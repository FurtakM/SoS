// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 36671 0 0
// InitNature ;
  19: CALL 36539 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 11799 0 0
// PrepareRussian ;
  40: CALL 7071 0 0
// PrepareLegion ;
  44: CALL 4242 0 0
// PreparePowell ;
  48: CALL 3044 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 15878 0 0
// MC_Start ( ) ;
  60: CALL 38843 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 123
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 124
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 61641 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 61734 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 61084 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 1
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 1
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 60899 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 61641 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 61734 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 60899 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 61084 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 61514 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 60581 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 61641 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 61734 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 128
 971: PUSH
 972: LD_EXP 128
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 60899 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 61641 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 61734 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 60791 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 62052 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 61223 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 61514 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 61514 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 61846 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 60899 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 61465 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 67335 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1900
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 72350 0 5
1898: GO 1959
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1900: LD_EXP 4
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 1
1911: ARRAY
1912: PPUSH
1913: LD_EXP 4
1917: PUSH
1918: LD_INT 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_EXP 4
1930: PUSH
1931: LD_INT 3
1933: ARRAY
1934: PUSH
1935: LD_INT 1
1937: ARRAY
1938: PPUSH
1939: LD_EXP 4
1943: PUSH
1944: LD_INT 4
1946: ARRAY
1947: PUSH
1948: LD_INT 1
1950: ARRAY
1951: PPUSH
1952: LD_INT 30
1954: PPUSH
1955: CALL 72350 0 5
// JMMNewVeh := CreateVehicle ;
1959: LD_ADDR_EXP 57
1963: PUSH
1964: CALL_OW 45
1968: ST_TO_ADDR
// if not JMMNewVeh then
1969: LD_EXP 57
1973: NOT
1974: IFFALSE 2005
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1976: LD_INT 5
1978: PPUSH
1979: LD_INT 3
1981: PPUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 9
1987: PPUSH
1988: LD_INT 100
1990: PPUSH
1991: CALL 72350 0 5
// JMMNewVeh := CreateVehicle ;
1995: LD_ADDR_EXP 57
1999: PUSH
2000: CALL_OW 45
2004: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2005: LD_EXP 57
2009: PPUSH
2010: LD_INT 4
2012: PPUSH
2013: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2017: LD_EXP 57
2021: PPUSH
2022: LD_INT 79
2024: PPUSH
2025: LD_INT 91
2027: PPUSH
2028: LD_INT 0
2030: PPUSH
2031: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2035: LD_EXP 40
2039: PPUSH
2040: LD_EXP 57
2044: PPUSH
2045: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2049: LD_EXP 6
2053: PUSH
2054: LD_EXP 2
2058: NOT
2059: AND
2060: IFFALSE 2318
// begin if not JMMGirlVeh then
2062: LD_EXP 5
2066: NOT
2067: IFFALSE 2090
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2069: LD_INT 3
2071: PPUSH
2072: LD_INT 3
2074: PPUSH
2075: LD_INT 1
2077: PPUSH
2078: LD_INT 9
2080: PPUSH
2081: LD_INT 100
2083: PPUSH
2084: CALL 72350 0 5
2088: GO 2149
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2090: LD_EXP 5
2094: PUSH
2095: LD_INT 1
2097: ARRAY
2098: PUSH
2099: LD_INT 1
2101: ARRAY
2102: PPUSH
2103: LD_EXP 5
2107: PUSH
2108: LD_INT 2
2110: ARRAY
2111: PUSH
2112: LD_INT 1
2114: ARRAY
2115: PPUSH
2116: LD_EXP 5
2120: PUSH
2121: LD_INT 3
2123: ARRAY
2124: PUSH
2125: LD_INT 1
2127: ARRAY
2128: PPUSH
2129: LD_EXP 5
2133: PUSH
2134: LD_INT 4
2136: ARRAY
2137: PUSH
2138: LD_INT 1
2140: ARRAY
2141: PPUSH
2142: LD_INT 30
2144: PPUSH
2145: CALL 72350 0 5
// GirlNewVeh := CreateVehicle ;
2149: LD_ADDR_EXP 58
2153: PUSH
2154: CALL_OW 45
2158: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2159: LD_EXP 58
2163: PPUSH
2164: LD_INT 4
2166: PPUSH
2167: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2171: LD_EXP 58
2175: PPUSH
2176: LD_INT 82
2178: PPUSH
2179: LD_INT 96
2181: PPUSH
2182: LD_INT 0
2184: PPUSH
2185: CALL_OW 48
// if JMMGirl = 1 then
2189: LD_EXP 7
2193: PUSH
2194: LD_INT 1
2196: EQUAL
2197: IFFALSE 2232
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2199: LD_ADDR_EXP 41
2203: PUSH
2204: LD_STRING Joan
2206: PPUSH
2207: LD_INT 1
2209: PPUSH
2210: LD_STRING 14_
2212: PPUSH
2213: CALL 67335 0 3
2217: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2218: LD_EXP 41
2222: PPUSH
2223: LD_EXP 58
2227: PPUSH
2228: CALL_OW 52
// end ; if JMMGirl = 2 then
2232: LD_EXP 7
2236: PUSH
2237: LD_INT 2
2239: EQUAL
2240: IFFALSE 2275
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2242: LD_ADDR_EXP 43
2246: PUSH
2247: LD_STRING Lisa
2249: PPUSH
2250: LD_INT 1
2252: PPUSH
2253: LD_STRING 14_
2255: PPUSH
2256: CALL 67335 0 3
2260: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2261: LD_EXP 43
2265: PPUSH
2266: LD_EXP 58
2270: PPUSH
2271: CALL_OW 52
// end ; if JMMGirl = 3 then
2275: LD_EXP 7
2279: PUSH
2280: LD_INT 3
2282: EQUAL
2283: IFFALSE 2318
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2285: LD_ADDR_EXP 55
2289: PUSH
2290: LD_STRING Connie
2292: PPUSH
2293: LD_INT 1
2295: PPUSH
2296: LD_STRING 14_
2298: PPUSH
2299: CALL 67335 0 3
2303: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2304: LD_EXP 55
2308: PPUSH
2309: LD_EXP 58
2313: PPUSH
2314: CALL_OW 52
// end ; end ; end ;
2318: LD_VAR 0 1
2322: RET
// export function PrepareStevensSquad ; var tmp ; begin
2323: LD_INT 0
2325: PPUSH
2326: PPUSH
// uc_side := 1 ;
2327: LD_ADDR_OWVAR 20
2331: PUSH
2332: LD_INT 1
2334: ST_TO_ADDR
// uc_nation := 1 ;
2335: LD_ADDR_OWVAR 21
2339: PUSH
2340: LD_INT 1
2342: ST_TO_ADDR
// tmp := [ ] ;
2343: LD_ADDR_VAR 0 2
2347: PUSH
2348: EMPTY
2349: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2350: LD_ADDR_EXP 42
2354: PUSH
2355: LD_STRING Stevens
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13f_
2366: PPUSH
2367: CALL 67335 0 3
2371: ST_TO_ADDR
// if not Stevens then
2372: LD_EXP 42
2376: NOT
2377: IFFALSE 2433
// begin hc_name = Baker Smith ;
2379: LD_ADDR_OWVAR 26
2383: PUSH
2384: LD_STRING Baker Smith
2386: ST_TO_ADDR
// hc_gallery =  ;
2387: LD_ADDR_OWVAR 33
2391: PUSH
2392: LD_STRING 
2394: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2395: LD_INT 1
2397: PPUSH
2398: LD_INT 10
2400: PPUSH
2401: CALL_OW 384
// Baker = CreateHuman ;
2405: LD_ADDR_EXP 56
2409: PUSH
2410: CALL_OW 44
2414: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2415: LD_ADDR_VAR 0 2
2419: PUSH
2420: LD_VAR 0 2
2424: PUSH
2425: LD_EXP 56
2429: ADD
2430: ST_TO_ADDR
// end else
2431: GO 2449
// tmp := tmp ^ Stevens ;
2433: LD_ADDR_VAR 0 2
2437: PUSH
2438: LD_VAR 0 2
2442: PUSH
2443: LD_EXP 42
2447: ADD
2448: ST_TO_ADDR
// if not Lisa then
2449: LD_EXP 43
2453: NOT
2454: IFFALSE 2500
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2456: LD_ADDR_EXP 43
2460: PUSH
2461: LD_STRING Lisa
2463: PPUSH
2464: LD_EXP 1
2468: NOT
2469: PPUSH
2470: LD_STRING 13f_
2472: PPUSH
2473: CALL 67335 0 3
2477: ST_TO_ADDR
// if Lisa then
2478: LD_EXP 43
2482: IFFALSE 2500
// tmp := tmp ^ Lisa ;
2484: LD_ADDR_VAR 0 2
2488: PUSH
2489: LD_VAR 0 2
2493: PUSH
2494: LD_EXP 43
2498: ADD
2499: ST_TO_ADDR
// end ; if not Donaldson then
2500: LD_EXP 44
2504: NOT
2505: IFFALSE 2551
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2507: LD_ADDR_EXP 44
2511: PUSH
2512: LD_STRING Donaldson
2514: PPUSH
2515: LD_EXP 1
2519: NOT
2520: PPUSH
2521: LD_STRING 13f_
2523: PPUSH
2524: CALL 67335 0 3
2528: ST_TO_ADDR
// if Donaldson then
2529: LD_EXP 44
2533: IFFALSE 2551
// tmp := tmp ^ Donaldson ;
2535: LD_ADDR_VAR 0 2
2539: PUSH
2540: LD_VAR 0 2
2544: PUSH
2545: LD_EXP 44
2549: ADD
2550: ST_TO_ADDR
// end ; if not Bobby then
2551: LD_EXP 45
2555: NOT
2556: IFFALSE 2602
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2558: LD_ADDR_EXP 45
2562: PUSH
2563: LD_STRING Bobby
2565: PPUSH
2566: LD_EXP 1
2570: NOT
2571: PPUSH
2572: LD_STRING 13f_
2574: PPUSH
2575: CALL 67335 0 3
2579: ST_TO_ADDR
// if Bobby then
2580: LD_EXP 45
2584: IFFALSE 2602
// tmp := tmp ^ Bobby ;
2586: LD_ADDR_VAR 0 2
2590: PUSH
2591: LD_VAR 0 2
2595: PUSH
2596: LD_EXP 45
2600: ADD
2601: ST_TO_ADDR
// end ; if not Cyrus then
2602: LD_EXP 46
2606: NOT
2607: IFFALSE 2653
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2609: LD_ADDR_EXP 46
2613: PUSH
2614: LD_STRING Cyrus
2616: PPUSH
2617: LD_EXP 1
2621: NOT
2622: PPUSH
2623: LD_STRING 13f_
2625: PPUSH
2626: CALL 67335 0 3
2630: ST_TO_ADDR
// if Cyrus then
2631: LD_EXP 46
2635: IFFALSE 2653
// tmp := tmp ^ Cyrus ;
2637: LD_ADDR_VAR 0 2
2641: PUSH
2642: LD_VAR 0 2
2646: PUSH
2647: LD_EXP 46
2651: ADD
2652: ST_TO_ADDR
// end ; if not Brown then
2653: LD_EXP 48
2657: NOT
2658: IFFALSE 2704
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2660: LD_ADDR_EXP 48
2664: PUSH
2665: LD_STRING Brown
2667: PPUSH
2668: LD_EXP 1
2672: NOT
2673: PPUSH
2674: LD_STRING 13f_
2676: PPUSH
2677: CALL 67335 0 3
2681: ST_TO_ADDR
// if Brown then
2682: LD_EXP 48
2686: IFFALSE 2704
// tmp := tmp ^ Brown ;
2688: LD_ADDR_VAR 0 2
2692: PUSH
2693: LD_VAR 0 2
2697: PUSH
2698: LD_EXP 48
2702: ADD
2703: ST_TO_ADDR
// end ; if not Gladstone then
2704: LD_EXP 49
2708: NOT
2709: IFFALSE 2755
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2711: LD_ADDR_EXP 49
2715: PUSH
2716: LD_STRING Gladstone
2718: PPUSH
2719: LD_EXP 1
2723: NOT
2724: PPUSH
2725: LD_STRING 13f_
2727: PPUSH
2728: CALL 67335 0 3
2732: ST_TO_ADDR
// if Gladstone then
2733: LD_EXP 49
2737: IFFALSE 2755
// tmp := tmp ^ Gladstone ;
2739: LD_ADDR_VAR 0 2
2743: PUSH
2744: LD_VAR 0 2
2748: PUSH
2749: LD_EXP 49
2753: ADD
2754: ST_TO_ADDR
// end ; if not Houten then
2755: LD_EXP 50
2759: NOT
2760: IFFALSE 2806
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2762: LD_ADDR_EXP 50
2766: PUSH
2767: LD_STRING Houten
2769: PPUSH
2770: LD_EXP 1
2774: NOT
2775: PPUSH
2776: LD_STRING 13f_
2778: PPUSH
2779: CALL 67335 0 3
2783: ST_TO_ADDR
// if Houten then
2784: LD_EXP 50
2788: IFFALSE 2806
// tmp := tmp ^ Houten ;
2790: LD_ADDR_VAR 0 2
2794: PUSH
2795: LD_VAR 0 2
2799: PUSH
2800: LD_EXP 50
2804: ADD
2805: ST_TO_ADDR
// end ; if not Cornel then
2806: LD_EXP 51
2810: NOT
2811: IFFALSE 2857
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2813: LD_ADDR_EXP 51
2817: PUSH
2818: LD_STRING Cornell
2820: PPUSH
2821: LD_EXP 1
2825: NOT
2826: PPUSH
2827: LD_STRING 13f_
2829: PPUSH
2830: CALL 67335 0 3
2834: ST_TO_ADDR
// if Cornel then
2835: LD_EXP 51
2839: IFFALSE 2857
// tmp := tmp ^ Cornel ;
2841: LD_ADDR_VAR 0 2
2845: PUSH
2846: LD_VAR 0 2
2850: PUSH
2851: LD_EXP 51
2855: ADD
2856: ST_TO_ADDR
// end ; if not Gary then
2857: LD_EXP 52
2861: NOT
2862: IFFALSE 2908
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2864: LD_ADDR_EXP 52
2868: PUSH
2869: LD_STRING Gary
2871: PPUSH
2872: LD_EXP 1
2876: NOT
2877: PPUSH
2878: LD_STRING 13f_
2880: PPUSH
2881: CALL 67335 0 3
2885: ST_TO_ADDR
// if Gary then
2886: LD_EXP 52
2890: IFFALSE 2908
// tmp := tmp ^ Gary ;
2892: LD_ADDR_VAR 0 2
2896: PUSH
2897: LD_VAR 0 2
2901: PUSH
2902: LD_EXP 52
2906: ADD
2907: ST_TO_ADDR
// end ; if not Frank then
2908: LD_EXP 53
2912: NOT
2913: IFFALSE 2959
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2915: LD_ADDR_EXP 53
2919: PUSH
2920: LD_STRING Frank
2922: PPUSH
2923: LD_EXP 1
2927: NOT
2928: PPUSH
2929: LD_STRING 13f_
2931: PPUSH
2932: CALL 67335 0 3
2936: ST_TO_ADDR
// if Frank then
2937: LD_EXP 53
2941: IFFALSE 2959
// tmp := tmp ^ Frank ;
2943: LD_ADDR_VAR 0 2
2947: PUSH
2948: LD_VAR 0 2
2952: PUSH
2953: LD_EXP 53
2957: ADD
2958: ST_TO_ADDR
// end ; if not Kikuchi then
2959: LD_EXP 54
2963: NOT
2964: IFFALSE 3010
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2966: LD_ADDR_EXP 54
2970: PUSH
2971: LD_STRING Kikuchi
2973: PPUSH
2974: LD_EXP 1
2978: NOT
2979: PPUSH
2980: LD_STRING 13f_
2982: PPUSH
2983: CALL 67335 0 3
2987: ST_TO_ADDR
// if Kikuchi then
2988: LD_EXP 54
2992: IFFALSE 3010
// tmp := tmp ^ Kikuchi ;
2994: LD_ADDR_VAR 0 2
2998: PUSH
2999: LD_VAR 0 2
3003: PUSH
3004: LD_EXP 54
3008: ADD
3009: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3010: LD_ADDR_VAR 0 2
3014: PUSH
3015: LD_VAR 0 2
3019: PUSH
3020: LD_STRING 13_other_survivors
3022: PPUSH
3023: CALL_OW 31
3027: UNION
3028: ST_TO_ADDR
// result := tmp ;
3029: LD_ADDR_VAR 0 1
3033: PUSH
3034: LD_VAR 0 2
3038: ST_TO_ADDR
// end ; end_of_file
3039: LD_VAR 0 1
3043: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3044: LD_INT 0
3046: PPUSH
3047: PPUSH
3048: PPUSH
3049: PPUSH
3050: PPUSH
3051: PPUSH
3052: PPUSH
3053: PPUSH
3054: PPUSH
3055: PPUSH
// uc_side := 4 ;
3056: LD_ADDR_OWVAR 20
3060: PUSH
3061: LD_INT 4
3063: ST_TO_ADDR
// uc_nation := 1 ;
3064: LD_ADDR_OWVAR 21
3068: PUSH
3069: LD_INT 1
3071: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3072: LD_INT 387
3074: PPUSH
3075: CALL_OW 274
3079: PPUSH
3080: LD_INT 1
3082: PPUSH
3083: LD_INT 3500
3085: PUSH
3086: LD_INT 3000
3088: PUSH
3089: LD_INT 2500
3091: PUSH
3092: LD_INT 2000
3094: PUSH
3095: EMPTY
3096: LIST
3097: LIST
3098: LIST
3099: LIST
3100: PUSH
3101: LD_OWVAR 67
3105: ARRAY
3106: PPUSH
3107: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3111: LD_INT 387
3113: PPUSH
3114: CALL_OW 274
3118: PPUSH
3119: LD_INT 2
3121: PPUSH
3122: LD_INT 400
3124: PPUSH
3125: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3129: LD_INT 387
3131: PPUSH
3132: CALL_OW 274
3136: PPUSH
3137: LD_INT 3
3139: PPUSH
3140: LD_INT 10
3142: PPUSH
3143: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3147: LD_ADDR_EXP 59
3151: PUSH
3152: LD_STRING Powell
3154: PPUSH
3155: CALL_OW 25
3159: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3160: LD_EXP 59
3164: PPUSH
3165: LD_INT 57
3167: PPUSH
3168: LD_INT 94
3170: PPUSH
3171: LD_INT 0
3173: PPUSH
3174: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3178: LD_EXP 59
3182: PPUSH
3183: LD_INT 58
3185: PPUSH
3186: LD_INT 94
3188: PPUSH
3189: CALL_OW 118
// vip := [ ] ;
3193: LD_ADDR_EXP 60
3197: PUSH
3198: EMPTY
3199: ST_TO_ADDR
// tmp := [ ] ;
3200: LD_ADDR_VAR 0 5
3204: PUSH
3205: EMPTY
3206: ST_TO_ADDR
// if JMMGirl <> 2 then
3207: LD_EXP 7
3211: PUSH
3212: LD_INT 2
3214: NONEQUAL
3215: IFFALSE 3239
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3217: LD_ADDR_EXP 43
3221: PUSH
3222: LD_STRING Lisa
3224: PPUSH
3225: LD_EXP 1
3229: NOT
3230: PPUSH
3231: LD_STRING 13s_
3233: PPUSH
3234: CALL 67335 0 3
3238: ST_TO_ADDR
// if Lisa then
3239: LD_EXP 43
3243: IFFALSE 3261
// tmp := tmp ^ Lisa ;
3245: LD_ADDR_VAR 0 5
3249: PUSH
3250: LD_VAR 0 5
3254: PUSH
3255: LD_EXP 43
3259: ADD
3260: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3261: LD_ADDR_EXP 44
3265: PUSH
3266: LD_STRING Donaldson
3268: PPUSH
3269: LD_EXP 1
3273: NOT
3274: PPUSH
3275: LD_STRING 13s_
3277: PPUSH
3278: CALL 67335 0 3
3282: ST_TO_ADDR
// if Donaldson then
3283: LD_EXP 44
3287: IFFALSE 3305
// tmp := tmp ^ Donaldson ;
3289: LD_ADDR_VAR 0 5
3293: PUSH
3294: LD_VAR 0 5
3298: PUSH
3299: LD_EXP 44
3303: ADD
3304: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3305: LD_ADDR_EXP 45
3309: PUSH
3310: LD_STRING Bobby
3312: PPUSH
3313: LD_EXP 1
3317: NOT
3318: PPUSH
3319: LD_STRING 13s_
3321: PPUSH
3322: CALL 67335 0 3
3326: ST_TO_ADDR
// if Bobby then
3327: LD_EXP 45
3331: IFFALSE 3349
// tmp := tmp ^ Bobby ;
3333: LD_ADDR_VAR 0 5
3337: PUSH
3338: LD_VAR 0 5
3342: PUSH
3343: LD_EXP 45
3347: ADD
3348: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3349: LD_ADDR_EXP 46
3353: PUSH
3354: LD_STRING Cyrus
3356: PPUSH
3357: LD_EXP 1
3361: NOT
3362: PPUSH
3363: LD_STRING 13s_
3365: PPUSH
3366: CALL 67335 0 3
3370: ST_TO_ADDR
// if Cyrus then
3371: LD_EXP 46
3375: IFFALSE 3393
// tmp := tmp ^ Cyrus ;
3377: LD_ADDR_VAR 0 5
3381: PUSH
3382: LD_VAR 0 5
3386: PUSH
3387: LD_EXP 46
3391: ADD
3392: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3393: LD_ADDR_EXP 47
3397: PUSH
3398: LD_STRING Denis
3400: PPUSH
3401: LD_EXP 1
3405: NOT
3406: PPUSH
3407: LD_STRING 13s_
3409: PPUSH
3410: CALL 67335 0 3
3414: ST_TO_ADDR
// if not Denis then
3415: LD_EXP 47
3419: NOT
3420: IFFALSE 3444
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3422: LD_ADDR_EXP 47
3426: PUSH
3427: LD_STRING Denis
3429: PPUSH
3430: LD_EXP 1
3434: NOT
3435: PPUSH
3436: LD_STRING 13f_
3438: PPUSH
3439: CALL 67335 0 3
3443: ST_TO_ADDR
// if Denis then
3444: LD_EXP 47
3448: IFFALSE 3466
// tmp := tmp ^ Denis ;
3450: LD_ADDR_VAR 0 5
3454: PUSH
3455: LD_VAR 0 5
3459: PUSH
3460: LD_EXP 47
3464: ADD
3465: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3466: LD_ADDR_EXP 48
3470: PUSH
3471: LD_STRING Brown
3473: PPUSH
3474: LD_EXP 1
3478: NOT
3479: PPUSH
3480: LD_STRING 13s_
3482: PPUSH
3483: CALL 67335 0 3
3487: ST_TO_ADDR
// if Brown then
3488: LD_EXP 48
3492: IFFALSE 3510
// tmp := tmp ^ Brown ;
3494: LD_ADDR_VAR 0 5
3498: PUSH
3499: LD_VAR 0 5
3503: PUSH
3504: LD_EXP 48
3508: ADD
3509: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3510: LD_ADDR_EXP 49
3514: PUSH
3515: LD_STRING Gladstone
3517: PPUSH
3518: LD_EXP 1
3522: NOT
3523: PPUSH
3524: LD_STRING 13s_
3526: PPUSH
3527: CALL 67335 0 3
3531: ST_TO_ADDR
// if Gladstone then
3532: LD_EXP 49
3536: IFFALSE 3554
// tmp := tmp ^ Gladstone ;
3538: LD_ADDR_VAR 0 5
3542: PUSH
3543: LD_VAR 0 5
3547: PUSH
3548: LD_EXP 49
3552: ADD
3553: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3554: LD_ADDR_EXP 50
3558: PUSH
3559: LD_STRING Houten
3561: PPUSH
3562: LD_EXP 1
3566: NOT
3567: PPUSH
3568: LD_STRING 13s_
3570: PPUSH
3571: CALL 67335 0 3
3575: ST_TO_ADDR
// if Houten then
3576: LD_EXP 50
3580: IFFALSE 3598
// tmp := tmp ^ Houten ;
3582: LD_ADDR_VAR 0 5
3586: PUSH
3587: LD_VAR 0 5
3591: PUSH
3592: LD_EXP 50
3596: ADD
3597: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3598: LD_ADDR_EXP 51
3602: PUSH
3603: LD_STRING Cornel
3605: PPUSH
3606: LD_EXP 1
3610: NOT
3611: PPUSH
3612: LD_STRING 13s_
3614: PPUSH
3615: CALL 67335 0 3
3619: ST_TO_ADDR
// if Cornel then
3620: LD_EXP 51
3624: IFFALSE 3642
// tmp := tmp ^ Cornel ;
3626: LD_ADDR_VAR 0 5
3630: PUSH
3631: LD_VAR 0 5
3635: PUSH
3636: LD_EXP 51
3640: ADD
3641: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3642: LD_ADDR_EXP 52
3646: PUSH
3647: LD_STRING Gary
3649: PPUSH
3650: LD_EXP 1
3654: NOT
3655: PPUSH
3656: LD_STRING 13s_
3658: PPUSH
3659: CALL 67335 0 3
3663: ST_TO_ADDR
// if Gary then
3664: LD_EXP 52
3668: IFFALSE 3686
// tmp := tmp ^ Gary ;
3670: LD_ADDR_VAR 0 5
3674: PUSH
3675: LD_VAR 0 5
3679: PUSH
3680: LD_EXP 52
3684: ADD
3685: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3686: LD_ADDR_EXP 53
3690: PUSH
3691: LD_STRING Frank
3693: PPUSH
3694: LD_EXP 1
3698: NOT
3699: PPUSH
3700: LD_STRING 13s_
3702: PPUSH
3703: CALL 67335 0 3
3707: ST_TO_ADDR
// if Frank then
3708: LD_EXP 53
3712: IFFALSE 3730
// tmp := tmp ^ Frank ;
3714: LD_ADDR_VAR 0 5
3718: PUSH
3719: LD_VAR 0 5
3723: PUSH
3724: LD_EXP 53
3728: ADD
3729: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3730: LD_ADDR_EXP 54
3734: PUSH
3735: LD_STRING Kikuchi
3737: PPUSH
3738: LD_EXP 1
3742: NOT
3743: PPUSH
3744: LD_STRING 13s_
3746: PPUSH
3747: CALL 67335 0 3
3751: ST_TO_ADDR
// if Kikuchi then
3752: LD_EXP 54
3756: IFFALSE 3774
// tmp := tmp ^ Kikuchi ;
3758: LD_ADDR_VAR 0 5
3762: PUSH
3763: LD_VAR 0 5
3767: PUSH
3768: LD_EXP 54
3772: ADD
3773: ST_TO_ADDR
// vip := tmp ;
3774: LD_ADDR_EXP 60
3778: PUSH
3779: LD_VAR 0 5
3783: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3784: LD_ADDR_VAR 0 5
3788: PUSH
3789: LD_VAR 0 5
3793: PUSH
3794: LD_STRING 13s_others
3796: PPUSH
3797: CALL_OW 31
3801: UNION
3802: ST_TO_ADDR
// if tmp < 18 then
3803: LD_VAR 0 5
3807: PUSH
3808: LD_INT 18
3810: LESS
3811: IFFALSE 3904
// for i = 1 to 18 - tmp do
3813: LD_ADDR_VAR 0 2
3817: PUSH
3818: DOUBLE
3819: LD_INT 1
3821: DEC
3822: ST_TO_ADDR
3823: LD_INT 18
3825: PUSH
3826: LD_VAR 0 5
3830: MINUS
3831: PUSH
3832: FOR_TO
3833: IFFALSE 3902
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
3835: LD_INT 1
3837: PPUSH
3838: LD_VAR 0 2
3842: PUSH
3843: LD_INT 4
3845: MOD
3846: PUSH
3847: LD_INT 1
3849: PLUS
3850: PPUSH
3851: LD_INT 4
3853: PPUSH
3854: CALL_OW 380
// un := CreateHuman ;
3858: LD_ADDR_VAR 0 10
3862: PUSH
3863: CALL_OW 44
3867: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
3868: LD_ADDR_VAR 0 5
3872: PUSH
3873: LD_VAR 0 5
3877: PPUSH
3878: LD_VAR 0 10
3882: PPUSH
3883: CALL 104784 0 2
3887: ST_TO_ADDR
// SetTag ( un , 1 ) ;
3888: LD_VAR 0 10
3892: PPUSH
3893: LD_INT 1
3895: PPUSH
3896: CALL_OW 109
// end ;
3900: GO 3832
3902: POP
3903: POP
// depot := HexInfo ( 53 , 94 ) ;
3904: LD_ADDR_VAR 0 6
3908: PUSH
3909: LD_INT 53
3911: PPUSH
3912: LD_INT 94
3914: PPUSH
3915: CALL_OW 428
3919: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
3920: LD_ADDR_VAR 0 7
3924: PUSH
3925: LD_INT 56
3927: PPUSH
3928: LD_INT 101
3930: PPUSH
3931: CALL_OW 428
3935: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
3936: LD_ADDR_VAR 0 8
3940: PUSH
3941: LD_INT 67
3943: PPUSH
3944: LD_INT 101
3946: PPUSH
3947: CALL_OW 428
3951: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
3952: LD_ADDR_VAR 0 9
3956: PUSH
3957: LD_INT 54
3959: PPUSH
3960: LD_INT 85
3962: PPUSH
3963: CALL_OW 428
3967: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
3968: LD_ADDR_VAR 0 3
3972: PUSH
3973: LD_VAR 0 8
3977: PUSH
3978: LD_VAR 0 6
3982: PUSH
3983: LD_VAR 0 9
3987: PUSH
3988: LD_VAR 0 7
3992: PUSH
3993: EMPTY
3994: LIST
3995: LIST
3996: LIST
3997: LIST
3998: ST_TO_ADDR
// for i in tmp do
3999: LD_ADDR_VAR 0 2
4003: PUSH
4004: LD_VAR 0 5
4008: PUSH
4009: FOR_IN
4010: IFFALSE 4098
// begin if UnitsInside ( b [ 1 ] ) = 6 then
4012: LD_VAR 0 3
4016: PUSH
4017: LD_INT 1
4019: ARRAY
4020: PPUSH
4021: CALL_OW 313
4025: PUSH
4026: LD_INT 6
4028: EQUAL
4029: IFFALSE 4049
// b := Delete ( b , 1 ) ;
4031: LD_ADDR_VAR 0 3
4035: PUSH
4036: LD_VAR 0 3
4040: PPUSH
4041: LD_INT 1
4043: PPUSH
4044: CALL_OW 3
4048: ST_TO_ADDR
// if b then
4049: LD_VAR 0 3
4053: IFFALSE 4075
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4055: LD_VAR 0 2
4059: PPUSH
4060: LD_VAR 0 3
4064: PUSH
4065: LD_INT 1
4067: ARRAY
4068: PPUSH
4069: CALL_OW 52
4073: GO 4096
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4075: LD_VAR 0 2
4079: PPUSH
4080: LD_INT 61
4082: PPUSH
4083: LD_INT 89
4085: PPUSH
4086: LD_INT 8
4088: PPUSH
4089: LD_INT 0
4091: PPUSH
4092: CALL_OW 50
// end ;
4096: GO 4009
4098: POP
4099: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4100: LD_INT 2
4102: PPUSH
4103: LD_INT 1
4105: PPUSH
4106: LD_INT 1
4108: PPUSH
4109: LD_INT 12
4111: PPUSH
4112: LD_INT 100
4114: PPUSH
4115: CALL 72350 0 5
// veh := CreateVehicle ;
4119: LD_ADDR_VAR 0 4
4123: PUSH
4124: CALL_OW 45
4128: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4129: LD_VAR 0 4
4133: PPUSH
4134: LD_INT 4
4136: PPUSH
4137: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4141: LD_VAR 0 4
4145: PPUSH
4146: LD_INT 49
4148: PPUSH
4149: LD_INT 88
4151: PPUSH
4152: LD_INT 0
4154: PPUSH
4155: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4159: LD_VAR 0 4
4163: PPUSH
4164: LD_INT 1
4166: PPUSH
4167: LD_INT 100
4169: PPUSH
4170: CALL_OW 290
// uc_side := 0 ;
4174: LD_ADDR_OWVAR 20
4178: PUSH
4179: LD_INT 0
4181: ST_TO_ADDR
// uc_nation := 0 ;
4182: LD_ADDR_OWVAR 21
4186: PUSH
4187: LD_INT 0
4189: ST_TO_ADDR
// for i := 1 to 3 do
4190: LD_ADDR_VAR 0 2
4194: PUSH
4195: DOUBLE
4196: LD_INT 1
4198: DEC
4199: ST_TO_ADDR
4200: LD_INT 3
4202: PUSH
4203: FOR_TO
4204: IFFALSE 4235
// begin InitHc ;
4206: CALL_OW 19
// hc_class := class_apeman ;
4210: LD_ADDR_OWVAR 28
4214: PUSH
4215: LD_INT 12
4217: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4218: CALL_OW 44
4222: PPUSH
4223: LD_INT 13
4225: PPUSH
4226: LD_INT 0
4228: PPUSH
4229: CALL_OW 49
// end ;
4233: GO 4203
4235: POP
4236: POP
// end ; end_of_file
4237: LD_VAR 0 1
4241: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4242: LD_INT 0
4244: PPUSH
4245: PPUSH
4246: PPUSH
4247: PPUSH
4248: PPUSH
// side := 8 ;
4249: LD_ADDR_VAR 0 3
4253: PUSH
4254: LD_INT 8
4256: ST_TO_ADDR
// uc_side := side ;
4257: LD_ADDR_OWVAR 20
4261: PUSH
4262: LD_VAR 0 3
4266: ST_TO_ADDR
// uc_nation := 2 ;
4267: LD_ADDR_OWVAR 21
4271: PUSH
4272: LD_INT 2
4274: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4275: LD_ADDR_VAR 0 2
4279: PUSH
4280: LD_INT 22
4282: PUSH
4283: LD_VAR 0 3
4287: PUSH
4288: EMPTY
4289: LIST
4290: LIST
4291: PUSH
4292: LD_INT 21
4294: PUSH
4295: LD_INT 3
4297: PUSH
4298: EMPTY
4299: LIST
4300: LIST
4301: PUSH
4302: EMPTY
4303: LIST
4304: LIST
4305: PPUSH
4306: CALL_OW 69
4310: PUSH
4311: FOR_IN
4312: IFFALSE 4328
// SetBLevel ( i , 10 ) ;
4314: LD_VAR 0 2
4318: PPUSH
4319: LD_INT 10
4321: PPUSH
4322: CALL_OW 241
4326: GO 4311
4328: POP
4329: POP
// if KurtStatus then
4330: LD_EXP 3
4334: IFFALSE 4357
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4336: LD_ADDR_EXP 61
4340: PUSH
4341: LD_STRING Kurt
4343: PPUSH
4344: LD_INT 0
4346: PPUSH
4347: LD_STRING 
4349: PPUSH
4350: CALL 67335 0 3
4354: ST_TO_ADDR
4355: GO 4379
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4357: LD_ADDR_EXP 61
4361: PUSH
4362: LD_STRING AltKurt
4364: PPUSH
4365: LD_EXP 1
4369: NOT
4370: PPUSH
4371: LD_STRING 
4373: PPUSH
4374: CALL 67335 0 3
4378: ST_TO_ADDR
// if not Kurt then
4379: LD_EXP 61
4383: NOT
4384: IFFALSE 4410
// begin InitHc ;
4386: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4390: LD_INT 1
4392: PPUSH
4393: LD_INT 10
4395: PPUSH
4396: CALL_OW 381
// Kurt := CreateHuman ;
4400: LD_ADDR_EXP 61
4404: PUSH
4405: CALL_OW 44
4409: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4410: LD_EXP 61
4414: PPUSH
4415: LD_INT 324
4417: PPUSH
4418: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4422: LD_ADDR_EXP 62
4426: PUSH
4427: LD_STRING Kozlov
4429: PPUSH
4430: LD_INT 0
4432: PPUSH
4433: LD_STRING 
4435: PPUSH
4436: CALL 67335 0 3
4440: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4441: LD_EXP 62
4445: PPUSH
4446: LD_INT 22
4448: PUSH
4449: LD_INT 8
4451: PUSH
4452: EMPTY
4453: LIST
4454: LIST
4455: PUSH
4456: LD_INT 23
4458: PUSH
4459: LD_INT 3
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: PUSH
4466: LD_INT 30
4468: PUSH
4469: LD_INT 8
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: PUSH
4476: EMPTY
4477: LIST
4478: LIST
4479: LIST
4480: PPUSH
4481: CALL_OW 69
4485: PUSH
4486: LD_INT 1
4488: ARRAY
4489: PPUSH
4490: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4494: LD_EXP 62
4498: PPUSH
4499: LD_INT 3
4501: PPUSH
4502: LD_INT 10
4504: PPUSH
4505: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4509: LD_EXP 62
4513: PPUSH
4514: LD_INT 4
4516: PPUSH
4517: LD_INT 10
4519: PPUSH
4520: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4524: LD_ADDR_VAR 0 5
4528: PUSH
4529: LD_INT 22
4531: PUSH
4532: LD_VAR 0 3
4536: PUSH
4537: EMPTY
4538: LIST
4539: LIST
4540: PUSH
4541: LD_INT 30
4543: PUSH
4544: LD_INT 32
4546: PUSH
4547: EMPTY
4548: LIST
4549: LIST
4550: PUSH
4551: LD_INT 58
4553: PUSH
4554: EMPTY
4555: LIST
4556: PUSH
4557: EMPTY
4558: LIST
4559: LIST
4560: LIST
4561: PPUSH
4562: CALL_OW 69
4566: ST_TO_ADDR
// for i = 1 to 10 do
4567: LD_ADDR_VAR 0 2
4571: PUSH
4572: DOUBLE
4573: LD_INT 1
4575: DEC
4576: ST_TO_ADDR
4577: LD_INT 10
4579: PUSH
4580: FOR_TO
4581: IFFALSE 4653
// begin uc_nation := nation_nature ;
4583: LD_ADDR_OWVAR 21
4587: PUSH
4588: LD_INT 0
4590: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4591: LD_ADDR_OWVAR 28
4595: PUSH
4596: LD_INT 15
4598: ST_TO_ADDR
// hc_gallery :=  ;
4599: LD_ADDR_OWVAR 33
4603: PUSH
4604: LD_STRING 
4606: ST_TO_ADDR
// hc_name :=  ;
4607: LD_ADDR_OWVAR 26
4611: PUSH
4612: LD_STRING 
4614: ST_TO_ADDR
// un := CreateHuman ;
4615: LD_ADDR_VAR 0 4
4619: PUSH
4620: CALL_OW 44
4624: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4625: LD_VAR 0 4
4629: PPUSH
4630: LD_VAR 0 5
4634: PUSH
4635: LD_VAR 0 5
4639: PUSH
4640: LD_VAR 0 2
4644: MINUS
4645: ARRAY
4646: PPUSH
4647: CALL_OW 52
// end ;
4651: GO 4580
4653: POP
4654: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4655: LD_ADDR_VAR 0 5
4659: PUSH
4660: LD_STRING 12_kurt_squad
4662: PPUSH
4663: CALL_OW 31
4667: ST_TO_ADDR
// if tmp then
4668: LD_VAR 0 5
4672: IFFALSE 4706
// for i in tmp do
4674: LD_ADDR_VAR 0 2
4678: PUSH
4679: LD_VAR 0 5
4683: PUSH
4684: FOR_IN
4685: IFFALSE 4704
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4687: LD_VAR 0 2
4691: PPUSH
4692: LD_INT 5
4694: PPUSH
4695: LD_INT 0
4697: PPUSH
4698: CALL_OW 49
4702: GO 4684
4704: POP
4705: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4706: LD_INT 324
4708: PPUSH
4709: LD_INT 5
4711: PPUSH
4712: LD_STRING 
4714: PPUSH
4715: LD_INT 8
4717: PUSH
4718: LD_INT 9
4720: PUSH
4721: LD_INT 10
4723: PUSH
4724: LD_INT 10
4726: PUSH
4727: EMPTY
4728: LIST
4729: LIST
4730: LIST
4731: LIST
4732: PUSH
4733: LD_OWVAR 67
4737: ARRAY
4738: PPUSH
4739: LD_INT 3000
4741: PUSH
4742: LD_INT 500
4744: PUSH
4745: LD_INT 150
4747: PUSH
4748: EMPTY
4749: LIST
4750: LIST
4751: LIST
4752: PPUSH
4753: LD_INT 16
4755: PUSH
4756: LD_INT 6
4758: PUSH
4759: LD_INT 6
4761: PUSH
4762: LD_INT 8
4764: PUSH
4765: EMPTY
4766: LIST
4767: LIST
4768: LIST
4769: LIST
4770: PPUSH
4771: CALL 75794 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4775: LD_ADDR_EXP 99
4779: PUSH
4780: LD_EXP 99
4784: PPUSH
4785: LD_INT 3
4787: PPUSH
4788: LD_INT 22
4790: PUSH
4791: LD_VAR 0 3
4795: PUSH
4796: EMPTY
4797: LIST
4798: LIST
4799: PUSH
4800: LD_INT 23
4802: PUSH
4803: LD_INT 2
4805: PUSH
4806: EMPTY
4807: LIST
4808: LIST
4809: PUSH
4810: LD_INT 3
4812: PUSH
4813: LD_INT 21
4815: PUSH
4816: LD_INT 2
4818: PUSH
4819: EMPTY
4820: LIST
4821: LIST
4822: PUSH
4823: EMPTY
4824: LIST
4825: LIST
4826: PUSH
4827: EMPTY
4828: LIST
4829: LIST
4830: LIST
4831: PPUSH
4832: CALL_OW 69
4836: PUSH
4837: LD_EXP 61
4841: DIFF
4842: PPUSH
4843: CALL_OW 1
4847: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4848: LD_INT 1
4850: PPUSH
4851: LD_INT 7
4853: PPUSH
4854: CALL_OW 383
// Friend := CreateHuman ;
4858: LD_ADDR_EXP 63
4862: PUSH
4863: CALL_OW 44
4867: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4868: LD_INT 14
4870: PPUSH
4871: LD_INT 3
4873: PPUSH
4874: LD_INT 1
4876: PPUSH
4877: LD_INT 29
4879: PPUSH
4880: LD_INT 100
4882: PPUSH
4883: CALL 72350 0 5
// powellBomb := CreateVehicle ;
4887: LD_ADDR_EXP 64
4891: PUSH
4892: CALL_OW 45
4896: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4897: LD_EXP 64
4901: PPUSH
4902: LD_INT 90
4904: PPUSH
4905: LD_INT 51
4907: PPUSH
4908: LD_INT 0
4910: PPUSH
4911: CALL_OW 48
// end ;
4915: LD_VAR 0 1
4919: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4920: LD_INT 0
4922: PPUSH
4923: PPUSH
4924: PPUSH
// if IsLive ( kozlov_fac ) then
4925: LD_INT 332
4927: PPUSH
4928: CALL_OW 300
4932: IFFALSE 4936
// exit ;
4934: GO 5503
// ComExitBuilding ( Kozlov ) ;
4936: LD_EXP 62
4940: PPUSH
4941: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4945: LD_EXP 62
4949: PPUSH
4950: CALL_OW 257
4954: PUSH
4955: LD_INT 2
4957: NONEQUAL
4958: IFFALSE 4993
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4960: LD_EXP 62
4964: PPUSH
4965: LD_INT 324
4967: PPUSH
4968: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4972: LD_EXP 62
4976: PPUSH
4977: LD_INT 2
4979: PPUSH
4980: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4984: LD_EXP 62
4988: PPUSH
4989: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4993: LD_EXP 62
4997: PPUSH
4998: LD_INT 2
5000: PPUSH
5001: LD_INT 93
5003: PPUSH
5004: LD_INT 32
5006: PPUSH
5007: LD_INT 3
5009: PPUSH
5010: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5014: LD_INT 35
5016: PPUSH
5017: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5021: LD_INT 22
5023: PUSH
5024: LD_INT 8
5026: PUSH
5027: EMPTY
5028: LIST
5029: LIST
5030: PUSH
5031: LD_INT 30
5033: PUSH
5034: LD_INT 3
5036: PUSH
5037: EMPTY
5038: LIST
5039: LIST
5040: PUSH
5041: LD_INT 23
5043: PUSH
5044: LD_INT 3
5046: PUSH
5047: EMPTY
5048: LIST
5049: LIST
5050: PUSH
5051: LD_INT 57
5053: PUSH
5054: EMPTY
5055: LIST
5056: PUSH
5057: EMPTY
5058: LIST
5059: LIST
5060: LIST
5061: LIST
5062: PPUSH
5063: CALL_OW 69
5067: IFFALSE 5014
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5069: LD_ADDR_VAR 0 2
5073: PUSH
5074: LD_INT 22
5076: PUSH
5077: LD_INT 8
5079: PUSH
5080: EMPTY
5081: LIST
5082: LIST
5083: PUSH
5084: LD_INT 30
5086: PUSH
5087: LD_INT 3
5089: PUSH
5090: EMPTY
5091: LIST
5092: LIST
5093: PUSH
5094: LD_INT 23
5096: PUSH
5097: LD_INT 3
5099: PUSH
5100: EMPTY
5101: LIST
5102: LIST
5103: PUSH
5104: LD_INT 57
5106: PUSH
5107: EMPTY
5108: LIST
5109: PUSH
5110: EMPTY
5111: LIST
5112: LIST
5113: LIST
5114: LIST
5115: PPUSH
5116: CALL_OW 69
5120: PUSH
5121: LD_INT 1
5123: ARRAY
5124: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5125: LD_INT 22
5127: PUSH
5128: LD_INT 8
5130: PUSH
5131: EMPTY
5132: LIST
5133: LIST
5134: PUSH
5135: LD_INT 23
5137: PUSH
5138: LD_INT 3
5140: PUSH
5141: EMPTY
5142: LIST
5143: LIST
5144: PUSH
5145: LD_INT 30
5147: PUSH
5148: LD_INT 21
5150: PUSH
5151: EMPTY
5152: LIST
5153: LIST
5154: PUSH
5155: EMPTY
5156: LIST
5157: LIST
5158: LIST
5159: PPUSH
5160: CALL_OW 69
5164: NOT
5165: IFFALSE 5243
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5167: LD_EXP 62
5171: PPUSH
5172: LD_INT 21
5174: PPUSH
5175: LD_INT 97
5177: PPUSH
5178: LD_INT 36
5180: PPUSH
5181: LD_INT 5
5183: PPUSH
5184: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5188: LD_INT 35
5190: PPUSH
5191: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5195: LD_INT 22
5197: PUSH
5198: LD_INT 8
5200: PUSH
5201: EMPTY
5202: LIST
5203: LIST
5204: PUSH
5205: LD_INT 23
5207: PUSH
5208: LD_INT 3
5210: PUSH
5211: EMPTY
5212: LIST
5213: LIST
5214: PUSH
5215: LD_INT 30
5217: PUSH
5218: LD_INT 21
5220: PUSH
5221: EMPTY
5222: LIST
5223: LIST
5224: PUSH
5225: LD_INT 57
5227: PUSH
5228: EMPTY
5229: LIST
5230: PUSH
5231: EMPTY
5232: LIST
5233: LIST
5234: LIST
5235: LIST
5236: PPUSH
5237: CALL_OW 69
5241: IFFALSE 5188
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5243: LD_INT 22
5245: PUSH
5246: LD_INT 8
5248: PUSH
5249: EMPTY
5250: LIST
5251: LIST
5252: PUSH
5253: LD_INT 23
5255: PUSH
5256: LD_INT 3
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: PUSH
5263: LD_INT 30
5265: PUSH
5266: LD_INT 18
5268: PUSH
5269: EMPTY
5270: LIST
5271: LIST
5272: PUSH
5273: EMPTY
5274: LIST
5275: LIST
5276: LIST
5277: PPUSH
5278: CALL_OW 69
5282: NOT
5283: IFFALSE 5361
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5285: LD_EXP 62
5289: PPUSH
5290: LD_INT 18
5292: PPUSH
5293: LD_INT 89
5295: PPUSH
5296: LD_INT 32
5298: PPUSH
5299: LD_INT 1
5301: PPUSH
5302: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5306: LD_INT 35
5308: PPUSH
5309: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5313: LD_INT 22
5315: PUSH
5316: LD_INT 8
5318: PUSH
5319: EMPTY
5320: LIST
5321: LIST
5322: PUSH
5323: LD_INT 23
5325: PUSH
5326: LD_INT 3
5328: PUSH
5329: EMPTY
5330: LIST
5331: LIST
5332: PUSH
5333: LD_INT 30
5335: PUSH
5336: LD_INT 18
5338: PUSH
5339: EMPTY
5340: LIST
5341: LIST
5342: PUSH
5343: LD_INT 57
5345: PUSH
5346: EMPTY
5347: LIST
5348: PUSH
5349: EMPTY
5350: LIST
5351: LIST
5352: LIST
5353: LIST
5354: PPUSH
5355: CALL_OW 69
5359: IFFALSE 5306
// end ; lab := kozlov_lab ;
5361: LD_ADDR_VAR 0 3
5365: PUSH
5366: LD_INT 336
5368: ST_TO_ADDR
// if not lab then
5369: LD_VAR 0 3
5373: NOT
5374: IFFALSE 5378
// exit ;
5376: GO 5503
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5378: LD_EXP 62
5382: PPUSH
5383: LD_VAR 0 3
5387: PUSH
5388: LD_INT 1
5390: ARRAY
5391: PPUSH
5392: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5396: LD_EXP 62
5400: PPUSH
5401: LD_INT 4
5403: PPUSH
5404: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5408: LD_VAR 0 3
5412: PUSH
5413: LD_INT 1
5415: ARRAY
5416: PPUSH
5417: LD_INT 25
5419: PPUSH
5420: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5424: LD_INT 35
5426: PPUSH
5427: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5431: LD_INT 25
5433: PPUSH
5434: LD_INT 8
5436: PPUSH
5437: CALL_OW 321
5441: PUSH
5442: LD_INT 2
5444: EQUAL
5445: IFFALSE 5424
// ComExitBuilding ( Kozlov ) ;
5447: LD_EXP 62
5451: PPUSH
5452: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5456: LD_EXP 62
5460: PPUSH
5461: LD_VAR 0 2
5465: PPUSH
5466: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5470: LD_EXP 62
5474: PPUSH
5475: LD_INT 3
5477: PPUSH
5478: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5482: LD_VAR 0 2
5486: PPUSH
5487: LD_INT 23
5489: PPUSH
5490: LD_INT 3
5492: PPUSH
5493: LD_INT 1
5495: PPUSH
5496: LD_INT 48
5498: PPUSH
5499: CALL_OW 125
// end ;
5503: LD_VAR 0 1
5507: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5508: LD_EXP 22
5512: NOT
5513: PUSH
5514: LD_EXP 15
5518: PUSH
5519: LD_INT 6
5521: GREATEREQUAL
5522: AND
5523: IFFALSE 5604
5525: GO 5527
5527: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5528: LD_INT 3
5530: PPUSH
5531: LD_INT 3
5533: PPUSH
5534: CALL 61084 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5538: LD_INT 3
5540: PPUSH
5541: LD_INT 14
5543: PUSH
5544: LD_INT 1
5546: PUSH
5547: LD_INT 1
5549: PUSH
5550: LD_INT 28
5552: PUSH
5553: EMPTY
5554: LIST
5555: LIST
5556: LIST
5557: LIST
5558: PUSH
5559: LD_INT 14
5561: PUSH
5562: LD_INT 1
5564: PUSH
5565: LD_INT 1
5567: PUSH
5568: LD_INT 28
5570: PUSH
5571: EMPTY
5572: LIST
5573: LIST
5574: LIST
5575: LIST
5576: PUSH
5577: LD_INT 14
5579: PUSH
5580: LD_INT 1
5582: PUSH
5583: LD_INT 1
5585: PUSH
5586: LD_INT 28
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: LIST
5593: LIST
5594: PUSH
5595: EMPTY
5596: LIST
5597: LIST
5598: LIST
5599: PPUSH
5600: CALL 60947 0 2
// end ;
5604: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5605: LD_EXP 22
5609: NOT
5610: PUSH
5611: LD_EXP 15
5615: PUSH
5616: LD_INT 6
5618: GREATEREQUAL
5619: AND
5620: PUSH
5621: LD_INT 3
5623: PPUSH
5624: LD_INT 1
5626: PPUSH
5627: CALL 62365 0 2
5631: NOT
5632: AND
5633: IFFALSE 6507
5635: GO 5637
5637: DISABLE
5638: LD_INT 0
5640: PPUSH
5641: PPUSH
5642: PPUSH
// begin enable ;
5643: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5644: LD_INT 22
5646: PUSH
5647: LD_INT 8
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: PUSH
5654: LD_INT 23
5656: PUSH
5657: LD_INT 2
5659: PUSH
5660: EMPTY
5661: LIST
5662: LIST
5663: PUSH
5664: LD_INT 30
5666: PUSH
5667: LD_INT 3
5669: PUSH
5670: EMPTY
5671: LIST
5672: LIST
5673: PUSH
5674: EMPTY
5675: LIST
5676: LIST
5677: LIST
5678: PPUSH
5679: CALL_OW 69
5683: NOT
5684: IFFALSE 5688
// exit ;
5686: GO 6507
// if Prob ( 40 ) then
5688: LD_INT 40
5690: PPUSH
5691: CALL_OW 13
5695: IFFALSE 5822
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5697: LD_INT 3
5699: PPUSH
5700: LD_INT 14
5702: PUSH
5703: LD_INT 1
5705: PUSH
5706: LD_INT 2
5708: PUSH
5709: LD_INT 28
5711: PUSH
5712: EMPTY
5713: LIST
5714: LIST
5715: LIST
5716: LIST
5717: PUSH
5718: LD_INT 14
5720: PUSH
5721: LD_INT 1
5723: PUSH
5724: LD_INT 2
5726: PUSH
5727: LD_INT 28
5729: PUSH
5730: EMPTY
5731: LIST
5732: LIST
5733: LIST
5734: LIST
5735: PUSH
5736: LD_INT 14
5738: PUSH
5739: LD_INT 1
5741: PUSH
5742: LD_INT 2
5744: PUSH
5745: LD_INT 28
5747: PUSH
5748: EMPTY
5749: LIST
5750: LIST
5751: LIST
5752: LIST
5753: PUSH
5754: LD_INT 14
5756: PUSH
5757: LD_INT 1
5759: PUSH
5760: LD_INT 2
5762: PUSH
5763: LD_INT 28
5765: PUSH
5766: EMPTY
5767: LIST
5768: LIST
5769: LIST
5770: LIST
5771: PUSH
5772: LD_INT 14
5774: PUSH
5775: LD_INT 1
5777: PUSH
5778: LD_INT 2
5780: PUSH
5781: LD_INT 28
5783: PUSH
5784: EMPTY
5785: LIST
5786: LIST
5787: LIST
5788: LIST
5789: PUSH
5790: LD_INT 14
5792: PUSH
5793: LD_INT 1
5795: PUSH
5796: LD_INT 2
5798: PUSH
5799: LD_INT 26
5801: PUSH
5802: EMPTY
5803: LIST
5804: LIST
5805: LIST
5806: LIST
5807: PUSH
5808: EMPTY
5809: LIST
5810: LIST
5811: LIST
5812: LIST
5813: LIST
5814: LIST
5815: PPUSH
5816: CALL 60947 0 2
// end else
5820: GO 6029
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5822: LD_INT 3
5824: PPUSH
5825: LD_INT 14
5827: PUSH
5828: LD_INT 1
5830: PUSH
5831: LD_INT 2
5833: PUSH
5834: LD_INT 27
5836: PUSH
5837: LD_INT 26
5839: PUSH
5840: LD_INT 26
5842: PUSH
5843: LD_INT 28
5845: PUSH
5846: EMPTY
5847: LIST
5848: LIST
5849: LIST
5850: LIST
5851: PUSH
5852: LD_OWVAR 67
5856: ARRAY
5857: PUSH
5858: EMPTY
5859: LIST
5860: LIST
5861: LIST
5862: LIST
5863: PUSH
5864: LD_INT 14
5866: PUSH
5867: LD_INT 1
5869: PUSH
5870: LD_INT 2
5872: PUSH
5873: LD_INT 27
5875: PUSH
5876: LD_INT 26
5878: PUSH
5879: LD_INT 26
5881: PUSH
5882: LD_INT 26
5884: PUSH
5885: EMPTY
5886: LIST
5887: LIST
5888: LIST
5889: LIST
5890: PUSH
5891: LD_OWVAR 67
5895: ARRAY
5896: PUSH
5897: EMPTY
5898: LIST
5899: LIST
5900: LIST
5901: LIST
5902: PUSH
5903: LD_INT 14
5905: PUSH
5906: LD_INT 1
5908: PUSH
5909: LD_INT 2
5911: PUSH
5912: LD_INT 26
5914: PUSH
5915: LD_INT 26
5917: PUSH
5918: LD_INT 29
5920: PUSH
5921: LD_INT 29
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: LIST
5928: LIST
5929: PUSH
5930: LD_OWVAR 67
5934: ARRAY
5935: PUSH
5936: EMPTY
5937: LIST
5938: LIST
5939: LIST
5940: LIST
5941: PUSH
5942: LD_INT 13
5944: PUSH
5945: LD_INT 1
5947: PUSH
5948: LD_INT 2
5950: PUSH
5951: LD_INT 26
5953: PUSH
5954: LD_INT 29
5956: PUSH
5957: LD_INT 29
5959: PUSH
5960: LD_INT 29
5962: PUSH
5963: EMPTY
5964: LIST
5965: LIST
5966: LIST
5967: LIST
5968: PUSH
5969: LD_OWVAR 67
5973: ARRAY
5974: PUSH
5975: EMPTY
5976: LIST
5977: LIST
5978: LIST
5979: LIST
5980: PUSH
5981: LD_INT 13
5983: PUSH
5984: LD_INT 1
5986: PUSH
5987: LD_INT 2
5989: PUSH
5990: LD_INT 29
5992: PUSH
5993: EMPTY
5994: LIST
5995: LIST
5996: LIST
5997: LIST
5998: PUSH
5999: LD_INT 14
6001: PUSH
6002: LD_INT 1
6004: PUSH
6005: LD_INT 2
6007: PUSH
6008: LD_INT 26
6010: PUSH
6011: EMPTY
6012: LIST
6013: LIST
6014: LIST
6015: LIST
6016: PUSH
6017: EMPTY
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: LIST
6023: LIST
6024: PPUSH
6025: CALL 60947 0 2
// end ; repeat wait ( 0 0$1 ) ;
6029: LD_INT 35
6031: PPUSH
6032: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
6036: LD_INT 3
6038: PPUSH
6039: LD_INT 1
6041: PPUSH
6042: CALL 62365 0 2
6046: PUSH
6047: LD_INT 6
6049: GREATEREQUAL
6050: IFFALSE 6029
// wait ( 0 0$30 ) ;
6052: LD_INT 1050
6054: PPUSH
6055: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6059: LD_ADDR_VAR 0 2
6063: PUSH
6064: LD_INT 3
6066: PPUSH
6067: LD_INT 1
6069: PPUSH
6070: CALL 62365 0 2
6074: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6075: LD_ADDR_EXP 118
6079: PUSH
6080: LD_EXP 118
6084: PPUSH
6085: LD_INT 3
6087: PPUSH
6088: LD_EXP 118
6092: PUSH
6093: LD_INT 3
6095: ARRAY
6096: PUSH
6097: LD_VAR 0 2
6101: DIFF
6102: PPUSH
6103: CALL_OW 1
6107: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6108: LD_ADDR_VAR 0 3
6112: PUSH
6113: LD_INT 0
6115: PPUSH
6116: LD_INT 2
6118: PPUSH
6119: CALL_OW 12
6123: ST_TO_ADDR
// if target then
6124: LD_VAR 0 3
6128: IFFALSE 6265
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6130: LD_ADDR_VAR 0 2
6134: PUSH
6135: LD_VAR 0 2
6139: PPUSH
6140: LD_INT 24
6142: PUSH
6143: LD_INT 250
6145: PUSH
6146: EMPTY
6147: LIST
6148: LIST
6149: PPUSH
6150: CALL_OW 72
6154: ST_TO_ADDR
// if not tmp then
6155: LD_VAR 0 2
6159: NOT
6160: IFFALSE 6164
// break ;
6162: GO 6263
// for i in tmp do
6164: LD_ADDR_VAR 0 1
6168: PUSH
6169: LD_VAR 0 2
6173: PUSH
6174: FOR_IN
6175: IFFALSE 6215
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6177: LD_VAR 0 1
6181: PPUSH
6182: LD_INT 89
6184: PPUSH
6185: LD_INT 71
6187: PPUSH
6188: CALL_OW 297
6192: PUSH
6193: LD_INT 9
6195: GREATER
6196: IFFALSE 6213
// ComMoveXY ( i , 89 , 71 ) ;
6198: LD_VAR 0 1
6202: PPUSH
6203: LD_INT 89
6205: PPUSH
6206: LD_INT 71
6208: PPUSH
6209: CALL_OW 111
6213: GO 6174
6215: POP
6216: POP
// wait ( 0 0$1 ) ;
6217: LD_INT 35
6219: PPUSH
6220: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6224: LD_VAR 0 2
6228: PPUSH
6229: LD_INT 92
6231: PUSH
6232: LD_INT 89
6234: PUSH
6235: LD_INT 71
6237: PUSH
6238: LD_INT 9
6240: PUSH
6241: EMPTY
6242: LIST
6243: LIST
6244: LIST
6245: LIST
6246: PPUSH
6247: CALL_OW 72
6251: PUSH
6252: LD_VAR 0 2
6256: PUSH
6257: LD_INT 1
6259: MINUS
6260: GREATEREQUAL
6261: IFFALSE 6130
// end else
6263: GO 6398
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6265: LD_ADDR_VAR 0 2
6269: PUSH
6270: LD_VAR 0 2
6274: PPUSH
6275: LD_INT 24
6277: PUSH
6278: LD_INT 250
6280: PUSH
6281: EMPTY
6282: LIST
6283: LIST
6284: PPUSH
6285: CALL_OW 72
6289: ST_TO_ADDR
// if not tmp then
6290: LD_VAR 0 2
6294: NOT
6295: IFFALSE 6299
// break ;
6297: GO 6398
// for i in tmp do
6299: LD_ADDR_VAR 0 1
6303: PUSH
6304: LD_VAR 0 2
6308: PUSH
6309: FOR_IN
6310: IFFALSE 6350
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6312: LD_VAR 0 1
6316: PPUSH
6317: LD_INT 125
6319: PPUSH
6320: LD_INT 129
6322: PPUSH
6323: CALL_OW 297
6327: PUSH
6328: LD_INT 9
6330: GREATER
6331: IFFALSE 6348
// ComMoveXY ( i , 125 , 129 ) ;
6333: LD_VAR 0 1
6337: PPUSH
6338: LD_INT 125
6340: PPUSH
6341: LD_INT 129
6343: PPUSH
6344: CALL_OW 111
6348: GO 6309
6350: POP
6351: POP
// wait ( 0 0$1 ) ;
6352: LD_INT 35
6354: PPUSH
6355: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6359: LD_VAR 0 2
6363: PPUSH
6364: LD_INT 92
6366: PUSH
6367: LD_INT 125
6369: PUSH
6370: LD_INT 129
6372: PUSH
6373: LD_INT 9
6375: PUSH
6376: EMPTY
6377: LIST
6378: LIST
6379: LIST
6380: LIST
6381: PPUSH
6382: CALL_OW 72
6386: PUSH
6387: LD_VAR 0 2
6391: PUSH
6392: LD_INT 1
6394: MINUS
6395: GREATEREQUAL
6396: IFFALSE 6265
// end ; repeat wait ( 0 0$1 ) ;
6398: LD_INT 35
6400: PPUSH
6401: CALL_OW 67
// for i in tmp do
6405: LD_ADDR_VAR 0 1
6409: PUSH
6410: LD_VAR 0 2
6414: PUSH
6415: FOR_IN
6416: IFFALSE 6498
// begin if GetLives ( i ) > 251 then
6418: LD_VAR 0 1
6422: PPUSH
6423: CALL_OW 256
6427: PUSH
6428: LD_INT 251
6430: GREATER
6431: IFFALSE 6469
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6433: LD_VAR 0 1
6437: PPUSH
6438: LD_INT 81
6440: PUSH
6441: LD_INT 8
6443: PUSH
6444: EMPTY
6445: LIST
6446: LIST
6447: PPUSH
6448: CALL_OW 69
6452: PPUSH
6453: LD_VAR 0 1
6457: PPUSH
6458: CALL_OW 74
6462: PPUSH
6463: CALL_OW 115
6467: GO 6496
// if IsDead ( i ) then
6469: LD_VAR 0 1
6473: PPUSH
6474: CALL_OW 301
6478: IFFALSE 6496
// tmp := tmp diff i ;
6480: LD_ADDR_VAR 0 2
6484: PUSH
6485: LD_VAR 0 2
6489: PUSH
6490: LD_VAR 0 1
6494: DIFF
6495: ST_TO_ADDR
// end ;
6496: GO 6415
6498: POP
6499: POP
// until not tmp ;
6500: LD_VAR 0 2
6504: NOT
6505: IFFALSE 6398
// end ;
6507: PPOPN 3
6509: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6510: LD_EXP 22
6514: NOT
6515: PUSH
6516: LD_EXP 15
6520: PUSH
6521: LD_INT 6
6523: GREATEREQUAL
6524: AND
6525: PUSH
6526: LD_OWVAR 67
6530: PUSH
6531: LD_INT 1
6533: GREATER
6534: AND
6535: IFFALSE 7068
6537: GO 6539
6539: DISABLE
6540: LD_INT 0
6542: PPUSH
6543: PPUSH
6544: PPUSH
// begin enable ;
6545: ENABLE
// tmp := [ ] ;
6546: LD_ADDR_VAR 0 3
6550: PUSH
6551: EMPTY
6552: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6553: LD_ADDR_VAR 0 1
6557: PUSH
6558: DOUBLE
6559: LD_INT 1
6561: DEC
6562: ST_TO_ADDR
6563: LD_INT 4
6565: PUSH
6566: LD_INT 6
6568: PUSH
6569: LD_INT 7
6571: PUSH
6572: LD_INT 8
6574: PUSH
6575: EMPTY
6576: LIST
6577: LIST
6578: LIST
6579: LIST
6580: PUSH
6581: LD_OWVAR 67
6585: ARRAY
6586: PUSH
6587: FOR_TO
6588: IFFALSE 6748
// begin uc_side := 8 ;
6590: LD_ADDR_OWVAR 20
6594: PUSH
6595: LD_INT 8
6597: ST_TO_ADDR
// uc_nation := 2 ;
6598: LD_ADDR_OWVAR 21
6602: PUSH
6603: LD_INT 2
6605: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6606: LD_INT 13
6608: PUSH
6609: LD_INT 14
6611: PUSH
6612: EMPTY
6613: LIST
6614: LIST
6615: PUSH
6616: LD_INT 1
6618: PPUSH
6619: LD_INT 2
6621: PPUSH
6622: CALL_OW 12
6626: ARRAY
6627: PPUSH
6628: LD_INT 1
6630: PPUSH
6631: LD_INT 5
6633: PPUSH
6634: LD_INT 27
6636: PUSH
6637: LD_INT 28
6639: PUSH
6640: LD_INT 26
6642: PUSH
6643: LD_INT 25
6645: PUSH
6646: EMPTY
6647: LIST
6648: LIST
6649: LIST
6650: LIST
6651: PUSH
6652: LD_INT 1
6654: PPUSH
6655: LD_INT 4
6657: PPUSH
6658: CALL_OW 12
6662: ARRAY
6663: PPUSH
6664: LD_INT 88
6666: PPUSH
6667: CALL 72350 0 5
// un := CreateVehicle ;
6671: LD_ADDR_VAR 0 2
6675: PUSH
6676: CALL_OW 45
6680: ST_TO_ADDR
// tmp := tmp ^ un ;
6681: LD_ADDR_VAR 0 3
6685: PUSH
6686: LD_VAR 0 3
6690: PUSH
6691: LD_VAR 0 2
6695: ADD
6696: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6697: LD_VAR 0 2
6701: PPUSH
6702: LD_INT 3
6704: PPUSH
6705: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6709: LD_VAR 0 2
6713: PPUSH
6714: LD_INT 30
6716: PPUSH
6717: LD_INT 0
6719: PPUSH
6720: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6724: LD_VAR 0 2
6728: PPUSH
6729: LD_INT 16
6731: PPUSH
6732: LD_INT 11
6734: PPUSH
6735: CALL_OW 111
// wait ( 0 0$2 ) ;
6739: LD_INT 70
6741: PPUSH
6742: CALL_OW 67
// end ;
6746: GO 6587
6748: POP
6749: POP
// for i = 1 to Difficulty do
6750: LD_ADDR_VAR 0 1
6754: PUSH
6755: DOUBLE
6756: LD_INT 1
6758: DEC
6759: ST_TO_ADDR
6760: LD_OWVAR 67
6764: PUSH
6765: FOR_TO
6766: IFFALSE 6895
// begin uc_side := 8 ;
6768: LD_ADDR_OWVAR 20
6772: PUSH
6773: LD_INT 8
6775: ST_TO_ADDR
// uc_nation := 2 ;
6776: LD_ADDR_OWVAR 21
6780: PUSH
6781: LD_INT 2
6783: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
6784: LD_INT 0
6786: PPUSH
6787: LD_INT 8
6789: PPUSH
6790: LD_INT 8
6792: PUSH
6793: LD_INT 8
6795: PUSH
6796: LD_INT 9
6798: PUSH
6799: LD_INT 10
6801: PUSH
6802: EMPTY
6803: LIST
6804: LIST
6805: LIST
6806: LIST
6807: PUSH
6808: LD_OWVAR 67
6812: ARRAY
6813: PPUSH
6814: CALL_OW 380
// un := CreateHuman ;
6818: LD_ADDR_VAR 0 2
6822: PUSH
6823: CALL_OW 44
6827: ST_TO_ADDR
// tmp := tmp ^ un ;
6828: LD_ADDR_VAR 0 3
6832: PUSH
6833: LD_VAR 0 3
6837: PUSH
6838: LD_VAR 0 2
6842: ADD
6843: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6844: LD_VAR 0 2
6848: PPUSH
6849: LD_INT 3
6851: PPUSH
6852: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6856: LD_VAR 0 2
6860: PPUSH
6861: LD_INT 30
6863: PPUSH
6864: LD_INT 0
6866: PPUSH
6867: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6871: LD_VAR 0 2
6875: PPUSH
6876: LD_INT 16
6878: PPUSH
6879: LD_INT 11
6881: PPUSH
6882: CALL_OW 111
// wait ( 0 0$2 ) ;
6886: LD_INT 70
6888: PPUSH
6889: CALL_OW 67
// end ;
6893: GO 6765
6895: POP
6896: POP
// repeat wait ( 0 0$1 ) ;
6897: LD_INT 35
6899: PPUSH
6900: CALL_OW 67
// if legionDestroyed then
6904: LD_EXP 22
6908: IFFALSE 6912
// exit ;
6910: GO 7068
// for i in tmp do
6912: LD_ADDR_VAR 0 1
6916: PUSH
6917: LD_VAR 0 3
6921: PUSH
6922: FOR_IN
6923: IFFALSE 7059
// begin if GetLives ( i ) > 250 then
6925: LD_VAR 0 1
6929: PPUSH
6930: CALL_OW 256
6934: PUSH
6935: LD_INT 250
6937: GREATER
6938: IFFALSE 7030
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6940: LD_INT 81
6942: PUSH
6943: LD_INT 8
6945: PUSH
6946: EMPTY
6947: LIST
6948: LIST
6949: PUSH
6950: LD_INT 91
6952: PUSH
6953: LD_VAR 0 1
6957: PUSH
6958: LD_INT 10
6960: PUSH
6961: EMPTY
6962: LIST
6963: LIST
6964: LIST
6965: PUSH
6966: EMPTY
6967: LIST
6968: LIST
6969: PPUSH
6970: CALL_OW 69
6974: NOT
6975: IFFALSE 6994
// ComAgressiveMove ( i , 67 , 110 ) else
6977: LD_VAR 0 1
6981: PPUSH
6982: LD_INT 67
6984: PPUSH
6985: LD_INT 110
6987: PPUSH
6988: CALL_OW 114
6992: GO 7028
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6994: LD_VAR 0 1
6998: PPUSH
6999: LD_INT 81
7001: PUSH
7002: LD_INT 8
7004: PUSH
7005: EMPTY
7006: LIST
7007: LIST
7008: PPUSH
7009: CALL_OW 69
7013: PPUSH
7014: LD_VAR 0 1
7018: PPUSH
7019: CALL_OW 74
7023: PPUSH
7024: CALL_OW 115
// end else
7028: GO 7057
// if IsDead ( i ) then
7030: LD_VAR 0 1
7034: PPUSH
7035: CALL_OW 301
7039: IFFALSE 7057
// tmp := tmp diff i ;
7041: LD_ADDR_VAR 0 3
7045: PUSH
7046: LD_VAR 0 3
7050: PUSH
7051: LD_VAR 0 1
7055: DIFF
7056: ST_TO_ADDR
// end ;
7057: GO 6922
7059: POP
7060: POP
// until not tmp ;
7061: LD_VAR 0 3
7065: NOT
7066: IFFALSE 6897
// end ; end_of_file
7068: PPOPN 3
7070: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
7071: LD_INT 0
7073: PPUSH
7074: PPUSH
7075: PPUSH
7076: PPUSH
7077: PPUSH
7078: PPUSH
7079: PPUSH
7080: PPUSH
7081: PPUSH
// side := 3 ;
7082: LD_ADDR_VAR 0 6
7086: PUSH
7087: LD_INT 3
7089: ST_TO_ADDR
// uc_side := side ;
7090: LD_ADDR_OWVAR 20
7094: PUSH
7095: LD_VAR 0 6
7099: ST_TO_ADDR
// uc_nation := 3 ;
7100: LD_ADDR_OWVAR 21
7104: PUSH
7105: LD_INT 3
7107: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7108: LD_ADDR_VAR 0 2
7112: PUSH
7113: LD_INT 22
7115: PUSH
7116: LD_VAR 0 6
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PUSH
7125: LD_INT 21
7127: PUSH
7128: LD_INT 3
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: PPUSH
7139: CALL_OW 69
7143: PUSH
7144: FOR_IN
7145: IFFALSE 7161
// SetBLevel ( i , 10 ) ;
7147: LD_VAR 0 2
7151: PPUSH
7152: LD_INT 10
7154: PPUSH
7155: CALL_OW 241
7159: GO 7144
7161: POP
7162: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7163: LD_ADDR_VAR 0 9
7167: PUSH
7168: LD_INT 22
7170: PUSH
7171: LD_VAR 0 6
7175: PUSH
7176: EMPTY
7177: LIST
7178: LIST
7179: PUSH
7180: LD_INT 30
7182: PUSH
7183: LD_INT 34
7185: PUSH
7186: EMPTY
7187: LIST
7188: LIST
7189: PUSH
7190: EMPTY
7191: LIST
7192: LIST
7193: PPUSH
7194: CALL_OW 69
7198: ST_TO_ADDR
// if teleport then
7199: LD_VAR 0 9
7203: IFFALSE 7224
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7205: LD_VAR 0 9
7209: PUSH
7210: LD_INT 1
7212: ARRAY
7213: PPUSH
7214: LD_INT 123
7216: PPUSH
7217: LD_INT 122
7219: PPUSH
7220: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7224: LD_ADDR_EXP 65
7228: PUSH
7229: LD_STRING Platonov
7231: PPUSH
7232: CALL_OW 25
7236: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7237: LD_ADDR_EXP 66
7241: PUSH
7242: LD_STRING Kovalyuk
7244: PPUSH
7245: CALL_OW 25
7249: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7250: LD_ADDR_EXP 68
7254: PUSH
7255: LD_STRING Yakotich
7257: PPUSH
7258: LD_EXP 1
7262: NOT
7263: PPUSH
7264: LD_STRING 09_
7266: PPUSH
7267: CALL 67335 0 3
7271: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7272: LD_ADDR_EXP 67
7276: PUSH
7277: LD_STRING Bystrov
7279: PPUSH
7280: CALL_OW 25
7284: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7285: LD_ADDR_EXP 69
7289: PUSH
7290: LD_STRING Gleb
7292: PPUSH
7293: CALL_OW 25
7297: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7298: LD_STRING 03_Cornel
7300: PPUSH
7301: CALL_OW 28
7305: IFFALSE 7353
// begin Bierezov := NewCharacter ( Mikhail ) ;
7307: LD_ADDR_EXP 70
7311: PUSH
7312: LD_STRING Mikhail
7314: PPUSH
7315: CALL_OW 25
7319: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7320: LD_EXP 70
7324: PPUSH
7325: LD_INT 197
7327: PPUSH
7328: LD_INT 111
7330: PPUSH
7331: LD_INT 9
7333: PPUSH
7334: LD_INT 0
7336: PPUSH
7337: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7341: LD_EXP 70
7345: PPUSH
7346: LD_INT 3
7348: PPUSH
7349: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7353: LD_EXP 65
7357: PPUSH
7358: LD_INT 126
7360: PPUSH
7361: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7365: LD_EXP 66
7369: PPUSH
7370: LD_INT 134
7372: PPUSH
7373: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7377: LD_EXP 68
7381: PPUSH
7382: LD_INT 197
7384: PPUSH
7385: LD_INT 111
7387: PPUSH
7388: LD_INT 9
7390: PPUSH
7391: LD_INT 0
7393: PPUSH
7394: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7398: LD_EXP 67
7402: PPUSH
7403: LD_INT 197
7405: PPUSH
7406: LD_INT 111
7408: PPUSH
7409: LD_INT 9
7411: PPUSH
7412: LD_INT 0
7414: PPUSH
7415: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7419: LD_EXP 69
7423: PPUSH
7424: LD_INT 197
7426: PPUSH
7427: LD_INT 111
7429: PPUSH
7430: LD_INT 9
7432: PPUSH
7433: LD_INT 0
7435: PPUSH
7436: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7440: LD_ADDR_VAR 0 5
7444: PUSH
7445: LD_INT 126
7447: PPUSH
7448: LD_INT 4
7450: PPUSH
7451: LD_STRING zhukov
7453: PPUSH
7454: LD_INT 9
7456: PUSH
7457: LD_INT 10
7459: PUSH
7460: LD_INT 10
7462: PUSH
7463: LD_INT 10
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: LIST
7470: LIST
7471: PUSH
7472: LD_OWVAR 67
7476: ARRAY
7477: PPUSH
7478: LD_INT 90000
7480: PUSH
7481: LD_INT 1000
7483: PUSH
7484: LD_INT 300
7486: PUSH
7487: EMPTY
7488: LIST
7489: LIST
7490: LIST
7491: PPUSH
7492: LD_INT 18
7494: PUSH
7495: LD_INT 8
7497: PUSH
7498: LD_INT 13
7500: PUSH
7501: LD_INT 8
7503: PUSH
7504: EMPTY
7505: LIST
7506: LIST
7507: LIST
7508: LIST
7509: PPUSH
7510: CALL 75794 0 6
7514: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7515: LD_ADDR_VAR 0 4
7519: PUSH
7520: LD_INT 267
7522: PPUSH
7523: CALL_OW 274
7527: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7528: LD_VAR 0 4
7532: PPUSH
7533: LD_INT 1
7535: PPUSH
7536: LD_INT 5000
7538: PPUSH
7539: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7543: LD_VAR 0 4
7547: PPUSH
7548: LD_INT 2
7550: PPUSH
7551: LD_INT 200
7553: PPUSH
7554: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7558: LD_VAR 0 4
7562: PPUSH
7563: LD_INT 3
7565: PPUSH
7566: LD_INT 200
7568: PPUSH
7569: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7573: LD_ADDR_EXP 99
7577: PUSH
7578: LD_EXP 99
7582: PPUSH
7583: LD_INT 2
7585: PPUSH
7586: LD_VAR 0 5
7590: PUSH
7591: LD_INT 22
7593: PUSH
7594: LD_VAR 0 6
7598: PUSH
7599: EMPTY
7600: LIST
7601: LIST
7602: PUSH
7603: LD_INT 3
7605: PUSH
7606: LD_INT 21
7608: PUSH
7609: LD_INT 2
7611: PUSH
7612: EMPTY
7613: LIST
7614: LIST
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PPUSH
7624: CALL_OW 69
7628: UNION
7629: PUSH
7630: LD_EXP 65
7634: DIFF
7635: PPUSH
7636: CALL_OW 1
7640: ST_TO_ADDR
// behemoths := [ ] ;
7641: LD_ADDR_EXP 73
7645: PUSH
7646: EMPTY
7647: ST_TO_ADDR
// behemothBuilders := [ ] ;
7648: LD_ADDR_EXP 74
7652: PUSH
7653: EMPTY
7654: ST_TO_ADDR
// if Kovalyuk then
7655: LD_EXP 66
7659: IFFALSE 7681
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7661: LD_ADDR_EXP 74
7665: PUSH
7666: LD_EXP 74
7670: PPUSH
7671: LD_EXP 66
7675: PPUSH
7676: CALL 104784 0 2
7680: ST_TO_ADDR
// j := 3 ;
7681: LD_ADDR_VAR 0 3
7685: PUSH
7686: LD_INT 3
7688: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7689: LD_ADDR_VAR 0 2
7693: PUSH
7694: LD_INT 22
7696: PUSH
7697: LD_INT 3
7699: PUSH
7700: EMPTY
7701: LIST
7702: LIST
7703: PUSH
7704: LD_INT 25
7706: PUSH
7707: LD_INT 3
7709: PUSH
7710: EMPTY
7711: LIST
7712: LIST
7713: PUSH
7714: EMPTY
7715: LIST
7716: LIST
7717: PPUSH
7718: CALL_OW 69
7722: PUSH
7723: LD_EXP 66
7727: DIFF
7728: PUSH
7729: FOR_IN
7730: IFFALSE 7780
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7732: LD_ADDR_EXP 74
7736: PUSH
7737: LD_EXP 74
7741: PPUSH
7742: LD_VAR 0 2
7746: PPUSH
7747: CALL 104784 0 2
7751: ST_TO_ADDR
// j := j - 1 ;
7752: LD_ADDR_VAR 0 3
7756: PUSH
7757: LD_VAR 0 3
7761: PUSH
7762: LD_INT 1
7764: MINUS
7765: ST_TO_ADDR
// if j = 0 then
7766: LD_VAR 0 3
7770: PUSH
7771: LD_INT 0
7773: EQUAL
7774: IFFALSE 7778
// break ;
7776: GO 7780
// end ;
7778: GO 7729
7780: POP
7781: POP
// end ;
7782: LD_VAR 0 1
7786: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7787: LD_INT 0
7789: PPUSH
7790: PPUSH
7791: PPUSH
7792: PPUSH
7793: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7794: LD_ADDR_VAR 0 4
7798: PUSH
7799: LD_INT 209
7801: PUSH
7802: LD_INT 149
7804: PUSH
7805: EMPTY
7806: LIST
7807: LIST
7808: PUSH
7809: LD_INT 219
7811: PUSH
7812: LD_INT 154
7814: PUSH
7815: EMPTY
7816: LIST
7817: LIST
7818: PUSH
7819: LD_INT 223
7821: PUSH
7822: LD_INT 149
7824: PUSH
7825: EMPTY
7826: LIST
7827: LIST
7828: PUSH
7829: LD_INT 232
7831: PUSH
7832: LD_INT 155
7834: PUSH
7835: EMPTY
7836: LIST
7837: LIST
7838: PUSH
7839: EMPTY
7840: LIST
7841: LIST
7842: LIST
7843: LIST
7844: ST_TO_ADDR
// if not behemothBuilders then
7845: LD_EXP 74
7849: NOT
7850: IFFALSE 7854
// exit ;
7852: GO 7985
// j := 1 ;
7854: LD_ADDR_VAR 0 3
7858: PUSH
7859: LD_INT 1
7861: ST_TO_ADDR
// for i in behemothBuilders do
7862: LD_ADDR_VAR 0 2
7866: PUSH
7867: LD_EXP 74
7871: PUSH
7872: FOR_IN
7873: IFFALSE 7983
// begin if GetClass ( i ) <> class_mechanic then
7875: LD_VAR 0 2
7879: PPUSH
7880: CALL_OW 257
7884: PUSH
7885: LD_INT 3
7887: NONEQUAL
7888: IFFALSE 7902
// SetClass ( i , class_mechanic ) ;
7890: LD_VAR 0 2
7894: PPUSH
7895: LD_INT 3
7897: PPUSH
7898: CALL_OW 336
// if IsInUnit ( i ) then
7902: LD_VAR 0 2
7906: PPUSH
7907: CALL_OW 310
7911: IFFALSE 7922
// ComExitBuilding ( i ) ;
7913: LD_VAR 0 2
7917: PPUSH
7918: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7922: LD_VAR 0 2
7926: PPUSH
7927: LD_INT 37
7929: PPUSH
7930: LD_VAR 0 4
7934: PUSH
7935: LD_VAR 0 3
7939: ARRAY
7940: PUSH
7941: LD_INT 1
7943: ARRAY
7944: PPUSH
7945: LD_VAR 0 4
7949: PUSH
7950: LD_VAR 0 3
7954: ARRAY
7955: PUSH
7956: LD_INT 2
7958: ARRAY
7959: PPUSH
7960: LD_INT 0
7962: PPUSH
7963: CALL_OW 230
// j := j + 1 ;
7967: LD_ADDR_VAR 0 3
7971: PUSH
7972: LD_VAR 0 3
7976: PUSH
7977: LD_INT 1
7979: PLUS
7980: ST_TO_ADDR
// end ;
7981: GO 7872
7983: POP
7984: POP
// end ;
7985: LD_VAR 0 1
7989: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7990: LD_INT 24
7992: PPUSH
7993: LD_INT 30
7995: PUSH
7996: LD_INT 37
7998: PUSH
7999: EMPTY
8000: LIST
8001: LIST
8002: PPUSH
8003: CALL_OW 70
8007: IFFALSE 8020
8009: GO 8011
8011: DISABLE
// behemothUnderConstruct := true ;
8012: LD_ADDR_EXP 26
8016: PUSH
8017: LD_INT 1
8019: ST_TO_ADDR
8020: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8021: LD_INT 3
8023: PPUSH
8024: CALL 104845 0 1
8028: PUSH
8029: LD_INT 22
8031: PUSH
8032: LD_INT 3
8034: PUSH
8035: EMPTY
8036: LIST
8037: LIST
8038: PUSH
8039: LD_INT 30
8041: PUSH
8042: LD_INT 37
8044: PUSH
8045: EMPTY
8046: LIST
8047: LIST
8048: PUSH
8049: EMPTY
8050: LIST
8051: LIST
8052: PPUSH
8053: CALL_OW 69
8057: NOT
8058: AND
8059: IFFALSE 8245
8061: GO 8063
8063: DISABLE
8064: LD_INT 0
8066: PPUSH
8067: PPUSH
// begin enable ;
8068: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8069: LD_ADDR_VAR 0 2
8073: PUSH
8074: LD_INT 3
8076: PPUSH
8077: CALL 104845 0 1
8081: ST_TO_ADDR
// for i in tmp do
8082: LD_ADDR_VAR 0 1
8086: PUSH
8087: LD_VAR 0 2
8091: PUSH
8092: FOR_IN
8093: IFFALSE 8243
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8095: LD_VAR 0 1
8099: PPUSH
8100: LD_INT 9
8102: PPUSH
8103: CALL_OW 308
8107: PUSH
8108: LD_VAR 0 1
8112: PPUSH
8113: CALL_OW 110
8117: PUSH
8118: LD_INT 2
8120: EQUAL
8121: NOT
8122: AND
8123: IFFALSE 8137
// SetTag ( i , 2 ) ;
8125: LD_VAR 0 1
8129: PPUSH
8130: LD_INT 2
8132: PPUSH
8133: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8137: LD_INT 81
8139: PUSH
8140: LD_INT 3
8142: PUSH
8143: EMPTY
8144: LIST
8145: LIST
8146: PUSH
8147: LD_INT 91
8149: PUSH
8150: LD_VAR 0 1
8154: PUSH
8155: LD_INT 12
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: LIST
8162: PUSH
8163: EMPTY
8164: LIST
8165: LIST
8166: PPUSH
8167: CALL_OW 69
8171: NOT
8172: PUSH
8173: LD_VAR 0 1
8177: PPUSH
8178: CALL_OW 110
8182: PUSH
8183: LD_INT 2
8185: EQUAL
8186: NOT
8187: AND
8188: IFFALSE 8207
// ComAgressiveMove ( i , 64 , 93 ) else
8190: LD_VAR 0 1
8194: PPUSH
8195: LD_INT 64
8197: PPUSH
8198: LD_INT 93
8200: PPUSH
8201: CALL_OW 114
8205: GO 8241
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8207: LD_VAR 0 1
8211: PPUSH
8212: LD_INT 81
8214: PUSH
8215: LD_INT 3
8217: PUSH
8218: EMPTY
8219: LIST
8220: LIST
8221: PPUSH
8222: CALL_OW 69
8226: PPUSH
8227: LD_VAR 0 1
8231: PPUSH
8232: CALL_OW 74
8236: PPUSH
8237: CALL_OW 115
// end ;
8241: GO 8092
8243: POP
8244: POP
// end ;
8245: PPOPN 2
8247: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8248: LD_INT 0
8250: PPUSH
8251: PPUSH
8252: PPUSH
// result := [ ] ;
8253: LD_ADDR_VAR 0 2
8257: PUSH
8258: EMPTY
8259: ST_TO_ADDR
// uc_side := 6 ;
8260: LD_ADDR_OWVAR 20
8264: PUSH
8265: LD_INT 6
8267: ST_TO_ADDR
// uc_nation := 3 ;
8268: LD_ADDR_OWVAR 21
8272: PUSH
8273: LD_INT 3
8275: ST_TO_ADDR
// case strength of 1 :
8276: LD_VAR 0 1
8280: PUSH
8281: LD_INT 1
8283: DOUBLE
8284: EQUAL
8285: IFTRUE 8289
8287: GO 8431
8289: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8290: LD_ADDR_VAR 0 3
8294: PUSH
8295: DOUBLE
8296: LD_INT 1
8298: DEC
8299: ST_TO_ADDR
8300: LD_INT 4
8302: PUSH
8303: LD_INT 5
8305: PUSH
8306: LD_INT 6
8308: PUSH
8309: LD_INT 7
8311: PUSH
8312: EMPTY
8313: LIST
8314: LIST
8315: LIST
8316: LIST
8317: PUSH
8318: LD_OWVAR 67
8322: ARRAY
8323: PUSH
8324: FOR_TO
8325: IFFALSE 8427
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8327: LD_INT 22
8329: PUSH
8330: LD_INT 24
8332: PUSH
8333: EMPTY
8334: LIST
8335: LIST
8336: PUSH
8337: LD_VAR 0 3
8341: PUSH
8342: LD_INT 2
8344: MOD
8345: PUSH
8346: LD_INT 1
8348: PLUS
8349: ARRAY
8350: PPUSH
8351: LD_INT 1
8353: PUSH
8354: LD_INT 3
8356: PUSH
8357: EMPTY
8358: LIST
8359: LIST
8360: PUSH
8361: LD_INT 1
8363: PPUSH
8364: LD_INT 2
8366: PPUSH
8367: CALL_OW 12
8371: ARRAY
8372: PPUSH
8373: LD_INT 3
8375: PPUSH
8376: LD_INT 43
8378: PUSH
8379: LD_INT 44
8381: PUSH
8382: LD_INT 45
8384: PUSH
8385: EMPTY
8386: LIST
8387: LIST
8388: LIST
8389: PUSH
8390: LD_INT 1
8392: PPUSH
8393: LD_INT 3
8395: PPUSH
8396: CALL_OW 12
8400: ARRAY
8401: PPUSH
8402: LD_INT 80
8404: PPUSH
8405: CALL 72350 0 5
// result := result union CreateVehicle ;
8409: LD_ADDR_VAR 0 2
8413: PUSH
8414: LD_VAR 0 2
8418: PUSH
8419: CALL_OW 45
8423: UNION
8424: ST_TO_ADDR
// end ;
8425: GO 8324
8427: POP
8428: POP
// end ; 2 :
8429: GO 9426
8431: LD_INT 2
8433: DOUBLE
8434: EQUAL
8435: IFTRUE 8439
8437: GO 8607
8439: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8440: LD_ADDR_VAR 0 3
8444: PUSH
8445: DOUBLE
8446: LD_INT 1
8448: DEC
8449: ST_TO_ADDR
8450: LD_INT 5
8452: PUSH
8453: LD_INT 6
8455: PUSH
8456: LD_INT 7
8458: PUSH
8459: LD_INT 8
8461: PUSH
8462: EMPTY
8463: LIST
8464: LIST
8465: LIST
8466: LIST
8467: PUSH
8468: LD_OWVAR 67
8472: ARRAY
8473: PUSH
8474: FOR_TO
8475: IFFALSE 8603
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
8477: LD_INT 22
8479: PUSH
8480: LD_INT 24
8482: PUSH
8483: LD_INT 24
8485: PUSH
8486: EMPTY
8487: LIST
8488: LIST
8489: LIST
8490: PUSH
8491: LD_VAR 0 3
8495: PUSH
8496: LD_INT 3
8498: MOD
8499: PUSH
8500: LD_INT 1
8502: PLUS
8503: ARRAY
8504: PPUSH
8505: LD_INT 1
8507: PUSH
8508: LD_INT 3
8510: PUSH
8511: EMPTY
8512: LIST
8513: LIST
8514: PUSH
8515: LD_INT 1
8517: PPUSH
8518: LD_INT 2
8520: PPUSH
8521: CALL_OW 12
8525: ARRAY
8526: PPUSH
8527: LD_INT 3
8529: PPUSH
8530: LD_INT 43
8532: PUSH
8533: LD_INT 44
8535: PUSH
8536: LD_INT 45
8538: PUSH
8539: LD_INT 44
8541: PUSH
8542: LD_INT 46
8544: PUSH
8545: LD_INT 46
8547: PUSH
8548: LD_INT 49
8550: PUSH
8551: LD_INT 49
8553: PUSH
8554: EMPTY
8555: LIST
8556: LIST
8557: LIST
8558: LIST
8559: LIST
8560: LIST
8561: LIST
8562: LIST
8563: PUSH
8564: LD_VAR 0 3
8568: PUSH
8569: LD_INT 8
8571: MOD
8572: PUSH
8573: LD_INT 1
8575: PLUS
8576: ARRAY
8577: PPUSH
8578: LD_INT 80
8580: PPUSH
8581: CALL 72350 0 5
// result := result union CreateVehicle ;
8585: LD_ADDR_VAR 0 2
8589: PUSH
8590: LD_VAR 0 2
8594: PUSH
8595: CALL_OW 45
8599: UNION
8600: ST_TO_ADDR
// end ;
8601: GO 8474
8603: POP
8604: POP
// end ; 3 :
8605: GO 9426
8607: LD_INT 3
8609: DOUBLE
8610: EQUAL
8611: IFTRUE 8615
8613: GO 8787
8615: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
8616: LD_ADDR_VAR 0 3
8620: PUSH
8621: DOUBLE
8622: LD_INT 1
8624: DEC
8625: ST_TO_ADDR
8626: LD_INT 6
8628: PUSH
8629: LD_INT 7
8631: PUSH
8632: LD_INT 8
8634: PUSH
8635: LD_INT 9
8637: PUSH
8638: EMPTY
8639: LIST
8640: LIST
8641: LIST
8642: LIST
8643: PUSH
8644: LD_OWVAR 67
8648: ARRAY
8649: PUSH
8650: FOR_TO
8651: IFFALSE 8783
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
8653: LD_INT 22
8655: PUSH
8656: LD_INT 24
8658: PUSH
8659: LD_INT 24
8661: PUSH
8662: EMPTY
8663: LIST
8664: LIST
8665: LIST
8666: PUSH
8667: LD_VAR 0 3
8671: PUSH
8672: LD_INT 3
8674: MOD
8675: PUSH
8676: LD_INT 1
8678: PLUS
8679: ARRAY
8680: PPUSH
8681: LD_INT 1
8683: PUSH
8684: LD_INT 3
8686: PUSH
8687: EMPTY
8688: LIST
8689: LIST
8690: PUSH
8691: LD_INT 1
8693: PPUSH
8694: LD_INT 2
8696: PPUSH
8697: CALL_OW 12
8701: ARRAY
8702: PPUSH
8703: LD_INT 3
8705: PPUSH
8706: LD_INT 43
8708: PUSH
8709: LD_INT 47
8711: PUSH
8712: LD_INT 45
8714: PUSH
8715: LD_INT 45
8717: PUSH
8718: LD_INT 46
8720: PUSH
8721: LD_INT 46
8723: PUSH
8724: LD_INT 49
8726: PUSH
8727: LD_INT 49
8729: PUSH
8730: LD_INT 49
8732: PUSH
8733: EMPTY
8734: LIST
8735: LIST
8736: LIST
8737: LIST
8738: LIST
8739: LIST
8740: LIST
8741: LIST
8742: LIST
8743: PUSH
8744: LD_VAR 0 3
8748: PUSH
8749: LD_INT 9
8751: MOD
8752: PUSH
8753: LD_INT 1
8755: PLUS
8756: ARRAY
8757: PPUSH
8758: LD_INT 80
8760: PPUSH
8761: CALL 72350 0 5
// result := result union CreateVehicle ;
8765: LD_ADDR_VAR 0 2
8769: PUSH
8770: LD_VAR 0 2
8774: PUSH
8775: CALL_OW 45
8779: UNION
8780: ST_TO_ADDR
// end ;
8781: GO 8650
8783: POP
8784: POP
// end ; 4 :
8785: GO 9426
8787: LD_INT 4
8789: DOUBLE
8790: EQUAL
8791: IFTRUE 8795
8793: GO 9425
8795: POP
// begin uc_nation := 3 ;
8796: LD_ADDR_OWVAR 21
8800: PUSH
8801: LD_INT 3
8803: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
8804: LD_ADDR_VAR 0 3
8808: PUSH
8809: DOUBLE
8810: LD_INT 1
8812: DEC
8813: ST_TO_ADDR
8814: LD_INT 6
8816: PUSH
8817: LD_INT 8
8819: PUSH
8820: LD_INT 9
8822: PUSH
8823: LD_INT 10
8825: PUSH
8826: EMPTY
8827: LIST
8828: LIST
8829: LIST
8830: LIST
8831: PUSH
8832: LD_OWVAR 67
8836: ARRAY
8837: PUSH
8838: FOR_TO
8839: IFFALSE 8971
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
8841: LD_INT 22
8843: PUSH
8844: LD_INT 24
8846: PUSH
8847: LD_INT 24
8849: PUSH
8850: EMPTY
8851: LIST
8852: LIST
8853: LIST
8854: PUSH
8855: LD_VAR 0 3
8859: PUSH
8860: LD_INT 3
8862: MOD
8863: PUSH
8864: LD_INT 1
8866: PLUS
8867: ARRAY
8868: PPUSH
8869: LD_INT 1
8871: PUSH
8872: LD_INT 3
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: PUSH
8879: LD_INT 1
8881: PPUSH
8882: LD_INT 2
8884: PPUSH
8885: CALL_OW 12
8889: ARRAY
8890: PPUSH
8891: LD_INT 3
8893: PPUSH
8894: LD_INT 45
8896: PUSH
8897: LD_INT 47
8899: PUSH
8900: LD_INT 47
8902: PUSH
8903: LD_INT 45
8905: PUSH
8906: LD_INT 46
8908: PUSH
8909: LD_INT 46
8911: PUSH
8912: LD_INT 49
8914: PUSH
8915: LD_INT 49
8917: PUSH
8918: LD_INT 49
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: LIST
8925: LIST
8926: LIST
8927: LIST
8928: LIST
8929: LIST
8930: LIST
8931: PUSH
8932: LD_VAR 0 3
8936: PUSH
8937: LD_INT 9
8939: MOD
8940: PUSH
8941: LD_INT 1
8943: PLUS
8944: ARRAY
8945: PPUSH
8946: LD_INT 80
8948: PPUSH
8949: CALL 72350 0 5
// result := result union CreateVehicle ;
8953: LD_ADDR_VAR 0 2
8957: PUSH
8958: LD_VAR 0 2
8962: PUSH
8963: CALL_OW 45
8967: UNION
8968: ST_TO_ADDR
// end ;
8969: GO 8838
8971: POP
8972: POP
// if not KappaStatus then
8973: LD_EXP 2
8977: NOT
8978: IFFALSE 9213
// begin uc_nation := 1 ;
8980: LD_ADDR_OWVAR 21
8984: PUSH
8985: LD_INT 1
8987: ST_TO_ADDR
// for i = 1 to 3 do
8988: LD_ADDR_VAR 0 3
8992: PUSH
8993: DOUBLE
8994: LD_INT 1
8996: DEC
8997: ST_TO_ADDR
8998: LD_INT 3
9000: PUSH
9001: FOR_TO
9002: IFFALSE 9138
// begin j := rand ( 0 , 1 ) ;
9004: LD_ADDR_VAR 0 4
9008: PUSH
9009: LD_INT 0
9011: PPUSH
9012: LD_INT 1
9014: PPUSH
9015: CALL_OW 12
9019: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9020: LD_INT 3
9022: PUSH
9023: LD_INT 5
9025: PUSH
9026: LD_INT 5
9028: PUSH
9029: LD_INT 4
9031: PUSH
9032: EMPTY
9033: LIST
9034: LIST
9035: LIST
9036: LIST
9037: PUSH
9038: LD_VAR 0 4
9042: PUSH
9043: LD_INT 1
9045: PPUSH
9046: LD_INT 3
9048: PPUSH
9049: CALL_OW 12
9053: PLUS
9054: ARRAY
9055: PPUSH
9056: LD_INT 1
9058: PUSH
9059: LD_INT 3
9061: PUSH
9062: EMPTY
9063: LIST
9064: LIST
9065: PUSH
9066: LD_INT 1
9068: PPUSH
9069: LD_INT 2
9071: PPUSH
9072: CALL_OW 12
9076: ARRAY
9077: PPUSH
9078: LD_INT 3
9080: PPUSH
9081: LD_INT 9
9083: PUSH
9084: LD_INT 7
9086: PUSH
9087: LD_INT 6
9089: PUSH
9090: EMPTY
9091: LIST
9092: LIST
9093: LIST
9094: PUSH
9095: LD_VAR 0 4
9099: PUSH
9100: LD_INT 1
9102: PPUSH
9103: LD_INT 2
9105: PPUSH
9106: CALL_OW 12
9110: PLUS
9111: ARRAY
9112: PPUSH
9113: LD_INT 85
9115: PPUSH
9116: CALL 72350 0 5
// result := result union CreateVehicle ;
9120: LD_ADDR_VAR 0 2
9124: PUSH
9125: LD_VAR 0 2
9129: PUSH
9130: CALL_OW 45
9134: UNION
9135: ST_TO_ADDR
// end ;
9136: GO 9001
9138: POP
9139: POP
// if vsevolodFirstAttack then
9140: LD_EXP 24
9144: IFFALSE 9211
// begin vsevolodFirstAttack := false ;
9146: LD_ADDR_EXP 24
9150: PUSH
9151: LD_INT 0
9153: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9154: LD_INT 5
9156: PPUSH
9157: LD_INT 3
9159: PPUSH
9160: LD_INT 1
9162: PPUSH
9163: LD_INT 6
9165: PPUSH
9166: LD_INT 100
9168: PPUSH
9169: CALL 72350 0 5
// sewiVeh := CreateVehicle ;
9173: LD_ADDR_EXP 72
9177: PUSH
9178: CALL_OW 45
9182: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9183: LD_EXP 72
9187: PPUSH
9188: LD_INT 1
9190: PPUSH
9191: CALL_OW 242
// result := result union sewiVeh ;
9195: LD_ADDR_VAR 0 2
9199: PUSH
9200: LD_VAR 0 2
9204: PUSH
9205: LD_EXP 72
9209: UNION
9210: ST_TO_ADDR
// end ; end else
9211: GO 9423
// if vsevolodFirstAttack then
9213: LD_EXP 24
9217: IFFALSE 9423
// begin vsevolodFirstAttack := false ;
9219: LD_ADDR_EXP 24
9223: PUSH
9224: LD_INT 0
9226: ST_TO_ADDR
// uc_nation := 3 ;
9227: LD_ADDR_OWVAR 21
9231: PUSH
9232: LD_INT 3
9234: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9235: LD_ADDR_VAR 0 3
9239: PUSH
9240: DOUBLE
9241: LD_INT 1
9243: DEC
9244: ST_TO_ADDR
9245: LD_INT 2
9247: PUSH
9248: LD_OWVAR 67
9252: PLUS
9253: PUSH
9254: FOR_TO
9255: IFFALSE 9363
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9257: LD_INT 22
9259: PUSH
9260: LD_INT 24
9262: PUSH
9263: LD_INT 24
9265: PUSH
9266: EMPTY
9267: LIST
9268: LIST
9269: LIST
9270: PUSH
9271: LD_VAR 0 3
9275: PUSH
9276: LD_INT 3
9278: MOD
9279: PUSH
9280: LD_INT 1
9282: PLUS
9283: ARRAY
9284: PPUSH
9285: LD_INT 1
9287: PUSH
9288: LD_INT 3
9290: PUSH
9291: EMPTY
9292: LIST
9293: LIST
9294: PUSH
9295: LD_INT 1
9297: PPUSH
9298: LD_INT 2
9300: PPUSH
9301: CALL_OW 12
9305: ARRAY
9306: PPUSH
9307: LD_INT 1
9309: PPUSH
9310: LD_INT 45
9312: PUSH
9313: LD_INT 47
9315: PUSH
9316: LD_INT 47
9318: PUSH
9319: EMPTY
9320: LIST
9321: LIST
9322: LIST
9323: PUSH
9324: LD_VAR 0 3
9328: PUSH
9329: LD_INT 3
9331: MOD
9332: PUSH
9333: LD_INT 1
9335: PLUS
9336: ARRAY
9337: PPUSH
9338: LD_INT 80
9340: PPUSH
9341: CALL 72350 0 5
// result := result union CreateVehicle ;
9345: LD_ADDR_VAR 0 2
9349: PUSH
9350: LD_VAR 0 2
9354: PUSH
9355: CALL_OW 45
9359: UNION
9360: ST_TO_ADDR
// end ;
9361: GO 9254
9363: POP
9364: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9365: LD_INT 24
9367: PPUSH
9368: LD_INT 3
9370: PPUSH
9371: LD_INT 1
9373: PPUSH
9374: LD_INT 47
9376: PPUSH
9377: LD_INT 100
9379: PPUSH
9380: CALL 72350 0 5
// sewiVeh := CreateVehicle ;
9384: LD_ADDR_EXP 72
9388: PUSH
9389: CALL_OW 45
9393: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9394: LD_EXP 72
9398: PPUSH
9399: LD_INT 6
9401: NEG
9402: PPUSH
9403: CALL_OW 242
// result := result union sewiVeh ;
9407: LD_ADDR_VAR 0 2
9411: PUSH
9412: LD_VAR 0 2
9416: PUSH
9417: LD_EXP 72
9421: UNION
9422: ST_TO_ADDR
// end ; end ; end ;
9423: GO 9426
9425: POP
// end ;
9426: LD_VAR 0 2
9430: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9431: LD_EXP 16
9435: IFFALSE 10106
9437: GO 9439
9439: DISABLE
9440: LD_INT 0
9442: PPUSH
9443: PPUSH
9444: PPUSH
9445: PPUSH
9446: PPUSH
9447: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9448: LD_ADDR_VAR 0 4
9452: PUSH
9453: LD_INT 11
9455: PUSH
9456: LD_INT 12
9458: PUSH
9459: EMPTY
9460: LIST
9461: LIST
9462: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9463: LD_ADDR_VAR 0 3
9467: PUSH
9468: LD_INT 11550
9470: PUSH
9471: LD_INT 10150
9473: PUSH
9474: LD_INT 9800
9476: PUSH
9477: LD_INT 9450
9479: PUSH
9480: EMPTY
9481: LIST
9482: LIST
9483: LIST
9484: LIST
9485: PUSH
9486: LD_OWVAR 67
9490: ARRAY
9491: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9492: LD_ADDR_VAR 0 6
9496: PUSH
9497: LD_INT 70
9499: PUSH
9500: LD_INT 118
9502: PUSH
9503: EMPTY
9504: LIST
9505: LIST
9506: PUSH
9507: LD_INT 78
9509: PUSH
9510: LD_INT 31
9512: PUSH
9513: EMPTY
9514: LIST
9515: LIST
9516: PUSH
9517: EMPTY
9518: LIST
9519: LIST
9520: ST_TO_ADDR
// repeat if missionStage = 2 then
9521: LD_EXP 15
9525: PUSH
9526: LD_INT 2
9528: EQUAL
9529: IFFALSE 9540
// wait ( 1 1$30 ) else
9531: LD_INT 3150
9533: PPUSH
9534: CALL_OW 67
9538: GO 9549
// wait ( time ) ;
9540: LD_VAR 0 3
9544: PPUSH
9545: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
9549: LD_EXP 15
9553: PUSH
9554: LD_INT 6
9556: EQUAL
9557: PUSH
9558: LD_OWVAR 67
9562: PUSH
9563: LD_INT 2
9565: GREATER
9566: OR
9567: IFFALSE 9595
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9569: LD_INT 51
9571: PPUSH
9572: LD_INT 6
9574: PPUSH
9575: LD_INT 2
9577: PPUSH
9578: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9582: LD_INT 57
9584: PPUSH
9585: LD_INT 6
9587: PPUSH
9588: LD_INT 2
9590: PPUSH
9591: CALL_OW 322
// end ; if missionStage = 8 then
9595: LD_EXP 15
9599: PUSH
9600: LD_INT 8
9602: EQUAL
9603: IFFALSE 9631
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9605: LD_INT 52
9607: PPUSH
9608: LD_INT 6
9610: PPUSH
9611: LD_INT 2
9613: PPUSH
9614: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9618: LD_INT 58
9620: PPUSH
9621: LD_INT 6
9623: PPUSH
9624: LD_INT 2
9626: PPUSH
9627: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9631: LD_EXP 15
9635: PUSH
9636: LD_INT 10
9638: EQUAL
9639: PUSH
9640: LD_OWVAR 67
9644: PUSH
9645: LD_INT 1
9647: GREATER
9648: AND
9649: IFFALSE 9677
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9651: LD_INT 53
9653: PPUSH
9654: LD_INT 6
9656: PPUSH
9657: LD_INT 2
9659: PPUSH
9660: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9664: LD_INT 59
9666: PPUSH
9667: LD_INT 6
9669: PPUSH
9670: LD_INT 2
9672: PPUSH
9673: CALL_OW 322
// end ; if activeAttacks then
9677: LD_EXP 16
9681: IFFALSE 10100
// begin if missionStage = 2 then
9683: LD_EXP 15
9687: PUSH
9688: LD_INT 2
9690: EQUAL
9691: IFFALSE 9701
// strength := 1 ;
9693: LD_ADDR_VAR 0 5
9697: PUSH
9698: LD_INT 1
9700: ST_TO_ADDR
// if missionStage > 2 then
9701: LD_EXP 15
9705: PUSH
9706: LD_INT 2
9708: GREATER
9709: IFFALSE 9719
// strength := 2 ;
9711: LD_ADDR_VAR 0 5
9715: PUSH
9716: LD_INT 2
9718: ST_TO_ADDR
// if missionStage > 6 then
9719: LD_EXP 15
9723: PUSH
9724: LD_INT 6
9726: GREATER
9727: IFFALSE 9737
// strength := 3 ;
9729: LD_ADDR_VAR 0 5
9733: PUSH
9734: LD_INT 3
9736: ST_TO_ADDR
// if missionStage > 10 then
9737: LD_EXP 15
9741: PUSH
9742: LD_INT 10
9744: GREATER
9745: IFFALSE 9755
// strength := 4 ;
9747: LD_ADDR_VAR 0 5
9751: PUSH
9752: LD_INT 4
9754: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9755: LD_ADDR_VAR 0 2
9759: PUSH
9760: LD_VAR 0 5
9764: PPUSH
9765: CALL 8248 0 1
9769: ST_TO_ADDR
// for i in tmp do
9770: LD_ADDR_VAR 0 1
9774: PUSH
9775: LD_VAR 0 2
9779: PUSH
9780: FOR_IN
9781: IFFALSE 9990
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9783: LD_VAR 0 1
9787: PPUSH
9788: LD_VAR 0 4
9792: PUSH
9793: LD_INT 1
9795: PPUSH
9796: LD_INT 2
9798: PPUSH
9799: CALL_OW 12
9803: ARRAY
9804: PPUSH
9805: LD_INT 0
9807: PPUSH
9808: CALL_OW 49
// if i = sewiVeh then
9812: LD_VAR 0 1
9816: PUSH
9817: LD_EXP 72
9821: EQUAL
9822: IFFALSE 9859
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9824: LD_ADDR_EXP 71
9828: PUSH
9829: LD_STRING Vsevolod
9831: PPUSH
9832: LD_INT 0
9834: PPUSH
9835: LD_STRING 
9837: PPUSH
9838: CALL 67335 0 3
9842: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9843: LD_EXP 71
9847: PPUSH
9848: LD_VAR 0 1
9852: PPUSH
9853: CALL_OW 52
// end else
9857: GO 9940
// if GetControl ( i ) = control_manual then
9859: LD_VAR 0 1
9863: PPUSH
9864: CALL_OW 263
9868: PUSH
9869: LD_INT 1
9871: EQUAL
9872: IFFALSE 9940
// begin uc_side := 6 ;
9874: LD_ADDR_OWVAR 20
9878: PUSH
9879: LD_INT 6
9881: ST_TO_ADDR
// uc_nation := 3 ;
9882: LD_ADDR_OWVAR 21
9886: PUSH
9887: LD_INT 3
9889: ST_TO_ADDR
// hc_gallery :=  ;
9890: LD_ADDR_OWVAR 33
9894: PUSH
9895: LD_STRING 
9897: ST_TO_ADDR
// hc_name :=  ;
9898: LD_ADDR_OWVAR 26
9902: PUSH
9903: LD_STRING 
9905: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9906: LD_INT 0
9908: PPUSH
9909: LD_INT 3
9911: PPUSH
9912: LD_INT 10
9914: PPUSH
9915: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9919: CALL_OW 44
9923: PPUSH
9924: LD_VAR 0 1
9928: PPUSH
9929: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9933: LD_INT 10
9935: PPUSH
9936: CALL_OW 67
// end ; if Prob ( 50 ) then
9940: LD_INT 50
9942: PPUSH
9943: CALL_OW 13
9947: IFFALSE 9966
// ComMoveXY ( i , 111 , 197 ) else
9949: LD_VAR 0 1
9953: PPUSH
9954: LD_INT 111
9956: PPUSH
9957: LD_INT 197
9959: PPUSH
9960: CALL_OW 111
9964: GO 9981
// ComMoveXY ( i , 91 , 165 ) ;
9966: LD_VAR 0 1
9970: PPUSH
9971: LD_INT 91
9973: PPUSH
9974: LD_INT 165
9976: PPUSH
9977: CALL_OW 111
// wait ( 0 0$2 ) ;
9981: LD_INT 70
9983: PPUSH
9984: CALL_OW 67
// end ;
9988: GO 9780
9990: POP
9991: POP
// repeat wait ( 0 0$1 ) ;
9992: LD_INT 35
9994: PPUSH
9995: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
9999: LD_ADDR_VAR 0 1
10003: PUSH
10004: LD_VAR 0 2
10008: PPUSH
10009: LD_INT 50
10011: PUSH
10012: EMPTY
10013: LIST
10014: PPUSH
10015: CALL_OW 72
10019: PUSH
10020: FOR_IN
10021: IFFALSE 10080
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10023: LD_VAR 0 1
10027: PPUSH
10028: LD_INT 108
10030: PUSH
10031: LD_INT 153
10033: PUSH
10034: EMPTY
10035: LIST
10036: LIST
10037: PUSH
10038: LD_INT 105
10040: PUSH
10041: LD_INT 149
10043: PUSH
10044: EMPTY
10045: LIST
10046: LIST
10047: PUSH
10048: LD_INT 85
10050: PUSH
10051: LD_INT 131
10053: PUSH
10054: EMPTY
10055: LIST
10056: LIST
10057: PUSH
10058: LD_INT 64
10060: PUSH
10061: LD_INT 105
10063: PUSH
10064: EMPTY
10065: LIST
10066: LIST
10067: PUSH
10068: EMPTY
10069: LIST
10070: LIST
10071: LIST
10072: LIST
10073: PPUSH
10074: CALL 107388 0 2
10078: GO 10020
10080: POP
10081: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
10082: LD_VAR 0 2
10086: PPUSH
10087: LD_INT 50
10089: PUSH
10090: EMPTY
10091: LIST
10092: PPUSH
10093: CALL_OW 72
10097: NOT
10098: IFFALSE 9992
// end ; until russianDestroyed ;
10100: LD_EXP 21
10104: IFFALSE 9521
// end ;
10106: PPOPN 6
10108: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10109: LD_EXP 21
10113: NOT
10114: PUSH
10115: LD_EXP 15
10119: PUSH
10120: LD_INT 6
10122: GREATEREQUAL
10123: AND
10124: PUSH
10125: LD_INT 2
10127: PPUSH
10128: LD_INT 1
10130: PPUSH
10131: CALL 62365 0 2
10135: NOT
10136: AND
10137: IFFALSE 11076
10139: GO 10141
10141: DISABLE
10142: LD_INT 0
10144: PPUSH
10145: PPUSH
10146: PPUSH
10147: PPUSH
// begin enable ;
10148: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10149: LD_INT 22
10151: PUSH
10152: LD_INT 3
10154: PUSH
10155: EMPTY
10156: LIST
10157: LIST
10158: PUSH
10159: LD_INT 30
10161: PUSH
10162: LD_INT 3
10164: PUSH
10165: EMPTY
10166: LIST
10167: LIST
10168: PUSH
10169: EMPTY
10170: LIST
10171: LIST
10172: PPUSH
10173: CALL_OW 69
10177: NOT
10178: IFFALSE 10182
// exit ;
10180: GO 11076
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10182: LD_ADDR_VAR 0 4
10186: PUSH
10187: LD_INT 22
10189: PUSH
10190: LD_INT 3
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: PUSH
10197: LD_INT 30
10199: PUSH
10200: LD_INT 34
10202: PUSH
10203: EMPTY
10204: LIST
10205: LIST
10206: PUSH
10207: EMPTY
10208: LIST
10209: LIST
10210: PPUSH
10211: CALL_OW 69
10215: ST_TO_ADDR
// if Prob ( 40 ) then
10216: LD_INT 40
10218: PPUSH
10219: CALL_OW 13
10223: IFFALSE 10369
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10225: LD_INT 2
10227: PPUSH
10228: LD_INT 22
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: LD_INT 3
10236: PUSH
10237: LD_INT 49
10239: PUSH
10240: EMPTY
10241: LIST
10242: LIST
10243: LIST
10244: LIST
10245: PUSH
10246: LD_INT 22
10248: PUSH
10249: LD_INT 3
10251: PUSH
10252: LD_INT 3
10254: PUSH
10255: LD_INT 49
10257: PUSH
10258: EMPTY
10259: LIST
10260: LIST
10261: LIST
10262: LIST
10263: PUSH
10264: LD_INT 22
10266: PUSH
10267: LD_INT 3
10269: PUSH
10270: LD_INT 3
10272: PUSH
10273: LD_INT 49
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: LIST
10280: LIST
10281: PUSH
10282: LD_INT 24
10284: PUSH
10285: LD_INT 3
10287: PUSH
10288: LD_INT 3
10290: PUSH
10291: LD_INT 46
10293: PUSH
10294: EMPTY
10295: LIST
10296: LIST
10297: LIST
10298: LIST
10299: PUSH
10300: LD_INT 24
10302: PUSH
10303: LD_INT 3
10305: PUSH
10306: LD_INT 3
10308: PUSH
10309: LD_INT 46
10311: PUSH
10312: EMPTY
10313: LIST
10314: LIST
10315: LIST
10316: LIST
10317: PUSH
10318: LD_INT 24
10320: PUSH
10321: LD_INT 3
10323: PUSH
10324: LD_INT 3
10326: PUSH
10327: LD_INT 46
10329: PUSH
10330: EMPTY
10331: LIST
10332: LIST
10333: LIST
10334: LIST
10335: PUSH
10336: LD_INT 24
10338: PUSH
10339: LD_INT 3
10341: PUSH
10342: LD_INT 3
10344: PUSH
10345: LD_INT 46
10347: PUSH
10348: EMPTY
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: PUSH
10354: EMPTY
10355: LIST
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: PPUSH
10363: CALL 60947 0 2
// end else
10367: GO 10511
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10369: LD_INT 2
10371: PPUSH
10372: LD_INT 24
10374: PUSH
10375: LD_INT 3
10377: PUSH
10378: LD_INT 3
10380: PUSH
10381: LD_INT 47
10383: PUSH
10384: EMPTY
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: PUSH
10390: LD_INT 24
10392: PUSH
10393: LD_INT 3
10395: PUSH
10396: LD_INT 3
10398: PUSH
10399: LD_INT 47
10401: PUSH
10402: EMPTY
10403: LIST
10404: LIST
10405: LIST
10406: LIST
10407: PUSH
10408: LD_INT 24
10410: PUSH
10411: LD_INT 3
10413: PUSH
10414: LD_INT 3
10416: PUSH
10417: LD_INT 47
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: LIST
10424: LIST
10425: PUSH
10426: LD_INT 24
10428: PUSH
10429: LD_INT 3
10431: PUSH
10432: LD_INT 3
10434: PUSH
10435: LD_INT 46
10437: PUSH
10438: EMPTY
10439: LIST
10440: LIST
10441: LIST
10442: LIST
10443: PUSH
10444: LD_INT 24
10446: PUSH
10447: LD_INT 3
10449: PUSH
10450: LD_INT 3
10452: PUSH
10453: LD_INT 46
10455: PUSH
10456: EMPTY
10457: LIST
10458: LIST
10459: LIST
10460: LIST
10461: PUSH
10462: LD_INT 24
10464: PUSH
10465: LD_INT 3
10467: PUSH
10468: LD_INT 3
10470: PUSH
10471: LD_INT 46
10473: PUSH
10474: EMPTY
10475: LIST
10476: LIST
10477: LIST
10478: LIST
10479: PUSH
10480: LD_INT 24
10482: PUSH
10483: LD_INT 3
10485: PUSH
10486: LD_INT 3
10488: PUSH
10489: LD_INT 46
10491: PUSH
10492: EMPTY
10493: LIST
10494: LIST
10495: LIST
10496: LIST
10497: PUSH
10498: EMPTY
10499: LIST
10500: LIST
10501: LIST
10502: LIST
10503: LIST
10504: LIST
10505: LIST
10506: PPUSH
10507: CALL 60947 0 2
// end ; repeat wait ( 0 0$1 ) ;
10511: LD_INT 35
10513: PPUSH
10514: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= 7 ;
10518: LD_INT 2
10520: PPUSH
10521: LD_INT 1
10523: PPUSH
10524: CALL 62365 0 2
10528: PUSH
10529: LD_INT 7
10531: GREATEREQUAL
10532: IFFALSE 10511
// wait ( 0 0$10 ) ;
10534: LD_INT 350
10536: PPUSH
10537: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10541: LD_ADDR_VAR 0 2
10545: PUSH
10546: LD_INT 2
10548: PPUSH
10549: LD_INT 1
10551: PPUSH
10552: CALL 62365 0 2
10556: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10557: LD_ADDR_EXP 118
10561: PUSH
10562: LD_EXP 118
10566: PPUSH
10567: LD_INT 2
10569: PPUSH
10570: LD_EXP 118
10574: PUSH
10575: LD_INT 2
10577: ARRAY
10578: PUSH
10579: LD_VAR 0 2
10583: DIFF
10584: PPUSH
10585: CALL_OW 1
10589: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10590: LD_ADDR_VAR 0 3
10594: PUSH
10595: LD_INT 0
10597: PPUSH
10598: LD_INT 1
10600: PPUSH
10601: CALL_OW 12
10605: ST_TO_ADDR
// if target then
10606: LD_VAR 0 3
10610: IFFALSE 10738
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10612: LD_ADDR_VAR 0 2
10616: PUSH
10617: LD_VAR 0 2
10621: PPUSH
10622: LD_INT 24
10624: PUSH
10625: LD_INT 250
10627: PUSH
10628: EMPTY
10629: LIST
10630: LIST
10631: PPUSH
10632: CALL_OW 72
10636: ST_TO_ADDR
// for i in tmp do
10637: LD_ADDR_VAR 0 1
10641: PUSH
10642: LD_VAR 0 2
10646: PUSH
10647: FOR_IN
10648: IFFALSE 10688
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10650: LD_VAR 0 1
10654: PPUSH
10655: LD_INT 139
10657: PPUSH
10658: LD_INT 89
10660: PPUSH
10661: CALL_OW 297
10665: PUSH
10666: LD_INT 9
10668: GREATER
10669: IFFALSE 10686
// ComMoveXY ( i , 139 , 89 ) ;
10671: LD_VAR 0 1
10675: PPUSH
10676: LD_INT 139
10678: PPUSH
10679: LD_INT 89
10681: PPUSH
10682: CALL_OW 111
10686: GO 10647
10688: POP
10689: POP
// wait ( 0 0$1 ) ;
10690: LD_INT 35
10692: PPUSH
10693: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10697: LD_VAR 0 2
10701: PPUSH
10702: LD_INT 92
10704: PUSH
10705: LD_INT 139
10707: PUSH
10708: LD_INT 89
10710: PUSH
10711: LD_INT 9
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: LIST
10718: LIST
10719: PPUSH
10720: CALL_OW 72
10724: PUSH
10725: LD_VAR 0 2
10729: PUSH
10730: LD_INT 1
10732: MINUS
10733: GREATEREQUAL
10734: IFFALSE 10612
// end else
10736: GO 10880
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10738: LD_VAR 0 2
10742: PPUSH
10743: LD_VAR 0 4
10747: PUSH
10748: LD_INT 1
10750: ARRAY
10751: PPUSH
10752: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10756: LD_ADDR_VAR 0 2
10760: PUSH
10761: LD_VAR 0 2
10765: PPUSH
10766: LD_INT 24
10768: PUSH
10769: LD_INT 250
10771: PUSH
10772: EMPTY
10773: LIST
10774: LIST
10775: PPUSH
10776: CALL_OW 72
10780: ST_TO_ADDR
// for i in tmp do
10781: LD_ADDR_VAR 0 1
10785: PUSH
10786: LD_VAR 0 2
10790: PUSH
10791: FOR_IN
10792: IFFALSE 10832
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10794: LD_VAR 0 1
10798: PPUSH
10799: LD_INT 124
10801: PPUSH
10802: LD_INT 139
10804: PPUSH
10805: CALL_OW 297
10809: PUSH
10810: LD_INT 9
10812: GREATER
10813: IFFALSE 10830
// ComMoveXY ( i , 124 , 139 ) ;
10815: LD_VAR 0 1
10819: PPUSH
10820: LD_INT 124
10822: PPUSH
10823: LD_INT 139
10825: PPUSH
10826: CALL_OW 111
10830: GO 10791
10832: POP
10833: POP
// wait ( 0 0$1 ) ;
10834: LD_INT 35
10836: PPUSH
10837: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10841: LD_VAR 0 2
10845: PPUSH
10846: LD_INT 92
10848: PUSH
10849: LD_INT 124
10851: PUSH
10852: LD_INT 139
10854: PUSH
10855: LD_INT 9
10857: PUSH
10858: EMPTY
10859: LIST
10860: LIST
10861: LIST
10862: LIST
10863: PPUSH
10864: CALL_OW 72
10868: PUSH
10869: LD_VAR 0 2
10873: PUSH
10874: LD_INT 1
10876: MINUS
10877: GREATEREQUAL
10878: IFFALSE 10756
// end ; repeat wait ( 0 0$1 ) ;
10880: LD_INT 35
10882: PPUSH
10883: CALL_OW 67
// for i in tmp do
10887: LD_ADDR_VAR 0 1
10891: PUSH
10892: LD_VAR 0 2
10896: PUSH
10897: FOR_IN
10898: IFFALSE 11067
// begin if GetLives ( i ) > 251 then
10900: LD_VAR 0 1
10904: PPUSH
10905: CALL_OW 256
10909: PUSH
10910: LD_INT 251
10912: GREATER
10913: IFFALSE 11038
// begin if GetWeapon ( i ) = ru_time_lapser then
10915: LD_VAR 0 1
10919: PPUSH
10920: CALL_OW 264
10924: PUSH
10925: LD_INT 49
10927: EQUAL
10928: IFFALSE 10984
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10930: LD_VAR 0 1
10934: PPUSH
10935: LD_INT 2
10937: PUSH
10938: LD_INT 22
10940: PUSH
10941: LD_INT 1
10943: PUSH
10944: EMPTY
10945: LIST
10946: LIST
10947: PUSH
10948: LD_INT 22
10950: PUSH
10951: LD_INT 8
10953: PUSH
10954: EMPTY
10955: LIST
10956: LIST
10957: PUSH
10958: EMPTY
10959: LIST
10960: LIST
10961: LIST
10962: PPUSH
10963: CALL_OW 69
10967: PPUSH
10968: LD_VAR 0 1
10972: PPUSH
10973: CALL_OW 74
10977: PPUSH
10978: CALL_OW 112
10982: GO 11036
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10984: LD_VAR 0 1
10988: PPUSH
10989: LD_INT 2
10991: PUSH
10992: LD_INT 22
10994: PUSH
10995: LD_INT 1
10997: PUSH
10998: EMPTY
10999: LIST
11000: LIST
11001: PUSH
11002: LD_INT 22
11004: PUSH
11005: LD_INT 8
11007: PUSH
11008: EMPTY
11009: LIST
11010: LIST
11011: PUSH
11012: EMPTY
11013: LIST
11014: LIST
11015: LIST
11016: PPUSH
11017: CALL_OW 69
11021: PPUSH
11022: LD_VAR 0 1
11026: PPUSH
11027: CALL_OW 74
11031: PPUSH
11032: CALL_OW 115
// end else
11036: GO 11065
// if IsDead ( i ) then
11038: LD_VAR 0 1
11042: PPUSH
11043: CALL_OW 301
11047: IFFALSE 11065
// tmp := tmp diff i ;
11049: LD_ADDR_VAR 0 2
11053: PUSH
11054: LD_VAR 0 2
11058: PUSH
11059: LD_VAR 0 1
11063: DIFF
11064: ST_TO_ADDR
// end ;
11065: GO 10897
11067: POP
11068: POP
// until not tmp ;
11069: LD_VAR 0 2
11073: NOT
11074: IFFALSE 10880
// end ;
11076: PPOPN 4
11078: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 8 and Difficulty > 1 do var i , veh , un ;
11079: LD_EXP 15
11083: PUSH
11084: LD_INT 8
11086: GREATEREQUAL
11087: PUSH
11088: LD_OWVAR 67
11092: PUSH
11093: LD_INT 1
11095: GREATER
11096: AND
11097: IFFALSE 11281
11099: GO 11101
11101: DISABLE
11102: LD_INT 0
11104: PPUSH
11105: PPUSH
11106: PPUSH
// begin ruMobile := [ ] ;
11107: LD_ADDR_EXP 75
11111: PUSH
11112: EMPTY
11113: ST_TO_ADDR
// for i := 1 to [ 3 , 4 , 5 ] [ Difficulty - 1 ] do
11114: LD_ADDR_VAR 0 1
11118: PUSH
11119: DOUBLE
11120: LD_INT 1
11122: DEC
11123: ST_TO_ADDR
11124: LD_INT 3
11126: PUSH
11127: LD_INT 4
11129: PUSH
11130: LD_INT 5
11132: PUSH
11133: EMPTY
11134: LIST
11135: LIST
11136: LIST
11137: PUSH
11138: LD_OWVAR 67
11142: PUSH
11143: LD_INT 1
11145: MINUS
11146: ARRAY
11147: PUSH
11148: FOR_TO
11149: IFFALSE 11279
// begin uc_side := 3 ;
11151: LD_ADDR_OWVAR 20
11155: PUSH
11156: LD_INT 3
11158: ST_TO_ADDR
// uc_nation := 3 ;
11159: LD_ADDR_OWVAR 21
11163: PUSH
11164: LD_INT 3
11166: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
11167: LD_INT 21
11169: PPUSH
11170: LD_INT 3
11172: PPUSH
11173: LD_INT 1
11175: PPUSH
11176: LD_INT 45
11178: PPUSH
11179: LD_INT 100
11181: PPUSH
11182: CALL 72350 0 5
// veh := CreateVehicle ;
11186: LD_ADDR_VAR 0 2
11190: PUSH
11191: CALL_OW 45
11195: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11196: LD_VAR 0 2
11200: PPUSH
11201: LD_INT 3
11203: PPUSH
11204: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11208: LD_VAR 0 2
11212: PPUSH
11213: LD_INT 29
11215: PPUSH
11216: LD_INT 0
11218: PPUSH
11219: CALL_OW 49
// PrepareMechanic ( false , 10 ) ;
11223: LD_INT 0
11225: PPUSH
11226: LD_INT 10
11228: PPUSH
11229: CALL_OW 383
// un := CreateHuman ;
11233: LD_ADDR_VAR 0 3
11237: PUSH
11238: CALL_OW 44
11242: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
11243: LD_VAR 0 3
11247: PPUSH
11248: LD_VAR 0 2
11252: PPUSH
11253: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
11257: LD_ADDR_EXP 75
11261: PUSH
11262: LD_EXP 75
11266: PPUSH
11267: LD_VAR 0 2
11271: PPUSH
11272: CALL 104784 0 2
11276: ST_TO_ADDR
// end ;
11277: GO 11148
11279: POP
11280: POP
// end ;
11281: PPOPN 3
11283: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
11284: LD_EXP 75
11288: IFFALSE 11796
11290: GO 11292
11292: DISABLE
11293: LD_INT 0
11295: PPUSH
11296: PPUSH
11297: PPUSH
// begin enable ;
11298: ENABLE
// if not ruMobile then
11299: LD_EXP 75
11303: NOT
11304: IFFALSE 11308
// exit ;
11306: GO 11796
// for i in ruMobile do
11308: LD_ADDR_VAR 0 1
11312: PUSH
11313: LD_EXP 75
11317: PUSH
11318: FOR_IN
11319: IFFALSE 11794
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
11321: LD_VAR 0 1
11325: PPUSH
11326: CALL_OW 302
11330: NOT
11331: PUSH
11332: LD_VAR 0 1
11336: PPUSH
11337: CALL_OW 255
11341: PUSH
11342: LD_INT 3
11344: NONEQUAL
11345: OR
11346: IFFALSE 11366
// begin ruMobile := ruMobile diff i ;
11348: LD_ADDR_EXP 75
11352: PUSH
11353: LD_EXP 75
11357: PUSH
11358: LD_VAR 0 1
11362: DIFF
11363: ST_TO_ADDR
// continue ;
11364: GO 11318
// end ; if GetTag ( i ) = 300 then
11366: LD_VAR 0 1
11370: PPUSH
11371: CALL_OW 110
11375: PUSH
11376: LD_INT 300
11378: EQUAL
11379: IFFALSE 11429
// begin ComMoveXY ( i , 160 , 81 ) ;
11381: LD_VAR 0 1
11385: PPUSH
11386: LD_INT 160
11388: PPUSH
11389: LD_INT 81
11391: PPUSH
11392: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
11396: LD_VAR 0 1
11400: PPUSH
11401: LD_INT 160
11403: PPUSH
11404: LD_INT 81
11406: PPUSH
11407: CALL_OW 297
11411: PUSH
11412: LD_INT 8
11414: LESS
11415: IFFALSE 11429
// SetTag ( i , 301 ) ;
11417: LD_VAR 0 1
11421: PPUSH
11422: LD_INT 301
11424: PPUSH
11425: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
11429: LD_VAR 0 1
11433: PPUSH
11434: CALL_OW 110
11438: PUSH
11439: LD_INT 301
11441: EQUAL
11442: IFFALSE 11485
// begin if not IsInArea ( i , ruMobileParkingArea ) then
11444: LD_VAR 0 1
11448: PPUSH
11449: LD_INT 33
11451: PPUSH
11452: CALL_OW 308
11456: NOT
11457: IFFALSE 11473
// ComMoveToArea ( i , ruMobileParkingArea ) else
11459: LD_VAR 0 1
11463: PPUSH
11464: LD_INT 33
11466: PPUSH
11467: CALL_OW 113
11471: GO 11485
// SetTag ( i , 302 ) ;
11473: LD_VAR 0 1
11477: PPUSH
11478: LD_INT 302
11480: PPUSH
11481: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
11485: LD_VAR 0 1
11489: PPUSH
11490: CALL_OW 110
11494: PUSH
11495: LD_INT 302
11497: EQUAL
11498: IFFALSE 11628
// begin if GetLives ( i ) < 1000 then
11500: LD_VAR 0 1
11504: PPUSH
11505: CALL_OW 256
11509: PUSH
11510: LD_INT 1000
11512: LESS
11513: IFFALSE 11605
// begin if not IsDrivenBy ( i ) then
11515: LD_VAR 0 1
11519: PPUSH
11520: CALL_OW 311
11524: NOT
11525: IFFALSE 11529
// continue ;
11527: GO 11318
// mech := IsDrivenBy ( i ) ;
11529: LD_ADDR_VAR 0 2
11533: PUSH
11534: LD_VAR 0 1
11538: PPUSH
11539: CALL_OW 311
11543: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
11544: LD_VAR 0 2
11548: PPUSH
11549: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
11553: LD_VAR 0 2
11557: PPUSH
11558: LD_VAR 0 1
11562: PPUSH
11563: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
11567: LD_INT 35
11569: PPUSH
11570: CALL_OW 67
// until GetLives ( i ) = 1000 ;
11574: LD_VAR 0 1
11578: PPUSH
11579: CALL_OW 256
11583: PUSH
11584: LD_INT 1000
11586: EQUAL
11587: IFFALSE 11567
// ComEnterUnit ( mech , i ) ;
11589: LD_VAR 0 2
11593: PPUSH
11594: LD_VAR 0 1
11598: PPUSH
11599: CALL_OW 120
// end else
11603: GO 11628
// if IsDrivenBy ( i ) then
11605: LD_VAR 0 1
11609: PPUSH
11610: CALL_OW 311
11614: IFFALSE 11628
// SetTag ( i , 0 ) ;
11616: LD_VAR 0 1
11620: PPUSH
11621: LD_INT 0
11623: PPUSH
11624: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
11628: LD_VAR 0 1
11632: PPUSH
11633: CALL_OW 110
11637: PUSH
11638: LD_INT 300
11640: LESS
11641: IFFALSE 11792
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
11643: LD_ADDR_VAR 0 3
11647: PUSH
11648: LD_INT 4
11650: PPUSH
11651: LD_INT 81
11653: PUSH
11654: LD_INT 3
11656: PUSH
11657: EMPTY
11658: LIST
11659: LIST
11660: PPUSH
11661: CALL_OW 70
11665: ST_TO_ADDR
// if GetLives ( i ) < 650 then
11666: LD_VAR 0 1
11670: PPUSH
11671: CALL_OW 256
11675: PUSH
11676: LD_INT 650
11678: LESS
11679: IFFALSE 11704
// begin ComStop ( i ) ;
11681: LD_VAR 0 1
11685: PPUSH
11686: CALL_OW 141
// SetTag ( i , 300 ) ;
11690: LD_VAR 0 1
11694: PPUSH
11695: LD_INT 300
11697: PPUSH
11698: CALL_OW 109
// continue ;
11702: GO 11318
// end ; if enemy then
11704: LD_VAR 0 3
11708: IFFALSE 11748
// begin if not HasTask ( i ) then
11710: LD_VAR 0 1
11714: PPUSH
11715: CALL_OW 314
11719: NOT
11720: IFFALSE 11746
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
11722: LD_VAR 0 1
11726: PPUSH
11727: LD_VAR 0 3
11731: PPUSH
11732: LD_VAR 0 1
11736: PPUSH
11737: CALL_OW 74
11741: PPUSH
11742: CALL_OW 115
// end else
11746: GO 11792
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
11748: LD_VAR 0 1
11752: PPUSH
11753: LD_INT 158
11755: PUSH
11756: LD_INT 61
11758: PUSH
11759: EMPTY
11760: LIST
11761: LIST
11762: PUSH
11763: LD_INT 98
11765: PUSH
11766: LD_INT 100
11768: PUSH
11769: EMPTY
11770: LIST
11771: LIST
11772: PUSH
11773: LD_INT 78
11775: PUSH
11776: LD_INT 93
11778: PUSH
11779: EMPTY
11780: LIST
11781: LIST
11782: PUSH
11783: EMPTY
11784: LIST
11785: LIST
11786: LIST
11787: PPUSH
11788: CALL 107388 0 2
// end ; end ;
11792: GO 11318
11794: POP
11795: POP
// end ; end_of_file
11796: PPOPN 3
11798: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11799: LD_INT 0
11801: PPUSH
11802: PPUSH
11803: PPUSH
11804: PPUSH
11805: PPUSH
11806: PPUSH
// side := 7 ;
11807: LD_ADDR_VAR 0 5
11811: PUSH
11812: LD_INT 7
11814: ST_TO_ADDR
// uc_side := side ;
11815: LD_ADDR_OWVAR 20
11819: PUSH
11820: LD_VAR 0 5
11824: ST_TO_ADDR
// uc_nation := 1 ;
11825: LD_ADDR_OWVAR 21
11829: PUSH
11830: LD_INT 1
11832: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11833: LD_ADDR_VAR 0 2
11837: PUSH
11838: LD_INT 22
11840: PUSH
11841: LD_VAR 0 5
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: PUSH
11850: LD_INT 21
11852: PUSH
11853: LD_INT 3
11855: PUSH
11856: EMPTY
11857: LIST
11858: LIST
11859: PUSH
11860: EMPTY
11861: LIST
11862: LIST
11863: PPUSH
11864: CALL_OW 69
11868: PUSH
11869: FOR_IN
11870: IFFALSE 11886
// SetBLevel ( i , 10 ) ;
11872: LD_VAR 0 2
11876: PPUSH
11877: LD_INT 10
11879: PPUSH
11880: CALL_OW 241
11884: GO 11869
11886: POP
11887: POP
// base := GetBase ( al_depot ) ;
11888: LD_ADDR_VAR 0 4
11892: PUSH
11893: LD_INT 2
11895: PPUSH
11896: CALL_OW 274
11900: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11901: LD_ADDR_VAR 0 6
11905: PUSH
11906: LD_INT 22
11908: PUSH
11909: LD_VAR 0 5
11913: PUSH
11914: EMPTY
11915: LIST
11916: LIST
11917: PUSH
11918: LD_INT 30
11920: PUSH
11921: LD_INT 34
11923: PUSH
11924: EMPTY
11925: LIST
11926: LIST
11927: PUSH
11928: EMPTY
11929: LIST
11930: LIST
11931: PPUSH
11932: CALL_OW 69
11936: ST_TO_ADDR
// if teleport then
11937: LD_VAR 0 6
11941: IFFALSE 11962
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11943: LD_VAR 0 6
11947: PUSH
11948: LD_INT 1
11950: ARRAY
11951: PPUSH
11952: LD_INT 262
11954: PPUSH
11955: LD_INT 119
11957: PPUSH
11958: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11962: LD_VAR 0 4
11966: PPUSH
11967: LD_INT 1
11969: PPUSH
11970: LD_INT 19500
11972: PPUSH
11973: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11977: LD_VAR 0 4
11981: PPUSH
11982: LD_INT 2
11984: PPUSH
11985: LD_INT 200
11987: PPUSH
11988: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11992: LD_VAR 0 4
11996: PPUSH
11997: LD_INT 3
11999: PPUSH
12000: LD_INT 650
12002: PPUSH
12003: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12007: LD_ADDR_EXP 76
12011: PUSH
12012: LD_STRING Roth
12014: PPUSH
12015: CALL_OW 25
12019: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12020: LD_ADDR_EXP 77
12024: PUSH
12025: LD_STRING Simms
12027: PPUSH
12028: LD_EXP 1
12032: NOT
12033: PPUSH
12034: LD_STRING 10c_
12036: PPUSH
12037: CALL 67335 0 3
12041: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
12042: LD_EXP 77
12046: PPUSH
12047: LD_INT 4
12049: PPUSH
12050: CALL_OW 336
// if not Simms then
12054: LD_EXP 77
12058: NOT
12059: IFFALSE 12089
// begin uc_nation := 1 ;
12061: LD_ADDR_OWVAR 21
12065: PUSH
12066: LD_INT 1
12068: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12069: LD_INT 2
12071: PPUSH
12072: LD_INT 10
12074: PPUSH
12075: CALL_OW 384
// Simms := CreateHuman ;
12079: LD_ADDR_EXP 77
12083: PUSH
12084: CALL_OW 44
12088: ST_TO_ADDR
// end ; uc_nation := 3 ;
12089: LD_ADDR_OWVAR 21
12093: PUSH
12094: LD_INT 3
12096: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
12097: LD_ADDR_EXP 78
12101: PUSH
12102: LD_STRING Kirilenkova
12104: PPUSH
12105: CALL_OW 25
12109: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
12110: LD_ADDR_EXP 92
12114: PUSH
12115: LD_STRING Oblukov
12117: PPUSH
12118: CALL_OW 25
12122: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
12123: LD_ADDR_EXP 79
12127: PUSH
12128: LD_STRING Dolgov
12130: PPUSH
12131: CALL_OW 25
12135: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
12136: LD_ADDR_EXP 80
12140: PUSH
12141: LD_STRING Petrosyan
12143: PPUSH
12144: CALL_OW 25
12148: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
12149: LD_ADDR_EXP 91
12153: PUSH
12154: LD_STRING Scholtze
12156: PPUSH
12157: CALL_OW 25
12161: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
12162: LD_ADDR_EXP 90
12166: PUSH
12167: LD_STRING Kapitsova
12169: PPUSH
12170: CALL_OW 25
12174: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
12175: LD_ADDR_EXP 81
12179: PUSH
12180: LD_STRING Petrovova
12182: PPUSH
12183: CALL_OW 25
12187: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
12188: LD_ADDR_EXP 82
12192: PUSH
12193: LD_STRING Kuzmov
12195: PPUSH
12196: CALL_OW 25
12200: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
12201: LD_ADDR_EXP 89
12205: PUSH
12206: LD_STRING Karamazov
12208: PPUSH
12209: CALL_OW 25
12213: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
12214: LD_STRING 13_Lipshchin_1
12216: PPUSH
12217: LD_INT 0
12219: PPUSH
12220: CALL_OW 30
12224: IFFALSE 12239
// Lipshchin := NewCharacter ( Lipshchin ) ;
12226: LD_ADDR_EXP 83
12230: PUSH
12231: LD_STRING Lipshchin
12233: PPUSH
12234: CALL_OW 25
12238: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
12239: LD_STRING 13_Titov_1
12241: PPUSH
12242: LD_INT 0
12244: PPUSH
12245: CALL_OW 30
12249: IFFALSE 12264
// Titov := NewCharacter ( Titov ) ;
12251: LD_ADDR_EXP 85
12255: PUSH
12256: LD_STRING Titov
12258: PPUSH
12259: CALL_OW 25
12263: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
12264: LD_STRING 13_Gnyevko_1
12266: PPUSH
12267: LD_INT 0
12269: PPUSH
12270: CALL_OW 30
12274: IFFALSE 12289
// Gnyevko := NewCharacter ( Gnyevko ) ;
12276: LD_ADDR_EXP 84
12280: PUSH
12281: LD_STRING Gnyevko
12283: PPUSH
12284: CALL_OW 25
12288: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
12289: LD_STRING 13_Xavier_1
12291: PPUSH
12292: LD_INT 0
12294: PPUSH
12295: CALL_OW 30
12299: IFFALSE 12314
// Xavier := NewCharacter ( Xavier2 ) ;
12301: LD_ADDR_EXP 86
12305: PUSH
12306: LD_STRING Xavier2
12308: PPUSH
12309: CALL_OW 25
12313: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
12314: LD_STRING 13_Belkov_1
12316: PPUSH
12317: LD_INT 0
12319: PPUSH
12320: CALL_OW 30
12324: IFFALSE 12339
// Belkov := NewCharacter ( Belkov ) ;
12326: LD_ADDR_EXP 87
12330: PUSH
12331: LD_STRING Belkov
12333: PPUSH
12334: CALL_OW 25
12338: ST_TO_ADDR
// if not BurlakStatus then
12339: LD_EXP 9
12343: NOT
12344: IFFALSE 12359
// Burlak = NewCharacter ( Burlak ) ;
12346: LD_ADDR_EXP 88
12350: PUSH
12351: LD_STRING Burlak
12353: PPUSH
12354: CALL_OW 25
12358: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
12359: LD_ADDR_VAR 0 3
12363: PUSH
12364: LD_EXP 76
12368: PUSH
12369: LD_EXP 78
12373: PUSH
12374: LD_EXP 92
12378: PUSH
12379: LD_EXP 79
12383: PUSH
12384: LD_EXP 80
12388: PUSH
12389: LD_EXP 91
12393: PUSH
12394: LD_EXP 90
12398: PUSH
12399: LD_EXP 81
12403: PUSH
12404: LD_EXP 82
12408: PUSH
12409: LD_EXP 89
12413: PUSH
12414: EMPTY
12415: LIST
12416: LIST
12417: LIST
12418: LIST
12419: LIST
12420: LIST
12421: LIST
12422: LIST
12423: LIST
12424: LIST
12425: ST_TO_ADDR
// if Simms then
12426: LD_EXP 77
12430: IFFALSE 12448
// tmp := tmp ^ Simms ;
12432: LD_ADDR_VAR 0 3
12436: PUSH
12437: LD_VAR 0 3
12441: PUSH
12442: LD_EXP 77
12446: ADD
12447: ST_TO_ADDR
// if Titov then
12448: LD_EXP 85
12452: IFFALSE 12470
// tmp := tmp ^ Titov ;
12454: LD_ADDR_VAR 0 3
12458: PUSH
12459: LD_VAR 0 3
12463: PUSH
12464: LD_EXP 85
12468: ADD
12469: ST_TO_ADDR
// if Lipshchin then
12470: LD_EXP 83
12474: IFFALSE 12492
// tmp := tmp ^ Lipshchin ;
12476: LD_ADDR_VAR 0 3
12480: PUSH
12481: LD_VAR 0 3
12485: PUSH
12486: LD_EXP 83
12490: ADD
12491: ST_TO_ADDR
// if Gnyevko then
12492: LD_EXP 84
12496: IFFALSE 12514
// tmp := tmp ^ Gnyevko ;
12498: LD_ADDR_VAR 0 3
12502: PUSH
12503: LD_VAR 0 3
12507: PUSH
12508: LD_EXP 84
12512: ADD
12513: ST_TO_ADDR
// if Xavier then
12514: LD_EXP 86
12518: IFFALSE 12536
// tmp := tmp ^ Xavier ;
12520: LD_ADDR_VAR 0 3
12524: PUSH
12525: LD_VAR 0 3
12529: PUSH
12530: LD_EXP 86
12534: ADD
12535: ST_TO_ADDR
// if Belkov then
12536: LD_EXP 87
12540: IFFALSE 12558
// tmp := tmp ^ Belkov ;
12542: LD_ADDR_VAR 0 3
12546: PUSH
12547: LD_VAR 0 3
12551: PUSH
12552: LD_EXP 87
12556: ADD
12557: ST_TO_ADDR
// if Burlak then
12558: LD_EXP 88
12562: IFFALSE 12580
// tmp := tmp ^ Burlak ;
12564: LD_ADDR_VAR 0 3
12568: PUSH
12569: LD_VAR 0 3
12573: PUSH
12574: LD_EXP 88
12578: ADD
12579: ST_TO_ADDR
// for i = 1 to 11 do
12580: LD_ADDR_VAR 0 2
12584: PUSH
12585: DOUBLE
12586: LD_INT 1
12588: DEC
12589: ST_TO_ADDR
12590: LD_INT 11
12592: PUSH
12593: FOR_TO
12594: IFFALSE 12660
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
12596: LD_ADDR_OWVAR 21
12600: PUSH
12601: LD_INT 1
12603: PUSH
12604: LD_INT 3
12606: PUSH
12607: EMPTY
12608: LIST
12609: LIST
12610: PUSH
12611: LD_INT 1
12613: PPUSH
12614: LD_INT 2
12616: PPUSH
12617: CALL_OW 12
12621: ARRAY
12622: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
12623: LD_INT 0
12625: PPUSH
12626: LD_VAR 0 2
12630: PUSH
12631: LD_INT 2
12633: DIV
12634: PPUSH
12635: LD_INT 10
12637: PPUSH
12638: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
12642: LD_ADDR_VAR 0 3
12646: PUSH
12647: LD_VAR 0 3
12651: PUSH
12652: CALL_OW 44
12656: ADD
12657: ST_TO_ADDR
// end ;
12658: GO 12593
12660: POP
12661: POP
// for i in tmp do
12662: LD_ADDR_VAR 0 2
12666: PUSH
12667: LD_VAR 0 3
12671: PUSH
12672: FOR_IN
12673: IFFALSE 12698
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
12675: LD_VAR 0 2
12679: PPUSH
12680: LD_INT 260
12682: PPUSH
12683: LD_INT 235
12685: PPUSH
12686: LD_INT 8
12688: PPUSH
12689: LD_INT 0
12691: PPUSH
12692: CALL_OW 50
12696: GO 12672
12698: POP
12699: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
12700: LD_ADDR_EXP 99
12704: PUSH
12705: LD_EXP 99
12709: PPUSH
12710: LD_INT 1
12712: PPUSH
12713: LD_INT 22
12715: PUSH
12716: LD_VAR 0 5
12720: PUSH
12721: EMPTY
12722: LIST
12723: LIST
12724: PUSH
12725: LD_INT 3
12727: PUSH
12728: LD_INT 21
12730: PUSH
12731: LD_INT 2
12733: PUSH
12734: EMPTY
12735: LIST
12736: LIST
12737: PUSH
12738: EMPTY
12739: LIST
12740: LIST
12741: PUSH
12742: EMPTY
12743: LIST
12744: LIST
12745: PPUSH
12746: CALL_OW 69
12750: PUSH
12751: LD_EXP 76
12755: PUSH
12756: LD_EXP 77
12760: PUSH
12761: EMPTY
12762: LIST
12763: LIST
12764: DIFF
12765: PPUSH
12766: CALL_OW 1
12770: ST_TO_ADDR
// uc_side := 0 ;
12771: LD_ADDR_OWVAR 20
12775: PUSH
12776: LD_INT 0
12778: ST_TO_ADDR
// uc_nation := 0 ;
12779: LD_ADDR_OWVAR 21
12783: PUSH
12784: LD_INT 0
12786: ST_TO_ADDR
// for i = 1 to 5 do
12787: LD_ADDR_VAR 0 2
12791: PUSH
12792: DOUBLE
12793: LD_INT 1
12795: DEC
12796: ST_TO_ADDR
12797: LD_INT 5
12799: PUSH
12800: FOR_TO
12801: IFFALSE 12838
// begin InitHc ;
12803: CALL_OW 19
// hc_class := class_apeman ;
12807: LD_ADDR_OWVAR 28
12811: PUSH
12812: LD_INT 12
12814: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12815: CALL_OW 44
12819: PPUSH
12820: LD_INT 299
12822: PPUSH
12823: LD_INT 229
12825: PPUSH
12826: LD_INT 10
12828: PPUSH
12829: LD_INT 0
12831: PPUSH
12832: CALL_OW 50
// end ;
12836: GO 12800
12838: POP
12839: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12840: LD_EXP 76
12844: PPUSH
12845: LD_INT 259
12847: PPUSH
12848: LD_INT 235
12850: PPUSH
12851: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12855: LD_EXP 76
12859: PPUSH
12860: LD_INT 262
12862: PPUSH
12863: LD_INT 235
12865: PPUSH
12866: CALL_OW 178
// if Simms then
12870: LD_EXP 77
12874: IFFALSE 12905
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12876: LD_EXP 77
12880: PPUSH
12881: LD_INT 262
12883: PPUSH
12884: LD_INT 235
12886: PPUSH
12887: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12891: LD_EXP 77
12895: PPUSH
12896: LD_EXP 76
12900: PPUSH
12901: CALL_OW 179
// end ; end ;
12905: LD_VAR 0 1
12909: RET
// every 5 5$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12910: LD_EXP 31
12914: PUSH
12915: LD_EXP 23
12919: NOT
12920: AND
12921: IFFALSE 13149
12923: GO 12925
12925: DISABLE
12926: LD_INT 0
12928: PPUSH
12929: PPUSH
12930: PPUSH
// begin enable ;
12931: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12932: LD_ADDR_VAR 0 2
12936: PUSH
12937: LD_INT 81
12939: PUSH
12940: LD_INT 7
12942: PUSH
12943: EMPTY
12944: LIST
12945: LIST
12946: PUSH
12947: LD_INT 2
12949: PUSH
12950: LD_INT 32
12952: PUSH
12953: LD_INT 3
12955: PUSH
12956: EMPTY
12957: LIST
12958: LIST
12959: PUSH
12960: LD_INT 30
12962: PUSH
12963: LD_INT 30
12965: PUSH
12966: EMPTY
12967: LIST
12968: LIST
12969: PUSH
12970: LD_INT 30
12972: PUSH
12973: LD_INT 28
12975: PUSH
12976: EMPTY
12977: LIST
12978: LIST
12979: PUSH
12980: LD_INT 34
12982: PUSH
12983: LD_INT 49
12985: PUSH
12986: EMPTY
12987: LIST
12988: LIST
12989: PUSH
12990: LD_INT 34
12992: PUSH
12993: LD_INT 10
12995: PUSH
12996: EMPTY
12997: LIST
12998: LIST
12999: PUSH
13000: LD_INT 34
13002: PUSH
13003: LD_INT 8
13005: PUSH
13006: EMPTY
13007: LIST
13008: LIST
13009: PUSH
13010: EMPTY
13011: LIST
13012: LIST
13013: LIST
13014: LIST
13015: LIST
13016: LIST
13017: LIST
13018: PUSH
13019: EMPTY
13020: LIST
13021: LIST
13022: PPUSH
13023: CALL_OW 69
13027: ST_TO_ADDR
// if not tmp then
13028: LD_VAR 0 2
13032: NOT
13033: IFFALSE 13037
// exit ;
13035: GO 13149
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
13037: LD_VAR 0 2
13041: PPUSH
13042: LD_INT 34
13044: PUSH
13045: LD_INT 8
13047: PUSH
13048: EMPTY
13049: LIST
13050: LIST
13051: PPUSH
13052: CALL_OW 72
13056: IFFALSE 13089
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
13058: LD_ADDR_VAR 0 3
13062: PUSH
13063: LD_VAR 0 2
13067: PPUSH
13068: LD_INT 34
13070: PUSH
13071: LD_INT 8
13073: PUSH
13074: EMPTY
13075: LIST
13076: LIST
13077: PPUSH
13078: CALL_OW 72
13082: PUSH
13083: LD_INT 1
13085: ARRAY
13086: ST_TO_ADDR
13087: GO 13113
// target := tmp [ rand ( 1 , tmp ) ] ;
13089: LD_ADDR_VAR 0 3
13093: PUSH
13094: LD_VAR 0 2
13098: PUSH
13099: LD_INT 1
13101: PPUSH
13102: LD_VAR 0 2
13106: PPUSH
13107: CALL_OW 12
13111: ARRAY
13112: ST_TO_ADDR
// if GetSide ( target ) = 1 then
13113: LD_VAR 0 3
13117: PPUSH
13118: CALL_OW 255
13122: PUSH
13123: LD_INT 1
13125: EQUAL
13126: IFFALSE 13137
// CenterNowOnUnits ( target ) ;
13128: LD_VAR 0 3
13132: PPUSH
13133: CALL_OW 87
// SetLives ( target , 0 ) ;
13137: LD_VAR 0 3
13141: PPUSH
13142: LD_INT 0
13144: PPUSH
13145: CALL_OW 234
// end ;
13149: PPOPN 3
13151: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
13152: LD_EXP 23
13156: NOT
13157: PUSH
13158: LD_EXP 31
13162: AND
13163: IFFALSE 13689
13165: GO 13167
13167: DISABLE
13168: LD_INT 0
13170: PPUSH
13171: PPUSH
13172: PPUSH
// begin uc_side := 7 ;
13173: LD_ADDR_OWVAR 20
13177: PUSH
13178: LD_INT 7
13180: ST_TO_ADDR
// uc_nation := 1 ;
13181: LD_ADDR_OWVAR 21
13185: PUSH
13186: LD_INT 1
13188: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
13189: LD_ADDR_VAR 0 3
13193: PUSH
13194: LD_INT 125
13196: PUSH
13197: LD_INT 163
13199: PUSH
13200: EMPTY
13201: LIST
13202: LIST
13203: PUSH
13204: LD_INT 185
13206: PUSH
13207: LD_INT 168
13209: PUSH
13210: EMPTY
13211: LIST
13212: LIST
13213: PUSH
13214: LD_INT 111
13216: PUSH
13217: LD_INT 97
13219: PUSH
13220: EMPTY
13221: LIST
13222: LIST
13223: PUSH
13224: EMPTY
13225: LIST
13226: LIST
13227: LIST
13228: PPUSH
13229: CALL 104889 0 1
13233: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
13234: LD_ADDR_EXP 93
13238: PUSH
13239: EMPTY
13240: ST_TO_ADDR
// for i = 1 to Difficulty do
13241: LD_ADDR_VAR 0 1
13245: PUSH
13246: DOUBLE
13247: LD_INT 1
13249: DEC
13250: ST_TO_ADDR
13251: LD_OWVAR 67
13255: PUSH
13256: FOR_TO
13257: IFFALSE 13415
// begin InitHc ;
13259: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
13263: LD_INT 0
13265: PPUSH
13266: LD_INT 8
13268: PPUSH
13269: CALL_OW 381
// un := CreateHuman ;
13273: LD_ADDR_VAR 0 2
13277: PUSH
13278: CALL_OW 44
13282: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
13283: LD_VAR 0 2
13287: PPUSH
13288: LD_INT 258
13290: PPUSH
13291: LD_INT 267
13293: PPUSH
13294: LD_INT 4
13296: PPUSH
13297: LD_INT 0
13299: PPUSH
13300: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
13304: LD_ADDR_EXP 93
13308: PUSH
13309: LD_EXP 93
13313: PUSH
13314: LD_VAR 0 2
13318: UNION
13319: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
13320: LD_VAR 0 2
13324: PPUSH
13325: LD_VAR 0 3
13329: PUSH
13330: LD_VAR 0 1
13334: ARRAY
13335: PUSH
13336: LD_INT 1
13338: ARRAY
13339: PPUSH
13340: LD_VAR 0 3
13344: PUSH
13345: LD_VAR 0 1
13349: ARRAY
13350: PUSH
13351: LD_INT 2
13353: ARRAY
13354: PPUSH
13355: LD_INT 4
13357: PPUSH
13358: LD_INT 1
13360: PPUSH
13361: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
13365: LD_VAR 0 2
13369: PPUSH
13370: LD_VAR 0 3
13374: PUSH
13375: LD_VAR 0 1
13379: ARRAY
13380: PUSH
13381: LD_INT 1
13383: ARRAY
13384: PPUSH
13385: LD_VAR 0 3
13389: PUSH
13390: LD_VAR 0 1
13394: ARRAY
13395: PUSH
13396: LD_INT 2
13398: ARRAY
13399: PPUSH
13400: CALL_OW 171
// AddComInvisible ( un ) ;
13404: LD_VAR 0 2
13408: PPUSH
13409: CALL_OW 212
// end ;
13413: GO 13256
13415: POP
13416: POP
// repeat wait ( 0 0$20 ) ;
13417: LD_INT 700
13419: PPUSH
13420: CALL_OW 67
// for i in allianceSpecialForce do
13424: LD_ADDR_VAR 0 1
13428: PUSH
13429: LD_EXP 93
13433: PUSH
13434: FOR_IN
13435: IFFALSE 13674
// begin if IsInvisible ( i ) then
13437: LD_VAR 0 1
13441: PPUSH
13442: CALL_OW 571
13446: IFFALSE 13643
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 , 40 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
13448: LD_ADDR_VAR 0 3
13452: PUSH
13453: LD_INT 22
13455: PUSH
13456: LD_INT 1
13458: PUSH
13459: EMPTY
13460: LIST
13461: LIST
13462: PUSH
13463: LD_INT 50
13465: PUSH
13466: EMPTY
13467: LIST
13468: PUSH
13469: LD_INT 56
13471: PUSH
13472: EMPTY
13473: LIST
13474: PUSH
13475: LD_INT 91
13477: PUSH
13478: LD_VAR 0 1
13482: PUSH
13483: LD_INT 25
13485: PUSH
13486: LD_INT 30
13488: PUSH
13489: LD_INT 35
13491: PUSH
13492: LD_INT 40
13494: PUSH
13495: EMPTY
13496: LIST
13497: LIST
13498: LIST
13499: LIST
13500: PUSH
13501: LD_OWVAR 67
13505: ARRAY
13506: PUSH
13507: EMPTY
13508: LIST
13509: LIST
13510: LIST
13511: PUSH
13512: LD_INT 2
13514: PUSH
13515: LD_INT 25
13517: PUSH
13518: LD_INT 1
13520: PUSH
13521: EMPTY
13522: LIST
13523: LIST
13524: PUSH
13525: LD_INT 25
13527: PUSH
13528: LD_INT 2
13530: PUSH
13531: EMPTY
13532: LIST
13533: LIST
13534: PUSH
13535: LD_INT 25
13537: PUSH
13538: LD_INT 3
13540: PUSH
13541: EMPTY
13542: LIST
13543: LIST
13544: PUSH
13545: LD_INT 25
13547: PUSH
13548: LD_INT 4
13550: PUSH
13551: EMPTY
13552: LIST
13553: LIST
13554: PUSH
13555: LD_INT 25
13557: PUSH
13558: LD_INT 5
13560: PUSH
13561: EMPTY
13562: LIST
13563: LIST
13564: PUSH
13565: LD_INT 25
13567: PUSH
13568: LD_INT 8
13570: PUSH
13571: EMPTY
13572: LIST
13573: LIST
13574: PUSH
13575: EMPTY
13576: LIST
13577: LIST
13578: LIST
13579: LIST
13580: LIST
13581: LIST
13582: LIST
13583: PUSH
13584: EMPTY
13585: LIST
13586: LIST
13587: LIST
13588: LIST
13589: LIST
13590: PPUSH
13591: CALL_OW 69
13595: ST_TO_ADDR
// if not tmp then
13596: LD_VAR 0 3
13600: NOT
13601: IFFALSE 13605
// continue ;
13603: GO 13434
// if Prob ( 30 * Difficulty ) then
13605: LD_INT 30
13607: PUSH
13608: LD_OWVAR 67
13612: MUL
13613: PPUSH
13614: CALL_OW 13
13618: IFFALSE 13643
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
13620: LD_VAR 0 3
13624: PUSH
13625: LD_INT 1
13627: PPUSH
13628: LD_VAR 0 3
13632: PPUSH
13633: CALL_OW 12
13637: ARRAY
13638: PPUSH
13639: CALL 32683 0 1
// end ; if IsDead ( i ) then
13643: LD_VAR 0 1
13647: PPUSH
13648: CALL_OW 301
13652: IFFALSE 13672
// begin allianceSpecialForce := allianceSpecialForce diff i ;
13654: LD_ADDR_EXP 93
13658: PUSH
13659: LD_EXP 93
13663: PUSH
13664: LD_VAR 0 1
13668: DIFF
13669: ST_TO_ADDR
// continue ;
13670: GO 13434
// end ; end ;
13672: GO 13434
13674: POP
13675: POP
// until allianceDestroyed or not allianceSpecialForce ;
13676: LD_EXP 23
13680: PUSH
13681: LD_EXP 93
13685: NOT
13686: OR
13687: IFFALSE 13417
// end ;
13689: PPOPN 3
13691: END
// every 12 12$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
13692: LD_EXP 23
13696: NOT
13697: PUSH
13698: LD_EXP 31
13702: AND
13703: IFFALSE 14653
13705: GO 13707
13707: DISABLE
13708: LD_INT 0
13710: PPUSH
13711: PPUSH
13712: PPUSH
13713: PPUSH
// begin enable ;
13714: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
13715: LD_INT 22
13717: PUSH
13718: LD_INT 7
13720: PUSH
13721: EMPTY
13722: LIST
13723: LIST
13724: PUSH
13725: LD_INT 30
13727: PUSH
13728: LD_INT 3
13730: PUSH
13731: EMPTY
13732: LIST
13733: LIST
13734: PUSH
13735: EMPTY
13736: LIST
13737: LIST
13738: PPUSH
13739: CALL_OW 69
13743: NOT
13744: IFFALSE 13748
// exit ;
13746: GO 14653
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
13748: LD_ADDR_VAR 0 4
13752: PUSH
13753: LD_INT 22
13755: PUSH
13756: LD_INT 7
13758: PUSH
13759: EMPTY
13760: LIST
13761: LIST
13762: PUSH
13763: LD_INT 30
13765: PUSH
13766: LD_INT 34
13768: PUSH
13769: EMPTY
13770: LIST
13771: LIST
13772: PUSH
13773: EMPTY
13774: LIST
13775: LIST
13776: PPUSH
13777: CALL_OW 69
13781: ST_TO_ADDR
// if Prob ( 40 ) then
13782: LD_INT 40
13784: PPUSH
13785: CALL_OW 13
13789: IFFALSE 13935
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
13791: LD_INT 1
13793: PPUSH
13794: LD_INT 5
13796: PUSH
13797: LD_INT 3
13799: PUSH
13800: LD_INT 2
13802: PUSH
13803: LD_INT 6
13805: PUSH
13806: EMPTY
13807: LIST
13808: LIST
13809: LIST
13810: LIST
13811: PUSH
13812: LD_INT 5
13814: PUSH
13815: LD_INT 3
13817: PUSH
13818: LD_INT 2
13820: PUSH
13821: LD_INT 6
13823: PUSH
13824: EMPTY
13825: LIST
13826: LIST
13827: LIST
13828: LIST
13829: PUSH
13830: LD_INT 5
13832: PUSH
13833: LD_INT 3
13835: PUSH
13836: LD_INT 2
13838: PUSH
13839: LD_INT 6
13841: PUSH
13842: EMPTY
13843: LIST
13844: LIST
13845: LIST
13846: LIST
13847: PUSH
13848: LD_INT 5
13850: PUSH
13851: LD_INT 3
13853: PUSH
13854: LD_INT 2
13856: PUSH
13857: LD_INT 9
13859: PUSH
13860: EMPTY
13861: LIST
13862: LIST
13863: LIST
13864: LIST
13865: PUSH
13866: LD_INT 24
13868: PUSH
13869: LD_INT 3
13871: PUSH
13872: LD_INT 3
13874: PUSH
13875: LD_INT 45
13877: PUSH
13878: EMPTY
13879: LIST
13880: LIST
13881: LIST
13882: LIST
13883: PUSH
13884: LD_INT 24
13886: PUSH
13887: LD_INT 3
13889: PUSH
13890: LD_INT 3
13892: PUSH
13893: LD_INT 47
13895: PUSH
13896: EMPTY
13897: LIST
13898: LIST
13899: LIST
13900: LIST
13901: PUSH
13902: LD_INT 24
13904: PUSH
13905: LD_INT 3
13907: PUSH
13908: LD_INT 3
13910: PUSH
13911: LD_INT 45
13913: PUSH
13914: EMPTY
13915: LIST
13916: LIST
13917: LIST
13918: LIST
13919: PUSH
13920: EMPTY
13921: LIST
13922: LIST
13923: LIST
13924: LIST
13925: LIST
13926: LIST
13927: LIST
13928: PPUSH
13929: CALL 60947 0 2
// end else
13933: GO 14077
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13935: LD_INT 1
13937: PPUSH
13938: LD_INT 24
13940: PUSH
13941: LD_INT 3
13943: PUSH
13944: LD_INT 3
13946: PUSH
13947: LD_INT 47
13949: PUSH
13950: EMPTY
13951: LIST
13952: LIST
13953: LIST
13954: LIST
13955: PUSH
13956: LD_INT 24
13958: PUSH
13959: LD_INT 3
13961: PUSH
13962: LD_INT 3
13964: PUSH
13965: LD_INT 47
13967: PUSH
13968: EMPTY
13969: LIST
13970: LIST
13971: LIST
13972: LIST
13973: PUSH
13974: LD_INT 5
13976: PUSH
13977: LD_INT 3
13979: PUSH
13980: LD_INT 2
13982: PUSH
13983: LD_INT 9
13985: PUSH
13986: EMPTY
13987: LIST
13988: LIST
13989: LIST
13990: LIST
13991: PUSH
13992: LD_INT 5
13994: PUSH
13995: LD_INT 3
13997: PUSH
13998: LD_INT 2
14000: PUSH
14001: LD_INT 9
14003: PUSH
14004: EMPTY
14005: LIST
14006: LIST
14007: LIST
14008: LIST
14009: PUSH
14010: LD_INT 5
14012: PUSH
14013: LD_INT 3
14015: PUSH
14016: LD_INT 2
14018: PUSH
14019: LD_INT 9
14021: PUSH
14022: EMPTY
14023: LIST
14024: LIST
14025: LIST
14026: LIST
14027: PUSH
14028: LD_INT 24
14030: PUSH
14031: LD_INT 1
14033: PUSH
14034: LD_INT 3
14036: PUSH
14037: LD_INT 45
14039: PUSH
14040: EMPTY
14041: LIST
14042: LIST
14043: LIST
14044: LIST
14045: PUSH
14046: LD_INT 24
14048: PUSH
14049: LD_INT 1
14051: PUSH
14052: LD_INT 3
14054: PUSH
14055: LD_INT 45
14057: PUSH
14058: EMPTY
14059: LIST
14060: LIST
14061: LIST
14062: LIST
14063: PUSH
14064: EMPTY
14065: LIST
14066: LIST
14067: LIST
14068: LIST
14069: LIST
14070: LIST
14071: LIST
14072: PPUSH
14073: CALL 60947 0 2
// end ; repeat wait ( 0 0$1 ) ;
14077: LD_INT 35
14079: PPUSH
14080: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= 7 ;
14084: LD_INT 1
14086: PPUSH
14087: LD_INT 1
14089: PPUSH
14090: CALL 62365 0 2
14094: PUSH
14095: LD_INT 7
14097: GREATEREQUAL
14098: IFFALSE 14077
// wait ( 0 0$10 ) ;
14100: LD_INT 350
14102: PPUSH
14103: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
14107: LD_ADDR_VAR 0 2
14111: PUSH
14112: LD_INT 1
14114: PPUSH
14115: LD_INT 1
14117: PPUSH
14118: CALL 62365 0 2
14122: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
14123: LD_ADDR_EXP 118
14127: PUSH
14128: LD_EXP 118
14132: PPUSH
14133: LD_INT 1
14135: PPUSH
14136: LD_EXP 118
14140: PUSH
14141: LD_INT 1
14143: ARRAY
14144: PUSH
14145: LD_VAR 0 2
14149: DIFF
14150: PPUSH
14151: CALL_OW 1
14155: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
14156: LD_ADDR_VAR 0 3
14160: PUSH
14161: LD_INT 0
14163: PPUSH
14164: LD_INT 1
14166: PPUSH
14167: CALL_OW 12
14171: ST_TO_ADDR
// if target then
14172: LD_VAR 0 3
14176: IFFALSE 14342
// begin for i in tmp do
14178: LD_ADDR_VAR 0 1
14182: PUSH
14183: LD_VAR 0 2
14187: PUSH
14188: FOR_IN
14189: IFFALSE 14214
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
14191: LD_VAR 0 1
14195: PPUSH
14196: LD_INT 179
14198: PPUSH
14199: LD_INT 209
14201: PPUSH
14202: LD_INT 8
14204: PPUSH
14205: LD_INT 1
14207: PPUSH
14208: CALL_OW 483
14212: GO 14188
14214: POP
14215: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
14216: LD_ADDR_VAR 0 2
14220: PUSH
14221: LD_VAR 0 2
14225: PPUSH
14226: LD_INT 24
14228: PUSH
14229: LD_INT 250
14231: PUSH
14232: EMPTY
14233: LIST
14234: LIST
14235: PPUSH
14236: CALL_OW 72
14240: ST_TO_ADDR
// for i in tmp do
14241: LD_ADDR_VAR 0 1
14245: PUSH
14246: LD_VAR 0 2
14250: PUSH
14251: FOR_IN
14252: IFFALSE 14292
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
14254: LD_VAR 0 1
14258: PPUSH
14259: LD_INT 179
14261: PPUSH
14262: LD_INT 209
14264: PPUSH
14265: CALL_OW 297
14269: PUSH
14270: LD_INT 9
14272: GREATER
14273: IFFALSE 14290
// ComMoveXY ( i , 179 , 209 ) ;
14275: LD_VAR 0 1
14279: PPUSH
14280: LD_INT 179
14282: PPUSH
14283: LD_INT 209
14285: PPUSH
14286: CALL_OW 111
14290: GO 14251
14292: POP
14293: POP
// wait ( 0 0$1 ) ;
14294: LD_INT 35
14296: PPUSH
14297: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
14301: LD_VAR 0 2
14305: PPUSH
14306: LD_INT 92
14308: PUSH
14309: LD_INT 179
14311: PUSH
14312: LD_INT 209
14314: PUSH
14315: LD_INT 9
14317: PUSH
14318: EMPTY
14319: LIST
14320: LIST
14321: LIST
14322: LIST
14323: PPUSH
14324: CALL_OW 72
14328: PUSH
14329: LD_VAR 0 2
14333: PUSH
14334: LD_INT 1
14336: MINUS
14337: GREATEREQUAL
14338: IFFALSE 14216
// end else
14340: GO 14504
// begin for i in tmp do
14342: LD_ADDR_VAR 0 1
14346: PUSH
14347: LD_VAR 0 2
14351: PUSH
14352: FOR_IN
14353: IFFALSE 14378
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
14355: LD_VAR 0 1
14359: PPUSH
14360: LD_INT 285
14362: PPUSH
14363: LD_INT 163
14365: PPUSH
14366: LD_INT 8
14368: PPUSH
14369: LD_INT 1
14371: PPUSH
14372: CALL_OW 483
14376: GO 14352
14378: POP
14379: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
14380: LD_ADDR_VAR 0 2
14384: PUSH
14385: LD_VAR 0 2
14389: PPUSH
14390: LD_INT 24
14392: PUSH
14393: LD_INT 250
14395: PUSH
14396: EMPTY
14397: LIST
14398: LIST
14399: PPUSH
14400: CALL_OW 72
14404: ST_TO_ADDR
// for i in tmp do
14405: LD_ADDR_VAR 0 1
14409: PUSH
14410: LD_VAR 0 2
14414: PUSH
14415: FOR_IN
14416: IFFALSE 14456
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
14418: LD_VAR 0 1
14422: PPUSH
14423: LD_INT 285
14425: PPUSH
14426: LD_INT 163
14428: PPUSH
14429: CALL_OW 297
14433: PUSH
14434: LD_INT 9
14436: GREATER
14437: IFFALSE 14454
// ComMoveXY ( i , 285 , 163 ) ;
14439: LD_VAR 0 1
14443: PPUSH
14444: LD_INT 285
14446: PPUSH
14447: LD_INT 163
14449: PPUSH
14450: CALL_OW 111
14454: GO 14415
14456: POP
14457: POP
// wait ( 0 0$1 ) ;
14458: LD_INT 35
14460: PPUSH
14461: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
14465: LD_VAR 0 2
14469: PPUSH
14470: LD_INT 92
14472: PUSH
14473: LD_INT 285
14475: PUSH
14476: LD_INT 163
14478: PUSH
14479: LD_INT 9
14481: PUSH
14482: EMPTY
14483: LIST
14484: LIST
14485: LIST
14486: LIST
14487: PPUSH
14488: CALL_OW 72
14492: PUSH
14493: LD_VAR 0 2
14497: PUSH
14498: LD_INT 1
14500: MINUS
14501: GREATEREQUAL
14502: IFFALSE 14380
// end ; repeat wait ( 0 0$1 ) ;
14504: LD_INT 35
14506: PPUSH
14507: CALL_OW 67
// for i in tmp do
14511: LD_ADDR_VAR 0 1
14515: PUSH
14516: LD_VAR 0 2
14520: PUSH
14521: FOR_IN
14522: IFFALSE 14644
// if GetLives ( i ) > 251 then
14524: LD_VAR 0 1
14528: PPUSH
14529: CALL_OW 256
14533: PUSH
14534: LD_INT 251
14536: GREATER
14537: IFFALSE 14626
// begin if GetWeapon ( i ) = ru_time_lapser then
14539: LD_VAR 0 1
14543: PPUSH
14544: CALL_OW 264
14548: PUSH
14549: LD_INT 49
14551: EQUAL
14552: IFFALSE 14590
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
14554: LD_VAR 0 1
14558: PPUSH
14559: LD_INT 81
14561: PUSH
14562: LD_INT 7
14564: PUSH
14565: EMPTY
14566: LIST
14567: LIST
14568: PPUSH
14569: CALL_OW 69
14573: PPUSH
14574: LD_VAR 0 1
14578: PPUSH
14579: CALL_OW 74
14583: PPUSH
14584: CALL_OW 112
14588: GO 14624
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
14590: LD_VAR 0 1
14594: PPUSH
14595: LD_INT 81
14597: PUSH
14598: LD_INT 7
14600: PUSH
14601: EMPTY
14602: LIST
14603: LIST
14604: PPUSH
14605: CALL_OW 69
14609: PPUSH
14610: LD_VAR 0 1
14614: PPUSH
14615: CALL_OW 74
14619: PPUSH
14620: CALL_OW 115
// end else
14624: GO 14642
// tmp := tmp diff i ;
14626: LD_ADDR_VAR 0 2
14630: PUSH
14631: LD_VAR 0 2
14635: PUSH
14636: LD_VAR 0 1
14640: DIFF
14641: ST_TO_ADDR
14642: GO 14521
14644: POP
14645: POP
// until not tmp ;
14646: LD_VAR 0 2
14650: NOT
14651: IFFALSE 14504
// end ; end_of_file
14653: PPOPN 4
14655: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
14656: LD_INT 0
14658: PPUSH
14659: PPUSH
14660: PPUSH
14661: PPUSH
// missionStage := 13 ;
14662: LD_ADDR_EXP 15
14666: PUSH
14667: LD_INT 13
14669: ST_TO_ADDR
// uc_side := 2 ;
14670: LD_ADDR_OWVAR 20
14674: PUSH
14675: LD_INT 2
14677: ST_TO_ADDR
// uc_nation := 2 ;
14678: LD_ADDR_OWVAR 21
14682: PUSH
14683: LD_INT 2
14685: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
14686: LD_ADDR_EXP 94
14690: PUSH
14691: LD_STRING Omar
14693: PPUSH
14694: CALL_OW 25
14698: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
14699: LD_EXP 94
14703: PPUSH
14704: LD_INT 4
14706: PPUSH
14707: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
14711: LD_EXP 94
14715: PPUSH
14716: LD_INT 242
14718: PPUSH
14719: LD_INT 75
14721: PPUSH
14722: LD_INT 0
14724: PPUSH
14725: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
14729: LD_ADDR_EXP 95
14733: PUSH
14734: LD_STRING Heike
14736: PPUSH
14737: CALL_OW 25
14741: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
14742: LD_INT 14
14744: PPUSH
14745: LD_INT 3
14747: PPUSH
14748: LD_INT 1
14750: PPUSH
14751: LD_INT 27
14753: PPUSH
14754: LD_INT 100
14756: PPUSH
14757: CALL 72350 0 5
// veh := CreateVehicle ;
14761: LD_ADDR_VAR 0 3
14765: PUSH
14766: CALL_OW 45
14770: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
14771: LD_VAR 0 3
14775: PPUSH
14776: LD_INT 2
14778: NEG
14779: PPUSH
14780: CALL_OW 242
// SetDir ( veh , 4 ) ;
14784: LD_VAR 0 3
14788: PPUSH
14789: LD_INT 4
14791: PPUSH
14792: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14796: LD_VAR 0 3
14800: PPUSH
14801: LD_INT 241
14803: PPUSH
14804: LD_INT 72
14806: PPUSH
14807: LD_INT 0
14809: PPUSH
14810: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14814: LD_EXP 95
14818: PPUSH
14819: LD_VAR 0 3
14823: PPUSH
14824: CALL_OW 52
// if KhatamStatus then
14828: LD_EXP 8
14832: IFFALSE 14895
// begin Khatam := NewCharacter ( Khatam ) ;
14834: LD_ADDR_EXP 96
14838: PUSH
14839: LD_STRING Khatam
14841: PPUSH
14842: CALL_OW 25
14846: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14847: LD_EXP 96
14851: PPUSH
14852: LD_INT 245
14854: PPUSH
14855: LD_INT 78
14857: PPUSH
14858: LD_INT 3
14860: PPUSH
14861: LD_INT 0
14863: PPUSH
14864: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14868: LD_EXP 96
14872: PPUSH
14873: LD_INT 4
14875: PPUSH
14876: LD_INT 10
14878: PPUSH
14879: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
14883: LD_EXP 96
14887: PPUSH
14888: LD_INT 4
14890: PPUSH
14891: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
14895: LD_ADDR_VAR 0 2
14899: PUSH
14900: DOUBLE
14901: LD_INT 1
14903: DEC
14904: ST_TO_ADDR
14905: LD_INT 2
14907: PUSH
14908: LD_INT 2
14910: PUSH
14911: LD_INT 3
14913: PUSH
14914: LD_INT 3
14916: PUSH
14917: EMPTY
14918: LIST
14919: LIST
14920: LIST
14921: LIST
14922: PUSH
14923: LD_OWVAR 67
14927: ARRAY
14928: PUSH
14929: FOR_TO
14930: IFFALSE 14996
// begin PrepareScientist ( false , 6 + Difficulty ) ;
14932: LD_INT 0
14934: PPUSH
14935: LD_INT 6
14937: PUSH
14938: LD_OWVAR 67
14942: PLUS
14943: PPUSH
14944: CALL_OW 384
// un := CreateHuman ;
14948: LD_ADDR_VAR 0 4
14952: PUSH
14953: CALL_OW 44
14957: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14958: LD_VAR 0 4
14962: PPUSH
14963: LD_INT 28
14965: PUSH
14966: LD_INT 29
14968: PUSH
14969: EMPTY
14970: LIST
14971: LIST
14972: PUSH
14973: LD_VAR 0 2
14977: PUSH
14978: LD_INT 2
14980: MOD
14981: PUSH
14982: LD_INT 1
14984: PLUS
14985: ARRAY
14986: PPUSH
14987: LD_INT 0
14989: PPUSH
14990: CALL_OW 49
// end ;
14994: GO 14929
14996: POP
14997: POP
// for i = 1 to 6 do
14998: LD_ADDR_VAR 0 2
15002: PUSH
15003: DOUBLE
15004: LD_INT 1
15006: DEC
15007: ST_TO_ADDR
15008: LD_INT 6
15010: PUSH
15011: FOR_TO
15012: IFFALSE 15057
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
15014: LD_INT 0
15016: PPUSH
15017: LD_INT 6
15019: PUSH
15020: LD_OWVAR 67
15024: PLUS
15025: PPUSH
15026: CALL_OW 381
// un := CreateHuman ;
15030: LD_ADDR_VAR 0 4
15034: PUSH
15035: CALL_OW 44
15039: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
15040: LD_VAR 0 4
15044: PPUSH
15045: LD_INT 32
15047: PPUSH
15048: LD_INT 0
15050: PPUSH
15051: CALL_OW 49
// end ;
15055: GO 15011
15057: POP
15058: POP
// for i = 1 to 3 do
15059: LD_ADDR_VAR 0 2
15063: PUSH
15064: DOUBLE
15065: LD_INT 1
15067: DEC
15068: ST_TO_ADDR
15069: LD_INT 3
15071: PUSH
15072: FOR_TO
15073: IFFALSE 15121
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
15075: LD_INT 0
15077: PPUSH
15078: LD_INT 8
15080: PPUSH
15081: LD_INT 6
15083: PUSH
15084: LD_OWVAR 67
15088: PLUS
15089: PPUSH
15090: CALL_OW 380
// un := CreateHuman ;
15094: LD_ADDR_VAR 0 4
15098: PUSH
15099: CALL_OW 44
15103: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
15104: LD_VAR 0 4
15108: PPUSH
15109: LD_INT 32
15111: PPUSH
15112: LD_INT 0
15114: PPUSH
15115: CALL_OW 49
// end ;
15119: GO 15072
15121: POP
15122: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
15123: LD_ADDR_VAR 0 2
15127: PUSH
15128: DOUBLE
15129: LD_INT 1
15131: DEC
15132: ST_TO_ADDR
15133: LD_INT 2
15135: PUSH
15136: LD_INT 3
15138: PUSH
15139: LD_INT 4
15141: PUSH
15142: LD_INT 4
15144: PUSH
15145: EMPTY
15146: LIST
15147: LIST
15148: LIST
15149: LIST
15150: PUSH
15151: LD_OWVAR 67
15155: ARRAY
15156: PUSH
15157: FOR_TO
15158: IFFALSE 15248
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
15160: LD_INT 14
15162: PPUSH
15163: LD_INT 2
15165: PPUSH
15166: LD_INT 1
15168: PPUSH
15169: LD_INT 28
15171: PPUSH
15172: LD_INT 80
15174: PPUSH
15175: CALL 72350 0 5
// veh := CreateVehicle ;
15179: LD_ADDR_VAR 0 3
15183: PUSH
15184: CALL_OW 45
15188: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
15189: LD_VAR 0 3
15193: PPUSH
15194: LD_INT 3
15196: PPUSH
15197: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
15201: LD_VAR 0 3
15205: PPUSH
15206: LD_INT 29
15208: PPUSH
15209: LD_INT 0
15211: PPUSH
15212: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
15216: LD_INT 0
15218: PPUSH
15219: LD_INT 6
15221: PUSH
15222: LD_OWVAR 67
15226: PLUS
15227: PPUSH
15228: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
15232: CALL_OW 44
15236: PPUSH
15237: LD_VAR 0 3
15241: PPUSH
15242: CALL_OW 52
// end ;
15246: GO 15157
15248: POP
15249: POP
// for i = 1 to 5 + Difficulty do
15250: LD_ADDR_VAR 0 2
15254: PUSH
15255: DOUBLE
15256: LD_INT 1
15258: DEC
15259: ST_TO_ADDR
15260: LD_INT 5
15262: PUSH
15263: LD_OWVAR 67
15267: PLUS
15268: PUSH
15269: FOR_TO
15270: IFFALSE 15397
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
15272: LD_INT 14
15274: PPUSH
15275: LD_INT 1
15277: PPUSH
15278: LD_INT 3
15280: PPUSH
15281: CALL_OW 12
15285: PPUSH
15286: LD_INT 1
15288: PPUSH
15289: LD_INT 28
15291: PUSH
15292: LD_INT 26
15294: PUSH
15295: LD_INT 27
15297: PUSH
15298: LD_INT 25
15300: PUSH
15301: EMPTY
15302: LIST
15303: LIST
15304: LIST
15305: LIST
15306: PUSH
15307: LD_VAR 0 2
15311: PUSH
15312: LD_INT 4
15314: MOD
15315: PUSH
15316: LD_INT 1
15318: PLUS
15319: ARRAY
15320: PPUSH
15321: LD_INT 80
15323: PPUSH
15324: CALL 72350 0 5
// veh := CreateVehicle ;
15328: LD_ADDR_VAR 0 3
15332: PUSH
15333: CALL_OW 45
15337: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
15338: LD_VAR 0 3
15342: PPUSH
15343: LD_INT 4
15345: PPUSH
15346: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
15350: LD_VAR 0 3
15354: PPUSH
15355: LD_INT 28
15357: PPUSH
15358: LD_INT 0
15360: PPUSH
15361: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
15365: LD_INT 0
15367: PPUSH
15368: LD_INT 6
15370: PUSH
15371: LD_OWVAR 67
15375: PLUS
15376: PPUSH
15377: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
15381: CALL_OW 44
15385: PPUSH
15386: LD_VAR 0 3
15390: PPUSH
15391: CALL_OW 52
// end ;
15395: GO 15269
15397: POP
15398: POP
// for i = 1 to Difficulty do
15399: LD_ADDR_VAR 0 2
15403: PUSH
15404: DOUBLE
15405: LD_INT 1
15407: DEC
15408: ST_TO_ADDR
15409: LD_OWVAR 67
15413: PUSH
15414: FOR_TO
15415: IFFALSE 15475
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
15417: LD_INT 14
15419: PPUSH
15420: LD_INT 3
15422: PPUSH
15423: LD_INT 5
15425: PPUSH
15426: LD_INT 29
15428: PPUSH
15429: LD_INT 80
15431: PPUSH
15432: CALL 72350 0 5
// veh := CreateVehicle ;
15436: LD_ADDR_VAR 0 3
15440: PUSH
15441: CALL_OW 45
15445: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
15446: LD_VAR 0 3
15450: PPUSH
15451: LD_INT 4
15453: PPUSH
15454: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
15458: LD_VAR 0 3
15462: PPUSH
15463: LD_INT 28
15465: PPUSH
15466: LD_INT 0
15468: PPUSH
15469: CALL_OW 49
// end ;
15473: GO 15414
15475: POP
15476: POP
// end ;
15477: LD_VAR 0 1
15481: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
15482: LD_INT 22
15484: PUSH
15485: LD_INT 2
15487: PUSH
15488: EMPTY
15489: LIST
15490: LIST
15491: PPUSH
15492: CALL_OW 69
15496: IFFALSE 15875
15498: GO 15500
15500: DISABLE
15501: LD_INT 0
15503: PPUSH
15504: PPUSH
15505: PPUSH
15506: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
15507: LD_ADDR_VAR 0 3
15511: PUSH
15512: LD_INT 22
15514: PUSH
15515: LD_INT 2
15517: PUSH
15518: EMPTY
15519: LIST
15520: LIST
15521: PUSH
15522: LD_INT 25
15524: PUSH
15525: LD_INT 4
15527: PUSH
15528: EMPTY
15529: LIST
15530: LIST
15531: PUSH
15532: EMPTY
15533: LIST
15534: LIST
15535: PPUSH
15536: CALL_OW 69
15540: PUSH
15541: LD_EXP 96
15545: DIFF
15546: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
15547: LD_ADDR_VAR 0 2
15551: PUSH
15552: LD_INT 22
15554: PUSH
15555: LD_INT 2
15557: PUSH
15558: EMPTY
15559: LIST
15560: LIST
15561: PPUSH
15562: CALL_OW 69
15566: PUSH
15567: LD_EXP 96
15571: PUSH
15572: LD_VAR 0 3
15576: UNION
15577: DIFF
15578: ST_TO_ADDR
// if Khatam then
15579: LD_EXP 96
15583: IFFALSE 15600
// ComMoveXY ( Khatam , 211 , 92 ) ;
15585: LD_EXP 96
15589: PPUSH
15590: LD_INT 211
15592: PPUSH
15593: LD_INT 92
15595: PPUSH
15596: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
15600: LD_INT 197
15602: PPUSH
15603: LD_INT 80
15605: PPUSH
15606: LD_INT 2
15608: PPUSH
15609: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
15613: LD_INT 213
15615: PPUSH
15616: LD_INT 90
15618: PPUSH
15619: LD_INT 2
15621: PPUSH
15622: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
15626: LD_INT 215
15628: PPUSH
15629: LD_INT 129
15631: PPUSH
15632: LD_INT 2
15634: PPUSH
15635: CALL_OW 441
// if sci then
15639: LD_VAR 0 3
15643: IFFALSE 15664
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
15645: LD_VAR 0 3
15649: PUSH
15650: LD_INT 1
15652: ARRAY
15653: PPUSH
15654: LD_INT 197
15656: PPUSH
15657: LD_INT 80
15659: PPUSH
15660: CALL_OW 158
// if sci > 1 then
15664: LD_VAR 0 3
15668: PUSH
15669: LD_INT 1
15671: GREATER
15672: IFFALSE 15693
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
15674: LD_VAR 0 3
15678: PUSH
15679: LD_INT 2
15681: ARRAY
15682: PPUSH
15683: LD_INT 213
15685: PPUSH
15686: LD_INT 90
15688: PPUSH
15689: CALL_OW 158
// if sci > 2 then
15693: LD_VAR 0 3
15697: PUSH
15698: LD_INT 2
15700: GREATER
15701: IFFALSE 15722
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
15703: LD_VAR 0 3
15707: PUSH
15708: LD_INT 3
15710: ARRAY
15711: PPUSH
15712: LD_INT 215
15714: PPUSH
15715: LD_INT 129
15717: PPUSH
15718: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
15722: LD_VAR 0 2
15726: PPUSH
15727: LD_INT 195
15729: PPUSH
15730: LD_INT 102
15732: PPUSH
15733: CALL_OW 114
// wait ( 0 0$5 ) ;
15737: LD_INT 175
15739: PPUSH
15740: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
15744: LD_INT 70
15746: PPUSH
15747: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
15751: LD_ADDR_VAR 0 4
15755: PUSH
15756: LD_INT 92
15758: PUSH
15759: LD_INT 195
15761: PUSH
15762: LD_INT 102
15764: PUSH
15765: LD_INT 36
15767: PUSH
15768: EMPTY
15769: LIST
15770: LIST
15771: LIST
15772: LIST
15773: PUSH
15774: LD_INT 22
15776: PUSH
15777: LD_INT 1
15779: PUSH
15780: EMPTY
15781: LIST
15782: LIST
15783: PUSH
15784: EMPTY
15785: LIST
15786: LIST
15787: PPUSH
15788: CALL_OW 69
15792: ST_TO_ADDR
// for i in tmp do
15793: LD_ADDR_VAR 0 1
15797: PUSH
15798: LD_VAR 0 2
15802: PUSH
15803: FOR_IN
15804: IFFALSE 15855
// if enemy then
15806: LD_VAR 0 4
15810: IFFALSE 15838
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15812: LD_VAR 0 1
15816: PPUSH
15817: LD_VAR 0 4
15821: PPUSH
15822: LD_VAR 0 1
15826: PPUSH
15827: CALL_OW 74
15831: PPUSH
15832: CALL_OW 115
15836: GO 15853
// ComAgressiveMove ( i , 195 , 102 ) ;
15838: LD_VAR 0 1
15842: PPUSH
15843: LD_INT 195
15845: PPUSH
15846: LD_INT 102
15848: PPUSH
15849: CALL_OW 114
15853: GO 15803
15855: POP
15856: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
15857: LD_VAR 0 2
15861: PPUSH
15862: LD_INT 50
15864: PUSH
15865: EMPTY
15866: LIST
15867: PPUSH
15868: CALL_OW 72
15872: NOT
15873: IFFALSE 15744
// end ; end_of_file
15875: PPOPN 4
15877: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
15878: LD_INT 0
15880: PPUSH
15881: PPUSH
15882: PPUSH
15883: PPUSH
15884: PPUSH
15885: PPUSH
15886: PPUSH
15887: PPUSH
15888: PPUSH
// Video ( true ) ;
15889: LD_INT 1
15891: PPUSH
15892: CALL 104756 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
15896: LD_ADDR_VAR 0 5
15900: PUSH
15901: LD_INT 7
15903: PPUSH
15904: LD_INT 0
15906: PPUSH
15907: CALL_OW 517
15911: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15912: LD_ADDR_VAR 0 2
15916: PUSH
15917: DOUBLE
15918: LD_INT 1
15920: DEC
15921: ST_TO_ADDR
15922: LD_VAR 0 5
15926: PUSH
15927: LD_INT 1
15929: ARRAY
15930: PUSH
15931: FOR_TO
15932: IFFALSE 15977
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15934: LD_VAR 0 5
15938: PUSH
15939: LD_INT 1
15941: ARRAY
15942: PUSH
15943: LD_VAR 0 2
15947: ARRAY
15948: PPUSH
15949: LD_VAR 0 5
15953: PUSH
15954: LD_INT 2
15956: ARRAY
15957: PUSH
15958: LD_VAR 0 2
15962: ARRAY
15963: PPUSH
15964: LD_INT 1
15966: PPUSH
15967: LD_INT 15
15969: NEG
15970: PPUSH
15971: CALL 104670 0 4
15975: GO 15931
15977: POP
15978: POP
// CenterNowOnUnits ( Powell ) ;
15979: LD_EXP 59
15983: PPUSH
15984: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15988: LD_ADDR_VAR 0 5
15992: PUSH
15993: LD_EXP 57
15997: PUSH
15998: EMPTY
15999: LIST
16000: ST_TO_ADDR
// if GirlNewVeh then
16001: LD_EXP 58
16005: IFFALSE 16023
// tmp := tmp ^ GirlNewVeh ;
16007: LD_ADDR_VAR 0 5
16011: PUSH
16012: LD_VAR 0 5
16016: PUSH
16017: LD_EXP 58
16021: ADD
16022: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
16023: LD_VAR 0 5
16027: PPUSH
16028: LD_INT 60
16030: PPUSH
16031: LD_INT 109
16033: PPUSH
16034: CALL_OW 111
// if KappaStatus then
16038: LD_EXP 2
16042: IFFALSE 16094
// begin Say ( JMM , D1nT-JMM-1 ) ;
16044: LD_EXP 40
16048: PPUSH
16049: LD_STRING D1nT-JMM-1
16051: PPUSH
16052: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
16056: LD_EXP 59
16060: PPUSH
16061: LD_STRING D1T-Pow-1
16063: PPUSH
16064: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
16068: LD_EXP 40
16072: PPUSH
16073: LD_STRING D1T-JMM-2
16075: PPUSH
16076: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
16080: LD_EXP 59
16084: PPUSH
16085: LD_STRING D1T-Pow-2
16087: PPUSH
16088: CALL_OW 88
// end else
16092: GO 16300
// if JMMGirlStatus then
16094: LD_EXP 6
16098: IFFALSE 16243
// begin Say ( JMM , D1T-JMM-1 ) ;
16100: LD_EXP 40
16104: PPUSH
16105: LD_STRING D1T-JMM-1
16107: PPUSH
16108: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
16112: LD_EXP 59
16116: PPUSH
16117: LD_STRING D1T-Pow-1
16119: PPUSH
16120: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
16124: LD_EXP 40
16128: PPUSH
16129: LD_STRING D1T-JMM-3
16131: PPUSH
16132: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
16136: LD_EXP 59
16140: PPUSH
16141: LD_STRING D1T-Pow-3
16143: PPUSH
16144: CALL_OW 88
// if JMMGirl then
16148: LD_EXP 7
16152: IFFALSE 16241
// begin case JMMGirl of 1 :
16154: LD_EXP 7
16158: PUSH
16159: LD_INT 1
16161: DOUBLE
16162: EQUAL
16163: IFTRUE 16167
16165: GO 16182
16167: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
16168: LD_EXP 41
16172: PPUSH
16173: LD_STRING D1T-Joan-3
16175: PPUSH
16176: CALL_OW 88
16180: GO 16229
16182: LD_INT 2
16184: DOUBLE
16185: EQUAL
16186: IFTRUE 16190
16188: GO 16205
16190: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
16191: LD_EXP 43
16195: PPUSH
16196: LD_STRING D1T-Lisa-3
16198: PPUSH
16199: CALL_OW 88
16203: GO 16229
16205: LD_INT 3
16207: DOUBLE
16208: EQUAL
16209: IFTRUE 16213
16211: GO 16228
16213: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
16214: LD_EXP 55
16218: PPUSH
16219: LD_STRING D1T-Con-3
16221: PPUSH
16222: CALL_OW 88
16226: GO 16229
16228: POP
// Say ( Powell , D1T-Pow-4 ) ;
16229: LD_EXP 59
16233: PPUSH
16234: LD_STRING D1T-Pow-4
16236: PPUSH
16237: CALL_OW 88
// end ; end else
16241: GO 16300
// if not FastEnd then
16243: LD_EXP 11
16247: NOT
16248: IFFALSE 16276
// begin Say ( JMM , D1T-JMM-4 ) ;
16250: LD_EXP 40
16254: PPUSH
16255: LD_STRING D1T-JMM-4
16257: PPUSH
16258: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
16262: LD_EXP 59
16266: PPUSH
16267: LD_STRING D1T-Pow-5
16269: PPUSH
16270: CALL_OW 88
// end else
16274: GO 16300
// begin Say ( JMM , D1nT-JMM-1 ) ;
16276: LD_EXP 40
16280: PPUSH
16281: LD_STRING D1nT-JMM-1
16283: PPUSH
16284: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
16288: LD_EXP 59
16292: PPUSH
16293: LD_STRING D1nT-Pow-1
16295: PPUSH
16296: CALL_OW 88
// end ; repeat wait ( 3 ) ;
16300: LD_INT 3
16302: PPUSH
16303: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
16307: LD_EXP 57
16311: PPUSH
16312: CALL_OW 314
16316: NOT
16317: IFFALSE 16300
// ComExitVehicle ( JMM ) ;
16319: LD_EXP 40
16323: PPUSH
16324: CALL_OW 121
// repeat wait ( 3 ) ;
16328: LD_INT 3
16330: PPUSH
16331: CALL_OW 67
// until not IsInUnit ( JMM ) ;
16335: LD_EXP 40
16339: PPUSH
16340: CALL_OW 310
16344: NOT
16345: IFFALSE 16328
// ComMoveXY ( JMM , 60 , 94 ) ;
16347: LD_EXP 40
16351: PPUSH
16352: LD_INT 60
16354: PPUSH
16355: LD_INT 94
16357: PPUSH
16358: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16362: LD_EXP 40
16366: PPUSH
16367: LD_EXP 59
16371: PPUSH
16372: CALL_OW 179
// if Joan then
16376: LD_EXP 41
16380: IFFALSE 16434
// begin ComExitVehicle ( Joan ) ;
16382: LD_EXP 41
16386: PPUSH
16387: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
16391: LD_EXP 41
16395: PPUSH
16396: LD_INT 35
16398: PPUSH
16399: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
16403: LD_EXP 41
16407: PPUSH
16408: LD_INT 65
16410: PPUSH
16411: LD_INT 104
16413: PPUSH
16414: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
16418: LD_EXP 41
16422: PPUSH
16423: LD_EXP 40
16427: PPUSH
16428: CALL_OW 179
// end else
16432: GO 16568
// if Lisa and JMMGirl = 2 then
16434: LD_EXP 43
16438: PUSH
16439: LD_EXP 7
16443: PUSH
16444: LD_INT 2
16446: EQUAL
16447: AND
16448: IFFALSE 16502
// begin ComExitVehicle ( Lisa ) ;
16450: LD_EXP 43
16454: PPUSH
16455: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
16459: LD_EXP 43
16463: PPUSH
16464: LD_INT 35
16466: PPUSH
16467: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
16471: LD_EXP 43
16475: PPUSH
16476: LD_INT 65
16478: PPUSH
16479: LD_INT 104
16481: PPUSH
16482: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
16486: LD_EXP 43
16490: PPUSH
16491: LD_EXP 40
16495: PPUSH
16496: CALL_OW 179
// end else
16500: GO 16568
// if Connie and JMMGirl = 3 then
16502: LD_EXP 55
16506: PUSH
16507: LD_EXP 7
16511: PUSH
16512: LD_INT 3
16514: EQUAL
16515: AND
16516: IFFALSE 16568
// begin ComExitVehicle ( Connie ) ;
16518: LD_EXP 55
16522: PPUSH
16523: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
16527: LD_EXP 55
16531: PPUSH
16532: LD_INT 35
16534: PPUSH
16535: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
16539: LD_EXP 55
16543: PPUSH
16544: LD_INT 65
16546: PPUSH
16547: LD_INT 104
16549: PPUSH
16550: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
16554: LD_EXP 55
16558: PPUSH
16559: LD_EXP 40
16563: PPUSH
16564: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
16568: LD_INT 35
16570: PPUSH
16571: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
16575: LD_EXP 40
16579: PPUSH
16580: LD_EXP 59
16584: PPUSH
16585: CALL_OW 296
16589: PUSH
16590: LD_INT 8
16592: LESS
16593: IFFALSE 16568
// wait ( 0 0$0.5 ) ;
16595: LD_INT 18
16597: PPUSH
16598: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
16602: LD_EXP 40
16606: PPUSH
16607: LD_STRING D1-JMM-1
16609: PPUSH
16610: CALL_OW 88
// async ;
16614: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
16615: LD_EXP 59
16619: PPUSH
16620: LD_STRING D1-Pow-1
16622: PPUSH
16623: CALL_OW 88
// if not dialogue_skipped then
16627: LD_OWVAR 59
16631: NOT
16632: IFFALSE 16641
// wait ( 0 0$2 ) ;
16634: LD_INT 70
16636: PPUSH
16637: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
16641: LD_INT 170
16643: PPUSH
16644: LD_INT 99
16646: PPUSH
16647: LD_INT 1
16649: PPUSH
16650: LD_INT 6
16652: NEG
16653: PPUSH
16654: CALL 104670 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
16658: LD_INT 174
16660: PPUSH
16661: LD_INT 115
16663: PPUSH
16664: LD_INT 1
16666: PPUSH
16667: LD_INT 6
16669: NEG
16670: PPUSH
16671: CALL 104670 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
16675: LD_INT 169
16677: PPUSH
16678: LD_INT 71
16680: PPUSH
16681: LD_INT 1
16683: PPUSH
16684: LD_INT 6
16686: NEG
16687: PPUSH
16688: CALL 104670 0 4
// if not dialogue_skipped then
16692: LD_OWVAR 59
16696: NOT
16697: IFFALSE 16716
// begin CenterOnXY ( 170 , 99 ) ;
16699: LD_INT 170
16701: PPUSH
16702: LD_INT 99
16704: PPUSH
16705: CALL_OW 84
// wait ( 0 0$2.3 ) ;
16709: LD_INT 80
16711: PPUSH
16712: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
16716: LD_INT 75
16718: PPUSH
16719: LD_INT 53
16721: PPUSH
16722: LD_INT 1
16724: PPUSH
16725: LD_INT 9
16727: NEG
16728: PPUSH
16729: CALL 104670 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
16733: LD_INT 54
16735: PPUSH
16736: LD_INT 42
16738: PPUSH
16739: LD_INT 1
16741: PPUSH
16742: LD_INT 9
16744: NEG
16745: PPUSH
16746: CALL 104670 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
16750: LD_INT 62
16752: PPUSH
16753: LD_INT 51
16755: PPUSH
16756: LD_INT 1
16758: PPUSH
16759: LD_INT 9
16761: NEG
16762: PPUSH
16763: CALL 104670 0 4
// if not dialogue_skipped then
16767: LD_OWVAR 59
16771: NOT
16772: IFFALSE 16791
// begin CenterOnXY ( 75 , 53 ) ;
16774: LD_INT 75
16776: PPUSH
16777: LD_INT 53
16779: PPUSH
16780: CALL_OW 84
// wait ( 0 0$4 ) ;
16784: LD_INT 140
16786: PPUSH
16787: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
16791: LD_EXP 59
16795: PPUSH
16796: CALL_OW 87
// if not dialogue_skipped then
16800: LD_OWVAR 59
16804: NOT
16805: IFFALSE 16814
// wait ( 0 0$2 ) ;
16807: LD_INT 70
16809: PPUSH
16810: CALL_OW 67
// sync ;
16814: SYNC
// Say ( JMM , D1-JMM-2 ) ;
16815: LD_EXP 40
16819: PPUSH
16820: LD_STRING D1-JMM-2
16822: PPUSH
16823: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
16827: LD_EXP 59
16831: PPUSH
16832: LD_STRING D1-Pow-2
16834: PPUSH
16835: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
16839: LD_EXP 40
16843: PPUSH
16844: LD_STRING D1-JMM-3
16846: PPUSH
16847: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
16851: LD_EXP 59
16855: PPUSH
16856: LD_STRING D1-Pow-3
16858: PPUSH
16859: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
16863: LD_EXP 40
16867: PPUSH
16868: LD_STRING D1-JMM-4
16870: PPUSH
16871: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
16875: LD_EXP 59
16879: PPUSH
16880: LD_STRING D1-Pow-4
16882: PPUSH
16883: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
16887: LD_EXP 40
16891: PPUSH
16892: LD_STRING D1-JMM-5
16894: PPUSH
16895: CALL_OW 88
// async ;
16899: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
16900: LD_EXP 59
16904: PPUSH
16905: LD_STRING D1-Pow-5
16907: PPUSH
16908: CALL_OW 88
// if not dialogue_skipped then
16912: LD_OWVAR 59
16916: NOT
16917: IFFALSE 16926
// wait ( 0 0$3.6 ) ;
16919: LD_INT 126
16921: PPUSH
16922: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16926: LD_INT 134
16928: PPUSH
16929: LD_INT 210
16931: PPUSH
16932: LD_INT 1
16934: PPUSH
16935: LD_INT 11
16937: NEG
16938: PPUSH
16939: CALL 104670 0 4
// if not dialogue_skipped then
16943: LD_OWVAR 59
16947: NOT
16948: IFFALSE 16967
// begin CenterOnXY ( 134 , 210 ) ;
16950: LD_INT 134
16952: PPUSH
16953: LD_INT 210
16955: PPUSH
16956: CALL_OW 84
// wait ( 0 0$2 ) ;
16960: LD_INT 70
16962: PPUSH
16963: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16967: LD_INT 101
16969: PPUSH
16970: LD_INT 159
16972: PPUSH
16973: LD_INT 1
16975: PPUSH
16976: LD_INT 10
16978: NEG
16979: PPUSH
16980: CALL 104670 0 4
// if not dialogue_skipped then
16984: LD_OWVAR 59
16988: NOT
16989: IFFALSE 17008
// begin CenterOnXY ( 101 , 159 ) ;
16991: LD_INT 101
16993: PPUSH
16994: LD_INT 159
16996: PPUSH
16997: CALL_OW 84
// wait ( 0 0$2 ) ;
17001: LD_INT 70
17003: PPUSH
17004: CALL_OW 67
// end ; sync ;
17008: SYNC
// CenterNowOnUnits ( Powell ) ;
17009: LD_EXP 59
17013: PPUSH
17014: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
17018: LD_ADDR_VAR 0 6
17022: PUSH
17023: LD_INT 1
17025: PUSH
17026: LD_INT 2
17028: PUSH
17029: LD_INT 3
17031: PUSH
17032: LD_INT 4
17034: PUSH
17035: LD_INT 5
17037: PUSH
17038: LD_INT 6
17040: PUSH
17041: EMPTY
17042: LIST
17043: LIST
17044: LIST
17045: LIST
17046: LIST
17047: LIST
17048: ST_TO_ADDR
// if not dialogue_skipped then
17049: LD_OWVAR 59
17053: NOT
17054: IFFALSE 17223
// begin game_speed := 4 ;
17056: LD_ADDR_OWVAR 65
17060: PUSH
17061: LD_INT 4
17063: ST_TO_ADDR
// wait ( 0 0$6 ) ;
17064: LD_INT 210
17066: PPUSH
17067: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
17071: LD_ADDR_VAR 0 7
17075: PUSH
17076: LD_STRING Q1
17078: PPUSH
17079: LD_VAR 0 6
17083: PPUSH
17084: CALL_OW 98
17088: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
17089: LD_ADDR_VAR 0 7
17093: PUSH
17094: LD_STRING Q1
17096: PPUSH
17097: LD_VAR 0 6
17101: PPUSH
17102: CALL_OW 98
17106: ST_TO_ADDR
// options := options diff dec ;
17107: LD_ADDR_VAR 0 6
17111: PUSH
17112: LD_VAR 0 6
17116: PUSH
17117: LD_VAR 0 7
17121: DIFF
17122: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
17123: LD_VAR 0 7
17127: PPUSH
17128: LD_VAR 0 6
17132: PPUSH
17133: CALL 18739 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
17137: LD_VAR 0 7
17141: PUSH
17142: LD_INT 5
17144: PUSH
17145: LD_INT 6
17147: PUSH
17148: EMPTY
17149: LIST
17150: LIST
17151: IN
17152: PUSH
17153: LD_VAR 0 6
17157: PUSH
17158: LD_INT 2
17160: EQUAL
17161: OR
17162: IFFALSE 17089
// if not ( dec in [ 5 , 6 ] ) then
17164: LD_VAR 0 7
17168: PUSH
17169: LD_INT 5
17171: PUSH
17172: LD_INT 6
17174: PUSH
17175: EMPTY
17176: LIST
17177: LIST
17178: IN
17179: NOT
17180: IFFALSE 17223
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
17182: LD_ADDR_VAR 0 7
17186: PUSH
17187: LD_STRING Q1a
17189: PPUSH
17190: LD_INT 1
17192: PUSH
17193: LD_INT 2
17195: PUSH
17196: EMPTY
17197: LIST
17198: LIST
17199: PPUSH
17200: CALL_OW 98
17204: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
17205: LD_VAR 0 7
17209: PUSH
17210: LD_INT 4
17212: PLUS
17213: PPUSH
17214: LD_VAR 0 6
17218: PPUSH
17219: CALL 18739 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
17223: LD_INT 81
17225: PPUSH
17226: LD_INT 127
17228: PPUSH
17229: CALL_OW 84
// amount := 8 ;
17233: LD_ADDR_VAR 0 8
17237: PUSH
17238: LD_INT 8
17240: ST_TO_ADDR
// macmilan_squad := [ ] ;
17241: LD_ADDR_VAR 0 9
17245: PUSH
17246: EMPTY
17247: ST_TO_ADDR
// if vip < amount then
17248: LD_EXP 60
17252: PUSH
17253: LD_VAR 0 8
17257: LESS
17258: IFFALSE 17302
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
17260: LD_ADDR_VAR 0 5
17264: PUSH
17265: LD_EXP 60
17269: PUSH
17270: LD_INT 22
17272: PUSH
17273: LD_INT 4
17275: PUSH
17276: EMPTY
17277: LIST
17278: LIST
17279: PUSH
17280: LD_INT 21
17282: PUSH
17283: LD_INT 1
17285: PUSH
17286: EMPTY
17287: LIST
17288: LIST
17289: PUSH
17290: EMPTY
17291: LIST
17292: LIST
17293: PPUSH
17294: CALL_OW 69
17298: UNION
17299: ST_TO_ADDR
17300: GO 17312
// tmp := vip ;
17302: LD_ADDR_VAR 0 5
17306: PUSH
17307: LD_EXP 60
17311: ST_TO_ADDR
// tmp := tmp diff Powell ;
17312: LD_ADDR_VAR 0 5
17316: PUSH
17317: LD_VAR 0 5
17321: PUSH
17322: LD_EXP 59
17326: DIFF
17327: ST_TO_ADDR
// if tmp < amount then
17328: LD_VAR 0 5
17332: PUSH
17333: LD_VAR 0 8
17337: LESS
17338: IFFALSE 17350
// amount := tmp ;
17340: LD_ADDR_VAR 0 8
17344: PUSH
17345: LD_VAR 0 5
17349: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
17350: LD_VAR 0 5
17354: PUSH
17355: LD_INT 1
17357: ARRAY
17358: PPUSH
17359: CALL_OW 257
17363: PUSH
17364: LD_INT 2
17366: NONEQUAL
17367: IFFALSE 17465
// begin if IsInUnit ( tmp [ 1 ] ) then
17369: LD_VAR 0 5
17373: PUSH
17374: LD_INT 1
17376: ARRAY
17377: PPUSH
17378: CALL_OW 310
17382: IFFALSE 17397
// ComExitBuilding ( tmp [ 1 ] ) ;
17384: LD_VAR 0 5
17388: PUSH
17389: LD_INT 1
17391: ARRAY
17392: PPUSH
17393: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
17397: LD_INT 387
17399: PPUSH
17400: CALL_OW 313
17404: PUSH
17405: LD_INT 6
17407: EQUAL
17408: IFFALSE 17433
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
17410: LD_INT 387
17412: PPUSH
17413: CALL_OW 313
17417: PUSH
17418: LD_INT 1
17420: ARRAY
17421: PPUSH
17422: CALL_OW 122
// wait ( 3 ) ;
17426: LD_INT 3
17428: PPUSH
17429: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
17433: LD_VAR 0 5
17437: PUSH
17438: LD_INT 1
17440: ARRAY
17441: PPUSH
17442: LD_INT 387
17444: PPUSH
17445: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
17449: LD_VAR 0 5
17453: PUSH
17454: LD_INT 1
17456: ARRAY
17457: PPUSH
17458: LD_INT 2
17460: PPUSH
17461: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
17465: LD_EXP 40
17469: PPUSH
17470: LD_INT 82
17472: PPUSH
17473: LD_INT 129
17475: PPUSH
17476: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
17480: LD_EXP 40
17484: PPUSH
17485: LD_EXP 59
17489: PPUSH
17490: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
17494: LD_INT 22
17496: PUSH
17497: LD_INT 1
17499: PUSH
17500: EMPTY
17501: LIST
17502: LIST
17503: PPUSH
17504: CALL_OW 69
17508: PUSH
17509: LD_EXP 40
17513: DIFF
17514: PPUSH
17515: LD_INT 84
17517: PPUSH
17518: LD_INT 128
17520: PPUSH
17521: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
17525: LD_INT 22
17527: PUSH
17528: LD_INT 1
17530: PUSH
17531: EMPTY
17532: LIST
17533: LIST
17534: PPUSH
17535: CALL_OW 69
17539: PUSH
17540: LD_EXP 40
17544: DIFF
17545: PPUSH
17546: LD_EXP 40
17550: PPUSH
17551: CALL_OW 179
// for i = 1 to amount do
17555: LD_ADDR_VAR 0 2
17559: PUSH
17560: DOUBLE
17561: LD_INT 1
17563: DEC
17564: ST_TO_ADDR
17565: LD_VAR 0 8
17569: PUSH
17570: FOR_TO
17571: IFFALSE 17739
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
17573: LD_ADDR_VAR 0 9
17577: PUSH
17578: LD_VAR 0 9
17582: PUSH
17583: LD_VAR 0 5
17587: PUSH
17588: LD_VAR 0 2
17592: ARRAY
17593: ADD
17594: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
17595: LD_VAR 0 5
17599: PUSH
17600: LD_VAR 0 2
17604: ARRAY
17605: PPUSH
17606: CALL_OW 310
17610: IFFALSE 17627
// AddComExitBuilding ( tmp [ i ] ) ;
17612: LD_VAR 0 5
17616: PUSH
17617: LD_VAR 0 2
17621: ARRAY
17622: PPUSH
17623: CALL_OW 182
// if i = 2 and JMMNewVeh then
17627: LD_VAR 0 2
17631: PUSH
17632: LD_INT 2
17634: EQUAL
17635: PUSH
17636: LD_EXP 57
17640: AND
17641: IFFALSE 17699
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
17643: LD_VAR 0 5
17647: PUSH
17648: LD_VAR 0 2
17652: ARRAY
17653: PPUSH
17654: LD_EXP 57
17658: PPUSH
17659: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
17663: LD_VAR 0 5
17667: PUSH
17668: LD_VAR 0 2
17672: ARRAY
17673: PPUSH
17674: LD_INT 86
17676: PPUSH
17677: LD_INT 133
17679: PPUSH
17680: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
17684: LD_VAR 0 5
17688: PUSH
17689: LD_VAR 0 2
17693: ARRAY
17694: PPUSH
17695: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
17699: LD_VAR 0 5
17703: PUSH
17704: LD_VAR 0 2
17708: ARRAY
17709: PPUSH
17710: LD_INT 8
17712: PPUSH
17713: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
17717: LD_VAR 0 5
17721: PUSH
17722: LD_VAR 0 2
17726: ARRAY
17727: PPUSH
17728: LD_EXP 40
17732: PPUSH
17733: CALL_OW 179
// end ;
17737: GO 17570
17739: POP
17740: POP
// if GirlNewVeh then
17741: LD_EXP 58
17745: IFFALSE 17759
// SetSide ( GirlNewVeh , 4 ) ;
17747: LD_EXP 58
17751: PPUSH
17752: LD_INT 4
17754: PPUSH
17755: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
17759: LD_INT 35
17761: PPUSH
17762: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
17766: LD_VAR 0 9
17770: PPUSH
17771: LD_INT 95
17773: PUSH
17774: LD_INT 9
17776: PUSH
17777: EMPTY
17778: LIST
17779: LIST
17780: PPUSH
17781: CALL_OW 72
17785: PUSH
17786: LD_INT 0
17788: EQUAL
17789: PUSH
17790: LD_EXP 40
17794: PPUSH
17795: LD_INT 9
17797: PPUSH
17798: CALL_OW 308
17802: NOT
17803: AND
17804: IFFALSE 17759
// wait ( 0 0$2 ) ;
17806: LD_INT 70
17808: PPUSH
17809: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
17813: LD_VAR 0 9
17817: PPUSH
17818: LD_INT 1
17820: PPUSH
17821: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
17825: LD_INT 21
17827: PUSH
17828: LD_INT 2
17830: PUSH
17831: EMPTY
17832: LIST
17833: LIST
17834: PUSH
17835: LD_INT 92
17837: PUSH
17838: LD_INT 83
17840: PUSH
17841: LD_INT 130
17843: PUSH
17844: LD_INT 10
17846: PUSH
17847: EMPTY
17848: LIST
17849: LIST
17850: LIST
17851: LIST
17852: PUSH
17853: EMPTY
17854: LIST
17855: LIST
17856: PPUSH
17857: CALL_OW 69
17861: PPUSH
17862: LD_INT 1
17864: PPUSH
17865: CALL_OW 235
// tick := 0 ;
17869: LD_ADDR_OWVAR 1
17873: PUSH
17874: LD_INT 0
17876: ST_TO_ADDR
// Video ( false ) ;
17877: LD_INT 0
17879: PPUSH
17880: CALL 104756 0 1
// ChangeMissionObjectives ( M1 ) ;
17884: LD_STRING M1
17886: PPUSH
17887: CALL_OW 337
// SaveForQuickRestart ;
17891: CALL_OW 22
// missionStart := true ;
17895: LD_ADDR_EXP 13
17899: PUSH
17900: LD_INT 1
17902: ST_TO_ADDR
// missionStage := 2 ;
17903: LD_ADDR_EXP 15
17907: PUSH
17908: LD_INT 2
17910: ST_TO_ADDR
// wait ( 0 0$1 ) ;
17911: LD_INT 35
17913: PPUSH
17914: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
17918: LD_ADDR_VAR 0 5
17922: PUSH
17923: LD_INT 22
17925: PUSH
17926: LD_INT 4
17928: PUSH
17929: EMPTY
17930: LIST
17931: LIST
17932: PUSH
17933: LD_INT 21
17935: PUSH
17936: LD_INT 1
17938: PUSH
17939: EMPTY
17940: LIST
17941: LIST
17942: PUSH
17943: EMPTY
17944: LIST
17945: LIST
17946: PPUSH
17947: CALL_OW 69
17951: PUSH
17952: LD_EXP 59
17956: DIFF
17957: ST_TO_ADDR
// if not tmp then
17958: LD_VAR 0 5
17962: NOT
17963: IFFALSE 17978
// tmp := [ Powell ] ;
17965: LD_ADDR_VAR 0 5
17969: PUSH
17970: LD_EXP 59
17974: PUSH
17975: EMPTY
17976: LIST
17977: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17978: LD_ADDR_VAR 0 4
17982: PUSH
17983: LD_INT 22
17985: PUSH
17986: LD_INT 4
17988: PUSH
17989: EMPTY
17990: LIST
17991: LIST
17992: PUSH
17993: LD_INT 34
17995: PUSH
17996: LD_INT 12
17998: PUSH
17999: EMPTY
18000: LIST
18001: LIST
18002: PUSH
18003: EMPTY
18004: LIST
18005: LIST
18006: PPUSH
18007: CALL_OW 69
18011: PUSH
18012: LD_INT 1
18014: ARRAY
18015: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
18016: LD_VAR 0 5
18020: PUSH
18021: LD_INT 1
18023: ARRAY
18024: PPUSH
18025: CALL_OW 310
18029: IFFALSE 18044
// ComExitBuilding ( tmp [ 1 ] ) ;
18031: LD_VAR 0 5
18035: PUSH
18036: LD_INT 1
18038: ARRAY
18039: PPUSH
18040: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
18044: LD_VAR 0 5
18048: PUSH
18049: LD_INT 1
18051: ARRAY
18052: PPUSH
18053: LD_VAR 0 4
18057: PPUSH
18058: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
18062: LD_VAR 0 5
18066: PUSH
18067: LD_INT 1
18069: ARRAY
18070: PPUSH
18071: LD_INT 80
18073: PPUSH
18074: LD_INT 136
18076: PPUSH
18077: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
18081: LD_VAR 0 5
18085: PUSH
18086: LD_INT 1
18088: ARRAY
18089: PPUSH
18090: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
18094: LD_VAR 0 5
18098: PUSH
18099: LD_INT 1
18101: ARRAY
18102: PPUSH
18103: LD_INT 59
18105: PPUSH
18106: LD_INT 112
18108: PPUSH
18109: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
18113: LD_VAR 0 5
18117: PUSH
18118: LD_INT 1
18120: ARRAY
18121: PPUSH
18122: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
18126: LD_EXP 41
18130: PUSH
18131: LD_EXP 41
18135: PPUSH
18136: CALL_OW 255
18140: PUSH
18141: LD_INT 1
18143: EQUAL
18144: AND
18145: IFFALSE 18171
// begin Say ( Joan , D3W-Joan-1 ) ;
18147: LD_EXP 41
18151: PPUSH
18152: LD_STRING D3W-Joan-1
18154: PPUSH
18155: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18159: LD_EXP 40
18163: PPUSH
18164: LD_STRING D3W-JMM-1
18166: PPUSH
18167: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
18171: LD_EXP 43
18175: PUSH
18176: LD_EXP 43
18180: PPUSH
18181: CALL_OW 255
18185: PUSH
18186: LD_INT 1
18188: EQUAL
18189: AND
18190: PUSH
18191: LD_EXP 43
18195: PUSH
18196: LD_EXP 60
18200: IN
18201: NOT
18202: AND
18203: IFFALSE 18229
// begin Say ( Lisa , D3W-Lisa-1 ) ;
18205: LD_EXP 43
18209: PPUSH
18210: LD_STRING D3W-Lisa-1
18212: PPUSH
18213: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18217: LD_EXP 40
18221: PPUSH
18222: LD_STRING D3W-JMM-1
18224: PPUSH
18225: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
18229: LD_EXP 55
18233: PUSH
18234: LD_EXP 55
18238: PPUSH
18239: CALL_OW 255
18243: PUSH
18244: LD_INT 1
18246: EQUAL
18247: AND
18248: IFFALSE 18274
// begin Say ( Connie , D3W-Con-1 ) ;
18250: LD_EXP 55
18254: PPUSH
18255: LD_STRING D3W-Con-1
18257: PPUSH
18258: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18262: LD_EXP 40
18266: PPUSH
18267: LD_STRING D3W-JMM-1
18269: PPUSH
18270: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
18274: LD_EXP 43
18278: PUSH
18279: LD_EXP 60
18283: IN
18284: PUSH
18285: LD_EXP 43
18289: PPUSH
18290: CALL_OW 255
18294: PUSH
18295: LD_INT 1
18297: EQUAL
18298: AND
18299: IFFALSE 18315
// Say ( Lisa , D3nW-Lisa-1 ) else
18301: LD_EXP 43
18305: PPUSH
18306: LD_STRING D3nW-Lisa-1
18308: PPUSH
18309: CALL_OW 88
18313: GO 18559
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
18315: LD_EXP 46
18319: PUSH
18320: LD_EXP 60
18324: IN
18325: PUSH
18326: LD_EXP 46
18330: PPUSH
18331: CALL_OW 255
18335: PUSH
18336: LD_INT 1
18338: EQUAL
18339: AND
18340: IFFALSE 18356
// Say ( Cyrus , D3nW-Cyrus-1 ) else
18342: LD_EXP 46
18346: PPUSH
18347: LD_STRING D3nW-Cyrus-1
18349: PPUSH
18350: CALL_OW 88
18354: GO 18559
// if Bobby in vip and GetSide ( Bobby ) = 1 then
18356: LD_EXP 45
18360: PUSH
18361: LD_EXP 60
18365: IN
18366: PUSH
18367: LD_EXP 45
18371: PPUSH
18372: CALL_OW 255
18376: PUSH
18377: LD_INT 1
18379: EQUAL
18380: AND
18381: IFFALSE 18397
// Say ( Bobby , D3nW-Bobby-1 ) else
18383: LD_EXP 45
18387: PPUSH
18388: LD_STRING D3nW-Bobby-1
18390: PPUSH
18391: CALL_OW 88
18395: GO 18559
// if Gary in vip and GetSide ( Gary ) = 1 then
18397: LD_EXP 52
18401: PUSH
18402: LD_EXP 60
18406: IN
18407: PUSH
18408: LD_EXP 52
18412: PPUSH
18413: CALL_OW 255
18417: PUSH
18418: LD_INT 1
18420: EQUAL
18421: AND
18422: IFFALSE 18438
// Say ( Gary , D3nW-Gary-1 ) else
18424: LD_EXP 52
18428: PPUSH
18429: LD_STRING D3nW-Gary-1
18431: PPUSH
18432: CALL_OW 88
18436: GO 18559
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
18438: LD_EXP 44
18442: PUSH
18443: LD_EXP 60
18447: IN
18448: PUSH
18449: LD_EXP 44
18453: PPUSH
18454: CALL_OW 255
18458: PUSH
18459: LD_INT 1
18461: EQUAL
18462: AND
18463: IFFALSE 18479
// Say ( Donaldson , D3nW-Don-1 ) else
18465: LD_EXP 44
18469: PPUSH
18470: LD_STRING D3nW-Don-1
18472: PPUSH
18473: CALL_OW 88
18477: GO 18559
// if Cornel in vip and GetSide ( Cornel ) = 1 then
18479: LD_EXP 51
18483: PUSH
18484: LD_EXP 60
18488: IN
18489: PUSH
18490: LD_EXP 51
18494: PPUSH
18495: CALL_OW 255
18499: PUSH
18500: LD_INT 1
18502: EQUAL
18503: AND
18504: IFFALSE 18520
// Say ( Cornel , D3nW-Corn-1 ) else
18506: LD_EXP 51
18510: PPUSH
18511: LD_STRING D3nW-Corn-1
18513: PPUSH
18514: CALL_OW 88
18518: GO 18559
// if Frank in vip and GetSide ( Frank ) = 1 then
18520: LD_EXP 53
18524: PUSH
18525: LD_EXP 60
18529: IN
18530: PUSH
18531: LD_EXP 53
18535: PPUSH
18536: CALL_OW 255
18540: PUSH
18541: LD_INT 1
18543: EQUAL
18544: AND
18545: IFFALSE 18559
// Say ( Frank , D3nW-Frank-1 ) ;
18547: LD_EXP 53
18551: PPUSH
18552: LD_STRING D3nW-Frank-1
18554: PPUSH
18555: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
18559: LD_EXP 60
18563: PPUSH
18564: LD_INT 22
18566: PUSH
18567: LD_INT 1
18569: PUSH
18570: EMPTY
18571: LIST
18572: LIST
18573: PPUSH
18574: CALL_OW 72
18578: IFFALSE 18604
// begin Say ( JMM , D3nW-JMM-1 ) ;
18580: LD_EXP 40
18584: PPUSH
18585: LD_STRING D3nW-JMM-1
18587: PPUSH
18588: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
18592: LD_EXP 40
18596: PPUSH
18597: LD_STRING D3nW-JMM-1a
18599: PPUSH
18600: CALL_OW 88
// end ; t := 0 0$00 ;
18604: LD_ADDR_VAR 0 3
18608: PUSH
18609: LD_INT 0
18611: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18612: LD_INT 35
18614: PPUSH
18615: CALL_OW 67
// t := t + 0 0$1 ;
18619: LD_ADDR_VAR 0 3
18623: PUSH
18624: LD_VAR 0 3
18628: PUSH
18629: LD_INT 35
18631: PLUS
18632: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
18633: LD_INT 59
18635: PPUSH
18636: LD_INT 112
18638: PPUSH
18639: CALL_OW 428
18643: PUSH
18644: LD_VAR 0 3
18648: PUSH
18649: LD_INT 2100
18651: GREATER
18652: OR
18653: IFFALSE 18612
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
18655: LD_ADDR_EXP 99
18659: PUSH
18660: LD_EXP 99
18664: PPUSH
18665: LD_INT 4
18667: PPUSH
18668: LD_INT 22
18670: PUSH
18671: LD_INT 4
18673: PUSH
18674: EMPTY
18675: LIST
18676: LIST
18677: PUSH
18678: LD_INT 23
18680: PUSH
18681: LD_INT 1
18683: PUSH
18684: EMPTY
18685: LIST
18686: LIST
18687: PUSH
18688: LD_INT 3
18690: PUSH
18691: LD_INT 21
18693: PUSH
18694: LD_INT 2
18696: PUSH
18697: EMPTY
18698: LIST
18699: LIST
18700: PUSH
18701: EMPTY
18702: LIST
18703: LIST
18704: PUSH
18705: EMPTY
18706: LIST
18707: LIST
18708: LIST
18709: PPUSH
18710: CALL_OW 69
18714: PUSH
18715: LD_EXP 59
18719: DIFF
18720: PPUSH
18721: CALL_OW 1
18725: ST_TO_ADDR
// activeAttacks := true ;
18726: LD_ADDR_EXP 16
18730: PUSH
18731: LD_INT 1
18733: ST_TO_ADDR
// end ;
18734: LD_VAR 0 1
18738: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
18739: LD_INT 0
18741: PPUSH
// case question of 1 :
18742: LD_VAR 0 1
18746: PUSH
18747: LD_INT 1
18749: DOUBLE
18750: EQUAL
18751: IFTRUE 18755
18753: GO 18806
18755: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
18756: LD_EXP 40
18760: PPUSH
18761: LD_STRING D2Mot-JMM-1
18763: PPUSH
18764: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
18768: LD_EXP 59
18772: PPUSH
18773: LD_STRING D2Mot-Pow-1
18775: PPUSH
18776: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
18780: LD_EXP 40
18784: PPUSH
18785: LD_STRING D2Mot-JMM-2
18787: PPUSH
18788: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
18792: LD_EXP 59
18796: PPUSH
18797: LD_STRING D2Mot-Pow-2
18799: PPUSH
18800: CALL_OW 88
// end ; 2 :
18804: GO 19157
18806: LD_INT 2
18808: DOUBLE
18809: EQUAL
18810: IFTRUE 18814
18812: GO 18890
18814: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
18815: LD_EXP 40
18819: PPUSH
18820: LD_STRING D2Rus-JMM-1
18822: PPUSH
18823: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
18827: LD_EXP 59
18831: PPUSH
18832: LD_STRING D2Rus-Pow-1
18834: PPUSH
18835: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
18839: LD_EXP 40
18843: PPUSH
18844: LD_STRING D2Rus-JMM-2
18846: PPUSH
18847: CALL_OW 88
// if not ( 3 in list_of_q ) then
18851: LD_INT 3
18853: PUSH
18854: LD_VAR 0 2
18858: IN
18859: NOT
18860: IFFALSE 18876
// Say ( Powell , D2Rus-Pow-2 ) else
18862: LD_EXP 59
18866: PPUSH
18867: LD_STRING D2Rus-Pow-2
18869: PPUSH
18870: CALL_OW 88
18874: GO 18888
// Say ( Powell , D2Rus-Pow-2a ) ;
18876: LD_EXP 59
18880: PPUSH
18881: LD_STRING D2Rus-Pow-2a
18883: PPUSH
18884: CALL_OW 88
// end ; 3 :
18888: GO 19157
18890: LD_INT 3
18892: DOUBLE
18893: EQUAL
18894: IFTRUE 18898
18896: GO 18983
18898: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
18899: LD_EXP 40
18903: PPUSH
18904: LD_STRING D2Leg-JMM-1
18906: PPUSH
18907: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
18911: LD_EXP 59
18915: PPUSH
18916: LD_STRING D2Leg-Pow-1
18918: PPUSH
18919: CALL_OW 88
// if 2 in list_of_q then
18923: LD_INT 2
18925: PUSH
18926: LD_VAR 0 2
18930: IN
18931: IFFALSE 18957
// begin Say ( JMM , D2Leg-JMM-2 ) ;
18933: LD_EXP 40
18937: PPUSH
18938: LD_STRING D2Leg-JMM-2
18940: PPUSH
18941: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
18945: LD_EXP 59
18949: PPUSH
18950: LD_STRING D2Leg-Pow-2
18952: PPUSH
18953: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
18957: LD_EXP 40
18961: PPUSH
18962: LD_STRING D2Leg-JMM-3
18964: PPUSH
18965: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18969: LD_EXP 59
18973: PPUSH
18974: LD_STRING D2Leg-Pow-3
18976: PPUSH
18977: CALL_OW 88
// end ; 4 :
18981: GO 19157
18983: LD_INT 4
18985: DOUBLE
18986: EQUAL
18987: IFTRUE 18991
18989: GO 19066
18991: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18992: LD_EXP 40
18996: PPUSH
18997: LD_STRING D2Ar-JMM-1
18999: PPUSH
19000: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
19004: LD_EXP 59
19008: PPUSH
19009: LD_STRING D2Ar-Pow-1
19011: PPUSH
19012: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
19016: LD_EXP 40
19020: PPUSH
19021: LD_STRING D2Ar-JMM-2
19023: PPUSH
19024: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
19028: LD_EXP 59
19032: PPUSH
19033: LD_STRING D2Ar-Pow-2
19035: PPUSH
19036: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
19040: LD_EXP 40
19044: PPUSH
19045: LD_STRING D2Ar-JMM-3
19047: PPUSH
19048: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
19052: LD_EXP 59
19056: PPUSH
19057: LD_STRING D2Ar-Pow-3
19059: PPUSH
19060: CALL_OW 88
// end ; 5 :
19064: GO 19157
19066: LD_INT 5
19068: DOUBLE
19069: EQUAL
19070: IFTRUE 19074
19072: GO 19089
19074: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
19075: LD_EXP 40
19079: PPUSH
19080: LD_STRING D2Conf-JMM-1
19082: PPUSH
19083: CALL_OW 88
19087: GO 19157
19089: LD_INT 6
19091: DOUBLE
19092: EQUAL
19093: IFTRUE 19097
19095: GO 19156
19097: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
19098: LD_EXP 40
19102: PPUSH
19103: LD_STRING D2Com-JMM-1
19105: PPUSH
19106: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
19110: LD_EXP 59
19114: PPUSH
19115: LD_STRING D2Com-Pow-1
19117: PPUSH
19118: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
19122: LD_EXP 40
19126: PPUSH
19127: LD_STRING D2Com-JMM-2
19129: PPUSH
19130: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
19134: LD_EXP 59
19138: PPUSH
19139: LD_STRING D2Com-Pow-2
19141: PPUSH
19142: CALL_OW 88
// powellAngerQuery := true ;
19146: LD_ADDR_EXP 36
19150: PUSH
19151: LD_INT 1
19153: ST_TO_ADDR
// end ; end ;
19154: GO 19157
19156: POP
// end ;
19157: LD_VAR 0 3
19161: RET
// every 0 0$5 trigger missionStart do var tmp ;
19162: LD_EXP 13
19166: IFFALSE 19449
19168: GO 19170
19170: DISABLE
19171: LD_INT 0
19173: PPUSH
// begin repeat wait ( 0 0$1 ) ;
19174: LD_INT 35
19176: PPUSH
19177: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
19181: LD_INT 14
19183: PPUSH
19184: LD_INT 22
19186: PUSH
19187: LD_INT 1
19189: PUSH
19190: EMPTY
19191: LIST
19192: LIST
19193: PPUSH
19194: CALL_OW 70
19198: PUSH
19199: LD_EXP 15
19203: PUSH
19204: LD_INT 2
19206: PUSH
19207: LD_INT 3
19209: PUSH
19210: LD_INT 4
19212: PUSH
19213: LD_INT 5
19215: PUSH
19216: EMPTY
19217: LIST
19218: LIST
19219: LIST
19220: LIST
19221: IN
19222: AND
19223: IFFALSE 19439
// begin powellAnger := powellAnger + 1 ;
19225: LD_ADDR_EXP 17
19229: PUSH
19230: LD_EXP 17
19234: PUSH
19235: LD_INT 1
19237: PLUS
19238: ST_TO_ADDR
// Video ( true ) ;
19239: LD_INT 1
19241: PPUSH
19242: CALL 104756 0 1
// CenterNowOnUnits ( tmp ) ;
19246: LD_VAR 0 1
19250: PPUSH
19251: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
19255: LD_INT 14
19257: PPUSH
19258: LD_INT 22
19260: PUSH
19261: LD_INT 1
19263: PUSH
19264: EMPTY
19265: LIST
19266: LIST
19267: PPUSH
19268: CALL_OW 70
19272: PPUSH
19273: LD_INT 86
19275: PPUSH
19276: LD_INT 133
19278: PPUSH
19279: CALL_OW 111
// async ;
19283: ASYNC
// case powellAnger of 1 :
19284: LD_EXP 17
19288: PUSH
19289: LD_INT 1
19291: DOUBLE
19292: EQUAL
19293: IFTRUE 19297
19295: GO 19312
19297: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
19298: LD_EXP 59
19302: PPUSH
19303: LD_STRING DBack1-Pow-1
19305: PPUSH
19306: CALL_OW 88
19310: GO 19359
19312: LD_INT 2
19314: DOUBLE
19315: EQUAL
19316: IFTRUE 19320
19318: GO 19335
19320: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
19321: LD_EXP 59
19325: PPUSH
19326: LD_STRING DBack2-Pow-1
19328: PPUSH
19329: CALL_OW 88
19333: GO 19359
19335: LD_INT 3
19337: DOUBLE
19338: EQUAL
19339: IFTRUE 19343
19341: GO 19358
19343: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
19344: LD_EXP 59
19348: PPUSH
19349: LD_STRING DBack3-Pow-1
19351: PPUSH
19352: CALL_OW 88
19356: GO 19359
19358: POP
// sync ;
19359: SYNC
// repeat wait ( 0 0$1 ) ;
19360: LD_INT 35
19362: PPUSH
19363: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
19367: LD_INT 14
19369: PPUSH
19370: LD_INT 22
19372: PUSH
19373: LD_INT 1
19375: PUSH
19376: EMPTY
19377: LIST
19378: LIST
19379: PPUSH
19380: CALL_OW 70
19384: PPUSH
19385: LD_INT 86
19387: PPUSH
19388: LD_INT 133
19390: PPUSH
19391: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
19395: LD_INT 14
19397: PPUSH
19398: LD_INT 22
19400: PUSH
19401: LD_INT 1
19403: PUSH
19404: EMPTY
19405: LIST
19406: LIST
19407: PPUSH
19408: CALL_OW 70
19412: NOT
19413: IFFALSE 19360
// if powellAnger >= 3 then
19415: LD_EXP 17
19419: PUSH
19420: LD_INT 3
19422: GREATEREQUAL
19423: IFFALSE 19432
// YouLost ( Dismissed ) ;
19425: LD_STRING Dismissed
19427: PPUSH
19428: CALL_OW 104
// Video ( false ) ;
19432: LD_INT 0
19434: PPUSH
19435: CALL 104756 0 1
// end ; until missionStage > 5 ;
19439: LD_EXP 15
19443: PUSH
19444: LD_INT 5
19446: GREATER
19447: IFFALSE 19174
// end ;
19449: PPOPN 1
19451: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t ;
19452: LD_EXP 13
19456: PUSH
19457: LD_INT 22
19459: PUSH
19460: LD_INT 4
19462: PUSH
19463: EMPTY
19464: LIST
19465: LIST
19466: PUSH
19467: LD_INT 21
19469: PUSH
19470: LD_INT 2
19472: PUSH
19473: EMPTY
19474: LIST
19475: LIST
19476: PUSH
19477: EMPTY
19478: LIST
19479: LIST
19480: PPUSH
19481: CALL_OW 69
19485: PUSH
19486: LD_INT 4
19488: GREATEREQUAL
19489: AND
19490: PUSH
19491: LD_EXP 15
19495: PUSH
19496: LD_INT 2
19498: EQUAL
19499: AND
19500: IFFALSE 21690
19502: GO 19504
19504: DISABLE
19505: LD_INT 0
19507: PPUSH
19508: PPUSH
19509: PPUSH
19510: PPUSH
19511: PPUSH
19512: PPUSH
19513: PPUSH
19514: PPUSH
19515: PPUSH
19516: PPUSH
// begin missionStage := 3 ;
19517: LD_ADDR_EXP 15
19521: PUSH
19522: LD_INT 3
19524: ST_TO_ADDR
// retreat := false ;
19525: LD_ADDR_VAR 0 4
19529: PUSH
19530: LD_INT 0
19532: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
19533: LD_ADDR_VAR 0 5
19537: PUSH
19538: LD_INT 22
19540: PUSH
19541: LD_INT 4
19543: PUSH
19544: EMPTY
19545: LIST
19546: LIST
19547: PUSH
19548: LD_INT 30
19550: PUSH
19551: LD_INT 4
19553: PUSH
19554: EMPTY
19555: LIST
19556: LIST
19557: PUSH
19558: EMPTY
19559: LIST
19560: LIST
19561: PPUSH
19562: CALL_OW 69
19566: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
19567: LD_ADDR_VAR 0 6
19571: PUSH
19572: LD_INT 22
19574: PUSH
19575: LD_INT 4
19577: PUSH
19578: EMPTY
19579: LIST
19580: LIST
19581: PUSH
19582: LD_INT 30
19584: PUSH
19585: LD_INT 5
19587: PUSH
19588: EMPTY
19589: LIST
19590: LIST
19591: PUSH
19592: EMPTY
19593: LIST
19594: LIST
19595: PPUSH
19596: CALL_OW 69
19600: ST_TO_ADDR
// if not bar then
19601: LD_VAR 0 6
19605: NOT
19606: IFFALSE 19659
// begin repeat wait ( 0 0$1 ) ;
19608: LD_INT 35
19610: PPUSH
19611: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
19615: LD_INT 22
19617: PUSH
19618: LD_INT 4
19620: PUSH
19621: EMPTY
19622: LIST
19623: LIST
19624: PUSH
19625: LD_INT 3
19627: PUSH
19628: LD_INT 57
19630: PUSH
19631: EMPTY
19632: LIST
19633: PUSH
19634: EMPTY
19635: LIST
19636: LIST
19637: PUSH
19638: LD_INT 30
19640: PUSH
19641: LD_INT 5
19643: PUSH
19644: EMPTY
19645: LIST
19646: LIST
19647: PUSH
19648: EMPTY
19649: LIST
19650: LIST
19651: LIST
19652: PPUSH
19653: CALL_OW 69
19657: IFFALSE 19608
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
19659: LD_ADDR_VAR 0 6
19663: PUSH
19664: LD_INT 22
19666: PUSH
19667: LD_INT 4
19669: PUSH
19670: EMPTY
19671: LIST
19672: LIST
19673: PUSH
19674: LD_INT 30
19676: PUSH
19677: LD_INT 5
19679: PUSH
19680: EMPTY
19681: LIST
19682: LIST
19683: PUSH
19684: EMPTY
19685: LIST
19686: LIST
19687: PPUSH
19688: CALL_OW 69
19692: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19693: LD_INT 35
19695: PPUSH
19696: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
19700: LD_EXP 118
19704: PUSH
19705: LD_INT 4
19707: ARRAY
19708: PUSH
19709: LD_INT 4
19711: GREATEREQUAL
19712: IFFALSE 19693
// tmp := [ ] ;
19714: LD_ADDR_VAR 0 2
19718: PUSH
19719: EMPTY
19720: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) do
19721: LD_ADDR_VAR 0 1
19725: PUSH
19726: LD_INT 22
19728: PUSH
19729: LD_INT 4
19731: PUSH
19732: EMPTY
19733: LIST
19734: LIST
19735: PUSH
19736: LD_INT 2
19738: PUSH
19739: LD_INT 25
19741: PUSH
19742: LD_INT 1
19744: PUSH
19745: EMPTY
19746: LIST
19747: LIST
19748: PUSH
19749: LD_INT 25
19751: PUSH
19752: LD_INT 2
19754: PUSH
19755: EMPTY
19756: LIST
19757: LIST
19758: PUSH
19759: LD_INT 25
19761: PUSH
19762: LD_INT 3
19764: PUSH
19765: EMPTY
19766: LIST
19767: LIST
19768: PUSH
19769: LD_INT 25
19771: PUSH
19772: LD_INT 4
19774: PUSH
19775: EMPTY
19776: LIST
19777: LIST
19778: PUSH
19779: LD_INT 25
19781: PUSH
19782: LD_INT 5
19784: PUSH
19785: EMPTY
19786: LIST
19787: LIST
19788: PUSH
19789: EMPTY
19790: LIST
19791: LIST
19792: LIST
19793: LIST
19794: LIST
19795: LIST
19796: PUSH
19797: EMPTY
19798: LIST
19799: LIST
19800: PPUSH
19801: CALL_OW 69
19805: PUSH
19806: LD_EXP 59
19810: PUSH
19811: LD_EXP 60
19815: ADD
19816: DIFF
19817: PUSH
19818: FOR_IN
19819: IFFALSE 19883
// if GetTag ( i ) = 1 then
19821: LD_VAR 0 1
19825: PPUSH
19826: CALL_OW 110
19830: PUSH
19831: LD_INT 1
19833: EQUAL
19834: IFFALSE 19858
// tmp := Join ( tmp , i ) else
19836: LD_ADDR_VAR 0 2
19840: PUSH
19841: LD_VAR 0 2
19845: PPUSH
19846: LD_VAR 0 1
19850: PPUSH
19851: CALL 104784 0 2
19855: ST_TO_ADDR
19856: GO 19881
// tmp := Insert ( tmp , 1 , i ) ;
19858: LD_ADDR_VAR 0 2
19862: PUSH
19863: LD_VAR 0 2
19867: PPUSH
19868: LD_INT 1
19870: PPUSH
19871: LD_VAR 0 1
19875: PPUSH
19876: CALL_OW 2
19880: ST_TO_ADDR
19881: GO 19818
19883: POP
19884: POP
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
19885: LD_ADDR_VAR 0 3
19889: PUSH
19890: LD_VAR 0 2
19894: PPUSH
19895: LD_INT 26
19897: PUSH
19898: LD_INT 1
19900: PUSH
19901: EMPTY
19902: LIST
19903: LIST
19904: PPUSH
19905: CALL_OW 72
19909: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
19910: LD_ADDR_VAR 0 2
19914: PUSH
19915: LD_VAR 0 2
19919: PUSH
19920: LD_VAR 0 3
19924: DIFF
19925: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
19926: LD_ADDR_VAR 0 2
19930: PUSH
19931: LD_VAR 0 2
19935: PPUSH
19936: LD_INT 3
19938: PPUSH
19939: CALL 103293 0 2
19943: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
19944: LD_ADDR_VAR 0 3
19948: PUSH
19949: LD_VAR 0 3
19953: PPUSH
19954: LD_INT 3
19956: PPUSH
19957: CALL 103293 0 2
19961: ST_TO_ADDR
// for i := 1 to 4 do
19962: LD_ADDR_VAR 0 1
19966: PUSH
19967: DOUBLE
19968: LD_INT 1
19970: DEC
19971: ST_TO_ADDR
19972: LD_INT 4
19974: PUSH
19975: FOR_TO
19976: IFFALSE 20129
// begin if tmp2 then
19978: LD_VAR 0 3
19982: IFFALSE 20050
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
19984: LD_ADDR_EXP 18
19988: PUSH
19989: LD_EXP 18
19993: PPUSH
19994: LD_INT 1
19996: PPUSH
19997: LD_EXP 18
20001: PUSH
20002: LD_INT 1
20004: ARRAY
20005: PUSH
20006: LD_VAR 0 3
20010: PUSH
20011: LD_VAR 0 3
20015: ARRAY
20016: ADD
20017: PPUSH
20018: CALL_OW 1
20022: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
20023: LD_VAR 0 3
20027: PUSH
20028: LD_VAR 0 3
20032: ARRAY
20033: PPUSH
20034: LD_INT 1
20036: PPUSH
20037: CALL_OW 109
// tmp2 := [ ] ;
20041: LD_ADDR_VAR 0 3
20045: PUSH
20046: EMPTY
20047: ST_TO_ADDR
// end else
20048: GO 20127
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
20050: LD_ADDR_EXP 18
20054: PUSH
20055: LD_EXP 18
20059: PPUSH
20060: LD_INT 1
20062: PPUSH
20063: LD_EXP 18
20067: PUSH
20068: LD_INT 1
20070: ARRAY
20071: PUSH
20072: LD_VAR 0 2
20076: PUSH
20077: LD_VAR 0 2
20081: ARRAY
20082: ADD
20083: PPUSH
20084: CALL_OW 1
20088: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
20089: LD_VAR 0 2
20093: PUSH
20094: LD_VAR 0 2
20098: ARRAY
20099: PPUSH
20100: LD_INT 1
20102: PPUSH
20103: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
20107: LD_ADDR_VAR 0 2
20111: PUSH
20112: LD_VAR 0 2
20116: PPUSH
20117: LD_VAR 0 2
20121: PPUSH
20122: CALL_OW 3
20126: ST_TO_ADDR
// end ; end ;
20127: GO 19975
20129: POP
20130: POP
// if tmp2 then
20131: LD_VAR 0 3
20135: IFFALSE 20153
// tmp := tmp union tmp2 ;
20137: LD_ADDR_VAR 0 2
20141: PUSH
20142: LD_VAR 0 2
20146: PUSH
20147: LD_VAR 0 3
20151: UNION
20152: ST_TO_ADDR
// for i := 1 to 4 do
20153: LD_ADDR_VAR 0 1
20157: PUSH
20158: DOUBLE
20159: LD_INT 1
20161: DEC
20162: ST_TO_ADDR
20163: LD_INT 4
20165: PUSH
20166: FOR_TO
20167: IFFALSE 20216
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
20169: LD_ADDR_EXP 18
20173: PUSH
20174: LD_EXP 18
20178: PPUSH
20179: LD_INT 2
20181: PPUSH
20182: LD_EXP 18
20186: PUSH
20187: LD_INT 2
20189: ARRAY
20190: PUSH
20191: LD_VAR 0 2
20195: PUSH
20196: LD_VAR 0 2
20200: PUSH
20201: LD_VAR 0 1
20205: MINUS
20206: ARRAY
20207: ADD
20208: PPUSH
20209: CALL_OW 1
20213: ST_TO_ADDR
20214: GO 20166
20216: POP
20217: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
20218: LD_ADDR_EXP 99
20222: PUSH
20223: LD_EXP 99
20227: PPUSH
20228: LD_INT 4
20230: PPUSH
20231: LD_EXP 99
20235: PUSH
20236: LD_INT 4
20238: ARRAY
20239: PUSH
20240: LD_EXP 18
20244: PUSH
20245: LD_INT 1
20247: ARRAY
20248: DIFF
20249: PPUSH
20250: CALL_OW 1
20254: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
20255: LD_VAR 0 5
20259: PUSH
20260: LD_INT 1
20262: ARRAY
20263: PPUSH
20264: CALL_OW 313
20268: IFFALSE 20323
// begin for i in UnitsInside ( arm [ 1 ] ) do
20270: LD_ADDR_VAR 0 1
20274: PUSH
20275: LD_VAR 0 5
20279: PUSH
20280: LD_INT 1
20282: ARRAY
20283: PPUSH
20284: CALL_OW 313
20288: PUSH
20289: FOR_IN
20290: IFFALSE 20321
// begin ComExitBuilding ( i ) ;
20292: LD_VAR 0 1
20296: PPUSH
20297: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
20301: LD_VAR 0 1
20305: PPUSH
20306: LD_VAR 0 6
20310: PUSH
20311: LD_INT 1
20313: ARRAY
20314: PPUSH
20315: CALL_OW 180
// end ;
20319: GO 20289
20321: POP
20322: POP
// end ; wait ( 0 0$3 ) ;
20323: LD_INT 105
20325: PPUSH
20326: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
20330: LD_ADDR_VAR 0 1
20334: PUSH
20335: LD_EXP 18
20339: PUSH
20340: LD_INT 1
20342: ARRAY
20343: PUSH
20344: FOR_IN
20345: IFFALSE 20452
// begin if IsInUnit ( i ) then
20347: LD_VAR 0 1
20351: PPUSH
20352: CALL_OW 310
20356: IFFALSE 20367
// ComExitBuilding ( i ) ;
20358: LD_VAR 0 1
20362: PPUSH
20363: CALL_OW 122
// if GetClass ( i ) <> 1 then
20367: LD_VAR 0 1
20371: PPUSH
20372: CALL_OW 257
20376: PUSH
20377: LD_INT 1
20379: NONEQUAL
20380: IFFALSE 20421
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
20382: LD_VAR 0 1
20386: PPUSH
20387: LD_VAR 0 5
20391: PUSH
20392: LD_INT 1
20394: ARRAY
20395: PPUSH
20396: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
20400: LD_VAR 0 1
20404: PPUSH
20405: LD_INT 1
20407: PPUSH
20408: CALL_OW 183
// AddComExitBuilding ( i ) ;
20412: LD_VAR 0 1
20416: PPUSH
20417: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
20421: LD_VAR 0 1
20425: PPUSH
20426: LD_INT 60
20428: PPUSH
20429: LD_INT 94
20431: PPUSH
20432: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
20436: LD_VAR 0 1
20440: PPUSH
20441: LD_EXP 59
20445: PPUSH
20446: CALL_OW 179
// end ;
20450: GO 20344
20452: POP
20453: POP
// wait ( 0 0$10 ) ;
20454: LD_INT 350
20456: PPUSH
20457: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
20461: LD_EXP 59
20465: PPUSH
20466: LD_STRING D4-Pow-1
20468: PPUSH
20469: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
20473: LD_ADDR_VAR 0 2
20477: PUSH
20478: LD_EXP 18
20482: PUSH
20483: LD_INT 1
20485: ARRAY
20486: PPUSH
20487: LD_INT 26
20489: PUSH
20490: LD_INT 1
20492: PUSH
20493: EMPTY
20494: LIST
20495: LIST
20496: PPUSH
20497: CALL_OW 72
20501: ST_TO_ADDR
// if tmp then
20502: LD_VAR 0 2
20506: IFFALSE 20524
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
20508: LD_VAR 0 2
20512: PUSH
20513: LD_INT 1
20515: ARRAY
20516: PPUSH
20517: LD_STRING D4-Sol1-1
20519: PPUSH
20520: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
20524: LD_EXP 59
20528: PPUSH
20529: LD_STRING D4-Pow-2
20531: PPUSH
20532: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
20536: LD_ADDR_VAR 0 1
20540: PUSH
20541: DOUBLE
20542: LD_INT 1
20544: DEC
20545: ST_TO_ADDR
20546: LD_EXP 18
20550: PUSH
20551: LD_INT 1
20553: ARRAY
20554: PUSH
20555: FOR_TO
20556: IFFALSE 20649
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
20558: LD_EXP 18
20562: PUSH
20563: LD_INT 1
20565: ARRAY
20566: PUSH
20567: LD_VAR 0 1
20571: ARRAY
20572: PPUSH
20573: LD_EXP 118
20577: PUSH
20578: LD_INT 4
20580: ARRAY
20581: PUSH
20582: LD_INT 1
20584: ARRAY
20585: PPUSH
20586: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
20590: LD_ADDR_EXP 118
20594: PUSH
20595: LD_EXP 118
20599: PPUSH
20600: LD_INT 4
20602: PPUSH
20603: LD_EXP 118
20607: PUSH
20608: LD_INT 4
20610: ARRAY
20611: PPUSH
20612: LD_INT 1
20614: PPUSH
20615: CALL_OW 3
20619: PPUSH
20620: CALL_OW 1
20624: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
20625: LD_INT 8
20627: PPUSH
20628: LD_EXP 18
20632: PUSH
20633: LD_INT 1
20635: ARRAY
20636: PUSH
20637: LD_VAR 0 1
20641: ARRAY
20642: PPUSH
20643: CALL_OW 471
// end ;
20647: GO 20555
20649: POP
20650: POP
// repeat wait ( 0 0$1 ) ;
20651: LD_INT 35
20653: PPUSH
20654: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
20658: LD_EXP 18
20662: PUSH
20663: LD_INT 1
20665: ARRAY
20666: PPUSH
20667: LD_INT 55
20669: PUSH
20670: EMPTY
20671: LIST
20672: PPUSH
20673: CALL_OW 72
20677: PUSH
20678: LD_INT 4
20680: GREATEREQUAL
20681: IFFALSE 20651
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
20683: LD_EXP 18
20687: PUSH
20688: LD_INT 1
20690: ARRAY
20691: PPUSH
20692: LD_INT 69
20694: PPUSH
20695: LD_INT 94
20697: PPUSH
20698: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
20702: LD_EXP 18
20706: PUSH
20707: LD_INT 1
20709: ARRAY
20710: PPUSH
20711: LD_INT 82
20713: PPUSH
20714: LD_INT 83
20716: PPUSH
20717: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
20721: LD_EXP 18
20725: PUSH
20726: LD_INT 1
20728: ARRAY
20729: PPUSH
20730: LD_INT 77
20732: PPUSH
20733: LD_INT 69
20735: PPUSH
20736: CALL_OW 174
// repeat wait ( 3 ) ;
20740: LD_INT 3
20742: PPUSH
20743: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
20747: LD_ADDR_VAR 0 1
20751: PUSH
20752: LD_EXP 18
20756: PUSH
20757: LD_INT 1
20759: ARRAY
20760: PUSH
20761: FOR_IN
20762: IFFALSE 20898
// begin if GetLives ( i ) < 990 then
20764: LD_VAR 0 1
20768: PPUSH
20769: CALL_OW 256
20773: PUSH
20774: LD_INT 990
20776: LESS
20777: IFFALSE 20791
// SetLives ( i , 1000 ) ;
20779: LD_VAR 0 1
20783: PPUSH
20784: LD_INT 1000
20786: PPUSH
20787: CALL_OW 234
// if not IsInUnit ( i ) then
20791: LD_VAR 0 1
20795: PPUSH
20796: CALL_OW 310
20800: NOT
20801: IFFALSE 20896
// begin if not HasTask ( i ) then
20803: LD_VAR 0 1
20807: PPUSH
20808: CALL_OW 314
20812: NOT
20813: IFFALSE 20830
// ComMoveXY ( i , 64 , 93 ) ;
20815: LD_VAR 0 1
20819: PPUSH
20820: LD_INT 64
20822: PPUSH
20823: LD_INT 93
20825: PPUSH
20826: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
20830: LD_VAR 0 4
20834: NOT
20835: PUSH
20836: LD_VAR 0 1
20840: PPUSH
20841: CALL_OW 258
20845: PUSH
20846: LD_INT 1
20848: EQUAL
20849: AND
20850: IFFALSE 20896
// begin retreat := true ;
20852: LD_ADDR_VAR 0 4
20856: PUSH
20857: LD_INT 1
20859: ST_TO_ADDR
// SetTag ( i , 2 ) ;
20860: LD_VAR 0 1
20864: PPUSH
20865: LD_INT 2
20867: PPUSH
20868: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
20872: LD_VAR 0 1
20876: PPUSH
20877: LD_STRING D4a-Sol1-1
20879: PPUSH
20880: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
20884: LD_EXP 59
20888: PPUSH
20889: LD_STRING D4a-Pow-1
20891: PPUSH
20892: CALL_OW 88
// end ; end ; end ;
20896: GO 20761
20898: POP
20899: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
20900: LD_EXP 18
20904: PUSH
20905: LD_INT 1
20907: ARRAY
20908: PPUSH
20909: LD_INT 95
20911: PUSH
20912: LD_INT 9
20914: PUSH
20915: EMPTY
20916: LIST
20917: LIST
20918: PUSH
20919: LD_INT 3
20921: PUSH
20922: LD_INT 55
20924: PUSH
20925: EMPTY
20926: LIST
20927: PUSH
20928: EMPTY
20929: LIST
20930: LIST
20931: PUSH
20932: EMPTY
20933: LIST
20934: LIST
20935: PPUSH
20936: CALL_OW 72
20940: PUSH
20941: LD_INT 4
20943: GREATEREQUAL
20944: IFFALSE 20740
// for i in powellSquadAttack [ 1 ] do
20946: LD_ADDR_VAR 0 1
20950: PUSH
20951: LD_EXP 18
20955: PUSH
20956: LD_INT 1
20958: ARRAY
20959: PUSH
20960: FOR_IN
20961: IFFALSE 21097
// begin if GetTag ( i ) = 2 then
20963: LD_VAR 0 1
20967: PPUSH
20968: CALL_OW 110
20972: PUSH
20973: LD_INT 2
20975: EQUAL
20976: IFFALSE 21038
// begin ComMoveXY ( i , 60 , 94 ) ;
20978: LD_VAR 0 1
20982: PPUSH
20983: LD_INT 60
20985: PPUSH
20986: LD_INT 94
20988: PPUSH
20989: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
20993: LD_VAR 0 1
20997: PPUSH
20998: LD_EXP 59
21002: PPUSH
21003: CALL_OW 179
// wait ( 0 0$3 ) ;
21007: LD_INT 105
21009: PPUSH
21010: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
21014: LD_VAR 0 1
21018: PPUSH
21019: LD_STRING D4a-Sol1-2
21021: PPUSH
21022: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
21026: LD_EXP 59
21030: PPUSH
21031: LD_STRING D4a-Pow-2
21033: PPUSH
21034: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
21038: LD_VAR 0 1
21042: PPUSH
21043: LD_INT 0
21045: PPUSH
21046: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
21050: LD_ADDR_EXP 99
21054: PUSH
21055: LD_EXP 99
21059: PPUSH
21060: LD_INT 4
21062: PPUSH
21063: LD_EXP 99
21067: PUSH
21068: LD_INT 4
21070: ARRAY
21071: PUSH
21072: LD_VAR 0 1
21076: UNION
21077: PPUSH
21078: CALL_OW 1
21082: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
21083: LD_INT 8
21085: PPUSH
21086: LD_VAR 0 1
21090: PPUSH
21091: CALL_OW 472
// end ;
21095: GO 20960
21097: POP
21098: POP
// wait ( 2 2$00 ) ;
21099: LD_INT 4200
21101: PPUSH
21102: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21106: LD_ADDR_VAR 0 9
21110: PUSH
21111: LD_INT 22
21113: PUSH
21114: LD_INT 4
21116: PUSH
21117: EMPTY
21118: LIST
21119: LIST
21120: PUSH
21121: LD_INT 30
21123: PUSH
21124: LD_INT 32
21126: PUSH
21127: EMPTY
21128: LIST
21129: LIST
21130: PUSH
21131: LD_INT 58
21133: PUSH
21134: EMPTY
21135: LIST
21136: PUSH
21137: EMPTY
21138: LIST
21139: LIST
21140: LIST
21141: PPUSH
21142: CALL_OW 69
21146: ST_TO_ADDR
// if tmp then
21147: LD_VAR 0 2
21151: IFFALSE 21391
// begin for i := 1 to tmp do
21153: LD_ADDR_VAR 0 1
21157: PUSH
21158: DOUBLE
21159: LD_INT 1
21161: DEC
21162: ST_TO_ADDR
21163: LD_VAR 0 2
21167: PUSH
21168: FOR_TO
21169: IFFALSE 21382
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
21171: LD_ADDR_EXP 99
21175: PUSH
21176: LD_EXP 99
21180: PPUSH
21181: LD_INT 4
21183: PPUSH
21184: LD_EXP 99
21188: PUSH
21189: LD_INT 4
21191: ARRAY
21192: PUSH
21193: LD_VAR 0 2
21197: PUSH
21198: LD_VAR 0 1
21202: ARRAY
21203: DIFF
21204: PPUSH
21205: CALL_OW 1
21209: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
21210: LD_ADDR_VAR 0 10
21214: PUSH
21215: LD_VAR 0 2
21219: PUSH
21220: LD_VAR 0 1
21224: ARRAY
21225: PPUSH
21226: CALL_OW 310
21230: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
21231: LD_VAR 0 10
21235: PUSH
21236: LD_VAR 0 10
21240: PPUSH
21241: CALL_OW 266
21245: PUSH
21246: LD_INT 32
21248: EQUAL
21249: AND
21250: IFFALSE 21254
// continue ;
21252: GO 21168
// if t then
21254: LD_VAR 0 10
21258: IFFALSE 21275
// ComExitBuilding ( tmp [ i ] ) ;
21260: LD_VAR 0 2
21264: PUSH
21265: LD_VAR 0 1
21269: ARRAY
21270: PPUSH
21271: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21275: LD_VAR 0 2
21279: PUSH
21280: LD_VAR 0 1
21284: ARRAY
21285: PPUSH
21286: LD_VAR 0 5
21290: PUSH
21291: LD_INT 1
21293: ARRAY
21294: PPUSH
21295: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21299: LD_VAR 0 2
21303: PUSH
21304: LD_VAR 0 1
21308: ARRAY
21309: PPUSH
21310: LD_INT 1
21312: PPUSH
21313: CALL_OW 183
// if emptyTowers then
21317: LD_VAR 0 9
21321: IFFALSE 21380
// begin AddComExitBuilding ( tmp [ i ] ) ;
21323: LD_VAR 0 2
21327: PUSH
21328: LD_VAR 0 1
21332: ARRAY
21333: PPUSH
21334: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
21338: LD_VAR 0 2
21342: PUSH
21343: LD_VAR 0 1
21347: ARRAY
21348: PPUSH
21349: LD_VAR 0 9
21353: PUSH
21354: LD_INT 1
21356: ARRAY
21357: PPUSH
21358: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
21362: LD_ADDR_VAR 0 9
21366: PUSH
21367: LD_VAR 0 9
21371: PPUSH
21372: LD_INT 1
21374: PPUSH
21375: CALL_OW 3
21379: ST_TO_ADDR
// end ; end ;
21380: GO 21168
21382: POP
21383: POP
// wait ( 0 0$30 ) ;
21384: LD_INT 1050
21386: PPUSH
21387: CALL_OW 67
// end ; uc_side := 6 ;
21391: LD_ADDR_OWVAR 20
21395: PUSH
21396: LD_INT 6
21398: ST_TO_ADDR
// uc_nation := 3 ;
21399: LD_ADDR_OWVAR 21
21403: PUSH
21404: LD_INT 3
21406: ST_TO_ADDR
// ru := [ ] ;
21407: LD_ADDR_VAR 0 7
21411: PUSH
21412: EMPTY
21413: ST_TO_ADDR
// for i = 1 to 5 do
21414: LD_ADDR_VAR 0 1
21418: PUSH
21419: DOUBLE
21420: LD_INT 1
21422: DEC
21423: ST_TO_ADDR
21424: LD_INT 5
21426: PUSH
21427: FOR_TO
21428: IFFALSE 21548
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
21430: LD_INT 22
21432: PUSH
21433: LD_INT 23
21435: PUSH
21436: EMPTY
21437: LIST
21438: LIST
21439: PUSH
21440: LD_INT 1
21442: PPUSH
21443: LD_INT 2
21445: PPUSH
21446: CALL_OW 12
21450: ARRAY
21451: PPUSH
21452: LD_INT 1
21454: PPUSH
21455: LD_INT 3
21457: PPUSH
21458: LD_INT 43
21460: PUSH
21461: LD_INT 44
21463: PUSH
21464: EMPTY
21465: LIST
21466: LIST
21467: PUSH
21468: LD_INT 1
21470: PPUSH
21471: LD_INT 2
21473: PPUSH
21474: CALL_OW 12
21478: ARRAY
21479: PPUSH
21480: LD_INT 89
21482: PPUSH
21483: CALL 72350 0 5
// un := CreateVehicle ;
21487: LD_ADDR_VAR 0 8
21491: PUSH
21492: CALL_OW 45
21496: ST_TO_ADDR
// SetDir ( un , 4 ) ;
21497: LD_VAR 0 8
21501: PPUSH
21502: LD_INT 4
21504: PPUSH
21505: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
21509: LD_VAR 0 8
21513: PPUSH
21514: LD_INT 136
21516: PPUSH
21517: LD_INT 90
21519: PPUSH
21520: LD_INT 8
21522: PPUSH
21523: LD_INT 0
21525: PPUSH
21526: CALL_OW 50
// ru := ru ^ un ;
21530: LD_ADDR_VAR 0 7
21534: PUSH
21535: LD_VAR 0 7
21539: PUSH
21540: LD_VAR 0 8
21544: ADD
21545: ST_TO_ADDR
// end ;
21546: GO 21427
21548: POP
21549: POP
// if ru then
21550: LD_VAR 0 7
21554: IFFALSE 21571
// ComAgressiveMove ( ru , 57 , 94 ) ;
21556: LD_VAR 0 7
21560: PPUSH
21561: LD_INT 57
21563: PPUSH
21564: LD_INT 94
21566: PPUSH
21567: CALL_OW 114
// wait ( 3 3$00 ) ;
21571: LD_INT 6300
21573: PPUSH
21574: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
21578: LD_INT 4
21580: PPUSH
21581: LD_INT 3
21583: PUSH
21584: LD_INT 1
21586: PUSH
21587: LD_INT 1
21589: PUSH
21590: LD_INT 5
21592: PUSH
21593: EMPTY
21594: LIST
21595: LIST
21596: LIST
21597: LIST
21598: PUSH
21599: LD_INT 4
21601: PUSH
21602: LD_INT 1
21604: PUSH
21605: LD_INT 1
21607: PUSH
21608: LD_INT 6
21610: PUSH
21611: EMPTY
21612: LIST
21613: LIST
21614: LIST
21615: LIST
21616: PUSH
21617: LD_INT 4
21619: PUSH
21620: LD_INT 1
21622: PUSH
21623: LD_INT 1
21625: PUSH
21626: LD_INT 7
21628: PUSH
21629: EMPTY
21630: LIST
21631: LIST
21632: LIST
21633: LIST
21634: PUSH
21635: LD_INT 3
21637: PUSH
21638: LD_INT 1
21640: PUSH
21641: LD_INT 1
21643: PUSH
21644: LD_INT 7
21646: PUSH
21647: EMPTY
21648: LIST
21649: LIST
21650: LIST
21651: LIST
21652: PUSH
21653: LD_INT 3
21655: PUSH
21656: LD_INT 1
21658: PUSH
21659: LD_INT 1
21661: PUSH
21662: LD_INT 5
21664: PUSH
21665: EMPTY
21666: LIST
21667: LIST
21668: LIST
21669: LIST
21670: PUSH
21671: EMPTY
21672: LIST
21673: LIST
21674: LIST
21675: LIST
21676: LIST
21677: PPUSH
21678: CALL 60899 0 2
// missionStage := 4 ;
21682: LD_ADDR_EXP 15
21686: PUSH
21687: LD_INT 4
21689: ST_TO_ADDR
// end ;
21690: PPOPN 10
21692: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
21693: LD_EXP 15
21697: PUSH
21698: LD_INT 4
21700: EQUAL
21701: PUSH
21702: LD_INT 22
21704: PUSH
21705: LD_INT 4
21707: PUSH
21708: EMPTY
21709: LIST
21710: LIST
21711: PUSH
21712: LD_INT 21
21714: PUSH
21715: LD_INT 2
21717: PUSH
21718: EMPTY
21719: LIST
21720: LIST
21721: PUSH
21722: EMPTY
21723: LIST
21724: LIST
21725: PPUSH
21726: CALL_OW 69
21730: PUSH
21731: LD_INT 5
21733: GREATEREQUAL
21734: AND
21735: IFFALSE 25948
21737: GO 21739
21739: DISABLE
21740: LD_INT 0
21742: PPUSH
21743: PPUSH
21744: PPUSH
21745: PPUSH
21746: PPUSH
21747: PPUSH
21748: PPUSH
21749: PPUSH
21750: PPUSH
21751: PPUSH
21752: PPUSH
21753: PPUSH
21754: PPUSH
// begin wait ( 0 0$10 ) ;
21755: LD_INT 350
21757: PPUSH
21758: CALL_OW 67
// missionStage := 5 ;
21762: LD_ADDR_EXP 15
21766: PUSH
21767: LD_INT 5
21769: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
21770: LD_ADDR_VAR 0 10
21774: PUSH
21775: LD_INT 22
21777: PUSH
21778: LD_INT 4
21780: PUSH
21781: EMPTY
21782: LIST
21783: LIST
21784: PUSH
21785: LD_INT 2
21787: PUSH
21788: LD_INT 30
21790: PUSH
21791: LD_INT 4
21793: PUSH
21794: EMPTY
21795: LIST
21796: LIST
21797: PUSH
21798: LD_INT 30
21800: PUSH
21801: LD_INT 5
21803: PUSH
21804: EMPTY
21805: LIST
21806: LIST
21807: PUSH
21808: EMPTY
21809: LIST
21810: LIST
21811: LIST
21812: PUSH
21813: EMPTY
21814: LIST
21815: LIST
21816: PPUSH
21817: CALL_OW 69
21821: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
21822: LD_ADDR_VAR 0 6
21826: PUSH
21827: LD_INT 22
21829: PUSH
21830: LD_INT 4
21832: PUSH
21833: EMPTY
21834: LIST
21835: LIST
21836: PUSH
21837: LD_INT 21
21839: PUSH
21840: LD_INT 1
21842: PUSH
21843: EMPTY
21844: LIST
21845: LIST
21846: PUSH
21847: LD_INT 3
21849: PUSH
21850: LD_INT 25
21852: PUSH
21853: LD_INT 16
21855: PUSH
21856: EMPTY
21857: LIST
21858: LIST
21859: PUSH
21860: EMPTY
21861: LIST
21862: LIST
21863: PUSH
21864: LD_INT 3
21866: PUSH
21867: LD_INT 25
21869: PUSH
21870: LD_INT 12
21872: PUSH
21873: EMPTY
21874: LIST
21875: LIST
21876: PUSH
21877: EMPTY
21878: LIST
21879: LIST
21880: PUSH
21881: EMPTY
21882: LIST
21883: LIST
21884: LIST
21885: LIST
21886: PPUSH
21887: CALL_OW 69
21891: PUSH
21892: LD_EXP 59
21896: DIFF
21897: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
21898: LD_ADDR_VAR 0 9
21902: PUSH
21903: LD_INT 22
21905: PUSH
21906: LD_INT 4
21908: PUSH
21909: EMPTY
21910: LIST
21911: LIST
21912: PUSH
21913: LD_INT 30
21915: PUSH
21916: LD_INT 3
21918: PUSH
21919: EMPTY
21920: LIST
21921: LIST
21922: PUSH
21923: EMPTY
21924: LIST
21925: LIST
21926: PPUSH
21927: CALL_OW 69
21931: PUSH
21932: LD_INT 1
21934: ARRAY
21935: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
21936: LD_INT 350
21938: PPUSH
21939: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
21943: LD_EXP 118
21947: PUSH
21948: LD_INT 4
21950: ARRAY
21951: PUSH
21952: LD_INT 5
21954: LESS
21955: PUSH
21956: LD_VAR 0 9
21960: PPUSH
21961: CALL_OW 461
21965: PUSH
21966: LD_INT 2
21968: EQUAL
21969: AND
21970: IFFALSE 22000
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
21972: LD_INT 4
21974: PPUSH
21975: LD_INT 3
21977: PUSH
21978: LD_INT 1
21980: PUSH
21981: LD_INT 1
21983: PUSH
21984: LD_INT 5
21986: PUSH
21987: EMPTY
21988: LIST
21989: LIST
21990: LIST
21991: LIST
21992: PUSH
21993: EMPTY
21994: LIST
21995: PPUSH
21996: CALL 60947 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
22000: LD_EXP 118
22004: PUSH
22005: LD_INT 4
22007: ARRAY
22008: PUSH
22009: LD_INT 5
22011: GREATEREQUAL
22012: PUSH
22013: LD_EXP 118
22017: PUSH
22018: LD_INT 4
22020: ARRAY
22021: PPUSH
22022: LD_INT 58
22024: PUSH
22025: EMPTY
22026: LIST
22027: PPUSH
22028: CALL_OW 72
22032: PUSH
22033: LD_INT 5
22035: GREATEREQUAL
22036: AND
22037: IFFALSE 21936
// powellAllowRetreat := false ;
22039: LD_ADDR_EXP 19
22043: PUSH
22044: LD_INT 0
22046: ST_TO_ADDR
// activeAttacks := false ;
22047: LD_ADDR_EXP 16
22051: PUSH
22052: LD_INT 0
22054: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22055: LD_INT 35
22057: PPUSH
22058: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
22062: LD_INT 22
22064: PUSH
22065: LD_INT 6
22067: PUSH
22068: EMPTY
22069: LIST
22070: LIST
22071: PPUSH
22072: CALL_OW 69
22076: PUSH
22077: LD_INT 0
22079: EQUAL
22080: IFFALSE 22055
// tmp := mc_vehicles [ 4 ] ;
22082: LD_ADDR_VAR 0 3
22086: PUSH
22087: LD_EXP 118
22091: PUSH
22092: LD_INT 4
22094: ARRAY
22095: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
22096: LD_ADDR_VAR 0 1
22100: PUSH
22101: DOUBLE
22102: LD_INT 1
22104: DEC
22105: ST_TO_ADDR
22106: LD_EXP 18
22110: PUSH
22111: FOR_TO
22112: IFFALSE 22373
// begin for j in powellSquadAttack [ i ] do
22114: LD_ADDR_VAR 0 2
22118: PUSH
22119: LD_EXP 18
22123: PUSH
22124: LD_VAR 0 1
22128: ARRAY
22129: PUSH
22130: FOR_IN
22131: IFFALSE 22369
// begin forces := forces diff j ;
22133: LD_ADDR_VAR 0 6
22137: PUSH
22138: LD_VAR 0 6
22142: PUSH
22143: LD_VAR 0 2
22147: DIFF
22148: ST_TO_ADDR
// SetTag ( j , 1 ) ;
22149: LD_VAR 0 2
22153: PPUSH
22154: LD_INT 1
22156: PPUSH
22157: CALL_OW 109
// wait ( 0 0$2 ) ;
22161: LD_INT 70
22163: PPUSH
22164: CALL_OW 67
// if IsInUnit ( j ) then
22168: LD_VAR 0 2
22172: PPUSH
22173: CALL_OW 310
22177: IFFALSE 22188
// ComExitBuilding ( j ) ;
22179: LD_VAR 0 2
22183: PPUSH
22184: CALL_OW 122
// if GetClass ( j ) <> 1 then
22188: LD_VAR 0 2
22192: PPUSH
22193: CALL_OW 257
22197: PUSH
22198: LD_INT 1
22200: NONEQUAL
22201: IFFALSE 22281
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
22203: LD_VAR 0 10
22207: PUSH
22208: LD_INT 1
22210: ARRAY
22211: PPUSH
22212: CALL_OW 313
22216: PUSH
22217: LD_INT 5
22219: GREATEREQUAL
22220: IFFALSE 22242
// AddComEnterUnit ( j , arm [ 2 ] ) else
22222: LD_VAR 0 2
22226: PPUSH
22227: LD_VAR 0 10
22231: PUSH
22232: LD_INT 2
22234: ARRAY
22235: PPUSH
22236: CALL_OW 180
22240: GO 22260
// AddComEnterUnit ( j , arm [ 1 ] ) ;
22242: LD_VAR 0 2
22246: PPUSH
22247: LD_VAR 0 10
22251: PUSH
22252: LD_INT 1
22254: ARRAY
22255: PPUSH
22256: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
22260: LD_VAR 0 2
22264: PPUSH
22265: LD_INT 1
22267: PPUSH
22268: CALL_OW 183
// AddComExitBuilding ( j ) ;
22272: LD_VAR 0 2
22276: PPUSH
22277: CALL_OW 182
// end ; if i = 2 then
22281: LD_VAR 0 1
22285: PUSH
22286: LD_INT 2
22288: EQUAL
22289: IFFALSE 22306
// AddComMoveXY ( j , 61 , 93 ) ;
22291: LD_VAR 0 2
22295: PPUSH
22296: LD_INT 61
22298: PPUSH
22299: LD_INT 93
22301: PPUSH
22302: CALL_OW 171
// if i = 1 then
22306: LD_VAR 0 1
22310: PUSH
22311: LD_INT 1
22313: EQUAL
22314: IFFALSE 22367
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
22316: LD_VAR 0 2
22320: PPUSH
22321: LD_VAR 0 3
22325: PUSH
22326: LD_INT 1
22328: ARRAY
22329: PPUSH
22330: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
22334: LD_ADDR_VAR 0 3
22338: PUSH
22339: LD_VAR 0 3
22343: PPUSH
22344: LD_INT 1
22346: PPUSH
22347: CALL_OW 3
22351: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
22352: LD_VAR 0 2
22356: PPUSH
22357: LD_INT 69
22359: PPUSH
22360: LD_INT 94
22362: PPUSH
22363: CALL_OW 171
// end ; end ;
22367: GO 22130
22369: POP
22370: POP
// end ;
22371: GO 22111
22373: POP
22374: POP
// wait ( 0 0$30 ) ;
22375: LD_INT 1050
22377: PPUSH
22378: CALL_OW 67
// MC_Kill ( 4 ) ;
22382: LD_INT 4
22384: PPUSH
22385: CALL 36920 0 1
// tmp := UnitsInside ( fac ) ;
22389: LD_ADDR_VAR 0 3
22393: PUSH
22394: LD_VAR 0 9
22398: PPUSH
22399: CALL_OW 313
22403: ST_TO_ADDR
// if tmp then
22404: LD_VAR 0 3
22408: IFFALSE 22529
// for i in tmp do
22410: LD_ADDR_VAR 0 1
22414: PUSH
22415: LD_VAR 0 3
22419: PUSH
22420: FOR_IN
22421: IFFALSE 22527
// begin ComExitBuilding ( i ) ;
22423: LD_VAR 0 1
22427: PPUSH
22428: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
22432: LD_VAR 0 10
22436: PUSH
22437: LD_INT 2
22439: ARRAY
22440: PPUSH
22441: CALL_OW 313
22445: PUSH
22446: LD_INT 6
22448: LESS
22449: IFFALSE 22471
// AddComEnterUnit ( i , arm [ 2 ] ) else
22451: LD_VAR 0 1
22455: PPUSH
22456: LD_VAR 0 10
22460: PUSH
22461: LD_INT 2
22463: ARRAY
22464: PPUSH
22465: CALL_OW 180
22469: GO 22525
// if UnitsInside ( arm [ 1 ] ) < 6 then
22471: LD_VAR 0 10
22475: PUSH
22476: LD_INT 1
22478: ARRAY
22479: PPUSH
22480: CALL_OW 313
22484: PUSH
22485: LD_INT 6
22487: LESS
22488: IFFALSE 22510
// AddComEnterUnit ( i , arm [ 1 ] ) else
22490: LD_VAR 0 1
22494: PPUSH
22495: LD_VAR 0 10
22499: PUSH
22500: LD_INT 1
22502: ARRAY
22503: PPUSH
22504: CALL_OW 180
22508: GO 22525
// AddComMoveXY ( i , 37 , 68 ) ;
22510: LD_VAR 0 1
22514: PPUSH
22515: LD_INT 37
22517: PPUSH
22518: LD_INT 68
22520: PPUSH
22521: CALL_OW 171
// end ;
22525: GO 22420
22527: POP
22528: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
22529: LD_ADDR_VAR 0 11
22533: PUSH
22534: LD_VAR 0 6
22538: PPUSH
22539: LD_INT 26
22541: PUSH
22542: LD_INT 1
22544: PUSH
22545: EMPTY
22546: LIST
22547: LIST
22548: PPUSH
22549: CALL_OW 72
22553: PUSH
22554: LD_EXP 60
22558: DIFF
22559: ST_TO_ADDR
// if not speaker then
22560: LD_VAR 0 11
22564: NOT
22565: IFFALSE 22592
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
22567: LD_ADDR_VAR 0 11
22571: PUSH
22572: LD_VAR 0 6
22576: PPUSH
22577: LD_INT 26
22579: PUSH
22580: LD_INT 1
22582: PUSH
22583: EMPTY
22584: LIST
22585: LIST
22586: PPUSH
22587: CALL_OW 72
22591: ST_TO_ADDR
// if speaker then
22592: LD_VAR 0 11
22596: IFFALSE 22612
// speaker := speaker [ 1 ] ;
22598: LD_ADDR_VAR 0 11
22602: PUSH
22603: LD_VAR 0 11
22607: PUSH
22608: LD_INT 1
22610: ARRAY
22611: ST_TO_ADDR
// Video ( true ) ;
22612: LD_INT 1
22614: PPUSH
22615: CALL 104756 0 1
// CenterNowOnUnits ( Powell ) ;
22619: LD_EXP 59
22623: PPUSH
22624: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
22628: LD_ADDR_VAR 0 3
22632: PUSH
22633: LD_VAR 0 6
22637: PPUSH
22638: LD_INT 3
22640: PUSH
22641: LD_INT 25
22643: PUSH
22644: LD_INT 1
22646: PUSH
22647: EMPTY
22648: LIST
22649: LIST
22650: PUSH
22651: EMPTY
22652: LIST
22653: LIST
22654: PPUSH
22655: CALL_OW 72
22659: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
22660: LD_ADDR_VAR 0 12
22664: PUSH
22665: LD_INT 22
22667: PUSH
22668: LD_INT 4
22670: PUSH
22671: EMPTY
22672: LIST
22673: LIST
22674: PUSH
22675: LD_INT 30
22677: PUSH
22678: LD_INT 32
22680: PUSH
22681: EMPTY
22682: LIST
22683: LIST
22684: PUSH
22685: LD_INT 58
22687: PUSH
22688: EMPTY
22689: LIST
22690: PUSH
22691: EMPTY
22692: LIST
22693: LIST
22694: LIST
22695: PPUSH
22696: CALL_OW 69
22700: ST_TO_ADDR
// for i := 1 to 4 do
22701: LD_ADDR_VAR 0 1
22705: PUSH
22706: DOUBLE
22707: LD_INT 1
22709: DEC
22710: ST_TO_ADDR
22711: LD_INT 4
22713: PUSH
22714: FOR_TO
22715: IFFALSE 22856
// begin if IsInUnit ( tmp [ i ] ) then
22717: LD_VAR 0 3
22721: PUSH
22722: LD_VAR 0 1
22726: ARRAY
22727: PPUSH
22728: CALL_OW 310
22732: IFFALSE 22749
// ComExitBuilding ( tmp [ i ] ) ;
22734: LD_VAR 0 3
22738: PUSH
22739: LD_VAR 0 1
22743: ARRAY
22744: PPUSH
22745: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
22749: LD_VAR 0 3
22753: PUSH
22754: LD_VAR 0 1
22758: ARRAY
22759: PPUSH
22760: LD_VAR 0 10
22764: PUSH
22765: LD_INT 1
22767: ARRAY
22768: PPUSH
22769: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
22773: LD_VAR 0 3
22777: PUSH
22778: LD_VAR 0 1
22782: ARRAY
22783: PPUSH
22784: LD_INT 1
22786: PPUSH
22787: CALL_OW 183
// if emp_towers then
22791: LD_VAR 0 12
22795: IFFALSE 22854
// begin AddComExitBuilding ( tmp [ i ] ) ;
22797: LD_VAR 0 3
22801: PUSH
22802: LD_VAR 0 1
22806: ARRAY
22807: PPUSH
22808: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
22812: LD_VAR 0 3
22816: PUSH
22817: LD_VAR 0 1
22821: ARRAY
22822: PPUSH
22823: LD_VAR 0 12
22827: PUSH
22828: LD_INT 1
22830: ARRAY
22831: PPUSH
22832: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
22836: LD_ADDR_VAR 0 12
22840: PUSH
22841: LD_VAR 0 12
22845: PPUSH
22846: LD_INT 1
22848: PPUSH
22849: CALL_OW 3
22853: ST_TO_ADDR
// end ; end ;
22854: GO 22714
22856: POP
22857: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
22858: LD_ADDR_VAR 0 3
22862: PUSH
22863: LD_EXP 18
22867: PUSH
22868: LD_INT 1
22870: ARRAY
22871: PUSH
22872: LD_EXP 18
22876: PUSH
22877: LD_INT 2
22879: ARRAY
22880: ADD
22881: PPUSH
22882: LD_INT 26
22884: PUSH
22885: LD_INT 1
22887: PUSH
22888: EMPTY
22889: LIST
22890: LIST
22891: PPUSH
22892: CALL_OW 72
22896: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
22897: LD_ADDR_VAR 0 1
22901: PUSH
22902: LD_EXP 18
22906: PUSH
22907: LD_INT 2
22909: ARRAY
22910: PUSH
22911: FOR_IN
22912: IFFALSE 22930
// ComTurnUnit ( i , Powell ) ;
22914: LD_VAR 0 1
22918: PPUSH
22919: LD_EXP 59
22923: PPUSH
22924: CALL_OW 119
22928: GO 22911
22930: POP
22931: POP
// Say ( Powell , D5-Pow-1 ) ;
22932: LD_EXP 59
22936: PPUSH
22937: LD_STRING D5-Pow-1
22939: PPUSH
22940: CALL_OW 88
// if tmp then
22944: LD_VAR 0 3
22948: IFFALSE 22966
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
22950: LD_VAR 0 3
22954: PUSH
22955: LD_INT 1
22957: ARRAY
22958: PPUSH
22959: LD_STRING D5-Sol2-1
22961: PPUSH
22962: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
22966: LD_EXP 59
22970: PPUSH
22971: LD_STRING D5-Pow-2
22973: PPUSH
22974: CALL_OW 88
// if tmp > 1 then
22978: LD_VAR 0 3
22982: PUSH
22983: LD_INT 1
22985: GREATER
22986: IFFALSE 23004
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
22988: LD_VAR 0 3
22992: PUSH
22993: LD_INT 2
22995: ARRAY
22996: PPUSH
22997: LD_STRING D5-Sol2-2
22999: PPUSH
23000: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
23004: LD_EXP 59
23008: PPUSH
23009: LD_STRING D5-Pow-3
23011: PPUSH
23012: CALL_OW 88
// wait ( 0 0$1 ) ;
23016: LD_INT 35
23018: PPUSH
23019: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
23023: LD_ADDR_VAR 0 3
23027: PUSH
23028: LD_EXP 18
23032: PUSH
23033: LD_INT 1
23035: ARRAY
23036: PUSH
23037: LD_EXP 18
23041: PUSH
23042: LD_INT 2
23044: ARRAY
23045: UNION
23046: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
23047: LD_VAR 0 3
23051: PPUSH
23052: LD_INT 80
23054: PPUSH
23055: LD_INT 67
23057: PPUSH
23058: CALL_OW 114
// wait ( 0 0$2 ) ;
23062: LD_INT 70
23064: PPUSH
23065: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
23069: LD_INT 79
23071: PPUSH
23072: LD_INT 72
23074: PPUSH
23075: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
23079: LD_INT 70
23081: PPUSH
23082: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
23086: LD_VAR 0 3
23090: PPUSH
23091: LD_INT 3
23093: PUSH
23094: LD_INT 24
23096: PUSH
23097: LD_INT 1000
23099: PUSH
23100: EMPTY
23101: LIST
23102: LIST
23103: PUSH
23104: EMPTY
23105: LIST
23106: LIST
23107: PPUSH
23108: CALL_OW 72
23112: IFFALSE 23079
// Say ( Powell , D5a-Pow-1 ) ;
23114: LD_EXP 59
23118: PPUSH
23119: LD_STRING D5a-Pow-1
23121: PPUSH
23122: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
23126: LD_EXP 59
23130: PPUSH
23131: LD_STRING D5a-Pow-1a
23133: PPUSH
23134: CALL_OW 88
// wait ( 0 0$0.7 ) ;
23138: LD_INT 24
23140: PPUSH
23141: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
23145: LD_EXP 59
23149: PPUSH
23150: LD_STRING D5a-Pow-1b
23152: PPUSH
23153: CALL_OW 88
// wait ( 0 0$0.3 ) ;
23157: LD_INT 10
23159: PPUSH
23160: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
23164: LD_EXP 59
23168: PPUSH
23169: LD_STRING D5a-Pow-1c
23171: PPUSH
23172: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
23176: LD_VAR 0 3
23180: PPUSH
23181: LD_INT 68
23183: PPUSH
23184: LD_INT 63
23186: PPUSH
23187: CALL_OW 111
// wait ( 0 0$0.5 ) ;
23191: LD_INT 18
23193: PPUSH
23194: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
23198: LD_EXP 59
23202: PPUSH
23203: LD_STRING D5a-Pow-1d
23205: PPUSH
23206: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
23210: LD_INT 35
23212: PPUSH
23213: CALL_OW 67
// if not HasTask ( tmp ) then
23217: LD_VAR 0 3
23221: PPUSH
23222: CALL_OW 314
23226: NOT
23227: IFFALSE 23244
// ComAgressiveMove ( tmp , 68 , 63 ) ;
23229: LD_VAR 0 3
23233: PPUSH
23234: LD_INT 68
23236: PPUSH
23237: LD_INT 63
23239: PPUSH
23240: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
23244: LD_VAR 0 3
23248: PPUSH
23249: LD_INT 24
23251: PUSH
23252: LD_INT 1
23254: PUSH
23255: EMPTY
23256: LIST
23257: LIST
23258: PPUSH
23259: CALL_OW 72
23263: NOT
23264: IFFALSE 23210
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
23266: LD_ADDR_VAR 0 3
23270: PUSH
23271: LD_INT 22
23273: PUSH
23274: LD_INT 4
23276: PUSH
23277: EMPTY
23278: LIST
23279: LIST
23280: PUSH
23281: LD_INT 92
23283: PUSH
23284: LD_INT 60
23286: PUSH
23287: LD_INT 93
23289: PUSH
23290: LD_INT 10
23292: PUSH
23293: EMPTY
23294: LIST
23295: LIST
23296: LIST
23297: LIST
23298: PUSH
23299: LD_INT 3
23301: PUSH
23302: LD_INT 54
23304: PUSH
23305: EMPTY
23306: LIST
23307: PUSH
23308: EMPTY
23309: LIST
23310: LIST
23311: PUSH
23312: EMPTY
23313: LIST
23314: LIST
23315: LIST
23316: PPUSH
23317: CALL_OW 69
23321: PUSH
23322: LD_EXP 59
23326: DIFF
23327: ST_TO_ADDR
// if tmp then
23328: LD_VAR 0 3
23332: IFFALSE 23366
// for i in tmp do
23334: LD_ADDR_VAR 0 1
23338: PUSH
23339: LD_VAR 0 3
23343: PUSH
23344: FOR_IN
23345: IFFALSE 23364
// ComMoveXY ( i , 36 , 67 ) ;
23347: LD_VAR 0 1
23351: PPUSH
23352: LD_INT 36
23354: PPUSH
23355: LD_INT 67
23357: PPUSH
23358: CALL_OW 111
23362: GO 23344
23364: POP
23365: POP
// wait ( 0 0$3 ) ;
23366: LD_INT 105
23368: PPUSH
23369: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
23373: LD_VAR 0 11
23377: PPUSH
23378: LD_STRING D6-Sol3-1
23380: PPUSH
23381: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
23385: LD_EXP 59
23389: PPUSH
23390: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
23394: LD_EXP 59
23398: PPUSH
23399: LD_STRING D6-Pow-1
23401: PPUSH
23402: CALL_OW 88
// tmp := [ ] ;
23406: LD_ADDR_VAR 0 3
23410: PUSH
23411: EMPTY
23412: ST_TO_ADDR
// for i = 1 to 2 do
23413: LD_ADDR_VAR 0 1
23417: PUSH
23418: DOUBLE
23419: LD_INT 1
23421: DEC
23422: ST_TO_ADDR
23423: LD_INT 2
23425: PUSH
23426: FOR_TO
23427: IFFALSE 23541
// begin uc_side := 8 ;
23429: LD_ADDR_OWVAR 20
23433: PUSH
23434: LD_INT 8
23436: ST_TO_ADDR
// uc_nation := 2 ;
23437: LD_ADDR_OWVAR 21
23441: PUSH
23442: LD_INT 2
23444: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
23445: LD_INT 14
23447: PPUSH
23448: LD_INT 3
23450: PPUSH
23451: LD_INT 2
23453: PPUSH
23454: LD_INT 29
23456: PPUSH
23457: LD_INT 100
23459: PPUSH
23460: CALL 72350 0 5
// veh := CreateVehicle ;
23464: LD_ADDR_VAR 0 13
23468: PUSH
23469: CALL_OW 45
23473: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
23474: LD_VAR 0 13
23478: PPUSH
23479: LD_INT 4
23481: PPUSH
23482: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
23486: LD_VAR 0 13
23490: PPUSH
23491: LD_INT 99
23493: PPUSH
23494: LD_INT 83
23496: PPUSH
23497: LD_INT 3
23499: PPUSH
23500: LD_INT 0
23502: PPUSH
23503: CALL_OW 50
// wait ( 3 ) ;
23507: LD_INT 3
23509: PPUSH
23510: CALL_OW 67
// Connect ( veh ) ;
23514: LD_VAR 0 13
23518: PPUSH
23519: CALL 75441 0 1
// tmp := tmp ^ veh ;
23523: LD_ADDR_VAR 0 3
23527: PUSH
23528: LD_VAR 0 3
23532: PUSH
23533: LD_VAR 0 13
23537: ADD
23538: ST_TO_ADDR
// end ;
23539: GO 23426
23541: POP
23542: POP
// wait ( 0 0$1 ) ;
23543: LD_INT 35
23545: PPUSH
23546: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
23550: LD_INT 99
23552: PPUSH
23553: LD_INT 83
23555: PPUSH
23556: LD_INT 1
23558: PPUSH
23559: LD_INT 10
23561: PPUSH
23562: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
23566: LD_INT 99
23568: PPUSH
23569: LD_INT 83
23571: PPUSH
23572: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
23576: LD_VAR 0 11
23580: PPUSH
23581: LD_STRING D6-Sol3-2
23583: PPUSH
23584: CALL_OW 88
// async ;
23588: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
23589: LD_EXP 59
23593: PPUSH
23594: LD_STRING D6-Pow-2
23596: PPUSH
23597: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
23601: LD_VAR 0 3
23605: PUSH
23606: LD_INT 1
23608: ARRAY
23609: PPUSH
23610: LD_VAR 0 9
23614: PPUSH
23615: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
23619: LD_VAR 0 3
23623: PUSH
23624: LD_INT 2
23626: ARRAY
23627: PPUSH
23628: LD_INT 22
23630: PUSH
23631: LD_INT 4
23633: PUSH
23634: EMPTY
23635: LIST
23636: LIST
23637: PUSH
23638: LD_INT 21
23640: PUSH
23641: LD_INT 3
23643: PUSH
23644: EMPTY
23645: LIST
23646: LIST
23647: PUSH
23648: EMPTY
23649: LIST
23650: LIST
23651: PPUSH
23652: CALL_OW 69
23656: PPUSH
23657: LD_VAR 0 3
23661: PUSH
23662: LD_INT 2
23664: ARRAY
23665: PPUSH
23666: CALL_OW 74
23670: PPUSH
23671: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
23675: LD_EXP 59
23679: PPUSH
23680: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
23684: LD_INT 99
23686: PPUSH
23687: LD_INT 83
23689: PPUSH
23690: LD_INT 1
23692: PPUSH
23693: CALL_OW 331
// repeat wait ( 4 ) ;
23697: LD_INT 4
23699: PPUSH
23700: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
23704: LD_VAR 0 3
23708: PUSH
23709: LD_INT 1
23711: ARRAY
23712: PPUSH
23713: CALL_OW 256
23717: PUSH
23718: LD_INT 1000
23720: LESS
23721: IFFALSE 23739
// SetLives ( tmp [ 1 ] , 1000 ) ;
23723: LD_VAR 0 3
23727: PUSH
23728: LD_INT 1
23730: ARRAY
23731: PPUSH
23732: LD_INT 1000
23734: PPUSH
23735: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
23739: LD_INT 22
23741: PUSH
23742: LD_INT 4
23744: PUSH
23745: EMPTY
23746: LIST
23747: LIST
23748: PUSH
23749: LD_INT 30
23751: PUSH
23752: LD_INT 3
23754: PUSH
23755: EMPTY
23756: LIST
23757: LIST
23758: PUSH
23759: EMPTY
23760: LIST
23761: LIST
23762: PPUSH
23763: CALL_OW 69
23767: PUSH
23768: LD_INT 0
23770: EQUAL
23771: IFFALSE 23697
// skirmish := false ;
23773: LD_ADDR_EXP 97
23777: PUSH
23778: LD_INT 0
23780: ST_TO_ADDR
// sync ;
23781: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
23782: LD_EXP 59
23786: PPUSH
23787: LD_STRING D6a-Pow-1
23789: PPUSH
23790: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
23794: LD_VAR 0 11
23798: PPUSH
23799: LD_STRING D6a-Sol3-1
23801: PPUSH
23802: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
23806: LD_EXP 59
23810: PPUSH
23811: LD_STRING D6a-Pow-2
23813: PPUSH
23814: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
23818: LD_VAR 0 11
23822: PPUSH
23823: LD_STRING D6a-Sol3-2
23825: PPUSH
23826: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
23830: LD_EXP 59
23834: PPUSH
23835: LD_STRING D6a-Pow-3
23837: PPUSH
23838: CALL_OW 88
// powellCenterCameraMode := true ;
23842: LD_ADDR_EXP 20
23846: PUSH
23847: LD_INT 1
23849: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23850: LD_ADDR_VAR 0 1
23854: PUSH
23855: LD_INT 22
23857: PUSH
23858: LD_INT 8
23860: PUSH
23861: EMPTY
23862: LIST
23863: LIST
23864: PUSH
23865: LD_INT 25
23867: PUSH
23868: LD_INT 2
23870: PUSH
23871: EMPTY
23872: LIST
23873: LIST
23874: PUSH
23875: EMPTY
23876: LIST
23877: LIST
23878: PPUSH
23879: CALL_OW 69
23883: PUSH
23884: FOR_IN
23885: IFFALSE 23940
// begin SetTag ( i , 1 ) ;
23887: LD_VAR 0 1
23891: PPUSH
23892: LD_INT 1
23894: PPUSH
23895: CALL_OW 109
// ComExitBuilding ( i ) ;
23899: LD_VAR 0 1
23903: PPUSH
23904: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
23908: LD_VAR 0 1
23912: PPUSH
23913: LD_INT 35
23915: PPUSH
23916: LD_INT 6
23918: PPUSH
23919: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
23923: LD_VAR 0 1
23927: PPUSH
23928: LD_INT 53
23930: PPUSH
23931: LD_INT 4
23933: PPUSH
23934: CALL_OW 171
// end ;
23938: GO 23884
23940: POP
23941: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
23942: LD_ADDR_VAR 0 3
23946: PUSH
23947: LD_INT 22
23949: PUSH
23950: LD_INT 4
23952: PUSH
23953: EMPTY
23954: LIST
23955: LIST
23956: PUSH
23957: LD_INT 21
23959: PUSH
23960: LD_INT 2
23962: PUSH
23963: EMPTY
23964: LIST
23965: LIST
23966: PUSH
23967: LD_INT 3
23969: PUSH
23970: LD_INT 34
23972: PUSH
23973: LD_INT 12
23975: PUSH
23976: EMPTY
23977: LIST
23978: LIST
23979: PUSH
23980: EMPTY
23981: LIST
23982: LIST
23983: PUSH
23984: EMPTY
23985: LIST
23986: LIST
23987: LIST
23988: PPUSH
23989: CALL_OW 69
23993: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
23994: LD_EXP 59
23998: PPUSH
23999: LD_VAR 0 3
24003: PPUSH
24004: LD_EXP 59
24008: PPUSH
24009: CALL_OW 74
24013: PPUSH
24014: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
24018: LD_EXP 59
24022: PPUSH
24023: LD_INT 100
24025: PPUSH
24026: LD_INT 88
24028: PPUSH
24029: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
24033: LD_EXP 59
24037: PPUSH
24038: LD_INT 100
24040: PPUSH
24041: LD_INT 75
24043: PPUSH
24044: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
24048: LD_EXP 59
24052: PPUSH
24053: LD_INT 88
24055: PPUSH
24056: LD_INT 53
24058: PPUSH
24059: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
24063: LD_INT 8
24065: PPUSH
24066: LD_EXP 59
24070: PPUSH
24071: CALL_OW 471
// repeat wait ( 3 ) ;
24075: LD_INT 3
24077: PPUSH
24078: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
24082: LD_INT 22
24084: PUSH
24085: LD_INT 4
24087: PUSH
24088: EMPTY
24089: LIST
24090: LIST
24091: PUSH
24092: LD_INT 92
24094: PUSH
24095: LD_INT 100
24097: PUSH
24098: LD_INT 75
24100: PUSH
24101: LD_INT 6
24103: PUSH
24104: EMPTY
24105: LIST
24106: LIST
24107: LIST
24108: LIST
24109: PUSH
24110: EMPTY
24111: LIST
24112: LIST
24113: PPUSH
24114: CALL_OW 69
24118: IFFALSE 24075
// async ;
24120: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
24121: LD_EXP 59
24125: PPUSH
24126: LD_STRING D6b-Pow-1
24128: PPUSH
24129: CALL_OW 88
// repeat wait ( 3 ) ;
24133: LD_INT 3
24135: PPUSH
24136: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
24140: LD_EXP 59
24144: PPUSH
24145: CALL_OW 310
24149: PPUSH
24150: CALL_OW 256
24154: PUSH
24155: LD_INT 1000
24157: LESS
24158: IFFALSE 24177
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
24160: LD_EXP 59
24164: PPUSH
24165: CALL_OW 310
24169: PPUSH
24170: LD_INT 1000
24172: PPUSH
24173: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
24177: LD_EXP 59
24181: PPUSH
24182: CALL_OW 256
24186: PUSH
24187: LD_INT 1000
24189: LESS
24190: IFFALSE 24204
// SetLives ( Powell , 1000 ) ;
24192: LD_EXP 59
24196: PPUSH
24197: LD_INT 1000
24199: PPUSH
24200: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
24204: LD_EXP 59
24208: PPUSH
24209: LD_EXP 64
24213: PPUSH
24214: CALL_OW 296
24218: PUSH
24219: LD_INT 5
24221: LESS
24222: PUSH
24223: LD_EXP 59
24227: PPUSH
24228: CALL_OW 310
24232: PPUSH
24233: LD_EXP 64
24237: PPUSH
24238: CALL_OW 296
24242: PUSH
24243: LD_INT 5
24245: LESS
24246: OR
24247: IFFALSE 24266
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
24249: LD_EXP 59
24253: PPUSH
24254: CALL_OW 310
24258: PPUSH
24259: LD_INT 100
24261: PPUSH
24262: CALL_OW 234
// until not IsInUnit ( Powell ) ;
24266: LD_EXP 59
24270: PPUSH
24271: CALL_OW 310
24275: NOT
24276: IFFALSE 24133
// DoNotAttack ( 8 , powellBomb ) ;
24278: LD_INT 8
24280: PPUSH
24281: LD_EXP 64
24285: PPUSH
24286: CALL_OW 471
// game_speed := 4 ;
24290: LD_ADDR_OWVAR 65
24294: PUSH
24295: LD_INT 4
24297: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
24298: LD_EXP 59
24302: PPUSH
24303: LD_STRING D6b-Pow-1a
24305: PPUSH
24306: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
24310: LD_EXP 59
24314: PPUSH
24315: LD_EXP 64
24319: PPUSH
24320: CALL_OW 180
// sync ;
24324: SYNC
// repeat wait ( 0 0$1 ) ;
24325: LD_INT 35
24327: PPUSH
24328: CALL_OW 67
// until IsInUnit ( Powell ) ;
24332: LD_EXP 59
24336: PPUSH
24337: CALL_OW 310
24341: IFFALSE 24325
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
24343: LD_INT 8
24345: PPUSH
24346: LD_EXP 59
24350: PPUSH
24351: CALL_OW 310
24355: PPUSH
24356: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
24360: LD_EXP 59
24364: PPUSH
24365: LD_INT 91
24367: PPUSH
24368: LD_INT 44
24370: PPUSH
24371: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
24375: LD_EXP 59
24379: PPUSH
24380: LD_INT 96
24382: PPUSH
24383: LD_INT 44
24385: PPUSH
24386: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
24390: LD_EXP 59
24394: PPUSH
24395: LD_INT 96
24397: PPUSH
24398: LD_INT 41
24400: PPUSH
24401: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
24405: LD_EXP 59
24409: PPUSH
24410: LD_INT 92
24412: PPUSH
24413: LD_INT 39
24415: PPUSH
24416: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
24420: LD_EXP 59
24424: PPUSH
24425: LD_INT 88
24427: PPUSH
24428: LD_INT 41
24430: PPUSH
24431: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
24435: LD_EXP 59
24439: PPUSH
24440: LD_INT 91
24442: PPUSH
24443: LD_INT 44
24445: PPUSH
24446: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
24450: LD_EXP 59
24454: PPUSH
24455: LD_INT 96
24457: PPUSH
24458: LD_INT 44
24460: PPUSH
24461: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
24465: LD_EXP 59
24469: PPUSH
24470: LD_INT 96
24472: PPUSH
24473: LD_INT 41
24475: PPUSH
24476: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
24480: LD_EXP 59
24484: PPUSH
24485: LD_INT 92
24487: PPUSH
24488: LD_INT 39
24490: PPUSH
24491: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
24495: LD_EXP 59
24499: PPUSH
24500: LD_INT 88
24502: PPUSH
24503: LD_INT 41
24505: PPUSH
24506: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
24510: LD_EXP 59
24514: PPUSH
24515: LD_INT 91
24517: PPUSH
24518: LD_INT 44
24520: PPUSH
24521: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
24525: LD_EXP 59
24529: PPUSH
24530: LD_INT 93
24532: PPUSH
24533: LD_INT 39
24535: PPUSH
24536: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
24540: LD_EXP 59
24544: PPUSH
24545: LD_INT 93
24547: PPUSH
24548: LD_INT 36
24550: PPUSH
24551: CALL_OW 171
// wait ( 0 0$3.5 ) ;
24555: LD_INT 122
24557: PPUSH
24558: CALL_OW 67
// game_speed := 4 ;
24562: LD_ADDR_OWVAR 65
24566: PUSH
24567: LD_INT 4
24569: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
24570: LD_EXP 59
24574: PPUSH
24575: LD_STRING D6b-Pow-1b
24577: PPUSH
24578: CALL_OW 88
// tmp := [ ] ;
24582: LD_ADDR_VAR 0 3
24586: PUSH
24587: EMPTY
24588: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
24589: LD_ADDR_VAR 0 5
24593: PUSH
24594: LD_INT 78
24596: PUSH
24597: LD_INT 47
24599: PUSH
24600: EMPTY
24601: LIST
24602: LIST
24603: PUSH
24604: LD_INT 106
24606: PUSH
24607: LD_INT 53
24609: PUSH
24610: EMPTY
24611: LIST
24612: LIST
24613: PUSH
24614: EMPTY
24615: LIST
24616: LIST
24617: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
24618: LD_ADDR_VAR 0 1
24622: PUSH
24623: LD_INT 22
24625: PUSH
24626: LD_INT 8
24628: PUSH
24629: EMPTY
24630: LIST
24631: LIST
24632: PUSH
24633: LD_INT 21
24635: PUSH
24636: LD_INT 3
24638: PUSH
24639: EMPTY
24640: LIST
24641: LIST
24642: PUSH
24643: LD_INT 92
24645: PUSH
24646: LD_INT 90
24648: PUSH
24649: LD_INT 52
24651: PUSH
24652: LD_INT 12
24654: PUSH
24655: EMPTY
24656: LIST
24657: LIST
24658: LIST
24659: LIST
24660: PUSH
24661: EMPTY
24662: LIST
24663: LIST
24664: LIST
24665: PPUSH
24666: CALL_OW 69
24670: PUSH
24671: FOR_IN
24672: IFFALSE 24697
// tmp := tmp ^ UnitsInside ( i ) ;
24674: LD_ADDR_VAR 0 3
24678: PUSH
24679: LD_VAR 0 3
24683: PUSH
24684: LD_VAR 0 1
24688: PPUSH
24689: CALL_OW 313
24693: ADD
24694: ST_TO_ADDR
24695: GO 24671
24697: POP
24698: POP
// for i in tmp do
24699: LD_ADDR_VAR 0 1
24703: PUSH
24704: LD_VAR 0 3
24708: PUSH
24709: FOR_IN
24710: IFFALSE 24872
// begin dist := 9999 ;
24712: LD_ADDR_VAR 0 8
24716: PUSH
24717: LD_INT 9999
24719: ST_TO_ADDR
// _xy := [ ] ;
24720: LD_ADDR_VAR 0 7
24724: PUSH
24725: EMPTY
24726: ST_TO_ADDR
// SetTag ( i , 1 ) ;
24727: LD_VAR 0 1
24731: PPUSH
24732: LD_INT 1
24734: PPUSH
24735: CALL_OW 109
// ComExitBuilding ( i ) ;
24739: LD_VAR 0 1
24743: PPUSH
24744: CALL_OW 122
// for j in xy do
24748: LD_ADDR_VAR 0 2
24752: PUSH
24753: LD_VAR 0 5
24757: PUSH
24758: FOR_IN
24759: IFFALSE 24841
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
24761: LD_VAR 0 1
24765: PPUSH
24766: LD_VAR 0 2
24770: PUSH
24771: LD_INT 1
24773: ARRAY
24774: PPUSH
24775: LD_VAR 0 2
24779: PUSH
24780: LD_INT 2
24782: ARRAY
24783: PPUSH
24784: CALL_OW 297
24788: PUSH
24789: LD_VAR 0 8
24793: LESS
24794: IFFALSE 24839
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
24796: LD_ADDR_VAR 0 8
24800: PUSH
24801: LD_VAR 0 1
24805: PPUSH
24806: LD_VAR 0 2
24810: PUSH
24811: LD_INT 1
24813: ARRAY
24814: PPUSH
24815: LD_VAR 0 2
24819: PUSH
24820: LD_INT 2
24822: ARRAY
24823: PPUSH
24824: CALL_OW 297
24828: ST_TO_ADDR
// _xy := j ;
24829: LD_ADDR_VAR 0 7
24833: PUSH
24834: LD_VAR 0 2
24838: ST_TO_ADDR
// end ;
24839: GO 24758
24841: POP
24842: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
24843: LD_VAR 0 1
24847: PPUSH
24848: LD_VAR 0 7
24852: PUSH
24853: LD_INT 1
24855: ARRAY
24856: PPUSH
24857: LD_VAR 0 7
24861: PUSH
24862: LD_INT 2
24864: ARRAY
24865: PPUSH
24866: CALL_OW 171
// end ;
24870: GO 24709
24872: POP
24873: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
24874: LD_ADDR_VAR 0 4
24878: PUSH
24879: LD_VAR 0 3
24883: PPUSH
24884: LD_INT 26
24886: PUSH
24887: LD_INT 1
24889: PUSH
24890: EMPTY
24891: LIST
24892: LIST
24893: PUSH
24894: LD_INT 25
24896: PUSH
24897: LD_INT 1
24899: PUSH
24900: EMPTY
24901: LIST
24902: LIST
24903: PUSH
24904: EMPTY
24905: LIST
24906: LIST
24907: PPUSH
24908: CALL_OW 72
24912: ST_TO_ADDR
// if tmp2 < 2 then
24913: LD_VAR 0 4
24917: PUSH
24918: LD_INT 2
24920: LESS
24921: IFFALSE 24990
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
24923: LD_ADDR_VAR 0 4
24927: PUSH
24928: LD_INT 22
24930: PUSH
24931: LD_INT 8
24933: PUSH
24934: EMPTY
24935: LIST
24936: LIST
24937: PUSH
24938: LD_INT 26
24940: PUSH
24941: LD_INT 1
24943: PUSH
24944: EMPTY
24945: LIST
24946: LIST
24947: PUSH
24948: LD_INT 3
24950: PUSH
24951: LD_INT 25
24953: PUSH
24954: LD_INT 15
24956: PUSH
24957: EMPTY
24958: LIST
24959: LIST
24960: PUSH
24961: EMPTY
24962: LIST
24963: LIST
24964: PUSH
24965: EMPTY
24966: LIST
24967: LIST
24968: LIST
24969: PPUSH
24970: CALL_OW 69
24974: PUSH
24975: LD_EXP 61
24979: PUSH
24980: LD_EXP 62
24984: PUSH
24985: EMPTY
24986: LIST
24987: LIST
24988: DIFF
24989: ST_TO_ADDR
// if tmp2 then
24990: LD_VAR 0 4
24994: IFFALSE 25012
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
24996: LD_VAR 0 4
25000: PUSH
25001: LD_INT 1
25003: ARRAY
25004: PPUSH
25005: LD_STRING D6b-ArSol1-1
25007: PPUSH
25008: CALL_OW 88
// async ;
25012: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
25013: LD_EXP 59
25017: PPUSH
25018: LD_STRING D6b-Pow-2
25020: PPUSH
25021: CALL_OW 88
// wait ( 0 0$0.5 ) ;
25025: LD_INT 18
25027: PPUSH
25028: CALL_OW 67
// if tmp2 > 1 then
25032: LD_VAR 0 4
25036: PUSH
25037: LD_INT 1
25039: GREATER
25040: IFFALSE 25058
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
25042: LD_VAR 0 4
25046: PUSH
25047: LD_INT 2
25049: ARRAY
25050: PPUSH
25051: LD_STRING D6b-ArSol2-1
25053: PPUSH
25054: CALL_OW 88
// sync ;
25058: SYNC
// repeat wait ( 5 ) ;
25059: LD_INT 5
25061: PPUSH
25062: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
25066: LD_INT 93
25068: PPUSH
25069: LD_INT 36
25071: PPUSH
25072: CALL_OW 428
25076: PPUSH
25077: CALL_OW 255
25081: PUSH
25082: LD_INT 4
25084: EQUAL
25085: IFFALSE 25059
// DialogueOn ;
25087: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
25091: LD_INT 10
25093: PPUSH
25094: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
25098: LD_EXP 59
25102: PPUSH
25103: LD_STRING D6b-Pow-2a
25105: PPUSH
25106: CALL_OW 88
// DialogueOff ;
25110: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
25114: LD_EXP 59
25118: PPUSH
25119: CALL_OW 310
25123: PPUSH
25124: LD_INT 332
25126: PPUSH
25127: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
25131: LD_INT 93
25133: PPUSH
25134: LD_INT 35
25136: PPUSH
25137: LD_INT 1
25139: PPUSH
25140: LD_INT 6
25142: NEG
25143: PPUSH
25144: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
25148: LD_INT 35
25150: PPUSH
25151: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
25155: LD_INT 332
25157: PPUSH
25158: CALL_OW 256
25162: PUSH
25163: LD_INT 1000
25165: LESS
25166: PUSH
25167: LD_INT 332
25169: PPUSH
25170: CALL_OW 300
25174: AND
25175: IFFALSE 25187
// SetLives ( kozlov_fac , 0 ) ;
25177: LD_INT 332
25179: PPUSH
25180: LD_INT 0
25182: PPUSH
25183: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
25187: LD_INT 332
25189: PPUSH
25190: CALL_OW 301
25194: PUSH
25195: LD_EXP 59
25199: PPUSH
25200: CALL_OW 301
25204: OR
25205: IFFALSE 25148
// game_speed := 4 ;
25207: LD_ADDR_OWVAR 65
25211: PUSH
25212: LD_INT 4
25214: ST_TO_ADDR
// powellCenterCameraMode := false ;
25215: LD_ADDR_EXP 20
25219: PUSH
25220: LD_INT 0
25222: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
25223: LD_ADDR_VAR 0 1
25227: PUSH
25228: LD_VAR 0 3
25232: PUSH
25233: LD_INT 22
25235: PUSH
25236: LD_INT 8
25238: PUSH
25239: EMPTY
25240: LIST
25241: LIST
25242: PUSH
25243: LD_INT 25
25245: PUSH
25246: LD_INT 2
25248: PUSH
25249: EMPTY
25250: LIST
25251: LIST
25252: PUSH
25253: EMPTY
25254: LIST
25255: LIST
25256: PPUSH
25257: CALL_OW 69
25261: UNION
25262: PUSH
25263: FOR_IN
25264: IFFALSE 25280
// SetTag ( i , 0 ) ;
25266: LD_VAR 0 1
25270: PPUSH
25271: LD_INT 0
25273: PPUSH
25274: CALL_OW 109
25278: GO 25263
25280: POP
25281: POP
// wait ( 0 0$3 ) ;
25282: LD_INT 105
25284: PPUSH
25285: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
25289: LD_INT 93
25291: PPUSH
25292: LD_INT 35
25294: PPUSH
25295: LD_INT 1
25297: PPUSH
25298: CALL_OW 331
// DialogueOn ;
25302: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
25306: LD_VAR 0 11
25310: PPUSH
25311: LD_STRING D6c-Sol3-1
25313: PPUSH
25314: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
25318: LD_INT 10
25320: PPUSH
25321: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
25325: LD_EXP 40
25329: PPUSH
25330: LD_STRING D6c-JMM-1
25332: PPUSH
25333: CALL_OW 88
// if Cyrus then
25337: LD_EXP 46
25341: IFFALSE 25355
// Say ( Cyrus , D6c-Cyrus-1 ) ;
25343: LD_EXP 46
25347: PPUSH
25348: LD_STRING D6c-Cyrus-1
25350: PPUSH
25351: CALL_OW 88
// if Bobby then
25355: LD_EXP 45
25359: IFFALSE 25373
// Say ( Bobby , D6c-Bobby-1 ) ;
25361: LD_EXP 45
25365: PPUSH
25366: LD_STRING D6c-Bobby-1
25368: PPUSH
25369: CALL_OW 88
// if Cornel then
25373: LD_EXP 51
25377: IFFALSE 25391
// Say ( Cornel , D6c-Corn-1 ) ;
25379: LD_EXP 51
25383: PPUSH
25384: LD_STRING D6c-Corn-1
25386: PPUSH
25387: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
25391: LD_ADDR_VAR 0 4
25395: PUSH
25396: LD_INT 2
25398: PUSH
25399: LD_INT 22
25401: PUSH
25402: LD_INT 1
25404: PUSH
25405: EMPTY
25406: LIST
25407: LIST
25408: PUSH
25409: LD_INT 22
25411: PUSH
25412: LD_INT 4
25414: PUSH
25415: EMPTY
25416: LIST
25417: LIST
25418: PUSH
25419: EMPTY
25420: LIST
25421: LIST
25422: LIST
25423: PUSH
25424: LD_INT 26
25426: PUSH
25427: LD_INT 1
25429: PUSH
25430: EMPTY
25431: LIST
25432: LIST
25433: PUSH
25434: LD_INT 23
25436: PUSH
25437: LD_INT 1
25439: PUSH
25440: EMPTY
25441: LIST
25442: LIST
25443: PUSH
25444: EMPTY
25445: LIST
25446: LIST
25447: LIST
25448: PPUSH
25449: CALL_OW 69
25453: PUSH
25454: LD_VAR 0 11
25458: PUSH
25459: LD_EXP 40
25463: UNION
25464: PUSH
25465: LD_EXP 60
25469: UNION
25470: DIFF
25471: ST_TO_ADDR
// if tmp2 then
25472: LD_VAR 0 4
25476: IFFALSE 25494
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
25478: LD_VAR 0 4
25482: PUSH
25483: LD_INT 1
25485: ARRAY
25486: PPUSH
25487: LD_STRING D6c-Sol1-1
25489: PPUSH
25490: CALL_OW 88
// if Lisa then
25494: LD_EXP 43
25498: IFFALSE 25512
// Say ( Lisa , D6c-Lisa-1 ) ;
25500: LD_EXP 43
25504: PPUSH
25505: LD_STRING D6c-Lisa-1
25507: PPUSH
25508: CALL_OW 88
// if Gary then
25512: LD_EXP 52
25516: IFFALSE 25530
// Say ( Gary , D6c-Gary-1 ) ;
25518: LD_EXP 52
25522: PPUSH
25523: LD_STRING D6c-Gary-1
25525: PPUSH
25526: CALL_OW 88
// if Donaldson then
25530: LD_EXP 44
25534: IFFALSE 25548
// Say ( Donaldson , D6c-Don-1 ) ;
25536: LD_EXP 44
25540: PPUSH
25541: LD_STRING D6c-Don-1
25543: PPUSH
25544: CALL_OW 88
// if tmp2 > 1 then
25548: LD_VAR 0 4
25552: PUSH
25553: LD_INT 1
25555: GREATER
25556: IFFALSE 25574
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
25558: LD_VAR 0 4
25562: PUSH
25563: LD_INT 2
25565: ARRAY
25566: PPUSH
25567: LD_STRING D6c-Sol2-1
25569: PPUSH
25570: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
25574: LD_VAR 0 11
25578: PPUSH
25579: LD_STRING D6c-Sol3-2
25581: PPUSH
25582: CALL_OW 88
// if IsInUnit ( JMM ) then
25586: LD_EXP 40
25590: PPUSH
25591: CALL_OW 310
25595: IFFALSE 25613
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
25597: LD_EXP 40
25601: PPUSH
25602: CALL_OW 310
25606: PPUSH
25607: CALL_OW 87
25611: GO 25622
// CenterNowOnUnits ( JMM ) ;
25613: LD_EXP 40
25617: PPUSH
25618: CALL_OW 87
// dwait ( 0 0$2 ) ;
25622: LD_INT 70
25624: PPUSH
25625: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
25629: LD_EXP 40
25633: PPUSH
25634: LD_STRING D6c-JMM-2
25636: PPUSH
25637: CALL_OW 88
// DialogueOff ;
25641: CALL_OW 7
// Video ( false ) ;
25645: LD_INT 0
25647: PPUSH
25648: CALL 104756 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
25652: LD_INT 22
25654: PUSH
25655: LD_INT 4
25657: PUSH
25658: EMPTY
25659: LIST
25660: LIST
25661: PPUSH
25662: CALL_OW 69
25666: PPUSH
25667: LD_INT 1
25669: PPUSH
25670: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
25674: LD_INT 4
25676: PPUSH
25677: LD_INT 4
25679: PPUSH
25680: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
25684: LD_ADDR_VAR 0 1
25688: PUSH
25689: LD_INT 4
25691: PPUSH
25692: LD_INT 1
25694: PPUSH
25695: LD_INT 2
25697: PPUSH
25698: CALL 67398 0 3
25702: PUSH
25703: FOR_IN
25704: IFFALSE 25741
// if GetTech ( i , 1 ) <> state_researched then
25706: LD_VAR 0 1
25710: PPUSH
25711: LD_INT 1
25713: PPUSH
25714: CALL_OW 321
25718: PUSH
25719: LD_INT 2
25721: NONEQUAL
25722: IFFALSE 25739
// SetTech ( i , 1 , state_researched ) ;
25724: LD_VAR 0 1
25728: PPUSH
25729: LD_INT 1
25731: PPUSH
25732: LD_INT 2
25734: PPUSH
25735: CALL_OW 322
25739: GO 25703
25741: POP
25742: POP
// missionStage := 6 ;
25743: LD_ADDR_EXP 15
25747: PUSH
25748: LD_INT 6
25750: ST_TO_ADDR
// activeAttacks := true ;
25751: LD_ADDR_EXP 16
25755: PUSH
25756: LD_INT 1
25758: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
25759: LD_STRING M2
25761: PPUSH
25762: CALL_OW 337
// SaveForQuickRestart ;
25766: CALL_OW 22
// wait ( 0 0$40 ) ;
25770: LD_INT 1400
25772: PPUSH
25773: CALL_OW 67
// DialogueOn ;
25777: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
25781: LD_EXP 63
25785: PPUSH
25786: LD_STRING D7-Friend-1
25788: PPUSH
25789: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
25793: LD_EXP 40
25797: PPUSH
25798: LD_STRING D7-JMM-1
25800: PPUSH
25801: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
25805: LD_EXP 63
25809: PPUSH
25810: LD_STRING D7-Friend-2
25812: PPUSH
25813: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
25817: LD_EXP 40
25821: PPUSH
25822: LD_STRING D7-JMM-2
25824: PPUSH
25825: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
25829: LD_EXP 63
25833: PPUSH
25834: LD_STRING D7-Friend-3
25836: PPUSH
25837: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
25841: LD_EXP 40
25845: PPUSH
25846: LD_STRING D7-JMM-3
25848: PPUSH
25849: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
25853: LD_EXP 63
25857: PPUSH
25858: LD_STRING D7-Friend-4
25860: PPUSH
25861: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
25865: LD_EXP 40
25869: PPUSH
25870: LD_STRING D7-JMM-4
25872: PPUSH
25873: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
25877: LD_EXP 63
25881: PPUSH
25882: LD_STRING D7-Friend-5
25884: PPUSH
25885: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
25889: LD_EXP 40
25893: PPUSH
25894: LD_STRING D7-JMM-5
25896: PPUSH
25897: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
25901: LD_EXP 63
25905: PPUSH
25906: LD_STRING D7-Friend-6
25908: PPUSH
25909: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
25913: LD_EXP 40
25917: PPUSH
25918: LD_STRING D7-JMM-6
25920: PPUSH
25921: CALL_OW 88
// DialogueOff ;
25925: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
25929: LD_STRING Mlegion
25931: PPUSH
25932: CALL_OW 337
// skirmish := true ;
25936: LD_ADDR_EXP 97
25940: PUSH
25941: LD_INT 1
25943: ST_TO_ADDR
// RebuildKozlovFactory ;
25944: CALL 4920 0 0
// end ;
25948: PPOPN 13
25950: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
25951: LD_EXP 20
25955: PUSH
25956: LD_EXP 59
25960: PPUSH
25961: CALL_OW 300
25965: AND
25966: IFFALSE 26008
25968: GO 25970
25970: DISABLE
// begin enable ;
25971: ENABLE
// if IsInUnit ( Powell ) then
25972: LD_EXP 59
25976: PPUSH
25977: CALL_OW 310
25981: IFFALSE 25999
// CenterOnUnits ( IsInUnit ( Powell ) ) else
25983: LD_EXP 59
25987: PPUSH
25988: CALL_OW 310
25992: PPUSH
25993: CALL_OW 85
25997: GO 26008
// CenterOnUnits ( Powell ) ;
25999: LD_EXP 59
26003: PPUSH
26004: CALL_OW 85
// end ;
26008: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
26009: LD_INT 22
26011: PUSH
26012: LD_INT 8
26014: PUSH
26015: EMPTY
26016: LIST
26017: LIST
26018: PUSH
26019: LD_INT 34
26021: PUSH
26022: LD_INT 48
26024: PUSH
26025: EMPTY
26026: LIST
26027: LIST
26028: PUSH
26029: EMPTY
26030: LIST
26031: LIST
26032: PPUSH
26033: CALL_OW 69
26037: IFFALSE 26311
26039: GO 26041
26041: DISABLE
26042: LD_INT 0
26044: PPUSH
26045: PPUSH
// begin if missionStage < 9 then
26046: LD_EXP 15
26050: PUSH
26051: LD_INT 9
26053: LESS
26054: IFFALSE 26064
// missionStage := 9 ;
26056: LD_ADDR_EXP 15
26060: PUSH
26061: LD_INT 9
26063: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
26064: LD_ADDR_VAR 0 1
26068: PUSH
26069: LD_INT 22
26071: PUSH
26072: LD_INT 8
26074: PUSH
26075: EMPTY
26076: LIST
26077: LIST
26078: PUSH
26079: LD_INT 34
26081: PUSH
26082: LD_INT 48
26084: PUSH
26085: EMPTY
26086: LIST
26087: LIST
26088: PUSH
26089: EMPTY
26090: LIST
26091: LIST
26092: PPUSH
26093: CALL_OW 69
26097: PUSH
26098: LD_INT 1
26100: ARRAY
26101: ST_TO_ADDR
// wait ( 0 0$05 ) ;
26102: LD_INT 175
26104: PPUSH
26105: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
26109: LD_EXP 12
26113: PUSH
26114: LD_EXP 3
26118: PUSH
26119: LD_INT 0
26121: PUSH
26122: LD_INT 2
26124: PUSH
26125: EMPTY
26126: LIST
26127: LIST
26128: IN
26129: OR
26130: IFFALSE 26153
// target := [ 68 , 108 , 1 ] else
26132: LD_ADDR_VAR 0 2
26136: PUSH
26137: LD_INT 68
26139: PUSH
26140: LD_INT 108
26142: PUSH
26143: LD_INT 1
26145: PUSH
26146: EMPTY
26147: LIST
26148: LIST
26149: LIST
26150: ST_TO_ADDR
26151: GO 26172
// target := [ 181 , 88 , 2 ] ;
26153: LD_ADDR_VAR 0 2
26157: PUSH
26158: LD_INT 181
26160: PUSH
26161: LD_INT 88
26163: PUSH
26164: LD_INT 2
26166: PUSH
26167: EMPTY
26168: LIST
26169: LIST
26170: LIST
26171: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
26172: LD_VAR 0 1
26176: PPUSH
26177: LD_VAR 0 2
26181: PUSH
26182: LD_INT 1
26184: ARRAY
26185: PPUSH
26186: LD_VAR 0 2
26190: PUSH
26191: LD_INT 2
26193: ARRAY
26194: PPUSH
26195: CALL_OW 176
// if target [ 3 ] = 1 then
26199: LD_VAR 0 2
26203: PUSH
26204: LD_INT 3
26206: ARRAY
26207: PUSH
26208: LD_INT 1
26210: EQUAL
26211: IFFALSE 26227
// SayRadio ( Kurt , D12-Kurt-1 ) else
26213: LD_EXP 61
26217: PPUSH
26218: LD_STRING D12-Kurt-1
26220: PPUSH
26221: CALL_OW 94
26225: GO 26251
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
26227: LD_EXP 61
26231: PPUSH
26232: LD_STRING D12a-Kurt-1
26234: PPUSH
26235: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
26239: LD_EXP 76
26243: PPUSH
26244: LD_STRING D12a-Roth-1
26246: PPUSH
26247: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
26251: LD_INT 350
26253: PPUSH
26254: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
26258: LD_VAR 0 1
26262: PPUSH
26263: LD_INT 22
26265: PUSH
26266: LD_INT 8
26268: PUSH
26269: EMPTY
26270: LIST
26271: LIST
26272: PUSH
26273: LD_INT 23
26275: PUSH
26276: LD_INT 2
26278: PUSH
26279: EMPTY
26280: LIST
26281: LIST
26282: PUSH
26283: LD_INT 30
26285: PUSH
26286: LD_INT 3
26288: PUSH
26289: EMPTY
26290: LIST
26291: LIST
26292: PUSH
26293: EMPTY
26294: LIST
26295: LIST
26296: LIST
26297: PPUSH
26298: CALL_OW 69
26302: PUSH
26303: LD_INT 1
26305: ARRAY
26306: PPUSH
26307: CALL_OW 228
// end ;
26311: PPOPN 2
26313: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
26314: LD_EXP 61
26318: PPUSH
26319: CALL_OW 256
26323: PUSH
26324: LD_INT 999
26326: LESS
26327: PUSH
26328: LD_INT 22
26330: PUSH
26331: LD_INT 8
26333: PUSH
26334: EMPTY
26335: LIST
26336: LIST
26337: PUSH
26338: LD_INT 21
26340: PUSH
26341: LD_INT 1
26343: PUSH
26344: EMPTY
26345: LIST
26346: LIST
26347: PUSH
26348: LD_INT 23
26350: PUSH
26351: LD_INT 2
26353: PUSH
26354: EMPTY
26355: LIST
26356: LIST
26357: PUSH
26358: EMPTY
26359: LIST
26360: LIST
26361: LIST
26362: PPUSH
26363: CALL_OW 69
26367: PUSH
26368: LD_INT 9
26370: PUSH
26371: LD_INT 8
26373: PUSH
26374: LD_INT 7
26376: PUSH
26377: LD_INT 6
26379: PUSH
26380: EMPTY
26381: LIST
26382: LIST
26383: LIST
26384: LIST
26385: PUSH
26386: LD_OWVAR 67
26390: ARRAY
26391: LESSEQUAL
26392: OR
26393: PUSH
26394: LD_INT 22
26396: PUSH
26397: LD_INT 8
26399: PUSH
26400: EMPTY
26401: LIST
26402: LIST
26403: PUSH
26404: LD_INT 34
26406: PUSH
26407: LD_INT 48
26409: PUSH
26410: EMPTY
26411: LIST
26412: LIST
26413: PUSH
26414: EMPTY
26415: LIST
26416: LIST
26417: PPUSH
26418: CALL_OW 69
26422: NOT
26423: AND
26424: PUSH
26425: LD_EXP 61
26429: PPUSH
26430: CALL_OW 302
26434: AND
26435: PUSH
26436: LD_INT 5
26438: PPUSH
26439: LD_INT 22
26441: PUSH
26442: LD_INT 1
26444: PUSH
26445: EMPTY
26446: LIST
26447: LIST
26448: PPUSH
26449: CALL_OW 70
26453: AND
26454: IFFALSE 27198
26456: GO 26458
26458: DISABLE
26459: LD_INT 0
26461: PPUSH
26462: PPUSH
26463: PPUSH
// begin legionDestroyed := true ;
26464: LD_ADDR_EXP 22
26468: PUSH
26469: LD_INT 1
26471: ST_TO_ADDR
// DialogueOn ;
26472: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
26476: LD_EXP 40
26480: PPUSH
26481: LD_STRING D13-JMM-1
26483: PPUSH
26484: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
26488: LD_EXP 61
26492: PPUSH
26493: LD_STRING D13-Kurt-1
26495: PPUSH
26496: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
26500: LD_EXP 40
26504: PPUSH
26505: LD_STRING D13-JMM-2
26507: PPUSH
26508: CALL_OW 88
// if FakeInfo then
26512: LD_EXP 12
26516: IFFALSE 26536
// begin Say ( Kurt , D13-Kurt-2 ) ;
26518: LD_EXP 61
26522: PPUSH
26523: LD_STRING D13-Kurt-2
26525: PPUSH
26526: CALL_OW 88
// DialogueOff ;
26530: CALL_OW 7
// exit ;
26534: GO 27198
// end ; if not KurtStatus then
26536: LD_EXP 3
26540: NOT
26541: IFFALSE 26557
// Say ( Kurt , D13-Kurt-2b ) else
26543: LD_EXP 61
26547: PPUSH
26548: LD_STRING D13-Kurt-2b
26550: PPUSH
26551: CALL_OW 88
26555: GO 26569
// Say ( Kurt , D13-Kurt-2a ) ;
26557: LD_EXP 61
26561: PPUSH
26562: LD_STRING D13-Kurt-2a
26564: PPUSH
26565: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
26569: LD_EXP 40
26573: PPUSH
26574: LD_STRING D13-JMM-3
26576: PPUSH
26577: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
26581: LD_EXP 61
26585: PPUSH
26586: LD_STRING D13-Kurt-3
26588: PPUSH
26589: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
26593: LD_EXP 40
26597: PPUSH
26598: LD_STRING D13-JMM-4
26600: PPUSH
26601: CALL_OW 88
// DialogueOff ;
26605: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
26609: LD_STRING MlegionOut
26611: PPUSH
26612: CALL_OW 337
// MC_Kill ( 3 ) ;
26616: LD_INT 3
26618: PPUSH
26619: CALL 36920 0 1
// KillUnit ( Kozlov ) ;
26623: LD_EXP 62
26627: PPUSH
26628: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
26632: LD_ADDR_VAR 0 1
26636: PUSH
26637: LD_INT 22
26639: PUSH
26640: LD_INT 8
26642: PUSH
26643: EMPTY
26644: LIST
26645: LIST
26646: PUSH
26647: LD_INT 23
26649: PUSH
26650: LD_INT 3
26652: PUSH
26653: EMPTY
26654: LIST
26655: LIST
26656: PUSH
26657: LD_INT 3
26659: PUSH
26660: LD_INT 21
26662: PUSH
26663: LD_INT 33
26665: PUSH
26666: EMPTY
26667: LIST
26668: LIST
26669: PUSH
26670: EMPTY
26671: LIST
26672: LIST
26673: PUSH
26674: EMPTY
26675: LIST
26676: LIST
26677: LIST
26678: PPUSH
26679: CALL_OW 69
26683: PUSH
26684: FOR_IN
26685: IFFALSE 26698
// KillUnit ( i ) ;
26687: LD_VAR 0 1
26691: PPUSH
26692: CALL_OW 66
26696: GO 26684
26698: POP
26699: POP
// ChangeSideFog ( 8 , 1 ) ;
26700: LD_INT 8
26702: PPUSH
26703: LD_INT 1
26705: PPUSH
26706: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
26710: LD_ADDR_VAR 0 2
26714: PUSH
26715: LD_INT 22
26717: PUSH
26718: LD_INT 8
26720: PUSH
26721: EMPTY
26722: LIST
26723: LIST
26724: PUSH
26725: LD_INT 21
26727: PUSH
26728: LD_INT 1
26730: PUSH
26731: EMPTY
26732: LIST
26733: LIST
26734: PUSH
26735: EMPTY
26736: LIST
26737: LIST
26738: PPUSH
26739: CALL_OW 69
26743: PUSH
26744: LD_EXP 62
26748: PUSH
26749: LD_EXP 61
26753: PUSH
26754: EMPTY
26755: LIST
26756: LIST
26757: DIFF
26758: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
26759: LD_VAR 0 2
26763: PUSH
26764: LD_INT 6
26766: PUSH
26767: LD_INT 5
26769: PUSH
26770: LD_INT 4
26772: PUSH
26773: LD_INT 3
26775: PUSH
26776: EMPTY
26777: LIST
26778: LIST
26779: LIST
26780: LIST
26781: PUSH
26782: LD_OWVAR 67
26786: ARRAY
26787: GREATEREQUAL
26788: IFFALSE 26940
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
26790: LD_ADDR_VAR 0 3
26794: PUSH
26795: LD_INT 6
26797: PUSH
26798: LD_INT 5
26800: PUSH
26801: LD_INT 4
26803: PUSH
26804: LD_INT 3
26806: PUSH
26807: EMPTY
26808: LIST
26809: LIST
26810: LIST
26811: LIST
26812: PUSH
26813: LD_OWVAR 67
26817: ARRAY
26818: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
26819: LD_ADDR_VAR 0 1
26823: PUSH
26824: DOUBLE
26825: LD_VAR 0 2
26829: PUSH
26830: LD_VAR 0 3
26834: PUSH
26835: LD_INT 1
26837: PLUS
26838: MINUS
26839: INC
26840: ST_TO_ADDR
26841: LD_INT 1
26843: PUSH
26844: FOR_DOWNTO
26845: IFFALSE 26936
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
26847: LD_ADDR_EXP 38
26851: PUSH
26852: LD_EXP 38
26856: PUSH
26857: LD_VAR 0 2
26861: PUSH
26862: LD_VAR 0 1
26866: ARRAY
26867: ADD
26868: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
26869: LD_VAR 0 2
26873: PUSH
26874: LD_VAR 0 1
26878: ARRAY
26879: PPUSH
26880: CALL_OW 310
26884: IFFALSE 26901
// ComExit ( tmp [ i ] ) ;
26886: LD_VAR 0 2
26890: PUSH
26891: LD_VAR 0 1
26895: ARRAY
26896: PPUSH
26897: CALL 105182 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
26901: LD_VAR 0 2
26905: PUSH
26906: LD_VAR 0 1
26910: ARRAY
26911: PPUSH
26912: LD_INT 34
26914: PUSH
26915: LD_INT 0
26917: PPUSH
26918: LD_INT 6
26920: PPUSH
26921: CALL_OW 12
26925: PLUS
26926: PPUSH
26927: LD_INT 1
26929: PPUSH
26930: CALL_OW 171
// end ;
26934: GO 26844
26936: POP
26937: POP
// end else
26938: GO 26950
// x := tmp ;
26940: LD_ADDR_VAR 0 3
26944: PUSH
26945: LD_VAR 0 2
26949: ST_TO_ADDR
// for i := tmp downto tmp - x do
26950: LD_ADDR_VAR 0 1
26954: PUSH
26955: DOUBLE
26956: LD_VAR 0 2
26960: INC
26961: ST_TO_ADDR
26962: LD_VAR 0 2
26966: PUSH
26967: LD_VAR 0 3
26971: MINUS
26972: PUSH
26973: FOR_DOWNTO
26974: IFFALSE 27028
// begin if IsInUnit ( tmp [ i ] ) then
26976: LD_VAR 0 2
26980: PUSH
26981: LD_VAR 0 1
26985: ARRAY
26986: PPUSH
26987: CALL_OW 310
26991: IFFALSE 27008
// ComExit ( tmp [ i ] ) ;
26993: LD_VAR 0 2
26997: PUSH
26998: LD_VAR 0 1
27002: ARRAY
27003: PPUSH
27004: CALL 105182 0 1
// SetSide ( tmp [ i ] , 1 ) ;
27008: LD_VAR 0 2
27012: PUSH
27013: LD_VAR 0 1
27017: ARRAY
27018: PPUSH
27019: LD_INT 1
27021: PPUSH
27022: CALL_OW 235
// end ;
27026: GO 26973
27028: POP
27029: POP
// wait ( 0 0$0.3 ) ;
27030: LD_INT 10
27032: PPUSH
27033: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
27037: LD_ADDR_VAR 0 1
27041: PUSH
27042: LD_INT 22
27044: PUSH
27045: LD_INT 8
27047: PUSH
27048: EMPTY
27049: LIST
27050: LIST
27051: PUSH
27052: LD_INT 21
27054: PUSH
27055: LD_INT 2
27057: PUSH
27058: EMPTY
27059: LIST
27060: LIST
27061: PUSH
27062: EMPTY
27063: LIST
27064: LIST
27065: PPUSH
27066: CALL_OW 69
27070: PUSH
27071: FOR_IN
27072: IFFALSE 27085
// KillUnit ( i ) ;
27074: LD_VAR 0 1
27078: PPUSH
27079: CALL_OW 66
27083: GO 27071
27085: POP
27086: POP
// SetSide ( Kurt , 1 ) ;
27087: LD_EXP 61
27091: PPUSH
27092: LD_INT 1
27094: PPUSH
27095: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
27099: LD_INT 22
27101: PUSH
27102: LD_INT 8
27104: PUSH
27105: EMPTY
27106: LIST
27107: LIST
27108: PUSH
27109: LD_INT 21
27111: PUSH
27112: LD_INT 3
27114: PUSH
27115: EMPTY
27116: LIST
27117: LIST
27118: PUSH
27119: EMPTY
27120: LIST
27121: LIST
27122: PPUSH
27123: CALL_OW 69
27127: PPUSH
27128: LD_INT 1
27130: PPUSH
27131: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
27135: LD_INT 8
27137: PPUSH
27138: LD_INT 1
27140: PPUSH
27141: LD_INT 1
27143: PPUSH
27144: LD_INT 1
27146: PPUSH
27147: CALL_OW 80
// wait ( 1 1$20 ) ;
27151: LD_INT 2800
27153: PPUSH
27154: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
27158: LD_EXP 63
27162: PPUSH
27163: LD_INT 37
27165: PPUSH
27166: LD_INT 1
27168: PPUSH
27169: LD_INT 0
27171: PPUSH
27172: CALL_OW 48
// wait ( 0 0$1 ) ;
27176: LD_INT 35
27178: PPUSH
27179: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
27183: LD_EXP 63
27187: PPUSH
27188: LD_INT 60
27190: PPUSH
27191: LD_INT 95
27193: PPUSH
27194: CALL_OW 111
// end ;
27198: PPOPN 3
27200: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
27201: LD_EXP 22
27205: NOT
27206: PUSH
27207: LD_INT 22
27209: PUSH
27210: LD_INT 8
27212: PUSH
27213: EMPTY
27214: LIST
27215: LIST
27216: PUSH
27217: LD_INT 21
27219: PUSH
27220: LD_INT 1
27222: PUSH
27223: EMPTY
27224: LIST
27225: LIST
27226: PUSH
27227: EMPTY
27228: LIST
27229: LIST
27230: PPUSH
27231: CALL_OW 69
27235: PUSH
27236: LD_INT 0
27238: EQUAL
27239: AND
27240: IFFALSE 27260
27242: GO 27244
27244: DISABLE
// begin legionDestroyed := true ;
27245: LD_ADDR_EXP 22
27249: PUSH
27250: LD_INT 1
27252: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
27253: LD_STRING MlegionOut
27255: PPUSH
27256: CALL_OW 337
// end ;
27260: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
27261: LD_EXP 38
27265: IFFALSE 27340
27267: GO 27269
27269: DISABLE
27270: LD_INT 0
27272: PPUSH
// begin enable ;
27273: ENABLE
// for i in legionEscapeUnits do
27274: LD_ADDR_VAR 0 1
27278: PUSH
27279: LD_EXP 38
27283: PUSH
27284: FOR_IN
27285: IFFALSE 27338
// begin if IsInArea ( i , legionEscapeArea ) then
27287: LD_VAR 0 1
27291: PPUSH
27292: LD_INT 31
27294: PPUSH
27295: CALL_OW 308
27299: IFFALSE 27312
// RemoveUnit ( i ) else
27301: LD_VAR 0 1
27305: PPUSH
27306: CALL_OW 64
27310: GO 27336
// if not HasTask ( i ) then
27312: LD_VAR 0 1
27316: PPUSH
27317: CALL_OW 314
27321: NOT
27322: IFFALSE 27336
// ComMoveToArea ( i , legionEscapeArea ) ;
27324: LD_VAR 0 1
27328: PPUSH
27329: LD_INT 31
27331: PPUSH
27332: CALL_OW 113
// end ;
27336: GO 27284
27338: POP
27339: POP
// end ;
27340: PPOPN 1
27342: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
27343: LD_INT 1
27345: PPUSH
27346: LD_EXP 63
27350: PPUSH
27351: CALL_OW 292
27355: IFFALSE 27653
27357: GO 27359
27359: DISABLE
27360: LD_INT 0
27362: PPUSH
// begin wait ( 0 0$2 ) ;
27363: LD_INT 70
27365: PPUSH
27366: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27370: LD_EXP 63
27374: PPUSH
27375: CALL_OW 87
// DialogueOn ;
27379: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
27383: LD_EXP 40
27387: PPUSH
27388: LD_STRING D14-JMM-1
27390: PPUSH
27391: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
27395: LD_EXP 63
27399: PPUSH
27400: LD_STRING D14-Friend-1
27402: PPUSH
27403: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
27407: LD_EXP 40
27411: PPUSH
27412: LD_STRING D14-JMM-2
27414: PPUSH
27415: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
27419: LD_EXP 63
27423: PPUSH
27424: LD_STRING D14-Friend-2
27426: PPUSH
27427: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
27431: LD_EXP 40
27435: PPUSH
27436: LD_STRING D14-JMM-3
27438: PPUSH
27439: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
27443: LD_EXP 63
27447: PPUSH
27448: LD_STRING D14-Friend-3
27450: PPUSH
27451: CALL_OW 88
// DialogueOff ;
27455: CALL_OW 7
// dec = Query ( Q14 ) ;
27459: LD_ADDR_VAR 0 1
27463: PUSH
27464: LD_STRING Q14
27466: PPUSH
27467: CALL_OW 97
27471: ST_TO_ADDR
// if dec = 1 then
27472: LD_VAR 0 1
27476: PUSH
27477: LD_INT 1
27479: EQUAL
27480: IFFALSE 27514
// begin DialogueOn ;
27482: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
27486: LD_EXP 40
27490: PPUSH
27491: LD_STRING D14a-JMM-1
27493: PPUSH
27494: CALL_OW 88
// DialogueOff ;
27498: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27502: LD_EXP 63
27506: PPUSH
27507: LD_INT 1
27509: PPUSH
27510: CALL_OW 235
// end ; if dec = 2 then
27514: LD_VAR 0 1
27518: PUSH
27519: LD_INT 2
27521: EQUAL
27522: IFFALSE 27575
// begin DialogueOn ;
27524: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
27528: LD_EXP 40
27532: PPUSH
27533: LD_STRING D14b-JMM-1
27535: PPUSH
27536: CALL_OW 88
// DialogueOff ;
27540: CALL_OW 7
// wait ( 0 0$1 ) ;
27544: LD_INT 35
27546: PPUSH
27547: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
27551: LD_EXP 63
27555: PPUSH
27556: LD_INT 9
27558: PPUSH
27559: LD_INT 2
27561: PPUSH
27562: CALL_OW 111
// AddComHold ( Friend ) ;
27566: LD_EXP 63
27570: PPUSH
27571: CALL_OW 200
// end ; if dec = 3 then
27575: LD_VAR 0 1
27579: PUSH
27580: LD_INT 3
27582: EQUAL
27583: IFFALSE 27653
// begin DialogueOn ;
27585: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
27589: LD_EXP 40
27593: PPUSH
27594: LD_STRING D14c-JMM-1
27596: PPUSH
27597: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
27601: LD_EXP 63
27605: PPUSH
27606: LD_STRING D14c-Friend-1
27608: PPUSH
27609: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
27613: LD_EXP 40
27617: PPUSH
27618: LD_STRING D14c-JMM-2
27620: PPUSH
27621: CALL_OW 88
// DialogueOff ;
27625: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
27629: LD_EXP 63
27633: PPUSH
27634: LD_INT 9
27636: PPUSH
27637: LD_INT 2
27639: PPUSH
27640: CALL_OW 111
// AddComHold ( Friend ) ;
27644: LD_EXP 63
27648: PPUSH
27649: CALL_OW 200
// end ; end ;
27653: PPOPN 1
27655: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
27656: LD_INT 9
27658: PPUSH
27659: LD_INT 2
27661: PPUSH
27662: CALL_OW 428
27666: PUSH
27667: LD_EXP 63
27671: EQUAL
27672: PUSH
27673: LD_EXP 63
27677: PPUSH
27678: CALL_OW 255
27682: PUSH
27683: LD_INT 8
27685: EQUAL
27686: AND
27687: IFFALSE 27701
27689: GO 27691
27691: DISABLE
// RemoveUnit ( Friend ) ;
27692: LD_EXP 63
27696: PPUSH
27697: CALL_OW 64
27701: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
27702: LD_EXP 14
27706: PUSH
27707: LD_INT 31500
27709: GREATEREQUAL
27710: PUSH
27711: LD_EXP 7
27715: AND
27716: PUSH
27717: LD_EXP 2
27721: AND
27722: IFFALSE 28152
27724: GO 27726
27726: DISABLE
27727: LD_INT 0
27729: PPUSH
27730: PPUSH
27731: PPUSH
// begin missionStage := 7 ;
27732: LD_ADDR_EXP 15
27736: PUSH
27737: LD_INT 7
27739: ST_TO_ADDR
// uc_side = 1 ;
27740: LD_ADDR_OWVAR 20
27744: PUSH
27745: LD_INT 1
27747: ST_TO_ADDR
// uc_nation = 1 ;
27748: LD_ADDR_OWVAR 21
27752: PUSH
27753: LD_INT 1
27755: ST_TO_ADDR
// for i = 1 to 5 do
27756: LD_ADDR_VAR 0 1
27760: PUSH
27761: DOUBLE
27762: LD_INT 1
27764: DEC
27765: ST_TO_ADDR
27766: LD_INT 5
27768: PUSH
27769: FOR_TO
27770: IFFALSE 27866
// begin vc_engine = 3 ;
27772: LD_ADDR_OWVAR 39
27776: PUSH
27777: LD_INT 3
27779: ST_TO_ADDR
// vc_control = 3 ;
27780: LD_ADDR_OWVAR 38
27784: PUSH
27785: LD_INT 3
27787: ST_TO_ADDR
// vc_chassis = 3 ;
27788: LD_ADDR_OWVAR 37
27792: PUSH
27793: LD_INT 3
27795: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
27796: LD_ADDR_OWVAR 40
27800: PUSH
27801: LD_INT 5
27803: PUSH
27804: LD_INT 9
27806: PUSH
27807: LD_INT 7
27809: PUSH
27810: EMPTY
27811: LIST
27812: LIST
27813: LIST
27814: PUSH
27815: LD_INT 1
27817: PPUSH
27818: LD_INT 3
27820: PPUSH
27821: CALL_OW 12
27825: ARRAY
27826: ST_TO_ADDR
// veh = CreateVehicle ;
27827: LD_ADDR_VAR 0 2
27831: PUSH
27832: CALL_OW 45
27836: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
27837: LD_VAR 0 2
27841: PPUSH
27842: LD_INT 1
27844: PPUSH
27845: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
27849: LD_VAR 0 2
27853: PPUSH
27854: LD_INT 19
27856: PPUSH
27857: LD_INT 0
27859: PPUSH
27860: CALL_OW 49
// end ;
27864: GO 27769
27866: POP
27867: POP
// vc_engine = 3 ;
27868: LD_ADDR_OWVAR 39
27872: PUSH
27873: LD_INT 3
27875: ST_TO_ADDR
// vc_control = 1 ;
27876: LD_ADDR_OWVAR 38
27880: PUSH
27881: LD_INT 1
27883: ST_TO_ADDR
// vc_chassis = 3 ;
27884: LD_ADDR_OWVAR 37
27888: PUSH
27889: LD_INT 3
27891: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
27892: LD_ADDR_OWVAR 40
27896: PUSH
27897: LD_INT 5
27899: PUSH
27900: LD_INT 9
27902: PUSH
27903: LD_INT 7
27905: PUSH
27906: EMPTY
27907: LIST
27908: LIST
27909: LIST
27910: PUSH
27911: LD_INT 1
27913: PPUSH
27914: LD_INT 3
27916: PPUSH
27917: CALL_OW 12
27921: ARRAY
27922: ST_TO_ADDR
// vehG = CreateVehicle ;
27923: LD_ADDR_VAR 0 3
27927: PUSH
27928: CALL_OW 45
27932: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
27933: LD_VAR 0 3
27937: PPUSH
27938: LD_INT 1
27940: PPUSH
27941: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
27945: LD_VAR 0 3
27949: PPUSH
27950: LD_INT 19
27952: PPUSH
27953: LD_INT 0
27955: PPUSH
27956: CALL_OW 49
// if JMMGirl = 1 then
27960: LD_EXP 7
27964: PUSH
27965: LD_INT 1
27967: EQUAL
27968: IFFALSE 28024
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
27970: LD_ADDR_EXP 41
27974: PUSH
27975: LD_STRING Joan
27977: PPUSH
27978: LD_INT 1
27980: PPUSH
27981: LD_STRING 14_
27983: PPUSH
27984: CALL 67335 0 3
27988: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
27989: LD_EXP 41
27993: PPUSH
27994: LD_VAR 0 3
27998: PPUSH
27999: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28003: LD_VAR 0 3
28007: PPUSH
28008: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
28012: LD_EXP 41
28016: PPUSH
28017: LD_STRING D10BW-Joan-1
28019: PPUSH
28020: CALL_OW 94
// end ; if JMMGirl = 2 then
28024: LD_EXP 7
28028: PUSH
28029: LD_INT 2
28031: EQUAL
28032: IFFALSE 28088
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
28034: LD_ADDR_EXP 43
28038: PUSH
28039: LD_STRING Lisa
28041: PPUSH
28042: LD_INT 1
28044: PPUSH
28045: LD_STRING 14_
28047: PPUSH
28048: CALL 67335 0 3
28052: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
28053: LD_EXP 43
28057: PPUSH
28058: LD_VAR 0 3
28062: PPUSH
28063: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28067: LD_VAR 0 3
28071: PPUSH
28072: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
28076: LD_EXP 43
28080: PPUSH
28081: LD_STRING D10BW-Lisa-1
28083: PPUSH
28084: CALL_OW 94
// end ; if JMMGirl = 3 then
28088: LD_EXP 7
28092: PUSH
28093: LD_INT 3
28095: EQUAL
28096: IFFALSE 28152
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
28098: LD_ADDR_EXP 55
28102: PUSH
28103: LD_STRING Connie
28105: PPUSH
28106: LD_INT 1
28108: PPUSH
28109: LD_STRING 14_
28111: PPUSH
28112: CALL 67335 0 3
28116: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
28117: LD_EXP 55
28121: PPUSH
28122: LD_VAR 0 3
28126: PPUSH
28127: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28131: LD_VAR 0 3
28135: PPUSH
28136: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
28140: LD_EXP 55
28144: PPUSH
28145: LD_STRING D10BW-Con-1
28147: PPUSH
28148: CALL_OW 94
// end ; end ;
28152: PPOPN 3
28154: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
28155: LD_EXP 14
28159: PUSH
28160: LD_INT 94500
28162: GREATEREQUAL
28163: IFFALSE 28575
28165: GO 28167
28167: DISABLE
28168: LD_INT 0
28170: PPUSH
28171: PPUSH
28172: PPUSH
// begin tmp := PrepareStevensSquad ;
28173: LD_ADDR_VAR 0 3
28177: PUSH
28178: CALL 2323 0 0
28182: ST_TO_ADDR
// if not tmp then
28183: LD_VAR 0 3
28187: NOT
28188: IFFALSE 28192
// exit ;
28190: GO 28575
// uc_side := 1 ;
28192: LD_ADDR_OWVAR 20
28196: PUSH
28197: LD_INT 1
28199: ST_TO_ADDR
// uc_nation := 1 ;
28200: LD_ADDR_OWVAR 21
28204: PUSH
28205: LD_INT 1
28207: ST_TO_ADDR
// for i in tmp do
28208: LD_ADDR_VAR 0 1
28212: PUSH
28213: LD_VAR 0 3
28217: PUSH
28218: FOR_IN
28219: IFFALSE 28316
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
28221: LD_INT 3
28223: PPUSH
28224: LD_INT 3
28226: PPUSH
28227: LD_INT 1
28229: PPUSH
28230: LD_INT 5
28232: PUSH
28233: LD_INT 9
28235: PUSH
28236: LD_INT 7
28238: PUSH
28239: EMPTY
28240: LIST
28241: LIST
28242: LIST
28243: PUSH
28244: LD_INT 1
28246: PPUSH
28247: LD_INT 3
28249: PPUSH
28250: CALL_OW 12
28254: ARRAY
28255: PPUSH
28256: LD_INT 40
28258: PPUSH
28259: CALL 72350 0 5
// veh := CreateVehicle ;
28263: LD_ADDR_VAR 0 2
28267: PUSH
28268: CALL_OW 45
28272: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
28273: LD_VAR 0 2
28277: PPUSH
28278: LD_INT 1
28280: PPUSH
28281: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
28285: LD_VAR 0 2
28289: PPUSH
28290: LD_INT 19
28292: PPUSH
28293: LD_INT 0
28295: PPUSH
28296: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
28300: LD_VAR 0 1
28304: PPUSH
28305: LD_VAR 0 2
28309: PPUSH
28310: CALL_OW 52
// end ;
28314: GO 28218
28316: POP
28317: POP
// missionStage := 8 ;
28318: LD_ADDR_EXP 15
28322: PUSH
28323: LD_INT 8
28325: ST_TO_ADDR
// DialogueOn ;
28326: CALL_OW 6
// if Stevens then
28330: LD_EXP 42
28334: IFFALSE 28448
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
28336: LD_EXP 42
28340: PPUSH
28341: CALL_OW 310
28345: PPUSH
28346: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
28350: LD_EXP 42
28354: PPUSH
28355: LD_STRING D8-Huck-1
28357: PPUSH
28358: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
28362: LD_EXP 40
28366: PPUSH
28367: LD_STRING D8-JMM-1
28369: PPUSH
28370: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
28374: LD_EXP 42
28378: PPUSH
28379: LD_STRING D8-Huck-2
28381: PPUSH
28382: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
28386: LD_EXP 40
28390: PPUSH
28391: LD_STRING D8-JMM-2
28393: PPUSH
28394: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
28398: LD_EXP 42
28402: PPUSH
28403: LD_STRING D8-Huck-3
28405: PPUSH
28406: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
28410: LD_EXP 40
28414: PPUSH
28415: LD_STRING D8-JMM-3
28417: PPUSH
28418: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
28422: LD_EXP 42
28426: PPUSH
28427: LD_STRING D8-Huck-4
28429: PPUSH
28430: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
28434: LD_EXP 40
28438: PPUSH
28439: LD_STRING D8-JMM-4
28441: PPUSH
28442: CALL_OW 88
// end else
28446: GO 28558
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
28448: LD_EXP 56
28452: PPUSH
28453: CALL_OW 310
28457: PPUSH
28458: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
28462: LD_EXP 56
28466: PPUSH
28467: LD_STRING D8-Huck-1
28469: PPUSH
28470: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
28474: LD_EXP 40
28478: PPUSH
28479: LD_STRING D8-JMM-1a
28481: PPUSH
28482: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
28486: LD_EXP 56
28490: PPUSH
28491: LD_STRING D8-Huck-2
28493: PPUSH
28494: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
28498: LD_EXP 40
28502: PPUSH
28503: LD_STRING D8-JMM-2
28505: PPUSH
28506: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
28510: LD_EXP 56
28514: PPUSH
28515: LD_STRING D8-Huck-3
28517: PPUSH
28518: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
28522: LD_EXP 40
28526: PPUSH
28527: LD_STRING D8-JMM-3
28529: PPUSH
28530: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
28534: LD_EXP 56
28538: PPUSH
28539: LD_STRING D8-Huck-4
28541: PPUSH
28542: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
28546: LD_EXP 40
28550: PPUSH
28551: LD_STRING D8-JMM-4
28553: PPUSH
28554: CALL_OW 88
// end ; DialogueOff ;
28558: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
28562: LD_INT 25
28564: PPUSH
28565: LD_INT 1
28567: PPUSH
28568: LD_INT 1
28570: PPUSH
28571: CALL_OW 322
// end ;
28575: PPOPN 3
28577: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
28578: LD_INT 1
28580: PPUSH
28581: LD_EXP 72
28585: PPUSH
28586: CALL_OW 292
28590: IFFALSE 28841
28592: GO 28594
28594: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
28595: LD_EXP 72
28599: PPUSH
28600: CALL_OW 87
// DialogueOn ;
28604: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
28608: LD_EXP 40
28612: PPUSH
28613: LD_STRING D10nB-JMM-1
28615: PPUSH
28616: CALL_OW 88
// if BurlakStatus = 1 then
28620: LD_EXP 9
28624: PUSH
28625: LD_INT 1
28627: EQUAL
28628: IFFALSE 28642
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
28630: LD_EXP 71
28634: PPUSH
28635: LD_STRING D10nB-Vse-1a
28637: PPUSH
28638: CALL_OW 94
// end ; if BurlakStatus = 0 then
28642: LD_EXP 9
28646: PUSH
28647: LD_INT 0
28649: EQUAL
28650: IFFALSE 28664
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
28652: LD_EXP 71
28656: PPUSH
28657: LD_STRING D10nB-Vse-1
28659: PPUSH
28660: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
28664: LD_EXP 40
28668: PPUSH
28669: LD_STRING D10nB-JMM-2
28671: PPUSH
28672: CALL_OW 88
// if KappaStatus then
28676: LD_EXP 2
28680: IFFALSE 28694
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
28682: LD_EXP 71
28686: PPUSH
28687: LD_STRING D10nB-Vse-5a
28689: PPUSH
28690: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
28694: LD_EXP 2
28698: NOT
28699: PUSH
28700: LD_EXP 6
28704: PUSH
28705: LD_INT 0
28707: EQUAL
28708: AND
28709: IFFALSE 28837
// begin if JMMGirl = 1 then
28711: LD_EXP 7
28715: PUSH
28716: LD_INT 1
28718: EQUAL
28719: IFFALSE 28769
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
28721: LD_EXP 71
28725: PPUSH
28726: LD_STRING D10nB-Vse-2
28728: PPUSH
28729: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
28733: LD_EXP 40
28737: PPUSH
28738: LD_STRING D10nB-JMM-3
28740: PPUSH
28741: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
28745: LD_EXP 71
28749: PPUSH
28750: LD_STRING D10nB-Vse-3
28752: PPUSH
28753: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
28757: LD_EXP 40
28761: PPUSH
28762: LD_STRING D10nB-JMM-4
28764: PPUSH
28765: CALL_OW 88
// end ; if JMMGirl = 2 then
28769: LD_EXP 7
28773: PUSH
28774: LD_INT 2
28776: EQUAL
28777: IFFALSE 28803
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
28779: LD_EXP 71
28783: PPUSH
28784: LD_STRING D10nB-Vse-4
28786: PPUSH
28787: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
28791: LD_EXP 40
28795: PPUSH
28796: LD_STRING D10nB-JMM-5
28798: PPUSH
28799: CALL_OW 88
// end ; if JMMGirl = 3 then
28803: LD_EXP 7
28807: PUSH
28808: LD_INT 3
28810: EQUAL
28811: IFFALSE 28837
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
28813: LD_EXP 71
28817: PPUSH
28818: LD_STRING D10nB-Vse-5
28820: PPUSH
28821: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
28825: LD_EXP 40
28829: PPUSH
28830: LD_STRING D10nB-JMM-6
28832: PPUSH
28833: CALL_OW 88
// end ; end ; DialogueOff ;
28837: CALL_OW 7
// end ;
28841: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
28842: LD_EXP 14
28846: PUSH
28847: LD_INT 115500
28849: GREATEREQUAL
28850: IFFALSE 29226
28852: GO 28854
28854: DISABLE
28855: LD_INT 0
28857: PPUSH
// begin missionStage := 10 ;
28858: LD_ADDR_EXP 15
28862: PUSH
28863: LD_INT 10
28865: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28866: LD_ADDR_VAR 0 1
28870: PUSH
28871: LD_INT 22
28873: PUSH
28874: LD_INT 1
28876: PUSH
28877: EMPTY
28878: LIST
28879: LIST
28880: PUSH
28881: LD_INT 23
28883: PUSH
28884: LD_INT 1
28886: PUSH
28887: EMPTY
28888: LIST
28889: LIST
28890: PUSH
28891: LD_INT 26
28893: PUSH
28894: LD_INT 1
28896: PUSH
28897: EMPTY
28898: LIST
28899: LIST
28900: PUSH
28901: LD_INT 3
28903: PUSH
28904: LD_INT 25
28906: PUSH
28907: LD_INT 12
28909: PUSH
28910: EMPTY
28911: LIST
28912: LIST
28913: PUSH
28914: EMPTY
28915: LIST
28916: LIST
28917: PUSH
28918: LD_INT 3
28920: PUSH
28921: LD_INT 25
28923: PUSH
28924: LD_INT 16
28926: PUSH
28927: EMPTY
28928: LIST
28929: LIST
28930: PUSH
28931: EMPTY
28932: LIST
28933: LIST
28934: PUSH
28935: EMPTY
28936: LIST
28937: LIST
28938: LIST
28939: LIST
28940: LIST
28941: PPUSH
28942: CALL_OW 69
28946: PUSH
28947: LD_EXP 40
28951: PUSH
28952: LD_EXP 61
28956: PUSH
28957: LD_EXP 42
28961: PUSH
28962: LD_EXP 56
28966: PUSH
28967: LD_EXP 43
28971: PUSH
28972: LD_EXP 44
28976: PUSH
28977: LD_EXP 45
28981: PUSH
28982: LD_EXP 46
28986: PUSH
28987: LD_EXP 47
28991: PUSH
28992: LD_EXP 48
28996: PUSH
28997: LD_EXP 49
29001: PUSH
29002: LD_EXP 50
29006: PUSH
29007: LD_EXP 51
29011: PUSH
29012: LD_EXP 52
29016: PUSH
29017: LD_EXP 53
29021: PUSH
29022: LD_EXP 54
29026: PUSH
29027: EMPTY
29028: LIST
29029: LIST
29030: LIST
29031: LIST
29032: LIST
29033: LIST
29034: LIST
29035: LIST
29036: LIST
29037: LIST
29038: LIST
29039: LIST
29040: LIST
29041: LIST
29042: LIST
29043: LIST
29044: DIFF
29045: ST_TO_ADDR
// if not tmp and Brown then
29046: LD_VAR 0 1
29050: NOT
29051: PUSH
29052: LD_EXP 48
29056: AND
29057: IFFALSE 29072
// tmp := [ Brown ] ;
29059: LD_ADDR_VAR 0 1
29063: PUSH
29064: LD_EXP 48
29068: PUSH
29069: EMPTY
29070: LIST
29071: ST_TO_ADDR
// DialogueOn ;
29072: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
29076: LD_VAR 0 1
29080: PUSH
29081: LD_INT 1
29083: ARRAY
29084: PPUSH
29085: LD_STRING D11-Sol1-1
29087: PPUSH
29088: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
29092: LD_EXP 65
29096: PPUSH
29097: LD_STRING D11-Pla-1
29099: PPUSH
29100: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
29104: LD_EXP 66
29108: PPUSH
29109: LD_STRING D11-Kov-1
29111: PPUSH
29112: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
29116: LD_EXP 65
29120: PPUSH
29121: LD_STRING D11-Pla-2
29123: PPUSH
29124: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
29128: LD_VAR 0 1
29132: PUSH
29133: LD_INT 1
29135: ARRAY
29136: PPUSH
29137: LD_STRING D11-Sol1-2
29139: PPUSH
29140: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
29144: LD_EXP 40
29148: PPUSH
29149: LD_STRING D11-JMM-2
29151: PPUSH
29152: CALL_OW 88
// DialogueOff ;
29156: CALL_OW 7
// allowBehemothConstruct := true ;
29160: LD_ADDR_EXP 25
29164: PUSH
29165: LD_INT 1
29167: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
29168: LD_STRING M4
29170: PPUSH
29171: CALL_OW 337
// BuildBehemoths ;
29175: CALL 7787 0 0
// repeat wait ( 15 15$00 ) ;
29179: LD_INT 31500
29181: PPUSH
29182: CALL_OW 67
// if behemothDestroyedBeforeFinish then
29186: LD_EXP 27
29190: IFFALSE 29194
// break ;
29192: GO 29226
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
29194: LD_INT 267
29196: PPUSH
29197: CALL_OW 274
29201: PPUSH
29202: LD_INT 1
29204: PPUSH
29205: CALL_OW 275
29209: PUSH
29210: LD_INT 1000
29212: GREATEREQUAL
29213: IFFALSE 29219
// BuildBehemoths ;
29215: CALL 7787 0 0
// until not behemothBuilders ;
29219: LD_EXP 74
29223: NOT
29224: IFFALSE 29179
// end ;
29226: PPOPN 1
29228: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
29229: LD_EXP 74
29233: NOT
29234: PUSH
29235: LD_EXP 28
29239: NOT
29240: AND
29241: PUSH
29242: LD_EXP 25
29246: AND
29247: IFFALSE 29267
29249: GO 29251
29251: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
29252: LD_STRING M4a
29254: PPUSH
29255: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
29259: LD_ADDR_EXP 27
29263: PUSH
29264: LD_INT 1
29266: ST_TO_ADDR
// end ;
29267: END
// every 0 0$1 trigger behemothDone do
29268: LD_EXP 28
29272: IFFALSE 29284
29274: GO 29276
29276: DISABLE
// ChangeMissionObjectives ( M4b ) ;
29277: LD_STRING M4b
29279: PPUSH
29280: CALL_OW 337
29284: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
29285: LD_EXP 29
29289: NOT
29290: IFFALSE 29486
29292: GO 29294
29294: DISABLE
29295: LD_INT 0
29297: PPUSH
29298: PPUSH
// begin enable ;
29299: ENABLE
// tmp := GetBehemoths ( 3 ) ;
29300: LD_ADDR_VAR 0 1
29304: PUSH
29305: LD_INT 3
29307: PPUSH
29308: CALL 104845 0 1
29312: ST_TO_ADDR
// if not tmp and not behemothDone then
29313: LD_VAR 0 1
29317: NOT
29318: PUSH
29319: LD_EXP 28
29323: NOT
29324: AND
29325: IFFALSE 29361
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
29327: LD_ADDR_VAR 0 1
29331: PUSH
29332: LD_INT 22
29334: PUSH
29335: LD_INT 3
29337: PUSH
29338: EMPTY
29339: LIST
29340: LIST
29341: PUSH
29342: LD_INT 30
29344: PUSH
29345: LD_INT 37
29347: PUSH
29348: EMPTY
29349: LIST
29350: LIST
29351: PUSH
29352: EMPTY
29353: LIST
29354: LIST
29355: PPUSH
29356: CALL_OW 69
29360: ST_TO_ADDR
// if not tmp then
29361: LD_VAR 0 1
29365: NOT
29366: IFFALSE 29370
// exit ;
29368: GO 29486
// for i in tmp do
29370: LD_ADDR_VAR 0 2
29374: PUSH
29375: LD_VAR 0 1
29379: PUSH
29380: FOR_IN
29381: IFFALSE 29484
// if See ( 1 , i ) then
29383: LD_INT 1
29385: PPUSH
29386: LD_VAR 0 2
29390: PPUSH
29391: CALL_OW 292
29395: IFFALSE 29482
// begin if GetType ( i ) = unit_building then
29397: LD_VAR 0 2
29401: PPUSH
29402: CALL_OW 247
29406: PUSH
29407: LD_INT 3
29409: EQUAL
29410: IFFALSE 29448
// begin disable ;
29412: DISABLE
// CenterNowOnUnits ( i ) ;
29413: LD_VAR 0 2
29417: PPUSH
29418: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
29422: LD_EXP 40
29426: PPUSH
29427: LD_STRING D17a-JMM-1
29429: PPUSH
29430: CALL_OW 88
// seeBehemoth := true ;
29434: LD_ADDR_EXP 29
29438: PUSH
29439: LD_INT 1
29441: ST_TO_ADDR
// exit ;
29442: POP
29443: POP
29444: GO 29486
// end else
29446: GO 29482
// begin disable ;
29448: DISABLE
// CenterNowOnUnits ( i ) ;
29449: LD_VAR 0 2
29453: PPUSH
29454: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
29458: LD_EXP 40
29462: PPUSH
29463: LD_STRING D17b-JMM-1
29465: PPUSH
29466: CALL_OW 88
// seeBehemoth := true ;
29470: LD_ADDR_EXP 29
29474: PUSH
29475: LD_INT 1
29477: ST_TO_ADDR
// exit ;
29478: POP
29479: POP
29480: GO 29486
// end ; end ;
29482: GO 29380
29484: POP
29485: POP
// end ;
29486: PPOPN 2
29488: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
29489: LD_EXP 14
29493: PUSH
29494: LD_INT 123200
29496: GREATEREQUAL
29497: IFFALSE 30697
29499: GO 29501
29501: DISABLE
29502: LD_INT 0
29504: PPUSH
29505: PPUSH
29506: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
29507: LD_INT 2
29509: PPUSH
29510: LD_INT 23
29512: PUSH
29513: LD_INT 3
29515: PUSH
29516: LD_INT 3
29518: PUSH
29519: LD_INT 48
29521: PUSH
29522: EMPTY
29523: LIST
29524: LIST
29525: LIST
29526: LIST
29527: PUSH
29528: EMPTY
29529: LIST
29530: PPUSH
29531: CALL 60947 0 2
// repeat wait ( 0 0$1 ) ;
29535: LD_INT 35
29537: PPUSH
29538: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
29542: LD_INT 22
29544: PUSH
29545: LD_INT 3
29547: PUSH
29548: EMPTY
29549: LIST
29550: LIST
29551: PUSH
29552: LD_INT 34
29554: PUSH
29555: LD_INT 48
29557: PUSH
29558: EMPTY
29559: LIST
29560: LIST
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PPUSH
29566: CALL_OW 69
29570: IFFALSE 29535
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
29572: LD_ADDR_VAR 0 1
29576: PUSH
29577: LD_INT 22
29579: PUSH
29580: LD_INT 3
29582: PUSH
29583: EMPTY
29584: LIST
29585: LIST
29586: PUSH
29587: LD_INT 34
29589: PUSH
29590: LD_INT 48
29592: PUSH
29593: EMPTY
29594: LIST
29595: LIST
29596: PUSH
29597: EMPTY
29598: LIST
29599: LIST
29600: PPUSH
29601: CALL_OW 69
29605: PUSH
29606: LD_INT 1
29608: ARRAY
29609: ST_TO_ADDR
// missionStage := 12 ;
29610: LD_ADDR_EXP 15
29614: PUSH
29615: LD_INT 12
29617: ST_TO_ADDR
// platonovHasBomb := true ;
29618: LD_ADDR_EXP 30
29622: PUSH
29623: LD_INT 1
29625: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
29626: LD_VAR 0 1
29630: PPUSH
29631: LD_INT 181
29633: PPUSH
29634: LD_INT 86
29636: PPUSH
29637: CALL_OW 171
// AddComHold ( bomb ) ;
29641: LD_VAR 0 1
29645: PPUSH
29646: CALL_OW 200
// wait ( 0 0$10 ) ;
29650: LD_INT 350
29652: PPUSH
29653: CALL_OW 67
// DialogueOn ;
29657: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
29661: LD_EXP 65
29665: PPUSH
29666: LD_STRING D15-Pla-1
29668: PPUSH
29669: CALL_OW 94
// dec = Query ( Q15a ) ;
29673: LD_ADDR_VAR 0 2
29677: PUSH
29678: LD_STRING Q15a
29680: PPUSH
29681: CALL_OW 97
29685: ST_TO_ADDR
// if dec = 1 then
29686: LD_VAR 0 2
29690: PUSH
29691: LD_INT 1
29693: EQUAL
29694: IFFALSE 29717
// begin Say ( JMM , D15a-JMM-1 ) ;
29696: LD_EXP 40
29700: PPUSH
29701: LD_STRING D15a-JMM-1
29703: PPUSH
29704: CALL_OW 88
// YouLost ( Surrender ) ;
29708: LD_STRING Surrender
29710: PPUSH
29711: CALL_OW 104
// exit ;
29715: GO 30697
// end ; if dec = 2 then
29717: LD_VAR 0 2
29721: PUSH
29722: LD_INT 2
29724: EQUAL
29725: IFFALSE 29794
// begin Say ( JMM , D15b-JMM-1 ) ;
29727: LD_EXP 40
29731: PPUSH
29732: LD_STRING D15b-JMM-1
29734: PPUSH
29735: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
29739: LD_EXP 65
29743: PPUSH
29744: LD_STRING D15b-Pla-1
29746: PPUSH
29747: CALL_OW 94
// DialogueOff ;
29751: CALL_OW 7
// wait ( 3 3$00 ) ;
29755: LD_INT 6300
29757: PPUSH
29758: CALL_OW 67
// DialogueOn ;
29762: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
29766: LD_EXP 40
29770: PPUSH
29771: LD_STRING D15d-JMM-1a
29773: PPUSH
29774: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
29778: LD_EXP 65
29782: PPUSH
29783: LD_STRING D15d-Pla-1
29785: PPUSH
29786: CALL_OW 94
// DialogueOff ;
29790: CALL_OW 7
// end ; if dec = 3 then
29794: LD_VAR 0 2
29798: PUSH
29799: LD_INT 3
29801: EQUAL
29802: IFFALSE 29856
// begin Say ( JMM , D15c-JMM-1 ) ;
29804: LD_EXP 40
29808: PPUSH
29809: LD_STRING D15c-JMM-1
29811: PPUSH
29812: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
29816: LD_EXP 65
29820: PPUSH
29821: LD_STRING D15c-Pla-1
29823: PPUSH
29824: CALL_OW 94
// DialogueOff ;
29828: CALL_OW 7
// wait ( 0 0$15 ) ;
29832: LD_INT 525
29834: PPUSH
29835: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
29839: LD_VAR 0 1
29843: PPUSH
29844: LD_INT 60
29846: PPUSH
29847: LD_INT 95
29849: PPUSH
29850: CALL_OW 116
// exit ;
29854: GO 30697
// end ; if dec = 4 then
29856: LD_VAR 0 2
29860: PUSH
29861: LD_INT 4
29863: EQUAL
29864: IFFALSE 29894
// begin Say ( JMM , D15d-JMM-1 ) ;
29866: LD_EXP 40
29870: PPUSH
29871: LD_STRING D15d-JMM-1
29873: PPUSH
29874: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
29878: LD_EXP 65
29882: PPUSH
29883: LD_STRING D15d-Pla-1
29885: PPUSH
29886: CALL_OW 94
// DialogueOff ;
29890: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29894: LD_EXP 63
29898: PPUSH
29899: CALL_OW 302
29903: PUSH
29904: LD_EXP 63
29908: PPUSH
29909: CALL_OW 255
29913: PUSH
29914: LD_INT 1
29916: EQUAL
29917: AND
29918: PUSH
29919: LD_INT 22
29921: PUSH
29922: LD_INT 1
29924: PUSH
29925: EMPTY
29926: LIST
29927: LIST
29928: PUSH
29929: LD_INT 34
29931: PUSH
29932: LD_INT 8
29934: PUSH
29935: EMPTY
29936: LIST
29937: LIST
29938: PUSH
29939: EMPTY
29940: LIST
29941: LIST
29942: PPUSH
29943: CALL_OW 69
29947: NOT
29948: AND
29949: IFFALSE 30598
// begin SetSide ( Friend , 8 ) ;
29951: LD_EXP 63
29955: PPUSH
29956: LD_INT 8
29958: PPUSH
29959: CALL_OW 235
// if IsInUnit ( Friend ) then
29963: LD_EXP 63
29967: PPUSH
29968: CALL_OW 310
29972: IFFALSE 29983
// ComExitBuilding ( Friend ) ;
29974: LD_EXP 63
29978: PPUSH
29979: CALL_OW 122
// if IsDriver ( Friend ) then
29983: LD_EXP 63
29987: PPUSH
29988: CALL 102393 0 1
29992: IFFALSE 30003
// ComExitVehicle ( Friend ) ;
29994: LD_EXP 63
29998: PPUSH
29999: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
30003: LD_EXP 63
30007: PPUSH
30008: LD_INT 9
30010: PPUSH
30011: LD_INT 2
30013: PPUSH
30014: CALL_OW 171
// wait ( 0 0$05 ) ;
30018: LD_INT 175
30020: PPUSH
30021: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
30025: LD_EXP 63
30029: PPUSH
30030: CALL_OW 87
// DialogueOn ;
30034: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
30038: LD_EXP 40
30042: PPUSH
30043: LD_STRING D16-JMM-1
30045: PPUSH
30046: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
30050: LD_EXP 63
30054: PPUSH
30055: LD_STRING D16-Friend-1
30057: PPUSH
30058: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
30062: LD_EXP 40
30066: PPUSH
30067: LD_STRING D16-JMM-2
30069: PPUSH
30070: CALL_OW 88
// DialogueOff ;
30074: CALL_OW 7
// SetSide ( Friend , 1 ) ;
30078: LD_EXP 63
30082: PPUSH
30083: LD_INT 1
30085: PPUSH
30086: CALL_OW 235
// ComHold ( Friend ) ;
30090: LD_EXP 63
30094: PPUSH
30095: CALL_OW 140
// wait ( 0 0$20 ) ;
30099: LD_INT 700
30101: PPUSH
30102: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
30106: LD_EXP 63
30110: PPUSH
30111: LD_INT 9
30113: PPUSH
30114: LD_INT 2
30116: PPUSH
30117: CALL_OW 297
30121: PUSH
30122: LD_INT 30
30124: LESS
30125: IFFALSE 30194
// begin SetSide ( Friend , 8 ) ;
30127: LD_EXP 63
30131: PPUSH
30132: LD_INT 8
30134: PPUSH
30135: CALL_OW 235
// if IsInUnit ( Friend ) then
30139: LD_EXP 63
30143: PPUSH
30144: CALL_OW 310
30148: IFFALSE 30159
// ComExitBuilding ( Friend ) ;
30150: LD_EXP 63
30154: PPUSH
30155: CALL_OW 122
// if IsDriver ( Friend ) then
30159: LD_EXP 63
30163: PPUSH
30164: CALL 102393 0 1
30168: IFFALSE 30179
// ComExitVehicle ( Friend ) ;
30170: LD_EXP 63
30174: PPUSH
30175: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
30179: LD_EXP 63
30183: PPUSH
30184: LD_INT 9
30186: PPUSH
30187: LD_INT 2
30189: PPUSH
30190: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
30194: LD_INT 1050
30196: PPUSH
30197: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30201: LD_INT 22
30203: PUSH
30204: LD_INT 1
30206: PUSH
30207: EMPTY
30208: LIST
30209: LIST
30210: PUSH
30211: LD_INT 34
30213: PUSH
30214: LD_INT 8
30216: PUSH
30217: EMPTY
30218: LIST
30219: LIST
30220: PUSH
30221: EMPTY
30222: LIST
30223: LIST
30224: PPUSH
30225: CALL_OW 69
30229: NOT
30230: IFFALSE 30576
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
30232: LD_ADDR_VAR 0 3
30236: PUSH
30237: LD_INT 22
30239: PUSH
30240: LD_INT 1
30242: PUSH
30243: EMPTY
30244: LIST
30245: LIST
30246: PUSH
30247: LD_INT 26
30249: PUSH
30250: LD_INT 1
30252: PUSH
30253: EMPTY
30254: LIST
30255: LIST
30256: PUSH
30257: LD_INT 3
30259: PUSH
30260: LD_INT 25
30262: PUSH
30263: LD_INT 12
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: PUSH
30270: LD_INT 25
30272: PUSH
30273: LD_INT 16
30275: PUSH
30276: EMPTY
30277: LIST
30278: LIST
30279: PUSH
30280: EMPTY
30281: LIST
30282: LIST
30283: LIST
30284: PUSH
30285: EMPTY
30286: LIST
30287: LIST
30288: LIST
30289: PPUSH
30290: CALL_OW 69
30294: PUSH
30295: LD_EXP 40
30299: PUSH
30300: LD_EXP 42
30304: PUSH
30305: LD_EXP 56
30309: PUSH
30310: LD_EXP 43
30314: PUSH
30315: LD_EXP 44
30319: PUSH
30320: LD_EXP 45
30324: PUSH
30325: LD_EXP 46
30329: PUSH
30330: LD_EXP 47
30334: PUSH
30335: LD_EXP 48
30339: PUSH
30340: LD_EXP 49
30344: PUSH
30345: LD_EXP 50
30349: PUSH
30350: LD_EXP 51
30354: PUSH
30355: LD_EXP 52
30359: PUSH
30360: LD_EXP 53
30364: PUSH
30365: LD_EXP 54
30369: PUSH
30370: EMPTY
30371: LIST
30372: LIST
30373: LIST
30374: LIST
30375: LIST
30376: LIST
30377: LIST
30378: LIST
30379: LIST
30380: LIST
30381: LIST
30382: LIST
30383: LIST
30384: LIST
30385: LIST
30386: DIFF
30387: ST_TO_ADDR
// DialogueOn ;
30388: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
30392: LD_EXP 65
30396: PPUSH
30397: LD_STRING D16a-Pla-1
30399: PPUSH
30400: CALL_OW 94
// if Stevens then
30404: LD_EXP 42
30408: IFFALSE 30424
// Say ( Stevens , D16a-Huck-1 ) else
30410: LD_EXP 42
30414: PPUSH
30415: LD_STRING D16a-Huck-1
30417: PPUSH
30418: CALL_OW 88
30422: GO 30466
// if Baker then
30424: LD_EXP 56
30428: IFFALSE 30444
// Say ( Baker , D16a-Huck-1 ) else
30430: LD_EXP 56
30434: PPUSH
30435: LD_STRING D16a-Huck-1
30437: PPUSH
30438: CALL_OW 88
30442: GO 30466
// if tmp then
30444: LD_VAR 0 3
30448: IFFALSE 30466
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
30450: LD_VAR 0 3
30454: PUSH
30455: LD_INT 1
30457: ARRAY
30458: PPUSH
30459: LD_STRING D16a-Sol1-1
30461: PPUSH
30462: CALL_OW 88
// if GetSide ( Friend ) = 8 then
30466: LD_EXP 63
30470: PPUSH
30471: CALL_OW 255
30475: PUSH
30476: LD_INT 8
30478: EQUAL
30479: IFFALSE 30495
// Say ( JMM , D16a-JMM-1 ) else
30481: LD_EXP 40
30485: PPUSH
30486: LD_STRING D16a-JMM-1
30488: PPUSH
30489: CALL_OW 88
30493: GO 30555
// begin Say ( JMM , D16a-JMM-1a ) ;
30495: LD_EXP 40
30499: PPUSH
30500: LD_STRING D16a-JMM-1a
30502: PPUSH
30503: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
30507: LD_EXP 63
30511: PPUSH
30512: LD_STRING D16a-Friend-1
30514: PPUSH
30515: CALL_OW 88
// ComExitBuilding ( Friend ) ;
30519: LD_EXP 63
30523: PPUSH
30524: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
30528: LD_EXP 63
30532: PPUSH
30533: LD_INT 191
30535: PPUSH
30536: LD_INT 103
30538: PPUSH
30539: CALL_OW 171
// SetSide ( Friend , 3 ) ;
30543: LD_EXP 63
30547: PPUSH
30548: LD_INT 3
30550: PPUSH
30551: CALL_OW 235
// end ; DialogueOff ;
30555: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
30559: LD_VAR 0 1
30563: PPUSH
30564: LD_INT 60
30566: PPUSH
30567: LD_INT 95
30569: PPUSH
30570: CALL_OW 116
// end else
30574: GO 30596
// begin DialogueOn ;
30576: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
30580: LD_EXP 65
30584: PPUSH
30585: LD_STRING D16c-Pla-1
30587: PPUSH
30588: CALL_OW 94
// DialogueOff ;
30592: CALL_OW 7
// end ; end else
30596: GO 30697
// begin wait ( 3 3$00 ) ;
30598: LD_INT 6300
30600: PPUSH
30601: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30605: LD_INT 22
30607: PUSH
30608: LD_INT 1
30610: PUSH
30611: EMPTY
30612: LIST
30613: LIST
30614: PUSH
30615: LD_INT 34
30617: PUSH
30618: LD_INT 8
30620: PUSH
30621: EMPTY
30622: LIST
30623: LIST
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: PPUSH
30629: CALL_OW 69
30633: NOT
30634: IFFALSE 30677
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
30636: LD_EXP 65
30640: PPUSH
30641: LD_STRING D16b-Pla-1
30643: PPUSH
30644: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
30648: LD_EXP 40
30652: PPUSH
30653: LD_STRING D16b-JMM-1
30655: PPUSH
30656: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
30660: LD_VAR 0 1
30664: PPUSH
30665: LD_INT 60
30667: PPUSH
30668: LD_INT 95
30670: PPUSH
30671: CALL_OW 116
// end else
30675: GO 30697
// begin DialogueOn ;
30677: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
30681: LD_EXP 65
30685: PPUSH
30686: LD_STRING D16c-Pla-1
30688: PPUSH
30689: CALL_OW 94
// DialogueOff ;
30693: CALL_OW 7
// end ; end ; end ;
30697: PPOPN 3
30699: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
30700: LD_EXP 14
30704: PUSH
30705: LD_INT 126000
30707: GREATEREQUAL
30708: PUSH
30709: LD_EXP 23
30713: NOT
30714: AND
30715: PUSH
30716: LD_EXP 76
30720: PPUSH
30721: CALL_OW 302
30725: AND
30726: IFFALSE 31084
30728: GO 30730
30730: DISABLE
30731: LD_INT 0
30733: PPUSH
// begin missionStage = 11 ;
30734: LD_ADDR_EXP 15
30738: PUSH
30739: LD_INT 11
30741: ST_TO_ADDR
// DialogueOn ;
30742: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
30746: LD_EXP 76
30750: PPUSH
30751: LD_STRING D9-Roth-1
30753: PPUSH
30754: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
30758: LD_EXP 40
30762: PPUSH
30763: LD_STRING D9-JMM-1
30765: PPUSH
30766: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
30770: LD_EXP 76
30774: PPUSH
30775: LD_STRING D9-Roth-2
30777: PPUSH
30778: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
30782: LD_EXP 76
30786: PPUSH
30787: LD_STRING D9-Roth-2a
30789: PPUSH
30790: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
30794: LD_EXP 65
30798: PPUSH
30799: LD_STRING D9-Pla-2
30801: PPUSH
30802: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
30806: LD_EXP 76
30810: PPUSH
30811: LD_STRING D9-Roth-3
30813: PPUSH
30814: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
30818: LD_EXP 65
30822: PPUSH
30823: LD_STRING D9-Pla-3
30825: PPUSH
30826: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
30830: LD_EXP 76
30834: PPUSH
30835: LD_STRING D9-Roth-4
30837: PPUSH
30838: CALL_OW 94
// dec = Query ( Q9 ) ;
30842: LD_ADDR_VAR 0 1
30846: PUSH
30847: LD_STRING Q9
30849: PPUSH
30850: CALL_OW 97
30854: ST_TO_ADDR
// if dec = 1 then
30855: LD_VAR 0 1
30859: PUSH
30860: LD_INT 1
30862: EQUAL
30863: IFFALSE 30877
// SayRadio ( Roth , D9a-Roth-1 ) ;
30865: LD_EXP 76
30869: PPUSH
30870: LD_STRING D9a-Roth-1
30872: PPUSH
30873: CALL_OW 94
// if dec = 2 then
30877: LD_VAR 0 1
30881: PUSH
30882: LD_INT 2
30884: EQUAL
30885: IFFALSE 30911
// begin Say ( JMM , D9b-JMM-1 ) ;
30887: LD_EXP 40
30891: PPUSH
30892: LD_STRING D9b-JMM-1
30894: PPUSH
30895: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
30899: LD_EXP 76
30903: PPUSH
30904: LD_STRING D9b-Roth-1
30906: PPUSH
30907: CALL_OW 94
// end ; if dec = 3 then
30911: LD_VAR 0 1
30915: PUSH
30916: LD_INT 3
30918: EQUAL
30919: IFFALSE 30981
// begin Say ( JMM , D9c-JMM-1 ) ;
30921: LD_EXP 40
30925: PPUSH
30926: LD_STRING D9c-JMM-1
30928: PPUSH
30929: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
30933: LD_EXP 76
30937: PPUSH
30938: LD_STRING D9c-Roth-1
30940: PPUSH
30941: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
30945: LD_EXP 40
30949: PPUSH
30950: LD_STRING D9c-JMM-2
30952: PPUSH
30953: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
30957: LD_EXP 76
30961: PPUSH
30962: LD_STRING D9c-Roth-2
30964: PPUSH
30965: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
30969: LD_EXP 40
30973: PPUSH
30974: LD_STRING D9c-JMM-3
30976: PPUSH
30977: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
30981: LD_EXP 76
30985: PPUSH
30986: LD_STRING D9c-Roth-3
30988: PPUSH
30989: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
30993: LD_EXP 76
30997: PPUSH
30998: LD_STRING D9cont-Roth-1
31000: PPUSH
31001: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
31005: LD_EXP 40
31009: PPUSH
31010: LD_STRING D9cont-JMM-1
31012: PPUSH
31013: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
31017: LD_EXP 76
31021: PPUSH
31022: LD_STRING D9cont-Roth-2
31024: PPUSH
31025: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
31029: LD_EXP 40
31033: PPUSH
31034: LD_STRING D9cont-JMM-2
31036: PPUSH
31037: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
31041: LD_EXP 76
31045: PPUSH
31046: LD_STRING D9cont-Roth-3
31048: PPUSH
31049: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
31053: LD_EXP 40
31057: PPUSH
31058: LD_STRING D9cont-JMM-3
31060: PPUSH
31061: CALL_OW 88
// DialogueOff ;
31065: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
31069: LD_STRING M3
31071: PPUSH
31072: CALL_OW 337
// allianceActive := true ;
31076: LD_ADDR_EXP 31
31080: PUSH
31081: LD_INT 1
31083: ST_TO_ADDR
// end ;
31084: PPOPN 1
31086: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
31087: LD_INT 1
31089: PPUSH
31090: LD_INT 126
31092: PPUSH
31093: CALL_OW 292
31097: PUSH
31098: LD_EXP 65
31102: PPUSH
31103: CALL_OW 310
31107: AND
31108: IFFALSE 31188
31110: GO 31112
31112: DISABLE
31113: LD_INT 0
31115: PPUSH
// begin ComExitBuilding ( Platonov ) ;
31116: LD_EXP 65
31120: PPUSH
31121: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
31125: LD_ADDR_VAR 0 1
31129: PUSH
31130: LD_INT 4
31132: PPUSH
31133: LD_INT 22
31135: PUSH
31136: LD_INT 1
31138: PUSH
31139: EMPTY
31140: LIST
31141: LIST
31142: PPUSH
31143: CALL_OW 70
31147: PPUSH
31148: LD_EXP 65
31152: PPUSH
31153: CALL_OW 74
31157: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
31158: LD_EXP 65
31162: PPUSH
31163: LD_VAR 0 1
31167: PUSH
31168: LD_INT 1
31170: ARRAY
31171: PPUSH
31172: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
31176: LD_EXP 65
31180: PPUSH
31181: LD_STRING D18-Pla-1
31183: PPUSH
31184: CALL_OW 88
// end ;
31188: PPOPN 1
31190: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
31191: LD_EXP 65
31195: PPUSH
31196: CALL_OW 301
31200: PUSH
31201: LD_EXP 68
31205: PPUSH
31206: CALL_OW 301
31210: AND
31211: PUSH
31212: LD_INT 22
31214: PUSH
31215: LD_INT 3
31217: PUSH
31218: EMPTY
31219: LIST
31220: LIST
31221: PUSH
31222: LD_INT 21
31224: PUSH
31225: LD_INT 1
31227: PUSH
31228: EMPTY
31229: LIST
31230: LIST
31231: PUSH
31232: LD_INT 50
31234: PUSH
31235: EMPTY
31236: LIST
31237: PUSH
31238: EMPTY
31239: LIST
31240: LIST
31241: LIST
31242: PPUSH
31243: CALL_OW 69
31247: PUSH
31248: LD_INT 7
31250: PUSH
31251: LD_INT 8
31253: PUSH
31254: LD_INT 9
31256: PUSH
31257: LD_INT 10
31259: PUSH
31260: EMPTY
31261: LIST
31262: LIST
31263: LIST
31264: LIST
31265: PUSH
31266: LD_OWVAR 67
31270: ARRAY
31271: LESS
31272: AND
31273: IFFALSE 32072
31275: GO 31277
31277: DISABLE
31278: LD_INT 0
31280: PPUSH
31281: PPUSH
31282: PPUSH
31283: PPUSH
// begin MC_Kill ( 2 ) ;
31284: LD_INT 2
31286: PPUSH
31287: CALL 36920 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
31291: LD_INT 1
31293: PPUSH
31294: LD_INT 3
31296: PPUSH
31297: LD_INT 1
31299: PPUSH
31300: LD_INT 1
31302: PPUSH
31303: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
31307: LD_ADDR_VAR 0 2
31311: PUSH
31312: LD_INT 22
31314: PUSH
31315: LD_INT 3
31317: PUSH
31318: EMPTY
31319: LIST
31320: LIST
31321: PUSH
31322: LD_INT 21
31324: PUSH
31325: LD_INT 1
31327: PUSH
31328: EMPTY
31329: LIST
31330: LIST
31331: PUSH
31332: LD_INT 50
31334: PUSH
31335: EMPTY
31336: LIST
31337: PUSH
31338: LD_INT 26
31340: PUSH
31341: LD_INT 1
31343: PUSH
31344: EMPTY
31345: LIST
31346: LIST
31347: PUSH
31348: EMPTY
31349: LIST
31350: LIST
31351: LIST
31352: LIST
31353: PPUSH
31354: CALL_OW 69
31358: ST_TO_ADDR
// if not tmp then
31359: LD_VAR 0 2
31363: NOT
31364: IFFALSE 31420
// begin uc_side = 3 ;
31366: LD_ADDR_OWVAR 20
31370: PUSH
31371: LD_INT 3
31373: ST_TO_ADDR
// uc_nation = 3 ;
31374: LD_ADDR_OWVAR 21
31378: PUSH
31379: LD_INT 3
31381: ST_TO_ADDR
// hc_name =  ;
31382: LD_ADDR_OWVAR 26
31386: PUSH
31387: LD_STRING 
31389: ST_TO_ADDR
// hc_gallery =  ;
31390: LD_ADDR_OWVAR 33
31394: PUSH
31395: LD_STRING 
31397: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
31398: LD_INT 1
31400: PPUSH
31401: LD_INT 10
31403: PPUSH
31404: CALL_OW 381
// tmp = CreateHuman ;
31408: LD_ADDR_VAR 0 2
31412: PUSH
31413: CALL_OW 44
31417: ST_TO_ADDR
// end else
31418: GO 31434
// tmp := tmp [ 1 ] ;
31420: LD_ADDR_VAR 0 2
31424: PUSH
31425: LD_VAR 0 2
31429: PUSH
31430: LD_INT 1
31432: ARRAY
31433: ST_TO_ADDR
// DialogueOn ;
31434: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
31438: LD_VAR 0 2
31442: PPUSH
31443: LD_STRING DSurrenderRussians-RSol1-1a
31445: PPUSH
31446: CALL_OW 94
// DialogueOff ;
31450: CALL_OW 7
// russianDestroyed := true ;
31454: LD_ADDR_EXP 21
31458: PUSH
31459: LD_INT 1
31461: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
31462: LD_ADDR_VAR 0 1
31466: PUSH
31467: LD_INT 22
31469: PUSH
31470: LD_INT 6
31472: PUSH
31473: EMPTY
31474: LIST
31475: LIST
31476: PPUSH
31477: CALL_OW 69
31481: PUSH
31482: FOR_IN
31483: IFFALSE 31496
// KillUnit ( i ) ;
31485: LD_VAR 0 1
31489: PPUSH
31490: CALL_OW 66
31494: GO 31482
31496: POP
31497: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
31498: LD_INT 22
31500: PUSH
31501: LD_INT 3
31503: PUSH
31504: EMPTY
31505: LIST
31506: LIST
31507: PUSH
31508: LD_INT 21
31510: PUSH
31511: LD_INT 1
31513: PUSH
31514: EMPTY
31515: LIST
31516: LIST
31517: PUSH
31518: EMPTY
31519: LIST
31520: LIST
31521: PPUSH
31522: CALL_OW 69
31526: PPUSH
31527: CALL_OW 122
// wait ( 0 0$1 ) ;
31531: LD_INT 35
31533: PPUSH
31534: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
31538: LD_INT 22
31540: PUSH
31541: LD_INT 3
31543: PUSH
31544: EMPTY
31545: LIST
31546: LIST
31547: PUSH
31548: LD_INT 21
31550: PUSH
31551: LD_INT 1
31553: PUSH
31554: EMPTY
31555: LIST
31556: LIST
31557: PUSH
31558: EMPTY
31559: LIST
31560: LIST
31561: PPUSH
31562: CALL_OW 69
31566: PPUSH
31567: LD_INT 25
31569: PPUSH
31570: CALL_OW 173
// wait ( 0 0$35 ) ;
31574: LD_INT 1225
31576: PPUSH
31577: CALL_OW 67
// PrepareOmarInvasion ;
31581: CALL 14656 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
31585: LD_ADDR_VAR 0 2
31589: PUSH
31590: LD_EXP 94
31594: PPUSH
31595: CALL_OW 250
31599: PUSH
31600: LD_EXP 94
31604: PPUSH
31605: CALL_OW 251
31609: PUSH
31610: EMPTY
31611: LIST
31612: LIST
31613: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
31614: LD_VAR 0 2
31618: PUSH
31619: LD_INT 1
31621: ARRAY
31622: PPUSH
31623: LD_VAR 0 2
31627: PUSH
31628: LD_INT 2
31630: ARRAY
31631: PPUSH
31632: LD_INT 1
31634: PPUSH
31635: LD_INT 8
31637: NEG
31638: PPUSH
31639: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
31643: LD_EXP 94
31647: PPUSH
31648: CALL_OW 87
// DialogueOn ;
31652: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
31656: LD_EXP 40
31660: PPUSH
31661: LD_STRING D19-JMM-1
31663: PPUSH
31664: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Kurt , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
31668: LD_ADDR_VAR 0 3
31672: PUSH
31673: LD_INT 22
31675: PUSH
31676: LD_INT 1
31678: PUSH
31679: EMPTY
31680: LIST
31681: LIST
31682: PUSH
31683: LD_INT 26
31685: PUSH
31686: LD_INT 1
31688: PUSH
31689: EMPTY
31690: LIST
31691: LIST
31692: PUSH
31693: LD_INT 2
31695: PUSH
31696: LD_INT 25
31698: PUSH
31699: LD_INT 1
31701: PUSH
31702: EMPTY
31703: LIST
31704: LIST
31705: PUSH
31706: LD_INT 25
31708: PUSH
31709: LD_INT 2
31711: PUSH
31712: EMPTY
31713: LIST
31714: LIST
31715: PUSH
31716: LD_INT 25
31718: PUSH
31719: LD_INT 3
31721: PUSH
31722: EMPTY
31723: LIST
31724: LIST
31725: PUSH
31726: LD_INT 25
31728: PUSH
31729: LD_INT 4
31731: PUSH
31732: EMPTY
31733: LIST
31734: LIST
31735: PUSH
31736: LD_INT 25
31738: PUSH
31739: LD_INT 5
31741: PUSH
31742: EMPTY
31743: LIST
31744: LIST
31745: PUSH
31746: LD_INT 25
31748: PUSH
31749: LD_INT 8
31751: PUSH
31752: EMPTY
31753: LIST
31754: LIST
31755: PUSH
31756: EMPTY
31757: LIST
31758: LIST
31759: LIST
31760: LIST
31761: LIST
31762: LIST
31763: LIST
31764: PUSH
31765: EMPTY
31766: LIST
31767: LIST
31768: LIST
31769: PPUSH
31770: CALL_OW 69
31774: PUSH
31775: LD_EXP 40
31779: PUSH
31780: LD_EXP 41
31784: PUSH
31785: LD_EXP 61
31789: PUSH
31790: LD_EXP 42
31794: PUSH
31795: LD_EXP 43
31799: PUSH
31800: LD_EXP 44
31804: PUSH
31805: LD_EXP 45
31809: PUSH
31810: LD_EXP 46
31814: PUSH
31815: LD_EXP 47
31819: PUSH
31820: LD_EXP 48
31824: PUSH
31825: LD_EXP 49
31829: PUSH
31830: LD_EXP 50
31834: PUSH
31835: LD_EXP 51
31839: PUSH
31840: LD_EXP 52
31844: PUSH
31845: LD_EXP 53
31849: PUSH
31850: LD_EXP 54
31854: PUSH
31855: LD_EXP 55
31859: PUSH
31860: LD_EXP 56
31864: PUSH
31865: EMPTY
31866: LIST
31867: LIST
31868: LIST
31869: LIST
31870: LIST
31871: LIST
31872: LIST
31873: LIST
31874: LIST
31875: LIST
31876: LIST
31877: LIST
31878: LIST
31879: LIST
31880: LIST
31881: LIST
31882: LIST
31883: LIST
31884: DIFF
31885: ST_TO_ADDR
// if tmp2 then
31886: LD_VAR 0 3
31890: IFFALSE 31908
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
31892: LD_VAR 0 3
31896: PUSH
31897: LD_INT 1
31899: ARRAY
31900: PPUSH
31901: LD_STRING D19-Sol1-1
31903: PPUSH
31904: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
31908: LD_EXP 40
31912: PPUSH
31913: LD_STRING D19-JMM-2
31915: PPUSH
31916: CALL_OW 88
// DialogueOff ;
31920: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
31924: LD_VAR 0 2
31928: PUSH
31929: LD_INT 1
31931: ARRAY
31932: PPUSH
31933: LD_VAR 0 2
31937: PUSH
31938: LD_INT 2
31940: ARRAY
31941: PPUSH
31942: LD_INT 1
31944: PPUSH
31945: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
31949: LD_STRING M5
31951: PPUSH
31952: CALL_OW 337
// omarOnMotherLode := false ;
31956: LD_ADDR_VAR 0 4
31960: PUSH
31961: LD_INT 0
31963: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
31964: LD_INT 35
31966: PPUSH
31967: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
31971: LD_EXP 94
31975: PPUSH
31976: LD_INT 215
31978: PPUSH
31979: LD_INT 100
31981: PPUSH
31982: CALL_OW 297
31986: PUSH
31987: LD_INT 10
31989: LESS
31990: PUSH
31991: LD_VAR 0 4
31995: NOT
31996: AND
31997: IFFALSE 32031
// begin omarOnMotherLode := true ;
31999: LD_ADDR_VAR 0 4
32003: PUSH
32004: LD_INT 1
32006: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
32007: LD_EXP 40
32011: PPUSH
32012: LD_STRING D19b-JMM-1
32014: PPUSH
32015: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
32019: LD_EXP 94
32023: PPUSH
32024: LD_STRING DOmarContam-Omar-1
32026: PPUSH
32027: CALL_OW 88
// end ; until IsDead ( Omar ) ;
32031: LD_EXP 94
32035: PPUSH
32036: CALL_OW 301
32040: IFFALSE 31964
// Say ( JMM , D19a-JMM-1 ) ;
32042: LD_EXP 40
32046: PPUSH
32047: LD_STRING D19a-JMM-1
32049: PPUSH
32050: CALL_OW 88
// if Heike then
32054: LD_EXP 95
32058: IFFALSE 32072
// Say ( Heike , D19a-Hke-1 ) ;
32060: LD_EXP 95
32064: PPUSH
32065: LD_STRING D19a-Hke-1
32067: PPUSH
32068: CALL_OW 88
// end ;
32072: PPOPN 4
32074: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
32075: LD_INT 22
32077: PUSH
32078: LD_INT 3
32080: PUSH
32081: EMPTY
32082: LIST
32083: LIST
32084: PUSH
32085: LD_INT 21
32087: PUSH
32088: LD_INT 1
32090: PUSH
32091: EMPTY
32092: LIST
32093: LIST
32094: PUSH
32095: EMPTY
32096: LIST
32097: LIST
32098: PPUSH
32099: CALL_OW 69
32103: PUSH
32104: LD_EXP 21
32108: AND
32109: IFFALSE 32177
32111: GO 32113
32113: DISABLE
32114: LD_INT 0
32116: PPUSH
32117: PPUSH
// begin enable ;
32118: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
32119: LD_ADDR_VAR 0 2
32123: PUSH
32124: LD_INT 25
32126: PPUSH
32127: LD_INT 22
32129: PUSH
32130: LD_INT 3
32132: PUSH
32133: EMPTY
32134: LIST
32135: LIST
32136: PPUSH
32137: CALL_OW 70
32141: ST_TO_ADDR
// if not tmp then
32142: LD_VAR 0 2
32146: NOT
32147: IFFALSE 32151
// exit ;
32149: GO 32177
// for i in tmp do
32151: LD_ADDR_VAR 0 1
32155: PUSH
32156: LD_VAR 0 2
32160: PUSH
32161: FOR_IN
32162: IFFALSE 32175
// RemoveUnit ( i ) ;
32164: LD_VAR 0 1
32168: PPUSH
32169: CALL_OW 64
32173: GO 32161
32175: POP
32176: POP
// end ;
32177: PPOPN 2
32179: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
32180: LD_INT 22
32182: PUSH
32183: LD_INT 7
32185: PUSH
32186: EMPTY
32187: LIST
32188: LIST
32189: PUSH
32190: LD_INT 21
32192: PUSH
32193: LD_INT 1
32195: PUSH
32196: EMPTY
32197: LIST
32198: LIST
32199: PUSH
32200: EMPTY
32201: LIST
32202: LIST
32203: PPUSH
32204: CALL_OW 69
32208: PUSH
32209: LD_INT 6
32211: LESS
32212: IFFALSE 32680
32214: GO 32216
32216: DISABLE
32217: LD_INT 0
32219: PPUSH
32220: PPUSH
// begin MC_Kill ( 1 ) ;
32221: LD_INT 1
32223: PPUSH
32224: CALL 36920 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
32228: LD_INT 7
32230: PPUSH
32231: LD_INT 1
32233: PPUSH
32234: LD_INT 1
32236: PPUSH
32237: LD_INT 1
32239: PPUSH
32240: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
32244: LD_ADDR_VAR 0 1
32248: PUSH
32249: LD_INT 22
32251: PUSH
32252: LD_INT 7
32254: PUSH
32255: EMPTY
32256: LIST
32257: LIST
32258: PUSH
32259: LD_INT 26
32261: PUSH
32262: LD_INT 1
32264: PUSH
32265: EMPTY
32266: LIST
32267: LIST
32268: PUSH
32269: EMPTY
32270: LIST
32271: LIST
32272: PPUSH
32273: CALL_OW 69
32277: PUSH
32278: LD_EXP 76
32282: DIFF
32283: ST_TO_ADDR
// if tmp then
32284: LD_VAR 0 1
32288: IFFALSE 32306
// tmp := tmp [ 1 ] else
32290: LD_ADDR_VAR 0 1
32294: PUSH
32295: LD_VAR 0 1
32299: PUSH
32300: LD_INT 1
32302: ARRAY
32303: ST_TO_ADDR
32304: GO 32342
// begin uc_side := 7 ;
32306: LD_ADDR_OWVAR 20
32310: PUSH
32311: LD_INT 7
32313: ST_TO_ADDR
// uc_nation := 1 ;
32314: LD_ADDR_OWVAR 21
32318: PUSH
32319: LD_INT 1
32321: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
32322: LD_INT 1
32324: PPUSH
32325: LD_INT 8
32327: PPUSH
32328: CALL_OW 384
// tmp := CreateHuman ;
32332: LD_ADDR_VAR 0 1
32336: PUSH
32337: CALL_OW 44
32341: ST_TO_ADDR
// end ; DialogueOn ;
32342: CALL_OW 6
// if IsOK ( Roth ) then
32346: LD_EXP 76
32350: PPUSH
32351: CALL_OW 302
32355: IFFALSE 32369
// Say ( JMM , DAb-JMM-1 ) ;
32357: LD_EXP 40
32361: PPUSH
32362: LD_STRING DAb-JMM-1
32364: PPUSH
32365: CALL_OW 88
// if IsOK ( Roth ) then
32369: LD_EXP 76
32373: PPUSH
32374: CALL_OW 302
32378: IFFALSE 32402
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
32380: LD_EXP 76
32384: PPUSH
32385: LD_STRING DSurrenderAlliance-Roth-1
32387: PPUSH
32388: CALL_OW 88
// RothCaptured := true ;
32392: LD_ADDR_EXP 33
32396: PUSH
32397: LD_INT 1
32399: ST_TO_ADDR
// end else
32400: GO 32414
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
32402: LD_VAR 0 1
32406: PPUSH
32407: LD_STRING DSurrenderAlliance-Sci1-1
32409: PPUSH
32410: CALL_OW 88
// DialogueOff ;
32414: CALL_OW 7
// allianceDestroyed := true ;
32418: LD_ADDR_EXP 23
32422: PUSH
32423: LD_INT 1
32425: ST_TO_ADDR
// if capturedUnit = 0 then
32426: LD_EXP 34
32430: PUSH
32431: LD_INT 0
32433: EQUAL
32434: IFFALSE 32443
// SetAchievement ( ACH_ALLIANCE ) ;
32436: LD_STRING ACH_ALLIANCE
32438: PPUSH
32439: CALL_OW 543
// if trueAmericans then
32443: LD_EXP 35
32447: IFFALSE 32523
// begin if trueAmericans = 1 then
32449: LD_EXP 35
32453: PUSH
32454: LD_INT 1
32456: EQUAL
32457: IFFALSE 32473
// Say ( JMM , DAb-JMM-1a ) else
32459: LD_EXP 40
32463: PPUSH
32464: LD_STRING DAb-JMM-1a
32466: PPUSH
32467: CALL_OW 88
32471: GO 32485
// Say ( JMM , DAb-JMM-1b ) ;
32473: LD_EXP 40
32477: PPUSH
32478: LD_STRING DAb-JMM-1b
32480: PPUSH
32481: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
32485: LD_EXP 35
32489: PPUSH
32490: CALL_OW 87
// for i in trueAmericans do
32494: LD_ADDR_VAR 0 2
32498: PUSH
32499: LD_EXP 35
32503: PUSH
32504: FOR_IN
32505: IFFALSE 32521
// SetSide ( i , 1 ) ;
32507: LD_VAR 0 2
32511: PPUSH
32512: LD_INT 1
32514: PPUSH
32515: CALL_OW 235
32519: GO 32504
32521: POP
32522: POP
// end ; repeat wait ( 0 0$1 ) ;
32523: LD_INT 35
32525: PPUSH
32526: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
32530: LD_ADDR_VAR 0 2
32534: PUSH
32535: LD_INT 22
32537: PUSH
32538: LD_INT 7
32540: PUSH
32541: EMPTY
32542: LIST
32543: LIST
32544: PUSH
32545: LD_INT 21
32547: PUSH
32548: LD_INT 1
32550: PUSH
32551: EMPTY
32552: LIST
32553: LIST
32554: PUSH
32555: EMPTY
32556: LIST
32557: LIST
32558: PPUSH
32559: CALL_OW 69
32563: PUSH
32564: FOR_IN
32565: IFFALSE 32647
// begin if IsInUnit ( i ) then
32567: LD_VAR 0 2
32571: PPUSH
32572: CALL_OW 310
32576: IFFALSE 32587
// ComExitBuilding ( i ) ;
32578: LD_VAR 0 2
32582: PPUSH
32583: CALL_OW 122
// if IsDriver ( i ) then
32587: LD_VAR 0 2
32591: PPUSH
32592: CALL 102393 0 1
32596: IFFALSE 32607
// ComExitVehicle ( i ) ;
32598: LD_VAR 0 2
32602: PPUSH
32603: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
32607: LD_VAR 0 2
32611: PPUSH
32612: LD_INT 26
32614: PPUSH
32615: CALL_OW 308
32619: NOT
32620: IFFALSE 32636
// AddComMoveToArea ( i , allianceEscapeArea ) else
32622: LD_VAR 0 2
32626: PPUSH
32627: LD_INT 26
32629: PPUSH
32630: CALL_OW 173
32634: GO 32645
// RemoveUnit ( i ) ;
32636: LD_VAR 0 2
32640: PPUSH
32641: CALL_OW 64
// end ;
32645: GO 32564
32647: POP
32648: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
32649: LD_INT 22
32651: PUSH
32652: LD_INT 7
32654: PUSH
32655: EMPTY
32656: LIST
32657: LIST
32658: PUSH
32659: LD_INT 21
32661: PUSH
32662: LD_INT 1
32664: PUSH
32665: EMPTY
32666: LIST
32667: LIST
32668: PUSH
32669: EMPTY
32670: LIST
32671: LIST
32672: PPUSH
32673: CALL_OW 69
32677: NOT
32678: IFFALSE 32523
// end ;
32680: PPOPN 2
32682: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
32683: LD_INT 0
32685: PPUSH
32686: PPUSH
// if not unit then
32687: LD_VAR 0 1
32691: NOT
32692: IFFALSE 32696
// exit ;
32694: GO 34194
// DoNotAttack ( 7 , unit ) ;
32696: LD_INT 7
32698: PPUSH
32699: LD_VAR 0 1
32703: PPUSH
32704: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
32708: LD_VAR 0 1
32712: PPUSH
32713: LD_INT 260
32715: PPUSH
32716: LD_INT 235
32718: PPUSH
32719: LD_INT 3
32721: PPUSH
32722: LD_INT 1
32724: PPUSH
32725: CALL_OW 483
// SetSide ( unit , 4 ) ;
32729: LD_VAR 0 1
32733: PPUSH
32734: LD_INT 4
32736: PPUSH
32737: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
32741: LD_ADDR_EXP 34
32745: PUSH
32746: LD_EXP 34
32750: PUSH
32751: LD_INT 1
32753: PLUS
32754: ST_TO_ADDR
// wait ( 0 0$2 ) ;
32755: LD_INT 70
32757: PPUSH
32758: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
32762: LD_INT 260
32764: PPUSH
32765: LD_INT 235
32767: PPUSH
32768: LD_INT 1
32770: PPUSH
32771: LD_INT 8
32773: NEG
32774: PPUSH
32775: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
32779: LD_VAR 0 1
32783: PPUSH
32784: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
32788: LD_VAR 0 1
32792: PPUSH
32793: LD_EXP 76
32797: PPUSH
32798: CALL_OW 119
// DialogueOn ;
32802: CALL_OW 6
// case unit of JMM :
32806: LD_VAR 0 1
32810: PUSH
32811: LD_EXP 40
32815: DOUBLE
32816: EQUAL
32817: IFTRUE 32821
32819: GO 32836
32821: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
32822: LD_EXP 40
32826: PPUSH
32827: LD_STRING DA1-JMM-1
32829: PPUSH
32830: CALL_OW 91
32834: GO 33278
32836: LD_EXP 41
32840: DOUBLE
32841: EQUAL
32842: IFTRUE 32846
32844: GO 32861
32846: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
32847: LD_EXP 41
32851: PPUSH
32852: LD_STRING DA1-Joan-1
32854: PPUSH
32855: CALL_OW 91
32859: GO 33278
32861: LD_EXP 43
32865: DOUBLE
32866: EQUAL
32867: IFTRUE 32871
32869: GO 32886
32871: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
32872: LD_EXP 43
32876: PPUSH
32877: LD_STRING DA1-Lisa-1
32879: PPUSH
32880: CALL_OW 91
32884: GO 33278
32886: LD_EXP 44
32890: DOUBLE
32891: EQUAL
32892: IFTRUE 32896
32894: GO 32911
32896: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
32897: LD_EXP 44
32901: PPUSH
32902: LD_STRING DA1-Don-1
32904: PPUSH
32905: CALL_OW 91
32909: GO 33278
32911: LD_EXP 51
32915: DOUBLE
32916: EQUAL
32917: IFTRUE 32921
32919: GO 32936
32921: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
32922: LD_EXP 51
32926: PPUSH
32927: LD_STRING DA1-Corn-1
32929: PPUSH
32930: CALL_OW 91
32934: GO 33278
32936: LD_EXP 47
32940: DOUBLE
32941: EQUAL
32942: IFTRUE 32946
32944: GO 32961
32946: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
32947: LD_EXP 47
32951: PPUSH
32952: LD_STRING DA1-Den-1
32954: PPUSH
32955: CALL_OW 91
32959: GO 33278
32961: LD_EXP 45
32965: DOUBLE
32966: EQUAL
32967: IFTRUE 32971
32969: GO 32986
32971: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
32972: LD_EXP 45
32976: PPUSH
32977: LD_STRING DA1-Bobby-1
32979: PPUSH
32980: CALL_OW 91
32984: GO 33278
32986: LD_EXP 49
32990: DOUBLE
32991: EQUAL
32992: IFTRUE 32996
32994: GO 33011
32996: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
32997: LD_EXP 49
33001: PPUSH
33002: LD_STRING DA1-Glad-1
33004: PPUSH
33005: CALL_OW 91
33009: GO 33278
33011: LD_EXP 46
33015: DOUBLE
33016: EQUAL
33017: IFTRUE 33021
33019: GO 33036
33021: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
33022: LD_EXP 46
33026: PPUSH
33027: LD_STRING DA1-Cyrus-1
33029: PPUSH
33030: CALL_OW 91
33034: GO 33278
33036: LD_EXP 42
33040: DOUBLE
33041: EQUAL
33042: IFTRUE 33046
33044: GO 33061
33046: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
33047: LD_EXP 42
33051: PPUSH
33052: LD_STRING DA1-Huck-1
33054: PPUSH
33055: CALL_OW 91
33059: GO 33278
33061: LD_EXP 56
33065: DOUBLE
33066: EQUAL
33067: IFTRUE 33071
33069: GO 33086
33071: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
33072: LD_EXP 56
33076: PPUSH
33077: LD_STRING DA1-Huck-1
33079: PPUSH
33080: CALL_OW 91
33084: GO 33278
33086: LD_EXP 48
33090: DOUBLE
33091: EQUAL
33092: IFTRUE 33096
33094: GO 33111
33096: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
33097: LD_EXP 48
33101: PPUSH
33102: LD_STRING DA1-Brown-1
33104: PPUSH
33105: CALL_OW 91
33109: GO 33278
33111: LD_EXP 52
33115: DOUBLE
33116: EQUAL
33117: IFTRUE 33121
33119: GO 33136
33121: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
33122: LD_EXP 52
33126: PPUSH
33127: LD_STRING DA1-Gary-1
33129: PPUSH
33130: CALL_OW 91
33134: GO 33278
33136: LD_EXP 55
33140: DOUBLE
33141: EQUAL
33142: IFTRUE 33146
33144: GO 33161
33146: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
33147: LD_EXP 55
33151: PPUSH
33152: LD_STRING DA1-Con-1
33154: PPUSH
33155: CALL_OW 91
33159: GO 33278
33161: LD_EXP 61
33165: DOUBLE
33166: EQUAL
33167: IFTRUE 33171
33169: GO 33186
33171: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
33172: LD_EXP 61
33176: PPUSH
33177: LD_STRING DA1-Kurt-1
33179: PPUSH
33180: CALL_OW 91
33184: GO 33278
33186: LD_EXP 54
33190: DOUBLE
33191: EQUAL
33192: IFTRUE 33196
33194: GO 33211
33196: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
33197: LD_EXP 54
33201: PPUSH
33202: LD_STRING DA1-Yam-1
33204: PPUSH
33205: CALL_OW 91
33209: GO 33278
33211: LD_EXP 53
33215: DOUBLE
33216: EQUAL
33217: IFTRUE 33221
33219: GO 33236
33221: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
33222: LD_EXP 53
33226: PPUSH
33227: LD_STRING DA1-Frank-1
33229: PPUSH
33230: CALL_OW 91
33234: GO 33278
33236: POP
// begin if GetSex ( unit ) = sex_male then
33237: LD_VAR 0 1
33241: PPUSH
33242: CALL_OW 258
33246: PUSH
33247: LD_INT 1
33249: EQUAL
33250: IFFALSE 33266
// ForceSay ( unit , DA1-Sol1-1 ) else
33252: LD_VAR 0 1
33256: PPUSH
33257: LD_STRING DA1-Sol1-1
33259: PPUSH
33260: CALL_OW 91
33264: GO 33278
// ForceSay ( unit , DA1-FSol1-1 ) ;
33266: LD_VAR 0 1
33270: PPUSH
33271: LD_STRING DA1-FSol1-1
33273: PPUSH
33274: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
33278: LD_EXP 76
33282: PPUSH
33283: LD_STRING DA-Roth-1
33285: PPUSH
33286: CALL_OW 88
// if capturedUnit = 1 then
33290: LD_EXP 34
33294: PUSH
33295: LD_INT 1
33297: EQUAL
33298: IFFALSE 33326
// begin Say ( Simms , DA-Sim-1 ) ;
33300: LD_EXP 77
33304: PPUSH
33305: LD_STRING DA-Sim-1
33307: PPUSH
33308: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
33312: LD_EXP 76
33316: PPUSH
33317: LD_STRING DA-Roth-2
33319: PPUSH
33320: CALL_OW 88
// end else
33324: GO 33338
// Say ( Simms , DA-Sim-2 ) ;
33326: LD_EXP 77
33330: PPUSH
33331: LD_STRING DA-Sim-2
33333: PPUSH
33334: CALL_OW 88
// case unit of JMM :
33338: LD_VAR 0 1
33342: PUSH
33343: LD_EXP 40
33347: DOUBLE
33348: EQUAL
33349: IFTRUE 33353
33351: GO 33368
33353: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
33354: LD_EXP 40
33358: PPUSH
33359: LD_STRING DA1-JMM-1a
33361: PPUSH
33362: CALL_OW 91
33366: GO 33875
33368: LD_EXP 41
33372: DOUBLE
33373: EQUAL
33374: IFTRUE 33378
33376: GO 33393
33378: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
33379: LD_EXP 41
33383: PPUSH
33384: LD_STRING DA1-Joan-1a
33386: PPUSH
33387: CALL_OW 91
33391: GO 33875
33393: LD_EXP 43
33397: DOUBLE
33398: EQUAL
33399: IFTRUE 33403
33401: GO 33418
33403: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
33404: LD_EXP 43
33408: PPUSH
33409: LD_STRING DA1-Lisa-1a
33411: PPUSH
33412: CALL_OW 91
33416: GO 33875
33418: LD_EXP 44
33422: DOUBLE
33423: EQUAL
33424: IFTRUE 33428
33426: GO 33443
33428: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
33429: LD_EXP 44
33433: PPUSH
33434: LD_STRING DA1-Don-1a
33436: PPUSH
33437: CALL_OW 91
33441: GO 33875
33443: LD_EXP 51
33447: DOUBLE
33448: EQUAL
33449: IFTRUE 33453
33451: GO 33468
33453: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
33454: LD_EXP 51
33458: PPUSH
33459: LD_STRING DA1-Corn-1a
33461: PPUSH
33462: CALL_OW 91
33466: GO 33875
33468: LD_EXP 47
33472: DOUBLE
33473: EQUAL
33474: IFTRUE 33478
33476: GO 33493
33478: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
33479: LD_EXP 47
33483: PPUSH
33484: LD_STRING DA1-Den-1a
33486: PPUSH
33487: CALL_OW 91
33491: GO 33875
33493: LD_EXP 45
33497: DOUBLE
33498: EQUAL
33499: IFTRUE 33503
33501: GO 33518
33503: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
33504: LD_EXP 45
33508: PPUSH
33509: LD_STRING DA1-Bobby-1a
33511: PPUSH
33512: CALL_OW 91
33516: GO 33875
33518: LD_EXP 49
33522: DOUBLE
33523: EQUAL
33524: IFTRUE 33528
33526: GO 33543
33528: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
33529: LD_EXP 49
33533: PPUSH
33534: LD_STRING DA1-Glad-1a
33536: PPUSH
33537: CALL_OW 91
33541: GO 33875
33543: LD_EXP 46
33547: DOUBLE
33548: EQUAL
33549: IFTRUE 33553
33551: GO 33568
33553: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
33554: LD_EXP 46
33558: PPUSH
33559: LD_STRING DA1-Cyrus-1a
33561: PPUSH
33562: CALL_OW 91
33566: GO 33875
33568: LD_EXP 42
33572: DOUBLE
33573: EQUAL
33574: IFTRUE 33578
33576: GO 33593
33578: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
33579: LD_EXP 42
33583: PPUSH
33584: LD_STRING DA1-Huck-1a
33586: PPUSH
33587: CALL_OW 91
33591: GO 33875
33593: LD_EXP 56
33597: DOUBLE
33598: EQUAL
33599: IFTRUE 33603
33601: GO 33618
33603: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
33604: LD_EXP 56
33608: PPUSH
33609: LD_STRING DA1-Huck-1a
33611: PPUSH
33612: CALL_OW 91
33616: GO 33875
33618: LD_EXP 48
33622: DOUBLE
33623: EQUAL
33624: IFTRUE 33628
33626: GO 33643
33628: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
33629: LD_EXP 48
33633: PPUSH
33634: LD_STRING DA1-Brown-1a
33636: PPUSH
33637: CALL_OW 91
33641: GO 33875
33643: LD_EXP 52
33647: DOUBLE
33648: EQUAL
33649: IFTRUE 33653
33651: GO 33668
33653: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
33654: LD_EXP 52
33658: PPUSH
33659: LD_STRING DA1-Gary-1a
33661: PPUSH
33662: CALL_OW 91
33666: GO 33875
33668: LD_EXP 55
33672: DOUBLE
33673: EQUAL
33674: IFTRUE 33678
33676: GO 33693
33678: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
33679: LD_EXP 55
33683: PPUSH
33684: LD_STRING DA1-Con-1a
33686: PPUSH
33687: CALL_OW 91
33691: GO 33875
33693: LD_EXP 61
33697: DOUBLE
33698: EQUAL
33699: IFTRUE 33703
33701: GO 33718
33703: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
33704: LD_EXP 61
33708: PPUSH
33709: LD_STRING DA1-Kurt-1a
33711: PPUSH
33712: CALL_OW 91
33716: GO 33875
33718: LD_EXP 54
33722: DOUBLE
33723: EQUAL
33724: IFTRUE 33728
33726: GO 33743
33728: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
33729: LD_EXP 54
33733: PPUSH
33734: LD_STRING DA1-Yam-1a
33736: PPUSH
33737: CALL_OW 91
33741: GO 33875
33743: LD_EXP 53
33747: DOUBLE
33748: EQUAL
33749: IFTRUE 33753
33751: GO 33768
33753: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
33754: LD_EXP 53
33758: PPUSH
33759: LD_STRING DA1-Frank-1a
33761: PPUSH
33762: CALL_OW 91
33766: GO 33875
33768: POP
// begin join := rand ( 0 , 1 ) ;
33769: LD_ADDR_VAR 0 3
33773: PUSH
33774: LD_INT 0
33776: PPUSH
33777: LD_INT 1
33779: PPUSH
33780: CALL_OW 12
33784: ST_TO_ADDR
// if join then
33785: LD_VAR 0 3
33789: IFFALSE 33834
// begin if GetSex ( unit ) = sex_male then
33791: LD_VAR 0 1
33795: PPUSH
33796: CALL_OW 258
33800: PUSH
33801: LD_INT 1
33803: EQUAL
33804: IFFALSE 33820
// ForceSay ( unit , DA1-Sol1-1b ) else
33806: LD_VAR 0 1
33810: PPUSH
33811: LD_STRING DA1-Sol1-1b
33813: PPUSH
33814: CALL_OW 91
33818: GO 33832
// ForceSay ( unit , DA1-FSol1-1b ) ;
33820: LD_VAR 0 1
33824: PPUSH
33825: LD_STRING DA1-FSol1-1b
33827: PPUSH
33828: CALL_OW 91
// end else
33832: GO 33875
// begin if GetSex ( unit ) = sex_male then
33834: LD_VAR 0 1
33838: PPUSH
33839: CALL_OW 258
33843: PUSH
33844: LD_INT 1
33846: EQUAL
33847: IFFALSE 33863
// ForceSay ( unit , DA1-Sol1-1a ) else
33849: LD_VAR 0 1
33853: PPUSH
33854: LD_STRING DA1-Sol1-1a
33856: PPUSH
33857: CALL_OW 91
33861: GO 33875
// ForceSay ( unit , DA1-FSol1-1a ) ;
33863: LD_VAR 0 1
33867: PPUSH
33868: LD_STRING DA1-FSol1-1a
33870: PPUSH
33871: CALL_OW 91
// end ; end ; end ; if unit = JMM then
33875: LD_VAR 0 1
33879: PUSH
33880: LD_EXP 40
33884: EQUAL
33885: IFFALSE 33896
// begin YouLost ( JMMCaptured ) ;
33887: LD_STRING JMMCaptured
33889: PPUSH
33890: CALL_OW 104
// exit ;
33894: GO 34194
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
33896: LD_VAR 0 1
33900: PUSH
33901: LD_EXP 44
33905: PUSH
33906: LD_EXP 47
33910: PUSH
33911: LD_EXP 45
33915: PUSH
33916: LD_EXP 42
33920: PUSH
33921: LD_EXP 56
33925: PUSH
33926: LD_EXP 48
33930: PUSH
33931: LD_EXP 54
33935: PUSH
33936: EMPTY
33937: LIST
33938: LIST
33939: LIST
33940: LIST
33941: LIST
33942: LIST
33943: LIST
33944: IN
33945: PUSH
33946: LD_VAR 0 3
33950: OR
33951: IFFALSE 34050
// begin Say ( Roth , DA-Roth-3 ) ;
33953: LD_EXP 76
33957: PPUSH
33958: LD_STRING DA-Roth-3
33960: PPUSH
33961: CALL_OW 88
// SetSide ( unit , 7 ) ;
33965: LD_VAR 0 1
33969: PPUSH
33970: LD_INT 7
33972: PPUSH
33973: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
33977: LD_ADDR_EXP 99
33981: PUSH
33982: LD_EXP 99
33986: PPUSH
33987: LD_INT 1
33989: PPUSH
33990: LD_EXP 99
33994: PUSH
33995: LD_INT 1
33997: ARRAY
33998: PUSH
33999: LD_VAR 0 1
34003: ADD
34004: PPUSH
34005: CALL_OW 1
34009: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
34010: LD_INT 260
34012: PPUSH
34013: LD_INT 235
34015: PPUSH
34016: LD_INT 1
34018: PPUSH
34019: CALL_OW 331
// SetLives ( unit , 1000 ) ;
34023: LD_VAR 0 1
34027: PPUSH
34028: LD_INT 1000
34030: PPUSH
34031: CALL_OW 234
// DialogueOff ;
34035: CALL_OW 7
// ComFree ( unit ) ;
34039: LD_VAR 0 1
34043: PPUSH
34044: CALL_OW 139
// end else
34048: GO 34131
// begin Say ( Roth , DA-Roth-3a ) ;
34050: LD_EXP 76
34054: PPUSH
34055: LD_STRING DA-Roth-3a
34057: PPUSH
34058: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
34062: LD_ADDR_EXP 35
34066: PUSH
34067: LD_EXP 35
34071: PUSH
34072: LD_VAR 0 1
34076: ADD
34077: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
34078: LD_INT 260
34080: PPUSH
34081: LD_INT 235
34083: PPUSH
34084: LD_INT 1
34086: PPUSH
34087: CALL_OW 331
// SetLives ( unit , 1000 ) ;
34091: LD_VAR 0 1
34095: PPUSH
34096: LD_INT 1000
34098: PPUSH
34099: CALL_OW 234
// DialogueOff ;
34103: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
34107: LD_VAR 0 1
34111: PPUSH
34112: LD_INT 272
34114: PPUSH
34115: LD_INT 254
34117: PPUSH
34118: CALL_OW 111
// AddComHold ( unit ) ;
34122: LD_VAR 0 1
34126: PPUSH
34127: CALL_OW 200
// end ; if capturedUnit = 1 then
34131: LD_EXP 34
34135: PUSH
34136: LD_INT 1
34138: EQUAL
34139: IFFALSE 34194
// begin DialogueOn ;
34141: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
34145: LD_EXP 40
34149: PPUSH
34150: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
34154: LD_EXP 40
34158: PPUSH
34159: LD_STRING DAa-JMM-1
34161: PPUSH
34162: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
34166: LD_EXP 40
34170: PPUSH
34171: LD_STRING DAa-JMM-1a
34173: PPUSH
34174: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
34178: LD_EXP 40
34182: PPUSH
34183: LD_STRING DAa-JMM-1b
34185: PPUSH
34186: CALL_OW 88
// DialogueOff ;
34190: CALL_OW 7
// end ; end ;
34194: LD_VAR 0 2
34198: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
34199: LD_EXP 15
34203: PUSH
34204: LD_INT 13
34206: GREATEREQUAL
34207: PUSH
34208: LD_INT 22
34210: PUSH
34211: LD_INT 2
34213: PUSH
34214: EMPTY
34215: LIST
34216: LIST
34217: PUSH
34218: LD_INT 21
34220: PUSH
34221: LD_INT 1
34223: PUSH
34224: EMPTY
34225: LIST
34226: LIST
34227: PUSH
34228: EMPTY
34229: LIST
34230: LIST
34231: PPUSH
34232: CALL_OW 69
34236: PUSH
34237: LD_INT 0
34239: EQUAL
34240: AND
34241: PUSH
34242: LD_INT 22
34244: PUSH
34245: LD_INT 2
34247: PUSH
34248: EMPTY
34249: LIST
34250: LIST
34251: PUSH
34252: LD_INT 33
34254: PUSH
34255: LD_INT 5
34257: PUSH
34258: EMPTY
34259: LIST
34260: LIST
34261: PUSH
34262: LD_INT 21
34264: PUSH
34265: LD_INT 2
34267: PUSH
34268: EMPTY
34269: LIST
34270: LIST
34271: PUSH
34272: LD_INT 50
34274: PUSH
34275: EMPTY
34276: LIST
34277: PUSH
34278: EMPTY
34279: LIST
34280: LIST
34281: LIST
34282: LIST
34283: PPUSH
34284: CALL_OW 69
34288: PUSH
34289: LD_INT 0
34291: EQUAL
34292: AND
34293: PUSH
34294: LD_EXP 21
34298: AND
34299: PUSH
34300: LD_EXP 22
34304: AND
34305: PUSH
34306: LD_EXP 23
34310: AND
34311: IFFALSE 35000
34313: GO 34315
34315: DISABLE
34316: LD_INT 0
34318: PPUSH
34319: PPUSH
34320: PPUSH
// begin m1 := false ;
34321: LD_ADDR_VAR 0 1
34325: PUSH
34326: LD_INT 0
34328: ST_TO_ADDR
// m2 := false ;
34329: LD_ADDR_VAR 0 2
34333: PUSH
34334: LD_INT 0
34336: ST_TO_ADDR
// m3 := false ;
34337: LD_ADDR_VAR 0 3
34341: PUSH
34342: LD_INT 0
34344: ST_TO_ADDR
// if not bombExploded then
34345: LD_EXP 37
34349: NOT
34350: IFFALSE 34359
// SetAchievement ( ACH_SIBROCKET ) ;
34352: LD_STRING ACH_SIBROCKET
34354: PPUSH
34355: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
34359: LD_EXP 63
34363: PPUSH
34364: CALL_OW 255
34368: PUSH
34369: LD_INT 1
34371: EQUAL
34372: PUSH
34373: LD_EXP 63
34377: PPUSH
34378: CALL_OW 302
34382: AND
34383: IFFALSE 34399
// begin wait ( 3 ) ;
34385: LD_INT 3
34387: PPUSH
34388: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
34392: LD_STRING ACH_OPO
34394: PPUSH
34395: CALL_OW 543
// end ; if tick <= 120 120$00 then
34399: LD_OWVAR 1
34403: PUSH
34404: LD_INT 252000
34406: LESSEQUAL
34407: IFFALSE 34423
// begin wait ( 3 ) ;
34409: LD_INT 3
34411: PPUSH
34412: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
34416: LD_STRING ACH_ASPEED_15
34418: PPUSH
34419: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
34423: LD_EXP 40
34427: PPUSH
34428: CALL_OW 87
// music_class := 5 ;
34432: LD_ADDR_OWVAR 72
34436: PUSH
34437: LD_INT 5
34439: ST_TO_ADDR
// music_nat := 5 ;
34440: LD_ADDR_OWVAR 71
34444: PUSH
34445: LD_INT 5
34447: ST_TO_ADDR
// DialogueOn ;
34448: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
34452: LD_EXP 40
34456: PPUSH
34457: LD_STRING D20-JMM-1
34459: PPUSH
34460: CALL_OW 88
// if IsOK ( Joan ) then
34464: LD_EXP 41
34468: PPUSH
34469: CALL_OW 302
34473: IFFALSE 34487
// Say ( Joan , D20-Joan-1 ) ;
34475: LD_EXP 41
34479: PPUSH
34480: LD_STRING D20-Joan-1
34482: PPUSH
34483: CALL_OW 88
// if IsOk ( Lisa ) then
34487: LD_EXP 43
34491: PPUSH
34492: CALL_OW 302
34496: IFFALSE 34510
// Say ( Lisa , D20-Lisa-1 ) ;
34498: LD_EXP 43
34502: PPUSH
34503: LD_STRING D20-Lisa-1
34505: PPUSH
34506: CALL_OW 88
// if IsOk ( Donaldson ) then
34510: LD_EXP 44
34514: PPUSH
34515: CALL_OW 302
34519: IFFALSE 34533
// Say ( Donaldson , D20-Don-1 ) ;
34521: LD_EXP 44
34525: PPUSH
34526: LD_STRING D20-Don-1
34528: PPUSH
34529: CALL_OW 88
// if IsOK ( Cornel ) then
34533: LD_EXP 51
34537: PPUSH
34538: CALL_OW 302
34542: IFFALSE 34556
// Say ( Cornel , D20-Corn-1 ) ;
34544: LD_EXP 51
34548: PPUSH
34549: LD_STRING D20-Corn-1
34551: PPUSH
34552: CALL_OW 88
// if IsOk ( Denis ) then
34556: LD_EXP 47
34560: PPUSH
34561: CALL_OW 302
34565: IFFALSE 34579
// Say ( Denis , D20-Den-1 ) ;
34567: LD_EXP 47
34571: PPUSH
34572: LD_STRING D20-Den-1
34574: PPUSH
34575: CALL_OW 88
// if IsOk ( Bobby ) then
34579: LD_EXP 45
34583: PPUSH
34584: CALL_OW 302
34588: IFFALSE 34602
// Say ( Bobby , D20-Bobby-1 ) ;
34590: LD_EXP 45
34594: PPUSH
34595: LD_STRING D20-Bobby-1
34597: PPUSH
34598: CALL_OW 88
// if IsOk ( Gladstone ) then
34602: LD_EXP 49
34606: PPUSH
34607: CALL_OW 302
34611: IFFALSE 34625
// Say ( Gladstone , D20-Glad-1 ) ;
34613: LD_EXP 49
34617: PPUSH
34618: LD_STRING D20-Glad-1
34620: PPUSH
34621: CALL_OW 88
// if IsOk ( Cyrus ) then
34625: LD_EXP 46
34629: PPUSH
34630: CALL_OW 302
34634: IFFALSE 34648
// Say ( Cyrus , D20-Cyrus-1 ) ;
34636: LD_EXP 46
34640: PPUSH
34641: LD_STRING D20-Cyrus-1
34643: PPUSH
34644: CALL_OW 88
// if IsOk ( Stevens ) then
34648: LD_EXP 42
34652: PPUSH
34653: CALL_OW 302
34657: IFFALSE 34671
// Say ( Stevens , D20-Huck-1 ) ;
34659: LD_EXP 42
34663: PPUSH
34664: LD_STRING D20-Huck-1
34666: PPUSH
34667: CALL_OW 88
// if IsOk ( Brown ) then
34671: LD_EXP 48
34675: PPUSH
34676: CALL_OW 302
34680: IFFALSE 34694
// Say ( Brown , D20-Brown-1 ) ;
34682: LD_EXP 48
34686: PPUSH
34687: LD_STRING D20-Brown-1
34689: PPUSH
34690: CALL_OW 88
// if IsOk ( Gary ) then
34694: LD_EXP 52
34698: PPUSH
34699: CALL_OW 302
34703: IFFALSE 34717
// Say ( Gary , D20-Gary-1 ) ;
34705: LD_EXP 52
34709: PPUSH
34710: LD_STRING D20-Gary-1
34712: PPUSH
34713: CALL_OW 88
// if IsOk ( Connie ) then
34717: LD_EXP 55
34721: PPUSH
34722: CALL_OW 302
34726: IFFALSE 34740
// Say ( Connie , D20-Con-1 ) ;
34728: LD_EXP 55
34732: PPUSH
34733: LD_STRING D20-Con-1
34735: PPUSH
34736: CALL_OW 88
// if IsOk ( Kurt ) then
34740: LD_EXP 61
34744: PPUSH
34745: CALL_OW 302
34749: IFFALSE 34763
// Say ( Kurt , D20-Kurt-1 ) ;
34751: LD_EXP 61
34755: PPUSH
34756: LD_STRING D20-Kurt-1
34758: PPUSH
34759: CALL_OW 88
// if IsOk ( Kikuchi ) then
34763: LD_EXP 54
34767: PPUSH
34768: CALL_OW 302
34772: IFFALSE 34786
// Say ( Kikuchi , D20-Yam-1 ) ;
34774: LD_EXP 54
34778: PPUSH
34779: LD_STRING D20-Yam-1
34781: PPUSH
34782: CALL_OW 88
// if IsOk ( Frank ) then
34786: LD_EXP 53
34790: PPUSH
34791: CALL_OW 302
34795: IFFALSE 34809
// Say ( Frank , D20-Frank-1 ) ;
34797: LD_EXP 53
34801: PPUSH
34802: LD_STRING D20-Frank-1
34804: PPUSH
34805: CALL_OW 88
// DialogueOff ;
34809: CALL_OW 7
// if RothCaptured then
34813: LD_EXP 33
34817: IFFALSE 34839
// begin m1 := true ;
34819: LD_ADDR_VAR 0 1
34823: PUSH
34824: LD_INT 1
34826: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
34827: LD_STRING Roth
34829: PPUSH
34830: LD_INT 1
34832: PPUSH
34833: CALL_OW 101
// end else
34837: GO 34850
// AddMedal ( Roth , - 1 ) ;
34839: LD_STRING Roth
34841: PPUSH
34842: LD_INT 1
34844: NEG
34845: PPUSH
34846: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish then
34850: LD_EXP 25
34854: NOT
34855: PUSH
34856: LD_EXP 27
34860: OR
34861: IFFALSE 34883
// begin m2 := true ;
34863: LD_ADDR_VAR 0 2
34867: PUSH
34868: LD_INT 1
34870: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
34871: LD_STRING Project
34873: PPUSH
34874: LD_INT 1
34876: PPUSH
34877: CALL_OW 101
// end else
34881: GO 34894
// AddMedal ( Project , - 1 ) ;
34883: LD_STRING Project
34885: PPUSH
34886: LD_INT 1
34888: NEG
34889: PPUSH
34890: CALL_OW 101
// if lostCounter = 0 then
34894: LD_EXP 32
34898: PUSH
34899: LD_INT 0
34901: EQUAL
34902: IFFALSE 34924
// begin m3 := true ;
34904: LD_ADDR_VAR 0 3
34908: PUSH
34909: LD_INT 1
34911: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
34912: LD_STRING NoLosses
34914: PPUSH
34915: LD_INT 1
34917: PPUSH
34918: CALL_OW 101
// end else
34922: GO 34935
// AddMedal ( NoLosses , - 1 ) ;
34924: LD_STRING NoLosses
34926: PPUSH
34927: LD_INT 1
34929: NEG
34930: PPUSH
34931: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
34935: LD_VAR 0 1
34939: PUSH
34940: LD_VAR 0 2
34944: AND
34945: PUSH
34946: LD_VAR 0 3
34950: AND
34951: PUSH
34952: LD_OWVAR 67
34956: PUSH
34957: LD_INT 3
34959: GREATEREQUAL
34960: AND
34961: IFFALSE 34973
// SetAchievementEX ( ACH_AMER , 15 ) ;
34963: LD_STRING ACH_AMER
34965: PPUSH
34966: LD_INT 15
34968: PPUSH
34969: CALL_OW 564
// GiveMedals ( MAIN ) ;
34973: LD_STRING MAIN
34975: PPUSH
34976: CALL_OW 102
// music_class := 4 ;
34980: LD_ADDR_OWVAR 72
34984: PUSH
34985: LD_INT 4
34987: ST_TO_ADDR
// music_nat := 1 ;
34988: LD_ADDR_OWVAR 71
34992: PUSH
34993: LD_INT 1
34995: ST_TO_ADDR
// YouWin ;
34996: CALL_OW 103
// end ; end_of_file
35000: PPOPN 3
35002: END
// export function CustomEvent ( event ) ; begin
35003: LD_INT 0
35005: PPUSH
// end ;
35006: LD_VAR 0 2
35010: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
35011: LD_VAR 0 1
35015: PUSH
35016: LD_INT 1
35018: EQUAL
35019: PUSH
35020: LD_VAR 0 2
35024: PUSH
35025: LD_INT 4
35027: EQUAL
35028: AND
35029: PUSH
35030: LD_EXP 59
35034: PPUSH
35035: CALL_OW 300
35039: AND
35040: IFFALSE 35056
// begin wait ( 0 0$2 ) ;
35042: LD_INT 70
35044: PPUSH
35045: CALL_OW 67
// YouLost ( Dismissed ) ;
35049: LD_STRING Dismissed
35051: PPUSH
35052: CALL_OW 104
// end ; end ;
35056: PPOPN 2
35058: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
35059: LD_VAR 0 2
35063: PPUSH
35064: LD_VAR 0 3
35068: PPUSH
35069: LD_INT 18
35071: PPUSH
35072: CALL_OW 309
35076: IFFALSE 35085
// YouLost ( Motherlode3 ) ;
35078: LD_STRING Motherlode3
35080: PPUSH
35081: CALL_OW 104
// end ;
35085: PPOPN 3
35087: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
35088: LD_EXP 27
35092: NOT
35093: IFFALSE 35103
// behemothDone := true ;
35095: LD_ADDR_EXP 28
35099: PUSH
35100: LD_INT 1
35102: ST_TO_ADDR
// end ;
35103: PPOPN 1
35105: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
35106: LD_VAR 0 1
35110: PPUSH
35111: CALL_OW 255
35115: PUSH
35116: LD_INT 1
35118: EQUAL
35119: IFFALSE 35129
// bombExploded := true ;
35121: LD_ADDR_EXP 37
35125: PUSH
35126: LD_INT 1
35128: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
35129: LD_VAR 0 1
35133: PPUSH
35134: CALL_OW 255
35138: PUSH
35139: LD_INT 3
35141: EQUAL
35142: IFFALSE 35172
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
35144: LD_INT 2
35146: PPUSH
35147: LD_INT 23
35149: PUSH
35150: LD_INT 3
35152: PUSH
35153: LD_INT 3
35155: PUSH
35156: LD_INT 48
35158: PUSH
35159: EMPTY
35160: LIST
35161: LIST
35162: LIST
35163: LIST
35164: PUSH
35165: EMPTY
35166: LIST
35167: PPUSH
35168: CALL 60947 0 2
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
35172: LD_VAR 0 1
35176: PPUSH
35177: CALL_OW 255
35181: PUSH
35182: LD_INT 1
35184: EQUAL
35185: PUSH
35186: LD_EXP 30
35190: AND
35191: PUSH
35192: LD_INT 22
35194: PUSH
35195: LD_INT 3
35197: PUSH
35198: EMPTY
35199: LIST
35200: LIST
35201: PUSH
35202: LD_INT 34
35204: PUSH
35205: LD_INT 48
35207: PUSH
35208: EMPTY
35209: LIST
35210: LIST
35211: PUSH
35212: EMPTY
35213: LIST
35214: LIST
35215: PPUSH
35216: CALL_OW 69
35220: AND
35221: PUSH
35222: LD_INT 22
35224: PUSH
35225: LD_INT 1
35227: PUSH
35228: EMPTY
35229: LIST
35230: LIST
35231: PUSH
35232: LD_INT 34
35234: PUSH
35235: LD_INT 8
35237: PUSH
35238: EMPTY
35239: LIST
35240: LIST
35241: PUSH
35242: EMPTY
35243: LIST
35244: LIST
35245: PPUSH
35246: CALL_OW 69
35250: NOT
35251: AND
35252: IFFALSE 35304
// begin wait ( 0 0$5 ) ;
35254: LD_INT 175
35256: PPUSH
35257: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
35261: LD_INT 22
35263: PUSH
35264: LD_INT 3
35266: PUSH
35267: EMPTY
35268: LIST
35269: LIST
35270: PUSH
35271: LD_INT 34
35273: PUSH
35274: LD_INT 48
35276: PUSH
35277: EMPTY
35278: LIST
35279: LIST
35280: PUSH
35281: EMPTY
35282: LIST
35283: LIST
35284: PPUSH
35285: CALL_OW 69
35289: PUSH
35290: LD_INT 1
35292: ARRAY
35293: PPUSH
35294: LD_INT 60
35296: PPUSH
35297: LD_INT 95
35299: PPUSH
35300: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
35304: LD_VAR 0 2
35308: PPUSH
35309: LD_VAR 0 3
35313: PPUSH
35314: LD_INT 18
35316: PPUSH
35317: CALL_OW 309
35321: PUSH
35322: LD_VAR 0 2
35326: PPUSH
35327: LD_VAR 0 3
35331: PPUSH
35332: LD_INT 18
35334: PPUSH
35335: CALL 108593 0 3
35339: OR
35340: IFFALSE 35387
// begin if GetSide ( unit ) = 1 then
35342: LD_VAR 0 1
35346: PPUSH
35347: CALL_OW 255
35351: PUSH
35352: LD_INT 1
35354: EQUAL
35355: IFFALSE 35373
// begin wait ( 0 0$6 ) ;
35357: LD_INT 210
35359: PPUSH
35360: CALL_OW 67
// YouLost ( Motherlode2 ) ;
35364: LD_STRING Motherlode2
35366: PPUSH
35367: CALL_OW 104
// end else
35371: GO 35387
// begin wait ( 0 0$6 ) ;
35373: LD_INT 210
35375: PPUSH
35376: CALL_OW 67
// YouLost ( Motherlode1 ) ;
35380: LD_STRING Motherlode1
35382: PPUSH
35383: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
35387: LD_VAR 0 1
35391: PPUSH
35392: CALL_OW 255
35396: PUSH
35397: LD_INT 3
35399: EQUAL
35400: IFFALSE 35421
// begin wait ( 0 0$5 ) ;
35402: LD_INT 175
35404: PPUSH
35405: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
35409: LD_EXP 65
35413: PPUSH
35414: LD_STRING D18-Pla-1
35416: PPUSH
35417: CALL_OW 94
// end ; end ;
35421: PPOPN 3
35423: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
35424: LD_VAR 0 1
35428: PPUSH
35429: CALL 124352 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
35433: LD_VAR 0 1
35437: PUSH
35438: LD_INT 22
35440: PUSH
35441: LD_INT 1
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 21
35450: PUSH
35451: LD_INT 1
35453: PUSH
35454: EMPTY
35455: LIST
35456: LIST
35457: PUSH
35458: LD_INT 23
35460: PUSH
35461: LD_INT 1
35463: PUSH
35464: EMPTY
35465: LIST
35466: LIST
35467: PUSH
35468: EMPTY
35469: LIST
35470: LIST
35471: LIST
35472: PPUSH
35473: CALL_OW 69
35477: IN
35478: IFFALSE 35494
// lostCounter := lostCounter + 1 ;
35480: LD_ADDR_EXP 32
35484: PUSH
35485: LD_EXP 32
35489: PUSH
35490: LD_INT 1
35492: PLUS
35493: ST_TO_ADDR
// if un in behemothBuilders then
35494: LD_VAR 0 1
35498: PUSH
35499: LD_EXP 74
35503: IN
35504: IFFALSE 35524
// begin behemothBuilders := behemothBuilders diff un ;
35506: LD_ADDR_EXP 74
35510: PUSH
35511: LD_EXP 74
35515: PUSH
35516: LD_VAR 0 1
35520: DIFF
35521: ST_TO_ADDR
// exit ;
35522: GO 35554
// end ; if un = JMM then
35524: LD_VAR 0 1
35528: PUSH
35529: LD_EXP 40
35533: EQUAL
35534: IFFALSE 35545
// begin YouLost ( JMM ) ;
35536: LD_STRING JMM
35538: PPUSH
35539: CALL_OW 104
// exit ;
35543: GO 35554
// end ; MCE_UnitDestroyed ( un ) ;
35545: LD_VAR 0 1
35549: PPUSH
35550: CALL 64351 0 1
// end ;
35554: PPOPN 1
35556: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
35557: LD_VAR 0 1
35561: PPUSH
35562: LD_VAR 0 2
35566: PPUSH
35567: CALL 66683 0 2
// end ;
35571: PPOPN 2
35573: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
35574: LD_VAR 0 1
35578: PPUSH
35579: CALL 65751 0 1
// end ;
35583: PPOPN 1
35585: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
35586: LD_VAR 0 1
35590: PUSH
35591: LD_INT 22
35593: PUSH
35594: LD_INT 8
35596: PUSH
35597: EMPTY
35598: LIST
35599: LIST
35600: PUSH
35601: LD_INT 30
35603: PUSH
35604: LD_INT 2
35606: PUSH
35607: EMPTY
35608: LIST
35609: LIST
35610: PUSH
35611: LD_INT 23
35613: PUSH
35614: LD_INT 3
35616: PUSH
35617: EMPTY
35618: LIST
35619: LIST
35620: PUSH
35621: EMPTY
35622: LIST
35623: LIST
35624: LIST
35625: PPUSH
35626: CALL_OW 69
35630: IN
35631: IFFALSE 35658
// begin ComUpgrade ( building ) ;
35633: LD_VAR 0 1
35637: PPUSH
35638: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
35642: LD_EXP 62
35646: PPUSH
35647: LD_VAR 0 1
35651: PPUSH
35652: CALL 75333 0 2
// exit ;
35656: GO 35667
// end ; MCE_BuildingComplete ( building ) ;
35658: LD_VAR 0 1
35662: PPUSH
35663: CALL 65992 0 1
// end ;
35667: PPOPN 1
35669: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
35670: LD_VAR 0 1
35674: PPUSH
35675: LD_VAR 0 2
35679: PPUSH
35680: CALL 64047 0 2
// end ;
35684: PPOPN 2
35686: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
35687: LD_VAR 0 1
35691: PPUSH
35692: LD_VAR 0 2
35696: PPUSH
35697: LD_VAR 0 3
35701: PPUSH
35702: LD_VAR 0 4
35706: PPUSH
35707: LD_VAR 0 5
35711: PPUSH
35712: CALL 63667 0 5
// end ;
35716: PPOPN 5
35718: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
35719: LD_VAR 0 1
35723: PPUSH
35724: CALL_OW 255
35728: PUSH
35729: LD_INT 1
35731: EQUAL
35732: IFFALSE 35749
// amConstructCounter := Inc ( amConstructCounter ) ;
35734: LD_ADDR_EXP 39
35738: PUSH
35739: LD_EXP 39
35743: PPUSH
35744: CALL 106145 0 1
35748: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
35749: LD_VAR 0 1
35753: PPUSH
35754: LD_VAR 0 2
35758: PPUSH
35759: CALL 124472 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
35763: LD_VAR 0 1
35767: PPUSH
35768: LD_VAR 0 2
35772: PPUSH
35773: CALL 63258 0 2
// end ;
35777: PPOPN 2
35779: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
35780: LD_VAR 0 1
35784: PPUSH
35785: LD_VAR 0 2
35789: PPUSH
35790: LD_VAR 0 3
35794: PPUSH
35795: LD_VAR 0 4
35799: PPUSH
35800: CALL 63096 0 4
// end ;
35804: PPOPN 4
35806: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
35807: LD_VAR 0 1
35811: PPUSH
35812: LD_VAR 0 2
35816: PPUSH
35817: LD_VAR 0 3
35821: PPUSH
35822: CALL 62871 0 3
// end ;
35826: PPOPN 3
35828: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
35829: LD_VAR 0 1
35833: PPUSH
35834: LD_VAR 0 2
35838: PPUSH
35839: CALL 62756 0 2
// end ;
35843: PPOPN 2
35845: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
35846: LD_VAR 0 1
35850: PPUSH
35851: LD_VAR 0 2
35855: PPUSH
35856: CALL 66978 0 2
// end ;
35860: PPOPN 2
35862: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
35863: LD_VAR 0 1
35867: PPUSH
35868: CALL_OW 255
35872: PUSH
35873: LD_INT 4
35875: EQUAL
35876: PUSH
35877: LD_VAR 0 1
35881: PUSH
35882: LD_EXP 18
35886: PUSH
35887: LD_INT 1
35889: ARRAY
35890: IN
35891: AND
35892: PUSH
35893: LD_EXP 19
35897: AND
35898: IFFALSE 35917
// begin ComMoveXY ( driver , 61 , 93 ) ;
35900: LD_VAR 0 1
35904: PPUSH
35905: LD_INT 61
35907: PPUSH
35908: LD_INT 93
35910: PPUSH
35911: CALL_OW 111
// exit ;
35915: GO 35941
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
35917: LD_VAR 0 1
35921: PPUSH
35922: LD_VAR 0 2
35926: PPUSH
35927: LD_VAR 0 3
35931: PPUSH
35932: LD_VAR 0 4
35936: PPUSH
35937: CALL 67194 0 4
// end ;
35941: PPOPN 4
35943: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
35944: LD_VAR 0 1
35948: PPUSH
35949: LD_VAR 0 2
35953: PPUSH
35954: CALL 62565 0 2
// end ;
35958: PPOPN 2
35960: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
35961: LD_VAR 0 1
35965: PPUSH
35966: CALL 124456 0 1
// end ; end_of_file
35970: PPOPN 1
35972: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
35973: LD_EXP 15
35977: PUSH
35978: LD_INT 2
35980: EQUAL
35981: IFFALSE 36484
35983: GO 35985
35985: DISABLE
35986: LD_INT 0
35988: PPUSH
35989: PPUSH
// begin time := 0 0$35 ;
35990: LD_ADDR_VAR 0 2
35994: PUSH
35995: LD_INT 1225
35997: ST_TO_ADDR
// repeat wait ( time ) ;
35998: LD_VAR 0 2
36002: PPUSH
36003: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
36007: LD_INT 1
36009: PPUSH
36010: LD_INT 5
36012: PPUSH
36013: CALL_OW 12
36017: PPUSH
36018: LD_INT 106
36020: PPUSH
36021: LD_INT 150
36023: PPUSH
36024: LD_INT 19
36026: PPUSH
36027: LD_INT 1
36029: PPUSH
36030: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
36034: LD_INT 455
36036: PPUSH
36037: LD_INT 770
36039: PPUSH
36040: CALL_OW 12
36044: PPUSH
36045: CALL_OW 67
// if Prob ( 50 ) then
36049: LD_INT 50
36051: PPUSH
36052: CALL_OW 13
36056: IFFALSE 36085
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
36058: LD_INT 1
36060: PPUSH
36061: LD_INT 5
36063: PPUSH
36064: CALL_OW 12
36068: PPUSH
36069: LD_INT 62
36071: PPUSH
36072: LD_INT 108
36074: PPUSH
36075: LD_INT 10
36077: PPUSH
36078: LD_INT 1
36080: PPUSH
36081: CALL_OW 56
// until missionStage > 4 ;
36085: LD_EXP 15
36089: PUSH
36090: LD_INT 4
36092: GREATER
36093: IFFALSE 35998
// repeat wait ( 0 0$1 ) ;
36095: LD_INT 35
36097: PPUSH
36098: CALL_OW 67
// until missionStage = 6 ;
36102: LD_EXP 15
36106: PUSH
36107: LD_INT 6
36109: EQUAL
36110: IFFALSE 36095
// time := 0 0$20 ;
36112: LD_ADDR_VAR 0 2
36116: PUSH
36117: LD_INT 700
36119: ST_TO_ADDR
// repeat wait ( time ) ;
36120: LD_VAR 0 2
36124: PPUSH
36125: CALL_OW 67
// if Prob ( 90 ) then
36129: LD_INT 90
36131: PPUSH
36132: CALL_OW 13
36136: IFFALSE 36179
// begin time := time + 0 0$2 ;
36138: LD_ADDR_VAR 0 2
36142: PUSH
36143: LD_VAR 0 2
36147: PUSH
36148: LD_INT 70
36150: PLUS
36151: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
36152: LD_INT 1
36154: PPUSH
36155: LD_INT 5
36157: PPUSH
36158: CALL_OW 12
36162: PPUSH
36163: LD_INT 106
36165: PPUSH
36166: LD_INT 89
36168: PPUSH
36169: LD_INT 45
36171: PPUSH
36172: LD_INT 1
36174: PPUSH
36175: CALL_OW 56
// end ; if Prob ( 45 ) then
36179: LD_INT 45
36181: PPUSH
36182: CALL_OW 13
36186: IFFALSE 36242
// begin for i := 1 to 4 do
36188: LD_ADDR_VAR 0 1
36192: PUSH
36193: DOUBLE
36194: LD_INT 1
36196: DEC
36197: ST_TO_ADDR
36198: LD_INT 4
36200: PUSH
36201: FOR_TO
36202: IFFALSE 36240
// begin wait ( 0 0$5 ) ;
36204: LD_INT 175
36206: PPUSH
36207: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
36211: LD_INT 1
36213: PPUSH
36214: LD_INT 5
36216: PPUSH
36217: CALL_OW 12
36221: PPUSH
36222: LD_INT 113
36224: PPUSH
36225: LD_INT 117
36227: PPUSH
36228: LD_INT 25
36230: PPUSH
36231: LD_INT 1
36233: PPUSH
36234: CALL_OW 56
// end ;
36238: GO 36201
36240: POP
36241: POP
// end ; if Prob ( 40 ) then
36242: LD_INT 40
36244: PPUSH
36245: CALL_OW 13
36249: IFFALSE 36295
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
36251: LD_INT 385
36253: PPUSH
36254: LD_INT 945
36256: PPUSH
36257: CALL_OW 12
36261: PPUSH
36262: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
36266: LD_INT 1
36268: PPUSH
36269: LD_INT 5
36271: PPUSH
36272: CALL_OW 12
36276: PPUSH
36277: LD_INT 21
36279: PPUSH
36280: LD_INT 26
36282: PPUSH
36283: LD_INT 12
36285: PPUSH
36286: LD_INT 1
36288: PPUSH
36289: CALL_OW 56
// end else
36293: GO 36331
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
36295: LD_INT 700
36297: PPUSH
36298: LD_INT 1225
36300: PPUSH
36301: CALL_OW 12
36305: PPUSH
36306: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
36310: LD_INT 1
36312: PPUSH
36313: LD_INT 5
36315: PPUSH
36316: CALL_OW 12
36320: PPUSH
36321: LD_INT 16
36323: PPUSH
36324: LD_INT 1
36326: PPUSH
36327: CALL_OW 55
// end ; if Prob ( 50 ) then
36331: LD_INT 50
36333: PPUSH
36334: CALL_OW 13
36338: IFFALSE 36384
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
36340: LD_INT 700
36342: PPUSH
36343: LD_INT 1050
36345: PPUSH
36346: CALL_OW 12
36350: PPUSH
36351: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
36355: LD_INT 1
36357: PPUSH
36358: LD_INT 5
36360: PPUSH
36361: CALL_OW 12
36365: PPUSH
36366: LD_INT 168
36368: PPUSH
36369: LD_INT 168
36371: PPUSH
36372: LD_INT 16
36374: PPUSH
36375: LD_INT 1
36377: PPUSH
36378: CALL_OW 56
// end else
36382: GO 36420
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
36384: LD_INT 350
36386: PPUSH
36387: LD_INT 525
36389: PPUSH
36390: CALL_OW 12
36394: PPUSH
36395: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
36399: LD_INT 1
36401: PPUSH
36402: LD_INT 5
36404: PPUSH
36405: CALL_OW 12
36409: PPUSH
36410: LD_INT 15
36412: PPUSH
36413: LD_INT 1
36415: PPUSH
36416: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
36420: LD_INT 175
36422: PPUSH
36423: LD_INT 315
36425: PPUSH
36426: CALL_OW 12
36430: PPUSH
36431: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
36435: LD_INT 1
36437: PPUSH
36438: LD_INT 5
36440: PPUSH
36441: CALL_OW 12
36445: PPUSH
36446: LD_INT 103
36448: PPUSH
36449: LD_INT 140
36451: PPUSH
36452: LD_INT 20
36454: PPUSH
36455: LD_INT 1
36457: PPUSH
36458: CALL_OW 56
// if time > 1 1$10 then
36462: LD_VAR 0 2
36466: PUSH
36467: LD_INT 2450
36469: GREATER
36470: IFFALSE 36480
// time := 0 0$30 ;
36472: LD_ADDR_VAR 0 2
36476: PUSH
36477: LD_INT 1050
36479: ST_TO_ADDR
// until false ;
36480: LD_INT 0
36482: IFFALSE 36120
// end ; end_of_file
36484: PPOPN 2
36486: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
36487: LD_EXP 13
36491: PUSH
36492: LD_EXP 15
36496: PUSH
36497: LD_INT 6
36499: GREATEREQUAL
36500: AND
36501: IFFALSE 36538
36503: GO 36505
36505: DISABLE
// begin enable ;
36506: ENABLE
// missionTime := missionTime + 0 0$1 ;
36507: LD_ADDR_EXP 14
36511: PUSH
36512: LD_EXP 14
36516: PUSH
36517: LD_INT 35
36519: PLUS
36520: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
36521: LD_ADDR_OWVAR 47
36525: PUSH
36526: LD_STRING #Am15-1
36528: PUSH
36529: LD_EXP 14
36533: PUSH
36534: EMPTY
36535: LIST
36536: LIST
36537: ST_TO_ADDR
// end ; end_of_file
36538: END
// export function InitNature ; begin
36539: LD_INT 0
36541: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
36542: LD_INT 3
36544: PPUSH
36545: LD_INT 3
36547: PPUSH
36548: LD_INT 2
36550: PPUSH
36551: LD_INT 1
36553: PPUSH
36554: LD_INT 1
36556: PPUSH
36557: LD_INT 0
36559: PPUSH
36560: LD_INT 0
36562: PPUSH
36563: LD_INT 20
36565: PPUSH
36566: LD_INT 0
36568: PPUSH
36569: CALL 101466 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
36573: LD_INT 2
36575: PPUSH
36576: LD_INT 1
36578: PPUSH
36579: LD_INT 1
36581: PPUSH
36582: LD_INT 1
36584: PPUSH
36585: LD_INT 1
36587: PPUSH
36588: LD_INT 0
36590: PPUSH
36591: LD_INT 0
36593: PPUSH
36594: LD_INT 21
36596: PPUSH
36597: LD_INT 0
36599: PPUSH
36600: CALL 101466 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
36604: LD_INT 4
36606: PPUSH
36607: LD_INT 1
36609: PPUSH
36610: LD_INT 2
36612: PPUSH
36613: LD_INT 4
36615: PPUSH
36616: LD_INT 2
36618: PPUSH
36619: LD_INT 1
36621: PPUSH
36622: LD_INT 0
36624: PPUSH
36625: LD_INT 22
36627: PPUSH
36628: LD_INT 0
36630: PPUSH
36631: CALL 101466 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
36635: LD_INT 0
36637: PPUSH
36638: LD_INT 0
36640: PPUSH
36641: LD_INT 0
36643: PPUSH
36644: LD_INT 0
36646: PPUSH
36647: LD_INT 0
36649: PPUSH
36650: LD_INT 0
36652: PPUSH
36653: LD_INT 9
36655: PPUSH
36656: LD_INT 0
36658: PPUSH
36659: LD_INT 23
36661: PPUSH
36662: CALL 101466 0 9
// end ; end_of_file
36666: LD_VAR 0 1
36670: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
36671: LD_INT 0
36673: PPUSH
36674: PPUSH
// skirmish := false ;
36675: LD_ADDR_EXP 97
36679: PUSH
36680: LD_INT 0
36682: ST_TO_ADDR
// debug_mc := false ;
36683: LD_ADDR_EXP 98
36687: PUSH
36688: LD_INT 0
36690: ST_TO_ADDR
// mc_bases := [ ] ;
36691: LD_ADDR_EXP 99
36695: PUSH
36696: EMPTY
36697: ST_TO_ADDR
// mc_sides := [ ] ;
36698: LD_ADDR_EXP 125
36702: PUSH
36703: EMPTY
36704: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
36705: LD_ADDR_EXP 100
36709: PUSH
36710: EMPTY
36711: ST_TO_ADDR
// mc_building_repairs := [ ] ;
36712: LD_ADDR_EXP 101
36716: PUSH
36717: EMPTY
36718: ST_TO_ADDR
// mc_need_heal := [ ] ;
36719: LD_ADDR_EXP 102
36723: PUSH
36724: EMPTY
36725: ST_TO_ADDR
// mc_healers := [ ] ;
36726: LD_ADDR_EXP 103
36730: PUSH
36731: EMPTY
36732: ST_TO_ADDR
// mc_build_list := [ ] ;
36733: LD_ADDR_EXP 104
36737: PUSH
36738: EMPTY
36739: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
36740: LD_ADDR_EXP 131
36744: PUSH
36745: EMPTY
36746: ST_TO_ADDR
// mc_builders := [ ] ;
36747: LD_ADDR_EXP 105
36751: PUSH
36752: EMPTY
36753: ST_TO_ADDR
// mc_construct_list := [ ] ;
36754: LD_ADDR_EXP 106
36758: PUSH
36759: EMPTY
36760: ST_TO_ADDR
// mc_turret_list := [ ] ;
36761: LD_ADDR_EXP 107
36765: PUSH
36766: EMPTY
36767: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
36768: LD_ADDR_EXP 108
36772: PUSH
36773: EMPTY
36774: ST_TO_ADDR
// mc_miners := [ ] ;
36775: LD_ADDR_EXP 113
36779: PUSH
36780: EMPTY
36781: ST_TO_ADDR
// mc_mines := [ ] ;
36782: LD_ADDR_EXP 112
36786: PUSH
36787: EMPTY
36788: ST_TO_ADDR
// mc_minefields := [ ] ;
36789: LD_ADDR_EXP 114
36793: PUSH
36794: EMPTY
36795: ST_TO_ADDR
// mc_crates := [ ] ;
36796: LD_ADDR_EXP 115
36800: PUSH
36801: EMPTY
36802: ST_TO_ADDR
// mc_crates_collector := [ ] ;
36803: LD_ADDR_EXP 116
36807: PUSH
36808: EMPTY
36809: ST_TO_ADDR
// mc_crates_area := [ ] ;
36810: LD_ADDR_EXP 117
36814: PUSH
36815: EMPTY
36816: ST_TO_ADDR
// mc_vehicles := [ ] ;
36817: LD_ADDR_EXP 118
36821: PUSH
36822: EMPTY
36823: ST_TO_ADDR
// mc_attack := [ ] ;
36824: LD_ADDR_EXP 119
36828: PUSH
36829: EMPTY
36830: ST_TO_ADDR
// mc_produce := [ ] ;
36831: LD_ADDR_EXP 120
36835: PUSH
36836: EMPTY
36837: ST_TO_ADDR
// mc_defender := [ ] ;
36838: LD_ADDR_EXP 121
36842: PUSH
36843: EMPTY
36844: ST_TO_ADDR
// mc_parking := [ ] ;
36845: LD_ADDR_EXP 123
36849: PUSH
36850: EMPTY
36851: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
36852: LD_ADDR_EXP 109
36856: PUSH
36857: EMPTY
36858: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
36859: LD_ADDR_EXP 111
36863: PUSH
36864: EMPTY
36865: ST_TO_ADDR
// mc_scan := [ ] ;
36866: LD_ADDR_EXP 122
36870: PUSH
36871: EMPTY
36872: ST_TO_ADDR
// mc_scan_area := [ ] ;
36873: LD_ADDR_EXP 124
36877: PUSH
36878: EMPTY
36879: ST_TO_ADDR
// mc_tech := [ ] ;
36880: LD_ADDR_EXP 126
36884: PUSH
36885: EMPTY
36886: ST_TO_ADDR
// mc_class := [ ] ;
36887: LD_ADDR_EXP 140
36891: PUSH
36892: EMPTY
36893: ST_TO_ADDR
// mc_class_case_use := [ ] ;
36894: LD_ADDR_EXP 141
36898: PUSH
36899: EMPTY
36900: ST_TO_ADDR
// mc_is_defending := [ ] ;
36901: LD_ADDR_EXP 142
36905: PUSH
36906: EMPTY
36907: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
36908: LD_ADDR_EXP 133
36912: PUSH
36913: EMPTY
36914: ST_TO_ADDR
// end ;
36915: LD_VAR 0 1
36919: RET
// export function MC_Kill ( base ) ; begin
36920: LD_INT 0
36922: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
36923: LD_ADDR_EXP 99
36927: PUSH
36928: LD_EXP 99
36932: PPUSH
36933: LD_VAR 0 1
36937: PPUSH
36938: EMPTY
36939: PPUSH
36940: CALL_OW 1
36944: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36945: LD_ADDR_EXP 100
36949: PUSH
36950: LD_EXP 100
36954: PPUSH
36955: LD_VAR 0 1
36959: PPUSH
36960: EMPTY
36961: PPUSH
36962: CALL_OW 1
36966: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36967: LD_ADDR_EXP 101
36971: PUSH
36972: LD_EXP 101
36976: PPUSH
36977: LD_VAR 0 1
36981: PPUSH
36982: EMPTY
36983: PPUSH
36984: CALL_OW 1
36988: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36989: LD_ADDR_EXP 102
36993: PUSH
36994: LD_EXP 102
36998: PPUSH
36999: LD_VAR 0 1
37003: PPUSH
37004: EMPTY
37005: PPUSH
37006: CALL_OW 1
37010: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
37011: LD_ADDR_EXP 103
37015: PUSH
37016: LD_EXP 103
37020: PPUSH
37021: LD_VAR 0 1
37025: PPUSH
37026: EMPTY
37027: PPUSH
37028: CALL_OW 1
37032: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
37033: LD_ADDR_EXP 104
37037: PUSH
37038: LD_EXP 104
37042: PPUSH
37043: LD_VAR 0 1
37047: PPUSH
37048: EMPTY
37049: PPUSH
37050: CALL_OW 1
37054: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
37055: LD_ADDR_EXP 105
37059: PUSH
37060: LD_EXP 105
37064: PPUSH
37065: LD_VAR 0 1
37069: PPUSH
37070: EMPTY
37071: PPUSH
37072: CALL_OW 1
37076: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
37077: LD_ADDR_EXP 106
37081: PUSH
37082: LD_EXP 106
37086: PPUSH
37087: LD_VAR 0 1
37091: PPUSH
37092: EMPTY
37093: PPUSH
37094: CALL_OW 1
37098: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
37099: LD_ADDR_EXP 107
37103: PUSH
37104: LD_EXP 107
37108: PPUSH
37109: LD_VAR 0 1
37113: PPUSH
37114: EMPTY
37115: PPUSH
37116: CALL_OW 1
37120: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
37121: LD_ADDR_EXP 108
37125: PUSH
37126: LD_EXP 108
37130: PPUSH
37131: LD_VAR 0 1
37135: PPUSH
37136: EMPTY
37137: PPUSH
37138: CALL_OW 1
37142: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
37143: LD_ADDR_EXP 109
37147: PUSH
37148: LD_EXP 109
37152: PPUSH
37153: LD_VAR 0 1
37157: PPUSH
37158: EMPTY
37159: PPUSH
37160: CALL_OW 1
37164: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
37165: LD_ADDR_EXP 110
37169: PUSH
37170: LD_EXP 110
37174: PPUSH
37175: LD_VAR 0 1
37179: PPUSH
37180: LD_INT 0
37182: PPUSH
37183: CALL_OW 1
37187: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
37188: LD_ADDR_EXP 111
37192: PUSH
37193: LD_EXP 111
37197: PPUSH
37198: LD_VAR 0 1
37202: PPUSH
37203: EMPTY
37204: PPUSH
37205: CALL_OW 1
37209: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
37210: LD_ADDR_EXP 112
37214: PUSH
37215: LD_EXP 112
37219: PPUSH
37220: LD_VAR 0 1
37224: PPUSH
37225: EMPTY
37226: PPUSH
37227: CALL_OW 1
37231: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
37232: LD_ADDR_EXP 113
37236: PUSH
37237: LD_EXP 113
37241: PPUSH
37242: LD_VAR 0 1
37246: PPUSH
37247: EMPTY
37248: PPUSH
37249: CALL_OW 1
37253: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
37254: LD_ADDR_EXP 114
37258: PUSH
37259: LD_EXP 114
37263: PPUSH
37264: LD_VAR 0 1
37268: PPUSH
37269: EMPTY
37270: PPUSH
37271: CALL_OW 1
37275: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
37276: LD_ADDR_EXP 115
37280: PUSH
37281: LD_EXP 115
37285: PPUSH
37286: LD_VAR 0 1
37290: PPUSH
37291: EMPTY
37292: PPUSH
37293: CALL_OW 1
37297: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
37298: LD_ADDR_EXP 116
37302: PUSH
37303: LD_EXP 116
37307: PPUSH
37308: LD_VAR 0 1
37312: PPUSH
37313: EMPTY
37314: PPUSH
37315: CALL_OW 1
37319: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
37320: LD_ADDR_EXP 117
37324: PUSH
37325: LD_EXP 117
37329: PPUSH
37330: LD_VAR 0 1
37334: PPUSH
37335: EMPTY
37336: PPUSH
37337: CALL_OW 1
37341: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
37342: LD_ADDR_EXP 118
37346: PUSH
37347: LD_EXP 118
37351: PPUSH
37352: LD_VAR 0 1
37356: PPUSH
37357: EMPTY
37358: PPUSH
37359: CALL_OW 1
37363: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
37364: LD_ADDR_EXP 119
37368: PUSH
37369: LD_EXP 119
37373: PPUSH
37374: LD_VAR 0 1
37378: PPUSH
37379: EMPTY
37380: PPUSH
37381: CALL_OW 1
37385: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
37386: LD_ADDR_EXP 120
37390: PUSH
37391: LD_EXP 120
37395: PPUSH
37396: LD_VAR 0 1
37400: PPUSH
37401: EMPTY
37402: PPUSH
37403: CALL_OW 1
37407: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
37408: LD_ADDR_EXP 121
37412: PUSH
37413: LD_EXP 121
37417: PPUSH
37418: LD_VAR 0 1
37422: PPUSH
37423: EMPTY
37424: PPUSH
37425: CALL_OW 1
37429: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
37430: LD_ADDR_EXP 122
37434: PUSH
37435: LD_EXP 122
37439: PPUSH
37440: LD_VAR 0 1
37444: PPUSH
37445: EMPTY
37446: PPUSH
37447: CALL_OW 1
37451: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
37452: LD_ADDR_EXP 123
37456: PUSH
37457: LD_EXP 123
37461: PPUSH
37462: LD_VAR 0 1
37466: PPUSH
37467: EMPTY
37468: PPUSH
37469: CALL_OW 1
37473: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
37474: LD_ADDR_EXP 124
37478: PUSH
37479: LD_EXP 124
37483: PPUSH
37484: LD_VAR 0 1
37488: PPUSH
37489: EMPTY
37490: PPUSH
37491: CALL_OW 1
37495: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
37496: LD_ADDR_EXP 126
37500: PUSH
37501: LD_EXP 126
37505: PPUSH
37506: LD_VAR 0 1
37510: PPUSH
37511: EMPTY
37512: PPUSH
37513: CALL_OW 1
37517: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
37518: LD_ADDR_EXP 128
37522: PUSH
37523: LD_EXP 128
37527: PPUSH
37528: LD_VAR 0 1
37532: PPUSH
37533: EMPTY
37534: PPUSH
37535: CALL_OW 1
37539: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
37540: LD_ADDR_EXP 129
37544: PUSH
37545: LD_EXP 129
37549: PPUSH
37550: LD_VAR 0 1
37554: PPUSH
37555: EMPTY
37556: PPUSH
37557: CALL_OW 1
37561: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
37562: LD_ADDR_EXP 130
37566: PUSH
37567: LD_EXP 130
37571: PPUSH
37572: LD_VAR 0 1
37576: PPUSH
37577: EMPTY
37578: PPUSH
37579: CALL_OW 1
37583: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
37584: LD_ADDR_EXP 131
37588: PUSH
37589: LD_EXP 131
37593: PPUSH
37594: LD_VAR 0 1
37598: PPUSH
37599: EMPTY
37600: PPUSH
37601: CALL_OW 1
37605: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
37606: LD_ADDR_EXP 132
37610: PUSH
37611: LD_EXP 132
37615: PPUSH
37616: LD_VAR 0 1
37620: PPUSH
37621: EMPTY
37622: PPUSH
37623: CALL_OW 1
37627: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37628: LD_ADDR_EXP 133
37632: PUSH
37633: LD_EXP 133
37637: PPUSH
37638: LD_VAR 0 1
37642: PPUSH
37643: EMPTY
37644: PPUSH
37645: CALL_OW 1
37649: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37650: LD_ADDR_EXP 134
37654: PUSH
37655: LD_EXP 134
37659: PPUSH
37660: LD_VAR 0 1
37664: PPUSH
37665: EMPTY
37666: PPUSH
37667: CALL_OW 1
37671: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37672: LD_ADDR_EXP 135
37676: PUSH
37677: LD_EXP 135
37681: PPUSH
37682: LD_VAR 0 1
37686: PPUSH
37687: EMPTY
37688: PPUSH
37689: CALL_OW 1
37693: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37694: LD_ADDR_EXP 136
37698: PUSH
37699: LD_EXP 136
37703: PPUSH
37704: LD_VAR 0 1
37708: PPUSH
37709: EMPTY
37710: PPUSH
37711: CALL_OW 1
37715: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37716: LD_ADDR_EXP 137
37720: PUSH
37721: LD_EXP 137
37725: PPUSH
37726: LD_VAR 0 1
37730: PPUSH
37731: EMPTY
37732: PPUSH
37733: CALL_OW 1
37737: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37738: LD_ADDR_EXP 138
37742: PUSH
37743: LD_EXP 138
37747: PPUSH
37748: LD_VAR 0 1
37752: PPUSH
37753: EMPTY
37754: PPUSH
37755: CALL_OW 1
37759: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37760: LD_ADDR_EXP 139
37764: PUSH
37765: LD_EXP 139
37769: PPUSH
37770: LD_VAR 0 1
37774: PPUSH
37775: EMPTY
37776: PPUSH
37777: CALL_OW 1
37781: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37782: LD_ADDR_EXP 140
37786: PUSH
37787: LD_EXP 140
37791: PPUSH
37792: LD_VAR 0 1
37796: PPUSH
37797: EMPTY
37798: PPUSH
37799: CALL_OW 1
37803: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37804: LD_ADDR_EXP 141
37808: PUSH
37809: LD_EXP 141
37813: PPUSH
37814: LD_VAR 0 1
37818: PPUSH
37819: LD_INT 0
37821: PPUSH
37822: CALL_OW 1
37826: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
37827: LD_ADDR_EXP 142
37831: PUSH
37832: LD_EXP 142
37836: PPUSH
37837: LD_VAR 0 1
37841: PPUSH
37842: LD_INT 0
37844: PPUSH
37845: CALL_OW 1
37849: ST_TO_ADDR
// end ;
37850: LD_VAR 0 2
37854: RET
// export function MC_Add ( side , units ) ; var base ; begin
37855: LD_INT 0
37857: PPUSH
37858: PPUSH
// base := mc_bases + 1 ;
37859: LD_ADDR_VAR 0 4
37863: PUSH
37864: LD_EXP 99
37868: PUSH
37869: LD_INT 1
37871: PLUS
37872: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
37873: LD_ADDR_EXP 125
37877: PUSH
37878: LD_EXP 125
37882: PPUSH
37883: LD_VAR 0 4
37887: PPUSH
37888: LD_VAR 0 1
37892: PPUSH
37893: CALL_OW 1
37897: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
37898: LD_ADDR_EXP 99
37902: PUSH
37903: LD_EXP 99
37907: PPUSH
37908: LD_VAR 0 4
37912: PPUSH
37913: LD_VAR 0 2
37917: PPUSH
37918: CALL_OW 1
37922: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
37923: LD_ADDR_EXP 100
37927: PUSH
37928: LD_EXP 100
37932: PPUSH
37933: LD_VAR 0 4
37937: PPUSH
37938: EMPTY
37939: PPUSH
37940: CALL_OW 1
37944: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
37945: LD_ADDR_EXP 101
37949: PUSH
37950: LD_EXP 101
37954: PPUSH
37955: LD_VAR 0 4
37959: PPUSH
37960: EMPTY
37961: PPUSH
37962: CALL_OW 1
37966: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
37967: LD_ADDR_EXP 102
37971: PUSH
37972: LD_EXP 102
37976: PPUSH
37977: LD_VAR 0 4
37981: PPUSH
37982: EMPTY
37983: PPUSH
37984: CALL_OW 1
37988: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
37989: LD_ADDR_EXP 103
37993: PUSH
37994: LD_EXP 103
37998: PPUSH
37999: LD_VAR 0 4
38003: PPUSH
38004: EMPTY
38005: PPUSH
38006: CALL_OW 1
38010: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
38011: LD_ADDR_EXP 104
38015: PUSH
38016: LD_EXP 104
38020: PPUSH
38021: LD_VAR 0 4
38025: PPUSH
38026: EMPTY
38027: PPUSH
38028: CALL_OW 1
38032: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
38033: LD_ADDR_EXP 105
38037: PUSH
38038: LD_EXP 105
38042: PPUSH
38043: LD_VAR 0 4
38047: PPUSH
38048: EMPTY
38049: PPUSH
38050: CALL_OW 1
38054: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
38055: LD_ADDR_EXP 106
38059: PUSH
38060: LD_EXP 106
38064: PPUSH
38065: LD_VAR 0 4
38069: PPUSH
38070: EMPTY
38071: PPUSH
38072: CALL_OW 1
38076: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
38077: LD_ADDR_EXP 107
38081: PUSH
38082: LD_EXP 107
38086: PPUSH
38087: LD_VAR 0 4
38091: PPUSH
38092: EMPTY
38093: PPUSH
38094: CALL_OW 1
38098: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
38099: LD_ADDR_EXP 108
38103: PUSH
38104: LD_EXP 108
38108: PPUSH
38109: LD_VAR 0 4
38113: PPUSH
38114: EMPTY
38115: PPUSH
38116: CALL_OW 1
38120: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
38121: LD_ADDR_EXP 109
38125: PUSH
38126: LD_EXP 109
38130: PPUSH
38131: LD_VAR 0 4
38135: PPUSH
38136: EMPTY
38137: PPUSH
38138: CALL_OW 1
38142: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
38143: LD_ADDR_EXP 110
38147: PUSH
38148: LD_EXP 110
38152: PPUSH
38153: LD_VAR 0 4
38157: PPUSH
38158: LD_INT 0
38160: PPUSH
38161: CALL_OW 1
38165: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
38166: LD_ADDR_EXP 111
38170: PUSH
38171: LD_EXP 111
38175: PPUSH
38176: LD_VAR 0 4
38180: PPUSH
38181: EMPTY
38182: PPUSH
38183: CALL_OW 1
38187: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
38188: LD_ADDR_EXP 112
38192: PUSH
38193: LD_EXP 112
38197: PPUSH
38198: LD_VAR 0 4
38202: PPUSH
38203: EMPTY
38204: PPUSH
38205: CALL_OW 1
38209: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
38210: LD_ADDR_EXP 113
38214: PUSH
38215: LD_EXP 113
38219: PPUSH
38220: LD_VAR 0 4
38224: PPUSH
38225: EMPTY
38226: PPUSH
38227: CALL_OW 1
38231: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
38232: LD_ADDR_EXP 114
38236: PUSH
38237: LD_EXP 114
38241: PPUSH
38242: LD_VAR 0 4
38246: PPUSH
38247: EMPTY
38248: PPUSH
38249: CALL_OW 1
38253: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
38254: LD_ADDR_EXP 115
38258: PUSH
38259: LD_EXP 115
38263: PPUSH
38264: LD_VAR 0 4
38268: PPUSH
38269: EMPTY
38270: PPUSH
38271: CALL_OW 1
38275: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
38276: LD_ADDR_EXP 116
38280: PUSH
38281: LD_EXP 116
38285: PPUSH
38286: LD_VAR 0 4
38290: PPUSH
38291: EMPTY
38292: PPUSH
38293: CALL_OW 1
38297: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
38298: LD_ADDR_EXP 117
38302: PUSH
38303: LD_EXP 117
38307: PPUSH
38308: LD_VAR 0 4
38312: PPUSH
38313: EMPTY
38314: PPUSH
38315: CALL_OW 1
38319: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
38320: LD_ADDR_EXP 118
38324: PUSH
38325: LD_EXP 118
38329: PPUSH
38330: LD_VAR 0 4
38334: PPUSH
38335: EMPTY
38336: PPUSH
38337: CALL_OW 1
38341: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
38342: LD_ADDR_EXP 119
38346: PUSH
38347: LD_EXP 119
38351: PPUSH
38352: LD_VAR 0 4
38356: PPUSH
38357: EMPTY
38358: PPUSH
38359: CALL_OW 1
38363: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
38364: LD_ADDR_EXP 120
38368: PUSH
38369: LD_EXP 120
38373: PPUSH
38374: LD_VAR 0 4
38378: PPUSH
38379: EMPTY
38380: PPUSH
38381: CALL_OW 1
38385: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
38386: LD_ADDR_EXP 121
38390: PUSH
38391: LD_EXP 121
38395: PPUSH
38396: LD_VAR 0 4
38400: PPUSH
38401: EMPTY
38402: PPUSH
38403: CALL_OW 1
38407: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
38408: LD_ADDR_EXP 122
38412: PUSH
38413: LD_EXP 122
38417: PPUSH
38418: LD_VAR 0 4
38422: PPUSH
38423: EMPTY
38424: PPUSH
38425: CALL_OW 1
38429: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
38430: LD_ADDR_EXP 123
38434: PUSH
38435: LD_EXP 123
38439: PPUSH
38440: LD_VAR 0 4
38444: PPUSH
38445: EMPTY
38446: PPUSH
38447: CALL_OW 1
38451: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
38452: LD_ADDR_EXP 124
38456: PUSH
38457: LD_EXP 124
38461: PPUSH
38462: LD_VAR 0 4
38466: PPUSH
38467: EMPTY
38468: PPUSH
38469: CALL_OW 1
38473: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
38474: LD_ADDR_EXP 126
38478: PUSH
38479: LD_EXP 126
38483: PPUSH
38484: LD_VAR 0 4
38488: PPUSH
38489: EMPTY
38490: PPUSH
38491: CALL_OW 1
38495: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
38496: LD_ADDR_EXP 128
38500: PUSH
38501: LD_EXP 128
38505: PPUSH
38506: LD_VAR 0 4
38510: PPUSH
38511: EMPTY
38512: PPUSH
38513: CALL_OW 1
38517: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
38518: LD_ADDR_EXP 129
38522: PUSH
38523: LD_EXP 129
38527: PPUSH
38528: LD_VAR 0 4
38532: PPUSH
38533: EMPTY
38534: PPUSH
38535: CALL_OW 1
38539: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
38540: LD_ADDR_EXP 130
38544: PUSH
38545: LD_EXP 130
38549: PPUSH
38550: LD_VAR 0 4
38554: PPUSH
38555: EMPTY
38556: PPUSH
38557: CALL_OW 1
38561: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
38562: LD_ADDR_EXP 131
38566: PUSH
38567: LD_EXP 131
38571: PPUSH
38572: LD_VAR 0 4
38576: PPUSH
38577: EMPTY
38578: PPUSH
38579: CALL_OW 1
38583: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
38584: LD_ADDR_EXP 132
38588: PUSH
38589: LD_EXP 132
38593: PPUSH
38594: LD_VAR 0 4
38598: PPUSH
38599: EMPTY
38600: PPUSH
38601: CALL_OW 1
38605: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
38606: LD_ADDR_EXP 133
38610: PUSH
38611: LD_EXP 133
38615: PPUSH
38616: LD_VAR 0 4
38620: PPUSH
38621: EMPTY
38622: PPUSH
38623: CALL_OW 1
38627: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
38628: LD_ADDR_EXP 134
38632: PUSH
38633: LD_EXP 134
38637: PPUSH
38638: LD_VAR 0 4
38642: PPUSH
38643: EMPTY
38644: PPUSH
38645: CALL_OW 1
38649: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
38650: LD_ADDR_EXP 135
38654: PUSH
38655: LD_EXP 135
38659: PPUSH
38660: LD_VAR 0 4
38664: PPUSH
38665: EMPTY
38666: PPUSH
38667: CALL_OW 1
38671: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
38672: LD_ADDR_EXP 136
38676: PUSH
38677: LD_EXP 136
38681: PPUSH
38682: LD_VAR 0 4
38686: PPUSH
38687: EMPTY
38688: PPUSH
38689: CALL_OW 1
38693: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
38694: LD_ADDR_EXP 137
38698: PUSH
38699: LD_EXP 137
38703: PPUSH
38704: LD_VAR 0 4
38708: PPUSH
38709: EMPTY
38710: PPUSH
38711: CALL_OW 1
38715: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
38716: LD_ADDR_EXP 138
38720: PUSH
38721: LD_EXP 138
38725: PPUSH
38726: LD_VAR 0 4
38730: PPUSH
38731: EMPTY
38732: PPUSH
38733: CALL_OW 1
38737: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
38738: LD_ADDR_EXP 139
38742: PUSH
38743: LD_EXP 139
38747: PPUSH
38748: LD_VAR 0 4
38752: PPUSH
38753: EMPTY
38754: PPUSH
38755: CALL_OW 1
38759: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
38760: LD_ADDR_EXP 140
38764: PUSH
38765: LD_EXP 140
38769: PPUSH
38770: LD_VAR 0 4
38774: PPUSH
38775: EMPTY
38776: PPUSH
38777: CALL_OW 1
38781: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
38782: LD_ADDR_EXP 141
38786: PUSH
38787: LD_EXP 141
38791: PPUSH
38792: LD_VAR 0 4
38796: PPUSH
38797: LD_INT 0
38799: PPUSH
38800: CALL_OW 1
38804: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
38805: LD_ADDR_EXP 142
38809: PUSH
38810: LD_EXP 142
38814: PPUSH
38815: LD_VAR 0 4
38819: PPUSH
38820: LD_INT 0
38822: PPUSH
38823: CALL_OW 1
38827: ST_TO_ADDR
// result := base ;
38828: LD_ADDR_VAR 0 3
38832: PUSH
38833: LD_VAR 0 4
38837: ST_TO_ADDR
// end ;
38838: LD_VAR 0 3
38842: RET
// export function MC_Start ( ) ; var i ; begin
38843: LD_INT 0
38845: PPUSH
38846: PPUSH
// for i = 1 to mc_bases do
38847: LD_ADDR_VAR 0 2
38851: PUSH
38852: DOUBLE
38853: LD_INT 1
38855: DEC
38856: ST_TO_ADDR
38857: LD_EXP 99
38861: PUSH
38862: FOR_TO
38863: IFFALSE 39963
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
38865: LD_ADDR_EXP 99
38869: PUSH
38870: LD_EXP 99
38874: PPUSH
38875: LD_VAR 0 2
38879: PPUSH
38880: LD_EXP 99
38884: PUSH
38885: LD_VAR 0 2
38889: ARRAY
38890: PUSH
38891: LD_INT 0
38893: DIFF
38894: PPUSH
38895: CALL_OW 1
38899: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
38900: LD_ADDR_EXP 100
38904: PUSH
38905: LD_EXP 100
38909: PPUSH
38910: LD_VAR 0 2
38914: PPUSH
38915: EMPTY
38916: PPUSH
38917: CALL_OW 1
38921: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
38922: LD_ADDR_EXP 101
38926: PUSH
38927: LD_EXP 101
38931: PPUSH
38932: LD_VAR 0 2
38936: PPUSH
38937: EMPTY
38938: PPUSH
38939: CALL_OW 1
38943: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
38944: LD_ADDR_EXP 102
38948: PUSH
38949: LD_EXP 102
38953: PPUSH
38954: LD_VAR 0 2
38958: PPUSH
38959: EMPTY
38960: PPUSH
38961: CALL_OW 1
38965: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
38966: LD_ADDR_EXP 103
38970: PUSH
38971: LD_EXP 103
38975: PPUSH
38976: LD_VAR 0 2
38980: PPUSH
38981: EMPTY
38982: PUSH
38983: EMPTY
38984: PUSH
38985: EMPTY
38986: LIST
38987: LIST
38988: PPUSH
38989: CALL_OW 1
38993: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
38994: LD_ADDR_EXP 104
38998: PUSH
38999: LD_EXP 104
39003: PPUSH
39004: LD_VAR 0 2
39008: PPUSH
39009: EMPTY
39010: PPUSH
39011: CALL_OW 1
39015: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
39016: LD_ADDR_EXP 131
39020: PUSH
39021: LD_EXP 131
39025: PPUSH
39026: LD_VAR 0 2
39030: PPUSH
39031: EMPTY
39032: PPUSH
39033: CALL_OW 1
39037: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
39038: LD_ADDR_EXP 105
39042: PUSH
39043: LD_EXP 105
39047: PPUSH
39048: LD_VAR 0 2
39052: PPUSH
39053: EMPTY
39054: PPUSH
39055: CALL_OW 1
39059: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
39060: LD_ADDR_EXP 106
39064: PUSH
39065: LD_EXP 106
39069: PPUSH
39070: LD_VAR 0 2
39074: PPUSH
39075: EMPTY
39076: PPUSH
39077: CALL_OW 1
39081: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
39082: LD_ADDR_EXP 107
39086: PUSH
39087: LD_EXP 107
39091: PPUSH
39092: LD_VAR 0 2
39096: PPUSH
39097: LD_EXP 99
39101: PUSH
39102: LD_VAR 0 2
39106: ARRAY
39107: PPUSH
39108: LD_INT 2
39110: PUSH
39111: LD_INT 30
39113: PUSH
39114: LD_INT 32
39116: PUSH
39117: EMPTY
39118: LIST
39119: LIST
39120: PUSH
39121: LD_INT 30
39123: PUSH
39124: LD_INT 33
39126: PUSH
39127: EMPTY
39128: LIST
39129: LIST
39130: PUSH
39131: EMPTY
39132: LIST
39133: LIST
39134: LIST
39135: PPUSH
39136: CALL_OW 72
39140: PPUSH
39141: CALL_OW 1
39145: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
39146: LD_ADDR_EXP 108
39150: PUSH
39151: LD_EXP 108
39155: PPUSH
39156: LD_VAR 0 2
39160: PPUSH
39161: LD_EXP 99
39165: PUSH
39166: LD_VAR 0 2
39170: ARRAY
39171: PPUSH
39172: LD_INT 2
39174: PUSH
39175: LD_INT 30
39177: PUSH
39178: LD_INT 32
39180: PUSH
39181: EMPTY
39182: LIST
39183: LIST
39184: PUSH
39185: LD_INT 30
39187: PUSH
39188: LD_INT 31
39190: PUSH
39191: EMPTY
39192: LIST
39193: LIST
39194: PUSH
39195: EMPTY
39196: LIST
39197: LIST
39198: LIST
39199: PUSH
39200: LD_INT 58
39202: PUSH
39203: EMPTY
39204: LIST
39205: PUSH
39206: EMPTY
39207: LIST
39208: LIST
39209: PPUSH
39210: CALL_OW 72
39214: PPUSH
39215: CALL_OW 1
39219: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
39220: LD_ADDR_EXP 109
39224: PUSH
39225: LD_EXP 109
39229: PPUSH
39230: LD_VAR 0 2
39234: PPUSH
39235: EMPTY
39236: PPUSH
39237: CALL_OW 1
39241: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
39242: LD_ADDR_EXP 113
39246: PUSH
39247: LD_EXP 113
39251: PPUSH
39252: LD_VAR 0 2
39256: PPUSH
39257: EMPTY
39258: PPUSH
39259: CALL_OW 1
39263: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
39264: LD_ADDR_EXP 112
39268: PUSH
39269: LD_EXP 112
39273: PPUSH
39274: LD_VAR 0 2
39278: PPUSH
39279: EMPTY
39280: PPUSH
39281: CALL_OW 1
39285: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
39286: LD_ADDR_EXP 114
39290: PUSH
39291: LD_EXP 114
39295: PPUSH
39296: LD_VAR 0 2
39300: PPUSH
39301: EMPTY
39302: PPUSH
39303: CALL_OW 1
39307: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
39308: LD_ADDR_EXP 115
39312: PUSH
39313: LD_EXP 115
39317: PPUSH
39318: LD_VAR 0 2
39322: PPUSH
39323: EMPTY
39324: PPUSH
39325: CALL_OW 1
39329: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
39330: LD_ADDR_EXP 116
39334: PUSH
39335: LD_EXP 116
39339: PPUSH
39340: LD_VAR 0 2
39344: PPUSH
39345: EMPTY
39346: PPUSH
39347: CALL_OW 1
39351: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
39352: LD_ADDR_EXP 117
39356: PUSH
39357: LD_EXP 117
39361: PPUSH
39362: LD_VAR 0 2
39366: PPUSH
39367: EMPTY
39368: PPUSH
39369: CALL_OW 1
39373: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
39374: LD_ADDR_EXP 118
39378: PUSH
39379: LD_EXP 118
39383: PPUSH
39384: LD_VAR 0 2
39388: PPUSH
39389: EMPTY
39390: PPUSH
39391: CALL_OW 1
39395: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
39396: LD_ADDR_EXP 119
39400: PUSH
39401: LD_EXP 119
39405: PPUSH
39406: LD_VAR 0 2
39410: PPUSH
39411: EMPTY
39412: PPUSH
39413: CALL_OW 1
39417: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
39418: LD_ADDR_EXP 120
39422: PUSH
39423: LD_EXP 120
39427: PPUSH
39428: LD_VAR 0 2
39432: PPUSH
39433: EMPTY
39434: PPUSH
39435: CALL_OW 1
39439: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
39440: LD_ADDR_EXP 121
39444: PUSH
39445: LD_EXP 121
39449: PPUSH
39450: LD_VAR 0 2
39454: PPUSH
39455: EMPTY
39456: PPUSH
39457: CALL_OW 1
39461: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
39462: LD_ADDR_EXP 110
39466: PUSH
39467: LD_EXP 110
39471: PPUSH
39472: LD_VAR 0 2
39476: PPUSH
39477: LD_INT 0
39479: PPUSH
39480: CALL_OW 1
39484: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
39485: LD_ADDR_EXP 123
39489: PUSH
39490: LD_EXP 123
39494: PPUSH
39495: LD_VAR 0 2
39499: PPUSH
39500: LD_INT 0
39502: PPUSH
39503: CALL_OW 1
39507: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
39508: LD_ADDR_EXP 111
39512: PUSH
39513: LD_EXP 111
39517: PPUSH
39518: LD_VAR 0 2
39522: PPUSH
39523: EMPTY
39524: PPUSH
39525: CALL_OW 1
39529: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
39530: LD_ADDR_EXP 122
39534: PUSH
39535: LD_EXP 122
39539: PPUSH
39540: LD_VAR 0 2
39544: PPUSH
39545: LD_INT 0
39547: PPUSH
39548: CALL_OW 1
39552: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
39553: LD_ADDR_EXP 124
39557: PUSH
39558: LD_EXP 124
39562: PPUSH
39563: LD_VAR 0 2
39567: PPUSH
39568: EMPTY
39569: PPUSH
39570: CALL_OW 1
39574: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
39575: LD_ADDR_EXP 127
39579: PUSH
39580: LD_EXP 127
39584: PPUSH
39585: LD_VAR 0 2
39589: PPUSH
39590: LD_INT 0
39592: PPUSH
39593: CALL_OW 1
39597: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
39598: LD_ADDR_EXP 128
39602: PUSH
39603: LD_EXP 128
39607: PPUSH
39608: LD_VAR 0 2
39612: PPUSH
39613: EMPTY
39614: PPUSH
39615: CALL_OW 1
39619: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
39620: LD_ADDR_EXP 129
39624: PUSH
39625: LD_EXP 129
39629: PPUSH
39630: LD_VAR 0 2
39634: PPUSH
39635: EMPTY
39636: PPUSH
39637: CALL_OW 1
39641: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39642: LD_ADDR_EXP 130
39646: PUSH
39647: LD_EXP 130
39651: PPUSH
39652: LD_VAR 0 2
39656: PPUSH
39657: EMPTY
39658: PPUSH
39659: CALL_OW 1
39663: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
39664: LD_ADDR_EXP 132
39668: PUSH
39669: LD_EXP 132
39673: PPUSH
39674: LD_VAR 0 2
39678: PPUSH
39679: LD_EXP 99
39683: PUSH
39684: LD_VAR 0 2
39688: ARRAY
39689: PPUSH
39690: LD_INT 2
39692: PUSH
39693: LD_INT 30
39695: PUSH
39696: LD_INT 6
39698: PUSH
39699: EMPTY
39700: LIST
39701: LIST
39702: PUSH
39703: LD_INT 30
39705: PUSH
39706: LD_INT 7
39708: PUSH
39709: EMPTY
39710: LIST
39711: LIST
39712: PUSH
39713: LD_INT 30
39715: PUSH
39716: LD_INT 8
39718: PUSH
39719: EMPTY
39720: LIST
39721: LIST
39722: PUSH
39723: EMPTY
39724: LIST
39725: LIST
39726: LIST
39727: LIST
39728: PPUSH
39729: CALL_OW 72
39733: PPUSH
39734: CALL_OW 1
39738: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
39739: LD_ADDR_EXP 133
39743: PUSH
39744: LD_EXP 133
39748: PPUSH
39749: LD_VAR 0 2
39753: PPUSH
39754: EMPTY
39755: PPUSH
39756: CALL_OW 1
39760: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
39761: LD_ADDR_EXP 134
39765: PUSH
39766: LD_EXP 134
39770: PPUSH
39771: LD_VAR 0 2
39775: PPUSH
39776: EMPTY
39777: PPUSH
39778: CALL_OW 1
39782: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
39783: LD_ADDR_EXP 135
39787: PUSH
39788: LD_EXP 135
39792: PPUSH
39793: LD_VAR 0 2
39797: PPUSH
39798: EMPTY
39799: PPUSH
39800: CALL_OW 1
39804: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
39805: LD_ADDR_EXP 136
39809: PUSH
39810: LD_EXP 136
39814: PPUSH
39815: LD_VAR 0 2
39819: PPUSH
39820: EMPTY
39821: PPUSH
39822: CALL_OW 1
39826: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39827: LD_ADDR_EXP 137
39831: PUSH
39832: LD_EXP 137
39836: PPUSH
39837: LD_VAR 0 2
39841: PPUSH
39842: EMPTY
39843: PPUSH
39844: CALL_OW 1
39848: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
39849: LD_ADDR_EXP 138
39853: PUSH
39854: LD_EXP 138
39858: PPUSH
39859: LD_VAR 0 2
39863: PPUSH
39864: EMPTY
39865: PPUSH
39866: CALL_OW 1
39870: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
39871: LD_ADDR_EXP 139
39875: PUSH
39876: LD_EXP 139
39880: PPUSH
39881: LD_VAR 0 2
39885: PPUSH
39886: EMPTY
39887: PPUSH
39888: CALL_OW 1
39892: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
39893: LD_ADDR_EXP 140
39897: PUSH
39898: LD_EXP 140
39902: PPUSH
39903: LD_VAR 0 2
39907: PPUSH
39908: EMPTY
39909: PPUSH
39910: CALL_OW 1
39914: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
39915: LD_ADDR_EXP 141
39919: PUSH
39920: LD_EXP 141
39924: PPUSH
39925: LD_VAR 0 2
39929: PPUSH
39930: LD_INT 0
39932: PPUSH
39933: CALL_OW 1
39937: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
39938: LD_ADDR_EXP 142
39942: PUSH
39943: LD_EXP 142
39947: PPUSH
39948: LD_VAR 0 2
39952: PPUSH
39953: LD_INT 0
39955: PPUSH
39956: CALL_OW 1
39960: ST_TO_ADDR
// end ;
39961: GO 38862
39963: POP
39964: POP
// MC_InitSides ( ) ;
39965: CALL 40251 0 0
// MC_InitResearch ( ) ;
39969: CALL 39990 0 0
// CustomInitMacro ( ) ;
39973: CALL 475 0 0
// skirmish := true ;
39977: LD_ADDR_EXP 97
39981: PUSH
39982: LD_INT 1
39984: ST_TO_ADDR
// end ;
39985: LD_VAR 0 1
39989: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
39990: LD_INT 0
39992: PPUSH
39993: PPUSH
39994: PPUSH
39995: PPUSH
39996: PPUSH
39997: PPUSH
// if not mc_bases then
39998: LD_EXP 99
40002: NOT
40003: IFFALSE 40007
// exit ;
40005: GO 40246
// for i = 1 to 8 do
40007: LD_ADDR_VAR 0 2
40011: PUSH
40012: DOUBLE
40013: LD_INT 1
40015: DEC
40016: ST_TO_ADDR
40017: LD_INT 8
40019: PUSH
40020: FOR_TO
40021: IFFALSE 40047
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
40023: LD_ADDR_EXP 126
40027: PUSH
40028: LD_EXP 126
40032: PPUSH
40033: LD_VAR 0 2
40037: PPUSH
40038: EMPTY
40039: PPUSH
40040: CALL_OW 1
40044: ST_TO_ADDR
40045: GO 40020
40047: POP
40048: POP
// tmp := [ ] ;
40049: LD_ADDR_VAR 0 5
40053: PUSH
40054: EMPTY
40055: ST_TO_ADDR
// for i = 1 to mc_sides do
40056: LD_ADDR_VAR 0 2
40060: PUSH
40061: DOUBLE
40062: LD_INT 1
40064: DEC
40065: ST_TO_ADDR
40066: LD_EXP 125
40070: PUSH
40071: FOR_TO
40072: IFFALSE 40130
// if not mc_sides [ i ] in tmp then
40074: LD_EXP 125
40078: PUSH
40079: LD_VAR 0 2
40083: ARRAY
40084: PUSH
40085: LD_VAR 0 5
40089: IN
40090: NOT
40091: IFFALSE 40128
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
40093: LD_ADDR_VAR 0 5
40097: PUSH
40098: LD_VAR 0 5
40102: PPUSH
40103: LD_VAR 0 5
40107: PUSH
40108: LD_INT 1
40110: PLUS
40111: PPUSH
40112: LD_EXP 125
40116: PUSH
40117: LD_VAR 0 2
40121: ARRAY
40122: PPUSH
40123: CALL_OW 2
40127: ST_TO_ADDR
40128: GO 40071
40130: POP
40131: POP
// if not tmp then
40132: LD_VAR 0 5
40136: NOT
40137: IFFALSE 40141
// exit ;
40139: GO 40246
// for j in tmp do
40141: LD_ADDR_VAR 0 3
40145: PUSH
40146: LD_VAR 0 5
40150: PUSH
40151: FOR_IN
40152: IFFALSE 40244
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
40154: LD_ADDR_VAR 0 6
40158: PUSH
40159: LD_INT 22
40161: PUSH
40162: LD_VAR 0 3
40166: PUSH
40167: EMPTY
40168: LIST
40169: LIST
40170: PPUSH
40171: CALL_OW 69
40175: ST_TO_ADDR
// if not un then
40176: LD_VAR 0 6
40180: NOT
40181: IFFALSE 40185
// continue ;
40183: GO 40151
// nation := GetNation ( un [ 1 ] ) ;
40185: LD_ADDR_VAR 0 4
40189: PUSH
40190: LD_VAR 0 6
40194: PUSH
40195: LD_INT 1
40197: ARRAY
40198: PPUSH
40199: CALL_OW 248
40203: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
40204: LD_ADDR_EXP 126
40208: PUSH
40209: LD_EXP 126
40213: PPUSH
40214: LD_VAR 0 3
40218: PPUSH
40219: LD_VAR 0 3
40223: PPUSH
40224: LD_VAR 0 4
40228: PPUSH
40229: LD_INT 1
40231: PPUSH
40232: CALL 67398 0 3
40236: PPUSH
40237: CALL_OW 1
40241: ST_TO_ADDR
// end ;
40242: GO 40151
40244: POP
40245: POP
// end ;
40246: LD_VAR 0 1
40250: RET
// export function MC_InitSides ( ) ; var i ; begin
40251: LD_INT 0
40253: PPUSH
40254: PPUSH
// if not mc_bases then
40255: LD_EXP 99
40259: NOT
40260: IFFALSE 40264
// exit ;
40262: GO 40338
// for i = 1 to mc_bases do
40264: LD_ADDR_VAR 0 2
40268: PUSH
40269: DOUBLE
40270: LD_INT 1
40272: DEC
40273: ST_TO_ADDR
40274: LD_EXP 99
40278: PUSH
40279: FOR_TO
40280: IFFALSE 40336
// if mc_bases [ i ] then
40282: LD_EXP 99
40286: PUSH
40287: LD_VAR 0 2
40291: ARRAY
40292: IFFALSE 40334
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
40294: LD_ADDR_EXP 125
40298: PUSH
40299: LD_EXP 125
40303: PPUSH
40304: LD_VAR 0 2
40308: PPUSH
40309: LD_EXP 99
40313: PUSH
40314: LD_VAR 0 2
40318: ARRAY
40319: PUSH
40320: LD_INT 1
40322: ARRAY
40323: PPUSH
40324: CALL_OW 255
40328: PPUSH
40329: CALL_OW 1
40333: ST_TO_ADDR
40334: GO 40279
40336: POP
40337: POP
// end ;
40338: LD_VAR 0 1
40342: RET
// every 0 0$03 trigger skirmish do
40343: LD_EXP 97
40347: IFFALSE 40501
40349: GO 40351
40351: DISABLE
// begin enable ;
40352: ENABLE
// MC_CheckBuildings ( ) ;
40353: CALL 44999 0 0
// MC_CheckPeopleLife ( ) ;
40357: CALL 45160 0 0
// RaiseSailEvent ( 100 ) ;
40361: LD_INT 100
40363: PPUSH
40364: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
40368: LD_INT 103
40370: PPUSH
40371: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
40375: LD_INT 104
40377: PPUSH
40378: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
40382: LD_INT 105
40384: PPUSH
40385: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
40389: LD_INT 106
40391: PPUSH
40392: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
40396: LD_INT 107
40398: PPUSH
40399: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
40403: LD_INT 108
40405: PPUSH
40406: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
40410: LD_INT 109
40412: PPUSH
40413: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
40417: LD_INT 110
40419: PPUSH
40420: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
40424: LD_INT 111
40426: PPUSH
40427: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
40431: LD_INT 112
40433: PPUSH
40434: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
40438: LD_INT 113
40440: PPUSH
40441: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
40445: LD_INT 120
40447: PPUSH
40448: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
40452: LD_INT 121
40454: PPUSH
40455: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
40459: LD_INT 122
40461: PPUSH
40462: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
40466: LD_INT 123
40468: PPUSH
40469: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
40473: LD_INT 124
40475: PPUSH
40476: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
40480: LD_INT 125
40482: PPUSH
40483: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
40487: LD_INT 126
40489: PPUSH
40490: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
40494: LD_INT 200
40496: PPUSH
40497: CALL_OW 427
// end ;
40501: END
// on SailEvent ( event ) do begin if event < 100 then
40502: LD_VAR 0 1
40506: PUSH
40507: LD_INT 100
40509: LESS
40510: IFFALSE 40521
// CustomEvent ( event ) ;
40512: LD_VAR 0 1
40516: PPUSH
40517: CALL 35003 0 1
// if event = 100 then
40521: LD_VAR 0 1
40525: PUSH
40526: LD_INT 100
40528: EQUAL
40529: IFFALSE 40535
// MC_ClassManager ( ) ;
40531: CALL 40927 0 0
// if event = 101 then
40535: LD_VAR 0 1
40539: PUSH
40540: LD_INT 101
40542: EQUAL
40543: IFFALSE 40549
// MC_RepairBuildings ( ) ;
40545: CALL 45745 0 0
// if event = 102 then
40549: LD_VAR 0 1
40553: PUSH
40554: LD_INT 102
40556: EQUAL
40557: IFFALSE 40563
// MC_Heal ( ) ;
40559: CALL 46680 0 0
// if event = 103 then
40563: LD_VAR 0 1
40567: PUSH
40568: LD_INT 103
40570: EQUAL
40571: IFFALSE 40577
// MC_Build ( ) ;
40573: CALL 47102 0 0
// if event = 104 then
40577: LD_VAR 0 1
40581: PUSH
40582: LD_INT 104
40584: EQUAL
40585: IFFALSE 40591
// MC_TurretWeapon ( ) ;
40587: CALL 48736 0 0
// if event = 105 then
40591: LD_VAR 0 1
40595: PUSH
40596: LD_INT 105
40598: EQUAL
40599: IFFALSE 40605
// MC_BuildUpgrade ( ) ;
40601: CALL 48287 0 0
// if event = 106 then
40605: LD_VAR 0 1
40609: PUSH
40610: LD_INT 106
40612: EQUAL
40613: IFFALSE 40619
// MC_PlantMines ( ) ;
40615: CALL 49166 0 0
// if event = 107 then
40619: LD_VAR 0 1
40623: PUSH
40624: LD_INT 107
40626: EQUAL
40627: IFFALSE 40633
// MC_CollectCrates ( ) ;
40629: CALL 49957 0 0
// if event = 108 then
40633: LD_VAR 0 1
40637: PUSH
40638: LD_INT 108
40640: EQUAL
40641: IFFALSE 40647
// MC_LinkRemoteControl ( ) ;
40643: CALL 51807 0 0
// if event = 109 then
40647: LD_VAR 0 1
40651: PUSH
40652: LD_INT 109
40654: EQUAL
40655: IFFALSE 40661
// MC_ProduceVehicle ( ) ;
40657: CALL 51988 0 0
// if event = 110 then
40661: LD_VAR 0 1
40665: PUSH
40666: LD_INT 110
40668: EQUAL
40669: IFFALSE 40675
// MC_SendAttack ( ) ;
40671: CALL 52454 0 0
// if event = 111 then
40675: LD_VAR 0 1
40679: PUSH
40680: LD_INT 111
40682: EQUAL
40683: IFFALSE 40689
// MC_Defend ( ) ;
40685: CALL 52562 0 0
// if event = 112 then
40689: LD_VAR 0 1
40693: PUSH
40694: LD_INT 112
40696: EQUAL
40697: IFFALSE 40703
// MC_Research ( ) ;
40699: CALL 53442 0 0
// if event = 113 then
40703: LD_VAR 0 1
40707: PUSH
40708: LD_INT 113
40710: EQUAL
40711: IFFALSE 40717
// MC_MinesTrigger ( ) ;
40713: CALL 54556 0 0
// if event = 120 then
40717: LD_VAR 0 1
40721: PUSH
40722: LD_INT 120
40724: EQUAL
40725: IFFALSE 40731
// MC_RepairVehicle ( ) ;
40727: CALL 54655 0 0
// if event = 121 then
40731: LD_VAR 0 1
40735: PUSH
40736: LD_INT 121
40738: EQUAL
40739: IFFALSE 40745
// MC_TameApe ( ) ;
40741: CALL 55424 0 0
// if event = 122 then
40745: LD_VAR 0 1
40749: PUSH
40750: LD_INT 122
40752: EQUAL
40753: IFFALSE 40759
// MC_ChangeApeClass ( ) ;
40755: CALL 56253 0 0
// if event = 123 then
40759: LD_VAR 0 1
40763: PUSH
40764: LD_INT 123
40766: EQUAL
40767: IFFALSE 40773
// MC_Bazooka ( ) ;
40769: CALL 56903 0 0
// if event = 124 then
40773: LD_VAR 0 1
40777: PUSH
40778: LD_INT 124
40780: EQUAL
40781: IFFALSE 40787
// MC_TeleportExit ( ) ;
40783: CALL 57101 0 0
// if event = 125 then
40787: LD_VAR 0 1
40791: PUSH
40792: LD_INT 125
40794: EQUAL
40795: IFFALSE 40801
// MC_Deposits ( ) ;
40797: CALL 57748 0 0
// if event = 126 then
40801: LD_VAR 0 1
40805: PUSH
40806: LD_INT 126
40808: EQUAL
40809: IFFALSE 40815
// MC_RemoteDriver ( ) ;
40811: CALL 58373 0 0
// if event = 200 then
40815: LD_VAR 0 1
40819: PUSH
40820: LD_INT 200
40822: EQUAL
40823: IFFALSE 40829
// MC_Idle ( ) ;
40825: CALL 60322 0 0
// end ;
40829: PPOPN 1
40831: END
// export function MC_Reset ( base , tag ) ; var i ; begin
40832: LD_INT 0
40834: PPUSH
40835: PPUSH
// if not mc_bases [ base ] or not tag then
40836: LD_EXP 99
40840: PUSH
40841: LD_VAR 0 1
40845: ARRAY
40846: NOT
40847: PUSH
40848: LD_VAR 0 2
40852: NOT
40853: OR
40854: IFFALSE 40858
// exit ;
40856: GO 40922
// for i in mc_bases [ base ] union mc_ape [ base ] do
40858: LD_ADDR_VAR 0 4
40862: PUSH
40863: LD_EXP 99
40867: PUSH
40868: LD_VAR 0 1
40872: ARRAY
40873: PUSH
40874: LD_EXP 128
40878: PUSH
40879: LD_VAR 0 1
40883: ARRAY
40884: UNION
40885: PUSH
40886: FOR_IN
40887: IFFALSE 40920
// if GetTag ( i ) = tag then
40889: LD_VAR 0 4
40893: PPUSH
40894: CALL_OW 110
40898: PUSH
40899: LD_VAR 0 2
40903: EQUAL
40904: IFFALSE 40918
// SetTag ( i , 0 ) ;
40906: LD_VAR 0 4
40910: PPUSH
40911: LD_INT 0
40913: PPUSH
40914: CALL_OW 109
40918: GO 40886
40920: POP
40921: POP
// end ;
40922: LD_VAR 0 3
40926: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
40927: LD_INT 0
40929: PPUSH
40930: PPUSH
40931: PPUSH
40932: PPUSH
40933: PPUSH
40934: PPUSH
40935: PPUSH
40936: PPUSH
// if not mc_bases then
40937: LD_EXP 99
40941: NOT
40942: IFFALSE 40946
// exit ;
40944: GO 41404
// for i = 1 to mc_bases do
40946: LD_ADDR_VAR 0 2
40950: PUSH
40951: DOUBLE
40952: LD_INT 1
40954: DEC
40955: ST_TO_ADDR
40956: LD_EXP 99
40960: PUSH
40961: FOR_TO
40962: IFFALSE 41402
// begin tmp := MC_ClassCheckReq ( i ) ;
40964: LD_ADDR_VAR 0 4
40968: PUSH
40969: LD_VAR 0 2
40973: PPUSH
40974: CALL 41409 0 1
40978: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
40979: LD_ADDR_EXP 140
40983: PUSH
40984: LD_EXP 140
40988: PPUSH
40989: LD_VAR 0 2
40993: PPUSH
40994: LD_VAR 0 4
40998: PPUSH
40999: CALL_OW 1
41003: ST_TO_ADDR
// if not tmp then
41004: LD_VAR 0 4
41008: NOT
41009: IFFALSE 41013
// continue ;
41011: GO 40961
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
41013: LD_ADDR_VAR 0 6
41017: PUSH
41018: LD_EXP 99
41022: PUSH
41023: LD_VAR 0 2
41027: ARRAY
41028: PPUSH
41029: LD_INT 2
41031: PUSH
41032: LD_INT 30
41034: PUSH
41035: LD_INT 4
41037: PUSH
41038: EMPTY
41039: LIST
41040: LIST
41041: PUSH
41042: LD_INT 30
41044: PUSH
41045: LD_INT 5
41047: PUSH
41048: EMPTY
41049: LIST
41050: LIST
41051: PUSH
41052: EMPTY
41053: LIST
41054: LIST
41055: LIST
41056: PPUSH
41057: CALL_OW 72
41061: PUSH
41062: LD_EXP 99
41066: PUSH
41067: LD_VAR 0 2
41071: ARRAY
41072: PPUSH
41073: LD_INT 2
41075: PUSH
41076: LD_INT 30
41078: PUSH
41079: LD_INT 0
41081: PUSH
41082: EMPTY
41083: LIST
41084: LIST
41085: PUSH
41086: LD_INT 30
41088: PUSH
41089: LD_INT 1
41091: PUSH
41092: EMPTY
41093: LIST
41094: LIST
41095: PUSH
41096: EMPTY
41097: LIST
41098: LIST
41099: LIST
41100: PPUSH
41101: CALL_OW 72
41105: PUSH
41106: LD_EXP 99
41110: PUSH
41111: LD_VAR 0 2
41115: ARRAY
41116: PPUSH
41117: LD_INT 30
41119: PUSH
41120: LD_INT 3
41122: PUSH
41123: EMPTY
41124: LIST
41125: LIST
41126: PPUSH
41127: CALL_OW 72
41131: PUSH
41132: LD_EXP 99
41136: PUSH
41137: LD_VAR 0 2
41141: ARRAY
41142: PPUSH
41143: LD_INT 2
41145: PUSH
41146: LD_INT 30
41148: PUSH
41149: LD_INT 6
41151: PUSH
41152: EMPTY
41153: LIST
41154: LIST
41155: PUSH
41156: LD_INT 30
41158: PUSH
41159: LD_INT 7
41161: PUSH
41162: EMPTY
41163: LIST
41164: LIST
41165: PUSH
41166: LD_INT 30
41168: PUSH
41169: LD_INT 8
41171: PUSH
41172: EMPTY
41173: LIST
41174: LIST
41175: PUSH
41176: EMPTY
41177: LIST
41178: LIST
41179: LIST
41180: LIST
41181: PPUSH
41182: CALL_OW 72
41186: PUSH
41187: EMPTY
41188: LIST
41189: LIST
41190: LIST
41191: LIST
41192: ST_TO_ADDR
// for j = 1 to 4 do
41193: LD_ADDR_VAR 0 3
41197: PUSH
41198: DOUBLE
41199: LD_INT 1
41201: DEC
41202: ST_TO_ADDR
41203: LD_INT 4
41205: PUSH
41206: FOR_TO
41207: IFFALSE 41398
// begin if not tmp [ j ] then
41209: LD_VAR 0 4
41213: PUSH
41214: LD_VAR 0 3
41218: ARRAY
41219: NOT
41220: IFFALSE 41224
// continue ;
41222: GO 41206
// for p in tmp [ j ] do
41224: LD_ADDR_VAR 0 5
41228: PUSH
41229: LD_VAR 0 4
41233: PUSH
41234: LD_VAR 0 3
41238: ARRAY
41239: PUSH
41240: FOR_IN
41241: IFFALSE 41394
// begin if not b [ j ] then
41243: LD_VAR 0 6
41247: PUSH
41248: LD_VAR 0 3
41252: ARRAY
41253: NOT
41254: IFFALSE 41258
// break ;
41256: GO 41394
// e := 0 ;
41258: LD_ADDR_VAR 0 7
41262: PUSH
41263: LD_INT 0
41265: ST_TO_ADDR
// for k in b [ j ] do
41266: LD_ADDR_VAR 0 8
41270: PUSH
41271: LD_VAR 0 6
41275: PUSH
41276: LD_VAR 0 3
41280: ARRAY
41281: PUSH
41282: FOR_IN
41283: IFFALSE 41310
// if IsNotFull ( k ) then
41285: LD_VAR 0 8
41289: PPUSH
41290: CALL 69551 0 1
41294: IFFALSE 41308
// begin e := k ;
41296: LD_ADDR_VAR 0 7
41300: PUSH
41301: LD_VAR 0 8
41305: ST_TO_ADDR
// break ;
41306: GO 41310
// end ;
41308: GO 41282
41310: POP
41311: POP
// if e and not UnitGoingToBuilding ( p , e ) then
41312: LD_VAR 0 7
41316: PUSH
41317: LD_VAR 0 5
41321: PPUSH
41322: LD_VAR 0 7
41326: PPUSH
41327: CALL 103430 0 2
41331: NOT
41332: AND
41333: IFFALSE 41392
// begin if IsInUnit ( p ) then
41335: LD_VAR 0 5
41339: PPUSH
41340: CALL_OW 310
41344: IFFALSE 41355
// ComExitBuilding ( p ) ;
41346: LD_VAR 0 5
41350: PPUSH
41351: CALL_OW 122
// ComEnterUnit ( p , e ) ;
41355: LD_VAR 0 5
41359: PPUSH
41360: LD_VAR 0 7
41364: PPUSH
41365: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
41369: LD_VAR 0 5
41373: PPUSH
41374: LD_VAR 0 3
41378: PPUSH
41379: CALL_OW 183
// AddComExitBuilding ( p ) ;
41383: LD_VAR 0 5
41387: PPUSH
41388: CALL_OW 182
// end ; end ;
41392: GO 41240
41394: POP
41395: POP
// end ;
41396: GO 41206
41398: POP
41399: POP
// end ;
41400: GO 40961
41402: POP
41403: POP
// end ;
41404: LD_VAR 0 1
41408: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
41409: LD_INT 0
41411: PPUSH
41412: PPUSH
41413: PPUSH
41414: PPUSH
41415: PPUSH
41416: PPUSH
41417: PPUSH
41418: PPUSH
41419: PPUSH
41420: PPUSH
41421: PPUSH
41422: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41423: LD_VAR 0 1
41427: NOT
41428: PUSH
41429: LD_EXP 99
41433: PUSH
41434: LD_VAR 0 1
41438: ARRAY
41439: NOT
41440: OR
41441: PUSH
41442: LD_EXP 99
41446: PUSH
41447: LD_VAR 0 1
41451: ARRAY
41452: PPUSH
41453: LD_INT 2
41455: PUSH
41456: LD_INT 30
41458: PUSH
41459: LD_INT 0
41461: PUSH
41462: EMPTY
41463: LIST
41464: LIST
41465: PUSH
41466: LD_INT 30
41468: PUSH
41469: LD_INT 1
41471: PUSH
41472: EMPTY
41473: LIST
41474: LIST
41475: PUSH
41476: EMPTY
41477: LIST
41478: LIST
41479: LIST
41480: PPUSH
41481: CALL_OW 72
41485: NOT
41486: OR
41487: IFFALSE 41491
// exit ;
41489: GO 44994
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
41491: LD_ADDR_VAR 0 4
41495: PUSH
41496: LD_EXP 99
41500: PUSH
41501: LD_VAR 0 1
41505: ARRAY
41506: PPUSH
41507: LD_INT 2
41509: PUSH
41510: LD_INT 25
41512: PUSH
41513: LD_INT 1
41515: PUSH
41516: EMPTY
41517: LIST
41518: LIST
41519: PUSH
41520: LD_INT 25
41522: PUSH
41523: LD_INT 2
41525: PUSH
41526: EMPTY
41527: LIST
41528: LIST
41529: PUSH
41530: LD_INT 25
41532: PUSH
41533: LD_INT 3
41535: PUSH
41536: EMPTY
41537: LIST
41538: LIST
41539: PUSH
41540: LD_INT 25
41542: PUSH
41543: LD_INT 4
41545: PUSH
41546: EMPTY
41547: LIST
41548: LIST
41549: PUSH
41550: LD_INT 25
41552: PUSH
41553: LD_INT 5
41555: PUSH
41556: EMPTY
41557: LIST
41558: LIST
41559: PUSH
41560: LD_INT 25
41562: PUSH
41563: LD_INT 8
41565: PUSH
41566: EMPTY
41567: LIST
41568: LIST
41569: PUSH
41570: LD_INT 25
41572: PUSH
41573: LD_INT 9
41575: PUSH
41576: EMPTY
41577: LIST
41578: LIST
41579: PUSH
41580: EMPTY
41581: LIST
41582: LIST
41583: LIST
41584: LIST
41585: LIST
41586: LIST
41587: LIST
41588: LIST
41589: PPUSH
41590: CALL_OW 72
41594: ST_TO_ADDR
// if not tmp then
41595: LD_VAR 0 4
41599: NOT
41600: IFFALSE 41604
// exit ;
41602: GO 44994
// for i in tmp do
41604: LD_ADDR_VAR 0 3
41608: PUSH
41609: LD_VAR 0 4
41613: PUSH
41614: FOR_IN
41615: IFFALSE 41646
// if GetTag ( i ) then
41617: LD_VAR 0 3
41621: PPUSH
41622: CALL_OW 110
41626: IFFALSE 41644
// tmp := tmp diff i ;
41628: LD_ADDR_VAR 0 4
41632: PUSH
41633: LD_VAR 0 4
41637: PUSH
41638: LD_VAR 0 3
41642: DIFF
41643: ST_TO_ADDR
41644: GO 41614
41646: POP
41647: POP
// if not tmp then
41648: LD_VAR 0 4
41652: NOT
41653: IFFALSE 41657
// exit ;
41655: GO 44994
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
41657: LD_ADDR_VAR 0 5
41661: PUSH
41662: LD_EXP 99
41666: PUSH
41667: LD_VAR 0 1
41671: ARRAY
41672: PPUSH
41673: LD_INT 2
41675: PUSH
41676: LD_INT 25
41678: PUSH
41679: LD_INT 1
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PUSH
41686: LD_INT 25
41688: PUSH
41689: LD_INT 5
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: LD_INT 25
41698: PUSH
41699: LD_INT 8
41701: PUSH
41702: EMPTY
41703: LIST
41704: LIST
41705: PUSH
41706: LD_INT 25
41708: PUSH
41709: LD_INT 9
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: PUSH
41716: EMPTY
41717: LIST
41718: LIST
41719: LIST
41720: LIST
41721: LIST
41722: PPUSH
41723: CALL_OW 72
41727: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
41728: LD_ADDR_VAR 0 6
41732: PUSH
41733: LD_EXP 99
41737: PUSH
41738: LD_VAR 0 1
41742: ARRAY
41743: PPUSH
41744: LD_INT 25
41746: PUSH
41747: LD_INT 2
41749: PUSH
41750: EMPTY
41751: LIST
41752: LIST
41753: PPUSH
41754: CALL_OW 72
41758: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
41759: LD_ADDR_VAR 0 7
41763: PUSH
41764: LD_EXP 99
41768: PUSH
41769: LD_VAR 0 1
41773: ARRAY
41774: PPUSH
41775: LD_INT 25
41777: PUSH
41778: LD_INT 3
41780: PUSH
41781: EMPTY
41782: LIST
41783: LIST
41784: PPUSH
41785: CALL_OW 72
41789: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
41790: LD_ADDR_VAR 0 8
41794: PUSH
41795: LD_EXP 99
41799: PUSH
41800: LD_VAR 0 1
41804: ARRAY
41805: PPUSH
41806: LD_INT 25
41808: PUSH
41809: LD_INT 4
41811: PUSH
41812: EMPTY
41813: LIST
41814: LIST
41815: PUSH
41816: LD_INT 24
41818: PUSH
41819: LD_INT 251
41821: PUSH
41822: EMPTY
41823: LIST
41824: LIST
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: PPUSH
41830: CALL_OW 72
41834: ST_TO_ADDR
// if mc_is_defending [ base ] then
41835: LD_EXP 142
41839: PUSH
41840: LD_VAR 0 1
41844: ARRAY
41845: IFFALSE 42306
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
41847: LD_ADDR_EXP 141
41851: PUSH
41852: LD_EXP 141
41856: PPUSH
41857: LD_VAR 0 1
41861: PPUSH
41862: LD_INT 4
41864: PPUSH
41865: CALL_OW 1
41869: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
41870: LD_ADDR_VAR 0 12
41874: PUSH
41875: LD_EXP 99
41879: PUSH
41880: LD_VAR 0 1
41884: ARRAY
41885: PPUSH
41886: LD_INT 2
41888: PUSH
41889: LD_INT 30
41891: PUSH
41892: LD_INT 4
41894: PUSH
41895: EMPTY
41896: LIST
41897: LIST
41898: PUSH
41899: LD_INT 30
41901: PUSH
41902: LD_INT 5
41904: PUSH
41905: EMPTY
41906: LIST
41907: LIST
41908: PUSH
41909: EMPTY
41910: LIST
41911: LIST
41912: LIST
41913: PPUSH
41914: CALL_OW 72
41918: ST_TO_ADDR
// if not b then
41919: LD_VAR 0 12
41923: NOT
41924: IFFALSE 41928
// exit ;
41926: GO 44994
// p := [ ] ;
41928: LD_ADDR_VAR 0 11
41932: PUSH
41933: EMPTY
41934: ST_TO_ADDR
// if sci >= 2 then
41935: LD_VAR 0 8
41939: PUSH
41940: LD_INT 2
41942: GREATEREQUAL
41943: IFFALSE 41974
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
41945: LD_ADDR_VAR 0 8
41949: PUSH
41950: LD_VAR 0 8
41954: PUSH
41955: LD_INT 1
41957: ARRAY
41958: PUSH
41959: LD_VAR 0 8
41963: PUSH
41964: LD_INT 2
41966: ARRAY
41967: PUSH
41968: EMPTY
41969: LIST
41970: LIST
41971: ST_TO_ADDR
41972: GO 42035
// if sci = 1 then
41974: LD_VAR 0 8
41978: PUSH
41979: LD_INT 1
41981: EQUAL
41982: IFFALSE 42003
// sci := [ sci [ 1 ] ] else
41984: LD_ADDR_VAR 0 8
41988: PUSH
41989: LD_VAR 0 8
41993: PUSH
41994: LD_INT 1
41996: ARRAY
41997: PUSH
41998: EMPTY
41999: LIST
42000: ST_TO_ADDR
42001: GO 42035
// if sci = 0 then
42003: LD_VAR 0 8
42007: PUSH
42008: LD_INT 0
42010: EQUAL
42011: IFFALSE 42035
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
42013: LD_ADDR_VAR 0 11
42017: PUSH
42018: LD_VAR 0 4
42022: PPUSH
42023: LD_INT 4
42025: PPUSH
42026: CALL 103293 0 2
42030: PUSH
42031: LD_INT 1
42033: ARRAY
42034: ST_TO_ADDR
// if eng > 4 then
42035: LD_VAR 0 6
42039: PUSH
42040: LD_INT 4
42042: GREATER
42043: IFFALSE 42089
// for i = eng downto 4 do
42045: LD_ADDR_VAR 0 3
42049: PUSH
42050: DOUBLE
42051: LD_VAR 0 6
42055: INC
42056: ST_TO_ADDR
42057: LD_INT 4
42059: PUSH
42060: FOR_DOWNTO
42061: IFFALSE 42087
// eng := eng diff eng [ i ] ;
42063: LD_ADDR_VAR 0 6
42067: PUSH
42068: LD_VAR 0 6
42072: PUSH
42073: LD_VAR 0 6
42077: PUSH
42078: LD_VAR 0 3
42082: ARRAY
42083: DIFF
42084: ST_TO_ADDR
42085: GO 42060
42087: POP
42088: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
42089: LD_ADDR_VAR 0 4
42093: PUSH
42094: LD_VAR 0 4
42098: PUSH
42099: LD_VAR 0 5
42103: PUSH
42104: LD_VAR 0 6
42108: UNION
42109: PUSH
42110: LD_VAR 0 7
42114: UNION
42115: PUSH
42116: LD_VAR 0 8
42120: UNION
42121: DIFF
42122: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
42123: LD_ADDR_VAR 0 13
42127: PUSH
42128: LD_EXP 99
42132: PUSH
42133: LD_VAR 0 1
42137: ARRAY
42138: PPUSH
42139: LD_INT 2
42141: PUSH
42142: LD_INT 30
42144: PUSH
42145: LD_INT 32
42147: PUSH
42148: EMPTY
42149: LIST
42150: LIST
42151: PUSH
42152: LD_INT 30
42154: PUSH
42155: LD_INT 31
42157: PUSH
42158: EMPTY
42159: LIST
42160: LIST
42161: PUSH
42162: EMPTY
42163: LIST
42164: LIST
42165: LIST
42166: PPUSH
42167: CALL_OW 72
42171: PUSH
42172: LD_EXP 99
42176: PUSH
42177: LD_VAR 0 1
42181: ARRAY
42182: PPUSH
42183: LD_INT 2
42185: PUSH
42186: LD_INT 30
42188: PUSH
42189: LD_INT 4
42191: PUSH
42192: EMPTY
42193: LIST
42194: LIST
42195: PUSH
42196: LD_INT 30
42198: PUSH
42199: LD_INT 5
42201: PUSH
42202: EMPTY
42203: LIST
42204: LIST
42205: PUSH
42206: EMPTY
42207: LIST
42208: LIST
42209: LIST
42210: PPUSH
42211: CALL_OW 72
42215: PUSH
42216: LD_INT 6
42218: MUL
42219: PLUS
42220: ST_TO_ADDR
// if bcount < tmp then
42221: LD_VAR 0 13
42225: PUSH
42226: LD_VAR 0 4
42230: LESS
42231: IFFALSE 42277
// for i = tmp downto bcount do
42233: LD_ADDR_VAR 0 3
42237: PUSH
42238: DOUBLE
42239: LD_VAR 0 4
42243: INC
42244: ST_TO_ADDR
42245: LD_VAR 0 13
42249: PUSH
42250: FOR_DOWNTO
42251: IFFALSE 42275
// tmp := Delete ( tmp , tmp ) ;
42253: LD_ADDR_VAR 0 4
42257: PUSH
42258: LD_VAR 0 4
42262: PPUSH
42263: LD_VAR 0 4
42267: PPUSH
42268: CALL_OW 3
42272: ST_TO_ADDR
42273: GO 42250
42275: POP
42276: POP
// result := [ tmp , 0 , 0 , p ] ;
42277: LD_ADDR_VAR 0 2
42281: PUSH
42282: LD_VAR 0 4
42286: PUSH
42287: LD_INT 0
42289: PUSH
42290: LD_INT 0
42292: PUSH
42293: LD_VAR 0 11
42297: PUSH
42298: EMPTY
42299: LIST
42300: LIST
42301: LIST
42302: LIST
42303: ST_TO_ADDR
// exit ;
42304: GO 44994
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42306: LD_EXP 99
42310: PUSH
42311: LD_VAR 0 1
42315: ARRAY
42316: PPUSH
42317: LD_INT 2
42319: PUSH
42320: LD_INT 30
42322: PUSH
42323: LD_INT 6
42325: PUSH
42326: EMPTY
42327: LIST
42328: LIST
42329: PUSH
42330: LD_INT 30
42332: PUSH
42333: LD_INT 7
42335: PUSH
42336: EMPTY
42337: LIST
42338: LIST
42339: PUSH
42340: LD_INT 30
42342: PUSH
42343: LD_INT 8
42345: PUSH
42346: EMPTY
42347: LIST
42348: LIST
42349: PUSH
42350: EMPTY
42351: LIST
42352: LIST
42353: LIST
42354: LIST
42355: PPUSH
42356: CALL_OW 72
42360: NOT
42361: PUSH
42362: LD_EXP 99
42366: PUSH
42367: LD_VAR 0 1
42371: ARRAY
42372: PPUSH
42373: LD_INT 30
42375: PUSH
42376: LD_INT 3
42378: PUSH
42379: EMPTY
42380: LIST
42381: LIST
42382: PPUSH
42383: CALL_OW 72
42387: NOT
42388: AND
42389: IFFALSE 42461
// begin if eng = tmp then
42391: LD_VAR 0 6
42395: PUSH
42396: LD_VAR 0 4
42400: EQUAL
42401: IFFALSE 42405
// exit ;
42403: GO 44994
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
42405: LD_ADDR_EXP 141
42409: PUSH
42410: LD_EXP 141
42414: PPUSH
42415: LD_VAR 0 1
42419: PPUSH
42420: LD_INT 1
42422: PPUSH
42423: CALL_OW 1
42427: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
42428: LD_ADDR_VAR 0 2
42432: PUSH
42433: LD_INT 0
42435: PUSH
42436: LD_VAR 0 4
42440: PUSH
42441: LD_VAR 0 6
42445: DIFF
42446: PUSH
42447: LD_INT 0
42449: PUSH
42450: LD_INT 0
42452: PUSH
42453: EMPTY
42454: LIST
42455: LIST
42456: LIST
42457: LIST
42458: ST_TO_ADDR
// exit ;
42459: GO 44994
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42461: LD_EXP 126
42465: PUSH
42466: LD_EXP 125
42470: PUSH
42471: LD_VAR 0 1
42475: ARRAY
42476: ARRAY
42477: PUSH
42478: LD_EXP 99
42482: PUSH
42483: LD_VAR 0 1
42487: ARRAY
42488: PPUSH
42489: LD_INT 2
42491: PUSH
42492: LD_INT 30
42494: PUSH
42495: LD_INT 6
42497: PUSH
42498: EMPTY
42499: LIST
42500: LIST
42501: PUSH
42502: LD_INT 30
42504: PUSH
42505: LD_INT 7
42507: PUSH
42508: EMPTY
42509: LIST
42510: LIST
42511: PUSH
42512: LD_INT 30
42514: PUSH
42515: LD_INT 8
42517: PUSH
42518: EMPTY
42519: LIST
42520: LIST
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: LIST
42526: LIST
42527: PPUSH
42528: CALL_OW 72
42532: AND
42533: PUSH
42534: LD_EXP 99
42538: PUSH
42539: LD_VAR 0 1
42543: ARRAY
42544: PPUSH
42545: LD_INT 30
42547: PUSH
42548: LD_INT 3
42550: PUSH
42551: EMPTY
42552: LIST
42553: LIST
42554: PPUSH
42555: CALL_OW 72
42559: NOT
42560: AND
42561: IFFALSE 42775
// begin if sci >= 6 then
42563: LD_VAR 0 8
42567: PUSH
42568: LD_INT 6
42570: GREATEREQUAL
42571: IFFALSE 42575
// exit ;
42573: GO 44994
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
42575: LD_ADDR_EXP 141
42579: PUSH
42580: LD_EXP 141
42584: PPUSH
42585: LD_VAR 0 1
42589: PPUSH
42590: LD_INT 2
42592: PPUSH
42593: CALL_OW 1
42597: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
42598: LD_ADDR_VAR 0 9
42602: PUSH
42603: LD_VAR 0 4
42607: PUSH
42608: LD_VAR 0 8
42612: DIFF
42613: PPUSH
42614: LD_INT 4
42616: PPUSH
42617: CALL 103293 0 2
42621: ST_TO_ADDR
// p := [ ] ;
42622: LD_ADDR_VAR 0 11
42626: PUSH
42627: EMPTY
42628: ST_TO_ADDR
// if sci < 6 and sort > 6 then
42629: LD_VAR 0 8
42633: PUSH
42634: LD_INT 6
42636: LESS
42637: PUSH
42638: LD_VAR 0 9
42642: PUSH
42643: LD_INT 6
42645: GREATER
42646: AND
42647: IFFALSE 42728
// begin for i = 1 to 6 - sci do
42649: LD_ADDR_VAR 0 3
42653: PUSH
42654: DOUBLE
42655: LD_INT 1
42657: DEC
42658: ST_TO_ADDR
42659: LD_INT 6
42661: PUSH
42662: LD_VAR 0 8
42666: MINUS
42667: PUSH
42668: FOR_TO
42669: IFFALSE 42724
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
42671: LD_ADDR_VAR 0 11
42675: PUSH
42676: LD_VAR 0 11
42680: PPUSH
42681: LD_VAR 0 11
42685: PUSH
42686: LD_INT 1
42688: PLUS
42689: PPUSH
42690: LD_VAR 0 9
42694: PUSH
42695: LD_INT 1
42697: ARRAY
42698: PPUSH
42699: CALL_OW 2
42703: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
42704: LD_ADDR_VAR 0 9
42708: PUSH
42709: LD_VAR 0 9
42713: PPUSH
42714: LD_INT 1
42716: PPUSH
42717: CALL_OW 3
42721: ST_TO_ADDR
// end ;
42722: GO 42668
42724: POP
42725: POP
// end else
42726: GO 42748
// if sort then
42728: LD_VAR 0 9
42732: IFFALSE 42748
// p := sort [ 1 ] ;
42734: LD_ADDR_VAR 0 11
42738: PUSH
42739: LD_VAR 0 9
42743: PUSH
42744: LD_INT 1
42746: ARRAY
42747: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
42748: LD_ADDR_VAR 0 2
42752: PUSH
42753: LD_INT 0
42755: PUSH
42756: LD_INT 0
42758: PUSH
42759: LD_INT 0
42761: PUSH
42762: LD_VAR 0 11
42766: PUSH
42767: EMPTY
42768: LIST
42769: LIST
42770: LIST
42771: LIST
42772: ST_TO_ADDR
// exit ;
42773: GO 44994
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42775: LD_EXP 126
42779: PUSH
42780: LD_EXP 125
42784: PUSH
42785: LD_VAR 0 1
42789: ARRAY
42790: ARRAY
42791: PUSH
42792: LD_EXP 99
42796: PUSH
42797: LD_VAR 0 1
42801: ARRAY
42802: PPUSH
42803: LD_INT 2
42805: PUSH
42806: LD_INT 30
42808: PUSH
42809: LD_INT 6
42811: PUSH
42812: EMPTY
42813: LIST
42814: LIST
42815: PUSH
42816: LD_INT 30
42818: PUSH
42819: LD_INT 7
42821: PUSH
42822: EMPTY
42823: LIST
42824: LIST
42825: PUSH
42826: LD_INT 30
42828: PUSH
42829: LD_INT 8
42831: PUSH
42832: EMPTY
42833: LIST
42834: LIST
42835: PUSH
42836: EMPTY
42837: LIST
42838: LIST
42839: LIST
42840: LIST
42841: PPUSH
42842: CALL_OW 72
42846: AND
42847: PUSH
42848: LD_EXP 99
42852: PUSH
42853: LD_VAR 0 1
42857: ARRAY
42858: PPUSH
42859: LD_INT 30
42861: PUSH
42862: LD_INT 3
42864: PUSH
42865: EMPTY
42866: LIST
42867: LIST
42868: PPUSH
42869: CALL_OW 72
42873: AND
42874: IFFALSE 43608
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
42876: LD_ADDR_EXP 141
42880: PUSH
42881: LD_EXP 141
42885: PPUSH
42886: LD_VAR 0 1
42890: PPUSH
42891: LD_INT 3
42893: PPUSH
42894: CALL_OW 1
42898: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42899: LD_ADDR_VAR 0 2
42903: PUSH
42904: LD_INT 0
42906: PUSH
42907: LD_INT 0
42909: PUSH
42910: LD_INT 0
42912: PUSH
42913: LD_INT 0
42915: PUSH
42916: EMPTY
42917: LIST
42918: LIST
42919: LIST
42920: LIST
42921: ST_TO_ADDR
// if not eng then
42922: LD_VAR 0 6
42926: NOT
42927: IFFALSE 42990
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
42929: LD_ADDR_VAR 0 11
42933: PUSH
42934: LD_VAR 0 4
42938: PPUSH
42939: LD_INT 2
42941: PPUSH
42942: CALL 103293 0 2
42946: PUSH
42947: LD_INT 1
42949: ARRAY
42950: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
42951: LD_ADDR_VAR 0 2
42955: PUSH
42956: LD_VAR 0 2
42960: PPUSH
42961: LD_INT 2
42963: PPUSH
42964: LD_VAR 0 11
42968: PPUSH
42969: CALL_OW 1
42973: ST_TO_ADDR
// tmp := tmp diff p ;
42974: LD_ADDR_VAR 0 4
42978: PUSH
42979: LD_VAR 0 4
42983: PUSH
42984: LD_VAR 0 11
42988: DIFF
42989: ST_TO_ADDR
// end ; if tmp and sci < 6 then
42990: LD_VAR 0 4
42994: PUSH
42995: LD_VAR 0 8
42999: PUSH
43000: LD_INT 6
43002: LESS
43003: AND
43004: IFFALSE 43192
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
43006: LD_ADDR_VAR 0 9
43010: PUSH
43011: LD_VAR 0 4
43015: PUSH
43016: LD_VAR 0 8
43020: PUSH
43021: LD_VAR 0 7
43025: UNION
43026: DIFF
43027: PPUSH
43028: LD_INT 4
43030: PPUSH
43031: CALL 103293 0 2
43035: ST_TO_ADDR
// p := [ ] ;
43036: LD_ADDR_VAR 0 11
43040: PUSH
43041: EMPTY
43042: ST_TO_ADDR
// if sort then
43043: LD_VAR 0 9
43047: IFFALSE 43163
// for i = 1 to 6 - sci do
43049: LD_ADDR_VAR 0 3
43053: PUSH
43054: DOUBLE
43055: LD_INT 1
43057: DEC
43058: ST_TO_ADDR
43059: LD_INT 6
43061: PUSH
43062: LD_VAR 0 8
43066: MINUS
43067: PUSH
43068: FOR_TO
43069: IFFALSE 43161
// begin if i = sort then
43071: LD_VAR 0 3
43075: PUSH
43076: LD_VAR 0 9
43080: EQUAL
43081: IFFALSE 43085
// break ;
43083: GO 43161
// if GetClass ( i ) = 4 then
43085: LD_VAR 0 3
43089: PPUSH
43090: CALL_OW 257
43094: PUSH
43095: LD_INT 4
43097: EQUAL
43098: IFFALSE 43102
// continue ;
43100: GO 43068
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43102: LD_ADDR_VAR 0 11
43106: PUSH
43107: LD_VAR 0 11
43111: PPUSH
43112: LD_VAR 0 11
43116: PUSH
43117: LD_INT 1
43119: PLUS
43120: PPUSH
43121: LD_VAR 0 9
43125: PUSH
43126: LD_VAR 0 3
43130: ARRAY
43131: PPUSH
43132: CALL_OW 2
43136: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43137: LD_ADDR_VAR 0 4
43141: PUSH
43142: LD_VAR 0 4
43146: PUSH
43147: LD_VAR 0 9
43151: PUSH
43152: LD_VAR 0 3
43156: ARRAY
43157: DIFF
43158: ST_TO_ADDR
// end ;
43159: GO 43068
43161: POP
43162: POP
// if p then
43163: LD_VAR 0 11
43167: IFFALSE 43192
// result := Replace ( result , 4 , p ) ;
43169: LD_ADDR_VAR 0 2
43173: PUSH
43174: LD_VAR 0 2
43178: PPUSH
43179: LD_INT 4
43181: PPUSH
43182: LD_VAR 0 11
43186: PPUSH
43187: CALL_OW 1
43191: ST_TO_ADDR
// end ; if tmp and mech < 6 then
43192: LD_VAR 0 4
43196: PUSH
43197: LD_VAR 0 7
43201: PUSH
43202: LD_INT 6
43204: LESS
43205: AND
43206: IFFALSE 43394
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
43208: LD_ADDR_VAR 0 9
43212: PUSH
43213: LD_VAR 0 4
43217: PUSH
43218: LD_VAR 0 8
43222: PUSH
43223: LD_VAR 0 7
43227: UNION
43228: DIFF
43229: PPUSH
43230: LD_INT 3
43232: PPUSH
43233: CALL 103293 0 2
43237: ST_TO_ADDR
// p := [ ] ;
43238: LD_ADDR_VAR 0 11
43242: PUSH
43243: EMPTY
43244: ST_TO_ADDR
// if sort then
43245: LD_VAR 0 9
43249: IFFALSE 43365
// for i = 1 to 6 - mech do
43251: LD_ADDR_VAR 0 3
43255: PUSH
43256: DOUBLE
43257: LD_INT 1
43259: DEC
43260: ST_TO_ADDR
43261: LD_INT 6
43263: PUSH
43264: LD_VAR 0 7
43268: MINUS
43269: PUSH
43270: FOR_TO
43271: IFFALSE 43363
// begin if i = sort then
43273: LD_VAR 0 3
43277: PUSH
43278: LD_VAR 0 9
43282: EQUAL
43283: IFFALSE 43287
// break ;
43285: GO 43363
// if GetClass ( i ) = 3 then
43287: LD_VAR 0 3
43291: PPUSH
43292: CALL_OW 257
43296: PUSH
43297: LD_INT 3
43299: EQUAL
43300: IFFALSE 43304
// continue ;
43302: GO 43270
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43304: LD_ADDR_VAR 0 11
43308: PUSH
43309: LD_VAR 0 11
43313: PPUSH
43314: LD_VAR 0 11
43318: PUSH
43319: LD_INT 1
43321: PLUS
43322: PPUSH
43323: LD_VAR 0 9
43327: PUSH
43328: LD_VAR 0 3
43332: ARRAY
43333: PPUSH
43334: CALL_OW 2
43338: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43339: LD_ADDR_VAR 0 4
43343: PUSH
43344: LD_VAR 0 4
43348: PUSH
43349: LD_VAR 0 9
43353: PUSH
43354: LD_VAR 0 3
43358: ARRAY
43359: DIFF
43360: ST_TO_ADDR
// end ;
43361: GO 43270
43363: POP
43364: POP
// if p then
43365: LD_VAR 0 11
43369: IFFALSE 43394
// result := Replace ( result , 3 , p ) ;
43371: LD_ADDR_VAR 0 2
43375: PUSH
43376: LD_VAR 0 2
43380: PPUSH
43381: LD_INT 3
43383: PPUSH
43384: LD_VAR 0 11
43388: PPUSH
43389: CALL_OW 1
43393: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
43394: LD_VAR 0 4
43398: PUSH
43399: LD_INT 6
43401: GREATER
43402: PUSH
43403: LD_VAR 0 6
43407: PUSH
43408: LD_INT 6
43410: LESS
43411: AND
43412: IFFALSE 43606
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
43414: LD_ADDR_VAR 0 9
43418: PUSH
43419: LD_VAR 0 4
43423: PUSH
43424: LD_VAR 0 8
43428: PUSH
43429: LD_VAR 0 7
43433: UNION
43434: PUSH
43435: LD_VAR 0 6
43439: UNION
43440: DIFF
43441: PPUSH
43442: LD_INT 2
43444: PPUSH
43445: CALL 103293 0 2
43449: ST_TO_ADDR
// p := [ ] ;
43450: LD_ADDR_VAR 0 11
43454: PUSH
43455: EMPTY
43456: ST_TO_ADDR
// if sort then
43457: LD_VAR 0 9
43461: IFFALSE 43577
// for i = 1 to 6 - eng do
43463: LD_ADDR_VAR 0 3
43467: PUSH
43468: DOUBLE
43469: LD_INT 1
43471: DEC
43472: ST_TO_ADDR
43473: LD_INT 6
43475: PUSH
43476: LD_VAR 0 6
43480: MINUS
43481: PUSH
43482: FOR_TO
43483: IFFALSE 43575
// begin if i = sort then
43485: LD_VAR 0 3
43489: PUSH
43490: LD_VAR 0 9
43494: EQUAL
43495: IFFALSE 43499
// break ;
43497: GO 43575
// if GetClass ( i ) = 2 then
43499: LD_VAR 0 3
43503: PPUSH
43504: CALL_OW 257
43508: PUSH
43509: LD_INT 2
43511: EQUAL
43512: IFFALSE 43516
// continue ;
43514: GO 43482
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43516: LD_ADDR_VAR 0 11
43520: PUSH
43521: LD_VAR 0 11
43525: PPUSH
43526: LD_VAR 0 11
43530: PUSH
43531: LD_INT 1
43533: PLUS
43534: PPUSH
43535: LD_VAR 0 9
43539: PUSH
43540: LD_VAR 0 3
43544: ARRAY
43545: PPUSH
43546: CALL_OW 2
43550: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43551: LD_ADDR_VAR 0 4
43555: PUSH
43556: LD_VAR 0 4
43560: PUSH
43561: LD_VAR 0 9
43565: PUSH
43566: LD_VAR 0 3
43570: ARRAY
43571: DIFF
43572: ST_TO_ADDR
// end ;
43573: GO 43482
43575: POP
43576: POP
// if p then
43577: LD_VAR 0 11
43581: IFFALSE 43606
// result := Replace ( result , 2 , p ) ;
43583: LD_ADDR_VAR 0 2
43587: PUSH
43588: LD_VAR 0 2
43592: PPUSH
43593: LD_INT 2
43595: PPUSH
43596: LD_VAR 0 11
43600: PPUSH
43601: CALL_OW 1
43605: ST_TO_ADDR
// end ; exit ;
43606: GO 44994
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
43608: LD_EXP 126
43612: PUSH
43613: LD_EXP 125
43617: PUSH
43618: LD_VAR 0 1
43622: ARRAY
43623: ARRAY
43624: NOT
43625: PUSH
43626: LD_EXP 99
43630: PUSH
43631: LD_VAR 0 1
43635: ARRAY
43636: PPUSH
43637: LD_INT 30
43639: PUSH
43640: LD_INT 3
43642: PUSH
43643: EMPTY
43644: LIST
43645: LIST
43646: PPUSH
43647: CALL_OW 72
43651: AND
43652: PUSH
43653: LD_EXP 104
43657: PUSH
43658: LD_VAR 0 1
43662: ARRAY
43663: AND
43664: IFFALSE 44272
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
43666: LD_ADDR_EXP 141
43670: PUSH
43671: LD_EXP 141
43675: PPUSH
43676: LD_VAR 0 1
43680: PPUSH
43681: LD_INT 5
43683: PPUSH
43684: CALL_OW 1
43688: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
43689: LD_ADDR_VAR 0 2
43693: PUSH
43694: LD_INT 0
43696: PUSH
43697: LD_INT 0
43699: PUSH
43700: LD_INT 0
43702: PUSH
43703: LD_INT 0
43705: PUSH
43706: EMPTY
43707: LIST
43708: LIST
43709: LIST
43710: LIST
43711: ST_TO_ADDR
// if sci > 1 then
43712: LD_VAR 0 8
43716: PUSH
43717: LD_INT 1
43719: GREATER
43720: IFFALSE 43748
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
43722: LD_ADDR_VAR 0 4
43726: PUSH
43727: LD_VAR 0 4
43731: PUSH
43732: LD_VAR 0 8
43736: PUSH
43737: LD_VAR 0 8
43741: PUSH
43742: LD_INT 1
43744: ARRAY
43745: DIFF
43746: DIFF
43747: ST_TO_ADDR
// if tmp and not sci then
43748: LD_VAR 0 4
43752: PUSH
43753: LD_VAR 0 8
43757: NOT
43758: AND
43759: IFFALSE 43828
// begin sort := SortBySkill ( tmp , 4 ) ;
43761: LD_ADDR_VAR 0 9
43765: PUSH
43766: LD_VAR 0 4
43770: PPUSH
43771: LD_INT 4
43773: PPUSH
43774: CALL 103293 0 2
43778: ST_TO_ADDR
// if sort then
43779: LD_VAR 0 9
43783: IFFALSE 43799
// p := sort [ 1 ] ;
43785: LD_ADDR_VAR 0 11
43789: PUSH
43790: LD_VAR 0 9
43794: PUSH
43795: LD_INT 1
43797: ARRAY
43798: ST_TO_ADDR
// if p then
43799: LD_VAR 0 11
43803: IFFALSE 43828
// result := Replace ( result , 4 , p ) ;
43805: LD_ADDR_VAR 0 2
43809: PUSH
43810: LD_VAR 0 2
43814: PPUSH
43815: LD_INT 4
43817: PPUSH
43818: LD_VAR 0 11
43822: PPUSH
43823: CALL_OW 1
43827: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
43828: LD_ADDR_VAR 0 4
43832: PUSH
43833: LD_VAR 0 4
43837: PUSH
43838: LD_VAR 0 7
43842: DIFF
43843: ST_TO_ADDR
// if tmp and mech < 6 then
43844: LD_VAR 0 4
43848: PUSH
43849: LD_VAR 0 7
43853: PUSH
43854: LD_INT 6
43856: LESS
43857: AND
43858: IFFALSE 44046
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
43860: LD_ADDR_VAR 0 9
43864: PUSH
43865: LD_VAR 0 4
43869: PUSH
43870: LD_VAR 0 8
43874: PUSH
43875: LD_VAR 0 7
43879: UNION
43880: DIFF
43881: PPUSH
43882: LD_INT 3
43884: PPUSH
43885: CALL 103293 0 2
43889: ST_TO_ADDR
// p := [ ] ;
43890: LD_ADDR_VAR 0 11
43894: PUSH
43895: EMPTY
43896: ST_TO_ADDR
// if sort then
43897: LD_VAR 0 9
43901: IFFALSE 44017
// for i = 1 to 6 - mech do
43903: LD_ADDR_VAR 0 3
43907: PUSH
43908: DOUBLE
43909: LD_INT 1
43911: DEC
43912: ST_TO_ADDR
43913: LD_INT 6
43915: PUSH
43916: LD_VAR 0 7
43920: MINUS
43921: PUSH
43922: FOR_TO
43923: IFFALSE 44015
// begin if i = sort then
43925: LD_VAR 0 3
43929: PUSH
43930: LD_VAR 0 9
43934: EQUAL
43935: IFFALSE 43939
// break ;
43937: GO 44015
// if GetClass ( i ) = 3 then
43939: LD_VAR 0 3
43943: PPUSH
43944: CALL_OW 257
43948: PUSH
43949: LD_INT 3
43951: EQUAL
43952: IFFALSE 43956
// continue ;
43954: GO 43922
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43956: LD_ADDR_VAR 0 11
43960: PUSH
43961: LD_VAR 0 11
43965: PPUSH
43966: LD_VAR 0 11
43970: PUSH
43971: LD_INT 1
43973: PLUS
43974: PPUSH
43975: LD_VAR 0 9
43979: PUSH
43980: LD_VAR 0 3
43984: ARRAY
43985: PPUSH
43986: CALL_OW 2
43990: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43991: LD_ADDR_VAR 0 4
43995: PUSH
43996: LD_VAR 0 4
44000: PUSH
44001: LD_VAR 0 9
44005: PUSH
44006: LD_VAR 0 3
44010: ARRAY
44011: DIFF
44012: ST_TO_ADDR
// end ;
44013: GO 43922
44015: POP
44016: POP
// if p then
44017: LD_VAR 0 11
44021: IFFALSE 44046
// result := Replace ( result , 3 , p ) ;
44023: LD_ADDR_VAR 0 2
44027: PUSH
44028: LD_VAR 0 2
44032: PPUSH
44033: LD_INT 3
44035: PPUSH
44036: LD_VAR 0 11
44040: PPUSH
44041: CALL_OW 1
44045: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
44046: LD_ADDR_VAR 0 4
44050: PUSH
44051: LD_VAR 0 4
44055: PUSH
44056: LD_VAR 0 6
44060: DIFF
44061: ST_TO_ADDR
// if tmp and eng < 6 then
44062: LD_VAR 0 4
44066: PUSH
44067: LD_VAR 0 6
44071: PUSH
44072: LD_INT 6
44074: LESS
44075: AND
44076: IFFALSE 44270
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
44078: LD_ADDR_VAR 0 9
44082: PUSH
44083: LD_VAR 0 4
44087: PUSH
44088: LD_VAR 0 8
44092: PUSH
44093: LD_VAR 0 7
44097: UNION
44098: PUSH
44099: LD_VAR 0 6
44103: UNION
44104: DIFF
44105: PPUSH
44106: LD_INT 2
44108: PPUSH
44109: CALL 103293 0 2
44113: ST_TO_ADDR
// p := [ ] ;
44114: LD_ADDR_VAR 0 11
44118: PUSH
44119: EMPTY
44120: ST_TO_ADDR
// if sort then
44121: LD_VAR 0 9
44125: IFFALSE 44241
// for i = 1 to 6 - eng do
44127: LD_ADDR_VAR 0 3
44131: PUSH
44132: DOUBLE
44133: LD_INT 1
44135: DEC
44136: ST_TO_ADDR
44137: LD_INT 6
44139: PUSH
44140: LD_VAR 0 6
44144: MINUS
44145: PUSH
44146: FOR_TO
44147: IFFALSE 44239
// begin if i = sort then
44149: LD_VAR 0 3
44153: PUSH
44154: LD_VAR 0 9
44158: EQUAL
44159: IFFALSE 44163
// break ;
44161: GO 44239
// if GetClass ( i ) = 2 then
44163: LD_VAR 0 3
44167: PPUSH
44168: CALL_OW 257
44172: PUSH
44173: LD_INT 2
44175: EQUAL
44176: IFFALSE 44180
// continue ;
44178: GO 44146
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44180: LD_ADDR_VAR 0 11
44184: PUSH
44185: LD_VAR 0 11
44189: PPUSH
44190: LD_VAR 0 11
44194: PUSH
44195: LD_INT 1
44197: PLUS
44198: PPUSH
44199: LD_VAR 0 9
44203: PUSH
44204: LD_VAR 0 3
44208: ARRAY
44209: PPUSH
44210: CALL_OW 2
44214: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44215: LD_ADDR_VAR 0 4
44219: PUSH
44220: LD_VAR 0 4
44224: PUSH
44225: LD_VAR 0 9
44229: PUSH
44230: LD_VAR 0 3
44234: ARRAY
44235: DIFF
44236: ST_TO_ADDR
// end ;
44237: GO 44146
44239: POP
44240: POP
// if p then
44241: LD_VAR 0 11
44245: IFFALSE 44270
// result := Replace ( result , 2 , p ) ;
44247: LD_ADDR_VAR 0 2
44251: PUSH
44252: LD_VAR 0 2
44256: PPUSH
44257: LD_INT 2
44259: PPUSH
44260: LD_VAR 0 11
44264: PPUSH
44265: CALL_OW 1
44269: ST_TO_ADDR
// end ; exit ;
44270: GO 44994
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
44272: LD_EXP 126
44276: PUSH
44277: LD_EXP 125
44281: PUSH
44282: LD_VAR 0 1
44286: ARRAY
44287: ARRAY
44288: NOT
44289: PUSH
44290: LD_EXP 99
44294: PUSH
44295: LD_VAR 0 1
44299: ARRAY
44300: PPUSH
44301: LD_INT 30
44303: PUSH
44304: LD_INT 3
44306: PUSH
44307: EMPTY
44308: LIST
44309: LIST
44310: PPUSH
44311: CALL_OW 72
44315: AND
44316: PUSH
44317: LD_EXP 104
44321: PUSH
44322: LD_VAR 0 1
44326: ARRAY
44327: NOT
44328: AND
44329: IFFALSE 44994
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
44331: LD_ADDR_EXP 141
44335: PUSH
44336: LD_EXP 141
44340: PPUSH
44341: LD_VAR 0 1
44345: PPUSH
44346: LD_INT 6
44348: PPUSH
44349: CALL_OW 1
44353: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
44354: LD_ADDR_VAR 0 2
44358: PUSH
44359: LD_INT 0
44361: PUSH
44362: LD_INT 0
44364: PUSH
44365: LD_INT 0
44367: PUSH
44368: LD_INT 0
44370: PUSH
44371: EMPTY
44372: LIST
44373: LIST
44374: LIST
44375: LIST
44376: ST_TO_ADDR
// if sci >= 1 then
44377: LD_VAR 0 8
44381: PUSH
44382: LD_INT 1
44384: GREATEREQUAL
44385: IFFALSE 44407
// tmp := tmp diff sci [ 1 ] ;
44387: LD_ADDR_VAR 0 4
44391: PUSH
44392: LD_VAR 0 4
44396: PUSH
44397: LD_VAR 0 8
44401: PUSH
44402: LD_INT 1
44404: ARRAY
44405: DIFF
44406: ST_TO_ADDR
// if tmp and not sci then
44407: LD_VAR 0 4
44411: PUSH
44412: LD_VAR 0 8
44416: NOT
44417: AND
44418: IFFALSE 44487
// begin sort := SortBySkill ( tmp , 4 ) ;
44420: LD_ADDR_VAR 0 9
44424: PUSH
44425: LD_VAR 0 4
44429: PPUSH
44430: LD_INT 4
44432: PPUSH
44433: CALL 103293 0 2
44437: ST_TO_ADDR
// if sort then
44438: LD_VAR 0 9
44442: IFFALSE 44458
// p := sort [ 1 ] ;
44444: LD_ADDR_VAR 0 11
44448: PUSH
44449: LD_VAR 0 9
44453: PUSH
44454: LD_INT 1
44456: ARRAY
44457: ST_TO_ADDR
// if p then
44458: LD_VAR 0 11
44462: IFFALSE 44487
// result := Replace ( result , 4 , p ) ;
44464: LD_ADDR_VAR 0 2
44468: PUSH
44469: LD_VAR 0 2
44473: PPUSH
44474: LD_INT 4
44476: PPUSH
44477: LD_VAR 0 11
44481: PPUSH
44482: CALL_OW 1
44486: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
44487: LD_ADDR_VAR 0 4
44491: PUSH
44492: LD_VAR 0 4
44496: PUSH
44497: LD_VAR 0 7
44501: DIFF
44502: ST_TO_ADDR
// if tmp and mech < 6 then
44503: LD_VAR 0 4
44507: PUSH
44508: LD_VAR 0 7
44512: PUSH
44513: LD_INT 6
44515: LESS
44516: AND
44517: IFFALSE 44699
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
44519: LD_ADDR_VAR 0 9
44523: PUSH
44524: LD_VAR 0 4
44528: PUSH
44529: LD_VAR 0 7
44533: DIFF
44534: PPUSH
44535: LD_INT 3
44537: PPUSH
44538: CALL 103293 0 2
44542: ST_TO_ADDR
// p := [ ] ;
44543: LD_ADDR_VAR 0 11
44547: PUSH
44548: EMPTY
44549: ST_TO_ADDR
// if sort then
44550: LD_VAR 0 9
44554: IFFALSE 44670
// for i = 1 to 6 - mech do
44556: LD_ADDR_VAR 0 3
44560: PUSH
44561: DOUBLE
44562: LD_INT 1
44564: DEC
44565: ST_TO_ADDR
44566: LD_INT 6
44568: PUSH
44569: LD_VAR 0 7
44573: MINUS
44574: PUSH
44575: FOR_TO
44576: IFFALSE 44668
// begin if i = sort then
44578: LD_VAR 0 3
44582: PUSH
44583: LD_VAR 0 9
44587: EQUAL
44588: IFFALSE 44592
// break ;
44590: GO 44668
// if GetClass ( i ) = 3 then
44592: LD_VAR 0 3
44596: PPUSH
44597: CALL_OW 257
44601: PUSH
44602: LD_INT 3
44604: EQUAL
44605: IFFALSE 44609
// continue ;
44607: GO 44575
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44609: LD_ADDR_VAR 0 11
44613: PUSH
44614: LD_VAR 0 11
44618: PPUSH
44619: LD_VAR 0 11
44623: PUSH
44624: LD_INT 1
44626: PLUS
44627: PPUSH
44628: LD_VAR 0 9
44632: PUSH
44633: LD_VAR 0 3
44637: ARRAY
44638: PPUSH
44639: CALL_OW 2
44643: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44644: LD_ADDR_VAR 0 4
44648: PUSH
44649: LD_VAR 0 4
44653: PUSH
44654: LD_VAR 0 9
44658: PUSH
44659: LD_VAR 0 3
44663: ARRAY
44664: DIFF
44665: ST_TO_ADDR
// end ;
44666: GO 44575
44668: POP
44669: POP
// if p then
44670: LD_VAR 0 11
44674: IFFALSE 44699
// result := Replace ( result , 3 , p ) ;
44676: LD_ADDR_VAR 0 2
44680: PUSH
44681: LD_VAR 0 2
44685: PPUSH
44686: LD_INT 3
44688: PPUSH
44689: LD_VAR 0 11
44693: PPUSH
44694: CALL_OW 1
44698: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
44699: LD_ADDR_VAR 0 4
44703: PUSH
44704: LD_VAR 0 4
44708: PUSH
44709: LD_VAR 0 6
44713: DIFF
44714: ST_TO_ADDR
// if tmp and eng < 4 then
44715: LD_VAR 0 4
44719: PUSH
44720: LD_VAR 0 6
44724: PUSH
44725: LD_INT 4
44727: LESS
44728: AND
44729: IFFALSE 44919
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
44731: LD_ADDR_VAR 0 9
44735: PUSH
44736: LD_VAR 0 4
44740: PUSH
44741: LD_VAR 0 7
44745: PUSH
44746: LD_VAR 0 6
44750: UNION
44751: DIFF
44752: PPUSH
44753: LD_INT 2
44755: PPUSH
44756: CALL 103293 0 2
44760: ST_TO_ADDR
// p := [ ] ;
44761: LD_ADDR_VAR 0 11
44765: PUSH
44766: EMPTY
44767: ST_TO_ADDR
// if sort then
44768: LD_VAR 0 9
44772: IFFALSE 44888
// for i = 1 to 4 - eng do
44774: LD_ADDR_VAR 0 3
44778: PUSH
44779: DOUBLE
44780: LD_INT 1
44782: DEC
44783: ST_TO_ADDR
44784: LD_INT 4
44786: PUSH
44787: LD_VAR 0 6
44791: MINUS
44792: PUSH
44793: FOR_TO
44794: IFFALSE 44886
// begin if i = sort then
44796: LD_VAR 0 3
44800: PUSH
44801: LD_VAR 0 9
44805: EQUAL
44806: IFFALSE 44810
// break ;
44808: GO 44886
// if GetClass ( i ) = 2 then
44810: LD_VAR 0 3
44814: PPUSH
44815: CALL_OW 257
44819: PUSH
44820: LD_INT 2
44822: EQUAL
44823: IFFALSE 44827
// continue ;
44825: GO 44793
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44827: LD_ADDR_VAR 0 11
44831: PUSH
44832: LD_VAR 0 11
44836: PPUSH
44837: LD_VAR 0 11
44841: PUSH
44842: LD_INT 1
44844: PLUS
44845: PPUSH
44846: LD_VAR 0 9
44850: PUSH
44851: LD_VAR 0 3
44855: ARRAY
44856: PPUSH
44857: CALL_OW 2
44861: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44862: LD_ADDR_VAR 0 4
44866: PUSH
44867: LD_VAR 0 4
44871: PUSH
44872: LD_VAR 0 9
44876: PUSH
44877: LD_VAR 0 3
44881: ARRAY
44882: DIFF
44883: ST_TO_ADDR
// end ;
44884: GO 44793
44886: POP
44887: POP
// if p then
44888: LD_VAR 0 11
44892: IFFALSE 44917
// result := Replace ( result , 2 , p ) ;
44894: LD_ADDR_VAR 0 2
44898: PUSH
44899: LD_VAR 0 2
44903: PPUSH
44904: LD_INT 2
44906: PPUSH
44907: LD_VAR 0 11
44911: PPUSH
44912: CALL_OW 1
44916: ST_TO_ADDR
// end else
44917: GO 44963
// for i = eng downto 5 do
44919: LD_ADDR_VAR 0 3
44923: PUSH
44924: DOUBLE
44925: LD_VAR 0 6
44929: INC
44930: ST_TO_ADDR
44931: LD_INT 5
44933: PUSH
44934: FOR_DOWNTO
44935: IFFALSE 44961
// tmp := tmp union eng [ i ] ;
44937: LD_ADDR_VAR 0 4
44941: PUSH
44942: LD_VAR 0 4
44946: PUSH
44947: LD_VAR 0 6
44951: PUSH
44952: LD_VAR 0 3
44956: ARRAY
44957: UNION
44958: ST_TO_ADDR
44959: GO 44934
44961: POP
44962: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
44963: LD_ADDR_VAR 0 2
44967: PUSH
44968: LD_VAR 0 2
44972: PPUSH
44973: LD_INT 1
44975: PPUSH
44976: LD_VAR 0 4
44980: PUSH
44981: LD_VAR 0 5
44985: DIFF
44986: PPUSH
44987: CALL_OW 1
44991: ST_TO_ADDR
// exit ;
44992: GO 44994
// end ; end ;
44994: LD_VAR 0 2
44998: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
44999: LD_INT 0
45001: PPUSH
45002: PPUSH
45003: PPUSH
// if not mc_bases then
45004: LD_EXP 99
45008: NOT
45009: IFFALSE 45013
// exit ;
45011: GO 45155
// for i = 1 to mc_bases do
45013: LD_ADDR_VAR 0 2
45017: PUSH
45018: DOUBLE
45019: LD_INT 1
45021: DEC
45022: ST_TO_ADDR
45023: LD_EXP 99
45027: PUSH
45028: FOR_TO
45029: IFFALSE 45146
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
45031: LD_ADDR_VAR 0 3
45035: PUSH
45036: LD_EXP 99
45040: PUSH
45041: LD_VAR 0 2
45045: ARRAY
45046: PPUSH
45047: LD_INT 21
45049: PUSH
45050: LD_INT 3
45052: PUSH
45053: EMPTY
45054: LIST
45055: LIST
45056: PUSH
45057: LD_INT 3
45059: PUSH
45060: LD_INT 2
45062: PUSH
45063: LD_INT 30
45065: PUSH
45066: LD_INT 29
45068: PUSH
45069: EMPTY
45070: LIST
45071: LIST
45072: PUSH
45073: LD_INT 30
45075: PUSH
45076: LD_INT 30
45078: PUSH
45079: EMPTY
45080: LIST
45081: LIST
45082: PUSH
45083: EMPTY
45084: LIST
45085: LIST
45086: LIST
45087: PUSH
45088: EMPTY
45089: LIST
45090: LIST
45091: PUSH
45092: LD_INT 3
45094: PUSH
45095: LD_INT 24
45097: PUSH
45098: LD_INT 1000
45100: PUSH
45101: EMPTY
45102: LIST
45103: LIST
45104: PUSH
45105: EMPTY
45106: LIST
45107: LIST
45108: PUSH
45109: EMPTY
45110: LIST
45111: LIST
45112: LIST
45113: PPUSH
45114: CALL_OW 72
45118: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
45119: LD_ADDR_EXP 100
45123: PUSH
45124: LD_EXP 100
45128: PPUSH
45129: LD_VAR 0 2
45133: PPUSH
45134: LD_VAR 0 3
45138: PPUSH
45139: CALL_OW 1
45143: ST_TO_ADDR
// end ;
45144: GO 45028
45146: POP
45147: POP
// RaiseSailEvent ( 101 ) ;
45148: LD_INT 101
45150: PPUSH
45151: CALL_OW 427
// end ;
45155: LD_VAR 0 1
45159: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
45160: LD_INT 0
45162: PPUSH
45163: PPUSH
45164: PPUSH
45165: PPUSH
45166: PPUSH
45167: PPUSH
45168: PPUSH
// if not mc_bases then
45169: LD_EXP 99
45173: NOT
45174: IFFALSE 45178
// exit ;
45176: GO 45740
// for i = 1 to mc_bases do
45178: LD_ADDR_VAR 0 2
45182: PUSH
45183: DOUBLE
45184: LD_INT 1
45186: DEC
45187: ST_TO_ADDR
45188: LD_EXP 99
45192: PUSH
45193: FOR_TO
45194: IFFALSE 45731
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
45196: LD_ADDR_VAR 0 5
45200: PUSH
45201: LD_EXP 99
45205: PUSH
45206: LD_VAR 0 2
45210: ARRAY
45211: PUSH
45212: LD_EXP 128
45216: PUSH
45217: LD_VAR 0 2
45221: ARRAY
45222: UNION
45223: PPUSH
45224: LD_INT 21
45226: PUSH
45227: LD_INT 1
45229: PUSH
45230: EMPTY
45231: LIST
45232: LIST
45233: PUSH
45234: LD_INT 1
45236: PUSH
45237: LD_INT 3
45239: PUSH
45240: LD_INT 54
45242: PUSH
45243: EMPTY
45244: LIST
45245: PUSH
45246: EMPTY
45247: LIST
45248: LIST
45249: PUSH
45250: LD_INT 3
45252: PUSH
45253: LD_INT 24
45255: PUSH
45256: LD_INT 1000
45258: PUSH
45259: EMPTY
45260: LIST
45261: LIST
45262: PUSH
45263: EMPTY
45264: LIST
45265: LIST
45266: PUSH
45267: EMPTY
45268: LIST
45269: LIST
45270: LIST
45271: PUSH
45272: EMPTY
45273: LIST
45274: LIST
45275: PPUSH
45276: CALL_OW 72
45280: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
45281: LD_ADDR_VAR 0 6
45285: PUSH
45286: LD_EXP 99
45290: PUSH
45291: LD_VAR 0 2
45295: ARRAY
45296: PPUSH
45297: LD_INT 21
45299: PUSH
45300: LD_INT 1
45302: PUSH
45303: EMPTY
45304: LIST
45305: LIST
45306: PUSH
45307: LD_INT 1
45309: PUSH
45310: LD_INT 3
45312: PUSH
45313: LD_INT 54
45315: PUSH
45316: EMPTY
45317: LIST
45318: PUSH
45319: EMPTY
45320: LIST
45321: LIST
45322: PUSH
45323: LD_INT 3
45325: PUSH
45326: LD_INT 24
45328: PUSH
45329: LD_INT 250
45331: PUSH
45332: EMPTY
45333: LIST
45334: LIST
45335: PUSH
45336: EMPTY
45337: LIST
45338: LIST
45339: PUSH
45340: EMPTY
45341: LIST
45342: LIST
45343: LIST
45344: PUSH
45345: EMPTY
45346: LIST
45347: LIST
45348: PPUSH
45349: CALL_OW 72
45353: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
45354: LD_ADDR_VAR 0 7
45358: PUSH
45359: LD_VAR 0 5
45363: PUSH
45364: LD_VAR 0 6
45368: DIFF
45369: ST_TO_ADDR
// if not need_heal_1 then
45370: LD_VAR 0 6
45374: NOT
45375: IFFALSE 45408
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
45377: LD_ADDR_EXP 102
45381: PUSH
45382: LD_EXP 102
45386: PPUSH
45387: LD_VAR 0 2
45391: PUSH
45392: LD_INT 1
45394: PUSH
45395: EMPTY
45396: LIST
45397: LIST
45398: PPUSH
45399: EMPTY
45400: PPUSH
45401: CALL 72472 0 3
45405: ST_TO_ADDR
45406: GO 45478
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
45408: LD_ADDR_EXP 102
45412: PUSH
45413: LD_EXP 102
45417: PPUSH
45418: LD_VAR 0 2
45422: PUSH
45423: LD_INT 1
45425: PUSH
45426: EMPTY
45427: LIST
45428: LIST
45429: PPUSH
45430: LD_EXP 102
45434: PUSH
45435: LD_VAR 0 2
45439: ARRAY
45440: PUSH
45441: LD_INT 1
45443: ARRAY
45444: PPUSH
45445: LD_INT 3
45447: PUSH
45448: LD_INT 24
45450: PUSH
45451: LD_INT 1000
45453: PUSH
45454: EMPTY
45455: LIST
45456: LIST
45457: PUSH
45458: EMPTY
45459: LIST
45460: LIST
45461: PPUSH
45462: CALL_OW 72
45466: PUSH
45467: LD_VAR 0 6
45471: UNION
45472: PPUSH
45473: CALL 72472 0 3
45477: ST_TO_ADDR
// if not need_heal_2 then
45478: LD_VAR 0 7
45482: NOT
45483: IFFALSE 45516
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
45485: LD_ADDR_EXP 102
45489: PUSH
45490: LD_EXP 102
45494: PPUSH
45495: LD_VAR 0 2
45499: PUSH
45500: LD_INT 2
45502: PUSH
45503: EMPTY
45504: LIST
45505: LIST
45506: PPUSH
45507: EMPTY
45508: PPUSH
45509: CALL 72472 0 3
45513: ST_TO_ADDR
45514: GO 45548
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
45516: LD_ADDR_EXP 102
45520: PUSH
45521: LD_EXP 102
45525: PPUSH
45526: LD_VAR 0 2
45530: PUSH
45531: LD_INT 2
45533: PUSH
45534: EMPTY
45535: LIST
45536: LIST
45537: PPUSH
45538: LD_VAR 0 7
45542: PPUSH
45543: CALL 72472 0 3
45547: ST_TO_ADDR
// if need_heal_2 then
45548: LD_VAR 0 7
45552: IFFALSE 45713
// for j in need_heal_2 do
45554: LD_ADDR_VAR 0 3
45558: PUSH
45559: LD_VAR 0 7
45563: PUSH
45564: FOR_IN
45565: IFFALSE 45711
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45567: LD_ADDR_VAR 0 5
45571: PUSH
45572: LD_EXP 99
45576: PUSH
45577: LD_VAR 0 2
45581: ARRAY
45582: PPUSH
45583: LD_INT 2
45585: PUSH
45586: LD_INT 30
45588: PUSH
45589: LD_INT 6
45591: PUSH
45592: EMPTY
45593: LIST
45594: LIST
45595: PUSH
45596: LD_INT 30
45598: PUSH
45599: LD_INT 7
45601: PUSH
45602: EMPTY
45603: LIST
45604: LIST
45605: PUSH
45606: LD_INT 30
45608: PUSH
45609: LD_INT 8
45611: PUSH
45612: EMPTY
45613: LIST
45614: LIST
45615: PUSH
45616: LD_INT 30
45618: PUSH
45619: LD_INT 0
45621: PUSH
45622: EMPTY
45623: LIST
45624: LIST
45625: PUSH
45626: LD_INT 30
45628: PUSH
45629: LD_INT 1
45631: PUSH
45632: EMPTY
45633: LIST
45634: LIST
45635: PUSH
45636: EMPTY
45637: LIST
45638: LIST
45639: LIST
45640: LIST
45641: LIST
45642: LIST
45643: PPUSH
45644: CALL_OW 72
45648: ST_TO_ADDR
// if tmp then
45649: LD_VAR 0 5
45653: IFFALSE 45709
// begin k := NearestUnitToUnit ( tmp , j ) ;
45655: LD_ADDR_VAR 0 4
45659: PUSH
45660: LD_VAR 0 5
45664: PPUSH
45665: LD_VAR 0 3
45669: PPUSH
45670: CALL_OW 74
45674: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
45675: LD_VAR 0 3
45679: PPUSH
45680: LD_VAR 0 4
45684: PPUSH
45685: CALL_OW 296
45689: PUSH
45690: LD_INT 5
45692: GREATER
45693: IFFALSE 45709
// ComMoveToNearbyEntrance ( j , k ) ;
45695: LD_VAR 0 3
45699: PPUSH
45700: LD_VAR 0 4
45704: PPUSH
45705: CALL 105661 0 2
// end ; end ;
45709: GO 45564
45711: POP
45712: POP
// if not need_heal_1 and not need_heal_2 then
45713: LD_VAR 0 6
45717: NOT
45718: PUSH
45719: LD_VAR 0 7
45723: NOT
45724: AND
45725: IFFALSE 45729
// continue ;
45727: GO 45193
// end ;
45729: GO 45193
45731: POP
45732: POP
// RaiseSailEvent ( 102 ) ;
45733: LD_INT 102
45735: PPUSH
45736: CALL_OW 427
// end ;
45740: LD_VAR 0 1
45744: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
45745: LD_INT 0
45747: PPUSH
45748: PPUSH
45749: PPUSH
45750: PPUSH
45751: PPUSH
45752: PPUSH
45753: PPUSH
45754: PPUSH
// if not mc_bases then
45755: LD_EXP 99
45759: NOT
45760: IFFALSE 45764
// exit ;
45762: GO 46675
// for i = 1 to mc_bases do
45764: LD_ADDR_VAR 0 2
45768: PUSH
45769: DOUBLE
45770: LD_INT 1
45772: DEC
45773: ST_TO_ADDR
45774: LD_EXP 99
45778: PUSH
45779: FOR_TO
45780: IFFALSE 46673
// begin if not mc_building_need_repair [ i ] then
45782: LD_EXP 100
45786: PUSH
45787: LD_VAR 0 2
45791: ARRAY
45792: NOT
45793: IFFALSE 45978
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
45795: LD_ADDR_VAR 0 6
45799: PUSH
45800: LD_EXP 118
45804: PUSH
45805: LD_VAR 0 2
45809: ARRAY
45810: PPUSH
45811: LD_INT 3
45813: PUSH
45814: LD_INT 24
45816: PUSH
45817: LD_INT 1000
45819: PUSH
45820: EMPTY
45821: LIST
45822: LIST
45823: PUSH
45824: EMPTY
45825: LIST
45826: LIST
45827: PUSH
45828: LD_INT 2
45830: PUSH
45831: LD_INT 34
45833: PUSH
45834: LD_INT 13
45836: PUSH
45837: EMPTY
45838: LIST
45839: LIST
45840: PUSH
45841: LD_INT 34
45843: PUSH
45844: LD_INT 52
45846: PUSH
45847: EMPTY
45848: LIST
45849: LIST
45850: PUSH
45851: LD_INT 34
45853: PUSH
45854: LD_INT 88
45856: PUSH
45857: EMPTY
45858: LIST
45859: LIST
45860: PUSH
45861: EMPTY
45862: LIST
45863: LIST
45864: LIST
45865: LIST
45866: PUSH
45867: EMPTY
45868: LIST
45869: LIST
45870: PPUSH
45871: CALL_OW 72
45875: ST_TO_ADDR
// if cranes then
45876: LD_VAR 0 6
45880: IFFALSE 45942
// for j in cranes do
45882: LD_ADDR_VAR 0 3
45886: PUSH
45887: LD_VAR 0 6
45891: PUSH
45892: FOR_IN
45893: IFFALSE 45940
// if not IsInArea ( j , mc_parking [ i ] ) then
45895: LD_VAR 0 3
45899: PPUSH
45900: LD_EXP 123
45904: PUSH
45905: LD_VAR 0 2
45909: ARRAY
45910: PPUSH
45911: CALL_OW 308
45915: NOT
45916: IFFALSE 45938
// ComMoveToArea ( j , mc_parking [ i ] ) ;
45918: LD_VAR 0 3
45922: PPUSH
45923: LD_EXP 123
45927: PUSH
45928: LD_VAR 0 2
45932: ARRAY
45933: PPUSH
45934: CALL_OW 113
45938: GO 45892
45940: POP
45941: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
45942: LD_ADDR_EXP 101
45946: PUSH
45947: LD_EXP 101
45951: PPUSH
45952: LD_VAR 0 2
45956: PPUSH
45957: EMPTY
45958: PPUSH
45959: CALL_OW 1
45963: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
45964: LD_VAR 0 2
45968: PPUSH
45969: LD_INT 101
45971: PPUSH
45972: CALL 40832 0 2
// continue ;
45976: GO 45779
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
45978: LD_ADDR_EXP 105
45982: PUSH
45983: LD_EXP 105
45987: PPUSH
45988: LD_VAR 0 2
45992: PPUSH
45993: EMPTY
45994: PPUSH
45995: CALL_OW 1
45999: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
46000: LD_VAR 0 2
46004: PPUSH
46005: LD_INT 103
46007: PPUSH
46008: CALL 40832 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
46012: LD_ADDR_VAR 0 5
46016: PUSH
46017: LD_EXP 99
46021: PUSH
46022: LD_VAR 0 2
46026: ARRAY
46027: PUSH
46028: LD_EXP 128
46032: PUSH
46033: LD_VAR 0 2
46037: ARRAY
46038: UNION
46039: PPUSH
46040: LD_INT 2
46042: PUSH
46043: LD_INT 25
46045: PUSH
46046: LD_INT 2
46048: PUSH
46049: EMPTY
46050: LIST
46051: LIST
46052: PUSH
46053: LD_INT 25
46055: PUSH
46056: LD_INT 16
46058: PUSH
46059: EMPTY
46060: LIST
46061: LIST
46062: PUSH
46063: EMPTY
46064: LIST
46065: LIST
46066: LIST
46067: PUSH
46068: EMPTY
46069: LIST
46070: PPUSH
46071: CALL_OW 72
46075: ST_TO_ADDR
// if mc_need_heal [ i ] then
46076: LD_EXP 102
46080: PUSH
46081: LD_VAR 0 2
46085: ARRAY
46086: IFFALSE 46130
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
46088: LD_ADDR_VAR 0 5
46092: PUSH
46093: LD_VAR 0 5
46097: PUSH
46098: LD_EXP 102
46102: PUSH
46103: LD_VAR 0 2
46107: ARRAY
46108: PUSH
46109: LD_INT 1
46111: ARRAY
46112: PUSH
46113: LD_EXP 102
46117: PUSH
46118: LD_VAR 0 2
46122: ARRAY
46123: PUSH
46124: LD_INT 2
46126: ARRAY
46127: UNION
46128: DIFF
46129: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
46130: LD_ADDR_VAR 0 6
46134: PUSH
46135: LD_EXP 118
46139: PUSH
46140: LD_VAR 0 2
46144: ARRAY
46145: PPUSH
46146: LD_INT 2
46148: PUSH
46149: LD_INT 34
46151: PUSH
46152: LD_INT 13
46154: PUSH
46155: EMPTY
46156: LIST
46157: LIST
46158: PUSH
46159: LD_INT 34
46161: PUSH
46162: LD_INT 52
46164: PUSH
46165: EMPTY
46166: LIST
46167: LIST
46168: PUSH
46169: LD_INT 34
46171: PUSH
46172: LD_INT 88
46174: PUSH
46175: EMPTY
46176: LIST
46177: LIST
46178: PUSH
46179: EMPTY
46180: LIST
46181: LIST
46182: LIST
46183: LIST
46184: PPUSH
46185: CALL_OW 72
46189: ST_TO_ADDR
// if cranes then
46190: LD_VAR 0 6
46194: IFFALSE 46362
// begin for j in cranes do
46196: LD_ADDR_VAR 0 3
46200: PUSH
46201: LD_VAR 0 6
46205: PUSH
46206: FOR_IN
46207: IFFALSE 46360
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
46209: LD_VAR 0 3
46213: PPUSH
46214: CALL_OW 256
46218: PUSH
46219: LD_INT 1000
46221: EQUAL
46222: PUSH
46223: LD_VAR 0 3
46227: PPUSH
46228: CALL_OW 314
46232: NOT
46233: AND
46234: IFFALSE 46300
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
46236: LD_ADDR_VAR 0 8
46240: PUSH
46241: LD_EXP 100
46245: PUSH
46246: LD_VAR 0 2
46250: ARRAY
46251: PPUSH
46252: LD_VAR 0 3
46256: PPUSH
46257: CALL_OW 74
46261: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
46262: LD_VAR 0 8
46266: PPUSH
46267: LD_INT 16
46269: PPUSH
46270: CALL 75069 0 2
46274: PUSH
46275: LD_INT 4
46277: ARRAY
46278: PUSH
46279: LD_INT 10
46281: LESS
46282: IFFALSE 46298
// ComRepairBuilding ( j , to_repair ) ;
46284: LD_VAR 0 3
46288: PPUSH
46289: LD_VAR 0 8
46293: PPUSH
46294: CALL_OW 130
// end else
46298: GO 46358
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
46300: LD_VAR 0 3
46304: PPUSH
46305: CALL_OW 256
46309: PUSH
46310: LD_INT 500
46312: LESS
46313: PUSH
46314: LD_VAR 0 3
46318: PPUSH
46319: LD_EXP 123
46323: PUSH
46324: LD_VAR 0 2
46328: ARRAY
46329: PPUSH
46330: CALL_OW 308
46334: NOT
46335: AND
46336: IFFALSE 46358
// ComMoveToArea ( j , mc_parking [ i ] ) ;
46338: LD_VAR 0 3
46342: PPUSH
46343: LD_EXP 123
46347: PUSH
46348: LD_VAR 0 2
46352: ARRAY
46353: PPUSH
46354: CALL_OW 113
// end ;
46358: GO 46206
46360: POP
46361: POP
// end ; if tmp > 3 then
46362: LD_VAR 0 5
46366: PUSH
46367: LD_INT 3
46369: GREATER
46370: IFFALSE 46390
// tmp := ShrinkArray ( tmp , 4 ) ;
46372: LD_ADDR_VAR 0 5
46376: PUSH
46377: LD_VAR 0 5
46381: PPUSH
46382: LD_INT 4
46384: PPUSH
46385: CALL 105099 0 2
46389: ST_TO_ADDR
// if not tmp then
46390: LD_VAR 0 5
46394: NOT
46395: IFFALSE 46399
// continue ;
46397: GO 45779
// for j in tmp do
46399: LD_ADDR_VAR 0 3
46403: PUSH
46404: LD_VAR 0 5
46408: PUSH
46409: FOR_IN
46410: IFFALSE 46669
// begin if IsInUnit ( j ) then
46412: LD_VAR 0 3
46416: PPUSH
46417: CALL_OW 310
46421: IFFALSE 46432
// ComExitBuilding ( j ) ;
46423: LD_VAR 0 3
46427: PPUSH
46428: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
46432: LD_VAR 0 3
46436: PUSH
46437: LD_EXP 101
46441: PUSH
46442: LD_VAR 0 2
46446: ARRAY
46447: IN
46448: NOT
46449: IFFALSE 46507
// begin SetTag ( j , 101 ) ;
46451: LD_VAR 0 3
46455: PPUSH
46456: LD_INT 101
46458: PPUSH
46459: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
46463: LD_ADDR_EXP 101
46467: PUSH
46468: LD_EXP 101
46472: PPUSH
46473: LD_VAR 0 2
46477: PUSH
46478: LD_EXP 101
46482: PUSH
46483: LD_VAR 0 2
46487: ARRAY
46488: PUSH
46489: LD_INT 1
46491: PLUS
46492: PUSH
46493: EMPTY
46494: LIST
46495: LIST
46496: PPUSH
46497: LD_VAR 0 3
46501: PPUSH
46502: CALL 72472 0 3
46506: ST_TO_ADDR
// end ; wait ( 1 ) ;
46507: LD_INT 1
46509: PPUSH
46510: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
46514: LD_ADDR_VAR 0 7
46518: PUSH
46519: LD_EXP 100
46523: PUSH
46524: LD_VAR 0 2
46528: ARRAY
46529: ST_TO_ADDR
// if mc_scan [ i ] then
46530: LD_EXP 122
46534: PUSH
46535: LD_VAR 0 2
46539: ARRAY
46540: IFFALSE 46602
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
46542: LD_ADDR_VAR 0 7
46546: PUSH
46547: LD_EXP 100
46551: PUSH
46552: LD_VAR 0 2
46556: ARRAY
46557: PPUSH
46558: LD_INT 3
46560: PUSH
46561: LD_INT 30
46563: PUSH
46564: LD_INT 32
46566: PUSH
46567: EMPTY
46568: LIST
46569: LIST
46570: PUSH
46571: LD_INT 30
46573: PUSH
46574: LD_INT 33
46576: PUSH
46577: EMPTY
46578: LIST
46579: LIST
46580: PUSH
46581: LD_INT 30
46583: PUSH
46584: LD_INT 31
46586: PUSH
46587: EMPTY
46588: LIST
46589: LIST
46590: PUSH
46591: EMPTY
46592: LIST
46593: LIST
46594: LIST
46595: LIST
46596: PPUSH
46597: CALL_OW 72
46601: ST_TO_ADDR
// if not to_repair_tmp then
46602: LD_VAR 0 7
46606: NOT
46607: IFFALSE 46611
// continue ;
46609: GO 46409
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
46611: LD_ADDR_VAR 0 8
46615: PUSH
46616: LD_VAR 0 7
46620: PPUSH
46621: LD_VAR 0 3
46625: PPUSH
46626: CALL_OW 74
46630: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
46631: LD_VAR 0 8
46635: PPUSH
46636: LD_INT 16
46638: PPUSH
46639: CALL 75069 0 2
46643: PUSH
46644: LD_INT 4
46646: ARRAY
46647: PUSH
46648: LD_INT 14
46650: LESS
46651: IFFALSE 46667
// ComRepairBuilding ( j , to_repair ) ;
46653: LD_VAR 0 3
46657: PPUSH
46658: LD_VAR 0 8
46662: PPUSH
46663: CALL_OW 130
// end ;
46667: GO 46409
46669: POP
46670: POP
// end ;
46671: GO 45779
46673: POP
46674: POP
// end ;
46675: LD_VAR 0 1
46679: RET
// export function MC_Heal ; var i , j , tmp ; begin
46680: LD_INT 0
46682: PPUSH
46683: PPUSH
46684: PPUSH
46685: PPUSH
// if not mc_bases then
46686: LD_EXP 99
46690: NOT
46691: IFFALSE 46695
// exit ;
46693: GO 47097
// for i = 1 to mc_bases do
46695: LD_ADDR_VAR 0 2
46699: PUSH
46700: DOUBLE
46701: LD_INT 1
46703: DEC
46704: ST_TO_ADDR
46705: LD_EXP 99
46709: PUSH
46710: FOR_TO
46711: IFFALSE 47095
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
46713: LD_EXP 102
46717: PUSH
46718: LD_VAR 0 2
46722: ARRAY
46723: PUSH
46724: LD_INT 1
46726: ARRAY
46727: NOT
46728: PUSH
46729: LD_EXP 102
46733: PUSH
46734: LD_VAR 0 2
46738: ARRAY
46739: PUSH
46740: LD_INT 2
46742: ARRAY
46743: NOT
46744: AND
46745: IFFALSE 46783
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
46747: LD_ADDR_EXP 103
46751: PUSH
46752: LD_EXP 103
46756: PPUSH
46757: LD_VAR 0 2
46761: PPUSH
46762: EMPTY
46763: PPUSH
46764: CALL_OW 1
46768: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
46769: LD_VAR 0 2
46773: PPUSH
46774: LD_INT 102
46776: PPUSH
46777: CALL 40832 0 2
// continue ;
46781: GO 46710
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
46783: LD_ADDR_VAR 0 4
46787: PUSH
46788: LD_EXP 99
46792: PUSH
46793: LD_VAR 0 2
46797: ARRAY
46798: PPUSH
46799: LD_INT 25
46801: PUSH
46802: LD_INT 4
46804: PUSH
46805: EMPTY
46806: LIST
46807: LIST
46808: PPUSH
46809: CALL_OW 72
46813: ST_TO_ADDR
// if not tmp then
46814: LD_VAR 0 4
46818: NOT
46819: IFFALSE 46823
// continue ;
46821: GO 46710
// if mc_taming [ i ] then
46823: LD_EXP 130
46827: PUSH
46828: LD_VAR 0 2
46832: ARRAY
46833: IFFALSE 46857
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
46835: LD_ADDR_EXP 130
46839: PUSH
46840: LD_EXP 130
46844: PPUSH
46845: LD_VAR 0 2
46849: PPUSH
46850: EMPTY
46851: PPUSH
46852: CALL_OW 1
46856: ST_TO_ADDR
// for j in tmp do
46857: LD_ADDR_VAR 0 3
46861: PUSH
46862: LD_VAR 0 4
46866: PUSH
46867: FOR_IN
46868: IFFALSE 47091
// begin if IsInUnit ( j ) then
46870: LD_VAR 0 3
46874: PPUSH
46875: CALL_OW 310
46879: IFFALSE 46890
// ComExitBuilding ( j ) ;
46881: LD_VAR 0 3
46885: PPUSH
46886: CALL_OW 122
// if not j in mc_healers [ i ] then
46890: LD_VAR 0 3
46894: PUSH
46895: LD_EXP 103
46899: PUSH
46900: LD_VAR 0 2
46904: ARRAY
46905: IN
46906: NOT
46907: IFFALSE 46953
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
46909: LD_ADDR_EXP 103
46913: PUSH
46914: LD_EXP 103
46918: PPUSH
46919: LD_VAR 0 2
46923: PUSH
46924: LD_EXP 103
46928: PUSH
46929: LD_VAR 0 2
46933: ARRAY
46934: PUSH
46935: LD_INT 1
46937: PLUS
46938: PUSH
46939: EMPTY
46940: LIST
46941: LIST
46942: PPUSH
46943: LD_VAR 0 3
46947: PPUSH
46948: CALL 72472 0 3
46952: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
46953: LD_VAR 0 3
46957: PPUSH
46958: CALL_OW 110
46962: PUSH
46963: LD_INT 102
46965: NONEQUAL
46966: IFFALSE 46980
// SetTag ( j , 102 ) ;
46968: LD_VAR 0 3
46972: PPUSH
46973: LD_INT 102
46975: PPUSH
46976: CALL_OW 109
// Wait ( 3 ) ;
46980: LD_INT 3
46982: PPUSH
46983: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
46987: LD_EXP 102
46991: PUSH
46992: LD_VAR 0 2
46996: ARRAY
46997: PUSH
46998: LD_INT 1
47000: ARRAY
47001: IFFALSE 47033
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
47003: LD_VAR 0 3
47007: PPUSH
47008: LD_EXP 102
47012: PUSH
47013: LD_VAR 0 2
47017: ARRAY
47018: PUSH
47019: LD_INT 1
47021: ARRAY
47022: PUSH
47023: LD_INT 1
47025: ARRAY
47026: PPUSH
47027: CALL_OW 128
47031: GO 47089
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
47033: LD_VAR 0 3
47037: PPUSH
47038: CALL_OW 314
47042: NOT
47043: PUSH
47044: LD_EXP 102
47048: PUSH
47049: LD_VAR 0 2
47053: ARRAY
47054: PUSH
47055: LD_INT 2
47057: ARRAY
47058: AND
47059: IFFALSE 47089
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
47061: LD_VAR 0 3
47065: PPUSH
47066: LD_EXP 102
47070: PUSH
47071: LD_VAR 0 2
47075: ARRAY
47076: PUSH
47077: LD_INT 2
47079: ARRAY
47080: PUSH
47081: LD_INT 1
47083: ARRAY
47084: PPUSH
47085: CALL_OW 128
// end ;
47089: GO 46867
47091: POP
47092: POP
// end ;
47093: GO 46710
47095: POP
47096: POP
// end ;
47097: LD_VAR 0 1
47101: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
47102: LD_INT 0
47104: PPUSH
47105: PPUSH
47106: PPUSH
47107: PPUSH
47108: PPUSH
47109: PPUSH
// if not mc_bases then
47110: LD_EXP 99
47114: NOT
47115: IFFALSE 47119
// exit ;
47117: GO 48282
// for i = 1 to mc_bases do
47119: LD_ADDR_VAR 0 2
47123: PUSH
47124: DOUBLE
47125: LD_INT 1
47127: DEC
47128: ST_TO_ADDR
47129: LD_EXP 99
47133: PUSH
47134: FOR_TO
47135: IFFALSE 48280
// begin if mc_scan [ i ] then
47137: LD_EXP 122
47141: PUSH
47142: LD_VAR 0 2
47146: ARRAY
47147: IFFALSE 47151
// continue ;
47149: GO 47134
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
47151: LD_EXP 104
47155: PUSH
47156: LD_VAR 0 2
47160: ARRAY
47161: NOT
47162: PUSH
47163: LD_EXP 106
47167: PUSH
47168: LD_VAR 0 2
47172: ARRAY
47173: NOT
47174: AND
47175: PUSH
47176: LD_EXP 105
47180: PUSH
47181: LD_VAR 0 2
47185: ARRAY
47186: AND
47187: IFFALSE 47225
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
47189: LD_ADDR_EXP 105
47193: PUSH
47194: LD_EXP 105
47198: PPUSH
47199: LD_VAR 0 2
47203: PPUSH
47204: EMPTY
47205: PPUSH
47206: CALL_OW 1
47210: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
47211: LD_VAR 0 2
47215: PPUSH
47216: LD_INT 103
47218: PPUSH
47219: CALL 40832 0 2
// continue ;
47223: GO 47134
// end ; if mc_construct_list [ i ] then
47225: LD_EXP 106
47229: PUSH
47230: LD_VAR 0 2
47234: ARRAY
47235: IFFALSE 47455
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
47237: LD_ADDR_VAR 0 5
47241: PUSH
47242: LD_EXP 99
47246: PUSH
47247: LD_VAR 0 2
47251: ARRAY
47252: PPUSH
47253: LD_INT 25
47255: PUSH
47256: LD_INT 2
47258: PUSH
47259: EMPTY
47260: LIST
47261: LIST
47262: PPUSH
47263: CALL_OW 72
47267: PUSH
47268: LD_EXP 101
47272: PUSH
47273: LD_VAR 0 2
47277: ARRAY
47278: DIFF
47279: ST_TO_ADDR
// if not tmp then
47280: LD_VAR 0 5
47284: NOT
47285: IFFALSE 47289
// continue ;
47287: GO 47134
// for j in tmp do
47289: LD_ADDR_VAR 0 3
47293: PUSH
47294: LD_VAR 0 5
47298: PUSH
47299: FOR_IN
47300: IFFALSE 47451
// begin if not mc_builders [ i ] then
47302: LD_EXP 105
47306: PUSH
47307: LD_VAR 0 2
47311: ARRAY
47312: NOT
47313: IFFALSE 47371
// begin SetTag ( j , 103 ) ;
47315: LD_VAR 0 3
47319: PPUSH
47320: LD_INT 103
47322: PPUSH
47323: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
47327: LD_ADDR_EXP 105
47331: PUSH
47332: LD_EXP 105
47336: PPUSH
47337: LD_VAR 0 2
47341: PUSH
47342: LD_EXP 105
47346: PUSH
47347: LD_VAR 0 2
47351: ARRAY
47352: PUSH
47353: LD_INT 1
47355: PLUS
47356: PUSH
47357: EMPTY
47358: LIST
47359: LIST
47360: PPUSH
47361: LD_VAR 0 3
47365: PPUSH
47366: CALL 72472 0 3
47370: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
47371: LD_VAR 0 3
47375: PPUSH
47376: CALL_OW 310
47380: IFFALSE 47391
// ComExitBuilding ( j ) ;
47382: LD_VAR 0 3
47386: PPUSH
47387: CALL_OW 122
// wait ( 3 ) ;
47391: LD_INT 3
47393: PPUSH
47394: CALL_OW 67
// if not mc_construct_list [ i ] then
47398: LD_EXP 106
47402: PUSH
47403: LD_VAR 0 2
47407: ARRAY
47408: NOT
47409: IFFALSE 47413
// break ;
47411: GO 47451
// if not HasTask ( j ) then
47413: LD_VAR 0 3
47417: PPUSH
47418: CALL_OW 314
47422: NOT
47423: IFFALSE 47449
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
47425: LD_VAR 0 3
47429: PPUSH
47430: LD_EXP 106
47434: PUSH
47435: LD_VAR 0 2
47439: ARRAY
47440: PUSH
47441: LD_INT 1
47443: ARRAY
47444: PPUSH
47445: CALL 75333 0 2
// end ;
47449: GO 47299
47451: POP
47452: POP
// end else
47453: GO 48278
// if mc_build_list [ i ] then
47455: LD_EXP 104
47459: PUSH
47460: LD_VAR 0 2
47464: ARRAY
47465: IFFALSE 48278
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
47467: LD_EXP 104
47471: PUSH
47472: LD_VAR 0 2
47476: ARRAY
47477: PUSH
47478: LD_INT 1
47480: ARRAY
47481: PUSH
47482: LD_INT 1
47484: ARRAY
47485: PPUSH
47486: CALL 75157 0 1
47490: PUSH
47491: LD_EXP 99
47495: PUSH
47496: LD_VAR 0 2
47500: ARRAY
47501: PPUSH
47502: LD_INT 2
47504: PUSH
47505: LD_INT 30
47507: PUSH
47508: LD_INT 2
47510: PUSH
47511: EMPTY
47512: LIST
47513: LIST
47514: PUSH
47515: LD_INT 30
47517: PUSH
47518: LD_INT 3
47520: PUSH
47521: EMPTY
47522: LIST
47523: LIST
47524: PUSH
47525: EMPTY
47526: LIST
47527: LIST
47528: LIST
47529: PPUSH
47530: CALL_OW 72
47534: NOT
47535: AND
47536: IFFALSE 47641
// begin for j = 1 to mc_build_list [ i ] do
47538: LD_ADDR_VAR 0 3
47542: PUSH
47543: DOUBLE
47544: LD_INT 1
47546: DEC
47547: ST_TO_ADDR
47548: LD_EXP 104
47552: PUSH
47553: LD_VAR 0 2
47557: ARRAY
47558: PUSH
47559: FOR_TO
47560: IFFALSE 47639
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
47562: LD_EXP 104
47566: PUSH
47567: LD_VAR 0 2
47571: ARRAY
47572: PUSH
47573: LD_VAR 0 3
47577: ARRAY
47578: PUSH
47579: LD_INT 1
47581: ARRAY
47582: PUSH
47583: LD_INT 2
47585: EQUAL
47586: IFFALSE 47637
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
47588: LD_ADDR_EXP 104
47592: PUSH
47593: LD_EXP 104
47597: PPUSH
47598: LD_VAR 0 2
47602: PPUSH
47603: LD_EXP 104
47607: PUSH
47608: LD_VAR 0 2
47612: ARRAY
47613: PPUSH
47614: LD_VAR 0 3
47618: PPUSH
47619: LD_INT 1
47621: PPUSH
47622: LD_INT 0
47624: PPUSH
47625: CALL 71890 0 4
47629: PPUSH
47630: CALL_OW 1
47634: ST_TO_ADDR
// break ;
47635: GO 47639
// end ;
47637: GO 47559
47639: POP
47640: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47641: LD_ADDR_VAR 0 6
47645: PUSH
47646: LD_EXP 99
47650: PUSH
47651: LD_VAR 0 2
47655: ARRAY
47656: PPUSH
47657: LD_INT 2
47659: PUSH
47660: LD_INT 30
47662: PUSH
47663: LD_INT 0
47665: PUSH
47666: EMPTY
47667: LIST
47668: LIST
47669: PUSH
47670: LD_INT 30
47672: PUSH
47673: LD_INT 1
47675: PUSH
47676: EMPTY
47677: LIST
47678: LIST
47679: PUSH
47680: EMPTY
47681: LIST
47682: LIST
47683: LIST
47684: PPUSH
47685: CALL_OW 72
47689: ST_TO_ADDR
// for k := 1 to depot do
47690: LD_ADDR_VAR 0 4
47694: PUSH
47695: DOUBLE
47696: LD_INT 1
47698: DEC
47699: ST_TO_ADDR
47700: LD_VAR 0 6
47704: PUSH
47705: FOR_TO
47706: IFFALSE 48276
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
47708: LD_EXP 104
47712: PUSH
47713: LD_VAR 0 2
47717: ARRAY
47718: PUSH
47719: LD_INT 1
47721: ARRAY
47722: PUSH
47723: LD_INT 1
47725: ARRAY
47726: PUSH
47727: LD_INT 0
47729: EQUAL
47730: PUSH
47731: LD_VAR 0 6
47735: PUSH
47736: LD_VAR 0 4
47740: ARRAY
47741: PPUSH
47742: LD_EXP 104
47746: PUSH
47747: LD_VAR 0 2
47751: ARRAY
47752: PUSH
47753: LD_INT 1
47755: ARRAY
47756: PUSH
47757: LD_INT 1
47759: ARRAY
47760: PPUSH
47761: LD_EXP 104
47765: PUSH
47766: LD_VAR 0 2
47770: ARRAY
47771: PUSH
47772: LD_INT 1
47774: ARRAY
47775: PUSH
47776: LD_INT 2
47778: ARRAY
47779: PPUSH
47780: LD_EXP 104
47784: PUSH
47785: LD_VAR 0 2
47789: ARRAY
47790: PUSH
47791: LD_INT 1
47793: ARRAY
47794: PUSH
47795: LD_INT 3
47797: ARRAY
47798: PPUSH
47799: LD_EXP 104
47803: PUSH
47804: LD_VAR 0 2
47808: ARRAY
47809: PUSH
47810: LD_INT 1
47812: ARRAY
47813: PUSH
47814: LD_INT 4
47816: ARRAY
47817: PPUSH
47818: CALL 80569 0 5
47822: OR
47823: IFFALSE 48104
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
47825: LD_ADDR_VAR 0 5
47829: PUSH
47830: LD_EXP 99
47834: PUSH
47835: LD_VAR 0 2
47839: ARRAY
47840: PPUSH
47841: LD_INT 25
47843: PUSH
47844: LD_INT 2
47846: PUSH
47847: EMPTY
47848: LIST
47849: LIST
47850: PPUSH
47851: CALL_OW 72
47855: PUSH
47856: LD_EXP 101
47860: PUSH
47861: LD_VAR 0 2
47865: ARRAY
47866: DIFF
47867: ST_TO_ADDR
// if not tmp then
47868: LD_VAR 0 5
47872: NOT
47873: IFFALSE 47877
// continue ;
47875: GO 47705
// for j in tmp do
47877: LD_ADDR_VAR 0 3
47881: PUSH
47882: LD_VAR 0 5
47886: PUSH
47887: FOR_IN
47888: IFFALSE 48100
// begin if not mc_builders [ i ] then
47890: LD_EXP 105
47894: PUSH
47895: LD_VAR 0 2
47899: ARRAY
47900: NOT
47901: IFFALSE 47959
// begin SetTag ( j , 103 ) ;
47903: LD_VAR 0 3
47907: PPUSH
47908: LD_INT 103
47910: PPUSH
47911: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
47915: LD_ADDR_EXP 105
47919: PUSH
47920: LD_EXP 105
47924: PPUSH
47925: LD_VAR 0 2
47929: PUSH
47930: LD_EXP 105
47934: PUSH
47935: LD_VAR 0 2
47939: ARRAY
47940: PUSH
47941: LD_INT 1
47943: PLUS
47944: PUSH
47945: EMPTY
47946: LIST
47947: LIST
47948: PPUSH
47949: LD_VAR 0 3
47953: PPUSH
47954: CALL 72472 0 3
47958: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
47959: LD_VAR 0 3
47963: PPUSH
47964: CALL_OW 310
47968: IFFALSE 47979
// ComExitBuilding ( j ) ;
47970: LD_VAR 0 3
47974: PPUSH
47975: CALL_OW 122
// wait ( 3 ) ;
47979: LD_INT 3
47981: PPUSH
47982: CALL_OW 67
// if not mc_build_list [ i ] then
47986: LD_EXP 104
47990: PUSH
47991: LD_VAR 0 2
47995: ARRAY
47996: NOT
47997: IFFALSE 48001
// break ;
47999: GO 48100
// if not HasTask ( j ) then
48001: LD_VAR 0 3
48005: PPUSH
48006: CALL_OW 314
48010: NOT
48011: IFFALSE 48098
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
48013: LD_VAR 0 3
48017: PPUSH
48018: LD_EXP 104
48022: PUSH
48023: LD_VAR 0 2
48027: ARRAY
48028: PUSH
48029: LD_INT 1
48031: ARRAY
48032: PUSH
48033: LD_INT 1
48035: ARRAY
48036: PPUSH
48037: LD_EXP 104
48041: PUSH
48042: LD_VAR 0 2
48046: ARRAY
48047: PUSH
48048: LD_INT 1
48050: ARRAY
48051: PUSH
48052: LD_INT 2
48054: ARRAY
48055: PPUSH
48056: LD_EXP 104
48060: PUSH
48061: LD_VAR 0 2
48065: ARRAY
48066: PUSH
48067: LD_INT 1
48069: ARRAY
48070: PUSH
48071: LD_INT 3
48073: ARRAY
48074: PPUSH
48075: LD_EXP 104
48079: PUSH
48080: LD_VAR 0 2
48084: ARRAY
48085: PUSH
48086: LD_INT 1
48088: ARRAY
48089: PUSH
48090: LD_INT 4
48092: ARRAY
48093: PPUSH
48094: CALL_OW 145
// end ;
48098: GO 47887
48100: POP
48101: POP
// end else
48102: GO 48274
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
48104: LD_EXP 99
48108: PUSH
48109: LD_VAR 0 2
48113: ARRAY
48114: PPUSH
48115: LD_EXP 104
48119: PUSH
48120: LD_VAR 0 2
48124: ARRAY
48125: PUSH
48126: LD_INT 1
48128: ARRAY
48129: PUSH
48130: LD_INT 1
48132: ARRAY
48133: PPUSH
48134: LD_EXP 104
48138: PUSH
48139: LD_VAR 0 2
48143: ARRAY
48144: PUSH
48145: LD_INT 1
48147: ARRAY
48148: PUSH
48149: LD_INT 2
48151: ARRAY
48152: PPUSH
48153: LD_EXP 104
48157: PUSH
48158: LD_VAR 0 2
48162: ARRAY
48163: PUSH
48164: LD_INT 1
48166: ARRAY
48167: PUSH
48168: LD_INT 3
48170: ARRAY
48171: PPUSH
48172: LD_EXP 104
48176: PUSH
48177: LD_VAR 0 2
48181: ARRAY
48182: PUSH
48183: LD_INT 1
48185: ARRAY
48186: PUSH
48187: LD_INT 4
48189: ARRAY
48190: PPUSH
48191: LD_EXP 99
48195: PUSH
48196: LD_VAR 0 2
48200: ARRAY
48201: PPUSH
48202: LD_INT 21
48204: PUSH
48205: LD_INT 3
48207: PUSH
48208: EMPTY
48209: LIST
48210: LIST
48211: PPUSH
48212: CALL_OW 72
48216: PPUSH
48217: EMPTY
48218: PPUSH
48219: CALL 79323 0 7
48223: NOT
48224: IFFALSE 48274
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
48226: LD_ADDR_EXP 104
48230: PUSH
48231: LD_EXP 104
48235: PPUSH
48236: LD_VAR 0 2
48240: PPUSH
48241: LD_EXP 104
48245: PUSH
48246: LD_VAR 0 2
48250: ARRAY
48251: PPUSH
48252: LD_INT 1
48254: PPUSH
48255: LD_INT 1
48257: NEG
48258: PPUSH
48259: LD_INT 0
48261: PPUSH
48262: CALL 71890 0 4
48266: PPUSH
48267: CALL_OW 1
48271: ST_TO_ADDR
// continue ;
48272: GO 47705
// end ; end ;
48274: GO 47705
48276: POP
48277: POP
// end ; end ;
48278: GO 47134
48280: POP
48281: POP
// end ;
48282: LD_VAR 0 1
48286: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
48287: LD_INT 0
48289: PPUSH
48290: PPUSH
48291: PPUSH
48292: PPUSH
48293: PPUSH
48294: PPUSH
// if not mc_bases then
48295: LD_EXP 99
48299: NOT
48300: IFFALSE 48304
// exit ;
48302: GO 48731
// for i = 1 to mc_bases do
48304: LD_ADDR_VAR 0 2
48308: PUSH
48309: DOUBLE
48310: LD_INT 1
48312: DEC
48313: ST_TO_ADDR
48314: LD_EXP 99
48318: PUSH
48319: FOR_TO
48320: IFFALSE 48729
// begin tmp := mc_build_upgrade [ i ] ;
48322: LD_ADDR_VAR 0 4
48326: PUSH
48327: LD_EXP 131
48331: PUSH
48332: LD_VAR 0 2
48336: ARRAY
48337: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
48338: LD_ADDR_VAR 0 6
48342: PUSH
48343: LD_EXP 132
48347: PUSH
48348: LD_VAR 0 2
48352: ARRAY
48353: PPUSH
48354: LD_INT 2
48356: PUSH
48357: LD_INT 30
48359: PUSH
48360: LD_INT 6
48362: PUSH
48363: EMPTY
48364: LIST
48365: LIST
48366: PUSH
48367: LD_INT 30
48369: PUSH
48370: LD_INT 7
48372: PUSH
48373: EMPTY
48374: LIST
48375: LIST
48376: PUSH
48377: EMPTY
48378: LIST
48379: LIST
48380: LIST
48381: PPUSH
48382: CALL_OW 72
48386: ST_TO_ADDR
// if not tmp and not lab then
48387: LD_VAR 0 4
48391: NOT
48392: PUSH
48393: LD_VAR 0 6
48397: NOT
48398: AND
48399: IFFALSE 48403
// continue ;
48401: GO 48319
// if tmp then
48403: LD_VAR 0 4
48407: IFFALSE 48527
// for j in tmp do
48409: LD_ADDR_VAR 0 3
48413: PUSH
48414: LD_VAR 0 4
48418: PUSH
48419: FOR_IN
48420: IFFALSE 48525
// begin if UpgradeCost ( j ) then
48422: LD_VAR 0 3
48426: PPUSH
48427: CALL 78983 0 1
48431: IFFALSE 48523
// begin ComUpgrade ( j ) ;
48433: LD_VAR 0 3
48437: PPUSH
48438: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
48442: LD_ADDR_EXP 131
48446: PUSH
48447: LD_EXP 131
48451: PPUSH
48452: LD_VAR 0 2
48456: PPUSH
48457: LD_EXP 131
48461: PUSH
48462: LD_VAR 0 2
48466: ARRAY
48467: PUSH
48468: LD_VAR 0 3
48472: DIFF
48473: PPUSH
48474: CALL_OW 1
48478: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
48479: LD_ADDR_EXP 106
48483: PUSH
48484: LD_EXP 106
48488: PPUSH
48489: LD_VAR 0 2
48493: PUSH
48494: LD_EXP 106
48498: PUSH
48499: LD_VAR 0 2
48503: ARRAY
48504: PUSH
48505: LD_INT 1
48507: PLUS
48508: PUSH
48509: EMPTY
48510: LIST
48511: LIST
48512: PPUSH
48513: LD_VAR 0 3
48517: PPUSH
48518: CALL 72472 0 3
48522: ST_TO_ADDR
// end ; end ;
48523: GO 48419
48525: POP
48526: POP
// if not lab or not mc_lab_upgrade [ i ] then
48527: LD_VAR 0 6
48531: NOT
48532: PUSH
48533: LD_EXP 133
48537: PUSH
48538: LD_VAR 0 2
48542: ARRAY
48543: NOT
48544: OR
48545: IFFALSE 48549
// continue ;
48547: GO 48319
// for j in lab do
48549: LD_ADDR_VAR 0 3
48553: PUSH
48554: LD_VAR 0 6
48558: PUSH
48559: FOR_IN
48560: IFFALSE 48725
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
48562: LD_VAR 0 3
48566: PPUSH
48567: CALL_OW 266
48571: PUSH
48572: LD_INT 6
48574: PUSH
48575: LD_INT 7
48577: PUSH
48578: EMPTY
48579: LIST
48580: LIST
48581: IN
48582: PUSH
48583: LD_VAR 0 3
48587: PPUSH
48588: CALL_OW 461
48592: PUSH
48593: LD_INT 1
48595: NONEQUAL
48596: AND
48597: IFFALSE 48723
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
48599: LD_VAR 0 3
48603: PPUSH
48604: LD_EXP 133
48608: PUSH
48609: LD_VAR 0 2
48613: ARRAY
48614: PUSH
48615: LD_INT 1
48617: ARRAY
48618: PPUSH
48619: CALL 79188 0 2
48623: IFFALSE 48723
// begin ComCancel ( j ) ;
48625: LD_VAR 0 3
48629: PPUSH
48630: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
48634: LD_VAR 0 3
48638: PPUSH
48639: LD_EXP 133
48643: PUSH
48644: LD_VAR 0 2
48648: ARRAY
48649: PUSH
48650: LD_INT 1
48652: ARRAY
48653: PPUSH
48654: CALL_OW 207
// if not j in mc_construct_list [ i ] then
48658: LD_VAR 0 3
48662: PUSH
48663: LD_EXP 106
48667: PUSH
48668: LD_VAR 0 2
48672: ARRAY
48673: IN
48674: NOT
48675: IFFALSE 48721
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
48677: LD_ADDR_EXP 106
48681: PUSH
48682: LD_EXP 106
48686: PPUSH
48687: LD_VAR 0 2
48691: PUSH
48692: LD_EXP 106
48696: PUSH
48697: LD_VAR 0 2
48701: ARRAY
48702: PUSH
48703: LD_INT 1
48705: PLUS
48706: PUSH
48707: EMPTY
48708: LIST
48709: LIST
48710: PPUSH
48711: LD_VAR 0 3
48715: PPUSH
48716: CALL 72472 0 3
48720: ST_TO_ADDR
// break ;
48721: GO 48725
// end ; end ; end ;
48723: GO 48559
48725: POP
48726: POP
// end ;
48727: GO 48319
48729: POP
48730: POP
// end ;
48731: LD_VAR 0 1
48735: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
48736: LD_INT 0
48738: PPUSH
48739: PPUSH
48740: PPUSH
48741: PPUSH
48742: PPUSH
48743: PPUSH
48744: PPUSH
48745: PPUSH
48746: PPUSH
// if not mc_bases then
48747: LD_EXP 99
48751: NOT
48752: IFFALSE 48756
// exit ;
48754: GO 49161
// for i = 1 to mc_bases do
48756: LD_ADDR_VAR 0 2
48760: PUSH
48761: DOUBLE
48762: LD_INT 1
48764: DEC
48765: ST_TO_ADDR
48766: LD_EXP 99
48770: PUSH
48771: FOR_TO
48772: IFFALSE 49159
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
48774: LD_EXP 107
48778: PUSH
48779: LD_VAR 0 2
48783: ARRAY
48784: NOT
48785: PUSH
48786: LD_EXP 99
48790: PUSH
48791: LD_VAR 0 2
48795: ARRAY
48796: PPUSH
48797: LD_INT 30
48799: PUSH
48800: LD_INT 3
48802: PUSH
48803: EMPTY
48804: LIST
48805: LIST
48806: PPUSH
48807: CALL_OW 72
48811: NOT
48812: OR
48813: IFFALSE 48817
// continue ;
48815: GO 48771
// busy := false ;
48817: LD_ADDR_VAR 0 8
48821: PUSH
48822: LD_INT 0
48824: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
48825: LD_ADDR_VAR 0 4
48829: PUSH
48830: LD_EXP 99
48834: PUSH
48835: LD_VAR 0 2
48839: ARRAY
48840: PPUSH
48841: LD_INT 30
48843: PUSH
48844: LD_INT 3
48846: PUSH
48847: EMPTY
48848: LIST
48849: LIST
48850: PPUSH
48851: CALL_OW 72
48855: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
48856: LD_ADDR_VAR 0 6
48860: PUSH
48861: LD_EXP 107
48865: PUSH
48866: LD_VAR 0 2
48870: ARRAY
48871: PPUSH
48872: LD_INT 2
48874: PUSH
48875: LD_INT 30
48877: PUSH
48878: LD_INT 32
48880: PUSH
48881: EMPTY
48882: LIST
48883: LIST
48884: PUSH
48885: LD_INT 30
48887: PUSH
48888: LD_INT 33
48890: PUSH
48891: EMPTY
48892: LIST
48893: LIST
48894: PUSH
48895: EMPTY
48896: LIST
48897: LIST
48898: LIST
48899: PPUSH
48900: CALL_OW 72
48904: ST_TO_ADDR
// if not t then
48905: LD_VAR 0 6
48909: NOT
48910: IFFALSE 48914
// continue ;
48912: GO 48771
// for j in tmp do
48914: LD_ADDR_VAR 0 3
48918: PUSH
48919: LD_VAR 0 4
48923: PUSH
48924: FOR_IN
48925: IFFALSE 48955
// if not BuildingStatus ( j ) = bs_idle then
48927: LD_VAR 0 3
48931: PPUSH
48932: CALL_OW 461
48936: PUSH
48937: LD_INT 2
48939: EQUAL
48940: NOT
48941: IFFALSE 48953
// begin busy := true ;
48943: LD_ADDR_VAR 0 8
48947: PUSH
48948: LD_INT 1
48950: ST_TO_ADDR
// break ;
48951: GO 48955
// end ;
48953: GO 48924
48955: POP
48956: POP
// if busy then
48957: LD_VAR 0 8
48961: IFFALSE 48965
// continue ;
48963: GO 48771
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
48965: LD_ADDR_VAR 0 7
48969: PUSH
48970: LD_VAR 0 6
48974: PPUSH
48975: LD_INT 35
48977: PUSH
48978: LD_INT 0
48980: PUSH
48981: EMPTY
48982: LIST
48983: LIST
48984: PPUSH
48985: CALL_OW 72
48989: ST_TO_ADDR
// if tw then
48990: LD_VAR 0 7
48994: IFFALSE 49071
// begin tw := tw [ 1 ] ;
48996: LD_ADDR_VAR 0 7
49000: PUSH
49001: LD_VAR 0 7
49005: PUSH
49006: LD_INT 1
49008: ARRAY
49009: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
49010: LD_ADDR_VAR 0 9
49014: PUSH
49015: LD_VAR 0 7
49019: PPUSH
49020: LD_EXP 124
49024: PUSH
49025: LD_VAR 0 2
49029: ARRAY
49030: PPUSH
49031: CALL 77480 0 2
49035: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
49036: LD_EXP 138
49040: PUSH
49041: LD_VAR 0 2
49045: ARRAY
49046: IFFALSE 49069
// if not weapon in mc_allowed_tower_weapons [ i ] then
49048: LD_VAR 0 9
49052: PUSH
49053: LD_EXP 138
49057: PUSH
49058: LD_VAR 0 2
49062: ARRAY
49063: IN
49064: NOT
49065: IFFALSE 49069
// continue ;
49067: GO 48771
// end else
49069: GO 49134
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
49071: LD_ADDR_VAR 0 5
49075: PUSH
49076: LD_EXP 107
49080: PUSH
49081: LD_VAR 0 2
49085: ARRAY
49086: PPUSH
49087: LD_VAR 0 4
49091: PPUSH
49092: CALL 104332 0 2
49096: ST_TO_ADDR
// if not tmp2 then
49097: LD_VAR 0 5
49101: NOT
49102: IFFALSE 49106
// continue ;
49104: GO 48771
// tw := tmp2 [ 1 ] ;
49106: LD_ADDR_VAR 0 7
49110: PUSH
49111: LD_VAR 0 5
49115: PUSH
49116: LD_INT 1
49118: ARRAY
49119: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
49120: LD_ADDR_VAR 0 9
49124: PUSH
49125: LD_VAR 0 5
49129: PUSH
49130: LD_INT 2
49132: ARRAY
49133: ST_TO_ADDR
// end ; if not weapon then
49134: LD_VAR 0 9
49138: NOT
49139: IFFALSE 49143
// continue ;
49141: GO 48771
// ComPlaceWeapon ( tw , weapon ) ;
49143: LD_VAR 0 7
49147: PPUSH
49148: LD_VAR 0 9
49152: PPUSH
49153: CALL_OW 148
// end ;
49157: GO 48771
49159: POP
49160: POP
// end ;
49161: LD_VAR 0 1
49165: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
49166: LD_INT 0
49168: PPUSH
49169: PPUSH
49170: PPUSH
49171: PPUSH
49172: PPUSH
49173: PPUSH
49174: PPUSH
// if not mc_bases then
49175: LD_EXP 99
49179: NOT
49180: IFFALSE 49184
// exit ;
49182: GO 49952
// for i = 1 to mc_bases do
49184: LD_ADDR_VAR 0 2
49188: PUSH
49189: DOUBLE
49190: LD_INT 1
49192: DEC
49193: ST_TO_ADDR
49194: LD_EXP 99
49198: PUSH
49199: FOR_TO
49200: IFFALSE 49950
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
49202: LD_EXP 112
49206: PUSH
49207: LD_VAR 0 2
49211: ARRAY
49212: NOT
49213: PUSH
49214: LD_EXP 112
49218: PUSH
49219: LD_VAR 0 2
49223: ARRAY
49224: PUSH
49225: LD_EXP 113
49229: PUSH
49230: LD_VAR 0 2
49234: ARRAY
49235: EQUAL
49236: OR
49237: PUSH
49238: LD_EXP 122
49242: PUSH
49243: LD_VAR 0 2
49247: ARRAY
49248: OR
49249: IFFALSE 49253
// continue ;
49251: GO 49199
// if mc_miners [ i ] then
49253: LD_EXP 113
49257: PUSH
49258: LD_VAR 0 2
49262: ARRAY
49263: IFFALSE 49637
// begin for j = mc_miners [ i ] downto 1 do
49265: LD_ADDR_VAR 0 3
49269: PUSH
49270: DOUBLE
49271: LD_EXP 113
49275: PUSH
49276: LD_VAR 0 2
49280: ARRAY
49281: INC
49282: ST_TO_ADDR
49283: LD_INT 1
49285: PUSH
49286: FOR_DOWNTO
49287: IFFALSE 49635
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
49289: LD_EXP 113
49293: PUSH
49294: LD_VAR 0 2
49298: ARRAY
49299: PUSH
49300: LD_VAR 0 3
49304: ARRAY
49305: PPUSH
49306: CALL_OW 301
49310: PUSH
49311: LD_EXP 113
49315: PUSH
49316: LD_VAR 0 2
49320: ARRAY
49321: PUSH
49322: LD_VAR 0 3
49326: ARRAY
49327: PPUSH
49328: CALL_OW 257
49332: PUSH
49333: LD_INT 1
49335: NONEQUAL
49336: OR
49337: IFFALSE 49400
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
49339: LD_ADDR_VAR 0 5
49343: PUSH
49344: LD_EXP 113
49348: PUSH
49349: LD_VAR 0 2
49353: ARRAY
49354: PUSH
49355: LD_EXP 113
49359: PUSH
49360: LD_VAR 0 2
49364: ARRAY
49365: PUSH
49366: LD_VAR 0 3
49370: ARRAY
49371: DIFF
49372: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
49373: LD_ADDR_EXP 113
49377: PUSH
49378: LD_EXP 113
49382: PPUSH
49383: LD_VAR 0 2
49387: PPUSH
49388: LD_VAR 0 5
49392: PPUSH
49393: CALL_OW 1
49397: ST_TO_ADDR
// continue ;
49398: GO 49286
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
49400: LD_EXP 113
49404: PUSH
49405: LD_VAR 0 2
49409: ARRAY
49410: PUSH
49411: LD_VAR 0 3
49415: ARRAY
49416: PPUSH
49417: CALL_OW 257
49421: PUSH
49422: LD_INT 1
49424: EQUAL
49425: PUSH
49426: LD_EXP 113
49430: PUSH
49431: LD_VAR 0 2
49435: ARRAY
49436: PUSH
49437: LD_VAR 0 3
49441: ARRAY
49442: PPUSH
49443: CALL_OW 459
49447: NOT
49448: AND
49449: PUSH
49450: LD_EXP 113
49454: PUSH
49455: LD_VAR 0 2
49459: ARRAY
49460: PUSH
49461: LD_VAR 0 3
49465: ARRAY
49466: PPUSH
49467: CALL_OW 314
49471: NOT
49472: AND
49473: IFFALSE 49633
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
49475: LD_EXP 113
49479: PUSH
49480: LD_VAR 0 2
49484: ARRAY
49485: PUSH
49486: LD_VAR 0 3
49490: ARRAY
49491: PPUSH
49492: CALL_OW 310
49496: IFFALSE 49519
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
49498: LD_EXP 113
49502: PUSH
49503: LD_VAR 0 2
49507: ARRAY
49508: PUSH
49509: LD_VAR 0 3
49513: ARRAY
49514: PPUSH
49515: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
49519: LD_EXP 113
49523: PUSH
49524: LD_VAR 0 2
49528: ARRAY
49529: PUSH
49530: LD_VAR 0 3
49534: ARRAY
49535: PPUSH
49536: CALL_OW 314
49540: NOT
49541: IFFALSE 49633
// begin r := rand ( 1 , mc_mines [ i ] ) ;
49543: LD_ADDR_VAR 0 7
49547: PUSH
49548: LD_INT 1
49550: PPUSH
49551: LD_EXP 112
49555: PUSH
49556: LD_VAR 0 2
49560: ARRAY
49561: PPUSH
49562: CALL_OW 12
49566: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
49567: LD_EXP 113
49571: PUSH
49572: LD_VAR 0 2
49576: ARRAY
49577: PUSH
49578: LD_VAR 0 3
49582: ARRAY
49583: PPUSH
49584: LD_EXP 112
49588: PUSH
49589: LD_VAR 0 2
49593: ARRAY
49594: PUSH
49595: LD_VAR 0 7
49599: ARRAY
49600: PUSH
49601: LD_INT 1
49603: ARRAY
49604: PPUSH
49605: LD_EXP 112
49609: PUSH
49610: LD_VAR 0 2
49614: ARRAY
49615: PUSH
49616: LD_VAR 0 7
49620: ARRAY
49621: PUSH
49622: LD_INT 2
49624: ARRAY
49625: PPUSH
49626: LD_INT 0
49628: PPUSH
49629: CALL_OW 193
// end ; end ; end ;
49633: GO 49286
49635: POP
49636: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
49637: LD_ADDR_VAR 0 5
49641: PUSH
49642: LD_EXP 99
49646: PUSH
49647: LD_VAR 0 2
49651: ARRAY
49652: PPUSH
49653: LD_INT 2
49655: PUSH
49656: LD_INT 30
49658: PUSH
49659: LD_INT 4
49661: PUSH
49662: EMPTY
49663: LIST
49664: LIST
49665: PUSH
49666: LD_INT 30
49668: PUSH
49669: LD_INT 5
49671: PUSH
49672: EMPTY
49673: LIST
49674: LIST
49675: PUSH
49676: LD_INT 30
49678: PUSH
49679: LD_INT 32
49681: PUSH
49682: EMPTY
49683: LIST
49684: LIST
49685: PUSH
49686: EMPTY
49687: LIST
49688: LIST
49689: LIST
49690: LIST
49691: PPUSH
49692: CALL_OW 72
49696: ST_TO_ADDR
// if not tmp then
49697: LD_VAR 0 5
49701: NOT
49702: IFFALSE 49706
// continue ;
49704: GO 49199
// list := [ ] ;
49706: LD_ADDR_VAR 0 6
49710: PUSH
49711: EMPTY
49712: ST_TO_ADDR
// for j in tmp do
49713: LD_ADDR_VAR 0 3
49717: PUSH
49718: LD_VAR 0 5
49722: PUSH
49723: FOR_IN
49724: IFFALSE 49793
// begin for k in UnitsInside ( j ) do
49726: LD_ADDR_VAR 0 4
49730: PUSH
49731: LD_VAR 0 3
49735: PPUSH
49736: CALL_OW 313
49740: PUSH
49741: FOR_IN
49742: IFFALSE 49789
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
49744: LD_VAR 0 4
49748: PPUSH
49749: CALL_OW 257
49753: PUSH
49754: LD_INT 1
49756: EQUAL
49757: PUSH
49758: LD_VAR 0 4
49762: PPUSH
49763: CALL_OW 459
49767: NOT
49768: AND
49769: IFFALSE 49787
// list := list ^ k ;
49771: LD_ADDR_VAR 0 6
49775: PUSH
49776: LD_VAR 0 6
49780: PUSH
49781: LD_VAR 0 4
49785: ADD
49786: ST_TO_ADDR
49787: GO 49741
49789: POP
49790: POP
// end ;
49791: GO 49723
49793: POP
49794: POP
// list := list diff mc_miners [ i ] ;
49795: LD_ADDR_VAR 0 6
49799: PUSH
49800: LD_VAR 0 6
49804: PUSH
49805: LD_EXP 113
49809: PUSH
49810: LD_VAR 0 2
49814: ARRAY
49815: DIFF
49816: ST_TO_ADDR
// if not list then
49817: LD_VAR 0 6
49821: NOT
49822: IFFALSE 49826
// continue ;
49824: GO 49199
// k := mc_mines [ i ] - mc_miners [ i ] ;
49826: LD_ADDR_VAR 0 4
49830: PUSH
49831: LD_EXP 112
49835: PUSH
49836: LD_VAR 0 2
49840: ARRAY
49841: PUSH
49842: LD_EXP 113
49846: PUSH
49847: LD_VAR 0 2
49851: ARRAY
49852: MINUS
49853: ST_TO_ADDR
// if k > list then
49854: LD_VAR 0 4
49858: PUSH
49859: LD_VAR 0 6
49863: GREATER
49864: IFFALSE 49876
// k := list ;
49866: LD_ADDR_VAR 0 4
49870: PUSH
49871: LD_VAR 0 6
49875: ST_TO_ADDR
// for j = 1 to k do
49876: LD_ADDR_VAR 0 3
49880: PUSH
49881: DOUBLE
49882: LD_INT 1
49884: DEC
49885: ST_TO_ADDR
49886: LD_VAR 0 4
49890: PUSH
49891: FOR_TO
49892: IFFALSE 49946
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
49894: LD_ADDR_EXP 113
49898: PUSH
49899: LD_EXP 113
49903: PPUSH
49904: LD_VAR 0 2
49908: PUSH
49909: LD_EXP 113
49913: PUSH
49914: LD_VAR 0 2
49918: ARRAY
49919: PUSH
49920: LD_INT 1
49922: PLUS
49923: PUSH
49924: EMPTY
49925: LIST
49926: LIST
49927: PPUSH
49928: LD_VAR 0 6
49932: PUSH
49933: LD_VAR 0 3
49937: ARRAY
49938: PPUSH
49939: CALL 72472 0 3
49943: ST_TO_ADDR
49944: GO 49891
49946: POP
49947: POP
// end ;
49948: GO 49199
49950: POP
49951: POP
// end ;
49952: LD_VAR 0 1
49956: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
49957: LD_INT 0
49959: PPUSH
49960: PPUSH
49961: PPUSH
49962: PPUSH
49963: PPUSH
49964: PPUSH
49965: PPUSH
49966: PPUSH
49967: PPUSH
49968: PPUSH
49969: PPUSH
// if not mc_bases then
49970: LD_EXP 99
49974: NOT
49975: IFFALSE 49979
// exit ;
49977: GO 51802
// for i = 1 to mc_bases do
49979: LD_ADDR_VAR 0 2
49983: PUSH
49984: DOUBLE
49985: LD_INT 1
49987: DEC
49988: ST_TO_ADDR
49989: LD_EXP 99
49993: PUSH
49994: FOR_TO
49995: IFFALSE 51800
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
49997: LD_EXP 99
50001: PUSH
50002: LD_VAR 0 2
50006: ARRAY
50007: NOT
50008: PUSH
50009: LD_EXP 106
50013: PUSH
50014: LD_VAR 0 2
50018: ARRAY
50019: OR
50020: IFFALSE 50024
// continue ;
50022: GO 49994
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
50024: LD_EXP 115
50028: PUSH
50029: LD_VAR 0 2
50033: ARRAY
50034: NOT
50035: PUSH
50036: LD_EXP 116
50040: PUSH
50041: LD_VAR 0 2
50045: ARRAY
50046: AND
50047: IFFALSE 50085
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
50049: LD_ADDR_EXP 116
50053: PUSH
50054: LD_EXP 116
50058: PPUSH
50059: LD_VAR 0 2
50063: PPUSH
50064: EMPTY
50065: PPUSH
50066: CALL_OW 1
50070: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
50071: LD_VAR 0 2
50075: PPUSH
50076: LD_INT 107
50078: PPUSH
50079: CALL 40832 0 2
// continue ;
50083: GO 49994
// end ; target := [ ] ;
50085: LD_ADDR_VAR 0 7
50089: PUSH
50090: EMPTY
50091: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
50092: LD_ADDR_VAR 0 6
50096: PUSH
50097: LD_EXP 99
50101: PUSH
50102: LD_VAR 0 2
50106: ARRAY
50107: PUSH
50108: LD_INT 1
50110: ARRAY
50111: PPUSH
50112: CALL_OW 255
50116: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50117: LD_ADDR_VAR 0 9
50121: PUSH
50122: LD_EXP 99
50126: PUSH
50127: LD_VAR 0 2
50131: ARRAY
50132: PPUSH
50133: LD_INT 2
50135: PUSH
50136: LD_INT 30
50138: PUSH
50139: LD_INT 0
50141: PUSH
50142: EMPTY
50143: LIST
50144: LIST
50145: PUSH
50146: LD_INT 30
50148: PUSH
50149: LD_INT 1
50151: PUSH
50152: EMPTY
50153: LIST
50154: LIST
50155: PUSH
50156: EMPTY
50157: LIST
50158: LIST
50159: LIST
50160: PPUSH
50161: CALL_OW 72
50165: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
50166: LD_ADDR_VAR 0 3
50170: PUSH
50171: DOUBLE
50172: LD_EXP 115
50176: PUSH
50177: LD_VAR 0 2
50181: ARRAY
50182: INC
50183: ST_TO_ADDR
50184: LD_INT 1
50186: PUSH
50187: FOR_DOWNTO
50188: IFFALSE 50433
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
50190: LD_EXP 115
50194: PUSH
50195: LD_VAR 0 2
50199: ARRAY
50200: PUSH
50201: LD_VAR 0 3
50205: ARRAY
50206: PUSH
50207: LD_INT 2
50209: ARRAY
50210: PPUSH
50211: LD_EXP 115
50215: PUSH
50216: LD_VAR 0 2
50220: ARRAY
50221: PUSH
50222: LD_VAR 0 3
50226: ARRAY
50227: PUSH
50228: LD_INT 3
50230: ARRAY
50231: PPUSH
50232: CALL_OW 488
50236: PUSH
50237: LD_EXP 115
50241: PUSH
50242: LD_VAR 0 2
50246: ARRAY
50247: PUSH
50248: LD_VAR 0 3
50252: ARRAY
50253: PUSH
50254: LD_INT 2
50256: ARRAY
50257: PPUSH
50258: LD_EXP 115
50262: PUSH
50263: LD_VAR 0 2
50267: ARRAY
50268: PUSH
50269: LD_VAR 0 3
50273: ARRAY
50274: PUSH
50275: LD_INT 3
50277: ARRAY
50278: PPUSH
50279: CALL_OW 284
50283: PUSH
50284: LD_INT 0
50286: EQUAL
50287: AND
50288: IFFALSE 50343
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
50290: LD_ADDR_VAR 0 5
50294: PUSH
50295: LD_EXP 115
50299: PUSH
50300: LD_VAR 0 2
50304: ARRAY
50305: PPUSH
50306: LD_VAR 0 3
50310: PPUSH
50311: CALL_OW 3
50315: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
50316: LD_ADDR_EXP 115
50320: PUSH
50321: LD_EXP 115
50325: PPUSH
50326: LD_VAR 0 2
50330: PPUSH
50331: LD_VAR 0 5
50335: PPUSH
50336: CALL_OW 1
50340: ST_TO_ADDR
// continue ;
50341: GO 50187
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
50343: LD_VAR 0 6
50347: PPUSH
50348: LD_EXP 115
50352: PUSH
50353: LD_VAR 0 2
50357: ARRAY
50358: PUSH
50359: LD_VAR 0 3
50363: ARRAY
50364: PUSH
50365: LD_INT 2
50367: ARRAY
50368: PPUSH
50369: LD_EXP 115
50373: PUSH
50374: LD_VAR 0 2
50378: ARRAY
50379: PUSH
50380: LD_VAR 0 3
50384: ARRAY
50385: PUSH
50386: LD_INT 3
50388: ARRAY
50389: PPUSH
50390: LD_INT 30
50392: PPUSH
50393: CALL 73368 0 4
50397: PUSH
50398: LD_INT 4
50400: ARRAY
50401: PUSH
50402: LD_INT 0
50404: EQUAL
50405: IFFALSE 50431
// begin target := mc_crates [ i ] [ j ] ;
50407: LD_ADDR_VAR 0 7
50411: PUSH
50412: LD_EXP 115
50416: PUSH
50417: LD_VAR 0 2
50421: ARRAY
50422: PUSH
50423: LD_VAR 0 3
50427: ARRAY
50428: ST_TO_ADDR
// break ;
50429: GO 50433
// end ; end ;
50431: GO 50187
50433: POP
50434: POP
// if not target then
50435: LD_VAR 0 7
50439: NOT
50440: IFFALSE 50444
// continue ;
50442: GO 49994
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
50444: LD_ADDR_VAR 0 8
50448: PUSH
50449: LD_EXP 118
50453: PUSH
50454: LD_VAR 0 2
50458: ARRAY
50459: PPUSH
50460: LD_INT 2
50462: PUSH
50463: LD_INT 3
50465: PUSH
50466: LD_INT 58
50468: PUSH
50469: EMPTY
50470: LIST
50471: PUSH
50472: EMPTY
50473: LIST
50474: LIST
50475: PUSH
50476: LD_INT 61
50478: PUSH
50479: EMPTY
50480: LIST
50481: PUSH
50482: LD_INT 33
50484: PUSH
50485: LD_INT 5
50487: PUSH
50488: EMPTY
50489: LIST
50490: LIST
50491: PUSH
50492: LD_INT 33
50494: PUSH
50495: LD_INT 3
50497: PUSH
50498: EMPTY
50499: LIST
50500: LIST
50501: PUSH
50502: EMPTY
50503: LIST
50504: LIST
50505: LIST
50506: LIST
50507: LIST
50508: PUSH
50509: LD_INT 2
50511: PUSH
50512: LD_INT 34
50514: PUSH
50515: LD_INT 32
50517: PUSH
50518: EMPTY
50519: LIST
50520: LIST
50521: PUSH
50522: LD_INT 34
50524: PUSH
50525: LD_INT 51
50527: PUSH
50528: EMPTY
50529: LIST
50530: LIST
50531: PUSH
50532: LD_INT 34
50534: PUSH
50535: LD_INT 12
50537: PUSH
50538: EMPTY
50539: LIST
50540: LIST
50541: PUSH
50542: EMPTY
50543: LIST
50544: LIST
50545: LIST
50546: LIST
50547: PUSH
50548: EMPTY
50549: LIST
50550: LIST
50551: PPUSH
50552: CALL_OW 72
50556: ST_TO_ADDR
// if not cargo then
50557: LD_VAR 0 8
50561: NOT
50562: IFFALSE 51268
// begin if mc_crates_collector [ i ] < 5 then
50564: LD_EXP 116
50568: PUSH
50569: LD_VAR 0 2
50573: ARRAY
50574: PUSH
50575: LD_INT 5
50577: LESS
50578: IFFALSE 50944
// begin if mc_ape [ i ] then
50580: LD_EXP 128
50584: PUSH
50585: LD_VAR 0 2
50589: ARRAY
50590: IFFALSE 50637
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
50592: LD_ADDR_VAR 0 5
50596: PUSH
50597: LD_EXP 128
50601: PUSH
50602: LD_VAR 0 2
50606: ARRAY
50607: PPUSH
50608: LD_INT 25
50610: PUSH
50611: LD_INT 16
50613: PUSH
50614: EMPTY
50615: LIST
50616: LIST
50617: PUSH
50618: LD_INT 24
50620: PUSH
50621: LD_INT 750
50623: PUSH
50624: EMPTY
50625: LIST
50626: LIST
50627: PUSH
50628: EMPTY
50629: LIST
50630: LIST
50631: PPUSH
50632: CALL_OW 72
50636: ST_TO_ADDR
// if not tmp then
50637: LD_VAR 0 5
50641: NOT
50642: IFFALSE 50689
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
50644: LD_ADDR_VAR 0 5
50648: PUSH
50649: LD_EXP 99
50653: PUSH
50654: LD_VAR 0 2
50658: ARRAY
50659: PPUSH
50660: LD_INT 25
50662: PUSH
50663: LD_INT 2
50665: PUSH
50666: EMPTY
50667: LIST
50668: LIST
50669: PUSH
50670: LD_INT 24
50672: PUSH
50673: LD_INT 750
50675: PUSH
50676: EMPTY
50677: LIST
50678: LIST
50679: PUSH
50680: EMPTY
50681: LIST
50682: LIST
50683: PPUSH
50684: CALL_OW 72
50688: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
50689: LD_EXP 128
50693: PUSH
50694: LD_VAR 0 2
50698: ARRAY
50699: PUSH
50700: LD_EXP 99
50704: PUSH
50705: LD_VAR 0 2
50709: ARRAY
50710: PPUSH
50711: LD_INT 25
50713: PUSH
50714: LD_INT 2
50716: PUSH
50717: EMPTY
50718: LIST
50719: LIST
50720: PUSH
50721: LD_INT 24
50723: PUSH
50724: LD_INT 750
50726: PUSH
50727: EMPTY
50728: LIST
50729: LIST
50730: PUSH
50731: EMPTY
50732: LIST
50733: LIST
50734: PPUSH
50735: CALL_OW 72
50739: AND
50740: PUSH
50741: LD_VAR 0 5
50745: PUSH
50746: LD_INT 5
50748: LESS
50749: AND
50750: IFFALSE 50832
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
50752: LD_ADDR_VAR 0 3
50756: PUSH
50757: LD_EXP 99
50761: PUSH
50762: LD_VAR 0 2
50766: ARRAY
50767: PPUSH
50768: LD_INT 25
50770: PUSH
50771: LD_INT 2
50773: PUSH
50774: EMPTY
50775: LIST
50776: LIST
50777: PUSH
50778: LD_INT 24
50780: PUSH
50781: LD_INT 750
50783: PUSH
50784: EMPTY
50785: LIST
50786: LIST
50787: PUSH
50788: EMPTY
50789: LIST
50790: LIST
50791: PPUSH
50792: CALL_OW 72
50796: PUSH
50797: FOR_IN
50798: IFFALSE 50830
// begin tmp := tmp union j ;
50800: LD_ADDR_VAR 0 5
50804: PUSH
50805: LD_VAR 0 5
50809: PUSH
50810: LD_VAR 0 3
50814: UNION
50815: ST_TO_ADDR
// if tmp >= 5 then
50816: LD_VAR 0 5
50820: PUSH
50821: LD_INT 5
50823: GREATEREQUAL
50824: IFFALSE 50828
// break ;
50826: GO 50830
// end ;
50828: GO 50797
50830: POP
50831: POP
// end ; if not tmp then
50832: LD_VAR 0 5
50836: NOT
50837: IFFALSE 50841
// continue ;
50839: GO 49994
// for j in tmp do
50841: LD_ADDR_VAR 0 3
50845: PUSH
50846: LD_VAR 0 5
50850: PUSH
50851: FOR_IN
50852: IFFALSE 50942
// if not GetTag ( j ) then
50854: LD_VAR 0 3
50858: PPUSH
50859: CALL_OW 110
50863: NOT
50864: IFFALSE 50940
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
50866: LD_ADDR_EXP 116
50870: PUSH
50871: LD_EXP 116
50875: PPUSH
50876: LD_VAR 0 2
50880: PUSH
50881: LD_EXP 116
50885: PUSH
50886: LD_VAR 0 2
50890: ARRAY
50891: PUSH
50892: LD_INT 1
50894: PLUS
50895: PUSH
50896: EMPTY
50897: LIST
50898: LIST
50899: PPUSH
50900: LD_VAR 0 3
50904: PPUSH
50905: CALL 72472 0 3
50909: ST_TO_ADDR
// SetTag ( j , 107 ) ;
50910: LD_VAR 0 3
50914: PPUSH
50915: LD_INT 107
50917: PPUSH
50918: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
50922: LD_EXP 116
50926: PUSH
50927: LD_VAR 0 2
50931: ARRAY
50932: PUSH
50933: LD_INT 5
50935: GREATEREQUAL
50936: IFFALSE 50940
// break ;
50938: GO 50942
// end ;
50940: GO 50851
50942: POP
50943: POP
// end ; if mc_crates_collector [ i ] and target then
50944: LD_EXP 116
50948: PUSH
50949: LD_VAR 0 2
50953: ARRAY
50954: PUSH
50955: LD_VAR 0 7
50959: AND
50960: IFFALSE 51266
// begin if mc_crates_collector [ i ] < target [ 1 ] then
50962: LD_EXP 116
50966: PUSH
50967: LD_VAR 0 2
50971: ARRAY
50972: PUSH
50973: LD_VAR 0 7
50977: PUSH
50978: LD_INT 1
50980: ARRAY
50981: LESS
50982: IFFALSE 51002
// tmp := mc_crates_collector [ i ] else
50984: LD_ADDR_VAR 0 5
50988: PUSH
50989: LD_EXP 116
50993: PUSH
50994: LD_VAR 0 2
50998: ARRAY
50999: ST_TO_ADDR
51000: GO 51016
// tmp := target [ 1 ] ;
51002: LD_ADDR_VAR 0 5
51006: PUSH
51007: LD_VAR 0 7
51011: PUSH
51012: LD_INT 1
51014: ARRAY
51015: ST_TO_ADDR
// k := 0 ;
51016: LD_ADDR_VAR 0 4
51020: PUSH
51021: LD_INT 0
51023: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
51024: LD_ADDR_VAR 0 3
51028: PUSH
51029: LD_EXP 116
51033: PUSH
51034: LD_VAR 0 2
51038: ARRAY
51039: PUSH
51040: FOR_IN
51041: IFFALSE 51264
// begin k := k + 1 ;
51043: LD_ADDR_VAR 0 4
51047: PUSH
51048: LD_VAR 0 4
51052: PUSH
51053: LD_INT 1
51055: PLUS
51056: ST_TO_ADDR
// if k > tmp then
51057: LD_VAR 0 4
51061: PUSH
51062: LD_VAR 0 5
51066: GREATER
51067: IFFALSE 51071
// break ;
51069: GO 51264
// if not GetClass ( j ) in [ 2 , 16 ] then
51071: LD_VAR 0 3
51075: PPUSH
51076: CALL_OW 257
51080: PUSH
51081: LD_INT 2
51083: PUSH
51084: LD_INT 16
51086: PUSH
51087: EMPTY
51088: LIST
51089: LIST
51090: IN
51091: NOT
51092: IFFALSE 51145
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
51094: LD_ADDR_EXP 116
51098: PUSH
51099: LD_EXP 116
51103: PPUSH
51104: LD_VAR 0 2
51108: PPUSH
51109: LD_EXP 116
51113: PUSH
51114: LD_VAR 0 2
51118: ARRAY
51119: PUSH
51120: LD_VAR 0 3
51124: DIFF
51125: PPUSH
51126: CALL_OW 1
51130: ST_TO_ADDR
// SetTag ( j , 0 ) ;
51131: LD_VAR 0 3
51135: PPUSH
51136: LD_INT 0
51138: PPUSH
51139: CALL_OW 109
// continue ;
51143: GO 51040
// end ; if IsInUnit ( j ) then
51145: LD_VAR 0 3
51149: PPUSH
51150: CALL_OW 310
51154: IFFALSE 51165
// ComExitBuilding ( j ) ;
51156: LD_VAR 0 3
51160: PPUSH
51161: CALL_OW 122
// wait ( 3 ) ;
51165: LD_INT 3
51167: PPUSH
51168: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
51172: LD_VAR 0 3
51176: PPUSH
51177: CALL_OW 314
51181: PUSH
51182: LD_VAR 0 6
51186: PPUSH
51187: LD_VAR 0 7
51191: PUSH
51192: LD_INT 2
51194: ARRAY
51195: PPUSH
51196: LD_VAR 0 7
51200: PUSH
51201: LD_INT 3
51203: ARRAY
51204: PPUSH
51205: LD_INT 30
51207: PPUSH
51208: CALL 73368 0 4
51212: PUSH
51213: LD_INT 4
51215: ARRAY
51216: AND
51217: IFFALSE 51235
// ComStandNearbyBuilding ( j , depot ) else
51219: LD_VAR 0 3
51223: PPUSH
51224: LD_VAR 0 9
51228: PPUSH
51229: CALL 68899 0 2
51233: GO 51262
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
51235: LD_VAR 0 3
51239: PPUSH
51240: LD_VAR 0 7
51244: PUSH
51245: LD_INT 2
51247: ARRAY
51248: PPUSH
51249: LD_VAR 0 7
51253: PUSH
51254: LD_INT 3
51256: ARRAY
51257: PPUSH
51258: CALL_OW 117
// end ;
51262: GO 51040
51264: POP
51265: POP
// end ; end else
51266: GO 51798
// begin for j in cargo do
51268: LD_ADDR_VAR 0 3
51272: PUSH
51273: LD_VAR 0 8
51277: PUSH
51278: FOR_IN
51279: IFFALSE 51796
// begin if GetTag ( j ) <> 0 then
51281: LD_VAR 0 3
51285: PPUSH
51286: CALL_OW 110
51290: PUSH
51291: LD_INT 0
51293: NONEQUAL
51294: IFFALSE 51298
// continue ;
51296: GO 51278
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
51298: LD_VAR 0 3
51302: PPUSH
51303: CALL_OW 256
51307: PUSH
51308: LD_INT 1000
51310: LESS
51311: PUSH
51312: LD_VAR 0 3
51316: PPUSH
51317: LD_EXP 123
51321: PUSH
51322: LD_VAR 0 2
51326: ARRAY
51327: PPUSH
51328: CALL_OW 308
51332: NOT
51333: AND
51334: IFFALSE 51356
// ComMoveToArea ( j , mc_parking [ i ] ) ;
51336: LD_VAR 0 3
51340: PPUSH
51341: LD_EXP 123
51345: PUSH
51346: LD_VAR 0 2
51350: ARRAY
51351: PPUSH
51352: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
51356: LD_VAR 0 3
51360: PPUSH
51361: CALL_OW 256
51365: PUSH
51366: LD_INT 1000
51368: LESS
51369: PUSH
51370: LD_VAR 0 3
51374: PPUSH
51375: LD_EXP 123
51379: PUSH
51380: LD_VAR 0 2
51384: ARRAY
51385: PPUSH
51386: CALL_OW 308
51390: AND
51391: IFFALSE 51395
// continue ;
51393: GO 51278
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
51395: LD_VAR 0 3
51399: PPUSH
51400: CALL_OW 262
51404: PUSH
51405: LD_INT 2
51407: EQUAL
51408: PUSH
51409: LD_VAR 0 3
51413: PPUSH
51414: CALL_OW 261
51418: PUSH
51419: LD_INT 15
51421: LESS
51422: AND
51423: IFFALSE 51427
// continue ;
51425: GO 51278
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
51427: LD_VAR 0 3
51431: PPUSH
51432: CALL_OW 262
51436: PUSH
51437: LD_INT 1
51439: EQUAL
51440: PUSH
51441: LD_VAR 0 3
51445: PPUSH
51446: CALL_OW 261
51450: PUSH
51451: LD_INT 10
51453: LESS
51454: AND
51455: IFFALSE 51735
// begin if not depot then
51457: LD_VAR 0 9
51461: NOT
51462: IFFALSE 51466
// continue ;
51464: GO 51278
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
51466: LD_VAR 0 3
51470: PPUSH
51471: LD_VAR 0 9
51475: PPUSH
51476: LD_VAR 0 3
51480: PPUSH
51481: CALL_OW 74
51485: PPUSH
51486: CALL_OW 296
51490: PUSH
51491: LD_INT 6
51493: LESS
51494: IFFALSE 51510
// SetFuel ( j , 100 ) else
51496: LD_VAR 0 3
51500: PPUSH
51501: LD_INT 100
51503: PPUSH
51504: CALL_OW 240
51508: GO 51735
// if GetFuel ( j ) = 0 then
51510: LD_VAR 0 3
51514: PPUSH
51515: CALL_OW 261
51519: PUSH
51520: LD_INT 0
51522: EQUAL
51523: IFFALSE 51735
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
51525: LD_ADDR_EXP 118
51529: PUSH
51530: LD_EXP 118
51534: PPUSH
51535: LD_VAR 0 2
51539: PPUSH
51540: LD_EXP 118
51544: PUSH
51545: LD_VAR 0 2
51549: ARRAY
51550: PUSH
51551: LD_VAR 0 3
51555: DIFF
51556: PPUSH
51557: CALL_OW 1
51561: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
51562: LD_VAR 0 3
51566: PPUSH
51567: CALL_OW 263
51571: PUSH
51572: LD_INT 1
51574: EQUAL
51575: IFFALSE 51591
// ComExitVehicle ( IsInUnit ( j ) ) ;
51577: LD_VAR 0 3
51581: PPUSH
51582: CALL_OW 310
51586: PPUSH
51587: CALL_OW 121
// if GetControl ( j ) = control_remote then
51591: LD_VAR 0 3
51595: PPUSH
51596: CALL_OW 263
51600: PUSH
51601: LD_INT 2
51603: EQUAL
51604: IFFALSE 51615
// ComUnlink ( j ) ;
51606: LD_VAR 0 3
51610: PPUSH
51611: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
51615: LD_ADDR_VAR 0 10
51619: PUSH
51620: LD_VAR 0 2
51624: PPUSH
51625: LD_INT 3
51627: PPUSH
51628: CALL 61402 0 2
51632: ST_TO_ADDR
// if fac then
51633: LD_VAR 0 10
51637: IFFALSE 51733
// begin for k in fac do
51639: LD_ADDR_VAR 0 4
51643: PUSH
51644: LD_VAR 0 10
51648: PUSH
51649: FOR_IN
51650: IFFALSE 51731
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
51652: LD_ADDR_VAR 0 11
51656: PUSH
51657: LD_VAR 0 10
51661: PPUSH
51662: LD_VAR 0 3
51666: PPUSH
51667: CALL_OW 265
51671: PPUSH
51672: LD_VAR 0 3
51676: PPUSH
51677: CALL_OW 262
51681: PPUSH
51682: LD_VAR 0 3
51686: PPUSH
51687: CALL_OW 263
51691: PPUSH
51692: LD_VAR 0 3
51696: PPUSH
51697: CALL_OW 264
51701: PPUSH
51702: CALL 69970 0 5
51706: ST_TO_ADDR
// if components then
51707: LD_VAR 0 11
51711: IFFALSE 51729
// begin MC_InsertProduceList ( i , components ) ;
51713: LD_VAR 0 2
51717: PPUSH
51718: LD_VAR 0 11
51722: PPUSH
51723: CALL 60947 0 2
// break ;
51727: GO 51731
// end ; end ;
51729: GO 51649
51731: POP
51732: POP
// end ; continue ;
51733: GO 51278
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
51735: LD_VAR 0 3
51739: PPUSH
51740: LD_INT 1
51742: PPUSH
51743: CALL_OW 289
51747: PUSH
51748: LD_INT 100
51750: LESS
51751: PUSH
51752: LD_VAR 0 3
51756: PPUSH
51757: CALL_OW 314
51761: NOT
51762: AND
51763: IFFALSE 51792
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
51765: LD_VAR 0 3
51769: PPUSH
51770: LD_VAR 0 7
51774: PUSH
51775: LD_INT 2
51777: ARRAY
51778: PPUSH
51779: LD_VAR 0 7
51783: PUSH
51784: LD_INT 3
51786: ARRAY
51787: PPUSH
51788: CALL_OW 117
// break ;
51792: GO 51796
// end ;
51794: GO 51278
51796: POP
51797: POP
// end ; end ;
51798: GO 49994
51800: POP
51801: POP
// end ;
51802: LD_VAR 0 1
51806: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
51807: LD_INT 0
51809: PPUSH
51810: PPUSH
51811: PPUSH
51812: PPUSH
// if not mc_bases then
51813: LD_EXP 99
51817: NOT
51818: IFFALSE 51822
// exit ;
51820: GO 51983
// for i = 1 to mc_bases do
51822: LD_ADDR_VAR 0 2
51826: PUSH
51827: DOUBLE
51828: LD_INT 1
51830: DEC
51831: ST_TO_ADDR
51832: LD_EXP 99
51836: PUSH
51837: FOR_TO
51838: IFFALSE 51981
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
51840: LD_ADDR_VAR 0 4
51844: PUSH
51845: LD_EXP 118
51849: PUSH
51850: LD_VAR 0 2
51854: ARRAY
51855: PUSH
51856: LD_EXP 121
51860: PUSH
51861: LD_VAR 0 2
51865: ARRAY
51866: UNION
51867: PPUSH
51868: LD_INT 33
51870: PUSH
51871: LD_INT 2
51873: PUSH
51874: EMPTY
51875: LIST
51876: LIST
51877: PPUSH
51878: CALL_OW 72
51882: ST_TO_ADDR
// if tmp then
51883: LD_VAR 0 4
51887: IFFALSE 51979
// for j in tmp do
51889: LD_ADDR_VAR 0 3
51893: PUSH
51894: LD_VAR 0 4
51898: PUSH
51899: FOR_IN
51900: IFFALSE 51977
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
51902: LD_VAR 0 3
51906: PPUSH
51907: CALL_OW 312
51911: NOT
51912: PUSH
51913: LD_VAR 0 3
51917: PPUSH
51918: CALL_OW 256
51922: PUSH
51923: LD_INT 250
51925: GREATEREQUAL
51926: AND
51927: IFFALSE 51940
// Connect ( j ) else
51929: LD_VAR 0 3
51933: PPUSH
51934: CALL 75441 0 1
51938: GO 51975
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
51940: LD_VAR 0 3
51944: PPUSH
51945: CALL_OW 256
51949: PUSH
51950: LD_INT 250
51952: LESS
51953: PUSH
51954: LD_VAR 0 3
51958: PPUSH
51959: CALL_OW 312
51963: AND
51964: IFFALSE 51975
// ComUnlink ( j ) ;
51966: LD_VAR 0 3
51970: PPUSH
51971: CALL_OW 136
51975: GO 51899
51977: POP
51978: POP
// end ;
51979: GO 51837
51981: POP
51982: POP
// end ;
51983: LD_VAR 0 1
51987: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
51988: LD_INT 0
51990: PPUSH
51991: PPUSH
51992: PPUSH
51993: PPUSH
51994: PPUSH
// if not mc_bases then
51995: LD_EXP 99
51999: NOT
52000: IFFALSE 52004
// exit ;
52002: GO 52449
// for i = 1 to mc_bases do
52004: LD_ADDR_VAR 0 2
52008: PUSH
52009: DOUBLE
52010: LD_INT 1
52012: DEC
52013: ST_TO_ADDR
52014: LD_EXP 99
52018: PUSH
52019: FOR_TO
52020: IFFALSE 52447
// begin if not mc_produce [ i ] then
52022: LD_EXP 120
52026: PUSH
52027: LD_VAR 0 2
52031: ARRAY
52032: NOT
52033: IFFALSE 52037
// continue ;
52035: GO 52019
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52037: LD_ADDR_VAR 0 5
52041: PUSH
52042: LD_EXP 99
52046: PUSH
52047: LD_VAR 0 2
52051: ARRAY
52052: PPUSH
52053: LD_INT 30
52055: PUSH
52056: LD_INT 3
52058: PUSH
52059: EMPTY
52060: LIST
52061: LIST
52062: PPUSH
52063: CALL_OW 72
52067: ST_TO_ADDR
// if not fac then
52068: LD_VAR 0 5
52072: NOT
52073: IFFALSE 52077
// continue ;
52075: GO 52019
// for j in fac do
52077: LD_ADDR_VAR 0 3
52081: PUSH
52082: LD_VAR 0 5
52086: PUSH
52087: FOR_IN
52088: IFFALSE 52443
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
52090: LD_VAR 0 3
52094: PPUSH
52095: CALL_OW 461
52099: PUSH
52100: LD_INT 2
52102: NONEQUAL
52103: PUSH
52104: LD_VAR 0 3
52108: PPUSH
52109: LD_INT 15
52111: PPUSH
52112: CALL 75069 0 2
52116: PUSH
52117: LD_INT 4
52119: ARRAY
52120: OR
52121: IFFALSE 52125
// continue ;
52123: GO 52087
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
52125: LD_VAR 0 3
52129: PPUSH
52130: LD_EXP 120
52134: PUSH
52135: LD_VAR 0 2
52139: ARRAY
52140: PUSH
52141: LD_INT 1
52143: ARRAY
52144: PUSH
52145: LD_INT 1
52147: ARRAY
52148: PPUSH
52149: LD_EXP 120
52153: PUSH
52154: LD_VAR 0 2
52158: ARRAY
52159: PUSH
52160: LD_INT 1
52162: ARRAY
52163: PUSH
52164: LD_INT 2
52166: ARRAY
52167: PPUSH
52168: LD_EXP 120
52172: PUSH
52173: LD_VAR 0 2
52177: ARRAY
52178: PUSH
52179: LD_INT 1
52181: ARRAY
52182: PUSH
52183: LD_INT 3
52185: ARRAY
52186: PPUSH
52187: LD_EXP 120
52191: PUSH
52192: LD_VAR 0 2
52196: ARRAY
52197: PUSH
52198: LD_INT 1
52200: ARRAY
52201: PUSH
52202: LD_INT 4
52204: ARRAY
52205: PPUSH
52206: CALL_OW 448
52210: PUSH
52211: LD_VAR 0 3
52215: PPUSH
52216: LD_EXP 120
52220: PUSH
52221: LD_VAR 0 2
52225: ARRAY
52226: PUSH
52227: LD_INT 1
52229: ARRAY
52230: PUSH
52231: LD_INT 1
52233: ARRAY
52234: PUSH
52235: LD_EXP 120
52239: PUSH
52240: LD_VAR 0 2
52244: ARRAY
52245: PUSH
52246: LD_INT 1
52248: ARRAY
52249: PUSH
52250: LD_INT 2
52252: ARRAY
52253: PUSH
52254: LD_EXP 120
52258: PUSH
52259: LD_VAR 0 2
52263: ARRAY
52264: PUSH
52265: LD_INT 1
52267: ARRAY
52268: PUSH
52269: LD_INT 3
52271: ARRAY
52272: PUSH
52273: LD_EXP 120
52277: PUSH
52278: LD_VAR 0 2
52282: ARRAY
52283: PUSH
52284: LD_INT 1
52286: ARRAY
52287: PUSH
52288: LD_INT 4
52290: ARRAY
52291: PUSH
52292: EMPTY
52293: LIST
52294: LIST
52295: LIST
52296: LIST
52297: PPUSH
52298: CALL 78836 0 2
52302: AND
52303: IFFALSE 52441
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
52305: LD_VAR 0 3
52309: PPUSH
52310: LD_EXP 120
52314: PUSH
52315: LD_VAR 0 2
52319: ARRAY
52320: PUSH
52321: LD_INT 1
52323: ARRAY
52324: PUSH
52325: LD_INT 1
52327: ARRAY
52328: PPUSH
52329: LD_EXP 120
52333: PUSH
52334: LD_VAR 0 2
52338: ARRAY
52339: PUSH
52340: LD_INT 1
52342: ARRAY
52343: PUSH
52344: LD_INT 2
52346: ARRAY
52347: PPUSH
52348: LD_EXP 120
52352: PUSH
52353: LD_VAR 0 2
52357: ARRAY
52358: PUSH
52359: LD_INT 1
52361: ARRAY
52362: PUSH
52363: LD_INT 3
52365: ARRAY
52366: PPUSH
52367: LD_EXP 120
52371: PUSH
52372: LD_VAR 0 2
52376: ARRAY
52377: PUSH
52378: LD_INT 1
52380: ARRAY
52381: PUSH
52382: LD_INT 4
52384: ARRAY
52385: PPUSH
52386: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
52390: LD_ADDR_VAR 0 4
52394: PUSH
52395: LD_EXP 120
52399: PUSH
52400: LD_VAR 0 2
52404: ARRAY
52405: PPUSH
52406: LD_INT 1
52408: PPUSH
52409: CALL_OW 3
52413: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
52414: LD_ADDR_EXP 120
52418: PUSH
52419: LD_EXP 120
52423: PPUSH
52424: LD_VAR 0 2
52428: PPUSH
52429: LD_VAR 0 4
52433: PPUSH
52434: CALL_OW 1
52438: ST_TO_ADDR
// break ;
52439: GO 52443
// end ; end ;
52441: GO 52087
52443: POP
52444: POP
// end ;
52445: GO 52019
52447: POP
52448: POP
// end ;
52449: LD_VAR 0 1
52453: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
52454: LD_INT 0
52456: PPUSH
52457: PPUSH
52458: PPUSH
// if not mc_bases then
52459: LD_EXP 99
52463: NOT
52464: IFFALSE 52468
// exit ;
52466: GO 52557
// for i = 1 to mc_bases do
52468: LD_ADDR_VAR 0 2
52472: PUSH
52473: DOUBLE
52474: LD_INT 1
52476: DEC
52477: ST_TO_ADDR
52478: LD_EXP 99
52482: PUSH
52483: FOR_TO
52484: IFFALSE 52555
// begin if mc_attack [ i ] then
52486: LD_EXP 119
52490: PUSH
52491: LD_VAR 0 2
52495: ARRAY
52496: IFFALSE 52553
// begin tmp := mc_attack [ i ] [ 1 ] ;
52498: LD_ADDR_VAR 0 3
52502: PUSH
52503: LD_EXP 119
52507: PUSH
52508: LD_VAR 0 2
52512: ARRAY
52513: PUSH
52514: LD_INT 1
52516: ARRAY
52517: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
52518: LD_ADDR_EXP 119
52522: PUSH
52523: LD_EXP 119
52527: PPUSH
52528: LD_VAR 0 2
52532: PPUSH
52533: EMPTY
52534: PPUSH
52535: CALL_OW 1
52539: ST_TO_ADDR
// Attack ( tmp ) ;
52540: LD_VAR 0 3
52544: PPUSH
52545: CALL 128641 0 1
// exit ;
52549: POP
52550: POP
52551: GO 52557
// end ; end ;
52553: GO 52483
52555: POP
52556: POP
// end ;
52557: LD_VAR 0 1
52561: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
52562: LD_INT 0
52564: PPUSH
52565: PPUSH
52566: PPUSH
52567: PPUSH
52568: PPUSH
52569: PPUSH
52570: PPUSH
// if not mc_bases then
52571: LD_EXP 99
52575: NOT
52576: IFFALSE 52580
// exit ;
52578: GO 53437
// for i = 1 to mc_bases do
52580: LD_ADDR_VAR 0 2
52584: PUSH
52585: DOUBLE
52586: LD_INT 1
52588: DEC
52589: ST_TO_ADDR
52590: LD_EXP 99
52594: PUSH
52595: FOR_TO
52596: IFFALSE 53435
// begin if not mc_bases [ i ] then
52598: LD_EXP 99
52602: PUSH
52603: LD_VAR 0 2
52607: ARRAY
52608: NOT
52609: IFFALSE 52613
// continue ;
52611: GO 52595
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
52613: LD_ADDR_VAR 0 7
52617: PUSH
52618: LD_EXP 99
52622: PUSH
52623: LD_VAR 0 2
52627: ARRAY
52628: PUSH
52629: LD_INT 1
52631: ARRAY
52632: PPUSH
52633: CALL 69121 0 1
52637: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
52638: LD_ADDR_EXP 122
52642: PUSH
52643: LD_EXP 122
52647: PPUSH
52648: LD_VAR 0 2
52652: PPUSH
52653: LD_EXP 99
52657: PUSH
52658: LD_VAR 0 2
52662: ARRAY
52663: PUSH
52664: LD_INT 1
52666: ARRAY
52667: PPUSH
52668: CALL_OW 255
52672: PPUSH
52673: LD_EXP 124
52677: PUSH
52678: LD_VAR 0 2
52682: ARRAY
52683: PPUSH
52684: CALL 69086 0 2
52688: PPUSH
52689: CALL_OW 1
52693: ST_TO_ADDR
// if not mc_scan [ i ] then
52694: LD_EXP 122
52698: PUSH
52699: LD_VAR 0 2
52703: ARRAY
52704: NOT
52705: IFFALSE 52883
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
52707: LD_ADDR_EXP 142
52711: PUSH
52712: LD_EXP 142
52716: PPUSH
52717: LD_VAR 0 2
52721: PPUSH
52722: LD_INT 0
52724: PPUSH
52725: CALL_OW 1
52729: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52730: LD_ADDR_VAR 0 4
52734: PUSH
52735: LD_EXP 99
52739: PUSH
52740: LD_VAR 0 2
52744: ARRAY
52745: PPUSH
52746: LD_INT 2
52748: PUSH
52749: LD_INT 25
52751: PUSH
52752: LD_INT 5
52754: PUSH
52755: EMPTY
52756: LIST
52757: LIST
52758: PUSH
52759: LD_INT 25
52761: PUSH
52762: LD_INT 8
52764: PUSH
52765: EMPTY
52766: LIST
52767: LIST
52768: PUSH
52769: LD_INT 25
52771: PUSH
52772: LD_INT 9
52774: PUSH
52775: EMPTY
52776: LIST
52777: LIST
52778: PUSH
52779: EMPTY
52780: LIST
52781: LIST
52782: LIST
52783: LIST
52784: PPUSH
52785: CALL_OW 72
52789: ST_TO_ADDR
// if not tmp then
52790: LD_VAR 0 4
52794: NOT
52795: IFFALSE 52799
// continue ;
52797: GO 52595
// for j in tmp do
52799: LD_ADDR_VAR 0 3
52803: PUSH
52804: LD_VAR 0 4
52808: PUSH
52809: FOR_IN
52810: IFFALSE 52881
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
52812: LD_VAR 0 3
52816: PPUSH
52817: CALL_OW 310
52821: PPUSH
52822: CALL_OW 266
52826: PUSH
52827: LD_INT 5
52829: EQUAL
52830: PUSH
52831: LD_VAR 0 3
52835: PPUSH
52836: CALL_OW 257
52840: PUSH
52841: LD_INT 1
52843: EQUAL
52844: AND
52845: PUSH
52846: LD_VAR 0 3
52850: PPUSH
52851: CALL_OW 459
52855: NOT
52856: AND
52857: PUSH
52858: LD_VAR 0 7
52862: AND
52863: IFFALSE 52879
// ComChangeProfession ( j , class ) ;
52865: LD_VAR 0 3
52869: PPUSH
52870: LD_VAR 0 7
52874: PPUSH
52875: CALL_OW 123
52879: GO 52809
52881: POP
52882: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
52883: LD_EXP 122
52887: PUSH
52888: LD_VAR 0 2
52892: ARRAY
52893: PUSH
52894: LD_EXP 142
52898: PUSH
52899: LD_VAR 0 2
52903: ARRAY
52904: NOT
52905: AND
52906: PUSH
52907: LD_EXP 121
52911: PUSH
52912: LD_VAR 0 2
52916: ARRAY
52917: NOT
52918: AND
52919: PUSH
52920: LD_EXP 99
52924: PUSH
52925: LD_VAR 0 2
52929: ARRAY
52930: PPUSH
52931: LD_INT 50
52933: PUSH
52934: EMPTY
52935: LIST
52936: PUSH
52937: LD_INT 2
52939: PUSH
52940: LD_INT 30
52942: PUSH
52943: LD_INT 32
52945: PUSH
52946: EMPTY
52947: LIST
52948: LIST
52949: PUSH
52950: LD_INT 30
52952: PUSH
52953: LD_INT 33
52955: PUSH
52956: EMPTY
52957: LIST
52958: LIST
52959: PUSH
52960: LD_INT 30
52962: PUSH
52963: LD_INT 4
52965: PUSH
52966: EMPTY
52967: LIST
52968: LIST
52969: PUSH
52970: LD_INT 30
52972: PUSH
52973: LD_INT 5
52975: PUSH
52976: EMPTY
52977: LIST
52978: LIST
52979: PUSH
52980: EMPTY
52981: LIST
52982: LIST
52983: LIST
52984: LIST
52985: LIST
52986: PUSH
52987: EMPTY
52988: LIST
52989: LIST
52990: PPUSH
52991: CALL_OW 72
52995: PUSH
52996: LD_INT 4
52998: LESS
52999: PUSH
53000: LD_EXP 99
53004: PUSH
53005: LD_VAR 0 2
53009: ARRAY
53010: PPUSH
53011: LD_INT 3
53013: PUSH
53014: LD_INT 24
53016: PUSH
53017: LD_INT 1000
53019: PUSH
53020: EMPTY
53021: LIST
53022: LIST
53023: PUSH
53024: EMPTY
53025: LIST
53026: LIST
53027: PUSH
53028: LD_INT 2
53030: PUSH
53031: LD_INT 30
53033: PUSH
53034: LD_INT 0
53036: PUSH
53037: EMPTY
53038: LIST
53039: LIST
53040: PUSH
53041: LD_INT 30
53043: PUSH
53044: LD_INT 1
53046: PUSH
53047: EMPTY
53048: LIST
53049: LIST
53050: PUSH
53051: EMPTY
53052: LIST
53053: LIST
53054: LIST
53055: PUSH
53056: EMPTY
53057: LIST
53058: LIST
53059: PPUSH
53060: CALL_OW 72
53064: OR
53065: AND
53066: IFFALSE 53317
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
53068: LD_ADDR_EXP 142
53072: PUSH
53073: LD_EXP 142
53077: PPUSH
53078: LD_VAR 0 2
53082: PPUSH
53083: LD_INT 1
53085: PPUSH
53086: CALL_OW 1
53090: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
53091: LD_ADDR_VAR 0 4
53095: PUSH
53096: LD_EXP 99
53100: PUSH
53101: LD_VAR 0 2
53105: ARRAY
53106: PPUSH
53107: LD_INT 2
53109: PUSH
53110: LD_INT 25
53112: PUSH
53113: LD_INT 1
53115: PUSH
53116: EMPTY
53117: LIST
53118: LIST
53119: PUSH
53120: LD_INT 25
53122: PUSH
53123: LD_INT 5
53125: PUSH
53126: EMPTY
53127: LIST
53128: LIST
53129: PUSH
53130: LD_INT 25
53132: PUSH
53133: LD_INT 8
53135: PUSH
53136: EMPTY
53137: LIST
53138: LIST
53139: PUSH
53140: LD_INT 25
53142: PUSH
53143: LD_INT 9
53145: PUSH
53146: EMPTY
53147: LIST
53148: LIST
53149: PUSH
53150: EMPTY
53151: LIST
53152: LIST
53153: LIST
53154: LIST
53155: LIST
53156: PPUSH
53157: CALL_OW 72
53161: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
53162: LD_ADDR_VAR 0 4
53166: PUSH
53167: LD_VAR 0 4
53171: PUSH
53172: LD_VAR 0 4
53176: PPUSH
53177: LD_INT 18
53179: PPUSH
53180: CALL 102358 0 2
53184: DIFF
53185: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
53186: LD_VAR 0 4
53190: NOT
53191: PUSH
53192: LD_EXP 99
53196: PUSH
53197: LD_VAR 0 2
53201: ARRAY
53202: PPUSH
53203: LD_INT 2
53205: PUSH
53206: LD_INT 30
53208: PUSH
53209: LD_INT 4
53211: PUSH
53212: EMPTY
53213: LIST
53214: LIST
53215: PUSH
53216: LD_INT 30
53218: PUSH
53219: LD_INT 5
53221: PUSH
53222: EMPTY
53223: LIST
53224: LIST
53225: PUSH
53226: EMPTY
53227: LIST
53228: LIST
53229: LIST
53230: PPUSH
53231: CALL_OW 72
53235: NOT
53236: AND
53237: IFFALSE 53299
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
53239: LD_ADDR_VAR 0 4
53243: PUSH
53244: LD_EXP 99
53248: PUSH
53249: LD_VAR 0 2
53253: ARRAY
53254: PPUSH
53255: LD_INT 2
53257: PUSH
53258: LD_INT 25
53260: PUSH
53261: LD_INT 2
53263: PUSH
53264: EMPTY
53265: LIST
53266: LIST
53267: PUSH
53268: LD_INT 25
53270: PUSH
53271: LD_INT 3
53273: PUSH
53274: EMPTY
53275: LIST
53276: LIST
53277: PUSH
53278: LD_INT 25
53280: PUSH
53281: LD_INT 4
53283: PUSH
53284: EMPTY
53285: LIST
53286: LIST
53287: PUSH
53288: EMPTY
53289: LIST
53290: LIST
53291: LIST
53292: LIST
53293: PPUSH
53294: CALL_OW 72
53298: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
53299: LD_VAR 0 2
53303: PPUSH
53304: LD_VAR 0 4
53308: PPUSH
53309: CALL 133350 0 2
// exit ;
53313: POP
53314: POP
53315: GO 53437
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
53317: LD_EXP 122
53321: PUSH
53322: LD_VAR 0 2
53326: ARRAY
53327: PUSH
53328: LD_EXP 142
53332: PUSH
53333: LD_VAR 0 2
53337: ARRAY
53338: NOT
53339: AND
53340: PUSH
53341: LD_EXP 121
53345: PUSH
53346: LD_VAR 0 2
53350: ARRAY
53351: AND
53352: IFFALSE 53433
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
53354: LD_ADDR_EXP 142
53358: PUSH
53359: LD_EXP 142
53363: PPUSH
53364: LD_VAR 0 2
53368: PPUSH
53369: LD_INT 1
53371: PPUSH
53372: CALL_OW 1
53376: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
53377: LD_ADDR_VAR 0 4
53381: PUSH
53382: LD_EXP 121
53386: PUSH
53387: LD_VAR 0 2
53391: ARRAY
53392: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
53393: LD_ADDR_EXP 121
53397: PUSH
53398: LD_EXP 121
53402: PPUSH
53403: LD_VAR 0 2
53407: PPUSH
53408: EMPTY
53409: PPUSH
53410: CALL_OW 1
53414: ST_TO_ADDR
// Defend ( i , tmp ) ;
53415: LD_VAR 0 2
53419: PPUSH
53420: LD_VAR 0 4
53424: PPUSH
53425: CALL 133946 0 2
// exit ;
53429: POP
53430: POP
53431: GO 53437
// end ; end ;
53433: GO 52595
53435: POP
53436: POP
// end ;
53437: LD_VAR 0 1
53441: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
53442: LD_INT 0
53444: PPUSH
53445: PPUSH
53446: PPUSH
53447: PPUSH
53448: PPUSH
53449: PPUSH
53450: PPUSH
53451: PPUSH
53452: PPUSH
53453: PPUSH
53454: PPUSH
// if not mc_bases then
53455: LD_EXP 99
53459: NOT
53460: IFFALSE 53464
// exit ;
53462: GO 54551
// for i = 1 to mc_bases do
53464: LD_ADDR_VAR 0 2
53468: PUSH
53469: DOUBLE
53470: LD_INT 1
53472: DEC
53473: ST_TO_ADDR
53474: LD_EXP 99
53478: PUSH
53479: FOR_TO
53480: IFFALSE 54549
// begin tmp := mc_lab [ i ] ;
53482: LD_ADDR_VAR 0 6
53486: PUSH
53487: LD_EXP 132
53491: PUSH
53492: LD_VAR 0 2
53496: ARRAY
53497: ST_TO_ADDR
// if not tmp then
53498: LD_VAR 0 6
53502: NOT
53503: IFFALSE 53507
// continue ;
53505: GO 53479
// idle_lab := 0 ;
53507: LD_ADDR_VAR 0 11
53511: PUSH
53512: LD_INT 0
53514: ST_TO_ADDR
// for j in tmp do
53515: LD_ADDR_VAR 0 3
53519: PUSH
53520: LD_VAR 0 6
53524: PUSH
53525: FOR_IN
53526: IFFALSE 54545
// begin researching := false ;
53528: LD_ADDR_VAR 0 10
53532: PUSH
53533: LD_INT 0
53535: ST_TO_ADDR
// side := GetSide ( j ) ;
53536: LD_ADDR_VAR 0 4
53540: PUSH
53541: LD_VAR 0 3
53545: PPUSH
53546: CALL_OW 255
53550: ST_TO_ADDR
// if not mc_tech [ side ] then
53551: LD_EXP 126
53555: PUSH
53556: LD_VAR 0 4
53560: ARRAY
53561: NOT
53562: IFFALSE 53566
// continue ;
53564: GO 53525
// if BuildingStatus ( j ) = bs_idle then
53566: LD_VAR 0 3
53570: PPUSH
53571: CALL_OW 461
53575: PUSH
53576: LD_INT 2
53578: EQUAL
53579: IFFALSE 53767
// begin if idle_lab and UnitsInside ( j ) < 6 then
53581: LD_VAR 0 11
53585: PUSH
53586: LD_VAR 0 3
53590: PPUSH
53591: CALL_OW 313
53595: PUSH
53596: LD_INT 6
53598: LESS
53599: AND
53600: IFFALSE 53671
// begin tmp2 := UnitsInside ( idle_lab ) ;
53602: LD_ADDR_VAR 0 9
53606: PUSH
53607: LD_VAR 0 11
53611: PPUSH
53612: CALL_OW 313
53616: ST_TO_ADDR
// if tmp2 then
53617: LD_VAR 0 9
53621: IFFALSE 53663
// for x in tmp2 do
53623: LD_ADDR_VAR 0 7
53627: PUSH
53628: LD_VAR 0 9
53632: PUSH
53633: FOR_IN
53634: IFFALSE 53661
// begin ComExitBuilding ( x ) ;
53636: LD_VAR 0 7
53640: PPUSH
53641: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
53645: LD_VAR 0 7
53649: PPUSH
53650: LD_VAR 0 3
53654: PPUSH
53655: CALL_OW 180
// end ;
53659: GO 53633
53661: POP
53662: POP
// idle_lab := 0 ;
53663: LD_ADDR_VAR 0 11
53667: PUSH
53668: LD_INT 0
53670: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
53671: LD_ADDR_VAR 0 5
53675: PUSH
53676: LD_EXP 126
53680: PUSH
53681: LD_VAR 0 4
53685: ARRAY
53686: PUSH
53687: FOR_IN
53688: IFFALSE 53748
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
53690: LD_VAR 0 3
53694: PPUSH
53695: LD_VAR 0 5
53699: PPUSH
53700: CALL_OW 430
53704: PUSH
53705: LD_VAR 0 4
53709: PPUSH
53710: LD_VAR 0 5
53714: PPUSH
53715: CALL 68191 0 2
53719: AND
53720: IFFALSE 53746
// begin researching := true ;
53722: LD_ADDR_VAR 0 10
53726: PUSH
53727: LD_INT 1
53729: ST_TO_ADDR
// ComResearch ( j , t ) ;
53730: LD_VAR 0 3
53734: PPUSH
53735: LD_VAR 0 5
53739: PPUSH
53740: CALL_OW 124
// break ;
53744: GO 53748
// end ;
53746: GO 53687
53748: POP
53749: POP
// if not researching then
53750: LD_VAR 0 10
53754: NOT
53755: IFFALSE 53767
// idle_lab := j ;
53757: LD_ADDR_VAR 0 11
53761: PUSH
53762: LD_VAR 0 3
53766: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
53767: LD_VAR 0 3
53771: PPUSH
53772: CALL_OW 461
53776: PUSH
53777: LD_INT 10
53779: EQUAL
53780: IFFALSE 54368
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
53782: LD_EXP 128
53786: PUSH
53787: LD_VAR 0 2
53791: ARRAY
53792: NOT
53793: PUSH
53794: LD_EXP 129
53798: PUSH
53799: LD_VAR 0 2
53803: ARRAY
53804: NOT
53805: AND
53806: PUSH
53807: LD_EXP 126
53811: PUSH
53812: LD_VAR 0 4
53816: ARRAY
53817: PUSH
53818: LD_INT 1
53820: GREATER
53821: AND
53822: IFFALSE 53953
// begin ComCancel ( j ) ;
53824: LD_VAR 0 3
53828: PPUSH
53829: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
53833: LD_ADDR_EXP 126
53837: PUSH
53838: LD_EXP 126
53842: PPUSH
53843: LD_VAR 0 4
53847: PPUSH
53848: LD_EXP 126
53852: PUSH
53853: LD_VAR 0 4
53857: ARRAY
53858: PPUSH
53859: LD_EXP 126
53863: PUSH
53864: LD_VAR 0 4
53868: ARRAY
53869: PUSH
53870: LD_INT 1
53872: MINUS
53873: PPUSH
53874: LD_EXP 126
53878: PUSH
53879: LD_VAR 0 4
53883: ARRAY
53884: PPUSH
53885: LD_INT 0
53887: PPUSH
53888: CALL 71890 0 4
53892: PPUSH
53893: CALL_OW 1
53897: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
53898: LD_ADDR_EXP 126
53902: PUSH
53903: LD_EXP 126
53907: PPUSH
53908: LD_VAR 0 4
53912: PPUSH
53913: LD_EXP 126
53917: PUSH
53918: LD_VAR 0 4
53922: ARRAY
53923: PPUSH
53924: LD_EXP 126
53928: PUSH
53929: LD_VAR 0 4
53933: ARRAY
53934: PPUSH
53935: LD_INT 1
53937: PPUSH
53938: LD_INT 0
53940: PPUSH
53941: CALL 71890 0 4
53945: PPUSH
53946: CALL_OW 1
53950: ST_TO_ADDR
// continue ;
53951: GO 53525
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
53953: LD_EXP 128
53957: PUSH
53958: LD_VAR 0 2
53962: ARRAY
53963: PUSH
53964: LD_EXP 129
53968: PUSH
53969: LD_VAR 0 2
53973: ARRAY
53974: NOT
53975: AND
53976: IFFALSE 54103
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
53978: LD_ADDR_EXP 129
53982: PUSH
53983: LD_EXP 129
53987: PPUSH
53988: LD_VAR 0 2
53992: PUSH
53993: LD_EXP 129
53997: PUSH
53998: LD_VAR 0 2
54002: ARRAY
54003: PUSH
54004: LD_INT 1
54006: PLUS
54007: PUSH
54008: EMPTY
54009: LIST
54010: LIST
54011: PPUSH
54012: LD_EXP 128
54016: PUSH
54017: LD_VAR 0 2
54021: ARRAY
54022: PUSH
54023: LD_INT 1
54025: ARRAY
54026: PPUSH
54027: CALL 72472 0 3
54031: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
54032: LD_EXP 128
54036: PUSH
54037: LD_VAR 0 2
54041: ARRAY
54042: PUSH
54043: LD_INT 1
54045: ARRAY
54046: PPUSH
54047: LD_INT 112
54049: PPUSH
54050: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
54054: LD_ADDR_VAR 0 9
54058: PUSH
54059: LD_EXP 128
54063: PUSH
54064: LD_VAR 0 2
54068: ARRAY
54069: PPUSH
54070: LD_INT 1
54072: PPUSH
54073: CALL_OW 3
54077: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
54078: LD_ADDR_EXP 128
54082: PUSH
54083: LD_EXP 128
54087: PPUSH
54088: LD_VAR 0 2
54092: PPUSH
54093: LD_VAR 0 9
54097: PPUSH
54098: CALL_OW 1
54102: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
54103: LD_EXP 128
54107: PUSH
54108: LD_VAR 0 2
54112: ARRAY
54113: PUSH
54114: LD_EXP 129
54118: PUSH
54119: LD_VAR 0 2
54123: ARRAY
54124: AND
54125: PUSH
54126: LD_EXP 129
54130: PUSH
54131: LD_VAR 0 2
54135: ARRAY
54136: PUSH
54137: LD_INT 1
54139: ARRAY
54140: PPUSH
54141: CALL_OW 310
54145: NOT
54146: AND
54147: PUSH
54148: LD_VAR 0 3
54152: PPUSH
54153: CALL_OW 313
54157: PUSH
54158: LD_INT 6
54160: EQUAL
54161: AND
54162: IFFALSE 54218
// begin tmp2 := UnitsInside ( j ) ;
54164: LD_ADDR_VAR 0 9
54168: PUSH
54169: LD_VAR 0 3
54173: PPUSH
54174: CALL_OW 313
54178: ST_TO_ADDR
// if tmp2 = 6 then
54179: LD_VAR 0 9
54183: PUSH
54184: LD_INT 6
54186: EQUAL
54187: IFFALSE 54218
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
54189: LD_VAR 0 9
54193: PUSH
54194: LD_INT 1
54196: ARRAY
54197: PPUSH
54198: LD_INT 112
54200: PPUSH
54201: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
54205: LD_VAR 0 9
54209: PUSH
54210: LD_INT 1
54212: ARRAY
54213: PPUSH
54214: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
54218: LD_EXP 129
54222: PUSH
54223: LD_VAR 0 2
54227: ARRAY
54228: PUSH
54229: LD_EXP 129
54233: PUSH
54234: LD_VAR 0 2
54238: ARRAY
54239: PUSH
54240: LD_INT 1
54242: ARRAY
54243: PPUSH
54244: CALL_OW 314
54248: NOT
54249: AND
54250: PUSH
54251: LD_EXP 129
54255: PUSH
54256: LD_VAR 0 2
54260: ARRAY
54261: PUSH
54262: LD_INT 1
54264: ARRAY
54265: PPUSH
54266: CALL_OW 310
54270: NOT
54271: AND
54272: IFFALSE 54298
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
54274: LD_EXP 129
54278: PUSH
54279: LD_VAR 0 2
54283: ARRAY
54284: PUSH
54285: LD_INT 1
54287: ARRAY
54288: PPUSH
54289: LD_VAR 0 3
54293: PPUSH
54294: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
54298: LD_EXP 129
54302: PUSH
54303: LD_VAR 0 2
54307: ARRAY
54308: PUSH
54309: LD_INT 1
54311: ARRAY
54312: PPUSH
54313: CALL_OW 310
54317: PUSH
54318: LD_EXP 129
54322: PUSH
54323: LD_VAR 0 2
54327: ARRAY
54328: PUSH
54329: LD_INT 1
54331: ARRAY
54332: PPUSH
54333: CALL_OW 310
54337: PPUSH
54338: CALL_OW 461
54342: PUSH
54343: LD_INT 3
54345: NONEQUAL
54346: AND
54347: IFFALSE 54368
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
54349: LD_EXP 129
54353: PUSH
54354: LD_VAR 0 2
54358: ARRAY
54359: PUSH
54360: LD_INT 1
54362: ARRAY
54363: PPUSH
54364: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
54368: LD_VAR 0 3
54372: PPUSH
54373: CALL_OW 461
54377: PUSH
54378: LD_INT 6
54380: EQUAL
54381: PUSH
54382: LD_VAR 0 6
54386: PUSH
54387: LD_INT 1
54389: GREATER
54390: AND
54391: IFFALSE 54543
// begin sci := [ ] ;
54393: LD_ADDR_VAR 0 8
54397: PUSH
54398: EMPTY
54399: ST_TO_ADDR
// for x in ( tmp diff j ) do
54400: LD_ADDR_VAR 0 7
54404: PUSH
54405: LD_VAR 0 6
54409: PUSH
54410: LD_VAR 0 3
54414: DIFF
54415: PUSH
54416: FOR_IN
54417: IFFALSE 54469
// begin if sci = 6 then
54419: LD_VAR 0 8
54423: PUSH
54424: LD_INT 6
54426: EQUAL
54427: IFFALSE 54431
// break ;
54429: GO 54469
// if BuildingStatus ( x ) = bs_idle then
54431: LD_VAR 0 7
54435: PPUSH
54436: CALL_OW 461
54440: PUSH
54441: LD_INT 2
54443: EQUAL
54444: IFFALSE 54467
// sci := sci ^ UnitsInside ( x ) ;
54446: LD_ADDR_VAR 0 8
54450: PUSH
54451: LD_VAR 0 8
54455: PUSH
54456: LD_VAR 0 7
54460: PPUSH
54461: CALL_OW 313
54465: ADD
54466: ST_TO_ADDR
// end ;
54467: GO 54416
54469: POP
54470: POP
// if not sci then
54471: LD_VAR 0 8
54475: NOT
54476: IFFALSE 54480
// continue ;
54478: GO 53525
// for x in sci do
54480: LD_ADDR_VAR 0 7
54484: PUSH
54485: LD_VAR 0 8
54489: PUSH
54490: FOR_IN
54491: IFFALSE 54541
// if IsInUnit ( x ) and not HasTask ( x ) then
54493: LD_VAR 0 7
54497: PPUSH
54498: CALL_OW 310
54502: PUSH
54503: LD_VAR 0 7
54507: PPUSH
54508: CALL_OW 314
54512: NOT
54513: AND
54514: IFFALSE 54539
// begin ComExitBuilding ( x ) ;
54516: LD_VAR 0 7
54520: PPUSH
54521: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
54525: LD_VAR 0 7
54529: PPUSH
54530: LD_VAR 0 3
54534: PPUSH
54535: CALL_OW 180
// end ;
54539: GO 54490
54541: POP
54542: POP
// end ; end ;
54543: GO 53525
54545: POP
54546: POP
// end ;
54547: GO 53479
54549: POP
54550: POP
// end ;
54551: LD_VAR 0 1
54555: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
54556: LD_INT 0
54558: PPUSH
54559: PPUSH
// if not mc_bases then
54560: LD_EXP 99
54564: NOT
54565: IFFALSE 54569
// exit ;
54567: GO 54650
// for i = 1 to mc_bases do
54569: LD_ADDR_VAR 0 2
54573: PUSH
54574: DOUBLE
54575: LD_INT 1
54577: DEC
54578: ST_TO_ADDR
54579: LD_EXP 99
54583: PUSH
54584: FOR_TO
54585: IFFALSE 54648
// if mc_mines [ i ] and mc_miners [ i ] then
54587: LD_EXP 112
54591: PUSH
54592: LD_VAR 0 2
54596: ARRAY
54597: PUSH
54598: LD_EXP 113
54602: PUSH
54603: LD_VAR 0 2
54607: ARRAY
54608: AND
54609: IFFALSE 54646
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
54611: LD_EXP 113
54615: PUSH
54616: LD_VAR 0 2
54620: ARRAY
54621: PUSH
54622: LD_INT 1
54624: ARRAY
54625: PPUSH
54626: CALL_OW 255
54630: PPUSH
54631: LD_EXP 112
54635: PUSH
54636: LD_VAR 0 2
54640: ARRAY
54641: PPUSH
54642: CALL 69274 0 2
54646: GO 54584
54648: POP
54649: POP
// end ;
54650: LD_VAR 0 1
54654: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
54655: LD_INT 0
54657: PPUSH
54658: PPUSH
54659: PPUSH
54660: PPUSH
54661: PPUSH
54662: PPUSH
54663: PPUSH
54664: PPUSH
// if not mc_bases or not mc_parking then
54665: LD_EXP 99
54669: NOT
54670: PUSH
54671: LD_EXP 123
54675: NOT
54676: OR
54677: IFFALSE 54681
// exit ;
54679: GO 55419
// for i = 1 to mc_bases do
54681: LD_ADDR_VAR 0 2
54685: PUSH
54686: DOUBLE
54687: LD_INT 1
54689: DEC
54690: ST_TO_ADDR
54691: LD_EXP 99
54695: PUSH
54696: FOR_TO
54697: IFFALSE 55417
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
54699: LD_EXP 99
54703: PUSH
54704: LD_VAR 0 2
54708: ARRAY
54709: NOT
54710: PUSH
54711: LD_EXP 123
54715: PUSH
54716: LD_VAR 0 2
54720: ARRAY
54721: NOT
54722: OR
54723: IFFALSE 54727
// continue ;
54725: GO 54696
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
54727: LD_ADDR_VAR 0 5
54731: PUSH
54732: LD_EXP 99
54736: PUSH
54737: LD_VAR 0 2
54741: ARRAY
54742: PUSH
54743: LD_INT 1
54745: ARRAY
54746: PPUSH
54747: CALL_OW 255
54751: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54752: LD_ADDR_VAR 0 6
54756: PUSH
54757: LD_EXP 99
54761: PUSH
54762: LD_VAR 0 2
54766: ARRAY
54767: PPUSH
54768: LD_INT 30
54770: PUSH
54771: LD_INT 3
54773: PUSH
54774: EMPTY
54775: LIST
54776: LIST
54777: PPUSH
54778: CALL_OW 72
54782: ST_TO_ADDR
// if not fac then
54783: LD_VAR 0 6
54787: NOT
54788: IFFALSE 54839
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54790: LD_ADDR_VAR 0 6
54794: PUSH
54795: LD_EXP 99
54799: PUSH
54800: LD_VAR 0 2
54804: ARRAY
54805: PPUSH
54806: LD_INT 2
54808: PUSH
54809: LD_INT 30
54811: PUSH
54812: LD_INT 0
54814: PUSH
54815: EMPTY
54816: LIST
54817: LIST
54818: PUSH
54819: LD_INT 30
54821: PUSH
54822: LD_INT 1
54824: PUSH
54825: EMPTY
54826: LIST
54827: LIST
54828: PUSH
54829: EMPTY
54830: LIST
54831: LIST
54832: LIST
54833: PPUSH
54834: CALL_OW 72
54838: ST_TO_ADDR
// if not fac then
54839: LD_VAR 0 6
54843: NOT
54844: IFFALSE 54848
// continue ;
54846: GO 54696
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
54848: LD_ADDR_VAR 0 7
54852: PUSH
54853: LD_EXP 123
54857: PUSH
54858: LD_VAR 0 2
54862: ARRAY
54863: PPUSH
54864: LD_INT 22
54866: PUSH
54867: LD_VAR 0 5
54871: PUSH
54872: EMPTY
54873: LIST
54874: LIST
54875: PUSH
54876: LD_INT 21
54878: PUSH
54879: LD_INT 2
54881: PUSH
54882: EMPTY
54883: LIST
54884: LIST
54885: PUSH
54886: LD_INT 3
54888: PUSH
54889: LD_INT 60
54891: PUSH
54892: EMPTY
54893: LIST
54894: PUSH
54895: EMPTY
54896: LIST
54897: LIST
54898: PUSH
54899: LD_INT 3
54901: PUSH
54902: LD_INT 24
54904: PUSH
54905: LD_INT 1000
54907: PUSH
54908: EMPTY
54909: LIST
54910: LIST
54911: PUSH
54912: EMPTY
54913: LIST
54914: LIST
54915: PUSH
54916: EMPTY
54917: LIST
54918: LIST
54919: LIST
54920: LIST
54921: PPUSH
54922: CALL_OW 70
54926: ST_TO_ADDR
// for j in fac do
54927: LD_ADDR_VAR 0 3
54931: PUSH
54932: LD_VAR 0 6
54936: PUSH
54937: FOR_IN
54938: IFFALSE 55033
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
54940: LD_ADDR_VAR 0 7
54944: PUSH
54945: LD_VAR 0 7
54949: PUSH
54950: LD_INT 22
54952: PUSH
54953: LD_VAR 0 5
54957: PUSH
54958: EMPTY
54959: LIST
54960: LIST
54961: PUSH
54962: LD_INT 91
54964: PUSH
54965: LD_VAR 0 3
54969: PUSH
54970: LD_INT 15
54972: PUSH
54973: EMPTY
54974: LIST
54975: LIST
54976: LIST
54977: PUSH
54978: LD_INT 21
54980: PUSH
54981: LD_INT 2
54983: PUSH
54984: EMPTY
54985: LIST
54986: LIST
54987: PUSH
54988: LD_INT 3
54990: PUSH
54991: LD_INT 60
54993: PUSH
54994: EMPTY
54995: LIST
54996: PUSH
54997: EMPTY
54998: LIST
54999: LIST
55000: PUSH
55001: LD_INT 3
55003: PUSH
55004: LD_INT 24
55006: PUSH
55007: LD_INT 1000
55009: PUSH
55010: EMPTY
55011: LIST
55012: LIST
55013: PUSH
55014: EMPTY
55015: LIST
55016: LIST
55017: PUSH
55018: EMPTY
55019: LIST
55020: LIST
55021: LIST
55022: LIST
55023: LIST
55024: PPUSH
55025: CALL_OW 69
55029: UNION
55030: ST_TO_ADDR
55031: GO 54937
55033: POP
55034: POP
// if not vehs then
55035: LD_VAR 0 7
55039: NOT
55040: IFFALSE 55066
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
55042: LD_ADDR_EXP 111
55046: PUSH
55047: LD_EXP 111
55051: PPUSH
55052: LD_VAR 0 2
55056: PPUSH
55057: EMPTY
55058: PPUSH
55059: CALL_OW 1
55063: ST_TO_ADDR
// continue ;
55064: GO 54696
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
55066: LD_ADDR_VAR 0 8
55070: PUSH
55071: LD_EXP 99
55075: PUSH
55076: LD_VAR 0 2
55080: ARRAY
55081: PPUSH
55082: LD_INT 30
55084: PUSH
55085: LD_INT 3
55087: PUSH
55088: EMPTY
55089: LIST
55090: LIST
55091: PPUSH
55092: CALL_OW 72
55096: ST_TO_ADDR
// if tmp then
55097: LD_VAR 0 8
55101: IFFALSE 55204
// begin for j in tmp do
55103: LD_ADDR_VAR 0 3
55107: PUSH
55108: LD_VAR 0 8
55112: PUSH
55113: FOR_IN
55114: IFFALSE 55202
// for k in UnitsInside ( j ) do
55116: LD_ADDR_VAR 0 4
55120: PUSH
55121: LD_VAR 0 3
55125: PPUSH
55126: CALL_OW 313
55130: PUSH
55131: FOR_IN
55132: IFFALSE 55198
// if k then
55134: LD_VAR 0 4
55138: IFFALSE 55196
// if not k in mc_repair_vehicle [ i ] then
55140: LD_VAR 0 4
55144: PUSH
55145: LD_EXP 111
55149: PUSH
55150: LD_VAR 0 2
55154: ARRAY
55155: IN
55156: NOT
55157: IFFALSE 55196
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
55159: LD_ADDR_EXP 111
55163: PUSH
55164: LD_EXP 111
55168: PPUSH
55169: LD_VAR 0 2
55173: PPUSH
55174: LD_EXP 111
55178: PUSH
55179: LD_VAR 0 2
55183: ARRAY
55184: PUSH
55185: LD_VAR 0 4
55189: UNION
55190: PPUSH
55191: CALL_OW 1
55195: ST_TO_ADDR
55196: GO 55131
55198: POP
55199: POP
55200: GO 55113
55202: POP
55203: POP
// end ; if not mc_repair_vehicle [ i ] then
55204: LD_EXP 111
55208: PUSH
55209: LD_VAR 0 2
55213: ARRAY
55214: NOT
55215: IFFALSE 55219
// continue ;
55217: GO 54696
// for j in mc_repair_vehicle [ i ] do
55219: LD_ADDR_VAR 0 3
55223: PUSH
55224: LD_EXP 111
55228: PUSH
55229: LD_VAR 0 2
55233: ARRAY
55234: PUSH
55235: FOR_IN
55236: IFFALSE 55413
// begin if GetClass ( j ) <> 3 then
55238: LD_VAR 0 3
55242: PPUSH
55243: CALL_OW 257
55247: PUSH
55248: LD_INT 3
55250: NONEQUAL
55251: IFFALSE 55292
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
55253: LD_ADDR_EXP 111
55257: PUSH
55258: LD_EXP 111
55262: PPUSH
55263: LD_VAR 0 2
55267: PPUSH
55268: LD_EXP 111
55272: PUSH
55273: LD_VAR 0 2
55277: ARRAY
55278: PUSH
55279: LD_VAR 0 3
55283: DIFF
55284: PPUSH
55285: CALL_OW 1
55289: ST_TO_ADDR
// continue ;
55290: GO 55235
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
55292: LD_VAR 0 3
55296: PPUSH
55297: CALL_OW 311
55301: NOT
55302: PUSH
55303: LD_VAR 0 3
55307: PUSH
55308: LD_EXP 102
55312: PUSH
55313: LD_VAR 0 2
55317: ARRAY
55318: PUSH
55319: LD_INT 1
55321: ARRAY
55322: IN
55323: NOT
55324: AND
55325: PUSH
55326: LD_VAR 0 3
55330: PUSH
55331: LD_EXP 102
55335: PUSH
55336: LD_VAR 0 2
55340: ARRAY
55341: PUSH
55342: LD_INT 2
55344: ARRAY
55345: IN
55346: NOT
55347: AND
55348: IFFALSE 55411
// begin if IsInUnit ( j ) then
55350: LD_VAR 0 3
55354: PPUSH
55355: CALL_OW 310
55359: IFFALSE 55372
// ComExitBuilding ( j ) else
55361: LD_VAR 0 3
55365: PPUSH
55366: CALL_OW 122
55370: GO 55411
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
55372: LD_VAR 0 3
55376: PPUSH
55377: LD_VAR 0 7
55381: PUSH
55382: LD_INT 1
55384: ARRAY
55385: PPUSH
55386: CALL 106849 0 2
55390: NOT
55391: IFFALSE 55411
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
55393: LD_VAR 0 3
55397: PPUSH
55398: LD_VAR 0 7
55402: PUSH
55403: LD_INT 1
55405: ARRAY
55406: PPUSH
55407: CALL_OW 129
// end ; end ;
55411: GO 55235
55413: POP
55414: POP
// end ;
55415: GO 54696
55417: POP
55418: POP
// end ;
55419: LD_VAR 0 1
55423: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
55424: LD_INT 0
55426: PPUSH
55427: PPUSH
55428: PPUSH
55429: PPUSH
55430: PPUSH
55431: PPUSH
55432: PPUSH
55433: PPUSH
55434: PPUSH
55435: PPUSH
55436: PPUSH
// if not mc_bases then
55437: LD_EXP 99
55441: NOT
55442: IFFALSE 55446
// exit ;
55444: GO 56248
// for i = 1 to mc_bases do
55446: LD_ADDR_VAR 0 2
55450: PUSH
55451: DOUBLE
55452: LD_INT 1
55454: DEC
55455: ST_TO_ADDR
55456: LD_EXP 99
55460: PUSH
55461: FOR_TO
55462: IFFALSE 56246
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
55464: LD_EXP 127
55468: PUSH
55469: LD_VAR 0 2
55473: ARRAY
55474: NOT
55475: PUSH
55476: LD_EXP 102
55480: PUSH
55481: LD_VAR 0 2
55485: ARRAY
55486: PUSH
55487: LD_INT 1
55489: ARRAY
55490: OR
55491: PUSH
55492: LD_EXP 102
55496: PUSH
55497: LD_VAR 0 2
55501: ARRAY
55502: PUSH
55503: LD_INT 2
55505: ARRAY
55506: OR
55507: PUSH
55508: LD_EXP 125
55512: PUSH
55513: LD_VAR 0 2
55517: ARRAY
55518: PPUSH
55519: LD_INT 1
55521: PPUSH
55522: CALL_OW 325
55526: NOT
55527: OR
55528: PUSH
55529: LD_EXP 122
55533: PUSH
55534: LD_VAR 0 2
55538: ARRAY
55539: OR
55540: IFFALSE 55544
// continue ;
55542: GO 55461
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
55544: LD_ADDR_VAR 0 8
55548: PUSH
55549: LD_EXP 99
55553: PUSH
55554: LD_VAR 0 2
55558: ARRAY
55559: PPUSH
55560: LD_INT 25
55562: PUSH
55563: LD_INT 4
55565: PUSH
55566: EMPTY
55567: LIST
55568: LIST
55569: PUSH
55570: LD_INT 50
55572: PUSH
55573: EMPTY
55574: LIST
55575: PUSH
55576: LD_INT 3
55578: PUSH
55579: LD_INT 60
55581: PUSH
55582: EMPTY
55583: LIST
55584: PUSH
55585: EMPTY
55586: LIST
55587: LIST
55588: PUSH
55589: EMPTY
55590: LIST
55591: LIST
55592: LIST
55593: PPUSH
55594: CALL_OW 72
55598: PUSH
55599: LD_EXP 103
55603: PUSH
55604: LD_VAR 0 2
55608: ARRAY
55609: DIFF
55610: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
55611: LD_ADDR_VAR 0 9
55615: PUSH
55616: LD_EXP 99
55620: PUSH
55621: LD_VAR 0 2
55625: ARRAY
55626: PPUSH
55627: LD_INT 2
55629: PUSH
55630: LD_INT 30
55632: PUSH
55633: LD_INT 0
55635: PUSH
55636: EMPTY
55637: LIST
55638: LIST
55639: PUSH
55640: LD_INT 30
55642: PUSH
55643: LD_INT 1
55645: PUSH
55646: EMPTY
55647: LIST
55648: LIST
55649: PUSH
55650: EMPTY
55651: LIST
55652: LIST
55653: LIST
55654: PPUSH
55655: CALL_OW 72
55659: ST_TO_ADDR
// if not tmp or not dep then
55660: LD_VAR 0 8
55664: NOT
55665: PUSH
55666: LD_VAR 0 9
55670: NOT
55671: OR
55672: IFFALSE 55676
// continue ;
55674: GO 55461
// side := GetSide ( tmp [ 1 ] ) ;
55676: LD_ADDR_VAR 0 11
55680: PUSH
55681: LD_VAR 0 8
55685: PUSH
55686: LD_INT 1
55688: ARRAY
55689: PPUSH
55690: CALL_OW 255
55694: ST_TO_ADDR
// dep := dep [ 1 ] ;
55695: LD_ADDR_VAR 0 9
55699: PUSH
55700: LD_VAR 0 9
55704: PUSH
55705: LD_INT 1
55707: ARRAY
55708: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
55709: LD_ADDR_VAR 0 7
55713: PUSH
55714: LD_EXP 127
55718: PUSH
55719: LD_VAR 0 2
55723: ARRAY
55724: PPUSH
55725: LD_INT 22
55727: PUSH
55728: LD_INT 0
55730: PUSH
55731: EMPTY
55732: LIST
55733: LIST
55734: PUSH
55735: LD_INT 25
55737: PUSH
55738: LD_INT 12
55740: PUSH
55741: EMPTY
55742: LIST
55743: LIST
55744: PUSH
55745: EMPTY
55746: LIST
55747: LIST
55748: PPUSH
55749: CALL_OW 70
55753: PUSH
55754: LD_INT 22
55756: PUSH
55757: LD_INT 0
55759: PUSH
55760: EMPTY
55761: LIST
55762: LIST
55763: PUSH
55764: LD_INT 25
55766: PUSH
55767: LD_INT 12
55769: PUSH
55770: EMPTY
55771: LIST
55772: LIST
55773: PUSH
55774: LD_INT 91
55776: PUSH
55777: LD_VAR 0 9
55781: PUSH
55782: LD_INT 20
55784: PUSH
55785: EMPTY
55786: LIST
55787: LIST
55788: LIST
55789: PUSH
55790: EMPTY
55791: LIST
55792: LIST
55793: LIST
55794: PPUSH
55795: CALL_OW 69
55799: UNION
55800: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
55801: LD_ADDR_VAR 0 10
55805: PUSH
55806: LD_EXP 127
55810: PUSH
55811: LD_VAR 0 2
55815: ARRAY
55816: PPUSH
55817: LD_INT 81
55819: PUSH
55820: LD_VAR 0 11
55824: PUSH
55825: EMPTY
55826: LIST
55827: LIST
55828: PPUSH
55829: CALL_OW 70
55833: ST_TO_ADDR
// if not apes or danger_at_area then
55834: LD_VAR 0 7
55838: NOT
55839: PUSH
55840: LD_VAR 0 10
55844: OR
55845: IFFALSE 55895
// begin if mc_taming [ i ] then
55847: LD_EXP 130
55851: PUSH
55852: LD_VAR 0 2
55856: ARRAY
55857: IFFALSE 55893
// begin MC_Reset ( i , 121 ) ;
55859: LD_VAR 0 2
55863: PPUSH
55864: LD_INT 121
55866: PPUSH
55867: CALL 40832 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
55871: LD_ADDR_EXP 130
55875: PUSH
55876: LD_EXP 130
55880: PPUSH
55881: LD_VAR 0 2
55885: PPUSH
55886: EMPTY
55887: PPUSH
55888: CALL_OW 1
55892: ST_TO_ADDR
// end ; continue ;
55893: GO 55461
// end ; for j in tmp do
55895: LD_ADDR_VAR 0 3
55899: PUSH
55900: LD_VAR 0 8
55904: PUSH
55905: FOR_IN
55906: IFFALSE 56242
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
55908: LD_VAR 0 3
55912: PUSH
55913: LD_EXP 130
55917: PUSH
55918: LD_VAR 0 2
55922: ARRAY
55923: IN
55924: NOT
55925: PUSH
55926: LD_EXP 130
55930: PUSH
55931: LD_VAR 0 2
55935: ARRAY
55936: PUSH
55937: LD_INT 3
55939: LESS
55940: AND
55941: IFFALSE 55999
// begin SetTag ( j , 121 ) ;
55943: LD_VAR 0 3
55947: PPUSH
55948: LD_INT 121
55950: PPUSH
55951: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
55955: LD_ADDR_EXP 130
55959: PUSH
55960: LD_EXP 130
55964: PPUSH
55965: LD_VAR 0 2
55969: PUSH
55970: LD_EXP 130
55974: PUSH
55975: LD_VAR 0 2
55979: ARRAY
55980: PUSH
55981: LD_INT 1
55983: PLUS
55984: PUSH
55985: EMPTY
55986: LIST
55987: LIST
55988: PPUSH
55989: LD_VAR 0 3
55993: PPUSH
55994: CALL 72472 0 3
55998: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
55999: LD_VAR 0 3
56003: PUSH
56004: LD_EXP 130
56008: PUSH
56009: LD_VAR 0 2
56013: ARRAY
56014: IN
56015: IFFALSE 56240
// begin if GetClass ( j ) <> 4 then
56017: LD_VAR 0 3
56021: PPUSH
56022: CALL_OW 257
56026: PUSH
56027: LD_INT 4
56029: NONEQUAL
56030: IFFALSE 56083
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
56032: LD_ADDR_EXP 130
56036: PUSH
56037: LD_EXP 130
56041: PPUSH
56042: LD_VAR 0 2
56046: PPUSH
56047: LD_EXP 130
56051: PUSH
56052: LD_VAR 0 2
56056: ARRAY
56057: PUSH
56058: LD_VAR 0 3
56062: DIFF
56063: PPUSH
56064: CALL_OW 1
56068: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56069: LD_VAR 0 3
56073: PPUSH
56074: LD_INT 0
56076: PPUSH
56077: CALL_OW 109
// continue ;
56081: GO 55905
// end ; if IsInUnit ( j ) then
56083: LD_VAR 0 3
56087: PPUSH
56088: CALL_OW 310
56092: IFFALSE 56103
// ComExitBuilding ( j ) ;
56094: LD_VAR 0 3
56098: PPUSH
56099: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
56103: LD_ADDR_VAR 0 6
56107: PUSH
56108: LD_VAR 0 7
56112: PPUSH
56113: LD_VAR 0 3
56117: PPUSH
56118: CALL_OW 74
56122: ST_TO_ADDR
// if not ape then
56123: LD_VAR 0 6
56127: NOT
56128: IFFALSE 56132
// break ;
56130: GO 56242
// x := GetX ( ape ) ;
56132: LD_ADDR_VAR 0 4
56136: PUSH
56137: LD_VAR 0 6
56141: PPUSH
56142: CALL_OW 250
56146: ST_TO_ADDR
// y := GetY ( ape ) ;
56147: LD_ADDR_VAR 0 5
56151: PUSH
56152: LD_VAR 0 6
56156: PPUSH
56157: CALL_OW 251
56161: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
56162: LD_VAR 0 4
56166: PPUSH
56167: LD_VAR 0 5
56171: PPUSH
56172: CALL_OW 488
56176: NOT
56177: PUSH
56178: LD_VAR 0 11
56182: PPUSH
56183: LD_VAR 0 4
56187: PPUSH
56188: LD_VAR 0 5
56192: PPUSH
56193: LD_INT 20
56195: PPUSH
56196: CALL 73368 0 4
56200: PUSH
56201: LD_INT 4
56203: ARRAY
56204: OR
56205: IFFALSE 56209
// break ;
56207: GO 56242
// if not HasTask ( j ) then
56209: LD_VAR 0 3
56213: PPUSH
56214: CALL_OW 314
56218: NOT
56219: IFFALSE 56240
// ComTameXY ( j , x , y ) ;
56221: LD_VAR 0 3
56225: PPUSH
56226: LD_VAR 0 4
56230: PPUSH
56231: LD_VAR 0 5
56235: PPUSH
56236: CALL_OW 131
// end ; end ;
56240: GO 55905
56242: POP
56243: POP
// end ;
56244: GO 55461
56246: POP
56247: POP
// end ;
56248: LD_VAR 0 1
56252: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
56253: LD_INT 0
56255: PPUSH
56256: PPUSH
56257: PPUSH
56258: PPUSH
56259: PPUSH
56260: PPUSH
56261: PPUSH
56262: PPUSH
// if not mc_bases then
56263: LD_EXP 99
56267: NOT
56268: IFFALSE 56272
// exit ;
56270: GO 56898
// for i = 1 to mc_bases do
56272: LD_ADDR_VAR 0 2
56276: PUSH
56277: DOUBLE
56278: LD_INT 1
56280: DEC
56281: ST_TO_ADDR
56282: LD_EXP 99
56286: PUSH
56287: FOR_TO
56288: IFFALSE 56896
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
56290: LD_EXP 128
56294: PUSH
56295: LD_VAR 0 2
56299: ARRAY
56300: NOT
56301: PUSH
56302: LD_EXP 128
56306: PUSH
56307: LD_VAR 0 2
56311: ARRAY
56312: PPUSH
56313: LD_INT 25
56315: PUSH
56316: LD_INT 12
56318: PUSH
56319: EMPTY
56320: LIST
56321: LIST
56322: PPUSH
56323: CALL_OW 72
56327: NOT
56328: OR
56329: IFFALSE 56333
// continue ;
56331: GO 56287
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
56333: LD_ADDR_VAR 0 5
56337: PUSH
56338: LD_EXP 128
56342: PUSH
56343: LD_VAR 0 2
56347: ARRAY
56348: PUSH
56349: LD_INT 1
56351: ARRAY
56352: PPUSH
56353: CALL_OW 255
56357: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
56358: LD_VAR 0 5
56362: PPUSH
56363: LD_INT 2
56365: PPUSH
56366: CALL_OW 325
56370: IFFALSE 56623
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
56372: LD_ADDR_VAR 0 4
56376: PUSH
56377: LD_EXP 128
56381: PUSH
56382: LD_VAR 0 2
56386: ARRAY
56387: PPUSH
56388: LD_INT 25
56390: PUSH
56391: LD_INT 16
56393: PUSH
56394: EMPTY
56395: LIST
56396: LIST
56397: PPUSH
56398: CALL_OW 72
56402: ST_TO_ADDR
// if tmp < 6 then
56403: LD_VAR 0 4
56407: PUSH
56408: LD_INT 6
56410: LESS
56411: IFFALSE 56623
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56413: LD_ADDR_VAR 0 6
56417: PUSH
56418: LD_EXP 99
56422: PUSH
56423: LD_VAR 0 2
56427: ARRAY
56428: PPUSH
56429: LD_INT 2
56431: PUSH
56432: LD_INT 30
56434: PUSH
56435: LD_INT 0
56437: PUSH
56438: EMPTY
56439: LIST
56440: LIST
56441: PUSH
56442: LD_INT 30
56444: PUSH
56445: LD_INT 1
56447: PUSH
56448: EMPTY
56449: LIST
56450: LIST
56451: PUSH
56452: EMPTY
56453: LIST
56454: LIST
56455: LIST
56456: PPUSH
56457: CALL_OW 72
56461: ST_TO_ADDR
// if depot then
56462: LD_VAR 0 6
56466: IFFALSE 56623
// begin selected := 0 ;
56468: LD_ADDR_VAR 0 7
56472: PUSH
56473: LD_INT 0
56475: ST_TO_ADDR
// for j in depot do
56476: LD_ADDR_VAR 0 3
56480: PUSH
56481: LD_VAR 0 6
56485: PUSH
56486: FOR_IN
56487: IFFALSE 56518
// begin if UnitsInside ( j ) < 6 then
56489: LD_VAR 0 3
56493: PPUSH
56494: CALL_OW 313
56498: PUSH
56499: LD_INT 6
56501: LESS
56502: IFFALSE 56516
// begin selected := j ;
56504: LD_ADDR_VAR 0 7
56508: PUSH
56509: LD_VAR 0 3
56513: ST_TO_ADDR
// break ;
56514: GO 56518
// end ; end ;
56516: GO 56486
56518: POP
56519: POP
// if selected then
56520: LD_VAR 0 7
56524: IFFALSE 56623
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
56526: LD_ADDR_VAR 0 3
56530: PUSH
56531: LD_EXP 128
56535: PUSH
56536: LD_VAR 0 2
56540: ARRAY
56541: PPUSH
56542: LD_INT 25
56544: PUSH
56545: LD_INT 12
56547: PUSH
56548: EMPTY
56549: LIST
56550: LIST
56551: PPUSH
56552: CALL_OW 72
56556: PUSH
56557: FOR_IN
56558: IFFALSE 56621
// if not HasTask ( j ) then
56560: LD_VAR 0 3
56564: PPUSH
56565: CALL_OW 314
56569: NOT
56570: IFFALSE 56619
// begin if not IsInUnit ( j ) then
56572: LD_VAR 0 3
56576: PPUSH
56577: CALL_OW 310
56581: NOT
56582: IFFALSE 56598
// ComEnterUnit ( j , selected ) ;
56584: LD_VAR 0 3
56588: PPUSH
56589: LD_VAR 0 7
56593: PPUSH
56594: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
56598: LD_VAR 0 3
56602: PPUSH
56603: LD_INT 16
56605: PPUSH
56606: CALL_OW 183
// AddComExitBuilding ( j ) ;
56610: LD_VAR 0 3
56614: PPUSH
56615: CALL_OW 182
// end ;
56619: GO 56557
56621: POP
56622: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
56623: LD_VAR 0 5
56627: PPUSH
56628: LD_INT 11
56630: PPUSH
56631: CALL_OW 325
56635: IFFALSE 56894
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
56637: LD_ADDR_VAR 0 4
56641: PUSH
56642: LD_EXP 128
56646: PUSH
56647: LD_VAR 0 2
56651: ARRAY
56652: PPUSH
56653: LD_INT 25
56655: PUSH
56656: LD_INT 16
56658: PUSH
56659: EMPTY
56660: LIST
56661: LIST
56662: PPUSH
56663: CALL_OW 72
56667: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
56668: LD_VAR 0 4
56672: PUSH
56673: LD_INT 6
56675: GREATEREQUAL
56676: PUSH
56677: LD_VAR 0 5
56681: PPUSH
56682: LD_INT 2
56684: PPUSH
56685: CALL_OW 325
56689: NOT
56690: OR
56691: IFFALSE 56894
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56693: LD_ADDR_VAR 0 8
56697: PUSH
56698: LD_EXP 99
56702: PUSH
56703: LD_VAR 0 2
56707: ARRAY
56708: PPUSH
56709: LD_INT 2
56711: PUSH
56712: LD_INT 30
56714: PUSH
56715: LD_INT 4
56717: PUSH
56718: EMPTY
56719: LIST
56720: LIST
56721: PUSH
56722: LD_INT 30
56724: PUSH
56725: LD_INT 5
56727: PUSH
56728: EMPTY
56729: LIST
56730: LIST
56731: PUSH
56732: EMPTY
56733: LIST
56734: LIST
56735: LIST
56736: PPUSH
56737: CALL_OW 72
56741: ST_TO_ADDR
// if barracks then
56742: LD_VAR 0 8
56746: IFFALSE 56894
// begin selected := 0 ;
56748: LD_ADDR_VAR 0 7
56752: PUSH
56753: LD_INT 0
56755: ST_TO_ADDR
// for j in barracks do
56756: LD_ADDR_VAR 0 3
56760: PUSH
56761: LD_VAR 0 8
56765: PUSH
56766: FOR_IN
56767: IFFALSE 56798
// begin if UnitsInside ( j ) < 6 then
56769: LD_VAR 0 3
56773: PPUSH
56774: CALL_OW 313
56778: PUSH
56779: LD_INT 6
56781: LESS
56782: IFFALSE 56796
// begin selected := j ;
56784: LD_ADDR_VAR 0 7
56788: PUSH
56789: LD_VAR 0 3
56793: ST_TO_ADDR
// break ;
56794: GO 56798
// end ; end ;
56796: GO 56766
56798: POP
56799: POP
// if selected then
56800: LD_VAR 0 7
56804: IFFALSE 56894
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
56806: LD_ADDR_VAR 0 3
56810: PUSH
56811: LD_EXP 128
56815: PUSH
56816: LD_VAR 0 2
56820: ARRAY
56821: PPUSH
56822: LD_INT 25
56824: PUSH
56825: LD_INT 12
56827: PUSH
56828: EMPTY
56829: LIST
56830: LIST
56831: PPUSH
56832: CALL_OW 72
56836: PUSH
56837: FOR_IN
56838: IFFALSE 56892
// if not IsInUnit ( j ) and not HasTask ( j ) then
56840: LD_VAR 0 3
56844: PPUSH
56845: CALL_OW 310
56849: NOT
56850: PUSH
56851: LD_VAR 0 3
56855: PPUSH
56856: CALL_OW 314
56860: NOT
56861: AND
56862: IFFALSE 56890
// begin ComEnterUnit ( j , selected ) ;
56864: LD_VAR 0 3
56868: PPUSH
56869: LD_VAR 0 7
56873: PPUSH
56874: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
56878: LD_VAR 0 3
56882: PPUSH
56883: LD_INT 15
56885: PPUSH
56886: CALL_OW 183
// end ;
56890: GO 56837
56892: POP
56893: POP
// end ; end ; end ; end ; end ;
56894: GO 56287
56896: POP
56897: POP
// end ;
56898: LD_VAR 0 1
56902: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
56903: LD_INT 0
56905: PPUSH
56906: PPUSH
56907: PPUSH
56908: PPUSH
// if not mc_bases then
56909: LD_EXP 99
56913: NOT
56914: IFFALSE 56918
// exit ;
56916: GO 57096
// for i = 1 to mc_bases do
56918: LD_ADDR_VAR 0 2
56922: PUSH
56923: DOUBLE
56924: LD_INT 1
56926: DEC
56927: ST_TO_ADDR
56928: LD_EXP 99
56932: PUSH
56933: FOR_TO
56934: IFFALSE 57094
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
56936: LD_ADDR_VAR 0 4
56940: PUSH
56941: LD_EXP 99
56945: PUSH
56946: LD_VAR 0 2
56950: ARRAY
56951: PPUSH
56952: LD_INT 25
56954: PUSH
56955: LD_INT 9
56957: PUSH
56958: EMPTY
56959: LIST
56960: LIST
56961: PPUSH
56962: CALL_OW 72
56966: ST_TO_ADDR
// if not tmp then
56967: LD_VAR 0 4
56971: NOT
56972: IFFALSE 56976
// continue ;
56974: GO 56933
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
56976: LD_EXP 125
56980: PUSH
56981: LD_VAR 0 2
56985: ARRAY
56986: PPUSH
56987: LD_INT 29
56989: PPUSH
56990: CALL_OW 325
56994: NOT
56995: PUSH
56996: LD_EXP 125
57000: PUSH
57001: LD_VAR 0 2
57005: ARRAY
57006: PPUSH
57007: LD_INT 28
57009: PPUSH
57010: CALL_OW 325
57014: NOT
57015: AND
57016: IFFALSE 57020
// continue ;
57018: GO 56933
// for j in tmp do
57020: LD_ADDR_VAR 0 3
57024: PUSH
57025: LD_VAR 0 4
57029: PUSH
57030: FOR_IN
57031: IFFALSE 57090
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
57033: LD_VAR 0 3
57037: PUSH
57038: LD_EXP 102
57042: PUSH
57043: LD_VAR 0 2
57047: ARRAY
57048: PUSH
57049: LD_INT 1
57051: ARRAY
57052: IN
57053: NOT
57054: PUSH
57055: LD_VAR 0 3
57059: PUSH
57060: LD_EXP 102
57064: PUSH
57065: LD_VAR 0 2
57069: ARRAY
57070: PUSH
57071: LD_INT 2
57073: ARRAY
57074: IN
57075: NOT
57076: AND
57077: IFFALSE 57088
// ComSpaceTimeShoot ( j ) ;
57079: LD_VAR 0 3
57083: PPUSH
57084: CALL 68282 0 1
57088: GO 57030
57090: POP
57091: POP
// end ;
57092: GO 56933
57094: POP
57095: POP
// end ;
57096: LD_VAR 0 1
57100: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
57101: LD_INT 0
57103: PPUSH
57104: PPUSH
57105: PPUSH
57106: PPUSH
57107: PPUSH
57108: PPUSH
57109: PPUSH
57110: PPUSH
57111: PPUSH
// if not mc_bases then
57112: LD_EXP 99
57116: NOT
57117: IFFALSE 57121
// exit ;
57119: GO 57743
// for i = 1 to mc_bases do
57121: LD_ADDR_VAR 0 2
57125: PUSH
57126: DOUBLE
57127: LD_INT 1
57129: DEC
57130: ST_TO_ADDR
57131: LD_EXP 99
57135: PUSH
57136: FOR_TO
57137: IFFALSE 57741
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
57139: LD_EXP 134
57143: PUSH
57144: LD_VAR 0 2
57148: ARRAY
57149: NOT
57150: PUSH
57151: LD_INT 38
57153: PPUSH
57154: LD_EXP 125
57158: PUSH
57159: LD_VAR 0 2
57163: ARRAY
57164: PPUSH
57165: CALL_OW 321
57169: PUSH
57170: LD_INT 2
57172: NONEQUAL
57173: OR
57174: IFFALSE 57178
// continue ;
57176: GO 57136
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
57178: LD_ADDR_VAR 0 8
57182: PUSH
57183: LD_EXP 99
57187: PUSH
57188: LD_VAR 0 2
57192: ARRAY
57193: PPUSH
57194: LD_INT 30
57196: PUSH
57197: LD_INT 34
57199: PUSH
57200: EMPTY
57201: LIST
57202: LIST
57203: PPUSH
57204: CALL_OW 72
57208: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
57209: LD_ADDR_VAR 0 9
57213: PUSH
57214: LD_EXP 99
57218: PUSH
57219: LD_VAR 0 2
57223: ARRAY
57224: PPUSH
57225: LD_INT 25
57227: PUSH
57228: LD_INT 4
57230: PUSH
57231: EMPTY
57232: LIST
57233: LIST
57234: PPUSH
57235: CALL_OW 72
57239: PPUSH
57240: LD_INT 0
57242: PPUSH
57243: CALL 102358 0 2
57247: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
57248: LD_VAR 0 9
57252: NOT
57253: PUSH
57254: LD_VAR 0 8
57258: NOT
57259: OR
57260: PUSH
57261: LD_EXP 99
57265: PUSH
57266: LD_VAR 0 2
57270: ARRAY
57271: PPUSH
57272: LD_INT 124
57274: PPUSH
57275: CALL 102358 0 2
57279: OR
57280: IFFALSE 57284
// continue ;
57282: GO 57136
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
57284: LD_EXP 135
57288: PUSH
57289: LD_VAR 0 2
57293: ARRAY
57294: PUSH
57295: LD_EXP 134
57299: PUSH
57300: LD_VAR 0 2
57304: ARRAY
57305: LESS
57306: PUSH
57307: LD_EXP 135
57311: PUSH
57312: LD_VAR 0 2
57316: ARRAY
57317: PUSH
57318: LD_VAR 0 8
57322: LESS
57323: AND
57324: IFFALSE 57739
// begin tmp := sci [ 1 ] ;
57326: LD_ADDR_VAR 0 7
57330: PUSH
57331: LD_VAR 0 9
57335: PUSH
57336: LD_INT 1
57338: ARRAY
57339: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
57340: LD_VAR 0 7
57344: PPUSH
57345: LD_INT 124
57347: PPUSH
57348: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
57352: LD_ADDR_VAR 0 3
57356: PUSH
57357: DOUBLE
57358: LD_EXP 134
57362: PUSH
57363: LD_VAR 0 2
57367: ARRAY
57368: INC
57369: ST_TO_ADDR
57370: LD_EXP 134
57374: PUSH
57375: LD_VAR 0 2
57379: ARRAY
57380: PUSH
57381: FOR_DOWNTO
57382: IFFALSE 57725
// begin if IsInUnit ( tmp ) then
57384: LD_VAR 0 7
57388: PPUSH
57389: CALL_OW 310
57393: IFFALSE 57404
// ComExitBuilding ( tmp ) ;
57395: LD_VAR 0 7
57399: PPUSH
57400: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
57404: LD_INT 35
57406: PPUSH
57407: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
57411: LD_VAR 0 7
57415: PPUSH
57416: CALL_OW 310
57420: NOT
57421: PUSH
57422: LD_VAR 0 7
57426: PPUSH
57427: CALL_OW 314
57431: NOT
57432: AND
57433: IFFALSE 57404
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
57435: LD_ADDR_VAR 0 6
57439: PUSH
57440: LD_VAR 0 7
57444: PPUSH
57445: CALL_OW 250
57449: PUSH
57450: LD_VAR 0 7
57454: PPUSH
57455: CALL_OW 251
57459: PUSH
57460: EMPTY
57461: LIST
57462: LIST
57463: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
57464: LD_INT 35
57466: PPUSH
57467: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
57471: LD_ADDR_VAR 0 4
57475: PUSH
57476: LD_EXP 134
57480: PUSH
57481: LD_VAR 0 2
57485: ARRAY
57486: PUSH
57487: LD_VAR 0 3
57491: ARRAY
57492: PUSH
57493: LD_INT 1
57495: ARRAY
57496: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
57497: LD_ADDR_VAR 0 5
57501: PUSH
57502: LD_EXP 134
57506: PUSH
57507: LD_VAR 0 2
57511: ARRAY
57512: PUSH
57513: LD_VAR 0 3
57517: ARRAY
57518: PUSH
57519: LD_INT 2
57521: ARRAY
57522: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
57523: LD_VAR 0 7
57527: PPUSH
57528: LD_INT 10
57530: PPUSH
57531: CALL 75069 0 2
57535: PUSH
57536: LD_INT 4
57538: ARRAY
57539: IFFALSE 57577
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
57541: LD_VAR 0 7
57545: PPUSH
57546: LD_VAR 0 6
57550: PUSH
57551: LD_INT 1
57553: ARRAY
57554: PPUSH
57555: LD_VAR 0 6
57559: PUSH
57560: LD_INT 2
57562: ARRAY
57563: PPUSH
57564: CALL_OW 111
// wait ( 0 0$10 ) ;
57568: LD_INT 350
57570: PPUSH
57571: CALL_OW 67
// end else
57575: GO 57603
// begin ComMoveXY ( tmp , x , y ) ;
57577: LD_VAR 0 7
57581: PPUSH
57582: LD_VAR 0 4
57586: PPUSH
57587: LD_VAR 0 5
57591: PPUSH
57592: CALL_OW 111
// wait ( 0 0$3 ) ;
57596: LD_INT 105
57598: PPUSH
57599: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
57603: LD_VAR 0 7
57607: PPUSH
57608: LD_VAR 0 4
57612: PPUSH
57613: LD_VAR 0 5
57617: PPUSH
57618: CALL_OW 307
57622: IFFALSE 57464
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
57624: LD_VAR 0 7
57628: PPUSH
57629: LD_VAR 0 4
57633: PPUSH
57634: LD_VAR 0 5
57638: PPUSH
57639: LD_VAR 0 8
57643: PUSH
57644: LD_VAR 0 3
57648: ARRAY
57649: PPUSH
57650: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
57654: LD_INT 35
57656: PPUSH
57657: CALL_OW 67
// until not HasTask ( tmp ) ;
57661: LD_VAR 0 7
57665: PPUSH
57666: CALL_OW 314
57670: NOT
57671: IFFALSE 57654
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
57673: LD_ADDR_EXP 135
57677: PUSH
57678: LD_EXP 135
57682: PPUSH
57683: LD_VAR 0 2
57687: PUSH
57688: LD_EXP 135
57692: PUSH
57693: LD_VAR 0 2
57697: ARRAY
57698: PUSH
57699: LD_INT 1
57701: PLUS
57702: PUSH
57703: EMPTY
57704: LIST
57705: LIST
57706: PPUSH
57707: LD_VAR 0 8
57711: PUSH
57712: LD_VAR 0 3
57716: ARRAY
57717: PPUSH
57718: CALL 72472 0 3
57722: ST_TO_ADDR
// end ;
57723: GO 57381
57725: POP
57726: POP
// MC_Reset ( i , 124 ) ;
57727: LD_VAR 0 2
57731: PPUSH
57732: LD_INT 124
57734: PPUSH
57735: CALL 40832 0 2
// end ; end ;
57739: GO 57136
57741: POP
57742: POP
// end ;
57743: LD_VAR 0 1
57747: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
57748: LD_INT 0
57750: PPUSH
57751: PPUSH
57752: PPUSH
// if not mc_bases then
57753: LD_EXP 99
57757: NOT
57758: IFFALSE 57762
// exit ;
57760: GO 58368
// for i = 1 to mc_bases do
57762: LD_ADDR_VAR 0 2
57766: PUSH
57767: DOUBLE
57768: LD_INT 1
57770: DEC
57771: ST_TO_ADDR
57772: LD_EXP 99
57776: PUSH
57777: FOR_TO
57778: IFFALSE 58366
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
57780: LD_ADDR_VAR 0 3
57784: PUSH
57785: LD_EXP 99
57789: PUSH
57790: LD_VAR 0 2
57794: ARRAY
57795: PPUSH
57796: LD_INT 25
57798: PUSH
57799: LD_INT 4
57801: PUSH
57802: EMPTY
57803: LIST
57804: LIST
57805: PPUSH
57806: CALL_OW 72
57810: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
57811: LD_VAR 0 3
57815: NOT
57816: PUSH
57817: LD_EXP 136
57821: PUSH
57822: LD_VAR 0 2
57826: ARRAY
57827: NOT
57828: OR
57829: PUSH
57830: LD_EXP 99
57834: PUSH
57835: LD_VAR 0 2
57839: ARRAY
57840: PPUSH
57841: LD_INT 2
57843: PUSH
57844: LD_INT 30
57846: PUSH
57847: LD_INT 0
57849: PUSH
57850: EMPTY
57851: LIST
57852: LIST
57853: PUSH
57854: LD_INT 30
57856: PUSH
57857: LD_INT 1
57859: PUSH
57860: EMPTY
57861: LIST
57862: LIST
57863: PUSH
57864: EMPTY
57865: LIST
57866: LIST
57867: LIST
57868: PPUSH
57869: CALL_OW 72
57873: NOT
57874: OR
57875: IFFALSE 57925
// begin if mc_deposits_finder [ i ] then
57877: LD_EXP 137
57881: PUSH
57882: LD_VAR 0 2
57886: ARRAY
57887: IFFALSE 57923
// begin MC_Reset ( i , 125 ) ;
57889: LD_VAR 0 2
57893: PPUSH
57894: LD_INT 125
57896: PPUSH
57897: CALL 40832 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
57901: LD_ADDR_EXP 137
57905: PUSH
57906: LD_EXP 137
57910: PPUSH
57911: LD_VAR 0 2
57915: PPUSH
57916: EMPTY
57917: PPUSH
57918: CALL_OW 1
57922: ST_TO_ADDR
// end ; continue ;
57923: GO 57777
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
57925: LD_EXP 136
57929: PUSH
57930: LD_VAR 0 2
57934: ARRAY
57935: PUSH
57936: LD_INT 1
57938: ARRAY
57939: PUSH
57940: LD_INT 3
57942: ARRAY
57943: PUSH
57944: LD_INT 1
57946: EQUAL
57947: PUSH
57948: LD_INT 20
57950: PPUSH
57951: LD_EXP 125
57955: PUSH
57956: LD_VAR 0 2
57960: ARRAY
57961: PPUSH
57962: CALL_OW 321
57966: PUSH
57967: LD_INT 2
57969: NONEQUAL
57970: AND
57971: IFFALSE 58021
// begin if mc_deposits_finder [ i ] then
57973: LD_EXP 137
57977: PUSH
57978: LD_VAR 0 2
57982: ARRAY
57983: IFFALSE 58019
// begin MC_Reset ( i , 125 ) ;
57985: LD_VAR 0 2
57989: PPUSH
57990: LD_INT 125
57992: PPUSH
57993: CALL 40832 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
57997: LD_ADDR_EXP 137
58001: PUSH
58002: LD_EXP 137
58006: PPUSH
58007: LD_VAR 0 2
58011: PPUSH
58012: EMPTY
58013: PPUSH
58014: CALL_OW 1
58018: ST_TO_ADDR
// end ; continue ;
58019: GO 57777
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
58021: LD_EXP 136
58025: PUSH
58026: LD_VAR 0 2
58030: ARRAY
58031: PUSH
58032: LD_INT 1
58034: ARRAY
58035: PUSH
58036: LD_INT 1
58038: ARRAY
58039: PPUSH
58040: LD_EXP 136
58044: PUSH
58045: LD_VAR 0 2
58049: ARRAY
58050: PUSH
58051: LD_INT 1
58053: ARRAY
58054: PUSH
58055: LD_INT 2
58057: ARRAY
58058: PPUSH
58059: LD_EXP 125
58063: PUSH
58064: LD_VAR 0 2
58068: ARRAY
58069: PPUSH
58070: CALL_OW 440
58074: IFFALSE 58117
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
58076: LD_ADDR_EXP 136
58080: PUSH
58081: LD_EXP 136
58085: PPUSH
58086: LD_VAR 0 2
58090: PPUSH
58091: LD_EXP 136
58095: PUSH
58096: LD_VAR 0 2
58100: ARRAY
58101: PPUSH
58102: LD_INT 1
58104: PPUSH
58105: CALL_OW 3
58109: PPUSH
58110: CALL_OW 1
58114: ST_TO_ADDR
58115: GO 58364
// begin if not mc_deposits_finder [ i ] then
58117: LD_EXP 137
58121: PUSH
58122: LD_VAR 0 2
58126: ARRAY
58127: NOT
58128: IFFALSE 58180
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
58130: LD_ADDR_EXP 137
58134: PUSH
58135: LD_EXP 137
58139: PPUSH
58140: LD_VAR 0 2
58144: PPUSH
58145: LD_VAR 0 3
58149: PUSH
58150: LD_INT 1
58152: ARRAY
58153: PUSH
58154: EMPTY
58155: LIST
58156: PPUSH
58157: CALL_OW 1
58161: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
58162: LD_VAR 0 3
58166: PUSH
58167: LD_INT 1
58169: ARRAY
58170: PPUSH
58171: LD_INT 125
58173: PPUSH
58174: CALL_OW 109
// end else
58178: GO 58364
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
58180: LD_EXP 137
58184: PUSH
58185: LD_VAR 0 2
58189: ARRAY
58190: PUSH
58191: LD_INT 1
58193: ARRAY
58194: PPUSH
58195: CALL_OW 310
58199: IFFALSE 58222
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
58201: LD_EXP 137
58205: PUSH
58206: LD_VAR 0 2
58210: ARRAY
58211: PUSH
58212: LD_INT 1
58214: ARRAY
58215: PPUSH
58216: CALL_OW 122
58220: GO 58364
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
58222: LD_EXP 137
58226: PUSH
58227: LD_VAR 0 2
58231: ARRAY
58232: PUSH
58233: LD_INT 1
58235: ARRAY
58236: PPUSH
58237: CALL_OW 314
58241: NOT
58242: PUSH
58243: LD_EXP 137
58247: PUSH
58248: LD_VAR 0 2
58252: ARRAY
58253: PUSH
58254: LD_INT 1
58256: ARRAY
58257: PPUSH
58258: LD_EXP 136
58262: PUSH
58263: LD_VAR 0 2
58267: ARRAY
58268: PUSH
58269: LD_INT 1
58271: ARRAY
58272: PUSH
58273: LD_INT 1
58275: ARRAY
58276: PPUSH
58277: LD_EXP 136
58281: PUSH
58282: LD_VAR 0 2
58286: ARRAY
58287: PUSH
58288: LD_INT 1
58290: ARRAY
58291: PUSH
58292: LD_INT 2
58294: ARRAY
58295: PPUSH
58296: CALL_OW 297
58300: PUSH
58301: LD_INT 6
58303: GREATER
58304: AND
58305: IFFALSE 58364
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
58307: LD_EXP 137
58311: PUSH
58312: LD_VAR 0 2
58316: ARRAY
58317: PUSH
58318: LD_INT 1
58320: ARRAY
58321: PPUSH
58322: LD_EXP 136
58326: PUSH
58327: LD_VAR 0 2
58331: ARRAY
58332: PUSH
58333: LD_INT 1
58335: ARRAY
58336: PUSH
58337: LD_INT 1
58339: ARRAY
58340: PPUSH
58341: LD_EXP 136
58345: PUSH
58346: LD_VAR 0 2
58350: ARRAY
58351: PUSH
58352: LD_INT 1
58354: ARRAY
58355: PUSH
58356: LD_INT 2
58358: ARRAY
58359: PPUSH
58360: CALL_OW 111
// end ; end ; end ;
58364: GO 57777
58366: POP
58367: POP
// end ;
58368: LD_VAR 0 1
58372: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
58373: LD_INT 0
58375: PPUSH
58376: PPUSH
58377: PPUSH
58378: PPUSH
58379: PPUSH
58380: PPUSH
58381: PPUSH
58382: PPUSH
58383: PPUSH
58384: PPUSH
58385: PPUSH
// if not mc_bases then
58386: LD_EXP 99
58390: NOT
58391: IFFALSE 58395
// exit ;
58393: GO 59335
// for i = 1 to mc_bases do
58395: LD_ADDR_VAR 0 2
58399: PUSH
58400: DOUBLE
58401: LD_INT 1
58403: DEC
58404: ST_TO_ADDR
58405: LD_EXP 99
58409: PUSH
58410: FOR_TO
58411: IFFALSE 59333
// begin if not mc_bases [ i ] or mc_scan [ i ] then
58413: LD_EXP 99
58417: PUSH
58418: LD_VAR 0 2
58422: ARRAY
58423: NOT
58424: PUSH
58425: LD_EXP 122
58429: PUSH
58430: LD_VAR 0 2
58434: ARRAY
58435: OR
58436: IFFALSE 58440
// continue ;
58438: GO 58410
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
58440: LD_ADDR_VAR 0 7
58444: PUSH
58445: LD_EXP 99
58449: PUSH
58450: LD_VAR 0 2
58454: ARRAY
58455: PUSH
58456: LD_INT 1
58458: ARRAY
58459: PPUSH
58460: CALL_OW 248
58464: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
58465: LD_VAR 0 7
58469: PUSH
58470: LD_INT 3
58472: EQUAL
58473: PUSH
58474: LD_EXP 118
58478: PUSH
58479: LD_VAR 0 2
58483: ARRAY
58484: PUSH
58485: LD_EXP 121
58489: PUSH
58490: LD_VAR 0 2
58494: ARRAY
58495: UNION
58496: PPUSH
58497: LD_INT 33
58499: PUSH
58500: LD_INT 2
58502: PUSH
58503: EMPTY
58504: LIST
58505: LIST
58506: PPUSH
58507: CALL_OW 72
58511: NOT
58512: OR
58513: IFFALSE 58517
// continue ;
58515: GO 58410
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
58517: LD_ADDR_VAR 0 9
58521: PUSH
58522: LD_EXP 99
58526: PUSH
58527: LD_VAR 0 2
58531: ARRAY
58532: PPUSH
58533: LD_INT 30
58535: PUSH
58536: LD_INT 36
58538: PUSH
58539: EMPTY
58540: LIST
58541: LIST
58542: PPUSH
58543: CALL_OW 72
58547: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
58548: LD_ADDR_VAR 0 10
58552: PUSH
58553: LD_EXP 118
58557: PUSH
58558: LD_VAR 0 2
58562: ARRAY
58563: PPUSH
58564: LD_INT 34
58566: PUSH
58567: LD_INT 31
58569: PUSH
58570: EMPTY
58571: LIST
58572: LIST
58573: PPUSH
58574: CALL_OW 72
58578: ST_TO_ADDR
// if not cts and not mcts then
58579: LD_VAR 0 9
58583: NOT
58584: PUSH
58585: LD_VAR 0 10
58589: NOT
58590: AND
58591: IFFALSE 58595
// continue ;
58593: GO 58410
// x := cts ;
58595: LD_ADDR_VAR 0 11
58599: PUSH
58600: LD_VAR 0 9
58604: ST_TO_ADDR
// if not x then
58605: LD_VAR 0 11
58609: NOT
58610: IFFALSE 58622
// x := mcts ;
58612: LD_ADDR_VAR 0 11
58616: PUSH
58617: LD_VAR 0 10
58621: ST_TO_ADDR
// if not x then
58622: LD_VAR 0 11
58626: NOT
58627: IFFALSE 58631
// continue ;
58629: GO 58410
// if mc_remote_driver [ i ] then
58631: LD_EXP 139
58635: PUSH
58636: LD_VAR 0 2
58640: ARRAY
58641: IFFALSE 59028
// for j in mc_remote_driver [ i ] do
58643: LD_ADDR_VAR 0 3
58647: PUSH
58648: LD_EXP 139
58652: PUSH
58653: LD_VAR 0 2
58657: ARRAY
58658: PUSH
58659: FOR_IN
58660: IFFALSE 59026
// begin if GetClass ( j ) <> 3 then
58662: LD_VAR 0 3
58666: PPUSH
58667: CALL_OW 257
58671: PUSH
58672: LD_INT 3
58674: NONEQUAL
58675: IFFALSE 58728
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
58677: LD_ADDR_EXP 139
58681: PUSH
58682: LD_EXP 139
58686: PPUSH
58687: LD_VAR 0 2
58691: PPUSH
58692: LD_EXP 139
58696: PUSH
58697: LD_VAR 0 2
58701: ARRAY
58702: PUSH
58703: LD_VAR 0 3
58707: DIFF
58708: PPUSH
58709: CALL_OW 1
58713: ST_TO_ADDR
// SetTag ( j , 0 ) ;
58714: LD_VAR 0 3
58718: PPUSH
58719: LD_INT 0
58721: PPUSH
58722: CALL_OW 109
// continue ;
58726: GO 58659
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
58728: LD_EXP 118
58732: PUSH
58733: LD_VAR 0 2
58737: ARRAY
58738: PPUSH
58739: LD_INT 34
58741: PUSH
58742: LD_INT 31
58744: PUSH
58745: EMPTY
58746: LIST
58747: LIST
58748: PUSH
58749: LD_INT 58
58751: PUSH
58752: EMPTY
58753: LIST
58754: PUSH
58755: EMPTY
58756: LIST
58757: LIST
58758: PPUSH
58759: CALL_OW 72
58763: PUSH
58764: LD_VAR 0 3
58768: PPUSH
58769: CALL 102393 0 1
58773: NOT
58774: AND
58775: IFFALSE 58846
// begin if IsInUnit ( j ) then
58777: LD_VAR 0 3
58781: PPUSH
58782: CALL_OW 310
58786: IFFALSE 58797
// ComExitBuilding ( j ) ;
58788: LD_VAR 0 3
58792: PPUSH
58793: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
58797: LD_VAR 0 3
58801: PPUSH
58802: LD_EXP 118
58806: PUSH
58807: LD_VAR 0 2
58811: ARRAY
58812: PPUSH
58813: LD_INT 34
58815: PUSH
58816: LD_INT 31
58818: PUSH
58819: EMPTY
58820: LIST
58821: LIST
58822: PUSH
58823: LD_INT 58
58825: PUSH
58826: EMPTY
58827: LIST
58828: PUSH
58829: EMPTY
58830: LIST
58831: LIST
58832: PPUSH
58833: CALL_OW 72
58837: PUSH
58838: LD_INT 1
58840: ARRAY
58841: PPUSH
58842: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
58846: LD_VAR 0 3
58850: PPUSH
58851: CALL_OW 310
58855: NOT
58856: PUSH
58857: LD_VAR 0 3
58861: PPUSH
58862: CALL_OW 310
58866: PPUSH
58867: CALL_OW 266
58871: PUSH
58872: LD_INT 36
58874: NONEQUAL
58875: PUSH
58876: LD_VAR 0 3
58880: PPUSH
58881: CALL 102393 0 1
58885: NOT
58886: AND
58887: OR
58888: IFFALSE 59024
// begin if IsInUnit ( j ) then
58890: LD_VAR 0 3
58894: PPUSH
58895: CALL_OW 310
58899: IFFALSE 58910
// ComExitBuilding ( j ) ;
58901: LD_VAR 0 3
58905: PPUSH
58906: CALL_OW 122
// ct := 0 ;
58910: LD_ADDR_VAR 0 8
58914: PUSH
58915: LD_INT 0
58917: ST_TO_ADDR
// for k in x do
58918: LD_ADDR_VAR 0 4
58922: PUSH
58923: LD_VAR 0 11
58927: PUSH
58928: FOR_IN
58929: IFFALSE 59002
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
58931: LD_VAR 0 4
58935: PPUSH
58936: CALL_OW 264
58940: PUSH
58941: LD_INT 31
58943: EQUAL
58944: PUSH
58945: LD_VAR 0 4
58949: PPUSH
58950: CALL_OW 311
58954: NOT
58955: AND
58956: PUSH
58957: LD_VAR 0 4
58961: PPUSH
58962: CALL_OW 266
58966: PUSH
58967: LD_INT 36
58969: EQUAL
58970: PUSH
58971: LD_VAR 0 4
58975: PPUSH
58976: CALL_OW 313
58980: PUSH
58981: LD_INT 3
58983: LESS
58984: AND
58985: OR
58986: IFFALSE 59000
// begin ct := k ;
58988: LD_ADDR_VAR 0 8
58992: PUSH
58993: LD_VAR 0 4
58997: ST_TO_ADDR
// break ;
58998: GO 59002
// end ;
59000: GO 58928
59002: POP
59003: POP
// if ct then
59004: LD_VAR 0 8
59008: IFFALSE 59024
// ComEnterUnit ( j , ct ) ;
59010: LD_VAR 0 3
59014: PPUSH
59015: LD_VAR 0 8
59019: PPUSH
59020: CALL_OW 120
// end ; end ;
59024: GO 58659
59026: POP
59027: POP
// places := 0 ;
59028: LD_ADDR_VAR 0 5
59032: PUSH
59033: LD_INT 0
59035: ST_TO_ADDR
// for j = 1 to x do
59036: LD_ADDR_VAR 0 3
59040: PUSH
59041: DOUBLE
59042: LD_INT 1
59044: DEC
59045: ST_TO_ADDR
59046: LD_VAR 0 11
59050: PUSH
59051: FOR_TO
59052: IFFALSE 59128
// if GetWeapon ( x [ j ] ) = ar_control_tower then
59054: LD_VAR 0 11
59058: PUSH
59059: LD_VAR 0 3
59063: ARRAY
59064: PPUSH
59065: CALL_OW 264
59069: PUSH
59070: LD_INT 31
59072: EQUAL
59073: IFFALSE 59091
// places := places + 1 else
59075: LD_ADDR_VAR 0 5
59079: PUSH
59080: LD_VAR 0 5
59084: PUSH
59085: LD_INT 1
59087: PLUS
59088: ST_TO_ADDR
59089: GO 59126
// if GetBType ( x [ j ] ) = b_control_tower then
59091: LD_VAR 0 11
59095: PUSH
59096: LD_VAR 0 3
59100: ARRAY
59101: PPUSH
59102: CALL_OW 266
59106: PUSH
59107: LD_INT 36
59109: EQUAL
59110: IFFALSE 59126
// places := places + 3 ;
59112: LD_ADDR_VAR 0 5
59116: PUSH
59117: LD_VAR 0 5
59121: PUSH
59122: LD_INT 3
59124: PLUS
59125: ST_TO_ADDR
59126: GO 59051
59128: POP
59129: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
59130: LD_VAR 0 5
59134: PUSH
59135: LD_INT 0
59137: EQUAL
59138: PUSH
59139: LD_VAR 0 5
59143: PUSH
59144: LD_EXP 139
59148: PUSH
59149: LD_VAR 0 2
59153: ARRAY
59154: LESSEQUAL
59155: OR
59156: IFFALSE 59160
// continue ;
59158: GO 58410
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
59160: LD_ADDR_VAR 0 6
59164: PUSH
59165: LD_EXP 99
59169: PUSH
59170: LD_VAR 0 2
59174: ARRAY
59175: PPUSH
59176: LD_INT 25
59178: PUSH
59179: LD_INT 3
59181: PUSH
59182: EMPTY
59183: LIST
59184: LIST
59185: PPUSH
59186: CALL_OW 72
59190: PUSH
59191: LD_EXP 139
59195: PUSH
59196: LD_VAR 0 2
59200: ARRAY
59201: DIFF
59202: PPUSH
59203: LD_INT 3
59205: PPUSH
59206: CALL 103293 0 2
59210: ST_TO_ADDR
// for j in tmp do
59211: LD_ADDR_VAR 0 3
59215: PUSH
59216: LD_VAR 0 6
59220: PUSH
59221: FOR_IN
59222: IFFALSE 59257
// if GetTag ( j ) > 0 then
59224: LD_VAR 0 3
59228: PPUSH
59229: CALL_OW 110
59233: PUSH
59234: LD_INT 0
59236: GREATER
59237: IFFALSE 59255
// tmp := tmp diff j ;
59239: LD_ADDR_VAR 0 6
59243: PUSH
59244: LD_VAR 0 6
59248: PUSH
59249: LD_VAR 0 3
59253: DIFF
59254: ST_TO_ADDR
59255: GO 59221
59257: POP
59258: POP
// if not tmp then
59259: LD_VAR 0 6
59263: NOT
59264: IFFALSE 59268
// continue ;
59266: GO 58410
// if places then
59268: LD_VAR 0 5
59272: IFFALSE 59331
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
59274: LD_ADDR_EXP 139
59278: PUSH
59279: LD_EXP 139
59283: PPUSH
59284: LD_VAR 0 2
59288: PPUSH
59289: LD_EXP 139
59293: PUSH
59294: LD_VAR 0 2
59298: ARRAY
59299: PUSH
59300: LD_VAR 0 6
59304: PUSH
59305: LD_INT 1
59307: ARRAY
59308: UNION
59309: PPUSH
59310: CALL_OW 1
59314: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
59315: LD_VAR 0 6
59319: PUSH
59320: LD_INT 1
59322: ARRAY
59323: PPUSH
59324: LD_INT 126
59326: PPUSH
59327: CALL_OW 109
// end ; end ;
59331: GO 58410
59333: POP
59334: POP
// end ;
59335: LD_VAR 0 1
59339: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
59340: LD_INT 0
59342: PPUSH
59343: PPUSH
59344: PPUSH
59345: PPUSH
59346: PPUSH
59347: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
59348: LD_VAR 0 1
59352: NOT
59353: PUSH
59354: LD_VAR 0 2
59358: NOT
59359: OR
59360: PUSH
59361: LD_VAR 0 3
59365: NOT
59366: OR
59367: PUSH
59368: LD_VAR 0 4
59372: PUSH
59373: LD_INT 1
59375: PUSH
59376: LD_INT 2
59378: PUSH
59379: LD_INT 3
59381: PUSH
59382: LD_INT 4
59384: PUSH
59385: LD_INT 5
59387: PUSH
59388: LD_INT 8
59390: PUSH
59391: LD_INT 9
59393: PUSH
59394: LD_INT 15
59396: PUSH
59397: LD_INT 16
59399: PUSH
59400: EMPTY
59401: LIST
59402: LIST
59403: LIST
59404: LIST
59405: LIST
59406: LIST
59407: LIST
59408: LIST
59409: LIST
59410: IN
59411: NOT
59412: OR
59413: IFFALSE 59417
// exit ;
59415: GO 60317
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
59417: LD_ADDR_VAR 0 2
59421: PUSH
59422: LD_VAR 0 2
59426: PPUSH
59427: LD_INT 21
59429: PUSH
59430: LD_INT 3
59432: PUSH
59433: EMPTY
59434: LIST
59435: LIST
59436: PUSH
59437: LD_INT 24
59439: PUSH
59440: LD_INT 250
59442: PUSH
59443: EMPTY
59444: LIST
59445: LIST
59446: PUSH
59447: EMPTY
59448: LIST
59449: LIST
59450: PPUSH
59451: CALL_OW 72
59455: ST_TO_ADDR
// case class of 1 , 15 :
59456: LD_VAR 0 4
59460: PUSH
59461: LD_INT 1
59463: DOUBLE
59464: EQUAL
59465: IFTRUE 59475
59467: LD_INT 15
59469: DOUBLE
59470: EQUAL
59471: IFTRUE 59475
59473: GO 59560
59475: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
59476: LD_ADDR_VAR 0 8
59480: PUSH
59481: LD_VAR 0 2
59485: PPUSH
59486: LD_INT 2
59488: PUSH
59489: LD_INT 30
59491: PUSH
59492: LD_INT 32
59494: PUSH
59495: EMPTY
59496: LIST
59497: LIST
59498: PUSH
59499: LD_INT 30
59501: PUSH
59502: LD_INT 31
59504: PUSH
59505: EMPTY
59506: LIST
59507: LIST
59508: PUSH
59509: EMPTY
59510: LIST
59511: LIST
59512: LIST
59513: PPUSH
59514: CALL_OW 72
59518: PUSH
59519: LD_VAR 0 2
59523: PPUSH
59524: LD_INT 2
59526: PUSH
59527: LD_INT 30
59529: PUSH
59530: LD_INT 4
59532: PUSH
59533: EMPTY
59534: LIST
59535: LIST
59536: PUSH
59537: LD_INT 30
59539: PUSH
59540: LD_INT 5
59542: PUSH
59543: EMPTY
59544: LIST
59545: LIST
59546: PUSH
59547: EMPTY
59548: LIST
59549: LIST
59550: LIST
59551: PPUSH
59552: CALL_OW 72
59556: ADD
59557: ST_TO_ADDR
59558: GO 59806
59560: LD_INT 2
59562: DOUBLE
59563: EQUAL
59564: IFTRUE 59574
59566: LD_INT 16
59568: DOUBLE
59569: EQUAL
59570: IFTRUE 59574
59572: GO 59620
59574: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
59575: LD_ADDR_VAR 0 8
59579: PUSH
59580: LD_VAR 0 2
59584: PPUSH
59585: LD_INT 2
59587: PUSH
59588: LD_INT 30
59590: PUSH
59591: LD_INT 0
59593: PUSH
59594: EMPTY
59595: LIST
59596: LIST
59597: PUSH
59598: LD_INT 30
59600: PUSH
59601: LD_INT 1
59603: PUSH
59604: EMPTY
59605: LIST
59606: LIST
59607: PUSH
59608: EMPTY
59609: LIST
59610: LIST
59611: LIST
59612: PPUSH
59613: CALL_OW 72
59617: ST_TO_ADDR
59618: GO 59806
59620: LD_INT 3
59622: DOUBLE
59623: EQUAL
59624: IFTRUE 59628
59626: GO 59674
59628: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
59629: LD_ADDR_VAR 0 8
59633: PUSH
59634: LD_VAR 0 2
59638: PPUSH
59639: LD_INT 2
59641: PUSH
59642: LD_INT 30
59644: PUSH
59645: LD_INT 2
59647: PUSH
59648: EMPTY
59649: LIST
59650: LIST
59651: PUSH
59652: LD_INT 30
59654: PUSH
59655: LD_INT 3
59657: PUSH
59658: EMPTY
59659: LIST
59660: LIST
59661: PUSH
59662: EMPTY
59663: LIST
59664: LIST
59665: LIST
59666: PPUSH
59667: CALL_OW 72
59671: ST_TO_ADDR
59672: GO 59806
59674: LD_INT 4
59676: DOUBLE
59677: EQUAL
59678: IFTRUE 59682
59680: GO 59739
59682: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
59683: LD_ADDR_VAR 0 8
59687: PUSH
59688: LD_VAR 0 2
59692: PPUSH
59693: LD_INT 2
59695: PUSH
59696: LD_INT 30
59698: PUSH
59699: LD_INT 6
59701: PUSH
59702: EMPTY
59703: LIST
59704: LIST
59705: PUSH
59706: LD_INT 30
59708: PUSH
59709: LD_INT 7
59711: PUSH
59712: EMPTY
59713: LIST
59714: LIST
59715: PUSH
59716: LD_INT 30
59718: PUSH
59719: LD_INT 8
59721: PUSH
59722: EMPTY
59723: LIST
59724: LIST
59725: PUSH
59726: EMPTY
59727: LIST
59728: LIST
59729: LIST
59730: LIST
59731: PPUSH
59732: CALL_OW 72
59736: ST_TO_ADDR
59737: GO 59806
59739: LD_INT 5
59741: DOUBLE
59742: EQUAL
59743: IFTRUE 59759
59745: LD_INT 8
59747: DOUBLE
59748: EQUAL
59749: IFTRUE 59759
59751: LD_INT 9
59753: DOUBLE
59754: EQUAL
59755: IFTRUE 59759
59757: GO 59805
59759: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
59760: LD_ADDR_VAR 0 8
59764: PUSH
59765: LD_VAR 0 2
59769: PPUSH
59770: LD_INT 2
59772: PUSH
59773: LD_INT 30
59775: PUSH
59776: LD_INT 4
59778: PUSH
59779: EMPTY
59780: LIST
59781: LIST
59782: PUSH
59783: LD_INT 30
59785: PUSH
59786: LD_INT 5
59788: PUSH
59789: EMPTY
59790: LIST
59791: LIST
59792: PUSH
59793: EMPTY
59794: LIST
59795: LIST
59796: LIST
59797: PPUSH
59798: CALL_OW 72
59802: ST_TO_ADDR
59803: GO 59806
59805: POP
// if not tmp then
59806: LD_VAR 0 8
59810: NOT
59811: IFFALSE 59815
// exit ;
59813: GO 60317
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
59815: LD_VAR 0 4
59819: PUSH
59820: LD_INT 1
59822: PUSH
59823: LD_INT 15
59825: PUSH
59826: EMPTY
59827: LIST
59828: LIST
59829: IN
59830: PUSH
59831: LD_EXP 108
59835: PUSH
59836: LD_VAR 0 1
59840: ARRAY
59841: AND
59842: IFFALSE 59998
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
59844: LD_ADDR_VAR 0 9
59848: PUSH
59849: LD_EXP 108
59853: PUSH
59854: LD_VAR 0 1
59858: ARRAY
59859: PUSH
59860: LD_INT 1
59862: ARRAY
59863: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
59864: LD_VAR 0 9
59868: PUSH
59869: LD_EXP 109
59873: PUSH
59874: LD_VAR 0 1
59878: ARRAY
59879: IN
59880: NOT
59881: IFFALSE 59996
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
59883: LD_ADDR_EXP 109
59887: PUSH
59888: LD_EXP 109
59892: PPUSH
59893: LD_VAR 0 1
59897: PUSH
59898: LD_EXP 109
59902: PUSH
59903: LD_VAR 0 1
59907: ARRAY
59908: PUSH
59909: LD_INT 1
59911: PLUS
59912: PUSH
59913: EMPTY
59914: LIST
59915: LIST
59916: PPUSH
59917: LD_VAR 0 9
59921: PPUSH
59922: CALL 72472 0 3
59926: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
59927: LD_ADDR_EXP 108
59931: PUSH
59932: LD_EXP 108
59936: PPUSH
59937: LD_VAR 0 1
59941: PPUSH
59942: LD_EXP 108
59946: PUSH
59947: LD_VAR 0 1
59951: ARRAY
59952: PUSH
59953: LD_VAR 0 9
59957: DIFF
59958: PPUSH
59959: CALL_OW 1
59963: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
59964: LD_VAR 0 3
59968: PPUSH
59969: LD_EXP 109
59973: PUSH
59974: LD_VAR 0 1
59978: ARRAY
59979: PUSH
59980: LD_EXP 109
59984: PUSH
59985: LD_VAR 0 1
59989: ARRAY
59990: ARRAY
59991: PPUSH
59992: CALL_OW 120
// end ; exit ;
59996: GO 60317
// end ; if tmp > 1 then
59998: LD_VAR 0 8
60002: PUSH
60003: LD_INT 1
60005: GREATER
60006: IFFALSE 60110
// for i = 2 to tmp do
60008: LD_ADDR_VAR 0 6
60012: PUSH
60013: DOUBLE
60014: LD_INT 2
60016: DEC
60017: ST_TO_ADDR
60018: LD_VAR 0 8
60022: PUSH
60023: FOR_TO
60024: IFFALSE 60108
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
60026: LD_VAR 0 8
60030: PUSH
60031: LD_VAR 0 6
60035: ARRAY
60036: PPUSH
60037: CALL_OW 461
60041: PUSH
60042: LD_INT 6
60044: EQUAL
60045: IFFALSE 60106
// begin x := tmp [ i ] ;
60047: LD_ADDR_VAR 0 9
60051: PUSH
60052: LD_VAR 0 8
60056: PUSH
60057: LD_VAR 0 6
60061: ARRAY
60062: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
60063: LD_ADDR_VAR 0 8
60067: PUSH
60068: LD_VAR 0 8
60072: PPUSH
60073: LD_VAR 0 6
60077: PPUSH
60078: CALL_OW 3
60082: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
60083: LD_ADDR_VAR 0 8
60087: PUSH
60088: LD_VAR 0 8
60092: PPUSH
60093: LD_INT 1
60095: PPUSH
60096: LD_VAR 0 9
60100: PPUSH
60101: CALL_OW 2
60105: ST_TO_ADDR
// end ;
60106: GO 60023
60108: POP
60109: POP
// for i in tmp do
60110: LD_ADDR_VAR 0 6
60114: PUSH
60115: LD_VAR 0 8
60119: PUSH
60120: FOR_IN
60121: IFFALSE 60190
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
60123: LD_VAR 0 6
60127: PPUSH
60128: CALL_OW 313
60132: PUSH
60133: LD_INT 6
60135: LESS
60136: PUSH
60137: LD_VAR 0 6
60141: PPUSH
60142: CALL_OW 266
60146: PUSH
60147: LD_INT 31
60149: PUSH
60150: LD_INT 32
60152: PUSH
60153: EMPTY
60154: LIST
60155: LIST
60156: IN
60157: NOT
60158: AND
60159: PUSH
60160: LD_VAR 0 6
60164: PPUSH
60165: CALL_OW 313
60169: PUSH
60170: LD_INT 0
60172: EQUAL
60173: OR
60174: IFFALSE 60188
// begin j := i ;
60176: LD_ADDR_VAR 0 7
60180: PUSH
60181: LD_VAR 0 6
60185: ST_TO_ADDR
// break ;
60186: GO 60190
// end ; end ;
60188: GO 60120
60190: POP
60191: POP
// if j then
60192: LD_VAR 0 7
60196: IFFALSE 60214
// ComEnterUnit ( unit , j ) else
60198: LD_VAR 0 3
60202: PPUSH
60203: LD_VAR 0 7
60207: PPUSH
60208: CALL_OW 120
60212: GO 60317
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60214: LD_ADDR_VAR 0 10
60218: PUSH
60219: LD_VAR 0 2
60223: PPUSH
60224: LD_INT 2
60226: PUSH
60227: LD_INT 30
60229: PUSH
60230: LD_INT 0
60232: PUSH
60233: EMPTY
60234: LIST
60235: LIST
60236: PUSH
60237: LD_INT 30
60239: PUSH
60240: LD_INT 1
60242: PUSH
60243: EMPTY
60244: LIST
60245: LIST
60246: PUSH
60247: EMPTY
60248: LIST
60249: LIST
60250: LIST
60251: PPUSH
60252: CALL_OW 72
60256: ST_TO_ADDR
// if depot then
60257: LD_VAR 0 10
60261: IFFALSE 60317
// begin depot := NearestUnitToUnit ( depot , unit ) ;
60263: LD_ADDR_VAR 0 10
60267: PUSH
60268: LD_VAR 0 10
60272: PPUSH
60273: LD_VAR 0 3
60277: PPUSH
60278: CALL_OW 74
60282: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
60283: LD_VAR 0 3
60287: PPUSH
60288: LD_VAR 0 10
60292: PPUSH
60293: CALL_OW 296
60297: PUSH
60298: LD_INT 10
60300: GREATER
60301: IFFALSE 60317
// ComStandNearbyBuilding ( unit , depot ) ;
60303: LD_VAR 0 3
60307: PPUSH
60308: LD_VAR 0 10
60312: PPUSH
60313: CALL 68899 0 2
// end ; end ; end ;
60317: LD_VAR 0 5
60321: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
60322: LD_INT 0
60324: PPUSH
60325: PPUSH
60326: PPUSH
60327: PPUSH
// if not mc_bases then
60328: LD_EXP 99
60332: NOT
60333: IFFALSE 60337
// exit ;
60335: GO 60576
// for i = 1 to mc_bases do
60337: LD_ADDR_VAR 0 2
60341: PUSH
60342: DOUBLE
60343: LD_INT 1
60345: DEC
60346: ST_TO_ADDR
60347: LD_EXP 99
60351: PUSH
60352: FOR_TO
60353: IFFALSE 60574
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
60355: LD_ADDR_VAR 0 4
60359: PUSH
60360: LD_EXP 99
60364: PUSH
60365: LD_VAR 0 2
60369: ARRAY
60370: PPUSH
60371: LD_INT 21
60373: PUSH
60374: LD_INT 1
60376: PUSH
60377: EMPTY
60378: LIST
60379: LIST
60380: PPUSH
60381: CALL_OW 72
60385: PUSH
60386: LD_EXP 128
60390: PUSH
60391: LD_VAR 0 2
60395: ARRAY
60396: UNION
60397: ST_TO_ADDR
// if not tmp then
60398: LD_VAR 0 4
60402: NOT
60403: IFFALSE 60407
// continue ;
60405: GO 60352
// for j in tmp do
60407: LD_ADDR_VAR 0 3
60411: PUSH
60412: LD_VAR 0 4
60416: PUSH
60417: FOR_IN
60418: IFFALSE 60570
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
60420: LD_VAR 0 3
60424: PPUSH
60425: CALL_OW 110
60429: NOT
60430: PUSH
60431: LD_VAR 0 3
60435: PPUSH
60436: CALL_OW 314
60440: NOT
60441: AND
60442: PUSH
60443: LD_VAR 0 3
60447: PPUSH
60448: CALL_OW 311
60452: NOT
60453: AND
60454: PUSH
60455: LD_VAR 0 3
60459: PPUSH
60460: CALL_OW 310
60464: NOT
60465: AND
60466: PUSH
60467: LD_VAR 0 3
60471: PUSH
60472: LD_EXP 102
60476: PUSH
60477: LD_VAR 0 2
60481: ARRAY
60482: PUSH
60483: LD_INT 1
60485: ARRAY
60486: IN
60487: NOT
60488: AND
60489: PUSH
60490: LD_VAR 0 3
60494: PUSH
60495: LD_EXP 102
60499: PUSH
60500: LD_VAR 0 2
60504: ARRAY
60505: PUSH
60506: LD_INT 2
60508: ARRAY
60509: IN
60510: NOT
60511: AND
60512: PUSH
60513: LD_VAR 0 3
60517: PUSH
60518: LD_EXP 111
60522: PUSH
60523: LD_VAR 0 2
60527: ARRAY
60528: IN
60529: NOT
60530: AND
60531: IFFALSE 60568
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
60533: LD_VAR 0 2
60537: PPUSH
60538: LD_EXP 99
60542: PUSH
60543: LD_VAR 0 2
60547: ARRAY
60548: PPUSH
60549: LD_VAR 0 3
60553: PPUSH
60554: LD_VAR 0 3
60558: PPUSH
60559: CALL_OW 257
60563: PPUSH
60564: CALL 59340 0 4
// end ;
60568: GO 60417
60570: POP
60571: POP
// end ;
60572: GO 60352
60574: POP
60575: POP
// end ;
60576: LD_VAR 0 1
60580: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
60581: LD_INT 0
60583: PPUSH
60584: PPUSH
60585: PPUSH
60586: PPUSH
60587: PPUSH
60588: PPUSH
// if not mc_bases [ base ] then
60589: LD_EXP 99
60593: PUSH
60594: LD_VAR 0 1
60598: ARRAY
60599: NOT
60600: IFFALSE 60604
// exit ;
60602: GO 60786
// tmp := [ ] ;
60604: LD_ADDR_VAR 0 6
60608: PUSH
60609: EMPTY
60610: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
60611: LD_ADDR_VAR 0 7
60615: PUSH
60616: LD_VAR 0 3
60620: PPUSH
60621: LD_INT 0
60623: PPUSH
60624: CALL_OW 517
60628: ST_TO_ADDR
// if not list then
60629: LD_VAR 0 7
60633: NOT
60634: IFFALSE 60638
// exit ;
60636: GO 60786
// for i = 1 to amount do
60638: LD_ADDR_VAR 0 5
60642: PUSH
60643: DOUBLE
60644: LD_INT 1
60646: DEC
60647: ST_TO_ADDR
60648: LD_VAR 0 2
60652: PUSH
60653: FOR_TO
60654: IFFALSE 60734
// begin x := rand ( 1 , list [ 1 ] ) ;
60656: LD_ADDR_VAR 0 8
60660: PUSH
60661: LD_INT 1
60663: PPUSH
60664: LD_VAR 0 7
60668: PUSH
60669: LD_INT 1
60671: ARRAY
60672: PPUSH
60673: CALL_OW 12
60677: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
60678: LD_ADDR_VAR 0 6
60682: PUSH
60683: LD_VAR 0 6
60687: PPUSH
60688: LD_VAR 0 5
60692: PPUSH
60693: LD_VAR 0 7
60697: PUSH
60698: LD_INT 1
60700: ARRAY
60701: PUSH
60702: LD_VAR 0 8
60706: ARRAY
60707: PUSH
60708: LD_VAR 0 7
60712: PUSH
60713: LD_INT 2
60715: ARRAY
60716: PUSH
60717: LD_VAR 0 8
60721: ARRAY
60722: PUSH
60723: EMPTY
60724: LIST
60725: LIST
60726: PPUSH
60727: CALL_OW 1
60731: ST_TO_ADDR
// end ;
60732: GO 60653
60734: POP
60735: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
60736: LD_ADDR_EXP 112
60740: PUSH
60741: LD_EXP 112
60745: PPUSH
60746: LD_VAR 0 1
60750: PPUSH
60751: LD_VAR 0 6
60755: PPUSH
60756: CALL_OW 1
60760: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
60761: LD_ADDR_EXP 114
60765: PUSH
60766: LD_EXP 114
60770: PPUSH
60771: LD_VAR 0 1
60775: PPUSH
60776: LD_VAR 0 3
60780: PPUSH
60781: CALL_OW 1
60785: ST_TO_ADDR
// end ;
60786: LD_VAR 0 4
60790: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
60791: LD_INT 0
60793: PPUSH
// if not mc_bases [ base ] then
60794: LD_EXP 99
60798: PUSH
60799: LD_VAR 0 1
60803: ARRAY
60804: NOT
60805: IFFALSE 60809
// exit ;
60807: GO 60834
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
60809: LD_ADDR_EXP 104
60813: PUSH
60814: LD_EXP 104
60818: PPUSH
60819: LD_VAR 0 1
60823: PPUSH
60824: LD_VAR 0 2
60828: PPUSH
60829: CALL_OW 1
60833: ST_TO_ADDR
// end ;
60834: LD_VAR 0 3
60838: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
60839: LD_INT 0
60841: PPUSH
// if not mc_bases [ base ] then
60842: LD_EXP 99
60846: PUSH
60847: LD_VAR 0 1
60851: ARRAY
60852: NOT
60853: IFFALSE 60857
// exit ;
60855: GO 60894
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
60857: LD_ADDR_EXP 104
60861: PUSH
60862: LD_EXP 104
60866: PPUSH
60867: LD_VAR 0 1
60871: PPUSH
60872: LD_EXP 104
60876: PUSH
60877: LD_VAR 0 1
60881: ARRAY
60882: PUSH
60883: LD_VAR 0 2
60887: UNION
60888: PPUSH
60889: CALL_OW 1
60893: ST_TO_ADDR
// end ;
60894: LD_VAR 0 3
60898: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
60899: LD_INT 0
60901: PPUSH
// if not mc_bases [ base ] then
60902: LD_EXP 99
60906: PUSH
60907: LD_VAR 0 1
60911: ARRAY
60912: NOT
60913: IFFALSE 60917
// exit ;
60915: GO 60942
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
60917: LD_ADDR_EXP 120
60921: PUSH
60922: LD_EXP 120
60926: PPUSH
60927: LD_VAR 0 1
60931: PPUSH
60932: LD_VAR 0 2
60936: PPUSH
60937: CALL_OW 1
60941: ST_TO_ADDR
// end ;
60942: LD_VAR 0 3
60946: RET
// export function MC_InsertProduceList ( base , components ) ; begin
60947: LD_INT 0
60949: PPUSH
// if not mc_bases [ base ] then
60950: LD_EXP 99
60954: PUSH
60955: LD_VAR 0 1
60959: ARRAY
60960: NOT
60961: IFFALSE 60965
// exit ;
60963: GO 61002
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
60965: LD_ADDR_EXP 120
60969: PUSH
60970: LD_EXP 120
60974: PPUSH
60975: LD_VAR 0 1
60979: PPUSH
60980: LD_EXP 120
60984: PUSH
60985: LD_VAR 0 1
60989: ARRAY
60990: PUSH
60991: LD_VAR 0 2
60995: ADD
60996: PPUSH
60997: CALL_OW 1
61001: ST_TO_ADDR
// end ;
61002: LD_VAR 0 3
61006: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
61007: LD_INT 0
61009: PPUSH
// if not mc_bases [ base ] then
61010: LD_EXP 99
61014: PUSH
61015: LD_VAR 0 1
61019: ARRAY
61020: NOT
61021: IFFALSE 61025
// exit ;
61023: GO 61079
// mc_defender := Replace ( mc_defender , base , deflist ) ;
61025: LD_ADDR_EXP 121
61029: PUSH
61030: LD_EXP 121
61034: PPUSH
61035: LD_VAR 0 1
61039: PPUSH
61040: LD_VAR 0 2
61044: PPUSH
61045: CALL_OW 1
61049: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
61050: LD_ADDR_EXP 110
61054: PUSH
61055: LD_EXP 110
61059: PPUSH
61060: LD_VAR 0 1
61064: PPUSH
61065: LD_VAR 0 2
61069: PUSH
61070: LD_INT 0
61072: PLUS
61073: PPUSH
61074: CALL_OW 1
61078: ST_TO_ADDR
// end ;
61079: LD_VAR 0 3
61083: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
61084: LD_INT 0
61086: PPUSH
// if not mc_bases [ base ] then
61087: LD_EXP 99
61091: PUSH
61092: LD_VAR 0 1
61096: ARRAY
61097: NOT
61098: IFFALSE 61102
// exit ;
61100: GO 61127
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
61102: LD_ADDR_EXP 110
61106: PUSH
61107: LD_EXP 110
61111: PPUSH
61112: LD_VAR 0 1
61116: PPUSH
61117: LD_VAR 0 2
61121: PPUSH
61122: CALL_OW 1
61126: ST_TO_ADDR
// end ;
61127: LD_VAR 0 3
61131: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
61132: LD_INT 0
61134: PPUSH
61135: PPUSH
61136: PPUSH
61137: PPUSH
// if not mc_bases [ base ] then
61138: LD_EXP 99
61142: PUSH
61143: LD_VAR 0 1
61147: ARRAY
61148: NOT
61149: IFFALSE 61153
// exit ;
61151: GO 61218
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
61153: LD_ADDR_EXP 119
61157: PUSH
61158: LD_EXP 119
61162: PPUSH
61163: LD_VAR 0 1
61167: PUSH
61168: LD_EXP 119
61172: PUSH
61173: LD_VAR 0 1
61177: ARRAY
61178: PUSH
61179: LD_INT 1
61181: PLUS
61182: PUSH
61183: EMPTY
61184: LIST
61185: LIST
61186: PPUSH
61187: LD_VAR 0 1
61191: PUSH
61192: LD_VAR 0 2
61196: PUSH
61197: LD_VAR 0 3
61201: PUSH
61202: LD_VAR 0 4
61206: PUSH
61207: EMPTY
61208: LIST
61209: LIST
61210: LIST
61211: LIST
61212: PPUSH
61213: CALL 72472 0 3
61217: ST_TO_ADDR
// end ;
61218: LD_VAR 0 5
61222: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
61223: LD_INT 0
61225: PPUSH
// if not mc_bases [ base ] then
61226: LD_EXP 99
61230: PUSH
61231: LD_VAR 0 1
61235: ARRAY
61236: NOT
61237: IFFALSE 61241
// exit ;
61239: GO 61266
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
61241: LD_ADDR_EXP 136
61245: PUSH
61246: LD_EXP 136
61250: PPUSH
61251: LD_VAR 0 1
61255: PPUSH
61256: LD_VAR 0 2
61260: PPUSH
61261: CALL_OW 1
61265: ST_TO_ADDR
// end ;
61266: LD_VAR 0 3
61270: RET
// export function MC_GetMinesField ( base ) ; begin
61271: LD_INT 0
61273: PPUSH
// result := mc_mines [ base ] ;
61274: LD_ADDR_VAR 0 2
61278: PUSH
61279: LD_EXP 112
61283: PUSH
61284: LD_VAR 0 1
61288: ARRAY
61289: ST_TO_ADDR
// end ;
61290: LD_VAR 0 2
61294: RET
// export function MC_GetProduceList ( base ) ; begin
61295: LD_INT 0
61297: PPUSH
// result := mc_produce [ base ] ;
61298: LD_ADDR_VAR 0 2
61302: PUSH
61303: LD_EXP 120
61307: PUSH
61308: LD_VAR 0 1
61312: ARRAY
61313: ST_TO_ADDR
// end ;
61314: LD_VAR 0 2
61318: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
61319: LD_INT 0
61321: PPUSH
61322: PPUSH
// if not mc_bases then
61323: LD_EXP 99
61327: NOT
61328: IFFALSE 61332
// exit ;
61330: GO 61397
// if mc_bases [ base ] then
61332: LD_EXP 99
61336: PUSH
61337: LD_VAR 0 1
61341: ARRAY
61342: IFFALSE 61397
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61344: LD_ADDR_VAR 0 3
61348: PUSH
61349: LD_EXP 99
61353: PUSH
61354: LD_VAR 0 1
61358: ARRAY
61359: PPUSH
61360: LD_INT 30
61362: PUSH
61363: LD_VAR 0 2
61367: PUSH
61368: EMPTY
61369: LIST
61370: LIST
61371: PPUSH
61372: CALL_OW 72
61376: ST_TO_ADDR
// if result then
61377: LD_VAR 0 3
61381: IFFALSE 61397
// result := result [ 1 ] ;
61383: LD_ADDR_VAR 0 3
61387: PUSH
61388: LD_VAR 0 3
61392: PUSH
61393: LD_INT 1
61395: ARRAY
61396: ST_TO_ADDR
// end ; end ;
61397: LD_VAR 0 3
61401: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
61402: LD_INT 0
61404: PPUSH
61405: PPUSH
// if not mc_bases then
61406: LD_EXP 99
61410: NOT
61411: IFFALSE 61415
// exit ;
61413: GO 61460
// if mc_bases [ base ] then
61415: LD_EXP 99
61419: PUSH
61420: LD_VAR 0 1
61424: ARRAY
61425: IFFALSE 61460
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61427: LD_ADDR_VAR 0 3
61431: PUSH
61432: LD_EXP 99
61436: PUSH
61437: LD_VAR 0 1
61441: ARRAY
61442: PPUSH
61443: LD_INT 30
61445: PUSH
61446: LD_VAR 0 2
61450: PUSH
61451: EMPTY
61452: LIST
61453: LIST
61454: PPUSH
61455: CALL_OW 72
61459: ST_TO_ADDR
// end ;
61460: LD_VAR 0 3
61464: RET
// export function MC_SetTame ( base , area ) ; begin
61465: LD_INT 0
61467: PPUSH
// if not mc_bases or not base then
61468: LD_EXP 99
61472: NOT
61473: PUSH
61474: LD_VAR 0 1
61478: NOT
61479: OR
61480: IFFALSE 61484
// exit ;
61482: GO 61509
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
61484: LD_ADDR_EXP 127
61488: PUSH
61489: LD_EXP 127
61493: PPUSH
61494: LD_VAR 0 1
61498: PPUSH
61499: LD_VAR 0 2
61503: PPUSH
61504: CALL_OW 1
61508: ST_TO_ADDR
// end ;
61509: LD_VAR 0 3
61513: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
61514: LD_INT 0
61516: PPUSH
61517: PPUSH
// if not mc_bases or not base then
61518: LD_EXP 99
61522: NOT
61523: PUSH
61524: LD_VAR 0 1
61528: NOT
61529: OR
61530: IFFALSE 61534
// exit ;
61532: GO 61636
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61534: LD_ADDR_VAR 0 4
61538: PUSH
61539: LD_EXP 99
61543: PUSH
61544: LD_VAR 0 1
61548: ARRAY
61549: PPUSH
61550: LD_INT 30
61552: PUSH
61553: LD_VAR 0 2
61557: PUSH
61558: EMPTY
61559: LIST
61560: LIST
61561: PPUSH
61562: CALL_OW 72
61566: ST_TO_ADDR
// if not tmp then
61567: LD_VAR 0 4
61571: NOT
61572: IFFALSE 61576
// exit ;
61574: GO 61636
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
61576: LD_ADDR_EXP 131
61580: PUSH
61581: LD_EXP 131
61585: PPUSH
61586: LD_VAR 0 1
61590: PPUSH
61591: LD_EXP 131
61595: PUSH
61596: LD_VAR 0 1
61600: ARRAY
61601: PPUSH
61602: LD_EXP 131
61606: PUSH
61607: LD_VAR 0 1
61611: ARRAY
61612: PUSH
61613: LD_INT 1
61615: PLUS
61616: PPUSH
61617: LD_VAR 0 4
61621: PUSH
61622: LD_INT 1
61624: ARRAY
61625: PPUSH
61626: CALL_OW 2
61630: PPUSH
61631: CALL_OW 1
61635: ST_TO_ADDR
// end ;
61636: LD_VAR 0 3
61640: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
61641: LD_INT 0
61643: PPUSH
61644: PPUSH
// if not mc_bases or not base or not kinds then
61645: LD_EXP 99
61649: NOT
61650: PUSH
61651: LD_VAR 0 1
61655: NOT
61656: OR
61657: PUSH
61658: LD_VAR 0 2
61662: NOT
61663: OR
61664: IFFALSE 61668
// exit ;
61666: GO 61729
// for i in kinds do
61668: LD_ADDR_VAR 0 4
61672: PUSH
61673: LD_VAR 0 2
61677: PUSH
61678: FOR_IN
61679: IFFALSE 61727
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
61681: LD_ADDR_EXP 133
61685: PUSH
61686: LD_EXP 133
61690: PPUSH
61691: LD_VAR 0 1
61695: PUSH
61696: LD_EXP 133
61700: PUSH
61701: LD_VAR 0 1
61705: ARRAY
61706: PUSH
61707: LD_INT 1
61709: PLUS
61710: PUSH
61711: EMPTY
61712: LIST
61713: LIST
61714: PPUSH
61715: LD_VAR 0 4
61719: PPUSH
61720: CALL 72472 0 3
61724: ST_TO_ADDR
61725: GO 61678
61727: POP
61728: POP
// end ;
61729: LD_VAR 0 3
61733: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
61734: LD_INT 0
61736: PPUSH
// if not mc_bases or not base or not areas then
61737: LD_EXP 99
61741: NOT
61742: PUSH
61743: LD_VAR 0 1
61747: NOT
61748: OR
61749: PUSH
61750: LD_VAR 0 2
61754: NOT
61755: OR
61756: IFFALSE 61760
// exit ;
61758: GO 61785
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
61760: LD_ADDR_EXP 117
61764: PUSH
61765: LD_EXP 117
61769: PPUSH
61770: LD_VAR 0 1
61774: PPUSH
61775: LD_VAR 0 2
61779: PPUSH
61780: CALL_OW 1
61784: ST_TO_ADDR
// end ;
61785: LD_VAR 0 3
61789: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
61790: LD_INT 0
61792: PPUSH
// if not mc_bases or not base or not teleports_exit then
61793: LD_EXP 99
61797: NOT
61798: PUSH
61799: LD_VAR 0 1
61803: NOT
61804: OR
61805: PUSH
61806: LD_VAR 0 2
61810: NOT
61811: OR
61812: IFFALSE 61816
// exit ;
61814: GO 61841
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
61816: LD_ADDR_EXP 134
61820: PUSH
61821: LD_EXP 134
61825: PPUSH
61826: LD_VAR 0 1
61830: PPUSH
61831: LD_VAR 0 2
61835: PPUSH
61836: CALL_OW 1
61840: ST_TO_ADDR
// end ;
61841: LD_VAR 0 3
61845: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
61846: LD_INT 0
61848: PPUSH
61849: PPUSH
61850: PPUSH
// if not mc_bases or not base or not ext_list then
61851: LD_EXP 99
61855: NOT
61856: PUSH
61857: LD_VAR 0 1
61861: NOT
61862: OR
61863: PUSH
61864: LD_VAR 0 5
61868: NOT
61869: OR
61870: IFFALSE 61874
// exit ;
61872: GO 62047
// tmp := GetFacExtXYD ( x , y , d ) ;
61874: LD_ADDR_VAR 0 8
61878: PUSH
61879: LD_VAR 0 2
61883: PPUSH
61884: LD_VAR 0 3
61888: PPUSH
61889: LD_VAR 0 4
61893: PPUSH
61894: CALL 102423 0 3
61898: ST_TO_ADDR
// if not tmp then
61899: LD_VAR 0 8
61903: NOT
61904: IFFALSE 61908
// exit ;
61906: GO 62047
// for i in tmp do
61908: LD_ADDR_VAR 0 7
61912: PUSH
61913: LD_VAR 0 8
61917: PUSH
61918: FOR_IN
61919: IFFALSE 62045
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
61921: LD_ADDR_EXP 104
61925: PUSH
61926: LD_EXP 104
61930: PPUSH
61931: LD_VAR 0 1
61935: PPUSH
61936: LD_EXP 104
61940: PUSH
61941: LD_VAR 0 1
61945: ARRAY
61946: PPUSH
61947: LD_EXP 104
61951: PUSH
61952: LD_VAR 0 1
61956: ARRAY
61957: PUSH
61958: LD_INT 1
61960: PLUS
61961: PPUSH
61962: LD_VAR 0 5
61966: PUSH
61967: LD_INT 1
61969: ARRAY
61970: PUSH
61971: LD_VAR 0 7
61975: PUSH
61976: LD_INT 1
61978: ARRAY
61979: PUSH
61980: LD_VAR 0 7
61984: PUSH
61985: LD_INT 2
61987: ARRAY
61988: PUSH
61989: LD_VAR 0 7
61993: PUSH
61994: LD_INT 3
61996: ARRAY
61997: PUSH
61998: EMPTY
61999: LIST
62000: LIST
62001: LIST
62002: LIST
62003: PPUSH
62004: CALL_OW 2
62008: PPUSH
62009: CALL_OW 1
62013: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
62014: LD_ADDR_VAR 0 5
62018: PUSH
62019: LD_VAR 0 5
62023: PPUSH
62024: LD_INT 1
62026: PPUSH
62027: CALL_OW 3
62031: ST_TO_ADDR
// if not ext_list then
62032: LD_VAR 0 5
62036: NOT
62037: IFFALSE 62043
// exit ;
62039: POP
62040: POP
62041: GO 62047
// end ;
62043: GO 61918
62045: POP
62046: POP
// end ;
62047: LD_VAR 0 6
62051: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
62052: LD_INT 0
62054: PPUSH
// if not mc_bases or not base or not weapon_list then
62055: LD_EXP 99
62059: NOT
62060: PUSH
62061: LD_VAR 0 1
62065: NOT
62066: OR
62067: PUSH
62068: LD_VAR 0 2
62072: NOT
62073: OR
62074: IFFALSE 62078
// exit ;
62076: GO 62103
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
62078: LD_ADDR_EXP 138
62082: PUSH
62083: LD_EXP 138
62087: PPUSH
62088: LD_VAR 0 1
62092: PPUSH
62093: LD_VAR 0 2
62097: PPUSH
62098: CALL_OW 1
62102: ST_TO_ADDR
// end ;
62103: LD_VAR 0 3
62107: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
62108: LD_INT 0
62110: PPUSH
// if not mc_bases or not base or not tech_list then
62111: LD_EXP 99
62115: NOT
62116: PUSH
62117: LD_VAR 0 1
62121: NOT
62122: OR
62123: PUSH
62124: LD_VAR 0 2
62128: NOT
62129: OR
62130: IFFALSE 62134
// exit ;
62132: GO 62159
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
62134: LD_ADDR_EXP 126
62138: PUSH
62139: LD_EXP 126
62143: PPUSH
62144: LD_VAR 0 1
62148: PPUSH
62149: LD_VAR 0 2
62153: PPUSH
62154: CALL_OW 1
62158: ST_TO_ADDR
// end ;
62159: LD_VAR 0 3
62163: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
62164: LD_INT 0
62166: PPUSH
// if not mc_bases or not parking_area or not base then
62167: LD_EXP 99
62171: NOT
62172: PUSH
62173: LD_VAR 0 2
62177: NOT
62178: OR
62179: PUSH
62180: LD_VAR 0 1
62184: NOT
62185: OR
62186: IFFALSE 62190
// exit ;
62188: GO 62215
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
62190: LD_ADDR_EXP 123
62194: PUSH
62195: LD_EXP 123
62199: PPUSH
62200: LD_VAR 0 1
62204: PPUSH
62205: LD_VAR 0 2
62209: PPUSH
62210: CALL_OW 1
62214: ST_TO_ADDR
// end ;
62215: LD_VAR 0 3
62219: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
62220: LD_INT 0
62222: PPUSH
// if not mc_bases or not base or not scan_area then
62223: LD_EXP 99
62227: NOT
62228: PUSH
62229: LD_VAR 0 1
62233: NOT
62234: OR
62235: PUSH
62236: LD_VAR 0 2
62240: NOT
62241: OR
62242: IFFALSE 62246
// exit ;
62244: GO 62271
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
62246: LD_ADDR_EXP 124
62250: PUSH
62251: LD_EXP 124
62255: PPUSH
62256: LD_VAR 0 1
62260: PPUSH
62261: LD_VAR 0 2
62265: PPUSH
62266: CALL_OW 1
62270: ST_TO_ADDR
// end ;
62271: LD_VAR 0 3
62275: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
62276: LD_INT 0
62278: PPUSH
62279: PPUSH
// if not mc_bases or not base then
62280: LD_EXP 99
62284: NOT
62285: PUSH
62286: LD_VAR 0 1
62290: NOT
62291: OR
62292: IFFALSE 62296
// exit ;
62294: GO 62360
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
62296: LD_ADDR_VAR 0 3
62300: PUSH
62301: LD_INT 1
62303: PUSH
62304: LD_INT 2
62306: PUSH
62307: LD_INT 3
62309: PUSH
62310: LD_INT 4
62312: PUSH
62313: LD_INT 11
62315: PUSH
62316: EMPTY
62317: LIST
62318: LIST
62319: LIST
62320: LIST
62321: LIST
62322: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
62323: LD_ADDR_EXP 126
62327: PUSH
62328: LD_EXP 126
62332: PPUSH
62333: LD_VAR 0 1
62337: PPUSH
62338: LD_EXP 126
62342: PUSH
62343: LD_VAR 0 1
62347: ARRAY
62348: PUSH
62349: LD_VAR 0 3
62353: DIFF
62354: PPUSH
62355: CALL_OW 1
62359: ST_TO_ADDR
// end ;
62360: LD_VAR 0 2
62364: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
62365: LD_INT 0
62367: PPUSH
// result := mc_vehicles [ base ] ;
62368: LD_ADDR_VAR 0 3
62372: PUSH
62373: LD_EXP 118
62377: PUSH
62378: LD_VAR 0 1
62382: ARRAY
62383: ST_TO_ADDR
// if onlyCombat then
62384: LD_VAR 0 2
62388: IFFALSE 62560
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
62390: LD_ADDR_VAR 0 3
62394: PUSH
62395: LD_VAR 0 3
62399: PUSH
62400: LD_VAR 0 3
62404: PPUSH
62405: LD_INT 2
62407: PUSH
62408: LD_INT 34
62410: PUSH
62411: LD_INT 12
62413: PUSH
62414: EMPTY
62415: LIST
62416: LIST
62417: PUSH
62418: LD_INT 34
62420: PUSH
62421: LD_INT 51
62423: PUSH
62424: EMPTY
62425: LIST
62426: LIST
62427: PUSH
62428: LD_INT 34
62430: PUSH
62431: LD_INT 89
62433: PUSH
62434: EMPTY
62435: LIST
62436: LIST
62437: PUSH
62438: LD_INT 34
62440: PUSH
62441: LD_INT 32
62443: PUSH
62444: EMPTY
62445: LIST
62446: LIST
62447: PUSH
62448: LD_INT 34
62450: PUSH
62451: LD_INT 13
62453: PUSH
62454: EMPTY
62455: LIST
62456: LIST
62457: PUSH
62458: LD_INT 34
62460: PUSH
62461: LD_INT 52
62463: PUSH
62464: EMPTY
62465: LIST
62466: LIST
62467: PUSH
62468: LD_INT 34
62470: PUSH
62471: LD_INT 88
62473: PUSH
62474: EMPTY
62475: LIST
62476: LIST
62477: PUSH
62478: LD_INT 34
62480: PUSH
62481: LD_INT 14
62483: PUSH
62484: EMPTY
62485: LIST
62486: LIST
62487: PUSH
62488: LD_INT 34
62490: PUSH
62491: LD_INT 53
62493: PUSH
62494: EMPTY
62495: LIST
62496: LIST
62497: PUSH
62498: LD_INT 34
62500: PUSH
62501: LD_INT 98
62503: PUSH
62504: EMPTY
62505: LIST
62506: LIST
62507: PUSH
62508: LD_INT 34
62510: PUSH
62511: LD_INT 31
62513: PUSH
62514: EMPTY
62515: LIST
62516: LIST
62517: PUSH
62518: LD_INT 34
62520: PUSH
62521: LD_INT 48
62523: PUSH
62524: EMPTY
62525: LIST
62526: LIST
62527: PUSH
62528: LD_INT 34
62530: PUSH
62531: LD_INT 8
62533: PUSH
62534: EMPTY
62535: LIST
62536: LIST
62537: PUSH
62538: EMPTY
62539: LIST
62540: LIST
62541: LIST
62542: LIST
62543: LIST
62544: LIST
62545: LIST
62546: LIST
62547: LIST
62548: LIST
62549: LIST
62550: LIST
62551: LIST
62552: LIST
62553: PPUSH
62554: CALL_OW 72
62558: DIFF
62559: ST_TO_ADDR
// end ; end_of_file
62560: LD_VAR 0 3
62564: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
62565: LD_INT 0
62567: PPUSH
62568: PPUSH
62569: PPUSH
// if not mc_bases or not skirmish then
62570: LD_EXP 99
62574: NOT
62575: PUSH
62576: LD_EXP 97
62580: NOT
62581: OR
62582: IFFALSE 62586
// exit ;
62584: GO 62751
// for i = 1 to mc_bases do
62586: LD_ADDR_VAR 0 4
62590: PUSH
62591: DOUBLE
62592: LD_INT 1
62594: DEC
62595: ST_TO_ADDR
62596: LD_EXP 99
62600: PUSH
62601: FOR_TO
62602: IFFALSE 62749
// begin if sci in mc_bases [ i ] then
62604: LD_VAR 0 2
62608: PUSH
62609: LD_EXP 99
62613: PUSH
62614: LD_VAR 0 4
62618: ARRAY
62619: IN
62620: IFFALSE 62747
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
62622: LD_ADDR_EXP 128
62626: PUSH
62627: LD_EXP 128
62631: PPUSH
62632: LD_VAR 0 4
62636: PUSH
62637: LD_EXP 128
62641: PUSH
62642: LD_VAR 0 4
62646: ARRAY
62647: PUSH
62648: LD_INT 1
62650: PLUS
62651: PUSH
62652: EMPTY
62653: LIST
62654: LIST
62655: PPUSH
62656: LD_VAR 0 1
62660: PPUSH
62661: CALL 72472 0 3
62665: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
62666: LD_ADDR_VAR 0 5
62670: PUSH
62671: LD_EXP 99
62675: PUSH
62676: LD_VAR 0 4
62680: ARRAY
62681: PPUSH
62682: LD_INT 2
62684: PUSH
62685: LD_INT 30
62687: PUSH
62688: LD_INT 0
62690: PUSH
62691: EMPTY
62692: LIST
62693: LIST
62694: PUSH
62695: LD_INT 30
62697: PUSH
62698: LD_INT 1
62700: PUSH
62701: EMPTY
62702: LIST
62703: LIST
62704: PUSH
62705: EMPTY
62706: LIST
62707: LIST
62708: LIST
62709: PPUSH
62710: CALL_OW 72
62714: PPUSH
62715: LD_VAR 0 1
62719: PPUSH
62720: CALL_OW 74
62724: ST_TO_ADDR
// if tmp then
62725: LD_VAR 0 5
62729: IFFALSE 62745
// ComStandNearbyBuilding ( ape , tmp ) ;
62731: LD_VAR 0 1
62735: PPUSH
62736: LD_VAR 0 5
62740: PPUSH
62741: CALL 68899 0 2
// break ;
62745: GO 62749
// end ; end ;
62747: GO 62601
62749: POP
62750: POP
// end ;
62751: LD_VAR 0 3
62755: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
62756: LD_INT 0
62758: PPUSH
62759: PPUSH
62760: PPUSH
// if not mc_bases or not skirmish then
62761: LD_EXP 99
62765: NOT
62766: PUSH
62767: LD_EXP 97
62771: NOT
62772: OR
62773: IFFALSE 62777
// exit ;
62775: GO 62866
// for i = 1 to mc_bases do
62777: LD_ADDR_VAR 0 4
62781: PUSH
62782: DOUBLE
62783: LD_INT 1
62785: DEC
62786: ST_TO_ADDR
62787: LD_EXP 99
62791: PUSH
62792: FOR_TO
62793: IFFALSE 62864
// begin if building in mc_busy_turret_list [ i ] then
62795: LD_VAR 0 1
62799: PUSH
62800: LD_EXP 109
62804: PUSH
62805: LD_VAR 0 4
62809: ARRAY
62810: IN
62811: IFFALSE 62862
// begin tmp := mc_busy_turret_list [ i ] diff building ;
62813: LD_ADDR_VAR 0 5
62817: PUSH
62818: LD_EXP 109
62822: PUSH
62823: LD_VAR 0 4
62827: ARRAY
62828: PUSH
62829: LD_VAR 0 1
62833: DIFF
62834: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
62835: LD_ADDR_EXP 109
62839: PUSH
62840: LD_EXP 109
62844: PPUSH
62845: LD_VAR 0 4
62849: PPUSH
62850: LD_VAR 0 5
62854: PPUSH
62855: CALL_OW 1
62859: ST_TO_ADDR
// break ;
62860: GO 62864
// end ; end ;
62862: GO 62792
62864: POP
62865: POP
// end ;
62866: LD_VAR 0 3
62870: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
62871: LD_INT 0
62873: PPUSH
62874: PPUSH
62875: PPUSH
// if not mc_bases or not skirmish then
62876: LD_EXP 99
62880: NOT
62881: PUSH
62882: LD_EXP 97
62886: NOT
62887: OR
62888: IFFALSE 62892
// exit ;
62890: GO 63091
// for i = 1 to mc_bases do
62892: LD_ADDR_VAR 0 5
62896: PUSH
62897: DOUBLE
62898: LD_INT 1
62900: DEC
62901: ST_TO_ADDR
62902: LD_EXP 99
62906: PUSH
62907: FOR_TO
62908: IFFALSE 63089
// if building in mc_bases [ i ] then
62910: LD_VAR 0 1
62914: PUSH
62915: LD_EXP 99
62919: PUSH
62920: LD_VAR 0 5
62924: ARRAY
62925: IN
62926: IFFALSE 63087
// begin tmp := mc_bases [ i ] diff building ;
62928: LD_ADDR_VAR 0 6
62932: PUSH
62933: LD_EXP 99
62937: PUSH
62938: LD_VAR 0 5
62942: ARRAY
62943: PUSH
62944: LD_VAR 0 1
62948: DIFF
62949: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
62950: LD_ADDR_EXP 99
62954: PUSH
62955: LD_EXP 99
62959: PPUSH
62960: LD_VAR 0 5
62964: PPUSH
62965: LD_VAR 0 6
62969: PPUSH
62970: CALL_OW 1
62974: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
62975: LD_VAR 0 1
62979: PUSH
62980: LD_EXP 107
62984: PUSH
62985: LD_VAR 0 5
62989: ARRAY
62990: IN
62991: IFFALSE 63030
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
62993: LD_ADDR_EXP 107
62997: PUSH
62998: LD_EXP 107
63002: PPUSH
63003: LD_VAR 0 5
63007: PPUSH
63008: LD_EXP 107
63012: PUSH
63013: LD_VAR 0 5
63017: ARRAY
63018: PUSH
63019: LD_VAR 0 1
63023: DIFF
63024: PPUSH
63025: CALL_OW 1
63029: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
63030: LD_VAR 0 1
63034: PUSH
63035: LD_EXP 108
63039: PUSH
63040: LD_VAR 0 5
63044: ARRAY
63045: IN
63046: IFFALSE 63085
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
63048: LD_ADDR_EXP 108
63052: PUSH
63053: LD_EXP 108
63057: PPUSH
63058: LD_VAR 0 5
63062: PPUSH
63063: LD_EXP 108
63067: PUSH
63068: LD_VAR 0 5
63072: ARRAY
63073: PUSH
63074: LD_VAR 0 1
63078: DIFF
63079: PPUSH
63080: CALL_OW 1
63084: ST_TO_ADDR
// break ;
63085: GO 63089
// end ;
63087: GO 62907
63089: POP
63090: POP
// end ;
63091: LD_VAR 0 4
63095: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
63096: LD_INT 0
63098: PPUSH
63099: PPUSH
63100: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
63101: LD_EXP 99
63105: NOT
63106: PUSH
63107: LD_EXP 97
63111: NOT
63112: OR
63113: PUSH
63114: LD_VAR 0 3
63118: PUSH
63119: LD_EXP 125
63123: IN
63124: NOT
63125: OR
63126: IFFALSE 63130
// exit ;
63128: GO 63253
// for i = 1 to mc_vehicles do
63130: LD_ADDR_VAR 0 6
63134: PUSH
63135: DOUBLE
63136: LD_INT 1
63138: DEC
63139: ST_TO_ADDR
63140: LD_EXP 118
63144: PUSH
63145: FOR_TO
63146: IFFALSE 63251
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
63148: LD_VAR 0 2
63152: PUSH
63153: LD_EXP 118
63157: PUSH
63158: LD_VAR 0 6
63162: ARRAY
63163: IN
63164: PUSH
63165: LD_VAR 0 1
63169: PUSH
63170: LD_EXP 118
63174: PUSH
63175: LD_VAR 0 6
63179: ARRAY
63180: IN
63181: OR
63182: IFFALSE 63249
// begin tmp := mc_vehicles [ i ] diff old ;
63184: LD_ADDR_VAR 0 7
63188: PUSH
63189: LD_EXP 118
63193: PUSH
63194: LD_VAR 0 6
63198: ARRAY
63199: PUSH
63200: LD_VAR 0 2
63204: DIFF
63205: ST_TO_ADDR
// tmp := tmp diff new ;
63206: LD_ADDR_VAR 0 7
63210: PUSH
63211: LD_VAR 0 7
63215: PUSH
63216: LD_VAR 0 1
63220: DIFF
63221: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
63222: LD_ADDR_EXP 118
63226: PUSH
63227: LD_EXP 118
63231: PPUSH
63232: LD_VAR 0 6
63236: PPUSH
63237: LD_VAR 0 7
63241: PPUSH
63242: CALL_OW 1
63246: ST_TO_ADDR
// break ;
63247: GO 63251
// end ;
63249: GO 63145
63251: POP
63252: POP
// end ;
63253: LD_VAR 0 5
63257: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
63258: LD_INT 0
63260: PPUSH
63261: PPUSH
63262: PPUSH
63263: PPUSH
// if not mc_bases or not skirmish then
63264: LD_EXP 99
63268: NOT
63269: PUSH
63270: LD_EXP 97
63274: NOT
63275: OR
63276: IFFALSE 63280
// exit ;
63278: GO 63662
// side := GetSide ( vehicle ) ;
63280: LD_ADDR_VAR 0 5
63284: PUSH
63285: LD_VAR 0 1
63289: PPUSH
63290: CALL_OW 255
63294: ST_TO_ADDR
// for i = 1 to mc_bases do
63295: LD_ADDR_VAR 0 4
63299: PUSH
63300: DOUBLE
63301: LD_INT 1
63303: DEC
63304: ST_TO_ADDR
63305: LD_EXP 99
63309: PUSH
63310: FOR_TO
63311: IFFALSE 63660
// begin if factory in mc_bases [ i ] then
63313: LD_VAR 0 2
63317: PUSH
63318: LD_EXP 99
63322: PUSH
63323: LD_VAR 0 4
63327: ARRAY
63328: IN
63329: IFFALSE 63658
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
63331: LD_EXP 121
63335: PUSH
63336: LD_VAR 0 4
63340: ARRAY
63341: PUSH
63342: LD_EXP 110
63346: PUSH
63347: LD_VAR 0 4
63351: ARRAY
63352: LESS
63353: PUSH
63354: LD_VAR 0 1
63358: PPUSH
63359: CALL_OW 264
63363: PUSH
63364: LD_INT 31
63366: PUSH
63367: LD_INT 32
63369: PUSH
63370: LD_INT 51
63372: PUSH
63373: LD_INT 89
63375: PUSH
63376: LD_INT 12
63378: PUSH
63379: LD_INT 30
63381: PUSH
63382: LD_INT 98
63384: PUSH
63385: LD_INT 11
63387: PUSH
63388: LD_INT 53
63390: PUSH
63391: LD_INT 14
63393: PUSH
63394: LD_INT 91
63396: PUSH
63397: LD_INT 29
63399: PUSH
63400: LD_INT 99
63402: PUSH
63403: LD_INT 13
63405: PUSH
63406: LD_INT 52
63408: PUSH
63409: LD_INT 88
63411: PUSH
63412: LD_INT 48
63414: PUSH
63415: LD_INT 8
63417: PUSH
63418: EMPTY
63419: LIST
63420: LIST
63421: LIST
63422: LIST
63423: LIST
63424: LIST
63425: LIST
63426: LIST
63427: LIST
63428: LIST
63429: LIST
63430: LIST
63431: LIST
63432: LIST
63433: LIST
63434: LIST
63435: LIST
63436: LIST
63437: IN
63438: NOT
63439: AND
63440: IFFALSE 63488
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
63442: LD_ADDR_EXP 121
63446: PUSH
63447: LD_EXP 121
63451: PPUSH
63452: LD_VAR 0 4
63456: PUSH
63457: LD_EXP 121
63461: PUSH
63462: LD_VAR 0 4
63466: ARRAY
63467: PUSH
63468: LD_INT 1
63470: PLUS
63471: PUSH
63472: EMPTY
63473: LIST
63474: LIST
63475: PPUSH
63476: LD_VAR 0 1
63480: PPUSH
63481: CALL 72472 0 3
63485: ST_TO_ADDR
63486: GO 63532
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
63488: LD_ADDR_EXP 118
63492: PUSH
63493: LD_EXP 118
63497: PPUSH
63498: LD_VAR 0 4
63502: PUSH
63503: LD_EXP 118
63507: PUSH
63508: LD_VAR 0 4
63512: ARRAY
63513: PUSH
63514: LD_INT 1
63516: PLUS
63517: PUSH
63518: EMPTY
63519: LIST
63520: LIST
63521: PPUSH
63522: LD_VAR 0 1
63526: PPUSH
63527: CALL 72472 0 3
63531: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
63532: LD_VAR 0 1
63536: PPUSH
63537: CALL_OW 263
63541: PUSH
63542: LD_INT 2
63544: EQUAL
63545: IFFALSE 63574
// begin repeat wait ( 0 0$3 ) ;
63547: LD_INT 105
63549: PPUSH
63550: CALL_OW 67
// Connect ( vehicle ) ;
63554: LD_VAR 0 1
63558: PPUSH
63559: CALL 75441 0 1
// until IsControledBy ( vehicle ) ;
63563: LD_VAR 0 1
63567: PPUSH
63568: CALL_OW 312
63572: IFFALSE 63547
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
63574: LD_VAR 0 1
63578: PPUSH
63579: LD_EXP 123
63583: PUSH
63584: LD_VAR 0 4
63588: ARRAY
63589: PPUSH
63590: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
63594: LD_VAR 0 1
63598: PPUSH
63599: CALL_OW 263
63603: PUSH
63604: LD_INT 1
63606: NONEQUAL
63607: IFFALSE 63611
// break ;
63609: GO 63660
// repeat wait ( 0 0$1 ) ;
63611: LD_INT 35
63613: PPUSH
63614: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
63618: LD_VAR 0 1
63622: PPUSH
63623: LD_EXP 123
63627: PUSH
63628: LD_VAR 0 4
63632: ARRAY
63633: PPUSH
63634: CALL_OW 308
63638: IFFALSE 63611
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
63640: LD_VAR 0 1
63644: PPUSH
63645: CALL_OW 311
63649: PPUSH
63650: CALL_OW 121
// exit ;
63654: POP
63655: POP
63656: GO 63662
// end ; end ;
63658: GO 63310
63660: POP
63661: POP
// end ;
63662: LD_VAR 0 3
63666: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
63667: LD_INT 0
63669: PPUSH
63670: PPUSH
63671: PPUSH
63672: PPUSH
// if not mc_bases or not skirmish then
63673: LD_EXP 99
63677: NOT
63678: PUSH
63679: LD_EXP 97
63683: NOT
63684: OR
63685: IFFALSE 63689
// exit ;
63687: GO 64042
// repeat wait ( 0 0$1 ) ;
63689: LD_INT 35
63691: PPUSH
63692: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
63696: LD_VAR 0 2
63700: PPUSH
63701: LD_VAR 0 3
63705: PPUSH
63706: CALL_OW 284
63710: IFFALSE 63689
// if GetResourceTypeXY ( x , y ) = mat_artefact then
63712: LD_VAR 0 2
63716: PPUSH
63717: LD_VAR 0 3
63721: PPUSH
63722: CALL_OW 283
63726: PUSH
63727: LD_INT 4
63729: EQUAL
63730: IFFALSE 63734
// exit ;
63732: GO 64042
// for i = 1 to mc_bases do
63734: LD_ADDR_VAR 0 7
63738: PUSH
63739: DOUBLE
63740: LD_INT 1
63742: DEC
63743: ST_TO_ADDR
63744: LD_EXP 99
63748: PUSH
63749: FOR_TO
63750: IFFALSE 64040
// begin if mc_crates_area [ i ] then
63752: LD_EXP 117
63756: PUSH
63757: LD_VAR 0 7
63761: ARRAY
63762: IFFALSE 63873
// for j in mc_crates_area [ i ] do
63764: LD_ADDR_VAR 0 8
63768: PUSH
63769: LD_EXP 117
63773: PUSH
63774: LD_VAR 0 7
63778: ARRAY
63779: PUSH
63780: FOR_IN
63781: IFFALSE 63871
// if InArea ( x , y , j ) then
63783: LD_VAR 0 2
63787: PPUSH
63788: LD_VAR 0 3
63792: PPUSH
63793: LD_VAR 0 8
63797: PPUSH
63798: CALL_OW 309
63802: IFFALSE 63869
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
63804: LD_ADDR_EXP 115
63808: PUSH
63809: LD_EXP 115
63813: PPUSH
63814: LD_VAR 0 7
63818: PUSH
63819: LD_EXP 115
63823: PUSH
63824: LD_VAR 0 7
63828: ARRAY
63829: PUSH
63830: LD_INT 1
63832: PLUS
63833: PUSH
63834: EMPTY
63835: LIST
63836: LIST
63837: PPUSH
63838: LD_VAR 0 4
63842: PUSH
63843: LD_VAR 0 2
63847: PUSH
63848: LD_VAR 0 3
63852: PUSH
63853: EMPTY
63854: LIST
63855: LIST
63856: LIST
63857: PPUSH
63858: CALL 72472 0 3
63862: ST_TO_ADDR
// exit ;
63863: POP
63864: POP
63865: POP
63866: POP
63867: GO 64042
// end ;
63869: GO 63780
63871: POP
63872: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63873: LD_ADDR_VAR 0 9
63877: PUSH
63878: LD_EXP 99
63882: PUSH
63883: LD_VAR 0 7
63887: ARRAY
63888: PPUSH
63889: LD_INT 2
63891: PUSH
63892: LD_INT 30
63894: PUSH
63895: LD_INT 0
63897: PUSH
63898: EMPTY
63899: LIST
63900: LIST
63901: PUSH
63902: LD_INT 30
63904: PUSH
63905: LD_INT 1
63907: PUSH
63908: EMPTY
63909: LIST
63910: LIST
63911: PUSH
63912: EMPTY
63913: LIST
63914: LIST
63915: LIST
63916: PPUSH
63917: CALL_OW 72
63921: ST_TO_ADDR
// if not depot then
63922: LD_VAR 0 9
63926: NOT
63927: IFFALSE 63931
// continue ;
63929: GO 63749
// for j in depot do
63931: LD_ADDR_VAR 0 8
63935: PUSH
63936: LD_VAR 0 9
63940: PUSH
63941: FOR_IN
63942: IFFALSE 64036
// if GetDistUnitXY ( j , x , y ) < 30 then
63944: LD_VAR 0 8
63948: PPUSH
63949: LD_VAR 0 2
63953: PPUSH
63954: LD_VAR 0 3
63958: PPUSH
63959: CALL_OW 297
63963: PUSH
63964: LD_INT 30
63966: LESS
63967: IFFALSE 64034
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
63969: LD_ADDR_EXP 115
63973: PUSH
63974: LD_EXP 115
63978: PPUSH
63979: LD_VAR 0 7
63983: PUSH
63984: LD_EXP 115
63988: PUSH
63989: LD_VAR 0 7
63993: ARRAY
63994: PUSH
63995: LD_INT 1
63997: PLUS
63998: PUSH
63999: EMPTY
64000: LIST
64001: LIST
64002: PPUSH
64003: LD_VAR 0 4
64007: PUSH
64008: LD_VAR 0 2
64012: PUSH
64013: LD_VAR 0 3
64017: PUSH
64018: EMPTY
64019: LIST
64020: LIST
64021: LIST
64022: PPUSH
64023: CALL 72472 0 3
64027: ST_TO_ADDR
// exit ;
64028: POP
64029: POP
64030: POP
64031: POP
64032: GO 64042
// end ;
64034: GO 63941
64036: POP
64037: POP
// end ;
64038: GO 63749
64040: POP
64041: POP
// end ;
64042: LD_VAR 0 6
64046: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
64047: LD_INT 0
64049: PPUSH
64050: PPUSH
64051: PPUSH
64052: PPUSH
// if not mc_bases or not skirmish then
64053: LD_EXP 99
64057: NOT
64058: PUSH
64059: LD_EXP 97
64063: NOT
64064: OR
64065: IFFALSE 64069
// exit ;
64067: GO 64346
// side := GetSide ( lab ) ;
64069: LD_ADDR_VAR 0 4
64073: PUSH
64074: LD_VAR 0 2
64078: PPUSH
64079: CALL_OW 255
64083: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
64084: LD_VAR 0 4
64088: PUSH
64089: LD_EXP 125
64093: IN
64094: NOT
64095: PUSH
64096: LD_EXP 126
64100: NOT
64101: OR
64102: PUSH
64103: LD_EXP 99
64107: NOT
64108: OR
64109: IFFALSE 64113
// exit ;
64111: GO 64346
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
64113: LD_ADDR_EXP 126
64117: PUSH
64118: LD_EXP 126
64122: PPUSH
64123: LD_VAR 0 4
64127: PPUSH
64128: LD_EXP 126
64132: PUSH
64133: LD_VAR 0 4
64137: ARRAY
64138: PUSH
64139: LD_VAR 0 1
64143: DIFF
64144: PPUSH
64145: CALL_OW 1
64149: ST_TO_ADDR
// for i = 1 to mc_bases do
64150: LD_ADDR_VAR 0 5
64154: PUSH
64155: DOUBLE
64156: LD_INT 1
64158: DEC
64159: ST_TO_ADDR
64160: LD_EXP 99
64164: PUSH
64165: FOR_TO
64166: IFFALSE 64344
// begin if lab in mc_bases [ i ] then
64168: LD_VAR 0 2
64172: PUSH
64173: LD_EXP 99
64177: PUSH
64178: LD_VAR 0 5
64182: ARRAY
64183: IN
64184: IFFALSE 64342
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
64186: LD_VAR 0 1
64190: PUSH
64191: LD_INT 11
64193: PUSH
64194: LD_INT 4
64196: PUSH
64197: LD_INT 3
64199: PUSH
64200: LD_INT 2
64202: PUSH
64203: EMPTY
64204: LIST
64205: LIST
64206: LIST
64207: LIST
64208: IN
64209: PUSH
64210: LD_EXP 129
64214: PUSH
64215: LD_VAR 0 5
64219: ARRAY
64220: AND
64221: IFFALSE 64342
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
64223: LD_ADDR_VAR 0 6
64227: PUSH
64228: LD_EXP 129
64232: PUSH
64233: LD_VAR 0 5
64237: ARRAY
64238: PUSH
64239: LD_INT 1
64241: ARRAY
64242: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64243: LD_ADDR_EXP 129
64247: PUSH
64248: LD_EXP 129
64252: PPUSH
64253: LD_VAR 0 5
64257: PPUSH
64258: EMPTY
64259: PPUSH
64260: CALL_OW 1
64264: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
64265: LD_VAR 0 6
64269: PPUSH
64270: LD_INT 0
64272: PPUSH
64273: CALL_OW 109
// ComExitBuilding ( tmp ) ;
64277: LD_VAR 0 6
64281: PPUSH
64282: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
64286: LD_ADDR_EXP 128
64290: PUSH
64291: LD_EXP 128
64295: PPUSH
64296: LD_VAR 0 5
64300: PPUSH
64301: LD_EXP 128
64305: PUSH
64306: LD_VAR 0 5
64310: ARRAY
64311: PPUSH
64312: LD_INT 1
64314: PPUSH
64315: LD_VAR 0 6
64319: PPUSH
64320: CALL_OW 2
64324: PPUSH
64325: CALL_OW 1
64329: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
64330: LD_VAR 0 5
64334: PPUSH
64335: LD_INT 112
64337: PPUSH
64338: CALL 40832 0 2
// end ; end ; end ;
64342: GO 64165
64344: POP
64345: POP
// end ;
64346: LD_VAR 0 3
64350: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
64351: LD_INT 0
64353: PPUSH
64354: PPUSH
64355: PPUSH
64356: PPUSH
64357: PPUSH
64358: PPUSH
64359: PPUSH
64360: PPUSH
// if not mc_bases or not skirmish then
64361: LD_EXP 99
64365: NOT
64366: PUSH
64367: LD_EXP 97
64371: NOT
64372: OR
64373: IFFALSE 64377
// exit ;
64375: GO 65746
// for i = 1 to mc_bases do
64377: LD_ADDR_VAR 0 3
64381: PUSH
64382: DOUBLE
64383: LD_INT 1
64385: DEC
64386: ST_TO_ADDR
64387: LD_EXP 99
64391: PUSH
64392: FOR_TO
64393: IFFALSE 65744
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
64395: LD_VAR 0 1
64399: PUSH
64400: LD_EXP 99
64404: PUSH
64405: LD_VAR 0 3
64409: ARRAY
64410: IN
64411: PUSH
64412: LD_VAR 0 1
64416: PUSH
64417: LD_EXP 106
64421: PUSH
64422: LD_VAR 0 3
64426: ARRAY
64427: IN
64428: OR
64429: PUSH
64430: LD_VAR 0 1
64434: PUSH
64435: LD_EXP 121
64439: PUSH
64440: LD_VAR 0 3
64444: ARRAY
64445: IN
64446: OR
64447: PUSH
64448: LD_VAR 0 1
64452: PUSH
64453: LD_EXP 118
64457: PUSH
64458: LD_VAR 0 3
64462: ARRAY
64463: IN
64464: OR
64465: PUSH
64466: LD_VAR 0 1
64470: PUSH
64471: LD_EXP 128
64475: PUSH
64476: LD_VAR 0 3
64480: ARRAY
64481: IN
64482: OR
64483: PUSH
64484: LD_VAR 0 1
64488: PUSH
64489: LD_EXP 129
64493: PUSH
64494: LD_VAR 0 3
64498: ARRAY
64499: IN
64500: OR
64501: IFFALSE 65742
// begin if un in mc_ape [ i ] then
64503: LD_VAR 0 1
64507: PUSH
64508: LD_EXP 128
64512: PUSH
64513: LD_VAR 0 3
64517: ARRAY
64518: IN
64519: IFFALSE 64558
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
64521: LD_ADDR_EXP 128
64525: PUSH
64526: LD_EXP 128
64530: PPUSH
64531: LD_VAR 0 3
64535: PPUSH
64536: LD_EXP 128
64540: PUSH
64541: LD_VAR 0 3
64545: ARRAY
64546: PUSH
64547: LD_VAR 0 1
64551: DIFF
64552: PPUSH
64553: CALL_OW 1
64557: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
64558: LD_VAR 0 1
64562: PUSH
64563: LD_EXP 129
64567: PUSH
64568: LD_VAR 0 3
64572: ARRAY
64573: IN
64574: IFFALSE 64598
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64576: LD_ADDR_EXP 129
64580: PUSH
64581: LD_EXP 129
64585: PPUSH
64586: LD_VAR 0 3
64590: PPUSH
64591: EMPTY
64592: PPUSH
64593: CALL_OW 1
64597: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
64598: LD_VAR 0 1
64602: PPUSH
64603: CALL_OW 247
64607: PUSH
64608: LD_INT 2
64610: EQUAL
64611: PUSH
64612: LD_VAR 0 1
64616: PPUSH
64617: CALL_OW 110
64621: PUSH
64622: LD_INT 20
64624: EQUAL
64625: PUSH
64626: LD_VAR 0 1
64630: PUSH
64631: LD_EXP 121
64635: PUSH
64636: LD_VAR 0 3
64640: ARRAY
64641: IN
64642: OR
64643: PUSH
64644: LD_VAR 0 1
64648: PPUSH
64649: CALL_OW 264
64653: PUSH
64654: LD_INT 12
64656: PUSH
64657: LD_INT 51
64659: PUSH
64660: LD_INT 89
64662: PUSH
64663: LD_INT 32
64665: PUSH
64666: LD_INT 13
64668: PUSH
64669: LD_INT 52
64671: PUSH
64672: LD_INT 31
64674: PUSH
64675: EMPTY
64676: LIST
64677: LIST
64678: LIST
64679: LIST
64680: LIST
64681: LIST
64682: LIST
64683: IN
64684: OR
64685: AND
64686: IFFALSE 64994
// begin if un in mc_defender [ i ] then
64688: LD_VAR 0 1
64692: PUSH
64693: LD_EXP 121
64697: PUSH
64698: LD_VAR 0 3
64702: ARRAY
64703: IN
64704: IFFALSE 64743
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
64706: LD_ADDR_EXP 121
64710: PUSH
64711: LD_EXP 121
64715: PPUSH
64716: LD_VAR 0 3
64720: PPUSH
64721: LD_EXP 121
64725: PUSH
64726: LD_VAR 0 3
64730: ARRAY
64731: PUSH
64732: LD_VAR 0 1
64736: DIFF
64737: PPUSH
64738: CALL_OW 1
64742: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
64743: LD_ADDR_VAR 0 8
64747: PUSH
64748: LD_VAR 0 3
64752: PPUSH
64753: LD_INT 3
64755: PPUSH
64756: CALL 61402 0 2
64760: ST_TO_ADDR
// if fac then
64761: LD_VAR 0 8
64765: IFFALSE 64994
// begin for j in fac do
64767: LD_ADDR_VAR 0 4
64771: PUSH
64772: LD_VAR 0 8
64776: PUSH
64777: FOR_IN
64778: IFFALSE 64992
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
64780: LD_ADDR_VAR 0 9
64784: PUSH
64785: LD_VAR 0 8
64789: PPUSH
64790: LD_VAR 0 1
64794: PPUSH
64795: CALL_OW 265
64799: PPUSH
64800: LD_VAR 0 1
64804: PPUSH
64805: CALL_OW 262
64809: PPUSH
64810: LD_VAR 0 1
64814: PPUSH
64815: CALL_OW 263
64819: PPUSH
64820: LD_VAR 0 1
64824: PPUSH
64825: CALL_OW 264
64829: PPUSH
64830: CALL 69970 0 5
64834: ST_TO_ADDR
// if components then
64835: LD_VAR 0 9
64839: IFFALSE 64990
// begin if GetWeapon ( un ) = ar_control_tower then
64841: LD_VAR 0 1
64845: PPUSH
64846: CALL_OW 264
64850: PUSH
64851: LD_INT 31
64853: EQUAL
64854: IFFALSE 64971
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
64856: LD_VAR 0 1
64860: PPUSH
64861: CALL_OW 311
64865: PPUSH
64866: LD_INT 0
64868: PPUSH
64869: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
64873: LD_ADDR_EXP 139
64877: PUSH
64878: LD_EXP 139
64882: PPUSH
64883: LD_VAR 0 3
64887: PPUSH
64888: LD_EXP 139
64892: PUSH
64893: LD_VAR 0 3
64897: ARRAY
64898: PUSH
64899: LD_VAR 0 1
64903: PPUSH
64904: CALL_OW 311
64908: DIFF
64909: PPUSH
64910: CALL_OW 1
64914: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
64915: LD_ADDR_VAR 0 7
64919: PUSH
64920: LD_EXP 120
64924: PUSH
64925: LD_VAR 0 3
64929: ARRAY
64930: PPUSH
64931: LD_INT 1
64933: PPUSH
64934: LD_VAR 0 9
64938: PPUSH
64939: CALL_OW 2
64943: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
64944: LD_ADDR_EXP 120
64948: PUSH
64949: LD_EXP 120
64953: PPUSH
64954: LD_VAR 0 3
64958: PPUSH
64959: LD_VAR 0 7
64963: PPUSH
64964: CALL_OW 1
64968: ST_TO_ADDR
// end else
64969: GO 64988
// MC_InsertProduceList ( i , [ components ] ) ;
64971: LD_VAR 0 3
64975: PPUSH
64976: LD_VAR 0 9
64980: PUSH
64981: EMPTY
64982: LIST
64983: PPUSH
64984: CALL 60947 0 2
// break ;
64988: GO 64992
// end ; end ;
64990: GO 64777
64992: POP
64993: POP
// end ; end ; if GetType ( un ) = unit_building then
64994: LD_VAR 0 1
64998: PPUSH
64999: CALL_OW 247
65003: PUSH
65004: LD_INT 3
65006: EQUAL
65007: IFFALSE 65410
// begin btype := GetBType ( un ) ;
65009: LD_ADDR_VAR 0 5
65013: PUSH
65014: LD_VAR 0 1
65018: PPUSH
65019: CALL_OW 266
65023: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
65024: LD_VAR 0 5
65028: PUSH
65029: LD_INT 29
65031: PUSH
65032: LD_INT 30
65034: PUSH
65035: EMPTY
65036: LIST
65037: LIST
65038: IN
65039: IFFALSE 65112
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
65041: LD_VAR 0 1
65045: PPUSH
65046: CALL_OW 250
65050: PPUSH
65051: LD_VAR 0 1
65055: PPUSH
65056: CALL_OW 251
65060: PPUSH
65061: LD_VAR 0 1
65065: PPUSH
65066: CALL_OW 255
65070: PPUSH
65071: CALL_OW 440
65075: NOT
65076: IFFALSE 65112
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
65078: LD_VAR 0 1
65082: PPUSH
65083: CALL_OW 250
65087: PPUSH
65088: LD_VAR 0 1
65092: PPUSH
65093: CALL_OW 251
65097: PPUSH
65098: LD_VAR 0 1
65102: PPUSH
65103: CALL_OW 255
65107: PPUSH
65108: CALL_OW 441
// end ; if btype = b_warehouse then
65112: LD_VAR 0 5
65116: PUSH
65117: LD_INT 1
65119: EQUAL
65120: IFFALSE 65138
// begin btype := b_depot ;
65122: LD_ADDR_VAR 0 5
65126: PUSH
65127: LD_INT 0
65129: ST_TO_ADDR
// pos := 1 ;
65130: LD_ADDR_VAR 0 6
65134: PUSH
65135: LD_INT 1
65137: ST_TO_ADDR
// end ; if btype = b_factory then
65138: LD_VAR 0 5
65142: PUSH
65143: LD_INT 3
65145: EQUAL
65146: IFFALSE 65164
// begin btype := b_workshop ;
65148: LD_ADDR_VAR 0 5
65152: PUSH
65153: LD_INT 2
65155: ST_TO_ADDR
// pos := 1 ;
65156: LD_ADDR_VAR 0 6
65160: PUSH
65161: LD_INT 1
65163: ST_TO_ADDR
// end ; if btype = b_barracks then
65164: LD_VAR 0 5
65168: PUSH
65169: LD_INT 5
65171: EQUAL
65172: IFFALSE 65182
// btype := b_armoury ;
65174: LD_ADDR_VAR 0 5
65178: PUSH
65179: LD_INT 4
65181: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
65182: LD_VAR 0 5
65186: PUSH
65187: LD_INT 7
65189: PUSH
65190: LD_INT 8
65192: PUSH
65193: EMPTY
65194: LIST
65195: LIST
65196: IN
65197: IFFALSE 65207
// btype := b_lab ;
65199: LD_ADDR_VAR 0 5
65203: PUSH
65204: LD_INT 6
65206: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
65207: LD_ADDR_EXP 104
65211: PUSH
65212: LD_EXP 104
65216: PPUSH
65217: LD_VAR 0 3
65221: PUSH
65222: LD_EXP 104
65226: PUSH
65227: LD_VAR 0 3
65231: ARRAY
65232: PUSH
65233: LD_INT 1
65235: PLUS
65236: PUSH
65237: EMPTY
65238: LIST
65239: LIST
65240: PPUSH
65241: LD_VAR 0 5
65245: PUSH
65246: LD_VAR 0 1
65250: PPUSH
65251: CALL_OW 250
65255: PUSH
65256: LD_VAR 0 1
65260: PPUSH
65261: CALL_OW 251
65265: PUSH
65266: LD_VAR 0 1
65270: PPUSH
65271: CALL_OW 254
65275: PUSH
65276: EMPTY
65277: LIST
65278: LIST
65279: LIST
65280: LIST
65281: PPUSH
65282: CALL 72472 0 3
65286: ST_TO_ADDR
// if pos = 1 then
65287: LD_VAR 0 6
65291: PUSH
65292: LD_INT 1
65294: EQUAL
65295: IFFALSE 65410
// begin tmp := mc_build_list [ i ] ;
65297: LD_ADDR_VAR 0 7
65301: PUSH
65302: LD_EXP 104
65306: PUSH
65307: LD_VAR 0 3
65311: ARRAY
65312: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
65313: LD_VAR 0 7
65317: PPUSH
65318: LD_INT 2
65320: PUSH
65321: LD_INT 30
65323: PUSH
65324: LD_INT 0
65326: PUSH
65327: EMPTY
65328: LIST
65329: LIST
65330: PUSH
65331: LD_INT 30
65333: PUSH
65334: LD_INT 1
65336: PUSH
65337: EMPTY
65338: LIST
65339: LIST
65340: PUSH
65341: EMPTY
65342: LIST
65343: LIST
65344: LIST
65345: PPUSH
65346: CALL_OW 72
65350: IFFALSE 65360
// pos := 2 ;
65352: LD_ADDR_VAR 0 6
65356: PUSH
65357: LD_INT 2
65359: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
65360: LD_ADDR_VAR 0 7
65364: PUSH
65365: LD_VAR 0 7
65369: PPUSH
65370: LD_VAR 0 6
65374: PPUSH
65375: LD_VAR 0 7
65379: PPUSH
65380: CALL 72798 0 3
65384: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
65385: LD_ADDR_EXP 104
65389: PUSH
65390: LD_EXP 104
65394: PPUSH
65395: LD_VAR 0 3
65399: PPUSH
65400: LD_VAR 0 7
65404: PPUSH
65405: CALL_OW 1
65409: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
65410: LD_VAR 0 1
65414: PUSH
65415: LD_EXP 99
65419: PUSH
65420: LD_VAR 0 3
65424: ARRAY
65425: IN
65426: IFFALSE 65465
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
65428: LD_ADDR_EXP 99
65432: PUSH
65433: LD_EXP 99
65437: PPUSH
65438: LD_VAR 0 3
65442: PPUSH
65443: LD_EXP 99
65447: PUSH
65448: LD_VAR 0 3
65452: ARRAY
65453: PUSH
65454: LD_VAR 0 1
65458: DIFF
65459: PPUSH
65460: CALL_OW 1
65464: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
65465: LD_VAR 0 1
65469: PUSH
65470: LD_EXP 106
65474: PUSH
65475: LD_VAR 0 3
65479: ARRAY
65480: IN
65481: IFFALSE 65520
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
65483: LD_ADDR_EXP 106
65487: PUSH
65488: LD_EXP 106
65492: PPUSH
65493: LD_VAR 0 3
65497: PPUSH
65498: LD_EXP 106
65502: PUSH
65503: LD_VAR 0 3
65507: ARRAY
65508: PUSH
65509: LD_VAR 0 1
65513: DIFF
65514: PPUSH
65515: CALL_OW 1
65519: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
65520: LD_VAR 0 1
65524: PUSH
65525: LD_EXP 118
65529: PUSH
65530: LD_VAR 0 3
65534: ARRAY
65535: IN
65536: IFFALSE 65575
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
65538: LD_ADDR_EXP 118
65542: PUSH
65543: LD_EXP 118
65547: PPUSH
65548: LD_VAR 0 3
65552: PPUSH
65553: LD_EXP 118
65557: PUSH
65558: LD_VAR 0 3
65562: ARRAY
65563: PUSH
65564: LD_VAR 0 1
65568: DIFF
65569: PPUSH
65570: CALL_OW 1
65574: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
65575: LD_VAR 0 1
65579: PUSH
65580: LD_EXP 121
65584: PUSH
65585: LD_VAR 0 3
65589: ARRAY
65590: IN
65591: IFFALSE 65630
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
65593: LD_ADDR_EXP 121
65597: PUSH
65598: LD_EXP 121
65602: PPUSH
65603: LD_VAR 0 3
65607: PPUSH
65608: LD_EXP 121
65612: PUSH
65613: LD_VAR 0 3
65617: ARRAY
65618: PUSH
65619: LD_VAR 0 1
65623: DIFF
65624: PPUSH
65625: CALL_OW 1
65629: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
65630: LD_VAR 0 1
65634: PUSH
65635: LD_EXP 108
65639: PUSH
65640: LD_VAR 0 3
65644: ARRAY
65645: IN
65646: IFFALSE 65685
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
65648: LD_ADDR_EXP 108
65652: PUSH
65653: LD_EXP 108
65657: PPUSH
65658: LD_VAR 0 3
65662: PPUSH
65663: LD_EXP 108
65667: PUSH
65668: LD_VAR 0 3
65672: ARRAY
65673: PUSH
65674: LD_VAR 0 1
65678: DIFF
65679: PPUSH
65680: CALL_OW 1
65684: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
65685: LD_VAR 0 1
65689: PUSH
65690: LD_EXP 107
65694: PUSH
65695: LD_VAR 0 3
65699: ARRAY
65700: IN
65701: IFFALSE 65740
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
65703: LD_ADDR_EXP 107
65707: PUSH
65708: LD_EXP 107
65712: PPUSH
65713: LD_VAR 0 3
65717: PPUSH
65718: LD_EXP 107
65722: PUSH
65723: LD_VAR 0 3
65727: ARRAY
65728: PUSH
65729: LD_VAR 0 1
65733: DIFF
65734: PPUSH
65735: CALL_OW 1
65739: ST_TO_ADDR
// end ; break ;
65740: GO 65744
// end ;
65742: GO 64392
65744: POP
65745: POP
// end ;
65746: LD_VAR 0 2
65750: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
65751: LD_INT 0
65753: PPUSH
65754: PPUSH
65755: PPUSH
// if not mc_bases or not skirmish then
65756: LD_EXP 99
65760: NOT
65761: PUSH
65762: LD_EXP 97
65766: NOT
65767: OR
65768: IFFALSE 65772
// exit ;
65770: GO 65987
// for i = 1 to mc_bases do
65772: LD_ADDR_VAR 0 3
65776: PUSH
65777: DOUBLE
65778: LD_INT 1
65780: DEC
65781: ST_TO_ADDR
65782: LD_EXP 99
65786: PUSH
65787: FOR_TO
65788: IFFALSE 65985
// begin if building in mc_construct_list [ i ] then
65790: LD_VAR 0 1
65794: PUSH
65795: LD_EXP 106
65799: PUSH
65800: LD_VAR 0 3
65804: ARRAY
65805: IN
65806: IFFALSE 65983
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
65808: LD_ADDR_EXP 106
65812: PUSH
65813: LD_EXP 106
65817: PPUSH
65818: LD_VAR 0 3
65822: PPUSH
65823: LD_EXP 106
65827: PUSH
65828: LD_VAR 0 3
65832: ARRAY
65833: PUSH
65834: LD_VAR 0 1
65838: DIFF
65839: PPUSH
65840: CALL_OW 1
65844: ST_TO_ADDR
// if building in mc_lab [ i ] then
65845: LD_VAR 0 1
65849: PUSH
65850: LD_EXP 132
65854: PUSH
65855: LD_VAR 0 3
65859: ARRAY
65860: IN
65861: IFFALSE 65916
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
65863: LD_ADDR_EXP 133
65867: PUSH
65868: LD_EXP 133
65872: PPUSH
65873: LD_VAR 0 3
65877: PPUSH
65878: LD_EXP 133
65882: PUSH
65883: LD_VAR 0 3
65887: ARRAY
65888: PPUSH
65889: LD_INT 1
65891: PPUSH
65892: LD_EXP 133
65896: PUSH
65897: LD_VAR 0 3
65901: ARRAY
65902: PPUSH
65903: LD_INT 0
65905: PPUSH
65906: CALL 71890 0 4
65910: PPUSH
65911: CALL_OW 1
65915: ST_TO_ADDR
// if not building in mc_bases [ i ] then
65916: LD_VAR 0 1
65920: PUSH
65921: LD_EXP 99
65925: PUSH
65926: LD_VAR 0 3
65930: ARRAY
65931: IN
65932: NOT
65933: IFFALSE 65979
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
65935: LD_ADDR_EXP 99
65939: PUSH
65940: LD_EXP 99
65944: PPUSH
65945: LD_VAR 0 3
65949: PUSH
65950: LD_EXP 99
65954: PUSH
65955: LD_VAR 0 3
65959: ARRAY
65960: PUSH
65961: LD_INT 1
65963: PLUS
65964: PUSH
65965: EMPTY
65966: LIST
65967: LIST
65968: PPUSH
65969: LD_VAR 0 1
65973: PPUSH
65974: CALL 72472 0 3
65978: ST_TO_ADDR
// exit ;
65979: POP
65980: POP
65981: GO 65987
// end ; end ;
65983: GO 65787
65985: POP
65986: POP
// end ;
65987: LD_VAR 0 2
65991: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
65992: LD_INT 0
65994: PPUSH
65995: PPUSH
65996: PPUSH
65997: PPUSH
65998: PPUSH
65999: PPUSH
66000: PPUSH
// if not mc_bases or not skirmish then
66001: LD_EXP 99
66005: NOT
66006: PUSH
66007: LD_EXP 97
66011: NOT
66012: OR
66013: IFFALSE 66017
// exit ;
66015: GO 66678
// for i = 1 to mc_bases do
66017: LD_ADDR_VAR 0 3
66021: PUSH
66022: DOUBLE
66023: LD_INT 1
66025: DEC
66026: ST_TO_ADDR
66027: LD_EXP 99
66031: PUSH
66032: FOR_TO
66033: IFFALSE 66676
// begin if building in mc_construct_list [ i ] then
66035: LD_VAR 0 1
66039: PUSH
66040: LD_EXP 106
66044: PUSH
66045: LD_VAR 0 3
66049: ARRAY
66050: IN
66051: IFFALSE 66674
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
66053: LD_ADDR_EXP 106
66057: PUSH
66058: LD_EXP 106
66062: PPUSH
66063: LD_VAR 0 3
66067: PPUSH
66068: LD_EXP 106
66072: PUSH
66073: LD_VAR 0 3
66077: ARRAY
66078: PUSH
66079: LD_VAR 0 1
66083: DIFF
66084: PPUSH
66085: CALL_OW 1
66089: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
66090: LD_ADDR_EXP 99
66094: PUSH
66095: LD_EXP 99
66099: PPUSH
66100: LD_VAR 0 3
66104: PUSH
66105: LD_EXP 99
66109: PUSH
66110: LD_VAR 0 3
66114: ARRAY
66115: PUSH
66116: LD_INT 1
66118: PLUS
66119: PUSH
66120: EMPTY
66121: LIST
66122: LIST
66123: PPUSH
66124: LD_VAR 0 1
66128: PPUSH
66129: CALL 72472 0 3
66133: ST_TO_ADDR
// btype := GetBType ( building ) ;
66134: LD_ADDR_VAR 0 5
66138: PUSH
66139: LD_VAR 0 1
66143: PPUSH
66144: CALL_OW 266
66148: ST_TO_ADDR
// side := GetSide ( building ) ;
66149: LD_ADDR_VAR 0 8
66153: PUSH
66154: LD_VAR 0 1
66158: PPUSH
66159: CALL_OW 255
66163: ST_TO_ADDR
// if btype = b_lab then
66164: LD_VAR 0 5
66168: PUSH
66169: LD_INT 6
66171: EQUAL
66172: IFFALSE 66222
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
66174: LD_ADDR_EXP 132
66178: PUSH
66179: LD_EXP 132
66183: PPUSH
66184: LD_VAR 0 3
66188: PUSH
66189: LD_EXP 132
66193: PUSH
66194: LD_VAR 0 3
66198: ARRAY
66199: PUSH
66200: LD_INT 1
66202: PLUS
66203: PUSH
66204: EMPTY
66205: LIST
66206: LIST
66207: PPUSH
66208: LD_VAR 0 1
66212: PPUSH
66213: CALL 72472 0 3
66217: ST_TO_ADDR
// exit ;
66218: POP
66219: POP
66220: GO 66678
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
66222: LD_VAR 0 5
66226: PUSH
66227: LD_INT 0
66229: PUSH
66230: LD_INT 2
66232: PUSH
66233: LD_INT 4
66235: PUSH
66236: EMPTY
66237: LIST
66238: LIST
66239: LIST
66240: IN
66241: IFFALSE 66365
// begin if btype = b_armoury then
66243: LD_VAR 0 5
66247: PUSH
66248: LD_INT 4
66250: EQUAL
66251: IFFALSE 66261
// btype := b_barracks ;
66253: LD_ADDR_VAR 0 5
66257: PUSH
66258: LD_INT 5
66260: ST_TO_ADDR
// if btype = b_depot then
66261: LD_VAR 0 5
66265: PUSH
66266: LD_INT 0
66268: EQUAL
66269: IFFALSE 66279
// btype := b_warehouse ;
66271: LD_ADDR_VAR 0 5
66275: PUSH
66276: LD_INT 1
66278: ST_TO_ADDR
// if btype = b_workshop then
66279: LD_VAR 0 5
66283: PUSH
66284: LD_INT 2
66286: EQUAL
66287: IFFALSE 66297
// btype := b_factory ;
66289: LD_ADDR_VAR 0 5
66293: PUSH
66294: LD_INT 3
66296: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
66297: LD_VAR 0 5
66301: PPUSH
66302: LD_VAR 0 8
66306: PPUSH
66307: CALL_OW 323
66311: PUSH
66312: LD_INT 1
66314: EQUAL
66315: IFFALSE 66361
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
66317: LD_ADDR_EXP 131
66321: PUSH
66322: LD_EXP 131
66326: PPUSH
66327: LD_VAR 0 3
66331: PUSH
66332: LD_EXP 131
66336: PUSH
66337: LD_VAR 0 3
66341: ARRAY
66342: PUSH
66343: LD_INT 1
66345: PLUS
66346: PUSH
66347: EMPTY
66348: LIST
66349: LIST
66350: PPUSH
66351: LD_VAR 0 1
66355: PPUSH
66356: CALL 72472 0 3
66360: ST_TO_ADDR
// exit ;
66361: POP
66362: POP
66363: GO 66678
// end ; if btype in [ b_bunker , b_turret ] then
66365: LD_VAR 0 5
66369: PUSH
66370: LD_INT 32
66372: PUSH
66373: LD_INT 33
66375: PUSH
66376: EMPTY
66377: LIST
66378: LIST
66379: IN
66380: IFFALSE 66670
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
66382: LD_ADDR_EXP 107
66386: PUSH
66387: LD_EXP 107
66391: PPUSH
66392: LD_VAR 0 3
66396: PUSH
66397: LD_EXP 107
66401: PUSH
66402: LD_VAR 0 3
66406: ARRAY
66407: PUSH
66408: LD_INT 1
66410: PLUS
66411: PUSH
66412: EMPTY
66413: LIST
66414: LIST
66415: PPUSH
66416: LD_VAR 0 1
66420: PPUSH
66421: CALL 72472 0 3
66425: ST_TO_ADDR
// if btype = b_bunker then
66426: LD_VAR 0 5
66430: PUSH
66431: LD_INT 32
66433: EQUAL
66434: IFFALSE 66670
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
66436: LD_ADDR_EXP 108
66440: PUSH
66441: LD_EXP 108
66445: PPUSH
66446: LD_VAR 0 3
66450: PUSH
66451: LD_EXP 108
66455: PUSH
66456: LD_VAR 0 3
66460: ARRAY
66461: PUSH
66462: LD_INT 1
66464: PLUS
66465: PUSH
66466: EMPTY
66467: LIST
66468: LIST
66469: PPUSH
66470: LD_VAR 0 1
66474: PPUSH
66475: CALL 72472 0 3
66479: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
66480: LD_ADDR_VAR 0 6
66484: PUSH
66485: LD_EXP 99
66489: PUSH
66490: LD_VAR 0 3
66494: ARRAY
66495: PPUSH
66496: LD_INT 25
66498: PUSH
66499: LD_INT 1
66501: PUSH
66502: EMPTY
66503: LIST
66504: LIST
66505: PUSH
66506: LD_INT 3
66508: PUSH
66509: LD_INT 54
66511: PUSH
66512: EMPTY
66513: LIST
66514: PUSH
66515: EMPTY
66516: LIST
66517: LIST
66518: PUSH
66519: EMPTY
66520: LIST
66521: LIST
66522: PPUSH
66523: CALL_OW 72
66527: ST_TO_ADDR
// if tmp then
66528: LD_VAR 0 6
66532: IFFALSE 66538
// exit ;
66534: POP
66535: POP
66536: GO 66678
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66538: LD_ADDR_VAR 0 6
66542: PUSH
66543: LD_EXP 99
66547: PUSH
66548: LD_VAR 0 3
66552: ARRAY
66553: PPUSH
66554: LD_INT 2
66556: PUSH
66557: LD_INT 30
66559: PUSH
66560: LD_INT 4
66562: PUSH
66563: EMPTY
66564: LIST
66565: LIST
66566: PUSH
66567: LD_INT 30
66569: PUSH
66570: LD_INT 5
66572: PUSH
66573: EMPTY
66574: LIST
66575: LIST
66576: PUSH
66577: EMPTY
66578: LIST
66579: LIST
66580: LIST
66581: PPUSH
66582: CALL_OW 72
66586: ST_TO_ADDR
// if not tmp then
66587: LD_VAR 0 6
66591: NOT
66592: IFFALSE 66598
// exit ;
66594: POP
66595: POP
66596: GO 66678
// for j in tmp do
66598: LD_ADDR_VAR 0 4
66602: PUSH
66603: LD_VAR 0 6
66607: PUSH
66608: FOR_IN
66609: IFFALSE 66668
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
66611: LD_ADDR_VAR 0 7
66615: PUSH
66616: LD_VAR 0 4
66620: PPUSH
66621: CALL_OW 313
66625: PPUSH
66626: LD_INT 25
66628: PUSH
66629: LD_INT 1
66631: PUSH
66632: EMPTY
66633: LIST
66634: LIST
66635: PPUSH
66636: CALL_OW 72
66640: ST_TO_ADDR
// if units then
66641: LD_VAR 0 7
66645: IFFALSE 66666
// begin ComExitBuilding ( units [ 1 ] ) ;
66647: LD_VAR 0 7
66651: PUSH
66652: LD_INT 1
66654: ARRAY
66655: PPUSH
66656: CALL_OW 122
// exit ;
66660: POP
66661: POP
66662: POP
66663: POP
66664: GO 66678
// end ; end ;
66666: GO 66608
66668: POP
66669: POP
// end ; end ; exit ;
66670: POP
66671: POP
66672: GO 66678
// end ; end ;
66674: GO 66032
66676: POP
66677: POP
// end ;
66678: LD_VAR 0 2
66682: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
66683: LD_INT 0
66685: PPUSH
66686: PPUSH
66687: PPUSH
66688: PPUSH
66689: PPUSH
66690: PPUSH
66691: PPUSH
// if not mc_bases or not skirmish then
66692: LD_EXP 99
66696: NOT
66697: PUSH
66698: LD_EXP 97
66702: NOT
66703: OR
66704: IFFALSE 66708
// exit ;
66706: GO 66973
// btype := GetBType ( building ) ;
66708: LD_ADDR_VAR 0 6
66712: PUSH
66713: LD_VAR 0 1
66717: PPUSH
66718: CALL_OW 266
66722: ST_TO_ADDR
// x := GetX ( building ) ;
66723: LD_ADDR_VAR 0 7
66727: PUSH
66728: LD_VAR 0 1
66732: PPUSH
66733: CALL_OW 250
66737: ST_TO_ADDR
// y := GetY ( building ) ;
66738: LD_ADDR_VAR 0 8
66742: PUSH
66743: LD_VAR 0 1
66747: PPUSH
66748: CALL_OW 251
66752: ST_TO_ADDR
// d := GetDir ( building ) ;
66753: LD_ADDR_VAR 0 9
66757: PUSH
66758: LD_VAR 0 1
66762: PPUSH
66763: CALL_OW 254
66767: ST_TO_ADDR
// for i = 1 to mc_bases do
66768: LD_ADDR_VAR 0 4
66772: PUSH
66773: DOUBLE
66774: LD_INT 1
66776: DEC
66777: ST_TO_ADDR
66778: LD_EXP 99
66782: PUSH
66783: FOR_TO
66784: IFFALSE 66971
// begin if not mc_build_list [ i ] then
66786: LD_EXP 104
66790: PUSH
66791: LD_VAR 0 4
66795: ARRAY
66796: NOT
66797: IFFALSE 66801
// continue ;
66799: GO 66783
// for j := 1 to mc_build_list [ i ] do
66801: LD_ADDR_VAR 0 5
66805: PUSH
66806: DOUBLE
66807: LD_INT 1
66809: DEC
66810: ST_TO_ADDR
66811: LD_EXP 104
66815: PUSH
66816: LD_VAR 0 4
66820: ARRAY
66821: PUSH
66822: FOR_TO
66823: IFFALSE 66967
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
66825: LD_VAR 0 6
66829: PUSH
66830: LD_VAR 0 7
66834: PUSH
66835: LD_VAR 0 8
66839: PUSH
66840: LD_VAR 0 9
66844: PUSH
66845: EMPTY
66846: LIST
66847: LIST
66848: LIST
66849: LIST
66850: PPUSH
66851: LD_EXP 104
66855: PUSH
66856: LD_VAR 0 4
66860: ARRAY
66861: PUSH
66862: LD_VAR 0 5
66866: ARRAY
66867: PPUSH
66868: CALL 78652 0 2
66872: IFFALSE 66965
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
66874: LD_ADDR_EXP 104
66878: PUSH
66879: LD_EXP 104
66883: PPUSH
66884: LD_VAR 0 4
66888: PPUSH
66889: LD_EXP 104
66893: PUSH
66894: LD_VAR 0 4
66898: ARRAY
66899: PPUSH
66900: LD_VAR 0 5
66904: PPUSH
66905: CALL_OW 3
66909: PPUSH
66910: CALL_OW 1
66914: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
66915: LD_ADDR_EXP 106
66919: PUSH
66920: LD_EXP 106
66924: PPUSH
66925: LD_VAR 0 4
66929: PUSH
66930: LD_EXP 106
66934: PUSH
66935: LD_VAR 0 4
66939: ARRAY
66940: PUSH
66941: LD_INT 1
66943: PLUS
66944: PUSH
66945: EMPTY
66946: LIST
66947: LIST
66948: PPUSH
66949: LD_VAR 0 1
66953: PPUSH
66954: CALL 72472 0 3
66958: ST_TO_ADDR
// exit ;
66959: POP
66960: POP
66961: POP
66962: POP
66963: GO 66973
// end ;
66965: GO 66822
66967: POP
66968: POP
// end ;
66969: GO 66783
66971: POP
66972: POP
// end ;
66973: LD_VAR 0 3
66977: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
66978: LD_INT 0
66980: PPUSH
66981: PPUSH
66982: PPUSH
// if not mc_bases or not skirmish then
66983: LD_EXP 99
66987: NOT
66988: PUSH
66989: LD_EXP 97
66993: NOT
66994: OR
66995: IFFALSE 66999
// exit ;
66997: GO 67189
// for i = 1 to mc_bases do
66999: LD_ADDR_VAR 0 4
67003: PUSH
67004: DOUBLE
67005: LD_INT 1
67007: DEC
67008: ST_TO_ADDR
67009: LD_EXP 99
67013: PUSH
67014: FOR_TO
67015: IFFALSE 67102
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
67017: LD_VAR 0 1
67021: PUSH
67022: LD_EXP 107
67026: PUSH
67027: LD_VAR 0 4
67031: ARRAY
67032: IN
67033: PUSH
67034: LD_VAR 0 1
67038: PUSH
67039: LD_EXP 108
67043: PUSH
67044: LD_VAR 0 4
67048: ARRAY
67049: IN
67050: NOT
67051: AND
67052: IFFALSE 67100
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
67054: LD_ADDR_EXP 108
67058: PUSH
67059: LD_EXP 108
67063: PPUSH
67064: LD_VAR 0 4
67068: PUSH
67069: LD_EXP 108
67073: PUSH
67074: LD_VAR 0 4
67078: ARRAY
67079: PUSH
67080: LD_INT 1
67082: PLUS
67083: PUSH
67084: EMPTY
67085: LIST
67086: LIST
67087: PPUSH
67088: LD_VAR 0 1
67092: PPUSH
67093: CALL 72472 0 3
67097: ST_TO_ADDR
// break ;
67098: GO 67102
// end ; end ;
67100: GO 67014
67102: POP
67103: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
67104: LD_VAR 0 1
67108: PPUSH
67109: CALL_OW 257
67113: PUSH
67114: LD_EXP 125
67118: IN
67119: PUSH
67120: LD_VAR 0 1
67124: PPUSH
67125: CALL_OW 266
67129: PUSH
67130: LD_INT 5
67132: EQUAL
67133: AND
67134: PUSH
67135: LD_VAR 0 2
67139: PPUSH
67140: CALL_OW 110
67144: PUSH
67145: LD_INT 18
67147: NONEQUAL
67148: AND
67149: IFFALSE 67189
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
67151: LD_VAR 0 2
67155: PPUSH
67156: CALL_OW 257
67160: PUSH
67161: LD_INT 5
67163: PUSH
67164: LD_INT 8
67166: PUSH
67167: LD_INT 9
67169: PUSH
67170: EMPTY
67171: LIST
67172: LIST
67173: LIST
67174: IN
67175: IFFALSE 67189
// SetClass ( unit , 1 ) ;
67177: LD_VAR 0 2
67181: PPUSH
67182: LD_INT 1
67184: PPUSH
67185: CALL_OW 336
// end ;
67189: LD_VAR 0 3
67193: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
67194: LD_INT 0
67196: PPUSH
67197: PPUSH
// if not mc_bases or not skirmish then
67198: LD_EXP 99
67202: NOT
67203: PUSH
67204: LD_EXP 97
67208: NOT
67209: OR
67210: IFFALSE 67214
// exit ;
67212: GO 67330
// if GetLives ( abandoned_vehicle ) > 250 then
67214: LD_VAR 0 2
67218: PPUSH
67219: CALL_OW 256
67223: PUSH
67224: LD_INT 250
67226: GREATER
67227: IFFALSE 67231
// exit ;
67229: GO 67330
// for i = 1 to mc_bases do
67231: LD_ADDR_VAR 0 6
67235: PUSH
67236: DOUBLE
67237: LD_INT 1
67239: DEC
67240: ST_TO_ADDR
67241: LD_EXP 99
67245: PUSH
67246: FOR_TO
67247: IFFALSE 67328
// begin if driver in mc_bases [ i ] then
67249: LD_VAR 0 1
67253: PUSH
67254: LD_EXP 99
67258: PUSH
67259: LD_VAR 0 6
67263: ARRAY
67264: IN
67265: IFFALSE 67326
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
67267: LD_VAR 0 1
67271: PPUSH
67272: LD_EXP 99
67276: PUSH
67277: LD_VAR 0 6
67281: ARRAY
67282: PPUSH
67283: LD_INT 2
67285: PUSH
67286: LD_INT 30
67288: PUSH
67289: LD_INT 0
67291: PUSH
67292: EMPTY
67293: LIST
67294: LIST
67295: PUSH
67296: LD_INT 30
67298: PUSH
67299: LD_INT 1
67301: PUSH
67302: EMPTY
67303: LIST
67304: LIST
67305: PUSH
67306: EMPTY
67307: LIST
67308: LIST
67309: LIST
67310: PPUSH
67311: CALL_OW 72
67315: PUSH
67316: LD_INT 1
67318: ARRAY
67319: PPUSH
67320: CALL 105661 0 2
// break ;
67324: GO 67328
// end ; end ;
67326: GO 67246
67328: POP
67329: POP
// end ; end_of_file
67330: LD_VAR 0 5
67334: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
67335: LD_INT 0
67337: PPUSH
67338: PPUSH
// if exist_mode then
67339: LD_VAR 0 2
67343: IFFALSE 67368
// unit := CreateCharacter ( prefix & ident ) else
67345: LD_ADDR_VAR 0 5
67349: PUSH
67350: LD_VAR 0 3
67354: PUSH
67355: LD_VAR 0 1
67359: STR
67360: PPUSH
67361: CALL_OW 34
67365: ST_TO_ADDR
67366: GO 67383
// unit := NewCharacter ( ident ) ;
67368: LD_ADDR_VAR 0 5
67372: PUSH
67373: LD_VAR 0 1
67377: PPUSH
67378: CALL_OW 25
67382: ST_TO_ADDR
// result := unit ;
67383: LD_ADDR_VAR 0 4
67387: PUSH
67388: LD_VAR 0 5
67392: ST_TO_ADDR
// end ;
67393: LD_VAR 0 4
67397: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
67398: LD_INT 0
67400: PPUSH
67401: PPUSH
// if not side or not nation then
67402: LD_VAR 0 1
67406: NOT
67407: PUSH
67408: LD_VAR 0 2
67412: NOT
67413: OR
67414: IFFALSE 67418
// exit ;
67416: GO 68186
// case nation of nation_american :
67418: LD_VAR 0 2
67422: PUSH
67423: LD_INT 1
67425: DOUBLE
67426: EQUAL
67427: IFTRUE 67431
67429: GO 67645
67431: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
67432: LD_ADDR_VAR 0 4
67436: PUSH
67437: LD_INT 35
67439: PUSH
67440: LD_INT 45
67442: PUSH
67443: LD_INT 46
67445: PUSH
67446: LD_INT 47
67448: PUSH
67449: LD_INT 82
67451: PUSH
67452: LD_INT 83
67454: PUSH
67455: LD_INT 84
67457: PUSH
67458: LD_INT 85
67460: PUSH
67461: LD_INT 86
67463: PUSH
67464: LD_INT 1
67466: PUSH
67467: LD_INT 2
67469: PUSH
67470: LD_INT 6
67472: PUSH
67473: LD_INT 15
67475: PUSH
67476: LD_INT 16
67478: PUSH
67479: LD_INT 7
67481: PUSH
67482: LD_INT 12
67484: PUSH
67485: LD_INT 13
67487: PUSH
67488: LD_INT 10
67490: PUSH
67491: LD_INT 14
67493: PUSH
67494: LD_INT 20
67496: PUSH
67497: LD_INT 21
67499: PUSH
67500: LD_INT 22
67502: PUSH
67503: LD_INT 25
67505: PUSH
67506: LD_INT 32
67508: PUSH
67509: LD_INT 27
67511: PUSH
67512: LD_INT 36
67514: PUSH
67515: LD_INT 69
67517: PUSH
67518: LD_INT 39
67520: PUSH
67521: LD_INT 34
67523: PUSH
67524: LD_INT 40
67526: PUSH
67527: LD_INT 48
67529: PUSH
67530: LD_INT 49
67532: PUSH
67533: LD_INT 50
67535: PUSH
67536: LD_INT 51
67538: PUSH
67539: LD_INT 52
67541: PUSH
67542: LD_INT 53
67544: PUSH
67545: LD_INT 54
67547: PUSH
67548: LD_INT 55
67550: PUSH
67551: LD_INT 56
67553: PUSH
67554: LD_INT 57
67556: PUSH
67557: LD_INT 58
67559: PUSH
67560: LD_INT 59
67562: PUSH
67563: LD_INT 60
67565: PUSH
67566: LD_INT 61
67568: PUSH
67569: LD_INT 62
67571: PUSH
67572: LD_INT 80
67574: PUSH
67575: LD_INT 82
67577: PUSH
67578: LD_INT 83
67580: PUSH
67581: LD_INT 84
67583: PUSH
67584: LD_INT 85
67586: PUSH
67587: LD_INT 86
67589: PUSH
67590: EMPTY
67591: LIST
67592: LIST
67593: LIST
67594: LIST
67595: LIST
67596: LIST
67597: LIST
67598: LIST
67599: LIST
67600: LIST
67601: LIST
67602: LIST
67603: LIST
67604: LIST
67605: LIST
67606: LIST
67607: LIST
67608: LIST
67609: LIST
67610: LIST
67611: LIST
67612: LIST
67613: LIST
67614: LIST
67615: LIST
67616: LIST
67617: LIST
67618: LIST
67619: LIST
67620: LIST
67621: LIST
67622: LIST
67623: LIST
67624: LIST
67625: LIST
67626: LIST
67627: LIST
67628: LIST
67629: LIST
67630: LIST
67631: LIST
67632: LIST
67633: LIST
67634: LIST
67635: LIST
67636: LIST
67637: LIST
67638: LIST
67639: LIST
67640: LIST
67641: LIST
67642: ST_TO_ADDR
67643: GO 68110
67645: LD_INT 2
67647: DOUBLE
67648: EQUAL
67649: IFTRUE 67653
67651: GO 67879
67653: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
67654: LD_ADDR_VAR 0 4
67658: PUSH
67659: LD_INT 35
67661: PUSH
67662: LD_INT 45
67664: PUSH
67665: LD_INT 46
67667: PUSH
67668: LD_INT 47
67670: PUSH
67671: LD_INT 82
67673: PUSH
67674: LD_INT 83
67676: PUSH
67677: LD_INT 84
67679: PUSH
67680: LD_INT 85
67682: PUSH
67683: LD_INT 87
67685: PUSH
67686: LD_INT 70
67688: PUSH
67689: LD_INT 1
67691: PUSH
67692: LD_INT 11
67694: PUSH
67695: LD_INT 3
67697: PUSH
67698: LD_INT 4
67700: PUSH
67701: LD_INT 5
67703: PUSH
67704: LD_INT 6
67706: PUSH
67707: LD_INT 15
67709: PUSH
67710: LD_INT 18
67712: PUSH
67713: LD_INT 7
67715: PUSH
67716: LD_INT 17
67718: PUSH
67719: LD_INT 8
67721: PUSH
67722: LD_INT 20
67724: PUSH
67725: LD_INT 21
67727: PUSH
67728: LD_INT 22
67730: PUSH
67731: LD_INT 72
67733: PUSH
67734: LD_INT 26
67736: PUSH
67737: LD_INT 69
67739: PUSH
67740: LD_INT 39
67742: PUSH
67743: LD_INT 40
67745: PUSH
67746: LD_INT 41
67748: PUSH
67749: LD_INT 42
67751: PUSH
67752: LD_INT 43
67754: PUSH
67755: LD_INT 48
67757: PUSH
67758: LD_INT 49
67760: PUSH
67761: LD_INT 50
67763: PUSH
67764: LD_INT 51
67766: PUSH
67767: LD_INT 52
67769: PUSH
67770: LD_INT 53
67772: PUSH
67773: LD_INT 54
67775: PUSH
67776: LD_INT 55
67778: PUSH
67779: LD_INT 56
67781: PUSH
67782: LD_INT 60
67784: PUSH
67785: LD_INT 61
67787: PUSH
67788: LD_INT 62
67790: PUSH
67791: LD_INT 66
67793: PUSH
67794: LD_INT 67
67796: PUSH
67797: LD_INT 68
67799: PUSH
67800: LD_INT 81
67802: PUSH
67803: LD_INT 82
67805: PUSH
67806: LD_INT 83
67808: PUSH
67809: LD_INT 84
67811: PUSH
67812: LD_INT 85
67814: PUSH
67815: LD_INT 87
67817: PUSH
67818: LD_INT 88
67820: PUSH
67821: EMPTY
67822: LIST
67823: LIST
67824: LIST
67825: LIST
67826: LIST
67827: LIST
67828: LIST
67829: LIST
67830: LIST
67831: LIST
67832: LIST
67833: LIST
67834: LIST
67835: LIST
67836: LIST
67837: LIST
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: LIST
67848: LIST
67849: LIST
67850: LIST
67851: LIST
67852: LIST
67853: LIST
67854: LIST
67855: LIST
67856: LIST
67857: LIST
67858: LIST
67859: LIST
67860: LIST
67861: LIST
67862: LIST
67863: LIST
67864: LIST
67865: LIST
67866: LIST
67867: LIST
67868: LIST
67869: LIST
67870: LIST
67871: LIST
67872: LIST
67873: LIST
67874: LIST
67875: LIST
67876: ST_TO_ADDR
67877: GO 68110
67879: LD_INT 3
67881: DOUBLE
67882: EQUAL
67883: IFTRUE 67887
67885: GO 68109
67887: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
67888: LD_ADDR_VAR 0 4
67892: PUSH
67893: LD_INT 46
67895: PUSH
67896: LD_INT 47
67898: PUSH
67899: LD_INT 1
67901: PUSH
67902: LD_INT 2
67904: PUSH
67905: LD_INT 82
67907: PUSH
67908: LD_INT 83
67910: PUSH
67911: LD_INT 84
67913: PUSH
67914: LD_INT 85
67916: PUSH
67917: LD_INT 86
67919: PUSH
67920: LD_INT 11
67922: PUSH
67923: LD_INT 9
67925: PUSH
67926: LD_INT 20
67928: PUSH
67929: LD_INT 19
67931: PUSH
67932: LD_INT 21
67934: PUSH
67935: LD_INT 24
67937: PUSH
67938: LD_INT 22
67940: PUSH
67941: LD_INT 25
67943: PUSH
67944: LD_INT 28
67946: PUSH
67947: LD_INT 29
67949: PUSH
67950: LD_INT 30
67952: PUSH
67953: LD_INT 31
67955: PUSH
67956: LD_INT 37
67958: PUSH
67959: LD_INT 38
67961: PUSH
67962: LD_INT 32
67964: PUSH
67965: LD_INT 27
67967: PUSH
67968: LD_INT 33
67970: PUSH
67971: LD_INT 69
67973: PUSH
67974: LD_INT 39
67976: PUSH
67977: LD_INT 34
67979: PUSH
67980: LD_INT 40
67982: PUSH
67983: LD_INT 71
67985: PUSH
67986: LD_INT 23
67988: PUSH
67989: LD_INT 44
67991: PUSH
67992: LD_INT 48
67994: PUSH
67995: LD_INT 49
67997: PUSH
67998: LD_INT 50
68000: PUSH
68001: LD_INT 51
68003: PUSH
68004: LD_INT 52
68006: PUSH
68007: LD_INT 53
68009: PUSH
68010: LD_INT 54
68012: PUSH
68013: LD_INT 55
68015: PUSH
68016: LD_INT 56
68018: PUSH
68019: LD_INT 57
68021: PUSH
68022: LD_INT 58
68024: PUSH
68025: LD_INT 59
68027: PUSH
68028: LD_INT 63
68030: PUSH
68031: LD_INT 64
68033: PUSH
68034: LD_INT 65
68036: PUSH
68037: LD_INT 82
68039: PUSH
68040: LD_INT 83
68042: PUSH
68043: LD_INT 84
68045: PUSH
68046: LD_INT 85
68048: PUSH
68049: LD_INT 86
68051: PUSH
68052: EMPTY
68053: LIST
68054: LIST
68055: LIST
68056: LIST
68057: LIST
68058: LIST
68059: LIST
68060: LIST
68061: LIST
68062: LIST
68063: LIST
68064: LIST
68065: LIST
68066: LIST
68067: LIST
68068: LIST
68069: LIST
68070: LIST
68071: LIST
68072: LIST
68073: LIST
68074: LIST
68075: LIST
68076: LIST
68077: LIST
68078: LIST
68079: LIST
68080: LIST
68081: LIST
68082: LIST
68083: LIST
68084: LIST
68085: LIST
68086: LIST
68087: LIST
68088: LIST
68089: LIST
68090: LIST
68091: LIST
68092: LIST
68093: LIST
68094: LIST
68095: LIST
68096: LIST
68097: LIST
68098: LIST
68099: LIST
68100: LIST
68101: LIST
68102: LIST
68103: LIST
68104: LIST
68105: LIST
68106: ST_TO_ADDR
68107: GO 68110
68109: POP
// if state > - 1 and state < 3 then
68110: LD_VAR 0 3
68114: PUSH
68115: LD_INT 1
68117: NEG
68118: GREATER
68119: PUSH
68120: LD_VAR 0 3
68124: PUSH
68125: LD_INT 3
68127: LESS
68128: AND
68129: IFFALSE 68186
// for i in result do
68131: LD_ADDR_VAR 0 5
68135: PUSH
68136: LD_VAR 0 4
68140: PUSH
68141: FOR_IN
68142: IFFALSE 68184
// if GetTech ( i , side ) <> state then
68144: LD_VAR 0 5
68148: PPUSH
68149: LD_VAR 0 1
68153: PPUSH
68154: CALL_OW 321
68158: PUSH
68159: LD_VAR 0 3
68163: NONEQUAL
68164: IFFALSE 68182
// result := result diff i ;
68166: LD_ADDR_VAR 0 4
68170: PUSH
68171: LD_VAR 0 4
68175: PUSH
68176: LD_VAR 0 5
68180: DIFF
68181: ST_TO_ADDR
68182: GO 68141
68184: POP
68185: POP
// end ;
68186: LD_VAR 0 4
68190: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
68191: LD_INT 0
68193: PPUSH
68194: PPUSH
68195: PPUSH
// result := true ;
68196: LD_ADDR_VAR 0 3
68200: PUSH
68201: LD_INT 1
68203: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
68204: LD_ADDR_VAR 0 5
68208: PUSH
68209: LD_VAR 0 2
68213: PPUSH
68214: CALL_OW 480
68218: ST_TO_ADDR
// if not tmp then
68219: LD_VAR 0 5
68223: NOT
68224: IFFALSE 68228
// exit ;
68226: GO 68277
// for i in tmp do
68228: LD_ADDR_VAR 0 4
68232: PUSH
68233: LD_VAR 0 5
68237: PUSH
68238: FOR_IN
68239: IFFALSE 68275
// if GetTech ( i , side ) <> state_researched then
68241: LD_VAR 0 4
68245: PPUSH
68246: LD_VAR 0 1
68250: PPUSH
68251: CALL_OW 321
68255: PUSH
68256: LD_INT 2
68258: NONEQUAL
68259: IFFALSE 68273
// begin result := false ;
68261: LD_ADDR_VAR 0 3
68265: PUSH
68266: LD_INT 0
68268: ST_TO_ADDR
// exit ;
68269: POP
68270: POP
68271: GO 68277
// end ;
68273: GO 68238
68275: POP
68276: POP
// end ;
68277: LD_VAR 0 3
68281: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
68282: LD_INT 0
68284: PPUSH
68285: PPUSH
68286: PPUSH
68287: PPUSH
68288: PPUSH
68289: PPUSH
68290: PPUSH
68291: PPUSH
68292: PPUSH
68293: PPUSH
68294: PPUSH
68295: PPUSH
68296: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
68297: LD_VAR 0 1
68301: NOT
68302: PUSH
68303: LD_VAR 0 1
68307: PPUSH
68308: CALL_OW 257
68312: PUSH
68313: LD_INT 9
68315: NONEQUAL
68316: OR
68317: IFFALSE 68321
// exit ;
68319: GO 68894
// side := GetSide ( unit ) ;
68321: LD_ADDR_VAR 0 9
68325: PUSH
68326: LD_VAR 0 1
68330: PPUSH
68331: CALL_OW 255
68335: ST_TO_ADDR
// tech_space := tech_spacanom ;
68336: LD_ADDR_VAR 0 12
68340: PUSH
68341: LD_INT 29
68343: ST_TO_ADDR
// tech_time := tech_taurad ;
68344: LD_ADDR_VAR 0 13
68348: PUSH
68349: LD_INT 28
68351: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
68352: LD_ADDR_VAR 0 11
68356: PUSH
68357: LD_VAR 0 1
68361: PPUSH
68362: CALL_OW 310
68366: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
68367: LD_VAR 0 11
68371: PPUSH
68372: CALL_OW 247
68376: PUSH
68377: LD_INT 2
68379: EQUAL
68380: IFFALSE 68384
// exit ;
68382: GO 68894
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
68384: LD_ADDR_VAR 0 8
68388: PUSH
68389: LD_INT 81
68391: PUSH
68392: LD_VAR 0 9
68396: PUSH
68397: EMPTY
68398: LIST
68399: LIST
68400: PUSH
68401: LD_INT 3
68403: PUSH
68404: LD_INT 21
68406: PUSH
68407: LD_INT 3
68409: PUSH
68410: EMPTY
68411: LIST
68412: LIST
68413: PUSH
68414: EMPTY
68415: LIST
68416: LIST
68417: PUSH
68418: EMPTY
68419: LIST
68420: LIST
68421: PPUSH
68422: CALL_OW 69
68426: ST_TO_ADDR
// if not tmp then
68427: LD_VAR 0 8
68431: NOT
68432: IFFALSE 68436
// exit ;
68434: GO 68894
// if in_unit then
68436: LD_VAR 0 11
68440: IFFALSE 68464
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
68442: LD_ADDR_VAR 0 10
68446: PUSH
68447: LD_VAR 0 8
68451: PPUSH
68452: LD_VAR 0 11
68456: PPUSH
68457: CALL_OW 74
68461: ST_TO_ADDR
68462: GO 68484
// enemy := NearestUnitToUnit ( tmp , unit ) ;
68464: LD_ADDR_VAR 0 10
68468: PUSH
68469: LD_VAR 0 8
68473: PPUSH
68474: LD_VAR 0 1
68478: PPUSH
68479: CALL_OW 74
68483: ST_TO_ADDR
// if not enemy then
68484: LD_VAR 0 10
68488: NOT
68489: IFFALSE 68493
// exit ;
68491: GO 68894
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
68493: LD_VAR 0 11
68497: PUSH
68498: LD_VAR 0 11
68502: PPUSH
68503: LD_VAR 0 10
68507: PPUSH
68508: CALL_OW 296
68512: PUSH
68513: LD_INT 13
68515: GREATER
68516: AND
68517: PUSH
68518: LD_VAR 0 1
68522: PPUSH
68523: LD_VAR 0 10
68527: PPUSH
68528: CALL_OW 296
68532: PUSH
68533: LD_INT 12
68535: GREATER
68536: OR
68537: IFFALSE 68541
// exit ;
68539: GO 68894
// missile := [ 1 ] ;
68541: LD_ADDR_VAR 0 14
68545: PUSH
68546: LD_INT 1
68548: PUSH
68549: EMPTY
68550: LIST
68551: ST_TO_ADDR
// if Researched ( side , tech_space ) then
68552: LD_VAR 0 9
68556: PPUSH
68557: LD_VAR 0 12
68561: PPUSH
68562: CALL_OW 325
68566: IFFALSE 68595
// missile := Replace ( missile , missile + 1 , 2 ) ;
68568: LD_ADDR_VAR 0 14
68572: PUSH
68573: LD_VAR 0 14
68577: PPUSH
68578: LD_VAR 0 14
68582: PUSH
68583: LD_INT 1
68585: PLUS
68586: PPUSH
68587: LD_INT 2
68589: PPUSH
68590: CALL_OW 1
68594: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
68595: LD_VAR 0 9
68599: PPUSH
68600: LD_VAR 0 13
68604: PPUSH
68605: CALL_OW 325
68609: PUSH
68610: LD_VAR 0 10
68614: PPUSH
68615: CALL_OW 255
68619: PPUSH
68620: LD_VAR 0 13
68624: PPUSH
68625: CALL_OW 325
68629: NOT
68630: AND
68631: IFFALSE 68660
// missile := Replace ( missile , missile + 1 , 3 ) ;
68633: LD_ADDR_VAR 0 14
68637: PUSH
68638: LD_VAR 0 14
68642: PPUSH
68643: LD_VAR 0 14
68647: PUSH
68648: LD_INT 1
68650: PLUS
68651: PPUSH
68652: LD_INT 3
68654: PPUSH
68655: CALL_OW 1
68659: ST_TO_ADDR
// if missile < 2 then
68660: LD_VAR 0 14
68664: PUSH
68665: LD_INT 2
68667: LESS
68668: IFFALSE 68672
// exit ;
68670: GO 68894
// x := GetX ( enemy ) ;
68672: LD_ADDR_VAR 0 4
68676: PUSH
68677: LD_VAR 0 10
68681: PPUSH
68682: CALL_OW 250
68686: ST_TO_ADDR
// y := GetY ( enemy ) ;
68687: LD_ADDR_VAR 0 5
68691: PUSH
68692: LD_VAR 0 10
68696: PPUSH
68697: CALL_OW 251
68701: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
68702: LD_ADDR_VAR 0 6
68706: PUSH
68707: LD_VAR 0 4
68711: PUSH
68712: LD_INT 1
68714: NEG
68715: PPUSH
68716: LD_INT 1
68718: PPUSH
68719: CALL_OW 12
68723: PLUS
68724: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
68725: LD_ADDR_VAR 0 7
68729: PUSH
68730: LD_VAR 0 5
68734: PUSH
68735: LD_INT 1
68737: NEG
68738: PPUSH
68739: LD_INT 1
68741: PPUSH
68742: CALL_OW 12
68746: PLUS
68747: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
68748: LD_VAR 0 6
68752: PPUSH
68753: LD_VAR 0 7
68757: PPUSH
68758: CALL_OW 488
68762: NOT
68763: IFFALSE 68785
// begin _x := x ;
68765: LD_ADDR_VAR 0 6
68769: PUSH
68770: LD_VAR 0 4
68774: ST_TO_ADDR
// _y := y ;
68775: LD_ADDR_VAR 0 7
68779: PUSH
68780: LD_VAR 0 5
68784: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
68785: LD_ADDR_VAR 0 3
68789: PUSH
68790: LD_INT 1
68792: PPUSH
68793: LD_VAR 0 14
68797: PPUSH
68798: CALL_OW 12
68802: ST_TO_ADDR
// case i of 1 :
68803: LD_VAR 0 3
68807: PUSH
68808: LD_INT 1
68810: DOUBLE
68811: EQUAL
68812: IFTRUE 68816
68814: GO 68833
68816: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
68817: LD_VAR 0 1
68821: PPUSH
68822: LD_VAR 0 10
68826: PPUSH
68827: CALL_OW 115
68831: GO 68894
68833: LD_INT 2
68835: DOUBLE
68836: EQUAL
68837: IFTRUE 68841
68839: GO 68863
68841: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
68842: LD_VAR 0 1
68846: PPUSH
68847: LD_VAR 0 6
68851: PPUSH
68852: LD_VAR 0 7
68856: PPUSH
68857: CALL_OW 153
68861: GO 68894
68863: LD_INT 3
68865: DOUBLE
68866: EQUAL
68867: IFTRUE 68871
68869: GO 68893
68871: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
68872: LD_VAR 0 1
68876: PPUSH
68877: LD_VAR 0 6
68881: PPUSH
68882: LD_VAR 0 7
68886: PPUSH
68887: CALL_OW 154
68891: GO 68894
68893: POP
// end ;
68894: LD_VAR 0 2
68898: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
68899: LD_INT 0
68901: PPUSH
68902: PPUSH
68903: PPUSH
68904: PPUSH
68905: PPUSH
68906: PPUSH
// if not unit or not building then
68907: LD_VAR 0 1
68911: NOT
68912: PUSH
68913: LD_VAR 0 2
68917: NOT
68918: OR
68919: IFFALSE 68923
// exit ;
68921: GO 69081
// x := GetX ( building ) ;
68923: LD_ADDR_VAR 0 5
68927: PUSH
68928: LD_VAR 0 2
68932: PPUSH
68933: CALL_OW 250
68937: ST_TO_ADDR
// y := GetY ( building ) ;
68938: LD_ADDR_VAR 0 6
68942: PUSH
68943: LD_VAR 0 2
68947: PPUSH
68948: CALL_OW 251
68952: ST_TO_ADDR
// for i = 0 to 5 do
68953: LD_ADDR_VAR 0 4
68957: PUSH
68958: DOUBLE
68959: LD_INT 0
68961: DEC
68962: ST_TO_ADDR
68963: LD_INT 5
68965: PUSH
68966: FOR_TO
68967: IFFALSE 69079
// begin _x := ShiftX ( x , i , 3 ) ;
68969: LD_ADDR_VAR 0 7
68973: PUSH
68974: LD_VAR 0 5
68978: PPUSH
68979: LD_VAR 0 4
68983: PPUSH
68984: LD_INT 3
68986: PPUSH
68987: CALL_OW 272
68991: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
68992: LD_ADDR_VAR 0 8
68996: PUSH
68997: LD_VAR 0 6
69001: PPUSH
69002: LD_VAR 0 4
69006: PPUSH
69007: LD_INT 3
69009: PPUSH
69010: CALL_OW 273
69014: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
69015: LD_VAR 0 7
69019: PPUSH
69020: LD_VAR 0 8
69024: PPUSH
69025: CALL_OW 488
69029: NOT
69030: IFFALSE 69034
// continue ;
69032: GO 68966
// if HexInfo ( _x , _y ) = 0 then
69034: LD_VAR 0 7
69038: PPUSH
69039: LD_VAR 0 8
69043: PPUSH
69044: CALL_OW 428
69048: PUSH
69049: LD_INT 0
69051: EQUAL
69052: IFFALSE 69077
// begin ComMoveXY ( unit , _x , _y ) ;
69054: LD_VAR 0 1
69058: PPUSH
69059: LD_VAR 0 7
69063: PPUSH
69064: LD_VAR 0 8
69068: PPUSH
69069: CALL_OW 111
// exit ;
69073: POP
69074: POP
69075: GO 69081
// end ; end ;
69077: GO 68966
69079: POP
69080: POP
// end ;
69081: LD_VAR 0 3
69085: RET
// export function ScanBase ( side , base_area ) ; begin
69086: LD_INT 0
69088: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
69089: LD_ADDR_VAR 0 3
69093: PUSH
69094: LD_VAR 0 2
69098: PPUSH
69099: LD_INT 81
69101: PUSH
69102: LD_VAR 0 1
69106: PUSH
69107: EMPTY
69108: LIST
69109: LIST
69110: PPUSH
69111: CALL_OW 70
69115: ST_TO_ADDR
// end ;
69116: LD_VAR 0 3
69120: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
69121: LD_INT 0
69123: PPUSH
69124: PPUSH
69125: PPUSH
69126: PPUSH
// result := false ;
69127: LD_ADDR_VAR 0 2
69131: PUSH
69132: LD_INT 0
69134: ST_TO_ADDR
// side := GetSide ( unit ) ;
69135: LD_ADDR_VAR 0 3
69139: PUSH
69140: LD_VAR 0 1
69144: PPUSH
69145: CALL_OW 255
69149: ST_TO_ADDR
// nat := GetNation ( unit ) ;
69150: LD_ADDR_VAR 0 4
69154: PUSH
69155: LD_VAR 0 1
69159: PPUSH
69160: CALL_OW 248
69164: ST_TO_ADDR
// case nat of 1 :
69165: LD_VAR 0 4
69169: PUSH
69170: LD_INT 1
69172: DOUBLE
69173: EQUAL
69174: IFTRUE 69178
69176: GO 69189
69178: POP
// tech := tech_lassight ; 2 :
69179: LD_ADDR_VAR 0 5
69183: PUSH
69184: LD_INT 12
69186: ST_TO_ADDR
69187: GO 69228
69189: LD_INT 2
69191: DOUBLE
69192: EQUAL
69193: IFTRUE 69197
69195: GO 69208
69197: POP
// tech := tech_mortar ; 3 :
69198: LD_ADDR_VAR 0 5
69202: PUSH
69203: LD_INT 41
69205: ST_TO_ADDR
69206: GO 69228
69208: LD_INT 3
69210: DOUBLE
69211: EQUAL
69212: IFTRUE 69216
69214: GO 69227
69216: POP
// tech := tech_bazooka ; end ;
69217: LD_ADDR_VAR 0 5
69221: PUSH
69222: LD_INT 44
69224: ST_TO_ADDR
69225: GO 69228
69227: POP
// if Researched ( side , tech ) then
69228: LD_VAR 0 3
69232: PPUSH
69233: LD_VAR 0 5
69237: PPUSH
69238: CALL_OW 325
69242: IFFALSE 69269
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
69244: LD_ADDR_VAR 0 2
69248: PUSH
69249: LD_INT 5
69251: PUSH
69252: LD_INT 8
69254: PUSH
69255: LD_INT 9
69257: PUSH
69258: EMPTY
69259: LIST
69260: LIST
69261: LIST
69262: PUSH
69263: LD_VAR 0 4
69267: ARRAY
69268: ST_TO_ADDR
// end ;
69269: LD_VAR 0 2
69273: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
69274: LD_INT 0
69276: PPUSH
69277: PPUSH
69278: PPUSH
// if not mines then
69279: LD_VAR 0 2
69283: NOT
69284: IFFALSE 69288
// exit ;
69286: GO 69432
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69288: LD_ADDR_VAR 0 5
69292: PUSH
69293: LD_INT 81
69295: PUSH
69296: LD_VAR 0 1
69300: PUSH
69301: EMPTY
69302: LIST
69303: LIST
69304: PUSH
69305: LD_INT 3
69307: PUSH
69308: LD_INT 21
69310: PUSH
69311: LD_INT 3
69313: PUSH
69314: EMPTY
69315: LIST
69316: LIST
69317: PUSH
69318: EMPTY
69319: LIST
69320: LIST
69321: PUSH
69322: EMPTY
69323: LIST
69324: LIST
69325: PPUSH
69326: CALL_OW 69
69330: ST_TO_ADDR
// for i in mines do
69331: LD_ADDR_VAR 0 4
69335: PUSH
69336: LD_VAR 0 2
69340: PUSH
69341: FOR_IN
69342: IFFALSE 69430
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
69344: LD_VAR 0 4
69348: PUSH
69349: LD_INT 1
69351: ARRAY
69352: PPUSH
69353: LD_VAR 0 4
69357: PUSH
69358: LD_INT 2
69360: ARRAY
69361: PPUSH
69362: CALL_OW 458
69366: NOT
69367: IFFALSE 69371
// continue ;
69369: GO 69341
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
69371: LD_VAR 0 4
69375: PUSH
69376: LD_INT 1
69378: ARRAY
69379: PPUSH
69380: LD_VAR 0 4
69384: PUSH
69385: LD_INT 2
69387: ARRAY
69388: PPUSH
69389: CALL_OW 428
69393: PUSH
69394: LD_VAR 0 5
69398: IN
69399: IFFALSE 69428
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
69401: LD_VAR 0 4
69405: PUSH
69406: LD_INT 1
69408: ARRAY
69409: PPUSH
69410: LD_VAR 0 4
69414: PUSH
69415: LD_INT 2
69417: ARRAY
69418: PPUSH
69419: LD_VAR 0 1
69423: PPUSH
69424: CALL_OW 456
// end ;
69428: GO 69341
69430: POP
69431: POP
// end ;
69432: LD_VAR 0 3
69436: RET
// export function Count ( array ) ; var i ; begin
69437: LD_INT 0
69439: PPUSH
69440: PPUSH
// result := 0 ;
69441: LD_ADDR_VAR 0 2
69445: PUSH
69446: LD_INT 0
69448: ST_TO_ADDR
// for i in array do
69449: LD_ADDR_VAR 0 3
69453: PUSH
69454: LD_VAR 0 1
69458: PUSH
69459: FOR_IN
69460: IFFALSE 69484
// if i then
69462: LD_VAR 0 3
69466: IFFALSE 69482
// result := result + 1 ;
69468: LD_ADDR_VAR 0 2
69472: PUSH
69473: LD_VAR 0 2
69477: PUSH
69478: LD_INT 1
69480: PLUS
69481: ST_TO_ADDR
69482: GO 69459
69484: POP
69485: POP
// end ;
69486: LD_VAR 0 2
69490: RET
// export function IsEmpty ( building ) ; begin
69491: LD_INT 0
69493: PPUSH
// if not building then
69494: LD_VAR 0 1
69498: NOT
69499: IFFALSE 69503
// exit ;
69501: GO 69546
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
69503: LD_ADDR_VAR 0 2
69507: PUSH
69508: LD_VAR 0 1
69512: PUSH
69513: LD_INT 22
69515: PUSH
69516: LD_VAR 0 1
69520: PPUSH
69521: CALL_OW 255
69525: PUSH
69526: EMPTY
69527: LIST
69528: LIST
69529: PUSH
69530: LD_INT 58
69532: PUSH
69533: EMPTY
69534: LIST
69535: PUSH
69536: EMPTY
69537: LIST
69538: LIST
69539: PPUSH
69540: CALL_OW 69
69544: IN
69545: ST_TO_ADDR
// end ;
69546: LD_VAR 0 2
69550: RET
// export function IsNotFull ( building ) ; var places ; begin
69551: LD_INT 0
69553: PPUSH
69554: PPUSH
// if not building then
69555: LD_VAR 0 1
69559: NOT
69560: IFFALSE 69564
// exit ;
69562: GO 69735
// result := false ;
69564: LD_ADDR_VAR 0 2
69568: PUSH
69569: LD_INT 0
69571: ST_TO_ADDR
// places := 0 ;
69572: LD_ADDR_VAR 0 3
69576: PUSH
69577: LD_INT 0
69579: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
69580: LD_VAR 0 1
69584: PPUSH
69585: CALL_OW 266
69589: PUSH
69590: LD_INT 0
69592: DOUBLE
69593: EQUAL
69594: IFTRUE 69652
69596: LD_INT 1
69598: DOUBLE
69599: EQUAL
69600: IFTRUE 69652
69602: LD_INT 6
69604: DOUBLE
69605: EQUAL
69606: IFTRUE 69652
69608: LD_INT 7
69610: DOUBLE
69611: EQUAL
69612: IFTRUE 69652
69614: LD_INT 8
69616: DOUBLE
69617: EQUAL
69618: IFTRUE 69652
69620: LD_INT 4
69622: DOUBLE
69623: EQUAL
69624: IFTRUE 69652
69626: LD_INT 5
69628: DOUBLE
69629: EQUAL
69630: IFTRUE 69652
69632: LD_INT 2
69634: DOUBLE
69635: EQUAL
69636: IFTRUE 69652
69638: LD_INT 3
69640: DOUBLE
69641: EQUAL
69642: IFTRUE 69652
69644: LD_INT 35
69646: DOUBLE
69647: EQUAL
69648: IFTRUE 69652
69650: GO 69663
69652: POP
// places := 6 ; b_bunker , b_breastwork :
69653: LD_ADDR_VAR 0 3
69657: PUSH
69658: LD_INT 6
69660: ST_TO_ADDR
69661: GO 69708
69663: LD_INT 32
69665: DOUBLE
69666: EQUAL
69667: IFTRUE 69677
69669: LD_INT 31
69671: DOUBLE
69672: EQUAL
69673: IFTRUE 69677
69675: GO 69688
69677: POP
// places := 1 ; b_control_tower :
69678: LD_ADDR_VAR 0 3
69682: PUSH
69683: LD_INT 1
69685: ST_TO_ADDR
69686: GO 69708
69688: LD_INT 36
69690: DOUBLE
69691: EQUAL
69692: IFTRUE 69696
69694: GO 69707
69696: POP
// places := 3 ; end ;
69697: LD_ADDR_VAR 0 3
69701: PUSH
69702: LD_INT 3
69704: ST_TO_ADDR
69705: GO 69708
69707: POP
// if places then
69708: LD_VAR 0 3
69712: IFFALSE 69735
// result := UnitsInside ( building ) < places ;
69714: LD_ADDR_VAR 0 2
69718: PUSH
69719: LD_VAR 0 1
69723: PPUSH
69724: CALL_OW 313
69728: PUSH
69729: LD_VAR 0 3
69733: LESS
69734: ST_TO_ADDR
// end ;
69735: LD_VAR 0 2
69739: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
69740: LD_INT 0
69742: PPUSH
69743: PPUSH
69744: PPUSH
69745: PPUSH
// tmp := [ ] ;
69746: LD_ADDR_VAR 0 3
69750: PUSH
69751: EMPTY
69752: ST_TO_ADDR
// list := [ ] ;
69753: LD_ADDR_VAR 0 5
69757: PUSH
69758: EMPTY
69759: ST_TO_ADDR
// for i = 16 to 25 do
69760: LD_ADDR_VAR 0 4
69764: PUSH
69765: DOUBLE
69766: LD_INT 16
69768: DEC
69769: ST_TO_ADDR
69770: LD_INT 25
69772: PUSH
69773: FOR_TO
69774: IFFALSE 69847
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
69776: LD_ADDR_VAR 0 3
69780: PUSH
69781: LD_VAR 0 3
69785: PUSH
69786: LD_INT 22
69788: PUSH
69789: LD_VAR 0 1
69793: PPUSH
69794: CALL_OW 255
69798: PUSH
69799: EMPTY
69800: LIST
69801: LIST
69802: PUSH
69803: LD_INT 91
69805: PUSH
69806: LD_VAR 0 1
69810: PUSH
69811: LD_INT 6
69813: PUSH
69814: EMPTY
69815: LIST
69816: LIST
69817: LIST
69818: PUSH
69819: LD_INT 30
69821: PUSH
69822: LD_VAR 0 4
69826: PUSH
69827: EMPTY
69828: LIST
69829: LIST
69830: PUSH
69831: EMPTY
69832: LIST
69833: LIST
69834: LIST
69835: PUSH
69836: EMPTY
69837: LIST
69838: PPUSH
69839: CALL_OW 69
69843: ADD
69844: ST_TO_ADDR
69845: GO 69773
69847: POP
69848: POP
// for i = 1 to tmp do
69849: LD_ADDR_VAR 0 4
69853: PUSH
69854: DOUBLE
69855: LD_INT 1
69857: DEC
69858: ST_TO_ADDR
69859: LD_VAR 0 3
69863: PUSH
69864: FOR_TO
69865: IFFALSE 69953
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
69867: LD_ADDR_VAR 0 5
69871: PUSH
69872: LD_VAR 0 5
69876: PUSH
69877: LD_VAR 0 3
69881: PUSH
69882: LD_VAR 0 4
69886: ARRAY
69887: PPUSH
69888: CALL_OW 266
69892: PUSH
69893: LD_VAR 0 3
69897: PUSH
69898: LD_VAR 0 4
69902: ARRAY
69903: PPUSH
69904: CALL_OW 250
69908: PUSH
69909: LD_VAR 0 3
69913: PUSH
69914: LD_VAR 0 4
69918: ARRAY
69919: PPUSH
69920: CALL_OW 251
69924: PUSH
69925: LD_VAR 0 3
69929: PUSH
69930: LD_VAR 0 4
69934: ARRAY
69935: PPUSH
69936: CALL_OW 254
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: LIST
69945: LIST
69946: PUSH
69947: EMPTY
69948: LIST
69949: ADD
69950: ST_TO_ADDR
69951: GO 69864
69953: POP
69954: POP
// result := list ;
69955: LD_ADDR_VAR 0 2
69959: PUSH
69960: LD_VAR 0 5
69964: ST_TO_ADDR
// end ;
69965: LD_VAR 0 2
69969: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
69970: LD_INT 0
69972: PPUSH
69973: PPUSH
69974: PPUSH
69975: PPUSH
69976: PPUSH
69977: PPUSH
69978: PPUSH
// if not factory then
69979: LD_VAR 0 1
69983: NOT
69984: IFFALSE 69988
// exit ;
69986: GO 70581
// if control = control_apeman then
69988: LD_VAR 0 4
69992: PUSH
69993: LD_INT 5
69995: EQUAL
69996: IFFALSE 70105
// begin tmp := UnitsInside ( factory ) ;
69998: LD_ADDR_VAR 0 8
70002: PUSH
70003: LD_VAR 0 1
70007: PPUSH
70008: CALL_OW 313
70012: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
70013: LD_VAR 0 8
70017: PPUSH
70018: LD_INT 25
70020: PUSH
70021: LD_INT 12
70023: PUSH
70024: EMPTY
70025: LIST
70026: LIST
70027: PPUSH
70028: CALL_OW 72
70032: NOT
70033: IFFALSE 70043
// control := control_manual ;
70035: LD_ADDR_VAR 0 4
70039: PUSH
70040: LD_INT 1
70042: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
70043: LD_ADDR_VAR 0 8
70047: PUSH
70048: LD_VAR 0 1
70052: PPUSH
70053: CALL 69740 0 1
70057: ST_TO_ADDR
// if tmp then
70058: LD_VAR 0 8
70062: IFFALSE 70105
// begin for i in tmp do
70064: LD_ADDR_VAR 0 7
70068: PUSH
70069: LD_VAR 0 8
70073: PUSH
70074: FOR_IN
70075: IFFALSE 70103
// if i [ 1 ] = b_ext_radio then
70077: LD_VAR 0 7
70081: PUSH
70082: LD_INT 1
70084: ARRAY
70085: PUSH
70086: LD_INT 22
70088: EQUAL
70089: IFFALSE 70101
// begin control := control_remote ;
70091: LD_ADDR_VAR 0 4
70095: PUSH
70096: LD_INT 2
70098: ST_TO_ADDR
// break ;
70099: GO 70103
// end ;
70101: GO 70074
70103: POP
70104: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70105: LD_VAR 0 1
70109: PPUSH
70110: LD_VAR 0 2
70114: PPUSH
70115: LD_VAR 0 3
70119: PPUSH
70120: LD_VAR 0 4
70124: PPUSH
70125: LD_VAR 0 5
70129: PPUSH
70130: CALL_OW 448
70134: IFFALSE 70169
// begin result := [ chassis , engine , control , weapon ] ;
70136: LD_ADDR_VAR 0 6
70140: PUSH
70141: LD_VAR 0 2
70145: PUSH
70146: LD_VAR 0 3
70150: PUSH
70151: LD_VAR 0 4
70155: PUSH
70156: LD_VAR 0 5
70160: PUSH
70161: EMPTY
70162: LIST
70163: LIST
70164: LIST
70165: LIST
70166: ST_TO_ADDR
// exit ;
70167: GO 70581
// end ; _chassis := AvailableChassisList ( factory ) ;
70169: LD_ADDR_VAR 0 9
70173: PUSH
70174: LD_VAR 0 1
70178: PPUSH
70179: CALL_OW 475
70183: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
70184: LD_ADDR_VAR 0 11
70188: PUSH
70189: LD_VAR 0 1
70193: PPUSH
70194: CALL_OW 476
70198: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
70199: LD_ADDR_VAR 0 12
70203: PUSH
70204: LD_VAR 0 1
70208: PPUSH
70209: CALL_OW 477
70213: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
70214: LD_ADDR_VAR 0 10
70218: PUSH
70219: LD_VAR 0 1
70223: PPUSH
70224: CALL_OW 478
70228: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
70229: LD_VAR 0 9
70233: NOT
70234: PUSH
70235: LD_VAR 0 11
70239: NOT
70240: OR
70241: PUSH
70242: LD_VAR 0 12
70246: NOT
70247: OR
70248: PUSH
70249: LD_VAR 0 10
70253: NOT
70254: OR
70255: IFFALSE 70290
// begin result := [ chassis , engine , control , weapon ] ;
70257: LD_ADDR_VAR 0 6
70261: PUSH
70262: LD_VAR 0 2
70266: PUSH
70267: LD_VAR 0 3
70271: PUSH
70272: LD_VAR 0 4
70276: PUSH
70277: LD_VAR 0 5
70281: PUSH
70282: EMPTY
70283: LIST
70284: LIST
70285: LIST
70286: LIST
70287: ST_TO_ADDR
// exit ;
70288: GO 70581
// end ; if not chassis in _chassis then
70290: LD_VAR 0 2
70294: PUSH
70295: LD_VAR 0 9
70299: IN
70300: NOT
70301: IFFALSE 70327
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
70303: LD_ADDR_VAR 0 2
70307: PUSH
70308: LD_VAR 0 9
70312: PUSH
70313: LD_INT 1
70315: PPUSH
70316: LD_VAR 0 9
70320: PPUSH
70321: CALL_OW 12
70325: ARRAY
70326: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
70327: LD_VAR 0 2
70331: PPUSH
70332: LD_VAR 0 3
70336: PPUSH
70337: CALL 70586 0 2
70341: NOT
70342: IFFALSE 70401
// repeat engine := _engine [ 1 ] ;
70344: LD_ADDR_VAR 0 3
70348: PUSH
70349: LD_VAR 0 11
70353: PUSH
70354: LD_INT 1
70356: ARRAY
70357: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
70358: LD_ADDR_VAR 0 11
70362: PUSH
70363: LD_VAR 0 11
70367: PPUSH
70368: LD_INT 1
70370: PPUSH
70371: CALL_OW 3
70375: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
70376: LD_VAR 0 2
70380: PPUSH
70381: LD_VAR 0 3
70385: PPUSH
70386: CALL 70586 0 2
70390: PUSH
70391: LD_VAR 0 11
70395: PUSH
70396: EMPTY
70397: EQUAL
70398: OR
70399: IFFALSE 70344
// if not control in _control then
70401: LD_VAR 0 4
70405: PUSH
70406: LD_VAR 0 12
70410: IN
70411: NOT
70412: IFFALSE 70438
// control := _control [ rand ( 1 , _control ) ] ;
70414: LD_ADDR_VAR 0 4
70418: PUSH
70419: LD_VAR 0 12
70423: PUSH
70424: LD_INT 1
70426: PPUSH
70427: LD_VAR 0 12
70431: PPUSH
70432: CALL_OW 12
70436: ARRAY
70437: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
70438: LD_VAR 0 2
70442: PPUSH
70443: LD_VAR 0 5
70447: PPUSH
70448: CALL 70806 0 2
70452: NOT
70453: IFFALSE 70512
// repeat weapon := _weapon [ 1 ] ;
70455: LD_ADDR_VAR 0 5
70459: PUSH
70460: LD_VAR 0 10
70464: PUSH
70465: LD_INT 1
70467: ARRAY
70468: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
70469: LD_ADDR_VAR 0 10
70473: PUSH
70474: LD_VAR 0 10
70478: PPUSH
70479: LD_INT 1
70481: PPUSH
70482: CALL_OW 3
70486: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
70487: LD_VAR 0 2
70491: PPUSH
70492: LD_VAR 0 5
70496: PPUSH
70497: CALL 70806 0 2
70501: PUSH
70502: LD_VAR 0 10
70506: PUSH
70507: EMPTY
70508: EQUAL
70509: OR
70510: IFFALSE 70455
// result := [ ] ;
70512: LD_ADDR_VAR 0 6
70516: PUSH
70517: EMPTY
70518: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70519: LD_VAR 0 1
70523: PPUSH
70524: LD_VAR 0 2
70528: PPUSH
70529: LD_VAR 0 3
70533: PPUSH
70534: LD_VAR 0 4
70538: PPUSH
70539: LD_VAR 0 5
70543: PPUSH
70544: CALL_OW 448
70548: IFFALSE 70581
// result := [ chassis , engine , control , weapon ] ;
70550: LD_ADDR_VAR 0 6
70554: PUSH
70555: LD_VAR 0 2
70559: PUSH
70560: LD_VAR 0 3
70564: PUSH
70565: LD_VAR 0 4
70569: PUSH
70570: LD_VAR 0 5
70574: PUSH
70575: EMPTY
70576: LIST
70577: LIST
70578: LIST
70579: LIST
70580: ST_TO_ADDR
// end ;
70581: LD_VAR 0 6
70585: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
70586: LD_INT 0
70588: PPUSH
// if not chassis or not engine then
70589: LD_VAR 0 1
70593: NOT
70594: PUSH
70595: LD_VAR 0 2
70599: NOT
70600: OR
70601: IFFALSE 70605
// exit ;
70603: GO 70801
// case engine of engine_solar :
70605: LD_VAR 0 2
70609: PUSH
70610: LD_INT 2
70612: DOUBLE
70613: EQUAL
70614: IFTRUE 70618
70616: GO 70656
70618: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
70619: LD_ADDR_VAR 0 3
70623: PUSH
70624: LD_INT 11
70626: PUSH
70627: LD_INT 12
70629: PUSH
70630: LD_INT 13
70632: PUSH
70633: LD_INT 14
70635: PUSH
70636: LD_INT 1
70638: PUSH
70639: LD_INT 2
70641: PUSH
70642: LD_INT 3
70644: PUSH
70645: EMPTY
70646: LIST
70647: LIST
70648: LIST
70649: LIST
70650: LIST
70651: LIST
70652: LIST
70653: ST_TO_ADDR
70654: GO 70785
70656: LD_INT 1
70658: DOUBLE
70659: EQUAL
70660: IFTRUE 70664
70662: GO 70726
70664: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
70665: LD_ADDR_VAR 0 3
70669: PUSH
70670: LD_INT 11
70672: PUSH
70673: LD_INT 12
70675: PUSH
70676: LD_INT 13
70678: PUSH
70679: LD_INT 14
70681: PUSH
70682: LD_INT 1
70684: PUSH
70685: LD_INT 2
70687: PUSH
70688: LD_INT 3
70690: PUSH
70691: LD_INT 4
70693: PUSH
70694: LD_INT 5
70696: PUSH
70697: LD_INT 21
70699: PUSH
70700: LD_INT 23
70702: PUSH
70703: LD_INT 22
70705: PUSH
70706: LD_INT 24
70708: PUSH
70709: EMPTY
70710: LIST
70711: LIST
70712: LIST
70713: LIST
70714: LIST
70715: LIST
70716: LIST
70717: LIST
70718: LIST
70719: LIST
70720: LIST
70721: LIST
70722: LIST
70723: ST_TO_ADDR
70724: GO 70785
70726: LD_INT 3
70728: DOUBLE
70729: EQUAL
70730: IFTRUE 70734
70732: GO 70784
70734: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70735: LD_ADDR_VAR 0 3
70739: PUSH
70740: LD_INT 13
70742: PUSH
70743: LD_INT 14
70745: PUSH
70746: LD_INT 2
70748: PUSH
70749: LD_INT 3
70751: PUSH
70752: LD_INT 4
70754: PUSH
70755: LD_INT 5
70757: PUSH
70758: LD_INT 21
70760: PUSH
70761: LD_INT 22
70763: PUSH
70764: LD_INT 23
70766: PUSH
70767: LD_INT 24
70769: PUSH
70770: EMPTY
70771: LIST
70772: LIST
70773: LIST
70774: LIST
70775: LIST
70776: LIST
70777: LIST
70778: LIST
70779: LIST
70780: LIST
70781: ST_TO_ADDR
70782: GO 70785
70784: POP
// result := ( chassis in result ) ;
70785: LD_ADDR_VAR 0 3
70789: PUSH
70790: LD_VAR 0 1
70794: PUSH
70795: LD_VAR 0 3
70799: IN
70800: ST_TO_ADDR
// end ;
70801: LD_VAR 0 3
70805: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
70806: LD_INT 0
70808: PPUSH
// if not chassis or not weapon then
70809: LD_VAR 0 1
70813: NOT
70814: PUSH
70815: LD_VAR 0 2
70819: NOT
70820: OR
70821: IFFALSE 70825
// exit ;
70823: GO 71885
// case weapon of us_machine_gun :
70825: LD_VAR 0 2
70829: PUSH
70830: LD_INT 2
70832: DOUBLE
70833: EQUAL
70834: IFTRUE 70838
70836: GO 70868
70838: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
70839: LD_ADDR_VAR 0 3
70843: PUSH
70844: LD_INT 1
70846: PUSH
70847: LD_INT 2
70849: PUSH
70850: LD_INT 3
70852: PUSH
70853: LD_INT 4
70855: PUSH
70856: LD_INT 5
70858: PUSH
70859: EMPTY
70860: LIST
70861: LIST
70862: LIST
70863: LIST
70864: LIST
70865: ST_TO_ADDR
70866: GO 71869
70868: LD_INT 3
70870: DOUBLE
70871: EQUAL
70872: IFTRUE 70876
70874: GO 70906
70876: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
70877: LD_ADDR_VAR 0 3
70881: PUSH
70882: LD_INT 1
70884: PUSH
70885: LD_INT 2
70887: PUSH
70888: LD_INT 3
70890: PUSH
70891: LD_INT 4
70893: PUSH
70894: LD_INT 5
70896: PUSH
70897: EMPTY
70898: LIST
70899: LIST
70900: LIST
70901: LIST
70902: LIST
70903: ST_TO_ADDR
70904: GO 71869
70906: LD_INT 11
70908: DOUBLE
70909: EQUAL
70910: IFTRUE 70914
70912: GO 70944
70914: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
70915: LD_ADDR_VAR 0 3
70919: PUSH
70920: LD_INT 1
70922: PUSH
70923: LD_INT 2
70925: PUSH
70926: LD_INT 3
70928: PUSH
70929: LD_INT 4
70931: PUSH
70932: LD_INT 5
70934: PUSH
70935: EMPTY
70936: LIST
70937: LIST
70938: LIST
70939: LIST
70940: LIST
70941: ST_TO_ADDR
70942: GO 71869
70944: LD_INT 4
70946: DOUBLE
70947: EQUAL
70948: IFTRUE 70952
70950: GO 70978
70952: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
70953: LD_ADDR_VAR 0 3
70957: PUSH
70958: LD_INT 2
70960: PUSH
70961: LD_INT 3
70963: PUSH
70964: LD_INT 4
70966: PUSH
70967: LD_INT 5
70969: PUSH
70970: EMPTY
70971: LIST
70972: LIST
70973: LIST
70974: LIST
70975: ST_TO_ADDR
70976: GO 71869
70978: LD_INT 5
70980: DOUBLE
70981: EQUAL
70982: IFTRUE 70986
70984: GO 71012
70986: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
70987: LD_ADDR_VAR 0 3
70991: PUSH
70992: LD_INT 2
70994: PUSH
70995: LD_INT 3
70997: PUSH
70998: LD_INT 4
71000: PUSH
71001: LD_INT 5
71003: PUSH
71004: EMPTY
71005: LIST
71006: LIST
71007: LIST
71008: LIST
71009: ST_TO_ADDR
71010: GO 71869
71012: LD_INT 9
71014: DOUBLE
71015: EQUAL
71016: IFTRUE 71020
71018: GO 71046
71020: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
71021: LD_ADDR_VAR 0 3
71025: PUSH
71026: LD_INT 2
71028: PUSH
71029: LD_INT 3
71031: PUSH
71032: LD_INT 4
71034: PUSH
71035: LD_INT 5
71037: PUSH
71038: EMPTY
71039: LIST
71040: LIST
71041: LIST
71042: LIST
71043: ST_TO_ADDR
71044: GO 71869
71046: LD_INT 7
71048: DOUBLE
71049: EQUAL
71050: IFTRUE 71054
71052: GO 71080
71054: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
71055: LD_ADDR_VAR 0 3
71059: PUSH
71060: LD_INT 2
71062: PUSH
71063: LD_INT 3
71065: PUSH
71066: LD_INT 4
71068: PUSH
71069: LD_INT 5
71071: PUSH
71072: EMPTY
71073: LIST
71074: LIST
71075: LIST
71076: LIST
71077: ST_TO_ADDR
71078: GO 71869
71080: LD_INT 12
71082: DOUBLE
71083: EQUAL
71084: IFTRUE 71088
71086: GO 71114
71088: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
71089: LD_ADDR_VAR 0 3
71093: PUSH
71094: LD_INT 2
71096: PUSH
71097: LD_INT 3
71099: PUSH
71100: LD_INT 4
71102: PUSH
71103: LD_INT 5
71105: PUSH
71106: EMPTY
71107: LIST
71108: LIST
71109: LIST
71110: LIST
71111: ST_TO_ADDR
71112: GO 71869
71114: LD_INT 13
71116: DOUBLE
71117: EQUAL
71118: IFTRUE 71122
71120: GO 71148
71122: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
71123: LD_ADDR_VAR 0 3
71127: PUSH
71128: LD_INT 2
71130: PUSH
71131: LD_INT 3
71133: PUSH
71134: LD_INT 4
71136: PUSH
71137: LD_INT 5
71139: PUSH
71140: EMPTY
71141: LIST
71142: LIST
71143: LIST
71144: LIST
71145: ST_TO_ADDR
71146: GO 71869
71148: LD_INT 14
71150: DOUBLE
71151: EQUAL
71152: IFTRUE 71156
71154: GO 71174
71156: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
71157: LD_ADDR_VAR 0 3
71161: PUSH
71162: LD_INT 4
71164: PUSH
71165: LD_INT 5
71167: PUSH
71168: EMPTY
71169: LIST
71170: LIST
71171: ST_TO_ADDR
71172: GO 71869
71174: LD_INT 6
71176: DOUBLE
71177: EQUAL
71178: IFTRUE 71182
71180: GO 71200
71182: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
71183: LD_ADDR_VAR 0 3
71187: PUSH
71188: LD_INT 4
71190: PUSH
71191: LD_INT 5
71193: PUSH
71194: EMPTY
71195: LIST
71196: LIST
71197: ST_TO_ADDR
71198: GO 71869
71200: LD_INT 10
71202: DOUBLE
71203: EQUAL
71204: IFTRUE 71208
71206: GO 71226
71208: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
71209: LD_ADDR_VAR 0 3
71213: PUSH
71214: LD_INT 4
71216: PUSH
71217: LD_INT 5
71219: PUSH
71220: EMPTY
71221: LIST
71222: LIST
71223: ST_TO_ADDR
71224: GO 71869
71226: LD_INT 22
71228: DOUBLE
71229: EQUAL
71230: IFTRUE 71234
71232: GO 71260
71234: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
71235: LD_ADDR_VAR 0 3
71239: PUSH
71240: LD_INT 11
71242: PUSH
71243: LD_INT 12
71245: PUSH
71246: LD_INT 13
71248: PUSH
71249: LD_INT 14
71251: PUSH
71252: EMPTY
71253: LIST
71254: LIST
71255: LIST
71256: LIST
71257: ST_TO_ADDR
71258: GO 71869
71260: LD_INT 23
71262: DOUBLE
71263: EQUAL
71264: IFTRUE 71268
71266: GO 71294
71268: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
71269: LD_ADDR_VAR 0 3
71273: PUSH
71274: LD_INT 11
71276: PUSH
71277: LD_INT 12
71279: PUSH
71280: LD_INT 13
71282: PUSH
71283: LD_INT 14
71285: PUSH
71286: EMPTY
71287: LIST
71288: LIST
71289: LIST
71290: LIST
71291: ST_TO_ADDR
71292: GO 71869
71294: LD_INT 24
71296: DOUBLE
71297: EQUAL
71298: IFTRUE 71302
71300: GO 71328
71302: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
71303: LD_ADDR_VAR 0 3
71307: PUSH
71308: LD_INT 11
71310: PUSH
71311: LD_INT 12
71313: PUSH
71314: LD_INT 13
71316: PUSH
71317: LD_INT 14
71319: PUSH
71320: EMPTY
71321: LIST
71322: LIST
71323: LIST
71324: LIST
71325: ST_TO_ADDR
71326: GO 71869
71328: LD_INT 30
71330: DOUBLE
71331: EQUAL
71332: IFTRUE 71336
71334: GO 71362
71336: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
71337: LD_ADDR_VAR 0 3
71341: PUSH
71342: LD_INT 11
71344: PUSH
71345: LD_INT 12
71347: PUSH
71348: LD_INT 13
71350: PUSH
71351: LD_INT 14
71353: PUSH
71354: EMPTY
71355: LIST
71356: LIST
71357: LIST
71358: LIST
71359: ST_TO_ADDR
71360: GO 71869
71362: LD_INT 25
71364: DOUBLE
71365: EQUAL
71366: IFTRUE 71370
71368: GO 71388
71370: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
71371: LD_ADDR_VAR 0 3
71375: PUSH
71376: LD_INT 13
71378: PUSH
71379: LD_INT 14
71381: PUSH
71382: EMPTY
71383: LIST
71384: LIST
71385: ST_TO_ADDR
71386: GO 71869
71388: LD_INT 27
71390: DOUBLE
71391: EQUAL
71392: IFTRUE 71396
71394: GO 71414
71396: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
71397: LD_ADDR_VAR 0 3
71401: PUSH
71402: LD_INT 13
71404: PUSH
71405: LD_INT 14
71407: PUSH
71408: EMPTY
71409: LIST
71410: LIST
71411: ST_TO_ADDR
71412: GO 71869
71414: LD_INT 92
71416: DOUBLE
71417: EQUAL
71418: IFTRUE 71422
71420: GO 71448
71422: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
71423: LD_ADDR_VAR 0 3
71427: PUSH
71428: LD_INT 11
71430: PUSH
71431: LD_INT 12
71433: PUSH
71434: LD_INT 13
71436: PUSH
71437: LD_INT 14
71439: PUSH
71440: EMPTY
71441: LIST
71442: LIST
71443: LIST
71444: LIST
71445: ST_TO_ADDR
71446: GO 71869
71448: LD_INT 28
71450: DOUBLE
71451: EQUAL
71452: IFTRUE 71456
71454: GO 71474
71456: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
71457: LD_ADDR_VAR 0 3
71461: PUSH
71462: LD_INT 13
71464: PUSH
71465: LD_INT 14
71467: PUSH
71468: EMPTY
71469: LIST
71470: LIST
71471: ST_TO_ADDR
71472: GO 71869
71474: LD_INT 29
71476: DOUBLE
71477: EQUAL
71478: IFTRUE 71482
71480: GO 71500
71482: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
71483: LD_ADDR_VAR 0 3
71487: PUSH
71488: LD_INT 13
71490: PUSH
71491: LD_INT 14
71493: PUSH
71494: EMPTY
71495: LIST
71496: LIST
71497: ST_TO_ADDR
71498: GO 71869
71500: LD_INT 31
71502: DOUBLE
71503: EQUAL
71504: IFTRUE 71508
71506: GO 71526
71508: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
71509: LD_ADDR_VAR 0 3
71513: PUSH
71514: LD_INT 13
71516: PUSH
71517: LD_INT 14
71519: PUSH
71520: EMPTY
71521: LIST
71522: LIST
71523: ST_TO_ADDR
71524: GO 71869
71526: LD_INT 26
71528: DOUBLE
71529: EQUAL
71530: IFTRUE 71534
71532: GO 71552
71534: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
71535: LD_ADDR_VAR 0 3
71539: PUSH
71540: LD_INT 13
71542: PUSH
71543: LD_INT 14
71545: PUSH
71546: EMPTY
71547: LIST
71548: LIST
71549: ST_TO_ADDR
71550: GO 71869
71552: LD_INT 42
71554: DOUBLE
71555: EQUAL
71556: IFTRUE 71560
71558: GO 71586
71560: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
71561: LD_ADDR_VAR 0 3
71565: PUSH
71566: LD_INT 21
71568: PUSH
71569: LD_INT 22
71571: PUSH
71572: LD_INT 23
71574: PUSH
71575: LD_INT 24
71577: PUSH
71578: EMPTY
71579: LIST
71580: LIST
71581: LIST
71582: LIST
71583: ST_TO_ADDR
71584: GO 71869
71586: LD_INT 43
71588: DOUBLE
71589: EQUAL
71590: IFTRUE 71594
71592: GO 71620
71594: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
71595: LD_ADDR_VAR 0 3
71599: PUSH
71600: LD_INT 21
71602: PUSH
71603: LD_INT 22
71605: PUSH
71606: LD_INT 23
71608: PUSH
71609: LD_INT 24
71611: PUSH
71612: EMPTY
71613: LIST
71614: LIST
71615: LIST
71616: LIST
71617: ST_TO_ADDR
71618: GO 71869
71620: LD_INT 44
71622: DOUBLE
71623: EQUAL
71624: IFTRUE 71628
71626: GO 71654
71628: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
71629: LD_ADDR_VAR 0 3
71633: PUSH
71634: LD_INT 21
71636: PUSH
71637: LD_INT 22
71639: PUSH
71640: LD_INT 23
71642: PUSH
71643: LD_INT 24
71645: PUSH
71646: EMPTY
71647: LIST
71648: LIST
71649: LIST
71650: LIST
71651: ST_TO_ADDR
71652: GO 71869
71654: LD_INT 45
71656: DOUBLE
71657: EQUAL
71658: IFTRUE 71662
71660: GO 71688
71662: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
71663: LD_ADDR_VAR 0 3
71667: PUSH
71668: LD_INT 21
71670: PUSH
71671: LD_INT 22
71673: PUSH
71674: LD_INT 23
71676: PUSH
71677: LD_INT 24
71679: PUSH
71680: EMPTY
71681: LIST
71682: LIST
71683: LIST
71684: LIST
71685: ST_TO_ADDR
71686: GO 71869
71688: LD_INT 49
71690: DOUBLE
71691: EQUAL
71692: IFTRUE 71696
71694: GO 71722
71696: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
71697: LD_ADDR_VAR 0 3
71701: PUSH
71702: LD_INT 21
71704: PUSH
71705: LD_INT 22
71707: PUSH
71708: LD_INT 23
71710: PUSH
71711: LD_INT 24
71713: PUSH
71714: EMPTY
71715: LIST
71716: LIST
71717: LIST
71718: LIST
71719: ST_TO_ADDR
71720: GO 71869
71722: LD_INT 51
71724: DOUBLE
71725: EQUAL
71726: IFTRUE 71730
71728: GO 71756
71730: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
71731: LD_ADDR_VAR 0 3
71735: PUSH
71736: LD_INT 21
71738: PUSH
71739: LD_INT 22
71741: PUSH
71742: LD_INT 23
71744: PUSH
71745: LD_INT 24
71747: PUSH
71748: EMPTY
71749: LIST
71750: LIST
71751: LIST
71752: LIST
71753: ST_TO_ADDR
71754: GO 71869
71756: LD_INT 52
71758: DOUBLE
71759: EQUAL
71760: IFTRUE 71764
71762: GO 71790
71764: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
71765: LD_ADDR_VAR 0 3
71769: PUSH
71770: LD_INT 21
71772: PUSH
71773: LD_INT 22
71775: PUSH
71776: LD_INT 23
71778: PUSH
71779: LD_INT 24
71781: PUSH
71782: EMPTY
71783: LIST
71784: LIST
71785: LIST
71786: LIST
71787: ST_TO_ADDR
71788: GO 71869
71790: LD_INT 53
71792: DOUBLE
71793: EQUAL
71794: IFTRUE 71798
71796: GO 71816
71798: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
71799: LD_ADDR_VAR 0 3
71803: PUSH
71804: LD_INT 23
71806: PUSH
71807: LD_INT 24
71809: PUSH
71810: EMPTY
71811: LIST
71812: LIST
71813: ST_TO_ADDR
71814: GO 71869
71816: LD_INT 46
71818: DOUBLE
71819: EQUAL
71820: IFTRUE 71824
71822: GO 71842
71824: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
71825: LD_ADDR_VAR 0 3
71829: PUSH
71830: LD_INT 23
71832: PUSH
71833: LD_INT 24
71835: PUSH
71836: EMPTY
71837: LIST
71838: LIST
71839: ST_TO_ADDR
71840: GO 71869
71842: LD_INT 47
71844: DOUBLE
71845: EQUAL
71846: IFTRUE 71850
71848: GO 71868
71850: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
71851: LD_ADDR_VAR 0 3
71855: PUSH
71856: LD_INT 23
71858: PUSH
71859: LD_INT 24
71861: PUSH
71862: EMPTY
71863: LIST
71864: LIST
71865: ST_TO_ADDR
71866: GO 71869
71868: POP
// result := ( chassis in result ) ;
71869: LD_ADDR_VAR 0 3
71873: PUSH
71874: LD_VAR 0 1
71878: PUSH
71879: LD_VAR 0 3
71883: IN
71884: ST_TO_ADDR
// end ;
71885: LD_VAR 0 3
71889: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
71890: LD_INT 0
71892: PPUSH
71893: PPUSH
71894: PPUSH
71895: PPUSH
71896: PPUSH
71897: PPUSH
71898: PPUSH
// result := array ;
71899: LD_ADDR_VAR 0 5
71903: PUSH
71904: LD_VAR 0 1
71908: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
71909: LD_VAR 0 1
71913: NOT
71914: PUSH
71915: LD_VAR 0 2
71919: NOT
71920: OR
71921: PUSH
71922: LD_VAR 0 3
71926: NOT
71927: OR
71928: PUSH
71929: LD_VAR 0 2
71933: PUSH
71934: LD_VAR 0 1
71938: GREATER
71939: OR
71940: PUSH
71941: LD_VAR 0 3
71945: PUSH
71946: LD_VAR 0 1
71950: GREATER
71951: OR
71952: IFFALSE 71956
// exit ;
71954: GO 72252
// if direction then
71956: LD_VAR 0 4
71960: IFFALSE 72024
// begin d := 1 ;
71962: LD_ADDR_VAR 0 9
71966: PUSH
71967: LD_INT 1
71969: ST_TO_ADDR
// if i_from > i_to then
71970: LD_VAR 0 2
71974: PUSH
71975: LD_VAR 0 3
71979: GREATER
71980: IFFALSE 72006
// length := ( array - i_from ) + i_to else
71982: LD_ADDR_VAR 0 11
71986: PUSH
71987: LD_VAR 0 1
71991: PUSH
71992: LD_VAR 0 2
71996: MINUS
71997: PUSH
71998: LD_VAR 0 3
72002: PLUS
72003: ST_TO_ADDR
72004: GO 72022
// length := i_to - i_from ;
72006: LD_ADDR_VAR 0 11
72010: PUSH
72011: LD_VAR 0 3
72015: PUSH
72016: LD_VAR 0 2
72020: MINUS
72021: ST_TO_ADDR
// end else
72022: GO 72085
// begin d := - 1 ;
72024: LD_ADDR_VAR 0 9
72028: PUSH
72029: LD_INT 1
72031: NEG
72032: ST_TO_ADDR
// if i_from > i_to then
72033: LD_VAR 0 2
72037: PUSH
72038: LD_VAR 0 3
72042: GREATER
72043: IFFALSE 72063
// length := i_from - i_to else
72045: LD_ADDR_VAR 0 11
72049: PUSH
72050: LD_VAR 0 2
72054: PUSH
72055: LD_VAR 0 3
72059: MINUS
72060: ST_TO_ADDR
72061: GO 72085
// length := ( array - i_to ) + i_from ;
72063: LD_ADDR_VAR 0 11
72067: PUSH
72068: LD_VAR 0 1
72072: PUSH
72073: LD_VAR 0 3
72077: MINUS
72078: PUSH
72079: LD_VAR 0 2
72083: PLUS
72084: ST_TO_ADDR
// end ; if not length then
72085: LD_VAR 0 11
72089: NOT
72090: IFFALSE 72094
// exit ;
72092: GO 72252
// tmp := array ;
72094: LD_ADDR_VAR 0 10
72098: PUSH
72099: LD_VAR 0 1
72103: ST_TO_ADDR
// for i = 1 to length do
72104: LD_ADDR_VAR 0 6
72108: PUSH
72109: DOUBLE
72110: LD_INT 1
72112: DEC
72113: ST_TO_ADDR
72114: LD_VAR 0 11
72118: PUSH
72119: FOR_TO
72120: IFFALSE 72240
// begin for j = 1 to array do
72122: LD_ADDR_VAR 0 7
72126: PUSH
72127: DOUBLE
72128: LD_INT 1
72130: DEC
72131: ST_TO_ADDR
72132: LD_VAR 0 1
72136: PUSH
72137: FOR_TO
72138: IFFALSE 72226
// begin k := j + d ;
72140: LD_ADDR_VAR 0 8
72144: PUSH
72145: LD_VAR 0 7
72149: PUSH
72150: LD_VAR 0 9
72154: PLUS
72155: ST_TO_ADDR
// if k > array then
72156: LD_VAR 0 8
72160: PUSH
72161: LD_VAR 0 1
72165: GREATER
72166: IFFALSE 72176
// k := 1 ;
72168: LD_ADDR_VAR 0 8
72172: PUSH
72173: LD_INT 1
72175: ST_TO_ADDR
// if not k then
72176: LD_VAR 0 8
72180: NOT
72181: IFFALSE 72193
// k := array ;
72183: LD_ADDR_VAR 0 8
72187: PUSH
72188: LD_VAR 0 1
72192: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
72193: LD_ADDR_VAR 0 10
72197: PUSH
72198: LD_VAR 0 10
72202: PPUSH
72203: LD_VAR 0 8
72207: PPUSH
72208: LD_VAR 0 1
72212: PUSH
72213: LD_VAR 0 7
72217: ARRAY
72218: PPUSH
72219: CALL_OW 1
72223: ST_TO_ADDR
// end ;
72224: GO 72137
72226: POP
72227: POP
// array := tmp ;
72228: LD_ADDR_VAR 0 1
72232: PUSH
72233: LD_VAR 0 10
72237: ST_TO_ADDR
// end ;
72238: GO 72119
72240: POP
72241: POP
// result := array ;
72242: LD_ADDR_VAR 0 5
72246: PUSH
72247: LD_VAR 0 1
72251: ST_TO_ADDR
// end ;
72252: LD_VAR 0 5
72256: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
72257: LD_INT 0
72259: PPUSH
72260: PPUSH
// result := 0 ;
72261: LD_ADDR_VAR 0 3
72265: PUSH
72266: LD_INT 0
72268: ST_TO_ADDR
// if not array or not value in array then
72269: LD_VAR 0 1
72273: NOT
72274: PUSH
72275: LD_VAR 0 2
72279: PUSH
72280: LD_VAR 0 1
72284: IN
72285: NOT
72286: OR
72287: IFFALSE 72291
// exit ;
72289: GO 72345
// for i = 1 to array do
72291: LD_ADDR_VAR 0 4
72295: PUSH
72296: DOUBLE
72297: LD_INT 1
72299: DEC
72300: ST_TO_ADDR
72301: LD_VAR 0 1
72305: PUSH
72306: FOR_TO
72307: IFFALSE 72343
// if value = array [ i ] then
72309: LD_VAR 0 2
72313: PUSH
72314: LD_VAR 0 1
72318: PUSH
72319: LD_VAR 0 4
72323: ARRAY
72324: EQUAL
72325: IFFALSE 72341
// begin result := i ;
72327: LD_ADDR_VAR 0 3
72331: PUSH
72332: LD_VAR 0 4
72336: ST_TO_ADDR
// exit ;
72337: POP
72338: POP
72339: GO 72345
// end ;
72341: GO 72306
72343: POP
72344: POP
// end ;
72345: LD_VAR 0 3
72349: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
72350: LD_INT 0
72352: PPUSH
// vc_chassis := chassis ;
72353: LD_ADDR_OWVAR 37
72357: PUSH
72358: LD_VAR 0 1
72362: ST_TO_ADDR
// vc_engine := engine ;
72363: LD_ADDR_OWVAR 39
72367: PUSH
72368: LD_VAR 0 2
72372: ST_TO_ADDR
// vc_control := control ;
72373: LD_ADDR_OWVAR 38
72377: PUSH
72378: LD_VAR 0 3
72382: ST_TO_ADDR
// vc_weapon := weapon ;
72383: LD_ADDR_OWVAR 40
72387: PUSH
72388: LD_VAR 0 4
72392: ST_TO_ADDR
// vc_fuel_battery := fuel ;
72393: LD_ADDR_OWVAR 41
72397: PUSH
72398: LD_VAR 0 5
72402: ST_TO_ADDR
// end ;
72403: LD_VAR 0 6
72407: RET
// export function WantPlant ( unit ) ; var task ; begin
72408: LD_INT 0
72410: PPUSH
72411: PPUSH
// result := false ;
72412: LD_ADDR_VAR 0 2
72416: PUSH
72417: LD_INT 0
72419: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
72420: LD_ADDR_VAR 0 3
72424: PUSH
72425: LD_VAR 0 1
72429: PPUSH
72430: CALL_OW 437
72434: ST_TO_ADDR
// if task then
72435: LD_VAR 0 3
72439: IFFALSE 72467
// if task [ 1 ] [ 1 ] = p then
72441: LD_VAR 0 3
72445: PUSH
72446: LD_INT 1
72448: ARRAY
72449: PUSH
72450: LD_INT 1
72452: ARRAY
72453: PUSH
72454: LD_STRING p
72456: EQUAL
72457: IFFALSE 72467
// result := true ;
72459: LD_ADDR_VAR 0 2
72463: PUSH
72464: LD_INT 1
72466: ST_TO_ADDR
// end ;
72467: LD_VAR 0 2
72471: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
72472: LD_INT 0
72474: PPUSH
72475: PPUSH
72476: PPUSH
72477: PPUSH
// if pos < 1 then
72478: LD_VAR 0 2
72482: PUSH
72483: LD_INT 1
72485: LESS
72486: IFFALSE 72490
// exit ;
72488: GO 72793
// if pos = 1 then
72490: LD_VAR 0 2
72494: PUSH
72495: LD_INT 1
72497: EQUAL
72498: IFFALSE 72531
// result := Replace ( arr , pos [ 1 ] , value ) else
72500: LD_ADDR_VAR 0 4
72504: PUSH
72505: LD_VAR 0 1
72509: PPUSH
72510: LD_VAR 0 2
72514: PUSH
72515: LD_INT 1
72517: ARRAY
72518: PPUSH
72519: LD_VAR 0 3
72523: PPUSH
72524: CALL_OW 1
72528: ST_TO_ADDR
72529: GO 72793
// begin tmp := arr ;
72531: LD_ADDR_VAR 0 6
72535: PUSH
72536: LD_VAR 0 1
72540: ST_TO_ADDR
// s_arr := [ tmp ] ;
72541: LD_ADDR_VAR 0 7
72545: PUSH
72546: LD_VAR 0 6
72550: PUSH
72551: EMPTY
72552: LIST
72553: ST_TO_ADDR
// for i = 1 to pos - 1 do
72554: LD_ADDR_VAR 0 5
72558: PUSH
72559: DOUBLE
72560: LD_INT 1
72562: DEC
72563: ST_TO_ADDR
72564: LD_VAR 0 2
72568: PUSH
72569: LD_INT 1
72571: MINUS
72572: PUSH
72573: FOR_TO
72574: IFFALSE 72619
// begin tmp := tmp [ pos [ i ] ] ;
72576: LD_ADDR_VAR 0 6
72580: PUSH
72581: LD_VAR 0 6
72585: PUSH
72586: LD_VAR 0 2
72590: PUSH
72591: LD_VAR 0 5
72595: ARRAY
72596: ARRAY
72597: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
72598: LD_ADDR_VAR 0 7
72602: PUSH
72603: LD_VAR 0 7
72607: PUSH
72608: LD_VAR 0 6
72612: PUSH
72613: EMPTY
72614: LIST
72615: ADD
72616: ST_TO_ADDR
// end ;
72617: GO 72573
72619: POP
72620: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
72621: LD_ADDR_VAR 0 6
72625: PUSH
72626: LD_VAR 0 6
72630: PPUSH
72631: LD_VAR 0 2
72635: PUSH
72636: LD_VAR 0 2
72640: ARRAY
72641: PPUSH
72642: LD_VAR 0 3
72646: PPUSH
72647: CALL_OW 1
72651: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
72652: LD_ADDR_VAR 0 7
72656: PUSH
72657: LD_VAR 0 7
72661: PPUSH
72662: LD_VAR 0 7
72666: PPUSH
72667: LD_VAR 0 6
72671: PPUSH
72672: CALL_OW 1
72676: ST_TO_ADDR
// for i = s_arr downto 2 do
72677: LD_ADDR_VAR 0 5
72681: PUSH
72682: DOUBLE
72683: LD_VAR 0 7
72687: INC
72688: ST_TO_ADDR
72689: LD_INT 2
72691: PUSH
72692: FOR_DOWNTO
72693: IFFALSE 72777
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
72695: LD_ADDR_VAR 0 6
72699: PUSH
72700: LD_VAR 0 7
72704: PUSH
72705: LD_VAR 0 5
72709: PUSH
72710: LD_INT 1
72712: MINUS
72713: ARRAY
72714: PPUSH
72715: LD_VAR 0 2
72719: PUSH
72720: LD_VAR 0 5
72724: PUSH
72725: LD_INT 1
72727: MINUS
72728: ARRAY
72729: PPUSH
72730: LD_VAR 0 7
72734: PUSH
72735: LD_VAR 0 5
72739: ARRAY
72740: PPUSH
72741: CALL_OW 1
72745: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
72746: LD_ADDR_VAR 0 7
72750: PUSH
72751: LD_VAR 0 7
72755: PPUSH
72756: LD_VAR 0 5
72760: PUSH
72761: LD_INT 1
72763: MINUS
72764: PPUSH
72765: LD_VAR 0 6
72769: PPUSH
72770: CALL_OW 1
72774: ST_TO_ADDR
// end ;
72775: GO 72692
72777: POP
72778: POP
// result := s_arr [ 1 ] ;
72779: LD_ADDR_VAR 0 4
72783: PUSH
72784: LD_VAR 0 7
72788: PUSH
72789: LD_INT 1
72791: ARRAY
72792: ST_TO_ADDR
// end ; end ;
72793: LD_VAR 0 4
72797: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
72798: LD_INT 0
72800: PPUSH
72801: PPUSH
// if not list then
72802: LD_VAR 0 1
72806: NOT
72807: IFFALSE 72811
// exit ;
72809: GO 72902
// i := list [ pos1 ] ;
72811: LD_ADDR_VAR 0 5
72815: PUSH
72816: LD_VAR 0 1
72820: PUSH
72821: LD_VAR 0 2
72825: ARRAY
72826: ST_TO_ADDR
// if not i then
72827: LD_VAR 0 5
72831: NOT
72832: IFFALSE 72836
// exit ;
72834: GO 72902
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
72836: LD_ADDR_VAR 0 1
72840: PUSH
72841: LD_VAR 0 1
72845: PPUSH
72846: LD_VAR 0 2
72850: PPUSH
72851: LD_VAR 0 1
72855: PUSH
72856: LD_VAR 0 3
72860: ARRAY
72861: PPUSH
72862: CALL_OW 1
72866: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
72867: LD_ADDR_VAR 0 1
72871: PUSH
72872: LD_VAR 0 1
72876: PPUSH
72877: LD_VAR 0 3
72881: PPUSH
72882: LD_VAR 0 5
72886: PPUSH
72887: CALL_OW 1
72891: ST_TO_ADDR
// result := list ;
72892: LD_ADDR_VAR 0 4
72896: PUSH
72897: LD_VAR 0 1
72901: ST_TO_ADDR
// end ;
72902: LD_VAR 0 4
72906: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
72907: LD_INT 0
72909: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
72910: LD_ADDR_VAR 0 5
72914: PUSH
72915: LD_VAR 0 1
72919: PPUSH
72920: CALL_OW 250
72924: PPUSH
72925: LD_VAR 0 1
72929: PPUSH
72930: CALL_OW 251
72934: PPUSH
72935: LD_VAR 0 2
72939: PPUSH
72940: LD_VAR 0 3
72944: PPUSH
72945: LD_VAR 0 4
72949: PPUSH
72950: CALL 72960 0 5
72954: ST_TO_ADDR
// end ;
72955: LD_VAR 0 5
72959: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
72960: LD_INT 0
72962: PPUSH
72963: PPUSH
72964: PPUSH
72965: PPUSH
// if not list then
72966: LD_VAR 0 3
72970: NOT
72971: IFFALSE 72975
// exit ;
72973: GO 73363
// result := [ ] ;
72975: LD_ADDR_VAR 0 6
72979: PUSH
72980: EMPTY
72981: ST_TO_ADDR
// for i in list do
72982: LD_ADDR_VAR 0 7
72986: PUSH
72987: LD_VAR 0 3
72991: PUSH
72992: FOR_IN
72993: IFFALSE 73195
// begin tmp := GetDistUnitXY ( i , x , y ) ;
72995: LD_ADDR_VAR 0 9
72999: PUSH
73000: LD_VAR 0 7
73004: PPUSH
73005: LD_VAR 0 1
73009: PPUSH
73010: LD_VAR 0 2
73014: PPUSH
73015: CALL_OW 297
73019: ST_TO_ADDR
// if not result then
73020: LD_VAR 0 6
73024: NOT
73025: IFFALSE 73051
// result := [ [ i , tmp ] ] else
73027: LD_ADDR_VAR 0 6
73031: PUSH
73032: LD_VAR 0 7
73036: PUSH
73037: LD_VAR 0 9
73041: PUSH
73042: EMPTY
73043: LIST
73044: LIST
73045: PUSH
73046: EMPTY
73047: LIST
73048: ST_TO_ADDR
73049: GO 73193
// begin if result [ result ] [ 2 ] < tmp then
73051: LD_VAR 0 6
73055: PUSH
73056: LD_VAR 0 6
73060: ARRAY
73061: PUSH
73062: LD_INT 2
73064: ARRAY
73065: PUSH
73066: LD_VAR 0 9
73070: LESS
73071: IFFALSE 73113
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
73073: LD_ADDR_VAR 0 6
73077: PUSH
73078: LD_VAR 0 6
73082: PPUSH
73083: LD_VAR 0 6
73087: PUSH
73088: LD_INT 1
73090: PLUS
73091: PPUSH
73092: LD_VAR 0 7
73096: PUSH
73097: LD_VAR 0 9
73101: PUSH
73102: EMPTY
73103: LIST
73104: LIST
73105: PPUSH
73106: CALL_OW 2
73110: ST_TO_ADDR
73111: GO 73193
// for j = 1 to result do
73113: LD_ADDR_VAR 0 8
73117: PUSH
73118: DOUBLE
73119: LD_INT 1
73121: DEC
73122: ST_TO_ADDR
73123: LD_VAR 0 6
73127: PUSH
73128: FOR_TO
73129: IFFALSE 73191
// begin if tmp < result [ j ] [ 2 ] then
73131: LD_VAR 0 9
73135: PUSH
73136: LD_VAR 0 6
73140: PUSH
73141: LD_VAR 0 8
73145: ARRAY
73146: PUSH
73147: LD_INT 2
73149: ARRAY
73150: LESS
73151: IFFALSE 73189
// begin result := Insert ( result , j , [ i , tmp ] ) ;
73153: LD_ADDR_VAR 0 6
73157: PUSH
73158: LD_VAR 0 6
73162: PPUSH
73163: LD_VAR 0 8
73167: PPUSH
73168: LD_VAR 0 7
73172: PUSH
73173: LD_VAR 0 9
73177: PUSH
73178: EMPTY
73179: LIST
73180: LIST
73181: PPUSH
73182: CALL_OW 2
73186: ST_TO_ADDR
// break ;
73187: GO 73191
// end ; end ;
73189: GO 73128
73191: POP
73192: POP
// end ; end ;
73193: GO 72992
73195: POP
73196: POP
// if result and not asc then
73197: LD_VAR 0 6
73201: PUSH
73202: LD_VAR 0 4
73206: NOT
73207: AND
73208: IFFALSE 73283
// begin tmp := result ;
73210: LD_ADDR_VAR 0 9
73214: PUSH
73215: LD_VAR 0 6
73219: ST_TO_ADDR
// for i = tmp downto 1 do
73220: LD_ADDR_VAR 0 7
73224: PUSH
73225: DOUBLE
73226: LD_VAR 0 9
73230: INC
73231: ST_TO_ADDR
73232: LD_INT 1
73234: PUSH
73235: FOR_DOWNTO
73236: IFFALSE 73281
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
73238: LD_ADDR_VAR 0 6
73242: PUSH
73243: LD_VAR 0 6
73247: PPUSH
73248: LD_VAR 0 9
73252: PUSH
73253: LD_VAR 0 7
73257: MINUS
73258: PUSH
73259: LD_INT 1
73261: PLUS
73262: PPUSH
73263: LD_VAR 0 9
73267: PUSH
73268: LD_VAR 0 7
73272: ARRAY
73273: PPUSH
73274: CALL_OW 1
73278: ST_TO_ADDR
73279: GO 73235
73281: POP
73282: POP
// end ; tmp := [ ] ;
73283: LD_ADDR_VAR 0 9
73287: PUSH
73288: EMPTY
73289: ST_TO_ADDR
// if mode then
73290: LD_VAR 0 5
73294: IFFALSE 73363
// begin for i = 1 to result do
73296: LD_ADDR_VAR 0 7
73300: PUSH
73301: DOUBLE
73302: LD_INT 1
73304: DEC
73305: ST_TO_ADDR
73306: LD_VAR 0 6
73310: PUSH
73311: FOR_TO
73312: IFFALSE 73351
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
73314: LD_ADDR_VAR 0 9
73318: PUSH
73319: LD_VAR 0 9
73323: PPUSH
73324: LD_VAR 0 7
73328: PPUSH
73329: LD_VAR 0 6
73333: PUSH
73334: LD_VAR 0 7
73338: ARRAY
73339: PUSH
73340: LD_INT 1
73342: ARRAY
73343: PPUSH
73344: CALL_OW 1
73348: ST_TO_ADDR
73349: GO 73311
73351: POP
73352: POP
// result := tmp ;
73353: LD_ADDR_VAR 0 6
73357: PUSH
73358: LD_VAR 0 9
73362: ST_TO_ADDR
// end ; end ;
73363: LD_VAR 0 6
73367: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
73368: LD_INT 0
73370: PPUSH
73371: PPUSH
73372: PPUSH
73373: PPUSH
73374: PPUSH
73375: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
73376: LD_ADDR_VAR 0 5
73380: PUSH
73381: LD_INT 0
73383: PUSH
73384: LD_INT 0
73386: PUSH
73387: LD_INT 0
73389: PUSH
73390: EMPTY
73391: PUSH
73392: EMPTY
73393: LIST
73394: LIST
73395: LIST
73396: LIST
73397: ST_TO_ADDR
// if not x or not y then
73398: LD_VAR 0 2
73402: NOT
73403: PUSH
73404: LD_VAR 0 3
73408: NOT
73409: OR
73410: IFFALSE 73414
// exit ;
73412: GO 75064
// if not range then
73414: LD_VAR 0 4
73418: NOT
73419: IFFALSE 73429
// range := 10 ;
73421: LD_ADDR_VAR 0 4
73425: PUSH
73426: LD_INT 10
73428: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
73429: LD_ADDR_VAR 0 8
73433: PUSH
73434: LD_INT 81
73436: PUSH
73437: LD_VAR 0 1
73441: PUSH
73442: EMPTY
73443: LIST
73444: LIST
73445: PUSH
73446: LD_INT 92
73448: PUSH
73449: LD_VAR 0 2
73453: PUSH
73454: LD_VAR 0 3
73458: PUSH
73459: LD_VAR 0 4
73463: PUSH
73464: EMPTY
73465: LIST
73466: LIST
73467: LIST
73468: LIST
73469: PUSH
73470: LD_INT 3
73472: PUSH
73473: LD_INT 21
73475: PUSH
73476: LD_INT 3
73478: PUSH
73479: EMPTY
73480: LIST
73481: LIST
73482: PUSH
73483: EMPTY
73484: LIST
73485: LIST
73486: PUSH
73487: EMPTY
73488: LIST
73489: LIST
73490: LIST
73491: PPUSH
73492: CALL_OW 69
73496: ST_TO_ADDR
// if not tmp then
73497: LD_VAR 0 8
73501: NOT
73502: IFFALSE 73506
// exit ;
73504: GO 75064
// for i in tmp do
73506: LD_ADDR_VAR 0 6
73510: PUSH
73511: LD_VAR 0 8
73515: PUSH
73516: FOR_IN
73517: IFFALSE 75039
// begin points := [ 0 , 0 , 0 ] ;
73519: LD_ADDR_VAR 0 9
73523: PUSH
73524: LD_INT 0
73526: PUSH
73527: LD_INT 0
73529: PUSH
73530: LD_INT 0
73532: PUSH
73533: EMPTY
73534: LIST
73535: LIST
73536: LIST
73537: ST_TO_ADDR
// bpoints := 1 ;
73538: LD_ADDR_VAR 0 10
73542: PUSH
73543: LD_INT 1
73545: ST_TO_ADDR
// case GetType ( i ) of unit_human :
73546: LD_VAR 0 6
73550: PPUSH
73551: CALL_OW 247
73555: PUSH
73556: LD_INT 1
73558: DOUBLE
73559: EQUAL
73560: IFTRUE 73564
73562: GO 74142
73564: POP
// begin if GetClass ( i ) = 1 then
73565: LD_VAR 0 6
73569: PPUSH
73570: CALL_OW 257
73574: PUSH
73575: LD_INT 1
73577: EQUAL
73578: IFFALSE 73599
// points := [ 10 , 5 , 3 ] ;
73580: LD_ADDR_VAR 0 9
73584: PUSH
73585: LD_INT 10
73587: PUSH
73588: LD_INT 5
73590: PUSH
73591: LD_INT 3
73593: PUSH
73594: EMPTY
73595: LIST
73596: LIST
73597: LIST
73598: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
73599: LD_VAR 0 6
73603: PPUSH
73604: CALL_OW 257
73608: PUSH
73609: LD_INT 2
73611: PUSH
73612: LD_INT 3
73614: PUSH
73615: LD_INT 4
73617: PUSH
73618: EMPTY
73619: LIST
73620: LIST
73621: LIST
73622: IN
73623: IFFALSE 73644
// points := [ 3 , 2 , 1 ] ;
73625: LD_ADDR_VAR 0 9
73629: PUSH
73630: LD_INT 3
73632: PUSH
73633: LD_INT 2
73635: PUSH
73636: LD_INT 1
73638: PUSH
73639: EMPTY
73640: LIST
73641: LIST
73642: LIST
73643: ST_TO_ADDR
// if GetClass ( i ) = 5 then
73644: LD_VAR 0 6
73648: PPUSH
73649: CALL_OW 257
73653: PUSH
73654: LD_INT 5
73656: EQUAL
73657: IFFALSE 73678
// points := [ 130 , 5 , 2 ] ;
73659: LD_ADDR_VAR 0 9
73663: PUSH
73664: LD_INT 130
73666: PUSH
73667: LD_INT 5
73669: PUSH
73670: LD_INT 2
73672: PUSH
73673: EMPTY
73674: LIST
73675: LIST
73676: LIST
73677: ST_TO_ADDR
// if GetClass ( i ) = 8 then
73678: LD_VAR 0 6
73682: PPUSH
73683: CALL_OW 257
73687: PUSH
73688: LD_INT 8
73690: EQUAL
73691: IFFALSE 73712
// points := [ 35 , 35 , 30 ] ;
73693: LD_ADDR_VAR 0 9
73697: PUSH
73698: LD_INT 35
73700: PUSH
73701: LD_INT 35
73703: PUSH
73704: LD_INT 30
73706: PUSH
73707: EMPTY
73708: LIST
73709: LIST
73710: LIST
73711: ST_TO_ADDR
// if GetClass ( i ) = 9 then
73712: LD_VAR 0 6
73716: PPUSH
73717: CALL_OW 257
73721: PUSH
73722: LD_INT 9
73724: EQUAL
73725: IFFALSE 73746
// points := [ 20 , 55 , 40 ] ;
73727: LD_ADDR_VAR 0 9
73731: PUSH
73732: LD_INT 20
73734: PUSH
73735: LD_INT 55
73737: PUSH
73738: LD_INT 40
73740: PUSH
73741: EMPTY
73742: LIST
73743: LIST
73744: LIST
73745: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
73746: LD_VAR 0 6
73750: PPUSH
73751: CALL_OW 257
73755: PUSH
73756: LD_INT 12
73758: PUSH
73759: LD_INT 16
73761: PUSH
73762: EMPTY
73763: LIST
73764: LIST
73765: IN
73766: IFFALSE 73787
// points := [ 5 , 3 , 2 ] ;
73768: LD_ADDR_VAR 0 9
73772: PUSH
73773: LD_INT 5
73775: PUSH
73776: LD_INT 3
73778: PUSH
73779: LD_INT 2
73781: PUSH
73782: EMPTY
73783: LIST
73784: LIST
73785: LIST
73786: ST_TO_ADDR
// if GetClass ( i ) = 17 then
73787: LD_VAR 0 6
73791: PPUSH
73792: CALL_OW 257
73796: PUSH
73797: LD_INT 17
73799: EQUAL
73800: IFFALSE 73821
// points := [ 100 , 50 , 75 ] ;
73802: LD_ADDR_VAR 0 9
73806: PUSH
73807: LD_INT 100
73809: PUSH
73810: LD_INT 50
73812: PUSH
73813: LD_INT 75
73815: PUSH
73816: EMPTY
73817: LIST
73818: LIST
73819: LIST
73820: ST_TO_ADDR
// if GetClass ( i ) = 15 then
73821: LD_VAR 0 6
73825: PPUSH
73826: CALL_OW 257
73830: PUSH
73831: LD_INT 15
73833: EQUAL
73834: IFFALSE 73855
// points := [ 10 , 5 , 3 ] ;
73836: LD_ADDR_VAR 0 9
73840: PUSH
73841: LD_INT 10
73843: PUSH
73844: LD_INT 5
73846: PUSH
73847: LD_INT 3
73849: PUSH
73850: EMPTY
73851: LIST
73852: LIST
73853: LIST
73854: ST_TO_ADDR
// if GetClass ( i ) = 14 then
73855: LD_VAR 0 6
73859: PPUSH
73860: CALL_OW 257
73864: PUSH
73865: LD_INT 14
73867: EQUAL
73868: IFFALSE 73889
// points := [ 10 , 0 , 0 ] ;
73870: LD_ADDR_VAR 0 9
73874: PUSH
73875: LD_INT 10
73877: PUSH
73878: LD_INT 0
73880: PUSH
73881: LD_INT 0
73883: PUSH
73884: EMPTY
73885: LIST
73886: LIST
73887: LIST
73888: ST_TO_ADDR
// if GetClass ( i ) = 11 then
73889: LD_VAR 0 6
73893: PPUSH
73894: CALL_OW 257
73898: PUSH
73899: LD_INT 11
73901: EQUAL
73902: IFFALSE 73923
// points := [ 30 , 10 , 5 ] ;
73904: LD_ADDR_VAR 0 9
73908: PUSH
73909: LD_INT 30
73911: PUSH
73912: LD_INT 10
73914: PUSH
73915: LD_INT 5
73917: PUSH
73918: EMPTY
73919: LIST
73920: LIST
73921: LIST
73922: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
73923: LD_VAR 0 1
73927: PPUSH
73928: LD_INT 5
73930: PPUSH
73931: CALL_OW 321
73935: PUSH
73936: LD_INT 2
73938: EQUAL
73939: IFFALSE 73956
// bpoints := bpoints * 1.8 ;
73941: LD_ADDR_VAR 0 10
73945: PUSH
73946: LD_VAR 0 10
73950: PUSH
73951: LD_REAL  1.80000000000000E+0000
73954: MUL
73955: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
73956: LD_VAR 0 6
73960: PPUSH
73961: CALL_OW 257
73965: PUSH
73966: LD_INT 1
73968: PUSH
73969: LD_INT 2
73971: PUSH
73972: LD_INT 3
73974: PUSH
73975: LD_INT 4
73977: PUSH
73978: EMPTY
73979: LIST
73980: LIST
73981: LIST
73982: LIST
73983: IN
73984: PUSH
73985: LD_VAR 0 1
73989: PPUSH
73990: LD_INT 51
73992: PPUSH
73993: CALL_OW 321
73997: PUSH
73998: LD_INT 2
74000: EQUAL
74001: AND
74002: IFFALSE 74019
// bpoints := bpoints * 1.2 ;
74004: LD_ADDR_VAR 0 10
74008: PUSH
74009: LD_VAR 0 10
74013: PUSH
74014: LD_REAL  1.20000000000000E+0000
74017: MUL
74018: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
74019: LD_VAR 0 6
74023: PPUSH
74024: CALL_OW 257
74028: PUSH
74029: LD_INT 5
74031: PUSH
74032: LD_INT 7
74034: PUSH
74035: LD_INT 9
74037: PUSH
74038: EMPTY
74039: LIST
74040: LIST
74041: LIST
74042: IN
74043: PUSH
74044: LD_VAR 0 1
74048: PPUSH
74049: LD_INT 52
74051: PPUSH
74052: CALL_OW 321
74056: PUSH
74057: LD_INT 2
74059: EQUAL
74060: AND
74061: IFFALSE 74078
// bpoints := bpoints * 1.5 ;
74063: LD_ADDR_VAR 0 10
74067: PUSH
74068: LD_VAR 0 10
74072: PUSH
74073: LD_REAL  1.50000000000000E+0000
74076: MUL
74077: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
74078: LD_VAR 0 1
74082: PPUSH
74083: LD_INT 66
74085: PPUSH
74086: CALL_OW 321
74090: PUSH
74091: LD_INT 2
74093: EQUAL
74094: IFFALSE 74111
// bpoints := bpoints * 1.1 ;
74096: LD_ADDR_VAR 0 10
74100: PUSH
74101: LD_VAR 0 10
74105: PUSH
74106: LD_REAL  1.10000000000000E+0000
74109: MUL
74110: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
74111: LD_ADDR_VAR 0 10
74115: PUSH
74116: LD_VAR 0 10
74120: PUSH
74121: LD_VAR 0 6
74125: PPUSH
74126: LD_INT 1
74128: PPUSH
74129: CALL_OW 259
74133: PUSH
74134: LD_REAL  1.15000000000000E+0000
74137: MUL
74138: MUL
74139: ST_TO_ADDR
// end ; unit_vehicle :
74140: GO 74968
74142: LD_INT 2
74144: DOUBLE
74145: EQUAL
74146: IFTRUE 74150
74148: GO 74956
74150: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
74151: LD_VAR 0 6
74155: PPUSH
74156: CALL_OW 264
74160: PUSH
74161: LD_INT 2
74163: PUSH
74164: LD_INT 42
74166: PUSH
74167: LD_INT 24
74169: PUSH
74170: EMPTY
74171: LIST
74172: LIST
74173: LIST
74174: IN
74175: IFFALSE 74196
// points := [ 25 , 5 , 3 ] ;
74177: LD_ADDR_VAR 0 9
74181: PUSH
74182: LD_INT 25
74184: PUSH
74185: LD_INT 5
74187: PUSH
74188: LD_INT 3
74190: PUSH
74191: EMPTY
74192: LIST
74193: LIST
74194: LIST
74195: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
74196: LD_VAR 0 6
74200: PPUSH
74201: CALL_OW 264
74205: PUSH
74206: LD_INT 4
74208: PUSH
74209: LD_INT 43
74211: PUSH
74212: LD_INT 25
74214: PUSH
74215: EMPTY
74216: LIST
74217: LIST
74218: LIST
74219: IN
74220: IFFALSE 74241
// points := [ 40 , 15 , 5 ] ;
74222: LD_ADDR_VAR 0 9
74226: PUSH
74227: LD_INT 40
74229: PUSH
74230: LD_INT 15
74232: PUSH
74233: LD_INT 5
74235: PUSH
74236: EMPTY
74237: LIST
74238: LIST
74239: LIST
74240: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
74241: LD_VAR 0 6
74245: PPUSH
74246: CALL_OW 264
74250: PUSH
74251: LD_INT 3
74253: PUSH
74254: LD_INT 23
74256: PUSH
74257: EMPTY
74258: LIST
74259: LIST
74260: IN
74261: IFFALSE 74282
// points := [ 7 , 25 , 8 ] ;
74263: LD_ADDR_VAR 0 9
74267: PUSH
74268: LD_INT 7
74270: PUSH
74271: LD_INT 25
74273: PUSH
74274: LD_INT 8
74276: PUSH
74277: EMPTY
74278: LIST
74279: LIST
74280: LIST
74281: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
74282: LD_VAR 0 6
74286: PPUSH
74287: CALL_OW 264
74291: PUSH
74292: LD_INT 5
74294: PUSH
74295: LD_INT 27
74297: PUSH
74298: LD_INT 44
74300: PUSH
74301: EMPTY
74302: LIST
74303: LIST
74304: LIST
74305: IN
74306: IFFALSE 74327
// points := [ 14 , 50 , 16 ] ;
74308: LD_ADDR_VAR 0 9
74312: PUSH
74313: LD_INT 14
74315: PUSH
74316: LD_INT 50
74318: PUSH
74319: LD_INT 16
74321: PUSH
74322: EMPTY
74323: LIST
74324: LIST
74325: LIST
74326: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
74327: LD_VAR 0 6
74331: PPUSH
74332: CALL_OW 264
74336: PUSH
74337: LD_INT 6
74339: PUSH
74340: LD_INT 46
74342: PUSH
74343: EMPTY
74344: LIST
74345: LIST
74346: IN
74347: IFFALSE 74368
// points := [ 32 , 120 , 70 ] ;
74349: LD_ADDR_VAR 0 9
74353: PUSH
74354: LD_INT 32
74356: PUSH
74357: LD_INT 120
74359: PUSH
74360: LD_INT 70
74362: PUSH
74363: EMPTY
74364: LIST
74365: LIST
74366: LIST
74367: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
74368: LD_VAR 0 6
74372: PPUSH
74373: CALL_OW 264
74377: PUSH
74378: LD_INT 7
74380: PUSH
74381: LD_INT 28
74383: PUSH
74384: LD_INT 45
74386: PUSH
74387: LD_INT 92
74389: PUSH
74390: EMPTY
74391: LIST
74392: LIST
74393: LIST
74394: LIST
74395: IN
74396: IFFALSE 74417
// points := [ 35 , 20 , 45 ] ;
74398: LD_ADDR_VAR 0 9
74402: PUSH
74403: LD_INT 35
74405: PUSH
74406: LD_INT 20
74408: PUSH
74409: LD_INT 45
74411: PUSH
74412: EMPTY
74413: LIST
74414: LIST
74415: LIST
74416: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
74417: LD_VAR 0 6
74421: PPUSH
74422: CALL_OW 264
74426: PUSH
74427: LD_INT 47
74429: PUSH
74430: EMPTY
74431: LIST
74432: IN
74433: IFFALSE 74454
// points := [ 67 , 45 , 75 ] ;
74435: LD_ADDR_VAR 0 9
74439: PUSH
74440: LD_INT 67
74442: PUSH
74443: LD_INT 45
74445: PUSH
74446: LD_INT 75
74448: PUSH
74449: EMPTY
74450: LIST
74451: LIST
74452: LIST
74453: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
74454: LD_VAR 0 6
74458: PPUSH
74459: CALL_OW 264
74463: PUSH
74464: LD_INT 26
74466: PUSH
74467: EMPTY
74468: LIST
74469: IN
74470: IFFALSE 74491
// points := [ 120 , 30 , 80 ] ;
74472: LD_ADDR_VAR 0 9
74476: PUSH
74477: LD_INT 120
74479: PUSH
74480: LD_INT 30
74482: PUSH
74483: LD_INT 80
74485: PUSH
74486: EMPTY
74487: LIST
74488: LIST
74489: LIST
74490: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
74491: LD_VAR 0 6
74495: PPUSH
74496: CALL_OW 264
74500: PUSH
74501: LD_INT 22
74503: PUSH
74504: EMPTY
74505: LIST
74506: IN
74507: IFFALSE 74528
// points := [ 40 , 1 , 1 ] ;
74509: LD_ADDR_VAR 0 9
74513: PUSH
74514: LD_INT 40
74516: PUSH
74517: LD_INT 1
74519: PUSH
74520: LD_INT 1
74522: PUSH
74523: EMPTY
74524: LIST
74525: LIST
74526: LIST
74527: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
74528: LD_VAR 0 6
74532: PPUSH
74533: CALL_OW 264
74537: PUSH
74538: LD_INT 29
74540: PUSH
74541: EMPTY
74542: LIST
74543: IN
74544: IFFALSE 74565
// points := [ 70 , 200 , 400 ] ;
74546: LD_ADDR_VAR 0 9
74550: PUSH
74551: LD_INT 70
74553: PUSH
74554: LD_INT 200
74556: PUSH
74557: LD_INT 400
74559: PUSH
74560: EMPTY
74561: LIST
74562: LIST
74563: LIST
74564: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
74565: LD_VAR 0 6
74569: PPUSH
74570: CALL_OW 264
74574: PUSH
74575: LD_INT 14
74577: PUSH
74578: LD_INT 53
74580: PUSH
74581: EMPTY
74582: LIST
74583: LIST
74584: IN
74585: IFFALSE 74606
// points := [ 40 , 10 , 20 ] ;
74587: LD_ADDR_VAR 0 9
74591: PUSH
74592: LD_INT 40
74594: PUSH
74595: LD_INT 10
74597: PUSH
74598: LD_INT 20
74600: PUSH
74601: EMPTY
74602: LIST
74603: LIST
74604: LIST
74605: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
74606: LD_VAR 0 6
74610: PPUSH
74611: CALL_OW 264
74615: PUSH
74616: LD_INT 9
74618: PUSH
74619: EMPTY
74620: LIST
74621: IN
74622: IFFALSE 74643
// points := [ 5 , 70 , 20 ] ;
74624: LD_ADDR_VAR 0 9
74628: PUSH
74629: LD_INT 5
74631: PUSH
74632: LD_INT 70
74634: PUSH
74635: LD_INT 20
74637: PUSH
74638: EMPTY
74639: LIST
74640: LIST
74641: LIST
74642: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
74643: LD_VAR 0 6
74647: PPUSH
74648: CALL_OW 264
74652: PUSH
74653: LD_INT 10
74655: PUSH
74656: EMPTY
74657: LIST
74658: IN
74659: IFFALSE 74680
// points := [ 35 , 110 , 70 ] ;
74661: LD_ADDR_VAR 0 9
74665: PUSH
74666: LD_INT 35
74668: PUSH
74669: LD_INT 110
74671: PUSH
74672: LD_INT 70
74674: PUSH
74675: EMPTY
74676: LIST
74677: LIST
74678: LIST
74679: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
74680: LD_VAR 0 6
74684: PPUSH
74685: CALL_OW 265
74689: PUSH
74690: LD_INT 25
74692: EQUAL
74693: IFFALSE 74714
// points := [ 80 , 65 , 100 ] ;
74695: LD_ADDR_VAR 0 9
74699: PUSH
74700: LD_INT 80
74702: PUSH
74703: LD_INT 65
74705: PUSH
74706: LD_INT 100
74708: PUSH
74709: EMPTY
74710: LIST
74711: LIST
74712: LIST
74713: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
74714: LD_VAR 0 6
74718: PPUSH
74719: CALL_OW 263
74723: PUSH
74724: LD_INT 1
74726: EQUAL
74727: IFFALSE 74762
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
74729: LD_ADDR_VAR 0 10
74733: PUSH
74734: LD_VAR 0 10
74738: PUSH
74739: LD_VAR 0 6
74743: PPUSH
74744: CALL_OW 311
74748: PPUSH
74749: LD_INT 3
74751: PPUSH
74752: CALL_OW 259
74756: PUSH
74757: LD_INT 4
74759: MUL
74760: MUL
74761: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
74762: LD_VAR 0 6
74766: PPUSH
74767: CALL_OW 263
74771: PUSH
74772: LD_INT 2
74774: EQUAL
74775: IFFALSE 74826
// begin j := IsControledBy ( i ) ;
74777: LD_ADDR_VAR 0 7
74781: PUSH
74782: LD_VAR 0 6
74786: PPUSH
74787: CALL_OW 312
74791: ST_TO_ADDR
// if j then
74792: LD_VAR 0 7
74796: IFFALSE 74826
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
74798: LD_ADDR_VAR 0 10
74802: PUSH
74803: LD_VAR 0 10
74807: PUSH
74808: LD_VAR 0 7
74812: PPUSH
74813: LD_INT 3
74815: PPUSH
74816: CALL_OW 259
74820: PUSH
74821: LD_INT 3
74823: MUL
74824: MUL
74825: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
74826: LD_VAR 0 6
74830: PPUSH
74831: CALL_OW 264
74835: PUSH
74836: LD_INT 5
74838: PUSH
74839: LD_INT 6
74841: PUSH
74842: LD_INT 46
74844: PUSH
74845: LD_INT 44
74847: PUSH
74848: LD_INT 47
74850: PUSH
74851: LD_INT 45
74853: PUSH
74854: LD_INT 28
74856: PUSH
74857: LD_INT 7
74859: PUSH
74860: LD_INT 27
74862: PUSH
74863: LD_INT 29
74865: PUSH
74866: EMPTY
74867: LIST
74868: LIST
74869: LIST
74870: LIST
74871: LIST
74872: LIST
74873: LIST
74874: LIST
74875: LIST
74876: LIST
74877: IN
74878: PUSH
74879: LD_VAR 0 1
74883: PPUSH
74884: LD_INT 52
74886: PPUSH
74887: CALL_OW 321
74891: PUSH
74892: LD_INT 2
74894: EQUAL
74895: AND
74896: IFFALSE 74913
// bpoints := bpoints * 1.2 ;
74898: LD_ADDR_VAR 0 10
74902: PUSH
74903: LD_VAR 0 10
74907: PUSH
74908: LD_REAL  1.20000000000000E+0000
74911: MUL
74912: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
74913: LD_VAR 0 6
74917: PPUSH
74918: CALL_OW 264
74922: PUSH
74923: LD_INT 6
74925: PUSH
74926: LD_INT 46
74928: PUSH
74929: LD_INT 47
74931: PUSH
74932: EMPTY
74933: LIST
74934: LIST
74935: LIST
74936: IN
74937: IFFALSE 74954
// bpoints := bpoints * 1.2 ;
74939: LD_ADDR_VAR 0 10
74943: PUSH
74944: LD_VAR 0 10
74948: PUSH
74949: LD_REAL  1.20000000000000E+0000
74952: MUL
74953: ST_TO_ADDR
// end ; unit_building :
74954: GO 74968
74956: LD_INT 3
74958: DOUBLE
74959: EQUAL
74960: IFTRUE 74964
74962: GO 74967
74964: POP
// ; end ;
74965: GO 74968
74967: POP
// for j = 1 to 3 do
74968: LD_ADDR_VAR 0 7
74972: PUSH
74973: DOUBLE
74974: LD_INT 1
74976: DEC
74977: ST_TO_ADDR
74978: LD_INT 3
74980: PUSH
74981: FOR_TO
74982: IFFALSE 75035
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
74984: LD_ADDR_VAR 0 5
74988: PUSH
74989: LD_VAR 0 5
74993: PPUSH
74994: LD_VAR 0 7
74998: PPUSH
74999: LD_VAR 0 5
75003: PUSH
75004: LD_VAR 0 7
75008: ARRAY
75009: PUSH
75010: LD_VAR 0 9
75014: PUSH
75015: LD_VAR 0 7
75019: ARRAY
75020: PUSH
75021: LD_VAR 0 10
75025: MUL
75026: PLUS
75027: PPUSH
75028: CALL_OW 1
75032: ST_TO_ADDR
75033: GO 74981
75035: POP
75036: POP
// end ;
75037: GO 73516
75039: POP
75040: POP
// result := Replace ( result , 4 , tmp ) ;
75041: LD_ADDR_VAR 0 5
75045: PUSH
75046: LD_VAR 0 5
75050: PPUSH
75051: LD_INT 4
75053: PPUSH
75054: LD_VAR 0 8
75058: PPUSH
75059: CALL_OW 1
75063: ST_TO_ADDR
// end ;
75064: LD_VAR 0 5
75068: RET
// export function DangerAtRange ( unit , range ) ; begin
75069: LD_INT 0
75071: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
75072: LD_ADDR_VAR 0 3
75076: PUSH
75077: LD_VAR 0 1
75081: PPUSH
75082: CALL_OW 255
75086: PPUSH
75087: LD_VAR 0 1
75091: PPUSH
75092: CALL_OW 250
75096: PPUSH
75097: LD_VAR 0 1
75101: PPUSH
75102: CALL_OW 251
75106: PPUSH
75107: LD_VAR 0 2
75111: PPUSH
75112: CALL 73368 0 4
75116: ST_TO_ADDR
// end ;
75117: LD_VAR 0 3
75121: RET
// export function DangerInArea ( side , area ) ; begin
75122: LD_INT 0
75124: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
75125: LD_ADDR_VAR 0 3
75129: PUSH
75130: LD_VAR 0 2
75134: PPUSH
75135: LD_INT 81
75137: PUSH
75138: LD_VAR 0 1
75142: PUSH
75143: EMPTY
75144: LIST
75145: LIST
75146: PPUSH
75147: CALL_OW 70
75151: ST_TO_ADDR
// end ;
75152: LD_VAR 0 3
75156: RET
// export function IsExtension ( b ) ; begin
75157: LD_INT 0
75159: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
75160: LD_ADDR_VAR 0 2
75164: PUSH
75165: LD_VAR 0 1
75169: PUSH
75170: LD_INT 23
75172: PUSH
75173: LD_INT 20
75175: PUSH
75176: LD_INT 22
75178: PUSH
75179: LD_INT 17
75181: PUSH
75182: LD_INT 24
75184: PUSH
75185: LD_INT 21
75187: PUSH
75188: LD_INT 19
75190: PUSH
75191: LD_INT 16
75193: PUSH
75194: LD_INT 25
75196: PUSH
75197: LD_INT 18
75199: PUSH
75200: EMPTY
75201: LIST
75202: LIST
75203: LIST
75204: LIST
75205: LIST
75206: LIST
75207: LIST
75208: LIST
75209: LIST
75210: LIST
75211: IN
75212: ST_TO_ADDR
// end ;
75213: LD_VAR 0 2
75217: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
75218: LD_INT 0
75220: PPUSH
75221: PPUSH
75222: PPUSH
// result := [ ] ;
75223: LD_ADDR_VAR 0 4
75227: PUSH
75228: EMPTY
75229: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
75230: LD_ADDR_VAR 0 5
75234: PUSH
75235: LD_VAR 0 2
75239: PPUSH
75240: LD_INT 21
75242: PUSH
75243: LD_INT 3
75245: PUSH
75246: EMPTY
75247: LIST
75248: LIST
75249: PPUSH
75250: CALL_OW 70
75254: ST_TO_ADDR
// if not tmp then
75255: LD_VAR 0 5
75259: NOT
75260: IFFALSE 75264
// exit ;
75262: GO 75328
// if checkLink then
75264: LD_VAR 0 3
75268: IFFALSE 75318
// begin for i in tmp do
75270: LD_ADDR_VAR 0 6
75274: PUSH
75275: LD_VAR 0 5
75279: PUSH
75280: FOR_IN
75281: IFFALSE 75316
// if GetBase ( i ) <> base then
75283: LD_VAR 0 6
75287: PPUSH
75288: CALL_OW 274
75292: PUSH
75293: LD_VAR 0 1
75297: NONEQUAL
75298: IFFALSE 75314
// ComLinkToBase ( base , i ) ;
75300: LD_VAR 0 1
75304: PPUSH
75305: LD_VAR 0 6
75309: PPUSH
75310: CALL_OW 169
75314: GO 75280
75316: POP
75317: POP
// end ; result := tmp ;
75318: LD_ADDR_VAR 0 4
75322: PUSH
75323: LD_VAR 0 5
75327: ST_TO_ADDR
// end ;
75328: LD_VAR 0 4
75332: RET
// export function ComComplete ( units , b ) ; var i ; begin
75333: LD_INT 0
75335: PPUSH
75336: PPUSH
// if not units then
75337: LD_VAR 0 1
75341: NOT
75342: IFFALSE 75346
// exit ;
75344: GO 75436
// for i in units do
75346: LD_ADDR_VAR 0 4
75350: PUSH
75351: LD_VAR 0 1
75355: PUSH
75356: FOR_IN
75357: IFFALSE 75434
// if BuildingStatus ( b ) = bs_build then
75359: LD_VAR 0 2
75363: PPUSH
75364: CALL_OW 461
75368: PUSH
75369: LD_INT 1
75371: EQUAL
75372: IFFALSE 75432
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
75374: LD_VAR 0 4
75378: PPUSH
75379: LD_STRING h
75381: PUSH
75382: LD_VAR 0 2
75386: PPUSH
75387: CALL_OW 250
75391: PUSH
75392: LD_VAR 0 2
75396: PPUSH
75397: CALL_OW 251
75401: PUSH
75402: LD_VAR 0 2
75406: PUSH
75407: LD_INT 0
75409: PUSH
75410: LD_INT 0
75412: PUSH
75413: LD_INT 0
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: LIST
75420: LIST
75421: LIST
75422: LIST
75423: LIST
75424: PUSH
75425: EMPTY
75426: LIST
75427: PPUSH
75428: CALL_OW 446
75432: GO 75356
75434: POP
75435: POP
// end ;
75436: LD_VAR 0 3
75440: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
75441: LD_INT 0
75443: PPUSH
75444: PPUSH
75445: PPUSH
75446: PPUSH
75447: PPUSH
75448: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
75449: LD_VAR 0 1
75453: NOT
75454: PUSH
75455: LD_VAR 0 1
75459: PPUSH
75460: CALL_OW 263
75464: PUSH
75465: LD_INT 2
75467: NONEQUAL
75468: OR
75469: IFFALSE 75473
// exit ;
75471: GO 75789
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
75473: LD_ADDR_VAR 0 6
75477: PUSH
75478: LD_INT 22
75480: PUSH
75481: LD_VAR 0 1
75485: PPUSH
75486: CALL_OW 255
75490: PUSH
75491: EMPTY
75492: LIST
75493: LIST
75494: PUSH
75495: LD_INT 2
75497: PUSH
75498: LD_INT 30
75500: PUSH
75501: LD_INT 36
75503: PUSH
75504: EMPTY
75505: LIST
75506: LIST
75507: PUSH
75508: LD_INT 34
75510: PUSH
75511: LD_INT 31
75513: PUSH
75514: EMPTY
75515: LIST
75516: LIST
75517: PUSH
75518: EMPTY
75519: LIST
75520: LIST
75521: LIST
75522: PUSH
75523: EMPTY
75524: LIST
75525: LIST
75526: PPUSH
75527: CALL_OW 69
75531: ST_TO_ADDR
// if not tmp then
75532: LD_VAR 0 6
75536: NOT
75537: IFFALSE 75541
// exit ;
75539: GO 75789
// result := [ ] ;
75541: LD_ADDR_VAR 0 2
75545: PUSH
75546: EMPTY
75547: ST_TO_ADDR
// for i in tmp do
75548: LD_ADDR_VAR 0 3
75552: PUSH
75553: LD_VAR 0 6
75557: PUSH
75558: FOR_IN
75559: IFFALSE 75630
// begin t := UnitsInside ( i ) ;
75561: LD_ADDR_VAR 0 4
75565: PUSH
75566: LD_VAR 0 3
75570: PPUSH
75571: CALL_OW 313
75575: ST_TO_ADDR
// if t then
75576: LD_VAR 0 4
75580: IFFALSE 75628
// for j in t do
75582: LD_ADDR_VAR 0 7
75586: PUSH
75587: LD_VAR 0 4
75591: PUSH
75592: FOR_IN
75593: IFFALSE 75626
// result := Replace ( result , result + 1 , j ) ;
75595: LD_ADDR_VAR 0 2
75599: PUSH
75600: LD_VAR 0 2
75604: PPUSH
75605: LD_VAR 0 2
75609: PUSH
75610: LD_INT 1
75612: PLUS
75613: PPUSH
75614: LD_VAR 0 7
75618: PPUSH
75619: CALL_OW 1
75623: ST_TO_ADDR
75624: GO 75592
75626: POP
75627: POP
// end ;
75628: GO 75558
75630: POP
75631: POP
// if not result then
75632: LD_VAR 0 2
75636: NOT
75637: IFFALSE 75641
// exit ;
75639: GO 75789
// mech := result [ 1 ] ;
75641: LD_ADDR_VAR 0 5
75645: PUSH
75646: LD_VAR 0 2
75650: PUSH
75651: LD_INT 1
75653: ARRAY
75654: ST_TO_ADDR
// if result > 1 then
75655: LD_VAR 0 2
75659: PUSH
75660: LD_INT 1
75662: GREATER
75663: IFFALSE 75775
// begin for i = 2 to result do
75665: LD_ADDR_VAR 0 3
75669: PUSH
75670: DOUBLE
75671: LD_INT 2
75673: DEC
75674: ST_TO_ADDR
75675: LD_VAR 0 2
75679: PUSH
75680: FOR_TO
75681: IFFALSE 75773
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
75683: LD_ADDR_VAR 0 4
75687: PUSH
75688: LD_VAR 0 2
75692: PUSH
75693: LD_VAR 0 3
75697: ARRAY
75698: PPUSH
75699: LD_INT 3
75701: PPUSH
75702: CALL_OW 259
75706: PUSH
75707: LD_VAR 0 2
75711: PUSH
75712: LD_VAR 0 3
75716: ARRAY
75717: PPUSH
75718: CALL_OW 432
75722: MINUS
75723: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
75724: LD_VAR 0 4
75728: PUSH
75729: LD_VAR 0 5
75733: PPUSH
75734: LD_INT 3
75736: PPUSH
75737: CALL_OW 259
75741: PUSH
75742: LD_VAR 0 5
75746: PPUSH
75747: CALL_OW 432
75751: MINUS
75752: GREATEREQUAL
75753: IFFALSE 75771
// mech := result [ i ] ;
75755: LD_ADDR_VAR 0 5
75759: PUSH
75760: LD_VAR 0 2
75764: PUSH
75765: LD_VAR 0 3
75769: ARRAY
75770: ST_TO_ADDR
// end ;
75771: GO 75680
75773: POP
75774: POP
// end ; ComLinkTo ( vehicle , mech ) ;
75775: LD_VAR 0 1
75779: PPUSH
75780: LD_VAR 0 5
75784: PPUSH
75785: CALL_OW 135
// end ;
75789: LD_VAR 0 2
75793: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
75794: LD_INT 0
75796: PPUSH
75797: PPUSH
75798: PPUSH
75799: PPUSH
75800: PPUSH
75801: PPUSH
75802: PPUSH
75803: PPUSH
75804: PPUSH
75805: PPUSH
75806: PPUSH
75807: PPUSH
75808: PPUSH
// result := [ ] ;
75809: LD_ADDR_VAR 0 7
75813: PUSH
75814: EMPTY
75815: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
75816: LD_VAR 0 1
75820: PPUSH
75821: CALL_OW 266
75825: PUSH
75826: LD_INT 0
75828: PUSH
75829: LD_INT 1
75831: PUSH
75832: EMPTY
75833: LIST
75834: LIST
75835: IN
75836: NOT
75837: IFFALSE 75841
// exit ;
75839: GO 77475
// if name then
75841: LD_VAR 0 3
75845: IFFALSE 75861
// SetBName ( base_dep , name ) ;
75847: LD_VAR 0 1
75851: PPUSH
75852: LD_VAR 0 3
75856: PPUSH
75857: CALL_OW 500
// base := GetBase ( base_dep ) ;
75861: LD_ADDR_VAR 0 15
75865: PUSH
75866: LD_VAR 0 1
75870: PPUSH
75871: CALL_OW 274
75875: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
75876: LD_ADDR_VAR 0 16
75880: PUSH
75881: LD_VAR 0 1
75885: PPUSH
75886: CALL_OW 255
75890: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
75891: LD_ADDR_VAR 0 17
75895: PUSH
75896: LD_VAR 0 1
75900: PPUSH
75901: CALL_OW 248
75905: ST_TO_ADDR
// if sources then
75906: LD_VAR 0 5
75910: IFFALSE 75957
// for i = 1 to 3 do
75912: LD_ADDR_VAR 0 8
75916: PUSH
75917: DOUBLE
75918: LD_INT 1
75920: DEC
75921: ST_TO_ADDR
75922: LD_INT 3
75924: PUSH
75925: FOR_TO
75926: IFFALSE 75955
// AddResourceType ( base , i , sources [ i ] ) ;
75928: LD_VAR 0 15
75932: PPUSH
75933: LD_VAR 0 8
75937: PPUSH
75938: LD_VAR 0 5
75942: PUSH
75943: LD_VAR 0 8
75947: ARRAY
75948: PPUSH
75949: CALL_OW 276
75953: GO 75925
75955: POP
75956: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
75957: LD_ADDR_VAR 0 18
75961: PUSH
75962: LD_VAR 0 15
75966: PPUSH
75967: LD_VAR 0 2
75971: PPUSH
75972: LD_INT 1
75974: PPUSH
75975: CALL 75218 0 3
75979: ST_TO_ADDR
// InitHc ;
75980: CALL_OW 19
// InitUc ;
75984: CALL_OW 18
// uc_side := side ;
75988: LD_ADDR_OWVAR 20
75992: PUSH
75993: LD_VAR 0 16
75997: ST_TO_ADDR
// uc_nation := nation ;
75998: LD_ADDR_OWVAR 21
76002: PUSH
76003: LD_VAR 0 17
76007: ST_TO_ADDR
// if buildings then
76008: LD_VAR 0 18
76012: IFFALSE 77334
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
76014: LD_ADDR_VAR 0 19
76018: PUSH
76019: LD_VAR 0 18
76023: PPUSH
76024: LD_INT 2
76026: PUSH
76027: LD_INT 30
76029: PUSH
76030: LD_INT 29
76032: PUSH
76033: EMPTY
76034: LIST
76035: LIST
76036: PUSH
76037: LD_INT 30
76039: PUSH
76040: LD_INT 30
76042: PUSH
76043: EMPTY
76044: LIST
76045: LIST
76046: PUSH
76047: EMPTY
76048: LIST
76049: LIST
76050: LIST
76051: PPUSH
76052: CALL_OW 72
76056: ST_TO_ADDR
// if tmp then
76057: LD_VAR 0 19
76061: IFFALSE 76109
// for i in tmp do
76063: LD_ADDR_VAR 0 8
76067: PUSH
76068: LD_VAR 0 19
76072: PUSH
76073: FOR_IN
76074: IFFALSE 76107
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
76076: LD_VAR 0 8
76080: PPUSH
76081: CALL_OW 250
76085: PPUSH
76086: LD_VAR 0 8
76090: PPUSH
76091: CALL_OW 251
76095: PPUSH
76096: LD_VAR 0 16
76100: PPUSH
76101: CALL_OW 441
76105: GO 76073
76107: POP
76108: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
76109: LD_VAR 0 18
76113: PPUSH
76114: LD_INT 2
76116: PUSH
76117: LD_INT 30
76119: PUSH
76120: LD_INT 32
76122: PUSH
76123: EMPTY
76124: LIST
76125: LIST
76126: PUSH
76127: LD_INT 30
76129: PUSH
76130: LD_INT 33
76132: PUSH
76133: EMPTY
76134: LIST
76135: LIST
76136: PUSH
76137: EMPTY
76138: LIST
76139: LIST
76140: LIST
76141: PPUSH
76142: CALL_OW 72
76146: IFFALSE 76234
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
76148: LD_ADDR_VAR 0 8
76152: PUSH
76153: LD_VAR 0 18
76157: PPUSH
76158: LD_INT 2
76160: PUSH
76161: LD_INT 30
76163: PUSH
76164: LD_INT 32
76166: PUSH
76167: EMPTY
76168: LIST
76169: LIST
76170: PUSH
76171: LD_INT 30
76173: PUSH
76174: LD_INT 33
76176: PUSH
76177: EMPTY
76178: LIST
76179: LIST
76180: PUSH
76181: EMPTY
76182: LIST
76183: LIST
76184: LIST
76185: PPUSH
76186: CALL_OW 72
76190: PUSH
76191: FOR_IN
76192: IFFALSE 76232
// begin if not GetBWeapon ( i ) then
76194: LD_VAR 0 8
76198: PPUSH
76199: CALL_OW 269
76203: NOT
76204: IFFALSE 76230
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
76206: LD_VAR 0 8
76210: PPUSH
76211: LD_VAR 0 8
76215: PPUSH
76216: LD_VAR 0 2
76220: PPUSH
76221: CALL 77480 0 2
76225: PPUSH
76226: CALL_OW 431
// end ;
76230: GO 76191
76232: POP
76233: POP
// end ; for i = 1 to personel do
76234: LD_ADDR_VAR 0 8
76238: PUSH
76239: DOUBLE
76240: LD_INT 1
76242: DEC
76243: ST_TO_ADDR
76244: LD_VAR 0 6
76248: PUSH
76249: FOR_TO
76250: IFFALSE 77314
// begin if i > 4 then
76252: LD_VAR 0 8
76256: PUSH
76257: LD_INT 4
76259: GREATER
76260: IFFALSE 76264
// break ;
76262: GO 77314
// case i of 1 :
76264: LD_VAR 0 8
76268: PUSH
76269: LD_INT 1
76271: DOUBLE
76272: EQUAL
76273: IFTRUE 76277
76275: GO 76357
76277: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
76278: LD_ADDR_VAR 0 12
76282: PUSH
76283: LD_VAR 0 18
76287: PPUSH
76288: LD_INT 22
76290: PUSH
76291: LD_VAR 0 16
76295: PUSH
76296: EMPTY
76297: LIST
76298: LIST
76299: PUSH
76300: LD_INT 58
76302: PUSH
76303: EMPTY
76304: LIST
76305: PUSH
76306: LD_INT 2
76308: PUSH
76309: LD_INT 30
76311: PUSH
76312: LD_INT 32
76314: PUSH
76315: EMPTY
76316: LIST
76317: LIST
76318: PUSH
76319: LD_INT 30
76321: PUSH
76322: LD_INT 4
76324: PUSH
76325: EMPTY
76326: LIST
76327: LIST
76328: PUSH
76329: LD_INT 30
76331: PUSH
76332: LD_INT 5
76334: PUSH
76335: EMPTY
76336: LIST
76337: LIST
76338: PUSH
76339: EMPTY
76340: LIST
76341: LIST
76342: LIST
76343: LIST
76344: PUSH
76345: EMPTY
76346: LIST
76347: LIST
76348: LIST
76349: PPUSH
76350: CALL_OW 72
76354: ST_TO_ADDR
76355: GO 76579
76357: LD_INT 2
76359: DOUBLE
76360: EQUAL
76361: IFTRUE 76365
76363: GO 76427
76365: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
76366: LD_ADDR_VAR 0 12
76370: PUSH
76371: LD_VAR 0 18
76375: PPUSH
76376: LD_INT 22
76378: PUSH
76379: LD_VAR 0 16
76383: PUSH
76384: EMPTY
76385: LIST
76386: LIST
76387: PUSH
76388: LD_INT 2
76390: PUSH
76391: LD_INT 30
76393: PUSH
76394: LD_INT 0
76396: PUSH
76397: EMPTY
76398: LIST
76399: LIST
76400: PUSH
76401: LD_INT 30
76403: PUSH
76404: LD_INT 1
76406: PUSH
76407: EMPTY
76408: LIST
76409: LIST
76410: PUSH
76411: EMPTY
76412: LIST
76413: LIST
76414: LIST
76415: PUSH
76416: EMPTY
76417: LIST
76418: LIST
76419: PPUSH
76420: CALL_OW 72
76424: ST_TO_ADDR
76425: GO 76579
76427: LD_INT 3
76429: DOUBLE
76430: EQUAL
76431: IFTRUE 76435
76433: GO 76497
76435: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
76436: LD_ADDR_VAR 0 12
76440: PUSH
76441: LD_VAR 0 18
76445: PPUSH
76446: LD_INT 22
76448: PUSH
76449: LD_VAR 0 16
76453: PUSH
76454: EMPTY
76455: LIST
76456: LIST
76457: PUSH
76458: LD_INT 2
76460: PUSH
76461: LD_INT 30
76463: PUSH
76464: LD_INT 2
76466: PUSH
76467: EMPTY
76468: LIST
76469: LIST
76470: PUSH
76471: LD_INT 30
76473: PUSH
76474: LD_INT 3
76476: PUSH
76477: EMPTY
76478: LIST
76479: LIST
76480: PUSH
76481: EMPTY
76482: LIST
76483: LIST
76484: LIST
76485: PUSH
76486: EMPTY
76487: LIST
76488: LIST
76489: PPUSH
76490: CALL_OW 72
76494: ST_TO_ADDR
76495: GO 76579
76497: LD_INT 4
76499: DOUBLE
76500: EQUAL
76501: IFTRUE 76505
76503: GO 76578
76505: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
76506: LD_ADDR_VAR 0 12
76510: PUSH
76511: LD_VAR 0 18
76515: PPUSH
76516: LD_INT 22
76518: PUSH
76519: LD_VAR 0 16
76523: PUSH
76524: EMPTY
76525: LIST
76526: LIST
76527: PUSH
76528: LD_INT 2
76530: PUSH
76531: LD_INT 30
76533: PUSH
76534: LD_INT 6
76536: PUSH
76537: EMPTY
76538: LIST
76539: LIST
76540: PUSH
76541: LD_INT 30
76543: PUSH
76544: LD_INT 7
76546: PUSH
76547: EMPTY
76548: LIST
76549: LIST
76550: PUSH
76551: LD_INT 30
76553: PUSH
76554: LD_INT 8
76556: PUSH
76557: EMPTY
76558: LIST
76559: LIST
76560: PUSH
76561: EMPTY
76562: LIST
76563: LIST
76564: LIST
76565: LIST
76566: PUSH
76567: EMPTY
76568: LIST
76569: LIST
76570: PPUSH
76571: CALL_OW 72
76575: ST_TO_ADDR
76576: GO 76579
76578: POP
// if i = 1 then
76579: LD_VAR 0 8
76583: PUSH
76584: LD_INT 1
76586: EQUAL
76587: IFFALSE 76698
// begin tmp := [ ] ;
76589: LD_ADDR_VAR 0 19
76593: PUSH
76594: EMPTY
76595: ST_TO_ADDR
// for j in f do
76596: LD_ADDR_VAR 0 9
76600: PUSH
76601: LD_VAR 0 12
76605: PUSH
76606: FOR_IN
76607: IFFALSE 76680
// if GetBType ( j ) = b_bunker then
76609: LD_VAR 0 9
76613: PPUSH
76614: CALL_OW 266
76618: PUSH
76619: LD_INT 32
76621: EQUAL
76622: IFFALSE 76649
// tmp := Insert ( tmp , 1 , j ) else
76624: LD_ADDR_VAR 0 19
76628: PUSH
76629: LD_VAR 0 19
76633: PPUSH
76634: LD_INT 1
76636: PPUSH
76637: LD_VAR 0 9
76641: PPUSH
76642: CALL_OW 2
76646: ST_TO_ADDR
76647: GO 76678
// tmp := Insert ( tmp , tmp + 1 , j ) ;
76649: LD_ADDR_VAR 0 19
76653: PUSH
76654: LD_VAR 0 19
76658: PPUSH
76659: LD_VAR 0 19
76663: PUSH
76664: LD_INT 1
76666: PLUS
76667: PPUSH
76668: LD_VAR 0 9
76672: PPUSH
76673: CALL_OW 2
76677: ST_TO_ADDR
76678: GO 76606
76680: POP
76681: POP
// if tmp then
76682: LD_VAR 0 19
76686: IFFALSE 76698
// f := tmp ;
76688: LD_ADDR_VAR 0 12
76692: PUSH
76693: LD_VAR 0 19
76697: ST_TO_ADDR
// end ; x := personel [ i ] ;
76698: LD_ADDR_VAR 0 13
76702: PUSH
76703: LD_VAR 0 6
76707: PUSH
76708: LD_VAR 0 8
76712: ARRAY
76713: ST_TO_ADDR
// if x = - 1 then
76714: LD_VAR 0 13
76718: PUSH
76719: LD_INT 1
76721: NEG
76722: EQUAL
76723: IFFALSE 76932
// begin for j in f do
76725: LD_ADDR_VAR 0 9
76729: PUSH
76730: LD_VAR 0 12
76734: PUSH
76735: FOR_IN
76736: IFFALSE 76928
// repeat InitHc ;
76738: CALL_OW 19
// if GetBType ( j ) = b_barracks then
76742: LD_VAR 0 9
76746: PPUSH
76747: CALL_OW 266
76751: PUSH
76752: LD_INT 5
76754: EQUAL
76755: IFFALSE 76825
// begin if UnitsInside ( j ) < 3 then
76757: LD_VAR 0 9
76761: PPUSH
76762: CALL_OW 313
76766: PUSH
76767: LD_INT 3
76769: LESS
76770: IFFALSE 76806
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76772: LD_INT 0
76774: PPUSH
76775: LD_INT 5
76777: PUSH
76778: LD_INT 8
76780: PUSH
76781: LD_INT 9
76783: PUSH
76784: EMPTY
76785: LIST
76786: LIST
76787: LIST
76788: PUSH
76789: LD_VAR 0 17
76793: ARRAY
76794: PPUSH
76795: LD_VAR 0 4
76799: PPUSH
76800: CALL_OW 380
76804: GO 76823
// PrepareHuman ( false , i , skill ) ;
76806: LD_INT 0
76808: PPUSH
76809: LD_VAR 0 8
76813: PPUSH
76814: LD_VAR 0 4
76818: PPUSH
76819: CALL_OW 380
// end else
76823: GO 76842
// PrepareHuman ( false , i , skill ) ;
76825: LD_INT 0
76827: PPUSH
76828: LD_VAR 0 8
76832: PPUSH
76833: LD_VAR 0 4
76837: PPUSH
76838: CALL_OW 380
// un := CreateHuman ;
76842: LD_ADDR_VAR 0 14
76846: PUSH
76847: CALL_OW 44
76851: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76852: LD_ADDR_VAR 0 7
76856: PUSH
76857: LD_VAR 0 7
76861: PPUSH
76862: LD_INT 1
76864: PPUSH
76865: LD_VAR 0 14
76869: PPUSH
76870: CALL_OW 2
76874: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
76875: LD_VAR 0 14
76879: PPUSH
76880: LD_VAR 0 9
76884: PPUSH
76885: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
76889: LD_VAR 0 9
76893: PPUSH
76894: CALL_OW 313
76898: PUSH
76899: LD_INT 6
76901: EQUAL
76902: PUSH
76903: LD_VAR 0 9
76907: PPUSH
76908: CALL_OW 266
76912: PUSH
76913: LD_INT 32
76915: PUSH
76916: LD_INT 31
76918: PUSH
76919: EMPTY
76920: LIST
76921: LIST
76922: IN
76923: OR
76924: IFFALSE 76738
76926: GO 76735
76928: POP
76929: POP
// end else
76930: GO 77312
// for j = 1 to x do
76932: LD_ADDR_VAR 0 9
76936: PUSH
76937: DOUBLE
76938: LD_INT 1
76940: DEC
76941: ST_TO_ADDR
76942: LD_VAR 0 13
76946: PUSH
76947: FOR_TO
76948: IFFALSE 77310
// begin InitHc ;
76950: CALL_OW 19
// if not f then
76954: LD_VAR 0 12
76958: NOT
76959: IFFALSE 77048
// begin PrepareHuman ( false , i , skill ) ;
76961: LD_INT 0
76963: PPUSH
76964: LD_VAR 0 8
76968: PPUSH
76969: LD_VAR 0 4
76973: PPUSH
76974: CALL_OW 380
// un := CreateHuman ;
76978: LD_ADDR_VAR 0 14
76982: PUSH
76983: CALL_OW 44
76987: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76988: LD_ADDR_VAR 0 7
76992: PUSH
76993: LD_VAR 0 7
76997: PPUSH
76998: LD_INT 1
77000: PPUSH
77001: LD_VAR 0 14
77005: PPUSH
77006: CALL_OW 2
77010: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
77011: LD_VAR 0 14
77015: PPUSH
77016: LD_VAR 0 1
77020: PPUSH
77021: CALL_OW 250
77025: PPUSH
77026: LD_VAR 0 1
77030: PPUSH
77031: CALL_OW 251
77035: PPUSH
77036: LD_INT 10
77038: PPUSH
77039: LD_INT 0
77041: PPUSH
77042: CALL_OW 50
// continue ;
77046: GO 76947
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
77048: LD_VAR 0 12
77052: PUSH
77053: LD_INT 1
77055: ARRAY
77056: PPUSH
77057: CALL_OW 313
77061: PUSH
77062: LD_VAR 0 12
77066: PUSH
77067: LD_INT 1
77069: ARRAY
77070: PPUSH
77071: CALL_OW 266
77075: PUSH
77076: LD_INT 32
77078: PUSH
77079: LD_INT 31
77081: PUSH
77082: EMPTY
77083: LIST
77084: LIST
77085: IN
77086: AND
77087: PUSH
77088: LD_VAR 0 12
77092: PUSH
77093: LD_INT 1
77095: ARRAY
77096: PPUSH
77097: CALL_OW 313
77101: PUSH
77102: LD_INT 6
77104: EQUAL
77105: OR
77106: IFFALSE 77126
// f := Delete ( f , 1 ) ;
77108: LD_ADDR_VAR 0 12
77112: PUSH
77113: LD_VAR 0 12
77117: PPUSH
77118: LD_INT 1
77120: PPUSH
77121: CALL_OW 3
77125: ST_TO_ADDR
// if not f then
77126: LD_VAR 0 12
77130: NOT
77131: IFFALSE 77149
// begin x := x + 2 ;
77133: LD_ADDR_VAR 0 13
77137: PUSH
77138: LD_VAR 0 13
77142: PUSH
77143: LD_INT 2
77145: PLUS
77146: ST_TO_ADDR
// continue ;
77147: GO 76947
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
77149: LD_VAR 0 12
77153: PUSH
77154: LD_INT 1
77156: ARRAY
77157: PPUSH
77158: CALL_OW 266
77162: PUSH
77163: LD_INT 5
77165: EQUAL
77166: IFFALSE 77240
// begin if UnitsInside ( f [ 1 ] ) < 3 then
77168: LD_VAR 0 12
77172: PUSH
77173: LD_INT 1
77175: ARRAY
77176: PPUSH
77177: CALL_OW 313
77181: PUSH
77182: LD_INT 3
77184: LESS
77185: IFFALSE 77221
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
77187: LD_INT 0
77189: PPUSH
77190: LD_INT 5
77192: PUSH
77193: LD_INT 8
77195: PUSH
77196: LD_INT 9
77198: PUSH
77199: EMPTY
77200: LIST
77201: LIST
77202: LIST
77203: PUSH
77204: LD_VAR 0 17
77208: ARRAY
77209: PPUSH
77210: LD_VAR 0 4
77214: PPUSH
77215: CALL_OW 380
77219: GO 77238
// PrepareHuman ( false , i , skill ) ;
77221: LD_INT 0
77223: PPUSH
77224: LD_VAR 0 8
77228: PPUSH
77229: LD_VAR 0 4
77233: PPUSH
77234: CALL_OW 380
// end else
77238: GO 77257
// PrepareHuman ( false , i , skill ) ;
77240: LD_INT 0
77242: PPUSH
77243: LD_VAR 0 8
77247: PPUSH
77248: LD_VAR 0 4
77252: PPUSH
77253: CALL_OW 380
// un := CreateHuman ;
77257: LD_ADDR_VAR 0 14
77261: PUSH
77262: CALL_OW 44
77266: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
77267: LD_ADDR_VAR 0 7
77271: PUSH
77272: LD_VAR 0 7
77276: PPUSH
77277: LD_INT 1
77279: PPUSH
77280: LD_VAR 0 14
77284: PPUSH
77285: CALL_OW 2
77289: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
77290: LD_VAR 0 14
77294: PPUSH
77295: LD_VAR 0 12
77299: PUSH
77300: LD_INT 1
77302: ARRAY
77303: PPUSH
77304: CALL_OW 52
// end ;
77308: GO 76947
77310: POP
77311: POP
// end ;
77312: GO 76249
77314: POP
77315: POP
// result := result ^ buildings ;
77316: LD_ADDR_VAR 0 7
77320: PUSH
77321: LD_VAR 0 7
77325: PUSH
77326: LD_VAR 0 18
77330: ADD
77331: ST_TO_ADDR
// end else
77332: GO 77475
// begin for i = 1 to personel do
77334: LD_ADDR_VAR 0 8
77338: PUSH
77339: DOUBLE
77340: LD_INT 1
77342: DEC
77343: ST_TO_ADDR
77344: LD_VAR 0 6
77348: PUSH
77349: FOR_TO
77350: IFFALSE 77473
// begin if i > 4 then
77352: LD_VAR 0 8
77356: PUSH
77357: LD_INT 4
77359: GREATER
77360: IFFALSE 77364
// break ;
77362: GO 77473
// x := personel [ i ] ;
77364: LD_ADDR_VAR 0 13
77368: PUSH
77369: LD_VAR 0 6
77373: PUSH
77374: LD_VAR 0 8
77378: ARRAY
77379: ST_TO_ADDR
// if x = - 1 then
77380: LD_VAR 0 13
77384: PUSH
77385: LD_INT 1
77387: NEG
77388: EQUAL
77389: IFFALSE 77393
// continue ;
77391: GO 77349
// PrepareHuman ( false , i , skill ) ;
77393: LD_INT 0
77395: PPUSH
77396: LD_VAR 0 8
77400: PPUSH
77401: LD_VAR 0 4
77405: PPUSH
77406: CALL_OW 380
// un := CreateHuman ;
77410: LD_ADDR_VAR 0 14
77414: PUSH
77415: CALL_OW 44
77419: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
77420: LD_VAR 0 14
77424: PPUSH
77425: LD_VAR 0 1
77429: PPUSH
77430: CALL_OW 250
77434: PPUSH
77435: LD_VAR 0 1
77439: PPUSH
77440: CALL_OW 251
77444: PPUSH
77445: LD_INT 10
77447: PPUSH
77448: LD_INT 0
77450: PPUSH
77451: CALL_OW 50
// result := result ^ un ;
77455: LD_ADDR_VAR 0 7
77459: PUSH
77460: LD_VAR 0 7
77464: PUSH
77465: LD_VAR 0 14
77469: ADD
77470: ST_TO_ADDR
// end ;
77471: GO 77349
77473: POP
77474: POP
// end ; end ;
77475: LD_VAR 0 7
77479: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
77480: LD_INT 0
77482: PPUSH
77483: PPUSH
77484: PPUSH
77485: PPUSH
77486: PPUSH
77487: PPUSH
77488: PPUSH
77489: PPUSH
77490: PPUSH
77491: PPUSH
77492: PPUSH
77493: PPUSH
77494: PPUSH
77495: PPUSH
77496: PPUSH
77497: PPUSH
// result := false ;
77498: LD_ADDR_VAR 0 3
77502: PUSH
77503: LD_INT 0
77505: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
77506: LD_VAR 0 1
77510: NOT
77511: PUSH
77512: LD_VAR 0 1
77516: PPUSH
77517: CALL_OW 266
77521: PUSH
77522: LD_INT 32
77524: PUSH
77525: LD_INT 33
77527: PUSH
77528: EMPTY
77529: LIST
77530: LIST
77531: IN
77532: NOT
77533: OR
77534: IFFALSE 77538
// exit ;
77536: GO 78647
// nat := GetNation ( tower ) ;
77538: LD_ADDR_VAR 0 12
77542: PUSH
77543: LD_VAR 0 1
77547: PPUSH
77548: CALL_OW 248
77552: ST_TO_ADDR
// side := GetSide ( tower ) ;
77553: LD_ADDR_VAR 0 16
77557: PUSH
77558: LD_VAR 0 1
77562: PPUSH
77563: CALL_OW 255
77567: ST_TO_ADDR
// x := GetX ( tower ) ;
77568: LD_ADDR_VAR 0 10
77572: PUSH
77573: LD_VAR 0 1
77577: PPUSH
77578: CALL_OW 250
77582: ST_TO_ADDR
// y := GetY ( tower ) ;
77583: LD_ADDR_VAR 0 11
77587: PUSH
77588: LD_VAR 0 1
77592: PPUSH
77593: CALL_OW 251
77597: ST_TO_ADDR
// if not x or not y then
77598: LD_VAR 0 10
77602: NOT
77603: PUSH
77604: LD_VAR 0 11
77608: NOT
77609: OR
77610: IFFALSE 77614
// exit ;
77612: GO 78647
// weapon := 0 ;
77614: LD_ADDR_VAR 0 18
77618: PUSH
77619: LD_INT 0
77621: ST_TO_ADDR
// fac_list := [ ] ;
77622: LD_ADDR_VAR 0 17
77626: PUSH
77627: EMPTY
77628: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
77629: LD_ADDR_VAR 0 6
77633: PUSH
77634: LD_VAR 0 1
77638: PPUSH
77639: CALL_OW 274
77643: PPUSH
77644: LD_VAR 0 2
77648: PPUSH
77649: LD_INT 0
77651: PPUSH
77652: CALL 75218 0 3
77656: PPUSH
77657: LD_INT 30
77659: PUSH
77660: LD_INT 3
77662: PUSH
77663: EMPTY
77664: LIST
77665: LIST
77666: PPUSH
77667: CALL_OW 72
77671: ST_TO_ADDR
// if not factories then
77672: LD_VAR 0 6
77676: NOT
77677: IFFALSE 77681
// exit ;
77679: GO 78647
// for i in factories do
77681: LD_ADDR_VAR 0 8
77685: PUSH
77686: LD_VAR 0 6
77690: PUSH
77691: FOR_IN
77692: IFFALSE 77717
// fac_list := fac_list union AvailableWeaponList ( i ) ;
77694: LD_ADDR_VAR 0 17
77698: PUSH
77699: LD_VAR 0 17
77703: PUSH
77704: LD_VAR 0 8
77708: PPUSH
77709: CALL_OW 478
77713: UNION
77714: ST_TO_ADDR
77715: GO 77691
77717: POP
77718: POP
// if not fac_list then
77719: LD_VAR 0 17
77723: NOT
77724: IFFALSE 77728
// exit ;
77726: GO 78647
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
77728: LD_ADDR_VAR 0 5
77732: PUSH
77733: LD_INT 4
77735: PUSH
77736: LD_INT 5
77738: PUSH
77739: LD_INT 9
77741: PUSH
77742: LD_INT 10
77744: PUSH
77745: LD_INT 6
77747: PUSH
77748: LD_INT 7
77750: PUSH
77751: LD_INT 11
77753: PUSH
77754: EMPTY
77755: LIST
77756: LIST
77757: LIST
77758: LIST
77759: LIST
77760: LIST
77761: LIST
77762: PUSH
77763: LD_INT 27
77765: PUSH
77766: LD_INT 28
77768: PUSH
77769: LD_INT 26
77771: PUSH
77772: LD_INT 30
77774: PUSH
77775: EMPTY
77776: LIST
77777: LIST
77778: LIST
77779: LIST
77780: PUSH
77781: LD_INT 43
77783: PUSH
77784: LD_INT 44
77786: PUSH
77787: LD_INT 46
77789: PUSH
77790: LD_INT 45
77792: PUSH
77793: LD_INT 47
77795: PUSH
77796: LD_INT 49
77798: PUSH
77799: EMPTY
77800: LIST
77801: LIST
77802: LIST
77803: LIST
77804: LIST
77805: LIST
77806: PUSH
77807: EMPTY
77808: LIST
77809: LIST
77810: LIST
77811: PUSH
77812: LD_VAR 0 12
77816: ARRAY
77817: ST_TO_ADDR
// list := list isect fac_list ;
77818: LD_ADDR_VAR 0 5
77822: PUSH
77823: LD_VAR 0 5
77827: PUSH
77828: LD_VAR 0 17
77832: ISECT
77833: ST_TO_ADDR
// if not list then
77834: LD_VAR 0 5
77838: NOT
77839: IFFALSE 77843
// exit ;
77841: GO 78647
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
77843: LD_VAR 0 12
77847: PUSH
77848: LD_INT 3
77850: EQUAL
77851: PUSH
77852: LD_INT 49
77854: PUSH
77855: LD_VAR 0 5
77859: IN
77860: AND
77861: PUSH
77862: LD_INT 31
77864: PPUSH
77865: LD_VAR 0 16
77869: PPUSH
77870: CALL_OW 321
77874: PUSH
77875: LD_INT 2
77877: EQUAL
77878: AND
77879: IFFALSE 77939
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
77881: LD_INT 22
77883: PUSH
77884: LD_VAR 0 16
77888: PUSH
77889: EMPTY
77890: LIST
77891: LIST
77892: PUSH
77893: LD_INT 35
77895: PUSH
77896: LD_INT 49
77898: PUSH
77899: EMPTY
77900: LIST
77901: LIST
77902: PUSH
77903: LD_INT 91
77905: PUSH
77906: LD_VAR 0 1
77910: PUSH
77911: LD_INT 10
77913: PUSH
77914: EMPTY
77915: LIST
77916: LIST
77917: LIST
77918: PUSH
77919: EMPTY
77920: LIST
77921: LIST
77922: LIST
77923: PPUSH
77924: CALL_OW 69
77928: NOT
77929: IFFALSE 77939
// weapon := ru_time_lapser ;
77931: LD_ADDR_VAR 0 18
77935: PUSH
77936: LD_INT 49
77938: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
77939: LD_VAR 0 12
77943: PUSH
77944: LD_INT 1
77946: PUSH
77947: LD_INT 2
77949: PUSH
77950: EMPTY
77951: LIST
77952: LIST
77953: IN
77954: PUSH
77955: LD_INT 11
77957: PUSH
77958: LD_VAR 0 5
77962: IN
77963: PUSH
77964: LD_INT 30
77966: PUSH
77967: LD_VAR 0 5
77971: IN
77972: OR
77973: AND
77974: PUSH
77975: LD_INT 6
77977: PPUSH
77978: LD_VAR 0 16
77982: PPUSH
77983: CALL_OW 321
77987: PUSH
77988: LD_INT 2
77990: EQUAL
77991: AND
77992: IFFALSE 78157
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
77994: LD_INT 22
77996: PUSH
77997: LD_VAR 0 16
78001: PUSH
78002: EMPTY
78003: LIST
78004: LIST
78005: PUSH
78006: LD_INT 2
78008: PUSH
78009: LD_INT 35
78011: PUSH
78012: LD_INT 11
78014: PUSH
78015: EMPTY
78016: LIST
78017: LIST
78018: PUSH
78019: LD_INT 35
78021: PUSH
78022: LD_INT 30
78024: PUSH
78025: EMPTY
78026: LIST
78027: LIST
78028: PUSH
78029: EMPTY
78030: LIST
78031: LIST
78032: LIST
78033: PUSH
78034: LD_INT 91
78036: PUSH
78037: LD_VAR 0 1
78041: PUSH
78042: LD_INT 18
78044: PUSH
78045: EMPTY
78046: LIST
78047: LIST
78048: LIST
78049: PUSH
78050: EMPTY
78051: LIST
78052: LIST
78053: LIST
78054: PPUSH
78055: CALL_OW 69
78059: NOT
78060: PUSH
78061: LD_INT 22
78063: PUSH
78064: LD_VAR 0 16
78068: PUSH
78069: EMPTY
78070: LIST
78071: LIST
78072: PUSH
78073: LD_INT 2
78075: PUSH
78076: LD_INT 30
78078: PUSH
78079: LD_INT 32
78081: PUSH
78082: EMPTY
78083: LIST
78084: LIST
78085: PUSH
78086: LD_INT 30
78088: PUSH
78089: LD_INT 33
78091: PUSH
78092: EMPTY
78093: LIST
78094: LIST
78095: PUSH
78096: EMPTY
78097: LIST
78098: LIST
78099: LIST
78100: PUSH
78101: LD_INT 91
78103: PUSH
78104: LD_VAR 0 1
78108: PUSH
78109: LD_INT 12
78111: PUSH
78112: EMPTY
78113: LIST
78114: LIST
78115: LIST
78116: PUSH
78117: EMPTY
78118: LIST
78119: LIST
78120: LIST
78121: PUSH
78122: EMPTY
78123: LIST
78124: PPUSH
78125: CALL_OW 69
78129: PUSH
78130: LD_INT 2
78132: GREATER
78133: AND
78134: IFFALSE 78157
// weapon := [ us_radar , ar_radar ] [ nat ] ;
78136: LD_ADDR_VAR 0 18
78140: PUSH
78141: LD_INT 11
78143: PUSH
78144: LD_INT 30
78146: PUSH
78147: EMPTY
78148: LIST
78149: LIST
78150: PUSH
78151: LD_VAR 0 12
78155: ARRAY
78156: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
78157: LD_VAR 0 18
78161: NOT
78162: PUSH
78163: LD_INT 40
78165: PPUSH
78166: LD_VAR 0 16
78170: PPUSH
78171: CALL_OW 321
78175: PUSH
78176: LD_INT 2
78178: EQUAL
78179: AND
78180: PUSH
78181: LD_INT 7
78183: PUSH
78184: LD_VAR 0 5
78188: IN
78189: PUSH
78190: LD_INT 28
78192: PUSH
78193: LD_VAR 0 5
78197: IN
78198: OR
78199: PUSH
78200: LD_INT 45
78202: PUSH
78203: LD_VAR 0 5
78207: IN
78208: OR
78209: AND
78210: IFFALSE 78464
// begin hex := GetHexInfo ( x , y ) ;
78212: LD_ADDR_VAR 0 4
78216: PUSH
78217: LD_VAR 0 10
78221: PPUSH
78222: LD_VAR 0 11
78226: PPUSH
78227: CALL_OW 546
78231: ST_TO_ADDR
// if hex [ 1 ] then
78232: LD_VAR 0 4
78236: PUSH
78237: LD_INT 1
78239: ARRAY
78240: IFFALSE 78244
// exit ;
78242: GO 78647
// height := hex [ 2 ] ;
78244: LD_ADDR_VAR 0 15
78248: PUSH
78249: LD_VAR 0 4
78253: PUSH
78254: LD_INT 2
78256: ARRAY
78257: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
78258: LD_ADDR_VAR 0 14
78262: PUSH
78263: LD_INT 0
78265: PUSH
78266: LD_INT 2
78268: PUSH
78269: LD_INT 3
78271: PUSH
78272: LD_INT 5
78274: PUSH
78275: EMPTY
78276: LIST
78277: LIST
78278: LIST
78279: LIST
78280: ST_TO_ADDR
// for i in tmp do
78281: LD_ADDR_VAR 0 8
78285: PUSH
78286: LD_VAR 0 14
78290: PUSH
78291: FOR_IN
78292: IFFALSE 78462
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
78294: LD_ADDR_VAR 0 9
78298: PUSH
78299: LD_VAR 0 10
78303: PPUSH
78304: LD_VAR 0 8
78308: PPUSH
78309: LD_INT 5
78311: PPUSH
78312: CALL_OW 272
78316: PUSH
78317: LD_VAR 0 11
78321: PPUSH
78322: LD_VAR 0 8
78326: PPUSH
78327: LD_INT 5
78329: PPUSH
78330: CALL_OW 273
78334: PUSH
78335: EMPTY
78336: LIST
78337: LIST
78338: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
78339: LD_VAR 0 9
78343: PUSH
78344: LD_INT 1
78346: ARRAY
78347: PPUSH
78348: LD_VAR 0 9
78352: PUSH
78353: LD_INT 2
78355: ARRAY
78356: PPUSH
78357: CALL_OW 488
78361: IFFALSE 78460
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
78363: LD_ADDR_VAR 0 4
78367: PUSH
78368: LD_VAR 0 9
78372: PUSH
78373: LD_INT 1
78375: ARRAY
78376: PPUSH
78377: LD_VAR 0 9
78381: PUSH
78382: LD_INT 2
78384: ARRAY
78385: PPUSH
78386: CALL_OW 546
78390: ST_TO_ADDR
// if hex [ 1 ] then
78391: LD_VAR 0 4
78395: PUSH
78396: LD_INT 1
78398: ARRAY
78399: IFFALSE 78403
// continue ;
78401: GO 78291
// h := hex [ 2 ] ;
78403: LD_ADDR_VAR 0 13
78407: PUSH
78408: LD_VAR 0 4
78412: PUSH
78413: LD_INT 2
78415: ARRAY
78416: ST_TO_ADDR
// if h + 7 < height then
78417: LD_VAR 0 13
78421: PUSH
78422: LD_INT 7
78424: PLUS
78425: PUSH
78426: LD_VAR 0 15
78430: LESS
78431: IFFALSE 78460
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
78433: LD_ADDR_VAR 0 18
78437: PUSH
78438: LD_INT 7
78440: PUSH
78441: LD_INT 28
78443: PUSH
78444: LD_INT 45
78446: PUSH
78447: EMPTY
78448: LIST
78449: LIST
78450: LIST
78451: PUSH
78452: LD_VAR 0 12
78456: ARRAY
78457: ST_TO_ADDR
// break ;
78458: GO 78462
// end ; end ; end ;
78460: GO 78291
78462: POP
78463: POP
// end ; if not weapon then
78464: LD_VAR 0 18
78468: NOT
78469: IFFALSE 78529
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
78471: LD_ADDR_VAR 0 5
78475: PUSH
78476: LD_VAR 0 5
78480: PUSH
78481: LD_INT 11
78483: PUSH
78484: LD_INT 30
78486: PUSH
78487: LD_INT 49
78489: PUSH
78490: EMPTY
78491: LIST
78492: LIST
78493: LIST
78494: DIFF
78495: ST_TO_ADDR
// if not list then
78496: LD_VAR 0 5
78500: NOT
78501: IFFALSE 78505
// exit ;
78503: GO 78647
// weapon := list [ rand ( 1 , list ) ] ;
78505: LD_ADDR_VAR 0 18
78509: PUSH
78510: LD_VAR 0 5
78514: PUSH
78515: LD_INT 1
78517: PPUSH
78518: LD_VAR 0 5
78522: PPUSH
78523: CALL_OW 12
78527: ARRAY
78528: ST_TO_ADDR
// end ; if weapon then
78529: LD_VAR 0 18
78533: IFFALSE 78647
// begin tmp := CostOfWeapon ( weapon ) ;
78535: LD_ADDR_VAR 0 14
78539: PUSH
78540: LD_VAR 0 18
78544: PPUSH
78545: CALL_OW 451
78549: ST_TO_ADDR
// j := GetBase ( tower ) ;
78550: LD_ADDR_VAR 0 9
78554: PUSH
78555: LD_VAR 0 1
78559: PPUSH
78560: CALL_OW 274
78564: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
78565: LD_VAR 0 9
78569: PPUSH
78570: LD_INT 1
78572: PPUSH
78573: CALL_OW 275
78577: PUSH
78578: LD_VAR 0 14
78582: PUSH
78583: LD_INT 1
78585: ARRAY
78586: GREATEREQUAL
78587: PUSH
78588: LD_VAR 0 9
78592: PPUSH
78593: LD_INT 2
78595: PPUSH
78596: CALL_OW 275
78600: PUSH
78601: LD_VAR 0 14
78605: PUSH
78606: LD_INT 2
78608: ARRAY
78609: GREATEREQUAL
78610: AND
78611: PUSH
78612: LD_VAR 0 9
78616: PPUSH
78617: LD_INT 3
78619: PPUSH
78620: CALL_OW 275
78624: PUSH
78625: LD_VAR 0 14
78629: PUSH
78630: LD_INT 3
78632: ARRAY
78633: GREATEREQUAL
78634: AND
78635: IFFALSE 78647
// result := weapon ;
78637: LD_ADDR_VAR 0 3
78641: PUSH
78642: LD_VAR 0 18
78646: ST_TO_ADDR
// end ; end ;
78647: LD_VAR 0 3
78651: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
78652: LD_INT 0
78654: PPUSH
78655: PPUSH
// result := true ;
78656: LD_ADDR_VAR 0 3
78660: PUSH
78661: LD_INT 1
78663: ST_TO_ADDR
// if array1 = array2 then
78664: LD_VAR 0 1
78668: PUSH
78669: LD_VAR 0 2
78673: EQUAL
78674: IFFALSE 78734
// begin for i = 1 to array1 do
78676: LD_ADDR_VAR 0 4
78680: PUSH
78681: DOUBLE
78682: LD_INT 1
78684: DEC
78685: ST_TO_ADDR
78686: LD_VAR 0 1
78690: PUSH
78691: FOR_TO
78692: IFFALSE 78730
// if array1 [ i ] <> array2 [ i ] then
78694: LD_VAR 0 1
78698: PUSH
78699: LD_VAR 0 4
78703: ARRAY
78704: PUSH
78705: LD_VAR 0 2
78709: PUSH
78710: LD_VAR 0 4
78714: ARRAY
78715: NONEQUAL
78716: IFFALSE 78728
// begin result := false ;
78718: LD_ADDR_VAR 0 3
78722: PUSH
78723: LD_INT 0
78725: ST_TO_ADDR
// break ;
78726: GO 78730
// end ;
78728: GO 78691
78730: POP
78731: POP
// end else
78732: GO 78742
// result := false ;
78734: LD_ADDR_VAR 0 3
78738: PUSH
78739: LD_INT 0
78741: ST_TO_ADDR
// end ;
78742: LD_VAR 0 3
78746: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
78747: LD_INT 0
78749: PPUSH
78750: PPUSH
// if not array1 or not array2 then
78751: LD_VAR 0 1
78755: NOT
78756: PUSH
78757: LD_VAR 0 2
78761: NOT
78762: OR
78763: IFFALSE 78767
// exit ;
78765: GO 78831
// result := true ;
78767: LD_ADDR_VAR 0 3
78771: PUSH
78772: LD_INT 1
78774: ST_TO_ADDR
// for i = 1 to array1 do
78775: LD_ADDR_VAR 0 4
78779: PUSH
78780: DOUBLE
78781: LD_INT 1
78783: DEC
78784: ST_TO_ADDR
78785: LD_VAR 0 1
78789: PUSH
78790: FOR_TO
78791: IFFALSE 78829
// if array1 [ i ] <> array2 [ i ] then
78793: LD_VAR 0 1
78797: PUSH
78798: LD_VAR 0 4
78802: ARRAY
78803: PUSH
78804: LD_VAR 0 2
78808: PUSH
78809: LD_VAR 0 4
78813: ARRAY
78814: NONEQUAL
78815: IFFALSE 78827
// begin result := false ;
78817: LD_ADDR_VAR 0 3
78821: PUSH
78822: LD_INT 0
78824: ST_TO_ADDR
// break ;
78825: GO 78829
// end ;
78827: GO 78790
78829: POP
78830: POP
// end ;
78831: LD_VAR 0 3
78835: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
78836: LD_INT 0
78838: PPUSH
78839: PPUSH
78840: PPUSH
// pom := GetBase ( fac ) ;
78841: LD_ADDR_VAR 0 5
78845: PUSH
78846: LD_VAR 0 1
78850: PPUSH
78851: CALL_OW 274
78855: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
78856: LD_ADDR_VAR 0 4
78860: PUSH
78861: LD_VAR 0 2
78865: PUSH
78866: LD_INT 1
78868: ARRAY
78869: PPUSH
78870: LD_VAR 0 2
78874: PUSH
78875: LD_INT 2
78877: ARRAY
78878: PPUSH
78879: LD_VAR 0 2
78883: PUSH
78884: LD_INT 3
78886: ARRAY
78887: PPUSH
78888: LD_VAR 0 2
78892: PUSH
78893: LD_INT 4
78895: ARRAY
78896: PPUSH
78897: CALL_OW 449
78901: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78902: LD_ADDR_VAR 0 3
78906: PUSH
78907: LD_VAR 0 5
78911: PPUSH
78912: LD_INT 1
78914: PPUSH
78915: CALL_OW 275
78919: PUSH
78920: LD_VAR 0 4
78924: PUSH
78925: LD_INT 1
78927: ARRAY
78928: GREATEREQUAL
78929: PUSH
78930: LD_VAR 0 5
78934: PPUSH
78935: LD_INT 2
78937: PPUSH
78938: CALL_OW 275
78942: PUSH
78943: LD_VAR 0 4
78947: PUSH
78948: LD_INT 2
78950: ARRAY
78951: GREATEREQUAL
78952: AND
78953: PUSH
78954: LD_VAR 0 5
78958: PPUSH
78959: LD_INT 3
78961: PPUSH
78962: CALL_OW 275
78966: PUSH
78967: LD_VAR 0 4
78971: PUSH
78972: LD_INT 3
78974: ARRAY
78975: GREATEREQUAL
78976: AND
78977: ST_TO_ADDR
// end ;
78978: LD_VAR 0 3
78982: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
78983: LD_INT 0
78985: PPUSH
78986: PPUSH
78987: PPUSH
78988: PPUSH
// pom := GetBase ( building ) ;
78989: LD_ADDR_VAR 0 3
78993: PUSH
78994: LD_VAR 0 1
78998: PPUSH
78999: CALL_OW 274
79003: ST_TO_ADDR
// if not pom then
79004: LD_VAR 0 3
79008: NOT
79009: IFFALSE 79013
// exit ;
79011: GO 79183
// btype := GetBType ( building ) ;
79013: LD_ADDR_VAR 0 5
79017: PUSH
79018: LD_VAR 0 1
79022: PPUSH
79023: CALL_OW 266
79027: ST_TO_ADDR
// if btype = b_armoury then
79028: LD_VAR 0 5
79032: PUSH
79033: LD_INT 4
79035: EQUAL
79036: IFFALSE 79046
// btype := b_barracks ;
79038: LD_ADDR_VAR 0 5
79042: PUSH
79043: LD_INT 5
79045: ST_TO_ADDR
// if btype = b_depot then
79046: LD_VAR 0 5
79050: PUSH
79051: LD_INT 0
79053: EQUAL
79054: IFFALSE 79064
// btype := b_warehouse ;
79056: LD_ADDR_VAR 0 5
79060: PUSH
79061: LD_INT 1
79063: ST_TO_ADDR
// if btype = b_workshop then
79064: LD_VAR 0 5
79068: PUSH
79069: LD_INT 2
79071: EQUAL
79072: IFFALSE 79082
// btype := b_factory ;
79074: LD_ADDR_VAR 0 5
79078: PUSH
79079: LD_INT 3
79081: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
79082: LD_ADDR_VAR 0 4
79086: PUSH
79087: LD_VAR 0 5
79091: PPUSH
79092: LD_VAR 0 1
79096: PPUSH
79097: CALL_OW 248
79101: PPUSH
79102: CALL_OW 450
79106: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79107: LD_ADDR_VAR 0 2
79111: PUSH
79112: LD_VAR 0 3
79116: PPUSH
79117: LD_INT 1
79119: PPUSH
79120: CALL_OW 275
79124: PUSH
79125: LD_VAR 0 4
79129: PUSH
79130: LD_INT 1
79132: ARRAY
79133: GREATEREQUAL
79134: PUSH
79135: LD_VAR 0 3
79139: PPUSH
79140: LD_INT 2
79142: PPUSH
79143: CALL_OW 275
79147: PUSH
79148: LD_VAR 0 4
79152: PUSH
79153: LD_INT 2
79155: ARRAY
79156: GREATEREQUAL
79157: AND
79158: PUSH
79159: LD_VAR 0 3
79163: PPUSH
79164: LD_INT 3
79166: PPUSH
79167: CALL_OW 275
79171: PUSH
79172: LD_VAR 0 4
79176: PUSH
79177: LD_INT 3
79179: ARRAY
79180: GREATEREQUAL
79181: AND
79182: ST_TO_ADDR
// end ;
79183: LD_VAR 0 2
79187: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
79188: LD_INT 0
79190: PPUSH
79191: PPUSH
79192: PPUSH
// pom := GetBase ( building ) ;
79193: LD_ADDR_VAR 0 4
79197: PUSH
79198: LD_VAR 0 1
79202: PPUSH
79203: CALL_OW 274
79207: ST_TO_ADDR
// if not pom then
79208: LD_VAR 0 4
79212: NOT
79213: IFFALSE 79217
// exit ;
79215: GO 79318
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
79217: LD_ADDR_VAR 0 5
79221: PUSH
79222: LD_VAR 0 2
79226: PPUSH
79227: LD_VAR 0 1
79231: PPUSH
79232: CALL_OW 248
79236: PPUSH
79237: CALL_OW 450
79241: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79242: LD_ADDR_VAR 0 3
79246: PUSH
79247: LD_VAR 0 4
79251: PPUSH
79252: LD_INT 1
79254: PPUSH
79255: CALL_OW 275
79259: PUSH
79260: LD_VAR 0 5
79264: PUSH
79265: LD_INT 1
79267: ARRAY
79268: GREATEREQUAL
79269: PUSH
79270: LD_VAR 0 4
79274: PPUSH
79275: LD_INT 2
79277: PPUSH
79278: CALL_OW 275
79282: PUSH
79283: LD_VAR 0 5
79287: PUSH
79288: LD_INT 2
79290: ARRAY
79291: GREATEREQUAL
79292: AND
79293: PUSH
79294: LD_VAR 0 4
79298: PPUSH
79299: LD_INT 3
79301: PPUSH
79302: CALL_OW 275
79306: PUSH
79307: LD_VAR 0 5
79311: PUSH
79312: LD_INT 3
79314: ARRAY
79315: GREATEREQUAL
79316: AND
79317: ST_TO_ADDR
// end ;
79318: LD_VAR 0 3
79322: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
79323: LD_INT 0
79325: PPUSH
79326: PPUSH
79327: PPUSH
79328: PPUSH
79329: PPUSH
79330: PPUSH
79331: PPUSH
79332: PPUSH
79333: PPUSH
79334: PPUSH
79335: PPUSH
// result := false ;
79336: LD_ADDR_VAR 0 8
79340: PUSH
79341: LD_INT 0
79343: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
79344: LD_VAR 0 5
79348: NOT
79349: PUSH
79350: LD_VAR 0 1
79354: NOT
79355: OR
79356: PUSH
79357: LD_VAR 0 2
79361: NOT
79362: OR
79363: PUSH
79364: LD_VAR 0 3
79368: NOT
79369: OR
79370: IFFALSE 79374
// exit ;
79372: GO 80188
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
79374: LD_ADDR_VAR 0 14
79378: PUSH
79379: LD_VAR 0 1
79383: PPUSH
79384: LD_VAR 0 2
79388: PPUSH
79389: LD_VAR 0 3
79393: PPUSH
79394: LD_VAR 0 4
79398: PPUSH
79399: LD_VAR 0 5
79403: PUSH
79404: LD_INT 1
79406: ARRAY
79407: PPUSH
79408: CALL_OW 248
79412: PPUSH
79413: LD_INT 0
79415: PPUSH
79416: CALL 81421 0 6
79420: ST_TO_ADDR
// if not hexes then
79421: LD_VAR 0 14
79425: NOT
79426: IFFALSE 79430
// exit ;
79428: GO 80188
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
79430: LD_ADDR_VAR 0 17
79434: PUSH
79435: LD_VAR 0 5
79439: PPUSH
79440: LD_INT 22
79442: PUSH
79443: LD_VAR 0 13
79447: PPUSH
79448: CALL_OW 255
79452: PUSH
79453: EMPTY
79454: LIST
79455: LIST
79456: PUSH
79457: LD_INT 2
79459: PUSH
79460: LD_INT 30
79462: PUSH
79463: LD_INT 0
79465: PUSH
79466: EMPTY
79467: LIST
79468: LIST
79469: PUSH
79470: LD_INT 30
79472: PUSH
79473: LD_INT 1
79475: PUSH
79476: EMPTY
79477: LIST
79478: LIST
79479: PUSH
79480: EMPTY
79481: LIST
79482: LIST
79483: LIST
79484: PUSH
79485: EMPTY
79486: LIST
79487: LIST
79488: PPUSH
79489: CALL_OW 72
79493: ST_TO_ADDR
// for i = 1 to hexes do
79494: LD_ADDR_VAR 0 9
79498: PUSH
79499: DOUBLE
79500: LD_INT 1
79502: DEC
79503: ST_TO_ADDR
79504: LD_VAR 0 14
79508: PUSH
79509: FOR_TO
79510: IFFALSE 80186
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79512: LD_ADDR_VAR 0 13
79516: PUSH
79517: LD_VAR 0 14
79521: PUSH
79522: LD_VAR 0 9
79526: ARRAY
79527: PUSH
79528: LD_INT 1
79530: ARRAY
79531: PPUSH
79532: LD_VAR 0 14
79536: PUSH
79537: LD_VAR 0 9
79541: ARRAY
79542: PUSH
79543: LD_INT 2
79545: ARRAY
79546: PPUSH
79547: CALL_OW 428
79551: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
79552: LD_VAR 0 14
79556: PUSH
79557: LD_VAR 0 9
79561: ARRAY
79562: PUSH
79563: LD_INT 1
79565: ARRAY
79566: PPUSH
79567: LD_VAR 0 14
79571: PUSH
79572: LD_VAR 0 9
79576: ARRAY
79577: PUSH
79578: LD_INT 2
79580: ARRAY
79581: PPUSH
79582: CALL_OW 351
79586: PUSH
79587: LD_VAR 0 14
79591: PUSH
79592: LD_VAR 0 9
79596: ARRAY
79597: PUSH
79598: LD_INT 1
79600: ARRAY
79601: PPUSH
79602: LD_VAR 0 14
79606: PUSH
79607: LD_VAR 0 9
79611: ARRAY
79612: PUSH
79613: LD_INT 2
79615: ARRAY
79616: PPUSH
79617: CALL_OW 488
79621: NOT
79622: OR
79623: PUSH
79624: LD_VAR 0 13
79628: PPUSH
79629: CALL_OW 247
79633: PUSH
79634: LD_INT 3
79636: EQUAL
79637: OR
79638: IFFALSE 79644
// exit ;
79640: POP
79641: POP
79642: GO 80188
// if not tmp then
79644: LD_VAR 0 13
79648: NOT
79649: IFFALSE 79653
// continue ;
79651: GO 79509
// result := true ;
79653: LD_ADDR_VAR 0 8
79657: PUSH
79658: LD_INT 1
79660: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
79661: LD_VAR 0 6
79665: PUSH
79666: LD_VAR 0 13
79670: PPUSH
79671: CALL_OW 247
79675: PUSH
79676: LD_INT 2
79678: EQUAL
79679: AND
79680: PUSH
79681: LD_VAR 0 13
79685: PPUSH
79686: CALL_OW 263
79690: PUSH
79691: LD_INT 1
79693: EQUAL
79694: AND
79695: IFFALSE 79859
// begin if IsDrivenBy ( tmp ) then
79697: LD_VAR 0 13
79701: PPUSH
79702: CALL_OW 311
79706: IFFALSE 79710
// continue ;
79708: GO 79509
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
79710: LD_VAR 0 6
79714: PPUSH
79715: LD_INT 3
79717: PUSH
79718: LD_INT 60
79720: PUSH
79721: EMPTY
79722: LIST
79723: PUSH
79724: EMPTY
79725: LIST
79726: LIST
79727: PUSH
79728: LD_INT 3
79730: PUSH
79731: LD_INT 55
79733: PUSH
79734: EMPTY
79735: LIST
79736: PUSH
79737: EMPTY
79738: LIST
79739: LIST
79740: PUSH
79741: EMPTY
79742: LIST
79743: LIST
79744: PPUSH
79745: CALL_OW 72
79749: IFFALSE 79857
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
79751: LD_ADDR_VAR 0 18
79755: PUSH
79756: LD_VAR 0 6
79760: PPUSH
79761: LD_INT 3
79763: PUSH
79764: LD_INT 60
79766: PUSH
79767: EMPTY
79768: LIST
79769: PUSH
79770: EMPTY
79771: LIST
79772: LIST
79773: PUSH
79774: LD_INT 3
79776: PUSH
79777: LD_INT 55
79779: PUSH
79780: EMPTY
79781: LIST
79782: PUSH
79783: EMPTY
79784: LIST
79785: LIST
79786: PUSH
79787: EMPTY
79788: LIST
79789: LIST
79790: PPUSH
79791: CALL_OW 72
79795: PUSH
79796: LD_INT 1
79798: ARRAY
79799: ST_TO_ADDR
// if IsInUnit ( driver ) then
79800: LD_VAR 0 18
79804: PPUSH
79805: CALL_OW 310
79809: IFFALSE 79820
// ComExit ( driver ) ;
79811: LD_VAR 0 18
79815: PPUSH
79816: CALL 105182 0 1
// AddComEnterUnit ( driver , tmp ) ;
79820: LD_VAR 0 18
79824: PPUSH
79825: LD_VAR 0 13
79829: PPUSH
79830: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
79834: LD_VAR 0 18
79838: PPUSH
79839: LD_VAR 0 7
79843: PPUSH
79844: CALL_OW 173
// AddComExitVehicle ( driver ) ;
79848: LD_VAR 0 18
79852: PPUSH
79853: CALL_OW 181
// end ; continue ;
79857: GO 79509
// end ; if not cleaners or not tmp in cleaners then
79859: LD_VAR 0 6
79863: NOT
79864: PUSH
79865: LD_VAR 0 13
79869: PUSH
79870: LD_VAR 0 6
79874: IN
79875: NOT
79876: OR
79877: IFFALSE 80184
// begin if dep then
79879: LD_VAR 0 17
79883: IFFALSE 80019
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
79885: LD_ADDR_VAR 0 16
79889: PUSH
79890: LD_VAR 0 17
79894: PUSH
79895: LD_INT 1
79897: ARRAY
79898: PPUSH
79899: CALL_OW 250
79903: PPUSH
79904: LD_VAR 0 17
79908: PUSH
79909: LD_INT 1
79911: ARRAY
79912: PPUSH
79913: CALL_OW 254
79917: PPUSH
79918: LD_INT 5
79920: PPUSH
79921: CALL_OW 272
79925: PUSH
79926: LD_VAR 0 17
79930: PUSH
79931: LD_INT 1
79933: ARRAY
79934: PPUSH
79935: CALL_OW 251
79939: PPUSH
79940: LD_VAR 0 17
79944: PUSH
79945: LD_INT 1
79947: ARRAY
79948: PPUSH
79949: CALL_OW 254
79953: PPUSH
79954: LD_INT 5
79956: PPUSH
79957: CALL_OW 273
79961: PUSH
79962: EMPTY
79963: LIST
79964: LIST
79965: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
79966: LD_VAR 0 16
79970: PUSH
79971: LD_INT 1
79973: ARRAY
79974: PPUSH
79975: LD_VAR 0 16
79979: PUSH
79980: LD_INT 2
79982: ARRAY
79983: PPUSH
79984: CALL_OW 488
79988: IFFALSE 80019
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
79990: LD_VAR 0 13
79994: PPUSH
79995: LD_VAR 0 16
79999: PUSH
80000: LD_INT 1
80002: ARRAY
80003: PPUSH
80004: LD_VAR 0 16
80008: PUSH
80009: LD_INT 2
80011: ARRAY
80012: PPUSH
80013: CALL_OW 111
// continue ;
80017: GO 79509
// end ; end ; r := GetDir ( tmp ) ;
80019: LD_ADDR_VAR 0 15
80023: PUSH
80024: LD_VAR 0 13
80028: PPUSH
80029: CALL_OW 254
80033: ST_TO_ADDR
// if r = 5 then
80034: LD_VAR 0 15
80038: PUSH
80039: LD_INT 5
80041: EQUAL
80042: IFFALSE 80052
// r := 0 ;
80044: LD_ADDR_VAR 0 15
80048: PUSH
80049: LD_INT 0
80051: ST_TO_ADDR
// for j = r to 5 do
80052: LD_ADDR_VAR 0 10
80056: PUSH
80057: DOUBLE
80058: LD_VAR 0 15
80062: DEC
80063: ST_TO_ADDR
80064: LD_INT 5
80066: PUSH
80067: FOR_TO
80068: IFFALSE 80182
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
80070: LD_ADDR_VAR 0 11
80074: PUSH
80075: LD_VAR 0 13
80079: PPUSH
80080: CALL_OW 250
80084: PPUSH
80085: LD_VAR 0 10
80089: PPUSH
80090: LD_INT 2
80092: PPUSH
80093: CALL_OW 272
80097: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
80098: LD_ADDR_VAR 0 12
80102: PUSH
80103: LD_VAR 0 13
80107: PPUSH
80108: CALL_OW 251
80112: PPUSH
80113: LD_VAR 0 10
80117: PPUSH
80118: LD_INT 2
80120: PPUSH
80121: CALL_OW 273
80125: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
80126: LD_VAR 0 11
80130: PPUSH
80131: LD_VAR 0 12
80135: PPUSH
80136: CALL_OW 488
80140: PUSH
80141: LD_VAR 0 11
80145: PPUSH
80146: LD_VAR 0 12
80150: PPUSH
80151: CALL_OW 428
80155: NOT
80156: AND
80157: IFFALSE 80180
// begin ComMoveXY ( tmp , _x , _y ) ;
80159: LD_VAR 0 13
80163: PPUSH
80164: LD_VAR 0 11
80168: PPUSH
80169: LD_VAR 0 12
80173: PPUSH
80174: CALL_OW 111
// break ;
80178: GO 80182
// end ; end ;
80180: GO 80067
80182: POP
80183: POP
// end ; end ;
80184: GO 79509
80186: POP
80187: POP
// end ;
80188: LD_VAR 0 8
80192: RET
// export function BuildingTechInvented ( side , btype ) ; begin
80193: LD_INT 0
80195: PPUSH
// result := true ;
80196: LD_ADDR_VAR 0 3
80200: PUSH
80201: LD_INT 1
80203: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
80204: LD_VAR 0 2
80208: PUSH
80209: LD_INT 24
80211: DOUBLE
80212: EQUAL
80213: IFTRUE 80223
80215: LD_INT 33
80217: DOUBLE
80218: EQUAL
80219: IFTRUE 80223
80221: GO 80248
80223: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
80224: LD_ADDR_VAR 0 3
80228: PUSH
80229: LD_INT 32
80231: PPUSH
80232: LD_VAR 0 1
80236: PPUSH
80237: CALL_OW 321
80241: PUSH
80242: LD_INT 2
80244: EQUAL
80245: ST_TO_ADDR
80246: GO 80564
80248: LD_INT 20
80250: DOUBLE
80251: EQUAL
80252: IFTRUE 80256
80254: GO 80281
80256: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
80257: LD_ADDR_VAR 0 3
80261: PUSH
80262: LD_INT 6
80264: PPUSH
80265: LD_VAR 0 1
80269: PPUSH
80270: CALL_OW 321
80274: PUSH
80275: LD_INT 2
80277: EQUAL
80278: ST_TO_ADDR
80279: GO 80564
80281: LD_INT 22
80283: DOUBLE
80284: EQUAL
80285: IFTRUE 80295
80287: LD_INT 36
80289: DOUBLE
80290: EQUAL
80291: IFTRUE 80295
80293: GO 80320
80295: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
80296: LD_ADDR_VAR 0 3
80300: PUSH
80301: LD_INT 15
80303: PPUSH
80304: LD_VAR 0 1
80308: PPUSH
80309: CALL_OW 321
80313: PUSH
80314: LD_INT 2
80316: EQUAL
80317: ST_TO_ADDR
80318: GO 80564
80320: LD_INT 30
80322: DOUBLE
80323: EQUAL
80324: IFTRUE 80328
80326: GO 80353
80328: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
80329: LD_ADDR_VAR 0 3
80333: PUSH
80334: LD_INT 20
80336: PPUSH
80337: LD_VAR 0 1
80341: PPUSH
80342: CALL_OW 321
80346: PUSH
80347: LD_INT 2
80349: EQUAL
80350: ST_TO_ADDR
80351: GO 80564
80353: LD_INT 28
80355: DOUBLE
80356: EQUAL
80357: IFTRUE 80367
80359: LD_INT 21
80361: DOUBLE
80362: EQUAL
80363: IFTRUE 80367
80365: GO 80392
80367: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
80368: LD_ADDR_VAR 0 3
80372: PUSH
80373: LD_INT 21
80375: PPUSH
80376: LD_VAR 0 1
80380: PPUSH
80381: CALL_OW 321
80385: PUSH
80386: LD_INT 2
80388: EQUAL
80389: ST_TO_ADDR
80390: GO 80564
80392: LD_INT 16
80394: DOUBLE
80395: EQUAL
80396: IFTRUE 80400
80398: GO 80425
80400: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
80401: LD_ADDR_VAR 0 3
80405: PUSH
80406: LD_INT 84
80408: PPUSH
80409: LD_VAR 0 1
80413: PPUSH
80414: CALL_OW 321
80418: PUSH
80419: LD_INT 2
80421: EQUAL
80422: ST_TO_ADDR
80423: GO 80564
80425: LD_INT 19
80427: DOUBLE
80428: EQUAL
80429: IFTRUE 80439
80431: LD_INT 23
80433: DOUBLE
80434: EQUAL
80435: IFTRUE 80439
80437: GO 80464
80439: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
80440: LD_ADDR_VAR 0 3
80444: PUSH
80445: LD_INT 83
80447: PPUSH
80448: LD_VAR 0 1
80452: PPUSH
80453: CALL_OW 321
80457: PUSH
80458: LD_INT 2
80460: EQUAL
80461: ST_TO_ADDR
80462: GO 80564
80464: LD_INT 17
80466: DOUBLE
80467: EQUAL
80468: IFTRUE 80472
80470: GO 80497
80472: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
80473: LD_ADDR_VAR 0 3
80477: PUSH
80478: LD_INT 39
80480: PPUSH
80481: LD_VAR 0 1
80485: PPUSH
80486: CALL_OW 321
80490: PUSH
80491: LD_INT 2
80493: EQUAL
80494: ST_TO_ADDR
80495: GO 80564
80497: LD_INT 18
80499: DOUBLE
80500: EQUAL
80501: IFTRUE 80505
80503: GO 80530
80505: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
80506: LD_ADDR_VAR 0 3
80510: PUSH
80511: LD_INT 40
80513: PPUSH
80514: LD_VAR 0 1
80518: PPUSH
80519: CALL_OW 321
80523: PUSH
80524: LD_INT 2
80526: EQUAL
80527: ST_TO_ADDR
80528: GO 80564
80530: LD_INT 27
80532: DOUBLE
80533: EQUAL
80534: IFTRUE 80538
80536: GO 80563
80538: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
80539: LD_ADDR_VAR 0 3
80543: PUSH
80544: LD_INT 35
80546: PPUSH
80547: LD_VAR 0 1
80551: PPUSH
80552: CALL_OW 321
80556: PUSH
80557: LD_INT 2
80559: EQUAL
80560: ST_TO_ADDR
80561: GO 80564
80563: POP
// end ;
80564: LD_VAR 0 3
80568: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
80569: LD_INT 0
80571: PPUSH
80572: PPUSH
80573: PPUSH
80574: PPUSH
80575: PPUSH
80576: PPUSH
80577: PPUSH
80578: PPUSH
80579: PPUSH
80580: PPUSH
80581: PPUSH
// result := false ;
80582: LD_ADDR_VAR 0 6
80586: PUSH
80587: LD_INT 0
80589: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
80590: LD_VAR 0 1
80594: NOT
80595: PUSH
80596: LD_VAR 0 1
80600: PPUSH
80601: CALL_OW 266
80605: PUSH
80606: LD_INT 0
80608: PUSH
80609: LD_INT 1
80611: PUSH
80612: EMPTY
80613: LIST
80614: LIST
80615: IN
80616: NOT
80617: OR
80618: PUSH
80619: LD_VAR 0 2
80623: NOT
80624: OR
80625: PUSH
80626: LD_VAR 0 5
80630: PUSH
80631: LD_INT 0
80633: PUSH
80634: LD_INT 1
80636: PUSH
80637: LD_INT 2
80639: PUSH
80640: LD_INT 3
80642: PUSH
80643: LD_INT 4
80645: PUSH
80646: LD_INT 5
80648: PUSH
80649: EMPTY
80650: LIST
80651: LIST
80652: LIST
80653: LIST
80654: LIST
80655: LIST
80656: IN
80657: NOT
80658: OR
80659: PUSH
80660: LD_VAR 0 3
80664: PPUSH
80665: LD_VAR 0 4
80669: PPUSH
80670: CALL_OW 488
80674: NOT
80675: OR
80676: IFFALSE 80680
// exit ;
80678: GO 81416
// side := GetSide ( depot ) ;
80680: LD_ADDR_VAR 0 9
80684: PUSH
80685: LD_VAR 0 1
80689: PPUSH
80690: CALL_OW 255
80694: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
80695: LD_VAR 0 9
80699: PPUSH
80700: LD_VAR 0 2
80704: PPUSH
80705: CALL 80193 0 2
80709: NOT
80710: IFFALSE 80714
// exit ;
80712: GO 81416
// pom := GetBase ( depot ) ;
80714: LD_ADDR_VAR 0 10
80718: PUSH
80719: LD_VAR 0 1
80723: PPUSH
80724: CALL_OW 274
80728: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
80729: LD_ADDR_VAR 0 11
80733: PUSH
80734: LD_VAR 0 2
80738: PPUSH
80739: LD_VAR 0 1
80743: PPUSH
80744: CALL_OW 248
80748: PPUSH
80749: CALL_OW 450
80753: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
80754: LD_VAR 0 10
80758: PPUSH
80759: LD_INT 1
80761: PPUSH
80762: CALL_OW 275
80766: PUSH
80767: LD_VAR 0 11
80771: PUSH
80772: LD_INT 1
80774: ARRAY
80775: GREATEREQUAL
80776: PUSH
80777: LD_VAR 0 10
80781: PPUSH
80782: LD_INT 2
80784: PPUSH
80785: CALL_OW 275
80789: PUSH
80790: LD_VAR 0 11
80794: PUSH
80795: LD_INT 2
80797: ARRAY
80798: GREATEREQUAL
80799: AND
80800: PUSH
80801: LD_VAR 0 10
80805: PPUSH
80806: LD_INT 3
80808: PPUSH
80809: CALL_OW 275
80813: PUSH
80814: LD_VAR 0 11
80818: PUSH
80819: LD_INT 3
80821: ARRAY
80822: GREATEREQUAL
80823: AND
80824: NOT
80825: IFFALSE 80829
// exit ;
80827: GO 81416
// if GetBType ( depot ) = b_depot then
80829: LD_VAR 0 1
80833: PPUSH
80834: CALL_OW 266
80838: PUSH
80839: LD_INT 0
80841: EQUAL
80842: IFFALSE 80854
// dist := 28 else
80844: LD_ADDR_VAR 0 14
80848: PUSH
80849: LD_INT 28
80851: ST_TO_ADDR
80852: GO 80862
// dist := 36 ;
80854: LD_ADDR_VAR 0 14
80858: PUSH
80859: LD_INT 36
80861: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
80862: LD_VAR 0 1
80866: PPUSH
80867: LD_VAR 0 3
80871: PPUSH
80872: LD_VAR 0 4
80876: PPUSH
80877: CALL_OW 297
80881: PUSH
80882: LD_VAR 0 14
80886: GREATER
80887: IFFALSE 80891
// exit ;
80889: GO 81416
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
80891: LD_ADDR_VAR 0 12
80895: PUSH
80896: LD_VAR 0 2
80900: PPUSH
80901: LD_VAR 0 3
80905: PPUSH
80906: LD_VAR 0 4
80910: PPUSH
80911: LD_VAR 0 5
80915: PPUSH
80916: LD_VAR 0 1
80920: PPUSH
80921: CALL_OW 248
80925: PPUSH
80926: LD_INT 0
80928: PPUSH
80929: CALL 81421 0 6
80933: ST_TO_ADDR
// if not hexes then
80934: LD_VAR 0 12
80938: NOT
80939: IFFALSE 80943
// exit ;
80941: GO 81416
// hex := GetHexInfo ( x , y ) ;
80943: LD_ADDR_VAR 0 15
80947: PUSH
80948: LD_VAR 0 3
80952: PPUSH
80953: LD_VAR 0 4
80957: PPUSH
80958: CALL_OW 546
80962: ST_TO_ADDR
// if hex [ 1 ] then
80963: LD_VAR 0 15
80967: PUSH
80968: LD_INT 1
80970: ARRAY
80971: IFFALSE 80975
// exit ;
80973: GO 81416
// height := hex [ 2 ] ;
80975: LD_ADDR_VAR 0 13
80979: PUSH
80980: LD_VAR 0 15
80984: PUSH
80985: LD_INT 2
80987: ARRAY
80988: ST_TO_ADDR
// for i = 1 to hexes do
80989: LD_ADDR_VAR 0 7
80993: PUSH
80994: DOUBLE
80995: LD_INT 1
80997: DEC
80998: ST_TO_ADDR
80999: LD_VAR 0 12
81003: PUSH
81004: FOR_TO
81005: IFFALSE 81335
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
81007: LD_VAR 0 12
81011: PUSH
81012: LD_VAR 0 7
81016: ARRAY
81017: PUSH
81018: LD_INT 1
81020: ARRAY
81021: PPUSH
81022: LD_VAR 0 12
81026: PUSH
81027: LD_VAR 0 7
81031: ARRAY
81032: PUSH
81033: LD_INT 2
81035: ARRAY
81036: PPUSH
81037: CALL_OW 488
81041: NOT
81042: PUSH
81043: LD_VAR 0 12
81047: PUSH
81048: LD_VAR 0 7
81052: ARRAY
81053: PUSH
81054: LD_INT 1
81056: ARRAY
81057: PPUSH
81058: LD_VAR 0 12
81062: PUSH
81063: LD_VAR 0 7
81067: ARRAY
81068: PUSH
81069: LD_INT 2
81071: ARRAY
81072: PPUSH
81073: CALL_OW 428
81077: PUSH
81078: LD_INT 0
81080: GREATER
81081: OR
81082: PUSH
81083: LD_VAR 0 12
81087: PUSH
81088: LD_VAR 0 7
81092: ARRAY
81093: PUSH
81094: LD_INT 1
81096: ARRAY
81097: PPUSH
81098: LD_VAR 0 12
81102: PUSH
81103: LD_VAR 0 7
81107: ARRAY
81108: PUSH
81109: LD_INT 2
81111: ARRAY
81112: PPUSH
81113: CALL_OW 351
81117: OR
81118: IFFALSE 81124
// exit ;
81120: POP
81121: POP
81122: GO 81416
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81124: LD_ADDR_VAR 0 8
81128: PUSH
81129: LD_VAR 0 12
81133: PUSH
81134: LD_VAR 0 7
81138: ARRAY
81139: PUSH
81140: LD_INT 1
81142: ARRAY
81143: PPUSH
81144: LD_VAR 0 12
81148: PUSH
81149: LD_VAR 0 7
81153: ARRAY
81154: PUSH
81155: LD_INT 2
81157: ARRAY
81158: PPUSH
81159: CALL_OW 546
81163: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
81164: LD_VAR 0 8
81168: PUSH
81169: LD_INT 1
81171: ARRAY
81172: PUSH
81173: LD_VAR 0 8
81177: PUSH
81178: LD_INT 2
81180: ARRAY
81181: PUSH
81182: LD_VAR 0 13
81186: PUSH
81187: LD_INT 2
81189: PLUS
81190: GREATER
81191: OR
81192: PUSH
81193: LD_VAR 0 8
81197: PUSH
81198: LD_INT 2
81200: ARRAY
81201: PUSH
81202: LD_VAR 0 13
81206: PUSH
81207: LD_INT 2
81209: MINUS
81210: LESS
81211: OR
81212: PUSH
81213: LD_VAR 0 8
81217: PUSH
81218: LD_INT 3
81220: ARRAY
81221: PUSH
81222: LD_INT 0
81224: PUSH
81225: LD_INT 8
81227: PUSH
81228: LD_INT 9
81230: PUSH
81231: LD_INT 10
81233: PUSH
81234: LD_INT 11
81236: PUSH
81237: LD_INT 12
81239: PUSH
81240: LD_INT 13
81242: PUSH
81243: LD_INT 16
81245: PUSH
81246: LD_INT 17
81248: PUSH
81249: LD_INT 18
81251: PUSH
81252: LD_INT 19
81254: PUSH
81255: LD_INT 20
81257: PUSH
81258: LD_INT 21
81260: PUSH
81261: EMPTY
81262: LIST
81263: LIST
81264: LIST
81265: LIST
81266: LIST
81267: LIST
81268: LIST
81269: LIST
81270: LIST
81271: LIST
81272: LIST
81273: LIST
81274: LIST
81275: IN
81276: NOT
81277: OR
81278: PUSH
81279: LD_VAR 0 8
81283: PUSH
81284: LD_INT 5
81286: ARRAY
81287: NOT
81288: OR
81289: PUSH
81290: LD_VAR 0 8
81294: PUSH
81295: LD_INT 6
81297: ARRAY
81298: PUSH
81299: LD_INT 1
81301: PUSH
81302: LD_INT 2
81304: PUSH
81305: LD_INT 7
81307: PUSH
81308: LD_INT 9
81310: PUSH
81311: LD_INT 10
81313: PUSH
81314: LD_INT 11
81316: PUSH
81317: EMPTY
81318: LIST
81319: LIST
81320: LIST
81321: LIST
81322: LIST
81323: LIST
81324: IN
81325: NOT
81326: OR
81327: IFFALSE 81333
// exit ;
81329: POP
81330: POP
81331: GO 81416
// end ;
81333: GO 81004
81335: POP
81336: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
81337: LD_VAR 0 9
81341: PPUSH
81342: LD_VAR 0 3
81346: PPUSH
81347: LD_VAR 0 4
81351: PPUSH
81352: LD_INT 20
81354: PPUSH
81355: CALL 73368 0 4
81359: PUSH
81360: LD_INT 4
81362: ARRAY
81363: IFFALSE 81367
// exit ;
81365: GO 81416
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
81367: LD_VAR 0 2
81371: PUSH
81372: LD_INT 29
81374: PUSH
81375: LD_INT 30
81377: PUSH
81378: EMPTY
81379: LIST
81380: LIST
81381: IN
81382: PUSH
81383: LD_VAR 0 3
81387: PPUSH
81388: LD_VAR 0 4
81392: PPUSH
81393: LD_VAR 0 9
81397: PPUSH
81398: CALL_OW 440
81402: NOT
81403: AND
81404: IFFALSE 81408
// exit ;
81406: GO 81416
// result := true ;
81408: LD_ADDR_VAR 0 6
81412: PUSH
81413: LD_INT 1
81415: ST_TO_ADDR
// end ;
81416: LD_VAR 0 6
81420: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
81421: LD_INT 0
81423: PPUSH
81424: PPUSH
81425: PPUSH
81426: PPUSH
81427: PPUSH
81428: PPUSH
81429: PPUSH
81430: PPUSH
81431: PPUSH
81432: PPUSH
81433: PPUSH
81434: PPUSH
81435: PPUSH
81436: PPUSH
81437: PPUSH
81438: PPUSH
81439: PPUSH
81440: PPUSH
81441: PPUSH
81442: PPUSH
81443: PPUSH
81444: PPUSH
81445: PPUSH
81446: PPUSH
81447: PPUSH
81448: PPUSH
81449: PPUSH
81450: PPUSH
81451: PPUSH
81452: PPUSH
81453: PPUSH
81454: PPUSH
81455: PPUSH
81456: PPUSH
81457: PPUSH
81458: PPUSH
81459: PPUSH
81460: PPUSH
81461: PPUSH
81462: PPUSH
81463: PPUSH
81464: PPUSH
81465: PPUSH
81466: PPUSH
81467: PPUSH
81468: PPUSH
81469: PPUSH
81470: PPUSH
81471: PPUSH
81472: PPUSH
81473: PPUSH
81474: PPUSH
81475: PPUSH
81476: PPUSH
81477: PPUSH
81478: PPUSH
81479: PPUSH
81480: PPUSH
// result = [ ] ;
81481: LD_ADDR_VAR 0 7
81485: PUSH
81486: EMPTY
81487: ST_TO_ADDR
// temp_list = [ ] ;
81488: LD_ADDR_VAR 0 9
81492: PUSH
81493: EMPTY
81494: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
81495: LD_VAR 0 4
81499: PUSH
81500: LD_INT 0
81502: PUSH
81503: LD_INT 1
81505: PUSH
81506: LD_INT 2
81508: PUSH
81509: LD_INT 3
81511: PUSH
81512: LD_INT 4
81514: PUSH
81515: LD_INT 5
81517: PUSH
81518: EMPTY
81519: LIST
81520: LIST
81521: LIST
81522: LIST
81523: LIST
81524: LIST
81525: IN
81526: NOT
81527: PUSH
81528: LD_VAR 0 1
81532: PUSH
81533: LD_INT 0
81535: PUSH
81536: LD_INT 1
81538: PUSH
81539: EMPTY
81540: LIST
81541: LIST
81542: IN
81543: PUSH
81544: LD_VAR 0 5
81548: PUSH
81549: LD_INT 1
81551: PUSH
81552: LD_INT 2
81554: PUSH
81555: LD_INT 3
81557: PUSH
81558: EMPTY
81559: LIST
81560: LIST
81561: LIST
81562: IN
81563: NOT
81564: AND
81565: OR
81566: IFFALSE 81570
// exit ;
81568: GO 99961
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
81570: LD_VAR 0 1
81574: PUSH
81575: LD_INT 6
81577: PUSH
81578: LD_INT 7
81580: PUSH
81581: LD_INT 8
81583: PUSH
81584: LD_INT 13
81586: PUSH
81587: LD_INT 12
81589: PUSH
81590: LD_INT 15
81592: PUSH
81593: LD_INT 11
81595: PUSH
81596: LD_INT 14
81598: PUSH
81599: LD_INT 10
81601: PUSH
81602: EMPTY
81603: LIST
81604: LIST
81605: LIST
81606: LIST
81607: LIST
81608: LIST
81609: LIST
81610: LIST
81611: LIST
81612: IN
81613: IFFALSE 81623
// btype = b_lab ;
81615: LD_ADDR_VAR 0 1
81619: PUSH
81620: LD_INT 6
81622: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
81623: LD_VAR 0 6
81627: PUSH
81628: LD_INT 0
81630: PUSH
81631: LD_INT 1
81633: PUSH
81634: LD_INT 2
81636: PUSH
81637: EMPTY
81638: LIST
81639: LIST
81640: LIST
81641: IN
81642: NOT
81643: PUSH
81644: LD_VAR 0 1
81648: PUSH
81649: LD_INT 0
81651: PUSH
81652: LD_INT 1
81654: PUSH
81655: LD_INT 2
81657: PUSH
81658: LD_INT 3
81660: PUSH
81661: LD_INT 6
81663: PUSH
81664: LD_INT 36
81666: PUSH
81667: LD_INT 4
81669: PUSH
81670: LD_INT 5
81672: PUSH
81673: LD_INT 31
81675: PUSH
81676: LD_INT 32
81678: PUSH
81679: LD_INT 33
81681: PUSH
81682: EMPTY
81683: LIST
81684: LIST
81685: LIST
81686: LIST
81687: LIST
81688: LIST
81689: LIST
81690: LIST
81691: LIST
81692: LIST
81693: LIST
81694: IN
81695: NOT
81696: PUSH
81697: LD_VAR 0 6
81701: PUSH
81702: LD_INT 1
81704: EQUAL
81705: AND
81706: OR
81707: PUSH
81708: LD_VAR 0 1
81712: PUSH
81713: LD_INT 2
81715: PUSH
81716: LD_INT 3
81718: PUSH
81719: EMPTY
81720: LIST
81721: LIST
81722: IN
81723: NOT
81724: PUSH
81725: LD_VAR 0 6
81729: PUSH
81730: LD_INT 2
81732: EQUAL
81733: AND
81734: OR
81735: IFFALSE 81745
// mode = 0 ;
81737: LD_ADDR_VAR 0 6
81741: PUSH
81742: LD_INT 0
81744: ST_TO_ADDR
// case mode of 0 :
81745: LD_VAR 0 6
81749: PUSH
81750: LD_INT 0
81752: DOUBLE
81753: EQUAL
81754: IFTRUE 81758
81756: GO 93211
81758: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
81759: LD_ADDR_VAR 0 11
81763: PUSH
81764: LD_INT 0
81766: PUSH
81767: LD_INT 0
81769: PUSH
81770: EMPTY
81771: LIST
81772: LIST
81773: PUSH
81774: LD_INT 0
81776: PUSH
81777: LD_INT 1
81779: NEG
81780: PUSH
81781: EMPTY
81782: LIST
81783: LIST
81784: PUSH
81785: LD_INT 1
81787: PUSH
81788: LD_INT 0
81790: PUSH
81791: EMPTY
81792: LIST
81793: LIST
81794: PUSH
81795: LD_INT 1
81797: PUSH
81798: LD_INT 1
81800: PUSH
81801: EMPTY
81802: LIST
81803: LIST
81804: PUSH
81805: LD_INT 0
81807: PUSH
81808: LD_INT 1
81810: PUSH
81811: EMPTY
81812: LIST
81813: LIST
81814: PUSH
81815: LD_INT 1
81817: NEG
81818: PUSH
81819: LD_INT 0
81821: PUSH
81822: EMPTY
81823: LIST
81824: LIST
81825: PUSH
81826: LD_INT 1
81828: NEG
81829: PUSH
81830: LD_INT 1
81832: NEG
81833: PUSH
81834: EMPTY
81835: LIST
81836: LIST
81837: PUSH
81838: LD_INT 1
81840: NEG
81841: PUSH
81842: LD_INT 2
81844: NEG
81845: PUSH
81846: EMPTY
81847: LIST
81848: LIST
81849: PUSH
81850: LD_INT 0
81852: PUSH
81853: LD_INT 2
81855: NEG
81856: PUSH
81857: EMPTY
81858: LIST
81859: LIST
81860: PUSH
81861: LD_INT 1
81863: PUSH
81864: LD_INT 1
81866: NEG
81867: PUSH
81868: EMPTY
81869: LIST
81870: LIST
81871: PUSH
81872: LD_INT 1
81874: PUSH
81875: LD_INT 2
81877: PUSH
81878: EMPTY
81879: LIST
81880: LIST
81881: PUSH
81882: LD_INT 0
81884: PUSH
81885: LD_INT 2
81887: PUSH
81888: EMPTY
81889: LIST
81890: LIST
81891: PUSH
81892: LD_INT 1
81894: NEG
81895: PUSH
81896: LD_INT 1
81898: PUSH
81899: EMPTY
81900: LIST
81901: LIST
81902: PUSH
81903: LD_INT 1
81905: PUSH
81906: LD_INT 3
81908: PUSH
81909: EMPTY
81910: LIST
81911: LIST
81912: PUSH
81913: LD_INT 0
81915: PUSH
81916: LD_INT 3
81918: PUSH
81919: EMPTY
81920: LIST
81921: LIST
81922: PUSH
81923: LD_INT 1
81925: NEG
81926: PUSH
81927: LD_INT 2
81929: PUSH
81930: EMPTY
81931: LIST
81932: LIST
81933: PUSH
81934: EMPTY
81935: LIST
81936: LIST
81937: LIST
81938: LIST
81939: LIST
81940: LIST
81941: LIST
81942: LIST
81943: LIST
81944: LIST
81945: LIST
81946: LIST
81947: LIST
81948: LIST
81949: LIST
81950: LIST
81951: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
81952: LD_ADDR_VAR 0 12
81956: PUSH
81957: LD_INT 0
81959: PUSH
81960: LD_INT 0
81962: PUSH
81963: EMPTY
81964: LIST
81965: LIST
81966: PUSH
81967: LD_INT 0
81969: PUSH
81970: LD_INT 1
81972: NEG
81973: PUSH
81974: EMPTY
81975: LIST
81976: LIST
81977: PUSH
81978: LD_INT 1
81980: PUSH
81981: LD_INT 0
81983: PUSH
81984: EMPTY
81985: LIST
81986: LIST
81987: PUSH
81988: LD_INT 1
81990: PUSH
81991: LD_INT 1
81993: PUSH
81994: EMPTY
81995: LIST
81996: LIST
81997: PUSH
81998: LD_INT 0
82000: PUSH
82001: LD_INT 1
82003: PUSH
82004: EMPTY
82005: LIST
82006: LIST
82007: PUSH
82008: LD_INT 1
82010: NEG
82011: PUSH
82012: LD_INT 0
82014: PUSH
82015: EMPTY
82016: LIST
82017: LIST
82018: PUSH
82019: LD_INT 1
82021: NEG
82022: PUSH
82023: LD_INT 1
82025: NEG
82026: PUSH
82027: EMPTY
82028: LIST
82029: LIST
82030: PUSH
82031: LD_INT 1
82033: PUSH
82034: LD_INT 1
82036: NEG
82037: PUSH
82038: EMPTY
82039: LIST
82040: LIST
82041: PUSH
82042: LD_INT 2
82044: PUSH
82045: LD_INT 0
82047: PUSH
82048: EMPTY
82049: LIST
82050: LIST
82051: PUSH
82052: LD_INT 2
82054: PUSH
82055: LD_INT 1
82057: PUSH
82058: EMPTY
82059: LIST
82060: LIST
82061: PUSH
82062: LD_INT 1
82064: NEG
82065: PUSH
82066: LD_INT 1
82068: PUSH
82069: EMPTY
82070: LIST
82071: LIST
82072: PUSH
82073: LD_INT 2
82075: NEG
82076: PUSH
82077: LD_INT 0
82079: PUSH
82080: EMPTY
82081: LIST
82082: LIST
82083: PUSH
82084: LD_INT 2
82086: NEG
82087: PUSH
82088: LD_INT 1
82090: NEG
82091: PUSH
82092: EMPTY
82093: LIST
82094: LIST
82095: PUSH
82096: LD_INT 2
82098: NEG
82099: PUSH
82100: LD_INT 1
82102: PUSH
82103: EMPTY
82104: LIST
82105: LIST
82106: PUSH
82107: LD_INT 3
82109: NEG
82110: PUSH
82111: LD_INT 0
82113: PUSH
82114: EMPTY
82115: LIST
82116: LIST
82117: PUSH
82118: LD_INT 3
82120: NEG
82121: PUSH
82122: LD_INT 1
82124: NEG
82125: PUSH
82126: EMPTY
82127: LIST
82128: LIST
82129: PUSH
82130: EMPTY
82131: LIST
82132: LIST
82133: LIST
82134: LIST
82135: LIST
82136: LIST
82137: LIST
82138: LIST
82139: LIST
82140: LIST
82141: LIST
82142: LIST
82143: LIST
82144: LIST
82145: LIST
82146: LIST
82147: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82148: LD_ADDR_VAR 0 13
82152: PUSH
82153: LD_INT 0
82155: PUSH
82156: LD_INT 0
82158: PUSH
82159: EMPTY
82160: LIST
82161: LIST
82162: PUSH
82163: LD_INT 0
82165: PUSH
82166: LD_INT 1
82168: NEG
82169: PUSH
82170: EMPTY
82171: LIST
82172: LIST
82173: PUSH
82174: LD_INT 1
82176: PUSH
82177: LD_INT 0
82179: PUSH
82180: EMPTY
82181: LIST
82182: LIST
82183: PUSH
82184: LD_INT 1
82186: PUSH
82187: LD_INT 1
82189: PUSH
82190: EMPTY
82191: LIST
82192: LIST
82193: PUSH
82194: LD_INT 0
82196: PUSH
82197: LD_INT 1
82199: PUSH
82200: EMPTY
82201: LIST
82202: LIST
82203: PUSH
82204: LD_INT 1
82206: NEG
82207: PUSH
82208: LD_INT 0
82210: PUSH
82211: EMPTY
82212: LIST
82213: LIST
82214: PUSH
82215: LD_INT 1
82217: NEG
82218: PUSH
82219: LD_INT 1
82221: NEG
82222: PUSH
82223: EMPTY
82224: LIST
82225: LIST
82226: PUSH
82227: LD_INT 1
82229: NEG
82230: PUSH
82231: LD_INT 2
82233: NEG
82234: PUSH
82235: EMPTY
82236: LIST
82237: LIST
82238: PUSH
82239: LD_INT 2
82241: PUSH
82242: LD_INT 1
82244: PUSH
82245: EMPTY
82246: LIST
82247: LIST
82248: PUSH
82249: LD_INT 2
82251: PUSH
82252: LD_INT 2
82254: PUSH
82255: EMPTY
82256: LIST
82257: LIST
82258: PUSH
82259: LD_INT 1
82261: PUSH
82262: LD_INT 2
82264: PUSH
82265: EMPTY
82266: LIST
82267: LIST
82268: PUSH
82269: LD_INT 2
82271: NEG
82272: PUSH
82273: LD_INT 1
82275: NEG
82276: PUSH
82277: EMPTY
82278: LIST
82279: LIST
82280: PUSH
82281: LD_INT 2
82283: NEG
82284: PUSH
82285: LD_INT 2
82287: NEG
82288: PUSH
82289: EMPTY
82290: LIST
82291: LIST
82292: PUSH
82293: LD_INT 2
82295: NEG
82296: PUSH
82297: LD_INT 3
82299: NEG
82300: PUSH
82301: EMPTY
82302: LIST
82303: LIST
82304: PUSH
82305: LD_INT 3
82307: NEG
82308: PUSH
82309: LD_INT 2
82311: NEG
82312: PUSH
82313: EMPTY
82314: LIST
82315: LIST
82316: PUSH
82317: LD_INT 3
82319: NEG
82320: PUSH
82321: LD_INT 3
82323: NEG
82324: PUSH
82325: EMPTY
82326: LIST
82327: LIST
82328: PUSH
82329: EMPTY
82330: LIST
82331: LIST
82332: LIST
82333: LIST
82334: LIST
82335: LIST
82336: LIST
82337: LIST
82338: LIST
82339: LIST
82340: LIST
82341: LIST
82342: LIST
82343: LIST
82344: LIST
82345: LIST
82346: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
82347: LD_ADDR_VAR 0 14
82351: PUSH
82352: LD_INT 0
82354: PUSH
82355: LD_INT 0
82357: PUSH
82358: EMPTY
82359: LIST
82360: LIST
82361: PUSH
82362: LD_INT 0
82364: PUSH
82365: LD_INT 1
82367: NEG
82368: PUSH
82369: EMPTY
82370: LIST
82371: LIST
82372: PUSH
82373: LD_INT 1
82375: PUSH
82376: LD_INT 0
82378: PUSH
82379: EMPTY
82380: LIST
82381: LIST
82382: PUSH
82383: LD_INT 1
82385: PUSH
82386: LD_INT 1
82388: PUSH
82389: EMPTY
82390: LIST
82391: LIST
82392: PUSH
82393: LD_INT 0
82395: PUSH
82396: LD_INT 1
82398: PUSH
82399: EMPTY
82400: LIST
82401: LIST
82402: PUSH
82403: LD_INT 1
82405: NEG
82406: PUSH
82407: LD_INT 0
82409: PUSH
82410: EMPTY
82411: LIST
82412: LIST
82413: PUSH
82414: LD_INT 1
82416: NEG
82417: PUSH
82418: LD_INT 1
82420: NEG
82421: PUSH
82422: EMPTY
82423: LIST
82424: LIST
82425: PUSH
82426: LD_INT 1
82428: NEG
82429: PUSH
82430: LD_INT 2
82432: NEG
82433: PUSH
82434: EMPTY
82435: LIST
82436: LIST
82437: PUSH
82438: LD_INT 0
82440: PUSH
82441: LD_INT 2
82443: NEG
82444: PUSH
82445: EMPTY
82446: LIST
82447: LIST
82448: PUSH
82449: LD_INT 1
82451: PUSH
82452: LD_INT 1
82454: NEG
82455: PUSH
82456: EMPTY
82457: LIST
82458: LIST
82459: PUSH
82460: LD_INT 1
82462: PUSH
82463: LD_INT 2
82465: PUSH
82466: EMPTY
82467: LIST
82468: LIST
82469: PUSH
82470: LD_INT 0
82472: PUSH
82473: LD_INT 2
82475: PUSH
82476: EMPTY
82477: LIST
82478: LIST
82479: PUSH
82480: LD_INT 1
82482: NEG
82483: PUSH
82484: LD_INT 1
82486: PUSH
82487: EMPTY
82488: LIST
82489: LIST
82490: PUSH
82491: LD_INT 1
82493: NEG
82494: PUSH
82495: LD_INT 3
82497: NEG
82498: PUSH
82499: EMPTY
82500: LIST
82501: LIST
82502: PUSH
82503: LD_INT 0
82505: PUSH
82506: LD_INT 3
82508: NEG
82509: PUSH
82510: EMPTY
82511: LIST
82512: LIST
82513: PUSH
82514: LD_INT 1
82516: PUSH
82517: LD_INT 2
82519: NEG
82520: PUSH
82521: EMPTY
82522: LIST
82523: LIST
82524: PUSH
82525: EMPTY
82526: LIST
82527: LIST
82528: LIST
82529: LIST
82530: LIST
82531: LIST
82532: LIST
82533: LIST
82534: LIST
82535: LIST
82536: LIST
82537: LIST
82538: LIST
82539: LIST
82540: LIST
82541: LIST
82542: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
82543: LD_ADDR_VAR 0 15
82547: PUSH
82548: LD_INT 0
82550: PUSH
82551: LD_INT 0
82553: PUSH
82554: EMPTY
82555: LIST
82556: LIST
82557: PUSH
82558: LD_INT 0
82560: PUSH
82561: LD_INT 1
82563: NEG
82564: PUSH
82565: EMPTY
82566: LIST
82567: LIST
82568: PUSH
82569: LD_INT 1
82571: PUSH
82572: LD_INT 0
82574: PUSH
82575: EMPTY
82576: LIST
82577: LIST
82578: PUSH
82579: LD_INT 1
82581: PUSH
82582: LD_INT 1
82584: PUSH
82585: EMPTY
82586: LIST
82587: LIST
82588: PUSH
82589: LD_INT 0
82591: PUSH
82592: LD_INT 1
82594: PUSH
82595: EMPTY
82596: LIST
82597: LIST
82598: PUSH
82599: LD_INT 1
82601: NEG
82602: PUSH
82603: LD_INT 0
82605: PUSH
82606: EMPTY
82607: LIST
82608: LIST
82609: PUSH
82610: LD_INT 1
82612: NEG
82613: PUSH
82614: LD_INT 1
82616: NEG
82617: PUSH
82618: EMPTY
82619: LIST
82620: LIST
82621: PUSH
82622: LD_INT 1
82624: PUSH
82625: LD_INT 1
82627: NEG
82628: PUSH
82629: EMPTY
82630: LIST
82631: LIST
82632: PUSH
82633: LD_INT 2
82635: PUSH
82636: LD_INT 0
82638: PUSH
82639: EMPTY
82640: LIST
82641: LIST
82642: PUSH
82643: LD_INT 2
82645: PUSH
82646: LD_INT 1
82648: PUSH
82649: EMPTY
82650: LIST
82651: LIST
82652: PUSH
82653: LD_INT 1
82655: NEG
82656: PUSH
82657: LD_INT 1
82659: PUSH
82660: EMPTY
82661: LIST
82662: LIST
82663: PUSH
82664: LD_INT 2
82666: NEG
82667: PUSH
82668: LD_INT 0
82670: PUSH
82671: EMPTY
82672: LIST
82673: LIST
82674: PUSH
82675: LD_INT 2
82677: NEG
82678: PUSH
82679: LD_INT 1
82681: NEG
82682: PUSH
82683: EMPTY
82684: LIST
82685: LIST
82686: PUSH
82687: LD_INT 2
82689: PUSH
82690: LD_INT 1
82692: NEG
82693: PUSH
82694: EMPTY
82695: LIST
82696: LIST
82697: PUSH
82698: LD_INT 3
82700: PUSH
82701: LD_INT 0
82703: PUSH
82704: EMPTY
82705: LIST
82706: LIST
82707: PUSH
82708: LD_INT 3
82710: PUSH
82711: LD_INT 1
82713: PUSH
82714: EMPTY
82715: LIST
82716: LIST
82717: PUSH
82718: EMPTY
82719: LIST
82720: LIST
82721: LIST
82722: LIST
82723: LIST
82724: LIST
82725: LIST
82726: LIST
82727: LIST
82728: LIST
82729: LIST
82730: LIST
82731: LIST
82732: LIST
82733: LIST
82734: LIST
82735: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
82736: LD_ADDR_VAR 0 16
82740: PUSH
82741: LD_INT 0
82743: PUSH
82744: LD_INT 0
82746: PUSH
82747: EMPTY
82748: LIST
82749: LIST
82750: PUSH
82751: LD_INT 0
82753: PUSH
82754: LD_INT 1
82756: NEG
82757: PUSH
82758: EMPTY
82759: LIST
82760: LIST
82761: PUSH
82762: LD_INT 1
82764: PUSH
82765: LD_INT 0
82767: PUSH
82768: EMPTY
82769: LIST
82770: LIST
82771: PUSH
82772: LD_INT 1
82774: PUSH
82775: LD_INT 1
82777: PUSH
82778: EMPTY
82779: LIST
82780: LIST
82781: PUSH
82782: LD_INT 0
82784: PUSH
82785: LD_INT 1
82787: PUSH
82788: EMPTY
82789: LIST
82790: LIST
82791: PUSH
82792: LD_INT 1
82794: NEG
82795: PUSH
82796: LD_INT 0
82798: PUSH
82799: EMPTY
82800: LIST
82801: LIST
82802: PUSH
82803: LD_INT 1
82805: NEG
82806: PUSH
82807: LD_INT 1
82809: NEG
82810: PUSH
82811: EMPTY
82812: LIST
82813: LIST
82814: PUSH
82815: LD_INT 1
82817: NEG
82818: PUSH
82819: LD_INT 2
82821: NEG
82822: PUSH
82823: EMPTY
82824: LIST
82825: LIST
82826: PUSH
82827: LD_INT 2
82829: PUSH
82830: LD_INT 1
82832: PUSH
82833: EMPTY
82834: LIST
82835: LIST
82836: PUSH
82837: LD_INT 2
82839: PUSH
82840: LD_INT 2
82842: PUSH
82843: EMPTY
82844: LIST
82845: LIST
82846: PUSH
82847: LD_INT 1
82849: PUSH
82850: LD_INT 2
82852: PUSH
82853: EMPTY
82854: LIST
82855: LIST
82856: PUSH
82857: LD_INT 2
82859: NEG
82860: PUSH
82861: LD_INT 1
82863: NEG
82864: PUSH
82865: EMPTY
82866: LIST
82867: LIST
82868: PUSH
82869: LD_INT 2
82871: NEG
82872: PUSH
82873: LD_INT 2
82875: NEG
82876: PUSH
82877: EMPTY
82878: LIST
82879: LIST
82880: PUSH
82881: LD_INT 3
82883: PUSH
82884: LD_INT 2
82886: PUSH
82887: EMPTY
82888: LIST
82889: LIST
82890: PUSH
82891: LD_INT 3
82893: PUSH
82894: LD_INT 3
82896: PUSH
82897: EMPTY
82898: LIST
82899: LIST
82900: PUSH
82901: LD_INT 2
82903: PUSH
82904: LD_INT 3
82906: PUSH
82907: EMPTY
82908: LIST
82909: LIST
82910: PUSH
82911: EMPTY
82912: LIST
82913: LIST
82914: LIST
82915: LIST
82916: LIST
82917: LIST
82918: LIST
82919: LIST
82920: LIST
82921: LIST
82922: LIST
82923: LIST
82924: LIST
82925: LIST
82926: LIST
82927: LIST
82928: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82929: LD_ADDR_VAR 0 17
82933: PUSH
82934: LD_INT 0
82936: PUSH
82937: LD_INT 0
82939: PUSH
82940: EMPTY
82941: LIST
82942: LIST
82943: PUSH
82944: LD_INT 0
82946: PUSH
82947: LD_INT 1
82949: NEG
82950: PUSH
82951: EMPTY
82952: LIST
82953: LIST
82954: PUSH
82955: LD_INT 1
82957: PUSH
82958: LD_INT 0
82960: PUSH
82961: EMPTY
82962: LIST
82963: LIST
82964: PUSH
82965: LD_INT 1
82967: PUSH
82968: LD_INT 1
82970: PUSH
82971: EMPTY
82972: LIST
82973: LIST
82974: PUSH
82975: LD_INT 0
82977: PUSH
82978: LD_INT 1
82980: PUSH
82981: EMPTY
82982: LIST
82983: LIST
82984: PUSH
82985: LD_INT 1
82987: NEG
82988: PUSH
82989: LD_INT 0
82991: PUSH
82992: EMPTY
82993: LIST
82994: LIST
82995: PUSH
82996: LD_INT 1
82998: NEG
82999: PUSH
83000: LD_INT 1
83002: NEG
83003: PUSH
83004: EMPTY
83005: LIST
83006: LIST
83007: PUSH
83008: LD_INT 1
83010: NEG
83011: PUSH
83012: LD_INT 2
83014: NEG
83015: PUSH
83016: EMPTY
83017: LIST
83018: LIST
83019: PUSH
83020: LD_INT 0
83022: PUSH
83023: LD_INT 2
83025: NEG
83026: PUSH
83027: EMPTY
83028: LIST
83029: LIST
83030: PUSH
83031: LD_INT 1
83033: PUSH
83034: LD_INT 1
83036: NEG
83037: PUSH
83038: EMPTY
83039: LIST
83040: LIST
83041: PUSH
83042: LD_INT 2
83044: PUSH
83045: LD_INT 0
83047: PUSH
83048: EMPTY
83049: LIST
83050: LIST
83051: PUSH
83052: LD_INT 2
83054: PUSH
83055: LD_INT 1
83057: PUSH
83058: EMPTY
83059: LIST
83060: LIST
83061: PUSH
83062: LD_INT 2
83064: PUSH
83065: LD_INT 2
83067: PUSH
83068: EMPTY
83069: LIST
83070: LIST
83071: PUSH
83072: LD_INT 1
83074: PUSH
83075: LD_INT 2
83077: PUSH
83078: EMPTY
83079: LIST
83080: LIST
83081: PUSH
83082: LD_INT 0
83084: PUSH
83085: LD_INT 2
83087: PUSH
83088: EMPTY
83089: LIST
83090: LIST
83091: PUSH
83092: LD_INT 1
83094: NEG
83095: PUSH
83096: LD_INT 1
83098: PUSH
83099: EMPTY
83100: LIST
83101: LIST
83102: PUSH
83103: LD_INT 2
83105: NEG
83106: PUSH
83107: LD_INT 0
83109: PUSH
83110: EMPTY
83111: LIST
83112: LIST
83113: PUSH
83114: LD_INT 2
83116: NEG
83117: PUSH
83118: LD_INT 1
83120: NEG
83121: PUSH
83122: EMPTY
83123: LIST
83124: LIST
83125: PUSH
83126: LD_INT 2
83128: NEG
83129: PUSH
83130: LD_INT 2
83132: NEG
83133: PUSH
83134: EMPTY
83135: LIST
83136: LIST
83137: PUSH
83138: EMPTY
83139: LIST
83140: LIST
83141: LIST
83142: LIST
83143: LIST
83144: LIST
83145: LIST
83146: LIST
83147: LIST
83148: LIST
83149: LIST
83150: LIST
83151: LIST
83152: LIST
83153: LIST
83154: LIST
83155: LIST
83156: LIST
83157: LIST
83158: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83159: LD_ADDR_VAR 0 18
83163: PUSH
83164: LD_INT 0
83166: PUSH
83167: LD_INT 0
83169: PUSH
83170: EMPTY
83171: LIST
83172: LIST
83173: PUSH
83174: LD_INT 0
83176: PUSH
83177: LD_INT 1
83179: NEG
83180: PUSH
83181: EMPTY
83182: LIST
83183: LIST
83184: PUSH
83185: LD_INT 1
83187: PUSH
83188: LD_INT 0
83190: PUSH
83191: EMPTY
83192: LIST
83193: LIST
83194: PUSH
83195: LD_INT 1
83197: PUSH
83198: LD_INT 1
83200: PUSH
83201: EMPTY
83202: LIST
83203: LIST
83204: PUSH
83205: LD_INT 0
83207: PUSH
83208: LD_INT 1
83210: PUSH
83211: EMPTY
83212: LIST
83213: LIST
83214: PUSH
83215: LD_INT 1
83217: NEG
83218: PUSH
83219: LD_INT 0
83221: PUSH
83222: EMPTY
83223: LIST
83224: LIST
83225: PUSH
83226: LD_INT 1
83228: NEG
83229: PUSH
83230: LD_INT 1
83232: NEG
83233: PUSH
83234: EMPTY
83235: LIST
83236: LIST
83237: PUSH
83238: LD_INT 1
83240: NEG
83241: PUSH
83242: LD_INT 2
83244: NEG
83245: PUSH
83246: EMPTY
83247: LIST
83248: LIST
83249: PUSH
83250: LD_INT 0
83252: PUSH
83253: LD_INT 2
83255: NEG
83256: PUSH
83257: EMPTY
83258: LIST
83259: LIST
83260: PUSH
83261: LD_INT 1
83263: PUSH
83264: LD_INT 1
83266: NEG
83267: PUSH
83268: EMPTY
83269: LIST
83270: LIST
83271: PUSH
83272: LD_INT 2
83274: PUSH
83275: LD_INT 0
83277: PUSH
83278: EMPTY
83279: LIST
83280: LIST
83281: PUSH
83282: LD_INT 2
83284: PUSH
83285: LD_INT 1
83287: PUSH
83288: EMPTY
83289: LIST
83290: LIST
83291: PUSH
83292: LD_INT 2
83294: PUSH
83295: LD_INT 2
83297: PUSH
83298: EMPTY
83299: LIST
83300: LIST
83301: PUSH
83302: LD_INT 1
83304: PUSH
83305: LD_INT 2
83307: PUSH
83308: EMPTY
83309: LIST
83310: LIST
83311: PUSH
83312: LD_INT 0
83314: PUSH
83315: LD_INT 2
83317: PUSH
83318: EMPTY
83319: LIST
83320: LIST
83321: PUSH
83322: LD_INT 1
83324: NEG
83325: PUSH
83326: LD_INT 1
83328: PUSH
83329: EMPTY
83330: LIST
83331: LIST
83332: PUSH
83333: LD_INT 2
83335: NEG
83336: PUSH
83337: LD_INT 0
83339: PUSH
83340: EMPTY
83341: LIST
83342: LIST
83343: PUSH
83344: LD_INT 2
83346: NEG
83347: PUSH
83348: LD_INT 1
83350: NEG
83351: PUSH
83352: EMPTY
83353: LIST
83354: LIST
83355: PUSH
83356: LD_INT 2
83358: NEG
83359: PUSH
83360: LD_INT 2
83362: NEG
83363: PUSH
83364: EMPTY
83365: LIST
83366: LIST
83367: PUSH
83368: EMPTY
83369: LIST
83370: LIST
83371: LIST
83372: LIST
83373: LIST
83374: LIST
83375: LIST
83376: LIST
83377: LIST
83378: LIST
83379: LIST
83380: LIST
83381: LIST
83382: LIST
83383: LIST
83384: LIST
83385: LIST
83386: LIST
83387: LIST
83388: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83389: LD_ADDR_VAR 0 19
83393: PUSH
83394: LD_INT 0
83396: PUSH
83397: LD_INT 0
83399: PUSH
83400: EMPTY
83401: LIST
83402: LIST
83403: PUSH
83404: LD_INT 0
83406: PUSH
83407: LD_INT 1
83409: NEG
83410: PUSH
83411: EMPTY
83412: LIST
83413: LIST
83414: PUSH
83415: LD_INT 1
83417: PUSH
83418: LD_INT 0
83420: PUSH
83421: EMPTY
83422: LIST
83423: LIST
83424: PUSH
83425: LD_INT 1
83427: PUSH
83428: LD_INT 1
83430: PUSH
83431: EMPTY
83432: LIST
83433: LIST
83434: PUSH
83435: LD_INT 0
83437: PUSH
83438: LD_INT 1
83440: PUSH
83441: EMPTY
83442: LIST
83443: LIST
83444: PUSH
83445: LD_INT 1
83447: NEG
83448: PUSH
83449: LD_INT 0
83451: PUSH
83452: EMPTY
83453: LIST
83454: LIST
83455: PUSH
83456: LD_INT 1
83458: NEG
83459: PUSH
83460: LD_INT 1
83462: NEG
83463: PUSH
83464: EMPTY
83465: LIST
83466: LIST
83467: PUSH
83468: LD_INT 1
83470: NEG
83471: PUSH
83472: LD_INT 2
83474: NEG
83475: PUSH
83476: EMPTY
83477: LIST
83478: LIST
83479: PUSH
83480: LD_INT 0
83482: PUSH
83483: LD_INT 2
83485: NEG
83486: PUSH
83487: EMPTY
83488: LIST
83489: LIST
83490: PUSH
83491: LD_INT 1
83493: PUSH
83494: LD_INT 1
83496: NEG
83497: PUSH
83498: EMPTY
83499: LIST
83500: LIST
83501: PUSH
83502: LD_INT 2
83504: PUSH
83505: LD_INT 0
83507: PUSH
83508: EMPTY
83509: LIST
83510: LIST
83511: PUSH
83512: LD_INT 2
83514: PUSH
83515: LD_INT 1
83517: PUSH
83518: EMPTY
83519: LIST
83520: LIST
83521: PUSH
83522: LD_INT 2
83524: PUSH
83525: LD_INT 2
83527: PUSH
83528: EMPTY
83529: LIST
83530: LIST
83531: PUSH
83532: LD_INT 1
83534: PUSH
83535: LD_INT 2
83537: PUSH
83538: EMPTY
83539: LIST
83540: LIST
83541: PUSH
83542: LD_INT 0
83544: PUSH
83545: LD_INT 2
83547: PUSH
83548: EMPTY
83549: LIST
83550: LIST
83551: PUSH
83552: LD_INT 1
83554: NEG
83555: PUSH
83556: LD_INT 1
83558: PUSH
83559: EMPTY
83560: LIST
83561: LIST
83562: PUSH
83563: LD_INT 2
83565: NEG
83566: PUSH
83567: LD_INT 0
83569: PUSH
83570: EMPTY
83571: LIST
83572: LIST
83573: PUSH
83574: LD_INT 2
83576: NEG
83577: PUSH
83578: LD_INT 1
83580: NEG
83581: PUSH
83582: EMPTY
83583: LIST
83584: LIST
83585: PUSH
83586: LD_INT 2
83588: NEG
83589: PUSH
83590: LD_INT 2
83592: NEG
83593: PUSH
83594: EMPTY
83595: LIST
83596: LIST
83597: PUSH
83598: EMPTY
83599: LIST
83600: LIST
83601: LIST
83602: LIST
83603: LIST
83604: LIST
83605: LIST
83606: LIST
83607: LIST
83608: LIST
83609: LIST
83610: LIST
83611: LIST
83612: LIST
83613: LIST
83614: LIST
83615: LIST
83616: LIST
83617: LIST
83618: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83619: LD_ADDR_VAR 0 20
83623: PUSH
83624: LD_INT 0
83626: PUSH
83627: LD_INT 0
83629: PUSH
83630: EMPTY
83631: LIST
83632: LIST
83633: PUSH
83634: LD_INT 0
83636: PUSH
83637: LD_INT 1
83639: NEG
83640: PUSH
83641: EMPTY
83642: LIST
83643: LIST
83644: PUSH
83645: LD_INT 1
83647: PUSH
83648: LD_INT 0
83650: PUSH
83651: EMPTY
83652: LIST
83653: LIST
83654: PUSH
83655: LD_INT 1
83657: PUSH
83658: LD_INT 1
83660: PUSH
83661: EMPTY
83662: LIST
83663: LIST
83664: PUSH
83665: LD_INT 0
83667: PUSH
83668: LD_INT 1
83670: PUSH
83671: EMPTY
83672: LIST
83673: LIST
83674: PUSH
83675: LD_INT 1
83677: NEG
83678: PUSH
83679: LD_INT 0
83681: PUSH
83682: EMPTY
83683: LIST
83684: LIST
83685: PUSH
83686: LD_INT 1
83688: NEG
83689: PUSH
83690: LD_INT 1
83692: NEG
83693: PUSH
83694: EMPTY
83695: LIST
83696: LIST
83697: PUSH
83698: LD_INT 1
83700: NEG
83701: PUSH
83702: LD_INT 2
83704: NEG
83705: PUSH
83706: EMPTY
83707: LIST
83708: LIST
83709: PUSH
83710: LD_INT 0
83712: PUSH
83713: LD_INT 2
83715: NEG
83716: PUSH
83717: EMPTY
83718: LIST
83719: LIST
83720: PUSH
83721: LD_INT 1
83723: PUSH
83724: LD_INT 1
83726: NEG
83727: PUSH
83728: EMPTY
83729: LIST
83730: LIST
83731: PUSH
83732: LD_INT 2
83734: PUSH
83735: LD_INT 0
83737: PUSH
83738: EMPTY
83739: LIST
83740: LIST
83741: PUSH
83742: LD_INT 2
83744: PUSH
83745: LD_INT 1
83747: PUSH
83748: EMPTY
83749: LIST
83750: LIST
83751: PUSH
83752: LD_INT 2
83754: PUSH
83755: LD_INT 2
83757: PUSH
83758: EMPTY
83759: LIST
83760: LIST
83761: PUSH
83762: LD_INT 1
83764: PUSH
83765: LD_INT 2
83767: PUSH
83768: EMPTY
83769: LIST
83770: LIST
83771: PUSH
83772: LD_INT 0
83774: PUSH
83775: LD_INT 2
83777: PUSH
83778: EMPTY
83779: LIST
83780: LIST
83781: PUSH
83782: LD_INT 1
83784: NEG
83785: PUSH
83786: LD_INT 1
83788: PUSH
83789: EMPTY
83790: LIST
83791: LIST
83792: PUSH
83793: LD_INT 2
83795: NEG
83796: PUSH
83797: LD_INT 0
83799: PUSH
83800: EMPTY
83801: LIST
83802: LIST
83803: PUSH
83804: LD_INT 2
83806: NEG
83807: PUSH
83808: LD_INT 1
83810: NEG
83811: PUSH
83812: EMPTY
83813: LIST
83814: LIST
83815: PUSH
83816: LD_INT 2
83818: NEG
83819: PUSH
83820: LD_INT 2
83822: NEG
83823: PUSH
83824: EMPTY
83825: LIST
83826: LIST
83827: PUSH
83828: EMPTY
83829: LIST
83830: LIST
83831: LIST
83832: LIST
83833: LIST
83834: LIST
83835: LIST
83836: LIST
83837: LIST
83838: LIST
83839: LIST
83840: LIST
83841: LIST
83842: LIST
83843: LIST
83844: LIST
83845: LIST
83846: LIST
83847: LIST
83848: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83849: LD_ADDR_VAR 0 21
83853: PUSH
83854: LD_INT 0
83856: PUSH
83857: LD_INT 0
83859: PUSH
83860: EMPTY
83861: LIST
83862: LIST
83863: PUSH
83864: LD_INT 0
83866: PUSH
83867: LD_INT 1
83869: NEG
83870: PUSH
83871: EMPTY
83872: LIST
83873: LIST
83874: PUSH
83875: LD_INT 1
83877: PUSH
83878: LD_INT 0
83880: PUSH
83881: EMPTY
83882: LIST
83883: LIST
83884: PUSH
83885: LD_INT 1
83887: PUSH
83888: LD_INT 1
83890: PUSH
83891: EMPTY
83892: LIST
83893: LIST
83894: PUSH
83895: LD_INT 0
83897: PUSH
83898: LD_INT 1
83900: PUSH
83901: EMPTY
83902: LIST
83903: LIST
83904: PUSH
83905: LD_INT 1
83907: NEG
83908: PUSH
83909: LD_INT 0
83911: PUSH
83912: EMPTY
83913: LIST
83914: LIST
83915: PUSH
83916: LD_INT 1
83918: NEG
83919: PUSH
83920: LD_INT 1
83922: NEG
83923: PUSH
83924: EMPTY
83925: LIST
83926: LIST
83927: PUSH
83928: LD_INT 1
83930: NEG
83931: PUSH
83932: LD_INT 2
83934: NEG
83935: PUSH
83936: EMPTY
83937: LIST
83938: LIST
83939: PUSH
83940: LD_INT 0
83942: PUSH
83943: LD_INT 2
83945: NEG
83946: PUSH
83947: EMPTY
83948: LIST
83949: LIST
83950: PUSH
83951: LD_INT 1
83953: PUSH
83954: LD_INT 1
83956: NEG
83957: PUSH
83958: EMPTY
83959: LIST
83960: LIST
83961: PUSH
83962: LD_INT 2
83964: PUSH
83965: LD_INT 0
83967: PUSH
83968: EMPTY
83969: LIST
83970: LIST
83971: PUSH
83972: LD_INT 2
83974: PUSH
83975: LD_INT 1
83977: PUSH
83978: EMPTY
83979: LIST
83980: LIST
83981: PUSH
83982: LD_INT 2
83984: PUSH
83985: LD_INT 2
83987: PUSH
83988: EMPTY
83989: LIST
83990: LIST
83991: PUSH
83992: LD_INT 1
83994: PUSH
83995: LD_INT 2
83997: PUSH
83998: EMPTY
83999: LIST
84000: LIST
84001: PUSH
84002: LD_INT 0
84004: PUSH
84005: LD_INT 2
84007: PUSH
84008: EMPTY
84009: LIST
84010: LIST
84011: PUSH
84012: LD_INT 1
84014: NEG
84015: PUSH
84016: LD_INT 1
84018: PUSH
84019: EMPTY
84020: LIST
84021: LIST
84022: PUSH
84023: LD_INT 2
84025: NEG
84026: PUSH
84027: LD_INT 0
84029: PUSH
84030: EMPTY
84031: LIST
84032: LIST
84033: PUSH
84034: LD_INT 2
84036: NEG
84037: PUSH
84038: LD_INT 1
84040: NEG
84041: PUSH
84042: EMPTY
84043: LIST
84044: LIST
84045: PUSH
84046: LD_INT 2
84048: NEG
84049: PUSH
84050: LD_INT 2
84052: NEG
84053: PUSH
84054: EMPTY
84055: LIST
84056: LIST
84057: PUSH
84058: EMPTY
84059: LIST
84060: LIST
84061: LIST
84062: LIST
84063: LIST
84064: LIST
84065: LIST
84066: LIST
84067: LIST
84068: LIST
84069: LIST
84070: LIST
84071: LIST
84072: LIST
84073: LIST
84074: LIST
84075: LIST
84076: LIST
84077: LIST
84078: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84079: LD_ADDR_VAR 0 22
84083: PUSH
84084: LD_INT 0
84086: PUSH
84087: LD_INT 0
84089: PUSH
84090: EMPTY
84091: LIST
84092: LIST
84093: PUSH
84094: LD_INT 0
84096: PUSH
84097: LD_INT 1
84099: NEG
84100: PUSH
84101: EMPTY
84102: LIST
84103: LIST
84104: PUSH
84105: LD_INT 1
84107: PUSH
84108: LD_INT 0
84110: PUSH
84111: EMPTY
84112: LIST
84113: LIST
84114: PUSH
84115: LD_INT 1
84117: PUSH
84118: LD_INT 1
84120: PUSH
84121: EMPTY
84122: LIST
84123: LIST
84124: PUSH
84125: LD_INT 0
84127: PUSH
84128: LD_INT 1
84130: PUSH
84131: EMPTY
84132: LIST
84133: LIST
84134: PUSH
84135: LD_INT 1
84137: NEG
84138: PUSH
84139: LD_INT 0
84141: PUSH
84142: EMPTY
84143: LIST
84144: LIST
84145: PUSH
84146: LD_INT 1
84148: NEG
84149: PUSH
84150: LD_INT 1
84152: NEG
84153: PUSH
84154: EMPTY
84155: LIST
84156: LIST
84157: PUSH
84158: LD_INT 1
84160: NEG
84161: PUSH
84162: LD_INT 2
84164: NEG
84165: PUSH
84166: EMPTY
84167: LIST
84168: LIST
84169: PUSH
84170: LD_INT 0
84172: PUSH
84173: LD_INT 2
84175: NEG
84176: PUSH
84177: EMPTY
84178: LIST
84179: LIST
84180: PUSH
84181: LD_INT 1
84183: PUSH
84184: LD_INT 1
84186: NEG
84187: PUSH
84188: EMPTY
84189: LIST
84190: LIST
84191: PUSH
84192: LD_INT 2
84194: PUSH
84195: LD_INT 0
84197: PUSH
84198: EMPTY
84199: LIST
84200: LIST
84201: PUSH
84202: LD_INT 2
84204: PUSH
84205: LD_INT 1
84207: PUSH
84208: EMPTY
84209: LIST
84210: LIST
84211: PUSH
84212: LD_INT 2
84214: PUSH
84215: LD_INT 2
84217: PUSH
84218: EMPTY
84219: LIST
84220: LIST
84221: PUSH
84222: LD_INT 1
84224: PUSH
84225: LD_INT 2
84227: PUSH
84228: EMPTY
84229: LIST
84230: LIST
84231: PUSH
84232: LD_INT 0
84234: PUSH
84235: LD_INT 2
84237: PUSH
84238: EMPTY
84239: LIST
84240: LIST
84241: PUSH
84242: LD_INT 1
84244: NEG
84245: PUSH
84246: LD_INT 1
84248: PUSH
84249: EMPTY
84250: LIST
84251: LIST
84252: PUSH
84253: LD_INT 2
84255: NEG
84256: PUSH
84257: LD_INT 0
84259: PUSH
84260: EMPTY
84261: LIST
84262: LIST
84263: PUSH
84264: LD_INT 2
84266: NEG
84267: PUSH
84268: LD_INT 1
84270: NEG
84271: PUSH
84272: EMPTY
84273: LIST
84274: LIST
84275: PUSH
84276: LD_INT 2
84278: NEG
84279: PUSH
84280: LD_INT 2
84282: NEG
84283: PUSH
84284: EMPTY
84285: LIST
84286: LIST
84287: PUSH
84288: EMPTY
84289: LIST
84290: LIST
84291: LIST
84292: LIST
84293: LIST
84294: LIST
84295: LIST
84296: LIST
84297: LIST
84298: LIST
84299: LIST
84300: LIST
84301: LIST
84302: LIST
84303: LIST
84304: LIST
84305: LIST
84306: LIST
84307: LIST
84308: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
84309: LD_ADDR_VAR 0 23
84313: PUSH
84314: LD_INT 0
84316: PUSH
84317: LD_INT 0
84319: PUSH
84320: EMPTY
84321: LIST
84322: LIST
84323: PUSH
84324: LD_INT 0
84326: PUSH
84327: LD_INT 1
84329: NEG
84330: PUSH
84331: EMPTY
84332: LIST
84333: LIST
84334: PUSH
84335: LD_INT 1
84337: PUSH
84338: LD_INT 0
84340: PUSH
84341: EMPTY
84342: LIST
84343: LIST
84344: PUSH
84345: LD_INT 1
84347: PUSH
84348: LD_INT 1
84350: PUSH
84351: EMPTY
84352: LIST
84353: LIST
84354: PUSH
84355: LD_INT 0
84357: PUSH
84358: LD_INT 1
84360: PUSH
84361: EMPTY
84362: LIST
84363: LIST
84364: PUSH
84365: LD_INT 1
84367: NEG
84368: PUSH
84369: LD_INT 0
84371: PUSH
84372: EMPTY
84373: LIST
84374: LIST
84375: PUSH
84376: LD_INT 1
84378: NEG
84379: PUSH
84380: LD_INT 1
84382: NEG
84383: PUSH
84384: EMPTY
84385: LIST
84386: LIST
84387: PUSH
84388: LD_INT 1
84390: NEG
84391: PUSH
84392: LD_INT 2
84394: NEG
84395: PUSH
84396: EMPTY
84397: LIST
84398: LIST
84399: PUSH
84400: LD_INT 0
84402: PUSH
84403: LD_INT 2
84405: NEG
84406: PUSH
84407: EMPTY
84408: LIST
84409: LIST
84410: PUSH
84411: LD_INT 1
84413: PUSH
84414: LD_INT 1
84416: NEG
84417: PUSH
84418: EMPTY
84419: LIST
84420: LIST
84421: PUSH
84422: LD_INT 2
84424: PUSH
84425: LD_INT 0
84427: PUSH
84428: EMPTY
84429: LIST
84430: LIST
84431: PUSH
84432: LD_INT 2
84434: PUSH
84435: LD_INT 1
84437: PUSH
84438: EMPTY
84439: LIST
84440: LIST
84441: PUSH
84442: LD_INT 2
84444: PUSH
84445: LD_INT 2
84447: PUSH
84448: EMPTY
84449: LIST
84450: LIST
84451: PUSH
84452: LD_INT 1
84454: PUSH
84455: LD_INT 2
84457: PUSH
84458: EMPTY
84459: LIST
84460: LIST
84461: PUSH
84462: LD_INT 0
84464: PUSH
84465: LD_INT 2
84467: PUSH
84468: EMPTY
84469: LIST
84470: LIST
84471: PUSH
84472: LD_INT 1
84474: NEG
84475: PUSH
84476: LD_INT 1
84478: PUSH
84479: EMPTY
84480: LIST
84481: LIST
84482: PUSH
84483: LD_INT 2
84485: NEG
84486: PUSH
84487: LD_INT 0
84489: PUSH
84490: EMPTY
84491: LIST
84492: LIST
84493: PUSH
84494: LD_INT 2
84496: NEG
84497: PUSH
84498: LD_INT 1
84500: NEG
84501: PUSH
84502: EMPTY
84503: LIST
84504: LIST
84505: PUSH
84506: LD_INT 2
84508: NEG
84509: PUSH
84510: LD_INT 2
84512: NEG
84513: PUSH
84514: EMPTY
84515: LIST
84516: LIST
84517: PUSH
84518: LD_INT 2
84520: NEG
84521: PUSH
84522: LD_INT 3
84524: NEG
84525: PUSH
84526: EMPTY
84527: LIST
84528: LIST
84529: PUSH
84530: LD_INT 1
84532: NEG
84533: PUSH
84534: LD_INT 3
84536: NEG
84537: PUSH
84538: EMPTY
84539: LIST
84540: LIST
84541: PUSH
84542: LD_INT 1
84544: PUSH
84545: LD_INT 2
84547: NEG
84548: PUSH
84549: EMPTY
84550: LIST
84551: LIST
84552: PUSH
84553: LD_INT 2
84555: PUSH
84556: LD_INT 1
84558: NEG
84559: PUSH
84560: EMPTY
84561: LIST
84562: LIST
84563: PUSH
84564: EMPTY
84565: LIST
84566: LIST
84567: LIST
84568: LIST
84569: LIST
84570: LIST
84571: LIST
84572: LIST
84573: LIST
84574: LIST
84575: LIST
84576: LIST
84577: LIST
84578: LIST
84579: LIST
84580: LIST
84581: LIST
84582: LIST
84583: LIST
84584: LIST
84585: LIST
84586: LIST
84587: LIST
84588: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
84589: LD_ADDR_VAR 0 24
84593: PUSH
84594: LD_INT 0
84596: PUSH
84597: LD_INT 0
84599: PUSH
84600: EMPTY
84601: LIST
84602: LIST
84603: PUSH
84604: LD_INT 0
84606: PUSH
84607: LD_INT 1
84609: NEG
84610: PUSH
84611: EMPTY
84612: LIST
84613: LIST
84614: PUSH
84615: LD_INT 1
84617: PUSH
84618: LD_INT 0
84620: PUSH
84621: EMPTY
84622: LIST
84623: LIST
84624: PUSH
84625: LD_INT 1
84627: PUSH
84628: LD_INT 1
84630: PUSH
84631: EMPTY
84632: LIST
84633: LIST
84634: PUSH
84635: LD_INT 0
84637: PUSH
84638: LD_INT 1
84640: PUSH
84641: EMPTY
84642: LIST
84643: LIST
84644: PUSH
84645: LD_INT 1
84647: NEG
84648: PUSH
84649: LD_INT 0
84651: PUSH
84652: EMPTY
84653: LIST
84654: LIST
84655: PUSH
84656: LD_INT 1
84658: NEG
84659: PUSH
84660: LD_INT 1
84662: NEG
84663: PUSH
84664: EMPTY
84665: LIST
84666: LIST
84667: PUSH
84668: LD_INT 1
84670: NEG
84671: PUSH
84672: LD_INT 2
84674: NEG
84675: PUSH
84676: EMPTY
84677: LIST
84678: LIST
84679: PUSH
84680: LD_INT 0
84682: PUSH
84683: LD_INT 2
84685: NEG
84686: PUSH
84687: EMPTY
84688: LIST
84689: LIST
84690: PUSH
84691: LD_INT 1
84693: PUSH
84694: LD_INT 1
84696: NEG
84697: PUSH
84698: EMPTY
84699: LIST
84700: LIST
84701: PUSH
84702: LD_INT 2
84704: PUSH
84705: LD_INT 0
84707: PUSH
84708: EMPTY
84709: LIST
84710: LIST
84711: PUSH
84712: LD_INT 2
84714: PUSH
84715: LD_INT 1
84717: PUSH
84718: EMPTY
84719: LIST
84720: LIST
84721: PUSH
84722: LD_INT 2
84724: PUSH
84725: LD_INT 2
84727: PUSH
84728: EMPTY
84729: LIST
84730: LIST
84731: PUSH
84732: LD_INT 1
84734: PUSH
84735: LD_INT 2
84737: PUSH
84738: EMPTY
84739: LIST
84740: LIST
84741: PUSH
84742: LD_INT 0
84744: PUSH
84745: LD_INT 2
84747: PUSH
84748: EMPTY
84749: LIST
84750: LIST
84751: PUSH
84752: LD_INT 1
84754: NEG
84755: PUSH
84756: LD_INT 1
84758: PUSH
84759: EMPTY
84760: LIST
84761: LIST
84762: PUSH
84763: LD_INT 2
84765: NEG
84766: PUSH
84767: LD_INT 0
84769: PUSH
84770: EMPTY
84771: LIST
84772: LIST
84773: PUSH
84774: LD_INT 2
84776: NEG
84777: PUSH
84778: LD_INT 1
84780: NEG
84781: PUSH
84782: EMPTY
84783: LIST
84784: LIST
84785: PUSH
84786: LD_INT 2
84788: NEG
84789: PUSH
84790: LD_INT 2
84792: NEG
84793: PUSH
84794: EMPTY
84795: LIST
84796: LIST
84797: PUSH
84798: LD_INT 1
84800: PUSH
84801: LD_INT 2
84803: NEG
84804: PUSH
84805: EMPTY
84806: LIST
84807: LIST
84808: PUSH
84809: LD_INT 2
84811: PUSH
84812: LD_INT 1
84814: NEG
84815: PUSH
84816: EMPTY
84817: LIST
84818: LIST
84819: PUSH
84820: LD_INT 3
84822: PUSH
84823: LD_INT 1
84825: PUSH
84826: EMPTY
84827: LIST
84828: LIST
84829: PUSH
84830: LD_INT 3
84832: PUSH
84833: LD_INT 2
84835: PUSH
84836: EMPTY
84837: LIST
84838: LIST
84839: PUSH
84840: EMPTY
84841: LIST
84842: LIST
84843: LIST
84844: LIST
84845: LIST
84846: LIST
84847: LIST
84848: LIST
84849: LIST
84850: LIST
84851: LIST
84852: LIST
84853: LIST
84854: LIST
84855: LIST
84856: LIST
84857: LIST
84858: LIST
84859: LIST
84860: LIST
84861: LIST
84862: LIST
84863: LIST
84864: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
84865: LD_ADDR_VAR 0 25
84869: PUSH
84870: LD_INT 0
84872: PUSH
84873: LD_INT 0
84875: PUSH
84876: EMPTY
84877: LIST
84878: LIST
84879: PUSH
84880: LD_INT 0
84882: PUSH
84883: LD_INT 1
84885: NEG
84886: PUSH
84887: EMPTY
84888: LIST
84889: LIST
84890: PUSH
84891: LD_INT 1
84893: PUSH
84894: LD_INT 0
84896: PUSH
84897: EMPTY
84898: LIST
84899: LIST
84900: PUSH
84901: LD_INT 1
84903: PUSH
84904: LD_INT 1
84906: PUSH
84907: EMPTY
84908: LIST
84909: LIST
84910: PUSH
84911: LD_INT 0
84913: PUSH
84914: LD_INT 1
84916: PUSH
84917: EMPTY
84918: LIST
84919: LIST
84920: PUSH
84921: LD_INT 1
84923: NEG
84924: PUSH
84925: LD_INT 0
84927: PUSH
84928: EMPTY
84929: LIST
84930: LIST
84931: PUSH
84932: LD_INT 1
84934: NEG
84935: PUSH
84936: LD_INT 1
84938: NEG
84939: PUSH
84940: EMPTY
84941: LIST
84942: LIST
84943: PUSH
84944: LD_INT 1
84946: NEG
84947: PUSH
84948: LD_INT 2
84950: NEG
84951: PUSH
84952: EMPTY
84953: LIST
84954: LIST
84955: PUSH
84956: LD_INT 0
84958: PUSH
84959: LD_INT 2
84961: NEG
84962: PUSH
84963: EMPTY
84964: LIST
84965: LIST
84966: PUSH
84967: LD_INT 1
84969: PUSH
84970: LD_INT 1
84972: NEG
84973: PUSH
84974: EMPTY
84975: LIST
84976: LIST
84977: PUSH
84978: LD_INT 2
84980: PUSH
84981: LD_INT 0
84983: PUSH
84984: EMPTY
84985: LIST
84986: LIST
84987: PUSH
84988: LD_INT 2
84990: PUSH
84991: LD_INT 1
84993: PUSH
84994: EMPTY
84995: LIST
84996: LIST
84997: PUSH
84998: LD_INT 2
85000: PUSH
85001: LD_INT 2
85003: PUSH
85004: EMPTY
85005: LIST
85006: LIST
85007: PUSH
85008: LD_INT 1
85010: PUSH
85011: LD_INT 2
85013: PUSH
85014: EMPTY
85015: LIST
85016: LIST
85017: PUSH
85018: LD_INT 0
85020: PUSH
85021: LD_INT 2
85023: PUSH
85024: EMPTY
85025: LIST
85026: LIST
85027: PUSH
85028: LD_INT 1
85030: NEG
85031: PUSH
85032: LD_INT 1
85034: PUSH
85035: EMPTY
85036: LIST
85037: LIST
85038: PUSH
85039: LD_INT 2
85041: NEG
85042: PUSH
85043: LD_INT 0
85045: PUSH
85046: EMPTY
85047: LIST
85048: LIST
85049: PUSH
85050: LD_INT 2
85052: NEG
85053: PUSH
85054: LD_INT 1
85056: NEG
85057: PUSH
85058: EMPTY
85059: LIST
85060: LIST
85061: PUSH
85062: LD_INT 2
85064: NEG
85065: PUSH
85066: LD_INT 2
85068: NEG
85069: PUSH
85070: EMPTY
85071: LIST
85072: LIST
85073: PUSH
85074: LD_INT 3
85076: PUSH
85077: LD_INT 1
85079: PUSH
85080: EMPTY
85081: LIST
85082: LIST
85083: PUSH
85084: LD_INT 3
85086: PUSH
85087: LD_INT 2
85089: PUSH
85090: EMPTY
85091: LIST
85092: LIST
85093: PUSH
85094: LD_INT 2
85096: PUSH
85097: LD_INT 3
85099: PUSH
85100: EMPTY
85101: LIST
85102: LIST
85103: PUSH
85104: LD_INT 1
85106: PUSH
85107: LD_INT 3
85109: PUSH
85110: EMPTY
85111: LIST
85112: LIST
85113: PUSH
85114: EMPTY
85115: LIST
85116: LIST
85117: LIST
85118: LIST
85119: LIST
85120: LIST
85121: LIST
85122: LIST
85123: LIST
85124: LIST
85125: LIST
85126: LIST
85127: LIST
85128: LIST
85129: LIST
85130: LIST
85131: LIST
85132: LIST
85133: LIST
85134: LIST
85135: LIST
85136: LIST
85137: LIST
85138: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
85139: LD_ADDR_VAR 0 26
85143: PUSH
85144: LD_INT 0
85146: PUSH
85147: LD_INT 0
85149: PUSH
85150: EMPTY
85151: LIST
85152: LIST
85153: PUSH
85154: LD_INT 0
85156: PUSH
85157: LD_INT 1
85159: NEG
85160: PUSH
85161: EMPTY
85162: LIST
85163: LIST
85164: PUSH
85165: LD_INT 1
85167: PUSH
85168: LD_INT 0
85170: PUSH
85171: EMPTY
85172: LIST
85173: LIST
85174: PUSH
85175: LD_INT 1
85177: PUSH
85178: LD_INT 1
85180: PUSH
85181: EMPTY
85182: LIST
85183: LIST
85184: PUSH
85185: LD_INT 0
85187: PUSH
85188: LD_INT 1
85190: PUSH
85191: EMPTY
85192: LIST
85193: LIST
85194: PUSH
85195: LD_INT 1
85197: NEG
85198: PUSH
85199: LD_INT 0
85201: PUSH
85202: EMPTY
85203: LIST
85204: LIST
85205: PUSH
85206: LD_INT 1
85208: NEG
85209: PUSH
85210: LD_INT 1
85212: NEG
85213: PUSH
85214: EMPTY
85215: LIST
85216: LIST
85217: PUSH
85218: LD_INT 1
85220: NEG
85221: PUSH
85222: LD_INT 2
85224: NEG
85225: PUSH
85226: EMPTY
85227: LIST
85228: LIST
85229: PUSH
85230: LD_INT 0
85232: PUSH
85233: LD_INT 2
85235: NEG
85236: PUSH
85237: EMPTY
85238: LIST
85239: LIST
85240: PUSH
85241: LD_INT 1
85243: PUSH
85244: LD_INT 1
85246: NEG
85247: PUSH
85248: EMPTY
85249: LIST
85250: LIST
85251: PUSH
85252: LD_INT 2
85254: PUSH
85255: LD_INT 0
85257: PUSH
85258: EMPTY
85259: LIST
85260: LIST
85261: PUSH
85262: LD_INT 2
85264: PUSH
85265: LD_INT 1
85267: PUSH
85268: EMPTY
85269: LIST
85270: LIST
85271: PUSH
85272: LD_INT 2
85274: PUSH
85275: LD_INT 2
85277: PUSH
85278: EMPTY
85279: LIST
85280: LIST
85281: PUSH
85282: LD_INT 1
85284: PUSH
85285: LD_INT 2
85287: PUSH
85288: EMPTY
85289: LIST
85290: LIST
85291: PUSH
85292: LD_INT 0
85294: PUSH
85295: LD_INT 2
85297: PUSH
85298: EMPTY
85299: LIST
85300: LIST
85301: PUSH
85302: LD_INT 1
85304: NEG
85305: PUSH
85306: LD_INT 1
85308: PUSH
85309: EMPTY
85310: LIST
85311: LIST
85312: PUSH
85313: LD_INT 2
85315: NEG
85316: PUSH
85317: LD_INT 0
85319: PUSH
85320: EMPTY
85321: LIST
85322: LIST
85323: PUSH
85324: LD_INT 2
85326: NEG
85327: PUSH
85328: LD_INT 1
85330: NEG
85331: PUSH
85332: EMPTY
85333: LIST
85334: LIST
85335: PUSH
85336: LD_INT 2
85338: NEG
85339: PUSH
85340: LD_INT 2
85342: NEG
85343: PUSH
85344: EMPTY
85345: LIST
85346: LIST
85347: PUSH
85348: LD_INT 2
85350: PUSH
85351: LD_INT 3
85353: PUSH
85354: EMPTY
85355: LIST
85356: LIST
85357: PUSH
85358: LD_INT 1
85360: PUSH
85361: LD_INT 3
85363: PUSH
85364: EMPTY
85365: LIST
85366: LIST
85367: PUSH
85368: LD_INT 1
85370: NEG
85371: PUSH
85372: LD_INT 2
85374: PUSH
85375: EMPTY
85376: LIST
85377: LIST
85378: PUSH
85379: LD_INT 2
85381: NEG
85382: PUSH
85383: LD_INT 1
85385: PUSH
85386: EMPTY
85387: LIST
85388: LIST
85389: PUSH
85390: EMPTY
85391: LIST
85392: LIST
85393: LIST
85394: LIST
85395: LIST
85396: LIST
85397: LIST
85398: LIST
85399: LIST
85400: LIST
85401: LIST
85402: LIST
85403: LIST
85404: LIST
85405: LIST
85406: LIST
85407: LIST
85408: LIST
85409: LIST
85410: LIST
85411: LIST
85412: LIST
85413: LIST
85414: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
85415: LD_ADDR_VAR 0 27
85419: PUSH
85420: LD_INT 0
85422: PUSH
85423: LD_INT 0
85425: PUSH
85426: EMPTY
85427: LIST
85428: LIST
85429: PUSH
85430: LD_INT 0
85432: PUSH
85433: LD_INT 1
85435: NEG
85436: PUSH
85437: EMPTY
85438: LIST
85439: LIST
85440: PUSH
85441: LD_INT 1
85443: PUSH
85444: LD_INT 0
85446: PUSH
85447: EMPTY
85448: LIST
85449: LIST
85450: PUSH
85451: LD_INT 1
85453: PUSH
85454: LD_INT 1
85456: PUSH
85457: EMPTY
85458: LIST
85459: LIST
85460: PUSH
85461: LD_INT 0
85463: PUSH
85464: LD_INT 1
85466: PUSH
85467: EMPTY
85468: LIST
85469: LIST
85470: PUSH
85471: LD_INT 1
85473: NEG
85474: PUSH
85475: LD_INT 0
85477: PUSH
85478: EMPTY
85479: LIST
85480: LIST
85481: PUSH
85482: LD_INT 1
85484: NEG
85485: PUSH
85486: LD_INT 1
85488: NEG
85489: PUSH
85490: EMPTY
85491: LIST
85492: LIST
85493: PUSH
85494: LD_INT 1
85496: NEG
85497: PUSH
85498: LD_INT 2
85500: NEG
85501: PUSH
85502: EMPTY
85503: LIST
85504: LIST
85505: PUSH
85506: LD_INT 0
85508: PUSH
85509: LD_INT 2
85511: NEG
85512: PUSH
85513: EMPTY
85514: LIST
85515: LIST
85516: PUSH
85517: LD_INT 1
85519: PUSH
85520: LD_INT 1
85522: NEG
85523: PUSH
85524: EMPTY
85525: LIST
85526: LIST
85527: PUSH
85528: LD_INT 2
85530: PUSH
85531: LD_INT 0
85533: PUSH
85534: EMPTY
85535: LIST
85536: LIST
85537: PUSH
85538: LD_INT 2
85540: PUSH
85541: LD_INT 1
85543: PUSH
85544: EMPTY
85545: LIST
85546: LIST
85547: PUSH
85548: LD_INT 2
85550: PUSH
85551: LD_INT 2
85553: PUSH
85554: EMPTY
85555: LIST
85556: LIST
85557: PUSH
85558: LD_INT 1
85560: PUSH
85561: LD_INT 2
85563: PUSH
85564: EMPTY
85565: LIST
85566: LIST
85567: PUSH
85568: LD_INT 0
85570: PUSH
85571: LD_INT 2
85573: PUSH
85574: EMPTY
85575: LIST
85576: LIST
85577: PUSH
85578: LD_INT 1
85580: NEG
85581: PUSH
85582: LD_INT 1
85584: PUSH
85585: EMPTY
85586: LIST
85587: LIST
85588: PUSH
85589: LD_INT 2
85591: NEG
85592: PUSH
85593: LD_INT 0
85595: PUSH
85596: EMPTY
85597: LIST
85598: LIST
85599: PUSH
85600: LD_INT 2
85602: NEG
85603: PUSH
85604: LD_INT 1
85606: NEG
85607: PUSH
85608: EMPTY
85609: LIST
85610: LIST
85611: PUSH
85612: LD_INT 2
85614: NEG
85615: PUSH
85616: LD_INT 2
85618: NEG
85619: PUSH
85620: EMPTY
85621: LIST
85622: LIST
85623: PUSH
85624: LD_INT 1
85626: NEG
85627: PUSH
85628: LD_INT 2
85630: PUSH
85631: EMPTY
85632: LIST
85633: LIST
85634: PUSH
85635: LD_INT 2
85637: NEG
85638: PUSH
85639: LD_INT 1
85641: PUSH
85642: EMPTY
85643: LIST
85644: LIST
85645: PUSH
85646: LD_INT 3
85648: NEG
85649: PUSH
85650: LD_INT 1
85652: NEG
85653: PUSH
85654: EMPTY
85655: LIST
85656: LIST
85657: PUSH
85658: LD_INT 3
85660: NEG
85661: PUSH
85662: LD_INT 2
85664: NEG
85665: PUSH
85666: EMPTY
85667: LIST
85668: LIST
85669: PUSH
85670: EMPTY
85671: LIST
85672: LIST
85673: LIST
85674: LIST
85675: LIST
85676: LIST
85677: LIST
85678: LIST
85679: LIST
85680: LIST
85681: LIST
85682: LIST
85683: LIST
85684: LIST
85685: LIST
85686: LIST
85687: LIST
85688: LIST
85689: LIST
85690: LIST
85691: LIST
85692: LIST
85693: LIST
85694: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
85695: LD_ADDR_VAR 0 28
85699: PUSH
85700: LD_INT 0
85702: PUSH
85703: LD_INT 0
85705: PUSH
85706: EMPTY
85707: LIST
85708: LIST
85709: PUSH
85710: LD_INT 0
85712: PUSH
85713: LD_INT 1
85715: NEG
85716: PUSH
85717: EMPTY
85718: LIST
85719: LIST
85720: PUSH
85721: LD_INT 1
85723: PUSH
85724: LD_INT 0
85726: PUSH
85727: EMPTY
85728: LIST
85729: LIST
85730: PUSH
85731: LD_INT 1
85733: PUSH
85734: LD_INT 1
85736: PUSH
85737: EMPTY
85738: LIST
85739: LIST
85740: PUSH
85741: LD_INT 0
85743: PUSH
85744: LD_INT 1
85746: PUSH
85747: EMPTY
85748: LIST
85749: LIST
85750: PUSH
85751: LD_INT 1
85753: NEG
85754: PUSH
85755: LD_INT 0
85757: PUSH
85758: EMPTY
85759: LIST
85760: LIST
85761: PUSH
85762: LD_INT 1
85764: NEG
85765: PUSH
85766: LD_INT 1
85768: NEG
85769: PUSH
85770: EMPTY
85771: LIST
85772: LIST
85773: PUSH
85774: LD_INT 1
85776: NEG
85777: PUSH
85778: LD_INT 2
85780: NEG
85781: PUSH
85782: EMPTY
85783: LIST
85784: LIST
85785: PUSH
85786: LD_INT 0
85788: PUSH
85789: LD_INT 2
85791: NEG
85792: PUSH
85793: EMPTY
85794: LIST
85795: LIST
85796: PUSH
85797: LD_INT 1
85799: PUSH
85800: LD_INT 1
85802: NEG
85803: PUSH
85804: EMPTY
85805: LIST
85806: LIST
85807: PUSH
85808: LD_INT 2
85810: PUSH
85811: LD_INT 0
85813: PUSH
85814: EMPTY
85815: LIST
85816: LIST
85817: PUSH
85818: LD_INT 2
85820: PUSH
85821: LD_INT 1
85823: PUSH
85824: EMPTY
85825: LIST
85826: LIST
85827: PUSH
85828: LD_INT 2
85830: PUSH
85831: LD_INT 2
85833: PUSH
85834: EMPTY
85835: LIST
85836: LIST
85837: PUSH
85838: LD_INT 1
85840: PUSH
85841: LD_INT 2
85843: PUSH
85844: EMPTY
85845: LIST
85846: LIST
85847: PUSH
85848: LD_INT 0
85850: PUSH
85851: LD_INT 2
85853: PUSH
85854: EMPTY
85855: LIST
85856: LIST
85857: PUSH
85858: LD_INT 1
85860: NEG
85861: PUSH
85862: LD_INT 1
85864: PUSH
85865: EMPTY
85866: LIST
85867: LIST
85868: PUSH
85869: LD_INT 2
85871: NEG
85872: PUSH
85873: LD_INT 0
85875: PUSH
85876: EMPTY
85877: LIST
85878: LIST
85879: PUSH
85880: LD_INT 2
85882: NEG
85883: PUSH
85884: LD_INT 1
85886: NEG
85887: PUSH
85888: EMPTY
85889: LIST
85890: LIST
85891: PUSH
85892: LD_INT 2
85894: NEG
85895: PUSH
85896: LD_INT 2
85898: NEG
85899: PUSH
85900: EMPTY
85901: LIST
85902: LIST
85903: PUSH
85904: LD_INT 2
85906: NEG
85907: PUSH
85908: LD_INT 3
85910: NEG
85911: PUSH
85912: EMPTY
85913: LIST
85914: LIST
85915: PUSH
85916: LD_INT 1
85918: NEG
85919: PUSH
85920: LD_INT 3
85922: NEG
85923: PUSH
85924: EMPTY
85925: LIST
85926: LIST
85927: PUSH
85928: LD_INT 3
85930: NEG
85931: PUSH
85932: LD_INT 1
85934: NEG
85935: PUSH
85936: EMPTY
85937: LIST
85938: LIST
85939: PUSH
85940: LD_INT 3
85942: NEG
85943: PUSH
85944: LD_INT 2
85946: NEG
85947: PUSH
85948: EMPTY
85949: LIST
85950: LIST
85951: PUSH
85952: EMPTY
85953: LIST
85954: LIST
85955: LIST
85956: LIST
85957: LIST
85958: LIST
85959: LIST
85960: LIST
85961: LIST
85962: LIST
85963: LIST
85964: LIST
85965: LIST
85966: LIST
85967: LIST
85968: LIST
85969: LIST
85970: LIST
85971: LIST
85972: LIST
85973: LIST
85974: LIST
85975: LIST
85976: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85977: LD_ADDR_VAR 0 29
85981: PUSH
85982: LD_INT 0
85984: PUSH
85985: LD_INT 0
85987: PUSH
85988: EMPTY
85989: LIST
85990: LIST
85991: PUSH
85992: LD_INT 0
85994: PUSH
85995: LD_INT 1
85997: NEG
85998: PUSH
85999: EMPTY
86000: LIST
86001: LIST
86002: PUSH
86003: LD_INT 1
86005: PUSH
86006: LD_INT 0
86008: PUSH
86009: EMPTY
86010: LIST
86011: LIST
86012: PUSH
86013: LD_INT 1
86015: PUSH
86016: LD_INT 1
86018: PUSH
86019: EMPTY
86020: LIST
86021: LIST
86022: PUSH
86023: LD_INT 0
86025: PUSH
86026: LD_INT 1
86028: PUSH
86029: EMPTY
86030: LIST
86031: LIST
86032: PUSH
86033: LD_INT 1
86035: NEG
86036: PUSH
86037: LD_INT 0
86039: PUSH
86040: EMPTY
86041: LIST
86042: LIST
86043: PUSH
86044: LD_INT 1
86046: NEG
86047: PUSH
86048: LD_INT 1
86050: NEG
86051: PUSH
86052: EMPTY
86053: LIST
86054: LIST
86055: PUSH
86056: LD_INT 1
86058: NEG
86059: PUSH
86060: LD_INT 2
86062: NEG
86063: PUSH
86064: EMPTY
86065: LIST
86066: LIST
86067: PUSH
86068: LD_INT 0
86070: PUSH
86071: LD_INT 2
86073: NEG
86074: PUSH
86075: EMPTY
86076: LIST
86077: LIST
86078: PUSH
86079: LD_INT 1
86081: PUSH
86082: LD_INT 1
86084: NEG
86085: PUSH
86086: EMPTY
86087: LIST
86088: LIST
86089: PUSH
86090: LD_INT 2
86092: PUSH
86093: LD_INT 0
86095: PUSH
86096: EMPTY
86097: LIST
86098: LIST
86099: PUSH
86100: LD_INT 2
86102: PUSH
86103: LD_INT 1
86105: PUSH
86106: EMPTY
86107: LIST
86108: LIST
86109: PUSH
86110: LD_INT 1
86112: PUSH
86113: LD_INT 2
86115: PUSH
86116: EMPTY
86117: LIST
86118: LIST
86119: PUSH
86120: LD_INT 0
86122: PUSH
86123: LD_INT 2
86125: PUSH
86126: EMPTY
86127: LIST
86128: LIST
86129: PUSH
86130: LD_INT 1
86132: NEG
86133: PUSH
86134: LD_INT 1
86136: PUSH
86137: EMPTY
86138: LIST
86139: LIST
86140: PUSH
86141: LD_INT 2
86143: NEG
86144: PUSH
86145: LD_INT 1
86147: NEG
86148: PUSH
86149: EMPTY
86150: LIST
86151: LIST
86152: PUSH
86153: LD_INT 2
86155: NEG
86156: PUSH
86157: LD_INT 2
86159: NEG
86160: PUSH
86161: EMPTY
86162: LIST
86163: LIST
86164: PUSH
86165: LD_INT 2
86167: NEG
86168: PUSH
86169: LD_INT 3
86171: NEG
86172: PUSH
86173: EMPTY
86174: LIST
86175: LIST
86176: PUSH
86177: LD_INT 2
86179: PUSH
86180: LD_INT 1
86182: NEG
86183: PUSH
86184: EMPTY
86185: LIST
86186: LIST
86187: PUSH
86188: LD_INT 3
86190: PUSH
86191: LD_INT 1
86193: PUSH
86194: EMPTY
86195: LIST
86196: LIST
86197: PUSH
86198: LD_INT 1
86200: PUSH
86201: LD_INT 3
86203: PUSH
86204: EMPTY
86205: LIST
86206: LIST
86207: PUSH
86208: LD_INT 1
86210: NEG
86211: PUSH
86212: LD_INT 2
86214: PUSH
86215: EMPTY
86216: LIST
86217: LIST
86218: PUSH
86219: LD_INT 3
86221: NEG
86222: PUSH
86223: LD_INT 2
86225: NEG
86226: PUSH
86227: EMPTY
86228: LIST
86229: LIST
86230: PUSH
86231: EMPTY
86232: LIST
86233: LIST
86234: LIST
86235: LIST
86236: LIST
86237: LIST
86238: LIST
86239: LIST
86240: LIST
86241: LIST
86242: LIST
86243: LIST
86244: LIST
86245: LIST
86246: LIST
86247: LIST
86248: LIST
86249: LIST
86250: LIST
86251: LIST
86252: LIST
86253: LIST
86254: LIST
86255: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86256: LD_ADDR_VAR 0 30
86260: PUSH
86261: LD_INT 0
86263: PUSH
86264: LD_INT 0
86266: PUSH
86267: EMPTY
86268: LIST
86269: LIST
86270: PUSH
86271: LD_INT 0
86273: PUSH
86274: LD_INT 1
86276: NEG
86277: PUSH
86278: EMPTY
86279: LIST
86280: LIST
86281: PUSH
86282: LD_INT 1
86284: PUSH
86285: LD_INT 0
86287: PUSH
86288: EMPTY
86289: LIST
86290: LIST
86291: PUSH
86292: LD_INT 1
86294: PUSH
86295: LD_INT 1
86297: PUSH
86298: EMPTY
86299: LIST
86300: LIST
86301: PUSH
86302: LD_INT 0
86304: PUSH
86305: LD_INT 1
86307: PUSH
86308: EMPTY
86309: LIST
86310: LIST
86311: PUSH
86312: LD_INT 1
86314: NEG
86315: PUSH
86316: LD_INT 0
86318: PUSH
86319: EMPTY
86320: LIST
86321: LIST
86322: PUSH
86323: LD_INT 1
86325: NEG
86326: PUSH
86327: LD_INT 1
86329: NEG
86330: PUSH
86331: EMPTY
86332: LIST
86333: LIST
86334: PUSH
86335: LD_INT 1
86337: NEG
86338: PUSH
86339: LD_INT 2
86341: NEG
86342: PUSH
86343: EMPTY
86344: LIST
86345: LIST
86346: PUSH
86347: LD_INT 0
86349: PUSH
86350: LD_INT 2
86352: NEG
86353: PUSH
86354: EMPTY
86355: LIST
86356: LIST
86357: PUSH
86358: LD_INT 1
86360: PUSH
86361: LD_INT 1
86363: NEG
86364: PUSH
86365: EMPTY
86366: LIST
86367: LIST
86368: PUSH
86369: LD_INT 2
86371: PUSH
86372: LD_INT 0
86374: PUSH
86375: EMPTY
86376: LIST
86377: LIST
86378: PUSH
86379: LD_INT 2
86381: PUSH
86382: LD_INT 1
86384: PUSH
86385: EMPTY
86386: LIST
86387: LIST
86388: PUSH
86389: LD_INT 2
86391: PUSH
86392: LD_INT 2
86394: PUSH
86395: EMPTY
86396: LIST
86397: LIST
86398: PUSH
86399: LD_INT 1
86401: PUSH
86402: LD_INT 2
86404: PUSH
86405: EMPTY
86406: LIST
86407: LIST
86408: PUSH
86409: LD_INT 1
86411: NEG
86412: PUSH
86413: LD_INT 1
86415: PUSH
86416: EMPTY
86417: LIST
86418: LIST
86419: PUSH
86420: LD_INT 2
86422: NEG
86423: PUSH
86424: LD_INT 0
86426: PUSH
86427: EMPTY
86428: LIST
86429: LIST
86430: PUSH
86431: LD_INT 2
86433: NEG
86434: PUSH
86435: LD_INT 1
86437: NEG
86438: PUSH
86439: EMPTY
86440: LIST
86441: LIST
86442: PUSH
86443: LD_INT 1
86445: NEG
86446: PUSH
86447: LD_INT 3
86449: NEG
86450: PUSH
86451: EMPTY
86452: LIST
86453: LIST
86454: PUSH
86455: LD_INT 1
86457: PUSH
86458: LD_INT 2
86460: NEG
86461: PUSH
86462: EMPTY
86463: LIST
86464: LIST
86465: PUSH
86466: LD_INT 3
86468: PUSH
86469: LD_INT 2
86471: PUSH
86472: EMPTY
86473: LIST
86474: LIST
86475: PUSH
86476: LD_INT 2
86478: PUSH
86479: LD_INT 3
86481: PUSH
86482: EMPTY
86483: LIST
86484: LIST
86485: PUSH
86486: LD_INT 2
86488: NEG
86489: PUSH
86490: LD_INT 1
86492: PUSH
86493: EMPTY
86494: LIST
86495: LIST
86496: PUSH
86497: LD_INT 3
86499: NEG
86500: PUSH
86501: LD_INT 1
86503: NEG
86504: PUSH
86505: EMPTY
86506: LIST
86507: LIST
86508: PUSH
86509: EMPTY
86510: LIST
86511: LIST
86512: LIST
86513: LIST
86514: LIST
86515: LIST
86516: LIST
86517: LIST
86518: LIST
86519: LIST
86520: LIST
86521: LIST
86522: LIST
86523: LIST
86524: LIST
86525: LIST
86526: LIST
86527: LIST
86528: LIST
86529: LIST
86530: LIST
86531: LIST
86532: LIST
86533: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
86534: LD_ADDR_VAR 0 31
86538: PUSH
86539: LD_INT 0
86541: PUSH
86542: LD_INT 0
86544: PUSH
86545: EMPTY
86546: LIST
86547: LIST
86548: PUSH
86549: LD_INT 0
86551: PUSH
86552: LD_INT 1
86554: NEG
86555: PUSH
86556: EMPTY
86557: LIST
86558: LIST
86559: PUSH
86560: LD_INT 1
86562: PUSH
86563: LD_INT 0
86565: PUSH
86566: EMPTY
86567: LIST
86568: LIST
86569: PUSH
86570: LD_INT 1
86572: PUSH
86573: LD_INT 1
86575: PUSH
86576: EMPTY
86577: LIST
86578: LIST
86579: PUSH
86580: LD_INT 0
86582: PUSH
86583: LD_INT 1
86585: PUSH
86586: EMPTY
86587: LIST
86588: LIST
86589: PUSH
86590: LD_INT 1
86592: NEG
86593: PUSH
86594: LD_INT 0
86596: PUSH
86597: EMPTY
86598: LIST
86599: LIST
86600: PUSH
86601: LD_INT 1
86603: NEG
86604: PUSH
86605: LD_INT 1
86607: NEG
86608: PUSH
86609: EMPTY
86610: LIST
86611: LIST
86612: PUSH
86613: LD_INT 1
86615: NEG
86616: PUSH
86617: LD_INT 2
86619: NEG
86620: PUSH
86621: EMPTY
86622: LIST
86623: LIST
86624: PUSH
86625: LD_INT 1
86627: PUSH
86628: LD_INT 1
86630: NEG
86631: PUSH
86632: EMPTY
86633: LIST
86634: LIST
86635: PUSH
86636: LD_INT 2
86638: PUSH
86639: LD_INT 0
86641: PUSH
86642: EMPTY
86643: LIST
86644: LIST
86645: PUSH
86646: LD_INT 2
86648: PUSH
86649: LD_INT 1
86651: PUSH
86652: EMPTY
86653: LIST
86654: LIST
86655: PUSH
86656: LD_INT 2
86658: PUSH
86659: LD_INT 2
86661: PUSH
86662: EMPTY
86663: LIST
86664: LIST
86665: PUSH
86666: LD_INT 1
86668: PUSH
86669: LD_INT 2
86671: PUSH
86672: EMPTY
86673: LIST
86674: LIST
86675: PUSH
86676: LD_INT 0
86678: PUSH
86679: LD_INT 2
86681: PUSH
86682: EMPTY
86683: LIST
86684: LIST
86685: PUSH
86686: LD_INT 1
86688: NEG
86689: PUSH
86690: LD_INT 1
86692: PUSH
86693: EMPTY
86694: LIST
86695: LIST
86696: PUSH
86697: LD_INT 2
86699: NEG
86700: PUSH
86701: LD_INT 1
86703: NEG
86704: PUSH
86705: EMPTY
86706: LIST
86707: LIST
86708: PUSH
86709: LD_INT 2
86711: NEG
86712: PUSH
86713: LD_INT 2
86715: NEG
86716: PUSH
86717: EMPTY
86718: LIST
86719: LIST
86720: PUSH
86721: LD_INT 2
86723: NEG
86724: PUSH
86725: LD_INT 3
86727: NEG
86728: PUSH
86729: EMPTY
86730: LIST
86731: LIST
86732: PUSH
86733: LD_INT 2
86735: PUSH
86736: LD_INT 1
86738: NEG
86739: PUSH
86740: EMPTY
86741: LIST
86742: LIST
86743: PUSH
86744: LD_INT 3
86746: PUSH
86747: LD_INT 1
86749: PUSH
86750: EMPTY
86751: LIST
86752: LIST
86753: PUSH
86754: LD_INT 1
86756: PUSH
86757: LD_INT 3
86759: PUSH
86760: EMPTY
86761: LIST
86762: LIST
86763: PUSH
86764: LD_INT 1
86766: NEG
86767: PUSH
86768: LD_INT 2
86770: PUSH
86771: EMPTY
86772: LIST
86773: LIST
86774: PUSH
86775: LD_INT 3
86777: NEG
86778: PUSH
86779: LD_INT 2
86781: NEG
86782: PUSH
86783: EMPTY
86784: LIST
86785: LIST
86786: PUSH
86787: EMPTY
86788: LIST
86789: LIST
86790: LIST
86791: LIST
86792: LIST
86793: LIST
86794: LIST
86795: LIST
86796: LIST
86797: LIST
86798: LIST
86799: LIST
86800: LIST
86801: LIST
86802: LIST
86803: LIST
86804: LIST
86805: LIST
86806: LIST
86807: LIST
86808: LIST
86809: LIST
86810: LIST
86811: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86812: LD_ADDR_VAR 0 32
86816: PUSH
86817: LD_INT 0
86819: PUSH
86820: LD_INT 0
86822: PUSH
86823: EMPTY
86824: LIST
86825: LIST
86826: PUSH
86827: LD_INT 0
86829: PUSH
86830: LD_INT 1
86832: NEG
86833: PUSH
86834: EMPTY
86835: LIST
86836: LIST
86837: PUSH
86838: LD_INT 1
86840: PUSH
86841: LD_INT 0
86843: PUSH
86844: EMPTY
86845: LIST
86846: LIST
86847: PUSH
86848: LD_INT 1
86850: PUSH
86851: LD_INT 1
86853: PUSH
86854: EMPTY
86855: LIST
86856: LIST
86857: PUSH
86858: LD_INT 0
86860: PUSH
86861: LD_INT 1
86863: PUSH
86864: EMPTY
86865: LIST
86866: LIST
86867: PUSH
86868: LD_INT 1
86870: NEG
86871: PUSH
86872: LD_INT 0
86874: PUSH
86875: EMPTY
86876: LIST
86877: LIST
86878: PUSH
86879: LD_INT 1
86881: NEG
86882: PUSH
86883: LD_INT 1
86885: NEG
86886: PUSH
86887: EMPTY
86888: LIST
86889: LIST
86890: PUSH
86891: LD_INT 1
86893: NEG
86894: PUSH
86895: LD_INT 2
86897: NEG
86898: PUSH
86899: EMPTY
86900: LIST
86901: LIST
86902: PUSH
86903: LD_INT 0
86905: PUSH
86906: LD_INT 2
86908: NEG
86909: PUSH
86910: EMPTY
86911: LIST
86912: LIST
86913: PUSH
86914: LD_INT 1
86916: PUSH
86917: LD_INT 1
86919: NEG
86920: PUSH
86921: EMPTY
86922: LIST
86923: LIST
86924: PUSH
86925: LD_INT 2
86927: PUSH
86928: LD_INT 1
86930: PUSH
86931: EMPTY
86932: LIST
86933: LIST
86934: PUSH
86935: LD_INT 2
86937: PUSH
86938: LD_INT 2
86940: PUSH
86941: EMPTY
86942: LIST
86943: LIST
86944: PUSH
86945: LD_INT 1
86947: PUSH
86948: LD_INT 2
86950: PUSH
86951: EMPTY
86952: LIST
86953: LIST
86954: PUSH
86955: LD_INT 0
86957: PUSH
86958: LD_INT 2
86960: PUSH
86961: EMPTY
86962: LIST
86963: LIST
86964: PUSH
86965: LD_INT 1
86967: NEG
86968: PUSH
86969: LD_INT 1
86971: PUSH
86972: EMPTY
86973: LIST
86974: LIST
86975: PUSH
86976: LD_INT 2
86978: NEG
86979: PUSH
86980: LD_INT 0
86982: PUSH
86983: EMPTY
86984: LIST
86985: LIST
86986: PUSH
86987: LD_INT 2
86989: NEG
86990: PUSH
86991: LD_INT 1
86993: NEG
86994: PUSH
86995: EMPTY
86996: LIST
86997: LIST
86998: PUSH
86999: LD_INT 1
87001: NEG
87002: PUSH
87003: LD_INT 3
87005: NEG
87006: PUSH
87007: EMPTY
87008: LIST
87009: LIST
87010: PUSH
87011: LD_INT 1
87013: PUSH
87014: LD_INT 2
87016: NEG
87017: PUSH
87018: EMPTY
87019: LIST
87020: LIST
87021: PUSH
87022: LD_INT 3
87024: PUSH
87025: LD_INT 2
87027: PUSH
87028: EMPTY
87029: LIST
87030: LIST
87031: PUSH
87032: LD_INT 2
87034: PUSH
87035: LD_INT 3
87037: PUSH
87038: EMPTY
87039: LIST
87040: LIST
87041: PUSH
87042: LD_INT 2
87044: NEG
87045: PUSH
87046: LD_INT 1
87048: PUSH
87049: EMPTY
87050: LIST
87051: LIST
87052: PUSH
87053: LD_INT 3
87055: NEG
87056: PUSH
87057: LD_INT 1
87059: NEG
87060: PUSH
87061: EMPTY
87062: LIST
87063: LIST
87064: PUSH
87065: EMPTY
87066: LIST
87067: LIST
87068: LIST
87069: LIST
87070: LIST
87071: LIST
87072: LIST
87073: LIST
87074: LIST
87075: LIST
87076: LIST
87077: LIST
87078: LIST
87079: LIST
87080: LIST
87081: LIST
87082: LIST
87083: LIST
87084: LIST
87085: LIST
87086: LIST
87087: LIST
87088: LIST
87089: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
87090: LD_ADDR_VAR 0 33
87094: PUSH
87095: LD_INT 0
87097: PUSH
87098: LD_INT 0
87100: PUSH
87101: EMPTY
87102: LIST
87103: LIST
87104: PUSH
87105: LD_INT 0
87107: PUSH
87108: LD_INT 1
87110: NEG
87111: PUSH
87112: EMPTY
87113: LIST
87114: LIST
87115: PUSH
87116: LD_INT 1
87118: PUSH
87119: LD_INT 0
87121: PUSH
87122: EMPTY
87123: LIST
87124: LIST
87125: PUSH
87126: LD_INT 1
87128: PUSH
87129: LD_INT 1
87131: PUSH
87132: EMPTY
87133: LIST
87134: LIST
87135: PUSH
87136: LD_INT 0
87138: PUSH
87139: LD_INT 1
87141: PUSH
87142: EMPTY
87143: LIST
87144: LIST
87145: PUSH
87146: LD_INT 1
87148: NEG
87149: PUSH
87150: LD_INT 0
87152: PUSH
87153: EMPTY
87154: LIST
87155: LIST
87156: PUSH
87157: LD_INT 1
87159: NEG
87160: PUSH
87161: LD_INT 1
87163: NEG
87164: PUSH
87165: EMPTY
87166: LIST
87167: LIST
87168: PUSH
87169: LD_INT 1
87171: NEG
87172: PUSH
87173: LD_INT 2
87175: NEG
87176: PUSH
87177: EMPTY
87178: LIST
87179: LIST
87180: PUSH
87181: LD_INT 1
87183: PUSH
87184: LD_INT 1
87186: NEG
87187: PUSH
87188: EMPTY
87189: LIST
87190: LIST
87191: PUSH
87192: LD_INT 2
87194: PUSH
87195: LD_INT 0
87197: PUSH
87198: EMPTY
87199: LIST
87200: LIST
87201: PUSH
87202: LD_INT 2
87204: PUSH
87205: LD_INT 1
87207: PUSH
87208: EMPTY
87209: LIST
87210: LIST
87211: PUSH
87212: LD_INT 1
87214: PUSH
87215: LD_INT 2
87217: PUSH
87218: EMPTY
87219: LIST
87220: LIST
87221: PUSH
87222: LD_INT 0
87224: PUSH
87225: LD_INT 2
87227: PUSH
87228: EMPTY
87229: LIST
87230: LIST
87231: PUSH
87232: LD_INT 1
87234: NEG
87235: PUSH
87236: LD_INT 1
87238: PUSH
87239: EMPTY
87240: LIST
87241: LIST
87242: PUSH
87243: LD_INT 2
87245: NEG
87246: PUSH
87247: LD_INT 0
87249: PUSH
87250: EMPTY
87251: LIST
87252: LIST
87253: PUSH
87254: LD_INT 2
87256: NEG
87257: PUSH
87258: LD_INT 1
87260: NEG
87261: PUSH
87262: EMPTY
87263: LIST
87264: LIST
87265: PUSH
87266: LD_INT 2
87268: NEG
87269: PUSH
87270: LD_INT 2
87272: NEG
87273: PUSH
87274: EMPTY
87275: LIST
87276: LIST
87277: PUSH
87278: LD_INT 2
87280: NEG
87281: PUSH
87282: LD_INT 3
87284: NEG
87285: PUSH
87286: EMPTY
87287: LIST
87288: LIST
87289: PUSH
87290: LD_INT 2
87292: PUSH
87293: LD_INT 1
87295: NEG
87296: PUSH
87297: EMPTY
87298: LIST
87299: LIST
87300: PUSH
87301: LD_INT 3
87303: PUSH
87304: LD_INT 1
87306: PUSH
87307: EMPTY
87308: LIST
87309: LIST
87310: PUSH
87311: LD_INT 1
87313: PUSH
87314: LD_INT 3
87316: PUSH
87317: EMPTY
87318: LIST
87319: LIST
87320: PUSH
87321: LD_INT 1
87323: NEG
87324: PUSH
87325: LD_INT 2
87327: PUSH
87328: EMPTY
87329: LIST
87330: LIST
87331: PUSH
87332: LD_INT 3
87334: NEG
87335: PUSH
87336: LD_INT 2
87338: NEG
87339: PUSH
87340: EMPTY
87341: LIST
87342: LIST
87343: PUSH
87344: EMPTY
87345: LIST
87346: LIST
87347: LIST
87348: LIST
87349: LIST
87350: LIST
87351: LIST
87352: LIST
87353: LIST
87354: LIST
87355: LIST
87356: LIST
87357: LIST
87358: LIST
87359: LIST
87360: LIST
87361: LIST
87362: LIST
87363: LIST
87364: LIST
87365: LIST
87366: LIST
87367: LIST
87368: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
87369: LD_ADDR_VAR 0 34
87373: PUSH
87374: LD_INT 0
87376: PUSH
87377: LD_INT 0
87379: PUSH
87380: EMPTY
87381: LIST
87382: LIST
87383: PUSH
87384: LD_INT 0
87386: PUSH
87387: LD_INT 1
87389: NEG
87390: PUSH
87391: EMPTY
87392: LIST
87393: LIST
87394: PUSH
87395: LD_INT 1
87397: PUSH
87398: LD_INT 0
87400: PUSH
87401: EMPTY
87402: LIST
87403: LIST
87404: PUSH
87405: LD_INT 1
87407: PUSH
87408: LD_INT 1
87410: PUSH
87411: EMPTY
87412: LIST
87413: LIST
87414: PUSH
87415: LD_INT 0
87417: PUSH
87418: LD_INT 1
87420: PUSH
87421: EMPTY
87422: LIST
87423: LIST
87424: PUSH
87425: LD_INT 1
87427: NEG
87428: PUSH
87429: LD_INT 0
87431: PUSH
87432: EMPTY
87433: LIST
87434: LIST
87435: PUSH
87436: LD_INT 1
87438: NEG
87439: PUSH
87440: LD_INT 1
87442: NEG
87443: PUSH
87444: EMPTY
87445: LIST
87446: LIST
87447: PUSH
87448: LD_INT 1
87450: NEG
87451: PUSH
87452: LD_INT 2
87454: NEG
87455: PUSH
87456: EMPTY
87457: LIST
87458: LIST
87459: PUSH
87460: LD_INT 0
87462: PUSH
87463: LD_INT 2
87465: NEG
87466: PUSH
87467: EMPTY
87468: LIST
87469: LIST
87470: PUSH
87471: LD_INT 1
87473: PUSH
87474: LD_INT 1
87476: NEG
87477: PUSH
87478: EMPTY
87479: LIST
87480: LIST
87481: PUSH
87482: LD_INT 2
87484: PUSH
87485: LD_INT 1
87487: PUSH
87488: EMPTY
87489: LIST
87490: LIST
87491: PUSH
87492: LD_INT 2
87494: PUSH
87495: LD_INT 2
87497: PUSH
87498: EMPTY
87499: LIST
87500: LIST
87501: PUSH
87502: LD_INT 1
87504: PUSH
87505: LD_INT 2
87507: PUSH
87508: EMPTY
87509: LIST
87510: LIST
87511: PUSH
87512: LD_INT 1
87514: NEG
87515: PUSH
87516: LD_INT 1
87518: PUSH
87519: EMPTY
87520: LIST
87521: LIST
87522: PUSH
87523: LD_INT 2
87525: NEG
87526: PUSH
87527: LD_INT 0
87529: PUSH
87530: EMPTY
87531: LIST
87532: LIST
87533: PUSH
87534: LD_INT 2
87536: NEG
87537: PUSH
87538: LD_INT 1
87540: NEG
87541: PUSH
87542: EMPTY
87543: LIST
87544: LIST
87545: PUSH
87546: LD_INT 2
87548: NEG
87549: PUSH
87550: LD_INT 2
87552: NEG
87553: PUSH
87554: EMPTY
87555: LIST
87556: LIST
87557: PUSH
87558: LD_INT 1
87560: NEG
87561: PUSH
87562: LD_INT 3
87564: NEG
87565: PUSH
87566: EMPTY
87567: LIST
87568: LIST
87569: PUSH
87570: LD_INT 1
87572: PUSH
87573: LD_INT 2
87575: NEG
87576: PUSH
87577: EMPTY
87578: LIST
87579: LIST
87580: PUSH
87581: LD_INT 3
87583: PUSH
87584: LD_INT 2
87586: PUSH
87587: EMPTY
87588: LIST
87589: LIST
87590: PUSH
87591: LD_INT 2
87593: PUSH
87594: LD_INT 3
87596: PUSH
87597: EMPTY
87598: LIST
87599: LIST
87600: PUSH
87601: LD_INT 2
87603: NEG
87604: PUSH
87605: LD_INT 1
87607: PUSH
87608: EMPTY
87609: LIST
87610: LIST
87611: PUSH
87612: LD_INT 3
87614: NEG
87615: PUSH
87616: LD_INT 1
87618: NEG
87619: PUSH
87620: EMPTY
87621: LIST
87622: LIST
87623: PUSH
87624: EMPTY
87625: LIST
87626: LIST
87627: LIST
87628: LIST
87629: LIST
87630: LIST
87631: LIST
87632: LIST
87633: LIST
87634: LIST
87635: LIST
87636: LIST
87637: LIST
87638: LIST
87639: LIST
87640: LIST
87641: LIST
87642: LIST
87643: LIST
87644: LIST
87645: LIST
87646: LIST
87647: LIST
87648: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
87649: LD_ADDR_VAR 0 35
87653: PUSH
87654: LD_INT 0
87656: PUSH
87657: LD_INT 0
87659: PUSH
87660: EMPTY
87661: LIST
87662: LIST
87663: PUSH
87664: LD_INT 0
87666: PUSH
87667: LD_INT 1
87669: NEG
87670: PUSH
87671: EMPTY
87672: LIST
87673: LIST
87674: PUSH
87675: LD_INT 1
87677: PUSH
87678: LD_INT 0
87680: PUSH
87681: EMPTY
87682: LIST
87683: LIST
87684: PUSH
87685: LD_INT 1
87687: PUSH
87688: LD_INT 1
87690: PUSH
87691: EMPTY
87692: LIST
87693: LIST
87694: PUSH
87695: LD_INT 0
87697: PUSH
87698: LD_INT 1
87700: PUSH
87701: EMPTY
87702: LIST
87703: LIST
87704: PUSH
87705: LD_INT 1
87707: NEG
87708: PUSH
87709: LD_INT 0
87711: PUSH
87712: EMPTY
87713: LIST
87714: LIST
87715: PUSH
87716: LD_INT 1
87718: NEG
87719: PUSH
87720: LD_INT 1
87722: NEG
87723: PUSH
87724: EMPTY
87725: LIST
87726: LIST
87727: PUSH
87728: LD_INT 2
87730: PUSH
87731: LD_INT 1
87733: PUSH
87734: EMPTY
87735: LIST
87736: LIST
87737: PUSH
87738: LD_INT 2
87740: NEG
87741: PUSH
87742: LD_INT 1
87744: NEG
87745: PUSH
87746: EMPTY
87747: LIST
87748: LIST
87749: PUSH
87750: EMPTY
87751: LIST
87752: LIST
87753: LIST
87754: LIST
87755: LIST
87756: LIST
87757: LIST
87758: LIST
87759: LIST
87760: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
87761: LD_ADDR_VAR 0 36
87765: PUSH
87766: LD_INT 0
87768: PUSH
87769: LD_INT 0
87771: PUSH
87772: EMPTY
87773: LIST
87774: LIST
87775: PUSH
87776: LD_INT 0
87778: PUSH
87779: LD_INT 1
87781: NEG
87782: PUSH
87783: EMPTY
87784: LIST
87785: LIST
87786: PUSH
87787: LD_INT 1
87789: PUSH
87790: LD_INT 0
87792: PUSH
87793: EMPTY
87794: LIST
87795: LIST
87796: PUSH
87797: LD_INT 1
87799: PUSH
87800: LD_INT 1
87802: PUSH
87803: EMPTY
87804: LIST
87805: LIST
87806: PUSH
87807: LD_INT 0
87809: PUSH
87810: LD_INT 1
87812: PUSH
87813: EMPTY
87814: LIST
87815: LIST
87816: PUSH
87817: LD_INT 1
87819: NEG
87820: PUSH
87821: LD_INT 0
87823: PUSH
87824: EMPTY
87825: LIST
87826: LIST
87827: PUSH
87828: LD_INT 1
87830: NEG
87831: PUSH
87832: LD_INT 1
87834: NEG
87835: PUSH
87836: EMPTY
87837: LIST
87838: LIST
87839: PUSH
87840: LD_INT 1
87842: NEG
87843: PUSH
87844: LD_INT 2
87846: NEG
87847: PUSH
87848: EMPTY
87849: LIST
87850: LIST
87851: PUSH
87852: LD_INT 1
87854: PUSH
87855: LD_INT 2
87857: PUSH
87858: EMPTY
87859: LIST
87860: LIST
87861: PUSH
87862: EMPTY
87863: LIST
87864: LIST
87865: LIST
87866: LIST
87867: LIST
87868: LIST
87869: LIST
87870: LIST
87871: LIST
87872: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
87873: LD_ADDR_VAR 0 37
87877: PUSH
87878: LD_INT 0
87880: PUSH
87881: LD_INT 0
87883: PUSH
87884: EMPTY
87885: LIST
87886: LIST
87887: PUSH
87888: LD_INT 0
87890: PUSH
87891: LD_INT 1
87893: NEG
87894: PUSH
87895: EMPTY
87896: LIST
87897: LIST
87898: PUSH
87899: LD_INT 1
87901: PUSH
87902: LD_INT 0
87904: PUSH
87905: EMPTY
87906: LIST
87907: LIST
87908: PUSH
87909: LD_INT 1
87911: PUSH
87912: LD_INT 1
87914: PUSH
87915: EMPTY
87916: LIST
87917: LIST
87918: PUSH
87919: LD_INT 0
87921: PUSH
87922: LD_INT 1
87924: PUSH
87925: EMPTY
87926: LIST
87927: LIST
87928: PUSH
87929: LD_INT 1
87931: NEG
87932: PUSH
87933: LD_INT 0
87935: PUSH
87936: EMPTY
87937: LIST
87938: LIST
87939: PUSH
87940: LD_INT 1
87942: NEG
87943: PUSH
87944: LD_INT 1
87946: NEG
87947: PUSH
87948: EMPTY
87949: LIST
87950: LIST
87951: PUSH
87952: LD_INT 1
87954: PUSH
87955: LD_INT 1
87957: NEG
87958: PUSH
87959: EMPTY
87960: LIST
87961: LIST
87962: PUSH
87963: LD_INT 1
87965: NEG
87966: PUSH
87967: LD_INT 1
87969: PUSH
87970: EMPTY
87971: LIST
87972: LIST
87973: PUSH
87974: EMPTY
87975: LIST
87976: LIST
87977: LIST
87978: LIST
87979: LIST
87980: LIST
87981: LIST
87982: LIST
87983: LIST
87984: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
87985: LD_ADDR_VAR 0 38
87989: PUSH
87990: LD_INT 0
87992: PUSH
87993: LD_INT 0
87995: PUSH
87996: EMPTY
87997: LIST
87998: LIST
87999: PUSH
88000: LD_INT 0
88002: PUSH
88003: LD_INT 1
88005: NEG
88006: PUSH
88007: EMPTY
88008: LIST
88009: LIST
88010: PUSH
88011: LD_INT 1
88013: PUSH
88014: LD_INT 0
88016: PUSH
88017: EMPTY
88018: LIST
88019: LIST
88020: PUSH
88021: LD_INT 1
88023: PUSH
88024: LD_INT 1
88026: PUSH
88027: EMPTY
88028: LIST
88029: LIST
88030: PUSH
88031: LD_INT 0
88033: PUSH
88034: LD_INT 1
88036: PUSH
88037: EMPTY
88038: LIST
88039: LIST
88040: PUSH
88041: LD_INT 1
88043: NEG
88044: PUSH
88045: LD_INT 0
88047: PUSH
88048: EMPTY
88049: LIST
88050: LIST
88051: PUSH
88052: LD_INT 1
88054: NEG
88055: PUSH
88056: LD_INT 1
88058: NEG
88059: PUSH
88060: EMPTY
88061: LIST
88062: LIST
88063: PUSH
88064: LD_INT 2
88066: PUSH
88067: LD_INT 1
88069: PUSH
88070: EMPTY
88071: LIST
88072: LIST
88073: PUSH
88074: LD_INT 2
88076: NEG
88077: PUSH
88078: LD_INT 1
88080: NEG
88081: PUSH
88082: EMPTY
88083: LIST
88084: LIST
88085: PUSH
88086: EMPTY
88087: LIST
88088: LIST
88089: LIST
88090: LIST
88091: LIST
88092: LIST
88093: LIST
88094: LIST
88095: LIST
88096: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
88097: LD_ADDR_VAR 0 39
88101: PUSH
88102: LD_INT 0
88104: PUSH
88105: LD_INT 0
88107: PUSH
88108: EMPTY
88109: LIST
88110: LIST
88111: PUSH
88112: LD_INT 0
88114: PUSH
88115: LD_INT 1
88117: NEG
88118: PUSH
88119: EMPTY
88120: LIST
88121: LIST
88122: PUSH
88123: LD_INT 1
88125: PUSH
88126: LD_INT 0
88128: PUSH
88129: EMPTY
88130: LIST
88131: LIST
88132: PUSH
88133: LD_INT 1
88135: PUSH
88136: LD_INT 1
88138: PUSH
88139: EMPTY
88140: LIST
88141: LIST
88142: PUSH
88143: LD_INT 0
88145: PUSH
88146: LD_INT 1
88148: PUSH
88149: EMPTY
88150: LIST
88151: LIST
88152: PUSH
88153: LD_INT 1
88155: NEG
88156: PUSH
88157: LD_INT 0
88159: PUSH
88160: EMPTY
88161: LIST
88162: LIST
88163: PUSH
88164: LD_INT 1
88166: NEG
88167: PUSH
88168: LD_INT 1
88170: NEG
88171: PUSH
88172: EMPTY
88173: LIST
88174: LIST
88175: PUSH
88176: LD_INT 1
88178: NEG
88179: PUSH
88180: LD_INT 2
88182: NEG
88183: PUSH
88184: EMPTY
88185: LIST
88186: LIST
88187: PUSH
88188: LD_INT 1
88190: PUSH
88191: LD_INT 2
88193: PUSH
88194: EMPTY
88195: LIST
88196: LIST
88197: PUSH
88198: EMPTY
88199: LIST
88200: LIST
88201: LIST
88202: LIST
88203: LIST
88204: LIST
88205: LIST
88206: LIST
88207: LIST
88208: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
88209: LD_ADDR_VAR 0 40
88213: PUSH
88214: LD_INT 0
88216: PUSH
88217: LD_INT 0
88219: PUSH
88220: EMPTY
88221: LIST
88222: LIST
88223: PUSH
88224: LD_INT 0
88226: PUSH
88227: LD_INT 1
88229: NEG
88230: PUSH
88231: EMPTY
88232: LIST
88233: LIST
88234: PUSH
88235: LD_INT 1
88237: PUSH
88238: LD_INT 0
88240: PUSH
88241: EMPTY
88242: LIST
88243: LIST
88244: PUSH
88245: LD_INT 1
88247: PUSH
88248: LD_INT 1
88250: PUSH
88251: EMPTY
88252: LIST
88253: LIST
88254: PUSH
88255: LD_INT 0
88257: PUSH
88258: LD_INT 1
88260: PUSH
88261: EMPTY
88262: LIST
88263: LIST
88264: PUSH
88265: LD_INT 1
88267: NEG
88268: PUSH
88269: LD_INT 0
88271: PUSH
88272: EMPTY
88273: LIST
88274: LIST
88275: PUSH
88276: LD_INT 1
88278: NEG
88279: PUSH
88280: LD_INT 1
88282: NEG
88283: PUSH
88284: EMPTY
88285: LIST
88286: LIST
88287: PUSH
88288: LD_INT 1
88290: PUSH
88291: LD_INT 1
88293: NEG
88294: PUSH
88295: EMPTY
88296: LIST
88297: LIST
88298: PUSH
88299: LD_INT 1
88301: NEG
88302: PUSH
88303: LD_INT 1
88305: PUSH
88306: EMPTY
88307: LIST
88308: LIST
88309: PUSH
88310: EMPTY
88311: LIST
88312: LIST
88313: LIST
88314: LIST
88315: LIST
88316: LIST
88317: LIST
88318: LIST
88319: LIST
88320: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88321: LD_ADDR_VAR 0 41
88325: PUSH
88326: LD_INT 0
88328: PUSH
88329: LD_INT 0
88331: PUSH
88332: EMPTY
88333: LIST
88334: LIST
88335: PUSH
88336: LD_INT 0
88338: PUSH
88339: LD_INT 1
88341: NEG
88342: PUSH
88343: EMPTY
88344: LIST
88345: LIST
88346: PUSH
88347: LD_INT 1
88349: PUSH
88350: LD_INT 0
88352: PUSH
88353: EMPTY
88354: LIST
88355: LIST
88356: PUSH
88357: LD_INT 1
88359: PUSH
88360: LD_INT 1
88362: PUSH
88363: EMPTY
88364: LIST
88365: LIST
88366: PUSH
88367: LD_INT 0
88369: PUSH
88370: LD_INT 1
88372: PUSH
88373: EMPTY
88374: LIST
88375: LIST
88376: PUSH
88377: LD_INT 1
88379: NEG
88380: PUSH
88381: LD_INT 0
88383: PUSH
88384: EMPTY
88385: LIST
88386: LIST
88387: PUSH
88388: LD_INT 1
88390: NEG
88391: PUSH
88392: LD_INT 1
88394: NEG
88395: PUSH
88396: EMPTY
88397: LIST
88398: LIST
88399: PUSH
88400: LD_INT 1
88402: NEG
88403: PUSH
88404: LD_INT 2
88406: NEG
88407: PUSH
88408: EMPTY
88409: LIST
88410: LIST
88411: PUSH
88412: LD_INT 1
88414: PUSH
88415: LD_INT 1
88417: NEG
88418: PUSH
88419: EMPTY
88420: LIST
88421: LIST
88422: PUSH
88423: LD_INT 2
88425: PUSH
88426: LD_INT 0
88428: PUSH
88429: EMPTY
88430: LIST
88431: LIST
88432: PUSH
88433: LD_INT 2
88435: PUSH
88436: LD_INT 1
88438: PUSH
88439: EMPTY
88440: LIST
88441: LIST
88442: PUSH
88443: LD_INT 2
88445: PUSH
88446: LD_INT 2
88448: PUSH
88449: EMPTY
88450: LIST
88451: LIST
88452: PUSH
88453: LD_INT 1
88455: PUSH
88456: LD_INT 2
88458: PUSH
88459: EMPTY
88460: LIST
88461: LIST
88462: PUSH
88463: LD_INT 1
88465: NEG
88466: PUSH
88467: LD_INT 1
88469: PUSH
88470: EMPTY
88471: LIST
88472: LIST
88473: PUSH
88474: LD_INT 2
88476: NEG
88477: PUSH
88478: LD_INT 0
88480: PUSH
88481: EMPTY
88482: LIST
88483: LIST
88484: PUSH
88485: LD_INT 2
88487: NEG
88488: PUSH
88489: LD_INT 1
88491: NEG
88492: PUSH
88493: EMPTY
88494: LIST
88495: LIST
88496: PUSH
88497: LD_INT 2
88499: NEG
88500: PUSH
88501: LD_INT 2
88503: NEG
88504: PUSH
88505: EMPTY
88506: LIST
88507: LIST
88508: PUSH
88509: LD_INT 2
88511: NEG
88512: PUSH
88513: LD_INT 3
88515: NEG
88516: PUSH
88517: EMPTY
88518: LIST
88519: LIST
88520: PUSH
88521: LD_INT 2
88523: PUSH
88524: LD_INT 1
88526: NEG
88527: PUSH
88528: EMPTY
88529: LIST
88530: LIST
88531: PUSH
88532: LD_INT 3
88534: PUSH
88535: LD_INT 0
88537: PUSH
88538: EMPTY
88539: LIST
88540: LIST
88541: PUSH
88542: LD_INT 3
88544: PUSH
88545: LD_INT 1
88547: PUSH
88548: EMPTY
88549: LIST
88550: LIST
88551: PUSH
88552: LD_INT 3
88554: PUSH
88555: LD_INT 2
88557: PUSH
88558: EMPTY
88559: LIST
88560: LIST
88561: PUSH
88562: LD_INT 3
88564: PUSH
88565: LD_INT 3
88567: PUSH
88568: EMPTY
88569: LIST
88570: LIST
88571: PUSH
88572: LD_INT 2
88574: PUSH
88575: LD_INT 3
88577: PUSH
88578: EMPTY
88579: LIST
88580: LIST
88581: PUSH
88582: LD_INT 2
88584: NEG
88585: PUSH
88586: LD_INT 1
88588: PUSH
88589: EMPTY
88590: LIST
88591: LIST
88592: PUSH
88593: LD_INT 3
88595: NEG
88596: PUSH
88597: LD_INT 0
88599: PUSH
88600: EMPTY
88601: LIST
88602: LIST
88603: PUSH
88604: LD_INT 3
88606: NEG
88607: PUSH
88608: LD_INT 1
88610: NEG
88611: PUSH
88612: EMPTY
88613: LIST
88614: LIST
88615: PUSH
88616: LD_INT 3
88618: NEG
88619: PUSH
88620: LD_INT 2
88622: NEG
88623: PUSH
88624: EMPTY
88625: LIST
88626: LIST
88627: PUSH
88628: LD_INT 3
88630: NEG
88631: PUSH
88632: LD_INT 3
88634: NEG
88635: PUSH
88636: EMPTY
88637: LIST
88638: LIST
88639: PUSH
88640: EMPTY
88641: LIST
88642: LIST
88643: LIST
88644: LIST
88645: LIST
88646: LIST
88647: LIST
88648: LIST
88649: LIST
88650: LIST
88651: LIST
88652: LIST
88653: LIST
88654: LIST
88655: LIST
88656: LIST
88657: LIST
88658: LIST
88659: LIST
88660: LIST
88661: LIST
88662: LIST
88663: LIST
88664: LIST
88665: LIST
88666: LIST
88667: LIST
88668: LIST
88669: LIST
88670: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88671: LD_ADDR_VAR 0 42
88675: PUSH
88676: LD_INT 0
88678: PUSH
88679: LD_INT 0
88681: PUSH
88682: EMPTY
88683: LIST
88684: LIST
88685: PUSH
88686: LD_INT 0
88688: PUSH
88689: LD_INT 1
88691: NEG
88692: PUSH
88693: EMPTY
88694: LIST
88695: LIST
88696: PUSH
88697: LD_INT 1
88699: PUSH
88700: LD_INT 0
88702: PUSH
88703: EMPTY
88704: LIST
88705: LIST
88706: PUSH
88707: LD_INT 1
88709: PUSH
88710: LD_INT 1
88712: PUSH
88713: EMPTY
88714: LIST
88715: LIST
88716: PUSH
88717: LD_INT 0
88719: PUSH
88720: LD_INT 1
88722: PUSH
88723: EMPTY
88724: LIST
88725: LIST
88726: PUSH
88727: LD_INT 1
88729: NEG
88730: PUSH
88731: LD_INT 0
88733: PUSH
88734: EMPTY
88735: LIST
88736: LIST
88737: PUSH
88738: LD_INT 1
88740: NEG
88741: PUSH
88742: LD_INT 1
88744: NEG
88745: PUSH
88746: EMPTY
88747: LIST
88748: LIST
88749: PUSH
88750: LD_INT 1
88752: NEG
88753: PUSH
88754: LD_INT 2
88756: NEG
88757: PUSH
88758: EMPTY
88759: LIST
88760: LIST
88761: PUSH
88762: LD_INT 0
88764: PUSH
88765: LD_INT 2
88767: NEG
88768: PUSH
88769: EMPTY
88770: LIST
88771: LIST
88772: PUSH
88773: LD_INT 1
88775: PUSH
88776: LD_INT 1
88778: NEG
88779: PUSH
88780: EMPTY
88781: LIST
88782: LIST
88783: PUSH
88784: LD_INT 2
88786: PUSH
88787: LD_INT 1
88789: PUSH
88790: EMPTY
88791: LIST
88792: LIST
88793: PUSH
88794: LD_INT 2
88796: PUSH
88797: LD_INT 2
88799: PUSH
88800: EMPTY
88801: LIST
88802: LIST
88803: PUSH
88804: LD_INT 1
88806: PUSH
88807: LD_INT 2
88809: PUSH
88810: EMPTY
88811: LIST
88812: LIST
88813: PUSH
88814: LD_INT 0
88816: PUSH
88817: LD_INT 2
88819: PUSH
88820: EMPTY
88821: LIST
88822: LIST
88823: PUSH
88824: LD_INT 1
88826: NEG
88827: PUSH
88828: LD_INT 1
88830: PUSH
88831: EMPTY
88832: LIST
88833: LIST
88834: PUSH
88835: LD_INT 2
88837: NEG
88838: PUSH
88839: LD_INT 1
88841: NEG
88842: PUSH
88843: EMPTY
88844: LIST
88845: LIST
88846: PUSH
88847: LD_INT 2
88849: NEG
88850: PUSH
88851: LD_INT 2
88853: NEG
88854: PUSH
88855: EMPTY
88856: LIST
88857: LIST
88858: PUSH
88859: LD_INT 2
88861: NEG
88862: PUSH
88863: LD_INT 3
88865: NEG
88866: PUSH
88867: EMPTY
88868: LIST
88869: LIST
88870: PUSH
88871: LD_INT 1
88873: NEG
88874: PUSH
88875: LD_INT 3
88877: NEG
88878: PUSH
88879: EMPTY
88880: LIST
88881: LIST
88882: PUSH
88883: LD_INT 0
88885: PUSH
88886: LD_INT 3
88888: NEG
88889: PUSH
88890: EMPTY
88891: LIST
88892: LIST
88893: PUSH
88894: LD_INT 1
88896: PUSH
88897: LD_INT 2
88899: NEG
88900: PUSH
88901: EMPTY
88902: LIST
88903: LIST
88904: PUSH
88905: LD_INT 3
88907: PUSH
88908: LD_INT 2
88910: PUSH
88911: EMPTY
88912: LIST
88913: LIST
88914: PUSH
88915: LD_INT 3
88917: PUSH
88918: LD_INT 3
88920: PUSH
88921: EMPTY
88922: LIST
88923: LIST
88924: PUSH
88925: LD_INT 2
88927: PUSH
88928: LD_INT 3
88930: PUSH
88931: EMPTY
88932: LIST
88933: LIST
88934: PUSH
88935: LD_INT 1
88937: PUSH
88938: LD_INT 3
88940: PUSH
88941: EMPTY
88942: LIST
88943: LIST
88944: PUSH
88945: LD_INT 0
88947: PUSH
88948: LD_INT 3
88950: PUSH
88951: EMPTY
88952: LIST
88953: LIST
88954: PUSH
88955: LD_INT 1
88957: NEG
88958: PUSH
88959: LD_INT 2
88961: PUSH
88962: EMPTY
88963: LIST
88964: LIST
88965: PUSH
88966: LD_INT 3
88968: NEG
88969: PUSH
88970: LD_INT 2
88972: NEG
88973: PUSH
88974: EMPTY
88975: LIST
88976: LIST
88977: PUSH
88978: LD_INT 3
88980: NEG
88981: PUSH
88982: LD_INT 3
88984: NEG
88985: PUSH
88986: EMPTY
88987: LIST
88988: LIST
88989: PUSH
88990: EMPTY
88991: LIST
88992: LIST
88993: LIST
88994: LIST
88995: LIST
88996: LIST
88997: LIST
88998: LIST
88999: LIST
89000: LIST
89001: LIST
89002: LIST
89003: LIST
89004: LIST
89005: LIST
89006: LIST
89007: LIST
89008: LIST
89009: LIST
89010: LIST
89011: LIST
89012: LIST
89013: LIST
89014: LIST
89015: LIST
89016: LIST
89017: LIST
89018: LIST
89019: LIST
89020: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89021: LD_ADDR_VAR 0 43
89025: PUSH
89026: LD_INT 0
89028: PUSH
89029: LD_INT 0
89031: PUSH
89032: EMPTY
89033: LIST
89034: LIST
89035: PUSH
89036: LD_INT 0
89038: PUSH
89039: LD_INT 1
89041: NEG
89042: PUSH
89043: EMPTY
89044: LIST
89045: LIST
89046: PUSH
89047: LD_INT 1
89049: PUSH
89050: LD_INT 0
89052: PUSH
89053: EMPTY
89054: LIST
89055: LIST
89056: PUSH
89057: LD_INT 1
89059: PUSH
89060: LD_INT 1
89062: PUSH
89063: EMPTY
89064: LIST
89065: LIST
89066: PUSH
89067: LD_INT 0
89069: PUSH
89070: LD_INT 1
89072: PUSH
89073: EMPTY
89074: LIST
89075: LIST
89076: PUSH
89077: LD_INT 1
89079: NEG
89080: PUSH
89081: LD_INT 0
89083: PUSH
89084: EMPTY
89085: LIST
89086: LIST
89087: PUSH
89088: LD_INT 1
89090: NEG
89091: PUSH
89092: LD_INT 1
89094: NEG
89095: PUSH
89096: EMPTY
89097: LIST
89098: LIST
89099: PUSH
89100: LD_INT 1
89102: NEG
89103: PUSH
89104: LD_INT 2
89106: NEG
89107: PUSH
89108: EMPTY
89109: LIST
89110: LIST
89111: PUSH
89112: LD_INT 0
89114: PUSH
89115: LD_INT 2
89117: NEG
89118: PUSH
89119: EMPTY
89120: LIST
89121: LIST
89122: PUSH
89123: LD_INT 1
89125: PUSH
89126: LD_INT 1
89128: NEG
89129: PUSH
89130: EMPTY
89131: LIST
89132: LIST
89133: PUSH
89134: LD_INT 2
89136: PUSH
89137: LD_INT 0
89139: PUSH
89140: EMPTY
89141: LIST
89142: LIST
89143: PUSH
89144: LD_INT 2
89146: PUSH
89147: LD_INT 1
89149: PUSH
89150: EMPTY
89151: LIST
89152: LIST
89153: PUSH
89154: LD_INT 1
89156: PUSH
89157: LD_INT 2
89159: PUSH
89160: EMPTY
89161: LIST
89162: LIST
89163: PUSH
89164: LD_INT 0
89166: PUSH
89167: LD_INT 2
89169: PUSH
89170: EMPTY
89171: LIST
89172: LIST
89173: PUSH
89174: LD_INT 1
89176: NEG
89177: PUSH
89178: LD_INT 1
89180: PUSH
89181: EMPTY
89182: LIST
89183: LIST
89184: PUSH
89185: LD_INT 2
89187: NEG
89188: PUSH
89189: LD_INT 0
89191: PUSH
89192: EMPTY
89193: LIST
89194: LIST
89195: PUSH
89196: LD_INT 2
89198: NEG
89199: PUSH
89200: LD_INT 1
89202: NEG
89203: PUSH
89204: EMPTY
89205: LIST
89206: LIST
89207: PUSH
89208: LD_INT 1
89210: NEG
89211: PUSH
89212: LD_INT 3
89214: NEG
89215: PUSH
89216: EMPTY
89217: LIST
89218: LIST
89219: PUSH
89220: LD_INT 0
89222: PUSH
89223: LD_INT 3
89225: NEG
89226: PUSH
89227: EMPTY
89228: LIST
89229: LIST
89230: PUSH
89231: LD_INT 1
89233: PUSH
89234: LD_INT 2
89236: NEG
89237: PUSH
89238: EMPTY
89239: LIST
89240: LIST
89241: PUSH
89242: LD_INT 2
89244: PUSH
89245: LD_INT 1
89247: NEG
89248: PUSH
89249: EMPTY
89250: LIST
89251: LIST
89252: PUSH
89253: LD_INT 3
89255: PUSH
89256: LD_INT 0
89258: PUSH
89259: EMPTY
89260: LIST
89261: LIST
89262: PUSH
89263: LD_INT 3
89265: PUSH
89266: LD_INT 1
89268: PUSH
89269: EMPTY
89270: LIST
89271: LIST
89272: PUSH
89273: LD_INT 1
89275: PUSH
89276: LD_INT 3
89278: PUSH
89279: EMPTY
89280: LIST
89281: LIST
89282: PUSH
89283: LD_INT 0
89285: PUSH
89286: LD_INT 3
89288: PUSH
89289: EMPTY
89290: LIST
89291: LIST
89292: PUSH
89293: LD_INT 1
89295: NEG
89296: PUSH
89297: LD_INT 2
89299: PUSH
89300: EMPTY
89301: LIST
89302: LIST
89303: PUSH
89304: LD_INT 2
89306: NEG
89307: PUSH
89308: LD_INT 1
89310: PUSH
89311: EMPTY
89312: LIST
89313: LIST
89314: PUSH
89315: LD_INT 3
89317: NEG
89318: PUSH
89319: LD_INT 0
89321: PUSH
89322: EMPTY
89323: LIST
89324: LIST
89325: PUSH
89326: LD_INT 3
89328: NEG
89329: PUSH
89330: LD_INT 1
89332: NEG
89333: PUSH
89334: EMPTY
89335: LIST
89336: LIST
89337: PUSH
89338: EMPTY
89339: LIST
89340: LIST
89341: LIST
89342: LIST
89343: LIST
89344: LIST
89345: LIST
89346: LIST
89347: LIST
89348: LIST
89349: LIST
89350: LIST
89351: LIST
89352: LIST
89353: LIST
89354: LIST
89355: LIST
89356: LIST
89357: LIST
89358: LIST
89359: LIST
89360: LIST
89361: LIST
89362: LIST
89363: LIST
89364: LIST
89365: LIST
89366: LIST
89367: LIST
89368: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89369: LD_ADDR_VAR 0 44
89373: PUSH
89374: LD_INT 0
89376: PUSH
89377: LD_INT 0
89379: PUSH
89380: EMPTY
89381: LIST
89382: LIST
89383: PUSH
89384: LD_INT 0
89386: PUSH
89387: LD_INT 1
89389: NEG
89390: PUSH
89391: EMPTY
89392: LIST
89393: LIST
89394: PUSH
89395: LD_INT 1
89397: PUSH
89398: LD_INT 0
89400: PUSH
89401: EMPTY
89402: LIST
89403: LIST
89404: PUSH
89405: LD_INT 1
89407: PUSH
89408: LD_INT 1
89410: PUSH
89411: EMPTY
89412: LIST
89413: LIST
89414: PUSH
89415: LD_INT 0
89417: PUSH
89418: LD_INT 1
89420: PUSH
89421: EMPTY
89422: LIST
89423: LIST
89424: PUSH
89425: LD_INT 1
89427: NEG
89428: PUSH
89429: LD_INT 0
89431: PUSH
89432: EMPTY
89433: LIST
89434: LIST
89435: PUSH
89436: LD_INT 1
89438: NEG
89439: PUSH
89440: LD_INT 1
89442: NEG
89443: PUSH
89444: EMPTY
89445: LIST
89446: LIST
89447: PUSH
89448: LD_INT 1
89450: NEG
89451: PUSH
89452: LD_INT 2
89454: NEG
89455: PUSH
89456: EMPTY
89457: LIST
89458: LIST
89459: PUSH
89460: LD_INT 1
89462: PUSH
89463: LD_INT 1
89465: NEG
89466: PUSH
89467: EMPTY
89468: LIST
89469: LIST
89470: PUSH
89471: LD_INT 2
89473: PUSH
89474: LD_INT 0
89476: PUSH
89477: EMPTY
89478: LIST
89479: LIST
89480: PUSH
89481: LD_INT 2
89483: PUSH
89484: LD_INT 1
89486: PUSH
89487: EMPTY
89488: LIST
89489: LIST
89490: PUSH
89491: LD_INT 2
89493: PUSH
89494: LD_INT 2
89496: PUSH
89497: EMPTY
89498: LIST
89499: LIST
89500: PUSH
89501: LD_INT 1
89503: PUSH
89504: LD_INT 2
89506: PUSH
89507: EMPTY
89508: LIST
89509: LIST
89510: PUSH
89511: LD_INT 1
89513: NEG
89514: PUSH
89515: LD_INT 1
89517: PUSH
89518: EMPTY
89519: LIST
89520: LIST
89521: PUSH
89522: LD_INT 2
89524: NEG
89525: PUSH
89526: LD_INT 0
89528: PUSH
89529: EMPTY
89530: LIST
89531: LIST
89532: PUSH
89533: LD_INT 2
89535: NEG
89536: PUSH
89537: LD_INT 1
89539: NEG
89540: PUSH
89541: EMPTY
89542: LIST
89543: LIST
89544: PUSH
89545: LD_INT 2
89547: NEG
89548: PUSH
89549: LD_INT 2
89551: NEG
89552: PUSH
89553: EMPTY
89554: LIST
89555: LIST
89556: PUSH
89557: LD_INT 2
89559: NEG
89560: PUSH
89561: LD_INT 3
89563: NEG
89564: PUSH
89565: EMPTY
89566: LIST
89567: LIST
89568: PUSH
89569: LD_INT 2
89571: PUSH
89572: LD_INT 1
89574: NEG
89575: PUSH
89576: EMPTY
89577: LIST
89578: LIST
89579: PUSH
89580: LD_INT 3
89582: PUSH
89583: LD_INT 0
89585: PUSH
89586: EMPTY
89587: LIST
89588: LIST
89589: PUSH
89590: LD_INT 3
89592: PUSH
89593: LD_INT 1
89595: PUSH
89596: EMPTY
89597: LIST
89598: LIST
89599: PUSH
89600: LD_INT 3
89602: PUSH
89603: LD_INT 2
89605: PUSH
89606: EMPTY
89607: LIST
89608: LIST
89609: PUSH
89610: LD_INT 3
89612: PUSH
89613: LD_INT 3
89615: PUSH
89616: EMPTY
89617: LIST
89618: LIST
89619: PUSH
89620: LD_INT 2
89622: PUSH
89623: LD_INT 3
89625: PUSH
89626: EMPTY
89627: LIST
89628: LIST
89629: PUSH
89630: LD_INT 2
89632: NEG
89633: PUSH
89634: LD_INT 1
89636: PUSH
89637: EMPTY
89638: LIST
89639: LIST
89640: PUSH
89641: LD_INT 3
89643: NEG
89644: PUSH
89645: LD_INT 0
89647: PUSH
89648: EMPTY
89649: LIST
89650: LIST
89651: PUSH
89652: LD_INT 3
89654: NEG
89655: PUSH
89656: LD_INT 1
89658: NEG
89659: PUSH
89660: EMPTY
89661: LIST
89662: LIST
89663: PUSH
89664: LD_INT 3
89666: NEG
89667: PUSH
89668: LD_INT 2
89670: NEG
89671: PUSH
89672: EMPTY
89673: LIST
89674: LIST
89675: PUSH
89676: LD_INT 3
89678: NEG
89679: PUSH
89680: LD_INT 3
89682: NEG
89683: PUSH
89684: EMPTY
89685: LIST
89686: LIST
89687: PUSH
89688: EMPTY
89689: LIST
89690: LIST
89691: LIST
89692: LIST
89693: LIST
89694: LIST
89695: LIST
89696: LIST
89697: LIST
89698: LIST
89699: LIST
89700: LIST
89701: LIST
89702: LIST
89703: LIST
89704: LIST
89705: LIST
89706: LIST
89707: LIST
89708: LIST
89709: LIST
89710: LIST
89711: LIST
89712: LIST
89713: LIST
89714: LIST
89715: LIST
89716: LIST
89717: LIST
89718: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89719: LD_ADDR_VAR 0 45
89723: PUSH
89724: LD_INT 0
89726: PUSH
89727: LD_INT 0
89729: PUSH
89730: EMPTY
89731: LIST
89732: LIST
89733: PUSH
89734: LD_INT 0
89736: PUSH
89737: LD_INT 1
89739: NEG
89740: PUSH
89741: EMPTY
89742: LIST
89743: LIST
89744: PUSH
89745: LD_INT 1
89747: PUSH
89748: LD_INT 0
89750: PUSH
89751: EMPTY
89752: LIST
89753: LIST
89754: PUSH
89755: LD_INT 1
89757: PUSH
89758: LD_INT 1
89760: PUSH
89761: EMPTY
89762: LIST
89763: LIST
89764: PUSH
89765: LD_INT 0
89767: PUSH
89768: LD_INT 1
89770: PUSH
89771: EMPTY
89772: LIST
89773: LIST
89774: PUSH
89775: LD_INT 1
89777: NEG
89778: PUSH
89779: LD_INT 0
89781: PUSH
89782: EMPTY
89783: LIST
89784: LIST
89785: PUSH
89786: LD_INT 1
89788: NEG
89789: PUSH
89790: LD_INT 1
89792: NEG
89793: PUSH
89794: EMPTY
89795: LIST
89796: LIST
89797: PUSH
89798: LD_INT 1
89800: NEG
89801: PUSH
89802: LD_INT 2
89804: NEG
89805: PUSH
89806: EMPTY
89807: LIST
89808: LIST
89809: PUSH
89810: LD_INT 0
89812: PUSH
89813: LD_INT 2
89815: NEG
89816: PUSH
89817: EMPTY
89818: LIST
89819: LIST
89820: PUSH
89821: LD_INT 1
89823: PUSH
89824: LD_INT 1
89826: NEG
89827: PUSH
89828: EMPTY
89829: LIST
89830: LIST
89831: PUSH
89832: LD_INT 2
89834: PUSH
89835: LD_INT 1
89837: PUSH
89838: EMPTY
89839: LIST
89840: LIST
89841: PUSH
89842: LD_INT 2
89844: PUSH
89845: LD_INT 2
89847: PUSH
89848: EMPTY
89849: LIST
89850: LIST
89851: PUSH
89852: LD_INT 1
89854: PUSH
89855: LD_INT 2
89857: PUSH
89858: EMPTY
89859: LIST
89860: LIST
89861: PUSH
89862: LD_INT 0
89864: PUSH
89865: LD_INT 2
89867: PUSH
89868: EMPTY
89869: LIST
89870: LIST
89871: PUSH
89872: LD_INT 1
89874: NEG
89875: PUSH
89876: LD_INT 1
89878: PUSH
89879: EMPTY
89880: LIST
89881: LIST
89882: PUSH
89883: LD_INT 2
89885: NEG
89886: PUSH
89887: LD_INT 1
89889: NEG
89890: PUSH
89891: EMPTY
89892: LIST
89893: LIST
89894: PUSH
89895: LD_INT 2
89897: NEG
89898: PUSH
89899: LD_INT 2
89901: NEG
89902: PUSH
89903: EMPTY
89904: LIST
89905: LIST
89906: PUSH
89907: LD_INT 2
89909: NEG
89910: PUSH
89911: LD_INT 3
89913: NEG
89914: PUSH
89915: EMPTY
89916: LIST
89917: LIST
89918: PUSH
89919: LD_INT 1
89921: NEG
89922: PUSH
89923: LD_INT 3
89925: NEG
89926: PUSH
89927: EMPTY
89928: LIST
89929: LIST
89930: PUSH
89931: LD_INT 0
89933: PUSH
89934: LD_INT 3
89936: NEG
89937: PUSH
89938: EMPTY
89939: LIST
89940: LIST
89941: PUSH
89942: LD_INT 1
89944: PUSH
89945: LD_INT 2
89947: NEG
89948: PUSH
89949: EMPTY
89950: LIST
89951: LIST
89952: PUSH
89953: LD_INT 3
89955: PUSH
89956: LD_INT 2
89958: PUSH
89959: EMPTY
89960: LIST
89961: LIST
89962: PUSH
89963: LD_INT 3
89965: PUSH
89966: LD_INT 3
89968: PUSH
89969: EMPTY
89970: LIST
89971: LIST
89972: PUSH
89973: LD_INT 2
89975: PUSH
89976: LD_INT 3
89978: PUSH
89979: EMPTY
89980: LIST
89981: LIST
89982: PUSH
89983: LD_INT 1
89985: PUSH
89986: LD_INT 3
89988: PUSH
89989: EMPTY
89990: LIST
89991: LIST
89992: PUSH
89993: LD_INT 0
89995: PUSH
89996: LD_INT 3
89998: PUSH
89999: EMPTY
90000: LIST
90001: LIST
90002: PUSH
90003: LD_INT 1
90005: NEG
90006: PUSH
90007: LD_INT 2
90009: PUSH
90010: EMPTY
90011: LIST
90012: LIST
90013: PUSH
90014: LD_INT 3
90016: NEG
90017: PUSH
90018: LD_INT 2
90020: NEG
90021: PUSH
90022: EMPTY
90023: LIST
90024: LIST
90025: PUSH
90026: LD_INT 3
90028: NEG
90029: PUSH
90030: LD_INT 3
90032: NEG
90033: PUSH
90034: EMPTY
90035: LIST
90036: LIST
90037: PUSH
90038: EMPTY
90039: LIST
90040: LIST
90041: LIST
90042: LIST
90043: LIST
90044: LIST
90045: LIST
90046: LIST
90047: LIST
90048: LIST
90049: LIST
90050: LIST
90051: LIST
90052: LIST
90053: LIST
90054: LIST
90055: LIST
90056: LIST
90057: LIST
90058: LIST
90059: LIST
90060: LIST
90061: LIST
90062: LIST
90063: LIST
90064: LIST
90065: LIST
90066: LIST
90067: LIST
90068: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90069: LD_ADDR_VAR 0 46
90073: PUSH
90074: LD_INT 0
90076: PUSH
90077: LD_INT 0
90079: PUSH
90080: EMPTY
90081: LIST
90082: LIST
90083: PUSH
90084: LD_INT 0
90086: PUSH
90087: LD_INT 1
90089: NEG
90090: PUSH
90091: EMPTY
90092: LIST
90093: LIST
90094: PUSH
90095: LD_INT 1
90097: PUSH
90098: LD_INT 0
90100: PUSH
90101: EMPTY
90102: LIST
90103: LIST
90104: PUSH
90105: LD_INT 1
90107: PUSH
90108: LD_INT 1
90110: PUSH
90111: EMPTY
90112: LIST
90113: LIST
90114: PUSH
90115: LD_INT 0
90117: PUSH
90118: LD_INT 1
90120: PUSH
90121: EMPTY
90122: LIST
90123: LIST
90124: PUSH
90125: LD_INT 1
90127: NEG
90128: PUSH
90129: LD_INT 0
90131: PUSH
90132: EMPTY
90133: LIST
90134: LIST
90135: PUSH
90136: LD_INT 1
90138: NEG
90139: PUSH
90140: LD_INT 1
90142: NEG
90143: PUSH
90144: EMPTY
90145: LIST
90146: LIST
90147: PUSH
90148: LD_INT 1
90150: NEG
90151: PUSH
90152: LD_INT 2
90154: NEG
90155: PUSH
90156: EMPTY
90157: LIST
90158: LIST
90159: PUSH
90160: LD_INT 0
90162: PUSH
90163: LD_INT 2
90165: NEG
90166: PUSH
90167: EMPTY
90168: LIST
90169: LIST
90170: PUSH
90171: LD_INT 1
90173: PUSH
90174: LD_INT 1
90176: NEG
90177: PUSH
90178: EMPTY
90179: LIST
90180: LIST
90181: PUSH
90182: LD_INT 2
90184: PUSH
90185: LD_INT 0
90187: PUSH
90188: EMPTY
90189: LIST
90190: LIST
90191: PUSH
90192: LD_INT 2
90194: PUSH
90195: LD_INT 1
90197: PUSH
90198: EMPTY
90199: LIST
90200: LIST
90201: PUSH
90202: LD_INT 1
90204: PUSH
90205: LD_INT 2
90207: PUSH
90208: EMPTY
90209: LIST
90210: LIST
90211: PUSH
90212: LD_INT 0
90214: PUSH
90215: LD_INT 2
90217: PUSH
90218: EMPTY
90219: LIST
90220: LIST
90221: PUSH
90222: LD_INT 1
90224: NEG
90225: PUSH
90226: LD_INT 1
90228: PUSH
90229: EMPTY
90230: LIST
90231: LIST
90232: PUSH
90233: LD_INT 2
90235: NEG
90236: PUSH
90237: LD_INT 0
90239: PUSH
90240: EMPTY
90241: LIST
90242: LIST
90243: PUSH
90244: LD_INT 2
90246: NEG
90247: PUSH
90248: LD_INT 1
90250: NEG
90251: PUSH
90252: EMPTY
90253: LIST
90254: LIST
90255: PUSH
90256: LD_INT 1
90258: NEG
90259: PUSH
90260: LD_INT 3
90262: NEG
90263: PUSH
90264: EMPTY
90265: LIST
90266: LIST
90267: PUSH
90268: LD_INT 0
90270: PUSH
90271: LD_INT 3
90273: NEG
90274: PUSH
90275: EMPTY
90276: LIST
90277: LIST
90278: PUSH
90279: LD_INT 1
90281: PUSH
90282: LD_INT 2
90284: NEG
90285: PUSH
90286: EMPTY
90287: LIST
90288: LIST
90289: PUSH
90290: LD_INT 2
90292: PUSH
90293: LD_INT 1
90295: NEG
90296: PUSH
90297: EMPTY
90298: LIST
90299: LIST
90300: PUSH
90301: LD_INT 3
90303: PUSH
90304: LD_INT 0
90306: PUSH
90307: EMPTY
90308: LIST
90309: LIST
90310: PUSH
90311: LD_INT 3
90313: PUSH
90314: LD_INT 1
90316: PUSH
90317: EMPTY
90318: LIST
90319: LIST
90320: PUSH
90321: LD_INT 1
90323: PUSH
90324: LD_INT 3
90326: PUSH
90327: EMPTY
90328: LIST
90329: LIST
90330: PUSH
90331: LD_INT 0
90333: PUSH
90334: LD_INT 3
90336: PUSH
90337: EMPTY
90338: LIST
90339: LIST
90340: PUSH
90341: LD_INT 1
90343: NEG
90344: PUSH
90345: LD_INT 2
90347: PUSH
90348: EMPTY
90349: LIST
90350: LIST
90351: PUSH
90352: LD_INT 2
90354: NEG
90355: PUSH
90356: LD_INT 1
90358: PUSH
90359: EMPTY
90360: LIST
90361: LIST
90362: PUSH
90363: LD_INT 3
90365: NEG
90366: PUSH
90367: LD_INT 0
90369: PUSH
90370: EMPTY
90371: LIST
90372: LIST
90373: PUSH
90374: LD_INT 3
90376: NEG
90377: PUSH
90378: LD_INT 1
90380: NEG
90381: PUSH
90382: EMPTY
90383: LIST
90384: LIST
90385: PUSH
90386: EMPTY
90387: LIST
90388: LIST
90389: LIST
90390: LIST
90391: LIST
90392: LIST
90393: LIST
90394: LIST
90395: LIST
90396: LIST
90397: LIST
90398: LIST
90399: LIST
90400: LIST
90401: LIST
90402: LIST
90403: LIST
90404: LIST
90405: LIST
90406: LIST
90407: LIST
90408: LIST
90409: LIST
90410: LIST
90411: LIST
90412: LIST
90413: LIST
90414: LIST
90415: LIST
90416: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90417: LD_ADDR_VAR 0 47
90421: PUSH
90422: LD_INT 0
90424: PUSH
90425: LD_INT 0
90427: PUSH
90428: EMPTY
90429: LIST
90430: LIST
90431: PUSH
90432: LD_INT 0
90434: PUSH
90435: LD_INT 1
90437: NEG
90438: PUSH
90439: EMPTY
90440: LIST
90441: LIST
90442: PUSH
90443: LD_INT 1
90445: PUSH
90446: LD_INT 0
90448: PUSH
90449: EMPTY
90450: LIST
90451: LIST
90452: PUSH
90453: LD_INT 1
90455: PUSH
90456: LD_INT 1
90458: PUSH
90459: EMPTY
90460: LIST
90461: LIST
90462: PUSH
90463: LD_INT 0
90465: PUSH
90466: LD_INT 1
90468: PUSH
90469: EMPTY
90470: LIST
90471: LIST
90472: PUSH
90473: LD_INT 1
90475: NEG
90476: PUSH
90477: LD_INT 0
90479: PUSH
90480: EMPTY
90481: LIST
90482: LIST
90483: PUSH
90484: LD_INT 1
90486: NEG
90487: PUSH
90488: LD_INT 1
90490: NEG
90491: PUSH
90492: EMPTY
90493: LIST
90494: LIST
90495: PUSH
90496: LD_INT 1
90498: NEG
90499: PUSH
90500: LD_INT 2
90502: NEG
90503: PUSH
90504: EMPTY
90505: LIST
90506: LIST
90507: PUSH
90508: LD_INT 0
90510: PUSH
90511: LD_INT 2
90513: NEG
90514: PUSH
90515: EMPTY
90516: LIST
90517: LIST
90518: PUSH
90519: LD_INT 1
90521: PUSH
90522: LD_INT 1
90524: NEG
90525: PUSH
90526: EMPTY
90527: LIST
90528: LIST
90529: PUSH
90530: LD_INT 2
90532: NEG
90533: PUSH
90534: LD_INT 1
90536: NEG
90537: PUSH
90538: EMPTY
90539: LIST
90540: LIST
90541: PUSH
90542: LD_INT 2
90544: NEG
90545: PUSH
90546: LD_INT 2
90548: NEG
90549: PUSH
90550: EMPTY
90551: LIST
90552: LIST
90553: PUSH
90554: EMPTY
90555: LIST
90556: LIST
90557: LIST
90558: LIST
90559: LIST
90560: LIST
90561: LIST
90562: LIST
90563: LIST
90564: LIST
90565: LIST
90566: LIST
90567: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
90568: LD_ADDR_VAR 0 48
90572: PUSH
90573: LD_INT 0
90575: PUSH
90576: LD_INT 0
90578: PUSH
90579: EMPTY
90580: LIST
90581: LIST
90582: PUSH
90583: LD_INT 0
90585: PUSH
90586: LD_INT 1
90588: NEG
90589: PUSH
90590: EMPTY
90591: LIST
90592: LIST
90593: PUSH
90594: LD_INT 1
90596: PUSH
90597: LD_INT 0
90599: PUSH
90600: EMPTY
90601: LIST
90602: LIST
90603: PUSH
90604: LD_INT 1
90606: PUSH
90607: LD_INT 1
90609: PUSH
90610: EMPTY
90611: LIST
90612: LIST
90613: PUSH
90614: LD_INT 0
90616: PUSH
90617: LD_INT 1
90619: PUSH
90620: EMPTY
90621: LIST
90622: LIST
90623: PUSH
90624: LD_INT 1
90626: NEG
90627: PUSH
90628: LD_INT 0
90630: PUSH
90631: EMPTY
90632: LIST
90633: LIST
90634: PUSH
90635: LD_INT 1
90637: NEG
90638: PUSH
90639: LD_INT 1
90641: NEG
90642: PUSH
90643: EMPTY
90644: LIST
90645: LIST
90646: PUSH
90647: LD_INT 1
90649: NEG
90650: PUSH
90651: LD_INT 2
90653: NEG
90654: PUSH
90655: EMPTY
90656: LIST
90657: LIST
90658: PUSH
90659: LD_INT 0
90661: PUSH
90662: LD_INT 2
90664: NEG
90665: PUSH
90666: EMPTY
90667: LIST
90668: LIST
90669: PUSH
90670: LD_INT 1
90672: PUSH
90673: LD_INT 1
90675: NEG
90676: PUSH
90677: EMPTY
90678: LIST
90679: LIST
90680: PUSH
90681: LD_INT 2
90683: PUSH
90684: LD_INT 0
90686: PUSH
90687: EMPTY
90688: LIST
90689: LIST
90690: PUSH
90691: LD_INT 2
90693: PUSH
90694: LD_INT 1
90696: PUSH
90697: EMPTY
90698: LIST
90699: LIST
90700: PUSH
90701: EMPTY
90702: LIST
90703: LIST
90704: LIST
90705: LIST
90706: LIST
90707: LIST
90708: LIST
90709: LIST
90710: LIST
90711: LIST
90712: LIST
90713: LIST
90714: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
90715: LD_ADDR_VAR 0 49
90719: PUSH
90720: LD_INT 0
90722: PUSH
90723: LD_INT 0
90725: PUSH
90726: EMPTY
90727: LIST
90728: LIST
90729: PUSH
90730: LD_INT 0
90732: PUSH
90733: LD_INT 1
90735: NEG
90736: PUSH
90737: EMPTY
90738: LIST
90739: LIST
90740: PUSH
90741: LD_INT 1
90743: PUSH
90744: LD_INT 0
90746: PUSH
90747: EMPTY
90748: LIST
90749: LIST
90750: PUSH
90751: LD_INT 1
90753: PUSH
90754: LD_INT 1
90756: PUSH
90757: EMPTY
90758: LIST
90759: LIST
90760: PUSH
90761: LD_INT 0
90763: PUSH
90764: LD_INT 1
90766: PUSH
90767: EMPTY
90768: LIST
90769: LIST
90770: PUSH
90771: LD_INT 1
90773: NEG
90774: PUSH
90775: LD_INT 0
90777: PUSH
90778: EMPTY
90779: LIST
90780: LIST
90781: PUSH
90782: LD_INT 1
90784: NEG
90785: PUSH
90786: LD_INT 1
90788: NEG
90789: PUSH
90790: EMPTY
90791: LIST
90792: LIST
90793: PUSH
90794: LD_INT 1
90796: PUSH
90797: LD_INT 1
90799: NEG
90800: PUSH
90801: EMPTY
90802: LIST
90803: LIST
90804: PUSH
90805: LD_INT 2
90807: PUSH
90808: LD_INT 0
90810: PUSH
90811: EMPTY
90812: LIST
90813: LIST
90814: PUSH
90815: LD_INT 2
90817: PUSH
90818: LD_INT 1
90820: PUSH
90821: EMPTY
90822: LIST
90823: LIST
90824: PUSH
90825: LD_INT 2
90827: PUSH
90828: LD_INT 2
90830: PUSH
90831: EMPTY
90832: LIST
90833: LIST
90834: PUSH
90835: LD_INT 1
90837: PUSH
90838: LD_INT 2
90840: PUSH
90841: EMPTY
90842: LIST
90843: LIST
90844: PUSH
90845: EMPTY
90846: LIST
90847: LIST
90848: LIST
90849: LIST
90850: LIST
90851: LIST
90852: LIST
90853: LIST
90854: LIST
90855: LIST
90856: LIST
90857: LIST
90858: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
90859: LD_ADDR_VAR 0 50
90863: PUSH
90864: LD_INT 0
90866: PUSH
90867: LD_INT 0
90869: PUSH
90870: EMPTY
90871: LIST
90872: LIST
90873: PUSH
90874: LD_INT 0
90876: PUSH
90877: LD_INT 1
90879: NEG
90880: PUSH
90881: EMPTY
90882: LIST
90883: LIST
90884: PUSH
90885: LD_INT 1
90887: PUSH
90888: LD_INT 0
90890: PUSH
90891: EMPTY
90892: LIST
90893: LIST
90894: PUSH
90895: LD_INT 1
90897: PUSH
90898: LD_INT 1
90900: PUSH
90901: EMPTY
90902: LIST
90903: LIST
90904: PUSH
90905: LD_INT 0
90907: PUSH
90908: LD_INT 1
90910: PUSH
90911: EMPTY
90912: LIST
90913: LIST
90914: PUSH
90915: LD_INT 1
90917: NEG
90918: PUSH
90919: LD_INT 0
90921: PUSH
90922: EMPTY
90923: LIST
90924: LIST
90925: PUSH
90926: LD_INT 1
90928: NEG
90929: PUSH
90930: LD_INT 1
90932: NEG
90933: PUSH
90934: EMPTY
90935: LIST
90936: LIST
90937: PUSH
90938: LD_INT 2
90940: PUSH
90941: LD_INT 1
90943: PUSH
90944: EMPTY
90945: LIST
90946: LIST
90947: PUSH
90948: LD_INT 2
90950: PUSH
90951: LD_INT 2
90953: PUSH
90954: EMPTY
90955: LIST
90956: LIST
90957: PUSH
90958: LD_INT 1
90960: PUSH
90961: LD_INT 2
90963: PUSH
90964: EMPTY
90965: LIST
90966: LIST
90967: PUSH
90968: LD_INT 0
90970: PUSH
90971: LD_INT 2
90973: PUSH
90974: EMPTY
90975: LIST
90976: LIST
90977: PUSH
90978: LD_INT 1
90980: NEG
90981: PUSH
90982: LD_INT 1
90984: PUSH
90985: EMPTY
90986: LIST
90987: LIST
90988: PUSH
90989: EMPTY
90990: LIST
90991: LIST
90992: LIST
90993: LIST
90994: LIST
90995: LIST
90996: LIST
90997: LIST
90998: LIST
90999: LIST
91000: LIST
91001: LIST
91002: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
91003: LD_ADDR_VAR 0 51
91007: PUSH
91008: LD_INT 0
91010: PUSH
91011: LD_INT 0
91013: PUSH
91014: EMPTY
91015: LIST
91016: LIST
91017: PUSH
91018: LD_INT 0
91020: PUSH
91021: LD_INT 1
91023: NEG
91024: PUSH
91025: EMPTY
91026: LIST
91027: LIST
91028: PUSH
91029: LD_INT 1
91031: PUSH
91032: LD_INT 0
91034: PUSH
91035: EMPTY
91036: LIST
91037: LIST
91038: PUSH
91039: LD_INT 1
91041: PUSH
91042: LD_INT 1
91044: PUSH
91045: EMPTY
91046: LIST
91047: LIST
91048: PUSH
91049: LD_INT 0
91051: PUSH
91052: LD_INT 1
91054: PUSH
91055: EMPTY
91056: LIST
91057: LIST
91058: PUSH
91059: LD_INT 1
91061: NEG
91062: PUSH
91063: LD_INT 0
91065: PUSH
91066: EMPTY
91067: LIST
91068: LIST
91069: PUSH
91070: LD_INT 1
91072: NEG
91073: PUSH
91074: LD_INT 1
91076: NEG
91077: PUSH
91078: EMPTY
91079: LIST
91080: LIST
91081: PUSH
91082: LD_INT 1
91084: PUSH
91085: LD_INT 2
91087: PUSH
91088: EMPTY
91089: LIST
91090: LIST
91091: PUSH
91092: LD_INT 0
91094: PUSH
91095: LD_INT 2
91097: PUSH
91098: EMPTY
91099: LIST
91100: LIST
91101: PUSH
91102: LD_INT 1
91104: NEG
91105: PUSH
91106: LD_INT 1
91108: PUSH
91109: EMPTY
91110: LIST
91111: LIST
91112: PUSH
91113: LD_INT 2
91115: NEG
91116: PUSH
91117: LD_INT 0
91119: PUSH
91120: EMPTY
91121: LIST
91122: LIST
91123: PUSH
91124: LD_INT 2
91126: NEG
91127: PUSH
91128: LD_INT 1
91130: NEG
91131: PUSH
91132: EMPTY
91133: LIST
91134: LIST
91135: PUSH
91136: EMPTY
91137: LIST
91138: LIST
91139: LIST
91140: LIST
91141: LIST
91142: LIST
91143: LIST
91144: LIST
91145: LIST
91146: LIST
91147: LIST
91148: LIST
91149: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91150: LD_ADDR_VAR 0 52
91154: PUSH
91155: LD_INT 0
91157: PUSH
91158: LD_INT 0
91160: PUSH
91161: EMPTY
91162: LIST
91163: LIST
91164: PUSH
91165: LD_INT 0
91167: PUSH
91168: LD_INT 1
91170: NEG
91171: PUSH
91172: EMPTY
91173: LIST
91174: LIST
91175: PUSH
91176: LD_INT 1
91178: PUSH
91179: LD_INT 0
91181: PUSH
91182: EMPTY
91183: LIST
91184: LIST
91185: PUSH
91186: LD_INT 1
91188: PUSH
91189: LD_INT 1
91191: PUSH
91192: EMPTY
91193: LIST
91194: LIST
91195: PUSH
91196: LD_INT 0
91198: PUSH
91199: LD_INT 1
91201: PUSH
91202: EMPTY
91203: LIST
91204: LIST
91205: PUSH
91206: LD_INT 1
91208: NEG
91209: PUSH
91210: LD_INT 0
91212: PUSH
91213: EMPTY
91214: LIST
91215: LIST
91216: PUSH
91217: LD_INT 1
91219: NEG
91220: PUSH
91221: LD_INT 1
91223: NEG
91224: PUSH
91225: EMPTY
91226: LIST
91227: LIST
91228: PUSH
91229: LD_INT 1
91231: NEG
91232: PUSH
91233: LD_INT 2
91235: NEG
91236: PUSH
91237: EMPTY
91238: LIST
91239: LIST
91240: PUSH
91241: LD_INT 1
91243: NEG
91244: PUSH
91245: LD_INT 1
91247: PUSH
91248: EMPTY
91249: LIST
91250: LIST
91251: PUSH
91252: LD_INT 2
91254: NEG
91255: PUSH
91256: LD_INT 0
91258: PUSH
91259: EMPTY
91260: LIST
91261: LIST
91262: PUSH
91263: LD_INT 2
91265: NEG
91266: PUSH
91267: LD_INT 1
91269: NEG
91270: PUSH
91271: EMPTY
91272: LIST
91273: LIST
91274: PUSH
91275: LD_INT 2
91277: NEG
91278: PUSH
91279: LD_INT 2
91281: NEG
91282: PUSH
91283: EMPTY
91284: LIST
91285: LIST
91286: PUSH
91287: EMPTY
91288: LIST
91289: LIST
91290: LIST
91291: LIST
91292: LIST
91293: LIST
91294: LIST
91295: LIST
91296: LIST
91297: LIST
91298: LIST
91299: LIST
91300: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91301: LD_ADDR_VAR 0 53
91305: PUSH
91306: LD_INT 0
91308: PUSH
91309: LD_INT 0
91311: PUSH
91312: EMPTY
91313: LIST
91314: LIST
91315: PUSH
91316: LD_INT 0
91318: PUSH
91319: LD_INT 1
91321: NEG
91322: PUSH
91323: EMPTY
91324: LIST
91325: LIST
91326: PUSH
91327: LD_INT 1
91329: PUSH
91330: LD_INT 0
91332: PUSH
91333: EMPTY
91334: LIST
91335: LIST
91336: PUSH
91337: LD_INT 1
91339: PUSH
91340: LD_INT 1
91342: PUSH
91343: EMPTY
91344: LIST
91345: LIST
91346: PUSH
91347: LD_INT 0
91349: PUSH
91350: LD_INT 1
91352: PUSH
91353: EMPTY
91354: LIST
91355: LIST
91356: PUSH
91357: LD_INT 1
91359: NEG
91360: PUSH
91361: LD_INT 0
91363: PUSH
91364: EMPTY
91365: LIST
91366: LIST
91367: PUSH
91368: LD_INT 1
91370: NEG
91371: PUSH
91372: LD_INT 1
91374: NEG
91375: PUSH
91376: EMPTY
91377: LIST
91378: LIST
91379: PUSH
91380: LD_INT 1
91382: NEG
91383: PUSH
91384: LD_INT 2
91386: NEG
91387: PUSH
91388: EMPTY
91389: LIST
91390: LIST
91391: PUSH
91392: LD_INT 0
91394: PUSH
91395: LD_INT 2
91397: NEG
91398: PUSH
91399: EMPTY
91400: LIST
91401: LIST
91402: PUSH
91403: LD_INT 1
91405: PUSH
91406: LD_INT 1
91408: NEG
91409: PUSH
91410: EMPTY
91411: LIST
91412: LIST
91413: PUSH
91414: LD_INT 2
91416: PUSH
91417: LD_INT 0
91419: PUSH
91420: EMPTY
91421: LIST
91422: LIST
91423: PUSH
91424: LD_INT 2
91426: PUSH
91427: LD_INT 1
91429: PUSH
91430: EMPTY
91431: LIST
91432: LIST
91433: PUSH
91434: LD_INT 2
91436: PUSH
91437: LD_INT 2
91439: PUSH
91440: EMPTY
91441: LIST
91442: LIST
91443: PUSH
91444: LD_INT 1
91446: PUSH
91447: LD_INT 2
91449: PUSH
91450: EMPTY
91451: LIST
91452: LIST
91453: PUSH
91454: LD_INT 0
91456: PUSH
91457: LD_INT 2
91459: PUSH
91460: EMPTY
91461: LIST
91462: LIST
91463: PUSH
91464: LD_INT 1
91466: NEG
91467: PUSH
91468: LD_INT 1
91470: PUSH
91471: EMPTY
91472: LIST
91473: LIST
91474: PUSH
91475: LD_INT 2
91477: NEG
91478: PUSH
91479: LD_INT 0
91481: PUSH
91482: EMPTY
91483: LIST
91484: LIST
91485: PUSH
91486: LD_INT 2
91488: NEG
91489: PUSH
91490: LD_INT 1
91492: NEG
91493: PUSH
91494: EMPTY
91495: LIST
91496: LIST
91497: PUSH
91498: LD_INT 2
91500: NEG
91501: PUSH
91502: LD_INT 2
91504: NEG
91505: PUSH
91506: EMPTY
91507: LIST
91508: LIST
91509: PUSH
91510: EMPTY
91511: LIST
91512: LIST
91513: LIST
91514: LIST
91515: LIST
91516: LIST
91517: LIST
91518: LIST
91519: LIST
91520: LIST
91521: LIST
91522: LIST
91523: LIST
91524: LIST
91525: LIST
91526: LIST
91527: LIST
91528: LIST
91529: LIST
91530: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91531: LD_ADDR_VAR 0 54
91535: PUSH
91536: LD_INT 0
91538: PUSH
91539: LD_INT 0
91541: PUSH
91542: EMPTY
91543: LIST
91544: LIST
91545: PUSH
91546: LD_INT 0
91548: PUSH
91549: LD_INT 1
91551: NEG
91552: PUSH
91553: EMPTY
91554: LIST
91555: LIST
91556: PUSH
91557: LD_INT 1
91559: PUSH
91560: LD_INT 0
91562: PUSH
91563: EMPTY
91564: LIST
91565: LIST
91566: PUSH
91567: LD_INT 1
91569: PUSH
91570: LD_INT 1
91572: PUSH
91573: EMPTY
91574: LIST
91575: LIST
91576: PUSH
91577: LD_INT 0
91579: PUSH
91580: LD_INT 1
91582: PUSH
91583: EMPTY
91584: LIST
91585: LIST
91586: PUSH
91587: LD_INT 1
91589: NEG
91590: PUSH
91591: LD_INT 0
91593: PUSH
91594: EMPTY
91595: LIST
91596: LIST
91597: PUSH
91598: LD_INT 1
91600: NEG
91601: PUSH
91602: LD_INT 1
91604: NEG
91605: PUSH
91606: EMPTY
91607: LIST
91608: LIST
91609: PUSH
91610: LD_INT 1
91612: NEG
91613: PUSH
91614: LD_INT 2
91616: NEG
91617: PUSH
91618: EMPTY
91619: LIST
91620: LIST
91621: PUSH
91622: LD_INT 0
91624: PUSH
91625: LD_INT 2
91627: NEG
91628: PUSH
91629: EMPTY
91630: LIST
91631: LIST
91632: PUSH
91633: LD_INT 1
91635: PUSH
91636: LD_INT 1
91638: NEG
91639: PUSH
91640: EMPTY
91641: LIST
91642: LIST
91643: PUSH
91644: LD_INT 2
91646: PUSH
91647: LD_INT 0
91649: PUSH
91650: EMPTY
91651: LIST
91652: LIST
91653: PUSH
91654: LD_INT 2
91656: PUSH
91657: LD_INT 1
91659: PUSH
91660: EMPTY
91661: LIST
91662: LIST
91663: PUSH
91664: LD_INT 2
91666: PUSH
91667: LD_INT 2
91669: PUSH
91670: EMPTY
91671: LIST
91672: LIST
91673: PUSH
91674: LD_INT 1
91676: PUSH
91677: LD_INT 2
91679: PUSH
91680: EMPTY
91681: LIST
91682: LIST
91683: PUSH
91684: LD_INT 0
91686: PUSH
91687: LD_INT 2
91689: PUSH
91690: EMPTY
91691: LIST
91692: LIST
91693: PUSH
91694: LD_INT 1
91696: NEG
91697: PUSH
91698: LD_INT 1
91700: PUSH
91701: EMPTY
91702: LIST
91703: LIST
91704: PUSH
91705: LD_INT 2
91707: NEG
91708: PUSH
91709: LD_INT 0
91711: PUSH
91712: EMPTY
91713: LIST
91714: LIST
91715: PUSH
91716: LD_INT 2
91718: NEG
91719: PUSH
91720: LD_INT 1
91722: NEG
91723: PUSH
91724: EMPTY
91725: LIST
91726: LIST
91727: PUSH
91728: LD_INT 2
91730: NEG
91731: PUSH
91732: LD_INT 2
91734: NEG
91735: PUSH
91736: EMPTY
91737: LIST
91738: LIST
91739: PUSH
91740: EMPTY
91741: LIST
91742: LIST
91743: LIST
91744: LIST
91745: LIST
91746: LIST
91747: LIST
91748: LIST
91749: LIST
91750: LIST
91751: LIST
91752: LIST
91753: LIST
91754: LIST
91755: LIST
91756: LIST
91757: LIST
91758: LIST
91759: LIST
91760: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91761: LD_ADDR_VAR 0 55
91765: PUSH
91766: LD_INT 0
91768: PUSH
91769: LD_INT 0
91771: PUSH
91772: EMPTY
91773: LIST
91774: LIST
91775: PUSH
91776: LD_INT 0
91778: PUSH
91779: LD_INT 1
91781: NEG
91782: PUSH
91783: EMPTY
91784: LIST
91785: LIST
91786: PUSH
91787: LD_INT 1
91789: PUSH
91790: LD_INT 0
91792: PUSH
91793: EMPTY
91794: LIST
91795: LIST
91796: PUSH
91797: LD_INT 1
91799: PUSH
91800: LD_INT 1
91802: PUSH
91803: EMPTY
91804: LIST
91805: LIST
91806: PUSH
91807: LD_INT 0
91809: PUSH
91810: LD_INT 1
91812: PUSH
91813: EMPTY
91814: LIST
91815: LIST
91816: PUSH
91817: LD_INT 1
91819: NEG
91820: PUSH
91821: LD_INT 0
91823: PUSH
91824: EMPTY
91825: LIST
91826: LIST
91827: PUSH
91828: LD_INT 1
91830: NEG
91831: PUSH
91832: LD_INT 1
91834: NEG
91835: PUSH
91836: EMPTY
91837: LIST
91838: LIST
91839: PUSH
91840: LD_INT 1
91842: NEG
91843: PUSH
91844: LD_INT 2
91846: NEG
91847: PUSH
91848: EMPTY
91849: LIST
91850: LIST
91851: PUSH
91852: LD_INT 0
91854: PUSH
91855: LD_INT 2
91857: NEG
91858: PUSH
91859: EMPTY
91860: LIST
91861: LIST
91862: PUSH
91863: LD_INT 1
91865: PUSH
91866: LD_INT 1
91868: NEG
91869: PUSH
91870: EMPTY
91871: LIST
91872: LIST
91873: PUSH
91874: LD_INT 2
91876: PUSH
91877: LD_INT 0
91879: PUSH
91880: EMPTY
91881: LIST
91882: LIST
91883: PUSH
91884: LD_INT 2
91886: PUSH
91887: LD_INT 1
91889: PUSH
91890: EMPTY
91891: LIST
91892: LIST
91893: PUSH
91894: LD_INT 2
91896: PUSH
91897: LD_INT 2
91899: PUSH
91900: EMPTY
91901: LIST
91902: LIST
91903: PUSH
91904: LD_INT 1
91906: PUSH
91907: LD_INT 2
91909: PUSH
91910: EMPTY
91911: LIST
91912: LIST
91913: PUSH
91914: LD_INT 0
91916: PUSH
91917: LD_INT 2
91919: PUSH
91920: EMPTY
91921: LIST
91922: LIST
91923: PUSH
91924: LD_INT 1
91926: NEG
91927: PUSH
91928: LD_INT 1
91930: PUSH
91931: EMPTY
91932: LIST
91933: LIST
91934: PUSH
91935: LD_INT 2
91937: NEG
91938: PUSH
91939: LD_INT 0
91941: PUSH
91942: EMPTY
91943: LIST
91944: LIST
91945: PUSH
91946: LD_INT 2
91948: NEG
91949: PUSH
91950: LD_INT 1
91952: NEG
91953: PUSH
91954: EMPTY
91955: LIST
91956: LIST
91957: PUSH
91958: LD_INT 2
91960: NEG
91961: PUSH
91962: LD_INT 2
91964: NEG
91965: PUSH
91966: EMPTY
91967: LIST
91968: LIST
91969: PUSH
91970: EMPTY
91971: LIST
91972: LIST
91973: LIST
91974: LIST
91975: LIST
91976: LIST
91977: LIST
91978: LIST
91979: LIST
91980: LIST
91981: LIST
91982: LIST
91983: LIST
91984: LIST
91985: LIST
91986: LIST
91987: LIST
91988: LIST
91989: LIST
91990: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91991: LD_ADDR_VAR 0 56
91995: PUSH
91996: LD_INT 0
91998: PUSH
91999: LD_INT 0
92001: PUSH
92002: EMPTY
92003: LIST
92004: LIST
92005: PUSH
92006: LD_INT 0
92008: PUSH
92009: LD_INT 1
92011: NEG
92012: PUSH
92013: EMPTY
92014: LIST
92015: LIST
92016: PUSH
92017: LD_INT 1
92019: PUSH
92020: LD_INT 0
92022: PUSH
92023: EMPTY
92024: LIST
92025: LIST
92026: PUSH
92027: LD_INT 1
92029: PUSH
92030: LD_INT 1
92032: PUSH
92033: EMPTY
92034: LIST
92035: LIST
92036: PUSH
92037: LD_INT 0
92039: PUSH
92040: LD_INT 1
92042: PUSH
92043: EMPTY
92044: LIST
92045: LIST
92046: PUSH
92047: LD_INT 1
92049: NEG
92050: PUSH
92051: LD_INT 0
92053: PUSH
92054: EMPTY
92055: LIST
92056: LIST
92057: PUSH
92058: LD_INT 1
92060: NEG
92061: PUSH
92062: LD_INT 1
92064: NEG
92065: PUSH
92066: EMPTY
92067: LIST
92068: LIST
92069: PUSH
92070: LD_INT 1
92072: NEG
92073: PUSH
92074: LD_INT 2
92076: NEG
92077: PUSH
92078: EMPTY
92079: LIST
92080: LIST
92081: PUSH
92082: LD_INT 0
92084: PUSH
92085: LD_INT 2
92087: NEG
92088: PUSH
92089: EMPTY
92090: LIST
92091: LIST
92092: PUSH
92093: LD_INT 1
92095: PUSH
92096: LD_INT 1
92098: NEG
92099: PUSH
92100: EMPTY
92101: LIST
92102: LIST
92103: PUSH
92104: LD_INT 2
92106: PUSH
92107: LD_INT 0
92109: PUSH
92110: EMPTY
92111: LIST
92112: LIST
92113: PUSH
92114: LD_INT 2
92116: PUSH
92117: LD_INT 1
92119: PUSH
92120: EMPTY
92121: LIST
92122: LIST
92123: PUSH
92124: LD_INT 2
92126: PUSH
92127: LD_INT 2
92129: PUSH
92130: EMPTY
92131: LIST
92132: LIST
92133: PUSH
92134: LD_INT 1
92136: PUSH
92137: LD_INT 2
92139: PUSH
92140: EMPTY
92141: LIST
92142: LIST
92143: PUSH
92144: LD_INT 0
92146: PUSH
92147: LD_INT 2
92149: PUSH
92150: EMPTY
92151: LIST
92152: LIST
92153: PUSH
92154: LD_INT 1
92156: NEG
92157: PUSH
92158: LD_INT 1
92160: PUSH
92161: EMPTY
92162: LIST
92163: LIST
92164: PUSH
92165: LD_INT 2
92167: NEG
92168: PUSH
92169: LD_INT 0
92171: PUSH
92172: EMPTY
92173: LIST
92174: LIST
92175: PUSH
92176: LD_INT 2
92178: NEG
92179: PUSH
92180: LD_INT 1
92182: NEG
92183: PUSH
92184: EMPTY
92185: LIST
92186: LIST
92187: PUSH
92188: LD_INT 2
92190: NEG
92191: PUSH
92192: LD_INT 2
92194: NEG
92195: PUSH
92196: EMPTY
92197: LIST
92198: LIST
92199: PUSH
92200: EMPTY
92201: LIST
92202: LIST
92203: LIST
92204: LIST
92205: LIST
92206: LIST
92207: LIST
92208: LIST
92209: LIST
92210: LIST
92211: LIST
92212: LIST
92213: LIST
92214: LIST
92215: LIST
92216: LIST
92217: LIST
92218: LIST
92219: LIST
92220: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92221: LD_ADDR_VAR 0 57
92225: PUSH
92226: LD_INT 0
92228: PUSH
92229: LD_INT 0
92231: PUSH
92232: EMPTY
92233: LIST
92234: LIST
92235: PUSH
92236: LD_INT 0
92238: PUSH
92239: LD_INT 1
92241: NEG
92242: PUSH
92243: EMPTY
92244: LIST
92245: LIST
92246: PUSH
92247: LD_INT 1
92249: PUSH
92250: LD_INT 0
92252: PUSH
92253: EMPTY
92254: LIST
92255: LIST
92256: PUSH
92257: LD_INT 1
92259: PUSH
92260: LD_INT 1
92262: PUSH
92263: EMPTY
92264: LIST
92265: LIST
92266: PUSH
92267: LD_INT 0
92269: PUSH
92270: LD_INT 1
92272: PUSH
92273: EMPTY
92274: LIST
92275: LIST
92276: PUSH
92277: LD_INT 1
92279: NEG
92280: PUSH
92281: LD_INT 0
92283: PUSH
92284: EMPTY
92285: LIST
92286: LIST
92287: PUSH
92288: LD_INT 1
92290: NEG
92291: PUSH
92292: LD_INT 1
92294: NEG
92295: PUSH
92296: EMPTY
92297: LIST
92298: LIST
92299: PUSH
92300: LD_INT 1
92302: NEG
92303: PUSH
92304: LD_INT 2
92306: NEG
92307: PUSH
92308: EMPTY
92309: LIST
92310: LIST
92311: PUSH
92312: LD_INT 0
92314: PUSH
92315: LD_INT 2
92317: NEG
92318: PUSH
92319: EMPTY
92320: LIST
92321: LIST
92322: PUSH
92323: LD_INT 1
92325: PUSH
92326: LD_INT 1
92328: NEG
92329: PUSH
92330: EMPTY
92331: LIST
92332: LIST
92333: PUSH
92334: LD_INT 2
92336: PUSH
92337: LD_INT 0
92339: PUSH
92340: EMPTY
92341: LIST
92342: LIST
92343: PUSH
92344: LD_INT 2
92346: PUSH
92347: LD_INT 1
92349: PUSH
92350: EMPTY
92351: LIST
92352: LIST
92353: PUSH
92354: LD_INT 2
92356: PUSH
92357: LD_INT 2
92359: PUSH
92360: EMPTY
92361: LIST
92362: LIST
92363: PUSH
92364: LD_INT 1
92366: PUSH
92367: LD_INT 2
92369: PUSH
92370: EMPTY
92371: LIST
92372: LIST
92373: PUSH
92374: LD_INT 0
92376: PUSH
92377: LD_INT 2
92379: PUSH
92380: EMPTY
92381: LIST
92382: LIST
92383: PUSH
92384: LD_INT 1
92386: NEG
92387: PUSH
92388: LD_INT 1
92390: PUSH
92391: EMPTY
92392: LIST
92393: LIST
92394: PUSH
92395: LD_INT 2
92397: NEG
92398: PUSH
92399: LD_INT 0
92401: PUSH
92402: EMPTY
92403: LIST
92404: LIST
92405: PUSH
92406: LD_INT 2
92408: NEG
92409: PUSH
92410: LD_INT 1
92412: NEG
92413: PUSH
92414: EMPTY
92415: LIST
92416: LIST
92417: PUSH
92418: LD_INT 2
92420: NEG
92421: PUSH
92422: LD_INT 2
92424: NEG
92425: PUSH
92426: EMPTY
92427: LIST
92428: LIST
92429: PUSH
92430: EMPTY
92431: LIST
92432: LIST
92433: LIST
92434: LIST
92435: LIST
92436: LIST
92437: LIST
92438: LIST
92439: LIST
92440: LIST
92441: LIST
92442: LIST
92443: LIST
92444: LIST
92445: LIST
92446: LIST
92447: LIST
92448: LIST
92449: LIST
92450: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92451: LD_ADDR_VAR 0 58
92455: PUSH
92456: LD_INT 0
92458: PUSH
92459: LD_INT 0
92461: PUSH
92462: EMPTY
92463: LIST
92464: LIST
92465: PUSH
92466: LD_INT 0
92468: PUSH
92469: LD_INT 1
92471: NEG
92472: PUSH
92473: EMPTY
92474: LIST
92475: LIST
92476: PUSH
92477: LD_INT 1
92479: PUSH
92480: LD_INT 0
92482: PUSH
92483: EMPTY
92484: LIST
92485: LIST
92486: PUSH
92487: LD_INT 1
92489: PUSH
92490: LD_INT 1
92492: PUSH
92493: EMPTY
92494: LIST
92495: LIST
92496: PUSH
92497: LD_INT 0
92499: PUSH
92500: LD_INT 1
92502: PUSH
92503: EMPTY
92504: LIST
92505: LIST
92506: PUSH
92507: LD_INT 1
92509: NEG
92510: PUSH
92511: LD_INT 0
92513: PUSH
92514: EMPTY
92515: LIST
92516: LIST
92517: PUSH
92518: LD_INT 1
92520: NEG
92521: PUSH
92522: LD_INT 1
92524: NEG
92525: PUSH
92526: EMPTY
92527: LIST
92528: LIST
92529: PUSH
92530: LD_INT 1
92532: NEG
92533: PUSH
92534: LD_INT 2
92536: NEG
92537: PUSH
92538: EMPTY
92539: LIST
92540: LIST
92541: PUSH
92542: LD_INT 0
92544: PUSH
92545: LD_INT 2
92547: NEG
92548: PUSH
92549: EMPTY
92550: LIST
92551: LIST
92552: PUSH
92553: LD_INT 1
92555: PUSH
92556: LD_INT 1
92558: NEG
92559: PUSH
92560: EMPTY
92561: LIST
92562: LIST
92563: PUSH
92564: LD_INT 2
92566: PUSH
92567: LD_INT 0
92569: PUSH
92570: EMPTY
92571: LIST
92572: LIST
92573: PUSH
92574: LD_INT 2
92576: PUSH
92577: LD_INT 1
92579: PUSH
92580: EMPTY
92581: LIST
92582: LIST
92583: PUSH
92584: LD_INT 2
92586: PUSH
92587: LD_INT 2
92589: PUSH
92590: EMPTY
92591: LIST
92592: LIST
92593: PUSH
92594: LD_INT 1
92596: PUSH
92597: LD_INT 2
92599: PUSH
92600: EMPTY
92601: LIST
92602: LIST
92603: PUSH
92604: LD_INT 0
92606: PUSH
92607: LD_INT 2
92609: PUSH
92610: EMPTY
92611: LIST
92612: LIST
92613: PUSH
92614: LD_INT 1
92616: NEG
92617: PUSH
92618: LD_INT 1
92620: PUSH
92621: EMPTY
92622: LIST
92623: LIST
92624: PUSH
92625: LD_INT 2
92627: NEG
92628: PUSH
92629: LD_INT 0
92631: PUSH
92632: EMPTY
92633: LIST
92634: LIST
92635: PUSH
92636: LD_INT 2
92638: NEG
92639: PUSH
92640: LD_INT 1
92642: NEG
92643: PUSH
92644: EMPTY
92645: LIST
92646: LIST
92647: PUSH
92648: LD_INT 2
92650: NEG
92651: PUSH
92652: LD_INT 2
92654: NEG
92655: PUSH
92656: EMPTY
92657: LIST
92658: LIST
92659: PUSH
92660: EMPTY
92661: LIST
92662: LIST
92663: LIST
92664: LIST
92665: LIST
92666: LIST
92667: LIST
92668: LIST
92669: LIST
92670: LIST
92671: LIST
92672: LIST
92673: LIST
92674: LIST
92675: LIST
92676: LIST
92677: LIST
92678: LIST
92679: LIST
92680: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92681: LD_ADDR_VAR 0 59
92685: PUSH
92686: LD_INT 0
92688: PUSH
92689: LD_INT 0
92691: PUSH
92692: EMPTY
92693: LIST
92694: LIST
92695: PUSH
92696: LD_INT 0
92698: PUSH
92699: LD_INT 1
92701: NEG
92702: PUSH
92703: EMPTY
92704: LIST
92705: LIST
92706: PUSH
92707: LD_INT 1
92709: PUSH
92710: LD_INT 0
92712: PUSH
92713: EMPTY
92714: LIST
92715: LIST
92716: PUSH
92717: LD_INT 1
92719: PUSH
92720: LD_INT 1
92722: PUSH
92723: EMPTY
92724: LIST
92725: LIST
92726: PUSH
92727: LD_INT 0
92729: PUSH
92730: LD_INT 1
92732: PUSH
92733: EMPTY
92734: LIST
92735: LIST
92736: PUSH
92737: LD_INT 1
92739: NEG
92740: PUSH
92741: LD_INT 0
92743: PUSH
92744: EMPTY
92745: LIST
92746: LIST
92747: PUSH
92748: LD_INT 1
92750: NEG
92751: PUSH
92752: LD_INT 1
92754: NEG
92755: PUSH
92756: EMPTY
92757: LIST
92758: LIST
92759: PUSH
92760: EMPTY
92761: LIST
92762: LIST
92763: LIST
92764: LIST
92765: LIST
92766: LIST
92767: LIST
92768: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92769: LD_ADDR_VAR 0 60
92773: PUSH
92774: LD_INT 0
92776: PUSH
92777: LD_INT 0
92779: PUSH
92780: EMPTY
92781: LIST
92782: LIST
92783: PUSH
92784: LD_INT 0
92786: PUSH
92787: LD_INT 1
92789: NEG
92790: PUSH
92791: EMPTY
92792: LIST
92793: LIST
92794: PUSH
92795: LD_INT 1
92797: PUSH
92798: LD_INT 0
92800: PUSH
92801: EMPTY
92802: LIST
92803: LIST
92804: PUSH
92805: LD_INT 1
92807: PUSH
92808: LD_INT 1
92810: PUSH
92811: EMPTY
92812: LIST
92813: LIST
92814: PUSH
92815: LD_INT 0
92817: PUSH
92818: LD_INT 1
92820: PUSH
92821: EMPTY
92822: LIST
92823: LIST
92824: PUSH
92825: LD_INT 1
92827: NEG
92828: PUSH
92829: LD_INT 0
92831: PUSH
92832: EMPTY
92833: LIST
92834: LIST
92835: PUSH
92836: LD_INT 1
92838: NEG
92839: PUSH
92840: LD_INT 1
92842: NEG
92843: PUSH
92844: EMPTY
92845: LIST
92846: LIST
92847: PUSH
92848: EMPTY
92849: LIST
92850: LIST
92851: LIST
92852: LIST
92853: LIST
92854: LIST
92855: LIST
92856: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92857: LD_ADDR_VAR 0 61
92861: PUSH
92862: LD_INT 0
92864: PUSH
92865: LD_INT 0
92867: PUSH
92868: EMPTY
92869: LIST
92870: LIST
92871: PUSH
92872: LD_INT 0
92874: PUSH
92875: LD_INT 1
92877: NEG
92878: PUSH
92879: EMPTY
92880: LIST
92881: LIST
92882: PUSH
92883: LD_INT 1
92885: PUSH
92886: LD_INT 0
92888: PUSH
92889: EMPTY
92890: LIST
92891: LIST
92892: PUSH
92893: LD_INT 1
92895: PUSH
92896: LD_INT 1
92898: PUSH
92899: EMPTY
92900: LIST
92901: LIST
92902: PUSH
92903: LD_INT 0
92905: PUSH
92906: LD_INT 1
92908: PUSH
92909: EMPTY
92910: LIST
92911: LIST
92912: PUSH
92913: LD_INT 1
92915: NEG
92916: PUSH
92917: LD_INT 0
92919: PUSH
92920: EMPTY
92921: LIST
92922: LIST
92923: PUSH
92924: LD_INT 1
92926: NEG
92927: PUSH
92928: LD_INT 1
92930: NEG
92931: PUSH
92932: EMPTY
92933: LIST
92934: LIST
92935: PUSH
92936: EMPTY
92937: LIST
92938: LIST
92939: LIST
92940: LIST
92941: LIST
92942: LIST
92943: LIST
92944: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92945: LD_ADDR_VAR 0 62
92949: PUSH
92950: LD_INT 0
92952: PUSH
92953: LD_INT 0
92955: PUSH
92956: EMPTY
92957: LIST
92958: LIST
92959: PUSH
92960: LD_INT 0
92962: PUSH
92963: LD_INT 1
92965: NEG
92966: PUSH
92967: EMPTY
92968: LIST
92969: LIST
92970: PUSH
92971: LD_INT 1
92973: PUSH
92974: LD_INT 0
92976: PUSH
92977: EMPTY
92978: LIST
92979: LIST
92980: PUSH
92981: LD_INT 1
92983: PUSH
92984: LD_INT 1
92986: PUSH
92987: EMPTY
92988: LIST
92989: LIST
92990: PUSH
92991: LD_INT 0
92993: PUSH
92994: LD_INT 1
92996: PUSH
92997: EMPTY
92998: LIST
92999: LIST
93000: PUSH
93001: LD_INT 1
93003: NEG
93004: PUSH
93005: LD_INT 0
93007: PUSH
93008: EMPTY
93009: LIST
93010: LIST
93011: PUSH
93012: LD_INT 1
93014: NEG
93015: PUSH
93016: LD_INT 1
93018: NEG
93019: PUSH
93020: EMPTY
93021: LIST
93022: LIST
93023: PUSH
93024: EMPTY
93025: LIST
93026: LIST
93027: LIST
93028: LIST
93029: LIST
93030: LIST
93031: LIST
93032: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93033: LD_ADDR_VAR 0 63
93037: PUSH
93038: LD_INT 0
93040: PUSH
93041: LD_INT 0
93043: PUSH
93044: EMPTY
93045: LIST
93046: LIST
93047: PUSH
93048: LD_INT 0
93050: PUSH
93051: LD_INT 1
93053: NEG
93054: PUSH
93055: EMPTY
93056: LIST
93057: LIST
93058: PUSH
93059: LD_INT 1
93061: PUSH
93062: LD_INT 0
93064: PUSH
93065: EMPTY
93066: LIST
93067: LIST
93068: PUSH
93069: LD_INT 1
93071: PUSH
93072: LD_INT 1
93074: PUSH
93075: EMPTY
93076: LIST
93077: LIST
93078: PUSH
93079: LD_INT 0
93081: PUSH
93082: LD_INT 1
93084: PUSH
93085: EMPTY
93086: LIST
93087: LIST
93088: PUSH
93089: LD_INT 1
93091: NEG
93092: PUSH
93093: LD_INT 0
93095: PUSH
93096: EMPTY
93097: LIST
93098: LIST
93099: PUSH
93100: LD_INT 1
93102: NEG
93103: PUSH
93104: LD_INT 1
93106: NEG
93107: PUSH
93108: EMPTY
93109: LIST
93110: LIST
93111: PUSH
93112: EMPTY
93113: LIST
93114: LIST
93115: LIST
93116: LIST
93117: LIST
93118: LIST
93119: LIST
93120: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93121: LD_ADDR_VAR 0 64
93125: PUSH
93126: LD_INT 0
93128: PUSH
93129: LD_INT 0
93131: PUSH
93132: EMPTY
93133: LIST
93134: LIST
93135: PUSH
93136: LD_INT 0
93138: PUSH
93139: LD_INT 1
93141: NEG
93142: PUSH
93143: EMPTY
93144: LIST
93145: LIST
93146: PUSH
93147: LD_INT 1
93149: PUSH
93150: LD_INT 0
93152: PUSH
93153: EMPTY
93154: LIST
93155: LIST
93156: PUSH
93157: LD_INT 1
93159: PUSH
93160: LD_INT 1
93162: PUSH
93163: EMPTY
93164: LIST
93165: LIST
93166: PUSH
93167: LD_INT 0
93169: PUSH
93170: LD_INT 1
93172: PUSH
93173: EMPTY
93174: LIST
93175: LIST
93176: PUSH
93177: LD_INT 1
93179: NEG
93180: PUSH
93181: LD_INT 0
93183: PUSH
93184: EMPTY
93185: LIST
93186: LIST
93187: PUSH
93188: LD_INT 1
93190: NEG
93191: PUSH
93192: LD_INT 1
93194: NEG
93195: PUSH
93196: EMPTY
93197: LIST
93198: LIST
93199: PUSH
93200: EMPTY
93201: LIST
93202: LIST
93203: LIST
93204: LIST
93205: LIST
93206: LIST
93207: LIST
93208: ST_TO_ADDR
// end ; 1 :
93209: GO 99106
93211: LD_INT 1
93213: DOUBLE
93214: EQUAL
93215: IFTRUE 93219
93217: GO 95842
93219: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93220: LD_ADDR_VAR 0 11
93224: PUSH
93225: LD_INT 1
93227: NEG
93228: PUSH
93229: LD_INT 3
93231: NEG
93232: PUSH
93233: EMPTY
93234: LIST
93235: LIST
93236: PUSH
93237: LD_INT 0
93239: PUSH
93240: LD_INT 3
93242: NEG
93243: PUSH
93244: EMPTY
93245: LIST
93246: LIST
93247: PUSH
93248: LD_INT 1
93250: PUSH
93251: LD_INT 2
93253: NEG
93254: PUSH
93255: EMPTY
93256: LIST
93257: LIST
93258: PUSH
93259: EMPTY
93260: LIST
93261: LIST
93262: LIST
93263: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93264: LD_ADDR_VAR 0 12
93268: PUSH
93269: LD_INT 2
93271: PUSH
93272: LD_INT 1
93274: NEG
93275: PUSH
93276: EMPTY
93277: LIST
93278: LIST
93279: PUSH
93280: LD_INT 3
93282: PUSH
93283: LD_INT 0
93285: PUSH
93286: EMPTY
93287: LIST
93288: LIST
93289: PUSH
93290: LD_INT 3
93292: PUSH
93293: LD_INT 1
93295: PUSH
93296: EMPTY
93297: LIST
93298: LIST
93299: PUSH
93300: EMPTY
93301: LIST
93302: LIST
93303: LIST
93304: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93305: LD_ADDR_VAR 0 13
93309: PUSH
93310: LD_INT 3
93312: PUSH
93313: LD_INT 2
93315: PUSH
93316: EMPTY
93317: LIST
93318: LIST
93319: PUSH
93320: LD_INT 3
93322: PUSH
93323: LD_INT 3
93325: PUSH
93326: EMPTY
93327: LIST
93328: LIST
93329: PUSH
93330: LD_INT 2
93332: PUSH
93333: LD_INT 3
93335: PUSH
93336: EMPTY
93337: LIST
93338: LIST
93339: PUSH
93340: EMPTY
93341: LIST
93342: LIST
93343: LIST
93344: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93345: LD_ADDR_VAR 0 14
93349: PUSH
93350: LD_INT 1
93352: PUSH
93353: LD_INT 3
93355: PUSH
93356: EMPTY
93357: LIST
93358: LIST
93359: PUSH
93360: LD_INT 0
93362: PUSH
93363: LD_INT 3
93365: PUSH
93366: EMPTY
93367: LIST
93368: LIST
93369: PUSH
93370: LD_INT 1
93372: NEG
93373: PUSH
93374: LD_INT 2
93376: PUSH
93377: EMPTY
93378: LIST
93379: LIST
93380: PUSH
93381: EMPTY
93382: LIST
93383: LIST
93384: LIST
93385: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93386: LD_ADDR_VAR 0 15
93390: PUSH
93391: LD_INT 2
93393: NEG
93394: PUSH
93395: LD_INT 1
93397: PUSH
93398: EMPTY
93399: LIST
93400: LIST
93401: PUSH
93402: LD_INT 3
93404: NEG
93405: PUSH
93406: LD_INT 0
93408: PUSH
93409: EMPTY
93410: LIST
93411: LIST
93412: PUSH
93413: LD_INT 3
93415: NEG
93416: PUSH
93417: LD_INT 1
93419: NEG
93420: PUSH
93421: EMPTY
93422: LIST
93423: LIST
93424: PUSH
93425: EMPTY
93426: LIST
93427: LIST
93428: LIST
93429: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93430: LD_ADDR_VAR 0 16
93434: PUSH
93435: LD_INT 2
93437: NEG
93438: PUSH
93439: LD_INT 3
93441: NEG
93442: PUSH
93443: EMPTY
93444: LIST
93445: LIST
93446: PUSH
93447: LD_INT 3
93449: NEG
93450: PUSH
93451: LD_INT 2
93453: NEG
93454: PUSH
93455: EMPTY
93456: LIST
93457: LIST
93458: PUSH
93459: LD_INT 3
93461: NEG
93462: PUSH
93463: LD_INT 3
93465: NEG
93466: PUSH
93467: EMPTY
93468: LIST
93469: LIST
93470: PUSH
93471: EMPTY
93472: LIST
93473: LIST
93474: LIST
93475: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93476: LD_ADDR_VAR 0 17
93480: PUSH
93481: LD_INT 1
93483: NEG
93484: PUSH
93485: LD_INT 3
93487: NEG
93488: PUSH
93489: EMPTY
93490: LIST
93491: LIST
93492: PUSH
93493: LD_INT 0
93495: PUSH
93496: LD_INT 3
93498: NEG
93499: PUSH
93500: EMPTY
93501: LIST
93502: LIST
93503: PUSH
93504: LD_INT 1
93506: PUSH
93507: LD_INT 2
93509: NEG
93510: PUSH
93511: EMPTY
93512: LIST
93513: LIST
93514: PUSH
93515: EMPTY
93516: LIST
93517: LIST
93518: LIST
93519: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93520: LD_ADDR_VAR 0 18
93524: PUSH
93525: LD_INT 2
93527: PUSH
93528: LD_INT 1
93530: NEG
93531: PUSH
93532: EMPTY
93533: LIST
93534: LIST
93535: PUSH
93536: LD_INT 3
93538: PUSH
93539: LD_INT 0
93541: PUSH
93542: EMPTY
93543: LIST
93544: LIST
93545: PUSH
93546: LD_INT 3
93548: PUSH
93549: LD_INT 1
93551: PUSH
93552: EMPTY
93553: LIST
93554: LIST
93555: PUSH
93556: EMPTY
93557: LIST
93558: LIST
93559: LIST
93560: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93561: LD_ADDR_VAR 0 19
93565: PUSH
93566: LD_INT 3
93568: PUSH
93569: LD_INT 2
93571: PUSH
93572: EMPTY
93573: LIST
93574: LIST
93575: PUSH
93576: LD_INT 3
93578: PUSH
93579: LD_INT 3
93581: PUSH
93582: EMPTY
93583: LIST
93584: LIST
93585: PUSH
93586: LD_INT 2
93588: PUSH
93589: LD_INT 3
93591: PUSH
93592: EMPTY
93593: LIST
93594: LIST
93595: PUSH
93596: EMPTY
93597: LIST
93598: LIST
93599: LIST
93600: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93601: LD_ADDR_VAR 0 20
93605: PUSH
93606: LD_INT 1
93608: PUSH
93609: LD_INT 3
93611: PUSH
93612: EMPTY
93613: LIST
93614: LIST
93615: PUSH
93616: LD_INT 0
93618: PUSH
93619: LD_INT 3
93621: PUSH
93622: EMPTY
93623: LIST
93624: LIST
93625: PUSH
93626: LD_INT 1
93628: NEG
93629: PUSH
93630: LD_INT 2
93632: PUSH
93633: EMPTY
93634: LIST
93635: LIST
93636: PUSH
93637: EMPTY
93638: LIST
93639: LIST
93640: LIST
93641: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93642: LD_ADDR_VAR 0 21
93646: PUSH
93647: LD_INT 2
93649: NEG
93650: PUSH
93651: LD_INT 1
93653: PUSH
93654: EMPTY
93655: LIST
93656: LIST
93657: PUSH
93658: LD_INT 3
93660: NEG
93661: PUSH
93662: LD_INT 0
93664: PUSH
93665: EMPTY
93666: LIST
93667: LIST
93668: PUSH
93669: LD_INT 3
93671: NEG
93672: PUSH
93673: LD_INT 1
93675: NEG
93676: PUSH
93677: EMPTY
93678: LIST
93679: LIST
93680: PUSH
93681: EMPTY
93682: LIST
93683: LIST
93684: LIST
93685: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93686: LD_ADDR_VAR 0 22
93690: PUSH
93691: LD_INT 2
93693: NEG
93694: PUSH
93695: LD_INT 3
93697: NEG
93698: PUSH
93699: EMPTY
93700: LIST
93701: LIST
93702: PUSH
93703: LD_INT 3
93705: NEG
93706: PUSH
93707: LD_INT 2
93709: NEG
93710: PUSH
93711: EMPTY
93712: LIST
93713: LIST
93714: PUSH
93715: LD_INT 3
93717: NEG
93718: PUSH
93719: LD_INT 3
93721: NEG
93722: PUSH
93723: EMPTY
93724: LIST
93725: LIST
93726: PUSH
93727: EMPTY
93728: LIST
93729: LIST
93730: LIST
93731: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
93732: LD_ADDR_VAR 0 23
93736: PUSH
93737: LD_INT 0
93739: PUSH
93740: LD_INT 3
93742: NEG
93743: PUSH
93744: EMPTY
93745: LIST
93746: LIST
93747: PUSH
93748: LD_INT 1
93750: NEG
93751: PUSH
93752: LD_INT 4
93754: NEG
93755: PUSH
93756: EMPTY
93757: LIST
93758: LIST
93759: PUSH
93760: LD_INT 1
93762: PUSH
93763: LD_INT 3
93765: NEG
93766: PUSH
93767: EMPTY
93768: LIST
93769: LIST
93770: PUSH
93771: EMPTY
93772: LIST
93773: LIST
93774: LIST
93775: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
93776: LD_ADDR_VAR 0 24
93780: PUSH
93781: LD_INT 3
93783: PUSH
93784: LD_INT 0
93786: PUSH
93787: EMPTY
93788: LIST
93789: LIST
93790: PUSH
93791: LD_INT 3
93793: PUSH
93794: LD_INT 1
93796: NEG
93797: PUSH
93798: EMPTY
93799: LIST
93800: LIST
93801: PUSH
93802: LD_INT 4
93804: PUSH
93805: LD_INT 1
93807: PUSH
93808: EMPTY
93809: LIST
93810: LIST
93811: PUSH
93812: EMPTY
93813: LIST
93814: LIST
93815: LIST
93816: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
93817: LD_ADDR_VAR 0 25
93821: PUSH
93822: LD_INT 3
93824: PUSH
93825: LD_INT 3
93827: PUSH
93828: EMPTY
93829: LIST
93830: LIST
93831: PUSH
93832: LD_INT 4
93834: PUSH
93835: LD_INT 3
93837: PUSH
93838: EMPTY
93839: LIST
93840: LIST
93841: PUSH
93842: LD_INT 3
93844: PUSH
93845: LD_INT 4
93847: PUSH
93848: EMPTY
93849: LIST
93850: LIST
93851: PUSH
93852: EMPTY
93853: LIST
93854: LIST
93855: LIST
93856: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
93857: LD_ADDR_VAR 0 26
93861: PUSH
93862: LD_INT 0
93864: PUSH
93865: LD_INT 3
93867: PUSH
93868: EMPTY
93869: LIST
93870: LIST
93871: PUSH
93872: LD_INT 1
93874: PUSH
93875: LD_INT 4
93877: PUSH
93878: EMPTY
93879: LIST
93880: LIST
93881: PUSH
93882: LD_INT 1
93884: NEG
93885: PUSH
93886: LD_INT 3
93888: PUSH
93889: EMPTY
93890: LIST
93891: LIST
93892: PUSH
93893: EMPTY
93894: LIST
93895: LIST
93896: LIST
93897: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
93898: LD_ADDR_VAR 0 27
93902: PUSH
93903: LD_INT 3
93905: NEG
93906: PUSH
93907: LD_INT 0
93909: PUSH
93910: EMPTY
93911: LIST
93912: LIST
93913: PUSH
93914: LD_INT 3
93916: NEG
93917: PUSH
93918: LD_INT 1
93920: PUSH
93921: EMPTY
93922: LIST
93923: LIST
93924: PUSH
93925: LD_INT 4
93927: NEG
93928: PUSH
93929: LD_INT 1
93931: NEG
93932: PUSH
93933: EMPTY
93934: LIST
93935: LIST
93936: PUSH
93937: EMPTY
93938: LIST
93939: LIST
93940: LIST
93941: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
93942: LD_ADDR_VAR 0 28
93946: PUSH
93947: LD_INT 3
93949: NEG
93950: PUSH
93951: LD_INT 3
93953: NEG
93954: PUSH
93955: EMPTY
93956: LIST
93957: LIST
93958: PUSH
93959: LD_INT 3
93961: NEG
93962: PUSH
93963: LD_INT 4
93965: NEG
93966: PUSH
93967: EMPTY
93968: LIST
93969: LIST
93970: PUSH
93971: LD_INT 4
93973: NEG
93974: PUSH
93975: LD_INT 3
93977: NEG
93978: PUSH
93979: EMPTY
93980: LIST
93981: LIST
93982: PUSH
93983: EMPTY
93984: LIST
93985: LIST
93986: LIST
93987: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
93988: LD_ADDR_VAR 0 29
93992: PUSH
93993: LD_INT 1
93995: NEG
93996: PUSH
93997: LD_INT 3
93999: NEG
94000: PUSH
94001: EMPTY
94002: LIST
94003: LIST
94004: PUSH
94005: LD_INT 0
94007: PUSH
94008: LD_INT 3
94010: NEG
94011: PUSH
94012: EMPTY
94013: LIST
94014: LIST
94015: PUSH
94016: LD_INT 1
94018: PUSH
94019: LD_INT 2
94021: NEG
94022: PUSH
94023: EMPTY
94024: LIST
94025: LIST
94026: PUSH
94027: LD_INT 1
94029: NEG
94030: PUSH
94031: LD_INT 4
94033: NEG
94034: PUSH
94035: EMPTY
94036: LIST
94037: LIST
94038: PUSH
94039: LD_INT 0
94041: PUSH
94042: LD_INT 4
94044: NEG
94045: PUSH
94046: EMPTY
94047: LIST
94048: LIST
94049: PUSH
94050: LD_INT 1
94052: PUSH
94053: LD_INT 3
94055: NEG
94056: PUSH
94057: EMPTY
94058: LIST
94059: LIST
94060: PUSH
94061: LD_INT 1
94063: NEG
94064: PUSH
94065: LD_INT 5
94067: NEG
94068: PUSH
94069: EMPTY
94070: LIST
94071: LIST
94072: PUSH
94073: LD_INT 0
94075: PUSH
94076: LD_INT 5
94078: NEG
94079: PUSH
94080: EMPTY
94081: LIST
94082: LIST
94083: PUSH
94084: LD_INT 1
94086: PUSH
94087: LD_INT 4
94089: NEG
94090: PUSH
94091: EMPTY
94092: LIST
94093: LIST
94094: PUSH
94095: LD_INT 1
94097: NEG
94098: PUSH
94099: LD_INT 6
94101: NEG
94102: PUSH
94103: EMPTY
94104: LIST
94105: LIST
94106: PUSH
94107: LD_INT 0
94109: PUSH
94110: LD_INT 6
94112: NEG
94113: PUSH
94114: EMPTY
94115: LIST
94116: LIST
94117: PUSH
94118: LD_INT 1
94120: PUSH
94121: LD_INT 5
94123: NEG
94124: PUSH
94125: EMPTY
94126: LIST
94127: LIST
94128: PUSH
94129: EMPTY
94130: LIST
94131: LIST
94132: LIST
94133: LIST
94134: LIST
94135: LIST
94136: LIST
94137: LIST
94138: LIST
94139: LIST
94140: LIST
94141: LIST
94142: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
94143: LD_ADDR_VAR 0 30
94147: PUSH
94148: LD_INT 2
94150: PUSH
94151: LD_INT 1
94153: NEG
94154: PUSH
94155: EMPTY
94156: LIST
94157: LIST
94158: PUSH
94159: LD_INT 3
94161: PUSH
94162: LD_INT 0
94164: PUSH
94165: EMPTY
94166: LIST
94167: LIST
94168: PUSH
94169: LD_INT 3
94171: PUSH
94172: LD_INT 1
94174: PUSH
94175: EMPTY
94176: LIST
94177: LIST
94178: PUSH
94179: LD_INT 3
94181: PUSH
94182: LD_INT 1
94184: NEG
94185: PUSH
94186: EMPTY
94187: LIST
94188: LIST
94189: PUSH
94190: LD_INT 4
94192: PUSH
94193: LD_INT 0
94195: PUSH
94196: EMPTY
94197: LIST
94198: LIST
94199: PUSH
94200: LD_INT 4
94202: PUSH
94203: LD_INT 1
94205: PUSH
94206: EMPTY
94207: LIST
94208: LIST
94209: PUSH
94210: LD_INT 4
94212: PUSH
94213: LD_INT 1
94215: NEG
94216: PUSH
94217: EMPTY
94218: LIST
94219: LIST
94220: PUSH
94221: LD_INT 5
94223: PUSH
94224: LD_INT 0
94226: PUSH
94227: EMPTY
94228: LIST
94229: LIST
94230: PUSH
94231: LD_INT 5
94233: PUSH
94234: LD_INT 1
94236: PUSH
94237: EMPTY
94238: LIST
94239: LIST
94240: PUSH
94241: LD_INT 5
94243: PUSH
94244: LD_INT 1
94246: NEG
94247: PUSH
94248: EMPTY
94249: LIST
94250: LIST
94251: PUSH
94252: LD_INT 6
94254: PUSH
94255: LD_INT 0
94257: PUSH
94258: EMPTY
94259: LIST
94260: LIST
94261: PUSH
94262: LD_INT 6
94264: PUSH
94265: LD_INT 1
94267: PUSH
94268: EMPTY
94269: LIST
94270: LIST
94271: PUSH
94272: EMPTY
94273: LIST
94274: LIST
94275: LIST
94276: LIST
94277: LIST
94278: LIST
94279: LIST
94280: LIST
94281: LIST
94282: LIST
94283: LIST
94284: LIST
94285: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
94286: LD_ADDR_VAR 0 31
94290: PUSH
94291: LD_INT 3
94293: PUSH
94294: LD_INT 2
94296: PUSH
94297: EMPTY
94298: LIST
94299: LIST
94300: PUSH
94301: LD_INT 3
94303: PUSH
94304: LD_INT 3
94306: PUSH
94307: EMPTY
94308: LIST
94309: LIST
94310: PUSH
94311: LD_INT 2
94313: PUSH
94314: LD_INT 3
94316: PUSH
94317: EMPTY
94318: LIST
94319: LIST
94320: PUSH
94321: LD_INT 4
94323: PUSH
94324: LD_INT 3
94326: PUSH
94327: EMPTY
94328: LIST
94329: LIST
94330: PUSH
94331: LD_INT 4
94333: PUSH
94334: LD_INT 4
94336: PUSH
94337: EMPTY
94338: LIST
94339: LIST
94340: PUSH
94341: LD_INT 3
94343: PUSH
94344: LD_INT 4
94346: PUSH
94347: EMPTY
94348: LIST
94349: LIST
94350: PUSH
94351: LD_INT 5
94353: PUSH
94354: LD_INT 4
94356: PUSH
94357: EMPTY
94358: LIST
94359: LIST
94360: PUSH
94361: LD_INT 5
94363: PUSH
94364: LD_INT 5
94366: PUSH
94367: EMPTY
94368: LIST
94369: LIST
94370: PUSH
94371: LD_INT 4
94373: PUSH
94374: LD_INT 5
94376: PUSH
94377: EMPTY
94378: LIST
94379: LIST
94380: PUSH
94381: LD_INT 6
94383: PUSH
94384: LD_INT 5
94386: PUSH
94387: EMPTY
94388: LIST
94389: LIST
94390: PUSH
94391: LD_INT 6
94393: PUSH
94394: LD_INT 6
94396: PUSH
94397: EMPTY
94398: LIST
94399: LIST
94400: PUSH
94401: LD_INT 5
94403: PUSH
94404: LD_INT 6
94406: PUSH
94407: EMPTY
94408: LIST
94409: LIST
94410: PUSH
94411: EMPTY
94412: LIST
94413: LIST
94414: LIST
94415: LIST
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: LIST
94423: LIST
94424: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
94425: LD_ADDR_VAR 0 32
94429: PUSH
94430: LD_INT 1
94432: PUSH
94433: LD_INT 3
94435: PUSH
94436: EMPTY
94437: LIST
94438: LIST
94439: PUSH
94440: LD_INT 0
94442: PUSH
94443: LD_INT 3
94445: PUSH
94446: EMPTY
94447: LIST
94448: LIST
94449: PUSH
94450: LD_INT 1
94452: NEG
94453: PUSH
94454: LD_INT 2
94456: PUSH
94457: EMPTY
94458: LIST
94459: LIST
94460: PUSH
94461: LD_INT 1
94463: PUSH
94464: LD_INT 4
94466: PUSH
94467: EMPTY
94468: LIST
94469: LIST
94470: PUSH
94471: LD_INT 0
94473: PUSH
94474: LD_INT 4
94476: PUSH
94477: EMPTY
94478: LIST
94479: LIST
94480: PUSH
94481: LD_INT 1
94483: NEG
94484: PUSH
94485: LD_INT 3
94487: PUSH
94488: EMPTY
94489: LIST
94490: LIST
94491: PUSH
94492: LD_INT 1
94494: PUSH
94495: LD_INT 5
94497: PUSH
94498: EMPTY
94499: LIST
94500: LIST
94501: PUSH
94502: LD_INT 0
94504: PUSH
94505: LD_INT 5
94507: PUSH
94508: EMPTY
94509: LIST
94510: LIST
94511: PUSH
94512: LD_INT 1
94514: NEG
94515: PUSH
94516: LD_INT 4
94518: PUSH
94519: EMPTY
94520: LIST
94521: LIST
94522: PUSH
94523: LD_INT 1
94525: PUSH
94526: LD_INT 6
94528: PUSH
94529: EMPTY
94530: LIST
94531: LIST
94532: PUSH
94533: LD_INT 0
94535: PUSH
94536: LD_INT 6
94538: PUSH
94539: EMPTY
94540: LIST
94541: LIST
94542: PUSH
94543: LD_INT 1
94545: NEG
94546: PUSH
94547: LD_INT 5
94549: PUSH
94550: EMPTY
94551: LIST
94552: LIST
94553: PUSH
94554: EMPTY
94555: LIST
94556: LIST
94557: LIST
94558: LIST
94559: LIST
94560: LIST
94561: LIST
94562: LIST
94563: LIST
94564: LIST
94565: LIST
94566: LIST
94567: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
94568: LD_ADDR_VAR 0 33
94572: PUSH
94573: LD_INT 2
94575: NEG
94576: PUSH
94577: LD_INT 1
94579: PUSH
94580: EMPTY
94581: LIST
94582: LIST
94583: PUSH
94584: LD_INT 3
94586: NEG
94587: PUSH
94588: LD_INT 0
94590: PUSH
94591: EMPTY
94592: LIST
94593: LIST
94594: PUSH
94595: LD_INT 3
94597: NEG
94598: PUSH
94599: LD_INT 1
94601: NEG
94602: PUSH
94603: EMPTY
94604: LIST
94605: LIST
94606: PUSH
94607: LD_INT 3
94609: NEG
94610: PUSH
94611: LD_INT 1
94613: PUSH
94614: EMPTY
94615: LIST
94616: LIST
94617: PUSH
94618: LD_INT 4
94620: NEG
94621: PUSH
94622: LD_INT 0
94624: PUSH
94625: EMPTY
94626: LIST
94627: LIST
94628: PUSH
94629: LD_INT 4
94631: NEG
94632: PUSH
94633: LD_INT 1
94635: NEG
94636: PUSH
94637: EMPTY
94638: LIST
94639: LIST
94640: PUSH
94641: LD_INT 4
94643: NEG
94644: PUSH
94645: LD_INT 1
94647: PUSH
94648: EMPTY
94649: LIST
94650: LIST
94651: PUSH
94652: LD_INT 5
94654: NEG
94655: PUSH
94656: LD_INT 0
94658: PUSH
94659: EMPTY
94660: LIST
94661: LIST
94662: PUSH
94663: LD_INT 5
94665: NEG
94666: PUSH
94667: LD_INT 1
94669: NEG
94670: PUSH
94671: EMPTY
94672: LIST
94673: LIST
94674: PUSH
94675: LD_INT 5
94677: NEG
94678: PUSH
94679: LD_INT 1
94681: PUSH
94682: EMPTY
94683: LIST
94684: LIST
94685: PUSH
94686: LD_INT 6
94688: NEG
94689: PUSH
94690: LD_INT 0
94692: PUSH
94693: EMPTY
94694: LIST
94695: LIST
94696: PUSH
94697: LD_INT 6
94699: NEG
94700: PUSH
94701: LD_INT 1
94703: NEG
94704: PUSH
94705: EMPTY
94706: LIST
94707: LIST
94708: PUSH
94709: EMPTY
94710: LIST
94711: LIST
94712: LIST
94713: LIST
94714: LIST
94715: LIST
94716: LIST
94717: LIST
94718: LIST
94719: LIST
94720: LIST
94721: LIST
94722: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
94723: LD_ADDR_VAR 0 34
94727: PUSH
94728: LD_INT 2
94730: NEG
94731: PUSH
94732: LD_INT 3
94734: NEG
94735: PUSH
94736: EMPTY
94737: LIST
94738: LIST
94739: PUSH
94740: LD_INT 3
94742: NEG
94743: PUSH
94744: LD_INT 2
94746: NEG
94747: PUSH
94748: EMPTY
94749: LIST
94750: LIST
94751: PUSH
94752: LD_INT 3
94754: NEG
94755: PUSH
94756: LD_INT 3
94758: NEG
94759: PUSH
94760: EMPTY
94761: LIST
94762: LIST
94763: PUSH
94764: LD_INT 3
94766: NEG
94767: PUSH
94768: LD_INT 4
94770: NEG
94771: PUSH
94772: EMPTY
94773: LIST
94774: LIST
94775: PUSH
94776: LD_INT 4
94778: NEG
94779: PUSH
94780: LD_INT 3
94782: NEG
94783: PUSH
94784: EMPTY
94785: LIST
94786: LIST
94787: PUSH
94788: LD_INT 4
94790: NEG
94791: PUSH
94792: LD_INT 4
94794: NEG
94795: PUSH
94796: EMPTY
94797: LIST
94798: LIST
94799: PUSH
94800: LD_INT 4
94802: NEG
94803: PUSH
94804: LD_INT 5
94806: NEG
94807: PUSH
94808: EMPTY
94809: LIST
94810: LIST
94811: PUSH
94812: LD_INT 5
94814: NEG
94815: PUSH
94816: LD_INT 4
94818: NEG
94819: PUSH
94820: EMPTY
94821: LIST
94822: LIST
94823: PUSH
94824: LD_INT 5
94826: NEG
94827: PUSH
94828: LD_INT 5
94830: NEG
94831: PUSH
94832: EMPTY
94833: LIST
94834: LIST
94835: PUSH
94836: LD_INT 5
94838: NEG
94839: PUSH
94840: LD_INT 6
94842: NEG
94843: PUSH
94844: EMPTY
94845: LIST
94846: LIST
94847: PUSH
94848: LD_INT 6
94850: NEG
94851: PUSH
94852: LD_INT 5
94854: NEG
94855: PUSH
94856: EMPTY
94857: LIST
94858: LIST
94859: PUSH
94860: LD_INT 6
94862: NEG
94863: PUSH
94864: LD_INT 6
94866: NEG
94867: PUSH
94868: EMPTY
94869: LIST
94870: LIST
94871: PUSH
94872: EMPTY
94873: LIST
94874: LIST
94875: LIST
94876: LIST
94877: LIST
94878: LIST
94879: LIST
94880: LIST
94881: LIST
94882: LIST
94883: LIST
94884: LIST
94885: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
94886: LD_ADDR_VAR 0 41
94890: PUSH
94891: LD_INT 0
94893: PUSH
94894: LD_INT 2
94896: NEG
94897: PUSH
94898: EMPTY
94899: LIST
94900: LIST
94901: PUSH
94902: LD_INT 1
94904: NEG
94905: PUSH
94906: LD_INT 3
94908: NEG
94909: PUSH
94910: EMPTY
94911: LIST
94912: LIST
94913: PUSH
94914: LD_INT 1
94916: PUSH
94917: LD_INT 2
94919: NEG
94920: PUSH
94921: EMPTY
94922: LIST
94923: LIST
94924: PUSH
94925: EMPTY
94926: LIST
94927: LIST
94928: LIST
94929: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
94930: LD_ADDR_VAR 0 42
94934: PUSH
94935: LD_INT 2
94937: PUSH
94938: LD_INT 0
94940: PUSH
94941: EMPTY
94942: LIST
94943: LIST
94944: PUSH
94945: LD_INT 2
94947: PUSH
94948: LD_INT 1
94950: NEG
94951: PUSH
94952: EMPTY
94953: LIST
94954: LIST
94955: PUSH
94956: LD_INT 3
94958: PUSH
94959: LD_INT 1
94961: PUSH
94962: EMPTY
94963: LIST
94964: LIST
94965: PUSH
94966: EMPTY
94967: LIST
94968: LIST
94969: LIST
94970: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
94971: LD_ADDR_VAR 0 43
94975: PUSH
94976: LD_INT 2
94978: PUSH
94979: LD_INT 2
94981: PUSH
94982: EMPTY
94983: LIST
94984: LIST
94985: PUSH
94986: LD_INT 3
94988: PUSH
94989: LD_INT 2
94991: PUSH
94992: EMPTY
94993: LIST
94994: LIST
94995: PUSH
94996: LD_INT 2
94998: PUSH
94999: LD_INT 3
95001: PUSH
95002: EMPTY
95003: LIST
95004: LIST
95005: PUSH
95006: EMPTY
95007: LIST
95008: LIST
95009: LIST
95010: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
95011: LD_ADDR_VAR 0 44
95015: PUSH
95016: LD_INT 0
95018: PUSH
95019: LD_INT 2
95021: PUSH
95022: EMPTY
95023: LIST
95024: LIST
95025: PUSH
95026: LD_INT 1
95028: PUSH
95029: LD_INT 3
95031: PUSH
95032: EMPTY
95033: LIST
95034: LIST
95035: PUSH
95036: LD_INT 1
95038: NEG
95039: PUSH
95040: LD_INT 2
95042: PUSH
95043: EMPTY
95044: LIST
95045: LIST
95046: PUSH
95047: EMPTY
95048: LIST
95049: LIST
95050: LIST
95051: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
95052: LD_ADDR_VAR 0 45
95056: PUSH
95057: LD_INT 2
95059: NEG
95060: PUSH
95061: LD_INT 0
95063: PUSH
95064: EMPTY
95065: LIST
95066: LIST
95067: PUSH
95068: LD_INT 2
95070: NEG
95071: PUSH
95072: LD_INT 1
95074: PUSH
95075: EMPTY
95076: LIST
95077: LIST
95078: PUSH
95079: LD_INT 3
95081: NEG
95082: PUSH
95083: LD_INT 1
95085: NEG
95086: PUSH
95087: EMPTY
95088: LIST
95089: LIST
95090: PUSH
95091: EMPTY
95092: LIST
95093: LIST
95094: LIST
95095: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
95096: LD_ADDR_VAR 0 46
95100: PUSH
95101: LD_INT 2
95103: NEG
95104: PUSH
95105: LD_INT 2
95107: NEG
95108: PUSH
95109: EMPTY
95110: LIST
95111: LIST
95112: PUSH
95113: LD_INT 2
95115: NEG
95116: PUSH
95117: LD_INT 3
95119: NEG
95120: PUSH
95121: EMPTY
95122: LIST
95123: LIST
95124: PUSH
95125: LD_INT 3
95127: NEG
95128: PUSH
95129: LD_INT 2
95131: NEG
95132: PUSH
95133: EMPTY
95134: LIST
95135: LIST
95136: PUSH
95137: EMPTY
95138: LIST
95139: LIST
95140: LIST
95141: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
95142: LD_ADDR_VAR 0 47
95146: PUSH
95147: LD_INT 2
95149: NEG
95150: PUSH
95151: LD_INT 3
95153: NEG
95154: PUSH
95155: EMPTY
95156: LIST
95157: LIST
95158: PUSH
95159: LD_INT 1
95161: NEG
95162: PUSH
95163: LD_INT 3
95165: NEG
95166: PUSH
95167: EMPTY
95168: LIST
95169: LIST
95170: PUSH
95171: EMPTY
95172: LIST
95173: LIST
95174: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
95175: LD_ADDR_VAR 0 48
95179: PUSH
95180: LD_INT 1
95182: PUSH
95183: LD_INT 2
95185: NEG
95186: PUSH
95187: EMPTY
95188: LIST
95189: LIST
95190: PUSH
95191: LD_INT 2
95193: PUSH
95194: LD_INT 1
95196: NEG
95197: PUSH
95198: EMPTY
95199: LIST
95200: LIST
95201: PUSH
95202: EMPTY
95203: LIST
95204: LIST
95205: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
95206: LD_ADDR_VAR 0 49
95210: PUSH
95211: LD_INT 3
95213: PUSH
95214: LD_INT 1
95216: PUSH
95217: EMPTY
95218: LIST
95219: LIST
95220: PUSH
95221: LD_INT 3
95223: PUSH
95224: LD_INT 2
95226: PUSH
95227: EMPTY
95228: LIST
95229: LIST
95230: PUSH
95231: EMPTY
95232: LIST
95233: LIST
95234: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
95235: LD_ADDR_VAR 0 50
95239: PUSH
95240: LD_INT 2
95242: PUSH
95243: LD_INT 3
95245: PUSH
95246: EMPTY
95247: LIST
95248: LIST
95249: PUSH
95250: LD_INT 1
95252: PUSH
95253: LD_INT 3
95255: PUSH
95256: EMPTY
95257: LIST
95258: LIST
95259: PUSH
95260: EMPTY
95261: LIST
95262: LIST
95263: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
95264: LD_ADDR_VAR 0 51
95268: PUSH
95269: LD_INT 1
95271: NEG
95272: PUSH
95273: LD_INT 2
95275: PUSH
95276: EMPTY
95277: LIST
95278: LIST
95279: PUSH
95280: LD_INT 2
95282: NEG
95283: PUSH
95284: LD_INT 1
95286: PUSH
95287: EMPTY
95288: LIST
95289: LIST
95290: PUSH
95291: EMPTY
95292: LIST
95293: LIST
95294: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
95295: LD_ADDR_VAR 0 52
95299: PUSH
95300: LD_INT 3
95302: NEG
95303: PUSH
95304: LD_INT 1
95306: NEG
95307: PUSH
95308: EMPTY
95309: LIST
95310: LIST
95311: PUSH
95312: LD_INT 3
95314: NEG
95315: PUSH
95316: LD_INT 2
95318: NEG
95319: PUSH
95320: EMPTY
95321: LIST
95322: LIST
95323: PUSH
95324: EMPTY
95325: LIST
95326: LIST
95327: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
95328: LD_ADDR_VAR 0 53
95332: PUSH
95333: LD_INT 1
95335: NEG
95336: PUSH
95337: LD_INT 3
95339: NEG
95340: PUSH
95341: EMPTY
95342: LIST
95343: LIST
95344: PUSH
95345: LD_INT 0
95347: PUSH
95348: LD_INT 3
95350: NEG
95351: PUSH
95352: EMPTY
95353: LIST
95354: LIST
95355: PUSH
95356: LD_INT 1
95358: PUSH
95359: LD_INT 2
95361: NEG
95362: PUSH
95363: EMPTY
95364: LIST
95365: LIST
95366: PUSH
95367: EMPTY
95368: LIST
95369: LIST
95370: LIST
95371: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
95372: LD_ADDR_VAR 0 54
95376: PUSH
95377: LD_INT 2
95379: PUSH
95380: LD_INT 1
95382: NEG
95383: PUSH
95384: EMPTY
95385: LIST
95386: LIST
95387: PUSH
95388: LD_INT 3
95390: PUSH
95391: LD_INT 0
95393: PUSH
95394: EMPTY
95395: LIST
95396: LIST
95397: PUSH
95398: LD_INT 3
95400: PUSH
95401: LD_INT 1
95403: PUSH
95404: EMPTY
95405: LIST
95406: LIST
95407: PUSH
95408: EMPTY
95409: LIST
95410: LIST
95411: LIST
95412: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
95413: LD_ADDR_VAR 0 55
95417: PUSH
95418: LD_INT 3
95420: PUSH
95421: LD_INT 2
95423: PUSH
95424: EMPTY
95425: LIST
95426: LIST
95427: PUSH
95428: LD_INT 3
95430: PUSH
95431: LD_INT 3
95433: PUSH
95434: EMPTY
95435: LIST
95436: LIST
95437: PUSH
95438: LD_INT 2
95440: PUSH
95441: LD_INT 3
95443: PUSH
95444: EMPTY
95445: LIST
95446: LIST
95447: PUSH
95448: EMPTY
95449: LIST
95450: LIST
95451: LIST
95452: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
95453: LD_ADDR_VAR 0 56
95457: PUSH
95458: LD_INT 1
95460: PUSH
95461: LD_INT 3
95463: PUSH
95464: EMPTY
95465: LIST
95466: LIST
95467: PUSH
95468: LD_INT 0
95470: PUSH
95471: LD_INT 3
95473: PUSH
95474: EMPTY
95475: LIST
95476: LIST
95477: PUSH
95478: LD_INT 1
95480: NEG
95481: PUSH
95482: LD_INT 2
95484: PUSH
95485: EMPTY
95486: LIST
95487: LIST
95488: PUSH
95489: EMPTY
95490: LIST
95491: LIST
95492: LIST
95493: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
95494: LD_ADDR_VAR 0 57
95498: PUSH
95499: LD_INT 2
95501: NEG
95502: PUSH
95503: LD_INT 1
95505: PUSH
95506: EMPTY
95507: LIST
95508: LIST
95509: PUSH
95510: LD_INT 3
95512: NEG
95513: PUSH
95514: LD_INT 0
95516: PUSH
95517: EMPTY
95518: LIST
95519: LIST
95520: PUSH
95521: LD_INT 3
95523: NEG
95524: PUSH
95525: LD_INT 1
95527: NEG
95528: PUSH
95529: EMPTY
95530: LIST
95531: LIST
95532: PUSH
95533: EMPTY
95534: LIST
95535: LIST
95536: LIST
95537: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
95538: LD_ADDR_VAR 0 58
95542: PUSH
95543: LD_INT 2
95545: NEG
95546: PUSH
95547: LD_INT 3
95549: NEG
95550: PUSH
95551: EMPTY
95552: LIST
95553: LIST
95554: PUSH
95555: LD_INT 3
95557: NEG
95558: PUSH
95559: LD_INT 2
95561: NEG
95562: PUSH
95563: EMPTY
95564: LIST
95565: LIST
95566: PUSH
95567: LD_INT 3
95569: NEG
95570: PUSH
95571: LD_INT 3
95573: NEG
95574: PUSH
95575: EMPTY
95576: LIST
95577: LIST
95578: PUSH
95579: EMPTY
95580: LIST
95581: LIST
95582: LIST
95583: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
95584: LD_ADDR_VAR 0 59
95588: PUSH
95589: LD_INT 1
95591: NEG
95592: PUSH
95593: LD_INT 2
95595: NEG
95596: PUSH
95597: EMPTY
95598: LIST
95599: LIST
95600: PUSH
95601: LD_INT 0
95603: PUSH
95604: LD_INT 2
95606: NEG
95607: PUSH
95608: EMPTY
95609: LIST
95610: LIST
95611: PUSH
95612: LD_INT 1
95614: PUSH
95615: LD_INT 1
95617: NEG
95618: PUSH
95619: EMPTY
95620: LIST
95621: LIST
95622: PUSH
95623: EMPTY
95624: LIST
95625: LIST
95626: LIST
95627: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
95628: LD_ADDR_VAR 0 60
95632: PUSH
95633: LD_INT 1
95635: PUSH
95636: LD_INT 1
95638: NEG
95639: PUSH
95640: EMPTY
95641: LIST
95642: LIST
95643: PUSH
95644: LD_INT 2
95646: PUSH
95647: LD_INT 0
95649: PUSH
95650: EMPTY
95651: LIST
95652: LIST
95653: PUSH
95654: LD_INT 2
95656: PUSH
95657: LD_INT 1
95659: PUSH
95660: EMPTY
95661: LIST
95662: LIST
95663: PUSH
95664: EMPTY
95665: LIST
95666: LIST
95667: LIST
95668: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
95669: LD_ADDR_VAR 0 61
95673: PUSH
95674: LD_INT 2
95676: PUSH
95677: LD_INT 1
95679: PUSH
95680: EMPTY
95681: LIST
95682: LIST
95683: PUSH
95684: LD_INT 2
95686: PUSH
95687: LD_INT 2
95689: PUSH
95690: EMPTY
95691: LIST
95692: LIST
95693: PUSH
95694: LD_INT 1
95696: PUSH
95697: LD_INT 2
95699: PUSH
95700: EMPTY
95701: LIST
95702: LIST
95703: PUSH
95704: EMPTY
95705: LIST
95706: LIST
95707: LIST
95708: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
95709: LD_ADDR_VAR 0 62
95713: PUSH
95714: LD_INT 1
95716: PUSH
95717: LD_INT 2
95719: PUSH
95720: EMPTY
95721: LIST
95722: LIST
95723: PUSH
95724: LD_INT 0
95726: PUSH
95727: LD_INT 2
95729: PUSH
95730: EMPTY
95731: LIST
95732: LIST
95733: PUSH
95734: LD_INT 1
95736: NEG
95737: PUSH
95738: LD_INT 1
95740: PUSH
95741: EMPTY
95742: LIST
95743: LIST
95744: PUSH
95745: EMPTY
95746: LIST
95747: LIST
95748: LIST
95749: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
95750: LD_ADDR_VAR 0 63
95754: PUSH
95755: LD_INT 1
95757: NEG
95758: PUSH
95759: LD_INT 1
95761: PUSH
95762: EMPTY
95763: LIST
95764: LIST
95765: PUSH
95766: LD_INT 2
95768: NEG
95769: PUSH
95770: LD_INT 0
95772: PUSH
95773: EMPTY
95774: LIST
95775: LIST
95776: PUSH
95777: LD_INT 2
95779: NEG
95780: PUSH
95781: LD_INT 1
95783: NEG
95784: PUSH
95785: EMPTY
95786: LIST
95787: LIST
95788: PUSH
95789: EMPTY
95790: LIST
95791: LIST
95792: LIST
95793: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95794: LD_ADDR_VAR 0 64
95798: PUSH
95799: LD_INT 1
95801: NEG
95802: PUSH
95803: LD_INT 2
95805: NEG
95806: PUSH
95807: EMPTY
95808: LIST
95809: LIST
95810: PUSH
95811: LD_INT 2
95813: NEG
95814: PUSH
95815: LD_INT 1
95817: NEG
95818: PUSH
95819: EMPTY
95820: LIST
95821: LIST
95822: PUSH
95823: LD_INT 2
95825: NEG
95826: PUSH
95827: LD_INT 2
95829: NEG
95830: PUSH
95831: EMPTY
95832: LIST
95833: LIST
95834: PUSH
95835: EMPTY
95836: LIST
95837: LIST
95838: LIST
95839: ST_TO_ADDR
// end ; 2 :
95840: GO 99106
95842: LD_INT 2
95844: DOUBLE
95845: EQUAL
95846: IFTRUE 95850
95848: GO 99105
95850: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
95851: LD_ADDR_VAR 0 29
95855: PUSH
95856: LD_INT 4
95858: PUSH
95859: LD_INT 0
95861: PUSH
95862: EMPTY
95863: LIST
95864: LIST
95865: PUSH
95866: LD_INT 4
95868: PUSH
95869: LD_INT 1
95871: NEG
95872: PUSH
95873: EMPTY
95874: LIST
95875: LIST
95876: PUSH
95877: LD_INT 5
95879: PUSH
95880: LD_INT 0
95882: PUSH
95883: EMPTY
95884: LIST
95885: LIST
95886: PUSH
95887: LD_INT 5
95889: PUSH
95890: LD_INT 1
95892: PUSH
95893: EMPTY
95894: LIST
95895: LIST
95896: PUSH
95897: LD_INT 4
95899: PUSH
95900: LD_INT 1
95902: PUSH
95903: EMPTY
95904: LIST
95905: LIST
95906: PUSH
95907: LD_INT 3
95909: PUSH
95910: LD_INT 0
95912: PUSH
95913: EMPTY
95914: LIST
95915: LIST
95916: PUSH
95917: LD_INT 3
95919: PUSH
95920: LD_INT 1
95922: NEG
95923: PUSH
95924: EMPTY
95925: LIST
95926: LIST
95927: PUSH
95928: LD_INT 3
95930: PUSH
95931: LD_INT 2
95933: NEG
95934: PUSH
95935: EMPTY
95936: LIST
95937: LIST
95938: PUSH
95939: LD_INT 5
95941: PUSH
95942: LD_INT 2
95944: PUSH
95945: EMPTY
95946: LIST
95947: LIST
95948: PUSH
95949: LD_INT 3
95951: PUSH
95952: LD_INT 3
95954: PUSH
95955: EMPTY
95956: LIST
95957: LIST
95958: PUSH
95959: LD_INT 3
95961: PUSH
95962: LD_INT 2
95964: PUSH
95965: EMPTY
95966: LIST
95967: LIST
95968: PUSH
95969: LD_INT 4
95971: PUSH
95972: LD_INT 3
95974: PUSH
95975: EMPTY
95976: LIST
95977: LIST
95978: PUSH
95979: LD_INT 4
95981: PUSH
95982: LD_INT 4
95984: PUSH
95985: EMPTY
95986: LIST
95987: LIST
95988: PUSH
95989: LD_INT 3
95991: PUSH
95992: LD_INT 4
95994: PUSH
95995: EMPTY
95996: LIST
95997: LIST
95998: PUSH
95999: LD_INT 2
96001: PUSH
96002: LD_INT 3
96004: PUSH
96005: EMPTY
96006: LIST
96007: LIST
96008: PUSH
96009: LD_INT 2
96011: PUSH
96012: LD_INT 2
96014: PUSH
96015: EMPTY
96016: LIST
96017: LIST
96018: PUSH
96019: LD_INT 4
96021: PUSH
96022: LD_INT 2
96024: PUSH
96025: EMPTY
96026: LIST
96027: LIST
96028: PUSH
96029: LD_INT 2
96031: PUSH
96032: LD_INT 4
96034: PUSH
96035: EMPTY
96036: LIST
96037: LIST
96038: PUSH
96039: LD_INT 0
96041: PUSH
96042: LD_INT 4
96044: PUSH
96045: EMPTY
96046: LIST
96047: LIST
96048: PUSH
96049: LD_INT 0
96051: PUSH
96052: LD_INT 3
96054: PUSH
96055: EMPTY
96056: LIST
96057: LIST
96058: PUSH
96059: LD_INT 1
96061: PUSH
96062: LD_INT 4
96064: PUSH
96065: EMPTY
96066: LIST
96067: LIST
96068: PUSH
96069: LD_INT 1
96071: PUSH
96072: LD_INT 5
96074: PUSH
96075: EMPTY
96076: LIST
96077: LIST
96078: PUSH
96079: LD_INT 0
96081: PUSH
96082: LD_INT 5
96084: PUSH
96085: EMPTY
96086: LIST
96087: LIST
96088: PUSH
96089: LD_INT 1
96091: NEG
96092: PUSH
96093: LD_INT 4
96095: PUSH
96096: EMPTY
96097: LIST
96098: LIST
96099: PUSH
96100: LD_INT 1
96102: NEG
96103: PUSH
96104: LD_INT 3
96106: PUSH
96107: EMPTY
96108: LIST
96109: LIST
96110: PUSH
96111: LD_INT 2
96113: PUSH
96114: LD_INT 5
96116: PUSH
96117: EMPTY
96118: LIST
96119: LIST
96120: PUSH
96121: LD_INT 2
96123: NEG
96124: PUSH
96125: LD_INT 3
96127: PUSH
96128: EMPTY
96129: LIST
96130: LIST
96131: PUSH
96132: LD_INT 3
96134: NEG
96135: PUSH
96136: LD_INT 0
96138: PUSH
96139: EMPTY
96140: LIST
96141: LIST
96142: PUSH
96143: LD_INT 3
96145: NEG
96146: PUSH
96147: LD_INT 1
96149: NEG
96150: PUSH
96151: EMPTY
96152: LIST
96153: LIST
96154: PUSH
96155: LD_INT 2
96157: NEG
96158: PUSH
96159: LD_INT 0
96161: PUSH
96162: EMPTY
96163: LIST
96164: LIST
96165: PUSH
96166: LD_INT 2
96168: NEG
96169: PUSH
96170: LD_INT 1
96172: PUSH
96173: EMPTY
96174: LIST
96175: LIST
96176: PUSH
96177: LD_INT 3
96179: NEG
96180: PUSH
96181: LD_INT 1
96183: PUSH
96184: EMPTY
96185: LIST
96186: LIST
96187: PUSH
96188: LD_INT 4
96190: NEG
96191: PUSH
96192: LD_INT 0
96194: PUSH
96195: EMPTY
96196: LIST
96197: LIST
96198: PUSH
96199: LD_INT 4
96201: NEG
96202: PUSH
96203: LD_INT 1
96205: NEG
96206: PUSH
96207: EMPTY
96208: LIST
96209: LIST
96210: PUSH
96211: LD_INT 4
96213: NEG
96214: PUSH
96215: LD_INT 2
96217: NEG
96218: PUSH
96219: EMPTY
96220: LIST
96221: LIST
96222: PUSH
96223: LD_INT 2
96225: NEG
96226: PUSH
96227: LD_INT 2
96229: PUSH
96230: EMPTY
96231: LIST
96232: LIST
96233: PUSH
96234: LD_INT 4
96236: NEG
96237: PUSH
96238: LD_INT 4
96240: NEG
96241: PUSH
96242: EMPTY
96243: LIST
96244: LIST
96245: PUSH
96246: LD_INT 4
96248: NEG
96249: PUSH
96250: LD_INT 5
96252: NEG
96253: PUSH
96254: EMPTY
96255: LIST
96256: LIST
96257: PUSH
96258: LD_INT 3
96260: NEG
96261: PUSH
96262: LD_INT 4
96264: NEG
96265: PUSH
96266: EMPTY
96267: LIST
96268: LIST
96269: PUSH
96270: LD_INT 3
96272: NEG
96273: PUSH
96274: LD_INT 3
96276: NEG
96277: PUSH
96278: EMPTY
96279: LIST
96280: LIST
96281: PUSH
96282: LD_INT 4
96284: NEG
96285: PUSH
96286: LD_INT 3
96288: NEG
96289: PUSH
96290: EMPTY
96291: LIST
96292: LIST
96293: PUSH
96294: LD_INT 5
96296: NEG
96297: PUSH
96298: LD_INT 4
96300: NEG
96301: PUSH
96302: EMPTY
96303: LIST
96304: LIST
96305: PUSH
96306: LD_INT 5
96308: NEG
96309: PUSH
96310: LD_INT 5
96312: NEG
96313: PUSH
96314: EMPTY
96315: LIST
96316: LIST
96317: PUSH
96318: LD_INT 3
96320: NEG
96321: PUSH
96322: LD_INT 5
96324: NEG
96325: PUSH
96326: EMPTY
96327: LIST
96328: LIST
96329: PUSH
96330: LD_INT 5
96332: NEG
96333: PUSH
96334: LD_INT 3
96336: NEG
96337: PUSH
96338: EMPTY
96339: LIST
96340: LIST
96341: PUSH
96342: EMPTY
96343: LIST
96344: LIST
96345: LIST
96346: LIST
96347: LIST
96348: LIST
96349: LIST
96350: LIST
96351: LIST
96352: LIST
96353: LIST
96354: LIST
96355: LIST
96356: LIST
96357: LIST
96358: LIST
96359: LIST
96360: LIST
96361: LIST
96362: LIST
96363: LIST
96364: LIST
96365: LIST
96366: LIST
96367: LIST
96368: LIST
96369: LIST
96370: LIST
96371: LIST
96372: LIST
96373: LIST
96374: LIST
96375: LIST
96376: LIST
96377: LIST
96378: LIST
96379: LIST
96380: LIST
96381: LIST
96382: LIST
96383: LIST
96384: LIST
96385: LIST
96386: LIST
96387: LIST
96388: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
96389: LD_ADDR_VAR 0 30
96393: PUSH
96394: LD_INT 4
96396: PUSH
96397: LD_INT 4
96399: PUSH
96400: EMPTY
96401: LIST
96402: LIST
96403: PUSH
96404: LD_INT 4
96406: PUSH
96407: LD_INT 3
96409: PUSH
96410: EMPTY
96411: LIST
96412: LIST
96413: PUSH
96414: LD_INT 5
96416: PUSH
96417: LD_INT 4
96419: PUSH
96420: EMPTY
96421: LIST
96422: LIST
96423: PUSH
96424: LD_INT 5
96426: PUSH
96427: LD_INT 5
96429: PUSH
96430: EMPTY
96431: LIST
96432: LIST
96433: PUSH
96434: LD_INT 4
96436: PUSH
96437: LD_INT 5
96439: PUSH
96440: EMPTY
96441: LIST
96442: LIST
96443: PUSH
96444: LD_INT 3
96446: PUSH
96447: LD_INT 4
96449: PUSH
96450: EMPTY
96451: LIST
96452: LIST
96453: PUSH
96454: LD_INT 3
96456: PUSH
96457: LD_INT 3
96459: PUSH
96460: EMPTY
96461: LIST
96462: LIST
96463: PUSH
96464: LD_INT 5
96466: PUSH
96467: LD_INT 3
96469: PUSH
96470: EMPTY
96471: LIST
96472: LIST
96473: PUSH
96474: LD_INT 3
96476: PUSH
96477: LD_INT 5
96479: PUSH
96480: EMPTY
96481: LIST
96482: LIST
96483: PUSH
96484: LD_INT 0
96486: PUSH
96487: LD_INT 3
96489: PUSH
96490: EMPTY
96491: LIST
96492: LIST
96493: PUSH
96494: LD_INT 0
96496: PUSH
96497: LD_INT 2
96499: PUSH
96500: EMPTY
96501: LIST
96502: LIST
96503: PUSH
96504: LD_INT 1
96506: PUSH
96507: LD_INT 3
96509: PUSH
96510: EMPTY
96511: LIST
96512: LIST
96513: PUSH
96514: LD_INT 1
96516: PUSH
96517: LD_INT 4
96519: PUSH
96520: EMPTY
96521: LIST
96522: LIST
96523: PUSH
96524: LD_INT 0
96526: PUSH
96527: LD_INT 4
96529: PUSH
96530: EMPTY
96531: LIST
96532: LIST
96533: PUSH
96534: LD_INT 1
96536: NEG
96537: PUSH
96538: LD_INT 3
96540: PUSH
96541: EMPTY
96542: LIST
96543: LIST
96544: PUSH
96545: LD_INT 1
96547: NEG
96548: PUSH
96549: LD_INT 2
96551: PUSH
96552: EMPTY
96553: LIST
96554: LIST
96555: PUSH
96556: LD_INT 2
96558: PUSH
96559: LD_INT 4
96561: PUSH
96562: EMPTY
96563: LIST
96564: LIST
96565: PUSH
96566: LD_INT 2
96568: NEG
96569: PUSH
96570: LD_INT 2
96572: PUSH
96573: EMPTY
96574: LIST
96575: LIST
96576: PUSH
96577: LD_INT 4
96579: NEG
96580: PUSH
96581: LD_INT 0
96583: PUSH
96584: EMPTY
96585: LIST
96586: LIST
96587: PUSH
96588: LD_INT 4
96590: NEG
96591: PUSH
96592: LD_INT 1
96594: NEG
96595: PUSH
96596: EMPTY
96597: LIST
96598: LIST
96599: PUSH
96600: LD_INT 3
96602: NEG
96603: PUSH
96604: LD_INT 0
96606: PUSH
96607: EMPTY
96608: LIST
96609: LIST
96610: PUSH
96611: LD_INT 3
96613: NEG
96614: PUSH
96615: LD_INT 1
96617: PUSH
96618: EMPTY
96619: LIST
96620: LIST
96621: PUSH
96622: LD_INT 4
96624: NEG
96625: PUSH
96626: LD_INT 1
96628: PUSH
96629: EMPTY
96630: LIST
96631: LIST
96632: PUSH
96633: LD_INT 5
96635: NEG
96636: PUSH
96637: LD_INT 0
96639: PUSH
96640: EMPTY
96641: LIST
96642: LIST
96643: PUSH
96644: LD_INT 5
96646: NEG
96647: PUSH
96648: LD_INT 1
96650: NEG
96651: PUSH
96652: EMPTY
96653: LIST
96654: LIST
96655: PUSH
96656: LD_INT 5
96658: NEG
96659: PUSH
96660: LD_INT 2
96662: NEG
96663: PUSH
96664: EMPTY
96665: LIST
96666: LIST
96667: PUSH
96668: LD_INT 3
96670: NEG
96671: PUSH
96672: LD_INT 2
96674: PUSH
96675: EMPTY
96676: LIST
96677: LIST
96678: PUSH
96679: LD_INT 3
96681: NEG
96682: PUSH
96683: LD_INT 3
96685: NEG
96686: PUSH
96687: EMPTY
96688: LIST
96689: LIST
96690: PUSH
96691: LD_INT 3
96693: NEG
96694: PUSH
96695: LD_INT 4
96697: NEG
96698: PUSH
96699: EMPTY
96700: LIST
96701: LIST
96702: PUSH
96703: LD_INT 2
96705: NEG
96706: PUSH
96707: LD_INT 3
96709: NEG
96710: PUSH
96711: EMPTY
96712: LIST
96713: LIST
96714: PUSH
96715: LD_INT 2
96717: NEG
96718: PUSH
96719: LD_INT 2
96721: NEG
96722: PUSH
96723: EMPTY
96724: LIST
96725: LIST
96726: PUSH
96727: LD_INT 3
96729: NEG
96730: PUSH
96731: LD_INT 2
96733: NEG
96734: PUSH
96735: EMPTY
96736: LIST
96737: LIST
96738: PUSH
96739: LD_INT 4
96741: NEG
96742: PUSH
96743: LD_INT 3
96745: NEG
96746: PUSH
96747: EMPTY
96748: LIST
96749: LIST
96750: PUSH
96751: LD_INT 4
96753: NEG
96754: PUSH
96755: LD_INT 4
96757: NEG
96758: PUSH
96759: EMPTY
96760: LIST
96761: LIST
96762: PUSH
96763: LD_INT 2
96765: NEG
96766: PUSH
96767: LD_INT 4
96769: NEG
96770: PUSH
96771: EMPTY
96772: LIST
96773: LIST
96774: PUSH
96775: LD_INT 4
96777: NEG
96778: PUSH
96779: LD_INT 2
96781: NEG
96782: PUSH
96783: EMPTY
96784: LIST
96785: LIST
96786: PUSH
96787: LD_INT 0
96789: PUSH
96790: LD_INT 4
96792: NEG
96793: PUSH
96794: EMPTY
96795: LIST
96796: LIST
96797: PUSH
96798: LD_INT 0
96800: PUSH
96801: LD_INT 5
96803: NEG
96804: PUSH
96805: EMPTY
96806: LIST
96807: LIST
96808: PUSH
96809: LD_INT 1
96811: PUSH
96812: LD_INT 4
96814: NEG
96815: PUSH
96816: EMPTY
96817: LIST
96818: LIST
96819: PUSH
96820: LD_INT 1
96822: PUSH
96823: LD_INT 3
96825: NEG
96826: PUSH
96827: EMPTY
96828: LIST
96829: LIST
96830: PUSH
96831: LD_INT 0
96833: PUSH
96834: LD_INT 3
96836: NEG
96837: PUSH
96838: EMPTY
96839: LIST
96840: LIST
96841: PUSH
96842: LD_INT 1
96844: NEG
96845: PUSH
96846: LD_INT 4
96848: NEG
96849: PUSH
96850: EMPTY
96851: LIST
96852: LIST
96853: PUSH
96854: LD_INT 1
96856: NEG
96857: PUSH
96858: LD_INT 5
96860: NEG
96861: PUSH
96862: EMPTY
96863: LIST
96864: LIST
96865: PUSH
96866: LD_INT 2
96868: PUSH
96869: LD_INT 3
96871: NEG
96872: PUSH
96873: EMPTY
96874: LIST
96875: LIST
96876: PUSH
96877: LD_INT 2
96879: NEG
96880: PUSH
96881: LD_INT 5
96883: NEG
96884: PUSH
96885: EMPTY
96886: LIST
96887: LIST
96888: PUSH
96889: EMPTY
96890: LIST
96891: LIST
96892: LIST
96893: LIST
96894: LIST
96895: LIST
96896: LIST
96897: LIST
96898: LIST
96899: LIST
96900: LIST
96901: LIST
96902: LIST
96903: LIST
96904: LIST
96905: LIST
96906: LIST
96907: LIST
96908: LIST
96909: LIST
96910: LIST
96911: LIST
96912: LIST
96913: LIST
96914: LIST
96915: LIST
96916: LIST
96917: LIST
96918: LIST
96919: LIST
96920: LIST
96921: LIST
96922: LIST
96923: LIST
96924: LIST
96925: LIST
96926: LIST
96927: LIST
96928: LIST
96929: LIST
96930: LIST
96931: LIST
96932: LIST
96933: LIST
96934: LIST
96935: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
96936: LD_ADDR_VAR 0 31
96940: PUSH
96941: LD_INT 0
96943: PUSH
96944: LD_INT 4
96946: PUSH
96947: EMPTY
96948: LIST
96949: LIST
96950: PUSH
96951: LD_INT 0
96953: PUSH
96954: LD_INT 3
96956: PUSH
96957: EMPTY
96958: LIST
96959: LIST
96960: PUSH
96961: LD_INT 1
96963: PUSH
96964: LD_INT 4
96966: PUSH
96967: EMPTY
96968: LIST
96969: LIST
96970: PUSH
96971: LD_INT 1
96973: PUSH
96974: LD_INT 5
96976: PUSH
96977: EMPTY
96978: LIST
96979: LIST
96980: PUSH
96981: LD_INT 0
96983: PUSH
96984: LD_INT 5
96986: PUSH
96987: EMPTY
96988: LIST
96989: LIST
96990: PUSH
96991: LD_INT 1
96993: NEG
96994: PUSH
96995: LD_INT 4
96997: PUSH
96998: EMPTY
96999: LIST
97000: LIST
97001: PUSH
97002: LD_INT 1
97004: NEG
97005: PUSH
97006: LD_INT 3
97008: PUSH
97009: EMPTY
97010: LIST
97011: LIST
97012: PUSH
97013: LD_INT 2
97015: PUSH
97016: LD_INT 5
97018: PUSH
97019: EMPTY
97020: LIST
97021: LIST
97022: PUSH
97023: LD_INT 2
97025: NEG
97026: PUSH
97027: LD_INT 3
97029: PUSH
97030: EMPTY
97031: LIST
97032: LIST
97033: PUSH
97034: LD_INT 3
97036: NEG
97037: PUSH
97038: LD_INT 0
97040: PUSH
97041: EMPTY
97042: LIST
97043: LIST
97044: PUSH
97045: LD_INT 3
97047: NEG
97048: PUSH
97049: LD_INT 1
97051: NEG
97052: PUSH
97053: EMPTY
97054: LIST
97055: LIST
97056: PUSH
97057: LD_INT 2
97059: NEG
97060: PUSH
97061: LD_INT 0
97063: PUSH
97064: EMPTY
97065: LIST
97066: LIST
97067: PUSH
97068: LD_INT 2
97070: NEG
97071: PUSH
97072: LD_INT 1
97074: PUSH
97075: EMPTY
97076: LIST
97077: LIST
97078: PUSH
97079: LD_INT 3
97081: NEG
97082: PUSH
97083: LD_INT 1
97085: PUSH
97086: EMPTY
97087: LIST
97088: LIST
97089: PUSH
97090: LD_INT 4
97092: NEG
97093: PUSH
97094: LD_INT 0
97096: PUSH
97097: EMPTY
97098: LIST
97099: LIST
97100: PUSH
97101: LD_INT 4
97103: NEG
97104: PUSH
97105: LD_INT 1
97107: NEG
97108: PUSH
97109: EMPTY
97110: LIST
97111: LIST
97112: PUSH
97113: LD_INT 4
97115: NEG
97116: PUSH
97117: LD_INT 2
97119: NEG
97120: PUSH
97121: EMPTY
97122: LIST
97123: LIST
97124: PUSH
97125: LD_INT 2
97127: NEG
97128: PUSH
97129: LD_INT 2
97131: PUSH
97132: EMPTY
97133: LIST
97134: LIST
97135: PUSH
97136: LD_INT 4
97138: NEG
97139: PUSH
97140: LD_INT 4
97142: NEG
97143: PUSH
97144: EMPTY
97145: LIST
97146: LIST
97147: PUSH
97148: LD_INT 4
97150: NEG
97151: PUSH
97152: LD_INT 5
97154: NEG
97155: PUSH
97156: EMPTY
97157: LIST
97158: LIST
97159: PUSH
97160: LD_INT 3
97162: NEG
97163: PUSH
97164: LD_INT 4
97166: NEG
97167: PUSH
97168: EMPTY
97169: LIST
97170: LIST
97171: PUSH
97172: LD_INT 3
97174: NEG
97175: PUSH
97176: LD_INT 3
97178: NEG
97179: PUSH
97180: EMPTY
97181: LIST
97182: LIST
97183: PUSH
97184: LD_INT 4
97186: NEG
97187: PUSH
97188: LD_INT 3
97190: NEG
97191: PUSH
97192: EMPTY
97193: LIST
97194: LIST
97195: PUSH
97196: LD_INT 5
97198: NEG
97199: PUSH
97200: LD_INT 4
97202: NEG
97203: PUSH
97204: EMPTY
97205: LIST
97206: LIST
97207: PUSH
97208: LD_INT 5
97210: NEG
97211: PUSH
97212: LD_INT 5
97214: NEG
97215: PUSH
97216: EMPTY
97217: LIST
97218: LIST
97219: PUSH
97220: LD_INT 3
97222: NEG
97223: PUSH
97224: LD_INT 5
97226: NEG
97227: PUSH
97228: EMPTY
97229: LIST
97230: LIST
97231: PUSH
97232: LD_INT 5
97234: NEG
97235: PUSH
97236: LD_INT 3
97238: NEG
97239: PUSH
97240: EMPTY
97241: LIST
97242: LIST
97243: PUSH
97244: LD_INT 0
97246: PUSH
97247: LD_INT 3
97249: NEG
97250: PUSH
97251: EMPTY
97252: LIST
97253: LIST
97254: PUSH
97255: LD_INT 0
97257: PUSH
97258: LD_INT 4
97260: NEG
97261: PUSH
97262: EMPTY
97263: LIST
97264: LIST
97265: PUSH
97266: LD_INT 1
97268: PUSH
97269: LD_INT 3
97271: NEG
97272: PUSH
97273: EMPTY
97274: LIST
97275: LIST
97276: PUSH
97277: LD_INT 1
97279: PUSH
97280: LD_INT 2
97282: NEG
97283: PUSH
97284: EMPTY
97285: LIST
97286: LIST
97287: PUSH
97288: LD_INT 0
97290: PUSH
97291: LD_INT 2
97293: NEG
97294: PUSH
97295: EMPTY
97296: LIST
97297: LIST
97298: PUSH
97299: LD_INT 1
97301: NEG
97302: PUSH
97303: LD_INT 3
97305: NEG
97306: PUSH
97307: EMPTY
97308: LIST
97309: LIST
97310: PUSH
97311: LD_INT 1
97313: NEG
97314: PUSH
97315: LD_INT 4
97317: NEG
97318: PUSH
97319: EMPTY
97320: LIST
97321: LIST
97322: PUSH
97323: LD_INT 2
97325: PUSH
97326: LD_INT 2
97328: NEG
97329: PUSH
97330: EMPTY
97331: LIST
97332: LIST
97333: PUSH
97334: LD_INT 2
97336: NEG
97337: PUSH
97338: LD_INT 4
97340: NEG
97341: PUSH
97342: EMPTY
97343: LIST
97344: LIST
97345: PUSH
97346: LD_INT 4
97348: PUSH
97349: LD_INT 0
97351: PUSH
97352: EMPTY
97353: LIST
97354: LIST
97355: PUSH
97356: LD_INT 4
97358: PUSH
97359: LD_INT 1
97361: NEG
97362: PUSH
97363: EMPTY
97364: LIST
97365: LIST
97366: PUSH
97367: LD_INT 5
97369: PUSH
97370: LD_INT 0
97372: PUSH
97373: EMPTY
97374: LIST
97375: LIST
97376: PUSH
97377: LD_INT 5
97379: PUSH
97380: LD_INT 1
97382: PUSH
97383: EMPTY
97384: LIST
97385: LIST
97386: PUSH
97387: LD_INT 4
97389: PUSH
97390: LD_INT 1
97392: PUSH
97393: EMPTY
97394: LIST
97395: LIST
97396: PUSH
97397: LD_INT 3
97399: PUSH
97400: LD_INT 0
97402: PUSH
97403: EMPTY
97404: LIST
97405: LIST
97406: PUSH
97407: LD_INT 3
97409: PUSH
97410: LD_INT 1
97412: NEG
97413: PUSH
97414: EMPTY
97415: LIST
97416: LIST
97417: PUSH
97418: LD_INT 3
97420: PUSH
97421: LD_INT 2
97423: NEG
97424: PUSH
97425: EMPTY
97426: LIST
97427: LIST
97428: PUSH
97429: LD_INT 5
97431: PUSH
97432: LD_INT 2
97434: PUSH
97435: EMPTY
97436: LIST
97437: LIST
97438: PUSH
97439: EMPTY
97440: LIST
97441: LIST
97442: LIST
97443: LIST
97444: LIST
97445: LIST
97446: LIST
97447: LIST
97448: LIST
97449: LIST
97450: LIST
97451: LIST
97452: LIST
97453: LIST
97454: LIST
97455: LIST
97456: LIST
97457: LIST
97458: LIST
97459: LIST
97460: LIST
97461: LIST
97462: LIST
97463: LIST
97464: LIST
97465: LIST
97466: LIST
97467: LIST
97468: LIST
97469: LIST
97470: LIST
97471: LIST
97472: LIST
97473: LIST
97474: LIST
97475: LIST
97476: LIST
97477: LIST
97478: LIST
97479: LIST
97480: LIST
97481: LIST
97482: LIST
97483: LIST
97484: LIST
97485: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
97486: LD_ADDR_VAR 0 32
97490: PUSH
97491: LD_INT 4
97493: NEG
97494: PUSH
97495: LD_INT 0
97497: PUSH
97498: EMPTY
97499: LIST
97500: LIST
97501: PUSH
97502: LD_INT 4
97504: NEG
97505: PUSH
97506: LD_INT 1
97508: NEG
97509: PUSH
97510: EMPTY
97511: LIST
97512: LIST
97513: PUSH
97514: LD_INT 3
97516: NEG
97517: PUSH
97518: LD_INT 0
97520: PUSH
97521: EMPTY
97522: LIST
97523: LIST
97524: PUSH
97525: LD_INT 3
97527: NEG
97528: PUSH
97529: LD_INT 1
97531: PUSH
97532: EMPTY
97533: LIST
97534: LIST
97535: PUSH
97536: LD_INT 4
97538: NEG
97539: PUSH
97540: LD_INT 1
97542: PUSH
97543: EMPTY
97544: LIST
97545: LIST
97546: PUSH
97547: LD_INT 5
97549: NEG
97550: PUSH
97551: LD_INT 0
97553: PUSH
97554: EMPTY
97555: LIST
97556: LIST
97557: PUSH
97558: LD_INT 5
97560: NEG
97561: PUSH
97562: LD_INT 1
97564: NEG
97565: PUSH
97566: EMPTY
97567: LIST
97568: LIST
97569: PUSH
97570: LD_INT 5
97572: NEG
97573: PUSH
97574: LD_INT 2
97576: NEG
97577: PUSH
97578: EMPTY
97579: LIST
97580: LIST
97581: PUSH
97582: LD_INT 3
97584: NEG
97585: PUSH
97586: LD_INT 2
97588: PUSH
97589: EMPTY
97590: LIST
97591: LIST
97592: PUSH
97593: LD_INT 3
97595: NEG
97596: PUSH
97597: LD_INT 3
97599: NEG
97600: PUSH
97601: EMPTY
97602: LIST
97603: LIST
97604: PUSH
97605: LD_INT 3
97607: NEG
97608: PUSH
97609: LD_INT 4
97611: NEG
97612: PUSH
97613: EMPTY
97614: LIST
97615: LIST
97616: PUSH
97617: LD_INT 2
97619: NEG
97620: PUSH
97621: LD_INT 3
97623: NEG
97624: PUSH
97625: EMPTY
97626: LIST
97627: LIST
97628: PUSH
97629: LD_INT 2
97631: NEG
97632: PUSH
97633: LD_INT 2
97635: NEG
97636: PUSH
97637: EMPTY
97638: LIST
97639: LIST
97640: PUSH
97641: LD_INT 3
97643: NEG
97644: PUSH
97645: LD_INT 2
97647: NEG
97648: PUSH
97649: EMPTY
97650: LIST
97651: LIST
97652: PUSH
97653: LD_INT 4
97655: NEG
97656: PUSH
97657: LD_INT 3
97659: NEG
97660: PUSH
97661: EMPTY
97662: LIST
97663: LIST
97664: PUSH
97665: LD_INT 4
97667: NEG
97668: PUSH
97669: LD_INT 4
97671: NEG
97672: PUSH
97673: EMPTY
97674: LIST
97675: LIST
97676: PUSH
97677: LD_INT 2
97679: NEG
97680: PUSH
97681: LD_INT 4
97683: NEG
97684: PUSH
97685: EMPTY
97686: LIST
97687: LIST
97688: PUSH
97689: LD_INT 4
97691: NEG
97692: PUSH
97693: LD_INT 2
97695: NEG
97696: PUSH
97697: EMPTY
97698: LIST
97699: LIST
97700: PUSH
97701: LD_INT 0
97703: PUSH
97704: LD_INT 4
97706: NEG
97707: PUSH
97708: EMPTY
97709: LIST
97710: LIST
97711: PUSH
97712: LD_INT 0
97714: PUSH
97715: LD_INT 5
97717: NEG
97718: PUSH
97719: EMPTY
97720: LIST
97721: LIST
97722: PUSH
97723: LD_INT 1
97725: PUSH
97726: LD_INT 4
97728: NEG
97729: PUSH
97730: EMPTY
97731: LIST
97732: LIST
97733: PUSH
97734: LD_INT 1
97736: PUSH
97737: LD_INT 3
97739: NEG
97740: PUSH
97741: EMPTY
97742: LIST
97743: LIST
97744: PUSH
97745: LD_INT 0
97747: PUSH
97748: LD_INT 3
97750: NEG
97751: PUSH
97752: EMPTY
97753: LIST
97754: LIST
97755: PUSH
97756: LD_INT 1
97758: NEG
97759: PUSH
97760: LD_INT 4
97762: NEG
97763: PUSH
97764: EMPTY
97765: LIST
97766: LIST
97767: PUSH
97768: LD_INT 1
97770: NEG
97771: PUSH
97772: LD_INT 5
97774: NEG
97775: PUSH
97776: EMPTY
97777: LIST
97778: LIST
97779: PUSH
97780: LD_INT 2
97782: PUSH
97783: LD_INT 3
97785: NEG
97786: PUSH
97787: EMPTY
97788: LIST
97789: LIST
97790: PUSH
97791: LD_INT 2
97793: NEG
97794: PUSH
97795: LD_INT 5
97797: NEG
97798: PUSH
97799: EMPTY
97800: LIST
97801: LIST
97802: PUSH
97803: LD_INT 3
97805: PUSH
97806: LD_INT 0
97808: PUSH
97809: EMPTY
97810: LIST
97811: LIST
97812: PUSH
97813: LD_INT 3
97815: PUSH
97816: LD_INT 1
97818: NEG
97819: PUSH
97820: EMPTY
97821: LIST
97822: LIST
97823: PUSH
97824: LD_INT 4
97826: PUSH
97827: LD_INT 0
97829: PUSH
97830: EMPTY
97831: LIST
97832: LIST
97833: PUSH
97834: LD_INT 4
97836: PUSH
97837: LD_INT 1
97839: PUSH
97840: EMPTY
97841: LIST
97842: LIST
97843: PUSH
97844: LD_INT 3
97846: PUSH
97847: LD_INT 1
97849: PUSH
97850: EMPTY
97851: LIST
97852: LIST
97853: PUSH
97854: LD_INT 2
97856: PUSH
97857: LD_INT 0
97859: PUSH
97860: EMPTY
97861: LIST
97862: LIST
97863: PUSH
97864: LD_INT 2
97866: PUSH
97867: LD_INT 1
97869: NEG
97870: PUSH
97871: EMPTY
97872: LIST
97873: LIST
97874: PUSH
97875: LD_INT 2
97877: PUSH
97878: LD_INT 2
97880: NEG
97881: PUSH
97882: EMPTY
97883: LIST
97884: LIST
97885: PUSH
97886: LD_INT 4
97888: PUSH
97889: LD_INT 2
97891: PUSH
97892: EMPTY
97893: LIST
97894: LIST
97895: PUSH
97896: LD_INT 4
97898: PUSH
97899: LD_INT 4
97901: PUSH
97902: EMPTY
97903: LIST
97904: LIST
97905: PUSH
97906: LD_INT 4
97908: PUSH
97909: LD_INT 3
97911: PUSH
97912: EMPTY
97913: LIST
97914: LIST
97915: PUSH
97916: LD_INT 5
97918: PUSH
97919: LD_INT 4
97921: PUSH
97922: EMPTY
97923: LIST
97924: LIST
97925: PUSH
97926: LD_INT 5
97928: PUSH
97929: LD_INT 5
97931: PUSH
97932: EMPTY
97933: LIST
97934: LIST
97935: PUSH
97936: LD_INT 4
97938: PUSH
97939: LD_INT 5
97941: PUSH
97942: EMPTY
97943: LIST
97944: LIST
97945: PUSH
97946: LD_INT 3
97948: PUSH
97949: LD_INT 4
97951: PUSH
97952: EMPTY
97953: LIST
97954: LIST
97955: PUSH
97956: LD_INT 3
97958: PUSH
97959: LD_INT 3
97961: PUSH
97962: EMPTY
97963: LIST
97964: LIST
97965: PUSH
97966: LD_INT 5
97968: PUSH
97969: LD_INT 3
97971: PUSH
97972: EMPTY
97973: LIST
97974: LIST
97975: PUSH
97976: LD_INT 3
97978: PUSH
97979: LD_INT 5
97981: PUSH
97982: EMPTY
97983: LIST
97984: LIST
97985: PUSH
97986: EMPTY
97987: LIST
97988: LIST
97989: LIST
97990: LIST
97991: LIST
97992: LIST
97993: LIST
97994: LIST
97995: LIST
97996: LIST
97997: LIST
97998: LIST
97999: LIST
98000: LIST
98001: LIST
98002: LIST
98003: LIST
98004: LIST
98005: LIST
98006: LIST
98007: LIST
98008: LIST
98009: LIST
98010: LIST
98011: LIST
98012: LIST
98013: LIST
98014: LIST
98015: LIST
98016: LIST
98017: LIST
98018: LIST
98019: LIST
98020: LIST
98021: LIST
98022: LIST
98023: LIST
98024: LIST
98025: LIST
98026: LIST
98027: LIST
98028: LIST
98029: LIST
98030: LIST
98031: LIST
98032: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
98033: LD_ADDR_VAR 0 33
98037: PUSH
98038: LD_INT 4
98040: NEG
98041: PUSH
98042: LD_INT 4
98044: NEG
98045: PUSH
98046: EMPTY
98047: LIST
98048: LIST
98049: PUSH
98050: LD_INT 4
98052: NEG
98053: PUSH
98054: LD_INT 5
98056: NEG
98057: PUSH
98058: EMPTY
98059: LIST
98060: LIST
98061: PUSH
98062: LD_INT 3
98064: NEG
98065: PUSH
98066: LD_INT 4
98068: NEG
98069: PUSH
98070: EMPTY
98071: LIST
98072: LIST
98073: PUSH
98074: LD_INT 3
98076: NEG
98077: PUSH
98078: LD_INT 3
98080: NEG
98081: PUSH
98082: EMPTY
98083: LIST
98084: LIST
98085: PUSH
98086: LD_INT 4
98088: NEG
98089: PUSH
98090: LD_INT 3
98092: NEG
98093: PUSH
98094: EMPTY
98095: LIST
98096: LIST
98097: PUSH
98098: LD_INT 5
98100: NEG
98101: PUSH
98102: LD_INT 4
98104: NEG
98105: PUSH
98106: EMPTY
98107: LIST
98108: LIST
98109: PUSH
98110: LD_INT 5
98112: NEG
98113: PUSH
98114: LD_INT 5
98116: NEG
98117: PUSH
98118: EMPTY
98119: LIST
98120: LIST
98121: PUSH
98122: LD_INT 3
98124: NEG
98125: PUSH
98126: LD_INT 5
98128: NEG
98129: PUSH
98130: EMPTY
98131: LIST
98132: LIST
98133: PUSH
98134: LD_INT 5
98136: NEG
98137: PUSH
98138: LD_INT 3
98140: NEG
98141: PUSH
98142: EMPTY
98143: LIST
98144: LIST
98145: PUSH
98146: LD_INT 0
98148: PUSH
98149: LD_INT 3
98151: NEG
98152: PUSH
98153: EMPTY
98154: LIST
98155: LIST
98156: PUSH
98157: LD_INT 0
98159: PUSH
98160: LD_INT 4
98162: NEG
98163: PUSH
98164: EMPTY
98165: LIST
98166: LIST
98167: PUSH
98168: LD_INT 1
98170: PUSH
98171: LD_INT 3
98173: NEG
98174: PUSH
98175: EMPTY
98176: LIST
98177: LIST
98178: PUSH
98179: LD_INT 1
98181: PUSH
98182: LD_INT 2
98184: NEG
98185: PUSH
98186: EMPTY
98187: LIST
98188: LIST
98189: PUSH
98190: LD_INT 0
98192: PUSH
98193: LD_INT 2
98195: NEG
98196: PUSH
98197: EMPTY
98198: LIST
98199: LIST
98200: PUSH
98201: LD_INT 1
98203: NEG
98204: PUSH
98205: LD_INT 3
98207: NEG
98208: PUSH
98209: EMPTY
98210: LIST
98211: LIST
98212: PUSH
98213: LD_INT 1
98215: NEG
98216: PUSH
98217: LD_INT 4
98219: NEG
98220: PUSH
98221: EMPTY
98222: LIST
98223: LIST
98224: PUSH
98225: LD_INT 2
98227: PUSH
98228: LD_INT 2
98230: NEG
98231: PUSH
98232: EMPTY
98233: LIST
98234: LIST
98235: PUSH
98236: LD_INT 2
98238: NEG
98239: PUSH
98240: LD_INT 4
98242: NEG
98243: PUSH
98244: EMPTY
98245: LIST
98246: LIST
98247: PUSH
98248: LD_INT 4
98250: PUSH
98251: LD_INT 0
98253: PUSH
98254: EMPTY
98255: LIST
98256: LIST
98257: PUSH
98258: LD_INT 4
98260: PUSH
98261: LD_INT 1
98263: NEG
98264: PUSH
98265: EMPTY
98266: LIST
98267: LIST
98268: PUSH
98269: LD_INT 5
98271: PUSH
98272: LD_INT 0
98274: PUSH
98275: EMPTY
98276: LIST
98277: LIST
98278: PUSH
98279: LD_INT 5
98281: PUSH
98282: LD_INT 1
98284: PUSH
98285: EMPTY
98286: LIST
98287: LIST
98288: PUSH
98289: LD_INT 4
98291: PUSH
98292: LD_INT 1
98294: PUSH
98295: EMPTY
98296: LIST
98297: LIST
98298: PUSH
98299: LD_INT 3
98301: PUSH
98302: LD_INT 0
98304: PUSH
98305: EMPTY
98306: LIST
98307: LIST
98308: PUSH
98309: LD_INT 3
98311: PUSH
98312: LD_INT 1
98314: NEG
98315: PUSH
98316: EMPTY
98317: LIST
98318: LIST
98319: PUSH
98320: LD_INT 3
98322: PUSH
98323: LD_INT 2
98325: NEG
98326: PUSH
98327: EMPTY
98328: LIST
98329: LIST
98330: PUSH
98331: LD_INT 5
98333: PUSH
98334: LD_INT 2
98336: PUSH
98337: EMPTY
98338: LIST
98339: LIST
98340: PUSH
98341: LD_INT 3
98343: PUSH
98344: LD_INT 3
98346: PUSH
98347: EMPTY
98348: LIST
98349: LIST
98350: PUSH
98351: LD_INT 3
98353: PUSH
98354: LD_INT 2
98356: PUSH
98357: EMPTY
98358: LIST
98359: LIST
98360: PUSH
98361: LD_INT 4
98363: PUSH
98364: LD_INT 3
98366: PUSH
98367: EMPTY
98368: LIST
98369: LIST
98370: PUSH
98371: LD_INT 4
98373: PUSH
98374: LD_INT 4
98376: PUSH
98377: EMPTY
98378: LIST
98379: LIST
98380: PUSH
98381: LD_INT 3
98383: PUSH
98384: LD_INT 4
98386: PUSH
98387: EMPTY
98388: LIST
98389: LIST
98390: PUSH
98391: LD_INT 2
98393: PUSH
98394: LD_INT 3
98396: PUSH
98397: EMPTY
98398: LIST
98399: LIST
98400: PUSH
98401: LD_INT 2
98403: PUSH
98404: LD_INT 2
98406: PUSH
98407: EMPTY
98408: LIST
98409: LIST
98410: PUSH
98411: LD_INT 4
98413: PUSH
98414: LD_INT 2
98416: PUSH
98417: EMPTY
98418: LIST
98419: LIST
98420: PUSH
98421: LD_INT 2
98423: PUSH
98424: LD_INT 4
98426: PUSH
98427: EMPTY
98428: LIST
98429: LIST
98430: PUSH
98431: LD_INT 0
98433: PUSH
98434: LD_INT 4
98436: PUSH
98437: EMPTY
98438: LIST
98439: LIST
98440: PUSH
98441: LD_INT 0
98443: PUSH
98444: LD_INT 3
98446: PUSH
98447: EMPTY
98448: LIST
98449: LIST
98450: PUSH
98451: LD_INT 1
98453: PUSH
98454: LD_INT 4
98456: PUSH
98457: EMPTY
98458: LIST
98459: LIST
98460: PUSH
98461: LD_INT 1
98463: PUSH
98464: LD_INT 5
98466: PUSH
98467: EMPTY
98468: LIST
98469: LIST
98470: PUSH
98471: LD_INT 0
98473: PUSH
98474: LD_INT 5
98476: PUSH
98477: EMPTY
98478: LIST
98479: LIST
98480: PUSH
98481: LD_INT 1
98483: NEG
98484: PUSH
98485: LD_INT 4
98487: PUSH
98488: EMPTY
98489: LIST
98490: LIST
98491: PUSH
98492: LD_INT 1
98494: NEG
98495: PUSH
98496: LD_INT 3
98498: PUSH
98499: EMPTY
98500: LIST
98501: LIST
98502: PUSH
98503: LD_INT 2
98505: PUSH
98506: LD_INT 5
98508: PUSH
98509: EMPTY
98510: LIST
98511: LIST
98512: PUSH
98513: LD_INT 2
98515: NEG
98516: PUSH
98517: LD_INT 3
98519: PUSH
98520: EMPTY
98521: LIST
98522: LIST
98523: PUSH
98524: EMPTY
98525: LIST
98526: LIST
98527: LIST
98528: LIST
98529: LIST
98530: LIST
98531: LIST
98532: LIST
98533: LIST
98534: LIST
98535: LIST
98536: LIST
98537: LIST
98538: LIST
98539: LIST
98540: LIST
98541: LIST
98542: LIST
98543: LIST
98544: LIST
98545: LIST
98546: LIST
98547: LIST
98548: LIST
98549: LIST
98550: LIST
98551: LIST
98552: LIST
98553: LIST
98554: LIST
98555: LIST
98556: LIST
98557: LIST
98558: LIST
98559: LIST
98560: LIST
98561: LIST
98562: LIST
98563: LIST
98564: LIST
98565: LIST
98566: LIST
98567: LIST
98568: LIST
98569: LIST
98570: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
98571: LD_ADDR_VAR 0 34
98575: PUSH
98576: LD_INT 0
98578: PUSH
98579: LD_INT 4
98581: NEG
98582: PUSH
98583: EMPTY
98584: LIST
98585: LIST
98586: PUSH
98587: LD_INT 0
98589: PUSH
98590: LD_INT 5
98592: NEG
98593: PUSH
98594: EMPTY
98595: LIST
98596: LIST
98597: PUSH
98598: LD_INT 1
98600: PUSH
98601: LD_INT 4
98603: NEG
98604: PUSH
98605: EMPTY
98606: LIST
98607: LIST
98608: PUSH
98609: LD_INT 1
98611: PUSH
98612: LD_INT 3
98614: NEG
98615: PUSH
98616: EMPTY
98617: LIST
98618: LIST
98619: PUSH
98620: LD_INT 0
98622: PUSH
98623: LD_INT 3
98625: NEG
98626: PUSH
98627: EMPTY
98628: LIST
98629: LIST
98630: PUSH
98631: LD_INT 1
98633: NEG
98634: PUSH
98635: LD_INT 4
98637: NEG
98638: PUSH
98639: EMPTY
98640: LIST
98641: LIST
98642: PUSH
98643: LD_INT 1
98645: NEG
98646: PUSH
98647: LD_INT 5
98649: NEG
98650: PUSH
98651: EMPTY
98652: LIST
98653: LIST
98654: PUSH
98655: LD_INT 2
98657: PUSH
98658: LD_INT 3
98660: NEG
98661: PUSH
98662: EMPTY
98663: LIST
98664: LIST
98665: PUSH
98666: LD_INT 2
98668: NEG
98669: PUSH
98670: LD_INT 5
98672: NEG
98673: PUSH
98674: EMPTY
98675: LIST
98676: LIST
98677: PUSH
98678: LD_INT 3
98680: PUSH
98681: LD_INT 0
98683: PUSH
98684: EMPTY
98685: LIST
98686: LIST
98687: PUSH
98688: LD_INT 3
98690: PUSH
98691: LD_INT 1
98693: NEG
98694: PUSH
98695: EMPTY
98696: LIST
98697: LIST
98698: PUSH
98699: LD_INT 4
98701: PUSH
98702: LD_INT 0
98704: PUSH
98705: EMPTY
98706: LIST
98707: LIST
98708: PUSH
98709: LD_INT 4
98711: PUSH
98712: LD_INT 1
98714: PUSH
98715: EMPTY
98716: LIST
98717: LIST
98718: PUSH
98719: LD_INT 3
98721: PUSH
98722: LD_INT 1
98724: PUSH
98725: EMPTY
98726: LIST
98727: LIST
98728: PUSH
98729: LD_INT 2
98731: PUSH
98732: LD_INT 0
98734: PUSH
98735: EMPTY
98736: LIST
98737: LIST
98738: PUSH
98739: LD_INT 2
98741: PUSH
98742: LD_INT 1
98744: NEG
98745: PUSH
98746: EMPTY
98747: LIST
98748: LIST
98749: PUSH
98750: LD_INT 2
98752: PUSH
98753: LD_INT 2
98755: NEG
98756: PUSH
98757: EMPTY
98758: LIST
98759: LIST
98760: PUSH
98761: LD_INT 4
98763: PUSH
98764: LD_INT 2
98766: PUSH
98767: EMPTY
98768: LIST
98769: LIST
98770: PUSH
98771: LD_INT 4
98773: PUSH
98774: LD_INT 4
98776: PUSH
98777: EMPTY
98778: LIST
98779: LIST
98780: PUSH
98781: LD_INT 4
98783: PUSH
98784: LD_INT 3
98786: PUSH
98787: EMPTY
98788: LIST
98789: LIST
98790: PUSH
98791: LD_INT 5
98793: PUSH
98794: LD_INT 4
98796: PUSH
98797: EMPTY
98798: LIST
98799: LIST
98800: PUSH
98801: LD_INT 5
98803: PUSH
98804: LD_INT 5
98806: PUSH
98807: EMPTY
98808: LIST
98809: LIST
98810: PUSH
98811: LD_INT 4
98813: PUSH
98814: LD_INT 5
98816: PUSH
98817: EMPTY
98818: LIST
98819: LIST
98820: PUSH
98821: LD_INT 3
98823: PUSH
98824: LD_INT 4
98826: PUSH
98827: EMPTY
98828: LIST
98829: LIST
98830: PUSH
98831: LD_INT 3
98833: PUSH
98834: LD_INT 3
98836: PUSH
98837: EMPTY
98838: LIST
98839: LIST
98840: PUSH
98841: LD_INT 5
98843: PUSH
98844: LD_INT 3
98846: PUSH
98847: EMPTY
98848: LIST
98849: LIST
98850: PUSH
98851: LD_INT 3
98853: PUSH
98854: LD_INT 5
98856: PUSH
98857: EMPTY
98858: LIST
98859: LIST
98860: PUSH
98861: LD_INT 0
98863: PUSH
98864: LD_INT 3
98866: PUSH
98867: EMPTY
98868: LIST
98869: LIST
98870: PUSH
98871: LD_INT 0
98873: PUSH
98874: LD_INT 2
98876: PUSH
98877: EMPTY
98878: LIST
98879: LIST
98880: PUSH
98881: LD_INT 1
98883: PUSH
98884: LD_INT 3
98886: PUSH
98887: EMPTY
98888: LIST
98889: LIST
98890: PUSH
98891: LD_INT 1
98893: PUSH
98894: LD_INT 4
98896: PUSH
98897: EMPTY
98898: LIST
98899: LIST
98900: PUSH
98901: LD_INT 0
98903: PUSH
98904: LD_INT 4
98906: PUSH
98907: EMPTY
98908: LIST
98909: LIST
98910: PUSH
98911: LD_INT 1
98913: NEG
98914: PUSH
98915: LD_INT 3
98917: PUSH
98918: EMPTY
98919: LIST
98920: LIST
98921: PUSH
98922: LD_INT 1
98924: NEG
98925: PUSH
98926: LD_INT 2
98928: PUSH
98929: EMPTY
98930: LIST
98931: LIST
98932: PUSH
98933: LD_INT 2
98935: PUSH
98936: LD_INT 4
98938: PUSH
98939: EMPTY
98940: LIST
98941: LIST
98942: PUSH
98943: LD_INT 2
98945: NEG
98946: PUSH
98947: LD_INT 2
98949: PUSH
98950: EMPTY
98951: LIST
98952: LIST
98953: PUSH
98954: LD_INT 4
98956: NEG
98957: PUSH
98958: LD_INT 0
98960: PUSH
98961: EMPTY
98962: LIST
98963: LIST
98964: PUSH
98965: LD_INT 4
98967: NEG
98968: PUSH
98969: LD_INT 1
98971: NEG
98972: PUSH
98973: EMPTY
98974: LIST
98975: LIST
98976: PUSH
98977: LD_INT 3
98979: NEG
98980: PUSH
98981: LD_INT 0
98983: PUSH
98984: EMPTY
98985: LIST
98986: LIST
98987: PUSH
98988: LD_INT 3
98990: NEG
98991: PUSH
98992: LD_INT 1
98994: PUSH
98995: EMPTY
98996: LIST
98997: LIST
98998: PUSH
98999: LD_INT 4
99001: NEG
99002: PUSH
99003: LD_INT 1
99005: PUSH
99006: EMPTY
99007: LIST
99008: LIST
99009: PUSH
99010: LD_INT 5
99012: NEG
99013: PUSH
99014: LD_INT 0
99016: PUSH
99017: EMPTY
99018: LIST
99019: LIST
99020: PUSH
99021: LD_INT 5
99023: NEG
99024: PUSH
99025: LD_INT 1
99027: NEG
99028: PUSH
99029: EMPTY
99030: LIST
99031: LIST
99032: PUSH
99033: LD_INT 5
99035: NEG
99036: PUSH
99037: LD_INT 2
99039: NEG
99040: PUSH
99041: EMPTY
99042: LIST
99043: LIST
99044: PUSH
99045: LD_INT 3
99047: NEG
99048: PUSH
99049: LD_INT 2
99051: PUSH
99052: EMPTY
99053: LIST
99054: LIST
99055: PUSH
99056: EMPTY
99057: LIST
99058: LIST
99059: LIST
99060: LIST
99061: LIST
99062: LIST
99063: LIST
99064: LIST
99065: LIST
99066: LIST
99067: LIST
99068: LIST
99069: LIST
99070: LIST
99071: LIST
99072: LIST
99073: LIST
99074: LIST
99075: LIST
99076: LIST
99077: LIST
99078: LIST
99079: LIST
99080: LIST
99081: LIST
99082: LIST
99083: LIST
99084: LIST
99085: LIST
99086: LIST
99087: LIST
99088: LIST
99089: LIST
99090: LIST
99091: LIST
99092: LIST
99093: LIST
99094: LIST
99095: LIST
99096: LIST
99097: LIST
99098: LIST
99099: LIST
99100: LIST
99101: LIST
99102: ST_TO_ADDR
// end ; end ;
99103: GO 99106
99105: POP
// case btype of b_depot , b_warehouse :
99106: LD_VAR 0 1
99110: PUSH
99111: LD_INT 0
99113: DOUBLE
99114: EQUAL
99115: IFTRUE 99125
99117: LD_INT 1
99119: DOUBLE
99120: EQUAL
99121: IFTRUE 99125
99123: GO 99326
99125: POP
// case nation of nation_american :
99126: LD_VAR 0 5
99130: PUSH
99131: LD_INT 1
99133: DOUBLE
99134: EQUAL
99135: IFTRUE 99139
99137: GO 99195
99139: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
99140: LD_ADDR_VAR 0 9
99144: PUSH
99145: LD_VAR 0 11
99149: PUSH
99150: LD_VAR 0 12
99154: PUSH
99155: LD_VAR 0 13
99159: PUSH
99160: LD_VAR 0 14
99164: PUSH
99165: LD_VAR 0 15
99169: PUSH
99170: LD_VAR 0 16
99174: PUSH
99175: EMPTY
99176: LIST
99177: LIST
99178: LIST
99179: LIST
99180: LIST
99181: LIST
99182: PUSH
99183: LD_VAR 0 4
99187: PUSH
99188: LD_INT 1
99190: PLUS
99191: ARRAY
99192: ST_TO_ADDR
99193: GO 99324
99195: LD_INT 2
99197: DOUBLE
99198: EQUAL
99199: IFTRUE 99203
99201: GO 99259
99203: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
99204: LD_ADDR_VAR 0 9
99208: PUSH
99209: LD_VAR 0 17
99213: PUSH
99214: LD_VAR 0 18
99218: PUSH
99219: LD_VAR 0 19
99223: PUSH
99224: LD_VAR 0 20
99228: PUSH
99229: LD_VAR 0 21
99233: PUSH
99234: LD_VAR 0 22
99238: PUSH
99239: EMPTY
99240: LIST
99241: LIST
99242: LIST
99243: LIST
99244: LIST
99245: LIST
99246: PUSH
99247: LD_VAR 0 4
99251: PUSH
99252: LD_INT 1
99254: PLUS
99255: ARRAY
99256: ST_TO_ADDR
99257: GO 99324
99259: LD_INT 3
99261: DOUBLE
99262: EQUAL
99263: IFTRUE 99267
99265: GO 99323
99267: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
99268: LD_ADDR_VAR 0 9
99272: PUSH
99273: LD_VAR 0 23
99277: PUSH
99278: LD_VAR 0 24
99282: PUSH
99283: LD_VAR 0 25
99287: PUSH
99288: LD_VAR 0 26
99292: PUSH
99293: LD_VAR 0 27
99297: PUSH
99298: LD_VAR 0 28
99302: PUSH
99303: EMPTY
99304: LIST
99305: LIST
99306: LIST
99307: LIST
99308: LIST
99309: LIST
99310: PUSH
99311: LD_VAR 0 4
99315: PUSH
99316: LD_INT 1
99318: PLUS
99319: ARRAY
99320: ST_TO_ADDR
99321: GO 99324
99323: POP
99324: GO 99879
99326: LD_INT 2
99328: DOUBLE
99329: EQUAL
99330: IFTRUE 99340
99332: LD_INT 3
99334: DOUBLE
99335: EQUAL
99336: IFTRUE 99340
99338: GO 99396
99340: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
99341: LD_ADDR_VAR 0 9
99345: PUSH
99346: LD_VAR 0 29
99350: PUSH
99351: LD_VAR 0 30
99355: PUSH
99356: LD_VAR 0 31
99360: PUSH
99361: LD_VAR 0 32
99365: PUSH
99366: LD_VAR 0 33
99370: PUSH
99371: LD_VAR 0 34
99375: PUSH
99376: EMPTY
99377: LIST
99378: LIST
99379: LIST
99380: LIST
99381: LIST
99382: LIST
99383: PUSH
99384: LD_VAR 0 4
99388: PUSH
99389: LD_INT 1
99391: PLUS
99392: ARRAY
99393: ST_TO_ADDR
99394: GO 99879
99396: LD_INT 16
99398: DOUBLE
99399: EQUAL
99400: IFTRUE 99458
99402: LD_INT 17
99404: DOUBLE
99405: EQUAL
99406: IFTRUE 99458
99408: LD_INT 18
99410: DOUBLE
99411: EQUAL
99412: IFTRUE 99458
99414: LD_INT 19
99416: DOUBLE
99417: EQUAL
99418: IFTRUE 99458
99420: LD_INT 22
99422: DOUBLE
99423: EQUAL
99424: IFTRUE 99458
99426: LD_INT 20
99428: DOUBLE
99429: EQUAL
99430: IFTRUE 99458
99432: LD_INT 21
99434: DOUBLE
99435: EQUAL
99436: IFTRUE 99458
99438: LD_INT 23
99440: DOUBLE
99441: EQUAL
99442: IFTRUE 99458
99444: LD_INT 24
99446: DOUBLE
99447: EQUAL
99448: IFTRUE 99458
99450: LD_INT 25
99452: DOUBLE
99453: EQUAL
99454: IFTRUE 99458
99456: GO 99514
99458: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
99459: LD_ADDR_VAR 0 9
99463: PUSH
99464: LD_VAR 0 35
99468: PUSH
99469: LD_VAR 0 36
99473: PUSH
99474: LD_VAR 0 37
99478: PUSH
99479: LD_VAR 0 38
99483: PUSH
99484: LD_VAR 0 39
99488: PUSH
99489: LD_VAR 0 40
99493: PUSH
99494: EMPTY
99495: LIST
99496: LIST
99497: LIST
99498: LIST
99499: LIST
99500: LIST
99501: PUSH
99502: LD_VAR 0 4
99506: PUSH
99507: LD_INT 1
99509: PLUS
99510: ARRAY
99511: ST_TO_ADDR
99512: GO 99879
99514: LD_INT 6
99516: DOUBLE
99517: EQUAL
99518: IFTRUE 99570
99520: LD_INT 7
99522: DOUBLE
99523: EQUAL
99524: IFTRUE 99570
99526: LD_INT 8
99528: DOUBLE
99529: EQUAL
99530: IFTRUE 99570
99532: LD_INT 13
99534: DOUBLE
99535: EQUAL
99536: IFTRUE 99570
99538: LD_INT 12
99540: DOUBLE
99541: EQUAL
99542: IFTRUE 99570
99544: LD_INT 15
99546: DOUBLE
99547: EQUAL
99548: IFTRUE 99570
99550: LD_INT 11
99552: DOUBLE
99553: EQUAL
99554: IFTRUE 99570
99556: LD_INT 14
99558: DOUBLE
99559: EQUAL
99560: IFTRUE 99570
99562: LD_INT 10
99564: DOUBLE
99565: EQUAL
99566: IFTRUE 99570
99568: GO 99626
99570: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
99571: LD_ADDR_VAR 0 9
99575: PUSH
99576: LD_VAR 0 41
99580: PUSH
99581: LD_VAR 0 42
99585: PUSH
99586: LD_VAR 0 43
99590: PUSH
99591: LD_VAR 0 44
99595: PUSH
99596: LD_VAR 0 45
99600: PUSH
99601: LD_VAR 0 46
99605: PUSH
99606: EMPTY
99607: LIST
99608: LIST
99609: LIST
99610: LIST
99611: LIST
99612: LIST
99613: PUSH
99614: LD_VAR 0 4
99618: PUSH
99619: LD_INT 1
99621: PLUS
99622: ARRAY
99623: ST_TO_ADDR
99624: GO 99879
99626: LD_INT 36
99628: DOUBLE
99629: EQUAL
99630: IFTRUE 99634
99632: GO 99690
99634: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
99635: LD_ADDR_VAR 0 9
99639: PUSH
99640: LD_VAR 0 47
99644: PUSH
99645: LD_VAR 0 48
99649: PUSH
99650: LD_VAR 0 49
99654: PUSH
99655: LD_VAR 0 50
99659: PUSH
99660: LD_VAR 0 51
99664: PUSH
99665: LD_VAR 0 52
99669: PUSH
99670: EMPTY
99671: LIST
99672: LIST
99673: LIST
99674: LIST
99675: LIST
99676: LIST
99677: PUSH
99678: LD_VAR 0 4
99682: PUSH
99683: LD_INT 1
99685: PLUS
99686: ARRAY
99687: ST_TO_ADDR
99688: GO 99879
99690: LD_INT 4
99692: DOUBLE
99693: EQUAL
99694: IFTRUE 99716
99696: LD_INT 5
99698: DOUBLE
99699: EQUAL
99700: IFTRUE 99716
99702: LD_INT 34
99704: DOUBLE
99705: EQUAL
99706: IFTRUE 99716
99708: LD_INT 37
99710: DOUBLE
99711: EQUAL
99712: IFTRUE 99716
99714: GO 99772
99716: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
99717: LD_ADDR_VAR 0 9
99721: PUSH
99722: LD_VAR 0 53
99726: PUSH
99727: LD_VAR 0 54
99731: PUSH
99732: LD_VAR 0 55
99736: PUSH
99737: LD_VAR 0 56
99741: PUSH
99742: LD_VAR 0 57
99746: PUSH
99747: LD_VAR 0 58
99751: PUSH
99752: EMPTY
99753: LIST
99754: LIST
99755: LIST
99756: LIST
99757: LIST
99758: LIST
99759: PUSH
99760: LD_VAR 0 4
99764: PUSH
99765: LD_INT 1
99767: PLUS
99768: ARRAY
99769: ST_TO_ADDR
99770: GO 99879
99772: LD_INT 31
99774: DOUBLE
99775: EQUAL
99776: IFTRUE 99822
99778: LD_INT 32
99780: DOUBLE
99781: EQUAL
99782: IFTRUE 99822
99784: LD_INT 33
99786: DOUBLE
99787: EQUAL
99788: IFTRUE 99822
99790: LD_INT 27
99792: DOUBLE
99793: EQUAL
99794: IFTRUE 99822
99796: LD_INT 26
99798: DOUBLE
99799: EQUAL
99800: IFTRUE 99822
99802: LD_INT 28
99804: DOUBLE
99805: EQUAL
99806: IFTRUE 99822
99808: LD_INT 29
99810: DOUBLE
99811: EQUAL
99812: IFTRUE 99822
99814: LD_INT 30
99816: DOUBLE
99817: EQUAL
99818: IFTRUE 99822
99820: GO 99878
99822: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
99823: LD_ADDR_VAR 0 9
99827: PUSH
99828: LD_VAR 0 59
99832: PUSH
99833: LD_VAR 0 60
99837: PUSH
99838: LD_VAR 0 61
99842: PUSH
99843: LD_VAR 0 62
99847: PUSH
99848: LD_VAR 0 63
99852: PUSH
99853: LD_VAR 0 64
99857: PUSH
99858: EMPTY
99859: LIST
99860: LIST
99861: LIST
99862: LIST
99863: LIST
99864: LIST
99865: PUSH
99866: LD_VAR 0 4
99870: PUSH
99871: LD_INT 1
99873: PLUS
99874: ARRAY
99875: ST_TO_ADDR
99876: GO 99879
99878: POP
// temp_list2 = [ ] ;
99879: LD_ADDR_VAR 0 10
99883: PUSH
99884: EMPTY
99885: ST_TO_ADDR
// for i in temp_list do
99886: LD_ADDR_VAR 0 8
99890: PUSH
99891: LD_VAR 0 9
99895: PUSH
99896: FOR_IN
99897: IFFALSE 99949
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
99899: LD_ADDR_VAR 0 10
99903: PUSH
99904: LD_VAR 0 10
99908: PUSH
99909: LD_VAR 0 8
99913: PUSH
99914: LD_INT 1
99916: ARRAY
99917: PUSH
99918: LD_VAR 0 2
99922: PLUS
99923: PUSH
99924: LD_VAR 0 8
99928: PUSH
99929: LD_INT 2
99931: ARRAY
99932: PUSH
99933: LD_VAR 0 3
99937: PLUS
99938: PUSH
99939: EMPTY
99940: LIST
99941: LIST
99942: PUSH
99943: EMPTY
99944: LIST
99945: ADD
99946: ST_TO_ADDR
99947: GO 99896
99949: POP
99950: POP
// result = temp_list2 ;
99951: LD_ADDR_VAR 0 7
99955: PUSH
99956: LD_VAR 0 10
99960: ST_TO_ADDR
// end ;
99961: LD_VAR 0 7
99965: RET
// export function EnemyInRange ( unit , dist ) ; begin
99966: LD_INT 0
99968: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
99969: LD_ADDR_VAR 0 3
99973: PUSH
99974: LD_VAR 0 1
99978: PPUSH
99979: CALL_OW 255
99983: PPUSH
99984: LD_VAR 0 1
99988: PPUSH
99989: CALL_OW 250
99993: PPUSH
99994: LD_VAR 0 1
99998: PPUSH
99999: CALL_OW 251
100003: PPUSH
100004: LD_VAR 0 2
100008: PPUSH
100009: CALL 73368 0 4
100013: PUSH
100014: LD_INT 4
100016: ARRAY
100017: ST_TO_ADDR
// end ;
100018: LD_VAR 0 3
100022: RET
// export function PlayerSeeMe ( unit ) ; begin
100023: LD_INT 0
100025: PPUSH
// result := See ( your_side , unit ) ;
100026: LD_ADDR_VAR 0 2
100030: PUSH
100031: LD_OWVAR 2
100035: PPUSH
100036: LD_VAR 0 1
100040: PPUSH
100041: CALL_OW 292
100045: ST_TO_ADDR
// end ;
100046: LD_VAR 0 2
100050: RET
// export function ReverseDir ( unit ) ; begin
100051: LD_INT 0
100053: PPUSH
// if not unit then
100054: LD_VAR 0 1
100058: NOT
100059: IFFALSE 100063
// exit ;
100061: GO 100086
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
100063: LD_ADDR_VAR 0 2
100067: PUSH
100068: LD_VAR 0 1
100072: PPUSH
100073: CALL_OW 254
100077: PUSH
100078: LD_INT 3
100080: PLUS
100081: PUSH
100082: LD_INT 6
100084: MOD
100085: ST_TO_ADDR
// end ;
100086: LD_VAR 0 2
100090: RET
// export function ReverseArray ( array ) ; var i ; begin
100091: LD_INT 0
100093: PPUSH
100094: PPUSH
// if not array then
100095: LD_VAR 0 1
100099: NOT
100100: IFFALSE 100104
// exit ;
100102: GO 100159
// result := [ ] ;
100104: LD_ADDR_VAR 0 2
100108: PUSH
100109: EMPTY
100110: ST_TO_ADDR
// for i := array downto 1 do
100111: LD_ADDR_VAR 0 3
100115: PUSH
100116: DOUBLE
100117: LD_VAR 0 1
100121: INC
100122: ST_TO_ADDR
100123: LD_INT 1
100125: PUSH
100126: FOR_DOWNTO
100127: IFFALSE 100157
// result := Join ( result , array [ i ] ) ;
100129: LD_ADDR_VAR 0 2
100133: PUSH
100134: LD_VAR 0 2
100138: PPUSH
100139: LD_VAR 0 1
100143: PUSH
100144: LD_VAR 0 3
100148: ARRAY
100149: PPUSH
100150: CALL 104784 0 2
100154: ST_TO_ADDR
100155: GO 100126
100157: POP
100158: POP
// end ;
100159: LD_VAR 0 2
100163: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
100164: LD_INT 0
100166: PPUSH
100167: PPUSH
100168: PPUSH
100169: PPUSH
100170: PPUSH
100171: PPUSH
// if not unit or not hexes then
100172: LD_VAR 0 1
100176: NOT
100177: PUSH
100178: LD_VAR 0 2
100182: NOT
100183: OR
100184: IFFALSE 100188
// exit ;
100186: GO 100311
// dist := 9999 ;
100188: LD_ADDR_VAR 0 5
100192: PUSH
100193: LD_INT 9999
100195: ST_TO_ADDR
// for i = 1 to hexes do
100196: LD_ADDR_VAR 0 4
100200: PUSH
100201: DOUBLE
100202: LD_INT 1
100204: DEC
100205: ST_TO_ADDR
100206: LD_VAR 0 2
100210: PUSH
100211: FOR_TO
100212: IFFALSE 100299
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
100214: LD_ADDR_VAR 0 6
100218: PUSH
100219: LD_VAR 0 1
100223: PPUSH
100224: LD_VAR 0 2
100228: PUSH
100229: LD_VAR 0 4
100233: ARRAY
100234: PUSH
100235: LD_INT 1
100237: ARRAY
100238: PPUSH
100239: LD_VAR 0 2
100243: PUSH
100244: LD_VAR 0 4
100248: ARRAY
100249: PUSH
100250: LD_INT 2
100252: ARRAY
100253: PPUSH
100254: CALL_OW 297
100258: ST_TO_ADDR
// if tdist < dist then
100259: LD_VAR 0 6
100263: PUSH
100264: LD_VAR 0 5
100268: LESS
100269: IFFALSE 100297
// begin hex := hexes [ i ] ;
100271: LD_ADDR_VAR 0 8
100275: PUSH
100276: LD_VAR 0 2
100280: PUSH
100281: LD_VAR 0 4
100285: ARRAY
100286: ST_TO_ADDR
// dist := tdist ;
100287: LD_ADDR_VAR 0 5
100291: PUSH
100292: LD_VAR 0 6
100296: ST_TO_ADDR
// end ; end ;
100297: GO 100211
100299: POP
100300: POP
// result := hex ;
100301: LD_ADDR_VAR 0 3
100305: PUSH
100306: LD_VAR 0 8
100310: ST_TO_ADDR
// end ;
100311: LD_VAR 0 3
100315: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
100316: LD_INT 0
100318: PPUSH
100319: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
100320: LD_VAR 0 1
100324: NOT
100325: PUSH
100326: LD_VAR 0 1
100330: PUSH
100331: LD_INT 21
100333: PUSH
100334: LD_INT 2
100336: PUSH
100337: EMPTY
100338: LIST
100339: LIST
100340: PUSH
100341: LD_INT 23
100343: PUSH
100344: LD_INT 2
100346: PUSH
100347: EMPTY
100348: LIST
100349: LIST
100350: PUSH
100351: EMPTY
100352: LIST
100353: LIST
100354: PPUSH
100355: CALL_OW 69
100359: IN
100360: NOT
100361: OR
100362: IFFALSE 100366
// exit ;
100364: GO 100413
// for i = 1 to 3 do
100366: LD_ADDR_VAR 0 3
100370: PUSH
100371: DOUBLE
100372: LD_INT 1
100374: DEC
100375: ST_TO_ADDR
100376: LD_INT 3
100378: PUSH
100379: FOR_TO
100380: IFFALSE 100411
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
100382: LD_VAR 0 1
100386: PPUSH
100387: CALL_OW 250
100391: PPUSH
100392: LD_VAR 0 1
100396: PPUSH
100397: CALL_OW 251
100401: PPUSH
100402: LD_INT 1
100404: PPUSH
100405: CALL_OW 453
100409: GO 100379
100411: POP
100412: POP
// end ;
100413: LD_VAR 0 2
100417: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
100418: LD_INT 0
100420: PPUSH
100421: PPUSH
100422: PPUSH
100423: PPUSH
100424: PPUSH
100425: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
100426: LD_VAR 0 1
100430: NOT
100431: PUSH
100432: LD_VAR 0 2
100436: NOT
100437: OR
100438: PUSH
100439: LD_VAR 0 1
100443: PPUSH
100444: CALL_OW 314
100448: OR
100449: IFFALSE 100453
// exit ;
100451: GO 100894
// x := GetX ( enemy_unit ) ;
100453: LD_ADDR_VAR 0 7
100457: PUSH
100458: LD_VAR 0 2
100462: PPUSH
100463: CALL_OW 250
100467: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
100468: LD_ADDR_VAR 0 8
100472: PUSH
100473: LD_VAR 0 2
100477: PPUSH
100478: CALL_OW 251
100482: ST_TO_ADDR
// if not x or not y then
100483: LD_VAR 0 7
100487: NOT
100488: PUSH
100489: LD_VAR 0 8
100493: NOT
100494: OR
100495: IFFALSE 100499
// exit ;
100497: GO 100894
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
100499: LD_ADDR_VAR 0 6
100503: PUSH
100504: LD_VAR 0 7
100508: PPUSH
100509: LD_INT 0
100511: PPUSH
100512: LD_INT 4
100514: PPUSH
100515: CALL_OW 272
100519: PUSH
100520: LD_VAR 0 8
100524: PPUSH
100525: LD_INT 0
100527: PPUSH
100528: LD_INT 4
100530: PPUSH
100531: CALL_OW 273
100535: PUSH
100536: EMPTY
100537: LIST
100538: LIST
100539: PUSH
100540: LD_VAR 0 7
100544: PPUSH
100545: LD_INT 1
100547: PPUSH
100548: LD_INT 4
100550: PPUSH
100551: CALL_OW 272
100555: PUSH
100556: LD_VAR 0 8
100560: PPUSH
100561: LD_INT 1
100563: PPUSH
100564: LD_INT 4
100566: PPUSH
100567: CALL_OW 273
100571: PUSH
100572: EMPTY
100573: LIST
100574: LIST
100575: PUSH
100576: LD_VAR 0 7
100580: PPUSH
100581: LD_INT 2
100583: PPUSH
100584: LD_INT 4
100586: PPUSH
100587: CALL_OW 272
100591: PUSH
100592: LD_VAR 0 8
100596: PPUSH
100597: LD_INT 2
100599: PPUSH
100600: LD_INT 4
100602: PPUSH
100603: CALL_OW 273
100607: PUSH
100608: EMPTY
100609: LIST
100610: LIST
100611: PUSH
100612: LD_VAR 0 7
100616: PPUSH
100617: LD_INT 3
100619: PPUSH
100620: LD_INT 4
100622: PPUSH
100623: CALL_OW 272
100627: PUSH
100628: LD_VAR 0 8
100632: PPUSH
100633: LD_INT 3
100635: PPUSH
100636: LD_INT 4
100638: PPUSH
100639: CALL_OW 273
100643: PUSH
100644: EMPTY
100645: LIST
100646: LIST
100647: PUSH
100648: LD_VAR 0 7
100652: PPUSH
100653: LD_INT 4
100655: PPUSH
100656: LD_INT 4
100658: PPUSH
100659: CALL_OW 272
100663: PUSH
100664: LD_VAR 0 8
100668: PPUSH
100669: LD_INT 4
100671: PPUSH
100672: LD_INT 4
100674: PPUSH
100675: CALL_OW 273
100679: PUSH
100680: EMPTY
100681: LIST
100682: LIST
100683: PUSH
100684: LD_VAR 0 7
100688: PPUSH
100689: LD_INT 5
100691: PPUSH
100692: LD_INT 4
100694: PPUSH
100695: CALL_OW 272
100699: PUSH
100700: LD_VAR 0 8
100704: PPUSH
100705: LD_INT 5
100707: PPUSH
100708: LD_INT 4
100710: PPUSH
100711: CALL_OW 273
100715: PUSH
100716: EMPTY
100717: LIST
100718: LIST
100719: PUSH
100720: EMPTY
100721: LIST
100722: LIST
100723: LIST
100724: LIST
100725: LIST
100726: LIST
100727: ST_TO_ADDR
// for i = tmp downto 1 do
100728: LD_ADDR_VAR 0 4
100732: PUSH
100733: DOUBLE
100734: LD_VAR 0 6
100738: INC
100739: ST_TO_ADDR
100740: LD_INT 1
100742: PUSH
100743: FOR_DOWNTO
100744: IFFALSE 100845
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
100746: LD_VAR 0 6
100750: PUSH
100751: LD_VAR 0 4
100755: ARRAY
100756: PUSH
100757: LD_INT 1
100759: ARRAY
100760: PPUSH
100761: LD_VAR 0 6
100765: PUSH
100766: LD_VAR 0 4
100770: ARRAY
100771: PUSH
100772: LD_INT 2
100774: ARRAY
100775: PPUSH
100776: CALL_OW 488
100780: NOT
100781: PUSH
100782: LD_VAR 0 6
100786: PUSH
100787: LD_VAR 0 4
100791: ARRAY
100792: PUSH
100793: LD_INT 1
100795: ARRAY
100796: PPUSH
100797: LD_VAR 0 6
100801: PUSH
100802: LD_VAR 0 4
100806: ARRAY
100807: PUSH
100808: LD_INT 2
100810: ARRAY
100811: PPUSH
100812: CALL_OW 428
100816: PUSH
100817: LD_INT 0
100819: NONEQUAL
100820: OR
100821: IFFALSE 100843
// tmp := Delete ( tmp , i ) ;
100823: LD_ADDR_VAR 0 6
100827: PUSH
100828: LD_VAR 0 6
100832: PPUSH
100833: LD_VAR 0 4
100837: PPUSH
100838: CALL_OW 3
100842: ST_TO_ADDR
100843: GO 100743
100845: POP
100846: POP
// j := GetClosestHex ( unit , tmp ) ;
100847: LD_ADDR_VAR 0 5
100851: PUSH
100852: LD_VAR 0 1
100856: PPUSH
100857: LD_VAR 0 6
100861: PPUSH
100862: CALL 100164 0 2
100866: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
100867: LD_VAR 0 1
100871: PPUSH
100872: LD_VAR 0 5
100876: PUSH
100877: LD_INT 1
100879: ARRAY
100880: PPUSH
100881: LD_VAR 0 5
100885: PUSH
100886: LD_INT 2
100888: ARRAY
100889: PPUSH
100890: CALL_OW 111
// end ;
100894: LD_VAR 0 3
100898: RET
// export function PrepareApemanSoldier ( ) ; begin
100899: LD_INT 0
100901: PPUSH
// uc_nation := 0 ;
100902: LD_ADDR_OWVAR 21
100906: PUSH
100907: LD_INT 0
100909: ST_TO_ADDR
// hc_sex := sex_male ;
100910: LD_ADDR_OWVAR 27
100914: PUSH
100915: LD_INT 1
100917: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
100918: LD_ADDR_OWVAR 28
100922: PUSH
100923: LD_INT 15
100925: ST_TO_ADDR
// hc_gallery :=  ;
100926: LD_ADDR_OWVAR 33
100930: PUSH
100931: LD_STRING 
100933: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
100934: LD_ADDR_OWVAR 31
100938: PUSH
100939: LD_INT 0
100941: PPUSH
100942: LD_INT 3
100944: PPUSH
100945: CALL_OW 12
100949: PUSH
100950: LD_INT 0
100952: PPUSH
100953: LD_INT 3
100955: PPUSH
100956: CALL_OW 12
100960: PUSH
100961: LD_INT 0
100963: PUSH
100964: LD_INT 0
100966: PUSH
100967: EMPTY
100968: LIST
100969: LIST
100970: LIST
100971: LIST
100972: ST_TO_ADDR
// end ;
100973: LD_VAR 0 1
100977: RET
// export function PrepareApemanEngineer ( ) ; begin
100978: LD_INT 0
100980: PPUSH
// uc_nation := 0 ;
100981: LD_ADDR_OWVAR 21
100985: PUSH
100986: LD_INT 0
100988: ST_TO_ADDR
// hc_sex := sex_male ;
100989: LD_ADDR_OWVAR 27
100993: PUSH
100994: LD_INT 1
100996: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
100997: LD_ADDR_OWVAR 28
101001: PUSH
101002: LD_INT 16
101004: ST_TO_ADDR
// hc_gallery :=  ;
101005: LD_ADDR_OWVAR 33
101009: PUSH
101010: LD_STRING 
101012: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
101013: LD_ADDR_OWVAR 31
101017: PUSH
101018: LD_INT 0
101020: PPUSH
101021: LD_INT 3
101023: PPUSH
101024: CALL_OW 12
101028: PUSH
101029: LD_INT 0
101031: PPUSH
101032: LD_INT 3
101034: PPUSH
101035: CALL_OW 12
101039: PUSH
101040: LD_INT 0
101042: PUSH
101043: LD_INT 0
101045: PUSH
101046: EMPTY
101047: LIST
101048: LIST
101049: LIST
101050: LIST
101051: ST_TO_ADDR
// end ;
101052: LD_VAR 0 1
101056: RET
// export function PrepareApeman ( agressivity ) ; begin
101057: LD_INT 0
101059: PPUSH
// uc_side := 0 ;
101060: LD_ADDR_OWVAR 20
101064: PUSH
101065: LD_INT 0
101067: ST_TO_ADDR
// uc_nation := 0 ;
101068: LD_ADDR_OWVAR 21
101072: PUSH
101073: LD_INT 0
101075: ST_TO_ADDR
// hc_sex := sex_male ;
101076: LD_ADDR_OWVAR 27
101080: PUSH
101081: LD_INT 1
101083: ST_TO_ADDR
// hc_class := class_apeman ;
101084: LD_ADDR_OWVAR 28
101088: PUSH
101089: LD_INT 12
101091: ST_TO_ADDR
// hc_gallery :=  ;
101092: LD_ADDR_OWVAR 33
101096: PUSH
101097: LD_STRING 
101099: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
101100: LD_ADDR_OWVAR 35
101104: PUSH
101105: LD_VAR 0 1
101109: NEG
101110: PPUSH
101111: LD_VAR 0 1
101115: PPUSH
101116: CALL_OW 12
101120: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
101121: LD_ADDR_OWVAR 31
101125: PUSH
101126: LD_INT 0
101128: PPUSH
101129: LD_INT 3
101131: PPUSH
101132: CALL_OW 12
101136: PUSH
101137: LD_INT 0
101139: PPUSH
101140: LD_INT 3
101142: PPUSH
101143: CALL_OW 12
101147: PUSH
101148: LD_INT 0
101150: PUSH
101151: LD_INT 0
101153: PUSH
101154: EMPTY
101155: LIST
101156: LIST
101157: LIST
101158: LIST
101159: ST_TO_ADDR
// end ;
101160: LD_VAR 0 2
101164: RET
// export function PrepareTiger ( agressivity ) ; begin
101165: LD_INT 0
101167: PPUSH
// uc_side := 0 ;
101168: LD_ADDR_OWVAR 20
101172: PUSH
101173: LD_INT 0
101175: ST_TO_ADDR
// uc_nation := 0 ;
101176: LD_ADDR_OWVAR 21
101180: PUSH
101181: LD_INT 0
101183: ST_TO_ADDR
// hc_class := class_tiger ;
101184: LD_ADDR_OWVAR 28
101188: PUSH
101189: LD_INT 14
101191: ST_TO_ADDR
// hc_gallery :=  ;
101192: LD_ADDR_OWVAR 33
101196: PUSH
101197: LD_STRING 
101199: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
101200: LD_ADDR_OWVAR 35
101204: PUSH
101205: LD_VAR 0 1
101209: NEG
101210: PPUSH
101211: LD_VAR 0 1
101215: PPUSH
101216: CALL_OW 12
101220: ST_TO_ADDR
// end ;
101221: LD_VAR 0 2
101225: RET
// export function PrepareEnchidna ( ) ; begin
101226: LD_INT 0
101228: PPUSH
// uc_side := 0 ;
101229: LD_ADDR_OWVAR 20
101233: PUSH
101234: LD_INT 0
101236: ST_TO_ADDR
// uc_nation := 0 ;
101237: LD_ADDR_OWVAR 21
101241: PUSH
101242: LD_INT 0
101244: ST_TO_ADDR
// hc_class := class_baggie ;
101245: LD_ADDR_OWVAR 28
101249: PUSH
101250: LD_INT 13
101252: ST_TO_ADDR
// hc_gallery :=  ;
101253: LD_ADDR_OWVAR 33
101257: PUSH
101258: LD_STRING 
101260: ST_TO_ADDR
// end ;
101261: LD_VAR 0 1
101265: RET
// export function PrepareFrog ( ) ; begin
101266: LD_INT 0
101268: PPUSH
// uc_side := 0 ;
101269: LD_ADDR_OWVAR 20
101273: PUSH
101274: LD_INT 0
101276: ST_TO_ADDR
// uc_nation := 0 ;
101277: LD_ADDR_OWVAR 21
101281: PUSH
101282: LD_INT 0
101284: ST_TO_ADDR
// hc_class := class_frog ;
101285: LD_ADDR_OWVAR 28
101289: PUSH
101290: LD_INT 19
101292: ST_TO_ADDR
// hc_gallery :=  ;
101293: LD_ADDR_OWVAR 33
101297: PUSH
101298: LD_STRING 
101300: ST_TO_ADDR
// end ;
101301: LD_VAR 0 1
101305: RET
// export function PrepareFish ( ) ; begin
101306: LD_INT 0
101308: PPUSH
// uc_side := 0 ;
101309: LD_ADDR_OWVAR 20
101313: PUSH
101314: LD_INT 0
101316: ST_TO_ADDR
// uc_nation := 0 ;
101317: LD_ADDR_OWVAR 21
101321: PUSH
101322: LD_INT 0
101324: ST_TO_ADDR
// hc_class := class_fish ;
101325: LD_ADDR_OWVAR 28
101329: PUSH
101330: LD_INT 20
101332: ST_TO_ADDR
// hc_gallery :=  ;
101333: LD_ADDR_OWVAR 33
101337: PUSH
101338: LD_STRING 
101340: ST_TO_ADDR
// end ;
101341: LD_VAR 0 1
101345: RET
// export function PrepareBird ( ) ; begin
101346: LD_INT 0
101348: PPUSH
// uc_side := 0 ;
101349: LD_ADDR_OWVAR 20
101353: PUSH
101354: LD_INT 0
101356: ST_TO_ADDR
// uc_nation := 0 ;
101357: LD_ADDR_OWVAR 21
101361: PUSH
101362: LD_INT 0
101364: ST_TO_ADDR
// hc_class := class_phororhacos ;
101365: LD_ADDR_OWVAR 28
101369: PUSH
101370: LD_INT 18
101372: ST_TO_ADDR
// hc_gallery :=  ;
101373: LD_ADDR_OWVAR 33
101377: PUSH
101378: LD_STRING 
101380: ST_TO_ADDR
// end ;
101381: LD_VAR 0 1
101385: RET
// export function PrepareHorse ( ) ; begin
101386: LD_INT 0
101388: PPUSH
// uc_side := 0 ;
101389: LD_ADDR_OWVAR 20
101393: PUSH
101394: LD_INT 0
101396: ST_TO_ADDR
// uc_nation := 0 ;
101397: LD_ADDR_OWVAR 21
101401: PUSH
101402: LD_INT 0
101404: ST_TO_ADDR
// hc_class := class_horse ;
101405: LD_ADDR_OWVAR 28
101409: PUSH
101410: LD_INT 21
101412: ST_TO_ADDR
// hc_gallery :=  ;
101413: LD_ADDR_OWVAR 33
101417: PUSH
101418: LD_STRING 
101420: ST_TO_ADDR
// end ;
101421: LD_VAR 0 1
101425: RET
// export function PrepareMastodont ( ) ; begin
101426: LD_INT 0
101428: PPUSH
// uc_side := 0 ;
101429: LD_ADDR_OWVAR 20
101433: PUSH
101434: LD_INT 0
101436: ST_TO_ADDR
// uc_nation := 0 ;
101437: LD_ADDR_OWVAR 21
101441: PUSH
101442: LD_INT 0
101444: ST_TO_ADDR
// vc_chassis := class_mastodont ;
101445: LD_ADDR_OWVAR 37
101449: PUSH
101450: LD_INT 31
101452: ST_TO_ADDR
// vc_control := control_rider ;
101453: LD_ADDR_OWVAR 38
101457: PUSH
101458: LD_INT 4
101460: ST_TO_ADDR
// end ;
101461: LD_VAR 0 1
101465: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
101466: LD_INT 0
101468: PPUSH
101469: PPUSH
101470: PPUSH
// uc_side = 0 ;
101471: LD_ADDR_OWVAR 20
101475: PUSH
101476: LD_INT 0
101478: ST_TO_ADDR
// uc_nation = 0 ;
101479: LD_ADDR_OWVAR 21
101483: PUSH
101484: LD_INT 0
101486: ST_TO_ADDR
// InitHc_All ( ) ;
101487: CALL_OW 584
// InitVc ;
101491: CALL_OW 20
// if mastodonts then
101495: LD_VAR 0 6
101499: IFFALSE 101566
// for i = 1 to mastodonts do
101501: LD_ADDR_VAR 0 11
101505: PUSH
101506: DOUBLE
101507: LD_INT 1
101509: DEC
101510: ST_TO_ADDR
101511: LD_VAR 0 6
101515: PUSH
101516: FOR_TO
101517: IFFALSE 101564
// begin vc_chassis := 31 ;
101519: LD_ADDR_OWVAR 37
101523: PUSH
101524: LD_INT 31
101526: ST_TO_ADDR
// vc_control := control_rider ;
101527: LD_ADDR_OWVAR 38
101531: PUSH
101532: LD_INT 4
101534: ST_TO_ADDR
// animal := CreateVehicle ;
101535: LD_ADDR_VAR 0 12
101539: PUSH
101540: CALL_OW 45
101544: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101545: LD_VAR 0 12
101549: PPUSH
101550: LD_VAR 0 8
101554: PPUSH
101555: LD_INT 0
101557: PPUSH
101558: CALL 103701 0 3
// end ;
101562: GO 101516
101564: POP
101565: POP
// if horses then
101566: LD_VAR 0 5
101570: IFFALSE 101637
// for i = 1 to horses do
101572: LD_ADDR_VAR 0 11
101576: PUSH
101577: DOUBLE
101578: LD_INT 1
101580: DEC
101581: ST_TO_ADDR
101582: LD_VAR 0 5
101586: PUSH
101587: FOR_TO
101588: IFFALSE 101635
// begin hc_class := 21 ;
101590: LD_ADDR_OWVAR 28
101594: PUSH
101595: LD_INT 21
101597: ST_TO_ADDR
// hc_gallery :=  ;
101598: LD_ADDR_OWVAR 33
101602: PUSH
101603: LD_STRING 
101605: ST_TO_ADDR
// animal := CreateHuman ;
101606: LD_ADDR_VAR 0 12
101610: PUSH
101611: CALL_OW 44
101615: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101616: LD_VAR 0 12
101620: PPUSH
101621: LD_VAR 0 8
101625: PPUSH
101626: LD_INT 0
101628: PPUSH
101629: CALL 103701 0 3
// end ;
101633: GO 101587
101635: POP
101636: POP
// if birds then
101637: LD_VAR 0 1
101641: IFFALSE 101708
// for i = 1 to birds do
101643: LD_ADDR_VAR 0 11
101647: PUSH
101648: DOUBLE
101649: LD_INT 1
101651: DEC
101652: ST_TO_ADDR
101653: LD_VAR 0 1
101657: PUSH
101658: FOR_TO
101659: IFFALSE 101706
// begin hc_class = 18 ;
101661: LD_ADDR_OWVAR 28
101665: PUSH
101666: LD_INT 18
101668: ST_TO_ADDR
// hc_gallery =  ;
101669: LD_ADDR_OWVAR 33
101673: PUSH
101674: LD_STRING 
101676: ST_TO_ADDR
// animal := CreateHuman ;
101677: LD_ADDR_VAR 0 12
101681: PUSH
101682: CALL_OW 44
101686: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101687: LD_VAR 0 12
101691: PPUSH
101692: LD_VAR 0 8
101696: PPUSH
101697: LD_INT 0
101699: PPUSH
101700: CALL 103701 0 3
// end ;
101704: GO 101658
101706: POP
101707: POP
// if tigers then
101708: LD_VAR 0 2
101712: IFFALSE 101796
// for i = 1 to tigers do
101714: LD_ADDR_VAR 0 11
101718: PUSH
101719: DOUBLE
101720: LD_INT 1
101722: DEC
101723: ST_TO_ADDR
101724: LD_VAR 0 2
101728: PUSH
101729: FOR_TO
101730: IFFALSE 101794
// begin hc_class = class_tiger ;
101732: LD_ADDR_OWVAR 28
101736: PUSH
101737: LD_INT 14
101739: ST_TO_ADDR
// hc_gallery =  ;
101740: LD_ADDR_OWVAR 33
101744: PUSH
101745: LD_STRING 
101747: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
101748: LD_ADDR_OWVAR 35
101752: PUSH
101753: LD_INT 7
101755: NEG
101756: PPUSH
101757: LD_INT 7
101759: PPUSH
101760: CALL_OW 12
101764: ST_TO_ADDR
// animal := CreateHuman ;
101765: LD_ADDR_VAR 0 12
101769: PUSH
101770: CALL_OW 44
101774: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101775: LD_VAR 0 12
101779: PPUSH
101780: LD_VAR 0 8
101784: PPUSH
101785: LD_INT 0
101787: PPUSH
101788: CALL 103701 0 3
// end ;
101792: GO 101729
101794: POP
101795: POP
// if apemans then
101796: LD_VAR 0 3
101800: IFFALSE 101923
// for i = 1 to apemans do
101802: LD_ADDR_VAR 0 11
101806: PUSH
101807: DOUBLE
101808: LD_INT 1
101810: DEC
101811: ST_TO_ADDR
101812: LD_VAR 0 3
101816: PUSH
101817: FOR_TO
101818: IFFALSE 101921
// begin hc_class = class_apeman ;
101820: LD_ADDR_OWVAR 28
101824: PUSH
101825: LD_INT 12
101827: ST_TO_ADDR
// hc_gallery =  ;
101828: LD_ADDR_OWVAR 33
101832: PUSH
101833: LD_STRING 
101835: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
101836: LD_ADDR_OWVAR 35
101840: PUSH
101841: LD_INT 2
101843: NEG
101844: PPUSH
101845: LD_INT 2
101847: PPUSH
101848: CALL_OW 12
101852: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
101853: LD_ADDR_OWVAR 31
101857: PUSH
101858: LD_INT 1
101860: PPUSH
101861: LD_INT 3
101863: PPUSH
101864: CALL_OW 12
101868: PUSH
101869: LD_INT 1
101871: PPUSH
101872: LD_INT 3
101874: PPUSH
101875: CALL_OW 12
101879: PUSH
101880: LD_INT 0
101882: PUSH
101883: LD_INT 0
101885: PUSH
101886: EMPTY
101887: LIST
101888: LIST
101889: LIST
101890: LIST
101891: ST_TO_ADDR
// animal := CreateHuman ;
101892: LD_ADDR_VAR 0 12
101896: PUSH
101897: CALL_OW 44
101901: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101902: LD_VAR 0 12
101906: PPUSH
101907: LD_VAR 0 8
101911: PPUSH
101912: LD_INT 0
101914: PPUSH
101915: CALL 103701 0 3
// end ;
101919: GO 101817
101921: POP
101922: POP
// if enchidnas then
101923: LD_VAR 0 4
101927: IFFALSE 101994
// for i = 1 to enchidnas do
101929: LD_ADDR_VAR 0 11
101933: PUSH
101934: DOUBLE
101935: LD_INT 1
101937: DEC
101938: ST_TO_ADDR
101939: LD_VAR 0 4
101943: PUSH
101944: FOR_TO
101945: IFFALSE 101992
// begin hc_class = 13 ;
101947: LD_ADDR_OWVAR 28
101951: PUSH
101952: LD_INT 13
101954: ST_TO_ADDR
// hc_gallery =  ;
101955: LD_ADDR_OWVAR 33
101959: PUSH
101960: LD_STRING 
101962: ST_TO_ADDR
// animal := CreateHuman ;
101963: LD_ADDR_VAR 0 12
101967: PUSH
101968: CALL_OW 44
101972: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101973: LD_VAR 0 12
101977: PPUSH
101978: LD_VAR 0 8
101982: PPUSH
101983: LD_INT 0
101985: PPUSH
101986: CALL 103701 0 3
// end ;
101990: GO 101944
101992: POP
101993: POP
// if fishes then
101994: LD_VAR 0 7
101998: IFFALSE 102065
// for i = 1 to fishes do
102000: LD_ADDR_VAR 0 11
102004: PUSH
102005: DOUBLE
102006: LD_INT 1
102008: DEC
102009: ST_TO_ADDR
102010: LD_VAR 0 7
102014: PUSH
102015: FOR_TO
102016: IFFALSE 102063
// begin hc_class = 20 ;
102018: LD_ADDR_OWVAR 28
102022: PUSH
102023: LD_INT 20
102025: ST_TO_ADDR
// hc_gallery =  ;
102026: LD_ADDR_OWVAR 33
102030: PUSH
102031: LD_STRING 
102033: ST_TO_ADDR
// animal := CreateHuman ;
102034: LD_ADDR_VAR 0 12
102038: PUSH
102039: CALL_OW 44
102043: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
102044: LD_VAR 0 12
102048: PPUSH
102049: LD_VAR 0 9
102053: PPUSH
102054: LD_INT 0
102056: PPUSH
102057: CALL 103701 0 3
// end ;
102061: GO 102015
102063: POP
102064: POP
// end ;
102065: LD_VAR 0 10
102069: RET
// export function WantHeal ( sci , unit ) ; begin
102070: LD_INT 0
102072: PPUSH
// if GetTaskList ( sci ) > 0 then
102073: LD_VAR 0 1
102077: PPUSH
102078: CALL_OW 437
102082: PUSH
102083: LD_INT 0
102085: GREATER
102086: IFFALSE 102156
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
102088: LD_VAR 0 1
102092: PPUSH
102093: CALL_OW 437
102097: PUSH
102098: LD_INT 1
102100: ARRAY
102101: PUSH
102102: LD_INT 1
102104: ARRAY
102105: PUSH
102106: LD_STRING l
102108: EQUAL
102109: PUSH
102110: LD_VAR 0 1
102114: PPUSH
102115: CALL_OW 437
102119: PUSH
102120: LD_INT 1
102122: ARRAY
102123: PUSH
102124: LD_INT 4
102126: ARRAY
102127: PUSH
102128: LD_VAR 0 2
102132: EQUAL
102133: AND
102134: IFFALSE 102146
// result := true else
102136: LD_ADDR_VAR 0 3
102140: PUSH
102141: LD_INT 1
102143: ST_TO_ADDR
102144: GO 102154
// result := false ;
102146: LD_ADDR_VAR 0 3
102150: PUSH
102151: LD_INT 0
102153: ST_TO_ADDR
// end else
102154: GO 102164
// result := false ;
102156: LD_ADDR_VAR 0 3
102160: PUSH
102161: LD_INT 0
102163: ST_TO_ADDR
// end ;
102164: LD_VAR 0 3
102168: RET
// export function HealTarget ( sci ) ; begin
102169: LD_INT 0
102171: PPUSH
// if not sci then
102172: LD_VAR 0 1
102176: NOT
102177: IFFALSE 102181
// exit ;
102179: GO 102246
// result := 0 ;
102181: LD_ADDR_VAR 0 2
102185: PUSH
102186: LD_INT 0
102188: ST_TO_ADDR
// if GetTaskList ( sci ) then
102189: LD_VAR 0 1
102193: PPUSH
102194: CALL_OW 437
102198: IFFALSE 102246
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
102200: LD_VAR 0 1
102204: PPUSH
102205: CALL_OW 437
102209: PUSH
102210: LD_INT 1
102212: ARRAY
102213: PUSH
102214: LD_INT 1
102216: ARRAY
102217: PUSH
102218: LD_STRING l
102220: EQUAL
102221: IFFALSE 102246
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
102223: LD_ADDR_VAR 0 2
102227: PUSH
102228: LD_VAR 0 1
102232: PPUSH
102233: CALL_OW 437
102237: PUSH
102238: LD_INT 1
102240: ARRAY
102241: PUSH
102242: LD_INT 4
102244: ARRAY
102245: ST_TO_ADDR
// end ;
102246: LD_VAR 0 2
102250: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
102251: LD_INT 0
102253: PPUSH
102254: PPUSH
102255: PPUSH
102256: PPUSH
// if not base_units then
102257: LD_VAR 0 1
102261: NOT
102262: IFFALSE 102266
// exit ;
102264: GO 102353
// result := false ;
102266: LD_ADDR_VAR 0 2
102270: PUSH
102271: LD_INT 0
102273: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
102274: LD_ADDR_VAR 0 5
102278: PUSH
102279: LD_VAR 0 1
102283: PPUSH
102284: LD_INT 21
102286: PUSH
102287: LD_INT 3
102289: PUSH
102290: EMPTY
102291: LIST
102292: LIST
102293: PPUSH
102294: CALL_OW 72
102298: ST_TO_ADDR
// if not tmp then
102299: LD_VAR 0 5
102303: NOT
102304: IFFALSE 102308
// exit ;
102306: GO 102353
// for i in tmp do
102308: LD_ADDR_VAR 0 3
102312: PUSH
102313: LD_VAR 0 5
102317: PUSH
102318: FOR_IN
102319: IFFALSE 102351
// begin result := EnemyInRange ( i , 22 ) ;
102321: LD_ADDR_VAR 0 2
102325: PUSH
102326: LD_VAR 0 3
102330: PPUSH
102331: LD_INT 22
102333: PPUSH
102334: CALL 99966 0 2
102338: ST_TO_ADDR
// if result then
102339: LD_VAR 0 2
102343: IFFALSE 102349
// exit ;
102345: POP
102346: POP
102347: GO 102353
// end ;
102349: GO 102318
102351: POP
102352: POP
// end ;
102353: LD_VAR 0 2
102357: RET
// export function FilterByTag ( units , tag ) ; begin
102358: LD_INT 0
102360: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
102361: LD_ADDR_VAR 0 3
102365: PUSH
102366: LD_VAR 0 1
102370: PPUSH
102371: LD_INT 120
102373: PUSH
102374: LD_VAR 0 2
102378: PUSH
102379: EMPTY
102380: LIST
102381: LIST
102382: PPUSH
102383: CALL_OW 72
102387: ST_TO_ADDR
// end ;
102388: LD_VAR 0 3
102392: RET
// export function IsDriver ( un ) ; begin
102393: LD_INT 0
102395: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
102396: LD_ADDR_VAR 0 2
102400: PUSH
102401: LD_VAR 0 1
102405: PUSH
102406: LD_INT 55
102408: PUSH
102409: EMPTY
102410: LIST
102411: PPUSH
102412: CALL_OW 69
102416: IN
102417: ST_TO_ADDR
// end ;
102418: LD_VAR 0 2
102422: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
102423: LD_INT 0
102425: PPUSH
102426: PPUSH
// list := [ ] ;
102427: LD_ADDR_VAR 0 5
102431: PUSH
102432: EMPTY
102433: ST_TO_ADDR
// case d of 0 :
102434: LD_VAR 0 3
102438: PUSH
102439: LD_INT 0
102441: DOUBLE
102442: EQUAL
102443: IFTRUE 102447
102445: GO 102580
102447: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
102448: LD_ADDR_VAR 0 5
102452: PUSH
102453: LD_VAR 0 1
102457: PUSH
102458: LD_INT 4
102460: MINUS
102461: PUSH
102462: LD_VAR 0 2
102466: PUSH
102467: LD_INT 4
102469: MINUS
102470: PUSH
102471: LD_INT 2
102473: PUSH
102474: EMPTY
102475: LIST
102476: LIST
102477: LIST
102478: PUSH
102479: LD_VAR 0 1
102483: PUSH
102484: LD_INT 3
102486: MINUS
102487: PUSH
102488: LD_VAR 0 2
102492: PUSH
102493: LD_INT 1
102495: PUSH
102496: EMPTY
102497: LIST
102498: LIST
102499: LIST
102500: PUSH
102501: LD_VAR 0 1
102505: PUSH
102506: LD_INT 4
102508: PLUS
102509: PUSH
102510: LD_VAR 0 2
102514: PUSH
102515: LD_INT 4
102517: PUSH
102518: EMPTY
102519: LIST
102520: LIST
102521: LIST
102522: PUSH
102523: LD_VAR 0 1
102527: PUSH
102528: LD_INT 3
102530: PLUS
102531: PUSH
102532: LD_VAR 0 2
102536: PUSH
102537: LD_INT 3
102539: PLUS
102540: PUSH
102541: LD_INT 5
102543: PUSH
102544: EMPTY
102545: LIST
102546: LIST
102547: LIST
102548: PUSH
102549: LD_VAR 0 1
102553: PUSH
102554: LD_VAR 0 2
102558: PUSH
102559: LD_INT 4
102561: PLUS
102562: PUSH
102563: LD_INT 0
102565: PUSH
102566: EMPTY
102567: LIST
102568: LIST
102569: LIST
102570: PUSH
102571: EMPTY
102572: LIST
102573: LIST
102574: LIST
102575: LIST
102576: LIST
102577: ST_TO_ADDR
// end ; 1 :
102578: GO 103278
102580: LD_INT 1
102582: DOUBLE
102583: EQUAL
102584: IFTRUE 102588
102586: GO 102721
102588: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
102589: LD_ADDR_VAR 0 5
102593: PUSH
102594: LD_VAR 0 1
102598: PUSH
102599: LD_VAR 0 2
102603: PUSH
102604: LD_INT 4
102606: MINUS
102607: PUSH
102608: LD_INT 3
102610: PUSH
102611: EMPTY
102612: LIST
102613: LIST
102614: LIST
102615: PUSH
102616: LD_VAR 0 1
102620: PUSH
102621: LD_INT 3
102623: MINUS
102624: PUSH
102625: LD_VAR 0 2
102629: PUSH
102630: LD_INT 3
102632: MINUS
102633: PUSH
102634: LD_INT 2
102636: PUSH
102637: EMPTY
102638: LIST
102639: LIST
102640: LIST
102641: PUSH
102642: LD_VAR 0 1
102646: PUSH
102647: LD_INT 4
102649: MINUS
102650: PUSH
102651: LD_VAR 0 2
102655: PUSH
102656: LD_INT 1
102658: PUSH
102659: EMPTY
102660: LIST
102661: LIST
102662: LIST
102663: PUSH
102664: LD_VAR 0 1
102668: PUSH
102669: LD_VAR 0 2
102673: PUSH
102674: LD_INT 3
102676: PLUS
102677: PUSH
102678: LD_INT 0
102680: PUSH
102681: EMPTY
102682: LIST
102683: LIST
102684: LIST
102685: PUSH
102686: LD_VAR 0 1
102690: PUSH
102691: LD_INT 4
102693: PLUS
102694: PUSH
102695: LD_VAR 0 2
102699: PUSH
102700: LD_INT 4
102702: PLUS
102703: PUSH
102704: LD_INT 5
102706: PUSH
102707: EMPTY
102708: LIST
102709: LIST
102710: LIST
102711: PUSH
102712: EMPTY
102713: LIST
102714: LIST
102715: LIST
102716: LIST
102717: LIST
102718: ST_TO_ADDR
// end ; 2 :
102719: GO 103278
102721: LD_INT 2
102723: DOUBLE
102724: EQUAL
102725: IFTRUE 102729
102727: GO 102858
102729: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
102730: LD_ADDR_VAR 0 5
102734: PUSH
102735: LD_VAR 0 1
102739: PUSH
102740: LD_VAR 0 2
102744: PUSH
102745: LD_INT 3
102747: MINUS
102748: PUSH
102749: LD_INT 3
102751: PUSH
102752: EMPTY
102753: LIST
102754: LIST
102755: LIST
102756: PUSH
102757: LD_VAR 0 1
102761: PUSH
102762: LD_INT 4
102764: PLUS
102765: PUSH
102766: LD_VAR 0 2
102770: PUSH
102771: LD_INT 4
102773: PUSH
102774: EMPTY
102775: LIST
102776: LIST
102777: LIST
102778: PUSH
102779: LD_VAR 0 1
102783: PUSH
102784: LD_VAR 0 2
102788: PUSH
102789: LD_INT 4
102791: PLUS
102792: PUSH
102793: LD_INT 0
102795: PUSH
102796: EMPTY
102797: LIST
102798: LIST
102799: LIST
102800: PUSH
102801: LD_VAR 0 1
102805: PUSH
102806: LD_INT 3
102808: MINUS
102809: PUSH
102810: LD_VAR 0 2
102814: PUSH
102815: LD_INT 1
102817: PUSH
102818: EMPTY
102819: LIST
102820: LIST
102821: LIST
102822: PUSH
102823: LD_VAR 0 1
102827: PUSH
102828: LD_INT 4
102830: MINUS
102831: PUSH
102832: LD_VAR 0 2
102836: PUSH
102837: LD_INT 4
102839: MINUS
102840: PUSH
102841: LD_INT 2
102843: PUSH
102844: EMPTY
102845: LIST
102846: LIST
102847: LIST
102848: PUSH
102849: EMPTY
102850: LIST
102851: LIST
102852: LIST
102853: LIST
102854: LIST
102855: ST_TO_ADDR
// end ; 3 :
102856: GO 103278
102858: LD_INT 3
102860: DOUBLE
102861: EQUAL
102862: IFTRUE 102866
102864: GO 102999
102866: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
102867: LD_ADDR_VAR 0 5
102871: PUSH
102872: LD_VAR 0 1
102876: PUSH
102877: LD_INT 3
102879: PLUS
102880: PUSH
102881: LD_VAR 0 2
102885: PUSH
102886: LD_INT 4
102888: PUSH
102889: EMPTY
102890: LIST
102891: LIST
102892: LIST
102893: PUSH
102894: LD_VAR 0 1
102898: PUSH
102899: LD_INT 4
102901: PLUS
102902: PUSH
102903: LD_VAR 0 2
102907: PUSH
102908: LD_INT 4
102910: PLUS
102911: PUSH
102912: LD_INT 5
102914: PUSH
102915: EMPTY
102916: LIST
102917: LIST
102918: LIST
102919: PUSH
102920: LD_VAR 0 1
102924: PUSH
102925: LD_INT 4
102927: MINUS
102928: PUSH
102929: LD_VAR 0 2
102933: PUSH
102934: LD_INT 1
102936: PUSH
102937: EMPTY
102938: LIST
102939: LIST
102940: LIST
102941: PUSH
102942: LD_VAR 0 1
102946: PUSH
102947: LD_VAR 0 2
102951: PUSH
102952: LD_INT 4
102954: MINUS
102955: PUSH
102956: LD_INT 3
102958: PUSH
102959: EMPTY
102960: LIST
102961: LIST
102962: LIST
102963: PUSH
102964: LD_VAR 0 1
102968: PUSH
102969: LD_INT 3
102971: MINUS
102972: PUSH
102973: LD_VAR 0 2
102977: PUSH
102978: LD_INT 3
102980: MINUS
102981: PUSH
102982: LD_INT 2
102984: PUSH
102985: EMPTY
102986: LIST
102987: LIST
102988: LIST
102989: PUSH
102990: EMPTY
102991: LIST
102992: LIST
102993: LIST
102994: LIST
102995: LIST
102996: ST_TO_ADDR
// end ; 4 :
102997: GO 103278
102999: LD_INT 4
103001: DOUBLE
103002: EQUAL
103003: IFTRUE 103007
103005: GO 103140
103007: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
103008: LD_ADDR_VAR 0 5
103012: PUSH
103013: LD_VAR 0 1
103017: PUSH
103018: LD_VAR 0 2
103022: PUSH
103023: LD_INT 4
103025: PLUS
103026: PUSH
103027: LD_INT 0
103029: PUSH
103030: EMPTY
103031: LIST
103032: LIST
103033: LIST
103034: PUSH
103035: LD_VAR 0 1
103039: PUSH
103040: LD_INT 3
103042: PLUS
103043: PUSH
103044: LD_VAR 0 2
103048: PUSH
103049: LD_INT 3
103051: PLUS
103052: PUSH
103053: LD_INT 5
103055: PUSH
103056: EMPTY
103057: LIST
103058: LIST
103059: LIST
103060: PUSH
103061: LD_VAR 0 1
103065: PUSH
103066: LD_INT 4
103068: PLUS
103069: PUSH
103070: LD_VAR 0 2
103074: PUSH
103075: LD_INT 4
103077: PUSH
103078: EMPTY
103079: LIST
103080: LIST
103081: LIST
103082: PUSH
103083: LD_VAR 0 1
103087: PUSH
103088: LD_VAR 0 2
103092: PUSH
103093: LD_INT 3
103095: MINUS
103096: PUSH
103097: LD_INT 3
103099: PUSH
103100: EMPTY
103101: LIST
103102: LIST
103103: LIST
103104: PUSH
103105: LD_VAR 0 1
103109: PUSH
103110: LD_INT 4
103112: MINUS
103113: PUSH
103114: LD_VAR 0 2
103118: PUSH
103119: LD_INT 4
103121: MINUS
103122: PUSH
103123: LD_INT 2
103125: PUSH
103126: EMPTY
103127: LIST
103128: LIST
103129: LIST
103130: PUSH
103131: EMPTY
103132: LIST
103133: LIST
103134: LIST
103135: LIST
103136: LIST
103137: ST_TO_ADDR
// end ; 5 :
103138: GO 103278
103140: LD_INT 5
103142: DOUBLE
103143: EQUAL
103144: IFTRUE 103148
103146: GO 103277
103148: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
103149: LD_ADDR_VAR 0 5
103153: PUSH
103154: LD_VAR 0 1
103158: PUSH
103159: LD_INT 4
103161: MINUS
103162: PUSH
103163: LD_VAR 0 2
103167: PUSH
103168: LD_INT 1
103170: PUSH
103171: EMPTY
103172: LIST
103173: LIST
103174: LIST
103175: PUSH
103176: LD_VAR 0 1
103180: PUSH
103181: LD_VAR 0 2
103185: PUSH
103186: LD_INT 4
103188: MINUS
103189: PUSH
103190: LD_INT 3
103192: PUSH
103193: EMPTY
103194: LIST
103195: LIST
103196: LIST
103197: PUSH
103198: LD_VAR 0 1
103202: PUSH
103203: LD_INT 4
103205: PLUS
103206: PUSH
103207: LD_VAR 0 2
103211: PUSH
103212: LD_INT 4
103214: PLUS
103215: PUSH
103216: LD_INT 5
103218: PUSH
103219: EMPTY
103220: LIST
103221: LIST
103222: LIST
103223: PUSH
103224: LD_VAR 0 1
103228: PUSH
103229: LD_INT 3
103231: PLUS
103232: PUSH
103233: LD_VAR 0 2
103237: PUSH
103238: LD_INT 4
103240: PUSH
103241: EMPTY
103242: LIST
103243: LIST
103244: LIST
103245: PUSH
103246: LD_VAR 0 1
103250: PUSH
103251: LD_VAR 0 2
103255: PUSH
103256: LD_INT 3
103258: PLUS
103259: PUSH
103260: LD_INT 0
103262: PUSH
103263: EMPTY
103264: LIST
103265: LIST
103266: LIST
103267: PUSH
103268: EMPTY
103269: LIST
103270: LIST
103271: LIST
103272: LIST
103273: LIST
103274: ST_TO_ADDR
// end ; end ;
103275: GO 103278
103277: POP
// result := list ;
103278: LD_ADDR_VAR 0 4
103282: PUSH
103283: LD_VAR 0 5
103287: ST_TO_ADDR
// end ;
103288: LD_VAR 0 4
103292: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
103293: LD_INT 0
103295: PPUSH
103296: PPUSH
103297: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
103298: LD_VAR 0 1
103302: NOT
103303: PUSH
103304: LD_VAR 0 2
103308: PUSH
103309: LD_INT 1
103311: PUSH
103312: LD_INT 2
103314: PUSH
103315: LD_INT 3
103317: PUSH
103318: LD_INT 4
103320: PUSH
103321: EMPTY
103322: LIST
103323: LIST
103324: LIST
103325: LIST
103326: IN
103327: NOT
103328: OR
103329: IFFALSE 103333
// exit ;
103331: GO 103425
// tmp := [ ] ;
103333: LD_ADDR_VAR 0 5
103337: PUSH
103338: EMPTY
103339: ST_TO_ADDR
// for i in units do
103340: LD_ADDR_VAR 0 4
103344: PUSH
103345: LD_VAR 0 1
103349: PUSH
103350: FOR_IN
103351: IFFALSE 103394
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
103353: LD_ADDR_VAR 0 5
103357: PUSH
103358: LD_VAR 0 5
103362: PPUSH
103363: LD_VAR 0 5
103367: PUSH
103368: LD_INT 1
103370: PLUS
103371: PPUSH
103372: LD_VAR 0 4
103376: PPUSH
103377: LD_VAR 0 2
103381: PPUSH
103382: CALL_OW 259
103386: PPUSH
103387: CALL_OW 2
103391: ST_TO_ADDR
103392: GO 103350
103394: POP
103395: POP
// if not tmp then
103396: LD_VAR 0 5
103400: NOT
103401: IFFALSE 103405
// exit ;
103403: GO 103425
// result := SortListByListDesc ( units , tmp ) ;
103405: LD_ADDR_VAR 0 3
103409: PUSH
103410: LD_VAR 0 1
103414: PPUSH
103415: LD_VAR 0 5
103419: PPUSH
103420: CALL_OW 77
103424: ST_TO_ADDR
// end ;
103425: LD_VAR 0 3
103429: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
103430: LD_INT 0
103432: PPUSH
103433: PPUSH
103434: PPUSH
// result := false ;
103435: LD_ADDR_VAR 0 3
103439: PUSH
103440: LD_INT 0
103442: ST_TO_ADDR
// x := GetX ( building ) ;
103443: LD_ADDR_VAR 0 4
103447: PUSH
103448: LD_VAR 0 2
103452: PPUSH
103453: CALL_OW 250
103457: ST_TO_ADDR
// y := GetY ( building ) ;
103458: LD_ADDR_VAR 0 5
103462: PUSH
103463: LD_VAR 0 2
103467: PPUSH
103468: CALL_OW 251
103472: ST_TO_ADDR
// if not building or not x or not y then
103473: LD_VAR 0 2
103477: NOT
103478: PUSH
103479: LD_VAR 0 4
103483: NOT
103484: OR
103485: PUSH
103486: LD_VAR 0 5
103490: NOT
103491: OR
103492: IFFALSE 103496
// exit ;
103494: GO 103588
// if GetTaskList ( unit ) then
103496: LD_VAR 0 1
103500: PPUSH
103501: CALL_OW 437
103505: IFFALSE 103588
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
103507: LD_STRING e
103509: PUSH
103510: LD_VAR 0 1
103514: PPUSH
103515: CALL_OW 437
103519: PUSH
103520: LD_INT 1
103522: ARRAY
103523: PUSH
103524: LD_INT 1
103526: ARRAY
103527: EQUAL
103528: PUSH
103529: LD_VAR 0 4
103533: PUSH
103534: LD_VAR 0 1
103538: PPUSH
103539: CALL_OW 437
103543: PUSH
103544: LD_INT 1
103546: ARRAY
103547: PUSH
103548: LD_INT 2
103550: ARRAY
103551: EQUAL
103552: AND
103553: PUSH
103554: LD_VAR 0 5
103558: PUSH
103559: LD_VAR 0 1
103563: PPUSH
103564: CALL_OW 437
103568: PUSH
103569: LD_INT 1
103571: ARRAY
103572: PUSH
103573: LD_INT 3
103575: ARRAY
103576: EQUAL
103577: AND
103578: IFFALSE 103588
// result := true end ;
103580: LD_ADDR_VAR 0 3
103584: PUSH
103585: LD_INT 1
103587: ST_TO_ADDR
// end ;
103588: LD_VAR 0 3
103592: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
103593: LD_INT 0
103595: PPUSH
// result := false ;
103596: LD_ADDR_VAR 0 4
103600: PUSH
103601: LD_INT 0
103603: ST_TO_ADDR
// if GetTaskList ( unit ) then
103604: LD_VAR 0 1
103608: PPUSH
103609: CALL_OW 437
103613: IFFALSE 103696
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
103615: LD_STRING M
103617: PUSH
103618: LD_VAR 0 1
103622: PPUSH
103623: CALL_OW 437
103627: PUSH
103628: LD_INT 1
103630: ARRAY
103631: PUSH
103632: LD_INT 1
103634: ARRAY
103635: EQUAL
103636: PUSH
103637: LD_VAR 0 2
103641: PUSH
103642: LD_VAR 0 1
103646: PPUSH
103647: CALL_OW 437
103651: PUSH
103652: LD_INT 1
103654: ARRAY
103655: PUSH
103656: LD_INT 2
103658: ARRAY
103659: EQUAL
103660: AND
103661: PUSH
103662: LD_VAR 0 3
103666: PUSH
103667: LD_VAR 0 1
103671: PPUSH
103672: CALL_OW 437
103676: PUSH
103677: LD_INT 1
103679: ARRAY
103680: PUSH
103681: LD_INT 3
103683: ARRAY
103684: EQUAL
103685: AND
103686: IFFALSE 103696
// result := true ;
103688: LD_ADDR_VAR 0 4
103692: PUSH
103693: LD_INT 1
103695: ST_TO_ADDR
// end ; end ;
103696: LD_VAR 0 4
103700: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
103701: LD_INT 0
103703: PPUSH
103704: PPUSH
103705: PPUSH
103706: PPUSH
// if not unit or not area then
103707: LD_VAR 0 1
103711: NOT
103712: PUSH
103713: LD_VAR 0 2
103717: NOT
103718: OR
103719: IFFALSE 103723
// exit ;
103721: GO 103887
// tmp := AreaToList ( area , i ) ;
103723: LD_ADDR_VAR 0 6
103727: PUSH
103728: LD_VAR 0 2
103732: PPUSH
103733: LD_VAR 0 5
103737: PPUSH
103738: CALL_OW 517
103742: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
103743: LD_ADDR_VAR 0 5
103747: PUSH
103748: DOUBLE
103749: LD_INT 1
103751: DEC
103752: ST_TO_ADDR
103753: LD_VAR 0 6
103757: PUSH
103758: LD_INT 1
103760: ARRAY
103761: PUSH
103762: FOR_TO
103763: IFFALSE 103885
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
103765: LD_ADDR_VAR 0 7
103769: PUSH
103770: LD_VAR 0 6
103774: PUSH
103775: LD_INT 1
103777: ARRAY
103778: PUSH
103779: LD_VAR 0 5
103783: ARRAY
103784: PUSH
103785: LD_VAR 0 6
103789: PUSH
103790: LD_INT 2
103792: ARRAY
103793: PUSH
103794: LD_VAR 0 5
103798: ARRAY
103799: PUSH
103800: EMPTY
103801: LIST
103802: LIST
103803: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
103804: LD_VAR 0 7
103808: PUSH
103809: LD_INT 1
103811: ARRAY
103812: PPUSH
103813: LD_VAR 0 7
103817: PUSH
103818: LD_INT 2
103820: ARRAY
103821: PPUSH
103822: CALL_OW 428
103826: PUSH
103827: LD_INT 0
103829: EQUAL
103830: IFFALSE 103883
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
103832: LD_VAR 0 1
103836: PPUSH
103837: LD_VAR 0 7
103841: PUSH
103842: LD_INT 1
103844: ARRAY
103845: PPUSH
103846: LD_VAR 0 7
103850: PUSH
103851: LD_INT 2
103853: ARRAY
103854: PPUSH
103855: LD_VAR 0 3
103859: PPUSH
103860: CALL_OW 48
// result := IsPlaced ( unit ) ;
103864: LD_ADDR_VAR 0 4
103868: PUSH
103869: LD_VAR 0 1
103873: PPUSH
103874: CALL_OW 305
103878: ST_TO_ADDR
// exit ;
103879: POP
103880: POP
103881: GO 103887
// end ; end ;
103883: GO 103762
103885: POP
103886: POP
// end ;
103887: LD_VAR 0 4
103891: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
103892: LD_INT 0
103894: PPUSH
103895: PPUSH
103896: PPUSH
// if not side or side > 8 then
103897: LD_VAR 0 1
103901: NOT
103902: PUSH
103903: LD_VAR 0 1
103907: PUSH
103908: LD_INT 8
103910: GREATER
103911: OR
103912: IFFALSE 103916
// exit ;
103914: GO 104103
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
103916: LD_ADDR_VAR 0 4
103920: PUSH
103921: LD_INT 22
103923: PUSH
103924: LD_VAR 0 1
103928: PUSH
103929: EMPTY
103930: LIST
103931: LIST
103932: PUSH
103933: LD_INT 21
103935: PUSH
103936: LD_INT 3
103938: PUSH
103939: EMPTY
103940: LIST
103941: LIST
103942: PUSH
103943: EMPTY
103944: LIST
103945: LIST
103946: PPUSH
103947: CALL_OW 69
103951: ST_TO_ADDR
// if not tmp then
103952: LD_VAR 0 4
103956: NOT
103957: IFFALSE 103961
// exit ;
103959: GO 104103
// enable_addtolog := true ;
103961: LD_ADDR_OWVAR 81
103965: PUSH
103966: LD_INT 1
103968: ST_TO_ADDR
// AddToLog ( [ ) ;
103969: LD_STRING [
103971: PPUSH
103972: CALL_OW 561
// for i in tmp do
103976: LD_ADDR_VAR 0 3
103980: PUSH
103981: LD_VAR 0 4
103985: PUSH
103986: FOR_IN
103987: IFFALSE 104094
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
103989: LD_STRING [
103991: PUSH
103992: LD_VAR 0 3
103996: PPUSH
103997: CALL_OW 266
104001: STR
104002: PUSH
104003: LD_STRING , 
104005: STR
104006: PUSH
104007: LD_VAR 0 3
104011: PPUSH
104012: CALL_OW 250
104016: STR
104017: PUSH
104018: LD_STRING , 
104020: STR
104021: PUSH
104022: LD_VAR 0 3
104026: PPUSH
104027: CALL_OW 251
104031: STR
104032: PUSH
104033: LD_STRING , 
104035: STR
104036: PUSH
104037: LD_VAR 0 3
104041: PPUSH
104042: CALL_OW 254
104046: STR
104047: PUSH
104048: LD_STRING , 
104050: STR
104051: PUSH
104052: LD_VAR 0 3
104056: PPUSH
104057: LD_INT 1
104059: PPUSH
104060: CALL_OW 268
104064: STR
104065: PUSH
104066: LD_STRING , 
104068: STR
104069: PUSH
104070: LD_VAR 0 3
104074: PPUSH
104075: LD_INT 2
104077: PPUSH
104078: CALL_OW 268
104082: STR
104083: PUSH
104084: LD_STRING ],
104086: STR
104087: PPUSH
104088: CALL_OW 561
// end ;
104092: GO 103986
104094: POP
104095: POP
// AddToLog ( ]; ) ;
104096: LD_STRING ];
104098: PPUSH
104099: CALL_OW 561
// end ;
104103: LD_VAR 0 2
104107: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
104108: LD_INT 0
104110: PPUSH
104111: PPUSH
104112: PPUSH
104113: PPUSH
104114: PPUSH
// if not area or not rate or not max then
104115: LD_VAR 0 1
104119: NOT
104120: PUSH
104121: LD_VAR 0 2
104125: NOT
104126: OR
104127: PUSH
104128: LD_VAR 0 4
104132: NOT
104133: OR
104134: IFFALSE 104138
// exit ;
104136: GO 104327
// while 1 do
104138: LD_INT 1
104140: IFFALSE 104327
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
104142: LD_ADDR_VAR 0 9
104146: PUSH
104147: LD_VAR 0 1
104151: PPUSH
104152: LD_INT 1
104154: PPUSH
104155: CALL_OW 287
104159: PUSH
104160: LD_INT 10
104162: MUL
104163: ST_TO_ADDR
// r := rate / 10 ;
104164: LD_ADDR_VAR 0 7
104168: PUSH
104169: LD_VAR 0 2
104173: PUSH
104174: LD_INT 10
104176: DIVREAL
104177: ST_TO_ADDR
// time := 1 1$00 ;
104178: LD_ADDR_VAR 0 8
104182: PUSH
104183: LD_INT 2100
104185: ST_TO_ADDR
// if amount < min then
104186: LD_VAR 0 9
104190: PUSH
104191: LD_VAR 0 3
104195: LESS
104196: IFFALSE 104214
// r := r * 2 else
104198: LD_ADDR_VAR 0 7
104202: PUSH
104203: LD_VAR 0 7
104207: PUSH
104208: LD_INT 2
104210: MUL
104211: ST_TO_ADDR
104212: GO 104240
// if amount > max then
104214: LD_VAR 0 9
104218: PUSH
104219: LD_VAR 0 4
104223: GREATER
104224: IFFALSE 104240
// r := r / 2 ;
104226: LD_ADDR_VAR 0 7
104230: PUSH
104231: LD_VAR 0 7
104235: PUSH
104236: LD_INT 2
104238: DIVREAL
104239: ST_TO_ADDR
// time := time / r ;
104240: LD_ADDR_VAR 0 8
104244: PUSH
104245: LD_VAR 0 8
104249: PUSH
104250: LD_VAR 0 7
104254: DIVREAL
104255: ST_TO_ADDR
// if time < 0 then
104256: LD_VAR 0 8
104260: PUSH
104261: LD_INT 0
104263: LESS
104264: IFFALSE 104281
// time := time * - 1 ;
104266: LD_ADDR_VAR 0 8
104270: PUSH
104271: LD_VAR 0 8
104275: PUSH
104276: LD_INT 1
104278: NEG
104279: MUL
104280: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
104281: LD_VAR 0 8
104285: PUSH
104286: LD_INT 35
104288: PPUSH
104289: LD_INT 875
104291: PPUSH
104292: CALL_OW 12
104296: PLUS
104297: PPUSH
104298: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
104302: LD_INT 1
104304: PPUSH
104305: LD_INT 5
104307: PPUSH
104308: CALL_OW 12
104312: PPUSH
104313: LD_VAR 0 1
104317: PPUSH
104318: LD_INT 1
104320: PPUSH
104321: CALL_OW 55
// end ;
104325: GO 104138
// end ;
104327: LD_VAR 0 5
104331: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
104332: LD_INT 0
104334: PPUSH
104335: PPUSH
104336: PPUSH
104337: PPUSH
104338: PPUSH
104339: PPUSH
104340: PPUSH
104341: PPUSH
// if not turrets or not factories then
104342: LD_VAR 0 1
104346: NOT
104347: PUSH
104348: LD_VAR 0 2
104352: NOT
104353: OR
104354: IFFALSE 104358
// exit ;
104356: GO 104665
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
104358: LD_ADDR_VAR 0 10
104362: PUSH
104363: LD_INT 5
104365: PUSH
104366: LD_INT 6
104368: PUSH
104369: EMPTY
104370: LIST
104371: LIST
104372: PUSH
104373: LD_INT 2
104375: PUSH
104376: LD_INT 4
104378: PUSH
104379: EMPTY
104380: LIST
104381: LIST
104382: PUSH
104383: LD_INT 3
104385: PUSH
104386: LD_INT 5
104388: PUSH
104389: EMPTY
104390: LIST
104391: LIST
104392: PUSH
104393: EMPTY
104394: LIST
104395: LIST
104396: LIST
104397: PUSH
104398: LD_INT 24
104400: PUSH
104401: LD_INT 25
104403: PUSH
104404: EMPTY
104405: LIST
104406: LIST
104407: PUSH
104408: LD_INT 23
104410: PUSH
104411: LD_INT 27
104413: PUSH
104414: EMPTY
104415: LIST
104416: LIST
104417: PUSH
104418: EMPTY
104419: LIST
104420: LIST
104421: PUSH
104422: LD_INT 42
104424: PUSH
104425: LD_INT 43
104427: PUSH
104428: EMPTY
104429: LIST
104430: LIST
104431: PUSH
104432: LD_INT 44
104434: PUSH
104435: LD_INT 46
104437: PUSH
104438: EMPTY
104439: LIST
104440: LIST
104441: PUSH
104442: LD_INT 45
104444: PUSH
104445: LD_INT 47
104447: PUSH
104448: EMPTY
104449: LIST
104450: LIST
104451: PUSH
104452: EMPTY
104453: LIST
104454: LIST
104455: LIST
104456: PUSH
104457: EMPTY
104458: LIST
104459: LIST
104460: LIST
104461: ST_TO_ADDR
// result := [ ] ;
104462: LD_ADDR_VAR 0 3
104466: PUSH
104467: EMPTY
104468: ST_TO_ADDR
// for i in turrets do
104469: LD_ADDR_VAR 0 4
104473: PUSH
104474: LD_VAR 0 1
104478: PUSH
104479: FOR_IN
104480: IFFALSE 104663
// begin nat := GetNation ( i ) ;
104482: LD_ADDR_VAR 0 7
104486: PUSH
104487: LD_VAR 0 4
104491: PPUSH
104492: CALL_OW 248
104496: ST_TO_ADDR
// weapon := 0 ;
104497: LD_ADDR_VAR 0 8
104501: PUSH
104502: LD_INT 0
104504: ST_TO_ADDR
// if not nat then
104505: LD_VAR 0 7
104509: NOT
104510: IFFALSE 104514
// continue ;
104512: GO 104479
// for j in list [ nat ] do
104514: LD_ADDR_VAR 0 5
104518: PUSH
104519: LD_VAR 0 10
104523: PUSH
104524: LD_VAR 0 7
104528: ARRAY
104529: PUSH
104530: FOR_IN
104531: IFFALSE 104572
// if GetBWeapon ( i ) = j [ 1 ] then
104533: LD_VAR 0 4
104537: PPUSH
104538: CALL_OW 269
104542: PUSH
104543: LD_VAR 0 5
104547: PUSH
104548: LD_INT 1
104550: ARRAY
104551: EQUAL
104552: IFFALSE 104570
// begin weapon := j [ 2 ] ;
104554: LD_ADDR_VAR 0 8
104558: PUSH
104559: LD_VAR 0 5
104563: PUSH
104564: LD_INT 2
104566: ARRAY
104567: ST_TO_ADDR
// break ;
104568: GO 104572
// end ;
104570: GO 104530
104572: POP
104573: POP
// if not weapon then
104574: LD_VAR 0 8
104578: NOT
104579: IFFALSE 104583
// continue ;
104581: GO 104479
// for k in factories do
104583: LD_ADDR_VAR 0 6
104587: PUSH
104588: LD_VAR 0 2
104592: PUSH
104593: FOR_IN
104594: IFFALSE 104659
// begin weapons := AvailableWeaponList ( k ) ;
104596: LD_ADDR_VAR 0 9
104600: PUSH
104601: LD_VAR 0 6
104605: PPUSH
104606: CALL_OW 478
104610: ST_TO_ADDR
// if not weapons then
104611: LD_VAR 0 9
104615: NOT
104616: IFFALSE 104620
// continue ;
104618: GO 104593
// if weapon in weapons then
104620: LD_VAR 0 8
104624: PUSH
104625: LD_VAR 0 9
104629: IN
104630: IFFALSE 104657
// begin result := [ i , weapon ] ;
104632: LD_ADDR_VAR 0 3
104636: PUSH
104637: LD_VAR 0 4
104641: PUSH
104642: LD_VAR 0 8
104646: PUSH
104647: EMPTY
104648: LIST
104649: LIST
104650: ST_TO_ADDR
// exit ;
104651: POP
104652: POP
104653: POP
104654: POP
104655: GO 104665
// end ; end ;
104657: GO 104593
104659: POP
104660: POP
// end ;
104661: GO 104479
104663: POP
104664: POP
// end ;
104665: LD_VAR 0 3
104669: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
104670: LD_INT 0
104672: PPUSH
// if not side or side > 8 then
104673: LD_VAR 0 3
104677: NOT
104678: PUSH
104679: LD_VAR 0 3
104683: PUSH
104684: LD_INT 8
104686: GREATER
104687: OR
104688: IFFALSE 104692
// exit ;
104690: GO 104751
// if not range then
104692: LD_VAR 0 4
104696: NOT
104697: IFFALSE 104708
// range := - 12 ;
104699: LD_ADDR_VAR 0 4
104703: PUSH
104704: LD_INT 12
104706: NEG
104707: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
104708: LD_VAR 0 1
104712: PPUSH
104713: LD_VAR 0 2
104717: PPUSH
104718: LD_VAR 0 3
104722: PPUSH
104723: LD_VAR 0 4
104727: PPUSH
104728: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
104732: LD_VAR 0 1
104736: PPUSH
104737: LD_VAR 0 2
104741: PPUSH
104742: LD_VAR 0 3
104746: PPUSH
104747: CALL_OW 331
// end ;
104751: LD_VAR 0 5
104755: RET
// export function Video ( mode ) ; begin
104756: LD_INT 0
104758: PPUSH
// ingame_video = mode ;
104759: LD_ADDR_OWVAR 52
104763: PUSH
104764: LD_VAR 0 1
104768: ST_TO_ADDR
// interface_hidden = mode ;
104769: LD_ADDR_OWVAR 54
104773: PUSH
104774: LD_VAR 0 1
104778: ST_TO_ADDR
// end ;
104779: LD_VAR 0 2
104783: RET
// export function Join ( array , element ) ; begin
104784: LD_INT 0
104786: PPUSH
// result := Replace ( array , array + 1 , element ) ;
104787: LD_ADDR_VAR 0 3
104791: PUSH
104792: LD_VAR 0 1
104796: PPUSH
104797: LD_VAR 0 1
104801: PUSH
104802: LD_INT 1
104804: PLUS
104805: PPUSH
104806: LD_VAR 0 2
104810: PPUSH
104811: CALL_OW 1
104815: ST_TO_ADDR
// end ;
104816: LD_VAR 0 3
104820: RET
// export function JoinUnion ( array , element ) ; begin
104821: LD_INT 0
104823: PPUSH
// result := array union element ;
104824: LD_ADDR_VAR 0 3
104828: PUSH
104829: LD_VAR 0 1
104833: PUSH
104834: LD_VAR 0 2
104838: UNION
104839: ST_TO_ADDR
// end ;
104840: LD_VAR 0 3
104844: RET
// export function GetBehemoths ( side ) ; begin
104845: LD_INT 0
104847: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
104848: LD_ADDR_VAR 0 2
104852: PUSH
104853: LD_INT 22
104855: PUSH
104856: LD_VAR 0 1
104860: PUSH
104861: EMPTY
104862: LIST
104863: LIST
104864: PUSH
104865: LD_INT 31
104867: PUSH
104868: LD_INT 25
104870: PUSH
104871: EMPTY
104872: LIST
104873: LIST
104874: PUSH
104875: EMPTY
104876: LIST
104877: LIST
104878: PPUSH
104879: CALL_OW 69
104883: ST_TO_ADDR
// end ;
104884: LD_VAR 0 2
104888: RET
// export function Shuffle ( array ) ; var i , index ; begin
104889: LD_INT 0
104891: PPUSH
104892: PPUSH
104893: PPUSH
// result := [ ] ;
104894: LD_ADDR_VAR 0 2
104898: PUSH
104899: EMPTY
104900: ST_TO_ADDR
// if not array then
104901: LD_VAR 0 1
104905: NOT
104906: IFFALSE 104910
// exit ;
104908: GO 105009
// Randomize ;
104910: CALL_OW 10
// for i = array downto 1 do
104914: LD_ADDR_VAR 0 3
104918: PUSH
104919: DOUBLE
104920: LD_VAR 0 1
104924: INC
104925: ST_TO_ADDR
104926: LD_INT 1
104928: PUSH
104929: FOR_DOWNTO
104930: IFFALSE 105007
// begin index := rand ( 1 , array ) ;
104932: LD_ADDR_VAR 0 4
104936: PUSH
104937: LD_INT 1
104939: PPUSH
104940: LD_VAR 0 1
104944: PPUSH
104945: CALL_OW 12
104949: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
104950: LD_ADDR_VAR 0 2
104954: PUSH
104955: LD_VAR 0 2
104959: PPUSH
104960: LD_VAR 0 2
104964: PUSH
104965: LD_INT 1
104967: PLUS
104968: PPUSH
104969: LD_VAR 0 1
104973: PUSH
104974: LD_VAR 0 4
104978: ARRAY
104979: PPUSH
104980: CALL_OW 2
104984: ST_TO_ADDR
// array := Delete ( array , index ) ;
104985: LD_ADDR_VAR 0 1
104989: PUSH
104990: LD_VAR 0 1
104994: PPUSH
104995: LD_VAR 0 4
104999: PPUSH
105000: CALL_OW 3
105004: ST_TO_ADDR
// end ;
105005: GO 104929
105007: POP
105008: POP
// end ;
105009: LD_VAR 0 2
105013: RET
// export function GetBaseMaterials ( base ) ; begin
105014: LD_INT 0
105016: PPUSH
// result := [ 0 , 0 , 0 ] ;
105017: LD_ADDR_VAR 0 2
105021: PUSH
105022: LD_INT 0
105024: PUSH
105025: LD_INT 0
105027: PUSH
105028: LD_INT 0
105030: PUSH
105031: EMPTY
105032: LIST
105033: LIST
105034: LIST
105035: ST_TO_ADDR
// if not base then
105036: LD_VAR 0 1
105040: NOT
105041: IFFALSE 105045
// exit ;
105043: GO 105094
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
105045: LD_ADDR_VAR 0 2
105049: PUSH
105050: LD_VAR 0 1
105054: PPUSH
105055: LD_INT 1
105057: PPUSH
105058: CALL_OW 275
105062: PUSH
105063: LD_VAR 0 1
105067: PPUSH
105068: LD_INT 2
105070: PPUSH
105071: CALL_OW 275
105075: PUSH
105076: LD_VAR 0 1
105080: PPUSH
105081: LD_INT 3
105083: PPUSH
105084: CALL_OW 275
105088: PUSH
105089: EMPTY
105090: LIST
105091: LIST
105092: LIST
105093: ST_TO_ADDR
// end ;
105094: LD_VAR 0 2
105098: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
105099: LD_INT 0
105101: PPUSH
105102: PPUSH
// result := array ;
105103: LD_ADDR_VAR 0 3
105107: PUSH
105108: LD_VAR 0 1
105112: ST_TO_ADDR
// if size >= result then
105113: LD_VAR 0 2
105117: PUSH
105118: LD_VAR 0 3
105122: GREATEREQUAL
105123: IFFALSE 105127
// exit ;
105125: GO 105177
// if size then
105127: LD_VAR 0 2
105131: IFFALSE 105177
// for i := array downto size do
105133: LD_ADDR_VAR 0 4
105137: PUSH
105138: DOUBLE
105139: LD_VAR 0 1
105143: INC
105144: ST_TO_ADDR
105145: LD_VAR 0 2
105149: PUSH
105150: FOR_DOWNTO
105151: IFFALSE 105175
// result := Delete ( result , result ) ;
105153: LD_ADDR_VAR 0 3
105157: PUSH
105158: LD_VAR 0 3
105162: PPUSH
105163: LD_VAR 0 3
105167: PPUSH
105168: CALL_OW 3
105172: ST_TO_ADDR
105173: GO 105150
105175: POP
105176: POP
// end ;
105177: LD_VAR 0 3
105181: RET
// export function ComExit ( unit ) ; var tmp ; begin
105182: LD_INT 0
105184: PPUSH
105185: PPUSH
// if not IsInUnit ( unit ) then
105186: LD_VAR 0 1
105190: PPUSH
105191: CALL_OW 310
105195: NOT
105196: IFFALSE 105200
// exit ;
105198: GO 105260
// tmp := IsInUnit ( unit ) ;
105200: LD_ADDR_VAR 0 3
105204: PUSH
105205: LD_VAR 0 1
105209: PPUSH
105210: CALL_OW 310
105214: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
105215: LD_VAR 0 3
105219: PPUSH
105220: CALL_OW 247
105224: PUSH
105225: LD_INT 2
105227: EQUAL
105228: IFFALSE 105241
// ComExitVehicle ( unit ) else
105230: LD_VAR 0 1
105234: PPUSH
105235: CALL_OW 121
105239: GO 105250
// ComExitBuilding ( unit ) ;
105241: LD_VAR 0 1
105245: PPUSH
105246: CALL_OW 122
// result := tmp ;
105250: LD_ADDR_VAR 0 2
105254: PUSH
105255: LD_VAR 0 3
105259: ST_TO_ADDR
// end ;
105260: LD_VAR 0 2
105264: RET
// export function ComExitAll ( units ) ; var i ; begin
105265: LD_INT 0
105267: PPUSH
105268: PPUSH
// if not units then
105269: LD_VAR 0 1
105273: NOT
105274: IFFALSE 105278
// exit ;
105276: GO 105304
// for i in units do
105278: LD_ADDR_VAR 0 3
105282: PUSH
105283: LD_VAR 0 1
105287: PUSH
105288: FOR_IN
105289: IFFALSE 105302
// ComExit ( i ) ;
105291: LD_VAR 0 3
105295: PPUSH
105296: CALL 105182 0 1
105300: GO 105288
105302: POP
105303: POP
// end ;
105304: LD_VAR 0 2
105308: RET
// export function ResetHc ; begin
105309: LD_INT 0
105311: PPUSH
// InitHc ;
105312: CALL_OW 19
// hc_importance := 0 ;
105316: LD_ADDR_OWVAR 32
105320: PUSH
105321: LD_INT 0
105323: ST_TO_ADDR
// end ;
105324: LD_VAR 0 1
105328: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
105329: LD_INT 0
105331: PPUSH
105332: PPUSH
105333: PPUSH
// _x := ( x1 + x2 ) div 2 ;
105334: LD_ADDR_VAR 0 6
105338: PUSH
105339: LD_VAR 0 1
105343: PUSH
105344: LD_VAR 0 3
105348: PLUS
105349: PUSH
105350: LD_INT 2
105352: DIV
105353: ST_TO_ADDR
// if _x < 0 then
105354: LD_VAR 0 6
105358: PUSH
105359: LD_INT 0
105361: LESS
105362: IFFALSE 105379
// _x := _x * - 1 ;
105364: LD_ADDR_VAR 0 6
105368: PUSH
105369: LD_VAR 0 6
105373: PUSH
105374: LD_INT 1
105376: NEG
105377: MUL
105378: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
105379: LD_ADDR_VAR 0 7
105383: PUSH
105384: LD_VAR 0 2
105388: PUSH
105389: LD_VAR 0 4
105393: PLUS
105394: PUSH
105395: LD_INT 2
105397: DIV
105398: ST_TO_ADDR
// if _y < 0 then
105399: LD_VAR 0 7
105403: PUSH
105404: LD_INT 0
105406: LESS
105407: IFFALSE 105424
// _y := _y * - 1 ;
105409: LD_ADDR_VAR 0 7
105413: PUSH
105414: LD_VAR 0 7
105418: PUSH
105419: LD_INT 1
105421: NEG
105422: MUL
105423: ST_TO_ADDR
// result := [ _x , _y ] ;
105424: LD_ADDR_VAR 0 5
105428: PUSH
105429: LD_VAR 0 6
105433: PUSH
105434: LD_VAR 0 7
105438: PUSH
105439: EMPTY
105440: LIST
105441: LIST
105442: ST_TO_ADDR
// end ;
105443: LD_VAR 0 5
105447: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
105448: LD_INT 0
105450: PPUSH
105451: PPUSH
105452: PPUSH
105453: PPUSH
// task := GetTaskList ( unit ) ;
105454: LD_ADDR_VAR 0 7
105458: PUSH
105459: LD_VAR 0 1
105463: PPUSH
105464: CALL_OW 437
105468: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
105469: LD_VAR 0 7
105473: NOT
105474: PUSH
105475: LD_VAR 0 1
105479: PPUSH
105480: LD_VAR 0 2
105484: PPUSH
105485: CALL_OW 308
105489: NOT
105490: AND
105491: IFFALSE 105495
// exit ;
105493: GO 105613
// if IsInArea ( unit , area ) then
105495: LD_VAR 0 1
105499: PPUSH
105500: LD_VAR 0 2
105504: PPUSH
105505: CALL_OW 308
105509: IFFALSE 105527
// begin ComMoveToArea ( unit , goAway ) ;
105511: LD_VAR 0 1
105515: PPUSH
105516: LD_VAR 0 3
105520: PPUSH
105521: CALL_OW 113
// exit ;
105525: GO 105613
// end ; if task [ 1 ] [ 1 ] <> M then
105527: LD_VAR 0 7
105531: PUSH
105532: LD_INT 1
105534: ARRAY
105535: PUSH
105536: LD_INT 1
105538: ARRAY
105539: PUSH
105540: LD_STRING M
105542: NONEQUAL
105543: IFFALSE 105547
// exit ;
105545: GO 105613
// x := task [ 1 ] [ 2 ] ;
105547: LD_ADDR_VAR 0 5
105551: PUSH
105552: LD_VAR 0 7
105556: PUSH
105557: LD_INT 1
105559: ARRAY
105560: PUSH
105561: LD_INT 2
105563: ARRAY
105564: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
105565: LD_ADDR_VAR 0 6
105569: PUSH
105570: LD_VAR 0 7
105574: PUSH
105575: LD_INT 1
105577: ARRAY
105578: PUSH
105579: LD_INT 3
105581: ARRAY
105582: ST_TO_ADDR
// if InArea ( x , y , area ) then
105583: LD_VAR 0 5
105587: PPUSH
105588: LD_VAR 0 6
105592: PPUSH
105593: LD_VAR 0 2
105597: PPUSH
105598: CALL_OW 309
105602: IFFALSE 105613
// ComStop ( unit ) ;
105604: LD_VAR 0 1
105608: PPUSH
105609: CALL_OW 141
// end ;
105613: LD_VAR 0 4
105617: RET
// export function Abs ( value ) ; begin
105618: LD_INT 0
105620: PPUSH
// result := value ;
105621: LD_ADDR_VAR 0 2
105625: PUSH
105626: LD_VAR 0 1
105630: ST_TO_ADDR
// if value < 0 then
105631: LD_VAR 0 1
105635: PUSH
105636: LD_INT 0
105638: LESS
105639: IFFALSE 105656
// result := value * - 1 ;
105641: LD_ADDR_VAR 0 2
105645: PUSH
105646: LD_VAR 0 1
105650: PUSH
105651: LD_INT 1
105653: NEG
105654: MUL
105655: ST_TO_ADDR
// end ;
105656: LD_VAR 0 2
105660: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
105661: LD_INT 0
105663: PPUSH
105664: PPUSH
105665: PPUSH
105666: PPUSH
105667: PPUSH
105668: PPUSH
105669: PPUSH
105670: PPUSH
// if not unit or not building then
105671: LD_VAR 0 1
105675: NOT
105676: PUSH
105677: LD_VAR 0 2
105681: NOT
105682: OR
105683: IFFALSE 105687
// exit ;
105685: GO 105913
// x := GetX ( building ) ;
105687: LD_ADDR_VAR 0 4
105691: PUSH
105692: LD_VAR 0 2
105696: PPUSH
105697: CALL_OW 250
105701: ST_TO_ADDR
// y := GetY ( building ) ;
105702: LD_ADDR_VAR 0 6
105706: PUSH
105707: LD_VAR 0 2
105711: PPUSH
105712: CALL_OW 251
105716: ST_TO_ADDR
// d := GetDir ( building ) ;
105717: LD_ADDR_VAR 0 8
105721: PUSH
105722: LD_VAR 0 2
105726: PPUSH
105727: CALL_OW 254
105731: ST_TO_ADDR
// r := 4 ;
105732: LD_ADDR_VAR 0 9
105736: PUSH
105737: LD_INT 4
105739: ST_TO_ADDR
// for i := 1 to 5 do
105740: LD_ADDR_VAR 0 10
105744: PUSH
105745: DOUBLE
105746: LD_INT 1
105748: DEC
105749: ST_TO_ADDR
105750: LD_INT 5
105752: PUSH
105753: FOR_TO
105754: IFFALSE 105911
// begin _x := ShiftX ( x , d , r + i ) ;
105756: LD_ADDR_VAR 0 5
105760: PUSH
105761: LD_VAR 0 4
105765: PPUSH
105766: LD_VAR 0 8
105770: PPUSH
105771: LD_VAR 0 9
105775: PUSH
105776: LD_VAR 0 10
105780: PLUS
105781: PPUSH
105782: CALL_OW 272
105786: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
105787: LD_ADDR_VAR 0 7
105791: PUSH
105792: LD_VAR 0 6
105796: PPUSH
105797: LD_VAR 0 8
105801: PPUSH
105802: LD_VAR 0 9
105806: PUSH
105807: LD_VAR 0 10
105811: PLUS
105812: PPUSH
105813: CALL_OW 273
105817: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
105818: LD_VAR 0 5
105822: PPUSH
105823: LD_VAR 0 7
105827: PPUSH
105828: CALL_OW 488
105832: PUSH
105833: LD_VAR 0 5
105837: PPUSH
105838: LD_VAR 0 7
105842: PPUSH
105843: CALL_OW 428
105847: PPUSH
105848: CALL_OW 247
105852: PUSH
105853: LD_INT 3
105855: PUSH
105856: LD_INT 2
105858: PUSH
105859: EMPTY
105860: LIST
105861: LIST
105862: IN
105863: NOT
105864: AND
105865: IFFALSE 105909
// begin ComMoveXY ( unit , _x , _y ) ;
105867: LD_VAR 0 1
105871: PPUSH
105872: LD_VAR 0 5
105876: PPUSH
105877: LD_VAR 0 7
105881: PPUSH
105882: CALL_OW 111
// result := [ _x , _y ] ;
105886: LD_ADDR_VAR 0 3
105890: PUSH
105891: LD_VAR 0 5
105895: PUSH
105896: LD_VAR 0 7
105900: PUSH
105901: EMPTY
105902: LIST
105903: LIST
105904: ST_TO_ADDR
// exit ;
105905: POP
105906: POP
105907: GO 105913
// end ; end ;
105909: GO 105753
105911: POP
105912: POP
// end ;
105913: LD_VAR 0 3
105917: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
105918: LD_INT 0
105920: PPUSH
105921: PPUSH
105922: PPUSH
// result := 0 ;
105923: LD_ADDR_VAR 0 3
105927: PUSH
105928: LD_INT 0
105930: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
105931: LD_VAR 0 1
105935: PUSH
105936: LD_INT 0
105938: LESS
105939: PUSH
105940: LD_VAR 0 1
105944: PUSH
105945: LD_INT 8
105947: GREATER
105948: OR
105949: PUSH
105950: LD_VAR 0 2
105954: PUSH
105955: LD_INT 0
105957: LESS
105958: OR
105959: PUSH
105960: LD_VAR 0 2
105964: PUSH
105965: LD_INT 8
105967: GREATER
105968: OR
105969: IFFALSE 105973
// exit ;
105971: GO 106048
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
105973: LD_ADDR_VAR 0 4
105977: PUSH
105978: LD_INT 22
105980: PUSH
105981: LD_VAR 0 2
105985: PUSH
105986: EMPTY
105987: LIST
105988: LIST
105989: PPUSH
105990: CALL_OW 69
105994: PUSH
105995: FOR_IN
105996: IFFALSE 106046
// begin un := UnitShoot ( i ) ;
105998: LD_ADDR_VAR 0 5
106002: PUSH
106003: LD_VAR 0 4
106007: PPUSH
106008: CALL_OW 504
106012: ST_TO_ADDR
// if GetSide ( un ) = side1 then
106013: LD_VAR 0 5
106017: PPUSH
106018: CALL_OW 255
106022: PUSH
106023: LD_VAR 0 1
106027: EQUAL
106028: IFFALSE 106044
// begin result := un ;
106030: LD_ADDR_VAR 0 3
106034: PUSH
106035: LD_VAR 0 5
106039: ST_TO_ADDR
// exit ;
106040: POP
106041: POP
106042: GO 106048
// end ; end ;
106044: GO 105995
106046: POP
106047: POP
// end ;
106048: LD_VAR 0 3
106052: RET
// export function GetCargoBay ( units ) ; begin
106053: LD_INT 0
106055: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
106056: LD_ADDR_VAR 0 2
106060: PUSH
106061: LD_VAR 0 1
106065: PPUSH
106066: LD_INT 2
106068: PUSH
106069: LD_INT 34
106071: PUSH
106072: LD_INT 12
106074: PUSH
106075: EMPTY
106076: LIST
106077: LIST
106078: PUSH
106079: LD_INT 34
106081: PUSH
106082: LD_INT 51
106084: PUSH
106085: EMPTY
106086: LIST
106087: LIST
106088: PUSH
106089: LD_INT 34
106091: PUSH
106092: LD_INT 32
106094: PUSH
106095: EMPTY
106096: LIST
106097: LIST
106098: PUSH
106099: LD_INT 34
106101: PUSH
106102: LD_INT 89
106104: PUSH
106105: EMPTY
106106: LIST
106107: LIST
106108: PUSH
106109: EMPTY
106110: LIST
106111: LIST
106112: LIST
106113: LIST
106114: LIST
106115: PPUSH
106116: CALL_OW 72
106120: ST_TO_ADDR
// end ;
106121: LD_VAR 0 2
106125: RET
// export function Negate ( value ) ; begin
106126: LD_INT 0
106128: PPUSH
// result := not value ;
106129: LD_ADDR_VAR 0 2
106133: PUSH
106134: LD_VAR 0 1
106138: NOT
106139: ST_TO_ADDR
// end ;
106140: LD_VAR 0 2
106144: RET
// export function Inc ( value ) ; begin
106145: LD_INT 0
106147: PPUSH
// result := value + 1 ;
106148: LD_ADDR_VAR 0 2
106152: PUSH
106153: LD_VAR 0 1
106157: PUSH
106158: LD_INT 1
106160: PLUS
106161: ST_TO_ADDR
// end ;
106162: LD_VAR 0 2
106166: RET
// export function Dec ( value ) ; begin
106167: LD_INT 0
106169: PPUSH
// result := value - 1 ;
106170: LD_ADDR_VAR 0 2
106174: PUSH
106175: LD_VAR 0 1
106179: PUSH
106180: LD_INT 1
106182: MINUS
106183: ST_TO_ADDR
// end ;
106184: LD_VAR 0 2
106188: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
106189: LD_INT 0
106191: PPUSH
106192: PPUSH
106193: PPUSH
106194: PPUSH
106195: PPUSH
106196: PPUSH
106197: PPUSH
106198: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
106199: LD_VAR 0 1
106203: PPUSH
106204: LD_VAR 0 2
106208: PPUSH
106209: CALL_OW 488
106213: NOT
106214: PUSH
106215: LD_VAR 0 3
106219: PPUSH
106220: LD_VAR 0 4
106224: PPUSH
106225: CALL_OW 488
106229: NOT
106230: OR
106231: IFFALSE 106244
// begin result := - 1 ;
106233: LD_ADDR_VAR 0 5
106237: PUSH
106238: LD_INT 1
106240: NEG
106241: ST_TO_ADDR
// exit ;
106242: GO 106479
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
106244: LD_ADDR_VAR 0 12
106248: PUSH
106249: LD_VAR 0 1
106253: PPUSH
106254: LD_VAR 0 2
106258: PPUSH
106259: LD_VAR 0 3
106263: PPUSH
106264: LD_VAR 0 4
106268: PPUSH
106269: CALL 105329 0 4
106273: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
106274: LD_ADDR_VAR 0 11
106278: PUSH
106279: LD_VAR 0 1
106283: PPUSH
106284: LD_VAR 0 2
106288: PPUSH
106289: LD_VAR 0 12
106293: PUSH
106294: LD_INT 1
106296: ARRAY
106297: PPUSH
106298: LD_VAR 0 12
106302: PUSH
106303: LD_INT 2
106305: ARRAY
106306: PPUSH
106307: CALL_OW 298
106311: ST_TO_ADDR
// distance := 9999 ;
106312: LD_ADDR_VAR 0 10
106316: PUSH
106317: LD_INT 9999
106319: ST_TO_ADDR
// for i := 0 to 5 do
106320: LD_ADDR_VAR 0 6
106324: PUSH
106325: DOUBLE
106326: LD_INT 0
106328: DEC
106329: ST_TO_ADDR
106330: LD_INT 5
106332: PUSH
106333: FOR_TO
106334: IFFALSE 106477
// begin _x := ShiftX ( x1 , i , centerDist ) ;
106336: LD_ADDR_VAR 0 7
106340: PUSH
106341: LD_VAR 0 1
106345: PPUSH
106346: LD_VAR 0 6
106350: PPUSH
106351: LD_VAR 0 11
106355: PPUSH
106356: CALL_OW 272
106360: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
106361: LD_ADDR_VAR 0 8
106365: PUSH
106366: LD_VAR 0 2
106370: PPUSH
106371: LD_VAR 0 6
106375: PPUSH
106376: LD_VAR 0 11
106380: PPUSH
106381: CALL_OW 273
106385: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
106386: LD_VAR 0 7
106390: PPUSH
106391: LD_VAR 0 8
106395: PPUSH
106396: CALL_OW 488
106400: NOT
106401: IFFALSE 106405
// continue ;
106403: GO 106333
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
106405: LD_ADDR_VAR 0 9
106409: PUSH
106410: LD_VAR 0 12
106414: PUSH
106415: LD_INT 1
106417: ARRAY
106418: PPUSH
106419: LD_VAR 0 12
106423: PUSH
106424: LD_INT 2
106426: ARRAY
106427: PPUSH
106428: LD_VAR 0 7
106432: PPUSH
106433: LD_VAR 0 8
106437: PPUSH
106438: CALL_OW 298
106442: ST_TO_ADDR
// if tmp < distance then
106443: LD_VAR 0 9
106447: PUSH
106448: LD_VAR 0 10
106452: LESS
106453: IFFALSE 106475
// begin result := i ;
106455: LD_ADDR_VAR 0 5
106459: PUSH
106460: LD_VAR 0 6
106464: ST_TO_ADDR
// distance := tmp ;
106465: LD_ADDR_VAR 0 10
106469: PUSH
106470: LD_VAR 0 9
106474: ST_TO_ADDR
// end ; end ;
106475: GO 106333
106477: POP
106478: POP
// end ;
106479: LD_VAR 0 5
106483: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
106484: LD_INT 0
106486: PPUSH
106487: PPUSH
// if not driver or not IsInUnit ( driver ) then
106488: LD_VAR 0 1
106492: NOT
106493: PUSH
106494: LD_VAR 0 1
106498: PPUSH
106499: CALL_OW 310
106503: NOT
106504: OR
106505: IFFALSE 106509
// exit ;
106507: GO 106599
// vehicle := IsInUnit ( driver ) ;
106509: LD_ADDR_VAR 0 3
106513: PUSH
106514: LD_VAR 0 1
106518: PPUSH
106519: CALL_OW 310
106523: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
106524: LD_VAR 0 1
106528: PPUSH
106529: LD_STRING \
106531: PUSH
106532: LD_INT 0
106534: PUSH
106535: LD_INT 0
106537: PUSH
106538: LD_INT 0
106540: PUSH
106541: LD_INT 0
106543: PUSH
106544: LD_INT 0
106546: PUSH
106547: LD_INT 0
106549: PUSH
106550: EMPTY
106551: LIST
106552: LIST
106553: LIST
106554: LIST
106555: LIST
106556: LIST
106557: LIST
106558: PUSH
106559: LD_STRING E
106561: PUSH
106562: LD_INT 0
106564: PUSH
106565: LD_INT 0
106567: PUSH
106568: LD_VAR 0 3
106572: PUSH
106573: LD_INT 0
106575: PUSH
106576: LD_INT 0
106578: PUSH
106579: LD_INT 0
106581: PUSH
106582: EMPTY
106583: LIST
106584: LIST
106585: LIST
106586: LIST
106587: LIST
106588: LIST
106589: LIST
106590: PUSH
106591: EMPTY
106592: LIST
106593: LIST
106594: PPUSH
106595: CALL_OW 446
// end ;
106599: LD_VAR 0 2
106603: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
106604: LD_INT 0
106606: PPUSH
106607: PPUSH
// if not driver or not IsInUnit ( driver ) then
106608: LD_VAR 0 1
106612: NOT
106613: PUSH
106614: LD_VAR 0 1
106618: PPUSH
106619: CALL_OW 310
106623: NOT
106624: OR
106625: IFFALSE 106629
// exit ;
106627: GO 106719
// vehicle := IsInUnit ( driver ) ;
106629: LD_ADDR_VAR 0 3
106633: PUSH
106634: LD_VAR 0 1
106638: PPUSH
106639: CALL_OW 310
106643: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
106644: LD_VAR 0 1
106648: PPUSH
106649: LD_STRING \
106651: PUSH
106652: LD_INT 0
106654: PUSH
106655: LD_INT 0
106657: PUSH
106658: LD_INT 0
106660: PUSH
106661: LD_INT 0
106663: PUSH
106664: LD_INT 0
106666: PUSH
106667: LD_INT 0
106669: PUSH
106670: EMPTY
106671: LIST
106672: LIST
106673: LIST
106674: LIST
106675: LIST
106676: LIST
106677: LIST
106678: PUSH
106679: LD_STRING E
106681: PUSH
106682: LD_INT 0
106684: PUSH
106685: LD_INT 0
106687: PUSH
106688: LD_VAR 0 3
106692: PUSH
106693: LD_INT 0
106695: PUSH
106696: LD_INT 0
106698: PUSH
106699: LD_INT 0
106701: PUSH
106702: EMPTY
106703: LIST
106704: LIST
106705: LIST
106706: LIST
106707: LIST
106708: LIST
106709: LIST
106710: PUSH
106711: EMPTY
106712: LIST
106713: LIST
106714: PPUSH
106715: CALL_OW 447
// end ;
106719: LD_VAR 0 2
106723: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
106724: LD_INT 0
106726: PPUSH
106727: PPUSH
106728: PPUSH
// tmp := [ ] ;
106729: LD_ADDR_VAR 0 5
106733: PUSH
106734: EMPTY
106735: ST_TO_ADDR
// for i in units do
106736: LD_ADDR_VAR 0 4
106740: PUSH
106741: LD_VAR 0 1
106745: PUSH
106746: FOR_IN
106747: IFFALSE 106785
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
106749: LD_ADDR_VAR 0 5
106753: PUSH
106754: LD_VAR 0 5
106758: PPUSH
106759: LD_VAR 0 5
106763: PUSH
106764: LD_INT 1
106766: PLUS
106767: PPUSH
106768: LD_VAR 0 4
106772: PPUSH
106773: CALL_OW 256
106777: PPUSH
106778: CALL_OW 2
106782: ST_TO_ADDR
106783: GO 106746
106785: POP
106786: POP
// if not tmp then
106787: LD_VAR 0 5
106791: NOT
106792: IFFALSE 106796
// exit ;
106794: GO 106844
// if asc then
106796: LD_VAR 0 2
106800: IFFALSE 106824
// result := SortListByListAsc ( units , tmp ) else
106802: LD_ADDR_VAR 0 3
106806: PUSH
106807: LD_VAR 0 1
106811: PPUSH
106812: LD_VAR 0 5
106816: PPUSH
106817: CALL_OW 76
106821: ST_TO_ADDR
106822: GO 106844
// result := SortListByListDesc ( units , tmp ) ;
106824: LD_ADDR_VAR 0 3
106828: PUSH
106829: LD_VAR 0 1
106833: PPUSH
106834: LD_VAR 0 5
106838: PPUSH
106839: CALL_OW 77
106843: ST_TO_ADDR
// end ;
106844: LD_VAR 0 3
106848: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
106849: LD_INT 0
106851: PPUSH
106852: PPUSH
// task := GetTaskList ( mech ) ;
106853: LD_ADDR_VAR 0 4
106857: PUSH
106858: LD_VAR 0 1
106862: PPUSH
106863: CALL_OW 437
106867: ST_TO_ADDR
// if not task then
106868: LD_VAR 0 4
106872: NOT
106873: IFFALSE 106877
// exit ;
106875: GO 106919
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
106877: LD_ADDR_VAR 0 3
106881: PUSH
106882: LD_VAR 0 4
106886: PUSH
106887: LD_INT 1
106889: ARRAY
106890: PUSH
106891: LD_INT 1
106893: ARRAY
106894: PUSH
106895: LD_STRING r
106897: EQUAL
106898: PUSH
106899: LD_VAR 0 4
106903: PUSH
106904: LD_INT 1
106906: ARRAY
106907: PUSH
106908: LD_INT 4
106910: ARRAY
106911: PUSH
106912: LD_VAR 0 2
106916: EQUAL
106917: AND
106918: ST_TO_ADDR
// end ;
106919: LD_VAR 0 3
106923: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
106924: LD_INT 0
106926: PPUSH
// SetDir ( unit , d ) ;
106927: LD_VAR 0 1
106931: PPUSH
106932: LD_VAR 0 4
106936: PPUSH
106937: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
106941: LD_VAR 0 1
106945: PPUSH
106946: LD_VAR 0 2
106950: PPUSH
106951: LD_VAR 0 3
106955: PPUSH
106956: LD_VAR 0 5
106960: PPUSH
106961: CALL_OW 48
// end ;
106965: LD_VAR 0 6
106969: RET
// export function ToNaturalNumber ( number ) ; begin
106970: LD_INT 0
106972: PPUSH
// result := number div 1 ;
106973: LD_ADDR_VAR 0 2
106977: PUSH
106978: LD_VAR 0 1
106982: PUSH
106983: LD_INT 1
106985: DIV
106986: ST_TO_ADDR
// if number < 0 then
106987: LD_VAR 0 1
106991: PUSH
106992: LD_INT 0
106994: LESS
106995: IFFALSE 107005
// result := 0 ;
106997: LD_ADDR_VAR 0 2
107001: PUSH
107002: LD_INT 0
107004: ST_TO_ADDR
// end ;
107005: LD_VAR 0 2
107009: RET
// export function SortByClass ( units , class ) ; var un ; begin
107010: LD_INT 0
107012: PPUSH
107013: PPUSH
// if not units or not class then
107014: LD_VAR 0 1
107018: NOT
107019: PUSH
107020: LD_VAR 0 2
107024: NOT
107025: OR
107026: IFFALSE 107030
// exit ;
107028: GO 107125
// result := [ ] ;
107030: LD_ADDR_VAR 0 3
107034: PUSH
107035: EMPTY
107036: ST_TO_ADDR
// for un in units do
107037: LD_ADDR_VAR 0 4
107041: PUSH
107042: LD_VAR 0 1
107046: PUSH
107047: FOR_IN
107048: IFFALSE 107123
// if GetClass ( un ) = class then
107050: LD_VAR 0 4
107054: PPUSH
107055: CALL_OW 257
107059: PUSH
107060: LD_VAR 0 2
107064: EQUAL
107065: IFFALSE 107092
// result := Insert ( result , 1 , un ) else
107067: LD_ADDR_VAR 0 3
107071: PUSH
107072: LD_VAR 0 3
107076: PPUSH
107077: LD_INT 1
107079: PPUSH
107080: LD_VAR 0 4
107084: PPUSH
107085: CALL_OW 2
107089: ST_TO_ADDR
107090: GO 107121
// result := Replace ( result , result + 1 , un ) ;
107092: LD_ADDR_VAR 0 3
107096: PUSH
107097: LD_VAR 0 3
107101: PPUSH
107102: LD_VAR 0 3
107106: PUSH
107107: LD_INT 1
107109: PLUS
107110: PPUSH
107111: LD_VAR 0 4
107115: PPUSH
107116: CALL_OW 1
107120: ST_TO_ADDR
107121: GO 107047
107123: POP
107124: POP
// end ;
107125: LD_VAR 0 3
107129: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
107130: LD_INT 0
107132: PPUSH
107133: PPUSH
107134: PPUSH
107135: PPUSH
107136: PPUSH
107137: PPUSH
107138: PPUSH
// result := [ ] ;
107139: LD_ADDR_VAR 0 4
107143: PUSH
107144: EMPTY
107145: ST_TO_ADDR
// if x - r < 0 then
107146: LD_VAR 0 1
107150: PUSH
107151: LD_VAR 0 3
107155: MINUS
107156: PUSH
107157: LD_INT 0
107159: LESS
107160: IFFALSE 107172
// min_x := 0 else
107162: LD_ADDR_VAR 0 8
107166: PUSH
107167: LD_INT 0
107169: ST_TO_ADDR
107170: GO 107188
// min_x := x - r ;
107172: LD_ADDR_VAR 0 8
107176: PUSH
107177: LD_VAR 0 1
107181: PUSH
107182: LD_VAR 0 3
107186: MINUS
107187: ST_TO_ADDR
// if y - r < 0 then
107188: LD_VAR 0 2
107192: PUSH
107193: LD_VAR 0 3
107197: MINUS
107198: PUSH
107199: LD_INT 0
107201: LESS
107202: IFFALSE 107214
// min_y := 0 else
107204: LD_ADDR_VAR 0 7
107208: PUSH
107209: LD_INT 0
107211: ST_TO_ADDR
107212: GO 107230
// min_y := y - r ;
107214: LD_ADDR_VAR 0 7
107218: PUSH
107219: LD_VAR 0 2
107223: PUSH
107224: LD_VAR 0 3
107228: MINUS
107229: ST_TO_ADDR
// max_x := x + r ;
107230: LD_ADDR_VAR 0 9
107234: PUSH
107235: LD_VAR 0 1
107239: PUSH
107240: LD_VAR 0 3
107244: PLUS
107245: ST_TO_ADDR
// max_y := y + r ;
107246: LD_ADDR_VAR 0 10
107250: PUSH
107251: LD_VAR 0 2
107255: PUSH
107256: LD_VAR 0 3
107260: PLUS
107261: ST_TO_ADDR
// for _x = min_x to max_x do
107262: LD_ADDR_VAR 0 5
107266: PUSH
107267: DOUBLE
107268: LD_VAR 0 8
107272: DEC
107273: ST_TO_ADDR
107274: LD_VAR 0 9
107278: PUSH
107279: FOR_TO
107280: IFFALSE 107381
// for _y = min_y to max_y do
107282: LD_ADDR_VAR 0 6
107286: PUSH
107287: DOUBLE
107288: LD_VAR 0 7
107292: DEC
107293: ST_TO_ADDR
107294: LD_VAR 0 10
107298: PUSH
107299: FOR_TO
107300: IFFALSE 107377
// begin if not ValidHex ( _x , _y ) then
107302: LD_VAR 0 5
107306: PPUSH
107307: LD_VAR 0 6
107311: PPUSH
107312: CALL_OW 488
107316: NOT
107317: IFFALSE 107321
// continue ;
107319: GO 107299
// if GetResourceTypeXY ( _x , _y ) then
107321: LD_VAR 0 5
107325: PPUSH
107326: LD_VAR 0 6
107330: PPUSH
107331: CALL_OW 283
107335: IFFALSE 107375
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
107337: LD_ADDR_VAR 0 4
107341: PUSH
107342: LD_VAR 0 4
107346: PPUSH
107347: LD_VAR 0 4
107351: PUSH
107352: LD_INT 1
107354: PLUS
107355: PPUSH
107356: LD_VAR 0 5
107360: PUSH
107361: LD_VAR 0 6
107365: PUSH
107366: EMPTY
107367: LIST
107368: LIST
107369: PPUSH
107370: CALL_OW 1
107374: ST_TO_ADDR
// end ;
107375: GO 107299
107377: POP
107378: POP
107379: GO 107279
107381: POP
107382: POP
// end ;
107383: LD_VAR 0 4
107387: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
107388: LD_INT 0
107390: PPUSH
107391: PPUSH
107392: PPUSH
107393: PPUSH
107394: PPUSH
107395: PPUSH
107396: PPUSH
107397: PPUSH
// if not units then
107398: LD_VAR 0 1
107402: NOT
107403: IFFALSE 107407
// exit ;
107405: GO 107931
// result := UnitFilter ( units , [ f_ok ] ) ;
107407: LD_ADDR_VAR 0 3
107411: PUSH
107412: LD_VAR 0 1
107416: PPUSH
107417: LD_INT 50
107419: PUSH
107420: EMPTY
107421: LIST
107422: PPUSH
107423: CALL_OW 72
107427: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
107428: LD_ADDR_VAR 0 8
107432: PUSH
107433: LD_VAR 0 1
107437: PUSH
107438: LD_INT 1
107440: ARRAY
107441: PPUSH
107442: CALL_OW 255
107446: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
107447: LD_ADDR_VAR 0 10
107451: PUSH
107452: LD_INT 29
107454: PUSH
107455: LD_INT 91
107457: PUSH
107458: LD_INT 49
107460: PUSH
107461: EMPTY
107462: LIST
107463: LIST
107464: LIST
107465: ST_TO_ADDR
// if not result then
107466: LD_VAR 0 3
107470: NOT
107471: IFFALSE 107475
// exit ;
107473: GO 107931
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
107475: LD_ADDR_VAR 0 5
107479: PUSH
107480: LD_INT 81
107482: PUSH
107483: LD_VAR 0 8
107487: PUSH
107488: EMPTY
107489: LIST
107490: LIST
107491: PPUSH
107492: CALL_OW 69
107496: ST_TO_ADDR
// for i in result do
107497: LD_ADDR_VAR 0 4
107501: PUSH
107502: LD_VAR 0 3
107506: PUSH
107507: FOR_IN
107508: IFFALSE 107929
// begin tag := GetTag ( i ) + 1 ;
107510: LD_ADDR_VAR 0 9
107514: PUSH
107515: LD_VAR 0 4
107519: PPUSH
107520: CALL_OW 110
107524: PUSH
107525: LD_INT 1
107527: PLUS
107528: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
107529: LD_ADDR_VAR 0 7
107533: PUSH
107534: LD_VAR 0 4
107538: PPUSH
107539: CALL_OW 250
107543: PPUSH
107544: LD_VAR 0 4
107548: PPUSH
107549: CALL_OW 251
107553: PPUSH
107554: LD_INT 6
107556: PPUSH
107557: CALL 107130 0 3
107561: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
107562: LD_VAR 0 4
107566: PPUSH
107567: CALL_OW 247
107571: PUSH
107572: LD_INT 2
107574: EQUAL
107575: PUSH
107576: LD_VAR 0 7
107580: AND
107581: PUSH
107582: LD_VAR 0 4
107586: PPUSH
107587: CALL_OW 264
107591: PUSH
107592: LD_VAR 0 10
107596: IN
107597: NOT
107598: AND
107599: IFFALSE 107638
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
107601: LD_VAR 0 4
107605: PPUSH
107606: LD_VAR 0 7
107610: PUSH
107611: LD_INT 1
107613: ARRAY
107614: PUSH
107615: LD_INT 1
107617: ARRAY
107618: PPUSH
107619: LD_VAR 0 7
107623: PUSH
107624: LD_INT 1
107626: ARRAY
107627: PUSH
107628: LD_INT 2
107630: ARRAY
107631: PPUSH
107632: CALL_OW 116
107636: GO 107927
// if path > tag then
107638: LD_VAR 0 2
107642: PUSH
107643: LD_VAR 0 9
107647: GREATER
107648: IFFALSE 107856
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
107650: LD_ADDR_VAR 0 6
107654: PUSH
107655: LD_VAR 0 5
107659: PPUSH
107660: LD_INT 91
107662: PUSH
107663: LD_VAR 0 4
107667: PUSH
107668: LD_INT 8
107670: PUSH
107671: EMPTY
107672: LIST
107673: LIST
107674: LIST
107675: PPUSH
107676: CALL_OW 72
107680: ST_TO_ADDR
// if nearEnemy then
107681: LD_VAR 0 6
107685: IFFALSE 107754
// begin if GetWeapon ( i ) = ru_time_lapser then
107687: LD_VAR 0 4
107691: PPUSH
107692: CALL_OW 264
107696: PUSH
107697: LD_INT 49
107699: EQUAL
107700: IFFALSE 107728
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
107702: LD_VAR 0 4
107706: PPUSH
107707: LD_VAR 0 6
107711: PPUSH
107712: LD_VAR 0 4
107716: PPUSH
107717: CALL_OW 74
107721: PPUSH
107722: CALL_OW 112
107726: GO 107752
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
107728: LD_VAR 0 4
107732: PPUSH
107733: LD_VAR 0 6
107737: PPUSH
107738: LD_VAR 0 4
107742: PPUSH
107743: CALL_OW 74
107747: PPUSH
107748: CALL_OW 115
// end else
107752: GO 107854
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
107754: LD_VAR 0 4
107758: PPUSH
107759: LD_VAR 0 2
107763: PUSH
107764: LD_VAR 0 9
107768: ARRAY
107769: PUSH
107770: LD_INT 1
107772: ARRAY
107773: PPUSH
107774: LD_VAR 0 2
107778: PUSH
107779: LD_VAR 0 9
107783: ARRAY
107784: PUSH
107785: LD_INT 2
107787: ARRAY
107788: PPUSH
107789: CALL_OW 297
107793: PUSH
107794: LD_INT 6
107796: GREATER
107797: IFFALSE 107840
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
107799: LD_VAR 0 4
107803: PPUSH
107804: LD_VAR 0 2
107808: PUSH
107809: LD_VAR 0 9
107813: ARRAY
107814: PUSH
107815: LD_INT 1
107817: ARRAY
107818: PPUSH
107819: LD_VAR 0 2
107823: PUSH
107824: LD_VAR 0 9
107828: ARRAY
107829: PUSH
107830: LD_INT 2
107832: ARRAY
107833: PPUSH
107834: CALL_OW 114
107838: GO 107854
// SetTag ( i , tag ) ;
107840: LD_VAR 0 4
107844: PPUSH
107845: LD_VAR 0 9
107849: PPUSH
107850: CALL_OW 109
// end else
107854: GO 107927
// if enemy then
107856: LD_VAR 0 5
107860: IFFALSE 107927
// begin if GetWeapon ( i ) = ru_time_lapser then
107862: LD_VAR 0 4
107866: PPUSH
107867: CALL_OW 264
107871: PUSH
107872: LD_INT 49
107874: EQUAL
107875: IFFALSE 107903
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
107877: LD_VAR 0 4
107881: PPUSH
107882: LD_VAR 0 5
107886: PPUSH
107887: LD_VAR 0 4
107891: PPUSH
107892: CALL_OW 74
107896: PPUSH
107897: CALL_OW 112
107901: GO 107927
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
107903: LD_VAR 0 4
107907: PPUSH
107908: LD_VAR 0 5
107912: PPUSH
107913: LD_VAR 0 4
107917: PPUSH
107918: CALL_OW 74
107922: PPUSH
107923: CALL_OW 115
// end ; end ;
107927: GO 107507
107929: POP
107930: POP
// end ;
107931: LD_VAR 0 3
107935: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
107936: LD_INT 0
107938: PPUSH
107939: PPUSH
107940: PPUSH
// if not unit or IsInUnit ( unit ) then
107941: LD_VAR 0 1
107945: NOT
107946: PUSH
107947: LD_VAR 0 1
107951: PPUSH
107952: CALL_OW 310
107956: OR
107957: IFFALSE 107961
// exit ;
107959: GO 108052
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
107961: LD_ADDR_VAR 0 4
107965: PUSH
107966: LD_VAR 0 1
107970: PPUSH
107971: CALL_OW 250
107975: PPUSH
107976: LD_VAR 0 2
107980: PPUSH
107981: LD_INT 1
107983: PPUSH
107984: CALL_OW 272
107988: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
107989: LD_ADDR_VAR 0 5
107993: PUSH
107994: LD_VAR 0 1
107998: PPUSH
107999: CALL_OW 251
108003: PPUSH
108004: LD_VAR 0 2
108008: PPUSH
108009: LD_INT 1
108011: PPUSH
108012: CALL_OW 273
108016: ST_TO_ADDR
// if ValidHex ( x , y ) then
108017: LD_VAR 0 4
108021: PPUSH
108022: LD_VAR 0 5
108026: PPUSH
108027: CALL_OW 488
108031: IFFALSE 108052
// ComTurnXY ( unit , x , y ) ;
108033: LD_VAR 0 1
108037: PPUSH
108038: LD_VAR 0 4
108042: PPUSH
108043: LD_VAR 0 5
108047: PPUSH
108048: CALL_OW 118
// end ;
108052: LD_VAR 0 3
108056: RET
// export function SeeUnits ( side , units ) ; var i ; begin
108057: LD_INT 0
108059: PPUSH
108060: PPUSH
// result := false ;
108061: LD_ADDR_VAR 0 3
108065: PUSH
108066: LD_INT 0
108068: ST_TO_ADDR
// if not units then
108069: LD_VAR 0 2
108073: NOT
108074: IFFALSE 108078
// exit ;
108076: GO 108123
// for i in units do
108078: LD_ADDR_VAR 0 4
108082: PUSH
108083: LD_VAR 0 2
108087: PUSH
108088: FOR_IN
108089: IFFALSE 108121
// if See ( side , i ) then
108091: LD_VAR 0 1
108095: PPUSH
108096: LD_VAR 0 4
108100: PPUSH
108101: CALL_OW 292
108105: IFFALSE 108119
// begin result := true ;
108107: LD_ADDR_VAR 0 3
108111: PUSH
108112: LD_INT 1
108114: ST_TO_ADDR
// exit ;
108115: POP
108116: POP
108117: GO 108123
// end ;
108119: GO 108088
108121: POP
108122: POP
// end ;
108123: LD_VAR 0 3
108127: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
108128: LD_INT 0
108130: PPUSH
108131: PPUSH
108132: PPUSH
108133: PPUSH
// if not unit or not points then
108134: LD_VAR 0 1
108138: NOT
108139: PUSH
108140: LD_VAR 0 2
108144: NOT
108145: OR
108146: IFFALSE 108150
// exit ;
108148: GO 108240
// dist := 99999 ;
108150: LD_ADDR_VAR 0 5
108154: PUSH
108155: LD_INT 99999
108157: ST_TO_ADDR
// for i in points do
108158: LD_ADDR_VAR 0 4
108162: PUSH
108163: LD_VAR 0 2
108167: PUSH
108168: FOR_IN
108169: IFFALSE 108238
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
108171: LD_ADDR_VAR 0 6
108175: PUSH
108176: LD_VAR 0 1
108180: PPUSH
108181: LD_VAR 0 4
108185: PUSH
108186: LD_INT 1
108188: ARRAY
108189: PPUSH
108190: LD_VAR 0 4
108194: PUSH
108195: LD_INT 2
108197: ARRAY
108198: PPUSH
108199: CALL_OW 297
108203: ST_TO_ADDR
// if tmpDist < dist then
108204: LD_VAR 0 6
108208: PUSH
108209: LD_VAR 0 5
108213: LESS
108214: IFFALSE 108236
// begin result := i ;
108216: LD_ADDR_VAR 0 3
108220: PUSH
108221: LD_VAR 0 4
108225: ST_TO_ADDR
// dist := tmpDist ;
108226: LD_ADDR_VAR 0 5
108230: PUSH
108231: LD_VAR 0 6
108235: ST_TO_ADDR
// end ; end ;
108236: GO 108168
108238: POP
108239: POP
// end ;
108240: LD_VAR 0 3
108244: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
108245: LD_INT 0
108247: PPUSH
// uc_side := side ;
108248: LD_ADDR_OWVAR 20
108252: PUSH
108253: LD_VAR 0 1
108257: ST_TO_ADDR
// uc_nation := 3 ;
108258: LD_ADDR_OWVAR 21
108262: PUSH
108263: LD_INT 3
108265: ST_TO_ADDR
// vc_chassis := 25 ;
108266: LD_ADDR_OWVAR 37
108270: PUSH
108271: LD_INT 25
108273: ST_TO_ADDR
// vc_engine := engine_siberite ;
108274: LD_ADDR_OWVAR 39
108278: PUSH
108279: LD_INT 3
108281: ST_TO_ADDR
// vc_control := control_computer ;
108282: LD_ADDR_OWVAR 38
108286: PUSH
108287: LD_INT 3
108289: ST_TO_ADDR
// vc_weapon := 59 ;
108290: LD_ADDR_OWVAR 40
108294: PUSH
108295: LD_INT 59
108297: ST_TO_ADDR
// result := CreateVehicle ;
108298: LD_ADDR_VAR 0 5
108302: PUSH
108303: CALL_OW 45
108307: ST_TO_ADDR
// SetDir ( result , d ) ;
108308: LD_VAR 0 5
108312: PPUSH
108313: LD_VAR 0 4
108317: PPUSH
108318: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
108322: LD_VAR 0 5
108326: PPUSH
108327: LD_VAR 0 2
108331: PPUSH
108332: LD_VAR 0 3
108336: PPUSH
108337: LD_INT 0
108339: PPUSH
108340: CALL_OW 48
// end ;
108344: LD_VAR 0 5
108348: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
108349: LD_INT 0
108351: PPUSH
108352: PPUSH
108353: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
108354: LD_ADDR_VAR 0 2
108358: PUSH
108359: LD_INT 0
108361: PUSH
108362: LD_INT 0
108364: PUSH
108365: LD_INT 0
108367: PUSH
108368: LD_INT 0
108370: PUSH
108371: EMPTY
108372: LIST
108373: LIST
108374: LIST
108375: LIST
108376: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
108377: LD_VAR 0 1
108381: NOT
108382: PUSH
108383: LD_VAR 0 1
108387: PPUSH
108388: CALL_OW 264
108392: PUSH
108393: LD_INT 12
108395: PUSH
108396: LD_INT 51
108398: PUSH
108399: LD_INT 32
108401: PUSH
108402: LD_INT 89
108404: PUSH
108405: EMPTY
108406: LIST
108407: LIST
108408: LIST
108409: LIST
108410: IN
108411: NOT
108412: OR
108413: IFFALSE 108417
// exit ;
108415: GO 108515
// for i := 1 to 3 do
108417: LD_ADDR_VAR 0 3
108421: PUSH
108422: DOUBLE
108423: LD_INT 1
108425: DEC
108426: ST_TO_ADDR
108427: LD_INT 3
108429: PUSH
108430: FOR_TO
108431: IFFALSE 108513
// begin tmp := GetCargo ( cargo , i ) ;
108433: LD_ADDR_VAR 0 4
108437: PUSH
108438: LD_VAR 0 1
108442: PPUSH
108443: LD_VAR 0 3
108447: PPUSH
108448: CALL_OW 289
108452: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
108453: LD_ADDR_VAR 0 2
108457: PUSH
108458: LD_VAR 0 2
108462: PPUSH
108463: LD_VAR 0 3
108467: PPUSH
108468: LD_VAR 0 4
108472: PPUSH
108473: CALL_OW 1
108477: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
108478: LD_ADDR_VAR 0 2
108482: PUSH
108483: LD_VAR 0 2
108487: PPUSH
108488: LD_INT 4
108490: PPUSH
108491: LD_VAR 0 2
108495: PUSH
108496: LD_INT 4
108498: ARRAY
108499: PUSH
108500: LD_VAR 0 4
108504: PLUS
108505: PPUSH
108506: CALL_OW 1
108510: ST_TO_ADDR
// end ;
108511: GO 108430
108513: POP
108514: POP
// end ;
108515: LD_VAR 0 2
108519: RET
// export function Length ( array ) ; begin
108520: LD_INT 0
108522: PPUSH
// result := array + 0 ;
108523: LD_ADDR_VAR 0 2
108527: PUSH
108528: LD_VAR 0 1
108532: PUSH
108533: LD_INT 0
108535: PLUS
108536: ST_TO_ADDR
// end ;
108537: LD_VAR 0 2
108541: RET
// export function PrepareArray ( array ) ; begin
108542: LD_INT 0
108544: PPUSH
// result := array diff 0 ;
108545: LD_ADDR_VAR 0 2
108549: PUSH
108550: LD_VAR 0 1
108554: PUSH
108555: LD_INT 0
108557: DIFF
108558: ST_TO_ADDR
// if not result [ 1 ] then
108559: LD_VAR 0 2
108563: PUSH
108564: LD_INT 1
108566: ARRAY
108567: NOT
108568: IFFALSE 108588
// result := Delete ( result , 1 ) ;
108570: LD_ADDR_VAR 0 2
108574: PUSH
108575: LD_VAR 0 2
108579: PPUSH
108580: LD_INT 1
108582: PPUSH
108583: CALL_OW 3
108587: ST_TO_ADDR
// end ;
108588: LD_VAR 0 2
108592: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
108593: LD_INT 0
108595: PPUSH
108596: PPUSH
108597: PPUSH
108598: PPUSH
// sibRocketRange := 25 ;
108599: LD_ADDR_VAR 0 6
108603: PUSH
108604: LD_INT 25
108606: ST_TO_ADDR
// result := false ;
108607: LD_ADDR_VAR 0 4
108611: PUSH
108612: LD_INT 0
108614: ST_TO_ADDR
// for i := 0 to 5 do
108615: LD_ADDR_VAR 0 5
108619: PUSH
108620: DOUBLE
108621: LD_INT 0
108623: DEC
108624: ST_TO_ADDR
108625: LD_INT 5
108627: PUSH
108628: FOR_TO
108629: IFFALSE 108696
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
108631: LD_VAR 0 1
108635: PPUSH
108636: LD_VAR 0 5
108640: PPUSH
108641: LD_VAR 0 6
108645: PPUSH
108646: CALL_OW 272
108650: PPUSH
108651: LD_VAR 0 2
108655: PPUSH
108656: LD_VAR 0 5
108660: PPUSH
108661: LD_VAR 0 6
108665: PPUSH
108666: CALL_OW 273
108670: PPUSH
108671: LD_VAR 0 3
108675: PPUSH
108676: CALL_OW 309
108680: IFFALSE 108694
// begin result := true ;
108682: LD_ADDR_VAR 0 4
108686: PUSH
108687: LD_INT 1
108689: ST_TO_ADDR
// exit ;
108690: POP
108691: POP
108692: GO 108698
// end ;
108694: GO 108628
108696: POP
108697: POP
// end ; end_of_file end_of_file
108698: LD_VAR 0 4
108702: RET
// every 0 0$1 do
108703: GO 108705
108705: DISABLE
// begin enable ;
108706: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
108707: LD_STRING updateTimer(
108709: PUSH
108710: LD_OWVAR 1
108714: STR
108715: PUSH
108716: LD_STRING );
108718: STR
108719: PPUSH
108720: CALL_OW 559
// end ;
108724: END
// export function SOS_MapStart ( ) ; begin
108725: LD_INT 0
108727: PPUSH
// if streamModeActive then
108728: LD_EXP 143
108732: IFFALSE 108741
// DefineStreamItems ( true ) ;
108734: LD_INT 1
108736: PPUSH
108737: CALL 110395 0 1
// UpdateFactoryWaypoints ( ) ;
108741: CALL 123256 0 0
// UpdateWarehouseGatheringPoints ( ) ;
108745: CALL 123513 0 0
// end ;
108749: LD_VAR 0 1
108753: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
108754: LD_INT 0
108756: PPUSH
// if p2 = hack_mode then
108757: LD_VAR 0 2
108761: PUSH
108762: LD_INT 100
108764: EQUAL
108765: IFFALSE 109768
// begin if not StreamModeActive then
108767: LD_EXP 143
108771: NOT
108772: IFFALSE 108782
// StreamModeActive := true ;
108774: LD_ADDR_EXP 143
108778: PUSH
108779: LD_INT 1
108781: ST_TO_ADDR
// if p3 = 0 then
108782: LD_VAR 0 3
108786: PUSH
108787: LD_INT 0
108789: EQUAL
108790: IFFALSE 108796
// InitStreamMode ;
108792: CALL 109931 0 0
// if p3 = 1 then
108796: LD_VAR 0 3
108800: PUSH
108801: LD_INT 1
108803: EQUAL
108804: IFFALSE 108814
// sRocket := true ;
108806: LD_ADDR_EXP 148
108810: PUSH
108811: LD_INT 1
108813: ST_TO_ADDR
// if p3 = 2 then
108814: LD_VAR 0 3
108818: PUSH
108819: LD_INT 2
108821: EQUAL
108822: IFFALSE 108832
// sSpeed := true ;
108824: LD_ADDR_EXP 147
108828: PUSH
108829: LD_INT 1
108831: ST_TO_ADDR
// if p3 = 3 then
108832: LD_VAR 0 3
108836: PUSH
108837: LD_INT 3
108839: EQUAL
108840: IFFALSE 108850
// sEngine := true ;
108842: LD_ADDR_EXP 149
108846: PUSH
108847: LD_INT 1
108849: ST_TO_ADDR
// if p3 = 4 then
108850: LD_VAR 0 3
108854: PUSH
108855: LD_INT 4
108857: EQUAL
108858: IFFALSE 108868
// sSpec := true ;
108860: LD_ADDR_EXP 146
108864: PUSH
108865: LD_INT 1
108867: ST_TO_ADDR
// if p3 = 5 then
108868: LD_VAR 0 3
108872: PUSH
108873: LD_INT 5
108875: EQUAL
108876: IFFALSE 108886
// sLevel := true ;
108878: LD_ADDR_EXP 150
108882: PUSH
108883: LD_INT 1
108885: ST_TO_ADDR
// if p3 = 6 then
108886: LD_VAR 0 3
108890: PUSH
108891: LD_INT 6
108893: EQUAL
108894: IFFALSE 108904
// sArmoury := true ;
108896: LD_ADDR_EXP 151
108900: PUSH
108901: LD_INT 1
108903: ST_TO_ADDR
// if p3 = 7 then
108904: LD_VAR 0 3
108908: PUSH
108909: LD_INT 7
108911: EQUAL
108912: IFFALSE 108922
// sRadar := true ;
108914: LD_ADDR_EXP 152
108918: PUSH
108919: LD_INT 1
108921: ST_TO_ADDR
// if p3 = 8 then
108922: LD_VAR 0 3
108926: PUSH
108927: LD_INT 8
108929: EQUAL
108930: IFFALSE 108940
// sBunker := true ;
108932: LD_ADDR_EXP 153
108936: PUSH
108937: LD_INT 1
108939: ST_TO_ADDR
// if p3 = 9 then
108940: LD_VAR 0 3
108944: PUSH
108945: LD_INT 9
108947: EQUAL
108948: IFFALSE 108958
// sHack := true ;
108950: LD_ADDR_EXP 154
108954: PUSH
108955: LD_INT 1
108957: ST_TO_ADDR
// if p3 = 10 then
108958: LD_VAR 0 3
108962: PUSH
108963: LD_INT 10
108965: EQUAL
108966: IFFALSE 108976
// sFire := true ;
108968: LD_ADDR_EXP 155
108972: PUSH
108973: LD_INT 1
108975: ST_TO_ADDR
// if p3 = 11 then
108976: LD_VAR 0 3
108980: PUSH
108981: LD_INT 11
108983: EQUAL
108984: IFFALSE 108994
// sRefresh := true ;
108986: LD_ADDR_EXP 156
108990: PUSH
108991: LD_INT 1
108993: ST_TO_ADDR
// if p3 = 12 then
108994: LD_VAR 0 3
108998: PUSH
108999: LD_INT 12
109001: EQUAL
109002: IFFALSE 109012
// sExp := true ;
109004: LD_ADDR_EXP 157
109008: PUSH
109009: LD_INT 1
109011: ST_TO_ADDR
// if p3 = 13 then
109012: LD_VAR 0 3
109016: PUSH
109017: LD_INT 13
109019: EQUAL
109020: IFFALSE 109030
// sDepot := true ;
109022: LD_ADDR_EXP 158
109026: PUSH
109027: LD_INT 1
109029: ST_TO_ADDR
// if p3 = 14 then
109030: LD_VAR 0 3
109034: PUSH
109035: LD_INT 14
109037: EQUAL
109038: IFFALSE 109048
// sFlag := true ;
109040: LD_ADDR_EXP 159
109044: PUSH
109045: LD_INT 1
109047: ST_TO_ADDR
// if p3 = 15 then
109048: LD_VAR 0 3
109052: PUSH
109053: LD_INT 15
109055: EQUAL
109056: IFFALSE 109066
// sKamikadze := true ;
109058: LD_ADDR_EXP 167
109062: PUSH
109063: LD_INT 1
109065: ST_TO_ADDR
// if p3 = 16 then
109066: LD_VAR 0 3
109070: PUSH
109071: LD_INT 16
109073: EQUAL
109074: IFFALSE 109084
// sTroll := true ;
109076: LD_ADDR_EXP 168
109080: PUSH
109081: LD_INT 1
109083: ST_TO_ADDR
// if p3 = 17 then
109084: LD_VAR 0 3
109088: PUSH
109089: LD_INT 17
109091: EQUAL
109092: IFFALSE 109102
// sSlow := true ;
109094: LD_ADDR_EXP 169
109098: PUSH
109099: LD_INT 1
109101: ST_TO_ADDR
// if p3 = 18 then
109102: LD_VAR 0 3
109106: PUSH
109107: LD_INT 18
109109: EQUAL
109110: IFFALSE 109120
// sLack := true ;
109112: LD_ADDR_EXP 170
109116: PUSH
109117: LD_INT 1
109119: ST_TO_ADDR
// if p3 = 19 then
109120: LD_VAR 0 3
109124: PUSH
109125: LD_INT 19
109127: EQUAL
109128: IFFALSE 109138
// sTank := true ;
109130: LD_ADDR_EXP 172
109134: PUSH
109135: LD_INT 1
109137: ST_TO_ADDR
// if p3 = 20 then
109138: LD_VAR 0 3
109142: PUSH
109143: LD_INT 20
109145: EQUAL
109146: IFFALSE 109156
// sRemote := true ;
109148: LD_ADDR_EXP 173
109152: PUSH
109153: LD_INT 1
109155: ST_TO_ADDR
// if p3 = 21 then
109156: LD_VAR 0 3
109160: PUSH
109161: LD_INT 21
109163: EQUAL
109164: IFFALSE 109174
// sPowell := true ;
109166: LD_ADDR_EXP 174
109170: PUSH
109171: LD_INT 1
109173: ST_TO_ADDR
// if p3 = 22 then
109174: LD_VAR 0 3
109178: PUSH
109179: LD_INT 22
109181: EQUAL
109182: IFFALSE 109192
// sTeleport := true ;
109184: LD_ADDR_EXP 177
109188: PUSH
109189: LD_INT 1
109191: ST_TO_ADDR
// if p3 = 23 then
109192: LD_VAR 0 3
109196: PUSH
109197: LD_INT 23
109199: EQUAL
109200: IFFALSE 109210
// sOilTower := true ;
109202: LD_ADDR_EXP 179
109206: PUSH
109207: LD_INT 1
109209: ST_TO_ADDR
// if p3 = 24 then
109210: LD_VAR 0 3
109214: PUSH
109215: LD_INT 24
109217: EQUAL
109218: IFFALSE 109228
// sShovel := true ;
109220: LD_ADDR_EXP 180
109224: PUSH
109225: LD_INT 1
109227: ST_TO_ADDR
// if p3 = 25 then
109228: LD_VAR 0 3
109232: PUSH
109233: LD_INT 25
109235: EQUAL
109236: IFFALSE 109246
// sSheik := true ;
109238: LD_ADDR_EXP 181
109242: PUSH
109243: LD_INT 1
109245: ST_TO_ADDR
// if p3 = 26 then
109246: LD_VAR 0 3
109250: PUSH
109251: LD_INT 26
109253: EQUAL
109254: IFFALSE 109264
// sEarthquake := true ;
109256: LD_ADDR_EXP 183
109260: PUSH
109261: LD_INT 1
109263: ST_TO_ADDR
// if p3 = 27 then
109264: LD_VAR 0 3
109268: PUSH
109269: LD_INT 27
109271: EQUAL
109272: IFFALSE 109282
// sAI := true ;
109274: LD_ADDR_EXP 184
109278: PUSH
109279: LD_INT 1
109281: ST_TO_ADDR
// if p3 = 28 then
109282: LD_VAR 0 3
109286: PUSH
109287: LD_INT 28
109289: EQUAL
109290: IFFALSE 109300
// sCargo := true ;
109292: LD_ADDR_EXP 187
109296: PUSH
109297: LD_INT 1
109299: ST_TO_ADDR
// if p3 = 29 then
109300: LD_VAR 0 3
109304: PUSH
109305: LD_INT 29
109307: EQUAL
109308: IFFALSE 109318
// sDLaser := true ;
109310: LD_ADDR_EXP 188
109314: PUSH
109315: LD_INT 1
109317: ST_TO_ADDR
// if p3 = 30 then
109318: LD_VAR 0 3
109322: PUSH
109323: LD_INT 30
109325: EQUAL
109326: IFFALSE 109336
// sExchange := true ;
109328: LD_ADDR_EXP 189
109332: PUSH
109333: LD_INT 1
109335: ST_TO_ADDR
// if p3 = 31 then
109336: LD_VAR 0 3
109340: PUSH
109341: LD_INT 31
109343: EQUAL
109344: IFFALSE 109354
// sFac := true ;
109346: LD_ADDR_EXP 190
109350: PUSH
109351: LD_INT 1
109353: ST_TO_ADDR
// if p3 = 32 then
109354: LD_VAR 0 3
109358: PUSH
109359: LD_INT 32
109361: EQUAL
109362: IFFALSE 109372
// sPower := true ;
109364: LD_ADDR_EXP 191
109368: PUSH
109369: LD_INT 1
109371: ST_TO_ADDR
// if p3 = 33 then
109372: LD_VAR 0 3
109376: PUSH
109377: LD_INT 33
109379: EQUAL
109380: IFFALSE 109390
// sRandom := true ;
109382: LD_ADDR_EXP 192
109386: PUSH
109387: LD_INT 1
109389: ST_TO_ADDR
// if p3 = 34 then
109390: LD_VAR 0 3
109394: PUSH
109395: LD_INT 34
109397: EQUAL
109398: IFFALSE 109408
// sShield := true ;
109400: LD_ADDR_EXP 193
109404: PUSH
109405: LD_INT 1
109407: ST_TO_ADDR
// if p3 = 35 then
109408: LD_VAR 0 3
109412: PUSH
109413: LD_INT 35
109415: EQUAL
109416: IFFALSE 109426
// sTime := true ;
109418: LD_ADDR_EXP 194
109422: PUSH
109423: LD_INT 1
109425: ST_TO_ADDR
// if p3 = 36 then
109426: LD_VAR 0 3
109430: PUSH
109431: LD_INT 36
109433: EQUAL
109434: IFFALSE 109444
// sTools := true ;
109436: LD_ADDR_EXP 195
109440: PUSH
109441: LD_INT 1
109443: ST_TO_ADDR
// if p3 = 101 then
109444: LD_VAR 0 3
109448: PUSH
109449: LD_INT 101
109451: EQUAL
109452: IFFALSE 109462
// sSold := true ;
109454: LD_ADDR_EXP 160
109458: PUSH
109459: LD_INT 1
109461: ST_TO_ADDR
// if p3 = 102 then
109462: LD_VAR 0 3
109466: PUSH
109467: LD_INT 102
109469: EQUAL
109470: IFFALSE 109480
// sDiff := true ;
109472: LD_ADDR_EXP 161
109476: PUSH
109477: LD_INT 1
109479: ST_TO_ADDR
// if p3 = 103 then
109480: LD_VAR 0 3
109484: PUSH
109485: LD_INT 103
109487: EQUAL
109488: IFFALSE 109498
// sFog := true ;
109490: LD_ADDR_EXP 164
109494: PUSH
109495: LD_INT 1
109497: ST_TO_ADDR
// if p3 = 104 then
109498: LD_VAR 0 3
109502: PUSH
109503: LD_INT 104
109505: EQUAL
109506: IFFALSE 109516
// sReset := true ;
109508: LD_ADDR_EXP 165
109512: PUSH
109513: LD_INT 1
109515: ST_TO_ADDR
// if p3 = 105 then
109516: LD_VAR 0 3
109520: PUSH
109521: LD_INT 105
109523: EQUAL
109524: IFFALSE 109534
// sSun := true ;
109526: LD_ADDR_EXP 166
109530: PUSH
109531: LD_INT 1
109533: ST_TO_ADDR
// if p3 = 106 then
109534: LD_VAR 0 3
109538: PUSH
109539: LD_INT 106
109541: EQUAL
109542: IFFALSE 109552
// sTiger := true ;
109544: LD_ADDR_EXP 162
109548: PUSH
109549: LD_INT 1
109551: ST_TO_ADDR
// if p3 = 107 then
109552: LD_VAR 0 3
109556: PUSH
109557: LD_INT 107
109559: EQUAL
109560: IFFALSE 109570
// sBomb := true ;
109562: LD_ADDR_EXP 163
109566: PUSH
109567: LD_INT 1
109569: ST_TO_ADDR
// if p3 = 108 then
109570: LD_VAR 0 3
109574: PUSH
109575: LD_INT 108
109577: EQUAL
109578: IFFALSE 109588
// sWound := true ;
109580: LD_ADDR_EXP 171
109584: PUSH
109585: LD_INT 1
109587: ST_TO_ADDR
// if p3 = 109 then
109588: LD_VAR 0 3
109592: PUSH
109593: LD_INT 109
109595: EQUAL
109596: IFFALSE 109606
// sBetray := true ;
109598: LD_ADDR_EXP 175
109602: PUSH
109603: LD_INT 1
109605: ST_TO_ADDR
// if p3 = 110 then
109606: LD_VAR 0 3
109610: PUSH
109611: LD_INT 110
109613: EQUAL
109614: IFFALSE 109624
// sContamin := true ;
109616: LD_ADDR_EXP 176
109620: PUSH
109621: LD_INT 1
109623: ST_TO_ADDR
// if p3 = 111 then
109624: LD_VAR 0 3
109628: PUSH
109629: LD_INT 111
109631: EQUAL
109632: IFFALSE 109642
// sOil := true ;
109634: LD_ADDR_EXP 178
109638: PUSH
109639: LD_INT 1
109641: ST_TO_ADDR
// if p3 = 112 then
109642: LD_VAR 0 3
109646: PUSH
109647: LD_INT 112
109649: EQUAL
109650: IFFALSE 109660
// sStu := true ;
109652: LD_ADDR_EXP 182
109656: PUSH
109657: LD_INT 1
109659: ST_TO_ADDR
// if p3 = 113 then
109660: LD_VAR 0 3
109664: PUSH
109665: LD_INT 113
109667: EQUAL
109668: IFFALSE 109678
// sBazooka := true ;
109670: LD_ADDR_EXP 185
109674: PUSH
109675: LD_INT 1
109677: ST_TO_ADDR
// if p3 = 114 then
109678: LD_VAR 0 3
109682: PUSH
109683: LD_INT 114
109685: EQUAL
109686: IFFALSE 109696
// sMortar := true ;
109688: LD_ADDR_EXP 186
109692: PUSH
109693: LD_INT 1
109695: ST_TO_ADDR
// if p3 = 115 then
109696: LD_VAR 0 3
109700: PUSH
109701: LD_INT 115
109703: EQUAL
109704: IFFALSE 109714
// sRanger := true ;
109706: LD_ADDR_EXP 196
109710: PUSH
109711: LD_INT 1
109713: ST_TO_ADDR
// if p3 = 116 then
109714: LD_VAR 0 3
109718: PUSH
109719: LD_INT 116
109721: EQUAL
109722: IFFALSE 109732
// sComputer := true ;
109724: LD_ADDR_EXP 197
109728: PUSH
109729: LD_INT 1
109731: ST_TO_ADDR
// if p3 = 117 then
109732: LD_VAR 0 3
109736: PUSH
109737: LD_INT 117
109739: EQUAL
109740: IFFALSE 109750
// s30 := true ;
109742: LD_ADDR_EXP 198
109746: PUSH
109747: LD_INT 1
109749: ST_TO_ADDR
// if p3 = 118 then
109750: LD_VAR 0 3
109754: PUSH
109755: LD_INT 118
109757: EQUAL
109758: IFFALSE 109768
// s60 := true ;
109760: LD_ADDR_EXP 199
109764: PUSH
109765: LD_INT 1
109767: ST_TO_ADDR
// end ; if p2 = stream_mode then
109768: LD_VAR 0 2
109772: PUSH
109773: LD_INT 101
109775: EQUAL
109776: IFFALSE 109904
// begin case p3 of 1 :
109778: LD_VAR 0 3
109782: PUSH
109783: LD_INT 1
109785: DOUBLE
109786: EQUAL
109787: IFTRUE 109791
109789: GO 109798
109791: POP
// hHackUnlimitedResources ; 2 :
109792: CALL 122002 0 0
109796: GO 109904
109798: LD_INT 2
109800: DOUBLE
109801: EQUAL
109802: IFTRUE 109806
109804: GO 109813
109806: POP
// hHackSetLevel10 ; 3 :
109807: CALL 122135 0 0
109811: GO 109904
109813: LD_INT 3
109815: DOUBLE
109816: EQUAL
109817: IFTRUE 109821
109819: GO 109828
109821: POP
// hHackSetLevel10YourUnits ; 4 :
109822: CALL 122220 0 0
109826: GO 109904
109828: LD_INT 4
109830: DOUBLE
109831: EQUAL
109832: IFTRUE 109836
109834: GO 109843
109836: POP
// hHackInvincible ; 5 :
109837: CALL 122668 0 0
109841: GO 109904
109843: LD_INT 5
109845: DOUBLE
109846: EQUAL
109847: IFTRUE 109851
109849: GO 109858
109851: POP
// hHackInvisible ; 6 :
109852: CALL 122779 0 0
109856: GO 109904
109858: LD_INT 6
109860: DOUBLE
109861: EQUAL
109862: IFTRUE 109866
109864: GO 109873
109866: POP
// hHackChangeYourSide ; 7 :
109867: CALL 122836 0 0
109871: GO 109904
109873: LD_INT 7
109875: DOUBLE
109876: EQUAL
109877: IFTRUE 109881
109879: GO 109888
109881: POP
// hHackChangeUnitSide ; 8 :
109882: CALL 122878 0 0
109886: GO 109904
109888: LD_INT 8
109890: DOUBLE
109891: EQUAL
109892: IFTRUE 109896
109894: GO 109903
109896: POP
// hHackFog ; end ;
109897: CALL 122979 0 0
109901: GO 109904
109903: POP
// end ; end ;
109904: LD_VAR 0 7
109908: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
109909: GO 109911
109911: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
109912: LD_STRING initStreamRollete();
109914: PPUSH
109915: CALL_OW 559
// InitStreamMode ;
109919: CALL 109931 0 0
// DefineStreamItems ( false ) ;
109923: LD_INT 0
109925: PPUSH
109926: CALL 110395 0 1
// end ;
109930: END
// function InitStreamMode ; begin
109931: LD_INT 0
109933: PPUSH
// streamModeActive := false ;
109934: LD_ADDR_EXP 143
109938: PUSH
109939: LD_INT 0
109941: ST_TO_ADDR
// normalCounter := 36 ;
109942: LD_ADDR_EXP 144
109946: PUSH
109947: LD_INT 36
109949: ST_TO_ADDR
// hardcoreCounter := 18 ;
109950: LD_ADDR_EXP 145
109954: PUSH
109955: LD_INT 18
109957: ST_TO_ADDR
// sRocket := false ;
109958: LD_ADDR_EXP 148
109962: PUSH
109963: LD_INT 0
109965: ST_TO_ADDR
// sSpeed := false ;
109966: LD_ADDR_EXP 147
109970: PUSH
109971: LD_INT 0
109973: ST_TO_ADDR
// sEngine := false ;
109974: LD_ADDR_EXP 149
109978: PUSH
109979: LD_INT 0
109981: ST_TO_ADDR
// sSpec := false ;
109982: LD_ADDR_EXP 146
109986: PUSH
109987: LD_INT 0
109989: ST_TO_ADDR
// sLevel := false ;
109990: LD_ADDR_EXP 150
109994: PUSH
109995: LD_INT 0
109997: ST_TO_ADDR
// sArmoury := false ;
109998: LD_ADDR_EXP 151
110002: PUSH
110003: LD_INT 0
110005: ST_TO_ADDR
// sRadar := false ;
110006: LD_ADDR_EXP 152
110010: PUSH
110011: LD_INT 0
110013: ST_TO_ADDR
// sBunker := false ;
110014: LD_ADDR_EXP 153
110018: PUSH
110019: LD_INT 0
110021: ST_TO_ADDR
// sHack := false ;
110022: LD_ADDR_EXP 154
110026: PUSH
110027: LD_INT 0
110029: ST_TO_ADDR
// sFire := false ;
110030: LD_ADDR_EXP 155
110034: PUSH
110035: LD_INT 0
110037: ST_TO_ADDR
// sRefresh := false ;
110038: LD_ADDR_EXP 156
110042: PUSH
110043: LD_INT 0
110045: ST_TO_ADDR
// sExp := false ;
110046: LD_ADDR_EXP 157
110050: PUSH
110051: LD_INT 0
110053: ST_TO_ADDR
// sDepot := false ;
110054: LD_ADDR_EXP 158
110058: PUSH
110059: LD_INT 0
110061: ST_TO_ADDR
// sFlag := false ;
110062: LD_ADDR_EXP 159
110066: PUSH
110067: LD_INT 0
110069: ST_TO_ADDR
// sKamikadze := false ;
110070: LD_ADDR_EXP 167
110074: PUSH
110075: LD_INT 0
110077: ST_TO_ADDR
// sTroll := false ;
110078: LD_ADDR_EXP 168
110082: PUSH
110083: LD_INT 0
110085: ST_TO_ADDR
// sSlow := false ;
110086: LD_ADDR_EXP 169
110090: PUSH
110091: LD_INT 0
110093: ST_TO_ADDR
// sLack := false ;
110094: LD_ADDR_EXP 170
110098: PUSH
110099: LD_INT 0
110101: ST_TO_ADDR
// sTank := false ;
110102: LD_ADDR_EXP 172
110106: PUSH
110107: LD_INT 0
110109: ST_TO_ADDR
// sRemote := false ;
110110: LD_ADDR_EXP 173
110114: PUSH
110115: LD_INT 0
110117: ST_TO_ADDR
// sPowell := false ;
110118: LD_ADDR_EXP 174
110122: PUSH
110123: LD_INT 0
110125: ST_TO_ADDR
// sTeleport := false ;
110126: LD_ADDR_EXP 177
110130: PUSH
110131: LD_INT 0
110133: ST_TO_ADDR
// sOilTower := false ;
110134: LD_ADDR_EXP 179
110138: PUSH
110139: LD_INT 0
110141: ST_TO_ADDR
// sShovel := false ;
110142: LD_ADDR_EXP 180
110146: PUSH
110147: LD_INT 0
110149: ST_TO_ADDR
// sSheik := false ;
110150: LD_ADDR_EXP 181
110154: PUSH
110155: LD_INT 0
110157: ST_TO_ADDR
// sEarthquake := false ;
110158: LD_ADDR_EXP 183
110162: PUSH
110163: LD_INT 0
110165: ST_TO_ADDR
// sAI := false ;
110166: LD_ADDR_EXP 184
110170: PUSH
110171: LD_INT 0
110173: ST_TO_ADDR
// sCargo := false ;
110174: LD_ADDR_EXP 187
110178: PUSH
110179: LD_INT 0
110181: ST_TO_ADDR
// sDLaser := false ;
110182: LD_ADDR_EXP 188
110186: PUSH
110187: LD_INT 0
110189: ST_TO_ADDR
// sExchange := false ;
110190: LD_ADDR_EXP 189
110194: PUSH
110195: LD_INT 0
110197: ST_TO_ADDR
// sFac := false ;
110198: LD_ADDR_EXP 190
110202: PUSH
110203: LD_INT 0
110205: ST_TO_ADDR
// sPower := false ;
110206: LD_ADDR_EXP 191
110210: PUSH
110211: LD_INT 0
110213: ST_TO_ADDR
// sRandom := false ;
110214: LD_ADDR_EXP 192
110218: PUSH
110219: LD_INT 0
110221: ST_TO_ADDR
// sShield := false ;
110222: LD_ADDR_EXP 193
110226: PUSH
110227: LD_INT 0
110229: ST_TO_ADDR
// sTime := false ;
110230: LD_ADDR_EXP 194
110234: PUSH
110235: LD_INT 0
110237: ST_TO_ADDR
// sTools := false ;
110238: LD_ADDR_EXP 195
110242: PUSH
110243: LD_INT 0
110245: ST_TO_ADDR
// sSold := false ;
110246: LD_ADDR_EXP 160
110250: PUSH
110251: LD_INT 0
110253: ST_TO_ADDR
// sDiff := false ;
110254: LD_ADDR_EXP 161
110258: PUSH
110259: LD_INT 0
110261: ST_TO_ADDR
// sFog := false ;
110262: LD_ADDR_EXP 164
110266: PUSH
110267: LD_INT 0
110269: ST_TO_ADDR
// sReset := false ;
110270: LD_ADDR_EXP 165
110274: PUSH
110275: LD_INT 0
110277: ST_TO_ADDR
// sSun := false ;
110278: LD_ADDR_EXP 166
110282: PUSH
110283: LD_INT 0
110285: ST_TO_ADDR
// sTiger := false ;
110286: LD_ADDR_EXP 162
110290: PUSH
110291: LD_INT 0
110293: ST_TO_ADDR
// sBomb := false ;
110294: LD_ADDR_EXP 163
110298: PUSH
110299: LD_INT 0
110301: ST_TO_ADDR
// sWound := false ;
110302: LD_ADDR_EXP 171
110306: PUSH
110307: LD_INT 0
110309: ST_TO_ADDR
// sBetray := false ;
110310: LD_ADDR_EXP 175
110314: PUSH
110315: LD_INT 0
110317: ST_TO_ADDR
// sContamin := false ;
110318: LD_ADDR_EXP 176
110322: PUSH
110323: LD_INT 0
110325: ST_TO_ADDR
// sOil := false ;
110326: LD_ADDR_EXP 178
110330: PUSH
110331: LD_INT 0
110333: ST_TO_ADDR
// sStu := false ;
110334: LD_ADDR_EXP 182
110338: PUSH
110339: LD_INT 0
110341: ST_TO_ADDR
// sBazooka := false ;
110342: LD_ADDR_EXP 185
110346: PUSH
110347: LD_INT 0
110349: ST_TO_ADDR
// sMortar := false ;
110350: LD_ADDR_EXP 186
110354: PUSH
110355: LD_INT 0
110357: ST_TO_ADDR
// sRanger := false ;
110358: LD_ADDR_EXP 196
110362: PUSH
110363: LD_INT 0
110365: ST_TO_ADDR
// sComputer := false ;
110366: LD_ADDR_EXP 197
110370: PUSH
110371: LD_INT 0
110373: ST_TO_ADDR
// s30 := false ;
110374: LD_ADDR_EXP 198
110378: PUSH
110379: LD_INT 0
110381: ST_TO_ADDR
// s60 := false ;
110382: LD_ADDR_EXP 199
110386: PUSH
110387: LD_INT 0
110389: ST_TO_ADDR
// end ;
110390: LD_VAR 0 1
110394: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
110395: LD_INT 0
110397: PPUSH
110398: PPUSH
110399: PPUSH
110400: PPUSH
110401: PPUSH
110402: PPUSH
110403: PPUSH
// result := [ ] ;
110404: LD_ADDR_VAR 0 2
110408: PUSH
110409: EMPTY
110410: ST_TO_ADDR
// if campaign_id = 1 then
110411: LD_OWVAR 69
110415: PUSH
110416: LD_INT 1
110418: EQUAL
110419: IFFALSE 113585
// begin case mission_number of 1 :
110421: LD_OWVAR 70
110425: PUSH
110426: LD_INT 1
110428: DOUBLE
110429: EQUAL
110430: IFTRUE 110434
110432: GO 110510
110434: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
110435: LD_ADDR_VAR 0 2
110439: PUSH
110440: LD_INT 2
110442: PUSH
110443: LD_INT 4
110445: PUSH
110446: LD_INT 11
110448: PUSH
110449: LD_INT 12
110451: PUSH
110452: LD_INT 15
110454: PUSH
110455: LD_INT 16
110457: PUSH
110458: LD_INT 22
110460: PUSH
110461: LD_INT 23
110463: PUSH
110464: LD_INT 26
110466: PUSH
110467: EMPTY
110468: LIST
110469: LIST
110470: LIST
110471: LIST
110472: LIST
110473: LIST
110474: LIST
110475: LIST
110476: LIST
110477: PUSH
110478: LD_INT 101
110480: PUSH
110481: LD_INT 102
110483: PUSH
110484: LD_INT 106
110486: PUSH
110487: LD_INT 116
110489: PUSH
110490: LD_INT 117
110492: PUSH
110493: LD_INT 118
110495: PUSH
110496: EMPTY
110497: LIST
110498: LIST
110499: LIST
110500: LIST
110501: LIST
110502: LIST
110503: PUSH
110504: EMPTY
110505: LIST
110506: LIST
110507: ST_TO_ADDR
110508: GO 113583
110510: LD_INT 2
110512: DOUBLE
110513: EQUAL
110514: IFTRUE 110518
110516: GO 110602
110518: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
110519: LD_ADDR_VAR 0 2
110523: PUSH
110524: LD_INT 2
110526: PUSH
110527: LD_INT 4
110529: PUSH
110530: LD_INT 11
110532: PUSH
110533: LD_INT 12
110535: PUSH
110536: LD_INT 15
110538: PUSH
110539: LD_INT 16
110541: PUSH
110542: LD_INT 22
110544: PUSH
110545: LD_INT 23
110547: PUSH
110548: LD_INT 26
110550: PUSH
110551: EMPTY
110552: LIST
110553: LIST
110554: LIST
110555: LIST
110556: LIST
110557: LIST
110558: LIST
110559: LIST
110560: LIST
110561: PUSH
110562: LD_INT 101
110564: PUSH
110565: LD_INT 102
110567: PUSH
110568: LD_INT 105
110570: PUSH
110571: LD_INT 106
110573: PUSH
110574: LD_INT 108
110576: PUSH
110577: LD_INT 116
110579: PUSH
110580: LD_INT 117
110582: PUSH
110583: LD_INT 118
110585: PUSH
110586: EMPTY
110587: LIST
110588: LIST
110589: LIST
110590: LIST
110591: LIST
110592: LIST
110593: LIST
110594: LIST
110595: PUSH
110596: EMPTY
110597: LIST
110598: LIST
110599: ST_TO_ADDR
110600: GO 113583
110602: LD_INT 3
110604: DOUBLE
110605: EQUAL
110606: IFTRUE 110610
110608: GO 110698
110610: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
110611: LD_ADDR_VAR 0 2
110615: PUSH
110616: LD_INT 2
110618: PUSH
110619: LD_INT 4
110621: PUSH
110622: LD_INT 5
110624: PUSH
110625: LD_INT 11
110627: PUSH
110628: LD_INT 12
110630: PUSH
110631: LD_INT 15
110633: PUSH
110634: LD_INT 16
110636: PUSH
110637: LD_INT 22
110639: PUSH
110640: LD_INT 26
110642: PUSH
110643: LD_INT 36
110645: PUSH
110646: EMPTY
110647: LIST
110648: LIST
110649: LIST
110650: LIST
110651: LIST
110652: LIST
110653: LIST
110654: LIST
110655: LIST
110656: LIST
110657: PUSH
110658: LD_INT 101
110660: PUSH
110661: LD_INT 102
110663: PUSH
110664: LD_INT 105
110666: PUSH
110667: LD_INT 106
110669: PUSH
110670: LD_INT 108
110672: PUSH
110673: LD_INT 116
110675: PUSH
110676: LD_INT 117
110678: PUSH
110679: LD_INT 118
110681: PUSH
110682: EMPTY
110683: LIST
110684: LIST
110685: LIST
110686: LIST
110687: LIST
110688: LIST
110689: LIST
110690: LIST
110691: PUSH
110692: EMPTY
110693: LIST
110694: LIST
110695: ST_TO_ADDR
110696: GO 113583
110698: LD_INT 4
110700: DOUBLE
110701: EQUAL
110702: IFTRUE 110706
110704: GO 110802
110706: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
110707: LD_ADDR_VAR 0 2
110711: PUSH
110712: LD_INT 2
110714: PUSH
110715: LD_INT 4
110717: PUSH
110718: LD_INT 5
110720: PUSH
110721: LD_INT 8
110723: PUSH
110724: LD_INT 11
110726: PUSH
110727: LD_INT 12
110729: PUSH
110730: LD_INT 15
110732: PUSH
110733: LD_INT 16
110735: PUSH
110736: LD_INT 22
110738: PUSH
110739: LD_INT 23
110741: PUSH
110742: LD_INT 26
110744: PUSH
110745: LD_INT 36
110747: PUSH
110748: EMPTY
110749: LIST
110750: LIST
110751: LIST
110752: LIST
110753: LIST
110754: LIST
110755: LIST
110756: LIST
110757: LIST
110758: LIST
110759: LIST
110760: LIST
110761: PUSH
110762: LD_INT 101
110764: PUSH
110765: LD_INT 102
110767: PUSH
110768: LD_INT 105
110770: PUSH
110771: LD_INT 106
110773: PUSH
110774: LD_INT 108
110776: PUSH
110777: LD_INT 116
110779: PUSH
110780: LD_INT 117
110782: PUSH
110783: LD_INT 118
110785: PUSH
110786: EMPTY
110787: LIST
110788: LIST
110789: LIST
110790: LIST
110791: LIST
110792: LIST
110793: LIST
110794: LIST
110795: PUSH
110796: EMPTY
110797: LIST
110798: LIST
110799: ST_TO_ADDR
110800: GO 113583
110802: LD_INT 5
110804: DOUBLE
110805: EQUAL
110806: IFTRUE 110810
110808: GO 110922
110810: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
110811: LD_ADDR_VAR 0 2
110815: PUSH
110816: LD_INT 2
110818: PUSH
110819: LD_INT 4
110821: PUSH
110822: LD_INT 5
110824: PUSH
110825: LD_INT 6
110827: PUSH
110828: LD_INT 8
110830: PUSH
110831: LD_INT 11
110833: PUSH
110834: LD_INT 12
110836: PUSH
110837: LD_INT 15
110839: PUSH
110840: LD_INT 16
110842: PUSH
110843: LD_INT 22
110845: PUSH
110846: LD_INT 23
110848: PUSH
110849: LD_INT 25
110851: PUSH
110852: LD_INT 26
110854: PUSH
110855: LD_INT 36
110857: PUSH
110858: EMPTY
110859: LIST
110860: LIST
110861: LIST
110862: LIST
110863: LIST
110864: LIST
110865: LIST
110866: LIST
110867: LIST
110868: LIST
110869: LIST
110870: LIST
110871: LIST
110872: LIST
110873: PUSH
110874: LD_INT 101
110876: PUSH
110877: LD_INT 102
110879: PUSH
110880: LD_INT 105
110882: PUSH
110883: LD_INT 106
110885: PUSH
110886: LD_INT 108
110888: PUSH
110889: LD_INT 109
110891: PUSH
110892: LD_INT 112
110894: PUSH
110895: LD_INT 116
110897: PUSH
110898: LD_INT 117
110900: PUSH
110901: LD_INT 118
110903: PUSH
110904: EMPTY
110905: LIST
110906: LIST
110907: LIST
110908: LIST
110909: LIST
110910: LIST
110911: LIST
110912: LIST
110913: LIST
110914: LIST
110915: PUSH
110916: EMPTY
110917: LIST
110918: LIST
110919: ST_TO_ADDR
110920: GO 113583
110922: LD_INT 6
110924: DOUBLE
110925: EQUAL
110926: IFTRUE 110930
110928: GO 111062
110930: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
110931: LD_ADDR_VAR 0 2
110935: PUSH
110936: LD_INT 2
110938: PUSH
110939: LD_INT 4
110941: PUSH
110942: LD_INT 5
110944: PUSH
110945: LD_INT 6
110947: PUSH
110948: LD_INT 8
110950: PUSH
110951: LD_INT 11
110953: PUSH
110954: LD_INT 12
110956: PUSH
110957: LD_INT 15
110959: PUSH
110960: LD_INT 16
110962: PUSH
110963: LD_INT 20
110965: PUSH
110966: LD_INT 21
110968: PUSH
110969: LD_INT 22
110971: PUSH
110972: LD_INT 23
110974: PUSH
110975: LD_INT 25
110977: PUSH
110978: LD_INT 26
110980: PUSH
110981: LD_INT 30
110983: PUSH
110984: LD_INT 31
110986: PUSH
110987: LD_INT 32
110989: PUSH
110990: LD_INT 36
110992: PUSH
110993: EMPTY
110994: LIST
110995: LIST
110996: LIST
110997: LIST
110998: LIST
110999: LIST
111000: LIST
111001: LIST
111002: LIST
111003: LIST
111004: LIST
111005: LIST
111006: LIST
111007: LIST
111008: LIST
111009: LIST
111010: LIST
111011: LIST
111012: LIST
111013: PUSH
111014: LD_INT 101
111016: PUSH
111017: LD_INT 102
111019: PUSH
111020: LD_INT 105
111022: PUSH
111023: LD_INT 106
111025: PUSH
111026: LD_INT 108
111028: PUSH
111029: LD_INT 109
111031: PUSH
111032: LD_INT 112
111034: PUSH
111035: LD_INT 116
111037: PUSH
111038: LD_INT 117
111040: PUSH
111041: LD_INT 118
111043: PUSH
111044: EMPTY
111045: LIST
111046: LIST
111047: LIST
111048: LIST
111049: LIST
111050: LIST
111051: LIST
111052: LIST
111053: LIST
111054: LIST
111055: PUSH
111056: EMPTY
111057: LIST
111058: LIST
111059: ST_TO_ADDR
111060: GO 113583
111062: LD_INT 7
111064: DOUBLE
111065: EQUAL
111066: IFTRUE 111070
111068: GO 111182
111070: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
111071: LD_ADDR_VAR 0 2
111075: PUSH
111076: LD_INT 2
111078: PUSH
111079: LD_INT 4
111081: PUSH
111082: LD_INT 5
111084: PUSH
111085: LD_INT 7
111087: PUSH
111088: LD_INT 11
111090: PUSH
111091: LD_INT 12
111093: PUSH
111094: LD_INT 15
111096: PUSH
111097: LD_INT 16
111099: PUSH
111100: LD_INT 20
111102: PUSH
111103: LD_INT 21
111105: PUSH
111106: LD_INT 22
111108: PUSH
111109: LD_INT 23
111111: PUSH
111112: LD_INT 25
111114: PUSH
111115: LD_INT 26
111117: PUSH
111118: EMPTY
111119: LIST
111120: LIST
111121: LIST
111122: LIST
111123: LIST
111124: LIST
111125: LIST
111126: LIST
111127: LIST
111128: LIST
111129: LIST
111130: LIST
111131: LIST
111132: LIST
111133: PUSH
111134: LD_INT 101
111136: PUSH
111137: LD_INT 102
111139: PUSH
111140: LD_INT 103
111142: PUSH
111143: LD_INT 105
111145: PUSH
111146: LD_INT 106
111148: PUSH
111149: LD_INT 108
111151: PUSH
111152: LD_INT 112
111154: PUSH
111155: LD_INT 116
111157: PUSH
111158: LD_INT 117
111160: PUSH
111161: LD_INT 118
111163: PUSH
111164: EMPTY
111165: LIST
111166: LIST
111167: LIST
111168: LIST
111169: LIST
111170: LIST
111171: LIST
111172: LIST
111173: LIST
111174: LIST
111175: PUSH
111176: EMPTY
111177: LIST
111178: LIST
111179: ST_TO_ADDR
111180: GO 113583
111182: LD_INT 8
111184: DOUBLE
111185: EQUAL
111186: IFTRUE 111190
111188: GO 111330
111190: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
111191: LD_ADDR_VAR 0 2
111195: PUSH
111196: LD_INT 2
111198: PUSH
111199: LD_INT 4
111201: PUSH
111202: LD_INT 5
111204: PUSH
111205: LD_INT 6
111207: PUSH
111208: LD_INT 7
111210: PUSH
111211: LD_INT 8
111213: PUSH
111214: LD_INT 11
111216: PUSH
111217: LD_INT 12
111219: PUSH
111220: LD_INT 15
111222: PUSH
111223: LD_INT 16
111225: PUSH
111226: LD_INT 20
111228: PUSH
111229: LD_INT 21
111231: PUSH
111232: LD_INT 22
111234: PUSH
111235: LD_INT 23
111237: PUSH
111238: LD_INT 25
111240: PUSH
111241: LD_INT 26
111243: PUSH
111244: LD_INT 30
111246: PUSH
111247: LD_INT 31
111249: PUSH
111250: LD_INT 32
111252: PUSH
111253: LD_INT 36
111255: PUSH
111256: EMPTY
111257: LIST
111258: LIST
111259: LIST
111260: LIST
111261: LIST
111262: LIST
111263: LIST
111264: LIST
111265: LIST
111266: LIST
111267: LIST
111268: LIST
111269: LIST
111270: LIST
111271: LIST
111272: LIST
111273: LIST
111274: LIST
111275: LIST
111276: LIST
111277: PUSH
111278: LD_INT 101
111280: PUSH
111281: LD_INT 102
111283: PUSH
111284: LD_INT 103
111286: PUSH
111287: LD_INT 105
111289: PUSH
111290: LD_INT 106
111292: PUSH
111293: LD_INT 108
111295: PUSH
111296: LD_INT 109
111298: PUSH
111299: LD_INT 112
111301: PUSH
111302: LD_INT 116
111304: PUSH
111305: LD_INT 117
111307: PUSH
111308: LD_INT 118
111310: PUSH
111311: EMPTY
111312: LIST
111313: LIST
111314: LIST
111315: LIST
111316: LIST
111317: LIST
111318: LIST
111319: LIST
111320: LIST
111321: LIST
111322: LIST
111323: PUSH
111324: EMPTY
111325: LIST
111326: LIST
111327: ST_TO_ADDR
111328: GO 113583
111330: LD_INT 9
111332: DOUBLE
111333: EQUAL
111334: IFTRUE 111338
111336: GO 111486
111338: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
111339: LD_ADDR_VAR 0 2
111343: PUSH
111344: LD_INT 2
111346: PUSH
111347: LD_INT 4
111349: PUSH
111350: LD_INT 5
111352: PUSH
111353: LD_INT 6
111355: PUSH
111356: LD_INT 7
111358: PUSH
111359: LD_INT 8
111361: PUSH
111362: LD_INT 11
111364: PUSH
111365: LD_INT 12
111367: PUSH
111368: LD_INT 15
111370: PUSH
111371: LD_INT 16
111373: PUSH
111374: LD_INT 20
111376: PUSH
111377: LD_INT 21
111379: PUSH
111380: LD_INT 22
111382: PUSH
111383: LD_INT 23
111385: PUSH
111386: LD_INT 25
111388: PUSH
111389: LD_INT 26
111391: PUSH
111392: LD_INT 28
111394: PUSH
111395: LD_INT 30
111397: PUSH
111398: LD_INT 31
111400: PUSH
111401: LD_INT 32
111403: PUSH
111404: LD_INT 36
111406: PUSH
111407: EMPTY
111408: LIST
111409: LIST
111410: LIST
111411: LIST
111412: LIST
111413: LIST
111414: LIST
111415: LIST
111416: LIST
111417: LIST
111418: LIST
111419: LIST
111420: LIST
111421: LIST
111422: LIST
111423: LIST
111424: LIST
111425: LIST
111426: LIST
111427: LIST
111428: LIST
111429: PUSH
111430: LD_INT 101
111432: PUSH
111433: LD_INT 102
111435: PUSH
111436: LD_INT 103
111438: PUSH
111439: LD_INT 105
111441: PUSH
111442: LD_INT 106
111444: PUSH
111445: LD_INT 108
111447: PUSH
111448: LD_INT 109
111450: PUSH
111451: LD_INT 112
111453: PUSH
111454: LD_INT 114
111456: PUSH
111457: LD_INT 116
111459: PUSH
111460: LD_INT 117
111462: PUSH
111463: LD_INT 118
111465: PUSH
111466: EMPTY
111467: LIST
111468: LIST
111469: LIST
111470: LIST
111471: LIST
111472: LIST
111473: LIST
111474: LIST
111475: LIST
111476: LIST
111477: LIST
111478: LIST
111479: PUSH
111480: EMPTY
111481: LIST
111482: LIST
111483: ST_TO_ADDR
111484: GO 113583
111486: LD_INT 10
111488: DOUBLE
111489: EQUAL
111490: IFTRUE 111494
111492: GO 111690
111494: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
111495: LD_ADDR_VAR 0 2
111499: PUSH
111500: LD_INT 2
111502: PUSH
111503: LD_INT 4
111505: PUSH
111506: LD_INT 5
111508: PUSH
111509: LD_INT 6
111511: PUSH
111512: LD_INT 7
111514: PUSH
111515: LD_INT 8
111517: PUSH
111518: LD_INT 9
111520: PUSH
111521: LD_INT 10
111523: PUSH
111524: LD_INT 11
111526: PUSH
111527: LD_INT 12
111529: PUSH
111530: LD_INT 13
111532: PUSH
111533: LD_INT 14
111535: PUSH
111536: LD_INT 15
111538: PUSH
111539: LD_INT 16
111541: PUSH
111542: LD_INT 17
111544: PUSH
111545: LD_INT 18
111547: PUSH
111548: LD_INT 19
111550: PUSH
111551: LD_INT 20
111553: PUSH
111554: LD_INT 21
111556: PUSH
111557: LD_INT 22
111559: PUSH
111560: LD_INT 23
111562: PUSH
111563: LD_INT 24
111565: PUSH
111566: LD_INT 25
111568: PUSH
111569: LD_INT 26
111571: PUSH
111572: LD_INT 28
111574: PUSH
111575: LD_INT 30
111577: PUSH
111578: LD_INT 31
111580: PUSH
111581: LD_INT 32
111583: PUSH
111584: LD_INT 36
111586: PUSH
111587: EMPTY
111588: LIST
111589: LIST
111590: LIST
111591: LIST
111592: LIST
111593: LIST
111594: LIST
111595: LIST
111596: LIST
111597: LIST
111598: LIST
111599: LIST
111600: LIST
111601: LIST
111602: LIST
111603: LIST
111604: LIST
111605: LIST
111606: LIST
111607: LIST
111608: LIST
111609: LIST
111610: LIST
111611: LIST
111612: LIST
111613: LIST
111614: LIST
111615: LIST
111616: LIST
111617: PUSH
111618: LD_INT 101
111620: PUSH
111621: LD_INT 102
111623: PUSH
111624: LD_INT 103
111626: PUSH
111627: LD_INT 104
111629: PUSH
111630: LD_INT 105
111632: PUSH
111633: LD_INT 106
111635: PUSH
111636: LD_INT 107
111638: PUSH
111639: LD_INT 108
111641: PUSH
111642: LD_INT 109
111644: PUSH
111645: LD_INT 110
111647: PUSH
111648: LD_INT 111
111650: PUSH
111651: LD_INT 112
111653: PUSH
111654: LD_INT 114
111656: PUSH
111657: LD_INT 116
111659: PUSH
111660: LD_INT 117
111662: PUSH
111663: LD_INT 118
111665: PUSH
111666: EMPTY
111667: LIST
111668: LIST
111669: LIST
111670: LIST
111671: LIST
111672: LIST
111673: LIST
111674: LIST
111675: LIST
111676: LIST
111677: LIST
111678: LIST
111679: LIST
111680: LIST
111681: LIST
111682: LIST
111683: PUSH
111684: EMPTY
111685: LIST
111686: LIST
111687: ST_TO_ADDR
111688: GO 113583
111690: LD_INT 11
111692: DOUBLE
111693: EQUAL
111694: IFTRUE 111698
111696: GO 111902
111698: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
111699: LD_ADDR_VAR 0 2
111703: PUSH
111704: LD_INT 2
111706: PUSH
111707: LD_INT 3
111709: PUSH
111710: LD_INT 4
111712: PUSH
111713: LD_INT 5
111715: PUSH
111716: LD_INT 6
111718: PUSH
111719: LD_INT 7
111721: PUSH
111722: LD_INT 8
111724: PUSH
111725: LD_INT 9
111727: PUSH
111728: LD_INT 10
111730: PUSH
111731: LD_INT 11
111733: PUSH
111734: LD_INT 12
111736: PUSH
111737: LD_INT 13
111739: PUSH
111740: LD_INT 14
111742: PUSH
111743: LD_INT 15
111745: PUSH
111746: LD_INT 16
111748: PUSH
111749: LD_INT 17
111751: PUSH
111752: LD_INT 18
111754: PUSH
111755: LD_INT 19
111757: PUSH
111758: LD_INT 20
111760: PUSH
111761: LD_INT 21
111763: PUSH
111764: LD_INT 22
111766: PUSH
111767: LD_INT 23
111769: PUSH
111770: LD_INT 24
111772: PUSH
111773: LD_INT 25
111775: PUSH
111776: LD_INT 26
111778: PUSH
111779: LD_INT 28
111781: PUSH
111782: LD_INT 30
111784: PUSH
111785: LD_INT 31
111787: PUSH
111788: LD_INT 32
111790: PUSH
111791: LD_INT 34
111793: PUSH
111794: LD_INT 36
111796: PUSH
111797: EMPTY
111798: LIST
111799: LIST
111800: LIST
111801: LIST
111802: LIST
111803: LIST
111804: LIST
111805: LIST
111806: LIST
111807: LIST
111808: LIST
111809: LIST
111810: LIST
111811: LIST
111812: LIST
111813: LIST
111814: LIST
111815: LIST
111816: LIST
111817: LIST
111818: LIST
111819: LIST
111820: LIST
111821: LIST
111822: LIST
111823: LIST
111824: LIST
111825: LIST
111826: LIST
111827: LIST
111828: LIST
111829: PUSH
111830: LD_INT 101
111832: PUSH
111833: LD_INT 102
111835: PUSH
111836: LD_INT 103
111838: PUSH
111839: LD_INT 104
111841: PUSH
111842: LD_INT 105
111844: PUSH
111845: LD_INT 106
111847: PUSH
111848: LD_INT 107
111850: PUSH
111851: LD_INT 108
111853: PUSH
111854: LD_INT 109
111856: PUSH
111857: LD_INT 110
111859: PUSH
111860: LD_INT 111
111862: PUSH
111863: LD_INT 112
111865: PUSH
111866: LD_INT 114
111868: PUSH
111869: LD_INT 116
111871: PUSH
111872: LD_INT 117
111874: PUSH
111875: LD_INT 118
111877: PUSH
111878: EMPTY
111879: LIST
111880: LIST
111881: LIST
111882: LIST
111883: LIST
111884: LIST
111885: LIST
111886: LIST
111887: LIST
111888: LIST
111889: LIST
111890: LIST
111891: LIST
111892: LIST
111893: LIST
111894: LIST
111895: PUSH
111896: EMPTY
111897: LIST
111898: LIST
111899: ST_TO_ADDR
111900: GO 113583
111902: LD_INT 12
111904: DOUBLE
111905: EQUAL
111906: IFTRUE 111910
111908: GO 112130
111910: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
111911: LD_ADDR_VAR 0 2
111915: PUSH
111916: LD_INT 1
111918: PUSH
111919: LD_INT 2
111921: PUSH
111922: LD_INT 3
111924: PUSH
111925: LD_INT 4
111927: PUSH
111928: LD_INT 5
111930: PUSH
111931: LD_INT 6
111933: PUSH
111934: LD_INT 7
111936: PUSH
111937: LD_INT 8
111939: PUSH
111940: LD_INT 9
111942: PUSH
111943: LD_INT 10
111945: PUSH
111946: LD_INT 11
111948: PUSH
111949: LD_INT 12
111951: PUSH
111952: LD_INT 13
111954: PUSH
111955: LD_INT 14
111957: PUSH
111958: LD_INT 15
111960: PUSH
111961: LD_INT 16
111963: PUSH
111964: LD_INT 17
111966: PUSH
111967: LD_INT 18
111969: PUSH
111970: LD_INT 19
111972: PUSH
111973: LD_INT 20
111975: PUSH
111976: LD_INT 21
111978: PUSH
111979: LD_INT 22
111981: PUSH
111982: LD_INT 23
111984: PUSH
111985: LD_INT 24
111987: PUSH
111988: LD_INT 25
111990: PUSH
111991: LD_INT 26
111993: PUSH
111994: LD_INT 27
111996: PUSH
111997: LD_INT 28
111999: PUSH
112000: LD_INT 30
112002: PUSH
112003: LD_INT 31
112005: PUSH
112006: LD_INT 32
112008: PUSH
112009: LD_INT 33
112011: PUSH
112012: LD_INT 34
112014: PUSH
112015: LD_INT 36
112017: PUSH
112018: EMPTY
112019: LIST
112020: LIST
112021: LIST
112022: LIST
112023: LIST
112024: LIST
112025: LIST
112026: LIST
112027: LIST
112028: LIST
112029: LIST
112030: LIST
112031: LIST
112032: LIST
112033: LIST
112034: LIST
112035: LIST
112036: LIST
112037: LIST
112038: LIST
112039: LIST
112040: LIST
112041: LIST
112042: LIST
112043: LIST
112044: LIST
112045: LIST
112046: LIST
112047: LIST
112048: LIST
112049: LIST
112050: LIST
112051: LIST
112052: LIST
112053: PUSH
112054: LD_INT 101
112056: PUSH
112057: LD_INT 102
112059: PUSH
112060: LD_INT 103
112062: PUSH
112063: LD_INT 104
112065: PUSH
112066: LD_INT 105
112068: PUSH
112069: LD_INT 106
112071: PUSH
112072: LD_INT 107
112074: PUSH
112075: LD_INT 108
112077: PUSH
112078: LD_INT 109
112080: PUSH
112081: LD_INT 110
112083: PUSH
112084: LD_INT 111
112086: PUSH
112087: LD_INT 112
112089: PUSH
112090: LD_INT 113
112092: PUSH
112093: LD_INT 114
112095: PUSH
112096: LD_INT 116
112098: PUSH
112099: LD_INT 117
112101: PUSH
112102: LD_INT 118
112104: PUSH
112105: EMPTY
112106: LIST
112107: LIST
112108: LIST
112109: LIST
112110: LIST
112111: LIST
112112: LIST
112113: LIST
112114: LIST
112115: LIST
112116: LIST
112117: LIST
112118: LIST
112119: LIST
112120: LIST
112121: LIST
112122: LIST
112123: PUSH
112124: EMPTY
112125: LIST
112126: LIST
112127: ST_TO_ADDR
112128: GO 113583
112130: LD_INT 13
112132: DOUBLE
112133: EQUAL
112134: IFTRUE 112138
112136: GO 112346
112138: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
112139: LD_ADDR_VAR 0 2
112143: PUSH
112144: LD_INT 1
112146: PUSH
112147: LD_INT 2
112149: PUSH
112150: LD_INT 3
112152: PUSH
112153: LD_INT 4
112155: PUSH
112156: LD_INT 5
112158: PUSH
112159: LD_INT 8
112161: PUSH
112162: LD_INT 9
112164: PUSH
112165: LD_INT 10
112167: PUSH
112168: LD_INT 11
112170: PUSH
112171: LD_INT 12
112173: PUSH
112174: LD_INT 14
112176: PUSH
112177: LD_INT 15
112179: PUSH
112180: LD_INT 16
112182: PUSH
112183: LD_INT 17
112185: PUSH
112186: LD_INT 18
112188: PUSH
112189: LD_INT 19
112191: PUSH
112192: LD_INT 20
112194: PUSH
112195: LD_INT 21
112197: PUSH
112198: LD_INT 22
112200: PUSH
112201: LD_INT 23
112203: PUSH
112204: LD_INT 24
112206: PUSH
112207: LD_INT 25
112209: PUSH
112210: LD_INT 26
112212: PUSH
112213: LD_INT 27
112215: PUSH
112216: LD_INT 28
112218: PUSH
112219: LD_INT 30
112221: PUSH
112222: LD_INT 31
112224: PUSH
112225: LD_INT 32
112227: PUSH
112228: LD_INT 33
112230: PUSH
112231: LD_INT 34
112233: PUSH
112234: LD_INT 36
112236: PUSH
112237: EMPTY
112238: LIST
112239: LIST
112240: LIST
112241: LIST
112242: LIST
112243: LIST
112244: LIST
112245: LIST
112246: LIST
112247: LIST
112248: LIST
112249: LIST
112250: LIST
112251: LIST
112252: LIST
112253: LIST
112254: LIST
112255: LIST
112256: LIST
112257: LIST
112258: LIST
112259: LIST
112260: LIST
112261: LIST
112262: LIST
112263: LIST
112264: LIST
112265: LIST
112266: LIST
112267: LIST
112268: LIST
112269: PUSH
112270: LD_INT 101
112272: PUSH
112273: LD_INT 102
112275: PUSH
112276: LD_INT 103
112278: PUSH
112279: LD_INT 104
112281: PUSH
112282: LD_INT 105
112284: PUSH
112285: LD_INT 106
112287: PUSH
112288: LD_INT 107
112290: PUSH
112291: LD_INT 108
112293: PUSH
112294: LD_INT 109
112296: PUSH
112297: LD_INT 110
112299: PUSH
112300: LD_INT 111
112302: PUSH
112303: LD_INT 112
112305: PUSH
112306: LD_INT 113
112308: PUSH
112309: LD_INT 114
112311: PUSH
112312: LD_INT 116
112314: PUSH
112315: LD_INT 117
112317: PUSH
112318: LD_INT 118
112320: PUSH
112321: EMPTY
112322: LIST
112323: LIST
112324: LIST
112325: LIST
112326: LIST
112327: LIST
112328: LIST
112329: LIST
112330: LIST
112331: LIST
112332: LIST
112333: LIST
112334: LIST
112335: LIST
112336: LIST
112337: LIST
112338: LIST
112339: PUSH
112340: EMPTY
112341: LIST
112342: LIST
112343: ST_TO_ADDR
112344: GO 113583
112346: LD_INT 14
112348: DOUBLE
112349: EQUAL
112350: IFTRUE 112354
112352: GO 112578
112354: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
112355: LD_ADDR_VAR 0 2
112359: PUSH
112360: LD_INT 1
112362: PUSH
112363: LD_INT 2
112365: PUSH
112366: LD_INT 3
112368: PUSH
112369: LD_INT 4
112371: PUSH
112372: LD_INT 5
112374: PUSH
112375: LD_INT 6
112377: PUSH
112378: LD_INT 7
112380: PUSH
112381: LD_INT 8
112383: PUSH
112384: LD_INT 9
112386: PUSH
112387: LD_INT 10
112389: PUSH
112390: LD_INT 11
112392: PUSH
112393: LD_INT 12
112395: PUSH
112396: LD_INT 13
112398: PUSH
112399: LD_INT 14
112401: PUSH
112402: LD_INT 15
112404: PUSH
112405: LD_INT 16
112407: PUSH
112408: LD_INT 17
112410: PUSH
112411: LD_INT 18
112413: PUSH
112414: LD_INT 19
112416: PUSH
112417: LD_INT 20
112419: PUSH
112420: LD_INT 21
112422: PUSH
112423: LD_INT 22
112425: PUSH
112426: LD_INT 23
112428: PUSH
112429: LD_INT 24
112431: PUSH
112432: LD_INT 25
112434: PUSH
112435: LD_INT 26
112437: PUSH
112438: LD_INT 27
112440: PUSH
112441: LD_INT 28
112443: PUSH
112444: LD_INT 29
112446: PUSH
112447: LD_INT 30
112449: PUSH
112450: LD_INT 31
112452: PUSH
112453: LD_INT 32
112455: PUSH
112456: LD_INT 33
112458: PUSH
112459: LD_INT 34
112461: PUSH
112462: LD_INT 36
112464: PUSH
112465: EMPTY
112466: LIST
112467: LIST
112468: LIST
112469: LIST
112470: LIST
112471: LIST
112472: LIST
112473: LIST
112474: LIST
112475: LIST
112476: LIST
112477: LIST
112478: LIST
112479: LIST
112480: LIST
112481: LIST
112482: LIST
112483: LIST
112484: LIST
112485: LIST
112486: LIST
112487: LIST
112488: LIST
112489: LIST
112490: LIST
112491: LIST
112492: LIST
112493: LIST
112494: LIST
112495: LIST
112496: LIST
112497: LIST
112498: LIST
112499: LIST
112500: LIST
112501: PUSH
112502: LD_INT 101
112504: PUSH
112505: LD_INT 102
112507: PUSH
112508: LD_INT 103
112510: PUSH
112511: LD_INT 104
112513: PUSH
112514: LD_INT 105
112516: PUSH
112517: LD_INT 106
112519: PUSH
112520: LD_INT 107
112522: PUSH
112523: LD_INT 108
112525: PUSH
112526: LD_INT 109
112528: PUSH
112529: LD_INT 110
112531: PUSH
112532: LD_INT 111
112534: PUSH
112535: LD_INT 112
112537: PUSH
112538: LD_INT 113
112540: PUSH
112541: LD_INT 114
112543: PUSH
112544: LD_INT 116
112546: PUSH
112547: LD_INT 117
112549: PUSH
112550: LD_INT 118
112552: PUSH
112553: EMPTY
112554: LIST
112555: LIST
112556: LIST
112557: LIST
112558: LIST
112559: LIST
112560: LIST
112561: LIST
112562: LIST
112563: LIST
112564: LIST
112565: LIST
112566: LIST
112567: LIST
112568: LIST
112569: LIST
112570: LIST
112571: PUSH
112572: EMPTY
112573: LIST
112574: LIST
112575: ST_TO_ADDR
112576: GO 113583
112578: LD_INT 15
112580: DOUBLE
112581: EQUAL
112582: IFTRUE 112586
112584: GO 112810
112586: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
112587: LD_ADDR_VAR 0 2
112591: PUSH
112592: LD_INT 1
112594: PUSH
112595: LD_INT 2
112597: PUSH
112598: LD_INT 3
112600: PUSH
112601: LD_INT 4
112603: PUSH
112604: LD_INT 5
112606: PUSH
112607: LD_INT 6
112609: PUSH
112610: LD_INT 7
112612: PUSH
112613: LD_INT 8
112615: PUSH
112616: LD_INT 9
112618: PUSH
112619: LD_INT 10
112621: PUSH
112622: LD_INT 11
112624: PUSH
112625: LD_INT 12
112627: PUSH
112628: LD_INT 13
112630: PUSH
112631: LD_INT 14
112633: PUSH
112634: LD_INT 15
112636: PUSH
112637: LD_INT 16
112639: PUSH
112640: LD_INT 17
112642: PUSH
112643: LD_INT 18
112645: PUSH
112646: LD_INT 19
112648: PUSH
112649: LD_INT 20
112651: PUSH
112652: LD_INT 21
112654: PUSH
112655: LD_INT 22
112657: PUSH
112658: LD_INT 23
112660: PUSH
112661: LD_INT 24
112663: PUSH
112664: LD_INT 25
112666: PUSH
112667: LD_INT 26
112669: PUSH
112670: LD_INT 27
112672: PUSH
112673: LD_INT 28
112675: PUSH
112676: LD_INT 29
112678: PUSH
112679: LD_INT 30
112681: PUSH
112682: LD_INT 31
112684: PUSH
112685: LD_INT 32
112687: PUSH
112688: LD_INT 33
112690: PUSH
112691: LD_INT 34
112693: PUSH
112694: LD_INT 36
112696: PUSH
112697: EMPTY
112698: LIST
112699: LIST
112700: LIST
112701: LIST
112702: LIST
112703: LIST
112704: LIST
112705: LIST
112706: LIST
112707: LIST
112708: LIST
112709: LIST
112710: LIST
112711: LIST
112712: LIST
112713: LIST
112714: LIST
112715: LIST
112716: LIST
112717: LIST
112718: LIST
112719: LIST
112720: LIST
112721: LIST
112722: LIST
112723: LIST
112724: LIST
112725: LIST
112726: LIST
112727: LIST
112728: LIST
112729: LIST
112730: LIST
112731: LIST
112732: LIST
112733: PUSH
112734: LD_INT 101
112736: PUSH
112737: LD_INT 102
112739: PUSH
112740: LD_INT 103
112742: PUSH
112743: LD_INT 104
112745: PUSH
112746: LD_INT 105
112748: PUSH
112749: LD_INT 106
112751: PUSH
112752: LD_INT 107
112754: PUSH
112755: LD_INT 108
112757: PUSH
112758: LD_INT 109
112760: PUSH
112761: LD_INT 110
112763: PUSH
112764: LD_INT 111
112766: PUSH
112767: LD_INT 112
112769: PUSH
112770: LD_INT 113
112772: PUSH
112773: LD_INT 114
112775: PUSH
112776: LD_INT 116
112778: PUSH
112779: LD_INT 117
112781: PUSH
112782: LD_INT 118
112784: PUSH
112785: EMPTY
112786: LIST
112787: LIST
112788: LIST
112789: LIST
112790: LIST
112791: LIST
112792: LIST
112793: LIST
112794: LIST
112795: LIST
112796: LIST
112797: LIST
112798: LIST
112799: LIST
112800: LIST
112801: LIST
112802: LIST
112803: PUSH
112804: EMPTY
112805: LIST
112806: LIST
112807: ST_TO_ADDR
112808: GO 113583
112810: LD_INT 16
112812: DOUBLE
112813: EQUAL
112814: IFTRUE 112818
112816: GO 112954
112818: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
112819: LD_ADDR_VAR 0 2
112823: PUSH
112824: LD_INT 2
112826: PUSH
112827: LD_INT 4
112829: PUSH
112830: LD_INT 5
112832: PUSH
112833: LD_INT 7
112835: PUSH
112836: LD_INT 11
112838: PUSH
112839: LD_INT 12
112841: PUSH
112842: LD_INT 15
112844: PUSH
112845: LD_INT 16
112847: PUSH
112848: LD_INT 20
112850: PUSH
112851: LD_INT 21
112853: PUSH
112854: LD_INT 22
112856: PUSH
112857: LD_INT 23
112859: PUSH
112860: LD_INT 25
112862: PUSH
112863: LD_INT 26
112865: PUSH
112866: LD_INT 30
112868: PUSH
112869: LD_INT 31
112871: PUSH
112872: LD_INT 32
112874: PUSH
112875: LD_INT 33
112877: PUSH
112878: LD_INT 34
112880: PUSH
112881: EMPTY
112882: LIST
112883: LIST
112884: LIST
112885: LIST
112886: LIST
112887: LIST
112888: LIST
112889: LIST
112890: LIST
112891: LIST
112892: LIST
112893: LIST
112894: LIST
112895: LIST
112896: LIST
112897: LIST
112898: LIST
112899: LIST
112900: LIST
112901: PUSH
112902: LD_INT 101
112904: PUSH
112905: LD_INT 102
112907: PUSH
112908: LD_INT 103
112910: PUSH
112911: LD_INT 106
112913: PUSH
112914: LD_INT 108
112916: PUSH
112917: LD_INT 112
112919: PUSH
112920: LD_INT 113
112922: PUSH
112923: LD_INT 114
112925: PUSH
112926: LD_INT 116
112928: PUSH
112929: LD_INT 117
112931: PUSH
112932: LD_INT 118
112934: PUSH
112935: EMPTY
112936: LIST
112937: LIST
112938: LIST
112939: LIST
112940: LIST
112941: LIST
112942: LIST
112943: LIST
112944: LIST
112945: LIST
112946: LIST
112947: PUSH
112948: EMPTY
112949: LIST
112950: LIST
112951: ST_TO_ADDR
112952: GO 113583
112954: LD_INT 17
112956: DOUBLE
112957: EQUAL
112958: IFTRUE 112962
112960: GO 113186
112962: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
112963: LD_ADDR_VAR 0 2
112967: PUSH
112968: LD_INT 1
112970: PUSH
112971: LD_INT 2
112973: PUSH
112974: LD_INT 3
112976: PUSH
112977: LD_INT 4
112979: PUSH
112980: LD_INT 5
112982: PUSH
112983: LD_INT 6
112985: PUSH
112986: LD_INT 7
112988: PUSH
112989: LD_INT 8
112991: PUSH
112992: LD_INT 9
112994: PUSH
112995: LD_INT 10
112997: PUSH
112998: LD_INT 11
113000: PUSH
113001: LD_INT 12
113003: PUSH
113004: LD_INT 13
113006: PUSH
113007: LD_INT 14
113009: PUSH
113010: LD_INT 15
113012: PUSH
113013: LD_INT 16
113015: PUSH
113016: LD_INT 17
113018: PUSH
113019: LD_INT 18
113021: PUSH
113022: LD_INT 19
113024: PUSH
113025: LD_INT 20
113027: PUSH
113028: LD_INT 21
113030: PUSH
113031: LD_INT 22
113033: PUSH
113034: LD_INT 23
113036: PUSH
113037: LD_INT 24
113039: PUSH
113040: LD_INT 25
113042: PUSH
113043: LD_INT 26
113045: PUSH
113046: LD_INT 27
113048: PUSH
113049: LD_INT 28
113051: PUSH
113052: LD_INT 29
113054: PUSH
113055: LD_INT 30
113057: PUSH
113058: LD_INT 31
113060: PUSH
113061: LD_INT 32
113063: PUSH
113064: LD_INT 33
113066: PUSH
113067: LD_INT 34
113069: PUSH
113070: LD_INT 36
113072: PUSH
113073: EMPTY
113074: LIST
113075: LIST
113076: LIST
113077: LIST
113078: LIST
113079: LIST
113080: LIST
113081: LIST
113082: LIST
113083: LIST
113084: LIST
113085: LIST
113086: LIST
113087: LIST
113088: LIST
113089: LIST
113090: LIST
113091: LIST
113092: LIST
113093: LIST
113094: LIST
113095: LIST
113096: LIST
113097: LIST
113098: LIST
113099: LIST
113100: LIST
113101: LIST
113102: LIST
113103: LIST
113104: LIST
113105: LIST
113106: LIST
113107: LIST
113108: LIST
113109: PUSH
113110: LD_INT 101
113112: PUSH
113113: LD_INT 102
113115: PUSH
113116: LD_INT 103
113118: PUSH
113119: LD_INT 104
113121: PUSH
113122: LD_INT 105
113124: PUSH
113125: LD_INT 106
113127: PUSH
113128: LD_INT 107
113130: PUSH
113131: LD_INT 108
113133: PUSH
113134: LD_INT 109
113136: PUSH
113137: LD_INT 110
113139: PUSH
113140: LD_INT 111
113142: PUSH
113143: LD_INT 112
113145: PUSH
113146: LD_INT 113
113148: PUSH
113149: LD_INT 114
113151: PUSH
113152: LD_INT 116
113154: PUSH
113155: LD_INT 117
113157: PUSH
113158: LD_INT 118
113160: PUSH
113161: EMPTY
113162: LIST
113163: LIST
113164: LIST
113165: LIST
113166: LIST
113167: LIST
113168: LIST
113169: LIST
113170: LIST
113171: LIST
113172: LIST
113173: LIST
113174: LIST
113175: LIST
113176: LIST
113177: LIST
113178: LIST
113179: PUSH
113180: EMPTY
113181: LIST
113182: LIST
113183: ST_TO_ADDR
113184: GO 113583
113186: LD_INT 18
113188: DOUBLE
113189: EQUAL
113190: IFTRUE 113194
113192: GO 113342
113194: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
113195: LD_ADDR_VAR 0 2
113199: PUSH
113200: LD_INT 2
113202: PUSH
113203: LD_INT 4
113205: PUSH
113206: LD_INT 5
113208: PUSH
113209: LD_INT 7
113211: PUSH
113212: LD_INT 11
113214: PUSH
113215: LD_INT 12
113217: PUSH
113218: LD_INT 15
113220: PUSH
113221: LD_INT 16
113223: PUSH
113224: LD_INT 20
113226: PUSH
113227: LD_INT 21
113229: PUSH
113230: LD_INT 22
113232: PUSH
113233: LD_INT 23
113235: PUSH
113236: LD_INT 25
113238: PUSH
113239: LD_INT 26
113241: PUSH
113242: LD_INT 30
113244: PUSH
113245: LD_INT 31
113247: PUSH
113248: LD_INT 32
113250: PUSH
113251: LD_INT 33
113253: PUSH
113254: LD_INT 34
113256: PUSH
113257: LD_INT 35
113259: PUSH
113260: LD_INT 36
113262: PUSH
113263: EMPTY
113264: LIST
113265: LIST
113266: LIST
113267: LIST
113268: LIST
113269: LIST
113270: LIST
113271: LIST
113272: LIST
113273: LIST
113274: LIST
113275: LIST
113276: LIST
113277: LIST
113278: LIST
113279: LIST
113280: LIST
113281: LIST
113282: LIST
113283: LIST
113284: LIST
113285: PUSH
113286: LD_INT 101
113288: PUSH
113289: LD_INT 102
113291: PUSH
113292: LD_INT 103
113294: PUSH
113295: LD_INT 106
113297: PUSH
113298: LD_INT 108
113300: PUSH
113301: LD_INT 112
113303: PUSH
113304: LD_INT 113
113306: PUSH
113307: LD_INT 114
113309: PUSH
113310: LD_INT 115
113312: PUSH
113313: LD_INT 116
113315: PUSH
113316: LD_INT 117
113318: PUSH
113319: LD_INT 118
113321: PUSH
113322: EMPTY
113323: LIST
113324: LIST
113325: LIST
113326: LIST
113327: LIST
113328: LIST
113329: LIST
113330: LIST
113331: LIST
113332: LIST
113333: LIST
113334: LIST
113335: PUSH
113336: EMPTY
113337: LIST
113338: LIST
113339: ST_TO_ADDR
113340: GO 113583
113342: LD_INT 19
113344: DOUBLE
113345: EQUAL
113346: IFTRUE 113350
113348: GO 113582
113350: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
113351: LD_ADDR_VAR 0 2
113355: PUSH
113356: LD_INT 1
113358: PUSH
113359: LD_INT 2
113361: PUSH
113362: LD_INT 3
113364: PUSH
113365: LD_INT 4
113367: PUSH
113368: LD_INT 5
113370: PUSH
113371: LD_INT 6
113373: PUSH
113374: LD_INT 7
113376: PUSH
113377: LD_INT 8
113379: PUSH
113380: LD_INT 9
113382: PUSH
113383: LD_INT 10
113385: PUSH
113386: LD_INT 11
113388: PUSH
113389: LD_INT 12
113391: PUSH
113392: LD_INT 13
113394: PUSH
113395: LD_INT 14
113397: PUSH
113398: LD_INT 15
113400: PUSH
113401: LD_INT 16
113403: PUSH
113404: LD_INT 17
113406: PUSH
113407: LD_INT 18
113409: PUSH
113410: LD_INT 19
113412: PUSH
113413: LD_INT 20
113415: PUSH
113416: LD_INT 21
113418: PUSH
113419: LD_INT 22
113421: PUSH
113422: LD_INT 23
113424: PUSH
113425: LD_INT 24
113427: PUSH
113428: LD_INT 25
113430: PUSH
113431: LD_INT 26
113433: PUSH
113434: LD_INT 27
113436: PUSH
113437: LD_INT 28
113439: PUSH
113440: LD_INT 29
113442: PUSH
113443: LD_INT 30
113445: PUSH
113446: LD_INT 31
113448: PUSH
113449: LD_INT 32
113451: PUSH
113452: LD_INT 33
113454: PUSH
113455: LD_INT 34
113457: PUSH
113458: LD_INT 35
113460: PUSH
113461: LD_INT 36
113463: PUSH
113464: EMPTY
113465: LIST
113466: LIST
113467: LIST
113468: LIST
113469: LIST
113470: LIST
113471: LIST
113472: LIST
113473: LIST
113474: LIST
113475: LIST
113476: LIST
113477: LIST
113478: LIST
113479: LIST
113480: LIST
113481: LIST
113482: LIST
113483: LIST
113484: LIST
113485: LIST
113486: LIST
113487: LIST
113488: LIST
113489: LIST
113490: LIST
113491: LIST
113492: LIST
113493: LIST
113494: LIST
113495: LIST
113496: LIST
113497: LIST
113498: LIST
113499: LIST
113500: LIST
113501: PUSH
113502: LD_INT 101
113504: PUSH
113505: LD_INT 102
113507: PUSH
113508: LD_INT 103
113510: PUSH
113511: LD_INT 104
113513: PUSH
113514: LD_INT 105
113516: PUSH
113517: LD_INT 106
113519: PUSH
113520: LD_INT 107
113522: PUSH
113523: LD_INT 108
113525: PUSH
113526: LD_INT 109
113528: PUSH
113529: LD_INT 110
113531: PUSH
113532: LD_INT 111
113534: PUSH
113535: LD_INT 112
113537: PUSH
113538: LD_INT 113
113540: PUSH
113541: LD_INT 114
113543: PUSH
113544: LD_INT 115
113546: PUSH
113547: LD_INT 116
113549: PUSH
113550: LD_INT 117
113552: PUSH
113553: LD_INT 118
113555: PUSH
113556: EMPTY
113557: LIST
113558: LIST
113559: LIST
113560: LIST
113561: LIST
113562: LIST
113563: LIST
113564: LIST
113565: LIST
113566: LIST
113567: LIST
113568: LIST
113569: LIST
113570: LIST
113571: LIST
113572: LIST
113573: LIST
113574: LIST
113575: PUSH
113576: EMPTY
113577: LIST
113578: LIST
113579: ST_TO_ADDR
113580: GO 113583
113582: POP
// end else
113583: GO 113814
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
113585: LD_ADDR_VAR 0 2
113589: PUSH
113590: LD_INT 1
113592: PUSH
113593: LD_INT 2
113595: PUSH
113596: LD_INT 3
113598: PUSH
113599: LD_INT 4
113601: PUSH
113602: LD_INT 5
113604: PUSH
113605: LD_INT 6
113607: PUSH
113608: LD_INT 7
113610: PUSH
113611: LD_INT 8
113613: PUSH
113614: LD_INT 9
113616: PUSH
113617: LD_INT 10
113619: PUSH
113620: LD_INT 11
113622: PUSH
113623: LD_INT 12
113625: PUSH
113626: LD_INT 13
113628: PUSH
113629: LD_INT 14
113631: PUSH
113632: LD_INT 15
113634: PUSH
113635: LD_INT 16
113637: PUSH
113638: LD_INT 17
113640: PUSH
113641: LD_INT 18
113643: PUSH
113644: LD_INT 19
113646: PUSH
113647: LD_INT 20
113649: PUSH
113650: LD_INT 21
113652: PUSH
113653: LD_INT 22
113655: PUSH
113656: LD_INT 23
113658: PUSH
113659: LD_INT 24
113661: PUSH
113662: LD_INT 25
113664: PUSH
113665: LD_INT 26
113667: PUSH
113668: LD_INT 27
113670: PUSH
113671: LD_INT 28
113673: PUSH
113674: LD_INT 29
113676: PUSH
113677: LD_INT 30
113679: PUSH
113680: LD_INT 31
113682: PUSH
113683: LD_INT 32
113685: PUSH
113686: LD_INT 33
113688: PUSH
113689: LD_INT 34
113691: PUSH
113692: LD_INT 35
113694: PUSH
113695: LD_INT 36
113697: PUSH
113698: EMPTY
113699: LIST
113700: LIST
113701: LIST
113702: LIST
113703: LIST
113704: LIST
113705: LIST
113706: LIST
113707: LIST
113708: LIST
113709: LIST
113710: LIST
113711: LIST
113712: LIST
113713: LIST
113714: LIST
113715: LIST
113716: LIST
113717: LIST
113718: LIST
113719: LIST
113720: LIST
113721: LIST
113722: LIST
113723: LIST
113724: LIST
113725: LIST
113726: LIST
113727: LIST
113728: LIST
113729: LIST
113730: LIST
113731: LIST
113732: LIST
113733: LIST
113734: LIST
113735: PUSH
113736: LD_INT 101
113738: PUSH
113739: LD_INT 102
113741: PUSH
113742: LD_INT 103
113744: PUSH
113745: LD_INT 104
113747: PUSH
113748: LD_INT 105
113750: PUSH
113751: LD_INT 106
113753: PUSH
113754: LD_INT 107
113756: PUSH
113757: LD_INT 108
113759: PUSH
113760: LD_INT 109
113762: PUSH
113763: LD_INT 110
113765: PUSH
113766: LD_INT 111
113768: PUSH
113769: LD_INT 112
113771: PUSH
113772: LD_INT 113
113774: PUSH
113775: LD_INT 114
113777: PUSH
113778: LD_INT 115
113780: PUSH
113781: LD_INT 116
113783: PUSH
113784: LD_INT 117
113786: PUSH
113787: LD_INT 118
113789: PUSH
113790: EMPTY
113791: LIST
113792: LIST
113793: LIST
113794: LIST
113795: LIST
113796: LIST
113797: LIST
113798: LIST
113799: LIST
113800: LIST
113801: LIST
113802: LIST
113803: LIST
113804: LIST
113805: LIST
113806: LIST
113807: LIST
113808: LIST
113809: PUSH
113810: EMPTY
113811: LIST
113812: LIST
113813: ST_TO_ADDR
// if result then
113814: LD_VAR 0 2
113818: IFFALSE 114604
// begin normal :=  ;
113820: LD_ADDR_VAR 0 5
113824: PUSH
113825: LD_STRING 
113827: ST_TO_ADDR
// hardcore :=  ;
113828: LD_ADDR_VAR 0 6
113832: PUSH
113833: LD_STRING 
113835: ST_TO_ADDR
// active :=  ;
113836: LD_ADDR_VAR 0 7
113840: PUSH
113841: LD_STRING 
113843: ST_TO_ADDR
// for i = 1 to normalCounter do
113844: LD_ADDR_VAR 0 8
113848: PUSH
113849: DOUBLE
113850: LD_INT 1
113852: DEC
113853: ST_TO_ADDR
113854: LD_EXP 144
113858: PUSH
113859: FOR_TO
113860: IFFALSE 113961
// begin tmp := 0 ;
113862: LD_ADDR_VAR 0 3
113866: PUSH
113867: LD_STRING 0
113869: ST_TO_ADDR
// if result [ 1 ] then
113870: LD_VAR 0 2
113874: PUSH
113875: LD_INT 1
113877: ARRAY
113878: IFFALSE 113943
// if result [ 1 ] [ 1 ] = i then
113880: LD_VAR 0 2
113884: PUSH
113885: LD_INT 1
113887: ARRAY
113888: PUSH
113889: LD_INT 1
113891: ARRAY
113892: PUSH
113893: LD_VAR 0 8
113897: EQUAL
113898: IFFALSE 113943
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
113900: LD_ADDR_VAR 0 2
113904: PUSH
113905: LD_VAR 0 2
113909: PPUSH
113910: LD_INT 1
113912: PPUSH
113913: LD_VAR 0 2
113917: PUSH
113918: LD_INT 1
113920: ARRAY
113921: PPUSH
113922: LD_INT 1
113924: PPUSH
113925: CALL_OW 3
113929: PPUSH
113930: CALL_OW 1
113934: ST_TO_ADDR
// tmp := 1 ;
113935: LD_ADDR_VAR 0 3
113939: PUSH
113940: LD_STRING 1
113942: ST_TO_ADDR
// end ; normal := normal & tmp ;
113943: LD_ADDR_VAR 0 5
113947: PUSH
113948: LD_VAR 0 5
113952: PUSH
113953: LD_VAR 0 3
113957: STR
113958: ST_TO_ADDR
// end ;
113959: GO 113859
113961: POP
113962: POP
// for i = 1 to hardcoreCounter do
113963: LD_ADDR_VAR 0 8
113967: PUSH
113968: DOUBLE
113969: LD_INT 1
113971: DEC
113972: ST_TO_ADDR
113973: LD_EXP 145
113977: PUSH
113978: FOR_TO
113979: IFFALSE 114084
// begin tmp := 0 ;
113981: LD_ADDR_VAR 0 3
113985: PUSH
113986: LD_STRING 0
113988: ST_TO_ADDR
// if result [ 2 ] then
113989: LD_VAR 0 2
113993: PUSH
113994: LD_INT 2
113996: ARRAY
113997: IFFALSE 114066
// if result [ 2 ] [ 1 ] = 100 + i then
113999: LD_VAR 0 2
114003: PUSH
114004: LD_INT 2
114006: ARRAY
114007: PUSH
114008: LD_INT 1
114010: ARRAY
114011: PUSH
114012: LD_INT 100
114014: PUSH
114015: LD_VAR 0 8
114019: PLUS
114020: EQUAL
114021: IFFALSE 114066
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
114023: LD_ADDR_VAR 0 2
114027: PUSH
114028: LD_VAR 0 2
114032: PPUSH
114033: LD_INT 2
114035: PPUSH
114036: LD_VAR 0 2
114040: PUSH
114041: LD_INT 2
114043: ARRAY
114044: PPUSH
114045: LD_INT 1
114047: PPUSH
114048: CALL_OW 3
114052: PPUSH
114053: CALL_OW 1
114057: ST_TO_ADDR
// tmp := 1 ;
114058: LD_ADDR_VAR 0 3
114062: PUSH
114063: LD_STRING 1
114065: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
114066: LD_ADDR_VAR 0 6
114070: PUSH
114071: LD_VAR 0 6
114075: PUSH
114076: LD_VAR 0 3
114080: STR
114081: ST_TO_ADDR
// end ;
114082: GO 113978
114084: POP
114085: POP
// if isGameLoad then
114086: LD_VAR 0 1
114090: IFFALSE 114565
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
114092: LD_ADDR_VAR 0 4
114096: PUSH
114097: LD_EXP 148
114101: PUSH
114102: LD_EXP 147
114106: PUSH
114107: LD_EXP 149
114111: PUSH
114112: LD_EXP 146
114116: PUSH
114117: LD_EXP 150
114121: PUSH
114122: LD_EXP 151
114126: PUSH
114127: LD_EXP 152
114131: PUSH
114132: LD_EXP 153
114136: PUSH
114137: LD_EXP 154
114141: PUSH
114142: LD_EXP 155
114146: PUSH
114147: LD_EXP 156
114151: PUSH
114152: LD_EXP 157
114156: PUSH
114157: LD_EXP 158
114161: PUSH
114162: LD_EXP 159
114166: PUSH
114167: LD_EXP 167
114171: PUSH
114172: LD_EXP 168
114176: PUSH
114177: LD_EXP 169
114181: PUSH
114182: LD_EXP 170
114186: PUSH
114187: LD_EXP 172
114191: PUSH
114192: LD_EXP 173
114196: PUSH
114197: LD_EXP 174
114201: PUSH
114202: LD_EXP 177
114206: PUSH
114207: LD_EXP 179
114211: PUSH
114212: LD_EXP 180
114216: PUSH
114217: LD_EXP 181
114221: PUSH
114222: LD_EXP 183
114226: PUSH
114227: LD_EXP 184
114231: PUSH
114232: LD_EXP 187
114236: PUSH
114237: LD_EXP 188
114241: PUSH
114242: LD_EXP 189
114246: PUSH
114247: LD_EXP 190
114251: PUSH
114252: LD_EXP 191
114256: PUSH
114257: LD_EXP 192
114261: PUSH
114262: LD_EXP 193
114266: PUSH
114267: LD_EXP 194
114271: PUSH
114272: LD_EXP 195
114276: PUSH
114277: LD_EXP 160
114281: PUSH
114282: LD_EXP 161
114286: PUSH
114287: LD_EXP 164
114291: PUSH
114292: LD_EXP 165
114296: PUSH
114297: LD_EXP 166
114301: PUSH
114302: LD_EXP 162
114306: PUSH
114307: LD_EXP 163
114311: PUSH
114312: LD_EXP 171
114316: PUSH
114317: LD_EXP 175
114321: PUSH
114322: LD_EXP 176
114326: PUSH
114327: LD_EXP 178
114331: PUSH
114332: LD_EXP 182
114336: PUSH
114337: LD_EXP 185
114341: PUSH
114342: LD_EXP 186
114346: PUSH
114347: LD_EXP 196
114351: PUSH
114352: LD_EXP 197
114356: PUSH
114357: LD_EXP 198
114361: PUSH
114362: LD_EXP 199
114366: PUSH
114367: EMPTY
114368: LIST
114369: LIST
114370: LIST
114371: LIST
114372: LIST
114373: LIST
114374: LIST
114375: LIST
114376: LIST
114377: LIST
114378: LIST
114379: LIST
114380: LIST
114381: LIST
114382: LIST
114383: LIST
114384: LIST
114385: LIST
114386: LIST
114387: LIST
114388: LIST
114389: LIST
114390: LIST
114391: LIST
114392: LIST
114393: LIST
114394: LIST
114395: LIST
114396: LIST
114397: LIST
114398: LIST
114399: LIST
114400: LIST
114401: LIST
114402: LIST
114403: LIST
114404: LIST
114405: LIST
114406: LIST
114407: LIST
114408: LIST
114409: LIST
114410: LIST
114411: LIST
114412: LIST
114413: LIST
114414: LIST
114415: LIST
114416: LIST
114417: LIST
114418: LIST
114419: LIST
114420: LIST
114421: LIST
114422: ST_TO_ADDR
// tmp :=  ;
114423: LD_ADDR_VAR 0 3
114427: PUSH
114428: LD_STRING 
114430: ST_TO_ADDR
// for i = 1 to normalCounter do
114431: LD_ADDR_VAR 0 8
114435: PUSH
114436: DOUBLE
114437: LD_INT 1
114439: DEC
114440: ST_TO_ADDR
114441: LD_EXP 144
114445: PUSH
114446: FOR_TO
114447: IFFALSE 114483
// begin if flags [ i ] then
114449: LD_VAR 0 4
114453: PUSH
114454: LD_VAR 0 8
114458: ARRAY
114459: IFFALSE 114481
// tmp := tmp & i & ; ;
114461: LD_ADDR_VAR 0 3
114465: PUSH
114466: LD_VAR 0 3
114470: PUSH
114471: LD_VAR 0 8
114475: STR
114476: PUSH
114477: LD_STRING ;
114479: STR
114480: ST_TO_ADDR
// end ;
114481: GO 114446
114483: POP
114484: POP
// for i = 1 to hardcoreCounter do
114485: LD_ADDR_VAR 0 8
114489: PUSH
114490: DOUBLE
114491: LD_INT 1
114493: DEC
114494: ST_TO_ADDR
114495: LD_EXP 145
114499: PUSH
114500: FOR_TO
114501: IFFALSE 114547
// begin if flags [ normalCounter + i ] then
114503: LD_VAR 0 4
114507: PUSH
114508: LD_EXP 144
114512: PUSH
114513: LD_VAR 0 8
114517: PLUS
114518: ARRAY
114519: IFFALSE 114545
// tmp := tmp & ( 100 + i ) & ; ;
114521: LD_ADDR_VAR 0 3
114525: PUSH
114526: LD_VAR 0 3
114530: PUSH
114531: LD_INT 100
114533: PUSH
114534: LD_VAR 0 8
114538: PLUS
114539: STR
114540: PUSH
114541: LD_STRING ;
114543: STR
114544: ST_TO_ADDR
// end ;
114545: GO 114500
114547: POP
114548: POP
// if tmp then
114549: LD_VAR 0 3
114553: IFFALSE 114565
// active := tmp ;
114555: LD_ADDR_VAR 0 7
114559: PUSH
114560: LD_VAR 0 3
114564: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
114565: LD_STRING getStreamItemsFromMission("
114567: PUSH
114568: LD_VAR 0 5
114572: STR
114573: PUSH
114574: LD_STRING ","
114576: STR
114577: PUSH
114578: LD_VAR 0 6
114582: STR
114583: PUSH
114584: LD_STRING ","
114586: STR
114587: PUSH
114588: LD_VAR 0 7
114592: STR
114593: PUSH
114594: LD_STRING ")
114596: STR
114597: PPUSH
114598: CALL_OW 559
// end else
114602: GO 114611
// ToLua ( getStreamItemsFromMission("","","") ) ;
114604: LD_STRING getStreamItemsFromMission("","","")
114606: PPUSH
114607: CALL_OW 559
// end ;
114611: LD_VAR 0 2
114615: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
114616: LD_EXP 143
114620: PUSH
114621: LD_EXP 148
114625: AND
114626: IFFALSE 114750
114628: GO 114630
114630: DISABLE
114631: LD_INT 0
114633: PPUSH
114634: PPUSH
// begin enable ;
114635: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
114636: LD_ADDR_VAR 0 2
114640: PUSH
114641: LD_INT 22
114643: PUSH
114644: LD_OWVAR 2
114648: PUSH
114649: EMPTY
114650: LIST
114651: LIST
114652: PUSH
114653: LD_INT 2
114655: PUSH
114656: LD_INT 34
114658: PUSH
114659: LD_INT 7
114661: PUSH
114662: EMPTY
114663: LIST
114664: LIST
114665: PUSH
114666: LD_INT 34
114668: PUSH
114669: LD_INT 45
114671: PUSH
114672: EMPTY
114673: LIST
114674: LIST
114675: PUSH
114676: LD_INT 34
114678: PUSH
114679: LD_INT 28
114681: PUSH
114682: EMPTY
114683: LIST
114684: LIST
114685: PUSH
114686: LD_INT 34
114688: PUSH
114689: LD_INT 47
114691: PUSH
114692: EMPTY
114693: LIST
114694: LIST
114695: PUSH
114696: EMPTY
114697: LIST
114698: LIST
114699: LIST
114700: LIST
114701: LIST
114702: PUSH
114703: EMPTY
114704: LIST
114705: LIST
114706: PPUSH
114707: CALL_OW 69
114711: ST_TO_ADDR
// if not tmp then
114712: LD_VAR 0 2
114716: NOT
114717: IFFALSE 114721
// exit ;
114719: GO 114750
// for i in tmp do
114721: LD_ADDR_VAR 0 1
114725: PUSH
114726: LD_VAR 0 2
114730: PUSH
114731: FOR_IN
114732: IFFALSE 114748
// begin SetLives ( i , 0 ) ;
114734: LD_VAR 0 1
114738: PPUSH
114739: LD_INT 0
114741: PPUSH
114742: CALL_OW 234
// end ;
114746: GO 114731
114748: POP
114749: POP
// end ;
114750: PPOPN 2
114752: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
114753: LD_EXP 143
114757: PUSH
114758: LD_EXP 149
114762: AND
114763: IFFALSE 114847
114765: GO 114767
114767: DISABLE
114768: LD_INT 0
114770: PPUSH
114771: PPUSH
// begin enable ;
114772: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
114773: LD_ADDR_VAR 0 2
114777: PUSH
114778: LD_INT 22
114780: PUSH
114781: LD_OWVAR 2
114785: PUSH
114786: EMPTY
114787: LIST
114788: LIST
114789: PUSH
114790: LD_INT 32
114792: PUSH
114793: LD_INT 3
114795: PUSH
114796: EMPTY
114797: LIST
114798: LIST
114799: PUSH
114800: EMPTY
114801: LIST
114802: LIST
114803: PPUSH
114804: CALL_OW 69
114808: ST_TO_ADDR
// if not tmp then
114809: LD_VAR 0 2
114813: NOT
114814: IFFALSE 114818
// exit ;
114816: GO 114847
// for i in tmp do
114818: LD_ADDR_VAR 0 1
114822: PUSH
114823: LD_VAR 0 2
114827: PUSH
114828: FOR_IN
114829: IFFALSE 114845
// begin SetLives ( i , 0 ) ;
114831: LD_VAR 0 1
114835: PPUSH
114836: LD_INT 0
114838: PPUSH
114839: CALL_OW 234
// end ;
114843: GO 114828
114845: POP
114846: POP
// end ;
114847: PPOPN 2
114849: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
114850: LD_EXP 143
114854: PUSH
114855: LD_EXP 146
114859: AND
114860: IFFALSE 114953
114862: GO 114864
114864: DISABLE
114865: LD_INT 0
114867: PPUSH
// begin enable ;
114868: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
114869: LD_ADDR_VAR 0 1
114873: PUSH
114874: LD_INT 22
114876: PUSH
114877: LD_OWVAR 2
114881: PUSH
114882: EMPTY
114883: LIST
114884: LIST
114885: PUSH
114886: LD_INT 2
114888: PUSH
114889: LD_INT 25
114891: PUSH
114892: LD_INT 5
114894: PUSH
114895: EMPTY
114896: LIST
114897: LIST
114898: PUSH
114899: LD_INT 25
114901: PUSH
114902: LD_INT 9
114904: PUSH
114905: EMPTY
114906: LIST
114907: LIST
114908: PUSH
114909: LD_INT 25
114911: PUSH
114912: LD_INT 8
114914: PUSH
114915: EMPTY
114916: LIST
114917: LIST
114918: PUSH
114919: EMPTY
114920: LIST
114921: LIST
114922: LIST
114923: LIST
114924: PUSH
114925: EMPTY
114926: LIST
114927: LIST
114928: PPUSH
114929: CALL_OW 69
114933: PUSH
114934: FOR_IN
114935: IFFALSE 114951
// begin SetClass ( i , 1 ) ;
114937: LD_VAR 0 1
114941: PPUSH
114942: LD_INT 1
114944: PPUSH
114945: CALL_OW 336
// end ;
114949: GO 114934
114951: POP
114952: POP
// end ;
114953: PPOPN 1
114955: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
114956: LD_EXP 143
114960: PUSH
114961: LD_EXP 147
114965: AND
114966: PUSH
114967: LD_OWVAR 65
114971: PUSH
114972: LD_INT 7
114974: LESS
114975: AND
114976: IFFALSE 114990
114978: GO 114980
114980: DISABLE
// begin enable ;
114981: ENABLE
// game_speed := 7 ;
114982: LD_ADDR_OWVAR 65
114986: PUSH
114987: LD_INT 7
114989: ST_TO_ADDR
// end ;
114990: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
114991: LD_EXP 143
114995: PUSH
114996: LD_EXP 150
115000: AND
115001: IFFALSE 115203
115003: GO 115005
115005: DISABLE
115006: LD_INT 0
115008: PPUSH
115009: PPUSH
115010: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
115011: LD_ADDR_VAR 0 3
115015: PUSH
115016: LD_INT 81
115018: PUSH
115019: LD_OWVAR 2
115023: PUSH
115024: EMPTY
115025: LIST
115026: LIST
115027: PUSH
115028: LD_INT 21
115030: PUSH
115031: LD_INT 1
115033: PUSH
115034: EMPTY
115035: LIST
115036: LIST
115037: PUSH
115038: EMPTY
115039: LIST
115040: LIST
115041: PPUSH
115042: CALL_OW 69
115046: ST_TO_ADDR
// if not tmp then
115047: LD_VAR 0 3
115051: NOT
115052: IFFALSE 115056
// exit ;
115054: GO 115203
// if tmp > 5 then
115056: LD_VAR 0 3
115060: PUSH
115061: LD_INT 5
115063: GREATER
115064: IFFALSE 115076
// k := 5 else
115066: LD_ADDR_VAR 0 2
115070: PUSH
115071: LD_INT 5
115073: ST_TO_ADDR
115074: GO 115086
// k := tmp ;
115076: LD_ADDR_VAR 0 2
115080: PUSH
115081: LD_VAR 0 3
115085: ST_TO_ADDR
// for i := 1 to k do
115086: LD_ADDR_VAR 0 1
115090: PUSH
115091: DOUBLE
115092: LD_INT 1
115094: DEC
115095: ST_TO_ADDR
115096: LD_VAR 0 2
115100: PUSH
115101: FOR_TO
115102: IFFALSE 115201
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
115104: LD_VAR 0 3
115108: PUSH
115109: LD_VAR 0 1
115113: ARRAY
115114: PPUSH
115115: LD_VAR 0 1
115119: PUSH
115120: LD_INT 4
115122: MOD
115123: PUSH
115124: LD_INT 1
115126: PLUS
115127: PPUSH
115128: CALL_OW 259
115132: PUSH
115133: LD_INT 10
115135: LESS
115136: IFFALSE 115199
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
115138: LD_VAR 0 3
115142: PUSH
115143: LD_VAR 0 1
115147: ARRAY
115148: PPUSH
115149: LD_VAR 0 1
115153: PUSH
115154: LD_INT 4
115156: MOD
115157: PUSH
115158: LD_INT 1
115160: PLUS
115161: PPUSH
115162: LD_VAR 0 3
115166: PUSH
115167: LD_VAR 0 1
115171: ARRAY
115172: PPUSH
115173: LD_VAR 0 1
115177: PUSH
115178: LD_INT 4
115180: MOD
115181: PUSH
115182: LD_INT 1
115184: PLUS
115185: PPUSH
115186: CALL_OW 259
115190: PUSH
115191: LD_INT 1
115193: PLUS
115194: PPUSH
115195: CALL_OW 237
115199: GO 115101
115201: POP
115202: POP
// end ;
115203: PPOPN 3
115205: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
115206: LD_EXP 143
115210: PUSH
115211: LD_EXP 151
115215: AND
115216: IFFALSE 115236
115218: GO 115220
115220: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
115221: LD_INT 4
115223: PPUSH
115224: LD_OWVAR 2
115228: PPUSH
115229: LD_INT 0
115231: PPUSH
115232: CALL_OW 324
115236: END
// every 0 0$1 trigger StreamModeActive and sShovel do
115237: LD_EXP 143
115241: PUSH
115242: LD_EXP 180
115246: AND
115247: IFFALSE 115267
115249: GO 115251
115251: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
115252: LD_INT 19
115254: PPUSH
115255: LD_OWVAR 2
115259: PPUSH
115260: LD_INT 0
115262: PPUSH
115263: CALL_OW 324
115267: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
115268: LD_EXP 143
115272: PUSH
115273: LD_EXP 152
115277: AND
115278: IFFALSE 115380
115280: GO 115282
115282: DISABLE
115283: LD_INT 0
115285: PPUSH
115286: PPUSH
// begin enable ;
115287: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
115288: LD_ADDR_VAR 0 2
115292: PUSH
115293: LD_INT 22
115295: PUSH
115296: LD_OWVAR 2
115300: PUSH
115301: EMPTY
115302: LIST
115303: LIST
115304: PUSH
115305: LD_INT 2
115307: PUSH
115308: LD_INT 34
115310: PUSH
115311: LD_INT 11
115313: PUSH
115314: EMPTY
115315: LIST
115316: LIST
115317: PUSH
115318: LD_INT 34
115320: PUSH
115321: LD_INT 30
115323: PUSH
115324: EMPTY
115325: LIST
115326: LIST
115327: PUSH
115328: EMPTY
115329: LIST
115330: LIST
115331: LIST
115332: PUSH
115333: EMPTY
115334: LIST
115335: LIST
115336: PPUSH
115337: CALL_OW 69
115341: ST_TO_ADDR
// if not tmp then
115342: LD_VAR 0 2
115346: NOT
115347: IFFALSE 115351
// exit ;
115349: GO 115380
// for i in tmp do
115351: LD_ADDR_VAR 0 1
115355: PUSH
115356: LD_VAR 0 2
115360: PUSH
115361: FOR_IN
115362: IFFALSE 115378
// begin SetLives ( i , 0 ) ;
115364: LD_VAR 0 1
115368: PPUSH
115369: LD_INT 0
115371: PPUSH
115372: CALL_OW 234
// end ;
115376: GO 115361
115378: POP
115379: POP
// end ;
115380: PPOPN 2
115382: END
// every 0 0$1 trigger StreamModeActive and sBunker do
115383: LD_EXP 143
115387: PUSH
115388: LD_EXP 153
115392: AND
115393: IFFALSE 115413
115395: GO 115397
115397: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
115398: LD_INT 32
115400: PPUSH
115401: LD_OWVAR 2
115405: PPUSH
115406: LD_INT 0
115408: PPUSH
115409: CALL_OW 324
115413: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
115414: LD_EXP 143
115418: PUSH
115419: LD_EXP 154
115423: AND
115424: IFFALSE 115605
115426: GO 115428
115428: DISABLE
115429: LD_INT 0
115431: PPUSH
115432: PPUSH
115433: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
115434: LD_ADDR_VAR 0 2
115438: PUSH
115439: LD_INT 22
115441: PUSH
115442: LD_OWVAR 2
115446: PUSH
115447: EMPTY
115448: LIST
115449: LIST
115450: PUSH
115451: LD_INT 33
115453: PUSH
115454: LD_INT 3
115456: PUSH
115457: EMPTY
115458: LIST
115459: LIST
115460: PUSH
115461: EMPTY
115462: LIST
115463: LIST
115464: PPUSH
115465: CALL_OW 69
115469: ST_TO_ADDR
// if not tmp then
115470: LD_VAR 0 2
115474: NOT
115475: IFFALSE 115479
// exit ;
115477: GO 115605
// side := 0 ;
115479: LD_ADDR_VAR 0 3
115483: PUSH
115484: LD_INT 0
115486: ST_TO_ADDR
// for i := 1 to 8 do
115487: LD_ADDR_VAR 0 1
115491: PUSH
115492: DOUBLE
115493: LD_INT 1
115495: DEC
115496: ST_TO_ADDR
115497: LD_INT 8
115499: PUSH
115500: FOR_TO
115501: IFFALSE 115549
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
115503: LD_OWVAR 2
115507: PUSH
115508: LD_VAR 0 1
115512: NONEQUAL
115513: PUSH
115514: LD_OWVAR 2
115518: PPUSH
115519: LD_VAR 0 1
115523: PPUSH
115524: CALL_OW 81
115528: PUSH
115529: LD_INT 2
115531: EQUAL
115532: AND
115533: IFFALSE 115547
// begin side := i ;
115535: LD_ADDR_VAR 0 3
115539: PUSH
115540: LD_VAR 0 1
115544: ST_TO_ADDR
// break ;
115545: GO 115549
// end ;
115547: GO 115500
115549: POP
115550: POP
// if not side then
115551: LD_VAR 0 3
115555: NOT
115556: IFFALSE 115560
// exit ;
115558: GO 115605
// for i := 1 to tmp do
115560: LD_ADDR_VAR 0 1
115564: PUSH
115565: DOUBLE
115566: LD_INT 1
115568: DEC
115569: ST_TO_ADDR
115570: LD_VAR 0 2
115574: PUSH
115575: FOR_TO
115576: IFFALSE 115603
// if Prob ( 60 ) then
115578: LD_INT 60
115580: PPUSH
115581: CALL_OW 13
115585: IFFALSE 115601
// SetSide ( i , side ) ;
115587: LD_VAR 0 1
115591: PPUSH
115592: LD_VAR 0 3
115596: PPUSH
115597: CALL_OW 235
115601: GO 115575
115603: POP
115604: POP
// end ;
115605: PPOPN 3
115607: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
115608: LD_EXP 143
115612: PUSH
115613: LD_EXP 156
115617: AND
115618: IFFALSE 115737
115620: GO 115622
115622: DISABLE
115623: LD_INT 0
115625: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
115626: LD_ADDR_VAR 0 1
115630: PUSH
115631: LD_INT 22
115633: PUSH
115634: LD_OWVAR 2
115638: PUSH
115639: EMPTY
115640: LIST
115641: LIST
115642: PUSH
115643: LD_INT 21
115645: PUSH
115646: LD_INT 1
115648: PUSH
115649: EMPTY
115650: LIST
115651: LIST
115652: PUSH
115653: LD_INT 3
115655: PUSH
115656: LD_INT 23
115658: PUSH
115659: LD_INT 0
115661: PUSH
115662: EMPTY
115663: LIST
115664: LIST
115665: PUSH
115666: EMPTY
115667: LIST
115668: LIST
115669: PUSH
115670: EMPTY
115671: LIST
115672: LIST
115673: LIST
115674: PPUSH
115675: CALL_OW 69
115679: PUSH
115680: FOR_IN
115681: IFFALSE 115735
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
115683: LD_VAR 0 1
115687: PPUSH
115688: CALL_OW 257
115692: PUSH
115693: LD_INT 1
115695: PUSH
115696: LD_INT 2
115698: PUSH
115699: LD_INT 3
115701: PUSH
115702: LD_INT 4
115704: PUSH
115705: EMPTY
115706: LIST
115707: LIST
115708: LIST
115709: LIST
115710: IN
115711: IFFALSE 115733
// SetClass ( un , rand ( 1 , 4 ) ) ;
115713: LD_VAR 0 1
115717: PPUSH
115718: LD_INT 1
115720: PPUSH
115721: LD_INT 4
115723: PPUSH
115724: CALL_OW 12
115728: PPUSH
115729: CALL_OW 336
115733: GO 115680
115735: POP
115736: POP
// end ;
115737: PPOPN 1
115739: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
115740: LD_EXP 143
115744: PUSH
115745: LD_EXP 155
115749: AND
115750: IFFALSE 115829
115752: GO 115754
115754: DISABLE
115755: LD_INT 0
115757: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
115758: LD_ADDR_VAR 0 1
115762: PUSH
115763: LD_INT 22
115765: PUSH
115766: LD_OWVAR 2
115770: PUSH
115771: EMPTY
115772: LIST
115773: LIST
115774: PUSH
115775: LD_INT 21
115777: PUSH
115778: LD_INT 3
115780: PUSH
115781: EMPTY
115782: LIST
115783: LIST
115784: PUSH
115785: EMPTY
115786: LIST
115787: LIST
115788: PPUSH
115789: CALL_OW 69
115793: ST_TO_ADDR
// if not tmp then
115794: LD_VAR 0 1
115798: NOT
115799: IFFALSE 115803
// exit ;
115801: GO 115829
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
115803: LD_VAR 0 1
115807: PUSH
115808: LD_INT 1
115810: PPUSH
115811: LD_VAR 0 1
115815: PPUSH
115816: CALL_OW 12
115820: ARRAY
115821: PPUSH
115822: LD_INT 100
115824: PPUSH
115825: CALL_OW 234
// end ;
115829: PPOPN 1
115831: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
115832: LD_EXP 143
115836: PUSH
115837: LD_EXP 157
115841: AND
115842: IFFALSE 115940
115844: GO 115846
115846: DISABLE
115847: LD_INT 0
115849: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
115850: LD_ADDR_VAR 0 1
115854: PUSH
115855: LD_INT 22
115857: PUSH
115858: LD_OWVAR 2
115862: PUSH
115863: EMPTY
115864: LIST
115865: LIST
115866: PUSH
115867: LD_INT 21
115869: PUSH
115870: LD_INT 1
115872: PUSH
115873: EMPTY
115874: LIST
115875: LIST
115876: PUSH
115877: EMPTY
115878: LIST
115879: LIST
115880: PPUSH
115881: CALL_OW 69
115885: ST_TO_ADDR
// if not tmp then
115886: LD_VAR 0 1
115890: NOT
115891: IFFALSE 115895
// exit ;
115893: GO 115940
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
115895: LD_VAR 0 1
115899: PUSH
115900: LD_INT 1
115902: PPUSH
115903: LD_VAR 0 1
115907: PPUSH
115908: CALL_OW 12
115912: ARRAY
115913: PPUSH
115914: LD_INT 1
115916: PPUSH
115917: LD_INT 4
115919: PPUSH
115920: CALL_OW 12
115924: PPUSH
115925: LD_INT 3000
115927: PPUSH
115928: LD_INT 9000
115930: PPUSH
115931: CALL_OW 12
115935: PPUSH
115936: CALL_OW 492
// end ;
115940: PPOPN 1
115942: END
// every 0 0$1 trigger StreamModeActive and sDepot do
115943: LD_EXP 143
115947: PUSH
115948: LD_EXP 158
115952: AND
115953: IFFALSE 115973
115955: GO 115957
115957: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
115958: LD_INT 1
115960: PPUSH
115961: LD_OWVAR 2
115965: PPUSH
115966: LD_INT 0
115968: PPUSH
115969: CALL_OW 324
115973: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
115974: LD_EXP 143
115978: PUSH
115979: LD_EXP 159
115983: AND
115984: IFFALSE 116067
115986: GO 115988
115988: DISABLE
115989: LD_INT 0
115991: PPUSH
115992: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
115993: LD_ADDR_VAR 0 2
115997: PUSH
115998: LD_INT 22
116000: PUSH
116001: LD_OWVAR 2
116005: PUSH
116006: EMPTY
116007: LIST
116008: LIST
116009: PUSH
116010: LD_INT 21
116012: PUSH
116013: LD_INT 3
116015: PUSH
116016: EMPTY
116017: LIST
116018: LIST
116019: PUSH
116020: EMPTY
116021: LIST
116022: LIST
116023: PPUSH
116024: CALL_OW 69
116028: ST_TO_ADDR
// if not tmp then
116029: LD_VAR 0 2
116033: NOT
116034: IFFALSE 116038
// exit ;
116036: GO 116067
// for i in tmp do
116038: LD_ADDR_VAR 0 1
116042: PUSH
116043: LD_VAR 0 2
116047: PUSH
116048: FOR_IN
116049: IFFALSE 116065
// SetBLevel ( i , 10 ) ;
116051: LD_VAR 0 1
116055: PPUSH
116056: LD_INT 10
116058: PPUSH
116059: CALL_OW 241
116063: GO 116048
116065: POP
116066: POP
// end ;
116067: PPOPN 2
116069: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
116070: LD_EXP 143
116074: PUSH
116075: LD_EXP 160
116079: AND
116080: IFFALSE 116191
116082: GO 116084
116084: DISABLE
116085: LD_INT 0
116087: PPUSH
116088: PPUSH
116089: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
116090: LD_ADDR_VAR 0 3
116094: PUSH
116095: LD_INT 22
116097: PUSH
116098: LD_OWVAR 2
116102: PUSH
116103: EMPTY
116104: LIST
116105: LIST
116106: PUSH
116107: LD_INT 25
116109: PUSH
116110: LD_INT 1
116112: PUSH
116113: EMPTY
116114: LIST
116115: LIST
116116: PUSH
116117: EMPTY
116118: LIST
116119: LIST
116120: PPUSH
116121: CALL_OW 69
116125: ST_TO_ADDR
// if not tmp then
116126: LD_VAR 0 3
116130: NOT
116131: IFFALSE 116135
// exit ;
116133: GO 116191
// un := tmp [ rand ( 1 , tmp ) ] ;
116135: LD_ADDR_VAR 0 2
116139: PUSH
116140: LD_VAR 0 3
116144: PUSH
116145: LD_INT 1
116147: PPUSH
116148: LD_VAR 0 3
116152: PPUSH
116153: CALL_OW 12
116157: ARRAY
116158: ST_TO_ADDR
// if Crawls ( un ) then
116159: LD_VAR 0 2
116163: PPUSH
116164: CALL_OW 318
116168: IFFALSE 116179
// ComWalk ( un ) ;
116170: LD_VAR 0 2
116174: PPUSH
116175: CALL_OW 138
// SetClass ( un , class_sniper ) ;
116179: LD_VAR 0 2
116183: PPUSH
116184: LD_INT 5
116186: PPUSH
116187: CALL_OW 336
// end ;
116191: PPOPN 3
116193: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
116194: LD_EXP 143
116198: PUSH
116199: LD_EXP 161
116203: AND
116204: PUSH
116205: LD_OWVAR 67
116209: PUSH
116210: LD_INT 4
116212: LESS
116213: AND
116214: IFFALSE 116233
116216: GO 116218
116218: DISABLE
// begin Difficulty := Difficulty + 1 ;
116219: LD_ADDR_OWVAR 67
116223: PUSH
116224: LD_OWVAR 67
116228: PUSH
116229: LD_INT 1
116231: PLUS
116232: ST_TO_ADDR
// end ;
116233: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
116234: LD_EXP 143
116238: PUSH
116239: LD_EXP 162
116243: AND
116244: IFFALSE 116347
116246: GO 116248
116248: DISABLE
116249: LD_INT 0
116251: PPUSH
// begin for i := 1 to 5 do
116252: LD_ADDR_VAR 0 1
116256: PUSH
116257: DOUBLE
116258: LD_INT 1
116260: DEC
116261: ST_TO_ADDR
116262: LD_INT 5
116264: PUSH
116265: FOR_TO
116266: IFFALSE 116345
// begin uc_nation := nation_nature ;
116268: LD_ADDR_OWVAR 21
116272: PUSH
116273: LD_INT 0
116275: ST_TO_ADDR
// uc_side := 0 ;
116276: LD_ADDR_OWVAR 20
116280: PUSH
116281: LD_INT 0
116283: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
116284: LD_ADDR_OWVAR 29
116288: PUSH
116289: LD_INT 12
116291: PUSH
116292: LD_INT 12
116294: PUSH
116295: EMPTY
116296: LIST
116297: LIST
116298: ST_TO_ADDR
// hc_agressivity := 20 ;
116299: LD_ADDR_OWVAR 35
116303: PUSH
116304: LD_INT 20
116306: ST_TO_ADDR
// hc_class := class_tiger ;
116307: LD_ADDR_OWVAR 28
116311: PUSH
116312: LD_INT 14
116314: ST_TO_ADDR
// hc_gallery :=  ;
116315: LD_ADDR_OWVAR 33
116319: PUSH
116320: LD_STRING 
116322: ST_TO_ADDR
// hc_name :=  ;
116323: LD_ADDR_OWVAR 26
116327: PUSH
116328: LD_STRING 
116330: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
116331: CALL_OW 44
116335: PPUSH
116336: LD_INT 0
116338: PPUSH
116339: CALL_OW 51
// end ;
116343: GO 116265
116345: POP
116346: POP
// end ;
116347: PPOPN 1
116349: END
// every 0 0$1 trigger StreamModeActive and sBomb do
116350: LD_EXP 143
116354: PUSH
116355: LD_EXP 163
116359: AND
116360: IFFALSE 116369
116362: GO 116364
116364: DISABLE
// StreamSibBomb ;
116365: CALL 116370 0 0
116369: END
// export function StreamSibBomb ; var i , x , y ; begin
116370: LD_INT 0
116372: PPUSH
116373: PPUSH
116374: PPUSH
116375: PPUSH
// result := false ;
116376: LD_ADDR_VAR 0 1
116380: PUSH
116381: LD_INT 0
116383: ST_TO_ADDR
// for i := 1 to 16 do
116384: LD_ADDR_VAR 0 2
116388: PUSH
116389: DOUBLE
116390: LD_INT 1
116392: DEC
116393: ST_TO_ADDR
116394: LD_INT 16
116396: PUSH
116397: FOR_TO
116398: IFFALSE 116597
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
116400: LD_ADDR_VAR 0 3
116404: PUSH
116405: LD_INT 10
116407: PUSH
116408: LD_INT 20
116410: PUSH
116411: LD_INT 30
116413: PUSH
116414: LD_INT 40
116416: PUSH
116417: LD_INT 50
116419: PUSH
116420: LD_INT 60
116422: PUSH
116423: LD_INT 70
116425: PUSH
116426: LD_INT 80
116428: PUSH
116429: LD_INT 90
116431: PUSH
116432: LD_INT 100
116434: PUSH
116435: LD_INT 110
116437: PUSH
116438: LD_INT 120
116440: PUSH
116441: LD_INT 130
116443: PUSH
116444: LD_INT 140
116446: PUSH
116447: LD_INT 150
116449: PUSH
116450: EMPTY
116451: LIST
116452: LIST
116453: LIST
116454: LIST
116455: LIST
116456: LIST
116457: LIST
116458: LIST
116459: LIST
116460: LIST
116461: LIST
116462: LIST
116463: LIST
116464: LIST
116465: LIST
116466: PUSH
116467: LD_INT 1
116469: PPUSH
116470: LD_INT 15
116472: PPUSH
116473: CALL_OW 12
116477: ARRAY
116478: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
116479: LD_ADDR_VAR 0 4
116483: PUSH
116484: LD_INT 10
116486: PUSH
116487: LD_INT 20
116489: PUSH
116490: LD_INT 30
116492: PUSH
116493: LD_INT 40
116495: PUSH
116496: LD_INT 50
116498: PUSH
116499: LD_INT 60
116501: PUSH
116502: LD_INT 70
116504: PUSH
116505: LD_INT 80
116507: PUSH
116508: LD_INT 90
116510: PUSH
116511: LD_INT 100
116513: PUSH
116514: LD_INT 110
116516: PUSH
116517: LD_INT 120
116519: PUSH
116520: LD_INT 130
116522: PUSH
116523: LD_INT 140
116525: PUSH
116526: LD_INT 150
116528: PUSH
116529: EMPTY
116530: LIST
116531: LIST
116532: LIST
116533: LIST
116534: LIST
116535: LIST
116536: LIST
116537: LIST
116538: LIST
116539: LIST
116540: LIST
116541: LIST
116542: LIST
116543: LIST
116544: LIST
116545: PUSH
116546: LD_INT 1
116548: PPUSH
116549: LD_INT 15
116551: PPUSH
116552: CALL_OW 12
116556: ARRAY
116557: ST_TO_ADDR
// if ValidHex ( x , y ) then
116558: LD_VAR 0 3
116562: PPUSH
116563: LD_VAR 0 4
116567: PPUSH
116568: CALL_OW 488
116572: IFFALSE 116595
// begin result := [ x , y ] ;
116574: LD_ADDR_VAR 0 1
116578: PUSH
116579: LD_VAR 0 3
116583: PUSH
116584: LD_VAR 0 4
116588: PUSH
116589: EMPTY
116590: LIST
116591: LIST
116592: ST_TO_ADDR
// break ;
116593: GO 116597
// end ; end ;
116595: GO 116397
116597: POP
116598: POP
// if result then
116599: LD_VAR 0 1
116603: IFFALSE 116663
// begin ToLua ( playSibBomb() ) ;
116605: LD_STRING playSibBomb()
116607: PPUSH
116608: CALL_OW 559
// wait ( 0 0$14 ) ;
116612: LD_INT 490
116614: PPUSH
116615: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
116619: LD_VAR 0 1
116623: PUSH
116624: LD_INT 1
116626: ARRAY
116627: PPUSH
116628: LD_VAR 0 1
116632: PUSH
116633: LD_INT 2
116635: ARRAY
116636: PPUSH
116637: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
116641: LD_VAR 0 1
116645: PUSH
116646: LD_INT 1
116648: ARRAY
116649: PPUSH
116650: LD_VAR 0 1
116654: PUSH
116655: LD_INT 2
116657: ARRAY
116658: PPUSH
116659: CALL_OW 429
// end ; end ;
116663: LD_VAR 0 1
116667: RET
// every 0 0$1 trigger StreamModeActive and sReset do
116668: LD_EXP 143
116672: PUSH
116673: LD_EXP 165
116677: AND
116678: IFFALSE 116690
116680: GO 116682
116682: DISABLE
// YouLost (  ) ;
116683: LD_STRING 
116685: PPUSH
116686: CALL_OW 104
116690: END
// every 0 0$1 trigger StreamModeActive and sFog do
116691: LD_EXP 143
116695: PUSH
116696: LD_EXP 164
116700: AND
116701: IFFALSE 116715
116703: GO 116705
116705: DISABLE
// FogOff ( your_side ) ;
116706: LD_OWVAR 2
116710: PPUSH
116711: CALL_OW 344
116715: END
// every 0 0$1 trigger StreamModeActive and sSun do
116716: LD_EXP 143
116720: PUSH
116721: LD_EXP 166
116725: AND
116726: IFFALSE 116754
116728: GO 116730
116730: DISABLE
// begin solar_recharge_percent := 0 ;
116731: LD_ADDR_OWVAR 79
116735: PUSH
116736: LD_INT 0
116738: ST_TO_ADDR
// wait ( 5 5$00 ) ;
116739: LD_INT 10500
116741: PPUSH
116742: CALL_OW 67
// solar_recharge_percent := 100 ;
116746: LD_ADDR_OWVAR 79
116750: PUSH
116751: LD_INT 100
116753: ST_TO_ADDR
// end ;
116754: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
116755: LD_EXP 143
116759: PUSH
116760: LD_EXP 167
116764: AND
116765: IFFALSE 117004
116767: GO 116769
116769: DISABLE
116770: LD_INT 0
116772: PPUSH
116773: PPUSH
116774: PPUSH
// begin tmp := [ ] ;
116775: LD_ADDR_VAR 0 3
116779: PUSH
116780: EMPTY
116781: ST_TO_ADDR
// for i := 1 to 6 do
116782: LD_ADDR_VAR 0 1
116786: PUSH
116787: DOUBLE
116788: LD_INT 1
116790: DEC
116791: ST_TO_ADDR
116792: LD_INT 6
116794: PUSH
116795: FOR_TO
116796: IFFALSE 116901
// begin uc_nation := nation_nature ;
116798: LD_ADDR_OWVAR 21
116802: PUSH
116803: LD_INT 0
116805: ST_TO_ADDR
// uc_side := 0 ;
116806: LD_ADDR_OWVAR 20
116810: PUSH
116811: LD_INT 0
116813: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
116814: LD_ADDR_OWVAR 29
116818: PUSH
116819: LD_INT 12
116821: PUSH
116822: LD_INT 12
116824: PUSH
116825: EMPTY
116826: LIST
116827: LIST
116828: ST_TO_ADDR
// hc_agressivity := 20 ;
116829: LD_ADDR_OWVAR 35
116833: PUSH
116834: LD_INT 20
116836: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
116837: LD_ADDR_OWVAR 28
116841: PUSH
116842: LD_INT 17
116844: ST_TO_ADDR
// hc_gallery :=  ;
116845: LD_ADDR_OWVAR 33
116849: PUSH
116850: LD_STRING 
116852: ST_TO_ADDR
// hc_name :=  ;
116853: LD_ADDR_OWVAR 26
116857: PUSH
116858: LD_STRING 
116860: ST_TO_ADDR
// un := CreateHuman ;
116861: LD_ADDR_VAR 0 2
116865: PUSH
116866: CALL_OW 44
116870: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
116871: LD_VAR 0 2
116875: PPUSH
116876: LD_INT 1
116878: PPUSH
116879: CALL_OW 51
// tmp := tmp ^ un ;
116883: LD_ADDR_VAR 0 3
116887: PUSH
116888: LD_VAR 0 3
116892: PUSH
116893: LD_VAR 0 2
116897: ADD
116898: ST_TO_ADDR
// end ;
116899: GO 116795
116901: POP
116902: POP
// repeat wait ( 0 0$1 ) ;
116903: LD_INT 35
116905: PPUSH
116906: CALL_OW 67
// for un in tmp do
116910: LD_ADDR_VAR 0 2
116914: PUSH
116915: LD_VAR 0 3
116919: PUSH
116920: FOR_IN
116921: IFFALSE 116995
// begin if IsDead ( un ) then
116923: LD_VAR 0 2
116927: PPUSH
116928: CALL_OW 301
116932: IFFALSE 116952
// begin tmp := tmp diff un ;
116934: LD_ADDR_VAR 0 3
116938: PUSH
116939: LD_VAR 0 3
116943: PUSH
116944: LD_VAR 0 2
116948: DIFF
116949: ST_TO_ADDR
// continue ;
116950: GO 116920
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
116952: LD_VAR 0 2
116956: PPUSH
116957: LD_INT 3
116959: PUSH
116960: LD_INT 22
116962: PUSH
116963: LD_INT 0
116965: PUSH
116966: EMPTY
116967: LIST
116968: LIST
116969: PUSH
116970: EMPTY
116971: LIST
116972: LIST
116973: PPUSH
116974: CALL_OW 69
116978: PPUSH
116979: LD_VAR 0 2
116983: PPUSH
116984: CALL_OW 74
116988: PPUSH
116989: CALL_OW 115
// end ;
116993: GO 116920
116995: POP
116996: POP
// until not tmp ;
116997: LD_VAR 0 3
117001: NOT
117002: IFFALSE 116903
// end ;
117004: PPOPN 3
117006: END
// every 0 0$1 trigger StreamModeActive and sTroll do
117007: LD_EXP 143
117011: PUSH
117012: LD_EXP 168
117016: AND
117017: IFFALSE 117071
117019: GO 117021
117021: DISABLE
// begin ToLua ( displayTroll(); ) ;
117022: LD_STRING displayTroll();
117024: PPUSH
117025: CALL_OW 559
// wait ( 3 3$00 ) ;
117029: LD_INT 6300
117031: PPUSH
117032: CALL_OW 67
// ToLua ( hideTroll(); ) ;
117036: LD_STRING hideTroll();
117038: PPUSH
117039: CALL_OW 559
// wait ( 1 1$00 ) ;
117043: LD_INT 2100
117045: PPUSH
117046: CALL_OW 67
// ToLua ( displayTroll(); ) ;
117050: LD_STRING displayTroll();
117052: PPUSH
117053: CALL_OW 559
// wait ( 1 1$00 ) ;
117057: LD_INT 2100
117059: PPUSH
117060: CALL_OW 67
// ToLua ( hideTroll(); ) ;
117064: LD_STRING hideTroll();
117066: PPUSH
117067: CALL_OW 559
// end ;
117071: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
117072: LD_EXP 143
117076: PUSH
117077: LD_EXP 169
117081: AND
117082: IFFALSE 117145
117084: GO 117086
117086: DISABLE
117087: LD_INT 0
117089: PPUSH
// begin p := 0 ;
117090: LD_ADDR_VAR 0 1
117094: PUSH
117095: LD_INT 0
117097: ST_TO_ADDR
// repeat game_speed := 1 ;
117098: LD_ADDR_OWVAR 65
117102: PUSH
117103: LD_INT 1
117105: ST_TO_ADDR
// wait ( 0 0$1 ) ;
117106: LD_INT 35
117108: PPUSH
117109: CALL_OW 67
// p := p + 1 ;
117113: LD_ADDR_VAR 0 1
117117: PUSH
117118: LD_VAR 0 1
117122: PUSH
117123: LD_INT 1
117125: PLUS
117126: ST_TO_ADDR
// until p >= 60 ;
117127: LD_VAR 0 1
117131: PUSH
117132: LD_INT 60
117134: GREATEREQUAL
117135: IFFALSE 117098
// game_speed := 4 ;
117137: LD_ADDR_OWVAR 65
117141: PUSH
117142: LD_INT 4
117144: ST_TO_ADDR
// end ;
117145: PPOPN 1
117147: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
117148: LD_EXP 143
117152: PUSH
117153: LD_EXP 170
117157: AND
117158: IFFALSE 117304
117160: GO 117162
117162: DISABLE
117163: LD_INT 0
117165: PPUSH
117166: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
117167: LD_ADDR_VAR 0 1
117171: PUSH
117172: LD_INT 22
117174: PUSH
117175: LD_OWVAR 2
117179: PUSH
117180: EMPTY
117181: LIST
117182: LIST
117183: PUSH
117184: LD_INT 2
117186: PUSH
117187: LD_INT 30
117189: PUSH
117190: LD_INT 0
117192: PUSH
117193: EMPTY
117194: LIST
117195: LIST
117196: PUSH
117197: LD_INT 30
117199: PUSH
117200: LD_INT 1
117202: PUSH
117203: EMPTY
117204: LIST
117205: LIST
117206: PUSH
117207: EMPTY
117208: LIST
117209: LIST
117210: LIST
117211: PUSH
117212: EMPTY
117213: LIST
117214: LIST
117215: PPUSH
117216: CALL_OW 69
117220: ST_TO_ADDR
// if not depot then
117221: LD_VAR 0 1
117225: NOT
117226: IFFALSE 117230
// exit ;
117228: GO 117304
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
117230: LD_ADDR_VAR 0 2
117234: PUSH
117235: LD_VAR 0 1
117239: PUSH
117240: LD_INT 1
117242: PPUSH
117243: LD_VAR 0 1
117247: PPUSH
117248: CALL_OW 12
117252: ARRAY
117253: PPUSH
117254: CALL_OW 274
117258: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
117259: LD_VAR 0 2
117263: PPUSH
117264: LD_INT 1
117266: PPUSH
117267: LD_INT 0
117269: PPUSH
117270: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
117274: LD_VAR 0 2
117278: PPUSH
117279: LD_INT 2
117281: PPUSH
117282: LD_INT 0
117284: PPUSH
117285: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
117289: LD_VAR 0 2
117293: PPUSH
117294: LD_INT 3
117296: PPUSH
117297: LD_INT 0
117299: PPUSH
117300: CALL_OW 277
// end ;
117304: PPOPN 2
117306: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
117307: LD_EXP 143
117311: PUSH
117312: LD_EXP 171
117316: AND
117317: IFFALSE 117414
117319: GO 117321
117321: DISABLE
117322: LD_INT 0
117324: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
117325: LD_ADDR_VAR 0 1
117329: PUSH
117330: LD_INT 22
117332: PUSH
117333: LD_OWVAR 2
117337: PUSH
117338: EMPTY
117339: LIST
117340: LIST
117341: PUSH
117342: LD_INT 21
117344: PUSH
117345: LD_INT 1
117347: PUSH
117348: EMPTY
117349: LIST
117350: LIST
117351: PUSH
117352: LD_INT 3
117354: PUSH
117355: LD_INT 23
117357: PUSH
117358: LD_INT 0
117360: PUSH
117361: EMPTY
117362: LIST
117363: LIST
117364: PUSH
117365: EMPTY
117366: LIST
117367: LIST
117368: PUSH
117369: EMPTY
117370: LIST
117371: LIST
117372: LIST
117373: PPUSH
117374: CALL_OW 69
117378: ST_TO_ADDR
// if not tmp then
117379: LD_VAR 0 1
117383: NOT
117384: IFFALSE 117388
// exit ;
117386: GO 117414
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
117388: LD_VAR 0 1
117392: PUSH
117393: LD_INT 1
117395: PPUSH
117396: LD_VAR 0 1
117400: PPUSH
117401: CALL_OW 12
117405: ARRAY
117406: PPUSH
117407: LD_INT 200
117409: PPUSH
117410: CALL_OW 234
// end ;
117414: PPOPN 1
117416: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
117417: LD_EXP 143
117421: PUSH
117422: LD_EXP 172
117426: AND
117427: IFFALSE 117506
117429: GO 117431
117431: DISABLE
117432: LD_INT 0
117434: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
117435: LD_ADDR_VAR 0 1
117439: PUSH
117440: LD_INT 22
117442: PUSH
117443: LD_OWVAR 2
117447: PUSH
117448: EMPTY
117449: LIST
117450: LIST
117451: PUSH
117452: LD_INT 21
117454: PUSH
117455: LD_INT 2
117457: PUSH
117458: EMPTY
117459: LIST
117460: LIST
117461: PUSH
117462: EMPTY
117463: LIST
117464: LIST
117465: PPUSH
117466: CALL_OW 69
117470: ST_TO_ADDR
// if not tmp then
117471: LD_VAR 0 1
117475: NOT
117476: IFFALSE 117480
// exit ;
117478: GO 117506
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
117480: LD_VAR 0 1
117484: PUSH
117485: LD_INT 1
117487: PPUSH
117488: LD_VAR 0 1
117492: PPUSH
117493: CALL_OW 12
117497: ARRAY
117498: PPUSH
117499: LD_INT 60
117501: PPUSH
117502: CALL_OW 234
// end ;
117506: PPOPN 1
117508: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
117509: LD_EXP 143
117513: PUSH
117514: LD_EXP 173
117518: AND
117519: IFFALSE 117618
117521: GO 117523
117523: DISABLE
117524: LD_INT 0
117526: PPUSH
117527: PPUSH
// begin enable ;
117528: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
117529: LD_ADDR_VAR 0 1
117533: PUSH
117534: LD_INT 22
117536: PUSH
117537: LD_OWVAR 2
117541: PUSH
117542: EMPTY
117543: LIST
117544: LIST
117545: PUSH
117546: LD_INT 61
117548: PUSH
117549: EMPTY
117550: LIST
117551: PUSH
117552: LD_INT 33
117554: PUSH
117555: LD_INT 2
117557: PUSH
117558: EMPTY
117559: LIST
117560: LIST
117561: PUSH
117562: EMPTY
117563: LIST
117564: LIST
117565: LIST
117566: PPUSH
117567: CALL_OW 69
117571: ST_TO_ADDR
// if not tmp then
117572: LD_VAR 0 1
117576: NOT
117577: IFFALSE 117581
// exit ;
117579: GO 117618
// for i in tmp do
117581: LD_ADDR_VAR 0 2
117585: PUSH
117586: LD_VAR 0 1
117590: PUSH
117591: FOR_IN
117592: IFFALSE 117616
// if IsControledBy ( i ) then
117594: LD_VAR 0 2
117598: PPUSH
117599: CALL_OW 312
117603: IFFALSE 117614
// ComUnlink ( i ) ;
117605: LD_VAR 0 2
117609: PPUSH
117610: CALL_OW 136
117614: GO 117591
117616: POP
117617: POP
// end ;
117618: PPOPN 2
117620: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
117621: LD_EXP 143
117625: PUSH
117626: LD_EXP 174
117630: AND
117631: IFFALSE 117771
117633: GO 117635
117635: DISABLE
117636: LD_INT 0
117638: PPUSH
117639: PPUSH
// begin ToLua ( displayPowell(); ) ;
117640: LD_STRING displayPowell();
117642: PPUSH
117643: CALL_OW 559
// uc_side := 0 ;
117647: LD_ADDR_OWVAR 20
117651: PUSH
117652: LD_INT 0
117654: ST_TO_ADDR
// uc_nation := 2 ;
117655: LD_ADDR_OWVAR 21
117659: PUSH
117660: LD_INT 2
117662: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
117663: LD_ADDR_OWVAR 37
117667: PUSH
117668: LD_INT 14
117670: ST_TO_ADDR
// vc_engine := engine_siberite ;
117671: LD_ADDR_OWVAR 39
117675: PUSH
117676: LD_INT 3
117678: ST_TO_ADDR
// vc_control := control_apeman ;
117679: LD_ADDR_OWVAR 38
117683: PUSH
117684: LD_INT 5
117686: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
117687: LD_ADDR_OWVAR 40
117691: PUSH
117692: LD_INT 29
117694: ST_TO_ADDR
// un := CreateVehicle ;
117695: LD_ADDR_VAR 0 2
117699: PUSH
117700: CALL_OW 45
117704: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
117705: LD_VAR 0 2
117709: PPUSH
117710: LD_INT 1
117712: PPUSH
117713: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
117717: LD_INT 35
117719: PPUSH
117720: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
117724: LD_VAR 0 2
117728: PPUSH
117729: LD_INT 22
117731: PUSH
117732: LD_OWVAR 2
117736: PUSH
117737: EMPTY
117738: LIST
117739: LIST
117740: PPUSH
117741: CALL_OW 69
117745: PPUSH
117746: LD_VAR 0 2
117750: PPUSH
117751: CALL_OW 74
117755: PPUSH
117756: CALL_OW 115
// until IsDead ( un ) ;
117760: LD_VAR 0 2
117764: PPUSH
117765: CALL_OW 301
117769: IFFALSE 117717
// end ;
117771: PPOPN 2
117773: END
// every 0 0$1 trigger StreamModeActive and sStu do
117774: LD_EXP 143
117778: PUSH
117779: LD_EXP 182
117783: AND
117784: IFFALSE 117800
117786: GO 117788
117788: DISABLE
// begin ToLua ( displayStucuk(); ) ;
117789: LD_STRING displayStucuk();
117791: PPUSH
117792: CALL_OW 559
// ResetFog ;
117796: CALL_OW 335
// end ;
117800: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
117801: LD_EXP 143
117805: PUSH
117806: LD_EXP 175
117810: AND
117811: IFFALSE 117952
117813: GO 117815
117815: DISABLE
117816: LD_INT 0
117818: PPUSH
117819: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
117820: LD_ADDR_VAR 0 2
117824: PUSH
117825: LD_INT 22
117827: PUSH
117828: LD_OWVAR 2
117832: PUSH
117833: EMPTY
117834: LIST
117835: LIST
117836: PUSH
117837: LD_INT 21
117839: PUSH
117840: LD_INT 1
117842: PUSH
117843: EMPTY
117844: LIST
117845: LIST
117846: PUSH
117847: EMPTY
117848: LIST
117849: LIST
117850: PPUSH
117851: CALL_OW 69
117855: ST_TO_ADDR
// if not tmp then
117856: LD_VAR 0 2
117860: NOT
117861: IFFALSE 117865
// exit ;
117863: GO 117952
// un := tmp [ rand ( 1 , tmp ) ] ;
117865: LD_ADDR_VAR 0 1
117869: PUSH
117870: LD_VAR 0 2
117874: PUSH
117875: LD_INT 1
117877: PPUSH
117878: LD_VAR 0 2
117882: PPUSH
117883: CALL_OW 12
117887: ARRAY
117888: ST_TO_ADDR
// SetSide ( un , 0 ) ;
117889: LD_VAR 0 1
117893: PPUSH
117894: LD_INT 0
117896: PPUSH
117897: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
117901: LD_VAR 0 1
117905: PPUSH
117906: LD_OWVAR 3
117910: PUSH
117911: LD_VAR 0 1
117915: DIFF
117916: PPUSH
117917: LD_VAR 0 1
117921: PPUSH
117922: CALL_OW 74
117926: PPUSH
117927: CALL_OW 115
// wait ( 0 0$20 ) ;
117931: LD_INT 700
117933: PPUSH
117934: CALL_OW 67
// SetSide ( un , your_side ) ;
117938: LD_VAR 0 1
117942: PPUSH
117943: LD_OWVAR 2
117947: PPUSH
117948: CALL_OW 235
// end ;
117952: PPOPN 2
117954: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
117955: LD_EXP 143
117959: PUSH
117960: LD_EXP 176
117964: AND
117965: IFFALSE 118071
117967: GO 117969
117969: DISABLE
117970: LD_INT 0
117972: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
117973: LD_ADDR_VAR 0 1
117977: PUSH
117978: LD_INT 22
117980: PUSH
117981: LD_OWVAR 2
117985: PUSH
117986: EMPTY
117987: LIST
117988: LIST
117989: PUSH
117990: LD_INT 2
117992: PUSH
117993: LD_INT 30
117995: PUSH
117996: LD_INT 0
117998: PUSH
117999: EMPTY
118000: LIST
118001: LIST
118002: PUSH
118003: LD_INT 30
118005: PUSH
118006: LD_INT 1
118008: PUSH
118009: EMPTY
118010: LIST
118011: LIST
118012: PUSH
118013: EMPTY
118014: LIST
118015: LIST
118016: LIST
118017: PUSH
118018: EMPTY
118019: LIST
118020: LIST
118021: PPUSH
118022: CALL_OW 69
118026: ST_TO_ADDR
// if not depot then
118027: LD_VAR 0 1
118031: NOT
118032: IFFALSE 118036
// exit ;
118034: GO 118071
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
118036: LD_VAR 0 1
118040: PUSH
118041: LD_INT 1
118043: ARRAY
118044: PPUSH
118045: CALL_OW 250
118049: PPUSH
118050: LD_VAR 0 1
118054: PUSH
118055: LD_INT 1
118057: ARRAY
118058: PPUSH
118059: CALL_OW 251
118063: PPUSH
118064: LD_INT 70
118066: PPUSH
118067: CALL_OW 495
// end ;
118071: PPOPN 1
118073: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
118074: LD_EXP 143
118078: PUSH
118079: LD_EXP 177
118083: AND
118084: IFFALSE 118295
118086: GO 118088
118088: DISABLE
118089: LD_INT 0
118091: PPUSH
118092: PPUSH
118093: PPUSH
118094: PPUSH
118095: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
118096: LD_ADDR_VAR 0 5
118100: PUSH
118101: LD_INT 22
118103: PUSH
118104: LD_OWVAR 2
118108: PUSH
118109: EMPTY
118110: LIST
118111: LIST
118112: PUSH
118113: LD_INT 21
118115: PUSH
118116: LD_INT 1
118118: PUSH
118119: EMPTY
118120: LIST
118121: LIST
118122: PUSH
118123: EMPTY
118124: LIST
118125: LIST
118126: PPUSH
118127: CALL_OW 69
118131: ST_TO_ADDR
// if not tmp then
118132: LD_VAR 0 5
118136: NOT
118137: IFFALSE 118141
// exit ;
118139: GO 118295
// for i in tmp do
118141: LD_ADDR_VAR 0 1
118145: PUSH
118146: LD_VAR 0 5
118150: PUSH
118151: FOR_IN
118152: IFFALSE 118293
// begin d := rand ( 0 , 5 ) ;
118154: LD_ADDR_VAR 0 4
118158: PUSH
118159: LD_INT 0
118161: PPUSH
118162: LD_INT 5
118164: PPUSH
118165: CALL_OW 12
118169: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
118170: LD_ADDR_VAR 0 2
118174: PUSH
118175: LD_VAR 0 1
118179: PPUSH
118180: CALL_OW 250
118184: PPUSH
118185: LD_VAR 0 4
118189: PPUSH
118190: LD_INT 3
118192: PPUSH
118193: LD_INT 12
118195: PPUSH
118196: CALL_OW 12
118200: PPUSH
118201: CALL_OW 272
118205: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
118206: LD_ADDR_VAR 0 3
118210: PUSH
118211: LD_VAR 0 1
118215: PPUSH
118216: CALL_OW 251
118220: PPUSH
118221: LD_VAR 0 4
118225: PPUSH
118226: LD_INT 3
118228: PPUSH
118229: LD_INT 12
118231: PPUSH
118232: CALL_OW 12
118236: PPUSH
118237: CALL_OW 273
118241: ST_TO_ADDR
// if ValidHex ( x , y ) then
118242: LD_VAR 0 2
118246: PPUSH
118247: LD_VAR 0 3
118251: PPUSH
118252: CALL_OW 488
118256: IFFALSE 118291
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
118258: LD_VAR 0 1
118262: PPUSH
118263: LD_VAR 0 2
118267: PPUSH
118268: LD_VAR 0 3
118272: PPUSH
118273: LD_INT 3
118275: PPUSH
118276: LD_INT 6
118278: PPUSH
118279: CALL_OW 12
118283: PPUSH
118284: LD_INT 1
118286: PPUSH
118287: CALL_OW 483
// end ;
118291: GO 118151
118293: POP
118294: POP
// end ;
118295: PPOPN 5
118297: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
118298: LD_EXP 143
118302: PUSH
118303: LD_EXP 178
118307: AND
118308: IFFALSE 118402
118310: GO 118312
118312: DISABLE
118313: LD_INT 0
118315: PPUSH
118316: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
118317: LD_ADDR_VAR 0 2
118321: PUSH
118322: LD_INT 22
118324: PUSH
118325: LD_OWVAR 2
118329: PUSH
118330: EMPTY
118331: LIST
118332: LIST
118333: PUSH
118334: LD_INT 32
118336: PUSH
118337: LD_INT 1
118339: PUSH
118340: EMPTY
118341: LIST
118342: LIST
118343: PUSH
118344: LD_INT 21
118346: PUSH
118347: LD_INT 2
118349: PUSH
118350: EMPTY
118351: LIST
118352: LIST
118353: PUSH
118354: EMPTY
118355: LIST
118356: LIST
118357: LIST
118358: PPUSH
118359: CALL_OW 69
118363: ST_TO_ADDR
// if not tmp then
118364: LD_VAR 0 2
118368: NOT
118369: IFFALSE 118373
// exit ;
118371: GO 118402
// for i in tmp do
118373: LD_ADDR_VAR 0 1
118377: PUSH
118378: LD_VAR 0 2
118382: PUSH
118383: FOR_IN
118384: IFFALSE 118400
// SetFuel ( i , 0 ) ;
118386: LD_VAR 0 1
118390: PPUSH
118391: LD_INT 0
118393: PPUSH
118394: CALL_OW 240
118398: GO 118383
118400: POP
118401: POP
// end ;
118402: PPOPN 2
118404: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
118405: LD_EXP 143
118409: PUSH
118410: LD_EXP 179
118414: AND
118415: IFFALSE 118481
118417: GO 118419
118419: DISABLE
118420: LD_INT 0
118422: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
118423: LD_ADDR_VAR 0 1
118427: PUSH
118428: LD_INT 22
118430: PUSH
118431: LD_OWVAR 2
118435: PUSH
118436: EMPTY
118437: LIST
118438: LIST
118439: PUSH
118440: LD_INT 30
118442: PUSH
118443: LD_INT 29
118445: PUSH
118446: EMPTY
118447: LIST
118448: LIST
118449: PUSH
118450: EMPTY
118451: LIST
118452: LIST
118453: PPUSH
118454: CALL_OW 69
118458: ST_TO_ADDR
// if not tmp then
118459: LD_VAR 0 1
118463: NOT
118464: IFFALSE 118468
// exit ;
118466: GO 118481
// DestroyUnit ( tmp [ 1 ] ) ;
118468: LD_VAR 0 1
118472: PUSH
118473: LD_INT 1
118475: ARRAY
118476: PPUSH
118477: CALL_OW 65
// end ;
118481: PPOPN 1
118483: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
118484: LD_EXP 143
118488: PUSH
118489: LD_EXP 181
118493: AND
118494: IFFALSE 118623
118496: GO 118498
118498: DISABLE
118499: LD_INT 0
118501: PPUSH
// begin uc_side := 0 ;
118502: LD_ADDR_OWVAR 20
118506: PUSH
118507: LD_INT 0
118509: ST_TO_ADDR
// uc_nation := nation_arabian ;
118510: LD_ADDR_OWVAR 21
118514: PUSH
118515: LD_INT 2
118517: ST_TO_ADDR
// hc_gallery :=  ;
118518: LD_ADDR_OWVAR 33
118522: PUSH
118523: LD_STRING 
118525: ST_TO_ADDR
// hc_name :=  ;
118526: LD_ADDR_OWVAR 26
118530: PUSH
118531: LD_STRING 
118533: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
118534: LD_INT 1
118536: PPUSH
118537: LD_INT 11
118539: PPUSH
118540: LD_INT 10
118542: PPUSH
118543: CALL_OW 380
// un := CreateHuman ;
118547: LD_ADDR_VAR 0 1
118551: PUSH
118552: CALL_OW 44
118556: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
118557: LD_VAR 0 1
118561: PPUSH
118562: LD_INT 1
118564: PPUSH
118565: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
118569: LD_INT 35
118571: PPUSH
118572: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
118576: LD_VAR 0 1
118580: PPUSH
118581: LD_INT 22
118583: PUSH
118584: LD_OWVAR 2
118588: PUSH
118589: EMPTY
118590: LIST
118591: LIST
118592: PPUSH
118593: CALL_OW 69
118597: PPUSH
118598: LD_VAR 0 1
118602: PPUSH
118603: CALL_OW 74
118607: PPUSH
118608: CALL_OW 115
// until IsDead ( un ) ;
118612: LD_VAR 0 1
118616: PPUSH
118617: CALL_OW 301
118621: IFFALSE 118569
// end ;
118623: PPOPN 1
118625: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
118626: LD_EXP 143
118630: PUSH
118631: LD_EXP 183
118635: AND
118636: IFFALSE 118648
118638: GO 118640
118640: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
118641: LD_STRING earthquake(getX(game), 0, 32)
118643: PPUSH
118644: CALL_OW 559
118648: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
118649: LD_EXP 143
118653: PUSH
118654: LD_EXP 184
118658: AND
118659: IFFALSE 118750
118661: GO 118663
118663: DISABLE
118664: LD_INT 0
118666: PPUSH
// begin enable ;
118667: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
118668: LD_ADDR_VAR 0 1
118672: PUSH
118673: LD_INT 22
118675: PUSH
118676: LD_OWVAR 2
118680: PUSH
118681: EMPTY
118682: LIST
118683: LIST
118684: PUSH
118685: LD_INT 21
118687: PUSH
118688: LD_INT 2
118690: PUSH
118691: EMPTY
118692: LIST
118693: LIST
118694: PUSH
118695: LD_INT 33
118697: PUSH
118698: LD_INT 3
118700: PUSH
118701: EMPTY
118702: LIST
118703: LIST
118704: PUSH
118705: EMPTY
118706: LIST
118707: LIST
118708: LIST
118709: PPUSH
118710: CALL_OW 69
118714: ST_TO_ADDR
// if not tmp then
118715: LD_VAR 0 1
118719: NOT
118720: IFFALSE 118724
// exit ;
118722: GO 118750
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
118724: LD_VAR 0 1
118728: PUSH
118729: LD_INT 1
118731: PPUSH
118732: LD_VAR 0 1
118736: PPUSH
118737: CALL_OW 12
118741: ARRAY
118742: PPUSH
118743: LD_INT 1
118745: PPUSH
118746: CALL_OW 234
// end ;
118750: PPOPN 1
118752: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
118753: LD_EXP 143
118757: PUSH
118758: LD_EXP 185
118762: AND
118763: IFFALSE 118904
118765: GO 118767
118767: DISABLE
118768: LD_INT 0
118770: PPUSH
118771: PPUSH
118772: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
118773: LD_ADDR_VAR 0 3
118777: PUSH
118778: LD_INT 22
118780: PUSH
118781: LD_OWVAR 2
118785: PUSH
118786: EMPTY
118787: LIST
118788: LIST
118789: PUSH
118790: LD_INT 25
118792: PUSH
118793: LD_INT 1
118795: PUSH
118796: EMPTY
118797: LIST
118798: LIST
118799: PUSH
118800: EMPTY
118801: LIST
118802: LIST
118803: PPUSH
118804: CALL_OW 69
118808: ST_TO_ADDR
// if not tmp then
118809: LD_VAR 0 3
118813: NOT
118814: IFFALSE 118818
// exit ;
118816: GO 118904
// un := tmp [ rand ( 1 , tmp ) ] ;
118818: LD_ADDR_VAR 0 2
118822: PUSH
118823: LD_VAR 0 3
118827: PUSH
118828: LD_INT 1
118830: PPUSH
118831: LD_VAR 0 3
118835: PPUSH
118836: CALL_OW 12
118840: ARRAY
118841: ST_TO_ADDR
// if Crawls ( un ) then
118842: LD_VAR 0 2
118846: PPUSH
118847: CALL_OW 318
118851: IFFALSE 118862
// ComWalk ( un ) ;
118853: LD_VAR 0 2
118857: PPUSH
118858: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
118862: LD_VAR 0 2
118866: PPUSH
118867: LD_INT 9
118869: PPUSH
118870: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
118874: LD_INT 28
118876: PPUSH
118877: LD_OWVAR 2
118881: PPUSH
118882: LD_INT 2
118884: PPUSH
118885: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
118889: LD_INT 29
118891: PPUSH
118892: LD_OWVAR 2
118896: PPUSH
118897: LD_INT 2
118899: PPUSH
118900: CALL_OW 322
// end ;
118904: PPOPN 3
118906: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
118907: LD_EXP 143
118911: PUSH
118912: LD_EXP 186
118916: AND
118917: IFFALSE 119028
118919: GO 118921
118921: DISABLE
118922: LD_INT 0
118924: PPUSH
118925: PPUSH
118926: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
118927: LD_ADDR_VAR 0 3
118931: PUSH
118932: LD_INT 22
118934: PUSH
118935: LD_OWVAR 2
118939: PUSH
118940: EMPTY
118941: LIST
118942: LIST
118943: PUSH
118944: LD_INT 25
118946: PUSH
118947: LD_INT 1
118949: PUSH
118950: EMPTY
118951: LIST
118952: LIST
118953: PUSH
118954: EMPTY
118955: LIST
118956: LIST
118957: PPUSH
118958: CALL_OW 69
118962: ST_TO_ADDR
// if not tmp then
118963: LD_VAR 0 3
118967: NOT
118968: IFFALSE 118972
// exit ;
118970: GO 119028
// un := tmp [ rand ( 1 , tmp ) ] ;
118972: LD_ADDR_VAR 0 2
118976: PUSH
118977: LD_VAR 0 3
118981: PUSH
118982: LD_INT 1
118984: PPUSH
118985: LD_VAR 0 3
118989: PPUSH
118990: CALL_OW 12
118994: ARRAY
118995: ST_TO_ADDR
// if Crawls ( un ) then
118996: LD_VAR 0 2
119000: PPUSH
119001: CALL_OW 318
119005: IFFALSE 119016
// ComWalk ( un ) ;
119007: LD_VAR 0 2
119011: PPUSH
119012: CALL_OW 138
// SetClass ( un , class_mortar ) ;
119016: LD_VAR 0 2
119020: PPUSH
119021: LD_INT 8
119023: PPUSH
119024: CALL_OW 336
// end ;
119028: PPOPN 3
119030: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
119031: LD_EXP 143
119035: PUSH
119036: LD_EXP 187
119040: AND
119041: IFFALSE 119185
119043: GO 119045
119045: DISABLE
119046: LD_INT 0
119048: PPUSH
119049: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
119050: LD_ADDR_VAR 0 2
119054: PUSH
119055: LD_INT 22
119057: PUSH
119058: LD_OWVAR 2
119062: PUSH
119063: EMPTY
119064: LIST
119065: LIST
119066: PUSH
119067: LD_INT 21
119069: PUSH
119070: LD_INT 2
119072: PUSH
119073: EMPTY
119074: LIST
119075: LIST
119076: PUSH
119077: LD_INT 2
119079: PUSH
119080: LD_INT 34
119082: PUSH
119083: LD_INT 12
119085: PUSH
119086: EMPTY
119087: LIST
119088: LIST
119089: PUSH
119090: LD_INT 34
119092: PUSH
119093: LD_INT 51
119095: PUSH
119096: EMPTY
119097: LIST
119098: LIST
119099: PUSH
119100: LD_INT 34
119102: PUSH
119103: LD_INT 32
119105: PUSH
119106: EMPTY
119107: LIST
119108: LIST
119109: PUSH
119110: EMPTY
119111: LIST
119112: LIST
119113: LIST
119114: LIST
119115: PUSH
119116: EMPTY
119117: LIST
119118: LIST
119119: LIST
119120: PPUSH
119121: CALL_OW 69
119125: ST_TO_ADDR
// if not tmp then
119126: LD_VAR 0 2
119130: NOT
119131: IFFALSE 119135
// exit ;
119133: GO 119185
// for i in tmp do
119135: LD_ADDR_VAR 0 1
119139: PUSH
119140: LD_VAR 0 2
119144: PUSH
119145: FOR_IN
119146: IFFALSE 119183
// if GetCargo ( i , mat_artifact ) = 0 then
119148: LD_VAR 0 1
119152: PPUSH
119153: LD_INT 4
119155: PPUSH
119156: CALL_OW 289
119160: PUSH
119161: LD_INT 0
119163: EQUAL
119164: IFFALSE 119181
// SetCargo ( i , mat_siberit , 100 ) ;
119166: LD_VAR 0 1
119170: PPUSH
119171: LD_INT 3
119173: PPUSH
119174: LD_INT 100
119176: PPUSH
119177: CALL_OW 290
119181: GO 119145
119183: POP
119184: POP
// end ;
119185: PPOPN 2
119187: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
119188: LD_EXP 143
119192: PUSH
119193: LD_EXP 188
119197: AND
119198: IFFALSE 119381
119200: GO 119202
119202: DISABLE
119203: LD_INT 0
119205: PPUSH
119206: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
119207: LD_ADDR_VAR 0 2
119211: PUSH
119212: LD_INT 22
119214: PUSH
119215: LD_OWVAR 2
119219: PUSH
119220: EMPTY
119221: LIST
119222: LIST
119223: PPUSH
119224: CALL_OW 69
119228: ST_TO_ADDR
// if not tmp then
119229: LD_VAR 0 2
119233: NOT
119234: IFFALSE 119238
// exit ;
119236: GO 119381
// for i := 1 to 2 do
119238: LD_ADDR_VAR 0 1
119242: PUSH
119243: DOUBLE
119244: LD_INT 1
119246: DEC
119247: ST_TO_ADDR
119248: LD_INT 2
119250: PUSH
119251: FOR_TO
119252: IFFALSE 119379
// begin uc_side := your_side ;
119254: LD_ADDR_OWVAR 20
119258: PUSH
119259: LD_OWVAR 2
119263: ST_TO_ADDR
// uc_nation := nation_american ;
119264: LD_ADDR_OWVAR 21
119268: PUSH
119269: LD_INT 1
119271: ST_TO_ADDR
// vc_chassis := us_morphling ;
119272: LD_ADDR_OWVAR 37
119276: PUSH
119277: LD_INT 5
119279: ST_TO_ADDR
// vc_engine := engine_siberite ;
119280: LD_ADDR_OWVAR 39
119284: PUSH
119285: LD_INT 3
119287: ST_TO_ADDR
// vc_control := control_computer ;
119288: LD_ADDR_OWVAR 38
119292: PUSH
119293: LD_INT 3
119295: ST_TO_ADDR
// vc_weapon := us_double_laser ;
119296: LD_ADDR_OWVAR 40
119300: PUSH
119301: LD_INT 10
119303: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
119304: LD_VAR 0 2
119308: PUSH
119309: LD_INT 1
119311: ARRAY
119312: PPUSH
119313: CALL_OW 310
119317: NOT
119318: IFFALSE 119365
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
119320: CALL_OW 45
119324: PPUSH
119325: LD_VAR 0 2
119329: PUSH
119330: LD_INT 1
119332: ARRAY
119333: PPUSH
119334: CALL_OW 250
119338: PPUSH
119339: LD_VAR 0 2
119343: PUSH
119344: LD_INT 1
119346: ARRAY
119347: PPUSH
119348: CALL_OW 251
119352: PPUSH
119353: LD_INT 12
119355: PPUSH
119356: LD_INT 1
119358: PPUSH
119359: CALL_OW 50
119363: GO 119377
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
119365: CALL_OW 45
119369: PPUSH
119370: LD_INT 1
119372: PPUSH
119373: CALL_OW 51
// end ;
119377: GO 119251
119379: POP
119380: POP
// end ;
119381: PPOPN 2
119383: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
119384: LD_EXP 143
119388: PUSH
119389: LD_EXP 189
119393: AND
119394: IFFALSE 119616
119396: GO 119398
119398: DISABLE
119399: LD_INT 0
119401: PPUSH
119402: PPUSH
119403: PPUSH
119404: PPUSH
119405: PPUSH
119406: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
119407: LD_ADDR_VAR 0 6
119411: PUSH
119412: LD_INT 22
119414: PUSH
119415: LD_OWVAR 2
119419: PUSH
119420: EMPTY
119421: LIST
119422: LIST
119423: PUSH
119424: LD_INT 21
119426: PUSH
119427: LD_INT 1
119429: PUSH
119430: EMPTY
119431: LIST
119432: LIST
119433: PUSH
119434: LD_INT 3
119436: PUSH
119437: LD_INT 23
119439: PUSH
119440: LD_INT 0
119442: PUSH
119443: EMPTY
119444: LIST
119445: LIST
119446: PUSH
119447: EMPTY
119448: LIST
119449: LIST
119450: PUSH
119451: EMPTY
119452: LIST
119453: LIST
119454: LIST
119455: PPUSH
119456: CALL_OW 69
119460: ST_TO_ADDR
// if not tmp then
119461: LD_VAR 0 6
119465: NOT
119466: IFFALSE 119470
// exit ;
119468: GO 119616
// s1 := rand ( 1 , 4 ) ;
119470: LD_ADDR_VAR 0 2
119474: PUSH
119475: LD_INT 1
119477: PPUSH
119478: LD_INT 4
119480: PPUSH
119481: CALL_OW 12
119485: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
119486: LD_ADDR_VAR 0 4
119490: PUSH
119491: LD_VAR 0 6
119495: PUSH
119496: LD_INT 1
119498: ARRAY
119499: PPUSH
119500: LD_VAR 0 2
119504: PPUSH
119505: CALL_OW 259
119509: ST_TO_ADDR
// if s1 = 1 then
119510: LD_VAR 0 2
119514: PUSH
119515: LD_INT 1
119517: EQUAL
119518: IFFALSE 119538
// s2 := rand ( 2 , 4 ) else
119520: LD_ADDR_VAR 0 3
119524: PUSH
119525: LD_INT 2
119527: PPUSH
119528: LD_INT 4
119530: PPUSH
119531: CALL_OW 12
119535: ST_TO_ADDR
119536: GO 119546
// s2 := 1 ;
119538: LD_ADDR_VAR 0 3
119542: PUSH
119543: LD_INT 1
119545: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
119546: LD_ADDR_VAR 0 5
119550: PUSH
119551: LD_VAR 0 6
119555: PUSH
119556: LD_INT 1
119558: ARRAY
119559: PPUSH
119560: LD_VAR 0 3
119564: PPUSH
119565: CALL_OW 259
119569: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
119570: LD_VAR 0 6
119574: PUSH
119575: LD_INT 1
119577: ARRAY
119578: PPUSH
119579: LD_VAR 0 2
119583: PPUSH
119584: LD_VAR 0 5
119588: PPUSH
119589: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
119593: LD_VAR 0 6
119597: PUSH
119598: LD_INT 1
119600: ARRAY
119601: PPUSH
119602: LD_VAR 0 3
119606: PPUSH
119607: LD_VAR 0 4
119611: PPUSH
119612: CALL_OW 237
// end ;
119616: PPOPN 6
119618: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
119619: LD_EXP 143
119623: PUSH
119624: LD_EXP 190
119628: AND
119629: IFFALSE 119708
119631: GO 119633
119633: DISABLE
119634: LD_INT 0
119636: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
119637: LD_ADDR_VAR 0 1
119641: PUSH
119642: LD_INT 22
119644: PUSH
119645: LD_OWVAR 2
119649: PUSH
119650: EMPTY
119651: LIST
119652: LIST
119653: PUSH
119654: LD_INT 30
119656: PUSH
119657: LD_INT 3
119659: PUSH
119660: EMPTY
119661: LIST
119662: LIST
119663: PUSH
119664: EMPTY
119665: LIST
119666: LIST
119667: PPUSH
119668: CALL_OW 69
119672: ST_TO_ADDR
// if not tmp then
119673: LD_VAR 0 1
119677: NOT
119678: IFFALSE 119682
// exit ;
119680: GO 119708
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
119682: LD_VAR 0 1
119686: PUSH
119687: LD_INT 1
119689: PPUSH
119690: LD_VAR 0 1
119694: PPUSH
119695: CALL_OW 12
119699: ARRAY
119700: PPUSH
119701: LD_INT 1
119703: PPUSH
119704: CALL_OW 234
// end ;
119708: PPOPN 1
119710: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
119711: LD_EXP 143
119715: PUSH
119716: LD_EXP 191
119720: AND
119721: IFFALSE 119833
119723: GO 119725
119725: DISABLE
119726: LD_INT 0
119728: PPUSH
119729: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
119730: LD_ADDR_VAR 0 2
119734: PUSH
119735: LD_INT 22
119737: PUSH
119738: LD_OWVAR 2
119742: PUSH
119743: EMPTY
119744: LIST
119745: LIST
119746: PUSH
119747: LD_INT 2
119749: PUSH
119750: LD_INT 30
119752: PUSH
119753: LD_INT 27
119755: PUSH
119756: EMPTY
119757: LIST
119758: LIST
119759: PUSH
119760: LD_INT 30
119762: PUSH
119763: LD_INT 26
119765: PUSH
119766: EMPTY
119767: LIST
119768: LIST
119769: PUSH
119770: LD_INT 30
119772: PUSH
119773: LD_INT 28
119775: PUSH
119776: EMPTY
119777: LIST
119778: LIST
119779: PUSH
119780: EMPTY
119781: LIST
119782: LIST
119783: LIST
119784: LIST
119785: PUSH
119786: EMPTY
119787: LIST
119788: LIST
119789: PPUSH
119790: CALL_OW 69
119794: ST_TO_ADDR
// if not tmp then
119795: LD_VAR 0 2
119799: NOT
119800: IFFALSE 119804
// exit ;
119802: GO 119833
// for i in tmp do
119804: LD_ADDR_VAR 0 1
119808: PUSH
119809: LD_VAR 0 2
119813: PUSH
119814: FOR_IN
119815: IFFALSE 119831
// SetLives ( i , 1 ) ;
119817: LD_VAR 0 1
119821: PPUSH
119822: LD_INT 1
119824: PPUSH
119825: CALL_OW 234
119829: GO 119814
119831: POP
119832: POP
// end ;
119833: PPOPN 2
119835: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
119836: LD_EXP 143
119840: PUSH
119841: LD_EXP 192
119845: AND
119846: IFFALSE 120133
119848: GO 119850
119850: DISABLE
119851: LD_INT 0
119853: PPUSH
119854: PPUSH
119855: PPUSH
// begin i := rand ( 1 , 7 ) ;
119856: LD_ADDR_VAR 0 1
119860: PUSH
119861: LD_INT 1
119863: PPUSH
119864: LD_INT 7
119866: PPUSH
119867: CALL_OW 12
119871: ST_TO_ADDR
// case i of 1 :
119872: LD_VAR 0 1
119876: PUSH
119877: LD_INT 1
119879: DOUBLE
119880: EQUAL
119881: IFTRUE 119885
119883: GO 119895
119885: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
119886: LD_STRING earthquake(getX(game), 0, 32)
119888: PPUSH
119889: CALL_OW 559
119893: GO 120133
119895: LD_INT 2
119897: DOUBLE
119898: EQUAL
119899: IFTRUE 119903
119901: GO 119917
119903: POP
// begin ToLua ( displayStucuk(); ) ;
119904: LD_STRING displayStucuk();
119906: PPUSH
119907: CALL_OW 559
// ResetFog ;
119911: CALL_OW 335
// end ; 3 :
119915: GO 120133
119917: LD_INT 3
119919: DOUBLE
119920: EQUAL
119921: IFTRUE 119925
119923: GO 120029
119925: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
119926: LD_ADDR_VAR 0 2
119930: PUSH
119931: LD_INT 22
119933: PUSH
119934: LD_OWVAR 2
119938: PUSH
119939: EMPTY
119940: LIST
119941: LIST
119942: PUSH
119943: LD_INT 25
119945: PUSH
119946: LD_INT 1
119948: PUSH
119949: EMPTY
119950: LIST
119951: LIST
119952: PUSH
119953: EMPTY
119954: LIST
119955: LIST
119956: PPUSH
119957: CALL_OW 69
119961: ST_TO_ADDR
// if not tmp then
119962: LD_VAR 0 2
119966: NOT
119967: IFFALSE 119971
// exit ;
119969: GO 120133
// un := tmp [ rand ( 1 , tmp ) ] ;
119971: LD_ADDR_VAR 0 3
119975: PUSH
119976: LD_VAR 0 2
119980: PUSH
119981: LD_INT 1
119983: PPUSH
119984: LD_VAR 0 2
119988: PPUSH
119989: CALL_OW 12
119993: ARRAY
119994: ST_TO_ADDR
// if Crawls ( un ) then
119995: LD_VAR 0 3
119999: PPUSH
120000: CALL_OW 318
120004: IFFALSE 120015
// ComWalk ( un ) ;
120006: LD_VAR 0 3
120010: PPUSH
120011: CALL_OW 138
// SetClass ( un , class_mortar ) ;
120015: LD_VAR 0 3
120019: PPUSH
120020: LD_INT 8
120022: PPUSH
120023: CALL_OW 336
// end ; 4 :
120027: GO 120133
120029: LD_INT 4
120031: DOUBLE
120032: EQUAL
120033: IFTRUE 120037
120035: GO 120111
120037: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
120038: LD_ADDR_VAR 0 2
120042: PUSH
120043: LD_INT 22
120045: PUSH
120046: LD_OWVAR 2
120050: PUSH
120051: EMPTY
120052: LIST
120053: LIST
120054: PUSH
120055: LD_INT 30
120057: PUSH
120058: LD_INT 29
120060: PUSH
120061: EMPTY
120062: LIST
120063: LIST
120064: PUSH
120065: EMPTY
120066: LIST
120067: LIST
120068: PPUSH
120069: CALL_OW 69
120073: ST_TO_ADDR
// if not tmp then
120074: LD_VAR 0 2
120078: NOT
120079: IFFALSE 120083
// exit ;
120081: GO 120133
// CenterNowOnUnits ( tmp [ 1 ] ) ;
120083: LD_VAR 0 2
120087: PUSH
120088: LD_INT 1
120090: ARRAY
120091: PPUSH
120092: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
120096: LD_VAR 0 2
120100: PUSH
120101: LD_INT 1
120103: ARRAY
120104: PPUSH
120105: CALL_OW 65
// end ; 5 .. 7 :
120109: GO 120133
120111: LD_INT 5
120113: DOUBLE
120114: GREATEREQUAL
120115: IFFALSE 120123
120117: LD_INT 7
120119: DOUBLE
120120: LESSEQUAL
120121: IFTRUE 120125
120123: GO 120132
120125: POP
// StreamSibBomb ; end ;
120126: CALL 116370 0 0
120130: GO 120133
120132: POP
// end ;
120133: PPOPN 3
120135: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
120136: LD_EXP 143
120140: PUSH
120141: LD_EXP 193
120145: AND
120146: IFFALSE 120302
120148: GO 120150
120150: DISABLE
120151: LD_INT 0
120153: PPUSH
120154: PPUSH
120155: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
120156: LD_ADDR_VAR 0 2
120160: PUSH
120161: LD_INT 81
120163: PUSH
120164: LD_OWVAR 2
120168: PUSH
120169: EMPTY
120170: LIST
120171: LIST
120172: PUSH
120173: LD_INT 2
120175: PUSH
120176: LD_INT 21
120178: PUSH
120179: LD_INT 1
120181: PUSH
120182: EMPTY
120183: LIST
120184: LIST
120185: PUSH
120186: LD_INT 21
120188: PUSH
120189: LD_INT 2
120191: PUSH
120192: EMPTY
120193: LIST
120194: LIST
120195: PUSH
120196: EMPTY
120197: LIST
120198: LIST
120199: LIST
120200: PUSH
120201: EMPTY
120202: LIST
120203: LIST
120204: PPUSH
120205: CALL_OW 69
120209: ST_TO_ADDR
// if not tmp then
120210: LD_VAR 0 2
120214: NOT
120215: IFFALSE 120219
// exit ;
120217: GO 120302
// p := 0 ;
120219: LD_ADDR_VAR 0 3
120223: PUSH
120224: LD_INT 0
120226: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
120227: LD_INT 35
120229: PPUSH
120230: CALL_OW 67
// p := p + 1 ;
120234: LD_ADDR_VAR 0 3
120238: PUSH
120239: LD_VAR 0 3
120243: PUSH
120244: LD_INT 1
120246: PLUS
120247: ST_TO_ADDR
// for i in tmp do
120248: LD_ADDR_VAR 0 1
120252: PUSH
120253: LD_VAR 0 2
120257: PUSH
120258: FOR_IN
120259: IFFALSE 120290
// if GetLives ( i ) < 1000 then
120261: LD_VAR 0 1
120265: PPUSH
120266: CALL_OW 256
120270: PUSH
120271: LD_INT 1000
120273: LESS
120274: IFFALSE 120288
// SetLives ( i , 1000 ) ;
120276: LD_VAR 0 1
120280: PPUSH
120281: LD_INT 1000
120283: PPUSH
120284: CALL_OW 234
120288: GO 120258
120290: POP
120291: POP
// until p > 20 ;
120292: LD_VAR 0 3
120296: PUSH
120297: LD_INT 20
120299: GREATER
120300: IFFALSE 120227
// end ;
120302: PPOPN 3
120304: END
// every 0 0$1 trigger StreamModeActive and sTime do
120305: LD_EXP 143
120309: PUSH
120310: LD_EXP 194
120314: AND
120315: IFFALSE 120350
120317: GO 120319
120319: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
120320: LD_INT 28
120322: PPUSH
120323: LD_OWVAR 2
120327: PPUSH
120328: LD_INT 2
120330: PPUSH
120331: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
120335: LD_INT 30
120337: PPUSH
120338: LD_OWVAR 2
120342: PPUSH
120343: LD_INT 2
120345: PPUSH
120346: CALL_OW 322
// end ;
120350: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
120351: LD_EXP 143
120355: PUSH
120356: LD_EXP 195
120360: AND
120361: IFFALSE 120482
120363: GO 120365
120365: DISABLE
120366: LD_INT 0
120368: PPUSH
120369: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
120370: LD_ADDR_VAR 0 2
120374: PUSH
120375: LD_INT 22
120377: PUSH
120378: LD_OWVAR 2
120382: PUSH
120383: EMPTY
120384: LIST
120385: LIST
120386: PUSH
120387: LD_INT 21
120389: PUSH
120390: LD_INT 1
120392: PUSH
120393: EMPTY
120394: LIST
120395: LIST
120396: PUSH
120397: LD_INT 3
120399: PUSH
120400: LD_INT 23
120402: PUSH
120403: LD_INT 0
120405: PUSH
120406: EMPTY
120407: LIST
120408: LIST
120409: PUSH
120410: EMPTY
120411: LIST
120412: LIST
120413: PUSH
120414: EMPTY
120415: LIST
120416: LIST
120417: LIST
120418: PPUSH
120419: CALL_OW 69
120423: ST_TO_ADDR
// if not tmp then
120424: LD_VAR 0 2
120428: NOT
120429: IFFALSE 120433
// exit ;
120431: GO 120482
// for i in tmp do
120433: LD_ADDR_VAR 0 1
120437: PUSH
120438: LD_VAR 0 2
120442: PUSH
120443: FOR_IN
120444: IFFALSE 120480
// begin if Crawls ( i ) then
120446: LD_VAR 0 1
120450: PPUSH
120451: CALL_OW 318
120455: IFFALSE 120466
// ComWalk ( i ) ;
120457: LD_VAR 0 1
120461: PPUSH
120462: CALL_OW 138
// SetClass ( i , 2 ) ;
120466: LD_VAR 0 1
120470: PPUSH
120471: LD_INT 2
120473: PPUSH
120474: CALL_OW 336
// end ;
120478: GO 120443
120480: POP
120481: POP
// end ;
120482: PPOPN 2
120484: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
120485: LD_EXP 143
120489: PUSH
120490: LD_EXP 196
120494: AND
120495: IFFALSE 120783
120497: GO 120499
120499: DISABLE
120500: LD_INT 0
120502: PPUSH
120503: PPUSH
120504: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
120505: LD_OWVAR 2
120509: PPUSH
120510: LD_INT 9
120512: PPUSH
120513: LD_INT 1
120515: PPUSH
120516: LD_INT 1
120518: PPUSH
120519: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
120523: LD_INT 9
120525: PPUSH
120526: LD_OWVAR 2
120530: PPUSH
120531: CALL_OW 343
// uc_side := 9 ;
120535: LD_ADDR_OWVAR 20
120539: PUSH
120540: LD_INT 9
120542: ST_TO_ADDR
// uc_nation := 2 ;
120543: LD_ADDR_OWVAR 21
120547: PUSH
120548: LD_INT 2
120550: ST_TO_ADDR
// hc_name := Dark Warrior ;
120551: LD_ADDR_OWVAR 26
120555: PUSH
120556: LD_STRING Dark Warrior
120558: ST_TO_ADDR
// hc_gallery :=  ;
120559: LD_ADDR_OWVAR 33
120563: PUSH
120564: LD_STRING 
120566: ST_TO_ADDR
// hc_noskilllimit := true ;
120567: LD_ADDR_OWVAR 76
120571: PUSH
120572: LD_INT 1
120574: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
120575: LD_ADDR_OWVAR 31
120579: PUSH
120580: LD_INT 30
120582: PUSH
120583: LD_INT 30
120585: PUSH
120586: LD_INT 30
120588: PUSH
120589: LD_INT 30
120591: PUSH
120592: EMPTY
120593: LIST
120594: LIST
120595: LIST
120596: LIST
120597: ST_TO_ADDR
// un := CreateHuman ;
120598: LD_ADDR_VAR 0 3
120602: PUSH
120603: CALL_OW 44
120607: ST_TO_ADDR
// hc_noskilllimit := false ;
120608: LD_ADDR_OWVAR 76
120612: PUSH
120613: LD_INT 0
120615: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
120616: LD_VAR 0 3
120620: PPUSH
120621: LD_INT 1
120623: PPUSH
120624: CALL_OW 51
// ToLua ( playRanger() ) ;
120628: LD_STRING playRanger()
120630: PPUSH
120631: CALL_OW 559
// p := 0 ;
120635: LD_ADDR_VAR 0 2
120639: PUSH
120640: LD_INT 0
120642: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
120643: LD_INT 35
120645: PPUSH
120646: CALL_OW 67
// p := p + 1 ;
120650: LD_ADDR_VAR 0 2
120654: PUSH
120655: LD_VAR 0 2
120659: PUSH
120660: LD_INT 1
120662: PLUS
120663: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
120664: LD_VAR 0 3
120668: PPUSH
120669: CALL_OW 256
120673: PUSH
120674: LD_INT 1000
120676: LESS
120677: IFFALSE 120691
// SetLives ( un , 1000 ) ;
120679: LD_VAR 0 3
120683: PPUSH
120684: LD_INT 1000
120686: PPUSH
120687: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
120691: LD_VAR 0 3
120695: PPUSH
120696: LD_INT 81
120698: PUSH
120699: LD_OWVAR 2
120703: PUSH
120704: EMPTY
120705: LIST
120706: LIST
120707: PUSH
120708: LD_INT 91
120710: PUSH
120711: LD_VAR 0 3
120715: PUSH
120716: LD_INT 30
120718: PUSH
120719: EMPTY
120720: LIST
120721: LIST
120722: LIST
120723: PUSH
120724: EMPTY
120725: LIST
120726: LIST
120727: PPUSH
120728: CALL_OW 69
120732: PPUSH
120733: LD_VAR 0 3
120737: PPUSH
120738: CALL_OW 74
120742: PPUSH
120743: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
120747: LD_VAR 0 2
120751: PUSH
120752: LD_INT 80
120754: GREATER
120755: PUSH
120756: LD_VAR 0 3
120760: PPUSH
120761: CALL_OW 301
120765: OR
120766: IFFALSE 120643
// if un then
120768: LD_VAR 0 3
120772: IFFALSE 120783
// RemoveUnit ( un ) ;
120774: LD_VAR 0 3
120778: PPUSH
120779: CALL_OW 64
// end ;
120783: PPOPN 3
120785: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
120786: LD_EXP 197
120790: IFFALSE 120906
120792: GO 120794
120794: DISABLE
120795: LD_INT 0
120797: PPUSH
120798: PPUSH
120799: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
120800: LD_ADDR_VAR 0 2
120804: PUSH
120805: LD_INT 81
120807: PUSH
120808: LD_OWVAR 2
120812: PUSH
120813: EMPTY
120814: LIST
120815: LIST
120816: PUSH
120817: LD_INT 21
120819: PUSH
120820: LD_INT 1
120822: PUSH
120823: EMPTY
120824: LIST
120825: LIST
120826: PUSH
120827: EMPTY
120828: LIST
120829: LIST
120830: PPUSH
120831: CALL_OW 69
120835: ST_TO_ADDR
// ToLua ( playComputer() ) ;
120836: LD_STRING playComputer()
120838: PPUSH
120839: CALL_OW 559
// if not tmp then
120843: LD_VAR 0 2
120847: NOT
120848: IFFALSE 120852
// exit ;
120850: GO 120906
// for i in tmp do
120852: LD_ADDR_VAR 0 1
120856: PUSH
120857: LD_VAR 0 2
120861: PUSH
120862: FOR_IN
120863: IFFALSE 120904
// for j := 1 to 4 do
120865: LD_ADDR_VAR 0 3
120869: PUSH
120870: DOUBLE
120871: LD_INT 1
120873: DEC
120874: ST_TO_ADDR
120875: LD_INT 4
120877: PUSH
120878: FOR_TO
120879: IFFALSE 120900
// SetSkill ( i , j , 10 ) ;
120881: LD_VAR 0 1
120885: PPUSH
120886: LD_VAR 0 3
120890: PPUSH
120891: LD_INT 10
120893: PPUSH
120894: CALL_OW 237
120898: GO 120878
120900: POP
120901: POP
120902: GO 120862
120904: POP
120905: POP
// end ;
120906: PPOPN 3
120908: END
// every 0 0$1 trigger s30 do var i , tmp ;
120909: LD_EXP 198
120913: IFFALSE 120982
120915: GO 120917
120917: DISABLE
120918: LD_INT 0
120920: PPUSH
120921: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
120922: LD_ADDR_VAR 0 2
120926: PUSH
120927: LD_INT 22
120929: PUSH
120930: LD_OWVAR 2
120934: PUSH
120935: EMPTY
120936: LIST
120937: LIST
120938: PPUSH
120939: CALL_OW 69
120943: ST_TO_ADDR
// if not tmp then
120944: LD_VAR 0 2
120948: NOT
120949: IFFALSE 120953
// exit ;
120951: GO 120982
// for i in tmp do
120953: LD_ADDR_VAR 0 1
120957: PUSH
120958: LD_VAR 0 2
120962: PUSH
120963: FOR_IN
120964: IFFALSE 120980
// SetLives ( i , 300 ) ;
120966: LD_VAR 0 1
120970: PPUSH
120971: LD_INT 300
120973: PPUSH
120974: CALL_OW 234
120978: GO 120963
120980: POP
120981: POP
// end ;
120982: PPOPN 2
120984: END
// every 0 0$1 trigger s60 do var i , tmp ;
120985: LD_EXP 199
120989: IFFALSE 121058
120991: GO 120993
120993: DISABLE
120994: LD_INT 0
120996: PPUSH
120997: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
120998: LD_ADDR_VAR 0 2
121002: PUSH
121003: LD_INT 22
121005: PUSH
121006: LD_OWVAR 2
121010: PUSH
121011: EMPTY
121012: LIST
121013: LIST
121014: PPUSH
121015: CALL_OW 69
121019: ST_TO_ADDR
// if not tmp then
121020: LD_VAR 0 2
121024: NOT
121025: IFFALSE 121029
// exit ;
121027: GO 121058
// for i in tmp do
121029: LD_ADDR_VAR 0 1
121033: PUSH
121034: LD_VAR 0 2
121038: PUSH
121039: FOR_IN
121040: IFFALSE 121056
// SetLives ( i , 600 ) ;
121042: LD_VAR 0 1
121046: PPUSH
121047: LD_INT 600
121049: PPUSH
121050: CALL_OW 234
121054: GO 121039
121056: POP
121057: POP
// end ;
121058: PPOPN 2
121060: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
121061: LD_INT 0
121063: PPUSH
// case cmd of 301 :
121064: LD_VAR 0 1
121068: PUSH
121069: LD_INT 301
121071: DOUBLE
121072: EQUAL
121073: IFTRUE 121077
121075: GO 121109
121077: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
121078: LD_VAR 0 6
121082: PPUSH
121083: LD_VAR 0 7
121087: PPUSH
121088: LD_VAR 0 8
121092: PPUSH
121093: LD_VAR 0 4
121097: PPUSH
121098: LD_VAR 0 5
121102: PPUSH
121103: CALL 122310 0 5
121107: GO 121230
121109: LD_INT 302
121111: DOUBLE
121112: EQUAL
121113: IFTRUE 121117
121115: GO 121154
121117: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
121118: LD_VAR 0 6
121122: PPUSH
121123: LD_VAR 0 7
121127: PPUSH
121128: LD_VAR 0 8
121132: PPUSH
121133: LD_VAR 0 9
121137: PPUSH
121138: LD_VAR 0 4
121142: PPUSH
121143: LD_VAR 0 5
121147: PPUSH
121148: CALL 122401 0 6
121152: GO 121230
121154: LD_INT 303
121156: DOUBLE
121157: EQUAL
121158: IFTRUE 121162
121160: GO 121199
121162: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
121163: LD_VAR 0 6
121167: PPUSH
121168: LD_VAR 0 7
121172: PPUSH
121173: LD_VAR 0 8
121177: PPUSH
121178: LD_VAR 0 9
121182: PPUSH
121183: LD_VAR 0 4
121187: PPUSH
121188: LD_VAR 0 5
121192: PPUSH
121193: CALL 121235 0 6
121197: GO 121230
121199: LD_INT 304
121201: DOUBLE
121202: EQUAL
121203: IFTRUE 121207
121205: GO 121229
121207: POP
// hHackTeleport ( unit , x , y ) ; end ;
121208: LD_VAR 0 2
121212: PPUSH
121213: LD_VAR 0 4
121217: PPUSH
121218: LD_VAR 0 5
121222: PPUSH
121223: CALL 122994 0 3
121227: GO 121230
121229: POP
// end ;
121230: LD_VAR 0 12
121234: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
121235: LD_INT 0
121237: PPUSH
121238: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
121239: LD_VAR 0 1
121243: PUSH
121244: LD_INT 1
121246: LESS
121247: PUSH
121248: LD_VAR 0 1
121252: PUSH
121253: LD_INT 3
121255: GREATER
121256: OR
121257: PUSH
121258: LD_VAR 0 5
121262: PPUSH
121263: LD_VAR 0 6
121267: PPUSH
121268: CALL_OW 428
121272: OR
121273: IFFALSE 121277
// exit ;
121275: GO 121997
// uc_side := your_side ;
121277: LD_ADDR_OWVAR 20
121281: PUSH
121282: LD_OWVAR 2
121286: ST_TO_ADDR
// uc_nation := nation ;
121287: LD_ADDR_OWVAR 21
121291: PUSH
121292: LD_VAR 0 1
121296: ST_TO_ADDR
// bc_level = 1 ;
121297: LD_ADDR_OWVAR 43
121301: PUSH
121302: LD_INT 1
121304: ST_TO_ADDR
// case btype of 1 :
121305: LD_VAR 0 2
121309: PUSH
121310: LD_INT 1
121312: DOUBLE
121313: EQUAL
121314: IFTRUE 121318
121316: GO 121329
121318: POP
// bc_type := b_depot ; 2 :
121319: LD_ADDR_OWVAR 42
121323: PUSH
121324: LD_INT 0
121326: ST_TO_ADDR
121327: GO 121941
121329: LD_INT 2
121331: DOUBLE
121332: EQUAL
121333: IFTRUE 121337
121335: GO 121348
121337: POP
// bc_type := b_warehouse ; 3 :
121338: LD_ADDR_OWVAR 42
121342: PUSH
121343: LD_INT 1
121345: ST_TO_ADDR
121346: GO 121941
121348: LD_INT 3
121350: DOUBLE
121351: EQUAL
121352: IFTRUE 121356
121354: GO 121367
121356: POP
// bc_type := b_lab ; 4 .. 9 :
121357: LD_ADDR_OWVAR 42
121361: PUSH
121362: LD_INT 6
121364: ST_TO_ADDR
121365: GO 121941
121367: LD_INT 4
121369: DOUBLE
121370: GREATEREQUAL
121371: IFFALSE 121379
121373: LD_INT 9
121375: DOUBLE
121376: LESSEQUAL
121377: IFTRUE 121381
121379: GO 121433
121381: POP
// begin bc_type := b_lab_half ;
121382: LD_ADDR_OWVAR 42
121386: PUSH
121387: LD_INT 7
121389: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
121390: LD_ADDR_OWVAR 44
121394: PUSH
121395: LD_INT 10
121397: PUSH
121398: LD_INT 11
121400: PUSH
121401: LD_INT 12
121403: PUSH
121404: LD_INT 15
121406: PUSH
121407: LD_INT 14
121409: PUSH
121410: LD_INT 13
121412: PUSH
121413: EMPTY
121414: LIST
121415: LIST
121416: LIST
121417: LIST
121418: LIST
121419: LIST
121420: PUSH
121421: LD_VAR 0 2
121425: PUSH
121426: LD_INT 3
121428: MINUS
121429: ARRAY
121430: ST_TO_ADDR
// end ; 10 .. 13 :
121431: GO 121941
121433: LD_INT 10
121435: DOUBLE
121436: GREATEREQUAL
121437: IFFALSE 121445
121439: LD_INT 13
121441: DOUBLE
121442: LESSEQUAL
121443: IFTRUE 121447
121445: GO 121524
121447: POP
// begin bc_type := b_lab_full ;
121448: LD_ADDR_OWVAR 42
121452: PUSH
121453: LD_INT 8
121455: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
121456: LD_ADDR_OWVAR 44
121460: PUSH
121461: LD_INT 10
121463: PUSH
121464: LD_INT 12
121466: PUSH
121467: LD_INT 14
121469: PUSH
121470: LD_INT 13
121472: PUSH
121473: EMPTY
121474: LIST
121475: LIST
121476: LIST
121477: LIST
121478: PUSH
121479: LD_VAR 0 2
121483: PUSH
121484: LD_INT 9
121486: MINUS
121487: ARRAY
121488: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
121489: LD_ADDR_OWVAR 45
121493: PUSH
121494: LD_INT 11
121496: PUSH
121497: LD_INT 15
121499: PUSH
121500: LD_INT 12
121502: PUSH
121503: LD_INT 15
121505: PUSH
121506: EMPTY
121507: LIST
121508: LIST
121509: LIST
121510: LIST
121511: PUSH
121512: LD_VAR 0 2
121516: PUSH
121517: LD_INT 9
121519: MINUS
121520: ARRAY
121521: ST_TO_ADDR
// end ; 14 :
121522: GO 121941
121524: LD_INT 14
121526: DOUBLE
121527: EQUAL
121528: IFTRUE 121532
121530: GO 121543
121532: POP
// bc_type := b_workshop ; 15 :
121533: LD_ADDR_OWVAR 42
121537: PUSH
121538: LD_INT 2
121540: ST_TO_ADDR
121541: GO 121941
121543: LD_INT 15
121545: DOUBLE
121546: EQUAL
121547: IFTRUE 121551
121549: GO 121562
121551: POP
// bc_type := b_factory ; 16 :
121552: LD_ADDR_OWVAR 42
121556: PUSH
121557: LD_INT 3
121559: ST_TO_ADDR
121560: GO 121941
121562: LD_INT 16
121564: DOUBLE
121565: EQUAL
121566: IFTRUE 121570
121568: GO 121581
121570: POP
// bc_type := b_ext_gun ; 17 :
121571: LD_ADDR_OWVAR 42
121575: PUSH
121576: LD_INT 17
121578: ST_TO_ADDR
121579: GO 121941
121581: LD_INT 17
121583: DOUBLE
121584: EQUAL
121585: IFTRUE 121589
121587: GO 121617
121589: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
121590: LD_ADDR_OWVAR 42
121594: PUSH
121595: LD_INT 19
121597: PUSH
121598: LD_INT 23
121600: PUSH
121601: LD_INT 19
121603: PUSH
121604: EMPTY
121605: LIST
121606: LIST
121607: LIST
121608: PUSH
121609: LD_VAR 0 1
121613: ARRAY
121614: ST_TO_ADDR
121615: GO 121941
121617: LD_INT 18
121619: DOUBLE
121620: EQUAL
121621: IFTRUE 121625
121623: GO 121636
121625: POP
// bc_type := b_ext_radar ; 19 :
121626: LD_ADDR_OWVAR 42
121630: PUSH
121631: LD_INT 20
121633: ST_TO_ADDR
121634: GO 121941
121636: LD_INT 19
121638: DOUBLE
121639: EQUAL
121640: IFTRUE 121644
121642: GO 121655
121644: POP
// bc_type := b_ext_radio ; 20 :
121645: LD_ADDR_OWVAR 42
121649: PUSH
121650: LD_INT 22
121652: ST_TO_ADDR
121653: GO 121941
121655: LD_INT 20
121657: DOUBLE
121658: EQUAL
121659: IFTRUE 121663
121661: GO 121674
121663: POP
// bc_type := b_ext_siberium ; 21 :
121664: LD_ADDR_OWVAR 42
121668: PUSH
121669: LD_INT 21
121671: ST_TO_ADDR
121672: GO 121941
121674: LD_INT 21
121676: DOUBLE
121677: EQUAL
121678: IFTRUE 121682
121680: GO 121693
121682: POP
// bc_type := b_ext_computer ; 22 :
121683: LD_ADDR_OWVAR 42
121687: PUSH
121688: LD_INT 24
121690: ST_TO_ADDR
121691: GO 121941
121693: LD_INT 22
121695: DOUBLE
121696: EQUAL
121697: IFTRUE 121701
121699: GO 121712
121701: POP
// bc_type := b_ext_track ; 23 :
121702: LD_ADDR_OWVAR 42
121706: PUSH
121707: LD_INT 16
121709: ST_TO_ADDR
121710: GO 121941
121712: LD_INT 23
121714: DOUBLE
121715: EQUAL
121716: IFTRUE 121720
121718: GO 121731
121720: POP
// bc_type := b_ext_laser ; 24 :
121721: LD_ADDR_OWVAR 42
121725: PUSH
121726: LD_INT 25
121728: ST_TO_ADDR
121729: GO 121941
121731: LD_INT 24
121733: DOUBLE
121734: EQUAL
121735: IFTRUE 121739
121737: GO 121750
121739: POP
// bc_type := b_control_tower ; 25 :
121740: LD_ADDR_OWVAR 42
121744: PUSH
121745: LD_INT 36
121747: ST_TO_ADDR
121748: GO 121941
121750: LD_INT 25
121752: DOUBLE
121753: EQUAL
121754: IFTRUE 121758
121756: GO 121769
121758: POP
// bc_type := b_breastwork ; 26 :
121759: LD_ADDR_OWVAR 42
121763: PUSH
121764: LD_INT 31
121766: ST_TO_ADDR
121767: GO 121941
121769: LD_INT 26
121771: DOUBLE
121772: EQUAL
121773: IFTRUE 121777
121775: GO 121788
121777: POP
// bc_type := b_bunker ; 27 :
121778: LD_ADDR_OWVAR 42
121782: PUSH
121783: LD_INT 32
121785: ST_TO_ADDR
121786: GO 121941
121788: LD_INT 27
121790: DOUBLE
121791: EQUAL
121792: IFTRUE 121796
121794: GO 121807
121796: POP
// bc_type := b_turret ; 28 :
121797: LD_ADDR_OWVAR 42
121801: PUSH
121802: LD_INT 33
121804: ST_TO_ADDR
121805: GO 121941
121807: LD_INT 28
121809: DOUBLE
121810: EQUAL
121811: IFTRUE 121815
121813: GO 121826
121815: POP
// bc_type := b_armoury ; 29 :
121816: LD_ADDR_OWVAR 42
121820: PUSH
121821: LD_INT 4
121823: ST_TO_ADDR
121824: GO 121941
121826: LD_INT 29
121828: DOUBLE
121829: EQUAL
121830: IFTRUE 121834
121832: GO 121845
121834: POP
// bc_type := b_barracks ; 30 :
121835: LD_ADDR_OWVAR 42
121839: PUSH
121840: LD_INT 5
121842: ST_TO_ADDR
121843: GO 121941
121845: LD_INT 30
121847: DOUBLE
121848: EQUAL
121849: IFTRUE 121853
121851: GO 121864
121853: POP
// bc_type := b_solar_power ; 31 :
121854: LD_ADDR_OWVAR 42
121858: PUSH
121859: LD_INT 27
121861: ST_TO_ADDR
121862: GO 121941
121864: LD_INT 31
121866: DOUBLE
121867: EQUAL
121868: IFTRUE 121872
121870: GO 121883
121872: POP
// bc_type := b_oil_power ; 32 :
121873: LD_ADDR_OWVAR 42
121877: PUSH
121878: LD_INT 26
121880: ST_TO_ADDR
121881: GO 121941
121883: LD_INT 32
121885: DOUBLE
121886: EQUAL
121887: IFTRUE 121891
121889: GO 121902
121891: POP
// bc_type := b_siberite_power ; 33 :
121892: LD_ADDR_OWVAR 42
121896: PUSH
121897: LD_INT 28
121899: ST_TO_ADDR
121900: GO 121941
121902: LD_INT 33
121904: DOUBLE
121905: EQUAL
121906: IFTRUE 121910
121908: GO 121921
121910: POP
// bc_type := b_oil_mine ; 34 :
121911: LD_ADDR_OWVAR 42
121915: PUSH
121916: LD_INT 29
121918: ST_TO_ADDR
121919: GO 121941
121921: LD_INT 34
121923: DOUBLE
121924: EQUAL
121925: IFTRUE 121929
121927: GO 121940
121929: POP
// bc_type := b_siberite_mine ; end ;
121930: LD_ADDR_OWVAR 42
121934: PUSH
121935: LD_INT 30
121937: ST_TO_ADDR
121938: GO 121941
121940: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
121941: LD_ADDR_VAR 0 8
121945: PUSH
121946: LD_VAR 0 5
121950: PPUSH
121951: LD_VAR 0 6
121955: PPUSH
121956: LD_VAR 0 3
121960: PPUSH
121961: CALL_OW 47
121965: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
121966: LD_OWVAR 42
121970: PUSH
121971: LD_INT 32
121973: PUSH
121974: LD_INT 33
121976: PUSH
121977: EMPTY
121978: LIST
121979: LIST
121980: IN
121981: IFFALSE 121997
// PlaceWeaponTurret ( b , weapon ) ;
121983: LD_VAR 0 8
121987: PPUSH
121988: LD_VAR 0 4
121992: PPUSH
121993: CALL_OW 431
// end ;
121997: LD_VAR 0 7
122001: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
122002: LD_INT 0
122004: PPUSH
122005: PPUSH
122006: PPUSH
122007: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
122008: LD_ADDR_VAR 0 4
122012: PUSH
122013: LD_INT 22
122015: PUSH
122016: LD_OWVAR 2
122020: PUSH
122021: EMPTY
122022: LIST
122023: LIST
122024: PUSH
122025: LD_INT 2
122027: PUSH
122028: LD_INT 30
122030: PUSH
122031: LD_INT 0
122033: PUSH
122034: EMPTY
122035: LIST
122036: LIST
122037: PUSH
122038: LD_INT 30
122040: PUSH
122041: LD_INT 1
122043: PUSH
122044: EMPTY
122045: LIST
122046: LIST
122047: PUSH
122048: EMPTY
122049: LIST
122050: LIST
122051: LIST
122052: PUSH
122053: EMPTY
122054: LIST
122055: LIST
122056: PPUSH
122057: CALL_OW 69
122061: ST_TO_ADDR
// if not tmp then
122062: LD_VAR 0 4
122066: NOT
122067: IFFALSE 122071
// exit ;
122069: GO 122130
// for i in tmp do
122071: LD_ADDR_VAR 0 2
122075: PUSH
122076: LD_VAR 0 4
122080: PUSH
122081: FOR_IN
122082: IFFALSE 122128
// for j = 1 to 3 do
122084: LD_ADDR_VAR 0 3
122088: PUSH
122089: DOUBLE
122090: LD_INT 1
122092: DEC
122093: ST_TO_ADDR
122094: LD_INT 3
122096: PUSH
122097: FOR_TO
122098: IFFALSE 122124
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
122100: LD_VAR 0 2
122104: PPUSH
122105: CALL_OW 274
122109: PPUSH
122110: LD_VAR 0 3
122114: PPUSH
122115: LD_INT 99999
122117: PPUSH
122118: CALL_OW 277
122122: GO 122097
122124: POP
122125: POP
122126: GO 122081
122128: POP
122129: POP
// end ;
122130: LD_VAR 0 1
122134: RET
// export function hHackSetLevel10 ; var i , j ; begin
122135: LD_INT 0
122137: PPUSH
122138: PPUSH
122139: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
122140: LD_ADDR_VAR 0 2
122144: PUSH
122145: LD_INT 21
122147: PUSH
122148: LD_INT 1
122150: PUSH
122151: EMPTY
122152: LIST
122153: LIST
122154: PPUSH
122155: CALL_OW 69
122159: PUSH
122160: FOR_IN
122161: IFFALSE 122213
// if IsSelected ( i ) then
122163: LD_VAR 0 2
122167: PPUSH
122168: CALL_OW 306
122172: IFFALSE 122211
// begin for j := 1 to 4 do
122174: LD_ADDR_VAR 0 3
122178: PUSH
122179: DOUBLE
122180: LD_INT 1
122182: DEC
122183: ST_TO_ADDR
122184: LD_INT 4
122186: PUSH
122187: FOR_TO
122188: IFFALSE 122209
// SetSkill ( i , j , 10 ) ;
122190: LD_VAR 0 2
122194: PPUSH
122195: LD_VAR 0 3
122199: PPUSH
122200: LD_INT 10
122202: PPUSH
122203: CALL_OW 237
122207: GO 122187
122209: POP
122210: POP
// end ;
122211: GO 122160
122213: POP
122214: POP
// end ;
122215: LD_VAR 0 1
122219: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
122220: LD_INT 0
122222: PPUSH
122223: PPUSH
122224: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
122225: LD_ADDR_VAR 0 2
122229: PUSH
122230: LD_INT 22
122232: PUSH
122233: LD_OWVAR 2
122237: PUSH
122238: EMPTY
122239: LIST
122240: LIST
122241: PUSH
122242: LD_INT 21
122244: PUSH
122245: LD_INT 1
122247: PUSH
122248: EMPTY
122249: LIST
122250: LIST
122251: PUSH
122252: EMPTY
122253: LIST
122254: LIST
122255: PPUSH
122256: CALL_OW 69
122260: PUSH
122261: FOR_IN
122262: IFFALSE 122303
// begin for j := 1 to 4 do
122264: LD_ADDR_VAR 0 3
122268: PUSH
122269: DOUBLE
122270: LD_INT 1
122272: DEC
122273: ST_TO_ADDR
122274: LD_INT 4
122276: PUSH
122277: FOR_TO
122278: IFFALSE 122299
// SetSkill ( i , j , 10 ) ;
122280: LD_VAR 0 2
122284: PPUSH
122285: LD_VAR 0 3
122289: PPUSH
122290: LD_INT 10
122292: PPUSH
122293: CALL_OW 237
122297: GO 122277
122299: POP
122300: POP
// end ;
122301: GO 122261
122303: POP
122304: POP
// end ;
122305: LD_VAR 0 1
122309: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
122310: LD_INT 0
122312: PPUSH
// uc_side := your_side ;
122313: LD_ADDR_OWVAR 20
122317: PUSH
122318: LD_OWVAR 2
122322: ST_TO_ADDR
// uc_nation := nation ;
122323: LD_ADDR_OWVAR 21
122327: PUSH
122328: LD_VAR 0 1
122332: ST_TO_ADDR
// InitHc ;
122333: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
122337: LD_INT 0
122339: PPUSH
122340: LD_VAR 0 2
122344: PPUSH
122345: LD_VAR 0 3
122349: PPUSH
122350: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
122354: LD_VAR 0 4
122358: PPUSH
122359: LD_VAR 0 5
122363: PPUSH
122364: CALL_OW 428
122368: PUSH
122369: LD_INT 0
122371: EQUAL
122372: IFFALSE 122396
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
122374: CALL_OW 44
122378: PPUSH
122379: LD_VAR 0 4
122383: PPUSH
122384: LD_VAR 0 5
122388: PPUSH
122389: LD_INT 1
122391: PPUSH
122392: CALL_OW 48
// end ;
122396: LD_VAR 0 6
122400: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
122401: LD_INT 0
122403: PPUSH
122404: PPUSH
// uc_side := your_side ;
122405: LD_ADDR_OWVAR 20
122409: PUSH
122410: LD_OWVAR 2
122414: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
122415: LD_VAR 0 1
122419: PUSH
122420: LD_INT 1
122422: PUSH
122423: LD_INT 2
122425: PUSH
122426: LD_INT 3
122428: PUSH
122429: LD_INT 4
122431: PUSH
122432: LD_INT 5
122434: PUSH
122435: EMPTY
122436: LIST
122437: LIST
122438: LIST
122439: LIST
122440: LIST
122441: IN
122442: IFFALSE 122454
// uc_nation := nation_american else
122444: LD_ADDR_OWVAR 21
122448: PUSH
122449: LD_INT 1
122451: ST_TO_ADDR
122452: GO 122497
// if chassis in [ 11 , 12 , 13 , 14 ] then
122454: LD_VAR 0 1
122458: PUSH
122459: LD_INT 11
122461: PUSH
122462: LD_INT 12
122464: PUSH
122465: LD_INT 13
122467: PUSH
122468: LD_INT 14
122470: PUSH
122471: EMPTY
122472: LIST
122473: LIST
122474: LIST
122475: LIST
122476: IN
122477: IFFALSE 122489
// uc_nation := nation_arabian else
122479: LD_ADDR_OWVAR 21
122483: PUSH
122484: LD_INT 2
122486: ST_TO_ADDR
122487: GO 122497
// uc_nation := nation_russian ;
122489: LD_ADDR_OWVAR 21
122493: PUSH
122494: LD_INT 3
122496: ST_TO_ADDR
// vc_chassis := chassis ;
122497: LD_ADDR_OWVAR 37
122501: PUSH
122502: LD_VAR 0 1
122506: ST_TO_ADDR
// vc_engine := engine ;
122507: LD_ADDR_OWVAR 39
122511: PUSH
122512: LD_VAR 0 2
122516: ST_TO_ADDR
// vc_control := control ;
122517: LD_ADDR_OWVAR 38
122521: PUSH
122522: LD_VAR 0 3
122526: ST_TO_ADDR
// vc_weapon := weapon ;
122527: LD_ADDR_OWVAR 40
122531: PUSH
122532: LD_VAR 0 4
122536: ST_TO_ADDR
// un := CreateVehicle ;
122537: LD_ADDR_VAR 0 8
122541: PUSH
122542: CALL_OW 45
122546: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
122547: LD_VAR 0 8
122551: PPUSH
122552: LD_INT 0
122554: PPUSH
122555: LD_INT 5
122557: PPUSH
122558: CALL_OW 12
122562: PPUSH
122563: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
122567: LD_VAR 0 8
122571: PPUSH
122572: LD_VAR 0 5
122576: PPUSH
122577: LD_VAR 0 6
122581: PPUSH
122582: LD_INT 1
122584: PPUSH
122585: CALL_OW 48
// end ;
122589: LD_VAR 0 7
122593: RET
// export hInvincible ; every 1 do
122594: GO 122596
122596: DISABLE
// hInvincible := [ ] ;
122597: LD_ADDR_EXP 200
122601: PUSH
122602: EMPTY
122603: ST_TO_ADDR
122604: END
// every 10 do var i ;
122605: GO 122607
122607: DISABLE
122608: LD_INT 0
122610: PPUSH
// begin enable ;
122611: ENABLE
// if not hInvincible then
122612: LD_EXP 200
122616: NOT
122617: IFFALSE 122621
// exit ;
122619: GO 122665
// for i in hInvincible do
122621: LD_ADDR_VAR 0 1
122625: PUSH
122626: LD_EXP 200
122630: PUSH
122631: FOR_IN
122632: IFFALSE 122663
// if GetLives ( i ) < 1000 then
122634: LD_VAR 0 1
122638: PPUSH
122639: CALL_OW 256
122643: PUSH
122644: LD_INT 1000
122646: LESS
122647: IFFALSE 122661
// SetLives ( i , 1000 ) ;
122649: LD_VAR 0 1
122653: PPUSH
122654: LD_INT 1000
122656: PPUSH
122657: CALL_OW 234
122661: GO 122631
122663: POP
122664: POP
// end ;
122665: PPOPN 1
122667: END
// export function hHackInvincible ; var i ; begin
122668: LD_INT 0
122670: PPUSH
122671: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
122672: LD_ADDR_VAR 0 2
122676: PUSH
122677: LD_INT 2
122679: PUSH
122680: LD_INT 21
122682: PUSH
122683: LD_INT 1
122685: PUSH
122686: EMPTY
122687: LIST
122688: LIST
122689: PUSH
122690: LD_INT 21
122692: PUSH
122693: LD_INT 2
122695: PUSH
122696: EMPTY
122697: LIST
122698: LIST
122699: PUSH
122700: EMPTY
122701: LIST
122702: LIST
122703: LIST
122704: PPUSH
122705: CALL_OW 69
122709: PUSH
122710: FOR_IN
122711: IFFALSE 122772
// if IsSelected ( i ) then
122713: LD_VAR 0 2
122717: PPUSH
122718: CALL_OW 306
122722: IFFALSE 122770
// begin if i in hInvincible then
122724: LD_VAR 0 2
122728: PUSH
122729: LD_EXP 200
122733: IN
122734: IFFALSE 122754
// hInvincible := hInvincible diff i else
122736: LD_ADDR_EXP 200
122740: PUSH
122741: LD_EXP 200
122745: PUSH
122746: LD_VAR 0 2
122750: DIFF
122751: ST_TO_ADDR
122752: GO 122770
// hInvincible := hInvincible union i ;
122754: LD_ADDR_EXP 200
122758: PUSH
122759: LD_EXP 200
122763: PUSH
122764: LD_VAR 0 2
122768: UNION
122769: ST_TO_ADDR
// end ;
122770: GO 122710
122772: POP
122773: POP
// end ;
122774: LD_VAR 0 1
122778: RET
// export function hHackInvisible ; var i , j ; begin
122779: LD_INT 0
122781: PPUSH
122782: PPUSH
122783: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
122784: LD_ADDR_VAR 0 2
122788: PUSH
122789: LD_INT 21
122791: PUSH
122792: LD_INT 1
122794: PUSH
122795: EMPTY
122796: LIST
122797: LIST
122798: PPUSH
122799: CALL_OW 69
122803: PUSH
122804: FOR_IN
122805: IFFALSE 122829
// if IsSelected ( i ) then
122807: LD_VAR 0 2
122811: PPUSH
122812: CALL_OW 306
122816: IFFALSE 122827
// ComForceInvisible ( i ) ;
122818: LD_VAR 0 2
122822: PPUSH
122823: CALL_OW 496
122827: GO 122804
122829: POP
122830: POP
// end ;
122831: LD_VAR 0 1
122835: RET
// export function hHackChangeYourSide ; begin
122836: LD_INT 0
122838: PPUSH
// if your_side = 8 then
122839: LD_OWVAR 2
122843: PUSH
122844: LD_INT 8
122846: EQUAL
122847: IFFALSE 122859
// your_side := 0 else
122849: LD_ADDR_OWVAR 2
122853: PUSH
122854: LD_INT 0
122856: ST_TO_ADDR
122857: GO 122873
// your_side := your_side + 1 ;
122859: LD_ADDR_OWVAR 2
122863: PUSH
122864: LD_OWVAR 2
122868: PUSH
122869: LD_INT 1
122871: PLUS
122872: ST_TO_ADDR
// end ;
122873: LD_VAR 0 1
122877: RET
// export function hHackChangeUnitSide ; var i , j ; begin
122878: LD_INT 0
122880: PPUSH
122881: PPUSH
122882: PPUSH
// for i in all_units do
122883: LD_ADDR_VAR 0 2
122887: PUSH
122888: LD_OWVAR 3
122892: PUSH
122893: FOR_IN
122894: IFFALSE 122972
// if IsSelected ( i ) then
122896: LD_VAR 0 2
122900: PPUSH
122901: CALL_OW 306
122905: IFFALSE 122970
// begin j := GetSide ( i ) ;
122907: LD_ADDR_VAR 0 3
122911: PUSH
122912: LD_VAR 0 2
122916: PPUSH
122917: CALL_OW 255
122921: ST_TO_ADDR
// if j = 8 then
122922: LD_VAR 0 3
122926: PUSH
122927: LD_INT 8
122929: EQUAL
122930: IFFALSE 122942
// j := 0 else
122932: LD_ADDR_VAR 0 3
122936: PUSH
122937: LD_INT 0
122939: ST_TO_ADDR
122940: GO 122956
// j := j + 1 ;
122942: LD_ADDR_VAR 0 3
122946: PUSH
122947: LD_VAR 0 3
122951: PUSH
122952: LD_INT 1
122954: PLUS
122955: ST_TO_ADDR
// SetSide ( i , j ) ;
122956: LD_VAR 0 2
122960: PPUSH
122961: LD_VAR 0 3
122965: PPUSH
122966: CALL_OW 235
// end ;
122970: GO 122893
122972: POP
122973: POP
// end ;
122974: LD_VAR 0 1
122978: RET
// export function hHackFog ; begin
122979: LD_INT 0
122981: PPUSH
// FogOff ( true ) ;
122982: LD_INT 1
122984: PPUSH
122985: CALL_OW 344
// end ;
122989: LD_VAR 0 1
122993: RET
// export function hHackTeleport ( unit , x , y ) ; begin
122994: LD_INT 0
122996: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
122997: LD_VAR 0 1
123001: PPUSH
123002: LD_VAR 0 2
123006: PPUSH
123007: LD_VAR 0 3
123011: PPUSH
123012: LD_INT 1
123014: PPUSH
123015: LD_INT 1
123017: PPUSH
123018: CALL_OW 483
// CenterOnXY ( x , y ) ;
123022: LD_VAR 0 2
123026: PPUSH
123027: LD_VAR 0 3
123031: PPUSH
123032: CALL_OW 84
// end ;
123036: LD_VAR 0 4
123040: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
123041: LD_INT 0
123043: PPUSH
123044: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
123045: LD_VAR 0 1
123049: NOT
123050: PUSH
123051: LD_VAR 0 2
123055: PPUSH
123056: LD_VAR 0 3
123060: PPUSH
123061: CALL_OW 488
123065: NOT
123066: OR
123067: PUSH
123068: LD_VAR 0 1
123072: PPUSH
123073: CALL_OW 266
123077: PUSH
123078: LD_INT 3
123080: NONEQUAL
123081: PUSH
123082: LD_VAR 0 1
123086: PPUSH
123087: CALL_OW 247
123091: PUSH
123092: LD_INT 1
123094: EQUAL
123095: NOT
123096: AND
123097: OR
123098: IFFALSE 123102
// exit ;
123100: GO 123251
// if GetType ( factory ) = unit_human then
123102: LD_VAR 0 1
123106: PPUSH
123107: CALL_OW 247
123111: PUSH
123112: LD_INT 1
123114: EQUAL
123115: IFFALSE 123132
// factory := IsInUnit ( factory ) ;
123117: LD_ADDR_VAR 0 1
123121: PUSH
123122: LD_VAR 0 1
123126: PPUSH
123127: CALL_OW 310
123131: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
123132: LD_VAR 0 1
123136: PPUSH
123137: CALL_OW 266
123141: PUSH
123142: LD_INT 3
123144: NONEQUAL
123145: IFFALSE 123149
// exit ;
123147: GO 123251
// if HexInfo ( x , y ) = factory then
123149: LD_VAR 0 2
123153: PPUSH
123154: LD_VAR 0 3
123158: PPUSH
123159: CALL_OW 428
123163: PUSH
123164: LD_VAR 0 1
123168: EQUAL
123169: IFFALSE 123196
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
123171: LD_ADDR_EXP 201
123175: PUSH
123176: LD_EXP 201
123180: PPUSH
123181: LD_VAR 0 1
123185: PPUSH
123186: LD_INT 0
123188: PPUSH
123189: CALL_OW 1
123193: ST_TO_ADDR
123194: GO 123247
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
123196: LD_ADDR_EXP 201
123200: PUSH
123201: LD_EXP 201
123205: PPUSH
123206: LD_VAR 0 1
123210: PPUSH
123211: LD_VAR 0 1
123215: PPUSH
123216: CALL_OW 255
123220: PUSH
123221: LD_VAR 0 1
123225: PUSH
123226: LD_VAR 0 2
123230: PUSH
123231: LD_VAR 0 3
123235: PUSH
123236: EMPTY
123237: LIST
123238: LIST
123239: LIST
123240: LIST
123241: PPUSH
123242: CALL_OW 1
123246: ST_TO_ADDR
// UpdateFactoryWaypoints ;
123247: CALL 123256 0 0
// end ;
123251: LD_VAR 0 4
123255: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
123256: LD_INT 0
123258: PPUSH
123259: PPUSH
123260: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
123261: LD_STRING resetFactoryWaypoint();
123263: PPUSH
123264: CALL_OW 559
// if factoryWaypoints then
123268: LD_EXP 201
123272: IFFALSE 123398
// begin list := PrepareArray ( factoryWaypoints ) ;
123274: LD_ADDR_VAR 0 3
123278: PUSH
123279: LD_EXP 201
123283: PPUSH
123284: CALL 108542 0 1
123288: ST_TO_ADDR
// for i := 1 to list do
123289: LD_ADDR_VAR 0 2
123293: PUSH
123294: DOUBLE
123295: LD_INT 1
123297: DEC
123298: ST_TO_ADDR
123299: LD_VAR 0 3
123303: PUSH
123304: FOR_TO
123305: IFFALSE 123396
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
123307: LD_STRING setFactoryWaypointXY(
123309: PUSH
123310: LD_VAR 0 3
123314: PUSH
123315: LD_VAR 0 2
123319: ARRAY
123320: PUSH
123321: LD_INT 1
123323: ARRAY
123324: STR
123325: PUSH
123326: LD_STRING ,
123328: STR
123329: PUSH
123330: LD_VAR 0 3
123334: PUSH
123335: LD_VAR 0 2
123339: ARRAY
123340: PUSH
123341: LD_INT 2
123343: ARRAY
123344: STR
123345: PUSH
123346: LD_STRING ,
123348: STR
123349: PUSH
123350: LD_VAR 0 3
123354: PUSH
123355: LD_VAR 0 2
123359: ARRAY
123360: PUSH
123361: LD_INT 3
123363: ARRAY
123364: STR
123365: PUSH
123366: LD_STRING ,
123368: STR
123369: PUSH
123370: LD_VAR 0 3
123374: PUSH
123375: LD_VAR 0 2
123379: ARRAY
123380: PUSH
123381: LD_INT 4
123383: ARRAY
123384: STR
123385: PUSH
123386: LD_STRING )
123388: STR
123389: PPUSH
123390: CALL_OW 559
123394: GO 123304
123396: POP
123397: POP
// end ; end ;
123398: LD_VAR 0 1
123402: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
123403: LD_INT 0
123405: PPUSH
// if HexInfo ( x , y ) = warehouse then
123406: LD_VAR 0 2
123410: PPUSH
123411: LD_VAR 0 3
123415: PPUSH
123416: CALL_OW 428
123420: PUSH
123421: LD_VAR 0 1
123425: EQUAL
123426: IFFALSE 123453
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
123428: LD_ADDR_EXP 202
123432: PUSH
123433: LD_EXP 202
123437: PPUSH
123438: LD_VAR 0 1
123442: PPUSH
123443: LD_INT 0
123445: PPUSH
123446: CALL_OW 1
123450: ST_TO_ADDR
123451: GO 123504
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
123453: LD_ADDR_EXP 202
123457: PUSH
123458: LD_EXP 202
123462: PPUSH
123463: LD_VAR 0 1
123467: PPUSH
123468: LD_VAR 0 1
123472: PPUSH
123473: CALL_OW 255
123477: PUSH
123478: LD_VAR 0 1
123482: PUSH
123483: LD_VAR 0 2
123487: PUSH
123488: LD_VAR 0 3
123492: PUSH
123493: EMPTY
123494: LIST
123495: LIST
123496: LIST
123497: LIST
123498: PPUSH
123499: CALL_OW 1
123503: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
123504: CALL 123513 0 0
// end ;
123508: LD_VAR 0 4
123512: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
123513: LD_INT 0
123515: PPUSH
123516: PPUSH
123517: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
123518: LD_STRING resetWarehouseGatheringPoints();
123520: PPUSH
123521: CALL_OW 559
// if warehouseGatheringPoints then
123525: LD_EXP 202
123529: IFFALSE 123655
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
123531: LD_ADDR_VAR 0 3
123535: PUSH
123536: LD_EXP 202
123540: PPUSH
123541: CALL 108542 0 1
123545: ST_TO_ADDR
// for i := 1 to list do
123546: LD_ADDR_VAR 0 2
123550: PUSH
123551: DOUBLE
123552: LD_INT 1
123554: DEC
123555: ST_TO_ADDR
123556: LD_VAR 0 3
123560: PUSH
123561: FOR_TO
123562: IFFALSE 123653
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
123564: LD_STRING setWarehouseGatheringPointXY(
123566: PUSH
123567: LD_VAR 0 3
123571: PUSH
123572: LD_VAR 0 2
123576: ARRAY
123577: PUSH
123578: LD_INT 1
123580: ARRAY
123581: STR
123582: PUSH
123583: LD_STRING ,
123585: STR
123586: PUSH
123587: LD_VAR 0 3
123591: PUSH
123592: LD_VAR 0 2
123596: ARRAY
123597: PUSH
123598: LD_INT 2
123600: ARRAY
123601: STR
123602: PUSH
123603: LD_STRING ,
123605: STR
123606: PUSH
123607: LD_VAR 0 3
123611: PUSH
123612: LD_VAR 0 2
123616: ARRAY
123617: PUSH
123618: LD_INT 3
123620: ARRAY
123621: STR
123622: PUSH
123623: LD_STRING ,
123625: STR
123626: PUSH
123627: LD_VAR 0 3
123631: PUSH
123632: LD_VAR 0 2
123636: ARRAY
123637: PUSH
123638: LD_INT 4
123640: ARRAY
123641: STR
123642: PUSH
123643: LD_STRING )
123645: STR
123646: PPUSH
123647: CALL_OW 559
123651: GO 123561
123653: POP
123654: POP
// end ; end ;
123655: LD_VAR 0 1
123659: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
123660: LD_EXP 202
123664: IFFALSE 124349
123666: GO 123668
123668: DISABLE
123669: LD_INT 0
123671: PPUSH
123672: PPUSH
123673: PPUSH
123674: PPUSH
123675: PPUSH
123676: PPUSH
123677: PPUSH
123678: PPUSH
123679: PPUSH
// begin enable ;
123680: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
123681: LD_ADDR_VAR 0 3
123685: PUSH
123686: LD_EXP 202
123690: PPUSH
123691: CALL 108542 0 1
123695: ST_TO_ADDR
// if not list then
123696: LD_VAR 0 3
123700: NOT
123701: IFFALSE 123705
// exit ;
123703: GO 124349
// for i := 1 to list do
123705: LD_ADDR_VAR 0 1
123709: PUSH
123710: DOUBLE
123711: LD_INT 1
123713: DEC
123714: ST_TO_ADDR
123715: LD_VAR 0 3
123719: PUSH
123720: FOR_TO
123721: IFFALSE 124347
// begin depot := list [ i ] [ 2 ] ;
123723: LD_ADDR_VAR 0 8
123727: PUSH
123728: LD_VAR 0 3
123732: PUSH
123733: LD_VAR 0 1
123737: ARRAY
123738: PUSH
123739: LD_INT 2
123741: ARRAY
123742: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
123743: LD_ADDR_VAR 0 5
123747: PUSH
123748: LD_VAR 0 3
123752: PUSH
123753: LD_VAR 0 1
123757: ARRAY
123758: PUSH
123759: LD_INT 1
123761: ARRAY
123762: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
123763: LD_VAR 0 8
123767: PPUSH
123768: CALL_OW 301
123772: PUSH
123773: LD_VAR 0 5
123777: PUSH
123778: LD_VAR 0 8
123782: PPUSH
123783: CALL_OW 255
123787: NONEQUAL
123788: OR
123789: IFFALSE 123818
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
123791: LD_ADDR_EXP 202
123795: PUSH
123796: LD_EXP 202
123800: PPUSH
123801: LD_VAR 0 8
123805: PPUSH
123806: LD_INT 0
123808: PPUSH
123809: CALL_OW 1
123813: ST_TO_ADDR
// exit ;
123814: POP
123815: POP
123816: GO 124349
// end ; x := list [ i ] [ 3 ] ;
123818: LD_ADDR_VAR 0 6
123822: PUSH
123823: LD_VAR 0 3
123827: PUSH
123828: LD_VAR 0 1
123832: ARRAY
123833: PUSH
123834: LD_INT 3
123836: ARRAY
123837: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
123838: LD_ADDR_VAR 0 7
123842: PUSH
123843: LD_VAR 0 3
123847: PUSH
123848: LD_VAR 0 1
123852: ARRAY
123853: PUSH
123854: LD_INT 4
123856: ARRAY
123857: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
123858: LD_ADDR_VAR 0 9
123862: PUSH
123863: LD_VAR 0 6
123867: PPUSH
123868: LD_VAR 0 7
123872: PPUSH
123873: LD_INT 16
123875: PPUSH
123876: CALL 107130 0 3
123880: ST_TO_ADDR
// if not cratesNearbyPoint then
123881: LD_VAR 0 9
123885: NOT
123886: IFFALSE 123892
// exit ;
123888: POP
123889: POP
123890: GO 124349
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
123892: LD_ADDR_VAR 0 4
123896: PUSH
123897: LD_INT 22
123899: PUSH
123900: LD_VAR 0 5
123904: PUSH
123905: EMPTY
123906: LIST
123907: LIST
123908: PUSH
123909: LD_INT 3
123911: PUSH
123912: LD_INT 60
123914: PUSH
123915: EMPTY
123916: LIST
123917: PUSH
123918: EMPTY
123919: LIST
123920: LIST
123921: PUSH
123922: LD_INT 91
123924: PUSH
123925: LD_VAR 0 8
123929: PUSH
123930: LD_INT 6
123932: PUSH
123933: EMPTY
123934: LIST
123935: LIST
123936: LIST
123937: PUSH
123938: LD_INT 2
123940: PUSH
123941: LD_INT 25
123943: PUSH
123944: LD_INT 2
123946: PUSH
123947: EMPTY
123948: LIST
123949: LIST
123950: PUSH
123951: LD_INT 25
123953: PUSH
123954: LD_INT 16
123956: PUSH
123957: EMPTY
123958: LIST
123959: LIST
123960: PUSH
123961: EMPTY
123962: LIST
123963: LIST
123964: LIST
123965: PUSH
123966: EMPTY
123967: LIST
123968: LIST
123969: LIST
123970: LIST
123971: PPUSH
123972: CALL_OW 69
123976: PUSH
123977: LD_VAR 0 8
123981: PPUSH
123982: CALL_OW 313
123986: PPUSH
123987: LD_INT 3
123989: PUSH
123990: LD_INT 60
123992: PUSH
123993: EMPTY
123994: LIST
123995: PUSH
123996: EMPTY
123997: LIST
123998: LIST
123999: PUSH
124000: LD_INT 2
124002: PUSH
124003: LD_INT 25
124005: PUSH
124006: LD_INT 2
124008: PUSH
124009: EMPTY
124010: LIST
124011: LIST
124012: PUSH
124013: LD_INT 25
124015: PUSH
124016: LD_INT 16
124018: PUSH
124019: EMPTY
124020: LIST
124021: LIST
124022: PUSH
124023: EMPTY
124024: LIST
124025: LIST
124026: LIST
124027: PUSH
124028: EMPTY
124029: LIST
124030: LIST
124031: PPUSH
124032: CALL_OW 72
124036: UNION
124037: ST_TO_ADDR
// if tmp then
124038: LD_VAR 0 4
124042: IFFALSE 124122
// begin tmp := ShrinkArray ( tmp , 3 ) ;
124044: LD_ADDR_VAR 0 4
124048: PUSH
124049: LD_VAR 0 4
124053: PPUSH
124054: LD_INT 3
124056: PPUSH
124057: CALL 105099 0 2
124061: ST_TO_ADDR
// for j in tmp do
124062: LD_ADDR_VAR 0 2
124066: PUSH
124067: LD_VAR 0 4
124071: PUSH
124072: FOR_IN
124073: IFFALSE 124116
// begin if IsInUnit ( j ) then
124075: LD_VAR 0 2
124079: PPUSH
124080: CALL_OW 310
124084: IFFALSE 124095
// ComExit ( j ) ;
124086: LD_VAR 0 2
124090: PPUSH
124091: CALL 105182 0 1
// AddComCollect ( j , x , y ) ;
124095: LD_VAR 0 2
124099: PPUSH
124100: LD_VAR 0 6
124104: PPUSH
124105: LD_VAR 0 7
124109: PPUSH
124110: CALL_OW 177
// end ;
124114: GO 124072
124116: POP
124117: POP
// exit ;
124118: POP
124119: POP
124120: GO 124349
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
124122: LD_ADDR_VAR 0 4
124126: PUSH
124127: LD_INT 22
124129: PUSH
124130: LD_VAR 0 5
124134: PUSH
124135: EMPTY
124136: LIST
124137: LIST
124138: PUSH
124139: LD_INT 91
124141: PUSH
124142: LD_VAR 0 8
124146: PUSH
124147: LD_INT 8
124149: PUSH
124150: EMPTY
124151: LIST
124152: LIST
124153: LIST
124154: PUSH
124155: LD_INT 2
124157: PUSH
124158: LD_INT 34
124160: PUSH
124161: LD_INT 12
124163: PUSH
124164: EMPTY
124165: LIST
124166: LIST
124167: PUSH
124168: LD_INT 34
124170: PUSH
124171: LD_INT 51
124173: PUSH
124174: EMPTY
124175: LIST
124176: LIST
124177: PUSH
124178: LD_INT 34
124180: PUSH
124181: LD_INT 32
124183: PUSH
124184: EMPTY
124185: LIST
124186: LIST
124187: PUSH
124188: LD_INT 34
124190: PUSH
124191: LD_INT 89
124193: PUSH
124194: EMPTY
124195: LIST
124196: LIST
124197: PUSH
124198: EMPTY
124199: LIST
124200: LIST
124201: LIST
124202: LIST
124203: LIST
124204: PUSH
124205: EMPTY
124206: LIST
124207: LIST
124208: LIST
124209: PPUSH
124210: CALL_OW 69
124214: ST_TO_ADDR
// if tmp then
124215: LD_VAR 0 4
124219: IFFALSE 124345
// begin for j in tmp do
124221: LD_ADDR_VAR 0 2
124225: PUSH
124226: LD_VAR 0 4
124230: PUSH
124231: FOR_IN
124232: IFFALSE 124343
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
124234: LD_VAR 0 2
124238: PPUSH
124239: CALL_OW 262
124243: PUSH
124244: LD_INT 3
124246: EQUAL
124247: PUSH
124248: LD_VAR 0 2
124252: PPUSH
124253: CALL_OW 261
124257: PUSH
124258: LD_INT 20
124260: GREATER
124261: OR
124262: PUSH
124263: LD_VAR 0 2
124267: PPUSH
124268: CALL_OW 314
124272: NOT
124273: AND
124274: PUSH
124275: LD_VAR 0 2
124279: PPUSH
124280: CALL_OW 263
124284: PUSH
124285: LD_INT 1
124287: NONEQUAL
124288: PUSH
124289: LD_VAR 0 2
124293: PPUSH
124294: CALL_OW 311
124298: OR
124299: AND
124300: IFFALSE 124341
// begin ComCollect ( j , x , y ) ;
124302: LD_VAR 0 2
124306: PPUSH
124307: LD_VAR 0 6
124311: PPUSH
124312: LD_VAR 0 7
124316: PPUSH
124317: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
124321: LD_VAR 0 2
124325: PPUSH
124326: LD_VAR 0 8
124330: PPUSH
124331: CALL_OW 172
// exit ;
124335: POP
124336: POP
124337: POP
124338: POP
124339: GO 124349
// end ;
124341: GO 124231
124343: POP
124344: POP
// end ; end ;
124345: GO 123720
124347: POP
124348: POP
// end ; end_of_file
124349: PPOPN 9
124351: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
124352: LD_INT 0
124354: PPUSH
124355: PPUSH
124356: PPUSH
124357: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
124358: LD_VAR 0 1
124362: PPUSH
124363: CALL_OW 264
124367: PUSH
124368: LD_INT 91
124370: EQUAL
124371: IFFALSE 124443
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
124373: LD_INT 68
124375: PPUSH
124376: LD_VAR 0 1
124380: PPUSH
124381: CALL_OW 255
124385: PPUSH
124386: CALL_OW 321
124390: PUSH
124391: LD_INT 2
124393: EQUAL
124394: IFFALSE 124406
// eff := 70 else
124396: LD_ADDR_VAR 0 4
124400: PUSH
124401: LD_INT 70
124403: ST_TO_ADDR
124404: GO 124414
// eff := 30 ;
124406: LD_ADDR_VAR 0 4
124410: PUSH
124411: LD_INT 30
124413: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
124414: LD_VAR 0 1
124418: PPUSH
124419: CALL_OW 250
124423: PPUSH
124424: LD_VAR 0 1
124428: PPUSH
124429: CALL_OW 251
124433: PPUSH
124434: LD_VAR 0 4
124438: PPUSH
124439: CALL_OW 495
// end ; end ;
124443: LD_VAR 0 2
124447: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
124448: LD_INT 0
124450: PPUSH
// end ;
124451: LD_VAR 0 4
124455: RET
// export function SOS_Command ( cmd ) ; begin
124456: LD_INT 0
124458: PPUSH
// end ;
124459: LD_VAR 0 2
124463: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
124464: LD_INT 0
124466: PPUSH
// end ;
124467: LD_VAR 0 6
124471: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
124472: LD_INT 0
124474: PPUSH
124475: PPUSH
// if not vehicle or not factory then
124476: LD_VAR 0 1
124480: NOT
124481: PUSH
124482: LD_VAR 0 2
124486: NOT
124487: OR
124488: IFFALSE 124492
// exit ;
124490: GO 124723
// if factoryWaypoints >= factory then
124492: LD_EXP 201
124496: PUSH
124497: LD_VAR 0 2
124501: GREATEREQUAL
124502: IFFALSE 124723
// if factoryWaypoints [ factory ] then
124504: LD_EXP 201
124508: PUSH
124509: LD_VAR 0 2
124513: ARRAY
124514: IFFALSE 124723
// begin if GetControl ( vehicle ) = control_manual then
124516: LD_VAR 0 1
124520: PPUSH
124521: CALL_OW 263
124525: PUSH
124526: LD_INT 1
124528: EQUAL
124529: IFFALSE 124610
// begin driver := IsDrivenBy ( vehicle ) ;
124531: LD_ADDR_VAR 0 4
124535: PUSH
124536: LD_VAR 0 1
124540: PPUSH
124541: CALL_OW 311
124545: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
124546: LD_VAR 0 4
124550: PPUSH
124551: LD_EXP 201
124555: PUSH
124556: LD_VAR 0 2
124560: ARRAY
124561: PUSH
124562: LD_INT 3
124564: ARRAY
124565: PPUSH
124566: LD_EXP 201
124570: PUSH
124571: LD_VAR 0 2
124575: ARRAY
124576: PUSH
124577: LD_INT 4
124579: ARRAY
124580: PPUSH
124581: CALL_OW 171
// AddComExitVehicle ( driver ) ;
124585: LD_VAR 0 4
124589: PPUSH
124590: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
124594: LD_VAR 0 4
124598: PPUSH
124599: LD_VAR 0 2
124603: PPUSH
124604: CALL_OW 180
// end else
124608: GO 124723
// if GetControl ( vehicle ) = control_remote then
124610: LD_VAR 0 1
124614: PPUSH
124615: CALL_OW 263
124619: PUSH
124620: LD_INT 2
124622: EQUAL
124623: IFFALSE 124684
// begin wait ( 0 0$2 ) ;
124625: LD_INT 70
124627: PPUSH
124628: CALL_OW 67
// if Connect ( vehicle ) then
124632: LD_VAR 0 1
124636: PPUSH
124637: CALL 75441 0 1
124641: IFFALSE 124682
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
124643: LD_VAR 0 1
124647: PPUSH
124648: LD_EXP 201
124652: PUSH
124653: LD_VAR 0 2
124657: ARRAY
124658: PUSH
124659: LD_INT 3
124661: ARRAY
124662: PPUSH
124663: LD_EXP 201
124667: PUSH
124668: LD_VAR 0 2
124672: ARRAY
124673: PUSH
124674: LD_INT 4
124676: ARRAY
124677: PPUSH
124678: CALL_OW 171
// end else
124682: GO 124723
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
124684: LD_VAR 0 1
124688: PPUSH
124689: LD_EXP 201
124693: PUSH
124694: LD_VAR 0 2
124698: ARRAY
124699: PUSH
124700: LD_INT 3
124702: ARRAY
124703: PPUSH
124704: LD_EXP 201
124708: PUSH
124709: LD_VAR 0 2
124713: ARRAY
124714: PUSH
124715: LD_INT 4
124717: ARRAY
124718: PPUSH
124719: CALL_OW 171
// end ; end ;
124723: LD_VAR 0 3
124727: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
124728: LD_INT 0
124730: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
124731: LD_VAR 0 1
124735: PUSH
124736: LD_INT 250
124738: EQUAL
124739: PUSH
124740: LD_VAR 0 2
124744: PPUSH
124745: CALL_OW 264
124749: PUSH
124750: LD_INT 81
124752: EQUAL
124753: AND
124754: IFFALSE 124775
// MinerPlaceMine ( unit , x , y ) ;
124756: LD_VAR 0 2
124760: PPUSH
124761: LD_VAR 0 4
124765: PPUSH
124766: LD_VAR 0 5
124770: PPUSH
124771: CALL 127160 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
124775: LD_VAR 0 1
124779: PUSH
124780: LD_INT 251
124782: EQUAL
124783: PUSH
124784: LD_VAR 0 2
124788: PPUSH
124789: CALL_OW 264
124793: PUSH
124794: LD_INT 81
124796: EQUAL
124797: AND
124798: IFFALSE 124819
// MinerDetonateMine ( unit , x , y ) ;
124800: LD_VAR 0 2
124804: PPUSH
124805: LD_VAR 0 4
124809: PPUSH
124810: LD_VAR 0 5
124814: PPUSH
124815: CALL 127435 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
124819: LD_VAR 0 1
124823: PUSH
124824: LD_INT 252
124826: EQUAL
124827: PUSH
124828: LD_VAR 0 2
124832: PPUSH
124833: CALL_OW 264
124837: PUSH
124838: LD_INT 81
124840: EQUAL
124841: AND
124842: IFFALSE 124863
// MinerCreateMinefield ( unit , x , y ) ;
124844: LD_VAR 0 2
124848: PPUSH
124849: LD_VAR 0 4
124853: PPUSH
124854: LD_VAR 0 5
124858: PPUSH
124859: CALL 127852 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
124863: LD_VAR 0 1
124867: PUSH
124868: LD_INT 253
124870: EQUAL
124871: PUSH
124872: LD_VAR 0 2
124876: PPUSH
124877: CALL_OW 257
124881: PUSH
124882: LD_INT 5
124884: EQUAL
124885: AND
124886: IFFALSE 124907
// ComBinocular ( unit , x , y ) ;
124888: LD_VAR 0 2
124892: PPUSH
124893: LD_VAR 0 4
124897: PPUSH
124898: LD_VAR 0 5
124902: PPUSH
124903: CALL 128221 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
124907: LD_VAR 0 1
124911: PUSH
124912: LD_INT 254
124914: EQUAL
124915: PUSH
124916: LD_VAR 0 2
124920: PPUSH
124921: CALL_OW 264
124925: PUSH
124926: LD_INT 99
124928: EQUAL
124929: AND
124930: PUSH
124931: LD_VAR 0 3
124935: PPUSH
124936: CALL_OW 263
124940: PUSH
124941: LD_INT 3
124943: EQUAL
124944: AND
124945: IFFALSE 124961
// HackDestroyVehicle ( unit , selectedUnit ) ;
124947: LD_VAR 0 2
124951: PPUSH
124952: LD_VAR 0 3
124956: PPUSH
124957: CALL 126524 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
124961: LD_VAR 0 1
124965: PUSH
124966: LD_INT 255
124968: EQUAL
124969: PUSH
124970: LD_VAR 0 2
124974: PPUSH
124975: CALL_OW 264
124979: PUSH
124980: LD_INT 14
124982: PUSH
124983: LD_INT 53
124985: PUSH
124986: EMPTY
124987: LIST
124988: LIST
124989: IN
124990: AND
124991: PUSH
124992: LD_VAR 0 4
124996: PPUSH
124997: LD_VAR 0 5
125001: PPUSH
125002: CALL_OW 488
125006: AND
125007: IFFALSE 125031
// CutTreeXYR ( unit , x , y , 12 ) ;
125009: LD_VAR 0 2
125013: PPUSH
125014: LD_VAR 0 4
125018: PPUSH
125019: LD_VAR 0 5
125023: PPUSH
125024: LD_INT 12
125026: PPUSH
125027: CALL 125094 0 4
// if cmd = 256 then
125031: LD_VAR 0 1
125035: PUSH
125036: LD_INT 256
125038: EQUAL
125039: IFFALSE 125060
// SetFactoryWaypoint ( unit , x , y ) ;
125041: LD_VAR 0 2
125045: PPUSH
125046: LD_VAR 0 4
125050: PPUSH
125051: LD_VAR 0 5
125055: PPUSH
125056: CALL 123041 0 3
// if cmd = 257 then
125060: LD_VAR 0 1
125064: PUSH
125065: LD_INT 257
125067: EQUAL
125068: IFFALSE 125089
// SetWarehouseGatheringPoint ( unit , x , y ) ;
125070: LD_VAR 0 2
125074: PPUSH
125075: LD_VAR 0 4
125079: PPUSH
125080: LD_VAR 0 5
125084: PPUSH
125085: CALL 123403 0 3
// end ;
125089: LD_VAR 0 6
125093: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
125094: LD_INT 0
125096: PPUSH
125097: PPUSH
125098: PPUSH
125099: PPUSH
125100: PPUSH
125101: PPUSH
125102: PPUSH
125103: PPUSH
125104: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
125105: LD_VAR 0 1
125109: NOT
125110: PUSH
125111: LD_VAR 0 2
125115: PPUSH
125116: LD_VAR 0 3
125120: PPUSH
125121: CALL_OW 488
125125: NOT
125126: OR
125127: PUSH
125128: LD_VAR 0 4
125132: NOT
125133: OR
125134: IFFALSE 125138
// exit ;
125136: GO 125478
// list := [ ] ;
125138: LD_ADDR_VAR 0 13
125142: PUSH
125143: EMPTY
125144: ST_TO_ADDR
// if x - r < 0 then
125145: LD_VAR 0 2
125149: PUSH
125150: LD_VAR 0 4
125154: MINUS
125155: PUSH
125156: LD_INT 0
125158: LESS
125159: IFFALSE 125171
// min_x := 0 else
125161: LD_ADDR_VAR 0 7
125165: PUSH
125166: LD_INT 0
125168: ST_TO_ADDR
125169: GO 125187
// min_x := x - r ;
125171: LD_ADDR_VAR 0 7
125175: PUSH
125176: LD_VAR 0 2
125180: PUSH
125181: LD_VAR 0 4
125185: MINUS
125186: ST_TO_ADDR
// if y - r < 0 then
125187: LD_VAR 0 3
125191: PUSH
125192: LD_VAR 0 4
125196: MINUS
125197: PUSH
125198: LD_INT 0
125200: LESS
125201: IFFALSE 125213
// min_y := 0 else
125203: LD_ADDR_VAR 0 8
125207: PUSH
125208: LD_INT 0
125210: ST_TO_ADDR
125211: GO 125229
// min_y := y - r ;
125213: LD_ADDR_VAR 0 8
125217: PUSH
125218: LD_VAR 0 3
125222: PUSH
125223: LD_VAR 0 4
125227: MINUS
125228: ST_TO_ADDR
// max_x := x + r ;
125229: LD_ADDR_VAR 0 9
125233: PUSH
125234: LD_VAR 0 2
125238: PUSH
125239: LD_VAR 0 4
125243: PLUS
125244: ST_TO_ADDR
// max_y := y + r ;
125245: LD_ADDR_VAR 0 10
125249: PUSH
125250: LD_VAR 0 3
125254: PUSH
125255: LD_VAR 0 4
125259: PLUS
125260: ST_TO_ADDR
// for _x = min_x to max_x do
125261: LD_ADDR_VAR 0 11
125265: PUSH
125266: DOUBLE
125267: LD_VAR 0 7
125271: DEC
125272: ST_TO_ADDR
125273: LD_VAR 0 9
125277: PUSH
125278: FOR_TO
125279: IFFALSE 125396
// for _y = min_y to max_y do
125281: LD_ADDR_VAR 0 12
125285: PUSH
125286: DOUBLE
125287: LD_VAR 0 8
125291: DEC
125292: ST_TO_ADDR
125293: LD_VAR 0 10
125297: PUSH
125298: FOR_TO
125299: IFFALSE 125392
// begin if not ValidHex ( _x , _y ) then
125301: LD_VAR 0 11
125305: PPUSH
125306: LD_VAR 0 12
125310: PPUSH
125311: CALL_OW 488
125315: NOT
125316: IFFALSE 125320
// continue ;
125318: GO 125298
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
125320: LD_VAR 0 11
125324: PPUSH
125325: LD_VAR 0 12
125329: PPUSH
125330: CALL_OW 351
125334: PUSH
125335: LD_VAR 0 11
125339: PPUSH
125340: LD_VAR 0 12
125344: PPUSH
125345: CALL_OW 554
125349: AND
125350: IFFALSE 125390
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
125352: LD_ADDR_VAR 0 13
125356: PUSH
125357: LD_VAR 0 13
125361: PPUSH
125362: LD_VAR 0 13
125366: PUSH
125367: LD_INT 1
125369: PLUS
125370: PPUSH
125371: LD_VAR 0 11
125375: PUSH
125376: LD_VAR 0 12
125380: PUSH
125381: EMPTY
125382: LIST
125383: LIST
125384: PPUSH
125385: CALL_OW 2
125389: ST_TO_ADDR
// end ;
125390: GO 125298
125392: POP
125393: POP
125394: GO 125278
125396: POP
125397: POP
// if not list then
125398: LD_VAR 0 13
125402: NOT
125403: IFFALSE 125407
// exit ;
125405: GO 125478
// for i in list do
125407: LD_ADDR_VAR 0 6
125411: PUSH
125412: LD_VAR 0 13
125416: PUSH
125417: FOR_IN
125418: IFFALSE 125476
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
125420: LD_VAR 0 1
125424: PPUSH
125425: LD_STRING M
125427: PUSH
125428: LD_VAR 0 6
125432: PUSH
125433: LD_INT 1
125435: ARRAY
125436: PUSH
125437: LD_VAR 0 6
125441: PUSH
125442: LD_INT 2
125444: ARRAY
125445: PUSH
125446: LD_INT 0
125448: PUSH
125449: LD_INT 0
125451: PUSH
125452: LD_INT 0
125454: PUSH
125455: LD_INT 0
125457: PUSH
125458: EMPTY
125459: LIST
125460: LIST
125461: LIST
125462: LIST
125463: LIST
125464: LIST
125465: LIST
125466: PUSH
125467: EMPTY
125468: LIST
125469: PPUSH
125470: CALL_OW 447
125474: GO 125417
125476: POP
125477: POP
// end ;
125478: LD_VAR 0 5
125482: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
125483: LD_EXP 204
125487: NOT
125488: IFFALSE 125538
125490: GO 125492
125492: DISABLE
// begin initHack := true ;
125493: LD_ADDR_EXP 204
125497: PUSH
125498: LD_INT 1
125500: ST_TO_ADDR
// hackTanks := [ ] ;
125501: LD_ADDR_EXP 205
125505: PUSH
125506: EMPTY
125507: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
125508: LD_ADDR_EXP 206
125512: PUSH
125513: EMPTY
125514: ST_TO_ADDR
// hackLimit := 3 ;
125515: LD_ADDR_EXP 207
125519: PUSH
125520: LD_INT 3
125522: ST_TO_ADDR
// hackDist := 12 ;
125523: LD_ADDR_EXP 208
125527: PUSH
125528: LD_INT 12
125530: ST_TO_ADDR
// hackCounter := [ ] ;
125531: LD_ADDR_EXP 209
125535: PUSH
125536: EMPTY
125537: ST_TO_ADDR
// end ;
125538: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
125539: LD_EXP 204
125543: PUSH
125544: LD_INT 34
125546: PUSH
125547: LD_INT 99
125549: PUSH
125550: EMPTY
125551: LIST
125552: LIST
125553: PPUSH
125554: CALL_OW 69
125558: AND
125559: IFFALSE 125812
125561: GO 125563
125563: DISABLE
125564: LD_INT 0
125566: PPUSH
125567: PPUSH
// begin enable ;
125568: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
125569: LD_ADDR_VAR 0 1
125573: PUSH
125574: LD_INT 34
125576: PUSH
125577: LD_INT 99
125579: PUSH
125580: EMPTY
125581: LIST
125582: LIST
125583: PPUSH
125584: CALL_OW 69
125588: PUSH
125589: FOR_IN
125590: IFFALSE 125810
// begin if not i in hackTanks then
125592: LD_VAR 0 1
125596: PUSH
125597: LD_EXP 205
125601: IN
125602: NOT
125603: IFFALSE 125686
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
125605: LD_ADDR_EXP 205
125609: PUSH
125610: LD_EXP 205
125614: PPUSH
125615: LD_EXP 205
125619: PUSH
125620: LD_INT 1
125622: PLUS
125623: PPUSH
125624: LD_VAR 0 1
125628: PPUSH
125629: CALL_OW 1
125633: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
125634: LD_ADDR_EXP 206
125638: PUSH
125639: LD_EXP 206
125643: PPUSH
125644: LD_EXP 206
125648: PUSH
125649: LD_INT 1
125651: PLUS
125652: PPUSH
125653: EMPTY
125654: PPUSH
125655: CALL_OW 1
125659: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
125660: LD_ADDR_EXP 209
125664: PUSH
125665: LD_EXP 209
125669: PPUSH
125670: LD_EXP 209
125674: PUSH
125675: LD_INT 1
125677: PLUS
125678: PPUSH
125679: EMPTY
125680: PPUSH
125681: CALL_OW 1
125685: ST_TO_ADDR
// end ; if not IsOk ( i ) then
125686: LD_VAR 0 1
125690: PPUSH
125691: CALL_OW 302
125695: NOT
125696: IFFALSE 125709
// begin HackUnlinkAll ( i ) ;
125698: LD_VAR 0 1
125702: PPUSH
125703: CALL 125815 0 1
// continue ;
125707: GO 125589
// end ; HackCheckCapturedStatus ( i ) ;
125709: LD_VAR 0 1
125713: PPUSH
125714: CALL 126258 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
125718: LD_ADDR_VAR 0 2
125722: PUSH
125723: LD_INT 81
125725: PUSH
125726: LD_VAR 0 1
125730: PPUSH
125731: CALL_OW 255
125735: PUSH
125736: EMPTY
125737: LIST
125738: LIST
125739: PUSH
125740: LD_INT 33
125742: PUSH
125743: LD_INT 3
125745: PUSH
125746: EMPTY
125747: LIST
125748: LIST
125749: PUSH
125750: LD_INT 91
125752: PUSH
125753: LD_VAR 0 1
125757: PUSH
125758: LD_EXP 208
125762: PUSH
125763: EMPTY
125764: LIST
125765: LIST
125766: LIST
125767: PUSH
125768: LD_INT 50
125770: PUSH
125771: EMPTY
125772: LIST
125773: PUSH
125774: EMPTY
125775: LIST
125776: LIST
125777: LIST
125778: LIST
125779: PPUSH
125780: CALL_OW 69
125784: ST_TO_ADDR
// if not tmp then
125785: LD_VAR 0 2
125789: NOT
125790: IFFALSE 125794
// continue ;
125792: GO 125589
// HackLink ( i , tmp ) ;
125794: LD_VAR 0 1
125798: PPUSH
125799: LD_VAR 0 2
125803: PPUSH
125804: CALL 125951 0 2
// end ;
125808: GO 125589
125810: POP
125811: POP
// end ;
125812: PPOPN 2
125814: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
125815: LD_INT 0
125817: PPUSH
125818: PPUSH
125819: PPUSH
// if not hack in hackTanks then
125820: LD_VAR 0 1
125824: PUSH
125825: LD_EXP 205
125829: IN
125830: NOT
125831: IFFALSE 125835
// exit ;
125833: GO 125946
// index := GetElementIndex ( hackTanks , hack ) ;
125835: LD_ADDR_VAR 0 4
125839: PUSH
125840: LD_EXP 205
125844: PPUSH
125845: LD_VAR 0 1
125849: PPUSH
125850: CALL 72257 0 2
125854: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
125855: LD_EXP 206
125859: PUSH
125860: LD_VAR 0 4
125864: ARRAY
125865: IFFALSE 125946
// begin for i in hackTanksCaptured [ index ] do
125867: LD_ADDR_VAR 0 3
125871: PUSH
125872: LD_EXP 206
125876: PUSH
125877: LD_VAR 0 4
125881: ARRAY
125882: PUSH
125883: FOR_IN
125884: IFFALSE 125910
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
125886: LD_VAR 0 3
125890: PUSH
125891: LD_INT 1
125893: ARRAY
125894: PPUSH
125895: LD_VAR 0 3
125899: PUSH
125900: LD_INT 2
125902: ARRAY
125903: PPUSH
125904: CALL_OW 235
125908: GO 125883
125910: POP
125911: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
125912: LD_ADDR_EXP 206
125916: PUSH
125917: LD_EXP 206
125921: PPUSH
125922: LD_VAR 0 4
125926: PPUSH
125927: EMPTY
125928: PPUSH
125929: CALL_OW 1
125933: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
125934: LD_VAR 0 1
125938: PPUSH
125939: LD_INT 0
125941: PPUSH
125942: CALL_OW 505
// end ; end ;
125946: LD_VAR 0 2
125950: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
125951: LD_INT 0
125953: PPUSH
125954: PPUSH
125955: PPUSH
// if not hack in hackTanks or not vehicles then
125956: LD_VAR 0 1
125960: PUSH
125961: LD_EXP 205
125965: IN
125966: NOT
125967: PUSH
125968: LD_VAR 0 2
125972: NOT
125973: OR
125974: IFFALSE 125978
// exit ;
125976: GO 126253
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
125978: LD_ADDR_VAR 0 2
125982: PUSH
125983: LD_VAR 0 1
125987: PPUSH
125988: LD_VAR 0 2
125992: PPUSH
125993: LD_INT 1
125995: PPUSH
125996: LD_INT 1
125998: PPUSH
125999: CALL 72907 0 4
126003: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
126004: LD_ADDR_VAR 0 5
126008: PUSH
126009: LD_EXP 205
126013: PPUSH
126014: LD_VAR 0 1
126018: PPUSH
126019: CALL 72257 0 2
126023: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
126024: LD_EXP 206
126028: PUSH
126029: LD_VAR 0 5
126033: ARRAY
126034: PUSH
126035: LD_EXP 207
126039: LESS
126040: IFFALSE 126229
// begin for i := 1 to vehicles do
126042: LD_ADDR_VAR 0 4
126046: PUSH
126047: DOUBLE
126048: LD_INT 1
126050: DEC
126051: ST_TO_ADDR
126052: LD_VAR 0 2
126056: PUSH
126057: FOR_TO
126058: IFFALSE 126227
// begin if hackTanksCaptured [ index ] = hackLimit then
126060: LD_EXP 206
126064: PUSH
126065: LD_VAR 0 5
126069: ARRAY
126070: PUSH
126071: LD_EXP 207
126075: EQUAL
126076: IFFALSE 126080
// break ;
126078: GO 126227
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
126080: LD_ADDR_EXP 209
126084: PUSH
126085: LD_EXP 209
126089: PPUSH
126090: LD_VAR 0 5
126094: PPUSH
126095: LD_EXP 209
126099: PUSH
126100: LD_VAR 0 5
126104: ARRAY
126105: PUSH
126106: LD_INT 1
126108: PLUS
126109: PPUSH
126110: CALL_OW 1
126114: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
126115: LD_ADDR_EXP 206
126119: PUSH
126120: LD_EXP 206
126124: PPUSH
126125: LD_VAR 0 5
126129: PUSH
126130: LD_EXP 206
126134: PUSH
126135: LD_VAR 0 5
126139: ARRAY
126140: PUSH
126141: LD_INT 1
126143: PLUS
126144: PUSH
126145: EMPTY
126146: LIST
126147: LIST
126148: PPUSH
126149: LD_VAR 0 2
126153: PUSH
126154: LD_VAR 0 4
126158: ARRAY
126159: PUSH
126160: LD_VAR 0 2
126164: PUSH
126165: LD_VAR 0 4
126169: ARRAY
126170: PPUSH
126171: CALL_OW 255
126175: PUSH
126176: EMPTY
126177: LIST
126178: LIST
126179: PPUSH
126180: CALL 72472 0 3
126184: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
126185: LD_VAR 0 2
126189: PUSH
126190: LD_VAR 0 4
126194: ARRAY
126195: PPUSH
126196: LD_VAR 0 1
126200: PPUSH
126201: CALL_OW 255
126205: PPUSH
126206: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
126210: LD_VAR 0 2
126214: PUSH
126215: LD_VAR 0 4
126219: ARRAY
126220: PPUSH
126221: CALL_OW 141
// end ;
126225: GO 126057
126227: POP
126228: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
126229: LD_VAR 0 1
126233: PPUSH
126234: LD_EXP 206
126238: PUSH
126239: LD_VAR 0 5
126243: ARRAY
126244: PUSH
126245: LD_INT 0
126247: PLUS
126248: PPUSH
126249: CALL_OW 505
// end ;
126253: LD_VAR 0 3
126257: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
126258: LD_INT 0
126260: PPUSH
126261: PPUSH
126262: PPUSH
126263: PPUSH
// if not hack in hackTanks then
126264: LD_VAR 0 1
126268: PUSH
126269: LD_EXP 205
126273: IN
126274: NOT
126275: IFFALSE 126279
// exit ;
126277: GO 126519
// index := GetElementIndex ( hackTanks , hack ) ;
126279: LD_ADDR_VAR 0 4
126283: PUSH
126284: LD_EXP 205
126288: PPUSH
126289: LD_VAR 0 1
126293: PPUSH
126294: CALL 72257 0 2
126298: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
126299: LD_ADDR_VAR 0 3
126303: PUSH
126304: DOUBLE
126305: LD_EXP 206
126309: PUSH
126310: LD_VAR 0 4
126314: ARRAY
126315: INC
126316: ST_TO_ADDR
126317: LD_INT 1
126319: PUSH
126320: FOR_DOWNTO
126321: IFFALSE 126493
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
126323: LD_ADDR_VAR 0 5
126327: PUSH
126328: LD_EXP 206
126332: PUSH
126333: LD_VAR 0 4
126337: ARRAY
126338: PUSH
126339: LD_VAR 0 3
126343: ARRAY
126344: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
126345: LD_VAR 0 5
126349: PUSH
126350: LD_INT 1
126352: ARRAY
126353: PPUSH
126354: CALL_OW 302
126358: NOT
126359: PUSH
126360: LD_VAR 0 5
126364: PUSH
126365: LD_INT 1
126367: ARRAY
126368: PPUSH
126369: CALL_OW 255
126373: PUSH
126374: LD_VAR 0 1
126378: PPUSH
126379: CALL_OW 255
126383: NONEQUAL
126384: OR
126385: IFFALSE 126491
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
126387: LD_VAR 0 5
126391: PUSH
126392: LD_INT 1
126394: ARRAY
126395: PPUSH
126396: CALL_OW 305
126400: PUSH
126401: LD_VAR 0 5
126405: PUSH
126406: LD_INT 1
126408: ARRAY
126409: PPUSH
126410: CALL_OW 255
126414: PUSH
126415: LD_VAR 0 1
126419: PPUSH
126420: CALL_OW 255
126424: EQUAL
126425: AND
126426: IFFALSE 126450
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
126428: LD_VAR 0 5
126432: PUSH
126433: LD_INT 1
126435: ARRAY
126436: PPUSH
126437: LD_VAR 0 5
126441: PUSH
126442: LD_INT 2
126444: ARRAY
126445: PPUSH
126446: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
126450: LD_ADDR_EXP 206
126454: PUSH
126455: LD_EXP 206
126459: PPUSH
126460: LD_VAR 0 4
126464: PPUSH
126465: LD_EXP 206
126469: PUSH
126470: LD_VAR 0 4
126474: ARRAY
126475: PPUSH
126476: LD_VAR 0 3
126480: PPUSH
126481: CALL_OW 3
126485: PPUSH
126486: CALL_OW 1
126490: ST_TO_ADDR
// end ; end ;
126491: GO 126320
126493: POP
126494: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
126495: LD_VAR 0 1
126499: PPUSH
126500: LD_EXP 206
126504: PUSH
126505: LD_VAR 0 4
126509: ARRAY
126510: PUSH
126511: LD_INT 0
126513: PLUS
126514: PPUSH
126515: CALL_OW 505
// end ;
126519: LD_VAR 0 2
126523: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
126524: LD_INT 0
126526: PPUSH
126527: PPUSH
126528: PPUSH
126529: PPUSH
// if not hack in hackTanks then
126530: LD_VAR 0 1
126534: PUSH
126535: LD_EXP 205
126539: IN
126540: NOT
126541: IFFALSE 126545
// exit ;
126543: GO 126630
// index := GetElementIndex ( hackTanks , hack ) ;
126545: LD_ADDR_VAR 0 5
126549: PUSH
126550: LD_EXP 205
126554: PPUSH
126555: LD_VAR 0 1
126559: PPUSH
126560: CALL 72257 0 2
126564: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
126565: LD_ADDR_VAR 0 4
126569: PUSH
126570: DOUBLE
126571: LD_INT 1
126573: DEC
126574: ST_TO_ADDR
126575: LD_EXP 206
126579: PUSH
126580: LD_VAR 0 5
126584: ARRAY
126585: PUSH
126586: FOR_TO
126587: IFFALSE 126628
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
126589: LD_EXP 206
126593: PUSH
126594: LD_VAR 0 5
126598: ARRAY
126599: PUSH
126600: LD_VAR 0 4
126604: ARRAY
126605: PUSH
126606: LD_INT 1
126608: ARRAY
126609: PUSH
126610: LD_VAR 0 2
126614: EQUAL
126615: IFFALSE 126626
// KillUnit ( vehicle ) ;
126617: LD_VAR 0 2
126621: PPUSH
126622: CALL_OW 66
126626: GO 126586
126628: POP
126629: POP
// end ;
126630: LD_VAR 0 3
126634: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
126635: LD_EXP 210
126639: NOT
126640: IFFALSE 126675
126642: GO 126644
126644: DISABLE
// begin initMiner := true ;
126645: LD_ADDR_EXP 210
126649: PUSH
126650: LD_INT 1
126652: ST_TO_ADDR
// minersList := [ ] ;
126653: LD_ADDR_EXP 211
126657: PUSH
126658: EMPTY
126659: ST_TO_ADDR
// minerMinesList := [ ] ;
126660: LD_ADDR_EXP 212
126664: PUSH
126665: EMPTY
126666: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
126667: LD_ADDR_EXP 213
126671: PUSH
126672: LD_INT 5
126674: ST_TO_ADDR
// end ;
126675: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
126676: LD_EXP 210
126680: PUSH
126681: LD_INT 34
126683: PUSH
126684: LD_INT 81
126686: PUSH
126687: EMPTY
126688: LIST
126689: LIST
126690: PPUSH
126691: CALL_OW 69
126695: AND
126696: IFFALSE 127157
126698: GO 126700
126700: DISABLE
126701: LD_INT 0
126703: PPUSH
126704: PPUSH
126705: PPUSH
126706: PPUSH
// begin enable ;
126707: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
126708: LD_ADDR_VAR 0 1
126712: PUSH
126713: LD_INT 34
126715: PUSH
126716: LD_INT 81
126718: PUSH
126719: EMPTY
126720: LIST
126721: LIST
126722: PPUSH
126723: CALL_OW 69
126727: PUSH
126728: FOR_IN
126729: IFFALSE 126801
// begin if not i in minersList then
126731: LD_VAR 0 1
126735: PUSH
126736: LD_EXP 211
126740: IN
126741: NOT
126742: IFFALSE 126799
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
126744: LD_ADDR_EXP 211
126748: PUSH
126749: LD_EXP 211
126753: PPUSH
126754: LD_EXP 211
126758: PUSH
126759: LD_INT 1
126761: PLUS
126762: PPUSH
126763: LD_VAR 0 1
126767: PPUSH
126768: CALL_OW 1
126772: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
126773: LD_ADDR_EXP 212
126777: PUSH
126778: LD_EXP 212
126782: PPUSH
126783: LD_EXP 212
126787: PUSH
126788: LD_INT 1
126790: PLUS
126791: PPUSH
126792: EMPTY
126793: PPUSH
126794: CALL_OW 1
126798: ST_TO_ADDR
// end end ;
126799: GO 126728
126801: POP
126802: POP
// for i := minerMinesList downto 1 do
126803: LD_ADDR_VAR 0 1
126807: PUSH
126808: DOUBLE
126809: LD_EXP 212
126813: INC
126814: ST_TO_ADDR
126815: LD_INT 1
126817: PUSH
126818: FOR_DOWNTO
126819: IFFALSE 127155
// begin if IsLive ( minersList [ i ] ) then
126821: LD_EXP 211
126825: PUSH
126826: LD_VAR 0 1
126830: ARRAY
126831: PPUSH
126832: CALL_OW 300
126836: IFFALSE 126864
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
126838: LD_EXP 211
126842: PUSH
126843: LD_VAR 0 1
126847: ARRAY
126848: PPUSH
126849: LD_EXP 212
126853: PUSH
126854: LD_VAR 0 1
126858: ARRAY
126859: PPUSH
126860: CALL_OW 505
// if not minerMinesList [ i ] then
126864: LD_EXP 212
126868: PUSH
126869: LD_VAR 0 1
126873: ARRAY
126874: NOT
126875: IFFALSE 126879
// continue ;
126877: GO 126818
// for j := minerMinesList [ i ] downto 1 do
126879: LD_ADDR_VAR 0 2
126883: PUSH
126884: DOUBLE
126885: LD_EXP 212
126889: PUSH
126890: LD_VAR 0 1
126894: ARRAY
126895: INC
126896: ST_TO_ADDR
126897: LD_INT 1
126899: PUSH
126900: FOR_DOWNTO
126901: IFFALSE 127151
// begin side := GetSide ( minersList [ i ] ) ;
126903: LD_ADDR_VAR 0 3
126907: PUSH
126908: LD_EXP 211
126912: PUSH
126913: LD_VAR 0 1
126917: ARRAY
126918: PPUSH
126919: CALL_OW 255
126923: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
126924: LD_ADDR_VAR 0 4
126928: PUSH
126929: LD_EXP 212
126933: PUSH
126934: LD_VAR 0 1
126938: ARRAY
126939: PUSH
126940: LD_VAR 0 2
126944: ARRAY
126945: PUSH
126946: LD_INT 1
126948: ARRAY
126949: PPUSH
126950: LD_EXP 212
126954: PUSH
126955: LD_VAR 0 1
126959: ARRAY
126960: PUSH
126961: LD_VAR 0 2
126965: ARRAY
126966: PUSH
126967: LD_INT 2
126969: ARRAY
126970: PPUSH
126971: CALL_OW 428
126975: ST_TO_ADDR
// if not tmp then
126976: LD_VAR 0 4
126980: NOT
126981: IFFALSE 126985
// continue ;
126983: GO 126900
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
126985: LD_VAR 0 4
126989: PUSH
126990: LD_INT 81
126992: PUSH
126993: LD_VAR 0 3
126997: PUSH
126998: EMPTY
126999: LIST
127000: LIST
127001: PPUSH
127002: CALL_OW 69
127006: IN
127007: PUSH
127008: LD_EXP 212
127012: PUSH
127013: LD_VAR 0 1
127017: ARRAY
127018: PUSH
127019: LD_VAR 0 2
127023: ARRAY
127024: PUSH
127025: LD_INT 1
127027: ARRAY
127028: PPUSH
127029: LD_EXP 212
127033: PUSH
127034: LD_VAR 0 1
127038: ARRAY
127039: PUSH
127040: LD_VAR 0 2
127044: ARRAY
127045: PUSH
127046: LD_INT 2
127048: ARRAY
127049: PPUSH
127050: CALL_OW 458
127054: AND
127055: IFFALSE 127149
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
127057: LD_EXP 212
127061: PUSH
127062: LD_VAR 0 1
127066: ARRAY
127067: PUSH
127068: LD_VAR 0 2
127072: ARRAY
127073: PUSH
127074: LD_INT 1
127076: ARRAY
127077: PPUSH
127078: LD_EXP 212
127082: PUSH
127083: LD_VAR 0 1
127087: ARRAY
127088: PUSH
127089: LD_VAR 0 2
127093: ARRAY
127094: PUSH
127095: LD_INT 2
127097: ARRAY
127098: PPUSH
127099: LD_VAR 0 3
127103: PPUSH
127104: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
127108: LD_ADDR_EXP 212
127112: PUSH
127113: LD_EXP 212
127117: PPUSH
127118: LD_VAR 0 1
127122: PPUSH
127123: LD_EXP 212
127127: PUSH
127128: LD_VAR 0 1
127132: ARRAY
127133: PPUSH
127134: LD_VAR 0 2
127138: PPUSH
127139: CALL_OW 3
127143: PPUSH
127144: CALL_OW 1
127148: ST_TO_ADDR
// end ; end ;
127149: GO 126900
127151: POP
127152: POP
// end ;
127153: GO 126818
127155: POP
127156: POP
// end ;
127157: PPOPN 4
127159: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
127160: LD_INT 0
127162: PPUSH
127163: PPUSH
// result := false ;
127164: LD_ADDR_VAR 0 4
127168: PUSH
127169: LD_INT 0
127171: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
127172: LD_VAR 0 1
127176: PPUSH
127177: CALL_OW 264
127181: PUSH
127182: LD_INT 81
127184: EQUAL
127185: NOT
127186: IFFALSE 127190
// exit ;
127188: GO 127430
// index := GetElementIndex ( minersList , unit ) ;
127190: LD_ADDR_VAR 0 5
127194: PUSH
127195: LD_EXP 211
127199: PPUSH
127200: LD_VAR 0 1
127204: PPUSH
127205: CALL 72257 0 2
127209: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
127210: LD_EXP 212
127214: PUSH
127215: LD_VAR 0 5
127219: ARRAY
127220: PUSH
127221: LD_EXP 213
127225: GREATEREQUAL
127226: IFFALSE 127230
// exit ;
127228: GO 127430
// ComMoveXY ( unit , x , y ) ;
127230: LD_VAR 0 1
127234: PPUSH
127235: LD_VAR 0 2
127239: PPUSH
127240: LD_VAR 0 3
127244: PPUSH
127245: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
127249: LD_INT 35
127251: PPUSH
127252: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
127256: LD_VAR 0 1
127260: PPUSH
127261: LD_VAR 0 2
127265: PPUSH
127266: LD_VAR 0 3
127270: PPUSH
127271: CALL 103593 0 3
127275: NOT
127276: PUSH
127277: LD_VAR 0 1
127281: PPUSH
127282: CALL_OW 314
127286: AND
127287: IFFALSE 127291
// exit ;
127289: GO 127430
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
127291: LD_VAR 0 2
127295: PPUSH
127296: LD_VAR 0 3
127300: PPUSH
127301: CALL_OW 428
127305: PUSH
127306: LD_VAR 0 1
127310: EQUAL
127311: PUSH
127312: LD_VAR 0 1
127316: PPUSH
127317: CALL_OW 314
127321: NOT
127322: AND
127323: IFFALSE 127249
// PlaySoundXY ( x , y , PlantMine ) ;
127325: LD_VAR 0 2
127329: PPUSH
127330: LD_VAR 0 3
127334: PPUSH
127335: LD_STRING PlantMine
127337: PPUSH
127338: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
127342: LD_VAR 0 2
127346: PPUSH
127347: LD_VAR 0 3
127351: PPUSH
127352: LD_VAR 0 1
127356: PPUSH
127357: CALL_OW 255
127361: PPUSH
127362: LD_INT 0
127364: PPUSH
127365: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
127369: LD_ADDR_EXP 212
127373: PUSH
127374: LD_EXP 212
127378: PPUSH
127379: LD_VAR 0 5
127383: PUSH
127384: LD_EXP 212
127388: PUSH
127389: LD_VAR 0 5
127393: ARRAY
127394: PUSH
127395: LD_INT 1
127397: PLUS
127398: PUSH
127399: EMPTY
127400: LIST
127401: LIST
127402: PPUSH
127403: LD_VAR 0 2
127407: PUSH
127408: LD_VAR 0 3
127412: PUSH
127413: EMPTY
127414: LIST
127415: LIST
127416: PPUSH
127417: CALL 72472 0 3
127421: ST_TO_ADDR
// result := true ;
127422: LD_ADDR_VAR 0 4
127426: PUSH
127427: LD_INT 1
127429: ST_TO_ADDR
// end ;
127430: LD_VAR 0 4
127434: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
127435: LD_INT 0
127437: PPUSH
127438: PPUSH
127439: PPUSH
// if not unit in minersList then
127440: LD_VAR 0 1
127444: PUSH
127445: LD_EXP 211
127449: IN
127450: NOT
127451: IFFALSE 127455
// exit ;
127453: GO 127847
// index := GetElementIndex ( minersList , unit ) ;
127455: LD_ADDR_VAR 0 6
127459: PUSH
127460: LD_EXP 211
127464: PPUSH
127465: LD_VAR 0 1
127469: PPUSH
127470: CALL 72257 0 2
127474: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
127475: LD_ADDR_VAR 0 5
127479: PUSH
127480: DOUBLE
127481: LD_EXP 212
127485: PUSH
127486: LD_VAR 0 6
127490: ARRAY
127491: INC
127492: ST_TO_ADDR
127493: LD_INT 1
127495: PUSH
127496: FOR_DOWNTO
127497: IFFALSE 127658
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
127499: LD_EXP 212
127503: PUSH
127504: LD_VAR 0 6
127508: ARRAY
127509: PUSH
127510: LD_VAR 0 5
127514: ARRAY
127515: PUSH
127516: LD_INT 1
127518: ARRAY
127519: PUSH
127520: LD_VAR 0 2
127524: EQUAL
127525: PUSH
127526: LD_EXP 212
127530: PUSH
127531: LD_VAR 0 6
127535: ARRAY
127536: PUSH
127537: LD_VAR 0 5
127541: ARRAY
127542: PUSH
127543: LD_INT 2
127545: ARRAY
127546: PUSH
127547: LD_VAR 0 3
127551: EQUAL
127552: AND
127553: IFFALSE 127656
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
127555: LD_EXP 212
127559: PUSH
127560: LD_VAR 0 6
127564: ARRAY
127565: PUSH
127566: LD_VAR 0 5
127570: ARRAY
127571: PUSH
127572: LD_INT 1
127574: ARRAY
127575: PPUSH
127576: LD_EXP 212
127580: PUSH
127581: LD_VAR 0 6
127585: ARRAY
127586: PUSH
127587: LD_VAR 0 5
127591: ARRAY
127592: PUSH
127593: LD_INT 2
127595: ARRAY
127596: PPUSH
127597: LD_VAR 0 1
127601: PPUSH
127602: CALL_OW 255
127606: PPUSH
127607: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
127611: LD_ADDR_EXP 212
127615: PUSH
127616: LD_EXP 212
127620: PPUSH
127621: LD_VAR 0 6
127625: PPUSH
127626: LD_EXP 212
127630: PUSH
127631: LD_VAR 0 6
127635: ARRAY
127636: PPUSH
127637: LD_VAR 0 5
127641: PPUSH
127642: CALL_OW 3
127646: PPUSH
127647: CALL_OW 1
127651: ST_TO_ADDR
// exit ;
127652: POP
127653: POP
127654: GO 127847
// end ; end ;
127656: GO 127496
127658: POP
127659: POP
// for i := minerMinesList [ index ] downto 1 do
127660: LD_ADDR_VAR 0 5
127664: PUSH
127665: DOUBLE
127666: LD_EXP 212
127670: PUSH
127671: LD_VAR 0 6
127675: ARRAY
127676: INC
127677: ST_TO_ADDR
127678: LD_INT 1
127680: PUSH
127681: FOR_DOWNTO
127682: IFFALSE 127845
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
127684: LD_EXP 212
127688: PUSH
127689: LD_VAR 0 6
127693: ARRAY
127694: PUSH
127695: LD_VAR 0 5
127699: ARRAY
127700: PUSH
127701: LD_INT 1
127703: ARRAY
127704: PPUSH
127705: LD_EXP 212
127709: PUSH
127710: LD_VAR 0 6
127714: ARRAY
127715: PUSH
127716: LD_VAR 0 5
127720: ARRAY
127721: PUSH
127722: LD_INT 2
127724: ARRAY
127725: PPUSH
127726: LD_VAR 0 2
127730: PPUSH
127731: LD_VAR 0 3
127735: PPUSH
127736: CALL_OW 298
127740: PUSH
127741: LD_INT 6
127743: LESS
127744: IFFALSE 127843
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
127746: LD_EXP 212
127750: PUSH
127751: LD_VAR 0 6
127755: ARRAY
127756: PUSH
127757: LD_VAR 0 5
127761: ARRAY
127762: PUSH
127763: LD_INT 1
127765: ARRAY
127766: PPUSH
127767: LD_EXP 212
127771: PUSH
127772: LD_VAR 0 6
127776: ARRAY
127777: PUSH
127778: LD_VAR 0 5
127782: ARRAY
127783: PUSH
127784: LD_INT 2
127786: ARRAY
127787: PPUSH
127788: LD_VAR 0 1
127792: PPUSH
127793: CALL_OW 255
127797: PPUSH
127798: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
127802: LD_ADDR_EXP 212
127806: PUSH
127807: LD_EXP 212
127811: PPUSH
127812: LD_VAR 0 6
127816: PPUSH
127817: LD_EXP 212
127821: PUSH
127822: LD_VAR 0 6
127826: ARRAY
127827: PPUSH
127828: LD_VAR 0 5
127832: PPUSH
127833: CALL_OW 3
127837: PPUSH
127838: CALL_OW 1
127842: ST_TO_ADDR
// end ; end ;
127843: GO 127681
127845: POP
127846: POP
// end ;
127847: LD_VAR 0 4
127851: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
127852: LD_INT 0
127854: PPUSH
127855: PPUSH
127856: PPUSH
127857: PPUSH
127858: PPUSH
127859: PPUSH
127860: PPUSH
127861: PPUSH
127862: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
127863: LD_VAR 0 1
127867: PPUSH
127868: CALL_OW 264
127872: PUSH
127873: LD_INT 81
127875: EQUAL
127876: NOT
127877: PUSH
127878: LD_VAR 0 1
127882: PUSH
127883: LD_EXP 211
127887: IN
127888: NOT
127889: OR
127890: IFFALSE 127894
// exit ;
127892: GO 128216
// index := GetElementIndex ( minersList , unit ) ;
127894: LD_ADDR_VAR 0 6
127898: PUSH
127899: LD_EXP 211
127903: PPUSH
127904: LD_VAR 0 1
127908: PPUSH
127909: CALL 72257 0 2
127913: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
127914: LD_ADDR_VAR 0 8
127918: PUSH
127919: LD_EXP 213
127923: PUSH
127924: LD_EXP 212
127928: PUSH
127929: LD_VAR 0 6
127933: ARRAY
127934: MINUS
127935: ST_TO_ADDR
// if not minesFreeAmount then
127936: LD_VAR 0 8
127940: NOT
127941: IFFALSE 127945
// exit ;
127943: GO 128216
// tmp := [ ] ;
127945: LD_ADDR_VAR 0 7
127949: PUSH
127950: EMPTY
127951: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
127952: LD_ADDR_VAR 0 5
127956: PUSH
127957: DOUBLE
127958: LD_INT 1
127960: DEC
127961: ST_TO_ADDR
127962: LD_VAR 0 8
127966: PUSH
127967: FOR_TO
127968: IFFALSE 128163
// begin _d := rand ( 0 , 5 ) ;
127970: LD_ADDR_VAR 0 11
127974: PUSH
127975: LD_INT 0
127977: PPUSH
127978: LD_INT 5
127980: PPUSH
127981: CALL_OW 12
127985: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
127986: LD_ADDR_VAR 0 12
127990: PUSH
127991: LD_INT 2
127993: PPUSH
127994: LD_INT 6
127996: PPUSH
127997: CALL_OW 12
128001: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
128002: LD_ADDR_VAR 0 9
128006: PUSH
128007: LD_VAR 0 2
128011: PPUSH
128012: LD_VAR 0 11
128016: PPUSH
128017: LD_VAR 0 12
128021: PPUSH
128022: CALL_OW 272
128026: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
128027: LD_ADDR_VAR 0 10
128031: PUSH
128032: LD_VAR 0 3
128036: PPUSH
128037: LD_VAR 0 11
128041: PPUSH
128042: LD_VAR 0 12
128046: PPUSH
128047: CALL_OW 273
128051: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
128052: LD_VAR 0 9
128056: PPUSH
128057: LD_VAR 0 10
128061: PPUSH
128062: CALL_OW 488
128066: PUSH
128067: LD_VAR 0 9
128071: PUSH
128072: LD_VAR 0 10
128076: PUSH
128077: EMPTY
128078: LIST
128079: LIST
128080: PUSH
128081: LD_VAR 0 7
128085: IN
128086: NOT
128087: AND
128088: PUSH
128089: LD_VAR 0 9
128093: PPUSH
128094: LD_VAR 0 10
128098: PPUSH
128099: CALL_OW 458
128103: NOT
128104: AND
128105: IFFALSE 128147
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
128107: LD_ADDR_VAR 0 7
128111: PUSH
128112: LD_VAR 0 7
128116: PPUSH
128117: LD_VAR 0 7
128121: PUSH
128122: LD_INT 1
128124: PLUS
128125: PPUSH
128126: LD_VAR 0 9
128130: PUSH
128131: LD_VAR 0 10
128135: PUSH
128136: EMPTY
128137: LIST
128138: LIST
128139: PPUSH
128140: CALL_OW 1
128144: ST_TO_ADDR
128145: GO 128161
// i := i - 1 ;
128147: LD_ADDR_VAR 0 5
128151: PUSH
128152: LD_VAR 0 5
128156: PUSH
128157: LD_INT 1
128159: MINUS
128160: ST_TO_ADDR
// end ;
128161: GO 127967
128163: POP
128164: POP
// for i in tmp do
128165: LD_ADDR_VAR 0 5
128169: PUSH
128170: LD_VAR 0 7
128174: PUSH
128175: FOR_IN
128176: IFFALSE 128214
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
128178: LD_VAR 0 1
128182: PPUSH
128183: LD_VAR 0 5
128187: PUSH
128188: LD_INT 1
128190: ARRAY
128191: PPUSH
128192: LD_VAR 0 5
128196: PUSH
128197: LD_INT 2
128199: ARRAY
128200: PPUSH
128201: CALL 127160 0 3
128205: NOT
128206: IFFALSE 128212
// exit ;
128208: POP
128209: POP
128210: GO 128216
128212: GO 128175
128214: POP
128215: POP
// end ;
128216: LD_VAR 0 4
128220: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
128221: LD_INT 0
128223: PPUSH
128224: PPUSH
128225: PPUSH
128226: PPUSH
128227: PPUSH
128228: PPUSH
128229: PPUSH
// if not GetClass ( unit ) = class_sniper then
128230: LD_VAR 0 1
128234: PPUSH
128235: CALL_OW 257
128239: PUSH
128240: LD_INT 5
128242: EQUAL
128243: NOT
128244: IFFALSE 128248
// exit ;
128246: GO 128636
// dist := 8 ;
128248: LD_ADDR_VAR 0 5
128252: PUSH
128253: LD_INT 8
128255: ST_TO_ADDR
// viewRange := 12 ;
128256: LD_ADDR_VAR 0 7
128260: PUSH
128261: LD_INT 12
128263: ST_TO_ADDR
// side := GetSide ( unit ) ;
128264: LD_ADDR_VAR 0 6
128268: PUSH
128269: LD_VAR 0 1
128273: PPUSH
128274: CALL_OW 255
128278: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
128279: LD_INT 61
128281: PPUSH
128282: LD_VAR 0 6
128286: PPUSH
128287: CALL_OW 321
128291: PUSH
128292: LD_INT 2
128294: EQUAL
128295: IFFALSE 128305
// viewRange := 16 ;
128297: LD_ADDR_VAR 0 7
128301: PUSH
128302: LD_INT 16
128304: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
128305: LD_VAR 0 1
128309: PPUSH
128310: LD_VAR 0 2
128314: PPUSH
128315: LD_VAR 0 3
128319: PPUSH
128320: CALL_OW 297
128324: PUSH
128325: LD_VAR 0 5
128329: GREATER
128330: IFFALSE 128409
// begin ComMoveXY ( unit , x , y ) ;
128332: LD_VAR 0 1
128336: PPUSH
128337: LD_VAR 0 2
128341: PPUSH
128342: LD_VAR 0 3
128346: PPUSH
128347: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
128351: LD_INT 35
128353: PPUSH
128354: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
128358: LD_VAR 0 1
128362: PPUSH
128363: LD_VAR 0 2
128367: PPUSH
128368: LD_VAR 0 3
128372: PPUSH
128373: CALL 103593 0 3
128377: NOT
128378: IFFALSE 128382
// exit ;
128380: GO 128636
// until GetDistUnitXY ( unit , x , y ) < dist ;
128382: LD_VAR 0 1
128386: PPUSH
128387: LD_VAR 0 2
128391: PPUSH
128392: LD_VAR 0 3
128396: PPUSH
128397: CALL_OW 297
128401: PUSH
128402: LD_VAR 0 5
128406: LESS
128407: IFFALSE 128351
// end ; ComTurnXY ( unit , x , y ) ;
128409: LD_VAR 0 1
128413: PPUSH
128414: LD_VAR 0 2
128418: PPUSH
128419: LD_VAR 0 3
128423: PPUSH
128424: CALL_OW 118
// wait ( 5 ) ;
128428: LD_INT 5
128430: PPUSH
128431: CALL_OW 67
// _d := GetDir ( unit ) ;
128435: LD_ADDR_VAR 0 10
128439: PUSH
128440: LD_VAR 0 1
128444: PPUSH
128445: CALL_OW 254
128449: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
128450: LD_ADDR_VAR 0 8
128454: PUSH
128455: LD_VAR 0 1
128459: PPUSH
128460: CALL_OW 250
128464: PPUSH
128465: LD_VAR 0 10
128469: PPUSH
128470: LD_VAR 0 5
128474: PPUSH
128475: CALL_OW 272
128479: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
128480: LD_ADDR_VAR 0 9
128484: PUSH
128485: LD_VAR 0 1
128489: PPUSH
128490: CALL_OW 251
128494: PPUSH
128495: LD_VAR 0 10
128499: PPUSH
128500: LD_VAR 0 5
128504: PPUSH
128505: CALL_OW 273
128509: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
128510: LD_VAR 0 8
128514: PPUSH
128515: LD_VAR 0 9
128519: PPUSH
128520: CALL_OW 488
128524: NOT
128525: IFFALSE 128529
// exit ;
128527: GO 128636
// ComAnimCustom ( unit , 1 ) ;
128529: LD_VAR 0 1
128533: PPUSH
128534: LD_INT 1
128536: PPUSH
128537: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
128541: LD_VAR 0 8
128545: PPUSH
128546: LD_VAR 0 9
128550: PPUSH
128551: LD_VAR 0 6
128555: PPUSH
128556: LD_VAR 0 7
128560: PPUSH
128561: CALL_OW 330
// repeat wait ( 1 ) ;
128565: LD_INT 1
128567: PPUSH
128568: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
128572: LD_VAR 0 1
128576: PPUSH
128577: CALL_OW 316
128581: PUSH
128582: LD_VAR 0 1
128586: PPUSH
128587: CALL_OW 314
128591: OR
128592: PUSH
128593: LD_VAR 0 1
128597: PPUSH
128598: CALL_OW 302
128602: NOT
128603: OR
128604: PUSH
128605: LD_VAR 0 1
128609: PPUSH
128610: CALL_OW 301
128614: OR
128615: IFFALSE 128565
// RemoveSeeing ( _x , _y , side ) ;
128617: LD_VAR 0 8
128621: PPUSH
128622: LD_VAR 0 9
128626: PPUSH
128627: LD_VAR 0 6
128631: PPUSH
128632: CALL_OW 331
// end ; end_of_file
128636: LD_VAR 0 4
128640: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
128641: LD_INT 0
128643: PPUSH
128644: PPUSH
128645: PPUSH
128646: PPUSH
128647: PPUSH
128648: PPUSH
128649: PPUSH
128650: PPUSH
128651: PPUSH
128652: PPUSH
128653: PPUSH
128654: PPUSH
128655: PPUSH
128656: PPUSH
128657: PPUSH
128658: PPUSH
128659: PPUSH
128660: PPUSH
128661: PPUSH
128662: PPUSH
128663: PPUSH
128664: PPUSH
128665: PPUSH
128666: PPUSH
128667: PPUSH
128668: PPUSH
128669: PPUSH
128670: PPUSH
128671: PPUSH
128672: PPUSH
128673: PPUSH
128674: PPUSH
128675: PPUSH
128676: PPUSH
// if not list then
128677: LD_VAR 0 1
128681: NOT
128682: IFFALSE 128686
// exit ;
128684: GO 133345
// base := list [ 1 ] ;
128686: LD_ADDR_VAR 0 3
128690: PUSH
128691: LD_VAR 0 1
128695: PUSH
128696: LD_INT 1
128698: ARRAY
128699: ST_TO_ADDR
// group := list [ 2 ] ;
128700: LD_ADDR_VAR 0 4
128704: PUSH
128705: LD_VAR 0 1
128709: PUSH
128710: LD_INT 2
128712: ARRAY
128713: ST_TO_ADDR
// path := list [ 3 ] ;
128714: LD_ADDR_VAR 0 5
128718: PUSH
128719: LD_VAR 0 1
128723: PUSH
128724: LD_INT 3
128726: ARRAY
128727: ST_TO_ADDR
// flags := list [ 4 ] ;
128728: LD_ADDR_VAR 0 6
128732: PUSH
128733: LD_VAR 0 1
128737: PUSH
128738: LD_INT 4
128740: ARRAY
128741: ST_TO_ADDR
// mined := [ ] ;
128742: LD_ADDR_VAR 0 27
128746: PUSH
128747: EMPTY
128748: ST_TO_ADDR
// bombed := [ ] ;
128749: LD_ADDR_VAR 0 28
128753: PUSH
128754: EMPTY
128755: ST_TO_ADDR
// healers := [ ] ;
128756: LD_ADDR_VAR 0 31
128760: PUSH
128761: EMPTY
128762: ST_TO_ADDR
// to_heal := [ ] ;
128763: LD_ADDR_VAR 0 30
128767: PUSH
128768: EMPTY
128769: ST_TO_ADDR
// repairs := [ ] ;
128770: LD_ADDR_VAR 0 33
128774: PUSH
128775: EMPTY
128776: ST_TO_ADDR
// to_repair := [ ] ;
128777: LD_ADDR_VAR 0 32
128781: PUSH
128782: EMPTY
128783: ST_TO_ADDR
// if not group or not path then
128784: LD_VAR 0 4
128788: NOT
128789: PUSH
128790: LD_VAR 0 5
128794: NOT
128795: OR
128796: IFFALSE 128800
// exit ;
128798: GO 133345
// side := GetSide ( group [ 1 ] ) ;
128800: LD_ADDR_VAR 0 35
128804: PUSH
128805: LD_VAR 0 4
128809: PUSH
128810: LD_INT 1
128812: ARRAY
128813: PPUSH
128814: CALL_OW 255
128818: ST_TO_ADDR
// if flags then
128819: LD_VAR 0 6
128823: IFFALSE 128967
// begin f_ignore_area := flags [ 1 ] ;
128825: LD_ADDR_VAR 0 17
128829: PUSH
128830: LD_VAR 0 6
128834: PUSH
128835: LD_INT 1
128837: ARRAY
128838: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
128839: LD_ADDR_VAR 0 18
128843: PUSH
128844: LD_VAR 0 6
128848: PUSH
128849: LD_INT 2
128851: ARRAY
128852: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
128853: LD_ADDR_VAR 0 19
128857: PUSH
128858: LD_VAR 0 6
128862: PUSH
128863: LD_INT 3
128865: ARRAY
128866: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
128867: LD_ADDR_VAR 0 20
128871: PUSH
128872: LD_VAR 0 6
128876: PUSH
128877: LD_INT 4
128879: ARRAY
128880: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
128881: LD_ADDR_VAR 0 21
128885: PUSH
128886: LD_VAR 0 6
128890: PUSH
128891: LD_INT 5
128893: ARRAY
128894: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
128895: LD_ADDR_VAR 0 22
128899: PUSH
128900: LD_VAR 0 6
128904: PUSH
128905: LD_INT 6
128907: ARRAY
128908: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
128909: LD_ADDR_VAR 0 23
128913: PUSH
128914: LD_VAR 0 6
128918: PUSH
128919: LD_INT 7
128921: ARRAY
128922: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
128923: LD_ADDR_VAR 0 24
128927: PUSH
128928: LD_VAR 0 6
128932: PUSH
128933: LD_INT 8
128935: ARRAY
128936: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
128937: LD_ADDR_VAR 0 25
128941: PUSH
128942: LD_VAR 0 6
128946: PUSH
128947: LD_INT 9
128949: ARRAY
128950: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
128951: LD_ADDR_VAR 0 26
128955: PUSH
128956: LD_VAR 0 6
128960: PUSH
128961: LD_INT 10
128963: ARRAY
128964: ST_TO_ADDR
// end else
128965: GO 129047
// begin f_ignore_area := false ;
128967: LD_ADDR_VAR 0 17
128971: PUSH
128972: LD_INT 0
128974: ST_TO_ADDR
// f_capture := false ;
128975: LD_ADDR_VAR 0 18
128979: PUSH
128980: LD_INT 0
128982: ST_TO_ADDR
// f_ignore_civ := false ;
128983: LD_ADDR_VAR 0 19
128987: PUSH
128988: LD_INT 0
128990: ST_TO_ADDR
// f_murder := false ;
128991: LD_ADDR_VAR 0 20
128995: PUSH
128996: LD_INT 0
128998: ST_TO_ADDR
// f_mines := false ;
128999: LD_ADDR_VAR 0 21
129003: PUSH
129004: LD_INT 0
129006: ST_TO_ADDR
// f_repair := false ;
129007: LD_ADDR_VAR 0 22
129011: PUSH
129012: LD_INT 0
129014: ST_TO_ADDR
// f_heal := false ;
129015: LD_ADDR_VAR 0 23
129019: PUSH
129020: LD_INT 0
129022: ST_TO_ADDR
// f_spacetime := false ;
129023: LD_ADDR_VAR 0 24
129027: PUSH
129028: LD_INT 0
129030: ST_TO_ADDR
// f_attack_depot := false ;
129031: LD_ADDR_VAR 0 25
129035: PUSH
129036: LD_INT 0
129038: ST_TO_ADDR
// f_crawl := false ;
129039: LD_ADDR_VAR 0 26
129043: PUSH
129044: LD_INT 0
129046: ST_TO_ADDR
// end ; if f_heal then
129047: LD_VAR 0 23
129051: IFFALSE 129078
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
129053: LD_ADDR_VAR 0 31
129057: PUSH
129058: LD_VAR 0 4
129062: PPUSH
129063: LD_INT 25
129065: PUSH
129066: LD_INT 4
129068: PUSH
129069: EMPTY
129070: LIST
129071: LIST
129072: PPUSH
129073: CALL_OW 72
129077: ST_TO_ADDR
// if f_repair then
129078: LD_VAR 0 22
129082: IFFALSE 129109
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
129084: LD_ADDR_VAR 0 33
129088: PUSH
129089: LD_VAR 0 4
129093: PPUSH
129094: LD_INT 25
129096: PUSH
129097: LD_INT 3
129099: PUSH
129100: EMPTY
129101: LIST
129102: LIST
129103: PPUSH
129104: CALL_OW 72
129108: ST_TO_ADDR
// units_path := [ ] ;
129109: LD_ADDR_VAR 0 16
129113: PUSH
129114: EMPTY
129115: ST_TO_ADDR
// for i = 1 to group do
129116: LD_ADDR_VAR 0 7
129120: PUSH
129121: DOUBLE
129122: LD_INT 1
129124: DEC
129125: ST_TO_ADDR
129126: LD_VAR 0 4
129130: PUSH
129131: FOR_TO
129132: IFFALSE 129161
// units_path := Replace ( units_path , i , path ) ;
129134: LD_ADDR_VAR 0 16
129138: PUSH
129139: LD_VAR 0 16
129143: PPUSH
129144: LD_VAR 0 7
129148: PPUSH
129149: LD_VAR 0 5
129153: PPUSH
129154: CALL_OW 1
129158: ST_TO_ADDR
129159: GO 129131
129161: POP
129162: POP
// repeat for i = group downto 1 do
129163: LD_ADDR_VAR 0 7
129167: PUSH
129168: DOUBLE
129169: LD_VAR 0 4
129173: INC
129174: ST_TO_ADDR
129175: LD_INT 1
129177: PUSH
129178: FOR_DOWNTO
129179: IFFALSE 133301
// begin wait ( 5 ) ;
129181: LD_INT 5
129183: PPUSH
129184: CALL_OW 67
// tmp := [ ] ;
129188: LD_ADDR_VAR 0 14
129192: PUSH
129193: EMPTY
129194: ST_TO_ADDR
// attacking := false ;
129195: LD_ADDR_VAR 0 29
129199: PUSH
129200: LD_INT 0
129202: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
129203: LD_VAR 0 4
129207: PUSH
129208: LD_VAR 0 7
129212: ARRAY
129213: PPUSH
129214: CALL_OW 301
129218: PUSH
129219: LD_VAR 0 4
129223: PUSH
129224: LD_VAR 0 7
129228: ARRAY
129229: NOT
129230: OR
129231: IFFALSE 129340
// begin if GetType ( group [ i ] ) = unit_human then
129233: LD_VAR 0 4
129237: PUSH
129238: LD_VAR 0 7
129242: ARRAY
129243: PPUSH
129244: CALL_OW 247
129248: PUSH
129249: LD_INT 1
129251: EQUAL
129252: IFFALSE 129298
// begin to_heal := to_heal diff group [ i ] ;
129254: LD_ADDR_VAR 0 30
129258: PUSH
129259: LD_VAR 0 30
129263: PUSH
129264: LD_VAR 0 4
129268: PUSH
129269: LD_VAR 0 7
129273: ARRAY
129274: DIFF
129275: ST_TO_ADDR
// healers := healers diff group [ i ] ;
129276: LD_ADDR_VAR 0 31
129280: PUSH
129281: LD_VAR 0 31
129285: PUSH
129286: LD_VAR 0 4
129290: PUSH
129291: LD_VAR 0 7
129295: ARRAY
129296: DIFF
129297: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
129298: LD_ADDR_VAR 0 4
129302: PUSH
129303: LD_VAR 0 4
129307: PPUSH
129308: LD_VAR 0 7
129312: PPUSH
129313: CALL_OW 3
129317: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
129318: LD_ADDR_VAR 0 16
129322: PUSH
129323: LD_VAR 0 16
129327: PPUSH
129328: LD_VAR 0 7
129332: PPUSH
129333: CALL_OW 3
129337: ST_TO_ADDR
// continue ;
129338: GO 129178
// end ; if f_repair then
129340: LD_VAR 0 22
129344: IFFALSE 129833
// begin if GetType ( group [ i ] ) = unit_vehicle then
129346: LD_VAR 0 4
129350: PUSH
129351: LD_VAR 0 7
129355: ARRAY
129356: PPUSH
129357: CALL_OW 247
129361: PUSH
129362: LD_INT 2
129364: EQUAL
129365: IFFALSE 129555
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
129367: LD_VAR 0 4
129371: PUSH
129372: LD_VAR 0 7
129376: ARRAY
129377: PPUSH
129378: CALL_OW 256
129382: PUSH
129383: LD_INT 700
129385: LESS
129386: PUSH
129387: LD_VAR 0 4
129391: PUSH
129392: LD_VAR 0 7
129396: ARRAY
129397: PUSH
129398: LD_VAR 0 32
129402: IN
129403: NOT
129404: AND
129405: IFFALSE 129429
// to_repair := to_repair union group [ i ] ;
129407: LD_ADDR_VAR 0 32
129411: PUSH
129412: LD_VAR 0 32
129416: PUSH
129417: LD_VAR 0 4
129421: PUSH
129422: LD_VAR 0 7
129426: ARRAY
129427: UNION
129428: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
129429: LD_VAR 0 4
129433: PUSH
129434: LD_VAR 0 7
129438: ARRAY
129439: PPUSH
129440: CALL_OW 256
129444: PUSH
129445: LD_INT 1000
129447: EQUAL
129448: PUSH
129449: LD_VAR 0 4
129453: PUSH
129454: LD_VAR 0 7
129458: ARRAY
129459: PUSH
129460: LD_VAR 0 32
129464: IN
129465: AND
129466: IFFALSE 129490
// to_repair := to_repair diff group [ i ] ;
129468: LD_ADDR_VAR 0 32
129472: PUSH
129473: LD_VAR 0 32
129477: PUSH
129478: LD_VAR 0 4
129482: PUSH
129483: LD_VAR 0 7
129487: ARRAY
129488: DIFF
129489: ST_TO_ADDR
// if group [ i ] in to_repair then
129490: LD_VAR 0 4
129494: PUSH
129495: LD_VAR 0 7
129499: ARRAY
129500: PUSH
129501: LD_VAR 0 32
129505: IN
129506: IFFALSE 129553
// begin if not IsInArea ( group [ i ] , f_repair ) then
129508: LD_VAR 0 4
129512: PUSH
129513: LD_VAR 0 7
129517: ARRAY
129518: PPUSH
129519: LD_VAR 0 22
129523: PPUSH
129524: CALL_OW 308
129528: NOT
129529: IFFALSE 129551
// ComMoveToArea ( group [ i ] , f_repair ) ;
129531: LD_VAR 0 4
129535: PUSH
129536: LD_VAR 0 7
129540: ARRAY
129541: PPUSH
129542: LD_VAR 0 22
129546: PPUSH
129547: CALL_OW 113
// continue ;
129551: GO 129178
// end ; end else
129553: GO 129833
// if group [ i ] in repairs then
129555: LD_VAR 0 4
129559: PUSH
129560: LD_VAR 0 7
129564: ARRAY
129565: PUSH
129566: LD_VAR 0 33
129570: IN
129571: IFFALSE 129833
// begin if IsInUnit ( group [ i ] ) then
129573: LD_VAR 0 4
129577: PUSH
129578: LD_VAR 0 7
129582: ARRAY
129583: PPUSH
129584: CALL_OW 310
129588: IFFALSE 129656
// begin z := IsInUnit ( group [ i ] ) ;
129590: LD_ADDR_VAR 0 13
129594: PUSH
129595: LD_VAR 0 4
129599: PUSH
129600: LD_VAR 0 7
129604: ARRAY
129605: PPUSH
129606: CALL_OW 310
129610: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
129611: LD_VAR 0 13
129615: PUSH
129616: LD_VAR 0 32
129620: IN
129621: PUSH
129622: LD_VAR 0 13
129626: PPUSH
129627: LD_VAR 0 22
129631: PPUSH
129632: CALL_OW 308
129636: AND
129637: IFFALSE 129654
// ComExitVehicle ( group [ i ] ) ;
129639: LD_VAR 0 4
129643: PUSH
129644: LD_VAR 0 7
129648: ARRAY
129649: PPUSH
129650: CALL_OW 121
// end else
129654: GO 129833
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
129656: LD_ADDR_VAR 0 13
129660: PUSH
129661: LD_VAR 0 4
129665: PPUSH
129666: LD_INT 95
129668: PUSH
129669: LD_VAR 0 22
129673: PUSH
129674: EMPTY
129675: LIST
129676: LIST
129677: PUSH
129678: LD_INT 58
129680: PUSH
129681: EMPTY
129682: LIST
129683: PUSH
129684: EMPTY
129685: LIST
129686: LIST
129687: PPUSH
129688: CALL_OW 72
129692: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
129693: LD_VAR 0 4
129697: PUSH
129698: LD_VAR 0 7
129702: ARRAY
129703: PPUSH
129704: CALL_OW 314
129708: NOT
129709: IFFALSE 129831
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
129711: LD_ADDR_VAR 0 10
129715: PUSH
129716: LD_VAR 0 13
129720: PPUSH
129721: LD_VAR 0 4
129725: PUSH
129726: LD_VAR 0 7
129730: ARRAY
129731: PPUSH
129732: CALL_OW 74
129736: ST_TO_ADDR
// if not x then
129737: LD_VAR 0 10
129741: NOT
129742: IFFALSE 129746
// continue ;
129744: GO 129178
// if GetLives ( x ) < 1000 then
129746: LD_VAR 0 10
129750: PPUSH
129751: CALL_OW 256
129755: PUSH
129756: LD_INT 1000
129758: LESS
129759: IFFALSE 129783
// ComRepairVehicle ( group [ i ] , x ) else
129761: LD_VAR 0 4
129765: PUSH
129766: LD_VAR 0 7
129770: ARRAY
129771: PPUSH
129772: LD_VAR 0 10
129776: PPUSH
129777: CALL_OW 129
129781: GO 129831
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
129783: LD_VAR 0 23
129787: PUSH
129788: LD_VAR 0 4
129792: PUSH
129793: LD_VAR 0 7
129797: ARRAY
129798: PPUSH
129799: CALL_OW 256
129803: PUSH
129804: LD_INT 1000
129806: LESS
129807: AND
129808: NOT
129809: IFFALSE 129831
// ComEnterUnit ( group [ i ] , x ) ;
129811: LD_VAR 0 4
129815: PUSH
129816: LD_VAR 0 7
129820: ARRAY
129821: PPUSH
129822: LD_VAR 0 10
129826: PPUSH
129827: CALL_OW 120
// end ; continue ;
129831: GO 129178
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
129833: LD_VAR 0 23
129837: PUSH
129838: LD_VAR 0 4
129842: PUSH
129843: LD_VAR 0 7
129847: ARRAY
129848: PPUSH
129849: CALL_OW 247
129853: PUSH
129854: LD_INT 1
129856: EQUAL
129857: AND
129858: IFFALSE 130336
// begin if group [ i ] in healers then
129860: LD_VAR 0 4
129864: PUSH
129865: LD_VAR 0 7
129869: ARRAY
129870: PUSH
129871: LD_VAR 0 31
129875: IN
129876: IFFALSE 130149
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
129878: LD_VAR 0 4
129882: PUSH
129883: LD_VAR 0 7
129887: ARRAY
129888: PPUSH
129889: LD_VAR 0 23
129893: PPUSH
129894: CALL_OW 308
129898: NOT
129899: PUSH
129900: LD_VAR 0 4
129904: PUSH
129905: LD_VAR 0 7
129909: ARRAY
129910: PPUSH
129911: CALL_OW 314
129915: NOT
129916: AND
129917: IFFALSE 129941
// ComMoveToArea ( group [ i ] , f_heal ) else
129919: LD_VAR 0 4
129923: PUSH
129924: LD_VAR 0 7
129928: ARRAY
129929: PPUSH
129930: LD_VAR 0 23
129934: PPUSH
129935: CALL_OW 113
129939: GO 130147
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
129941: LD_VAR 0 4
129945: PUSH
129946: LD_VAR 0 7
129950: ARRAY
129951: PPUSH
129952: CALL 102169 0 1
129956: PPUSH
129957: CALL_OW 256
129961: PUSH
129962: LD_INT 1000
129964: EQUAL
129965: IFFALSE 129984
// ComStop ( group [ i ] ) else
129967: LD_VAR 0 4
129971: PUSH
129972: LD_VAR 0 7
129976: ARRAY
129977: PPUSH
129978: CALL_OW 141
129982: GO 130147
// if not HasTask ( group [ i ] ) and to_heal then
129984: LD_VAR 0 4
129988: PUSH
129989: LD_VAR 0 7
129993: ARRAY
129994: PPUSH
129995: CALL_OW 314
129999: NOT
130000: PUSH
130001: LD_VAR 0 30
130005: AND
130006: IFFALSE 130147
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
130008: LD_ADDR_VAR 0 13
130012: PUSH
130013: LD_VAR 0 30
130017: PPUSH
130018: LD_INT 3
130020: PUSH
130021: LD_INT 54
130023: PUSH
130024: EMPTY
130025: LIST
130026: PUSH
130027: EMPTY
130028: LIST
130029: LIST
130030: PPUSH
130031: CALL_OW 72
130035: PPUSH
130036: LD_VAR 0 4
130040: PUSH
130041: LD_VAR 0 7
130045: ARRAY
130046: PPUSH
130047: CALL_OW 74
130051: ST_TO_ADDR
// if z then
130052: LD_VAR 0 13
130056: IFFALSE 130147
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
130058: LD_INT 91
130060: PUSH
130061: LD_VAR 0 13
130065: PUSH
130066: LD_INT 10
130068: PUSH
130069: EMPTY
130070: LIST
130071: LIST
130072: LIST
130073: PUSH
130074: LD_INT 81
130076: PUSH
130077: LD_VAR 0 13
130081: PPUSH
130082: CALL_OW 255
130086: PUSH
130087: EMPTY
130088: LIST
130089: LIST
130090: PUSH
130091: EMPTY
130092: LIST
130093: LIST
130094: PPUSH
130095: CALL_OW 69
130099: PUSH
130100: LD_INT 0
130102: EQUAL
130103: IFFALSE 130127
// ComHeal ( group [ i ] , z ) else
130105: LD_VAR 0 4
130109: PUSH
130110: LD_VAR 0 7
130114: ARRAY
130115: PPUSH
130116: LD_VAR 0 13
130120: PPUSH
130121: CALL_OW 128
130125: GO 130147
// ComMoveToArea ( group [ i ] , f_heal ) ;
130127: LD_VAR 0 4
130131: PUSH
130132: LD_VAR 0 7
130136: ARRAY
130137: PPUSH
130138: LD_VAR 0 23
130142: PPUSH
130143: CALL_OW 113
// end ; continue ;
130147: GO 129178
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
130149: LD_VAR 0 4
130153: PUSH
130154: LD_VAR 0 7
130158: ARRAY
130159: PPUSH
130160: CALL_OW 256
130164: PUSH
130165: LD_INT 700
130167: LESS
130168: PUSH
130169: LD_VAR 0 4
130173: PUSH
130174: LD_VAR 0 7
130178: ARRAY
130179: PUSH
130180: LD_VAR 0 30
130184: IN
130185: NOT
130186: AND
130187: IFFALSE 130211
// to_heal := to_heal union group [ i ] ;
130189: LD_ADDR_VAR 0 30
130193: PUSH
130194: LD_VAR 0 30
130198: PUSH
130199: LD_VAR 0 4
130203: PUSH
130204: LD_VAR 0 7
130208: ARRAY
130209: UNION
130210: ST_TO_ADDR
// if group [ i ] in to_heal then
130211: LD_VAR 0 4
130215: PUSH
130216: LD_VAR 0 7
130220: ARRAY
130221: PUSH
130222: LD_VAR 0 30
130226: IN
130227: IFFALSE 130336
// begin if GetLives ( group [ i ] ) = 1000 then
130229: LD_VAR 0 4
130233: PUSH
130234: LD_VAR 0 7
130238: ARRAY
130239: PPUSH
130240: CALL_OW 256
130244: PUSH
130245: LD_INT 1000
130247: EQUAL
130248: IFFALSE 130274
// to_heal := to_heal diff group [ i ] else
130250: LD_ADDR_VAR 0 30
130254: PUSH
130255: LD_VAR 0 30
130259: PUSH
130260: LD_VAR 0 4
130264: PUSH
130265: LD_VAR 0 7
130269: ARRAY
130270: DIFF
130271: ST_TO_ADDR
130272: GO 130336
// begin if not IsInArea ( group [ i ] , to_heal ) then
130274: LD_VAR 0 4
130278: PUSH
130279: LD_VAR 0 7
130283: ARRAY
130284: PPUSH
130285: LD_VAR 0 30
130289: PPUSH
130290: CALL_OW 308
130294: NOT
130295: IFFALSE 130319
// ComMoveToArea ( group [ i ] , f_heal ) else
130297: LD_VAR 0 4
130301: PUSH
130302: LD_VAR 0 7
130306: ARRAY
130307: PPUSH
130308: LD_VAR 0 23
130312: PPUSH
130313: CALL_OW 113
130317: GO 130334
// ComHold ( group [ i ] ) ;
130319: LD_VAR 0 4
130323: PUSH
130324: LD_VAR 0 7
130328: ARRAY
130329: PPUSH
130330: CALL_OW 140
// continue ;
130334: GO 129178
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
130336: LD_VAR 0 4
130340: PUSH
130341: LD_VAR 0 7
130345: ARRAY
130346: PPUSH
130347: LD_INT 10
130349: PPUSH
130350: CALL 99966 0 2
130354: NOT
130355: PUSH
130356: LD_VAR 0 16
130360: PUSH
130361: LD_VAR 0 7
130365: ARRAY
130366: PUSH
130367: EMPTY
130368: EQUAL
130369: NOT
130370: AND
130371: IFFALSE 130637
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
130373: LD_VAR 0 4
130377: PUSH
130378: LD_VAR 0 7
130382: ARRAY
130383: PPUSH
130384: CALL_OW 262
130388: PUSH
130389: LD_INT 1
130391: PUSH
130392: LD_INT 2
130394: PUSH
130395: EMPTY
130396: LIST
130397: LIST
130398: IN
130399: IFFALSE 130440
// if GetFuel ( group [ i ] ) < 10 then
130401: LD_VAR 0 4
130405: PUSH
130406: LD_VAR 0 7
130410: ARRAY
130411: PPUSH
130412: CALL_OW 261
130416: PUSH
130417: LD_INT 10
130419: LESS
130420: IFFALSE 130440
// SetFuel ( group [ i ] , 12 ) ;
130422: LD_VAR 0 4
130426: PUSH
130427: LD_VAR 0 7
130431: ARRAY
130432: PPUSH
130433: LD_INT 12
130435: PPUSH
130436: CALL_OW 240
// if units_path [ i ] then
130440: LD_VAR 0 16
130444: PUSH
130445: LD_VAR 0 7
130449: ARRAY
130450: IFFALSE 130635
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
130452: LD_VAR 0 4
130456: PUSH
130457: LD_VAR 0 7
130461: ARRAY
130462: PPUSH
130463: LD_VAR 0 16
130467: PUSH
130468: LD_VAR 0 7
130472: ARRAY
130473: PUSH
130474: LD_INT 1
130476: ARRAY
130477: PUSH
130478: LD_INT 1
130480: ARRAY
130481: PPUSH
130482: LD_VAR 0 16
130486: PUSH
130487: LD_VAR 0 7
130491: ARRAY
130492: PUSH
130493: LD_INT 1
130495: ARRAY
130496: PUSH
130497: LD_INT 2
130499: ARRAY
130500: PPUSH
130501: CALL_OW 297
130505: PUSH
130506: LD_INT 6
130508: GREATER
130509: IFFALSE 130584
// begin if not HasTask ( group [ i ] ) then
130511: LD_VAR 0 4
130515: PUSH
130516: LD_VAR 0 7
130520: ARRAY
130521: PPUSH
130522: CALL_OW 314
130526: NOT
130527: IFFALSE 130582
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
130529: LD_VAR 0 4
130533: PUSH
130534: LD_VAR 0 7
130538: ARRAY
130539: PPUSH
130540: LD_VAR 0 16
130544: PUSH
130545: LD_VAR 0 7
130549: ARRAY
130550: PUSH
130551: LD_INT 1
130553: ARRAY
130554: PUSH
130555: LD_INT 1
130557: ARRAY
130558: PPUSH
130559: LD_VAR 0 16
130563: PUSH
130564: LD_VAR 0 7
130568: ARRAY
130569: PUSH
130570: LD_INT 1
130572: ARRAY
130573: PUSH
130574: LD_INT 2
130576: ARRAY
130577: PPUSH
130578: CALL_OW 114
// end else
130582: GO 130635
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
130584: LD_ADDR_VAR 0 15
130588: PUSH
130589: LD_VAR 0 16
130593: PUSH
130594: LD_VAR 0 7
130598: ARRAY
130599: PPUSH
130600: LD_INT 1
130602: PPUSH
130603: CALL_OW 3
130607: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
130608: LD_ADDR_VAR 0 16
130612: PUSH
130613: LD_VAR 0 16
130617: PPUSH
130618: LD_VAR 0 7
130622: PPUSH
130623: LD_VAR 0 15
130627: PPUSH
130628: CALL_OW 1
130632: ST_TO_ADDR
// continue ;
130633: GO 129178
// end ; end ; end else
130635: GO 133299
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
130637: LD_ADDR_VAR 0 14
130641: PUSH
130642: LD_INT 81
130644: PUSH
130645: LD_VAR 0 4
130649: PUSH
130650: LD_VAR 0 7
130654: ARRAY
130655: PPUSH
130656: CALL_OW 255
130660: PUSH
130661: EMPTY
130662: LIST
130663: LIST
130664: PPUSH
130665: CALL_OW 69
130669: ST_TO_ADDR
// if not tmp then
130670: LD_VAR 0 14
130674: NOT
130675: IFFALSE 130679
// continue ;
130677: GO 129178
// if f_ignore_area then
130679: LD_VAR 0 17
130683: IFFALSE 130771
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
130685: LD_ADDR_VAR 0 15
130689: PUSH
130690: LD_VAR 0 14
130694: PPUSH
130695: LD_INT 3
130697: PUSH
130698: LD_INT 92
130700: PUSH
130701: LD_VAR 0 17
130705: PUSH
130706: LD_INT 1
130708: ARRAY
130709: PUSH
130710: LD_VAR 0 17
130714: PUSH
130715: LD_INT 2
130717: ARRAY
130718: PUSH
130719: LD_VAR 0 17
130723: PUSH
130724: LD_INT 3
130726: ARRAY
130727: PUSH
130728: EMPTY
130729: LIST
130730: LIST
130731: LIST
130732: LIST
130733: PUSH
130734: EMPTY
130735: LIST
130736: LIST
130737: PPUSH
130738: CALL_OW 72
130742: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
130743: LD_VAR 0 14
130747: PUSH
130748: LD_VAR 0 15
130752: DIFF
130753: IFFALSE 130771
// tmp := tmp diff tmp2 ;
130755: LD_ADDR_VAR 0 14
130759: PUSH
130760: LD_VAR 0 14
130764: PUSH
130765: LD_VAR 0 15
130769: DIFF
130770: ST_TO_ADDR
// end ; if not f_murder then
130771: LD_VAR 0 20
130775: NOT
130776: IFFALSE 130834
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
130778: LD_ADDR_VAR 0 15
130782: PUSH
130783: LD_VAR 0 14
130787: PPUSH
130788: LD_INT 3
130790: PUSH
130791: LD_INT 50
130793: PUSH
130794: EMPTY
130795: LIST
130796: PUSH
130797: EMPTY
130798: LIST
130799: LIST
130800: PPUSH
130801: CALL_OW 72
130805: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
130806: LD_VAR 0 14
130810: PUSH
130811: LD_VAR 0 15
130815: DIFF
130816: IFFALSE 130834
// tmp := tmp diff tmp2 ;
130818: LD_ADDR_VAR 0 14
130822: PUSH
130823: LD_VAR 0 14
130827: PUSH
130828: LD_VAR 0 15
130832: DIFF
130833: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
130834: LD_ADDR_VAR 0 14
130838: PUSH
130839: LD_VAR 0 4
130843: PUSH
130844: LD_VAR 0 7
130848: ARRAY
130849: PPUSH
130850: LD_VAR 0 14
130854: PPUSH
130855: LD_INT 1
130857: PPUSH
130858: LD_INT 1
130860: PPUSH
130861: CALL 72907 0 4
130865: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
130866: LD_VAR 0 4
130870: PUSH
130871: LD_VAR 0 7
130875: ARRAY
130876: PPUSH
130877: CALL_OW 257
130881: PUSH
130882: LD_INT 1
130884: EQUAL
130885: IFFALSE 131333
// begin if WantPlant ( group [ i ] ) then
130887: LD_VAR 0 4
130891: PUSH
130892: LD_VAR 0 7
130896: ARRAY
130897: PPUSH
130898: CALL 72408 0 1
130902: IFFALSE 130906
// continue ;
130904: GO 129178
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
130906: LD_VAR 0 18
130910: PUSH
130911: LD_VAR 0 4
130915: PUSH
130916: LD_VAR 0 7
130920: ARRAY
130921: PPUSH
130922: CALL_OW 310
130926: NOT
130927: AND
130928: PUSH
130929: LD_VAR 0 14
130933: PUSH
130934: LD_INT 1
130936: ARRAY
130937: PUSH
130938: LD_VAR 0 14
130942: PPUSH
130943: LD_INT 21
130945: PUSH
130946: LD_INT 2
130948: PUSH
130949: EMPTY
130950: LIST
130951: LIST
130952: PUSH
130953: LD_INT 58
130955: PUSH
130956: EMPTY
130957: LIST
130958: PUSH
130959: EMPTY
130960: LIST
130961: LIST
130962: PPUSH
130963: CALL_OW 72
130967: IN
130968: AND
130969: IFFALSE 131005
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
130971: LD_VAR 0 4
130975: PUSH
130976: LD_VAR 0 7
130980: ARRAY
130981: PPUSH
130982: LD_VAR 0 14
130986: PUSH
130987: LD_INT 1
130989: ARRAY
130990: PPUSH
130991: CALL_OW 120
// attacking := true ;
130995: LD_ADDR_VAR 0 29
130999: PUSH
131000: LD_INT 1
131002: ST_TO_ADDR
// continue ;
131003: GO 129178
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
131005: LD_VAR 0 26
131009: PUSH
131010: LD_VAR 0 4
131014: PUSH
131015: LD_VAR 0 7
131019: ARRAY
131020: PPUSH
131021: CALL_OW 257
131025: PUSH
131026: LD_INT 1
131028: EQUAL
131029: AND
131030: PUSH
131031: LD_VAR 0 4
131035: PUSH
131036: LD_VAR 0 7
131040: ARRAY
131041: PPUSH
131042: CALL_OW 256
131046: PUSH
131047: LD_INT 800
131049: LESS
131050: AND
131051: PUSH
131052: LD_VAR 0 4
131056: PUSH
131057: LD_VAR 0 7
131061: ARRAY
131062: PPUSH
131063: CALL_OW 318
131067: NOT
131068: AND
131069: IFFALSE 131086
// ComCrawl ( group [ i ] ) ;
131071: LD_VAR 0 4
131075: PUSH
131076: LD_VAR 0 7
131080: ARRAY
131081: PPUSH
131082: CALL_OW 137
// if f_mines then
131086: LD_VAR 0 21
131090: IFFALSE 131333
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
131092: LD_VAR 0 14
131096: PUSH
131097: LD_INT 1
131099: ARRAY
131100: PPUSH
131101: CALL_OW 247
131105: PUSH
131106: LD_INT 3
131108: EQUAL
131109: PUSH
131110: LD_VAR 0 14
131114: PUSH
131115: LD_INT 1
131117: ARRAY
131118: PUSH
131119: LD_VAR 0 27
131123: IN
131124: NOT
131125: AND
131126: IFFALSE 131333
// begin x := GetX ( tmp [ 1 ] ) ;
131128: LD_ADDR_VAR 0 10
131132: PUSH
131133: LD_VAR 0 14
131137: PUSH
131138: LD_INT 1
131140: ARRAY
131141: PPUSH
131142: CALL_OW 250
131146: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
131147: LD_ADDR_VAR 0 11
131151: PUSH
131152: LD_VAR 0 14
131156: PUSH
131157: LD_INT 1
131159: ARRAY
131160: PPUSH
131161: CALL_OW 251
131165: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
131166: LD_ADDR_VAR 0 12
131170: PUSH
131171: LD_VAR 0 4
131175: PUSH
131176: LD_VAR 0 7
131180: ARRAY
131181: PPUSH
131182: CALL 100051 0 1
131186: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
131187: LD_VAR 0 4
131191: PUSH
131192: LD_VAR 0 7
131196: ARRAY
131197: PPUSH
131198: LD_VAR 0 10
131202: PPUSH
131203: LD_VAR 0 11
131207: PPUSH
131208: LD_VAR 0 14
131212: PUSH
131213: LD_INT 1
131215: ARRAY
131216: PPUSH
131217: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
131221: LD_VAR 0 4
131225: PUSH
131226: LD_VAR 0 7
131230: ARRAY
131231: PPUSH
131232: LD_VAR 0 10
131236: PPUSH
131237: LD_VAR 0 12
131241: PPUSH
131242: LD_INT 7
131244: PPUSH
131245: CALL_OW 272
131249: PPUSH
131250: LD_VAR 0 11
131254: PPUSH
131255: LD_VAR 0 12
131259: PPUSH
131260: LD_INT 7
131262: PPUSH
131263: CALL_OW 273
131267: PPUSH
131268: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
131272: LD_VAR 0 4
131276: PUSH
131277: LD_VAR 0 7
131281: ARRAY
131282: PPUSH
131283: LD_INT 71
131285: PPUSH
131286: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
131290: LD_ADDR_VAR 0 27
131294: PUSH
131295: LD_VAR 0 27
131299: PPUSH
131300: LD_VAR 0 27
131304: PUSH
131305: LD_INT 1
131307: PLUS
131308: PPUSH
131309: LD_VAR 0 14
131313: PUSH
131314: LD_INT 1
131316: ARRAY
131317: PPUSH
131318: CALL_OW 1
131322: ST_TO_ADDR
// attacking := true ;
131323: LD_ADDR_VAR 0 29
131327: PUSH
131328: LD_INT 1
131330: ST_TO_ADDR
// continue ;
131331: GO 129178
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
131333: LD_VAR 0 4
131337: PUSH
131338: LD_VAR 0 7
131342: ARRAY
131343: PPUSH
131344: CALL_OW 257
131348: PUSH
131349: LD_INT 17
131351: EQUAL
131352: PUSH
131353: LD_VAR 0 4
131357: PUSH
131358: LD_VAR 0 7
131362: ARRAY
131363: PPUSH
131364: CALL_OW 110
131368: PUSH
131369: LD_INT 71
131371: EQUAL
131372: NOT
131373: AND
131374: IFFALSE 131520
// begin attacking := false ;
131376: LD_ADDR_VAR 0 29
131380: PUSH
131381: LD_INT 0
131383: ST_TO_ADDR
// k := 5 ;
131384: LD_ADDR_VAR 0 9
131388: PUSH
131389: LD_INT 5
131391: ST_TO_ADDR
// if tmp < k then
131392: LD_VAR 0 14
131396: PUSH
131397: LD_VAR 0 9
131401: LESS
131402: IFFALSE 131414
// k := tmp ;
131404: LD_ADDR_VAR 0 9
131408: PUSH
131409: LD_VAR 0 14
131413: ST_TO_ADDR
// for j = 1 to k do
131414: LD_ADDR_VAR 0 8
131418: PUSH
131419: DOUBLE
131420: LD_INT 1
131422: DEC
131423: ST_TO_ADDR
131424: LD_VAR 0 9
131428: PUSH
131429: FOR_TO
131430: IFFALSE 131518
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
131432: LD_VAR 0 14
131436: PUSH
131437: LD_VAR 0 8
131441: ARRAY
131442: PUSH
131443: LD_VAR 0 14
131447: PPUSH
131448: LD_INT 58
131450: PUSH
131451: EMPTY
131452: LIST
131453: PPUSH
131454: CALL_OW 72
131458: IN
131459: NOT
131460: IFFALSE 131516
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
131462: LD_VAR 0 4
131466: PUSH
131467: LD_VAR 0 7
131471: ARRAY
131472: PPUSH
131473: LD_VAR 0 14
131477: PUSH
131478: LD_VAR 0 8
131482: ARRAY
131483: PPUSH
131484: CALL_OW 115
// attacking := true ;
131488: LD_ADDR_VAR 0 29
131492: PUSH
131493: LD_INT 1
131495: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
131496: LD_VAR 0 4
131500: PUSH
131501: LD_VAR 0 7
131505: ARRAY
131506: PPUSH
131507: LD_INT 71
131509: PPUSH
131510: CALL_OW 109
// continue ;
131514: GO 131429
// end ; end ;
131516: GO 131429
131518: POP
131519: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
131520: LD_VAR 0 4
131524: PUSH
131525: LD_VAR 0 7
131529: ARRAY
131530: PPUSH
131531: CALL_OW 257
131535: PUSH
131536: LD_INT 8
131538: EQUAL
131539: PUSH
131540: LD_VAR 0 4
131544: PUSH
131545: LD_VAR 0 7
131549: ARRAY
131550: PPUSH
131551: CALL_OW 264
131555: PUSH
131556: LD_INT 28
131558: PUSH
131559: LD_INT 45
131561: PUSH
131562: LD_INT 7
131564: PUSH
131565: LD_INT 47
131567: PUSH
131568: EMPTY
131569: LIST
131570: LIST
131571: LIST
131572: LIST
131573: IN
131574: OR
131575: IFFALSE 131831
// begin attacking := false ;
131577: LD_ADDR_VAR 0 29
131581: PUSH
131582: LD_INT 0
131584: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
131585: LD_VAR 0 14
131589: PUSH
131590: LD_INT 1
131592: ARRAY
131593: PPUSH
131594: CALL_OW 266
131598: PUSH
131599: LD_INT 32
131601: PUSH
131602: LD_INT 31
131604: PUSH
131605: LD_INT 33
131607: PUSH
131608: LD_INT 4
131610: PUSH
131611: LD_INT 5
131613: PUSH
131614: EMPTY
131615: LIST
131616: LIST
131617: LIST
131618: LIST
131619: LIST
131620: IN
131621: IFFALSE 131807
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
131623: LD_ADDR_VAR 0 9
131627: PUSH
131628: LD_VAR 0 14
131632: PUSH
131633: LD_INT 1
131635: ARRAY
131636: PPUSH
131637: CALL_OW 266
131641: PPUSH
131642: LD_VAR 0 14
131646: PUSH
131647: LD_INT 1
131649: ARRAY
131650: PPUSH
131651: CALL_OW 250
131655: PPUSH
131656: LD_VAR 0 14
131660: PUSH
131661: LD_INT 1
131663: ARRAY
131664: PPUSH
131665: CALL_OW 251
131669: PPUSH
131670: LD_VAR 0 14
131674: PUSH
131675: LD_INT 1
131677: ARRAY
131678: PPUSH
131679: CALL_OW 254
131683: PPUSH
131684: LD_VAR 0 14
131688: PUSH
131689: LD_INT 1
131691: ARRAY
131692: PPUSH
131693: CALL_OW 248
131697: PPUSH
131698: LD_INT 0
131700: PPUSH
131701: CALL 81421 0 6
131705: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
131706: LD_ADDR_VAR 0 8
131710: PUSH
131711: LD_VAR 0 4
131715: PUSH
131716: LD_VAR 0 7
131720: ARRAY
131721: PPUSH
131722: LD_VAR 0 9
131726: PPUSH
131727: CALL 100164 0 2
131731: ST_TO_ADDR
// if j then
131732: LD_VAR 0 8
131736: IFFALSE 131805
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
131738: LD_VAR 0 8
131742: PUSH
131743: LD_INT 1
131745: ARRAY
131746: PPUSH
131747: LD_VAR 0 8
131751: PUSH
131752: LD_INT 2
131754: ARRAY
131755: PPUSH
131756: CALL_OW 488
131760: IFFALSE 131805
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
131762: LD_VAR 0 4
131766: PUSH
131767: LD_VAR 0 7
131771: ARRAY
131772: PPUSH
131773: LD_VAR 0 8
131777: PUSH
131778: LD_INT 1
131780: ARRAY
131781: PPUSH
131782: LD_VAR 0 8
131786: PUSH
131787: LD_INT 2
131789: ARRAY
131790: PPUSH
131791: CALL_OW 116
// attacking := true ;
131795: LD_ADDR_VAR 0 29
131799: PUSH
131800: LD_INT 1
131802: ST_TO_ADDR
// continue ;
131803: GO 129178
// end ; end else
131805: GO 131831
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
131807: LD_VAR 0 4
131811: PUSH
131812: LD_VAR 0 7
131816: ARRAY
131817: PPUSH
131818: LD_VAR 0 14
131822: PUSH
131823: LD_INT 1
131825: ARRAY
131826: PPUSH
131827: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
131831: LD_VAR 0 4
131835: PUSH
131836: LD_VAR 0 7
131840: ARRAY
131841: PPUSH
131842: CALL_OW 265
131846: PUSH
131847: LD_INT 11
131849: EQUAL
131850: IFFALSE 132128
// begin k := 10 ;
131852: LD_ADDR_VAR 0 9
131856: PUSH
131857: LD_INT 10
131859: ST_TO_ADDR
// x := 0 ;
131860: LD_ADDR_VAR 0 10
131864: PUSH
131865: LD_INT 0
131867: ST_TO_ADDR
// if tmp < k then
131868: LD_VAR 0 14
131872: PUSH
131873: LD_VAR 0 9
131877: LESS
131878: IFFALSE 131890
// k := tmp ;
131880: LD_ADDR_VAR 0 9
131884: PUSH
131885: LD_VAR 0 14
131889: ST_TO_ADDR
// for j = k downto 1 do
131890: LD_ADDR_VAR 0 8
131894: PUSH
131895: DOUBLE
131896: LD_VAR 0 9
131900: INC
131901: ST_TO_ADDR
131902: LD_INT 1
131904: PUSH
131905: FOR_DOWNTO
131906: IFFALSE 131981
// begin if GetType ( tmp [ j ] ) = unit_human then
131908: LD_VAR 0 14
131912: PUSH
131913: LD_VAR 0 8
131917: ARRAY
131918: PPUSH
131919: CALL_OW 247
131923: PUSH
131924: LD_INT 1
131926: EQUAL
131927: IFFALSE 131979
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
131929: LD_VAR 0 4
131933: PUSH
131934: LD_VAR 0 7
131938: ARRAY
131939: PPUSH
131940: LD_VAR 0 14
131944: PUSH
131945: LD_VAR 0 8
131949: ARRAY
131950: PPUSH
131951: CALL 100418 0 2
// x := tmp [ j ] ;
131955: LD_ADDR_VAR 0 10
131959: PUSH
131960: LD_VAR 0 14
131964: PUSH
131965: LD_VAR 0 8
131969: ARRAY
131970: ST_TO_ADDR
// attacking := true ;
131971: LD_ADDR_VAR 0 29
131975: PUSH
131976: LD_INT 1
131978: ST_TO_ADDR
// end ; end ;
131979: GO 131905
131981: POP
131982: POP
// if not x then
131983: LD_VAR 0 10
131987: NOT
131988: IFFALSE 132128
// begin attacking := true ;
131990: LD_ADDR_VAR 0 29
131994: PUSH
131995: LD_INT 1
131997: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
131998: LD_VAR 0 4
132002: PUSH
132003: LD_VAR 0 7
132007: ARRAY
132008: PPUSH
132009: CALL_OW 250
132013: PPUSH
132014: LD_VAR 0 4
132018: PUSH
132019: LD_VAR 0 7
132023: ARRAY
132024: PPUSH
132025: CALL_OW 251
132029: PPUSH
132030: CALL_OW 546
132034: PUSH
132035: LD_INT 2
132037: ARRAY
132038: PUSH
132039: LD_VAR 0 14
132043: PUSH
132044: LD_INT 1
132046: ARRAY
132047: PPUSH
132048: CALL_OW 250
132052: PPUSH
132053: LD_VAR 0 14
132057: PUSH
132058: LD_INT 1
132060: ARRAY
132061: PPUSH
132062: CALL_OW 251
132066: PPUSH
132067: CALL_OW 546
132071: PUSH
132072: LD_INT 2
132074: ARRAY
132075: EQUAL
132076: IFFALSE 132104
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
132078: LD_VAR 0 4
132082: PUSH
132083: LD_VAR 0 7
132087: ARRAY
132088: PPUSH
132089: LD_VAR 0 14
132093: PUSH
132094: LD_INT 1
132096: ARRAY
132097: PPUSH
132098: CALL 100418 0 2
132102: GO 132128
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
132104: LD_VAR 0 4
132108: PUSH
132109: LD_VAR 0 7
132113: ARRAY
132114: PPUSH
132115: LD_VAR 0 14
132119: PUSH
132120: LD_INT 1
132122: ARRAY
132123: PPUSH
132124: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
132128: LD_VAR 0 4
132132: PUSH
132133: LD_VAR 0 7
132137: ARRAY
132138: PPUSH
132139: CALL_OW 264
132143: PUSH
132144: LD_INT 29
132146: EQUAL
132147: IFFALSE 132513
// begin if WantsToAttack ( group [ i ] ) in bombed then
132149: LD_VAR 0 4
132153: PUSH
132154: LD_VAR 0 7
132158: ARRAY
132159: PPUSH
132160: CALL_OW 319
132164: PUSH
132165: LD_VAR 0 28
132169: IN
132170: IFFALSE 132174
// continue ;
132172: GO 129178
// k := 8 ;
132174: LD_ADDR_VAR 0 9
132178: PUSH
132179: LD_INT 8
132181: ST_TO_ADDR
// x := 0 ;
132182: LD_ADDR_VAR 0 10
132186: PUSH
132187: LD_INT 0
132189: ST_TO_ADDR
// if tmp < k then
132190: LD_VAR 0 14
132194: PUSH
132195: LD_VAR 0 9
132199: LESS
132200: IFFALSE 132212
// k := tmp ;
132202: LD_ADDR_VAR 0 9
132206: PUSH
132207: LD_VAR 0 14
132211: ST_TO_ADDR
// for j = 1 to k do
132212: LD_ADDR_VAR 0 8
132216: PUSH
132217: DOUBLE
132218: LD_INT 1
132220: DEC
132221: ST_TO_ADDR
132222: LD_VAR 0 9
132226: PUSH
132227: FOR_TO
132228: IFFALSE 132360
// begin if GetType ( tmp [ j ] ) = unit_building then
132230: LD_VAR 0 14
132234: PUSH
132235: LD_VAR 0 8
132239: ARRAY
132240: PPUSH
132241: CALL_OW 247
132245: PUSH
132246: LD_INT 3
132248: EQUAL
132249: IFFALSE 132358
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
132251: LD_VAR 0 14
132255: PUSH
132256: LD_VAR 0 8
132260: ARRAY
132261: PUSH
132262: LD_VAR 0 28
132266: IN
132267: NOT
132268: PUSH
132269: LD_VAR 0 14
132273: PUSH
132274: LD_VAR 0 8
132278: ARRAY
132279: PPUSH
132280: CALL_OW 313
132284: AND
132285: IFFALSE 132358
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
132287: LD_VAR 0 4
132291: PUSH
132292: LD_VAR 0 7
132296: ARRAY
132297: PPUSH
132298: LD_VAR 0 14
132302: PUSH
132303: LD_VAR 0 8
132307: ARRAY
132308: PPUSH
132309: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
132313: LD_ADDR_VAR 0 28
132317: PUSH
132318: LD_VAR 0 28
132322: PPUSH
132323: LD_VAR 0 28
132327: PUSH
132328: LD_INT 1
132330: PLUS
132331: PPUSH
132332: LD_VAR 0 14
132336: PUSH
132337: LD_VAR 0 8
132341: ARRAY
132342: PPUSH
132343: CALL_OW 1
132347: ST_TO_ADDR
// attacking := true ;
132348: LD_ADDR_VAR 0 29
132352: PUSH
132353: LD_INT 1
132355: ST_TO_ADDR
// break ;
132356: GO 132360
// end ; end ;
132358: GO 132227
132360: POP
132361: POP
// if not attacking and f_attack_depot then
132362: LD_VAR 0 29
132366: NOT
132367: PUSH
132368: LD_VAR 0 25
132372: AND
132373: IFFALSE 132468
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
132375: LD_ADDR_VAR 0 13
132379: PUSH
132380: LD_VAR 0 14
132384: PPUSH
132385: LD_INT 2
132387: PUSH
132388: LD_INT 30
132390: PUSH
132391: LD_INT 0
132393: PUSH
132394: EMPTY
132395: LIST
132396: LIST
132397: PUSH
132398: LD_INT 30
132400: PUSH
132401: LD_INT 1
132403: PUSH
132404: EMPTY
132405: LIST
132406: LIST
132407: PUSH
132408: EMPTY
132409: LIST
132410: LIST
132411: LIST
132412: PPUSH
132413: CALL_OW 72
132417: ST_TO_ADDR
// if z then
132418: LD_VAR 0 13
132422: IFFALSE 132468
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
132424: LD_VAR 0 4
132428: PUSH
132429: LD_VAR 0 7
132433: ARRAY
132434: PPUSH
132435: LD_VAR 0 13
132439: PPUSH
132440: LD_VAR 0 4
132444: PUSH
132445: LD_VAR 0 7
132449: ARRAY
132450: PPUSH
132451: CALL_OW 74
132455: PPUSH
132456: CALL_OW 115
// attacking := true ;
132460: LD_ADDR_VAR 0 29
132464: PUSH
132465: LD_INT 1
132467: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
132468: LD_VAR 0 4
132472: PUSH
132473: LD_VAR 0 7
132477: ARRAY
132478: PPUSH
132479: CALL_OW 256
132483: PUSH
132484: LD_INT 500
132486: LESS
132487: IFFALSE 132513
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
132489: LD_VAR 0 4
132493: PUSH
132494: LD_VAR 0 7
132498: ARRAY
132499: PPUSH
132500: LD_VAR 0 14
132504: PUSH
132505: LD_INT 1
132507: ARRAY
132508: PPUSH
132509: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
132513: LD_VAR 0 4
132517: PUSH
132518: LD_VAR 0 7
132522: ARRAY
132523: PPUSH
132524: CALL_OW 264
132528: PUSH
132529: LD_INT 49
132531: EQUAL
132532: IFFALSE 132653
// begin if not HasTask ( group [ i ] ) then
132534: LD_VAR 0 4
132538: PUSH
132539: LD_VAR 0 7
132543: ARRAY
132544: PPUSH
132545: CALL_OW 314
132549: NOT
132550: IFFALSE 132653
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
132552: LD_ADDR_VAR 0 9
132556: PUSH
132557: LD_INT 81
132559: PUSH
132560: LD_VAR 0 4
132564: PUSH
132565: LD_VAR 0 7
132569: ARRAY
132570: PPUSH
132571: CALL_OW 255
132575: PUSH
132576: EMPTY
132577: LIST
132578: LIST
132579: PPUSH
132580: CALL_OW 69
132584: PPUSH
132585: LD_VAR 0 4
132589: PUSH
132590: LD_VAR 0 7
132594: ARRAY
132595: PPUSH
132596: CALL_OW 74
132600: ST_TO_ADDR
// if k then
132601: LD_VAR 0 9
132605: IFFALSE 132653
// if GetDistUnits ( group [ i ] , k ) > 10 then
132607: LD_VAR 0 4
132611: PUSH
132612: LD_VAR 0 7
132616: ARRAY
132617: PPUSH
132618: LD_VAR 0 9
132622: PPUSH
132623: CALL_OW 296
132627: PUSH
132628: LD_INT 10
132630: GREATER
132631: IFFALSE 132653
// ComMoveUnit ( group [ i ] , k ) ;
132633: LD_VAR 0 4
132637: PUSH
132638: LD_VAR 0 7
132642: ARRAY
132643: PPUSH
132644: LD_VAR 0 9
132648: PPUSH
132649: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
132653: LD_VAR 0 4
132657: PUSH
132658: LD_VAR 0 7
132662: ARRAY
132663: PPUSH
132664: CALL_OW 256
132668: PUSH
132669: LD_INT 250
132671: LESS
132672: PUSH
132673: LD_VAR 0 4
132677: PUSH
132678: LD_VAR 0 7
132682: ARRAY
132683: PUSH
132684: LD_INT 21
132686: PUSH
132687: LD_INT 2
132689: PUSH
132690: EMPTY
132691: LIST
132692: LIST
132693: PUSH
132694: LD_INT 23
132696: PUSH
132697: LD_INT 2
132699: PUSH
132700: EMPTY
132701: LIST
132702: LIST
132703: PUSH
132704: EMPTY
132705: LIST
132706: LIST
132707: PPUSH
132708: CALL_OW 69
132712: IN
132713: AND
132714: IFFALSE 132839
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
132716: LD_ADDR_VAR 0 9
132720: PUSH
132721: LD_OWVAR 3
132725: PUSH
132726: LD_VAR 0 4
132730: PUSH
132731: LD_VAR 0 7
132735: ARRAY
132736: DIFF
132737: PPUSH
132738: LD_VAR 0 4
132742: PUSH
132743: LD_VAR 0 7
132747: ARRAY
132748: PPUSH
132749: CALL_OW 74
132753: ST_TO_ADDR
// if not k then
132754: LD_VAR 0 9
132758: NOT
132759: IFFALSE 132763
// continue ;
132761: GO 129178
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
132763: LD_VAR 0 9
132767: PUSH
132768: LD_INT 81
132770: PUSH
132771: LD_VAR 0 4
132775: PUSH
132776: LD_VAR 0 7
132780: ARRAY
132781: PPUSH
132782: CALL_OW 255
132786: PUSH
132787: EMPTY
132788: LIST
132789: LIST
132790: PPUSH
132791: CALL_OW 69
132795: IN
132796: PUSH
132797: LD_VAR 0 9
132801: PPUSH
132802: LD_VAR 0 4
132806: PUSH
132807: LD_VAR 0 7
132811: ARRAY
132812: PPUSH
132813: CALL_OW 296
132817: PUSH
132818: LD_INT 5
132820: LESS
132821: AND
132822: IFFALSE 132839
// ComAutodestruct ( group [ i ] ) ;
132824: LD_VAR 0 4
132828: PUSH
132829: LD_VAR 0 7
132833: ARRAY
132834: PPUSH
132835: CALL 100316 0 1
// end ; if f_attack_depot then
132839: LD_VAR 0 25
132843: IFFALSE 132955
// begin k := 6 ;
132845: LD_ADDR_VAR 0 9
132849: PUSH
132850: LD_INT 6
132852: ST_TO_ADDR
// if tmp < k then
132853: LD_VAR 0 14
132857: PUSH
132858: LD_VAR 0 9
132862: LESS
132863: IFFALSE 132875
// k := tmp ;
132865: LD_ADDR_VAR 0 9
132869: PUSH
132870: LD_VAR 0 14
132874: ST_TO_ADDR
// for j = 1 to k do
132875: LD_ADDR_VAR 0 8
132879: PUSH
132880: DOUBLE
132881: LD_INT 1
132883: DEC
132884: ST_TO_ADDR
132885: LD_VAR 0 9
132889: PUSH
132890: FOR_TO
132891: IFFALSE 132953
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
132893: LD_VAR 0 8
132897: PPUSH
132898: CALL_OW 266
132902: PUSH
132903: LD_INT 0
132905: PUSH
132906: LD_INT 1
132908: PUSH
132909: EMPTY
132910: LIST
132911: LIST
132912: IN
132913: IFFALSE 132951
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
132915: LD_VAR 0 4
132919: PUSH
132920: LD_VAR 0 7
132924: ARRAY
132925: PPUSH
132926: LD_VAR 0 14
132930: PUSH
132931: LD_VAR 0 8
132935: ARRAY
132936: PPUSH
132937: CALL_OW 115
// attacking := true ;
132941: LD_ADDR_VAR 0 29
132945: PUSH
132946: LD_INT 1
132948: ST_TO_ADDR
// break ;
132949: GO 132953
// end ;
132951: GO 132890
132953: POP
132954: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
132955: LD_VAR 0 4
132959: PUSH
132960: LD_VAR 0 7
132964: ARRAY
132965: PPUSH
132966: CALL_OW 302
132970: PUSH
132971: LD_VAR 0 29
132975: NOT
132976: AND
132977: IFFALSE 133299
// begin if GetTag ( group [ i ] ) = 71 then
132979: LD_VAR 0 4
132983: PUSH
132984: LD_VAR 0 7
132988: ARRAY
132989: PPUSH
132990: CALL_OW 110
132994: PUSH
132995: LD_INT 71
132997: EQUAL
132998: IFFALSE 133039
// begin if HasTask ( group [ i ] ) then
133000: LD_VAR 0 4
133004: PUSH
133005: LD_VAR 0 7
133009: ARRAY
133010: PPUSH
133011: CALL_OW 314
133015: IFFALSE 133021
// continue else
133017: GO 129178
133019: GO 133039
// SetTag ( group [ i ] , 0 ) ;
133021: LD_VAR 0 4
133025: PUSH
133026: LD_VAR 0 7
133030: ARRAY
133031: PPUSH
133032: LD_INT 0
133034: PPUSH
133035: CALL_OW 109
// end ; k := 8 ;
133039: LD_ADDR_VAR 0 9
133043: PUSH
133044: LD_INT 8
133046: ST_TO_ADDR
// x := 0 ;
133047: LD_ADDR_VAR 0 10
133051: PUSH
133052: LD_INT 0
133054: ST_TO_ADDR
// if tmp < k then
133055: LD_VAR 0 14
133059: PUSH
133060: LD_VAR 0 9
133064: LESS
133065: IFFALSE 133077
// k := tmp ;
133067: LD_ADDR_VAR 0 9
133071: PUSH
133072: LD_VAR 0 14
133076: ST_TO_ADDR
// for j = 1 to k do
133077: LD_ADDR_VAR 0 8
133081: PUSH
133082: DOUBLE
133083: LD_INT 1
133085: DEC
133086: ST_TO_ADDR
133087: LD_VAR 0 9
133091: PUSH
133092: FOR_TO
133093: IFFALSE 133191
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
133095: LD_VAR 0 14
133099: PUSH
133100: LD_VAR 0 8
133104: ARRAY
133105: PPUSH
133106: CALL_OW 247
133110: PUSH
133111: LD_INT 1
133113: EQUAL
133114: PUSH
133115: LD_VAR 0 14
133119: PUSH
133120: LD_VAR 0 8
133124: ARRAY
133125: PPUSH
133126: CALL_OW 256
133130: PUSH
133131: LD_INT 250
133133: LESS
133134: PUSH
133135: LD_VAR 0 20
133139: AND
133140: PUSH
133141: LD_VAR 0 20
133145: NOT
133146: PUSH
133147: LD_VAR 0 14
133151: PUSH
133152: LD_VAR 0 8
133156: ARRAY
133157: PPUSH
133158: CALL_OW 256
133162: PUSH
133163: LD_INT 250
133165: GREATEREQUAL
133166: AND
133167: OR
133168: AND
133169: IFFALSE 133189
// begin x := tmp [ j ] ;
133171: LD_ADDR_VAR 0 10
133175: PUSH
133176: LD_VAR 0 14
133180: PUSH
133181: LD_VAR 0 8
133185: ARRAY
133186: ST_TO_ADDR
// break ;
133187: GO 133191
// end ;
133189: GO 133092
133191: POP
133192: POP
// if x then
133193: LD_VAR 0 10
133197: IFFALSE 133221
// ComAttackUnit ( group [ i ] , x ) else
133199: LD_VAR 0 4
133203: PUSH
133204: LD_VAR 0 7
133208: ARRAY
133209: PPUSH
133210: LD_VAR 0 10
133214: PPUSH
133215: CALL_OW 115
133219: GO 133245
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
133221: LD_VAR 0 4
133225: PUSH
133226: LD_VAR 0 7
133230: ARRAY
133231: PPUSH
133232: LD_VAR 0 14
133236: PUSH
133237: LD_INT 1
133239: ARRAY
133240: PPUSH
133241: CALL_OW 115
// if not HasTask ( group [ i ] ) then
133245: LD_VAR 0 4
133249: PUSH
133250: LD_VAR 0 7
133254: ARRAY
133255: PPUSH
133256: CALL_OW 314
133260: NOT
133261: IFFALSE 133299
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
133263: LD_VAR 0 4
133267: PUSH
133268: LD_VAR 0 7
133272: ARRAY
133273: PPUSH
133274: LD_VAR 0 14
133278: PPUSH
133279: LD_VAR 0 4
133283: PUSH
133284: LD_VAR 0 7
133288: ARRAY
133289: PPUSH
133290: CALL_OW 74
133294: PPUSH
133295: CALL_OW 115
// end ; end ; end ;
133299: GO 129178
133301: POP
133302: POP
// wait ( 0 0$2 ) ;
133303: LD_INT 70
133305: PPUSH
133306: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
133310: LD_VAR 0 4
133314: NOT
133315: PUSH
133316: LD_VAR 0 4
133320: PUSH
133321: EMPTY
133322: EQUAL
133323: OR
133324: PUSH
133325: LD_INT 81
133327: PUSH
133328: LD_VAR 0 35
133332: PUSH
133333: EMPTY
133334: LIST
133335: LIST
133336: PPUSH
133337: CALL_OW 69
133341: NOT
133342: OR
133343: IFFALSE 129163
// end ;
133345: LD_VAR 0 2
133349: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
133350: LD_INT 0
133352: PPUSH
133353: PPUSH
133354: PPUSH
133355: PPUSH
133356: PPUSH
133357: PPUSH
// if not base or not mc_bases [ base ] or not solds then
133358: LD_VAR 0 1
133362: NOT
133363: PUSH
133364: LD_EXP 99
133368: PUSH
133369: LD_VAR 0 1
133373: ARRAY
133374: NOT
133375: OR
133376: PUSH
133377: LD_VAR 0 2
133381: NOT
133382: OR
133383: IFFALSE 133387
// exit ;
133385: GO 133941
// side := mc_sides [ base ] ;
133387: LD_ADDR_VAR 0 6
133391: PUSH
133392: LD_EXP 125
133396: PUSH
133397: LD_VAR 0 1
133401: ARRAY
133402: ST_TO_ADDR
// if not side then
133403: LD_VAR 0 6
133407: NOT
133408: IFFALSE 133412
// exit ;
133410: GO 133941
// for i in solds do
133412: LD_ADDR_VAR 0 7
133416: PUSH
133417: LD_VAR 0 2
133421: PUSH
133422: FOR_IN
133423: IFFALSE 133484
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
133425: LD_VAR 0 7
133429: PPUSH
133430: CALL_OW 310
133434: PPUSH
133435: CALL_OW 266
133439: PUSH
133440: LD_INT 32
133442: PUSH
133443: LD_INT 31
133445: PUSH
133446: EMPTY
133447: LIST
133448: LIST
133449: IN
133450: IFFALSE 133470
// solds := solds diff i else
133452: LD_ADDR_VAR 0 2
133456: PUSH
133457: LD_VAR 0 2
133461: PUSH
133462: LD_VAR 0 7
133466: DIFF
133467: ST_TO_ADDR
133468: GO 133482
// SetTag ( i , 18 ) ;
133470: LD_VAR 0 7
133474: PPUSH
133475: LD_INT 18
133477: PPUSH
133478: CALL_OW 109
133482: GO 133422
133484: POP
133485: POP
// if not solds then
133486: LD_VAR 0 2
133490: NOT
133491: IFFALSE 133495
// exit ;
133493: GO 133941
// repeat wait ( 0 0$2 ) ;
133495: LD_INT 70
133497: PPUSH
133498: CALL_OW 67
// enemy := mc_scan [ base ] ;
133502: LD_ADDR_VAR 0 4
133506: PUSH
133507: LD_EXP 122
133511: PUSH
133512: LD_VAR 0 1
133516: ARRAY
133517: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
133518: LD_EXP 99
133522: PUSH
133523: LD_VAR 0 1
133527: ARRAY
133528: NOT
133529: PUSH
133530: LD_EXP 99
133534: PUSH
133535: LD_VAR 0 1
133539: ARRAY
133540: PUSH
133541: EMPTY
133542: EQUAL
133543: OR
133544: IFFALSE 133581
// begin for i in solds do
133546: LD_ADDR_VAR 0 7
133550: PUSH
133551: LD_VAR 0 2
133555: PUSH
133556: FOR_IN
133557: IFFALSE 133570
// ComStop ( i ) ;
133559: LD_VAR 0 7
133563: PPUSH
133564: CALL_OW 141
133568: GO 133556
133570: POP
133571: POP
// solds := [ ] ;
133572: LD_ADDR_VAR 0 2
133576: PUSH
133577: EMPTY
133578: ST_TO_ADDR
// exit ;
133579: GO 133941
// end ; for i in solds do
133581: LD_ADDR_VAR 0 7
133585: PUSH
133586: LD_VAR 0 2
133590: PUSH
133591: FOR_IN
133592: IFFALSE 133913
// begin if IsInUnit ( i ) then
133594: LD_VAR 0 7
133598: PPUSH
133599: CALL_OW 310
133603: IFFALSE 133614
// ComExitBuilding ( i ) ;
133605: LD_VAR 0 7
133609: PPUSH
133610: CALL_OW 122
// if GetLives ( i ) > 500 then
133614: LD_VAR 0 7
133618: PPUSH
133619: CALL_OW 256
133623: PUSH
133624: LD_INT 500
133626: GREATER
133627: IFFALSE 133680
// begin e := NearestUnitToUnit ( enemy , i ) ;
133629: LD_ADDR_VAR 0 5
133633: PUSH
133634: LD_VAR 0 4
133638: PPUSH
133639: LD_VAR 0 7
133643: PPUSH
133644: CALL_OW 74
133648: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
133649: LD_VAR 0 7
133653: PPUSH
133654: LD_VAR 0 5
133658: PPUSH
133659: CALL_OW 250
133663: PPUSH
133664: LD_VAR 0 5
133668: PPUSH
133669: CALL_OW 251
133673: PPUSH
133674: CALL_OW 114
// end else
133678: GO 133911
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
133680: LD_VAR 0 7
133684: PPUSH
133685: LD_EXP 99
133689: PUSH
133690: LD_VAR 0 1
133694: ARRAY
133695: PPUSH
133696: LD_INT 2
133698: PUSH
133699: LD_INT 30
133701: PUSH
133702: LD_INT 0
133704: PUSH
133705: EMPTY
133706: LIST
133707: LIST
133708: PUSH
133709: LD_INT 30
133711: PUSH
133712: LD_INT 1
133714: PUSH
133715: EMPTY
133716: LIST
133717: LIST
133718: PUSH
133719: LD_INT 30
133721: PUSH
133722: LD_INT 6
133724: PUSH
133725: EMPTY
133726: LIST
133727: LIST
133728: PUSH
133729: EMPTY
133730: LIST
133731: LIST
133732: LIST
133733: LIST
133734: PPUSH
133735: CALL_OW 72
133739: PPUSH
133740: LD_VAR 0 7
133744: PPUSH
133745: CALL_OW 74
133749: PPUSH
133750: CALL_OW 296
133754: PUSH
133755: LD_INT 10
133757: GREATER
133758: IFFALSE 133911
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
133760: LD_ADDR_VAR 0 8
133764: PUSH
133765: LD_EXP 99
133769: PUSH
133770: LD_VAR 0 1
133774: ARRAY
133775: PPUSH
133776: LD_INT 2
133778: PUSH
133779: LD_INT 30
133781: PUSH
133782: LD_INT 0
133784: PUSH
133785: EMPTY
133786: LIST
133787: LIST
133788: PUSH
133789: LD_INT 30
133791: PUSH
133792: LD_INT 1
133794: PUSH
133795: EMPTY
133796: LIST
133797: LIST
133798: PUSH
133799: LD_INT 30
133801: PUSH
133802: LD_INT 6
133804: PUSH
133805: EMPTY
133806: LIST
133807: LIST
133808: PUSH
133809: EMPTY
133810: LIST
133811: LIST
133812: LIST
133813: LIST
133814: PPUSH
133815: CALL_OW 72
133819: PPUSH
133820: LD_VAR 0 7
133824: PPUSH
133825: CALL_OW 74
133829: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
133830: LD_VAR 0 7
133834: PPUSH
133835: LD_VAR 0 8
133839: PPUSH
133840: CALL_OW 250
133844: PPUSH
133845: LD_INT 3
133847: PPUSH
133848: LD_INT 5
133850: PPUSH
133851: CALL_OW 272
133855: PPUSH
133856: LD_VAR 0 8
133860: PPUSH
133861: CALL_OW 251
133865: PPUSH
133866: LD_INT 3
133868: PPUSH
133869: LD_INT 5
133871: PPUSH
133872: CALL_OW 273
133876: PPUSH
133877: CALL_OW 111
// SetTag ( i , 0 ) ;
133881: LD_VAR 0 7
133885: PPUSH
133886: LD_INT 0
133888: PPUSH
133889: CALL_OW 109
// solds := solds diff i ;
133893: LD_ADDR_VAR 0 2
133897: PUSH
133898: LD_VAR 0 2
133902: PUSH
133903: LD_VAR 0 7
133907: DIFF
133908: ST_TO_ADDR
// continue ;
133909: GO 133591
// end ; end ;
133911: GO 133591
133913: POP
133914: POP
// until not solds or not enemy ;
133915: LD_VAR 0 2
133919: NOT
133920: PUSH
133921: LD_VAR 0 4
133925: NOT
133926: OR
133927: IFFALSE 133495
// MC_Reset ( base , 18 ) ;
133929: LD_VAR 0 1
133933: PPUSH
133934: LD_INT 18
133936: PPUSH
133937: CALL 40832 0 2
// end ;
133941: LD_VAR 0 3
133945: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
133946: LD_INT 0
133948: PPUSH
133949: PPUSH
133950: PPUSH
133951: PPUSH
133952: PPUSH
133953: PPUSH
133954: PPUSH
133955: PPUSH
133956: PPUSH
133957: PPUSH
133958: PPUSH
133959: PPUSH
133960: PPUSH
133961: PPUSH
133962: PPUSH
133963: PPUSH
133964: PPUSH
133965: PPUSH
133966: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
133967: LD_ADDR_VAR 0 12
133971: PUSH
133972: LD_EXP 99
133976: PUSH
133977: LD_VAR 0 1
133981: ARRAY
133982: PPUSH
133983: LD_INT 25
133985: PUSH
133986: LD_INT 3
133988: PUSH
133989: EMPTY
133990: LIST
133991: LIST
133992: PPUSH
133993: CALL_OW 72
133997: ST_TO_ADDR
// if mc_remote_driver [ base ] then
133998: LD_EXP 139
134002: PUSH
134003: LD_VAR 0 1
134007: ARRAY
134008: IFFALSE 134032
// mechs := mechs diff mc_remote_driver [ base ] ;
134010: LD_ADDR_VAR 0 12
134014: PUSH
134015: LD_VAR 0 12
134019: PUSH
134020: LD_EXP 139
134024: PUSH
134025: LD_VAR 0 1
134029: ARRAY
134030: DIFF
134031: ST_TO_ADDR
// for i in mechs do
134032: LD_ADDR_VAR 0 4
134036: PUSH
134037: LD_VAR 0 12
134041: PUSH
134042: FOR_IN
134043: IFFALSE 134078
// if GetTag ( i ) > 0 then
134045: LD_VAR 0 4
134049: PPUSH
134050: CALL_OW 110
134054: PUSH
134055: LD_INT 0
134057: GREATER
134058: IFFALSE 134076
// mechs := mechs diff i ;
134060: LD_ADDR_VAR 0 12
134064: PUSH
134065: LD_VAR 0 12
134069: PUSH
134070: LD_VAR 0 4
134074: DIFF
134075: ST_TO_ADDR
134076: GO 134042
134078: POP
134079: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
134080: LD_ADDR_VAR 0 8
134084: PUSH
134085: LD_EXP 99
134089: PUSH
134090: LD_VAR 0 1
134094: ARRAY
134095: PPUSH
134096: LD_INT 2
134098: PUSH
134099: LD_INT 25
134101: PUSH
134102: LD_INT 1
134104: PUSH
134105: EMPTY
134106: LIST
134107: LIST
134108: PUSH
134109: LD_INT 25
134111: PUSH
134112: LD_INT 5
134114: PUSH
134115: EMPTY
134116: LIST
134117: LIST
134118: PUSH
134119: LD_INT 25
134121: PUSH
134122: LD_INT 8
134124: PUSH
134125: EMPTY
134126: LIST
134127: LIST
134128: PUSH
134129: LD_INT 25
134131: PUSH
134132: LD_INT 9
134134: PUSH
134135: EMPTY
134136: LIST
134137: LIST
134138: PUSH
134139: EMPTY
134140: LIST
134141: LIST
134142: LIST
134143: LIST
134144: LIST
134145: PPUSH
134146: CALL_OW 72
134150: ST_TO_ADDR
// if not defenders and not solds then
134151: LD_VAR 0 2
134155: NOT
134156: PUSH
134157: LD_VAR 0 8
134161: NOT
134162: AND
134163: IFFALSE 134167
// exit ;
134165: GO 135937
// depot_under_attack := false ;
134167: LD_ADDR_VAR 0 16
134171: PUSH
134172: LD_INT 0
134174: ST_TO_ADDR
// sold_defenders := [ ] ;
134175: LD_ADDR_VAR 0 17
134179: PUSH
134180: EMPTY
134181: ST_TO_ADDR
// if mechs then
134182: LD_VAR 0 12
134186: IFFALSE 134339
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
134188: LD_ADDR_VAR 0 4
134192: PUSH
134193: LD_VAR 0 2
134197: PPUSH
134198: LD_INT 21
134200: PUSH
134201: LD_INT 2
134203: PUSH
134204: EMPTY
134205: LIST
134206: LIST
134207: PPUSH
134208: CALL_OW 72
134212: PUSH
134213: FOR_IN
134214: IFFALSE 134337
// begin if GetTag ( i ) <> 20 then
134216: LD_VAR 0 4
134220: PPUSH
134221: CALL_OW 110
134225: PUSH
134226: LD_INT 20
134228: NONEQUAL
134229: IFFALSE 134243
// SetTag ( i , 20 ) ;
134231: LD_VAR 0 4
134235: PPUSH
134236: LD_INT 20
134238: PPUSH
134239: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
134243: LD_VAR 0 4
134247: PPUSH
134248: CALL_OW 263
134252: PUSH
134253: LD_INT 1
134255: EQUAL
134256: PUSH
134257: LD_VAR 0 4
134261: PPUSH
134262: CALL_OW 311
134266: NOT
134267: AND
134268: IFFALSE 134335
// begin un := mechs [ 1 ] ;
134270: LD_ADDR_VAR 0 10
134274: PUSH
134275: LD_VAR 0 12
134279: PUSH
134280: LD_INT 1
134282: ARRAY
134283: ST_TO_ADDR
// ComExit ( un ) ;
134284: LD_VAR 0 10
134288: PPUSH
134289: CALL 105182 0 1
// AddComEnterUnit ( un , i ) ;
134293: LD_VAR 0 10
134297: PPUSH
134298: LD_VAR 0 4
134302: PPUSH
134303: CALL_OW 180
// SetTag ( un , 19 ) ;
134307: LD_VAR 0 10
134311: PPUSH
134312: LD_INT 19
134314: PPUSH
134315: CALL_OW 109
// mechs := mechs diff un ;
134319: LD_ADDR_VAR 0 12
134323: PUSH
134324: LD_VAR 0 12
134328: PUSH
134329: LD_VAR 0 10
134333: DIFF
134334: ST_TO_ADDR
// end ; end ;
134335: GO 134213
134337: POP
134338: POP
// if solds then
134339: LD_VAR 0 8
134343: IFFALSE 134402
// for i in solds do
134345: LD_ADDR_VAR 0 4
134349: PUSH
134350: LD_VAR 0 8
134354: PUSH
134355: FOR_IN
134356: IFFALSE 134400
// if not GetTag ( i ) then
134358: LD_VAR 0 4
134362: PPUSH
134363: CALL_OW 110
134367: NOT
134368: IFFALSE 134398
// begin defenders := defenders union i ;
134370: LD_ADDR_VAR 0 2
134374: PUSH
134375: LD_VAR 0 2
134379: PUSH
134380: LD_VAR 0 4
134384: UNION
134385: ST_TO_ADDR
// SetTag ( i , 18 ) ;
134386: LD_VAR 0 4
134390: PPUSH
134391: LD_INT 18
134393: PPUSH
134394: CALL_OW 109
// end ;
134398: GO 134355
134400: POP
134401: POP
// repeat wait ( 0 0$2 ) ;
134402: LD_INT 70
134404: PPUSH
134405: CALL_OW 67
// enemy := mc_scan [ base ] ;
134409: LD_ADDR_VAR 0 21
134413: PUSH
134414: LD_EXP 122
134418: PUSH
134419: LD_VAR 0 1
134423: ARRAY
134424: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
134425: LD_EXP 99
134429: PUSH
134430: LD_VAR 0 1
134434: ARRAY
134435: NOT
134436: PUSH
134437: LD_EXP 99
134441: PUSH
134442: LD_VAR 0 1
134446: ARRAY
134447: PUSH
134448: EMPTY
134449: EQUAL
134450: OR
134451: IFFALSE 134488
// begin for i in defenders do
134453: LD_ADDR_VAR 0 4
134457: PUSH
134458: LD_VAR 0 2
134462: PUSH
134463: FOR_IN
134464: IFFALSE 134477
// ComStop ( i ) ;
134466: LD_VAR 0 4
134470: PPUSH
134471: CALL_OW 141
134475: GO 134463
134477: POP
134478: POP
// defenders := [ ] ;
134479: LD_ADDR_VAR 0 2
134483: PUSH
134484: EMPTY
134485: ST_TO_ADDR
// exit ;
134486: GO 135937
// end ; for i in defenders do
134488: LD_ADDR_VAR 0 4
134492: PUSH
134493: LD_VAR 0 2
134497: PUSH
134498: FOR_IN
134499: IFFALSE 135397
// begin e := NearestUnitToUnit ( enemy , i ) ;
134501: LD_ADDR_VAR 0 13
134505: PUSH
134506: LD_VAR 0 21
134510: PPUSH
134511: LD_VAR 0 4
134515: PPUSH
134516: CALL_OW 74
134520: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
134521: LD_ADDR_VAR 0 7
134525: PUSH
134526: LD_EXP 99
134530: PUSH
134531: LD_VAR 0 1
134535: ARRAY
134536: PPUSH
134537: LD_INT 2
134539: PUSH
134540: LD_INT 30
134542: PUSH
134543: LD_INT 0
134545: PUSH
134546: EMPTY
134547: LIST
134548: LIST
134549: PUSH
134550: LD_INT 30
134552: PUSH
134553: LD_INT 1
134555: PUSH
134556: EMPTY
134557: LIST
134558: LIST
134559: PUSH
134560: EMPTY
134561: LIST
134562: LIST
134563: LIST
134564: PPUSH
134565: CALL_OW 72
134569: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
134570: LD_ADDR_VAR 0 16
134574: PUSH
134575: LD_VAR 0 7
134579: NOT
134580: PUSH
134581: LD_VAR 0 7
134585: PPUSH
134586: LD_INT 3
134588: PUSH
134589: LD_INT 24
134591: PUSH
134592: LD_INT 600
134594: PUSH
134595: EMPTY
134596: LIST
134597: LIST
134598: PUSH
134599: EMPTY
134600: LIST
134601: LIST
134602: PPUSH
134603: CALL_OW 72
134607: OR
134608: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
134609: LD_VAR 0 4
134613: PPUSH
134614: CALL_OW 247
134618: PUSH
134619: LD_INT 2
134621: DOUBLE
134622: EQUAL
134623: IFTRUE 134627
134625: GO 135023
134627: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
134628: LD_VAR 0 4
134632: PPUSH
134633: CALL_OW 256
134637: PUSH
134638: LD_INT 1000
134640: EQUAL
134641: PUSH
134642: LD_VAR 0 4
134646: PPUSH
134647: LD_VAR 0 13
134651: PPUSH
134652: CALL_OW 296
134656: PUSH
134657: LD_INT 40
134659: LESS
134660: PUSH
134661: LD_VAR 0 13
134665: PPUSH
134666: LD_EXP 124
134670: PUSH
134671: LD_VAR 0 1
134675: ARRAY
134676: PPUSH
134677: CALL_OW 308
134681: OR
134682: AND
134683: IFFALSE 134805
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
134685: LD_VAR 0 4
134689: PPUSH
134690: CALL_OW 262
134694: PUSH
134695: LD_INT 1
134697: EQUAL
134698: PUSH
134699: LD_VAR 0 4
134703: PPUSH
134704: CALL_OW 261
134708: PUSH
134709: LD_INT 30
134711: LESS
134712: AND
134713: PUSH
134714: LD_VAR 0 7
134718: AND
134719: IFFALSE 134789
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
134721: LD_VAR 0 4
134725: PPUSH
134726: LD_VAR 0 7
134730: PPUSH
134731: LD_VAR 0 4
134735: PPUSH
134736: CALL_OW 74
134740: PPUSH
134741: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
134745: LD_VAR 0 4
134749: PPUSH
134750: LD_VAR 0 7
134754: PPUSH
134755: LD_VAR 0 4
134759: PPUSH
134760: CALL_OW 74
134764: PPUSH
134765: CALL_OW 296
134769: PUSH
134770: LD_INT 6
134772: LESS
134773: IFFALSE 134787
// SetFuel ( i , 100 ) ;
134775: LD_VAR 0 4
134779: PPUSH
134780: LD_INT 100
134782: PPUSH
134783: CALL_OW 240
// end else
134787: GO 134803
// ComAttackUnit ( i , e ) ;
134789: LD_VAR 0 4
134793: PPUSH
134794: LD_VAR 0 13
134798: PPUSH
134799: CALL_OW 115
// end else
134803: GO 134906
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
134805: LD_VAR 0 13
134809: PPUSH
134810: LD_EXP 124
134814: PUSH
134815: LD_VAR 0 1
134819: ARRAY
134820: PPUSH
134821: CALL_OW 308
134825: NOT
134826: PUSH
134827: LD_VAR 0 4
134831: PPUSH
134832: LD_VAR 0 13
134836: PPUSH
134837: CALL_OW 296
134841: PUSH
134842: LD_INT 40
134844: GREATEREQUAL
134845: AND
134846: PUSH
134847: LD_VAR 0 4
134851: PPUSH
134852: CALL_OW 256
134856: PUSH
134857: LD_INT 650
134859: LESSEQUAL
134860: OR
134861: PUSH
134862: LD_VAR 0 4
134866: PPUSH
134867: LD_EXP 123
134871: PUSH
134872: LD_VAR 0 1
134876: ARRAY
134877: PPUSH
134878: CALL_OW 308
134882: NOT
134883: AND
134884: IFFALSE 134906
// ComMoveToArea ( i , mc_parking [ base ] ) ;
134886: LD_VAR 0 4
134890: PPUSH
134891: LD_EXP 123
134895: PUSH
134896: LD_VAR 0 1
134900: ARRAY
134901: PPUSH
134902: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
134906: LD_VAR 0 4
134910: PPUSH
134911: CALL_OW 256
134915: PUSH
134916: LD_INT 1000
134918: LESS
134919: PUSH
134920: LD_VAR 0 4
134924: PPUSH
134925: CALL_OW 263
134929: PUSH
134930: LD_INT 1
134932: EQUAL
134933: AND
134934: PUSH
134935: LD_VAR 0 4
134939: PPUSH
134940: CALL_OW 311
134944: AND
134945: PUSH
134946: LD_VAR 0 4
134950: PPUSH
134951: LD_EXP 123
134955: PUSH
134956: LD_VAR 0 1
134960: ARRAY
134961: PPUSH
134962: CALL_OW 308
134966: AND
134967: IFFALSE 135021
// begin mech := IsDrivenBy ( i ) ;
134969: LD_ADDR_VAR 0 9
134973: PUSH
134974: LD_VAR 0 4
134978: PPUSH
134979: CALL_OW 311
134983: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
134984: LD_VAR 0 9
134988: PPUSH
134989: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
134993: LD_VAR 0 9
134997: PPUSH
134998: LD_VAR 0 4
135002: PPUSH
135003: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
135007: LD_VAR 0 9
135011: PPUSH
135012: LD_VAR 0 4
135016: PPUSH
135017: CALL_OW 180
// end ; end ; unit_human :
135021: GO 135368
135023: LD_INT 1
135025: DOUBLE
135026: EQUAL
135027: IFTRUE 135031
135029: GO 135367
135031: POP
// begin b := IsInUnit ( i ) ;
135032: LD_ADDR_VAR 0 18
135036: PUSH
135037: LD_VAR 0 4
135041: PPUSH
135042: CALL_OW 310
135046: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
135047: LD_ADDR_VAR 0 19
135051: PUSH
135052: LD_VAR 0 18
135056: NOT
135057: PUSH
135058: LD_VAR 0 18
135062: PPUSH
135063: CALL_OW 266
135067: PUSH
135068: LD_INT 32
135070: PUSH
135071: LD_INT 31
135073: PUSH
135074: EMPTY
135075: LIST
135076: LIST
135077: IN
135078: OR
135079: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
135080: LD_VAR 0 18
135084: PPUSH
135085: CALL_OW 266
135089: PUSH
135090: LD_INT 5
135092: EQUAL
135093: PUSH
135094: LD_VAR 0 4
135098: PPUSH
135099: CALL_OW 257
135103: PUSH
135104: LD_INT 1
135106: PUSH
135107: LD_INT 2
135109: PUSH
135110: LD_INT 3
135112: PUSH
135113: LD_INT 4
135115: PUSH
135116: EMPTY
135117: LIST
135118: LIST
135119: LIST
135120: LIST
135121: IN
135122: AND
135123: IFFALSE 135160
// begin class := AllowSpecClass ( i ) ;
135125: LD_ADDR_VAR 0 20
135129: PUSH
135130: LD_VAR 0 4
135134: PPUSH
135135: CALL 69121 0 1
135139: ST_TO_ADDR
// if class then
135140: LD_VAR 0 20
135144: IFFALSE 135160
// ComChangeProfession ( i , class ) ;
135146: LD_VAR 0 4
135150: PPUSH
135151: LD_VAR 0 20
135155: PPUSH
135156: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
135160: LD_VAR 0 16
135164: PUSH
135165: LD_VAR 0 2
135169: PPUSH
135170: LD_INT 21
135172: PUSH
135173: LD_INT 2
135175: PUSH
135176: EMPTY
135177: LIST
135178: LIST
135179: PPUSH
135180: CALL_OW 72
135184: PUSH
135185: LD_INT 1
135187: LESSEQUAL
135188: OR
135189: PUSH
135190: LD_VAR 0 19
135194: AND
135195: PUSH
135196: LD_VAR 0 4
135200: PUSH
135201: LD_VAR 0 17
135205: IN
135206: NOT
135207: AND
135208: IFFALSE 135301
// begin if b then
135210: LD_VAR 0 18
135214: IFFALSE 135263
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
135216: LD_VAR 0 18
135220: PPUSH
135221: LD_VAR 0 21
135225: PPUSH
135226: LD_VAR 0 18
135230: PPUSH
135231: CALL_OW 74
135235: PPUSH
135236: CALL_OW 296
135240: PUSH
135241: LD_INT 10
135243: LESS
135244: PUSH
135245: LD_VAR 0 18
135249: PPUSH
135250: CALL_OW 461
135254: PUSH
135255: LD_INT 7
135257: NONEQUAL
135258: AND
135259: IFFALSE 135263
// continue ;
135261: GO 134498
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
135263: LD_ADDR_VAR 0 17
135267: PUSH
135268: LD_VAR 0 17
135272: PPUSH
135273: LD_VAR 0 17
135277: PUSH
135278: LD_INT 1
135280: PLUS
135281: PPUSH
135282: LD_VAR 0 4
135286: PPUSH
135287: CALL_OW 1
135291: ST_TO_ADDR
// ComExitBuilding ( i ) ;
135292: LD_VAR 0 4
135296: PPUSH
135297: CALL_OW 122
// end ; if sold_defenders then
135301: LD_VAR 0 17
135305: IFFALSE 135365
// if i in sold_defenders then
135307: LD_VAR 0 4
135311: PUSH
135312: LD_VAR 0 17
135316: IN
135317: IFFALSE 135365
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
135319: LD_VAR 0 4
135323: PPUSH
135324: CALL_OW 314
135328: NOT
135329: PUSH
135330: LD_VAR 0 4
135334: PPUSH
135335: LD_VAR 0 13
135339: PPUSH
135340: CALL_OW 296
135344: PUSH
135345: LD_INT 30
135347: LESS
135348: AND
135349: IFFALSE 135365
// ComAttackUnit ( i , e ) ;
135351: LD_VAR 0 4
135355: PPUSH
135356: LD_VAR 0 13
135360: PPUSH
135361: CALL_OW 115
// end ; end ; end ;
135365: GO 135368
135367: POP
// if IsDead ( i ) then
135368: LD_VAR 0 4
135372: PPUSH
135373: CALL_OW 301
135377: IFFALSE 135395
// defenders := defenders diff i ;
135379: LD_ADDR_VAR 0 2
135383: PUSH
135384: LD_VAR 0 2
135388: PUSH
135389: LD_VAR 0 4
135393: DIFF
135394: ST_TO_ADDR
// end ;
135395: GO 134498
135397: POP
135398: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
135399: LD_VAR 0 21
135403: NOT
135404: PUSH
135405: LD_VAR 0 2
135409: NOT
135410: OR
135411: PUSH
135412: LD_EXP 99
135416: PUSH
135417: LD_VAR 0 1
135421: ARRAY
135422: NOT
135423: OR
135424: IFFALSE 134402
// MC_Reset ( base , 18 ) ;
135426: LD_VAR 0 1
135430: PPUSH
135431: LD_INT 18
135433: PPUSH
135434: CALL 40832 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
135438: LD_ADDR_VAR 0 2
135442: PUSH
135443: LD_VAR 0 2
135447: PUSH
135448: LD_VAR 0 2
135452: PPUSH
135453: LD_INT 2
135455: PUSH
135456: LD_INT 25
135458: PUSH
135459: LD_INT 1
135461: PUSH
135462: EMPTY
135463: LIST
135464: LIST
135465: PUSH
135466: LD_INT 25
135468: PUSH
135469: LD_INT 5
135471: PUSH
135472: EMPTY
135473: LIST
135474: LIST
135475: PUSH
135476: LD_INT 25
135478: PUSH
135479: LD_INT 8
135481: PUSH
135482: EMPTY
135483: LIST
135484: LIST
135485: PUSH
135486: LD_INT 25
135488: PUSH
135489: LD_INT 9
135491: PUSH
135492: EMPTY
135493: LIST
135494: LIST
135495: PUSH
135496: EMPTY
135497: LIST
135498: LIST
135499: LIST
135500: LIST
135501: LIST
135502: PPUSH
135503: CALL_OW 72
135507: DIFF
135508: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
135509: LD_VAR 0 21
135513: NOT
135514: PUSH
135515: LD_VAR 0 2
135519: PPUSH
135520: LD_INT 21
135522: PUSH
135523: LD_INT 2
135525: PUSH
135526: EMPTY
135527: LIST
135528: LIST
135529: PPUSH
135530: CALL_OW 72
135534: AND
135535: IFFALSE 135873
// begin tmp := FilterByTag ( defenders , 19 ) ;
135537: LD_ADDR_VAR 0 11
135541: PUSH
135542: LD_VAR 0 2
135546: PPUSH
135547: LD_INT 19
135549: PPUSH
135550: CALL 102358 0 2
135554: ST_TO_ADDR
// if tmp then
135555: LD_VAR 0 11
135559: IFFALSE 135629
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
135561: LD_ADDR_VAR 0 11
135565: PUSH
135566: LD_VAR 0 11
135570: PPUSH
135571: LD_INT 25
135573: PUSH
135574: LD_INT 3
135576: PUSH
135577: EMPTY
135578: LIST
135579: LIST
135580: PPUSH
135581: CALL_OW 72
135585: ST_TO_ADDR
// if tmp then
135586: LD_VAR 0 11
135590: IFFALSE 135629
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
135592: LD_ADDR_EXP 111
135596: PUSH
135597: LD_EXP 111
135601: PPUSH
135602: LD_VAR 0 1
135606: PPUSH
135607: LD_EXP 111
135611: PUSH
135612: LD_VAR 0 1
135616: ARRAY
135617: PUSH
135618: LD_VAR 0 11
135622: UNION
135623: PPUSH
135624: CALL_OW 1
135628: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
135629: LD_VAR 0 1
135633: PPUSH
135634: LD_INT 19
135636: PPUSH
135637: CALL 40832 0 2
// repeat wait ( 0 0$1 ) ;
135641: LD_INT 35
135643: PPUSH
135644: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
135648: LD_EXP 99
135652: PUSH
135653: LD_VAR 0 1
135657: ARRAY
135658: NOT
135659: PUSH
135660: LD_EXP 99
135664: PUSH
135665: LD_VAR 0 1
135669: ARRAY
135670: PUSH
135671: EMPTY
135672: EQUAL
135673: OR
135674: IFFALSE 135711
// begin for i in defenders do
135676: LD_ADDR_VAR 0 4
135680: PUSH
135681: LD_VAR 0 2
135685: PUSH
135686: FOR_IN
135687: IFFALSE 135700
// ComStop ( i ) ;
135689: LD_VAR 0 4
135693: PPUSH
135694: CALL_OW 141
135698: GO 135686
135700: POP
135701: POP
// defenders := [ ] ;
135702: LD_ADDR_VAR 0 2
135706: PUSH
135707: EMPTY
135708: ST_TO_ADDR
// exit ;
135709: GO 135937
// end ; for i in defenders do
135711: LD_ADDR_VAR 0 4
135715: PUSH
135716: LD_VAR 0 2
135720: PUSH
135721: FOR_IN
135722: IFFALSE 135811
// begin if not IsInArea ( i , mc_parking [ base ] ) then
135724: LD_VAR 0 4
135728: PPUSH
135729: LD_EXP 123
135733: PUSH
135734: LD_VAR 0 1
135738: ARRAY
135739: PPUSH
135740: CALL_OW 308
135744: NOT
135745: IFFALSE 135769
// ComMoveToArea ( i , mc_parking [ base ] ) else
135747: LD_VAR 0 4
135751: PPUSH
135752: LD_EXP 123
135756: PUSH
135757: LD_VAR 0 1
135761: ARRAY
135762: PPUSH
135763: CALL_OW 113
135767: GO 135809
// if GetControl ( i ) = control_manual then
135769: LD_VAR 0 4
135773: PPUSH
135774: CALL_OW 263
135778: PUSH
135779: LD_INT 1
135781: EQUAL
135782: IFFALSE 135809
// if IsDrivenBy ( i ) then
135784: LD_VAR 0 4
135788: PPUSH
135789: CALL_OW 311
135793: IFFALSE 135809
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
135795: LD_VAR 0 4
135799: PPUSH
135800: CALL_OW 311
135804: PPUSH
135805: CALL_OW 121
// end ;
135809: GO 135721
135811: POP
135812: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
135813: LD_VAR 0 2
135817: PPUSH
135818: LD_INT 95
135820: PUSH
135821: LD_EXP 123
135825: PUSH
135826: LD_VAR 0 1
135830: ARRAY
135831: PUSH
135832: EMPTY
135833: LIST
135834: LIST
135835: PPUSH
135836: CALL_OW 72
135840: PUSH
135841: LD_VAR 0 2
135845: EQUAL
135846: PUSH
135847: LD_EXP 122
135851: PUSH
135852: LD_VAR 0 1
135856: ARRAY
135857: OR
135858: PUSH
135859: LD_EXP 99
135863: PUSH
135864: LD_VAR 0 1
135868: ARRAY
135869: NOT
135870: OR
135871: IFFALSE 135641
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
135873: LD_ADDR_EXP 121
135877: PUSH
135878: LD_EXP 121
135882: PPUSH
135883: LD_VAR 0 1
135887: PPUSH
135888: LD_VAR 0 2
135892: PPUSH
135893: LD_INT 21
135895: PUSH
135896: LD_INT 2
135898: PUSH
135899: EMPTY
135900: LIST
135901: LIST
135902: PPUSH
135903: CALL_OW 72
135907: PPUSH
135908: CALL_OW 1
135912: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
135913: LD_VAR 0 1
135917: PPUSH
135918: LD_INT 19
135920: PPUSH
135921: CALL 40832 0 2
// MC_Reset ( base , 20 ) ;
135925: LD_VAR 0 1
135929: PPUSH
135930: LD_INT 20
135932: PPUSH
135933: CALL 40832 0 2
// end ; end_of_file
135937: LD_VAR 0 3
135941: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
135942: LD_VAR 0 1
135946: PUSH
135947: LD_INT 200
135949: DOUBLE
135950: GREATEREQUAL
135951: IFFALSE 135959
135953: LD_INT 299
135955: DOUBLE
135956: LESSEQUAL
135957: IFTRUE 135961
135959: GO 135993
135961: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
135962: LD_VAR 0 1
135966: PPUSH
135967: LD_VAR 0 2
135971: PPUSH
135972: LD_VAR 0 3
135976: PPUSH
135977: LD_VAR 0 4
135981: PPUSH
135982: LD_VAR 0 5
135986: PPUSH
135987: CALL 124728 0 5
135991: GO 136070
135993: LD_INT 300
135995: DOUBLE
135996: GREATEREQUAL
135997: IFFALSE 136005
135999: LD_INT 399
136001: DOUBLE
136002: LESSEQUAL
136003: IFTRUE 136007
136005: GO 136069
136007: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
136008: LD_VAR 0 1
136012: PPUSH
136013: LD_VAR 0 2
136017: PPUSH
136018: LD_VAR 0 3
136022: PPUSH
136023: LD_VAR 0 4
136027: PPUSH
136028: LD_VAR 0 5
136032: PPUSH
136033: LD_VAR 0 6
136037: PPUSH
136038: LD_VAR 0 7
136042: PPUSH
136043: LD_VAR 0 8
136047: PPUSH
136048: LD_VAR 0 9
136052: PPUSH
136053: LD_VAR 0 10
136057: PPUSH
136058: LD_VAR 0 11
136062: PPUSH
136063: CALL 121061 0 11
136067: GO 136070
136069: POP
// end ;
136070: PPOPN 11
136072: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
136073: LD_VAR 0 1
136077: PPUSH
136078: LD_VAR 0 2
136082: PPUSH
136083: LD_VAR 0 3
136087: PPUSH
136088: LD_VAR 0 4
136092: PPUSH
136093: LD_VAR 0 5
136097: PPUSH
136098: CALL 124464 0 5
// end ; end_of_file
136102: PPOPN 5
136104: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
136105: LD_VAR 0 1
136109: PPUSH
136110: LD_VAR 0 2
136114: PPUSH
136115: LD_VAR 0 3
136119: PPUSH
136120: LD_VAR 0 4
136124: PPUSH
136125: LD_VAR 0 5
136129: PPUSH
136130: LD_VAR 0 6
136134: PPUSH
136135: CALL 108754 0 6
// end ;
136139: PPOPN 6
136141: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
136142: LD_INT 0
136144: PPUSH
// begin if not units then
136145: LD_VAR 0 1
136149: NOT
136150: IFFALSE 136154
// exit ;
136152: GO 136154
// end ;
136154: PPOPN 7
136156: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
136157: CALL 108725 0 0
// end ;
136161: PPOPN 1
136163: END
