// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 39564 0 0
// InitNature ;
  19: CALL 39432 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 12660 0 0
// PrepareRussian ;
  40: CALL 7610 0 0
// PrepareLegion ;
  44: CALL 4678 0 0
// PreparePowell ;
  48: CALL 3212 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 17590 0 0
// MC_Start ( ) ;
  60: CALL 41744 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 126
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 127
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 64540 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 64633 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 63983 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 3
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 3
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 63798 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 64540 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 64633 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 63798 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 63983 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 64413 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 63461 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 64540 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 64633 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 131
 971: PUSH
 972: LD_EXP 131
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 63798 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 64540 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 64633 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 63690 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 64951 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 64122 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 64413 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 64413 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 64745 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 63798 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 64364 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker , Mike , DeltaDoctor ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 70272 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1942
// PrepareVehicle ( [ us_morphling , us_morphling , us_medium_tracked , us_medium_tracked ] [ Difficulty ] , engine_siberite , control_manual , [ us_laser , us_laser , us_double_gun , us_double_gun ] [ Difficulty ] , 100 ) else
1879: LD_INT 5
1881: PUSH
1882: LD_INT 5
1884: PUSH
1885: LD_INT 3
1887: PUSH
1888: LD_INT 3
1890: PUSH
1891: EMPTY
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: PUSH
1897: LD_OWVAR 67
1901: ARRAY
1902: PPUSH
1903: LD_INT 3
1905: PPUSH
1906: LD_INT 1
1908: PPUSH
1909: LD_INT 9
1911: PUSH
1912: LD_INT 9
1914: PUSH
1915: LD_INT 5
1917: PUSH
1918: LD_INT 5
1920: PUSH
1921: EMPTY
1922: LIST
1923: LIST
1924: LIST
1925: LIST
1926: PUSH
1927: LD_OWVAR 67
1931: ARRAY
1932: PPUSH
1933: LD_INT 100
1935: PPUSH
1936: CALL 75112 0 5
1940: GO 2001
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1942: LD_EXP 4
1946: PUSH
1947: LD_INT 1
1949: ARRAY
1950: PUSH
1951: LD_INT 1
1953: ARRAY
1954: PPUSH
1955: LD_EXP 4
1959: PUSH
1960: LD_INT 2
1962: ARRAY
1963: PUSH
1964: LD_INT 1
1966: ARRAY
1967: PPUSH
1968: LD_EXP 4
1972: PUSH
1973: LD_INT 3
1975: ARRAY
1976: PUSH
1977: LD_INT 1
1979: ARRAY
1980: PPUSH
1981: LD_EXP 4
1985: PUSH
1986: LD_INT 4
1988: ARRAY
1989: PUSH
1990: LD_INT 1
1992: ARRAY
1993: PPUSH
1994: LD_INT 30
1996: PPUSH
1997: CALL 75112 0 5
// JMMNewVeh := CreateVehicle ;
2001: LD_ADDR_EXP 59
2005: PUSH
2006: CALL_OW 45
2010: ST_TO_ADDR
// if not JMMNewVeh then
2011: LD_EXP 59
2015: NOT
2016: IFFALSE 2047
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
2018: LD_INT 5
2020: PPUSH
2021: LD_INT 3
2023: PPUSH
2024: LD_INT 1
2026: PPUSH
2027: LD_INT 9
2029: PPUSH
2030: LD_INT 100
2032: PPUSH
2033: CALL 75112 0 5
// JMMNewVeh := CreateVehicle ;
2037: LD_ADDR_EXP 59
2041: PUSH
2042: CALL_OW 45
2046: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2047: LD_EXP 59
2051: PPUSH
2052: LD_INT 4
2054: PPUSH
2055: CALL_OW 233
// SetMark ( JMMNewVeh , - 1 ) ;
2059: LD_EXP 59
2063: PPUSH
2064: LD_INT 1
2066: NEG
2067: PPUSH
2068: CALL_OW 242
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2072: LD_EXP 59
2076: PPUSH
2077: LD_INT 79
2079: PPUSH
2080: LD_INT 91
2082: PPUSH
2083: LD_INT 0
2085: PPUSH
2086: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2090: LD_EXP 40
2094: PPUSH
2095: LD_EXP 59
2099: PPUSH
2100: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2104: LD_EXP 6
2108: PUSH
2109: LD_EXP 2
2113: NOT
2114: AND
2115: IFFALSE 2373
// begin if not JMMGirlVeh then
2117: LD_EXP 5
2121: NOT
2122: IFFALSE 2145
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2124: LD_INT 3
2126: PPUSH
2127: LD_INT 3
2129: PPUSH
2130: LD_INT 1
2132: PPUSH
2133: LD_INT 9
2135: PPUSH
2136: LD_INT 100
2138: PPUSH
2139: CALL 75112 0 5
2143: GO 2204
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2145: LD_EXP 5
2149: PUSH
2150: LD_INT 1
2152: ARRAY
2153: PUSH
2154: LD_INT 1
2156: ARRAY
2157: PPUSH
2158: LD_EXP 5
2162: PUSH
2163: LD_INT 2
2165: ARRAY
2166: PUSH
2167: LD_INT 1
2169: ARRAY
2170: PPUSH
2171: LD_EXP 5
2175: PUSH
2176: LD_INT 3
2178: ARRAY
2179: PUSH
2180: LD_INT 1
2182: ARRAY
2183: PPUSH
2184: LD_EXP 5
2188: PUSH
2189: LD_INT 4
2191: ARRAY
2192: PUSH
2193: LD_INT 1
2195: ARRAY
2196: PPUSH
2197: LD_INT 30
2199: PPUSH
2200: CALL 75112 0 5
// GirlNewVeh := CreateVehicle ;
2204: LD_ADDR_EXP 60
2208: PUSH
2209: CALL_OW 45
2213: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2214: LD_EXP 60
2218: PPUSH
2219: LD_INT 4
2221: PPUSH
2222: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2226: LD_EXP 60
2230: PPUSH
2231: LD_INT 82
2233: PPUSH
2234: LD_INT 96
2236: PPUSH
2237: LD_INT 0
2239: PPUSH
2240: CALL_OW 48
// if JMMGirl = 1 then
2244: LD_EXP 7
2248: PUSH
2249: LD_INT 1
2251: EQUAL
2252: IFFALSE 2287
// begin Joan := PrepareUnit ( Joan , true , 14_ ) ;
2254: LD_ADDR_EXP 41
2258: PUSH
2259: LD_STRING Joan
2261: PPUSH
2262: LD_INT 1
2264: PPUSH
2265: LD_STRING 14_
2267: PPUSH
2268: CALL 70272 0 3
2272: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2273: LD_EXP 41
2277: PPUSH
2278: LD_EXP 60
2282: PPUSH
2283: CALL_OW 52
// end ; if JMMGirl = 2 then
2287: LD_EXP 7
2291: PUSH
2292: LD_INT 2
2294: EQUAL
2295: IFFALSE 2330
// begin Lisa := PrepareUnit ( Lisa , true , 14_ ) ;
2297: LD_ADDR_EXP 43
2301: PUSH
2302: LD_STRING Lisa
2304: PPUSH
2305: LD_INT 1
2307: PPUSH
2308: LD_STRING 14_
2310: PPUSH
2311: CALL 70272 0 3
2315: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2316: LD_EXP 43
2320: PPUSH
2321: LD_EXP 60
2325: PPUSH
2326: CALL_OW 52
// end ; if JMMGirl = 3 then
2330: LD_EXP 7
2334: PUSH
2335: LD_INT 3
2337: EQUAL
2338: IFFALSE 2373
// begin Connie := PrepareUnit ( Connie , true , 14_ ) ;
2340: LD_ADDR_EXP 55
2344: PUSH
2345: LD_STRING Connie
2347: PPUSH
2348: LD_INT 1
2350: PPUSH
2351: LD_STRING 14_
2353: PPUSH
2354: CALL 70272 0 3
2358: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2359: LD_EXP 55
2363: PPUSH
2364: LD_EXP 60
2368: PPUSH
2369: CALL_OW 52
// end ; end ; end ;
2373: LD_VAR 0 1
2377: RET
// export function PrepareStevensSquad ; var tmp ; begin
2378: LD_INT 0
2380: PPUSH
2381: PPUSH
// uc_side := 1 ;
2382: LD_ADDR_OWVAR 20
2386: PUSH
2387: LD_INT 1
2389: ST_TO_ADDR
// uc_nation := 1 ;
2390: LD_ADDR_OWVAR 21
2394: PUSH
2395: LD_INT 1
2397: ST_TO_ADDR
// tmp := [ ] ;
2398: LD_ADDR_VAR 0 2
2402: PUSH
2403: EMPTY
2404: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2405: LD_ADDR_EXP 42
2409: PUSH
2410: LD_STRING Stevens
2412: PPUSH
2413: LD_EXP 1
2417: NOT
2418: PPUSH
2419: LD_STRING 13f_
2421: PPUSH
2422: CALL 70272 0 3
2426: ST_TO_ADDR
// if not Stevens then
2427: LD_EXP 42
2431: NOT
2432: IFFALSE 2546
// begin hc_name = Baker Smith ;
2434: LD_ADDR_OWVAR 26
2438: PUSH
2439: LD_STRING Baker Smith
2441: ST_TO_ADDR
// hc_gallery = us ;
2442: LD_ADDR_OWVAR 33
2446: PUSH
2447: LD_STRING us
2449: ST_TO_ADDR
// hc_face_number := 29 ;
2450: LD_ADDR_OWVAR 34
2454: PUSH
2455: LD_INT 29
2457: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2458: LD_INT 1
2460: PPUSH
2461: LD_INT 10
2463: PPUSH
2464: CALL_OW 384
// hc_basic_skills := [ 2 , 2 , 0 , 2 ] ;
2468: LD_ADDR_OWVAR 30
2472: PUSH
2473: LD_INT 2
2475: PUSH
2476: LD_INT 2
2478: PUSH
2479: LD_INT 0
2481: PUSH
2482: LD_INT 2
2484: PUSH
2485: EMPTY
2486: LIST
2487: LIST
2488: LIST
2489: LIST
2490: ST_TO_ADDR
// hc_skills := [ 4 , 5 , 2 , 10 ] ;
2491: LD_ADDR_OWVAR 31
2495: PUSH
2496: LD_INT 4
2498: PUSH
2499: LD_INT 5
2501: PUSH
2502: LD_INT 2
2504: PUSH
2505: LD_INT 10
2507: PUSH
2508: EMPTY
2509: LIST
2510: LIST
2511: LIST
2512: LIST
2513: ST_TO_ADDR
// Baker := CreateHuman ;
2514: LD_ADDR_EXP 56
2518: PUSH
2519: CALL_OW 44
2523: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2524: LD_ADDR_VAR 0 2
2528: PUSH
2529: LD_VAR 0 2
2533: PUSH
2534: LD_EXP 56
2538: ADD
2539: ST_TO_ADDR
// InitHc ;
2540: CALL_OW 19
// end else
2544: GO 2562
// tmp := tmp ^ Stevens ;
2546: LD_ADDR_VAR 0 2
2550: PUSH
2551: LD_VAR 0 2
2555: PUSH
2556: LD_EXP 42
2560: ADD
2561: ST_TO_ADDR
// if not Lisa then
2562: LD_EXP 43
2566: NOT
2567: IFFALSE 2613
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2569: LD_ADDR_EXP 43
2573: PUSH
2574: LD_STRING Lisa
2576: PPUSH
2577: LD_EXP 1
2581: NOT
2582: PPUSH
2583: LD_STRING 13f_
2585: PPUSH
2586: CALL 70272 0 3
2590: ST_TO_ADDR
// if Lisa then
2591: LD_EXP 43
2595: IFFALSE 2613
// tmp := tmp ^ Lisa ;
2597: LD_ADDR_VAR 0 2
2601: PUSH
2602: LD_VAR 0 2
2606: PUSH
2607: LD_EXP 43
2611: ADD
2612: ST_TO_ADDR
// end ; if not Donaldson then
2613: LD_EXP 44
2617: NOT
2618: IFFALSE 2664
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2620: LD_ADDR_EXP 44
2624: PUSH
2625: LD_STRING Donaldson
2627: PPUSH
2628: LD_EXP 1
2632: NOT
2633: PPUSH
2634: LD_STRING 13f_
2636: PPUSH
2637: CALL 70272 0 3
2641: ST_TO_ADDR
// if Donaldson then
2642: LD_EXP 44
2646: IFFALSE 2664
// tmp := tmp ^ Donaldson ;
2648: LD_ADDR_VAR 0 2
2652: PUSH
2653: LD_VAR 0 2
2657: PUSH
2658: LD_EXP 44
2662: ADD
2663: ST_TO_ADDR
// end ; if not Bobby then
2664: LD_EXP 45
2668: NOT
2669: IFFALSE 2715
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2671: LD_ADDR_EXP 45
2675: PUSH
2676: LD_STRING Bobby
2678: PPUSH
2679: LD_EXP 1
2683: NOT
2684: PPUSH
2685: LD_STRING 13f_
2687: PPUSH
2688: CALL 70272 0 3
2692: ST_TO_ADDR
// if Bobby then
2693: LD_EXP 45
2697: IFFALSE 2715
// tmp := tmp ^ Bobby ;
2699: LD_ADDR_VAR 0 2
2703: PUSH
2704: LD_VAR 0 2
2708: PUSH
2709: LD_EXP 45
2713: ADD
2714: ST_TO_ADDR
// end ; if not Cyrus then
2715: LD_EXP 46
2719: NOT
2720: IFFALSE 2766
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2722: LD_ADDR_EXP 46
2726: PUSH
2727: LD_STRING Cyrus
2729: PPUSH
2730: LD_EXP 1
2734: NOT
2735: PPUSH
2736: LD_STRING 13f_
2738: PPUSH
2739: CALL 70272 0 3
2743: ST_TO_ADDR
// if Cyrus then
2744: LD_EXP 46
2748: IFFALSE 2766
// tmp := tmp ^ Cyrus ;
2750: LD_ADDR_VAR 0 2
2754: PUSH
2755: LD_VAR 0 2
2759: PUSH
2760: LD_EXP 46
2764: ADD
2765: ST_TO_ADDR
// end ; if not Brown then
2766: LD_EXP 48
2770: NOT
2771: IFFALSE 2817
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2773: LD_ADDR_EXP 48
2777: PUSH
2778: LD_STRING Brown
2780: PPUSH
2781: LD_EXP 1
2785: NOT
2786: PPUSH
2787: LD_STRING 13f_
2789: PPUSH
2790: CALL 70272 0 3
2794: ST_TO_ADDR
// if Brown then
2795: LD_EXP 48
2799: IFFALSE 2817
// tmp := tmp ^ Brown ;
2801: LD_ADDR_VAR 0 2
2805: PUSH
2806: LD_VAR 0 2
2810: PUSH
2811: LD_EXP 48
2815: ADD
2816: ST_TO_ADDR
// end ; if not Gladstone then
2817: LD_EXP 49
2821: NOT
2822: IFFALSE 2868
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2824: LD_ADDR_EXP 49
2828: PUSH
2829: LD_STRING Gladstone
2831: PPUSH
2832: LD_EXP 1
2836: NOT
2837: PPUSH
2838: LD_STRING 13f_
2840: PPUSH
2841: CALL 70272 0 3
2845: ST_TO_ADDR
// if Gladstone then
2846: LD_EXP 49
2850: IFFALSE 2868
// tmp := tmp ^ Gladstone ;
2852: LD_ADDR_VAR 0 2
2856: PUSH
2857: LD_VAR 0 2
2861: PUSH
2862: LD_EXP 49
2866: ADD
2867: ST_TO_ADDR
// end ; if not Houten then
2868: LD_EXP 50
2872: NOT
2873: IFFALSE 2919
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2875: LD_ADDR_EXP 50
2879: PUSH
2880: LD_STRING Houten
2882: PPUSH
2883: LD_EXP 1
2887: NOT
2888: PPUSH
2889: LD_STRING 13f_
2891: PPUSH
2892: CALL 70272 0 3
2896: ST_TO_ADDR
// if Houten then
2897: LD_EXP 50
2901: IFFALSE 2919
// tmp := tmp ^ Houten ;
2903: LD_ADDR_VAR 0 2
2907: PUSH
2908: LD_VAR 0 2
2912: PUSH
2913: LD_EXP 50
2917: ADD
2918: ST_TO_ADDR
// end ; if not Cornel then
2919: LD_EXP 51
2923: NOT
2924: IFFALSE 2970
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2926: LD_ADDR_EXP 51
2930: PUSH
2931: LD_STRING Cornell
2933: PPUSH
2934: LD_EXP 1
2938: NOT
2939: PPUSH
2940: LD_STRING 13f_
2942: PPUSH
2943: CALL 70272 0 3
2947: ST_TO_ADDR
// if Cornel then
2948: LD_EXP 51
2952: IFFALSE 2970
// tmp := tmp ^ Cornel ;
2954: LD_ADDR_VAR 0 2
2958: PUSH
2959: LD_VAR 0 2
2963: PUSH
2964: LD_EXP 51
2968: ADD
2969: ST_TO_ADDR
// end ; if not Gary then
2970: LD_EXP 52
2974: NOT
2975: IFFALSE 3021
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2977: LD_ADDR_EXP 52
2981: PUSH
2982: LD_STRING Gary
2984: PPUSH
2985: LD_EXP 1
2989: NOT
2990: PPUSH
2991: LD_STRING 13f_
2993: PPUSH
2994: CALL 70272 0 3
2998: ST_TO_ADDR
// if Gary then
2999: LD_EXP 52
3003: IFFALSE 3021
// tmp := tmp ^ Gary ;
3005: LD_ADDR_VAR 0 2
3009: PUSH
3010: LD_VAR 0 2
3014: PUSH
3015: LD_EXP 52
3019: ADD
3020: ST_TO_ADDR
// end ; if not Frank then
3021: LD_EXP 53
3025: NOT
3026: IFFALSE 3072
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
3028: LD_ADDR_EXP 53
3032: PUSH
3033: LD_STRING Frank
3035: PPUSH
3036: LD_EXP 1
3040: NOT
3041: PPUSH
3042: LD_STRING 13f_
3044: PPUSH
3045: CALL 70272 0 3
3049: ST_TO_ADDR
// if Frank then
3050: LD_EXP 53
3054: IFFALSE 3072
// tmp := tmp ^ Frank ;
3056: LD_ADDR_VAR 0 2
3060: PUSH
3061: LD_VAR 0 2
3065: PUSH
3066: LD_EXP 53
3070: ADD
3071: ST_TO_ADDR
// end ; if not Kikuchi then
3072: LD_EXP 54
3076: NOT
3077: IFFALSE 3123
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
3079: LD_ADDR_EXP 54
3083: PUSH
3084: LD_STRING Kikuchi
3086: PPUSH
3087: LD_EXP 1
3091: NOT
3092: PPUSH
3093: LD_STRING 13f_
3095: PPUSH
3096: CALL 70272 0 3
3100: ST_TO_ADDR
// if Kikuchi then
3101: LD_EXP 54
3105: IFFALSE 3123
// tmp := tmp ^ Kikuchi ;
3107: LD_ADDR_VAR 0 2
3111: PUSH
3112: LD_VAR 0 2
3116: PUSH
3117: LD_EXP 54
3121: ADD
3122: ST_TO_ADDR
// end ; if not DeltaDoctor then
3123: LD_EXP 58
3127: NOT
3128: IFFALSE 3174
// begin DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13f_ ) ;
3130: LD_ADDR_EXP 58
3134: PUSH
3135: LD_STRING DeltaDoctor
3137: PPUSH
3138: LD_EXP 1
3142: NOT
3143: PPUSH
3144: LD_STRING 13f_
3146: PPUSH
3147: CALL 70272 0 3
3151: ST_TO_ADDR
// if Bobby then
3152: LD_EXP 45
3156: IFFALSE 3174
// tmp := tmp ^ DeltaDoctor ;
3158: LD_ADDR_VAR 0 2
3162: PUSH
3163: LD_VAR 0 2
3167: PUSH
3168: LD_EXP 58
3172: ADD
3173: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3174: LD_ADDR_VAR 0 2
3178: PUSH
3179: LD_VAR 0 2
3183: PUSH
3184: LD_STRING 13_other_survivors
3186: PPUSH
3187: CALL_OW 31
3191: UNION
3192: ST_TO_ADDR
// result := tmp diff 0 ;
3193: LD_ADDR_VAR 0 1
3197: PUSH
3198: LD_VAR 0 2
3202: PUSH
3203: LD_INT 0
3205: DIFF
3206: ST_TO_ADDR
// end ; end_of_file
3207: LD_VAR 0 1
3211: RET
// export Powell ; export vip , extraSquad ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3212: LD_INT 0
3214: PPUSH
3215: PPUSH
3216: PPUSH
3217: PPUSH
3218: PPUSH
3219: PPUSH
3220: PPUSH
3221: PPUSH
3222: PPUSH
3223: PPUSH
// uc_side := 4 ;
3224: LD_ADDR_OWVAR 20
3228: PUSH
3229: LD_INT 4
3231: ST_TO_ADDR
// uc_nation := 1 ;
3232: LD_ADDR_OWVAR 21
3236: PUSH
3237: LD_INT 1
3239: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3240: LD_INT 387
3242: PPUSH
3243: CALL_OW 274
3247: PPUSH
3248: LD_INT 1
3250: PPUSH
3251: LD_INT 3500
3253: PUSH
3254: LD_INT 3000
3256: PUSH
3257: LD_INT 2500
3259: PUSH
3260: LD_INT 2000
3262: PUSH
3263: EMPTY
3264: LIST
3265: LIST
3266: LIST
3267: LIST
3268: PUSH
3269: LD_OWVAR 67
3273: ARRAY
3274: PPUSH
3275: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3279: LD_INT 387
3281: PPUSH
3282: CALL_OW 274
3286: PPUSH
3287: LD_INT 2
3289: PPUSH
3290: LD_INT 400
3292: PPUSH
3293: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3297: LD_INT 387
3299: PPUSH
3300: CALL_OW 274
3304: PPUSH
3305: LD_INT 3
3307: PPUSH
3308: LD_INT 10
3310: PPUSH
3311: CALL_OW 277
// SetBName ( am_depot , sigma ) ;
3315: LD_INT 387
3317: PPUSH
3318: LD_STRING sigma
3320: PPUSH
3321: CALL_OW 500
// Powell := NewCharacter ( Powell ) ;
3325: LD_ADDR_EXP 61
3329: PUSH
3330: LD_STRING Powell
3332: PPUSH
3333: CALL_OW 25
3337: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3338: LD_EXP 61
3342: PPUSH
3343: LD_INT 57
3345: PPUSH
3346: LD_INT 94
3348: PPUSH
3349: LD_INT 0
3351: PPUSH
3352: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3356: LD_EXP 61
3360: PPUSH
3361: LD_INT 58
3363: PPUSH
3364: LD_INT 94
3366: PPUSH
3367: CALL_OW 118
// vip := [ ] ;
3371: LD_ADDR_EXP 62
3375: PUSH
3376: EMPTY
3377: ST_TO_ADDR
// extraSquad := [ ] ;
3378: LD_ADDR_EXP 63
3382: PUSH
3383: EMPTY
3384: ST_TO_ADDR
// tmp := [ ] ;
3385: LD_ADDR_VAR 0 5
3389: PUSH
3390: EMPTY
3391: ST_TO_ADDR
// if JMMGirl <> 2 then
3392: LD_EXP 7
3396: PUSH
3397: LD_INT 2
3399: NONEQUAL
3400: IFFALSE 3424
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3402: LD_ADDR_EXP 43
3406: PUSH
3407: LD_STRING Lisa
3409: PPUSH
3410: LD_EXP 1
3414: NOT
3415: PPUSH
3416: LD_STRING 13s_
3418: PPUSH
3419: CALL 70272 0 3
3423: ST_TO_ADDR
// if Lisa then
3424: LD_EXP 43
3428: IFFALSE 3446
// tmp := tmp ^ Lisa ;
3430: LD_ADDR_VAR 0 5
3434: PUSH
3435: LD_VAR 0 5
3439: PUSH
3440: LD_EXP 43
3444: ADD
3445: ST_TO_ADDR
// if JMMGirl < 3 then
3446: LD_EXP 7
3450: PUSH
3451: LD_INT 3
3453: LESS
3454: IFFALSE 3485
// begin Connie := NewCharacter ( Coonie ) ;
3456: LD_ADDR_EXP 55
3460: PUSH
3461: LD_STRING Coonie
3463: PPUSH
3464: CALL_OW 25
3468: ST_TO_ADDR
// tmp := tmp ^ Connie ;
3469: LD_ADDR_VAR 0 5
3473: PUSH
3474: LD_VAR 0 5
3478: PUSH
3479: LD_EXP 55
3483: ADD
3484: ST_TO_ADDR
// end ; Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3485: LD_ADDR_EXP 44
3489: PUSH
3490: LD_STRING Donaldson
3492: PPUSH
3493: LD_EXP 1
3497: NOT
3498: PPUSH
3499: LD_STRING 13s_
3501: PPUSH
3502: CALL 70272 0 3
3506: ST_TO_ADDR
// if Donaldson then
3507: LD_EXP 44
3511: IFFALSE 3529
// tmp := tmp ^ Donaldson ;
3513: LD_ADDR_VAR 0 5
3517: PUSH
3518: LD_VAR 0 5
3522: PUSH
3523: LD_EXP 44
3527: ADD
3528: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3529: LD_ADDR_EXP 45
3533: PUSH
3534: LD_STRING Bobby
3536: PPUSH
3537: LD_EXP 1
3541: NOT
3542: PPUSH
3543: LD_STRING 13s_
3545: PPUSH
3546: CALL 70272 0 3
3550: ST_TO_ADDR
// if Bobby then
3551: LD_EXP 45
3555: IFFALSE 3573
// tmp := tmp ^ Bobby ;
3557: LD_ADDR_VAR 0 5
3561: PUSH
3562: LD_VAR 0 5
3566: PUSH
3567: LD_EXP 45
3571: ADD
3572: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3573: LD_ADDR_EXP 46
3577: PUSH
3578: LD_STRING Cyrus
3580: PPUSH
3581: LD_EXP 1
3585: NOT
3586: PPUSH
3587: LD_STRING 13s_
3589: PPUSH
3590: CALL 70272 0 3
3594: ST_TO_ADDR
// if Cyrus then
3595: LD_EXP 46
3599: IFFALSE 3617
// tmp := tmp ^ Cyrus ;
3601: LD_ADDR_VAR 0 5
3605: PUSH
3606: LD_VAR 0 5
3610: PUSH
3611: LD_EXP 46
3615: ADD
3616: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3617: LD_ADDR_EXP 47
3621: PUSH
3622: LD_STRING Denis
3624: PPUSH
3625: LD_EXP 1
3629: NOT
3630: PPUSH
3631: LD_STRING 13s_
3633: PPUSH
3634: CALL 70272 0 3
3638: ST_TO_ADDR
// if not Denis then
3639: LD_EXP 47
3643: NOT
3644: IFFALSE 3668
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3646: LD_ADDR_EXP 47
3650: PUSH
3651: LD_STRING Denis
3653: PPUSH
3654: LD_EXP 1
3658: NOT
3659: PPUSH
3660: LD_STRING 13f_
3662: PPUSH
3663: CALL 70272 0 3
3667: ST_TO_ADDR
// if Denis then
3668: LD_EXP 47
3672: IFFALSE 3690
// tmp := tmp ^ Denis ;
3674: LD_ADDR_VAR 0 5
3678: PUSH
3679: LD_VAR 0 5
3683: PUSH
3684: LD_EXP 47
3688: ADD
3689: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3690: LD_ADDR_EXP 48
3694: PUSH
3695: LD_STRING Brown
3697: PPUSH
3698: LD_EXP 1
3702: NOT
3703: PPUSH
3704: LD_STRING 13s_
3706: PPUSH
3707: CALL 70272 0 3
3711: ST_TO_ADDR
// if Brown then
3712: LD_EXP 48
3716: IFFALSE 3734
// tmp := tmp ^ Brown ;
3718: LD_ADDR_VAR 0 5
3722: PUSH
3723: LD_VAR 0 5
3727: PUSH
3728: LD_EXP 48
3732: ADD
3733: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3734: LD_ADDR_EXP 49
3738: PUSH
3739: LD_STRING Gladstone
3741: PPUSH
3742: LD_EXP 1
3746: NOT
3747: PPUSH
3748: LD_STRING 13s_
3750: PPUSH
3751: CALL 70272 0 3
3755: ST_TO_ADDR
// if Gladstone then
3756: LD_EXP 49
3760: IFFALSE 3778
// tmp := tmp ^ Gladstone ;
3762: LD_ADDR_VAR 0 5
3766: PUSH
3767: LD_VAR 0 5
3771: PUSH
3772: LD_EXP 49
3776: ADD
3777: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3778: LD_ADDR_EXP 50
3782: PUSH
3783: LD_STRING Houten
3785: PPUSH
3786: LD_EXP 1
3790: NOT
3791: PPUSH
3792: LD_STRING 13s_
3794: PPUSH
3795: CALL 70272 0 3
3799: ST_TO_ADDR
// if Houten then
3800: LD_EXP 50
3804: IFFALSE 3822
// tmp := tmp ^ Houten ;
3806: LD_ADDR_VAR 0 5
3810: PUSH
3811: LD_VAR 0 5
3815: PUSH
3816: LD_EXP 50
3820: ADD
3821: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3822: LD_ADDR_EXP 51
3826: PUSH
3827: LD_STRING Cornel
3829: PPUSH
3830: LD_EXP 1
3834: NOT
3835: PPUSH
3836: LD_STRING 13s_
3838: PPUSH
3839: CALL 70272 0 3
3843: ST_TO_ADDR
// if Cornel then
3844: LD_EXP 51
3848: IFFALSE 3866
// tmp := tmp ^ Cornel ;
3850: LD_ADDR_VAR 0 5
3854: PUSH
3855: LD_VAR 0 5
3859: PUSH
3860: LD_EXP 51
3864: ADD
3865: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3866: LD_ADDR_EXP 52
3870: PUSH
3871: LD_STRING Gary
3873: PPUSH
3874: LD_EXP 1
3878: NOT
3879: PPUSH
3880: LD_STRING 13s_
3882: PPUSH
3883: CALL 70272 0 3
3887: ST_TO_ADDR
// if Gary then
3888: LD_EXP 52
3892: IFFALSE 3910
// tmp := tmp ^ Gary ;
3894: LD_ADDR_VAR 0 5
3898: PUSH
3899: LD_VAR 0 5
3903: PUSH
3904: LD_EXP 52
3908: ADD
3909: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3910: LD_ADDR_EXP 53
3914: PUSH
3915: LD_STRING Frank
3917: PPUSH
3918: LD_EXP 1
3922: NOT
3923: PPUSH
3924: LD_STRING 13s_
3926: PPUSH
3927: CALL 70272 0 3
3931: ST_TO_ADDR
// if Frank then
3932: LD_EXP 53
3936: IFFALSE 3954
// tmp := tmp ^ Frank ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_VAR 0 5
3947: PUSH
3948: LD_EXP 53
3952: ADD
3953: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3954: LD_ADDR_EXP 54
3958: PUSH
3959: LD_STRING Kikuchi
3961: PPUSH
3962: LD_EXP 1
3966: NOT
3967: PPUSH
3968: LD_STRING 13s_
3970: PPUSH
3971: CALL 70272 0 3
3975: ST_TO_ADDR
// if Kikuchi then
3976: LD_EXP 54
3980: IFFALSE 3998
// tmp := tmp ^ Kikuchi ;
3982: LD_ADDR_VAR 0 5
3986: PUSH
3987: LD_VAR 0 5
3991: PUSH
3992: LD_EXP 54
3996: ADD
3997: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13s_ ) ;
3998: LD_ADDR_EXP 58
4002: PUSH
4003: LD_STRING DeltaDoctor
4005: PPUSH
4006: LD_EXP 1
4010: NOT
4011: PPUSH
4012: LD_STRING 13s_
4014: PPUSH
4015: CALL 70272 0 3
4019: ST_TO_ADDR
// if DeltaDoctor then
4020: LD_EXP 58
4024: IFFALSE 4042
// tmp := tmp ^ DeltaDoctor ;
4026: LD_ADDR_VAR 0 5
4030: PUSH
4031: LD_VAR 0 5
4035: PUSH
4036: LD_EXP 58
4040: ADD
4041: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 10c_ ) ;
4042: LD_ADDR_EXP 57
4046: PUSH
4047: LD_STRING Mike
4049: PPUSH
4050: LD_EXP 1
4054: NOT
4055: PPUSH
4056: LD_STRING 10c_
4058: PPUSH
4059: CALL 70272 0 3
4063: ST_TO_ADDR
// if Mike then
4064: LD_EXP 57
4068: IFFALSE 4091
// PlaceUnitXYR ( Mike , 61 , 89 , 8 , false ) ;
4070: LD_EXP 57
4074: PPUSH
4075: LD_INT 61
4077: PPUSH
4078: LD_INT 89
4080: PPUSH
4081: LD_INT 8
4083: PPUSH
4084: LD_INT 0
4086: PPUSH
4087: CALL_OW 50
// vip := tmp ;
4091: LD_ADDR_EXP 62
4095: PUSH
4096: LD_VAR 0 5
4100: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
4101: LD_ADDR_VAR 0 5
4105: PUSH
4106: LD_VAR 0 5
4110: PUSH
4111: LD_STRING 13s_others
4113: PPUSH
4114: CALL_OW 31
4118: UNION
4119: ST_TO_ADDR
// if tmp < 18 then
4120: LD_VAR 0 5
4124: PUSH
4125: LD_INT 18
4127: LESS
4128: IFFALSE 4233
// begin InitHC_All ( ) ;
4130: CALL_OW 584
// for i = 1 to 18 - tmp do
4134: LD_ADDR_VAR 0 2
4138: PUSH
4139: DOUBLE
4140: LD_INT 1
4142: DEC
4143: ST_TO_ADDR
4144: LD_INT 18
4146: PUSH
4147: LD_VAR 0 5
4151: MINUS
4152: PUSH
4153: FOR_TO
4154: IFFALSE 4231
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
4156: LD_INT 1
4158: PPUSH
4159: LD_VAR 0 2
4163: PUSH
4164: LD_INT 4
4166: MOD
4167: PUSH
4168: LD_INT 1
4170: PLUS
4171: PPUSH
4172: LD_INT 4
4174: PPUSH
4175: CALL_OW 380
// un := CreateHuman ;
4179: LD_ADDR_VAR 0 10
4183: PUSH
4184: CALL_OW 44
4188: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
4189: LD_ADDR_VAR 0 5
4193: PUSH
4194: LD_VAR 0 5
4198: PPUSH
4199: LD_VAR 0 10
4203: PPUSH
4204: CALL 107963 0 2
4208: ST_TO_ADDR
// extraSquad := Join ( extraSquad , un ) ;
4209: LD_ADDR_EXP 63
4213: PUSH
4214: LD_EXP 63
4218: PPUSH
4219: LD_VAR 0 10
4223: PPUSH
4224: CALL 107963 0 2
4228: ST_TO_ADDR
// end ;
4229: GO 4153
4231: POP
4232: POP
// end ; depot := HexInfo ( 53 , 94 ) ;
4233: LD_ADDR_VAR 0 6
4237: PUSH
4238: LD_INT 53
4240: PPUSH
4241: LD_INT 94
4243: PPUSH
4244: CALL_OW 428
4248: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
4249: LD_ADDR_VAR 0 7
4253: PUSH
4254: LD_INT 56
4256: PPUSH
4257: LD_INT 101
4259: PPUSH
4260: CALL_OW 428
4264: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
4265: LD_ADDR_VAR 0 8
4269: PUSH
4270: LD_INT 67
4272: PPUSH
4273: LD_INT 101
4275: PPUSH
4276: CALL_OW 428
4280: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
4281: LD_ADDR_VAR 0 9
4285: PUSH
4286: LD_INT 54
4288: PPUSH
4289: LD_INT 85
4291: PPUSH
4292: CALL_OW 428
4296: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
4297: LD_ADDR_VAR 0 3
4301: PUSH
4302: LD_VAR 0 8
4306: PUSH
4307: LD_VAR 0 6
4311: PUSH
4312: LD_VAR 0 9
4316: PUSH
4317: LD_VAR 0 7
4321: PUSH
4322: EMPTY
4323: LIST
4324: LIST
4325: LIST
4326: LIST
4327: ST_TO_ADDR
// for i in tmp do
4328: LD_ADDR_VAR 0 2
4332: PUSH
4333: LD_VAR 0 5
4337: PUSH
4338: FOR_IN
4339: IFFALSE 4534
// begin case GetBType ( b [ 1 ] ) of b_armoury :
4341: LD_VAR 0 3
4345: PUSH
4346: LD_INT 1
4348: ARRAY
4349: PPUSH
4350: CALL_OW 266
4354: PUSH
4355: LD_INT 4
4357: DOUBLE
4358: EQUAL
4359: IFTRUE 4363
4361: GO 4378
4363: POP
// SetClass ( i , class_soldier ) ; b_depot :
4364: LD_VAR 0 2
4368: PPUSH
4369: LD_INT 1
4371: PPUSH
4372: CALL_OW 336
4376: GO 4448
4378: LD_INT 0
4380: DOUBLE
4381: EQUAL
4382: IFTRUE 4386
4384: GO 4401
4386: POP
// SetClass ( i , class_engineer ) ; b_workshop :
4387: LD_VAR 0 2
4391: PPUSH
4392: LD_INT 2
4394: PPUSH
4395: CALL_OW 336
4399: GO 4448
4401: LD_INT 2
4403: DOUBLE
4404: EQUAL
4405: IFTRUE 4409
4407: GO 4424
4409: POP
// SetClass ( i , class_mechanic ) ; b_lab :
4410: LD_VAR 0 2
4414: PPUSH
4415: LD_INT 3
4417: PPUSH
4418: CALL_OW 336
4422: GO 4448
4424: LD_INT 6
4426: DOUBLE
4427: EQUAL
4428: IFTRUE 4432
4430: GO 4447
4432: POP
// SetClass ( i , class_scientistic ) ; end ;
4433: LD_VAR 0 2
4437: PPUSH
4438: LD_INT 4
4440: PPUSH
4441: CALL_OW 336
4445: GO 4448
4447: POP
// if UnitsInside ( b [ 1 ] ) = 6 then
4448: LD_VAR 0 3
4452: PUSH
4453: LD_INT 1
4455: ARRAY
4456: PPUSH
4457: CALL_OW 313
4461: PUSH
4462: LD_INT 6
4464: EQUAL
4465: IFFALSE 4485
// b := Delete ( b , 1 ) ;
4467: LD_ADDR_VAR 0 3
4471: PUSH
4472: LD_VAR 0 3
4476: PPUSH
4477: LD_INT 1
4479: PPUSH
4480: CALL_OW 3
4484: ST_TO_ADDR
// if b then
4485: LD_VAR 0 3
4489: IFFALSE 4511
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4491: LD_VAR 0 2
4495: PPUSH
4496: LD_VAR 0 3
4500: PUSH
4501: LD_INT 1
4503: ARRAY
4504: PPUSH
4505: CALL_OW 52
4509: GO 4532
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4511: LD_VAR 0 2
4515: PPUSH
4516: LD_INT 61
4518: PPUSH
4519: LD_INT 89
4521: PPUSH
4522: LD_INT 8
4524: PPUSH
4525: LD_INT 0
4527: PPUSH
4528: CALL_OW 50
// end ;
4532: GO 4338
4534: POP
4535: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4536: LD_INT 2
4538: PPUSH
4539: LD_INT 1
4541: PPUSH
4542: LD_INT 1
4544: PPUSH
4545: LD_INT 12
4547: PPUSH
4548: LD_INT 100
4550: PPUSH
4551: CALL 75112 0 5
// veh := CreateVehicle ;
4555: LD_ADDR_VAR 0 4
4559: PUSH
4560: CALL_OW 45
4564: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4565: LD_VAR 0 4
4569: PPUSH
4570: LD_INT 4
4572: PPUSH
4573: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4577: LD_VAR 0 4
4581: PPUSH
4582: LD_INT 49
4584: PPUSH
4585: LD_INT 88
4587: PPUSH
4588: LD_INT 0
4590: PPUSH
4591: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4595: LD_VAR 0 4
4599: PPUSH
4600: LD_INT 1
4602: PPUSH
4603: LD_INT 100
4605: PPUSH
4606: CALL_OW 290
// uc_side := 0 ;
4610: LD_ADDR_OWVAR 20
4614: PUSH
4615: LD_INT 0
4617: ST_TO_ADDR
// uc_nation := 0 ;
4618: LD_ADDR_OWVAR 21
4622: PUSH
4623: LD_INT 0
4625: ST_TO_ADDR
// for i := 1 to 3 do
4626: LD_ADDR_VAR 0 2
4630: PUSH
4631: DOUBLE
4632: LD_INT 1
4634: DEC
4635: ST_TO_ADDR
4636: LD_INT 3
4638: PUSH
4639: FOR_TO
4640: IFFALSE 4671
// begin InitHc ;
4642: CALL_OW 19
// hc_class := class_apeman ;
4646: LD_ADDR_OWVAR 28
4650: PUSH
4651: LD_INT 12
4653: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4654: CALL_OW 44
4658: PPUSH
4659: LD_INT 13
4661: PPUSH
4662: LD_INT 0
4664: PPUSH
4665: CALL_OW 49
// end ;
4669: GO 4639
4671: POP
4672: POP
// end ; end_of_file
4673: LD_VAR 0 1
4677: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4678: LD_INT 0
4680: PPUSH
4681: PPUSH
4682: PPUSH
4683: PPUSH
4684: PPUSH
// side := 8 ;
4685: LD_ADDR_VAR 0 3
4689: PUSH
4690: LD_INT 8
4692: ST_TO_ADDR
// uc_side := side ;
4693: LD_ADDR_OWVAR 20
4697: PUSH
4698: LD_VAR 0 3
4702: ST_TO_ADDR
// uc_nation := 2 ;
4703: LD_ADDR_OWVAR 21
4707: PUSH
4708: LD_INT 2
4710: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4711: LD_ADDR_VAR 0 2
4715: PUSH
4716: LD_INT 22
4718: PUSH
4719: LD_VAR 0 3
4723: PUSH
4724: EMPTY
4725: LIST
4726: LIST
4727: PUSH
4728: LD_INT 21
4730: PUSH
4731: LD_INT 3
4733: PUSH
4734: EMPTY
4735: LIST
4736: LIST
4737: PUSH
4738: EMPTY
4739: LIST
4740: LIST
4741: PPUSH
4742: CALL_OW 69
4746: PUSH
4747: FOR_IN
4748: IFFALSE 4764
// SetBLevel ( i , 10 ) ;
4750: LD_VAR 0 2
4754: PPUSH
4755: LD_INT 10
4757: PPUSH
4758: CALL_OW 241
4762: GO 4747
4764: POP
4765: POP
// if KurtStatus then
4766: LD_EXP 3
4770: IFFALSE 4793
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4772: LD_ADDR_EXP 64
4776: PUSH
4777: LD_STRING Kurt
4779: PPUSH
4780: LD_INT 0
4782: PPUSH
4783: LD_STRING 
4785: PPUSH
4786: CALL 70272 0 3
4790: ST_TO_ADDR
4791: GO 4815
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4793: LD_ADDR_EXP 64
4797: PUSH
4798: LD_STRING AltKurt
4800: PPUSH
4801: LD_EXP 1
4805: NOT
4806: PPUSH
4807: LD_STRING 
4809: PPUSH
4810: CALL 70272 0 3
4814: ST_TO_ADDR
// if not Kurt then
4815: LD_EXP 64
4819: NOT
4820: IFFALSE 4846
// begin InitHc ;
4822: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4826: LD_INT 1
4828: PPUSH
4829: LD_INT 10
4831: PPUSH
4832: CALL_OW 381
// Kurt := CreateHuman ;
4836: LD_ADDR_EXP 64
4840: PUSH
4841: CALL_OW 44
4845: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4846: LD_EXP 64
4850: PPUSH
4851: LD_INT 324
4853: PPUSH
4854: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4858: LD_ADDR_EXP 65
4862: PUSH
4863: LD_STRING Kozlov
4865: PPUSH
4866: LD_INT 0
4868: PPUSH
4869: LD_STRING 
4871: PPUSH
4872: CALL 70272 0 3
4876: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4877: LD_EXP 65
4881: PPUSH
4882: LD_INT 22
4884: PUSH
4885: LD_INT 8
4887: PUSH
4888: EMPTY
4889: LIST
4890: LIST
4891: PUSH
4892: LD_INT 23
4894: PUSH
4895: LD_INT 3
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: PUSH
4902: LD_INT 30
4904: PUSH
4905: LD_INT 8
4907: PUSH
4908: EMPTY
4909: LIST
4910: LIST
4911: PUSH
4912: EMPTY
4913: LIST
4914: LIST
4915: LIST
4916: PPUSH
4917: CALL_OW 69
4921: PUSH
4922: LD_INT 1
4924: ARRAY
4925: PPUSH
4926: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4930: LD_EXP 65
4934: PPUSH
4935: LD_INT 3
4937: PPUSH
4938: LD_INT 10
4940: PPUSH
4941: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4945: LD_EXP 65
4949: PPUSH
4950: LD_INT 4
4952: PPUSH
4953: LD_INT 10
4955: PPUSH
4956: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4960: LD_ADDR_VAR 0 5
4964: PUSH
4965: LD_INT 22
4967: PUSH
4968: LD_VAR 0 3
4972: PUSH
4973: EMPTY
4974: LIST
4975: LIST
4976: PUSH
4977: LD_INT 30
4979: PUSH
4980: LD_INT 32
4982: PUSH
4983: EMPTY
4984: LIST
4985: LIST
4986: PUSH
4987: LD_INT 58
4989: PUSH
4990: EMPTY
4991: LIST
4992: PUSH
4993: EMPTY
4994: LIST
4995: LIST
4996: LIST
4997: PPUSH
4998: CALL_OW 69
5002: ST_TO_ADDR
// for i = 1 to 10 do
5003: LD_ADDR_VAR 0 2
5007: PUSH
5008: DOUBLE
5009: LD_INT 1
5011: DEC
5012: ST_TO_ADDR
5013: LD_INT 10
5015: PUSH
5016: FOR_TO
5017: IFFALSE 5089
// begin uc_nation := nation_nature ;
5019: LD_ADDR_OWVAR 21
5023: PUSH
5024: LD_INT 0
5026: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
5027: LD_ADDR_OWVAR 28
5031: PUSH
5032: LD_INT 15
5034: ST_TO_ADDR
// hc_gallery :=  ;
5035: LD_ADDR_OWVAR 33
5039: PUSH
5040: LD_STRING 
5042: ST_TO_ADDR
// hc_name :=  ;
5043: LD_ADDR_OWVAR 26
5047: PUSH
5048: LD_STRING 
5050: ST_TO_ADDR
// un := CreateHuman ;
5051: LD_ADDR_VAR 0 4
5055: PUSH
5056: CALL_OW 44
5060: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
5061: LD_VAR 0 4
5065: PPUSH
5066: LD_VAR 0 5
5070: PUSH
5071: LD_VAR 0 5
5075: PUSH
5076: LD_VAR 0 2
5080: MINUS
5081: ARRAY
5082: PPUSH
5083: CALL_OW 52
// end ;
5087: GO 5016
5089: POP
5090: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
5091: LD_ADDR_VAR 0 5
5095: PUSH
5096: LD_STRING 12_kurt_squad
5098: PPUSH
5099: CALL_OW 31
5103: ST_TO_ADDR
// if tmp then
5104: LD_VAR 0 5
5108: IFFALSE 5142
// for i in tmp do
5110: LD_ADDR_VAR 0 2
5114: PUSH
5115: LD_VAR 0 5
5119: PUSH
5120: FOR_IN
5121: IFFALSE 5140
// PlaceUnitArea ( i , legionBaseArea , false ) ;
5123: LD_VAR 0 2
5127: PPUSH
5128: LD_INT 5
5130: PPUSH
5131: LD_INT 0
5133: PPUSH
5134: CALL_OW 49
5138: GO 5120
5140: POP
5141: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
5142: LD_INT 324
5144: PPUSH
5145: LD_INT 5
5147: PPUSH
5148: LD_STRING 
5150: PPUSH
5151: LD_INT 8
5153: PUSH
5154: LD_INT 9
5156: PUSH
5157: LD_INT 10
5159: PUSH
5160: LD_INT 10
5162: PUSH
5163: EMPTY
5164: LIST
5165: LIST
5166: LIST
5167: LIST
5168: PUSH
5169: LD_OWVAR 67
5173: ARRAY
5174: PPUSH
5175: LD_INT 3000
5177: PUSH
5178: LD_INT 500
5180: PUSH
5181: LD_INT 150
5183: PUSH
5184: EMPTY
5185: LIST
5186: LIST
5187: LIST
5188: PPUSH
5189: LD_INT 16
5191: PUSH
5192: LD_INT 6
5194: PUSH
5195: LD_INT 6
5197: PUSH
5198: LD_INT 8
5200: PUSH
5201: EMPTY
5202: LIST
5203: LIST
5204: LIST
5205: LIST
5206: PPUSH
5207: CALL 78933 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
5211: LD_ADDR_EXP 102
5215: PUSH
5216: LD_EXP 102
5220: PPUSH
5221: LD_INT 3
5223: PPUSH
5224: LD_INT 22
5226: PUSH
5227: LD_VAR 0 3
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: PUSH
5236: LD_INT 23
5238: PUSH
5239: LD_INT 2
5241: PUSH
5242: EMPTY
5243: LIST
5244: LIST
5245: PUSH
5246: LD_INT 3
5248: PUSH
5249: LD_INT 21
5251: PUSH
5252: LD_INT 2
5254: PUSH
5255: EMPTY
5256: LIST
5257: LIST
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: PUSH
5263: EMPTY
5264: LIST
5265: LIST
5266: LIST
5267: PPUSH
5268: CALL_OW 69
5272: PUSH
5273: LD_EXP 64
5277: DIFF
5278: PPUSH
5279: CALL_OW 1
5283: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
5284: LD_INT 1
5286: PPUSH
5287: LD_INT 7
5289: PPUSH
5290: CALL_OW 383
// hc_name := Ali Hadrach ;
5294: LD_ADDR_OWVAR 26
5298: PUSH
5299: LD_STRING Ali Hadrach
5301: ST_TO_ADDR
// hc_gallery := us ;
5302: LD_ADDR_OWVAR 33
5306: PUSH
5307: LD_STRING us
5309: ST_TO_ADDR
// hc_face_number := 31 ;
5310: LD_ADDR_OWVAR 34
5314: PUSH
5315: LD_INT 31
5317: ST_TO_ADDR
// Friend := CreateHuman ;
5318: LD_ADDR_EXP 66
5322: PUSH
5323: CALL_OW 44
5327: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
5328: LD_INT 14
5330: PPUSH
5331: LD_INT 3
5333: PPUSH
5334: LD_INT 1
5336: PPUSH
5337: LD_INT 29
5339: PPUSH
5340: LD_INT 100
5342: PPUSH
5343: CALL 75112 0 5
// powellBomb := CreateVehicle ;
5347: LD_ADDR_EXP 67
5351: PUSH
5352: CALL_OW 45
5356: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
5357: LD_EXP 67
5361: PPUSH
5362: LD_INT 90
5364: PPUSH
5365: LD_INT 51
5367: PPUSH
5368: LD_INT 0
5370: PPUSH
5371: CALL_OW 48
// end ;
5375: LD_VAR 0 1
5379: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
5380: LD_INT 0
5382: PPUSH
5383: PPUSH
5384: PPUSH
// if IsLive ( kozlov_fac ) then
5385: LD_INT 332
5387: PPUSH
5388: CALL_OW 300
5392: IFFALSE 5396
// exit ;
5394: GO 5963
// ComExitBuilding ( Kozlov ) ;
5396: LD_EXP 65
5400: PPUSH
5401: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
5405: LD_EXP 65
5409: PPUSH
5410: CALL_OW 257
5414: PUSH
5415: LD_INT 2
5417: NONEQUAL
5418: IFFALSE 5453
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
5420: LD_EXP 65
5424: PPUSH
5425: LD_INT 324
5427: PPUSH
5428: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
5432: LD_EXP 65
5436: PPUSH
5437: LD_INT 2
5439: PPUSH
5440: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
5444: LD_EXP 65
5448: PPUSH
5449: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
5453: LD_EXP 65
5457: PPUSH
5458: LD_INT 2
5460: PPUSH
5461: LD_INT 93
5463: PPUSH
5464: LD_INT 32
5466: PPUSH
5467: LD_INT 3
5469: PPUSH
5470: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5474: LD_INT 35
5476: PPUSH
5477: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5481: LD_INT 22
5483: PUSH
5484: LD_INT 8
5486: PUSH
5487: EMPTY
5488: LIST
5489: LIST
5490: PUSH
5491: LD_INT 30
5493: PUSH
5494: LD_INT 3
5496: PUSH
5497: EMPTY
5498: LIST
5499: LIST
5500: PUSH
5501: LD_INT 23
5503: PUSH
5504: LD_INT 3
5506: PUSH
5507: EMPTY
5508: LIST
5509: LIST
5510: PUSH
5511: LD_INT 57
5513: PUSH
5514: EMPTY
5515: LIST
5516: PUSH
5517: EMPTY
5518: LIST
5519: LIST
5520: LIST
5521: LIST
5522: PPUSH
5523: CALL_OW 69
5527: IFFALSE 5474
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5529: LD_ADDR_VAR 0 2
5533: PUSH
5534: LD_INT 22
5536: PUSH
5537: LD_INT 8
5539: PUSH
5540: EMPTY
5541: LIST
5542: LIST
5543: PUSH
5544: LD_INT 30
5546: PUSH
5547: LD_INT 3
5549: PUSH
5550: EMPTY
5551: LIST
5552: LIST
5553: PUSH
5554: LD_INT 23
5556: PUSH
5557: LD_INT 3
5559: PUSH
5560: EMPTY
5561: LIST
5562: LIST
5563: PUSH
5564: LD_INT 57
5566: PUSH
5567: EMPTY
5568: LIST
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: LIST
5574: LIST
5575: PPUSH
5576: CALL_OW 69
5580: PUSH
5581: LD_INT 1
5583: ARRAY
5584: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5585: LD_INT 22
5587: PUSH
5588: LD_INT 8
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: PUSH
5595: LD_INT 23
5597: PUSH
5598: LD_INT 3
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: PUSH
5605: LD_INT 30
5607: PUSH
5608: LD_INT 21
5610: PUSH
5611: EMPTY
5612: LIST
5613: LIST
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: LIST
5619: PPUSH
5620: CALL_OW 69
5624: NOT
5625: IFFALSE 5703
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5627: LD_EXP 65
5631: PPUSH
5632: LD_INT 21
5634: PPUSH
5635: LD_INT 97
5637: PPUSH
5638: LD_INT 36
5640: PPUSH
5641: LD_INT 5
5643: PPUSH
5644: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5648: LD_INT 35
5650: PPUSH
5651: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5655: LD_INT 22
5657: PUSH
5658: LD_INT 8
5660: PUSH
5661: EMPTY
5662: LIST
5663: LIST
5664: PUSH
5665: LD_INT 23
5667: PUSH
5668: LD_INT 3
5670: PUSH
5671: EMPTY
5672: LIST
5673: LIST
5674: PUSH
5675: LD_INT 30
5677: PUSH
5678: LD_INT 21
5680: PUSH
5681: EMPTY
5682: LIST
5683: LIST
5684: PUSH
5685: LD_INT 57
5687: PUSH
5688: EMPTY
5689: LIST
5690: PUSH
5691: EMPTY
5692: LIST
5693: LIST
5694: LIST
5695: LIST
5696: PPUSH
5697: CALL_OW 69
5701: IFFALSE 5648
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5703: LD_INT 22
5705: PUSH
5706: LD_INT 8
5708: PUSH
5709: EMPTY
5710: LIST
5711: LIST
5712: PUSH
5713: LD_INT 23
5715: PUSH
5716: LD_INT 3
5718: PUSH
5719: EMPTY
5720: LIST
5721: LIST
5722: PUSH
5723: LD_INT 30
5725: PUSH
5726: LD_INT 18
5728: PUSH
5729: EMPTY
5730: LIST
5731: LIST
5732: PUSH
5733: EMPTY
5734: LIST
5735: LIST
5736: LIST
5737: PPUSH
5738: CALL_OW 69
5742: NOT
5743: IFFALSE 5821
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5745: LD_EXP 65
5749: PPUSH
5750: LD_INT 18
5752: PPUSH
5753: LD_INT 89
5755: PPUSH
5756: LD_INT 32
5758: PPUSH
5759: LD_INT 1
5761: PPUSH
5762: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5766: LD_INT 35
5768: PPUSH
5769: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5773: LD_INT 22
5775: PUSH
5776: LD_INT 8
5778: PUSH
5779: EMPTY
5780: LIST
5781: LIST
5782: PUSH
5783: LD_INT 23
5785: PUSH
5786: LD_INT 3
5788: PUSH
5789: EMPTY
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 30
5795: PUSH
5796: LD_INT 18
5798: PUSH
5799: EMPTY
5800: LIST
5801: LIST
5802: PUSH
5803: LD_INT 57
5805: PUSH
5806: EMPTY
5807: LIST
5808: PUSH
5809: EMPTY
5810: LIST
5811: LIST
5812: LIST
5813: LIST
5814: PPUSH
5815: CALL_OW 69
5819: IFFALSE 5766
// end ; lab := kozlov_lab ;
5821: LD_ADDR_VAR 0 3
5825: PUSH
5826: LD_INT 336
5828: ST_TO_ADDR
// if not lab then
5829: LD_VAR 0 3
5833: NOT
5834: IFFALSE 5838
// exit ;
5836: GO 5963
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5838: LD_EXP 65
5842: PPUSH
5843: LD_VAR 0 3
5847: PUSH
5848: LD_INT 1
5850: ARRAY
5851: PPUSH
5852: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5856: LD_EXP 65
5860: PPUSH
5861: LD_INT 4
5863: PPUSH
5864: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5868: LD_VAR 0 3
5872: PUSH
5873: LD_INT 1
5875: ARRAY
5876: PPUSH
5877: LD_INT 25
5879: PPUSH
5880: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5884: LD_INT 35
5886: PPUSH
5887: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5891: LD_INT 25
5893: PPUSH
5894: LD_INT 8
5896: PPUSH
5897: CALL_OW 321
5901: PUSH
5902: LD_INT 2
5904: EQUAL
5905: IFFALSE 5884
// ComExitBuilding ( Kozlov ) ;
5907: LD_EXP 65
5911: PPUSH
5912: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5916: LD_EXP 65
5920: PPUSH
5921: LD_VAR 0 2
5925: PPUSH
5926: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5930: LD_EXP 65
5934: PPUSH
5935: LD_INT 3
5937: PPUSH
5938: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5942: LD_VAR 0 2
5946: PPUSH
5947: LD_INT 23
5949: PPUSH
5950: LD_INT 3
5952: PPUSH
5953: LD_INT 1
5955: PPUSH
5956: LD_INT 48
5958: PPUSH
5959: CALL_OW 125
// end ;
5963: LD_VAR 0 1
5967: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5968: LD_EXP 22
5972: NOT
5973: PUSH
5974: LD_EXP 15
5978: PUSH
5979: LD_INT 6
5981: GREATEREQUAL
5982: AND
5983: IFFALSE 6064
5985: GO 5987
5987: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5988: LD_INT 3
5990: PPUSH
5991: LD_INT 3
5993: PPUSH
5994: CALL 63983 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5998: LD_INT 3
6000: PPUSH
6001: LD_INT 14
6003: PUSH
6004: LD_INT 1
6006: PUSH
6007: LD_INT 1
6009: PUSH
6010: LD_INT 28
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: PUSH
6019: LD_INT 14
6021: PUSH
6022: LD_INT 1
6024: PUSH
6025: LD_INT 1
6027: PUSH
6028: LD_INT 28
6030: PUSH
6031: EMPTY
6032: LIST
6033: LIST
6034: LIST
6035: LIST
6036: PUSH
6037: LD_INT 14
6039: PUSH
6040: LD_INT 1
6042: PUSH
6043: LD_INT 1
6045: PUSH
6046: LD_INT 28
6048: PUSH
6049: EMPTY
6050: LIST
6051: LIST
6052: LIST
6053: LIST
6054: PUSH
6055: EMPTY
6056: LIST
6057: LIST
6058: LIST
6059: PPUSH
6060: CALL 63846 0 2
// end ;
6064: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target , p ;
6065: LD_EXP 22
6069: NOT
6070: PUSH
6071: LD_EXP 15
6075: PUSH
6076: LD_INT 6
6078: GREATEREQUAL
6079: AND
6080: PUSH
6081: LD_INT 3
6083: PPUSH
6084: LD_INT 1
6086: PPUSH
6087: CALL 65264 0 2
6091: NOT
6092: AND
6093: IFFALSE 7046
6095: GO 6097
6097: DISABLE
6098: LD_INT 0
6100: PPUSH
6101: PPUSH
6102: PPUSH
6103: PPUSH
// begin enable ;
6104: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
6105: LD_INT 22
6107: PUSH
6108: LD_INT 8
6110: PUSH
6111: EMPTY
6112: LIST
6113: LIST
6114: PUSH
6115: LD_INT 23
6117: PUSH
6118: LD_INT 2
6120: PUSH
6121: EMPTY
6122: LIST
6123: LIST
6124: PUSH
6125: LD_INT 30
6127: PUSH
6128: LD_INT 3
6130: PUSH
6131: EMPTY
6132: LIST
6133: LIST
6134: PUSH
6135: EMPTY
6136: LIST
6137: LIST
6138: LIST
6139: PPUSH
6140: CALL_OW 69
6144: NOT
6145: IFFALSE 6149
// exit ;
6147: GO 7046
// if Prob ( 40 ) then
6149: LD_INT 40
6151: PPUSH
6152: CALL_OW 13
6156: IFFALSE 6283
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6158: LD_INT 3
6160: PPUSH
6161: LD_INT 14
6163: PUSH
6164: LD_INT 1
6166: PUSH
6167: LD_INT 2
6169: PUSH
6170: LD_INT 28
6172: PUSH
6173: EMPTY
6174: LIST
6175: LIST
6176: LIST
6177: LIST
6178: PUSH
6179: LD_INT 14
6181: PUSH
6182: LD_INT 1
6184: PUSH
6185: LD_INT 2
6187: PUSH
6188: LD_INT 28
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: LIST
6195: LIST
6196: PUSH
6197: LD_INT 14
6199: PUSH
6200: LD_INT 1
6202: PUSH
6203: LD_INT 2
6205: PUSH
6206: LD_INT 28
6208: PUSH
6209: EMPTY
6210: LIST
6211: LIST
6212: LIST
6213: LIST
6214: PUSH
6215: LD_INT 14
6217: PUSH
6218: LD_INT 1
6220: PUSH
6221: LD_INT 2
6223: PUSH
6224: LD_INT 28
6226: PUSH
6227: EMPTY
6228: LIST
6229: LIST
6230: LIST
6231: LIST
6232: PUSH
6233: LD_INT 14
6235: PUSH
6236: LD_INT 1
6238: PUSH
6239: LD_INT 2
6241: PUSH
6242: LD_INT 28
6244: PUSH
6245: EMPTY
6246: LIST
6247: LIST
6248: LIST
6249: LIST
6250: PUSH
6251: LD_INT 14
6253: PUSH
6254: LD_INT 1
6256: PUSH
6257: LD_INT 2
6259: PUSH
6260: LD_INT 26
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: LIST
6267: LIST
6268: PUSH
6269: EMPTY
6270: LIST
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: LIST
6276: PPUSH
6277: CALL 63846 0 2
// end else
6281: GO 6490
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6283: LD_INT 3
6285: PPUSH
6286: LD_INT 14
6288: PUSH
6289: LD_INT 1
6291: PUSH
6292: LD_INT 2
6294: PUSH
6295: LD_INT 27
6297: PUSH
6298: LD_INT 26
6300: PUSH
6301: LD_INT 26
6303: PUSH
6304: LD_INT 28
6306: PUSH
6307: EMPTY
6308: LIST
6309: LIST
6310: LIST
6311: LIST
6312: PUSH
6313: LD_OWVAR 67
6317: ARRAY
6318: PUSH
6319: EMPTY
6320: LIST
6321: LIST
6322: LIST
6323: LIST
6324: PUSH
6325: LD_INT 14
6327: PUSH
6328: LD_INT 1
6330: PUSH
6331: LD_INT 2
6333: PUSH
6334: LD_INT 27
6336: PUSH
6337: LD_INT 26
6339: PUSH
6340: LD_INT 26
6342: PUSH
6343: LD_INT 26
6345: PUSH
6346: EMPTY
6347: LIST
6348: LIST
6349: LIST
6350: LIST
6351: PUSH
6352: LD_OWVAR 67
6356: ARRAY
6357: PUSH
6358: EMPTY
6359: LIST
6360: LIST
6361: LIST
6362: LIST
6363: PUSH
6364: LD_INT 14
6366: PUSH
6367: LD_INT 1
6369: PUSH
6370: LD_INT 2
6372: PUSH
6373: LD_INT 26
6375: PUSH
6376: LD_INT 26
6378: PUSH
6379: LD_INT 29
6381: PUSH
6382: LD_INT 29
6384: PUSH
6385: EMPTY
6386: LIST
6387: LIST
6388: LIST
6389: LIST
6390: PUSH
6391: LD_OWVAR 67
6395: ARRAY
6396: PUSH
6397: EMPTY
6398: LIST
6399: LIST
6400: LIST
6401: LIST
6402: PUSH
6403: LD_INT 13
6405: PUSH
6406: LD_INT 1
6408: PUSH
6409: LD_INT 2
6411: PUSH
6412: LD_INT 26
6414: PUSH
6415: LD_INT 29
6417: PUSH
6418: LD_INT 29
6420: PUSH
6421: LD_INT 29
6423: PUSH
6424: EMPTY
6425: LIST
6426: LIST
6427: LIST
6428: LIST
6429: PUSH
6430: LD_OWVAR 67
6434: ARRAY
6435: PUSH
6436: EMPTY
6437: LIST
6438: LIST
6439: LIST
6440: LIST
6441: PUSH
6442: LD_INT 13
6444: PUSH
6445: LD_INT 1
6447: PUSH
6448: LD_INT 2
6450: PUSH
6451: LD_INT 29
6453: PUSH
6454: EMPTY
6455: LIST
6456: LIST
6457: LIST
6458: LIST
6459: PUSH
6460: LD_INT 14
6462: PUSH
6463: LD_INT 1
6465: PUSH
6466: LD_INT 2
6468: PUSH
6469: LD_INT 26
6471: PUSH
6472: EMPTY
6473: LIST
6474: LIST
6475: LIST
6476: LIST
6477: PUSH
6478: EMPTY
6479: LIST
6480: LIST
6481: LIST
6482: LIST
6483: LIST
6484: LIST
6485: PPUSH
6486: CALL 63846 0 2
// end ; wait ( 2 2$00 ) ;
6490: LD_INT 4200
6492: PPUSH
6493: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] , [ f_not , [ f_weapon , ar_crane ] ] ] ) diff mc_defender [ 3 ] ;
6497: LD_ADDR_VAR 0 2
6501: PUSH
6502: LD_INT 22
6504: PUSH
6505: LD_INT 8
6507: PUSH
6508: EMPTY
6509: LIST
6510: LIST
6511: PUSH
6512: LD_INT 21
6514: PUSH
6515: LD_INT 2
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: PUSH
6522: LD_INT 3
6524: PUSH
6525: LD_INT 34
6527: PUSH
6528: LD_INT 31
6530: PUSH
6531: EMPTY
6532: LIST
6533: LIST
6534: PUSH
6535: EMPTY
6536: LIST
6537: LIST
6538: PUSH
6539: LD_INT 3
6541: PUSH
6542: LD_INT 34
6544: PUSH
6545: LD_INT 32
6547: PUSH
6548: EMPTY
6549: LIST
6550: LIST
6551: PUSH
6552: EMPTY
6553: LIST
6554: LIST
6555: PUSH
6556: LD_INT 3
6558: PUSH
6559: LD_INT 34
6561: PUSH
6562: LD_INT 88
6564: PUSH
6565: EMPTY
6566: LIST
6567: LIST
6568: PUSH
6569: EMPTY
6570: LIST
6571: LIST
6572: PUSH
6573: EMPTY
6574: LIST
6575: LIST
6576: LIST
6577: LIST
6578: LIST
6579: PPUSH
6580: CALL_OW 69
6584: PUSH
6585: LD_EXP 124
6589: PUSH
6590: LD_INT 3
6592: ARRAY
6593: DIFF
6594: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6595: LD_ADDR_EXP 121
6599: PUSH
6600: LD_EXP 121
6604: PPUSH
6605: LD_INT 3
6607: PPUSH
6608: LD_EXP 121
6612: PUSH
6613: LD_INT 3
6615: ARRAY
6616: PUSH
6617: LD_VAR 0 2
6621: DIFF
6622: PPUSH
6623: CALL_OW 1
6627: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6628: LD_ADDR_VAR 0 3
6632: PUSH
6633: LD_INT 0
6635: PPUSH
6636: LD_INT 2
6638: PPUSH
6639: CALL_OW 12
6643: ST_TO_ADDR
// if target then
6644: LD_VAR 0 3
6648: IFFALSE 6806
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6650: LD_ADDR_VAR 0 2
6654: PUSH
6655: LD_VAR 0 2
6659: PPUSH
6660: LD_INT 50
6662: PUSH
6663: EMPTY
6664: LIST
6665: PPUSH
6666: CALL_OW 72
6670: ST_TO_ADDR
// if not tmp then
6671: LD_VAR 0 2
6675: NOT
6676: IFFALSE 6680
// break ;
6678: GO 6804
// for i in tmp do
6680: LD_ADDR_VAR 0 1
6684: PUSH
6685: LD_VAR 0 2
6689: PUSH
6690: FOR_IN
6691: IFFALSE 6731
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6693: LD_VAR 0 1
6697: PPUSH
6698: LD_INT 89
6700: PPUSH
6701: LD_INT 71
6703: PPUSH
6704: CALL_OW 297
6708: PUSH
6709: LD_INT 9
6711: GREATER
6712: IFFALSE 6729
// ComMoveXY ( i , 89 , 71 ) ;
6714: LD_VAR 0 1
6718: PPUSH
6719: LD_INT 89
6721: PPUSH
6722: LD_INT 71
6724: PPUSH
6725: CALL_OW 111
6729: GO 6690
6731: POP
6732: POP
// wait ( 0 0$1 ) ;
6733: LD_INT 35
6735: PPUSH
6736: CALL_OW 67
// p := Inc ( p ) ;
6740: LD_ADDR_VAR 0 4
6744: PUSH
6745: LD_VAR 0 4
6749: PPUSH
6750: CALL 109324 0 1
6754: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6755: LD_VAR 0 2
6759: PPUSH
6760: LD_INT 92
6762: PUSH
6763: LD_INT 89
6765: PUSH
6766: LD_INT 71
6768: PUSH
6769: LD_INT 9
6771: PUSH
6772: EMPTY
6773: LIST
6774: LIST
6775: LIST
6776: LIST
6777: PPUSH
6778: CALL_OW 72
6782: PUSH
6783: LD_VAR 0 2
6787: PUSH
6788: LD_INT 1
6790: MINUS
6791: GREATEREQUAL
6792: PUSH
6793: LD_VAR 0 4
6797: PUSH
6798: LD_INT 30
6800: GREATER
6801: OR
6802: IFFALSE 6650
// end else
6804: GO 6960
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6806: LD_ADDR_VAR 0 2
6810: PUSH
6811: LD_VAR 0 2
6815: PPUSH
6816: LD_INT 50
6818: PUSH
6819: EMPTY
6820: LIST
6821: PPUSH
6822: CALL_OW 72
6826: ST_TO_ADDR
// if not tmp then
6827: LD_VAR 0 2
6831: NOT
6832: IFFALSE 6836
// break ;
6834: GO 6960
// for i in tmp do
6836: LD_ADDR_VAR 0 1
6840: PUSH
6841: LD_VAR 0 2
6845: PUSH
6846: FOR_IN
6847: IFFALSE 6887
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6849: LD_VAR 0 1
6853: PPUSH
6854: LD_INT 125
6856: PPUSH
6857: LD_INT 129
6859: PPUSH
6860: CALL_OW 297
6864: PUSH
6865: LD_INT 9
6867: GREATER
6868: IFFALSE 6885
// ComMoveXY ( i , 125 , 129 ) ;
6870: LD_VAR 0 1
6874: PPUSH
6875: LD_INT 125
6877: PPUSH
6878: LD_INT 129
6880: PPUSH
6881: CALL_OW 111
6885: GO 6846
6887: POP
6888: POP
// wait ( 0 0$1 ) ;
6889: LD_INT 35
6891: PPUSH
6892: CALL_OW 67
// p := Inc ( p ) ;
6896: LD_ADDR_VAR 0 4
6900: PUSH
6901: LD_VAR 0 4
6905: PPUSH
6906: CALL 109324 0 1
6910: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6911: LD_VAR 0 2
6915: PPUSH
6916: LD_INT 92
6918: PUSH
6919: LD_INT 125
6921: PUSH
6922: LD_INT 129
6924: PUSH
6925: LD_INT 9
6927: PUSH
6928: EMPTY
6929: LIST
6930: LIST
6931: LIST
6932: LIST
6933: PPUSH
6934: CALL_OW 72
6938: PUSH
6939: LD_VAR 0 2
6943: PUSH
6944: LD_INT 1
6946: MINUS
6947: GREATEREQUAL
6948: PUSH
6949: LD_VAR 0 4
6953: PUSH
6954: LD_INT 30
6956: GREATER
6957: OR
6958: IFFALSE 6806
// end ; repeat wait ( 0 0$1 ) ;
6960: LD_INT 35
6962: PPUSH
6963: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6967: LD_ADDR_VAR 0 2
6971: PUSH
6972: LD_VAR 0 2
6976: PPUSH
6977: LD_INT 50
6979: PUSH
6980: EMPTY
6981: LIST
6982: PPUSH
6983: CALL_OW 72
6987: ST_TO_ADDR
// for i in tmp do
6988: LD_ADDR_VAR 0 1
6992: PUSH
6993: LD_VAR 0 2
6997: PUSH
6998: FOR_IN
6999: IFFALSE 7037
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7001: LD_VAR 0 1
7005: PPUSH
7006: LD_INT 81
7008: PUSH
7009: LD_INT 8
7011: PUSH
7012: EMPTY
7013: LIST
7014: LIST
7015: PPUSH
7016: CALL_OW 69
7020: PPUSH
7021: LD_VAR 0 1
7025: PPUSH
7026: CALL_OW 74
7030: PPUSH
7031: CALL_OW 115
7035: GO 6998
7037: POP
7038: POP
// until not tmp ;
7039: LD_VAR 0 2
7043: NOT
7044: IFFALSE 6960
// end ;
7046: PPOPN 4
7048: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
7049: LD_EXP 22
7053: NOT
7054: PUSH
7055: LD_EXP 15
7059: PUSH
7060: LD_INT 6
7062: GREATEREQUAL
7063: AND
7064: PUSH
7065: LD_OWVAR 67
7069: PUSH
7070: LD_INT 1
7072: GREATER
7073: AND
7074: IFFALSE 7607
7076: GO 7078
7078: DISABLE
7079: LD_INT 0
7081: PPUSH
7082: PPUSH
7083: PPUSH
// begin enable ;
7084: ENABLE
// tmp := [ ] ;
7085: LD_ADDR_VAR 0 3
7089: PUSH
7090: EMPTY
7091: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
7092: LD_ADDR_VAR 0 1
7096: PUSH
7097: DOUBLE
7098: LD_INT 1
7100: DEC
7101: ST_TO_ADDR
7102: LD_INT 4
7104: PUSH
7105: LD_INT 6
7107: PUSH
7108: LD_INT 7
7110: PUSH
7111: LD_INT 8
7113: PUSH
7114: EMPTY
7115: LIST
7116: LIST
7117: LIST
7118: LIST
7119: PUSH
7120: LD_OWVAR 67
7124: ARRAY
7125: PUSH
7126: FOR_TO
7127: IFFALSE 7287
// begin uc_side := 8 ;
7129: LD_ADDR_OWVAR 20
7133: PUSH
7134: LD_INT 8
7136: ST_TO_ADDR
// uc_nation := 2 ;
7137: LD_ADDR_OWVAR 21
7141: PUSH
7142: LD_INT 2
7144: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
7145: LD_INT 13
7147: PUSH
7148: LD_INT 14
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: PUSH
7155: LD_INT 1
7157: PPUSH
7158: LD_INT 2
7160: PPUSH
7161: CALL_OW 12
7165: ARRAY
7166: PPUSH
7167: LD_INT 1
7169: PPUSH
7170: LD_INT 5
7172: PPUSH
7173: LD_INT 27
7175: PUSH
7176: LD_INT 28
7178: PUSH
7179: LD_INT 26
7181: PUSH
7182: LD_INT 25
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: LIST
7189: LIST
7190: PUSH
7191: LD_INT 1
7193: PPUSH
7194: LD_INT 4
7196: PPUSH
7197: CALL_OW 12
7201: ARRAY
7202: PPUSH
7203: LD_INT 88
7205: PPUSH
7206: CALL 75112 0 5
// un := CreateVehicle ;
7210: LD_ADDR_VAR 0 2
7214: PUSH
7215: CALL_OW 45
7219: ST_TO_ADDR
// tmp := tmp ^ un ;
7220: LD_ADDR_VAR 0 3
7224: PUSH
7225: LD_VAR 0 3
7229: PUSH
7230: LD_VAR 0 2
7234: ADD
7235: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7236: LD_VAR 0 2
7240: PPUSH
7241: LD_INT 3
7243: PPUSH
7244: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7248: LD_VAR 0 2
7252: PPUSH
7253: LD_INT 30
7255: PPUSH
7256: LD_INT 0
7258: PPUSH
7259: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7263: LD_VAR 0 2
7267: PPUSH
7268: LD_INT 16
7270: PPUSH
7271: LD_INT 11
7273: PPUSH
7274: CALL_OW 111
// wait ( 0 0$2 ) ;
7278: LD_INT 70
7280: PPUSH
7281: CALL_OW 67
// end ;
7285: GO 7126
7287: POP
7288: POP
// for i = 1 to Difficulty do
7289: LD_ADDR_VAR 0 1
7293: PUSH
7294: DOUBLE
7295: LD_INT 1
7297: DEC
7298: ST_TO_ADDR
7299: LD_OWVAR 67
7303: PUSH
7304: FOR_TO
7305: IFFALSE 7434
// begin uc_side := 8 ;
7307: LD_ADDR_OWVAR 20
7311: PUSH
7312: LD_INT 8
7314: ST_TO_ADDR
// uc_nation := 2 ;
7315: LD_ADDR_OWVAR 21
7319: PUSH
7320: LD_INT 2
7322: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
7323: LD_INT 0
7325: PPUSH
7326: LD_INT 8
7328: PPUSH
7329: LD_INT 8
7331: PUSH
7332: LD_INT 8
7334: PUSH
7335: LD_INT 9
7337: PUSH
7338: LD_INT 10
7340: PUSH
7341: EMPTY
7342: LIST
7343: LIST
7344: LIST
7345: LIST
7346: PUSH
7347: LD_OWVAR 67
7351: ARRAY
7352: PPUSH
7353: CALL_OW 380
// un := CreateHuman ;
7357: LD_ADDR_VAR 0 2
7361: PUSH
7362: CALL_OW 44
7366: ST_TO_ADDR
// tmp := tmp ^ un ;
7367: LD_ADDR_VAR 0 3
7371: PUSH
7372: LD_VAR 0 3
7376: PUSH
7377: LD_VAR 0 2
7381: ADD
7382: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7383: LD_VAR 0 2
7387: PPUSH
7388: LD_INT 3
7390: PPUSH
7391: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7395: LD_VAR 0 2
7399: PPUSH
7400: LD_INT 30
7402: PPUSH
7403: LD_INT 0
7405: PPUSH
7406: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7410: LD_VAR 0 2
7414: PPUSH
7415: LD_INT 16
7417: PPUSH
7418: LD_INT 11
7420: PPUSH
7421: CALL_OW 111
// wait ( 0 0$2 ) ;
7425: LD_INT 70
7427: PPUSH
7428: CALL_OW 67
// end ;
7432: GO 7304
7434: POP
7435: POP
// repeat wait ( 0 0$1 ) ;
7436: LD_INT 35
7438: PPUSH
7439: CALL_OW 67
// if legionDestroyed then
7443: LD_EXP 22
7447: IFFALSE 7451
// exit ;
7449: GO 7607
// for i in tmp do
7451: LD_ADDR_VAR 0 1
7455: PUSH
7456: LD_VAR 0 3
7460: PUSH
7461: FOR_IN
7462: IFFALSE 7598
// begin if GetLives ( i ) > 250 then
7464: LD_VAR 0 1
7468: PPUSH
7469: CALL_OW 256
7473: PUSH
7474: LD_INT 250
7476: GREATER
7477: IFFALSE 7569
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
7479: LD_INT 81
7481: PUSH
7482: LD_INT 8
7484: PUSH
7485: EMPTY
7486: LIST
7487: LIST
7488: PUSH
7489: LD_INT 91
7491: PUSH
7492: LD_VAR 0 1
7496: PUSH
7497: LD_INT 10
7499: PUSH
7500: EMPTY
7501: LIST
7502: LIST
7503: LIST
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PPUSH
7509: CALL_OW 69
7513: NOT
7514: IFFALSE 7533
// ComAgressiveMove ( i , 67 , 110 ) else
7516: LD_VAR 0 1
7520: PPUSH
7521: LD_INT 67
7523: PPUSH
7524: LD_INT 110
7526: PPUSH
7527: CALL_OW 114
7531: GO 7567
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7533: LD_VAR 0 1
7537: PPUSH
7538: LD_INT 81
7540: PUSH
7541: LD_INT 8
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: PPUSH
7548: CALL_OW 69
7552: PPUSH
7553: LD_VAR 0 1
7557: PPUSH
7558: CALL_OW 74
7562: PPUSH
7563: CALL_OW 115
// end else
7567: GO 7596
// if IsDead ( i ) then
7569: LD_VAR 0 1
7573: PPUSH
7574: CALL_OW 301
7578: IFFALSE 7596
// tmp := tmp diff i ;
7580: LD_ADDR_VAR 0 3
7584: PUSH
7585: LD_VAR 0 3
7589: PUSH
7590: LD_VAR 0 1
7594: DIFF
7595: ST_TO_ADDR
// end ;
7596: GO 7461
7598: POP
7599: POP
// until not tmp ;
7600: LD_VAR 0 3
7604: NOT
7605: IFFALSE 7436
// end ; end_of_file
7607: PPOPN 3
7609: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
7610: LD_INT 0
7612: PPUSH
7613: PPUSH
7614: PPUSH
7615: PPUSH
7616: PPUSH
7617: PPUSH
7618: PPUSH
7619: PPUSH
7620: PPUSH
7621: PPUSH
// side := 3 ;
7622: LD_ADDR_VAR 0 6
7626: PUSH
7627: LD_INT 3
7629: ST_TO_ADDR
// uc_side := side ;
7630: LD_ADDR_OWVAR 20
7634: PUSH
7635: LD_VAR 0 6
7639: ST_TO_ADDR
// uc_nation := 3 ;
7640: LD_ADDR_OWVAR 21
7644: PUSH
7645: LD_INT 3
7647: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7648: LD_ADDR_VAR 0 2
7652: PUSH
7653: LD_INT 22
7655: PUSH
7656: LD_VAR 0 6
7660: PUSH
7661: EMPTY
7662: LIST
7663: LIST
7664: PUSH
7665: LD_INT 21
7667: PUSH
7668: LD_INT 3
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: PUSH
7675: EMPTY
7676: LIST
7677: LIST
7678: PPUSH
7679: CALL_OW 69
7683: PUSH
7684: FOR_IN
7685: IFFALSE 7701
// SetBLevel ( i , 10 ) ;
7687: LD_VAR 0 2
7691: PPUSH
7692: LD_INT 10
7694: PPUSH
7695: CALL_OW 241
7699: GO 7684
7701: POP
7702: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7703: LD_ADDR_VAR 0 10
7707: PUSH
7708: LD_INT 22
7710: PUSH
7711: LD_VAR 0 6
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: PUSH
7720: LD_INT 30
7722: PUSH
7723: LD_INT 34
7725: PUSH
7726: EMPTY
7727: LIST
7728: LIST
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: PPUSH
7734: CALL_OW 69
7738: ST_TO_ADDR
// if teleport then
7739: LD_VAR 0 10
7743: IFFALSE 7764
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7745: LD_VAR 0 10
7749: PUSH
7750: LD_INT 1
7752: ARRAY
7753: PPUSH
7754: LD_INT 123
7756: PPUSH
7757: LD_INT 122
7759: PPUSH
7760: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7764: LD_ADDR_EXP 68
7768: PUSH
7769: LD_STRING Platonov
7771: PPUSH
7772: CALL_OW 25
7776: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7777: LD_ADDR_EXP 69
7781: PUSH
7782: LD_STRING Kovalyuk
7784: PPUSH
7785: CALL_OW 25
7789: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7790: LD_ADDR_EXP 71
7794: PUSH
7795: LD_STRING Yakotich
7797: PPUSH
7798: LD_EXP 1
7802: NOT
7803: PPUSH
7804: LD_STRING 09_
7806: PPUSH
7807: CALL 70272 0 3
7811: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7812: LD_ADDR_EXP 70
7816: PUSH
7817: LD_STRING Bystrov
7819: PPUSH
7820: CALL_OW 25
7824: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7825: LD_ADDR_EXP 72
7829: PUSH
7830: LD_STRING Gleb
7832: PPUSH
7833: CALL_OW 25
7837: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7838: LD_STRING 03_Cornel
7840: PPUSH
7841: CALL_OW 28
7845: IFFALSE 7893
// begin Bierezov := NewCharacter ( Mikhail ) ;
7847: LD_ADDR_EXP 73
7851: PUSH
7852: LD_STRING Mikhail
7854: PPUSH
7855: CALL_OW 25
7859: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7860: LD_EXP 73
7864: PPUSH
7865: LD_INT 197
7867: PPUSH
7868: LD_INT 111
7870: PPUSH
7871: LD_INT 9
7873: PPUSH
7874: LD_INT 0
7876: PPUSH
7877: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7881: LD_EXP 73
7885: PPUSH
7886: LD_INT 3
7888: PPUSH
7889: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7893: LD_EXP 68
7897: PPUSH
7898: LD_INT 126
7900: PPUSH
7901: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7905: LD_EXP 69
7909: PPUSH
7910: LD_INT 134
7912: PPUSH
7913: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7917: LD_EXP 71
7921: PPUSH
7922: LD_INT 197
7924: PPUSH
7925: LD_INT 111
7927: PPUSH
7928: LD_INT 9
7930: PPUSH
7931: LD_INT 0
7933: PPUSH
7934: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7938: LD_EXP 70
7942: PPUSH
7943: LD_INT 197
7945: PPUSH
7946: LD_INT 111
7948: PPUSH
7949: LD_INT 9
7951: PPUSH
7952: LD_INT 0
7954: PPUSH
7955: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7959: LD_EXP 72
7963: PPUSH
7964: LD_INT 197
7966: PPUSH
7967: LD_INT 111
7969: PPUSH
7970: LD_INT 9
7972: PPUSH
7973: LD_INT 0
7975: PPUSH
7976: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 12 , 6 ] ) ;
7980: LD_ADDR_VAR 0 5
7984: PUSH
7985: LD_INT 126
7987: PPUSH
7988: LD_INT 4
7990: PPUSH
7991: LD_STRING zhukov
7993: PPUSH
7994: LD_INT 9
7996: PUSH
7997: LD_INT 10
7999: PUSH
8000: LD_INT 10
8002: PUSH
8003: LD_INT 10
8005: PUSH
8006: EMPTY
8007: LIST
8008: LIST
8009: LIST
8010: LIST
8011: PUSH
8012: LD_OWVAR 67
8016: ARRAY
8017: PPUSH
8018: LD_INT 90000
8020: PUSH
8021: LD_INT 1000
8023: PUSH
8024: LD_INT 300
8026: PUSH
8027: EMPTY
8028: LIST
8029: LIST
8030: LIST
8031: PPUSH
8032: LD_INT 18
8034: PUSH
8035: LD_INT 8
8037: PUSH
8038: LD_INT 12
8040: PUSH
8041: LD_INT 6
8043: PUSH
8044: EMPTY
8045: LIST
8046: LIST
8047: LIST
8048: LIST
8049: PPUSH
8050: CALL 78933 0 6
8054: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Bystrov , Gleb , Bierezov ] ) ;
8055: LD_ADDR_EXP 102
8059: PUSH
8060: LD_EXP 102
8064: PPUSH
8065: LD_INT 2
8067: PPUSH
8068: LD_VAR 0 5
8072: PUSH
8073: LD_EXP 71
8077: PUSH
8078: LD_EXP 70
8082: PUSH
8083: LD_EXP 72
8087: PUSH
8088: LD_EXP 73
8092: PUSH
8093: EMPTY
8094: LIST
8095: LIST
8096: LIST
8097: LIST
8098: UNION
8099: PPUSH
8100: CALL_OW 1
8104: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8105: LD_ADDR_VAR 0 4
8109: PUSH
8110: LD_INT 267
8112: PPUSH
8113: CALL_OW 274
8117: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8118: LD_VAR 0 4
8122: PPUSH
8123: LD_INT 1
8125: PPUSH
8126: LD_INT 5000
8128: PPUSH
8129: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8133: LD_VAR 0 4
8137: PPUSH
8138: LD_INT 2
8140: PPUSH
8141: LD_INT 200
8143: PPUSH
8144: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8148: LD_VAR 0 4
8152: PPUSH
8153: LD_INT 3
8155: PPUSH
8156: LD_INT 200
8158: PPUSH
8159: CALL_OW 277
// for i := 1 to 6 do
8163: LD_ADDR_VAR 0 2
8167: PUSH
8168: DOUBLE
8169: LD_INT 1
8171: DEC
8172: ST_TO_ADDR
8173: LD_INT 6
8175: PUSH
8176: FOR_TO
8177: IFFALSE 8260
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
8179: LD_INT 0
8181: PPUSH
8182: LD_INT 8
8184: PUSH
8185: LD_INT 9
8187: PUSH
8188: LD_INT 10
8190: PUSH
8191: LD_INT 10
8193: PUSH
8194: EMPTY
8195: LIST
8196: LIST
8197: LIST
8198: LIST
8199: PUSH
8200: LD_OWVAR 67
8204: ARRAY
8205: PPUSH
8206: CALL_OW 381
// un := CreateHuman ;
8210: LD_ADDR_VAR 0 8
8214: PUSH
8215: CALL_OW 44
8219: ST_TO_ADDR
// if i mod 2 = 0 then
8220: LD_VAR 0 2
8224: PUSH
8225: LD_INT 2
8227: MOD
8228: PUSH
8229: LD_INT 0
8231: EQUAL
8232: IFFALSE 8246
// SetClass ( un , class_bazooker ) ;
8234: LD_VAR 0 8
8238: PPUSH
8239: LD_INT 9
8241: PPUSH
8242: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
8246: LD_VAR 0 8
8250: PPUSH
8251: LD_INT 460
8253: PPUSH
8254: CALL_OW 52
// end ;
8258: GO 8176
8260: POP
8261: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
8262: LD_INT 21
8264: PPUSH
8265: LD_INT 3
8267: PPUSH
8268: LD_INT 3
8270: PPUSH
8271: LD_INT 52
8273: PPUSH
8274: LD_INT 100
8276: PPUSH
8277: CALL 75112 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
8281: CALL_OW 45
8285: PPUSH
8286: LD_INT 259
8288: PPUSH
8289: LD_INT 145
8291: PPUSH
8292: LD_INT 3
8294: PPUSH
8295: LD_INT 0
8297: PPUSH
8298: CALL 110103 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
8302: CALL_OW 45
8306: PPUSH
8307: LD_INT 245
8309: PPUSH
8310: LD_INT 139
8312: PPUSH
8313: LD_INT 3
8315: PPUSH
8316: LD_INT 0
8318: PPUSH
8319: CALL 110103 0 5
// behemoths := [ ] ;
8323: LD_ADDR_EXP 76
8327: PUSH
8328: EMPTY
8329: ST_TO_ADDR
// behemothBuilders := [ ] ;
8330: LD_ADDR_EXP 77
8334: PUSH
8335: EMPTY
8336: ST_TO_ADDR
// if Kovalyuk then
8337: LD_EXP 69
8341: IFFALSE 8363
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
8343: LD_ADDR_EXP 77
8347: PUSH
8348: LD_EXP 77
8352: PPUSH
8353: LD_EXP 69
8357: PPUSH
8358: CALL 107963 0 2
8362: ST_TO_ADDR
// end ;
8363: LD_VAR 0 1
8367: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8368: LD_INT 0
8370: PPUSH
8371: PPUSH
8372: PPUSH
8373: PPUSH
8374: PPUSH
// xy := [ [ 221 , 154 ] , [ 223 , 149 ] , [ 228 , 147 ] , [ 232 , 155 ] ] ;
8375: LD_ADDR_VAR 0 4
8379: PUSH
8380: LD_INT 221
8382: PUSH
8383: LD_INT 154
8385: PUSH
8386: EMPTY
8387: LIST
8388: LIST
8389: PUSH
8390: LD_INT 223
8392: PUSH
8393: LD_INT 149
8395: PUSH
8396: EMPTY
8397: LIST
8398: LIST
8399: PUSH
8400: LD_INT 228
8402: PUSH
8403: LD_INT 147
8405: PUSH
8406: EMPTY
8407: LIST
8408: LIST
8409: PUSH
8410: LD_INT 232
8412: PUSH
8413: LD_INT 155
8415: PUSH
8416: EMPTY
8417: LIST
8418: LIST
8419: PUSH
8420: EMPTY
8421: LIST
8422: LIST
8423: LIST
8424: LIST
8425: ST_TO_ADDR
// if not behemothBuilders then
8426: LD_EXP 77
8430: NOT
8431: IFFALSE 8435
// exit ;
8433: GO 8566
// j := 1 ;
8435: LD_ADDR_VAR 0 3
8439: PUSH
8440: LD_INT 1
8442: ST_TO_ADDR
// for i in behemothBuilders do
8443: LD_ADDR_VAR 0 2
8447: PUSH
8448: LD_EXP 77
8452: PUSH
8453: FOR_IN
8454: IFFALSE 8564
// begin if GetClass ( i ) <> class_mechanic then
8456: LD_VAR 0 2
8460: PPUSH
8461: CALL_OW 257
8465: PUSH
8466: LD_INT 3
8468: NONEQUAL
8469: IFFALSE 8483
// SetClass ( i , class_mechanic ) ;
8471: LD_VAR 0 2
8475: PPUSH
8476: LD_INT 3
8478: PPUSH
8479: CALL_OW 336
// if IsInUnit ( i ) then
8483: LD_VAR 0 2
8487: PPUSH
8488: CALL_OW 310
8492: IFFALSE 8503
// ComExitBuilding ( i ) ;
8494: LD_VAR 0 2
8498: PPUSH
8499: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8503: LD_VAR 0 2
8507: PPUSH
8508: LD_INT 37
8510: PPUSH
8511: LD_VAR 0 4
8515: PUSH
8516: LD_VAR 0 3
8520: ARRAY
8521: PUSH
8522: LD_INT 1
8524: ARRAY
8525: PPUSH
8526: LD_VAR 0 4
8530: PUSH
8531: LD_VAR 0 3
8535: ARRAY
8536: PUSH
8537: LD_INT 2
8539: ARRAY
8540: PPUSH
8541: LD_INT 0
8543: PPUSH
8544: CALL_OW 230
// j := j + 1 ;
8548: LD_ADDR_VAR 0 3
8552: PUSH
8553: LD_VAR 0 3
8557: PUSH
8558: LD_INT 1
8560: PLUS
8561: ST_TO_ADDR
// end ;
8562: GO 8453
8564: POP
8565: POP
// end ;
8566: LD_VAR 0 1
8570: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
8571: LD_INT 24
8573: PPUSH
8574: LD_INT 30
8576: PUSH
8577: LD_INT 37
8579: PUSH
8580: EMPTY
8581: LIST
8582: LIST
8583: PPUSH
8584: CALL_OW 70
8588: IFFALSE 8601
8590: GO 8592
8592: DISABLE
// behemothUnderConstruct := true ;
8593: LD_ADDR_EXP 26
8597: PUSH
8598: LD_INT 1
8600: ST_TO_ADDR
8601: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8602: LD_INT 3
8604: PPUSH
8605: CALL 108024 0 1
8609: PUSH
8610: LD_INT 22
8612: PUSH
8613: LD_INT 3
8615: PUSH
8616: EMPTY
8617: LIST
8618: LIST
8619: PUSH
8620: LD_INT 30
8622: PUSH
8623: LD_INT 37
8625: PUSH
8626: EMPTY
8627: LIST
8628: LIST
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: PPUSH
8634: CALL_OW 69
8638: NOT
8639: AND
8640: IFFALSE 8826
8642: GO 8644
8644: DISABLE
8645: LD_INT 0
8647: PPUSH
8648: PPUSH
// begin enable ;
8649: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8650: LD_ADDR_VAR 0 2
8654: PUSH
8655: LD_INT 3
8657: PPUSH
8658: CALL 108024 0 1
8662: ST_TO_ADDR
// for i in tmp do
8663: LD_ADDR_VAR 0 1
8667: PUSH
8668: LD_VAR 0 2
8672: PUSH
8673: FOR_IN
8674: IFFALSE 8824
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8676: LD_VAR 0 1
8680: PPUSH
8681: LD_INT 9
8683: PPUSH
8684: CALL_OW 308
8688: PUSH
8689: LD_VAR 0 1
8693: PPUSH
8694: CALL_OW 110
8698: PUSH
8699: LD_INT 2
8701: EQUAL
8702: NOT
8703: AND
8704: IFFALSE 8718
// SetTag ( i , 2 ) ;
8706: LD_VAR 0 1
8710: PPUSH
8711: LD_INT 2
8713: PPUSH
8714: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8718: LD_INT 81
8720: PUSH
8721: LD_INT 3
8723: PUSH
8724: EMPTY
8725: LIST
8726: LIST
8727: PUSH
8728: LD_INT 91
8730: PUSH
8731: LD_VAR 0 1
8735: PUSH
8736: LD_INT 12
8738: PUSH
8739: EMPTY
8740: LIST
8741: LIST
8742: LIST
8743: PUSH
8744: EMPTY
8745: LIST
8746: LIST
8747: PPUSH
8748: CALL_OW 69
8752: NOT
8753: PUSH
8754: LD_VAR 0 1
8758: PPUSH
8759: CALL_OW 110
8763: PUSH
8764: LD_INT 2
8766: EQUAL
8767: NOT
8768: AND
8769: IFFALSE 8788
// ComAgressiveMove ( i , 64 , 93 ) else
8771: LD_VAR 0 1
8775: PPUSH
8776: LD_INT 64
8778: PPUSH
8779: LD_INT 93
8781: PPUSH
8782: CALL_OW 114
8786: GO 8822
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8788: LD_VAR 0 1
8792: PPUSH
8793: LD_INT 81
8795: PUSH
8796: LD_INT 3
8798: PUSH
8799: EMPTY
8800: LIST
8801: LIST
8802: PPUSH
8803: CALL_OW 69
8807: PPUSH
8808: LD_VAR 0 1
8812: PPUSH
8813: CALL_OW 74
8817: PPUSH
8818: CALL_OW 115
// end ;
8822: GO 8673
8824: POP
8825: POP
// end ;
8826: PPOPN 2
8828: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8829: LD_INT 0
8831: PPUSH
8832: PPUSH
8833: PPUSH
// result := [ ] ;
8834: LD_ADDR_VAR 0 2
8838: PUSH
8839: EMPTY
8840: ST_TO_ADDR
// uc_side := 6 ;
8841: LD_ADDR_OWVAR 20
8845: PUSH
8846: LD_INT 6
8848: ST_TO_ADDR
// uc_nation := 3 ;
8849: LD_ADDR_OWVAR 21
8853: PUSH
8854: LD_INT 3
8856: ST_TO_ADDR
// case strength of 1 :
8857: LD_VAR 0 1
8861: PUSH
8862: LD_INT 1
8864: DOUBLE
8865: EQUAL
8866: IFTRUE 8870
8868: GO 9012
8870: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8871: LD_ADDR_VAR 0 3
8875: PUSH
8876: DOUBLE
8877: LD_INT 1
8879: DEC
8880: ST_TO_ADDR
8881: LD_INT 4
8883: PUSH
8884: LD_INT 5
8886: PUSH
8887: LD_INT 6
8889: PUSH
8890: LD_INT 7
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: LIST
8897: LIST
8898: PUSH
8899: LD_OWVAR 67
8903: ARRAY
8904: PUSH
8905: FOR_TO
8906: IFFALSE 9008
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8908: LD_INT 22
8910: PUSH
8911: LD_INT 24
8913: PUSH
8914: EMPTY
8915: LIST
8916: LIST
8917: PUSH
8918: LD_VAR 0 3
8922: PUSH
8923: LD_INT 2
8925: MOD
8926: PUSH
8927: LD_INT 1
8929: PLUS
8930: ARRAY
8931: PPUSH
8932: LD_INT 1
8934: PUSH
8935: LD_INT 3
8937: PUSH
8938: EMPTY
8939: LIST
8940: LIST
8941: PUSH
8942: LD_INT 1
8944: PPUSH
8945: LD_INT 2
8947: PPUSH
8948: CALL_OW 12
8952: ARRAY
8953: PPUSH
8954: LD_INT 3
8956: PPUSH
8957: LD_INT 43
8959: PUSH
8960: LD_INT 44
8962: PUSH
8963: LD_INT 45
8965: PUSH
8966: EMPTY
8967: LIST
8968: LIST
8969: LIST
8970: PUSH
8971: LD_INT 1
8973: PPUSH
8974: LD_INT 3
8976: PPUSH
8977: CALL_OW 12
8981: ARRAY
8982: PPUSH
8983: LD_INT 80
8985: PPUSH
8986: CALL 75112 0 5
// result := result union CreateVehicle ;
8990: LD_ADDR_VAR 0 2
8994: PUSH
8995: LD_VAR 0 2
8999: PUSH
9000: CALL_OW 45
9004: UNION
9005: ST_TO_ADDR
// end ;
9006: GO 8905
9008: POP
9009: POP
// end ; 2 :
9010: GO 10007
9012: LD_INT 2
9014: DOUBLE
9015: EQUAL
9016: IFTRUE 9020
9018: GO 9188
9020: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
9021: LD_ADDR_VAR 0 3
9025: PUSH
9026: DOUBLE
9027: LD_INT 1
9029: DEC
9030: ST_TO_ADDR
9031: LD_INT 5
9033: PUSH
9034: LD_INT 6
9036: PUSH
9037: LD_INT 7
9039: PUSH
9040: LD_INT 8
9042: PUSH
9043: EMPTY
9044: LIST
9045: LIST
9046: LIST
9047: LIST
9048: PUSH
9049: LD_OWVAR 67
9053: ARRAY
9054: PUSH
9055: FOR_TO
9056: IFFALSE 9184
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
9058: LD_INT 22
9060: PUSH
9061: LD_INT 24
9063: PUSH
9064: LD_INT 24
9066: PUSH
9067: EMPTY
9068: LIST
9069: LIST
9070: LIST
9071: PUSH
9072: LD_VAR 0 3
9076: PUSH
9077: LD_INT 3
9079: MOD
9080: PUSH
9081: LD_INT 1
9083: PLUS
9084: ARRAY
9085: PPUSH
9086: LD_INT 1
9088: PUSH
9089: LD_INT 3
9091: PUSH
9092: EMPTY
9093: LIST
9094: LIST
9095: PUSH
9096: LD_INT 1
9098: PPUSH
9099: LD_INT 2
9101: PPUSH
9102: CALL_OW 12
9106: ARRAY
9107: PPUSH
9108: LD_INT 3
9110: PPUSH
9111: LD_INT 43
9113: PUSH
9114: LD_INT 44
9116: PUSH
9117: LD_INT 45
9119: PUSH
9120: LD_INT 44
9122: PUSH
9123: LD_INT 46
9125: PUSH
9126: LD_INT 46
9128: PUSH
9129: LD_INT 49
9131: PUSH
9132: LD_INT 49
9134: PUSH
9135: EMPTY
9136: LIST
9137: LIST
9138: LIST
9139: LIST
9140: LIST
9141: LIST
9142: LIST
9143: LIST
9144: PUSH
9145: LD_VAR 0 3
9149: PUSH
9150: LD_INT 8
9152: MOD
9153: PUSH
9154: LD_INT 1
9156: PLUS
9157: ARRAY
9158: PPUSH
9159: LD_INT 80
9161: PPUSH
9162: CALL 75112 0 5
// result := result union CreateVehicle ;
9166: LD_ADDR_VAR 0 2
9170: PUSH
9171: LD_VAR 0 2
9175: PUSH
9176: CALL_OW 45
9180: UNION
9181: ST_TO_ADDR
// end ;
9182: GO 9055
9184: POP
9185: POP
// end ; 3 :
9186: GO 10007
9188: LD_INT 3
9190: DOUBLE
9191: EQUAL
9192: IFTRUE 9196
9194: GO 9368
9196: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
9197: LD_ADDR_VAR 0 3
9201: PUSH
9202: DOUBLE
9203: LD_INT 1
9205: DEC
9206: ST_TO_ADDR
9207: LD_INT 6
9209: PUSH
9210: LD_INT 7
9212: PUSH
9213: LD_INT 8
9215: PUSH
9216: LD_INT 9
9218: PUSH
9219: EMPTY
9220: LIST
9221: LIST
9222: LIST
9223: LIST
9224: PUSH
9225: LD_OWVAR 67
9229: ARRAY
9230: PUSH
9231: FOR_TO
9232: IFFALSE 9364
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9234: LD_INT 22
9236: PUSH
9237: LD_INT 24
9239: PUSH
9240: LD_INT 24
9242: PUSH
9243: EMPTY
9244: LIST
9245: LIST
9246: LIST
9247: PUSH
9248: LD_VAR 0 3
9252: PUSH
9253: LD_INT 3
9255: MOD
9256: PUSH
9257: LD_INT 1
9259: PLUS
9260: ARRAY
9261: PPUSH
9262: LD_INT 1
9264: PUSH
9265: LD_INT 3
9267: PUSH
9268: EMPTY
9269: LIST
9270: LIST
9271: PUSH
9272: LD_INT 1
9274: PPUSH
9275: LD_INT 2
9277: PPUSH
9278: CALL_OW 12
9282: ARRAY
9283: PPUSH
9284: LD_INT 3
9286: PPUSH
9287: LD_INT 43
9289: PUSH
9290: LD_INT 47
9292: PUSH
9293: LD_INT 45
9295: PUSH
9296: LD_INT 45
9298: PUSH
9299: LD_INT 46
9301: PUSH
9302: LD_INT 46
9304: PUSH
9305: LD_INT 49
9307: PUSH
9308: LD_INT 49
9310: PUSH
9311: LD_INT 49
9313: PUSH
9314: EMPTY
9315: LIST
9316: LIST
9317: LIST
9318: LIST
9319: LIST
9320: LIST
9321: LIST
9322: LIST
9323: LIST
9324: PUSH
9325: LD_VAR 0 3
9329: PUSH
9330: LD_INT 9
9332: MOD
9333: PUSH
9334: LD_INT 1
9336: PLUS
9337: ARRAY
9338: PPUSH
9339: LD_INT 80
9341: PPUSH
9342: CALL 75112 0 5
// result := result union CreateVehicle ;
9346: LD_ADDR_VAR 0 2
9350: PUSH
9351: LD_VAR 0 2
9355: PUSH
9356: CALL_OW 45
9360: UNION
9361: ST_TO_ADDR
// end ;
9362: GO 9231
9364: POP
9365: POP
// end ; 4 :
9366: GO 10007
9368: LD_INT 4
9370: DOUBLE
9371: EQUAL
9372: IFTRUE 9376
9374: GO 10006
9376: POP
// begin uc_nation := 3 ;
9377: LD_ADDR_OWVAR 21
9381: PUSH
9382: LD_INT 3
9384: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
9385: LD_ADDR_VAR 0 3
9389: PUSH
9390: DOUBLE
9391: LD_INT 1
9393: DEC
9394: ST_TO_ADDR
9395: LD_INT 6
9397: PUSH
9398: LD_INT 8
9400: PUSH
9401: LD_INT 9
9403: PUSH
9404: LD_INT 10
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: LIST
9411: LIST
9412: PUSH
9413: LD_OWVAR 67
9417: ARRAY
9418: PUSH
9419: FOR_TO
9420: IFFALSE 9552
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9422: LD_INT 22
9424: PUSH
9425: LD_INT 24
9427: PUSH
9428: LD_INT 24
9430: PUSH
9431: EMPTY
9432: LIST
9433: LIST
9434: LIST
9435: PUSH
9436: LD_VAR 0 3
9440: PUSH
9441: LD_INT 3
9443: MOD
9444: PUSH
9445: LD_INT 1
9447: PLUS
9448: ARRAY
9449: PPUSH
9450: LD_INT 1
9452: PUSH
9453: LD_INT 3
9455: PUSH
9456: EMPTY
9457: LIST
9458: LIST
9459: PUSH
9460: LD_INT 1
9462: PPUSH
9463: LD_INT 2
9465: PPUSH
9466: CALL_OW 12
9470: ARRAY
9471: PPUSH
9472: LD_INT 3
9474: PPUSH
9475: LD_INT 45
9477: PUSH
9478: LD_INT 47
9480: PUSH
9481: LD_INT 47
9483: PUSH
9484: LD_INT 45
9486: PUSH
9487: LD_INT 46
9489: PUSH
9490: LD_INT 46
9492: PUSH
9493: LD_INT 49
9495: PUSH
9496: LD_INT 49
9498: PUSH
9499: LD_INT 49
9501: PUSH
9502: EMPTY
9503: LIST
9504: LIST
9505: LIST
9506: LIST
9507: LIST
9508: LIST
9509: LIST
9510: LIST
9511: LIST
9512: PUSH
9513: LD_VAR 0 3
9517: PUSH
9518: LD_INT 9
9520: MOD
9521: PUSH
9522: LD_INT 1
9524: PLUS
9525: ARRAY
9526: PPUSH
9527: LD_INT 80
9529: PPUSH
9530: CALL 75112 0 5
// result := result union CreateVehicle ;
9534: LD_ADDR_VAR 0 2
9538: PUSH
9539: LD_VAR 0 2
9543: PUSH
9544: CALL_OW 45
9548: UNION
9549: ST_TO_ADDR
// end ;
9550: GO 9419
9552: POP
9553: POP
// if not KappaStatus then
9554: LD_EXP 2
9558: NOT
9559: IFFALSE 9794
// begin uc_nation := 1 ;
9561: LD_ADDR_OWVAR 21
9565: PUSH
9566: LD_INT 1
9568: ST_TO_ADDR
// for i = 1 to 3 do
9569: LD_ADDR_VAR 0 3
9573: PUSH
9574: DOUBLE
9575: LD_INT 1
9577: DEC
9578: ST_TO_ADDR
9579: LD_INT 3
9581: PUSH
9582: FOR_TO
9583: IFFALSE 9719
// begin j := rand ( 0 , 1 ) ;
9585: LD_ADDR_VAR 0 4
9589: PUSH
9590: LD_INT 0
9592: PPUSH
9593: LD_INT 1
9595: PPUSH
9596: CALL_OW 12
9600: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9601: LD_INT 3
9603: PUSH
9604: LD_INT 5
9606: PUSH
9607: LD_INT 5
9609: PUSH
9610: LD_INT 4
9612: PUSH
9613: EMPTY
9614: LIST
9615: LIST
9616: LIST
9617: LIST
9618: PUSH
9619: LD_VAR 0 4
9623: PUSH
9624: LD_INT 1
9626: PPUSH
9627: LD_INT 3
9629: PPUSH
9630: CALL_OW 12
9634: PLUS
9635: ARRAY
9636: PPUSH
9637: LD_INT 1
9639: PUSH
9640: LD_INT 3
9642: PUSH
9643: EMPTY
9644: LIST
9645: LIST
9646: PUSH
9647: LD_INT 1
9649: PPUSH
9650: LD_INT 2
9652: PPUSH
9653: CALL_OW 12
9657: ARRAY
9658: PPUSH
9659: LD_INT 3
9661: PPUSH
9662: LD_INT 9
9664: PUSH
9665: LD_INT 7
9667: PUSH
9668: LD_INT 6
9670: PUSH
9671: EMPTY
9672: LIST
9673: LIST
9674: LIST
9675: PUSH
9676: LD_VAR 0 4
9680: PUSH
9681: LD_INT 1
9683: PPUSH
9684: LD_INT 2
9686: PPUSH
9687: CALL_OW 12
9691: PLUS
9692: ARRAY
9693: PPUSH
9694: LD_INT 85
9696: PPUSH
9697: CALL 75112 0 5
// result := result union CreateVehicle ;
9701: LD_ADDR_VAR 0 2
9705: PUSH
9706: LD_VAR 0 2
9710: PUSH
9711: CALL_OW 45
9715: UNION
9716: ST_TO_ADDR
// end ;
9717: GO 9582
9719: POP
9720: POP
// if vsevolodFirstAttack then
9721: LD_EXP 24
9725: IFFALSE 9792
// begin vsevolodFirstAttack := false ;
9727: LD_ADDR_EXP 24
9731: PUSH
9732: LD_INT 0
9734: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9735: LD_INT 5
9737: PPUSH
9738: LD_INT 3
9740: PPUSH
9741: LD_INT 1
9743: PPUSH
9744: LD_INT 6
9746: PPUSH
9747: LD_INT 100
9749: PPUSH
9750: CALL 75112 0 5
// sewiVeh := CreateVehicle ;
9754: LD_ADDR_EXP 75
9758: PUSH
9759: CALL_OW 45
9763: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9764: LD_EXP 75
9768: PPUSH
9769: LD_INT 1
9771: PPUSH
9772: CALL_OW 242
// result := result union sewiVeh ;
9776: LD_ADDR_VAR 0 2
9780: PUSH
9781: LD_VAR 0 2
9785: PUSH
9786: LD_EXP 75
9790: UNION
9791: ST_TO_ADDR
// end ; end else
9792: GO 10004
// if vsevolodFirstAttack then
9794: LD_EXP 24
9798: IFFALSE 10004
// begin vsevolodFirstAttack := false ;
9800: LD_ADDR_EXP 24
9804: PUSH
9805: LD_INT 0
9807: ST_TO_ADDR
// uc_nation := 3 ;
9808: LD_ADDR_OWVAR 21
9812: PUSH
9813: LD_INT 3
9815: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9816: LD_ADDR_VAR 0 3
9820: PUSH
9821: DOUBLE
9822: LD_INT 1
9824: DEC
9825: ST_TO_ADDR
9826: LD_INT 2
9828: PUSH
9829: LD_OWVAR 67
9833: PLUS
9834: PUSH
9835: FOR_TO
9836: IFFALSE 9944
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9838: LD_INT 22
9840: PUSH
9841: LD_INT 24
9843: PUSH
9844: LD_INT 24
9846: PUSH
9847: EMPTY
9848: LIST
9849: LIST
9850: LIST
9851: PUSH
9852: LD_VAR 0 3
9856: PUSH
9857: LD_INT 3
9859: MOD
9860: PUSH
9861: LD_INT 1
9863: PLUS
9864: ARRAY
9865: PPUSH
9866: LD_INT 1
9868: PUSH
9869: LD_INT 3
9871: PUSH
9872: EMPTY
9873: LIST
9874: LIST
9875: PUSH
9876: LD_INT 1
9878: PPUSH
9879: LD_INT 2
9881: PPUSH
9882: CALL_OW 12
9886: ARRAY
9887: PPUSH
9888: LD_INT 1
9890: PPUSH
9891: LD_INT 45
9893: PUSH
9894: LD_INT 47
9896: PUSH
9897: LD_INT 47
9899: PUSH
9900: EMPTY
9901: LIST
9902: LIST
9903: LIST
9904: PUSH
9905: LD_VAR 0 3
9909: PUSH
9910: LD_INT 3
9912: MOD
9913: PUSH
9914: LD_INT 1
9916: PLUS
9917: ARRAY
9918: PPUSH
9919: LD_INT 80
9921: PPUSH
9922: CALL 75112 0 5
// result := result union CreateVehicle ;
9926: LD_ADDR_VAR 0 2
9930: PUSH
9931: LD_VAR 0 2
9935: PUSH
9936: CALL_OW 45
9940: UNION
9941: ST_TO_ADDR
// end ;
9942: GO 9835
9944: POP
9945: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9946: LD_INT 24
9948: PPUSH
9949: LD_INT 3
9951: PPUSH
9952: LD_INT 1
9954: PPUSH
9955: LD_INT 47
9957: PPUSH
9958: LD_INT 100
9960: PPUSH
9961: CALL 75112 0 5
// sewiVeh := CreateVehicle ;
9965: LD_ADDR_EXP 75
9969: PUSH
9970: CALL_OW 45
9974: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9975: LD_EXP 75
9979: PPUSH
9980: LD_INT 6
9982: NEG
9983: PPUSH
9984: CALL_OW 242
// result := result union sewiVeh ;
9988: LD_ADDR_VAR 0 2
9992: PUSH
9993: LD_VAR 0 2
9997: PUSH
9998: LD_EXP 75
10002: UNION
10003: ST_TO_ADDR
// end ; end ; end ;
10004: GO 10007
10006: POP
// end ;
10007: LD_VAR 0 2
10011: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
10012: LD_EXP 16
10016: IFFALSE 10773
10018: GO 10020
10020: DISABLE
10021: LD_INT 0
10023: PPUSH
10024: PPUSH
10025: PPUSH
10026: PPUSH
10027: PPUSH
10028: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
10029: LD_ADDR_VAR 0 4
10033: PUSH
10034: LD_INT 11
10036: PUSH
10037: LD_INT 12
10039: PUSH
10040: EMPTY
10041: LIST
10042: LIST
10043: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
10044: LD_ADDR_VAR 0 3
10048: PUSH
10049: LD_INT 11550
10051: PUSH
10052: LD_INT 10150
10054: PUSH
10055: LD_INT 9800
10057: PUSH
10058: LD_INT 9450
10060: PUSH
10061: EMPTY
10062: LIST
10063: LIST
10064: LIST
10065: LIST
10066: PUSH
10067: LD_OWVAR 67
10071: ARRAY
10072: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
10073: LD_ADDR_VAR 0 6
10077: PUSH
10078: LD_INT 70
10080: PUSH
10081: LD_INT 118
10083: PUSH
10084: EMPTY
10085: LIST
10086: LIST
10087: PUSH
10088: LD_INT 78
10090: PUSH
10091: LD_INT 31
10093: PUSH
10094: EMPTY
10095: LIST
10096: LIST
10097: PUSH
10098: EMPTY
10099: LIST
10100: LIST
10101: ST_TO_ADDR
// repeat if missionStage = 2 then
10102: LD_EXP 15
10106: PUSH
10107: LD_INT 2
10109: EQUAL
10110: IFFALSE 10121
// wait ( 1 1$30 ) else
10112: LD_INT 3150
10114: PPUSH
10115: CALL_OW 67
10119: GO 10130
// wait ( time ) ;
10121: LD_VAR 0 3
10125: PPUSH
10126: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
10130: LD_EXP 15
10134: PUSH
10135: LD_INT 6
10137: EQUAL
10138: PUSH
10139: LD_OWVAR 67
10143: PUSH
10144: LD_INT 2
10146: GREATER
10147: OR
10148: IFFALSE 10176
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
10150: LD_INT 51
10152: PPUSH
10153: LD_INT 6
10155: PPUSH
10156: LD_INT 2
10158: PPUSH
10159: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
10163: LD_INT 57
10165: PPUSH
10166: LD_INT 6
10168: PPUSH
10169: LD_INT 2
10171: PPUSH
10172: CALL_OW 322
// end ; if missionStage = 8 then
10176: LD_EXP 15
10180: PUSH
10181: LD_INT 8
10183: EQUAL
10184: IFFALSE 10212
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
10186: LD_INT 52
10188: PPUSH
10189: LD_INT 6
10191: PPUSH
10192: LD_INT 2
10194: PPUSH
10195: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
10199: LD_INT 58
10201: PPUSH
10202: LD_INT 6
10204: PPUSH
10205: LD_INT 2
10207: PPUSH
10208: CALL_OW 322
// end ; if Difficulty = 4 or missionStage = 10 then
10212: LD_OWVAR 67
10216: PUSH
10217: LD_INT 4
10219: EQUAL
10220: PUSH
10221: LD_EXP 15
10225: PUSH
10226: LD_INT 10
10228: EQUAL
10229: OR
10230: IFFALSE 10258
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
10232: LD_INT 53
10234: PPUSH
10235: LD_INT 6
10237: PPUSH
10238: LD_INT 2
10240: PPUSH
10241: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
10245: LD_INT 59
10247: PPUSH
10248: LD_INT 6
10250: PPUSH
10251: LD_INT 2
10253: PPUSH
10254: CALL_OW 322
// end ; if activeAttacks then
10258: LD_EXP 16
10262: IFFALSE 10767
// begin if missionStage = 2 then
10264: LD_EXP 15
10268: PUSH
10269: LD_INT 2
10271: EQUAL
10272: IFFALSE 10282
// strength := 1 ;
10274: LD_ADDR_VAR 0 5
10278: PUSH
10279: LD_INT 1
10281: ST_TO_ADDR
// if missionStage > 2 then
10282: LD_EXP 15
10286: PUSH
10287: LD_INT 2
10289: GREATER
10290: IFFALSE 10300
// strength := 2 ;
10292: LD_ADDR_VAR 0 5
10296: PUSH
10297: LD_INT 2
10299: ST_TO_ADDR
// if missionStage > 6 then
10300: LD_EXP 15
10304: PUSH
10305: LD_INT 6
10307: GREATER
10308: IFFALSE 10318
// strength := 3 ;
10310: LD_ADDR_VAR 0 5
10314: PUSH
10315: LD_INT 3
10317: ST_TO_ADDR
// if missionStage > 10 then
10318: LD_EXP 15
10322: PUSH
10323: LD_INT 10
10325: GREATER
10326: IFFALSE 10336
// strength := 4 ;
10328: LD_ADDR_VAR 0 5
10332: PUSH
10333: LD_INT 4
10335: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
10336: LD_ADDR_VAR 0 2
10340: PUSH
10341: LD_VAR 0 5
10345: PPUSH
10346: CALL 8829 0 1
10350: ST_TO_ADDR
// for i in tmp do
10351: LD_ADDR_VAR 0 1
10355: PUSH
10356: LD_VAR 0 2
10360: PUSH
10361: FOR_IN
10362: IFFALSE 10636
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
10364: LD_VAR 0 1
10368: PPUSH
10369: LD_VAR 0 4
10373: PUSH
10374: LD_INT 1
10376: PPUSH
10377: LD_INT 2
10379: PPUSH
10380: CALL_OW 12
10384: ARRAY
10385: PPUSH
10386: LD_INT 0
10388: PPUSH
10389: CALL_OW 49
// if i = sewiVeh then
10393: LD_VAR 0 1
10397: PUSH
10398: LD_EXP 75
10402: EQUAL
10403: IFFALSE 10456
// begin uc_side := 6 ;
10405: LD_ADDR_OWVAR 20
10409: PUSH
10410: LD_INT 6
10412: ST_TO_ADDR
// uc_nation := nation_russian ;
10413: LD_ADDR_OWVAR 21
10417: PUSH
10418: LD_INT 3
10420: ST_TO_ADDR
// Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
10421: LD_ADDR_EXP 74
10425: PUSH
10426: LD_STRING Vsevolod
10428: PPUSH
10429: LD_INT 0
10431: PPUSH
10432: LD_STRING 
10434: PPUSH
10435: CALL 70272 0 3
10439: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
10440: LD_EXP 74
10444: PPUSH
10445: LD_VAR 0 1
10449: PPUSH
10450: CALL_OW 52
// end else
10454: GO 10537
// if GetControl ( i ) = control_manual then
10456: LD_VAR 0 1
10460: PPUSH
10461: CALL_OW 263
10465: PUSH
10466: LD_INT 1
10468: EQUAL
10469: IFFALSE 10537
// begin uc_side := 6 ;
10471: LD_ADDR_OWVAR 20
10475: PUSH
10476: LD_INT 6
10478: ST_TO_ADDR
// uc_nation := 3 ;
10479: LD_ADDR_OWVAR 21
10483: PUSH
10484: LD_INT 3
10486: ST_TO_ADDR
// hc_gallery :=  ;
10487: LD_ADDR_OWVAR 33
10491: PUSH
10492: LD_STRING 
10494: ST_TO_ADDR
// hc_name :=  ;
10495: LD_ADDR_OWVAR 26
10499: PUSH
10500: LD_STRING 
10502: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
10503: LD_INT 0
10505: PPUSH
10506: LD_INT 3
10508: PPUSH
10509: LD_INT 10
10511: PPUSH
10512: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
10516: CALL_OW 44
10520: PPUSH
10521: LD_VAR 0 1
10525: PPUSH
10526: CALL_OW 52
// wait ( 0 0$0.3 ) ;
10530: LD_INT 10
10532: PPUSH
10533: CALL_OW 67
// end ; case rand ( 1 , 3 ) of 1 :
10537: LD_INT 1
10539: PPUSH
10540: LD_INT 3
10542: PPUSH
10543: CALL_OW 12
10547: PUSH
10548: LD_INT 1
10550: DOUBLE
10551: EQUAL
10552: IFTRUE 10556
10554: GO 10574
10556: POP
// ComMoveXY ( i , 111 , 197 ) ; 2 :
10557: LD_VAR 0 1
10561: PPUSH
10562: LD_INT 111
10564: PPUSH
10565: LD_INT 197
10567: PPUSH
10568: CALL_OW 111
10572: GO 10627
10574: LD_INT 2
10576: DOUBLE
10577: EQUAL
10578: IFTRUE 10582
10580: GO 10600
10582: POP
// ComMoveXY ( i , 91 , 165 ) ; 3 :
10583: LD_VAR 0 1
10587: PPUSH
10588: LD_INT 91
10590: PPUSH
10591: LD_INT 165
10593: PPUSH
10594: CALL_OW 111
10598: GO 10627
10600: LD_INT 3
10602: DOUBLE
10603: EQUAL
10604: IFTRUE 10608
10606: GO 10626
10608: POP
// ComMoveXY ( i , 137 , 157 ) ; end ;
10609: LD_VAR 0 1
10613: PPUSH
10614: LD_INT 137
10616: PPUSH
10617: LD_INT 157
10619: PPUSH
10620: CALL_OW 111
10624: GO 10627
10626: POP
// wait ( 0 0$2 ) ;
10627: LD_INT 70
10629: PPUSH
10630: CALL_OW 67
// end ;
10634: GO 10361
10636: POP
10637: POP
// repeat wait ( 0 0$1 ) ;
10638: LD_INT 35
10640: PPUSH
10641: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
10645: LD_ADDR_VAR 0 1
10649: PUSH
10650: LD_VAR 0 2
10654: PPUSH
10655: LD_INT 50
10657: PUSH
10658: EMPTY
10659: LIST
10660: PPUSH
10661: CALL_OW 72
10665: PUSH
10666: FOR_IN
10667: IFFALSE 10726
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10669: LD_VAR 0 1
10673: PPUSH
10674: LD_INT 108
10676: PUSH
10677: LD_INT 153
10679: PUSH
10680: EMPTY
10681: LIST
10682: LIST
10683: PUSH
10684: LD_INT 105
10686: PUSH
10687: LD_INT 149
10689: PUSH
10690: EMPTY
10691: LIST
10692: LIST
10693: PUSH
10694: LD_INT 85
10696: PUSH
10697: LD_INT 131
10699: PUSH
10700: EMPTY
10701: LIST
10702: LIST
10703: PUSH
10704: LD_INT 64
10706: PUSH
10707: LD_INT 105
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: LIST
10718: LIST
10719: PPUSH
10720: CALL 110567 0 2
10724: GO 10666
10726: POP
10727: POP
// until not UnitFilter ( tmp , [ [ f_not , [ f_weapon , ru_time_lapser ] ] , [ f_ok ] ] ) ;
10728: LD_VAR 0 2
10732: PPUSH
10733: LD_INT 3
10735: PUSH
10736: LD_INT 34
10738: PUSH
10739: LD_INT 49
10741: PUSH
10742: EMPTY
10743: LIST
10744: LIST
10745: PUSH
10746: EMPTY
10747: LIST
10748: LIST
10749: PUSH
10750: LD_INT 50
10752: PUSH
10753: EMPTY
10754: LIST
10755: PUSH
10756: EMPTY
10757: LIST
10758: LIST
10759: PPUSH
10760: CALL_OW 72
10764: NOT
10765: IFFALSE 10638
// end ; until russianDestroyed ;
10767: LD_EXP 21
10771: IFFALSE 10102
// end ;
10773: PPOPN 6
10775: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 do var i , tmp , target , teleport , p ;
10776: LD_EXP 21
10780: NOT
10781: PUSH
10782: LD_EXP 15
10786: PUSH
10787: LD_INT 6
10789: GREATEREQUAL
10790: AND
10791: IFFALSE 11828
10793: GO 10795
10795: DISABLE
10796: LD_INT 0
10798: PPUSH
10799: PPUSH
10800: PPUSH
10801: PPUSH
10802: PPUSH
// begin enable ;
10803: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10804: LD_INT 22
10806: PUSH
10807: LD_INT 3
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PUSH
10814: LD_INT 30
10816: PUSH
10817: LD_INT 3
10819: PUSH
10820: EMPTY
10821: LIST
10822: LIST
10823: PUSH
10824: EMPTY
10825: LIST
10826: LIST
10827: PPUSH
10828: CALL_OW 69
10832: NOT
10833: IFFALSE 10837
// exit ;
10835: GO 11828
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10837: LD_ADDR_VAR 0 4
10841: PUSH
10842: LD_INT 22
10844: PUSH
10845: LD_INT 3
10847: PUSH
10848: EMPTY
10849: LIST
10850: LIST
10851: PUSH
10852: LD_INT 30
10854: PUSH
10855: LD_INT 34
10857: PUSH
10858: EMPTY
10859: LIST
10860: LIST
10861: PUSH
10862: EMPTY
10863: LIST
10864: LIST
10865: PPUSH
10866: CALL_OW 69
10870: ST_TO_ADDR
// if Prob ( 40 ) then
10871: LD_INT 40
10873: PPUSH
10874: CALL_OW 13
10878: IFFALSE 11024
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10880: LD_INT 2
10882: PPUSH
10883: LD_INT 22
10885: PUSH
10886: LD_INT 3
10888: PUSH
10889: LD_INT 3
10891: PUSH
10892: LD_INT 49
10894: PUSH
10895: EMPTY
10896: LIST
10897: LIST
10898: LIST
10899: LIST
10900: PUSH
10901: LD_INT 22
10903: PUSH
10904: LD_INT 3
10906: PUSH
10907: LD_INT 3
10909: PUSH
10910: LD_INT 49
10912: PUSH
10913: EMPTY
10914: LIST
10915: LIST
10916: LIST
10917: LIST
10918: PUSH
10919: LD_INT 22
10921: PUSH
10922: LD_INT 3
10924: PUSH
10925: LD_INT 3
10927: PUSH
10928: LD_INT 49
10930: PUSH
10931: EMPTY
10932: LIST
10933: LIST
10934: LIST
10935: LIST
10936: PUSH
10937: LD_INT 24
10939: PUSH
10940: LD_INT 3
10942: PUSH
10943: LD_INT 3
10945: PUSH
10946: LD_INT 46
10948: PUSH
10949: EMPTY
10950: LIST
10951: LIST
10952: LIST
10953: LIST
10954: PUSH
10955: LD_INT 24
10957: PUSH
10958: LD_INT 3
10960: PUSH
10961: LD_INT 3
10963: PUSH
10964: LD_INT 46
10966: PUSH
10967: EMPTY
10968: LIST
10969: LIST
10970: LIST
10971: LIST
10972: PUSH
10973: LD_INT 24
10975: PUSH
10976: LD_INT 3
10978: PUSH
10979: LD_INT 3
10981: PUSH
10982: LD_INT 46
10984: PUSH
10985: EMPTY
10986: LIST
10987: LIST
10988: LIST
10989: LIST
10990: PUSH
10991: LD_INT 24
10993: PUSH
10994: LD_INT 3
10996: PUSH
10997: LD_INT 3
10999: PUSH
11000: LD_INT 46
11002: PUSH
11003: EMPTY
11004: LIST
11005: LIST
11006: LIST
11007: LIST
11008: PUSH
11009: EMPTY
11010: LIST
11011: LIST
11012: LIST
11013: LIST
11014: LIST
11015: LIST
11016: LIST
11017: PPUSH
11018: CALL 63846 0 2
// end else
11022: GO 11166
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
11024: LD_INT 2
11026: PPUSH
11027: LD_INT 24
11029: PUSH
11030: LD_INT 3
11032: PUSH
11033: LD_INT 3
11035: PUSH
11036: LD_INT 47
11038: PUSH
11039: EMPTY
11040: LIST
11041: LIST
11042: LIST
11043: LIST
11044: PUSH
11045: LD_INT 24
11047: PUSH
11048: LD_INT 3
11050: PUSH
11051: LD_INT 3
11053: PUSH
11054: LD_INT 47
11056: PUSH
11057: EMPTY
11058: LIST
11059: LIST
11060: LIST
11061: LIST
11062: PUSH
11063: LD_INT 24
11065: PUSH
11066: LD_INT 3
11068: PUSH
11069: LD_INT 3
11071: PUSH
11072: LD_INT 47
11074: PUSH
11075: EMPTY
11076: LIST
11077: LIST
11078: LIST
11079: LIST
11080: PUSH
11081: LD_INT 24
11083: PUSH
11084: LD_INT 3
11086: PUSH
11087: LD_INT 3
11089: PUSH
11090: LD_INT 46
11092: PUSH
11093: EMPTY
11094: LIST
11095: LIST
11096: LIST
11097: LIST
11098: PUSH
11099: LD_INT 24
11101: PUSH
11102: LD_INT 3
11104: PUSH
11105: LD_INT 3
11107: PUSH
11108: LD_INT 46
11110: PUSH
11111: EMPTY
11112: LIST
11113: LIST
11114: LIST
11115: LIST
11116: PUSH
11117: LD_INT 24
11119: PUSH
11120: LD_INT 3
11122: PUSH
11123: LD_INT 3
11125: PUSH
11126: LD_INT 46
11128: PUSH
11129: EMPTY
11130: LIST
11131: LIST
11132: LIST
11133: LIST
11134: PUSH
11135: LD_INT 24
11137: PUSH
11138: LD_INT 3
11140: PUSH
11141: LD_INT 3
11143: PUSH
11144: LD_INT 46
11146: PUSH
11147: EMPTY
11148: LIST
11149: LIST
11150: LIST
11151: LIST
11152: PUSH
11153: EMPTY
11154: LIST
11155: LIST
11156: LIST
11157: LIST
11158: LIST
11159: LIST
11160: LIST
11161: PPUSH
11162: CALL 63846 0 2
// end ; wait ( 2 2$00 ) ;
11166: LD_INT 4200
11168: PPUSH
11169: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_siberium_rocket ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 2 ] ;
11173: LD_ADDR_VAR 0 2
11177: PUSH
11178: LD_INT 22
11180: PUSH
11181: LD_INT 3
11183: PUSH
11184: EMPTY
11185: LIST
11186: LIST
11187: PUSH
11188: LD_INT 23
11190: PUSH
11191: LD_INT 3
11193: PUSH
11194: EMPTY
11195: LIST
11196: LIST
11197: PUSH
11198: LD_INT 21
11200: PUSH
11201: LD_INT 2
11203: PUSH
11204: EMPTY
11205: LIST
11206: LIST
11207: PUSH
11208: LD_INT 3
11210: PUSH
11211: LD_INT 34
11213: PUSH
11214: LD_INT 48
11216: PUSH
11217: EMPTY
11218: LIST
11219: LIST
11220: PUSH
11221: EMPTY
11222: LIST
11223: LIST
11224: PUSH
11225: LD_INT 3
11227: PUSH
11228: LD_INT 34
11230: PUSH
11231: LD_INT 51
11233: PUSH
11234: EMPTY
11235: LIST
11236: LIST
11237: PUSH
11238: EMPTY
11239: LIST
11240: LIST
11241: PUSH
11242: LD_INT 3
11244: PUSH
11245: LD_INT 34
11247: PUSH
11248: LD_INT 52
11250: PUSH
11251: EMPTY
11252: LIST
11253: LIST
11254: PUSH
11255: EMPTY
11256: LIST
11257: LIST
11258: PUSH
11259: EMPTY
11260: LIST
11261: LIST
11262: LIST
11263: LIST
11264: LIST
11265: LIST
11266: PPUSH
11267: CALL_OW 69
11271: PUSH
11272: LD_EXP 124
11276: PUSH
11277: LD_INT 2
11279: ARRAY
11280: DIFF
11281: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
11282: LD_ADDR_EXP 121
11286: PUSH
11287: LD_EXP 121
11291: PPUSH
11292: LD_INT 2
11294: PPUSH
11295: LD_EXP 121
11299: PUSH
11300: LD_INT 2
11302: ARRAY
11303: PUSH
11304: LD_VAR 0 2
11308: DIFF
11309: PPUSH
11310: CALL_OW 1
11314: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
11315: LD_ADDR_VAR 0 3
11319: PUSH
11320: LD_INT 0
11322: PPUSH
11323: LD_INT 1
11325: PPUSH
11326: CALL_OW 12
11330: ST_TO_ADDR
// p := 0 ;
11331: LD_ADDR_VAR 0 5
11335: PUSH
11336: LD_INT 0
11338: ST_TO_ADDR
// if target then
11339: LD_VAR 0 3
11343: IFFALSE 11492
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11345: LD_ADDR_VAR 0 2
11349: PUSH
11350: LD_VAR 0 2
11354: PPUSH
11355: LD_INT 50
11357: PUSH
11358: EMPTY
11359: LIST
11360: PPUSH
11361: CALL_OW 72
11365: ST_TO_ADDR
// for i in tmp do
11366: LD_ADDR_VAR 0 1
11370: PUSH
11371: LD_VAR 0 2
11375: PUSH
11376: FOR_IN
11377: IFFALSE 11417
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
11379: LD_VAR 0 1
11383: PPUSH
11384: LD_INT 139
11386: PPUSH
11387: LD_INT 89
11389: PPUSH
11390: CALL_OW 297
11394: PUSH
11395: LD_INT 9
11397: GREATER
11398: IFFALSE 11415
// ComMoveXY ( i , 139 , 89 ) ;
11400: LD_VAR 0 1
11404: PPUSH
11405: LD_INT 139
11407: PPUSH
11408: LD_INT 89
11410: PPUSH
11411: CALL_OW 111
11415: GO 11376
11417: POP
11418: POP
// wait ( 0 0$1 ) ;
11419: LD_INT 35
11421: PPUSH
11422: CALL_OW 67
// p := Inc ( p ) ;
11426: LD_ADDR_VAR 0 5
11430: PUSH
11431: LD_VAR 0 5
11435: PPUSH
11436: CALL 109324 0 1
11440: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11441: LD_VAR 0 2
11445: PPUSH
11446: LD_INT 92
11448: PUSH
11449: LD_INT 139
11451: PUSH
11452: LD_INT 89
11454: PUSH
11455: LD_INT 9
11457: PUSH
11458: EMPTY
11459: LIST
11460: LIST
11461: LIST
11462: LIST
11463: PPUSH
11464: CALL_OW 72
11468: PUSH
11469: LD_VAR 0 2
11473: PUSH
11474: LD_INT 1
11476: MINUS
11477: GREATEREQUAL
11478: PUSH
11479: LD_VAR 0 5
11483: PUSH
11484: LD_INT 60
11486: GREATER
11487: OR
11488: IFFALSE 11345
// end else
11490: GO 11655
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11492: LD_VAR 0 2
11496: PPUSH
11497: LD_VAR 0 4
11501: PUSH
11502: LD_INT 1
11504: ARRAY
11505: PPUSH
11506: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11510: LD_ADDR_VAR 0 2
11514: PUSH
11515: LD_VAR 0 2
11519: PPUSH
11520: LD_INT 50
11522: PUSH
11523: EMPTY
11524: LIST
11525: PPUSH
11526: CALL_OW 72
11530: ST_TO_ADDR
// for i in tmp do
11531: LD_ADDR_VAR 0 1
11535: PUSH
11536: LD_VAR 0 2
11540: PUSH
11541: FOR_IN
11542: IFFALSE 11582
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11544: LD_VAR 0 1
11548: PPUSH
11549: LD_INT 124
11551: PPUSH
11552: LD_INT 139
11554: PPUSH
11555: CALL_OW 297
11559: PUSH
11560: LD_INT 9
11562: GREATER
11563: IFFALSE 11580
// ComMoveXY ( i , 124 , 139 ) ;
11565: LD_VAR 0 1
11569: PPUSH
11570: LD_INT 124
11572: PPUSH
11573: LD_INT 139
11575: PPUSH
11576: CALL_OW 111
11580: GO 11541
11582: POP
11583: POP
// wait ( 0 0$1 ) ;
11584: LD_INT 35
11586: PPUSH
11587: CALL_OW 67
// p := Inc ( p ) ;
11591: LD_ADDR_VAR 0 5
11595: PUSH
11596: LD_VAR 0 5
11600: PPUSH
11601: CALL 109324 0 1
11605: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11606: LD_VAR 0 2
11610: PPUSH
11611: LD_INT 92
11613: PUSH
11614: LD_INT 124
11616: PUSH
11617: LD_INT 139
11619: PUSH
11620: LD_INT 9
11622: PUSH
11623: EMPTY
11624: LIST
11625: LIST
11626: LIST
11627: LIST
11628: PPUSH
11629: CALL_OW 72
11633: PUSH
11634: LD_VAR 0 2
11638: PUSH
11639: LD_INT 1
11641: MINUS
11642: GREATEREQUAL
11643: PUSH
11644: LD_VAR 0 5
11648: PUSH
11649: LD_INT 60
11651: GREATER
11652: OR
11653: IFFALSE 11510
// end ; repeat wait ( 0 0$1 ) ;
11655: LD_INT 35
11657: PPUSH
11658: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11662: LD_ADDR_VAR 0 2
11666: PUSH
11667: LD_VAR 0 2
11671: PPUSH
11672: LD_INT 50
11674: PUSH
11675: EMPTY
11676: LIST
11677: PPUSH
11678: CALL_OW 72
11682: ST_TO_ADDR
// for i in tmp do
11683: LD_ADDR_VAR 0 1
11687: PUSH
11688: LD_VAR 0 2
11692: PUSH
11693: FOR_IN
11694: IFFALSE 11819
// begin if GetWeapon ( i ) = ru_time_lapser then
11696: LD_VAR 0 1
11700: PPUSH
11701: CALL_OW 264
11705: PUSH
11706: LD_INT 49
11708: EQUAL
11709: IFFALSE 11765
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11711: LD_VAR 0 1
11715: PPUSH
11716: LD_INT 2
11718: PUSH
11719: LD_INT 22
11721: PUSH
11722: LD_INT 1
11724: PUSH
11725: EMPTY
11726: LIST
11727: LIST
11728: PUSH
11729: LD_INT 22
11731: PUSH
11732: LD_INT 8
11734: PUSH
11735: EMPTY
11736: LIST
11737: LIST
11738: PUSH
11739: EMPTY
11740: LIST
11741: LIST
11742: LIST
11743: PPUSH
11744: CALL_OW 69
11748: PPUSH
11749: LD_VAR 0 1
11753: PPUSH
11754: CALL_OW 74
11758: PPUSH
11759: CALL_OW 112
11763: GO 11817
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11765: LD_VAR 0 1
11769: PPUSH
11770: LD_INT 2
11772: PUSH
11773: LD_INT 22
11775: PUSH
11776: LD_INT 1
11778: PUSH
11779: EMPTY
11780: LIST
11781: LIST
11782: PUSH
11783: LD_INT 22
11785: PUSH
11786: LD_INT 8
11788: PUSH
11789: EMPTY
11790: LIST
11791: LIST
11792: PUSH
11793: EMPTY
11794: LIST
11795: LIST
11796: LIST
11797: PPUSH
11798: CALL_OW 69
11802: PPUSH
11803: LD_VAR 0 1
11807: PPUSH
11808: CALL_OW 74
11812: PPUSH
11813: CALL_OW 115
// end ;
11817: GO 11693
11819: POP
11820: POP
// until not tmp ;
11821: LD_VAR 0 2
11825: NOT
11826: IFFALSE 11655
// end ;
11828: PPOPN 5
11830: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 7 and Difficulty > 1 do var i , veh , un ;
11831: LD_EXP 15
11835: PUSH
11836: LD_INT 7
11838: GREATEREQUAL
11839: PUSH
11840: LD_OWVAR 67
11844: PUSH
11845: LD_INT 1
11847: GREATER
11848: AND
11849: IFFALSE 12141
11851: GO 11853
11853: DISABLE
11854: LD_INT 0
11856: PPUSH
11857: PPUSH
11858: PPUSH
// begin ruMobile := [ ] ;
11859: LD_ADDR_EXP 78
11863: PUSH
11864: EMPTY
11865: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 ] [ Difficulty - 1 ] do
11866: LD_ADDR_VAR 0 1
11870: PUSH
11871: DOUBLE
11872: LD_INT 1
11874: DEC
11875: ST_TO_ADDR
11876: LD_INT 4
11878: PUSH
11879: LD_INT 5
11881: PUSH
11882: LD_INT 6
11884: PUSH
11885: EMPTY
11886: LIST
11887: LIST
11888: LIST
11889: PUSH
11890: LD_OWVAR 67
11894: PUSH
11895: LD_INT 1
11897: MINUS
11898: ARRAY
11899: PUSH
11900: FOR_TO
11901: IFFALSE 12139
// begin uc_side := 3 ;
11903: LD_ADDR_OWVAR 20
11907: PUSH
11908: LD_INT 3
11910: ST_TO_ADDR
// uc_nation := 1 ;
11911: LD_ADDR_OWVAR 21
11915: PUSH
11916: LD_INT 1
11918: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_laser , us_rocket_launcher ] [ i mod 2 + 1 ] , 100 ) ;
11919: LD_INT 5
11921: PPUSH
11922: LD_INT 3
11924: PPUSH
11925: LD_INT 1
11927: PPUSH
11928: LD_INT 9
11930: PUSH
11931: LD_INT 7
11933: PUSH
11934: EMPTY
11935: LIST
11936: LIST
11937: PUSH
11938: LD_VAR 0 1
11942: PUSH
11943: LD_INT 2
11945: MOD
11946: PUSH
11947: LD_INT 1
11949: PLUS
11950: ARRAY
11951: PPUSH
11952: LD_INT 100
11954: PPUSH
11955: CALL 75112 0 5
// veh := CreateVehicle ;
11959: LD_ADDR_VAR 0 2
11963: PUSH
11964: CALL_OW 45
11968: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11969: LD_VAR 0 2
11973: PPUSH
11974: LD_INT 3
11976: PPUSH
11977: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11981: LD_VAR 0 2
11985: PPUSH
11986: LD_INT 29
11988: PPUSH
11989: LD_INT 0
11991: PPUSH
11992: CALL_OW 49
// uc_nation := 3 ;
11996: LD_ADDR_OWVAR 21
12000: PUSH
12001: LD_INT 3
12003: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
12004: LD_INT 0
12006: PPUSH
12007: LD_INT 10
12009: PPUSH
12010: CALL_OW 383
// un := CreateHuman ;
12014: LD_ADDR_VAR 0 3
12018: PUSH
12019: CALL_OW 44
12023: ST_TO_ADDR
// SetTag ( un , 105 ) ;
12024: LD_VAR 0 3
12028: PPUSH
12029: LD_INT 105
12031: PPUSH
12032: CALL_OW 109
// if GetSkill ( un , skill_mechanical ) < [ 8 , 9 , 10 ] [ Difficulty ] then
12036: LD_VAR 0 3
12040: PPUSH
12041: LD_INT 3
12043: PPUSH
12044: CALL_OW 259
12048: PUSH
12049: LD_INT 8
12051: PUSH
12052: LD_INT 9
12054: PUSH
12055: LD_INT 10
12057: PUSH
12058: EMPTY
12059: LIST
12060: LIST
12061: LIST
12062: PUSH
12063: LD_OWVAR 67
12067: ARRAY
12068: LESS
12069: IFFALSE 12103
// SetSkill ( un , skill_mechanical , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
12071: LD_VAR 0 3
12075: PPUSH
12076: LD_INT 3
12078: PPUSH
12079: LD_INT 8
12081: PUSH
12082: LD_INT 9
12084: PUSH
12085: LD_INT 10
12087: PUSH
12088: EMPTY
12089: LIST
12090: LIST
12091: LIST
12092: PUSH
12093: LD_OWVAR 67
12097: ARRAY
12098: PPUSH
12099: CALL_OW 237
// PlaceHumanInUnit ( un , veh ) ;
12103: LD_VAR 0 3
12107: PPUSH
12108: LD_VAR 0 2
12112: PPUSH
12113: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
12117: LD_ADDR_EXP 78
12121: PUSH
12122: LD_EXP 78
12126: PPUSH
12127: LD_VAR 0 2
12131: PPUSH
12132: CALL 107963 0 2
12136: ST_TO_ADDR
// end ;
12137: GO 11900
12139: POP
12140: POP
// end ;
12141: PPOPN 3
12143: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
12144: LD_EXP 78
12148: IFFALSE 12657
12150: GO 12152
12152: DISABLE
12153: LD_INT 0
12155: PPUSH
12156: PPUSH
12157: PPUSH
// begin enable ;
12158: ENABLE
// if not ruMobile then
12159: LD_EXP 78
12163: NOT
12164: IFFALSE 12169
// begin disable ;
12166: DISABLE
// exit ;
12167: GO 12657
// end ; for i in ruMobile do
12169: LD_ADDR_VAR 0 1
12173: PUSH
12174: LD_EXP 78
12178: PUSH
12179: FOR_IN
12180: IFFALSE 12655
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
12182: LD_VAR 0 1
12186: PPUSH
12187: CALL_OW 302
12191: NOT
12192: PUSH
12193: LD_VAR 0 1
12197: PPUSH
12198: CALL_OW 255
12202: PUSH
12203: LD_INT 3
12205: NONEQUAL
12206: OR
12207: IFFALSE 12227
// begin ruMobile := ruMobile diff i ;
12209: LD_ADDR_EXP 78
12213: PUSH
12214: LD_EXP 78
12218: PUSH
12219: LD_VAR 0 1
12223: DIFF
12224: ST_TO_ADDR
// continue ;
12225: GO 12179
// end ; if GetTag ( i ) = 300 then
12227: LD_VAR 0 1
12231: PPUSH
12232: CALL_OW 110
12236: PUSH
12237: LD_INT 300
12239: EQUAL
12240: IFFALSE 12290
// begin ComMoveXY ( i , 160 , 81 ) ;
12242: LD_VAR 0 1
12246: PPUSH
12247: LD_INT 160
12249: PPUSH
12250: LD_INT 81
12252: PPUSH
12253: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
12257: LD_VAR 0 1
12261: PPUSH
12262: LD_INT 160
12264: PPUSH
12265: LD_INT 81
12267: PPUSH
12268: CALL_OW 297
12272: PUSH
12273: LD_INT 8
12275: LESS
12276: IFFALSE 12290
// SetTag ( i , 301 ) ;
12278: LD_VAR 0 1
12282: PPUSH
12283: LD_INT 301
12285: PPUSH
12286: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
12290: LD_VAR 0 1
12294: PPUSH
12295: CALL_OW 110
12299: PUSH
12300: LD_INT 301
12302: EQUAL
12303: IFFALSE 12346
// begin if not IsInArea ( i , ruMobileParkingArea ) then
12305: LD_VAR 0 1
12309: PPUSH
12310: LD_INT 33
12312: PPUSH
12313: CALL_OW 308
12317: NOT
12318: IFFALSE 12334
// ComMoveToArea ( i , ruMobileParkingArea ) else
12320: LD_VAR 0 1
12324: PPUSH
12325: LD_INT 33
12327: PPUSH
12328: CALL_OW 113
12332: GO 12346
// SetTag ( i , 302 ) ;
12334: LD_VAR 0 1
12338: PPUSH
12339: LD_INT 302
12341: PPUSH
12342: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
12346: LD_VAR 0 1
12350: PPUSH
12351: CALL_OW 110
12355: PUSH
12356: LD_INT 302
12358: EQUAL
12359: IFFALSE 12489
// begin if GetLives ( i ) < 1000 then
12361: LD_VAR 0 1
12365: PPUSH
12366: CALL_OW 256
12370: PUSH
12371: LD_INT 1000
12373: LESS
12374: IFFALSE 12466
// begin if not IsDrivenBy ( i ) then
12376: LD_VAR 0 1
12380: PPUSH
12381: CALL_OW 311
12385: NOT
12386: IFFALSE 12390
// continue ;
12388: GO 12179
// mech := IsDrivenBy ( i ) ;
12390: LD_ADDR_VAR 0 2
12394: PUSH
12395: LD_VAR 0 1
12399: PPUSH
12400: CALL_OW 311
12404: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
12405: LD_VAR 0 2
12409: PPUSH
12410: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
12414: LD_VAR 0 2
12418: PPUSH
12419: LD_VAR 0 1
12423: PPUSH
12424: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
12428: LD_INT 35
12430: PPUSH
12431: CALL_OW 67
// until GetLives ( i ) = 1000 ;
12435: LD_VAR 0 1
12439: PPUSH
12440: CALL_OW 256
12444: PUSH
12445: LD_INT 1000
12447: EQUAL
12448: IFFALSE 12428
// ComEnterUnit ( mech , i ) ;
12450: LD_VAR 0 2
12454: PPUSH
12455: LD_VAR 0 1
12459: PPUSH
12460: CALL_OW 120
// end else
12464: GO 12489
// if IsDrivenBy ( i ) then
12466: LD_VAR 0 1
12470: PPUSH
12471: CALL_OW 311
12475: IFFALSE 12489
// SetTag ( i , 0 ) ;
12477: LD_VAR 0 1
12481: PPUSH
12482: LD_INT 0
12484: PPUSH
12485: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
12489: LD_VAR 0 1
12493: PPUSH
12494: CALL_OW 110
12498: PUSH
12499: LD_INT 300
12501: LESS
12502: IFFALSE 12653
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
12504: LD_ADDR_VAR 0 3
12508: PUSH
12509: LD_INT 4
12511: PPUSH
12512: LD_INT 81
12514: PUSH
12515: LD_INT 3
12517: PUSH
12518: EMPTY
12519: LIST
12520: LIST
12521: PPUSH
12522: CALL_OW 70
12526: ST_TO_ADDR
// if GetLives ( i ) < 650 then
12527: LD_VAR 0 1
12531: PPUSH
12532: CALL_OW 256
12536: PUSH
12537: LD_INT 650
12539: LESS
12540: IFFALSE 12565
// begin ComStop ( i ) ;
12542: LD_VAR 0 1
12546: PPUSH
12547: CALL_OW 141
// SetTag ( i , 300 ) ;
12551: LD_VAR 0 1
12555: PPUSH
12556: LD_INT 300
12558: PPUSH
12559: CALL_OW 109
// continue ;
12563: GO 12179
// end ; if enemy then
12565: LD_VAR 0 3
12569: IFFALSE 12609
// begin if not HasTask ( i ) then
12571: LD_VAR 0 1
12575: PPUSH
12576: CALL_OW 314
12580: NOT
12581: IFFALSE 12607
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
12583: LD_VAR 0 1
12587: PPUSH
12588: LD_VAR 0 3
12592: PPUSH
12593: LD_VAR 0 1
12597: PPUSH
12598: CALL_OW 74
12602: PPUSH
12603: CALL_OW 115
// end else
12607: GO 12653
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
12609: LD_VAR 0 1
12613: PPUSH
12614: LD_INT 158
12616: PUSH
12617: LD_INT 61
12619: PUSH
12620: EMPTY
12621: LIST
12622: LIST
12623: PUSH
12624: LD_INT 98
12626: PUSH
12627: LD_INT 100
12629: PUSH
12630: EMPTY
12631: LIST
12632: LIST
12633: PUSH
12634: LD_INT 78
12636: PUSH
12637: LD_INT 93
12639: PUSH
12640: EMPTY
12641: LIST
12642: LIST
12643: PUSH
12644: EMPTY
12645: LIST
12646: LIST
12647: LIST
12648: PPUSH
12649: CALL 110567 0 2
// end ; end ;
12653: GO 12179
12655: POP
12656: POP
// end ; end_of_file
12657: PPOPN 3
12659: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport , b ; begin
12660: LD_INT 0
12662: PPUSH
12663: PPUSH
12664: PPUSH
12665: PPUSH
12666: PPUSH
12667: PPUSH
12668: PPUSH
// if Difficulty = 1 then
12669: LD_OWVAR 67
12673: PUSH
12674: LD_INT 1
12676: EQUAL
12677: IFFALSE 12715
// for i in FilterAllUnits ( [ f_inarea , delBuildingsArea ] ) do
12679: LD_ADDR_VAR 0 2
12683: PUSH
12684: LD_INT 95
12686: PUSH
12687: LD_INT 34
12689: PUSH
12690: EMPTY
12691: LIST
12692: LIST
12693: PPUSH
12694: CALL_OW 69
12698: PUSH
12699: FOR_IN
12700: IFFALSE 12713
// RemoveUnit ( i ) ;
12702: LD_VAR 0 2
12706: PPUSH
12707: CALL_OW 64
12711: GO 12699
12713: POP
12714: POP
// SetInvulnrability ( alien , true ) ;
12715: LD_INT 1
12717: PPUSH
12718: LD_INT 1
12720: PPUSH
12721: CALL_OW 607
// side := 7 ;
12725: LD_ADDR_VAR 0 5
12729: PUSH
12730: LD_INT 7
12732: ST_TO_ADDR
// uc_side := side ;
12733: LD_ADDR_OWVAR 20
12737: PUSH
12738: LD_VAR 0 5
12742: ST_TO_ADDR
// uc_nation := 1 ;
12743: LD_ADDR_OWVAR 21
12747: PUSH
12748: LD_INT 1
12750: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
12751: LD_ADDR_VAR 0 2
12755: PUSH
12756: LD_INT 22
12758: PUSH
12759: LD_VAR 0 5
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: PUSH
12768: LD_INT 21
12770: PUSH
12771: LD_INT 3
12773: PUSH
12774: EMPTY
12775: LIST
12776: LIST
12777: PUSH
12778: EMPTY
12779: LIST
12780: LIST
12781: PPUSH
12782: CALL_OW 69
12786: PUSH
12787: FOR_IN
12788: IFFALSE 12804
// SetBLevel ( i , 10 ) ;
12790: LD_VAR 0 2
12794: PPUSH
12795: LD_INT 10
12797: PPUSH
12798: CALL_OW 241
12802: GO 12787
12804: POP
12805: POP
// base := GetBase ( al_depot ) ;
12806: LD_ADDR_VAR 0 4
12810: PUSH
12811: LD_INT 2
12813: PPUSH
12814: CALL_OW 274
12818: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
12819: LD_ADDR_VAR 0 6
12823: PUSH
12824: LD_INT 22
12826: PUSH
12827: LD_VAR 0 5
12831: PUSH
12832: EMPTY
12833: LIST
12834: LIST
12835: PUSH
12836: LD_INT 30
12838: PUSH
12839: LD_INT 34
12841: PUSH
12842: EMPTY
12843: LIST
12844: LIST
12845: PUSH
12846: EMPTY
12847: LIST
12848: LIST
12849: PPUSH
12850: CALL_OW 69
12854: ST_TO_ADDR
// if teleport then
12855: LD_VAR 0 6
12859: IFFALSE 12880
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
12861: LD_VAR 0 6
12865: PUSH
12866: LD_INT 1
12868: ARRAY
12869: PPUSH
12870: LD_INT 262
12872: PPUSH
12873: LD_INT 119
12875: PPUSH
12876: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
12880: LD_VAR 0 4
12884: PPUSH
12885: LD_INT 1
12887: PPUSH
12888: LD_INT 19500
12890: PPUSH
12891: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
12895: LD_VAR 0 4
12899: PPUSH
12900: LD_INT 2
12902: PPUSH
12903: LD_INT 200
12905: PPUSH
12906: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
12910: LD_VAR 0 4
12914: PPUSH
12915: LD_INT 3
12917: PPUSH
12918: LD_INT 650
12920: PPUSH
12921: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12925: LD_ADDR_EXP 79
12929: PUSH
12930: LD_STRING Roth
12932: PPUSH
12933: CALL_OW 25
12937: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12938: LD_ADDR_EXP 80
12942: PUSH
12943: LD_STRING Simms
12945: PPUSH
12946: LD_EXP 1
12950: NOT
12951: PPUSH
12952: LD_STRING 10c_
12954: PPUSH
12955: CALL 70272 0 3
12959: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
12960: LD_EXP 80
12964: PPUSH
12965: LD_INT 4
12967: PPUSH
12968: CALL_OW 336
// if not Simms then
12972: LD_EXP 80
12976: NOT
12977: IFFALSE 13007
// begin uc_nation := 1 ;
12979: LD_ADDR_OWVAR 21
12983: PUSH
12984: LD_INT 1
12986: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12987: LD_INT 2
12989: PPUSH
12990: LD_INT 10
12992: PPUSH
12993: CALL_OW 384
// Simms := CreateHuman ;
12997: LD_ADDR_EXP 80
13001: PUSH
13002: CALL_OW 44
13006: ST_TO_ADDR
// end ; uc_nation := 3 ;
13007: LD_ADDR_OWVAR 21
13011: PUSH
13012: LD_INT 3
13014: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
13015: LD_ADDR_EXP 81
13019: PUSH
13020: LD_STRING Kirilenkova
13022: PPUSH
13023: CALL_OW 25
13027: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
13028: LD_ADDR_EXP 95
13032: PUSH
13033: LD_STRING Oblukov
13035: PPUSH
13036: CALL_OW 25
13040: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
13041: LD_ADDR_EXP 82
13045: PUSH
13046: LD_STRING Dolgov
13048: PPUSH
13049: CALL_OW 25
13053: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
13054: LD_ADDR_EXP 83
13058: PUSH
13059: LD_STRING Petrosyan
13061: PPUSH
13062: CALL_OW 25
13066: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
13067: LD_ADDR_EXP 94
13071: PUSH
13072: LD_STRING Scholtze
13074: PPUSH
13075: CALL_OW 25
13079: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
13080: LD_ADDR_EXP 93
13084: PUSH
13085: LD_STRING Kapitsova
13087: PPUSH
13088: CALL_OW 25
13092: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
13093: LD_ADDR_EXP 84
13097: PUSH
13098: LD_STRING Petrovova
13100: PPUSH
13101: CALL_OW 25
13105: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
13106: LD_ADDR_EXP 85
13110: PUSH
13111: LD_STRING Kuzmov
13113: PPUSH
13114: CALL_OW 25
13118: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
13119: LD_ADDR_EXP 92
13123: PUSH
13124: LD_STRING Karamazov
13126: PPUSH
13127: CALL_OW 25
13131: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
13132: LD_STRING 13_Lipshchin_1
13134: PPUSH
13135: LD_INT 0
13137: PPUSH
13138: CALL_OW 30
13142: IFFALSE 13157
// Lipshchin := NewCharacter ( Lipshchin ) ;
13144: LD_ADDR_EXP 86
13148: PUSH
13149: LD_STRING Lipshchin
13151: PPUSH
13152: CALL_OW 25
13156: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
13157: LD_STRING 13_Titov_1
13159: PPUSH
13160: LD_INT 0
13162: PPUSH
13163: CALL_OW 30
13167: IFFALSE 13182
// Titov := NewCharacter ( Titov ) ;
13169: LD_ADDR_EXP 88
13173: PUSH
13174: LD_STRING Titov
13176: PPUSH
13177: CALL_OW 25
13181: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
13182: LD_STRING 13_Gnyevko_1
13184: PPUSH
13185: LD_INT 0
13187: PPUSH
13188: CALL_OW 30
13192: IFFALSE 13207
// Gnyevko := NewCharacter ( Gnyevko ) ;
13194: LD_ADDR_EXP 87
13198: PUSH
13199: LD_STRING Gnyevko
13201: PPUSH
13202: CALL_OW 25
13206: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
13207: LD_STRING 13_Xavier_1
13209: PPUSH
13210: LD_INT 0
13212: PPUSH
13213: CALL_OW 30
13217: IFFALSE 13232
// Xavier := NewCharacter ( Xavier2 ) ;
13219: LD_ADDR_EXP 89
13223: PUSH
13224: LD_STRING Xavier2
13226: PPUSH
13227: CALL_OW 25
13231: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
13232: LD_STRING 13_Belkov_1
13234: PPUSH
13235: LD_INT 0
13237: PPUSH
13238: CALL_OW 30
13242: IFFALSE 13257
// Belkov := NewCharacter ( Belkov ) ;
13244: LD_ADDR_EXP 90
13248: PUSH
13249: LD_STRING Belkov
13251: PPUSH
13252: CALL_OW 25
13256: ST_TO_ADDR
// if not BurlakStatus then
13257: LD_EXP 9
13261: NOT
13262: IFFALSE 13277
// Burlak = NewCharacter ( Burlak ) ;
13264: LD_ADDR_EXP 91
13268: PUSH
13269: LD_STRING Burlak
13271: PPUSH
13272: CALL_OW 25
13276: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
13277: LD_ADDR_VAR 0 3
13281: PUSH
13282: LD_EXP 79
13286: PUSH
13287: LD_EXP 81
13291: PUSH
13292: LD_EXP 95
13296: PUSH
13297: LD_EXP 82
13301: PUSH
13302: LD_EXP 83
13306: PUSH
13307: LD_EXP 94
13311: PUSH
13312: LD_EXP 93
13316: PUSH
13317: LD_EXP 84
13321: PUSH
13322: LD_EXP 85
13326: PUSH
13327: LD_EXP 92
13331: PUSH
13332: EMPTY
13333: LIST
13334: LIST
13335: LIST
13336: LIST
13337: LIST
13338: LIST
13339: LIST
13340: LIST
13341: LIST
13342: LIST
13343: ST_TO_ADDR
// if Simms then
13344: LD_EXP 80
13348: IFFALSE 13366
// tmp := tmp ^ Simms ;
13350: LD_ADDR_VAR 0 3
13354: PUSH
13355: LD_VAR 0 3
13359: PUSH
13360: LD_EXP 80
13364: ADD
13365: ST_TO_ADDR
// if Titov then
13366: LD_EXP 88
13370: IFFALSE 13388
// tmp := tmp ^ Titov ;
13372: LD_ADDR_VAR 0 3
13376: PUSH
13377: LD_VAR 0 3
13381: PUSH
13382: LD_EXP 88
13386: ADD
13387: ST_TO_ADDR
// if Lipshchin then
13388: LD_EXP 86
13392: IFFALSE 13410
// tmp := tmp ^ Lipshchin ;
13394: LD_ADDR_VAR 0 3
13398: PUSH
13399: LD_VAR 0 3
13403: PUSH
13404: LD_EXP 86
13408: ADD
13409: ST_TO_ADDR
// if Gnyevko then
13410: LD_EXP 87
13414: IFFALSE 13432
// tmp := tmp ^ Gnyevko ;
13416: LD_ADDR_VAR 0 3
13420: PUSH
13421: LD_VAR 0 3
13425: PUSH
13426: LD_EXP 87
13430: ADD
13431: ST_TO_ADDR
// if Xavier then
13432: LD_EXP 89
13436: IFFALSE 13454
// tmp := tmp ^ Xavier ;
13438: LD_ADDR_VAR 0 3
13442: PUSH
13443: LD_VAR 0 3
13447: PUSH
13448: LD_EXP 89
13452: ADD
13453: ST_TO_ADDR
// if Belkov then
13454: LD_EXP 90
13458: IFFALSE 13476
// tmp := tmp ^ Belkov ;
13460: LD_ADDR_VAR 0 3
13464: PUSH
13465: LD_VAR 0 3
13469: PUSH
13470: LD_EXP 90
13474: ADD
13475: ST_TO_ADDR
// if Burlak then
13476: LD_EXP 91
13480: IFFALSE 13498
// tmp := tmp ^ Burlak ;
13482: LD_ADDR_VAR 0 3
13486: PUSH
13487: LD_VAR 0 3
13491: PUSH
13492: LD_EXP 91
13496: ADD
13497: ST_TO_ADDR
// for i = 1 to 11 do
13498: LD_ADDR_VAR 0 2
13502: PUSH
13503: DOUBLE
13504: LD_INT 1
13506: DEC
13507: ST_TO_ADDR
13508: LD_INT 11
13510: PUSH
13511: FOR_TO
13512: IFFALSE 13580
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
13514: LD_ADDR_OWVAR 21
13518: PUSH
13519: LD_INT 1
13521: PUSH
13522: LD_INT 3
13524: PUSH
13525: EMPTY
13526: LIST
13527: LIST
13528: PUSH
13529: LD_INT 1
13531: PPUSH
13532: LD_INT 2
13534: PPUSH
13535: CALL_OW 12
13539: ARRAY
13540: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 10 ) ;
13541: LD_INT 0
13543: PPUSH
13544: LD_INT 1
13546: PPUSH
13547: LD_INT 4
13549: PPUSH
13550: CALL_OW 12
13554: PPUSH
13555: LD_INT 10
13557: PPUSH
13558: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
13562: LD_ADDR_VAR 0 3
13566: PUSH
13567: LD_VAR 0 3
13571: PUSH
13572: CALL_OW 44
13576: ADD
13577: ST_TO_ADDR
// end ;
13578: GO 13511
13580: POP
13581: POP
// for i in tmp do
13582: LD_ADDR_VAR 0 2
13586: PUSH
13587: LD_VAR 0 3
13591: PUSH
13592: FOR_IN
13593: IFFALSE 13618
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
13595: LD_VAR 0 2
13599: PPUSH
13600: LD_INT 260
13602: PPUSH
13603: LD_INT 235
13605: PPUSH
13606: LD_INT 8
13608: PPUSH
13609: LD_INT 0
13611: PPUSH
13612: CALL_OW 50
13616: GO 13592
13618: POP
13619: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
13620: LD_ADDR_EXP 102
13624: PUSH
13625: LD_EXP 102
13629: PPUSH
13630: LD_INT 1
13632: PPUSH
13633: LD_INT 22
13635: PUSH
13636: LD_VAR 0 5
13640: PUSH
13641: EMPTY
13642: LIST
13643: LIST
13644: PUSH
13645: LD_INT 3
13647: PUSH
13648: LD_INT 21
13650: PUSH
13651: LD_INT 2
13653: PUSH
13654: EMPTY
13655: LIST
13656: LIST
13657: PUSH
13658: EMPTY
13659: LIST
13660: LIST
13661: PUSH
13662: EMPTY
13663: LIST
13664: LIST
13665: PPUSH
13666: CALL_OW 69
13670: PUSH
13671: LD_EXP 79
13675: PUSH
13676: LD_EXP 80
13680: PUSH
13681: EMPTY
13682: LIST
13683: LIST
13684: DIFF
13685: PPUSH
13686: CALL_OW 1
13690: ST_TO_ADDR
// uc_side := 0 ;
13691: LD_ADDR_OWVAR 20
13695: PUSH
13696: LD_INT 0
13698: ST_TO_ADDR
// uc_nation := 0 ;
13699: LD_ADDR_OWVAR 21
13703: PUSH
13704: LD_INT 0
13706: ST_TO_ADDR
// for i = 1 to 5 do
13707: LD_ADDR_VAR 0 2
13711: PUSH
13712: DOUBLE
13713: LD_INT 1
13715: DEC
13716: ST_TO_ADDR
13717: LD_INT 5
13719: PUSH
13720: FOR_TO
13721: IFFALSE 13758
// begin InitHc ;
13723: CALL_OW 19
// hc_class := class_apeman ;
13727: LD_ADDR_OWVAR 28
13731: PUSH
13732: LD_INT 12
13734: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
13735: CALL_OW 44
13739: PPUSH
13740: LD_INT 299
13742: PPUSH
13743: LD_INT 229
13745: PPUSH
13746: LD_INT 10
13748: PPUSH
13749: LD_INT 0
13751: PPUSH
13752: CALL_OW 50
// end ;
13756: GO 13720
13758: POP
13759: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
13760: LD_EXP 79
13764: PPUSH
13765: LD_INT 259
13767: PPUSH
13768: LD_INT 235
13770: PPUSH
13771: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
13775: LD_EXP 79
13779: PPUSH
13780: LD_INT 262
13782: PPUSH
13783: LD_INT 235
13785: PPUSH
13786: CALL_OW 178
// if Simms then
13790: LD_EXP 80
13794: IFFALSE 13825
// begin ComMoveXY ( Simms , 262 , 235 ) ;
13796: LD_EXP 80
13800: PPUSH
13801: LD_INT 262
13803: PPUSH
13804: LD_INT 235
13806: PPUSH
13807: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
13811: LD_EXP 80
13815: PPUSH
13816: LD_EXP 79
13820: PPUSH
13821: CALL_OW 179
// end ; uc_side := 7 ;
13825: LD_ADDR_OWVAR 20
13829: PUSH
13830: LD_INT 7
13832: ST_TO_ADDR
// uc_nation := 1 ;
13833: LD_ADDR_OWVAR 21
13837: PUSH
13838: LD_INT 1
13840: ST_TO_ADDR
// bc_type := b_control_tower ;
13841: LD_ADDR_OWVAR 42
13845: PUSH
13846: LD_INT 36
13848: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 268 , 251 , 4 ) ;
13849: LD_ADDR_VAR 0 7
13853: PUSH
13854: LD_INT 268
13856: PPUSH
13857: LD_INT 251
13859: PPUSH
13860: LD_INT 4
13862: PPUSH
13863: CALL_OW 47
13867: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
13868: LD_INT 0
13870: PPUSH
13871: LD_INT 10
13873: PPUSH
13874: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , b ) ;
13878: CALL_OW 44
13882: PPUSH
13883: LD_VAR 0 7
13887: PPUSH
13888: CALL_OW 52
// end ;
13892: LD_VAR 0 1
13896: RET
// every 9 9$00 trigger allianceActive and not allianceDestroyed and FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_lab_full ] ] ) do var i , tmp , target ;
13897: LD_EXP 31
13901: PUSH
13902: LD_EXP 23
13906: NOT
13907: AND
13908: PUSH
13909: LD_INT 22
13911: PUSH
13912: LD_INT 7
13914: PUSH
13915: EMPTY
13916: LIST
13917: LIST
13918: PUSH
13919: LD_INT 30
13921: PUSH
13922: LD_INT 8
13924: PUSH
13925: EMPTY
13926: LIST
13927: LIST
13928: PUSH
13929: EMPTY
13930: LIST
13931: LIST
13932: PPUSH
13933: CALL_OW 69
13937: AND
13938: IFFALSE 14166
13940: GO 13942
13942: DISABLE
13943: LD_INT 0
13945: PPUSH
13946: PPUSH
13947: PPUSH
// begin enable ;
13948: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
13949: LD_ADDR_VAR 0 2
13953: PUSH
13954: LD_INT 81
13956: PUSH
13957: LD_INT 7
13959: PUSH
13960: EMPTY
13961: LIST
13962: LIST
13963: PUSH
13964: LD_INT 2
13966: PUSH
13967: LD_INT 32
13969: PUSH
13970: LD_INT 3
13972: PUSH
13973: EMPTY
13974: LIST
13975: LIST
13976: PUSH
13977: LD_INT 30
13979: PUSH
13980: LD_INT 30
13982: PUSH
13983: EMPTY
13984: LIST
13985: LIST
13986: PUSH
13987: LD_INT 30
13989: PUSH
13990: LD_INT 28
13992: PUSH
13993: EMPTY
13994: LIST
13995: LIST
13996: PUSH
13997: LD_INT 34
13999: PUSH
14000: LD_INT 49
14002: PUSH
14003: EMPTY
14004: LIST
14005: LIST
14006: PUSH
14007: LD_INT 34
14009: PUSH
14010: LD_INT 10
14012: PUSH
14013: EMPTY
14014: LIST
14015: LIST
14016: PUSH
14017: LD_INT 34
14019: PUSH
14020: LD_INT 8
14022: PUSH
14023: EMPTY
14024: LIST
14025: LIST
14026: PUSH
14027: EMPTY
14028: LIST
14029: LIST
14030: LIST
14031: LIST
14032: LIST
14033: LIST
14034: LIST
14035: PUSH
14036: EMPTY
14037: LIST
14038: LIST
14039: PPUSH
14040: CALL_OW 69
14044: ST_TO_ADDR
// if not tmp then
14045: LD_VAR 0 2
14049: NOT
14050: IFFALSE 14054
// exit ;
14052: GO 14166
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
14054: LD_VAR 0 2
14058: PPUSH
14059: LD_INT 34
14061: PUSH
14062: LD_INT 8
14064: PUSH
14065: EMPTY
14066: LIST
14067: LIST
14068: PPUSH
14069: CALL_OW 72
14073: IFFALSE 14106
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
14075: LD_ADDR_VAR 0 3
14079: PUSH
14080: LD_VAR 0 2
14084: PPUSH
14085: LD_INT 34
14087: PUSH
14088: LD_INT 8
14090: PUSH
14091: EMPTY
14092: LIST
14093: LIST
14094: PPUSH
14095: CALL_OW 72
14099: PUSH
14100: LD_INT 1
14102: ARRAY
14103: ST_TO_ADDR
14104: GO 14130
// target := tmp [ rand ( 1 , tmp ) ] ;
14106: LD_ADDR_VAR 0 3
14110: PUSH
14111: LD_VAR 0 2
14115: PUSH
14116: LD_INT 1
14118: PPUSH
14119: LD_VAR 0 2
14123: PPUSH
14124: CALL_OW 12
14128: ARRAY
14129: ST_TO_ADDR
// if GetSide ( target ) = 1 then
14130: LD_VAR 0 3
14134: PPUSH
14135: CALL_OW 255
14139: PUSH
14140: LD_INT 1
14142: EQUAL
14143: IFFALSE 14154
// CenterNowOnUnits ( target ) ;
14145: LD_VAR 0 3
14149: PPUSH
14150: CALL_OW 87
// SetLives ( target , 0 ) ;
14154: LD_VAR 0 3
14158: PPUSH
14159: LD_INT 0
14161: PPUSH
14162: CALL_OW 234
// end ;
14166: PPOPN 3
14168: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
14169: LD_EXP 23
14173: NOT
14174: PUSH
14175: LD_EXP 31
14179: AND
14180: IFFALSE 14696
14182: GO 14184
14184: DISABLE
14185: LD_INT 0
14187: PPUSH
14188: PPUSH
14189: PPUSH
// begin uc_side := 7 ;
14190: LD_ADDR_OWVAR 20
14194: PUSH
14195: LD_INT 7
14197: ST_TO_ADDR
// uc_nation := 1 ;
14198: LD_ADDR_OWVAR 21
14202: PUSH
14203: LD_INT 1
14205: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] , [ 94 , 114 ] ] ) ;
14206: LD_ADDR_VAR 0 3
14210: PUSH
14211: LD_INT 125
14213: PUSH
14214: LD_INT 163
14216: PUSH
14217: EMPTY
14218: LIST
14219: LIST
14220: PUSH
14221: LD_INT 185
14223: PUSH
14224: LD_INT 168
14226: PUSH
14227: EMPTY
14228: LIST
14229: LIST
14230: PUSH
14231: LD_INT 111
14233: PUSH
14234: LD_INT 97
14236: PUSH
14237: EMPTY
14238: LIST
14239: LIST
14240: PUSH
14241: LD_INT 94
14243: PUSH
14244: LD_INT 114
14246: PUSH
14247: EMPTY
14248: LIST
14249: LIST
14250: PUSH
14251: EMPTY
14252: LIST
14253: LIST
14254: LIST
14255: LIST
14256: PPUSH
14257: CALL 108068 0 1
14261: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
14262: LD_ADDR_EXP 96
14266: PUSH
14267: EMPTY
14268: ST_TO_ADDR
// for i = 1 to Difficulty do
14269: LD_ADDR_VAR 0 1
14273: PUSH
14274: DOUBLE
14275: LD_INT 1
14277: DEC
14278: ST_TO_ADDR
14279: LD_OWVAR 67
14283: PUSH
14284: FOR_TO
14285: IFFALSE 14443
// begin InitHc ;
14287: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
14291: LD_INT 0
14293: PPUSH
14294: LD_INT 8
14296: PPUSH
14297: CALL_OW 381
// un := CreateHuman ;
14301: LD_ADDR_VAR 0 2
14305: PUSH
14306: CALL_OW 44
14310: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
14311: LD_VAR 0 2
14315: PPUSH
14316: LD_INT 258
14318: PPUSH
14319: LD_INT 267
14321: PPUSH
14322: LD_INT 4
14324: PPUSH
14325: LD_INT 0
14327: PPUSH
14328: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
14332: LD_ADDR_EXP 96
14336: PUSH
14337: LD_EXP 96
14341: PUSH
14342: LD_VAR 0 2
14346: UNION
14347: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
14348: LD_VAR 0 2
14352: PPUSH
14353: LD_VAR 0 3
14357: PUSH
14358: LD_VAR 0 1
14362: ARRAY
14363: PUSH
14364: LD_INT 1
14366: ARRAY
14367: PPUSH
14368: LD_VAR 0 3
14372: PUSH
14373: LD_VAR 0 1
14377: ARRAY
14378: PUSH
14379: LD_INT 2
14381: ARRAY
14382: PPUSH
14383: LD_INT 4
14385: PPUSH
14386: LD_INT 1
14388: PPUSH
14389: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
14393: LD_VAR 0 2
14397: PPUSH
14398: LD_VAR 0 3
14402: PUSH
14403: LD_VAR 0 1
14407: ARRAY
14408: PUSH
14409: LD_INT 1
14411: ARRAY
14412: PPUSH
14413: LD_VAR 0 3
14417: PUSH
14418: LD_VAR 0 1
14422: ARRAY
14423: PUSH
14424: LD_INT 2
14426: ARRAY
14427: PPUSH
14428: CALL_OW 171
// AddComInvisible ( un ) ;
14432: LD_VAR 0 2
14436: PPUSH
14437: CALL_OW 212
// end ;
14441: GO 14284
14443: POP
14444: POP
// repeat wait ( 0 0$45 ) ;
14445: LD_INT 1575
14447: PPUSH
14448: CALL_OW 67
// for i in allianceSpecialForce do
14452: LD_ADDR_VAR 0 1
14456: PUSH
14457: LD_EXP 96
14461: PUSH
14462: FOR_IN
14463: IFFALSE 14681
// begin if IsInvisible ( i ) then
14465: LD_VAR 0 1
14469: PPUSH
14470: CALL_OW 571
14474: IFFALSE 14650
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , 25 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
14476: LD_ADDR_VAR 0 3
14480: PUSH
14481: LD_INT 22
14483: PUSH
14484: LD_INT 1
14486: PUSH
14487: EMPTY
14488: LIST
14489: LIST
14490: PUSH
14491: LD_INT 50
14493: PUSH
14494: EMPTY
14495: LIST
14496: PUSH
14497: LD_INT 56
14499: PUSH
14500: EMPTY
14501: LIST
14502: PUSH
14503: LD_INT 91
14505: PUSH
14506: LD_VAR 0 1
14510: PUSH
14511: LD_INT 25
14513: PUSH
14514: EMPTY
14515: LIST
14516: LIST
14517: LIST
14518: PUSH
14519: LD_INT 2
14521: PUSH
14522: LD_INT 25
14524: PUSH
14525: LD_INT 1
14527: PUSH
14528: EMPTY
14529: LIST
14530: LIST
14531: PUSH
14532: LD_INT 25
14534: PUSH
14535: LD_INT 2
14537: PUSH
14538: EMPTY
14539: LIST
14540: LIST
14541: PUSH
14542: LD_INT 25
14544: PUSH
14545: LD_INT 3
14547: PUSH
14548: EMPTY
14549: LIST
14550: LIST
14551: PUSH
14552: LD_INT 25
14554: PUSH
14555: LD_INT 4
14557: PUSH
14558: EMPTY
14559: LIST
14560: LIST
14561: PUSH
14562: LD_INT 25
14564: PUSH
14565: LD_INT 5
14567: PUSH
14568: EMPTY
14569: LIST
14570: LIST
14571: PUSH
14572: LD_INT 25
14574: PUSH
14575: LD_INT 8
14577: PUSH
14578: EMPTY
14579: LIST
14580: LIST
14581: PUSH
14582: EMPTY
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: LIST
14589: LIST
14590: PUSH
14591: EMPTY
14592: LIST
14593: LIST
14594: LIST
14595: LIST
14596: LIST
14597: PPUSH
14598: CALL_OW 69
14602: ST_TO_ADDR
// if not tmp then
14603: LD_VAR 0 3
14607: NOT
14608: IFFALSE 14612
// continue ;
14610: GO 14462
// if Prob ( 30 * Difficulty ) then
14612: LD_INT 30
14614: PUSH
14615: LD_OWVAR 67
14619: MUL
14620: PPUSH
14621: CALL_OW 13
14625: IFFALSE 14650
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
14627: LD_VAR 0 3
14631: PUSH
14632: LD_INT 1
14634: PPUSH
14635: LD_VAR 0 3
14639: PPUSH
14640: CALL_OW 12
14644: ARRAY
14645: PPUSH
14646: CALL 35362 0 1
// end ; if IsDead ( i ) then
14650: LD_VAR 0 1
14654: PPUSH
14655: CALL_OW 301
14659: IFFALSE 14679
// begin allianceSpecialForce := allianceSpecialForce diff i ;
14661: LD_ADDR_EXP 96
14665: PUSH
14666: LD_EXP 96
14670: PUSH
14671: LD_VAR 0 1
14675: DIFF
14676: ST_TO_ADDR
// continue ;
14677: GO 14462
// end ; end ;
14679: GO 14462
14681: POP
14682: POP
// until allianceDestroyed or not allianceSpecialForce ;
14683: LD_EXP 23
14687: PUSH
14688: LD_EXP 96
14692: NOT
14693: OR
14694: IFFALSE 14445
// end ;
14696: PPOPN 3
14698: END
// every 0 0$30 trigger allianceActive and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_bweapon , us_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ] ) do var i , un , tmp , e ;
14699: LD_EXP 31
14703: PUSH
14704: LD_INT 22
14706: PUSH
14707: LD_INT 1
14709: PUSH
14710: EMPTY
14711: LIST
14712: LIST
14713: PUSH
14714: LD_INT 2
14716: PUSH
14717: LD_INT 35
14719: PUSH
14720: LD_INT 8
14722: PUSH
14723: EMPTY
14724: LIST
14725: LIST
14726: PUSH
14727: LD_INT 34
14729: PUSH
14730: LD_INT 8
14732: PUSH
14733: EMPTY
14734: LIST
14735: LIST
14736: PUSH
14737: EMPTY
14738: LIST
14739: LIST
14740: LIST
14741: PUSH
14742: EMPTY
14743: LIST
14744: LIST
14745: PPUSH
14746: CALL_OW 69
14750: AND
14751: IFFALSE 15151
14753: GO 14755
14755: DISABLE
14756: LD_INT 0
14758: PPUSH
14759: PPUSH
14760: PPUSH
14761: PPUSH
// begin for i := 1 to [ 6 , 8 , 10 , 12 ] [ Difficulty ] do
14762: LD_ADDR_VAR 0 1
14766: PUSH
14767: DOUBLE
14768: LD_INT 1
14770: DEC
14771: ST_TO_ADDR
14772: LD_INT 6
14774: PUSH
14775: LD_INT 8
14777: PUSH
14778: LD_INT 10
14780: PUSH
14781: LD_INT 12
14783: PUSH
14784: EMPTY
14785: LIST
14786: LIST
14787: LIST
14788: LIST
14789: PUSH
14790: LD_OWVAR 67
14794: ARRAY
14795: PUSH
14796: FOR_TO
14797: IFFALSE 14989
// begin uc_side := 7 ;
14799: LD_ADDR_OWVAR 20
14803: PUSH
14804: LD_INT 7
14806: ST_TO_ADDR
// uc_nation := 1 ;
14807: LD_ADDR_OWVAR 21
14811: PUSH
14812: LD_INT 1
14814: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , [ control_remote , control_computer ] [ rand ( 1 , 2 ) ] , [ us_heavy_gun , us_laser ] [ rand ( 1 , 2 ) ] , 100 ) ;
14815: LD_INT 5
14817: PPUSH
14818: LD_INT 3
14820: PPUSH
14821: LD_INT 2
14823: PUSH
14824: LD_INT 3
14826: PUSH
14827: EMPTY
14828: LIST
14829: LIST
14830: PUSH
14831: LD_INT 1
14833: PPUSH
14834: LD_INT 2
14836: PPUSH
14837: CALL_OW 12
14841: ARRAY
14842: PPUSH
14843: LD_INT 6
14845: PUSH
14846: LD_INT 9
14848: PUSH
14849: EMPTY
14850: LIST
14851: LIST
14852: PUSH
14853: LD_INT 1
14855: PPUSH
14856: LD_INT 2
14858: PPUSH
14859: CALL_OW 12
14863: ARRAY
14864: PPUSH
14865: LD_INT 100
14867: PPUSH
14868: CALL 75112 0 5
// un := CreateVehicle ;
14872: LD_ADDR_VAR 0 2
14876: PUSH
14877: CALL_OW 45
14881: ST_TO_ADDR
// SetDir ( un , 4 ) ;
14882: LD_VAR 0 2
14886: PPUSH
14887: LD_INT 4
14889: PPUSH
14890: CALL_OW 233
// PlaceUnitXYR ( un , 307 , 219 , 6 , false ) ;
14894: LD_VAR 0 2
14898: PPUSH
14899: LD_INT 307
14901: PPUSH
14902: LD_INT 219
14904: PPUSH
14905: LD_INT 6
14907: PPUSH
14908: LD_INT 0
14910: PPUSH
14911: CALL_OW 50
// if GetControl ( un ) = control_remote then
14915: LD_VAR 0 2
14919: PPUSH
14920: CALL_OW 263
14924: PUSH
14925: LD_INT 2
14927: EQUAL
14928: IFFALSE 14939
// Connect ( un ) ;
14930: LD_VAR 0 2
14934: PPUSH
14935: CALL 78580 0 1
// TeleportUnit ( un , 124 , 92 , 12 , true ) ;
14939: LD_VAR 0 2
14943: PPUSH
14944: LD_INT 124
14946: PPUSH
14947: LD_INT 92
14949: PPUSH
14950: LD_INT 12
14952: PPUSH
14953: LD_INT 1
14955: PPUSH
14956: CALL_OW 483
// tmp := Join ( tmp , un ) ;
14960: LD_ADDR_VAR 0 3
14964: PUSH
14965: LD_VAR 0 3
14969: PPUSH
14970: LD_VAR 0 2
14974: PPUSH
14975: CALL 107963 0 2
14979: ST_TO_ADDR
// wait ( 0 0$0.3 ) ;
14980: LD_INT 10
14982: PPUSH
14983: CALL_OW 67
// end ;
14987: GO 14796
14989: POP
14990: POP
// repeat wait ( 0 0$2 ) ;
14991: LD_INT 70
14993: PPUSH
14994: CALL_OW 67
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) ;
14998: LD_ADDR_VAR 0 4
15002: PUSH
15003: LD_INT 22
15005: PUSH
15006: LD_INT 1
15008: PUSH
15009: EMPTY
15010: LIST
15011: LIST
15012: PUSH
15013: LD_INT 34
15015: PUSH
15016: LD_INT 8
15018: PUSH
15019: EMPTY
15020: LIST
15021: LIST
15022: PUSH
15023: EMPTY
15024: LIST
15025: LIST
15026: PPUSH
15027: CALL_OW 69
15031: ST_TO_ADDR
// if not e then
15032: LD_VAR 0 4
15036: NOT
15037: IFFALSE 15073
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
15039: LD_ADDR_VAR 0 4
15043: PUSH
15044: LD_INT 22
15046: PUSH
15047: LD_INT 1
15049: PUSH
15050: EMPTY
15051: LIST
15052: LIST
15053: PUSH
15054: LD_INT 21
15056: PUSH
15057: LD_INT 2
15059: PUSH
15060: EMPTY
15061: LIST
15062: LIST
15063: PUSH
15064: EMPTY
15065: LIST
15066: LIST
15067: PPUSH
15068: CALL_OW 69
15072: ST_TO_ADDR
// for i in tmp do
15073: LD_ADDR_VAR 0 1
15077: PUSH
15078: LD_VAR 0 3
15082: PUSH
15083: FOR_IN
15084: IFFALSE 15142
// if not IsOK ( i ) then
15086: LD_VAR 0 1
15090: PPUSH
15091: CALL_OW 302
15095: NOT
15096: IFFALSE 15116
// tmp := tmp diff i else
15098: LD_ADDR_VAR 0 3
15102: PUSH
15103: LD_VAR 0 3
15107: PUSH
15108: LD_VAR 0 1
15112: DIFF
15113: ST_TO_ADDR
15114: GO 15140
// ComAttackUnit ( i , NearestUnitToUnit ( e , i ) ) ;
15116: LD_VAR 0 1
15120: PPUSH
15121: LD_VAR 0 4
15125: PPUSH
15126: LD_VAR 0 1
15130: PPUSH
15131: CALL_OW 74
15135: PPUSH
15136: CALL_OW 115
15140: GO 15083
15142: POP
15143: POP
// until not tmp ;
15144: LD_VAR 0 3
15148: NOT
15149: IFFALSE 14991
// end ;
15151: PPOPN 4
15153: END
// every 8 8$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport , p ;
15154: LD_EXP 23
15158: NOT
15159: PUSH
15160: LD_EXP 31
15164: AND
15165: IFFALSE 16239
15167: GO 15169
15169: DISABLE
15170: LD_INT 0
15172: PPUSH
15173: PPUSH
15174: PPUSH
15175: PPUSH
15176: PPUSH
// begin enable ;
15177: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
15178: LD_INT 22
15180: PUSH
15181: LD_INT 7
15183: PUSH
15184: EMPTY
15185: LIST
15186: LIST
15187: PUSH
15188: LD_INT 30
15190: PUSH
15191: LD_INT 3
15193: PUSH
15194: EMPTY
15195: LIST
15196: LIST
15197: PUSH
15198: EMPTY
15199: LIST
15200: LIST
15201: PPUSH
15202: CALL_OW 69
15206: NOT
15207: IFFALSE 15211
// exit ;
15209: GO 16239
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
15211: LD_ADDR_VAR 0 4
15215: PUSH
15216: LD_INT 22
15218: PUSH
15219: LD_INT 7
15221: PUSH
15222: EMPTY
15223: LIST
15224: LIST
15225: PUSH
15226: LD_INT 30
15228: PUSH
15229: LD_INT 34
15231: PUSH
15232: EMPTY
15233: LIST
15234: LIST
15235: PUSH
15236: EMPTY
15237: LIST
15238: LIST
15239: PPUSH
15240: CALL_OW 69
15244: ST_TO_ADDR
// if Prob ( 40 ) then
15245: LD_INT 40
15247: PPUSH
15248: CALL_OW 13
15252: IFFALSE 15398
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
15254: LD_INT 1
15256: PPUSH
15257: LD_INT 5
15259: PUSH
15260: LD_INT 3
15262: PUSH
15263: LD_INT 2
15265: PUSH
15266: LD_INT 6
15268: PUSH
15269: EMPTY
15270: LIST
15271: LIST
15272: LIST
15273: LIST
15274: PUSH
15275: LD_INT 5
15277: PUSH
15278: LD_INT 3
15280: PUSH
15281: LD_INT 2
15283: PUSH
15284: LD_INT 6
15286: PUSH
15287: EMPTY
15288: LIST
15289: LIST
15290: LIST
15291: LIST
15292: PUSH
15293: LD_INT 5
15295: PUSH
15296: LD_INT 3
15298: PUSH
15299: LD_INT 2
15301: PUSH
15302: LD_INT 6
15304: PUSH
15305: EMPTY
15306: LIST
15307: LIST
15308: LIST
15309: LIST
15310: PUSH
15311: LD_INT 5
15313: PUSH
15314: LD_INT 3
15316: PUSH
15317: LD_INT 2
15319: PUSH
15320: LD_INT 9
15322: PUSH
15323: EMPTY
15324: LIST
15325: LIST
15326: LIST
15327: LIST
15328: PUSH
15329: LD_INT 24
15331: PUSH
15332: LD_INT 3
15334: PUSH
15335: LD_INT 3
15337: PUSH
15338: LD_INT 45
15340: PUSH
15341: EMPTY
15342: LIST
15343: LIST
15344: LIST
15345: LIST
15346: PUSH
15347: LD_INT 24
15349: PUSH
15350: LD_INT 3
15352: PUSH
15353: LD_INT 3
15355: PUSH
15356: LD_INT 47
15358: PUSH
15359: EMPTY
15360: LIST
15361: LIST
15362: LIST
15363: LIST
15364: PUSH
15365: LD_INT 24
15367: PUSH
15368: LD_INT 3
15370: PUSH
15371: LD_INT 3
15373: PUSH
15374: LD_INT 45
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: LIST
15381: LIST
15382: PUSH
15383: EMPTY
15384: LIST
15385: LIST
15386: LIST
15387: LIST
15388: LIST
15389: LIST
15390: LIST
15391: PPUSH
15392: CALL 63846 0 2
// end else
15396: GO 15540
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
15398: LD_INT 1
15400: PPUSH
15401: LD_INT 24
15403: PUSH
15404: LD_INT 3
15406: PUSH
15407: LD_INT 3
15409: PUSH
15410: LD_INT 47
15412: PUSH
15413: EMPTY
15414: LIST
15415: LIST
15416: LIST
15417: LIST
15418: PUSH
15419: LD_INT 24
15421: PUSH
15422: LD_INT 3
15424: PUSH
15425: LD_INT 3
15427: PUSH
15428: LD_INT 47
15430: PUSH
15431: EMPTY
15432: LIST
15433: LIST
15434: LIST
15435: LIST
15436: PUSH
15437: LD_INT 5
15439: PUSH
15440: LD_INT 3
15442: PUSH
15443: LD_INT 2
15445: PUSH
15446: LD_INT 9
15448: PUSH
15449: EMPTY
15450: LIST
15451: LIST
15452: LIST
15453: LIST
15454: PUSH
15455: LD_INT 5
15457: PUSH
15458: LD_INT 3
15460: PUSH
15461: LD_INT 2
15463: PUSH
15464: LD_INT 9
15466: PUSH
15467: EMPTY
15468: LIST
15469: LIST
15470: LIST
15471: LIST
15472: PUSH
15473: LD_INT 5
15475: PUSH
15476: LD_INT 3
15478: PUSH
15479: LD_INT 2
15481: PUSH
15482: LD_INT 9
15484: PUSH
15485: EMPTY
15486: LIST
15487: LIST
15488: LIST
15489: LIST
15490: PUSH
15491: LD_INT 24
15493: PUSH
15494: LD_INT 1
15496: PUSH
15497: LD_INT 3
15499: PUSH
15500: LD_INT 45
15502: PUSH
15503: EMPTY
15504: LIST
15505: LIST
15506: LIST
15507: LIST
15508: PUSH
15509: LD_INT 24
15511: PUSH
15512: LD_INT 1
15514: PUSH
15515: LD_INT 3
15517: PUSH
15518: LD_INT 45
15520: PUSH
15521: EMPTY
15522: LIST
15523: LIST
15524: LIST
15525: LIST
15526: PUSH
15527: EMPTY
15528: LIST
15529: LIST
15530: LIST
15531: LIST
15532: LIST
15533: LIST
15534: LIST
15535: PPUSH
15536: CALL 63846 0 2
// end ; wait ( 2 2$00 ) ;
15540: LD_INT 4200
15542: PPUSH
15543: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_crane ] ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 1 ] ;
15547: LD_ADDR_VAR 0 2
15551: PUSH
15552: LD_INT 22
15554: PUSH
15555: LD_INT 7
15557: PUSH
15558: EMPTY
15559: LIST
15560: LIST
15561: PUSH
15562: LD_INT 21
15564: PUSH
15565: LD_INT 2
15567: PUSH
15568: EMPTY
15569: LIST
15570: LIST
15571: PUSH
15572: LD_INT 3
15574: PUSH
15575: LD_INT 34
15577: PUSH
15578: LD_INT 13
15580: PUSH
15581: EMPTY
15582: LIST
15583: LIST
15584: PUSH
15585: EMPTY
15586: LIST
15587: LIST
15588: PUSH
15589: LD_INT 3
15591: PUSH
15592: LD_INT 34
15594: PUSH
15595: LD_INT 12
15597: PUSH
15598: EMPTY
15599: LIST
15600: LIST
15601: PUSH
15602: EMPTY
15603: LIST
15604: LIST
15605: PUSH
15606: LD_INT 3
15608: PUSH
15609: LD_INT 34
15611: PUSH
15612: LD_INT 51
15614: PUSH
15615: EMPTY
15616: LIST
15617: LIST
15618: PUSH
15619: EMPTY
15620: LIST
15621: LIST
15622: PUSH
15623: LD_INT 3
15625: PUSH
15626: LD_INT 34
15628: PUSH
15629: LD_INT 52
15631: PUSH
15632: EMPTY
15633: LIST
15634: LIST
15635: PUSH
15636: EMPTY
15637: LIST
15638: LIST
15639: PUSH
15640: EMPTY
15641: LIST
15642: LIST
15643: LIST
15644: LIST
15645: LIST
15646: LIST
15647: PPUSH
15648: CALL_OW 69
15652: PUSH
15653: LD_EXP 124
15657: PUSH
15658: LD_INT 1
15660: ARRAY
15661: DIFF
15662: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
15663: LD_ADDR_EXP 121
15667: PUSH
15668: LD_EXP 121
15672: PPUSH
15673: LD_INT 1
15675: PPUSH
15676: LD_EXP 121
15680: PUSH
15681: LD_INT 1
15683: ARRAY
15684: PUSH
15685: LD_VAR 0 2
15689: DIFF
15690: PPUSH
15691: CALL_OW 1
15695: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
15696: LD_ADDR_VAR 0 3
15700: PUSH
15701: LD_INT 0
15703: PPUSH
15704: LD_INT 1
15706: PPUSH
15707: CALL_OW 12
15711: ST_TO_ADDR
// p := 0 ;
15712: LD_ADDR_VAR 0 5
15716: PUSH
15717: LD_INT 0
15719: ST_TO_ADDR
// if target then
15720: LD_VAR 0 3
15724: IFFALSE 15915
// begin for i in tmp do
15726: LD_ADDR_VAR 0 1
15730: PUSH
15731: LD_VAR 0 2
15735: PUSH
15736: FOR_IN
15737: IFFALSE 15762
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
15739: LD_VAR 0 1
15743: PPUSH
15744: LD_INT 179
15746: PPUSH
15747: LD_INT 209
15749: PPUSH
15750: LD_INT 8
15752: PPUSH
15753: LD_INT 1
15755: PPUSH
15756: CALL_OW 483
15760: GO 15736
15762: POP
15763: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15764: LD_ADDR_VAR 0 2
15768: PUSH
15769: LD_VAR 0 2
15773: PPUSH
15774: LD_INT 24
15776: PUSH
15777: LD_INT 250
15779: PUSH
15780: EMPTY
15781: LIST
15782: LIST
15783: PPUSH
15784: CALL_OW 72
15788: ST_TO_ADDR
// for i in tmp do
15789: LD_ADDR_VAR 0 1
15793: PUSH
15794: LD_VAR 0 2
15798: PUSH
15799: FOR_IN
15800: IFFALSE 15840
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
15802: LD_VAR 0 1
15806: PPUSH
15807: LD_INT 179
15809: PPUSH
15810: LD_INT 209
15812: PPUSH
15813: CALL_OW 297
15817: PUSH
15818: LD_INT 9
15820: GREATER
15821: IFFALSE 15838
// ComMoveXY ( i , 179 , 209 ) ;
15823: LD_VAR 0 1
15827: PPUSH
15828: LD_INT 179
15830: PPUSH
15831: LD_INT 209
15833: PPUSH
15834: CALL_OW 111
15838: GO 15799
15840: POP
15841: POP
// wait ( 0 0$1 ) ;
15842: LD_INT 35
15844: PPUSH
15845: CALL_OW 67
// p := Inc ( p ) ;
15849: LD_ADDR_VAR 0 5
15853: PUSH
15854: LD_VAR 0 5
15858: PPUSH
15859: CALL 109324 0 1
15863: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
15864: LD_VAR 0 2
15868: PPUSH
15869: LD_INT 92
15871: PUSH
15872: LD_INT 179
15874: PUSH
15875: LD_INT 209
15877: PUSH
15878: LD_INT 9
15880: PUSH
15881: EMPTY
15882: LIST
15883: LIST
15884: LIST
15885: LIST
15886: PPUSH
15887: CALL_OW 72
15891: PUSH
15892: LD_VAR 0 2
15896: PUSH
15897: LD_INT 1
15899: MINUS
15900: GREATEREQUAL
15901: PUSH
15902: LD_VAR 0 5
15906: PUSH
15907: LD_INT 30
15909: GREATER
15910: OR
15911: IFFALSE 15764
// end else
15913: GO 16102
// begin for i in tmp do
15915: LD_ADDR_VAR 0 1
15919: PUSH
15920: LD_VAR 0 2
15924: PUSH
15925: FOR_IN
15926: IFFALSE 15951
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
15928: LD_VAR 0 1
15932: PPUSH
15933: LD_INT 285
15935: PPUSH
15936: LD_INT 163
15938: PPUSH
15939: LD_INT 8
15941: PPUSH
15942: LD_INT 1
15944: PPUSH
15945: CALL_OW 483
15949: GO 15925
15951: POP
15952: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15953: LD_ADDR_VAR 0 2
15957: PUSH
15958: LD_VAR 0 2
15962: PPUSH
15963: LD_INT 24
15965: PUSH
15966: LD_INT 250
15968: PUSH
15969: EMPTY
15970: LIST
15971: LIST
15972: PPUSH
15973: CALL_OW 72
15977: ST_TO_ADDR
// for i in tmp do
15978: LD_ADDR_VAR 0 1
15982: PUSH
15983: LD_VAR 0 2
15987: PUSH
15988: FOR_IN
15989: IFFALSE 16029
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
15991: LD_VAR 0 1
15995: PPUSH
15996: LD_INT 285
15998: PPUSH
15999: LD_INT 163
16001: PPUSH
16002: CALL_OW 297
16006: PUSH
16007: LD_INT 9
16009: GREATER
16010: IFFALSE 16027
// ComMoveXY ( i , 285 , 163 ) ;
16012: LD_VAR 0 1
16016: PPUSH
16017: LD_INT 285
16019: PPUSH
16020: LD_INT 163
16022: PPUSH
16023: CALL_OW 111
16027: GO 15988
16029: POP
16030: POP
// wait ( 0 0$1 ) ;
16031: LD_INT 35
16033: PPUSH
16034: CALL_OW 67
// p := Inc ( p ) ;
16038: LD_ADDR_VAR 0 5
16042: PUSH
16043: LD_VAR 0 5
16047: PPUSH
16048: CALL 109324 0 1
16052: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
16053: LD_VAR 0 2
16057: PPUSH
16058: LD_INT 92
16060: PUSH
16061: LD_INT 285
16063: PUSH
16064: LD_INT 163
16066: PUSH
16067: LD_INT 9
16069: PUSH
16070: EMPTY
16071: LIST
16072: LIST
16073: LIST
16074: LIST
16075: PPUSH
16076: CALL_OW 72
16080: PUSH
16081: LD_VAR 0 2
16085: PUSH
16086: LD_INT 1
16088: MINUS
16089: GREATEREQUAL
16090: PUSH
16091: LD_VAR 0 5
16095: PUSH
16096: LD_INT 30
16098: GREATER
16099: OR
16100: IFFALSE 15953
// end ; repeat wait ( 0 0$1 ) ;
16102: LD_INT 35
16104: PPUSH
16105: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
16109: LD_ADDR_VAR 0 2
16113: PUSH
16114: LD_VAR 0 2
16118: PPUSH
16119: LD_INT 50
16121: PUSH
16122: EMPTY
16123: LIST
16124: PPUSH
16125: CALL_OW 72
16129: ST_TO_ADDR
// for i in tmp do
16130: LD_ADDR_VAR 0 1
16134: PUSH
16135: LD_VAR 0 2
16139: PUSH
16140: FOR_IN
16141: IFFALSE 16230
// if GetWeapon ( i ) = ru_time_lapser then
16143: LD_VAR 0 1
16147: PPUSH
16148: CALL_OW 264
16152: PUSH
16153: LD_INT 49
16155: EQUAL
16156: IFFALSE 16194
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
16158: LD_VAR 0 1
16162: PPUSH
16163: LD_INT 81
16165: PUSH
16166: LD_INT 7
16168: PUSH
16169: EMPTY
16170: LIST
16171: LIST
16172: PPUSH
16173: CALL_OW 69
16177: PPUSH
16178: LD_VAR 0 1
16182: PPUSH
16183: CALL_OW 74
16187: PPUSH
16188: CALL_OW 112
16192: GO 16228
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
16194: LD_VAR 0 1
16198: PPUSH
16199: LD_INT 81
16201: PUSH
16202: LD_INT 7
16204: PUSH
16205: EMPTY
16206: LIST
16207: LIST
16208: PPUSH
16209: CALL_OW 69
16213: PPUSH
16214: LD_VAR 0 1
16218: PPUSH
16219: CALL_OW 74
16223: PPUSH
16224: CALL_OW 115
16228: GO 16140
16230: POP
16231: POP
// until not tmp ;
16232: LD_VAR 0 2
16236: NOT
16237: IFFALSE 16102
// end ;
16239: PPOPN 5
16241: END
// every 1 1$30 trigger allianceActive and IsOk ( Roth ) and Difficulty > 2 do
16242: LD_EXP 31
16246: PUSH
16247: LD_EXP 79
16251: PPUSH
16252: CALL_OW 302
16256: AND
16257: PUSH
16258: LD_OWVAR 67
16262: PUSH
16263: LD_INT 2
16265: GREATER
16266: AND
16267: IFFALSE 16367
16269: GO 16271
16271: DISABLE
// begin enable ;
16272: ENABLE
// if GetDistUnitXY ( Roth , 245 , 234 ) > 6 then
16273: LD_EXP 79
16277: PPUSH
16278: LD_INT 245
16280: PPUSH
16281: LD_INT 234
16283: PPUSH
16284: CALL_OW 297
16288: PUSH
16289: LD_INT 6
16291: GREATER
16292: IFFALSE 16311
// ComMoveXY ( Roth , 245 , 234 ) else
16294: LD_EXP 79
16298: PPUSH
16299: LD_INT 245
16301: PPUSH
16302: LD_INT 234
16304: PPUSH
16305: CALL_OW 111
16309: GO 16367
// ComMoveHex ( Roth , [ [ 259 , 235 ] , [ 252 , 209 ] , [ 275 , 235 ] ] [ rand ( 1 , 3 ) ] ) ;
16311: LD_EXP 79
16315: PPUSH
16316: LD_INT 259
16318: PUSH
16319: LD_INT 235
16321: PUSH
16322: EMPTY
16323: LIST
16324: LIST
16325: PUSH
16326: LD_INT 252
16328: PUSH
16329: LD_INT 209
16331: PUSH
16332: EMPTY
16333: LIST
16334: LIST
16335: PUSH
16336: LD_INT 275
16338: PUSH
16339: LD_INT 235
16341: PUSH
16342: EMPTY
16343: LIST
16344: LIST
16345: PUSH
16346: EMPTY
16347: LIST
16348: LIST
16349: LIST
16350: PUSH
16351: LD_INT 1
16353: PPUSH
16354: LD_INT 3
16356: PPUSH
16357: CALL_OW 12
16361: ARRAY
16362: PPUSH
16363: CALL 112115 0 2
// end ; end_of_file
16367: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
16368: LD_INT 0
16370: PPUSH
16371: PPUSH
16372: PPUSH
16373: PPUSH
// missionStage := 13 ;
16374: LD_ADDR_EXP 15
16378: PUSH
16379: LD_INT 13
16381: ST_TO_ADDR
// uc_side := 2 ;
16382: LD_ADDR_OWVAR 20
16386: PUSH
16387: LD_INT 2
16389: ST_TO_ADDR
// uc_nation := 2 ;
16390: LD_ADDR_OWVAR 21
16394: PUSH
16395: LD_INT 2
16397: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
16398: LD_ADDR_EXP 97
16402: PUSH
16403: LD_STRING Omar
16405: PPUSH
16406: CALL_OW 25
16410: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
16411: LD_EXP 97
16415: PPUSH
16416: LD_INT 4
16418: PPUSH
16419: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
16423: LD_EXP 97
16427: PPUSH
16428: LD_INT 242
16430: PPUSH
16431: LD_INT 75
16433: PPUSH
16434: LD_INT 0
16436: PPUSH
16437: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
16441: LD_ADDR_EXP 98
16445: PUSH
16446: LD_STRING Heike
16448: PPUSH
16449: CALL_OW 25
16453: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
16454: LD_INT 14
16456: PPUSH
16457: LD_INT 3
16459: PPUSH
16460: LD_INT 1
16462: PPUSH
16463: LD_INT 27
16465: PPUSH
16466: LD_INT 100
16468: PPUSH
16469: CALL 75112 0 5
// veh := CreateVehicle ;
16473: LD_ADDR_VAR 0 3
16477: PUSH
16478: CALL_OW 45
16482: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
16483: LD_VAR 0 3
16487: PPUSH
16488: LD_INT 2
16490: NEG
16491: PPUSH
16492: CALL_OW 242
// SetDir ( veh , 4 ) ;
16496: LD_VAR 0 3
16500: PPUSH
16501: LD_INT 4
16503: PPUSH
16504: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
16508: LD_VAR 0 3
16512: PPUSH
16513: LD_INT 241
16515: PPUSH
16516: LD_INT 72
16518: PPUSH
16519: LD_INT 0
16521: PPUSH
16522: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
16526: LD_EXP 98
16530: PPUSH
16531: LD_VAR 0 3
16535: PPUSH
16536: CALL_OW 52
// if KhatamStatus then
16540: LD_EXP 8
16544: IFFALSE 16607
// begin Khatam := NewCharacter ( Khatam ) ;
16546: LD_ADDR_EXP 99
16550: PUSH
16551: LD_STRING Khatam
16553: PPUSH
16554: CALL_OW 25
16558: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
16559: LD_EXP 99
16563: PPUSH
16564: LD_INT 245
16566: PPUSH
16567: LD_INT 78
16569: PPUSH
16570: LD_INT 3
16572: PPUSH
16573: LD_INT 0
16575: PPUSH
16576: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
16580: LD_EXP 99
16584: PPUSH
16585: LD_INT 4
16587: PPUSH
16588: LD_INT 10
16590: PPUSH
16591: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
16595: LD_EXP 99
16599: PPUSH
16600: LD_INT 4
16602: PPUSH
16603: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
16607: LD_ADDR_VAR 0 2
16611: PUSH
16612: DOUBLE
16613: LD_INT 1
16615: DEC
16616: ST_TO_ADDR
16617: LD_INT 2
16619: PUSH
16620: LD_INT 2
16622: PUSH
16623: LD_INT 3
16625: PUSH
16626: LD_INT 3
16628: PUSH
16629: EMPTY
16630: LIST
16631: LIST
16632: LIST
16633: LIST
16634: PUSH
16635: LD_OWVAR 67
16639: ARRAY
16640: PUSH
16641: FOR_TO
16642: IFFALSE 16708
// begin PrepareScientist ( false , 6 + Difficulty ) ;
16644: LD_INT 0
16646: PPUSH
16647: LD_INT 6
16649: PUSH
16650: LD_OWVAR 67
16654: PLUS
16655: PPUSH
16656: CALL_OW 384
// un := CreateHuman ;
16660: LD_ADDR_VAR 0 4
16664: PUSH
16665: CALL_OW 44
16669: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
16670: LD_VAR 0 4
16674: PPUSH
16675: LD_INT 28
16677: PUSH
16678: LD_INT 29
16680: PUSH
16681: EMPTY
16682: LIST
16683: LIST
16684: PUSH
16685: LD_VAR 0 2
16689: PUSH
16690: LD_INT 2
16692: MOD
16693: PUSH
16694: LD_INT 1
16696: PLUS
16697: ARRAY
16698: PPUSH
16699: LD_INT 0
16701: PPUSH
16702: CALL_OW 49
// end ;
16706: GO 16641
16708: POP
16709: POP
// for i = 1 to 6 do
16710: LD_ADDR_VAR 0 2
16714: PUSH
16715: DOUBLE
16716: LD_INT 1
16718: DEC
16719: ST_TO_ADDR
16720: LD_INT 6
16722: PUSH
16723: FOR_TO
16724: IFFALSE 16769
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
16726: LD_INT 0
16728: PPUSH
16729: LD_INT 6
16731: PUSH
16732: LD_OWVAR 67
16736: PLUS
16737: PPUSH
16738: CALL_OW 381
// un := CreateHuman ;
16742: LD_ADDR_VAR 0 4
16746: PUSH
16747: CALL_OW 44
16751: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16752: LD_VAR 0 4
16756: PPUSH
16757: LD_INT 32
16759: PPUSH
16760: LD_INT 0
16762: PPUSH
16763: CALL_OW 49
// end ;
16767: GO 16723
16769: POP
16770: POP
// for i = 1 to 3 do
16771: LD_ADDR_VAR 0 2
16775: PUSH
16776: DOUBLE
16777: LD_INT 1
16779: DEC
16780: ST_TO_ADDR
16781: LD_INT 3
16783: PUSH
16784: FOR_TO
16785: IFFALSE 16833
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
16787: LD_INT 0
16789: PPUSH
16790: LD_INT 8
16792: PPUSH
16793: LD_INT 6
16795: PUSH
16796: LD_OWVAR 67
16800: PLUS
16801: PPUSH
16802: CALL_OW 380
// un := CreateHuman ;
16806: LD_ADDR_VAR 0 4
16810: PUSH
16811: CALL_OW 44
16815: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16816: LD_VAR 0 4
16820: PPUSH
16821: LD_INT 32
16823: PPUSH
16824: LD_INT 0
16826: PPUSH
16827: CALL_OW 49
// end ;
16831: GO 16784
16833: POP
16834: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
16835: LD_ADDR_VAR 0 2
16839: PUSH
16840: DOUBLE
16841: LD_INT 1
16843: DEC
16844: ST_TO_ADDR
16845: LD_INT 2
16847: PUSH
16848: LD_INT 3
16850: PUSH
16851: LD_INT 4
16853: PUSH
16854: LD_INT 4
16856: PUSH
16857: EMPTY
16858: LIST
16859: LIST
16860: LIST
16861: LIST
16862: PUSH
16863: LD_OWVAR 67
16867: ARRAY
16868: PUSH
16869: FOR_TO
16870: IFFALSE 16960
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
16872: LD_INT 14
16874: PPUSH
16875: LD_INT 2
16877: PPUSH
16878: LD_INT 1
16880: PPUSH
16881: LD_INT 28
16883: PPUSH
16884: LD_INT 80
16886: PPUSH
16887: CALL 75112 0 5
// veh := CreateVehicle ;
16891: LD_ADDR_VAR 0 3
16895: PUSH
16896: CALL_OW 45
16900: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
16901: LD_VAR 0 3
16905: PPUSH
16906: LD_INT 3
16908: PPUSH
16909: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
16913: LD_VAR 0 3
16917: PPUSH
16918: LD_INT 29
16920: PPUSH
16921: LD_INT 0
16923: PPUSH
16924: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16928: LD_INT 0
16930: PPUSH
16931: LD_INT 6
16933: PUSH
16934: LD_OWVAR 67
16938: PLUS
16939: PPUSH
16940: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
16944: CALL_OW 44
16948: PPUSH
16949: LD_VAR 0 3
16953: PPUSH
16954: CALL_OW 52
// end ;
16958: GO 16869
16960: POP
16961: POP
// for i = 1 to 5 + Difficulty do
16962: LD_ADDR_VAR 0 2
16966: PUSH
16967: DOUBLE
16968: LD_INT 1
16970: DEC
16971: ST_TO_ADDR
16972: LD_INT 5
16974: PUSH
16975: LD_OWVAR 67
16979: PLUS
16980: PUSH
16981: FOR_TO
16982: IFFALSE 17109
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
16984: LD_INT 14
16986: PPUSH
16987: LD_INT 1
16989: PPUSH
16990: LD_INT 3
16992: PPUSH
16993: CALL_OW 12
16997: PPUSH
16998: LD_INT 1
17000: PPUSH
17001: LD_INT 28
17003: PUSH
17004: LD_INT 26
17006: PUSH
17007: LD_INT 27
17009: PUSH
17010: LD_INT 25
17012: PUSH
17013: EMPTY
17014: LIST
17015: LIST
17016: LIST
17017: LIST
17018: PUSH
17019: LD_VAR 0 2
17023: PUSH
17024: LD_INT 4
17026: MOD
17027: PUSH
17028: LD_INT 1
17030: PLUS
17031: ARRAY
17032: PPUSH
17033: LD_INT 80
17035: PPUSH
17036: CALL 75112 0 5
// veh := CreateVehicle ;
17040: LD_ADDR_VAR 0 3
17044: PUSH
17045: CALL_OW 45
17049: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
17050: LD_VAR 0 3
17054: PPUSH
17055: LD_INT 4
17057: PPUSH
17058: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
17062: LD_VAR 0 3
17066: PPUSH
17067: LD_INT 28
17069: PPUSH
17070: LD_INT 0
17072: PPUSH
17073: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
17077: LD_INT 0
17079: PPUSH
17080: LD_INT 6
17082: PUSH
17083: LD_OWVAR 67
17087: PLUS
17088: PPUSH
17089: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
17093: CALL_OW 44
17097: PPUSH
17098: LD_VAR 0 3
17102: PPUSH
17103: CALL_OW 52
// end ;
17107: GO 16981
17109: POP
17110: POP
// for i = 1 to Difficulty do
17111: LD_ADDR_VAR 0 2
17115: PUSH
17116: DOUBLE
17117: LD_INT 1
17119: DEC
17120: ST_TO_ADDR
17121: LD_OWVAR 67
17125: PUSH
17126: FOR_TO
17127: IFFALSE 17187
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
17129: LD_INT 14
17131: PPUSH
17132: LD_INT 3
17134: PPUSH
17135: LD_INT 5
17137: PPUSH
17138: LD_INT 29
17140: PPUSH
17141: LD_INT 80
17143: PPUSH
17144: CALL 75112 0 5
// veh := CreateVehicle ;
17148: LD_ADDR_VAR 0 3
17152: PUSH
17153: CALL_OW 45
17157: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
17158: LD_VAR 0 3
17162: PPUSH
17163: LD_INT 4
17165: PPUSH
17166: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
17170: LD_VAR 0 3
17174: PPUSH
17175: LD_INT 28
17177: PPUSH
17178: LD_INT 0
17180: PPUSH
17181: CALL_OW 49
// end ;
17185: GO 17126
17187: POP
17188: POP
// end ;
17189: LD_VAR 0 1
17193: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
17194: LD_INT 22
17196: PUSH
17197: LD_INT 2
17199: PUSH
17200: EMPTY
17201: LIST
17202: LIST
17203: PPUSH
17204: CALL_OW 69
17208: IFFALSE 17587
17210: GO 17212
17212: DISABLE
17213: LD_INT 0
17215: PPUSH
17216: PPUSH
17217: PPUSH
17218: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
17219: LD_ADDR_VAR 0 3
17223: PUSH
17224: LD_INT 22
17226: PUSH
17227: LD_INT 2
17229: PUSH
17230: EMPTY
17231: LIST
17232: LIST
17233: PUSH
17234: LD_INT 25
17236: PUSH
17237: LD_INT 4
17239: PUSH
17240: EMPTY
17241: LIST
17242: LIST
17243: PUSH
17244: EMPTY
17245: LIST
17246: LIST
17247: PPUSH
17248: CALL_OW 69
17252: PUSH
17253: LD_EXP 99
17257: DIFF
17258: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
17259: LD_ADDR_VAR 0 2
17263: PUSH
17264: LD_INT 22
17266: PUSH
17267: LD_INT 2
17269: PUSH
17270: EMPTY
17271: LIST
17272: LIST
17273: PPUSH
17274: CALL_OW 69
17278: PUSH
17279: LD_EXP 99
17283: PUSH
17284: LD_VAR 0 3
17288: UNION
17289: DIFF
17290: ST_TO_ADDR
// if Khatam then
17291: LD_EXP 99
17295: IFFALSE 17312
// ComMoveXY ( Khatam , 211 , 92 ) ;
17297: LD_EXP 99
17301: PPUSH
17302: LD_INT 211
17304: PPUSH
17305: LD_INT 92
17307: PPUSH
17308: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
17312: LD_INT 197
17314: PPUSH
17315: LD_INT 80
17317: PPUSH
17318: LD_INT 2
17320: PPUSH
17321: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
17325: LD_INT 213
17327: PPUSH
17328: LD_INT 90
17330: PPUSH
17331: LD_INT 2
17333: PPUSH
17334: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
17338: LD_INT 215
17340: PPUSH
17341: LD_INT 129
17343: PPUSH
17344: LD_INT 2
17346: PPUSH
17347: CALL_OW 441
// if sci then
17351: LD_VAR 0 3
17355: IFFALSE 17376
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
17357: LD_VAR 0 3
17361: PUSH
17362: LD_INT 1
17364: ARRAY
17365: PPUSH
17366: LD_INT 197
17368: PPUSH
17369: LD_INT 80
17371: PPUSH
17372: CALL_OW 158
// if sci > 1 then
17376: LD_VAR 0 3
17380: PUSH
17381: LD_INT 1
17383: GREATER
17384: IFFALSE 17405
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
17386: LD_VAR 0 3
17390: PUSH
17391: LD_INT 2
17393: ARRAY
17394: PPUSH
17395: LD_INT 213
17397: PPUSH
17398: LD_INT 90
17400: PPUSH
17401: CALL_OW 158
// if sci > 2 then
17405: LD_VAR 0 3
17409: PUSH
17410: LD_INT 2
17412: GREATER
17413: IFFALSE 17434
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
17415: LD_VAR 0 3
17419: PUSH
17420: LD_INT 3
17422: ARRAY
17423: PPUSH
17424: LD_INT 215
17426: PPUSH
17427: LD_INT 129
17429: PPUSH
17430: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
17434: LD_VAR 0 2
17438: PPUSH
17439: LD_INT 195
17441: PPUSH
17442: LD_INT 102
17444: PPUSH
17445: CALL_OW 114
// wait ( 0 0$5 ) ;
17449: LD_INT 175
17451: PPUSH
17452: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
17456: LD_INT 70
17458: PPUSH
17459: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
17463: LD_ADDR_VAR 0 4
17467: PUSH
17468: LD_INT 92
17470: PUSH
17471: LD_INT 195
17473: PUSH
17474: LD_INT 102
17476: PUSH
17477: LD_INT 36
17479: PUSH
17480: EMPTY
17481: LIST
17482: LIST
17483: LIST
17484: LIST
17485: PUSH
17486: LD_INT 22
17488: PUSH
17489: LD_INT 1
17491: PUSH
17492: EMPTY
17493: LIST
17494: LIST
17495: PUSH
17496: EMPTY
17497: LIST
17498: LIST
17499: PPUSH
17500: CALL_OW 69
17504: ST_TO_ADDR
// for i in tmp do
17505: LD_ADDR_VAR 0 1
17509: PUSH
17510: LD_VAR 0 2
17514: PUSH
17515: FOR_IN
17516: IFFALSE 17567
// if enemy then
17518: LD_VAR 0 4
17522: IFFALSE 17550
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
17524: LD_VAR 0 1
17528: PPUSH
17529: LD_VAR 0 4
17533: PPUSH
17534: LD_VAR 0 1
17538: PPUSH
17539: CALL_OW 74
17543: PPUSH
17544: CALL_OW 115
17548: GO 17565
// ComAgressiveMove ( i , 195 , 102 ) ;
17550: LD_VAR 0 1
17554: PPUSH
17555: LD_INT 195
17557: PPUSH
17558: LD_INT 102
17560: PPUSH
17561: CALL_OW 114
17565: GO 17515
17567: POP
17568: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
17569: LD_VAR 0 2
17573: PPUSH
17574: LD_INT 50
17576: PUSH
17577: EMPTY
17578: LIST
17579: PPUSH
17580: CALL_OW 72
17584: NOT
17585: IFFALSE 17456
// end ; end_of_file
17587: PPOPN 4
17589: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
17590: LD_INT 0
17592: PPUSH
17593: PPUSH
17594: PPUSH
17595: PPUSH
17596: PPUSH
17597: PPUSH
17598: PPUSH
17599: PPUSH
17600: PPUSH
// Video ( true ) ;
17601: LD_INT 1
17603: PPUSH
17604: CALL 107935 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
17608: LD_ADDR_VAR 0 5
17612: PUSH
17613: LD_INT 7
17615: PPUSH
17616: LD_INT 0
17618: PPUSH
17619: CALL_OW 517
17623: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
17624: LD_ADDR_VAR 0 2
17628: PUSH
17629: DOUBLE
17630: LD_INT 1
17632: DEC
17633: ST_TO_ADDR
17634: LD_VAR 0 5
17638: PUSH
17639: LD_INT 1
17641: ARRAY
17642: PUSH
17643: FOR_TO
17644: IFFALSE 17689
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
17646: LD_VAR 0 5
17650: PUSH
17651: LD_INT 1
17653: ARRAY
17654: PUSH
17655: LD_VAR 0 2
17659: ARRAY
17660: PPUSH
17661: LD_VAR 0 5
17665: PUSH
17666: LD_INT 2
17668: ARRAY
17669: PUSH
17670: LD_VAR 0 2
17674: ARRAY
17675: PPUSH
17676: LD_INT 1
17678: PPUSH
17679: LD_INT 15
17681: NEG
17682: PPUSH
17683: CALL 107849 0 4
17687: GO 17643
17689: POP
17690: POP
// CenterNowOnUnits ( Powell ) ;
17691: LD_EXP 61
17695: PPUSH
17696: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
17700: LD_ADDR_VAR 0 5
17704: PUSH
17705: LD_EXP 59
17709: PUSH
17710: EMPTY
17711: LIST
17712: ST_TO_ADDR
// if GirlNewVeh then
17713: LD_EXP 60
17717: IFFALSE 17735
// tmp := tmp ^ GirlNewVeh ;
17719: LD_ADDR_VAR 0 5
17723: PUSH
17724: LD_VAR 0 5
17728: PUSH
17729: LD_EXP 60
17733: ADD
17734: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
17735: LD_VAR 0 5
17739: PPUSH
17740: LD_INT 60
17742: PPUSH
17743: LD_INT 109
17745: PPUSH
17746: CALL_OW 111
// if KappaStatus then
17750: LD_EXP 2
17754: IFFALSE 17806
// begin Say ( JMM , D1nT-JMM-1 ) ;
17756: LD_EXP 40
17760: PPUSH
17761: LD_STRING D1nT-JMM-1
17763: PPUSH
17764: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17768: LD_EXP 61
17772: PPUSH
17773: LD_STRING D1T-Pow-1
17775: PPUSH
17776: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
17780: LD_EXP 40
17784: PPUSH
17785: LD_STRING D1T-JMM-2
17787: PPUSH
17788: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
17792: LD_EXP 61
17796: PPUSH
17797: LD_STRING D1T-Pow-2
17799: PPUSH
17800: CALL_OW 88
// end else
17804: GO 18012
// if JMMGirlStatus then
17806: LD_EXP 6
17810: IFFALSE 17955
// begin Say ( JMM , D1T-JMM-1 ) ;
17812: LD_EXP 40
17816: PPUSH
17817: LD_STRING D1T-JMM-1
17819: PPUSH
17820: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17824: LD_EXP 61
17828: PPUSH
17829: LD_STRING D1T-Pow-1
17831: PPUSH
17832: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
17836: LD_EXP 40
17840: PPUSH
17841: LD_STRING D1T-JMM-3
17843: PPUSH
17844: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
17848: LD_EXP 61
17852: PPUSH
17853: LD_STRING D1T-Pow-3
17855: PPUSH
17856: CALL_OW 88
// if JMMGirl then
17860: LD_EXP 7
17864: IFFALSE 17953
// begin case JMMGirl of 1 :
17866: LD_EXP 7
17870: PUSH
17871: LD_INT 1
17873: DOUBLE
17874: EQUAL
17875: IFTRUE 17879
17877: GO 17894
17879: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
17880: LD_EXP 41
17884: PPUSH
17885: LD_STRING D1T-Joan-3
17887: PPUSH
17888: CALL_OW 88
17892: GO 17941
17894: LD_INT 2
17896: DOUBLE
17897: EQUAL
17898: IFTRUE 17902
17900: GO 17917
17902: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
17903: LD_EXP 43
17907: PPUSH
17908: LD_STRING D1T-Lisa-3
17910: PPUSH
17911: CALL_OW 88
17915: GO 17941
17917: LD_INT 3
17919: DOUBLE
17920: EQUAL
17921: IFTRUE 17925
17923: GO 17940
17925: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
17926: LD_EXP 55
17930: PPUSH
17931: LD_STRING D1T-Con-3
17933: PPUSH
17934: CALL_OW 88
17938: GO 17941
17940: POP
// Say ( Powell , D1T-Pow-4 ) ;
17941: LD_EXP 61
17945: PPUSH
17946: LD_STRING D1T-Pow-4
17948: PPUSH
17949: CALL_OW 88
// end ; end else
17953: GO 18012
// if not FastEnd then
17955: LD_EXP 11
17959: NOT
17960: IFFALSE 17988
// begin Say ( JMM , D1T-JMM-4 ) ;
17962: LD_EXP 40
17966: PPUSH
17967: LD_STRING D1T-JMM-4
17969: PPUSH
17970: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
17974: LD_EXP 61
17978: PPUSH
17979: LD_STRING D1T-Pow-5
17981: PPUSH
17982: CALL_OW 88
// end else
17986: GO 18012
// begin Say ( JMM , D1nT-JMM-1 ) ;
17988: LD_EXP 40
17992: PPUSH
17993: LD_STRING D1nT-JMM-1
17995: PPUSH
17996: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
18000: LD_EXP 61
18004: PPUSH
18005: LD_STRING D1nT-Pow-1
18007: PPUSH
18008: CALL_OW 88
// end ; repeat wait ( 3 ) ;
18012: LD_INT 3
18014: PPUSH
18015: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
18019: LD_EXP 59
18023: PPUSH
18024: CALL_OW 314
18028: NOT
18029: IFFALSE 18012
// ComExitVehicle ( JMM ) ;
18031: LD_EXP 40
18035: PPUSH
18036: CALL_OW 121
// repeat wait ( 3 ) ;
18040: LD_INT 3
18042: PPUSH
18043: CALL_OW 67
// until not IsInUnit ( JMM ) ;
18047: LD_EXP 40
18051: PPUSH
18052: CALL_OW 310
18056: NOT
18057: IFFALSE 18040
// ComMoveXY ( JMM , 60 , 94 ) ;
18059: LD_EXP 40
18063: PPUSH
18064: LD_INT 60
18066: PPUSH
18067: LD_INT 94
18069: PPUSH
18070: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
18074: LD_EXP 40
18078: PPUSH
18079: LD_EXP 61
18083: PPUSH
18084: CALL_OW 179
// if Joan then
18088: LD_EXP 41
18092: IFFALSE 18146
// begin ComExitVehicle ( Joan ) ;
18094: LD_EXP 41
18098: PPUSH
18099: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
18103: LD_EXP 41
18107: PPUSH
18108: LD_INT 35
18110: PPUSH
18111: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
18115: LD_EXP 41
18119: PPUSH
18120: LD_INT 65
18122: PPUSH
18123: LD_INT 104
18125: PPUSH
18126: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
18130: LD_EXP 41
18134: PPUSH
18135: LD_EXP 40
18139: PPUSH
18140: CALL_OW 179
// end else
18144: GO 18280
// if Lisa and JMMGirl = 2 then
18146: LD_EXP 43
18150: PUSH
18151: LD_EXP 7
18155: PUSH
18156: LD_INT 2
18158: EQUAL
18159: AND
18160: IFFALSE 18214
// begin ComExitVehicle ( Lisa ) ;
18162: LD_EXP 43
18166: PPUSH
18167: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
18171: LD_EXP 43
18175: PPUSH
18176: LD_INT 35
18178: PPUSH
18179: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
18183: LD_EXP 43
18187: PPUSH
18188: LD_INT 65
18190: PPUSH
18191: LD_INT 104
18193: PPUSH
18194: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
18198: LD_EXP 43
18202: PPUSH
18203: LD_EXP 40
18207: PPUSH
18208: CALL_OW 179
// end else
18212: GO 18280
// if Connie and JMMGirl = 3 then
18214: LD_EXP 55
18218: PUSH
18219: LD_EXP 7
18223: PUSH
18224: LD_INT 3
18226: EQUAL
18227: AND
18228: IFFALSE 18280
// begin ComExitVehicle ( Connie ) ;
18230: LD_EXP 55
18234: PPUSH
18235: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
18239: LD_EXP 55
18243: PPUSH
18244: LD_INT 35
18246: PPUSH
18247: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
18251: LD_EXP 55
18255: PPUSH
18256: LD_INT 65
18258: PPUSH
18259: LD_INT 104
18261: PPUSH
18262: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
18266: LD_EXP 55
18270: PPUSH
18271: LD_EXP 40
18275: PPUSH
18276: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
18280: LD_INT 35
18282: PPUSH
18283: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
18287: LD_EXP 40
18291: PPUSH
18292: LD_EXP 61
18296: PPUSH
18297: CALL_OW 296
18301: PUSH
18302: LD_INT 8
18304: LESS
18305: IFFALSE 18280
// wait ( 0 0$0.5 ) ;
18307: LD_INT 18
18309: PPUSH
18310: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
18314: LD_EXP 40
18318: PPUSH
18319: LD_STRING D1-JMM-1
18321: PPUSH
18322: CALL_OW 88
// async ;
18326: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
18327: LD_EXP 61
18331: PPUSH
18332: LD_STRING D1-Pow-1
18334: PPUSH
18335: CALL_OW 88
// if not dialogue_skipped then
18339: LD_OWVAR 59
18343: NOT
18344: IFFALSE 18353
// wait ( 0 0$2 ) ;
18346: LD_INT 70
18348: PPUSH
18349: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
18353: LD_INT 170
18355: PPUSH
18356: LD_INT 99
18358: PPUSH
18359: LD_INT 1
18361: PPUSH
18362: LD_INT 6
18364: NEG
18365: PPUSH
18366: CALL 107849 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
18370: LD_INT 174
18372: PPUSH
18373: LD_INT 115
18375: PPUSH
18376: LD_INT 1
18378: PPUSH
18379: LD_INT 6
18381: NEG
18382: PPUSH
18383: CALL 107849 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
18387: LD_INT 169
18389: PPUSH
18390: LD_INT 71
18392: PPUSH
18393: LD_INT 1
18395: PPUSH
18396: LD_INT 6
18398: NEG
18399: PPUSH
18400: CALL 107849 0 4
// if not dialogue_skipped then
18404: LD_OWVAR 59
18408: NOT
18409: IFFALSE 18428
// begin CenterOnXY ( 170 , 99 ) ;
18411: LD_INT 170
18413: PPUSH
18414: LD_INT 99
18416: PPUSH
18417: CALL_OW 84
// wait ( 0 0$2.3 ) ;
18421: LD_INT 80
18423: PPUSH
18424: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
18428: LD_INT 75
18430: PPUSH
18431: LD_INT 53
18433: PPUSH
18434: LD_INT 1
18436: PPUSH
18437: LD_INT 9
18439: NEG
18440: PPUSH
18441: CALL 107849 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
18445: LD_INT 54
18447: PPUSH
18448: LD_INT 42
18450: PPUSH
18451: LD_INT 1
18453: PPUSH
18454: LD_INT 9
18456: NEG
18457: PPUSH
18458: CALL 107849 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
18462: LD_INT 62
18464: PPUSH
18465: LD_INT 51
18467: PPUSH
18468: LD_INT 1
18470: PPUSH
18471: LD_INT 9
18473: NEG
18474: PPUSH
18475: CALL 107849 0 4
// if not dialogue_skipped then
18479: LD_OWVAR 59
18483: NOT
18484: IFFALSE 18503
// begin CenterOnXY ( 75 , 53 ) ;
18486: LD_INT 75
18488: PPUSH
18489: LD_INT 53
18491: PPUSH
18492: CALL_OW 84
// wait ( 0 0$4 ) ;
18496: LD_INT 140
18498: PPUSH
18499: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
18503: LD_EXP 61
18507: PPUSH
18508: CALL_OW 87
// if not dialogue_skipped then
18512: LD_OWVAR 59
18516: NOT
18517: IFFALSE 18526
// wait ( 0 0$2 ) ;
18519: LD_INT 70
18521: PPUSH
18522: CALL_OW 67
// sync ;
18526: SYNC
// Say ( JMM , D1-JMM-2 ) ;
18527: LD_EXP 40
18531: PPUSH
18532: LD_STRING D1-JMM-2
18534: PPUSH
18535: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
18539: LD_EXP 61
18543: PPUSH
18544: LD_STRING D1-Pow-2
18546: PPUSH
18547: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
18551: LD_EXP 40
18555: PPUSH
18556: LD_STRING D1-JMM-3
18558: PPUSH
18559: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
18563: LD_EXP 61
18567: PPUSH
18568: LD_STRING D1-Pow-3
18570: PPUSH
18571: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
18575: LD_EXP 40
18579: PPUSH
18580: LD_STRING D1-JMM-4
18582: PPUSH
18583: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
18587: LD_EXP 61
18591: PPUSH
18592: LD_STRING D1-Pow-4
18594: PPUSH
18595: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
18599: LD_EXP 40
18603: PPUSH
18604: LD_STRING D1-JMM-5
18606: PPUSH
18607: CALL_OW 88
// async ;
18611: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
18612: LD_EXP 61
18616: PPUSH
18617: LD_STRING D1-Pow-5
18619: PPUSH
18620: CALL_OW 88
// if not dialogue_skipped then
18624: LD_OWVAR 59
18628: NOT
18629: IFFALSE 18638
// wait ( 0 0$3.6 ) ;
18631: LD_INT 126
18633: PPUSH
18634: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
18638: LD_INT 134
18640: PPUSH
18641: LD_INT 210
18643: PPUSH
18644: LD_INT 1
18646: PPUSH
18647: LD_INT 11
18649: NEG
18650: PPUSH
18651: CALL 107849 0 4
// if not dialogue_skipped then
18655: LD_OWVAR 59
18659: NOT
18660: IFFALSE 18679
// begin CenterOnXY ( 134 , 210 ) ;
18662: LD_INT 134
18664: PPUSH
18665: LD_INT 210
18667: PPUSH
18668: CALL_OW 84
// wait ( 0 0$2 ) ;
18672: LD_INT 70
18674: PPUSH
18675: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
18679: LD_INT 101
18681: PPUSH
18682: LD_INT 159
18684: PPUSH
18685: LD_INT 1
18687: PPUSH
18688: LD_INT 10
18690: NEG
18691: PPUSH
18692: CALL 107849 0 4
// if not dialogue_skipped then
18696: LD_OWVAR 59
18700: NOT
18701: IFFALSE 18720
// begin CenterOnXY ( 101 , 159 ) ;
18703: LD_INT 101
18705: PPUSH
18706: LD_INT 159
18708: PPUSH
18709: CALL_OW 84
// wait ( 0 0$2 ) ;
18713: LD_INT 70
18715: PPUSH
18716: CALL_OW 67
// end ; sync ;
18720: SYNC
// CenterNowOnUnits ( Powell ) ;
18721: LD_EXP 61
18725: PPUSH
18726: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
18730: LD_ADDR_VAR 0 6
18734: PUSH
18735: LD_INT 1
18737: PUSH
18738: LD_INT 2
18740: PUSH
18741: LD_INT 3
18743: PUSH
18744: LD_INT 4
18746: PUSH
18747: LD_INT 5
18749: PUSH
18750: LD_INT 6
18752: PUSH
18753: EMPTY
18754: LIST
18755: LIST
18756: LIST
18757: LIST
18758: LIST
18759: LIST
18760: ST_TO_ADDR
// if not dialogue_skipped then
18761: LD_OWVAR 59
18765: NOT
18766: IFFALSE 18935
// begin game_speed := 4 ;
18768: LD_ADDR_OWVAR 65
18772: PUSH
18773: LD_INT 4
18775: ST_TO_ADDR
// wait ( 0 0$6 ) ;
18776: LD_INT 210
18778: PPUSH
18779: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
18783: LD_ADDR_VAR 0 7
18787: PUSH
18788: LD_STRING Q1
18790: PPUSH
18791: LD_VAR 0 6
18795: PPUSH
18796: CALL_OW 98
18800: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
18801: LD_ADDR_VAR 0 7
18805: PUSH
18806: LD_STRING Q1
18808: PPUSH
18809: LD_VAR 0 6
18813: PPUSH
18814: CALL_OW 98
18818: ST_TO_ADDR
// options := options diff dec ;
18819: LD_ADDR_VAR 0 6
18823: PUSH
18824: LD_VAR 0 6
18828: PUSH
18829: LD_VAR 0 7
18833: DIFF
18834: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
18835: LD_VAR 0 7
18839: PPUSH
18840: LD_VAR 0 6
18844: PPUSH
18845: CALL 20499 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
18849: LD_VAR 0 7
18853: PUSH
18854: LD_INT 5
18856: PUSH
18857: LD_INT 6
18859: PUSH
18860: EMPTY
18861: LIST
18862: LIST
18863: IN
18864: PUSH
18865: LD_VAR 0 6
18869: PUSH
18870: LD_INT 2
18872: EQUAL
18873: OR
18874: IFFALSE 18801
// if not ( dec in [ 5 , 6 ] ) then
18876: LD_VAR 0 7
18880: PUSH
18881: LD_INT 5
18883: PUSH
18884: LD_INT 6
18886: PUSH
18887: EMPTY
18888: LIST
18889: LIST
18890: IN
18891: NOT
18892: IFFALSE 18935
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
18894: LD_ADDR_VAR 0 7
18898: PUSH
18899: LD_STRING Q1a
18901: PPUSH
18902: LD_INT 1
18904: PUSH
18905: LD_INT 2
18907: PUSH
18908: EMPTY
18909: LIST
18910: LIST
18911: PPUSH
18912: CALL_OW 98
18916: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
18917: LD_VAR 0 7
18921: PUSH
18922: LD_INT 4
18924: PLUS
18925: PPUSH
18926: LD_VAR 0 6
18930: PPUSH
18931: CALL 20499 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
18935: LD_INT 81
18937: PPUSH
18938: LD_INT 127
18940: PPUSH
18941: CALL_OW 84
// amount := 8 ;
18945: LD_ADDR_VAR 0 8
18949: PUSH
18950: LD_INT 8
18952: ST_TO_ADDR
// macmilan_squad := [ ] ;
18953: LD_ADDR_VAR 0 9
18957: PUSH
18958: EMPTY
18959: ST_TO_ADDR
// if vip < amount then
18960: LD_EXP 62
18964: PUSH
18965: LD_VAR 0 8
18969: LESS
18970: IFFALSE 19014
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
18972: LD_ADDR_VAR 0 5
18976: PUSH
18977: LD_EXP 62
18981: PUSH
18982: LD_INT 22
18984: PUSH
18985: LD_INT 4
18987: PUSH
18988: EMPTY
18989: LIST
18990: LIST
18991: PUSH
18992: LD_INT 21
18994: PUSH
18995: LD_INT 1
18997: PUSH
18998: EMPTY
18999: LIST
19000: LIST
19001: PUSH
19002: EMPTY
19003: LIST
19004: LIST
19005: PPUSH
19006: CALL_OW 69
19010: UNION
19011: ST_TO_ADDR
19012: GO 19024
// tmp := vip ;
19014: LD_ADDR_VAR 0 5
19018: PUSH
19019: LD_EXP 62
19023: ST_TO_ADDR
// tmp := tmp diff Powell ;
19024: LD_ADDR_VAR 0 5
19028: PUSH
19029: LD_VAR 0 5
19033: PUSH
19034: LD_EXP 61
19038: DIFF
19039: ST_TO_ADDR
// if tmp < amount then
19040: LD_VAR 0 5
19044: PUSH
19045: LD_VAR 0 8
19049: LESS
19050: IFFALSE 19062
// amount := tmp ;
19052: LD_ADDR_VAR 0 8
19056: PUSH
19057: LD_VAR 0 5
19061: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
19062: LD_VAR 0 5
19066: PUSH
19067: LD_INT 1
19069: ARRAY
19070: PPUSH
19071: CALL_OW 257
19075: PUSH
19076: LD_INT 2
19078: NONEQUAL
19079: IFFALSE 19177
// begin if IsInUnit ( tmp [ 1 ] ) then
19081: LD_VAR 0 5
19085: PUSH
19086: LD_INT 1
19088: ARRAY
19089: PPUSH
19090: CALL_OW 310
19094: IFFALSE 19109
// ComExitBuilding ( tmp [ 1 ] ) ;
19096: LD_VAR 0 5
19100: PUSH
19101: LD_INT 1
19103: ARRAY
19104: PPUSH
19105: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
19109: LD_INT 387
19111: PPUSH
19112: CALL_OW 313
19116: PUSH
19117: LD_INT 6
19119: EQUAL
19120: IFFALSE 19145
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
19122: LD_INT 387
19124: PPUSH
19125: CALL_OW 313
19129: PUSH
19130: LD_INT 1
19132: ARRAY
19133: PPUSH
19134: CALL_OW 122
// wait ( 3 ) ;
19138: LD_INT 3
19140: PPUSH
19141: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
19145: LD_VAR 0 5
19149: PUSH
19150: LD_INT 1
19152: ARRAY
19153: PPUSH
19154: LD_INT 387
19156: PPUSH
19157: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
19161: LD_VAR 0 5
19165: PUSH
19166: LD_INT 1
19168: ARRAY
19169: PPUSH
19170: LD_INT 2
19172: PPUSH
19173: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
19177: LD_EXP 40
19181: PPUSH
19182: LD_INT 82
19184: PPUSH
19185: LD_INT 129
19187: PPUSH
19188: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
19192: LD_EXP 40
19196: PPUSH
19197: LD_EXP 61
19201: PPUSH
19202: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
19206: LD_INT 22
19208: PUSH
19209: LD_INT 1
19211: PUSH
19212: EMPTY
19213: LIST
19214: LIST
19215: PPUSH
19216: CALL_OW 69
19220: PUSH
19221: LD_EXP 40
19225: DIFF
19226: PPUSH
19227: LD_INT 84
19229: PPUSH
19230: LD_INT 128
19232: PPUSH
19233: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
19237: LD_INT 22
19239: PUSH
19240: LD_INT 1
19242: PUSH
19243: EMPTY
19244: LIST
19245: LIST
19246: PPUSH
19247: CALL_OW 69
19251: PUSH
19252: LD_EXP 40
19256: DIFF
19257: PPUSH
19258: LD_EXP 40
19262: PPUSH
19263: CALL_OW 179
// for i = 1 to amount do
19267: LD_ADDR_VAR 0 2
19271: PUSH
19272: DOUBLE
19273: LD_INT 1
19275: DEC
19276: ST_TO_ADDR
19277: LD_VAR 0 8
19281: PUSH
19282: FOR_TO
19283: IFFALSE 19451
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
19285: LD_ADDR_VAR 0 9
19289: PUSH
19290: LD_VAR 0 9
19294: PUSH
19295: LD_VAR 0 5
19299: PUSH
19300: LD_VAR 0 2
19304: ARRAY
19305: ADD
19306: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
19307: LD_VAR 0 5
19311: PUSH
19312: LD_VAR 0 2
19316: ARRAY
19317: PPUSH
19318: CALL_OW 310
19322: IFFALSE 19339
// AddComExitBuilding ( tmp [ i ] ) ;
19324: LD_VAR 0 5
19328: PUSH
19329: LD_VAR 0 2
19333: ARRAY
19334: PPUSH
19335: CALL_OW 182
// if i = 2 and JMMNewVeh then
19339: LD_VAR 0 2
19343: PUSH
19344: LD_INT 2
19346: EQUAL
19347: PUSH
19348: LD_EXP 59
19352: AND
19353: IFFALSE 19411
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
19355: LD_VAR 0 5
19359: PUSH
19360: LD_VAR 0 2
19364: ARRAY
19365: PPUSH
19366: LD_EXP 59
19370: PPUSH
19371: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
19375: LD_VAR 0 5
19379: PUSH
19380: LD_VAR 0 2
19384: ARRAY
19385: PPUSH
19386: LD_INT 86
19388: PPUSH
19389: LD_INT 133
19391: PPUSH
19392: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
19396: LD_VAR 0 5
19400: PUSH
19401: LD_VAR 0 2
19405: ARRAY
19406: PPUSH
19407: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
19411: LD_VAR 0 5
19415: PUSH
19416: LD_VAR 0 2
19420: ARRAY
19421: PPUSH
19422: LD_INT 8
19424: PPUSH
19425: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
19429: LD_VAR 0 5
19433: PUSH
19434: LD_VAR 0 2
19438: ARRAY
19439: PPUSH
19440: LD_EXP 40
19444: PPUSH
19445: CALL_OW 179
// end ;
19449: GO 19282
19451: POP
19452: POP
// if GirlNewVeh then
19453: LD_EXP 60
19457: IFFALSE 19471
// SetSide ( GirlNewVeh , 4 ) ;
19459: LD_EXP 60
19463: PPUSH
19464: LD_INT 4
19466: PPUSH
19467: CALL_OW 235
// if Mike then
19471: LD_EXP 57
19475: IFFALSE 19512
// begin macmilan_squad := Join ( macmilan_squad , Mike ) ;
19477: LD_ADDR_VAR 0 9
19481: PUSH
19482: LD_VAR 0 9
19486: PPUSH
19487: LD_EXP 57
19491: PPUSH
19492: CALL 107963 0 2
19496: ST_TO_ADDR
// ComMoveXY ( Mike , 86 , 133 ) ;
19497: LD_EXP 57
19501: PPUSH
19502: LD_INT 86
19504: PPUSH
19505: LD_INT 133
19507: PPUSH
19508: CALL_OW 111
// end ; repeat wait ( 0 0$1 ) ;
19512: LD_INT 35
19514: PPUSH
19515: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
19519: LD_VAR 0 9
19523: PPUSH
19524: LD_INT 95
19526: PUSH
19527: LD_INT 9
19529: PUSH
19530: EMPTY
19531: LIST
19532: LIST
19533: PPUSH
19534: CALL_OW 72
19538: PUSH
19539: LD_INT 0
19541: EQUAL
19542: PUSH
19543: LD_EXP 40
19547: PPUSH
19548: LD_INT 9
19550: PPUSH
19551: CALL_OW 308
19555: NOT
19556: AND
19557: IFFALSE 19512
// wait ( 0 0$2 ) ;
19559: LD_INT 70
19561: PPUSH
19562: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
19566: LD_VAR 0 9
19570: PPUSH
19571: LD_INT 1
19573: PPUSH
19574: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
19578: LD_INT 21
19580: PUSH
19581: LD_INT 2
19583: PUSH
19584: EMPTY
19585: LIST
19586: LIST
19587: PUSH
19588: LD_INT 92
19590: PUSH
19591: LD_INT 83
19593: PUSH
19594: LD_INT 130
19596: PUSH
19597: LD_INT 10
19599: PUSH
19600: EMPTY
19601: LIST
19602: LIST
19603: LIST
19604: LIST
19605: PUSH
19606: EMPTY
19607: LIST
19608: LIST
19609: PPUSH
19610: CALL_OW 69
19614: PPUSH
19615: LD_INT 1
19617: PPUSH
19618: CALL_OW 235
// tick := 0 ;
19622: LD_ADDR_OWVAR 1
19626: PUSH
19627: LD_INT 0
19629: ST_TO_ADDR
// Video ( false ) ;
19630: LD_INT 0
19632: PPUSH
19633: CALL 107935 0 1
// ChangeMissionObjectives ( M1 ) ;
19637: LD_STRING M1
19639: PPUSH
19640: CALL_OW 337
// SaveForQuickRestart ;
19644: CALL_OW 22
// missionStart := true ;
19648: LD_ADDR_EXP 13
19652: PUSH
19653: LD_INT 1
19655: ST_TO_ADDR
// missionStage := 2 ;
19656: LD_ADDR_EXP 15
19660: PUSH
19661: LD_INT 2
19663: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19664: LD_INT 35
19666: PPUSH
19667: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
19671: LD_ADDR_VAR 0 5
19675: PUSH
19676: LD_INT 22
19678: PUSH
19679: LD_INT 4
19681: PUSH
19682: EMPTY
19683: LIST
19684: LIST
19685: PUSH
19686: LD_INT 21
19688: PUSH
19689: LD_INT 1
19691: PUSH
19692: EMPTY
19693: LIST
19694: LIST
19695: PUSH
19696: EMPTY
19697: LIST
19698: LIST
19699: PPUSH
19700: CALL_OW 69
19704: PUSH
19705: LD_EXP 61
19709: DIFF
19710: ST_TO_ADDR
// if not tmp then
19711: LD_VAR 0 5
19715: NOT
19716: IFFALSE 19731
// tmp := [ Powell ] ;
19718: LD_ADDR_VAR 0 5
19722: PUSH
19723: LD_EXP 61
19727: PUSH
19728: EMPTY
19729: LIST
19730: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
19731: LD_ADDR_VAR 0 4
19735: PUSH
19736: LD_INT 22
19738: PUSH
19739: LD_INT 4
19741: PUSH
19742: EMPTY
19743: LIST
19744: LIST
19745: PUSH
19746: LD_INT 34
19748: PUSH
19749: LD_INT 12
19751: PUSH
19752: EMPTY
19753: LIST
19754: LIST
19755: PUSH
19756: EMPTY
19757: LIST
19758: LIST
19759: PPUSH
19760: CALL_OW 69
19764: PUSH
19765: LD_INT 1
19767: ARRAY
19768: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
19769: LD_VAR 0 5
19773: PUSH
19774: LD_INT 1
19776: ARRAY
19777: PPUSH
19778: CALL_OW 310
19782: IFFALSE 19797
// ComExitBuilding ( tmp [ 1 ] ) ;
19784: LD_VAR 0 5
19788: PUSH
19789: LD_INT 1
19791: ARRAY
19792: PPUSH
19793: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
19797: LD_VAR 0 5
19801: PUSH
19802: LD_INT 1
19804: ARRAY
19805: PPUSH
19806: LD_VAR 0 4
19810: PPUSH
19811: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
19815: LD_VAR 0 5
19819: PUSH
19820: LD_INT 1
19822: ARRAY
19823: PPUSH
19824: LD_INT 80
19826: PPUSH
19827: LD_INT 136
19829: PPUSH
19830: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
19834: LD_VAR 0 5
19838: PUSH
19839: LD_INT 1
19841: ARRAY
19842: PPUSH
19843: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
19847: LD_VAR 0 5
19851: PUSH
19852: LD_INT 1
19854: ARRAY
19855: PPUSH
19856: LD_INT 59
19858: PPUSH
19859: LD_INT 112
19861: PPUSH
19862: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
19866: LD_VAR 0 5
19870: PUSH
19871: LD_INT 1
19873: ARRAY
19874: PPUSH
19875: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
19879: LD_EXP 41
19883: PUSH
19884: LD_EXP 41
19888: PPUSH
19889: CALL_OW 255
19893: PUSH
19894: LD_INT 1
19896: EQUAL
19897: AND
19898: IFFALSE 19924
// begin Say ( Joan , D3W-Joan-1 ) ;
19900: LD_EXP 41
19904: PPUSH
19905: LD_STRING D3W-Joan-1
19907: PPUSH
19908: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19912: LD_EXP 40
19916: PPUSH
19917: LD_STRING D3W-JMM-1
19919: PPUSH
19920: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
19924: LD_EXP 43
19928: PUSH
19929: LD_EXP 43
19933: PPUSH
19934: CALL_OW 255
19938: PUSH
19939: LD_INT 1
19941: EQUAL
19942: AND
19943: PUSH
19944: LD_EXP 43
19948: PUSH
19949: LD_EXP 62
19953: IN
19954: NOT
19955: AND
19956: IFFALSE 19982
// begin Say ( Lisa , D3W-Lisa-1 ) ;
19958: LD_EXP 43
19962: PPUSH
19963: LD_STRING D3W-Lisa-1
19965: PPUSH
19966: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19970: LD_EXP 40
19974: PPUSH
19975: LD_STRING D3W-JMM-1
19977: PPUSH
19978: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
19982: LD_EXP 55
19986: PUSH
19987: LD_EXP 55
19991: PPUSH
19992: CALL_OW 255
19996: PUSH
19997: LD_INT 1
19999: EQUAL
20000: AND
20001: IFFALSE 20027
// begin Say ( Connie , D3W-Con-1 ) ;
20003: LD_EXP 55
20007: PPUSH
20008: LD_STRING D3W-Con-1
20010: PPUSH
20011: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
20015: LD_EXP 40
20019: PPUSH
20020: LD_STRING D3W-JMM-1
20022: PPUSH
20023: CALL_OW 88
// end ; wait ( 0 0$0.5 ) ;
20027: LD_INT 18
20029: PPUSH
20030: CALL_OW 67
// if Lisa in vip and GetSide ( Lisa ) = 1 then
20034: LD_EXP 43
20038: PUSH
20039: LD_EXP 62
20043: IN
20044: PUSH
20045: LD_EXP 43
20049: PPUSH
20050: CALL_OW 255
20054: PUSH
20055: LD_INT 1
20057: EQUAL
20058: AND
20059: IFFALSE 20075
// Say ( Lisa , D3nW-Lisa-1 ) else
20061: LD_EXP 43
20065: PPUSH
20066: LD_STRING D3nW-Lisa-1
20068: PPUSH
20069: CALL_OW 88
20073: GO 20319
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
20075: LD_EXP 46
20079: PUSH
20080: LD_EXP 62
20084: IN
20085: PUSH
20086: LD_EXP 46
20090: PPUSH
20091: CALL_OW 255
20095: PUSH
20096: LD_INT 1
20098: EQUAL
20099: AND
20100: IFFALSE 20116
// Say ( Cyrus , D3nW-Cyrus-1 ) else
20102: LD_EXP 46
20106: PPUSH
20107: LD_STRING D3nW-Cyrus-1
20109: PPUSH
20110: CALL_OW 88
20114: GO 20319
// if Bobby in vip and GetSide ( Bobby ) = 1 then
20116: LD_EXP 45
20120: PUSH
20121: LD_EXP 62
20125: IN
20126: PUSH
20127: LD_EXP 45
20131: PPUSH
20132: CALL_OW 255
20136: PUSH
20137: LD_INT 1
20139: EQUAL
20140: AND
20141: IFFALSE 20157
// Say ( Bobby , D3nW-Bobby-1 ) else
20143: LD_EXP 45
20147: PPUSH
20148: LD_STRING D3nW-Bobby-1
20150: PPUSH
20151: CALL_OW 88
20155: GO 20319
// if Gary in vip and GetSide ( Gary ) = 1 then
20157: LD_EXP 52
20161: PUSH
20162: LD_EXP 62
20166: IN
20167: PUSH
20168: LD_EXP 52
20172: PPUSH
20173: CALL_OW 255
20177: PUSH
20178: LD_INT 1
20180: EQUAL
20181: AND
20182: IFFALSE 20198
// Say ( Gary , D3nW-Gary-1 ) else
20184: LD_EXP 52
20188: PPUSH
20189: LD_STRING D3nW-Gary-1
20191: PPUSH
20192: CALL_OW 88
20196: GO 20319
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
20198: LD_EXP 44
20202: PUSH
20203: LD_EXP 62
20207: IN
20208: PUSH
20209: LD_EXP 44
20213: PPUSH
20214: CALL_OW 255
20218: PUSH
20219: LD_INT 1
20221: EQUAL
20222: AND
20223: IFFALSE 20239
// Say ( Donaldson , D3nW-Don-1 ) else
20225: LD_EXP 44
20229: PPUSH
20230: LD_STRING D3nW-Don-1
20232: PPUSH
20233: CALL_OW 88
20237: GO 20319
// if Cornel in vip and GetSide ( Cornel ) = 1 then
20239: LD_EXP 51
20243: PUSH
20244: LD_EXP 62
20248: IN
20249: PUSH
20250: LD_EXP 51
20254: PPUSH
20255: CALL_OW 255
20259: PUSH
20260: LD_INT 1
20262: EQUAL
20263: AND
20264: IFFALSE 20280
// Say ( Cornel , D3nW-Corn-1 ) else
20266: LD_EXP 51
20270: PPUSH
20271: LD_STRING D3nW-Corn-1
20273: PPUSH
20274: CALL_OW 88
20278: GO 20319
// if Frank in vip and GetSide ( Frank ) = 1 then
20280: LD_EXP 53
20284: PUSH
20285: LD_EXP 62
20289: IN
20290: PUSH
20291: LD_EXP 53
20295: PPUSH
20296: CALL_OW 255
20300: PUSH
20301: LD_INT 1
20303: EQUAL
20304: AND
20305: IFFALSE 20319
// Say ( Frank , D3nW-Frank-1 ) ;
20307: LD_EXP 53
20311: PPUSH
20312: LD_STRING D3nW-Frank-1
20314: PPUSH
20315: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
20319: LD_EXP 62
20323: PPUSH
20324: LD_INT 22
20326: PUSH
20327: LD_INT 1
20329: PUSH
20330: EMPTY
20331: LIST
20332: LIST
20333: PPUSH
20334: CALL_OW 72
20338: IFFALSE 20364
// begin Say ( JMM , D3nW-JMM-1 ) ;
20340: LD_EXP 40
20344: PPUSH
20345: LD_STRING D3nW-JMM-1
20347: PPUSH
20348: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
20352: LD_EXP 40
20356: PPUSH
20357: LD_STRING D3nW-JMM-1a
20359: PPUSH
20360: CALL_OW 88
// end ; t := 0 0$00 ;
20364: LD_ADDR_VAR 0 3
20368: PUSH
20369: LD_INT 0
20371: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20372: LD_INT 35
20374: PPUSH
20375: CALL_OW 67
// t := t + 0 0$1 ;
20379: LD_ADDR_VAR 0 3
20383: PUSH
20384: LD_VAR 0 3
20388: PUSH
20389: LD_INT 35
20391: PLUS
20392: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
20393: LD_INT 59
20395: PPUSH
20396: LD_INT 112
20398: PPUSH
20399: CALL_OW 428
20403: PUSH
20404: LD_VAR 0 3
20408: PUSH
20409: LD_INT 2100
20411: GREATER
20412: OR
20413: IFFALSE 20372
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
20415: LD_ADDR_EXP 102
20419: PUSH
20420: LD_EXP 102
20424: PPUSH
20425: LD_INT 4
20427: PPUSH
20428: LD_INT 22
20430: PUSH
20431: LD_INT 4
20433: PUSH
20434: EMPTY
20435: LIST
20436: LIST
20437: PUSH
20438: LD_INT 23
20440: PUSH
20441: LD_INT 1
20443: PUSH
20444: EMPTY
20445: LIST
20446: LIST
20447: PUSH
20448: LD_INT 3
20450: PUSH
20451: LD_INT 21
20453: PUSH
20454: LD_INT 2
20456: PUSH
20457: EMPTY
20458: LIST
20459: LIST
20460: PUSH
20461: EMPTY
20462: LIST
20463: LIST
20464: PUSH
20465: EMPTY
20466: LIST
20467: LIST
20468: LIST
20469: PPUSH
20470: CALL_OW 69
20474: PUSH
20475: LD_EXP 61
20479: DIFF
20480: PPUSH
20481: CALL_OW 1
20485: ST_TO_ADDR
// activeAttacks := true ;
20486: LD_ADDR_EXP 16
20490: PUSH
20491: LD_INT 1
20493: ST_TO_ADDR
// end ;
20494: LD_VAR 0 1
20498: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
20499: LD_INT 0
20501: PPUSH
// case question of 1 :
20502: LD_VAR 0 1
20506: PUSH
20507: LD_INT 1
20509: DOUBLE
20510: EQUAL
20511: IFTRUE 20515
20513: GO 20566
20515: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
20516: LD_EXP 40
20520: PPUSH
20521: LD_STRING D2Mot-JMM-1
20523: PPUSH
20524: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
20528: LD_EXP 61
20532: PPUSH
20533: LD_STRING D2Mot-Pow-1
20535: PPUSH
20536: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
20540: LD_EXP 40
20544: PPUSH
20545: LD_STRING D2Mot-JMM-2
20547: PPUSH
20548: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
20552: LD_EXP 61
20556: PPUSH
20557: LD_STRING D2Mot-Pow-2
20559: PPUSH
20560: CALL_OW 88
// end ; 2 :
20564: GO 20917
20566: LD_INT 2
20568: DOUBLE
20569: EQUAL
20570: IFTRUE 20574
20572: GO 20650
20574: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
20575: LD_EXP 40
20579: PPUSH
20580: LD_STRING D2Rus-JMM-1
20582: PPUSH
20583: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
20587: LD_EXP 61
20591: PPUSH
20592: LD_STRING D2Rus-Pow-1
20594: PPUSH
20595: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
20599: LD_EXP 40
20603: PPUSH
20604: LD_STRING D2Rus-JMM-2
20606: PPUSH
20607: CALL_OW 88
// if not ( 3 in list_of_q ) then
20611: LD_INT 3
20613: PUSH
20614: LD_VAR 0 2
20618: IN
20619: NOT
20620: IFFALSE 20636
// Say ( Powell , D2Rus-Pow-2 ) else
20622: LD_EXP 61
20626: PPUSH
20627: LD_STRING D2Rus-Pow-2
20629: PPUSH
20630: CALL_OW 88
20634: GO 20648
// Say ( Powell , D2Rus-Pow-2a ) ;
20636: LD_EXP 61
20640: PPUSH
20641: LD_STRING D2Rus-Pow-2a
20643: PPUSH
20644: CALL_OW 88
// end ; 3 :
20648: GO 20917
20650: LD_INT 3
20652: DOUBLE
20653: EQUAL
20654: IFTRUE 20658
20656: GO 20743
20658: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
20659: LD_EXP 40
20663: PPUSH
20664: LD_STRING D2Leg-JMM-1
20666: PPUSH
20667: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
20671: LD_EXP 61
20675: PPUSH
20676: LD_STRING D2Leg-Pow-1
20678: PPUSH
20679: CALL_OW 88
// if 2 in list_of_q then
20683: LD_INT 2
20685: PUSH
20686: LD_VAR 0 2
20690: IN
20691: IFFALSE 20717
// begin Say ( JMM , D2Leg-JMM-2 ) ;
20693: LD_EXP 40
20697: PPUSH
20698: LD_STRING D2Leg-JMM-2
20700: PPUSH
20701: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
20705: LD_EXP 61
20709: PPUSH
20710: LD_STRING D2Leg-Pow-2
20712: PPUSH
20713: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
20717: LD_EXP 40
20721: PPUSH
20722: LD_STRING D2Leg-JMM-3
20724: PPUSH
20725: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
20729: LD_EXP 61
20733: PPUSH
20734: LD_STRING D2Leg-Pow-3
20736: PPUSH
20737: CALL_OW 88
// end ; 4 :
20741: GO 20917
20743: LD_INT 4
20745: DOUBLE
20746: EQUAL
20747: IFTRUE 20751
20749: GO 20826
20751: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
20752: LD_EXP 40
20756: PPUSH
20757: LD_STRING D2Ar-JMM-1
20759: PPUSH
20760: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
20764: LD_EXP 61
20768: PPUSH
20769: LD_STRING D2Ar-Pow-1
20771: PPUSH
20772: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
20776: LD_EXP 40
20780: PPUSH
20781: LD_STRING D2Ar-JMM-2
20783: PPUSH
20784: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
20788: LD_EXP 61
20792: PPUSH
20793: LD_STRING D2Ar-Pow-2
20795: PPUSH
20796: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
20800: LD_EXP 40
20804: PPUSH
20805: LD_STRING D2Ar-JMM-3
20807: PPUSH
20808: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
20812: LD_EXP 61
20816: PPUSH
20817: LD_STRING D2Ar-Pow-3
20819: PPUSH
20820: CALL_OW 88
// end ; 5 :
20824: GO 20917
20826: LD_INT 5
20828: DOUBLE
20829: EQUAL
20830: IFTRUE 20834
20832: GO 20849
20834: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
20835: LD_EXP 40
20839: PPUSH
20840: LD_STRING D2Conf-JMM-1
20842: PPUSH
20843: CALL_OW 88
20847: GO 20917
20849: LD_INT 6
20851: DOUBLE
20852: EQUAL
20853: IFTRUE 20857
20855: GO 20916
20857: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
20858: LD_EXP 40
20862: PPUSH
20863: LD_STRING D2Com-JMM-1
20865: PPUSH
20866: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
20870: LD_EXP 61
20874: PPUSH
20875: LD_STRING D2Com-Pow-1
20877: PPUSH
20878: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
20882: LD_EXP 40
20886: PPUSH
20887: LD_STRING D2Com-JMM-2
20889: PPUSH
20890: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
20894: LD_EXP 61
20898: PPUSH
20899: LD_STRING D2Com-Pow-2
20901: PPUSH
20902: CALL_OW 88
// powellAngerQuery := true ;
20906: LD_ADDR_EXP 36
20910: PUSH
20911: LD_INT 1
20913: ST_TO_ADDR
// end ; end ;
20914: GO 20917
20916: POP
// end ;
20917: LD_VAR 0 3
20921: RET
// every 0 0$5 trigger missionStart do var tmp ;
20922: LD_EXP 13
20926: IFFALSE 21251
20928: GO 20930
20930: DISABLE
20931: LD_INT 0
20933: PPUSH
// begin repeat wait ( 0 0$1 ) ;
20934: LD_INT 35
20936: PPUSH
20937: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
20941: LD_INT 14
20943: PPUSH
20944: LD_INT 22
20946: PUSH
20947: LD_INT 1
20949: PUSH
20950: EMPTY
20951: LIST
20952: LIST
20953: PUSH
20954: LD_INT 3
20956: PUSH
20957: LD_INT 21
20959: PUSH
20960: LD_INT 3
20962: PUSH
20963: EMPTY
20964: LIST
20965: LIST
20966: PUSH
20967: EMPTY
20968: LIST
20969: LIST
20970: PUSH
20971: EMPTY
20972: LIST
20973: LIST
20974: PPUSH
20975: CALL_OW 70
20979: PUSH
20980: LD_EXP 15
20984: PUSH
20985: LD_INT 2
20987: PUSH
20988: LD_INT 3
20990: PUSH
20991: LD_INT 4
20993: PUSH
20994: LD_INT 5
20996: PUSH
20997: EMPTY
20998: LIST
20999: LIST
21000: LIST
21001: LIST
21002: IN
21003: AND
21004: IFFALSE 21241
// begin powellAnger := powellAnger + 1 ;
21006: LD_ADDR_EXP 17
21010: PUSH
21011: LD_EXP 17
21015: PUSH
21016: LD_INT 1
21018: PLUS
21019: ST_TO_ADDR
// Video ( true ) ;
21020: LD_INT 1
21022: PPUSH
21023: CALL 107935 0 1
// CenterNowOnUnits ( tmp ) ;
21027: LD_VAR 0 1
21031: PPUSH
21032: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
21036: LD_INT 14
21038: PPUSH
21039: LD_INT 22
21041: PUSH
21042: LD_INT 1
21044: PUSH
21045: EMPTY
21046: LIST
21047: LIST
21048: PPUSH
21049: CALL_OW 70
21053: PPUSH
21054: LD_INT 86
21056: PPUSH
21057: LD_INT 133
21059: PPUSH
21060: CALL_OW 111
// async ;
21064: ASYNC
// case powellAnger of 1 :
21065: LD_EXP 17
21069: PUSH
21070: LD_INT 1
21072: DOUBLE
21073: EQUAL
21074: IFTRUE 21078
21076: GO 21093
21078: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
21079: LD_EXP 61
21083: PPUSH
21084: LD_STRING DBack1-Pow-1
21086: PPUSH
21087: CALL_OW 88
21091: GO 21140
21093: LD_INT 2
21095: DOUBLE
21096: EQUAL
21097: IFTRUE 21101
21099: GO 21116
21101: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
21102: LD_EXP 61
21106: PPUSH
21107: LD_STRING DBack2-Pow-1
21109: PPUSH
21110: CALL_OW 88
21114: GO 21140
21116: LD_INT 3
21118: DOUBLE
21119: EQUAL
21120: IFTRUE 21124
21122: GO 21139
21124: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
21125: LD_EXP 61
21129: PPUSH
21130: LD_STRING DBack3-Pow-1
21132: PPUSH
21133: CALL_OW 88
21137: GO 21140
21139: POP
// sync ;
21140: SYNC
// repeat wait ( 0 0$1 ) ;
21141: LD_INT 35
21143: PPUSH
21144: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
21148: LD_INT 14
21150: PPUSH
21151: LD_INT 22
21153: PUSH
21154: LD_INT 1
21156: PUSH
21157: EMPTY
21158: LIST
21159: LIST
21160: PPUSH
21161: CALL_OW 70
21165: PPUSH
21166: LD_INT 86
21168: PPUSH
21169: LD_INT 133
21171: PPUSH
21172: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21176: LD_INT 14
21178: PPUSH
21179: LD_INT 22
21181: PUSH
21182: LD_INT 1
21184: PUSH
21185: EMPTY
21186: LIST
21187: LIST
21188: PUSH
21189: LD_INT 3
21191: PUSH
21192: LD_INT 21
21194: PUSH
21195: LD_INT 3
21197: PUSH
21198: EMPTY
21199: LIST
21200: LIST
21201: PUSH
21202: EMPTY
21203: LIST
21204: LIST
21205: PUSH
21206: EMPTY
21207: LIST
21208: LIST
21209: PPUSH
21210: CALL_OW 70
21214: NOT
21215: IFFALSE 21141
// if powellAnger >= 3 then
21217: LD_EXP 17
21221: PUSH
21222: LD_INT 3
21224: GREATEREQUAL
21225: IFFALSE 21234
// YouLost ( Dismissed ) ;
21227: LD_STRING Dismissed
21229: PPUSH
21230: CALL_OW 104
// Video ( false ) ;
21234: LD_INT 0
21236: PPUSH
21237: CALL 107935 0 1
// end ; until missionStage > 5 ;
21241: LD_EXP 15
21245: PUSH
21246: LD_INT 5
21248: GREATER
21249: IFFALSE 20934
// end ;
21251: PPOPN 1
21253: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t , p ;
21254: LD_EXP 13
21258: PUSH
21259: LD_INT 22
21261: PUSH
21262: LD_INT 4
21264: PUSH
21265: EMPTY
21266: LIST
21267: LIST
21268: PUSH
21269: LD_INT 21
21271: PUSH
21272: LD_INT 2
21274: PUSH
21275: EMPTY
21276: LIST
21277: LIST
21278: PUSH
21279: EMPTY
21280: LIST
21281: LIST
21282: PPUSH
21283: CALL_OW 69
21287: PUSH
21288: LD_INT 4
21290: GREATEREQUAL
21291: AND
21292: PUSH
21293: LD_EXP 15
21297: PUSH
21298: LD_INT 2
21300: EQUAL
21301: AND
21302: IFFALSE 23926
21304: GO 21306
21306: DISABLE
21307: LD_INT 0
21309: PPUSH
21310: PPUSH
21311: PPUSH
21312: PPUSH
21313: PPUSH
21314: PPUSH
21315: PPUSH
21316: PPUSH
21317: PPUSH
21318: PPUSH
21319: PPUSH
// begin missionStage := 3 ;
21320: LD_ADDR_EXP 15
21324: PUSH
21325: LD_INT 3
21327: ST_TO_ADDR
// retreat := false ;
21328: LD_ADDR_VAR 0 4
21332: PUSH
21333: LD_INT 0
21335: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
21336: LD_ADDR_VAR 0 5
21340: PUSH
21341: LD_INT 22
21343: PUSH
21344: LD_INT 4
21346: PUSH
21347: EMPTY
21348: LIST
21349: LIST
21350: PUSH
21351: LD_INT 30
21353: PUSH
21354: LD_INT 4
21356: PUSH
21357: EMPTY
21358: LIST
21359: LIST
21360: PUSH
21361: EMPTY
21362: LIST
21363: LIST
21364: PPUSH
21365: CALL_OW 69
21369: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21370: LD_ADDR_VAR 0 6
21374: PUSH
21375: LD_INT 22
21377: PUSH
21378: LD_INT 4
21380: PUSH
21381: EMPTY
21382: LIST
21383: LIST
21384: PUSH
21385: LD_INT 30
21387: PUSH
21388: LD_INT 5
21390: PUSH
21391: EMPTY
21392: LIST
21393: LIST
21394: PUSH
21395: EMPTY
21396: LIST
21397: LIST
21398: PPUSH
21399: CALL_OW 69
21403: ST_TO_ADDR
// if not bar then
21404: LD_VAR 0 6
21408: NOT
21409: IFFALSE 21462
// begin repeat wait ( 0 0$1 ) ;
21411: LD_INT 35
21413: PPUSH
21414: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
21418: LD_INT 22
21420: PUSH
21421: LD_INT 4
21423: PUSH
21424: EMPTY
21425: LIST
21426: LIST
21427: PUSH
21428: LD_INT 3
21430: PUSH
21431: LD_INT 57
21433: PUSH
21434: EMPTY
21435: LIST
21436: PUSH
21437: EMPTY
21438: LIST
21439: LIST
21440: PUSH
21441: LD_INT 30
21443: PUSH
21444: LD_INT 5
21446: PUSH
21447: EMPTY
21448: LIST
21449: LIST
21450: PUSH
21451: EMPTY
21452: LIST
21453: LIST
21454: LIST
21455: PPUSH
21456: CALL_OW 69
21460: IFFALSE 21411
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21462: LD_ADDR_VAR 0 6
21466: PUSH
21467: LD_INT 22
21469: PUSH
21470: LD_INT 4
21472: PUSH
21473: EMPTY
21474: LIST
21475: LIST
21476: PUSH
21477: LD_INT 30
21479: PUSH
21480: LD_INT 5
21482: PUSH
21483: EMPTY
21484: LIST
21485: LIST
21486: PUSH
21487: EMPTY
21488: LIST
21489: LIST
21490: PPUSH
21491: CALL_OW 69
21495: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21496: LD_INT 35
21498: PPUSH
21499: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
21503: LD_EXP 121
21507: PUSH
21508: LD_INT 4
21510: ARRAY
21511: PUSH
21512: LD_INT 4
21514: GREATEREQUAL
21515: IFFALSE 21496
// tmp := [ ] ;
21517: LD_ADDR_VAR 0 2
21521: PUSH
21522: EMPTY
21523: ST_TO_ADDR
// tmp2 := [ ] ;
21524: LD_ADDR_VAR 0 3
21528: PUSH
21529: EMPTY
21530: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell union vip ) do
21531: LD_ADDR_VAR 0 1
21535: PUSH
21536: LD_INT 22
21538: PUSH
21539: LD_INT 4
21541: PUSH
21542: EMPTY
21543: LIST
21544: LIST
21545: PUSH
21546: LD_INT 2
21548: PUSH
21549: LD_INT 25
21551: PUSH
21552: LD_INT 1
21554: PUSH
21555: EMPTY
21556: LIST
21557: LIST
21558: PUSH
21559: LD_INT 25
21561: PUSH
21562: LD_INT 2
21564: PUSH
21565: EMPTY
21566: LIST
21567: LIST
21568: PUSH
21569: LD_INT 25
21571: PUSH
21572: LD_INT 3
21574: PUSH
21575: EMPTY
21576: LIST
21577: LIST
21578: PUSH
21579: LD_INT 25
21581: PUSH
21582: LD_INT 4
21584: PUSH
21585: EMPTY
21586: LIST
21587: LIST
21588: PUSH
21589: LD_INT 25
21591: PUSH
21592: LD_INT 5
21594: PUSH
21595: EMPTY
21596: LIST
21597: LIST
21598: PUSH
21599: EMPTY
21600: LIST
21601: LIST
21602: LIST
21603: LIST
21604: LIST
21605: LIST
21606: PUSH
21607: EMPTY
21608: LIST
21609: LIST
21610: PPUSH
21611: CALL_OW 69
21615: PUSH
21616: LD_EXP 61
21620: PUSH
21621: LD_EXP 62
21625: UNION
21626: DIFF
21627: PUSH
21628: FOR_IN
21629: IFFALSE 21691
// if not i in extraSquad then
21631: LD_VAR 0 1
21635: PUSH
21636: LD_EXP 63
21640: IN
21641: NOT
21642: IFFALSE 21666
// tmp := Join ( tmp , i ) else
21644: LD_ADDR_VAR 0 2
21648: PUSH
21649: LD_VAR 0 2
21653: PPUSH
21654: LD_VAR 0 1
21658: PPUSH
21659: CALL 107963 0 2
21663: ST_TO_ADDR
21664: GO 21689
// tmp := Insert ( tmp , 1 , i ) ;
21666: LD_ADDR_VAR 0 2
21670: PUSH
21671: LD_VAR 0 2
21675: PPUSH
21676: LD_INT 1
21678: PPUSH
21679: LD_VAR 0 1
21683: PPUSH
21684: CALL_OW 2
21688: ST_TO_ADDR
21689: GO 21628
21691: POP
21692: POP
// tmp := tmp diff 0 ;
21693: LD_ADDR_VAR 0 2
21697: PUSH
21698: LD_VAR 0 2
21702: PUSH
21703: LD_INT 0
21705: DIFF
21706: ST_TO_ADDR
// p := 0 ;
21707: LD_ADDR_VAR 0 11
21711: PUSH
21712: LD_INT 0
21714: ST_TO_ADDR
// for i in UnitFilter ( tmp , [ f_sex , sex_male ] ) do
21715: LD_ADDR_VAR 0 1
21719: PUSH
21720: LD_VAR 0 2
21724: PPUSH
21725: LD_INT 26
21727: PUSH
21728: LD_INT 1
21730: PUSH
21731: EMPTY
21732: LIST
21733: LIST
21734: PPUSH
21735: CALL_OW 72
21739: PUSH
21740: FOR_IN
21741: IFFALSE 21792
// begin p := Inc ( p ) ;
21743: LD_ADDR_VAR 0 11
21747: PUSH
21748: LD_VAR 0 11
21752: PPUSH
21753: CALL 109324 0 1
21757: ST_TO_ADDR
// tmp2 := Join ( tmp2 , i ) ;
21758: LD_ADDR_VAR 0 3
21762: PUSH
21763: LD_VAR 0 3
21767: PPUSH
21768: LD_VAR 0 1
21772: PPUSH
21773: CALL 107963 0 2
21777: ST_TO_ADDR
// if p = 4 then
21778: LD_VAR 0 11
21782: PUSH
21783: LD_INT 4
21785: EQUAL
21786: IFFALSE 21790
// break ;
21788: GO 21792
// end ;
21790: GO 21740
21792: POP
21793: POP
// tmp := tmp diff tmp2 ;
21794: LD_ADDR_VAR 0 2
21798: PUSH
21799: LD_VAR 0 2
21803: PUSH
21804: LD_VAR 0 3
21808: DIFF
21809: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
21810: LD_ADDR_VAR 0 2
21814: PUSH
21815: LD_VAR 0 2
21819: PPUSH
21820: LD_INT 3
21822: PPUSH
21823: CALL 106467 0 2
21827: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
21828: LD_ADDR_VAR 0 3
21832: PUSH
21833: LD_VAR 0 3
21837: PPUSH
21838: LD_INT 3
21840: PPUSH
21841: CALL 106467 0 2
21845: ST_TO_ADDR
// for i := 1 to 4 do
21846: LD_ADDR_VAR 0 1
21850: PUSH
21851: DOUBLE
21852: LD_INT 1
21854: DEC
21855: ST_TO_ADDR
21856: LD_INT 4
21858: PUSH
21859: FOR_TO
21860: IFFALSE 22026
// begin if tmp2 then
21862: LD_VAR 0 3
21866: IFFALSE 21947
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
21868: LD_ADDR_EXP 18
21872: PUSH
21873: LD_EXP 18
21877: PPUSH
21878: LD_INT 1
21880: PPUSH
21881: LD_EXP 18
21885: PUSH
21886: LD_INT 1
21888: ARRAY
21889: PUSH
21890: LD_VAR 0 3
21894: PUSH
21895: LD_VAR 0 3
21899: ARRAY
21900: ADD
21901: PPUSH
21902: CALL_OW 1
21906: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
21907: LD_VAR 0 3
21911: PUSH
21912: LD_VAR 0 3
21916: ARRAY
21917: PPUSH
21918: LD_INT 1
21920: PPUSH
21921: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
21925: LD_ADDR_VAR 0 3
21929: PUSH
21930: LD_VAR 0 3
21934: PPUSH
21935: LD_VAR 0 3
21939: PPUSH
21940: CALL_OW 3
21944: ST_TO_ADDR
// end else
21945: GO 22024
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
21947: LD_ADDR_EXP 18
21951: PUSH
21952: LD_EXP 18
21956: PPUSH
21957: LD_INT 1
21959: PPUSH
21960: LD_EXP 18
21964: PUSH
21965: LD_INT 1
21967: ARRAY
21968: PUSH
21969: LD_VAR 0 2
21973: PUSH
21974: LD_VAR 0 2
21978: ARRAY
21979: ADD
21980: PPUSH
21981: CALL_OW 1
21985: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
21986: LD_VAR 0 2
21990: PUSH
21991: LD_VAR 0 2
21995: ARRAY
21996: PPUSH
21997: LD_INT 1
21999: PPUSH
22000: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
22004: LD_ADDR_VAR 0 2
22008: PUSH
22009: LD_VAR 0 2
22013: PPUSH
22014: LD_VAR 0 2
22018: PPUSH
22019: CALL_OW 3
22023: ST_TO_ADDR
// end ; end ;
22024: GO 21859
22026: POP
22027: POP
// if tmp2 then
22028: LD_VAR 0 3
22032: IFFALSE 22050
// tmp := tmp union tmp2 ;
22034: LD_ADDR_VAR 0 2
22038: PUSH
22039: LD_VAR 0 2
22043: PUSH
22044: LD_VAR 0 3
22048: UNION
22049: ST_TO_ADDR
// for i := 0 to 3 do
22050: LD_ADDR_VAR 0 1
22054: PUSH
22055: DOUBLE
22056: LD_INT 0
22058: DEC
22059: ST_TO_ADDR
22060: LD_INT 3
22062: PUSH
22063: FOR_TO
22064: IFFALSE 22227
// begin if not tmp [ tmp - i ] then
22066: LD_VAR 0 2
22070: PUSH
22071: LD_VAR 0 2
22075: PUSH
22076: LD_VAR 0 1
22080: MINUS
22081: ARRAY
22082: NOT
22083: IFFALSE 22180
// begin uc_side := 4 ;
22085: LD_ADDR_OWVAR 20
22089: PUSH
22090: LD_INT 4
22092: ST_TO_ADDR
// uc_nation := 1 ;
22093: LD_ADDR_OWVAR 21
22097: PUSH
22098: LD_INT 1
22100: ST_TO_ADDR
// InitHc ;
22101: CALL_OW 19
// PrepareSoldier ( sex_male , 3 ) ;
22105: LD_INT 1
22107: PPUSH
22108: LD_INT 3
22110: PPUSH
22111: CALL_OW 381
// un := CreateHuman ;
22115: LD_ADDR_VAR 0 8
22119: PUSH
22120: CALL_OW 44
22124: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( 39 , 61 ) ) ;
22125: LD_VAR 0 8
22129: PPUSH
22130: LD_INT 39
22132: PPUSH
22133: LD_INT 61
22135: PPUSH
22136: CALL_OW 428
22140: PPUSH
22141: CALL_OW 52
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ un ) ;
22145: LD_ADDR_EXP 18
22149: PUSH
22150: LD_EXP 18
22154: PPUSH
22155: LD_INT 2
22157: PPUSH
22158: LD_EXP 18
22162: PUSH
22163: LD_INT 2
22165: ARRAY
22166: PUSH
22167: LD_VAR 0 8
22171: ADD
22172: PPUSH
22173: CALL_OW 1
22177: ST_TO_ADDR
// end else
22178: GO 22225
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
22180: LD_ADDR_EXP 18
22184: PUSH
22185: LD_EXP 18
22189: PPUSH
22190: LD_INT 2
22192: PPUSH
22193: LD_EXP 18
22197: PUSH
22198: LD_INT 2
22200: ARRAY
22201: PUSH
22202: LD_VAR 0 2
22206: PUSH
22207: LD_VAR 0 2
22211: PUSH
22212: LD_VAR 0 1
22216: MINUS
22217: ARRAY
22218: ADD
22219: PPUSH
22220: CALL_OW 1
22224: ST_TO_ADDR
// end ;
22225: GO 22063
22227: POP
22228: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
22229: LD_ADDR_EXP 102
22233: PUSH
22234: LD_EXP 102
22238: PPUSH
22239: LD_INT 4
22241: PPUSH
22242: LD_EXP 102
22246: PUSH
22247: LD_INT 4
22249: ARRAY
22250: PUSH
22251: LD_EXP 18
22255: PUSH
22256: LD_INT 1
22258: ARRAY
22259: DIFF
22260: PPUSH
22261: CALL_OW 1
22265: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
22266: LD_VAR 0 5
22270: PUSH
22271: LD_INT 1
22273: ARRAY
22274: PPUSH
22275: CALL_OW 313
22279: IFFALSE 22334
// begin for i in UnitsInside ( arm [ 1 ] ) do
22281: LD_ADDR_VAR 0 1
22285: PUSH
22286: LD_VAR 0 5
22290: PUSH
22291: LD_INT 1
22293: ARRAY
22294: PPUSH
22295: CALL_OW 313
22299: PUSH
22300: FOR_IN
22301: IFFALSE 22332
// begin ComExitBuilding ( i ) ;
22303: LD_VAR 0 1
22307: PPUSH
22308: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
22312: LD_VAR 0 1
22316: PPUSH
22317: LD_VAR 0 6
22321: PUSH
22322: LD_INT 1
22324: ARRAY
22325: PPUSH
22326: CALL_OW 180
// end ;
22330: GO 22300
22332: POP
22333: POP
// end ; wait ( 0 0$5 ) ;
22334: LD_INT 175
22336: PPUSH
22337: CALL_OW 67
// repeat wait ( 0 0$1 ) until not UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) ;
22341: LD_INT 35
22343: PPUSH
22344: CALL_OW 67
22348: LD_EXP 18
22352: PUSH
22353: LD_INT 1
22355: ARRAY
22356: PPUSH
22357: LD_INT 55
22359: PUSH
22360: EMPTY
22361: LIST
22362: PPUSH
22363: CALL_OW 72
22367: NOT
22368: IFFALSE 22341
// for i in powellSquadAttack [ 1 ] do
22370: LD_ADDR_VAR 0 1
22374: PUSH
22375: LD_EXP 18
22379: PUSH
22380: LD_INT 1
22382: ARRAY
22383: PUSH
22384: FOR_IN
22385: IFFALSE 22492
// begin if IsInUnit ( i ) then
22387: LD_VAR 0 1
22391: PPUSH
22392: CALL_OW 310
22396: IFFALSE 22407
// ComExitBuilding ( i ) ;
22398: LD_VAR 0 1
22402: PPUSH
22403: CALL_OW 122
// if GetClass ( i ) <> 1 then
22407: LD_VAR 0 1
22411: PPUSH
22412: CALL_OW 257
22416: PUSH
22417: LD_INT 1
22419: NONEQUAL
22420: IFFALSE 22461
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
22422: LD_VAR 0 1
22426: PPUSH
22427: LD_VAR 0 5
22431: PUSH
22432: LD_INT 1
22434: ARRAY
22435: PPUSH
22436: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
22440: LD_VAR 0 1
22444: PPUSH
22445: LD_INT 1
22447: PPUSH
22448: CALL_OW 183
// AddComExitBuilding ( i ) ;
22452: LD_VAR 0 1
22456: PPUSH
22457: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
22461: LD_VAR 0 1
22465: PPUSH
22466: LD_INT 60
22468: PPUSH
22469: LD_INT 94
22471: PPUSH
22472: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
22476: LD_VAR 0 1
22480: PPUSH
22481: LD_EXP 61
22485: PPUSH
22486: CALL_OW 179
// end ;
22490: GO 22384
22492: POP
22493: POP
// wait ( 0 0$45 ) ;
22494: LD_INT 1575
22496: PPUSH
22497: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
22501: LD_EXP 61
22505: PPUSH
22506: LD_STRING D4-Pow-1
22508: PPUSH
22509: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
22513: LD_ADDR_VAR 0 2
22517: PUSH
22518: LD_EXP 18
22522: PUSH
22523: LD_INT 1
22525: ARRAY
22526: PPUSH
22527: LD_INT 26
22529: PUSH
22530: LD_INT 1
22532: PUSH
22533: EMPTY
22534: LIST
22535: LIST
22536: PPUSH
22537: CALL_OW 72
22541: ST_TO_ADDR
// if tmp then
22542: LD_VAR 0 2
22546: IFFALSE 22564
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
22548: LD_VAR 0 2
22552: PUSH
22553: LD_INT 1
22555: ARRAY
22556: PPUSH
22557: LD_STRING D4-Sol1-1
22559: PPUSH
22560: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
22564: LD_EXP 61
22568: PPUSH
22569: LD_STRING D4-Pow-2
22571: PPUSH
22572: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
22576: LD_ADDR_VAR 0 1
22580: PUSH
22581: DOUBLE
22582: LD_INT 1
22584: DEC
22585: ST_TO_ADDR
22586: LD_EXP 18
22590: PUSH
22591: LD_INT 1
22593: ARRAY
22594: PUSH
22595: FOR_TO
22596: IFFALSE 22689
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
22598: LD_EXP 18
22602: PUSH
22603: LD_INT 1
22605: ARRAY
22606: PUSH
22607: LD_VAR 0 1
22611: ARRAY
22612: PPUSH
22613: LD_EXP 121
22617: PUSH
22618: LD_INT 4
22620: ARRAY
22621: PUSH
22622: LD_INT 1
22624: ARRAY
22625: PPUSH
22626: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
22630: LD_ADDR_EXP 121
22634: PUSH
22635: LD_EXP 121
22639: PPUSH
22640: LD_INT 4
22642: PPUSH
22643: LD_EXP 121
22647: PUSH
22648: LD_INT 4
22650: ARRAY
22651: PPUSH
22652: LD_INT 1
22654: PPUSH
22655: CALL_OW 3
22659: PPUSH
22660: CALL_OW 1
22664: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
22665: LD_INT 8
22667: PPUSH
22668: LD_EXP 18
22672: PUSH
22673: LD_INT 1
22675: ARRAY
22676: PUSH
22677: LD_VAR 0 1
22681: ARRAY
22682: PPUSH
22683: CALL_OW 471
// end ;
22687: GO 22595
22689: POP
22690: POP
// repeat wait ( 0 0$1 ) ;
22691: LD_INT 35
22693: PPUSH
22694: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
22698: LD_EXP 18
22702: PUSH
22703: LD_INT 1
22705: ARRAY
22706: PPUSH
22707: LD_INT 55
22709: PUSH
22710: EMPTY
22711: LIST
22712: PPUSH
22713: CALL_OW 72
22717: PUSH
22718: LD_INT 4
22720: GREATEREQUAL
22721: IFFALSE 22691
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
22723: LD_EXP 18
22727: PUSH
22728: LD_INT 1
22730: ARRAY
22731: PPUSH
22732: LD_INT 69
22734: PPUSH
22735: LD_INT 94
22737: PPUSH
22738: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
22742: LD_EXP 18
22746: PUSH
22747: LD_INT 1
22749: ARRAY
22750: PPUSH
22751: LD_INT 82
22753: PPUSH
22754: LD_INT 83
22756: PPUSH
22757: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
22761: LD_EXP 18
22765: PUSH
22766: LD_INT 1
22768: ARRAY
22769: PPUSH
22770: LD_INT 77
22772: PPUSH
22773: LD_INT 69
22775: PPUSH
22776: CALL_OW 174
// wait ( 0 0$30 ) ;
22780: LD_INT 1050
22782: PPUSH
22783: CALL_OW 67
// repeat wait ( 3 ) ;
22787: LD_INT 3
22789: PPUSH
22790: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
22794: LD_ADDR_VAR 0 1
22798: PUSH
22799: LD_EXP 18
22803: PUSH
22804: LD_INT 1
22806: ARRAY
22807: PUSH
22808: FOR_IN
22809: IFFALSE 22945
// begin if GetLives ( i ) < 990 then
22811: LD_VAR 0 1
22815: PPUSH
22816: CALL_OW 256
22820: PUSH
22821: LD_INT 990
22823: LESS
22824: IFFALSE 22838
// SetLives ( i , 1000 ) ;
22826: LD_VAR 0 1
22830: PPUSH
22831: LD_INT 1000
22833: PPUSH
22834: CALL_OW 234
// if not IsInUnit ( i ) then
22838: LD_VAR 0 1
22842: PPUSH
22843: CALL_OW 310
22847: NOT
22848: IFFALSE 22943
// begin if not HasTask ( i ) then
22850: LD_VAR 0 1
22854: PPUSH
22855: CALL_OW 314
22859: NOT
22860: IFFALSE 22877
// ComMoveXY ( i , 64 , 93 ) ;
22862: LD_VAR 0 1
22866: PPUSH
22867: LD_INT 64
22869: PPUSH
22870: LD_INT 93
22872: PPUSH
22873: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
22877: LD_VAR 0 4
22881: NOT
22882: PUSH
22883: LD_VAR 0 1
22887: PPUSH
22888: CALL_OW 258
22892: PUSH
22893: LD_INT 1
22895: EQUAL
22896: AND
22897: IFFALSE 22943
// begin retreat := true ;
22899: LD_ADDR_VAR 0 4
22903: PUSH
22904: LD_INT 1
22906: ST_TO_ADDR
// SetTag ( i , 2 ) ;
22907: LD_VAR 0 1
22911: PPUSH
22912: LD_INT 2
22914: PPUSH
22915: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
22919: LD_VAR 0 1
22923: PPUSH
22924: LD_STRING D4a-Sol1-1
22926: PPUSH
22927: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
22931: LD_EXP 61
22935: PPUSH
22936: LD_STRING D4a-Pow-1
22938: PPUSH
22939: CALL_OW 88
// end ; end ; end ;
22943: GO 22808
22945: POP
22946: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_inarea , powellBase ] ) >= 4 ;
22947: LD_EXP 18
22951: PUSH
22952: LD_INT 1
22954: ARRAY
22955: PPUSH
22956: LD_INT 95
22958: PUSH
22959: LD_INT 9
22961: PUSH
22962: EMPTY
22963: LIST
22964: LIST
22965: PPUSH
22966: CALL_OW 72
22970: PUSH
22971: LD_INT 4
22973: GREATEREQUAL
22974: IFFALSE 22787
// for i in powellSquadAttack [ 1 ] do
22976: LD_ADDR_VAR 0 1
22980: PUSH
22981: LD_EXP 18
22985: PUSH
22986: LD_INT 1
22988: ARRAY
22989: PUSH
22990: FOR_IN
22991: IFFALSE 23127
// begin if GetTag ( i ) = 2 then
22993: LD_VAR 0 1
22997: PPUSH
22998: CALL_OW 110
23002: PUSH
23003: LD_INT 2
23005: EQUAL
23006: IFFALSE 23068
// begin ComMoveXY ( i , 60 , 94 ) ;
23008: LD_VAR 0 1
23012: PPUSH
23013: LD_INT 60
23015: PPUSH
23016: LD_INT 94
23018: PPUSH
23019: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
23023: LD_VAR 0 1
23027: PPUSH
23028: LD_EXP 61
23032: PPUSH
23033: CALL_OW 179
// wait ( 0 0$3 ) ;
23037: LD_INT 105
23039: PPUSH
23040: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
23044: LD_VAR 0 1
23048: PPUSH
23049: LD_STRING D4a-Sol1-2
23051: PPUSH
23052: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
23056: LD_EXP 61
23060: PPUSH
23061: LD_STRING D4a-Pow-2
23063: PPUSH
23064: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
23068: LD_VAR 0 1
23072: PPUSH
23073: LD_INT 0
23075: PPUSH
23076: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
23080: LD_ADDR_EXP 102
23084: PUSH
23085: LD_EXP 102
23089: PPUSH
23090: LD_INT 4
23092: PPUSH
23093: LD_EXP 102
23097: PUSH
23098: LD_INT 4
23100: ARRAY
23101: PUSH
23102: LD_VAR 0 1
23106: UNION
23107: PPUSH
23108: CALL_OW 1
23112: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
23113: LD_INT 8
23115: PPUSH
23116: LD_VAR 0 1
23120: PPUSH
23121: CALL_OW 472
// end ;
23125: GO 22990
23127: POP
23128: POP
// wait ( 1 1$00 ) ;
23129: LD_INT 2100
23131: PPUSH
23132: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
23136: LD_ADDR_VAR 0 9
23140: PUSH
23141: LD_INT 22
23143: PUSH
23144: LD_INT 4
23146: PUSH
23147: EMPTY
23148: LIST
23149: LIST
23150: PUSH
23151: LD_INT 30
23153: PUSH
23154: LD_INT 32
23156: PUSH
23157: EMPTY
23158: LIST
23159: LIST
23160: PUSH
23161: LD_INT 58
23163: PUSH
23164: EMPTY
23165: LIST
23166: PUSH
23167: EMPTY
23168: LIST
23169: LIST
23170: LIST
23171: PPUSH
23172: CALL_OW 69
23176: ST_TO_ADDR
// if tmp then
23177: LD_VAR 0 2
23181: IFFALSE 23421
// begin for i := 1 to tmp do
23183: LD_ADDR_VAR 0 1
23187: PUSH
23188: DOUBLE
23189: LD_INT 1
23191: DEC
23192: ST_TO_ADDR
23193: LD_VAR 0 2
23197: PUSH
23198: FOR_TO
23199: IFFALSE 23412
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
23201: LD_ADDR_EXP 102
23205: PUSH
23206: LD_EXP 102
23210: PPUSH
23211: LD_INT 4
23213: PPUSH
23214: LD_EXP 102
23218: PUSH
23219: LD_INT 4
23221: ARRAY
23222: PUSH
23223: LD_VAR 0 2
23227: PUSH
23228: LD_VAR 0 1
23232: ARRAY
23233: DIFF
23234: PPUSH
23235: CALL_OW 1
23239: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
23240: LD_ADDR_VAR 0 10
23244: PUSH
23245: LD_VAR 0 2
23249: PUSH
23250: LD_VAR 0 1
23254: ARRAY
23255: PPUSH
23256: CALL_OW 310
23260: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
23261: LD_VAR 0 10
23265: PUSH
23266: LD_VAR 0 10
23270: PPUSH
23271: CALL_OW 266
23275: PUSH
23276: LD_INT 32
23278: EQUAL
23279: AND
23280: IFFALSE 23284
// continue ;
23282: GO 23198
// if t then
23284: LD_VAR 0 10
23288: IFFALSE 23305
// ComExitBuilding ( tmp [ i ] ) ;
23290: LD_VAR 0 2
23294: PUSH
23295: LD_VAR 0 1
23299: ARRAY
23300: PPUSH
23301: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
23305: LD_VAR 0 2
23309: PUSH
23310: LD_VAR 0 1
23314: ARRAY
23315: PPUSH
23316: LD_VAR 0 5
23320: PUSH
23321: LD_INT 1
23323: ARRAY
23324: PPUSH
23325: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
23329: LD_VAR 0 2
23333: PUSH
23334: LD_VAR 0 1
23338: ARRAY
23339: PPUSH
23340: LD_INT 1
23342: PPUSH
23343: CALL_OW 183
// if emptyTowers then
23347: LD_VAR 0 9
23351: IFFALSE 23410
// begin AddComExitBuilding ( tmp [ i ] ) ;
23353: LD_VAR 0 2
23357: PUSH
23358: LD_VAR 0 1
23362: ARRAY
23363: PPUSH
23364: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
23368: LD_VAR 0 2
23372: PUSH
23373: LD_VAR 0 1
23377: ARRAY
23378: PPUSH
23379: LD_VAR 0 9
23383: PUSH
23384: LD_INT 1
23386: ARRAY
23387: PPUSH
23388: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
23392: LD_ADDR_VAR 0 9
23396: PUSH
23397: LD_VAR 0 9
23401: PPUSH
23402: LD_INT 1
23404: PPUSH
23405: CALL_OW 3
23409: ST_TO_ADDR
// end ; end ;
23410: GO 23198
23412: POP
23413: POP
// wait ( 0 0$30 ) ;
23414: LD_INT 1050
23416: PPUSH
23417: CALL_OW 67
// end ; uc_side := 6 ;
23421: LD_ADDR_OWVAR 20
23425: PUSH
23426: LD_INT 6
23428: ST_TO_ADDR
// uc_nation := 3 ;
23429: LD_ADDR_OWVAR 21
23433: PUSH
23434: LD_INT 3
23436: ST_TO_ADDR
// ru := [ ] ;
23437: LD_ADDR_VAR 0 7
23441: PUSH
23442: EMPTY
23443: ST_TO_ADDR
// for i = 1 to 5 do
23444: LD_ADDR_VAR 0 1
23448: PUSH
23449: DOUBLE
23450: LD_INT 1
23452: DEC
23453: ST_TO_ADDR
23454: LD_INT 5
23456: PUSH
23457: FOR_TO
23458: IFFALSE 23578
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
23460: LD_INT 22
23462: PUSH
23463: LD_INT 23
23465: PUSH
23466: EMPTY
23467: LIST
23468: LIST
23469: PUSH
23470: LD_INT 1
23472: PPUSH
23473: LD_INT 2
23475: PPUSH
23476: CALL_OW 12
23480: ARRAY
23481: PPUSH
23482: LD_INT 1
23484: PPUSH
23485: LD_INT 3
23487: PPUSH
23488: LD_INT 43
23490: PUSH
23491: LD_INT 44
23493: PUSH
23494: EMPTY
23495: LIST
23496: LIST
23497: PUSH
23498: LD_INT 1
23500: PPUSH
23501: LD_INT 2
23503: PPUSH
23504: CALL_OW 12
23508: ARRAY
23509: PPUSH
23510: LD_INT 89
23512: PPUSH
23513: CALL 75112 0 5
// un := CreateVehicle ;
23517: LD_ADDR_VAR 0 8
23521: PUSH
23522: CALL_OW 45
23526: ST_TO_ADDR
// SetDir ( un , 4 ) ;
23527: LD_VAR 0 8
23531: PPUSH
23532: LD_INT 4
23534: PPUSH
23535: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
23539: LD_VAR 0 8
23543: PPUSH
23544: LD_INT 136
23546: PPUSH
23547: LD_INT 90
23549: PPUSH
23550: LD_INT 8
23552: PPUSH
23553: LD_INT 0
23555: PPUSH
23556: CALL_OW 50
// ru := ru ^ un ;
23560: LD_ADDR_VAR 0 7
23564: PUSH
23565: LD_VAR 0 7
23569: PUSH
23570: LD_VAR 0 8
23574: ADD
23575: ST_TO_ADDR
// end ;
23576: GO 23457
23578: POP
23579: POP
// if ru then
23580: LD_VAR 0 7
23584: IFFALSE 23601
// ComAgressiveMove ( ru , 57 , 94 ) ;
23586: LD_VAR 0 7
23590: PPUSH
23591: LD_INT 57
23593: PPUSH
23594: LD_INT 94
23596: PPUSH
23597: CALL_OW 114
// wait ( 3 3$00 ) ;
23601: LD_INT 6300
23603: PPUSH
23604: CALL_OW 67
// p := UnitsInside ( HexInfo ( 54 , 85 ) ) ;
23608: LD_ADDR_VAR 0 11
23612: PUSH
23613: LD_INT 54
23615: PPUSH
23616: LD_INT 85
23618: PPUSH
23619: CALL_OW 428
23623: PPUSH
23624: CALL_OW 313
23628: ST_TO_ADDR
// t := 0 ;
23629: LD_ADDR_VAR 0 10
23633: PUSH
23634: LD_INT 0
23636: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_empty ] ] , [ f_btype , b_bunker ] ] ) do
23637: LD_ADDR_VAR 0 1
23641: PUSH
23642: LD_INT 22
23644: PUSH
23645: LD_INT 4
23647: PUSH
23648: EMPTY
23649: LIST
23650: LIST
23651: PUSH
23652: LD_INT 3
23654: PUSH
23655: LD_INT 58
23657: PUSH
23658: EMPTY
23659: LIST
23660: PUSH
23661: EMPTY
23662: LIST
23663: LIST
23664: PUSH
23665: LD_INT 30
23667: PUSH
23668: LD_INT 32
23670: PUSH
23671: EMPTY
23672: LIST
23673: LIST
23674: PUSH
23675: EMPTY
23676: LIST
23677: LIST
23678: LIST
23679: PPUSH
23680: CALL_OW 69
23684: PUSH
23685: FOR_IN
23686: IFFALSE 23812
// begin if p + t > 5 then
23688: LD_VAR 0 11
23692: PUSH
23693: LD_VAR 0 10
23697: PLUS
23698: PUSH
23699: LD_INT 5
23701: GREATER
23702: IFFALSE 23706
// break ;
23704: GO 23812
// un := UnitsInside ( i ) ;
23706: LD_ADDR_VAR 0 8
23710: PUSH
23711: LD_VAR 0 1
23715: PPUSH
23716: CALL_OW 313
23720: ST_TO_ADDR
// ComExitBuilding ( un ) ;
23721: LD_VAR 0 8
23725: PPUSH
23726: CALL_OW 122
// AddComEnterUnit ( un , HexInfo ( 54 , 85 ) ) ;
23730: LD_VAR 0 8
23734: PPUSH
23735: LD_INT 54
23737: PPUSH
23738: LD_INT 85
23740: PPUSH
23741: CALL_OW 428
23745: PPUSH
23746: CALL_OW 180
// AddComChangeProfession ( un , class_mechanic ) ;
23750: LD_VAR 0 8
23754: PPUSH
23755: LD_INT 3
23757: PPUSH
23758: CALL_OW 183
// t := Inc ( t ) ;
23762: LD_ADDR_VAR 0 10
23766: PUSH
23767: LD_VAR 0 10
23771: PPUSH
23772: CALL 109324 0 1
23776: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] ^ un ) ;
23777: LD_ADDR_EXP 102
23781: PUSH
23782: LD_EXP 102
23786: PPUSH
23787: LD_INT 4
23789: PPUSH
23790: LD_EXP 102
23794: PUSH
23795: LD_INT 4
23797: ARRAY
23798: PUSH
23799: LD_VAR 0 8
23803: ADD
23804: PPUSH
23805: CALL_OW 1
23809: ST_TO_ADDR
// end ;
23810: GO 23685
23812: POP
23813: POP
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
23814: LD_INT 4
23816: PPUSH
23817: LD_INT 3
23819: PUSH
23820: LD_INT 1
23822: PUSH
23823: LD_INT 1
23825: PUSH
23826: LD_INT 5
23828: PUSH
23829: EMPTY
23830: LIST
23831: LIST
23832: LIST
23833: LIST
23834: PUSH
23835: LD_INT 4
23837: PUSH
23838: LD_INT 1
23840: PUSH
23841: LD_INT 1
23843: PUSH
23844: LD_INT 6
23846: PUSH
23847: EMPTY
23848: LIST
23849: LIST
23850: LIST
23851: LIST
23852: PUSH
23853: LD_INT 4
23855: PUSH
23856: LD_INT 1
23858: PUSH
23859: LD_INT 1
23861: PUSH
23862: LD_INT 7
23864: PUSH
23865: EMPTY
23866: LIST
23867: LIST
23868: LIST
23869: LIST
23870: PUSH
23871: LD_INT 3
23873: PUSH
23874: LD_INT 1
23876: PUSH
23877: LD_INT 1
23879: PUSH
23880: LD_INT 7
23882: PUSH
23883: EMPTY
23884: LIST
23885: LIST
23886: LIST
23887: LIST
23888: PUSH
23889: LD_INT 3
23891: PUSH
23892: LD_INT 1
23894: PUSH
23895: LD_INT 1
23897: PUSH
23898: LD_INT 5
23900: PUSH
23901: EMPTY
23902: LIST
23903: LIST
23904: LIST
23905: LIST
23906: PUSH
23907: EMPTY
23908: LIST
23909: LIST
23910: LIST
23911: LIST
23912: LIST
23913: PPUSH
23914: CALL 63798 0 2
// missionStage := 4 ;
23918: LD_ADDR_EXP 15
23922: PUSH
23923: LD_INT 4
23925: ST_TO_ADDR
// end ;
23926: PPOPN 11
23928: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , t , _xy , dist , fac , arm , speaker , emp_towers , veh ;
23929: LD_EXP 15
23933: PUSH
23934: LD_INT 4
23936: EQUAL
23937: PUSH
23938: LD_INT 22
23940: PUSH
23941: LD_INT 4
23943: PUSH
23944: EMPTY
23945: LIST
23946: LIST
23947: PUSH
23948: LD_INT 21
23950: PUSH
23951: LD_INT 2
23953: PUSH
23954: EMPTY
23955: LIST
23956: LIST
23957: PUSH
23958: EMPTY
23959: LIST
23960: LIST
23961: PPUSH
23962: CALL_OW 69
23966: PUSH
23967: LD_INT 5
23969: GREATEREQUAL
23970: AND
23971: IFFALSE 28335
23973: GO 23975
23975: DISABLE
23976: LD_INT 0
23978: PPUSH
23979: PPUSH
23980: PPUSH
23981: PPUSH
23982: PPUSH
23983: PPUSH
23984: PPUSH
23985: PPUSH
23986: PPUSH
23987: PPUSH
23988: PPUSH
23989: PPUSH
23990: PPUSH
23991: PPUSH
// begin wait ( 0 0$10 ) ;
23992: LD_INT 350
23994: PPUSH
23995: CALL_OW 67
// missionStage := 5 ;
23999: LD_ADDR_EXP 15
24003: PUSH
24004: LD_INT 5
24006: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
24007: LD_ADDR_VAR 0 11
24011: PUSH
24012: LD_INT 22
24014: PUSH
24015: LD_INT 4
24017: PUSH
24018: EMPTY
24019: LIST
24020: LIST
24021: PUSH
24022: LD_INT 2
24024: PUSH
24025: LD_INT 30
24027: PUSH
24028: LD_INT 4
24030: PUSH
24031: EMPTY
24032: LIST
24033: LIST
24034: PUSH
24035: LD_INT 30
24037: PUSH
24038: LD_INT 5
24040: PUSH
24041: EMPTY
24042: LIST
24043: LIST
24044: PUSH
24045: EMPTY
24046: LIST
24047: LIST
24048: LIST
24049: PUSH
24050: EMPTY
24051: LIST
24052: LIST
24053: PPUSH
24054: CALL_OW 69
24058: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
24059: LD_ADDR_VAR 0 6
24063: PUSH
24064: LD_INT 22
24066: PUSH
24067: LD_INT 4
24069: PUSH
24070: EMPTY
24071: LIST
24072: LIST
24073: PUSH
24074: LD_INT 21
24076: PUSH
24077: LD_INT 1
24079: PUSH
24080: EMPTY
24081: LIST
24082: LIST
24083: PUSH
24084: LD_INT 3
24086: PUSH
24087: LD_INT 25
24089: PUSH
24090: LD_INT 16
24092: PUSH
24093: EMPTY
24094: LIST
24095: LIST
24096: PUSH
24097: EMPTY
24098: LIST
24099: LIST
24100: PUSH
24101: LD_INT 3
24103: PUSH
24104: LD_INT 25
24106: PUSH
24107: LD_INT 12
24109: PUSH
24110: EMPTY
24111: LIST
24112: LIST
24113: PUSH
24114: EMPTY
24115: LIST
24116: LIST
24117: PUSH
24118: EMPTY
24119: LIST
24120: LIST
24121: LIST
24122: LIST
24123: PPUSH
24124: CALL_OW 69
24128: PUSH
24129: LD_EXP 61
24133: DIFF
24134: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
24135: LD_ADDR_VAR 0 10
24139: PUSH
24140: LD_INT 22
24142: PUSH
24143: LD_INT 4
24145: PUSH
24146: EMPTY
24147: LIST
24148: LIST
24149: PUSH
24150: LD_INT 30
24152: PUSH
24153: LD_INT 3
24155: PUSH
24156: EMPTY
24157: LIST
24158: LIST
24159: PUSH
24160: EMPTY
24161: LIST
24162: LIST
24163: PPUSH
24164: CALL_OW 69
24168: PUSH
24169: LD_INT 1
24171: ARRAY
24172: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
24173: LD_INT 350
24175: PPUSH
24176: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
24180: LD_EXP 121
24184: PUSH
24185: LD_INT 4
24187: ARRAY
24188: PUSH
24189: LD_INT 5
24191: LESS
24192: PUSH
24193: LD_VAR 0 10
24197: PPUSH
24198: CALL_OW 461
24202: PUSH
24203: LD_INT 2
24205: EQUAL
24206: AND
24207: IFFALSE 24237
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
24209: LD_INT 4
24211: PPUSH
24212: LD_INT 3
24214: PUSH
24215: LD_INT 1
24217: PUSH
24218: LD_INT 1
24220: PUSH
24221: LD_INT 5
24223: PUSH
24224: EMPTY
24225: LIST
24226: LIST
24227: LIST
24228: LIST
24229: PUSH
24230: EMPTY
24231: LIST
24232: PPUSH
24233: CALL 63846 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
24237: LD_EXP 121
24241: PUSH
24242: LD_INT 4
24244: ARRAY
24245: PUSH
24246: LD_INT 5
24248: GREATEREQUAL
24249: PUSH
24250: LD_EXP 121
24254: PUSH
24255: LD_INT 4
24257: ARRAY
24258: PPUSH
24259: LD_INT 58
24261: PUSH
24262: EMPTY
24263: LIST
24264: PPUSH
24265: CALL_OW 72
24269: PUSH
24270: LD_INT 5
24272: GREATEREQUAL
24273: AND
24274: IFFALSE 24173
// powellAllowRetreat := false ;
24276: LD_ADDR_EXP 19
24280: PUSH
24281: LD_INT 0
24283: ST_TO_ADDR
// activeAttacks := false ;
24284: LD_ADDR_EXP 16
24288: PUSH
24289: LD_INT 0
24291: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
24292: LD_INT 35
24294: PPUSH
24295: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
24299: LD_INT 22
24301: PUSH
24302: LD_INT 6
24304: PUSH
24305: EMPTY
24306: LIST
24307: LIST
24308: PPUSH
24309: CALL_OW 69
24313: PUSH
24314: LD_INT 0
24316: EQUAL
24317: IFFALSE 24292
// tmp := mc_vehicles [ 4 ] ;
24319: LD_ADDR_VAR 0 3
24323: PUSH
24324: LD_EXP 121
24328: PUSH
24329: LD_INT 4
24331: ARRAY
24332: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
24333: LD_ADDR_VAR 0 1
24337: PUSH
24338: DOUBLE
24339: LD_INT 1
24341: DEC
24342: ST_TO_ADDR
24343: LD_EXP 18
24347: PUSH
24348: FOR_TO
24349: IFFALSE 24671
// begin for j in powellSquadAttack [ i ] do
24351: LD_ADDR_VAR 0 2
24355: PUSH
24356: LD_EXP 18
24360: PUSH
24361: LD_VAR 0 1
24365: ARRAY
24366: PUSH
24367: FOR_IN
24368: IFFALSE 24667
// begin if j in mc_bases [ 4 ] then
24370: LD_VAR 0 2
24374: PUSH
24375: LD_EXP 102
24379: PUSH
24380: LD_INT 4
24382: ARRAY
24383: IN
24384: IFFALSE 24419
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff j ) ;
24386: LD_ADDR_EXP 102
24390: PUSH
24391: LD_EXP 102
24395: PPUSH
24396: LD_INT 4
24398: PPUSH
24399: LD_EXP 102
24403: PUSH
24404: LD_INT 4
24406: ARRAY
24407: PUSH
24408: LD_VAR 0 2
24412: DIFF
24413: PPUSH
24414: CALL_OW 1
24418: ST_TO_ADDR
// forces := forces diff j ;
24419: LD_ADDR_VAR 0 6
24423: PUSH
24424: LD_VAR 0 6
24428: PUSH
24429: LD_VAR 0 2
24433: DIFF
24434: ST_TO_ADDR
// SetTag ( j , 1 ) ;
24435: LD_VAR 0 2
24439: PPUSH
24440: LD_INT 1
24442: PPUSH
24443: CALL_OW 109
// wait ( 0 0$2 ) ;
24447: LD_INT 70
24449: PPUSH
24450: CALL_OW 67
// if IsInUnit ( j ) then
24454: LD_VAR 0 2
24458: PPUSH
24459: CALL_OW 310
24463: IFFALSE 24474
// ComExitBuilding ( j ) ;
24465: LD_VAR 0 2
24469: PPUSH
24470: CALL_OW 122
// if GetClass ( j ) <> 1 and not HasTask ( j ) then
24474: LD_VAR 0 2
24478: PPUSH
24479: CALL_OW 257
24483: PUSH
24484: LD_INT 1
24486: NONEQUAL
24487: PUSH
24488: LD_VAR 0 2
24492: PPUSH
24493: CALL_OW 314
24497: NOT
24498: AND
24499: IFFALSE 24579
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
24501: LD_VAR 0 11
24505: PUSH
24506: LD_INT 1
24508: ARRAY
24509: PPUSH
24510: CALL_OW 313
24514: PUSH
24515: LD_INT 5
24517: GREATEREQUAL
24518: IFFALSE 24540
// ComEnterUnit ( j , arm [ 2 ] ) else
24520: LD_VAR 0 2
24524: PPUSH
24525: LD_VAR 0 11
24529: PUSH
24530: LD_INT 2
24532: ARRAY
24533: PPUSH
24534: CALL_OW 120
24538: GO 24558
// ComEnterUnit ( j , arm [ 1 ] ) ;
24540: LD_VAR 0 2
24544: PPUSH
24545: LD_VAR 0 11
24549: PUSH
24550: LD_INT 1
24552: ARRAY
24553: PPUSH
24554: CALL_OW 120
// AddComChangeProfession ( j , 1 ) ;
24558: LD_VAR 0 2
24562: PPUSH
24563: LD_INT 1
24565: PPUSH
24566: CALL_OW 183
// AddComExitBuilding ( j ) ;
24570: LD_VAR 0 2
24574: PPUSH
24575: CALL_OW 182
// end ; if i = 2 then
24579: LD_VAR 0 1
24583: PUSH
24584: LD_INT 2
24586: EQUAL
24587: IFFALSE 24604
// AddComMoveXY ( j , 61 , 93 ) ;
24589: LD_VAR 0 2
24593: PPUSH
24594: LD_INT 61
24596: PPUSH
24597: LD_INT 93
24599: PPUSH
24600: CALL_OW 171
// if i = 1 then
24604: LD_VAR 0 1
24608: PUSH
24609: LD_INT 1
24611: EQUAL
24612: IFFALSE 24665
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
24614: LD_VAR 0 2
24618: PPUSH
24619: LD_VAR 0 3
24623: PUSH
24624: LD_INT 1
24626: ARRAY
24627: PPUSH
24628: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
24632: LD_ADDR_VAR 0 3
24636: PUSH
24637: LD_VAR 0 3
24641: PPUSH
24642: LD_INT 1
24644: PPUSH
24645: CALL_OW 3
24649: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
24650: LD_VAR 0 2
24654: PPUSH
24655: LD_INT 69
24657: PPUSH
24658: LD_INT 94
24660: PPUSH
24661: CALL_OW 171
// end ; end ;
24665: GO 24367
24667: POP
24668: POP
// end ;
24669: GO 24348
24671: POP
24672: POP
// wait ( 0 0$30 ) ;
24673: LD_INT 1050
24675: PPUSH
24676: CALL_OW 67
// MC_Kill ( 4 ) ;
24680: LD_INT 4
24682: PPUSH
24683: CALL 39821 0 1
// tmp := UnitsInside ( fac ) ;
24687: LD_ADDR_VAR 0 3
24691: PUSH
24692: LD_VAR 0 10
24696: PPUSH
24697: CALL_OW 313
24701: ST_TO_ADDR
// if tmp then
24702: LD_VAR 0 3
24706: IFFALSE 24827
// for i in tmp do
24708: LD_ADDR_VAR 0 1
24712: PUSH
24713: LD_VAR 0 3
24717: PUSH
24718: FOR_IN
24719: IFFALSE 24825
// begin ComExitBuilding ( i ) ;
24721: LD_VAR 0 1
24725: PPUSH
24726: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
24730: LD_VAR 0 11
24734: PUSH
24735: LD_INT 2
24737: ARRAY
24738: PPUSH
24739: CALL_OW 313
24743: PUSH
24744: LD_INT 6
24746: LESS
24747: IFFALSE 24769
// AddComEnterUnit ( i , arm [ 2 ] ) else
24749: LD_VAR 0 1
24753: PPUSH
24754: LD_VAR 0 11
24758: PUSH
24759: LD_INT 2
24761: ARRAY
24762: PPUSH
24763: CALL_OW 180
24767: GO 24823
// if UnitsInside ( arm [ 1 ] ) < 6 then
24769: LD_VAR 0 11
24773: PUSH
24774: LD_INT 1
24776: ARRAY
24777: PPUSH
24778: CALL_OW 313
24782: PUSH
24783: LD_INT 6
24785: LESS
24786: IFFALSE 24808
// AddComEnterUnit ( i , arm [ 1 ] ) else
24788: LD_VAR 0 1
24792: PPUSH
24793: LD_VAR 0 11
24797: PUSH
24798: LD_INT 1
24800: ARRAY
24801: PPUSH
24802: CALL_OW 180
24806: GO 24823
// AddComMoveXY ( i , 37 , 68 ) ;
24808: LD_VAR 0 1
24812: PPUSH
24813: LD_INT 37
24815: PPUSH
24816: LD_INT 68
24818: PPUSH
24819: CALL_OW 171
// end ;
24823: GO 24718
24825: POP
24826: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
24827: LD_ADDR_VAR 0 12
24831: PUSH
24832: LD_VAR 0 6
24836: PPUSH
24837: LD_INT 26
24839: PUSH
24840: LD_INT 1
24842: PUSH
24843: EMPTY
24844: LIST
24845: LIST
24846: PPUSH
24847: CALL_OW 72
24851: PUSH
24852: LD_EXP 62
24856: DIFF
24857: ST_TO_ADDR
// if not speaker then
24858: LD_VAR 0 12
24862: NOT
24863: IFFALSE 24890
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
24865: LD_ADDR_VAR 0 12
24869: PUSH
24870: LD_VAR 0 6
24874: PPUSH
24875: LD_INT 26
24877: PUSH
24878: LD_INT 1
24880: PUSH
24881: EMPTY
24882: LIST
24883: LIST
24884: PPUSH
24885: CALL_OW 72
24889: ST_TO_ADDR
// if speaker then
24890: LD_VAR 0 12
24894: IFFALSE 24910
// speaker := speaker [ 1 ] ;
24896: LD_ADDR_VAR 0 12
24900: PUSH
24901: LD_VAR 0 12
24905: PUSH
24906: LD_INT 1
24908: ARRAY
24909: ST_TO_ADDR
// Video ( true ) ;
24910: LD_INT 1
24912: PPUSH
24913: CALL 107935 0 1
// CenterNowOnUnits ( Powell ) ;
24917: LD_EXP 61
24921: PPUSH
24922: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
24926: LD_ADDR_VAR 0 3
24930: PUSH
24931: LD_VAR 0 6
24935: PPUSH
24936: LD_INT 3
24938: PUSH
24939: LD_INT 25
24941: PUSH
24942: LD_INT 1
24944: PUSH
24945: EMPTY
24946: LIST
24947: LIST
24948: PUSH
24949: EMPTY
24950: LIST
24951: LIST
24952: PPUSH
24953: CALL_OW 72
24957: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
24958: LD_ADDR_VAR 0 13
24962: PUSH
24963: LD_INT 22
24965: PUSH
24966: LD_INT 4
24968: PUSH
24969: EMPTY
24970: LIST
24971: LIST
24972: PUSH
24973: LD_INT 30
24975: PUSH
24976: LD_INT 32
24978: PUSH
24979: EMPTY
24980: LIST
24981: LIST
24982: PUSH
24983: LD_INT 58
24985: PUSH
24986: EMPTY
24987: LIST
24988: PUSH
24989: EMPTY
24990: LIST
24991: LIST
24992: LIST
24993: PPUSH
24994: CALL_OW 69
24998: ST_TO_ADDR
// t := Count ( tmp ) ;
24999: LD_ADDR_VAR 0 7
25003: PUSH
25004: LD_VAR 0 3
25008: PPUSH
25009: CALL 72374 0 1
25013: ST_TO_ADDR
// if t > 4 then
25014: LD_VAR 0 7
25018: PUSH
25019: LD_INT 4
25021: GREATER
25022: IFFALSE 25032
// t := 4 ;
25024: LD_ADDR_VAR 0 7
25028: PUSH
25029: LD_INT 4
25031: ST_TO_ADDR
// for i := 1 to t do
25032: LD_ADDR_VAR 0 1
25036: PUSH
25037: DOUBLE
25038: LD_INT 1
25040: DEC
25041: ST_TO_ADDR
25042: LD_VAR 0 7
25046: PUSH
25047: FOR_TO
25048: IFFALSE 25194
// begin if IsInUnit ( tmp [ i ] ) then
25050: LD_VAR 0 3
25054: PUSH
25055: LD_VAR 0 1
25059: ARRAY
25060: PPUSH
25061: CALL_OW 310
25065: IFFALSE 25082
// ComExitBuilding ( tmp [ i ] ) ;
25067: LD_VAR 0 3
25071: PUSH
25072: LD_VAR 0 1
25076: ARRAY
25077: PPUSH
25078: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
25082: LD_VAR 0 3
25086: PUSH
25087: LD_VAR 0 1
25091: ARRAY
25092: PPUSH
25093: LD_VAR 0 11
25097: PUSH
25098: LD_INT 1
25100: ARRAY
25101: PPUSH
25102: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
25106: LD_VAR 0 3
25110: PUSH
25111: LD_VAR 0 1
25115: ARRAY
25116: PPUSH
25117: LD_INT 1
25119: PPUSH
25120: CALL_OW 183
// if Count ( emp_towers ) then
25124: LD_VAR 0 13
25128: PPUSH
25129: CALL 72374 0 1
25133: IFFALSE 25192
// begin AddComExitBuilding ( tmp [ i ] ) ;
25135: LD_VAR 0 3
25139: PUSH
25140: LD_VAR 0 1
25144: ARRAY
25145: PPUSH
25146: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
25150: LD_VAR 0 3
25154: PUSH
25155: LD_VAR 0 1
25159: ARRAY
25160: PPUSH
25161: LD_VAR 0 13
25165: PUSH
25166: LD_INT 1
25168: ARRAY
25169: PPUSH
25170: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
25174: LD_ADDR_VAR 0 13
25178: PUSH
25179: LD_VAR 0 13
25183: PPUSH
25184: LD_INT 1
25186: PPUSH
25187: CALL_OW 3
25191: ST_TO_ADDR
// end ; end ;
25192: GO 25047
25194: POP
25195: POP
// wait ( 0 0$5 ) ;
25196: LD_INT 175
25198: PPUSH
25199: CALL_OW 67
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
25203: LD_VAR 0 3
25207: PPUSH
25208: LD_INT 3
25210: PUSH
25211: LD_INT 54
25213: PUSH
25214: EMPTY
25215: LIST
25216: PUSH
25217: EMPTY
25218: LIST
25219: LIST
25220: PPUSH
25221: CALL_OW 72
25225: IFFALSE 25245
// ComEnterUnit ( tmp , arm [ 1 ] ) ;
25227: LD_VAR 0 3
25231: PPUSH
25232: LD_VAR 0 11
25236: PUSH
25237: LD_INT 1
25239: ARRAY
25240: PPUSH
25241: CALL_OW 120
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
25245: LD_ADDR_VAR 0 3
25249: PUSH
25250: LD_EXP 18
25254: PUSH
25255: LD_INT 1
25257: ARRAY
25258: PUSH
25259: LD_EXP 18
25263: PUSH
25264: LD_INT 2
25266: ARRAY
25267: ADD
25268: PPUSH
25269: LD_INT 26
25271: PUSH
25272: LD_INT 1
25274: PUSH
25275: EMPTY
25276: LIST
25277: LIST
25278: PPUSH
25279: CALL_OW 72
25283: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
25284: LD_ADDR_VAR 0 1
25288: PUSH
25289: LD_EXP 18
25293: PUSH
25294: LD_INT 2
25296: ARRAY
25297: PUSH
25298: FOR_IN
25299: IFFALSE 25317
// ComTurnUnit ( i , Powell ) ;
25301: LD_VAR 0 1
25305: PPUSH
25306: LD_EXP 61
25310: PPUSH
25311: CALL_OW 119
25315: GO 25298
25317: POP
25318: POP
// Say ( Powell , D5-Pow-1 ) ;
25319: LD_EXP 61
25323: PPUSH
25324: LD_STRING D5-Pow-1
25326: PPUSH
25327: CALL_OW 88
// if tmp then
25331: LD_VAR 0 3
25335: IFFALSE 25353
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
25337: LD_VAR 0 3
25341: PUSH
25342: LD_INT 1
25344: ARRAY
25345: PPUSH
25346: LD_STRING D5-Sol2-1
25348: PPUSH
25349: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
25353: LD_EXP 61
25357: PPUSH
25358: LD_STRING D5-Pow-2
25360: PPUSH
25361: CALL_OW 88
// if tmp > 1 then
25365: LD_VAR 0 3
25369: PUSH
25370: LD_INT 1
25372: GREATER
25373: IFFALSE 25391
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
25375: LD_VAR 0 3
25379: PUSH
25380: LD_INT 2
25382: ARRAY
25383: PPUSH
25384: LD_STRING D5-Sol2-2
25386: PPUSH
25387: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
25391: LD_EXP 61
25395: PPUSH
25396: LD_STRING D5-Pow-3
25398: PPUSH
25399: CALL_OW 88
// wait ( 0 0$1 ) ;
25403: LD_INT 35
25405: PPUSH
25406: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
25410: LD_ADDR_VAR 0 3
25414: PUSH
25415: LD_EXP 18
25419: PUSH
25420: LD_INT 1
25422: ARRAY
25423: PUSH
25424: LD_EXP 18
25428: PUSH
25429: LD_INT 2
25431: ARRAY
25432: UNION
25433: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
25434: LD_VAR 0 3
25438: PPUSH
25439: LD_INT 80
25441: PPUSH
25442: LD_INT 67
25444: PPUSH
25445: CALL_OW 114
// wait ( 0 0$2 ) ;
25449: LD_INT 70
25451: PPUSH
25452: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
25456: LD_INT 79
25458: PPUSH
25459: LD_INT 72
25461: PPUSH
25462: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
25466: LD_INT 70
25468: PPUSH
25469: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
25473: LD_VAR 0 3
25477: PPUSH
25478: LD_INT 3
25480: PUSH
25481: LD_INT 24
25483: PUSH
25484: LD_INT 1000
25486: PUSH
25487: EMPTY
25488: LIST
25489: LIST
25490: PUSH
25491: EMPTY
25492: LIST
25493: LIST
25494: PPUSH
25495: CALL_OW 72
25499: IFFALSE 25466
// Say ( Powell , D5a-Pow-1 ) ;
25501: LD_EXP 61
25505: PPUSH
25506: LD_STRING D5a-Pow-1
25508: PPUSH
25509: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
25513: LD_EXP 61
25517: PPUSH
25518: LD_STRING D5a-Pow-1a
25520: PPUSH
25521: CALL_OW 88
// wait ( 0 0$0.7 ) ;
25525: LD_INT 24
25527: PPUSH
25528: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
25532: LD_EXP 61
25536: PPUSH
25537: LD_STRING D5a-Pow-1b
25539: PPUSH
25540: CALL_OW 88
// wait ( 0 0$0.3 ) ;
25544: LD_INT 10
25546: PPUSH
25547: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
25551: LD_EXP 61
25555: PPUSH
25556: LD_STRING D5a-Pow-1c
25558: PPUSH
25559: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
25563: LD_VAR 0 3
25567: PPUSH
25568: LD_INT 68
25570: PPUSH
25571: LD_INT 63
25573: PPUSH
25574: CALL_OW 111
// wait ( 0 0$0.5 ) ;
25578: LD_INT 18
25580: PPUSH
25581: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
25585: LD_EXP 61
25589: PPUSH
25590: LD_STRING D5a-Pow-1d
25592: PPUSH
25593: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
25597: LD_INT 35
25599: PPUSH
25600: CALL_OW 67
// if not HasTask ( tmp ) then
25604: LD_VAR 0 3
25608: PPUSH
25609: CALL_OW 314
25613: NOT
25614: IFFALSE 25631
// ComAgressiveMove ( tmp , 68 , 63 ) ;
25616: LD_VAR 0 3
25620: PPUSH
25621: LD_INT 68
25623: PPUSH
25624: LD_INT 63
25626: PPUSH
25627: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
25631: LD_VAR 0 3
25635: PPUSH
25636: LD_INT 24
25638: PUSH
25639: LD_INT 1
25641: PUSH
25642: EMPTY
25643: LIST
25644: LIST
25645: PPUSH
25646: CALL_OW 72
25650: NOT
25651: IFFALSE 25597
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
25653: LD_ADDR_VAR 0 3
25657: PUSH
25658: LD_INT 22
25660: PUSH
25661: LD_INT 4
25663: PUSH
25664: EMPTY
25665: LIST
25666: LIST
25667: PUSH
25668: LD_INT 92
25670: PUSH
25671: LD_INT 60
25673: PUSH
25674: LD_INT 93
25676: PUSH
25677: LD_INT 10
25679: PUSH
25680: EMPTY
25681: LIST
25682: LIST
25683: LIST
25684: LIST
25685: PUSH
25686: LD_INT 3
25688: PUSH
25689: LD_INT 54
25691: PUSH
25692: EMPTY
25693: LIST
25694: PUSH
25695: EMPTY
25696: LIST
25697: LIST
25698: PUSH
25699: EMPTY
25700: LIST
25701: LIST
25702: LIST
25703: PPUSH
25704: CALL_OW 69
25708: PUSH
25709: LD_EXP 61
25713: DIFF
25714: ST_TO_ADDR
// if tmp then
25715: LD_VAR 0 3
25719: IFFALSE 25753
// for i in tmp do
25721: LD_ADDR_VAR 0 1
25725: PUSH
25726: LD_VAR 0 3
25730: PUSH
25731: FOR_IN
25732: IFFALSE 25751
// ComMoveXY ( i , 36 , 67 ) ;
25734: LD_VAR 0 1
25738: PPUSH
25739: LD_INT 36
25741: PPUSH
25742: LD_INT 67
25744: PPUSH
25745: CALL_OW 111
25749: GO 25731
25751: POP
25752: POP
// wait ( 0 0$3 ) ;
25753: LD_INT 105
25755: PPUSH
25756: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
25760: LD_VAR 0 12
25764: PPUSH
25765: LD_STRING D6-Sol3-1
25767: PPUSH
25768: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
25772: LD_EXP 61
25776: PPUSH
25777: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
25781: LD_EXP 61
25785: PPUSH
25786: LD_STRING D6-Pow-1
25788: PPUSH
25789: CALL_OW 88
// tmp := [ ] ;
25793: LD_ADDR_VAR 0 3
25797: PUSH
25798: EMPTY
25799: ST_TO_ADDR
// for i = 1 to 2 do
25800: LD_ADDR_VAR 0 1
25804: PUSH
25805: DOUBLE
25806: LD_INT 1
25808: DEC
25809: ST_TO_ADDR
25810: LD_INT 2
25812: PUSH
25813: FOR_TO
25814: IFFALSE 25928
// begin uc_side := 8 ;
25816: LD_ADDR_OWVAR 20
25820: PUSH
25821: LD_INT 8
25823: ST_TO_ADDR
// uc_nation := 2 ;
25824: LD_ADDR_OWVAR 21
25828: PUSH
25829: LD_INT 2
25831: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
25832: LD_INT 14
25834: PPUSH
25835: LD_INT 3
25837: PPUSH
25838: LD_INT 2
25840: PPUSH
25841: LD_INT 29
25843: PPUSH
25844: LD_INT 100
25846: PPUSH
25847: CALL 75112 0 5
// veh := CreateVehicle ;
25851: LD_ADDR_VAR 0 14
25855: PUSH
25856: CALL_OW 45
25860: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
25861: LD_VAR 0 14
25865: PPUSH
25866: LD_INT 4
25868: PPUSH
25869: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
25873: LD_VAR 0 14
25877: PPUSH
25878: LD_INT 99
25880: PPUSH
25881: LD_INT 83
25883: PPUSH
25884: LD_INT 3
25886: PPUSH
25887: LD_INT 0
25889: PPUSH
25890: CALL_OW 50
// wait ( 3 ) ;
25894: LD_INT 3
25896: PPUSH
25897: CALL_OW 67
// Connect ( veh ) ;
25901: LD_VAR 0 14
25905: PPUSH
25906: CALL 78580 0 1
// tmp := tmp ^ veh ;
25910: LD_ADDR_VAR 0 3
25914: PUSH
25915: LD_VAR 0 3
25919: PUSH
25920: LD_VAR 0 14
25924: ADD
25925: ST_TO_ADDR
// end ;
25926: GO 25813
25928: POP
25929: POP
// wait ( 0 0$1 ) ;
25930: LD_INT 35
25932: PPUSH
25933: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
25937: LD_INT 99
25939: PPUSH
25940: LD_INT 83
25942: PPUSH
25943: LD_INT 1
25945: PPUSH
25946: LD_INT 10
25948: PPUSH
25949: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
25953: LD_INT 99
25955: PPUSH
25956: LD_INT 83
25958: PPUSH
25959: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
25963: LD_VAR 0 12
25967: PPUSH
25968: LD_STRING D6-Sol3-2
25970: PPUSH
25971: CALL_OW 88
// async ;
25975: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
25976: LD_EXP 61
25980: PPUSH
25981: LD_STRING D6-Pow-2
25983: PPUSH
25984: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
25988: LD_VAR 0 3
25992: PUSH
25993: LD_INT 1
25995: ARRAY
25996: PPUSH
25997: LD_VAR 0 10
26001: PPUSH
26002: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
26006: LD_VAR 0 3
26010: PUSH
26011: LD_INT 2
26013: ARRAY
26014: PPUSH
26015: LD_INT 22
26017: PUSH
26018: LD_INT 4
26020: PUSH
26021: EMPTY
26022: LIST
26023: LIST
26024: PUSH
26025: LD_INT 21
26027: PUSH
26028: LD_INT 3
26030: PUSH
26031: EMPTY
26032: LIST
26033: LIST
26034: PUSH
26035: EMPTY
26036: LIST
26037: LIST
26038: PPUSH
26039: CALL_OW 69
26043: PPUSH
26044: LD_VAR 0 3
26048: PUSH
26049: LD_INT 2
26051: ARRAY
26052: PPUSH
26053: CALL_OW 74
26057: PPUSH
26058: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
26062: LD_EXP 61
26066: PPUSH
26067: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
26071: LD_INT 99
26073: PPUSH
26074: LD_INT 83
26076: PPUSH
26077: LD_INT 1
26079: PPUSH
26080: CALL_OW 331
// repeat wait ( 4 ) ;
26084: LD_INT 4
26086: PPUSH
26087: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
26091: LD_VAR 0 3
26095: PUSH
26096: LD_INT 1
26098: ARRAY
26099: PPUSH
26100: CALL_OW 256
26104: PUSH
26105: LD_INT 1000
26107: LESS
26108: IFFALSE 26126
// SetLives ( tmp [ 1 ] , 1000 ) ;
26110: LD_VAR 0 3
26114: PUSH
26115: LD_INT 1
26117: ARRAY
26118: PPUSH
26119: LD_INT 1000
26121: PPUSH
26122: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
26126: LD_INT 22
26128: PUSH
26129: LD_INT 4
26131: PUSH
26132: EMPTY
26133: LIST
26134: LIST
26135: PUSH
26136: LD_INT 30
26138: PUSH
26139: LD_INT 3
26141: PUSH
26142: EMPTY
26143: LIST
26144: LIST
26145: PUSH
26146: EMPTY
26147: LIST
26148: LIST
26149: PPUSH
26150: CALL_OW 69
26154: PUSH
26155: LD_INT 0
26157: EQUAL
26158: IFFALSE 26084
// skirmish := false ;
26160: LD_ADDR_EXP 100
26164: PUSH
26165: LD_INT 0
26167: ST_TO_ADDR
// sync ;
26168: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
26169: LD_EXP 61
26173: PPUSH
26174: LD_STRING D6a-Pow-1
26176: PPUSH
26177: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
26181: LD_VAR 0 12
26185: PPUSH
26186: LD_STRING D6a-Sol3-1
26188: PPUSH
26189: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
26193: LD_EXP 61
26197: PPUSH
26198: LD_STRING D6a-Pow-2
26200: PPUSH
26201: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
26205: LD_VAR 0 12
26209: PPUSH
26210: LD_STRING D6a-Sol3-2
26212: PPUSH
26213: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
26217: LD_EXP 61
26221: PPUSH
26222: LD_STRING D6a-Pow-3
26224: PPUSH
26225: CALL_OW 88
// powellCenterCameraMode := true ;
26229: LD_ADDR_EXP 20
26233: PUSH
26234: LD_INT 1
26236: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
26237: LD_ADDR_VAR 0 1
26241: PUSH
26242: LD_INT 22
26244: PUSH
26245: LD_INT 8
26247: PUSH
26248: EMPTY
26249: LIST
26250: LIST
26251: PUSH
26252: LD_INT 25
26254: PUSH
26255: LD_INT 2
26257: PUSH
26258: EMPTY
26259: LIST
26260: LIST
26261: PUSH
26262: EMPTY
26263: LIST
26264: LIST
26265: PPUSH
26266: CALL_OW 69
26270: PUSH
26271: FOR_IN
26272: IFFALSE 26327
// begin SetTag ( i , 1 ) ;
26274: LD_VAR 0 1
26278: PPUSH
26279: LD_INT 1
26281: PPUSH
26282: CALL_OW 109
// ComExitBuilding ( i ) ;
26286: LD_VAR 0 1
26290: PPUSH
26291: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
26295: LD_VAR 0 1
26299: PPUSH
26300: LD_INT 35
26302: PPUSH
26303: LD_INT 6
26305: PPUSH
26306: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
26310: LD_VAR 0 1
26314: PPUSH
26315: LD_INT 53
26317: PPUSH
26318: LD_INT 4
26320: PPUSH
26321: CALL_OW 171
// end ;
26325: GO 26271
26327: POP
26328: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
26329: LD_ADDR_VAR 0 3
26333: PUSH
26334: LD_INT 22
26336: PUSH
26337: LD_INT 4
26339: PUSH
26340: EMPTY
26341: LIST
26342: LIST
26343: PUSH
26344: LD_INT 21
26346: PUSH
26347: LD_INT 2
26349: PUSH
26350: EMPTY
26351: LIST
26352: LIST
26353: PUSH
26354: LD_INT 3
26356: PUSH
26357: LD_INT 34
26359: PUSH
26360: LD_INT 12
26362: PUSH
26363: EMPTY
26364: LIST
26365: LIST
26366: PUSH
26367: EMPTY
26368: LIST
26369: LIST
26370: PUSH
26371: EMPTY
26372: LIST
26373: LIST
26374: LIST
26375: PPUSH
26376: CALL_OW 69
26380: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
26381: LD_EXP 61
26385: PPUSH
26386: LD_VAR 0 3
26390: PPUSH
26391: LD_EXP 61
26395: PPUSH
26396: CALL_OW 74
26400: PPUSH
26401: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
26405: LD_EXP 61
26409: PPUSH
26410: LD_INT 100
26412: PPUSH
26413: LD_INT 88
26415: PPUSH
26416: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
26420: LD_EXP 61
26424: PPUSH
26425: LD_INT 100
26427: PPUSH
26428: LD_INT 75
26430: PPUSH
26431: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
26435: LD_EXP 61
26439: PPUSH
26440: LD_INT 88
26442: PPUSH
26443: LD_INT 53
26445: PPUSH
26446: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
26450: LD_INT 8
26452: PPUSH
26453: LD_EXP 61
26457: PPUSH
26458: CALL_OW 471
// repeat wait ( 3 ) ;
26462: LD_INT 3
26464: PPUSH
26465: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
26469: LD_INT 22
26471: PUSH
26472: LD_INT 4
26474: PUSH
26475: EMPTY
26476: LIST
26477: LIST
26478: PUSH
26479: LD_INT 92
26481: PUSH
26482: LD_INT 100
26484: PUSH
26485: LD_INT 75
26487: PUSH
26488: LD_INT 6
26490: PUSH
26491: EMPTY
26492: LIST
26493: LIST
26494: LIST
26495: LIST
26496: PUSH
26497: EMPTY
26498: LIST
26499: LIST
26500: PPUSH
26501: CALL_OW 69
26505: IFFALSE 26462
// async ;
26507: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
26508: LD_EXP 61
26512: PPUSH
26513: LD_STRING D6b-Pow-1
26515: PPUSH
26516: CALL_OW 88
// repeat wait ( 3 ) ;
26520: LD_INT 3
26522: PPUSH
26523: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
26527: LD_EXP 61
26531: PPUSH
26532: CALL_OW 310
26536: PPUSH
26537: CALL_OW 256
26541: PUSH
26542: LD_INT 1000
26544: LESS
26545: IFFALSE 26564
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
26547: LD_EXP 61
26551: PPUSH
26552: CALL_OW 310
26556: PPUSH
26557: LD_INT 1000
26559: PPUSH
26560: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
26564: LD_EXP 61
26568: PPUSH
26569: CALL_OW 256
26573: PUSH
26574: LD_INT 1000
26576: LESS
26577: IFFALSE 26591
// SetLives ( Powell , 1000 ) ;
26579: LD_EXP 61
26583: PPUSH
26584: LD_INT 1000
26586: PPUSH
26587: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
26591: LD_EXP 61
26595: PPUSH
26596: LD_EXP 67
26600: PPUSH
26601: CALL_OW 296
26605: PUSH
26606: LD_INT 5
26608: LESS
26609: PUSH
26610: LD_EXP 61
26614: PPUSH
26615: CALL_OW 310
26619: PPUSH
26620: LD_EXP 67
26624: PPUSH
26625: CALL_OW 296
26629: PUSH
26630: LD_INT 5
26632: LESS
26633: OR
26634: IFFALSE 26653
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
26636: LD_EXP 61
26640: PPUSH
26641: CALL_OW 310
26645: PPUSH
26646: LD_INT 100
26648: PPUSH
26649: CALL_OW 234
// until not IsInUnit ( Powell ) ;
26653: LD_EXP 61
26657: PPUSH
26658: CALL_OW 310
26662: NOT
26663: IFFALSE 26520
// DoNotAttack ( 8 , powellBomb ) ;
26665: LD_INT 8
26667: PPUSH
26668: LD_EXP 67
26672: PPUSH
26673: CALL_OW 471
// game_speed := 4 ;
26677: LD_ADDR_OWVAR 65
26681: PUSH
26682: LD_INT 4
26684: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
26685: LD_EXP 61
26689: PPUSH
26690: LD_STRING D6b-Pow-1a
26692: PPUSH
26693: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
26697: LD_EXP 61
26701: PPUSH
26702: LD_EXP 67
26706: PPUSH
26707: CALL_OW 180
// sync ;
26711: SYNC
// repeat wait ( 0 0$1 ) ;
26712: LD_INT 35
26714: PPUSH
26715: CALL_OW 67
// until IsInUnit ( Powell ) ;
26719: LD_EXP 61
26723: PPUSH
26724: CALL_OW 310
26728: IFFALSE 26712
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
26730: LD_INT 8
26732: PPUSH
26733: LD_EXP 61
26737: PPUSH
26738: CALL_OW 310
26742: PPUSH
26743: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
26747: LD_EXP 61
26751: PPUSH
26752: LD_INT 91
26754: PPUSH
26755: LD_INT 44
26757: PPUSH
26758: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26762: LD_EXP 61
26766: PPUSH
26767: LD_INT 96
26769: PPUSH
26770: LD_INT 44
26772: PPUSH
26773: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26777: LD_EXP 61
26781: PPUSH
26782: LD_INT 96
26784: PPUSH
26785: LD_INT 41
26787: PPUSH
26788: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
26792: LD_EXP 61
26796: PPUSH
26797: LD_INT 92
26799: PPUSH
26800: LD_INT 39
26802: PPUSH
26803: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
26807: LD_EXP 61
26811: PPUSH
26812: LD_INT 88
26814: PPUSH
26815: LD_INT 41
26817: PPUSH
26818: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
26822: LD_EXP 61
26826: PPUSH
26827: LD_INT 91
26829: PPUSH
26830: LD_INT 44
26832: PPUSH
26833: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26837: LD_EXP 61
26841: PPUSH
26842: LD_INT 96
26844: PPUSH
26845: LD_INT 44
26847: PPUSH
26848: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26852: LD_EXP 61
26856: PPUSH
26857: LD_INT 96
26859: PPUSH
26860: LD_INT 41
26862: PPUSH
26863: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
26867: LD_EXP 61
26871: PPUSH
26872: LD_INT 92
26874: PPUSH
26875: LD_INT 39
26877: PPUSH
26878: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
26882: LD_EXP 61
26886: PPUSH
26887: LD_INT 88
26889: PPUSH
26890: LD_INT 41
26892: PPUSH
26893: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
26897: LD_EXP 61
26901: PPUSH
26902: LD_INT 91
26904: PPUSH
26905: LD_INT 44
26907: PPUSH
26908: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
26912: LD_EXP 61
26916: PPUSH
26917: LD_INT 93
26919: PPUSH
26920: LD_INT 39
26922: PPUSH
26923: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
26927: LD_EXP 61
26931: PPUSH
26932: LD_INT 93
26934: PPUSH
26935: LD_INT 36
26937: PPUSH
26938: CALL_OW 171
// wait ( 0 0$3.5 ) ;
26942: LD_INT 122
26944: PPUSH
26945: CALL_OW 67
// game_speed := 4 ;
26949: LD_ADDR_OWVAR 65
26953: PUSH
26954: LD_INT 4
26956: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
26957: LD_EXP 61
26961: PPUSH
26962: LD_STRING D6b-Pow-1b
26964: PPUSH
26965: CALL_OW 88
// tmp := [ ] ;
26969: LD_ADDR_VAR 0 3
26973: PUSH
26974: EMPTY
26975: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
26976: LD_ADDR_VAR 0 5
26980: PUSH
26981: LD_INT 78
26983: PUSH
26984: LD_INT 47
26986: PUSH
26987: EMPTY
26988: LIST
26989: LIST
26990: PUSH
26991: LD_INT 106
26993: PUSH
26994: LD_INT 53
26996: PUSH
26997: EMPTY
26998: LIST
26999: LIST
27000: PUSH
27001: EMPTY
27002: LIST
27003: LIST
27004: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
27005: LD_ADDR_VAR 0 1
27009: PUSH
27010: LD_INT 22
27012: PUSH
27013: LD_INT 8
27015: PUSH
27016: EMPTY
27017: LIST
27018: LIST
27019: PUSH
27020: LD_INT 21
27022: PUSH
27023: LD_INT 3
27025: PUSH
27026: EMPTY
27027: LIST
27028: LIST
27029: PUSH
27030: LD_INT 92
27032: PUSH
27033: LD_INT 90
27035: PUSH
27036: LD_INT 52
27038: PUSH
27039: LD_INT 12
27041: PUSH
27042: EMPTY
27043: LIST
27044: LIST
27045: LIST
27046: LIST
27047: PUSH
27048: EMPTY
27049: LIST
27050: LIST
27051: LIST
27052: PPUSH
27053: CALL_OW 69
27057: PUSH
27058: FOR_IN
27059: IFFALSE 27084
// tmp := tmp ^ UnitsInside ( i ) ;
27061: LD_ADDR_VAR 0 3
27065: PUSH
27066: LD_VAR 0 3
27070: PUSH
27071: LD_VAR 0 1
27075: PPUSH
27076: CALL_OW 313
27080: ADD
27081: ST_TO_ADDR
27082: GO 27058
27084: POP
27085: POP
// for i in tmp do
27086: LD_ADDR_VAR 0 1
27090: PUSH
27091: LD_VAR 0 3
27095: PUSH
27096: FOR_IN
27097: IFFALSE 27259
// begin dist := 9999 ;
27099: LD_ADDR_VAR 0 9
27103: PUSH
27104: LD_INT 9999
27106: ST_TO_ADDR
// _xy := [ ] ;
27107: LD_ADDR_VAR 0 8
27111: PUSH
27112: EMPTY
27113: ST_TO_ADDR
// SetTag ( i , 1 ) ;
27114: LD_VAR 0 1
27118: PPUSH
27119: LD_INT 1
27121: PPUSH
27122: CALL_OW 109
// ComExitBuilding ( i ) ;
27126: LD_VAR 0 1
27130: PPUSH
27131: CALL_OW 122
// for j in xy do
27135: LD_ADDR_VAR 0 2
27139: PUSH
27140: LD_VAR 0 5
27144: PUSH
27145: FOR_IN
27146: IFFALSE 27228
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
27148: LD_VAR 0 1
27152: PPUSH
27153: LD_VAR 0 2
27157: PUSH
27158: LD_INT 1
27160: ARRAY
27161: PPUSH
27162: LD_VAR 0 2
27166: PUSH
27167: LD_INT 2
27169: ARRAY
27170: PPUSH
27171: CALL_OW 297
27175: PUSH
27176: LD_VAR 0 9
27180: LESS
27181: IFFALSE 27226
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
27183: LD_ADDR_VAR 0 9
27187: PUSH
27188: LD_VAR 0 1
27192: PPUSH
27193: LD_VAR 0 2
27197: PUSH
27198: LD_INT 1
27200: ARRAY
27201: PPUSH
27202: LD_VAR 0 2
27206: PUSH
27207: LD_INT 2
27209: ARRAY
27210: PPUSH
27211: CALL_OW 297
27215: ST_TO_ADDR
// _xy := j ;
27216: LD_ADDR_VAR 0 8
27220: PUSH
27221: LD_VAR 0 2
27225: ST_TO_ADDR
// end ;
27226: GO 27145
27228: POP
27229: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
27230: LD_VAR 0 1
27234: PPUSH
27235: LD_VAR 0 8
27239: PUSH
27240: LD_INT 1
27242: ARRAY
27243: PPUSH
27244: LD_VAR 0 8
27248: PUSH
27249: LD_INT 2
27251: ARRAY
27252: PPUSH
27253: CALL_OW 171
// end ;
27257: GO 27096
27259: POP
27260: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
27261: LD_ADDR_VAR 0 4
27265: PUSH
27266: LD_VAR 0 3
27270: PPUSH
27271: LD_INT 26
27273: PUSH
27274: LD_INT 1
27276: PUSH
27277: EMPTY
27278: LIST
27279: LIST
27280: PUSH
27281: LD_INT 25
27283: PUSH
27284: LD_INT 1
27286: PUSH
27287: EMPTY
27288: LIST
27289: LIST
27290: PUSH
27291: EMPTY
27292: LIST
27293: LIST
27294: PPUSH
27295: CALL_OW 72
27299: ST_TO_ADDR
// if tmp2 < 2 then
27300: LD_VAR 0 4
27304: PUSH
27305: LD_INT 2
27307: LESS
27308: IFFALSE 27377
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
27310: LD_ADDR_VAR 0 4
27314: PUSH
27315: LD_INT 22
27317: PUSH
27318: LD_INT 8
27320: PUSH
27321: EMPTY
27322: LIST
27323: LIST
27324: PUSH
27325: LD_INT 26
27327: PUSH
27328: LD_INT 1
27330: PUSH
27331: EMPTY
27332: LIST
27333: LIST
27334: PUSH
27335: LD_INT 3
27337: PUSH
27338: LD_INT 25
27340: PUSH
27341: LD_INT 15
27343: PUSH
27344: EMPTY
27345: LIST
27346: LIST
27347: PUSH
27348: EMPTY
27349: LIST
27350: LIST
27351: PUSH
27352: EMPTY
27353: LIST
27354: LIST
27355: LIST
27356: PPUSH
27357: CALL_OW 69
27361: PUSH
27362: LD_EXP 64
27366: PUSH
27367: LD_EXP 65
27371: PUSH
27372: EMPTY
27373: LIST
27374: LIST
27375: DIFF
27376: ST_TO_ADDR
// if tmp2 then
27377: LD_VAR 0 4
27381: IFFALSE 27399
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
27383: LD_VAR 0 4
27387: PUSH
27388: LD_INT 1
27390: ARRAY
27391: PPUSH
27392: LD_STRING D6b-ArSol1-1
27394: PPUSH
27395: CALL_OW 88
// async ;
27399: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
27400: LD_EXP 61
27404: PPUSH
27405: LD_STRING D6b-Pow-2
27407: PPUSH
27408: CALL_OW 88
// wait ( 0 0$0.5 ) ;
27412: LD_INT 18
27414: PPUSH
27415: CALL_OW 67
// if tmp2 > 1 then
27419: LD_VAR 0 4
27423: PUSH
27424: LD_INT 1
27426: GREATER
27427: IFFALSE 27445
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
27429: LD_VAR 0 4
27433: PUSH
27434: LD_INT 2
27436: ARRAY
27437: PPUSH
27438: LD_STRING D6b-ArSol2-1
27440: PPUSH
27441: CALL_OW 88
// sync ;
27445: SYNC
// repeat wait ( 5 ) ;
27446: LD_INT 5
27448: PPUSH
27449: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
27453: LD_INT 93
27455: PPUSH
27456: LD_INT 36
27458: PPUSH
27459: CALL_OW 428
27463: PPUSH
27464: CALL_OW 255
27468: PUSH
27469: LD_INT 4
27471: EQUAL
27472: IFFALSE 27446
// DialogueOn ;
27474: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
27478: LD_INT 10
27480: PPUSH
27481: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
27485: LD_EXP 61
27489: PPUSH
27490: LD_STRING D6b-Pow-2a
27492: PPUSH
27493: CALL_OW 88
// DialogueOff ;
27497: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
27501: LD_EXP 61
27505: PPUSH
27506: CALL_OW 310
27510: PPUSH
27511: LD_INT 332
27513: PPUSH
27514: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
27518: LD_INT 93
27520: PPUSH
27521: LD_INT 35
27523: PPUSH
27524: LD_INT 1
27526: PPUSH
27527: LD_INT 6
27529: NEG
27530: PPUSH
27531: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
27535: LD_INT 35
27537: PPUSH
27538: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
27542: LD_INT 332
27544: PPUSH
27545: CALL_OW 256
27549: PUSH
27550: LD_INT 1000
27552: LESS
27553: PUSH
27554: LD_INT 332
27556: PPUSH
27557: CALL_OW 300
27561: AND
27562: IFFALSE 27574
// SetLives ( kozlov_fac , 0 ) ;
27564: LD_INT 332
27566: PPUSH
27567: LD_INT 0
27569: PPUSH
27570: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
27574: LD_INT 332
27576: PPUSH
27577: CALL_OW 301
27581: PUSH
27582: LD_EXP 61
27586: PPUSH
27587: CALL_OW 301
27591: OR
27592: IFFALSE 27535
// game_speed := 4 ;
27594: LD_ADDR_OWVAR 65
27598: PUSH
27599: LD_INT 4
27601: ST_TO_ADDR
// powellCenterCameraMode := false ;
27602: LD_ADDR_EXP 20
27606: PUSH
27607: LD_INT 0
27609: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
27610: LD_ADDR_VAR 0 1
27614: PUSH
27615: LD_VAR 0 3
27619: PUSH
27620: LD_INT 22
27622: PUSH
27623: LD_INT 8
27625: PUSH
27626: EMPTY
27627: LIST
27628: LIST
27629: PUSH
27630: LD_INT 25
27632: PUSH
27633: LD_INT 2
27635: PUSH
27636: EMPTY
27637: LIST
27638: LIST
27639: PUSH
27640: EMPTY
27641: LIST
27642: LIST
27643: PPUSH
27644: CALL_OW 69
27648: UNION
27649: PUSH
27650: FOR_IN
27651: IFFALSE 27667
// SetTag ( i , 0 ) ;
27653: LD_VAR 0 1
27657: PPUSH
27658: LD_INT 0
27660: PPUSH
27661: CALL_OW 109
27665: GO 27650
27667: POP
27668: POP
// wait ( 0 0$3 ) ;
27669: LD_INT 105
27671: PPUSH
27672: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
27676: LD_INT 93
27678: PPUSH
27679: LD_INT 35
27681: PPUSH
27682: LD_INT 1
27684: PPUSH
27685: CALL_OW 331
// DialogueOn ;
27689: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
27693: LD_VAR 0 12
27697: PPUSH
27698: LD_STRING D6c-Sol3-1
27700: PPUSH
27701: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
27705: LD_INT 10
27707: PPUSH
27708: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
27712: LD_EXP 40
27716: PPUSH
27717: LD_STRING D6c-JMM-1
27719: PPUSH
27720: CALL_OW 88
// if Cyrus then
27724: LD_EXP 46
27728: IFFALSE 27742
// Say ( Cyrus , D6c-Cyrus-1 ) ;
27730: LD_EXP 46
27734: PPUSH
27735: LD_STRING D6c-Cyrus-1
27737: PPUSH
27738: CALL_OW 88
// if Bobby then
27742: LD_EXP 45
27746: IFFALSE 27760
// Say ( Bobby , D6c-Bobby-1 ) ;
27748: LD_EXP 45
27752: PPUSH
27753: LD_STRING D6c-Bobby-1
27755: PPUSH
27756: CALL_OW 88
// if Cornel then
27760: LD_EXP 51
27764: IFFALSE 27778
// Say ( Cornel , D6c-Corn-1 ) ;
27766: LD_EXP 51
27770: PPUSH
27771: LD_STRING D6c-Corn-1
27773: PPUSH
27774: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
27778: LD_ADDR_VAR 0 4
27782: PUSH
27783: LD_INT 2
27785: PUSH
27786: LD_INT 22
27788: PUSH
27789: LD_INT 1
27791: PUSH
27792: EMPTY
27793: LIST
27794: LIST
27795: PUSH
27796: LD_INT 22
27798: PUSH
27799: LD_INT 4
27801: PUSH
27802: EMPTY
27803: LIST
27804: LIST
27805: PUSH
27806: EMPTY
27807: LIST
27808: LIST
27809: LIST
27810: PUSH
27811: LD_INT 26
27813: PUSH
27814: LD_INT 1
27816: PUSH
27817: EMPTY
27818: LIST
27819: LIST
27820: PUSH
27821: LD_INT 23
27823: PUSH
27824: LD_INT 1
27826: PUSH
27827: EMPTY
27828: LIST
27829: LIST
27830: PUSH
27831: EMPTY
27832: LIST
27833: LIST
27834: LIST
27835: PPUSH
27836: CALL_OW 69
27840: PUSH
27841: LD_VAR 0 12
27845: PUSH
27846: LD_EXP 40
27850: UNION
27851: PUSH
27852: LD_EXP 62
27856: UNION
27857: DIFF
27858: ST_TO_ADDR
// if tmp2 then
27859: LD_VAR 0 4
27863: IFFALSE 27881
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
27865: LD_VAR 0 4
27869: PUSH
27870: LD_INT 1
27872: ARRAY
27873: PPUSH
27874: LD_STRING D6c-Sol1-1
27876: PPUSH
27877: CALL_OW 88
// if Lisa then
27881: LD_EXP 43
27885: IFFALSE 27899
// Say ( Lisa , D6c-Lisa-1 ) ;
27887: LD_EXP 43
27891: PPUSH
27892: LD_STRING D6c-Lisa-1
27894: PPUSH
27895: CALL_OW 88
// if Gary then
27899: LD_EXP 52
27903: IFFALSE 27917
// Say ( Gary , D6c-Gary-1 ) ;
27905: LD_EXP 52
27909: PPUSH
27910: LD_STRING D6c-Gary-1
27912: PPUSH
27913: CALL_OW 88
// if Donaldson then
27917: LD_EXP 44
27921: IFFALSE 27935
// Say ( Donaldson , D6c-Don-1 ) ;
27923: LD_EXP 44
27927: PPUSH
27928: LD_STRING D6c-Don-1
27930: PPUSH
27931: CALL_OW 88
// if tmp2 > 1 then
27935: LD_VAR 0 4
27939: PUSH
27940: LD_INT 1
27942: GREATER
27943: IFFALSE 27961
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
27945: LD_VAR 0 4
27949: PUSH
27950: LD_INT 2
27952: ARRAY
27953: PPUSH
27954: LD_STRING D6c-Sol2-1
27956: PPUSH
27957: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
27961: LD_VAR 0 12
27965: PPUSH
27966: LD_STRING D6c-Sol3-2
27968: PPUSH
27969: CALL_OW 88
// if IsInUnit ( JMM ) then
27973: LD_EXP 40
27977: PPUSH
27978: CALL_OW 310
27982: IFFALSE 28000
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
27984: LD_EXP 40
27988: PPUSH
27989: CALL_OW 310
27993: PPUSH
27994: CALL_OW 87
27998: GO 28009
// CenterNowOnUnits ( JMM ) ;
28000: LD_EXP 40
28004: PPUSH
28005: CALL_OW 87
// dwait ( 0 0$2 ) ;
28009: LD_INT 70
28011: PPUSH
28012: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
28016: LD_EXP 40
28020: PPUSH
28021: LD_STRING D6c-JMM-2
28023: PPUSH
28024: CALL_OW 88
// DialogueOff ;
28028: CALL_OW 7
// Video ( false ) ;
28032: LD_INT 0
28034: PPUSH
28035: CALL 107935 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
28039: LD_INT 22
28041: PUSH
28042: LD_INT 4
28044: PUSH
28045: EMPTY
28046: LIST
28047: LIST
28048: PPUSH
28049: CALL_OW 69
28053: PPUSH
28054: LD_INT 1
28056: PPUSH
28057: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
28061: LD_INT 4
28063: PPUSH
28064: LD_INT 4
28066: PPUSH
28067: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
28071: LD_ADDR_VAR 0 1
28075: PUSH
28076: LD_INT 4
28078: PPUSH
28079: LD_INT 1
28081: PPUSH
28082: LD_INT 2
28084: PPUSH
28085: CALL 70335 0 3
28089: PUSH
28090: FOR_IN
28091: IFFALSE 28128
// if GetTech ( i , 1 ) <> state_researched then
28093: LD_VAR 0 1
28097: PPUSH
28098: LD_INT 1
28100: PPUSH
28101: CALL_OW 321
28105: PUSH
28106: LD_INT 2
28108: NONEQUAL
28109: IFFALSE 28126
// SetTech ( i , 1 , state_researched ) ;
28111: LD_VAR 0 1
28115: PPUSH
28116: LD_INT 1
28118: PPUSH
28119: LD_INT 2
28121: PPUSH
28122: CALL_OW 322
28126: GO 28090
28128: POP
28129: POP
// missionStage := 6 ;
28130: LD_ADDR_EXP 15
28134: PUSH
28135: LD_INT 6
28137: ST_TO_ADDR
// activeAttacks := true ;
28138: LD_ADDR_EXP 16
28142: PUSH
28143: LD_INT 1
28145: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
28146: LD_STRING M2
28148: PPUSH
28149: CALL_OW 337
// SaveForQuickRestart ;
28153: CALL_OW 22
// wait ( 0 0$40 ) ;
28157: LD_INT 1400
28159: PPUSH
28160: CALL_OW 67
// DialogueOn ;
28164: CALL_OW 6
// SayRadioNoFaceNoName ( Friend , D7-Friend-1 ) ;
28168: LD_EXP 66
28172: PPUSH
28173: LD_STRING D7-Friend-1
28175: PPUSH
28176: CALL 112032 0 2
// Say ( JMM , D7-JMM-1 ) ;
28180: LD_EXP 40
28184: PPUSH
28185: LD_STRING D7-JMM-1
28187: PPUSH
28188: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-2 ) ;
28192: LD_EXP 66
28196: PPUSH
28197: LD_STRING D7-Friend-2
28199: PPUSH
28200: CALL 112032 0 2
// Say ( JMM , D7-JMM-2 ) ;
28204: LD_EXP 40
28208: PPUSH
28209: LD_STRING D7-JMM-2
28211: PPUSH
28212: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-3 ) ;
28216: LD_EXP 66
28220: PPUSH
28221: LD_STRING D7-Friend-3
28223: PPUSH
28224: CALL 112032 0 2
// Say ( JMM , D7-JMM-3 ) ;
28228: LD_EXP 40
28232: PPUSH
28233: LD_STRING D7-JMM-3
28235: PPUSH
28236: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-4 ) ;
28240: LD_EXP 66
28244: PPUSH
28245: LD_STRING D7-Friend-4
28247: PPUSH
28248: CALL 112032 0 2
// Say ( JMM , D7-JMM-4 ) ;
28252: LD_EXP 40
28256: PPUSH
28257: LD_STRING D7-JMM-4
28259: PPUSH
28260: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-5 ) ;
28264: LD_EXP 66
28268: PPUSH
28269: LD_STRING D7-Friend-5
28271: PPUSH
28272: CALL 112032 0 2
// Say ( JMM , D7-JMM-5 ) ;
28276: LD_EXP 40
28280: PPUSH
28281: LD_STRING D7-JMM-5
28283: PPUSH
28284: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-6 ) ;
28288: LD_EXP 66
28292: PPUSH
28293: LD_STRING D7-Friend-6
28295: PPUSH
28296: CALL 112032 0 2
// Say ( JMM , D7-JMM-6 ) ;
28300: LD_EXP 40
28304: PPUSH
28305: LD_STRING D7-JMM-6
28307: PPUSH
28308: CALL_OW 88
// DialogueOff ;
28312: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
28316: LD_STRING Mlegion
28318: PPUSH
28319: CALL_OW 337
// skirmish := true ;
28323: LD_ADDR_EXP 100
28327: PUSH
28328: LD_INT 1
28330: ST_TO_ADDR
// RebuildKozlovFactory ;
28331: CALL 5380 0 0
// end ;
28335: PPOPN 14
28337: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
28338: LD_EXP 20
28342: PUSH
28343: LD_EXP 61
28347: PPUSH
28348: CALL_OW 300
28352: AND
28353: IFFALSE 28395
28355: GO 28357
28357: DISABLE
// begin enable ;
28358: ENABLE
// if IsInUnit ( Powell ) then
28359: LD_EXP 61
28363: PPUSH
28364: CALL_OW 310
28368: IFFALSE 28386
// CenterOnUnits ( IsInUnit ( Powell ) ) else
28370: LD_EXP 61
28374: PPUSH
28375: CALL_OW 310
28379: PPUSH
28380: CALL_OW 85
28384: GO 28395
// CenterOnUnits ( Powell ) ;
28386: LD_EXP 61
28390: PPUSH
28391: CALL_OW 85
// end ;
28395: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
28396: LD_INT 22
28398: PUSH
28399: LD_INT 8
28401: PUSH
28402: EMPTY
28403: LIST
28404: LIST
28405: PUSH
28406: LD_INT 34
28408: PUSH
28409: LD_INT 48
28411: PUSH
28412: EMPTY
28413: LIST
28414: LIST
28415: PUSH
28416: EMPTY
28417: LIST
28418: LIST
28419: PPUSH
28420: CALL_OW 69
28424: IFFALSE 28698
28426: GO 28428
28428: DISABLE
28429: LD_INT 0
28431: PPUSH
28432: PPUSH
// begin if missionStage < 9 then
28433: LD_EXP 15
28437: PUSH
28438: LD_INT 9
28440: LESS
28441: IFFALSE 28451
// missionStage := 9 ;
28443: LD_ADDR_EXP 15
28447: PUSH
28448: LD_INT 9
28450: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28451: LD_ADDR_VAR 0 1
28455: PUSH
28456: LD_INT 22
28458: PUSH
28459: LD_INT 8
28461: PUSH
28462: EMPTY
28463: LIST
28464: LIST
28465: PUSH
28466: LD_INT 34
28468: PUSH
28469: LD_INT 48
28471: PUSH
28472: EMPTY
28473: LIST
28474: LIST
28475: PUSH
28476: EMPTY
28477: LIST
28478: LIST
28479: PPUSH
28480: CALL_OW 69
28484: PUSH
28485: LD_INT 1
28487: ARRAY
28488: ST_TO_ADDR
// wait ( 0 0$05 ) ;
28489: LD_INT 175
28491: PPUSH
28492: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
28496: LD_EXP 12
28500: PUSH
28501: LD_EXP 3
28505: PUSH
28506: LD_INT 0
28508: PUSH
28509: LD_INT 2
28511: PUSH
28512: EMPTY
28513: LIST
28514: LIST
28515: IN
28516: OR
28517: IFFALSE 28540
// target := [ 68 , 108 , 1 ] else
28519: LD_ADDR_VAR 0 2
28523: PUSH
28524: LD_INT 68
28526: PUSH
28527: LD_INT 108
28529: PUSH
28530: LD_INT 1
28532: PUSH
28533: EMPTY
28534: LIST
28535: LIST
28536: LIST
28537: ST_TO_ADDR
28538: GO 28559
// target := [ 181 , 88 , 2 ] ;
28540: LD_ADDR_VAR 0 2
28544: PUSH
28545: LD_INT 181
28547: PUSH
28548: LD_INT 88
28550: PUSH
28551: LD_INT 2
28553: PUSH
28554: EMPTY
28555: LIST
28556: LIST
28557: LIST
28558: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
28559: LD_VAR 0 1
28563: PPUSH
28564: LD_VAR 0 2
28568: PUSH
28569: LD_INT 1
28571: ARRAY
28572: PPUSH
28573: LD_VAR 0 2
28577: PUSH
28578: LD_INT 2
28580: ARRAY
28581: PPUSH
28582: CALL_OW 176
// if target [ 3 ] = 1 then
28586: LD_VAR 0 2
28590: PUSH
28591: LD_INT 3
28593: ARRAY
28594: PUSH
28595: LD_INT 1
28597: EQUAL
28598: IFFALSE 28614
// SayRadio ( Kurt , D12-Kurt-1 ) else
28600: LD_EXP 64
28604: PPUSH
28605: LD_STRING D12-Kurt-1
28607: PPUSH
28608: CALL_OW 94
28612: GO 28638
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
28614: LD_EXP 64
28618: PPUSH
28619: LD_STRING D12a-Kurt-1
28621: PPUSH
28622: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
28626: LD_EXP 79
28630: PPUSH
28631: LD_STRING D12a-Roth-1
28633: PPUSH
28634: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
28638: LD_INT 350
28640: PPUSH
28641: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
28645: LD_VAR 0 1
28649: PPUSH
28650: LD_INT 22
28652: PUSH
28653: LD_INT 8
28655: PUSH
28656: EMPTY
28657: LIST
28658: LIST
28659: PUSH
28660: LD_INT 23
28662: PUSH
28663: LD_INT 2
28665: PUSH
28666: EMPTY
28667: LIST
28668: LIST
28669: PUSH
28670: LD_INT 30
28672: PUSH
28673: LD_INT 3
28675: PUSH
28676: EMPTY
28677: LIST
28678: LIST
28679: PUSH
28680: EMPTY
28681: LIST
28682: LIST
28683: LIST
28684: PPUSH
28685: CALL_OW 69
28689: PUSH
28690: LD_INT 1
28692: ARRAY
28693: PPUSH
28694: CALL_OW 228
// end ;
28698: PPOPN 2
28700: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
28701: LD_EXP 64
28705: PPUSH
28706: CALL_OW 256
28710: PUSH
28711: LD_INT 999
28713: LESS
28714: PUSH
28715: LD_INT 22
28717: PUSH
28718: LD_INT 8
28720: PUSH
28721: EMPTY
28722: LIST
28723: LIST
28724: PUSH
28725: LD_INT 21
28727: PUSH
28728: LD_INT 1
28730: PUSH
28731: EMPTY
28732: LIST
28733: LIST
28734: PUSH
28735: LD_INT 23
28737: PUSH
28738: LD_INT 2
28740: PUSH
28741: EMPTY
28742: LIST
28743: LIST
28744: PUSH
28745: EMPTY
28746: LIST
28747: LIST
28748: LIST
28749: PPUSH
28750: CALL_OW 69
28754: PUSH
28755: LD_INT 9
28757: PUSH
28758: LD_INT 8
28760: PUSH
28761: LD_INT 7
28763: PUSH
28764: LD_INT 6
28766: PUSH
28767: EMPTY
28768: LIST
28769: LIST
28770: LIST
28771: LIST
28772: PUSH
28773: LD_OWVAR 67
28777: ARRAY
28778: LESSEQUAL
28779: OR
28780: PUSH
28781: LD_INT 22
28783: PUSH
28784: LD_INT 8
28786: PUSH
28787: EMPTY
28788: LIST
28789: LIST
28790: PUSH
28791: LD_INT 34
28793: PUSH
28794: LD_INT 48
28796: PUSH
28797: EMPTY
28798: LIST
28799: LIST
28800: PUSH
28801: EMPTY
28802: LIST
28803: LIST
28804: PPUSH
28805: CALL_OW 69
28809: NOT
28810: AND
28811: PUSH
28812: LD_EXP 64
28816: PPUSH
28817: CALL_OW 302
28821: AND
28822: PUSH
28823: LD_INT 5
28825: PPUSH
28826: LD_INT 22
28828: PUSH
28829: LD_INT 1
28831: PUSH
28832: EMPTY
28833: LIST
28834: LIST
28835: PPUSH
28836: CALL_OW 70
28840: AND
28841: IFFALSE 29603
28843: GO 28845
28845: DISABLE
28846: LD_INT 0
28848: PPUSH
28849: PPUSH
28850: PPUSH
// begin legionDestroyed := true ;
28851: LD_ADDR_EXP 22
28855: PUSH
28856: LD_INT 1
28858: ST_TO_ADDR
// DialogueOn ;
28859: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
28863: LD_EXP 40
28867: PPUSH
28868: LD_STRING D13-JMM-1
28870: PPUSH
28871: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
28875: LD_EXP 64
28879: PPUSH
28880: LD_STRING D13-Kurt-1
28882: PPUSH
28883: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
28887: LD_EXP 40
28891: PPUSH
28892: LD_STRING D13-JMM-2
28894: PPUSH
28895: CALL_OW 88
// if FakeInfo then
28899: LD_EXP 12
28903: IFFALSE 28923
// begin Say ( Kurt , D13-Kurt-2 ) ;
28905: LD_EXP 64
28909: PPUSH
28910: LD_STRING D13-Kurt-2
28912: PPUSH
28913: CALL_OW 88
// DialogueOff ;
28917: CALL_OW 7
// exit ;
28921: GO 29603
// end ; if not KurtStatus then
28923: LD_EXP 3
28927: NOT
28928: IFFALSE 28944
// Say ( Kurt , D13-Kurt-2b ) else
28930: LD_EXP 64
28934: PPUSH
28935: LD_STRING D13-Kurt-2b
28937: PPUSH
28938: CALL_OW 88
28942: GO 28956
// Say ( Kurt , D13-Kurt-2a ) ;
28944: LD_EXP 64
28948: PPUSH
28949: LD_STRING D13-Kurt-2a
28951: PPUSH
28952: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
28956: LD_EXP 40
28960: PPUSH
28961: LD_STRING D13-JMM-3
28963: PPUSH
28964: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
28968: LD_EXP 64
28972: PPUSH
28973: LD_STRING D13-Kurt-3
28975: PPUSH
28976: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
28980: LD_EXP 40
28984: PPUSH
28985: LD_STRING D13-JMM-4
28987: PPUSH
28988: CALL_OW 88
// DialogueOff ;
28992: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
28996: LD_STRING MlegionOut
28998: PPUSH
28999: CALL_OW 337
// MC_Kill ( 3 ) ;
29003: LD_INT 3
29005: PPUSH
29006: CALL 39821 0 1
// KillUnit ( Kozlov ) ;
29010: LD_EXP 65
29014: PPUSH
29015: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
29019: LD_ADDR_VAR 0 1
29023: PUSH
29024: LD_INT 22
29026: PUSH
29027: LD_INT 8
29029: PUSH
29030: EMPTY
29031: LIST
29032: LIST
29033: PUSH
29034: LD_INT 23
29036: PUSH
29037: LD_INT 3
29039: PUSH
29040: EMPTY
29041: LIST
29042: LIST
29043: PUSH
29044: LD_INT 3
29046: PUSH
29047: LD_INT 21
29049: PUSH
29050: LD_INT 33
29052: PUSH
29053: EMPTY
29054: LIST
29055: LIST
29056: PUSH
29057: EMPTY
29058: LIST
29059: LIST
29060: PUSH
29061: EMPTY
29062: LIST
29063: LIST
29064: LIST
29065: PPUSH
29066: CALL_OW 69
29070: PUSH
29071: FOR_IN
29072: IFFALSE 29085
// KillUnit ( i ) ;
29074: LD_VAR 0 1
29078: PPUSH
29079: CALL_OW 66
29083: GO 29071
29085: POP
29086: POP
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
29087: LD_ADDR_VAR 0 1
29091: PUSH
29092: LD_INT 22
29094: PUSH
29095: LD_INT 8
29097: PUSH
29098: EMPTY
29099: LIST
29100: LIST
29101: PUSH
29102: LD_INT 21
29104: PUSH
29105: LD_INT 2
29107: PUSH
29108: EMPTY
29109: LIST
29110: LIST
29111: PUSH
29112: EMPTY
29113: LIST
29114: LIST
29115: PPUSH
29116: CALL_OW 69
29120: PUSH
29121: FOR_IN
29122: IFFALSE 29135
// KillUnit ( i ) ;
29124: LD_VAR 0 1
29128: PPUSH
29129: CALL_OW 66
29133: GO 29121
29135: POP
29136: POP
// wait ( 0 0$0.6 ) ;
29137: LD_INT 21
29139: PPUSH
29140: CALL_OW 67
// ChangeSideFog ( 8 , 1 ) ;
29144: LD_INT 8
29146: PPUSH
29147: LD_INT 1
29149: PPUSH
29150: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
29154: LD_ADDR_VAR 0 2
29158: PUSH
29159: LD_INT 22
29161: PUSH
29162: LD_INT 8
29164: PUSH
29165: EMPTY
29166: LIST
29167: LIST
29168: PUSH
29169: LD_INT 21
29171: PUSH
29172: LD_INT 1
29174: PUSH
29175: EMPTY
29176: LIST
29177: LIST
29178: PUSH
29179: EMPTY
29180: LIST
29181: LIST
29182: PPUSH
29183: CALL_OW 69
29187: PUSH
29188: LD_EXP 65
29192: PUSH
29193: LD_EXP 64
29197: PUSH
29198: EMPTY
29199: LIST
29200: LIST
29201: DIFF
29202: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
29203: LD_VAR 0 2
29207: PUSH
29208: LD_INT 6
29210: PUSH
29211: LD_INT 5
29213: PUSH
29214: LD_INT 4
29216: PUSH
29217: LD_INT 3
29219: PUSH
29220: EMPTY
29221: LIST
29222: LIST
29223: LIST
29224: LIST
29225: PUSH
29226: LD_OWVAR 67
29230: ARRAY
29231: GREATEREQUAL
29232: IFFALSE 29384
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
29234: LD_ADDR_VAR 0 3
29238: PUSH
29239: LD_INT 6
29241: PUSH
29242: LD_INT 5
29244: PUSH
29245: LD_INT 4
29247: PUSH
29248: LD_INT 3
29250: PUSH
29251: EMPTY
29252: LIST
29253: LIST
29254: LIST
29255: LIST
29256: PUSH
29257: LD_OWVAR 67
29261: ARRAY
29262: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
29263: LD_ADDR_VAR 0 1
29267: PUSH
29268: DOUBLE
29269: LD_VAR 0 2
29273: PUSH
29274: LD_VAR 0 3
29278: PUSH
29279: LD_INT 1
29281: PLUS
29282: MINUS
29283: INC
29284: ST_TO_ADDR
29285: LD_INT 1
29287: PUSH
29288: FOR_DOWNTO
29289: IFFALSE 29380
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
29291: LD_ADDR_EXP 38
29295: PUSH
29296: LD_EXP 38
29300: PUSH
29301: LD_VAR 0 2
29305: PUSH
29306: LD_VAR 0 1
29310: ARRAY
29311: ADD
29312: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
29313: LD_VAR 0 2
29317: PUSH
29318: LD_VAR 0 1
29322: ARRAY
29323: PPUSH
29324: CALL_OW 310
29328: IFFALSE 29345
// ComExit ( tmp [ i ] ) ;
29330: LD_VAR 0 2
29334: PUSH
29335: LD_VAR 0 1
29339: ARRAY
29340: PPUSH
29341: CALL 108361 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
29345: LD_VAR 0 2
29349: PUSH
29350: LD_VAR 0 1
29354: ARRAY
29355: PPUSH
29356: LD_INT 34
29358: PUSH
29359: LD_INT 0
29361: PPUSH
29362: LD_INT 6
29364: PPUSH
29365: CALL_OW 12
29369: PLUS
29370: PPUSH
29371: LD_INT 1
29373: PPUSH
29374: CALL_OW 171
// end ;
29378: GO 29288
29380: POP
29381: POP
// end else
29382: GO 29394
// x := tmp ;
29384: LD_ADDR_VAR 0 3
29388: PUSH
29389: LD_VAR 0 2
29393: ST_TO_ADDR
// for i := tmp downto tmp - x do
29394: LD_ADDR_VAR 0 1
29398: PUSH
29399: DOUBLE
29400: LD_VAR 0 2
29404: INC
29405: ST_TO_ADDR
29406: LD_VAR 0 2
29410: PUSH
29411: LD_VAR 0 3
29415: MINUS
29416: PUSH
29417: FOR_DOWNTO
29418: IFFALSE 29490
// begin if IsInUnit ( tmp [ i ] ) then
29420: LD_VAR 0 2
29424: PUSH
29425: LD_VAR 0 1
29429: ARRAY
29430: PPUSH
29431: CALL_OW 310
29435: IFFALSE 29452
// ComExit ( tmp [ i ] ) ;
29437: LD_VAR 0 2
29441: PUSH
29442: LD_VAR 0 1
29446: ARRAY
29447: PPUSH
29448: CALL 108361 0 1
// SetSide ( tmp [ i ] , 1 ) ;
29452: LD_VAR 0 2
29456: PUSH
29457: LD_VAR 0 1
29461: ARRAY
29462: PPUSH
29463: LD_INT 1
29465: PPUSH
29466: CALL_OW 235
// SetLives ( tmp [ i ] , 1000 ) ;
29470: LD_VAR 0 2
29474: PUSH
29475: LD_VAR 0 1
29479: ARRAY
29480: PPUSH
29481: LD_INT 1000
29483: PPUSH
29484: CALL_OW 234
// end ;
29488: GO 29417
29490: POP
29491: POP
// SetSide ( Kurt , 1 ) ;
29492: LD_EXP 64
29496: PPUSH
29497: LD_INT 1
29499: PPUSH
29500: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
29504: LD_INT 22
29506: PUSH
29507: LD_INT 8
29509: PUSH
29510: EMPTY
29511: LIST
29512: LIST
29513: PUSH
29514: LD_INT 21
29516: PUSH
29517: LD_INT 3
29519: PUSH
29520: EMPTY
29521: LIST
29522: LIST
29523: PUSH
29524: EMPTY
29525: LIST
29526: LIST
29527: PPUSH
29528: CALL_OW 69
29532: PPUSH
29533: LD_INT 1
29535: PPUSH
29536: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
29540: LD_INT 8
29542: PPUSH
29543: LD_INT 1
29545: PPUSH
29546: LD_INT 1
29548: PPUSH
29549: LD_INT 1
29551: PPUSH
29552: CALL_OW 80
// wait ( 1 1$20 ) ;
29556: LD_INT 2800
29558: PPUSH
29559: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
29563: LD_EXP 66
29567: PPUSH
29568: LD_INT 37
29570: PPUSH
29571: LD_INT 1
29573: PPUSH
29574: LD_INT 0
29576: PPUSH
29577: CALL_OW 48
// wait ( 0 0$1 ) ;
29581: LD_INT 35
29583: PPUSH
29584: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
29588: LD_EXP 66
29592: PPUSH
29593: LD_INT 60
29595: PPUSH
29596: LD_INT 95
29598: PPUSH
29599: CALL_OW 111
// end ;
29603: PPOPN 3
29605: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
29606: LD_EXP 22
29610: NOT
29611: PUSH
29612: LD_INT 22
29614: PUSH
29615: LD_INT 8
29617: PUSH
29618: EMPTY
29619: LIST
29620: LIST
29621: PUSH
29622: LD_INT 21
29624: PUSH
29625: LD_INT 1
29627: PUSH
29628: EMPTY
29629: LIST
29630: LIST
29631: PUSH
29632: EMPTY
29633: LIST
29634: LIST
29635: PPUSH
29636: CALL_OW 69
29640: PUSH
29641: LD_INT 0
29643: EQUAL
29644: AND
29645: IFFALSE 29665
29647: GO 29649
29649: DISABLE
// begin legionDestroyed := true ;
29650: LD_ADDR_EXP 22
29654: PUSH
29655: LD_INT 1
29657: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
29658: LD_STRING MlegionOut
29660: PPUSH
29661: CALL_OW 337
// end ;
29665: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
29666: LD_EXP 38
29670: IFFALSE 29745
29672: GO 29674
29674: DISABLE
29675: LD_INT 0
29677: PPUSH
// begin enable ;
29678: ENABLE
// for i in legionEscapeUnits do
29679: LD_ADDR_VAR 0 1
29683: PUSH
29684: LD_EXP 38
29688: PUSH
29689: FOR_IN
29690: IFFALSE 29743
// begin if IsInArea ( i , legionEscapeArea ) then
29692: LD_VAR 0 1
29696: PPUSH
29697: LD_INT 31
29699: PPUSH
29700: CALL_OW 308
29704: IFFALSE 29717
// RemoveUnit ( i ) else
29706: LD_VAR 0 1
29710: PPUSH
29711: CALL_OW 64
29715: GO 29741
// if not HasTask ( i ) then
29717: LD_VAR 0 1
29721: PPUSH
29722: CALL_OW 314
29726: NOT
29727: IFFALSE 29741
// ComMoveToArea ( i , legionEscapeArea ) ;
29729: LD_VAR 0 1
29733: PPUSH
29734: LD_INT 31
29736: PPUSH
29737: CALL_OW 113
// end ;
29741: GO 29689
29743: POP
29744: POP
// end ;
29745: PPOPN 1
29747: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
29748: LD_INT 1
29750: PPUSH
29751: LD_EXP 66
29755: PPUSH
29756: CALL_OW 292
29760: IFFALSE 30058
29762: GO 29764
29764: DISABLE
29765: LD_INT 0
29767: PPUSH
// begin wait ( 0 0$2 ) ;
29768: LD_INT 70
29770: PPUSH
29771: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
29775: LD_EXP 66
29779: PPUSH
29780: CALL_OW 87
// DialogueOn ;
29784: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
29788: LD_EXP 40
29792: PPUSH
29793: LD_STRING D14-JMM-1
29795: PPUSH
29796: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
29800: LD_EXP 66
29804: PPUSH
29805: LD_STRING D14-Friend-1
29807: PPUSH
29808: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
29812: LD_EXP 40
29816: PPUSH
29817: LD_STRING D14-JMM-2
29819: PPUSH
29820: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
29824: LD_EXP 66
29828: PPUSH
29829: LD_STRING D14-Friend-2
29831: PPUSH
29832: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
29836: LD_EXP 40
29840: PPUSH
29841: LD_STRING D14-JMM-3
29843: PPUSH
29844: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
29848: LD_EXP 66
29852: PPUSH
29853: LD_STRING D14-Friend-3
29855: PPUSH
29856: CALL_OW 88
// DialogueOff ;
29860: CALL_OW 7
// dec := Query ( Q14 ) ;
29864: LD_ADDR_VAR 0 1
29868: PUSH
29869: LD_STRING Q14
29871: PPUSH
29872: CALL_OW 97
29876: ST_TO_ADDR
// if dec = 1 then
29877: LD_VAR 0 1
29881: PUSH
29882: LD_INT 1
29884: EQUAL
29885: IFFALSE 29919
// begin DialogueOn ;
29887: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
29891: LD_EXP 40
29895: PPUSH
29896: LD_STRING D14a-JMM-1
29898: PPUSH
29899: CALL_OW 88
// DialogueOff ;
29903: CALL_OW 7
// SetSide ( Friend , 1 ) ;
29907: LD_EXP 66
29911: PPUSH
29912: LD_INT 1
29914: PPUSH
29915: CALL_OW 235
// end ; if dec = 2 then
29919: LD_VAR 0 1
29923: PUSH
29924: LD_INT 2
29926: EQUAL
29927: IFFALSE 29980
// begin DialogueOn ;
29929: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
29933: LD_EXP 40
29937: PPUSH
29938: LD_STRING D14b-JMM-1
29940: PPUSH
29941: CALL_OW 88
// DialogueOff ;
29945: CALL_OW 7
// wait ( 0 0$1 ) ;
29949: LD_INT 35
29951: PPUSH
29952: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
29956: LD_EXP 66
29960: PPUSH
29961: LD_INT 9
29963: PPUSH
29964: LD_INT 2
29966: PPUSH
29967: CALL_OW 111
// AddComHold ( Friend ) ;
29971: LD_EXP 66
29975: PPUSH
29976: CALL_OW 200
// end ; if dec = 3 then
29980: LD_VAR 0 1
29984: PUSH
29985: LD_INT 3
29987: EQUAL
29988: IFFALSE 30058
// begin DialogueOn ;
29990: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
29994: LD_EXP 40
29998: PPUSH
29999: LD_STRING D14c-JMM-1
30001: PPUSH
30002: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
30006: LD_EXP 66
30010: PPUSH
30011: LD_STRING D14c-Friend-1
30013: PPUSH
30014: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
30018: LD_EXP 40
30022: PPUSH
30023: LD_STRING D14c-JMM-2
30025: PPUSH
30026: CALL_OW 88
// DialogueOff ;
30030: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
30034: LD_EXP 66
30038: PPUSH
30039: LD_INT 9
30041: PPUSH
30042: LD_INT 2
30044: PPUSH
30045: CALL_OW 111
// AddComHold ( Friend ) ;
30049: LD_EXP 66
30053: PPUSH
30054: CALL_OW 200
// end ; end ;
30058: PPOPN 1
30060: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
30061: LD_INT 9
30063: PPUSH
30064: LD_INT 2
30066: PPUSH
30067: CALL_OW 428
30071: PUSH
30072: LD_EXP 66
30076: EQUAL
30077: PUSH
30078: LD_EXP 66
30082: PPUSH
30083: CALL_OW 255
30087: PUSH
30088: LD_INT 8
30090: EQUAL
30091: AND
30092: IFFALSE 30106
30094: GO 30096
30096: DISABLE
// RemoveUnit ( Friend ) ;
30097: LD_EXP 66
30101: PPUSH
30102: CALL_OW 64
30106: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
30107: LD_EXP 14
30111: PUSH
30112: LD_INT 31500
30114: GREATEREQUAL
30115: PUSH
30116: LD_EXP 7
30120: AND
30121: PUSH
30122: LD_EXP 2
30126: AND
30127: IFFALSE 30573
30129: GO 30131
30131: DISABLE
30132: LD_INT 0
30134: PPUSH
30135: PPUSH
30136: PPUSH
// begin missionStage := 7 ;
30137: LD_ADDR_EXP 15
30141: PUSH
30142: LD_INT 7
30144: ST_TO_ADDR
// for i := 1 to 5 do
30145: LD_ADDR_VAR 0 1
30149: PUSH
30150: DOUBLE
30151: LD_INT 1
30153: DEC
30154: ST_TO_ADDR
30155: LD_INT 5
30157: PUSH
30158: FOR_TO
30159: IFFALSE 30271
// begin uc_side = 1 ;
30161: LD_ADDR_OWVAR 20
30165: PUSH
30166: LD_INT 1
30168: ST_TO_ADDR
// uc_nation = 1 ;
30169: LD_ADDR_OWVAR 21
30173: PUSH
30174: LD_INT 1
30176: ST_TO_ADDR
// vc_engine = engine_siberite ;
30177: LD_ADDR_OWVAR 39
30181: PUSH
30182: LD_INT 3
30184: ST_TO_ADDR
// vc_control = control_computer ;
30185: LD_ADDR_OWVAR 38
30189: PUSH
30190: LD_INT 3
30192: ST_TO_ADDR
// vc_chassis = us_medium_tracked ;
30193: LD_ADDR_OWVAR 37
30197: PUSH
30198: LD_INT 3
30200: ST_TO_ADDR
// vc_weapon = [ us_double_gun , us_laser , us_rocket_launcher ] [ Rand ( 1 , 3 ) ] ;
30201: LD_ADDR_OWVAR 40
30205: PUSH
30206: LD_INT 5
30208: PUSH
30209: LD_INT 9
30211: PUSH
30212: LD_INT 7
30214: PUSH
30215: EMPTY
30216: LIST
30217: LIST
30218: LIST
30219: PUSH
30220: LD_INT 1
30222: PPUSH
30223: LD_INT 3
30225: PPUSH
30226: CALL_OW 12
30230: ARRAY
30231: ST_TO_ADDR
// veh = CreateVehicle ;
30232: LD_ADDR_VAR 0 2
30236: PUSH
30237: CALL_OW 45
30241: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
30242: LD_VAR 0 2
30246: PPUSH
30247: LD_INT 1
30249: PPUSH
30250: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
30254: LD_VAR 0 2
30258: PPUSH
30259: LD_INT 19
30261: PPUSH
30262: LD_INT 0
30264: PPUSH
30265: CALL_OW 49
// end ;
30269: GO 30158
30271: POP
30272: POP
// uc_side = 1 ;
30273: LD_ADDR_OWVAR 20
30277: PUSH
30278: LD_INT 1
30280: ST_TO_ADDR
// uc_nation = 1 ;
30281: LD_ADDR_OWVAR 21
30285: PUSH
30286: LD_INT 1
30288: ST_TO_ADDR
// vc_engine = 3 ;
30289: LD_ADDR_OWVAR 39
30293: PUSH
30294: LD_INT 3
30296: ST_TO_ADDR
// vc_control = 1 ;
30297: LD_ADDR_OWVAR 38
30301: PUSH
30302: LD_INT 1
30304: ST_TO_ADDR
// vc_chassis = 3 ;
30305: LD_ADDR_OWVAR 37
30309: PUSH
30310: LD_INT 3
30312: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
30313: LD_ADDR_OWVAR 40
30317: PUSH
30318: LD_INT 5
30320: PUSH
30321: LD_INT 9
30323: PUSH
30324: LD_INT 7
30326: PUSH
30327: EMPTY
30328: LIST
30329: LIST
30330: LIST
30331: PUSH
30332: LD_INT 1
30334: PPUSH
30335: LD_INT 3
30337: PPUSH
30338: CALL_OW 12
30342: ARRAY
30343: ST_TO_ADDR
// vehG = CreateVehicle ;
30344: LD_ADDR_VAR 0 3
30348: PUSH
30349: CALL_OW 45
30353: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
30354: LD_VAR 0 3
30358: PPUSH
30359: LD_INT 1
30361: PPUSH
30362: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
30366: LD_VAR 0 3
30370: PPUSH
30371: LD_INT 19
30373: PPUSH
30374: LD_INT 0
30376: PPUSH
30377: CALL_OW 49
// if JMMGirl = 1 then
30381: LD_EXP 7
30385: PUSH
30386: LD_INT 1
30388: EQUAL
30389: IFFALSE 30445
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
30391: LD_ADDR_EXP 41
30395: PUSH
30396: LD_STRING Joan
30398: PPUSH
30399: LD_INT 1
30401: PPUSH
30402: LD_STRING 14_
30404: PPUSH
30405: CALL 70272 0 3
30409: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
30410: LD_EXP 41
30414: PPUSH
30415: LD_VAR 0 3
30419: PPUSH
30420: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30424: LD_VAR 0 3
30428: PPUSH
30429: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
30433: LD_EXP 41
30437: PPUSH
30438: LD_STRING D10BW-Joan-1
30440: PPUSH
30441: CALL_OW 94
// end ; if JMMGirl = 2 then
30445: LD_EXP 7
30449: PUSH
30450: LD_INT 2
30452: EQUAL
30453: IFFALSE 30509
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
30455: LD_ADDR_EXP 43
30459: PUSH
30460: LD_STRING Lisa
30462: PPUSH
30463: LD_INT 1
30465: PPUSH
30466: LD_STRING 14_
30468: PPUSH
30469: CALL 70272 0 3
30473: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
30474: LD_EXP 43
30478: PPUSH
30479: LD_VAR 0 3
30483: PPUSH
30484: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30488: LD_VAR 0 3
30492: PPUSH
30493: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
30497: LD_EXP 43
30501: PPUSH
30502: LD_STRING D10BW-Lisa-1
30504: PPUSH
30505: CALL_OW 94
// end ; if JMMGirl = 3 then
30509: LD_EXP 7
30513: PUSH
30514: LD_INT 3
30516: EQUAL
30517: IFFALSE 30573
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
30519: LD_ADDR_EXP 55
30523: PUSH
30524: LD_STRING Connie
30526: PPUSH
30527: LD_INT 1
30529: PPUSH
30530: LD_STRING 14_
30532: PPUSH
30533: CALL 70272 0 3
30537: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
30538: LD_EXP 55
30542: PPUSH
30543: LD_VAR 0 3
30547: PPUSH
30548: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30552: LD_VAR 0 3
30556: PPUSH
30557: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
30561: LD_EXP 55
30565: PPUSH
30566: LD_STRING D10BW-Con-1
30568: PPUSH
30569: CALL_OW 94
// end ; end ;
30573: PPOPN 3
30575: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
30576: LD_EXP 14
30580: PUSH
30581: LD_INT 94500
30583: GREATEREQUAL
30584: IFFALSE 30996
30586: GO 30588
30588: DISABLE
30589: LD_INT 0
30591: PPUSH
30592: PPUSH
30593: PPUSH
// begin tmp := PrepareStevensSquad ;
30594: LD_ADDR_VAR 0 3
30598: PUSH
30599: CALL 2378 0 0
30603: ST_TO_ADDR
// if not tmp then
30604: LD_VAR 0 3
30608: NOT
30609: IFFALSE 30613
// exit ;
30611: GO 30996
// uc_side := 1 ;
30613: LD_ADDR_OWVAR 20
30617: PUSH
30618: LD_INT 1
30620: ST_TO_ADDR
// uc_nation := 1 ;
30621: LD_ADDR_OWVAR 21
30625: PUSH
30626: LD_INT 1
30628: ST_TO_ADDR
// for i in tmp do
30629: LD_ADDR_VAR 0 1
30633: PUSH
30634: LD_VAR 0 3
30638: PUSH
30639: FOR_IN
30640: IFFALSE 30737
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
30642: LD_INT 3
30644: PPUSH
30645: LD_INT 3
30647: PPUSH
30648: LD_INT 1
30650: PPUSH
30651: LD_INT 5
30653: PUSH
30654: LD_INT 9
30656: PUSH
30657: LD_INT 7
30659: PUSH
30660: EMPTY
30661: LIST
30662: LIST
30663: LIST
30664: PUSH
30665: LD_INT 1
30667: PPUSH
30668: LD_INT 3
30670: PPUSH
30671: CALL_OW 12
30675: ARRAY
30676: PPUSH
30677: LD_INT 40
30679: PPUSH
30680: CALL 75112 0 5
// veh := CreateVehicle ;
30684: LD_ADDR_VAR 0 2
30688: PUSH
30689: CALL_OW 45
30693: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
30694: LD_VAR 0 2
30698: PPUSH
30699: LD_INT 1
30701: PPUSH
30702: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
30706: LD_VAR 0 2
30710: PPUSH
30711: LD_INT 19
30713: PPUSH
30714: LD_INT 0
30716: PPUSH
30717: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
30721: LD_VAR 0 1
30725: PPUSH
30726: LD_VAR 0 2
30730: PPUSH
30731: CALL_OW 52
// end ;
30735: GO 30639
30737: POP
30738: POP
// missionStage := 8 ;
30739: LD_ADDR_EXP 15
30743: PUSH
30744: LD_INT 8
30746: ST_TO_ADDR
// DialogueOn ;
30747: CALL_OW 6
// if Stevens then
30751: LD_EXP 42
30755: IFFALSE 30869
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
30757: LD_EXP 42
30761: PPUSH
30762: CALL_OW 310
30766: PPUSH
30767: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
30771: LD_EXP 42
30775: PPUSH
30776: LD_STRING D8-Huck-1
30778: PPUSH
30779: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
30783: LD_EXP 40
30787: PPUSH
30788: LD_STRING D8-JMM-1
30790: PPUSH
30791: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
30795: LD_EXP 42
30799: PPUSH
30800: LD_STRING D8-Huck-2
30802: PPUSH
30803: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
30807: LD_EXP 40
30811: PPUSH
30812: LD_STRING D8-JMM-2
30814: PPUSH
30815: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
30819: LD_EXP 42
30823: PPUSH
30824: LD_STRING D8-Huck-3
30826: PPUSH
30827: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
30831: LD_EXP 40
30835: PPUSH
30836: LD_STRING D8-JMM-3
30838: PPUSH
30839: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
30843: LD_EXP 42
30847: PPUSH
30848: LD_STRING D8-Huck-4
30850: PPUSH
30851: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
30855: LD_EXP 40
30859: PPUSH
30860: LD_STRING D8-JMM-4
30862: PPUSH
30863: CALL_OW 88
// end else
30867: GO 30979
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
30869: LD_EXP 56
30873: PPUSH
30874: CALL_OW 310
30878: PPUSH
30879: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
30883: LD_EXP 56
30887: PPUSH
30888: LD_STRING D8-Huck-1
30890: PPUSH
30891: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
30895: LD_EXP 40
30899: PPUSH
30900: LD_STRING D8-JMM-1a
30902: PPUSH
30903: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
30907: LD_EXP 56
30911: PPUSH
30912: LD_STRING D8-Huck-2
30914: PPUSH
30915: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
30919: LD_EXP 40
30923: PPUSH
30924: LD_STRING D8-JMM-2
30926: PPUSH
30927: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
30931: LD_EXP 56
30935: PPUSH
30936: LD_STRING D8-Huck-3
30938: PPUSH
30939: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
30943: LD_EXP 40
30947: PPUSH
30948: LD_STRING D8-JMM-3
30950: PPUSH
30951: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
30955: LD_EXP 56
30959: PPUSH
30960: LD_STRING D8-Huck-4
30962: PPUSH
30963: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
30967: LD_EXP 40
30971: PPUSH
30972: LD_STRING D8-JMM-4
30974: PPUSH
30975: CALL_OW 88
// end ; DialogueOff ;
30979: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
30983: LD_INT 25
30985: PPUSH
30986: LD_INT 1
30988: PPUSH
30989: LD_INT 1
30991: PPUSH
30992: CALL_OW 322
// end ;
30996: PPOPN 3
30998: END
// every 0 0$1 trigger IsOk ( sewiVeh ) and See ( 1 , sewiVeh ) do
30999: LD_EXP 75
31003: PPUSH
31004: CALL_OW 302
31008: PUSH
31009: LD_INT 1
31011: PPUSH
31012: LD_EXP 75
31016: PPUSH
31017: CALL_OW 292
31021: AND
31022: IFFALSE 31273
31024: GO 31026
31026: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
31027: LD_EXP 75
31031: PPUSH
31032: CALL_OW 87
// DialogueOn ;
31036: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
31040: LD_EXP 40
31044: PPUSH
31045: LD_STRING D10nB-JMM-1
31047: PPUSH
31048: CALL_OW 88
// if BurlakStatus = 1 then
31052: LD_EXP 9
31056: PUSH
31057: LD_INT 1
31059: EQUAL
31060: IFFALSE 31074
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
31062: LD_EXP 74
31066: PPUSH
31067: LD_STRING D10nB-Vse-1a
31069: PPUSH
31070: CALL_OW 94
// end ; if BurlakStatus = 0 then
31074: LD_EXP 9
31078: PUSH
31079: LD_INT 0
31081: EQUAL
31082: IFFALSE 31096
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
31084: LD_EXP 74
31088: PPUSH
31089: LD_STRING D10nB-Vse-1
31091: PPUSH
31092: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
31096: LD_EXP 40
31100: PPUSH
31101: LD_STRING D10nB-JMM-2
31103: PPUSH
31104: CALL_OW 88
// if KappaStatus then
31108: LD_EXP 2
31112: IFFALSE 31126
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
31114: LD_EXP 74
31118: PPUSH
31119: LD_STRING D10nB-Vse-5a
31121: PPUSH
31122: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
31126: LD_EXP 2
31130: NOT
31131: PUSH
31132: LD_EXP 6
31136: PUSH
31137: LD_INT 0
31139: EQUAL
31140: AND
31141: IFFALSE 31269
// begin if JMMGirl = 1 then
31143: LD_EXP 7
31147: PUSH
31148: LD_INT 1
31150: EQUAL
31151: IFFALSE 31201
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
31153: LD_EXP 74
31157: PPUSH
31158: LD_STRING D10nB-Vse-2
31160: PPUSH
31161: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
31165: LD_EXP 40
31169: PPUSH
31170: LD_STRING D10nB-JMM-3
31172: PPUSH
31173: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
31177: LD_EXP 74
31181: PPUSH
31182: LD_STRING D10nB-Vse-3
31184: PPUSH
31185: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
31189: LD_EXP 40
31193: PPUSH
31194: LD_STRING D10nB-JMM-4
31196: PPUSH
31197: CALL_OW 88
// end ; if JMMGirl = 2 then
31201: LD_EXP 7
31205: PUSH
31206: LD_INT 2
31208: EQUAL
31209: IFFALSE 31235
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
31211: LD_EXP 74
31215: PPUSH
31216: LD_STRING D10nB-Vse-4
31218: PPUSH
31219: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
31223: LD_EXP 40
31227: PPUSH
31228: LD_STRING D10nB-JMM-5
31230: PPUSH
31231: CALL_OW 88
// end ; if JMMGirl = 3 then
31235: LD_EXP 7
31239: PUSH
31240: LD_INT 3
31242: EQUAL
31243: IFFALSE 31269
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
31245: LD_EXP 74
31249: PPUSH
31250: LD_STRING D10nB-Vse-5
31252: PPUSH
31253: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
31257: LD_EXP 40
31261: PPUSH
31262: LD_STRING D10nB-JMM-6
31264: PPUSH
31265: CALL_OW 88
// end ; end ; DialogueOff ;
31269: CALL_OW 7
// end ;
31273: END
// every 0 0$1 trigger missionTime >= 55 55$00 and IsOk ( Kovalyuk ) and IsOk ( ru_depot2 ) do var i , j , tmp ;
31274: LD_EXP 14
31278: PUSH
31279: LD_INT 115500
31281: GREATEREQUAL
31282: PUSH
31283: LD_EXP 69
31287: PPUSH
31288: CALL_OW 302
31292: AND
31293: PUSH
31294: LD_INT 267
31296: PPUSH
31297: CALL_OW 302
31301: AND
31302: IFFALSE 31816
31304: GO 31306
31306: DISABLE
31307: LD_INT 0
31309: PPUSH
31310: PPUSH
31311: PPUSH
// begin missionStage := 10 ;
31312: LD_ADDR_EXP 15
31316: PUSH
31317: LD_INT 10
31319: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
31320: LD_ADDR_VAR 0 3
31324: PUSH
31325: LD_INT 22
31327: PUSH
31328: LD_INT 1
31330: PUSH
31331: EMPTY
31332: LIST
31333: LIST
31334: PUSH
31335: LD_INT 23
31337: PUSH
31338: LD_INT 1
31340: PUSH
31341: EMPTY
31342: LIST
31343: LIST
31344: PUSH
31345: LD_INT 26
31347: PUSH
31348: LD_INT 1
31350: PUSH
31351: EMPTY
31352: LIST
31353: LIST
31354: PUSH
31355: LD_INT 3
31357: PUSH
31358: LD_INT 25
31360: PUSH
31361: LD_INT 12
31363: PUSH
31364: EMPTY
31365: LIST
31366: LIST
31367: PUSH
31368: EMPTY
31369: LIST
31370: LIST
31371: PUSH
31372: LD_INT 3
31374: PUSH
31375: LD_INT 25
31377: PUSH
31378: LD_INT 16
31380: PUSH
31381: EMPTY
31382: LIST
31383: LIST
31384: PUSH
31385: EMPTY
31386: LIST
31387: LIST
31388: PUSH
31389: EMPTY
31390: LIST
31391: LIST
31392: LIST
31393: LIST
31394: LIST
31395: PPUSH
31396: CALL_OW 69
31400: PUSH
31401: LD_EXP 40
31405: PUSH
31406: LD_EXP 64
31410: PUSH
31411: LD_EXP 42
31415: PUSH
31416: LD_EXP 56
31420: PUSH
31421: LD_EXP 43
31425: PUSH
31426: LD_EXP 44
31430: PUSH
31431: LD_EXP 45
31435: PUSH
31436: LD_EXP 46
31440: PUSH
31441: LD_EXP 47
31445: PUSH
31446: LD_EXP 48
31450: PUSH
31451: LD_EXP 49
31455: PUSH
31456: LD_EXP 50
31460: PUSH
31461: LD_EXP 51
31465: PUSH
31466: LD_EXP 52
31470: PUSH
31471: LD_EXP 53
31475: PUSH
31476: LD_EXP 54
31480: PUSH
31481: EMPTY
31482: LIST
31483: LIST
31484: LIST
31485: LIST
31486: LIST
31487: LIST
31488: LIST
31489: LIST
31490: LIST
31491: LIST
31492: LIST
31493: LIST
31494: LIST
31495: LIST
31496: LIST
31497: LIST
31498: DIFF
31499: ST_TO_ADDR
// if not tmp and Brown then
31500: LD_VAR 0 3
31504: NOT
31505: PUSH
31506: LD_EXP 48
31510: AND
31511: IFFALSE 31526
// tmp := [ Brown ] ;
31513: LD_ADDR_VAR 0 3
31517: PUSH
31518: LD_EXP 48
31522: PUSH
31523: EMPTY
31524: LIST
31525: ST_TO_ADDR
// DialogueOn ;
31526: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
31530: LD_VAR 0 3
31534: PUSH
31535: LD_INT 1
31537: ARRAY
31538: PPUSH
31539: LD_STRING D11-Sol1-1
31541: PPUSH
31542: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
31546: LD_EXP 68
31550: PPUSH
31551: LD_STRING D11-Pla-1
31553: PPUSH
31554: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
31558: LD_EXP 69
31562: PPUSH
31563: LD_STRING D11-Kov-1
31565: PPUSH
31566: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
31570: LD_EXP 68
31574: PPUSH
31575: LD_STRING D11-Pla-2
31577: PPUSH
31578: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
31582: LD_VAR 0 3
31586: PUSH
31587: LD_INT 1
31589: ARRAY
31590: PPUSH
31591: LD_STRING D11-Sol1-2
31593: PPUSH
31594: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
31598: LD_EXP 40
31602: PPUSH
31603: LD_STRING D11-JMM-2
31605: PPUSH
31606: CALL_OW 88
// DialogueOff ;
31610: CALL_OW 7
// allowBehemothConstruct := true ;
31614: LD_ADDR_EXP 25
31618: PUSH
31619: LD_INT 1
31621: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
31622: LD_STRING M4
31624: PPUSH
31625: CALL_OW 337
// j := 3 ;
31629: LD_ADDR_VAR 0 2
31633: PUSH
31634: LD_INT 3
31636: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_not , [ f_tag , 105 ] ] , [ f_class , 3 ] ] ) diff Kovalyuk ;
31637: LD_ADDR_VAR 0 3
31641: PUSH
31642: LD_INT 22
31644: PUSH
31645: LD_INT 3
31647: PUSH
31648: EMPTY
31649: LIST
31650: LIST
31651: PUSH
31652: LD_INT 50
31654: PUSH
31655: EMPTY
31656: LIST
31657: PUSH
31658: LD_INT 3
31660: PUSH
31661: LD_INT 120
31663: PUSH
31664: LD_INT 105
31666: PUSH
31667: EMPTY
31668: LIST
31669: LIST
31670: PUSH
31671: EMPTY
31672: LIST
31673: LIST
31674: PUSH
31675: LD_INT 25
31677: PUSH
31678: LD_INT 3
31680: PUSH
31681: EMPTY
31682: LIST
31683: LIST
31684: PUSH
31685: EMPTY
31686: LIST
31687: LIST
31688: LIST
31689: LIST
31690: PPUSH
31691: CALL_OW 69
31695: PUSH
31696: LD_EXP 69
31700: DIFF
31701: ST_TO_ADDR
// for i in tmp do
31702: LD_ADDR_VAR 0 1
31706: PUSH
31707: LD_VAR 0 3
31711: PUSH
31712: FOR_IN
31713: IFFALSE 31763
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
31715: LD_ADDR_EXP 77
31719: PUSH
31720: LD_EXP 77
31724: PPUSH
31725: LD_VAR 0 1
31729: PPUSH
31730: CALL 107963 0 2
31734: ST_TO_ADDR
// j := j - 1 ;
31735: LD_ADDR_VAR 0 2
31739: PUSH
31740: LD_VAR 0 2
31744: PUSH
31745: LD_INT 1
31747: MINUS
31748: ST_TO_ADDR
// if j = 0 then
31749: LD_VAR 0 2
31753: PUSH
31754: LD_INT 0
31756: EQUAL
31757: IFFALSE 31761
// break ;
31759: GO 31763
// end ;
31761: GO 31712
31763: POP
31764: POP
// BuildBehemoths ;
31765: CALL 8368 0 0
// repeat wait ( 15 15$00 ) ;
31769: LD_INT 31500
31771: PPUSH
31772: CALL_OW 67
// if behemothDestroyedBeforeFinish then
31776: LD_EXP 27
31780: IFFALSE 31784
// break ;
31782: GO 31816
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
31784: LD_INT 267
31786: PPUSH
31787: CALL_OW 274
31791: PPUSH
31792: LD_INT 1
31794: PPUSH
31795: CALL_OW 275
31799: PUSH
31800: LD_INT 1000
31802: GREATEREQUAL
31803: IFFALSE 31809
// BuildBehemoths ;
31805: CALL 8368 0 0
// until not behemothBuilders ;
31809: LD_EXP 77
31813: NOT
31814: IFFALSE 31769
// end ;
31816: PPOPN 3
31818: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
31819: LD_EXP 77
31823: NOT
31824: PUSH
31825: LD_EXP 28
31829: NOT
31830: AND
31831: PUSH
31832: LD_EXP 25
31836: AND
31837: IFFALSE 31857
31839: GO 31841
31841: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
31842: LD_STRING M4a
31844: PPUSH
31845: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
31849: LD_ADDR_EXP 27
31853: PUSH
31854: LD_INT 1
31856: ST_TO_ADDR
// end ;
31857: END
// every 0 0$1 trigger behemothDone do
31858: LD_EXP 28
31862: IFFALSE 31874
31864: GO 31866
31866: DISABLE
// ChangeMissionObjectives ( M4b ) ;
31867: LD_STRING M4b
31869: PPUSH
31870: CALL_OW 337
31874: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
31875: LD_EXP 29
31879: NOT
31880: IFFALSE 32076
31882: GO 31884
31884: DISABLE
31885: LD_INT 0
31887: PPUSH
31888: PPUSH
// begin enable ;
31889: ENABLE
// tmp := GetBehemoths ( 3 ) ;
31890: LD_ADDR_VAR 0 1
31894: PUSH
31895: LD_INT 3
31897: PPUSH
31898: CALL 108024 0 1
31902: ST_TO_ADDR
// if not tmp and not behemothDone then
31903: LD_VAR 0 1
31907: NOT
31908: PUSH
31909: LD_EXP 28
31913: NOT
31914: AND
31915: IFFALSE 31951
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
31917: LD_ADDR_VAR 0 1
31921: PUSH
31922: LD_INT 22
31924: PUSH
31925: LD_INT 3
31927: PUSH
31928: EMPTY
31929: LIST
31930: LIST
31931: PUSH
31932: LD_INT 30
31934: PUSH
31935: LD_INT 37
31937: PUSH
31938: EMPTY
31939: LIST
31940: LIST
31941: PUSH
31942: EMPTY
31943: LIST
31944: LIST
31945: PPUSH
31946: CALL_OW 69
31950: ST_TO_ADDR
// if not tmp then
31951: LD_VAR 0 1
31955: NOT
31956: IFFALSE 31960
// exit ;
31958: GO 32076
// for i in tmp do
31960: LD_ADDR_VAR 0 2
31964: PUSH
31965: LD_VAR 0 1
31969: PUSH
31970: FOR_IN
31971: IFFALSE 32074
// if See ( 1 , i ) then
31973: LD_INT 1
31975: PPUSH
31976: LD_VAR 0 2
31980: PPUSH
31981: CALL_OW 292
31985: IFFALSE 32072
// begin if GetType ( i ) = unit_building then
31987: LD_VAR 0 2
31991: PPUSH
31992: CALL_OW 247
31996: PUSH
31997: LD_INT 3
31999: EQUAL
32000: IFFALSE 32038
// begin disable ;
32002: DISABLE
// CenterNowOnUnits ( i ) ;
32003: LD_VAR 0 2
32007: PPUSH
32008: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
32012: LD_EXP 40
32016: PPUSH
32017: LD_STRING D17a-JMM-1
32019: PPUSH
32020: CALL_OW 88
// seeBehemoth := true ;
32024: LD_ADDR_EXP 29
32028: PUSH
32029: LD_INT 1
32031: ST_TO_ADDR
// exit ;
32032: POP
32033: POP
32034: GO 32076
// end else
32036: GO 32072
// begin disable ;
32038: DISABLE
// CenterNowOnUnits ( i ) ;
32039: LD_VAR 0 2
32043: PPUSH
32044: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
32048: LD_EXP 40
32052: PPUSH
32053: LD_STRING D17b-JMM-1
32055: PPUSH
32056: CALL_OW 88
// seeBehemoth := true ;
32060: LD_ADDR_EXP 29
32064: PUSH
32065: LD_INT 1
32067: ST_TO_ADDR
// exit ;
32068: POP
32069: POP
32070: GO 32076
// end ; end ;
32072: GO 31970
32074: POP
32075: POP
// end ;
32076: PPOPN 2
32078: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
32079: LD_EXP 14
32083: PUSH
32084: LD_INT 123200
32086: GREATEREQUAL
32087: IFFALSE 33287
32089: GO 32091
32091: DISABLE
32092: LD_INT 0
32094: PPUSH
32095: PPUSH
32096: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
32097: LD_INT 2
32099: PPUSH
32100: LD_INT 23
32102: PUSH
32103: LD_INT 3
32105: PUSH
32106: LD_INT 3
32108: PUSH
32109: LD_INT 48
32111: PUSH
32112: EMPTY
32113: LIST
32114: LIST
32115: LIST
32116: LIST
32117: PUSH
32118: EMPTY
32119: LIST
32120: PPUSH
32121: CALL 63846 0 2
// repeat wait ( 0 0$1 ) ;
32125: LD_INT 35
32127: PPUSH
32128: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
32132: LD_INT 22
32134: PUSH
32135: LD_INT 3
32137: PUSH
32138: EMPTY
32139: LIST
32140: LIST
32141: PUSH
32142: LD_INT 34
32144: PUSH
32145: LD_INT 48
32147: PUSH
32148: EMPTY
32149: LIST
32150: LIST
32151: PUSH
32152: EMPTY
32153: LIST
32154: LIST
32155: PPUSH
32156: CALL_OW 69
32160: IFFALSE 32125
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
32162: LD_ADDR_VAR 0 1
32166: PUSH
32167: LD_INT 22
32169: PUSH
32170: LD_INT 3
32172: PUSH
32173: EMPTY
32174: LIST
32175: LIST
32176: PUSH
32177: LD_INT 34
32179: PUSH
32180: LD_INT 48
32182: PUSH
32183: EMPTY
32184: LIST
32185: LIST
32186: PUSH
32187: EMPTY
32188: LIST
32189: LIST
32190: PPUSH
32191: CALL_OW 69
32195: PUSH
32196: LD_INT 1
32198: ARRAY
32199: ST_TO_ADDR
// missionStage := 12 ;
32200: LD_ADDR_EXP 15
32204: PUSH
32205: LD_INT 12
32207: ST_TO_ADDR
// platonovHasBomb := true ;
32208: LD_ADDR_EXP 30
32212: PUSH
32213: LD_INT 1
32215: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
32216: LD_VAR 0 1
32220: PPUSH
32221: LD_INT 181
32223: PPUSH
32224: LD_INT 86
32226: PPUSH
32227: CALL_OW 171
// AddComHold ( bomb ) ;
32231: LD_VAR 0 1
32235: PPUSH
32236: CALL_OW 200
// wait ( 0 0$10 ) ;
32240: LD_INT 350
32242: PPUSH
32243: CALL_OW 67
// DialogueOn ;
32247: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
32251: LD_EXP 68
32255: PPUSH
32256: LD_STRING D15-Pla-1
32258: PPUSH
32259: CALL_OW 94
// dec := Query ( Q15a ) ;
32263: LD_ADDR_VAR 0 2
32267: PUSH
32268: LD_STRING Q15a
32270: PPUSH
32271: CALL_OW 97
32275: ST_TO_ADDR
// if dec = 1 then
32276: LD_VAR 0 2
32280: PUSH
32281: LD_INT 1
32283: EQUAL
32284: IFFALSE 32307
// begin Say ( JMM , D15a-JMM-1 ) ;
32286: LD_EXP 40
32290: PPUSH
32291: LD_STRING D15a-JMM-1
32293: PPUSH
32294: CALL_OW 88
// YouLost ( Surrender ) ;
32298: LD_STRING Surrender
32300: PPUSH
32301: CALL_OW 104
// exit ;
32305: GO 33287
// end ; if dec = 2 then
32307: LD_VAR 0 2
32311: PUSH
32312: LD_INT 2
32314: EQUAL
32315: IFFALSE 32384
// begin Say ( JMM , D15b-JMM-1 ) ;
32317: LD_EXP 40
32321: PPUSH
32322: LD_STRING D15b-JMM-1
32324: PPUSH
32325: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
32329: LD_EXP 68
32333: PPUSH
32334: LD_STRING D15b-Pla-1
32336: PPUSH
32337: CALL_OW 94
// DialogueOff ;
32341: CALL_OW 7
// wait ( 3 3$00 ) ;
32345: LD_INT 6300
32347: PPUSH
32348: CALL_OW 67
// DialogueOn ;
32352: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
32356: LD_EXP 40
32360: PPUSH
32361: LD_STRING D15d-JMM-1a
32363: PPUSH
32364: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
32368: LD_EXP 68
32372: PPUSH
32373: LD_STRING D15d-Pla-1
32375: PPUSH
32376: CALL_OW 94
// DialogueOff ;
32380: CALL_OW 7
// end ; if dec = 3 then
32384: LD_VAR 0 2
32388: PUSH
32389: LD_INT 3
32391: EQUAL
32392: IFFALSE 32446
// begin Say ( JMM , D15c-JMM-1 ) ;
32394: LD_EXP 40
32398: PPUSH
32399: LD_STRING D15c-JMM-1
32401: PPUSH
32402: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
32406: LD_EXP 68
32410: PPUSH
32411: LD_STRING D15c-Pla-1
32413: PPUSH
32414: CALL_OW 94
// DialogueOff ;
32418: CALL_OW 7
// wait ( 0 0$15 ) ;
32422: LD_INT 525
32424: PPUSH
32425: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
32429: LD_VAR 0 1
32433: PPUSH
32434: LD_INT 60
32436: PPUSH
32437: LD_INT 95
32439: PPUSH
32440: CALL_OW 116
// exit ;
32444: GO 33287
// end ; if dec = 4 then
32446: LD_VAR 0 2
32450: PUSH
32451: LD_INT 4
32453: EQUAL
32454: IFFALSE 32484
// begin Say ( JMM , D15d-JMM-1 ) ;
32456: LD_EXP 40
32460: PPUSH
32461: LD_STRING D15d-JMM-1
32463: PPUSH
32464: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
32468: LD_EXP 68
32472: PPUSH
32473: LD_STRING D15d-Pla-1
32475: PPUSH
32476: CALL_OW 94
// DialogueOff ;
32480: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32484: LD_EXP 66
32488: PPUSH
32489: CALL_OW 302
32493: PUSH
32494: LD_EXP 66
32498: PPUSH
32499: CALL_OW 255
32503: PUSH
32504: LD_INT 1
32506: EQUAL
32507: AND
32508: PUSH
32509: LD_INT 22
32511: PUSH
32512: LD_INT 1
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PUSH
32519: LD_INT 34
32521: PUSH
32522: LD_INT 8
32524: PUSH
32525: EMPTY
32526: LIST
32527: LIST
32528: PUSH
32529: EMPTY
32530: LIST
32531: LIST
32532: PPUSH
32533: CALL_OW 69
32537: NOT
32538: AND
32539: IFFALSE 33188
// begin SetSide ( Friend , 8 ) ;
32541: LD_EXP 66
32545: PPUSH
32546: LD_INT 8
32548: PPUSH
32549: CALL_OW 235
// if IsInUnit ( Friend ) then
32553: LD_EXP 66
32557: PPUSH
32558: CALL_OW 310
32562: IFFALSE 32573
// ComExitBuilding ( Friend ) ;
32564: LD_EXP 66
32568: PPUSH
32569: CALL_OW 122
// if IsDriver ( Friend ) then
32573: LD_EXP 66
32577: PPUSH
32578: CALL 105567 0 1
32582: IFFALSE 32593
// ComExitVehicle ( Friend ) ;
32584: LD_EXP 66
32588: PPUSH
32589: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
32593: LD_EXP 66
32597: PPUSH
32598: LD_INT 9
32600: PPUSH
32601: LD_INT 2
32603: PPUSH
32604: CALL_OW 171
// wait ( 0 0$05 ) ;
32608: LD_INT 175
32610: PPUSH
32611: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
32615: LD_EXP 66
32619: PPUSH
32620: CALL_OW 87
// DialogueOn ;
32624: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
32628: LD_EXP 40
32632: PPUSH
32633: LD_STRING D16-JMM-1
32635: PPUSH
32636: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
32640: LD_EXP 66
32644: PPUSH
32645: LD_STRING D16-Friend-1
32647: PPUSH
32648: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
32652: LD_EXP 40
32656: PPUSH
32657: LD_STRING D16-JMM-2
32659: PPUSH
32660: CALL_OW 88
// DialogueOff ;
32664: CALL_OW 7
// SetSide ( Friend , 1 ) ;
32668: LD_EXP 66
32672: PPUSH
32673: LD_INT 1
32675: PPUSH
32676: CALL_OW 235
// ComHold ( Friend ) ;
32680: LD_EXP 66
32684: PPUSH
32685: CALL_OW 140
// wait ( 0 0$20 ) ;
32689: LD_INT 700
32691: PPUSH
32692: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
32696: LD_EXP 66
32700: PPUSH
32701: LD_INT 9
32703: PPUSH
32704: LD_INT 2
32706: PPUSH
32707: CALL_OW 297
32711: PUSH
32712: LD_INT 30
32714: LESS
32715: IFFALSE 32784
// begin SetSide ( Friend , 8 ) ;
32717: LD_EXP 66
32721: PPUSH
32722: LD_INT 8
32724: PPUSH
32725: CALL_OW 235
// if IsInUnit ( Friend ) then
32729: LD_EXP 66
32733: PPUSH
32734: CALL_OW 310
32738: IFFALSE 32749
// ComExitBuilding ( Friend ) ;
32740: LD_EXP 66
32744: PPUSH
32745: CALL_OW 122
// if IsDriver ( Friend ) then
32749: LD_EXP 66
32753: PPUSH
32754: CALL 105567 0 1
32758: IFFALSE 32769
// ComExitVehicle ( Friend ) ;
32760: LD_EXP 66
32764: PPUSH
32765: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
32769: LD_EXP 66
32773: PPUSH
32774: LD_INT 9
32776: PPUSH
32777: LD_INT 2
32779: PPUSH
32780: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
32784: LD_INT 1050
32786: PPUSH
32787: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32791: LD_INT 22
32793: PUSH
32794: LD_INT 1
32796: PUSH
32797: EMPTY
32798: LIST
32799: LIST
32800: PUSH
32801: LD_INT 34
32803: PUSH
32804: LD_INT 8
32806: PUSH
32807: EMPTY
32808: LIST
32809: LIST
32810: PUSH
32811: EMPTY
32812: LIST
32813: LIST
32814: PPUSH
32815: CALL_OW 69
32819: NOT
32820: IFFALSE 33166
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
32822: LD_ADDR_VAR 0 3
32826: PUSH
32827: LD_INT 22
32829: PUSH
32830: LD_INT 1
32832: PUSH
32833: EMPTY
32834: LIST
32835: LIST
32836: PUSH
32837: LD_INT 26
32839: PUSH
32840: LD_INT 1
32842: PUSH
32843: EMPTY
32844: LIST
32845: LIST
32846: PUSH
32847: LD_INT 3
32849: PUSH
32850: LD_INT 25
32852: PUSH
32853: LD_INT 12
32855: PUSH
32856: EMPTY
32857: LIST
32858: LIST
32859: PUSH
32860: LD_INT 25
32862: PUSH
32863: LD_INT 16
32865: PUSH
32866: EMPTY
32867: LIST
32868: LIST
32869: PUSH
32870: EMPTY
32871: LIST
32872: LIST
32873: LIST
32874: PUSH
32875: EMPTY
32876: LIST
32877: LIST
32878: LIST
32879: PPUSH
32880: CALL_OW 69
32884: PUSH
32885: LD_EXP 40
32889: PUSH
32890: LD_EXP 42
32894: PUSH
32895: LD_EXP 56
32899: PUSH
32900: LD_EXP 43
32904: PUSH
32905: LD_EXP 44
32909: PUSH
32910: LD_EXP 45
32914: PUSH
32915: LD_EXP 46
32919: PUSH
32920: LD_EXP 47
32924: PUSH
32925: LD_EXP 48
32929: PUSH
32930: LD_EXP 49
32934: PUSH
32935: LD_EXP 50
32939: PUSH
32940: LD_EXP 51
32944: PUSH
32945: LD_EXP 52
32949: PUSH
32950: LD_EXP 53
32954: PUSH
32955: LD_EXP 54
32959: PUSH
32960: EMPTY
32961: LIST
32962: LIST
32963: LIST
32964: LIST
32965: LIST
32966: LIST
32967: LIST
32968: LIST
32969: LIST
32970: LIST
32971: LIST
32972: LIST
32973: LIST
32974: LIST
32975: LIST
32976: DIFF
32977: ST_TO_ADDR
// DialogueOn ;
32978: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
32982: LD_EXP 68
32986: PPUSH
32987: LD_STRING D16a-Pla-1
32989: PPUSH
32990: CALL_OW 94
// if Stevens then
32994: LD_EXP 42
32998: IFFALSE 33014
// Say ( Stevens , D16a-Huck-1 ) else
33000: LD_EXP 42
33004: PPUSH
33005: LD_STRING D16a-Huck-1
33007: PPUSH
33008: CALL_OW 88
33012: GO 33056
// if Baker then
33014: LD_EXP 56
33018: IFFALSE 33034
// Say ( Baker , D16a-Huck-1 ) else
33020: LD_EXP 56
33024: PPUSH
33025: LD_STRING D16a-Huck-1
33027: PPUSH
33028: CALL_OW 88
33032: GO 33056
// if tmp then
33034: LD_VAR 0 3
33038: IFFALSE 33056
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
33040: LD_VAR 0 3
33044: PUSH
33045: LD_INT 1
33047: ARRAY
33048: PPUSH
33049: LD_STRING D16a-Sol1-1
33051: PPUSH
33052: CALL_OW 88
// if GetSide ( Friend ) = 8 then
33056: LD_EXP 66
33060: PPUSH
33061: CALL_OW 255
33065: PUSH
33066: LD_INT 8
33068: EQUAL
33069: IFFALSE 33085
// Say ( JMM , D16a-JMM-1 ) else
33071: LD_EXP 40
33075: PPUSH
33076: LD_STRING D16a-JMM-1
33078: PPUSH
33079: CALL_OW 88
33083: GO 33145
// begin Say ( JMM , D16a-JMM-1a ) ;
33085: LD_EXP 40
33089: PPUSH
33090: LD_STRING D16a-JMM-1a
33092: PPUSH
33093: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
33097: LD_EXP 66
33101: PPUSH
33102: LD_STRING D16a-Friend-1
33104: PPUSH
33105: CALL_OW 88
// ComExitBuilding ( Friend ) ;
33109: LD_EXP 66
33113: PPUSH
33114: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
33118: LD_EXP 66
33122: PPUSH
33123: LD_INT 191
33125: PPUSH
33126: LD_INT 103
33128: PPUSH
33129: CALL_OW 171
// SetSide ( Friend , 3 ) ;
33133: LD_EXP 66
33137: PPUSH
33138: LD_INT 3
33140: PPUSH
33141: CALL_OW 235
// end ; DialogueOff ;
33145: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
33149: LD_VAR 0 1
33153: PPUSH
33154: LD_INT 60
33156: PPUSH
33157: LD_INT 95
33159: PPUSH
33160: CALL_OW 116
// end else
33164: GO 33186
// begin DialogueOn ;
33166: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
33170: LD_EXP 68
33174: PPUSH
33175: LD_STRING D16c-Pla-1
33177: PPUSH
33178: CALL_OW 94
// DialogueOff ;
33182: CALL_OW 7
// end ; end else
33186: GO 33287
// begin wait ( 3 3$00 ) ;
33188: LD_INT 6300
33190: PPUSH
33191: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33195: LD_INT 22
33197: PUSH
33198: LD_INT 1
33200: PUSH
33201: EMPTY
33202: LIST
33203: LIST
33204: PUSH
33205: LD_INT 34
33207: PUSH
33208: LD_INT 8
33210: PUSH
33211: EMPTY
33212: LIST
33213: LIST
33214: PUSH
33215: EMPTY
33216: LIST
33217: LIST
33218: PPUSH
33219: CALL_OW 69
33223: NOT
33224: IFFALSE 33267
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
33226: LD_EXP 68
33230: PPUSH
33231: LD_STRING D16b-Pla-1
33233: PPUSH
33234: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
33238: LD_EXP 40
33242: PPUSH
33243: LD_STRING D16b-JMM-1
33245: PPUSH
33246: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
33250: LD_VAR 0 1
33254: PPUSH
33255: LD_INT 60
33257: PPUSH
33258: LD_INT 95
33260: PPUSH
33261: CALL_OW 116
// end else
33265: GO 33287
// begin DialogueOn ;
33267: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
33271: LD_EXP 68
33275: PPUSH
33276: LD_STRING D16c-Pla-1
33278: PPUSH
33279: CALL_OW 94
// DialogueOff ;
33283: CALL_OW 7
// end ; end ; end ;
33287: PPOPN 3
33289: END
// every 0 0$10 trigger ( GetTech ( tech_SibFiss , 1 ) = state_researched or missionTime >= 60 60$00 ) and not allianceDestroyed and IsOk ( Roth ) do var dec ;
33290: LD_INT 25
33292: PPUSH
33293: LD_INT 1
33295: PPUSH
33296: CALL_OW 321
33300: PUSH
33301: LD_INT 2
33303: EQUAL
33304: PUSH
33305: LD_EXP 14
33309: PUSH
33310: LD_INT 126000
33312: GREATEREQUAL
33313: OR
33314: PUSH
33315: LD_EXP 23
33319: NOT
33320: AND
33321: PUSH
33322: LD_EXP 79
33326: PPUSH
33327: CALL_OW 302
33331: AND
33332: IFFALSE 33690
33334: GO 33336
33336: DISABLE
33337: LD_INT 0
33339: PPUSH
// begin missionStage := 11 ;
33340: LD_ADDR_EXP 15
33344: PUSH
33345: LD_INT 11
33347: ST_TO_ADDR
// DialogueOn ;
33348: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
33352: LD_EXP 79
33356: PPUSH
33357: LD_STRING D9-Roth-1
33359: PPUSH
33360: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
33364: LD_EXP 40
33368: PPUSH
33369: LD_STRING D9-JMM-1
33371: PPUSH
33372: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
33376: LD_EXP 79
33380: PPUSH
33381: LD_STRING D9-Roth-2
33383: PPUSH
33384: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
33388: LD_EXP 79
33392: PPUSH
33393: LD_STRING D9-Roth-2a
33395: PPUSH
33396: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
33400: LD_EXP 68
33404: PPUSH
33405: LD_STRING D9-Pla-2
33407: PPUSH
33408: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
33412: LD_EXP 79
33416: PPUSH
33417: LD_STRING D9-Roth-3
33419: PPUSH
33420: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
33424: LD_EXP 68
33428: PPUSH
33429: LD_STRING D9-Pla-3
33431: PPUSH
33432: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
33436: LD_EXP 79
33440: PPUSH
33441: LD_STRING D9-Roth-4
33443: PPUSH
33444: CALL_OW 94
// dec := Query ( Q9 ) ;
33448: LD_ADDR_VAR 0 1
33452: PUSH
33453: LD_STRING Q9
33455: PPUSH
33456: CALL_OW 97
33460: ST_TO_ADDR
// if dec = 1 then
33461: LD_VAR 0 1
33465: PUSH
33466: LD_INT 1
33468: EQUAL
33469: IFFALSE 33483
// SayRadio ( Roth , D9a-Roth-1 ) ;
33471: LD_EXP 79
33475: PPUSH
33476: LD_STRING D9a-Roth-1
33478: PPUSH
33479: CALL_OW 94
// if dec = 2 then
33483: LD_VAR 0 1
33487: PUSH
33488: LD_INT 2
33490: EQUAL
33491: IFFALSE 33517
// begin Say ( JMM , D9b-JMM-1 ) ;
33493: LD_EXP 40
33497: PPUSH
33498: LD_STRING D9b-JMM-1
33500: PPUSH
33501: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
33505: LD_EXP 79
33509: PPUSH
33510: LD_STRING D9b-Roth-1
33512: PPUSH
33513: CALL_OW 94
// end ; if dec = 3 then
33517: LD_VAR 0 1
33521: PUSH
33522: LD_INT 3
33524: EQUAL
33525: IFFALSE 33587
// begin Say ( JMM , D9c-JMM-1 ) ;
33527: LD_EXP 40
33531: PPUSH
33532: LD_STRING D9c-JMM-1
33534: PPUSH
33535: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
33539: LD_EXP 79
33543: PPUSH
33544: LD_STRING D9c-Roth-1
33546: PPUSH
33547: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
33551: LD_EXP 40
33555: PPUSH
33556: LD_STRING D9c-JMM-2
33558: PPUSH
33559: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
33563: LD_EXP 79
33567: PPUSH
33568: LD_STRING D9c-Roth-2
33570: PPUSH
33571: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
33575: LD_EXP 40
33579: PPUSH
33580: LD_STRING D9c-JMM-3
33582: PPUSH
33583: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
33587: LD_EXP 79
33591: PPUSH
33592: LD_STRING D9c-Roth-3
33594: PPUSH
33595: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
33599: LD_EXP 79
33603: PPUSH
33604: LD_STRING D9cont-Roth-1
33606: PPUSH
33607: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
33611: LD_EXP 40
33615: PPUSH
33616: LD_STRING D9cont-JMM-1
33618: PPUSH
33619: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
33623: LD_EXP 79
33627: PPUSH
33628: LD_STRING D9cont-Roth-2
33630: PPUSH
33631: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
33635: LD_EXP 40
33639: PPUSH
33640: LD_STRING D9cont-JMM-2
33642: PPUSH
33643: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
33647: LD_EXP 79
33651: PPUSH
33652: LD_STRING D9cont-Roth-3
33654: PPUSH
33655: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
33659: LD_EXP 40
33663: PPUSH
33664: LD_STRING D9cont-JMM-3
33666: PPUSH
33667: CALL_OW 88
// DialogueOff ;
33671: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
33675: LD_STRING M3
33677: PPUSH
33678: CALL_OW 337
// allianceActive := true ;
33682: LD_ADDR_EXP 31
33686: PUSH
33687: LD_INT 1
33689: ST_TO_ADDR
// end ;
33690: PPOPN 1
33692: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
33693: LD_INT 1
33695: PPUSH
33696: LD_INT 126
33698: PPUSH
33699: CALL_OW 292
33703: PUSH
33704: LD_EXP 68
33708: PPUSH
33709: CALL_OW 310
33713: AND
33714: IFFALSE 33867
33716: GO 33718
33718: DISABLE
33719: LD_INT 0
33721: PPUSH
// begin ComExitBuilding ( Platonov ) ;
33722: LD_EXP 68
33726: PPUSH
33727: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
33731: LD_ADDR_VAR 0 1
33735: PUSH
33736: LD_INT 4
33738: PPUSH
33739: LD_INT 22
33741: PUSH
33742: LD_INT 1
33744: PUSH
33745: EMPTY
33746: LIST
33747: LIST
33748: PPUSH
33749: CALL_OW 70
33753: PPUSH
33754: LD_EXP 68
33758: PPUSH
33759: CALL_OW 74
33763: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
33764: LD_EXP 68
33768: PPUSH
33769: LD_VAR 0 1
33773: PUSH
33774: LD_INT 1
33776: ARRAY
33777: PPUSH
33778: CALL_OW 175
// SayRadio ( Platonov , D18-Pla-1 ) ;
33782: LD_EXP 68
33786: PPUSH
33787: LD_STRING D18-Pla-1
33789: PPUSH
33790: CALL_OW 94
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
33794: LD_INT 22
33796: PUSH
33797: LD_INT 3
33799: PUSH
33800: EMPTY
33801: LIST
33802: LIST
33803: PUSH
33804: LD_INT 34
33806: PUSH
33807: LD_INT 48
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: PPUSH
33818: CALL_OW 69
33822: IFFALSE 33867
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 111 , 97 ) ;
33824: LD_INT 22
33826: PUSH
33827: LD_INT 3
33829: PUSH
33830: EMPTY
33831: LIST
33832: LIST
33833: PUSH
33834: LD_INT 34
33836: PUSH
33837: LD_INT 48
33839: PUSH
33840: EMPTY
33841: LIST
33842: LIST
33843: PUSH
33844: EMPTY
33845: LIST
33846: LIST
33847: PPUSH
33848: CALL_OW 69
33852: PUSH
33853: LD_INT 1
33855: ARRAY
33856: PPUSH
33857: LD_INT 111
33859: PPUSH
33860: LD_INT 97
33862: PPUSH
33863: CALL_OW 116
// end ;
33867: PPOPN 1
33869: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 14 , 13 , 12 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
33870: LD_EXP 68
33874: PPUSH
33875: CALL_OW 301
33879: PUSH
33880: LD_EXP 71
33884: PPUSH
33885: CALL_OW 301
33889: AND
33890: PUSH
33891: LD_INT 22
33893: PUSH
33894: LD_INT 3
33896: PUSH
33897: EMPTY
33898: LIST
33899: LIST
33900: PUSH
33901: LD_INT 21
33903: PUSH
33904: LD_INT 1
33906: PUSH
33907: EMPTY
33908: LIST
33909: LIST
33910: PUSH
33911: LD_INT 50
33913: PUSH
33914: EMPTY
33915: LIST
33916: PUSH
33917: EMPTY
33918: LIST
33919: LIST
33920: LIST
33921: PPUSH
33922: CALL_OW 69
33926: PUSH
33927: LD_INT 14
33929: PUSH
33930: LD_INT 13
33932: PUSH
33933: LD_INT 12
33935: PUSH
33936: LD_INT 10
33938: PUSH
33939: EMPTY
33940: LIST
33941: LIST
33942: LIST
33943: LIST
33944: PUSH
33945: LD_OWVAR 67
33949: ARRAY
33950: LESS
33951: AND
33952: IFFALSE 34751
33954: GO 33956
33956: DISABLE
33957: LD_INT 0
33959: PPUSH
33960: PPUSH
33961: PPUSH
33962: PPUSH
// begin MC_Kill ( 2 ) ;
33963: LD_INT 2
33965: PPUSH
33966: CALL 39821 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
33970: LD_INT 1
33972: PPUSH
33973: LD_INT 3
33975: PPUSH
33976: LD_INT 1
33978: PPUSH
33979: LD_INT 1
33981: PPUSH
33982: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
33986: LD_ADDR_VAR 0 2
33990: PUSH
33991: LD_INT 22
33993: PUSH
33994: LD_INT 3
33996: PUSH
33997: EMPTY
33998: LIST
33999: LIST
34000: PUSH
34001: LD_INT 21
34003: PUSH
34004: LD_INT 1
34006: PUSH
34007: EMPTY
34008: LIST
34009: LIST
34010: PUSH
34011: LD_INT 50
34013: PUSH
34014: EMPTY
34015: LIST
34016: PUSH
34017: LD_INT 26
34019: PUSH
34020: LD_INT 1
34022: PUSH
34023: EMPTY
34024: LIST
34025: LIST
34026: PUSH
34027: EMPTY
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: PPUSH
34033: CALL_OW 69
34037: ST_TO_ADDR
// if not tmp then
34038: LD_VAR 0 2
34042: NOT
34043: IFFALSE 34099
// begin uc_side = 3 ;
34045: LD_ADDR_OWVAR 20
34049: PUSH
34050: LD_INT 3
34052: ST_TO_ADDR
// uc_nation = 3 ;
34053: LD_ADDR_OWVAR 21
34057: PUSH
34058: LD_INT 3
34060: ST_TO_ADDR
// hc_name =  ;
34061: LD_ADDR_OWVAR 26
34065: PUSH
34066: LD_STRING 
34068: ST_TO_ADDR
// hc_gallery =  ;
34069: LD_ADDR_OWVAR 33
34073: PUSH
34074: LD_STRING 
34076: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
34077: LD_INT 1
34079: PPUSH
34080: LD_INT 10
34082: PPUSH
34083: CALL_OW 381
// tmp = CreateHuman ;
34087: LD_ADDR_VAR 0 2
34091: PUSH
34092: CALL_OW 44
34096: ST_TO_ADDR
// end else
34097: GO 34113
// tmp := tmp [ 1 ] ;
34099: LD_ADDR_VAR 0 2
34103: PUSH
34104: LD_VAR 0 2
34108: PUSH
34109: LD_INT 1
34111: ARRAY
34112: ST_TO_ADDR
// DialogueOn ;
34113: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
34117: LD_VAR 0 2
34121: PPUSH
34122: LD_STRING DSurrenderRussians-RSol1-1a
34124: PPUSH
34125: CALL_OW 94
// DialogueOff ;
34129: CALL_OW 7
// russianDestroyed := true ;
34133: LD_ADDR_EXP 21
34137: PUSH
34138: LD_INT 1
34140: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
34141: LD_ADDR_VAR 0 1
34145: PUSH
34146: LD_INT 22
34148: PUSH
34149: LD_INT 6
34151: PUSH
34152: EMPTY
34153: LIST
34154: LIST
34155: PPUSH
34156: CALL_OW 69
34160: PUSH
34161: FOR_IN
34162: IFFALSE 34175
// KillUnit ( i ) ;
34164: LD_VAR 0 1
34168: PPUSH
34169: CALL_OW 66
34173: GO 34161
34175: POP
34176: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
34177: LD_INT 22
34179: PUSH
34180: LD_INT 3
34182: PUSH
34183: EMPTY
34184: LIST
34185: LIST
34186: PUSH
34187: LD_INT 21
34189: PUSH
34190: LD_INT 1
34192: PUSH
34193: EMPTY
34194: LIST
34195: LIST
34196: PUSH
34197: EMPTY
34198: LIST
34199: LIST
34200: PPUSH
34201: CALL_OW 69
34205: PPUSH
34206: CALL_OW 122
// wait ( 0 0$1 ) ;
34210: LD_INT 35
34212: PPUSH
34213: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
34217: LD_INT 22
34219: PUSH
34220: LD_INT 3
34222: PUSH
34223: EMPTY
34224: LIST
34225: LIST
34226: PUSH
34227: LD_INT 21
34229: PUSH
34230: LD_INT 1
34232: PUSH
34233: EMPTY
34234: LIST
34235: LIST
34236: PUSH
34237: EMPTY
34238: LIST
34239: LIST
34240: PPUSH
34241: CALL_OW 69
34245: PPUSH
34246: LD_INT 25
34248: PPUSH
34249: CALL_OW 173
// wait ( 0 0$35 ) ;
34253: LD_INT 1225
34255: PPUSH
34256: CALL_OW 67
// PrepareOmarInvasion ;
34260: CALL 16368 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
34264: LD_ADDR_VAR 0 2
34268: PUSH
34269: LD_EXP 97
34273: PPUSH
34274: CALL_OW 250
34278: PUSH
34279: LD_EXP 97
34283: PPUSH
34284: CALL_OW 251
34288: PUSH
34289: EMPTY
34290: LIST
34291: LIST
34292: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
34293: LD_VAR 0 2
34297: PUSH
34298: LD_INT 1
34300: ARRAY
34301: PPUSH
34302: LD_VAR 0 2
34306: PUSH
34307: LD_INT 2
34309: ARRAY
34310: PPUSH
34311: LD_INT 1
34313: PPUSH
34314: LD_INT 8
34316: NEG
34317: PPUSH
34318: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
34322: LD_EXP 97
34326: PPUSH
34327: CALL_OW 87
// DialogueOn ;
34331: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
34335: LD_EXP 40
34339: PPUSH
34340: LD_STRING D19-JMM-1
34342: PPUSH
34343: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Kurt , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
34347: LD_ADDR_VAR 0 3
34351: PUSH
34352: LD_INT 22
34354: PUSH
34355: LD_INT 1
34357: PUSH
34358: EMPTY
34359: LIST
34360: LIST
34361: PUSH
34362: LD_INT 26
34364: PUSH
34365: LD_INT 1
34367: PUSH
34368: EMPTY
34369: LIST
34370: LIST
34371: PUSH
34372: LD_INT 2
34374: PUSH
34375: LD_INT 25
34377: PUSH
34378: LD_INT 1
34380: PUSH
34381: EMPTY
34382: LIST
34383: LIST
34384: PUSH
34385: LD_INT 25
34387: PUSH
34388: LD_INT 2
34390: PUSH
34391: EMPTY
34392: LIST
34393: LIST
34394: PUSH
34395: LD_INT 25
34397: PUSH
34398: LD_INT 3
34400: PUSH
34401: EMPTY
34402: LIST
34403: LIST
34404: PUSH
34405: LD_INT 25
34407: PUSH
34408: LD_INT 4
34410: PUSH
34411: EMPTY
34412: LIST
34413: LIST
34414: PUSH
34415: LD_INT 25
34417: PUSH
34418: LD_INT 5
34420: PUSH
34421: EMPTY
34422: LIST
34423: LIST
34424: PUSH
34425: LD_INT 25
34427: PUSH
34428: LD_INT 8
34430: PUSH
34431: EMPTY
34432: LIST
34433: LIST
34434: PUSH
34435: EMPTY
34436: LIST
34437: LIST
34438: LIST
34439: LIST
34440: LIST
34441: LIST
34442: LIST
34443: PUSH
34444: EMPTY
34445: LIST
34446: LIST
34447: LIST
34448: PPUSH
34449: CALL_OW 69
34453: PUSH
34454: LD_EXP 40
34458: PUSH
34459: LD_EXP 41
34463: PUSH
34464: LD_EXP 64
34468: PUSH
34469: LD_EXP 42
34473: PUSH
34474: LD_EXP 43
34478: PUSH
34479: LD_EXP 44
34483: PUSH
34484: LD_EXP 45
34488: PUSH
34489: LD_EXP 46
34493: PUSH
34494: LD_EXP 47
34498: PUSH
34499: LD_EXP 48
34503: PUSH
34504: LD_EXP 49
34508: PUSH
34509: LD_EXP 50
34513: PUSH
34514: LD_EXP 51
34518: PUSH
34519: LD_EXP 52
34523: PUSH
34524: LD_EXP 53
34528: PUSH
34529: LD_EXP 54
34533: PUSH
34534: LD_EXP 55
34538: PUSH
34539: LD_EXP 56
34543: PUSH
34544: EMPTY
34545: LIST
34546: LIST
34547: LIST
34548: LIST
34549: LIST
34550: LIST
34551: LIST
34552: LIST
34553: LIST
34554: LIST
34555: LIST
34556: LIST
34557: LIST
34558: LIST
34559: LIST
34560: LIST
34561: LIST
34562: LIST
34563: DIFF
34564: ST_TO_ADDR
// if tmp2 then
34565: LD_VAR 0 3
34569: IFFALSE 34587
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
34571: LD_VAR 0 3
34575: PUSH
34576: LD_INT 1
34578: ARRAY
34579: PPUSH
34580: LD_STRING D19-Sol1-1
34582: PPUSH
34583: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
34587: LD_EXP 40
34591: PPUSH
34592: LD_STRING D19-JMM-2
34594: PPUSH
34595: CALL_OW 88
// DialogueOff ;
34599: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
34603: LD_VAR 0 2
34607: PUSH
34608: LD_INT 1
34610: ARRAY
34611: PPUSH
34612: LD_VAR 0 2
34616: PUSH
34617: LD_INT 2
34619: ARRAY
34620: PPUSH
34621: LD_INT 1
34623: PPUSH
34624: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
34628: LD_STRING M5
34630: PPUSH
34631: CALL_OW 337
// omarOnMotherLode := false ;
34635: LD_ADDR_VAR 0 4
34639: PUSH
34640: LD_INT 0
34642: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
34643: LD_INT 35
34645: PPUSH
34646: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
34650: LD_EXP 97
34654: PPUSH
34655: LD_INT 215
34657: PPUSH
34658: LD_INT 100
34660: PPUSH
34661: CALL_OW 297
34665: PUSH
34666: LD_INT 10
34668: LESS
34669: PUSH
34670: LD_VAR 0 4
34674: NOT
34675: AND
34676: IFFALSE 34710
// begin omarOnMotherLode := true ;
34678: LD_ADDR_VAR 0 4
34682: PUSH
34683: LD_INT 1
34685: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
34686: LD_EXP 40
34690: PPUSH
34691: LD_STRING D19b-JMM-1
34693: PPUSH
34694: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
34698: LD_EXP 97
34702: PPUSH
34703: LD_STRING DOmarContam-Omar-1
34705: PPUSH
34706: CALL_OW 88
// end ; until IsDead ( Omar ) ;
34710: LD_EXP 97
34714: PPUSH
34715: CALL_OW 301
34719: IFFALSE 34643
// Say ( JMM , D19a-JMM-1 ) ;
34721: LD_EXP 40
34725: PPUSH
34726: LD_STRING D19a-JMM-1
34728: PPUSH
34729: CALL_OW 88
// if Heike then
34733: LD_EXP 98
34737: IFFALSE 34751
// Say ( Heike , D19a-Hke-1 ) ;
34739: LD_EXP 98
34743: PPUSH
34744: LD_STRING D19a-Hke-1
34746: PPUSH
34747: CALL_OW 88
// end ;
34751: PPOPN 4
34753: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
34754: LD_INT 22
34756: PUSH
34757: LD_INT 3
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PUSH
34764: LD_INT 21
34766: PUSH
34767: LD_INT 1
34769: PUSH
34770: EMPTY
34771: LIST
34772: LIST
34773: PUSH
34774: EMPTY
34775: LIST
34776: LIST
34777: PPUSH
34778: CALL_OW 69
34782: PUSH
34783: LD_EXP 21
34787: AND
34788: IFFALSE 34856
34790: GO 34792
34792: DISABLE
34793: LD_INT 0
34795: PPUSH
34796: PPUSH
// begin enable ;
34797: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
34798: LD_ADDR_VAR 0 2
34802: PUSH
34803: LD_INT 25
34805: PPUSH
34806: LD_INT 22
34808: PUSH
34809: LD_INT 3
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PPUSH
34816: CALL_OW 70
34820: ST_TO_ADDR
// if not tmp then
34821: LD_VAR 0 2
34825: NOT
34826: IFFALSE 34830
// exit ;
34828: GO 34856
// for i in tmp do
34830: LD_ADDR_VAR 0 1
34834: PUSH
34835: LD_VAR 0 2
34839: PUSH
34840: FOR_IN
34841: IFFALSE 34854
// RemoveUnit ( i ) ;
34843: LD_VAR 0 1
34847: PPUSH
34848: CALL_OW 64
34852: GO 34840
34854: POP
34855: POP
// end ;
34856: PPOPN 2
34858: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
34859: LD_INT 22
34861: PUSH
34862: LD_INT 7
34864: PUSH
34865: EMPTY
34866: LIST
34867: LIST
34868: PUSH
34869: LD_INT 21
34871: PUSH
34872: LD_INT 1
34874: PUSH
34875: EMPTY
34876: LIST
34877: LIST
34878: PUSH
34879: EMPTY
34880: LIST
34881: LIST
34882: PPUSH
34883: CALL_OW 69
34887: PUSH
34888: LD_INT 6
34890: LESS
34891: IFFALSE 35359
34893: GO 34895
34895: DISABLE
34896: LD_INT 0
34898: PPUSH
34899: PPUSH
// begin MC_Kill ( 1 ) ;
34900: LD_INT 1
34902: PPUSH
34903: CALL 39821 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
34907: LD_INT 7
34909: PPUSH
34910: LD_INT 1
34912: PPUSH
34913: LD_INT 1
34915: PPUSH
34916: LD_INT 1
34918: PPUSH
34919: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
34923: LD_ADDR_VAR 0 1
34927: PUSH
34928: LD_INT 22
34930: PUSH
34931: LD_INT 7
34933: PUSH
34934: EMPTY
34935: LIST
34936: LIST
34937: PUSH
34938: LD_INT 26
34940: PUSH
34941: LD_INT 1
34943: PUSH
34944: EMPTY
34945: LIST
34946: LIST
34947: PUSH
34948: EMPTY
34949: LIST
34950: LIST
34951: PPUSH
34952: CALL_OW 69
34956: PUSH
34957: LD_EXP 79
34961: DIFF
34962: ST_TO_ADDR
// if tmp then
34963: LD_VAR 0 1
34967: IFFALSE 34985
// tmp := tmp [ 1 ] else
34969: LD_ADDR_VAR 0 1
34973: PUSH
34974: LD_VAR 0 1
34978: PUSH
34979: LD_INT 1
34981: ARRAY
34982: ST_TO_ADDR
34983: GO 35021
// begin uc_side := 7 ;
34985: LD_ADDR_OWVAR 20
34989: PUSH
34990: LD_INT 7
34992: ST_TO_ADDR
// uc_nation := 1 ;
34993: LD_ADDR_OWVAR 21
34997: PUSH
34998: LD_INT 1
35000: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
35001: LD_INT 1
35003: PPUSH
35004: LD_INT 8
35006: PPUSH
35007: CALL_OW 384
// tmp := CreateHuman ;
35011: LD_ADDR_VAR 0 1
35015: PUSH
35016: CALL_OW 44
35020: ST_TO_ADDR
// end ; DialogueOn ;
35021: CALL_OW 6
// if IsOK ( Roth ) then
35025: LD_EXP 79
35029: PPUSH
35030: CALL_OW 302
35034: IFFALSE 35048
// Say ( JMM , DAb-JMM-1 ) ;
35036: LD_EXP 40
35040: PPUSH
35041: LD_STRING DAb-JMM-1
35043: PPUSH
35044: CALL_OW 88
// if IsOK ( Roth ) then
35048: LD_EXP 79
35052: PPUSH
35053: CALL_OW 302
35057: IFFALSE 35081
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
35059: LD_EXP 79
35063: PPUSH
35064: LD_STRING DSurrenderAlliance-Roth-1
35066: PPUSH
35067: CALL_OW 88
// RothCaptured := true ;
35071: LD_ADDR_EXP 33
35075: PUSH
35076: LD_INT 1
35078: ST_TO_ADDR
// end else
35079: GO 35093
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
35081: LD_VAR 0 1
35085: PPUSH
35086: LD_STRING DSurrenderAlliance-Sci1-1
35088: PPUSH
35089: CALL_OW 88
// DialogueOff ;
35093: CALL_OW 7
// allianceDestroyed := true ;
35097: LD_ADDR_EXP 23
35101: PUSH
35102: LD_INT 1
35104: ST_TO_ADDR
// if capturedUnit = 0 then
35105: LD_EXP 34
35109: PUSH
35110: LD_INT 0
35112: EQUAL
35113: IFFALSE 35122
// SetAchievement ( ACH_ALLIANCE ) ;
35115: LD_STRING ACH_ALLIANCE
35117: PPUSH
35118: CALL_OW 543
// if trueAmericans then
35122: LD_EXP 35
35126: IFFALSE 35202
// begin if trueAmericans = 1 then
35128: LD_EXP 35
35132: PUSH
35133: LD_INT 1
35135: EQUAL
35136: IFFALSE 35152
// Say ( JMM , DAb-JMM-1a ) else
35138: LD_EXP 40
35142: PPUSH
35143: LD_STRING DAb-JMM-1a
35145: PPUSH
35146: CALL_OW 88
35150: GO 35164
// Say ( JMM , DAb-JMM-1b ) ;
35152: LD_EXP 40
35156: PPUSH
35157: LD_STRING DAb-JMM-1b
35159: PPUSH
35160: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
35164: LD_EXP 35
35168: PPUSH
35169: CALL_OW 87
// for i in trueAmericans do
35173: LD_ADDR_VAR 0 2
35177: PUSH
35178: LD_EXP 35
35182: PUSH
35183: FOR_IN
35184: IFFALSE 35200
// SetSide ( i , 1 ) ;
35186: LD_VAR 0 2
35190: PPUSH
35191: LD_INT 1
35193: PPUSH
35194: CALL_OW 235
35198: GO 35183
35200: POP
35201: POP
// end ; repeat wait ( 0 0$1 ) ;
35202: LD_INT 35
35204: PPUSH
35205: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
35209: LD_ADDR_VAR 0 2
35213: PUSH
35214: LD_INT 22
35216: PUSH
35217: LD_INT 7
35219: PUSH
35220: EMPTY
35221: LIST
35222: LIST
35223: PUSH
35224: LD_INT 21
35226: PUSH
35227: LD_INT 1
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: PUSH
35234: EMPTY
35235: LIST
35236: LIST
35237: PPUSH
35238: CALL_OW 69
35242: PUSH
35243: FOR_IN
35244: IFFALSE 35326
// begin if IsInUnit ( i ) then
35246: LD_VAR 0 2
35250: PPUSH
35251: CALL_OW 310
35255: IFFALSE 35266
// ComExitBuilding ( i ) ;
35257: LD_VAR 0 2
35261: PPUSH
35262: CALL_OW 122
// if IsDriver ( i ) then
35266: LD_VAR 0 2
35270: PPUSH
35271: CALL 105567 0 1
35275: IFFALSE 35286
// ComExitVehicle ( i ) ;
35277: LD_VAR 0 2
35281: PPUSH
35282: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
35286: LD_VAR 0 2
35290: PPUSH
35291: LD_INT 26
35293: PPUSH
35294: CALL_OW 308
35298: NOT
35299: IFFALSE 35315
// AddComMoveToArea ( i , allianceEscapeArea ) else
35301: LD_VAR 0 2
35305: PPUSH
35306: LD_INT 26
35308: PPUSH
35309: CALL_OW 173
35313: GO 35324
// RemoveUnit ( i ) ;
35315: LD_VAR 0 2
35319: PPUSH
35320: CALL_OW 64
// end ;
35324: GO 35243
35326: POP
35327: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
35328: LD_INT 22
35330: PUSH
35331: LD_INT 7
35333: PUSH
35334: EMPTY
35335: LIST
35336: LIST
35337: PUSH
35338: LD_INT 21
35340: PUSH
35341: LD_INT 1
35343: PUSH
35344: EMPTY
35345: LIST
35346: LIST
35347: PUSH
35348: EMPTY
35349: LIST
35350: LIST
35351: PPUSH
35352: CALL_OW 69
35356: NOT
35357: IFFALSE 35202
// end ;
35359: PPOPN 2
35361: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
35362: LD_INT 0
35364: PPUSH
35365: PPUSH
// if not unit then
35366: LD_VAR 0 1
35370: NOT
35371: IFFALSE 35375
// exit ;
35373: GO 36889
// DoNotAttack ( 7 , unit ) ;
35375: LD_INT 7
35377: PPUSH
35378: LD_VAR 0 1
35382: PPUSH
35383: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
35387: LD_VAR 0 1
35391: PPUSH
35392: LD_INT 260
35394: PPUSH
35395: LD_INT 235
35397: PPUSH
35398: LD_INT 3
35400: PPUSH
35401: LD_INT 1
35403: PPUSH
35404: CALL_OW 483
// SetSide ( unit , 4 ) ;
35408: LD_VAR 0 1
35412: PPUSH
35413: LD_INT 4
35415: PPUSH
35416: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
35420: LD_ADDR_EXP 34
35424: PUSH
35425: LD_EXP 34
35429: PUSH
35430: LD_INT 1
35432: PLUS
35433: ST_TO_ADDR
// wait ( 0 0$2 ) ;
35434: LD_INT 70
35436: PPUSH
35437: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
35441: LD_INT 260
35443: PPUSH
35444: LD_INT 235
35446: PPUSH
35447: LD_INT 1
35449: PPUSH
35450: LD_INT 8
35452: NEG
35453: PPUSH
35454: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
35458: LD_VAR 0 1
35462: PPUSH
35463: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
35467: LD_VAR 0 1
35471: PPUSH
35472: LD_EXP 79
35476: PPUSH
35477: CALL_OW 119
// DialogueOn ;
35481: CALL_OW 6
// case unit of JMM :
35485: LD_VAR 0 1
35489: PUSH
35490: LD_EXP 40
35494: DOUBLE
35495: EQUAL
35496: IFTRUE 35500
35498: GO 35515
35500: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
35501: LD_EXP 40
35505: PPUSH
35506: LD_STRING DA1-JMM-1
35508: PPUSH
35509: CALL_OW 91
35513: GO 35957
35515: LD_EXP 41
35519: DOUBLE
35520: EQUAL
35521: IFTRUE 35525
35523: GO 35540
35525: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
35526: LD_EXP 41
35530: PPUSH
35531: LD_STRING DA1-Joan-1
35533: PPUSH
35534: CALL_OW 91
35538: GO 35957
35540: LD_EXP 43
35544: DOUBLE
35545: EQUAL
35546: IFTRUE 35550
35548: GO 35565
35550: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
35551: LD_EXP 43
35555: PPUSH
35556: LD_STRING DA1-Lisa-1
35558: PPUSH
35559: CALL_OW 91
35563: GO 35957
35565: LD_EXP 44
35569: DOUBLE
35570: EQUAL
35571: IFTRUE 35575
35573: GO 35590
35575: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
35576: LD_EXP 44
35580: PPUSH
35581: LD_STRING DA1-Don-1
35583: PPUSH
35584: CALL_OW 91
35588: GO 35957
35590: LD_EXP 51
35594: DOUBLE
35595: EQUAL
35596: IFTRUE 35600
35598: GO 35615
35600: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
35601: LD_EXP 51
35605: PPUSH
35606: LD_STRING DA1-Corn-1
35608: PPUSH
35609: CALL_OW 91
35613: GO 35957
35615: LD_EXP 47
35619: DOUBLE
35620: EQUAL
35621: IFTRUE 35625
35623: GO 35640
35625: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
35626: LD_EXP 47
35630: PPUSH
35631: LD_STRING DA1-Den-1
35633: PPUSH
35634: CALL_OW 91
35638: GO 35957
35640: LD_EXP 45
35644: DOUBLE
35645: EQUAL
35646: IFTRUE 35650
35648: GO 35665
35650: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
35651: LD_EXP 45
35655: PPUSH
35656: LD_STRING DA1-Bobby-1
35658: PPUSH
35659: CALL_OW 91
35663: GO 35957
35665: LD_EXP 49
35669: DOUBLE
35670: EQUAL
35671: IFTRUE 35675
35673: GO 35690
35675: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
35676: LD_EXP 49
35680: PPUSH
35681: LD_STRING DA1-Glad-1
35683: PPUSH
35684: CALL_OW 91
35688: GO 35957
35690: LD_EXP 46
35694: DOUBLE
35695: EQUAL
35696: IFTRUE 35700
35698: GO 35715
35700: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
35701: LD_EXP 46
35705: PPUSH
35706: LD_STRING DA1-Cyrus-1
35708: PPUSH
35709: CALL_OW 91
35713: GO 35957
35715: LD_EXP 42
35719: DOUBLE
35720: EQUAL
35721: IFTRUE 35725
35723: GO 35740
35725: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
35726: LD_EXP 42
35730: PPUSH
35731: LD_STRING DA1-Huck-1
35733: PPUSH
35734: CALL_OW 91
35738: GO 35957
35740: LD_EXP 56
35744: DOUBLE
35745: EQUAL
35746: IFTRUE 35750
35748: GO 35765
35750: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
35751: LD_EXP 56
35755: PPUSH
35756: LD_STRING DA1-Huck-1
35758: PPUSH
35759: CALL_OW 91
35763: GO 35957
35765: LD_EXP 48
35769: DOUBLE
35770: EQUAL
35771: IFTRUE 35775
35773: GO 35790
35775: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
35776: LD_EXP 48
35780: PPUSH
35781: LD_STRING DA1-Brown-1
35783: PPUSH
35784: CALL_OW 91
35788: GO 35957
35790: LD_EXP 52
35794: DOUBLE
35795: EQUAL
35796: IFTRUE 35800
35798: GO 35815
35800: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
35801: LD_EXP 52
35805: PPUSH
35806: LD_STRING DA1-Gary-1
35808: PPUSH
35809: CALL_OW 91
35813: GO 35957
35815: LD_EXP 55
35819: DOUBLE
35820: EQUAL
35821: IFTRUE 35825
35823: GO 35840
35825: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
35826: LD_EXP 55
35830: PPUSH
35831: LD_STRING DA1-Con-1
35833: PPUSH
35834: CALL_OW 91
35838: GO 35957
35840: LD_EXP 64
35844: DOUBLE
35845: EQUAL
35846: IFTRUE 35850
35848: GO 35865
35850: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
35851: LD_EXP 64
35855: PPUSH
35856: LD_STRING DA1-Kurt-1
35858: PPUSH
35859: CALL_OW 91
35863: GO 35957
35865: LD_EXP 54
35869: DOUBLE
35870: EQUAL
35871: IFTRUE 35875
35873: GO 35890
35875: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
35876: LD_EXP 54
35880: PPUSH
35881: LD_STRING DA1-Yam-1
35883: PPUSH
35884: CALL_OW 91
35888: GO 35957
35890: LD_EXP 53
35894: DOUBLE
35895: EQUAL
35896: IFTRUE 35900
35898: GO 35915
35900: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
35901: LD_EXP 53
35905: PPUSH
35906: LD_STRING DA1-Frank-1
35908: PPUSH
35909: CALL_OW 91
35913: GO 35957
35915: POP
// begin if GetSex ( unit ) = sex_male then
35916: LD_VAR 0 1
35920: PPUSH
35921: CALL_OW 258
35925: PUSH
35926: LD_INT 1
35928: EQUAL
35929: IFFALSE 35945
// ForceSay ( unit , DA1-Sol1-1 ) else
35931: LD_VAR 0 1
35935: PPUSH
35936: LD_STRING DA1-Sol1-1
35938: PPUSH
35939: CALL_OW 91
35943: GO 35957
// ForceSay ( unit , DA1-FSol1-1 ) ;
35945: LD_VAR 0 1
35949: PPUSH
35950: LD_STRING DA1-FSol1-1
35952: PPUSH
35953: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
35957: LD_EXP 79
35961: PPUSH
35962: LD_STRING DA-Roth-1
35964: PPUSH
35965: CALL_OW 88
// if capturedUnit = 1 then
35969: LD_EXP 34
35973: PUSH
35974: LD_INT 1
35976: EQUAL
35977: IFFALSE 36005
// begin Say ( Simms , DA-Sim-1 ) ;
35979: LD_EXP 80
35983: PPUSH
35984: LD_STRING DA-Sim-1
35986: PPUSH
35987: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
35991: LD_EXP 79
35995: PPUSH
35996: LD_STRING DA-Roth-2
35998: PPUSH
35999: CALL_OW 88
// end else
36003: GO 36017
// Say ( Simms , DA-Sim-2 ) ;
36005: LD_EXP 80
36009: PPUSH
36010: LD_STRING DA-Sim-2
36012: PPUSH
36013: CALL_OW 88
// case unit of JMM :
36017: LD_VAR 0 1
36021: PUSH
36022: LD_EXP 40
36026: DOUBLE
36027: EQUAL
36028: IFTRUE 36032
36030: GO 36047
36032: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
36033: LD_EXP 40
36037: PPUSH
36038: LD_STRING DA1-JMM-1a
36040: PPUSH
36041: CALL_OW 91
36045: GO 36564
36047: LD_EXP 41
36051: DOUBLE
36052: EQUAL
36053: IFTRUE 36057
36055: GO 36072
36057: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
36058: LD_EXP 41
36062: PPUSH
36063: LD_STRING DA1-Joan-1a
36065: PPUSH
36066: CALL_OW 91
36070: GO 36564
36072: LD_EXP 43
36076: DOUBLE
36077: EQUAL
36078: IFTRUE 36082
36080: GO 36097
36082: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
36083: LD_EXP 43
36087: PPUSH
36088: LD_STRING DA1-Lisa-1a
36090: PPUSH
36091: CALL_OW 91
36095: GO 36564
36097: LD_EXP 44
36101: DOUBLE
36102: EQUAL
36103: IFTRUE 36107
36105: GO 36122
36107: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
36108: LD_EXP 44
36112: PPUSH
36113: LD_STRING DA1-Don-1a
36115: PPUSH
36116: CALL_OW 91
36120: GO 36564
36122: LD_EXP 51
36126: DOUBLE
36127: EQUAL
36128: IFTRUE 36132
36130: GO 36147
36132: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
36133: LD_EXP 51
36137: PPUSH
36138: LD_STRING DA1-Corn-1a
36140: PPUSH
36141: CALL_OW 91
36145: GO 36564
36147: LD_EXP 47
36151: DOUBLE
36152: EQUAL
36153: IFTRUE 36157
36155: GO 36172
36157: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
36158: LD_EXP 47
36162: PPUSH
36163: LD_STRING DA1-Den-1a
36165: PPUSH
36166: CALL_OW 91
36170: GO 36564
36172: LD_EXP 45
36176: DOUBLE
36177: EQUAL
36178: IFTRUE 36182
36180: GO 36197
36182: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
36183: LD_EXP 45
36187: PPUSH
36188: LD_STRING DA1-Bobby-1a
36190: PPUSH
36191: CALL_OW 91
36195: GO 36564
36197: LD_EXP 49
36201: DOUBLE
36202: EQUAL
36203: IFTRUE 36207
36205: GO 36222
36207: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
36208: LD_EXP 49
36212: PPUSH
36213: LD_STRING DA1-Glad-1a
36215: PPUSH
36216: CALL_OW 91
36220: GO 36564
36222: LD_EXP 46
36226: DOUBLE
36227: EQUAL
36228: IFTRUE 36232
36230: GO 36247
36232: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
36233: LD_EXP 46
36237: PPUSH
36238: LD_STRING DA1-Cyrus-1a
36240: PPUSH
36241: CALL_OW 91
36245: GO 36564
36247: LD_EXP 42
36251: DOUBLE
36252: EQUAL
36253: IFTRUE 36257
36255: GO 36272
36257: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
36258: LD_EXP 42
36262: PPUSH
36263: LD_STRING DA1-Huck-1a
36265: PPUSH
36266: CALL_OW 91
36270: GO 36564
36272: LD_EXP 56
36276: DOUBLE
36277: EQUAL
36278: IFTRUE 36282
36280: GO 36297
36282: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
36283: LD_EXP 56
36287: PPUSH
36288: LD_STRING DA1-Huck-1a
36290: PPUSH
36291: CALL_OW 91
36295: GO 36564
36297: LD_EXP 48
36301: DOUBLE
36302: EQUAL
36303: IFTRUE 36307
36305: GO 36322
36307: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
36308: LD_EXP 48
36312: PPUSH
36313: LD_STRING DA1-Brown-1a
36315: PPUSH
36316: CALL_OW 91
36320: GO 36564
36322: LD_EXP 52
36326: DOUBLE
36327: EQUAL
36328: IFTRUE 36332
36330: GO 36347
36332: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
36333: LD_EXP 52
36337: PPUSH
36338: LD_STRING DA1-Gary-1a
36340: PPUSH
36341: CALL_OW 91
36345: GO 36564
36347: LD_EXP 55
36351: DOUBLE
36352: EQUAL
36353: IFTRUE 36357
36355: GO 36382
36357: POP
// if JMMGirl = 3 then
36358: LD_EXP 7
36362: PUSH
36363: LD_INT 3
36365: EQUAL
36366: IFFALSE 36380
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
36368: LD_EXP 55
36372: PPUSH
36373: LD_STRING DA1-Con-1a
36375: PPUSH
36376: CALL_OW 91
36380: GO 36564
36382: LD_EXP 64
36386: DOUBLE
36387: EQUAL
36388: IFTRUE 36392
36390: GO 36407
36392: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
36393: LD_EXP 64
36397: PPUSH
36398: LD_STRING DA1-Kurt-1a
36400: PPUSH
36401: CALL_OW 91
36405: GO 36564
36407: LD_EXP 54
36411: DOUBLE
36412: EQUAL
36413: IFTRUE 36417
36415: GO 36432
36417: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
36418: LD_EXP 54
36422: PPUSH
36423: LD_STRING DA1-Yam-1a
36425: PPUSH
36426: CALL_OW 91
36430: GO 36564
36432: LD_EXP 53
36436: DOUBLE
36437: EQUAL
36438: IFTRUE 36442
36440: GO 36457
36442: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
36443: LD_EXP 53
36447: PPUSH
36448: LD_STRING DA1-Frank-1a
36450: PPUSH
36451: CALL_OW 91
36455: GO 36564
36457: POP
// begin join := rand ( 0 , 1 ) ;
36458: LD_ADDR_VAR 0 3
36462: PUSH
36463: LD_INT 0
36465: PPUSH
36466: LD_INT 1
36468: PPUSH
36469: CALL_OW 12
36473: ST_TO_ADDR
// if join then
36474: LD_VAR 0 3
36478: IFFALSE 36523
// begin if GetSex ( unit ) = sex_male then
36480: LD_VAR 0 1
36484: PPUSH
36485: CALL_OW 258
36489: PUSH
36490: LD_INT 1
36492: EQUAL
36493: IFFALSE 36509
// ForceSay ( unit , DA1-Sol1-1b ) else
36495: LD_VAR 0 1
36499: PPUSH
36500: LD_STRING DA1-Sol1-1b
36502: PPUSH
36503: CALL_OW 91
36507: GO 36521
// ForceSay ( unit , DA1-FSol1-1b ) ;
36509: LD_VAR 0 1
36513: PPUSH
36514: LD_STRING DA1-FSol1-1b
36516: PPUSH
36517: CALL_OW 91
// end else
36521: GO 36564
// begin if GetSex ( unit ) = sex_male then
36523: LD_VAR 0 1
36527: PPUSH
36528: CALL_OW 258
36532: PUSH
36533: LD_INT 1
36535: EQUAL
36536: IFFALSE 36552
// ForceSay ( unit , DA1-Sol1-1a ) else
36538: LD_VAR 0 1
36542: PPUSH
36543: LD_STRING DA1-Sol1-1a
36545: PPUSH
36546: CALL_OW 91
36550: GO 36564
// ForceSay ( unit , DA1-FSol1-1a ) ;
36552: LD_VAR 0 1
36556: PPUSH
36557: LD_STRING DA1-FSol1-1a
36559: PPUSH
36560: CALL_OW 91
// end ; end ; end ; if unit = JMM then
36564: LD_VAR 0 1
36568: PUSH
36569: LD_EXP 40
36573: EQUAL
36574: IFFALSE 36585
// begin YouLost ( JMMCaptured ) ;
36576: LD_STRING JMMCaptured
36578: PPUSH
36579: CALL_OW 104
// exit ;
36583: GO 36889
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi , DeltaDoctor ] or join then
36585: LD_VAR 0 1
36589: PUSH
36590: LD_EXP 44
36594: PUSH
36595: LD_EXP 47
36599: PUSH
36600: LD_EXP 45
36604: PUSH
36605: LD_EXP 42
36609: PUSH
36610: LD_EXP 56
36614: PUSH
36615: LD_EXP 48
36619: PUSH
36620: LD_EXP 54
36624: PUSH
36625: LD_EXP 58
36629: PUSH
36630: EMPTY
36631: LIST
36632: LIST
36633: LIST
36634: LIST
36635: LIST
36636: LIST
36637: LIST
36638: LIST
36639: IN
36640: PUSH
36641: LD_VAR 0 3
36645: OR
36646: IFFALSE 36745
// begin Say ( Roth , DA-Roth-3 ) ;
36648: LD_EXP 79
36652: PPUSH
36653: LD_STRING DA-Roth-3
36655: PPUSH
36656: CALL_OW 88
// SetSide ( unit , 7 ) ;
36660: LD_VAR 0 1
36664: PPUSH
36665: LD_INT 7
36667: PPUSH
36668: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
36672: LD_ADDR_EXP 102
36676: PUSH
36677: LD_EXP 102
36681: PPUSH
36682: LD_INT 1
36684: PPUSH
36685: LD_EXP 102
36689: PUSH
36690: LD_INT 1
36692: ARRAY
36693: PUSH
36694: LD_VAR 0 1
36698: ADD
36699: PPUSH
36700: CALL_OW 1
36704: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
36705: LD_INT 260
36707: PPUSH
36708: LD_INT 235
36710: PPUSH
36711: LD_INT 1
36713: PPUSH
36714: CALL_OW 331
// SetLives ( unit , 1000 ) ;
36718: LD_VAR 0 1
36722: PPUSH
36723: LD_INT 1000
36725: PPUSH
36726: CALL_OW 234
// DialogueOff ;
36730: CALL_OW 7
// ComFree ( unit ) ;
36734: LD_VAR 0 1
36738: PPUSH
36739: CALL_OW 139
// end else
36743: GO 36826
// begin Say ( Roth , DA-Roth-3a ) ;
36745: LD_EXP 79
36749: PPUSH
36750: LD_STRING DA-Roth-3a
36752: PPUSH
36753: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
36757: LD_ADDR_EXP 35
36761: PUSH
36762: LD_EXP 35
36766: PUSH
36767: LD_VAR 0 1
36771: ADD
36772: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
36773: LD_INT 260
36775: PPUSH
36776: LD_INT 235
36778: PPUSH
36779: LD_INT 1
36781: PPUSH
36782: CALL_OW 331
// SetLives ( unit , 1000 ) ;
36786: LD_VAR 0 1
36790: PPUSH
36791: LD_INT 1000
36793: PPUSH
36794: CALL_OW 234
// DialogueOff ;
36798: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
36802: LD_VAR 0 1
36806: PPUSH
36807: LD_INT 272
36809: PPUSH
36810: LD_INT 254
36812: PPUSH
36813: CALL_OW 111
// AddComHold ( unit ) ;
36817: LD_VAR 0 1
36821: PPUSH
36822: CALL_OW 200
// end ; if capturedUnit = 1 then
36826: LD_EXP 34
36830: PUSH
36831: LD_INT 1
36833: EQUAL
36834: IFFALSE 36889
// begin DialogueOn ;
36836: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
36840: LD_EXP 40
36844: PPUSH
36845: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
36849: LD_EXP 40
36853: PPUSH
36854: LD_STRING DAa-JMM-1
36856: PPUSH
36857: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
36861: LD_EXP 40
36865: PPUSH
36866: LD_STRING DAa-JMM-1a
36868: PPUSH
36869: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
36873: LD_EXP 40
36877: PPUSH
36878: LD_STRING DAa-JMM-1b
36880: PPUSH
36881: CALL_OW 88
// DialogueOff ;
36885: CALL_OW 7
// end ; end ;
36889: LD_VAR 0 2
36893: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
36894: LD_EXP 15
36898: PUSH
36899: LD_INT 13
36901: GREATEREQUAL
36902: PUSH
36903: LD_INT 22
36905: PUSH
36906: LD_INT 2
36908: PUSH
36909: EMPTY
36910: LIST
36911: LIST
36912: PUSH
36913: LD_INT 21
36915: PUSH
36916: LD_INT 1
36918: PUSH
36919: EMPTY
36920: LIST
36921: LIST
36922: PUSH
36923: EMPTY
36924: LIST
36925: LIST
36926: PPUSH
36927: CALL_OW 69
36931: PUSH
36932: LD_INT 0
36934: EQUAL
36935: AND
36936: PUSH
36937: LD_INT 22
36939: PUSH
36940: LD_INT 2
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: PUSH
36947: LD_INT 33
36949: PUSH
36950: LD_INT 5
36952: PUSH
36953: EMPTY
36954: LIST
36955: LIST
36956: PUSH
36957: LD_INT 21
36959: PUSH
36960: LD_INT 2
36962: PUSH
36963: EMPTY
36964: LIST
36965: LIST
36966: PUSH
36967: LD_INT 50
36969: PUSH
36970: EMPTY
36971: LIST
36972: PUSH
36973: EMPTY
36974: LIST
36975: LIST
36976: LIST
36977: LIST
36978: PPUSH
36979: CALL_OW 69
36983: PUSH
36984: LD_INT 0
36986: EQUAL
36987: AND
36988: PUSH
36989: LD_EXP 21
36993: AND
36994: PUSH
36995: LD_EXP 22
36999: AND
37000: PUSH
37001: LD_EXP 23
37005: AND
37006: IFFALSE 37775
37008: GO 37010
37010: DISABLE
37011: LD_INT 0
37013: PPUSH
37014: PPUSH
37015: PPUSH
// begin wait ( 0 0$05 ) ;
37016: LD_INT 175
37018: PPUSH
37019: CALL_OW 67
// if Count ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 2 then
37023: LD_INT 22
37025: PUSH
37026: LD_INT 1
37028: PUSH
37029: EMPTY
37030: LIST
37031: LIST
37032: PUSH
37033: LD_INT 21
37035: PUSH
37036: LD_INT 1
37038: PUSH
37039: EMPTY
37040: LIST
37041: LIST
37042: PUSH
37043: LD_INT 23
37045: PUSH
37046: LD_INT 1
37048: PUSH
37049: EMPTY
37050: LIST
37051: LIST
37052: PUSH
37053: LD_INT 50
37055: PUSH
37056: EMPTY
37057: LIST
37058: PUSH
37059: EMPTY
37060: LIST
37061: LIST
37062: LIST
37063: LIST
37064: PPUSH
37065: CALL_OW 69
37069: PPUSH
37070: CALL 72374 0 1
37074: PUSH
37075: LD_INT 2
37077: LESS
37078: IFFALSE 37089
// begin YouLost ( LostVictory ) ;
37080: LD_STRING LostVictory
37082: PPUSH
37083: CALL_OW 104
// exit ;
37087: GO 37775
// end ; m1 := false ;
37089: LD_ADDR_VAR 0 1
37093: PUSH
37094: LD_INT 0
37096: ST_TO_ADDR
// m2 := false ;
37097: LD_ADDR_VAR 0 2
37101: PUSH
37102: LD_INT 0
37104: ST_TO_ADDR
// m3 := false ;
37105: LD_ADDR_VAR 0 3
37109: PUSH
37110: LD_INT 0
37112: ST_TO_ADDR
// if not bombExploded then
37113: LD_EXP 37
37117: NOT
37118: IFFALSE 37127
// SetAchievement ( ACH_SIBROCKET ) ;
37120: LD_STRING ACH_SIBROCKET
37122: PPUSH
37123: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
37127: LD_EXP 66
37131: PPUSH
37132: CALL_OW 255
37136: PUSH
37137: LD_INT 1
37139: EQUAL
37140: PUSH
37141: LD_EXP 66
37145: PPUSH
37146: CALL_OW 302
37150: AND
37151: IFFALSE 37167
// begin wait ( 3 ) ;
37153: LD_INT 3
37155: PPUSH
37156: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
37160: LD_STRING ACH_OPO
37162: PPUSH
37163: CALL_OW 543
// end ; if tick <= 120 120$00 then
37167: LD_OWVAR 1
37171: PUSH
37172: LD_INT 252000
37174: LESSEQUAL
37175: IFFALSE 37191
// begin wait ( 3 ) ;
37177: LD_INT 3
37179: PPUSH
37180: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
37184: LD_STRING ACH_ASPEED_15
37186: PPUSH
37187: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
37191: LD_EXP 40
37195: PPUSH
37196: CALL_OW 87
// music_class := 5 ;
37200: LD_ADDR_OWVAR 72
37204: PUSH
37205: LD_INT 5
37207: ST_TO_ADDR
// music_nat := 5 ;
37208: LD_ADDR_OWVAR 71
37212: PUSH
37213: LD_INT 5
37215: ST_TO_ADDR
// DialogueOn ;
37216: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
37220: LD_EXP 40
37224: PPUSH
37225: LD_STRING D20-JMM-1
37227: PPUSH
37228: CALL_OW 88
// if IsOK ( Joan ) then
37232: LD_EXP 41
37236: PPUSH
37237: CALL_OW 302
37241: IFFALSE 37255
// Say ( Joan , D20-Joan-1 ) ;
37243: LD_EXP 41
37247: PPUSH
37248: LD_STRING D20-Joan-1
37250: PPUSH
37251: CALL_OW 88
// if IsOk ( Lisa ) then
37255: LD_EXP 43
37259: PPUSH
37260: CALL_OW 302
37264: IFFALSE 37278
// Say ( Lisa , D20-Lisa-1 ) ;
37266: LD_EXP 43
37270: PPUSH
37271: LD_STRING D20-Lisa-1
37273: PPUSH
37274: CALL_OW 88
// if IsOk ( Donaldson ) then
37278: LD_EXP 44
37282: PPUSH
37283: CALL_OW 302
37287: IFFALSE 37301
// Say ( Donaldson , D20-Don-1 ) ;
37289: LD_EXP 44
37293: PPUSH
37294: LD_STRING D20-Don-1
37296: PPUSH
37297: CALL_OW 88
// if IsOK ( Cornel ) then
37301: LD_EXP 51
37305: PPUSH
37306: CALL_OW 302
37310: IFFALSE 37324
// Say ( Cornel , D20-Corn-1 ) ;
37312: LD_EXP 51
37316: PPUSH
37317: LD_STRING D20-Corn-1
37319: PPUSH
37320: CALL_OW 88
// if IsOk ( Denis ) then
37324: LD_EXP 47
37328: PPUSH
37329: CALL_OW 302
37333: IFFALSE 37347
// Say ( Denis , D20-Den-1 ) ;
37335: LD_EXP 47
37339: PPUSH
37340: LD_STRING D20-Den-1
37342: PPUSH
37343: CALL_OW 88
// if IsOk ( Bobby ) then
37347: LD_EXP 45
37351: PPUSH
37352: CALL_OW 302
37356: IFFALSE 37370
// Say ( Bobby , D20-Bobby-1 ) ;
37358: LD_EXP 45
37362: PPUSH
37363: LD_STRING D20-Bobby-1
37365: PPUSH
37366: CALL_OW 88
// if IsOk ( Gladstone ) then
37370: LD_EXP 49
37374: PPUSH
37375: CALL_OW 302
37379: IFFALSE 37393
// Say ( Gladstone , D20-Glad-1 ) ;
37381: LD_EXP 49
37385: PPUSH
37386: LD_STRING D20-Glad-1
37388: PPUSH
37389: CALL_OW 88
// if IsOk ( Cyrus ) then
37393: LD_EXP 46
37397: PPUSH
37398: CALL_OW 302
37402: IFFALSE 37416
// Say ( Cyrus , D20-Cyrus-1 ) ;
37404: LD_EXP 46
37408: PPUSH
37409: LD_STRING D20-Cyrus-1
37411: PPUSH
37412: CALL_OW 88
// if IsOk ( Stevens ) then
37416: LD_EXP 42
37420: PPUSH
37421: CALL_OW 302
37425: IFFALSE 37439
// Say ( Stevens , D20-Huck-1 ) ;
37427: LD_EXP 42
37431: PPUSH
37432: LD_STRING D20-Huck-1
37434: PPUSH
37435: CALL_OW 88
// if IsOk ( Brown ) then
37439: LD_EXP 48
37443: PPUSH
37444: CALL_OW 302
37448: IFFALSE 37462
// Say ( Brown , D20-Brown-1 ) ;
37450: LD_EXP 48
37454: PPUSH
37455: LD_STRING D20-Brown-1
37457: PPUSH
37458: CALL_OW 88
// if IsOk ( Gary ) then
37462: LD_EXP 52
37466: PPUSH
37467: CALL_OW 302
37471: IFFALSE 37485
// Say ( Gary , D20-Gary-1 ) ;
37473: LD_EXP 52
37477: PPUSH
37478: LD_STRING D20-Gary-1
37480: PPUSH
37481: CALL_OW 88
// if IsOk ( Connie ) then
37485: LD_EXP 55
37489: PPUSH
37490: CALL_OW 302
37494: IFFALSE 37508
// Say ( Connie , D20-Con-1 ) ;
37496: LD_EXP 55
37500: PPUSH
37501: LD_STRING D20-Con-1
37503: PPUSH
37504: CALL_OW 88
// if IsOk ( Kurt ) then
37508: LD_EXP 64
37512: PPUSH
37513: CALL_OW 302
37517: IFFALSE 37531
// Say ( Kurt , D20-Kurt-1 ) ;
37519: LD_EXP 64
37523: PPUSH
37524: LD_STRING D20-Kurt-1
37526: PPUSH
37527: CALL_OW 88
// if IsOk ( Kikuchi ) then
37531: LD_EXP 54
37535: PPUSH
37536: CALL_OW 302
37540: IFFALSE 37554
// Say ( Kikuchi , D20-Yam-1 ) ;
37542: LD_EXP 54
37546: PPUSH
37547: LD_STRING D20-Yam-1
37549: PPUSH
37550: CALL_OW 88
// if IsOk ( Frank ) then
37554: LD_EXP 53
37558: PPUSH
37559: CALL_OW 302
37563: IFFALSE 37577
// Say ( Frank , D20-Frank-1 ) ;
37565: LD_EXP 53
37569: PPUSH
37570: LD_STRING D20-Frank-1
37572: PPUSH
37573: CALL_OW 88
// DialogueOff ;
37577: CALL_OW 7
// if RothCaptured then
37581: LD_EXP 33
37585: IFFALSE 37607
// begin m1 := true ;
37587: LD_ADDR_VAR 0 1
37591: PUSH
37592: LD_INT 1
37594: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
37595: LD_STRING Roth
37597: PPUSH
37598: LD_INT 1
37600: PPUSH
37601: CALL_OW 101
// end else
37605: GO 37618
// AddMedal ( Roth , - 1 ) ;
37607: LD_STRING Roth
37609: PPUSH
37610: LD_INT 1
37612: NEG
37613: PPUSH
37614: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish or not behemothDone then
37618: LD_EXP 25
37622: NOT
37623: PUSH
37624: LD_EXP 27
37628: OR
37629: PUSH
37630: LD_EXP 28
37634: NOT
37635: OR
37636: IFFALSE 37658
// begin m2 := true ;
37638: LD_ADDR_VAR 0 2
37642: PUSH
37643: LD_INT 1
37645: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
37646: LD_STRING Project
37648: PPUSH
37649: LD_INT 1
37651: PPUSH
37652: CALL_OW 101
// end else
37656: GO 37669
// AddMedal ( Project , - 1 ) ;
37658: LD_STRING Project
37660: PPUSH
37661: LD_INT 1
37663: NEG
37664: PPUSH
37665: CALL_OW 101
// if lostCounter = 0 then
37669: LD_EXP 32
37673: PUSH
37674: LD_INT 0
37676: EQUAL
37677: IFFALSE 37699
// begin m3 := true ;
37679: LD_ADDR_VAR 0 3
37683: PUSH
37684: LD_INT 1
37686: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
37687: LD_STRING NoLosses
37689: PPUSH
37690: LD_INT 1
37692: PPUSH
37693: CALL_OW 101
// end else
37697: GO 37710
// AddMedal ( NoLosses , - 1 ) ;
37699: LD_STRING NoLosses
37701: PPUSH
37702: LD_INT 1
37704: NEG
37705: PPUSH
37706: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
37710: LD_VAR 0 1
37714: PUSH
37715: LD_VAR 0 2
37719: AND
37720: PUSH
37721: LD_VAR 0 3
37725: AND
37726: PUSH
37727: LD_OWVAR 67
37731: PUSH
37732: LD_INT 3
37734: GREATEREQUAL
37735: AND
37736: IFFALSE 37748
// SetAchievementEX ( ACH_AMER , 15 ) ;
37738: LD_STRING ACH_AMER
37740: PPUSH
37741: LD_INT 15
37743: PPUSH
37744: CALL_OW 564
// GiveMedals ( MAIN ) ;
37748: LD_STRING MAIN
37750: PPUSH
37751: CALL_OW 102
// music_class := 4 ;
37755: LD_ADDR_OWVAR 72
37759: PUSH
37760: LD_INT 4
37762: ST_TO_ADDR
// music_nat := 1 ;
37763: LD_ADDR_OWVAR 71
37767: PUSH
37768: LD_INT 1
37770: ST_TO_ADDR
// YouWin ;
37771: CALL_OW 103
// end ; end_of_file
37775: PPOPN 3
37777: END
// export function CustomEvent ( event ) ; begin
37778: LD_INT 0
37780: PPUSH
// end ;
37781: LD_VAR 0 2
37785: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
37786: LD_VAR 0 1
37790: PUSH
37791: LD_INT 1
37793: EQUAL
37794: PUSH
37795: LD_VAR 0 2
37799: PUSH
37800: LD_INT 4
37802: EQUAL
37803: AND
37804: PUSH
37805: LD_EXP 61
37809: PPUSH
37810: CALL_OW 300
37814: AND
37815: IFFALSE 37831
// begin wait ( 0 0$2 ) ;
37817: LD_INT 70
37819: PPUSH
37820: CALL_OW 67
// YouLost ( Dismissed ) ;
37824: LD_STRING Dismissed
37826: PPUSH
37827: CALL_OW 104
// end ; end ;
37831: PPOPN 2
37833: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
37834: LD_VAR 0 2
37838: PPUSH
37839: LD_VAR 0 3
37843: PPUSH
37844: LD_INT 18
37846: PPUSH
37847: CALL_OW 309
37851: IFFALSE 37860
// YouLost ( Motherlode3 ) ;
37853: LD_STRING Motherlode3
37855: PPUSH
37856: CALL_OW 104
// end ;
37860: PPOPN 3
37862: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
37863: LD_EXP 27
37867: NOT
37868: IFFALSE 37878
// behemothDone := true ;
37870: LD_ADDR_EXP 28
37874: PUSH
37875: LD_INT 1
37877: ST_TO_ADDR
// end ;
37878: PPOPN 1
37880: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
37881: LD_VAR 0 1
37885: PPUSH
37886: CALL_OW 255
37890: PUSH
37891: LD_INT 1
37893: EQUAL
37894: IFFALSE 37904
// bombExploded := true ;
37896: LD_ADDR_EXP 37
37900: PUSH
37901: LD_INT 1
37903: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
37904: LD_VAR 0 1
37908: PPUSH
37909: CALL_OW 255
37913: PUSH
37914: LD_INT 3
37916: EQUAL
37917: IFFALSE 37947
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
37919: LD_INT 2
37921: PPUSH
37922: LD_INT 23
37924: PUSH
37925: LD_INT 3
37927: PUSH
37928: LD_INT 3
37930: PUSH
37931: LD_INT 48
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: LIST
37938: LIST
37939: PUSH
37940: EMPTY
37941: LIST
37942: PPUSH
37943: CALL 63846 0 2
// if GetSide ( unit ) = 1 and GetSide ( Friend ) = 1 and IsOk ( Friend ) and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
37947: LD_VAR 0 1
37951: PPUSH
37952: CALL_OW 255
37956: PUSH
37957: LD_INT 1
37959: EQUAL
37960: PUSH
37961: LD_EXP 66
37965: PPUSH
37966: CALL_OW 255
37970: PUSH
37971: LD_INT 1
37973: EQUAL
37974: AND
37975: PUSH
37976: LD_EXP 66
37980: PPUSH
37981: CALL_OW 302
37985: AND
37986: PUSH
37987: LD_EXP 30
37991: AND
37992: PUSH
37993: LD_INT 22
37995: PUSH
37996: LD_INT 3
37998: PUSH
37999: EMPTY
38000: LIST
38001: LIST
38002: PUSH
38003: LD_INT 34
38005: PUSH
38006: LD_INT 48
38008: PUSH
38009: EMPTY
38010: LIST
38011: LIST
38012: PUSH
38013: EMPTY
38014: LIST
38015: LIST
38016: PPUSH
38017: CALL_OW 69
38021: AND
38022: PUSH
38023: LD_INT 22
38025: PUSH
38026: LD_INT 1
38028: PUSH
38029: EMPTY
38030: LIST
38031: LIST
38032: PUSH
38033: LD_INT 34
38035: PUSH
38036: LD_INT 8
38038: PUSH
38039: EMPTY
38040: LIST
38041: LIST
38042: PUSH
38043: EMPTY
38044: LIST
38045: LIST
38046: PPUSH
38047: CALL_OW 69
38051: NOT
38052: AND
38053: IFFALSE 38105
// begin wait ( 0 0$5 ) ;
38055: LD_INT 175
38057: PPUSH
38058: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
38062: LD_INT 22
38064: PUSH
38065: LD_INT 3
38067: PUSH
38068: EMPTY
38069: LIST
38070: LIST
38071: PUSH
38072: LD_INT 34
38074: PUSH
38075: LD_INT 48
38077: PUSH
38078: EMPTY
38079: LIST
38080: LIST
38081: PUSH
38082: EMPTY
38083: LIST
38084: LIST
38085: PPUSH
38086: CALL_OW 69
38090: PUSH
38091: LD_INT 1
38093: ARRAY
38094: PPUSH
38095: LD_INT 60
38097: PPUSH
38098: LD_INT 95
38100: PPUSH
38101: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
38105: LD_VAR 0 2
38109: PPUSH
38110: LD_VAR 0 3
38114: PPUSH
38115: LD_INT 18
38117: PPUSH
38118: CALL_OW 309
38122: PUSH
38123: LD_VAR 0 2
38127: PPUSH
38128: LD_VAR 0 3
38132: PPUSH
38133: LD_INT 18
38135: PPUSH
38136: CALL 111776 0 3
38140: OR
38141: IFFALSE 38188
// begin if GetSide ( unit ) = 1 then
38143: LD_VAR 0 1
38147: PPUSH
38148: CALL_OW 255
38152: PUSH
38153: LD_INT 1
38155: EQUAL
38156: IFFALSE 38174
// begin wait ( 0 0$6 ) ;
38158: LD_INT 210
38160: PPUSH
38161: CALL_OW 67
// YouLost ( Motherlode2 ) ;
38165: LD_STRING Motherlode2
38167: PPUSH
38168: CALL_OW 104
// end else
38172: GO 38188
// begin wait ( 0 0$6 ) ;
38174: LD_INT 210
38176: PPUSH
38177: CALL_OW 67
// YouLost ( Motherlode1 ) ;
38181: LD_STRING Motherlode1
38183: PPUSH
38184: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
38188: LD_VAR 0 1
38192: PPUSH
38193: CALL_OW 255
38197: PUSH
38198: LD_INT 3
38200: EQUAL
38201: IFFALSE 38222
// begin wait ( 0 0$5 ) ;
38203: LD_INT 175
38205: PPUSH
38206: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
38210: LD_EXP 68
38214: PPUSH
38215: LD_STRING D18-Pla-1
38217: PPUSH
38218: CALL_OW 94
// end ; end ;
38222: PPOPN 3
38224: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
38225: LD_VAR 0 1
38229: PPUSH
38230: CALL 128866 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
38234: LD_VAR 0 1
38238: PUSH
38239: LD_INT 22
38241: PUSH
38242: LD_INT 1
38244: PUSH
38245: EMPTY
38246: LIST
38247: LIST
38248: PUSH
38249: LD_INT 21
38251: PUSH
38252: LD_INT 1
38254: PUSH
38255: EMPTY
38256: LIST
38257: LIST
38258: PUSH
38259: LD_INT 23
38261: PUSH
38262: LD_INT 1
38264: PUSH
38265: EMPTY
38266: LIST
38267: LIST
38268: PUSH
38269: EMPTY
38270: LIST
38271: LIST
38272: LIST
38273: PPUSH
38274: CALL_OW 69
38278: IN
38279: IFFALSE 38295
// lostCounter := lostCounter + 1 ;
38281: LD_ADDR_EXP 32
38285: PUSH
38286: LD_EXP 32
38290: PUSH
38291: LD_INT 1
38293: PLUS
38294: ST_TO_ADDR
// if un in behemothBuilders then
38295: LD_VAR 0 1
38299: PUSH
38300: LD_EXP 77
38304: IN
38305: IFFALSE 38325
// begin behemothBuilders := behemothBuilders diff un ;
38307: LD_ADDR_EXP 77
38311: PUSH
38312: LD_EXP 77
38316: PUSH
38317: LD_VAR 0 1
38321: DIFF
38322: ST_TO_ADDR
// exit ;
38323: GO 38355
// end ; if un = JMM then
38325: LD_VAR 0 1
38329: PUSH
38330: LD_EXP 40
38334: EQUAL
38335: IFFALSE 38346
// begin YouLost ( JMM ) ;
38337: LD_STRING JMM
38339: PPUSH
38340: CALL_OW 104
// exit ;
38344: GO 38355
// end ; MCE_UnitDestroyed ( un ) ;
38346: LD_VAR 0 1
38350: PPUSH
38351: CALL 67288 0 1
// end ;
38355: PPOPN 1
38357: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
38358: LD_VAR 0 1
38362: PPUSH
38363: LD_VAR 0 2
38367: PPUSH
38368: CALL 69620 0 2
// end ;
38372: PPOPN 2
38374: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
38375: LD_VAR 0 1
38379: PPUSH
38380: CALL 68688 0 1
// end ;
38384: PPOPN 1
38386: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
38387: LD_VAR 0 1
38391: PUSH
38392: LD_INT 22
38394: PUSH
38395: LD_INT 8
38397: PUSH
38398: EMPTY
38399: LIST
38400: LIST
38401: PUSH
38402: LD_INT 30
38404: PUSH
38405: LD_INT 2
38407: PUSH
38408: EMPTY
38409: LIST
38410: LIST
38411: PUSH
38412: LD_INT 23
38414: PUSH
38415: LD_INT 3
38417: PUSH
38418: EMPTY
38419: LIST
38420: LIST
38421: PUSH
38422: EMPTY
38423: LIST
38424: LIST
38425: LIST
38426: PPUSH
38427: CALL_OW 69
38431: IN
38432: IFFALSE 38459
// begin ComUpgrade ( building ) ;
38434: LD_VAR 0 1
38438: PPUSH
38439: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
38443: LD_EXP 65
38447: PPUSH
38448: LD_VAR 0 1
38452: PPUSH
38453: CALL 78472 0 2
// exit ;
38457: GO 38468
// end ; MCE_BuildingComplete ( building ) ;
38459: LD_VAR 0 1
38463: PPUSH
38464: CALL 68929 0 1
// end ;
38468: PPOPN 1
38470: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
38471: LD_VAR 0 1
38475: PPUSH
38476: LD_VAR 0 2
38480: PPUSH
38481: CALL 66984 0 2
// end ;
38485: PPOPN 2
38487: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
38488: LD_VAR 0 1
38492: PPUSH
38493: LD_VAR 0 2
38497: PPUSH
38498: LD_VAR 0 3
38502: PPUSH
38503: LD_VAR 0 4
38507: PPUSH
38508: LD_VAR 0 5
38512: PPUSH
38513: CALL 66604 0 5
// end ;
38517: PPOPN 5
38519: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
38520: LD_VAR 0 1
38524: PPUSH
38525: CALL_OW 255
38529: PUSH
38530: LD_INT 1
38532: EQUAL
38533: IFFALSE 38550
// amConstructCounter := Inc ( amConstructCounter ) ;
38535: LD_ADDR_EXP 39
38539: PUSH
38540: LD_EXP 39
38544: PPUSH
38545: CALL 109324 0 1
38549: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
38550: LD_VAR 0 1
38554: PPUSH
38555: LD_VAR 0 2
38559: PPUSH
38560: CALL 128924 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
38564: LD_VAR 0 1
38568: PPUSH
38569: LD_VAR 0 2
38573: PPUSH
38574: CALL 66157 0 2
// end ;
38578: PPOPN 2
38580: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
38581: LD_VAR 0 1
38585: PPUSH
38586: LD_VAR 0 2
38590: PPUSH
38591: LD_VAR 0 3
38595: PPUSH
38596: LD_VAR 0 4
38600: PPUSH
38601: CALL 65995 0 4
// end ;
38605: PPOPN 4
38607: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
38608: LD_VAR 0 1
38612: PPUSH
38613: LD_VAR 0 2
38617: PPUSH
38618: LD_VAR 0 3
38622: PPUSH
38623: CALL 65770 0 3
// end ;
38627: PPOPN 3
38629: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
38630: LD_VAR 0 1
38634: PPUSH
38635: LD_VAR 0 2
38639: PPUSH
38640: CALL 65655 0 2
// end ;
38644: PPOPN 2
38646: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
38647: LD_VAR 0 1
38651: PPUSH
38652: LD_VAR 0 2
38656: PPUSH
38657: CALL 69915 0 2
// end ;
38661: PPOPN 2
38663: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
38664: LD_VAR 0 1
38668: PUSH
38669: LD_INT 460
38671: EQUAL
38672: IFFALSE 38694
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
38674: LD_VAR 0 2
38678: PPUSH
38679: LD_INT 227
38681: PPUSH
38682: LD_INT 136
38684: PPUSH
38685: CALL_OW 428
38689: PPUSH
38690: CALL_OW 120
// end ;
38694: PPOPN 2
38696: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
38697: LD_VAR 0 1
38701: PPUSH
38702: CALL_OW 255
38706: PUSH
38707: LD_INT 4
38709: EQUAL
38710: PUSH
38711: LD_VAR 0 1
38715: PUSH
38716: LD_EXP 18
38720: PUSH
38721: LD_INT 1
38723: ARRAY
38724: IN
38725: AND
38726: PUSH
38727: LD_EXP 19
38731: AND
38732: IFFALSE 38751
// begin ComMoveXY ( driver , 61 , 93 ) ;
38734: LD_VAR 0 1
38738: PPUSH
38739: LD_INT 61
38741: PPUSH
38742: LD_INT 93
38744: PPUSH
38745: CALL_OW 111
// exit ;
38749: GO 38820
// end ; if GetSide ( driver ) = 3 and GetTag ( driver ) = 105 then
38751: LD_VAR 0 1
38755: PPUSH
38756: CALL_OW 255
38760: PUSH
38761: LD_INT 3
38763: EQUAL
38764: PUSH
38765: LD_VAR 0 1
38769: PPUSH
38770: CALL_OW 110
38774: PUSH
38775: LD_INT 105
38777: EQUAL
38778: AND
38779: IFFALSE 38796
// begin ComMoveXY ( driver , 187 , 92 ) ;
38781: LD_VAR 0 1
38785: PPUSH
38786: LD_INT 187
38788: PPUSH
38789: LD_INT 92
38791: PPUSH
38792: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
38796: LD_VAR 0 1
38800: PPUSH
38801: LD_VAR 0 2
38805: PPUSH
38806: LD_VAR 0 3
38810: PPUSH
38811: LD_VAR 0 4
38815: PPUSH
38816: CALL 70131 0 4
// end ;
38820: PPOPN 4
38822: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
38823: LD_VAR 0 1
38827: PPUSH
38828: LD_VAR 0 2
38832: PPUSH
38833: CALL 65464 0 2
// end ;
38837: PPOPN 2
38839: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
38840: LD_VAR 0 1
38844: PPUSH
38845: CALL 128908 0 1
// end ; end_of_file
38849: PPOPN 1
38851: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
38852: LD_EXP 15
38856: PUSH
38857: LD_INT 2
38859: EQUAL
38860: IFFALSE 39377
38862: GO 38864
38864: DISABLE
38865: LD_INT 0
38867: PPUSH
38868: PPUSH
// begin time := 0 0$35 ;
38869: LD_ADDR_VAR 0 2
38873: PUSH
38874: LD_INT 1225
38876: ST_TO_ADDR
// repeat wait ( time ) ;
38877: LD_VAR 0 2
38881: PPUSH
38882: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
38886: LD_INT 1
38888: PPUSH
38889: LD_INT 5
38891: PPUSH
38892: CALL_OW 12
38896: PPUSH
38897: LD_INT 106
38899: PPUSH
38900: LD_INT 150
38902: PPUSH
38903: LD_INT 19
38905: PPUSH
38906: LD_INT 1
38908: PPUSH
38909: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
38913: LD_INT 455
38915: PPUSH
38916: LD_INT 770
38918: PPUSH
38919: CALL_OW 12
38923: PPUSH
38924: CALL_OW 67
// if Prob ( 50 ) then
38928: LD_INT 50
38930: PPUSH
38931: CALL_OW 13
38935: IFFALSE 38964
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
38937: LD_INT 1
38939: PPUSH
38940: LD_INT 5
38942: PPUSH
38943: CALL_OW 12
38947: PPUSH
38948: LD_INT 62
38950: PPUSH
38951: LD_INT 108
38953: PPUSH
38954: LD_INT 10
38956: PPUSH
38957: LD_INT 1
38959: PPUSH
38960: CALL_OW 56
// until missionStage > 4 ;
38964: LD_EXP 15
38968: PUSH
38969: LD_INT 4
38971: GREATER
38972: IFFALSE 38877
// repeat wait ( 0 0$1 ) ;
38974: LD_INT 35
38976: PPUSH
38977: CALL_OW 67
// until missionStage = 6 ;
38981: LD_EXP 15
38985: PUSH
38986: LD_INT 6
38988: EQUAL
38989: IFFALSE 38974
// time := 0 0$20 ;
38991: LD_ADDR_VAR 0 2
38995: PUSH
38996: LD_INT 700
38998: ST_TO_ADDR
// repeat wait ( time ) ;
38999: LD_VAR 0 2
39003: PPUSH
39004: CALL_OW 67
// if Prob ( 90 ) then
39008: LD_INT 90
39010: PPUSH
39011: CALL_OW 13
39015: IFFALSE 39058
// begin time := time + 0 0$2 ;
39017: LD_ADDR_VAR 0 2
39021: PUSH
39022: LD_VAR 0 2
39026: PUSH
39027: LD_INT 70
39029: PLUS
39030: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
39031: LD_INT 1
39033: PPUSH
39034: LD_INT 5
39036: PPUSH
39037: CALL_OW 12
39041: PPUSH
39042: LD_INT 106
39044: PPUSH
39045: LD_INT 89
39047: PPUSH
39048: LD_INT 45
39050: PPUSH
39051: LD_INT 1
39053: PPUSH
39054: CALL_OW 56
// end ; if Prob ( 45 ) then
39058: LD_INT 45
39060: PPUSH
39061: CALL_OW 13
39065: IFFALSE 39121
// begin for i := 1 to 4 do
39067: LD_ADDR_VAR 0 1
39071: PUSH
39072: DOUBLE
39073: LD_INT 1
39075: DEC
39076: ST_TO_ADDR
39077: LD_INT 4
39079: PUSH
39080: FOR_TO
39081: IFFALSE 39119
// begin wait ( 0 0$5 ) ;
39083: LD_INT 175
39085: PPUSH
39086: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
39090: LD_INT 1
39092: PPUSH
39093: LD_INT 5
39095: PPUSH
39096: CALL_OW 12
39100: PPUSH
39101: LD_INT 113
39103: PPUSH
39104: LD_INT 117
39106: PPUSH
39107: LD_INT 25
39109: PPUSH
39110: LD_INT 1
39112: PPUSH
39113: CALL_OW 56
// end ;
39117: GO 39080
39119: POP
39120: POP
// end ; if Prob ( 40 ) then
39121: LD_INT 40
39123: PPUSH
39124: CALL_OW 13
39128: IFFALSE 39174
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
39130: LD_INT 385
39132: PPUSH
39133: LD_INT 945
39135: PPUSH
39136: CALL_OW 12
39140: PPUSH
39141: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
39145: LD_INT 1
39147: PPUSH
39148: LD_INT 5
39150: PPUSH
39151: CALL_OW 12
39155: PPUSH
39156: LD_INT 21
39158: PPUSH
39159: LD_INT 26
39161: PPUSH
39162: LD_INT 12
39164: PPUSH
39165: LD_INT 1
39167: PPUSH
39168: CALL_OW 56
// end else
39172: GO 39210
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
39174: LD_INT 700
39176: PPUSH
39177: LD_INT 1225
39179: PPUSH
39180: CALL_OW 12
39184: PPUSH
39185: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
39189: LD_INT 1
39191: PPUSH
39192: LD_INT 5
39194: PPUSH
39195: CALL_OW 12
39199: PPUSH
39200: LD_INT 16
39202: PPUSH
39203: LD_INT 1
39205: PPUSH
39206: CALL_OW 55
// end ; if Prob ( 50 ) then
39210: LD_INT 50
39212: PPUSH
39213: CALL_OW 13
39217: IFFALSE 39263
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
39219: LD_INT 700
39221: PPUSH
39222: LD_INT 1050
39224: PPUSH
39225: CALL_OW 12
39229: PPUSH
39230: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
39234: LD_INT 1
39236: PPUSH
39237: LD_INT 5
39239: PPUSH
39240: CALL_OW 12
39244: PPUSH
39245: LD_INT 168
39247: PPUSH
39248: LD_INT 168
39250: PPUSH
39251: LD_INT 16
39253: PPUSH
39254: LD_INT 1
39256: PPUSH
39257: CALL_OW 56
// end else
39261: GO 39299
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
39263: LD_INT 350
39265: PPUSH
39266: LD_INT 525
39268: PPUSH
39269: CALL_OW 12
39273: PPUSH
39274: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
39278: LD_INT 1
39280: PPUSH
39281: LD_INT 5
39283: PPUSH
39284: CALL_OW 12
39288: PPUSH
39289: LD_INT 15
39291: PPUSH
39292: LD_INT 1
39294: PPUSH
39295: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
39299: LD_INT 175
39301: PPUSH
39302: LD_INT 315
39304: PPUSH
39305: CALL_OW 12
39309: PPUSH
39310: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
39314: LD_INT 1
39316: PPUSH
39317: LD_INT 5
39319: PPUSH
39320: CALL_OW 12
39324: PPUSH
39325: LD_INT 103
39327: PPUSH
39328: LD_INT 140
39330: PPUSH
39331: LD_INT 20
39333: PPUSH
39334: LD_INT 1
39336: PPUSH
39337: CALL_OW 56
// time := time + 0 0$2 ;
39341: LD_ADDR_VAR 0 2
39345: PUSH
39346: LD_VAR 0 2
39350: PUSH
39351: LD_INT 70
39353: PLUS
39354: ST_TO_ADDR
// if time > 1 1$20 then
39355: LD_VAR 0 2
39359: PUSH
39360: LD_INT 2800
39362: GREATER
39363: IFFALSE 39373
// time := 0 0$30 ;
39365: LD_ADDR_VAR 0 2
39369: PUSH
39370: LD_INT 1050
39372: ST_TO_ADDR
// until false ;
39373: LD_INT 0
39375: IFFALSE 38999
// end ; end_of_file
39377: PPOPN 2
39379: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
39380: LD_EXP 13
39384: PUSH
39385: LD_EXP 15
39389: PUSH
39390: LD_INT 6
39392: GREATEREQUAL
39393: AND
39394: IFFALSE 39431
39396: GO 39398
39398: DISABLE
// begin enable ;
39399: ENABLE
// missionTime := missionTime + 0 0$1 ;
39400: LD_ADDR_EXP 14
39404: PUSH
39405: LD_EXP 14
39409: PUSH
39410: LD_INT 35
39412: PLUS
39413: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
39414: LD_ADDR_OWVAR 47
39418: PUSH
39419: LD_STRING #Am15-1
39421: PUSH
39422: LD_EXP 14
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: ST_TO_ADDR
// end ; end_of_file
39431: END
// export function InitNature ; begin
39432: LD_INT 0
39434: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
39435: LD_INT 3
39437: PPUSH
39438: LD_INT 3
39440: PPUSH
39441: LD_INT 2
39443: PPUSH
39444: LD_INT 1
39446: PPUSH
39447: LD_INT 1
39449: PPUSH
39450: LD_INT 0
39452: PPUSH
39453: LD_INT 0
39455: PPUSH
39456: LD_INT 20
39458: PPUSH
39459: LD_INT 0
39461: PPUSH
39462: CALL 104640 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
39466: LD_INT 2
39468: PPUSH
39469: LD_INT 1
39471: PPUSH
39472: LD_INT 1
39474: PPUSH
39475: LD_INT 1
39477: PPUSH
39478: LD_INT 1
39480: PPUSH
39481: LD_INT 0
39483: PPUSH
39484: LD_INT 0
39486: PPUSH
39487: LD_INT 21
39489: PPUSH
39490: LD_INT 0
39492: PPUSH
39493: CALL 104640 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
39497: LD_INT 4
39499: PPUSH
39500: LD_INT 1
39502: PPUSH
39503: LD_INT 2
39505: PPUSH
39506: LD_INT 4
39508: PPUSH
39509: LD_INT 2
39511: PPUSH
39512: LD_INT 1
39514: PPUSH
39515: LD_INT 0
39517: PPUSH
39518: LD_INT 22
39520: PPUSH
39521: LD_INT 0
39523: PPUSH
39524: CALL 104640 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
39528: LD_INT 0
39530: PPUSH
39531: LD_INT 0
39533: PPUSH
39534: LD_INT 0
39536: PPUSH
39537: LD_INT 0
39539: PPUSH
39540: LD_INT 0
39542: PPUSH
39543: LD_INT 0
39545: PPUSH
39546: LD_INT 9
39548: PPUSH
39549: LD_INT 0
39551: PPUSH
39552: LD_INT 23
39554: PPUSH
39555: CALL 104640 0 9
// end ; end_of_file
39559: LD_VAR 0 1
39563: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
39564: LD_INT 0
39566: PPUSH
39567: PPUSH
// skirmish := false ;
39568: LD_ADDR_EXP 100
39572: PUSH
39573: LD_INT 0
39575: ST_TO_ADDR
// debug_mc := false ;
39576: LD_ADDR_EXP 101
39580: PUSH
39581: LD_INT 0
39583: ST_TO_ADDR
// mc_bases := [ ] ;
39584: LD_ADDR_EXP 102
39588: PUSH
39589: EMPTY
39590: ST_TO_ADDR
// mc_sides := [ ] ;
39591: LD_ADDR_EXP 128
39595: PUSH
39596: EMPTY
39597: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
39598: LD_ADDR_EXP 103
39602: PUSH
39603: EMPTY
39604: ST_TO_ADDR
// mc_building_repairs := [ ] ;
39605: LD_ADDR_EXP 104
39609: PUSH
39610: EMPTY
39611: ST_TO_ADDR
// mc_need_heal := [ ] ;
39612: LD_ADDR_EXP 105
39616: PUSH
39617: EMPTY
39618: ST_TO_ADDR
// mc_healers := [ ] ;
39619: LD_ADDR_EXP 106
39623: PUSH
39624: EMPTY
39625: ST_TO_ADDR
// mc_build_list := [ ] ;
39626: LD_ADDR_EXP 107
39630: PUSH
39631: EMPTY
39632: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
39633: LD_ADDR_EXP 134
39637: PUSH
39638: EMPTY
39639: ST_TO_ADDR
// mc_builders := [ ] ;
39640: LD_ADDR_EXP 108
39644: PUSH
39645: EMPTY
39646: ST_TO_ADDR
// mc_construct_list := [ ] ;
39647: LD_ADDR_EXP 109
39651: PUSH
39652: EMPTY
39653: ST_TO_ADDR
// mc_turret_list := [ ] ;
39654: LD_ADDR_EXP 110
39658: PUSH
39659: EMPTY
39660: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
39661: LD_ADDR_EXP 111
39665: PUSH
39666: EMPTY
39667: ST_TO_ADDR
// mc_miners := [ ] ;
39668: LD_ADDR_EXP 116
39672: PUSH
39673: EMPTY
39674: ST_TO_ADDR
// mc_mines := [ ] ;
39675: LD_ADDR_EXP 115
39679: PUSH
39680: EMPTY
39681: ST_TO_ADDR
// mc_minefields := [ ] ;
39682: LD_ADDR_EXP 117
39686: PUSH
39687: EMPTY
39688: ST_TO_ADDR
// mc_crates := [ ] ;
39689: LD_ADDR_EXP 118
39693: PUSH
39694: EMPTY
39695: ST_TO_ADDR
// mc_crates_collector := [ ] ;
39696: LD_ADDR_EXP 119
39700: PUSH
39701: EMPTY
39702: ST_TO_ADDR
// mc_crates_area := [ ] ;
39703: LD_ADDR_EXP 120
39707: PUSH
39708: EMPTY
39709: ST_TO_ADDR
// mc_vehicles := [ ] ;
39710: LD_ADDR_EXP 121
39714: PUSH
39715: EMPTY
39716: ST_TO_ADDR
// mc_attack := [ ] ;
39717: LD_ADDR_EXP 122
39721: PUSH
39722: EMPTY
39723: ST_TO_ADDR
// mc_produce := [ ] ;
39724: LD_ADDR_EXP 123
39728: PUSH
39729: EMPTY
39730: ST_TO_ADDR
// mc_defender := [ ] ;
39731: LD_ADDR_EXP 124
39735: PUSH
39736: EMPTY
39737: ST_TO_ADDR
// mc_parking := [ ] ;
39738: LD_ADDR_EXP 126
39742: PUSH
39743: EMPTY
39744: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
39745: LD_ADDR_EXP 112
39749: PUSH
39750: EMPTY
39751: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
39752: LD_ADDR_EXP 114
39756: PUSH
39757: EMPTY
39758: ST_TO_ADDR
// mc_scan := [ ] ;
39759: LD_ADDR_EXP 125
39763: PUSH
39764: EMPTY
39765: ST_TO_ADDR
// mc_scan_area := [ ] ;
39766: LD_ADDR_EXP 127
39770: PUSH
39771: EMPTY
39772: ST_TO_ADDR
// mc_tech := [ ] ;
39773: LD_ADDR_EXP 129
39777: PUSH
39778: EMPTY
39779: ST_TO_ADDR
// mc_class := [ ] ;
39780: LD_ADDR_EXP 143
39784: PUSH
39785: EMPTY
39786: ST_TO_ADDR
// mc_class_case_use := [ ] ;
39787: LD_ADDR_EXP 144
39791: PUSH
39792: EMPTY
39793: ST_TO_ADDR
// mc_is_defending := [ ] ;
39794: LD_ADDR_EXP 145
39798: PUSH
39799: EMPTY
39800: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
39801: LD_ADDR_EXP 136
39805: PUSH
39806: EMPTY
39807: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
39808: LD_ADDR_EXP 146
39812: PUSH
39813: LD_INT 0
39815: ST_TO_ADDR
// end ;
39816: LD_VAR 0 1
39820: RET
// export function MC_Kill ( base ) ; begin
39821: LD_INT 0
39823: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
39824: LD_ADDR_EXP 102
39828: PUSH
39829: LD_EXP 102
39833: PPUSH
39834: LD_VAR 0 1
39838: PPUSH
39839: EMPTY
39840: PPUSH
39841: CALL_OW 1
39845: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
39846: LD_ADDR_EXP 103
39850: PUSH
39851: LD_EXP 103
39855: PPUSH
39856: LD_VAR 0 1
39860: PPUSH
39861: EMPTY
39862: PPUSH
39863: CALL_OW 1
39867: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
39868: LD_ADDR_EXP 104
39872: PUSH
39873: LD_EXP 104
39877: PPUSH
39878: LD_VAR 0 1
39882: PPUSH
39883: EMPTY
39884: PPUSH
39885: CALL_OW 1
39889: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
39890: LD_ADDR_EXP 105
39894: PUSH
39895: LD_EXP 105
39899: PPUSH
39900: LD_VAR 0 1
39904: PPUSH
39905: EMPTY
39906: PPUSH
39907: CALL_OW 1
39911: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
39912: LD_ADDR_EXP 106
39916: PUSH
39917: LD_EXP 106
39921: PPUSH
39922: LD_VAR 0 1
39926: PPUSH
39927: EMPTY
39928: PPUSH
39929: CALL_OW 1
39933: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
39934: LD_ADDR_EXP 107
39938: PUSH
39939: LD_EXP 107
39943: PPUSH
39944: LD_VAR 0 1
39948: PPUSH
39949: EMPTY
39950: PPUSH
39951: CALL_OW 1
39955: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
39956: LD_ADDR_EXP 108
39960: PUSH
39961: LD_EXP 108
39965: PPUSH
39966: LD_VAR 0 1
39970: PPUSH
39971: EMPTY
39972: PPUSH
39973: CALL_OW 1
39977: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
39978: LD_ADDR_EXP 109
39982: PUSH
39983: LD_EXP 109
39987: PPUSH
39988: LD_VAR 0 1
39992: PPUSH
39993: EMPTY
39994: PPUSH
39995: CALL_OW 1
39999: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
40000: LD_ADDR_EXP 110
40004: PUSH
40005: LD_EXP 110
40009: PPUSH
40010: LD_VAR 0 1
40014: PPUSH
40015: EMPTY
40016: PPUSH
40017: CALL_OW 1
40021: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
40022: LD_ADDR_EXP 111
40026: PUSH
40027: LD_EXP 111
40031: PPUSH
40032: LD_VAR 0 1
40036: PPUSH
40037: EMPTY
40038: PPUSH
40039: CALL_OW 1
40043: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
40044: LD_ADDR_EXP 112
40048: PUSH
40049: LD_EXP 112
40053: PPUSH
40054: LD_VAR 0 1
40058: PPUSH
40059: EMPTY
40060: PPUSH
40061: CALL_OW 1
40065: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
40066: LD_ADDR_EXP 113
40070: PUSH
40071: LD_EXP 113
40075: PPUSH
40076: LD_VAR 0 1
40080: PPUSH
40081: LD_INT 0
40083: PPUSH
40084: CALL_OW 1
40088: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
40089: LD_ADDR_EXP 114
40093: PUSH
40094: LD_EXP 114
40098: PPUSH
40099: LD_VAR 0 1
40103: PPUSH
40104: EMPTY
40105: PPUSH
40106: CALL_OW 1
40110: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
40111: LD_ADDR_EXP 115
40115: PUSH
40116: LD_EXP 115
40120: PPUSH
40121: LD_VAR 0 1
40125: PPUSH
40126: EMPTY
40127: PPUSH
40128: CALL_OW 1
40132: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
40133: LD_ADDR_EXP 116
40137: PUSH
40138: LD_EXP 116
40142: PPUSH
40143: LD_VAR 0 1
40147: PPUSH
40148: EMPTY
40149: PPUSH
40150: CALL_OW 1
40154: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
40155: LD_ADDR_EXP 117
40159: PUSH
40160: LD_EXP 117
40164: PPUSH
40165: LD_VAR 0 1
40169: PPUSH
40170: EMPTY
40171: PPUSH
40172: CALL_OW 1
40176: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
40177: LD_ADDR_EXP 118
40181: PUSH
40182: LD_EXP 118
40186: PPUSH
40187: LD_VAR 0 1
40191: PPUSH
40192: EMPTY
40193: PPUSH
40194: CALL_OW 1
40198: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
40199: LD_ADDR_EXP 119
40203: PUSH
40204: LD_EXP 119
40208: PPUSH
40209: LD_VAR 0 1
40213: PPUSH
40214: EMPTY
40215: PPUSH
40216: CALL_OW 1
40220: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
40221: LD_ADDR_EXP 120
40225: PUSH
40226: LD_EXP 120
40230: PPUSH
40231: LD_VAR 0 1
40235: PPUSH
40236: EMPTY
40237: PPUSH
40238: CALL_OW 1
40242: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
40243: LD_ADDR_EXP 121
40247: PUSH
40248: LD_EXP 121
40252: PPUSH
40253: LD_VAR 0 1
40257: PPUSH
40258: EMPTY
40259: PPUSH
40260: CALL_OW 1
40264: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
40265: LD_ADDR_EXP 122
40269: PUSH
40270: LD_EXP 122
40274: PPUSH
40275: LD_VAR 0 1
40279: PPUSH
40280: EMPTY
40281: PPUSH
40282: CALL_OW 1
40286: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
40287: LD_ADDR_EXP 123
40291: PUSH
40292: LD_EXP 123
40296: PPUSH
40297: LD_VAR 0 1
40301: PPUSH
40302: EMPTY
40303: PPUSH
40304: CALL_OW 1
40308: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
40309: LD_ADDR_EXP 124
40313: PUSH
40314: LD_EXP 124
40318: PPUSH
40319: LD_VAR 0 1
40323: PPUSH
40324: EMPTY
40325: PPUSH
40326: CALL_OW 1
40330: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
40331: LD_ADDR_EXP 125
40335: PUSH
40336: LD_EXP 125
40340: PPUSH
40341: LD_VAR 0 1
40345: PPUSH
40346: EMPTY
40347: PPUSH
40348: CALL_OW 1
40352: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
40353: LD_ADDR_EXP 126
40357: PUSH
40358: LD_EXP 126
40362: PPUSH
40363: LD_VAR 0 1
40367: PPUSH
40368: EMPTY
40369: PPUSH
40370: CALL_OW 1
40374: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
40375: LD_ADDR_EXP 127
40379: PUSH
40380: LD_EXP 127
40384: PPUSH
40385: LD_VAR 0 1
40389: PPUSH
40390: EMPTY
40391: PPUSH
40392: CALL_OW 1
40396: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
40397: LD_ADDR_EXP 129
40401: PUSH
40402: LD_EXP 129
40406: PPUSH
40407: LD_VAR 0 1
40411: PPUSH
40412: EMPTY
40413: PPUSH
40414: CALL_OW 1
40418: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
40419: LD_ADDR_EXP 131
40423: PUSH
40424: LD_EXP 131
40428: PPUSH
40429: LD_VAR 0 1
40433: PPUSH
40434: EMPTY
40435: PPUSH
40436: CALL_OW 1
40440: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
40441: LD_ADDR_EXP 132
40445: PUSH
40446: LD_EXP 132
40450: PPUSH
40451: LD_VAR 0 1
40455: PPUSH
40456: EMPTY
40457: PPUSH
40458: CALL_OW 1
40462: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
40463: LD_ADDR_EXP 133
40467: PUSH
40468: LD_EXP 133
40472: PPUSH
40473: LD_VAR 0 1
40477: PPUSH
40478: EMPTY
40479: PPUSH
40480: CALL_OW 1
40484: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
40485: LD_ADDR_EXP 134
40489: PUSH
40490: LD_EXP 134
40494: PPUSH
40495: LD_VAR 0 1
40499: PPUSH
40500: EMPTY
40501: PPUSH
40502: CALL_OW 1
40506: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
40507: LD_ADDR_EXP 135
40511: PUSH
40512: LD_EXP 135
40516: PPUSH
40517: LD_VAR 0 1
40521: PPUSH
40522: EMPTY
40523: PPUSH
40524: CALL_OW 1
40528: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
40529: LD_ADDR_EXP 136
40533: PUSH
40534: LD_EXP 136
40538: PPUSH
40539: LD_VAR 0 1
40543: PPUSH
40544: EMPTY
40545: PPUSH
40546: CALL_OW 1
40550: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
40551: LD_ADDR_EXP 137
40555: PUSH
40556: LD_EXP 137
40560: PPUSH
40561: LD_VAR 0 1
40565: PPUSH
40566: EMPTY
40567: PPUSH
40568: CALL_OW 1
40572: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
40573: LD_ADDR_EXP 138
40577: PUSH
40578: LD_EXP 138
40582: PPUSH
40583: LD_VAR 0 1
40587: PPUSH
40588: EMPTY
40589: PPUSH
40590: CALL_OW 1
40594: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
40595: LD_ADDR_EXP 139
40599: PUSH
40600: LD_EXP 139
40604: PPUSH
40605: LD_VAR 0 1
40609: PPUSH
40610: EMPTY
40611: PPUSH
40612: CALL_OW 1
40616: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
40617: LD_ADDR_EXP 140
40621: PUSH
40622: LD_EXP 140
40626: PPUSH
40627: LD_VAR 0 1
40631: PPUSH
40632: EMPTY
40633: PPUSH
40634: CALL_OW 1
40638: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
40639: LD_ADDR_EXP 141
40643: PUSH
40644: LD_EXP 141
40648: PPUSH
40649: LD_VAR 0 1
40653: PPUSH
40654: EMPTY
40655: PPUSH
40656: CALL_OW 1
40660: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
40661: LD_ADDR_EXP 142
40665: PUSH
40666: LD_EXP 142
40670: PPUSH
40671: LD_VAR 0 1
40675: PPUSH
40676: EMPTY
40677: PPUSH
40678: CALL_OW 1
40682: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
40683: LD_ADDR_EXP 143
40687: PUSH
40688: LD_EXP 143
40692: PPUSH
40693: LD_VAR 0 1
40697: PPUSH
40698: EMPTY
40699: PPUSH
40700: CALL_OW 1
40704: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
40705: LD_ADDR_EXP 144
40709: PUSH
40710: LD_EXP 144
40714: PPUSH
40715: LD_VAR 0 1
40719: PPUSH
40720: LD_INT 0
40722: PPUSH
40723: CALL_OW 1
40727: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
40728: LD_ADDR_EXP 145
40732: PUSH
40733: LD_EXP 145
40737: PPUSH
40738: LD_VAR 0 1
40742: PPUSH
40743: LD_INT 0
40745: PPUSH
40746: CALL_OW 1
40750: ST_TO_ADDR
// end ;
40751: LD_VAR 0 2
40755: RET
// export function MC_Add ( side , units ) ; var base ; begin
40756: LD_INT 0
40758: PPUSH
40759: PPUSH
// base := mc_bases + 1 ;
40760: LD_ADDR_VAR 0 4
40764: PUSH
40765: LD_EXP 102
40769: PUSH
40770: LD_INT 1
40772: PLUS
40773: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
40774: LD_ADDR_EXP 128
40778: PUSH
40779: LD_EXP 128
40783: PPUSH
40784: LD_VAR 0 4
40788: PPUSH
40789: LD_VAR 0 1
40793: PPUSH
40794: CALL_OW 1
40798: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
40799: LD_ADDR_EXP 102
40803: PUSH
40804: LD_EXP 102
40808: PPUSH
40809: LD_VAR 0 4
40813: PPUSH
40814: LD_VAR 0 2
40818: PPUSH
40819: CALL_OW 1
40823: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
40824: LD_ADDR_EXP 103
40828: PUSH
40829: LD_EXP 103
40833: PPUSH
40834: LD_VAR 0 4
40838: PPUSH
40839: EMPTY
40840: PPUSH
40841: CALL_OW 1
40845: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
40846: LD_ADDR_EXP 104
40850: PUSH
40851: LD_EXP 104
40855: PPUSH
40856: LD_VAR 0 4
40860: PPUSH
40861: EMPTY
40862: PPUSH
40863: CALL_OW 1
40867: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
40868: LD_ADDR_EXP 105
40872: PUSH
40873: LD_EXP 105
40877: PPUSH
40878: LD_VAR 0 4
40882: PPUSH
40883: EMPTY
40884: PPUSH
40885: CALL_OW 1
40889: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
40890: LD_ADDR_EXP 106
40894: PUSH
40895: LD_EXP 106
40899: PPUSH
40900: LD_VAR 0 4
40904: PPUSH
40905: EMPTY
40906: PPUSH
40907: CALL_OW 1
40911: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
40912: LD_ADDR_EXP 107
40916: PUSH
40917: LD_EXP 107
40921: PPUSH
40922: LD_VAR 0 4
40926: PPUSH
40927: EMPTY
40928: PPUSH
40929: CALL_OW 1
40933: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
40934: LD_ADDR_EXP 108
40938: PUSH
40939: LD_EXP 108
40943: PPUSH
40944: LD_VAR 0 4
40948: PPUSH
40949: EMPTY
40950: PPUSH
40951: CALL_OW 1
40955: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
40956: LD_ADDR_EXP 109
40960: PUSH
40961: LD_EXP 109
40965: PPUSH
40966: LD_VAR 0 4
40970: PPUSH
40971: EMPTY
40972: PPUSH
40973: CALL_OW 1
40977: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
40978: LD_ADDR_EXP 110
40982: PUSH
40983: LD_EXP 110
40987: PPUSH
40988: LD_VAR 0 4
40992: PPUSH
40993: EMPTY
40994: PPUSH
40995: CALL_OW 1
40999: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
41000: LD_ADDR_EXP 111
41004: PUSH
41005: LD_EXP 111
41009: PPUSH
41010: LD_VAR 0 4
41014: PPUSH
41015: EMPTY
41016: PPUSH
41017: CALL_OW 1
41021: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
41022: LD_ADDR_EXP 112
41026: PUSH
41027: LD_EXP 112
41031: PPUSH
41032: LD_VAR 0 4
41036: PPUSH
41037: EMPTY
41038: PPUSH
41039: CALL_OW 1
41043: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
41044: LD_ADDR_EXP 113
41048: PUSH
41049: LD_EXP 113
41053: PPUSH
41054: LD_VAR 0 4
41058: PPUSH
41059: LD_INT 0
41061: PPUSH
41062: CALL_OW 1
41066: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
41067: LD_ADDR_EXP 114
41071: PUSH
41072: LD_EXP 114
41076: PPUSH
41077: LD_VAR 0 4
41081: PPUSH
41082: EMPTY
41083: PPUSH
41084: CALL_OW 1
41088: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
41089: LD_ADDR_EXP 115
41093: PUSH
41094: LD_EXP 115
41098: PPUSH
41099: LD_VAR 0 4
41103: PPUSH
41104: EMPTY
41105: PPUSH
41106: CALL_OW 1
41110: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
41111: LD_ADDR_EXP 116
41115: PUSH
41116: LD_EXP 116
41120: PPUSH
41121: LD_VAR 0 4
41125: PPUSH
41126: EMPTY
41127: PPUSH
41128: CALL_OW 1
41132: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
41133: LD_ADDR_EXP 117
41137: PUSH
41138: LD_EXP 117
41142: PPUSH
41143: LD_VAR 0 4
41147: PPUSH
41148: EMPTY
41149: PPUSH
41150: CALL_OW 1
41154: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
41155: LD_ADDR_EXP 118
41159: PUSH
41160: LD_EXP 118
41164: PPUSH
41165: LD_VAR 0 4
41169: PPUSH
41170: EMPTY
41171: PPUSH
41172: CALL_OW 1
41176: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
41177: LD_ADDR_EXP 119
41181: PUSH
41182: LD_EXP 119
41186: PPUSH
41187: LD_VAR 0 4
41191: PPUSH
41192: EMPTY
41193: PPUSH
41194: CALL_OW 1
41198: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
41199: LD_ADDR_EXP 120
41203: PUSH
41204: LD_EXP 120
41208: PPUSH
41209: LD_VAR 0 4
41213: PPUSH
41214: EMPTY
41215: PPUSH
41216: CALL_OW 1
41220: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
41221: LD_ADDR_EXP 121
41225: PUSH
41226: LD_EXP 121
41230: PPUSH
41231: LD_VAR 0 4
41235: PPUSH
41236: EMPTY
41237: PPUSH
41238: CALL_OW 1
41242: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
41243: LD_ADDR_EXP 122
41247: PUSH
41248: LD_EXP 122
41252: PPUSH
41253: LD_VAR 0 4
41257: PPUSH
41258: EMPTY
41259: PPUSH
41260: CALL_OW 1
41264: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
41265: LD_ADDR_EXP 123
41269: PUSH
41270: LD_EXP 123
41274: PPUSH
41275: LD_VAR 0 4
41279: PPUSH
41280: EMPTY
41281: PPUSH
41282: CALL_OW 1
41286: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
41287: LD_ADDR_EXP 124
41291: PUSH
41292: LD_EXP 124
41296: PPUSH
41297: LD_VAR 0 4
41301: PPUSH
41302: EMPTY
41303: PPUSH
41304: CALL_OW 1
41308: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
41309: LD_ADDR_EXP 125
41313: PUSH
41314: LD_EXP 125
41318: PPUSH
41319: LD_VAR 0 4
41323: PPUSH
41324: EMPTY
41325: PPUSH
41326: CALL_OW 1
41330: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
41331: LD_ADDR_EXP 126
41335: PUSH
41336: LD_EXP 126
41340: PPUSH
41341: LD_VAR 0 4
41345: PPUSH
41346: EMPTY
41347: PPUSH
41348: CALL_OW 1
41352: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
41353: LD_ADDR_EXP 127
41357: PUSH
41358: LD_EXP 127
41362: PPUSH
41363: LD_VAR 0 4
41367: PPUSH
41368: EMPTY
41369: PPUSH
41370: CALL_OW 1
41374: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
41375: LD_ADDR_EXP 129
41379: PUSH
41380: LD_EXP 129
41384: PPUSH
41385: LD_VAR 0 4
41389: PPUSH
41390: EMPTY
41391: PPUSH
41392: CALL_OW 1
41396: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
41397: LD_ADDR_EXP 131
41401: PUSH
41402: LD_EXP 131
41406: PPUSH
41407: LD_VAR 0 4
41411: PPUSH
41412: EMPTY
41413: PPUSH
41414: CALL_OW 1
41418: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
41419: LD_ADDR_EXP 132
41423: PUSH
41424: LD_EXP 132
41428: PPUSH
41429: LD_VAR 0 4
41433: PPUSH
41434: EMPTY
41435: PPUSH
41436: CALL_OW 1
41440: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
41441: LD_ADDR_EXP 133
41445: PUSH
41446: LD_EXP 133
41450: PPUSH
41451: LD_VAR 0 4
41455: PPUSH
41456: EMPTY
41457: PPUSH
41458: CALL_OW 1
41462: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
41463: LD_ADDR_EXP 134
41467: PUSH
41468: LD_EXP 134
41472: PPUSH
41473: LD_VAR 0 4
41477: PPUSH
41478: EMPTY
41479: PPUSH
41480: CALL_OW 1
41484: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
41485: LD_ADDR_EXP 135
41489: PUSH
41490: LD_EXP 135
41494: PPUSH
41495: LD_VAR 0 4
41499: PPUSH
41500: EMPTY
41501: PPUSH
41502: CALL_OW 1
41506: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
41507: LD_ADDR_EXP 136
41511: PUSH
41512: LD_EXP 136
41516: PPUSH
41517: LD_VAR 0 4
41521: PPUSH
41522: EMPTY
41523: PPUSH
41524: CALL_OW 1
41528: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
41529: LD_ADDR_EXP 137
41533: PUSH
41534: LD_EXP 137
41538: PPUSH
41539: LD_VAR 0 4
41543: PPUSH
41544: EMPTY
41545: PPUSH
41546: CALL_OW 1
41550: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
41551: LD_ADDR_EXP 138
41555: PUSH
41556: LD_EXP 138
41560: PPUSH
41561: LD_VAR 0 4
41565: PPUSH
41566: EMPTY
41567: PPUSH
41568: CALL_OW 1
41572: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
41573: LD_ADDR_EXP 139
41577: PUSH
41578: LD_EXP 139
41582: PPUSH
41583: LD_VAR 0 4
41587: PPUSH
41588: EMPTY
41589: PPUSH
41590: CALL_OW 1
41594: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
41595: LD_ADDR_EXP 140
41599: PUSH
41600: LD_EXP 140
41604: PPUSH
41605: LD_VAR 0 4
41609: PPUSH
41610: EMPTY
41611: PPUSH
41612: CALL_OW 1
41616: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
41617: LD_ADDR_EXP 141
41621: PUSH
41622: LD_EXP 141
41626: PPUSH
41627: LD_VAR 0 4
41631: PPUSH
41632: EMPTY
41633: PPUSH
41634: CALL_OW 1
41638: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
41639: LD_ADDR_EXP 142
41643: PUSH
41644: LD_EXP 142
41648: PPUSH
41649: LD_VAR 0 4
41653: PPUSH
41654: EMPTY
41655: PPUSH
41656: CALL_OW 1
41660: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
41661: LD_ADDR_EXP 143
41665: PUSH
41666: LD_EXP 143
41670: PPUSH
41671: LD_VAR 0 4
41675: PPUSH
41676: EMPTY
41677: PPUSH
41678: CALL_OW 1
41682: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
41683: LD_ADDR_EXP 144
41687: PUSH
41688: LD_EXP 144
41692: PPUSH
41693: LD_VAR 0 4
41697: PPUSH
41698: LD_INT 0
41700: PPUSH
41701: CALL_OW 1
41705: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
41706: LD_ADDR_EXP 145
41710: PUSH
41711: LD_EXP 145
41715: PPUSH
41716: LD_VAR 0 4
41720: PPUSH
41721: LD_INT 0
41723: PPUSH
41724: CALL_OW 1
41728: ST_TO_ADDR
// result := base ;
41729: LD_ADDR_VAR 0 3
41733: PUSH
41734: LD_VAR 0 4
41738: ST_TO_ADDR
// end ;
41739: LD_VAR 0 3
41743: RET
// export function MC_Start ( ) ; var i ; begin
41744: LD_INT 0
41746: PPUSH
41747: PPUSH
// for i = 1 to mc_bases do
41748: LD_ADDR_VAR 0 2
41752: PUSH
41753: DOUBLE
41754: LD_INT 1
41756: DEC
41757: ST_TO_ADDR
41758: LD_EXP 102
41762: PUSH
41763: FOR_TO
41764: IFFALSE 42864
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
41766: LD_ADDR_EXP 102
41770: PUSH
41771: LD_EXP 102
41775: PPUSH
41776: LD_VAR 0 2
41780: PPUSH
41781: LD_EXP 102
41785: PUSH
41786: LD_VAR 0 2
41790: ARRAY
41791: PUSH
41792: LD_INT 0
41794: DIFF
41795: PPUSH
41796: CALL_OW 1
41800: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
41801: LD_ADDR_EXP 103
41805: PUSH
41806: LD_EXP 103
41810: PPUSH
41811: LD_VAR 0 2
41815: PPUSH
41816: EMPTY
41817: PPUSH
41818: CALL_OW 1
41822: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
41823: LD_ADDR_EXP 104
41827: PUSH
41828: LD_EXP 104
41832: PPUSH
41833: LD_VAR 0 2
41837: PPUSH
41838: EMPTY
41839: PPUSH
41840: CALL_OW 1
41844: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
41845: LD_ADDR_EXP 105
41849: PUSH
41850: LD_EXP 105
41854: PPUSH
41855: LD_VAR 0 2
41859: PPUSH
41860: EMPTY
41861: PPUSH
41862: CALL_OW 1
41866: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
41867: LD_ADDR_EXP 106
41871: PUSH
41872: LD_EXP 106
41876: PPUSH
41877: LD_VAR 0 2
41881: PPUSH
41882: EMPTY
41883: PUSH
41884: EMPTY
41885: PUSH
41886: EMPTY
41887: LIST
41888: LIST
41889: PPUSH
41890: CALL_OW 1
41894: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
41895: LD_ADDR_EXP 107
41899: PUSH
41900: LD_EXP 107
41904: PPUSH
41905: LD_VAR 0 2
41909: PPUSH
41910: EMPTY
41911: PPUSH
41912: CALL_OW 1
41916: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
41917: LD_ADDR_EXP 134
41921: PUSH
41922: LD_EXP 134
41926: PPUSH
41927: LD_VAR 0 2
41931: PPUSH
41932: EMPTY
41933: PPUSH
41934: CALL_OW 1
41938: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
41939: LD_ADDR_EXP 108
41943: PUSH
41944: LD_EXP 108
41948: PPUSH
41949: LD_VAR 0 2
41953: PPUSH
41954: EMPTY
41955: PPUSH
41956: CALL_OW 1
41960: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
41961: LD_ADDR_EXP 109
41965: PUSH
41966: LD_EXP 109
41970: PPUSH
41971: LD_VAR 0 2
41975: PPUSH
41976: EMPTY
41977: PPUSH
41978: CALL_OW 1
41982: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
41983: LD_ADDR_EXP 110
41987: PUSH
41988: LD_EXP 110
41992: PPUSH
41993: LD_VAR 0 2
41997: PPUSH
41998: LD_EXP 102
42002: PUSH
42003: LD_VAR 0 2
42007: ARRAY
42008: PPUSH
42009: LD_INT 2
42011: PUSH
42012: LD_INT 30
42014: PUSH
42015: LD_INT 32
42017: PUSH
42018: EMPTY
42019: LIST
42020: LIST
42021: PUSH
42022: LD_INT 30
42024: PUSH
42025: LD_INT 33
42027: PUSH
42028: EMPTY
42029: LIST
42030: LIST
42031: PUSH
42032: EMPTY
42033: LIST
42034: LIST
42035: LIST
42036: PPUSH
42037: CALL_OW 72
42041: PPUSH
42042: CALL_OW 1
42046: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
42047: LD_ADDR_EXP 111
42051: PUSH
42052: LD_EXP 111
42056: PPUSH
42057: LD_VAR 0 2
42061: PPUSH
42062: LD_EXP 102
42066: PUSH
42067: LD_VAR 0 2
42071: ARRAY
42072: PPUSH
42073: LD_INT 2
42075: PUSH
42076: LD_INT 30
42078: PUSH
42079: LD_INT 32
42081: PUSH
42082: EMPTY
42083: LIST
42084: LIST
42085: PUSH
42086: LD_INT 30
42088: PUSH
42089: LD_INT 31
42091: PUSH
42092: EMPTY
42093: LIST
42094: LIST
42095: PUSH
42096: EMPTY
42097: LIST
42098: LIST
42099: LIST
42100: PUSH
42101: LD_INT 58
42103: PUSH
42104: EMPTY
42105: LIST
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PPUSH
42111: CALL_OW 72
42115: PPUSH
42116: CALL_OW 1
42120: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
42121: LD_ADDR_EXP 112
42125: PUSH
42126: LD_EXP 112
42130: PPUSH
42131: LD_VAR 0 2
42135: PPUSH
42136: EMPTY
42137: PPUSH
42138: CALL_OW 1
42142: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
42143: LD_ADDR_EXP 116
42147: PUSH
42148: LD_EXP 116
42152: PPUSH
42153: LD_VAR 0 2
42157: PPUSH
42158: EMPTY
42159: PPUSH
42160: CALL_OW 1
42164: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
42165: LD_ADDR_EXP 115
42169: PUSH
42170: LD_EXP 115
42174: PPUSH
42175: LD_VAR 0 2
42179: PPUSH
42180: EMPTY
42181: PPUSH
42182: CALL_OW 1
42186: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
42187: LD_ADDR_EXP 117
42191: PUSH
42192: LD_EXP 117
42196: PPUSH
42197: LD_VAR 0 2
42201: PPUSH
42202: EMPTY
42203: PPUSH
42204: CALL_OW 1
42208: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
42209: LD_ADDR_EXP 118
42213: PUSH
42214: LD_EXP 118
42218: PPUSH
42219: LD_VAR 0 2
42223: PPUSH
42224: EMPTY
42225: PPUSH
42226: CALL_OW 1
42230: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
42231: LD_ADDR_EXP 119
42235: PUSH
42236: LD_EXP 119
42240: PPUSH
42241: LD_VAR 0 2
42245: PPUSH
42246: EMPTY
42247: PPUSH
42248: CALL_OW 1
42252: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
42253: LD_ADDR_EXP 120
42257: PUSH
42258: LD_EXP 120
42262: PPUSH
42263: LD_VAR 0 2
42267: PPUSH
42268: EMPTY
42269: PPUSH
42270: CALL_OW 1
42274: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
42275: LD_ADDR_EXP 121
42279: PUSH
42280: LD_EXP 121
42284: PPUSH
42285: LD_VAR 0 2
42289: PPUSH
42290: EMPTY
42291: PPUSH
42292: CALL_OW 1
42296: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
42297: LD_ADDR_EXP 122
42301: PUSH
42302: LD_EXP 122
42306: PPUSH
42307: LD_VAR 0 2
42311: PPUSH
42312: EMPTY
42313: PPUSH
42314: CALL_OW 1
42318: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
42319: LD_ADDR_EXP 123
42323: PUSH
42324: LD_EXP 123
42328: PPUSH
42329: LD_VAR 0 2
42333: PPUSH
42334: EMPTY
42335: PPUSH
42336: CALL_OW 1
42340: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
42341: LD_ADDR_EXP 124
42345: PUSH
42346: LD_EXP 124
42350: PPUSH
42351: LD_VAR 0 2
42355: PPUSH
42356: EMPTY
42357: PPUSH
42358: CALL_OW 1
42362: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
42363: LD_ADDR_EXP 113
42367: PUSH
42368: LD_EXP 113
42372: PPUSH
42373: LD_VAR 0 2
42377: PPUSH
42378: LD_INT 0
42380: PPUSH
42381: CALL_OW 1
42385: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
42386: LD_ADDR_EXP 126
42390: PUSH
42391: LD_EXP 126
42395: PPUSH
42396: LD_VAR 0 2
42400: PPUSH
42401: LD_INT 0
42403: PPUSH
42404: CALL_OW 1
42408: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
42409: LD_ADDR_EXP 114
42413: PUSH
42414: LD_EXP 114
42418: PPUSH
42419: LD_VAR 0 2
42423: PPUSH
42424: EMPTY
42425: PPUSH
42426: CALL_OW 1
42430: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
42431: LD_ADDR_EXP 125
42435: PUSH
42436: LD_EXP 125
42440: PPUSH
42441: LD_VAR 0 2
42445: PPUSH
42446: LD_INT 0
42448: PPUSH
42449: CALL_OW 1
42453: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
42454: LD_ADDR_EXP 127
42458: PUSH
42459: LD_EXP 127
42463: PPUSH
42464: LD_VAR 0 2
42468: PPUSH
42469: EMPTY
42470: PPUSH
42471: CALL_OW 1
42475: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
42476: LD_ADDR_EXP 130
42480: PUSH
42481: LD_EXP 130
42485: PPUSH
42486: LD_VAR 0 2
42490: PPUSH
42491: LD_INT 0
42493: PPUSH
42494: CALL_OW 1
42498: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
42499: LD_ADDR_EXP 131
42503: PUSH
42504: LD_EXP 131
42508: PPUSH
42509: LD_VAR 0 2
42513: PPUSH
42514: EMPTY
42515: PPUSH
42516: CALL_OW 1
42520: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
42521: LD_ADDR_EXP 132
42525: PUSH
42526: LD_EXP 132
42530: PPUSH
42531: LD_VAR 0 2
42535: PPUSH
42536: EMPTY
42537: PPUSH
42538: CALL_OW 1
42542: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
42543: LD_ADDR_EXP 133
42547: PUSH
42548: LD_EXP 133
42552: PPUSH
42553: LD_VAR 0 2
42557: PPUSH
42558: EMPTY
42559: PPUSH
42560: CALL_OW 1
42564: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
42565: LD_ADDR_EXP 135
42569: PUSH
42570: LD_EXP 135
42574: PPUSH
42575: LD_VAR 0 2
42579: PPUSH
42580: LD_EXP 102
42584: PUSH
42585: LD_VAR 0 2
42589: ARRAY
42590: PPUSH
42591: LD_INT 2
42593: PUSH
42594: LD_INT 30
42596: PUSH
42597: LD_INT 6
42599: PUSH
42600: EMPTY
42601: LIST
42602: LIST
42603: PUSH
42604: LD_INT 30
42606: PUSH
42607: LD_INT 7
42609: PUSH
42610: EMPTY
42611: LIST
42612: LIST
42613: PUSH
42614: LD_INT 30
42616: PUSH
42617: LD_INT 8
42619: PUSH
42620: EMPTY
42621: LIST
42622: LIST
42623: PUSH
42624: EMPTY
42625: LIST
42626: LIST
42627: LIST
42628: LIST
42629: PPUSH
42630: CALL_OW 72
42634: PPUSH
42635: CALL_OW 1
42639: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
42640: LD_ADDR_EXP 136
42644: PUSH
42645: LD_EXP 136
42649: PPUSH
42650: LD_VAR 0 2
42654: PPUSH
42655: EMPTY
42656: PPUSH
42657: CALL_OW 1
42661: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
42662: LD_ADDR_EXP 137
42666: PUSH
42667: LD_EXP 137
42671: PPUSH
42672: LD_VAR 0 2
42676: PPUSH
42677: EMPTY
42678: PPUSH
42679: CALL_OW 1
42683: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
42684: LD_ADDR_EXP 138
42688: PUSH
42689: LD_EXP 138
42693: PPUSH
42694: LD_VAR 0 2
42698: PPUSH
42699: EMPTY
42700: PPUSH
42701: CALL_OW 1
42705: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
42706: LD_ADDR_EXP 139
42710: PUSH
42711: LD_EXP 139
42715: PPUSH
42716: LD_VAR 0 2
42720: PPUSH
42721: EMPTY
42722: PPUSH
42723: CALL_OW 1
42727: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42728: LD_ADDR_EXP 140
42732: PUSH
42733: LD_EXP 140
42737: PPUSH
42738: LD_VAR 0 2
42742: PPUSH
42743: EMPTY
42744: PPUSH
42745: CALL_OW 1
42749: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
42750: LD_ADDR_EXP 141
42754: PUSH
42755: LD_EXP 141
42759: PPUSH
42760: LD_VAR 0 2
42764: PPUSH
42765: EMPTY
42766: PPUSH
42767: CALL_OW 1
42771: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
42772: LD_ADDR_EXP 142
42776: PUSH
42777: LD_EXP 142
42781: PPUSH
42782: LD_VAR 0 2
42786: PPUSH
42787: EMPTY
42788: PPUSH
42789: CALL_OW 1
42793: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
42794: LD_ADDR_EXP 143
42798: PUSH
42799: LD_EXP 143
42803: PPUSH
42804: LD_VAR 0 2
42808: PPUSH
42809: EMPTY
42810: PPUSH
42811: CALL_OW 1
42815: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
42816: LD_ADDR_EXP 144
42820: PUSH
42821: LD_EXP 144
42825: PPUSH
42826: LD_VAR 0 2
42830: PPUSH
42831: LD_INT 0
42833: PPUSH
42834: CALL_OW 1
42838: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
42839: LD_ADDR_EXP 145
42843: PUSH
42844: LD_EXP 145
42848: PPUSH
42849: LD_VAR 0 2
42853: PPUSH
42854: LD_INT 0
42856: PPUSH
42857: CALL_OW 1
42861: ST_TO_ADDR
// end ;
42862: GO 41763
42864: POP
42865: POP
// MC_InitSides ( ) ;
42866: CALL 43152 0 0
// MC_InitResearch ( ) ;
42870: CALL 42891 0 0
// CustomInitMacro ( ) ;
42874: CALL 475 0 0
// skirmish := true ;
42878: LD_ADDR_EXP 100
42882: PUSH
42883: LD_INT 1
42885: ST_TO_ADDR
// end ;
42886: LD_VAR 0 1
42890: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
42891: LD_INT 0
42893: PPUSH
42894: PPUSH
42895: PPUSH
42896: PPUSH
42897: PPUSH
42898: PPUSH
// if not mc_bases then
42899: LD_EXP 102
42903: NOT
42904: IFFALSE 42908
// exit ;
42906: GO 43147
// for i = 1 to 8 do
42908: LD_ADDR_VAR 0 2
42912: PUSH
42913: DOUBLE
42914: LD_INT 1
42916: DEC
42917: ST_TO_ADDR
42918: LD_INT 8
42920: PUSH
42921: FOR_TO
42922: IFFALSE 42948
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
42924: LD_ADDR_EXP 129
42928: PUSH
42929: LD_EXP 129
42933: PPUSH
42934: LD_VAR 0 2
42938: PPUSH
42939: EMPTY
42940: PPUSH
42941: CALL_OW 1
42945: ST_TO_ADDR
42946: GO 42921
42948: POP
42949: POP
// tmp := [ ] ;
42950: LD_ADDR_VAR 0 5
42954: PUSH
42955: EMPTY
42956: ST_TO_ADDR
// for i = 1 to mc_sides do
42957: LD_ADDR_VAR 0 2
42961: PUSH
42962: DOUBLE
42963: LD_INT 1
42965: DEC
42966: ST_TO_ADDR
42967: LD_EXP 128
42971: PUSH
42972: FOR_TO
42973: IFFALSE 43031
// if not mc_sides [ i ] in tmp then
42975: LD_EXP 128
42979: PUSH
42980: LD_VAR 0 2
42984: ARRAY
42985: PUSH
42986: LD_VAR 0 5
42990: IN
42991: NOT
42992: IFFALSE 43029
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
42994: LD_ADDR_VAR 0 5
42998: PUSH
42999: LD_VAR 0 5
43003: PPUSH
43004: LD_VAR 0 5
43008: PUSH
43009: LD_INT 1
43011: PLUS
43012: PPUSH
43013: LD_EXP 128
43017: PUSH
43018: LD_VAR 0 2
43022: ARRAY
43023: PPUSH
43024: CALL_OW 2
43028: ST_TO_ADDR
43029: GO 42972
43031: POP
43032: POP
// if not tmp then
43033: LD_VAR 0 5
43037: NOT
43038: IFFALSE 43042
// exit ;
43040: GO 43147
// for j in tmp do
43042: LD_ADDR_VAR 0 3
43046: PUSH
43047: LD_VAR 0 5
43051: PUSH
43052: FOR_IN
43053: IFFALSE 43145
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
43055: LD_ADDR_VAR 0 6
43059: PUSH
43060: LD_INT 22
43062: PUSH
43063: LD_VAR 0 3
43067: PUSH
43068: EMPTY
43069: LIST
43070: LIST
43071: PPUSH
43072: CALL_OW 69
43076: ST_TO_ADDR
// if not un then
43077: LD_VAR 0 6
43081: NOT
43082: IFFALSE 43086
// continue ;
43084: GO 43052
// nation := GetNation ( un [ 1 ] ) ;
43086: LD_ADDR_VAR 0 4
43090: PUSH
43091: LD_VAR 0 6
43095: PUSH
43096: LD_INT 1
43098: ARRAY
43099: PPUSH
43100: CALL_OW 248
43104: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
43105: LD_ADDR_EXP 129
43109: PUSH
43110: LD_EXP 129
43114: PPUSH
43115: LD_VAR 0 3
43119: PPUSH
43120: LD_VAR 0 3
43124: PPUSH
43125: LD_VAR 0 4
43129: PPUSH
43130: LD_INT 1
43132: PPUSH
43133: CALL 70335 0 3
43137: PPUSH
43138: CALL_OW 1
43142: ST_TO_ADDR
// end ;
43143: GO 43052
43145: POP
43146: POP
// end ;
43147: LD_VAR 0 1
43151: RET
// export function MC_InitSides ( ) ; var i ; begin
43152: LD_INT 0
43154: PPUSH
43155: PPUSH
// if not mc_bases then
43156: LD_EXP 102
43160: NOT
43161: IFFALSE 43165
// exit ;
43163: GO 43239
// for i = 1 to mc_bases do
43165: LD_ADDR_VAR 0 2
43169: PUSH
43170: DOUBLE
43171: LD_INT 1
43173: DEC
43174: ST_TO_ADDR
43175: LD_EXP 102
43179: PUSH
43180: FOR_TO
43181: IFFALSE 43237
// if mc_bases [ i ] then
43183: LD_EXP 102
43187: PUSH
43188: LD_VAR 0 2
43192: ARRAY
43193: IFFALSE 43235
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
43195: LD_ADDR_EXP 128
43199: PUSH
43200: LD_EXP 128
43204: PPUSH
43205: LD_VAR 0 2
43209: PPUSH
43210: LD_EXP 102
43214: PUSH
43215: LD_VAR 0 2
43219: ARRAY
43220: PUSH
43221: LD_INT 1
43223: ARRAY
43224: PPUSH
43225: CALL_OW 255
43229: PPUSH
43230: CALL_OW 1
43234: ST_TO_ADDR
43235: GO 43180
43237: POP
43238: POP
// end ;
43239: LD_VAR 0 1
43243: RET
// every 0 0$03 trigger skirmish do
43244: LD_EXP 100
43248: IFFALSE 43402
43250: GO 43252
43252: DISABLE
// begin enable ;
43253: ENABLE
// MC_CheckBuildings ( ) ;
43254: CALL 47914 0 0
// MC_CheckPeopleLife ( ) ;
43258: CALL 48075 0 0
// RaiseSailEvent ( 100 ) ;
43262: LD_INT 100
43264: PPUSH
43265: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
43269: LD_INT 103
43271: PPUSH
43272: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
43276: LD_INT 104
43278: PPUSH
43279: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
43283: LD_INT 105
43285: PPUSH
43286: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
43290: LD_INT 106
43292: PPUSH
43293: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
43297: LD_INT 107
43299: PPUSH
43300: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
43304: LD_INT 108
43306: PPUSH
43307: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
43311: LD_INT 109
43313: PPUSH
43314: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
43318: LD_INT 110
43320: PPUSH
43321: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
43325: LD_INT 111
43327: PPUSH
43328: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
43332: LD_INT 112
43334: PPUSH
43335: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
43339: LD_INT 113
43341: PPUSH
43342: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
43346: LD_INT 120
43348: PPUSH
43349: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
43353: LD_INT 121
43355: PPUSH
43356: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
43360: LD_INT 122
43362: PPUSH
43363: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
43367: LD_INT 123
43369: PPUSH
43370: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
43374: LD_INT 124
43376: PPUSH
43377: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
43381: LD_INT 125
43383: PPUSH
43384: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
43388: LD_INT 126
43390: PPUSH
43391: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
43395: LD_INT 200
43397: PPUSH
43398: CALL_OW 427
// end ;
43402: END
// on SailEvent ( event ) do begin if event < 100 then
43403: LD_VAR 0 1
43407: PUSH
43408: LD_INT 100
43410: LESS
43411: IFFALSE 43422
// CustomEvent ( event ) ;
43413: LD_VAR 0 1
43417: PPUSH
43418: CALL 37778 0 1
// if event = 100 then
43422: LD_VAR 0 1
43426: PUSH
43427: LD_INT 100
43429: EQUAL
43430: IFFALSE 43436
// MC_ClassManager ( ) ;
43432: CALL 43828 0 0
// if event = 101 then
43436: LD_VAR 0 1
43440: PUSH
43441: LD_INT 101
43443: EQUAL
43444: IFFALSE 43450
// MC_RepairBuildings ( ) ;
43446: CALL 48660 0 0
// if event = 102 then
43450: LD_VAR 0 1
43454: PUSH
43455: LD_INT 102
43457: EQUAL
43458: IFFALSE 43464
// MC_Heal ( ) ;
43460: CALL 49595 0 0
// if event = 103 then
43464: LD_VAR 0 1
43468: PUSH
43469: LD_INT 103
43471: EQUAL
43472: IFFALSE 43478
// MC_Build ( ) ;
43474: CALL 50017 0 0
// if event = 104 then
43478: LD_VAR 0 1
43482: PUSH
43483: LD_INT 104
43485: EQUAL
43486: IFFALSE 43492
// MC_TurretWeapon ( ) ;
43488: CALL 51651 0 0
// if event = 105 then
43492: LD_VAR 0 1
43496: PUSH
43497: LD_INT 105
43499: EQUAL
43500: IFFALSE 43506
// MC_BuildUpgrade ( ) ;
43502: CALL 51202 0 0
// if event = 106 then
43506: LD_VAR 0 1
43510: PUSH
43511: LD_INT 106
43513: EQUAL
43514: IFFALSE 43520
// MC_PlantMines ( ) ;
43516: CALL 52081 0 0
// if event = 107 then
43520: LD_VAR 0 1
43524: PUSH
43525: LD_INT 107
43527: EQUAL
43528: IFFALSE 43534
// MC_CollectCrates ( ) ;
43530: CALL 52879 0 0
// if event = 108 then
43534: LD_VAR 0 1
43538: PUSH
43539: LD_INT 108
43541: EQUAL
43542: IFFALSE 43548
// MC_LinkRemoteControl ( ) ;
43544: CALL 54729 0 0
// if event = 109 then
43548: LD_VAR 0 1
43552: PUSH
43553: LD_INT 109
43555: EQUAL
43556: IFFALSE 43562
// MC_ProduceVehicle ( ) ;
43558: CALL 54910 0 0
// if event = 110 then
43562: LD_VAR 0 1
43566: PUSH
43567: LD_INT 110
43569: EQUAL
43570: IFFALSE 43576
// MC_SendAttack ( ) ;
43572: CALL 55376 0 0
// if event = 111 then
43576: LD_VAR 0 1
43580: PUSH
43581: LD_INT 111
43583: EQUAL
43584: IFFALSE 43590
// MC_Defend ( ) ;
43586: CALL 55484 0 0
// if event = 112 then
43590: LD_VAR 0 1
43594: PUSH
43595: LD_INT 112
43597: EQUAL
43598: IFFALSE 43604
// MC_Research ( ) ;
43600: CALL 56364 0 0
// if event = 113 then
43604: LD_VAR 0 1
43608: PUSH
43609: LD_INT 113
43611: EQUAL
43612: IFFALSE 43618
// MC_MinesTrigger ( ) ;
43614: CALL 57478 0 0
// if event = 120 then
43618: LD_VAR 0 1
43622: PUSH
43623: LD_INT 120
43625: EQUAL
43626: IFFALSE 43632
// MC_RepairVehicle ( ) ;
43628: CALL 57577 0 0
// if event = 121 then
43632: LD_VAR 0 1
43636: PUSH
43637: LD_INT 121
43639: EQUAL
43640: IFFALSE 43646
// MC_TameApe ( ) ;
43642: CALL 58346 0 0
// if event = 122 then
43646: LD_VAR 0 1
43650: PUSH
43651: LD_INT 122
43653: EQUAL
43654: IFFALSE 43660
// MC_ChangeApeClass ( ) ;
43656: CALL 59175 0 0
// if event = 123 then
43660: LD_VAR 0 1
43664: PUSH
43665: LD_INT 123
43667: EQUAL
43668: IFFALSE 43674
// MC_Bazooka ( ) ;
43670: CALL 59825 0 0
// if event = 124 then
43674: LD_VAR 0 1
43678: PUSH
43679: LD_INT 124
43681: EQUAL
43682: IFFALSE 43688
// MC_TeleportExit ( ) ;
43684: CALL 60023 0 0
// if event = 125 then
43688: LD_VAR 0 1
43692: PUSH
43693: LD_INT 125
43695: EQUAL
43696: IFFALSE 43702
// MC_Deposits ( ) ;
43698: CALL 60670 0 0
// if event = 126 then
43702: LD_VAR 0 1
43706: PUSH
43707: LD_INT 126
43709: EQUAL
43710: IFFALSE 43716
// MC_RemoteDriver ( ) ;
43712: CALL 61295 0 0
// if event = 200 then
43716: LD_VAR 0 1
43720: PUSH
43721: LD_INT 200
43723: EQUAL
43724: IFFALSE 43730
// MC_Idle ( ) ;
43726: CALL 63202 0 0
// end ;
43730: PPOPN 1
43732: END
// export function MC_Reset ( base , tag ) ; var i ; begin
43733: LD_INT 0
43735: PPUSH
43736: PPUSH
// if not mc_bases [ base ] or not tag then
43737: LD_EXP 102
43741: PUSH
43742: LD_VAR 0 1
43746: ARRAY
43747: NOT
43748: PUSH
43749: LD_VAR 0 2
43753: NOT
43754: OR
43755: IFFALSE 43759
// exit ;
43757: GO 43823
// for i in mc_bases [ base ] union mc_ape [ base ] do
43759: LD_ADDR_VAR 0 4
43763: PUSH
43764: LD_EXP 102
43768: PUSH
43769: LD_VAR 0 1
43773: ARRAY
43774: PUSH
43775: LD_EXP 131
43779: PUSH
43780: LD_VAR 0 1
43784: ARRAY
43785: UNION
43786: PUSH
43787: FOR_IN
43788: IFFALSE 43821
// if GetTag ( i ) = tag then
43790: LD_VAR 0 4
43794: PPUSH
43795: CALL_OW 110
43799: PUSH
43800: LD_VAR 0 2
43804: EQUAL
43805: IFFALSE 43819
// SetTag ( i , 0 ) ;
43807: LD_VAR 0 4
43811: PPUSH
43812: LD_INT 0
43814: PPUSH
43815: CALL_OW 109
43819: GO 43787
43821: POP
43822: POP
// end ;
43823: LD_VAR 0 3
43827: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
43828: LD_INT 0
43830: PPUSH
43831: PPUSH
43832: PPUSH
43833: PPUSH
43834: PPUSH
43835: PPUSH
43836: PPUSH
43837: PPUSH
// if not mc_bases then
43838: LD_EXP 102
43842: NOT
43843: IFFALSE 43847
// exit ;
43845: GO 44296
// for i = 1 to mc_bases do
43847: LD_ADDR_VAR 0 2
43851: PUSH
43852: DOUBLE
43853: LD_INT 1
43855: DEC
43856: ST_TO_ADDR
43857: LD_EXP 102
43861: PUSH
43862: FOR_TO
43863: IFFALSE 44294
// begin tmp := MC_ClassCheckReq ( i ) ;
43865: LD_ADDR_VAR 0 4
43869: PUSH
43870: LD_VAR 0 2
43874: PPUSH
43875: CALL 44301 0 1
43879: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
43880: LD_ADDR_EXP 143
43884: PUSH
43885: LD_EXP 143
43889: PPUSH
43890: LD_VAR 0 2
43894: PPUSH
43895: LD_VAR 0 4
43899: PPUSH
43900: CALL_OW 1
43904: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
43905: LD_ADDR_VAR 0 6
43909: PUSH
43910: LD_EXP 102
43914: PUSH
43915: LD_VAR 0 2
43919: ARRAY
43920: PPUSH
43921: LD_INT 2
43923: PUSH
43924: LD_INT 30
43926: PUSH
43927: LD_INT 4
43929: PUSH
43930: EMPTY
43931: LIST
43932: LIST
43933: PUSH
43934: LD_INT 30
43936: PUSH
43937: LD_INT 5
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: PUSH
43944: EMPTY
43945: LIST
43946: LIST
43947: LIST
43948: PPUSH
43949: CALL_OW 72
43953: PUSH
43954: LD_EXP 102
43958: PUSH
43959: LD_VAR 0 2
43963: ARRAY
43964: PPUSH
43965: LD_INT 2
43967: PUSH
43968: LD_INT 30
43970: PUSH
43971: LD_INT 0
43973: PUSH
43974: EMPTY
43975: LIST
43976: LIST
43977: PUSH
43978: LD_INT 30
43980: PUSH
43981: LD_INT 1
43983: PUSH
43984: EMPTY
43985: LIST
43986: LIST
43987: PUSH
43988: EMPTY
43989: LIST
43990: LIST
43991: LIST
43992: PPUSH
43993: CALL_OW 72
43997: PUSH
43998: LD_EXP 102
44002: PUSH
44003: LD_VAR 0 2
44007: ARRAY
44008: PPUSH
44009: LD_INT 30
44011: PUSH
44012: LD_INT 3
44014: PUSH
44015: EMPTY
44016: LIST
44017: LIST
44018: PPUSH
44019: CALL_OW 72
44023: PUSH
44024: LD_EXP 102
44028: PUSH
44029: LD_VAR 0 2
44033: ARRAY
44034: PPUSH
44035: LD_INT 2
44037: PUSH
44038: LD_INT 30
44040: PUSH
44041: LD_INT 6
44043: PUSH
44044: EMPTY
44045: LIST
44046: LIST
44047: PUSH
44048: LD_INT 30
44050: PUSH
44051: LD_INT 7
44053: PUSH
44054: EMPTY
44055: LIST
44056: LIST
44057: PUSH
44058: LD_INT 30
44060: PUSH
44061: LD_INT 8
44063: PUSH
44064: EMPTY
44065: LIST
44066: LIST
44067: PUSH
44068: EMPTY
44069: LIST
44070: LIST
44071: LIST
44072: LIST
44073: PPUSH
44074: CALL_OW 72
44078: PUSH
44079: EMPTY
44080: LIST
44081: LIST
44082: LIST
44083: LIST
44084: ST_TO_ADDR
// for j := 1 to 4 do
44085: LD_ADDR_VAR 0 3
44089: PUSH
44090: DOUBLE
44091: LD_INT 1
44093: DEC
44094: ST_TO_ADDR
44095: LD_INT 4
44097: PUSH
44098: FOR_TO
44099: IFFALSE 44290
// begin if not tmp [ j ] then
44101: LD_VAR 0 4
44105: PUSH
44106: LD_VAR 0 3
44110: ARRAY
44111: NOT
44112: IFFALSE 44116
// continue ;
44114: GO 44098
// for p in tmp [ j ] do
44116: LD_ADDR_VAR 0 5
44120: PUSH
44121: LD_VAR 0 4
44125: PUSH
44126: LD_VAR 0 3
44130: ARRAY
44131: PUSH
44132: FOR_IN
44133: IFFALSE 44286
// begin if not b [ j ] then
44135: LD_VAR 0 6
44139: PUSH
44140: LD_VAR 0 3
44144: ARRAY
44145: NOT
44146: IFFALSE 44150
// break ;
44148: GO 44286
// e := 0 ;
44150: LD_ADDR_VAR 0 7
44154: PUSH
44155: LD_INT 0
44157: ST_TO_ADDR
// for k in b [ j ] do
44158: LD_ADDR_VAR 0 8
44162: PUSH
44163: LD_VAR 0 6
44167: PUSH
44168: LD_VAR 0 3
44172: ARRAY
44173: PUSH
44174: FOR_IN
44175: IFFALSE 44202
// if IsNotFull ( k ) then
44177: LD_VAR 0 8
44181: PPUSH
44182: CALL 72456 0 1
44186: IFFALSE 44200
// begin e := k ;
44188: LD_ADDR_VAR 0 7
44192: PUSH
44193: LD_VAR 0 8
44197: ST_TO_ADDR
// break ;
44198: GO 44202
// end ;
44200: GO 44174
44202: POP
44203: POP
// if e and not UnitGoingToBuilding ( p , e ) then
44204: LD_VAR 0 7
44208: PUSH
44209: LD_VAR 0 5
44213: PPUSH
44214: LD_VAR 0 7
44218: PPUSH
44219: CALL 106595 0 2
44223: NOT
44224: AND
44225: IFFALSE 44284
// begin if IsInUnit ( p ) then
44227: LD_VAR 0 5
44231: PPUSH
44232: CALL_OW 310
44236: IFFALSE 44247
// ComExitBuilding ( p ) ;
44238: LD_VAR 0 5
44242: PPUSH
44243: CALL_OW 122
// ComEnterUnit ( p , e ) ;
44247: LD_VAR 0 5
44251: PPUSH
44252: LD_VAR 0 7
44256: PPUSH
44257: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
44261: LD_VAR 0 5
44265: PPUSH
44266: LD_VAR 0 3
44270: PPUSH
44271: CALL_OW 183
// AddComExitBuilding ( p ) ;
44275: LD_VAR 0 5
44279: PPUSH
44280: CALL_OW 182
// end ; end ;
44284: GO 44132
44286: POP
44287: POP
// end ;
44288: GO 44098
44290: POP
44291: POP
// end ;
44292: GO 43862
44294: POP
44295: POP
// end ;
44296: LD_VAR 0 1
44300: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
44301: LD_INT 0
44303: PPUSH
44304: PPUSH
44305: PPUSH
44306: PPUSH
44307: PPUSH
44308: PPUSH
44309: PPUSH
44310: PPUSH
44311: PPUSH
44312: PPUSH
44313: PPUSH
44314: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
44315: LD_ADDR_VAR 0 2
44319: PUSH
44320: LD_INT 0
44322: PUSH
44323: LD_INT 0
44325: PUSH
44326: LD_INT 0
44328: PUSH
44329: LD_INT 0
44331: PUSH
44332: EMPTY
44333: LIST
44334: LIST
44335: LIST
44336: LIST
44337: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
44338: LD_VAR 0 1
44342: NOT
44343: PUSH
44344: LD_EXP 102
44348: PUSH
44349: LD_VAR 0 1
44353: ARRAY
44354: NOT
44355: OR
44356: PUSH
44357: LD_EXP 102
44361: PUSH
44362: LD_VAR 0 1
44366: ARRAY
44367: PPUSH
44368: LD_INT 2
44370: PUSH
44371: LD_INT 30
44373: PUSH
44374: LD_INT 0
44376: PUSH
44377: EMPTY
44378: LIST
44379: LIST
44380: PUSH
44381: LD_INT 30
44383: PUSH
44384: LD_INT 1
44386: PUSH
44387: EMPTY
44388: LIST
44389: LIST
44390: PUSH
44391: EMPTY
44392: LIST
44393: LIST
44394: LIST
44395: PPUSH
44396: CALL_OW 72
44400: NOT
44401: OR
44402: IFFALSE 44406
// exit ;
44404: GO 47909
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
44406: LD_ADDR_VAR 0 4
44410: PUSH
44411: LD_EXP 102
44415: PUSH
44416: LD_VAR 0 1
44420: ARRAY
44421: PPUSH
44422: LD_INT 2
44424: PUSH
44425: LD_INT 25
44427: PUSH
44428: LD_INT 1
44430: PUSH
44431: EMPTY
44432: LIST
44433: LIST
44434: PUSH
44435: LD_INT 25
44437: PUSH
44438: LD_INT 2
44440: PUSH
44441: EMPTY
44442: LIST
44443: LIST
44444: PUSH
44445: LD_INT 25
44447: PUSH
44448: LD_INT 3
44450: PUSH
44451: EMPTY
44452: LIST
44453: LIST
44454: PUSH
44455: LD_INT 25
44457: PUSH
44458: LD_INT 4
44460: PUSH
44461: EMPTY
44462: LIST
44463: LIST
44464: PUSH
44465: LD_INT 25
44467: PUSH
44468: LD_INT 5
44470: PUSH
44471: EMPTY
44472: LIST
44473: LIST
44474: PUSH
44475: LD_INT 25
44477: PUSH
44478: LD_INT 8
44480: PUSH
44481: EMPTY
44482: LIST
44483: LIST
44484: PUSH
44485: LD_INT 25
44487: PUSH
44488: LD_INT 9
44490: PUSH
44491: EMPTY
44492: LIST
44493: LIST
44494: PUSH
44495: EMPTY
44496: LIST
44497: LIST
44498: LIST
44499: LIST
44500: LIST
44501: LIST
44502: LIST
44503: LIST
44504: PPUSH
44505: CALL_OW 72
44509: ST_TO_ADDR
// if not tmp then
44510: LD_VAR 0 4
44514: NOT
44515: IFFALSE 44519
// exit ;
44517: GO 47909
// for i in tmp do
44519: LD_ADDR_VAR 0 3
44523: PUSH
44524: LD_VAR 0 4
44528: PUSH
44529: FOR_IN
44530: IFFALSE 44561
// if GetTag ( i ) then
44532: LD_VAR 0 3
44536: PPUSH
44537: CALL_OW 110
44541: IFFALSE 44559
// tmp := tmp diff i ;
44543: LD_ADDR_VAR 0 4
44547: PUSH
44548: LD_VAR 0 4
44552: PUSH
44553: LD_VAR 0 3
44557: DIFF
44558: ST_TO_ADDR
44559: GO 44529
44561: POP
44562: POP
// if not tmp then
44563: LD_VAR 0 4
44567: NOT
44568: IFFALSE 44572
// exit ;
44570: GO 47909
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
44572: LD_ADDR_VAR 0 5
44576: PUSH
44577: LD_EXP 102
44581: PUSH
44582: LD_VAR 0 1
44586: ARRAY
44587: PPUSH
44588: LD_INT 2
44590: PUSH
44591: LD_INT 25
44593: PUSH
44594: LD_INT 1
44596: PUSH
44597: EMPTY
44598: LIST
44599: LIST
44600: PUSH
44601: LD_INT 25
44603: PUSH
44604: LD_INT 5
44606: PUSH
44607: EMPTY
44608: LIST
44609: LIST
44610: PUSH
44611: LD_INT 25
44613: PUSH
44614: LD_INT 8
44616: PUSH
44617: EMPTY
44618: LIST
44619: LIST
44620: PUSH
44621: LD_INT 25
44623: PUSH
44624: LD_INT 9
44626: PUSH
44627: EMPTY
44628: LIST
44629: LIST
44630: PUSH
44631: EMPTY
44632: LIST
44633: LIST
44634: LIST
44635: LIST
44636: LIST
44637: PPUSH
44638: CALL_OW 72
44642: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
44643: LD_ADDR_VAR 0 6
44647: PUSH
44648: LD_EXP 102
44652: PUSH
44653: LD_VAR 0 1
44657: ARRAY
44658: PPUSH
44659: LD_INT 25
44661: PUSH
44662: LD_INT 2
44664: PUSH
44665: EMPTY
44666: LIST
44667: LIST
44668: PPUSH
44669: CALL_OW 72
44673: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
44674: LD_ADDR_VAR 0 7
44678: PUSH
44679: LD_EXP 102
44683: PUSH
44684: LD_VAR 0 1
44688: ARRAY
44689: PPUSH
44690: LD_INT 25
44692: PUSH
44693: LD_INT 3
44695: PUSH
44696: EMPTY
44697: LIST
44698: LIST
44699: PPUSH
44700: CALL_OW 72
44704: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
44705: LD_ADDR_VAR 0 8
44709: PUSH
44710: LD_EXP 102
44714: PUSH
44715: LD_VAR 0 1
44719: ARRAY
44720: PPUSH
44721: LD_INT 25
44723: PUSH
44724: LD_INT 4
44726: PUSH
44727: EMPTY
44728: LIST
44729: LIST
44730: PUSH
44731: LD_INT 24
44733: PUSH
44734: LD_INT 251
44736: PUSH
44737: EMPTY
44738: LIST
44739: LIST
44740: PUSH
44741: EMPTY
44742: LIST
44743: LIST
44744: PPUSH
44745: CALL_OW 72
44749: ST_TO_ADDR
// if mc_is_defending [ base ] then
44750: LD_EXP 145
44754: PUSH
44755: LD_VAR 0 1
44759: ARRAY
44760: IFFALSE 45221
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
44762: LD_ADDR_EXP 144
44766: PUSH
44767: LD_EXP 144
44771: PPUSH
44772: LD_VAR 0 1
44776: PPUSH
44777: LD_INT 4
44779: PPUSH
44780: CALL_OW 1
44784: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
44785: LD_ADDR_VAR 0 12
44789: PUSH
44790: LD_EXP 102
44794: PUSH
44795: LD_VAR 0 1
44799: ARRAY
44800: PPUSH
44801: LD_INT 2
44803: PUSH
44804: LD_INT 30
44806: PUSH
44807: LD_INT 4
44809: PUSH
44810: EMPTY
44811: LIST
44812: LIST
44813: PUSH
44814: LD_INT 30
44816: PUSH
44817: LD_INT 5
44819: PUSH
44820: EMPTY
44821: LIST
44822: LIST
44823: PUSH
44824: EMPTY
44825: LIST
44826: LIST
44827: LIST
44828: PPUSH
44829: CALL_OW 72
44833: ST_TO_ADDR
// if not b then
44834: LD_VAR 0 12
44838: NOT
44839: IFFALSE 44843
// exit ;
44841: GO 47909
// p := [ ] ;
44843: LD_ADDR_VAR 0 11
44847: PUSH
44848: EMPTY
44849: ST_TO_ADDR
// if sci >= 2 then
44850: LD_VAR 0 8
44854: PUSH
44855: LD_INT 2
44857: GREATEREQUAL
44858: IFFALSE 44889
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
44860: LD_ADDR_VAR 0 8
44864: PUSH
44865: LD_VAR 0 8
44869: PUSH
44870: LD_INT 1
44872: ARRAY
44873: PUSH
44874: LD_VAR 0 8
44878: PUSH
44879: LD_INT 2
44881: ARRAY
44882: PUSH
44883: EMPTY
44884: LIST
44885: LIST
44886: ST_TO_ADDR
44887: GO 44950
// if sci = 1 then
44889: LD_VAR 0 8
44893: PUSH
44894: LD_INT 1
44896: EQUAL
44897: IFFALSE 44918
// sci := [ sci [ 1 ] ] else
44899: LD_ADDR_VAR 0 8
44903: PUSH
44904: LD_VAR 0 8
44908: PUSH
44909: LD_INT 1
44911: ARRAY
44912: PUSH
44913: EMPTY
44914: LIST
44915: ST_TO_ADDR
44916: GO 44950
// if sci = 0 then
44918: LD_VAR 0 8
44922: PUSH
44923: LD_INT 0
44925: EQUAL
44926: IFFALSE 44950
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
44928: LD_ADDR_VAR 0 11
44932: PUSH
44933: LD_VAR 0 4
44937: PPUSH
44938: LD_INT 4
44940: PPUSH
44941: CALL 106467 0 2
44945: PUSH
44946: LD_INT 1
44948: ARRAY
44949: ST_TO_ADDR
// if eng > 4 then
44950: LD_VAR 0 6
44954: PUSH
44955: LD_INT 4
44957: GREATER
44958: IFFALSE 45004
// for i = eng downto 4 do
44960: LD_ADDR_VAR 0 3
44964: PUSH
44965: DOUBLE
44966: LD_VAR 0 6
44970: INC
44971: ST_TO_ADDR
44972: LD_INT 4
44974: PUSH
44975: FOR_DOWNTO
44976: IFFALSE 45002
// eng := eng diff eng [ i ] ;
44978: LD_ADDR_VAR 0 6
44982: PUSH
44983: LD_VAR 0 6
44987: PUSH
44988: LD_VAR 0 6
44992: PUSH
44993: LD_VAR 0 3
44997: ARRAY
44998: DIFF
44999: ST_TO_ADDR
45000: GO 44975
45002: POP
45003: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
45004: LD_ADDR_VAR 0 4
45008: PUSH
45009: LD_VAR 0 4
45013: PUSH
45014: LD_VAR 0 5
45018: PUSH
45019: LD_VAR 0 6
45023: UNION
45024: PUSH
45025: LD_VAR 0 7
45029: UNION
45030: PUSH
45031: LD_VAR 0 8
45035: UNION
45036: DIFF
45037: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
45038: LD_ADDR_VAR 0 13
45042: PUSH
45043: LD_EXP 102
45047: PUSH
45048: LD_VAR 0 1
45052: ARRAY
45053: PPUSH
45054: LD_INT 2
45056: PUSH
45057: LD_INT 30
45059: PUSH
45060: LD_INT 32
45062: PUSH
45063: EMPTY
45064: LIST
45065: LIST
45066: PUSH
45067: LD_INT 30
45069: PUSH
45070: LD_INT 31
45072: PUSH
45073: EMPTY
45074: LIST
45075: LIST
45076: PUSH
45077: EMPTY
45078: LIST
45079: LIST
45080: LIST
45081: PPUSH
45082: CALL_OW 72
45086: PUSH
45087: LD_EXP 102
45091: PUSH
45092: LD_VAR 0 1
45096: ARRAY
45097: PPUSH
45098: LD_INT 2
45100: PUSH
45101: LD_INT 30
45103: PUSH
45104: LD_INT 4
45106: PUSH
45107: EMPTY
45108: LIST
45109: LIST
45110: PUSH
45111: LD_INT 30
45113: PUSH
45114: LD_INT 5
45116: PUSH
45117: EMPTY
45118: LIST
45119: LIST
45120: PUSH
45121: EMPTY
45122: LIST
45123: LIST
45124: LIST
45125: PPUSH
45126: CALL_OW 72
45130: PUSH
45131: LD_INT 6
45133: MUL
45134: PLUS
45135: ST_TO_ADDR
// if bcount < tmp then
45136: LD_VAR 0 13
45140: PUSH
45141: LD_VAR 0 4
45145: LESS
45146: IFFALSE 45192
// for i = tmp downto bcount do
45148: LD_ADDR_VAR 0 3
45152: PUSH
45153: DOUBLE
45154: LD_VAR 0 4
45158: INC
45159: ST_TO_ADDR
45160: LD_VAR 0 13
45164: PUSH
45165: FOR_DOWNTO
45166: IFFALSE 45190
// tmp := Delete ( tmp , tmp ) ;
45168: LD_ADDR_VAR 0 4
45172: PUSH
45173: LD_VAR 0 4
45177: PPUSH
45178: LD_VAR 0 4
45182: PPUSH
45183: CALL_OW 3
45187: ST_TO_ADDR
45188: GO 45165
45190: POP
45191: POP
// result := [ tmp , 0 , 0 , p ] ;
45192: LD_ADDR_VAR 0 2
45196: PUSH
45197: LD_VAR 0 4
45201: PUSH
45202: LD_INT 0
45204: PUSH
45205: LD_INT 0
45207: PUSH
45208: LD_VAR 0 11
45212: PUSH
45213: EMPTY
45214: LIST
45215: LIST
45216: LIST
45217: LIST
45218: ST_TO_ADDR
// exit ;
45219: GO 47909
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
45221: LD_EXP 102
45225: PUSH
45226: LD_VAR 0 1
45230: ARRAY
45231: PPUSH
45232: LD_INT 2
45234: PUSH
45235: LD_INT 30
45237: PUSH
45238: LD_INT 6
45240: PUSH
45241: EMPTY
45242: LIST
45243: LIST
45244: PUSH
45245: LD_INT 30
45247: PUSH
45248: LD_INT 7
45250: PUSH
45251: EMPTY
45252: LIST
45253: LIST
45254: PUSH
45255: LD_INT 30
45257: PUSH
45258: LD_INT 8
45260: PUSH
45261: EMPTY
45262: LIST
45263: LIST
45264: PUSH
45265: EMPTY
45266: LIST
45267: LIST
45268: LIST
45269: LIST
45270: PPUSH
45271: CALL_OW 72
45275: NOT
45276: PUSH
45277: LD_EXP 102
45281: PUSH
45282: LD_VAR 0 1
45286: ARRAY
45287: PPUSH
45288: LD_INT 30
45290: PUSH
45291: LD_INT 3
45293: PUSH
45294: EMPTY
45295: LIST
45296: LIST
45297: PPUSH
45298: CALL_OW 72
45302: NOT
45303: AND
45304: IFFALSE 45376
// begin if eng = tmp then
45306: LD_VAR 0 6
45310: PUSH
45311: LD_VAR 0 4
45315: EQUAL
45316: IFFALSE 45320
// exit ;
45318: GO 47909
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
45320: LD_ADDR_EXP 144
45324: PUSH
45325: LD_EXP 144
45329: PPUSH
45330: LD_VAR 0 1
45334: PPUSH
45335: LD_INT 1
45337: PPUSH
45338: CALL_OW 1
45342: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
45343: LD_ADDR_VAR 0 2
45347: PUSH
45348: LD_INT 0
45350: PUSH
45351: LD_VAR 0 4
45355: PUSH
45356: LD_VAR 0 6
45360: DIFF
45361: PUSH
45362: LD_INT 0
45364: PUSH
45365: LD_INT 0
45367: PUSH
45368: EMPTY
45369: LIST
45370: LIST
45371: LIST
45372: LIST
45373: ST_TO_ADDR
// exit ;
45374: GO 47909
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
45376: LD_EXP 129
45380: PUSH
45381: LD_EXP 128
45385: PUSH
45386: LD_VAR 0 1
45390: ARRAY
45391: ARRAY
45392: PUSH
45393: LD_EXP 102
45397: PUSH
45398: LD_VAR 0 1
45402: ARRAY
45403: PPUSH
45404: LD_INT 2
45406: PUSH
45407: LD_INT 30
45409: PUSH
45410: LD_INT 6
45412: PUSH
45413: EMPTY
45414: LIST
45415: LIST
45416: PUSH
45417: LD_INT 30
45419: PUSH
45420: LD_INT 7
45422: PUSH
45423: EMPTY
45424: LIST
45425: LIST
45426: PUSH
45427: LD_INT 30
45429: PUSH
45430: LD_INT 8
45432: PUSH
45433: EMPTY
45434: LIST
45435: LIST
45436: PUSH
45437: EMPTY
45438: LIST
45439: LIST
45440: LIST
45441: LIST
45442: PPUSH
45443: CALL_OW 72
45447: AND
45448: PUSH
45449: LD_EXP 102
45453: PUSH
45454: LD_VAR 0 1
45458: ARRAY
45459: PPUSH
45460: LD_INT 30
45462: PUSH
45463: LD_INT 3
45465: PUSH
45466: EMPTY
45467: LIST
45468: LIST
45469: PPUSH
45470: CALL_OW 72
45474: NOT
45475: AND
45476: IFFALSE 45690
// begin if sci >= 6 then
45478: LD_VAR 0 8
45482: PUSH
45483: LD_INT 6
45485: GREATEREQUAL
45486: IFFALSE 45490
// exit ;
45488: GO 47909
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
45490: LD_ADDR_EXP 144
45494: PUSH
45495: LD_EXP 144
45499: PPUSH
45500: LD_VAR 0 1
45504: PPUSH
45505: LD_INT 2
45507: PPUSH
45508: CALL_OW 1
45512: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
45513: LD_ADDR_VAR 0 9
45517: PUSH
45518: LD_VAR 0 4
45522: PUSH
45523: LD_VAR 0 8
45527: DIFF
45528: PPUSH
45529: LD_INT 4
45531: PPUSH
45532: CALL 106467 0 2
45536: ST_TO_ADDR
// p := [ ] ;
45537: LD_ADDR_VAR 0 11
45541: PUSH
45542: EMPTY
45543: ST_TO_ADDR
// if sci < 6 and sort > 6 then
45544: LD_VAR 0 8
45548: PUSH
45549: LD_INT 6
45551: LESS
45552: PUSH
45553: LD_VAR 0 9
45557: PUSH
45558: LD_INT 6
45560: GREATER
45561: AND
45562: IFFALSE 45643
// begin for i = 1 to 6 - sci do
45564: LD_ADDR_VAR 0 3
45568: PUSH
45569: DOUBLE
45570: LD_INT 1
45572: DEC
45573: ST_TO_ADDR
45574: LD_INT 6
45576: PUSH
45577: LD_VAR 0 8
45581: MINUS
45582: PUSH
45583: FOR_TO
45584: IFFALSE 45639
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
45586: LD_ADDR_VAR 0 11
45590: PUSH
45591: LD_VAR 0 11
45595: PPUSH
45596: LD_VAR 0 11
45600: PUSH
45601: LD_INT 1
45603: PLUS
45604: PPUSH
45605: LD_VAR 0 9
45609: PUSH
45610: LD_INT 1
45612: ARRAY
45613: PPUSH
45614: CALL_OW 2
45618: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
45619: LD_ADDR_VAR 0 9
45623: PUSH
45624: LD_VAR 0 9
45628: PPUSH
45629: LD_INT 1
45631: PPUSH
45632: CALL_OW 3
45636: ST_TO_ADDR
// end ;
45637: GO 45583
45639: POP
45640: POP
// end else
45641: GO 45663
// if sort then
45643: LD_VAR 0 9
45647: IFFALSE 45663
// p := sort [ 1 ] ;
45649: LD_ADDR_VAR 0 11
45653: PUSH
45654: LD_VAR 0 9
45658: PUSH
45659: LD_INT 1
45661: ARRAY
45662: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
45663: LD_ADDR_VAR 0 2
45667: PUSH
45668: LD_INT 0
45670: PUSH
45671: LD_INT 0
45673: PUSH
45674: LD_INT 0
45676: PUSH
45677: LD_VAR 0 11
45681: PUSH
45682: EMPTY
45683: LIST
45684: LIST
45685: LIST
45686: LIST
45687: ST_TO_ADDR
// exit ;
45688: GO 47909
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
45690: LD_EXP 129
45694: PUSH
45695: LD_EXP 128
45699: PUSH
45700: LD_VAR 0 1
45704: ARRAY
45705: ARRAY
45706: PUSH
45707: LD_EXP 102
45711: PUSH
45712: LD_VAR 0 1
45716: ARRAY
45717: PPUSH
45718: LD_INT 2
45720: PUSH
45721: LD_INT 30
45723: PUSH
45724: LD_INT 6
45726: PUSH
45727: EMPTY
45728: LIST
45729: LIST
45730: PUSH
45731: LD_INT 30
45733: PUSH
45734: LD_INT 7
45736: PUSH
45737: EMPTY
45738: LIST
45739: LIST
45740: PUSH
45741: LD_INT 30
45743: PUSH
45744: LD_INT 8
45746: PUSH
45747: EMPTY
45748: LIST
45749: LIST
45750: PUSH
45751: EMPTY
45752: LIST
45753: LIST
45754: LIST
45755: LIST
45756: PPUSH
45757: CALL_OW 72
45761: AND
45762: PUSH
45763: LD_EXP 102
45767: PUSH
45768: LD_VAR 0 1
45772: ARRAY
45773: PPUSH
45774: LD_INT 30
45776: PUSH
45777: LD_INT 3
45779: PUSH
45780: EMPTY
45781: LIST
45782: LIST
45783: PPUSH
45784: CALL_OW 72
45788: AND
45789: IFFALSE 46523
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
45791: LD_ADDR_EXP 144
45795: PUSH
45796: LD_EXP 144
45800: PPUSH
45801: LD_VAR 0 1
45805: PPUSH
45806: LD_INT 3
45808: PPUSH
45809: CALL_OW 1
45813: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
45814: LD_ADDR_VAR 0 2
45818: PUSH
45819: LD_INT 0
45821: PUSH
45822: LD_INT 0
45824: PUSH
45825: LD_INT 0
45827: PUSH
45828: LD_INT 0
45830: PUSH
45831: EMPTY
45832: LIST
45833: LIST
45834: LIST
45835: LIST
45836: ST_TO_ADDR
// if not eng then
45837: LD_VAR 0 6
45841: NOT
45842: IFFALSE 45905
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
45844: LD_ADDR_VAR 0 11
45848: PUSH
45849: LD_VAR 0 4
45853: PPUSH
45854: LD_INT 2
45856: PPUSH
45857: CALL 106467 0 2
45861: PUSH
45862: LD_INT 1
45864: ARRAY
45865: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
45866: LD_ADDR_VAR 0 2
45870: PUSH
45871: LD_VAR 0 2
45875: PPUSH
45876: LD_INT 2
45878: PPUSH
45879: LD_VAR 0 11
45883: PPUSH
45884: CALL_OW 1
45888: ST_TO_ADDR
// tmp := tmp diff p ;
45889: LD_ADDR_VAR 0 4
45893: PUSH
45894: LD_VAR 0 4
45898: PUSH
45899: LD_VAR 0 11
45903: DIFF
45904: ST_TO_ADDR
// end ; if tmp and sci < 6 then
45905: LD_VAR 0 4
45909: PUSH
45910: LD_VAR 0 8
45914: PUSH
45915: LD_INT 6
45917: LESS
45918: AND
45919: IFFALSE 46107
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
45921: LD_ADDR_VAR 0 9
45925: PUSH
45926: LD_VAR 0 4
45930: PUSH
45931: LD_VAR 0 8
45935: PUSH
45936: LD_VAR 0 7
45940: UNION
45941: DIFF
45942: PPUSH
45943: LD_INT 4
45945: PPUSH
45946: CALL 106467 0 2
45950: ST_TO_ADDR
// p := [ ] ;
45951: LD_ADDR_VAR 0 11
45955: PUSH
45956: EMPTY
45957: ST_TO_ADDR
// if sort then
45958: LD_VAR 0 9
45962: IFFALSE 46078
// for i = 1 to 6 - sci do
45964: LD_ADDR_VAR 0 3
45968: PUSH
45969: DOUBLE
45970: LD_INT 1
45972: DEC
45973: ST_TO_ADDR
45974: LD_INT 6
45976: PUSH
45977: LD_VAR 0 8
45981: MINUS
45982: PUSH
45983: FOR_TO
45984: IFFALSE 46076
// begin if i = sort then
45986: LD_VAR 0 3
45990: PUSH
45991: LD_VAR 0 9
45995: EQUAL
45996: IFFALSE 46000
// break ;
45998: GO 46076
// if GetClass ( i ) = 4 then
46000: LD_VAR 0 3
46004: PPUSH
46005: CALL_OW 257
46009: PUSH
46010: LD_INT 4
46012: EQUAL
46013: IFFALSE 46017
// continue ;
46015: GO 45983
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46017: LD_ADDR_VAR 0 11
46021: PUSH
46022: LD_VAR 0 11
46026: PPUSH
46027: LD_VAR 0 11
46031: PUSH
46032: LD_INT 1
46034: PLUS
46035: PPUSH
46036: LD_VAR 0 9
46040: PUSH
46041: LD_VAR 0 3
46045: ARRAY
46046: PPUSH
46047: CALL_OW 2
46051: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46052: LD_ADDR_VAR 0 4
46056: PUSH
46057: LD_VAR 0 4
46061: PUSH
46062: LD_VAR 0 9
46066: PUSH
46067: LD_VAR 0 3
46071: ARRAY
46072: DIFF
46073: ST_TO_ADDR
// end ;
46074: GO 45983
46076: POP
46077: POP
// if p then
46078: LD_VAR 0 11
46082: IFFALSE 46107
// result := Replace ( result , 4 , p ) ;
46084: LD_ADDR_VAR 0 2
46088: PUSH
46089: LD_VAR 0 2
46093: PPUSH
46094: LD_INT 4
46096: PPUSH
46097: LD_VAR 0 11
46101: PPUSH
46102: CALL_OW 1
46106: ST_TO_ADDR
// end ; if tmp and mech < 6 then
46107: LD_VAR 0 4
46111: PUSH
46112: LD_VAR 0 7
46116: PUSH
46117: LD_INT 6
46119: LESS
46120: AND
46121: IFFALSE 46309
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
46123: LD_ADDR_VAR 0 9
46127: PUSH
46128: LD_VAR 0 4
46132: PUSH
46133: LD_VAR 0 8
46137: PUSH
46138: LD_VAR 0 7
46142: UNION
46143: DIFF
46144: PPUSH
46145: LD_INT 3
46147: PPUSH
46148: CALL 106467 0 2
46152: ST_TO_ADDR
// p := [ ] ;
46153: LD_ADDR_VAR 0 11
46157: PUSH
46158: EMPTY
46159: ST_TO_ADDR
// if sort then
46160: LD_VAR 0 9
46164: IFFALSE 46280
// for i = 1 to 6 - mech do
46166: LD_ADDR_VAR 0 3
46170: PUSH
46171: DOUBLE
46172: LD_INT 1
46174: DEC
46175: ST_TO_ADDR
46176: LD_INT 6
46178: PUSH
46179: LD_VAR 0 7
46183: MINUS
46184: PUSH
46185: FOR_TO
46186: IFFALSE 46278
// begin if i = sort then
46188: LD_VAR 0 3
46192: PUSH
46193: LD_VAR 0 9
46197: EQUAL
46198: IFFALSE 46202
// break ;
46200: GO 46278
// if GetClass ( i ) = 3 then
46202: LD_VAR 0 3
46206: PPUSH
46207: CALL_OW 257
46211: PUSH
46212: LD_INT 3
46214: EQUAL
46215: IFFALSE 46219
// continue ;
46217: GO 46185
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46219: LD_ADDR_VAR 0 11
46223: PUSH
46224: LD_VAR 0 11
46228: PPUSH
46229: LD_VAR 0 11
46233: PUSH
46234: LD_INT 1
46236: PLUS
46237: PPUSH
46238: LD_VAR 0 9
46242: PUSH
46243: LD_VAR 0 3
46247: ARRAY
46248: PPUSH
46249: CALL_OW 2
46253: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46254: LD_ADDR_VAR 0 4
46258: PUSH
46259: LD_VAR 0 4
46263: PUSH
46264: LD_VAR 0 9
46268: PUSH
46269: LD_VAR 0 3
46273: ARRAY
46274: DIFF
46275: ST_TO_ADDR
// end ;
46276: GO 46185
46278: POP
46279: POP
// if p then
46280: LD_VAR 0 11
46284: IFFALSE 46309
// result := Replace ( result , 3 , p ) ;
46286: LD_ADDR_VAR 0 2
46290: PUSH
46291: LD_VAR 0 2
46295: PPUSH
46296: LD_INT 3
46298: PPUSH
46299: LD_VAR 0 11
46303: PPUSH
46304: CALL_OW 1
46308: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
46309: LD_VAR 0 4
46313: PUSH
46314: LD_INT 6
46316: GREATER
46317: PUSH
46318: LD_VAR 0 6
46322: PUSH
46323: LD_INT 6
46325: LESS
46326: AND
46327: IFFALSE 46521
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
46329: LD_ADDR_VAR 0 9
46333: PUSH
46334: LD_VAR 0 4
46338: PUSH
46339: LD_VAR 0 8
46343: PUSH
46344: LD_VAR 0 7
46348: UNION
46349: PUSH
46350: LD_VAR 0 6
46354: UNION
46355: DIFF
46356: PPUSH
46357: LD_INT 2
46359: PPUSH
46360: CALL 106467 0 2
46364: ST_TO_ADDR
// p := [ ] ;
46365: LD_ADDR_VAR 0 11
46369: PUSH
46370: EMPTY
46371: ST_TO_ADDR
// if sort then
46372: LD_VAR 0 9
46376: IFFALSE 46492
// for i = 1 to 6 - eng do
46378: LD_ADDR_VAR 0 3
46382: PUSH
46383: DOUBLE
46384: LD_INT 1
46386: DEC
46387: ST_TO_ADDR
46388: LD_INT 6
46390: PUSH
46391: LD_VAR 0 6
46395: MINUS
46396: PUSH
46397: FOR_TO
46398: IFFALSE 46490
// begin if i = sort then
46400: LD_VAR 0 3
46404: PUSH
46405: LD_VAR 0 9
46409: EQUAL
46410: IFFALSE 46414
// break ;
46412: GO 46490
// if GetClass ( i ) = 2 then
46414: LD_VAR 0 3
46418: PPUSH
46419: CALL_OW 257
46423: PUSH
46424: LD_INT 2
46426: EQUAL
46427: IFFALSE 46431
// continue ;
46429: GO 46397
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46431: LD_ADDR_VAR 0 11
46435: PUSH
46436: LD_VAR 0 11
46440: PPUSH
46441: LD_VAR 0 11
46445: PUSH
46446: LD_INT 1
46448: PLUS
46449: PPUSH
46450: LD_VAR 0 9
46454: PUSH
46455: LD_VAR 0 3
46459: ARRAY
46460: PPUSH
46461: CALL_OW 2
46465: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46466: LD_ADDR_VAR 0 4
46470: PUSH
46471: LD_VAR 0 4
46475: PUSH
46476: LD_VAR 0 9
46480: PUSH
46481: LD_VAR 0 3
46485: ARRAY
46486: DIFF
46487: ST_TO_ADDR
// end ;
46488: GO 46397
46490: POP
46491: POP
// if p then
46492: LD_VAR 0 11
46496: IFFALSE 46521
// result := Replace ( result , 2 , p ) ;
46498: LD_ADDR_VAR 0 2
46502: PUSH
46503: LD_VAR 0 2
46507: PPUSH
46508: LD_INT 2
46510: PPUSH
46511: LD_VAR 0 11
46515: PPUSH
46516: CALL_OW 1
46520: ST_TO_ADDR
// end ; exit ;
46521: GO 47909
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
46523: LD_EXP 129
46527: PUSH
46528: LD_EXP 128
46532: PUSH
46533: LD_VAR 0 1
46537: ARRAY
46538: ARRAY
46539: NOT
46540: PUSH
46541: LD_EXP 102
46545: PUSH
46546: LD_VAR 0 1
46550: ARRAY
46551: PPUSH
46552: LD_INT 30
46554: PUSH
46555: LD_INT 3
46557: PUSH
46558: EMPTY
46559: LIST
46560: LIST
46561: PPUSH
46562: CALL_OW 72
46566: AND
46567: PUSH
46568: LD_EXP 107
46572: PUSH
46573: LD_VAR 0 1
46577: ARRAY
46578: AND
46579: IFFALSE 47187
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
46581: LD_ADDR_EXP 144
46585: PUSH
46586: LD_EXP 144
46590: PPUSH
46591: LD_VAR 0 1
46595: PPUSH
46596: LD_INT 5
46598: PPUSH
46599: CALL_OW 1
46603: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
46604: LD_ADDR_VAR 0 2
46608: PUSH
46609: LD_INT 0
46611: PUSH
46612: LD_INT 0
46614: PUSH
46615: LD_INT 0
46617: PUSH
46618: LD_INT 0
46620: PUSH
46621: EMPTY
46622: LIST
46623: LIST
46624: LIST
46625: LIST
46626: ST_TO_ADDR
// if sci > 1 then
46627: LD_VAR 0 8
46631: PUSH
46632: LD_INT 1
46634: GREATER
46635: IFFALSE 46663
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
46637: LD_ADDR_VAR 0 4
46641: PUSH
46642: LD_VAR 0 4
46646: PUSH
46647: LD_VAR 0 8
46651: PUSH
46652: LD_VAR 0 8
46656: PUSH
46657: LD_INT 1
46659: ARRAY
46660: DIFF
46661: DIFF
46662: ST_TO_ADDR
// if tmp and not sci then
46663: LD_VAR 0 4
46667: PUSH
46668: LD_VAR 0 8
46672: NOT
46673: AND
46674: IFFALSE 46743
// begin sort := SortBySkill ( tmp , 4 ) ;
46676: LD_ADDR_VAR 0 9
46680: PUSH
46681: LD_VAR 0 4
46685: PPUSH
46686: LD_INT 4
46688: PPUSH
46689: CALL 106467 0 2
46693: ST_TO_ADDR
// if sort then
46694: LD_VAR 0 9
46698: IFFALSE 46714
// p := sort [ 1 ] ;
46700: LD_ADDR_VAR 0 11
46704: PUSH
46705: LD_VAR 0 9
46709: PUSH
46710: LD_INT 1
46712: ARRAY
46713: ST_TO_ADDR
// if p then
46714: LD_VAR 0 11
46718: IFFALSE 46743
// result := Replace ( result , 4 , p ) ;
46720: LD_ADDR_VAR 0 2
46724: PUSH
46725: LD_VAR 0 2
46729: PPUSH
46730: LD_INT 4
46732: PPUSH
46733: LD_VAR 0 11
46737: PPUSH
46738: CALL_OW 1
46742: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
46743: LD_ADDR_VAR 0 4
46747: PUSH
46748: LD_VAR 0 4
46752: PUSH
46753: LD_VAR 0 7
46757: DIFF
46758: ST_TO_ADDR
// if tmp and mech < 6 then
46759: LD_VAR 0 4
46763: PUSH
46764: LD_VAR 0 7
46768: PUSH
46769: LD_INT 6
46771: LESS
46772: AND
46773: IFFALSE 46961
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
46775: LD_ADDR_VAR 0 9
46779: PUSH
46780: LD_VAR 0 4
46784: PUSH
46785: LD_VAR 0 8
46789: PUSH
46790: LD_VAR 0 7
46794: UNION
46795: DIFF
46796: PPUSH
46797: LD_INT 3
46799: PPUSH
46800: CALL 106467 0 2
46804: ST_TO_ADDR
// p := [ ] ;
46805: LD_ADDR_VAR 0 11
46809: PUSH
46810: EMPTY
46811: ST_TO_ADDR
// if sort then
46812: LD_VAR 0 9
46816: IFFALSE 46932
// for i = 1 to 6 - mech do
46818: LD_ADDR_VAR 0 3
46822: PUSH
46823: DOUBLE
46824: LD_INT 1
46826: DEC
46827: ST_TO_ADDR
46828: LD_INT 6
46830: PUSH
46831: LD_VAR 0 7
46835: MINUS
46836: PUSH
46837: FOR_TO
46838: IFFALSE 46930
// begin if i = sort then
46840: LD_VAR 0 3
46844: PUSH
46845: LD_VAR 0 9
46849: EQUAL
46850: IFFALSE 46854
// break ;
46852: GO 46930
// if GetClass ( i ) = 3 then
46854: LD_VAR 0 3
46858: PPUSH
46859: CALL_OW 257
46863: PUSH
46864: LD_INT 3
46866: EQUAL
46867: IFFALSE 46871
// continue ;
46869: GO 46837
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46871: LD_ADDR_VAR 0 11
46875: PUSH
46876: LD_VAR 0 11
46880: PPUSH
46881: LD_VAR 0 11
46885: PUSH
46886: LD_INT 1
46888: PLUS
46889: PPUSH
46890: LD_VAR 0 9
46894: PUSH
46895: LD_VAR 0 3
46899: ARRAY
46900: PPUSH
46901: CALL_OW 2
46905: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46906: LD_ADDR_VAR 0 4
46910: PUSH
46911: LD_VAR 0 4
46915: PUSH
46916: LD_VAR 0 9
46920: PUSH
46921: LD_VAR 0 3
46925: ARRAY
46926: DIFF
46927: ST_TO_ADDR
// end ;
46928: GO 46837
46930: POP
46931: POP
// if p then
46932: LD_VAR 0 11
46936: IFFALSE 46961
// result := Replace ( result , 3 , p ) ;
46938: LD_ADDR_VAR 0 2
46942: PUSH
46943: LD_VAR 0 2
46947: PPUSH
46948: LD_INT 3
46950: PPUSH
46951: LD_VAR 0 11
46955: PPUSH
46956: CALL_OW 1
46960: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
46961: LD_ADDR_VAR 0 4
46965: PUSH
46966: LD_VAR 0 4
46970: PUSH
46971: LD_VAR 0 6
46975: DIFF
46976: ST_TO_ADDR
// if tmp and eng < 6 then
46977: LD_VAR 0 4
46981: PUSH
46982: LD_VAR 0 6
46986: PUSH
46987: LD_INT 6
46989: LESS
46990: AND
46991: IFFALSE 47185
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
46993: LD_ADDR_VAR 0 9
46997: PUSH
46998: LD_VAR 0 4
47002: PUSH
47003: LD_VAR 0 8
47007: PUSH
47008: LD_VAR 0 7
47012: UNION
47013: PUSH
47014: LD_VAR 0 6
47018: UNION
47019: DIFF
47020: PPUSH
47021: LD_INT 2
47023: PPUSH
47024: CALL 106467 0 2
47028: ST_TO_ADDR
// p := [ ] ;
47029: LD_ADDR_VAR 0 11
47033: PUSH
47034: EMPTY
47035: ST_TO_ADDR
// if sort then
47036: LD_VAR 0 9
47040: IFFALSE 47156
// for i = 1 to 6 - eng do
47042: LD_ADDR_VAR 0 3
47046: PUSH
47047: DOUBLE
47048: LD_INT 1
47050: DEC
47051: ST_TO_ADDR
47052: LD_INT 6
47054: PUSH
47055: LD_VAR 0 6
47059: MINUS
47060: PUSH
47061: FOR_TO
47062: IFFALSE 47154
// begin if i = sort then
47064: LD_VAR 0 3
47068: PUSH
47069: LD_VAR 0 9
47073: EQUAL
47074: IFFALSE 47078
// break ;
47076: GO 47154
// if GetClass ( i ) = 2 then
47078: LD_VAR 0 3
47082: PPUSH
47083: CALL_OW 257
47087: PUSH
47088: LD_INT 2
47090: EQUAL
47091: IFFALSE 47095
// continue ;
47093: GO 47061
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47095: LD_ADDR_VAR 0 11
47099: PUSH
47100: LD_VAR 0 11
47104: PPUSH
47105: LD_VAR 0 11
47109: PUSH
47110: LD_INT 1
47112: PLUS
47113: PPUSH
47114: LD_VAR 0 9
47118: PUSH
47119: LD_VAR 0 3
47123: ARRAY
47124: PPUSH
47125: CALL_OW 2
47129: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47130: LD_ADDR_VAR 0 4
47134: PUSH
47135: LD_VAR 0 4
47139: PUSH
47140: LD_VAR 0 9
47144: PUSH
47145: LD_VAR 0 3
47149: ARRAY
47150: DIFF
47151: ST_TO_ADDR
// end ;
47152: GO 47061
47154: POP
47155: POP
// if p then
47156: LD_VAR 0 11
47160: IFFALSE 47185
// result := Replace ( result , 2 , p ) ;
47162: LD_ADDR_VAR 0 2
47166: PUSH
47167: LD_VAR 0 2
47171: PPUSH
47172: LD_INT 2
47174: PPUSH
47175: LD_VAR 0 11
47179: PPUSH
47180: CALL_OW 1
47184: ST_TO_ADDR
// end ; exit ;
47185: GO 47909
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
47187: LD_EXP 129
47191: PUSH
47192: LD_EXP 128
47196: PUSH
47197: LD_VAR 0 1
47201: ARRAY
47202: ARRAY
47203: NOT
47204: PUSH
47205: LD_EXP 102
47209: PUSH
47210: LD_VAR 0 1
47214: ARRAY
47215: PPUSH
47216: LD_INT 30
47218: PUSH
47219: LD_INT 3
47221: PUSH
47222: EMPTY
47223: LIST
47224: LIST
47225: PPUSH
47226: CALL_OW 72
47230: AND
47231: PUSH
47232: LD_EXP 107
47236: PUSH
47237: LD_VAR 0 1
47241: ARRAY
47242: NOT
47243: AND
47244: IFFALSE 47909
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
47246: LD_ADDR_EXP 144
47250: PUSH
47251: LD_EXP 144
47255: PPUSH
47256: LD_VAR 0 1
47260: PPUSH
47261: LD_INT 6
47263: PPUSH
47264: CALL_OW 1
47268: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
47269: LD_ADDR_VAR 0 2
47273: PUSH
47274: LD_INT 0
47276: PUSH
47277: LD_INT 0
47279: PUSH
47280: LD_INT 0
47282: PUSH
47283: LD_INT 0
47285: PUSH
47286: EMPTY
47287: LIST
47288: LIST
47289: LIST
47290: LIST
47291: ST_TO_ADDR
// if sci >= 1 then
47292: LD_VAR 0 8
47296: PUSH
47297: LD_INT 1
47299: GREATEREQUAL
47300: IFFALSE 47322
// tmp := tmp diff sci [ 1 ] ;
47302: LD_ADDR_VAR 0 4
47306: PUSH
47307: LD_VAR 0 4
47311: PUSH
47312: LD_VAR 0 8
47316: PUSH
47317: LD_INT 1
47319: ARRAY
47320: DIFF
47321: ST_TO_ADDR
// if tmp and not sci then
47322: LD_VAR 0 4
47326: PUSH
47327: LD_VAR 0 8
47331: NOT
47332: AND
47333: IFFALSE 47402
// begin sort := SortBySkill ( tmp , 4 ) ;
47335: LD_ADDR_VAR 0 9
47339: PUSH
47340: LD_VAR 0 4
47344: PPUSH
47345: LD_INT 4
47347: PPUSH
47348: CALL 106467 0 2
47352: ST_TO_ADDR
// if sort then
47353: LD_VAR 0 9
47357: IFFALSE 47373
// p := sort [ 1 ] ;
47359: LD_ADDR_VAR 0 11
47363: PUSH
47364: LD_VAR 0 9
47368: PUSH
47369: LD_INT 1
47371: ARRAY
47372: ST_TO_ADDR
// if p then
47373: LD_VAR 0 11
47377: IFFALSE 47402
// result := Replace ( result , 4 , p ) ;
47379: LD_ADDR_VAR 0 2
47383: PUSH
47384: LD_VAR 0 2
47388: PPUSH
47389: LD_INT 4
47391: PPUSH
47392: LD_VAR 0 11
47396: PPUSH
47397: CALL_OW 1
47401: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
47402: LD_ADDR_VAR 0 4
47406: PUSH
47407: LD_VAR 0 4
47411: PUSH
47412: LD_VAR 0 7
47416: DIFF
47417: ST_TO_ADDR
// if tmp and mech < 6 then
47418: LD_VAR 0 4
47422: PUSH
47423: LD_VAR 0 7
47427: PUSH
47428: LD_INT 6
47430: LESS
47431: AND
47432: IFFALSE 47614
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
47434: LD_ADDR_VAR 0 9
47438: PUSH
47439: LD_VAR 0 4
47443: PUSH
47444: LD_VAR 0 7
47448: DIFF
47449: PPUSH
47450: LD_INT 3
47452: PPUSH
47453: CALL 106467 0 2
47457: ST_TO_ADDR
// p := [ ] ;
47458: LD_ADDR_VAR 0 11
47462: PUSH
47463: EMPTY
47464: ST_TO_ADDR
// if sort then
47465: LD_VAR 0 9
47469: IFFALSE 47585
// for i = 1 to 6 - mech do
47471: LD_ADDR_VAR 0 3
47475: PUSH
47476: DOUBLE
47477: LD_INT 1
47479: DEC
47480: ST_TO_ADDR
47481: LD_INT 6
47483: PUSH
47484: LD_VAR 0 7
47488: MINUS
47489: PUSH
47490: FOR_TO
47491: IFFALSE 47583
// begin if i = sort then
47493: LD_VAR 0 3
47497: PUSH
47498: LD_VAR 0 9
47502: EQUAL
47503: IFFALSE 47507
// break ;
47505: GO 47583
// if GetClass ( i ) = 3 then
47507: LD_VAR 0 3
47511: PPUSH
47512: CALL_OW 257
47516: PUSH
47517: LD_INT 3
47519: EQUAL
47520: IFFALSE 47524
// continue ;
47522: GO 47490
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47524: LD_ADDR_VAR 0 11
47528: PUSH
47529: LD_VAR 0 11
47533: PPUSH
47534: LD_VAR 0 11
47538: PUSH
47539: LD_INT 1
47541: PLUS
47542: PPUSH
47543: LD_VAR 0 9
47547: PUSH
47548: LD_VAR 0 3
47552: ARRAY
47553: PPUSH
47554: CALL_OW 2
47558: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47559: LD_ADDR_VAR 0 4
47563: PUSH
47564: LD_VAR 0 4
47568: PUSH
47569: LD_VAR 0 9
47573: PUSH
47574: LD_VAR 0 3
47578: ARRAY
47579: DIFF
47580: ST_TO_ADDR
// end ;
47581: GO 47490
47583: POP
47584: POP
// if p then
47585: LD_VAR 0 11
47589: IFFALSE 47614
// result := Replace ( result , 3 , p ) ;
47591: LD_ADDR_VAR 0 2
47595: PUSH
47596: LD_VAR 0 2
47600: PPUSH
47601: LD_INT 3
47603: PPUSH
47604: LD_VAR 0 11
47608: PPUSH
47609: CALL_OW 1
47613: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
47614: LD_ADDR_VAR 0 4
47618: PUSH
47619: LD_VAR 0 4
47623: PUSH
47624: LD_VAR 0 6
47628: DIFF
47629: ST_TO_ADDR
// if tmp and eng < 4 then
47630: LD_VAR 0 4
47634: PUSH
47635: LD_VAR 0 6
47639: PUSH
47640: LD_INT 4
47642: LESS
47643: AND
47644: IFFALSE 47834
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
47646: LD_ADDR_VAR 0 9
47650: PUSH
47651: LD_VAR 0 4
47655: PUSH
47656: LD_VAR 0 7
47660: PUSH
47661: LD_VAR 0 6
47665: UNION
47666: DIFF
47667: PPUSH
47668: LD_INT 2
47670: PPUSH
47671: CALL 106467 0 2
47675: ST_TO_ADDR
// p := [ ] ;
47676: LD_ADDR_VAR 0 11
47680: PUSH
47681: EMPTY
47682: ST_TO_ADDR
// if sort then
47683: LD_VAR 0 9
47687: IFFALSE 47803
// for i = 1 to 4 - eng do
47689: LD_ADDR_VAR 0 3
47693: PUSH
47694: DOUBLE
47695: LD_INT 1
47697: DEC
47698: ST_TO_ADDR
47699: LD_INT 4
47701: PUSH
47702: LD_VAR 0 6
47706: MINUS
47707: PUSH
47708: FOR_TO
47709: IFFALSE 47801
// begin if i = sort then
47711: LD_VAR 0 3
47715: PUSH
47716: LD_VAR 0 9
47720: EQUAL
47721: IFFALSE 47725
// break ;
47723: GO 47801
// if GetClass ( i ) = 2 then
47725: LD_VAR 0 3
47729: PPUSH
47730: CALL_OW 257
47734: PUSH
47735: LD_INT 2
47737: EQUAL
47738: IFFALSE 47742
// continue ;
47740: GO 47708
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47742: LD_ADDR_VAR 0 11
47746: PUSH
47747: LD_VAR 0 11
47751: PPUSH
47752: LD_VAR 0 11
47756: PUSH
47757: LD_INT 1
47759: PLUS
47760: PPUSH
47761: LD_VAR 0 9
47765: PUSH
47766: LD_VAR 0 3
47770: ARRAY
47771: PPUSH
47772: CALL_OW 2
47776: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47777: LD_ADDR_VAR 0 4
47781: PUSH
47782: LD_VAR 0 4
47786: PUSH
47787: LD_VAR 0 9
47791: PUSH
47792: LD_VAR 0 3
47796: ARRAY
47797: DIFF
47798: ST_TO_ADDR
// end ;
47799: GO 47708
47801: POP
47802: POP
// if p then
47803: LD_VAR 0 11
47807: IFFALSE 47832
// result := Replace ( result , 2 , p ) ;
47809: LD_ADDR_VAR 0 2
47813: PUSH
47814: LD_VAR 0 2
47818: PPUSH
47819: LD_INT 2
47821: PPUSH
47822: LD_VAR 0 11
47826: PPUSH
47827: CALL_OW 1
47831: ST_TO_ADDR
// end else
47832: GO 47878
// for i = eng downto 5 do
47834: LD_ADDR_VAR 0 3
47838: PUSH
47839: DOUBLE
47840: LD_VAR 0 6
47844: INC
47845: ST_TO_ADDR
47846: LD_INT 5
47848: PUSH
47849: FOR_DOWNTO
47850: IFFALSE 47876
// tmp := tmp union eng [ i ] ;
47852: LD_ADDR_VAR 0 4
47856: PUSH
47857: LD_VAR 0 4
47861: PUSH
47862: LD_VAR 0 6
47866: PUSH
47867: LD_VAR 0 3
47871: ARRAY
47872: UNION
47873: ST_TO_ADDR
47874: GO 47849
47876: POP
47877: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
47878: LD_ADDR_VAR 0 2
47882: PUSH
47883: LD_VAR 0 2
47887: PPUSH
47888: LD_INT 1
47890: PPUSH
47891: LD_VAR 0 4
47895: PUSH
47896: LD_VAR 0 5
47900: DIFF
47901: PPUSH
47902: CALL_OW 1
47906: ST_TO_ADDR
// exit ;
47907: GO 47909
// end ; end ;
47909: LD_VAR 0 2
47913: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
47914: LD_INT 0
47916: PPUSH
47917: PPUSH
47918: PPUSH
// if not mc_bases then
47919: LD_EXP 102
47923: NOT
47924: IFFALSE 47928
// exit ;
47926: GO 48070
// for i = 1 to mc_bases do
47928: LD_ADDR_VAR 0 2
47932: PUSH
47933: DOUBLE
47934: LD_INT 1
47936: DEC
47937: ST_TO_ADDR
47938: LD_EXP 102
47942: PUSH
47943: FOR_TO
47944: IFFALSE 48061
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
47946: LD_ADDR_VAR 0 3
47950: PUSH
47951: LD_EXP 102
47955: PUSH
47956: LD_VAR 0 2
47960: ARRAY
47961: PPUSH
47962: LD_INT 21
47964: PUSH
47965: LD_INT 3
47967: PUSH
47968: EMPTY
47969: LIST
47970: LIST
47971: PUSH
47972: LD_INT 3
47974: PUSH
47975: LD_INT 2
47977: PUSH
47978: LD_INT 30
47980: PUSH
47981: LD_INT 29
47983: PUSH
47984: EMPTY
47985: LIST
47986: LIST
47987: PUSH
47988: LD_INT 30
47990: PUSH
47991: LD_INT 30
47993: PUSH
47994: EMPTY
47995: LIST
47996: LIST
47997: PUSH
47998: EMPTY
47999: LIST
48000: LIST
48001: LIST
48002: PUSH
48003: EMPTY
48004: LIST
48005: LIST
48006: PUSH
48007: LD_INT 3
48009: PUSH
48010: LD_INT 24
48012: PUSH
48013: LD_INT 1000
48015: PUSH
48016: EMPTY
48017: LIST
48018: LIST
48019: PUSH
48020: EMPTY
48021: LIST
48022: LIST
48023: PUSH
48024: EMPTY
48025: LIST
48026: LIST
48027: LIST
48028: PPUSH
48029: CALL_OW 72
48033: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
48034: LD_ADDR_EXP 103
48038: PUSH
48039: LD_EXP 103
48043: PPUSH
48044: LD_VAR 0 2
48048: PPUSH
48049: LD_VAR 0 3
48053: PPUSH
48054: CALL_OW 1
48058: ST_TO_ADDR
// end ;
48059: GO 47943
48061: POP
48062: POP
// RaiseSailEvent ( 101 ) ;
48063: LD_INT 101
48065: PPUSH
48066: CALL_OW 427
// end ;
48070: LD_VAR 0 1
48074: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
48075: LD_INT 0
48077: PPUSH
48078: PPUSH
48079: PPUSH
48080: PPUSH
48081: PPUSH
48082: PPUSH
48083: PPUSH
// if not mc_bases then
48084: LD_EXP 102
48088: NOT
48089: IFFALSE 48093
// exit ;
48091: GO 48655
// for i = 1 to mc_bases do
48093: LD_ADDR_VAR 0 2
48097: PUSH
48098: DOUBLE
48099: LD_INT 1
48101: DEC
48102: ST_TO_ADDR
48103: LD_EXP 102
48107: PUSH
48108: FOR_TO
48109: IFFALSE 48646
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
48111: LD_ADDR_VAR 0 5
48115: PUSH
48116: LD_EXP 102
48120: PUSH
48121: LD_VAR 0 2
48125: ARRAY
48126: PUSH
48127: LD_EXP 131
48131: PUSH
48132: LD_VAR 0 2
48136: ARRAY
48137: UNION
48138: PPUSH
48139: LD_INT 21
48141: PUSH
48142: LD_INT 1
48144: PUSH
48145: EMPTY
48146: LIST
48147: LIST
48148: PUSH
48149: LD_INT 1
48151: PUSH
48152: LD_INT 3
48154: PUSH
48155: LD_INT 54
48157: PUSH
48158: EMPTY
48159: LIST
48160: PUSH
48161: EMPTY
48162: LIST
48163: LIST
48164: PUSH
48165: LD_INT 3
48167: PUSH
48168: LD_INT 24
48170: PUSH
48171: LD_INT 1000
48173: PUSH
48174: EMPTY
48175: LIST
48176: LIST
48177: PUSH
48178: EMPTY
48179: LIST
48180: LIST
48181: PUSH
48182: EMPTY
48183: LIST
48184: LIST
48185: LIST
48186: PUSH
48187: EMPTY
48188: LIST
48189: LIST
48190: PPUSH
48191: CALL_OW 72
48195: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
48196: LD_ADDR_VAR 0 6
48200: PUSH
48201: LD_EXP 102
48205: PUSH
48206: LD_VAR 0 2
48210: ARRAY
48211: PPUSH
48212: LD_INT 21
48214: PUSH
48215: LD_INT 1
48217: PUSH
48218: EMPTY
48219: LIST
48220: LIST
48221: PUSH
48222: LD_INT 1
48224: PUSH
48225: LD_INT 3
48227: PUSH
48228: LD_INT 54
48230: PUSH
48231: EMPTY
48232: LIST
48233: PUSH
48234: EMPTY
48235: LIST
48236: LIST
48237: PUSH
48238: LD_INT 3
48240: PUSH
48241: LD_INT 24
48243: PUSH
48244: LD_INT 250
48246: PUSH
48247: EMPTY
48248: LIST
48249: LIST
48250: PUSH
48251: EMPTY
48252: LIST
48253: LIST
48254: PUSH
48255: EMPTY
48256: LIST
48257: LIST
48258: LIST
48259: PUSH
48260: EMPTY
48261: LIST
48262: LIST
48263: PPUSH
48264: CALL_OW 72
48268: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
48269: LD_ADDR_VAR 0 7
48273: PUSH
48274: LD_VAR 0 5
48278: PUSH
48279: LD_VAR 0 6
48283: DIFF
48284: ST_TO_ADDR
// if not need_heal_1 then
48285: LD_VAR 0 6
48289: NOT
48290: IFFALSE 48323
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
48292: LD_ADDR_EXP 105
48296: PUSH
48297: LD_EXP 105
48301: PPUSH
48302: LD_VAR 0 2
48306: PUSH
48307: LD_INT 1
48309: PUSH
48310: EMPTY
48311: LIST
48312: LIST
48313: PPUSH
48314: EMPTY
48315: PPUSH
48316: CALL 75234 0 3
48320: ST_TO_ADDR
48321: GO 48393
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
48323: LD_ADDR_EXP 105
48327: PUSH
48328: LD_EXP 105
48332: PPUSH
48333: LD_VAR 0 2
48337: PUSH
48338: LD_INT 1
48340: PUSH
48341: EMPTY
48342: LIST
48343: LIST
48344: PPUSH
48345: LD_EXP 105
48349: PUSH
48350: LD_VAR 0 2
48354: ARRAY
48355: PUSH
48356: LD_INT 1
48358: ARRAY
48359: PPUSH
48360: LD_INT 3
48362: PUSH
48363: LD_INT 24
48365: PUSH
48366: LD_INT 1000
48368: PUSH
48369: EMPTY
48370: LIST
48371: LIST
48372: PUSH
48373: EMPTY
48374: LIST
48375: LIST
48376: PPUSH
48377: CALL_OW 72
48381: PUSH
48382: LD_VAR 0 6
48386: UNION
48387: PPUSH
48388: CALL 75234 0 3
48392: ST_TO_ADDR
// if not need_heal_2 then
48393: LD_VAR 0 7
48397: NOT
48398: IFFALSE 48431
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
48400: LD_ADDR_EXP 105
48404: PUSH
48405: LD_EXP 105
48409: PPUSH
48410: LD_VAR 0 2
48414: PUSH
48415: LD_INT 2
48417: PUSH
48418: EMPTY
48419: LIST
48420: LIST
48421: PPUSH
48422: EMPTY
48423: PPUSH
48424: CALL 75234 0 3
48428: ST_TO_ADDR
48429: GO 48463
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
48431: LD_ADDR_EXP 105
48435: PUSH
48436: LD_EXP 105
48440: PPUSH
48441: LD_VAR 0 2
48445: PUSH
48446: LD_INT 2
48448: PUSH
48449: EMPTY
48450: LIST
48451: LIST
48452: PPUSH
48453: LD_VAR 0 7
48457: PPUSH
48458: CALL 75234 0 3
48462: ST_TO_ADDR
// if need_heal_2 then
48463: LD_VAR 0 7
48467: IFFALSE 48628
// for j in need_heal_2 do
48469: LD_ADDR_VAR 0 3
48473: PUSH
48474: LD_VAR 0 7
48478: PUSH
48479: FOR_IN
48480: IFFALSE 48626
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48482: LD_ADDR_VAR 0 5
48486: PUSH
48487: LD_EXP 102
48491: PUSH
48492: LD_VAR 0 2
48496: ARRAY
48497: PPUSH
48498: LD_INT 2
48500: PUSH
48501: LD_INT 30
48503: PUSH
48504: LD_INT 6
48506: PUSH
48507: EMPTY
48508: LIST
48509: LIST
48510: PUSH
48511: LD_INT 30
48513: PUSH
48514: LD_INT 7
48516: PUSH
48517: EMPTY
48518: LIST
48519: LIST
48520: PUSH
48521: LD_INT 30
48523: PUSH
48524: LD_INT 8
48526: PUSH
48527: EMPTY
48528: LIST
48529: LIST
48530: PUSH
48531: LD_INT 30
48533: PUSH
48534: LD_INT 0
48536: PUSH
48537: EMPTY
48538: LIST
48539: LIST
48540: PUSH
48541: LD_INT 30
48543: PUSH
48544: LD_INT 1
48546: PUSH
48547: EMPTY
48548: LIST
48549: LIST
48550: PUSH
48551: EMPTY
48552: LIST
48553: LIST
48554: LIST
48555: LIST
48556: LIST
48557: LIST
48558: PPUSH
48559: CALL_OW 72
48563: ST_TO_ADDR
// if tmp then
48564: LD_VAR 0 5
48568: IFFALSE 48624
// begin k := NearestUnitToUnit ( tmp , j ) ;
48570: LD_ADDR_VAR 0 4
48574: PUSH
48575: LD_VAR 0 5
48579: PPUSH
48580: LD_VAR 0 3
48584: PPUSH
48585: CALL_OW 74
48589: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
48590: LD_VAR 0 3
48594: PPUSH
48595: LD_VAR 0 4
48599: PPUSH
48600: CALL_OW 296
48604: PUSH
48605: LD_INT 5
48607: GREATER
48608: IFFALSE 48624
// ComMoveToNearbyEntrance ( j , k ) ;
48610: LD_VAR 0 3
48614: PPUSH
48615: LD_VAR 0 4
48619: PPUSH
48620: CALL 108840 0 2
// end ; end ;
48624: GO 48479
48626: POP
48627: POP
// if not need_heal_1 and not need_heal_2 then
48628: LD_VAR 0 6
48632: NOT
48633: PUSH
48634: LD_VAR 0 7
48638: NOT
48639: AND
48640: IFFALSE 48644
// continue ;
48642: GO 48108
// end ;
48644: GO 48108
48646: POP
48647: POP
// RaiseSailEvent ( 102 ) ;
48648: LD_INT 102
48650: PPUSH
48651: CALL_OW 427
// end ;
48655: LD_VAR 0 1
48659: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
48660: LD_INT 0
48662: PPUSH
48663: PPUSH
48664: PPUSH
48665: PPUSH
48666: PPUSH
48667: PPUSH
48668: PPUSH
48669: PPUSH
// if not mc_bases then
48670: LD_EXP 102
48674: NOT
48675: IFFALSE 48679
// exit ;
48677: GO 49590
// for i = 1 to mc_bases do
48679: LD_ADDR_VAR 0 2
48683: PUSH
48684: DOUBLE
48685: LD_INT 1
48687: DEC
48688: ST_TO_ADDR
48689: LD_EXP 102
48693: PUSH
48694: FOR_TO
48695: IFFALSE 49588
// begin if not mc_building_need_repair [ i ] then
48697: LD_EXP 103
48701: PUSH
48702: LD_VAR 0 2
48706: ARRAY
48707: NOT
48708: IFFALSE 48893
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
48710: LD_ADDR_VAR 0 6
48714: PUSH
48715: LD_EXP 121
48719: PUSH
48720: LD_VAR 0 2
48724: ARRAY
48725: PPUSH
48726: LD_INT 3
48728: PUSH
48729: LD_INT 24
48731: PUSH
48732: LD_INT 1000
48734: PUSH
48735: EMPTY
48736: LIST
48737: LIST
48738: PUSH
48739: EMPTY
48740: LIST
48741: LIST
48742: PUSH
48743: LD_INT 2
48745: PUSH
48746: LD_INT 34
48748: PUSH
48749: LD_INT 13
48751: PUSH
48752: EMPTY
48753: LIST
48754: LIST
48755: PUSH
48756: LD_INT 34
48758: PUSH
48759: LD_INT 52
48761: PUSH
48762: EMPTY
48763: LIST
48764: LIST
48765: PUSH
48766: LD_INT 34
48768: PUSH
48769: LD_INT 88
48771: PUSH
48772: EMPTY
48773: LIST
48774: LIST
48775: PUSH
48776: EMPTY
48777: LIST
48778: LIST
48779: LIST
48780: LIST
48781: PUSH
48782: EMPTY
48783: LIST
48784: LIST
48785: PPUSH
48786: CALL_OW 72
48790: ST_TO_ADDR
// if cranes then
48791: LD_VAR 0 6
48795: IFFALSE 48857
// for j in cranes do
48797: LD_ADDR_VAR 0 3
48801: PUSH
48802: LD_VAR 0 6
48806: PUSH
48807: FOR_IN
48808: IFFALSE 48855
// if not IsInArea ( j , mc_parking [ i ] ) then
48810: LD_VAR 0 3
48814: PPUSH
48815: LD_EXP 126
48819: PUSH
48820: LD_VAR 0 2
48824: ARRAY
48825: PPUSH
48826: CALL_OW 308
48830: NOT
48831: IFFALSE 48853
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48833: LD_VAR 0 3
48837: PPUSH
48838: LD_EXP 126
48842: PUSH
48843: LD_VAR 0 2
48847: ARRAY
48848: PPUSH
48849: CALL_OW 113
48853: GO 48807
48855: POP
48856: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
48857: LD_ADDR_EXP 104
48861: PUSH
48862: LD_EXP 104
48866: PPUSH
48867: LD_VAR 0 2
48871: PPUSH
48872: EMPTY
48873: PPUSH
48874: CALL_OW 1
48878: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
48879: LD_VAR 0 2
48883: PPUSH
48884: LD_INT 101
48886: PPUSH
48887: CALL 43733 0 2
// continue ;
48891: GO 48694
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
48893: LD_ADDR_EXP 108
48897: PUSH
48898: LD_EXP 108
48902: PPUSH
48903: LD_VAR 0 2
48907: PPUSH
48908: EMPTY
48909: PPUSH
48910: CALL_OW 1
48914: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
48915: LD_VAR 0 2
48919: PPUSH
48920: LD_INT 103
48922: PPUSH
48923: CALL 43733 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
48927: LD_ADDR_VAR 0 5
48931: PUSH
48932: LD_EXP 102
48936: PUSH
48937: LD_VAR 0 2
48941: ARRAY
48942: PUSH
48943: LD_EXP 131
48947: PUSH
48948: LD_VAR 0 2
48952: ARRAY
48953: UNION
48954: PPUSH
48955: LD_INT 2
48957: PUSH
48958: LD_INT 25
48960: PUSH
48961: LD_INT 2
48963: PUSH
48964: EMPTY
48965: LIST
48966: LIST
48967: PUSH
48968: LD_INT 25
48970: PUSH
48971: LD_INT 16
48973: PUSH
48974: EMPTY
48975: LIST
48976: LIST
48977: PUSH
48978: EMPTY
48979: LIST
48980: LIST
48981: LIST
48982: PUSH
48983: EMPTY
48984: LIST
48985: PPUSH
48986: CALL_OW 72
48990: ST_TO_ADDR
// if mc_need_heal [ i ] then
48991: LD_EXP 105
48995: PUSH
48996: LD_VAR 0 2
49000: ARRAY
49001: IFFALSE 49045
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
49003: LD_ADDR_VAR 0 5
49007: PUSH
49008: LD_VAR 0 5
49012: PUSH
49013: LD_EXP 105
49017: PUSH
49018: LD_VAR 0 2
49022: ARRAY
49023: PUSH
49024: LD_INT 1
49026: ARRAY
49027: PUSH
49028: LD_EXP 105
49032: PUSH
49033: LD_VAR 0 2
49037: ARRAY
49038: PUSH
49039: LD_INT 2
49041: ARRAY
49042: UNION
49043: DIFF
49044: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
49045: LD_ADDR_VAR 0 6
49049: PUSH
49050: LD_EXP 121
49054: PUSH
49055: LD_VAR 0 2
49059: ARRAY
49060: PPUSH
49061: LD_INT 2
49063: PUSH
49064: LD_INT 34
49066: PUSH
49067: LD_INT 13
49069: PUSH
49070: EMPTY
49071: LIST
49072: LIST
49073: PUSH
49074: LD_INT 34
49076: PUSH
49077: LD_INT 52
49079: PUSH
49080: EMPTY
49081: LIST
49082: LIST
49083: PUSH
49084: LD_INT 34
49086: PUSH
49087: LD_INT 88
49089: PUSH
49090: EMPTY
49091: LIST
49092: LIST
49093: PUSH
49094: EMPTY
49095: LIST
49096: LIST
49097: LIST
49098: LIST
49099: PPUSH
49100: CALL_OW 72
49104: ST_TO_ADDR
// if cranes then
49105: LD_VAR 0 6
49109: IFFALSE 49277
// begin for j in cranes do
49111: LD_ADDR_VAR 0 3
49115: PUSH
49116: LD_VAR 0 6
49120: PUSH
49121: FOR_IN
49122: IFFALSE 49275
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
49124: LD_VAR 0 3
49128: PPUSH
49129: CALL_OW 256
49133: PUSH
49134: LD_INT 1000
49136: EQUAL
49137: PUSH
49138: LD_VAR 0 3
49142: PPUSH
49143: CALL_OW 314
49147: NOT
49148: AND
49149: IFFALSE 49215
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
49151: LD_ADDR_VAR 0 8
49155: PUSH
49156: LD_EXP 103
49160: PUSH
49161: LD_VAR 0 2
49165: ARRAY
49166: PPUSH
49167: LD_VAR 0 3
49171: PPUSH
49172: CALL_OW 74
49176: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
49177: LD_VAR 0 8
49181: PPUSH
49182: LD_INT 16
49184: PPUSH
49185: CALL 78199 0 2
49189: PUSH
49190: LD_INT 4
49192: ARRAY
49193: PUSH
49194: LD_INT 10
49196: LESS
49197: IFFALSE 49213
// ComRepairBuilding ( j , to_repair ) ;
49199: LD_VAR 0 3
49203: PPUSH
49204: LD_VAR 0 8
49208: PPUSH
49209: CALL_OW 130
// end else
49213: GO 49273
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
49215: LD_VAR 0 3
49219: PPUSH
49220: CALL_OW 256
49224: PUSH
49225: LD_INT 500
49227: LESS
49228: PUSH
49229: LD_VAR 0 3
49233: PPUSH
49234: LD_EXP 126
49238: PUSH
49239: LD_VAR 0 2
49243: ARRAY
49244: PPUSH
49245: CALL_OW 308
49249: NOT
49250: AND
49251: IFFALSE 49273
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49253: LD_VAR 0 3
49257: PPUSH
49258: LD_EXP 126
49262: PUSH
49263: LD_VAR 0 2
49267: ARRAY
49268: PPUSH
49269: CALL_OW 113
// end ;
49273: GO 49121
49275: POP
49276: POP
// end ; if tmp > 3 then
49277: LD_VAR 0 5
49281: PUSH
49282: LD_INT 3
49284: GREATER
49285: IFFALSE 49305
// tmp := ShrinkArray ( tmp , 4 ) ;
49287: LD_ADDR_VAR 0 5
49291: PUSH
49292: LD_VAR 0 5
49296: PPUSH
49297: LD_INT 4
49299: PPUSH
49300: CALL 108278 0 2
49304: ST_TO_ADDR
// if not tmp then
49305: LD_VAR 0 5
49309: NOT
49310: IFFALSE 49314
// continue ;
49312: GO 48694
// for j in tmp do
49314: LD_ADDR_VAR 0 3
49318: PUSH
49319: LD_VAR 0 5
49323: PUSH
49324: FOR_IN
49325: IFFALSE 49584
// begin if IsInUnit ( j ) then
49327: LD_VAR 0 3
49331: PPUSH
49332: CALL_OW 310
49336: IFFALSE 49347
// ComExitBuilding ( j ) ;
49338: LD_VAR 0 3
49342: PPUSH
49343: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
49347: LD_VAR 0 3
49351: PUSH
49352: LD_EXP 104
49356: PUSH
49357: LD_VAR 0 2
49361: ARRAY
49362: IN
49363: NOT
49364: IFFALSE 49422
// begin SetTag ( j , 101 ) ;
49366: LD_VAR 0 3
49370: PPUSH
49371: LD_INT 101
49373: PPUSH
49374: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
49378: LD_ADDR_EXP 104
49382: PUSH
49383: LD_EXP 104
49387: PPUSH
49388: LD_VAR 0 2
49392: PUSH
49393: LD_EXP 104
49397: PUSH
49398: LD_VAR 0 2
49402: ARRAY
49403: PUSH
49404: LD_INT 1
49406: PLUS
49407: PUSH
49408: EMPTY
49409: LIST
49410: LIST
49411: PPUSH
49412: LD_VAR 0 3
49416: PPUSH
49417: CALL 75234 0 3
49421: ST_TO_ADDR
// end ; wait ( 1 ) ;
49422: LD_INT 1
49424: PPUSH
49425: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
49429: LD_ADDR_VAR 0 7
49433: PUSH
49434: LD_EXP 103
49438: PUSH
49439: LD_VAR 0 2
49443: ARRAY
49444: ST_TO_ADDR
// if mc_scan [ i ] then
49445: LD_EXP 125
49449: PUSH
49450: LD_VAR 0 2
49454: ARRAY
49455: IFFALSE 49517
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
49457: LD_ADDR_VAR 0 7
49461: PUSH
49462: LD_EXP 103
49466: PUSH
49467: LD_VAR 0 2
49471: ARRAY
49472: PPUSH
49473: LD_INT 3
49475: PUSH
49476: LD_INT 30
49478: PUSH
49479: LD_INT 32
49481: PUSH
49482: EMPTY
49483: LIST
49484: LIST
49485: PUSH
49486: LD_INT 30
49488: PUSH
49489: LD_INT 33
49491: PUSH
49492: EMPTY
49493: LIST
49494: LIST
49495: PUSH
49496: LD_INT 30
49498: PUSH
49499: LD_INT 31
49501: PUSH
49502: EMPTY
49503: LIST
49504: LIST
49505: PUSH
49506: EMPTY
49507: LIST
49508: LIST
49509: LIST
49510: LIST
49511: PPUSH
49512: CALL_OW 72
49516: ST_TO_ADDR
// if not to_repair_tmp then
49517: LD_VAR 0 7
49521: NOT
49522: IFFALSE 49526
// continue ;
49524: GO 49324
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
49526: LD_ADDR_VAR 0 8
49530: PUSH
49531: LD_VAR 0 7
49535: PPUSH
49536: LD_VAR 0 3
49540: PPUSH
49541: CALL_OW 74
49545: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
49546: LD_VAR 0 8
49550: PPUSH
49551: LD_INT 16
49553: PPUSH
49554: CALL 78199 0 2
49558: PUSH
49559: LD_INT 4
49561: ARRAY
49562: PUSH
49563: LD_INT 14
49565: LESS
49566: IFFALSE 49582
// ComRepairBuilding ( j , to_repair ) ;
49568: LD_VAR 0 3
49572: PPUSH
49573: LD_VAR 0 8
49577: PPUSH
49578: CALL_OW 130
// end ;
49582: GO 49324
49584: POP
49585: POP
// end ;
49586: GO 48694
49588: POP
49589: POP
// end ;
49590: LD_VAR 0 1
49594: RET
// export function MC_Heal ; var i , j , tmp ; begin
49595: LD_INT 0
49597: PPUSH
49598: PPUSH
49599: PPUSH
49600: PPUSH
// if not mc_bases then
49601: LD_EXP 102
49605: NOT
49606: IFFALSE 49610
// exit ;
49608: GO 50012
// for i = 1 to mc_bases do
49610: LD_ADDR_VAR 0 2
49614: PUSH
49615: DOUBLE
49616: LD_INT 1
49618: DEC
49619: ST_TO_ADDR
49620: LD_EXP 102
49624: PUSH
49625: FOR_TO
49626: IFFALSE 50010
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
49628: LD_EXP 105
49632: PUSH
49633: LD_VAR 0 2
49637: ARRAY
49638: PUSH
49639: LD_INT 1
49641: ARRAY
49642: NOT
49643: PUSH
49644: LD_EXP 105
49648: PUSH
49649: LD_VAR 0 2
49653: ARRAY
49654: PUSH
49655: LD_INT 2
49657: ARRAY
49658: NOT
49659: AND
49660: IFFALSE 49698
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
49662: LD_ADDR_EXP 106
49666: PUSH
49667: LD_EXP 106
49671: PPUSH
49672: LD_VAR 0 2
49676: PPUSH
49677: EMPTY
49678: PPUSH
49679: CALL_OW 1
49683: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
49684: LD_VAR 0 2
49688: PPUSH
49689: LD_INT 102
49691: PPUSH
49692: CALL 43733 0 2
// continue ;
49696: GO 49625
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
49698: LD_ADDR_VAR 0 4
49702: PUSH
49703: LD_EXP 102
49707: PUSH
49708: LD_VAR 0 2
49712: ARRAY
49713: PPUSH
49714: LD_INT 25
49716: PUSH
49717: LD_INT 4
49719: PUSH
49720: EMPTY
49721: LIST
49722: LIST
49723: PPUSH
49724: CALL_OW 72
49728: ST_TO_ADDR
// if not tmp then
49729: LD_VAR 0 4
49733: NOT
49734: IFFALSE 49738
// continue ;
49736: GO 49625
// if mc_taming [ i ] then
49738: LD_EXP 133
49742: PUSH
49743: LD_VAR 0 2
49747: ARRAY
49748: IFFALSE 49772
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
49750: LD_ADDR_EXP 133
49754: PUSH
49755: LD_EXP 133
49759: PPUSH
49760: LD_VAR 0 2
49764: PPUSH
49765: EMPTY
49766: PPUSH
49767: CALL_OW 1
49771: ST_TO_ADDR
// for j in tmp do
49772: LD_ADDR_VAR 0 3
49776: PUSH
49777: LD_VAR 0 4
49781: PUSH
49782: FOR_IN
49783: IFFALSE 50006
// begin if IsInUnit ( j ) then
49785: LD_VAR 0 3
49789: PPUSH
49790: CALL_OW 310
49794: IFFALSE 49805
// ComExitBuilding ( j ) ;
49796: LD_VAR 0 3
49800: PPUSH
49801: CALL_OW 122
// if not j in mc_healers [ i ] then
49805: LD_VAR 0 3
49809: PUSH
49810: LD_EXP 106
49814: PUSH
49815: LD_VAR 0 2
49819: ARRAY
49820: IN
49821: NOT
49822: IFFALSE 49868
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
49824: LD_ADDR_EXP 106
49828: PUSH
49829: LD_EXP 106
49833: PPUSH
49834: LD_VAR 0 2
49838: PUSH
49839: LD_EXP 106
49843: PUSH
49844: LD_VAR 0 2
49848: ARRAY
49849: PUSH
49850: LD_INT 1
49852: PLUS
49853: PUSH
49854: EMPTY
49855: LIST
49856: LIST
49857: PPUSH
49858: LD_VAR 0 3
49862: PPUSH
49863: CALL 75234 0 3
49867: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
49868: LD_VAR 0 3
49872: PPUSH
49873: CALL_OW 110
49877: PUSH
49878: LD_INT 102
49880: NONEQUAL
49881: IFFALSE 49895
// SetTag ( j , 102 ) ;
49883: LD_VAR 0 3
49887: PPUSH
49888: LD_INT 102
49890: PPUSH
49891: CALL_OW 109
// Wait ( 3 ) ;
49895: LD_INT 3
49897: PPUSH
49898: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
49902: LD_EXP 105
49906: PUSH
49907: LD_VAR 0 2
49911: ARRAY
49912: PUSH
49913: LD_INT 1
49915: ARRAY
49916: IFFALSE 49948
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
49918: LD_VAR 0 3
49922: PPUSH
49923: LD_EXP 105
49927: PUSH
49928: LD_VAR 0 2
49932: ARRAY
49933: PUSH
49934: LD_INT 1
49936: ARRAY
49937: PUSH
49938: LD_INT 1
49940: ARRAY
49941: PPUSH
49942: CALL_OW 128
49946: GO 50004
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
49948: LD_VAR 0 3
49952: PPUSH
49953: CALL_OW 314
49957: NOT
49958: PUSH
49959: LD_EXP 105
49963: PUSH
49964: LD_VAR 0 2
49968: ARRAY
49969: PUSH
49970: LD_INT 2
49972: ARRAY
49973: AND
49974: IFFALSE 50004
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
49976: LD_VAR 0 3
49980: PPUSH
49981: LD_EXP 105
49985: PUSH
49986: LD_VAR 0 2
49990: ARRAY
49991: PUSH
49992: LD_INT 2
49994: ARRAY
49995: PUSH
49996: LD_INT 1
49998: ARRAY
49999: PPUSH
50000: CALL_OW 128
// end ;
50004: GO 49782
50006: POP
50007: POP
// end ;
50008: GO 49625
50010: POP
50011: POP
// end ;
50012: LD_VAR 0 1
50016: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
50017: LD_INT 0
50019: PPUSH
50020: PPUSH
50021: PPUSH
50022: PPUSH
50023: PPUSH
50024: PPUSH
// if not mc_bases then
50025: LD_EXP 102
50029: NOT
50030: IFFALSE 50034
// exit ;
50032: GO 51197
// for i = 1 to mc_bases do
50034: LD_ADDR_VAR 0 2
50038: PUSH
50039: DOUBLE
50040: LD_INT 1
50042: DEC
50043: ST_TO_ADDR
50044: LD_EXP 102
50048: PUSH
50049: FOR_TO
50050: IFFALSE 51195
// begin if mc_scan [ i ] then
50052: LD_EXP 125
50056: PUSH
50057: LD_VAR 0 2
50061: ARRAY
50062: IFFALSE 50066
// continue ;
50064: GO 50049
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
50066: LD_EXP 107
50070: PUSH
50071: LD_VAR 0 2
50075: ARRAY
50076: NOT
50077: PUSH
50078: LD_EXP 109
50082: PUSH
50083: LD_VAR 0 2
50087: ARRAY
50088: NOT
50089: AND
50090: PUSH
50091: LD_EXP 108
50095: PUSH
50096: LD_VAR 0 2
50100: ARRAY
50101: AND
50102: IFFALSE 50140
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
50104: LD_ADDR_EXP 108
50108: PUSH
50109: LD_EXP 108
50113: PPUSH
50114: LD_VAR 0 2
50118: PPUSH
50119: EMPTY
50120: PPUSH
50121: CALL_OW 1
50125: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
50126: LD_VAR 0 2
50130: PPUSH
50131: LD_INT 103
50133: PPUSH
50134: CALL 43733 0 2
// continue ;
50138: GO 50049
// end ; if mc_construct_list [ i ] then
50140: LD_EXP 109
50144: PUSH
50145: LD_VAR 0 2
50149: ARRAY
50150: IFFALSE 50370
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
50152: LD_ADDR_VAR 0 5
50156: PUSH
50157: LD_EXP 102
50161: PUSH
50162: LD_VAR 0 2
50166: ARRAY
50167: PPUSH
50168: LD_INT 25
50170: PUSH
50171: LD_INT 2
50173: PUSH
50174: EMPTY
50175: LIST
50176: LIST
50177: PPUSH
50178: CALL_OW 72
50182: PUSH
50183: LD_EXP 104
50187: PUSH
50188: LD_VAR 0 2
50192: ARRAY
50193: DIFF
50194: ST_TO_ADDR
// if not tmp then
50195: LD_VAR 0 5
50199: NOT
50200: IFFALSE 50204
// continue ;
50202: GO 50049
// for j in tmp do
50204: LD_ADDR_VAR 0 3
50208: PUSH
50209: LD_VAR 0 5
50213: PUSH
50214: FOR_IN
50215: IFFALSE 50366
// begin if not mc_builders [ i ] then
50217: LD_EXP 108
50221: PUSH
50222: LD_VAR 0 2
50226: ARRAY
50227: NOT
50228: IFFALSE 50286
// begin SetTag ( j , 103 ) ;
50230: LD_VAR 0 3
50234: PPUSH
50235: LD_INT 103
50237: PPUSH
50238: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
50242: LD_ADDR_EXP 108
50246: PUSH
50247: LD_EXP 108
50251: PPUSH
50252: LD_VAR 0 2
50256: PUSH
50257: LD_EXP 108
50261: PUSH
50262: LD_VAR 0 2
50266: ARRAY
50267: PUSH
50268: LD_INT 1
50270: PLUS
50271: PUSH
50272: EMPTY
50273: LIST
50274: LIST
50275: PPUSH
50276: LD_VAR 0 3
50280: PPUSH
50281: CALL 75234 0 3
50285: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
50286: LD_VAR 0 3
50290: PPUSH
50291: CALL_OW 310
50295: IFFALSE 50306
// ComExitBuilding ( j ) ;
50297: LD_VAR 0 3
50301: PPUSH
50302: CALL_OW 122
// wait ( 3 ) ;
50306: LD_INT 3
50308: PPUSH
50309: CALL_OW 67
// if not mc_construct_list [ i ] then
50313: LD_EXP 109
50317: PUSH
50318: LD_VAR 0 2
50322: ARRAY
50323: NOT
50324: IFFALSE 50328
// break ;
50326: GO 50366
// if not HasTask ( j ) then
50328: LD_VAR 0 3
50332: PPUSH
50333: CALL_OW 314
50337: NOT
50338: IFFALSE 50364
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
50340: LD_VAR 0 3
50344: PPUSH
50345: LD_EXP 109
50349: PUSH
50350: LD_VAR 0 2
50354: ARRAY
50355: PUSH
50356: LD_INT 1
50358: ARRAY
50359: PPUSH
50360: CALL 78472 0 2
// end ;
50364: GO 50214
50366: POP
50367: POP
// end else
50368: GO 51193
// if mc_build_list [ i ] then
50370: LD_EXP 107
50374: PUSH
50375: LD_VAR 0 2
50379: ARRAY
50380: IFFALSE 51193
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
50382: LD_EXP 107
50386: PUSH
50387: LD_VAR 0 2
50391: ARRAY
50392: PUSH
50393: LD_INT 1
50395: ARRAY
50396: PUSH
50397: LD_INT 1
50399: ARRAY
50400: PPUSH
50401: CALL 78296 0 1
50405: PUSH
50406: LD_EXP 102
50410: PUSH
50411: LD_VAR 0 2
50415: ARRAY
50416: PPUSH
50417: LD_INT 2
50419: PUSH
50420: LD_INT 30
50422: PUSH
50423: LD_INT 2
50425: PUSH
50426: EMPTY
50427: LIST
50428: LIST
50429: PUSH
50430: LD_INT 30
50432: PUSH
50433: LD_INT 3
50435: PUSH
50436: EMPTY
50437: LIST
50438: LIST
50439: PUSH
50440: EMPTY
50441: LIST
50442: LIST
50443: LIST
50444: PPUSH
50445: CALL_OW 72
50449: NOT
50450: AND
50451: IFFALSE 50556
// begin for j = 1 to mc_build_list [ i ] do
50453: LD_ADDR_VAR 0 3
50457: PUSH
50458: DOUBLE
50459: LD_INT 1
50461: DEC
50462: ST_TO_ADDR
50463: LD_EXP 107
50467: PUSH
50468: LD_VAR 0 2
50472: ARRAY
50473: PUSH
50474: FOR_TO
50475: IFFALSE 50554
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
50477: LD_EXP 107
50481: PUSH
50482: LD_VAR 0 2
50486: ARRAY
50487: PUSH
50488: LD_VAR 0 3
50492: ARRAY
50493: PUSH
50494: LD_INT 1
50496: ARRAY
50497: PUSH
50498: LD_INT 2
50500: EQUAL
50501: IFFALSE 50552
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
50503: LD_ADDR_EXP 107
50507: PUSH
50508: LD_EXP 107
50512: PPUSH
50513: LD_VAR 0 2
50517: PPUSH
50518: LD_EXP 107
50522: PUSH
50523: LD_VAR 0 2
50527: ARRAY
50528: PPUSH
50529: LD_VAR 0 3
50533: PPUSH
50534: LD_INT 1
50536: PPUSH
50537: LD_INT 0
50539: PPUSH
50540: CALL 74652 0 4
50544: PPUSH
50545: CALL_OW 1
50549: ST_TO_ADDR
// break ;
50550: GO 50554
// end ;
50552: GO 50474
50554: POP
50555: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50556: LD_ADDR_VAR 0 6
50560: PUSH
50561: LD_EXP 102
50565: PUSH
50566: LD_VAR 0 2
50570: ARRAY
50571: PPUSH
50572: LD_INT 2
50574: PUSH
50575: LD_INT 30
50577: PUSH
50578: LD_INT 0
50580: PUSH
50581: EMPTY
50582: LIST
50583: LIST
50584: PUSH
50585: LD_INT 30
50587: PUSH
50588: LD_INT 1
50590: PUSH
50591: EMPTY
50592: LIST
50593: LIST
50594: PUSH
50595: EMPTY
50596: LIST
50597: LIST
50598: LIST
50599: PPUSH
50600: CALL_OW 72
50604: ST_TO_ADDR
// for k := 1 to depot do
50605: LD_ADDR_VAR 0 4
50609: PUSH
50610: DOUBLE
50611: LD_INT 1
50613: DEC
50614: ST_TO_ADDR
50615: LD_VAR 0 6
50619: PUSH
50620: FOR_TO
50621: IFFALSE 51191
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
50623: LD_EXP 107
50627: PUSH
50628: LD_VAR 0 2
50632: ARRAY
50633: PUSH
50634: LD_INT 1
50636: ARRAY
50637: PUSH
50638: LD_INT 1
50640: ARRAY
50641: PUSH
50642: LD_INT 0
50644: EQUAL
50645: PUSH
50646: LD_VAR 0 6
50650: PUSH
50651: LD_VAR 0 4
50655: ARRAY
50656: PPUSH
50657: LD_EXP 107
50661: PUSH
50662: LD_VAR 0 2
50666: ARRAY
50667: PUSH
50668: LD_INT 1
50670: ARRAY
50671: PUSH
50672: LD_INT 1
50674: ARRAY
50675: PPUSH
50676: LD_EXP 107
50680: PUSH
50681: LD_VAR 0 2
50685: ARRAY
50686: PUSH
50687: LD_INT 1
50689: ARRAY
50690: PUSH
50691: LD_INT 2
50693: ARRAY
50694: PPUSH
50695: LD_EXP 107
50699: PUSH
50700: LD_VAR 0 2
50704: ARRAY
50705: PUSH
50706: LD_INT 1
50708: ARRAY
50709: PUSH
50710: LD_INT 3
50712: ARRAY
50713: PPUSH
50714: LD_EXP 107
50718: PUSH
50719: LD_VAR 0 2
50723: ARRAY
50724: PUSH
50725: LD_INT 1
50727: ARRAY
50728: PUSH
50729: LD_INT 4
50731: ARRAY
50732: PPUSH
50733: CALL 83708 0 5
50737: OR
50738: IFFALSE 51019
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
50740: LD_ADDR_VAR 0 5
50744: PUSH
50745: LD_EXP 102
50749: PUSH
50750: LD_VAR 0 2
50754: ARRAY
50755: PPUSH
50756: LD_INT 25
50758: PUSH
50759: LD_INT 2
50761: PUSH
50762: EMPTY
50763: LIST
50764: LIST
50765: PPUSH
50766: CALL_OW 72
50770: PUSH
50771: LD_EXP 104
50775: PUSH
50776: LD_VAR 0 2
50780: ARRAY
50781: DIFF
50782: ST_TO_ADDR
// if not tmp then
50783: LD_VAR 0 5
50787: NOT
50788: IFFALSE 50792
// continue ;
50790: GO 50620
// for j in tmp do
50792: LD_ADDR_VAR 0 3
50796: PUSH
50797: LD_VAR 0 5
50801: PUSH
50802: FOR_IN
50803: IFFALSE 51015
// begin if not mc_builders [ i ] then
50805: LD_EXP 108
50809: PUSH
50810: LD_VAR 0 2
50814: ARRAY
50815: NOT
50816: IFFALSE 50874
// begin SetTag ( j , 103 ) ;
50818: LD_VAR 0 3
50822: PPUSH
50823: LD_INT 103
50825: PPUSH
50826: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
50830: LD_ADDR_EXP 108
50834: PUSH
50835: LD_EXP 108
50839: PPUSH
50840: LD_VAR 0 2
50844: PUSH
50845: LD_EXP 108
50849: PUSH
50850: LD_VAR 0 2
50854: ARRAY
50855: PUSH
50856: LD_INT 1
50858: PLUS
50859: PUSH
50860: EMPTY
50861: LIST
50862: LIST
50863: PPUSH
50864: LD_VAR 0 3
50868: PPUSH
50869: CALL 75234 0 3
50873: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
50874: LD_VAR 0 3
50878: PPUSH
50879: CALL_OW 310
50883: IFFALSE 50894
// ComExitBuilding ( j ) ;
50885: LD_VAR 0 3
50889: PPUSH
50890: CALL_OW 122
// wait ( 3 ) ;
50894: LD_INT 3
50896: PPUSH
50897: CALL_OW 67
// if not mc_build_list [ i ] then
50901: LD_EXP 107
50905: PUSH
50906: LD_VAR 0 2
50910: ARRAY
50911: NOT
50912: IFFALSE 50916
// break ;
50914: GO 51015
// if not HasTask ( j ) then
50916: LD_VAR 0 3
50920: PPUSH
50921: CALL_OW 314
50925: NOT
50926: IFFALSE 51013
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
50928: LD_VAR 0 3
50932: PPUSH
50933: LD_EXP 107
50937: PUSH
50938: LD_VAR 0 2
50942: ARRAY
50943: PUSH
50944: LD_INT 1
50946: ARRAY
50947: PUSH
50948: LD_INT 1
50950: ARRAY
50951: PPUSH
50952: LD_EXP 107
50956: PUSH
50957: LD_VAR 0 2
50961: ARRAY
50962: PUSH
50963: LD_INT 1
50965: ARRAY
50966: PUSH
50967: LD_INT 2
50969: ARRAY
50970: PPUSH
50971: LD_EXP 107
50975: PUSH
50976: LD_VAR 0 2
50980: ARRAY
50981: PUSH
50982: LD_INT 1
50984: ARRAY
50985: PUSH
50986: LD_INT 3
50988: ARRAY
50989: PPUSH
50990: LD_EXP 107
50994: PUSH
50995: LD_VAR 0 2
50999: ARRAY
51000: PUSH
51001: LD_INT 1
51003: ARRAY
51004: PUSH
51005: LD_INT 4
51007: ARRAY
51008: PPUSH
51009: CALL_OW 145
// end ;
51013: GO 50802
51015: POP
51016: POP
// end else
51017: GO 51189
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
51019: LD_EXP 102
51023: PUSH
51024: LD_VAR 0 2
51028: ARRAY
51029: PPUSH
51030: LD_EXP 107
51034: PUSH
51035: LD_VAR 0 2
51039: ARRAY
51040: PUSH
51041: LD_INT 1
51043: ARRAY
51044: PUSH
51045: LD_INT 1
51047: ARRAY
51048: PPUSH
51049: LD_EXP 107
51053: PUSH
51054: LD_VAR 0 2
51058: ARRAY
51059: PUSH
51060: LD_INT 1
51062: ARRAY
51063: PUSH
51064: LD_INT 2
51066: ARRAY
51067: PPUSH
51068: LD_EXP 107
51072: PUSH
51073: LD_VAR 0 2
51077: ARRAY
51078: PUSH
51079: LD_INT 1
51081: ARRAY
51082: PUSH
51083: LD_INT 3
51085: ARRAY
51086: PPUSH
51087: LD_EXP 107
51091: PUSH
51092: LD_VAR 0 2
51096: ARRAY
51097: PUSH
51098: LD_INT 1
51100: ARRAY
51101: PUSH
51102: LD_INT 4
51104: ARRAY
51105: PPUSH
51106: LD_EXP 102
51110: PUSH
51111: LD_VAR 0 2
51115: ARRAY
51116: PPUSH
51117: LD_INT 21
51119: PUSH
51120: LD_INT 3
51122: PUSH
51123: EMPTY
51124: LIST
51125: LIST
51126: PPUSH
51127: CALL_OW 72
51131: PPUSH
51132: EMPTY
51133: PPUSH
51134: CALL 82462 0 7
51138: NOT
51139: IFFALSE 51189
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
51141: LD_ADDR_EXP 107
51145: PUSH
51146: LD_EXP 107
51150: PPUSH
51151: LD_VAR 0 2
51155: PPUSH
51156: LD_EXP 107
51160: PUSH
51161: LD_VAR 0 2
51165: ARRAY
51166: PPUSH
51167: LD_INT 1
51169: PPUSH
51170: LD_INT 1
51172: NEG
51173: PPUSH
51174: LD_INT 0
51176: PPUSH
51177: CALL 74652 0 4
51181: PPUSH
51182: CALL_OW 1
51186: ST_TO_ADDR
// continue ;
51187: GO 50620
// end ; end ;
51189: GO 50620
51191: POP
51192: POP
// end ; end ;
51193: GO 50049
51195: POP
51196: POP
// end ;
51197: LD_VAR 0 1
51201: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
51202: LD_INT 0
51204: PPUSH
51205: PPUSH
51206: PPUSH
51207: PPUSH
51208: PPUSH
51209: PPUSH
// if not mc_bases then
51210: LD_EXP 102
51214: NOT
51215: IFFALSE 51219
// exit ;
51217: GO 51646
// for i = 1 to mc_bases do
51219: LD_ADDR_VAR 0 2
51223: PUSH
51224: DOUBLE
51225: LD_INT 1
51227: DEC
51228: ST_TO_ADDR
51229: LD_EXP 102
51233: PUSH
51234: FOR_TO
51235: IFFALSE 51644
// begin tmp := mc_build_upgrade [ i ] ;
51237: LD_ADDR_VAR 0 4
51241: PUSH
51242: LD_EXP 134
51246: PUSH
51247: LD_VAR 0 2
51251: ARRAY
51252: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
51253: LD_ADDR_VAR 0 6
51257: PUSH
51258: LD_EXP 135
51262: PUSH
51263: LD_VAR 0 2
51267: ARRAY
51268: PPUSH
51269: LD_INT 2
51271: PUSH
51272: LD_INT 30
51274: PUSH
51275: LD_INT 6
51277: PUSH
51278: EMPTY
51279: LIST
51280: LIST
51281: PUSH
51282: LD_INT 30
51284: PUSH
51285: LD_INT 7
51287: PUSH
51288: EMPTY
51289: LIST
51290: LIST
51291: PUSH
51292: EMPTY
51293: LIST
51294: LIST
51295: LIST
51296: PPUSH
51297: CALL_OW 72
51301: ST_TO_ADDR
// if not tmp and not lab then
51302: LD_VAR 0 4
51306: NOT
51307: PUSH
51308: LD_VAR 0 6
51312: NOT
51313: AND
51314: IFFALSE 51318
// continue ;
51316: GO 51234
// if tmp then
51318: LD_VAR 0 4
51322: IFFALSE 51442
// for j in tmp do
51324: LD_ADDR_VAR 0 3
51328: PUSH
51329: LD_VAR 0 4
51333: PUSH
51334: FOR_IN
51335: IFFALSE 51440
// begin if UpgradeCost ( j ) then
51337: LD_VAR 0 3
51341: PPUSH
51342: CALL 82122 0 1
51346: IFFALSE 51438
// begin ComUpgrade ( j ) ;
51348: LD_VAR 0 3
51352: PPUSH
51353: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
51357: LD_ADDR_EXP 134
51361: PUSH
51362: LD_EXP 134
51366: PPUSH
51367: LD_VAR 0 2
51371: PPUSH
51372: LD_EXP 134
51376: PUSH
51377: LD_VAR 0 2
51381: ARRAY
51382: PUSH
51383: LD_VAR 0 3
51387: DIFF
51388: PPUSH
51389: CALL_OW 1
51393: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
51394: LD_ADDR_EXP 109
51398: PUSH
51399: LD_EXP 109
51403: PPUSH
51404: LD_VAR 0 2
51408: PUSH
51409: LD_EXP 109
51413: PUSH
51414: LD_VAR 0 2
51418: ARRAY
51419: PUSH
51420: LD_INT 1
51422: PLUS
51423: PUSH
51424: EMPTY
51425: LIST
51426: LIST
51427: PPUSH
51428: LD_VAR 0 3
51432: PPUSH
51433: CALL 75234 0 3
51437: ST_TO_ADDR
// end ; end ;
51438: GO 51334
51440: POP
51441: POP
// if not lab or not mc_lab_upgrade [ i ] then
51442: LD_VAR 0 6
51446: NOT
51447: PUSH
51448: LD_EXP 136
51452: PUSH
51453: LD_VAR 0 2
51457: ARRAY
51458: NOT
51459: OR
51460: IFFALSE 51464
// continue ;
51462: GO 51234
// for j in lab do
51464: LD_ADDR_VAR 0 3
51468: PUSH
51469: LD_VAR 0 6
51473: PUSH
51474: FOR_IN
51475: IFFALSE 51640
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
51477: LD_VAR 0 3
51481: PPUSH
51482: CALL_OW 266
51486: PUSH
51487: LD_INT 6
51489: PUSH
51490: LD_INT 7
51492: PUSH
51493: EMPTY
51494: LIST
51495: LIST
51496: IN
51497: PUSH
51498: LD_VAR 0 3
51502: PPUSH
51503: CALL_OW 461
51507: PUSH
51508: LD_INT 1
51510: NONEQUAL
51511: AND
51512: IFFALSE 51638
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
51514: LD_VAR 0 3
51518: PPUSH
51519: LD_EXP 136
51523: PUSH
51524: LD_VAR 0 2
51528: ARRAY
51529: PUSH
51530: LD_INT 1
51532: ARRAY
51533: PPUSH
51534: CALL 82327 0 2
51538: IFFALSE 51638
// begin ComCancel ( j ) ;
51540: LD_VAR 0 3
51544: PPUSH
51545: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
51549: LD_VAR 0 3
51553: PPUSH
51554: LD_EXP 136
51558: PUSH
51559: LD_VAR 0 2
51563: ARRAY
51564: PUSH
51565: LD_INT 1
51567: ARRAY
51568: PPUSH
51569: CALL_OW 207
// if not j in mc_construct_list [ i ] then
51573: LD_VAR 0 3
51577: PUSH
51578: LD_EXP 109
51582: PUSH
51583: LD_VAR 0 2
51587: ARRAY
51588: IN
51589: NOT
51590: IFFALSE 51636
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
51592: LD_ADDR_EXP 109
51596: PUSH
51597: LD_EXP 109
51601: PPUSH
51602: LD_VAR 0 2
51606: PUSH
51607: LD_EXP 109
51611: PUSH
51612: LD_VAR 0 2
51616: ARRAY
51617: PUSH
51618: LD_INT 1
51620: PLUS
51621: PUSH
51622: EMPTY
51623: LIST
51624: LIST
51625: PPUSH
51626: LD_VAR 0 3
51630: PPUSH
51631: CALL 75234 0 3
51635: ST_TO_ADDR
// break ;
51636: GO 51640
// end ; end ; end ;
51638: GO 51474
51640: POP
51641: POP
// end ;
51642: GO 51234
51644: POP
51645: POP
// end ;
51646: LD_VAR 0 1
51650: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
51651: LD_INT 0
51653: PPUSH
51654: PPUSH
51655: PPUSH
51656: PPUSH
51657: PPUSH
51658: PPUSH
51659: PPUSH
51660: PPUSH
51661: PPUSH
// if not mc_bases then
51662: LD_EXP 102
51666: NOT
51667: IFFALSE 51671
// exit ;
51669: GO 52076
// for i = 1 to mc_bases do
51671: LD_ADDR_VAR 0 2
51675: PUSH
51676: DOUBLE
51677: LD_INT 1
51679: DEC
51680: ST_TO_ADDR
51681: LD_EXP 102
51685: PUSH
51686: FOR_TO
51687: IFFALSE 52074
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
51689: LD_EXP 110
51693: PUSH
51694: LD_VAR 0 2
51698: ARRAY
51699: NOT
51700: PUSH
51701: LD_EXP 102
51705: PUSH
51706: LD_VAR 0 2
51710: ARRAY
51711: PPUSH
51712: LD_INT 30
51714: PUSH
51715: LD_INT 3
51717: PUSH
51718: EMPTY
51719: LIST
51720: LIST
51721: PPUSH
51722: CALL_OW 72
51726: NOT
51727: OR
51728: IFFALSE 51732
// continue ;
51730: GO 51686
// busy := false ;
51732: LD_ADDR_VAR 0 8
51736: PUSH
51737: LD_INT 0
51739: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51740: LD_ADDR_VAR 0 4
51744: PUSH
51745: LD_EXP 102
51749: PUSH
51750: LD_VAR 0 2
51754: ARRAY
51755: PPUSH
51756: LD_INT 30
51758: PUSH
51759: LD_INT 3
51761: PUSH
51762: EMPTY
51763: LIST
51764: LIST
51765: PPUSH
51766: CALL_OW 72
51770: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
51771: LD_ADDR_VAR 0 6
51775: PUSH
51776: LD_EXP 110
51780: PUSH
51781: LD_VAR 0 2
51785: ARRAY
51786: PPUSH
51787: LD_INT 2
51789: PUSH
51790: LD_INT 30
51792: PUSH
51793: LD_INT 32
51795: PUSH
51796: EMPTY
51797: LIST
51798: LIST
51799: PUSH
51800: LD_INT 30
51802: PUSH
51803: LD_INT 33
51805: PUSH
51806: EMPTY
51807: LIST
51808: LIST
51809: PUSH
51810: EMPTY
51811: LIST
51812: LIST
51813: LIST
51814: PPUSH
51815: CALL_OW 72
51819: ST_TO_ADDR
// if not t then
51820: LD_VAR 0 6
51824: NOT
51825: IFFALSE 51829
// continue ;
51827: GO 51686
// for j in tmp do
51829: LD_ADDR_VAR 0 3
51833: PUSH
51834: LD_VAR 0 4
51838: PUSH
51839: FOR_IN
51840: IFFALSE 51870
// if not BuildingStatus ( j ) = bs_idle then
51842: LD_VAR 0 3
51846: PPUSH
51847: CALL_OW 461
51851: PUSH
51852: LD_INT 2
51854: EQUAL
51855: NOT
51856: IFFALSE 51868
// begin busy := true ;
51858: LD_ADDR_VAR 0 8
51862: PUSH
51863: LD_INT 1
51865: ST_TO_ADDR
// break ;
51866: GO 51870
// end ;
51868: GO 51839
51870: POP
51871: POP
// if busy then
51872: LD_VAR 0 8
51876: IFFALSE 51880
// continue ;
51878: GO 51686
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
51880: LD_ADDR_VAR 0 7
51884: PUSH
51885: LD_VAR 0 6
51889: PPUSH
51890: LD_INT 35
51892: PUSH
51893: LD_INT 0
51895: PUSH
51896: EMPTY
51897: LIST
51898: LIST
51899: PPUSH
51900: CALL_OW 72
51904: ST_TO_ADDR
// if tw then
51905: LD_VAR 0 7
51909: IFFALSE 51986
// begin tw := tw [ 1 ] ;
51911: LD_ADDR_VAR 0 7
51915: PUSH
51916: LD_VAR 0 7
51920: PUSH
51921: LD_INT 1
51923: ARRAY
51924: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
51925: LD_ADDR_VAR 0 9
51929: PUSH
51930: LD_VAR 0 7
51934: PPUSH
51935: LD_EXP 127
51939: PUSH
51940: LD_VAR 0 2
51944: ARRAY
51945: PPUSH
51946: CALL 80619 0 2
51950: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
51951: LD_EXP 141
51955: PUSH
51956: LD_VAR 0 2
51960: ARRAY
51961: IFFALSE 51984
// if not weapon in mc_allowed_tower_weapons [ i ] then
51963: LD_VAR 0 9
51967: PUSH
51968: LD_EXP 141
51972: PUSH
51973: LD_VAR 0 2
51977: ARRAY
51978: IN
51979: NOT
51980: IFFALSE 51984
// continue ;
51982: GO 51686
// end else
51984: GO 52049
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
51986: LD_ADDR_VAR 0 5
51990: PUSH
51991: LD_EXP 110
51995: PUSH
51996: LD_VAR 0 2
52000: ARRAY
52001: PPUSH
52002: LD_VAR 0 4
52006: PPUSH
52007: CALL 107511 0 2
52011: ST_TO_ADDR
// if not tmp2 then
52012: LD_VAR 0 5
52016: NOT
52017: IFFALSE 52021
// continue ;
52019: GO 51686
// tw := tmp2 [ 1 ] ;
52021: LD_ADDR_VAR 0 7
52025: PUSH
52026: LD_VAR 0 5
52030: PUSH
52031: LD_INT 1
52033: ARRAY
52034: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
52035: LD_ADDR_VAR 0 9
52039: PUSH
52040: LD_VAR 0 5
52044: PUSH
52045: LD_INT 2
52047: ARRAY
52048: ST_TO_ADDR
// end ; if not weapon then
52049: LD_VAR 0 9
52053: NOT
52054: IFFALSE 52058
// continue ;
52056: GO 51686
// ComPlaceWeapon ( tw , weapon ) ;
52058: LD_VAR 0 7
52062: PPUSH
52063: LD_VAR 0 9
52067: PPUSH
52068: CALL_OW 148
// end ;
52072: GO 51686
52074: POP
52075: POP
// end ;
52076: LD_VAR 0 1
52080: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
52081: LD_INT 0
52083: PPUSH
52084: PPUSH
52085: PPUSH
52086: PPUSH
52087: PPUSH
52088: PPUSH
52089: PPUSH
// if not mc_bases then
52090: LD_EXP 102
52094: NOT
52095: IFFALSE 52099
// exit ;
52097: GO 52874
// for i = 1 to mc_bases do
52099: LD_ADDR_VAR 0 2
52103: PUSH
52104: DOUBLE
52105: LD_INT 1
52107: DEC
52108: ST_TO_ADDR
52109: LD_EXP 102
52113: PUSH
52114: FOR_TO
52115: IFFALSE 52872
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
52117: LD_EXP 115
52121: PUSH
52122: LD_VAR 0 2
52126: ARRAY
52127: NOT
52128: PUSH
52129: LD_EXP 115
52133: PUSH
52134: LD_VAR 0 2
52138: ARRAY
52139: PUSH
52140: LD_EXP 116
52144: PUSH
52145: LD_VAR 0 2
52149: ARRAY
52150: EQUAL
52151: OR
52152: PUSH
52153: LD_EXP 125
52157: PUSH
52158: LD_VAR 0 2
52162: ARRAY
52163: OR
52164: IFFALSE 52168
// continue ;
52166: GO 52114
// if mc_miners [ i ] then
52168: LD_EXP 116
52172: PUSH
52173: LD_VAR 0 2
52177: ARRAY
52178: IFFALSE 52559
// begin for j = mc_miners [ i ] downto 1 do
52180: LD_ADDR_VAR 0 3
52184: PUSH
52185: DOUBLE
52186: LD_EXP 116
52190: PUSH
52191: LD_VAR 0 2
52195: ARRAY
52196: INC
52197: ST_TO_ADDR
52198: LD_INT 1
52200: PUSH
52201: FOR_DOWNTO
52202: IFFALSE 52557
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
52204: LD_EXP 116
52208: PUSH
52209: LD_VAR 0 2
52213: ARRAY
52214: PUSH
52215: LD_VAR 0 3
52219: ARRAY
52220: PPUSH
52221: CALL_OW 301
52225: PUSH
52226: LD_EXP 116
52230: PUSH
52231: LD_VAR 0 2
52235: ARRAY
52236: PUSH
52237: LD_VAR 0 3
52241: ARRAY
52242: PPUSH
52243: CALL_OW 257
52247: PUSH
52248: LD_INT 1
52250: NONEQUAL
52251: OR
52252: IFFALSE 52315
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
52254: LD_ADDR_VAR 0 5
52258: PUSH
52259: LD_EXP 116
52263: PUSH
52264: LD_VAR 0 2
52268: ARRAY
52269: PUSH
52270: LD_EXP 116
52274: PUSH
52275: LD_VAR 0 2
52279: ARRAY
52280: PUSH
52281: LD_VAR 0 3
52285: ARRAY
52286: DIFF
52287: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
52288: LD_ADDR_EXP 116
52292: PUSH
52293: LD_EXP 116
52297: PPUSH
52298: LD_VAR 0 2
52302: PPUSH
52303: LD_VAR 0 5
52307: PPUSH
52308: CALL_OW 1
52312: ST_TO_ADDR
// continue ;
52313: GO 52201
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
52315: LD_EXP 116
52319: PUSH
52320: LD_VAR 0 2
52324: ARRAY
52325: PUSH
52326: LD_VAR 0 3
52330: ARRAY
52331: PPUSH
52332: CALL_OW 257
52336: PUSH
52337: LD_INT 1
52339: EQUAL
52340: PUSH
52341: LD_EXP 116
52345: PUSH
52346: LD_VAR 0 2
52350: ARRAY
52351: PUSH
52352: LD_VAR 0 3
52356: ARRAY
52357: PPUSH
52358: CALL_OW 459
52362: NOT
52363: AND
52364: PUSH
52365: LD_EXP 116
52369: PUSH
52370: LD_VAR 0 2
52374: ARRAY
52375: PUSH
52376: LD_VAR 0 3
52380: ARRAY
52381: PPUSH
52382: CALL_OW 314
52386: NOT
52387: AND
52388: IFFALSE 52555
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
52390: LD_EXP 116
52394: PUSH
52395: LD_VAR 0 2
52399: ARRAY
52400: PUSH
52401: LD_VAR 0 3
52405: ARRAY
52406: PPUSH
52407: CALL_OW 310
52411: IFFALSE 52434
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
52413: LD_EXP 116
52417: PUSH
52418: LD_VAR 0 2
52422: ARRAY
52423: PUSH
52424: LD_VAR 0 3
52428: ARRAY
52429: PPUSH
52430: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
52434: LD_EXP 116
52438: PUSH
52439: LD_VAR 0 2
52443: ARRAY
52444: PUSH
52445: LD_VAR 0 3
52449: ARRAY
52450: PPUSH
52451: CALL_OW 314
52455: NOT
52456: IFFALSE 52555
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
52458: LD_ADDR_VAR 0 7
52462: PUSH
52463: LD_VAR 0 3
52467: PUSH
52468: LD_EXP 115
52472: PUSH
52473: LD_VAR 0 2
52477: ARRAY
52478: PPUSH
52479: CALL 72374 0 1
52483: MOD
52484: PUSH
52485: LD_INT 1
52487: PLUS
52488: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
52489: LD_EXP 116
52493: PUSH
52494: LD_VAR 0 2
52498: ARRAY
52499: PUSH
52500: LD_VAR 0 3
52504: ARRAY
52505: PPUSH
52506: LD_EXP 115
52510: PUSH
52511: LD_VAR 0 2
52515: ARRAY
52516: PUSH
52517: LD_VAR 0 7
52521: ARRAY
52522: PUSH
52523: LD_INT 1
52525: ARRAY
52526: PPUSH
52527: LD_EXP 115
52531: PUSH
52532: LD_VAR 0 2
52536: ARRAY
52537: PUSH
52538: LD_VAR 0 7
52542: ARRAY
52543: PUSH
52544: LD_INT 2
52546: ARRAY
52547: PPUSH
52548: LD_INT 0
52550: PPUSH
52551: CALL_OW 193
// end ; end ; end ;
52555: GO 52201
52557: POP
52558: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
52559: LD_ADDR_VAR 0 5
52563: PUSH
52564: LD_EXP 102
52568: PUSH
52569: LD_VAR 0 2
52573: ARRAY
52574: PPUSH
52575: LD_INT 2
52577: PUSH
52578: LD_INT 30
52580: PUSH
52581: LD_INT 4
52583: PUSH
52584: EMPTY
52585: LIST
52586: LIST
52587: PUSH
52588: LD_INT 30
52590: PUSH
52591: LD_INT 5
52593: PUSH
52594: EMPTY
52595: LIST
52596: LIST
52597: PUSH
52598: LD_INT 30
52600: PUSH
52601: LD_INT 32
52603: PUSH
52604: EMPTY
52605: LIST
52606: LIST
52607: PUSH
52608: EMPTY
52609: LIST
52610: LIST
52611: LIST
52612: LIST
52613: PPUSH
52614: CALL_OW 72
52618: ST_TO_ADDR
// if not tmp then
52619: LD_VAR 0 5
52623: NOT
52624: IFFALSE 52628
// continue ;
52626: GO 52114
// list := [ ] ;
52628: LD_ADDR_VAR 0 6
52632: PUSH
52633: EMPTY
52634: ST_TO_ADDR
// for j in tmp do
52635: LD_ADDR_VAR 0 3
52639: PUSH
52640: LD_VAR 0 5
52644: PUSH
52645: FOR_IN
52646: IFFALSE 52715
// begin for k in UnitsInside ( j ) do
52648: LD_ADDR_VAR 0 4
52652: PUSH
52653: LD_VAR 0 3
52657: PPUSH
52658: CALL_OW 313
52662: PUSH
52663: FOR_IN
52664: IFFALSE 52711
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
52666: LD_VAR 0 4
52670: PPUSH
52671: CALL_OW 257
52675: PUSH
52676: LD_INT 1
52678: EQUAL
52679: PUSH
52680: LD_VAR 0 4
52684: PPUSH
52685: CALL_OW 459
52689: NOT
52690: AND
52691: IFFALSE 52709
// list := list ^ k ;
52693: LD_ADDR_VAR 0 6
52697: PUSH
52698: LD_VAR 0 6
52702: PUSH
52703: LD_VAR 0 4
52707: ADD
52708: ST_TO_ADDR
52709: GO 52663
52711: POP
52712: POP
// end ;
52713: GO 52645
52715: POP
52716: POP
// list := list diff mc_miners [ i ] ;
52717: LD_ADDR_VAR 0 6
52721: PUSH
52722: LD_VAR 0 6
52726: PUSH
52727: LD_EXP 116
52731: PUSH
52732: LD_VAR 0 2
52736: ARRAY
52737: DIFF
52738: ST_TO_ADDR
// if not list then
52739: LD_VAR 0 6
52743: NOT
52744: IFFALSE 52748
// continue ;
52746: GO 52114
// k := mc_mines [ i ] - mc_miners [ i ] ;
52748: LD_ADDR_VAR 0 4
52752: PUSH
52753: LD_EXP 115
52757: PUSH
52758: LD_VAR 0 2
52762: ARRAY
52763: PUSH
52764: LD_EXP 116
52768: PUSH
52769: LD_VAR 0 2
52773: ARRAY
52774: MINUS
52775: ST_TO_ADDR
// if k > list then
52776: LD_VAR 0 4
52780: PUSH
52781: LD_VAR 0 6
52785: GREATER
52786: IFFALSE 52798
// k := list ;
52788: LD_ADDR_VAR 0 4
52792: PUSH
52793: LD_VAR 0 6
52797: ST_TO_ADDR
// for j = 1 to k do
52798: LD_ADDR_VAR 0 3
52802: PUSH
52803: DOUBLE
52804: LD_INT 1
52806: DEC
52807: ST_TO_ADDR
52808: LD_VAR 0 4
52812: PUSH
52813: FOR_TO
52814: IFFALSE 52868
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
52816: LD_ADDR_EXP 116
52820: PUSH
52821: LD_EXP 116
52825: PPUSH
52826: LD_VAR 0 2
52830: PUSH
52831: LD_EXP 116
52835: PUSH
52836: LD_VAR 0 2
52840: ARRAY
52841: PUSH
52842: LD_INT 1
52844: PLUS
52845: PUSH
52846: EMPTY
52847: LIST
52848: LIST
52849: PPUSH
52850: LD_VAR 0 6
52854: PUSH
52855: LD_VAR 0 3
52859: ARRAY
52860: PPUSH
52861: CALL 75234 0 3
52865: ST_TO_ADDR
52866: GO 52813
52868: POP
52869: POP
// end ;
52870: GO 52114
52872: POP
52873: POP
// end ;
52874: LD_VAR 0 1
52878: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
52879: LD_INT 0
52881: PPUSH
52882: PPUSH
52883: PPUSH
52884: PPUSH
52885: PPUSH
52886: PPUSH
52887: PPUSH
52888: PPUSH
52889: PPUSH
52890: PPUSH
52891: PPUSH
// if not mc_bases then
52892: LD_EXP 102
52896: NOT
52897: IFFALSE 52901
// exit ;
52899: GO 54724
// for i = 1 to mc_bases do
52901: LD_ADDR_VAR 0 2
52905: PUSH
52906: DOUBLE
52907: LD_INT 1
52909: DEC
52910: ST_TO_ADDR
52911: LD_EXP 102
52915: PUSH
52916: FOR_TO
52917: IFFALSE 54722
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
52919: LD_EXP 102
52923: PUSH
52924: LD_VAR 0 2
52928: ARRAY
52929: NOT
52930: PUSH
52931: LD_EXP 109
52935: PUSH
52936: LD_VAR 0 2
52940: ARRAY
52941: OR
52942: IFFALSE 52946
// continue ;
52944: GO 52916
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
52946: LD_EXP 118
52950: PUSH
52951: LD_VAR 0 2
52955: ARRAY
52956: NOT
52957: PUSH
52958: LD_EXP 119
52962: PUSH
52963: LD_VAR 0 2
52967: ARRAY
52968: AND
52969: IFFALSE 53007
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
52971: LD_ADDR_EXP 119
52975: PUSH
52976: LD_EXP 119
52980: PPUSH
52981: LD_VAR 0 2
52985: PPUSH
52986: EMPTY
52987: PPUSH
52988: CALL_OW 1
52992: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
52993: LD_VAR 0 2
52997: PPUSH
52998: LD_INT 107
53000: PPUSH
53001: CALL 43733 0 2
// continue ;
53005: GO 52916
// end ; target := [ ] ;
53007: LD_ADDR_VAR 0 7
53011: PUSH
53012: EMPTY
53013: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
53014: LD_ADDR_VAR 0 6
53018: PUSH
53019: LD_EXP 102
53023: PUSH
53024: LD_VAR 0 2
53028: ARRAY
53029: PUSH
53030: LD_INT 1
53032: ARRAY
53033: PPUSH
53034: CALL_OW 255
53038: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53039: LD_ADDR_VAR 0 9
53043: PUSH
53044: LD_EXP 102
53048: PUSH
53049: LD_VAR 0 2
53053: ARRAY
53054: PPUSH
53055: LD_INT 2
53057: PUSH
53058: LD_INT 30
53060: PUSH
53061: LD_INT 0
53063: PUSH
53064: EMPTY
53065: LIST
53066: LIST
53067: PUSH
53068: LD_INT 30
53070: PUSH
53071: LD_INT 1
53073: PUSH
53074: EMPTY
53075: LIST
53076: LIST
53077: PUSH
53078: EMPTY
53079: LIST
53080: LIST
53081: LIST
53082: PPUSH
53083: CALL_OW 72
53087: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
53088: LD_ADDR_VAR 0 3
53092: PUSH
53093: DOUBLE
53094: LD_EXP 118
53098: PUSH
53099: LD_VAR 0 2
53103: ARRAY
53104: INC
53105: ST_TO_ADDR
53106: LD_INT 1
53108: PUSH
53109: FOR_DOWNTO
53110: IFFALSE 53355
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
53112: LD_EXP 118
53116: PUSH
53117: LD_VAR 0 2
53121: ARRAY
53122: PUSH
53123: LD_VAR 0 3
53127: ARRAY
53128: PUSH
53129: LD_INT 2
53131: ARRAY
53132: PPUSH
53133: LD_EXP 118
53137: PUSH
53138: LD_VAR 0 2
53142: ARRAY
53143: PUSH
53144: LD_VAR 0 3
53148: ARRAY
53149: PUSH
53150: LD_INT 3
53152: ARRAY
53153: PPUSH
53154: CALL_OW 488
53158: PUSH
53159: LD_EXP 118
53163: PUSH
53164: LD_VAR 0 2
53168: ARRAY
53169: PUSH
53170: LD_VAR 0 3
53174: ARRAY
53175: PUSH
53176: LD_INT 2
53178: ARRAY
53179: PPUSH
53180: LD_EXP 118
53184: PUSH
53185: LD_VAR 0 2
53189: ARRAY
53190: PUSH
53191: LD_VAR 0 3
53195: ARRAY
53196: PUSH
53197: LD_INT 3
53199: ARRAY
53200: PPUSH
53201: CALL_OW 284
53205: PUSH
53206: LD_INT 0
53208: EQUAL
53209: AND
53210: IFFALSE 53265
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
53212: LD_ADDR_VAR 0 5
53216: PUSH
53217: LD_EXP 118
53221: PUSH
53222: LD_VAR 0 2
53226: ARRAY
53227: PPUSH
53228: LD_VAR 0 3
53232: PPUSH
53233: CALL_OW 3
53237: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
53238: LD_ADDR_EXP 118
53242: PUSH
53243: LD_EXP 118
53247: PPUSH
53248: LD_VAR 0 2
53252: PPUSH
53253: LD_VAR 0 5
53257: PPUSH
53258: CALL_OW 1
53262: ST_TO_ADDR
// continue ;
53263: GO 53109
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
53265: LD_VAR 0 6
53269: PPUSH
53270: LD_EXP 118
53274: PUSH
53275: LD_VAR 0 2
53279: ARRAY
53280: PUSH
53281: LD_VAR 0 3
53285: ARRAY
53286: PUSH
53287: LD_INT 2
53289: ARRAY
53290: PPUSH
53291: LD_EXP 118
53295: PUSH
53296: LD_VAR 0 2
53300: ARRAY
53301: PUSH
53302: LD_VAR 0 3
53306: ARRAY
53307: PUSH
53308: LD_INT 3
53310: ARRAY
53311: PPUSH
53312: LD_INT 30
53314: PPUSH
53315: CALL 76498 0 4
53319: PUSH
53320: LD_INT 4
53322: ARRAY
53323: PUSH
53324: LD_INT 0
53326: EQUAL
53327: IFFALSE 53353
// begin target := mc_crates [ i ] [ j ] ;
53329: LD_ADDR_VAR 0 7
53333: PUSH
53334: LD_EXP 118
53338: PUSH
53339: LD_VAR 0 2
53343: ARRAY
53344: PUSH
53345: LD_VAR 0 3
53349: ARRAY
53350: ST_TO_ADDR
// break ;
53351: GO 53355
// end ; end ;
53353: GO 53109
53355: POP
53356: POP
// if not target then
53357: LD_VAR 0 7
53361: NOT
53362: IFFALSE 53366
// continue ;
53364: GO 52916
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
53366: LD_ADDR_VAR 0 8
53370: PUSH
53371: LD_EXP 121
53375: PUSH
53376: LD_VAR 0 2
53380: ARRAY
53381: PPUSH
53382: LD_INT 2
53384: PUSH
53385: LD_INT 3
53387: PUSH
53388: LD_INT 58
53390: PUSH
53391: EMPTY
53392: LIST
53393: PUSH
53394: EMPTY
53395: LIST
53396: LIST
53397: PUSH
53398: LD_INT 61
53400: PUSH
53401: EMPTY
53402: LIST
53403: PUSH
53404: LD_INT 33
53406: PUSH
53407: LD_INT 5
53409: PUSH
53410: EMPTY
53411: LIST
53412: LIST
53413: PUSH
53414: LD_INT 33
53416: PUSH
53417: LD_INT 3
53419: PUSH
53420: EMPTY
53421: LIST
53422: LIST
53423: PUSH
53424: EMPTY
53425: LIST
53426: LIST
53427: LIST
53428: LIST
53429: LIST
53430: PUSH
53431: LD_INT 2
53433: PUSH
53434: LD_INT 34
53436: PUSH
53437: LD_INT 32
53439: PUSH
53440: EMPTY
53441: LIST
53442: LIST
53443: PUSH
53444: LD_INT 34
53446: PUSH
53447: LD_INT 51
53449: PUSH
53450: EMPTY
53451: LIST
53452: LIST
53453: PUSH
53454: LD_INT 34
53456: PUSH
53457: LD_INT 12
53459: PUSH
53460: EMPTY
53461: LIST
53462: LIST
53463: PUSH
53464: EMPTY
53465: LIST
53466: LIST
53467: LIST
53468: LIST
53469: PUSH
53470: EMPTY
53471: LIST
53472: LIST
53473: PPUSH
53474: CALL_OW 72
53478: ST_TO_ADDR
// if not cargo then
53479: LD_VAR 0 8
53483: NOT
53484: IFFALSE 54190
// begin if mc_crates_collector [ i ] < 5 then
53486: LD_EXP 119
53490: PUSH
53491: LD_VAR 0 2
53495: ARRAY
53496: PUSH
53497: LD_INT 5
53499: LESS
53500: IFFALSE 53866
// begin if mc_ape [ i ] then
53502: LD_EXP 131
53506: PUSH
53507: LD_VAR 0 2
53511: ARRAY
53512: IFFALSE 53559
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
53514: LD_ADDR_VAR 0 5
53518: PUSH
53519: LD_EXP 131
53523: PUSH
53524: LD_VAR 0 2
53528: ARRAY
53529: PPUSH
53530: LD_INT 25
53532: PUSH
53533: LD_INT 16
53535: PUSH
53536: EMPTY
53537: LIST
53538: LIST
53539: PUSH
53540: LD_INT 24
53542: PUSH
53543: LD_INT 750
53545: PUSH
53546: EMPTY
53547: LIST
53548: LIST
53549: PUSH
53550: EMPTY
53551: LIST
53552: LIST
53553: PPUSH
53554: CALL_OW 72
53558: ST_TO_ADDR
// if not tmp then
53559: LD_VAR 0 5
53563: NOT
53564: IFFALSE 53611
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
53566: LD_ADDR_VAR 0 5
53570: PUSH
53571: LD_EXP 102
53575: PUSH
53576: LD_VAR 0 2
53580: ARRAY
53581: PPUSH
53582: LD_INT 25
53584: PUSH
53585: LD_INT 2
53587: PUSH
53588: EMPTY
53589: LIST
53590: LIST
53591: PUSH
53592: LD_INT 24
53594: PUSH
53595: LD_INT 750
53597: PUSH
53598: EMPTY
53599: LIST
53600: LIST
53601: PUSH
53602: EMPTY
53603: LIST
53604: LIST
53605: PPUSH
53606: CALL_OW 72
53610: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
53611: LD_EXP 131
53615: PUSH
53616: LD_VAR 0 2
53620: ARRAY
53621: PUSH
53622: LD_EXP 102
53626: PUSH
53627: LD_VAR 0 2
53631: ARRAY
53632: PPUSH
53633: LD_INT 25
53635: PUSH
53636: LD_INT 2
53638: PUSH
53639: EMPTY
53640: LIST
53641: LIST
53642: PUSH
53643: LD_INT 24
53645: PUSH
53646: LD_INT 750
53648: PUSH
53649: EMPTY
53650: LIST
53651: LIST
53652: PUSH
53653: EMPTY
53654: LIST
53655: LIST
53656: PPUSH
53657: CALL_OW 72
53661: AND
53662: PUSH
53663: LD_VAR 0 5
53667: PUSH
53668: LD_INT 5
53670: LESS
53671: AND
53672: IFFALSE 53754
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
53674: LD_ADDR_VAR 0 3
53678: PUSH
53679: LD_EXP 102
53683: PUSH
53684: LD_VAR 0 2
53688: ARRAY
53689: PPUSH
53690: LD_INT 25
53692: PUSH
53693: LD_INT 2
53695: PUSH
53696: EMPTY
53697: LIST
53698: LIST
53699: PUSH
53700: LD_INT 24
53702: PUSH
53703: LD_INT 750
53705: PUSH
53706: EMPTY
53707: LIST
53708: LIST
53709: PUSH
53710: EMPTY
53711: LIST
53712: LIST
53713: PPUSH
53714: CALL_OW 72
53718: PUSH
53719: FOR_IN
53720: IFFALSE 53752
// begin tmp := tmp union j ;
53722: LD_ADDR_VAR 0 5
53726: PUSH
53727: LD_VAR 0 5
53731: PUSH
53732: LD_VAR 0 3
53736: UNION
53737: ST_TO_ADDR
// if tmp >= 5 then
53738: LD_VAR 0 5
53742: PUSH
53743: LD_INT 5
53745: GREATEREQUAL
53746: IFFALSE 53750
// break ;
53748: GO 53752
// end ;
53750: GO 53719
53752: POP
53753: POP
// end ; if not tmp then
53754: LD_VAR 0 5
53758: NOT
53759: IFFALSE 53763
// continue ;
53761: GO 52916
// for j in tmp do
53763: LD_ADDR_VAR 0 3
53767: PUSH
53768: LD_VAR 0 5
53772: PUSH
53773: FOR_IN
53774: IFFALSE 53864
// if not GetTag ( j ) then
53776: LD_VAR 0 3
53780: PPUSH
53781: CALL_OW 110
53785: NOT
53786: IFFALSE 53862
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
53788: LD_ADDR_EXP 119
53792: PUSH
53793: LD_EXP 119
53797: PPUSH
53798: LD_VAR 0 2
53802: PUSH
53803: LD_EXP 119
53807: PUSH
53808: LD_VAR 0 2
53812: ARRAY
53813: PUSH
53814: LD_INT 1
53816: PLUS
53817: PUSH
53818: EMPTY
53819: LIST
53820: LIST
53821: PPUSH
53822: LD_VAR 0 3
53826: PPUSH
53827: CALL 75234 0 3
53831: ST_TO_ADDR
// SetTag ( j , 107 ) ;
53832: LD_VAR 0 3
53836: PPUSH
53837: LD_INT 107
53839: PPUSH
53840: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
53844: LD_EXP 119
53848: PUSH
53849: LD_VAR 0 2
53853: ARRAY
53854: PUSH
53855: LD_INT 5
53857: GREATEREQUAL
53858: IFFALSE 53862
// break ;
53860: GO 53864
// end ;
53862: GO 53773
53864: POP
53865: POP
// end ; if mc_crates_collector [ i ] and target then
53866: LD_EXP 119
53870: PUSH
53871: LD_VAR 0 2
53875: ARRAY
53876: PUSH
53877: LD_VAR 0 7
53881: AND
53882: IFFALSE 54188
// begin if mc_crates_collector [ i ] < target [ 1 ] then
53884: LD_EXP 119
53888: PUSH
53889: LD_VAR 0 2
53893: ARRAY
53894: PUSH
53895: LD_VAR 0 7
53899: PUSH
53900: LD_INT 1
53902: ARRAY
53903: LESS
53904: IFFALSE 53924
// tmp := mc_crates_collector [ i ] else
53906: LD_ADDR_VAR 0 5
53910: PUSH
53911: LD_EXP 119
53915: PUSH
53916: LD_VAR 0 2
53920: ARRAY
53921: ST_TO_ADDR
53922: GO 53938
// tmp := target [ 1 ] ;
53924: LD_ADDR_VAR 0 5
53928: PUSH
53929: LD_VAR 0 7
53933: PUSH
53934: LD_INT 1
53936: ARRAY
53937: ST_TO_ADDR
// k := 0 ;
53938: LD_ADDR_VAR 0 4
53942: PUSH
53943: LD_INT 0
53945: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
53946: LD_ADDR_VAR 0 3
53950: PUSH
53951: LD_EXP 119
53955: PUSH
53956: LD_VAR 0 2
53960: ARRAY
53961: PUSH
53962: FOR_IN
53963: IFFALSE 54186
// begin k := k + 1 ;
53965: LD_ADDR_VAR 0 4
53969: PUSH
53970: LD_VAR 0 4
53974: PUSH
53975: LD_INT 1
53977: PLUS
53978: ST_TO_ADDR
// if k > tmp then
53979: LD_VAR 0 4
53983: PUSH
53984: LD_VAR 0 5
53988: GREATER
53989: IFFALSE 53993
// break ;
53991: GO 54186
// if not GetClass ( j ) in [ 2 , 16 ] then
53993: LD_VAR 0 3
53997: PPUSH
53998: CALL_OW 257
54002: PUSH
54003: LD_INT 2
54005: PUSH
54006: LD_INT 16
54008: PUSH
54009: EMPTY
54010: LIST
54011: LIST
54012: IN
54013: NOT
54014: IFFALSE 54067
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
54016: LD_ADDR_EXP 119
54020: PUSH
54021: LD_EXP 119
54025: PPUSH
54026: LD_VAR 0 2
54030: PPUSH
54031: LD_EXP 119
54035: PUSH
54036: LD_VAR 0 2
54040: ARRAY
54041: PUSH
54042: LD_VAR 0 3
54046: DIFF
54047: PPUSH
54048: CALL_OW 1
54052: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54053: LD_VAR 0 3
54057: PPUSH
54058: LD_INT 0
54060: PPUSH
54061: CALL_OW 109
// continue ;
54065: GO 53962
// end ; if IsInUnit ( j ) then
54067: LD_VAR 0 3
54071: PPUSH
54072: CALL_OW 310
54076: IFFALSE 54087
// ComExitBuilding ( j ) ;
54078: LD_VAR 0 3
54082: PPUSH
54083: CALL_OW 122
// wait ( 3 ) ;
54087: LD_INT 3
54089: PPUSH
54090: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
54094: LD_VAR 0 3
54098: PPUSH
54099: CALL_OW 314
54103: PUSH
54104: LD_VAR 0 6
54108: PPUSH
54109: LD_VAR 0 7
54113: PUSH
54114: LD_INT 2
54116: ARRAY
54117: PPUSH
54118: LD_VAR 0 7
54122: PUSH
54123: LD_INT 3
54125: ARRAY
54126: PPUSH
54127: LD_INT 30
54129: PPUSH
54130: CALL 76498 0 4
54134: PUSH
54135: LD_INT 4
54137: ARRAY
54138: AND
54139: IFFALSE 54157
// ComStandNearbyBuilding ( j , depot ) else
54141: LD_VAR 0 3
54145: PPUSH
54146: LD_VAR 0 9
54150: PPUSH
54151: CALL 71836 0 2
54155: GO 54184
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
54157: LD_VAR 0 3
54161: PPUSH
54162: LD_VAR 0 7
54166: PUSH
54167: LD_INT 2
54169: ARRAY
54170: PPUSH
54171: LD_VAR 0 7
54175: PUSH
54176: LD_INT 3
54178: ARRAY
54179: PPUSH
54180: CALL_OW 117
// end ;
54184: GO 53962
54186: POP
54187: POP
// end ; end else
54188: GO 54720
// begin for j in cargo do
54190: LD_ADDR_VAR 0 3
54194: PUSH
54195: LD_VAR 0 8
54199: PUSH
54200: FOR_IN
54201: IFFALSE 54718
// begin if GetTag ( j ) <> 0 then
54203: LD_VAR 0 3
54207: PPUSH
54208: CALL_OW 110
54212: PUSH
54213: LD_INT 0
54215: NONEQUAL
54216: IFFALSE 54220
// continue ;
54218: GO 54200
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
54220: LD_VAR 0 3
54224: PPUSH
54225: CALL_OW 256
54229: PUSH
54230: LD_INT 1000
54232: LESS
54233: PUSH
54234: LD_VAR 0 3
54238: PPUSH
54239: LD_EXP 126
54243: PUSH
54244: LD_VAR 0 2
54248: ARRAY
54249: PPUSH
54250: CALL_OW 308
54254: NOT
54255: AND
54256: IFFALSE 54278
// ComMoveToArea ( j , mc_parking [ i ] ) ;
54258: LD_VAR 0 3
54262: PPUSH
54263: LD_EXP 126
54267: PUSH
54268: LD_VAR 0 2
54272: ARRAY
54273: PPUSH
54274: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
54278: LD_VAR 0 3
54282: PPUSH
54283: CALL_OW 256
54287: PUSH
54288: LD_INT 1000
54290: LESS
54291: PUSH
54292: LD_VAR 0 3
54296: PPUSH
54297: LD_EXP 126
54301: PUSH
54302: LD_VAR 0 2
54306: ARRAY
54307: PPUSH
54308: CALL_OW 308
54312: AND
54313: IFFALSE 54317
// continue ;
54315: GO 54200
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
54317: LD_VAR 0 3
54321: PPUSH
54322: CALL_OW 262
54326: PUSH
54327: LD_INT 2
54329: EQUAL
54330: PUSH
54331: LD_VAR 0 3
54335: PPUSH
54336: CALL_OW 261
54340: PUSH
54341: LD_INT 15
54343: LESS
54344: AND
54345: IFFALSE 54349
// continue ;
54347: GO 54200
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
54349: LD_VAR 0 3
54353: PPUSH
54354: CALL_OW 262
54358: PUSH
54359: LD_INT 1
54361: EQUAL
54362: PUSH
54363: LD_VAR 0 3
54367: PPUSH
54368: CALL_OW 261
54372: PUSH
54373: LD_INT 10
54375: LESS
54376: AND
54377: IFFALSE 54657
// begin if not depot then
54379: LD_VAR 0 9
54383: NOT
54384: IFFALSE 54388
// continue ;
54386: GO 54200
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
54388: LD_VAR 0 3
54392: PPUSH
54393: LD_VAR 0 9
54397: PPUSH
54398: LD_VAR 0 3
54402: PPUSH
54403: CALL_OW 74
54407: PPUSH
54408: CALL_OW 296
54412: PUSH
54413: LD_INT 6
54415: LESS
54416: IFFALSE 54432
// SetFuel ( j , 100 ) else
54418: LD_VAR 0 3
54422: PPUSH
54423: LD_INT 100
54425: PPUSH
54426: CALL_OW 240
54430: GO 54657
// if GetFuel ( j ) = 0 then
54432: LD_VAR 0 3
54436: PPUSH
54437: CALL_OW 261
54441: PUSH
54442: LD_INT 0
54444: EQUAL
54445: IFFALSE 54657
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
54447: LD_ADDR_EXP 121
54451: PUSH
54452: LD_EXP 121
54456: PPUSH
54457: LD_VAR 0 2
54461: PPUSH
54462: LD_EXP 121
54466: PUSH
54467: LD_VAR 0 2
54471: ARRAY
54472: PUSH
54473: LD_VAR 0 3
54477: DIFF
54478: PPUSH
54479: CALL_OW 1
54483: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
54484: LD_VAR 0 3
54488: PPUSH
54489: CALL_OW 263
54493: PUSH
54494: LD_INT 1
54496: EQUAL
54497: IFFALSE 54513
// ComExitVehicle ( IsInUnit ( j ) ) ;
54499: LD_VAR 0 3
54503: PPUSH
54504: CALL_OW 310
54508: PPUSH
54509: CALL_OW 121
// if GetControl ( j ) = control_remote then
54513: LD_VAR 0 3
54517: PPUSH
54518: CALL_OW 263
54522: PUSH
54523: LD_INT 2
54525: EQUAL
54526: IFFALSE 54537
// ComUnlink ( j ) ;
54528: LD_VAR 0 3
54532: PPUSH
54533: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
54537: LD_ADDR_VAR 0 10
54541: PUSH
54542: LD_VAR 0 2
54546: PPUSH
54547: LD_INT 3
54549: PPUSH
54550: CALL 64301 0 2
54554: ST_TO_ADDR
// if fac then
54555: LD_VAR 0 10
54559: IFFALSE 54655
// begin for k in fac do
54561: LD_ADDR_VAR 0 4
54565: PUSH
54566: LD_VAR 0 10
54570: PUSH
54571: FOR_IN
54572: IFFALSE 54653
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
54574: LD_ADDR_VAR 0 11
54578: PUSH
54579: LD_VAR 0 10
54583: PPUSH
54584: LD_VAR 0 3
54588: PPUSH
54589: CALL_OW 265
54593: PPUSH
54594: LD_VAR 0 3
54598: PPUSH
54599: CALL_OW 262
54603: PPUSH
54604: LD_VAR 0 3
54608: PPUSH
54609: CALL_OW 263
54613: PPUSH
54614: LD_VAR 0 3
54618: PPUSH
54619: CALL_OW 264
54623: PPUSH
54624: CALL 72732 0 5
54628: ST_TO_ADDR
// if components then
54629: LD_VAR 0 11
54633: IFFALSE 54651
// begin MC_InsertProduceList ( i , components ) ;
54635: LD_VAR 0 2
54639: PPUSH
54640: LD_VAR 0 11
54644: PPUSH
54645: CALL 63846 0 2
// break ;
54649: GO 54653
// end ; end ;
54651: GO 54571
54653: POP
54654: POP
// end ; continue ;
54655: GO 54200
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
54657: LD_VAR 0 3
54661: PPUSH
54662: LD_INT 1
54664: PPUSH
54665: CALL_OW 289
54669: PUSH
54670: LD_INT 100
54672: LESS
54673: PUSH
54674: LD_VAR 0 3
54678: PPUSH
54679: CALL_OW 314
54683: NOT
54684: AND
54685: IFFALSE 54714
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
54687: LD_VAR 0 3
54691: PPUSH
54692: LD_VAR 0 7
54696: PUSH
54697: LD_INT 2
54699: ARRAY
54700: PPUSH
54701: LD_VAR 0 7
54705: PUSH
54706: LD_INT 3
54708: ARRAY
54709: PPUSH
54710: CALL_OW 117
// break ;
54714: GO 54718
// end ;
54716: GO 54200
54718: POP
54719: POP
// end ; end ;
54720: GO 52916
54722: POP
54723: POP
// end ;
54724: LD_VAR 0 1
54728: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
54729: LD_INT 0
54731: PPUSH
54732: PPUSH
54733: PPUSH
54734: PPUSH
// if not mc_bases then
54735: LD_EXP 102
54739: NOT
54740: IFFALSE 54744
// exit ;
54742: GO 54905
// for i = 1 to mc_bases do
54744: LD_ADDR_VAR 0 2
54748: PUSH
54749: DOUBLE
54750: LD_INT 1
54752: DEC
54753: ST_TO_ADDR
54754: LD_EXP 102
54758: PUSH
54759: FOR_TO
54760: IFFALSE 54903
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
54762: LD_ADDR_VAR 0 4
54766: PUSH
54767: LD_EXP 121
54771: PUSH
54772: LD_VAR 0 2
54776: ARRAY
54777: PUSH
54778: LD_EXP 124
54782: PUSH
54783: LD_VAR 0 2
54787: ARRAY
54788: UNION
54789: PPUSH
54790: LD_INT 33
54792: PUSH
54793: LD_INT 2
54795: PUSH
54796: EMPTY
54797: LIST
54798: LIST
54799: PPUSH
54800: CALL_OW 72
54804: ST_TO_ADDR
// if tmp then
54805: LD_VAR 0 4
54809: IFFALSE 54901
// for j in tmp do
54811: LD_ADDR_VAR 0 3
54815: PUSH
54816: LD_VAR 0 4
54820: PUSH
54821: FOR_IN
54822: IFFALSE 54899
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
54824: LD_VAR 0 3
54828: PPUSH
54829: CALL_OW 312
54833: NOT
54834: PUSH
54835: LD_VAR 0 3
54839: PPUSH
54840: CALL_OW 256
54844: PUSH
54845: LD_INT 250
54847: GREATEREQUAL
54848: AND
54849: IFFALSE 54862
// Connect ( j ) else
54851: LD_VAR 0 3
54855: PPUSH
54856: CALL 78580 0 1
54860: GO 54897
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
54862: LD_VAR 0 3
54866: PPUSH
54867: CALL_OW 256
54871: PUSH
54872: LD_INT 250
54874: LESS
54875: PUSH
54876: LD_VAR 0 3
54880: PPUSH
54881: CALL_OW 312
54885: AND
54886: IFFALSE 54897
// ComUnlink ( j ) ;
54888: LD_VAR 0 3
54892: PPUSH
54893: CALL_OW 136
54897: GO 54821
54899: POP
54900: POP
// end ;
54901: GO 54759
54903: POP
54904: POP
// end ;
54905: LD_VAR 0 1
54909: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
54910: LD_INT 0
54912: PPUSH
54913: PPUSH
54914: PPUSH
54915: PPUSH
54916: PPUSH
// if not mc_bases then
54917: LD_EXP 102
54921: NOT
54922: IFFALSE 54926
// exit ;
54924: GO 55371
// for i = 1 to mc_bases do
54926: LD_ADDR_VAR 0 2
54930: PUSH
54931: DOUBLE
54932: LD_INT 1
54934: DEC
54935: ST_TO_ADDR
54936: LD_EXP 102
54940: PUSH
54941: FOR_TO
54942: IFFALSE 55369
// begin if not mc_produce [ i ] then
54944: LD_EXP 123
54948: PUSH
54949: LD_VAR 0 2
54953: ARRAY
54954: NOT
54955: IFFALSE 54959
// continue ;
54957: GO 54941
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54959: LD_ADDR_VAR 0 5
54963: PUSH
54964: LD_EXP 102
54968: PUSH
54969: LD_VAR 0 2
54973: ARRAY
54974: PPUSH
54975: LD_INT 30
54977: PUSH
54978: LD_INT 3
54980: PUSH
54981: EMPTY
54982: LIST
54983: LIST
54984: PPUSH
54985: CALL_OW 72
54989: ST_TO_ADDR
// if not fac then
54990: LD_VAR 0 5
54994: NOT
54995: IFFALSE 54999
// continue ;
54997: GO 54941
// for j in fac do
54999: LD_ADDR_VAR 0 3
55003: PUSH
55004: LD_VAR 0 5
55008: PUSH
55009: FOR_IN
55010: IFFALSE 55365
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
55012: LD_VAR 0 3
55016: PPUSH
55017: CALL_OW 461
55021: PUSH
55022: LD_INT 2
55024: NONEQUAL
55025: PUSH
55026: LD_VAR 0 3
55030: PPUSH
55031: LD_INT 15
55033: PPUSH
55034: CALL 78199 0 2
55038: PUSH
55039: LD_INT 4
55041: ARRAY
55042: OR
55043: IFFALSE 55047
// continue ;
55045: GO 55009
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
55047: LD_VAR 0 3
55051: PPUSH
55052: LD_EXP 123
55056: PUSH
55057: LD_VAR 0 2
55061: ARRAY
55062: PUSH
55063: LD_INT 1
55065: ARRAY
55066: PUSH
55067: LD_INT 1
55069: ARRAY
55070: PPUSH
55071: LD_EXP 123
55075: PUSH
55076: LD_VAR 0 2
55080: ARRAY
55081: PUSH
55082: LD_INT 1
55084: ARRAY
55085: PUSH
55086: LD_INT 2
55088: ARRAY
55089: PPUSH
55090: LD_EXP 123
55094: PUSH
55095: LD_VAR 0 2
55099: ARRAY
55100: PUSH
55101: LD_INT 1
55103: ARRAY
55104: PUSH
55105: LD_INT 3
55107: ARRAY
55108: PPUSH
55109: LD_EXP 123
55113: PUSH
55114: LD_VAR 0 2
55118: ARRAY
55119: PUSH
55120: LD_INT 1
55122: ARRAY
55123: PUSH
55124: LD_INT 4
55126: ARRAY
55127: PPUSH
55128: CALL_OW 448
55132: PUSH
55133: LD_VAR 0 3
55137: PPUSH
55138: LD_EXP 123
55142: PUSH
55143: LD_VAR 0 2
55147: ARRAY
55148: PUSH
55149: LD_INT 1
55151: ARRAY
55152: PUSH
55153: LD_INT 1
55155: ARRAY
55156: PUSH
55157: LD_EXP 123
55161: PUSH
55162: LD_VAR 0 2
55166: ARRAY
55167: PUSH
55168: LD_INT 1
55170: ARRAY
55171: PUSH
55172: LD_INT 2
55174: ARRAY
55175: PUSH
55176: LD_EXP 123
55180: PUSH
55181: LD_VAR 0 2
55185: ARRAY
55186: PUSH
55187: LD_INT 1
55189: ARRAY
55190: PUSH
55191: LD_INT 3
55193: ARRAY
55194: PUSH
55195: LD_EXP 123
55199: PUSH
55200: LD_VAR 0 2
55204: ARRAY
55205: PUSH
55206: LD_INT 1
55208: ARRAY
55209: PUSH
55210: LD_INT 4
55212: ARRAY
55213: PUSH
55214: EMPTY
55215: LIST
55216: LIST
55217: LIST
55218: LIST
55219: PPUSH
55220: CALL 81975 0 2
55224: AND
55225: IFFALSE 55363
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
55227: LD_VAR 0 3
55231: PPUSH
55232: LD_EXP 123
55236: PUSH
55237: LD_VAR 0 2
55241: ARRAY
55242: PUSH
55243: LD_INT 1
55245: ARRAY
55246: PUSH
55247: LD_INT 1
55249: ARRAY
55250: PPUSH
55251: LD_EXP 123
55255: PUSH
55256: LD_VAR 0 2
55260: ARRAY
55261: PUSH
55262: LD_INT 1
55264: ARRAY
55265: PUSH
55266: LD_INT 2
55268: ARRAY
55269: PPUSH
55270: LD_EXP 123
55274: PUSH
55275: LD_VAR 0 2
55279: ARRAY
55280: PUSH
55281: LD_INT 1
55283: ARRAY
55284: PUSH
55285: LD_INT 3
55287: ARRAY
55288: PPUSH
55289: LD_EXP 123
55293: PUSH
55294: LD_VAR 0 2
55298: ARRAY
55299: PUSH
55300: LD_INT 1
55302: ARRAY
55303: PUSH
55304: LD_INT 4
55306: ARRAY
55307: PPUSH
55308: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
55312: LD_ADDR_VAR 0 4
55316: PUSH
55317: LD_EXP 123
55321: PUSH
55322: LD_VAR 0 2
55326: ARRAY
55327: PPUSH
55328: LD_INT 1
55330: PPUSH
55331: CALL_OW 3
55335: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
55336: LD_ADDR_EXP 123
55340: PUSH
55341: LD_EXP 123
55345: PPUSH
55346: LD_VAR 0 2
55350: PPUSH
55351: LD_VAR 0 4
55355: PPUSH
55356: CALL_OW 1
55360: ST_TO_ADDR
// break ;
55361: GO 55365
// end ; end ;
55363: GO 55009
55365: POP
55366: POP
// end ;
55367: GO 54941
55369: POP
55370: POP
// end ;
55371: LD_VAR 0 1
55375: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
55376: LD_INT 0
55378: PPUSH
55379: PPUSH
55380: PPUSH
// if not mc_bases then
55381: LD_EXP 102
55385: NOT
55386: IFFALSE 55390
// exit ;
55388: GO 55479
// for i = 1 to mc_bases do
55390: LD_ADDR_VAR 0 2
55394: PUSH
55395: DOUBLE
55396: LD_INT 1
55398: DEC
55399: ST_TO_ADDR
55400: LD_EXP 102
55404: PUSH
55405: FOR_TO
55406: IFFALSE 55477
// begin if mc_attack [ i ] then
55408: LD_EXP 122
55412: PUSH
55413: LD_VAR 0 2
55417: ARRAY
55418: IFFALSE 55475
// begin tmp := mc_attack [ i ] [ 1 ] ;
55420: LD_ADDR_VAR 0 3
55424: PUSH
55425: LD_EXP 122
55429: PUSH
55430: LD_VAR 0 2
55434: ARRAY
55435: PUSH
55436: LD_INT 1
55438: ARRAY
55439: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
55440: LD_ADDR_EXP 122
55444: PUSH
55445: LD_EXP 122
55449: PPUSH
55450: LD_VAR 0 2
55454: PPUSH
55455: EMPTY
55456: PPUSH
55457: CALL_OW 1
55461: ST_TO_ADDR
// Attack ( tmp ) ;
55462: LD_VAR 0 3
55466: PPUSH
55467: CALL 134107 0 1
// exit ;
55471: POP
55472: POP
55473: GO 55479
// end ; end ;
55475: GO 55405
55477: POP
55478: POP
// end ;
55479: LD_VAR 0 1
55483: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
55484: LD_INT 0
55486: PPUSH
55487: PPUSH
55488: PPUSH
55489: PPUSH
55490: PPUSH
55491: PPUSH
55492: PPUSH
// if not mc_bases then
55493: LD_EXP 102
55497: NOT
55498: IFFALSE 55502
// exit ;
55500: GO 56359
// for i = 1 to mc_bases do
55502: LD_ADDR_VAR 0 2
55506: PUSH
55507: DOUBLE
55508: LD_INT 1
55510: DEC
55511: ST_TO_ADDR
55512: LD_EXP 102
55516: PUSH
55517: FOR_TO
55518: IFFALSE 56357
// begin if not mc_bases [ i ] then
55520: LD_EXP 102
55524: PUSH
55525: LD_VAR 0 2
55529: ARRAY
55530: NOT
55531: IFFALSE 55535
// continue ;
55533: GO 55517
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
55535: LD_ADDR_VAR 0 7
55539: PUSH
55540: LD_EXP 102
55544: PUSH
55545: LD_VAR 0 2
55549: ARRAY
55550: PUSH
55551: LD_INT 1
55553: ARRAY
55554: PPUSH
55555: CALL 72058 0 1
55559: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
55560: LD_ADDR_EXP 125
55564: PUSH
55565: LD_EXP 125
55569: PPUSH
55570: LD_VAR 0 2
55574: PPUSH
55575: LD_EXP 102
55579: PUSH
55580: LD_VAR 0 2
55584: ARRAY
55585: PUSH
55586: LD_INT 1
55588: ARRAY
55589: PPUSH
55590: CALL_OW 255
55594: PPUSH
55595: LD_EXP 127
55599: PUSH
55600: LD_VAR 0 2
55604: ARRAY
55605: PPUSH
55606: CALL 72023 0 2
55610: PPUSH
55611: CALL_OW 1
55615: ST_TO_ADDR
// if not mc_scan [ i ] then
55616: LD_EXP 125
55620: PUSH
55621: LD_VAR 0 2
55625: ARRAY
55626: NOT
55627: IFFALSE 55805
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
55629: LD_ADDR_EXP 145
55633: PUSH
55634: LD_EXP 145
55638: PPUSH
55639: LD_VAR 0 2
55643: PPUSH
55644: LD_INT 0
55646: PPUSH
55647: CALL_OW 1
55651: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55652: LD_ADDR_VAR 0 4
55656: PUSH
55657: LD_EXP 102
55661: PUSH
55662: LD_VAR 0 2
55666: ARRAY
55667: PPUSH
55668: LD_INT 2
55670: PUSH
55671: LD_INT 25
55673: PUSH
55674: LD_INT 5
55676: PUSH
55677: EMPTY
55678: LIST
55679: LIST
55680: PUSH
55681: LD_INT 25
55683: PUSH
55684: LD_INT 8
55686: PUSH
55687: EMPTY
55688: LIST
55689: LIST
55690: PUSH
55691: LD_INT 25
55693: PUSH
55694: LD_INT 9
55696: PUSH
55697: EMPTY
55698: LIST
55699: LIST
55700: PUSH
55701: EMPTY
55702: LIST
55703: LIST
55704: LIST
55705: LIST
55706: PPUSH
55707: CALL_OW 72
55711: ST_TO_ADDR
// if not tmp then
55712: LD_VAR 0 4
55716: NOT
55717: IFFALSE 55721
// continue ;
55719: GO 55517
// for j in tmp do
55721: LD_ADDR_VAR 0 3
55725: PUSH
55726: LD_VAR 0 4
55730: PUSH
55731: FOR_IN
55732: IFFALSE 55803
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
55734: LD_VAR 0 3
55738: PPUSH
55739: CALL_OW 310
55743: PPUSH
55744: CALL_OW 266
55748: PUSH
55749: LD_INT 5
55751: EQUAL
55752: PUSH
55753: LD_VAR 0 3
55757: PPUSH
55758: CALL_OW 257
55762: PUSH
55763: LD_INT 1
55765: EQUAL
55766: AND
55767: PUSH
55768: LD_VAR 0 3
55772: PPUSH
55773: CALL_OW 459
55777: NOT
55778: AND
55779: PUSH
55780: LD_VAR 0 7
55784: AND
55785: IFFALSE 55801
// ComChangeProfession ( j , class ) ;
55787: LD_VAR 0 3
55791: PPUSH
55792: LD_VAR 0 7
55796: PPUSH
55797: CALL_OW 123
55801: GO 55731
55803: POP
55804: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
55805: LD_EXP 125
55809: PUSH
55810: LD_VAR 0 2
55814: ARRAY
55815: PUSH
55816: LD_EXP 145
55820: PUSH
55821: LD_VAR 0 2
55825: ARRAY
55826: NOT
55827: AND
55828: PUSH
55829: LD_EXP 124
55833: PUSH
55834: LD_VAR 0 2
55838: ARRAY
55839: NOT
55840: AND
55841: PUSH
55842: LD_EXP 102
55846: PUSH
55847: LD_VAR 0 2
55851: ARRAY
55852: PPUSH
55853: LD_INT 50
55855: PUSH
55856: EMPTY
55857: LIST
55858: PUSH
55859: LD_INT 2
55861: PUSH
55862: LD_INT 30
55864: PUSH
55865: LD_INT 32
55867: PUSH
55868: EMPTY
55869: LIST
55870: LIST
55871: PUSH
55872: LD_INT 30
55874: PUSH
55875: LD_INT 33
55877: PUSH
55878: EMPTY
55879: LIST
55880: LIST
55881: PUSH
55882: LD_INT 30
55884: PUSH
55885: LD_INT 4
55887: PUSH
55888: EMPTY
55889: LIST
55890: LIST
55891: PUSH
55892: LD_INT 30
55894: PUSH
55895: LD_INT 5
55897: PUSH
55898: EMPTY
55899: LIST
55900: LIST
55901: PUSH
55902: EMPTY
55903: LIST
55904: LIST
55905: LIST
55906: LIST
55907: LIST
55908: PUSH
55909: EMPTY
55910: LIST
55911: LIST
55912: PPUSH
55913: CALL_OW 72
55917: PUSH
55918: LD_INT 4
55920: LESS
55921: PUSH
55922: LD_EXP 102
55926: PUSH
55927: LD_VAR 0 2
55931: ARRAY
55932: PPUSH
55933: LD_INT 3
55935: PUSH
55936: LD_INT 24
55938: PUSH
55939: LD_INT 1000
55941: PUSH
55942: EMPTY
55943: LIST
55944: LIST
55945: PUSH
55946: EMPTY
55947: LIST
55948: LIST
55949: PUSH
55950: LD_INT 2
55952: PUSH
55953: LD_INT 30
55955: PUSH
55956: LD_INT 0
55958: PUSH
55959: EMPTY
55960: LIST
55961: LIST
55962: PUSH
55963: LD_INT 30
55965: PUSH
55966: LD_INT 1
55968: PUSH
55969: EMPTY
55970: LIST
55971: LIST
55972: PUSH
55973: EMPTY
55974: LIST
55975: LIST
55976: LIST
55977: PUSH
55978: EMPTY
55979: LIST
55980: LIST
55981: PPUSH
55982: CALL_OW 72
55986: OR
55987: AND
55988: IFFALSE 56239
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
55990: LD_ADDR_EXP 145
55994: PUSH
55995: LD_EXP 145
55999: PPUSH
56000: LD_VAR 0 2
56004: PPUSH
56005: LD_INT 1
56007: PPUSH
56008: CALL_OW 1
56012: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56013: LD_ADDR_VAR 0 4
56017: PUSH
56018: LD_EXP 102
56022: PUSH
56023: LD_VAR 0 2
56027: ARRAY
56028: PPUSH
56029: LD_INT 2
56031: PUSH
56032: LD_INT 25
56034: PUSH
56035: LD_INT 1
56037: PUSH
56038: EMPTY
56039: LIST
56040: LIST
56041: PUSH
56042: LD_INT 25
56044: PUSH
56045: LD_INT 5
56047: PUSH
56048: EMPTY
56049: LIST
56050: LIST
56051: PUSH
56052: LD_INT 25
56054: PUSH
56055: LD_INT 8
56057: PUSH
56058: EMPTY
56059: LIST
56060: LIST
56061: PUSH
56062: LD_INT 25
56064: PUSH
56065: LD_INT 9
56067: PUSH
56068: EMPTY
56069: LIST
56070: LIST
56071: PUSH
56072: EMPTY
56073: LIST
56074: LIST
56075: LIST
56076: LIST
56077: LIST
56078: PPUSH
56079: CALL_OW 72
56083: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
56084: LD_ADDR_VAR 0 4
56088: PUSH
56089: LD_VAR 0 4
56093: PUSH
56094: LD_VAR 0 4
56098: PPUSH
56099: LD_INT 18
56101: PPUSH
56102: CALL 105532 0 2
56106: DIFF
56107: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
56108: LD_VAR 0 4
56112: NOT
56113: PUSH
56114: LD_EXP 102
56118: PUSH
56119: LD_VAR 0 2
56123: ARRAY
56124: PPUSH
56125: LD_INT 2
56127: PUSH
56128: LD_INT 30
56130: PUSH
56131: LD_INT 4
56133: PUSH
56134: EMPTY
56135: LIST
56136: LIST
56137: PUSH
56138: LD_INT 30
56140: PUSH
56141: LD_INT 5
56143: PUSH
56144: EMPTY
56145: LIST
56146: LIST
56147: PUSH
56148: EMPTY
56149: LIST
56150: LIST
56151: LIST
56152: PPUSH
56153: CALL_OW 72
56157: NOT
56158: AND
56159: IFFALSE 56221
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
56161: LD_ADDR_VAR 0 4
56165: PUSH
56166: LD_EXP 102
56170: PUSH
56171: LD_VAR 0 2
56175: ARRAY
56176: PPUSH
56177: LD_INT 2
56179: PUSH
56180: LD_INT 25
56182: PUSH
56183: LD_INT 2
56185: PUSH
56186: EMPTY
56187: LIST
56188: LIST
56189: PUSH
56190: LD_INT 25
56192: PUSH
56193: LD_INT 3
56195: PUSH
56196: EMPTY
56197: LIST
56198: LIST
56199: PUSH
56200: LD_INT 25
56202: PUSH
56203: LD_INT 4
56205: PUSH
56206: EMPTY
56207: LIST
56208: LIST
56209: PUSH
56210: EMPTY
56211: LIST
56212: LIST
56213: LIST
56214: LIST
56215: PPUSH
56216: CALL_OW 72
56220: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
56221: LD_VAR 0 2
56225: PPUSH
56226: LD_VAR 0 4
56230: PPUSH
56231: CALL 138816 0 2
// exit ;
56235: POP
56236: POP
56237: GO 56359
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
56239: LD_EXP 125
56243: PUSH
56244: LD_VAR 0 2
56248: ARRAY
56249: PUSH
56250: LD_EXP 145
56254: PUSH
56255: LD_VAR 0 2
56259: ARRAY
56260: NOT
56261: AND
56262: PUSH
56263: LD_EXP 124
56267: PUSH
56268: LD_VAR 0 2
56272: ARRAY
56273: AND
56274: IFFALSE 56355
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
56276: LD_ADDR_EXP 145
56280: PUSH
56281: LD_EXP 145
56285: PPUSH
56286: LD_VAR 0 2
56290: PPUSH
56291: LD_INT 1
56293: PPUSH
56294: CALL_OW 1
56298: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
56299: LD_ADDR_VAR 0 4
56303: PUSH
56304: LD_EXP 124
56308: PUSH
56309: LD_VAR 0 2
56313: ARRAY
56314: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
56315: LD_ADDR_EXP 124
56319: PUSH
56320: LD_EXP 124
56324: PPUSH
56325: LD_VAR 0 2
56329: PPUSH
56330: EMPTY
56331: PPUSH
56332: CALL_OW 1
56336: ST_TO_ADDR
// Defend ( i , tmp ) ;
56337: LD_VAR 0 2
56341: PPUSH
56342: LD_VAR 0 4
56346: PPUSH
56347: CALL 139412 0 2
// exit ;
56351: POP
56352: POP
56353: GO 56359
// end ; end ;
56355: GO 55517
56357: POP
56358: POP
// end ;
56359: LD_VAR 0 1
56363: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
56364: LD_INT 0
56366: PPUSH
56367: PPUSH
56368: PPUSH
56369: PPUSH
56370: PPUSH
56371: PPUSH
56372: PPUSH
56373: PPUSH
56374: PPUSH
56375: PPUSH
56376: PPUSH
// if not mc_bases then
56377: LD_EXP 102
56381: NOT
56382: IFFALSE 56386
// exit ;
56384: GO 57473
// for i = 1 to mc_bases do
56386: LD_ADDR_VAR 0 2
56390: PUSH
56391: DOUBLE
56392: LD_INT 1
56394: DEC
56395: ST_TO_ADDR
56396: LD_EXP 102
56400: PUSH
56401: FOR_TO
56402: IFFALSE 57471
// begin tmp := mc_lab [ i ] ;
56404: LD_ADDR_VAR 0 6
56408: PUSH
56409: LD_EXP 135
56413: PUSH
56414: LD_VAR 0 2
56418: ARRAY
56419: ST_TO_ADDR
// if not tmp then
56420: LD_VAR 0 6
56424: NOT
56425: IFFALSE 56429
// continue ;
56427: GO 56401
// idle_lab := 0 ;
56429: LD_ADDR_VAR 0 11
56433: PUSH
56434: LD_INT 0
56436: ST_TO_ADDR
// for j in tmp do
56437: LD_ADDR_VAR 0 3
56441: PUSH
56442: LD_VAR 0 6
56446: PUSH
56447: FOR_IN
56448: IFFALSE 57467
// begin researching := false ;
56450: LD_ADDR_VAR 0 10
56454: PUSH
56455: LD_INT 0
56457: ST_TO_ADDR
// side := GetSide ( j ) ;
56458: LD_ADDR_VAR 0 4
56462: PUSH
56463: LD_VAR 0 3
56467: PPUSH
56468: CALL_OW 255
56472: ST_TO_ADDR
// if not mc_tech [ side ] then
56473: LD_EXP 129
56477: PUSH
56478: LD_VAR 0 4
56482: ARRAY
56483: NOT
56484: IFFALSE 56488
// continue ;
56486: GO 56447
// if BuildingStatus ( j ) = bs_idle then
56488: LD_VAR 0 3
56492: PPUSH
56493: CALL_OW 461
56497: PUSH
56498: LD_INT 2
56500: EQUAL
56501: IFFALSE 56689
// begin if idle_lab and UnitsInside ( j ) < 6 then
56503: LD_VAR 0 11
56507: PUSH
56508: LD_VAR 0 3
56512: PPUSH
56513: CALL_OW 313
56517: PUSH
56518: LD_INT 6
56520: LESS
56521: AND
56522: IFFALSE 56593
// begin tmp2 := UnitsInside ( idle_lab ) ;
56524: LD_ADDR_VAR 0 9
56528: PUSH
56529: LD_VAR 0 11
56533: PPUSH
56534: CALL_OW 313
56538: ST_TO_ADDR
// if tmp2 then
56539: LD_VAR 0 9
56543: IFFALSE 56585
// for x in tmp2 do
56545: LD_ADDR_VAR 0 7
56549: PUSH
56550: LD_VAR 0 9
56554: PUSH
56555: FOR_IN
56556: IFFALSE 56583
// begin ComExitBuilding ( x ) ;
56558: LD_VAR 0 7
56562: PPUSH
56563: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
56567: LD_VAR 0 7
56571: PPUSH
56572: LD_VAR 0 3
56576: PPUSH
56577: CALL_OW 180
// end ;
56581: GO 56555
56583: POP
56584: POP
// idle_lab := 0 ;
56585: LD_ADDR_VAR 0 11
56589: PUSH
56590: LD_INT 0
56592: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
56593: LD_ADDR_VAR 0 5
56597: PUSH
56598: LD_EXP 129
56602: PUSH
56603: LD_VAR 0 4
56607: ARRAY
56608: PUSH
56609: FOR_IN
56610: IFFALSE 56670
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
56612: LD_VAR 0 3
56616: PPUSH
56617: LD_VAR 0 5
56621: PPUSH
56622: CALL_OW 430
56626: PUSH
56627: LD_VAR 0 4
56631: PPUSH
56632: LD_VAR 0 5
56636: PPUSH
56637: CALL 71128 0 2
56641: AND
56642: IFFALSE 56668
// begin researching := true ;
56644: LD_ADDR_VAR 0 10
56648: PUSH
56649: LD_INT 1
56651: ST_TO_ADDR
// ComResearch ( j , t ) ;
56652: LD_VAR 0 3
56656: PPUSH
56657: LD_VAR 0 5
56661: PPUSH
56662: CALL_OW 124
// break ;
56666: GO 56670
// end ;
56668: GO 56609
56670: POP
56671: POP
// if not researching then
56672: LD_VAR 0 10
56676: NOT
56677: IFFALSE 56689
// idle_lab := j ;
56679: LD_ADDR_VAR 0 11
56683: PUSH
56684: LD_VAR 0 3
56688: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
56689: LD_VAR 0 3
56693: PPUSH
56694: CALL_OW 461
56698: PUSH
56699: LD_INT 10
56701: EQUAL
56702: IFFALSE 57290
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
56704: LD_EXP 131
56708: PUSH
56709: LD_VAR 0 2
56713: ARRAY
56714: NOT
56715: PUSH
56716: LD_EXP 132
56720: PUSH
56721: LD_VAR 0 2
56725: ARRAY
56726: NOT
56727: AND
56728: PUSH
56729: LD_EXP 129
56733: PUSH
56734: LD_VAR 0 4
56738: ARRAY
56739: PUSH
56740: LD_INT 1
56742: GREATER
56743: AND
56744: IFFALSE 56875
// begin ComCancel ( j ) ;
56746: LD_VAR 0 3
56750: PPUSH
56751: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
56755: LD_ADDR_EXP 129
56759: PUSH
56760: LD_EXP 129
56764: PPUSH
56765: LD_VAR 0 4
56769: PPUSH
56770: LD_EXP 129
56774: PUSH
56775: LD_VAR 0 4
56779: ARRAY
56780: PPUSH
56781: LD_EXP 129
56785: PUSH
56786: LD_VAR 0 4
56790: ARRAY
56791: PUSH
56792: LD_INT 1
56794: MINUS
56795: PPUSH
56796: LD_EXP 129
56800: PUSH
56801: LD_VAR 0 4
56805: ARRAY
56806: PPUSH
56807: LD_INT 0
56809: PPUSH
56810: CALL 74652 0 4
56814: PPUSH
56815: CALL_OW 1
56819: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
56820: LD_ADDR_EXP 129
56824: PUSH
56825: LD_EXP 129
56829: PPUSH
56830: LD_VAR 0 4
56834: PPUSH
56835: LD_EXP 129
56839: PUSH
56840: LD_VAR 0 4
56844: ARRAY
56845: PPUSH
56846: LD_EXP 129
56850: PUSH
56851: LD_VAR 0 4
56855: ARRAY
56856: PPUSH
56857: LD_INT 1
56859: PPUSH
56860: LD_INT 0
56862: PPUSH
56863: CALL 74652 0 4
56867: PPUSH
56868: CALL_OW 1
56872: ST_TO_ADDR
// continue ;
56873: GO 56447
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
56875: LD_EXP 131
56879: PUSH
56880: LD_VAR 0 2
56884: ARRAY
56885: PUSH
56886: LD_EXP 132
56890: PUSH
56891: LD_VAR 0 2
56895: ARRAY
56896: NOT
56897: AND
56898: IFFALSE 57025
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
56900: LD_ADDR_EXP 132
56904: PUSH
56905: LD_EXP 132
56909: PPUSH
56910: LD_VAR 0 2
56914: PUSH
56915: LD_EXP 132
56919: PUSH
56920: LD_VAR 0 2
56924: ARRAY
56925: PUSH
56926: LD_INT 1
56928: PLUS
56929: PUSH
56930: EMPTY
56931: LIST
56932: LIST
56933: PPUSH
56934: LD_EXP 131
56938: PUSH
56939: LD_VAR 0 2
56943: ARRAY
56944: PUSH
56945: LD_INT 1
56947: ARRAY
56948: PPUSH
56949: CALL 75234 0 3
56953: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
56954: LD_EXP 131
56958: PUSH
56959: LD_VAR 0 2
56963: ARRAY
56964: PUSH
56965: LD_INT 1
56967: ARRAY
56968: PPUSH
56969: LD_INT 112
56971: PPUSH
56972: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
56976: LD_ADDR_VAR 0 9
56980: PUSH
56981: LD_EXP 131
56985: PUSH
56986: LD_VAR 0 2
56990: ARRAY
56991: PPUSH
56992: LD_INT 1
56994: PPUSH
56995: CALL_OW 3
56999: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
57000: LD_ADDR_EXP 131
57004: PUSH
57005: LD_EXP 131
57009: PPUSH
57010: LD_VAR 0 2
57014: PPUSH
57015: LD_VAR 0 9
57019: PPUSH
57020: CALL_OW 1
57024: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
57025: LD_EXP 131
57029: PUSH
57030: LD_VAR 0 2
57034: ARRAY
57035: PUSH
57036: LD_EXP 132
57040: PUSH
57041: LD_VAR 0 2
57045: ARRAY
57046: AND
57047: PUSH
57048: LD_EXP 132
57052: PUSH
57053: LD_VAR 0 2
57057: ARRAY
57058: PUSH
57059: LD_INT 1
57061: ARRAY
57062: PPUSH
57063: CALL_OW 310
57067: NOT
57068: AND
57069: PUSH
57070: LD_VAR 0 3
57074: PPUSH
57075: CALL_OW 313
57079: PUSH
57080: LD_INT 6
57082: EQUAL
57083: AND
57084: IFFALSE 57140
// begin tmp2 := UnitsInside ( j ) ;
57086: LD_ADDR_VAR 0 9
57090: PUSH
57091: LD_VAR 0 3
57095: PPUSH
57096: CALL_OW 313
57100: ST_TO_ADDR
// if tmp2 = 6 then
57101: LD_VAR 0 9
57105: PUSH
57106: LD_INT 6
57108: EQUAL
57109: IFFALSE 57140
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
57111: LD_VAR 0 9
57115: PUSH
57116: LD_INT 1
57118: ARRAY
57119: PPUSH
57120: LD_INT 112
57122: PPUSH
57123: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
57127: LD_VAR 0 9
57131: PUSH
57132: LD_INT 1
57134: ARRAY
57135: PPUSH
57136: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
57140: LD_EXP 132
57144: PUSH
57145: LD_VAR 0 2
57149: ARRAY
57150: PUSH
57151: LD_EXP 132
57155: PUSH
57156: LD_VAR 0 2
57160: ARRAY
57161: PUSH
57162: LD_INT 1
57164: ARRAY
57165: PPUSH
57166: CALL_OW 314
57170: NOT
57171: AND
57172: PUSH
57173: LD_EXP 132
57177: PUSH
57178: LD_VAR 0 2
57182: ARRAY
57183: PUSH
57184: LD_INT 1
57186: ARRAY
57187: PPUSH
57188: CALL_OW 310
57192: NOT
57193: AND
57194: IFFALSE 57220
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
57196: LD_EXP 132
57200: PUSH
57201: LD_VAR 0 2
57205: ARRAY
57206: PUSH
57207: LD_INT 1
57209: ARRAY
57210: PPUSH
57211: LD_VAR 0 3
57215: PPUSH
57216: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
57220: LD_EXP 132
57224: PUSH
57225: LD_VAR 0 2
57229: ARRAY
57230: PUSH
57231: LD_INT 1
57233: ARRAY
57234: PPUSH
57235: CALL_OW 310
57239: PUSH
57240: LD_EXP 132
57244: PUSH
57245: LD_VAR 0 2
57249: ARRAY
57250: PUSH
57251: LD_INT 1
57253: ARRAY
57254: PPUSH
57255: CALL_OW 310
57259: PPUSH
57260: CALL_OW 461
57264: PUSH
57265: LD_INT 3
57267: NONEQUAL
57268: AND
57269: IFFALSE 57290
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
57271: LD_EXP 132
57275: PUSH
57276: LD_VAR 0 2
57280: ARRAY
57281: PUSH
57282: LD_INT 1
57284: ARRAY
57285: PPUSH
57286: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
57290: LD_VAR 0 3
57294: PPUSH
57295: CALL_OW 461
57299: PUSH
57300: LD_INT 6
57302: EQUAL
57303: PUSH
57304: LD_VAR 0 6
57308: PUSH
57309: LD_INT 1
57311: GREATER
57312: AND
57313: IFFALSE 57465
// begin sci := [ ] ;
57315: LD_ADDR_VAR 0 8
57319: PUSH
57320: EMPTY
57321: ST_TO_ADDR
// for x in ( tmp diff j ) do
57322: LD_ADDR_VAR 0 7
57326: PUSH
57327: LD_VAR 0 6
57331: PUSH
57332: LD_VAR 0 3
57336: DIFF
57337: PUSH
57338: FOR_IN
57339: IFFALSE 57391
// begin if sci = 6 then
57341: LD_VAR 0 8
57345: PUSH
57346: LD_INT 6
57348: EQUAL
57349: IFFALSE 57353
// break ;
57351: GO 57391
// if BuildingStatus ( x ) = bs_idle then
57353: LD_VAR 0 7
57357: PPUSH
57358: CALL_OW 461
57362: PUSH
57363: LD_INT 2
57365: EQUAL
57366: IFFALSE 57389
// sci := sci ^ UnitsInside ( x ) ;
57368: LD_ADDR_VAR 0 8
57372: PUSH
57373: LD_VAR 0 8
57377: PUSH
57378: LD_VAR 0 7
57382: PPUSH
57383: CALL_OW 313
57387: ADD
57388: ST_TO_ADDR
// end ;
57389: GO 57338
57391: POP
57392: POP
// if not sci then
57393: LD_VAR 0 8
57397: NOT
57398: IFFALSE 57402
// continue ;
57400: GO 56447
// for x in sci do
57402: LD_ADDR_VAR 0 7
57406: PUSH
57407: LD_VAR 0 8
57411: PUSH
57412: FOR_IN
57413: IFFALSE 57463
// if IsInUnit ( x ) and not HasTask ( x ) then
57415: LD_VAR 0 7
57419: PPUSH
57420: CALL_OW 310
57424: PUSH
57425: LD_VAR 0 7
57429: PPUSH
57430: CALL_OW 314
57434: NOT
57435: AND
57436: IFFALSE 57461
// begin ComExitBuilding ( x ) ;
57438: LD_VAR 0 7
57442: PPUSH
57443: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
57447: LD_VAR 0 7
57451: PPUSH
57452: LD_VAR 0 3
57456: PPUSH
57457: CALL_OW 180
// end ;
57461: GO 57412
57463: POP
57464: POP
// end ; end ;
57465: GO 56447
57467: POP
57468: POP
// end ;
57469: GO 56401
57471: POP
57472: POP
// end ;
57473: LD_VAR 0 1
57477: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
57478: LD_INT 0
57480: PPUSH
57481: PPUSH
// if not mc_bases then
57482: LD_EXP 102
57486: NOT
57487: IFFALSE 57491
// exit ;
57489: GO 57572
// for i = 1 to mc_bases do
57491: LD_ADDR_VAR 0 2
57495: PUSH
57496: DOUBLE
57497: LD_INT 1
57499: DEC
57500: ST_TO_ADDR
57501: LD_EXP 102
57505: PUSH
57506: FOR_TO
57507: IFFALSE 57570
// if mc_mines [ i ] and mc_miners [ i ] then
57509: LD_EXP 115
57513: PUSH
57514: LD_VAR 0 2
57518: ARRAY
57519: PUSH
57520: LD_EXP 116
57524: PUSH
57525: LD_VAR 0 2
57529: ARRAY
57530: AND
57531: IFFALSE 57568
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
57533: LD_EXP 116
57537: PUSH
57538: LD_VAR 0 2
57542: ARRAY
57543: PUSH
57544: LD_INT 1
57546: ARRAY
57547: PPUSH
57548: CALL_OW 255
57552: PPUSH
57553: LD_EXP 115
57557: PUSH
57558: LD_VAR 0 2
57562: ARRAY
57563: PPUSH
57564: CALL 72211 0 2
57568: GO 57506
57570: POP
57571: POP
// end ;
57572: LD_VAR 0 1
57576: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
57577: LD_INT 0
57579: PPUSH
57580: PPUSH
57581: PPUSH
57582: PPUSH
57583: PPUSH
57584: PPUSH
57585: PPUSH
57586: PPUSH
// if not mc_bases or not mc_parking then
57587: LD_EXP 102
57591: NOT
57592: PUSH
57593: LD_EXP 126
57597: NOT
57598: OR
57599: IFFALSE 57603
// exit ;
57601: GO 58341
// for i = 1 to mc_bases do
57603: LD_ADDR_VAR 0 2
57607: PUSH
57608: DOUBLE
57609: LD_INT 1
57611: DEC
57612: ST_TO_ADDR
57613: LD_EXP 102
57617: PUSH
57618: FOR_TO
57619: IFFALSE 58339
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
57621: LD_EXP 102
57625: PUSH
57626: LD_VAR 0 2
57630: ARRAY
57631: NOT
57632: PUSH
57633: LD_EXP 126
57637: PUSH
57638: LD_VAR 0 2
57642: ARRAY
57643: NOT
57644: OR
57645: IFFALSE 57649
// continue ;
57647: GO 57618
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
57649: LD_ADDR_VAR 0 5
57653: PUSH
57654: LD_EXP 102
57658: PUSH
57659: LD_VAR 0 2
57663: ARRAY
57664: PUSH
57665: LD_INT 1
57667: ARRAY
57668: PPUSH
57669: CALL_OW 255
57673: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
57674: LD_ADDR_VAR 0 6
57678: PUSH
57679: LD_EXP 102
57683: PUSH
57684: LD_VAR 0 2
57688: ARRAY
57689: PPUSH
57690: LD_INT 30
57692: PUSH
57693: LD_INT 3
57695: PUSH
57696: EMPTY
57697: LIST
57698: LIST
57699: PPUSH
57700: CALL_OW 72
57704: ST_TO_ADDR
// if not fac then
57705: LD_VAR 0 6
57709: NOT
57710: IFFALSE 57761
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57712: LD_ADDR_VAR 0 6
57716: PUSH
57717: LD_EXP 102
57721: PUSH
57722: LD_VAR 0 2
57726: ARRAY
57727: PPUSH
57728: LD_INT 2
57730: PUSH
57731: LD_INT 30
57733: PUSH
57734: LD_INT 0
57736: PUSH
57737: EMPTY
57738: LIST
57739: LIST
57740: PUSH
57741: LD_INT 30
57743: PUSH
57744: LD_INT 1
57746: PUSH
57747: EMPTY
57748: LIST
57749: LIST
57750: PUSH
57751: EMPTY
57752: LIST
57753: LIST
57754: LIST
57755: PPUSH
57756: CALL_OW 72
57760: ST_TO_ADDR
// if not fac then
57761: LD_VAR 0 6
57765: NOT
57766: IFFALSE 57770
// continue ;
57768: GO 57618
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
57770: LD_ADDR_VAR 0 7
57774: PUSH
57775: LD_EXP 126
57779: PUSH
57780: LD_VAR 0 2
57784: ARRAY
57785: PPUSH
57786: LD_INT 22
57788: PUSH
57789: LD_VAR 0 5
57793: PUSH
57794: EMPTY
57795: LIST
57796: LIST
57797: PUSH
57798: LD_INT 21
57800: PUSH
57801: LD_INT 2
57803: PUSH
57804: EMPTY
57805: LIST
57806: LIST
57807: PUSH
57808: LD_INT 3
57810: PUSH
57811: LD_INT 60
57813: PUSH
57814: EMPTY
57815: LIST
57816: PUSH
57817: EMPTY
57818: LIST
57819: LIST
57820: PUSH
57821: LD_INT 3
57823: PUSH
57824: LD_INT 24
57826: PUSH
57827: LD_INT 1000
57829: PUSH
57830: EMPTY
57831: LIST
57832: LIST
57833: PUSH
57834: EMPTY
57835: LIST
57836: LIST
57837: PUSH
57838: EMPTY
57839: LIST
57840: LIST
57841: LIST
57842: LIST
57843: PPUSH
57844: CALL_OW 70
57848: ST_TO_ADDR
// for j in fac do
57849: LD_ADDR_VAR 0 3
57853: PUSH
57854: LD_VAR 0 6
57858: PUSH
57859: FOR_IN
57860: IFFALSE 57955
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
57862: LD_ADDR_VAR 0 7
57866: PUSH
57867: LD_VAR 0 7
57871: PUSH
57872: LD_INT 22
57874: PUSH
57875: LD_VAR 0 5
57879: PUSH
57880: EMPTY
57881: LIST
57882: LIST
57883: PUSH
57884: LD_INT 91
57886: PUSH
57887: LD_VAR 0 3
57891: PUSH
57892: LD_INT 15
57894: PUSH
57895: EMPTY
57896: LIST
57897: LIST
57898: LIST
57899: PUSH
57900: LD_INT 21
57902: PUSH
57903: LD_INT 2
57905: PUSH
57906: EMPTY
57907: LIST
57908: LIST
57909: PUSH
57910: LD_INT 3
57912: PUSH
57913: LD_INT 60
57915: PUSH
57916: EMPTY
57917: LIST
57918: PUSH
57919: EMPTY
57920: LIST
57921: LIST
57922: PUSH
57923: LD_INT 3
57925: PUSH
57926: LD_INT 24
57928: PUSH
57929: LD_INT 1000
57931: PUSH
57932: EMPTY
57933: LIST
57934: LIST
57935: PUSH
57936: EMPTY
57937: LIST
57938: LIST
57939: PUSH
57940: EMPTY
57941: LIST
57942: LIST
57943: LIST
57944: LIST
57945: LIST
57946: PPUSH
57947: CALL_OW 69
57951: UNION
57952: ST_TO_ADDR
57953: GO 57859
57955: POP
57956: POP
// if not vehs then
57957: LD_VAR 0 7
57961: NOT
57962: IFFALSE 57988
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57964: LD_ADDR_EXP 114
57968: PUSH
57969: LD_EXP 114
57973: PPUSH
57974: LD_VAR 0 2
57978: PPUSH
57979: EMPTY
57980: PPUSH
57981: CALL_OW 1
57985: ST_TO_ADDR
// continue ;
57986: GO 57618
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
57988: LD_ADDR_VAR 0 8
57992: PUSH
57993: LD_EXP 102
57997: PUSH
57998: LD_VAR 0 2
58002: ARRAY
58003: PPUSH
58004: LD_INT 30
58006: PUSH
58007: LD_INT 3
58009: PUSH
58010: EMPTY
58011: LIST
58012: LIST
58013: PPUSH
58014: CALL_OW 72
58018: ST_TO_ADDR
// if tmp then
58019: LD_VAR 0 8
58023: IFFALSE 58126
// begin for j in tmp do
58025: LD_ADDR_VAR 0 3
58029: PUSH
58030: LD_VAR 0 8
58034: PUSH
58035: FOR_IN
58036: IFFALSE 58124
// for k in UnitsInside ( j ) do
58038: LD_ADDR_VAR 0 4
58042: PUSH
58043: LD_VAR 0 3
58047: PPUSH
58048: CALL_OW 313
58052: PUSH
58053: FOR_IN
58054: IFFALSE 58120
// if k then
58056: LD_VAR 0 4
58060: IFFALSE 58118
// if not k in mc_repair_vehicle [ i ] then
58062: LD_VAR 0 4
58066: PUSH
58067: LD_EXP 114
58071: PUSH
58072: LD_VAR 0 2
58076: ARRAY
58077: IN
58078: NOT
58079: IFFALSE 58118
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
58081: LD_ADDR_EXP 114
58085: PUSH
58086: LD_EXP 114
58090: PPUSH
58091: LD_VAR 0 2
58095: PPUSH
58096: LD_EXP 114
58100: PUSH
58101: LD_VAR 0 2
58105: ARRAY
58106: PUSH
58107: LD_VAR 0 4
58111: UNION
58112: PPUSH
58113: CALL_OW 1
58117: ST_TO_ADDR
58118: GO 58053
58120: POP
58121: POP
58122: GO 58035
58124: POP
58125: POP
// end ; if not mc_repair_vehicle [ i ] then
58126: LD_EXP 114
58130: PUSH
58131: LD_VAR 0 2
58135: ARRAY
58136: NOT
58137: IFFALSE 58141
// continue ;
58139: GO 57618
// for j in mc_repair_vehicle [ i ] do
58141: LD_ADDR_VAR 0 3
58145: PUSH
58146: LD_EXP 114
58150: PUSH
58151: LD_VAR 0 2
58155: ARRAY
58156: PUSH
58157: FOR_IN
58158: IFFALSE 58335
// begin if GetClass ( j ) <> 3 then
58160: LD_VAR 0 3
58164: PPUSH
58165: CALL_OW 257
58169: PUSH
58170: LD_INT 3
58172: NONEQUAL
58173: IFFALSE 58214
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
58175: LD_ADDR_EXP 114
58179: PUSH
58180: LD_EXP 114
58184: PPUSH
58185: LD_VAR 0 2
58189: PPUSH
58190: LD_EXP 114
58194: PUSH
58195: LD_VAR 0 2
58199: ARRAY
58200: PUSH
58201: LD_VAR 0 3
58205: DIFF
58206: PPUSH
58207: CALL_OW 1
58211: ST_TO_ADDR
// continue ;
58212: GO 58157
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
58214: LD_VAR 0 3
58218: PPUSH
58219: CALL_OW 311
58223: NOT
58224: PUSH
58225: LD_VAR 0 3
58229: PUSH
58230: LD_EXP 105
58234: PUSH
58235: LD_VAR 0 2
58239: ARRAY
58240: PUSH
58241: LD_INT 1
58243: ARRAY
58244: IN
58245: NOT
58246: AND
58247: PUSH
58248: LD_VAR 0 3
58252: PUSH
58253: LD_EXP 105
58257: PUSH
58258: LD_VAR 0 2
58262: ARRAY
58263: PUSH
58264: LD_INT 2
58266: ARRAY
58267: IN
58268: NOT
58269: AND
58270: IFFALSE 58333
// begin if IsInUnit ( j ) then
58272: LD_VAR 0 3
58276: PPUSH
58277: CALL_OW 310
58281: IFFALSE 58294
// ComExitBuilding ( j ) else
58283: LD_VAR 0 3
58287: PPUSH
58288: CALL_OW 122
58292: GO 58333
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
58294: LD_VAR 0 3
58298: PPUSH
58299: LD_VAR 0 7
58303: PUSH
58304: LD_INT 1
58306: ARRAY
58307: PPUSH
58308: CALL 110028 0 2
58312: NOT
58313: IFFALSE 58333
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
58315: LD_VAR 0 3
58319: PPUSH
58320: LD_VAR 0 7
58324: PUSH
58325: LD_INT 1
58327: ARRAY
58328: PPUSH
58329: CALL_OW 129
// end ; end ;
58333: GO 58157
58335: POP
58336: POP
// end ;
58337: GO 57618
58339: POP
58340: POP
// end ;
58341: LD_VAR 0 1
58345: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
58346: LD_INT 0
58348: PPUSH
58349: PPUSH
58350: PPUSH
58351: PPUSH
58352: PPUSH
58353: PPUSH
58354: PPUSH
58355: PPUSH
58356: PPUSH
58357: PPUSH
58358: PPUSH
// if not mc_bases then
58359: LD_EXP 102
58363: NOT
58364: IFFALSE 58368
// exit ;
58366: GO 59170
// for i = 1 to mc_bases do
58368: LD_ADDR_VAR 0 2
58372: PUSH
58373: DOUBLE
58374: LD_INT 1
58376: DEC
58377: ST_TO_ADDR
58378: LD_EXP 102
58382: PUSH
58383: FOR_TO
58384: IFFALSE 59168
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
58386: LD_EXP 130
58390: PUSH
58391: LD_VAR 0 2
58395: ARRAY
58396: NOT
58397: PUSH
58398: LD_EXP 105
58402: PUSH
58403: LD_VAR 0 2
58407: ARRAY
58408: PUSH
58409: LD_INT 1
58411: ARRAY
58412: OR
58413: PUSH
58414: LD_EXP 105
58418: PUSH
58419: LD_VAR 0 2
58423: ARRAY
58424: PUSH
58425: LD_INT 2
58427: ARRAY
58428: OR
58429: PUSH
58430: LD_EXP 128
58434: PUSH
58435: LD_VAR 0 2
58439: ARRAY
58440: PPUSH
58441: LD_INT 1
58443: PPUSH
58444: CALL_OW 325
58448: NOT
58449: OR
58450: PUSH
58451: LD_EXP 125
58455: PUSH
58456: LD_VAR 0 2
58460: ARRAY
58461: OR
58462: IFFALSE 58466
// continue ;
58464: GO 58383
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
58466: LD_ADDR_VAR 0 8
58470: PUSH
58471: LD_EXP 102
58475: PUSH
58476: LD_VAR 0 2
58480: ARRAY
58481: PPUSH
58482: LD_INT 25
58484: PUSH
58485: LD_INT 4
58487: PUSH
58488: EMPTY
58489: LIST
58490: LIST
58491: PUSH
58492: LD_INT 50
58494: PUSH
58495: EMPTY
58496: LIST
58497: PUSH
58498: LD_INT 3
58500: PUSH
58501: LD_INT 60
58503: PUSH
58504: EMPTY
58505: LIST
58506: PUSH
58507: EMPTY
58508: LIST
58509: LIST
58510: PUSH
58511: EMPTY
58512: LIST
58513: LIST
58514: LIST
58515: PPUSH
58516: CALL_OW 72
58520: PUSH
58521: LD_EXP 106
58525: PUSH
58526: LD_VAR 0 2
58530: ARRAY
58531: DIFF
58532: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58533: LD_ADDR_VAR 0 9
58537: PUSH
58538: LD_EXP 102
58542: PUSH
58543: LD_VAR 0 2
58547: ARRAY
58548: PPUSH
58549: LD_INT 2
58551: PUSH
58552: LD_INT 30
58554: PUSH
58555: LD_INT 0
58557: PUSH
58558: EMPTY
58559: LIST
58560: LIST
58561: PUSH
58562: LD_INT 30
58564: PUSH
58565: LD_INT 1
58567: PUSH
58568: EMPTY
58569: LIST
58570: LIST
58571: PUSH
58572: EMPTY
58573: LIST
58574: LIST
58575: LIST
58576: PPUSH
58577: CALL_OW 72
58581: ST_TO_ADDR
// if not tmp or not dep then
58582: LD_VAR 0 8
58586: NOT
58587: PUSH
58588: LD_VAR 0 9
58592: NOT
58593: OR
58594: IFFALSE 58598
// continue ;
58596: GO 58383
// side := GetSide ( tmp [ 1 ] ) ;
58598: LD_ADDR_VAR 0 11
58602: PUSH
58603: LD_VAR 0 8
58607: PUSH
58608: LD_INT 1
58610: ARRAY
58611: PPUSH
58612: CALL_OW 255
58616: ST_TO_ADDR
// dep := dep [ 1 ] ;
58617: LD_ADDR_VAR 0 9
58621: PUSH
58622: LD_VAR 0 9
58626: PUSH
58627: LD_INT 1
58629: ARRAY
58630: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
58631: LD_ADDR_VAR 0 7
58635: PUSH
58636: LD_EXP 130
58640: PUSH
58641: LD_VAR 0 2
58645: ARRAY
58646: PPUSH
58647: LD_INT 22
58649: PUSH
58650: LD_INT 0
58652: PUSH
58653: EMPTY
58654: LIST
58655: LIST
58656: PUSH
58657: LD_INT 25
58659: PUSH
58660: LD_INT 12
58662: PUSH
58663: EMPTY
58664: LIST
58665: LIST
58666: PUSH
58667: EMPTY
58668: LIST
58669: LIST
58670: PPUSH
58671: CALL_OW 70
58675: PUSH
58676: LD_INT 22
58678: PUSH
58679: LD_INT 0
58681: PUSH
58682: EMPTY
58683: LIST
58684: LIST
58685: PUSH
58686: LD_INT 25
58688: PUSH
58689: LD_INT 12
58691: PUSH
58692: EMPTY
58693: LIST
58694: LIST
58695: PUSH
58696: LD_INT 91
58698: PUSH
58699: LD_VAR 0 9
58703: PUSH
58704: LD_INT 20
58706: PUSH
58707: EMPTY
58708: LIST
58709: LIST
58710: LIST
58711: PUSH
58712: EMPTY
58713: LIST
58714: LIST
58715: LIST
58716: PPUSH
58717: CALL_OW 69
58721: UNION
58722: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
58723: LD_ADDR_VAR 0 10
58727: PUSH
58728: LD_EXP 130
58732: PUSH
58733: LD_VAR 0 2
58737: ARRAY
58738: PPUSH
58739: LD_INT 81
58741: PUSH
58742: LD_VAR 0 11
58746: PUSH
58747: EMPTY
58748: LIST
58749: LIST
58750: PPUSH
58751: CALL_OW 70
58755: ST_TO_ADDR
// if not apes or danger_at_area then
58756: LD_VAR 0 7
58760: NOT
58761: PUSH
58762: LD_VAR 0 10
58766: OR
58767: IFFALSE 58817
// begin if mc_taming [ i ] then
58769: LD_EXP 133
58773: PUSH
58774: LD_VAR 0 2
58778: ARRAY
58779: IFFALSE 58815
// begin MC_Reset ( i , 121 ) ;
58781: LD_VAR 0 2
58785: PPUSH
58786: LD_INT 121
58788: PPUSH
58789: CALL 43733 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
58793: LD_ADDR_EXP 133
58797: PUSH
58798: LD_EXP 133
58802: PPUSH
58803: LD_VAR 0 2
58807: PPUSH
58808: EMPTY
58809: PPUSH
58810: CALL_OW 1
58814: ST_TO_ADDR
// end ; continue ;
58815: GO 58383
// end ; for j in tmp do
58817: LD_ADDR_VAR 0 3
58821: PUSH
58822: LD_VAR 0 8
58826: PUSH
58827: FOR_IN
58828: IFFALSE 59164
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
58830: LD_VAR 0 3
58834: PUSH
58835: LD_EXP 133
58839: PUSH
58840: LD_VAR 0 2
58844: ARRAY
58845: IN
58846: NOT
58847: PUSH
58848: LD_EXP 133
58852: PUSH
58853: LD_VAR 0 2
58857: ARRAY
58858: PUSH
58859: LD_INT 3
58861: LESS
58862: AND
58863: IFFALSE 58921
// begin SetTag ( j , 121 ) ;
58865: LD_VAR 0 3
58869: PPUSH
58870: LD_INT 121
58872: PPUSH
58873: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
58877: LD_ADDR_EXP 133
58881: PUSH
58882: LD_EXP 133
58886: PPUSH
58887: LD_VAR 0 2
58891: PUSH
58892: LD_EXP 133
58896: PUSH
58897: LD_VAR 0 2
58901: ARRAY
58902: PUSH
58903: LD_INT 1
58905: PLUS
58906: PUSH
58907: EMPTY
58908: LIST
58909: LIST
58910: PPUSH
58911: LD_VAR 0 3
58915: PPUSH
58916: CALL 75234 0 3
58920: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
58921: LD_VAR 0 3
58925: PUSH
58926: LD_EXP 133
58930: PUSH
58931: LD_VAR 0 2
58935: ARRAY
58936: IN
58937: IFFALSE 59162
// begin if GetClass ( j ) <> 4 then
58939: LD_VAR 0 3
58943: PPUSH
58944: CALL_OW 257
58948: PUSH
58949: LD_INT 4
58951: NONEQUAL
58952: IFFALSE 59005
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
58954: LD_ADDR_EXP 133
58958: PUSH
58959: LD_EXP 133
58963: PPUSH
58964: LD_VAR 0 2
58968: PPUSH
58969: LD_EXP 133
58973: PUSH
58974: LD_VAR 0 2
58978: ARRAY
58979: PUSH
58980: LD_VAR 0 3
58984: DIFF
58985: PPUSH
58986: CALL_OW 1
58990: ST_TO_ADDR
// SetTag ( j , 0 ) ;
58991: LD_VAR 0 3
58995: PPUSH
58996: LD_INT 0
58998: PPUSH
58999: CALL_OW 109
// continue ;
59003: GO 58827
// end ; if IsInUnit ( j ) then
59005: LD_VAR 0 3
59009: PPUSH
59010: CALL_OW 310
59014: IFFALSE 59025
// ComExitBuilding ( j ) ;
59016: LD_VAR 0 3
59020: PPUSH
59021: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
59025: LD_ADDR_VAR 0 6
59029: PUSH
59030: LD_VAR 0 7
59034: PPUSH
59035: LD_VAR 0 3
59039: PPUSH
59040: CALL_OW 74
59044: ST_TO_ADDR
// if not ape then
59045: LD_VAR 0 6
59049: NOT
59050: IFFALSE 59054
// break ;
59052: GO 59164
// x := GetX ( ape ) ;
59054: LD_ADDR_VAR 0 4
59058: PUSH
59059: LD_VAR 0 6
59063: PPUSH
59064: CALL_OW 250
59068: ST_TO_ADDR
// y := GetY ( ape ) ;
59069: LD_ADDR_VAR 0 5
59073: PUSH
59074: LD_VAR 0 6
59078: PPUSH
59079: CALL_OW 251
59083: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
59084: LD_VAR 0 4
59088: PPUSH
59089: LD_VAR 0 5
59093: PPUSH
59094: CALL_OW 488
59098: NOT
59099: PUSH
59100: LD_VAR 0 11
59104: PPUSH
59105: LD_VAR 0 4
59109: PPUSH
59110: LD_VAR 0 5
59114: PPUSH
59115: LD_INT 20
59117: PPUSH
59118: CALL 76498 0 4
59122: PUSH
59123: LD_INT 4
59125: ARRAY
59126: OR
59127: IFFALSE 59131
// break ;
59129: GO 59164
// if not HasTask ( j ) then
59131: LD_VAR 0 3
59135: PPUSH
59136: CALL_OW 314
59140: NOT
59141: IFFALSE 59162
// ComTameXY ( j , x , y ) ;
59143: LD_VAR 0 3
59147: PPUSH
59148: LD_VAR 0 4
59152: PPUSH
59153: LD_VAR 0 5
59157: PPUSH
59158: CALL_OW 131
// end ; end ;
59162: GO 58827
59164: POP
59165: POP
// end ;
59166: GO 58383
59168: POP
59169: POP
// end ;
59170: LD_VAR 0 1
59174: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
59175: LD_INT 0
59177: PPUSH
59178: PPUSH
59179: PPUSH
59180: PPUSH
59181: PPUSH
59182: PPUSH
59183: PPUSH
59184: PPUSH
// if not mc_bases then
59185: LD_EXP 102
59189: NOT
59190: IFFALSE 59194
// exit ;
59192: GO 59820
// for i = 1 to mc_bases do
59194: LD_ADDR_VAR 0 2
59198: PUSH
59199: DOUBLE
59200: LD_INT 1
59202: DEC
59203: ST_TO_ADDR
59204: LD_EXP 102
59208: PUSH
59209: FOR_TO
59210: IFFALSE 59818
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
59212: LD_EXP 131
59216: PUSH
59217: LD_VAR 0 2
59221: ARRAY
59222: NOT
59223: PUSH
59224: LD_EXP 131
59228: PUSH
59229: LD_VAR 0 2
59233: ARRAY
59234: PPUSH
59235: LD_INT 25
59237: PUSH
59238: LD_INT 12
59240: PUSH
59241: EMPTY
59242: LIST
59243: LIST
59244: PPUSH
59245: CALL_OW 72
59249: NOT
59250: OR
59251: IFFALSE 59255
// continue ;
59253: GO 59209
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
59255: LD_ADDR_VAR 0 5
59259: PUSH
59260: LD_EXP 131
59264: PUSH
59265: LD_VAR 0 2
59269: ARRAY
59270: PUSH
59271: LD_INT 1
59273: ARRAY
59274: PPUSH
59275: CALL_OW 255
59279: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
59280: LD_VAR 0 5
59284: PPUSH
59285: LD_INT 2
59287: PPUSH
59288: CALL_OW 325
59292: IFFALSE 59545
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
59294: LD_ADDR_VAR 0 4
59298: PUSH
59299: LD_EXP 131
59303: PUSH
59304: LD_VAR 0 2
59308: ARRAY
59309: PPUSH
59310: LD_INT 25
59312: PUSH
59313: LD_INT 16
59315: PUSH
59316: EMPTY
59317: LIST
59318: LIST
59319: PPUSH
59320: CALL_OW 72
59324: ST_TO_ADDR
// if tmp < 6 then
59325: LD_VAR 0 4
59329: PUSH
59330: LD_INT 6
59332: LESS
59333: IFFALSE 59545
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59335: LD_ADDR_VAR 0 6
59339: PUSH
59340: LD_EXP 102
59344: PUSH
59345: LD_VAR 0 2
59349: ARRAY
59350: PPUSH
59351: LD_INT 2
59353: PUSH
59354: LD_INT 30
59356: PUSH
59357: LD_INT 0
59359: PUSH
59360: EMPTY
59361: LIST
59362: LIST
59363: PUSH
59364: LD_INT 30
59366: PUSH
59367: LD_INT 1
59369: PUSH
59370: EMPTY
59371: LIST
59372: LIST
59373: PUSH
59374: EMPTY
59375: LIST
59376: LIST
59377: LIST
59378: PPUSH
59379: CALL_OW 72
59383: ST_TO_ADDR
// if depot then
59384: LD_VAR 0 6
59388: IFFALSE 59545
// begin selected := 0 ;
59390: LD_ADDR_VAR 0 7
59394: PUSH
59395: LD_INT 0
59397: ST_TO_ADDR
// for j in depot do
59398: LD_ADDR_VAR 0 3
59402: PUSH
59403: LD_VAR 0 6
59407: PUSH
59408: FOR_IN
59409: IFFALSE 59440
// begin if UnitsInside ( j ) < 6 then
59411: LD_VAR 0 3
59415: PPUSH
59416: CALL_OW 313
59420: PUSH
59421: LD_INT 6
59423: LESS
59424: IFFALSE 59438
// begin selected := j ;
59426: LD_ADDR_VAR 0 7
59430: PUSH
59431: LD_VAR 0 3
59435: ST_TO_ADDR
// break ;
59436: GO 59440
// end ; end ;
59438: GO 59408
59440: POP
59441: POP
// if selected then
59442: LD_VAR 0 7
59446: IFFALSE 59545
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
59448: LD_ADDR_VAR 0 3
59452: PUSH
59453: LD_EXP 131
59457: PUSH
59458: LD_VAR 0 2
59462: ARRAY
59463: PPUSH
59464: LD_INT 25
59466: PUSH
59467: LD_INT 12
59469: PUSH
59470: EMPTY
59471: LIST
59472: LIST
59473: PPUSH
59474: CALL_OW 72
59478: PUSH
59479: FOR_IN
59480: IFFALSE 59543
// if not HasTask ( j ) then
59482: LD_VAR 0 3
59486: PPUSH
59487: CALL_OW 314
59491: NOT
59492: IFFALSE 59541
// begin if not IsInUnit ( j ) then
59494: LD_VAR 0 3
59498: PPUSH
59499: CALL_OW 310
59503: NOT
59504: IFFALSE 59520
// ComEnterUnit ( j , selected ) ;
59506: LD_VAR 0 3
59510: PPUSH
59511: LD_VAR 0 7
59515: PPUSH
59516: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
59520: LD_VAR 0 3
59524: PPUSH
59525: LD_INT 16
59527: PPUSH
59528: CALL_OW 183
// AddComExitBuilding ( j ) ;
59532: LD_VAR 0 3
59536: PPUSH
59537: CALL_OW 182
// end ;
59541: GO 59479
59543: POP
59544: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
59545: LD_VAR 0 5
59549: PPUSH
59550: LD_INT 11
59552: PPUSH
59553: CALL_OW 325
59557: IFFALSE 59816
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
59559: LD_ADDR_VAR 0 4
59563: PUSH
59564: LD_EXP 131
59568: PUSH
59569: LD_VAR 0 2
59573: ARRAY
59574: PPUSH
59575: LD_INT 25
59577: PUSH
59578: LD_INT 16
59580: PUSH
59581: EMPTY
59582: LIST
59583: LIST
59584: PPUSH
59585: CALL_OW 72
59589: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
59590: LD_VAR 0 4
59594: PUSH
59595: LD_INT 6
59597: GREATEREQUAL
59598: PUSH
59599: LD_VAR 0 5
59603: PPUSH
59604: LD_INT 2
59606: PPUSH
59607: CALL_OW 325
59611: NOT
59612: OR
59613: IFFALSE 59816
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
59615: LD_ADDR_VAR 0 8
59619: PUSH
59620: LD_EXP 102
59624: PUSH
59625: LD_VAR 0 2
59629: ARRAY
59630: PPUSH
59631: LD_INT 2
59633: PUSH
59634: LD_INT 30
59636: PUSH
59637: LD_INT 4
59639: PUSH
59640: EMPTY
59641: LIST
59642: LIST
59643: PUSH
59644: LD_INT 30
59646: PUSH
59647: LD_INT 5
59649: PUSH
59650: EMPTY
59651: LIST
59652: LIST
59653: PUSH
59654: EMPTY
59655: LIST
59656: LIST
59657: LIST
59658: PPUSH
59659: CALL_OW 72
59663: ST_TO_ADDR
// if barracks then
59664: LD_VAR 0 8
59668: IFFALSE 59816
// begin selected := 0 ;
59670: LD_ADDR_VAR 0 7
59674: PUSH
59675: LD_INT 0
59677: ST_TO_ADDR
// for j in barracks do
59678: LD_ADDR_VAR 0 3
59682: PUSH
59683: LD_VAR 0 8
59687: PUSH
59688: FOR_IN
59689: IFFALSE 59720
// begin if UnitsInside ( j ) < 6 then
59691: LD_VAR 0 3
59695: PPUSH
59696: CALL_OW 313
59700: PUSH
59701: LD_INT 6
59703: LESS
59704: IFFALSE 59718
// begin selected := j ;
59706: LD_ADDR_VAR 0 7
59710: PUSH
59711: LD_VAR 0 3
59715: ST_TO_ADDR
// break ;
59716: GO 59720
// end ; end ;
59718: GO 59688
59720: POP
59721: POP
// if selected then
59722: LD_VAR 0 7
59726: IFFALSE 59816
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
59728: LD_ADDR_VAR 0 3
59732: PUSH
59733: LD_EXP 131
59737: PUSH
59738: LD_VAR 0 2
59742: ARRAY
59743: PPUSH
59744: LD_INT 25
59746: PUSH
59747: LD_INT 12
59749: PUSH
59750: EMPTY
59751: LIST
59752: LIST
59753: PPUSH
59754: CALL_OW 72
59758: PUSH
59759: FOR_IN
59760: IFFALSE 59814
// if not IsInUnit ( j ) and not HasTask ( j ) then
59762: LD_VAR 0 3
59766: PPUSH
59767: CALL_OW 310
59771: NOT
59772: PUSH
59773: LD_VAR 0 3
59777: PPUSH
59778: CALL_OW 314
59782: NOT
59783: AND
59784: IFFALSE 59812
// begin ComEnterUnit ( j , selected ) ;
59786: LD_VAR 0 3
59790: PPUSH
59791: LD_VAR 0 7
59795: PPUSH
59796: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
59800: LD_VAR 0 3
59804: PPUSH
59805: LD_INT 15
59807: PPUSH
59808: CALL_OW 183
// end ;
59812: GO 59759
59814: POP
59815: POP
// end ; end ; end ; end ; end ;
59816: GO 59209
59818: POP
59819: POP
// end ;
59820: LD_VAR 0 1
59824: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
59825: LD_INT 0
59827: PPUSH
59828: PPUSH
59829: PPUSH
59830: PPUSH
// if not mc_bases then
59831: LD_EXP 102
59835: NOT
59836: IFFALSE 59840
// exit ;
59838: GO 60018
// for i = 1 to mc_bases do
59840: LD_ADDR_VAR 0 2
59844: PUSH
59845: DOUBLE
59846: LD_INT 1
59848: DEC
59849: ST_TO_ADDR
59850: LD_EXP 102
59854: PUSH
59855: FOR_TO
59856: IFFALSE 60016
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
59858: LD_ADDR_VAR 0 4
59862: PUSH
59863: LD_EXP 102
59867: PUSH
59868: LD_VAR 0 2
59872: ARRAY
59873: PPUSH
59874: LD_INT 25
59876: PUSH
59877: LD_INT 9
59879: PUSH
59880: EMPTY
59881: LIST
59882: LIST
59883: PPUSH
59884: CALL_OW 72
59888: ST_TO_ADDR
// if not tmp then
59889: LD_VAR 0 4
59893: NOT
59894: IFFALSE 59898
// continue ;
59896: GO 59855
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
59898: LD_EXP 128
59902: PUSH
59903: LD_VAR 0 2
59907: ARRAY
59908: PPUSH
59909: LD_INT 29
59911: PPUSH
59912: CALL_OW 325
59916: NOT
59917: PUSH
59918: LD_EXP 128
59922: PUSH
59923: LD_VAR 0 2
59927: ARRAY
59928: PPUSH
59929: LD_INT 28
59931: PPUSH
59932: CALL_OW 325
59936: NOT
59937: AND
59938: IFFALSE 59942
// continue ;
59940: GO 59855
// for j in tmp do
59942: LD_ADDR_VAR 0 3
59946: PUSH
59947: LD_VAR 0 4
59951: PUSH
59952: FOR_IN
59953: IFFALSE 60012
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
59955: LD_VAR 0 3
59959: PUSH
59960: LD_EXP 105
59964: PUSH
59965: LD_VAR 0 2
59969: ARRAY
59970: PUSH
59971: LD_INT 1
59973: ARRAY
59974: IN
59975: NOT
59976: PUSH
59977: LD_VAR 0 3
59981: PUSH
59982: LD_EXP 105
59986: PUSH
59987: LD_VAR 0 2
59991: ARRAY
59992: PUSH
59993: LD_INT 2
59995: ARRAY
59996: IN
59997: NOT
59998: AND
59999: IFFALSE 60010
// ComSpaceTimeShoot ( j ) ;
60001: LD_VAR 0 3
60005: PPUSH
60006: CALL 71219 0 1
60010: GO 59952
60012: POP
60013: POP
// end ;
60014: GO 59855
60016: POP
60017: POP
// end ;
60018: LD_VAR 0 1
60022: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
60023: LD_INT 0
60025: PPUSH
60026: PPUSH
60027: PPUSH
60028: PPUSH
60029: PPUSH
60030: PPUSH
60031: PPUSH
60032: PPUSH
60033: PPUSH
// if not mc_bases then
60034: LD_EXP 102
60038: NOT
60039: IFFALSE 60043
// exit ;
60041: GO 60665
// for i = 1 to mc_bases do
60043: LD_ADDR_VAR 0 2
60047: PUSH
60048: DOUBLE
60049: LD_INT 1
60051: DEC
60052: ST_TO_ADDR
60053: LD_EXP 102
60057: PUSH
60058: FOR_TO
60059: IFFALSE 60663
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
60061: LD_EXP 137
60065: PUSH
60066: LD_VAR 0 2
60070: ARRAY
60071: NOT
60072: PUSH
60073: LD_INT 38
60075: PPUSH
60076: LD_EXP 128
60080: PUSH
60081: LD_VAR 0 2
60085: ARRAY
60086: PPUSH
60087: CALL_OW 321
60091: PUSH
60092: LD_INT 2
60094: NONEQUAL
60095: OR
60096: IFFALSE 60100
// continue ;
60098: GO 60058
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
60100: LD_ADDR_VAR 0 8
60104: PUSH
60105: LD_EXP 102
60109: PUSH
60110: LD_VAR 0 2
60114: ARRAY
60115: PPUSH
60116: LD_INT 30
60118: PUSH
60119: LD_INT 34
60121: PUSH
60122: EMPTY
60123: LIST
60124: LIST
60125: PPUSH
60126: CALL_OW 72
60130: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
60131: LD_ADDR_VAR 0 9
60135: PUSH
60136: LD_EXP 102
60140: PUSH
60141: LD_VAR 0 2
60145: ARRAY
60146: PPUSH
60147: LD_INT 25
60149: PUSH
60150: LD_INT 4
60152: PUSH
60153: EMPTY
60154: LIST
60155: LIST
60156: PPUSH
60157: CALL_OW 72
60161: PPUSH
60162: LD_INT 0
60164: PPUSH
60165: CALL 105532 0 2
60169: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
60170: LD_VAR 0 9
60174: NOT
60175: PUSH
60176: LD_VAR 0 8
60180: NOT
60181: OR
60182: PUSH
60183: LD_EXP 102
60187: PUSH
60188: LD_VAR 0 2
60192: ARRAY
60193: PPUSH
60194: LD_INT 124
60196: PPUSH
60197: CALL 105532 0 2
60201: OR
60202: IFFALSE 60206
// continue ;
60204: GO 60058
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
60206: LD_EXP 138
60210: PUSH
60211: LD_VAR 0 2
60215: ARRAY
60216: PUSH
60217: LD_EXP 137
60221: PUSH
60222: LD_VAR 0 2
60226: ARRAY
60227: LESS
60228: PUSH
60229: LD_EXP 138
60233: PUSH
60234: LD_VAR 0 2
60238: ARRAY
60239: PUSH
60240: LD_VAR 0 8
60244: LESS
60245: AND
60246: IFFALSE 60661
// begin tmp := sci [ 1 ] ;
60248: LD_ADDR_VAR 0 7
60252: PUSH
60253: LD_VAR 0 9
60257: PUSH
60258: LD_INT 1
60260: ARRAY
60261: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
60262: LD_VAR 0 7
60266: PPUSH
60267: LD_INT 124
60269: PPUSH
60270: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
60274: LD_ADDR_VAR 0 3
60278: PUSH
60279: DOUBLE
60280: LD_EXP 137
60284: PUSH
60285: LD_VAR 0 2
60289: ARRAY
60290: INC
60291: ST_TO_ADDR
60292: LD_EXP 137
60296: PUSH
60297: LD_VAR 0 2
60301: ARRAY
60302: PUSH
60303: FOR_DOWNTO
60304: IFFALSE 60647
// begin if IsInUnit ( tmp ) then
60306: LD_VAR 0 7
60310: PPUSH
60311: CALL_OW 310
60315: IFFALSE 60326
// ComExitBuilding ( tmp ) ;
60317: LD_VAR 0 7
60321: PPUSH
60322: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
60326: LD_INT 35
60328: PPUSH
60329: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
60333: LD_VAR 0 7
60337: PPUSH
60338: CALL_OW 310
60342: NOT
60343: PUSH
60344: LD_VAR 0 7
60348: PPUSH
60349: CALL_OW 314
60353: NOT
60354: AND
60355: IFFALSE 60326
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
60357: LD_ADDR_VAR 0 6
60361: PUSH
60362: LD_VAR 0 7
60366: PPUSH
60367: CALL_OW 250
60371: PUSH
60372: LD_VAR 0 7
60376: PPUSH
60377: CALL_OW 251
60381: PUSH
60382: EMPTY
60383: LIST
60384: LIST
60385: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
60386: LD_INT 35
60388: PPUSH
60389: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
60393: LD_ADDR_VAR 0 4
60397: PUSH
60398: LD_EXP 137
60402: PUSH
60403: LD_VAR 0 2
60407: ARRAY
60408: PUSH
60409: LD_VAR 0 3
60413: ARRAY
60414: PUSH
60415: LD_INT 1
60417: ARRAY
60418: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
60419: LD_ADDR_VAR 0 5
60423: PUSH
60424: LD_EXP 137
60428: PUSH
60429: LD_VAR 0 2
60433: ARRAY
60434: PUSH
60435: LD_VAR 0 3
60439: ARRAY
60440: PUSH
60441: LD_INT 2
60443: ARRAY
60444: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
60445: LD_VAR 0 7
60449: PPUSH
60450: LD_INT 10
60452: PPUSH
60453: CALL 78199 0 2
60457: PUSH
60458: LD_INT 4
60460: ARRAY
60461: IFFALSE 60499
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
60463: LD_VAR 0 7
60467: PPUSH
60468: LD_VAR 0 6
60472: PUSH
60473: LD_INT 1
60475: ARRAY
60476: PPUSH
60477: LD_VAR 0 6
60481: PUSH
60482: LD_INT 2
60484: ARRAY
60485: PPUSH
60486: CALL_OW 111
// wait ( 0 0$10 ) ;
60490: LD_INT 350
60492: PPUSH
60493: CALL_OW 67
// end else
60497: GO 60525
// begin ComMoveXY ( tmp , x , y ) ;
60499: LD_VAR 0 7
60503: PPUSH
60504: LD_VAR 0 4
60508: PPUSH
60509: LD_VAR 0 5
60513: PPUSH
60514: CALL_OW 111
// wait ( 0 0$3 ) ;
60518: LD_INT 105
60520: PPUSH
60521: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
60525: LD_VAR 0 7
60529: PPUSH
60530: LD_VAR 0 4
60534: PPUSH
60535: LD_VAR 0 5
60539: PPUSH
60540: CALL_OW 307
60544: IFFALSE 60386
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
60546: LD_VAR 0 7
60550: PPUSH
60551: LD_VAR 0 4
60555: PPUSH
60556: LD_VAR 0 5
60560: PPUSH
60561: LD_VAR 0 8
60565: PUSH
60566: LD_VAR 0 3
60570: ARRAY
60571: PPUSH
60572: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
60576: LD_INT 35
60578: PPUSH
60579: CALL_OW 67
// until not HasTask ( tmp ) ;
60583: LD_VAR 0 7
60587: PPUSH
60588: CALL_OW 314
60592: NOT
60593: IFFALSE 60576
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
60595: LD_ADDR_EXP 138
60599: PUSH
60600: LD_EXP 138
60604: PPUSH
60605: LD_VAR 0 2
60609: PUSH
60610: LD_EXP 138
60614: PUSH
60615: LD_VAR 0 2
60619: ARRAY
60620: PUSH
60621: LD_INT 1
60623: PLUS
60624: PUSH
60625: EMPTY
60626: LIST
60627: LIST
60628: PPUSH
60629: LD_VAR 0 8
60633: PUSH
60634: LD_VAR 0 3
60638: ARRAY
60639: PPUSH
60640: CALL 75234 0 3
60644: ST_TO_ADDR
// end ;
60645: GO 60303
60647: POP
60648: POP
// MC_Reset ( i , 124 ) ;
60649: LD_VAR 0 2
60653: PPUSH
60654: LD_INT 124
60656: PPUSH
60657: CALL 43733 0 2
// end ; end ;
60661: GO 60058
60663: POP
60664: POP
// end ;
60665: LD_VAR 0 1
60669: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
60670: LD_INT 0
60672: PPUSH
60673: PPUSH
60674: PPUSH
// if not mc_bases then
60675: LD_EXP 102
60679: NOT
60680: IFFALSE 60684
// exit ;
60682: GO 61290
// for i = 1 to mc_bases do
60684: LD_ADDR_VAR 0 2
60688: PUSH
60689: DOUBLE
60690: LD_INT 1
60692: DEC
60693: ST_TO_ADDR
60694: LD_EXP 102
60698: PUSH
60699: FOR_TO
60700: IFFALSE 61288
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
60702: LD_ADDR_VAR 0 3
60706: PUSH
60707: LD_EXP 102
60711: PUSH
60712: LD_VAR 0 2
60716: ARRAY
60717: PPUSH
60718: LD_INT 25
60720: PUSH
60721: LD_INT 4
60723: PUSH
60724: EMPTY
60725: LIST
60726: LIST
60727: PPUSH
60728: CALL_OW 72
60732: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
60733: LD_VAR 0 3
60737: NOT
60738: PUSH
60739: LD_EXP 139
60743: PUSH
60744: LD_VAR 0 2
60748: ARRAY
60749: NOT
60750: OR
60751: PUSH
60752: LD_EXP 102
60756: PUSH
60757: LD_VAR 0 2
60761: ARRAY
60762: PPUSH
60763: LD_INT 2
60765: PUSH
60766: LD_INT 30
60768: PUSH
60769: LD_INT 0
60771: PUSH
60772: EMPTY
60773: LIST
60774: LIST
60775: PUSH
60776: LD_INT 30
60778: PUSH
60779: LD_INT 1
60781: PUSH
60782: EMPTY
60783: LIST
60784: LIST
60785: PUSH
60786: EMPTY
60787: LIST
60788: LIST
60789: LIST
60790: PPUSH
60791: CALL_OW 72
60795: NOT
60796: OR
60797: IFFALSE 60847
// begin if mc_deposits_finder [ i ] then
60799: LD_EXP 140
60803: PUSH
60804: LD_VAR 0 2
60808: ARRAY
60809: IFFALSE 60845
// begin MC_Reset ( i , 125 ) ;
60811: LD_VAR 0 2
60815: PPUSH
60816: LD_INT 125
60818: PPUSH
60819: CALL 43733 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60823: LD_ADDR_EXP 140
60827: PUSH
60828: LD_EXP 140
60832: PPUSH
60833: LD_VAR 0 2
60837: PPUSH
60838: EMPTY
60839: PPUSH
60840: CALL_OW 1
60844: ST_TO_ADDR
// end ; continue ;
60845: GO 60699
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
60847: LD_EXP 139
60851: PUSH
60852: LD_VAR 0 2
60856: ARRAY
60857: PUSH
60858: LD_INT 1
60860: ARRAY
60861: PUSH
60862: LD_INT 3
60864: ARRAY
60865: PUSH
60866: LD_INT 1
60868: EQUAL
60869: PUSH
60870: LD_INT 20
60872: PPUSH
60873: LD_EXP 128
60877: PUSH
60878: LD_VAR 0 2
60882: ARRAY
60883: PPUSH
60884: CALL_OW 321
60888: PUSH
60889: LD_INT 2
60891: NONEQUAL
60892: AND
60893: IFFALSE 60943
// begin if mc_deposits_finder [ i ] then
60895: LD_EXP 140
60899: PUSH
60900: LD_VAR 0 2
60904: ARRAY
60905: IFFALSE 60941
// begin MC_Reset ( i , 125 ) ;
60907: LD_VAR 0 2
60911: PPUSH
60912: LD_INT 125
60914: PPUSH
60915: CALL 43733 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60919: LD_ADDR_EXP 140
60923: PUSH
60924: LD_EXP 140
60928: PPUSH
60929: LD_VAR 0 2
60933: PPUSH
60934: EMPTY
60935: PPUSH
60936: CALL_OW 1
60940: ST_TO_ADDR
// end ; continue ;
60941: GO 60699
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
60943: LD_EXP 139
60947: PUSH
60948: LD_VAR 0 2
60952: ARRAY
60953: PUSH
60954: LD_INT 1
60956: ARRAY
60957: PUSH
60958: LD_INT 1
60960: ARRAY
60961: PPUSH
60962: LD_EXP 139
60966: PUSH
60967: LD_VAR 0 2
60971: ARRAY
60972: PUSH
60973: LD_INT 1
60975: ARRAY
60976: PUSH
60977: LD_INT 2
60979: ARRAY
60980: PPUSH
60981: LD_EXP 128
60985: PUSH
60986: LD_VAR 0 2
60990: ARRAY
60991: PPUSH
60992: CALL_OW 440
60996: IFFALSE 61039
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
60998: LD_ADDR_EXP 139
61002: PUSH
61003: LD_EXP 139
61007: PPUSH
61008: LD_VAR 0 2
61012: PPUSH
61013: LD_EXP 139
61017: PUSH
61018: LD_VAR 0 2
61022: ARRAY
61023: PPUSH
61024: LD_INT 1
61026: PPUSH
61027: CALL_OW 3
61031: PPUSH
61032: CALL_OW 1
61036: ST_TO_ADDR
61037: GO 61286
// begin if not mc_deposits_finder [ i ] then
61039: LD_EXP 140
61043: PUSH
61044: LD_VAR 0 2
61048: ARRAY
61049: NOT
61050: IFFALSE 61102
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
61052: LD_ADDR_EXP 140
61056: PUSH
61057: LD_EXP 140
61061: PPUSH
61062: LD_VAR 0 2
61066: PPUSH
61067: LD_VAR 0 3
61071: PUSH
61072: LD_INT 1
61074: ARRAY
61075: PUSH
61076: EMPTY
61077: LIST
61078: PPUSH
61079: CALL_OW 1
61083: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
61084: LD_VAR 0 3
61088: PUSH
61089: LD_INT 1
61091: ARRAY
61092: PPUSH
61093: LD_INT 125
61095: PPUSH
61096: CALL_OW 109
// end else
61100: GO 61286
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
61102: LD_EXP 140
61106: PUSH
61107: LD_VAR 0 2
61111: ARRAY
61112: PUSH
61113: LD_INT 1
61115: ARRAY
61116: PPUSH
61117: CALL_OW 310
61121: IFFALSE 61144
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
61123: LD_EXP 140
61127: PUSH
61128: LD_VAR 0 2
61132: ARRAY
61133: PUSH
61134: LD_INT 1
61136: ARRAY
61137: PPUSH
61138: CALL_OW 122
61142: GO 61286
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
61144: LD_EXP 140
61148: PUSH
61149: LD_VAR 0 2
61153: ARRAY
61154: PUSH
61155: LD_INT 1
61157: ARRAY
61158: PPUSH
61159: CALL_OW 314
61163: NOT
61164: PUSH
61165: LD_EXP 140
61169: PUSH
61170: LD_VAR 0 2
61174: ARRAY
61175: PUSH
61176: LD_INT 1
61178: ARRAY
61179: PPUSH
61180: LD_EXP 139
61184: PUSH
61185: LD_VAR 0 2
61189: ARRAY
61190: PUSH
61191: LD_INT 1
61193: ARRAY
61194: PUSH
61195: LD_INT 1
61197: ARRAY
61198: PPUSH
61199: LD_EXP 139
61203: PUSH
61204: LD_VAR 0 2
61208: ARRAY
61209: PUSH
61210: LD_INT 1
61212: ARRAY
61213: PUSH
61214: LD_INT 2
61216: ARRAY
61217: PPUSH
61218: CALL_OW 297
61222: PUSH
61223: LD_INT 6
61225: GREATER
61226: AND
61227: IFFALSE 61286
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
61229: LD_EXP 140
61233: PUSH
61234: LD_VAR 0 2
61238: ARRAY
61239: PUSH
61240: LD_INT 1
61242: ARRAY
61243: PPUSH
61244: LD_EXP 139
61248: PUSH
61249: LD_VAR 0 2
61253: ARRAY
61254: PUSH
61255: LD_INT 1
61257: ARRAY
61258: PUSH
61259: LD_INT 1
61261: ARRAY
61262: PPUSH
61263: LD_EXP 139
61267: PUSH
61268: LD_VAR 0 2
61272: ARRAY
61273: PUSH
61274: LD_INT 1
61276: ARRAY
61277: PUSH
61278: LD_INT 2
61280: ARRAY
61281: PPUSH
61282: CALL_OW 111
// end ; end ; end ;
61286: GO 60699
61288: POP
61289: POP
// end ;
61290: LD_VAR 0 1
61294: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
61295: LD_INT 0
61297: PPUSH
61298: PPUSH
61299: PPUSH
61300: PPUSH
61301: PPUSH
61302: PPUSH
61303: PPUSH
61304: PPUSH
61305: PPUSH
61306: PPUSH
61307: PPUSH
// if not mc_bases then
61308: LD_EXP 102
61312: NOT
61313: IFFALSE 61317
// exit ;
61315: GO 62257
// for i = 1 to mc_bases do
61317: LD_ADDR_VAR 0 2
61321: PUSH
61322: DOUBLE
61323: LD_INT 1
61325: DEC
61326: ST_TO_ADDR
61327: LD_EXP 102
61331: PUSH
61332: FOR_TO
61333: IFFALSE 62255
// begin if not mc_bases [ i ] or mc_scan [ i ] then
61335: LD_EXP 102
61339: PUSH
61340: LD_VAR 0 2
61344: ARRAY
61345: NOT
61346: PUSH
61347: LD_EXP 125
61351: PUSH
61352: LD_VAR 0 2
61356: ARRAY
61357: OR
61358: IFFALSE 61362
// continue ;
61360: GO 61332
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
61362: LD_ADDR_VAR 0 7
61366: PUSH
61367: LD_EXP 102
61371: PUSH
61372: LD_VAR 0 2
61376: ARRAY
61377: PUSH
61378: LD_INT 1
61380: ARRAY
61381: PPUSH
61382: CALL_OW 248
61386: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
61387: LD_VAR 0 7
61391: PUSH
61392: LD_INT 3
61394: EQUAL
61395: PUSH
61396: LD_EXP 121
61400: PUSH
61401: LD_VAR 0 2
61405: ARRAY
61406: PUSH
61407: LD_EXP 124
61411: PUSH
61412: LD_VAR 0 2
61416: ARRAY
61417: UNION
61418: PPUSH
61419: LD_INT 33
61421: PUSH
61422: LD_INT 2
61424: PUSH
61425: EMPTY
61426: LIST
61427: LIST
61428: PPUSH
61429: CALL_OW 72
61433: NOT
61434: OR
61435: IFFALSE 61439
// continue ;
61437: GO 61332
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
61439: LD_ADDR_VAR 0 9
61443: PUSH
61444: LD_EXP 102
61448: PUSH
61449: LD_VAR 0 2
61453: ARRAY
61454: PPUSH
61455: LD_INT 30
61457: PUSH
61458: LD_INT 36
61460: PUSH
61461: EMPTY
61462: LIST
61463: LIST
61464: PPUSH
61465: CALL_OW 72
61469: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
61470: LD_ADDR_VAR 0 10
61474: PUSH
61475: LD_EXP 121
61479: PUSH
61480: LD_VAR 0 2
61484: ARRAY
61485: PPUSH
61486: LD_INT 34
61488: PUSH
61489: LD_INT 31
61491: PUSH
61492: EMPTY
61493: LIST
61494: LIST
61495: PPUSH
61496: CALL_OW 72
61500: ST_TO_ADDR
// if not cts and not mcts then
61501: LD_VAR 0 9
61505: NOT
61506: PUSH
61507: LD_VAR 0 10
61511: NOT
61512: AND
61513: IFFALSE 61517
// continue ;
61515: GO 61332
// x := cts ;
61517: LD_ADDR_VAR 0 11
61521: PUSH
61522: LD_VAR 0 9
61526: ST_TO_ADDR
// if not x then
61527: LD_VAR 0 11
61531: NOT
61532: IFFALSE 61544
// x := mcts ;
61534: LD_ADDR_VAR 0 11
61538: PUSH
61539: LD_VAR 0 10
61543: ST_TO_ADDR
// if not x then
61544: LD_VAR 0 11
61548: NOT
61549: IFFALSE 61553
// continue ;
61551: GO 61332
// if mc_remote_driver [ i ] then
61553: LD_EXP 142
61557: PUSH
61558: LD_VAR 0 2
61562: ARRAY
61563: IFFALSE 61950
// for j in mc_remote_driver [ i ] do
61565: LD_ADDR_VAR 0 3
61569: PUSH
61570: LD_EXP 142
61574: PUSH
61575: LD_VAR 0 2
61579: ARRAY
61580: PUSH
61581: FOR_IN
61582: IFFALSE 61948
// begin if GetClass ( j ) <> 3 then
61584: LD_VAR 0 3
61588: PPUSH
61589: CALL_OW 257
61593: PUSH
61594: LD_INT 3
61596: NONEQUAL
61597: IFFALSE 61650
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
61599: LD_ADDR_EXP 142
61603: PUSH
61604: LD_EXP 142
61608: PPUSH
61609: LD_VAR 0 2
61613: PPUSH
61614: LD_EXP 142
61618: PUSH
61619: LD_VAR 0 2
61623: ARRAY
61624: PUSH
61625: LD_VAR 0 3
61629: DIFF
61630: PPUSH
61631: CALL_OW 1
61635: ST_TO_ADDR
// SetTag ( j , 0 ) ;
61636: LD_VAR 0 3
61640: PPUSH
61641: LD_INT 0
61643: PPUSH
61644: CALL_OW 109
// continue ;
61648: GO 61581
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
61650: LD_EXP 121
61654: PUSH
61655: LD_VAR 0 2
61659: ARRAY
61660: PPUSH
61661: LD_INT 34
61663: PUSH
61664: LD_INT 31
61666: PUSH
61667: EMPTY
61668: LIST
61669: LIST
61670: PUSH
61671: LD_INT 58
61673: PUSH
61674: EMPTY
61675: LIST
61676: PUSH
61677: EMPTY
61678: LIST
61679: LIST
61680: PPUSH
61681: CALL_OW 72
61685: PUSH
61686: LD_VAR 0 3
61690: PPUSH
61691: CALL 105567 0 1
61695: NOT
61696: AND
61697: IFFALSE 61768
// begin if IsInUnit ( j ) then
61699: LD_VAR 0 3
61703: PPUSH
61704: CALL_OW 310
61708: IFFALSE 61719
// ComExitBuilding ( j ) ;
61710: LD_VAR 0 3
61714: PPUSH
61715: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
61719: LD_VAR 0 3
61723: PPUSH
61724: LD_EXP 121
61728: PUSH
61729: LD_VAR 0 2
61733: ARRAY
61734: PPUSH
61735: LD_INT 34
61737: PUSH
61738: LD_INT 31
61740: PUSH
61741: EMPTY
61742: LIST
61743: LIST
61744: PUSH
61745: LD_INT 58
61747: PUSH
61748: EMPTY
61749: LIST
61750: PUSH
61751: EMPTY
61752: LIST
61753: LIST
61754: PPUSH
61755: CALL_OW 72
61759: PUSH
61760: LD_INT 1
61762: ARRAY
61763: PPUSH
61764: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
61768: LD_VAR 0 3
61772: PPUSH
61773: CALL_OW 310
61777: NOT
61778: PUSH
61779: LD_VAR 0 3
61783: PPUSH
61784: CALL_OW 310
61788: PPUSH
61789: CALL_OW 266
61793: PUSH
61794: LD_INT 36
61796: NONEQUAL
61797: PUSH
61798: LD_VAR 0 3
61802: PPUSH
61803: CALL 105567 0 1
61807: NOT
61808: AND
61809: OR
61810: IFFALSE 61946
// begin if IsInUnit ( j ) then
61812: LD_VAR 0 3
61816: PPUSH
61817: CALL_OW 310
61821: IFFALSE 61832
// ComExitBuilding ( j ) ;
61823: LD_VAR 0 3
61827: PPUSH
61828: CALL_OW 122
// ct := 0 ;
61832: LD_ADDR_VAR 0 8
61836: PUSH
61837: LD_INT 0
61839: ST_TO_ADDR
// for k in x do
61840: LD_ADDR_VAR 0 4
61844: PUSH
61845: LD_VAR 0 11
61849: PUSH
61850: FOR_IN
61851: IFFALSE 61924
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
61853: LD_VAR 0 4
61857: PPUSH
61858: CALL_OW 264
61862: PUSH
61863: LD_INT 31
61865: EQUAL
61866: PUSH
61867: LD_VAR 0 4
61871: PPUSH
61872: CALL_OW 311
61876: NOT
61877: AND
61878: PUSH
61879: LD_VAR 0 4
61883: PPUSH
61884: CALL_OW 266
61888: PUSH
61889: LD_INT 36
61891: EQUAL
61892: PUSH
61893: LD_VAR 0 4
61897: PPUSH
61898: CALL_OW 313
61902: PUSH
61903: LD_INT 3
61905: LESS
61906: AND
61907: OR
61908: IFFALSE 61922
// begin ct := k ;
61910: LD_ADDR_VAR 0 8
61914: PUSH
61915: LD_VAR 0 4
61919: ST_TO_ADDR
// break ;
61920: GO 61924
// end ;
61922: GO 61850
61924: POP
61925: POP
// if ct then
61926: LD_VAR 0 8
61930: IFFALSE 61946
// ComEnterUnit ( j , ct ) ;
61932: LD_VAR 0 3
61936: PPUSH
61937: LD_VAR 0 8
61941: PPUSH
61942: CALL_OW 120
// end ; end ;
61946: GO 61581
61948: POP
61949: POP
// places := 0 ;
61950: LD_ADDR_VAR 0 5
61954: PUSH
61955: LD_INT 0
61957: ST_TO_ADDR
// for j = 1 to x do
61958: LD_ADDR_VAR 0 3
61962: PUSH
61963: DOUBLE
61964: LD_INT 1
61966: DEC
61967: ST_TO_ADDR
61968: LD_VAR 0 11
61972: PUSH
61973: FOR_TO
61974: IFFALSE 62050
// if GetWeapon ( x [ j ] ) = ar_control_tower then
61976: LD_VAR 0 11
61980: PUSH
61981: LD_VAR 0 3
61985: ARRAY
61986: PPUSH
61987: CALL_OW 264
61991: PUSH
61992: LD_INT 31
61994: EQUAL
61995: IFFALSE 62013
// places := places + 1 else
61997: LD_ADDR_VAR 0 5
62001: PUSH
62002: LD_VAR 0 5
62006: PUSH
62007: LD_INT 1
62009: PLUS
62010: ST_TO_ADDR
62011: GO 62048
// if GetBType ( x [ j ] ) = b_control_tower then
62013: LD_VAR 0 11
62017: PUSH
62018: LD_VAR 0 3
62022: ARRAY
62023: PPUSH
62024: CALL_OW 266
62028: PUSH
62029: LD_INT 36
62031: EQUAL
62032: IFFALSE 62048
// places := places + 3 ;
62034: LD_ADDR_VAR 0 5
62038: PUSH
62039: LD_VAR 0 5
62043: PUSH
62044: LD_INT 3
62046: PLUS
62047: ST_TO_ADDR
62048: GO 61973
62050: POP
62051: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
62052: LD_VAR 0 5
62056: PUSH
62057: LD_INT 0
62059: EQUAL
62060: PUSH
62061: LD_VAR 0 5
62065: PUSH
62066: LD_EXP 142
62070: PUSH
62071: LD_VAR 0 2
62075: ARRAY
62076: LESSEQUAL
62077: OR
62078: IFFALSE 62082
// continue ;
62080: GO 61332
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
62082: LD_ADDR_VAR 0 6
62086: PUSH
62087: LD_EXP 102
62091: PUSH
62092: LD_VAR 0 2
62096: ARRAY
62097: PPUSH
62098: LD_INT 25
62100: PUSH
62101: LD_INT 3
62103: PUSH
62104: EMPTY
62105: LIST
62106: LIST
62107: PPUSH
62108: CALL_OW 72
62112: PUSH
62113: LD_EXP 142
62117: PUSH
62118: LD_VAR 0 2
62122: ARRAY
62123: DIFF
62124: PPUSH
62125: LD_INT 3
62127: PPUSH
62128: CALL 106467 0 2
62132: ST_TO_ADDR
// for j in tmp do
62133: LD_ADDR_VAR 0 3
62137: PUSH
62138: LD_VAR 0 6
62142: PUSH
62143: FOR_IN
62144: IFFALSE 62179
// if GetTag ( j ) > 0 then
62146: LD_VAR 0 3
62150: PPUSH
62151: CALL_OW 110
62155: PUSH
62156: LD_INT 0
62158: GREATER
62159: IFFALSE 62177
// tmp := tmp diff j ;
62161: LD_ADDR_VAR 0 6
62165: PUSH
62166: LD_VAR 0 6
62170: PUSH
62171: LD_VAR 0 3
62175: DIFF
62176: ST_TO_ADDR
62177: GO 62143
62179: POP
62180: POP
// if not tmp then
62181: LD_VAR 0 6
62185: NOT
62186: IFFALSE 62190
// continue ;
62188: GO 61332
// if places then
62190: LD_VAR 0 5
62194: IFFALSE 62253
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
62196: LD_ADDR_EXP 142
62200: PUSH
62201: LD_EXP 142
62205: PPUSH
62206: LD_VAR 0 2
62210: PPUSH
62211: LD_EXP 142
62215: PUSH
62216: LD_VAR 0 2
62220: ARRAY
62221: PUSH
62222: LD_VAR 0 6
62226: PUSH
62227: LD_INT 1
62229: ARRAY
62230: UNION
62231: PPUSH
62232: CALL_OW 1
62236: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
62237: LD_VAR 0 6
62241: PUSH
62242: LD_INT 1
62244: ARRAY
62245: PPUSH
62246: LD_INT 126
62248: PPUSH
62249: CALL_OW 109
// end ; end ;
62253: GO 61332
62255: POP
62256: POP
// end ;
62257: LD_VAR 0 1
62261: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
62262: LD_INT 0
62264: PPUSH
62265: PPUSH
62266: PPUSH
62267: PPUSH
62268: PPUSH
62269: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
62270: LD_VAR 0 1
62274: NOT
62275: PUSH
62276: LD_VAR 0 2
62280: NOT
62281: OR
62282: PUSH
62283: LD_VAR 0 3
62287: NOT
62288: OR
62289: PUSH
62290: LD_VAR 0 4
62294: PUSH
62295: LD_INT 1
62297: PUSH
62298: LD_INT 2
62300: PUSH
62301: LD_INT 3
62303: PUSH
62304: LD_INT 4
62306: PUSH
62307: LD_INT 5
62309: PUSH
62310: LD_INT 8
62312: PUSH
62313: LD_INT 9
62315: PUSH
62316: LD_INT 15
62318: PUSH
62319: LD_INT 16
62321: PUSH
62322: EMPTY
62323: LIST
62324: LIST
62325: LIST
62326: LIST
62327: LIST
62328: LIST
62329: LIST
62330: LIST
62331: LIST
62332: IN
62333: NOT
62334: OR
62335: IFFALSE 62339
// exit ;
62337: GO 63197
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
62339: LD_ADDR_VAR 0 2
62343: PUSH
62344: LD_VAR 0 2
62348: PPUSH
62349: LD_INT 21
62351: PUSH
62352: LD_INT 3
62354: PUSH
62355: EMPTY
62356: LIST
62357: LIST
62358: PUSH
62359: LD_INT 24
62361: PUSH
62362: LD_INT 250
62364: PUSH
62365: EMPTY
62366: LIST
62367: LIST
62368: PUSH
62369: EMPTY
62370: LIST
62371: LIST
62372: PPUSH
62373: CALL_OW 72
62377: ST_TO_ADDR
// case class of 1 , 15 :
62378: LD_VAR 0 4
62382: PUSH
62383: LD_INT 1
62385: DOUBLE
62386: EQUAL
62387: IFTRUE 62397
62389: LD_INT 15
62391: DOUBLE
62392: EQUAL
62393: IFTRUE 62397
62395: GO 62482
62397: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
62398: LD_ADDR_VAR 0 8
62402: PUSH
62403: LD_VAR 0 2
62407: PPUSH
62408: LD_INT 2
62410: PUSH
62411: LD_INT 30
62413: PUSH
62414: LD_INT 32
62416: PUSH
62417: EMPTY
62418: LIST
62419: LIST
62420: PUSH
62421: LD_INT 30
62423: PUSH
62424: LD_INT 31
62426: PUSH
62427: EMPTY
62428: LIST
62429: LIST
62430: PUSH
62431: EMPTY
62432: LIST
62433: LIST
62434: LIST
62435: PPUSH
62436: CALL_OW 72
62440: PUSH
62441: LD_VAR 0 2
62445: PPUSH
62446: LD_INT 2
62448: PUSH
62449: LD_INT 30
62451: PUSH
62452: LD_INT 4
62454: PUSH
62455: EMPTY
62456: LIST
62457: LIST
62458: PUSH
62459: LD_INT 30
62461: PUSH
62462: LD_INT 5
62464: PUSH
62465: EMPTY
62466: LIST
62467: LIST
62468: PUSH
62469: EMPTY
62470: LIST
62471: LIST
62472: LIST
62473: PPUSH
62474: CALL_OW 72
62478: ADD
62479: ST_TO_ADDR
62480: GO 62728
62482: LD_INT 2
62484: DOUBLE
62485: EQUAL
62486: IFTRUE 62496
62488: LD_INT 16
62490: DOUBLE
62491: EQUAL
62492: IFTRUE 62496
62494: GO 62542
62496: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
62497: LD_ADDR_VAR 0 8
62501: PUSH
62502: LD_VAR 0 2
62506: PPUSH
62507: LD_INT 2
62509: PUSH
62510: LD_INT 30
62512: PUSH
62513: LD_INT 0
62515: PUSH
62516: EMPTY
62517: LIST
62518: LIST
62519: PUSH
62520: LD_INT 30
62522: PUSH
62523: LD_INT 1
62525: PUSH
62526: EMPTY
62527: LIST
62528: LIST
62529: PUSH
62530: EMPTY
62531: LIST
62532: LIST
62533: LIST
62534: PPUSH
62535: CALL_OW 72
62539: ST_TO_ADDR
62540: GO 62728
62542: LD_INT 3
62544: DOUBLE
62545: EQUAL
62546: IFTRUE 62550
62548: GO 62596
62550: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
62551: LD_ADDR_VAR 0 8
62555: PUSH
62556: LD_VAR 0 2
62560: PPUSH
62561: LD_INT 2
62563: PUSH
62564: LD_INT 30
62566: PUSH
62567: LD_INT 2
62569: PUSH
62570: EMPTY
62571: LIST
62572: LIST
62573: PUSH
62574: LD_INT 30
62576: PUSH
62577: LD_INT 3
62579: PUSH
62580: EMPTY
62581: LIST
62582: LIST
62583: PUSH
62584: EMPTY
62585: LIST
62586: LIST
62587: LIST
62588: PPUSH
62589: CALL_OW 72
62593: ST_TO_ADDR
62594: GO 62728
62596: LD_INT 4
62598: DOUBLE
62599: EQUAL
62600: IFTRUE 62604
62602: GO 62661
62604: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
62605: LD_ADDR_VAR 0 8
62609: PUSH
62610: LD_VAR 0 2
62614: PPUSH
62615: LD_INT 2
62617: PUSH
62618: LD_INT 30
62620: PUSH
62621: LD_INT 6
62623: PUSH
62624: EMPTY
62625: LIST
62626: LIST
62627: PUSH
62628: LD_INT 30
62630: PUSH
62631: LD_INT 7
62633: PUSH
62634: EMPTY
62635: LIST
62636: LIST
62637: PUSH
62638: LD_INT 30
62640: PUSH
62641: LD_INT 8
62643: PUSH
62644: EMPTY
62645: LIST
62646: LIST
62647: PUSH
62648: EMPTY
62649: LIST
62650: LIST
62651: LIST
62652: LIST
62653: PPUSH
62654: CALL_OW 72
62658: ST_TO_ADDR
62659: GO 62728
62661: LD_INT 5
62663: DOUBLE
62664: EQUAL
62665: IFTRUE 62681
62667: LD_INT 8
62669: DOUBLE
62670: EQUAL
62671: IFTRUE 62681
62673: LD_INT 9
62675: DOUBLE
62676: EQUAL
62677: IFTRUE 62681
62679: GO 62727
62681: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
62682: LD_ADDR_VAR 0 8
62686: PUSH
62687: LD_VAR 0 2
62691: PPUSH
62692: LD_INT 2
62694: PUSH
62695: LD_INT 30
62697: PUSH
62698: LD_INT 4
62700: PUSH
62701: EMPTY
62702: LIST
62703: LIST
62704: PUSH
62705: LD_INT 30
62707: PUSH
62708: LD_INT 5
62710: PUSH
62711: EMPTY
62712: LIST
62713: LIST
62714: PUSH
62715: EMPTY
62716: LIST
62717: LIST
62718: LIST
62719: PPUSH
62720: CALL_OW 72
62724: ST_TO_ADDR
62725: GO 62728
62727: POP
// if not tmp then
62728: LD_VAR 0 8
62732: NOT
62733: IFFALSE 62737
// exit ;
62735: GO 63197
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
62737: LD_VAR 0 4
62741: PUSH
62742: LD_INT 1
62744: PUSH
62745: LD_INT 15
62747: PUSH
62748: EMPTY
62749: LIST
62750: LIST
62751: IN
62752: PUSH
62753: LD_EXP 111
62757: PUSH
62758: LD_VAR 0 1
62762: ARRAY
62763: AND
62764: IFFALSE 62920
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
62766: LD_ADDR_VAR 0 9
62770: PUSH
62771: LD_EXP 111
62775: PUSH
62776: LD_VAR 0 1
62780: ARRAY
62781: PUSH
62782: LD_INT 1
62784: ARRAY
62785: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
62786: LD_VAR 0 9
62790: PUSH
62791: LD_EXP 112
62795: PUSH
62796: LD_VAR 0 1
62800: ARRAY
62801: IN
62802: NOT
62803: IFFALSE 62918
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
62805: LD_ADDR_EXP 112
62809: PUSH
62810: LD_EXP 112
62814: PPUSH
62815: LD_VAR 0 1
62819: PUSH
62820: LD_EXP 112
62824: PUSH
62825: LD_VAR 0 1
62829: ARRAY
62830: PUSH
62831: LD_INT 1
62833: PLUS
62834: PUSH
62835: EMPTY
62836: LIST
62837: LIST
62838: PPUSH
62839: LD_VAR 0 9
62843: PPUSH
62844: CALL 75234 0 3
62848: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
62849: LD_ADDR_EXP 111
62853: PUSH
62854: LD_EXP 111
62858: PPUSH
62859: LD_VAR 0 1
62863: PPUSH
62864: LD_EXP 111
62868: PUSH
62869: LD_VAR 0 1
62873: ARRAY
62874: PUSH
62875: LD_VAR 0 9
62879: DIFF
62880: PPUSH
62881: CALL_OW 1
62885: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
62886: LD_VAR 0 3
62890: PPUSH
62891: LD_EXP 112
62895: PUSH
62896: LD_VAR 0 1
62900: ARRAY
62901: PUSH
62902: LD_EXP 112
62906: PUSH
62907: LD_VAR 0 1
62911: ARRAY
62912: ARRAY
62913: PPUSH
62914: CALL_OW 120
// end ; exit ;
62918: GO 63197
// end ; if tmp > 1 then
62920: LD_VAR 0 8
62924: PUSH
62925: LD_INT 1
62927: GREATER
62928: IFFALSE 63032
// for i = 2 to tmp do
62930: LD_ADDR_VAR 0 6
62934: PUSH
62935: DOUBLE
62936: LD_INT 2
62938: DEC
62939: ST_TO_ADDR
62940: LD_VAR 0 8
62944: PUSH
62945: FOR_TO
62946: IFFALSE 63030
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
62948: LD_VAR 0 8
62952: PUSH
62953: LD_VAR 0 6
62957: ARRAY
62958: PPUSH
62959: CALL_OW 461
62963: PUSH
62964: LD_INT 6
62966: EQUAL
62967: IFFALSE 63028
// begin x := tmp [ i ] ;
62969: LD_ADDR_VAR 0 9
62973: PUSH
62974: LD_VAR 0 8
62978: PUSH
62979: LD_VAR 0 6
62983: ARRAY
62984: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
62985: LD_ADDR_VAR 0 8
62989: PUSH
62990: LD_VAR 0 8
62994: PPUSH
62995: LD_VAR 0 6
62999: PPUSH
63000: CALL_OW 3
63004: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
63005: LD_ADDR_VAR 0 8
63009: PUSH
63010: LD_VAR 0 8
63014: PPUSH
63015: LD_INT 1
63017: PPUSH
63018: LD_VAR 0 9
63022: PPUSH
63023: CALL_OW 2
63027: ST_TO_ADDR
// end ;
63028: GO 62945
63030: POP
63031: POP
// for i in tmp do
63032: LD_ADDR_VAR 0 6
63036: PUSH
63037: LD_VAR 0 8
63041: PUSH
63042: FOR_IN
63043: IFFALSE 63070
// begin if IsNotFull ( i ) then
63045: LD_VAR 0 6
63049: PPUSH
63050: CALL 72456 0 1
63054: IFFALSE 63068
// begin j := i ;
63056: LD_ADDR_VAR 0 7
63060: PUSH
63061: LD_VAR 0 6
63065: ST_TO_ADDR
// break ;
63066: GO 63070
// end ; end ;
63068: GO 63042
63070: POP
63071: POP
// if j then
63072: LD_VAR 0 7
63076: IFFALSE 63094
// ComEnterUnit ( unit , j ) else
63078: LD_VAR 0 3
63082: PPUSH
63083: LD_VAR 0 7
63087: PPUSH
63088: CALL_OW 120
63092: GO 63197
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63094: LD_ADDR_VAR 0 10
63098: PUSH
63099: LD_VAR 0 2
63103: PPUSH
63104: LD_INT 2
63106: PUSH
63107: LD_INT 30
63109: PUSH
63110: LD_INT 0
63112: PUSH
63113: EMPTY
63114: LIST
63115: LIST
63116: PUSH
63117: LD_INT 30
63119: PUSH
63120: LD_INT 1
63122: PUSH
63123: EMPTY
63124: LIST
63125: LIST
63126: PUSH
63127: EMPTY
63128: LIST
63129: LIST
63130: LIST
63131: PPUSH
63132: CALL_OW 72
63136: ST_TO_ADDR
// if depot then
63137: LD_VAR 0 10
63141: IFFALSE 63197
// begin depot := NearestUnitToUnit ( depot , unit ) ;
63143: LD_ADDR_VAR 0 10
63147: PUSH
63148: LD_VAR 0 10
63152: PPUSH
63153: LD_VAR 0 3
63157: PPUSH
63158: CALL_OW 74
63162: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
63163: LD_VAR 0 3
63167: PPUSH
63168: LD_VAR 0 10
63172: PPUSH
63173: CALL_OW 296
63177: PUSH
63178: LD_INT 10
63180: GREATER
63181: IFFALSE 63197
// ComStandNearbyBuilding ( unit , depot ) ;
63183: LD_VAR 0 3
63187: PPUSH
63188: LD_VAR 0 10
63192: PPUSH
63193: CALL 71836 0 2
// end ; end ; end ;
63197: LD_VAR 0 5
63201: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
63202: LD_INT 0
63204: PPUSH
63205: PPUSH
63206: PPUSH
63207: PPUSH
// if not mc_bases then
63208: LD_EXP 102
63212: NOT
63213: IFFALSE 63217
// exit ;
63215: GO 63456
// for i = 1 to mc_bases do
63217: LD_ADDR_VAR 0 2
63221: PUSH
63222: DOUBLE
63223: LD_INT 1
63225: DEC
63226: ST_TO_ADDR
63227: LD_EXP 102
63231: PUSH
63232: FOR_TO
63233: IFFALSE 63454
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
63235: LD_ADDR_VAR 0 4
63239: PUSH
63240: LD_EXP 102
63244: PUSH
63245: LD_VAR 0 2
63249: ARRAY
63250: PPUSH
63251: LD_INT 21
63253: PUSH
63254: LD_INT 1
63256: PUSH
63257: EMPTY
63258: LIST
63259: LIST
63260: PPUSH
63261: CALL_OW 72
63265: PUSH
63266: LD_EXP 131
63270: PUSH
63271: LD_VAR 0 2
63275: ARRAY
63276: UNION
63277: ST_TO_ADDR
// if not tmp then
63278: LD_VAR 0 4
63282: NOT
63283: IFFALSE 63287
// continue ;
63285: GO 63232
// for j in tmp do
63287: LD_ADDR_VAR 0 3
63291: PUSH
63292: LD_VAR 0 4
63296: PUSH
63297: FOR_IN
63298: IFFALSE 63450
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
63300: LD_VAR 0 3
63304: PPUSH
63305: CALL_OW 110
63309: NOT
63310: PUSH
63311: LD_VAR 0 3
63315: PPUSH
63316: CALL_OW 314
63320: NOT
63321: AND
63322: PUSH
63323: LD_VAR 0 3
63327: PPUSH
63328: CALL_OW 311
63332: NOT
63333: AND
63334: PUSH
63335: LD_VAR 0 3
63339: PPUSH
63340: CALL_OW 310
63344: NOT
63345: AND
63346: PUSH
63347: LD_VAR 0 3
63351: PUSH
63352: LD_EXP 105
63356: PUSH
63357: LD_VAR 0 2
63361: ARRAY
63362: PUSH
63363: LD_INT 1
63365: ARRAY
63366: IN
63367: NOT
63368: AND
63369: PUSH
63370: LD_VAR 0 3
63374: PUSH
63375: LD_EXP 105
63379: PUSH
63380: LD_VAR 0 2
63384: ARRAY
63385: PUSH
63386: LD_INT 2
63388: ARRAY
63389: IN
63390: NOT
63391: AND
63392: PUSH
63393: LD_VAR 0 3
63397: PUSH
63398: LD_EXP 114
63402: PUSH
63403: LD_VAR 0 2
63407: ARRAY
63408: IN
63409: NOT
63410: AND
63411: IFFALSE 63448
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
63413: LD_VAR 0 2
63417: PPUSH
63418: LD_EXP 102
63422: PUSH
63423: LD_VAR 0 2
63427: ARRAY
63428: PPUSH
63429: LD_VAR 0 3
63433: PPUSH
63434: LD_VAR 0 3
63438: PPUSH
63439: CALL_OW 257
63443: PPUSH
63444: CALL 62262 0 4
// end ;
63448: GO 63297
63450: POP
63451: POP
// end ;
63452: GO 63232
63454: POP
63455: POP
// end ;
63456: LD_VAR 0 1
63460: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
63461: LD_INT 0
63463: PPUSH
63464: PPUSH
63465: PPUSH
63466: PPUSH
63467: PPUSH
63468: PPUSH
// if not mc_bases [ base ] then
63469: LD_EXP 102
63473: PUSH
63474: LD_VAR 0 1
63478: ARRAY
63479: NOT
63480: IFFALSE 63484
// exit ;
63482: GO 63685
// tmp := [ ] ;
63484: LD_ADDR_VAR 0 6
63488: PUSH
63489: EMPTY
63490: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
63491: LD_ADDR_VAR 0 7
63495: PUSH
63496: LD_VAR 0 3
63500: PPUSH
63501: LD_INT 0
63503: PPUSH
63504: CALL_OW 517
63508: ST_TO_ADDR
// if not list then
63509: LD_VAR 0 7
63513: NOT
63514: IFFALSE 63518
// exit ;
63516: GO 63685
// c := Count ( list [ 1 ] ) ;
63518: LD_ADDR_VAR 0 9
63522: PUSH
63523: LD_VAR 0 7
63527: PUSH
63528: LD_INT 1
63530: ARRAY
63531: PPUSH
63532: CALL 72374 0 1
63536: ST_TO_ADDR
// if amount > c then
63537: LD_VAR 0 2
63541: PUSH
63542: LD_VAR 0 9
63546: GREATER
63547: IFFALSE 63559
// amount := c ;
63549: LD_ADDR_VAR 0 2
63553: PUSH
63554: LD_VAR 0 9
63558: ST_TO_ADDR
// for i := 1 to amount do
63559: LD_ADDR_VAR 0 5
63563: PUSH
63564: DOUBLE
63565: LD_INT 1
63567: DEC
63568: ST_TO_ADDR
63569: LD_VAR 0 2
63573: PUSH
63574: FOR_TO
63575: IFFALSE 63633
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
63577: LD_ADDR_VAR 0 6
63581: PUSH
63582: LD_VAR 0 6
63586: PPUSH
63587: LD_VAR 0 5
63591: PPUSH
63592: LD_VAR 0 7
63596: PUSH
63597: LD_INT 1
63599: ARRAY
63600: PUSH
63601: LD_VAR 0 5
63605: ARRAY
63606: PUSH
63607: LD_VAR 0 7
63611: PUSH
63612: LD_INT 2
63614: ARRAY
63615: PUSH
63616: LD_VAR 0 5
63620: ARRAY
63621: PUSH
63622: EMPTY
63623: LIST
63624: LIST
63625: PPUSH
63626: CALL_OW 1
63630: ST_TO_ADDR
63631: GO 63574
63633: POP
63634: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
63635: LD_ADDR_EXP 115
63639: PUSH
63640: LD_EXP 115
63644: PPUSH
63645: LD_VAR 0 1
63649: PPUSH
63650: LD_VAR 0 6
63654: PPUSH
63655: CALL_OW 1
63659: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
63660: LD_ADDR_EXP 117
63664: PUSH
63665: LD_EXP 117
63669: PPUSH
63670: LD_VAR 0 1
63674: PPUSH
63675: LD_VAR 0 3
63679: PPUSH
63680: CALL_OW 1
63684: ST_TO_ADDR
// end ;
63685: LD_VAR 0 4
63689: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
63690: LD_INT 0
63692: PPUSH
// if not mc_bases [ base ] then
63693: LD_EXP 102
63697: PUSH
63698: LD_VAR 0 1
63702: ARRAY
63703: NOT
63704: IFFALSE 63708
// exit ;
63706: GO 63733
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
63708: LD_ADDR_EXP 107
63712: PUSH
63713: LD_EXP 107
63717: PPUSH
63718: LD_VAR 0 1
63722: PPUSH
63723: LD_VAR 0 2
63727: PPUSH
63728: CALL_OW 1
63732: ST_TO_ADDR
// end ;
63733: LD_VAR 0 3
63737: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
63738: LD_INT 0
63740: PPUSH
// if not mc_bases [ base ] then
63741: LD_EXP 102
63745: PUSH
63746: LD_VAR 0 1
63750: ARRAY
63751: NOT
63752: IFFALSE 63756
// exit ;
63754: GO 63793
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
63756: LD_ADDR_EXP 107
63760: PUSH
63761: LD_EXP 107
63765: PPUSH
63766: LD_VAR 0 1
63770: PPUSH
63771: LD_EXP 107
63775: PUSH
63776: LD_VAR 0 1
63780: ARRAY
63781: PUSH
63782: LD_VAR 0 2
63786: UNION
63787: PPUSH
63788: CALL_OW 1
63792: ST_TO_ADDR
// end ;
63793: LD_VAR 0 3
63797: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
63798: LD_INT 0
63800: PPUSH
// if not mc_bases [ base ] then
63801: LD_EXP 102
63805: PUSH
63806: LD_VAR 0 1
63810: ARRAY
63811: NOT
63812: IFFALSE 63816
// exit ;
63814: GO 63841
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
63816: LD_ADDR_EXP 123
63820: PUSH
63821: LD_EXP 123
63825: PPUSH
63826: LD_VAR 0 1
63830: PPUSH
63831: LD_VAR 0 2
63835: PPUSH
63836: CALL_OW 1
63840: ST_TO_ADDR
// end ;
63841: LD_VAR 0 3
63845: RET
// export function MC_InsertProduceList ( base , components ) ; begin
63846: LD_INT 0
63848: PPUSH
// if not mc_bases [ base ] then
63849: LD_EXP 102
63853: PUSH
63854: LD_VAR 0 1
63858: ARRAY
63859: NOT
63860: IFFALSE 63864
// exit ;
63862: GO 63901
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
63864: LD_ADDR_EXP 123
63868: PUSH
63869: LD_EXP 123
63873: PPUSH
63874: LD_VAR 0 1
63878: PPUSH
63879: LD_EXP 123
63883: PUSH
63884: LD_VAR 0 1
63888: ARRAY
63889: PUSH
63890: LD_VAR 0 2
63894: ADD
63895: PPUSH
63896: CALL_OW 1
63900: ST_TO_ADDR
// end ;
63901: LD_VAR 0 3
63905: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
63906: LD_INT 0
63908: PPUSH
// if not mc_bases [ base ] then
63909: LD_EXP 102
63913: PUSH
63914: LD_VAR 0 1
63918: ARRAY
63919: NOT
63920: IFFALSE 63924
// exit ;
63922: GO 63978
// mc_defender := Replace ( mc_defender , base , deflist ) ;
63924: LD_ADDR_EXP 124
63928: PUSH
63929: LD_EXP 124
63933: PPUSH
63934: LD_VAR 0 1
63938: PPUSH
63939: LD_VAR 0 2
63943: PPUSH
63944: CALL_OW 1
63948: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
63949: LD_ADDR_EXP 113
63953: PUSH
63954: LD_EXP 113
63958: PPUSH
63959: LD_VAR 0 1
63963: PPUSH
63964: LD_VAR 0 2
63968: PUSH
63969: LD_INT 0
63971: PLUS
63972: PPUSH
63973: CALL_OW 1
63977: ST_TO_ADDR
// end ;
63978: LD_VAR 0 3
63982: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
63983: LD_INT 0
63985: PPUSH
// if not mc_bases [ base ] then
63986: LD_EXP 102
63990: PUSH
63991: LD_VAR 0 1
63995: ARRAY
63996: NOT
63997: IFFALSE 64001
// exit ;
63999: GO 64026
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
64001: LD_ADDR_EXP 113
64005: PUSH
64006: LD_EXP 113
64010: PPUSH
64011: LD_VAR 0 1
64015: PPUSH
64016: LD_VAR 0 2
64020: PPUSH
64021: CALL_OW 1
64025: ST_TO_ADDR
// end ;
64026: LD_VAR 0 3
64030: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
64031: LD_INT 0
64033: PPUSH
64034: PPUSH
64035: PPUSH
64036: PPUSH
// if not mc_bases [ base ] then
64037: LD_EXP 102
64041: PUSH
64042: LD_VAR 0 1
64046: ARRAY
64047: NOT
64048: IFFALSE 64052
// exit ;
64050: GO 64117
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
64052: LD_ADDR_EXP 122
64056: PUSH
64057: LD_EXP 122
64061: PPUSH
64062: LD_VAR 0 1
64066: PUSH
64067: LD_EXP 122
64071: PUSH
64072: LD_VAR 0 1
64076: ARRAY
64077: PUSH
64078: LD_INT 1
64080: PLUS
64081: PUSH
64082: EMPTY
64083: LIST
64084: LIST
64085: PPUSH
64086: LD_VAR 0 1
64090: PUSH
64091: LD_VAR 0 2
64095: PUSH
64096: LD_VAR 0 3
64100: PUSH
64101: LD_VAR 0 4
64105: PUSH
64106: EMPTY
64107: LIST
64108: LIST
64109: LIST
64110: LIST
64111: PPUSH
64112: CALL 75234 0 3
64116: ST_TO_ADDR
// end ;
64117: LD_VAR 0 5
64121: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
64122: LD_INT 0
64124: PPUSH
// if not mc_bases [ base ] then
64125: LD_EXP 102
64129: PUSH
64130: LD_VAR 0 1
64134: ARRAY
64135: NOT
64136: IFFALSE 64140
// exit ;
64138: GO 64165
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
64140: LD_ADDR_EXP 139
64144: PUSH
64145: LD_EXP 139
64149: PPUSH
64150: LD_VAR 0 1
64154: PPUSH
64155: LD_VAR 0 2
64159: PPUSH
64160: CALL_OW 1
64164: ST_TO_ADDR
// end ;
64165: LD_VAR 0 3
64169: RET
// export function MC_GetMinesField ( base ) ; begin
64170: LD_INT 0
64172: PPUSH
// result := mc_mines [ base ] ;
64173: LD_ADDR_VAR 0 2
64177: PUSH
64178: LD_EXP 115
64182: PUSH
64183: LD_VAR 0 1
64187: ARRAY
64188: ST_TO_ADDR
// end ;
64189: LD_VAR 0 2
64193: RET
// export function MC_GetProduceList ( base ) ; begin
64194: LD_INT 0
64196: PPUSH
// result := mc_produce [ base ] ;
64197: LD_ADDR_VAR 0 2
64201: PUSH
64202: LD_EXP 123
64206: PUSH
64207: LD_VAR 0 1
64211: ARRAY
64212: ST_TO_ADDR
// end ;
64213: LD_VAR 0 2
64217: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
64218: LD_INT 0
64220: PPUSH
64221: PPUSH
// if not mc_bases then
64222: LD_EXP 102
64226: NOT
64227: IFFALSE 64231
// exit ;
64229: GO 64296
// if mc_bases [ base ] then
64231: LD_EXP 102
64235: PUSH
64236: LD_VAR 0 1
64240: ARRAY
64241: IFFALSE 64296
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
64243: LD_ADDR_VAR 0 3
64247: PUSH
64248: LD_EXP 102
64252: PUSH
64253: LD_VAR 0 1
64257: ARRAY
64258: PPUSH
64259: LD_INT 30
64261: PUSH
64262: LD_VAR 0 2
64266: PUSH
64267: EMPTY
64268: LIST
64269: LIST
64270: PPUSH
64271: CALL_OW 72
64275: ST_TO_ADDR
// if result then
64276: LD_VAR 0 3
64280: IFFALSE 64296
// result := result [ 1 ] ;
64282: LD_ADDR_VAR 0 3
64286: PUSH
64287: LD_VAR 0 3
64291: PUSH
64292: LD_INT 1
64294: ARRAY
64295: ST_TO_ADDR
// end ; end ;
64296: LD_VAR 0 3
64300: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
64301: LD_INT 0
64303: PPUSH
64304: PPUSH
// if not mc_bases then
64305: LD_EXP 102
64309: NOT
64310: IFFALSE 64314
// exit ;
64312: GO 64359
// if mc_bases [ base ] then
64314: LD_EXP 102
64318: PUSH
64319: LD_VAR 0 1
64323: ARRAY
64324: IFFALSE 64359
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
64326: LD_ADDR_VAR 0 3
64330: PUSH
64331: LD_EXP 102
64335: PUSH
64336: LD_VAR 0 1
64340: ARRAY
64341: PPUSH
64342: LD_INT 30
64344: PUSH
64345: LD_VAR 0 2
64349: PUSH
64350: EMPTY
64351: LIST
64352: LIST
64353: PPUSH
64354: CALL_OW 72
64358: ST_TO_ADDR
// end ;
64359: LD_VAR 0 3
64363: RET
// export function MC_SetTame ( base , area ) ; begin
64364: LD_INT 0
64366: PPUSH
// if not mc_bases or not base then
64367: LD_EXP 102
64371: NOT
64372: PUSH
64373: LD_VAR 0 1
64377: NOT
64378: OR
64379: IFFALSE 64383
// exit ;
64381: GO 64408
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
64383: LD_ADDR_EXP 130
64387: PUSH
64388: LD_EXP 130
64392: PPUSH
64393: LD_VAR 0 1
64397: PPUSH
64398: LD_VAR 0 2
64402: PPUSH
64403: CALL_OW 1
64407: ST_TO_ADDR
// end ;
64408: LD_VAR 0 3
64412: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
64413: LD_INT 0
64415: PPUSH
64416: PPUSH
// if not mc_bases or not base then
64417: LD_EXP 102
64421: NOT
64422: PUSH
64423: LD_VAR 0 1
64427: NOT
64428: OR
64429: IFFALSE 64433
// exit ;
64431: GO 64535
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
64433: LD_ADDR_VAR 0 4
64437: PUSH
64438: LD_EXP 102
64442: PUSH
64443: LD_VAR 0 1
64447: ARRAY
64448: PPUSH
64449: LD_INT 30
64451: PUSH
64452: LD_VAR 0 2
64456: PUSH
64457: EMPTY
64458: LIST
64459: LIST
64460: PPUSH
64461: CALL_OW 72
64465: ST_TO_ADDR
// if not tmp then
64466: LD_VAR 0 4
64470: NOT
64471: IFFALSE 64475
// exit ;
64473: GO 64535
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
64475: LD_ADDR_EXP 134
64479: PUSH
64480: LD_EXP 134
64484: PPUSH
64485: LD_VAR 0 1
64489: PPUSH
64490: LD_EXP 134
64494: PUSH
64495: LD_VAR 0 1
64499: ARRAY
64500: PPUSH
64501: LD_EXP 134
64505: PUSH
64506: LD_VAR 0 1
64510: ARRAY
64511: PUSH
64512: LD_INT 1
64514: PLUS
64515: PPUSH
64516: LD_VAR 0 4
64520: PUSH
64521: LD_INT 1
64523: ARRAY
64524: PPUSH
64525: CALL_OW 2
64529: PPUSH
64530: CALL_OW 1
64534: ST_TO_ADDR
// end ;
64535: LD_VAR 0 3
64539: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
64540: LD_INT 0
64542: PPUSH
64543: PPUSH
// if not mc_bases or not base or not kinds then
64544: LD_EXP 102
64548: NOT
64549: PUSH
64550: LD_VAR 0 1
64554: NOT
64555: OR
64556: PUSH
64557: LD_VAR 0 2
64561: NOT
64562: OR
64563: IFFALSE 64567
// exit ;
64565: GO 64628
// for i in kinds do
64567: LD_ADDR_VAR 0 4
64571: PUSH
64572: LD_VAR 0 2
64576: PUSH
64577: FOR_IN
64578: IFFALSE 64626
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
64580: LD_ADDR_EXP 136
64584: PUSH
64585: LD_EXP 136
64589: PPUSH
64590: LD_VAR 0 1
64594: PUSH
64595: LD_EXP 136
64599: PUSH
64600: LD_VAR 0 1
64604: ARRAY
64605: PUSH
64606: LD_INT 1
64608: PLUS
64609: PUSH
64610: EMPTY
64611: LIST
64612: LIST
64613: PPUSH
64614: LD_VAR 0 4
64618: PPUSH
64619: CALL 75234 0 3
64623: ST_TO_ADDR
64624: GO 64577
64626: POP
64627: POP
// end ;
64628: LD_VAR 0 3
64632: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
64633: LD_INT 0
64635: PPUSH
// if not mc_bases or not base or not areas then
64636: LD_EXP 102
64640: NOT
64641: PUSH
64642: LD_VAR 0 1
64646: NOT
64647: OR
64648: PUSH
64649: LD_VAR 0 2
64653: NOT
64654: OR
64655: IFFALSE 64659
// exit ;
64657: GO 64684
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
64659: LD_ADDR_EXP 120
64663: PUSH
64664: LD_EXP 120
64668: PPUSH
64669: LD_VAR 0 1
64673: PPUSH
64674: LD_VAR 0 2
64678: PPUSH
64679: CALL_OW 1
64683: ST_TO_ADDR
// end ;
64684: LD_VAR 0 3
64688: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
64689: LD_INT 0
64691: PPUSH
// if not mc_bases or not base or not teleports_exit then
64692: LD_EXP 102
64696: NOT
64697: PUSH
64698: LD_VAR 0 1
64702: NOT
64703: OR
64704: PUSH
64705: LD_VAR 0 2
64709: NOT
64710: OR
64711: IFFALSE 64715
// exit ;
64713: GO 64740
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
64715: LD_ADDR_EXP 137
64719: PUSH
64720: LD_EXP 137
64724: PPUSH
64725: LD_VAR 0 1
64729: PPUSH
64730: LD_VAR 0 2
64734: PPUSH
64735: CALL_OW 1
64739: ST_TO_ADDR
// end ;
64740: LD_VAR 0 3
64744: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
64745: LD_INT 0
64747: PPUSH
64748: PPUSH
64749: PPUSH
// if not mc_bases or not base or not ext_list then
64750: LD_EXP 102
64754: NOT
64755: PUSH
64756: LD_VAR 0 1
64760: NOT
64761: OR
64762: PUSH
64763: LD_VAR 0 5
64767: NOT
64768: OR
64769: IFFALSE 64773
// exit ;
64771: GO 64946
// tmp := GetFacExtXYD ( x , y , d ) ;
64773: LD_ADDR_VAR 0 8
64777: PUSH
64778: LD_VAR 0 2
64782: PPUSH
64783: LD_VAR 0 3
64787: PPUSH
64788: LD_VAR 0 4
64792: PPUSH
64793: CALL 105597 0 3
64797: ST_TO_ADDR
// if not tmp then
64798: LD_VAR 0 8
64802: NOT
64803: IFFALSE 64807
// exit ;
64805: GO 64946
// for i in tmp do
64807: LD_ADDR_VAR 0 7
64811: PUSH
64812: LD_VAR 0 8
64816: PUSH
64817: FOR_IN
64818: IFFALSE 64944
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
64820: LD_ADDR_EXP 107
64824: PUSH
64825: LD_EXP 107
64829: PPUSH
64830: LD_VAR 0 1
64834: PPUSH
64835: LD_EXP 107
64839: PUSH
64840: LD_VAR 0 1
64844: ARRAY
64845: PPUSH
64846: LD_EXP 107
64850: PUSH
64851: LD_VAR 0 1
64855: ARRAY
64856: PUSH
64857: LD_INT 1
64859: PLUS
64860: PPUSH
64861: LD_VAR 0 5
64865: PUSH
64866: LD_INT 1
64868: ARRAY
64869: PUSH
64870: LD_VAR 0 7
64874: PUSH
64875: LD_INT 1
64877: ARRAY
64878: PUSH
64879: LD_VAR 0 7
64883: PUSH
64884: LD_INT 2
64886: ARRAY
64887: PUSH
64888: LD_VAR 0 7
64892: PUSH
64893: LD_INT 3
64895: ARRAY
64896: PUSH
64897: EMPTY
64898: LIST
64899: LIST
64900: LIST
64901: LIST
64902: PPUSH
64903: CALL_OW 2
64907: PPUSH
64908: CALL_OW 1
64912: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
64913: LD_ADDR_VAR 0 5
64917: PUSH
64918: LD_VAR 0 5
64922: PPUSH
64923: LD_INT 1
64925: PPUSH
64926: CALL_OW 3
64930: ST_TO_ADDR
// if not ext_list then
64931: LD_VAR 0 5
64935: NOT
64936: IFFALSE 64942
// exit ;
64938: POP
64939: POP
64940: GO 64946
// end ;
64942: GO 64817
64944: POP
64945: POP
// end ;
64946: LD_VAR 0 6
64950: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
64951: LD_INT 0
64953: PPUSH
// if not mc_bases or not base or not weapon_list then
64954: LD_EXP 102
64958: NOT
64959: PUSH
64960: LD_VAR 0 1
64964: NOT
64965: OR
64966: PUSH
64967: LD_VAR 0 2
64971: NOT
64972: OR
64973: IFFALSE 64977
// exit ;
64975: GO 65002
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
64977: LD_ADDR_EXP 141
64981: PUSH
64982: LD_EXP 141
64986: PPUSH
64987: LD_VAR 0 1
64991: PPUSH
64992: LD_VAR 0 2
64996: PPUSH
64997: CALL_OW 1
65001: ST_TO_ADDR
// end ;
65002: LD_VAR 0 3
65006: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
65007: LD_INT 0
65009: PPUSH
// if not mc_bases or not base or not tech_list then
65010: LD_EXP 102
65014: NOT
65015: PUSH
65016: LD_VAR 0 1
65020: NOT
65021: OR
65022: PUSH
65023: LD_VAR 0 2
65027: NOT
65028: OR
65029: IFFALSE 65033
// exit ;
65031: GO 65058
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
65033: LD_ADDR_EXP 129
65037: PUSH
65038: LD_EXP 129
65042: PPUSH
65043: LD_VAR 0 1
65047: PPUSH
65048: LD_VAR 0 2
65052: PPUSH
65053: CALL_OW 1
65057: ST_TO_ADDR
// end ;
65058: LD_VAR 0 3
65062: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
65063: LD_INT 0
65065: PPUSH
// if not mc_bases or not parking_area or not base then
65066: LD_EXP 102
65070: NOT
65071: PUSH
65072: LD_VAR 0 2
65076: NOT
65077: OR
65078: PUSH
65079: LD_VAR 0 1
65083: NOT
65084: OR
65085: IFFALSE 65089
// exit ;
65087: GO 65114
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
65089: LD_ADDR_EXP 126
65093: PUSH
65094: LD_EXP 126
65098: PPUSH
65099: LD_VAR 0 1
65103: PPUSH
65104: LD_VAR 0 2
65108: PPUSH
65109: CALL_OW 1
65113: ST_TO_ADDR
// end ;
65114: LD_VAR 0 3
65118: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
65119: LD_INT 0
65121: PPUSH
// if not mc_bases or not base or not scan_area then
65122: LD_EXP 102
65126: NOT
65127: PUSH
65128: LD_VAR 0 1
65132: NOT
65133: OR
65134: PUSH
65135: LD_VAR 0 2
65139: NOT
65140: OR
65141: IFFALSE 65145
// exit ;
65143: GO 65170
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
65145: LD_ADDR_EXP 127
65149: PUSH
65150: LD_EXP 127
65154: PPUSH
65155: LD_VAR 0 1
65159: PPUSH
65160: LD_VAR 0 2
65164: PPUSH
65165: CALL_OW 1
65169: ST_TO_ADDR
// end ;
65170: LD_VAR 0 3
65174: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
65175: LD_INT 0
65177: PPUSH
65178: PPUSH
// if not mc_bases or not base then
65179: LD_EXP 102
65183: NOT
65184: PUSH
65185: LD_VAR 0 1
65189: NOT
65190: OR
65191: IFFALSE 65195
// exit ;
65193: GO 65259
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
65195: LD_ADDR_VAR 0 3
65199: PUSH
65200: LD_INT 1
65202: PUSH
65203: LD_INT 2
65205: PUSH
65206: LD_INT 3
65208: PUSH
65209: LD_INT 4
65211: PUSH
65212: LD_INT 11
65214: PUSH
65215: EMPTY
65216: LIST
65217: LIST
65218: LIST
65219: LIST
65220: LIST
65221: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
65222: LD_ADDR_EXP 129
65226: PUSH
65227: LD_EXP 129
65231: PPUSH
65232: LD_VAR 0 1
65236: PPUSH
65237: LD_EXP 129
65241: PUSH
65242: LD_VAR 0 1
65246: ARRAY
65247: PUSH
65248: LD_VAR 0 3
65252: DIFF
65253: PPUSH
65254: CALL_OW 1
65258: ST_TO_ADDR
// end ;
65259: LD_VAR 0 2
65263: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
65264: LD_INT 0
65266: PPUSH
// result := mc_vehicles [ base ] ;
65267: LD_ADDR_VAR 0 3
65271: PUSH
65272: LD_EXP 121
65276: PUSH
65277: LD_VAR 0 1
65281: ARRAY
65282: ST_TO_ADDR
// if onlyCombat then
65283: LD_VAR 0 2
65287: IFFALSE 65459
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
65289: LD_ADDR_VAR 0 3
65293: PUSH
65294: LD_VAR 0 3
65298: PUSH
65299: LD_VAR 0 3
65303: PPUSH
65304: LD_INT 2
65306: PUSH
65307: LD_INT 34
65309: PUSH
65310: LD_INT 12
65312: PUSH
65313: EMPTY
65314: LIST
65315: LIST
65316: PUSH
65317: LD_INT 34
65319: PUSH
65320: LD_INT 51
65322: PUSH
65323: EMPTY
65324: LIST
65325: LIST
65326: PUSH
65327: LD_INT 34
65329: PUSH
65330: LD_INT 89
65332: PUSH
65333: EMPTY
65334: LIST
65335: LIST
65336: PUSH
65337: LD_INT 34
65339: PUSH
65340: LD_INT 32
65342: PUSH
65343: EMPTY
65344: LIST
65345: LIST
65346: PUSH
65347: LD_INT 34
65349: PUSH
65350: LD_INT 13
65352: PUSH
65353: EMPTY
65354: LIST
65355: LIST
65356: PUSH
65357: LD_INT 34
65359: PUSH
65360: LD_INT 52
65362: PUSH
65363: EMPTY
65364: LIST
65365: LIST
65366: PUSH
65367: LD_INT 34
65369: PUSH
65370: LD_INT 88
65372: PUSH
65373: EMPTY
65374: LIST
65375: LIST
65376: PUSH
65377: LD_INT 34
65379: PUSH
65380: LD_INT 14
65382: PUSH
65383: EMPTY
65384: LIST
65385: LIST
65386: PUSH
65387: LD_INT 34
65389: PUSH
65390: LD_INT 53
65392: PUSH
65393: EMPTY
65394: LIST
65395: LIST
65396: PUSH
65397: LD_INT 34
65399: PUSH
65400: LD_INT 98
65402: PUSH
65403: EMPTY
65404: LIST
65405: LIST
65406: PUSH
65407: LD_INT 34
65409: PUSH
65410: LD_INT 31
65412: PUSH
65413: EMPTY
65414: LIST
65415: LIST
65416: PUSH
65417: LD_INT 34
65419: PUSH
65420: LD_INT 48
65422: PUSH
65423: EMPTY
65424: LIST
65425: LIST
65426: PUSH
65427: LD_INT 34
65429: PUSH
65430: LD_INT 8
65432: PUSH
65433: EMPTY
65434: LIST
65435: LIST
65436: PUSH
65437: EMPTY
65438: LIST
65439: LIST
65440: LIST
65441: LIST
65442: LIST
65443: LIST
65444: LIST
65445: LIST
65446: LIST
65447: LIST
65448: LIST
65449: LIST
65450: LIST
65451: LIST
65452: PPUSH
65453: CALL_OW 72
65457: DIFF
65458: ST_TO_ADDR
// end ; end_of_file
65459: LD_VAR 0 3
65463: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
65464: LD_INT 0
65466: PPUSH
65467: PPUSH
65468: PPUSH
// if not mc_bases or not skirmish then
65469: LD_EXP 102
65473: NOT
65474: PUSH
65475: LD_EXP 100
65479: NOT
65480: OR
65481: IFFALSE 65485
// exit ;
65483: GO 65650
// for i = 1 to mc_bases do
65485: LD_ADDR_VAR 0 4
65489: PUSH
65490: DOUBLE
65491: LD_INT 1
65493: DEC
65494: ST_TO_ADDR
65495: LD_EXP 102
65499: PUSH
65500: FOR_TO
65501: IFFALSE 65648
// begin if sci in mc_bases [ i ] then
65503: LD_VAR 0 2
65507: PUSH
65508: LD_EXP 102
65512: PUSH
65513: LD_VAR 0 4
65517: ARRAY
65518: IN
65519: IFFALSE 65646
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
65521: LD_ADDR_EXP 131
65525: PUSH
65526: LD_EXP 131
65530: PPUSH
65531: LD_VAR 0 4
65535: PUSH
65536: LD_EXP 131
65540: PUSH
65541: LD_VAR 0 4
65545: ARRAY
65546: PUSH
65547: LD_INT 1
65549: PLUS
65550: PUSH
65551: EMPTY
65552: LIST
65553: LIST
65554: PPUSH
65555: LD_VAR 0 1
65559: PPUSH
65560: CALL 75234 0 3
65564: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
65565: LD_ADDR_VAR 0 5
65569: PUSH
65570: LD_EXP 102
65574: PUSH
65575: LD_VAR 0 4
65579: ARRAY
65580: PPUSH
65581: LD_INT 2
65583: PUSH
65584: LD_INT 30
65586: PUSH
65587: LD_INT 0
65589: PUSH
65590: EMPTY
65591: LIST
65592: LIST
65593: PUSH
65594: LD_INT 30
65596: PUSH
65597: LD_INT 1
65599: PUSH
65600: EMPTY
65601: LIST
65602: LIST
65603: PUSH
65604: EMPTY
65605: LIST
65606: LIST
65607: LIST
65608: PPUSH
65609: CALL_OW 72
65613: PPUSH
65614: LD_VAR 0 1
65618: PPUSH
65619: CALL_OW 74
65623: ST_TO_ADDR
// if tmp then
65624: LD_VAR 0 5
65628: IFFALSE 65644
// ComStandNearbyBuilding ( ape , tmp ) ;
65630: LD_VAR 0 1
65634: PPUSH
65635: LD_VAR 0 5
65639: PPUSH
65640: CALL 71836 0 2
// break ;
65644: GO 65648
// end ; end ;
65646: GO 65500
65648: POP
65649: POP
// end ;
65650: LD_VAR 0 3
65654: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
65655: LD_INT 0
65657: PPUSH
65658: PPUSH
65659: PPUSH
// if not mc_bases or not skirmish then
65660: LD_EXP 102
65664: NOT
65665: PUSH
65666: LD_EXP 100
65670: NOT
65671: OR
65672: IFFALSE 65676
// exit ;
65674: GO 65765
// for i = 1 to mc_bases do
65676: LD_ADDR_VAR 0 4
65680: PUSH
65681: DOUBLE
65682: LD_INT 1
65684: DEC
65685: ST_TO_ADDR
65686: LD_EXP 102
65690: PUSH
65691: FOR_TO
65692: IFFALSE 65763
// begin if building in mc_busy_turret_list [ i ] then
65694: LD_VAR 0 1
65698: PUSH
65699: LD_EXP 112
65703: PUSH
65704: LD_VAR 0 4
65708: ARRAY
65709: IN
65710: IFFALSE 65761
// begin tmp := mc_busy_turret_list [ i ] diff building ;
65712: LD_ADDR_VAR 0 5
65716: PUSH
65717: LD_EXP 112
65721: PUSH
65722: LD_VAR 0 4
65726: ARRAY
65727: PUSH
65728: LD_VAR 0 1
65732: DIFF
65733: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
65734: LD_ADDR_EXP 112
65738: PUSH
65739: LD_EXP 112
65743: PPUSH
65744: LD_VAR 0 4
65748: PPUSH
65749: LD_VAR 0 5
65753: PPUSH
65754: CALL_OW 1
65758: ST_TO_ADDR
// break ;
65759: GO 65763
// end ; end ;
65761: GO 65691
65763: POP
65764: POP
// end ;
65765: LD_VAR 0 3
65769: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
65770: LD_INT 0
65772: PPUSH
65773: PPUSH
65774: PPUSH
// if not mc_bases or not skirmish then
65775: LD_EXP 102
65779: NOT
65780: PUSH
65781: LD_EXP 100
65785: NOT
65786: OR
65787: IFFALSE 65791
// exit ;
65789: GO 65990
// for i = 1 to mc_bases do
65791: LD_ADDR_VAR 0 5
65795: PUSH
65796: DOUBLE
65797: LD_INT 1
65799: DEC
65800: ST_TO_ADDR
65801: LD_EXP 102
65805: PUSH
65806: FOR_TO
65807: IFFALSE 65988
// if building in mc_bases [ i ] then
65809: LD_VAR 0 1
65813: PUSH
65814: LD_EXP 102
65818: PUSH
65819: LD_VAR 0 5
65823: ARRAY
65824: IN
65825: IFFALSE 65986
// begin tmp := mc_bases [ i ] diff building ;
65827: LD_ADDR_VAR 0 6
65831: PUSH
65832: LD_EXP 102
65836: PUSH
65837: LD_VAR 0 5
65841: ARRAY
65842: PUSH
65843: LD_VAR 0 1
65847: DIFF
65848: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
65849: LD_ADDR_EXP 102
65853: PUSH
65854: LD_EXP 102
65858: PPUSH
65859: LD_VAR 0 5
65863: PPUSH
65864: LD_VAR 0 6
65868: PPUSH
65869: CALL_OW 1
65873: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
65874: LD_VAR 0 1
65878: PUSH
65879: LD_EXP 110
65883: PUSH
65884: LD_VAR 0 5
65888: ARRAY
65889: IN
65890: IFFALSE 65929
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
65892: LD_ADDR_EXP 110
65896: PUSH
65897: LD_EXP 110
65901: PPUSH
65902: LD_VAR 0 5
65906: PPUSH
65907: LD_EXP 110
65911: PUSH
65912: LD_VAR 0 5
65916: ARRAY
65917: PUSH
65918: LD_VAR 0 1
65922: DIFF
65923: PPUSH
65924: CALL_OW 1
65928: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
65929: LD_VAR 0 1
65933: PUSH
65934: LD_EXP 111
65938: PUSH
65939: LD_VAR 0 5
65943: ARRAY
65944: IN
65945: IFFALSE 65984
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
65947: LD_ADDR_EXP 111
65951: PUSH
65952: LD_EXP 111
65956: PPUSH
65957: LD_VAR 0 5
65961: PPUSH
65962: LD_EXP 111
65966: PUSH
65967: LD_VAR 0 5
65971: ARRAY
65972: PUSH
65973: LD_VAR 0 1
65977: DIFF
65978: PPUSH
65979: CALL_OW 1
65983: ST_TO_ADDR
// break ;
65984: GO 65988
// end ;
65986: GO 65806
65988: POP
65989: POP
// end ;
65990: LD_VAR 0 4
65994: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
65995: LD_INT 0
65997: PPUSH
65998: PPUSH
65999: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
66000: LD_EXP 102
66004: NOT
66005: PUSH
66006: LD_EXP 100
66010: NOT
66011: OR
66012: PUSH
66013: LD_VAR 0 3
66017: PUSH
66018: LD_EXP 128
66022: IN
66023: NOT
66024: OR
66025: IFFALSE 66029
// exit ;
66027: GO 66152
// for i = 1 to mc_vehicles do
66029: LD_ADDR_VAR 0 6
66033: PUSH
66034: DOUBLE
66035: LD_INT 1
66037: DEC
66038: ST_TO_ADDR
66039: LD_EXP 121
66043: PUSH
66044: FOR_TO
66045: IFFALSE 66150
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
66047: LD_VAR 0 2
66051: PUSH
66052: LD_EXP 121
66056: PUSH
66057: LD_VAR 0 6
66061: ARRAY
66062: IN
66063: PUSH
66064: LD_VAR 0 1
66068: PUSH
66069: LD_EXP 121
66073: PUSH
66074: LD_VAR 0 6
66078: ARRAY
66079: IN
66080: OR
66081: IFFALSE 66148
// begin tmp := mc_vehicles [ i ] diff old ;
66083: LD_ADDR_VAR 0 7
66087: PUSH
66088: LD_EXP 121
66092: PUSH
66093: LD_VAR 0 6
66097: ARRAY
66098: PUSH
66099: LD_VAR 0 2
66103: DIFF
66104: ST_TO_ADDR
// tmp := tmp diff new ;
66105: LD_ADDR_VAR 0 7
66109: PUSH
66110: LD_VAR 0 7
66114: PUSH
66115: LD_VAR 0 1
66119: DIFF
66120: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
66121: LD_ADDR_EXP 121
66125: PUSH
66126: LD_EXP 121
66130: PPUSH
66131: LD_VAR 0 6
66135: PPUSH
66136: LD_VAR 0 7
66140: PPUSH
66141: CALL_OW 1
66145: ST_TO_ADDR
// break ;
66146: GO 66150
// end ;
66148: GO 66044
66150: POP
66151: POP
// end ;
66152: LD_VAR 0 5
66156: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
66157: LD_INT 0
66159: PPUSH
66160: PPUSH
66161: PPUSH
66162: PPUSH
// if not mc_bases or not skirmish then
66163: LD_EXP 102
66167: NOT
66168: PUSH
66169: LD_EXP 100
66173: NOT
66174: OR
66175: IFFALSE 66179
// exit ;
66177: GO 66599
// repeat wait ( 0 0$1 ) ;
66179: LD_INT 35
66181: PPUSH
66182: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
66186: LD_EXP 146
66190: NOT
66191: IFFALSE 66179
// mc_block_vehicle_constructed_thread := true ;
66193: LD_ADDR_EXP 146
66197: PUSH
66198: LD_INT 1
66200: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
66201: LD_ADDR_VAR 0 5
66205: PUSH
66206: LD_VAR 0 1
66210: PPUSH
66211: CALL_OW 255
66215: ST_TO_ADDR
// for i = 1 to mc_bases do
66216: LD_ADDR_VAR 0 4
66220: PUSH
66221: DOUBLE
66222: LD_INT 1
66224: DEC
66225: ST_TO_ADDR
66226: LD_EXP 102
66230: PUSH
66231: FOR_TO
66232: IFFALSE 66589
// begin if factory in mc_bases [ i ] then
66234: LD_VAR 0 2
66238: PUSH
66239: LD_EXP 102
66243: PUSH
66244: LD_VAR 0 4
66248: ARRAY
66249: IN
66250: IFFALSE 66587
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
66252: LD_EXP 124
66256: PUSH
66257: LD_VAR 0 4
66261: ARRAY
66262: PUSH
66263: LD_EXP 113
66267: PUSH
66268: LD_VAR 0 4
66272: ARRAY
66273: LESS
66274: PUSH
66275: LD_VAR 0 1
66279: PPUSH
66280: CALL_OW 264
66284: PUSH
66285: LD_INT 31
66287: PUSH
66288: LD_INT 32
66290: PUSH
66291: LD_INT 51
66293: PUSH
66294: LD_INT 89
66296: PUSH
66297: LD_INT 12
66299: PUSH
66300: LD_INT 30
66302: PUSH
66303: LD_INT 98
66305: PUSH
66306: LD_INT 11
66308: PUSH
66309: LD_INT 53
66311: PUSH
66312: LD_INT 14
66314: PUSH
66315: LD_INT 91
66317: PUSH
66318: LD_INT 29
66320: PUSH
66321: LD_INT 99
66323: PUSH
66324: LD_INT 13
66326: PUSH
66327: LD_INT 52
66329: PUSH
66330: LD_INT 88
66332: PUSH
66333: LD_INT 48
66335: PUSH
66336: LD_INT 8
66338: PUSH
66339: EMPTY
66340: LIST
66341: LIST
66342: LIST
66343: LIST
66344: LIST
66345: LIST
66346: LIST
66347: LIST
66348: LIST
66349: LIST
66350: LIST
66351: LIST
66352: LIST
66353: LIST
66354: LIST
66355: LIST
66356: LIST
66357: LIST
66358: IN
66359: NOT
66360: AND
66361: IFFALSE 66409
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
66363: LD_ADDR_EXP 124
66367: PUSH
66368: LD_EXP 124
66372: PPUSH
66373: LD_VAR 0 4
66377: PUSH
66378: LD_EXP 124
66382: PUSH
66383: LD_VAR 0 4
66387: ARRAY
66388: PUSH
66389: LD_INT 1
66391: PLUS
66392: PUSH
66393: EMPTY
66394: LIST
66395: LIST
66396: PPUSH
66397: LD_VAR 0 1
66401: PPUSH
66402: CALL 75234 0 3
66406: ST_TO_ADDR
66407: GO 66453
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
66409: LD_ADDR_EXP 121
66413: PUSH
66414: LD_EXP 121
66418: PPUSH
66419: LD_VAR 0 4
66423: PUSH
66424: LD_EXP 121
66428: PUSH
66429: LD_VAR 0 4
66433: ARRAY
66434: PUSH
66435: LD_INT 1
66437: PLUS
66438: PUSH
66439: EMPTY
66440: LIST
66441: LIST
66442: PPUSH
66443: LD_VAR 0 1
66447: PPUSH
66448: CALL 75234 0 3
66452: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
66453: LD_ADDR_EXP 146
66457: PUSH
66458: LD_INT 0
66460: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
66461: LD_VAR 0 1
66465: PPUSH
66466: CALL_OW 263
66470: PUSH
66471: LD_INT 2
66473: EQUAL
66474: IFFALSE 66503
// begin repeat wait ( 0 0$3 ) ;
66476: LD_INT 105
66478: PPUSH
66479: CALL_OW 67
// Connect ( vehicle ) ;
66483: LD_VAR 0 1
66487: PPUSH
66488: CALL 78580 0 1
// until IsControledBy ( vehicle ) ;
66492: LD_VAR 0 1
66496: PPUSH
66497: CALL_OW 312
66501: IFFALSE 66476
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
66503: LD_VAR 0 1
66507: PPUSH
66508: LD_EXP 126
66512: PUSH
66513: LD_VAR 0 4
66517: ARRAY
66518: PPUSH
66519: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
66523: LD_VAR 0 1
66527: PPUSH
66528: CALL_OW 263
66532: PUSH
66533: LD_INT 1
66535: NONEQUAL
66536: IFFALSE 66540
// break ;
66538: GO 66589
// repeat wait ( 0 0$1 ) ;
66540: LD_INT 35
66542: PPUSH
66543: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
66547: LD_VAR 0 1
66551: PPUSH
66552: LD_EXP 126
66556: PUSH
66557: LD_VAR 0 4
66561: ARRAY
66562: PPUSH
66563: CALL_OW 308
66567: IFFALSE 66540
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
66569: LD_VAR 0 1
66573: PPUSH
66574: CALL_OW 311
66578: PPUSH
66579: CALL_OW 121
// exit ;
66583: POP
66584: POP
66585: GO 66599
// end ; end ;
66587: GO 66231
66589: POP
66590: POP
// mc_block_vehicle_constructed_thread := false ;
66591: LD_ADDR_EXP 146
66595: PUSH
66596: LD_INT 0
66598: ST_TO_ADDR
// end ;
66599: LD_VAR 0 3
66603: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
66604: LD_INT 0
66606: PPUSH
66607: PPUSH
66608: PPUSH
66609: PPUSH
// if not mc_bases or not skirmish then
66610: LD_EXP 102
66614: NOT
66615: PUSH
66616: LD_EXP 100
66620: NOT
66621: OR
66622: IFFALSE 66626
// exit ;
66624: GO 66979
// repeat wait ( 0 0$1 ) ;
66626: LD_INT 35
66628: PPUSH
66629: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
66633: LD_VAR 0 2
66637: PPUSH
66638: LD_VAR 0 3
66642: PPUSH
66643: CALL_OW 284
66647: IFFALSE 66626
// if GetResourceTypeXY ( x , y ) = mat_artefact then
66649: LD_VAR 0 2
66653: PPUSH
66654: LD_VAR 0 3
66658: PPUSH
66659: CALL_OW 283
66663: PUSH
66664: LD_INT 4
66666: EQUAL
66667: IFFALSE 66671
// exit ;
66669: GO 66979
// for i = 1 to mc_bases do
66671: LD_ADDR_VAR 0 7
66675: PUSH
66676: DOUBLE
66677: LD_INT 1
66679: DEC
66680: ST_TO_ADDR
66681: LD_EXP 102
66685: PUSH
66686: FOR_TO
66687: IFFALSE 66977
// begin if mc_crates_area [ i ] then
66689: LD_EXP 120
66693: PUSH
66694: LD_VAR 0 7
66698: ARRAY
66699: IFFALSE 66810
// for j in mc_crates_area [ i ] do
66701: LD_ADDR_VAR 0 8
66705: PUSH
66706: LD_EXP 120
66710: PUSH
66711: LD_VAR 0 7
66715: ARRAY
66716: PUSH
66717: FOR_IN
66718: IFFALSE 66808
// if InArea ( x , y , j ) then
66720: LD_VAR 0 2
66724: PPUSH
66725: LD_VAR 0 3
66729: PPUSH
66730: LD_VAR 0 8
66734: PPUSH
66735: CALL_OW 309
66739: IFFALSE 66806
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
66741: LD_ADDR_EXP 118
66745: PUSH
66746: LD_EXP 118
66750: PPUSH
66751: LD_VAR 0 7
66755: PUSH
66756: LD_EXP 118
66760: PUSH
66761: LD_VAR 0 7
66765: ARRAY
66766: PUSH
66767: LD_INT 1
66769: PLUS
66770: PUSH
66771: EMPTY
66772: LIST
66773: LIST
66774: PPUSH
66775: LD_VAR 0 4
66779: PUSH
66780: LD_VAR 0 2
66784: PUSH
66785: LD_VAR 0 3
66789: PUSH
66790: EMPTY
66791: LIST
66792: LIST
66793: LIST
66794: PPUSH
66795: CALL 75234 0 3
66799: ST_TO_ADDR
// exit ;
66800: POP
66801: POP
66802: POP
66803: POP
66804: GO 66979
// end ;
66806: GO 66717
66808: POP
66809: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66810: LD_ADDR_VAR 0 9
66814: PUSH
66815: LD_EXP 102
66819: PUSH
66820: LD_VAR 0 7
66824: ARRAY
66825: PPUSH
66826: LD_INT 2
66828: PUSH
66829: LD_INT 30
66831: PUSH
66832: LD_INT 0
66834: PUSH
66835: EMPTY
66836: LIST
66837: LIST
66838: PUSH
66839: LD_INT 30
66841: PUSH
66842: LD_INT 1
66844: PUSH
66845: EMPTY
66846: LIST
66847: LIST
66848: PUSH
66849: EMPTY
66850: LIST
66851: LIST
66852: LIST
66853: PPUSH
66854: CALL_OW 72
66858: ST_TO_ADDR
// if not depot then
66859: LD_VAR 0 9
66863: NOT
66864: IFFALSE 66868
// continue ;
66866: GO 66686
// for j in depot do
66868: LD_ADDR_VAR 0 8
66872: PUSH
66873: LD_VAR 0 9
66877: PUSH
66878: FOR_IN
66879: IFFALSE 66973
// if GetDistUnitXY ( j , x , y ) < 30 then
66881: LD_VAR 0 8
66885: PPUSH
66886: LD_VAR 0 2
66890: PPUSH
66891: LD_VAR 0 3
66895: PPUSH
66896: CALL_OW 297
66900: PUSH
66901: LD_INT 30
66903: LESS
66904: IFFALSE 66971
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
66906: LD_ADDR_EXP 118
66910: PUSH
66911: LD_EXP 118
66915: PPUSH
66916: LD_VAR 0 7
66920: PUSH
66921: LD_EXP 118
66925: PUSH
66926: LD_VAR 0 7
66930: ARRAY
66931: PUSH
66932: LD_INT 1
66934: PLUS
66935: PUSH
66936: EMPTY
66937: LIST
66938: LIST
66939: PPUSH
66940: LD_VAR 0 4
66944: PUSH
66945: LD_VAR 0 2
66949: PUSH
66950: LD_VAR 0 3
66954: PUSH
66955: EMPTY
66956: LIST
66957: LIST
66958: LIST
66959: PPUSH
66960: CALL 75234 0 3
66964: ST_TO_ADDR
// exit ;
66965: POP
66966: POP
66967: POP
66968: POP
66969: GO 66979
// end ;
66971: GO 66878
66973: POP
66974: POP
// end ;
66975: GO 66686
66977: POP
66978: POP
// end ;
66979: LD_VAR 0 6
66983: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
66984: LD_INT 0
66986: PPUSH
66987: PPUSH
66988: PPUSH
66989: PPUSH
// if not mc_bases or not skirmish then
66990: LD_EXP 102
66994: NOT
66995: PUSH
66996: LD_EXP 100
67000: NOT
67001: OR
67002: IFFALSE 67006
// exit ;
67004: GO 67283
// side := GetSide ( lab ) ;
67006: LD_ADDR_VAR 0 4
67010: PUSH
67011: LD_VAR 0 2
67015: PPUSH
67016: CALL_OW 255
67020: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
67021: LD_VAR 0 4
67025: PUSH
67026: LD_EXP 128
67030: IN
67031: NOT
67032: PUSH
67033: LD_EXP 129
67037: NOT
67038: OR
67039: PUSH
67040: LD_EXP 102
67044: NOT
67045: OR
67046: IFFALSE 67050
// exit ;
67048: GO 67283
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
67050: LD_ADDR_EXP 129
67054: PUSH
67055: LD_EXP 129
67059: PPUSH
67060: LD_VAR 0 4
67064: PPUSH
67065: LD_EXP 129
67069: PUSH
67070: LD_VAR 0 4
67074: ARRAY
67075: PUSH
67076: LD_VAR 0 1
67080: DIFF
67081: PPUSH
67082: CALL_OW 1
67086: ST_TO_ADDR
// for i = 1 to mc_bases do
67087: LD_ADDR_VAR 0 5
67091: PUSH
67092: DOUBLE
67093: LD_INT 1
67095: DEC
67096: ST_TO_ADDR
67097: LD_EXP 102
67101: PUSH
67102: FOR_TO
67103: IFFALSE 67281
// begin if lab in mc_bases [ i ] then
67105: LD_VAR 0 2
67109: PUSH
67110: LD_EXP 102
67114: PUSH
67115: LD_VAR 0 5
67119: ARRAY
67120: IN
67121: IFFALSE 67279
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
67123: LD_VAR 0 1
67127: PUSH
67128: LD_INT 11
67130: PUSH
67131: LD_INT 4
67133: PUSH
67134: LD_INT 3
67136: PUSH
67137: LD_INT 2
67139: PUSH
67140: EMPTY
67141: LIST
67142: LIST
67143: LIST
67144: LIST
67145: IN
67146: PUSH
67147: LD_EXP 132
67151: PUSH
67152: LD_VAR 0 5
67156: ARRAY
67157: AND
67158: IFFALSE 67279
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
67160: LD_ADDR_VAR 0 6
67164: PUSH
67165: LD_EXP 132
67169: PUSH
67170: LD_VAR 0 5
67174: ARRAY
67175: PUSH
67176: LD_INT 1
67178: ARRAY
67179: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
67180: LD_ADDR_EXP 132
67184: PUSH
67185: LD_EXP 132
67189: PPUSH
67190: LD_VAR 0 5
67194: PPUSH
67195: EMPTY
67196: PPUSH
67197: CALL_OW 1
67201: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
67202: LD_VAR 0 6
67206: PPUSH
67207: LD_INT 0
67209: PPUSH
67210: CALL_OW 109
// ComExitBuilding ( tmp ) ;
67214: LD_VAR 0 6
67218: PPUSH
67219: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
67223: LD_ADDR_EXP 131
67227: PUSH
67228: LD_EXP 131
67232: PPUSH
67233: LD_VAR 0 5
67237: PPUSH
67238: LD_EXP 131
67242: PUSH
67243: LD_VAR 0 5
67247: ARRAY
67248: PPUSH
67249: LD_INT 1
67251: PPUSH
67252: LD_VAR 0 6
67256: PPUSH
67257: CALL_OW 2
67261: PPUSH
67262: CALL_OW 1
67266: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
67267: LD_VAR 0 5
67271: PPUSH
67272: LD_INT 112
67274: PPUSH
67275: CALL 43733 0 2
// end ; end ; end ;
67279: GO 67102
67281: POP
67282: POP
// end ;
67283: LD_VAR 0 3
67287: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
67288: LD_INT 0
67290: PPUSH
67291: PPUSH
67292: PPUSH
67293: PPUSH
67294: PPUSH
67295: PPUSH
67296: PPUSH
67297: PPUSH
// if not mc_bases or not skirmish then
67298: LD_EXP 102
67302: NOT
67303: PUSH
67304: LD_EXP 100
67308: NOT
67309: OR
67310: IFFALSE 67314
// exit ;
67312: GO 68683
// for i = 1 to mc_bases do
67314: LD_ADDR_VAR 0 3
67318: PUSH
67319: DOUBLE
67320: LD_INT 1
67322: DEC
67323: ST_TO_ADDR
67324: LD_EXP 102
67328: PUSH
67329: FOR_TO
67330: IFFALSE 68681
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
67332: LD_VAR 0 1
67336: PUSH
67337: LD_EXP 102
67341: PUSH
67342: LD_VAR 0 3
67346: ARRAY
67347: IN
67348: PUSH
67349: LD_VAR 0 1
67353: PUSH
67354: LD_EXP 109
67358: PUSH
67359: LD_VAR 0 3
67363: ARRAY
67364: IN
67365: OR
67366: PUSH
67367: LD_VAR 0 1
67371: PUSH
67372: LD_EXP 124
67376: PUSH
67377: LD_VAR 0 3
67381: ARRAY
67382: IN
67383: OR
67384: PUSH
67385: LD_VAR 0 1
67389: PUSH
67390: LD_EXP 121
67394: PUSH
67395: LD_VAR 0 3
67399: ARRAY
67400: IN
67401: OR
67402: PUSH
67403: LD_VAR 0 1
67407: PUSH
67408: LD_EXP 131
67412: PUSH
67413: LD_VAR 0 3
67417: ARRAY
67418: IN
67419: OR
67420: PUSH
67421: LD_VAR 0 1
67425: PUSH
67426: LD_EXP 132
67430: PUSH
67431: LD_VAR 0 3
67435: ARRAY
67436: IN
67437: OR
67438: IFFALSE 68679
// begin if un in mc_ape [ i ] then
67440: LD_VAR 0 1
67444: PUSH
67445: LD_EXP 131
67449: PUSH
67450: LD_VAR 0 3
67454: ARRAY
67455: IN
67456: IFFALSE 67495
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
67458: LD_ADDR_EXP 131
67462: PUSH
67463: LD_EXP 131
67467: PPUSH
67468: LD_VAR 0 3
67472: PPUSH
67473: LD_EXP 131
67477: PUSH
67478: LD_VAR 0 3
67482: ARRAY
67483: PUSH
67484: LD_VAR 0 1
67488: DIFF
67489: PPUSH
67490: CALL_OW 1
67494: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
67495: LD_VAR 0 1
67499: PUSH
67500: LD_EXP 132
67504: PUSH
67505: LD_VAR 0 3
67509: ARRAY
67510: IN
67511: IFFALSE 67535
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
67513: LD_ADDR_EXP 132
67517: PUSH
67518: LD_EXP 132
67522: PPUSH
67523: LD_VAR 0 3
67527: PPUSH
67528: EMPTY
67529: PPUSH
67530: CALL_OW 1
67534: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
67535: LD_VAR 0 1
67539: PPUSH
67540: CALL_OW 247
67544: PUSH
67545: LD_INT 2
67547: EQUAL
67548: PUSH
67549: LD_VAR 0 1
67553: PPUSH
67554: CALL_OW 110
67558: PUSH
67559: LD_INT 20
67561: EQUAL
67562: PUSH
67563: LD_VAR 0 1
67567: PUSH
67568: LD_EXP 124
67572: PUSH
67573: LD_VAR 0 3
67577: ARRAY
67578: IN
67579: OR
67580: PUSH
67581: LD_VAR 0 1
67585: PPUSH
67586: CALL_OW 264
67590: PUSH
67591: LD_INT 12
67593: PUSH
67594: LD_INT 51
67596: PUSH
67597: LD_INT 89
67599: PUSH
67600: LD_INT 32
67602: PUSH
67603: LD_INT 13
67605: PUSH
67606: LD_INT 52
67608: PUSH
67609: LD_INT 31
67611: PUSH
67612: EMPTY
67613: LIST
67614: LIST
67615: LIST
67616: LIST
67617: LIST
67618: LIST
67619: LIST
67620: IN
67621: OR
67622: AND
67623: IFFALSE 67931
// begin if un in mc_defender [ i ] then
67625: LD_VAR 0 1
67629: PUSH
67630: LD_EXP 124
67634: PUSH
67635: LD_VAR 0 3
67639: ARRAY
67640: IN
67641: IFFALSE 67680
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
67643: LD_ADDR_EXP 124
67647: PUSH
67648: LD_EXP 124
67652: PPUSH
67653: LD_VAR 0 3
67657: PPUSH
67658: LD_EXP 124
67662: PUSH
67663: LD_VAR 0 3
67667: ARRAY
67668: PUSH
67669: LD_VAR 0 1
67673: DIFF
67674: PPUSH
67675: CALL_OW 1
67679: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
67680: LD_ADDR_VAR 0 8
67684: PUSH
67685: LD_VAR 0 3
67689: PPUSH
67690: LD_INT 3
67692: PPUSH
67693: CALL 64301 0 2
67697: ST_TO_ADDR
// if fac then
67698: LD_VAR 0 8
67702: IFFALSE 67931
// begin for j in fac do
67704: LD_ADDR_VAR 0 4
67708: PUSH
67709: LD_VAR 0 8
67713: PUSH
67714: FOR_IN
67715: IFFALSE 67929
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
67717: LD_ADDR_VAR 0 9
67721: PUSH
67722: LD_VAR 0 8
67726: PPUSH
67727: LD_VAR 0 1
67731: PPUSH
67732: CALL_OW 265
67736: PPUSH
67737: LD_VAR 0 1
67741: PPUSH
67742: CALL_OW 262
67746: PPUSH
67747: LD_VAR 0 1
67751: PPUSH
67752: CALL_OW 263
67756: PPUSH
67757: LD_VAR 0 1
67761: PPUSH
67762: CALL_OW 264
67766: PPUSH
67767: CALL 72732 0 5
67771: ST_TO_ADDR
// if components then
67772: LD_VAR 0 9
67776: IFFALSE 67927
// begin if GetWeapon ( un ) = ar_control_tower then
67778: LD_VAR 0 1
67782: PPUSH
67783: CALL_OW 264
67787: PUSH
67788: LD_INT 31
67790: EQUAL
67791: IFFALSE 67908
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
67793: LD_VAR 0 1
67797: PPUSH
67798: CALL_OW 311
67802: PPUSH
67803: LD_INT 0
67805: PPUSH
67806: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
67810: LD_ADDR_EXP 142
67814: PUSH
67815: LD_EXP 142
67819: PPUSH
67820: LD_VAR 0 3
67824: PPUSH
67825: LD_EXP 142
67829: PUSH
67830: LD_VAR 0 3
67834: ARRAY
67835: PUSH
67836: LD_VAR 0 1
67840: PPUSH
67841: CALL_OW 311
67845: DIFF
67846: PPUSH
67847: CALL_OW 1
67851: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
67852: LD_ADDR_VAR 0 7
67856: PUSH
67857: LD_EXP 123
67861: PUSH
67862: LD_VAR 0 3
67866: ARRAY
67867: PPUSH
67868: LD_INT 1
67870: PPUSH
67871: LD_VAR 0 9
67875: PPUSH
67876: CALL_OW 2
67880: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
67881: LD_ADDR_EXP 123
67885: PUSH
67886: LD_EXP 123
67890: PPUSH
67891: LD_VAR 0 3
67895: PPUSH
67896: LD_VAR 0 7
67900: PPUSH
67901: CALL_OW 1
67905: ST_TO_ADDR
// end else
67906: GO 67925
// MC_InsertProduceList ( i , [ components ] ) ;
67908: LD_VAR 0 3
67912: PPUSH
67913: LD_VAR 0 9
67917: PUSH
67918: EMPTY
67919: LIST
67920: PPUSH
67921: CALL 63846 0 2
// break ;
67925: GO 67929
// end ; end ;
67927: GO 67714
67929: POP
67930: POP
// end ; end ; if GetType ( un ) = unit_building then
67931: LD_VAR 0 1
67935: PPUSH
67936: CALL_OW 247
67940: PUSH
67941: LD_INT 3
67943: EQUAL
67944: IFFALSE 68347
// begin btype := GetBType ( un ) ;
67946: LD_ADDR_VAR 0 5
67950: PUSH
67951: LD_VAR 0 1
67955: PPUSH
67956: CALL_OW 266
67960: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
67961: LD_VAR 0 5
67965: PUSH
67966: LD_INT 29
67968: PUSH
67969: LD_INT 30
67971: PUSH
67972: EMPTY
67973: LIST
67974: LIST
67975: IN
67976: IFFALSE 68049
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
67978: LD_VAR 0 1
67982: PPUSH
67983: CALL_OW 250
67987: PPUSH
67988: LD_VAR 0 1
67992: PPUSH
67993: CALL_OW 251
67997: PPUSH
67998: LD_VAR 0 1
68002: PPUSH
68003: CALL_OW 255
68007: PPUSH
68008: CALL_OW 440
68012: NOT
68013: IFFALSE 68049
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
68015: LD_VAR 0 1
68019: PPUSH
68020: CALL_OW 250
68024: PPUSH
68025: LD_VAR 0 1
68029: PPUSH
68030: CALL_OW 251
68034: PPUSH
68035: LD_VAR 0 1
68039: PPUSH
68040: CALL_OW 255
68044: PPUSH
68045: CALL_OW 441
// end ; if btype = b_warehouse then
68049: LD_VAR 0 5
68053: PUSH
68054: LD_INT 1
68056: EQUAL
68057: IFFALSE 68075
// begin btype := b_depot ;
68059: LD_ADDR_VAR 0 5
68063: PUSH
68064: LD_INT 0
68066: ST_TO_ADDR
// pos := 1 ;
68067: LD_ADDR_VAR 0 6
68071: PUSH
68072: LD_INT 1
68074: ST_TO_ADDR
// end ; if btype = b_factory then
68075: LD_VAR 0 5
68079: PUSH
68080: LD_INT 3
68082: EQUAL
68083: IFFALSE 68101
// begin btype := b_workshop ;
68085: LD_ADDR_VAR 0 5
68089: PUSH
68090: LD_INT 2
68092: ST_TO_ADDR
// pos := 1 ;
68093: LD_ADDR_VAR 0 6
68097: PUSH
68098: LD_INT 1
68100: ST_TO_ADDR
// end ; if btype = b_barracks then
68101: LD_VAR 0 5
68105: PUSH
68106: LD_INT 5
68108: EQUAL
68109: IFFALSE 68119
// btype := b_armoury ;
68111: LD_ADDR_VAR 0 5
68115: PUSH
68116: LD_INT 4
68118: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
68119: LD_VAR 0 5
68123: PUSH
68124: LD_INT 7
68126: PUSH
68127: LD_INT 8
68129: PUSH
68130: EMPTY
68131: LIST
68132: LIST
68133: IN
68134: IFFALSE 68144
// btype := b_lab ;
68136: LD_ADDR_VAR 0 5
68140: PUSH
68141: LD_INT 6
68143: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
68144: LD_ADDR_EXP 107
68148: PUSH
68149: LD_EXP 107
68153: PPUSH
68154: LD_VAR 0 3
68158: PUSH
68159: LD_EXP 107
68163: PUSH
68164: LD_VAR 0 3
68168: ARRAY
68169: PUSH
68170: LD_INT 1
68172: PLUS
68173: PUSH
68174: EMPTY
68175: LIST
68176: LIST
68177: PPUSH
68178: LD_VAR 0 5
68182: PUSH
68183: LD_VAR 0 1
68187: PPUSH
68188: CALL_OW 250
68192: PUSH
68193: LD_VAR 0 1
68197: PPUSH
68198: CALL_OW 251
68202: PUSH
68203: LD_VAR 0 1
68207: PPUSH
68208: CALL_OW 254
68212: PUSH
68213: EMPTY
68214: LIST
68215: LIST
68216: LIST
68217: LIST
68218: PPUSH
68219: CALL 75234 0 3
68223: ST_TO_ADDR
// if pos = 1 then
68224: LD_VAR 0 6
68228: PUSH
68229: LD_INT 1
68231: EQUAL
68232: IFFALSE 68347
// begin tmp := mc_build_list [ i ] ;
68234: LD_ADDR_VAR 0 7
68238: PUSH
68239: LD_EXP 107
68243: PUSH
68244: LD_VAR 0 3
68248: ARRAY
68249: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
68250: LD_VAR 0 7
68254: PPUSH
68255: LD_INT 2
68257: PUSH
68258: LD_INT 30
68260: PUSH
68261: LD_INT 0
68263: PUSH
68264: EMPTY
68265: LIST
68266: LIST
68267: PUSH
68268: LD_INT 30
68270: PUSH
68271: LD_INT 1
68273: PUSH
68274: EMPTY
68275: LIST
68276: LIST
68277: PUSH
68278: EMPTY
68279: LIST
68280: LIST
68281: LIST
68282: PPUSH
68283: CALL_OW 72
68287: IFFALSE 68297
// pos := 2 ;
68289: LD_ADDR_VAR 0 6
68293: PUSH
68294: LD_INT 2
68296: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
68297: LD_ADDR_VAR 0 7
68301: PUSH
68302: LD_VAR 0 7
68306: PPUSH
68307: LD_VAR 0 6
68311: PPUSH
68312: LD_VAR 0 7
68316: PPUSH
68317: CALL 75560 0 3
68321: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
68322: LD_ADDR_EXP 107
68326: PUSH
68327: LD_EXP 107
68331: PPUSH
68332: LD_VAR 0 3
68336: PPUSH
68337: LD_VAR 0 7
68341: PPUSH
68342: CALL_OW 1
68346: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
68347: LD_VAR 0 1
68351: PUSH
68352: LD_EXP 102
68356: PUSH
68357: LD_VAR 0 3
68361: ARRAY
68362: IN
68363: IFFALSE 68402
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
68365: LD_ADDR_EXP 102
68369: PUSH
68370: LD_EXP 102
68374: PPUSH
68375: LD_VAR 0 3
68379: PPUSH
68380: LD_EXP 102
68384: PUSH
68385: LD_VAR 0 3
68389: ARRAY
68390: PUSH
68391: LD_VAR 0 1
68395: DIFF
68396: PPUSH
68397: CALL_OW 1
68401: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
68402: LD_VAR 0 1
68406: PUSH
68407: LD_EXP 109
68411: PUSH
68412: LD_VAR 0 3
68416: ARRAY
68417: IN
68418: IFFALSE 68457
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
68420: LD_ADDR_EXP 109
68424: PUSH
68425: LD_EXP 109
68429: PPUSH
68430: LD_VAR 0 3
68434: PPUSH
68435: LD_EXP 109
68439: PUSH
68440: LD_VAR 0 3
68444: ARRAY
68445: PUSH
68446: LD_VAR 0 1
68450: DIFF
68451: PPUSH
68452: CALL_OW 1
68456: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
68457: LD_VAR 0 1
68461: PUSH
68462: LD_EXP 121
68466: PUSH
68467: LD_VAR 0 3
68471: ARRAY
68472: IN
68473: IFFALSE 68512
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
68475: LD_ADDR_EXP 121
68479: PUSH
68480: LD_EXP 121
68484: PPUSH
68485: LD_VAR 0 3
68489: PPUSH
68490: LD_EXP 121
68494: PUSH
68495: LD_VAR 0 3
68499: ARRAY
68500: PUSH
68501: LD_VAR 0 1
68505: DIFF
68506: PPUSH
68507: CALL_OW 1
68511: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
68512: LD_VAR 0 1
68516: PUSH
68517: LD_EXP 124
68521: PUSH
68522: LD_VAR 0 3
68526: ARRAY
68527: IN
68528: IFFALSE 68567
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
68530: LD_ADDR_EXP 124
68534: PUSH
68535: LD_EXP 124
68539: PPUSH
68540: LD_VAR 0 3
68544: PPUSH
68545: LD_EXP 124
68549: PUSH
68550: LD_VAR 0 3
68554: ARRAY
68555: PUSH
68556: LD_VAR 0 1
68560: DIFF
68561: PPUSH
68562: CALL_OW 1
68566: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
68567: LD_VAR 0 1
68571: PUSH
68572: LD_EXP 111
68576: PUSH
68577: LD_VAR 0 3
68581: ARRAY
68582: IN
68583: IFFALSE 68622
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
68585: LD_ADDR_EXP 111
68589: PUSH
68590: LD_EXP 111
68594: PPUSH
68595: LD_VAR 0 3
68599: PPUSH
68600: LD_EXP 111
68604: PUSH
68605: LD_VAR 0 3
68609: ARRAY
68610: PUSH
68611: LD_VAR 0 1
68615: DIFF
68616: PPUSH
68617: CALL_OW 1
68621: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
68622: LD_VAR 0 1
68626: PUSH
68627: LD_EXP 110
68631: PUSH
68632: LD_VAR 0 3
68636: ARRAY
68637: IN
68638: IFFALSE 68677
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
68640: LD_ADDR_EXP 110
68644: PUSH
68645: LD_EXP 110
68649: PPUSH
68650: LD_VAR 0 3
68654: PPUSH
68655: LD_EXP 110
68659: PUSH
68660: LD_VAR 0 3
68664: ARRAY
68665: PUSH
68666: LD_VAR 0 1
68670: DIFF
68671: PPUSH
68672: CALL_OW 1
68676: ST_TO_ADDR
// end ; break ;
68677: GO 68681
// end ;
68679: GO 67329
68681: POP
68682: POP
// end ;
68683: LD_VAR 0 2
68687: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
68688: LD_INT 0
68690: PPUSH
68691: PPUSH
68692: PPUSH
// if not mc_bases or not skirmish then
68693: LD_EXP 102
68697: NOT
68698: PUSH
68699: LD_EXP 100
68703: NOT
68704: OR
68705: IFFALSE 68709
// exit ;
68707: GO 68924
// for i = 1 to mc_bases do
68709: LD_ADDR_VAR 0 3
68713: PUSH
68714: DOUBLE
68715: LD_INT 1
68717: DEC
68718: ST_TO_ADDR
68719: LD_EXP 102
68723: PUSH
68724: FOR_TO
68725: IFFALSE 68922
// begin if building in mc_construct_list [ i ] then
68727: LD_VAR 0 1
68731: PUSH
68732: LD_EXP 109
68736: PUSH
68737: LD_VAR 0 3
68741: ARRAY
68742: IN
68743: IFFALSE 68920
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
68745: LD_ADDR_EXP 109
68749: PUSH
68750: LD_EXP 109
68754: PPUSH
68755: LD_VAR 0 3
68759: PPUSH
68760: LD_EXP 109
68764: PUSH
68765: LD_VAR 0 3
68769: ARRAY
68770: PUSH
68771: LD_VAR 0 1
68775: DIFF
68776: PPUSH
68777: CALL_OW 1
68781: ST_TO_ADDR
// if building in mc_lab [ i ] then
68782: LD_VAR 0 1
68786: PUSH
68787: LD_EXP 135
68791: PUSH
68792: LD_VAR 0 3
68796: ARRAY
68797: IN
68798: IFFALSE 68853
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
68800: LD_ADDR_EXP 136
68804: PUSH
68805: LD_EXP 136
68809: PPUSH
68810: LD_VAR 0 3
68814: PPUSH
68815: LD_EXP 136
68819: PUSH
68820: LD_VAR 0 3
68824: ARRAY
68825: PPUSH
68826: LD_INT 1
68828: PPUSH
68829: LD_EXP 136
68833: PUSH
68834: LD_VAR 0 3
68838: ARRAY
68839: PPUSH
68840: LD_INT 0
68842: PPUSH
68843: CALL 74652 0 4
68847: PPUSH
68848: CALL_OW 1
68852: ST_TO_ADDR
// if not building in mc_bases [ i ] then
68853: LD_VAR 0 1
68857: PUSH
68858: LD_EXP 102
68862: PUSH
68863: LD_VAR 0 3
68867: ARRAY
68868: IN
68869: NOT
68870: IFFALSE 68916
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
68872: LD_ADDR_EXP 102
68876: PUSH
68877: LD_EXP 102
68881: PPUSH
68882: LD_VAR 0 3
68886: PUSH
68887: LD_EXP 102
68891: PUSH
68892: LD_VAR 0 3
68896: ARRAY
68897: PUSH
68898: LD_INT 1
68900: PLUS
68901: PUSH
68902: EMPTY
68903: LIST
68904: LIST
68905: PPUSH
68906: LD_VAR 0 1
68910: PPUSH
68911: CALL 75234 0 3
68915: ST_TO_ADDR
// exit ;
68916: POP
68917: POP
68918: GO 68924
// end ; end ;
68920: GO 68724
68922: POP
68923: POP
// end ;
68924: LD_VAR 0 2
68928: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
68929: LD_INT 0
68931: PPUSH
68932: PPUSH
68933: PPUSH
68934: PPUSH
68935: PPUSH
68936: PPUSH
68937: PPUSH
// if not mc_bases or not skirmish then
68938: LD_EXP 102
68942: NOT
68943: PUSH
68944: LD_EXP 100
68948: NOT
68949: OR
68950: IFFALSE 68954
// exit ;
68952: GO 69615
// for i = 1 to mc_bases do
68954: LD_ADDR_VAR 0 3
68958: PUSH
68959: DOUBLE
68960: LD_INT 1
68962: DEC
68963: ST_TO_ADDR
68964: LD_EXP 102
68968: PUSH
68969: FOR_TO
68970: IFFALSE 69613
// begin if building in mc_construct_list [ i ] then
68972: LD_VAR 0 1
68976: PUSH
68977: LD_EXP 109
68981: PUSH
68982: LD_VAR 0 3
68986: ARRAY
68987: IN
68988: IFFALSE 69611
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
68990: LD_ADDR_EXP 109
68994: PUSH
68995: LD_EXP 109
68999: PPUSH
69000: LD_VAR 0 3
69004: PPUSH
69005: LD_EXP 109
69009: PUSH
69010: LD_VAR 0 3
69014: ARRAY
69015: PUSH
69016: LD_VAR 0 1
69020: DIFF
69021: PPUSH
69022: CALL_OW 1
69026: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
69027: LD_ADDR_EXP 102
69031: PUSH
69032: LD_EXP 102
69036: PPUSH
69037: LD_VAR 0 3
69041: PUSH
69042: LD_EXP 102
69046: PUSH
69047: LD_VAR 0 3
69051: ARRAY
69052: PUSH
69053: LD_INT 1
69055: PLUS
69056: PUSH
69057: EMPTY
69058: LIST
69059: LIST
69060: PPUSH
69061: LD_VAR 0 1
69065: PPUSH
69066: CALL 75234 0 3
69070: ST_TO_ADDR
// btype := GetBType ( building ) ;
69071: LD_ADDR_VAR 0 5
69075: PUSH
69076: LD_VAR 0 1
69080: PPUSH
69081: CALL_OW 266
69085: ST_TO_ADDR
// side := GetSide ( building ) ;
69086: LD_ADDR_VAR 0 8
69090: PUSH
69091: LD_VAR 0 1
69095: PPUSH
69096: CALL_OW 255
69100: ST_TO_ADDR
// if btype = b_lab then
69101: LD_VAR 0 5
69105: PUSH
69106: LD_INT 6
69108: EQUAL
69109: IFFALSE 69159
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
69111: LD_ADDR_EXP 135
69115: PUSH
69116: LD_EXP 135
69120: PPUSH
69121: LD_VAR 0 3
69125: PUSH
69126: LD_EXP 135
69130: PUSH
69131: LD_VAR 0 3
69135: ARRAY
69136: PUSH
69137: LD_INT 1
69139: PLUS
69140: PUSH
69141: EMPTY
69142: LIST
69143: LIST
69144: PPUSH
69145: LD_VAR 0 1
69149: PPUSH
69150: CALL 75234 0 3
69154: ST_TO_ADDR
// exit ;
69155: POP
69156: POP
69157: GO 69615
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
69159: LD_VAR 0 5
69163: PUSH
69164: LD_INT 0
69166: PUSH
69167: LD_INT 2
69169: PUSH
69170: LD_INT 4
69172: PUSH
69173: EMPTY
69174: LIST
69175: LIST
69176: LIST
69177: IN
69178: IFFALSE 69302
// begin if btype = b_armoury then
69180: LD_VAR 0 5
69184: PUSH
69185: LD_INT 4
69187: EQUAL
69188: IFFALSE 69198
// btype := b_barracks ;
69190: LD_ADDR_VAR 0 5
69194: PUSH
69195: LD_INT 5
69197: ST_TO_ADDR
// if btype = b_depot then
69198: LD_VAR 0 5
69202: PUSH
69203: LD_INT 0
69205: EQUAL
69206: IFFALSE 69216
// btype := b_warehouse ;
69208: LD_ADDR_VAR 0 5
69212: PUSH
69213: LD_INT 1
69215: ST_TO_ADDR
// if btype = b_workshop then
69216: LD_VAR 0 5
69220: PUSH
69221: LD_INT 2
69223: EQUAL
69224: IFFALSE 69234
// btype := b_factory ;
69226: LD_ADDR_VAR 0 5
69230: PUSH
69231: LD_INT 3
69233: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
69234: LD_VAR 0 5
69238: PPUSH
69239: LD_VAR 0 8
69243: PPUSH
69244: CALL_OW 323
69248: PUSH
69249: LD_INT 1
69251: EQUAL
69252: IFFALSE 69298
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
69254: LD_ADDR_EXP 134
69258: PUSH
69259: LD_EXP 134
69263: PPUSH
69264: LD_VAR 0 3
69268: PUSH
69269: LD_EXP 134
69273: PUSH
69274: LD_VAR 0 3
69278: ARRAY
69279: PUSH
69280: LD_INT 1
69282: PLUS
69283: PUSH
69284: EMPTY
69285: LIST
69286: LIST
69287: PPUSH
69288: LD_VAR 0 1
69292: PPUSH
69293: CALL 75234 0 3
69297: ST_TO_ADDR
// exit ;
69298: POP
69299: POP
69300: GO 69615
// end ; if btype in [ b_bunker , b_turret ] then
69302: LD_VAR 0 5
69306: PUSH
69307: LD_INT 32
69309: PUSH
69310: LD_INT 33
69312: PUSH
69313: EMPTY
69314: LIST
69315: LIST
69316: IN
69317: IFFALSE 69607
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
69319: LD_ADDR_EXP 110
69323: PUSH
69324: LD_EXP 110
69328: PPUSH
69329: LD_VAR 0 3
69333: PUSH
69334: LD_EXP 110
69338: PUSH
69339: LD_VAR 0 3
69343: ARRAY
69344: PUSH
69345: LD_INT 1
69347: PLUS
69348: PUSH
69349: EMPTY
69350: LIST
69351: LIST
69352: PPUSH
69353: LD_VAR 0 1
69357: PPUSH
69358: CALL 75234 0 3
69362: ST_TO_ADDR
// if btype = b_bunker then
69363: LD_VAR 0 5
69367: PUSH
69368: LD_INT 32
69370: EQUAL
69371: IFFALSE 69607
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
69373: LD_ADDR_EXP 111
69377: PUSH
69378: LD_EXP 111
69382: PPUSH
69383: LD_VAR 0 3
69387: PUSH
69388: LD_EXP 111
69392: PUSH
69393: LD_VAR 0 3
69397: ARRAY
69398: PUSH
69399: LD_INT 1
69401: PLUS
69402: PUSH
69403: EMPTY
69404: LIST
69405: LIST
69406: PPUSH
69407: LD_VAR 0 1
69411: PPUSH
69412: CALL 75234 0 3
69416: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
69417: LD_ADDR_VAR 0 6
69421: PUSH
69422: LD_EXP 102
69426: PUSH
69427: LD_VAR 0 3
69431: ARRAY
69432: PPUSH
69433: LD_INT 25
69435: PUSH
69436: LD_INT 1
69438: PUSH
69439: EMPTY
69440: LIST
69441: LIST
69442: PUSH
69443: LD_INT 3
69445: PUSH
69446: LD_INT 54
69448: PUSH
69449: EMPTY
69450: LIST
69451: PUSH
69452: EMPTY
69453: LIST
69454: LIST
69455: PUSH
69456: EMPTY
69457: LIST
69458: LIST
69459: PPUSH
69460: CALL_OW 72
69464: ST_TO_ADDR
// if tmp then
69465: LD_VAR 0 6
69469: IFFALSE 69475
// exit ;
69471: POP
69472: POP
69473: GO 69615
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
69475: LD_ADDR_VAR 0 6
69479: PUSH
69480: LD_EXP 102
69484: PUSH
69485: LD_VAR 0 3
69489: ARRAY
69490: PPUSH
69491: LD_INT 2
69493: PUSH
69494: LD_INT 30
69496: PUSH
69497: LD_INT 4
69499: PUSH
69500: EMPTY
69501: LIST
69502: LIST
69503: PUSH
69504: LD_INT 30
69506: PUSH
69507: LD_INT 5
69509: PUSH
69510: EMPTY
69511: LIST
69512: LIST
69513: PUSH
69514: EMPTY
69515: LIST
69516: LIST
69517: LIST
69518: PPUSH
69519: CALL_OW 72
69523: ST_TO_ADDR
// if not tmp then
69524: LD_VAR 0 6
69528: NOT
69529: IFFALSE 69535
// exit ;
69531: POP
69532: POP
69533: GO 69615
// for j in tmp do
69535: LD_ADDR_VAR 0 4
69539: PUSH
69540: LD_VAR 0 6
69544: PUSH
69545: FOR_IN
69546: IFFALSE 69605
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
69548: LD_ADDR_VAR 0 7
69552: PUSH
69553: LD_VAR 0 4
69557: PPUSH
69558: CALL_OW 313
69562: PPUSH
69563: LD_INT 25
69565: PUSH
69566: LD_INT 1
69568: PUSH
69569: EMPTY
69570: LIST
69571: LIST
69572: PPUSH
69573: CALL_OW 72
69577: ST_TO_ADDR
// if units then
69578: LD_VAR 0 7
69582: IFFALSE 69603
// begin ComExitBuilding ( units [ 1 ] ) ;
69584: LD_VAR 0 7
69588: PUSH
69589: LD_INT 1
69591: ARRAY
69592: PPUSH
69593: CALL_OW 122
// exit ;
69597: POP
69598: POP
69599: POP
69600: POP
69601: GO 69615
// end ; end ;
69603: GO 69545
69605: POP
69606: POP
// end ; end ; exit ;
69607: POP
69608: POP
69609: GO 69615
// end ; end ;
69611: GO 68969
69613: POP
69614: POP
// end ;
69615: LD_VAR 0 2
69619: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
69620: LD_INT 0
69622: PPUSH
69623: PPUSH
69624: PPUSH
69625: PPUSH
69626: PPUSH
69627: PPUSH
69628: PPUSH
// if not mc_bases or not skirmish then
69629: LD_EXP 102
69633: NOT
69634: PUSH
69635: LD_EXP 100
69639: NOT
69640: OR
69641: IFFALSE 69645
// exit ;
69643: GO 69910
// btype := GetBType ( building ) ;
69645: LD_ADDR_VAR 0 6
69649: PUSH
69650: LD_VAR 0 1
69654: PPUSH
69655: CALL_OW 266
69659: ST_TO_ADDR
// x := GetX ( building ) ;
69660: LD_ADDR_VAR 0 7
69664: PUSH
69665: LD_VAR 0 1
69669: PPUSH
69670: CALL_OW 250
69674: ST_TO_ADDR
// y := GetY ( building ) ;
69675: LD_ADDR_VAR 0 8
69679: PUSH
69680: LD_VAR 0 1
69684: PPUSH
69685: CALL_OW 251
69689: ST_TO_ADDR
// d := GetDir ( building ) ;
69690: LD_ADDR_VAR 0 9
69694: PUSH
69695: LD_VAR 0 1
69699: PPUSH
69700: CALL_OW 254
69704: ST_TO_ADDR
// for i = 1 to mc_bases do
69705: LD_ADDR_VAR 0 4
69709: PUSH
69710: DOUBLE
69711: LD_INT 1
69713: DEC
69714: ST_TO_ADDR
69715: LD_EXP 102
69719: PUSH
69720: FOR_TO
69721: IFFALSE 69908
// begin if not mc_build_list [ i ] then
69723: LD_EXP 107
69727: PUSH
69728: LD_VAR 0 4
69732: ARRAY
69733: NOT
69734: IFFALSE 69738
// continue ;
69736: GO 69720
// for j := 1 to mc_build_list [ i ] do
69738: LD_ADDR_VAR 0 5
69742: PUSH
69743: DOUBLE
69744: LD_INT 1
69746: DEC
69747: ST_TO_ADDR
69748: LD_EXP 107
69752: PUSH
69753: LD_VAR 0 4
69757: ARRAY
69758: PUSH
69759: FOR_TO
69760: IFFALSE 69904
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
69762: LD_VAR 0 6
69766: PUSH
69767: LD_VAR 0 7
69771: PUSH
69772: LD_VAR 0 8
69776: PUSH
69777: LD_VAR 0 9
69781: PUSH
69782: EMPTY
69783: LIST
69784: LIST
69785: LIST
69786: LIST
69787: PPUSH
69788: LD_EXP 107
69792: PUSH
69793: LD_VAR 0 4
69797: ARRAY
69798: PUSH
69799: LD_VAR 0 5
69803: ARRAY
69804: PPUSH
69805: CALL 81791 0 2
69809: IFFALSE 69902
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
69811: LD_ADDR_EXP 107
69815: PUSH
69816: LD_EXP 107
69820: PPUSH
69821: LD_VAR 0 4
69825: PPUSH
69826: LD_EXP 107
69830: PUSH
69831: LD_VAR 0 4
69835: ARRAY
69836: PPUSH
69837: LD_VAR 0 5
69841: PPUSH
69842: CALL_OW 3
69846: PPUSH
69847: CALL_OW 1
69851: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
69852: LD_ADDR_EXP 109
69856: PUSH
69857: LD_EXP 109
69861: PPUSH
69862: LD_VAR 0 4
69866: PUSH
69867: LD_EXP 109
69871: PUSH
69872: LD_VAR 0 4
69876: ARRAY
69877: PUSH
69878: LD_INT 1
69880: PLUS
69881: PUSH
69882: EMPTY
69883: LIST
69884: LIST
69885: PPUSH
69886: LD_VAR 0 1
69890: PPUSH
69891: CALL 75234 0 3
69895: ST_TO_ADDR
// exit ;
69896: POP
69897: POP
69898: POP
69899: POP
69900: GO 69910
// end ;
69902: GO 69759
69904: POP
69905: POP
// end ;
69906: GO 69720
69908: POP
69909: POP
// end ;
69910: LD_VAR 0 3
69914: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
69915: LD_INT 0
69917: PPUSH
69918: PPUSH
69919: PPUSH
// if not mc_bases or not skirmish then
69920: LD_EXP 102
69924: NOT
69925: PUSH
69926: LD_EXP 100
69930: NOT
69931: OR
69932: IFFALSE 69936
// exit ;
69934: GO 70126
// for i = 1 to mc_bases do
69936: LD_ADDR_VAR 0 4
69940: PUSH
69941: DOUBLE
69942: LD_INT 1
69944: DEC
69945: ST_TO_ADDR
69946: LD_EXP 102
69950: PUSH
69951: FOR_TO
69952: IFFALSE 70039
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
69954: LD_VAR 0 1
69958: PUSH
69959: LD_EXP 110
69963: PUSH
69964: LD_VAR 0 4
69968: ARRAY
69969: IN
69970: PUSH
69971: LD_VAR 0 1
69975: PUSH
69976: LD_EXP 111
69980: PUSH
69981: LD_VAR 0 4
69985: ARRAY
69986: IN
69987: NOT
69988: AND
69989: IFFALSE 70037
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
69991: LD_ADDR_EXP 111
69995: PUSH
69996: LD_EXP 111
70000: PPUSH
70001: LD_VAR 0 4
70005: PUSH
70006: LD_EXP 111
70010: PUSH
70011: LD_VAR 0 4
70015: ARRAY
70016: PUSH
70017: LD_INT 1
70019: PLUS
70020: PUSH
70021: EMPTY
70022: LIST
70023: LIST
70024: PPUSH
70025: LD_VAR 0 1
70029: PPUSH
70030: CALL 75234 0 3
70034: ST_TO_ADDR
// break ;
70035: GO 70039
// end ; end ;
70037: GO 69951
70039: POP
70040: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
70041: LD_VAR 0 1
70045: PPUSH
70046: CALL_OW 257
70050: PUSH
70051: LD_EXP 128
70055: IN
70056: PUSH
70057: LD_VAR 0 1
70061: PPUSH
70062: CALL_OW 266
70066: PUSH
70067: LD_INT 5
70069: EQUAL
70070: AND
70071: PUSH
70072: LD_VAR 0 2
70076: PPUSH
70077: CALL_OW 110
70081: PUSH
70082: LD_INT 18
70084: NONEQUAL
70085: AND
70086: IFFALSE 70126
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
70088: LD_VAR 0 2
70092: PPUSH
70093: CALL_OW 257
70097: PUSH
70098: LD_INT 5
70100: PUSH
70101: LD_INT 8
70103: PUSH
70104: LD_INT 9
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: LIST
70111: IN
70112: IFFALSE 70126
// SetClass ( unit , 1 ) ;
70114: LD_VAR 0 2
70118: PPUSH
70119: LD_INT 1
70121: PPUSH
70122: CALL_OW 336
// end ;
70126: LD_VAR 0 3
70130: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
70131: LD_INT 0
70133: PPUSH
70134: PPUSH
// if not mc_bases or not skirmish then
70135: LD_EXP 102
70139: NOT
70140: PUSH
70141: LD_EXP 100
70145: NOT
70146: OR
70147: IFFALSE 70151
// exit ;
70149: GO 70267
// if GetLives ( abandoned_vehicle ) > 250 then
70151: LD_VAR 0 2
70155: PPUSH
70156: CALL_OW 256
70160: PUSH
70161: LD_INT 250
70163: GREATER
70164: IFFALSE 70168
// exit ;
70166: GO 70267
// for i = 1 to mc_bases do
70168: LD_ADDR_VAR 0 6
70172: PUSH
70173: DOUBLE
70174: LD_INT 1
70176: DEC
70177: ST_TO_ADDR
70178: LD_EXP 102
70182: PUSH
70183: FOR_TO
70184: IFFALSE 70265
// begin if driver in mc_bases [ i ] then
70186: LD_VAR 0 1
70190: PUSH
70191: LD_EXP 102
70195: PUSH
70196: LD_VAR 0 6
70200: ARRAY
70201: IN
70202: IFFALSE 70263
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
70204: LD_VAR 0 1
70208: PPUSH
70209: LD_EXP 102
70213: PUSH
70214: LD_VAR 0 6
70218: ARRAY
70219: PPUSH
70220: LD_INT 2
70222: PUSH
70223: LD_INT 30
70225: PUSH
70226: LD_INT 0
70228: PUSH
70229: EMPTY
70230: LIST
70231: LIST
70232: PUSH
70233: LD_INT 30
70235: PUSH
70236: LD_INT 1
70238: PUSH
70239: EMPTY
70240: LIST
70241: LIST
70242: PUSH
70243: EMPTY
70244: LIST
70245: LIST
70246: LIST
70247: PPUSH
70248: CALL_OW 72
70252: PUSH
70253: LD_INT 1
70255: ARRAY
70256: PPUSH
70257: CALL 108840 0 2
// break ;
70261: GO 70265
// end ; end ;
70263: GO 70183
70265: POP
70266: POP
// end ; end_of_file
70267: LD_VAR 0 5
70271: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
70272: LD_INT 0
70274: PPUSH
70275: PPUSH
// if exist_mode then
70276: LD_VAR 0 2
70280: IFFALSE 70305
// unit := CreateCharacter ( prefix & ident ) else
70282: LD_ADDR_VAR 0 5
70286: PUSH
70287: LD_VAR 0 3
70291: PUSH
70292: LD_VAR 0 1
70296: STR
70297: PPUSH
70298: CALL_OW 34
70302: ST_TO_ADDR
70303: GO 70320
// unit := NewCharacter ( ident ) ;
70305: LD_ADDR_VAR 0 5
70309: PUSH
70310: LD_VAR 0 1
70314: PPUSH
70315: CALL_OW 25
70319: ST_TO_ADDR
// result := unit ;
70320: LD_ADDR_VAR 0 4
70324: PUSH
70325: LD_VAR 0 5
70329: ST_TO_ADDR
// end ;
70330: LD_VAR 0 4
70334: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
70335: LD_INT 0
70337: PPUSH
70338: PPUSH
// if not side or not nation then
70339: LD_VAR 0 1
70343: NOT
70344: PUSH
70345: LD_VAR 0 2
70349: NOT
70350: OR
70351: IFFALSE 70355
// exit ;
70353: GO 71123
// case nation of nation_american :
70355: LD_VAR 0 2
70359: PUSH
70360: LD_INT 1
70362: DOUBLE
70363: EQUAL
70364: IFTRUE 70368
70366: GO 70582
70368: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
70369: LD_ADDR_VAR 0 4
70373: PUSH
70374: LD_INT 35
70376: PUSH
70377: LD_INT 45
70379: PUSH
70380: LD_INT 46
70382: PUSH
70383: LD_INT 47
70385: PUSH
70386: LD_INT 82
70388: PUSH
70389: LD_INT 83
70391: PUSH
70392: LD_INT 84
70394: PUSH
70395: LD_INT 85
70397: PUSH
70398: LD_INT 86
70400: PUSH
70401: LD_INT 1
70403: PUSH
70404: LD_INT 2
70406: PUSH
70407: LD_INT 6
70409: PUSH
70410: LD_INT 15
70412: PUSH
70413: LD_INT 16
70415: PUSH
70416: LD_INT 7
70418: PUSH
70419: LD_INT 12
70421: PUSH
70422: LD_INT 13
70424: PUSH
70425: LD_INT 10
70427: PUSH
70428: LD_INT 14
70430: PUSH
70431: LD_INT 20
70433: PUSH
70434: LD_INT 21
70436: PUSH
70437: LD_INT 22
70439: PUSH
70440: LD_INT 25
70442: PUSH
70443: LD_INT 32
70445: PUSH
70446: LD_INT 27
70448: PUSH
70449: LD_INT 36
70451: PUSH
70452: LD_INT 69
70454: PUSH
70455: LD_INT 39
70457: PUSH
70458: LD_INT 34
70460: PUSH
70461: LD_INT 40
70463: PUSH
70464: LD_INT 48
70466: PUSH
70467: LD_INT 49
70469: PUSH
70470: LD_INT 50
70472: PUSH
70473: LD_INT 51
70475: PUSH
70476: LD_INT 52
70478: PUSH
70479: LD_INT 53
70481: PUSH
70482: LD_INT 54
70484: PUSH
70485: LD_INT 55
70487: PUSH
70488: LD_INT 56
70490: PUSH
70491: LD_INT 57
70493: PUSH
70494: LD_INT 58
70496: PUSH
70497: LD_INT 59
70499: PUSH
70500: LD_INT 60
70502: PUSH
70503: LD_INT 61
70505: PUSH
70506: LD_INT 62
70508: PUSH
70509: LD_INT 80
70511: PUSH
70512: LD_INT 82
70514: PUSH
70515: LD_INT 83
70517: PUSH
70518: LD_INT 84
70520: PUSH
70521: LD_INT 85
70523: PUSH
70524: LD_INT 86
70526: PUSH
70527: EMPTY
70528: LIST
70529: LIST
70530: LIST
70531: LIST
70532: LIST
70533: LIST
70534: LIST
70535: LIST
70536: LIST
70537: LIST
70538: LIST
70539: LIST
70540: LIST
70541: LIST
70542: LIST
70543: LIST
70544: LIST
70545: LIST
70546: LIST
70547: LIST
70548: LIST
70549: LIST
70550: LIST
70551: LIST
70552: LIST
70553: LIST
70554: LIST
70555: LIST
70556: LIST
70557: LIST
70558: LIST
70559: LIST
70560: LIST
70561: LIST
70562: LIST
70563: LIST
70564: LIST
70565: LIST
70566: LIST
70567: LIST
70568: LIST
70569: LIST
70570: LIST
70571: LIST
70572: LIST
70573: LIST
70574: LIST
70575: LIST
70576: LIST
70577: LIST
70578: LIST
70579: ST_TO_ADDR
70580: GO 71047
70582: LD_INT 2
70584: DOUBLE
70585: EQUAL
70586: IFTRUE 70590
70588: GO 70816
70590: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
70591: LD_ADDR_VAR 0 4
70595: PUSH
70596: LD_INT 35
70598: PUSH
70599: LD_INT 45
70601: PUSH
70602: LD_INT 46
70604: PUSH
70605: LD_INT 47
70607: PUSH
70608: LD_INT 82
70610: PUSH
70611: LD_INT 83
70613: PUSH
70614: LD_INT 84
70616: PUSH
70617: LD_INT 85
70619: PUSH
70620: LD_INT 87
70622: PUSH
70623: LD_INT 70
70625: PUSH
70626: LD_INT 1
70628: PUSH
70629: LD_INT 11
70631: PUSH
70632: LD_INT 3
70634: PUSH
70635: LD_INT 4
70637: PUSH
70638: LD_INT 5
70640: PUSH
70641: LD_INT 6
70643: PUSH
70644: LD_INT 15
70646: PUSH
70647: LD_INT 18
70649: PUSH
70650: LD_INT 7
70652: PUSH
70653: LD_INT 17
70655: PUSH
70656: LD_INT 8
70658: PUSH
70659: LD_INT 20
70661: PUSH
70662: LD_INT 21
70664: PUSH
70665: LD_INT 22
70667: PUSH
70668: LD_INT 72
70670: PUSH
70671: LD_INT 26
70673: PUSH
70674: LD_INT 69
70676: PUSH
70677: LD_INT 39
70679: PUSH
70680: LD_INT 40
70682: PUSH
70683: LD_INT 41
70685: PUSH
70686: LD_INT 42
70688: PUSH
70689: LD_INT 43
70691: PUSH
70692: LD_INT 48
70694: PUSH
70695: LD_INT 49
70697: PUSH
70698: LD_INT 50
70700: PUSH
70701: LD_INT 51
70703: PUSH
70704: LD_INT 52
70706: PUSH
70707: LD_INT 53
70709: PUSH
70710: LD_INT 54
70712: PUSH
70713: LD_INT 55
70715: PUSH
70716: LD_INT 56
70718: PUSH
70719: LD_INT 60
70721: PUSH
70722: LD_INT 61
70724: PUSH
70725: LD_INT 62
70727: PUSH
70728: LD_INT 66
70730: PUSH
70731: LD_INT 67
70733: PUSH
70734: LD_INT 68
70736: PUSH
70737: LD_INT 81
70739: PUSH
70740: LD_INT 82
70742: PUSH
70743: LD_INT 83
70745: PUSH
70746: LD_INT 84
70748: PUSH
70749: LD_INT 85
70751: PUSH
70752: LD_INT 87
70754: PUSH
70755: LD_INT 88
70757: PUSH
70758: EMPTY
70759: LIST
70760: LIST
70761: LIST
70762: LIST
70763: LIST
70764: LIST
70765: LIST
70766: LIST
70767: LIST
70768: LIST
70769: LIST
70770: LIST
70771: LIST
70772: LIST
70773: LIST
70774: LIST
70775: LIST
70776: LIST
70777: LIST
70778: LIST
70779: LIST
70780: LIST
70781: LIST
70782: LIST
70783: LIST
70784: LIST
70785: LIST
70786: LIST
70787: LIST
70788: LIST
70789: LIST
70790: LIST
70791: LIST
70792: LIST
70793: LIST
70794: LIST
70795: LIST
70796: LIST
70797: LIST
70798: LIST
70799: LIST
70800: LIST
70801: LIST
70802: LIST
70803: LIST
70804: LIST
70805: LIST
70806: LIST
70807: LIST
70808: LIST
70809: LIST
70810: LIST
70811: LIST
70812: LIST
70813: ST_TO_ADDR
70814: GO 71047
70816: LD_INT 3
70818: DOUBLE
70819: EQUAL
70820: IFTRUE 70824
70822: GO 71046
70824: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
70825: LD_ADDR_VAR 0 4
70829: PUSH
70830: LD_INT 46
70832: PUSH
70833: LD_INT 47
70835: PUSH
70836: LD_INT 1
70838: PUSH
70839: LD_INT 2
70841: PUSH
70842: LD_INT 82
70844: PUSH
70845: LD_INT 83
70847: PUSH
70848: LD_INT 84
70850: PUSH
70851: LD_INT 85
70853: PUSH
70854: LD_INT 86
70856: PUSH
70857: LD_INT 11
70859: PUSH
70860: LD_INT 9
70862: PUSH
70863: LD_INT 20
70865: PUSH
70866: LD_INT 19
70868: PUSH
70869: LD_INT 21
70871: PUSH
70872: LD_INT 24
70874: PUSH
70875: LD_INT 22
70877: PUSH
70878: LD_INT 25
70880: PUSH
70881: LD_INT 28
70883: PUSH
70884: LD_INT 29
70886: PUSH
70887: LD_INT 30
70889: PUSH
70890: LD_INT 31
70892: PUSH
70893: LD_INT 37
70895: PUSH
70896: LD_INT 38
70898: PUSH
70899: LD_INT 32
70901: PUSH
70902: LD_INT 27
70904: PUSH
70905: LD_INT 33
70907: PUSH
70908: LD_INT 69
70910: PUSH
70911: LD_INT 39
70913: PUSH
70914: LD_INT 34
70916: PUSH
70917: LD_INT 40
70919: PUSH
70920: LD_INT 71
70922: PUSH
70923: LD_INT 23
70925: PUSH
70926: LD_INT 44
70928: PUSH
70929: LD_INT 48
70931: PUSH
70932: LD_INT 49
70934: PUSH
70935: LD_INT 50
70937: PUSH
70938: LD_INT 51
70940: PUSH
70941: LD_INT 52
70943: PUSH
70944: LD_INT 53
70946: PUSH
70947: LD_INT 54
70949: PUSH
70950: LD_INT 55
70952: PUSH
70953: LD_INT 56
70955: PUSH
70956: LD_INT 57
70958: PUSH
70959: LD_INT 58
70961: PUSH
70962: LD_INT 59
70964: PUSH
70965: LD_INT 63
70967: PUSH
70968: LD_INT 64
70970: PUSH
70971: LD_INT 65
70973: PUSH
70974: LD_INT 82
70976: PUSH
70977: LD_INT 83
70979: PUSH
70980: LD_INT 84
70982: PUSH
70983: LD_INT 85
70985: PUSH
70986: LD_INT 86
70988: PUSH
70989: EMPTY
70990: LIST
70991: LIST
70992: LIST
70993: LIST
70994: LIST
70995: LIST
70996: LIST
70997: LIST
70998: LIST
70999: LIST
71000: LIST
71001: LIST
71002: LIST
71003: LIST
71004: LIST
71005: LIST
71006: LIST
71007: LIST
71008: LIST
71009: LIST
71010: LIST
71011: LIST
71012: LIST
71013: LIST
71014: LIST
71015: LIST
71016: LIST
71017: LIST
71018: LIST
71019: LIST
71020: LIST
71021: LIST
71022: LIST
71023: LIST
71024: LIST
71025: LIST
71026: LIST
71027: LIST
71028: LIST
71029: LIST
71030: LIST
71031: LIST
71032: LIST
71033: LIST
71034: LIST
71035: LIST
71036: LIST
71037: LIST
71038: LIST
71039: LIST
71040: LIST
71041: LIST
71042: LIST
71043: ST_TO_ADDR
71044: GO 71047
71046: POP
// if state > - 1 and state < 3 then
71047: LD_VAR 0 3
71051: PUSH
71052: LD_INT 1
71054: NEG
71055: GREATER
71056: PUSH
71057: LD_VAR 0 3
71061: PUSH
71062: LD_INT 3
71064: LESS
71065: AND
71066: IFFALSE 71123
// for i in result do
71068: LD_ADDR_VAR 0 5
71072: PUSH
71073: LD_VAR 0 4
71077: PUSH
71078: FOR_IN
71079: IFFALSE 71121
// if GetTech ( i , side ) <> state then
71081: LD_VAR 0 5
71085: PPUSH
71086: LD_VAR 0 1
71090: PPUSH
71091: CALL_OW 321
71095: PUSH
71096: LD_VAR 0 3
71100: NONEQUAL
71101: IFFALSE 71119
// result := result diff i ;
71103: LD_ADDR_VAR 0 4
71107: PUSH
71108: LD_VAR 0 4
71112: PUSH
71113: LD_VAR 0 5
71117: DIFF
71118: ST_TO_ADDR
71119: GO 71078
71121: POP
71122: POP
// end ;
71123: LD_VAR 0 4
71127: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
71128: LD_INT 0
71130: PPUSH
71131: PPUSH
71132: PPUSH
// result := true ;
71133: LD_ADDR_VAR 0 3
71137: PUSH
71138: LD_INT 1
71140: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
71141: LD_ADDR_VAR 0 5
71145: PUSH
71146: LD_VAR 0 2
71150: PPUSH
71151: CALL_OW 480
71155: ST_TO_ADDR
// if not tmp then
71156: LD_VAR 0 5
71160: NOT
71161: IFFALSE 71165
// exit ;
71163: GO 71214
// for i in tmp do
71165: LD_ADDR_VAR 0 4
71169: PUSH
71170: LD_VAR 0 5
71174: PUSH
71175: FOR_IN
71176: IFFALSE 71212
// if GetTech ( i , side ) <> state_researched then
71178: LD_VAR 0 4
71182: PPUSH
71183: LD_VAR 0 1
71187: PPUSH
71188: CALL_OW 321
71192: PUSH
71193: LD_INT 2
71195: NONEQUAL
71196: IFFALSE 71210
// begin result := false ;
71198: LD_ADDR_VAR 0 3
71202: PUSH
71203: LD_INT 0
71205: ST_TO_ADDR
// exit ;
71206: POP
71207: POP
71208: GO 71214
// end ;
71210: GO 71175
71212: POP
71213: POP
// end ;
71214: LD_VAR 0 3
71218: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
71219: LD_INT 0
71221: PPUSH
71222: PPUSH
71223: PPUSH
71224: PPUSH
71225: PPUSH
71226: PPUSH
71227: PPUSH
71228: PPUSH
71229: PPUSH
71230: PPUSH
71231: PPUSH
71232: PPUSH
71233: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
71234: LD_VAR 0 1
71238: NOT
71239: PUSH
71240: LD_VAR 0 1
71244: PPUSH
71245: CALL_OW 257
71249: PUSH
71250: LD_INT 9
71252: NONEQUAL
71253: OR
71254: IFFALSE 71258
// exit ;
71256: GO 71831
// side := GetSide ( unit ) ;
71258: LD_ADDR_VAR 0 9
71262: PUSH
71263: LD_VAR 0 1
71267: PPUSH
71268: CALL_OW 255
71272: ST_TO_ADDR
// tech_space := tech_spacanom ;
71273: LD_ADDR_VAR 0 12
71277: PUSH
71278: LD_INT 29
71280: ST_TO_ADDR
// tech_time := tech_taurad ;
71281: LD_ADDR_VAR 0 13
71285: PUSH
71286: LD_INT 28
71288: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
71289: LD_ADDR_VAR 0 11
71293: PUSH
71294: LD_VAR 0 1
71298: PPUSH
71299: CALL_OW 310
71303: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
71304: LD_VAR 0 11
71308: PPUSH
71309: CALL_OW 247
71313: PUSH
71314: LD_INT 2
71316: EQUAL
71317: IFFALSE 71321
// exit ;
71319: GO 71831
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71321: LD_ADDR_VAR 0 8
71325: PUSH
71326: LD_INT 81
71328: PUSH
71329: LD_VAR 0 9
71333: PUSH
71334: EMPTY
71335: LIST
71336: LIST
71337: PUSH
71338: LD_INT 3
71340: PUSH
71341: LD_INT 21
71343: PUSH
71344: LD_INT 3
71346: PUSH
71347: EMPTY
71348: LIST
71349: LIST
71350: PUSH
71351: EMPTY
71352: LIST
71353: LIST
71354: PUSH
71355: EMPTY
71356: LIST
71357: LIST
71358: PPUSH
71359: CALL_OW 69
71363: ST_TO_ADDR
// if not tmp then
71364: LD_VAR 0 8
71368: NOT
71369: IFFALSE 71373
// exit ;
71371: GO 71831
// if in_unit then
71373: LD_VAR 0 11
71377: IFFALSE 71401
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
71379: LD_ADDR_VAR 0 10
71383: PUSH
71384: LD_VAR 0 8
71388: PPUSH
71389: LD_VAR 0 11
71393: PPUSH
71394: CALL_OW 74
71398: ST_TO_ADDR
71399: GO 71421
// enemy := NearestUnitToUnit ( tmp , unit ) ;
71401: LD_ADDR_VAR 0 10
71405: PUSH
71406: LD_VAR 0 8
71410: PPUSH
71411: LD_VAR 0 1
71415: PPUSH
71416: CALL_OW 74
71420: ST_TO_ADDR
// if not enemy then
71421: LD_VAR 0 10
71425: NOT
71426: IFFALSE 71430
// exit ;
71428: GO 71831
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
71430: LD_VAR 0 11
71434: PUSH
71435: LD_VAR 0 11
71439: PPUSH
71440: LD_VAR 0 10
71444: PPUSH
71445: CALL_OW 296
71449: PUSH
71450: LD_INT 13
71452: GREATER
71453: AND
71454: PUSH
71455: LD_VAR 0 1
71459: PPUSH
71460: LD_VAR 0 10
71464: PPUSH
71465: CALL_OW 296
71469: PUSH
71470: LD_INT 12
71472: GREATER
71473: OR
71474: IFFALSE 71478
// exit ;
71476: GO 71831
// missile := [ 1 ] ;
71478: LD_ADDR_VAR 0 14
71482: PUSH
71483: LD_INT 1
71485: PUSH
71486: EMPTY
71487: LIST
71488: ST_TO_ADDR
// if Researched ( side , tech_space ) then
71489: LD_VAR 0 9
71493: PPUSH
71494: LD_VAR 0 12
71498: PPUSH
71499: CALL_OW 325
71503: IFFALSE 71532
// missile := Replace ( missile , missile + 1 , 2 ) ;
71505: LD_ADDR_VAR 0 14
71509: PUSH
71510: LD_VAR 0 14
71514: PPUSH
71515: LD_VAR 0 14
71519: PUSH
71520: LD_INT 1
71522: PLUS
71523: PPUSH
71524: LD_INT 2
71526: PPUSH
71527: CALL_OW 1
71531: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
71532: LD_VAR 0 9
71536: PPUSH
71537: LD_VAR 0 13
71541: PPUSH
71542: CALL_OW 325
71546: PUSH
71547: LD_VAR 0 10
71551: PPUSH
71552: CALL_OW 255
71556: PPUSH
71557: LD_VAR 0 13
71561: PPUSH
71562: CALL_OW 325
71566: NOT
71567: AND
71568: IFFALSE 71597
// missile := Replace ( missile , missile + 1 , 3 ) ;
71570: LD_ADDR_VAR 0 14
71574: PUSH
71575: LD_VAR 0 14
71579: PPUSH
71580: LD_VAR 0 14
71584: PUSH
71585: LD_INT 1
71587: PLUS
71588: PPUSH
71589: LD_INT 3
71591: PPUSH
71592: CALL_OW 1
71596: ST_TO_ADDR
// if missile < 2 then
71597: LD_VAR 0 14
71601: PUSH
71602: LD_INT 2
71604: LESS
71605: IFFALSE 71609
// exit ;
71607: GO 71831
// x := GetX ( enemy ) ;
71609: LD_ADDR_VAR 0 4
71613: PUSH
71614: LD_VAR 0 10
71618: PPUSH
71619: CALL_OW 250
71623: ST_TO_ADDR
// y := GetY ( enemy ) ;
71624: LD_ADDR_VAR 0 5
71628: PUSH
71629: LD_VAR 0 10
71633: PPUSH
71634: CALL_OW 251
71638: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
71639: LD_ADDR_VAR 0 6
71643: PUSH
71644: LD_VAR 0 4
71648: PUSH
71649: LD_INT 1
71651: NEG
71652: PPUSH
71653: LD_INT 1
71655: PPUSH
71656: CALL_OW 12
71660: PLUS
71661: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
71662: LD_ADDR_VAR 0 7
71666: PUSH
71667: LD_VAR 0 5
71671: PUSH
71672: LD_INT 1
71674: NEG
71675: PPUSH
71676: LD_INT 1
71678: PPUSH
71679: CALL_OW 12
71683: PLUS
71684: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
71685: LD_VAR 0 6
71689: PPUSH
71690: LD_VAR 0 7
71694: PPUSH
71695: CALL_OW 488
71699: NOT
71700: IFFALSE 71722
// begin _x := x ;
71702: LD_ADDR_VAR 0 6
71706: PUSH
71707: LD_VAR 0 4
71711: ST_TO_ADDR
// _y := y ;
71712: LD_ADDR_VAR 0 7
71716: PUSH
71717: LD_VAR 0 5
71721: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
71722: LD_ADDR_VAR 0 3
71726: PUSH
71727: LD_INT 1
71729: PPUSH
71730: LD_VAR 0 14
71734: PPUSH
71735: CALL_OW 12
71739: ST_TO_ADDR
// case i of 1 :
71740: LD_VAR 0 3
71744: PUSH
71745: LD_INT 1
71747: DOUBLE
71748: EQUAL
71749: IFTRUE 71753
71751: GO 71770
71753: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
71754: LD_VAR 0 1
71758: PPUSH
71759: LD_VAR 0 10
71763: PPUSH
71764: CALL_OW 115
71768: GO 71831
71770: LD_INT 2
71772: DOUBLE
71773: EQUAL
71774: IFTRUE 71778
71776: GO 71800
71778: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
71779: LD_VAR 0 1
71783: PPUSH
71784: LD_VAR 0 6
71788: PPUSH
71789: LD_VAR 0 7
71793: PPUSH
71794: CALL_OW 153
71798: GO 71831
71800: LD_INT 3
71802: DOUBLE
71803: EQUAL
71804: IFTRUE 71808
71806: GO 71830
71808: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
71809: LD_VAR 0 1
71813: PPUSH
71814: LD_VAR 0 6
71818: PPUSH
71819: LD_VAR 0 7
71823: PPUSH
71824: CALL_OW 154
71828: GO 71831
71830: POP
// end ;
71831: LD_VAR 0 2
71835: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
71836: LD_INT 0
71838: PPUSH
71839: PPUSH
71840: PPUSH
71841: PPUSH
71842: PPUSH
71843: PPUSH
// if not unit or not building then
71844: LD_VAR 0 1
71848: NOT
71849: PUSH
71850: LD_VAR 0 2
71854: NOT
71855: OR
71856: IFFALSE 71860
// exit ;
71858: GO 72018
// x := GetX ( building ) ;
71860: LD_ADDR_VAR 0 5
71864: PUSH
71865: LD_VAR 0 2
71869: PPUSH
71870: CALL_OW 250
71874: ST_TO_ADDR
// y := GetY ( building ) ;
71875: LD_ADDR_VAR 0 6
71879: PUSH
71880: LD_VAR 0 2
71884: PPUSH
71885: CALL_OW 251
71889: ST_TO_ADDR
// for i = 0 to 5 do
71890: LD_ADDR_VAR 0 4
71894: PUSH
71895: DOUBLE
71896: LD_INT 0
71898: DEC
71899: ST_TO_ADDR
71900: LD_INT 5
71902: PUSH
71903: FOR_TO
71904: IFFALSE 72016
// begin _x := ShiftX ( x , i , 3 ) ;
71906: LD_ADDR_VAR 0 7
71910: PUSH
71911: LD_VAR 0 5
71915: PPUSH
71916: LD_VAR 0 4
71920: PPUSH
71921: LD_INT 3
71923: PPUSH
71924: CALL_OW 272
71928: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
71929: LD_ADDR_VAR 0 8
71933: PUSH
71934: LD_VAR 0 6
71938: PPUSH
71939: LD_VAR 0 4
71943: PPUSH
71944: LD_INT 3
71946: PPUSH
71947: CALL_OW 273
71951: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
71952: LD_VAR 0 7
71956: PPUSH
71957: LD_VAR 0 8
71961: PPUSH
71962: CALL_OW 488
71966: NOT
71967: IFFALSE 71971
// continue ;
71969: GO 71903
// if HexInfo ( _x , _y ) = 0 then
71971: LD_VAR 0 7
71975: PPUSH
71976: LD_VAR 0 8
71980: PPUSH
71981: CALL_OW 428
71985: PUSH
71986: LD_INT 0
71988: EQUAL
71989: IFFALSE 72014
// begin ComMoveXY ( unit , _x , _y ) ;
71991: LD_VAR 0 1
71995: PPUSH
71996: LD_VAR 0 7
72000: PPUSH
72001: LD_VAR 0 8
72005: PPUSH
72006: CALL_OW 111
// exit ;
72010: POP
72011: POP
72012: GO 72018
// end ; end ;
72014: GO 71903
72016: POP
72017: POP
// end ;
72018: LD_VAR 0 3
72022: RET
// export function ScanBase ( side , base_area ) ; begin
72023: LD_INT 0
72025: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
72026: LD_ADDR_VAR 0 3
72030: PUSH
72031: LD_VAR 0 2
72035: PPUSH
72036: LD_INT 81
72038: PUSH
72039: LD_VAR 0 1
72043: PUSH
72044: EMPTY
72045: LIST
72046: LIST
72047: PPUSH
72048: CALL_OW 70
72052: ST_TO_ADDR
// end ;
72053: LD_VAR 0 3
72057: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
72058: LD_INT 0
72060: PPUSH
72061: PPUSH
72062: PPUSH
72063: PPUSH
// result := false ;
72064: LD_ADDR_VAR 0 2
72068: PUSH
72069: LD_INT 0
72071: ST_TO_ADDR
// side := GetSide ( unit ) ;
72072: LD_ADDR_VAR 0 3
72076: PUSH
72077: LD_VAR 0 1
72081: PPUSH
72082: CALL_OW 255
72086: ST_TO_ADDR
// nat := GetNation ( unit ) ;
72087: LD_ADDR_VAR 0 4
72091: PUSH
72092: LD_VAR 0 1
72096: PPUSH
72097: CALL_OW 248
72101: ST_TO_ADDR
// case nat of 1 :
72102: LD_VAR 0 4
72106: PUSH
72107: LD_INT 1
72109: DOUBLE
72110: EQUAL
72111: IFTRUE 72115
72113: GO 72126
72115: POP
// tech := tech_lassight ; 2 :
72116: LD_ADDR_VAR 0 5
72120: PUSH
72121: LD_INT 12
72123: ST_TO_ADDR
72124: GO 72165
72126: LD_INT 2
72128: DOUBLE
72129: EQUAL
72130: IFTRUE 72134
72132: GO 72145
72134: POP
// tech := tech_mortar ; 3 :
72135: LD_ADDR_VAR 0 5
72139: PUSH
72140: LD_INT 41
72142: ST_TO_ADDR
72143: GO 72165
72145: LD_INT 3
72147: DOUBLE
72148: EQUAL
72149: IFTRUE 72153
72151: GO 72164
72153: POP
// tech := tech_bazooka ; end ;
72154: LD_ADDR_VAR 0 5
72158: PUSH
72159: LD_INT 44
72161: ST_TO_ADDR
72162: GO 72165
72164: POP
// if Researched ( side , tech ) then
72165: LD_VAR 0 3
72169: PPUSH
72170: LD_VAR 0 5
72174: PPUSH
72175: CALL_OW 325
72179: IFFALSE 72206
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
72181: LD_ADDR_VAR 0 2
72185: PUSH
72186: LD_INT 5
72188: PUSH
72189: LD_INT 8
72191: PUSH
72192: LD_INT 9
72194: PUSH
72195: EMPTY
72196: LIST
72197: LIST
72198: LIST
72199: PUSH
72200: LD_VAR 0 4
72204: ARRAY
72205: ST_TO_ADDR
// end ;
72206: LD_VAR 0 2
72210: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
72211: LD_INT 0
72213: PPUSH
72214: PPUSH
72215: PPUSH
// if not mines then
72216: LD_VAR 0 2
72220: NOT
72221: IFFALSE 72225
// exit ;
72223: GO 72369
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72225: LD_ADDR_VAR 0 5
72229: PUSH
72230: LD_INT 81
72232: PUSH
72233: LD_VAR 0 1
72237: PUSH
72238: EMPTY
72239: LIST
72240: LIST
72241: PUSH
72242: LD_INT 3
72244: PUSH
72245: LD_INT 21
72247: PUSH
72248: LD_INT 3
72250: PUSH
72251: EMPTY
72252: LIST
72253: LIST
72254: PUSH
72255: EMPTY
72256: LIST
72257: LIST
72258: PUSH
72259: EMPTY
72260: LIST
72261: LIST
72262: PPUSH
72263: CALL_OW 69
72267: ST_TO_ADDR
// for i in mines do
72268: LD_ADDR_VAR 0 4
72272: PUSH
72273: LD_VAR 0 2
72277: PUSH
72278: FOR_IN
72279: IFFALSE 72367
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
72281: LD_VAR 0 4
72285: PUSH
72286: LD_INT 1
72288: ARRAY
72289: PPUSH
72290: LD_VAR 0 4
72294: PUSH
72295: LD_INT 2
72297: ARRAY
72298: PPUSH
72299: CALL_OW 458
72303: NOT
72304: IFFALSE 72308
// continue ;
72306: GO 72278
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
72308: LD_VAR 0 4
72312: PUSH
72313: LD_INT 1
72315: ARRAY
72316: PPUSH
72317: LD_VAR 0 4
72321: PUSH
72322: LD_INT 2
72324: ARRAY
72325: PPUSH
72326: CALL_OW 428
72330: PUSH
72331: LD_VAR 0 5
72335: IN
72336: IFFALSE 72365
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
72338: LD_VAR 0 4
72342: PUSH
72343: LD_INT 1
72345: ARRAY
72346: PPUSH
72347: LD_VAR 0 4
72351: PUSH
72352: LD_INT 2
72354: ARRAY
72355: PPUSH
72356: LD_VAR 0 1
72360: PPUSH
72361: CALL_OW 456
// end ;
72365: GO 72278
72367: POP
72368: POP
// end ;
72369: LD_VAR 0 3
72373: RET
// export function Count ( array ) ; begin
72374: LD_INT 0
72376: PPUSH
// result := array + 0 ;
72377: LD_ADDR_VAR 0 2
72381: PUSH
72382: LD_VAR 0 1
72386: PUSH
72387: LD_INT 0
72389: PLUS
72390: ST_TO_ADDR
// end ;
72391: LD_VAR 0 2
72395: RET
// export function IsEmpty ( building ) ; begin
72396: LD_INT 0
72398: PPUSH
// if not building then
72399: LD_VAR 0 1
72403: NOT
72404: IFFALSE 72408
// exit ;
72406: GO 72451
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
72408: LD_ADDR_VAR 0 2
72412: PUSH
72413: LD_VAR 0 1
72417: PUSH
72418: LD_INT 22
72420: PUSH
72421: LD_VAR 0 1
72425: PPUSH
72426: CALL_OW 255
72430: PUSH
72431: EMPTY
72432: LIST
72433: LIST
72434: PUSH
72435: LD_INT 58
72437: PUSH
72438: EMPTY
72439: LIST
72440: PUSH
72441: EMPTY
72442: LIST
72443: LIST
72444: PPUSH
72445: CALL_OW 69
72449: IN
72450: ST_TO_ADDR
// end ;
72451: LD_VAR 0 2
72455: RET
// export function IsNotFull ( building ) ; var places ; begin
72456: LD_INT 0
72458: PPUSH
72459: PPUSH
// if not building then
72460: LD_VAR 0 1
72464: NOT
72465: IFFALSE 72469
// exit ;
72467: GO 72497
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
72469: LD_ADDR_VAR 0 2
72473: PUSH
72474: LD_VAR 0 1
72478: PPUSH
72479: LD_INT 3
72481: PUSH
72482: LD_INT 62
72484: PUSH
72485: EMPTY
72486: LIST
72487: PUSH
72488: EMPTY
72489: LIST
72490: LIST
72491: PPUSH
72492: CALL_OW 72
72496: ST_TO_ADDR
// end ;
72497: LD_VAR 0 2
72501: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
72502: LD_INT 0
72504: PPUSH
72505: PPUSH
72506: PPUSH
72507: PPUSH
// tmp := [ ] ;
72508: LD_ADDR_VAR 0 3
72512: PUSH
72513: EMPTY
72514: ST_TO_ADDR
// list := [ ] ;
72515: LD_ADDR_VAR 0 5
72519: PUSH
72520: EMPTY
72521: ST_TO_ADDR
// for i = 16 to 25 do
72522: LD_ADDR_VAR 0 4
72526: PUSH
72527: DOUBLE
72528: LD_INT 16
72530: DEC
72531: ST_TO_ADDR
72532: LD_INT 25
72534: PUSH
72535: FOR_TO
72536: IFFALSE 72609
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
72538: LD_ADDR_VAR 0 3
72542: PUSH
72543: LD_VAR 0 3
72547: PUSH
72548: LD_INT 22
72550: PUSH
72551: LD_VAR 0 1
72555: PPUSH
72556: CALL_OW 255
72560: PUSH
72561: EMPTY
72562: LIST
72563: LIST
72564: PUSH
72565: LD_INT 91
72567: PUSH
72568: LD_VAR 0 1
72572: PUSH
72573: LD_INT 6
72575: PUSH
72576: EMPTY
72577: LIST
72578: LIST
72579: LIST
72580: PUSH
72581: LD_INT 30
72583: PUSH
72584: LD_VAR 0 4
72588: PUSH
72589: EMPTY
72590: LIST
72591: LIST
72592: PUSH
72593: EMPTY
72594: LIST
72595: LIST
72596: LIST
72597: PUSH
72598: EMPTY
72599: LIST
72600: PPUSH
72601: CALL_OW 69
72605: ADD
72606: ST_TO_ADDR
72607: GO 72535
72609: POP
72610: POP
// for i = 1 to tmp do
72611: LD_ADDR_VAR 0 4
72615: PUSH
72616: DOUBLE
72617: LD_INT 1
72619: DEC
72620: ST_TO_ADDR
72621: LD_VAR 0 3
72625: PUSH
72626: FOR_TO
72627: IFFALSE 72715
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
72629: LD_ADDR_VAR 0 5
72633: PUSH
72634: LD_VAR 0 5
72638: PUSH
72639: LD_VAR 0 3
72643: PUSH
72644: LD_VAR 0 4
72648: ARRAY
72649: PPUSH
72650: CALL_OW 266
72654: PUSH
72655: LD_VAR 0 3
72659: PUSH
72660: LD_VAR 0 4
72664: ARRAY
72665: PPUSH
72666: CALL_OW 250
72670: PUSH
72671: LD_VAR 0 3
72675: PUSH
72676: LD_VAR 0 4
72680: ARRAY
72681: PPUSH
72682: CALL_OW 251
72686: PUSH
72687: LD_VAR 0 3
72691: PUSH
72692: LD_VAR 0 4
72696: ARRAY
72697: PPUSH
72698: CALL_OW 254
72702: PUSH
72703: EMPTY
72704: LIST
72705: LIST
72706: LIST
72707: LIST
72708: PUSH
72709: EMPTY
72710: LIST
72711: ADD
72712: ST_TO_ADDR
72713: GO 72626
72715: POP
72716: POP
// result := list ;
72717: LD_ADDR_VAR 0 2
72721: PUSH
72722: LD_VAR 0 5
72726: ST_TO_ADDR
// end ;
72727: LD_VAR 0 2
72731: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
72732: LD_INT 0
72734: PPUSH
72735: PPUSH
72736: PPUSH
72737: PPUSH
72738: PPUSH
72739: PPUSH
72740: PPUSH
// if not factory then
72741: LD_VAR 0 1
72745: NOT
72746: IFFALSE 72750
// exit ;
72748: GO 73343
// if control = control_apeman then
72750: LD_VAR 0 4
72754: PUSH
72755: LD_INT 5
72757: EQUAL
72758: IFFALSE 72867
// begin tmp := UnitsInside ( factory ) ;
72760: LD_ADDR_VAR 0 8
72764: PUSH
72765: LD_VAR 0 1
72769: PPUSH
72770: CALL_OW 313
72774: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
72775: LD_VAR 0 8
72779: PPUSH
72780: LD_INT 25
72782: PUSH
72783: LD_INT 12
72785: PUSH
72786: EMPTY
72787: LIST
72788: LIST
72789: PPUSH
72790: CALL_OW 72
72794: NOT
72795: IFFALSE 72805
// control := control_manual ;
72797: LD_ADDR_VAR 0 4
72801: PUSH
72802: LD_INT 1
72804: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
72805: LD_ADDR_VAR 0 8
72809: PUSH
72810: LD_VAR 0 1
72814: PPUSH
72815: CALL 72502 0 1
72819: ST_TO_ADDR
// if tmp then
72820: LD_VAR 0 8
72824: IFFALSE 72867
// begin for i in tmp do
72826: LD_ADDR_VAR 0 7
72830: PUSH
72831: LD_VAR 0 8
72835: PUSH
72836: FOR_IN
72837: IFFALSE 72865
// if i [ 1 ] = b_ext_radio then
72839: LD_VAR 0 7
72843: PUSH
72844: LD_INT 1
72846: ARRAY
72847: PUSH
72848: LD_INT 22
72850: EQUAL
72851: IFFALSE 72863
// begin control := control_remote ;
72853: LD_ADDR_VAR 0 4
72857: PUSH
72858: LD_INT 2
72860: ST_TO_ADDR
// break ;
72861: GO 72865
// end ;
72863: GO 72836
72865: POP
72866: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
72867: LD_VAR 0 1
72871: PPUSH
72872: LD_VAR 0 2
72876: PPUSH
72877: LD_VAR 0 3
72881: PPUSH
72882: LD_VAR 0 4
72886: PPUSH
72887: LD_VAR 0 5
72891: PPUSH
72892: CALL_OW 448
72896: IFFALSE 72931
// begin result := [ chassis , engine , control , weapon ] ;
72898: LD_ADDR_VAR 0 6
72902: PUSH
72903: LD_VAR 0 2
72907: PUSH
72908: LD_VAR 0 3
72912: PUSH
72913: LD_VAR 0 4
72917: PUSH
72918: LD_VAR 0 5
72922: PUSH
72923: EMPTY
72924: LIST
72925: LIST
72926: LIST
72927: LIST
72928: ST_TO_ADDR
// exit ;
72929: GO 73343
// end ; _chassis := AvailableChassisList ( factory ) ;
72931: LD_ADDR_VAR 0 9
72935: PUSH
72936: LD_VAR 0 1
72940: PPUSH
72941: CALL_OW 475
72945: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
72946: LD_ADDR_VAR 0 11
72950: PUSH
72951: LD_VAR 0 1
72955: PPUSH
72956: CALL_OW 476
72960: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
72961: LD_ADDR_VAR 0 12
72965: PUSH
72966: LD_VAR 0 1
72970: PPUSH
72971: CALL_OW 477
72975: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
72976: LD_ADDR_VAR 0 10
72980: PUSH
72981: LD_VAR 0 1
72985: PPUSH
72986: CALL_OW 478
72990: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
72991: LD_VAR 0 9
72995: NOT
72996: PUSH
72997: LD_VAR 0 11
73001: NOT
73002: OR
73003: PUSH
73004: LD_VAR 0 12
73008: NOT
73009: OR
73010: PUSH
73011: LD_VAR 0 10
73015: NOT
73016: OR
73017: IFFALSE 73052
// begin result := [ chassis , engine , control , weapon ] ;
73019: LD_ADDR_VAR 0 6
73023: PUSH
73024: LD_VAR 0 2
73028: PUSH
73029: LD_VAR 0 3
73033: PUSH
73034: LD_VAR 0 4
73038: PUSH
73039: LD_VAR 0 5
73043: PUSH
73044: EMPTY
73045: LIST
73046: LIST
73047: LIST
73048: LIST
73049: ST_TO_ADDR
// exit ;
73050: GO 73343
// end ; if not chassis in _chassis then
73052: LD_VAR 0 2
73056: PUSH
73057: LD_VAR 0 9
73061: IN
73062: NOT
73063: IFFALSE 73089
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
73065: LD_ADDR_VAR 0 2
73069: PUSH
73070: LD_VAR 0 9
73074: PUSH
73075: LD_INT 1
73077: PPUSH
73078: LD_VAR 0 9
73082: PPUSH
73083: CALL_OW 12
73087: ARRAY
73088: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
73089: LD_VAR 0 2
73093: PPUSH
73094: LD_VAR 0 3
73098: PPUSH
73099: CALL 73348 0 2
73103: NOT
73104: IFFALSE 73163
// repeat engine := _engine [ 1 ] ;
73106: LD_ADDR_VAR 0 3
73110: PUSH
73111: LD_VAR 0 11
73115: PUSH
73116: LD_INT 1
73118: ARRAY
73119: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
73120: LD_ADDR_VAR 0 11
73124: PUSH
73125: LD_VAR 0 11
73129: PPUSH
73130: LD_INT 1
73132: PPUSH
73133: CALL_OW 3
73137: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
73138: LD_VAR 0 2
73142: PPUSH
73143: LD_VAR 0 3
73147: PPUSH
73148: CALL 73348 0 2
73152: PUSH
73153: LD_VAR 0 11
73157: PUSH
73158: EMPTY
73159: EQUAL
73160: OR
73161: IFFALSE 73106
// if not control in _control then
73163: LD_VAR 0 4
73167: PUSH
73168: LD_VAR 0 12
73172: IN
73173: NOT
73174: IFFALSE 73200
// control := _control [ rand ( 1 , _control ) ] ;
73176: LD_ADDR_VAR 0 4
73180: PUSH
73181: LD_VAR 0 12
73185: PUSH
73186: LD_INT 1
73188: PPUSH
73189: LD_VAR 0 12
73193: PPUSH
73194: CALL_OW 12
73198: ARRAY
73199: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
73200: LD_VAR 0 2
73204: PPUSH
73205: LD_VAR 0 5
73209: PPUSH
73210: CALL 73568 0 2
73214: NOT
73215: IFFALSE 73274
// repeat weapon := _weapon [ 1 ] ;
73217: LD_ADDR_VAR 0 5
73221: PUSH
73222: LD_VAR 0 10
73226: PUSH
73227: LD_INT 1
73229: ARRAY
73230: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
73231: LD_ADDR_VAR 0 10
73235: PUSH
73236: LD_VAR 0 10
73240: PPUSH
73241: LD_INT 1
73243: PPUSH
73244: CALL_OW 3
73248: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
73249: LD_VAR 0 2
73253: PPUSH
73254: LD_VAR 0 5
73258: PPUSH
73259: CALL 73568 0 2
73263: PUSH
73264: LD_VAR 0 10
73268: PUSH
73269: EMPTY
73270: EQUAL
73271: OR
73272: IFFALSE 73217
// result := [ ] ;
73274: LD_ADDR_VAR 0 6
73278: PUSH
73279: EMPTY
73280: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
73281: LD_VAR 0 1
73285: PPUSH
73286: LD_VAR 0 2
73290: PPUSH
73291: LD_VAR 0 3
73295: PPUSH
73296: LD_VAR 0 4
73300: PPUSH
73301: LD_VAR 0 5
73305: PPUSH
73306: CALL_OW 448
73310: IFFALSE 73343
// result := [ chassis , engine , control , weapon ] ;
73312: LD_ADDR_VAR 0 6
73316: PUSH
73317: LD_VAR 0 2
73321: PUSH
73322: LD_VAR 0 3
73326: PUSH
73327: LD_VAR 0 4
73331: PUSH
73332: LD_VAR 0 5
73336: PUSH
73337: EMPTY
73338: LIST
73339: LIST
73340: LIST
73341: LIST
73342: ST_TO_ADDR
// end ;
73343: LD_VAR 0 6
73347: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
73348: LD_INT 0
73350: PPUSH
// if not chassis or not engine then
73351: LD_VAR 0 1
73355: NOT
73356: PUSH
73357: LD_VAR 0 2
73361: NOT
73362: OR
73363: IFFALSE 73367
// exit ;
73365: GO 73563
// case engine of engine_solar :
73367: LD_VAR 0 2
73371: PUSH
73372: LD_INT 2
73374: DOUBLE
73375: EQUAL
73376: IFTRUE 73380
73378: GO 73418
73380: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
73381: LD_ADDR_VAR 0 3
73385: PUSH
73386: LD_INT 11
73388: PUSH
73389: LD_INT 12
73391: PUSH
73392: LD_INT 13
73394: PUSH
73395: LD_INT 14
73397: PUSH
73398: LD_INT 1
73400: PUSH
73401: LD_INT 2
73403: PUSH
73404: LD_INT 3
73406: PUSH
73407: EMPTY
73408: LIST
73409: LIST
73410: LIST
73411: LIST
73412: LIST
73413: LIST
73414: LIST
73415: ST_TO_ADDR
73416: GO 73547
73418: LD_INT 1
73420: DOUBLE
73421: EQUAL
73422: IFTRUE 73426
73424: GO 73488
73426: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
73427: LD_ADDR_VAR 0 3
73431: PUSH
73432: LD_INT 11
73434: PUSH
73435: LD_INT 12
73437: PUSH
73438: LD_INT 13
73440: PUSH
73441: LD_INT 14
73443: PUSH
73444: LD_INT 1
73446: PUSH
73447: LD_INT 2
73449: PUSH
73450: LD_INT 3
73452: PUSH
73453: LD_INT 4
73455: PUSH
73456: LD_INT 5
73458: PUSH
73459: LD_INT 21
73461: PUSH
73462: LD_INT 23
73464: PUSH
73465: LD_INT 22
73467: PUSH
73468: LD_INT 24
73470: PUSH
73471: EMPTY
73472: LIST
73473: LIST
73474: LIST
73475: LIST
73476: LIST
73477: LIST
73478: LIST
73479: LIST
73480: LIST
73481: LIST
73482: LIST
73483: LIST
73484: LIST
73485: ST_TO_ADDR
73486: GO 73547
73488: LD_INT 3
73490: DOUBLE
73491: EQUAL
73492: IFTRUE 73496
73494: GO 73546
73496: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
73497: LD_ADDR_VAR 0 3
73501: PUSH
73502: LD_INT 13
73504: PUSH
73505: LD_INT 14
73507: PUSH
73508: LD_INT 2
73510: PUSH
73511: LD_INT 3
73513: PUSH
73514: LD_INT 4
73516: PUSH
73517: LD_INT 5
73519: PUSH
73520: LD_INT 21
73522: PUSH
73523: LD_INT 22
73525: PUSH
73526: LD_INT 23
73528: PUSH
73529: LD_INT 24
73531: PUSH
73532: EMPTY
73533: LIST
73534: LIST
73535: LIST
73536: LIST
73537: LIST
73538: LIST
73539: LIST
73540: LIST
73541: LIST
73542: LIST
73543: ST_TO_ADDR
73544: GO 73547
73546: POP
// result := ( chassis in result ) ;
73547: LD_ADDR_VAR 0 3
73551: PUSH
73552: LD_VAR 0 1
73556: PUSH
73557: LD_VAR 0 3
73561: IN
73562: ST_TO_ADDR
// end ;
73563: LD_VAR 0 3
73567: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
73568: LD_INT 0
73570: PPUSH
// if not chassis or not weapon then
73571: LD_VAR 0 1
73575: NOT
73576: PUSH
73577: LD_VAR 0 2
73581: NOT
73582: OR
73583: IFFALSE 73587
// exit ;
73585: GO 74647
// case weapon of us_machine_gun :
73587: LD_VAR 0 2
73591: PUSH
73592: LD_INT 2
73594: DOUBLE
73595: EQUAL
73596: IFTRUE 73600
73598: GO 73630
73600: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
73601: LD_ADDR_VAR 0 3
73605: PUSH
73606: LD_INT 1
73608: PUSH
73609: LD_INT 2
73611: PUSH
73612: LD_INT 3
73614: PUSH
73615: LD_INT 4
73617: PUSH
73618: LD_INT 5
73620: PUSH
73621: EMPTY
73622: LIST
73623: LIST
73624: LIST
73625: LIST
73626: LIST
73627: ST_TO_ADDR
73628: GO 74631
73630: LD_INT 3
73632: DOUBLE
73633: EQUAL
73634: IFTRUE 73638
73636: GO 73668
73638: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
73639: LD_ADDR_VAR 0 3
73643: PUSH
73644: LD_INT 1
73646: PUSH
73647: LD_INT 2
73649: PUSH
73650: LD_INT 3
73652: PUSH
73653: LD_INT 4
73655: PUSH
73656: LD_INT 5
73658: PUSH
73659: EMPTY
73660: LIST
73661: LIST
73662: LIST
73663: LIST
73664: LIST
73665: ST_TO_ADDR
73666: GO 74631
73668: LD_INT 11
73670: DOUBLE
73671: EQUAL
73672: IFTRUE 73676
73674: GO 73706
73676: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
73677: LD_ADDR_VAR 0 3
73681: PUSH
73682: LD_INT 1
73684: PUSH
73685: LD_INT 2
73687: PUSH
73688: LD_INT 3
73690: PUSH
73691: LD_INT 4
73693: PUSH
73694: LD_INT 5
73696: PUSH
73697: EMPTY
73698: LIST
73699: LIST
73700: LIST
73701: LIST
73702: LIST
73703: ST_TO_ADDR
73704: GO 74631
73706: LD_INT 4
73708: DOUBLE
73709: EQUAL
73710: IFTRUE 73714
73712: GO 73740
73714: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
73715: LD_ADDR_VAR 0 3
73719: PUSH
73720: LD_INT 2
73722: PUSH
73723: LD_INT 3
73725: PUSH
73726: LD_INT 4
73728: PUSH
73729: LD_INT 5
73731: PUSH
73732: EMPTY
73733: LIST
73734: LIST
73735: LIST
73736: LIST
73737: ST_TO_ADDR
73738: GO 74631
73740: LD_INT 5
73742: DOUBLE
73743: EQUAL
73744: IFTRUE 73748
73746: GO 73774
73748: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
73749: LD_ADDR_VAR 0 3
73753: PUSH
73754: LD_INT 2
73756: PUSH
73757: LD_INT 3
73759: PUSH
73760: LD_INT 4
73762: PUSH
73763: LD_INT 5
73765: PUSH
73766: EMPTY
73767: LIST
73768: LIST
73769: LIST
73770: LIST
73771: ST_TO_ADDR
73772: GO 74631
73774: LD_INT 9
73776: DOUBLE
73777: EQUAL
73778: IFTRUE 73782
73780: GO 73808
73782: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
73783: LD_ADDR_VAR 0 3
73787: PUSH
73788: LD_INT 2
73790: PUSH
73791: LD_INT 3
73793: PUSH
73794: LD_INT 4
73796: PUSH
73797: LD_INT 5
73799: PUSH
73800: EMPTY
73801: LIST
73802: LIST
73803: LIST
73804: LIST
73805: ST_TO_ADDR
73806: GO 74631
73808: LD_INT 7
73810: DOUBLE
73811: EQUAL
73812: IFTRUE 73816
73814: GO 73842
73816: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
73817: LD_ADDR_VAR 0 3
73821: PUSH
73822: LD_INT 2
73824: PUSH
73825: LD_INT 3
73827: PUSH
73828: LD_INT 4
73830: PUSH
73831: LD_INT 5
73833: PUSH
73834: EMPTY
73835: LIST
73836: LIST
73837: LIST
73838: LIST
73839: ST_TO_ADDR
73840: GO 74631
73842: LD_INT 12
73844: DOUBLE
73845: EQUAL
73846: IFTRUE 73850
73848: GO 73876
73850: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
73851: LD_ADDR_VAR 0 3
73855: PUSH
73856: LD_INT 2
73858: PUSH
73859: LD_INT 3
73861: PUSH
73862: LD_INT 4
73864: PUSH
73865: LD_INT 5
73867: PUSH
73868: EMPTY
73869: LIST
73870: LIST
73871: LIST
73872: LIST
73873: ST_TO_ADDR
73874: GO 74631
73876: LD_INT 13
73878: DOUBLE
73879: EQUAL
73880: IFTRUE 73884
73882: GO 73910
73884: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
73885: LD_ADDR_VAR 0 3
73889: PUSH
73890: LD_INT 2
73892: PUSH
73893: LD_INT 3
73895: PUSH
73896: LD_INT 4
73898: PUSH
73899: LD_INT 5
73901: PUSH
73902: EMPTY
73903: LIST
73904: LIST
73905: LIST
73906: LIST
73907: ST_TO_ADDR
73908: GO 74631
73910: LD_INT 14
73912: DOUBLE
73913: EQUAL
73914: IFTRUE 73918
73916: GO 73936
73918: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
73919: LD_ADDR_VAR 0 3
73923: PUSH
73924: LD_INT 4
73926: PUSH
73927: LD_INT 5
73929: PUSH
73930: EMPTY
73931: LIST
73932: LIST
73933: ST_TO_ADDR
73934: GO 74631
73936: LD_INT 6
73938: DOUBLE
73939: EQUAL
73940: IFTRUE 73944
73942: GO 73962
73944: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
73945: LD_ADDR_VAR 0 3
73949: PUSH
73950: LD_INT 4
73952: PUSH
73953: LD_INT 5
73955: PUSH
73956: EMPTY
73957: LIST
73958: LIST
73959: ST_TO_ADDR
73960: GO 74631
73962: LD_INT 10
73964: DOUBLE
73965: EQUAL
73966: IFTRUE 73970
73968: GO 73988
73970: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
73971: LD_ADDR_VAR 0 3
73975: PUSH
73976: LD_INT 4
73978: PUSH
73979: LD_INT 5
73981: PUSH
73982: EMPTY
73983: LIST
73984: LIST
73985: ST_TO_ADDR
73986: GO 74631
73988: LD_INT 22
73990: DOUBLE
73991: EQUAL
73992: IFTRUE 73996
73994: GO 74022
73996: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
73997: LD_ADDR_VAR 0 3
74001: PUSH
74002: LD_INT 11
74004: PUSH
74005: LD_INT 12
74007: PUSH
74008: LD_INT 13
74010: PUSH
74011: LD_INT 14
74013: PUSH
74014: EMPTY
74015: LIST
74016: LIST
74017: LIST
74018: LIST
74019: ST_TO_ADDR
74020: GO 74631
74022: LD_INT 23
74024: DOUBLE
74025: EQUAL
74026: IFTRUE 74030
74028: GO 74056
74030: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
74031: LD_ADDR_VAR 0 3
74035: PUSH
74036: LD_INT 11
74038: PUSH
74039: LD_INT 12
74041: PUSH
74042: LD_INT 13
74044: PUSH
74045: LD_INT 14
74047: PUSH
74048: EMPTY
74049: LIST
74050: LIST
74051: LIST
74052: LIST
74053: ST_TO_ADDR
74054: GO 74631
74056: LD_INT 24
74058: DOUBLE
74059: EQUAL
74060: IFTRUE 74064
74062: GO 74090
74064: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
74065: LD_ADDR_VAR 0 3
74069: PUSH
74070: LD_INT 11
74072: PUSH
74073: LD_INT 12
74075: PUSH
74076: LD_INT 13
74078: PUSH
74079: LD_INT 14
74081: PUSH
74082: EMPTY
74083: LIST
74084: LIST
74085: LIST
74086: LIST
74087: ST_TO_ADDR
74088: GO 74631
74090: LD_INT 30
74092: DOUBLE
74093: EQUAL
74094: IFTRUE 74098
74096: GO 74124
74098: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
74099: LD_ADDR_VAR 0 3
74103: PUSH
74104: LD_INT 11
74106: PUSH
74107: LD_INT 12
74109: PUSH
74110: LD_INT 13
74112: PUSH
74113: LD_INT 14
74115: PUSH
74116: EMPTY
74117: LIST
74118: LIST
74119: LIST
74120: LIST
74121: ST_TO_ADDR
74122: GO 74631
74124: LD_INT 25
74126: DOUBLE
74127: EQUAL
74128: IFTRUE 74132
74130: GO 74150
74132: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
74133: LD_ADDR_VAR 0 3
74137: PUSH
74138: LD_INT 13
74140: PUSH
74141: LD_INT 14
74143: PUSH
74144: EMPTY
74145: LIST
74146: LIST
74147: ST_TO_ADDR
74148: GO 74631
74150: LD_INT 27
74152: DOUBLE
74153: EQUAL
74154: IFTRUE 74158
74156: GO 74176
74158: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
74159: LD_ADDR_VAR 0 3
74163: PUSH
74164: LD_INT 13
74166: PUSH
74167: LD_INT 14
74169: PUSH
74170: EMPTY
74171: LIST
74172: LIST
74173: ST_TO_ADDR
74174: GO 74631
74176: LD_INT 92
74178: DOUBLE
74179: EQUAL
74180: IFTRUE 74184
74182: GO 74210
74184: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
74185: LD_ADDR_VAR 0 3
74189: PUSH
74190: LD_INT 11
74192: PUSH
74193: LD_INT 12
74195: PUSH
74196: LD_INT 13
74198: PUSH
74199: LD_INT 14
74201: PUSH
74202: EMPTY
74203: LIST
74204: LIST
74205: LIST
74206: LIST
74207: ST_TO_ADDR
74208: GO 74631
74210: LD_INT 28
74212: DOUBLE
74213: EQUAL
74214: IFTRUE 74218
74216: GO 74236
74218: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
74219: LD_ADDR_VAR 0 3
74223: PUSH
74224: LD_INT 13
74226: PUSH
74227: LD_INT 14
74229: PUSH
74230: EMPTY
74231: LIST
74232: LIST
74233: ST_TO_ADDR
74234: GO 74631
74236: LD_INT 29
74238: DOUBLE
74239: EQUAL
74240: IFTRUE 74244
74242: GO 74262
74244: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
74245: LD_ADDR_VAR 0 3
74249: PUSH
74250: LD_INT 13
74252: PUSH
74253: LD_INT 14
74255: PUSH
74256: EMPTY
74257: LIST
74258: LIST
74259: ST_TO_ADDR
74260: GO 74631
74262: LD_INT 31
74264: DOUBLE
74265: EQUAL
74266: IFTRUE 74270
74268: GO 74288
74270: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
74271: LD_ADDR_VAR 0 3
74275: PUSH
74276: LD_INT 13
74278: PUSH
74279: LD_INT 14
74281: PUSH
74282: EMPTY
74283: LIST
74284: LIST
74285: ST_TO_ADDR
74286: GO 74631
74288: LD_INT 26
74290: DOUBLE
74291: EQUAL
74292: IFTRUE 74296
74294: GO 74314
74296: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
74297: LD_ADDR_VAR 0 3
74301: PUSH
74302: LD_INT 13
74304: PUSH
74305: LD_INT 14
74307: PUSH
74308: EMPTY
74309: LIST
74310: LIST
74311: ST_TO_ADDR
74312: GO 74631
74314: LD_INT 42
74316: DOUBLE
74317: EQUAL
74318: IFTRUE 74322
74320: GO 74348
74322: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
74323: LD_ADDR_VAR 0 3
74327: PUSH
74328: LD_INT 21
74330: PUSH
74331: LD_INT 22
74333: PUSH
74334: LD_INT 23
74336: PUSH
74337: LD_INT 24
74339: PUSH
74340: EMPTY
74341: LIST
74342: LIST
74343: LIST
74344: LIST
74345: ST_TO_ADDR
74346: GO 74631
74348: LD_INT 43
74350: DOUBLE
74351: EQUAL
74352: IFTRUE 74356
74354: GO 74382
74356: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
74357: LD_ADDR_VAR 0 3
74361: PUSH
74362: LD_INT 21
74364: PUSH
74365: LD_INT 22
74367: PUSH
74368: LD_INT 23
74370: PUSH
74371: LD_INT 24
74373: PUSH
74374: EMPTY
74375: LIST
74376: LIST
74377: LIST
74378: LIST
74379: ST_TO_ADDR
74380: GO 74631
74382: LD_INT 44
74384: DOUBLE
74385: EQUAL
74386: IFTRUE 74390
74388: GO 74416
74390: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
74391: LD_ADDR_VAR 0 3
74395: PUSH
74396: LD_INT 21
74398: PUSH
74399: LD_INT 22
74401: PUSH
74402: LD_INT 23
74404: PUSH
74405: LD_INT 24
74407: PUSH
74408: EMPTY
74409: LIST
74410: LIST
74411: LIST
74412: LIST
74413: ST_TO_ADDR
74414: GO 74631
74416: LD_INT 45
74418: DOUBLE
74419: EQUAL
74420: IFTRUE 74424
74422: GO 74450
74424: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
74425: LD_ADDR_VAR 0 3
74429: PUSH
74430: LD_INT 21
74432: PUSH
74433: LD_INT 22
74435: PUSH
74436: LD_INT 23
74438: PUSH
74439: LD_INT 24
74441: PUSH
74442: EMPTY
74443: LIST
74444: LIST
74445: LIST
74446: LIST
74447: ST_TO_ADDR
74448: GO 74631
74450: LD_INT 49
74452: DOUBLE
74453: EQUAL
74454: IFTRUE 74458
74456: GO 74484
74458: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
74459: LD_ADDR_VAR 0 3
74463: PUSH
74464: LD_INT 21
74466: PUSH
74467: LD_INT 22
74469: PUSH
74470: LD_INT 23
74472: PUSH
74473: LD_INT 24
74475: PUSH
74476: EMPTY
74477: LIST
74478: LIST
74479: LIST
74480: LIST
74481: ST_TO_ADDR
74482: GO 74631
74484: LD_INT 51
74486: DOUBLE
74487: EQUAL
74488: IFTRUE 74492
74490: GO 74518
74492: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
74493: LD_ADDR_VAR 0 3
74497: PUSH
74498: LD_INT 21
74500: PUSH
74501: LD_INT 22
74503: PUSH
74504: LD_INT 23
74506: PUSH
74507: LD_INT 24
74509: PUSH
74510: EMPTY
74511: LIST
74512: LIST
74513: LIST
74514: LIST
74515: ST_TO_ADDR
74516: GO 74631
74518: LD_INT 52
74520: DOUBLE
74521: EQUAL
74522: IFTRUE 74526
74524: GO 74552
74526: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
74527: LD_ADDR_VAR 0 3
74531: PUSH
74532: LD_INT 21
74534: PUSH
74535: LD_INT 22
74537: PUSH
74538: LD_INT 23
74540: PUSH
74541: LD_INT 24
74543: PUSH
74544: EMPTY
74545: LIST
74546: LIST
74547: LIST
74548: LIST
74549: ST_TO_ADDR
74550: GO 74631
74552: LD_INT 53
74554: DOUBLE
74555: EQUAL
74556: IFTRUE 74560
74558: GO 74578
74560: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
74561: LD_ADDR_VAR 0 3
74565: PUSH
74566: LD_INT 23
74568: PUSH
74569: LD_INT 24
74571: PUSH
74572: EMPTY
74573: LIST
74574: LIST
74575: ST_TO_ADDR
74576: GO 74631
74578: LD_INT 46
74580: DOUBLE
74581: EQUAL
74582: IFTRUE 74586
74584: GO 74604
74586: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
74587: LD_ADDR_VAR 0 3
74591: PUSH
74592: LD_INT 23
74594: PUSH
74595: LD_INT 24
74597: PUSH
74598: EMPTY
74599: LIST
74600: LIST
74601: ST_TO_ADDR
74602: GO 74631
74604: LD_INT 47
74606: DOUBLE
74607: EQUAL
74608: IFTRUE 74612
74610: GO 74630
74612: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
74613: LD_ADDR_VAR 0 3
74617: PUSH
74618: LD_INT 23
74620: PUSH
74621: LD_INT 24
74623: PUSH
74624: EMPTY
74625: LIST
74626: LIST
74627: ST_TO_ADDR
74628: GO 74631
74630: POP
// result := ( chassis in result ) ;
74631: LD_ADDR_VAR 0 3
74635: PUSH
74636: LD_VAR 0 1
74640: PUSH
74641: LD_VAR 0 3
74645: IN
74646: ST_TO_ADDR
// end ;
74647: LD_VAR 0 3
74651: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
74652: LD_INT 0
74654: PPUSH
74655: PPUSH
74656: PPUSH
74657: PPUSH
74658: PPUSH
74659: PPUSH
74660: PPUSH
// result := array ;
74661: LD_ADDR_VAR 0 5
74665: PUSH
74666: LD_VAR 0 1
74670: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
74671: LD_VAR 0 1
74675: NOT
74676: PUSH
74677: LD_VAR 0 2
74681: NOT
74682: OR
74683: PUSH
74684: LD_VAR 0 3
74688: NOT
74689: OR
74690: PUSH
74691: LD_VAR 0 2
74695: PUSH
74696: LD_VAR 0 1
74700: GREATER
74701: OR
74702: PUSH
74703: LD_VAR 0 3
74707: PUSH
74708: LD_VAR 0 1
74712: GREATER
74713: OR
74714: IFFALSE 74718
// exit ;
74716: GO 75014
// if direction then
74718: LD_VAR 0 4
74722: IFFALSE 74786
// begin d := 1 ;
74724: LD_ADDR_VAR 0 9
74728: PUSH
74729: LD_INT 1
74731: ST_TO_ADDR
// if i_from > i_to then
74732: LD_VAR 0 2
74736: PUSH
74737: LD_VAR 0 3
74741: GREATER
74742: IFFALSE 74768
// length := ( array - i_from ) + i_to else
74744: LD_ADDR_VAR 0 11
74748: PUSH
74749: LD_VAR 0 1
74753: PUSH
74754: LD_VAR 0 2
74758: MINUS
74759: PUSH
74760: LD_VAR 0 3
74764: PLUS
74765: ST_TO_ADDR
74766: GO 74784
// length := i_to - i_from ;
74768: LD_ADDR_VAR 0 11
74772: PUSH
74773: LD_VAR 0 3
74777: PUSH
74778: LD_VAR 0 2
74782: MINUS
74783: ST_TO_ADDR
// end else
74784: GO 74847
// begin d := - 1 ;
74786: LD_ADDR_VAR 0 9
74790: PUSH
74791: LD_INT 1
74793: NEG
74794: ST_TO_ADDR
// if i_from > i_to then
74795: LD_VAR 0 2
74799: PUSH
74800: LD_VAR 0 3
74804: GREATER
74805: IFFALSE 74825
// length := i_from - i_to else
74807: LD_ADDR_VAR 0 11
74811: PUSH
74812: LD_VAR 0 2
74816: PUSH
74817: LD_VAR 0 3
74821: MINUS
74822: ST_TO_ADDR
74823: GO 74847
// length := ( array - i_to ) + i_from ;
74825: LD_ADDR_VAR 0 11
74829: PUSH
74830: LD_VAR 0 1
74834: PUSH
74835: LD_VAR 0 3
74839: MINUS
74840: PUSH
74841: LD_VAR 0 2
74845: PLUS
74846: ST_TO_ADDR
// end ; if not length then
74847: LD_VAR 0 11
74851: NOT
74852: IFFALSE 74856
// exit ;
74854: GO 75014
// tmp := array ;
74856: LD_ADDR_VAR 0 10
74860: PUSH
74861: LD_VAR 0 1
74865: ST_TO_ADDR
// for i = 1 to length do
74866: LD_ADDR_VAR 0 6
74870: PUSH
74871: DOUBLE
74872: LD_INT 1
74874: DEC
74875: ST_TO_ADDR
74876: LD_VAR 0 11
74880: PUSH
74881: FOR_TO
74882: IFFALSE 75002
// begin for j = 1 to array do
74884: LD_ADDR_VAR 0 7
74888: PUSH
74889: DOUBLE
74890: LD_INT 1
74892: DEC
74893: ST_TO_ADDR
74894: LD_VAR 0 1
74898: PUSH
74899: FOR_TO
74900: IFFALSE 74988
// begin k := j + d ;
74902: LD_ADDR_VAR 0 8
74906: PUSH
74907: LD_VAR 0 7
74911: PUSH
74912: LD_VAR 0 9
74916: PLUS
74917: ST_TO_ADDR
// if k > array then
74918: LD_VAR 0 8
74922: PUSH
74923: LD_VAR 0 1
74927: GREATER
74928: IFFALSE 74938
// k := 1 ;
74930: LD_ADDR_VAR 0 8
74934: PUSH
74935: LD_INT 1
74937: ST_TO_ADDR
// if not k then
74938: LD_VAR 0 8
74942: NOT
74943: IFFALSE 74955
// k := array ;
74945: LD_ADDR_VAR 0 8
74949: PUSH
74950: LD_VAR 0 1
74954: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
74955: LD_ADDR_VAR 0 10
74959: PUSH
74960: LD_VAR 0 10
74964: PPUSH
74965: LD_VAR 0 8
74969: PPUSH
74970: LD_VAR 0 1
74974: PUSH
74975: LD_VAR 0 7
74979: ARRAY
74980: PPUSH
74981: CALL_OW 1
74985: ST_TO_ADDR
// end ;
74986: GO 74899
74988: POP
74989: POP
// array := tmp ;
74990: LD_ADDR_VAR 0 1
74994: PUSH
74995: LD_VAR 0 10
74999: ST_TO_ADDR
// end ;
75000: GO 74881
75002: POP
75003: POP
// result := array ;
75004: LD_ADDR_VAR 0 5
75008: PUSH
75009: LD_VAR 0 1
75013: ST_TO_ADDR
// end ;
75014: LD_VAR 0 5
75018: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
75019: LD_INT 0
75021: PPUSH
75022: PPUSH
// result := 0 ;
75023: LD_ADDR_VAR 0 3
75027: PUSH
75028: LD_INT 0
75030: ST_TO_ADDR
// if not array or not value in array then
75031: LD_VAR 0 1
75035: NOT
75036: PUSH
75037: LD_VAR 0 2
75041: PUSH
75042: LD_VAR 0 1
75046: IN
75047: NOT
75048: OR
75049: IFFALSE 75053
// exit ;
75051: GO 75107
// for i = 1 to array do
75053: LD_ADDR_VAR 0 4
75057: PUSH
75058: DOUBLE
75059: LD_INT 1
75061: DEC
75062: ST_TO_ADDR
75063: LD_VAR 0 1
75067: PUSH
75068: FOR_TO
75069: IFFALSE 75105
// if value = array [ i ] then
75071: LD_VAR 0 2
75075: PUSH
75076: LD_VAR 0 1
75080: PUSH
75081: LD_VAR 0 4
75085: ARRAY
75086: EQUAL
75087: IFFALSE 75103
// begin result := i ;
75089: LD_ADDR_VAR 0 3
75093: PUSH
75094: LD_VAR 0 4
75098: ST_TO_ADDR
// exit ;
75099: POP
75100: POP
75101: GO 75107
// end ;
75103: GO 75068
75105: POP
75106: POP
// end ;
75107: LD_VAR 0 3
75111: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
75112: LD_INT 0
75114: PPUSH
// vc_chassis := chassis ;
75115: LD_ADDR_OWVAR 37
75119: PUSH
75120: LD_VAR 0 1
75124: ST_TO_ADDR
// vc_engine := engine ;
75125: LD_ADDR_OWVAR 39
75129: PUSH
75130: LD_VAR 0 2
75134: ST_TO_ADDR
// vc_control := control ;
75135: LD_ADDR_OWVAR 38
75139: PUSH
75140: LD_VAR 0 3
75144: ST_TO_ADDR
// vc_weapon := weapon ;
75145: LD_ADDR_OWVAR 40
75149: PUSH
75150: LD_VAR 0 4
75154: ST_TO_ADDR
// vc_fuel_battery := fuel ;
75155: LD_ADDR_OWVAR 41
75159: PUSH
75160: LD_VAR 0 5
75164: ST_TO_ADDR
// end ;
75165: LD_VAR 0 6
75169: RET
// export function WantPlant ( unit ) ; var task ; begin
75170: LD_INT 0
75172: PPUSH
75173: PPUSH
// result := false ;
75174: LD_ADDR_VAR 0 2
75178: PUSH
75179: LD_INT 0
75181: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
75182: LD_ADDR_VAR 0 3
75186: PUSH
75187: LD_VAR 0 1
75191: PPUSH
75192: CALL_OW 437
75196: ST_TO_ADDR
// if task then
75197: LD_VAR 0 3
75201: IFFALSE 75229
// if task [ 1 ] [ 1 ] = p then
75203: LD_VAR 0 3
75207: PUSH
75208: LD_INT 1
75210: ARRAY
75211: PUSH
75212: LD_INT 1
75214: ARRAY
75215: PUSH
75216: LD_STRING p
75218: EQUAL
75219: IFFALSE 75229
// result := true ;
75221: LD_ADDR_VAR 0 2
75225: PUSH
75226: LD_INT 1
75228: ST_TO_ADDR
// end ;
75229: LD_VAR 0 2
75233: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
75234: LD_INT 0
75236: PPUSH
75237: PPUSH
75238: PPUSH
75239: PPUSH
// if pos < 1 then
75240: LD_VAR 0 2
75244: PUSH
75245: LD_INT 1
75247: LESS
75248: IFFALSE 75252
// exit ;
75250: GO 75555
// if pos = 1 then
75252: LD_VAR 0 2
75256: PUSH
75257: LD_INT 1
75259: EQUAL
75260: IFFALSE 75293
// result := Replace ( arr , pos [ 1 ] , value ) else
75262: LD_ADDR_VAR 0 4
75266: PUSH
75267: LD_VAR 0 1
75271: PPUSH
75272: LD_VAR 0 2
75276: PUSH
75277: LD_INT 1
75279: ARRAY
75280: PPUSH
75281: LD_VAR 0 3
75285: PPUSH
75286: CALL_OW 1
75290: ST_TO_ADDR
75291: GO 75555
// begin tmp := arr ;
75293: LD_ADDR_VAR 0 6
75297: PUSH
75298: LD_VAR 0 1
75302: ST_TO_ADDR
// s_arr := [ tmp ] ;
75303: LD_ADDR_VAR 0 7
75307: PUSH
75308: LD_VAR 0 6
75312: PUSH
75313: EMPTY
75314: LIST
75315: ST_TO_ADDR
// for i = 1 to pos - 1 do
75316: LD_ADDR_VAR 0 5
75320: PUSH
75321: DOUBLE
75322: LD_INT 1
75324: DEC
75325: ST_TO_ADDR
75326: LD_VAR 0 2
75330: PUSH
75331: LD_INT 1
75333: MINUS
75334: PUSH
75335: FOR_TO
75336: IFFALSE 75381
// begin tmp := tmp [ pos [ i ] ] ;
75338: LD_ADDR_VAR 0 6
75342: PUSH
75343: LD_VAR 0 6
75347: PUSH
75348: LD_VAR 0 2
75352: PUSH
75353: LD_VAR 0 5
75357: ARRAY
75358: ARRAY
75359: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
75360: LD_ADDR_VAR 0 7
75364: PUSH
75365: LD_VAR 0 7
75369: PUSH
75370: LD_VAR 0 6
75374: PUSH
75375: EMPTY
75376: LIST
75377: ADD
75378: ST_TO_ADDR
// end ;
75379: GO 75335
75381: POP
75382: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
75383: LD_ADDR_VAR 0 6
75387: PUSH
75388: LD_VAR 0 6
75392: PPUSH
75393: LD_VAR 0 2
75397: PUSH
75398: LD_VAR 0 2
75402: ARRAY
75403: PPUSH
75404: LD_VAR 0 3
75408: PPUSH
75409: CALL_OW 1
75413: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
75414: LD_ADDR_VAR 0 7
75418: PUSH
75419: LD_VAR 0 7
75423: PPUSH
75424: LD_VAR 0 7
75428: PPUSH
75429: LD_VAR 0 6
75433: PPUSH
75434: CALL_OW 1
75438: ST_TO_ADDR
// for i = s_arr downto 2 do
75439: LD_ADDR_VAR 0 5
75443: PUSH
75444: DOUBLE
75445: LD_VAR 0 7
75449: INC
75450: ST_TO_ADDR
75451: LD_INT 2
75453: PUSH
75454: FOR_DOWNTO
75455: IFFALSE 75539
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
75457: LD_ADDR_VAR 0 6
75461: PUSH
75462: LD_VAR 0 7
75466: PUSH
75467: LD_VAR 0 5
75471: PUSH
75472: LD_INT 1
75474: MINUS
75475: ARRAY
75476: PPUSH
75477: LD_VAR 0 2
75481: PUSH
75482: LD_VAR 0 5
75486: PUSH
75487: LD_INT 1
75489: MINUS
75490: ARRAY
75491: PPUSH
75492: LD_VAR 0 7
75496: PUSH
75497: LD_VAR 0 5
75501: ARRAY
75502: PPUSH
75503: CALL_OW 1
75507: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
75508: LD_ADDR_VAR 0 7
75512: PUSH
75513: LD_VAR 0 7
75517: PPUSH
75518: LD_VAR 0 5
75522: PUSH
75523: LD_INT 1
75525: MINUS
75526: PPUSH
75527: LD_VAR 0 6
75531: PPUSH
75532: CALL_OW 1
75536: ST_TO_ADDR
// end ;
75537: GO 75454
75539: POP
75540: POP
// result := s_arr [ 1 ] ;
75541: LD_ADDR_VAR 0 4
75545: PUSH
75546: LD_VAR 0 7
75550: PUSH
75551: LD_INT 1
75553: ARRAY
75554: ST_TO_ADDR
// end ; end ;
75555: LD_VAR 0 4
75559: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
75560: LD_INT 0
75562: PPUSH
75563: PPUSH
// if not list then
75564: LD_VAR 0 1
75568: NOT
75569: IFFALSE 75573
// exit ;
75571: GO 75664
// i := list [ pos1 ] ;
75573: LD_ADDR_VAR 0 5
75577: PUSH
75578: LD_VAR 0 1
75582: PUSH
75583: LD_VAR 0 2
75587: ARRAY
75588: ST_TO_ADDR
// if not i then
75589: LD_VAR 0 5
75593: NOT
75594: IFFALSE 75598
// exit ;
75596: GO 75664
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
75598: LD_ADDR_VAR 0 1
75602: PUSH
75603: LD_VAR 0 1
75607: PPUSH
75608: LD_VAR 0 2
75612: PPUSH
75613: LD_VAR 0 1
75617: PUSH
75618: LD_VAR 0 3
75622: ARRAY
75623: PPUSH
75624: CALL_OW 1
75628: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
75629: LD_ADDR_VAR 0 1
75633: PUSH
75634: LD_VAR 0 1
75638: PPUSH
75639: LD_VAR 0 3
75643: PPUSH
75644: LD_VAR 0 5
75648: PPUSH
75649: CALL_OW 1
75653: ST_TO_ADDR
// result := list ;
75654: LD_ADDR_VAR 0 4
75658: PUSH
75659: LD_VAR 0 1
75663: ST_TO_ADDR
// end ;
75664: LD_VAR 0 4
75668: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
75669: LD_INT 0
75671: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
75672: LD_ADDR_VAR 0 5
75676: PUSH
75677: LD_VAR 0 1
75681: PPUSH
75682: CALL_OW 250
75686: PPUSH
75687: LD_VAR 0 1
75691: PPUSH
75692: CALL_OW 251
75696: PPUSH
75697: LD_VAR 0 2
75701: PPUSH
75702: LD_VAR 0 3
75706: PPUSH
75707: LD_VAR 0 4
75711: PPUSH
75712: CALL 76090 0 5
75716: ST_TO_ADDR
// end ;
75717: LD_VAR 0 5
75721: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
75722: LD_INT 0
75724: PPUSH
75725: PPUSH
75726: PPUSH
75727: PPUSH
// if not list or not unit then
75728: LD_VAR 0 2
75732: NOT
75733: PUSH
75734: LD_VAR 0 1
75738: NOT
75739: OR
75740: IFFALSE 75744
// exit ;
75742: GO 76085
// result := [ ] ;
75744: LD_ADDR_VAR 0 5
75748: PUSH
75749: EMPTY
75750: ST_TO_ADDR
// for i in list do
75751: LD_ADDR_VAR 0 6
75755: PUSH
75756: LD_VAR 0 2
75760: PUSH
75761: FOR_IN
75762: IFFALSE 75980
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
75764: LD_ADDR_VAR 0 8
75768: PUSH
75769: LD_VAR 0 1
75773: PPUSH
75774: LD_VAR 0 6
75778: PUSH
75779: LD_INT 1
75781: ARRAY
75782: PPUSH
75783: LD_VAR 0 6
75787: PUSH
75788: LD_INT 2
75790: ARRAY
75791: PPUSH
75792: CALL_OW 297
75796: ST_TO_ADDR
// if not Count ( result ) then
75797: LD_VAR 0 5
75801: PPUSH
75802: CALL 72374 0 1
75806: NOT
75807: IFFALSE 75840
// begin result := Join ( result , [ i , tmp ] ) ;
75809: LD_ADDR_VAR 0 5
75813: PUSH
75814: LD_VAR 0 5
75818: PPUSH
75819: LD_VAR 0 6
75823: PUSH
75824: LD_VAR 0 8
75828: PUSH
75829: EMPTY
75830: LIST
75831: LIST
75832: PPUSH
75833: CALL 107963 0 2
75837: ST_TO_ADDR
// continue ;
75838: GO 75761
// end ; if result [ result ] [ 2 ] <= tmp then
75840: LD_VAR 0 5
75844: PUSH
75845: LD_VAR 0 5
75849: ARRAY
75850: PUSH
75851: LD_INT 2
75853: ARRAY
75854: PUSH
75855: LD_VAR 0 8
75859: LESSEQUAL
75860: IFFALSE 75893
// result := Join ( result , [ i , tmp ] ) else
75862: LD_ADDR_VAR 0 5
75866: PUSH
75867: LD_VAR 0 5
75871: PPUSH
75872: LD_VAR 0 6
75876: PUSH
75877: LD_VAR 0 8
75881: PUSH
75882: EMPTY
75883: LIST
75884: LIST
75885: PPUSH
75886: CALL 107963 0 2
75890: ST_TO_ADDR
75891: GO 75978
// begin for j := 1 to Count ( result ) do
75893: LD_ADDR_VAR 0 7
75897: PUSH
75898: DOUBLE
75899: LD_INT 1
75901: DEC
75902: ST_TO_ADDR
75903: LD_VAR 0 5
75907: PPUSH
75908: CALL 72374 0 1
75912: PUSH
75913: FOR_TO
75914: IFFALSE 75976
// begin if tmp < result [ j ] [ 2 ] then
75916: LD_VAR 0 8
75920: PUSH
75921: LD_VAR 0 5
75925: PUSH
75926: LD_VAR 0 7
75930: ARRAY
75931: PUSH
75932: LD_INT 2
75934: ARRAY
75935: LESS
75936: IFFALSE 75974
// begin result := Insert ( result , j , [ i , tmp ] ) ;
75938: LD_ADDR_VAR 0 5
75942: PUSH
75943: LD_VAR 0 5
75947: PPUSH
75948: LD_VAR 0 7
75952: PPUSH
75953: LD_VAR 0 6
75957: PUSH
75958: LD_VAR 0 8
75962: PUSH
75963: EMPTY
75964: LIST
75965: LIST
75966: PPUSH
75967: CALL_OW 2
75971: ST_TO_ADDR
// break ;
75972: GO 75976
// end ; end ;
75974: GO 75913
75976: POP
75977: POP
// end ; end ;
75978: GO 75761
75980: POP
75981: POP
// if result and not asc then
75982: LD_VAR 0 5
75986: PUSH
75987: LD_VAR 0 3
75991: NOT
75992: AND
75993: IFFALSE 76010
// result := ReverseArray ( result ) ;
75995: LD_ADDR_VAR 0 5
75999: PUSH
76000: LD_VAR 0 5
76004: PPUSH
76005: CALL 103250 0 1
76009: ST_TO_ADDR
// tmp := [ ] ;
76010: LD_ADDR_VAR 0 8
76014: PUSH
76015: EMPTY
76016: ST_TO_ADDR
// if mode then
76017: LD_VAR 0 4
76021: IFFALSE 76085
// begin for i := 1 to result do
76023: LD_ADDR_VAR 0 6
76027: PUSH
76028: DOUBLE
76029: LD_INT 1
76031: DEC
76032: ST_TO_ADDR
76033: LD_VAR 0 5
76037: PUSH
76038: FOR_TO
76039: IFFALSE 76073
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
76041: LD_ADDR_VAR 0 8
76045: PUSH
76046: LD_VAR 0 8
76050: PPUSH
76051: LD_VAR 0 5
76055: PUSH
76056: LD_VAR 0 6
76060: ARRAY
76061: PUSH
76062: LD_INT 1
76064: ARRAY
76065: PPUSH
76066: CALL 107963 0 2
76070: ST_TO_ADDR
76071: GO 76038
76073: POP
76074: POP
// result := tmp ;
76075: LD_ADDR_VAR 0 5
76079: PUSH
76080: LD_VAR 0 8
76084: ST_TO_ADDR
// end ; end ;
76085: LD_VAR 0 5
76089: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
76090: LD_INT 0
76092: PPUSH
76093: PPUSH
76094: PPUSH
76095: PPUSH
// if not list then
76096: LD_VAR 0 3
76100: NOT
76101: IFFALSE 76105
// exit ;
76103: GO 76493
// result := [ ] ;
76105: LD_ADDR_VAR 0 6
76109: PUSH
76110: EMPTY
76111: ST_TO_ADDR
// for i in list do
76112: LD_ADDR_VAR 0 7
76116: PUSH
76117: LD_VAR 0 3
76121: PUSH
76122: FOR_IN
76123: IFFALSE 76325
// begin tmp := GetDistUnitXY ( i , x , y ) ;
76125: LD_ADDR_VAR 0 9
76129: PUSH
76130: LD_VAR 0 7
76134: PPUSH
76135: LD_VAR 0 1
76139: PPUSH
76140: LD_VAR 0 2
76144: PPUSH
76145: CALL_OW 297
76149: ST_TO_ADDR
// if not result then
76150: LD_VAR 0 6
76154: NOT
76155: IFFALSE 76181
// result := [ [ i , tmp ] ] else
76157: LD_ADDR_VAR 0 6
76161: PUSH
76162: LD_VAR 0 7
76166: PUSH
76167: LD_VAR 0 9
76171: PUSH
76172: EMPTY
76173: LIST
76174: LIST
76175: PUSH
76176: EMPTY
76177: LIST
76178: ST_TO_ADDR
76179: GO 76323
// begin if result [ result ] [ 2 ] < tmp then
76181: LD_VAR 0 6
76185: PUSH
76186: LD_VAR 0 6
76190: ARRAY
76191: PUSH
76192: LD_INT 2
76194: ARRAY
76195: PUSH
76196: LD_VAR 0 9
76200: LESS
76201: IFFALSE 76243
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
76203: LD_ADDR_VAR 0 6
76207: PUSH
76208: LD_VAR 0 6
76212: PPUSH
76213: LD_VAR 0 6
76217: PUSH
76218: LD_INT 1
76220: PLUS
76221: PPUSH
76222: LD_VAR 0 7
76226: PUSH
76227: LD_VAR 0 9
76231: PUSH
76232: EMPTY
76233: LIST
76234: LIST
76235: PPUSH
76236: CALL_OW 2
76240: ST_TO_ADDR
76241: GO 76323
// for j = 1 to result do
76243: LD_ADDR_VAR 0 8
76247: PUSH
76248: DOUBLE
76249: LD_INT 1
76251: DEC
76252: ST_TO_ADDR
76253: LD_VAR 0 6
76257: PUSH
76258: FOR_TO
76259: IFFALSE 76321
// begin if tmp < result [ j ] [ 2 ] then
76261: LD_VAR 0 9
76265: PUSH
76266: LD_VAR 0 6
76270: PUSH
76271: LD_VAR 0 8
76275: ARRAY
76276: PUSH
76277: LD_INT 2
76279: ARRAY
76280: LESS
76281: IFFALSE 76319
// begin result := Insert ( result , j , [ i , tmp ] ) ;
76283: LD_ADDR_VAR 0 6
76287: PUSH
76288: LD_VAR 0 6
76292: PPUSH
76293: LD_VAR 0 8
76297: PPUSH
76298: LD_VAR 0 7
76302: PUSH
76303: LD_VAR 0 9
76307: PUSH
76308: EMPTY
76309: LIST
76310: LIST
76311: PPUSH
76312: CALL_OW 2
76316: ST_TO_ADDR
// break ;
76317: GO 76321
// end ; end ;
76319: GO 76258
76321: POP
76322: POP
// end ; end ;
76323: GO 76122
76325: POP
76326: POP
// if result and not asc then
76327: LD_VAR 0 6
76331: PUSH
76332: LD_VAR 0 4
76336: NOT
76337: AND
76338: IFFALSE 76413
// begin tmp := result ;
76340: LD_ADDR_VAR 0 9
76344: PUSH
76345: LD_VAR 0 6
76349: ST_TO_ADDR
// for i = tmp downto 1 do
76350: LD_ADDR_VAR 0 7
76354: PUSH
76355: DOUBLE
76356: LD_VAR 0 9
76360: INC
76361: ST_TO_ADDR
76362: LD_INT 1
76364: PUSH
76365: FOR_DOWNTO
76366: IFFALSE 76411
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
76368: LD_ADDR_VAR 0 6
76372: PUSH
76373: LD_VAR 0 6
76377: PPUSH
76378: LD_VAR 0 9
76382: PUSH
76383: LD_VAR 0 7
76387: MINUS
76388: PUSH
76389: LD_INT 1
76391: PLUS
76392: PPUSH
76393: LD_VAR 0 9
76397: PUSH
76398: LD_VAR 0 7
76402: ARRAY
76403: PPUSH
76404: CALL_OW 1
76408: ST_TO_ADDR
76409: GO 76365
76411: POP
76412: POP
// end ; tmp := [ ] ;
76413: LD_ADDR_VAR 0 9
76417: PUSH
76418: EMPTY
76419: ST_TO_ADDR
// if mode then
76420: LD_VAR 0 5
76424: IFFALSE 76493
// begin for i = 1 to result do
76426: LD_ADDR_VAR 0 7
76430: PUSH
76431: DOUBLE
76432: LD_INT 1
76434: DEC
76435: ST_TO_ADDR
76436: LD_VAR 0 6
76440: PUSH
76441: FOR_TO
76442: IFFALSE 76481
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
76444: LD_ADDR_VAR 0 9
76448: PUSH
76449: LD_VAR 0 9
76453: PPUSH
76454: LD_VAR 0 7
76458: PPUSH
76459: LD_VAR 0 6
76463: PUSH
76464: LD_VAR 0 7
76468: ARRAY
76469: PUSH
76470: LD_INT 1
76472: ARRAY
76473: PPUSH
76474: CALL_OW 1
76478: ST_TO_ADDR
76479: GO 76441
76481: POP
76482: POP
// result := tmp ;
76483: LD_ADDR_VAR 0 6
76487: PUSH
76488: LD_VAR 0 9
76492: ST_TO_ADDR
// end ; end ;
76493: LD_VAR 0 6
76497: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
76498: LD_INT 0
76500: PPUSH
76501: PPUSH
76502: PPUSH
76503: PPUSH
76504: PPUSH
76505: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
76506: LD_ADDR_VAR 0 5
76510: PUSH
76511: LD_INT 0
76513: PUSH
76514: LD_INT 0
76516: PUSH
76517: LD_INT 0
76519: PUSH
76520: EMPTY
76521: PUSH
76522: EMPTY
76523: LIST
76524: LIST
76525: LIST
76526: LIST
76527: ST_TO_ADDR
// if not x or not y then
76528: LD_VAR 0 2
76532: NOT
76533: PUSH
76534: LD_VAR 0 3
76538: NOT
76539: OR
76540: IFFALSE 76544
// exit ;
76542: GO 78194
// if not range then
76544: LD_VAR 0 4
76548: NOT
76549: IFFALSE 76559
// range := 10 ;
76551: LD_ADDR_VAR 0 4
76555: PUSH
76556: LD_INT 10
76558: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
76559: LD_ADDR_VAR 0 8
76563: PUSH
76564: LD_INT 81
76566: PUSH
76567: LD_VAR 0 1
76571: PUSH
76572: EMPTY
76573: LIST
76574: LIST
76575: PUSH
76576: LD_INT 92
76578: PUSH
76579: LD_VAR 0 2
76583: PUSH
76584: LD_VAR 0 3
76588: PUSH
76589: LD_VAR 0 4
76593: PUSH
76594: EMPTY
76595: LIST
76596: LIST
76597: LIST
76598: LIST
76599: PUSH
76600: LD_INT 3
76602: PUSH
76603: LD_INT 21
76605: PUSH
76606: LD_INT 3
76608: PUSH
76609: EMPTY
76610: LIST
76611: LIST
76612: PUSH
76613: EMPTY
76614: LIST
76615: LIST
76616: PUSH
76617: EMPTY
76618: LIST
76619: LIST
76620: LIST
76621: PPUSH
76622: CALL_OW 69
76626: ST_TO_ADDR
// if not tmp then
76627: LD_VAR 0 8
76631: NOT
76632: IFFALSE 76636
// exit ;
76634: GO 78194
// for i in tmp do
76636: LD_ADDR_VAR 0 6
76640: PUSH
76641: LD_VAR 0 8
76645: PUSH
76646: FOR_IN
76647: IFFALSE 78169
// begin points := [ 0 , 0 , 0 ] ;
76649: LD_ADDR_VAR 0 9
76653: PUSH
76654: LD_INT 0
76656: PUSH
76657: LD_INT 0
76659: PUSH
76660: LD_INT 0
76662: PUSH
76663: EMPTY
76664: LIST
76665: LIST
76666: LIST
76667: ST_TO_ADDR
// bpoints := 1 ;
76668: LD_ADDR_VAR 0 10
76672: PUSH
76673: LD_INT 1
76675: ST_TO_ADDR
// case GetType ( i ) of unit_human :
76676: LD_VAR 0 6
76680: PPUSH
76681: CALL_OW 247
76685: PUSH
76686: LD_INT 1
76688: DOUBLE
76689: EQUAL
76690: IFTRUE 76694
76692: GO 77272
76694: POP
// begin if GetClass ( i ) = 1 then
76695: LD_VAR 0 6
76699: PPUSH
76700: CALL_OW 257
76704: PUSH
76705: LD_INT 1
76707: EQUAL
76708: IFFALSE 76729
// points := [ 10 , 5 , 3 ] ;
76710: LD_ADDR_VAR 0 9
76714: PUSH
76715: LD_INT 10
76717: PUSH
76718: LD_INT 5
76720: PUSH
76721: LD_INT 3
76723: PUSH
76724: EMPTY
76725: LIST
76726: LIST
76727: LIST
76728: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
76729: LD_VAR 0 6
76733: PPUSH
76734: CALL_OW 257
76738: PUSH
76739: LD_INT 2
76741: PUSH
76742: LD_INT 3
76744: PUSH
76745: LD_INT 4
76747: PUSH
76748: EMPTY
76749: LIST
76750: LIST
76751: LIST
76752: IN
76753: IFFALSE 76774
// points := [ 3 , 2 , 1 ] ;
76755: LD_ADDR_VAR 0 9
76759: PUSH
76760: LD_INT 3
76762: PUSH
76763: LD_INT 2
76765: PUSH
76766: LD_INT 1
76768: PUSH
76769: EMPTY
76770: LIST
76771: LIST
76772: LIST
76773: ST_TO_ADDR
// if GetClass ( i ) = 5 then
76774: LD_VAR 0 6
76778: PPUSH
76779: CALL_OW 257
76783: PUSH
76784: LD_INT 5
76786: EQUAL
76787: IFFALSE 76808
// points := [ 130 , 5 , 2 ] ;
76789: LD_ADDR_VAR 0 9
76793: PUSH
76794: LD_INT 130
76796: PUSH
76797: LD_INT 5
76799: PUSH
76800: LD_INT 2
76802: PUSH
76803: EMPTY
76804: LIST
76805: LIST
76806: LIST
76807: ST_TO_ADDR
// if GetClass ( i ) = 8 then
76808: LD_VAR 0 6
76812: PPUSH
76813: CALL_OW 257
76817: PUSH
76818: LD_INT 8
76820: EQUAL
76821: IFFALSE 76842
// points := [ 35 , 35 , 30 ] ;
76823: LD_ADDR_VAR 0 9
76827: PUSH
76828: LD_INT 35
76830: PUSH
76831: LD_INT 35
76833: PUSH
76834: LD_INT 30
76836: PUSH
76837: EMPTY
76838: LIST
76839: LIST
76840: LIST
76841: ST_TO_ADDR
// if GetClass ( i ) = 9 then
76842: LD_VAR 0 6
76846: PPUSH
76847: CALL_OW 257
76851: PUSH
76852: LD_INT 9
76854: EQUAL
76855: IFFALSE 76876
// points := [ 20 , 55 , 40 ] ;
76857: LD_ADDR_VAR 0 9
76861: PUSH
76862: LD_INT 20
76864: PUSH
76865: LD_INT 55
76867: PUSH
76868: LD_INT 40
76870: PUSH
76871: EMPTY
76872: LIST
76873: LIST
76874: LIST
76875: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
76876: LD_VAR 0 6
76880: PPUSH
76881: CALL_OW 257
76885: PUSH
76886: LD_INT 12
76888: PUSH
76889: LD_INT 16
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: IN
76896: IFFALSE 76917
// points := [ 5 , 3 , 2 ] ;
76898: LD_ADDR_VAR 0 9
76902: PUSH
76903: LD_INT 5
76905: PUSH
76906: LD_INT 3
76908: PUSH
76909: LD_INT 2
76911: PUSH
76912: EMPTY
76913: LIST
76914: LIST
76915: LIST
76916: ST_TO_ADDR
// if GetClass ( i ) = 17 then
76917: LD_VAR 0 6
76921: PPUSH
76922: CALL_OW 257
76926: PUSH
76927: LD_INT 17
76929: EQUAL
76930: IFFALSE 76951
// points := [ 100 , 50 , 75 ] ;
76932: LD_ADDR_VAR 0 9
76936: PUSH
76937: LD_INT 100
76939: PUSH
76940: LD_INT 50
76942: PUSH
76943: LD_INT 75
76945: PUSH
76946: EMPTY
76947: LIST
76948: LIST
76949: LIST
76950: ST_TO_ADDR
// if GetClass ( i ) = 15 then
76951: LD_VAR 0 6
76955: PPUSH
76956: CALL_OW 257
76960: PUSH
76961: LD_INT 15
76963: EQUAL
76964: IFFALSE 76985
// points := [ 10 , 5 , 3 ] ;
76966: LD_ADDR_VAR 0 9
76970: PUSH
76971: LD_INT 10
76973: PUSH
76974: LD_INT 5
76976: PUSH
76977: LD_INT 3
76979: PUSH
76980: EMPTY
76981: LIST
76982: LIST
76983: LIST
76984: ST_TO_ADDR
// if GetClass ( i ) = 14 then
76985: LD_VAR 0 6
76989: PPUSH
76990: CALL_OW 257
76994: PUSH
76995: LD_INT 14
76997: EQUAL
76998: IFFALSE 77019
// points := [ 10 , 0 , 0 ] ;
77000: LD_ADDR_VAR 0 9
77004: PUSH
77005: LD_INT 10
77007: PUSH
77008: LD_INT 0
77010: PUSH
77011: LD_INT 0
77013: PUSH
77014: EMPTY
77015: LIST
77016: LIST
77017: LIST
77018: ST_TO_ADDR
// if GetClass ( i ) = 11 then
77019: LD_VAR 0 6
77023: PPUSH
77024: CALL_OW 257
77028: PUSH
77029: LD_INT 11
77031: EQUAL
77032: IFFALSE 77053
// points := [ 30 , 10 , 5 ] ;
77034: LD_ADDR_VAR 0 9
77038: PUSH
77039: LD_INT 30
77041: PUSH
77042: LD_INT 10
77044: PUSH
77045: LD_INT 5
77047: PUSH
77048: EMPTY
77049: LIST
77050: LIST
77051: LIST
77052: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
77053: LD_VAR 0 1
77057: PPUSH
77058: LD_INT 5
77060: PPUSH
77061: CALL_OW 321
77065: PUSH
77066: LD_INT 2
77068: EQUAL
77069: IFFALSE 77086
// bpoints := bpoints * 1.8 ;
77071: LD_ADDR_VAR 0 10
77075: PUSH
77076: LD_VAR 0 10
77080: PUSH
77081: LD_REAL  1.80000000000000E+0000
77084: MUL
77085: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
77086: LD_VAR 0 6
77090: PPUSH
77091: CALL_OW 257
77095: PUSH
77096: LD_INT 1
77098: PUSH
77099: LD_INT 2
77101: PUSH
77102: LD_INT 3
77104: PUSH
77105: LD_INT 4
77107: PUSH
77108: EMPTY
77109: LIST
77110: LIST
77111: LIST
77112: LIST
77113: IN
77114: PUSH
77115: LD_VAR 0 1
77119: PPUSH
77120: LD_INT 51
77122: PPUSH
77123: CALL_OW 321
77127: PUSH
77128: LD_INT 2
77130: EQUAL
77131: AND
77132: IFFALSE 77149
// bpoints := bpoints * 1.2 ;
77134: LD_ADDR_VAR 0 10
77138: PUSH
77139: LD_VAR 0 10
77143: PUSH
77144: LD_REAL  1.20000000000000E+0000
77147: MUL
77148: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
77149: LD_VAR 0 6
77153: PPUSH
77154: CALL_OW 257
77158: PUSH
77159: LD_INT 5
77161: PUSH
77162: LD_INT 7
77164: PUSH
77165: LD_INT 9
77167: PUSH
77168: EMPTY
77169: LIST
77170: LIST
77171: LIST
77172: IN
77173: PUSH
77174: LD_VAR 0 1
77178: PPUSH
77179: LD_INT 52
77181: PPUSH
77182: CALL_OW 321
77186: PUSH
77187: LD_INT 2
77189: EQUAL
77190: AND
77191: IFFALSE 77208
// bpoints := bpoints * 1.5 ;
77193: LD_ADDR_VAR 0 10
77197: PUSH
77198: LD_VAR 0 10
77202: PUSH
77203: LD_REAL  1.50000000000000E+0000
77206: MUL
77207: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
77208: LD_VAR 0 1
77212: PPUSH
77213: LD_INT 66
77215: PPUSH
77216: CALL_OW 321
77220: PUSH
77221: LD_INT 2
77223: EQUAL
77224: IFFALSE 77241
// bpoints := bpoints * 1.1 ;
77226: LD_ADDR_VAR 0 10
77230: PUSH
77231: LD_VAR 0 10
77235: PUSH
77236: LD_REAL  1.10000000000000E+0000
77239: MUL
77240: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
77241: LD_ADDR_VAR 0 10
77245: PUSH
77246: LD_VAR 0 10
77250: PUSH
77251: LD_VAR 0 6
77255: PPUSH
77256: LD_INT 1
77258: PPUSH
77259: CALL_OW 259
77263: PUSH
77264: LD_REAL  1.15000000000000E+0000
77267: MUL
77268: MUL
77269: ST_TO_ADDR
// end ; unit_vehicle :
77270: GO 78098
77272: LD_INT 2
77274: DOUBLE
77275: EQUAL
77276: IFTRUE 77280
77278: GO 78086
77280: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
77281: LD_VAR 0 6
77285: PPUSH
77286: CALL_OW 264
77290: PUSH
77291: LD_INT 2
77293: PUSH
77294: LD_INT 42
77296: PUSH
77297: LD_INT 24
77299: PUSH
77300: EMPTY
77301: LIST
77302: LIST
77303: LIST
77304: IN
77305: IFFALSE 77326
// points := [ 25 , 5 , 3 ] ;
77307: LD_ADDR_VAR 0 9
77311: PUSH
77312: LD_INT 25
77314: PUSH
77315: LD_INT 5
77317: PUSH
77318: LD_INT 3
77320: PUSH
77321: EMPTY
77322: LIST
77323: LIST
77324: LIST
77325: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
77326: LD_VAR 0 6
77330: PPUSH
77331: CALL_OW 264
77335: PUSH
77336: LD_INT 4
77338: PUSH
77339: LD_INT 43
77341: PUSH
77342: LD_INT 25
77344: PUSH
77345: EMPTY
77346: LIST
77347: LIST
77348: LIST
77349: IN
77350: IFFALSE 77371
// points := [ 40 , 15 , 5 ] ;
77352: LD_ADDR_VAR 0 9
77356: PUSH
77357: LD_INT 40
77359: PUSH
77360: LD_INT 15
77362: PUSH
77363: LD_INT 5
77365: PUSH
77366: EMPTY
77367: LIST
77368: LIST
77369: LIST
77370: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
77371: LD_VAR 0 6
77375: PPUSH
77376: CALL_OW 264
77380: PUSH
77381: LD_INT 3
77383: PUSH
77384: LD_INT 23
77386: PUSH
77387: EMPTY
77388: LIST
77389: LIST
77390: IN
77391: IFFALSE 77412
// points := [ 7 , 25 , 8 ] ;
77393: LD_ADDR_VAR 0 9
77397: PUSH
77398: LD_INT 7
77400: PUSH
77401: LD_INT 25
77403: PUSH
77404: LD_INT 8
77406: PUSH
77407: EMPTY
77408: LIST
77409: LIST
77410: LIST
77411: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
77412: LD_VAR 0 6
77416: PPUSH
77417: CALL_OW 264
77421: PUSH
77422: LD_INT 5
77424: PUSH
77425: LD_INT 27
77427: PUSH
77428: LD_INT 44
77430: PUSH
77431: EMPTY
77432: LIST
77433: LIST
77434: LIST
77435: IN
77436: IFFALSE 77457
// points := [ 14 , 50 , 16 ] ;
77438: LD_ADDR_VAR 0 9
77442: PUSH
77443: LD_INT 14
77445: PUSH
77446: LD_INT 50
77448: PUSH
77449: LD_INT 16
77451: PUSH
77452: EMPTY
77453: LIST
77454: LIST
77455: LIST
77456: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
77457: LD_VAR 0 6
77461: PPUSH
77462: CALL_OW 264
77466: PUSH
77467: LD_INT 6
77469: PUSH
77470: LD_INT 46
77472: PUSH
77473: EMPTY
77474: LIST
77475: LIST
77476: IN
77477: IFFALSE 77498
// points := [ 32 , 120 , 70 ] ;
77479: LD_ADDR_VAR 0 9
77483: PUSH
77484: LD_INT 32
77486: PUSH
77487: LD_INT 120
77489: PUSH
77490: LD_INT 70
77492: PUSH
77493: EMPTY
77494: LIST
77495: LIST
77496: LIST
77497: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
77498: LD_VAR 0 6
77502: PPUSH
77503: CALL_OW 264
77507: PUSH
77508: LD_INT 7
77510: PUSH
77511: LD_INT 28
77513: PUSH
77514: LD_INT 45
77516: PUSH
77517: LD_INT 92
77519: PUSH
77520: EMPTY
77521: LIST
77522: LIST
77523: LIST
77524: LIST
77525: IN
77526: IFFALSE 77547
// points := [ 35 , 20 , 45 ] ;
77528: LD_ADDR_VAR 0 9
77532: PUSH
77533: LD_INT 35
77535: PUSH
77536: LD_INT 20
77538: PUSH
77539: LD_INT 45
77541: PUSH
77542: EMPTY
77543: LIST
77544: LIST
77545: LIST
77546: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
77547: LD_VAR 0 6
77551: PPUSH
77552: CALL_OW 264
77556: PUSH
77557: LD_INT 47
77559: PUSH
77560: EMPTY
77561: LIST
77562: IN
77563: IFFALSE 77584
// points := [ 67 , 45 , 75 ] ;
77565: LD_ADDR_VAR 0 9
77569: PUSH
77570: LD_INT 67
77572: PUSH
77573: LD_INT 45
77575: PUSH
77576: LD_INT 75
77578: PUSH
77579: EMPTY
77580: LIST
77581: LIST
77582: LIST
77583: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
77584: LD_VAR 0 6
77588: PPUSH
77589: CALL_OW 264
77593: PUSH
77594: LD_INT 26
77596: PUSH
77597: EMPTY
77598: LIST
77599: IN
77600: IFFALSE 77621
// points := [ 120 , 30 , 80 ] ;
77602: LD_ADDR_VAR 0 9
77606: PUSH
77607: LD_INT 120
77609: PUSH
77610: LD_INT 30
77612: PUSH
77613: LD_INT 80
77615: PUSH
77616: EMPTY
77617: LIST
77618: LIST
77619: LIST
77620: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
77621: LD_VAR 0 6
77625: PPUSH
77626: CALL_OW 264
77630: PUSH
77631: LD_INT 22
77633: PUSH
77634: EMPTY
77635: LIST
77636: IN
77637: IFFALSE 77658
// points := [ 40 , 1 , 1 ] ;
77639: LD_ADDR_VAR 0 9
77643: PUSH
77644: LD_INT 40
77646: PUSH
77647: LD_INT 1
77649: PUSH
77650: LD_INT 1
77652: PUSH
77653: EMPTY
77654: LIST
77655: LIST
77656: LIST
77657: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
77658: LD_VAR 0 6
77662: PPUSH
77663: CALL_OW 264
77667: PUSH
77668: LD_INT 29
77670: PUSH
77671: EMPTY
77672: LIST
77673: IN
77674: IFFALSE 77695
// points := [ 70 , 200 , 400 ] ;
77676: LD_ADDR_VAR 0 9
77680: PUSH
77681: LD_INT 70
77683: PUSH
77684: LD_INT 200
77686: PUSH
77687: LD_INT 400
77689: PUSH
77690: EMPTY
77691: LIST
77692: LIST
77693: LIST
77694: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
77695: LD_VAR 0 6
77699: PPUSH
77700: CALL_OW 264
77704: PUSH
77705: LD_INT 14
77707: PUSH
77708: LD_INT 53
77710: PUSH
77711: EMPTY
77712: LIST
77713: LIST
77714: IN
77715: IFFALSE 77736
// points := [ 40 , 10 , 20 ] ;
77717: LD_ADDR_VAR 0 9
77721: PUSH
77722: LD_INT 40
77724: PUSH
77725: LD_INT 10
77727: PUSH
77728: LD_INT 20
77730: PUSH
77731: EMPTY
77732: LIST
77733: LIST
77734: LIST
77735: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
77736: LD_VAR 0 6
77740: PPUSH
77741: CALL_OW 264
77745: PUSH
77746: LD_INT 9
77748: PUSH
77749: EMPTY
77750: LIST
77751: IN
77752: IFFALSE 77773
// points := [ 5 , 70 , 20 ] ;
77754: LD_ADDR_VAR 0 9
77758: PUSH
77759: LD_INT 5
77761: PUSH
77762: LD_INT 70
77764: PUSH
77765: LD_INT 20
77767: PUSH
77768: EMPTY
77769: LIST
77770: LIST
77771: LIST
77772: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
77773: LD_VAR 0 6
77777: PPUSH
77778: CALL_OW 264
77782: PUSH
77783: LD_INT 10
77785: PUSH
77786: EMPTY
77787: LIST
77788: IN
77789: IFFALSE 77810
// points := [ 35 , 110 , 70 ] ;
77791: LD_ADDR_VAR 0 9
77795: PUSH
77796: LD_INT 35
77798: PUSH
77799: LD_INT 110
77801: PUSH
77802: LD_INT 70
77804: PUSH
77805: EMPTY
77806: LIST
77807: LIST
77808: LIST
77809: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
77810: LD_VAR 0 6
77814: PPUSH
77815: CALL_OW 265
77819: PUSH
77820: LD_INT 25
77822: EQUAL
77823: IFFALSE 77844
// points := [ 80 , 65 , 100 ] ;
77825: LD_ADDR_VAR 0 9
77829: PUSH
77830: LD_INT 80
77832: PUSH
77833: LD_INT 65
77835: PUSH
77836: LD_INT 100
77838: PUSH
77839: EMPTY
77840: LIST
77841: LIST
77842: LIST
77843: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
77844: LD_VAR 0 6
77848: PPUSH
77849: CALL_OW 263
77853: PUSH
77854: LD_INT 1
77856: EQUAL
77857: IFFALSE 77892
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
77859: LD_ADDR_VAR 0 10
77863: PUSH
77864: LD_VAR 0 10
77868: PUSH
77869: LD_VAR 0 6
77873: PPUSH
77874: CALL_OW 311
77878: PPUSH
77879: LD_INT 3
77881: PPUSH
77882: CALL_OW 259
77886: PUSH
77887: LD_INT 4
77889: MUL
77890: MUL
77891: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
77892: LD_VAR 0 6
77896: PPUSH
77897: CALL_OW 263
77901: PUSH
77902: LD_INT 2
77904: EQUAL
77905: IFFALSE 77956
// begin j := IsControledBy ( i ) ;
77907: LD_ADDR_VAR 0 7
77911: PUSH
77912: LD_VAR 0 6
77916: PPUSH
77917: CALL_OW 312
77921: ST_TO_ADDR
// if j then
77922: LD_VAR 0 7
77926: IFFALSE 77956
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
77928: LD_ADDR_VAR 0 10
77932: PUSH
77933: LD_VAR 0 10
77937: PUSH
77938: LD_VAR 0 7
77942: PPUSH
77943: LD_INT 3
77945: PPUSH
77946: CALL_OW 259
77950: PUSH
77951: LD_INT 3
77953: MUL
77954: MUL
77955: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
77956: LD_VAR 0 6
77960: PPUSH
77961: CALL_OW 264
77965: PUSH
77966: LD_INT 5
77968: PUSH
77969: LD_INT 6
77971: PUSH
77972: LD_INT 46
77974: PUSH
77975: LD_INT 44
77977: PUSH
77978: LD_INT 47
77980: PUSH
77981: LD_INT 45
77983: PUSH
77984: LD_INT 28
77986: PUSH
77987: LD_INT 7
77989: PUSH
77990: LD_INT 27
77992: PUSH
77993: LD_INT 29
77995: PUSH
77996: EMPTY
77997: LIST
77998: LIST
77999: LIST
78000: LIST
78001: LIST
78002: LIST
78003: LIST
78004: LIST
78005: LIST
78006: LIST
78007: IN
78008: PUSH
78009: LD_VAR 0 1
78013: PPUSH
78014: LD_INT 52
78016: PPUSH
78017: CALL_OW 321
78021: PUSH
78022: LD_INT 2
78024: EQUAL
78025: AND
78026: IFFALSE 78043
// bpoints := bpoints * 1.2 ;
78028: LD_ADDR_VAR 0 10
78032: PUSH
78033: LD_VAR 0 10
78037: PUSH
78038: LD_REAL  1.20000000000000E+0000
78041: MUL
78042: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
78043: LD_VAR 0 6
78047: PPUSH
78048: CALL_OW 264
78052: PUSH
78053: LD_INT 6
78055: PUSH
78056: LD_INT 46
78058: PUSH
78059: LD_INT 47
78061: PUSH
78062: EMPTY
78063: LIST
78064: LIST
78065: LIST
78066: IN
78067: IFFALSE 78084
// bpoints := bpoints * 1.2 ;
78069: LD_ADDR_VAR 0 10
78073: PUSH
78074: LD_VAR 0 10
78078: PUSH
78079: LD_REAL  1.20000000000000E+0000
78082: MUL
78083: ST_TO_ADDR
// end ; unit_building :
78084: GO 78098
78086: LD_INT 3
78088: DOUBLE
78089: EQUAL
78090: IFTRUE 78094
78092: GO 78097
78094: POP
// ; end ;
78095: GO 78098
78097: POP
// for j = 1 to 3 do
78098: LD_ADDR_VAR 0 7
78102: PUSH
78103: DOUBLE
78104: LD_INT 1
78106: DEC
78107: ST_TO_ADDR
78108: LD_INT 3
78110: PUSH
78111: FOR_TO
78112: IFFALSE 78165
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
78114: LD_ADDR_VAR 0 5
78118: PUSH
78119: LD_VAR 0 5
78123: PPUSH
78124: LD_VAR 0 7
78128: PPUSH
78129: LD_VAR 0 5
78133: PUSH
78134: LD_VAR 0 7
78138: ARRAY
78139: PUSH
78140: LD_VAR 0 9
78144: PUSH
78145: LD_VAR 0 7
78149: ARRAY
78150: PUSH
78151: LD_VAR 0 10
78155: MUL
78156: PLUS
78157: PPUSH
78158: CALL_OW 1
78162: ST_TO_ADDR
78163: GO 78111
78165: POP
78166: POP
// end ;
78167: GO 76646
78169: POP
78170: POP
// result := Replace ( result , 4 , tmp ) ;
78171: LD_ADDR_VAR 0 5
78175: PUSH
78176: LD_VAR 0 5
78180: PPUSH
78181: LD_INT 4
78183: PPUSH
78184: LD_VAR 0 8
78188: PPUSH
78189: CALL_OW 1
78193: ST_TO_ADDR
// end ;
78194: LD_VAR 0 5
78198: RET
// export function DangerAtRange ( unit , range ) ; begin
78199: LD_INT 0
78201: PPUSH
// if not unit then
78202: LD_VAR 0 1
78206: NOT
78207: IFFALSE 78211
// exit ;
78209: GO 78256
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
78211: LD_ADDR_VAR 0 3
78215: PUSH
78216: LD_VAR 0 1
78220: PPUSH
78221: CALL_OW 255
78225: PPUSH
78226: LD_VAR 0 1
78230: PPUSH
78231: CALL_OW 250
78235: PPUSH
78236: LD_VAR 0 1
78240: PPUSH
78241: CALL_OW 251
78245: PPUSH
78246: LD_VAR 0 2
78250: PPUSH
78251: CALL 76498 0 4
78255: ST_TO_ADDR
// end ;
78256: LD_VAR 0 3
78260: RET
// export function DangerInArea ( side , area ) ; begin
78261: LD_INT 0
78263: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
78264: LD_ADDR_VAR 0 3
78268: PUSH
78269: LD_VAR 0 2
78273: PPUSH
78274: LD_INT 81
78276: PUSH
78277: LD_VAR 0 1
78281: PUSH
78282: EMPTY
78283: LIST
78284: LIST
78285: PPUSH
78286: CALL_OW 70
78290: ST_TO_ADDR
// end ;
78291: LD_VAR 0 3
78295: RET
// export function IsExtension ( b ) ; begin
78296: LD_INT 0
78298: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
78299: LD_ADDR_VAR 0 2
78303: PUSH
78304: LD_VAR 0 1
78308: PUSH
78309: LD_INT 23
78311: PUSH
78312: LD_INT 20
78314: PUSH
78315: LD_INT 22
78317: PUSH
78318: LD_INT 17
78320: PUSH
78321: LD_INT 24
78323: PUSH
78324: LD_INT 21
78326: PUSH
78327: LD_INT 19
78329: PUSH
78330: LD_INT 16
78332: PUSH
78333: LD_INT 25
78335: PUSH
78336: LD_INT 18
78338: PUSH
78339: EMPTY
78340: LIST
78341: LIST
78342: LIST
78343: LIST
78344: LIST
78345: LIST
78346: LIST
78347: LIST
78348: LIST
78349: LIST
78350: IN
78351: ST_TO_ADDR
// end ;
78352: LD_VAR 0 2
78356: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
78357: LD_INT 0
78359: PPUSH
78360: PPUSH
78361: PPUSH
// result := [ ] ;
78362: LD_ADDR_VAR 0 4
78366: PUSH
78367: EMPTY
78368: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
78369: LD_ADDR_VAR 0 5
78373: PUSH
78374: LD_VAR 0 2
78378: PPUSH
78379: LD_INT 21
78381: PUSH
78382: LD_INT 3
78384: PUSH
78385: EMPTY
78386: LIST
78387: LIST
78388: PPUSH
78389: CALL_OW 70
78393: ST_TO_ADDR
// if not tmp then
78394: LD_VAR 0 5
78398: NOT
78399: IFFALSE 78403
// exit ;
78401: GO 78467
// if checkLink then
78403: LD_VAR 0 3
78407: IFFALSE 78457
// begin for i in tmp do
78409: LD_ADDR_VAR 0 6
78413: PUSH
78414: LD_VAR 0 5
78418: PUSH
78419: FOR_IN
78420: IFFALSE 78455
// if GetBase ( i ) <> base then
78422: LD_VAR 0 6
78426: PPUSH
78427: CALL_OW 274
78431: PUSH
78432: LD_VAR 0 1
78436: NONEQUAL
78437: IFFALSE 78453
// ComLinkToBase ( base , i ) ;
78439: LD_VAR 0 1
78443: PPUSH
78444: LD_VAR 0 6
78448: PPUSH
78449: CALL_OW 169
78453: GO 78419
78455: POP
78456: POP
// end ; result := tmp ;
78457: LD_ADDR_VAR 0 4
78461: PUSH
78462: LD_VAR 0 5
78466: ST_TO_ADDR
// end ;
78467: LD_VAR 0 4
78471: RET
// export function ComComplete ( units , b ) ; var i ; begin
78472: LD_INT 0
78474: PPUSH
78475: PPUSH
// if not units then
78476: LD_VAR 0 1
78480: NOT
78481: IFFALSE 78485
// exit ;
78483: GO 78575
// for i in units do
78485: LD_ADDR_VAR 0 4
78489: PUSH
78490: LD_VAR 0 1
78494: PUSH
78495: FOR_IN
78496: IFFALSE 78573
// if BuildingStatus ( b ) = bs_build then
78498: LD_VAR 0 2
78502: PPUSH
78503: CALL_OW 461
78507: PUSH
78508: LD_INT 1
78510: EQUAL
78511: IFFALSE 78571
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
78513: LD_VAR 0 4
78517: PPUSH
78518: LD_STRING h
78520: PUSH
78521: LD_VAR 0 2
78525: PPUSH
78526: CALL_OW 250
78530: PUSH
78531: LD_VAR 0 2
78535: PPUSH
78536: CALL_OW 251
78540: PUSH
78541: LD_VAR 0 2
78545: PUSH
78546: LD_INT 0
78548: PUSH
78549: LD_INT 0
78551: PUSH
78552: LD_INT 0
78554: PUSH
78555: EMPTY
78556: LIST
78557: LIST
78558: LIST
78559: LIST
78560: LIST
78561: LIST
78562: LIST
78563: PUSH
78564: EMPTY
78565: LIST
78566: PPUSH
78567: CALL_OW 446
78571: GO 78495
78573: POP
78574: POP
// end ;
78575: LD_VAR 0 3
78579: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
78580: LD_INT 0
78582: PPUSH
78583: PPUSH
78584: PPUSH
78585: PPUSH
78586: PPUSH
78587: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
78588: LD_VAR 0 1
78592: NOT
78593: PUSH
78594: LD_VAR 0 1
78598: PPUSH
78599: CALL_OW 263
78603: PUSH
78604: LD_INT 2
78606: NONEQUAL
78607: OR
78608: IFFALSE 78612
// exit ;
78610: GO 78928
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
78612: LD_ADDR_VAR 0 6
78616: PUSH
78617: LD_INT 22
78619: PUSH
78620: LD_VAR 0 1
78624: PPUSH
78625: CALL_OW 255
78629: PUSH
78630: EMPTY
78631: LIST
78632: LIST
78633: PUSH
78634: LD_INT 2
78636: PUSH
78637: LD_INT 30
78639: PUSH
78640: LD_INT 36
78642: PUSH
78643: EMPTY
78644: LIST
78645: LIST
78646: PUSH
78647: LD_INT 34
78649: PUSH
78650: LD_INT 31
78652: PUSH
78653: EMPTY
78654: LIST
78655: LIST
78656: PUSH
78657: EMPTY
78658: LIST
78659: LIST
78660: LIST
78661: PUSH
78662: EMPTY
78663: LIST
78664: LIST
78665: PPUSH
78666: CALL_OW 69
78670: ST_TO_ADDR
// if not tmp then
78671: LD_VAR 0 6
78675: NOT
78676: IFFALSE 78680
// exit ;
78678: GO 78928
// result := [ ] ;
78680: LD_ADDR_VAR 0 2
78684: PUSH
78685: EMPTY
78686: ST_TO_ADDR
// for i in tmp do
78687: LD_ADDR_VAR 0 3
78691: PUSH
78692: LD_VAR 0 6
78696: PUSH
78697: FOR_IN
78698: IFFALSE 78769
// begin t := UnitsInside ( i ) ;
78700: LD_ADDR_VAR 0 4
78704: PUSH
78705: LD_VAR 0 3
78709: PPUSH
78710: CALL_OW 313
78714: ST_TO_ADDR
// if t then
78715: LD_VAR 0 4
78719: IFFALSE 78767
// for j in t do
78721: LD_ADDR_VAR 0 7
78725: PUSH
78726: LD_VAR 0 4
78730: PUSH
78731: FOR_IN
78732: IFFALSE 78765
// result := Replace ( result , result + 1 , j ) ;
78734: LD_ADDR_VAR 0 2
78738: PUSH
78739: LD_VAR 0 2
78743: PPUSH
78744: LD_VAR 0 2
78748: PUSH
78749: LD_INT 1
78751: PLUS
78752: PPUSH
78753: LD_VAR 0 7
78757: PPUSH
78758: CALL_OW 1
78762: ST_TO_ADDR
78763: GO 78731
78765: POP
78766: POP
// end ;
78767: GO 78697
78769: POP
78770: POP
// if not result then
78771: LD_VAR 0 2
78775: NOT
78776: IFFALSE 78780
// exit ;
78778: GO 78928
// mech := result [ 1 ] ;
78780: LD_ADDR_VAR 0 5
78784: PUSH
78785: LD_VAR 0 2
78789: PUSH
78790: LD_INT 1
78792: ARRAY
78793: ST_TO_ADDR
// if result > 1 then
78794: LD_VAR 0 2
78798: PUSH
78799: LD_INT 1
78801: GREATER
78802: IFFALSE 78914
// begin for i = 2 to result do
78804: LD_ADDR_VAR 0 3
78808: PUSH
78809: DOUBLE
78810: LD_INT 2
78812: DEC
78813: ST_TO_ADDR
78814: LD_VAR 0 2
78818: PUSH
78819: FOR_TO
78820: IFFALSE 78912
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
78822: LD_ADDR_VAR 0 4
78826: PUSH
78827: LD_VAR 0 2
78831: PUSH
78832: LD_VAR 0 3
78836: ARRAY
78837: PPUSH
78838: LD_INT 3
78840: PPUSH
78841: CALL_OW 259
78845: PUSH
78846: LD_VAR 0 2
78850: PUSH
78851: LD_VAR 0 3
78855: ARRAY
78856: PPUSH
78857: CALL_OW 432
78861: MINUS
78862: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
78863: LD_VAR 0 4
78867: PUSH
78868: LD_VAR 0 5
78872: PPUSH
78873: LD_INT 3
78875: PPUSH
78876: CALL_OW 259
78880: PUSH
78881: LD_VAR 0 5
78885: PPUSH
78886: CALL_OW 432
78890: MINUS
78891: GREATEREQUAL
78892: IFFALSE 78910
// mech := result [ i ] ;
78894: LD_ADDR_VAR 0 5
78898: PUSH
78899: LD_VAR 0 2
78903: PUSH
78904: LD_VAR 0 3
78908: ARRAY
78909: ST_TO_ADDR
// end ;
78910: GO 78819
78912: POP
78913: POP
// end ; ComLinkTo ( vehicle , mech ) ;
78914: LD_VAR 0 1
78918: PPUSH
78919: LD_VAR 0 5
78923: PPUSH
78924: CALL_OW 135
// end ;
78928: LD_VAR 0 2
78932: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
78933: LD_INT 0
78935: PPUSH
78936: PPUSH
78937: PPUSH
78938: PPUSH
78939: PPUSH
78940: PPUSH
78941: PPUSH
78942: PPUSH
78943: PPUSH
78944: PPUSH
78945: PPUSH
78946: PPUSH
78947: PPUSH
// result := [ ] ;
78948: LD_ADDR_VAR 0 7
78952: PUSH
78953: EMPTY
78954: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
78955: LD_VAR 0 1
78959: PPUSH
78960: CALL_OW 266
78964: PUSH
78965: LD_INT 0
78967: PUSH
78968: LD_INT 1
78970: PUSH
78971: EMPTY
78972: LIST
78973: LIST
78974: IN
78975: NOT
78976: IFFALSE 78980
// exit ;
78978: GO 80614
// if name then
78980: LD_VAR 0 3
78984: IFFALSE 79000
// SetBName ( base_dep , name ) ;
78986: LD_VAR 0 1
78990: PPUSH
78991: LD_VAR 0 3
78995: PPUSH
78996: CALL_OW 500
// base := GetBase ( base_dep ) ;
79000: LD_ADDR_VAR 0 15
79004: PUSH
79005: LD_VAR 0 1
79009: PPUSH
79010: CALL_OW 274
79014: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
79015: LD_ADDR_VAR 0 16
79019: PUSH
79020: LD_VAR 0 1
79024: PPUSH
79025: CALL_OW 255
79029: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
79030: LD_ADDR_VAR 0 17
79034: PUSH
79035: LD_VAR 0 1
79039: PPUSH
79040: CALL_OW 248
79044: ST_TO_ADDR
// if sources then
79045: LD_VAR 0 5
79049: IFFALSE 79096
// for i = 1 to 3 do
79051: LD_ADDR_VAR 0 8
79055: PUSH
79056: DOUBLE
79057: LD_INT 1
79059: DEC
79060: ST_TO_ADDR
79061: LD_INT 3
79063: PUSH
79064: FOR_TO
79065: IFFALSE 79094
// AddResourceType ( base , i , sources [ i ] ) ;
79067: LD_VAR 0 15
79071: PPUSH
79072: LD_VAR 0 8
79076: PPUSH
79077: LD_VAR 0 5
79081: PUSH
79082: LD_VAR 0 8
79086: ARRAY
79087: PPUSH
79088: CALL_OW 276
79092: GO 79064
79094: POP
79095: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
79096: LD_ADDR_VAR 0 18
79100: PUSH
79101: LD_VAR 0 15
79105: PPUSH
79106: LD_VAR 0 2
79110: PPUSH
79111: LD_INT 1
79113: PPUSH
79114: CALL 78357 0 3
79118: ST_TO_ADDR
// InitHc ;
79119: CALL_OW 19
// InitUc ;
79123: CALL_OW 18
// uc_side := side ;
79127: LD_ADDR_OWVAR 20
79131: PUSH
79132: LD_VAR 0 16
79136: ST_TO_ADDR
// uc_nation := nation ;
79137: LD_ADDR_OWVAR 21
79141: PUSH
79142: LD_VAR 0 17
79146: ST_TO_ADDR
// if buildings then
79147: LD_VAR 0 18
79151: IFFALSE 80473
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
79153: LD_ADDR_VAR 0 19
79157: PUSH
79158: LD_VAR 0 18
79162: PPUSH
79163: LD_INT 2
79165: PUSH
79166: LD_INT 30
79168: PUSH
79169: LD_INT 29
79171: PUSH
79172: EMPTY
79173: LIST
79174: LIST
79175: PUSH
79176: LD_INT 30
79178: PUSH
79179: LD_INT 30
79181: PUSH
79182: EMPTY
79183: LIST
79184: LIST
79185: PUSH
79186: EMPTY
79187: LIST
79188: LIST
79189: LIST
79190: PPUSH
79191: CALL_OW 72
79195: ST_TO_ADDR
// if tmp then
79196: LD_VAR 0 19
79200: IFFALSE 79248
// for i in tmp do
79202: LD_ADDR_VAR 0 8
79206: PUSH
79207: LD_VAR 0 19
79211: PUSH
79212: FOR_IN
79213: IFFALSE 79246
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
79215: LD_VAR 0 8
79219: PPUSH
79220: CALL_OW 250
79224: PPUSH
79225: LD_VAR 0 8
79229: PPUSH
79230: CALL_OW 251
79234: PPUSH
79235: LD_VAR 0 16
79239: PPUSH
79240: CALL_OW 441
79244: GO 79212
79246: POP
79247: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
79248: LD_VAR 0 18
79252: PPUSH
79253: LD_INT 2
79255: PUSH
79256: LD_INT 30
79258: PUSH
79259: LD_INT 32
79261: PUSH
79262: EMPTY
79263: LIST
79264: LIST
79265: PUSH
79266: LD_INT 30
79268: PUSH
79269: LD_INT 33
79271: PUSH
79272: EMPTY
79273: LIST
79274: LIST
79275: PUSH
79276: EMPTY
79277: LIST
79278: LIST
79279: LIST
79280: PPUSH
79281: CALL_OW 72
79285: IFFALSE 79373
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
79287: LD_ADDR_VAR 0 8
79291: PUSH
79292: LD_VAR 0 18
79296: PPUSH
79297: LD_INT 2
79299: PUSH
79300: LD_INT 30
79302: PUSH
79303: LD_INT 32
79305: PUSH
79306: EMPTY
79307: LIST
79308: LIST
79309: PUSH
79310: LD_INT 30
79312: PUSH
79313: LD_INT 33
79315: PUSH
79316: EMPTY
79317: LIST
79318: LIST
79319: PUSH
79320: EMPTY
79321: LIST
79322: LIST
79323: LIST
79324: PPUSH
79325: CALL_OW 72
79329: PUSH
79330: FOR_IN
79331: IFFALSE 79371
// begin if not GetBWeapon ( i ) then
79333: LD_VAR 0 8
79337: PPUSH
79338: CALL_OW 269
79342: NOT
79343: IFFALSE 79369
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
79345: LD_VAR 0 8
79349: PPUSH
79350: LD_VAR 0 8
79354: PPUSH
79355: LD_VAR 0 2
79359: PPUSH
79360: CALL 80619 0 2
79364: PPUSH
79365: CALL_OW 431
// end ;
79369: GO 79330
79371: POP
79372: POP
// end ; for i = 1 to personel do
79373: LD_ADDR_VAR 0 8
79377: PUSH
79378: DOUBLE
79379: LD_INT 1
79381: DEC
79382: ST_TO_ADDR
79383: LD_VAR 0 6
79387: PUSH
79388: FOR_TO
79389: IFFALSE 80453
// begin if i > 4 then
79391: LD_VAR 0 8
79395: PUSH
79396: LD_INT 4
79398: GREATER
79399: IFFALSE 79403
// break ;
79401: GO 80453
// case i of 1 :
79403: LD_VAR 0 8
79407: PUSH
79408: LD_INT 1
79410: DOUBLE
79411: EQUAL
79412: IFTRUE 79416
79414: GO 79496
79416: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
79417: LD_ADDR_VAR 0 12
79421: PUSH
79422: LD_VAR 0 18
79426: PPUSH
79427: LD_INT 22
79429: PUSH
79430: LD_VAR 0 16
79434: PUSH
79435: EMPTY
79436: LIST
79437: LIST
79438: PUSH
79439: LD_INT 58
79441: PUSH
79442: EMPTY
79443: LIST
79444: PUSH
79445: LD_INT 2
79447: PUSH
79448: LD_INT 30
79450: PUSH
79451: LD_INT 32
79453: PUSH
79454: EMPTY
79455: LIST
79456: LIST
79457: PUSH
79458: LD_INT 30
79460: PUSH
79461: LD_INT 4
79463: PUSH
79464: EMPTY
79465: LIST
79466: LIST
79467: PUSH
79468: LD_INT 30
79470: PUSH
79471: LD_INT 5
79473: PUSH
79474: EMPTY
79475: LIST
79476: LIST
79477: PUSH
79478: EMPTY
79479: LIST
79480: LIST
79481: LIST
79482: LIST
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: LIST
79488: PPUSH
79489: CALL_OW 72
79493: ST_TO_ADDR
79494: GO 79718
79496: LD_INT 2
79498: DOUBLE
79499: EQUAL
79500: IFTRUE 79504
79502: GO 79566
79504: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
79505: LD_ADDR_VAR 0 12
79509: PUSH
79510: LD_VAR 0 18
79514: PPUSH
79515: LD_INT 22
79517: PUSH
79518: LD_VAR 0 16
79522: PUSH
79523: EMPTY
79524: LIST
79525: LIST
79526: PUSH
79527: LD_INT 2
79529: PUSH
79530: LD_INT 30
79532: PUSH
79533: LD_INT 0
79535: PUSH
79536: EMPTY
79537: LIST
79538: LIST
79539: PUSH
79540: LD_INT 30
79542: PUSH
79543: LD_INT 1
79545: PUSH
79546: EMPTY
79547: LIST
79548: LIST
79549: PUSH
79550: EMPTY
79551: LIST
79552: LIST
79553: LIST
79554: PUSH
79555: EMPTY
79556: LIST
79557: LIST
79558: PPUSH
79559: CALL_OW 72
79563: ST_TO_ADDR
79564: GO 79718
79566: LD_INT 3
79568: DOUBLE
79569: EQUAL
79570: IFTRUE 79574
79572: GO 79636
79574: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
79575: LD_ADDR_VAR 0 12
79579: PUSH
79580: LD_VAR 0 18
79584: PPUSH
79585: LD_INT 22
79587: PUSH
79588: LD_VAR 0 16
79592: PUSH
79593: EMPTY
79594: LIST
79595: LIST
79596: PUSH
79597: LD_INT 2
79599: PUSH
79600: LD_INT 30
79602: PUSH
79603: LD_INT 2
79605: PUSH
79606: EMPTY
79607: LIST
79608: LIST
79609: PUSH
79610: LD_INT 30
79612: PUSH
79613: LD_INT 3
79615: PUSH
79616: EMPTY
79617: LIST
79618: LIST
79619: PUSH
79620: EMPTY
79621: LIST
79622: LIST
79623: LIST
79624: PUSH
79625: EMPTY
79626: LIST
79627: LIST
79628: PPUSH
79629: CALL_OW 72
79633: ST_TO_ADDR
79634: GO 79718
79636: LD_INT 4
79638: DOUBLE
79639: EQUAL
79640: IFTRUE 79644
79642: GO 79717
79644: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
79645: LD_ADDR_VAR 0 12
79649: PUSH
79650: LD_VAR 0 18
79654: PPUSH
79655: LD_INT 22
79657: PUSH
79658: LD_VAR 0 16
79662: PUSH
79663: EMPTY
79664: LIST
79665: LIST
79666: PUSH
79667: LD_INT 2
79669: PUSH
79670: LD_INT 30
79672: PUSH
79673: LD_INT 6
79675: PUSH
79676: EMPTY
79677: LIST
79678: LIST
79679: PUSH
79680: LD_INT 30
79682: PUSH
79683: LD_INT 7
79685: PUSH
79686: EMPTY
79687: LIST
79688: LIST
79689: PUSH
79690: LD_INT 30
79692: PUSH
79693: LD_INT 8
79695: PUSH
79696: EMPTY
79697: LIST
79698: LIST
79699: PUSH
79700: EMPTY
79701: LIST
79702: LIST
79703: LIST
79704: LIST
79705: PUSH
79706: EMPTY
79707: LIST
79708: LIST
79709: PPUSH
79710: CALL_OW 72
79714: ST_TO_ADDR
79715: GO 79718
79717: POP
// if i = 1 then
79718: LD_VAR 0 8
79722: PUSH
79723: LD_INT 1
79725: EQUAL
79726: IFFALSE 79837
// begin tmp := [ ] ;
79728: LD_ADDR_VAR 0 19
79732: PUSH
79733: EMPTY
79734: ST_TO_ADDR
// for j in f do
79735: LD_ADDR_VAR 0 9
79739: PUSH
79740: LD_VAR 0 12
79744: PUSH
79745: FOR_IN
79746: IFFALSE 79819
// if GetBType ( j ) = b_bunker then
79748: LD_VAR 0 9
79752: PPUSH
79753: CALL_OW 266
79757: PUSH
79758: LD_INT 32
79760: EQUAL
79761: IFFALSE 79788
// tmp := Insert ( tmp , 1 , j ) else
79763: LD_ADDR_VAR 0 19
79767: PUSH
79768: LD_VAR 0 19
79772: PPUSH
79773: LD_INT 1
79775: PPUSH
79776: LD_VAR 0 9
79780: PPUSH
79781: CALL_OW 2
79785: ST_TO_ADDR
79786: GO 79817
// tmp := Insert ( tmp , tmp + 1 , j ) ;
79788: LD_ADDR_VAR 0 19
79792: PUSH
79793: LD_VAR 0 19
79797: PPUSH
79798: LD_VAR 0 19
79802: PUSH
79803: LD_INT 1
79805: PLUS
79806: PPUSH
79807: LD_VAR 0 9
79811: PPUSH
79812: CALL_OW 2
79816: ST_TO_ADDR
79817: GO 79745
79819: POP
79820: POP
// if tmp then
79821: LD_VAR 0 19
79825: IFFALSE 79837
// f := tmp ;
79827: LD_ADDR_VAR 0 12
79831: PUSH
79832: LD_VAR 0 19
79836: ST_TO_ADDR
// end ; x := personel [ i ] ;
79837: LD_ADDR_VAR 0 13
79841: PUSH
79842: LD_VAR 0 6
79846: PUSH
79847: LD_VAR 0 8
79851: ARRAY
79852: ST_TO_ADDR
// if x = - 1 then
79853: LD_VAR 0 13
79857: PUSH
79858: LD_INT 1
79860: NEG
79861: EQUAL
79862: IFFALSE 80071
// begin for j in f do
79864: LD_ADDR_VAR 0 9
79868: PUSH
79869: LD_VAR 0 12
79873: PUSH
79874: FOR_IN
79875: IFFALSE 80067
// repeat InitHc ;
79877: CALL_OW 19
// if GetBType ( j ) = b_barracks then
79881: LD_VAR 0 9
79885: PPUSH
79886: CALL_OW 266
79890: PUSH
79891: LD_INT 5
79893: EQUAL
79894: IFFALSE 79964
// begin if UnitsInside ( j ) < 3 then
79896: LD_VAR 0 9
79900: PPUSH
79901: CALL_OW 313
79905: PUSH
79906: LD_INT 3
79908: LESS
79909: IFFALSE 79945
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
79911: LD_INT 0
79913: PPUSH
79914: LD_INT 5
79916: PUSH
79917: LD_INT 8
79919: PUSH
79920: LD_INT 9
79922: PUSH
79923: EMPTY
79924: LIST
79925: LIST
79926: LIST
79927: PUSH
79928: LD_VAR 0 17
79932: ARRAY
79933: PPUSH
79934: LD_VAR 0 4
79938: PPUSH
79939: CALL_OW 380
79943: GO 79962
// PrepareHuman ( false , i , skill ) ;
79945: LD_INT 0
79947: PPUSH
79948: LD_VAR 0 8
79952: PPUSH
79953: LD_VAR 0 4
79957: PPUSH
79958: CALL_OW 380
// end else
79962: GO 79981
// PrepareHuman ( false , i , skill ) ;
79964: LD_INT 0
79966: PPUSH
79967: LD_VAR 0 8
79971: PPUSH
79972: LD_VAR 0 4
79976: PPUSH
79977: CALL_OW 380
// un := CreateHuman ;
79981: LD_ADDR_VAR 0 14
79985: PUSH
79986: CALL_OW 44
79990: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
79991: LD_ADDR_VAR 0 7
79995: PUSH
79996: LD_VAR 0 7
80000: PPUSH
80001: LD_INT 1
80003: PPUSH
80004: LD_VAR 0 14
80008: PPUSH
80009: CALL_OW 2
80013: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
80014: LD_VAR 0 14
80018: PPUSH
80019: LD_VAR 0 9
80023: PPUSH
80024: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
80028: LD_VAR 0 9
80032: PPUSH
80033: CALL_OW 313
80037: PUSH
80038: LD_INT 6
80040: EQUAL
80041: PUSH
80042: LD_VAR 0 9
80046: PPUSH
80047: CALL_OW 266
80051: PUSH
80052: LD_INT 32
80054: PUSH
80055: LD_INT 31
80057: PUSH
80058: EMPTY
80059: LIST
80060: LIST
80061: IN
80062: OR
80063: IFFALSE 79877
80065: GO 79874
80067: POP
80068: POP
// end else
80069: GO 80451
// for j = 1 to x do
80071: LD_ADDR_VAR 0 9
80075: PUSH
80076: DOUBLE
80077: LD_INT 1
80079: DEC
80080: ST_TO_ADDR
80081: LD_VAR 0 13
80085: PUSH
80086: FOR_TO
80087: IFFALSE 80449
// begin InitHc ;
80089: CALL_OW 19
// if not f then
80093: LD_VAR 0 12
80097: NOT
80098: IFFALSE 80187
// begin PrepareHuman ( false , i , skill ) ;
80100: LD_INT 0
80102: PPUSH
80103: LD_VAR 0 8
80107: PPUSH
80108: LD_VAR 0 4
80112: PPUSH
80113: CALL_OW 380
// un := CreateHuman ;
80117: LD_ADDR_VAR 0 14
80121: PUSH
80122: CALL_OW 44
80126: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
80127: LD_ADDR_VAR 0 7
80131: PUSH
80132: LD_VAR 0 7
80136: PPUSH
80137: LD_INT 1
80139: PPUSH
80140: LD_VAR 0 14
80144: PPUSH
80145: CALL_OW 2
80149: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
80150: LD_VAR 0 14
80154: PPUSH
80155: LD_VAR 0 1
80159: PPUSH
80160: CALL_OW 250
80164: PPUSH
80165: LD_VAR 0 1
80169: PPUSH
80170: CALL_OW 251
80174: PPUSH
80175: LD_INT 10
80177: PPUSH
80178: LD_INT 0
80180: PPUSH
80181: CALL_OW 50
// continue ;
80185: GO 80086
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
80187: LD_VAR 0 12
80191: PUSH
80192: LD_INT 1
80194: ARRAY
80195: PPUSH
80196: CALL_OW 313
80200: PUSH
80201: LD_VAR 0 12
80205: PUSH
80206: LD_INT 1
80208: ARRAY
80209: PPUSH
80210: CALL_OW 266
80214: PUSH
80215: LD_INT 32
80217: PUSH
80218: LD_INT 31
80220: PUSH
80221: EMPTY
80222: LIST
80223: LIST
80224: IN
80225: AND
80226: PUSH
80227: LD_VAR 0 12
80231: PUSH
80232: LD_INT 1
80234: ARRAY
80235: PPUSH
80236: CALL_OW 313
80240: PUSH
80241: LD_INT 6
80243: EQUAL
80244: OR
80245: IFFALSE 80265
// f := Delete ( f , 1 ) ;
80247: LD_ADDR_VAR 0 12
80251: PUSH
80252: LD_VAR 0 12
80256: PPUSH
80257: LD_INT 1
80259: PPUSH
80260: CALL_OW 3
80264: ST_TO_ADDR
// if not f then
80265: LD_VAR 0 12
80269: NOT
80270: IFFALSE 80288
// begin x := x + 2 ;
80272: LD_ADDR_VAR 0 13
80276: PUSH
80277: LD_VAR 0 13
80281: PUSH
80282: LD_INT 2
80284: PLUS
80285: ST_TO_ADDR
// continue ;
80286: GO 80086
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
80288: LD_VAR 0 12
80292: PUSH
80293: LD_INT 1
80295: ARRAY
80296: PPUSH
80297: CALL_OW 266
80301: PUSH
80302: LD_INT 5
80304: EQUAL
80305: IFFALSE 80379
// begin if UnitsInside ( f [ 1 ] ) < 3 then
80307: LD_VAR 0 12
80311: PUSH
80312: LD_INT 1
80314: ARRAY
80315: PPUSH
80316: CALL_OW 313
80320: PUSH
80321: LD_INT 3
80323: LESS
80324: IFFALSE 80360
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
80326: LD_INT 0
80328: PPUSH
80329: LD_INT 5
80331: PUSH
80332: LD_INT 8
80334: PUSH
80335: LD_INT 9
80337: PUSH
80338: EMPTY
80339: LIST
80340: LIST
80341: LIST
80342: PUSH
80343: LD_VAR 0 17
80347: ARRAY
80348: PPUSH
80349: LD_VAR 0 4
80353: PPUSH
80354: CALL_OW 380
80358: GO 80377
// PrepareHuman ( false , i , skill ) ;
80360: LD_INT 0
80362: PPUSH
80363: LD_VAR 0 8
80367: PPUSH
80368: LD_VAR 0 4
80372: PPUSH
80373: CALL_OW 380
// end else
80377: GO 80396
// PrepareHuman ( false , i , skill ) ;
80379: LD_INT 0
80381: PPUSH
80382: LD_VAR 0 8
80386: PPUSH
80387: LD_VAR 0 4
80391: PPUSH
80392: CALL_OW 380
// un := CreateHuman ;
80396: LD_ADDR_VAR 0 14
80400: PUSH
80401: CALL_OW 44
80405: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
80406: LD_ADDR_VAR 0 7
80410: PUSH
80411: LD_VAR 0 7
80415: PPUSH
80416: LD_INT 1
80418: PPUSH
80419: LD_VAR 0 14
80423: PPUSH
80424: CALL_OW 2
80428: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
80429: LD_VAR 0 14
80433: PPUSH
80434: LD_VAR 0 12
80438: PUSH
80439: LD_INT 1
80441: ARRAY
80442: PPUSH
80443: CALL_OW 52
// end ;
80447: GO 80086
80449: POP
80450: POP
// end ;
80451: GO 79388
80453: POP
80454: POP
// result := result ^ buildings ;
80455: LD_ADDR_VAR 0 7
80459: PUSH
80460: LD_VAR 0 7
80464: PUSH
80465: LD_VAR 0 18
80469: ADD
80470: ST_TO_ADDR
// end else
80471: GO 80614
// begin for i = 1 to personel do
80473: LD_ADDR_VAR 0 8
80477: PUSH
80478: DOUBLE
80479: LD_INT 1
80481: DEC
80482: ST_TO_ADDR
80483: LD_VAR 0 6
80487: PUSH
80488: FOR_TO
80489: IFFALSE 80612
// begin if i > 4 then
80491: LD_VAR 0 8
80495: PUSH
80496: LD_INT 4
80498: GREATER
80499: IFFALSE 80503
// break ;
80501: GO 80612
// x := personel [ i ] ;
80503: LD_ADDR_VAR 0 13
80507: PUSH
80508: LD_VAR 0 6
80512: PUSH
80513: LD_VAR 0 8
80517: ARRAY
80518: ST_TO_ADDR
// if x = - 1 then
80519: LD_VAR 0 13
80523: PUSH
80524: LD_INT 1
80526: NEG
80527: EQUAL
80528: IFFALSE 80532
// continue ;
80530: GO 80488
// PrepareHuman ( false , i , skill ) ;
80532: LD_INT 0
80534: PPUSH
80535: LD_VAR 0 8
80539: PPUSH
80540: LD_VAR 0 4
80544: PPUSH
80545: CALL_OW 380
// un := CreateHuman ;
80549: LD_ADDR_VAR 0 14
80553: PUSH
80554: CALL_OW 44
80558: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
80559: LD_VAR 0 14
80563: PPUSH
80564: LD_VAR 0 1
80568: PPUSH
80569: CALL_OW 250
80573: PPUSH
80574: LD_VAR 0 1
80578: PPUSH
80579: CALL_OW 251
80583: PPUSH
80584: LD_INT 10
80586: PPUSH
80587: LD_INT 0
80589: PPUSH
80590: CALL_OW 50
// result := result ^ un ;
80594: LD_ADDR_VAR 0 7
80598: PUSH
80599: LD_VAR 0 7
80603: PUSH
80604: LD_VAR 0 14
80608: ADD
80609: ST_TO_ADDR
// end ;
80610: GO 80488
80612: POP
80613: POP
// end ; end ;
80614: LD_VAR 0 7
80618: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
80619: LD_INT 0
80621: PPUSH
80622: PPUSH
80623: PPUSH
80624: PPUSH
80625: PPUSH
80626: PPUSH
80627: PPUSH
80628: PPUSH
80629: PPUSH
80630: PPUSH
80631: PPUSH
80632: PPUSH
80633: PPUSH
80634: PPUSH
80635: PPUSH
80636: PPUSH
// result := false ;
80637: LD_ADDR_VAR 0 3
80641: PUSH
80642: LD_INT 0
80644: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
80645: LD_VAR 0 1
80649: NOT
80650: PUSH
80651: LD_VAR 0 1
80655: PPUSH
80656: CALL_OW 266
80660: PUSH
80661: LD_INT 32
80663: PUSH
80664: LD_INT 33
80666: PUSH
80667: EMPTY
80668: LIST
80669: LIST
80670: IN
80671: NOT
80672: OR
80673: IFFALSE 80677
// exit ;
80675: GO 81786
// nat := GetNation ( tower ) ;
80677: LD_ADDR_VAR 0 12
80681: PUSH
80682: LD_VAR 0 1
80686: PPUSH
80687: CALL_OW 248
80691: ST_TO_ADDR
// side := GetSide ( tower ) ;
80692: LD_ADDR_VAR 0 16
80696: PUSH
80697: LD_VAR 0 1
80701: PPUSH
80702: CALL_OW 255
80706: ST_TO_ADDR
// x := GetX ( tower ) ;
80707: LD_ADDR_VAR 0 10
80711: PUSH
80712: LD_VAR 0 1
80716: PPUSH
80717: CALL_OW 250
80721: ST_TO_ADDR
// y := GetY ( tower ) ;
80722: LD_ADDR_VAR 0 11
80726: PUSH
80727: LD_VAR 0 1
80731: PPUSH
80732: CALL_OW 251
80736: ST_TO_ADDR
// if not x or not y then
80737: LD_VAR 0 10
80741: NOT
80742: PUSH
80743: LD_VAR 0 11
80747: NOT
80748: OR
80749: IFFALSE 80753
// exit ;
80751: GO 81786
// weapon := 0 ;
80753: LD_ADDR_VAR 0 18
80757: PUSH
80758: LD_INT 0
80760: ST_TO_ADDR
// fac_list := [ ] ;
80761: LD_ADDR_VAR 0 17
80765: PUSH
80766: EMPTY
80767: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
80768: LD_ADDR_VAR 0 6
80772: PUSH
80773: LD_VAR 0 1
80777: PPUSH
80778: CALL_OW 274
80782: PPUSH
80783: LD_VAR 0 2
80787: PPUSH
80788: LD_INT 0
80790: PPUSH
80791: CALL 78357 0 3
80795: PPUSH
80796: LD_INT 30
80798: PUSH
80799: LD_INT 3
80801: PUSH
80802: EMPTY
80803: LIST
80804: LIST
80805: PPUSH
80806: CALL_OW 72
80810: ST_TO_ADDR
// if not factories then
80811: LD_VAR 0 6
80815: NOT
80816: IFFALSE 80820
// exit ;
80818: GO 81786
// for i in factories do
80820: LD_ADDR_VAR 0 8
80824: PUSH
80825: LD_VAR 0 6
80829: PUSH
80830: FOR_IN
80831: IFFALSE 80856
// fac_list := fac_list union AvailableWeaponList ( i ) ;
80833: LD_ADDR_VAR 0 17
80837: PUSH
80838: LD_VAR 0 17
80842: PUSH
80843: LD_VAR 0 8
80847: PPUSH
80848: CALL_OW 478
80852: UNION
80853: ST_TO_ADDR
80854: GO 80830
80856: POP
80857: POP
// if not fac_list then
80858: LD_VAR 0 17
80862: NOT
80863: IFFALSE 80867
// exit ;
80865: GO 81786
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
80867: LD_ADDR_VAR 0 5
80871: PUSH
80872: LD_INT 4
80874: PUSH
80875: LD_INT 5
80877: PUSH
80878: LD_INT 9
80880: PUSH
80881: LD_INT 10
80883: PUSH
80884: LD_INT 6
80886: PUSH
80887: LD_INT 7
80889: PUSH
80890: LD_INT 11
80892: PUSH
80893: EMPTY
80894: LIST
80895: LIST
80896: LIST
80897: LIST
80898: LIST
80899: LIST
80900: LIST
80901: PUSH
80902: LD_INT 27
80904: PUSH
80905: LD_INT 28
80907: PUSH
80908: LD_INT 26
80910: PUSH
80911: LD_INT 30
80913: PUSH
80914: EMPTY
80915: LIST
80916: LIST
80917: LIST
80918: LIST
80919: PUSH
80920: LD_INT 43
80922: PUSH
80923: LD_INT 44
80925: PUSH
80926: LD_INT 46
80928: PUSH
80929: LD_INT 45
80931: PUSH
80932: LD_INT 47
80934: PUSH
80935: LD_INT 49
80937: PUSH
80938: EMPTY
80939: LIST
80940: LIST
80941: LIST
80942: LIST
80943: LIST
80944: LIST
80945: PUSH
80946: EMPTY
80947: LIST
80948: LIST
80949: LIST
80950: PUSH
80951: LD_VAR 0 12
80955: ARRAY
80956: ST_TO_ADDR
// list := list isect fac_list ;
80957: LD_ADDR_VAR 0 5
80961: PUSH
80962: LD_VAR 0 5
80966: PUSH
80967: LD_VAR 0 17
80971: ISECT
80972: ST_TO_ADDR
// if not list then
80973: LD_VAR 0 5
80977: NOT
80978: IFFALSE 80982
// exit ;
80980: GO 81786
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
80982: LD_VAR 0 12
80986: PUSH
80987: LD_INT 3
80989: EQUAL
80990: PUSH
80991: LD_INT 49
80993: PUSH
80994: LD_VAR 0 5
80998: IN
80999: AND
81000: PUSH
81001: LD_INT 31
81003: PPUSH
81004: LD_VAR 0 16
81008: PPUSH
81009: CALL_OW 321
81013: PUSH
81014: LD_INT 2
81016: EQUAL
81017: AND
81018: IFFALSE 81078
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
81020: LD_INT 22
81022: PUSH
81023: LD_VAR 0 16
81027: PUSH
81028: EMPTY
81029: LIST
81030: LIST
81031: PUSH
81032: LD_INT 35
81034: PUSH
81035: LD_INT 49
81037: PUSH
81038: EMPTY
81039: LIST
81040: LIST
81041: PUSH
81042: LD_INT 91
81044: PUSH
81045: LD_VAR 0 1
81049: PUSH
81050: LD_INT 10
81052: PUSH
81053: EMPTY
81054: LIST
81055: LIST
81056: LIST
81057: PUSH
81058: EMPTY
81059: LIST
81060: LIST
81061: LIST
81062: PPUSH
81063: CALL_OW 69
81067: NOT
81068: IFFALSE 81078
// weapon := ru_time_lapser ;
81070: LD_ADDR_VAR 0 18
81074: PUSH
81075: LD_INT 49
81077: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
81078: LD_VAR 0 12
81082: PUSH
81083: LD_INT 1
81085: PUSH
81086: LD_INT 2
81088: PUSH
81089: EMPTY
81090: LIST
81091: LIST
81092: IN
81093: PUSH
81094: LD_INT 11
81096: PUSH
81097: LD_VAR 0 5
81101: IN
81102: PUSH
81103: LD_INT 30
81105: PUSH
81106: LD_VAR 0 5
81110: IN
81111: OR
81112: AND
81113: PUSH
81114: LD_INT 6
81116: PPUSH
81117: LD_VAR 0 16
81121: PPUSH
81122: CALL_OW 321
81126: PUSH
81127: LD_INT 2
81129: EQUAL
81130: AND
81131: IFFALSE 81296
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
81133: LD_INT 22
81135: PUSH
81136: LD_VAR 0 16
81140: PUSH
81141: EMPTY
81142: LIST
81143: LIST
81144: PUSH
81145: LD_INT 2
81147: PUSH
81148: LD_INT 35
81150: PUSH
81151: LD_INT 11
81153: PUSH
81154: EMPTY
81155: LIST
81156: LIST
81157: PUSH
81158: LD_INT 35
81160: PUSH
81161: LD_INT 30
81163: PUSH
81164: EMPTY
81165: LIST
81166: LIST
81167: PUSH
81168: EMPTY
81169: LIST
81170: LIST
81171: LIST
81172: PUSH
81173: LD_INT 91
81175: PUSH
81176: LD_VAR 0 1
81180: PUSH
81181: LD_INT 18
81183: PUSH
81184: EMPTY
81185: LIST
81186: LIST
81187: LIST
81188: PUSH
81189: EMPTY
81190: LIST
81191: LIST
81192: LIST
81193: PPUSH
81194: CALL_OW 69
81198: NOT
81199: PUSH
81200: LD_INT 22
81202: PUSH
81203: LD_VAR 0 16
81207: PUSH
81208: EMPTY
81209: LIST
81210: LIST
81211: PUSH
81212: LD_INT 2
81214: PUSH
81215: LD_INT 30
81217: PUSH
81218: LD_INT 32
81220: PUSH
81221: EMPTY
81222: LIST
81223: LIST
81224: PUSH
81225: LD_INT 30
81227: PUSH
81228: LD_INT 33
81230: PUSH
81231: EMPTY
81232: LIST
81233: LIST
81234: PUSH
81235: EMPTY
81236: LIST
81237: LIST
81238: LIST
81239: PUSH
81240: LD_INT 91
81242: PUSH
81243: LD_VAR 0 1
81247: PUSH
81248: LD_INT 12
81250: PUSH
81251: EMPTY
81252: LIST
81253: LIST
81254: LIST
81255: PUSH
81256: EMPTY
81257: LIST
81258: LIST
81259: LIST
81260: PUSH
81261: EMPTY
81262: LIST
81263: PPUSH
81264: CALL_OW 69
81268: PUSH
81269: LD_INT 2
81271: GREATER
81272: AND
81273: IFFALSE 81296
// weapon := [ us_radar , ar_radar ] [ nat ] ;
81275: LD_ADDR_VAR 0 18
81279: PUSH
81280: LD_INT 11
81282: PUSH
81283: LD_INT 30
81285: PUSH
81286: EMPTY
81287: LIST
81288: LIST
81289: PUSH
81290: LD_VAR 0 12
81294: ARRAY
81295: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
81296: LD_VAR 0 18
81300: NOT
81301: PUSH
81302: LD_INT 40
81304: PPUSH
81305: LD_VAR 0 16
81309: PPUSH
81310: CALL_OW 321
81314: PUSH
81315: LD_INT 2
81317: EQUAL
81318: AND
81319: PUSH
81320: LD_INT 7
81322: PUSH
81323: LD_VAR 0 5
81327: IN
81328: PUSH
81329: LD_INT 28
81331: PUSH
81332: LD_VAR 0 5
81336: IN
81337: OR
81338: PUSH
81339: LD_INT 45
81341: PUSH
81342: LD_VAR 0 5
81346: IN
81347: OR
81348: AND
81349: IFFALSE 81603
// begin hex := GetHexInfo ( x , y ) ;
81351: LD_ADDR_VAR 0 4
81355: PUSH
81356: LD_VAR 0 10
81360: PPUSH
81361: LD_VAR 0 11
81365: PPUSH
81366: CALL_OW 546
81370: ST_TO_ADDR
// if hex [ 1 ] then
81371: LD_VAR 0 4
81375: PUSH
81376: LD_INT 1
81378: ARRAY
81379: IFFALSE 81383
// exit ;
81381: GO 81786
// height := hex [ 2 ] ;
81383: LD_ADDR_VAR 0 15
81387: PUSH
81388: LD_VAR 0 4
81392: PUSH
81393: LD_INT 2
81395: ARRAY
81396: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
81397: LD_ADDR_VAR 0 14
81401: PUSH
81402: LD_INT 0
81404: PUSH
81405: LD_INT 2
81407: PUSH
81408: LD_INT 3
81410: PUSH
81411: LD_INT 5
81413: PUSH
81414: EMPTY
81415: LIST
81416: LIST
81417: LIST
81418: LIST
81419: ST_TO_ADDR
// for i in tmp do
81420: LD_ADDR_VAR 0 8
81424: PUSH
81425: LD_VAR 0 14
81429: PUSH
81430: FOR_IN
81431: IFFALSE 81601
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
81433: LD_ADDR_VAR 0 9
81437: PUSH
81438: LD_VAR 0 10
81442: PPUSH
81443: LD_VAR 0 8
81447: PPUSH
81448: LD_INT 5
81450: PPUSH
81451: CALL_OW 272
81455: PUSH
81456: LD_VAR 0 11
81460: PPUSH
81461: LD_VAR 0 8
81465: PPUSH
81466: LD_INT 5
81468: PPUSH
81469: CALL_OW 273
81473: PUSH
81474: EMPTY
81475: LIST
81476: LIST
81477: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
81478: LD_VAR 0 9
81482: PUSH
81483: LD_INT 1
81485: ARRAY
81486: PPUSH
81487: LD_VAR 0 9
81491: PUSH
81492: LD_INT 2
81494: ARRAY
81495: PPUSH
81496: CALL_OW 488
81500: IFFALSE 81599
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
81502: LD_ADDR_VAR 0 4
81506: PUSH
81507: LD_VAR 0 9
81511: PUSH
81512: LD_INT 1
81514: ARRAY
81515: PPUSH
81516: LD_VAR 0 9
81520: PUSH
81521: LD_INT 2
81523: ARRAY
81524: PPUSH
81525: CALL_OW 546
81529: ST_TO_ADDR
// if hex [ 1 ] then
81530: LD_VAR 0 4
81534: PUSH
81535: LD_INT 1
81537: ARRAY
81538: IFFALSE 81542
// continue ;
81540: GO 81430
// h := hex [ 2 ] ;
81542: LD_ADDR_VAR 0 13
81546: PUSH
81547: LD_VAR 0 4
81551: PUSH
81552: LD_INT 2
81554: ARRAY
81555: ST_TO_ADDR
// if h + 7 < height then
81556: LD_VAR 0 13
81560: PUSH
81561: LD_INT 7
81563: PLUS
81564: PUSH
81565: LD_VAR 0 15
81569: LESS
81570: IFFALSE 81599
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
81572: LD_ADDR_VAR 0 18
81576: PUSH
81577: LD_INT 7
81579: PUSH
81580: LD_INT 28
81582: PUSH
81583: LD_INT 45
81585: PUSH
81586: EMPTY
81587: LIST
81588: LIST
81589: LIST
81590: PUSH
81591: LD_VAR 0 12
81595: ARRAY
81596: ST_TO_ADDR
// break ;
81597: GO 81601
// end ; end ; end ;
81599: GO 81430
81601: POP
81602: POP
// end ; if not weapon then
81603: LD_VAR 0 18
81607: NOT
81608: IFFALSE 81668
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
81610: LD_ADDR_VAR 0 5
81614: PUSH
81615: LD_VAR 0 5
81619: PUSH
81620: LD_INT 11
81622: PUSH
81623: LD_INT 30
81625: PUSH
81626: LD_INT 49
81628: PUSH
81629: EMPTY
81630: LIST
81631: LIST
81632: LIST
81633: DIFF
81634: ST_TO_ADDR
// if not list then
81635: LD_VAR 0 5
81639: NOT
81640: IFFALSE 81644
// exit ;
81642: GO 81786
// weapon := list [ rand ( 1 , list ) ] ;
81644: LD_ADDR_VAR 0 18
81648: PUSH
81649: LD_VAR 0 5
81653: PUSH
81654: LD_INT 1
81656: PPUSH
81657: LD_VAR 0 5
81661: PPUSH
81662: CALL_OW 12
81666: ARRAY
81667: ST_TO_ADDR
// end ; if weapon then
81668: LD_VAR 0 18
81672: IFFALSE 81786
// begin tmp := CostOfWeapon ( weapon ) ;
81674: LD_ADDR_VAR 0 14
81678: PUSH
81679: LD_VAR 0 18
81683: PPUSH
81684: CALL_OW 451
81688: ST_TO_ADDR
// j := GetBase ( tower ) ;
81689: LD_ADDR_VAR 0 9
81693: PUSH
81694: LD_VAR 0 1
81698: PPUSH
81699: CALL_OW 274
81703: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
81704: LD_VAR 0 9
81708: PPUSH
81709: LD_INT 1
81711: PPUSH
81712: CALL_OW 275
81716: PUSH
81717: LD_VAR 0 14
81721: PUSH
81722: LD_INT 1
81724: ARRAY
81725: GREATEREQUAL
81726: PUSH
81727: LD_VAR 0 9
81731: PPUSH
81732: LD_INT 2
81734: PPUSH
81735: CALL_OW 275
81739: PUSH
81740: LD_VAR 0 14
81744: PUSH
81745: LD_INT 2
81747: ARRAY
81748: GREATEREQUAL
81749: AND
81750: PUSH
81751: LD_VAR 0 9
81755: PPUSH
81756: LD_INT 3
81758: PPUSH
81759: CALL_OW 275
81763: PUSH
81764: LD_VAR 0 14
81768: PUSH
81769: LD_INT 3
81771: ARRAY
81772: GREATEREQUAL
81773: AND
81774: IFFALSE 81786
// result := weapon ;
81776: LD_ADDR_VAR 0 3
81780: PUSH
81781: LD_VAR 0 18
81785: ST_TO_ADDR
// end ; end ;
81786: LD_VAR 0 3
81790: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
81791: LD_INT 0
81793: PPUSH
81794: PPUSH
// result := true ;
81795: LD_ADDR_VAR 0 3
81799: PUSH
81800: LD_INT 1
81802: ST_TO_ADDR
// if array1 = array2 then
81803: LD_VAR 0 1
81807: PUSH
81808: LD_VAR 0 2
81812: EQUAL
81813: IFFALSE 81873
// begin for i = 1 to array1 do
81815: LD_ADDR_VAR 0 4
81819: PUSH
81820: DOUBLE
81821: LD_INT 1
81823: DEC
81824: ST_TO_ADDR
81825: LD_VAR 0 1
81829: PUSH
81830: FOR_TO
81831: IFFALSE 81869
// if array1 [ i ] <> array2 [ i ] then
81833: LD_VAR 0 1
81837: PUSH
81838: LD_VAR 0 4
81842: ARRAY
81843: PUSH
81844: LD_VAR 0 2
81848: PUSH
81849: LD_VAR 0 4
81853: ARRAY
81854: NONEQUAL
81855: IFFALSE 81867
// begin result := false ;
81857: LD_ADDR_VAR 0 3
81861: PUSH
81862: LD_INT 0
81864: ST_TO_ADDR
// break ;
81865: GO 81869
// end ;
81867: GO 81830
81869: POP
81870: POP
// end else
81871: GO 81881
// result := false ;
81873: LD_ADDR_VAR 0 3
81877: PUSH
81878: LD_INT 0
81880: ST_TO_ADDR
// end ;
81881: LD_VAR 0 3
81885: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
81886: LD_INT 0
81888: PPUSH
81889: PPUSH
// if not array1 or not array2 then
81890: LD_VAR 0 1
81894: NOT
81895: PUSH
81896: LD_VAR 0 2
81900: NOT
81901: OR
81902: IFFALSE 81906
// exit ;
81904: GO 81970
// result := true ;
81906: LD_ADDR_VAR 0 3
81910: PUSH
81911: LD_INT 1
81913: ST_TO_ADDR
// for i = 1 to array1 do
81914: LD_ADDR_VAR 0 4
81918: PUSH
81919: DOUBLE
81920: LD_INT 1
81922: DEC
81923: ST_TO_ADDR
81924: LD_VAR 0 1
81928: PUSH
81929: FOR_TO
81930: IFFALSE 81968
// if array1 [ i ] <> array2 [ i ] then
81932: LD_VAR 0 1
81936: PUSH
81937: LD_VAR 0 4
81941: ARRAY
81942: PUSH
81943: LD_VAR 0 2
81947: PUSH
81948: LD_VAR 0 4
81952: ARRAY
81953: NONEQUAL
81954: IFFALSE 81966
// begin result := false ;
81956: LD_ADDR_VAR 0 3
81960: PUSH
81961: LD_INT 0
81963: ST_TO_ADDR
// break ;
81964: GO 81968
// end ;
81966: GO 81929
81968: POP
81969: POP
// end ;
81970: LD_VAR 0 3
81974: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
81975: LD_INT 0
81977: PPUSH
81978: PPUSH
81979: PPUSH
// pom := GetBase ( fac ) ;
81980: LD_ADDR_VAR 0 5
81984: PUSH
81985: LD_VAR 0 1
81989: PPUSH
81990: CALL_OW 274
81994: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
81995: LD_ADDR_VAR 0 4
81999: PUSH
82000: LD_VAR 0 2
82004: PUSH
82005: LD_INT 1
82007: ARRAY
82008: PPUSH
82009: LD_VAR 0 2
82013: PUSH
82014: LD_INT 2
82016: ARRAY
82017: PPUSH
82018: LD_VAR 0 2
82022: PUSH
82023: LD_INT 3
82025: ARRAY
82026: PPUSH
82027: LD_VAR 0 2
82031: PUSH
82032: LD_INT 4
82034: ARRAY
82035: PPUSH
82036: CALL_OW 449
82040: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
82041: LD_ADDR_VAR 0 3
82045: PUSH
82046: LD_VAR 0 5
82050: PPUSH
82051: LD_INT 1
82053: PPUSH
82054: CALL_OW 275
82058: PUSH
82059: LD_VAR 0 4
82063: PUSH
82064: LD_INT 1
82066: ARRAY
82067: GREATEREQUAL
82068: PUSH
82069: LD_VAR 0 5
82073: PPUSH
82074: LD_INT 2
82076: PPUSH
82077: CALL_OW 275
82081: PUSH
82082: LD_VAR 0 4
82086: PUSH
82087: LD_INT 2
82089: ARRAY
82090: GREATEREQUAL
82091: AND
82092: PUSH
82093: LD_VAR 0 5
82097: PPUSH
82098: LD_INT 3
82100: PPUSH
82101: CALL_OW 275
82105: PUSH
82106: LD_VAR 0 4
82110: PUSH
82111: LD_INT 3
82113: ARRAY
82114: GREATEREQUAL
82115: AND
82116: ST_TO_ADDR
// end ;
82117: LD_VAR 0 3
82121: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
82122: LD_INT 0
82124: PPUSH
82125: PPUSH
82126: PPUSH
82127: PPUSH
// pom := GetBase ( building ) ;
82128: LD_ADDR_VAR 0 3
82132: PUSH
82133: LD_VAR 0 1
82137: PPUSH
82138: CALL_OW 274
82142: ST_TO_ADDR
// if not pom then
82143: LD_VAR 0 3
82147: NOT
82148: IFFALSE 82152
// exit ;
82150: GO 82322
// btype := GetBType ( building ) ;
82152: LD_ADDR_VAR 0 5
82156: PUSH
82157: LD_VAR 0 1
82161: PPUSH
82162: CALL_OW 266
82166: ST_TO_ADDR
// if btype = b_armoury then
82167: LD_VAR 0 5
82171: PUSH
82172: LD_INT 4
82174: EQUAL
82175: IFFALSE 82185
// btype := b_barracks ;
82177: LD_ADDR_VAR 0 5
82181: PUSH
82182: LD_INT 5
82184: ST_TO_ADDR
// if btype = b_depot then
82185: LD_VAR 0 5
82189: PUSH
82190: LD_INT 0
82192: EQUAL
82193: IFFALSE 82203
// btype := b_warehouse ;
82195: LD_ADDR_VAR 0 5
82199: PUSH
82200: LD_INT 1
82202: ST_TO_ADDR
// if btype = b_workshop then
82203: LD_VAR 0 5
82207: PUSH
82208: LD_INT 2
82210: EQUAL
82211: IFFALSE 82221
// btype := b_factory ;
82213: LD_ADDR_VAR 0 5
82217: PUSH
82218: LD_INT 3
82220: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
82221: LD_ADDR_VAR 0 4
82225: PUSH
82226: LD_VAR 0 5
82230: PPUSH
82231: LD_VAR 0 1
82235: PPUSH
82236: CALL_OW 248
82240: PPUSH
82241: CALL_OW 450
82245: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
82246: LD_ADDR_VAR 0 2
82250: PUSH
82251: LD_VAR 0 3
82255: PPUSH
82256: LD_INT 1
82258: PPUSH
82259: CALL_OW 275
82263: PUSH
82264: LD_VAR 0 4
82268: PUSH
82269: LD_INT 1
82271: ARRAY
82272: GREATEREQUAL
82273: PUSH
82274: LD_VAR 0 3
82278: PPUSH
82279: LD_INT 2
82281: PPUSH
82282: CALL_OW 275
82286: PUSH
82287: LD_VAR 0 4
82291: PUSH
82292: LD_INT 2
82294: ARRAY
82295: GREATEREQUAL
82296: AND
82297: PUSH
82298: LD_VAR 0 3
82302: PPUSH
82303: LD_INT 3
82305: PPUSH
82306: CALL_OW 275
82310: PUSH
82311: LD_VAR 0 4
82315: PUSH
82316: LD_INT 3
82318: ARRAY
82319: GREATEREQUAL
82320: AND
82321: ST_TO_ADDR
// end ;
82322: LD_VAR 0 2
82326: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
82327: LD_INT 0
82329: PPUSH
82330: PPUSH
82331: PPUSH
// pom := GetBase ( building ) ;
82332: LD_ADDR_VAR 0 4
82336: PUSH
82337: LD_VAR 0 1
82341: PPUSH
82342: CALL_OW 274
82346: ST_TO_ADDR
// if not pom then
82347: LD_VAR 0 4
82351: NOT
82352: IFFALSE 82356
// exit ;
82354: GO 82457
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
82356: LD_ADDR_VAR 0 5
82360: PUSH
82361: LD_VAR 0 2
82365: PPUSH
82366: LD_VAR 0 1
82370: PPUSH
82371: CALL_OW 248
82375: PPUSH
82376: CALL_OW 450
82380: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
82381: LD_ADDR_VAR 0 3
82385: PUSH
82386: LD_VAR 0 4
82390: PPUSH
82391: LD_INT 1
82393: PPUSH
82394: CALL_OW 275
82398: PUSH
82399: LD_VAR 0 5
82403: PUSH
82404: LD_INT 1
82406: ARRAY
82407: GREATEREQUAL
82408: PUSH
82409: LD_VAR 0 4
82413: PPUSH
82414: LD_INT 2
82416: PPUSH
82417: CALL_OW 275
82421: PUSH
82422: LD_VAR 0 5
82426: PUSH
82427: LD_INT 2
82429: ARRAY
82430: GREATEREQUAL
82431: AND
82432: PUSH
82433: LD_VAR 0 4
82437: PPUSH
82438: LD_INT 3
82440: PPUSH
82441: CALL_OW 275
82445: PUSH
82446: LD_VAR 0 5
82450: PUSH
82451: LD_INT 3
82453: ARRAY
82454: GREATEREQUAL
82455: AND
82456: ST_TO_ADDR
// end ;
82457: LD_VAR 0 3
82461: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
82462: LD_INT 0
82464: PPUSH
82465: PPUSH
82466: PPUSH
82467: PPUSH
82468: PPUSH
82469: PPUSH
82470: PPUSH
82471: PPUSH
82472: PPUSH
82473: PPUSH
82474: PPUSH
// result := false ;
82475: LD_ADDR_VAR 0 8
82479: PUSH
82480: LD_INT 0
82482: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
82483: LD_VAR 0 5
82487: NOT
82488: PUSH
82489: LD_VAR 0 1
82493: NOT
82494: OR
82495: PUSH
82496: LD_VAR 0 2
82500: NOT
82501: OR
82502: PUSH
82503: LD_VAR 0 3
82507: NOT
82508: OR
82509: IFFALSE 82513
// exit ;
82511: GO 83327
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
82513: LD_ADDR_VAR 0 14
82517: PUSH
82518: LD_VAR 0 1
82522: PPUSH
82523: LD_VAR 0 2
82527: PPUSH
82528: LD_VAR 0 3
82532: PPUSH
82533: LD_VAR 0 4
82537: PPUSH
82538: LD_VAR 0 5
82542: PUSH
82543: LD_INT 1
82545: ARRAY
82546: PPUSH
82547: CALL_OW 248
82551: PPUSH
82552: LD_INT 0
82554: PPUSH
82555: CALL 84580 0 6
82559: ST_TO_ADDR
// if not hexes then
82560: LD_VAR 0 14
82564: NOT
82565: IFFALSE 82569
// exit ;
82567: GO 83327
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
82569: LD_ADDR_VAR 0 17
82573: PUSH
82574: LD_VAR 0 5
82578: PPUSH
82579: LD_INT 22
82581: PUSH
82582: LD_VAR 0 13
82586: PPUSH
82587: CALL_OW 255
82591: PUSH
82592: EMPTY
82593: LIST
82594: LIST
82595: PUSH
82596: LD_INT 2
82598: PUSH
82599: LD_INT 30
82601: PUSH
82602: LD_INT 0
82604: PUSH
82605: EMPTY
82606: LIST
82607: LIST
82608: PUSH
82609: LD_INT 30
82611: PUSH
82612: LD_INT 1
82614: PUSH
82615: EMPTY
82616: LIST
82617: LIST
82618: PUSH
82619: EMPTY
82620: LIST
82621: LIST
82622: LIST
82623: PUSH
82624: EMPTY
82625: LIST
82626: LIST
82627: PPUSH
82628: CALL_OW 72
82632: ST_TO_ADDR
// for i = 1 to hexes do
82633: LD_ADDR_VAR 0 9
82637: PUSH
82638: DOUBLE
82639: LD_INT 1
82641: DEC
82642: ST_TO_ADDR
82643: LD_VAR 0 14
82647: PUSH
82648: FOR_TO
82649: IFFALSE 83325
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
82651: LD_ADDR_VAR 0 13
82655: PUSH
82656: LD_VAR 0 14
82660: PUSH
82661: LD_VAR 0 9
82665: ARRAY
82666: PUSH
82667: LD_INT 1
82669: ARRAY
82670: PPUSH
82671: LD_VAR 0 14
82675: PUSH
82676: LD_VAR 0 9
82680: ARRAY
82681: PUSH
82682: LD_INT 2
82684: ARRAY
82685: PPUSH
82686: CALL_OW 428
82690: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
82691: LD_VAR 0 14
82695: PUSH
82696: LD_VAR 0 9
82700: ARRAY
82701: PUSH
82702: LD_INT 1
82704: ARRAY
82705: PPUSH
82706: LD_VAR 0 14
82710: PUSH
82711: LD_VAR 0 9
82715: ARRAY
82716: PUSH
82717: LD_INT 2
82719: ARRAY
82720: PPUSH
82721: CALL_OW 351
82725: PUSH
82726: LD_VAR 0 14
82730: PUSH
82731: LD_VAR 0 9
82735: ARRAY
82736: PUSH
82737: LD_INT 1
82739: ARRAY
82740: PPUSH
82741: LD_VAR 0 14
82745: PUSH
82746: LD_VAR 0 9
82750: ARRAY
82751: PUSH
82752: LD_INT 2
82754: ARRAY
82755: PPUSH
82756: CALL_OW 488
82760: NOT
82761: OR
82762: PUSH
82763: LD_VAR 0 13
82767: PPUSH
82768: CALL_OW 247
82772: PUSH
82773: LD_INT 3
82775: EQUAL
82776: OR
82777: IFFALSE 82783
// exit ;
82779: POP
82780: POP
82781: GO 83327
// if not tmp then
82783: LD_VAR 0 13
82787: NOT
82788: IFFALSE 82792
// continue ;
82790: GO 82648
// result := true ;
82792: LD_ADDR_VAR 0 8
82796: PUSH
82797: LD_INT 1
82799: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
82800: LD_VAR 0 6
82804: PUSH
82805: LD_VAR 0 13
82809: PPUSH
82810: CALL_OW 247
82814: PUSH
82815: LD_INT 2
82817: EQUAL
82818: AND
82819: PUSH
82820: LD_VAR 0 13
82824: PPUSH
82825: CALL_OW 263
82829: PUSH
82830: LD_INT 1
82832: EQUAL
82833: AND
82834: IFFALSE 82998
// begin if IsDrivenBy ( tmp ) then
82836: LD_VAR 0 13
82840: PPUSH
82841: CALL_OW 311
82845: IFFALSE 82849
// continue ;
82847: GO 82648
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
82849: LD_VAR 0 6
82853: PPUSH
82854: LD_INT 3
82856: PUSH
82857: LD_INT 60
82859: PUSH
82860: EMPTY
82861: LIST
82862: PUSH
82863: EMPTY
82864: LIST
82865: LIST
82866: PUSH
82867: LD_INT 3
82869: PUSH
82870: LD_INT 55
82872: PUSH
82873: EMPTY
82874: LIST
82875: PUSH
82876: EMPTY
82877: LIST
82878: LIST
82879: PUSH
82880: EMPTY
82881: LIST
82882: LIST
82883: PPUSH
82884: CALL_OW 72
82888: IFFALSE 82996
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
82890: LD_ADDR_VAR 0 18
82894: PUSH
82895: LD_VAR 0 6
82899: PPUSH
82900: LD_INT 3
82902: PUSH
82903: LD_INT 60
82905: PUSH
82906: EMPTY
82907: LIST
82908: PUSH
82909: EMPTY
82910: LIST
82911: LIST
82912: PUSH
82913: LD_INT 3
82915: PUSH
82916: LD_INT 55
82918: PUSH
82919: EMPTY
82920: LIST
82921: PUSH
82922: EMPTY
82923: LIST
82924: LIST
82925: PUSH
82926: EMPTY
82927: LIST
82928: LIST
82929: PPUSH
82930: CALL_OW 72
82934: PUSH
82935: LD_INT 1
82937: ARRAY
82938: ST_TO_ADDR
// if IsInUnit ( driver ) then
82939: LD_VAR 0 18
82943: PPUSH
82944: CALL_OW 310
82948: IFFALSE 82959
// ComExit ( driver ) ;
82950: LD_VAR 0 18
82954: PPUSH
82955: CALL 108361 0 1
// AddComEnterUnit ( driver , tmp ) ;
82959: LD_VAR 0 18
82963: PPUSH
82964: LD_VAR 0 13
82968: PPUSH
82969: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
82973: LD_VAR 0 18
82977: PPUSH
82978: LD_VAR 0 7
82982: PPUSH
82983: CALL_OW 173
// AddComExitVehicle ( driver ) ;
82987: LD_VAR 0 18
82991: PPUSH
82992: CALL_OW 181
// end ; continue ;
82996: GO 82648
// end ; if not cleaners or not tmp in cleaners then
82998: LD_VAR 0 6
83002: NOT
83003: PUSH
83004: LD_VAR 0 13
83008: PUSH
83009: LD_VAR 0 6
83013: IN
83014: NOT
83015: OR
83016: IFFALSE 83323
// begin if dep then
83018: LD_VAR 0 17
83022: IFFALSE 83158
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
83024: LD_ADDR_VAR 0 16
83028: PUSH
83029: LD_VAR 0 17
83033: PUSH
83034: LD_INT 1
83036: ARRAY
83037: PPUSH
83038: CALL_OW 250
83042: PPUSH
83043: LD_VAR 0 17
83047: PUSH
83048: LD_INT 1
83050: ARRAY
83051: PPUSH
83052: CALL_OW 254
83056: PPUSH
83057: LD_INT 5
83059: PPUSH
83060: CALL_OW 272
83064: PUSH
83065: LD_VAR 0 17
83069: PUSH
83070: LD_INT 1
83072: ARRAY
83073: PPUSH
83074: CALL_OW 251
83078: PPUSH
83079: LD_VAR 0 17
83083: PUSH
83084: LD_INT 1
83086: ARRAY
83087: PPUSH
83088: CALL_OW 254
83092: PPUSH
83093: LD_INT 5
83095: PPUSH
83096: CALL_OW 273
83100: PUSH
83101: EMPTY
83102: LIST
83103: LIST
83104: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
83105: LD_VAR 0 16
83109: PUSH
83110: LD_INT 1
83112: ARRAY
83113: PPUSH
83114: LD_VAR 0 16
83118: PUSH
83119: LD_INT 2
83121: ARRAY
83122: PPUSH
83123: CALL_OW 488
83127: IFFALSE 83158
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
83129: LD_VAR 0 13
83133: PPUSH
83134: LD_VAR 0 16
83138: PUSH
83139: LD_INT 1
83141: ARRAY
83142: PPUSH
83143: LD_VAR 0 16
83147: PUSH
83148: LD_INT 2
83150: ARRAY
83151: PPUSH
83152: CALL_OW 111
// continue ;
83156: GO 82648
// end ; end ; r := GetDir ( tmp ) ;
83158: LD_ADDR_VAR 0 15
83162: PUSH
83163: LD_VAR 0 13
83167: PPUSH
83168: CALL_OW 254
83172: ST_TO_ADDR
// if r = 5 then
83173: LD_VAR 0 15
83177: PUSH
83178: LD_INT 5
83180: EQUAL
83181: IFFALSE 83191
// r := 0 ;
83183: LD_ADDR_VAR 0 15
83187: PUSH
83188: LD_INT 0
83190: ST_TO_ADDR
// for j = r to 5 do
83191: LD_ADDR_VAR 0 10
83195: PUSH
83196: DOUBLE
83197: LD_VAR 0 15
83201: DEC
83202: ST_TO_ADDR
83203: LD_INT 5
83205: PUSH
83206: FOR_TO
83207: IFFALSE 83321
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
83209: LD_ADDR_VAR 0 11
83213: PUSH
83214: LD_VAR 0 13
83218: PPUSH
83219: CALL_OW 250
83223: PPUSH
83224: LD_VAR 0 10
83228: PPUSH
83229: LD_INT 2
83231: PPUSH
83232: CALL_OW 272
83236: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
83237: LD_ADDR_VAR 0 12
83241: PUSH
83242: LD_VAR 0 13
83246: PPUSH
83247: CALL_OW 251
83251: PPUSH
83252: LD_VAR 0 10
83256: PPUSH
83257: LD_INT 2
83259: PPUSH
83260: CALL_OW 273
83264: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
83265: LD_VAR 0 11
83269: PPUSH
83270: LD_VAR 0 12
83274: PPUSH
83275: CALL_OW 488
83279: PUSH
83280: LD_VAR 0 11
83284: PPUSH
83285: LD_VAR 0 12
83289: PPUSH
83290: CALL_OW 428
83294: NOT
83295: AND
83296: IFFALSE 83319
// begin ComMoveXY ( tmp , _x , _y ) ;
83298: LD_VAR 0 13
83302: PPUSH
83303: LD_VAR 0 11
83307: PPUSH
83308: LD_VAR 0 12
83312: PPUSH
83313: CALL_OW 111
// break ;
83317: GO 83321
// end ; end ;
83319: GO 83206
83321: POP
83322: POP
// end ; end ;
83323: GO 82648
83325: POP
83326: POP
// end ;
83327: LD_VAR 0 8
83331: RET
// export function BuildingTechInvented ( side , btype ) ; begin
83332: LD_INT 0
83334: PPUSH
// result := true ;
83335: LD_ADDR_VAR 0 3
83339: PUSH
83340: LD_INT 1
83342: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
83343: LD_VAR 0 2
83347: PUSH
83348: LD_INT 24
83350: DOUBLE
83351: EQUAL
83352: IFTRUE 83362
83354: LD_INT 33
83356: DOUBLE
83357: EQUAL
83358: IFTRUE 83362
83360: GO 83387
83362: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
83363: LD_ADDR_VAR 0 3
83367: PUSH
83368: LD_INT 32
83370: PPUSH
83371: LD_VAR 0 1
83375: PPUSH
83376: CALL_OW 321
83380: PUSH
83381: LD_INT 2
83383: EQUAL
83384: ST_TO_ADDR
83385: GO 83703
83387: LD_INT 20
83389: DOUBLE
83390: EQUAL
83391: IFTRUE 83395
83393: GO 83420
83395: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
83396: LD_ADDR_VAR 0 3
83400: PUSH
83401: LD_INT 6
83403: PPUSH
83404: LD_VAR 0 1
83408: PPUSH
83409: CALL_OW 321
83413: PUSH
83414: LD_INT 2
83416: EQUAL
83417: ST_TO_ADDR
83418: GO 83703
83420: LD_INT 22
83422: DOUBLE
83423: EQUAL
83424: IFTRUE 83434
83426: LD_INT 36
83428: DOUBLE
83429: EQUAL
83430: IFTRUE 83434
83432: GO 83459
83434: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
83435: LD_ADDR_VAR 0 3
83439: PUSH
83440: LD_INT 15
83442: PPUSH
83443: LD_VAR 0 1
83447: PPUSH
83448: CALL_OW 321
83452: PUSH
83453: LD_INT 2
83455: EQUAL
83456: ST_TO_ADDR
83457: GO 83703
83459: LD_INT 30
83461: DOUBLE
83462: EQUAL
83463: IFTRUE 83467
83465: GO 83492
83467: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
83468: LD_ADDR_VAR 0 3
83472: PUSH
83473: LD_INT 20
83475: PPUSH
83476: LD_VAR 0 1
83480: PPUSH
83481: CALL_OW 321
83485: PUSH
83486: LD_INT 2
83488: EQUAL
83489: ST_TO_ADDR
83490: GO 83703
83492: LD_INT 28
83494: DOUBLE
83495: EQUAL
83496: IFTRUE 83506
83498: LD_INT 21
83500: DOUBLE
83501: EQUAL
83502: IFTRUE 83506
83504: GO 83531
83506: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
83507: LD_ADDR_VAR 0 3
83511: PUSH
83512: LD_INT 21
83514: PPUSH
83515: LD_VAR 0 1
83519: PPUSH
83520: CALL_OW 321
83524: PUSH
83525: LD_INT 2
83527: EQUAL
83528: ST_TO_ADDR
83529: GO 83703
83531: LD_INT 16
83533: DOUBLE
83534: EQUAL
83535: IFTRUE 83539
83537: GO 83564
83539: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
83540: LD_ADDR_VAR 0 3
83544: PUSH
83545: LD_INT 84
83547: PPUSH
83548: LD_VAR 0 1
83552: PPUSH
83553: CALL_OW 321
83557: PUSH
83558: LD_INT 2
83560: EQUAL
83561: ST_TO_ADDR
83562: GO 83703
83564: LD_INT 19
83566: DOUBLE
83567: EQUAL
83568: IFTRUE 83578
83570: LD_INT 23
83572: DOUBLE
83573: EQUAL
83574: IFTRUE 83578
83576: GO 83603
83578: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
83579: LD_ADDR_VAR 0 3
83583: PUSH
83584: LD_INT 83
83586: PPUSH
83587: LD_VAR 0 1
83591: PPUSH
83592: CALL_OW 321
83596: PUSH
83597: LD_INT 2
83599: EQUAL
83600: ST_TO_ADDR
83601: GO 83703
83603: LD_INT 17
83605: DOUBLE
83606: EQUAL
83607: IFTRUE 83611
83609: GO 83636
83611: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
83612: LD_ADDR_VAR 0 3
83616: PUSH
83617: LD_INT 39
83619: PPUSH
83620: LD_VAR 0 1
83624: PPUSH
83625: CALL_OW 321
83629: PUSH
83630: LD_INT 2
83632: EQUAL
83633: ST_TO_ADDR
83634: GO 83703
83636: LD_INT 18
83638: DOUBLE
83639: EQUAL
83640: IFTRUE 83644
83642: GO 83669
83644: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
83645: LD_ADDR_VAR 0 3
83649: PUSH
83650: LD_INT 40
83652: PPUSH
83653: LD_VAR 0 1
83657: PPUSH
83658: CALL_OW 321
83662: PUSH
83663: LD_INT 2
83665: EQUAL
83666: ST_TO_ADDR
83667: GO 83703
83669: LD_INT 27
83671: DOUBLE
83672: EQUAL
83673: IFTRUE 83677
83675: GO 83702
83677: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
83678: LD_ADDR_VAR 0 3
83682: PUSH
83683: LD_INT 35
83685: PPUSH
83686: LD_VAR 0 1
83690: PPUSH
83691: CALL_OW 321
83695: PUSH
83696: LD_INT 2
83698: EQUAL
83699: ST_TO_ADDR
83700: GO 83703
83702: POP
// end ;
83703: LD_VAR 0 3
83707: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
83708: LD_INT 0
83710: PPUSH
83711: PPUSH
83712: PPUSH
83713: PPUSH
83714: PPUSH
83715: PPUSH
83716: PPUSH
83717: PPUSH
83718: PPUSH
83719: PPUSH
83720: PPUSH
// result := false ;
83721: LD_ADDR_VAR 0 6
83725: PUSH
83726: LD_INT 0
83728: ST_TO_ADDR
// if btype = b_depot then
83729: LD_VAR 0 2
83733: PUSH
83734: LD_INT 0
83736: EQUAL
83737: IFFALSE 83749
// begin result := true ;
83739: LD_ADDR_VAR 0 6
83743: PUSH
83744: LD_INT 1
83746: ST_TO_ADDR
// exit ;
83747: GO 84575
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
83749: LD_VAR 0 1
83753: NOT
83754: PUSH
83755: LD_VAR 0 1
83759: PPUSH
83760: CALL_OW 266
83764: PUSH
83765: LD_INT 0
83767: PUSH
83768: LD_INT 1
83770: PUSH
83771: EMPTY
83772: LIST
83773: LIST
83774: IN
83775: NOT
83776: OR
83777: PUSH
83778: LD_VAR 0 2
83782: NOT
83783: OR
83784: PUSH
83785: LD_VAR 0 5
83789: PUSH
83790: LD_INT 0
83792: PUSH
83793: LD_INT 1
83795: PUSH
83796: LD_INT 2
83798: PUSH
83799: LD_INT 3
83801: PUSH
83802: LD_INT 4
83804: PUSH
83805: LD_INT 5
83807: PUSH
83808: EMPTY
83809: LIST
83810: LIST
83811: LIST
83812: LIST
83813: LIST
83814: LIST
83815: IN
83816: NOT
83817: OR
83818: PUSH
83819: LD_VAR 0 3
83823: PPUSH
83824: LD_VAR 0 4
83828: PPUSH
83829: CALL_OW 488
83833: NOT
83834: OR
83835: IFFALSE 83839
// exit ;
83837: GO 84575
// side := GetSide ( depot ) ;
83839: LD_ADDR_VAR 0 9
83843: PUSH
83844: LD_VAR 0 1
83848: PPUSH
83849: CALL_OW 255
83853: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
83854: LD_VAR 0 9
83858: PPUSH
83859: LD_VAR 0 2
83863: PPUSH
83864: CALL 83332 0 2
83868: NOT
83869: IFFALSE 83873
// exit ;
83871: GO 84575
// pom := GetBase ( depot ) ;
83873: LD_ADDR_VAR 0 10
83877: PUSH
83878: LD_VAR 0 1
83882: PPUSH
83883: CALL_OW 274
83887: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
83888: LD_ADDR_VAR 0 11
83892: PUSH
83893: LD_VAR 0 2
83897: PPUSH
83898: LD_VAR 0 1
83902: PPUSH
83903: CALL_OW 248
83907: PPUSH
83908: CALL_OW 450
83912: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
83913: LD_VAR 0 10
83917: PPUSH
83918: LD_INT 1
83920: PPUSH
83921: CALL_OW 275
83925: PUSH
83926: LD_VAR 0 11
83930: PUSH
83931: LD_INT 1
83933: ARRAY
83934: GREATEREQUAL
83935: PUSH
83936: LD_VAR 0 10
83940: PPUSH
83941: LD_INT 2
83943: PPUSH
83944: CALL_OW 275
83948: PUSH
83949: LD_VAR 0 11
83953: PUSH
83954: LD_INT 2
83956: ARRAY
83957: GREATEREQUAL
83958: AND
83959: PUSH
83960: LD_VAR 0 10
83964: PPUSH
83965: LD_INT 3
83967: PPUSH
83968: CALL_OW 275
83972: PUSH
83973: LD_VAR 0 11
83977: PUSH
83978: LD_INT 3
83980: ARRAY
83981: GREATEREQUAL
83982: AND
83983: NOT
83984: IFFALSE 83988
// exit ;
83986: GO 84575
// if GetBType ( depot ) = b_depot then
83988: LD_VAR 0 1
83992: PPUSH
83993: CALL_OW 266
83997: PUSH
83998: LD_INT 0
84000: EQUAL
84001: IFFALSE 84013
// dist := 28 else
84003: LD_ADDR_VAR 0 14
84007: PUSH
84008: LD_INT 28
84010: ST_TO_ADDR
84011: GO 84021
// dist := 36 ;
84013: LD_ADDR_VAR 0 14
84017: PUSH
84018: LD_INT 36
84020: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
84021: LD_VAR 0 1
84025: PPUSH
84026: LD_VAR 0 3
84030: PPUSH
84031: LD_VAR 0 4
84035: PPUSH
84036: CALL_OW 297
84040: PUSH
84041: LD_VAR 0 14
84045: GREATER
84046: IFFALSE 84050
// exit ;
84048: GO 84575
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
84050: LD_ADDR_VAR 0 12
84054: PUSH
84055: LD_VAR 0 2
84059: PPUSH
84060: LD_VAR 0 3
84064: PPUSH
84065: LD_VAR 0 4
84069: PPUSH
84070: LD_VAR 0 5
84074: PPUSH
84075: LD_VAR 0 1
84079: PPUSH
84080: CALL_OW 248
84084: PPUSH
84085: LD_INT 0
84087: PPUSH
84088: CALL 84580 0 6
84092: ST_TO_ADDR
// if not hexes then
84093: LD_VAR 0 12
84097: NOT
84098: IFFALSE 84102
// exit ;
84100: GO 84575
// hex := GetHexInfo ( x , y ) ;
84102: LD_ADDR_VAR 0 15
84106: PUSH
84107: LD_VAR 0 3
84111: PPUSH
84112: LD_VAR 0 4
84116: PPUSH
84117: CALL_OW 546
84121: ST_TO_ADDR
// if hex [ 1 ] then
84122: LD_VAR 0 15
84126: PUSH
84127: LD_INT 1
84129: ARRAY
84130: IFFALSE 84134
// exit ;
84132: GO 84575
// height := hex [ 2 ] ;
84134: LD_ADDR_VAR 0 13
84138: PUSH
84139: LD_VAR 0 15
84143: PUSH
84144: LD_INT 2
84146: ARRAY
84147: ST_TO_ADDR
// for i = 1 to hexes do
84148: LD_ADDR_VAR 0 7
84152: PUSH
84153: DOUBLE
84154: LD_INT 1
84156: DEC
84157: ST_TO_ADDR
84158: LD_VAR 0 12
84162: PUSH
84163: FOR_TO
84164: IFFALSE 84494
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
84166: LD_VAR 0 12
84170: PUSH
84171: LD_VAR 0 7
84175: ARRAY
84176: PUSH
84177: LD_INT 1
84179: ARRAY
84180: PPUSH
84181: LD_VAR 0 12
84185: PUSH
84186: LD_VAR 0 7
84190: ARRAY
84191: PUSH
84192: LD_INT 2
84194: ARRAY
84195: PPUSH
84196: CALL_OW 488
84200: NOT
84201: PUSH
84202: LD_VAR 0 12
84206: PUSH
84207: LD_VAR 0 7
84211: ARRAY
84212: PUSH
84213: LD_INT 1
84215: ARRAY
84216: PPUSH
84217: LD_VAR 0 12
84221: PUSH
84222: LD_VAR 0 7
84226: ARRAY
84227: PUSH
84228: LD_INT 2
84230: ARRAY
84231: PPUSH
84232: CALL_OW 428
84236: PUSH
84237: LD_INT 0
84239: GREATER
84240: OR
84241: PUSH
84242: LD_VAR 0 12
84246: PUSH
84247: LD_VAR 0 7
84251: ARRAY
84252: PUSH
84253: LD_INT 1
84255: ARRAY
84256: PPUSH
84257: LD_VAR 0 12
84261: PUSH
84262: LD_VAR 0 7
84266: ARRAY
84267: PUSH
84268: LD_INT 2
84270: ARRAY
84271: PPUSH
84272: CALL_OW 351
84276: OR
84277: IFFALSE 84283
// exit ;
84279: POP
84280: POP
84281: GO 84575
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84283: LD_ADDR_VAR 0 8
84287: PUSH
84288: LD_VAR 0 12
84292: PUSH
84293: LD_VAR 0 7
84297: ARRAY
84298: PUSH
84299: LD_INT 1
84301: ARRAY
84302: PPUSH
84303: LD_VAR 0 12
84307: PUSH
84308: LD_VAR 0 7
84312: ARRAY
84313: PUSH
84314: LD_INT 2
84316: ARRAY
84317: PPUSH
84318: CALL_OW 546
84322: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
84323: LD_VAR 0 8
84327: PUSH
84328: LD_INT 1
84330: ARRAY
84331: PUSH
84332: LD_VAR 0 8
84336: PUSH
84337: LD_INT 2
84339: ARRAY
84340: PUSH
84341: LD_VAR 0 13
84345: PUSH
84346: LD_INT 2
84348: PLUS
84349: GREATER
84350: OR
84351: PUSH
84352: LD_VAR 0 8
84356: PUSH
84357: LD_INT 2
84359: ARRAY
84360: PUSH
84361: LD_VAR 0 13
84365: PUSH
84366: LD_INT 2
84368: MINUS
84369: LESS
84370: OR
84371: PUSH
84372: LD_VAR 0 8
84376: PUSH
84377: LD_INT 3
84379: ARRAY
84380: PUSH
84381: LD_INT 0
84383: PUSH
84384: LD_INT 8
84386: PUSH
84387: LD_INT 9
84389: PUSH
84390: LD_INT 10
84392: PUSH
84393: LD_INT 11
84395: PUSH
84396: LD_INT 12
84398: PUSH
84399: LD_INT 13
84401: PUSH
84402: LD_INT 16
84404: PUSH
84405: LD_INT 17
84407: PUSH
84408: LD_INT 18
84410: PUSH
84411: LD_INT 19
84413: PUSH
84414: LD_INT 20
84416: PUSH
84417: LD_INT 21
84419: PUSH
84420: EMPTY
84421: LIST
84422: LIST
84423: LIST
84424: LIST
84425: LIST
84426: LIST
84427: LIST
84428: LIST
84429: LIST
84430: LIST
84431: LIST
84432: LIST
84433: LIST
84434: IN
84435: NOT
84436: OR
84437: PUSH
84438: LD_VAR 0 8
84442: PUSH
84443: LD_INT 5
84445: ARRAY
84446: NOT
84447: OR
84448: PUSH
84449: LD_VAR 0 8
84453: PUSH
84454: LD_INT 6
84456: ARRAY
84457: PUSH
84458: LD_INT 1
84460: PUSH
84461: LD_INT 2
84463: PUSH
84464: LD_INT 7
84466: PUSH
84467: LD_INT 9
84469: PUSH
84470: LD_INT 10
84472: PUSH
84473: LD_INT 11
84475: PUSH
84476: EMPTY
84477: LIST
84478: LIST
84479: LIST
84480: LIST
84481: LIST
84482: LIST
84483: IN
84484: NOT
84485: OR
84486: IFFALSE 84492
// exit ;
84488: POP
84489: POP
84490: GO 84575
// end ;
84492: GO 84163
84494: POP
84495: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
84496: LD_VAR 0 9
84500: PPUSH
84501: LD_VAR 0 3
84505: PPUSH
84506: LD_VAR 0 4
84510: PPUSH
84511: LD_INT 20
84513: PPUSH
84514: CALL 76498 0 4
84518: PUSH
84519: LD_INT 4
84521: ARRAY
84522: IFFALSE 84526
// exit ;
84524: GO 84575
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
84526: LD_VAR 0 2
84530: PUSH
84531: LD_INT 29
84533: PUSH
84534: LD_INT 30
84536: PUSH
84537: EMPTY
84538: LIST
84539: LIST
84540: IN
84541: PUSH
84542: LD_VAR 0 3
84546: PPUSH
84547: LD_VAR 0 4
84551: PPUSH
84552: LD_VAR 0 9
84556: PPUSH
84557: CALL_OW 440
84561: NOT
84562: AND
84563: IFFALSE 84567
// exit ;
84565: GO 84575
// result := true ;
84567: LD_ADDR_VAR 0 6
84571: PUSH
84572: LD_INT 1
84574: ST_TO_ADDR
// end ;
84575: LD_VAR 0 6
84579: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
84580: LD_INT 0
84582: PPUSH
84583: PPUSH
84584: PPUSH
84585: PPUSH
84586: PPUSH
84587: PPUSH
84588: PPUSH
84589: PPUSH
84590: PPUSH
84591: PPUSH
84592: PPUSH
84593: PPUSH
84594: PPUSH
84595: PPUSH
84596: PPUSH
84597: PPUSH
84598: PPUSH
84599: PPUSH
84600: PPUSH
84601: PPUSH
84602: PPUSH
84603: PPUSH
84604: PPUSH
84605: PPUSH
84606: PPUSH
84607: PPUSH
84608: PPUSH
84609: PPUSH
84610: PPUSH
84611: PPUSH
84612: PPUSH
84613: PPUSH
84614: PPUSH
84615: PPUSH
84616: PPUSH
84617: PPUSH
84618: PPUSH
84619: PPUSH
84620: PPUSH
84621: PPUSH
84622: PPUSH
84623: PPUSH
84624: PPUSH
84625: PPUSH
84626: PPUSH
84627: PPUSH
84628: PPUSH
84629: PPUSH
84630: PPUSH
84631: PPUSH
84632: PPUSH
84633: PPUSH
84634: PPUSH
84635: PPUSH
84636: PPUSH
84637: PPUSH
84638: PPUSH
84639: PPUSH
// result = [ ] ;
84640: LD_ADDR_VAR 0 7
84644: PUSH
84645: EMPTY
84646: ST_TO_ADDR
// temp_list = [ ] ;
84647: LD_ADDR_VAR 0 9
84651: PUSH
84652: EMPTY
84653: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
84654: LD_VAR 0 4
84658: PUSH
84659: LD_INT 0
84661: PUSH
84662: LD_INT 1
84664: PUSH
84665: LD_INT 2
84667: PUSH
84668: LD_INT 3
84670: PUSH
84671: LD_INT 4
84673: PUSH
84674: LD_INT 5
84676: PUSH
84677: EMPTY
84678: LIST
84679: LIST
84680: LIST
84681: LIST
84682: LIST
84683: LIST
84684: IN
84685: NOT
84686: PUSH
84687: LD_VAR 0 1
84691: PUSH
84692: LD_INT 0
84694: PUSH
84695: LD_INT 1
84697: PUSH
84698: EMPTY
84699: LIST
84700: LIST
84701: IN
84702: PUSH
84703: LD_VAR 0 5
84707: PUSH
84708: LD_INT 1
84710: PUSH
84711: LD_INT 2
84713: PUSH
84714: LD_INT 3
84716: PUSH
84717: EMPTY
84718: LIST
84719: LIST
84720: LIST
84721: IN
84722: NOT
84723: AND
84724: OR
84725: IFFALSE 84729
// exit ;
84727: GO 103120
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
84729: LD_VAR 0 1
84733: PUSH
84734: LD_INT 6
84736: PUSH
84737: LD_INT 7
84739: PUSH
84740: LD_INT 8
84742: PUSH
84743: LD_INT 13
84745: PUSH
84746: LD_INT 12
84748: PUSH
84749: LD_INT 15
84751: PUSH
84752: LD_INT 11
84754: PUSH
84755: LD_INT 14
84757: PUSH
84758: LD_INT 10
84760: PUSH
84761: EMPTY
84762: LIST
84763: LIST
84764: LIST
84765: LIST
84766: LIST
84767: LIST
84768: LIST
84769: LIST
84770: LIST
84771: IN
84772: IFFALSE 84782
// btype = b_lab ;
84774: LD_ADDR_VAR 0 1
84778: PUSH
84779: LD_INT 6
84781: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
84782: LD_VAR 0 6
84786: PUSH
84787: LD_INT 0
84789: PUSH
84790: LD_INT 1
84792: PUSH
84793: LD_INT 2
84795: PUSH
84796: EMPTY
84797: LIST
84798: LIST
84799: LIST
84800: IN
84801: NOT
84802: PUSH
84803: LD_VAR 0 1
84807: PUSH
84808: LD_INT 0
84810: PUSH
84811: LD_INT 1
84813: PUSH
84814: LD_INT 2
84816: PUSH
84817: LD_INT 3
84819: PUSH
84820: LD_INT 6
84822: PUSH
84823: LD_INT 36
84825: PUSH
84826: LD_INT 4
84828: PUSH
84829: LD_INT 5
84831: PUSH
84832: LD_INT 31
84834: PUSH
84835: LD_INT 32
84837: PUSH
84838: LD_INT 33
84840: PUSH
84841: EMPTY
84842: LIST
84843: LIST
84844: LIST
84845: LIST
84846: LIST
84847: LIST
84848: LIST
84849: LIST
84850: LIST
84851: LIST
84852: LIST
84853: IN
84854: NOT
84855: PUSH
84856: LD_VAR 0 6
84860: PUSH
84861: LD_INT 1
84863: EQUAL
84864: AND
84865: OR
84866: PUSH
84867: LD_VAR 0 1
84871: PUSH
84872: LD_INT 2
84874: PUSH
84875: LD_INT 3
84877: PUSH
84878: EMPTY
84879: LIST
84880: LIST
84881: IN
84882: NOT
84883: PUSH
84884: LD_VAR 0 6
84888: PUSH
84889: LD_INT 2
84891: EQUAL
84892: AND
84893: OR
84894: IFFALSE 84904
// mode = 0 ;
84896: LD_ADDR_VAR 0 6
84900: PUSH
84901: LD_INT 0
84903: ST_TO_ADDR
// case mode of 0 :
84904: LD_VAR 0 6
84908: PUSH
84909: LD_INT 0
84911: DOUBLE
84912: EQUAL
84913: IFTRUE 84917
84915: GO 96370
84917: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
84918: LD_ADDR_VAR 0 11
84922: PUSH
84923: LD_INT 0
84925: PUSH
84926: LD_INT 0
84928: PUSH
84929: EMPTY
84930: LIST
84931: LIST
84932: PUSH
84933: LD_INT 0
84935: PUSH
84936: LD_INT 1
84938: NEG
84939: PUSH
84940: EMPTY
84941: LIST
84942: LIST
84943: PUSH
84944: LD_INT 1
84946: PUSH
84947: LD_INT 0
84949: PUSH
84950: EMPTY
84951: LIST
84952: LIST
84953: PUSH
84954: LD_INT 1
84956: PUSH
84957: LD_INT 1
84959: PUSH
84960: EMPTY
84961: LIST
84962: LIST
84963: PUSH
84964: LD_INT 0
84966: PUSH
84967: LD_INT 1
84969: PUSH
84970: EMPTY
84971: LIST
84972: LIST
84973: PUSH
84974: LD_INT 1
84976: NEG
84977: PUSH
84978: LD_INT 0
84980: PUSH
84981: EMPTY
84982: LIST
84983: LIST
84984: PUSH
84985: LD_INT 1
84987: NEG
84988: PUSH
84989: LD_INT 1
84991: NEG
84992: PUSH
84993: EMPTY
84994: LIST
84995: LIST
84996: PUSH
84997: LD_INT 1
84999: NEG
85000: PUSH
85001: LD_INT 2
85003: NEG
85004: PUSH
85005: EMPTY
85006: LIST
85007: LIST
85008: PUSH
85009: LD_INT 0
85011: PUSH
85012: LD_INT 2
85014: NEG
85015: PUSH
85016: EMPTY
85017: LIST
85018: LIST
85019: PUSH
85020: LD_INT 1
85022: PUSH
85023: LD_INT 1
85025: NEG
85026: PUSH
85027: EMPTY
85028: LIST
85029: LIST
85030: PUSH
85031: LD_INT 1
85033: PUSH
85034: LD_INT 2
85036: PUSH
85037: EMPTY
85038: LIST
85039: LIST
85040: PUSH
85041: LD_INT 0
85043: PUSH
85044: LD_INT 2
85046: PUSH
85047: EMPTY
85048: LIST
85049: LIST
85050: PUSH
85051: LD_INT 1
85053: NEG
85054: PUSH
85055: LD_INT 1
85057: PUSH
85058: EMPTY
85059: LIST
85060: LIST
85061: PUSH
85062: LD_INT 1
85064: PUSH
85065: LD_INT 3
85067: PUSH
85068: EMPTY
85069: LIST
85070: LIST
85071: PUSH
85072: LD_INT 0
85074: PUSH
85075: LD_INT 3
85077: PUSH
85078: EMPTY
85079: LIST
85080: LIST
85081: PUSH
85082: LD_INT 1
85084: NEG
85085: PUSH
85086: LD_INT 2
85088: PUSH
85089: EMPTY
85090: LIST
85091: LIST
85092: PUSH
85093: EMPTY
85094: LIST
85095: LIST
85096: LIST
85097: LIST
85098: LIST
85099: LIST
85100: LIST
85101: LIST
85102: LIST
85103: LIST
85104: LIST
85105: LIST
85106: LIST
85107: LIST
85108: LIST
85109: LIST
85110: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85111: LD_ADDR_VAR 0 12
85115: PUSH
85116: LD_INT 0
85118: PUSH
85119: LD_INT 0
85121: PUSH
85122: EMPTY
85123: LIST
85124: LIST
85125: PUSH
85126: LD_INT 0
85128: PUSH
85129: LD_INT 1
85131: NEG
85132: PUSH
85133: EMPTY
85134: LIST
85135: LIST
85136: PUSH
85137: LD_INT 1
85139: PUSH
85140: LD_INT 0
85142: PUSH
85143: EMPTY
85144: LIST
85145: LIST
85146: PUSH
85147: LD_INT 1
85149: PUSH
85150: LD_INT 1
85152: PUSH
85153: EMPTY
85154: LIST
85155: LIST
85156: PUSH
85157: LD_INT 0
85159: PUSH
85160: LD_INT 1
85162: PUSH
85163: EMPTY
85164: LIST
85165: LIST
85166: PUSH
85167: LD_INT 1
85169: NEG
85170: PUSH
85171: LD_INT 0
85173: PUSH
85174: EMPTY
85175: LIST
85176: LIST
85177: PUSH
85178: LD_INT 1
85180: NEG
85181: PUSH
85182: LD_INT 1
85184: NEG
85185: PUSH
85186: EMPTY
85187: LIST
85188: LIST
85189: PUSH
85190: LD_INT 1
85192: PUSH
85193: LD_INT 1
85195: NEG
85196: PUSH
85197: EMPTY
85198: LIST
85199: LIST
85200: PUSH
85201: LD_INT 2
85203: PUSH
85204: LD_INT 0
85206: PUSH
85207: EMPTY
85208: LIST
85209: LIST
85210: PUSH
85211: LD_INT 2
85213: PUSH
85214: LD_INT 1
85216: PUSH
85217: EMPTY
85218: LIST
85219: LIST
85220: PUSH
85221: LD_INT 1
85223: NEG
85224: PUSH
85225: LD_INT 1
85227: PUSH
85228: EMPTY
85229: LIST
85230: LIST
85231: PUSH
85232: LD_INT 2
85234: NEG
85235: PUSH
85236: LD_INT 0
85238: PUSH
85239: EMPTY
85240: LIST
85241: LIST
85242: PUSH
85243: LD_INT 2
85245: NEG
85246: PUSH
85247: LD_INT 1
85249: NEG
85250: PUSH
85251: EMPTY
85252: LIST
85253: LIST
85254: PUSH
85255: LD_INT 2
85257: NEG
85258: PUSH
85259: LD_INT 1
85261: PUSH
85262: EMPTY
85263: LIST
85264: LIST
85265: PUSH
85266: LD_INT 3
85268: NEG
85269: PUSH
85270: LD_INT 0
85272: PUSH
85273: EMPTY
85274: LIST
85275: LIST
85276: PUSH
85277: LD_INT 3
85279: NEG
85280: PUSH
85281: LD_INT 1
85283: NEG
85284: PUSH
85285: EMPTY
85286: LIST
85287: LIST
85288: PUSH
85289: EMPTY
85290: LIST
85291: LIST
85292: LIST
85293: LIST
85294: LIST
85295: LIST
85296: LIST
85297: LIST
85298: LIST
85299: LIST
85300: LIST
85301: LIST
85302: LIST
85303: LIST
85304: LIST
85305: LIST
85306: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85307: LD_ADDR_VAR 0 13
85311: PUSH
85312: LD_INT 0
85314: PUSH
85315: LD_INT 0
85317: PUSH
85318: EMPTY
85319: LIST
85320: LIST
85321: PUSH
85322: LD_INT 0
85324: PUSH
85325: LD_INT 1
85327: NEG
85328: PUSH
85329: EMPTY
85330: LIST
85331: LIST
85332: PUSH
85333: LD_INT 1
85335: PUSH
85336: LD_INT 0
85338: PUSH
85339: EMPTY
85340: LIST
85341: LIST
85342: PUSH
85343: LD_INT 1
85345: PUSH
85346: LD_INT 1
85348: PUSH
85349: EMPTY
85350: LIST
85351: LIST
85352: PUSH
85353: LD_INT 0
85355: PUSH
85356: LD_INT 1
85358: PUSH
85359: EMPTY
85360: LIST
85361: LIST
85362: PUSH
85363: LD_INT 1
85365: NEG
85366: PUSH
85367: LD_INT 0
85369: PUSH
85370: EMPTY
85371: LIST
85372: LIST
85373: PUSH
85374: LD_INT 1
85376: NEG
85377: PUSH
85378: LD_INT 1
85380: NEG
85381: PUSH
85382: EMPTY
85383: LIST
85384: LIST
85385: PUSH
85386: LD_INT 1
85388: NEG
85389: PUSH
85390: LD_INT 2
85392: NEG
85393: PUSH
85394: EMPTY
85395: LIST
85396: LIST
85397: PUSH
85398: LD_INT 2
85400: PUSH
85401: LD_INT 1
85403: PUSH
85404: EMPTY
85405: LIST
85406: LIST
85407: PUSH
85408: LD_INT 2
85410: PUSH
85411: LD_INT 2
85413: PUSH
85414: EMPTY
85415: LIST
85416: LIST
85417: PUSH
85418: LD_INT 1
85420: PUSH
85421: LD_INT 2
85423: PUSH
85424: EMPTY
85425: LIST
85426: LIST
85427: PUSH
85428: LD_INT 2
85430: NEG
85431: PUSH
85432: LD_INT 1
85434: NEG
85435: PUSH
85436: EMPTY
85437: LIST
85438: LIST
85439: PUSH
85440: LD_INT 2
85442: NEG
85443: PUSH
85444: LD_INT 2
85446: NEG
85447: PUSH
85448: EMPTY
85449: LIST
85450: LIST
85451: PUSH
85452: LD_INT 2
85454: NEG
85455: PUSH
85456: LD_INT 3
85458: NEG
85459: PUSH
85460: EMPTY
85461: LIST
85462: LIST
85463: PUSH
85464: LD_INT 3
85466: NEG
85467: PUSH
85468: LD_INT 2
85470: NEG
85471: PUSH
85472: EMPTY
85473: LIST
85474: LIST
85475: PUSH
85476: LD_INT 3
85478: NEG
85479: PUSH
85480: LD_INT 3
85482: NEG
85483: PUSH
85484: EMPTY
85485: LIST
85486: LIST
85487: PUSH
85488: EMPTY
85489: LIST
85490: LIST
85491: LIST
85492: LIST
85493: LIST
85494: LIST
85495: LIST
85496: LIST
85497: LIST
85498: LIST
85499: LIST
85500: LIST
85501: LIST
85502: LIST
85503: LIST
85504: LIST
85505: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
85506: LD_ADDR_VAR 0 14
85510: PUSH
85511: LD_INT 0
85513: PUSH
85514: LD_INT 0
85516: PUSH
85517: EMPTY
85518: LIST
85519: LIST
85520: PUSH
85521: LD_INT 0
85523: PUSH
85524: LD_INT 1
85526: NEG
85527: PUSH
85528: EMPTY
85529: LIST
85530: LIST
85531: PUSH
85532: LD_INT 1
85534: PUSH
85535: LD_INT 0
85537: PUSH
85538: EMPTY
85539: LIST
85540: LIST
85541: PUSH
85542: LD_INT 1
85544: PUSH
85545: LD_INT 1
85547: PUSH
85548: EMPTY
85549: LIST
85550: LIST
85551: PUSH
85552: LD_INT 0
85554: PUSH
85555: LD_INT 1
85557: PUSH
85558: EMPTY
85559: LIST
85560: LIST
85561: PUSH
85562: LD_INT 1
85564: NEG
85565: PUSH
85566: LD_INT 0
85568: PUSH
85569: EMPTY
85570: LIST
85571: LIST
85572: PUSH
85573: LD_INT 1
85575: NEG
85576: PUSH
85577: LD_INT 1
85579: NEG
85580: PUSH
85581: EMPTY
85582: LIST
85583: LIST
85584: PUSH
85585: LD_INT 1
85587: NEG
85588: PUSH
85589: LD_INT 2
85591: NEG
85592: PUSH
85593: EMPTY
85594: LIST
85595: LIST
85596: PUSH
85597: LD_INT 0
85599: PUSH
85600: LD_INT 2
85602: NEG
85603: PUSH
85604: EMPTY
85605: LIST
85606: LIST
85607: PUSH
85608: LD_INT 1
85610: PUSH
85611: LD_INT 1
85613: NEG
85614: PUSH
85615: EMPTY
85616: LIST
85617: LIST
85618: PUSH
85619: LD_INT 1
85621: PUSH
85622: LD_INT 2
85624: PUSH
85625: EMPTY
85626: LIST
85627: LIST
85628: PUSH
85629: LD_INT 0
85631: PUSH
85632: LD_INT 2
85634: PUSH
85635: EMPTY
85636: LIST
85637: LIST
85638: PUSH
85639: LD_INT 1
85641: NEG
85642: PUSH
85643: LD_INT 1
85645: PUSH
85646: EMPTY
85647: LIST
85648: LIST
85649: PUSH
85650: LD_INT 1
85652: NEG
85653: PUSH
85654: LD_INT 3
85656: NEG
85657: PUSH
85658: EMPTY
85659: LIST
85660: LIST
85661: PUSH
85662: LD_INT 0
85664: PUSH
85665: LD_INT 3
85667: NEG
85668: PUSH
85669: EMPTY
85670: LIST
85671: LIST
85672: PUSH
85673: LD_INT 1
85675: PUSH
85676: LD_INT 2
85678: NEG
85679: PUSH
85680: EMPTY
85681: LIST
85682: LIST
85683: PUSH
85684: EMPTY
85685: LIST
85686: LIST
85687: LIST
85688: LIST
85689: LIST
85690: LIST
85691: LIST
85692: LIST
85693: LIST
85694: LIST
85695: LIST
85696: LIST
85697: LIST
85698: LIST
85699: LIST
85700: LIST
85701: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
85702: LD_ADDR_VAR 0 15
85706: PUSH
85707: LD_INT 0
85709: PUSH
85710: LD_INT 0
85712: PUSH
85713: EMPTY
85714: LIST
85715: LIST
85716: PUSH
85717: LD_INT 0
85719: PUSH
85720: LD_INT 1
85722: NEG
85723: PUSH
85724: EMPTY
85725: LIST
85726: LIST
85727: PUSH
85728: LD_INT 1
85730: PUSH
85731: LD_INT 0
85733: PUSH
85734: EMPTY
85735: LIST
85736: LIST
85737: PUSH
85738: LD_INT 1
85740: PUSH
85741: LD_INT 1
85743: PUSH
85744: EMPTY
85745: LIST
85746: LIST
85747: PUSH
85748: LD_INT 0
85750: PUSH
85751: LD_INT 1
85753: PUSH
85754: EMPTY
85755: LIST
85756: LIST
85757: PUSH
85758: LD_INT 1
85760: NEG
85761: PUSH
85762: LD_INT 0
85764: PUSH
85765: EMPTY
85766: LIST
85767: LIST
85768: PUSH
85769: LD_INT 1
85771: NEG
85772: PUSH
85773: LD_INT 1
85775: NEG
85776: PUSH
85777: EMPTY
85778: LIST
85779: LIST
85780: PUSH
85781: LD_INT 1
85783: PUSH
85784: LD_INT 1
85786: NEG
85787: PUSH
85788: EMPTY
85789: LIST
85790: LIST
85791: PUSH
85792: LD_INT 2
85794: PUSH
85795: LD_INT 0
85797: PUSH
85798: EMPTY
85799: LIST
85800: LIST
85801: PUSH
85802: LD_INT 2
85804: PUSH
85805: LD_INT 1
85807: PUSH
85808: EMPTY
85809: LIST
85810: LIST
85811: PUSH
85812: LD_INT 1
85814: NEG
85815: PUSH
85816: LD_INT 1
85818: PUSH
85819: EMPTY
85820: LIST
85821: LIST
85822: PUSH
85823: LD_INT 2
85825: NEG
85826: PUSH
85827: LD_INT 0
85829: PUSH
85830: EMPTY
85831: LIST
85832: LIST
85833: PUSH
85834: LD_INT 2
85836: NEG
85837: PUSH
85838: LD_INT 1
85840: NEG
85841: PUSH
85842: EMPTY
85843: LIST
85844: LIST
85845: PUSH
85846: LD_INT 2
85848: PUSH
85849: LD_INT 1
85851: NEG
85852: PUSH
85853: EMPTY
85854: LIST
85855: LIST
85856: PUSH
85857: LD_INT 3
85859: PUSH
85860: LD_INT 0
85862: PUSH
85863: EMPTY
85864: LIST
85865: LIST
85866: PUSH
85867: LD_INT 3
85869: PUSH
85870: LD_INT 1
85872: PUSH
85873: EMPTY
85874: LIST
85875: LIST
85876: PUSH
85877: EMPTY
85878: LIST
85879: LIST
85880: LIST
85881: LIST
85882: LIST
85883: LIST
85884: LIST
85885: LIST
85886: LIST
85887: LIST
85888: LIST
85889: LIST
85890: LIST
85891: LIST
85892: LIST
85893: LIST
85894: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
85895: LD_ADDR_VAR 0 16
85899: PUSH
85900: LD_INT 0
85902: PUSH
85903: LD_INT 0
85905: PUSH
85906: EMPTY
85907: LIST
85908: LIST
85909: PUSH
85910: LD_INT 0
85912: PUSH
85913: LD_INT 1
85915: NEG
85916: PUSH
85917: EMPTY
85918: LIST
85919: LIST
85920: PUSH
85921: LD_INT 1
85923: PUSH
85924: LD_INT 0
85926: PUSH
85927: EMPTY
85928: LIST
85929: LIST
85930: PUSH
85931: LD_INT 1
85933: PUSH
85934: LD_INT 1
85936: PUSH
85937: EMPTY
85938: LIST
85939: LIST
85940: PUSH
85941: LD_INT 0
85943: PUSH
85944: LD_INT 1
85946: PUSH
85947: EMPTY
85948: LIST
85949: LIST
85950: PUSH
85951: LD_INT 1
85953: NEG
85954: PUSH
85955: LD_INT 0
85957: PUSH
85958: EMPTY
85959: LIST
85960: LIST
85961: PUSH
85962: LD_INT 1
85964: NEG
85965: PUSH
85966: LD_INT 1
85968: NEG
85969: PUSH
85970: EMPTY
85971: LIST
85972: LIST
85973: PUSH
85974: LD_INT 1
85976: NEG
85977: PUSH
85978: LD_INT 2
85980: NEG
85981: PUSH
85982: EMPTY
85983: LIST
85984: LIST
85985: PUSH
85986: LD_INT 2
85988: PUSH
85989: LD_INT 1
85991: PUSH
85992: EMPTY
85993: LIST
85994: LIST
85995: PUSH
85996: LD_INT 2
85998: PUSH
85999: LD_INT 2
86001: PUSH
86002: EMPTY
86003: LIST
86004: LIST
86005: PUSH
86006: LD_INT 1
86008: PUSH
86009: LD_INT 2
86011: PUSH
86012: EMPTY
86013: LIST
86014: LIST
86015: PUSH
86016: LD_INT 2
86018: NEG
86019: PUSH
86020: LD_INT 1
86022: NEG
86023: PUSH
86024: EMPTY
86025: LIST
86026: LIST
86027: PUSH
86028: LD_INT 2
86030: NEG
86031: PUSH
86032: LD_INT 2
86034: NEG
86035: PUSH
86036: EMPTY
86037: LIST
86038: LIST
86039: PUSH
86040: LD_INT 3
86042: PUSH
86043: LD_INT 2
86045: PUSH
86046: EMPTY
86047: LIST
86048: LIST
86049: PUSH
86050: LD_INT 3
86052: PUSH
86053: LD_INT 3
86055: PUSH
86056: EMPTY
86057: LIST
86058: LIST
86059: PUSH
86060: LD_INT 2
86062: PUSH
86063: LD_INT 3
86065: PUSH
86066: EMPTY
86067: LIST
86068: LIST
86069: PUSH
86070: EMPTY
86071: LIST
86072: LIST
86073: LIST
86074: LIST
86075: LIST
86076: LIST
86077: LIST
86078: LIST
86079: LIST
86080: LIST
86081: LIST
86082: LIST
86083: LIST
86084: LIST
86085: LIST
86086: LIST
86087: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86088: LD_ADDR_VAR 0 17
86092: PUSH
86093: LD_INT 0
86095: PUSH
86096: LD_INT 0
86098: PUSH
86099: EMPTY
86100: LIST
86101: LIST
86102: PUSH
86103: LD_INT 0
86105: PUSH
86106: LD_INT 1
86108: NEG
86109: PUSH
86110: EMPTY
86111: LIST
86112: LIST
86113: PUSH
86114: LD_INT 1
86116: PUSH
86117: LD_INT 0
86119: PUSH
86120: EMPTY
86121: LIST
86122: LIST
86123: PUSH
86124: LD_INT 1
86126: PUSH
86127: LD_INT 1
86129: PUSH
86130: EMPTY
86131: LIST
86132: LIST
86133: PUSH
86134: LD_INT 0
86136: PUSH
86137: LD_INT 1
86139: PUSH
86140: EMPTY
86141: LIST
86142: LIST
86143: PUSH
86144: LD_INT 1
86146: NEG
86147: PUSH
86148: LD_INT 0
86150: PUSH
86151: EMPTY
86152: LIST
86153: LIST
86154: PUSH
86155: LD_INT 1
86157: NEG
86158: PUSH
86159: LD_INT 1
86161: NEG
86162: PUSH
86163: EMPTY
86164: LIST
86165: LIST
86166: PUSH
86167: LD_INT 1
86169: NEG
86170: PUSH
86171: LD_INT 2
86173: NEG
86174: PUSH
86175: EMPTY
86176: LIST
86177: LIST
86178: PUSH
86179: LD_INT 0
86181: PUSH
86182: LD_INT 2
86184: NEG
86185: PUSH
86186: EMPTY
86187: LIST
86188: LIST
86189: PUSH
86190: LD_INT 1
86192: PUSH
86193: LD_INT 1
86195: NEG
86196: PUSH
86197: EMPTY
86198: LIST
86199: LIST
86200: PUSH
86201: LD_INT 2
86203: PUSH
86204: LD_INT 0
86206: PUSH
86207: EMPTY
86208: LIST
86209: LIST
86210: PUSH
86211: LD_INT 2
86213: PUSH
86214: LD_INT 1
86216: PUSH
86217: EMPTY
86218: LIST
86219: LIST
86220: PUSH
86221: LD_INT 2
86223: PUSH
86224: LD_INT 2
86226: PUSH
86227: EMPTY
86228: LIST
86229: LIST
86230: PUSH
86231: LD_INT 1
86233: PUSH
86234: LD_INT 2
86236: PUSH
86237: EMPTY
86238: LIST
86239: LIST
86240: PUSH
86241: LD_INT 0
86243: PUSH
86244: LD_INT 2
86246: PUSH
86247: EMPTY
86248: LIST
86249: LIST
86250: PUSH
86251: LD_INT 1
86253: NEG
86254: PUSH
86255: LD_INT 1
86257: PUSH
86258: EMPTY
86259: LIST
86260: LIST
86261: PUSH
86262: LD_INT 2
86264: NEG
86265: PUSH
86266: LD_INT 0
86268: PUSH
86269: EMPTY
86270: LIST
86271: LIST
86272: PUSH
86273: LD_INT 2
86275: NEG
86276: PUSH
86277: LD_INT 1
86279: NEG
86280: PUSH
86281: EMPTY
86282: LIST
86283: LIST
86284: PUSH
86285: LD_INT 2
86287: NEG
86288: PUSH
86289: LD_INT 2
86291: NEG
86292: PUSH
86293: EMPTY
86294: LIST
86295: LIST
86296: PUSH
86297: EMPTY
86298: LIST
86299: LIST
86300: LIST
86301: LIST
86302: LIST
86303: LIST
86304: LIST
86305: LIST
86306: LIST
86307: LIST
86308: LIST
86309: LIST
86310: LIST
86311: LIST
86312: LIST
86313: LIST
86314: LIST
86315: LIST
86316: LIST
86317: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86318: LD_ADDR_VAR 0 18
86322: PUSH
86323: LD_INT 0
86325: PUSH
86326: LD_INT 0
86328: PUSH
86329: EMPTY
86330: LIST
86331: LIST
86332: PUSH
86333: LD_INT 0
86335: PUSH
86336: LD_INT 1
86338: NEG
86339: PUSH
86340: EMPTY
86341: LIST
86342: LIST
86343: PUSH
86344: LD_INT 1
86346: PUSH
86347: LD_INT 0
86349: PUSH
86350: EMPTY
86351: LIST
86352: LIST
86353: PUSH
86354: LD_INT 1
86356: PUSH
86357: LD_INT 1
86359: PUSH
86360: EMPTY
86361: LIST
86362: LIST
86363: PUSH
86364: LD_INT 0
86366: PUSH
86367: LD_INT 1
86369: PUSH
86370: EMPTY
86371: LIST
86372: LIST
86373: PUSH
86374: LD_INT 1
86376: NEG
86377: PUSH
86378: LD_INT 0
86380: PUSH
86381: EMPTY
86382: LIST
86383: LIST
86384: PUSH
86385: LD_INT 1
86387: NEG
86388: PUSH
86389: LD_INT 1
86391: NEG
86392: PUSH
86393: EMPTY
86394: LIST
86395: LIST
86396: PUSH
86397: LD_INT 1
86399: NEG
86400: PUSH
86401: LD_INT 2
86403: NEG
86404: PUSH
86405: EMPTY
86406: LIST
86407: LIST
86408: PUSH
86409: LD_INT 0
86411: PUSH
86412: LD_INT 2
86414: NEG
86415: PUSH
86416: EMPTY
86417: LIST
86418: LIST
86419: PUSH
86420: LD_INT 1
86422: PUSH
86423: LD_INT 1
86425: NEG
86426: PUSH
86427: EMPTY
86428: LIST
86429: LIST
86430: PUSH
86431: LD_INT 2
86433: PUSH
86434: LD_INT 0
86436: PUSH
86437: EMPTY
86438: LIST
86439: LIST
86440: PUSH
86441: LD_INT 2
86443: PUSH
86444: LD_INT 1
86446: PUSH
86447: EMPTY
86448: LIST
86449: LIST
86450: PUSH
86451: LD_INT 2
86453: PUSH
86454: LD_INT 2
86456: PUSH
86457: EMPTY
86458: LIST
86459: LIST
86460: PUSH
86461: LD_INT 1
86463: PUSH
86464: LD_INT 2
86466: PUSH
86467: EMPTY
86468: LIST
86469: LIST
86470: PUSH
86471: LD_INT 0
86473: PUSH
86474: LD_INT 2
86476: PUSH
86477: EMPTY
86478: LIST
86479: LIST
86480: PUSH
86481: LD_INT 1
86483: NEG
86484: PUSH
86485: LD_INT 1
86487: PUSH
86488: EMPTY
86489: LIST
86490: LIST
86491: PUSH
86492: LD_INT 2
86494: NEG
86495: PUSH
86496: LD_INT 0
86498: PUSH
86499: EMPTY
86500: LIST
86501: LIST
86502: PUSH
86503: LD_INT 2
86505: NEG
86506: PUSH
86507: LD_INT 1
86509: NEG
86510: PUSH
86511: EMPTY
86512: LIST
86513: LIST
86514: PUSH
86515: LD_INT 2
86517: NEG
86518: PUSH
86519: LD_INT 2
86521: NEG
86522: PUSH
86523: EMPTY
86524: LIST
86525: LIST
86526: PUSH
86527: EMPTY
86528: LIST
86529: LIST
86530: LIST
86531: LIST
86532: LIST
86533: LIST
86534: LIST
86535: LIST
86536: LIST
86537: LIST
86538: LIST
86539: LIST
86540: LIST
86541: LIST
86542: LIST
86543: LIST
86544: LIST
86545: LIST
86546: LIST
86547: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86548: LD_ADDR_VAR 0 19
86552: PUSH
86553: LD_INT 0
86555: PUSH
86556: LD_INT 0
86558: PUSH
86559: EMPTY
86560: LIST
86561: LIST
86562: PUSH
86563: LD_INT 0
86565: PUSH
86566: LD_INT 1
86568: NEG
86569: PUSH
86570: EMPTY
86571: LIST
86572: LIST
86573: PUSH
86574: LD_INT 1
86576: PUSH
86577: LD_INT 0
86579: PUSH
86580: EMPTY
86581: LIST
86582: LIST
86583: PUSH
86584: LD_INT 1
86586: PUSH
86587: LD_INT 1
86589: PUSH
86590: EMPTY
86591: LIST
86592: LIST
86593: PUSH
86594: LD_INT 0
86596: PUSH
86597: LD_INT 1
86599: PUSH
86600: EMPTY
86601: LIST
86602: LIST
86603: PUSH
86604: LD_INT 1
86606: NEG
86607: PUSH
86608: LD_INT 0
86610: PUSH
86611: EMPTY
86612: LIST
86613: LIST
86614: PUSH
86615: LD_INT 1
86617: NEG
86618: PUSH
86619: LD_INT 1
86621: NEG
86622: PUSH
86623: EMPTY
86624: LIST
86625: LIST
86626: PUSH
86627: LD_INT 1
86629: NEG
86630: PUSH
86631: LD_INT 2
86633: NEG
86634: PUSH
86635: EMPTY
86636: LIST
86637: LIST
86638: PUSH
86639: LD_INT 0
86641: PUSH
86642: LD_INT 2
86644: NEG
86645: PUSH
86646: EMPTY
86647: LIST
86648: LIST
86649: PUSH
86650: LD_INT 1
86652: PUSH
86653: LD_INT 1
86655: NEG
86656: PUSH
86657: EMPTY
86658: LIST
86659: LIST
86660: PUSH
86661: LD_INT 2
86663: PUSH
86664: LD_INT 0
86666: PUSH
86667: EMPTY
86668: LIST
86669: LIST
86670: PUSH
86671: LD_INT 2
86673: PUSH
86674: LD_INT 1
86676: PUSH
86677: EMPTY
86678: LIST
86679: LIST
86680: PUSH
86681: LD_INT 2
86683: PUSH
86684: LD_INT 2
86686: PUSH
86687: EMPTY
86688: LIST
86689: LIST
86690: PUSH
86691: LD_INT 1
86693: PUSH
86694: LD_INT 2
86696: PUSH
86697: EMPTY
86698: LIST
86699: LIST
86700: PUSH
86701: LD_INT 0
86703: PUSH
86704: LD_INT 2
86706: PUSH
86707: EMPTY
86708: LIST
86709: LIST
86710: PUSH
86711: LD_INT 1
86713: NEG
86714: PUSH
86715: LD_INT 1
86717: PUSH
86718: EMPTY
86719: LIST
86720: LIST
86721: PUSH
86722: LD_INT 2
86724: NEG
86725: PUSH
86726: LD_INT 0
86728: PUSH
86729: EMPTY
86730: LIST
86731: LIST
86732: PUSH
86733: LD_INT 2
86735: NEG
86736: PUSH
86737: LD_INT 1
86739: NEG
86740: PUSH
86741: EMPTY
86742: LIST
86743: LIST
86744: PUSH
86745: LD_INT 2
86747: NEG
86748: PUSH
86749: LD_INT 2
86751: NEG
86752: PUSH
86753: EMPTY
86754: LIST
86755: LIST
86756: PUSH
86757: EMPTY
86758: LIST
86759: LIST
86760: LIST
86761: LIST
86762: LIST
86763: LIST
86764: LIST
86765: LIST
86766: LIST
86767: LIST
86768: LIST
86769: LIST
86770: LIST
86771: LIST
86772: LIST
86773: LIST
86774: LIST
86775: LIST
86776: LIST
86777: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86778: LD_ADDR_VAR 0 20
86782: PUSH
86783: LD_INT 0
86785: PUSH
86786: LD_INT 0
86788: PUSH
86789: EMPTY
86790: LIST
86791: LIST
86792: PUSH
86793: LD_INT 0
86795: PUSH
86796: LD_INT 1
86798: NEG
86799: PUSH
86800: EMPTY
86801: LIST
86802: LIST
86803: PUSH
86804: LD_INT 1
86806: PUSH
86807: LD_INT 0
86809: PUSH
86810: EMPTY
86811: LIST
86812: LIST
86813: PUSH
86814: LD_INT 1
86816: PUSH
86817: LD_INT 1
86819: PUSH
86820: EMPTY
86821: LIST
86822: LIST
86823: PUSH
86824: LD_INT 0
86826: PUSH
86827: LD_INT 1
86829: PUSH
86830: EMPTY
86831: LIST
86832: LIST
86833: PUSH
86834: LD_INT 1
86836: NEG
86837: PUSH
86838: LD_INT 0
86840: PUSH
86841: EMPTY
86842: LIST
86843: LIST
86844: PUSH
86845: LD_INT 1
86847: NEG
86848: PUSH
86849: LD_INT 1
86851: NEG
86852: PUSH
86853: EMPTY
86854: LIST
86855: LIST
86856: PUSH
86857: LD_INT 1
86859: NEG
86860: PUSH
86861: LD_INT 2
86863: NEG
86864: PUSH
86865: EMPTY
86866: LIST
86867: LIST
86868: PUSH
86869: LD_INT 0
86871: PUSH
86872: LD_INT 2
86874: NEG
86875: PUSH
86876: EMPTY
86877: LIST
86878: LIST
86879: PUSH
86880: LD_INT 1
86882: PUSH
86883: LD_INT 1
86885: NEG
86886: PUSH
86887: EMPTY
86888: LIST
86889: LIST
86890: PUSH
86891: LD_INT 2
86893: PUSH
86894: LD_INT 0
86896: PUSH
86897: EMPTY
86898: LIST
86899: LIST
86900: PUSH
86901: LD_INT 2
86903: PUSH
86904: LD_INT 1
86906: PUSH
86907: EMPTY
86908: LIST
86909: LIST
86910: PUSH
86911: LD_INT 2
86913: PUSH
86914: LD_INT 2
86916: PUSH
86917: EMPTY
86918: LIST
86919: LIST
86920: PUSH
86921: LD_INT 1
86923: PUSH
86924: LD_INT 2
86926: PUSH
86927: EMPTY
86928: LIST
86929: LIST
86930: PUSH
86931: LD_INT 0
86933: PUSH
86934: LD_INT 2
86936: PUSH
86937: EMPTY
86938: LIST
86939: LIST
86940: PUSH
86941: LD_INT 1
86943: NEG
86944: PUSH
86945: LD_INT 1
86947: PUSH
86948: EMPTY
86949: LIST
86950: LIST
86951: PUSH
86952: LD_INT 2
86954: NEG
86955: PUSH
86956: LD_INT 0
86958: PUSH
86959: EMPTY
86960: LIST
86961: LIST
86962: PUSH
86963: LD_INT 2
86965: NEG
86966: PUSH
86967: LD_INT 1
86969: NEG
86970: PUSH
86971: EMPTY
86972: LIST
86973: LIST
86974: PUSH
86975: LD_INT 2
86977: NEG
86978: PUSH
86979: LD_INT 2
86981: NEG
86982: PUSH
86983: EMPTY
86984: LIST
86985: LIST
86986: PUSH
86987: EMPTY
86988: LIST
86989: LIST
86990: LIST
86991: LIST
86992: LIST
86993: LIST
86994: LIST
86995: LIST
86996: LIST
86997: LIST
86998: LIST
86999: LIST
87000: LIST
87001: LIST
87002: LIST
87003: LIST
87004: LIST
87005: LIST
87006: LIST
87007: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87008: LD_ADDR_VAR 0 21
87012: PUSH
87013: LD_INT 0
87015: PUSH
87016: LD_INT 0
87018: PUSH
87019: EMPTY
87020: LIST
87021: LIST
87022: PUSH
87023: LD_INT 0
87025: PUSH
87026: LD_INT 1
87028: NEG
87029: PUSH
87030: EMPTY
87031: LIST
87032: LIST
87033: PUSH
87034: LD_INT 1
87036: PUSH
87037: LD_INT 0
87039: PUSH
87040: EMPTY
87041: LIST
87042: LIST
87043: PUSH
87044: LD_INT 1
87046: PUSH
87047: LD_INT 1
87049: PUSH
87050: EMPTY
87051: LIST
87052: LIST
87053: PUSH
87054: LD_INT 0
87056: PUSH
87057: LD_INT 1
87059: PUSH
87060: EMPTY
87061: LIST
87062: LIST
87063: PUSH
87064: LD_INT 1
87066: NEG
87067: PUSH
87068: LD_INT 0
87070: PUSH
87071: EMPTY
87072: LIST
87073: LIST
87074: PUSH
87075: LD_INT 1
87077: NEG
87078: PUSH
87079: LD_INT 1
87081: NEG
87082: PUSH
87083: EMPTY
87084: LIST
87085: LIST
87086: PUSH
87087: LD_INT 1
87089: NEG
87090: PUSH
87091: LD_INT 2
87093: NEG
87094: PUSH
87095: EMPTY
87096: LIST
87097: LIST
87098: PUSH
87099: LD_INT 0
87101: PUSH
87102: LD_INT 2
87104: NEG
87105: PUSH
87106: EMPTY
87107: LIST
87108: LIST
87109: PUSH
87110: LD_INT 1
87112: PUSH
87113: LD_INT 1
87115: NEG
87116: PUSH
87117: EMPTY
87118: LIST
87119: LIST
87120: PUSH
87121: LD_INT 2
87123: PUSH
87124: LD_INT 0
87126: PUSH
87127: EMPTY
87128: LIST
87129: LIST
87130: PUSH
87131: LD_INT 2
87133: PUSH
87134: LD_INT 1
87136: PUSH
87137: EMPTY
87138: LIST
87139: LIST
87140: PUSH
87141: LD_INT 2
87143: PUSH
87144: LD_INT 2
87146: PUSH
87147: EMPTY
87148: LIST
87149: LIST
87150: PUSH
87151: LD_INT 1
87153: PUSH
87154: LD_INT 2
87156: PUSH
87157: EMPTY
87158: LIST
87159: LIST
87160: PUSH
87161: LD_INT 0
87163: PUSH
87164: LD_INT 2
87166: PUSH
87167: EMPTY
87168: LIST
87169: LIST
87170: PUSH
87171: LD_INT 1
87173: NEG
87174: PUSH
87175: LD_INT 1
87177: PUSH
87178: EMPTY
87179: LIST
87180: LIST
87181: PUSH
87182: LD_INT 2
87184: NEG
87185: PUSH
87186: LD_INT 0
87188: PUSH
87189: EMPTY
87190: LIST
87191: LIST
87192: PUSH
87193: LD_INT 2
87195: NEG
87196: PUSH
87197: LD_INT 1
87199: NEG
87200: PUSH
87201: EMPTY
87202: LIST
87203: LIST
87204: PUSH
87205: LD_INT 2
87207: NEG
87208: PUSH
87209: LD_INT 2
87211: NEG
87212: PUSH
87213: EMPTY
87214: LIST
87215: LIST
87216: PUSH
87217: EMPTY
87218: LIST
87219: LIST
87220: LIST
87221: LIST
87222: LIST
87223: LIST
87224: LIST
87225: LIST
87226: LIST
87227: LIST
87228: LIST
87229: LIST
87230: LIST
87231: LIST
87232: LIST
87233: LIST
87234: LIST
87235: LIST
87236: LIST
87237: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87238: LD_ADDR_VAR 0 22
87242: PUSH
87243: LD_INT 0
87245: PUSH
87246: LD_INT 0
87248: PUSH
87249: EMPTY
87250: LIST
87251: LIST
87252: PUSH
87253: LD_INT 0
87255: PUSH
87256: LD_INT 1
87258: NEG
87259: PUSH
87260: EMPTY
87261: LIST
87262: LIST
87263: PUSH
87264: LD_INT 1
87266: PUSH
87267: LD_INT 0
87269: PUSH
87270: EMPTY
87271: LIST
87272: LIST
87273: PUSH
87274: LD_INT 1
87276: PUSH
87277: LD_INT 1
87279: PUSH
87280: EMPTY
87281: LIST
87282: LIST
87283: PUSH
87284: LD_INT 0
87286: PUSH
87287: LD_INT 1
87289: PUSH
87290: EMPTY
87291: LIST
87292: LIST
87293: PUSH
87294: LD_INT 1
87296: NEG
87297: PUSH
87298: LD_INT 0
87300: PUSH
87301: EMPTY
87302: LIST
87303: LIST
87304: PUSH
87305: LD_INT 1
87307: NEG
87308: PUSH
87309: LD_INT 1
87311: NEG
87312: PUSH
87313: EMPTY
87314: LIST
87315: LIST
87316: PUSH
87317: LD_INT 1
87319: NEG
87320: PUSH
87321: LD_INT 2
87323: NEG
87324: PUSH
87325: EMPTY
87326: LIST
87327: LIST
87328: PUSH
87329: LD_INT 0
87331: PUSH
87332: LD_INT 2
87334: NEG
87335: PUSH
87336: EMPTY
87337: LIST
87338: LIST
87339: PUSH
87340: LD_INT 1
87342: PUSH
87343: LD_INT 1
87345: NEG
87346: PUSH
87347: EMPTY
87348: LIST
87349: LIST
87350: PUSH
87351: LD_INT 2
87353: PUSH
87354: LD_INT 0
87356: PUSH
87357: EMPTY
87358: LIST
87359: LIST
87360: PUSH
87361: LD_INT 2
87363: PUSH
87364: LD_INT 1
87366: PUSH
87367: EMPTY
87368: LIST
87369: LIST
87370: PUSH
87371: LD_INT 2
87373: PUSH
87374: LD_INT 2
87376: PUSH
87377: EMPTY
87378: LIST
87379: LIST
87380: PUSH
87381: LD_INT 1
87383: PUSH
87384: LD_INT 2
87386: PUSH
87387: EMPTY
87388: LIST
87389: LIST
87390: PUSH
87391: LD_INT 0
87393: PUSH
87394: LD_INT 2
87396: PUSH
87397: EMPTY
87398: LIST
87399: LIST
87400: PUSH
87401: LD_INT 1
87403: NEG
87404: PUSH
87405: LD_INT 1
87407: PUSH
87408: EMPTY
87409: LIST
87410: LIST
87411: PUSH
87412: LD_INT 2
87414: NEG
87415: PUSH
87416: LD_INT 0
87418: PUSH
87419: EMPTY
87420: LIST
87421: LIST
87422: PUSH
87423: LD_INT 2
87425: NEG
87426: PUSH
87427: LD_INT 1
87429: NEG
87430: PUSH
87431: EMPTY
87432: LIST
87433: LIST
87434: PUSH
87435: LD_INT 2
87437: NEG
87438: PUSH
87439: LD_INT 2
87441: NEG
87442: PUSH
87443: EMPTY
87444: LIST
87445: LIST
87446: PUSH
87447: EMPTY
87448: LIST
87449: LIST
87450: LIST
87451: LIST
87452: LIST
87453: LIST
87454: LIST
87455: LIST
87456: LIST
87457: LIST
87458: LIST
87459: LIST
87460: LIST
87461: LIST
87462: LIST
87463: LIST
87464: LIST
87465: LIST
87466: LIST
87467: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
87468: LD_ADDR_VAR 0 23
87472: PUSH
87473: LD_INT 0
87475: PUSH
87476: LD_INT 0
87478: PUSH
87479: EMPTY
87480: LIST
87481: LIST
87482: PUSH
87483: LD_INT 0
87485: PUSH
87486: LD_INT 1
87488: NEG
87489: PUSH
87490: EMPTY
87491: LIST
87492: LIST
87493: PUSH
87494: LD_INT 1
87496: PUSH
87497: LD_INT 0
87499: PUSH
87500: EMPTY
87501: LIST
87502: LIST
87503: PUSH
87504: LD_INT 1
87506: PUSH
87507: LD_INT 1
87509: PUSH
87510: EMPTY
87511: LIST
87512: LIST
87513: PUSH
87514: LD_INT 0
87516: PUSH
87517: LD_INT 1
87519: PUSH
87520: EMPTY
87521: LIST
87522: LIST
87523: PUSH
87524: LD_INT 1
87526: NEG
87527: PUSH
87528: LD_INT 0
87530: PUSH
87531: EMPTY
87532: LIST
87533: LIST
87534: PUSH
87535: LD_INT 1
87537: NEG
87538: PUSH
87539: LD_INT 1
87541: NEG
87542: PUSH
87543: EMPTY
87544: LIST
87545: LIST
87546: PUSH
87547: LD_INT 1
87549: NEG
87550: PUSH
87551: LD_INT 2
87553: NEG
87554: PUSH
87555: EMPTY
87556: LIST
87557: LIST
87558: PUSH
87559: LD_INT 0
87561: PUSH
87562: LD_INT 2
87564: NEG
87565: PUSH
87566: EMPTY
87567: LIST
87568: LIST
87569: PUSH
87570: LD_INT 1
87572: PUSH
87573: LD_INT 1
87575: NEG
87576: PUSH
87577: EMPTY
87578: LIST
87579: LIST
87580: PUSH
87581: LD_INT 2
87583: PUSH
87584: LD_INT 0
87586: PUSH
87587: EMPTY
87588: LIST
87589: LIST
87590: PUSH
87591: LD_INT 2
87593: PUSH
87594: LD_INT 1
87596: PUSH
87597: EMPTY
87598: LIST
87599: LIST
87600: PUSH
87601: LD_INT 2
87603: PUSH
87604: LD_INT 2
87606: PUSH
87607: EMPTY
87608: LIST
87609: LIST
87610: PUSH
87611: LD_INT 1
87613: PUSH
87614: LD_INT 2
87616: PUSH
87617: EMPTY
87618: LIST
87619: LIST
87620: PUSH
87621: LD_INT 0
87623: PUSH
87624: LD_INT 2
87626: PUSH
87627: EMPTY
87628: LIST
87629: LIST
87630: PUSH
87631: LD_INT 1
87633: NEG
87634: PUSH
87635: LD_INT 1
87637: PUSH
87638: EMPTY
87639: LIST
87640: LIST
87641: PUSH
87642: LD_INT 2
87644: NEG
87645: PUSH
87646: LD_INT 0
87648: PUSH
87649: EMPTY
87650: LIST
87651: LIST
87652: PUSH
87653: LD_INT 2
87655: NEG
87656: PUSH
87657: LD_INT 1
87659: NEG
87660: PUSH
87661: EMPTY
87662: LIST
87663: LIST
87664: PUSH
87665: LD_INT 2
87667: NEG
87668: PUSH
87669: LD_INT 2
87671: NEG
87672: PUSH
87673: EMPTY
87674: LIST
87675: LIST
87676: PUSH
87677: LD_INT 2
87679: NEG
87680: PUSH
87681: LD_INT 3
87683: NEG
87684: PUSH
87685: EMPTY
87686: LIST
87687: LIST
87688: PUSH
87689: LD_INT 1
87691: NEG
87692: PUSH
87693: LD_INT 3
87695: NEG
87696: PUSH
87697: EMPTY
87698: LIST
87699: LIST
87700: PUSH
87701: LD_INT 1
87703: PUSH
87704: LD_INT 2
87706: NEG
87707: PUSH
87708: EMPTY
87709: LIST
87710: LIST
87711: PUSH
87712: LD_INT 2
87714: PUSH
87715: LD_INT 1
87717: NEG
87718: PUSH
87719: EMPTY
87720: LIST
87721: LIST
87722: PUSH
87723: EMPTY
87724: LIST
87725: LIST
87726: LIST
87727: LIST
87728: LIST
87729: LIST
87730: LIST
87731: LIST
87732: LIST
87733: LIST
87734: LIST
87735: LIST
87736: LIST
87737: LIST
87738: LIST
87739: LIST
87740: LIST
87741: LIST
87742: LIST
87743: LIST
87744: LIST
87745: LIST
87746: LIST
87747: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
87748: LD_ADDR_VAR 0 24
87752: PUSH
87753: LD_INT 0
87755: PUSH
87756: LD_INT 0
87758: PUSH
87759: EMPTY
87760: LIST
87761: LIST
87762: PUSH
87763: LD_INT 0
87765: PUSH
87766: LD_INT 1
87768: NEG
87769: PUSH
87770: EMPTY
87771: LIST
87772: LIST
87773: PUSH
87774: LD_INT 1
87776: PUSH
87777: LD_INT 0
87779: PUSH
87780: EMPTY
87781: LIST
87782: LIST
87783: PUSH
87784: LD_INT 1
87786: PUSH
87787: LD_INT 1
87789: PUSH
87790: EMPTY
87791: LIST
87792: LIST
87793: PUSH
87794: LD_INT 0
87796: PUSH
87797: LD_INT 1
87799: PUSH
87800: EMPTY
87801: LIST
87802: LIST
87803: PUSH
87804: LD_INT 1
87806: NEG
87807: PUSH
87808: LD_INT 0
87810: PUSH
87811: EMPTY
87812: LIST
87813: LIST
87814: PUSH
87815: LD_INT 1
87817: NEG
87818: PUSH
87819: LD_INT 1
87821: NEG
87822: PUSH
87823: EMPTY
87824: LIST
87825: LIST
87826: PUSH
87827: LD_INT 1
87829: NEG
87830: PUSH
87831: LD_INT 2
87833: NEG
87834: PUSH
87835: EMPTY
87836: LIST
87837: LIST
87838: PUSH
87839: LD_INT 0
87841: PUSH
87842: LD_INT 2
87844: NEG
87845: PUSH
87846: EMPTY
87847: LIST
87848: LIST
87849: PUSH
87850: LD_INT 1
87852: PUSH
87853: LD_INT 1
87855: NEG
87856: PUSH
87857: EMPTY
87858: LIST
87859: LIST
87860: PUSH
87861: LD_INT 2
87863: PUSH
87864: LD_INT 0
87866: PUSH
87867: EMPTY
87868: LIST
87869: LIST
87870: PUSH
87871: LD_INT 2
87873: PUSH
87874: LD_INT 1
87876: PUSH
87877: EMPTY
87878: LIST
87879: LIST
87880: PUSH
87881: LD_INT 2
87883: PUSH
87884: LD_INT 2
87886: PUSH
87887: EMPTY
87888: LIST
87889: LIST
87890: PUSH
87891: LD_INT 1
87893: PUSH
87894: LD_INT 2
87896: PUSH
87897: EMPTY
87898: LIST
87899: LIST
87900: PUSH
87901: LD_INT 0
87903: PUSH
87904: LD_INT 2
87906: PUSH
87907: EMPTY
87908: LIST
87909: LIST
87910: PUSH
87911: LD_INT 1
87913: NEG
87914: PUSH
87915: LD_INT 1
87917: PUSH
87918: EMPTY
87919: LIST
87920: LIST
87921: PUSH
87922: LD_INT 2
87924: NEG
87925: PUSH
87926: LD_INT 0
87928: PUSH
87929: EMPTY
87930: LIST
87931: LIST
87932: PUSH
87933: LD_INT 2
87935: NEG
87936: PUSH
87937: LD_INT 1
87939: NEG
87940: PUSH
87941: EMPTY
87942: LIST
87943: LIST
87944: PUSH
87945: LD_INT 2
87947: NEG
87948: PUSH
87949: LD_INT 2
87951: NEG
87952: PUSH
87953: EMPTY
87954: LIST
87955: LIST
87956: PUSH
87957: LD_INT 1
87959: PUSH
87960: LD_INT 2
87962: NEG
87963: PUSH
87964: EMPTY
87965: LIST
87966: LIST
87967: PUSH
87968: LD_INT 2
87970: PUSH
87971: LD_INT 1
87973: NEG
87974: PUSH
87975: EMPTY
87976: LIST
87977: LIST
87978: PUSH
87979: LD_INT 3
87981: PUSH
87982: LD_INT 1
87984: PUSH
87985: EMPTY
87986: LIST
87987: LIST
87988: PUSH
87989: LD_INT 3
87991: PUSH
87992: LD_INT 2
87994: PUSH
87995: EMPTY
87996: LIST
87997: LIST
87998: PUSH
87999: EMPTY
88000: LIST
88001: LIST
88002: LIST
88003: LIST
88004: LIST
88005: LIST
88006: LIST
88007: LIST
88008: LIST
88009: LIST
88010: LIST
88011: LIST
88012: LIST
88013: LIST
88014: LIST
88015: LIST
88016: LIST
88017: LIST
88018: LIST
88019: LIST
88020: LIST
88021: LIST
88022: LIST
88023: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
88024: LD_ADDR_VAR 0 25
88028: PUSH
88029: LD_INT 0
88031: PUSH
88032: LD_INT 0
88034: PUSH
88035: EMPTY
88036: LIST
88037: LIST
88038: PUSH
88039: LD_INT 0
88041: PUSH
88042: LD_INT 1
88044: NEG
88045: PUSH
88046: EMPTY
88047: LIST
88048: LIST
88049: PUSH
88050: LD_INT 1
88052: PUSH
88053: LD_INT 0
88055: PUSH
88056: EMPTY
88057: LIST
88058: LIST
88059: PUSH
88060: LD_INT 1
88062: PUSH
88063: LD_INT 1
88065: PUSH
88066: EMPTY
88067: LIST
88068: LIST
88069: PUSH
88070: LD_INT 0
88072: PUSH
88073: LD_INT 1
88075: PUSH
88076: EMPTY
88077: LIST
88078: LIST
88079: PUSH
88080: LD_INT 1
88082: NEG
88083: PUSH
88084: LD_INT 0
88086: PUSH
88087: EMPTY
88088: LIST
88089: LIST
88090: PUSH
88091: LD_INT 1
88093: NEG
88094: PUSH
88095: LD_INT 1
88097: NEG
88098: PUSH
88099: EMPTY
88100: LIST
88101: LIST
88102: PUSH
88103: LD_INT 1
88105: NEG
88106: PUSH
88107: LD_INT 2
88109: NEG
88110: PUSH
88111: EMPTY
88112: LIST
88113: LIST
88114: PUSH
88115: LD_INT 0
88117: PUSH
88118: LD_INT 2
88120: NEG
88121: PUSH
88122: EMPTY
88123: LIST
88124: LIST
88125: PUSH
88126: LD_INT 1
88128: PUSH
88129: LD_INT 1
88131: NEG
88132: PUSH
88133: EMPTY
88134: LIST
88135: LIST
88136: PUSH
88137: LD_INT 2
88139: PUSH
88140: LD_INT 0
88142: PUSH
88143: EMPTY
88144: LIST
88145: LIST
88146: PUSH
88147: LD_INT 2
88149: PUSH
88150: LD_INT 1
88152: PUSH
88153: EMPTY
88154: LIST
88155: LIST
88156: PUSH
88157: LD_INT 2
88159: PUSH
88160: LD_INT 2
88162: PUSH
88163: EMPTY
88164: LIST
88165: LIST
88166: PUSH
88167: LD_INT 1
88169: PUSH
88170: LD_INT 2
88172: PUSH
88173: EMPTY
88174: LIST
88175: LIST
88176: PUSH
88177: LD_INT 0
88179: PUSH
88180: LD_INT 2
88182: PUSH
88183: EMPTY
88184: LIST
88185: LIST
88186: PUSH
88187: LD_INT 1
88189: NEG
88190: PUSH
88191: LD_INT 1
88193: PUSH
88194: EMPTY
88195: LIST
88196: LIST
88197: PUSH
88198: LD_INT 2
88200: NEG
88201: PUSH
88202: LD_INT 0
88204: PUSH
88205: EMPTY
88206: LIST
88207: LIST
88208: PUSH
88209: LD_INT 2
88211: NEG
88212: PUSH
88213: LD_INT 1
88215: NEG
88216: PUSH
88217: EMPTY
88218: LIST
88219: LIST
88220: PUSH
88221: LD_INT 2
88223: NEG
88224: PUSH
88225: LD_INT 2
88227: NEG
88228: PUSH
88229: EMPTY
88230: LIST
88231: LIST
88232: PUSH
88233: LD_INT 3
88235: PUSH
88236: LD_INT 1
88238: PUSH
88239: EMPTY
88240: LIST
88241: LIST
88242: PUSH
88243: LD_INT 3
88245: PUSH
88246: LD_INT 2
88248: PUSH
88249: EMPTY
88250: LIST
88251: LIST
88252: PUSH
88253: LD_INT 2
88255: PUSH
88256: LD_INT 3
88258: PUSH
88259: EMPTY
88260: LIST
88261: LIST
88262: PUSH
88263: LD_INT 1
88265: PUSH
88266: LD_INT 3
88268: PUSH
88269: EMPTY
88270: LIST
88271: LIST
88272: PUSH
88273: EMPTY
88274: LIST
88275: LIST
88276: LIST
88277: LIST
88278: LIST
88279: LIST
88280: LIST
88281: LIST
88282: LIST
88283: LIST
88284: LIST
88285: LIST
88286: LIST
88287: LIST
88288: LIST
88289: LIST
88290: LIST
88291: LIST
88292: LIST
88293: LIST
88294: LIST
88295: LIST
88296: LIST
88297: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
88298: LD_ADDR_VAR 0 26
88302: PUSH
88303: LD_INT 0
88305: PUSH
88306: LD_INT 0
88308: PUSH
88309: EMPTY
88310: LIST
88311: LIST
88312: PUSH
88313: LD_INT 0
88315: PUSH
88316: LD_INT 1
88318: NEG
88319: PUSH
88320: EMPTY
88321: LIST
88322: LIST
88323: PUSH
88324: LD_INT 1
88326: PUSH
88327: LD_INT 0
88329: PUSH
88330: EMPTY
88331: LIST
88332: LIST
88333: PUSH
88334: LD_INT 1
88336: PUSH
88337: LD_INT 1
88339: PUSH
88340: EMPTY
88341: LIST
88342: LIST
88343: PUSH
88344: LD_INT 0
88346: PUSH
88347: LD_INT 1
88349: PUSH
88350: EMPTY
88351: LIST
88352: LIST
88353: PUSH
88354: LD_INT 1
88356: NEG
88357: PUSH
88358: LD_INT 0
88360: PUSH
88361: EMPTY
88362: LIST
88363: LIST
88364: PUSH
88365: LD_INT 1
88367: NEG
88368: PUSH
88369: LD_INT 1
88371: NEG
88372: PUSH
88373: EMPTY
88374: LIST
88375: LIST
88376: PUSH
88377: LD_INT 1
88379: NEG
88380: PUSH
88381: LD_INT 2
88383: NEG
88384: PUSH
88385: EMPTY
88386: LIST
88387: LIST
88388: PUSH
88389: LD_INT 0
88391: PUSH
88392: LD_INT 2
88394: NEG
88395: PUSH
88396: EMPTY
88397: LIST
88398: LIST
88399: PUSH
88400: LD_INT 1
88402: PUSH
88403: LD_INT 1
88405: NEG
88406: PUSH
88407: EMPTY
88408: LIST
88409: LIST
88410: PUSH
88411: LD_INT 2
88413: PUSH
88414: LD_INT 0
88416: PUSH
88417: EMPTY
88418: LIST
88419: LIST
88420: PUSH
88421: LD_INT 2
88423: PUSH
88424: LD_INT 1
88426: PUSH
88427: EMPTY
88428: LIST
88429: LIST
88430: PUSH
88431: LD_INT 2
88433: PUSH
88434: LD_INT 2
88436: PUSH
88437: EMPTY
88438: LIST
88439: LIST
88440: PUSH
88441: LD_INT 1
88443: PUSH
88444: LD_INT 2
88446: PUSH
88447: EMPTY
88448: LIST
88449: LIST
88450: PUSH
88451: LD_INT 0
88453: PUSH
88454: LD_INT 2
88456: PUSH
88457: EMPTY
88458: LIST
88459: LIST
88460: PUSH
88461: LD_INT 1
88463: NEG
88464: PUSH
88465: LD_INT 1
88467: PUSH
88468: EMPTY
88469: LIST
88470: LIST
88471: PUSH
88472: LD_INT 2
88474: NEG
88475: PUSH
88476: LD_INT 0
88478: PUSH
88479: EMPTY
88480: LIST
88481: LIST
88482: PUSH
88483: LD_INT 2
88485: NEG
88486: PUSH
88487: LD_INT 1
88489: NEG
88490: PUSH
88491: EMPTY
88492: LIST
88493: LIST
88494: PUSH
88495: LD_INT 2
88497: NEG
88498: PUSH
88499: LD_INT 2
88501: NEG
88502: PUSH
88503: EMPTY
88504: LIST
88505: LIST
88506: PUSH
88507: LD_INT 2
88509: PUSH
88510: LD_INT 3
88512: PUSH
88513: EMPTY
88514: LIST
88515: LIST
88516: PUSH
88517: LD_INT 1
88519: PUSH
88520: LD_INT 3
88522: PUSH
88523: EMPTY
88524: LIST
88525: LIST
88526: PUSH
88527: LD_INT 1
88529: NEG
88530: PUSH
88531: LD_INT 2
88533: PUSH
88534: EMPTY
88535: LIST
88536: LIST
88537: PUSH
88538: LD_INT 2
88540: NEG
88541: PUSH
88542: LD_INT 1
88544: PUSH
88545: EMPTY
88546: LIST
88547: LIST
88548: PUSH
88549: EMPTY
88550: LIST
88551: LIST
88552: LIST
88553: LIST
88554: LIST
88555: LIST
88556: LIST
88557: LIST
88558: LIST
88559: LIST
88560: LIST
88561: LIST
88562: LIST
88563: LIST
88564: LIST
88565: LIST
88566: LIST
88567: LIST
88568: LIST
88569: LIST
88570: LIST
88571: LIST
88572: LIST
88573: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
88574: LD_ADDR_VAR 0 27
88578: PUSH
88579: LD_INT 0
88581: PUSH
88582: LD_INT 0
88584: PUSH
88585: EMPTY
88586: LIST
88587: LIST
88588: PUSH
88589: LD_INT 0
88591: PUSH
88592: LD_INT 1
88594: NEG
88595: PUSH
88596: EMPTY
88597: LIST
88598: LIST
88599: PUSH
88600: LD_INT 1
88602: PUSH
88603: LD_INT 0
88605: PUSH
88606: EMPTY
88607: LIST
88608: LIST
88609: PUSH
88610: LD_INT 1
88612: PUSH
88613: LD_INT 1
88615: PUSH
88616: EMPTY
88617: LIST
88618: LIST
88619: PUSH
88620: LD_INT 0
88622: PUSH
88623: LD_INT 1
88625: PUSH
88626: EMPTY
88627: LIST
88628: LIST
88629: PUSH
88630: LD_INT 1
88632: NEG
88633: PUSH
88634: LD_INT 0
88636: PUSH
88637: EMPTY
88638: LIST
88639: LIST
88640: PUSH
88641: LD_INT 1
88643: NEG
88644: PUSH
88645: LD_INT 1
88647: NEG
88648: PUSH
88649: EMPTY
88650: LIST
88651: LIST
88652: PUSH
88653: LD_INT 1
88655: NEG
88656: PUSH
88657: LD_INT 2
88659: NEG
88660: PUSH
88661: EMPTY
88662: LIST
88663: LIST
88664: PUSH
88665: LD_INT 0
88667: PUSH
88668: LD_INT 2
88670: NEG
88671: PUSH
88672: EMPTY
88673: LIST
88674: LIST
88675: PUSH
88676: LD_INT 1
88678: PUSH
88679: LD_INT 1
88681: NEG
88682: PUSH
88683: EMPTY
88684: LIST
88685: LIST
88686: PUSH
88687: LD_INT 2
88689: PUSH
88690: LD_INT 0
88692: PUSH
88693: EMPTY
88694: LIST
88695: LIST
88696: PUSH
88697: LD_INT 2
88699: PUSH
88700: LD_INT 1
88702: PUSH
88703: EMPTY
88704: LIST
88705: LIST
88706: PUSH
88707: LD_INT 2
88709: PUSH
88710: LD_INT 2
88712: PUSH
88713: EMPTY
88714: LIST
88715: LIST
88716: PUSH
88717: LD_INT 1
88719: PUSH
88720: LD_INT 2
88722: PUSH
88723: EMPTY
88724: LIST
88725: LIST
88726: PUSH
88727: LD_INT 0
88729: PUSH
88730: LD_INT 2
88732: PUSH
88733: EMPTY
88734: LIST
88735: LIST
88736: PUSH
88737: LD_INT 1
88739: NEG
88740: PUSH
88741: LD_INT 1
88743: PUSH
88744: EMPTY
88745: LIST
88746: LIST
88747: PUSH
88748: LD_INT 2
88750: NEG
88751: PUSH
88752: LD_INT 0
88754: PUSH
88755: EMPTY
88756: LIST
88757: LIST
88758: PUSH
88759: LD_INT 2
88761: NEG
88762: PUSH
88763: LD_INT 1
88765: NEG
88766: PUSH
88767: EMPTY
88768: LIST
88769: LIST
88770: PUSH
88771: LD_INT 2
88773: NEG
88774: PUSH
88775: LD_INT 2
88777: NEG
88778: PUSH
88779: EMPTY
88780: LIST
88781: LIST
88782: PUSH
88783: LD_INT 1
88785: NEG
88786: PUSH
88787: LD_INT 2
88789: PUSH
88790: EMPTY
88791: LIST
88792: LIST
88793: PUSH
88794: LD_INT 2
88796: NEG
88797: PUSH
88798: LD_INT 1
88800: PUSH
88801: EMPTY
88802: LIST
88803: LIST
88804: PUSH
88805: LD_INT 3
88807: NEG
88808: PUSH
88809: LD_INT 1
88811: NEG
88812: PUSH
88813: EMPTY
88814: LIST
88815: LIST
88816: PUSH
88817: LD_INT 3
88819: NEG
88820: PUSH
88821: LD_INT 2
88823: NEG
88824: PUSH
88825: EMPTY
88826: LIST
88827: LIST
88828: PUSH
88829: EMPTY
88830: LIST
88831: LIST
88832: LIST
88833: LIST
88834: LIST
88835: LIST
88836: LIST
88837: LIST
88838: LIST
88839: LIST
88840: LIST
88841: LIST
88842: LIST
88843: LIST
88844: LIST
88845: LIST
88846: LIST
88847: LIST
88848: LIST
88849: LIST
88850: LIST
88851: LIST
88852: LIST
88853: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
88854: LD_ADDR_VAR 0 28
88858: PUSH
88859: LD_INT 0
88861: PUSH
88862: LD_INT 0
88864: PUSH
88865: EMPTY
88866: LIST
88867: LIST
88868: PUSH
88869: LD_INT 0
88871: PUSH
88872: LD_INT 1
88874: NEG
88875: PUSH
88876: EMPTY
88877: LIST
88878: LIST
88879: PUSH
88880: LD_INT 1
88882: PUSH
88883: LD_INT 0
88885: PUSH
88886: EMPTY
88887: LIST
88888: LIST
88889: PUSH
88890: LD_INT 1
88892: PUSH
88893: LD_INT 1
88895: PUSH
88896: EMPTY
88897: LIST
88898: LIST
88899: PUSH
88900: LD_INT 0
88902: PUSH
88903: LD_INT 1
88905: PUSH
88906: EMPTY
88907: LIST
88908: LIST
88909: PUSH
88910: LD_INT 1
88912: NEG
88913: PUSH
88914: LD_INT 0
88916: PUSH
88917: EMPTY
88918: LIST
88919: LIST
88920: PUSH
88921: LD_INT 1
88923: NEG
88924: PUSH
88925: LD_INT 1
88927: NEG
88928: PUSH
88929: EMPTY
88930: LIST
88931: LIST
88932: PUSH
88933: LD_INT 1
88935: NEG
88936: PUSH
88937: LD_INT 2
88939: NEG
88940: PUSH
88941: EMPTY
88942: LIST
88943: LIST
88944: PUSH
88945: LD_INT 0
88947: PUSH
88948: LD_INT 2
88950: NEG
88951: PUSH
88952: EMPTY
88953: LIST
88954: LIST
88955: PUSH
88956: LD_INT 1
88958: PUSH
88959: LD_INT 1
88961: NEG
88962: PUSH
88963: EMPTY
88964: LIST
88965: LIST
88966: PUSH
88967: LD_INT 2
88969: PUSH
88970: LD_INT 0
88972: PUSH
88973: EMPTY
88974: LIST
88975: LIST
88976: PUSH
88977: LD_INT 2
88979: PUSH
88980: LD_INT 1
88982: PUSH
88983: EMPTY
88984: LIST
88985: LIST
88986: PUSH
88987: LD_INT 2
88989: PUSH
88990: LD_INT 2
88992: PUSH
88993: EMPTY
88994: LIST
88995: LIST
88996: PUSH
88997: LD_INT 1
88999: PUSH
89000: LD_INT 2
89002: PUSH
89003: EMPTY
89004: LIST
89005: LIST
89006: PUSH
89007: LD_INT 0
89009: PUSH
89010: LD_INT 2
89012: PUSH
89013: EMPTY
89014: LIST
89015: LIST
89016: PUSH
89017: LD_INT 1
89019: NEG
89020: PUSH
89021: LD_INT 1
89023: PUSH
89024: EMPTY
89025: LIST
89026: LIST
89027: PUSH
89028: LD_INT 2
89030: NEG
89031: PUSH
89032: LD_INT 0
89034: PUSH
89035: EMPTY
89036: LIST
89037: LIST
89038: PUSH
89039: LD_INT 2
89041: NEG
89042: PUSH
89043: LD_INT 1
89045: NEG
89046: PUSH
89047: EMPTY
89048: LIST
89049: LIST
89050: PUSH
89051: LD_INT 2
89053: NEG
89054: PUSH
89055: LD_INT 2
89057: NEG
89058: PUSH
89059: EMPTY
89060: LIST
89061: LIST
89062: PUSH
89063: LD_INT 2
89065: NEG
89066: PUSH
89067: LD_INT 3
89069: NEG
89070: PUSH
89071: EMPTY
89072: LIST
89073: LIST
89074: PUSH
89075: LD_INT 1
89077: NEG
89078: PUSH
89079: LD_INT 3
89081: NEG
89082: PUSH
89083: EMPTY
89084: LIST
89085: LIST
89086: PUSH
89087: LD_INT 3
89089: NEG
89090: PUSH
89091: LD_INT 1
89093: NEG
89094: PUSH
89095: EMPTY
89096: LIST
89097: LIST
89098: PUSH
89099: LD_INT 3
89101: NEG
89102: PUSH
89103: LD_INT 2
89105: NEG
89106: PUSH
89107: EMPTY
89108: LIST
89109: LIST
89110: PUSH
89111: EMPTY
89112: LIST
89113: LIST
89114: LIST
89115: LIST
89116: LIST
89117: LIST
89118: LIST
89119: LIST
89120: LIST
89121: LIST
89122: LIST
89123: LIST
89124: LIST
89125: LIST
89126: LIST
89127: LIST
89128: LIST
89129: LIST
89130: LIST
89131: LIST
89132: LIST
89133: LIST
89134: LIST
89135: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
89136: LD_ADDR_VAR 0 29
89140: PUSH
89141: LD_INT 0
89143: PUSH
89144: LD_INT 0
89146: PUSH
89147: EMPTY
89148: LIST
89149: LIST
89150: PUSH
89151: LD_INT 0
89153: PUSH
89154: LD_INT 1
89156: NEG
89157: PUSH
89158: EMPTY
89159: LIST
89160: LIST
89161: PUSH
89162: LD_INT 1
89164: PUSH
89165: LD_INT 0
89167: PUSH
89168: EMPTY
89169: LIST
89170: LIST
89171: PUSH
89172: LD_INT 1
89174: PUSH
89175: LD_INT 1
89177: PUSH
89178: EMPTY
89179: LIST
89180: LIST
89181: PUSH
89182: LD_INT 0
89184: PUSH
89185: LD_INT 1
89187: PUSH
89188: EMPTY
89189: LIST
89190: LIST
89191: PUSH
89192: LD_INT 1
89194: NEG
89195: PUSH
89196: LD_INT 0
89198: PUSH
89199: EMPTY
89200: LIST
89201: LIST
89202: PUSH
89203: LD_INT 1
89205: NEG
89206: PUSH
89207: LD_INT 1
89209: NEG
89210: PUSH
89211: EMPTY
89212: LIST
89213: LIST
89214: PUSH
89215: LD_INT 1
89217: NEG
89218: PUSH
89219: LD_INT 2
89221: NEG
89222: PUSH
89223: EMPTY
89224: LIST
89225: LIST
89226: PUSH
89227: LD_INT 0
89229: PUSH
89230: LD_INT 2
89232: NEG
89233: PUSH
89234: EMPTY
89235: LIST
89236: LIST
89237: PUSH
89238: LD_INT 1
89240: PUSH
89241: LD_INT 1
89243: NEG
89244: PUSH
89245: EMPTY
89246: LIST
89247: LIST
89248: PUSH
89249: LD_INT 2
89251: PUSH
89252: LD_INT 0
89254: PUSH
89255: EMPTY
89256: LIST
89257: LIST
89258: PUSH
89259: LD_INT 2
89261: PUSH
89262: LD_INT 1
89264: PUSH
89265: EMPTY
89266: LIST
89267: LIST
89268: PUSH
89269: LD_INT 1
89271: PUSH
89272: LD_INT 2
89274: PUSH
89275: EMPTY
89276: LIST
89277: LIST
89278: PUSH
89279: LD_INT 0
89281: PUSH
89282: LD_INT 2
89284: PUSH
89285: EMPTY
89286: LIST
89287: LIST
89288: PUSH
89289: LD_INT 1
89291: NEG
89292: PUSH
89293: LD_INT 1
89295: PUSH
89296: EMPTY
89297: LIST
89298: LIST
89299: PUSH
89300: LD_INT 2
89302: NEG
89303: PUSH
89304: LD_INT 1
89306: NEG
89307: PUSH
89308: EMPTY
89309: LIST
89310: LIST
89311: PUSH
89312: LD_INT 2
89314: NEG
89315: PUSH
89316: LD_INT 2
89318: NEG
89319: PUSH
89320: EMPTY
89321: LIST
89322: LIST
89323: PUSH
89324: LD_INT 2
89326: NEG
89327: PUSH
89328: LD_INT 3
89330: NEG
89331: PUSH
89332: EMPTY
89333: LIST
89334: LIST
89335: PUSH
89336: LD_INT 2
89338: PUSH
89339: LD_INT 1
89341: NEG
89342: PUSH
89343: EMPTY
89344: LIST
89345: LIST
89346: PUSH
89347: LD_INT 3
89349: PUSH
89350: LD_INT 1
89352: PUSH
89353: EMPTY
89354: LIST
89355: LIST
89356: PUSH
89357: LD_INT 1
89359: PUSH
89360: LD_INT 3
89362: PUSH
89363: EMPTY
89364: LIST
89365: LIST
89366: PUSH
89367: LD_INT 1
89369: NEG
89370: PUSH
89371: LD_INT 2
89373: PUSH
89374: EMPTY
89375: LIST
89376: LIST
89377: PUSH
89378: LD_INT 3
89380: NEG
89381: PUSH
89382: LD_INT 2
89384: NEG
89385: PUSH
89386: EMPTY
89387: LIST
89388: LIST
89389: PUSH
89390: EMPTY
89391: LIST
89392: LIST
89393: LIST
89394: LIST
89395: LIST
89396: LIST
89397: LIST
89398: LIST
89399: LIST
89400: LIST
89401: LIST
89402: LIST
89403: LIST
89404: LIST
89405: LIST
89406: LIST
89407: LIST
89408: LIST
89409: LIST
89410: LIST
89411: LIST
89412: LIST
89413: LIST
89414: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
89415: LD_ADDR_VAR 0 30
89419: PUSH
89420: LD_INT 0
89422: PUSH
89423: LD_INT 0
89425: PUSH
89426: EMPTY
89427: LIST
89428: LIST
89429: PUSH
89430: LD_INT 0
89432: PUSH
89433: LD_INT 1
89435: NEG
89436: PUSH
89437: EMPTY
89438: LIST
89439: LIST
89440: PUSH
89441: LD_INT 1
89443: PUSH
89444: LD_INT 0
89446: PUSH
89447: EMPTY
89448: LIST
89449: LIST
89450: PUSH
89451: LD_INT 1
89453: PUSH
89454: LD_INT 1
89456: PUSH
89457: EMPTY
89458: LIST
89459: LIST
89460: PUSH
89461: LD_INT 0
89463: PUSH
89464: LD_INT 1
89466: PUSH
89467: EMPTY
89468: LIST
89469: LIST
89470: PUSH
89471: LD_INT 1
89473: NEG
89474: PUSH
89475: LD_INT 0
89477: PUSH
89478: EMPTY
89479: LIST
89480: LIST
89481: PUSH
89482: LD_INT 1
89484: NEG
89485: PUSH
89486: LD_INT 1
89488: NEG
89489: PUSH
89490: EMPTY
89491: LIST
89492: LIST
89493: PUSH
89494: LD_INT 1
89496: NEG
89497: PUSH
89498: LD_INT 2
89500: NEG
89501: PUSH
89502: EMPTY
89503: LIST
89504: LIST
89505: PUSH
89506: LD_INT 0
89508: PUSH
89509: LD_INT 2
89511: NEG
89512: PUSH
89513: EMPTY
89514: LIST
89515: LIST
89516: PUSH
89517: LD_INT 1
89519: PUSH
89520: LD_INT 1
89522: NEG
89523: PUSH
89524: EMPTY
89525: LIST
89526: LIST
89527: PUSH
89528: LD_INT 2
89530: PUSH
89531: LD_INT 0
89533: PUSH
89534: EMPTY
89535: LIST
89536: LIST
89537: PUSH
89538: LD_INT 2
89540: PUSH
89541: LD_INT 1
89543: PUSH
89544: EMPTY
89545: LIST
89546: LIST
89547: PUSH
89548: LD_INT 2
89550: PUSH
89551: LD_INT 2
89553: PUSH
89554: EMPTY
89555: LIST
89556: LIST
89557: PUSH
89558: LD_INT 1
89560: PUSH
89561: LD_INT 2
89563: PUSH
89564: EMPTY
89565: LIST
89566: LIST
89567: PUSH
89568: LD_INT 1
89570: NEG
89571: PUSH
89572: LD_INT 1
89574: PUSH
89575: EMPTY
89576: LIST
89577: LIST
89578: PUSH
89579: LD_INT 2
89581: NEG
89582: PUSH
89583: LD_INT 0
89585: PUSH
89586: EMPTY
89587: LIST
89588: LIST
89589: PUSH
89590: LD_INT 2
89592: NEG
89593: PUSH
89594: LD_INT 1
89596: NEG
89597: PUSH
89598: EMPTY
89599: LIST
89600: LIST
89601: PUSH
89602: LD_INT 1
89604: NEG
89605: PUSH
89606: LD_INT 3
89608: NEG
89609: PUSH
89610: EMPTY
89611: LIST
89612: LIST
89613: PUSH
89614: LD_INT 1
89616: PUSH
89617: LD_INT 2
89619: NEG
89620: PUSH
89621: EMPTY
89622: LIST
89623: LIST
89624: PUSH
89625: LD_INT 3
89627: PUSH
89628: LD_INT 2
89630: PUSH
89631: EMPTY
89632: LIST
89633: LIST
89634: PUSH
89635: LD_INT 2
89637: PUSH
89638: LD_INT 3
89640: PUSH
89641: EMPTY
89642: LIST
89643: LIST
89644: PUSH
89645: LD_INT 2
89647: NEG
89648: PUSH
89649: LD_INT 1
89651: PUSH
89652: EMPTY
89653: LIST
89654: LIST
89655: PUSH
89656: LD_INT 3
89658: NEG
89659: PUSH
89660: LD_INT 1
89662: NEG
89663: PUSH
89664: EMPTY
89665: LIST
89666: LIST
89667: PUSH
89668: EMPTY
89669: LIST
89670: LIST
89671: LIST
89672: LIST
89673: LIST
89674: LIST
89675: LIST
89676: LIST
89677: LIST
89678: LIST
89679: LIST
89680: LIST
89681: LIST
89682: LIST
89683: LIST
89684: LIST
89685: LIST
89686: LIST
89687: LIST
89688: LIST
89689: LIST
89690: LIST
89691: LIST
89692: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
89693: LD_ADDR_VAR 0 31
89697: PUSH
89698: LD_INT 0
89700: PUSH
89701: LD_INT 0
89703: PUSH
89704: EMPTY
89705: LIST
89706: LIST
89707: PUSH
89708: LD_INT 0
89710: PUSH
89711: LD_INT 1
89713: NEG
89714: PUSH
89715: EMPTY
89716: LIST
89717: LIST
89718: PUSH
89719: LD_INT 1
89721: PUSH
89722: LD_INT 0
89724: PUSH
89725: EMPTY
89726: LIST
89727: LIST
89728: PUSH
89729: LD_INT 1
89731: PUSH
89732: LD_INT 1
89734: PUSH
89735: EMPTY
89736: LIST
89737: LIST
89738: PUSH
89739: LD_INT 0
89741: PUSH
89742: LD_INT 1
89744: PUSH
89745: EMPTY
89746: LIST
89747: LIST
89748: PUSH
89749: LD_INT 1
89751: NEG
89752: PUSH
89753: LD_INT 0
89755: PUSH
89756: EMPTY
89757: LIST
89758: LIST
89759: PUSH
89760: LD_INT 1
89762: NEG
89763: PUSH
89764: LD_INT 1
89766: NEG
89767: PUSH
89768: EMPTY
89769: LIST
89770: LIST
89771: PUSH
89772: LD_INT 1
89774: NEG
89775: PUSH
89776: LD_INT 2
89778: NEG
89779: PUSH
89780: EMPTY
89781: LIST
89782: LIST
89783: PUSH
89784: LD_INT 1
89786: PUSH
89787: LD_INT 1
89789: NEG
89790: PUSH
89791: EMPTY
89792: LIST
89793: LIST
89794: PUSH
89795: LD_INT 2
89797: PUSH
89798: LD_INT 0
89800: PUSH
89801: EMPTY
89802: LIST
89803: LIST
89804: PUSH
89805: LD_INT 2
89807: PUSH
89808: LD_INT 1
89810: PUSH
89811: EMPTY
89812: LIST
89813: LIST
89814: PUSH
89815: LD_INT 2
89817: PUSH
89818: LD_INT 2
89820: PUSH
89821: EMPTY
89822: LIST
89823: LIST
89824: PUSH
89825: LD_INT 1
89827: PUSH
89828: LD_INT 2
89830: PUSH
89831: EMPTY
89832: LIST
89833: LIST
89834: PUSH
89835: LD_INT 0
89837: PUSH
89838: LD_INT 2
89840: PUSH
89841: EMPTY
89842: LIST
89843: LIST
89844: PUSH
89845: LD_INT 1
89847: NEG
89848: PUSH
89849: LD_INT 1
89851: PUSH
89852: EMPTY
89853: LIST
89854: LIST
89855: PUSH
89856: LD_INT 2
89858: NEG
89859: PUSH
89860: LD_INT 1
89862: NEG
89863: PUSH
89864: EMPTY
89865: LIST
89866: LIST
89867: PUSH
89868: LD_INT 2
89870: NEG
89871: PUSH
89872: LD_INT 2
89874: NEG
89875: PUSH
89876: EMPTY
89877: LIST
89878: LIST
89879: PUSH
89880: LD_INT 2
89882: NEG
89883: PUSH
89884: LD_INT 3
89886: NEG
89887: PUSH
89888: EMPTY
89889: LIST
89890: LIST
89891: PUSH
89892: LD_INT 2
89894: PUSH
89895: LD_INT 1
89897: NEG
89898: PUSH
89899: EMPTY
89900: LIST
89901: LIST
89902: PUSH
89903: LD_INT 3
89905: PUSH
89906: LD_INT 1
89908: PUSH
89909: EMPTY
89910: LIST
89911: LIST
89912: PUSH
89913: LD_INT 1
89915: PUSH
89916: LD_INT 3
89918: PUSH
89919: EMPTY
89920: LIST
89921: LIST
89922: PUSH
89923: LD_INT 1
89925: NEG
89926: PUSH
89927: LD_INT 2
89929: PUSH
89930: EMPTY
89931: LIST
89932: LIST
89933: PUSH
89934: LD_INT 3
89936: NEG
89937: PUSH
89938: LD_INT 2
89940: NEG
89941: PUSH
89942: EMPTY
89943: LIST
89944: LIST
89945: PUSH
89946: EMPTY
89947: LIST
89948: LIST
89949: LIST
89950: LIST
89951: LIST
89952: LIST
89953: LIST
89954: LIST
89955: LIST
89956: LIST
89957: LIST
89958: LIST
89959: LIST
89960: LIST
89961: LIST
89962: LIST
89963: LIST
89964: LIST
89965: LIST
89966: LIST
89967: LIST
89968: LIST
89969: LIST
89970: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
89971: LD_ADDR_VAR 0 32
89975: PUSH
89976: LD_INT 0
89978: PUSH
89979: LD_INT 0
89981: PUSH
89982: EMPTY
89983: LIST
89984: LIST
89985: PUSH
89986: LD_INT 0
89988: PUSH
89989: LD_INT 1
89991: NEG
89992: PUSH
89993: EMPTY
89994: LIST
89995: LIST
89996: PUSH
89997: LD_INT 1
89999: PUSH
90000: LD_INT 0
90002: PUSH
90003: EMPTY
90004: LIST
90005: LIST
90006: PUSH
90007: LD_INT 1
90009: PUSH
90010: LD_INT 1
90012: PUSH
90013: EMPTY
90014: LIST
90015: LIST
90016: PUSH
90017: LD_INT 0
90019: PUSH
90020: LD_INT 1
90022: PUSH
90023: EMPTY
90024: LIST
90025: LIST
90026: PUSH
90027: LD_INT 1
90029: NEG
90030: PUSH
90031: LD_INT 0
90033: PUSH
90034: EMPTY
90035: LIST
90036: LIST
90037: PUSH
90038: LD_INT 1
90040: NEG
90041: PUSH
90042: LD_INT 1
90044: NEG
90045: PUSH
90046: EMPTY
90047: LIST
90048: LIST
90049: PUSH
90050: LD_INT 1
90052: NEG
90053: PUSH
90054: LD_INT 2
90056: NEG
90057: PUSH
90058: EMPTY
90059: LIST
90060: LIST
90061: PUSH
90062: LD_INT 0
90064: PUSH
90065: LD_INT 2
90067: NEG
90068: PUSH
90069: EMPTY
90070: LIST
90071: LIST
90072: PUSH
90073: LD_INT 1
90075: PUSH
90076: LD_INT 1
90078: NEG
90079: PUSH
90080: EMPTY
90081: LIST
90082: LIST
90083: PUSH
90084: LD_INT 2
90086: PUSH
90087: LD_INT 1
90089: PUSH
90090: EMPTY
90091: LIST
90092: LIST
90093: PUSH
90094: LD_INT 2
90096: PUSH
90097: LD_INT 2
90099: PUSH
90100: EMPTY
90101: LIST
90102: LIST
90103: PUSH
90104: LD_INT 1
90106: PUSH
90107: LD_INT 2
90109: PUSH
90110: EMPTY
90111: LIST
90112: LIST
90113: PUSH
90114: LD_INT 0
90116: PUSH
90117: LD_INT 2
90119: PUSH
90120: EMPTY
90121: LIST
90122: LIST
90123: PUSH
90124: LD_INT 1
90126: NEG
90127: PUSH
90128: LD_INT 1
90130: PUSH
90131: EMPTY
90132: LIST
90133: LIST
90134: PUSH
90135: LD_INT 2
90137: NEG
90138: PUSH
90139: LD_INT 0
90141: PUSH
90142: EMPTY
90143: LIST
90144: LIST
90145: PUSH
90146: LD_INT 2
90148: NEG
90149: PUSH
90150: LD_INT 1
90152: NEG
90153: PUSH
90154: EMPTY
90155: LIST
90156: LIST
90157: PUSH
90158: LD_INT 1
90160: NEG
90161: PUSH
90162: LD_INT 3
90164: NEG
90165: PUSH
90166: EMPTY
90167: LIST
90168: LIST
90169: PUSH
90170: LD_INT 1
90172: PUSH
90173: LD_INT 2
90175: NEG
90176: PUSH
90177: EMPTY
90178: LIST
90179: LIST
90180: PUSH
90181: LD_INT 3
90183: PUSH
90184: LD_INT 2
90186: PUSH
90187: EMPTY
90188: LIST
90189: LIST
90190: PUSH
90191: LD_INT 2
90193: PUSH
90194: LD_INT 3
90196: PUSH
90197: EMPTY
90198: LIST
90199: LIST
90200: PUSH
90201: LD_INT 2
90203: NEG
90204: PUSH
90205: LD_INT 1
90207: PUSH
90208: EMPTY
90209: LIST
90210: LIST
90211: PUSH
90212: LD_INT 3
90214: NEG
90215: PUSH
90216: LD_INT 1
90218: NEG
90219: PUSH
90220: EMPTY
90221: LIST
90222: LIST
90223: PUSH
90224: EMPTY
90225: LIST
90226: LIST
90227: LIST
90228: LIST
90229: LIST
90230: LIST
90231: LIST
90232: LIST
90233: LIST
90234: LIST
90235: LIST
90236: LIST
90237: LIST
90238: LIST
90239: LIST
90240: LIST
90241: LIST
90242: LIST
90243: LIST
90244: LIST
90245: LIST
90246: LIST
90247: LIST
90248: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
90249: LD_ADDR_VAR 0 33
90253: PUSH
90254: LD_INT 0
90256: PUSH
90257: LD_INT 0
90259: PUSH
90260: EMPTY
90261: LIST
90262: LIST
90263: PUSH
90264: LD_INT 0
90266: PUSH
90267: LD_INT 1
90269: NEG
90270: PUSH
90271: EMPTY
90272: LIST
90273: LIST
90274: PUSH
90275: LD_INT 1
90277: PUSH
90278: LD_INT 0
90280: PUSH
90281: EMPTY
90282: LIST
90283: LIST
90284: PUSH
90285: LD_INT 1
90287: PUSH
90288: LD_INT 1
90290: PUSH
90291: EMPTY
90292: LIST
90293: LIST
90294: PUSH
90295: LD_INT 0
90297: PUSH
90298: LD_INT 1
90300: PUSH
90301: EMPTY
90302: LIST
90303: LIST
90304: PUSH
90305: LD_INT 1
90307: NEG
90308: PUSH
90309: LD_INT 0
90311: PUSH
90312: EMPTY
90313: LIST
90314: LIST
90315: PUSH
90316: LD_INT 1
90318: NEG
90319: PUSH
90320: LD_INT 1
90322: NEG
90323: PUSH
90324: EMPTY
90325: LIST
90326: LIST
90327: PUSH
90328: LD_INT 1
90330: NEG
90331: PUSH
90332: LD_INT 2
90334: NEG
90335: PUSH
90336: EMPTY
90337: LIST
90338: LIST
90339: PUSH
90340: LD_INT 1
90342: PUSH
90343: LD_INT 1
90345: NEG
90346: PUSH
90347: EMPTY
90348: LIST
90349: LIST
90350: PUSH
90351: LD_INT 2
90353: PUSH
90354: LD_INT 0
90356: PUSH
90357: EMPTY
90358: LIST
90359: LIST
90360: PUSH
90361: LD_INT 2
90363: PUSH
90364: LD_INT 1
90366: PUSH
90367: EMPTY
90368: LIST
90369: LIST
90370: PUSH
90371: LD_INT 1
90373: PUSH
90374: LD_INT 2
90376: PUSH
90377: EMPTY
90378: LIST
90379: LIST
90380: PUSH
90381: LD_INT 0
90383: PUSH
90384: LD_INT 2
90386: PUSH
90387: EMPTY
90388: LIST
90389: LIST
90390: PUSH
90391: LD_INT 1
90393: NEG
90394: PUSH
90395: LD_INT 1
90397: PUSH
90398: EMPTY
90399: LIST
90400: LIST
90401: PUSH
90402: LD_INT 2
90404: NEG
90405: PUSH
90406: LD_INT 0
90408: PUSH
90409: EMPTY
90410: LIST
90411: LIST
90412: PUSH
90413: LD_INT 2
90415: NEG
90416: PUSH
90417: LD_INT 1
90419: NEG
90420: PUSH
90421: EMPTY
90422: LIST
90423: LIST
90424: PUSH
90425: LD_INT 2
90427: NEG
90428: PUSH
90429: LD_INT 2
90431: NEG
90432: PUSH
90433: EMPTY
90434: LIST
90435: LIST
90436: PUSH
90437: LD_INT 2
90439: NEG
90440: PUSH
90441: LD_INT 3
90443: NEG
90444: PUSH
90445: EMPTY
90446: LIST
90447: LIST
90448: PUSH
90449: LD_INT 2
90451: PUSH
90452: LD_INT 1
90454: NEG
90455: PUSH
90456: EMPTY
90457: LIST
90458: LIST
90459: PUSH
90460: LD_INT 3
90462: PUSH
90463: LD_INT 1
90465: PUSH
90466: EMPTY
90467: LIST
90468: LIST
90469: PUSH
90470: LD_INT 1
90472: PUSH
90473: LD_INT 3
90475: PUSH
90476: EMPTY
90477: LIST
90478: LIST
90479: PUSH
90480: LD_INT 1
90482: NEG
90483: PUSH
90484: LD_INT 2
90486: PUSH
90487: EMPTY
90488: LIST
90489: LIST
90490: PUSH
90491: LD_INT 3
90493: NEG
90494: PUSH
90495: LD_INT 2
90497: NEG
90498: PUSH
90499: EMPTY
90500: LIST
90501: LIST
90502: PUSH
90503: EMPTY
90504: LIST
90505: LIST
90506: LIST
90507: LIST
90508: LIST
90509: LIST
90510: LIST
90511: LIST
90512: LIST
90513: LIST
90514: LIST
90515: LIST
90516: LIST
90517: LIST
90518: LIST
90519: LIST
90520: LIST
90521: LIST
90522: LIST
90523: LIST
90524: LIST
90525: LIST
90526: LIST
90527: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
90528: LD_ADDR_VAR 0 34
90532: PUSH
90533: LD_INT 0
90535: PUSH
90536: LD_INT 0
90538: PUSH
90539: EMPTY
90540: LIST
90541: LIST
90542: PUSH
90543: LD_INT 0
90545: PUSH
90546: LD_INT 1
90548: NEG
90549: PUSH
90550: EMPTY
90551: LIST
90552: LIST
90553: PUSH
90554: LD_INT 1
90556: PUSH
90557: LD_INT 0
90559: PUSH
90560: EMPTY
90561: LIST
90562: LIST
90563: PUSH
90564: LD_INT 1
90566: PUSH
90567: LD_INT 1
90569: PUSH
90570: EMPTY
90571: LIST
90572: LIST
90573: PUSH
90574: LD_INT 0
90576: PUSH
90577: LD_INT 1
90579: PUSH
90580: EMPTY
90581: LIST
90582: LIST
90583: PUSH
90584: LD_INT 1
90586: NEG
90587: PUSH
90588: LD_INT 0
90590: PUSH
90591: EMPTY
90592: LIST
90593: LIST
90594: PUSH
90595: LD_INT 1
90597: NEG
90598: PUSH
90599: LD_INT 1
90601: NEG
90602: PUSH
90603: EMPTY
90604: LIST
90605: LIST
90606: PUSH
90607: LD_INT 1
90609: NEG
90610: PUSH
90611: LD_INT 2
90613: NEG
90614: PUSH
90615: EMPTY
90616: LIST
90617: LIST
90618: PUSH
90619: LD_INT 0
90621: PUSH
90622: LD_INT 2
90624: NEG
90625: PUSH
90626: EMPTY
90627: LIST
90628: LIST
90629: PUSH
90630: LD_INT 1
90632: PUSH
90633: LD_INT 1
90635: NEG
90636: PUSH
90637: EMPTY
90638: LIST
90639: LIST
90640: PUSH
90641: LD_INT 2
90643: PUSH
90644: LD_INT 1
90646: PUSH
90647: EMPTY
90648: LIST
90649: LIST
90650: PUSH
90651: LD_INT 2
90653: PUSH
90654: LD_INT 2
90656: PUSH
90657: EMPTY
90658: LIST
90659: LIST
90660: PUSH
90661: LD_INT 1
90663: PUSH
90664: LD_INT 2
90666: PUSH
90667: EMPTY
90668: LIST
90669: LIST
90670: PUSH
90671: LD_INT 1
90673: NEG
90674: PUSH
90675: LD_INT 1
90677: PUSH
90678: EMPTY
90679: LIST
90680: LIST
90681: PUSH
90682: LD_INT 2
90684: NEG
90685: PUSH
90686: LD_INT 0
90688: PUSH
90689: EMPTY
90690: LIST
90691: LIST
90692: PUSH
90693: LD_INT 2
90695: NEG
90696: PUSH
90697: LD_INT 1
90699: NEG
90700: PUSH
90701: EMPTY
90702: LIST
90703: LIST
90704: PUSH
90705: LD_INT 2
90707: NEG
90708: PUSH
90709: LD_INT 2
90711: NEG
90712: PUSH
90713: EMPTY
90714: LIST
90715: LIST
90716: PUSH
90717: LD_INT 1
90719: NEG
90720: PUSH
90721: LD_INT 3
90723: NEG
90724: PUSH
90725: EMPTY
90726: LIST
90727: LIST
90728: PUSH
90729: LD_INT 1
90731: PUSH
90732: LD_INT 2
90734: NEG
90735: PUSH
90736: EMPTY
90737: LIST
90738: LIST
90739: PUSH
90740: LD_INT 3
90742: PUSH
90743: LD_INT 2
90745: PUSH
90746: EMPTY
90747: LIST
90748: LIST
90749: PUSH
90750: LD_INT 2
90752: PUSH
90753: LD_INT 3
90755: PUSH
90756: EMPTY
90757: LIST
90758: LIST
90759: PUSH
90760: LD_INT 2
90762: NEG
90763: PUSH
90764: LD_INT 1
90766: PUSH
90767: EMPTY
90768: LIST
90769: LIST
90770: PUSH
90771: LD_INT 3
90773: NEG
90774: PUSH
90775: LD_INT 1
90777: NEG
90778: PUSH
90779: EMPTY
90780: LIST
90781: LIST
90782: PUSH
90783: EMPTY
90784: LIST
90785: LIST
90786: LIST
90787: LIST
90788: LIST
90789: LIST
90790: LIST
90791: LIST
90792: LIST
90793: LIST
90794: LIST
90795: LIST
90796: LIST
90797: LIST
90798: LIST
90799: LIST
90800: LIST
90801: LIST
90802: LIST
90803: LIST
90804: LIST
90805: LIST
90806: LIST
90807: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
90808: LD_ADDR_VAR 0 35
90812: PUSH
90813: LD_INT 0
90815: PUSH
90816: LD_INT 0
90818: PUSH
90819: EMPTY
90820: LIST
90821: LIST
90822: PUSH
90823: LD_INT 0
90825: PUSH
90826: LD_INT 1
90828: NEG
90829: PUSH
90830: EMPTY
90831: LIST
90832: LIST
90833: PUSH
90834: LD_INT 1
90836: PUSH
90837: LD_INT 0
90839: PUSH
90840: EMPTY
90841: LIST
90842: LIST
90843: PUSH
90844: LD_INT 1
90846: PUSH
90847: LD_INT 1
90849: PUSH
90850: EMPTY
90851: LIST
90852: LIST
90853: PUSH
90854: LD_INT 0
90856: PUSH
90857: LD_INT 1
90859: PUSH
90860: EMPTY
90861: LIST
90862: LIST
90863: PUSH
90864: LD_INT 1
90866: NEG
90867: PUSH
90868: LD_INT 0
90870: PUSH
90871: EMPTY
90872: LIST
90873: LIST
90874: PUSH
90875: LD_INT 1
90877: NEG
90878: PUSH
90879: LD_INT 1
90881: NEG
90882: PUSH
90883: EMPTY
90884: LIST
90885: LIST
90886: PUSH
90887: LD_INT 2
90889: PUSH
90890: LD_INT 1
90892: PUSH
90893: EMPTY
90894: LIST
90895: LIST
90896: PUSH
90897: LD_INT 2
90899: NEG
90900: PUSH
90901: LD_INT 1
90903: NEG
90904: PUSH
90905: EMPTY
90906: LIST
90907: LIST
90908: PUSH
90909: EMPTY
90910: LIST
90911: LIST
90912: LIST
90913: LIST
90914: LIST
90915: LIST
90916: LIST
90917: LIST
90918: LIST
90919: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
90920: LD_ADDR_VAR 0 36
90924: PUSH
90925: LD_INT 0
90927: PUSH
90928: LD_INT 0
90930: PUSH
90931: EMPTY
90932: LIST
90933: LIST
90934: PUSH
90935: LD_INT 0
90937: PUSH
90938: LD_INT 1
90940: NEG
90941: PUSH
90942: EMPTY
90943: LIST
90944: LIST
90945: PUSH
90946: LD_INT 1
90948: PUSH
90949: LD_INT 0
90951: PUSH
90952: EMPTY
90953: LIST
90954: LIST
90955: PUSH
90956: LD_INT 1
90958: PUSH
90959: LD_INT 1
90961: PUSH
90962: EMPTY
90963: LIST
90964: LIST
90965: PUSH
90966: LD_INT 0
90968: PUSH
90969: LD_INT 1
90971: PUSH
90972: EMPTY
90973: LIST
90974: LIST
90975: PUSH
90976: LD_INT 1
90978: NEG
90979: PUSH
90980: LD_INT 0
90982: PUSH
90983: EMPTY
90984: LIST
90985: LIST
90986: PUSH
90987: LD_INT 1
90989: NEG
90990: PUSH
90991: LD_INT 1
90993: NEG
90994: PUSH
90995: EMPTY
90996: LIST
90997: LIST
90998: PUSH
90999: LD_INT 1
91001: NEG
91002: PUSH
91003: LD_INT 2
91005: NEG
91006: PUSH
91007: EMPTY
91008: LIST
91009: LIST
91010: PUSH
91011: LD_INT 1
91013: PUSH
91014: LD_INT 2
91016: PUSH
91017: EMPTY
91018: LIST
91019: LIST
91020: PUSH
91021: EMPTY
91022: LIST
91023: LIST
91024: LIST
91025: LIST
91026: LIST
91027: LIST
91028: LIST
91029: LIST
91030: LIST
91031: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
91032: LD_ADDR_VAR 0 37
91036: PUSH
91037: LD_INT 0
91039: PUSH
91040: LD_INT 0
91042: PUSH
91043: EMPTY
91044: LIST
91045: LIST
91046: PUSH
91047: LD_INT 0
91049: PUSH
91050: LD_INT 1
91052: NEG
91053: PUSH
91054: EMPTY
91055: LIST
91056: LIST
91057: PUSH
91058: LD_INT 1
91060: PUSH
91061: LD_INT 0
91063: PUSH
91064: EMPTY
91065: LIST
91066: LIST
91067: PUSH
91068: LD_INT 1
91070: PUSH
91071: LD_INT 1
91073: PUSH
91074: EMPTY
91075: LIST
91076: LIST
91077: PUSH
91078: LD_INT 0
91080: PUSH
91081: LD_INT 1
91083: PUSH
91084: EMPTY
91085: LIST
91086: LIST
91087: PUSH
91088: LD_INT 1
91090: NEG
91091: PUSH
91092: LD_INT 0
91094: PUSH
91095: EMPTY
91096: LIST
91097: LIST
91098: PUSH
91099: LD_INT 1
91101: NEG
91102: PUSH
91103: LD_INT 1
91105: NEG
91106: PUSH
91107: EMPTY
91108: LIST
91109: LIST
91110: PUSH
91111: LD_INT 1
91113: PUSH
91114: LD_INT 1
91116: NEG
91117: PUSH
91118: EMPTY
91119: LIST
91120: LIST
91121: PUSH
91122: LD_INT 1
91124: NEG
91125: PUSH
91126: LD_INT 1
91128: PUSH
91129: EMPTY
91130: LIST
91131: LIST
91132: PUSH
91133: EMPTY
91134: LIST
91135: LIST
91136: LIST
91137: LIST
91138: LIST
91139: LIST
91140: LIST
91141: LIST
91142: LIST
91143: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
91144: LD_ADDR_VAR 0 38
91148: PUSH
91149: LD_INT 0
91151: PUSH
91152: LD_INT 0
91154: PUSH
91155: EMPTY
91156: LIST
91157: LIST
91158: PUSH
91159: LD_INT 0
91161: PUSH
91162: LD_INT 1
91164: NEG
91165: PUSH
91166: EMPTY
91167: LIST
91168: LIST
91169: PUSH
91170: LD_INT 1
91172: PUSH
91173: LD_INT 0
91175: PUSH
91176: EMPTY
91177: LIST
91178: LIST
91179: PUSH
91180: LD_INT 1
91182: PUSH
91183: LD_INT 1
91185: PUSH
91186: EMPTY
91187: LIST
91188: LIST
91189: PUSH
91190: LD_INT 0
91192: PUSH
91193: LD_INT 1
91195: PUSH
91196: EMPTY
91197: LIST
91198: LIST
91199: PUSH
91200: LD_INT 1
91202: NEG
91203: PUSH
91204: LD_INT 0
91206: PUSH
91207: EMPTY
91208: LIST
91209: LIST
91210: PUSH
91211: LD_INT 1
91213: NEG
91214: PUSH
91215: LD_INT 1
91217: NEG
91218: PUSH
91219: EMPTY
91220: LIST
91221: LIST
91222: PUSH
91223: LD_INT 2
91225: PUSH
91226: LD_INT 1
91228: PUSH
91229: EMPTY
91230: LIST
91231: LIST
91232: PUSH
91233: LD_INT 2
91235: NEG
91236: PUSH
91237: LD_INT 1
91239: NEG
91240: PUSH
91241: EMPTY
91242: LIST
91243: LIST
91244: PUSH
91245: EMPTY
91246: LIST
91247: LIST
91248: LIST
91249: LIST
91250: LIST
91251: LIST
91252: LIST
91253: LIST
91254: LIST
91255: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
91256: LD_ADDR_VAR 0 39
91260: PUSH
91261: LD_INT 0
91263: PUSH
91264: LD_INT 0
91266: PUSH
91267: EMPTY
91268: LIST
91269: LIST
91270: PUSH
91271: LD_INT 0
91273: PUSH
91274: LD_INT 1
91276: NEG
91277: PUSH
91278: EMPTY
91279: LIST
91280: LIST
91281: PUSH
91282: LD_INT 1
91284: PUSH
91285: LD_INT 0
91287: PUSH
91288: EMPTY
91289: LIST
91290: LIST
91291: PUSH
91292: LD_INT 1
91294: PUSH
91295: LD_INT 1
91297: PUSH
91298: EMPTY
91299: LIST
91300: LIST
91301: PUSH
91302: LD_INT 0
91304: PUSH
91305: LD_INT 1
91307: PUSH
91308: EMPTY
91309: LIST
91310: LIST
91311: PUSH
91312: LD_INT 1
91314: NEG
91315: PUSH
91316: LD_INT 0
91318: PUSH
91319: EMPTY
91320: LIST
91321: LIST
91322: PUSH
91323: LD_INT 1
91325: NEG
91326: PUSH
91327: LD_INT 1
91329: NEG
91330: PUSH
91331: EMPTY
91332: LIST
91333: LIST
91334: PUSH
91335: LD_INT 1
91337: NEG
91338: PUSH
91339: LD_INT 2
91341: NEG
91342: PUSH
91343: EMPTY
91344: LIST
91345: LIST
91346: PUSH
91347: LD_INT 1
91349: PUSH
91350: LD_INT 2
91352: PUSH
91353: EMPTY
91354: LIST
91355: LIST
91356: PUSH
91357: EMPTY
91358: LIST
91359: LIST
91360: LIST
91361: LIST
91362: LIST
91363: LIST
91364: LIST
91365: LIST
91366: LIST
91367: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
91368: LD_ADDR_VAR 0 40
91372: PUSH
91373: LD_INT 0
91375: PUSH
91376: LD_INT 0
91378: PUSH
91379: EMPTY
91380: LIST
91381: LIST
91382: PUSH
91383: LD_INT 0
91385: PUSH
91386: LD_INT 1
91388: NEG
91389: PUSH
91390: EMPTY
91391: LIST
91392: LIST
91393: PUSH
91394: LD_INT 1
91396: PUSH
91397: LD_INT 0
91399: PUSH
91400: EMPTY
91401: LIST
91402: LIST
91403: PUSH
91404: LD_INT 1
91406: PUSH
91407: LD_INT 1
91409: PUSH
91410: EMPTY
91411: LIST
91412: LIST
91413: PUSH
91414: LD_INT 0
91416: PUSH
91417: LD_INT 1
91419: PUSH
91420: EMPTY
91421: LIST
91422: LIST
91423: PUSH
91424: LD_INT 1
91426: NEG
91427: PUSH
91428: LD_INT 0
91430: PUSH
91431: EMPTY
91432: LIST
91433: LIST
91434: PUSH
91435: LD_INT 1
91437: NEG
91438: PUSH
91439: LD_INT 1
91441: NEG
91442: PUSH
91443: EMPTY
91444: LIST
91445: LIST
91446: PUSH
91447: LD_INT 1
91449: PUSH
91450: LD_INT 1
91452: NEG
91453: PUSH
91454: EMPTY
91455: LIST
91456: LIST
91457: PUSH
91458: LD_INT 1
91460: NEG
91461: PUSH
91462: LD_INT 1
91464: PUSH
91465: EMPTY
91466: LIST
91467: LIST
91468: PUSH
91469: EMPTY
91470: LIST
91471: LIST
91472: LIST
91473: LIST
91474: LIST
91475: LIST
91476: LIST
91477: LIST
91478: LIST
91479: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91480: LD_ADDR_VAR 0 41
91484: PUSH
91485: LD_INT 0
91487: PUSH
91488: LD_INT 0
91490: PUSH
91491: EMPTY
91492: LIST
91493: LIST
91494: PUSH
91495: LD_INT 0
91497: PUSH
91498: LD_INT 1
91500: NEG
91501: PUSH
91502: EMPTY
91503: LIST
91504: LIST
91505: PUSH
91506: LD_INT 1
91508: PUSH
91509: LD_INT 0
91511: PUSH
91512: EMPTY
91513: LIST
91514: LIST
91515: PUSH
91516: LD_INT 1
91518: PUSH
91519: LD_INT 1
91521: PUSH
91522: EMPTY
91523: LIST
91524: LIST
91525: PUSH
91526: LD_INT 0
91528: PUSH
91529: LD_INT 1
91531: PUSH
91532: EMPTY
91533: LIST
91534: LIST
91535: PUSH
91536: LD_INT 1
91538: NEG
91539: PUSH
91540: LD_INT 0
91542: PUSH
91543: EMPTY
91544: LIST
91545: LIST
91546: PUSH
91547: LD_INT 1
91549: NEG
91550: PUSH
91551: LD_INT 1
91553: NEG
91554: PUSH
91555: EMPTY
91556: LIST
91557: LIST
91558: PUSH
91559: LD_INT 1
91561: NEG
91562: PUSH
91563: LD_INT 2
91565: NEG
91566: PUSH
91567: EMPTY
91568: LIST
91569: LIST
91570: PUSH
91571: LD_INT 1
91573: PUSH
91574: LD_INT 1
91576: NEG
91577: PUSH
91578: EMPTY
91579: LIST
91580: LIST
91581: PUSH
91582: LD_INT 2
91584: PUSH
91585: LD_INT 0
91587: PUSH
91588: EMPTY
91589: LIST
91590: LIST
91591: PUSH
91592: LD_INT 2
91594: PUSH
91595: LD_INT 1
91597: PUSH
91598: EMPTY
91599: LIST
91600: LIST
91601: PUSH
91602: LD_INT 2
91604: PUSH
91605: LD_INT 2
91607: PUSH
91608: EMPTY
91609: LIST
91610: LIST
91611: PUSH
91612: LD_INT 1
91614: PUSH
91615: LD_INT 2
91617: PUSH
91618: EMPTY
91619: LIST
91620: LIST
91621: PUSH
91622: LD_INT 1
91624: NEG
91625: PUSH
91626: LD_INT 1
91628: PUSH
91629: EMPTY
91630: LIST
91631: LIST
91632: PUSH
91633: LD_INT 2
91635: NEG
91636: PUSH
91637: LD_INT 0
91639: PUSH
91640: EMPTY
91641: LIST
91642: LIST
91643: PUSH
91644: LD_INT 2
91646: NEG
91647: PUSH
91648: LD_INT 1
91650: NEG
91651: PUSH
91652: EMPTY
91653: LIST
91654: LIST
91655: PUSH
91656: LD_INT 2
91658: NEG
91659: PUSH
91660: LD_INT 2
91662: NEG
91663: PUSH
91664: EMPTY
91665: LIST
91666: LIST
91667: PUSH
91668: LD_INT 2
91670: NEG
91671: PUSH
91672: LD_INT 3
91674: NEG
91675: PUSH
91676: EMPTY
91677: LIST
91678: LIST
91679: PUSH
91680: LD_INT 2
91682: PUSH
91683: LD_INT 1
91685: NEG
91686: PUSH
91687: EMPTY
91688: LIST
91689: LIST
91690: PUSH
91691: LD_INT 3
91693: PUSH
91694: LD_INT 0
91696: PUSH
91697: EMPTY
91698: LIST
91699: LIST
91700: PUSH
91701: LD_INT 3
91703: PUSH
91704: LD_INT 1
91706: PUSH
91707: EMPTY
91708: LIST
91709: LIST
91710: PUSH
91711: LD_INT 3
91713: PUSH
91714: LD_INT 2
91716: PUSH
91717: EMPTY
91718: LIST
91719: LIST
91720: PUSH
91721: LD_INT 3
91723: PUSH
91724: LD_INT 3
91726: PUSH
91727: EMPTY
91728: LIST
91729: LIST
91730: PUSH
91731: LD_INT 2
91733: PUSH
91734: LD_INT 3
91736: PUSH
91737: EMPTY
91738: LIST
91739: LIST
91740: PUSH
91741: LD_INT 2
91743: NEG
91744: PUSH
91745: LD_INT 1
91747: PUSH
91748: EMPTY
91749: LIST
91750: LIST
91751: PUSH
91752: LD_INT 3
91754: NEG
91755: PUSH
91756: LD_INT 0
91758: PUSH
91759: EMPTY
91760: LIST
91761: LIST
91762: PUSH
91763: LD_INT 3
91765: NEG
91766: PUSH
91767: LD_INT 1
91769: NEG
91770: PUSH
91771: EMPTY
91772: LIST
91773: LIST
91774: PUSH
91775: LD_INT 3
91777: NEG
91778: PUSH
91779: LD_INT 2
91781: NEG
91782: PUSH
91783: EMPTY
91784: LIST
91785: LIST
91786: PUSH
91787: LD_INT 3
91789: NEG
91790: PUSH
91791: LD_INT 3
91793: NEG
91794: PUSH
91795: EMPTY
91796: LIST
91797: LIST
91798: PUSH
91799: EMPTY
91800: LIST
91801: LIST
91802: LIST
91803: LIST
91804: LIST
91805: LIST
91806: LIST
91807: LIST
91808: LIST
91809: LIST
91810: LIST
91811: LIST
91812: LIST
91813: LIST
91814: LIST
91815: LIST
91816: LIST
91817: LIST
91818: LIST
91819: LIST
91820: LIST
91821: LIST
91822: LIST
91823: LIST
91824: LIST
91825: LIST
91826: LIST
91827: LIST
91828: LIST
91829: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91830: LD_ADDR_VAR 0 42
91834: PUSH
91835: LD_INT 0
91837: PUSH
91838: LD_INT 0
91840: PUSH
91841: EMPTY
91842: LIST
91843: LIST
91844: PUSH
91845: LD_INT 0
91847: PUSH
91848: LD_INT 1
91850: NEG
91851: PUSH
91852: EMPTY
91853: LIST
91854: LIST
91855: PUSH
91856: LD_INT 1
91858: PUSH
91859: LD_INT 0
91861: PUSH
91862: EMPTY
91863: LIST
91864: LIST
91865: PUSH
91866: LD_INT 1
91868: PUSH
91869: LD_INT 1
91871: PUSH
91872: EMPTY
91873: LIST
91874: LIST
91875: PUSH
91876: LD_INT 0
91878: PUSH
91879: LD_INT 1
91881: PUSH
91882: EMPTY
91883: LIST
91884: LIST
91885: PUSH
91886: LD_INT 1
91888: NEG
91889: PUSH
91890: LD_INT 0
91892: PUSH
91893: EMPTY
91894: LIST
91895: LIST
91896: PUSH
91897: LD_INT 1
91899: NEG
91900: PUSH
91901: LD_INT 1
91903: NEG
91904: PUSH
91905: EMPTY
91906: LIST
91907: LIST
91908: PUSH
91909: LD_INT 1
91911: NEG
91912: PUSH
91913: LD_INT 2
91915: NEG
91916: PUSH
91917: EMPTY
91918: LIST
91919: LIST
91920: PUSH
91921: LD_INT 0
91923: PUSH
91924: LD_INT 2
91926: NEG
91927: PUSH
91928: EMPTY
91929: LIST
91930: LIST
91931: PUSH
91932: LD_INT 1
91934: PUSH
91935: LD_INT 1
91937: NEG
91938: PUSH
91939: EMPTY
91940: LIST
91941: LIST
91942: PUSH
91943: LD_INT 2
91945: PUSH
91946: LD_INT 1
91948: PUSH
91949: EMPTY
91950: LIST
91951: LIST
91952: PUSH
91953: LD_INT 2
91955: PUSH
91956: LD_INT 2
91958: PUSH
91959: EMPTY
91960: LIST
91961: LIST
91962: PUSH
91963: LD_INT 1
91965: PUSH
91966: LD_INT 2
91968: PUSH
91969: EMPTY
91970: LIST
91971: LIST
91972: PUSH
91973: LD_INT 0
91975: PUSH
91976: LD_INT 2
91978: PUSH
91979: EMPTY
91980: LIST
91981: LIST
91982: PUSH
91983: LD_INT 1
91985: NEG
91986: PUSH
91987: LD_INT 1
91989: PUSH
91990: EMPTY
91991: LIST
91992: LIST
91993: PUSH
91994: LD_INT 2
91996: NEG
91997: PUSH
91998: LD_INT 1
92000: NEG
92001: PUSH
92002: EMPTY
92003: LIST
92004: LIST
92005: PUSH
92006: LD_INT 2
92008: NEG
92009: PUSH
92010: LD_INT 2
92012: NEG
92013: PUSH
92014: EMPTY
92015: LIST
92016: LIST
92017: PUSH
92018: LD_INT 2
92020: NEG
92021: PUSH
92022: LD_INT 3
92024: NEG
92025: PUSH
92026: EMPTY
92027: LIST
92028: LIST
92029: PUSH
92030: LD_INT 1
92032: NEG
92033: PUSH
92034: LD_INT 3
92036: NEG
92037: PUSH
92038: EMPTY
92039: LIST
92040: LIST
92041: PUSH
92042: LD_INT 0
92044: PUSH
92045: LD_INT 3
92047: NEG
92048: PUSH
92049: EMPTY
92050: LIST
92051: LIST
92052: PUSH
92053: LD_INT 1
92055: PUSH
92056: LD_INT 2
92058: NEG
92059: PUSH
92060: EMPTY
92061: LIST
92062: LIST
92063: PUSH
92064: LD_INT 3
92066: PUSH
92067: LD_INT 2
92069: PUSH
92070: EMPTY
92071: LIST
92072: LIST
92073: PUSH
92074: LD_INT 3
92076: PUSH
92077: LD_INT 3
92079: PUSH
92080: EMPTY
92081: LIST
92082: LIST
92083: PUSH
92084: LD_INT 2
92086: PUSH
92087: LD_INT 3
92089: PUSH
92090: EMPTY
92091: LIST
92092: LIST
92093: PUSH
92094: LD_INT 1
92096: PUSH
92097: LD_INT 3
92099: PUSH
92100: EMPTY
92101: LIST
92102: LIST
92103: PUSH
92104: LD_INT 0
92106: PUSH
92107: LD_INT 3
92109: PUSH
92110: EMPTY
92111: LIST
92112: LIST
92113: PUSH
92114: LD_INT 1
92116: NEG
92117: PUSH
92118: LD_INT 2
92120: PUSH
92121: EMPTY
92122: LIST
92123: LIST
92124: PUSH
92125: LD_INT 3
92127: NEG
92128: PUSH
92129: LD_INT 2
92131: NEG
92132: PUSH
92133: EMPTY
92134: LIST
92135: LIST
92136: PUSH
92137: LD_INT 3
92139: NEG
92140: PUSH
92141: LD_INT 3
92143: NEG
92144: PUSH
92145: EMPTY
92146: LIST
92147: LIST
92148: PUSH
92149: EMPTY
92150: LIST
92151: LIST
92152: LIST
92153: LIST
92154: LIST
92155: LIST
92156: LIST
92157: LIST
92158: LIST
92159: LIST
92160: LIST
92161: LIST
92162: LIST
92163: LIST
92164: LIST
92165: LIST
92166: LIST
92167: LIST
92168: LIST
92169: LIST
92170: LIST
92171: LIST
92172: LIST
92173: LIST
92174: LIST
92175: LIST
92176: LIST
92177: LIST
92178: LIST
92179: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92180: LD_ADDR_VAR 0 43
92184: PUSH
92185: LD_INT 0
92187: PUSH
92188: LD_INT 0
92190: PUSH
92191: EMPTY
92192: LIST
92193: LIST
92194: PUSH
92195: LD_INT 0
92197: PUSH
92198: LD_INT 1
92200: NEG
92201: PUSH
92202: EMPTY
92203: LIST
92204: LIST
92205: PUSH
92206: LD_INT 1
92208: PUSH
92209: LD_INT 0
92211: PUSH
92212: EMPTY
92213: LIST
92214: LIST
92215: PUSH
92216: LD_INT 1
92218: PUSH
92219: LD_INT 1
92221: PUSH
92222: EMPTY
92223: LIST
92224: LIST
92225: PUSH
92226: LD_INT 0
92228: PUSH
92229: LD_INT 1
92231: PUSH
92232: EMPTY
92233: LIST
92234: LIST
92235: PUSH
92236: LD_INT 1
92238: NEG
92239: PUSH
92240: LD_INT 0
92242: PUSH
92243: EMPTY
92244: LIST
92245: LIST
92246: PUSH
92247: LD_INT 1
92249: NEG
92250: PUSH
92251: LD_INT 1
92253: NEG
92254: PUSH
92255: EMPTY
92256: LIST
92257: LIST
92258: PUSH
92259: LD_INT 1
92261: NEG
92262: PUSH
92263: LD_INT 2
92265: NEG
92266: PUSH
92267: EMPTY
92268: LIST
92269: LIST
92270: PUSH
92271: LD_INT 0
92273: PUSH
92274: LD_INT 2
92276: NEG
92277: PUSH
92278: EMPTY
92279: LIST
92280: LIST
92281: PUSH
92282: LD_INT 1
92284: PUSH
92285: LD_INT 1
92287: NEG
92288: PUSH
92289: EMPTY
92290: LIST
92291: LIST
92292: PUSH
92293: LD_INT 2
92295: PUSH
92296: LD_INT 0
92298: PUSH
92299: EMPTY
92300: LIST
92301: LIST
92302: PUSH
92303: LD_INT 2
92305: PUSH
92306: LD_INT 1
92308: PUSH
92309: EMPTY
92310: LIST
92311: LIST
92312: PUSH
92313: LD_INT 1
92315: PUSH
92316: LD_INT 2
92318: PUSH
92319: EMPTY
92320: LIST
92321: LIST
92322: PUSH
92323: LD_INT 0
92325: PUSH
92326: LD_INT 2
92328: PUSH
92329: EMPTY
92330: LIST
92331: LIST
92332: PUSH
92333: LD_INT 1
92335: NEG
92336: PUSH
92337: LD_INT 1
92339: PUSH
92340: EMPTY
92341: LIST
92342: LIST
92343: PUSH
92344: LD_INT 2
92346: NEG
92347: PUSH
92348: LD_INT 0
92350: PUSH
92351: EMPTY
92352: LIST
92353: LIST
92354: PUSH
92355: LD_INT 2
92357: NEG
92358: PUSH
92359: LD_INT 1
92361: NEG
92362: PUSH
92363: EMPTY
92364: LIST
92365: LIST
92366: PUSH
92367: LD_INT 1
92369: NEG
92370: PUSH
92371: LD_INT 3
92373: NEG
92374: PUSH
92375: EMPTY
92376: LIST
92377: LIST
92378: PUSH
92379: LD_INT 0
92381: PUSH
92382: LD_INT 3
92384: NEG
92385: PUSH
92386: EMPTY
92387: LIST
92388: LIST
92389: PUSH
92390: LD_INT 1
92392: PUSH
92393: LD_INT 2
92395: NEG
92396: PUSH
92397: EMPTY
92398: LIST
92399: LIST
92400: PUSH
92401: LD_INT 2
92403: PUSH
92404: LD_INT 1
92406: NEG
92407: PUSH
92408: EMPTY
92409: LIST
92410: LIST
92411: PUSH
92412: LD_INT 3
92414: PUSH
92415: LD_INT 0
92417: PUSH
92418: EMPTY
92419: LIST
92420: LIST
92421: PUSH
92422: LD_INT 3
92424: PUSH
92425: LD_INT 1
92427: PUSH
92428: EMPTY
92429: LIST
92430: LIST
92431: PUSH
92432: LD_INT 1
92434: PUSH
92435: LD_INT 3
92437: PUSH
92438: EMPTY
92439: LIST
92440: LIST
92441: PUSH
92442: LD_INT 0
92444: PUSH
92445: LD_INT 3
92447: PUSH
92448: EMPTY
92449: LIST
92450: LIST
92451: PUSH
92452: LD_INT 1
92454: NEG
92455: PUSH
92456: LD_INT 2
92458: PUSH
92459: EMPTY
92460: LIST
92461: LIST
92462: PUSH
92463: LD_INT 2
92465: NEG
92466: PUSH
92467: LD_INT 1
92469: PUSH
92470: EMPTY
92471: LIST
92472: LIST
92473: PUSH
92474: LD_INT 3
92476: NEG
92477: PUSH
92478: LD_INT 0
92480: PUSH
92481: EMPTY
92482: LIST
92483: LIST
92484: PUSH
92485: LD_INT 3
92487: NEG
92488: PUSH
92489: LD_INT 1
92491: NEG
92492: PUSH
92493: EMPTY
92494: LIST
92495: LIST
92496: PUSH
92497: EMPTY
92498: LIST
92499: LIST
92500: LIST
92501: LIST
92502: LIST
92503: LIST
92504: LIST
92505: LIST
92506: LIST
92507: LIST
92508: LIST
92509: LIST
92510: LIST
92511: LIST
92512: LIST
92513: LIST
92514: LIST
92515: LIST
92516: LIST
92517: LIST
92518: LIST
92519: LIST
92520: LIST
92521: LIST
92522: LIST
92523: LIST
92524: LIST
92525: LIST
92526: LIST
92527: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92528: LD_ADDR_VAR 0 44
92532: PUSH
92533: LD_INT 0
92535: PUSH
92536: LD_INT 0
92538: PUSH
92539: EMPTY
92540: LIST
92541: LIST
92542: PUSH
92543: LD_INT 0
92545: PUSH
92546: LD_INT 1
92548: NEG
92549: PUSH
92550: EMPTY
92551: LIST
92552: LIST
92553: PUSH
92554: LD_INT 1
92556: PUSH
92557: LD_INT 0
92559: PUSH
92560: EMPTY
92561: LIST
92562: LIST
92563: PUSH
92564: LD_INT 1
92566: PUSH
92567: LD_INT 1
92569: PUSH
92570: EMPTY
92571: LIST
92572: LIST
92573: PUSH
92574: LD_INT 0
92576: PUSH
92577: LD_INT 1
92579: PUSH
92580: EMPTY
92581: LIST
92582: LIST
92583: PUSH
92584: LD_INT 1
92586: NEG
92587: PUSH
92588: LD_INT 0
92590: PUSH
92591: EMPTY
92592: LIST
92593: LIST
92594: PUSH
92595: LD_INT 1
92597: NEG
92598: PUSH
92599: LD_INT 1
92601: NEG
92602: PUSH
92603: EMPTY
92604: LIST
92605: LIST
92606: PUSH
92607: LD_INT 1
92609: NEG
92610: PUSH
92611: LD_INT 2
92613: NEG
92614: PUSH
92615: EMPTY
92616: LIST
92617: LIST
92618: PUSH
92619: LD_INT 1
92621: PUSH
92622: LD_INT 1
92624: NEG
92625: PUSH
92626: EMPTY
92627: LIST
92628: LIST
92629: PUSH
92630: LD_INT 2
92632: PUSH
92633: LD_INT 0
92635: PUSH
92636: EMPTY
92637: LIST
92638: LIST
92639: PUSH
92640: LD_INT 2
92642: PUSH
92643: LD_INT 1
92645: PUSH
92646: EMPTY
92647: LIST
92648: LIST
92649: PUSH
92650: LD_INT 2
92652: PUSH
92653: LD_INT 2
92655: PUSH
92656: EMPTY
92657: LIST
92658: LIST
92659: PUSH
92660: LD_INT 1
92662: PUSH
92663: LD_INT 2
92665: PUSH
92666: EMPTY
92667: LIST
92668: LIST
92669: PUSH
92670: LD_INT 1
92672: NEG
92673: PUSH
92674: LD_INT 1
92676: PUSH
92677: EMPTY
92678: LIST
92679: LIST
92680: PUSH
92681: LD_INT 2
92683: NEG
92684: PUSH
92685: LD_INT 0
92687: PUSH
92688: EMPTY
92689: LIST
92690: LIST
92691: PUSH
92692: LD_INT 2
92694: NEG
92695: PUSH
92696: LD_INT 1
92698: NEG
92699: PUSH
92700: EMPTY
92701: LIST
92702: LIST
92703: PUSH
92704: LD_INT 2
92706: NEG
92707: PUSH
92708: LD_INT 2
92710: NEG
92711: PUSH
92712: EMPTY
92713: LIST
92714: LIST
92715: PUSH
92716: LD_INT 2
92718: NEG
92719: PUSH
92720: LD_INT 3
92722: NEG
92723: PUSH
92724: EMPTY
92725: LIST
92726: LIST
92727: PUSH
92728: LD_INT 2
92730: PUSH
92731: LD_INT 1
92733: NEG
92734: PUSH
92735: EMPTY
92736: LIST
92737: LIST
92738: PUSH
92739: LD_INT 3
92741: PUSH
92742: LD_INT 0
92744: PUSH
92745: EMPTY
92746: LIST
92747: LIST
92748: PUSH
92749: LD_INT 3
92751: PUSH
92752: LD_INT 1
92754: PUSH
92755: EMPTY
92756: LIST
92757: LIST
92758: PUSH
92759: LD_INT 3
92761: PUSH
92762: LD_INT 2
92764: PUSH
92765: EMPTY
92766: LIST
92767: LIST
92768: PUSH
92769: LD_INT 3
92771: PUSH
92772: LD_INT 3
92774: PUSH
92775: EMPTY
92776: LIST
92777: LIST
92778: PUSH
92779: LD_INT 2
92781: PUSH
92782: LD_INT 3
92784: PUSH
92785: EMPTY
92786: LIST
92787: LIST
92788: PUSH
92789: LD_INT 2
92791: NEG
92792: PUSH
92793: LD_INT 1
92795: PUSH
92796: EMPTY
92797: LIST
92798: LIST
92799: PUSH
92800: LD_INT 3
92802: NEG
92803: PUSH
92804: LD_INT 0
92806: PUSH
92807: EMPTY
92808: LIST
92809: LIST
92810: PUSH
92811: LD_INT 3
92813: NEG
92814: PUSH
92815: LD_INT 1
92817: NEG
92818: PUSH
92819: EMPTY
92820: LIST
92821: LIST
92822: PUSH
92823: LD_INT 3
92825: NEG
92826: PUSH
92827: LD_INT 2
92829: NEG
92830: PUSH
92831: EMPTY
92832: LIST
92833: LIST
92834: PUSH
92835: LD_INT 3
92837: NEG
92838: PUSH
92839: LD_INT 3
92841: NEG
92842: PUSH
92843: EMPTY
92844: LIST
92845: LIST
92846: PUSH
92847: EMPTY
92848: LIST
92849: LIST
92850: LIST
92851: LIST
92852: LIST
92853: LIST
92854: LIST
92855: LIST
92856: LIST
92857: LIST
92858: LIST
92859: LIST
92860: LIST
92861: LIST
92862: LIST
92863: LIST
92864: LIST
92865: LIST
92866: LIST
92867: LIST
92868: LIST
92869: LIST
92870: LIST
92871: LIST
92872: LIST
92873: LIST
92874: LIST
92875: LIST
92876: LIST
92877: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92878: LD_ADDR_VAR 0 45
92882: PUSH
92883: LD_INT 0
92885: PUSH
92886: LD_INT 0
92888: PUSH
92889: EMPTY
92890: LIST
92891: LIST
92892: PUSH
92893: LD_INT 0
92895: PUSH
92896: LD_INT 1
92898: NEG
92899: PUSH
92900: EMPTY
92901: LIST
92902: LIST
92903: PUSH
92904: LD_INT 1
92906: PUSH
92907: LD_INT 0
92909: PUSH
92910: EMPTY
92911: LIST
92912: LIST
92913: PUSH
92914: LD_INT 1
92916: PUSH
92917: LD_INT 1
92919: PUSH
92920: EMPTY
92921: LIST
92922: LIST
92923: PUSH
92924: LD_INT 0
92926: PUSH
92927: LD_INT 1
92929: PUSH
92930: EMPTY
92931: LIST
92932: LIST
92933: PUSH
92934: LD_INT 1
92936: NEG
92937: PUSH
92938: LD_INT 0
92940: PUSH
92941: EMPTY
92942: LIST
92943: LIST
92944: PUSH
92945: LD_INT 1
92947: NEG
92948: PUSH
92949: LD_INT 1
92951: NEG
92952: PUSH
92953: EMPTY
92954: LIST
92955: LIST
92956: PUSH
92957: LD_INT 1
92959: NEG
92960: PUSH
92961: LD_INT 2
92963: NEG
92964: PUSH
92965: EMPTY
92966: LIST
92967: LIST
92968: PUSH
92969: LD_INT 0
92971: PUSH
92972: LD_INT 2
92974: NEG
92975: PUSH
92976: EMPTY
92977: LIST
92978: LIST
92979: PUSH
92980: LD_INT 1
92982: PUSH
92983: LD_INT 1
92985: NEG
92986: PUSH
92987: EMPTY
92988: LIST
92989: LIST
92990: PUSH
92991: LD_INT 2
92993: PUSH
92994: LD_INT 1
92996: PUSH
92997: EMPTY
92998: LIST
92999: LIST
93000: PUSH
93001: LD_INT 2
93003: PUSH
93004: LD_INT 2
93006: PUSH
93007: EMPTY
93008: LIST
93009: LIST
93010: PUSH
93011: LD_INT 1
93013: PUSH
93014: LD_INT 2
93016: PUSH
93017: EMPTY
93018: LIST
93019: LIST
93020: PUSH
93021: LD_INT 0
93023: PUSH
93024: LD_INT 2
93026: PUSH
93027: EMPTY
93028: LIST
93029: LIST
93030: PUSH
93031: LD_INT 1
93033: NEG
93034: PUSH
93035: LD_INT 1
93037: PUSH
93038: EMPTY
93039: LIST
93040: LIST
93041: PUSH
93042: LD_INT 2
93044: NEG
93045: PUSH
93046: LD_INT 1
93048: NEG
93049: PUSH
93050: EMPTY
93051: LIST
93052: LIST
93053: PUSH
93054: LD_INT 2
93056: NEG
93057: PUSH
93058: LD_INT 2
93060: NEG
93061: PUSH
93062: EMPTY
93063: LIST
93064: LIST
93065: PUSH
93066: LD_INT 2
93068: NEG
93069: PUSH
93070: LD_INT 3
93072: NEG
93073: PUSH
93074: EMPTY
93075: LIST
93076: LIST
93077: PUSH
93078: LD_INT 1
93080: NEG
93081: PUSH
93082: LD_INT 3
93084: NEG
93085: PUSH
93086: EMPTY
93087: LIST
93088: LIST
93089: PUSH
93090: LD_INT 0
93092: PUSH
93093: LD_INT 3
93095: NEG
93096: PUSH
93097: EMPTY
93098: LIST
93099: LIST
93100: PUSH
93101: LD_INT 1
93103: PUSH
93104: LD_INT 2
93106: NEG
93107: PUSH
93108: EMPTY
93109: LIST
93110: LIST
93111: PUSH
93112: LD_INT 3
93114: PUSH
93115: LD_INT 2
93117: PUSH
93118: EMPTY
93119: LIST
93120: LIST
93121: PUSH
93122: LD_INT 3
93124: PUSH
93125: LD_INT 3
93127: PUSH
93128: EMPTY
93129: LIST
93130: LIST
93131: PUSH
93132: LD_INT 2
93134: PUSH
93135: LD_INT 3
93137: PUSH
93138: EMPTY
93139: LIST
93140: LIST
93141: PUSH
93142: LD_INT 1
93144: PUSH
93145: LD_INT 3
93147: PUSH
93148: EMPTY
93149: LIST
93150: LIST
93151: PUSH
93152: LD_INT 0
93154: PUSH
93155: LD_INT 3
93157: PUSH
93158: EMPTY
93159: LIST
93160: LIST
93161: PUSH
93162: LD_INT 1
93164: NEG
93165: PUSH
93166: LD_INT 2
93168: PUSH
93169: EMPTY
93170: LIST
93171: LIST
93172: PUSH
93173: LD_INT 3
93175: NEG
93176: PUSH
93177: LD_INT 2
93179: NEG
93180: PUSH
93181: EMPTY
93182: LIST
93183: LIST
93184: PUSH
93185: LD_INT 3
93187: NEG
93188: PUSH
93189: LD_INT 3
93191: NEG
93192: PUSH
93193: EMPTY
93194: LIST
93195: LIST
93196: PUSH
93197: EMPTY
93198: LIST
93199: LIST
93200: LIST
93201: LIST
93202: LIST
93203: LIST
93204: LIST
93205: LIST
93206: LIST
93207: LIST
93208: LIST
93209: LIST
93210: LIST
93211: LIST
93212: LIST
93213: LIST
93214: LIST
93215: LIST
93216: LIST
93217: LIST
93218: LIST
93219: LIST
93220: LIST
93221: LIST
93222: LIST
93223: LIST
93224: LIST
93225: LIST
93226: LIST
93227: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93228: LD_ADDR_VAR 0 46
93232: PUSH
93233: LD_INT 0
93235: PUSH
93236: LD_INT 0
93238: PUSH
93239: EMPTY
93240: LIST
93241: LIST
93242: PUSH
93243: LD_INT 0
93245: PUSH
93246: LD_INT 1
93248: NEG
93249: PUSH
93250: EMPTY
93251: LIST
93252: LIST
93253: PUSH
93254: LD_INT 1
93256: PUSH
93257: LD_INT 0
93259: PUSH
93260: EMPTY
93261: LIST
93262: LIST
93263: PUSH
93264: LD_INT 1
93266: PUSH
93267: LD_INT 1
93269: PUSH
93270: EMPTY
93271: LIST
93272: LIST
93273: PUSH
93274: LD_INT 0
93276: PUSH
93277: LD_INT 1
93279: PUSH
93280: EMPTY
93281: LIST
93282: LIST
93283: PUSH
93284: LD_INT 1
93286: NEG
93287: PUSH
93288: LD_INT 0
93290: PUSH
93291: EMPTY
93292: LIST
93293: LIST
93294: PUSH
93295: LD_INT 1
93297: NEG
93298: PUSH
93299: LD_INT 1
93301: NEG
93302: PUSH
93303: EMPTY
93304: LIST
93305: LIST
93306: PUSH
93307: LD_INT 1
93309: NEG
93310: PUSH
93311: LD_INT 2
93313: NEG
93314: PUSH
93315: EMPTY
93316: LIST
93317: LIST
93318: PUSH
93319: LD_INT 0
93321: PUSH
93322: LD_INT 2
93324: NEG
93325: PUSH
93326: EMPTY
93327: LIST
93328: LIST
93329: PUSH
93330: LD_INT 1
93332: PUSH
93333: LD_INT 1
93335: NEG
93336: PUSH
93337: EMPTY
93338: LIST
93339: LIST
93340: PUSH
93341: LD_INT 2
93343: PUSH
93344: LD_INT 0
93346: PUSH
93347: EMPTY
93348: LIST
93349: LIST
93350: PUSH
93351: LD_INT 2
93353: PUSH
93354: LD_INT 1
93356: PUSH
93357: EMPTY
93358: LIST
93359: LIST
93360: PUSH
93361: LD_INT 1
93363: PUSH
93364: LD_INT 2
93366: PUSH
93367: EMPTY
93368: LIST
93369: LIST
93370: PUSH
93371: LD_INT 0
93373: PUSH
93374: LD_INT 2
93376: PUSH
93377: EMPTY
93378: LIST
93379: LIST
93380: PUSH
93381: LD_INT 1
93383: NEG
93384: PUSH
93385: LD_INT 1
93387: PUSH
93388: EMPTY
93389: LIST
93390: LIST
93391: PUSH
93392: LD_INT 2
93394: NEG
93395: PUSH
93396: LD_INT 0
93398: PUSH
93399: EMPTY
93400: LIST
93401: LIST
93402: PUSH
93403: LD_INT 2
93405: NEG
93406: PUSH
93407: LD_INT 1
93409: NEG
93410: PUSH
93411: EMPTY
93412: LIST
93413: LIST
93414: PUSH
93415: LD_INT 1
93417: NEG
93418: PUSH
93419: LD_INT 3
93421: NEG
93422: PUSH
93423: EMPTY
93424: LIST
93425: LIST
93426: PUSH
93427: LD_INT 0
93429: PUSH
93430: LD_INT 3
93432: NEG
93433: PUSH
93434: EMPTY
93435: LIST
93436: LIST
93437: PUSH
93438: LD_INT 1
93440: PUSH
93441: LD_INT 2
93443: NEG
93444: PUSH
93445: EMPTY
93446: LIST
93447: LIST
93448: PUSH
93449: LD_INT 2
93451: PUSH
93452: LD_INT 1
93454: NEG
93455: PUSH
93456: EMPTY
93457: LIST
93458: LIST
93459: PUSH
93460: LD_INT 3
93462: PUSH
93463: LD_INT 0
93465: PUSH
93466: EMPTY
93467: LIST
93468: LIST
93469: PUSH
93470: LD_INT 3
93472: PUSH
93473: LD_INT 1
93475: PUSH
93476: EMPTY
93477: LIST
93478: LIST
93479: PUSH
93480: LD_INT 1
93482: PUSH
93483: LD_INT 3
93485: PUSH
93486: EMPTY
93487: LIST
93488: LIST
93489: PUSH
93490: LD_INT 0
93492: PUSH
93493: LD_INT 3
93495: PUSH
93496: EMPTY
93497: LIST
93498: LIST
93499: PUSH
93500: LD_INT 1
93502: NEG
93503: PUSH
93504: LD_INT 2
93506: PUSH
93507: EMPTY
93508: LIST
93509: LIST
93510: PUSH
93511: LD_INT 2
93513: NEG
93514: PUSH
93515: LD_INT 1
93517: PUSH
93518: EMPTY
93519: LIST
93520: LIST
93521: PUSH
93522: LD_INT 3
93524: NEG
93525: PUSH
93526: LD_INT 0
93528: PUSH
93529: EMPTY
93530: LIST
93531: LIST
93532: PUSH
93533: LD_INT 3
93535: NEG
93536: PUSH
93537: LD_INT 1
93539: NEG
93540: PUSH
93541: EMPTY
93542: LIST
93543: LIST
93544: PUSH
93545: EMPTY
93546: LIST
93547: LIST
93548: LIST
93549: LIST
93550: LIST
93551: LIST
93552: LIST
93553: LIST
93554: LIST
93555: LIST
93556: LIST
93557: LIST
93558: LIST
93559: LIST
93560: LIST
93561: LIST
93562: LIST
93563: LIST
93564: LIST
93565: LIST
93566: LIST
93567: LIST
93568: LIST
93569: LIST
93570: LIST
93571: LIST
93572: LIST
93573: LIST
93574: LIST
93575: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93576: LD_ADDR_VAR 0 47
93580: PUSH
93581: LD_INT 0
93583: PUSH
93584: LD_INT 0
93586: PUSH
93587: EMPTY
93588: LIST
93589: LIST
93590: PUSH
93591: LD_INT 0
93593: PUSH
93594: LD_INT 1
93596: NEG
93597: PUSH
93598: EMPTY
93599: LIST
93600: LIST
93601: PUSH
93602: LD_INT 1
93604: PUSH
93605: LD_INT 0
93607: PUSH
93608: EMPTY
93609: LIST
93610: LIST
93611: PUSH
93612: LD_INT 1
93614: PUSH
93615: LD_INT 1
93617: PUSH
93618: EMPTY
93619: LIST
93620: LIST
93621: PUSH
93622: LD_INT 0
93624: PUSH
93625: LD_INT 1
93627: PUSH
93628: EMPTY
93629: LIST
93630: LIST
93631: PUSH
93632: LD_INT 1
93634: NEG
93635: PUSH
93636: LD_INT 0
93638: PUSH
93639: EMPTY
93640: LIST
93641: LIST
93642: PUSH
93643: LD_INT 1
93645: NEG
93646: PUSH
93647: LD_INT 1
93649: NEG
93650: PUSH
93651: EMPTY
93652: LIST
93653: LIST
93654: PUSH
93655: LD_INT 1
93657: NEG
93658: PUSH
93659: LD_INT 2
93661: NEG
93662: PUSH
93663: EMPTY
93664: LIST
93665: LIST
93666: PUSH
93667: LD_INT 0
93669: PUSH
93670: LD_INT 2
93672: NEG
93673: PUSH
93674: EMPTY
93675: LIST
93676: LIST
93677: PUSH
93678: LD_INT 1
93680: PUSH
93681: LD_INT 1
93683: NEG
93684: PUSH
93685: EMPTY
93686: LIST
93687: LIST
93688: PUSH
93689: LD_INT 2
93691: NEG
93692: PUSH
93693: LD_INT 1
93695: NEG
93696: PUSH
93697: EMPTY
93698: LIST
93699: LIST
93700: PUSH
93701: LD_INT 2
93703: NEG
93704: PUSH
93705: LD_INT 2
93707: NEG
93708: PUSH
93709: EMPTY
93710: LIST
93711: LIST
93712: PUSH
93713: EMPTY
93714: LIST
93715: LIST
93716: LIST
93717: LIST
93718: LIST
93719: LIST
93720: LIST
93721: LIST
93722: LIST
93723: LIST
93724: LIST
93725: LIST
93726: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
93727: LD_ADDR_VAR 0 48
93731: PUSH
93732: LD_INT 0
93734: PUSH
93735: LD_INT 0
93737: PUSH
93738: EMPTY
93739: LIST
93740: LIST
93741: PUSH
93742: LD_INT 0
93744: PUSH
93745: LD_INT 1
93747: NEG
93748: PUSH
93749: EMPTY
93750: LIST
93751: LIST
93752: PUSH
93753: LD_INT 1
93755: PUSH
93756: LD_INT 0
93758: PUSH
93759: EMPTY
93760: LIST
93761: LIST
93762: PUSH
93763: LD_INT 1
93765: PUSH
93766: LD_INT 1
93768: PUSH
93769: EMPTY
93770: LIST
93771: LIST
93772: PUSH
93773: LD_INT 0
93775: PUSH
93776: LD_INT 1
93778: PUSH
93779: EMPTY
93780: LIST
93781: LIST
93782: PUSH
93783: LD_INT 1
93785: NEG
93786: PUSH
93787: LD_INT 0
93789: PUSH
93790: EMPTY
93791: LIST
93792: LIST
93793: PUSH
93794: LD_INT 1
93796: NEG
93797: PUSH
93798: LD_INT 1
93800: NEG
93801: PUSH
93802: EMPTY
93803: LIST
93804: LIST
93805: PUSH
93806: LD_INT 1
93808: NEG
93809: PUSH
93810: LD_INT 2
93812: NEG
93813: PUSH
93814: EMPTY
93815: LIST
93816: LIST
93817: PUSH
93818: LD_INT 0
93820: PUSH
93821: LD_INT 2
93823: NEG
93824: PUSH
93825: EMPTY
93826: LIST
93827: LIST
93828: PUSH
93829: LD_INT 1
93831: PUSH
93832: LD_INT 1
93834: NEG
93835: PUSH
93836: EMPTY
93837: LIST
93838: LIST
93839: PUSH
93840: LD_INT 2
93842: PUSH
93843: LD_INT 0
93845: PUSH
93846: EMPTY
93847: LIST
93848: LIST
93849: PUSH
93850: LD_INT 2
93852: PUSH
93853: LD_INT 1
93855: PUSH
93856: EMPTY
93857: LIST
93858: LIST
93859: PUSH
93860: EMPTY
93861: LIST
93862: LIST
93863: LIST
93864: LIST
93865: LIST
93866: LIST
93867: LIST
93868: LIST
93869: LIST
93870: LIST
93871: LIST
93872: LIST
93873: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
93874: LD_ADDR_VAR 0 49
93878: PUSH
93879: LD_INT 0
93881: PUSH
93882: LD_INT 0
93884: PUSH
93885: EMPTY
93886: LIST
93887: LIST
93888: PUSH
93889: LD_INT 0
93891: PUSH
93892: LD_INT 1
93894: NEG
93895: PUSH
93896: EMPTY
93897: LIST
93898: LIST
93899: PUSH
93900: LD_INT 1
93902: PUSH
93903: LD_INT 0
93905: PUSH
93906: EMPTY
93907: LIST
93908: LIST
93909: PUSH
93910: LD_INT 1
93912: PUSH
93913: LD_INT 1
93915: PUSH
93916: EMPTY
93917: LIST
93918: LIST
93919: PUSH
93920: LD_INT 0
93922: PUSH
93923: LD_INT 1
93925: PUSH
93926: EMPTY
93927: LIST
93928: LIST
93929: PUSH
93930: LD_INT 1
93932: NEG
93933: PUSH
93934: LD_INT 0
93936: PUSH
93937: EMPTY
93938: LIST
93939: LIST
93940: PUSH
93941: LD_INT 1
93943: NEG
93944: PUSH
93945: LD_INT 1
93947: NEG
93948: PUSH
93949: EMPTY
93950: LIST
93951: LIST
93952: PUSH
93953: LD_INT 1
93955: PUSH
93956: LD_INT 1
93958: NEG
93959: PUSH
93960: EMPTY
93961: LIST
93962: LIST
93963: PUSH
93964: LD_INT 2
93966: PUSH
93967: LD_INT 0
93969: PUSH
93970: EMPTY
93971: LIST
93972: LIST
93973: PUSH
93974: LD_INT 2
93976: PUSH
93977: LD_INT 1
93979: PUSH
93980: EMPTY
93981: LIST
93982: LIST
93983: PUSH
93984: LD_INT 2
93986: PUSH
93987: LD_INT 2
93989: PUSH
93990: EMPTY
93991: LIST
93992: LIST
93993: PUSH
93994: LD_INT 1
93996: PUSH
93997: LD_INT 2
93999: PUSH
94000: EMPTY
94001: LIST
94002: LIST
94003: PUSH
94004: EMPTY
94005: LIST
94006: LIST
94007: LIST
94008: LIST
94009: LIST
94010: LIST
94011: LIST
94012: LIST
94013: LIST
94014: LIST
94015: LIST
94016: LIST
94017: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94018: LD_ADDR_VAR 0 50
94022: PUSH
94023: LD_INT 0
94025: PUSH
94026: LD_INT 0
94028: PUSH
94029: EMPTY
94030: LIST
94031: LIST
94032: PUSH
94033: LD_INT 0
94035: PUSH
94036: LD_INT 1
94038: NEG
94039: PUSH
94040: EMPTY
94041: LIST
94042: LIST
94043: PUSH
94044: LD_INT 1
94046: PUSH
94047: LD_INT 0
94049: PUSH
94050: EMPTY
94051: LIST
94052: LIST
94053: PUSH
94054: LD_INT 1
94056: PUSH
94057: LD_INT 1
94059: PUSH
94060: EMPTY
94061: LIST
94062: LIST
94063: PUSH
94064: LD_INT 0
94066: PUSH
94067: LD_INT 1
94069: PUSH
94070: EMPTY
94071: LIST
94072: LIST
94073: PUSH
94074: LD_INT 1
94076: NEG
94077: PUSH
94078: LD_INT 0
94080: PUSH
94081: EMPTY
94082: LIST
94083: LIST
94084: PUSH
94085: LD_INT 1
94087: NEG
94088: PUSH
94089: LD_INT 1
94091: NEG
94092: PUSH
94093: EMPTY
94094: LIST
94095: LIST
94096: PUSH
94097: LD_INT 2
94099: PUSH
94100: LD_INT 1
94102: PUSH
94103: EMPTY
94104: LIST
94105: LIST
94106: PUSH
94107: LD_INT 2
94109: PUSH
94110: LD_INT 2
94112: PUSH
94113: EMPTY
94114: LIST
94115: LIST
94116: PUSH
94117: LD_INT 1
94119: PUSH
94120: LD_INT 2
94122: PUSH
94123: EMPTY
94124: LIST
94125: LIST
94126: PUSH
94127: LD_INT 0
94129: PUSH
94130: LD_INT 2
94132: PUSH
94133: EMPTY
94134: LIST
94135: LIST
94136: PUSH
94137: LD_INT 1
94139: NEG
94140: PUSH
94141: LD_INT 1
94143: PUSH
94144: EMPTY
94145: LIST
94146: LIST
94147: PUSH
94148: EMPTY
94149: LIST
94150: LIST
94151: LIST
94152: LIST
94153: LIST
94154: LIST
94155: LIST
94156: LIST
94157: LIST
94158: LIST
94159: LIST
94160: LIST
94161: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94162: LD_ADDR_VAR 0 51
94166: PUSH
94167: LD_INT 0
94169: PUSH
94170: LD_INT 0
94172: PUSH
94173: EMPTY
94174: LIST
94175: LIST
94176: PUSH
94177: LD_INT 0
94179: PUSH
94180: LD_INT 1
94182: NEG
94183: PUSH
94184: EMPTY
94185: LIST
94186: LIST
94187: PUSH
94188: LD_INT 1
94190: PUSH
94191: LD_INT 0
94193: PUSH
94194: EMPTY
94195: LIST
94196: LIST
94197: PUSH
94198: LD_INT 1
94200: PUSH
94201: LD_INT 1
94203: PUSH
94204: EMPTY
94205: LIST
94206: LIST
94207: PUSH
94208: LD_INT 0
94210: PUSH
94211: LD_INT 1
94213: PUSH
94214: EMPTY
94215: LIST
94216: LIST
94217: PUSH
94218: LD_INT 1
94220: NEG
94221: PUSH
94222: LD_INT 0
94224: PUSH
94225: EMPTY
94226: LIST
94227: LIST
94228: PUSH
94229: LD_INT 1
94231: NEG
94232: PUSH
94233: LD_INT 1
94235: NEG
94236: PUSH
94237: EMPTY
94238: LIST
94239: LIST
94240: PUSH
94241: LD_INT 1
94243: PUSH
94244: LD_INT 2
94246: PUSH
94247: EMPTY
94248: LIST
94249: LIST
94250: PUSH
94251: LD_INT 0
94253: PUSH
94254: LD_INT 2
94256: PUSH
94257: EMPTY
94258: LIST
94259: LIST
94260: PUSH
94261: LD_INT 1
94263: NEG
94264: PUSH
94265: LD_INT 1
94267: PUSH
94268: EMPTY
94269: LIST
94270: LIST
94271: PUSH
94272: LD_INT 2
94274: NEG
94275: PUSH
94276: LD_INT 0
94278: PUSH
94279: EMPTY
94280: LIST
94281: LIST
94282: PUSH
94283: LD_INT 2
94285: NEG
94286: PUSH
94287: LD_INT 1
94289: NEG
94290: PUSH
94291: EMPTY
94292: LIST
94293: LIST
94294: PUSH
94295: EMPTY
94296: LIST
94297: LIST
94298: LIST
94299: LIST
94300: LIST
94301: LIST
94302: LIST
94303: LIST
94304: LIST
94305: LIST
94306: LIST
94307: LIST
94308: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94309: LD_ADDR_VAR 0 52
94313: PUSH
94314: LD_INT 0
94316: PUSH
94317: LD_INT 0
94319: PUSH
94320: EMPTY
94321: LIST
94322: LIST
94323: PUSH
94324: LD_INT 0
94326: PUSH
94327: LD_INT 1
94329: NEG
94330: PUSH
94331: EMPTY
94332: LIST
94333: LIST
94334: PUSH
94335: LD_INT 1
94337: PUSH
94338: LD_INT 0
94340: PUSH
94341: EMPTY
94342: LIST
94343: LIST
94344: PUSH
94345: LD_INT 1
94347: PUSH
94348: LD_INT 1
94350: PUSH
94351: EMPTY
94352: LIST
94353: LIST
94354: PUSH
94355: LD_INT 0
94357: PUSH
94358: LD_INT 1
94360: PUSH
94361: EMPTY
94362: LIST
94363: LIST
94364: PUSH
94365: LD_INT 1
94367: NEG
94368: PUSH
94369: LD_INT 0
94371: PUSH
94372: EMPTY
94373: LIST
94374: LIST
94375: PUSH
94376: LD_INT 1
94378: NEG
94379: PUSH
94380: LD_INT 1
94382: NEG
94383: PUSH
94384: EMPTY
94385: LIST
94386: LIST
94387: PUSH
94388: LD_INT 1
94390: NEG
94391: PUSH
94392: LD_INT 2
94394: NEG
94395: PUSH
94396: EMPTY
94397: LIST
94398: LIST
94399: PUSH
94400: LD_INT 1
94402: NEG
94403: PUSH
94404: LD_INT 1
94406: PUSH
94407: EMPTY
94408: LIST
94409: LIST
94410: PUSH
94411: LD_INT 2
94413: NEG
94414: PUSH
94415: LD_INT 0
94417: PUSH
94418: EMPTY
94419: LIST
94420: LIST
94421: PUSH
94422: LD_INT 2
94424: NEG
94425: PUSH
94426: LD_INT 1
94428: NEG
94429: PUSH
94430: EMPTY
94431: LIST
94432: LIST
94433: PUSH
94434: LD_INT 2
94436: NEG
94437: PUSH
94438: LD_INT 2
94440: NEG
94441: PUSH
94442: EMPTY
94443: LIST
94444: LIST
94445: PUSH
94446: EMPTY
94447: LIST
94448: LIST
94449: LIST
94450: LIST
94451: LIST
94452: LIST
94453: LIST
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94460: LD_ADDR_VAR 0 53
94464: PUSH
94465: LD_INT 0
94467: PUSH
94468: LD_INT 0
94470: PUSH
94471: EMPTY
94472: LIST
94473: LIST
94474: PUSH
94475: LD_INT 0
94477: PUSH
94478: LD_INT 1
94480: NEG
94481: PUSH
94482: EMPTY
94483: LIST
94484: LIST
94485: PUSH
94486: LD_INT 1
94488: PUSH
94489: LD_INT 0
94491: PUSH
94492: EMPTY
94493: LIST
94494: LIST
94495: PUSH
94496: LD_INT 1
94498: PUSH
94499: LD_INT 1
94501: PUSH
94502: EMPTY
94503: LIST
94504: LIST
94505: PUSH
94506: LD_INT 0
94508: PUSH
94509: LD_INT 1
94511: PUSH
94512: EMPTY
94513: LIST
94514: LIST
94515: PUSH
94516: LD_INT 1
94518: NEG
94519: PUSH
94520: LD_INT 0
94522: PUSH
94523: EMPTY
94524: LIST
94525: LIST
94526: PUSH
94527: LD_INT 1
94529: NEG
94530: PUSH
94531: LD_INT 1
94533: NEG
94534: PUSH
94535: EMPTY
94536: LIST
94537: LIST
94538: PUSH
94539: LD_INT 1
94541: NEG
94542: PUSH
94543: LD_INT 2
94545: NEG
94546: PUSH
94547: EMPTY
94548: LIST
94549: LIST
94550: PUSH
94551: LD_INT 0
94553: PUSH
94554: LD_INT 2
94556: NEG
94557: PUSH
94558: EMPTY
94559: LIST
94560: LIST
94561: PUSH
94562: LD_INT 1
94564: PUSH
94565: LD_INT 1
94567: NEG
94568: PUSH
94569: EMPTY
94570: LIST
94571: LIST
94572: PUSH
94573: LD_INT 2
94575: PUSH
94576: LD_INT 0
94578: PUSH
94579: EMPTY
94580: LIST
94581: LIST
94582: PUSH
94583: LD_INT 2
94585: PUSH
94586: LD_INT 1
94588: PUSH
94589: EMPTY
94590: LIST
94591: LIST
94592: PUSH
94593: LD_INT 2
94595: PUSH
94596: LD_INT 2
94598: PUSH
94599: EMPTY
94600: LIST
94601: LIST
94602: PUSH
94603: LD_INT 1
94605: PUSH
94606: LD_INT 2
94608: PUSH
94609: EMPTY
94610: LIST
94611: LIST
94612: PUSH
94613: LD_INT 0
94615: PUSH
94616: LD_INT 2
94618: PUSH
94619: EMPTY
94620: LIST
94621: LIST
94622: PUSH
94623: LD_INT 1
94625: NEG
94626: PUSH
94627: LD_INT 1
94629: PUSH
94630: EMPTY
94631: LIST
94632: LIST
94633: PUSH
94634: LD_INT 2
94636: NEG
94637: PUSH
94638: LD_INT 0
94640: PUSH
94641: EMPTY
94642: LIST
94643: LIST
94644: PUSH
94645: LD_INT 2
94647: NEG
94648: PUSH
94649: LD_INT 1
94651: NEG
94652: PUSH
94653: EMPTY
94654: LIST
94655: LIST
94656: PUSH
94657: LD_INT 2
94659: NEG
94660: PUSH
94661: LD_INT 2
94663: NEG
94664: PUSH
94665: EMPTY
94666: LIST
94667: LIST
94668: PUSH
94669: EMPTY
94670: LIST
94671: LIST
94672: LIST
94673: LIST
94674: LIST
94675: LIST
94676: LIST
94677: LIST
94678: LIST
94679: LIST
94680: LIST
94681: LIST
94682: LIST
94683: LIST
94684: LIST
94685: LIST
94686: LIST
94687: LIST
94688: LIST
94689: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94690: LD_ADDR_VAR 0 54
94694: PUSH
94695: LD_INT 0
94697: PUSH
94698: LD_INT 0
94700: PUSH
94701: EMPTY
94702: LIST
94703: LIST
94704: PUSH
94705: LD_INT 0
94707: PUSH
94708: LD_INT 1
94710: NEG
94711: PUSH
94712: EMPTY
94713: LIST
94714: LIST
94715: PUSH
94716: LD_INT 1
94718: PUSH
94719: LD_INT 0
94721: PUSH
94722: EMPTY
94723: LIST
94724: LIST
94725: PUSH
94726: LD_INT 1
94728: PUSH
94729: LD_INT 1
94731: PUSH
94732: EMPTY
94733: LIST
94734: LIST
94735: PUSH
94736: LD_INT 0
94738: PUSH
94739: LD_INT 1
94741: PUSH
94742: EMPTY
94743: LIST
94744: LIST
94745: PUSH
94746: LD_INT 1
94748: NEG
94749: PUSH
94750: LD_INT 0
94752: PUSH
94753: EMPTY
94754: LIST
94755: LIST
94756: PUSH
94757: LD_INT 1
94759: NEG
94760: PUSH
94761: LD_INT 1
94763: NEG
94764: PUSH
94765: EMPTY
94766: LIST
94767: LIST
94768: PUSH
94769: LD_INT 1
94771: NEG
94772: PUSH
94773: LD_INT 2
94775: NEG
94776: PUSH
94777: EMPTY
94778: LIST
94779: LIST
94780: PUSH
94781: LD_INT 0
94783: PUSH
94784: LD_INT 2
94786: NEG
94787: PUSH
94788: EMPTY
94789: LIST
94790: LIST
94791: PUSH
94792: LD_INT 1
94794: PUSH
94795: LD_INT 1
94797: NEG
94798: PUSH
94799: EMPTY
94800: LIST
94801: LIST
94802: PUSH
94803: LD_INT 2
94805: PUSH
94806: LD_INT 0
94808: PUSH
94809: EMPTY
94810: LIST
94811: LIST
94812: PUSH
94813: LD_INT 2
94815: PUSH
94816: LD_INT 1
94818: PUSH
94819: EMPTY
94820: LIST
94821: LIST
94822: PUSH
94823: LD_INT 2
94825: PUSH
94826: LD_INT 2
94828: PUSH
94829: EMPTY
94830: LIST
94831: LIST
94832: PUSH
94833: LD_INT 1
94835: PUSH
94836: LD_INT 2
94838: PUSH
94839: EMPTY
94840: LIST
94841: LIST
94842: PUSH
94843: LD_INT 0
94845: PUSH
94846: LD_INT 2
94848: PUSH
94849: EMPTY
94850: LIST
94851: LIST
94852: PUSH
94853: LD_INT 1
94855: NEG
94856: PUSH
94857: LD_INT 1
94859: PUSH
94860: EMPTY
94861: LIST
94862: LIST
94863: PUSH
94864: LD_INT 2
94866: NEG
94867: PUSH
94868: LD_INT 0
94870: PUSH
94871: EMPTY
94872: LIST
94873: LIST
94874: PUSH
94875: LD_INT 2
94877: NEG
94878: PUSH
94879: LD_INT 1
94881: NEG
94882: PUSH
94883: EMPTY
94884: LIST
94885: LIST
94886: PUSH
94887: LD_INT 2
94889: NEG
94890: PUSH
94891: LD_INT 2
94893: NEG
94894: PUSH
94895: EMPTY
94896: LIST
94897: LIST
94898: PUSH
94899: EMPTY
94900: LIST
94901: LIST
94902: LIST
94903: LIST
94904: LIST
94905: LIST
94906: LIST
94907: LIST
94908: LIST
94909: LIST
94910: LIST
94911: LIST
94912: LIST
94913: LIST
94914: LIST
94915: LIST
94916: LIST
94917: LIST
94918: LIST
94919: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94920: LD_ADDR_VAR 0 55
94924: PUSH
94925: LD_INT 0
94927: PUSH
94928: LD_INT 0
94930: PUSH
94931: EMPTY
94932: LIST
94933: LIST
94934: PUSH
94935: LD_INT 0
94937: PUSH
94938: LD_INT 1
94940: NEG
94941: PUSH
94942: EMPTY
94943: LIST
94944: LIST
94945: PUSH
94946: LD_INT 1
94948: PUSH
94949: LD_INT 0
94951: PUSH
94952: EMPTY
94953: LIST
94954: LIST
94955: PUSH
94956: LD_INT 1
94958: PUSH
94959: LD_INT 1
94961: PUSH
94962: EMPTY
94963: LIST
94964: LIST
94965: PUSH
94966: LD_INT 0
94968: PUSH
94969: LD_INT 1
94971: PUSH
94972: EMPTY
94973: LIST
94974: LIST
94975: PUSH
94976: LD_INT 1
94978: NEG
94979: PUSH
94980: LD_INT 0
94982: PUSH
94983: EMPTY
94984: LIST
94985: LIST
94986: PUSH
94987: LD_INT 1
94989: NEG
94990: PUSH
94991: LD_INT 1
94993: NEG
94994: PUSH
94995: EMPTY
94996: LIST
94997: LIST
94998: PUSH
94999: LD_INT 1
95001: NEG
95002: PUSH
95003: LD_INT 2
95005: NEG
95006: PUSH
95007: EMPTY
95008: LIST
95009: LIST
95010: PUSH
95011: LD_INT 0
95013: PUSH
95014: LD_INT 2
95016: NEG
95017: PUSH
95018: EMPTY
95019: LIST
95020: LIST
95021: PUSH
95022: LD_INT 1
95024: PUSH
95025: LD_INT 1
95027: NEG
95028: PUSH
95029: EMPTY
95030: LIST
95031: LIST
95032: PUSH
95033: LD_INT 2
95035: PUSH
95036: LD_INT 0
95038: PUSH
95039: EMPTY
95040: LIST
95041: LIST
95042: PUSH
95043: LD_INT 2
95045: PUSH
95046: LD_INT 1
95048: PUSH
95049: EMPTY
95050: LIST
95051: LIST
95052: PUSH
95053: LD_INT 2
95055: PUSH
95056: LD_INT 2
95058: PUSH
95059: EMPTY
95060: LIST
95061: LIST
95062: PUSH
95063: LD_INT 1
95065: PUSH
95066: LD_INT 2
95068: PUSH
95069: EMPTY
95070: LIST
95071: LIST
95072: PUSH
95073: LD_INT 0
95075: PUSH
95076: LD_INT 2
95078: PUSH
95079: EMPTY
95080: LIST
95081: LIST
95082: PUSH
95083: LD_INT 1
95085: NEG
95086: PUSH
95087: LD_INT 1
95089: PUSH
95090: EMPTY
95091: LIST
95092: LIST
95093: PUSH
95094: LD_INT 2
95096: NEG
95097: PUSH
95098: LD_INT 0
95100: PUSH
95101: EMPTY
95102: LIST
95103: LIST
95104: PUSH
95105: LD_INT 2
95107: NEG
95108: PUSH
95109: LD_INT 1
95111: NEG
95112: PUSH
95113: EMPTY
95114: LIST
95115: LIST
95116: PUSH
95117: LD_INT 2
95119: NEG
95120: PUSH
95121: LD_INT 2
95123: NEG
95124: PUSH
95125: EMPTY
95126: LIST
95127: LIST
95128: PUSH
95129: EMPTY
95130: LIST
95131: LIST
95132: LIST
95133: LIST
95134: LIST
95135: LIST
95136: LIST
95137: LIST
95138: LIST
95139: LIST
95140: LIST
95141: LIST
95142: LIST
95143: LIST
95144: LIST
95145: LIST
95146: LIST
95147: LIST
95148: LIST
95149: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95150: LD_ADDR_VAR 0 56
95154: PUSH
95155: LD_INT 0
95157: PUSH
95158: LD_INT 0
95160: PUSH
95161: EMPTY
95162: LIST
95163: LIST
95164: PUSH
95165: LD_INT 0
95167: PUSH
95168: LD_INT 1
95170: NEG
95171: PUSH
95172: EMPTY
95173: LIST
95174: LIST
95175: PUSH
95176: LD_INT 1
95178: PUSH
95179: LD_INT 0
95181: PUSH
95182: EMPTY
95183: LIST
95184: LIST
95185: PUSH
95186: LD_INT 1
95188: PUSH
95189: LD_INT 1
95191: PUSH
95192: EMPTY
95193: LIST
95194: LIST
95195: PUSH
95196: LD_INT 0
95198: PUSH
95199: LD_INT 1
95201: PUSH
95202: EMPTY
95203: LIST
95204: LIST
95205: PUSH
95206: LD_INT 1
95208: NEG
95209: PUSH
95210: LD_INT 0
95212: PUSH
95213: EMPTY
95214: LIST
95215: LIST
95216: PUSH
95217: LD_INT 1
95219: NEG
95220: PUSH
95221: LD_INT 1
95223: NEG
95224: PUSH
95225: EMPTY
95226: LIST
95227: LIST
95228: PUSH
95229: LD_INT 1
95231: NEG
95232: PUSH
95233: LD_INT 2
95235: NEG
95236: PUSH
95237: EMPTY
95238: LIST
95239: LIST
95240: PUSH
95241: LD_INT 0
95243: PUSH
95244: LD_INT 2
95246: NEG
95247: PUSH
95248: EMPTY
95249: LIST
95250: LIST
95251: PUSH
95252: LD_INT 1
95254: PUSH
95255: LD_INT 1
95257: NEG
95258: PUSH
95259: EMPTY
95260: LIST
95261: LIST
95262: PUSH
95263: LD_INT 2
95265: PUSH
95266: LD_INT 0
95268: PUSH
95269: EMPTY
95270: LIST
95271: LIST
95272: PUSH
95273: LD_INT 2
95275: PUSH
95276: LD_INT 1
95278: PUSH
95279: EMPTY
95280: LIST
95281: LIST
95282: PUSH
95283: LD_INT 2
95285: PUSH
95286: LD_INT 2
95288: PUSH
95289: EMPTY
95290: LIST
95291: LIST
95292: PUSH
95293: LD_INT 1
95295: PUSH
95296: LD_INT 2
95298: PUSH
95299: EMPTY
95300: LIST
95301: LIST
95302: PUSH
95303: LD_INT 0
95305: PUSH
95306: LD_INT 2
95308: PUSH
95309: EMPTY
95310: LIST
95311: LIST
95312: PUSH
95313: LD_INT 1
95315: NEG
95316: PUSH
95317: LD_INT 1
95319: PUSH
95320: EMPTY
95321: LIST
95322: LIST
95323: PUSH
95324: LD_INT 2
95326: NEG
95327: PUSH
95328: LD_INT 0
95330: PUSH
95331: EMPTY
95332: LIST
95333: LIST
95334: PUSH
95335: LD_INT 2
95337: NEG
95338: PUSH
95339: LD_INT 1
95341: NEG
95342: PUSH
95343: EMPTY
95344: LIST
95345: LIST
95346: PUSH
95347: LD_INT 2
95349: NEG
95350: PUSH
95351: LD_INT 2
95353: NEG
95354: PUSH
95355: EMPTY
95356: LIST
95357: LIST
95358: PUSH
95359: EMPTY
95360: LIST
95361: LIST
95362: LIST
95363: LIST
95364: LIST
95365: LIST
95366: LIST
95367: LIST
95368: LIST
95369: LIST
95370: LIST
95371: LIST
95372: LIST
95373: LIST
95374: LIST
95375: LIST
95376: LIST
95377: LIST
95378: LIST
95379: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95380: LD_ADDR_VAR 0 57
95384: PUSH
95385: LD_INT 0
95387: PUSH
95388: LD_INT 0
95390: PUSH
95391: EMPTY
95392: LIST
95393: LIST
95394: PUSH
95395: LD_INT 0
95397: PUSH
95398: LD_INT 1
95400: NEG
95401: PUSH
95402: EMPTY
95403: LIST
95404: LIST
95405: PUSH
95406: LD_INT 1
95408: PUSH
95409: LD_INT 0
95411: PUSH
95412: EMPTY
95413: LIST
95414: LIST
95415: PUSH
95416: LD_INT 1
95418: PUSH
95419: LD_INT 1
95421: PUSH
95422: EMPTY
95423: LIST
95424: LIST
95425: PUSH
95426: LD_INT 0
95428: PUSH
95429: LD_INT 1
95431: PUSH
95432: EMPTY
95433: LIST
95434: LIST
95435: PUSH
95436: LD_INT 1
95438: NEG
95439: PUSH
95440: LD_INT 0
95442: PUSH
95443: EMPTY
95444: LIST
95445: LIST
95446: PUSH
95447: LD_INT 1
95449: NEG
95450: PUSH
95451: LD_INT 1
95453: NEG
95454: PUSH
95455: EMPTY
95456: LIST
95457: LIST
95458: PUSH
95459: LD_INT 1
95461: NEG
95462: PUSH
95463: LD_INT 2
95465: NEG
95466: PUSH
95467: EMPTY
95468: LIST
95469: LIST
95470: PUSH
95471: LD_INT 0
95473: PUSH
95474: LD_INT 2
95476: NEG
95477: PUSH
95478: EMPTY
95479: LIST
95480: LIST
95481: PUSH
95482: LD_INT 1
95484: PUSH
95485: LD_INT 1
95487: NEG
95488: PUSH
95489: EMPTY
95490: LIST
95491: LIST
95492: PUSH
95493: LD_INT 2
95495: PUSH
95496: LD_INT 0
95498: PUSH
95499: EMPTY
95500: LIST
95501: LIST
95502: PUSH
95503: LD_INT 2
95505: PUSH
95506: LD_INT 1
95508: PUSH
95509: EMPTY
95510: LIST
95511: LIST
95512: PUSH
95513: LD_INT 2
95515: PUSH
95516: LD_INT 2
95518: PUSH
95519: EMPTY
95520: LIST
95521: LIST
95522: PUSH
95523: LD_INT 1
95525: PUSH
95526: LD_INT 2
95528: PUSH
95529: EMPTY
95530: LIST
95531: LIST
95532: PUSH
95533: LD_INT 0
95535: PUSH
95536: LD_INT 2
95538: PUSH
95539: EMPTY
95540: LIST
95541: LIST
95542: PUSH
95543: LD_INT 1
95545: NEG
95546: PUSH
95547: LD_INT 1
95549: PUSH
95550: EMPTY
95551: LIST
95552: LIST
95553: PUSH
95554: LD_INT 2
95556: NEG
95557: PUSH
95558: LD_INT 0
95560: PUSH
95561: EMPTY
95562: LIST
95563: LIST
95564: PUSH
95565: LD_INT 2
95567: NEG
95568: PUSH
95569: LD_INT 1
95571: NEG
95572: PUSH
95573: EMPTY
95574: LIST
95575: LIST
95576: PUSH
95577: LD_INT 2
95579: NEG
95580: PUSH
95581: LD_INT 2
95583: NEG
95584: PUSH
95585: EMPTY
95586: LIST
95587: LIST
95588: PUSH
95589: EMPTY
95590: LIST
95591: LIST
95592: LIST
95593: LIST
95594: LIST
95595: LIST
95596: LIST
95597: LIST
95598: LIST
95599: LIST
95600: LIST
95601: LIST
95602: LIST
95603: LIST
95604: LIST
95605: LIST
95606: LIST
95607: LIST
95608: LIST
95609: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95610: LD_ADDR_VAR 0 58
95614: PUSH
95615: LD_INT 0
95617: PUSH
95618: LD_INT 0
95620: PUSH
95621: EMPTY
95622: LIST
95623: LIST
95624: PUSH
95625: LD_INT 0
95627: PUSH
95628: LD_INT 1
95630: NEG
95631: PUSH
95632: EMPTY
95633: LIST
95634: LIST
95635: PUSH
95636: LD_INT 1
95638: PUSH
95639: LD_INT 0
95641: PUSH
95642: EMPTY
95643: LIST
95644: LIST
95645: PUSH
95646: LD_INT 1
95648: PUSH
95649: LD_INT 1
95651: PUSH
95652: EMPTY
95653: LIST
95654: LIST
95655: PUSH
95656: LD_INT 0
95658: PUSH
95659: LD_INT 1
95661: PUSH
95662: EMPTY
95663: LIST
95664: LIST
95665: PUSH
95666: LD_INT 1
95668: NEG
95669: PUSH
95670: LD_INT 0
95672: PUSH
95673: EMPTY
95674: LIST
95675: LIST
95676: PUSH
95677: LD_INT 1
95679: NEG
95680: PUSH
95681: LD_INT 1
95683: NEG
95684: PUSH
95685: EMPTY
95686: LIST
95687: LIST
95688: PUSH
95689: LD_INT 1
95691: NEG
95692: PUSH
95693: LD_INT 2
95695: NEG
95696: PUSH
95697: EMPTY
95698: LIST
95699: LIST
95700: PUSH
95701: LD_INT 0
95703: PUSH
95704: LD_INT 2
95706: NEG
95707: PUSH
95708: EMPTY
95709: LIST
95710: LIST
95711: PUSH
95712: LD_INT 1
95714: PUSH
95715: LD_INT 1
95717: NEG
95718: PUSH
95719: EMPTY
95720: LIST
95721: LIST
95722: PUSH
95723: LD_INT 2
95725: PUSH
95726: LD_INT 0
95728: PUSH
95729: EMPTY
95730: LIST
95731: LIST
95732: PUSH
95733: LD_INT 2
95735: PUSH
95736: LD_INT 1
95738: PUSH
95739: EMPTY
95740: LIST
95741: LIST
95742: PUSH
95743: LD_INT 2
95745: PUSH
95746: LD_INT 2
95748: PUSH
95749: EMPTY
95750: LIST
95751: LIST
95752: PUSH
95753: LD_INT 1
95755: PUSH
95756: LD_INT 2
95758: PUSH
95759: EMPTY
95760: LIST
95761: LIST
95762: PUSH
95763: LD_INT 0
95765: PUSH
95766: LD_INT 2
95768: PUSH
95769: EMPTY
95770: LIST
95771: LIST
95772: PUSH
95773: LD_INT 1
95775: NEG
95776: PUSH
95777: LD_INT 1
95779: PUSH
95780: EMPTY
95781: LIST
95782: LIST
95783: PUSH
95784: LD_INT 2
95786: NEG
95787: PUSH
95788: LD_INT 0
95790: PUSH
95791: EMPTY
95792: LIST
95793: LIST
95794: PUSH
95795: LD_INT 2
95797: NEG
95798: PUSH
95799: LD_INT 1
95801: NEG
95802: PUSH
95803: EMPTY
95804: LIST
95805: LIST
95806: PUSH
95807: LD_INT 2
95809: NEG
95810: PUSH
95811: LD_INT 2
95813: NEG
95814: PUSH
95815: EMPTY
95816: LIST
95817: LIST
95818: PUSH
95819: EMPTY
95820: LIST
95821: LIST
95822: LIST
95823: LIST
95824: LIST
95825: LIST
95826: LIST
95827: LIST
95828: LIST
95829: LIST
95830: LIST
95831: LIST
95832: LIST
95833: LIST
95834: LIST
95835: LIST
95836: LIST
95837: LIST
95838: LIST
95839: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95840: LD_ADDR_VAR 0 59
95844: PUSH
95845: LD_INT 0
95847: PUSH
95848: LD_INT 0
95850: PUSH
95851: EMPTY
95852: LIST
95853: LIST
95854: PUSH
95855: LD_INT 0
95857: PUSH
95858: LD_INT 1
95860: NEG
95861: PUSH
95862: EMPTY
95863: LIST
95864: LIST
95865: PUSH
95866: LD_INT 1
95868: PUSH
95869: LD_INT 0
95871: PUSH
95872: EMPTY
95873: LIST
95874: LIST
95875: PUSH
95876: LD_INT 1
95878: PUSH
95879: LD_INT 1
95881: PUSH
95882: EMPTY
95883: LIST
95884: LIST
95885: PUSH
95886: LD_INT 0
95888: PUSH
95889: LD_INT 1
95891: PUSH
95892: EMPTY
95893: LIST
95894: LIST
95895: PUSH
95896: LD_INT 1
95898: NEG
95899: PUSH
95900: LD_INT 0
95902: PUSH
95903: EMPTY
95904: LIST
95905: LIST
95906: PUSH
95907: LD_INT 1
95909: NEG
95910: PUSH
95911: LD_INT 1
95913: NEG
95914: PUSH
95915: EMPTY
95916: LIST
95917: LIST
95918: PUSH
95919: EMPTY
95920: LIST
95921: LIST
95922: LIST
95923: LIST
95924: LIST
95925: LIST
95926: LIST
95927: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95928: LD_ADDR_VAR 0 60
95932: PUSH
95933: LD_INT 0
95935: PUSH
95936: LD_INT 0
95938: PUSH
95939: EMPTY
95940: LIST
95941: LIST
95942: PUSH
95943: LD_INT 0
95945: PUSH
95946: LD_INT 1
95948: NEG
95949: PUSH
95950: EMPTY
95951: LIST
95952: LIST
95953: PUSH
95954: LD_INT 1
95956: PUSH
95957: LD_INT 0
95959: PUSH
95960: EMPTY
95961: LIST
95962: LIST
95963: PUSH
95964: LD_INT 1
95966: PUSH
95967: LD_INT 1
95969: PUSH
95970: EMPTY
95971: LIST
95972: LIST
95973: PUSH
95974: LD_INT 0
95976: PUSH
95977: LD_INT 1
95979: PUSH
95980: EMPTY
95981: LIST
95982: LIST
95983: PUSH
95984: LD_INT 1
95986: NEG
95987: PUSH
95988: LD_INT 0
95990: PUSH
95991: EMPTY
95992: LIST
95993: LIST
95994: PUSH
95995: LD_INT 1
95997: NEG
95998: PUSH
95999: LD_INT 1
96001: NEG
96002: PUSH
96003: EMPTY
96004: LIST
96005: LIST
96006: PUSH
96007: EMPTY
96008: LIST
96009: LIST
96010: LIST
96011: LIST
96012: LIST
96013: LIST
96014: LIST
96015: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96016: LD_ADDR_VAR 0 61
96020: PUSH
96021: LD_INT 0
96023: PUSH
96024: LD_INT 0
96026: PUSH
96027: EMPTY
96028: LIST
96029: LIST
96030: PUSH
96031: LD_INT 0
96033: PUSH
96034: LD_INT 1
96036: NEG
96037: PUSH
96038: EMPTY
96039: LIST
96040: LIST
96041: PUSH
96042: LD_INT 1
96044: PUSH
96045: LD_INT 0
96047: PUSH
96048: EMPTY
96049: LIST
96050: LIST
96051: PUSH
96052: LD_INT 1
96054: PUSH
96055: LD_INT 1
96057: PUSH
96058: EMPTY
96059: LIST
96060: LIST
96061: PUSH
96062: LD_INT 0
96064: PUSH
96065: LD_INT 1
96067: PUSH
96068: EMPTY
96069: LIST
96070: LIST
96071: PUSH
96072: LD_INT 1
96074: NEG
96075: PUSH
96076: LD_INT 0
96078: PUSH
96079: EMPTY
96080: LIST
96081: LIST
96082: PUSH
96083: LD_INT 1
96085: NEG
96086: PUSH
96087: LD_INT 1
96089: NEG
96090: PUSH
96091: EMPTY
96092: LIST
96093: LIST
96094: PUSH
96095: EMPTY
96096: LIST
96097: LIST
96098: LIST
96099: LIST
96100: LIST
96101: LIST
96102: LIST
96103: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96104: LD_ADDR_VAR 0 62
96108: PUSH
96109: LD_INT 0
96111: PUSH
96112: LD_INT 0
96114: PUSH
96115: EMPTY
96116: LIST
96117: LIST
96118: PUSH
96119: LD_INT 0
96121: PUSH
96122: LD_INT 1
96124: NEG
96125: PUSH
96126: EMPTY
96127: LIST
96128: LIST
96129: PUSH
96130: LD_INT 1
96132: PUSH
96133: LD_INT 0
96135: PUSH
96136: EMPTY
96137: LIST
96138: LIST
96139: PUSH
96140: LD_INT 1
96142: PUSH
96143: LD_INT 1
96145: PUSH
96146: EMPTY
96147: LIST
96148: LIST
96149: PUSH
96150: LD_INT 0
96152: PUSH
96153: LD_INT 1
96155: PUSH
96156: EMPTY
96157: LIST
96158: LIST
96159: PUSH
96160: LD_INT 1
96162: NEG
96163: PUSH
96164: LD_INT 0
96166: PUSH
96167: EMPTY
96168: LIST
96169: LIST
96170: PUSH
96171: LD_INT 1
96173: NEG
96174: PUSH
96175: LD_INT 1
96177: NEG
96178: PUSH
96179: EMPTY
96180: LIST
96181: LIST
96182: PUSH
96183: EMPTY
96184: LIST
96185: LIST
96186: LIST
96187: LIST
96188: LIST
96189: LIST
96190: LIST
96191: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96192: LD_ADDR_VAR 0 63
96196: PUSH
96197: LD_INT 0
96199: PUSH
96200: LD_INT 0
96202: PUSH
96203: EMPTY
96204: LIST
96205: LIST
96206: PUSH
96207: LD_INT 0
96209: PUSH
96210: LD_INT 1
96212: NEG
96213: PUSH
96214: EMPTY
96215: LIST
96216: LIST
96217: PUSH
96218: LD_INT 1
96220: PUSH
96221: LD_INT 0
96223: PUSH
96224: EMPTY
96225: LIST
96226: LIST
96227: PUSH
96228: LD_INT 1
96230: PUSH
96231: LD_INT 1
96233: PUSH
96234: EMPTY
96235: LIST
96236: LIST
96237: PUSH
96238: LD_INT 0
96240: PUSH
96241: LD_INT 1
96243: PUSH
96244: EMPTY
96245: LIST
96246: LIST
96247: PUSH
96248: LD_INT 1
96250: NEG
96251: PUSH
96252: LD_INT 0
96254: PUSH
96255: EMPTY
96256: LIST
96257: LIST
96258: PUSH
96259: LD_INT 1
96261: NEG
96262: PUSH
96263: LD_INT 1
96265: NEG
96266: PUSH
96267: EMPTY
96268: LIST
96269: LIST
96270: PUSH
96271: EMPTY
96272: LIST
96273: LIST
96274: LIST
96275: LIST
96276: LIST
96277: LIST
96278: LIST
96279: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96280: LD_ADDR_VAR 0 64
96284: PUSH
96285: LD_INT 0
96287: PUSH
96288: LD_INT 0
96290: PUSH
96291: EMPTY
96292: LIST
96293: LIST
96294: PUSH
96295: LD_INT 0
96297: PUSH
96298: LD_INT 1
96300: NEG
96301: PUSH
96302: EMPTY
96303: LIST
96304: LIST
96305: PUSH
96306: LD_INT 1
96308: PUSH
96309: LD_INT 0
96311: PUSH
96312: EMPTY
96313: LIST
96314: LIST
96315: PUSH
96316: LD_INT 1
96318: PUSH
96319: LD_INT 1
96321: PUSH
96322: EMPTY
96323: LIST
96324: LIST
96325: PUSH
96326: LD_INT 0
96328: PUSH
96329: LD_INT 1
96331: PUSH
96332: EMPTY
96333: LIST
96334: LIST
96335: PUSH
96336: LD_INT 1
96338: NEG
96339: PUSH
96340: LD_INT 0
96342: PUSH
96343: EMPTY
96344: LIST
96345: LIST
96346: PUSH
96347: LD_INT 1
96349: NEG
96350: PUSH
96351: LD_INT 1
96353: NEG
96354: PUSH
96355: EMPTY
96356: LIST
96357: LIST
96358: PUSH
96359: EMPTY
96360: LIST
96361: LIST
96362: LIST
96363: LIST
96364: LIST
96365: LIST
96366: LIST
96367: ST_TO_ADDR
// end ; 1 :
96368: GO 102265
96370: LD_INT 1
96372: DOUBLE
96373: EQUAL
96374: IFTRUE 96378
96376: GO 99001
96378: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
96379: LD_ADDR_VAR 0 11
96383: PUSH
96384: LD_INT 1
96386: NEG
96387: PUSH
96388: LD_INT 3
96390: NEG
96391: PUSH
96392: EMPTY
96393: LIST
96394: LIST
96395: PUSH
96396: LD_INT 0
96398: PUSH
96399: LD_INT 3
96401: NEG
96402: PUSH
96403: EMPTY
96404: LIST
96405: LIST
96406: PUSH
96407: LD_INT 1
96409: PUSH
96410: LD_INT 2
96412: NEG
96413: PUSH
96414: EMPTY
96415: LIST
96416: LIST
96417: PUSH
96418: EMPTY
96419: LIST
96420: LIST
96421: LIST
96422: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
96423: LD_ADDR_VAR 0 12
96427: PUSH
96428: LD_INT 2
96430: PUSH
96431: LD_INT 1
96433: NEG
96434: PUSH
96435: EMPTY
96436: LIST
96437: LIST
96438: PUSH
96439: LD_INT 3
96441: PUSH
96442: LD_INT 0
96444: PUSH
96445: EMPTY
96446: LIST
96447: LIST
96448: PUSH
96449: LD_INT 3
96451: PUSH
96452: LD_INT 1
96454: PUSH
96455: EMPTY
96456: LIST
96457: LIST
96458: PUSH
96459: EMPTY
96460: LIST
96461: LIST
96462: LIST
96463: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
96464: LD_ADDR_VAR 0 13
96468: PUSH
96469: LD_INT 3
96471: PUSH
96472: LD_INT 2
96474: PUSH
96475: EMPTY
96476: LIST
96477: LIST
96478: PUSH
96479: LD_INT 3
96481: PUSH
96482: LD_INT 3
96484: PUSH
96485: EMPTY
96486: LIST
96487: LIST
96488: PUSH
96489: LD_INT 2
96491: PUSH
96492: LD_INT 3
96494: PUSH
96495: EMPTY
96496: LIST
96497: LIST
96498: PUSH
96499: EMPTY
96500: LIST
96501: LIST
96502: LIST
96503: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
96504: LD_ADDR_VAR 0 14
96508: PUSH
96509: LD_INT 1
96511: PUSH
96512: LD_INT 3
96514: PUSH
96515: EMPTY
96516: LIST
96517: LIST
96518: PUSH
96519: LD_INT 0
96521: PUSH
96522: LD_INT 3
96524: PUSH
96525: EMPTY
96526: LIST
96527: LIST
96528: PUSH
96529: LD_INT 1
96531: NEG
96532: PUSH
96533: LD_INT 2
96535: PUSH
96536: EMPTY
96537: LIST
96538: LIST
96539: PUSH
96540: EMPTY
96541: LIST
96542: LIST
96543: LIST
96544: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
96545: LD_ADDR_VAR 0 15
96549: PUSH
96550: LD_INT 2
96552: NEG
96553: PUSH
96554: LD_INT 1
96556: PUSH
96557: EMPTY
96558: LIST
96559: LIST
96560: PUSH
96561: LD_INT 3
96563: NEG
96564: PUSH
96565: LD_INT 0
96567: PUSH
96568: EMPTY
96569: LIST
96570: LIST
96571: PUSH
96572: LD_INT 3
96574: NEG
96575: PUSH
96576: LD_INT 1
96578: NEG
96579: PUSH
96580: EMPTY
96581: LIST
96582: LIST
96583: PUSH
96584: EMPTY
96585: LIST
96586: LIST
96587: LIST
96588: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
96589: LD_ADDR_VAR 0 16
96593: PUSH
96594: LD_INT 2
96596: NEG
96597: PUSH
96598: LD_INT 3
96600: NEG
96601: PUSH
96602: EMPTY
96603: LIST
96604: LIST
96605: PUSH
96606: LD_INT 3
96608: NEG
96609: PUSH
96610: LD_INT 2
96612: NEG
96613: PUSH
96614: EMPTY
96615: LIST
96616: LIST
96617: PUSH
96618: LD_INT 3
96620: NEG
96621: PUSH
96622: LD_INT 3
96624: NEG
96625: PUSH
96626: EMPTY
96627: LIST
96628: LIST
96629: PUSH
96630: EMPTY
96631: LIST
96632: LIST
96633: LIST
96634: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
96635: LD_ADDR_VAR 0 17
96639: PUSH
96640: LD_INT 1
96642: NEG
96643: PUSH
96644: LD_INT 3
96646: NEG
96647: PUSH
96648: EMPTY
96649: LIST
96650: LIST
96651: PUSH
96652: LD_INT 0
96654: PUSH
96655: LD_INT 3
96657: NEG
96658: PUSH
96659: EMPTY
96660: LIST
96661: LIST
96662: PUSH
96663: LD_INT 1
96665: PUSH
96666: LD_INT 2
96668: NEG
96669: PUSH
96670: EMPTY
96671: LIST
96672: LIST
96673: PUSH
96674: EMPTY
96675: LIST
96676: LIST
96677: LIST
96678: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
96679: LD_ADDR_VAR 0 18
96683: PUSH
96684: LD_INT 2
96686: PUSH
96687: LD_INT 1
96689: NEG
96690: PUSH
96691: EMPTY
96692: LIST
96693: LIST
96694: PUSH
96695: LD_INT 3
96697: PUSH
96698: LD_INT 0
96700: PUSH
96701: EMPTY
96702: LIST
96703: LIST
96704: PUSH
96705: LD_INT 3
96707: PUSH
96708: LD_INT 1
96710: PUSH
96711: EMPTY
96712: LIST
96713: LIST
96714: PUSH
96715: EMPTY
96716: LIST
96717: LIST
96718: LIST
96719: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
96720: LD_ADDR_VAR 0 19
96724: PUSH
96725: LD_INT 3
96727: PUSH
96728: LD_INT 2
96730: PUSH
96731: EMPTY
96732: LIST
96733: LIST
96734: PUSH
96735: LD_INT 3
96737: PUSH
96738: LD_INT 3
96740: PUSH
96741: EMPTY
96742: LIST
96743: LIST
96744: PUSH
96745: LD_INT 2
96747: PUSH
96748: LD_INT 3
96750: PUSH
96751: EMPTY
96752: LIST
96753: LIST
96754: PUSH
96755: EMPTY
96756: LIST
96757: LIST
96758: LIST
96759: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
96760: LD_ADDR_VAR 0 20
96764: PUSH
96765: LD_INT 1
96767: PUSH
96768: LD_INT 3
96770: PUSH
96771: EMPTY
96772: LIST
96773: LIST
96774: PUSH
96775: LD_INT 0
96777: PUSH
96778: LD_INT 3
96780: PUSH
96781: EMPTY
96782: LIST
96783: LIST
96784: PUSH
96785: LD_INT 1
96787: NEG
96788: PUSH
96789: LD_INT 2
96791: PUSH
96792: EMPTY
96793: LIST
96794: LIST
96795: PUSH
96796: EMPTY
96797: LIST
96798: LIST
96799: LIST
96800: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
96801: LD_ADDR_VAR 0 21
96805: PUSH
96806: LD_INT 2
96808: NEG
96809: PUSH
96810: LD_INT 1
96812: PUSH
96813: EMPTY
96814: LIST
96815: LIST
96816: PUSH
96817: LD_INT 3
96819: NEG
96820: PUSH
96821: LD_INT 0
96823: PUSH
96824: EMPTY
96825: LIST
96826: LIST
96827: PUSH
96828: LD_INT 3
96830: NEG
96831: PUSH
96832: LD_INT 1
96834: NEG
96835: PUSH
96836: EMPTY
96837: LIST
96838: LIST
96839: PUSH
96840: EMPTY
96841: LIST
96842: LIST
96843: LIST
96844: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
96845: LD_ADDR_VAR 0 22
96849: PUSH
96850: LD_INT 2
96852: NEG
96853: PUSH
96854: LD_INT 3
96856: NEG
96857: PUSH
96858: EMPTY
96859: LIST
96860: LIST
96861: PUSH
96862: LD_INT 3
96864: NEG
96865: PUSH
96866: LD_INT 2
96868: NEG
96869: PUSH
96870: EMPTY
96871: LIST
96872: LIST
96873: PUSH
96874: LD_INT 3
96876: NEG
96877: PUSH
96878: LD_INT 3
96880: NEG
96881: PUSH
96882: EMPTY
96883: LIST
96884: LIST
96885: PUSH
96886: EMPTY
96887: LIST
96888: LIST
96889: LIST
96890: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
96891: LD_ADDR_VAR 0 23
96895: PUSH
96896: LD_INT 0
96898: PUSH
96899: LD_INT 3
96901: NEG
96902: PUSH
96903: EMPTY
96904: LIST
96905: LIST
96906: PUSH
96907: LD_INT 1
96909: NEG
96910: PUSH
96911: LD_INT 4
96913: NEG
96914: PUSH
96915: EMPTY
96916: LIST
96917: LIST
96918: PUSH
96919: LD_INT 1
96921: PUSH
96922: LD_INT 3
96924: NEG
96925: PUSH
96926: EMPTY
96927: LIST
96928: LIST
96929: PUSH
96930: EMPTY
96931: LIST
96932: LIST
96933: LIST
96934: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
96935: LD_ADDR_VAR 0 24
96939: PUSH
96940: LD_INT 3
96942: PUSH
96943: LD_INT 0
96945: PUSH
96946: EMPTY
96947: LIST
96948: LIST
96949: PUSH
96950: LD_INT 3
96952: PUSH
96953: LD_INT 1
96955: NEG
96956: PUSH
96957: EMPTY
96958: LIST
96959: LIST
96960: PUSH
96961: LD_INT 4
96963: PUSH
96964: LD_INT 1
96966: PUSH
96967: EMPTY
96968: LIST
96969: LIST
96970: PUSH
96971: EMPTY
96972: LIST
96973: LIST
96974: LIST
96975: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
96976: LD_ADDR_VAR 0 25
96980: PUSH
96981: LD_INT 3
96983: PUSH
96984: LD_INT 3
96986: PUSH
96987: EMPTY
96988: LIST
96989: LIST
96990: PUSH
96991: LD_INT 4
96993: PUSH
96994: LD_INT 3
96996: PUSH
96997: EMPTY
96998: LIST
96999: LIST
97000: PUSH
97001: LD_INT 3
97003: PUSH
97004: LD_INT 4
97006: PUSH
97007: EMPTY
97008: LIST
97009: LIST
97010: PUSH
97011: EMPTY
97012: LIST
97013: LIST
97014: LIST
97015: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
97016: LD_ADDR_VAR 0 26
97020: PUSH
97021: LD_INT 0
97023: PUSH
97024: LD_INT 3
97026: PUSH
97027: EMPTY
97028: LIST
97029: LIST
97030: PUSH
97031: LD_INT 1
97033: PUSH
97034: LD_INT 4
97036: PUSH
97037: EMPTY
97038: LIST
97039: LIST
97040: PUSH
97041: LD_INT 1
97043: NEG
97044: PUSH
97045: LD_INT 3
97047: PUSH
97048: EMPTY
97049: LIST
97050: LIST
97051: PUSH
97052: EMPTY
97053: LIST
97054: LIST
97055: LIST
97056: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
97057: LD_ADDR_VAR 0 27
97061: PUSH
97062: LD_INT 3
97064: NEG
97065: PUSH
97066: LD_INT 0
97068: PUSH
97069: EMPTY
97070: LIST
97071: LIST
97072: PUSH
97073: LD_INT 3
97075: NEG
97076: PUSH
97077: LD_INT 1
97079: PUSH
97080: EMPTY
97081: LIST
97082: LIST
97083: PUSH
97084: LD_INT 4
97086: NEG
97087: PUSH
97088: LD_INT 1
97090: NEG
97091: PUSH
97092: EMPTY
97093: LIST
97094: LIST
97095: PUSH
97096: EMPTY
97097: LIST
97098: LIST
97099: LIST
97100: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
97101: LD_ADDR_VAR 0 28
97105: PUSH
97106: LD_INT 3
97108: NEG
97109: PUSH
97110: LD_INT 3
97112: NEG
97113: PUSH
97114: EMPTY
97115: LIST
97116: LIST
97117: PUSH
97118: LD_INT 3
97120: NEG
97121: PUSH
97122: LD_INT 4
97124: NEG
97125: PUSH
97126: EMPTY
97127: LIST
97128: LIST
97129: PUSH
97130: LD_INT 4
97132: NEG
97133: PUSH
97134: LD_INT 3
97136: NEG
97137: PUSH
97138: EMPTY
97139: LIST
97140: LIST
97141: PUSH
97142: EMPTY
97143: LIST
97144: LIST
97145: LIST
97146: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
97147: LD_ADDR_VAR 0 29
97151: PUSH
97152: LD_INT 1
97154: NEG
97155: PUSH
97156: LD_INT 3
97158: NEG
97159: PUSH
97160: EMPTY
97161: LIST
97162: LIST
97163: PUSH
97164: LD_INT 0
97166: PUSH
97167: LD_INT 3
97169: NEG
97170: PUSH
97171: EMPTY
97172: LIST
97173: LIST
97174: PUSH
97175: LD_INT 1
97177: PUSH
97178: LD_INT 2
97180: NEG
97181: PUSH
97182: EMPTY
97183: LIST
97184: LIST
97185: PUSH
97186: LD_INT 1
97188: NEG
97189: PUSH
97190: LD_INT 4
97192: NEG
97193: PUSH
97194: EMPTY
97195: LIST
97196: LIST
97197: PUSH
97198: LD_INT 0
97200: PUSH
97201: LD_INT 4
97203: NEG
97204: PUSH
97205: EMPTY
97206: LIST
97207: LIST
97208: PUSH
97209: LD_INT 1
97211: PUSH
97212: LD_INT 3
97214: NEG
97215: PUSH
97216: EMPTY
97217: LIST
97218: LIST
97219: PUSH
97220: LD_INT 1
97222: NEG
97223: PUSH
97224: LD_INT 5
97226: NEG
97227: PUSH
97228: EMPTY
97229: LIST
97230: LIST
97231: PUSH
97232: LD_INT 0
97234: PUSH
97235: LD_INT 5
97237: NEG
97238: PUSH
97239: EMPTY
97240: LIST
97241: LIST
97242: PUSH
97243: LD_INT 1
97245: PUSH
97246: LD_INT 4
97248: NEG
97249: PUSH
97250: EMPTY
97251: LIST
97252: LIST
97253: PUSH
97254: LD_INT 1
97256: NEG
97257: PUSH
97258: LD_INT 6
97260: NEG
97261: PUSH
97262: EMPTY
97263: LIST
97264: LIST
97265: PUSH
97266: LD_INT 0
97268: PUSH
97269: LD_INT 6
97271: NEG
97272: PUSH
97273: EMPTY
97274: LIST
97275: LIST
97276: PUSH
97277: LD_INT 1
97279: PUSH
97280: LD_INT 5
97282: NEG
97283: PUSH
97284: EMPTY
97285: LIST
97286: LIST
97287: PUSH
97288: EMPTY
97289: LIST
97290: LIST
97291: LIST
97292: LIST
97293: LIST
97294: LIST
97295: LIST
97296: LIST
97297: LIST
97298: LIST
97299: LIST
97300: LIST
97301: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
97302: LD_ADDR_VAR 0 30
97306: PUSH
97307: LD_INT 2
97309: PUSH
97310: LD_INT 1
97312: NEG
97313: PUSH
97314: EMPTY
97315: LIST
97316: LIST
97317: PUSH
97318: LD_INT 3
97320: PUSH
97321: LD_INT 0
97323: PUSH
97324: EMPTY
97325: LIST
97326: LIST
97327: PUSH
97328: LD_INT 3
97330: PUSH
97331: LD_INT 1
97333: PUSH
97334: EMPTY
97335: LIST
97336: LIST
97337: PUSH
97338: LD_INT 3
97340: PUSH
97341: LD_INT 1
97343: NEG
97344: PUSH
97345: EMPTY
97346: LIST
97347: LIST
97348: PUSH
97349: LD_INT 4
97351: PUSH
97352: LD_INT 0
97354: PUSH
97355: EMPTY
97356: LIST
97357: LIST
97358: PUSH
97359: LD_INT 4
97361: PUSH
97362: LD_INT 1
97364: PUSH
97365: EMPTY
97366: LIST
97367: LIST
97368: PUSH
97369: LD_INT 4
97371: PUSH
97372: LD_INT 1
97374: NEG
97375: PUSH
97376: EMPTY
97377: LIST
97378: LIST
97379: PUSH
97380: LD_INT 5
97382: PUSH
97383: LD_INT 0
97385: PUSH
97386: EMPTY
97387: LIST
97388: LIST
97389: PUSH
97390: LD_INT 5
97392: PUSH
97393: LD_INT 1
97395: PUSH
97396: EMPTY
97397: LIST
97398: LIST
97399: PUSH
97400: LD_INT 5
97402: PUSH
97403: LD_INT 1
97405: NEG
97406: PUSH
97407: EMPTY
97408: LIST
97409: LIST
97410: PUSH
97411: LD_INT 6
97413: PUSH
97414: LD_INT 0
97416: PUSH
97417: EMPTY
97418: LIST
97419: LIST
97420: PUSH
97421: LD_INT 6
97423: PUSH
97424: LD_INT 1
97426: PUSH
97427: EMPTY
97428: LIST
97429: LIST
97430: PUSH
97431: EMPTY
97432: LIST
97433: LIST
97434: LIST
97435: LIST
97436: LIST
97437: LIST
97438: LIST
97439: LIST
97440: LIST
97441: LIST
97442: LIST
97443: LIST
97444: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
97445: LD_ADDR_VAR 0 31
97449: PUSH
97450: LD_INT 3
97452: PUSH
97453: LD_INT 2
97455: PUSH
97456: EMPTY
97457: LIST
97458: LIST
97459: PUSH
97460: LD_INT 3
97462: PUSH
97463: LD_INT 3
97465: PUSH
97466: EMPTY
97467: LIST
97468: LIST
97469: PUSH
97470: LD_INT 2
97472: PUSH
97473: LD_INT 3
97475: PUSH
97476: EMPTY
97477: LIST
97478: LIST
97479: PUSH
97480: LD_INT 4
97482: PUSH
97483: LD_INT 3
97485: PUSH
97486: EMPTY
97487: LIST
97488: LIST
97489: PUSH
97490: LD_INT 4
97492: PUSH
97493: LD_INT 4
97495: PUSH
97496: EMPTY
97497: LIST
97498: LIST
97499: PUSH
97500: LD_INT 3
97502: PUSH
97503: LD_INT 4
97505: PUSH
97506: EMPTY
97507: LIST
97508: LIST
97509: PUSH
97510: LD_INT 5
97512: PUSH
97513: LD_INT 4
97515: PUSH
97516: EMPTY
97517: LIST
97518: LIST
97519: PUSH
97520: LD_INT 5
97522: PUSH
97523: LD_INT 5
97525: PUSH
97526: EMPTY
97527: LIST
97528: LIST
97529: PUSH
97530: LD_INT 4
97532: PUSH
97533: LD_INT 5
97535: PUSH
97536: EMPTY
97537: LIST
97538: LIST
97539: PUSH
97540: LD_INT 6
97542: PUSH
97543: LD_INT 5
97545: PUSH
97546: EMPTY
97547: LIST
97548: LIST
97549: PUSH
97550: LD_INT 6
97552: PUSH
97553: LD_INT 6
97555: PUSH
97556: EMPTY
97557: LIST
97558: LIST
97559: PUSH
97560: LD_INT 5
97562: PUSH
97563: LD_INT 6
97565: PUSH
97566: EMPTY
97567: LIST
97568: LIST
97569: PUSH
97570: EMPTY
97571: LIST
97572: LIST
97573: LIST
97574: LIST
97575: LIST
97576: LIST
97577: LIST
97578: LIST
97579: LIST
97580: LIST
97581: LIST
97582: LIST
97583: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
97584: LD_ADDR_VAR 0 32
97588: PUSH
97589: LD_INT 1
97591: PUSH
97592: LD_INT 3
97594: PUSH
97595: EMPTY
97596: LIST
97597: LIST
97598: PUSH
97599: LD_INT 0
97601: PUSH
97602: LD_INT 3
97604: PUSH
97605: EMPTY
97606: LIST
97607: LIST
97608: PUSH
97609: LD_INT 1
97611: NEG
97612: PUSH
97613: LD_INT 2
97615: PUSH
97616: EMPTY
97617: LIST
97618: LIST
97619: PUSH
97620: LD_INT 1
97622: PUSH
97623: LD_INT 4
97625: PUSH
97626: EMPTY
97627: LIST
97628: LIST
97629: PUSH
97630: LD_INT 0
97632: PUSH
97633: LD_INT 4
97635: PUSH
97636: EMPTY
97637: LIST
97638: LIST
97639: PUSH
97640: LD_INT 1
97642: NEG
97643: PUSH
97644: LD_INT 3
97646: PUSH
97647: EMPTY
97648: LIST
97649: LIST
97650: PUSH
97651: LD_INT 1
97653: PUSH
97654: LD_INT 5
97656: PUSH
97657: EMPTY
97658: LIST
97659: LIST
97660: PUSH
97661: LD_INT 0
97663: PUSH
97664: LD_INT 5
97666: PUSH
97667: EMPTY
97668: LIST
97669: LIST
97670: PUSH
97671: LD_INT 1
97673: NEG
97674: PUSH
97675: LD_INT 4
97677: PUSH
97678: EMPTY
97679: LIST
97680: LIST
97681: PUSH
97682: LD_INT 1
97684: PUSH
97685: LD_INT 6
97687: PUSH
97688: EMPTY
97689: LIST
97690: LIST
97691: PUSH
97692: LD_INT 0
97694: PUSH
97695: LD_INT 6
97697: PUSH
97698: EMPTY
97699: LIST
97700: LIST
97701: PUSH
97702: LD_INT 1
97704: NEG
97705: PUSH
97706: LD_INT 5
97708: PUSH
97709: EMPTY
97710: LIST
97711: LIST
97712: PUSH
97713: EMPTY
97714: LIST
97715: LIST
97716: LIST
97717: LIST
97718: LIST
97719: LIST
97720: LIST
97721: LIST
97722: LIST
97723: LIST
97724: LIST
97725: LIST
97726: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
97727: LD_ADDR_VAR 0 33
97731: PUSH
97732: LD_INT 2
97734: NEG
97735: PUSH
97736: LD_INT 1
97738: PUSH
97739: EMPTY
97740: LIST
97741: LIST
97742: PUSH
97743: LD_INT 3
97745: NEG
97746: PUSH
97747: LD_INT 0
97749: PUSH
97750: EMPTY
97751: LIST
97752: LIST
97753: PUSH
97754: LD_INT 3
97756: NEG
97757: PUSH
97758: LD_INT 1
97760: NEG
97761: PUSH
97762: EMPTY
97763: LIST
97764: LIST
97765: PUSH
97766: LD_INT 3
97768: NEG
97769: PUSH
97770: LD_INT 1
97772: PUSH
97773: EMPTY
97774: LIST
97775: LIST
97776: PUSH
97777: LD_INT 4
97779: NEG
97780: PUSH
97781: LD_INT 0
97783: PUSH
97784: EMPTY
97785: LIST
97786: LIST
97787: PUSH
97788: LD_INT 4
97790: NEG
97791: PUSH
97792: LD_INT 1
97794: NEG
97795: PUSH
97796: EMPTY
97797: LIST
97798: LIST
97799: PUSH
97800: LD_INT 4
97802: NEG
97803: PUSH
97804: LD_INT 1
97806: PUSH
97807: EMPTY
97808: LIST
97809: LIST
97810: PUSH
97811: LD_INT 5
97813: NEG
97814: PUSH
97815: LD_INT 0
97817: PUSH
97818: EMPTY
97819: LIST
97820: LIST
97821: PUSH
97822: LD_INT 5
97824: NEG
97825: PUSH
97826: LD_INT 1
97828: NEG
97829: PUSH
97830: EMPTY
97831: LIST
97832: LIST
97833: PUSH
97834: LD_INT 5
97836: NEG
97837: PUSH
97838: LD_INT 1
97840: PUSH
97841: EMPTY
97842: LIST
97843: LIST
97844: PUSH
97845: LD_INT 6
97847: NEG
97848: PUSH
97849: LD_INT 0
97851: PUSH
97852: EMPTY
97853: LIST
97854: LIST
97855: PUSH
97856: LD_INT 6
97858: NEG
97859: PUSH
97860: LD_INT 1
97862: NEG
97863: PUSH
97864: EMPTY
97865: LIST
97866: LIST
97867: PUSH
97868: EMPTY
97869: LIST
97870: LIST
97871: LIST
97872: LIST
97873: LIST
97874: LIST
97875: LIST
97876: LIST
97877: LIST
97878: LIST
97879: LIST
97880: LIST
97881: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
97882: LD_ADDR_VAR 0 34
97886: PUSH
97887: LD_INT 2
97889: NEG
97890: PUSH
97891: LD_INT 3
97893: NEG
97894: PUSH
97895: EMPTY
97896: LIST
97897: LIST
97898: PUSH
97899: LD_INT 3
97901: NEG
97902: PUSH
97903: LD_INT 2
97905: NEG
97906: PUSH
97907: EMPTY
97908: LIST
97909: LIST
97910: PUSH
97911: LD_INT 3
97913: NEG
97914: PUSH
97915: LD_INT 3
97917: NEG
97918: PUSH
97919: EMPTY
97920: LIST
97921: LIST
97922: PUSH
97923: LD_INT 3
97925: NEG
97926: PUSH
97927: LD_INT 4
97929: NEG
97930: PUSH
97931: EMPTY
97932: LIST
97933: LIST
97934: PUSH
97935: LD_INT 4
97937: NEG
97938: PUSH
97939: LD_INT 3
97941: NEG
97942: PUSH
97943: EMPTY
97944: LIST
97945: LIST
97946: PUSH
97947: LD_INT 4
97949: NEG
97950: PUSH
97951: LD_INT 4
97953: NEG
97954: PUSH
97955: EMPTY
97956: LIST
97957: LIST
97958: PUSH
97959: LD_INT 4
97961: NEG
97962: PUSH
97963: LD_INT 5
97965: NEG
97966: PUSH
97967: EMPTY
97968: LIST
97969: LIST
97970: PUSH
97971: LD_INT 5
97973: NEG
97974: PUSH
97975: LD_INT 4
97977: NEG
97978: PUSH
97979: EMPTY
97980: LIST
97981: LIST
97982: PUSH
97983: LD_INT 5
97985: NEG
97986: PUSH
97987: LD_INT 5
97989: NEG
97990: PUSH
97991: EMPTY
97992: LIST
97993: LIST
97994: PUSH
97995: LD_INT 5
97997: NEG
97998: PUSH
97999: LD_INT 6
98001: NEG
98002: PUSH
98003: EMPTY
98004: LIST
98005: LIST
98006: PUSH
98007: LD_INT 6
98009: NEG
98010: PUSH
98011: LD_INT 5
98013: NEG
98014: PUSH
98015: EMPTY
98016: LIST
98017: LIST
98018: PUSH
98019: LD_INT 6
98021: NEG
98022: PUSH
98023: LD_INT 6
98025: NEG
98026: PUSH
98027: EMPTY
98028: LIST
98029: LIST
98030: PUSH
98031: EMPTY
98032: LIST
98033: LIST
98034: LIST
98035: LIST
98036: LIST
98037: LIST
98038: LIST
98039: LIST
98040: LIST
98041: LIST
98042: LIST
98043: LIST
98044: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
98045: LD_ADDR_VAR 0 41
98049: PUSH
98050: LD_INT 0
98052: PUSH
98053: LD_INT 2
98055: NEG
98056: PUSH
98057: EMPTY
98058: LIST
98059: LIST
98060: PUSH
98061: LD_INT 1
98063: NEG
98064: PUSH
98065: LD_INT 3
98067: NEG
98068: PUSH
98069: EMPTY
98070: LIST
98071: LIST
98072: PUSH
98073: LD_INT 1
98075: PUSH
98076: LD_INT 2
98078: NEG
98079: PUSH
98080: EMPTY
98081: LIST
98082: LIST
98083: PUSH
98084: EMPTY
98085: LIST
98086: LIST
98087: LIST
98088: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
98089: LD_ADDR_VAR 0 42
98093: PUSH
98094: LD_INT 2
98096: PUSH
98097: LD_INT 0
98099: PUSH
98100: EMPTY
98101: LIST
98102: LIST
98103: PUSH
98104: LD_INT 2
98106: PUSH
98107: LD_INT 1
98109: NEG
98110: PUSH
98111: EMPTY
98112: LIST
98113: LIST
98114: PUSH
98115: LD_INT 3
98117: PUSH
98118: LD_INT 1
98120: PUSH
98121: EMPTY
98122: LIST
98123: LIST
98124: PUSH
98125: EMPTY
98126: LIST
98127: LIST
98128: LIST
98129: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
98130: LD_ADDR_VAR 0 43
98134: PUSH
98135: LD_INT 2
98137: PUSH
98138: LD_INT 2
98140: PUSH
98141: EMPTY
98142: LIST
98143: LIST
98144: PUSH
98145: LD_INT 3
98147: PUSH
98148: LD_INT 2
98150: PUSH
98151: EMPTY
98152: LIST
98153: LIST
98154: PUSH
98155: LD_INT 2
98157: PUSH
98158: LD_INT 3
98160: PUSH
98161: EMPTY
98162: LIST
98163: LIST
98164: PUSH
98165: EMPTY
98166: LIST
98167: LIST
98168: LIST
98169: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
98170: LD_ADDR_VAR 0 44
98174: PUSH
98175: LD_INT 0
98177: PUSH
98178: LD_INT 2
98180: PUSH
98181: EMPTY
98182: LIST
98183: LIST
98184: PUSH
98185: LD_INT 1
98187: PUSH
98188: LD_INT 3
98190: PUSH
98191: EMPTY
98192: LIST
98193: LIST
98194: PUSH
98195: LD_INT 1
98197: NEG
98198: PUSH
98199: LD_INT 2
98201: PUSH
98202: EMPTY
98203: LIST
98204: LIST
98205: PUSH
98206: EMPTY
98207: LIST
98208: LIST
98209: LIST
98210: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
98211: LD_ADDR_VAR 0 45
98215: PUSH
98216: LD_INT 2
98218: NEG
98219: PUSH
98220: LD_INT 0
98222: PUSH
98223: EMPTY
98224: LIST
98225: LIST
98226: PUSH
98227: LD_INT 2
98229: NEG
98230: PUSH
98231: LD_INT 1
98233: PUSH
98234: EMPTY
98235: LIST
98236: LIST
98237: PUSH
98238: LD_INT 3
98240: NEG
98241: PUSH
98242: LD_INT 1
98244: NEG
98245: PUSH
98246: EMPTY
98247: LIST
98248: LIST
98249: PUSH
98250: EMPTY
98251: LIST
98252: LIST
98253: LIST
98254: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
98255: LD_ADDR_VAR 0 46
98259: PUSH
98260: LD_INT 2
98262: NEG
98263: PUSH
98264: LD_INT 2
98266: NEG
98267: PUSH
98268: EMPTY
98269: LIST
98270: LIST
98271: PUSH
98272: LD_INT 2
98274: NEG
98275: PUSH
98276: LD_INT 3
98278: NEG
98279: PUSH
98280: EMPTY
98281: LIST
98282: LIST
98283: PUSH
98284: LD_INT 3
98286: NEG
98287: PUSH
98288: LD_INT 2
98290: NEG
98291: PUSH
98292: EMPTY
98293: LIST
98294: LIST
98295: PUSH
98296: EMPTY
98297: LIST
98298: LIST
98299: LIST
98300: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
98301: LD_ADDR_VAR 0 47
98305: PUSH
98306: LD_INT 2
98308: NEG
98309: PUSH
98310: LD_INT 3
98312: NEG
98313: PUSH
98314: EMPTY
98315: LIST
98316: LIST
98317: PUSH
98318: LD_INT 1
98320: NEG
98321: PUSH
98322: LD_INT 3
98324: NEG
98325: PUSH
98326: EMPTY
98327: LIST
98328: LIST
98329: PUSH
98330: EMPTY
98331: LIST
98332: LIST
98333: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
98334: LD_ADDR_VAR 0 48
98338: PUSH
98339: LD_INT 1
98341: PUSH
98342: LD_INT 2
98344: NEG
98345: PUSH
98346: EMPTY
98347: LIST
98348: LIST
98349: PUSH
98350: LD_INT 2
98352: PUSH
98353: LD_INT 1
98355: NEG
98356: PUSH
98357: EMPTY
98358: LIST
98359: LIST
98360: PUSH
98361: EMPTY
98362: LIST
98363: LIST
98364: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
98365: LD_ADDR_VAR 0 49
98369: PUSH
98370: LD_INT 3
98372: PUSH
98373: LD_INT 1
98375: PUSH
98376: EMPTY
98377: LIST
98378: LIST
98379: PUSH
98380: LD_INT 3
98382: PUSH
98383: LD_INT 2
98385: PUSH
98386: EMPTY
98387: LIST
98388: LIST
98389: PUSH
98390: EMPTY
98391: LIST
98392: LIST
98393: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
98394: LD_ADDR_VAR 0 50
98398: PUSH
98399: LD_INT 2
98401: PUSH
98402: LD_INT 3
98404: PUSH
98405: EMPTY
98406: LIST
98407: LIST
98408: PUSH
98409: LD_INT 1
98411: PUSH
98412: LD_INT 3
98414: PUSH
98415: EMPTY
98416: LIST
98417: LIST
98418: PUSH
98419: EMPTY
98420: LIST
98421: LIST
98422: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
98423: LD_ADDR_VAR 0 51
98427: PUSH
98428: LD_INT 1
98430: NEG
98431: PUSH
98432: LD_INT 2
98434: PUSH
98435: EMPTY
98436: LIST
98437: LIST
98438: PUSH
98439: LD_INT 2
98441: NEG
98442: PUSH
98443: LD_INT 1
98445: PUSH
98446: EMPTY
98447: LIST
98448: LIST
98449: PUSH
98450: EMPTY
98451: LIST
98452: LIST
98453: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
98454: LD_ADDR_VAR 0 52
98458: PUSH
98459: LD_INT 3
98461: NEG
98462: PUSH
98463: LD_INT 1
98465: NEG
98466: PUSH
98467: EMPTY
98468: LIST
98469: LIST
98470: PUSH
98471: LD_INT 3
98473: NEG
98474: PUSH
98475: LD_INT 2
98477: NEG
98478: PUSH
98479: EMPTY
98480: LIST
98481: LIST
98482: PUSH
98483: EMPTY
98484: LIST
98485: LIST
98486: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
98487: LD_ADDR_VAR 0 53
98491: PUSH
98492: LD_INT 1
98494: NEG
98495: PUSH
98496: LD_INT 3
98498: NEG
98499: PUSH
98500: EMPTY
98501: LIST
98502: LIST
98503: PUSH
98504: LD_INT 0
98506: PUSH
98507: LD_INT 3
98509: NEG
98510: PUSH
98511: EMPTY
98512: LIST
98513: LIST
98514: PUSH
98515: LD_INT 1
98517: PUSH
98518: LD_INT 2
98520: NEG
98521: PUSH
98522: EMPTY
98523: LIST
98524: LIST
98525: PUSH
98526: EMPTY
98527: LIST
98528: LIST
98529: LIST
98530: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
98531: LD_ADDR_VAR 0 54
98535: PUSH
98536: LD_INT 2
98538: PUSH
98539: LD_INT 1
98541: NEG
98542: PUSH
98543: EMPTY
98544: LIST
98545: LIST
98546: PUSH
98547: LD_INT 3
98549: PUSH
98550: LD_INT 0
98552: PUSH
98553: EMPTY
98554: LIST
98555: LIST
98556: PUSH
98557: LD_INT 3
98559: PUSH
98560: LD_INT 1
98562: PUSH
98563: EMPTY
98564: LIST
98565: LIST
98566: PUSH
98567: EMPTY
98568: LIST
98569: LIST
98570: LIST
98571: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
98572: LD_ADDR_VAR 0 55
98576: PUSH
98577: LD_INT 3
98579: PUSH
98580: LD_INT 2
98582: PUSH
98583: EMPTY
98584: LIST
98585: LIST
98586: PUSH
98587: LD_INT 3
98589: PUSH
98590: LD_INT 3
98592: PUSH
98593: EMPTY
98594: LIST
98595: LIST
98596: PUSH
98597: LD_INT 2
98599: PUSH
98600: LD_INT 3
98602: PUSH
98603: EMPTY
98604: LIST
98605: LIST
98606: PUSH
98607: EMPTY
98608: LIST
98609: LIST
98610: LIST
98611: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
98612: LD_ADDR_VAR 0 56
98616: PUSH
98617: LD_INT 1
98619: PUSH
98620: LD_INT 3
98622: PUSH
98623: EMPTY
98624: LIST
98625: LIST
98626: PUSH
98627: LD_INT 0
98629: PUSH
98630: LD_INT 3
98632: PUSH
98633: EMPTY
98634: LIST
98635: LIST
98636: PUSH
98637: LD_INT 1
98639: NEG
98640: PUSH
98641: LD_INT 2
98643: PUSH
98644: EMPTY
98645: LIST
98646: LIST
98647: PUSH
98648: EMPTY
98649: LIST
98650: LIST
98651: LIST
98652: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
98653: LD_ADDR_VAR 0 57
98657: PUSH
98658: LD_INT 2
98660: NEG
98661: PUSH
98662: LD_INT 1
98664: PUSH
98665: EMPTY
98666: LIST
98667: LIST
98668: PUSH
98669: LD_INT 3
98671: NEG
98672: PUSH
98673: LD_INT 0
98675: PUSH
98676: EMPTY
98677: LIST
98678: LIST
98679: PUSH
98680: LD_INT 3
98682: NEG
98683: PUSH
98684: LD_INT 1
98686: NEG
98687: PUSH
98688: EMPTY
98689: LIST
98690: LIST
98691: PUSH
98692: EMPTY
98693: LIST
98694: LIST
98695: LIST
98696: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
98697: LD_ADDR_VAR 0 58
98701: PUSH
98702: LD_INT 2
98704: NEG
98705: PUSH
98706: LD_INT 3
98708: NEG
98709: PUSH
98710: EMPTY
98711: LIST
98712: LIST
98713: PUSH
98714: LD_INT 3
98716: NEG
98717: PUSH
98718: LD_INT 2
98720: NEG
98721: PUSH
98722: EMPTY
98723: LIST
98724: LIST
98725: PUSH
98726: LD_INT 3
98728: NEG
98729: PUSH
98730: LD_INT 3
98732: NEG
98733: PUSH
98734: EMPTY
98735: LIST
98736: LIST
98737: PUSH
98738: EMPTY
98739: LIST
98740: LIST
98741: LIST
98742: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
98743: LD_ADDR_VAR 0 59
98747: PUSH
98748: LD_INT 1
98750: NEG
98751: PUSH
98752: LD_INT 2
98754: NEG
98755: PUSH
98756: EMPTY
98757: LIST
98758: LIST
98759: PUSH
98760: LD_INT 0
98762: PUSH
98763: LD_INT 2
98765: NEG
98766: PUSH
98767: EMPTY
98768: LIST
98769: LIST
98770: PUSH
98771: LD_INT 1
98773: PUSH
98774: LD_INT 1
98776: NEG
98777: PUSH
98778: EMPTY
98779: LIST
98780: LIST
98781: PUSH
98782: EMPTY
98783: LIST
98784: LIST
98785: LIST
98786: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
98787: LD_ADDR_VAR 0 60
98791: PUSH
98792: LD_INT 1
98794: PUSH
98795: LD_INT 1
98797: NEG
98798: PUSH
98799: EMPTY
98800: LIST
98801: LIST
98802: PUSH
98803: LD_INT 2
98805: PUSH
98806: LD_INT 0
98808: PUSH
98809: EMPTY
98810: LIST
98811: LIST
98812: PUSH
98813: LD_INT 2
98815: PUSH
98816: LD_INT 1
98818: PUSH
98819: EMPTY
98820: LIST
98821: LIST
98822: PUSH
98823: EMPTY
98824: LIST
98825: LIST
98826: LIST
98827: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
98828: LD_ADDR_VAR 0 61
98832: PUSH
98833: LD_INT 2
98835: PUSH
98836: LD_INT 1
98838: PUSH
98839: EMPTY
98840: LIST
98841: LIST
98842: PUSH
98843: LD_INT 2
98845: PUSH
98846: LD_INT 2
98848: PUSH
98849: EMPTY
98850: LIST
98851: LIST
98852: PUSH
98853: LD_INT 1
98855: PUSH
98856: LD_INT 2
98858: PUSH
98859: EMPTY
98860: LIST
98861: LIST
98862: PUSH
98863: EMPTY
98864: LIST
98865: LIST
98866: LIST
98867: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
98868: LD_ADDR_VAR 0 62
98872: PUSH
98873: LD_INT 1
98875: PUSH
98876: LD_INT 2
98878: PUSH
98879: EMPTY
98880: LIST
98881: LIST
98882: PUSH
98883: LD_INT 0
98885: PUSH
98886: LD_INT 2
98888: PUSH
98889: EMPTY
98890: LIST
98891: LIST
98892: PUSH
98893: LD_INT 1
98895: NEG
98896: PUSH
98897: LD_INT 1
98899: PUSH
98900: EMPTY
98901: LIST
98902: LIST
98903: PUSH
98904: EMPTY
98905: LIST
98906: LIST
98907: LIST
98908: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
98909: LD_ADDR_VAR 0 63
98913: PUSH
98914: LD_INT 1
98916: NEG
98917: PUSH
98918: LD_INT 1
98920: PUSH
98921: EMPTY
98922: LIST
98923: LIST
98924: PUSH
98925: LD_INT 2
98927: NEG
98928: PUSH
98929: LD_INT 0
98931: PUSH
98932: EMPTY
98933: LIST
98934: LIST
98935: PUSH
98936: LD_INT 2
98938: NEG
98939: PUSH
98940: LD_INT 1
98942: NEG
98943: PUSH
98944: EMPTY
98945: LIST
98946: LIST
98947: PUSH
98948: EMPTY
98949: LIST
98950: LIST
98951: LIST
98952: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
98953: LD_ADDR_VAR 0 64
98957: PUSH
98958: LD_INT 1
98960: NEG
98961: PUSH
98962: LD_INT 2
98964: NEG
98965: PUSH
98966: EMPTY
98967: LIST
98968: LIST
98969: PUSH
98970: LD_INT 2
98972: NEG
98973: PUSH
98974: LD_INT 1
98976: NEG
98977: PUSH
98978: EMPTY
98979: LIST
98980: LIST
98981: PUSH
98982: LD_INT 2
98984: NEG
98985: PUSH
98986: LD_INT 2
98988: NEG
98989: PUSH
98990: EMPTY
98991: LIST
98992: LIST
98993: PUSH
98994: EMPTY
98995: LIST
98996: LIST
98997: LIST
98998: ST_TO_ADDR
// end ; 2 :
98999: GO 102265
99001: LD_INT 2
99003: DOUBLE
99004: EQUAL
99005: IFTRUE 99009
99007: GO 102264
99009: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
99010: LD_ADDR_VAR 0 29
99014: PUSH
99015: LD_INT 4
99017: PUSH
99018: LD_INT 0
99020: PUSH
99021: EMPTY
99022: LIST
99023: LIST
99024: PUSH
99025: LD_INT 4
99027: PUSH
99028: LD_INT 1
99030: NEG
99031: PUSH
99032: EMPTY
99033: LIST
99034: LIST
99035: PUSH
99036: LD_INT 5
99038: PUSH
99039: LD_INT 0
99041: PUSH
99042: EMPTY
99043: LIST
99044: LIST
99045: PUSH
99046: LD_INT 5
99048: PUSH
99049: LD_INT 1
99051: PUSH
99052: EMPTY
99053: LIST
99054: LIST
99055: PUSH
99056: LD_INT 4
99058: PUSH
99059: LD_INT 1
99061: PUSH
99062: EMPTY
99063: LIST
99064: LIST
99065: PUSH
99066: LD_INT 3
99068: PUSH
99069: LD_INT 0
99071: PUSH
99072: EMPTY
99073: LIST
99074: LIST
99075: PUSH
99076: LD_INT 3
99078: PUSH
99079: LD_INT 1
99081: NEG
99082: PUSH
99083: EMPTY
99084: LIST
99085: LIST
99086: PUSH
99087: LD_INT 3
99089: PUSH
99090: LD_INT 2
99092: NEG
99093: PUSH
99094: EMPTY
99095: LIST
99096: LIST
99097: PUSH
99098: LD_INT 5
99100: PUSH
99101: LD_INT 2
99103: PUSH
99104: EMPTY
99105: LIST
99106: LIST
99107: PUSH
99108: LD_INT 3
99110: PUSH
99111: LD_INT 3
99113: PUSH
99114: EMPTY
99115: LIST
99116: LIST
99117: PUSH
99118: LD_INT 3
99120: PUSH
99121: LD_INT 2
99123: PUSH
99124: EMPTY
99125: LIST
99126: LIST
99127: PUSH
99128: LD_INT 4
99130: PUSH
99131: LD_INT 3
99133: PUSH
99134: EMPTY
99135: LIST
99136: LIST
99137: PUSH
99138: LD_INT 4
99140: PUSH
99141: LD_INT 4
99143: PUSH
99144: EMPTY
99145: LIST
99146: LIST
99147: PUSH
99148: LD_INT 3
99150: PUSH
99151: LD_INT 4
99153: PUSH
99154: EMPTY
99155: LIST
99156: LIST
99157: PUSH
99158: LD_INT 2
99160: PUSH
99161: LD_INT 3
99163: PUSH
99164: EMPTY
99165: LIST
99166: LIST
99167: PUSH
99168: LD_INT 2
99170: PUSH
99171: LD_INT 2
99173: PUSH
99174: EMPTY
99175: LIST
99176: LIST
99177: PUSH
99178: LD_INT 4
99180: PUSH
99181: LD_INT 2
99183: PUSH
99184: EMPTY
99185: LIST
99186: LIST
99187: PUSH
99188: LD_INT 2
99190: PUSH
99191: LD_INT 4
99193: PUSH
99194: EMPTY
99195: LIST
99196: LIST
99197: PUSH
99198: LD_INT 0
99200: PUSH
99201: LD_INT 4
99203: PUSH
99204: EMPTY
99205: LIST
99206: LIST
99207: PUSH
99208: LD_INT 0
99210: PUSH
99211: LD_INT 3
99213: PUSH
99214: EMPTY
99215: LIST
99216: LIST
99217: PUSH
99218: LD_INT 1
99220: PUSH
99221: LD_INT 4
99223: PUSH
99224: EMPTY
99225: LIST
99226: LIST
99227: PUSH
99228: LD_INT 1
99230: PUSH
99231: LD_INT 5
99233: PUSH
99234: EMPTY
99235: LIST
99236: LIST
99237: PUSH
99238: LD_INT 0
99240: PUSH
99241: LD_INT 5
99243: PUSH
99244: EMPTY
99245: LIST
99246: LIST
99247: PUSH
99248: LD_INT 1
99250: NEG
99251: PUSH
99252: LD_INT 4
99254: PUSH
99255: EMPTY
99256: LIST
99257: LIST
99258: PUSH
99259: LD_INT 1
99261: NEG
99262: PUSH
99263: LD_INT 3
99265: PUSH
99266: EMPTY
99267: LIST
99268: LIST
99269: PUSH
99270: LD_INT 2
99272: PUSH
99273: LD_INT 5
99275: PUSH
99276: EMPTY
99277: LIST
99278: LIST
99279: PUSH
99280: LD_INT 2
99282: NEG
99283: PUSH
99284: LD_INT 3
99286: PUSH
99287: EMPTY
99288: LIST
99289: LIST
99290: PUSH
99291: LD_INT 3
99293: NEG
99294: PUSH
99295: LD_INT 0
99297: PUSH
99298: EMPTY
99299: LIST
99300: LIST
99301: PUSH
99302: LD_INT 3
99304: NEG
99305: PUSH
99306: LD_INT 1
99308: NEG
99309: PUSH
99310: EMPTY
99311: LIST
99312: LIST
99313: PUSH
99314: LD_INT 2
99316: NEG
99317: PUSH
99318: LD_INT 0
99320: PUSH
99321: EMPTY
99322: LIST
99323: LIST
99324: PUSH
99325: LD_INT 2
99327: NEG
99328: PUSH
99329: LD_INT 1
99331: PUSH
99332: EMPTY
99333: LIST
99334: LIST
99335: PUSH
99336: LD_INT 3
99338: NEG
99339: PUSH
99340: LD_INT 1
99342: PUSH
99343: EMPTY
99344: LIST
99345: LIST
99346: PUSH
99347: LD_INT 4
99349: NEG
99350: PUSH
99351: LD_INT 0
99353: PUSH
99354: EMPTY
99355: LIST
99356: LIST
99357: PUSH
99358: LD_INT 4
99360: NEG
99361: PUSH
99362: LD_INT 1
99364: NEG
99365: PUSH
99366: EMPTY
99367: LIST
99368: LIST
99369: PUSH
99370: LD_INT 4
99372: NEG
99373: PUSH
99374: LD_INT 2
99376: NEG
99377: PUSH
99378: EMPTY
99379: LIST
99380: LIST
99381: PUSH
99382: LD_INT 2
99384: NEG
99385: PUSH
99386: LD_INT 2
99388: PUSH
99389: EMPTY
99390: LIST
99391: LIST
99392: PUSH
99393: LD_INT 4
99395: NEG
99396: PUSH
99397: LD_INT 4
99399: NEG
99400: PUSH
99401: EMPTY
99402: LIST
99403: LIST
99404: PUSH
99405: LD_INT 4
99407: NEG
99408: PUSH
99409: LD_INT 5
99411: NEG
99412: PUSH
99413: EMPTY
99414: LIST
99415: LIST
99416: PUSH
99417: LD_INT 3
99419: NEG
99420: PUSH
99421: LD_INT 4
99423: NEG
99424: PUSH
99425: EMPTY
99426: LIST
99427: LIST
99428: PUSH
99429: LD_INT 3
99431: NEG
99432: PUSH
99433: LD_INT 3
99435: NEG
99436: PUSH
99437: EMPTY
99438: LIST
99439: LIST
99440: PUSH
99441: LD_INT 4
99443: NEG
99444: PUSH
99445: LD_INT 3
99447: NEG
99448: PUSH
99449: EMPTY
99450: LIST
99451: LIST
99452: PUSH
99453: LD_INT 5
99455: NEG
99456: PUSH
99457: LD_INT 4
99459: NEG
99460: PUSH
99461: EMPTY
99462: LIST
99463: LIST
99464: PUSH
99465: LD_INT 5
99467: NEG
99468: PUSH
99469: LD_INT 5
99471: NEG
99472: PUSH
99473: EMPTY
99474: LIST
99475: LIST
99476: PUSH
99477: LD_INT 3
99479: NEG
99480: PUSH
99481: LD_INT 5
99483: NEG
99484: PUSH
99485: EMPTY
99486: LIST
99487: LIST
99488: PUSH
99489: LD_INT 5
99491: NEG
99492: PUSH
99493: LD_INT 3
99495: NEG
99496: PUSH
99497: EMPTY
99498: LIST
99499: LIST
99500: PUSH
99501: EMPTY
99502: LIST
99503: LIST
99504: LIST
99505: LIST
99506: LIST
99507: LIST
99508: LIST
99509: LIST
99510: LIST
99511: LIST
99512: LIST
99513: LIST
99514: LIST
99515: LIST
99516: LIST
99517: LIST
99518: LIST
99519: LIST
99520: LIST
99521: LIST
99522: LIST
99523: LIST
99524: LIST
99525: LIST
99526: LIST
99527: LIST
99528: LIST
99529: LIST
99530: LIST
99531: LIST
99532: LIST
99533: LIST
99534: LIST
99535: LIST
99536: LIST
99537: LIST
99538: LIST
99539: LIST
99540: LIST
99541: LIST
99542: LIST
99543: LIST
99544: LIST
99545: LIST
99546: LIST
99547: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
99548: LD_ADDR_VAR 0 30
99552: PUSH
99553: LD_INT 4
99555: PUSH
99556: LD_INT 4
99558: PUSH
99559: EMPTY
99560: LIST
99561: LIST
99562: PUSH
99563: LD_INT 4
99565: PUSH
99566: LD_INT 3
99568: PUSH
99569: EMPTY
99570: LIST
99571: LIST
99572: PUSH
99573: LD_INT 5
99575: PUSH
99576: LD_INT 4
99578: PUSH
99579: EMPTY
99580: LIST
99581: LIST
99582: PUSH
99583: LD_INT 5
99585: PUSH
99586: LD_INT 5
99588: PUSH
99589: EMPTY
99590: LIST
99591: LIST
99592: PUSH
99593: LD_INT 4
99595: PUSH
99596: LD_INT 5
99598: PUSH
99599: EMPTY
99600: LIST
99601: LIST
99602: PUSH
99603: LD_INT 3
99605: PUSH
99606: LD_INT 4
99608: PUSH
99609: EMPTY
99610: LIST
99611: LIST
99612: PUSH
99613: LD_INT 3
99615: PUSH
99616: LD_INT 3
99618: PUSH
99619: EMPTY
99620: LIST
99621: LIST
99622: PUSH
99623: LD_INT 5
99625: PUSH
99626: LD_INT 3
99628: PUSH
99629: EMPTY
99630: LIST
99631: LIST
99632: PUSH
99633: LD_INT 3
99635: PUSH
99636: LD_INT 5
99638: PUSH
99639: EMPTY
99640: LIST
99641: LIST
99642: PUSH
99643: LD_INT 0
99645: PUSH
99646: LD_INT 3
99648: PUSH
99649: EMPTY
99650: LIST
99651: LIST
99652: PUSH
99653: LD_INT 0
99655: PUSH
99656: LD_INT 2
99658: PUSH
99659: EMPTY
99660: LIST
99661: LIST
99662: PUSH
99663: LD_INT 1
99665: PUSH
99666: LD_INT 3
99668: PUSH
99669: EMPTY
99670: LIST
99671: LIST
99672: PUSH
99673: LD_INT 1
99675: PUSH
99676: LD_INT 4
99678: PUSH
99679: EMPTY
99680: LIST
99681: LIST
99682: PUSH
99683: LD_INT 0
99685: PUSH
99686: LD_INT 4
99688: PUSH
99689: EMPTY
99690: LIST
99691: LIST
99692: PUSH
99693: LD_INT 1
99695: NEG
99696: PUSH
99697: LD_INT 3
99699: PUSH
99700: EMPTY
99701: LIST
99702: LIST
99703: PUSH
99704: LD_INT 1
99706: NEG
99707: PUSH
99708: LD_INT 2
99710: PUSH
99711: EMPTY
99712: LIST
99713: LIST
99714: PUSH
99715: LD_INT 2
99717: PUSH
99718: LD_INT 4
99720: PUSH
99721: EMPTY
99722: LIST
99723: LIST
99724: PUSH
99725: LD_INT 2
99727: NEG
99728: PUSH
99729: LD_INT 2
99731: PUSH
99732: EMPTY
99733: LIST
99734: LIST
99735: PUSH
99736: LD_INT 4
99738: NEG
99739: PUSH
99740: LD_INT 0
99742: PUSH
99743: EMPTY
99744: LIST
99745: LIST
99746: PUSH
99747: LD_INT 4
99749: NEG
99750: PUSH
99751: LD_INT 1
99753: NEG
99754: PUSH
99755: EMPTY
99756: LIST
99757: LIST
99758: PUSH
99759: LD_INT 3
99761: NEG
99762: PUSH
99763: LD_INT 0
99765: PUSH
99766: EMPTY
99767: LIST
99768: LIST
99769: PUSH
99770: LD_INT 3
99772: NEG
99773: PUSH
99774: LD_INT 1
99776: PUSH
99777: EMPTY
99778: LIST
99779: LIST
99780: PUSH
99781: LD_INT 4
99783: NEG
99784: PUSH
99785: LD_INT 1
99787: PUSH
99788: EMPTY
99789: LIST
99790: LIST
99791: PUSH
99792: LD_INT 5
99794: NEG
99795: PUSH
99796: LD_INT 0
99798: PUSH
99799: EMPTY
99800: LIST
99801: LIST
99802: PUSH
99803: LD_INT 5
99805: NEG
99806: PUSH
99807: LD_INT 1
99809: NEG
99810: PUSH
99811: EMPTY
99812: LIST
99813: LIST
99814: PUSH
99815: LD_INT 5
99817: NEG
99818: PUSH
99819: LD_INT 2
99821: NEG
99822: PUSH
99823: EMPTY
99824: LIST
99825: LIST
99826: PUSH
99827: LD_INT 3
99829: NEG
99830: PUSH
99831: LD_INT 2
99833: PUSH
99834: EMPTY
99835: LIST
99836: LIST
99837: PUSH
99838: LD_INT 3
99840: NEG
99841: PUSH
99842: LD_INT 3
99844: NEG
99845: PUSH
99846: EMPTY
99847: LIST
99848: LIST
99849: PUSH
99850: LD_INT 3
99852: NEG
99853: PUSH
99854: LD_INT 4
99856: NEG
99857: PUSH
99858: EMPTY
99859: LIST
99860: LIST
99861: PUSH
99862: LD_INT 2
99864: NEG
99865: PUSH
99866: LD_INT 3
99868: NEG
99869: PUSH
99870: EMPTY
99871: LIST
99872: LIST
99873: PUSH
99874: LD_INT 2
99876: NEG
99877: PUSH
99878: LD_INT 2
99880: NEG
99881: PUSH
99882: EMPTY
99883: LIST
99884: LIST
99885: PUSH
99886: LD_INT 3
99888: NEG
99889: PUSH
99890: LD_INT 2
99892: NEG
99893: PUSH
99894: EMPTY
99895: LIST
99896: LIST
99897: PUSH
99898: LD_INT 4
99900: NEG
99901: PUSH
99902: LD_INT 3
99904: NEG
99905: PUSH
99906: EMPTY
99907: LIST
99908: LIST
99909: PUSH
99910: LD_INT 4
99912: NEG
99913: PUSH
99914: LD_INT 4
99916: NEG
99917: PUSH
99918: EMPTY
99919: LIST
99920: LIST
99921: PUSH
99922: LD_INT 2
99924: NEG
99925: PUSH
99926: LD_INT 4
99928: NEG
99929: PUSH
99930: EMPTY
99931: LIST
99932: LIST
99933: PUSH
99934: LD_INT 4
99936: NEG
99937: PUSH
99938: LD_INT 2
99940: NEG
99941: PUSH
99942: EMPTY
99943: LIST
99944: LIST
99945: PUSH
99946: LD_INT 0
99948: PUSH
99949: LD_INT 4
99951: NEG
99952: PUSH
99953: EMPTY
99954: LIST
99955: LIST
99956: PUSH
99957: LD_INT 0
99959: PUSH
99960: LD_INT 5
99962: NEG
99963: PUSH
99964: EMPTY
99965: LIST
99966: LIST
99967: PUSH
99968: LD_INT 1
99970: PUSH
99971: LD_INT 4
99973: NEG
99974: PUSH
99975: EMPTY
99976: LIST
99977: LIST
99978: PUSH
99979: LD_INT 1
99981: PUSH
99982: LD_INT 3
99984: NEG
99985: PUSH
99986: EMPTY
99987: LIST
99988: LIST
99989: PUSH
99990: LD_INT 0
99992: PUSH
99993: LD_INT 3
99995: NEG
99996: PUSH
99997: EMPTY
99998: LIST
99999: LIST
100000: PUSH
100001: LD_INT 1
100003: NEG
100004: PUSH
100005: LD_INT 4
100007: NEG
100008: PUSH
100009: EMPTY
100010: LIST
100011: LIST
100012: PUSH
100013: LD_INT 1
100015: NEG
100016: PUSH
100017: LD_INT 5
100019: NEG
100020: PUSH
100021: EMPTY
100022: LIST
100023: LIST
100024: PUSH
100025: LD_INT 2
100027: PUSH
100028: LD_INT 3
100030: NEG
100031: PUSH
100032: EMPTY
100033: LIST
100034: LIST
100035: PUSH
100036: LD_INT 2
100038: NEG
100039: PUSH
100040: LD_INT 5
100042: NEG
100043: PUSH
100044: EMPTY
100045: LIST
100046: LIST
100047: PUSH
100048: EMPTY
100049: LIST
100050: LIST
100051: LIST
100052: LIST
100053: LIST
100054: LIST
100055: LIST
100056: LIST
100057: LIST
100058: LIST
100059: LIST
100060: LIST
100061: LIST
100062: LIST
100063: LIST
100064: LIST
100065: LIST
100066: LIST
100067: LIST
100068: LIST
100069: LIST
100070: LIST
100071: LIST
100072: LIST
100073: LIST
100074: LIST
100075: LIST
100076: LIST
100077: LIST
100078: LIST
100079: LIST
100080: LIST
100081: LIST
100082: LIST
100083: LIST
100084: LIST
100085: LIST
100086: LIST
100087: LIST
100088: LIST
100089: LIST
100090: LIST
100091: LIST
100092: LIST
100093: LIST
100094: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
100095: LD_ADDR_VAR 0 31
100099: PUSH
100100: LD_INT 0
100102: PUSH
100103: LD_INT 4
100105: PUSH
100106: EMPTY
100107: LIST
100108: LIST
100109: PUSH
100110: LD_INT 0
100112: PUSH
100113: LD_INT 3
100115: PUSH
100116: EMPTY
100117: LIST
100118: LIST
100119: PUSH
100120: LD_INT 1
100122: PUSH
100123: LD_INT 4
100125: PUSH
100126: EMPTY
100127: LIST
100128: LIST
100129: PUSH
100130: LD_INT 1
100132: PUSH
100133: LD_INT 5
100135: PUSH
100136: EMPTY
100137: LIST
100138: LIST
100139: PUSH
100140: LD_INT 0
100142: PUSH
100143: LD_INT 5
100145: PUSH
100146: EMPTY
100147: LIST
100148: LIST
100149: PUSH
100150: LD_INT 1
100152: NEG
100153: PUSH
100154: LD_INT 4
100156: PUSH
100157: EMPTY
100158: LIST
100159: LIST
100160: PUSH
100161: LD_INT 1
100163: NEG
100164: PUSH
100165: LD_INT 3
100167: PUSH
100168: EMPTY
100169: LIST
100170: LIST
100171: PUSH
100172: LD_INT 2
100174: PUSH
100175: LD_INT 5
100177: PUSH
100178: EMPTY
100179: LIST
100180: LIST
100181: PUSH
100182: LD_INT 2
100184: NEG
100185: PUSH
100186: LD_INT 3
100188: PUSH
100189: EMPTY
100190: LIST
100191: LIST
100192: PUSH
100193: LD_INT 3
100195: NEG
100196: PUSH
100197: LD_INT 0
100199: PUSH
100200: EMPTY
100201: LIST
100202: LIST
100203: PUSH
100204: LD_INT 3
100206: NEG
100207: PUSH
100208: LD_INT 1
100210: NEG
100211: PUSH
100212: EMPTY
100213: LIST
100214: LIST
100215: PUSH
100216: LD_INT 2
100218: NEG
100219: PUSH
100220: LD_INT 0
100222: PUSH
100223: EMPTY
100224: LIST
100225: LIST
100226: PUSH
100227: LD_INT 2
100229: NEG
100230: PUSH
100231: LD_INT 1
100233: PUSH
100234: EMPTY
100235: LIST
100236: LIST
100237: PUSH
100238: LD_INT 3
100240: NEG
100241: PUSH
100242: LD_INT 1
100244: PUSH
100245: EMPTY
100246: LIST
100247: LIST
100248: PUSH
100249: LD_INT 4
100251: NEG
100252: PUSH
100253: LD_INT 0
100255: PUSH
100256: EMPTY
100257: LIST
100258: LIST
100259: PUSH
100260: LD_INT 4
100262: NEG
100263: PUSH
100264: LD_INT 1
100266: NEG
100267: PUSH
100268: EMPTY
100269: LIST
100270: LIST
100271: PUSH
100272: LD_INT 4
100274: NEG
100275: PUSH
100276: LD_INT 2
100278: NEG
100279: PUSH
100280: EMPTY
100281: LIST
100282: LIST
100283: PUSH
100284: LD_INT 2
100286: NEG
100287: PUSH
100288: LD_INT 2
100290: PUSH
100291: EMPTY
100292: LIST
100293: LIST
100294: PUSH
100295: LD_INT 4
100297: NEG
100298: PUSH
100299: LD_INT 4
100301: NEG
100302: PUSH
100303: EMPTY
100304: LIST
100305: LIST
100306: PUSH
100307: LD_INT 4
100309: NEG
100310: PUSH
100311: LD_INT 5
100313: NEG
100314: PUSH
100315: EMPTY
100316: LIST
100317: LIST
100318: PUSH
100319: LD_INT 3
100321: NEG
100322: PUSH
100323: LD_INT 4
100325: NEG
100326: PUSH
100327: EMPTY
100328: LIST
100329: LIST
100330: PUSH
100331: LD_INT 3
100333: NEG
100334: PUSH
100335: LD_INT 3
100337: NEG
100338: PUSH
100339: EMPTY
100340: LIST
100341: LIST
100342: PUSH
100343: LD_INT 4
100345: NEG
100346: PUSH
100347: LD_INT 3
100349: NEG
100350: PUSH
100351: EMPTY
100352: LIST
100353: LIST
100354: PUSH
100355: LD_INT 5
100357: NEG
100358: PUSH
100359: LD_INT 4
100361: NEG
100362: PUSH
100363: EMPTY
100364: LIST
100365: LIST
100366: PUSH
100367: LD_INT 5
100369: NEG
100370: PUSH
100371: LD_INT 5
100373: NEG
100374: PUSH
100375: EMPTY
100376: LIST
100377: LIST
100378: PUSH
100379: LD_INT 3
100381: NEG
100382: PUSH
100383: LD_INT 5
100385: NEG
100386: PUSH
100387: EMPTY
100388: LIST
100389: LIST
100390: PUSH
100391: LD_INT 5
100393: NEG
100394: PUSH
100395: LD_INT 3
100397: NEG
100398: PUSH
100399: EMPTY
100400: LIST
100401: LIST
100402: PUSH
100403: LD_INT 0
100405: PUSH
100406: LD_INT 3
100408: NEG
100409: PUSH
100410: EMPTY
100411: LIST
100412: LIST
100413: PUSH
100414: LD_INT 0
100416: PUSH
100417: LD_INT 4
100419: NEG
100420: PUSH
100421: EMPTY
100422: LIST
100423: LIST
100424: PUSH
100425: LD_INT 1
100427: PUSH
100428: LD_INT 3
100430: NEG
100431: PUSH
100432: EMPTY
100433: LIST
100434: LIST
100435: PUSH
100436: LD_INT 1
100438: PUSH
100439: LD_INT 2
100441: NEG
100442: PUSH
100443: EMPTY
100444: LIST
100445: LIST
100446: PUSH
100447: LD_INT 0
100449: PUSH
100450: LD_INT 2
100452: NEG
100453: PUSH
100454: EMPTY
100455: LIST
100456: LIST
100457: PUSH
100458: LD_INT 1
100460: NEG
100461: PUSH
100462: LD_INT 3
100464: NEG
100465: PUSH
100466: EMPTY
100467: LIST
100468: LIST
100469: PUSH
100470: LD_INT 1
100472: NEG
100473: PUSH
100474: LD_INT 4
100476: NEG
100477: PUSH
100478: EMPTY
100479: LIST
100480: LIST
100481: PUSH
100482: LD_INT 2
100484: PUSH
100485: LD_INT 2
100487: NEG
100488: PUSH
100489: EMPTY
100490: LIST
100491: LIST
100492: PUSH
100493: LD_INT 2
100495: NEG
100496: PUSH
100497: LD_INT 4
100499: NEG
100500: PUSH
100501: EMPTY
100502: LIST
100503: LIST
100504: PUSH
100505: LD_INT 4
100507: PUSH
100508: LD_INT 0
100510: PUSH
100511: EMPTY
100512: LIST
100513: LIST
100514: PUSH
100515: LD_INT 4
100517: PUSH
100518: LD_INT 1
100520: NEG
100521: PUSH
100522: EMPTY
100523: LIST
100524: LIST
100525: PUSH
100526: LD_INT 5
100528: PUSH
100529: LD_INT 0
100531: PUSH
100532: EMPTY
100533: LIST
100534: LIST
100535: PUSH
100536: LD_INT 5
100538: PUSH
100539: LD_INT 1
100541: PUSH
100542: EMPTY
100543: LIST
100544: LIST
100545: PUSH
100546: LD_INT 4
100548: PUSH
100549: LD_INT 1
100551: PUSH
100552: EMPTY
100553: LIST
100554: LIST
100555: PUSH
100556: LD_INT 3
100558: PUSH
100559: LD_INT 0
100561: PUSH
100562: EMPTY
100563: LIST
100564: LIST
100565: PUSH
100566: LD_INT 3
100568: PUSH
100569: LD_INT 1
100571: NEG
100572: PUSH
100573: EMPTY
100574: LIST
100575: LIST
100576: PUSH
100577: LD_INT 3
100579: PUSH
100580: LD_INT 2
100582: NEG
100583: PUSH
100584: EMPTY
100585: LIST
100586: LIST
100587: PUSH
100588: LD_INT 5
100590: PUSH
100591: LD_INT 2
100593: PUSH
100594: EMPTY
100595: LIST
100596: LIST
100597: PUSH
100598: EMPTY
100599: LIST
100600: LIST
100601: LIST
100602: LIST
100603: LIST
100604: LIST
100605: LIST
100606: LIST
100607: LIST
100608: LIST
100609: LIST
100610: LIST
100611: LIST
100612: LIST
100613: LIST
100614: LIST
100615: LIST
100616: LIST
100617: LIST
100618: LIST
100619: LIST
100620: LIST
100621: LIST
100622: LIST
100623: LIST
100624: LIST
100625: LIST
100626: LIST
100627: LIST
100628: LIST
100629: LIST
100630: LIST
100631: LIST
100632: LIST
100633: LIST
100634: LIST
100635: LIST
100636: LIST
100637: LIST
100638: LIST
100639: LIST
100640: LIST
100641: LIST
100642: LIST
100643: LIST
100644: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
100645: LD_ADDR_VAR 0 32
100649: PUSH
100650: LD_INT 4
100652: NEG
100653: PUSH
100654: LD_INT 0
100656: PUSH
100657: EMPTY
100658: LIST
100659: LIST
100660: PUSH
100661: LD_INT 4
100663: NEG
100664: PUSH
100665: LD_INT 1
100667: NEG
100668: PUSH
100669: EMPTY
100670: LIST
100671: LIST
100672: PUSH
100673: LD_INT 3
100675: NEG
100676: PUSH
100677: LD_INT 0
100679: PUSH
100680: EMPTY
100681: LIST
100682: LIST
100683: PUSH
100684: LD_INT 3
100686: NEG
100687: PUSH
100688: LD_INT 1
100690: PUSH
100691: EMPTY
100692: LIST
100693: LIST
100694: PUSH
100695: LD_INT 4
100697: NEG
100698: PUSH
100699: LD_INT 1
100701: PUSH
100702: EMPTY
100703: LIST
100704: LIST
100705: PUSH
100706: LD_INT 5
100708: NEG
100709: PUSH
100710: LD_INT 0
100712: PUSH
100713: EMPTY
100714: LIST
100715: LIST
100716: PUSH
100717: LD_INT 5
100719: NEG
100720: PUSH
100721: LD_INT 1
100723: NEG
100724: PUSH
100725: EMPTY
100726: LIST
100727: LIST
100728: PUSH
100729: LD_INT 5
100731: NEG
100732: PUSH
100733: LD_INT 2
100735: NEG
100736: PUSH
100737: EMPTY
100738: LIST
100739: LIST
100740: PUSH
100741: LD_INT 3
100743: NEG
100744: PUSH
100745: LD_INT 2
100747: PUSH
100748: EMPTY
100749: LIST
100750: LIST
100751: PUSH
100752: LD_INT 3
100754: NEG
100755: PUSH
100756: LD_INT 3
100758: NEG
100759: PUSH
100760: EMPTY
100761: LIST
100762: LIST
100763: PUSH
100764: LD_INT 3
100766: NEG
100767: PUSH
100768: LD_INT 4
100770: NEG
100771: PUSH
100772: EMPTY
100773: LIST
100774: LIST
100775: PUSH
100776: LD_INT 2
100778: NEG
100779: PUSH
100780: LD_INT 3
100782: NEG
100783: PUSH
100784: EMPTY
100785: LIST
100786: LIST
100787: PUSH
100788: LD_INT 2
100790: NEG
100791: PUSH
100792: LD_INT 2
100794: NEG
100795: PUSH
100796: EMPTY
100797: LIST
100798: LIST
100799: PUSH
100800: LD_INT 3
100802: NEG
100803: PUSH
100804: LD_INT 2
100806: NEG
100807: PUSH
100808: EMPTY
100809: LIST
100810: LIST
100811: PUSH
100812: LD_INT 4
100814: NEG
100815: PUSH
100816: LD_INT 3
100818: NEG
100819: PUSH
100820: EMPTY
100821: LIST
100822: LIST
100823: PUSH
100824: LD_INT 4
100826: NEG
100827: PUSH
100828: LD_INT 4
100830: NEG
100831: PUSH
100832: EMPTY
100833: LIST
100834: LIST
100835: PUSH
100836: LD_INT 2
100838: NEG
100839: PUSH
100840: LD_INT 4
100842: NEG
100843: PUSH
100844: EMPTY
100845: LIST
100846: LIST
100847: PUSH
100848: LD_INT 4
100850: NEG
100851: PUSH
100852: LD_INT 2
100854: NEG
100855: PUSH
100856: EMPTY
100857: LIST
100858: LIST
100859: PUSH
100860: LD_INT 0
100862: PUSH
100863: LD_INT 4
100865: NEG
100866: PUSH
100867: EMPTY
100868: LIST
100869: LIST
100870: PUSH
100871: LD_INT 0
100873: PUSH
100874: LD_INT 5
100876: NEG
100877: PUSH
100878: EMPTY
100879: LIST
100880: LIST
100881: PUSH
100882: LD_INT 1
100884: PUSH
100885: LD_INT 4
100887: NEG
100888: PUSH
100889: EMPTY
100890: LIST
100891: LIST
100892: PUSH
100893: LD_INT 1
100895: PUSH
100896: LD_INT 3
100898: NEG
100899: PUSH
100900: EMPTY
100901: LIST
100902: LIST
100903: PUSH
100904: LD_INT 0
100906: PUSH
100907: LD_INT 3
100909: NEG
100910: PUSH
100911: EMPTY
100912: LIST
100913: LIST
100914: PUSH
100915: LD_INT 1
100917: NEG
100918: PUSH
100919: LD_INT 4
100921: NEG
100922: PUSH
100923: EMPTY
100924: LIST
100925: LIST
100926: PUSH
100927: LD_INT 1
100929: NEG
100930: PUSH
100931: LD_INT 5
100933: NEG
100934: PUSH
100935: EMPTY
100936: LIST
100937: LIST
100938: PUSH
100939: LD_INT 2
100941: PUSH
100942: LD_INT 3
100944: NEG
100945: PUSH
100946: EMPTY
100947: LIST
100948: LIST
100949: PUSH
100950: LD_INT 2
100952: NEG
100953: PUSH
100954: LD_INT 5
100956: NEG
100957: PUSH
100958: EMPTY
100959: LIST
100960: LIST
100961: PUSH
100962: LD_INT 3
100964: PUSH
100965: LD_INT 0
100967: PUSH
100968: EMPTY
100969: LIST
100970: LIST
100971: PUSH
100972: LD_INT 3
100974: PUSH
100975: LD_INT 1
100977: NEG
100978: PUSH
100979: EMPTY
100980: LIST
100981: LIST
100982: PUSH
100983: LD_INT 4
100985: PUSH
100986: LD_INT 0
100988: PUSH
100989: EMPTY
100990: LIST
100991: LIST
100992: PUSH
100993: LD_INT 4
100995: PUSH
100996: LD_INT 1
100998: PUSH
100999: EMPTY
101000: LIST
101001: LIST
101002: PUSH
101003: LD_INT 3
101005: PUSH
101006: LD_INT 1
101008: PUSH
101009: EMPTY
101010: LIST
101011: LIST
101012: PUSH
101013: LD_INT 2
101015: PUSH
101016: LD_INT 0
101018: PUSH
101019: EMPTY
101020: LIST
101021: LIST
101022: PUSH
101023: LD_INT 2
101025: PUSH
101026: LD_INT 1
101028: NEG
101029: PUSH
101030: EMPTY
101031: LIST
101032: LIST
101033: PUSH
101034: LD_INT 2
101036: PUSH
101037: LD_INT 2
101039: NEG
101040: PUSH
101041: EMPTY
101042: LIST
101043: LIST
101044: PUSH
101045: LD_INT 4
101047: PUSH
101048: LD_INT 2
101050: PUSH
101051: EMPTY
101052: LIST
101053: LIST
101054: PUSH
101055: LD_INT 4
101057: PUSH
101058: LD_INT 4
101060: PUSH
101061: EMPTY
101062: LIST
101063: LIST
101064: PUSH
101065: LD_INT 4
101067: PUSH
101068: LD_INT 3
101070: PUSH
101071: EMPTY
101072: LIST
101073: LIST
101074: PUSH
101075: LD_INT 5
101077: PUSH
101078: LD_INT 4
101080: PUSH
101081: EMPTY
101082: LIST
101083: LIST
101084: PUSH
101085: LD_INT 5
101087: PUSH
101088: LD_INT 5
101090: PUSH
101091: EMPTY
101092: LIST
101093: LIST
101094: PUSH
101095: LD_INT 4
101097: PUSH
101098: LD_INT 5
101100: PUSH
101101: EMPTY
101102: LIST
101103: LIST
101104: PUSH
101105: LD_INT 3
101107: PUSH
101108: LD_INT 4
101110: PUSH
101111: EMPTY
101112: LIST
101113: LIST
101114: PUSH
101115: LD_INT 3
101117: PUSH
101118: LD_INT 3
101120: PUSH
101121: EMPTY
101122: LIST
101123: LIST
101124: PUSH
101125: LD_INT 5
101127: PUSH
101128: LD_INT 3
101130: PUSH
101131: EMPTY
101132: LIST
101133: LIST
101134: PUSH
101135: LD_INT 3
101137: PUSH
101138: LD_INT 5
101140: PUSH
101141: EMPTY
101142: LIST
101143: LIST
101144: PUSH
101145: EMPTY
101146: LIST
101147: LIST
101148: LIST
101149: LIST
101150: LIST
101151: LIST
101152: LIST
101153: LIST
101154: LIST
101155: LIST
101156: LIST
101157: LIST
101158: LIST
101159: LIST
101160: LIST
101161: LIST
101162: LIST
101163: LIST
101164: LIST
101165: LIST
101166: LIST
101167: LIST
101168: LIST
101169: LIST
101170: LIST
101171: LIST
101172: LIST
101173: LIST
101174: LIST
101175: LIST
101176: LIST
101177: LIST
101178: LIST
101179: LIST
101180: LIST
101181: LIST
101182: LIST
101183: LIST
101184: LIST
101185: LIST
101186: LIST
101187: LIST
101188: LIST
101189: LIST
101190: LIST
101191: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
101192: LD_ADDR_VAR 0 33
101196: PUSH
101197: LD_INT 4
101199: NEG
101200: PUSH
101201: LD_INT 4
101203: NEG
101204: PUSH
101205: EMPTY
101206: LIST
101207: LIST
101208: PUSH
101209: LD_INT 4
101211: NEG
101212: PUSH
101213: LD_INT 5
101215: NEG
101216: PUSH
101217: EMPTY
101218: LIST
101219: LIST
101220: PUSH
101221: LD_INT 3
101223: NEG
101224: PUSH
101225: LD_INT 4
101227: NEG
101228: PUSH
101229: EMPTY
101230: LIST
101231: LIST
101232: PUSH
101233: LD_INT 3
101235: NEG
101236: PUSH
101237: LD_INT 3
101239: NEG
101240: PUSH
101241: EMPTY
101242: LIST
101243: LIST
101244: PUSH
101245: LD_INT 4
101247: NEG
101248: PUSH
101249: LD_INT 3
101251: NEG
101252: PUSH
101253: EMPTY
101254: LIST
101255: LIST
101256: PUSH
101257: LD_INT 5
101259: NEG
101260: PUSH
101261: LD_INT 4
101263: NEG
101264: PUSH
101265: EMPTY
101266: LIST
101267: LIST
101268: PUSH
101269: LD_INT 5
101271: NEG
101272: PUSH
101273: LD_INT 5
101275: NEG
101276: PUSH
101277: EMPTY
101278: LIST
101279: LIST
101280: PUSH
101281: LD_INT 3
101283: NEG
101284: PUSH
101285: LD_INT 5
101287: NEG
101288: PUSH
101289: EMPTY
101290: LIST
101291: LIST
101292: PUSH
101293: LD_INT 5
101295: NEG
101296: PUSH
101297: LD_INT 3
101299: NEG
101300: PUSH
101301: EMPTY
101302: LIST
101303: LIST
101304: PUSH
101305: LD_INT 0
101307: PUSH
101308: LD_INT 3
101310: NEG
101311: PUSH
101312: EMPTY
101313: LIST
101314: LIST
101315: PUSH
101316: LD_INT 0
101318: PUSH
101319: LD_INT 4
101321: NEG
101322: PUSH
101323: EMPTY
101324: LIST
101325: LIST
101326: PUSH
101327: LD_INT 1
101329: PUSH
101330: LD_INT 3
101332: NEG
101333: PUSH
101334: EMPTY
101335: LIST
101336: LIST
101337: PUSH
101338: LD_INT 1
101340: PUSH
101341: LD_INT 2
101343: NEG
101344: PUSH
101345: EMPTY
101346: LIST
101347: LIST
101348: PUSH
101349: LD_INT 0
101351: PUSH
101352: LD_INT 2
101354: NEG
101355: PUSH
101356: EMPTY
101357: LIST
101358: LIST
101359: PUSH
101360: LD_INT 1
101362: NEG
101363: PUSH
101364: LD_INT 3
101366: NEG
101367: PUSH
101368: EMPTY
101369: LIST
101370: LIST
101371: PUSH
101372: LD_INT 1
101374: NEG
101375: PUSH
101376: LD_INT 4
101378: NEG
101379: PUSH
101380: EMPTY
101381: LIST
101382: LIST
101383: PUSH
101384: LD_INT 2
101386: PUSH
101387: LD_INT 2
101389: NEG
101390: PUSH
101391: EMPTY
101392: LIST
101393: LIST
101394: PUSH
101395: LD_INT 2
101397: NEG
101398: PUSH
101399: LD_INT 4
101401: NEG
101402: PUSH
101403: EMPTY
101404: LIST
101405: LIST
101406: PUSH
101407: LD_INT 4
101409: PUSH
101410: LD_INT 0
101412: PUSH
101413: EMPTY
101414: LIST
101415: LIST
101416: PUSH
101417: LD_INT 4
101419: PUSH
101420: LD_INT 1
101422: NEG
101423: PUSH
101424: EMPTY
101425: LIST
101426: LIST
101427: PUSH
101428: LD_INT 5
101430: PUSH
101431: LD_INT 0
101433: PUSH
101434: EMPTY
101435: LIST
101436: LIST
101437: PUSH
101438: LD_INT 5
101440: PUSH
101441: LD_INT 1
101443: PUSH
101444: EMPTY
101445: LIST
101446: LIST
101447: PUSH
101448: LD_INT 4
101450: PUSH
101451: LD_INT 1
101453: PUSH
101454: EMPTY
101455: LIST
101456: LIST
101457: PUSH
101458: LD_INT 3
101460: PUSH
101461: LD_INT 0
101463: PUSH
101464: EMPTY
101465: LIST
101466: LIST
101467: PUSH
101468: LD_INT 3
101470: PUSH
101471: LD_INT 1
101473: NEG
101474: PUSH
101475: EMPTY
101476: LIST
101477: LIST
101478: PUSH
101479: LD_INT 3
101481: PUSH
101482: LD_INT 2
101484: NEG
101485: PUSH
101486: EMPTY
101487: LIST
101488: LIST
101489: PUSH
101490: LD_INT 5
101492: PUSH
101493: LD_INT 2
101495: PUSH
101496: EMPTY
101497: LIST
101498: LIST
101499: PUSH
101500: LD_INT 3
101502: PUSH
101503: LD_INT 3
101505: PUSH
101506: EMPTY
101507: LIST
101508: LIST
101509: PUSH
101510: LD_INT 3
101512: PUSH
101513: LD_INT 2
101515: PUSH
101516: EMPTY
101517: LIST
101518: LIST
101519: PUSH
101520: LD_INT 4
101522: PUSH
101523: LD_INT 3
101525: PUSH
101526: EMPTY
101527: LIST
101528: LIST
101529: PUSH
101530: LD_INT 4
101532: PUSH
101533: LD_INT 4
101535: PUSH
101536: EMPTY
101537: LIST
101538: LIST
101539: PUSH
101540: LD_INT 3
101542: PUSH
101543: LD_INT 4
101545: PUSH
101546: EMPTY
101547: LIST
101548: LIST
101549: PUSH
101550: LD_INT 2
101552: PUSH
101553: LD_INT 3
101555: PUSH
101556: EMPTY
101557: LIST
101558: LIST
101559: PUSH
101560: LD_INT 2
101562: PUSH
101563: LD_INT 2
101565: PUSH
101566: EMPTY
101567: LIST
101568: LIST
101569: PUSH
101570: LD_INT 4
101572: PUSH
101573: LD_INT 2
101575: PUSH
101576: EMPTY
101577: LIST
101578: LIST
101579: PUSH
101580: LD_INT 2
101582: PUSH
101583: LD_INT 4
101585: PUSH
101586: EMPTY
101587: LIST
101588: LIST
101589: PUSH
101590: LD_INT 0
101592: PUSH
101593: LD_INT 4
101595: PUSH
101596: EMPTY
101597: LIST
101598: LIST
101599: PUSH
101600: LD_INT 0
101602: PUSH
101603: LD_INT 3
101605: PUSH
101606: EMPTY
101607: LIST
101608: LIST
101609: PUSH
101610: LD_INT 1
101612: PUSH
101613: LD_INT 4
101615: PUSH
101616: EMPTY
101617: LIST
101618: LIST
101619: PUSH
101620: LD_INT 1
101622: PUSH
101623: LD_INT 5
101625: PUSH
101626: EMPTY
101627: LIST
101628: LIST
101629: PUSH
101630: LD_INT 0
101632: PUSH
101633: LD_INT 5
101635: PUSH
101636: EMPTY
101637: LIST
101638: LIST
101639: PUSH
101640: LD_INT 1
101642: NEG
101643: PUSH
101644: LD_INT 4
101646: PUSH
101647: EMPTY
101648: LIST
101649: LIST
101650: PUSH
101651: LD_INT 1
101653: NEG
101654: PUSH
101655: LD_INT 3
101657: PUSH
101658: EMPTY
101659: LIST
101660: LIST
101661: PUSH
101662: LD_INT 2
101664: PUSH
101665: LD_INT 5
101667: PUSH
101668: EMPTY
101669: LIST
101670: LIST
101671: PUSH
101672: LD_INT 2
101674: NEG
101675: PUSH
101676: LD_INT 3
101678: PUSH
101679: EMPTY
101680: LIST
101681: LIST
101682: PUSH
101683: EMPTY
101684: LIST
101685: LIST
101686: LIST
101687: LIST
101688: LIST
101689: LIST
101690: LIST
101691: LIST
101692: LIST
101693: LIST
101694: LIST
101695: LIST
101696: LIST
101697: LIST
101698: LIST
101699: LIST
101700: LIST
101701: LIST
101702: LIST
101703: LIST
101704: LIST
101705: LIST
101706: LIST
101707: LIST
101708: LIST
101709: LIST
101710: LIST
101711: LIST
101712: LIST
101713: LIST
101714: LIST
101715: LIST
101716: LIST
101717: LIST
101718: LIST
101719: LIST
101720: LIST
101721: LIST
101722: LIST
101723: LIST
101724: LIST
101725: LIST
101726: LIST
101727: LIST
101728: LIST
101729: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
101730: LD_ADDR_VAR 0 34
101734: PUSH
101735: LD_INT 0
101737: PUSH
101738: LD_INT 4
101740: NEG
101741: PUSH
101742: EMPTY
101743: LIST
101744: LIST
101745: PUSH
101746: LD_INT 0
101748: PUSH
101749: LD_INT 5
101751: NEG
101752: PUSH
101753: EMPTY
101754: LIST
101755: LIST
101756: PUSH
101757: LD_INT 1
101759: PUSH
101760: LD_INT 4
101762: NEG
101763: PUSH
101764: EMPTY
101765: LIST
101766: LIST
101767: PUSH
101768: LD_INT 1
101770: PUSH
101771: LD_INT 3
101773: NEG
101774: PUSH
101775: EMPTY
101776: LIST
101777: LIST
101778: PUSH
101779: LD_INT 0
101781: PUSH
101782: LD_INT 3
101784: NEG
101785: PUSH
101786: EMPTY
101787: LIST
101788: LIST
101789: PUSH
101790: LD_INT 1
101792: NEG
101793: PUSH
101794: LD_INT 4
101796: NEG
101797: PUSH
101798: EMPTY
101799: LIST
101800: LIST
101801: PUSH
101802: LD_INT 1
101804: NEG
101805: PUSH
101806: LD_INT 5
101808: NEG
101809: PUSH
101810: EMPTY
101811: LIST
101812: LIST
101813: PUSH
101814: LD_INT 2
101816: PUSH
101817: LD_INT 3
101819: NEG
101820: PUSH
101821: EMPTY
101822: LIST
101823: LIST
101824: PUSH
101825: LD_INT 2
101827: NEG
101828: PUSH
101829: LD_INT 5
101831: NEG
101832: PUSH
101833: EMPTY
101834: LIST
101835: LIST
101836: PUSH
101837: LD_INT 3
101839: PUSH
101840: LD_INT 0
101842: PUSH
101843: EMPTY
101844: LIST
101845: LIST
101846: PUSH
101847: LD_INT 3
101849: PUSH
101850: LD_INT 1
101852: NEG
101853: PUSH
101854: EMPTY
101855: LIST
101856: LIST
101857: PUSH
101858: LD_INT 4
101860: PUSH
101861: LD_INT 0
101863: PUSH
101864: EMPTY
101865: LIST
101866: LIST
101867: PUSH
101868: LD_INT 4
101870: PUSH
101871: LD_INT 1
101873: PUSH
101874: EMPTY
101875: LIST
101876: LIST
101877: PUSH
101878: LD_INT 3
101880: PUSH
101881: LD_INT 1
101883: PUSH
101884: EMPTY
101885: LIST
101886: LIST
101887: PUSH
101888: LD_INT 2
101890: PUSH
101891: LD_INT 0
101893: PUSH
101894: EMPTY
101895: LIST
101896: LIST
101897: PUSH
101898: LD_INT 2
101900: PUSH
101901: LD_INT 1
101903: NEG
101904: PUSH
101905: EMPTY
101906: LIST
101907: LIST
101908: PUSH
101909: LD_INT 2
101911: PUSH
101912: LD_INT 2
101914: NEG
101915: PUSH
101916: EMPTY
101917: LIST
101918: LIST
101919: PUSH
101920: LD_INT 4
101922: PUSH
101923: LD_INT 2
101925: PUSH
101926: EMPTY
101927: LIST
101928: LIST
101929: PUSH
101930: LD_INT 4
101932: PUSH
101933: LD_INT 4
101935: PUSH
101936: EMPTY
101937: LIST
101938: LIST
101939: PUSH
101940: LD_INT 4
101942: PUSH
101943: LD_INT 3
101945: PUSH
101946: EMPTY
101947: LIST
101948: LIST
101949: PUSH
101950: LD_INT 5
101952: PUSH
101953: LD_INT 4
101955: PUSH
101956: EMPTY
101957: LIST
101958: LIST
101959: PUSH
101960: LD_INT 5
101962: PUSH
101963: LD_INT 5
101965: PUSH
101966: EMPTY
101967: LIST
101968: LIST
101969: PUSH
101970: LD_INT 4
101972: PUSH
101973: LD_INT 5
101975: PUSH
101976: EMPTY
101977: LIST
101978: LIST
101979: PUSH
101980: LD_INT 3
101982: PUSH
101983: LD_INT 4
101985: PUSH
101986: EMPTY
101987: LIST
101988: LIST
101989: PUSH
101990: LD_INT 3
101992: PUSH
101993: LD_INT 3
101995: PUSH
101996: EMPTY
101997: LIST
101998: LIST
101999: PUSH
102000: LD_INT 5
102002: PUSH
102003: LD_INT 3
102005: PUSH
102006: EMPTY
102007: LIST
102008: LIST
102009: PUSH
102010: LD_INT 3
102012: PUSH
102013: LD_INT 5
102015: PUSH
102016: EMPTY
102017: LIST
102018: LIST
102019: PUSH
102020: LD_INT 0
102022: PUSH
102023: LD_INT 3
102025: PUSH
102026: EMPTY
102027: LIST
102028: LIST
102029: PUSH
102030: LD_INT 0
102032: PUSH
102033: LD_INT 2
102035: PUSH
102036: EMPTY
102037: LIST
102038: LIST
102039: PUSH
102040: LD_INT 1
102042: PUSH
102043: LD_INT 3
102045: PUSH
102046: EMPTY
102047: LIST
102048: LIST
102049: PUSH
102050: LD_INT 1
102052: PUSH
102053: LD_INT 4
102055: PUSH
102056: EMPTY
102057: LIST
102058: LIST
102059: PUSH
102060: LD_INT 0
102062: PUSH
102063: LD_INT 4
102065: PUSH
102066: EMPTY
102067: LIST
102068: LIST
102069: PUSH
102070: LD_INT 1
102072: NEG
102073: PUSH
102074: LD_INT 3
102076: PUSH
102077: EMPTY
102078: LIST
102079: LIST
102080: PUSH
102081: LD_INT 1
102083: NEG
102084: PUSH
102085: LD_INT 2
102087: PUSH
102088: EMPTY
102089: LIST
102090: LIST
102091: PUSH
102092: LD_INT 2
102094: PUSH
102095: LD_INT 4
102097: PUSH
102098: EMPTY
102099: LIST
102100: LIST
102101: PUSH
102102: LD_INT 2
102104: NEG
102105: PUSH
102106: LD_INT 2
102108: PUSH
102109: EMPTY
102110: LIST
102111: LIST
102112: PUSH
102113: LD_INT 4
102115: NEG
102116: PUSH
102117: LD_INT 0
102119: PUSH
102120: EMPTY
102121: LIST
102122: LIST
102123: PUSH
102124: LD_INT 4
102126: NEG
102127: PUSH
102128: LD_INT 1
102130: NEG
102131: PUSH
102132: EMPTY
102133: LIST
102134: LIST
102135: PUSH
102136: LD_INT 3
102138: NEG
102139: PUSH
102140: LD_INT 0
102142: PUSH
102143: EMPTY
102144: LIST
102145: LIST
102146: PUSH
102147: LD_INT 3
102149: NEG
102150: PUSH
102151: LD_INT 1
102153: PUSH
102154: EMPTY
102155: LIST
102156: LIST
102157: PUSH
102158: LD_INT 4
102160: NEG
102161: PUSH
102162: LD_INT 1
102164: PUSH
102165: EMPTY
102166: LIST
102167: LIST
102168: PUSH
102169: LD_INT 5
102171: NEG
102172: PUSH
102173: LD_INT 0
102175: PUSH
102176: EMPTY
102177: LIST
102178: LIST
102179: PUSH
102180: LD_INT 5
102182: NEG
102183: PUSH
102184: LD_INT 1
102186: NEG
102187: PUSH
102188: EMPTY
102189: LIST
102190: LIST
102191: PUSH
102192: LD_INT 5
102194: NEG
102195: PUSH
102196: LD_INT 2
102198: NEG
102199: PUSH
102200: EMPTY
102201: LIST
102202: LIST
102203: PUSH
102204: LD_INT 3
102206: NEG
102207: PUSH
102208: LD_INT 2
102210: PUSH
102211: EMPTY
102212: LIST
102213: LIST
102214: PUSH
102215: EMPTY
102216: LIST
102217: LIST
102218: LIST
102219: LIST
102220: LIST
102221: LIST
102222: LIST
102223: LIST
102224: LIST
102225: LIST
102226: LIST
102227: LIST
102228: LIST
102229: LIST
102230: LIST
102231: LIST
102232: LIST
102233: LIST
102234: LIST
102235: LIST
102236: LIST
102237: LIST
102238: LIST
102239: LIST
102240: LIST
102241: LIST
102242: LIST
102243: LIST
102244: LIST
102245: LIST
102246: LIST
102247: LIST
102248: LIST
102249: LIST
102250: LIST
102251: LIST
102252: LIST
102253: LIST
102254: LIST
102255: LIST
102256: LIST
102257: LIST
102258: LIST
102259: LIST
102260: LIST
102261: ST_TO_ADDR
// end ; end ;
102262: GO 102265
102264: POP
// case btype of b_depot , b_warehouse :
102265: LD_VAR 0 1
102269: PUSH
102270: LD_INT 0
102272: DOUBLE
102273: EQUAL
102274: IFTRUE 102284
102276: LD_INT 1
102278: DOUBLE
102279: EQUAL
102280: IFTRUE 102284
102282: GO 102485
102284: POP
// case nation of nation_american :
102285: LD_VAR 0 5
102289: PUSH
102290: LD_INT 1
102292: DOUBLE
102293: EQUAL
102294: IFTRUE 102298
102296: GO 102354
102298: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
102299: LD_ADDR_VAR 0 9
102303: PUSH
102304: LD_VAR 0 11
102308: PUSH
102309: LD_VAR 0 12
102313: PUSH
102314: LD_VAR 0 13
102318: PUSH
102319: LD_VAR 0 14
102323: PUSH
102324: LD_VAR 0 15
102328: PUSH
102329: LD_VAR 0 16
102333: PUSH
102334: EMPTY
102335: LIST
102336: LIST
102337: LIST
102338: LIST
102339: LIST
102340: LIST
102341: PUSH
102342: LD_VAR 0 4
102346: PUSH
102347: LD_INT 1
102349: PLUS
102350: ARRAY
102351: ST_TO_ADDR
102352: GO 102483
102354: LD_INT 2
102356: DOUBLE
102357: EQUAL
102358: IFTRUE 102362
102360: GO 102418
102362: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
102363: LD_ADDR_VAR 0 9
102367: PUSH
102368: LD_VAR 0 17
102372: PUSH
102373: LD_VAR 0 18
102377: PUSH
102378: LD_VAR 0 19
102382: PUSH
102383: LD_VAR 0 20
102387: PUSH
102388: LD_VAR 0 21
102392: PUSH
102393: LD_VAR 0 22
102397: PUSH
102398: EMPTY
102399: LIST
102400: LIST
102401: LIST
102402: LIST
102403: LIST
102404: LIST
102405: PUSH
102406: LD_VAR 0 4
102410: PUSH
102411: LD_INT 1
102413: PLUS
102414: ARRAY
102415: ST_TO_ADDR
102416: GO 102483
102418: LD_INT 3
102420: DOUBLE
102421: EQUAL
102422: IFTRUE 102426
102424: GO 102482
102426: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
102427: LD_ADDR_VAR 0 9
102431: PUSH
102432: LD_VAR 0 23
102436: PUSH
102437: LD_VAR 0 24
102441: PUSH
102442: LD_VAR 0 25
102446: PUSH
102447: LD_VAR 0 26
102451: PUSH
102452: LD_VAR 0 27
102456: PUSH
102457: LD_VAR 0 28
102461: PUSH
102462: EMPTY
102463: LIST
102464: LIST
102465: LIST
102466: LIST
102467: LIST
102468: LIST
102469: PUSH
102470: LD_VAR 0 4
102474: PUSH
102475: LD_INT 1
102477: PLUS
102478: ARRAY
102479: ST_TO_ADDR
102480: GO 102483
102482: POP
102483: GO 103038
102485: LD_INT 2
102487: DOUBLE
102488: EQUAL
102489: IFTRUE 102499
102491: LD_INT 3
102493: DOUBLE
102494: EQUAL
102495: IFTRUE 102499
102497: GO 102555
102499: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
102500: LD_ADDR_VAR 0 9
102504: PUSH
102505: LD_VAR 0 29
102509: PUSH
102510: LD_VAR 0 30
102514: PUSH
102515: LD_VAR 0 31
102519: PUSH
102520: LD_VAR 0 32
102524: PUSH
102525: LD_VAR 0 33
102529: PUSH
102530: LD_VAR 0 34
102534: PUSH
102535: EMPTY
102536: LIST
102537: LIST
102538: LIST
102539: LIST
102540: LIST
102541: LIST
102542: PUSH
102543: LD_VAR 0 4
102547: PUSH
102548: LD_INT 1
102550: PLUS
102551: ARRAY
102552: ST_TO_ADDR
102553: GO 103038
102555: LD_INT 16
102557: DOUBLE
102558: EQUAL
102559: IFTRUE 102617
102561: LD_INT 17
102563: DOUBLE
102564: EQUAL
102565: IFTRUE 102617
102567: LD_INT 18
102569: DOUBLE
102570: EQUAL
102571: IFTRUE 102617
102573: LD_INT 19
102575: DOUBLE
102576: EQUAL
102577: IFTRUE 102617
102579: LD_INT 22
102581: DOUBLE
102582: EQUAL
102583: IFTRUE 102617
102585: LD_INT 20
102587: DOUBLE
102588: EQUAL
102589: IFTRUE 102617
102591: LD_INT 21
102593: DOUBLE
102594: EQUAL
102595: IFTRUE 102617
102597: LD_INT 23
102599: DOUBLE
102600: EQUAL
102601: IFTRUE 102617
102603: LD_INT 24
102605: DOUBLE
102606: EQUAL
102607: IFTRUE 102617
102609: LD_INT 25
102611: DOUBLE
102612: EQUAL
102613: IFTRUE 102617
102615: GO 102673
102617: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
102618: LD_ADDR_VAR 0 9
102622: PUSH
102623: LD_VAR 0 35
102627: PUSH
102628: LD_VAR 0 36
102632: PUSH
102633: LD_VAR 0 37
102637: PUSH
102638: LD_VAR 0 38
102642: PUSH
102643: LD_VAR 0 39
102647: PUSH
102648: LD_VAR 0 40
102652: PUSH
102653: EMPTY
102654: LIST
102655: LIST
102656: LIST
102657: LIST
102658: LIST
102659: LIST
102660: PUSH
102661: LD_VAR 0 4
102665: PUSH
102666: LD_INT 1
102668: PLUS
102669: ARRAY
102670: ST_TO_ADDR
102671: GO 103038
102673: LD_INT 6
102675: DOUBLE
102676: EQUAL
102677: IFTRUE 102729
102679: LD_INT 7
102681: DOUBLE
102682: EQUAL
102683: IFTRUE 102729
102685: LD_INT 8
102687: DOUBLE
102688: EQUAL
102689: IFTRUE 102729
102691: LD_INT 13
102693: DOUBLE
102694: EQUAL
102695: IFTRUE 102729
102697: LD_INT 12
102699: DOUBLE
102700: EQUAL
102701: IFTRUE 102729
102703: LD_INT 15
102705: DOUBLE
102706: EQUAL
102707: IFTRUE 102729
102709: LD_INT 11
102711: DOUBLE
102712: EQUAL
102713: IFTRUE 102729
102715: LD_INT 14
102717: DOUBLE
102718: EQUAL
102719: IFTRUE 102729
102721: LD_INT 10
102723: DOUBLE
102724: EQUAL
102725: IFTRUE 102729
102727: GO 102785
102729: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
102730: LD_ADDR_VAR 0 9
102734: PUSH
102735: LD_VAR 0 41
102739: PUSH
102740: LD_VAR 0 42
102744: PUSH
102745: LD_VAR 0 43
102749: PUSH
102750: LD_VAR 0 44
102754: PUSH
102755: LD_VAR 0 45
102759: PUSH
102760: LD_VAR 0 46
102764: PUSH
102765: EMPTY
102766: LIST
102767: LIST
102768: LIST
102769: LIST
102770: LIST
102771: LIST
102772: PUSH
102773: LD_VAR 0 4
102777: PUSH
102778: LD_INT 1
102780: PLUS
102781: ARRAY
102782: ST_TO_ADDR
102783: GO 103038
102785: LD_INT 36
102787: DOUBLE
102788: EQUAL
102789: IFTRUE 102793
102791: GO 102849
102793: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
102794: LD_ADDR_VAR 0 9
102798: PUSH
102799: LD_VAR 0 47
102803: PUSH
102804: LD_VAR 0 48
102808: PUSH
102809: LD_VAR 0 49
102813: PUSH
102814: LD_VAR 0 50
102818: PUSH
102819: LD_VAR 0 51
102823: PUSH
102824: LD_VAR 0 52
102828: PUSH
102829: EMPTY
102830: LIST
102831: LIST
102832: LIST
102833: LIST
102834: LIST
102835: LIST
102836: PUSH
102837: LD_VAR 0 4
102841: PUSH
102842: LD_INT 1
102844: PLUS
102845: ARRAY
102846: ST_TO_ADDR
102847: GO 103038
102849: LD_INT 4
102851: DOUBLE
102852: EQUAL
102853: IFTRUE 102875
102855: LD_INT 5
102857: DOUBLE
102858: EQUAL
102859: IFTRUE 102875
102861: LD_INT 34
102863: DOUBLE
102864: EQUAL
102865: IFTRUE 102875
102867: LD_INT 37
102869: DOUBLE
102870: EQUAL
102871: IFTRUE 102875
102873: GO 102931
102875: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
102876: LD_ADDR_VAR 0 9
102880: PUSH
102881: LD_VAR 0 53
102885: PUSH
102886: LD_VAR 0 54
102890: PUSH
102891: LD_VAR 0 55
102895: PUSH
102896: LD_VAR 0 56
102900: PUSH
102901: LD_VAR 0 57
102905: PUSH
102906: LD_VAR 0 58
102910: PUSH
102911: EMPTY
102912: LIST
102913: LIST
102914: LIST
102915: LIST
102916: LIST
102917: LIST
102918: PUSH
102919: LD_VAR 0 4
102923: PUSH
102924: LD_INT 1
102926: PLUS
102927: ARRAY
102928: ST_TO_ADDR
102929: GO 103038
102931: LD_INT 31
102933: DOUBLE
102934: EQUAL
102935: IFTRUE 102981
102937: LD_INT 32
102939: DOUBLE
102940: EQUAL
102941: IFTRUE 102981
102943: LD_INT 33
102945: DOUBLE
102946: EQUAL
102947: IFTRUE 102981
102949: LD_INT 27
102951: DOUBLE
102952: EQUAL
102953: IFTRUE 102981
102955: LD_INT 26
102957: DOUBLE
102958: EQUAL
102959: IFTRUE 102981
102961: LD_INT 28
102963: DOUBLE
102964: EQUAL
102965: IFTRUE 102981
102967: LD_INT 29
102969: DOUBLE
102970: EQUAL
102971: IFTRUE 102981
102973: LD_INT 30
102975: DOUBLE
102976: EQUAL
102977: IFTRUE 102981
102979: GO 103037
102981: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
102982: LD_ADDR_VAR 0 9
102986: PUSH
102987: LD_VAR 0 59
102991: PUSH
102992: LD_VAR 0 60
102996: PUSH
102997: LD_VAR 0 61
103001: PUSH
103002: LD_VAR 0 62
103006: PUSH
103007: LD_VAR 0 63
103011: PUSH
103012: LD_VAR 0 64
103016: PUSH
103017: EMPTY
103018: LIST
103019: LIST
103020: LIST
103021: LIST
103022: LIST
103023: LIST
103024: PUSH
103025: LD_VAR 0 4
103029: PUSH
103030: LD_INT 1
103032: PLUS
103033: ARRAY
103034: ST_TO_ADDR
103035: GO 103038
103037: POP
// temp_list2 = [ ] ;
103038: LD_ADDR_VAR 0 10
103042: PUSH
103043: EMPTY
103044: ST_TO_ADDR
// for i in temp_list do
103045: LD_ADDR_VAR 0 8
103049: PUSH
103050: LD_VAR 0 9
103054: PUSH
103055: FOR_IN
103056: IFFALSE 103108
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
103058: LD_ADDR_VAR 0 10
103062: PUSH
103063: LD_VAR 0 10
103067: PUSH
103068: LD_VAR 0 8
103072: PUSH
103073: LD_INT 1
103075: ARRAY
103076: PUSH
103077: LD_VAR 0 2
103081: PLUS
103082: PUSH
103083: LD_VAR 0 8
103087: PUSH
103088: LD_INT 2
103090: ARRAY
103091: PUSH
103092: LD_VAR 0 3
103096: PLUS
103097: PUSH
103098: EMPTY
103099: LIST
103100: LIST
103101: PUSH
103102: EMPTY
103103: LIST
103104: ADD
103105: ST_TO_ADDR
103106: GO 103055
103108: POP
103109: POP
// result = temp_list2 ;
103110: LD_ADDR_VAR 0 7
103114: PUSH
103115: LD_VAR 0 10
103119: ST_TO_ADDR
// end ;
103120: LD_VAR 0 7
103124: RET
// export function EnemyInRange ( unit , dist ) ; begin
103125: LD_INT 0
103127: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
103128: LD_ADDR_VAR 0 3
103132: PUSH
103133: LD_VAR 0 1
103137: PPUSH
103138: CALL_OW 255
103142: PPUSH
103143: LD_VAR 0 1
103147: PPUSH
103148: CALL_OW 250
103152: PPUSH
103153: LD_VAR 0 1
103157: PPUSH
103158: CALL_OW 251
103162: PPUSH
103163: LD_VAR 0 2
103167: PPUSH
103168: CALL 76498 0 4
103172: PUSH
103173: LD_INT 4
103175: ARRAY
103176: ST_TO_ADDR
// end ;
103177: LD_VAR 0 3
103181: RET
// export function PlayerSeeMe ( unit ) ; begin
103182: LD_INT 0
103184: PPUSH
// result := See ( your_side , unit ) ;
103185: LD_ADDR_VAR 0 2
103189: PUSH
103190: LD_OWVAR 2
103194: PPUSH
103195: LD_VAR 0 1
103199: PPUSH
103200: CALL_OW 292
103204: ST_TO_ADDR
// end ;
103205: LD_VAR 0 2
103209: RET
// export function ReverseDir ( unit ) ; begin
103210: LD_INT 0
103212: PPUSH
// if not unit then
103213: LD_VAR 0 1
103217: NOT
103218: IFFALSE 103222
// exit ;
103220: GO 103245
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
103222: LD_ADDR_VAR 0 2
103226: PUSH
103227: LD_VAR 0 1
103231: PPUSH
103232: CALL_OW 254
103236: PUSH
103237: LD_INT 3
103239: PLUS
103240: PUSH
103241: LD_INT 6
103243: MOD
103244: ST_TO_ADDR
// end ;
103245: LD_VAR 0 2
103249: RET
// export function ReverseArray ( array ) ; var i ; begin
103250: LD_INT 0
103252: PPUSH
103253: PPUSH
// if not array then
103254: LD_VAR 0 1
103258: NOT
103259: IFFALSE 103263
// exit ;
103261: GO 103318
// result := [ ] ;
103263: LD_ADDR_VAR 0 2
103267: PUSH
103268: EMPTY
103269: ST_TO_ADDR
// for i := array downto 1 do
103270: LD_ADDR_VAR 0 3
103274: PUSH
103275: DOUBLE
103276: LD_VAR 0 1
103280: INC
103281: ST_TO_ADDR
103282: LD_INT 1
103284: PUSH
103285: FOR_DOWNTO
103286: IFFALSE 103316
// result := Join ( result , array [ i ] ) ;
103288: LD_ADDR_VAR 0 2
103292: PUSH
103293: LD_VAR 0 2
103297: PPUSH
103298: LD_VAR 0 1
103302: PUSH
103303: LD_VAR 0 3
103307: ARRAY
103308: PPUSH
103309: CALL 107963 0 2
103313: ST_TO_ADDR
103314: GO 103285
103316: POP
103317: POP
// end ;
103318: LD_VAR 0 2
103322: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
103323: LD_INT 0
103325: PPUSH
103326: PPUSH
103327: PPUSH
103328: PPUSH
103329: PPUSH
103330: PPUSH
// if not unit or not hexes then
103331: LD_VAR 0 1
103335: NOT
103336: PUSH
103337: LD_VAR 0 2
103341: NOT
103342: OR
103343: IFFALSE 103347
// exit ;
103345: GO 103470
// dist := 9999 ;
103347: LD_ADDR_VAR 0 5
103351: PUSH
103352: LD_INT 9999
103354: ST_TO_ADDR
// for i = 1 to hexes do
103355: LD_ADDR_VAR 0 4
103359: PUSH
103360: DOUBLE
103361: LD_INT 1
103363: DEC
103364: ST_TO_ADDR
103365: LD_VAR 0 2
103369: PUSH
103370: FOR_TO
103371: IFFALSE 103458
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
103373: LD_ADDR_VAR 0 6
103377: PUSH
103378: LD_VAR 0 1
103382: PPUSH
103383: LD_VAR 0 2
103387: PUSH
103388: LD_VAR 0 4
103392: ARRAY
103393: PUSH
103394: LD_INT 1
103396: ARRAY
103397: PPUSH
103398: LD_VAR 0 2
103402: PUSH
103403: LD_VAR 0 4
103407: ARRAY
103408: PUSH
103409: LD_INT 2
103411: ARRAY
103412: PPUSH
103413: CALL_OW 297
103417: ST_TO_ADDR
// if tdist < dist then
103418: LD_VAR 0 6
103422: PUSH
103423: LD_VAR 0 5
103427: LESS
103428: IFFALSE 103456
// begin hex := hexes [ i ] ;
103430: LD_ADDR_VAR 0 8
103434: PUSH
103435: LD_VAR 0 2
103439: PUSH
103440: LD_VAR 0 4
103444: ARRAY
103445: ST_TO_ADDR
// dist := tdist ;
103446: LD_ADDR_VAR 0 5
103450: PUSH
103451: LD_VAR 0 6
103455: ST_TO_ADDR
// end ; end ;
103456: GO 103370
103458: POP
103459: POP
// result := hex ;
103460: LD_ADDR_VAR 0 3
103464: PUSH
103465: LD_VAR 0 8
103469: ST_TO_ADDR
// end ;
103470: LD_VAR 0 3
103474: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
103475: LD_INT 0
103477: PPUSH
103478: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
103479: LD_VAR 0 1
103483: NOT
103484: PUSH
103485: LD_VAR 0 1
103489: PUSH
103490: LD_INT 21
103492: PUSH
103493: LD_INT 2
103495: PUSH
103496: EMPTY
103497: LIST
103498: LIST
103499: PUSH
103500: LD_INT 23
103502: PUSH
103503: LD_INT 2
103505: PUSH
103506: EMPTY
103507: LIST
103508: LIST
103509: PUSH
103510: EMPTY
103511: LIST
103512: LIST
103513: PPUSH
103514: CALL_OW 69
103518: IN
103519: NOT
103520: OR
103521: IFFALSE 103525
// exit ;
103523: GO 103572
// for i = 1 to 3 do
103525: LD_ADDR_VAR 0 3
103529: PUSH
103530: DOUBLE
103531: LD_INT 1
103533: DEC
103534: ST_TO_ADDR
103535: LD_INT 3
103537: PUSH
103538: FOR_TO
103539: IFFALSE 103570
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
103541: LD_VAR 0 1
103545: PPUSH
103546: CALL_OW 250
103550: PPUSH
103551: LD_VAR 0 1
103555: PPUSH
103556: CALL_OW 251
103560: PPUSH
103561: LD_INT 1
103563: PPUSH
103564: CALL_OW 453
103568: GO 103538
103570: POP
103571: POP
// end ;
103572: LD_VAR 0 2
103576: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
103577: LD_INT 0
103579: PPUSH
103580: PPUSH
103581: PPUSH
103582: PPUSH
103583: PPUSH
103584: PPUSH
// if not unit or not enemy_unit then
103585: LD_VAR 0 1
103589: NOT
103590: PUSH
103591: LD_VAR 0 2
103595: NOT
103596: OR
103597: IFFALSE 103601
// exit ;
103599: GO 104068
// if GetLives ( i ) < 250 then
103601: LD_VAR 0 4
103605: PPUSH
103606: CALL_OW 256
103610: PUSH
103611: LD_INT 250
103613: LESS
103614: IFFALSE 103627
// begin ComAutodestruct ( i ) ;
103616: LD_VAR 0 4
103620: PPUSH
103621: CALL 103475 0 1
// exit ;
103625: GO 104068
// end ; x := GetX ( enemy_unit ) ;
103627: LD_ADDR_VAR 0 7
103631: PUSH
103632: LD_VAR 0 2
103636: PPUSH
103637: CALL_OW 250
103641: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
103642: LD_ADDR_VAR 0 8
103646: PUSH
103647: LD_VAR 0 2
103651: PPUSH
103652: CALL_OW 251
103656: ST_TO_ADDR
// if not x or not y then
103657: LD_VAR 0 7
103661: NOT
103662: PUSH
103663: LD_VAR 0 8
103667: NOT
103668: OR
103669: IFFALSE 103673
// exit ;
103671: GO 104068
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
103673: LD_ADDR_VAR 0 6
103677: PUSH
103678: LD_VAR 0 7
103682: PPUSH
103683: LD_INT 0
103685: PPUSH
103686: LD_INT 4
103688: PPUSH
103689: CALL_OW 272
103693: PUSH
103694: LD_VAR 0 8
103698: PPUSH
103699: LD_INT 0
103701: PPUSH
103702: LD_INT 4
103704: PPUSH
103705: CALL_OW 273
103709: PUSH
103710: EMPTY
103711: LIST
103712: LIST
103713: PUSH
103714: LD_VAR 0 7
103718: PPUSH
103719: LD_INT 1
103721: PPUSH
103722: LD_INT 4
103724: PPUSH
103725: CALL_OW 272
103729: PUSH
103730: LD_VAR 0 8
103734: PPUSH
103735: LD_INT 1
103737: PPUSH
103738: LD_INT 4
103740: PPUSH
103741: CALL_OW 273
103745: PUSH
103746: EMPTY
103747: LIST
103748: LIST
103749: PUSH
103750: LD_VAR 0 7
103754: PPUSH
103755: LD_INT 2
103757: PPUSH
103758: LD_INT 4
103760: PPUSH
103761: CALL_OW 272
103765: PUSH
103766: LD_VAR 0 8
103770: PPUSH
103771: LD_INT 2
103773: PPUSH
103774: LD_INT 4
103776: PPUSH
103777: CALL_OW 273
103781: PUSH
103782: EMPTY
103783: LIST
103784: LIST
103785: PUSH
103786: LD_VAR 0 7
103790: PPUSH
103791: LD_INT 3
103793: PPUSH
103794: LD_INT 4
103796: PPUSH
103797: CALL_OW 272
103801: PUSH
103802: LD_VAR 0 8
103806: PPUSH
103807: LD_INT 3
103809: PPUSH
103810: LD_INT 4
103812: PPUSH
103813: CALL_OW 273
103817: PUSH
103818: EMPTY
103819: LIST
103820: LIST
103821: PUSH
103822: LD_VAR 0 7
103826: PPUSH
103827: LD_INT 4
103829: PPUSH
103830: LD_INT 4
103832: PPUSH
103833: CALL_OW 272
103837: PUSH
103838: LD_VAR 0 8
103842: PPUSH
103843: LD_INT 4
103845: PPUSH
103846: LD_INT 4
103848: PPUSH
103849: CALL_OW 273
103853: PUSH
103854: EMPTY
103855: LIST
103856: LIST
103857: PUSH
103858: LD_VAR 0 7
103862: PPUSH
103863: LD_INT 5
103865: PPUSH
103866: LD_INT 4
103868: PPUSH
103869: CALL_OW 272
103873: PUSH
103874: LD_VAR 0 8
103878: PPUSH
103879: LD_INT 5
103881: PPUSH
103882: LD_INT 4
103884: PPUSH
103885: CALL_OW 273
103889: PUSH
103890: EMPTY
103891: LIST
103892: LIST
103893: PUSH
103894: EMPTY
103895: LIST
103896: LIST
103897: LIST
103898: LIST
103899: LIST
103900: LIST
103901: ST_TO_ADDR
// for i = tmp downto 1 do
103902: LD_ADDR_VAR 0 4
103906: PUSH
103907: DOUBLE
103908: LD_VAR 0 6
103912: INC
103913: ST_TO_ADDR
103914: LD_INT 1
103916: PUSH
103917: FOR_DOWNTO
103918: IFFALSE 104019
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
103920: LD_VAR 0 6
103924: PUSH
103925: LD_VAR 0 4
103929: ARRAY
103930: PUSH
103931: LD_INT 1
103933: ARRAY
103934: PPUSH
103935: LD_VAR 0 6
103939: PUSH
103940: LD_VAR 0 4
103944: ARRAY
103945: PUSH
103946: LD_INT 2
103948: ARRAY
103949: PPUSH
103950: CALL_OW 488
103954: NOT
103955: PUSH
103956: LD_VAR 0 6
103960: PUSH
103961: LD_VAR 0 4
103965: ARRAY
103966: PUSH
103967: LD_INT 1
103969: ARRAY
103970: PPUSH
103971: LD_VAR 0 6
103975: PUSH
103976: LD_VAR 0 4
103980: ARRAY
103981: PUSH
103982: LD_INT 2
103984: ARRAY
103985: PPUSH
103986: CALL_OW 428
103990: PUSH
103991: LD_INT 0
103993: NONEQUAL
103994: OR
103995: IFFALSE 104017
// tmp := Delete ( tmp , i ) ;
103997: LD_ADDR_VAR 0 6
104001: PUSH
104002: LD_VAR 0 6
104006: PPUSH
104007: LD_VAR 0 4
104011: PPUSH
104012: CALL_OW 3
104016: ST_TO_ADDR
104017: GO 103917
104019: POP
104020: POP
// j := GetClosestHex ( unit , tmp ) ;
104021: LD_ADDR_VAR 0 5
104025: PUSH
104026: LD_VAR 0 1
104030: PPUSH
104031: LD_VAR 0 6
104035: PPUSH
104036: CALL 103323 0 2
104040: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
104041: LD_VAR 0 1
104045: PPUSH
104046: LD_VAR 0 5
104050: PUSH
104051: LD_INT 1
104053: ARRAY
104054: PPUSH
104055: LD_VAR 0 5
104059: PUSH
104060: LD_INT 2
104062: ARRAY
104063: PPUSH
104064: CALL_OW 111
// end ;
104068: LD_VAR 0 3
104072: RET
// export function PrepareApemanSoldier ( ) ; begin
104073: LD_INT 0
104075: PPUSH
// uc_nation := 0 ;
104076: LD_ADDR_OWVAR 21
104080: PUSH
104081: LD_INT 0
104083: ST_TO_ADDR
// hc_sex := sex_male ;
104084: LD_ADDR_OWVAR 27
104088: PUSH
104089: LD_INT 1
104091: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
104092: LD_ADDR_OWVAR 28
104096: PUSH
104097: LD_INT 15
104099: ST_TO_ADDR
// hc_gallery :=  ;
104100: LD_ADDR_OWVAR 33
104104: PUSH
104105: LD_STRING 
104107: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
104108: LD_ADDR_OWVAR 31
104112: PUSH
104113: LD_INT 0
104115: PPUSH
104116: LD_INT 3
104118: PPUSH
104119: CALL_OW 12
104123: PUSH
104124: LD_INT 0
104126: PPUSH
104127: LD_INT 3
104129: PPUSH
104130: CALL_OW 12
104134: PUSH
104135: LD_INT 0
104137: PUSH
104138: LD_INT 0
104140: PUSH
104141: EMPTY
104142: LIST
104143: LIST
104144: LIST
104145: LIST
104146: ST_TO_ADDR
// end ;
104147: LD_VAR 0 1
104151: RET
// export function PrepareApemanEngineer ( ) ; begin
104152: LD_INT 0
104154: PPUSH
// uc_nation := 0 ;
104155: LD_ADDR_OWVAR 21
104159: PUSH
104160: LD_INT 0
104162: ST_TO_ADDR
// hc_sex := sex_male ;
104163: LD_ADDR_OWVAR 27
104167: PUSH
104168: LD_INT 1
104170: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
104171: LD_ADDR_OWVAR 28
104175: PUSH
104176: LD_INT 16
104178: ST_TO_ADDR
// hc_gallery :=  ;
104179: LD_ADDR_OWVAR 33
104183: PUSH
104184: LD_STRING 
104186: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
104187: LD_ADDR_OWVAR 31
104191: PUSH
104192: LD_INT 0
104194: PPUSH
104195: LD_INT 3
104197: PPUSH
104198: CALL_OW 12
104202: PUSH
104203: LD_INT 0
104205: PPUSH
104206: LD_INT 3
104208: PPUSH
104209: CALL_OW 12
104213: PUSH
104214: LD_INT 0
104216: PUSH
104217: LD_INT 0
104219: PUSH
104220: EMPTY
104221: LIST
104222: LIST
104223: LIST
104224: LIST
104225: ST_TO_ADDR
// end ;
104226: LD_VAR 0 1
104230: RET
// export function PrepareApeman ( agressivity ) ; begin
104231: LD_INT 0
104233: PPUSH
// uc_side := 0 ;
104234: LD_ADDR_OWVAR 20
104238: PUSH
104239: LD_INT 0
104241: ST_TO_ADDR
// uc_nation := 0 ;
104242: LD_ADDR_OWVAR 21
104246: PUSH
104247: LD_INT 0
104249: ST_TO_ADDR
// hc_sex := sex_male ;
104250: LD_ADDR_OWVAR 27
104254: PUSH
104255: LD_INT 1
104257: ST_TO_ADDR
// hc_class := class_apeman ;
104258: LD_ADDR_OWVAR 28
104262: PUSH
104263: LD_INT 12
104265: ST_TO_ADDR
// hc_gallery :=  ;
104266: LD_ADDR_OWVAR 33
104270: PUSH
104271: LD_STRING 
104273: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
104274: LD_ADDR_OWVAR 35
104278: PUSH
104279: LD_VAR 0 1
104283: NEG
104284: PPUSH
104285: LD_VAR 0 1
104289: PPUSH
104290: CALL_OW 12
104294: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
104295: LD_ADDR_OWVAR 31
104299: PUSH
104300: LD_INT 0
104302: PPUSH
104303: LD_INT 3
104305: PPUSH
104306: CALL_OW 12
104310: PUSH
104311: LD_INT 0
104313: PPUSH
104314: LD_INT 3
104316: PPUSH
104317: CALL_OW 12
104321: PUSH
104322: LD_INT 0
104324: PUSH
104325: LD_INT 0
104327: PUSH
104328: EMPTY
104329: LIST
104330: LIST
104331: LIST
104332: LIST
104333: ST_TO_ADDR
// end ;
104334: LD_VAR 0 2
104338: RET
// export function PrepareTiger ( agressivity ) ; begin
104339: LD_INT 0
104341: PPUSH
// uc_side := 0 ;
104342: LD_ADDR_OWVAR 20
104346: PUSH
104347: LD_INT 0
104349: ST_TO_ADDR
// uc_nation := 0 ;
104350: LD_ADDR_OWVAR 21
104354: PUSH
104355: LD_INT 0
104357: ST_TO_ADDR
// hc_class := class_tiger ;
104358: LD_ADDR_OWVAR 28
104362: PUSH
104363: LD_INT 14
104365: ST_TO_ADDR
// hc_gallery :=  ;
104366: LD_ADDR_OWVAR 33
104370: PUSH
104371: LD_STRING 
104373: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
104374: LD_ADDR_OWVAR 35
104378: PUSH
104379: LD_VAR 0 1
104383: NEG
104384: PPUSH
104385: LD_VAR 0 1
104389: PPUSH
104390: CALL_OW 12
104394: ST_TO_ADDR
// end ;
104395: LD_VAR 0 2
104399: RET
// export function PrepareEnchidna ( ) ; begin
104400: LD_INT 0
104402: PPUSH
// uc_side := 0 ;
104403: LD_ADDR_OWVAR 20
104407: PUSH
104408: LD_INT 0
104410: ST_TO_ADDR
// uc_nation := 0 ;
104411: LD_ADDR_OWVAR 21
104415: PUSH
104416: LD_INT 0
104418: ST_TO_ADDR
// hc_class := class_baggie ;
104419: LD_ADDR_OWVAR 28
104423: PUSH
104424: LD_INT 13
104426: ST_TO_ADDR
// hc_gallery :=  ;
104427: LD_ADDR_OWVAR 33
104431: PUSH
104432: LD_STRING 
104434: ST_TO_ADDR
// end ;
104435: LD_VAR 0 1
104439: RET
// export function PrepareFrog ( ) ; begin
104440: LD_INT 0
104442: PPUSH
// uc_side := 0 ;
104443: LD_ADDR_OWVAR 20
104447: PUSH
104448: LD_INT 0
104450: ST_TO_ADDR
// uc_nation := 0 ;
104451: LD_ADDR_OWVAR 21
104455: PUSH
104456: LD_INT 0
104458: ST_TO_ADDR
// hc_class := class_frog ;
104459: LD_ADDR_OWVAR 28
104463: PUSH
104464: LD_INT 19
104466: ST_TO_ADDR
// hc_gallery :=  ;
104467: LD_ADDR_OWVAR 33
104471: PUSH
104472: LD_STRING 
104474: ST_TO_ADDR
// end ;
104475: LD_VAR 0 1
104479: RET
// export function PrepareFish ( ) ; begin
104480: LD_INT 0
104482: PPUSH
// uc_side := 0 ;
104483: LD_ADDR_OWVAR 20
104487: PUSH
104488: LD_INT 0
104490: ST_TO_ADDR
// uc_nation := 0 ;
104491: LD_ADDR_OWVAR 21
104495: PUSH
104496: LD_INT 0
104498: ST_TO_ADDR
// hc_class := class_fish ;
104499: LD_ADDR_OWVAR 28
104503: PUSH
104504: LD_INT 20
104506: ST_TO_ADDR
// hc_gallery :=  ;
104507: LD_ADDR_OWVAR 33
104511: PUSH
104512: LD_STRING 
104514: ST_TO_ADDR
// end ;
104515: LD_VAR 0 1
104519: RET
// export function PrepareBird ( ) ; begin
104520: LD_INT 0
104522: PPUSH
// uc_side := 0 ;
104523: LD_ADDR_OWVAR 20
104527: PUSH
104528: LD_INT 0
104530: ST_TO_ADDR
// uc_nation := 0 ;
104531: LD_ADDR_OWVAR 21
104535: PUSH
104536: LD_INT 0
104538: ST_TO_ADDR
// hc_class := class_phororhacos ;
104539: LD_ADDR_OWVAR 28
104543: PUSH
104544: LD_INT 18
104546: ST_TO_ADDR
// hc_gallery :=  ;
104547: LD_ADDR_OWVAR 33
104551: PUSH
104552: LD_STRING 
104554: ST_TO_ADDR
// end ;
104555: LD_VAR 0 1
104559: RET
// export function PrepareHorse ( ) ; begin
104560: LD_INT 0
104562: PPUSH
// uc_side := 0 ;
104563: LD_ADDR_OWVAR 20
104567: PUSH
104568: LD_INT 0
104570: ST_TO_ADDR
// uc_nation := 0 ;
104571: LD_ADDR_OWVAR 21
104575: PUSH
104576: LD_INT 0
104578: ST_TO_ADDR
// hc_class := class_horse ;
104579: LD_ADDR_OWVAR 28
104583: PUSH
104584: LD_INT 21
104586: ST_TO_ADDR
// hc_gallery :=  ;
104587: LD_ADDR_OWVAR 33
104591: PUSH
104592: LD_STRING 
104594: ST_TO_ADDR
// end ;
104595: LD_VAR 0 1
104599: RET
// export function PrepareMastodont ( ) ; begin
104600: LD_INT 0
104602: PPUSH
// uc_side := 0 ;
104603: LD_ADDR_OWVAR 20
104607: PUSH
104608: LD_INT 0
104610: ST_TO_ADDR
// uc_nation := 0 ;
104611: LD_ADDR_OWVAR 21
104615: PUSH
104616: LD_INT 0
104618: ST_TO_ADDR
// vc_chassis := class_mastodont ;
104619: LD_ADDR_OWVAR 37
104623: PUSH
104624: LD_INT 31
104626: ST_TO_ADDR
// vc_control := control_rider ;
104627: LD_ADDR_OWVAR 38
104631: PUSH
104632: LD_INT 4
104634: ST_TO_ADDR
// end ;
104635: LD_VAR 0 1
104639: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
104640: LD_INT 0
104642: PPUSH
104643: PPUSH
104644: PPUSH
// uc_side = 0 ;
104645: LD_ADDR_OWVAR 20
104649: PUSH
104650: LD_INT 0
104652: ST_TO_ADDR
// uc_nation = 0 ;
104653: LD_ADDR_OWVAR 21
104657: PUSH
104658: LD_INT 0
104660: ST_TO_ADDR
// InitHc_All ( ) ;
104661: CALL_OW 584
// InitVc ;
104665: CALL_OW 20
// if mastodonts then
104669: LD_VAR 0 6
104673: IFFALSE 104740
// for i = 1 to mastodonts do
104675: LD_ADDR_VAR 0 11
104679: PUSH
104680: DOUBLE
104681: LD_INT 1
104683: DEC
104684: ST_TO_ADDR
104685: LD_VAR 0 6
104689: PUSH
104690: FOR_TO
104691: IFFALSE 104738
// begin vc_chassis := 31 ;
104693: LD_ADDR_OWVAR 37
104697: PUSH
104698: LD_INT 31
104700: ST_TO_ADDR
// vc_control := control_rider ;
104701: LD_ADDR_OWVAR 38
104705: PUSH
104706: LD_INT 4
104708: ST_TO_ADDR
// animal := CreateVehicle ;
104709: LD_ADDR_VAR 0 12
104713: PUSH
104714: CALL_OW 45
104718: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104719: LD_VAR 0 12
104723: PPUSH
104724: LD_VAR 0 8
104728: PPUSH
104729: LD_INT 0
104731: PPUSH
104732: CALL 106868 0 3
// end ;
104736: GO 104690
104738: POP
104739: POP
// if horses then
104740: LD_VAR 0 5
104744: IFFALSE 104811
// for i = 1 to horses do
104746: LD_ADDR_VAR 0 11
104750: PUSH
104751: DOUBLE
104752: LD_INT 1
104754: DEC
104755: ST_TO_ADDR
104756: LD_VAR 0 5
104760: PUSH
104761: FOR_TO
104762: IFFALSE 104809
// begin hc_class := 21 ;
104764: LD_ADDR_OWVAR 28
104768: PUSH
104769: LD_INT 21
104771: ST_TO_ADDR
// hc_gallery :=  ;
104772: LD_ADDR_OWVAR 33
104776: PUSH
104777: LD_STRING 
104779: ST_TO_ADDR
// animal := CreateHuman ;
104780: LD_ADDR_VAR 0 12
104784: PUSH
104785: CALL_OW 44
104789: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104790: LD_VAR 0 12
104794: PPUSH
104795: LD_VAR 0 8
104799: PPUSH
104800: LD_INT 0
104802: PPUSH
104803: CALL 106868 0 3
// end ;
104807: GO 104761
104809: POP
104810: POP
// if birds then
104811: LD_VAR 0 1
104815: IFFALSE 104882
// for i = 1 to birds do
104817: LD_ADDR_VAR 0 11
104821: PUSH
104822: DOUBLE
104823: LD_INT 1
104825: DEC
104826: ST_TO_ADDR
104827: LD_VAR 0 1
104831: PUSH
104832: FOR_TO
104833: IFFALSE 104880
// begin hc_class := 18 ;
104835: LD_ADDR_OWVAR 28
104839: PUSH
104840: LD_INT 18
104842: ST_TO_ADDR
// hc_gallery =  ;
104843: LD_ADDR_OWVAR 33
104847: PUSH
104848: LD_STRING 
104850: ST_TO_ADDR
// animal := CreateHuman ;
104851: LD_ADDR_VAR 0 12
104855: PUSH
104856: CALL_OW 44
104860: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104861: LD_VAR 0 12
104865: PPUSH
104866: LD_VAR 0 8
104870: PPUSH
104871: LD_INT 0
104873: PPUSH
104874: CALL 106868 0 3
// end ;
104878: GO 104832
104880: POP
104881: POP
// if tigers then
104882: LD_VAR 0 2
104886: IFFALSE 104970
// for i = 1 to tigers do
104888: LD_ADDR_VAR 0 11
104892: PUSH
104893: DOUBLE
104894: LD_INT 1
104896: DEC
104897: ST_TO_ADDR
104898: LD_VAR 0 2
104902: PUSH
104903: FOR_TO
104904: IFFALSE 104968
// begin hc_class = class_tiger ;
104906: LD_ADDR_OWVAR 28
104910: PUSH
104911: LD_INT 14
104913: ST_TO_ADDR
// hc_gallery =  ;
104914: LD_ADDR_OWVAR 33
104918: PUSH
104919: LD_STRING 
104921: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
104922: LD_ADDR_OWVAR 35
104926: PUSH
104927: LD_INT 7
104929: NEG
104930: PPUSH
104931: LD_INT 7
104933: PPUSH
104934: CALL_OW 12
104938: ST_TO_ADDR
// animal := CreateHuman ;
104939: LD_ADDR_VAR 0 12
104943: PUSH
104944: CALL_OW 44
104948: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104949: LD_VAR 0 12
104953: PPUSH
104954: LD_VAR 0 8
104958: PPUSH
104959: LD_INT 0
104961: PPUSH
104962: CALL 106868 0 3
// end ;
104966: GO 104903
104968: POP
104969: POP
// if apemans then
104970: LD_VAR 0 3
104974: IFFALSE 105097
// for i = 1 to apemans do
104976: LD_ADDR_VAR 0 11
104980: PUSH
104981: DOUBLE
104982: LD_INT 1
104984: DEC
104985: ST_TO_ADDR
104986: LD_VAR 0 3
104990: PUSH
104991: FOR_TO
104992: IFFALSE 105095
// begin hc_class = class_apeman ;
104994: LD_ADDR_OWVAR 28
104998: PUSH
104999: LD_INT 12
105001: ST_TO_ADDR
// hc_gallery =  ;
105002: LD_ADDR_OWVAR 33
105006: PUSH
105007: LD_STRING 
105009: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
105010: LD_ADDR_OWVAR 35
105014: PUSH
105015: LD_INT 2
105017: NEG
105018: PPUSH
105019: LD_INT 2
105021: PPUSH
105022: CALL_OW 12
105026: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
105027: LD_ADDR_OWVAR 31
105031: PUSH
105032: LD_INT 1
105034: PPUSH
105035: LD_INT 3
105037: PPUSH
105038: CALL_OW 12
105042: PUSH
105043: LD_INT 1
105045: PPUSH
105046: LD_INT 3
105048: PPUSH
105049: CALL_OW 12
105053: PUSH
105054: LD_INT 0
105056: PUSH
105057: LD_INT 0
105059: PUSH
105060: EMPTY
105061: LIST
105062: LIST
105063: LIST
105064: LIST
105065: ST_TO_ADDR
// animal := CreateHuman ;
105066: LD_ADDR_VAR 0 12
105070: PUSH
105071: CALL_OW 44
105075: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
105076: LD_VAR 0 12
105080: PPUSH
105081: LD_VAR 0 8
105085: PPUSH
105086: LD_INT 0
105088: PPUSH
105089: CALL 106868 0 3
// end ;
105093: GO 104991
105095: POP
105096: POP
// if enchidnas then
105097: LD_VAR 0 4
105101: IFFALSE 105168
// for i = 1 to enchidnas do
105103: LD_ADDR_VAR 0 11
105107: PUSH
105108: DOUBLE
105109: LD_INT 1
105111: DEC
105112: ST_TO_ADDR
105113: LD_VAR 0 4
105117: PUSH
105118: FOR_TO
105119: IFFALSE 105166
// begin hc_class = 13 ;
105121: LD_ADDR_OWVAR 28
105125: PUSH
105126: LD_INT 13
105128: ST_TO_ADDR
// hc_gallery =  ;
105129: LD_ADDR_OWVAR 33
105133: PUSH
105134: LD_STRING 
105136: ST_TO_ADDR
// animal := CreateHuman ;
105137: LD_ADDR_VAR 0 12
105141: PUSH
105142: CALL_OW 44
105146: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
105147: LD_VAR 0 12
105151: PPUSH
105152: LD_VAR 0 8
105156: PPUSH
105157: LD_INT 0
105159: PPUSH
105160: CALL 106868 0 3
// end ;
105164: GO 105118
105166: POP
105167: POP
// if fishes then
105168: LD_VAR 0 7
105172: IFFALSE 105239
// for i = 1 to fishes do
105174: LD_ADDR_VAR 0 11
105178: PUSH
105179: DOUBLE
105180: LD_INT 1
105182: DEC
105183: ST_TO_ADDR
105184: LD_VAR 0 7
105188: PUSH
105189: FOR_TO
105190: IFFALSE 105237
// begin hc_class = 20 ;
105192: LD_ADDR_OWVAR 28
105196: PUSH
105197: LD_INT 20
105199: ST_TO_ADDR
// hc_gallery =  ;
105200: LD_ADDR_OWVAR 33
105204: PUSH
105205: LD_STRING 
105207: ST_TO_ADDR
// animal := CreateHuman ;
105208: LD_ADDR_VAR 0 12
105212: PUSH
105213: CALL_OW 44
105217: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
105218: LD_VAR 0 12
105222: PPUSH
105223: LD_VAR 0 9
105227: PPUSH
105228: LD_INT 0
105230: PPUSH
105231: CALL 106868 0 3
// end ;
105235: GO 105189
105237: POP
105238: POP
// end ;
105239: LD_VAR 0 10
105243: RET
// export function WantHeal ( sci , unit ) ; begin
105244: LD_INT 0
105246: PPUSH
// if GetTaskList ( sci ) > 0 then
105247: LD_VAR 0 1
105251: PPUSH
105252: CALL_OW 437
105256: PUSH
105257: LD_INT 0
105259: GREATER
105260: IFFALSE 105330
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
105262: LD_VAR 0 1
105266: PPUSH
105267: CALL_OW 437
105271: PUSH
105272: LD_INT 1
105274: ARRAY
105275: PUSH
105276: LD_INT 1
105278: ARRAY
105279: PUSH
105280: LD_STRING l
105282: EQUAL
105283: PUSH
105284: LD_VAR 0 1
105288: PPUSH
105289: CALL_OW 437
105293: PUSH
105294: LD_INT 1
105296: ARRAY
105297: PUSH
105298: LD_INT 4
105300: ARRAY
105301: PUSH
105302: LD_VAR 0 2
105306: EQUAL
105307: AND
105308: IFFALSE 105320
// result := true else
105310: LD_ADDR_VAR 0 3
105314: PUSH
105315: LD_INT 1
105317: ST_TO_ADDR
105318: GO 105328
// result := false ;
105320: LD_ADDR_VAR 0 3
105324: PUSH
105325: LD_INT 0
105327: ST_TO_ADDR
// end else
105328: GO 105338
// result := false ;
105330: LD_ADDR_VAR 0 3
105334: PUSH
105335: LD_INT 0
105337: ST_TO_ADDR
// end ;
105338: LD_VAR 0 3
105342: RET
// export function HealTarget ( sci ) ; begin
105343: LD_INT 0
105345: PPUSH
// if not sci then
105346: LD_VAR 0 1
105350: NOT
105351: IFFALSE 105355
// exit ;
105353: GO 105420
// result := 0 ;
105355: LD_ADDR_VAR 0 2
105359: PUSH
105360: LD_INT 0
105362: ST_TO_ADDR
// if GetTaskList ( sci ) then
105363: LD_VAR 0 1
105367: PPUSH
105368: CALL_OW 437
105372: IFFALSE 105420
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
105374: LD_VAR 0 1
105378: PPUSH
105379: CALL_OW 437
105383: PUSH
105384: LD_INT 1
105386: ARRAY
105387: PUSH
105388: LD_INT 1
105390: ARRAY
105391: PUSH
105392: LD_STRING l
105394: EQUAL
105395: IFFALSE 105420
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
105397: LD_ADDR_VAR 0 2
105401: PUSH
105402: LD_VAR 0 1
105406: PPUSH
105407: CALL_OW 437
105411: PUSH
105412: LD_INT 1
105414: ARRAY
105415: PUSH
105416: LD_INT 4
105418: ARRAY
105419: ST_TO_ADDR
// end ;
105420: LD_VAR 0 2
105424: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
105425: LD_INT 0
105427: PPUSH
105428: PPUSH
105429: PPUSH
105430: PPUSH
// if not base_units then
105431: LD_VAR 0 1
105435: NOT
105436: IFFALSE 105440
// exit ;
105438: GO 105527
// result := false ;
105440: LD_ADDR_VAR 0 2
105444: PUSH
105445: LD_INT 0
105447: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
105448: LD_ADDR_VAR 0 5
105452: PUSH
105453: LD_VAR 0 1
105457: PPUSH
105458: LD_INT 21
105460: PUSH
105461: LD_INT 3
105463: PUSH
105464: EMPTY
105465: LIST
105466: LIST
105467: PPUSH
105468: CALL_OW 72
105472: ST_TO_ADDR
// if not tmp then
105473: LD_VAR 0 5
105477: NOT
105478: IFFALSE 105482
// exit ;
105480: GO 105527
// for i in tmp do
105482: LD_ADDR_VAR 0 3
105486: PUSH
105487: LD_VAR 0 5
105491: PUSH
105492: FOR_IN
105493: IFFALSE 105525
// begin result := EnemyInRange ( i , 22 ) ;
105495: LD_ADDR_VAR 0 2
105499: PUSH
105500: LD_VAR 0 3
105504: PPUSH
105505: LD_INT 22
105507: PPUSH
105508: CALL 103125 0 2
105512: ST_TO_ADDR
// if result then
105513: LD_VAR 0 2
105517: IFFALSE 105523
// exit ;
105519: POP
105520: POP
105521: GO 105527
// end ;
105523: GO 105492
105525: POP
105526: POP
// end ;
105527: LD_VAR 0 2
105531: RET
// export function FilterByTag ( units , tag ) ; begin
105532: LD_INT 0
105534: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
105535: LD_ADDR_VAR 0 3
105539: PUSH
105540: LD_VAR 0 1
105544: PPUSH
105545: LD_INT 120
105547: PUSH
105548: LD_VAR 0 2
105552: PUSH
105553: EMPTY
105554: LIST
105555: LIST
105556: PPUSH
105557: CALL_OW 72
105561: ST_TO_ADDR
// end ;
105562: LD_VAR 0 3
105566: RET
// export function IsDriver ( un ) ; begin
105567: LD_INT 0
105569: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
105570: LD_ADDR_VAR 0 2
105574: PUSH
105575: LD_VAR 0 1
105579: PUSH
105580: LD_INT 55
105582: PUSH
105583: EMPTY
105584: LIST
105585: PPUSH
105586: CALL_OW 69
105590: IN
105591: ST_TO_ADDR
// end ;
105592: LD_VAR 0 2
105596: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
105597: LD_INT 0
105599: PPUSH
105600: PPUSH
// list := [ ] ;
105601: LD_ADDR_VAR 0 5
105605: PUSH
105606: EMPTY
105607: ST_TO_ADDR
// case d of 0 :
105608: LD_VAR 0 3
105612: PUSH
105613: LD_INT 0
105615: DOUBLE
105616: EQUAL
105617: IFTRUE 105621
105619: GO 105754
105621: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
105622: LD_ADDR_VAR 0 5
105626: PUSH
105627: LD_VAR 0 1
105631: PUSH
105632: LD_INT 4
105634: MINUS
105635: PUSH
105636: LD_VAR 0 2
105640: PUSH
105641: LD_INT 4
105643: MINUS
105644: PUSH
105645: LD_INT 2
105647: PUSH
105648: EMPTY
105649: LIST
105650: LIST
105651: LIST
105652: PUSH
105653: LD_VAR 0 1
105657: PUSH
105658: LD_INT 3
105660: MINUS
105661: PUSH
105662: LD_VAR 0 2
105666: PUSH
105667: LD_INT 1
105669: PUSH
105670: EMPTY
105671: LIST
105672: LIST
105673: LIST
105674: PUSH
105675: LD_VAR 0 1
105679: PUSH
105680: LD_INT 4
105682: PLUS
105683: PUSH
105684: LD_VAR 0 2
105688: PUSH
105689: LD_INT 4
105691: PUSH
105692: EMPTY
105693: LIST
105694: LIST
105695: LIST
105696: PUSH
105697: LD_VAR 0 1
105701: PUSH
105702: LD_INT 3
105704: PLUS
105705: PUSH
105706: LD_VAR 0 2
105710: PUSH
105711: LD_INT 3
105713: PLUS
105714: PUSH
105715: LD_INT 5
105717: PUSH
105718: EMPTY
105719: LIST
105720: LIST
105721: LIST
105722: PUSH
105723: LD_VAR 0 1
105727: PUSH
105728: LD_VAR 0 2
105732: PUSH
105733: LD_INT 4
105735: PLUS
105736: PUSH
105737: LD_INT 0
105739: PUSH
105740: EMPTY
105741: LIST
105742: LIST
105743: LIST
105744: PUSH
105745: EMPTY
105746: LIST
105747: LIST
105748: LIST
105749: LIST
105750: LIST
105751: ST_TO_ADDR
// end ; 1 :
105752: GO 106452
105754: LD_INT 1
105756: DOUBLE
105757: EQUAL
105758: IFTRUE 105762
105760: GO 105895
105762: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
105763: LD_ADDR_VAR 0 5
105767: PUSH
105768: LD_VAR 0 1
105772: PUSH
105773: LD_VAR 0 2
105777: PUSH
105778: LD_INT 4
105780: MINUS
105781: PUSH
105782: LD_INT 3
105784: PUSH
105785: EMPTY
105786: LIST
105787: LIST
105788: LIST
105789: PUSH
105790: LD_VAR 0 1
105794: PUSH
105795: LD_INT 3
105797: MINUS
105798: PUSH
105799: LD_VAR 0 2
105803: PUSH
105804: LD_INT 3
105806: MINUS
105807: PUSH
105808: LD_INT 2
105810: PUSH
105811: EMPTY
105812: LIST
105813: LIST
105814: LIST
105815: PUSH
105816: LD_VAR 0 1
105820: PUSH
105821: LD_INT 4
105823: MINUS
105824: PUSH
105825: LD_VAR 0 2
105829: PUSH
105830: LD_INT 1
105832: PUSH
105833: EMPTY
105834: LIST
105835: LIST
105836: LIST
105837: PUSH
105838: LD_VAR 0 1
105842: PUSH
105843: LD_VAR 0 2
105847: PUSH
105848: LD_INT 3
105850: PLUS
105851: PUSH
105852: LD_INT 0
105854: PUSH
105855: EMPTY
105856: LIST
105857: LIST
105858: LIST
105859: PUSH
105860: LD_VAR 0 1
105864: PUSH
105865: LD_INT 4
105867: PLUS
105868: PUSH
105869: LD_VAR 0 2
105873: PUSH
105874: LD_INT 4
105876: PLUS
105877: PUSH
105878: LD_INT 5
105880: PUSH
105881: EMPTY
105882: LIST
105883: LIST
105884: LIST
105885: PUSH
105886: EMPTY
105887: LIST
105888: LIST
105889: LIST
105890: LIST
105891: LIST
105892: ST_TO_ADDR
// end ; 2 :
105893: GO 106452
105895: LD_INT 2
105897: DOUBLE
105898: EQUAL
105899: IFTRUE 105903
105901: GO 106032
105903: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
105904: LD_ADDR_VAR 0 5
105908: PUSH
105909: LD_VAR 0 1
105913: PUSH
105914: LD_VAR 0 2
105918: PUSH
105919: LD_INT 3
105921: MINUS
105922: PUSH
105923: LD_INT 3
105925: PUSH
105926: EMPTY
105927: LIST
105928: LIST
105929: LIST
105930: PUSH
105931: LD_VAR 0 1
105935: PUSH
105936: LD_INT 4
105938: PLUS
105939: PUSH
105940: LD_VAR 0 2
105944: PUSH
105945: LD_INT 4
105947: PUSH
105948: EMPTY
105949: LIST
105950: LIST
105951: LIST
105952: PUSH
105953: LD_VAR 0 1
105957: PUSH
105958: LD_VAR 0 2
105962: PUSH
105963: LD_INT 4
105965: PLUS
105966: PUSH
105967: LD_INT 0
105969: PUSH
105970: EMPTY
105971: LIST
105972: LIST
105973: LIST
105974: PUSH
105975: LD_VAR 0 1
105979: PUSH
105980: LD_INT 3
105982: MINUS
105983: PUSH
105984: LD_VAR 0 2
105988: PUSH
105989: LD_INT 1
105991: PUSH
105992: EMPTY
105993: LIST
105994: LIST
105995: LIST
105996: PUSH
105997: LD_VAR 0 1
106001: PUSH
106002: LD_INT 4
106004: MINUS
106005: PUSH
106006: LD_VAR 0 2
106010: PUSH
106011: LD_INT 4
106013: MINUS
106014: PUSH
106015: LD_INT 2
106017: PUSH
106018: EMPTY
106019: LIST
106020: LIST
106021: LIST
106022: PUSH
106023: EMPTY
106024: LIST
106025: LIST
106026: LIST
106027: LIST
106028: LIST
106029: ST_TO_ADDR
// end ; 3 :
106030: GO 106452
106032: LD_INT 3
106034: DOUBLE
106035: EQUAL
106036: IFTRUE 106040
106038: GO 106173
106040: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
106041: LD_ADDR_VAR 0 5
106045: PUSH
106046: LD_VAR 0 1
106050: PUSH
106051: LD_INT 3
106053: PLUS
106054: PUSH
106055: LD_VAR 0 2
106059: PUSH
106060: LD_INT 4
106062: PUSH
106063: EMPTY
106064: LIST
106065: LIST
106066: LIST
106067: PUSH
106068: LD_VAR 0 1
106072: PUSH
106073: LD_INT 4
106075: PLUS
106076: PUSH
106077: LD_VAR 0 2
106081: PUSH
106082: LD_INT 4
106084: PLUS
106085: PUSH
106086: LD_INT 5
106088: PUSH
106089: EMPTY
106090: LIST
106091: LIST
106092: LIST
106093: PUSH
106094: LD_VAR 0 1
106098: PUSH
106099: LD_INT 4
106101: MINUS
106102: PUSH
106103: LD_VAR 0 2
106107: PUSH
106108: LD_INT 1
106110: PUSH
106111: EMPTY
106112: LIST
106113: LIST
106114: LIST
106115: PUSH
106116: LD_VAR 0 1
106120: PUSH
106121: LD_VAR 0 2
106125: PUSH
106126: LD_INT 4
106128: MINUS
106129: PUSH
106130: LD_INT 3
106132: PUSH
106133: EMPTY
106134: LIST
106135: LIST
106136: LIST
106137: PUSH
106138: LD_VAR 0 1
106142: PUSH
106143: LD_INT 3
106145: MINUS
106146: PUSH
106147: LD_VAR 0 2
106151: PUSH
106152: LD_INT 3
106154: MINUS
106155: PUSH
106156: LD_INT 2
106158: PUSH
106159: EMPTY
106160: LIST
106161: LIST
106162: LIST
106163: PUSH
106164: EMPTY
106165: LIST
106166: LIST
106167: LIST
106168: LIST
106169: LIST
106170: ST_TO_ADDR
// end ; 4 :
106171: GO 106452
106173: LD_INT 4
106175: DOUBLE
106176: EQUAL
106177: IFTRUE 106181
106179: GO 106314
106181: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
106182: LD_ADDR_VAR 0 5
106186: PUSH
106187: LD_VAR 0 1
106191: PUSH
106192: LD_VAR 0 2
106196: PUSH
106197: LD_INT 4
106199: PLUS
106200: PUSH
106201: LD_INT 0
106203: PUSH
106204: EMPTY
106205: LIST
106206: LIST
106207: LIST
106208: PUSH
106209: LD_VAR 0 1
106213: PUSH
106214: LD_INT 3
106216: PLUS
106217: PUSH
106218: LD_VAR 0 2
106222: PUSH
106223: LD_INT 3
106225: PLUS
106226: PUSH
106227: LD_INT 5
106229: PUSH
106230: EMPTY
106231: LIST
106232: LIST
106233: LIST
106234: PUSH
106235: LD_VAR 0 1
106239: PUSH
106240: LD_INT 4
106242: PLUS
106243: PUSH
106244: LD_VAR 0 2
106248: PUSH
106249: LD_INT 4
106251: PUSH
106252: EMPTY
106253: LIST
106254: LIST
106255: LIST
106256: PUSH
106257: LD_VAR 0 1
106261: PUSH
106262: LD_VAR 0 2
106266: PUSH
106267: LD_INT 3
106269: MINUS
106270: PUSH
106271: LD_INT 3
106273: PUSH
106274: EMPTY
106275: LIST
106276: LIST
106277: LIST
106278: PUSH
106279: LD_VAR 0 1
106283: PUSH
106284: LD_INT 4
106286: MINUS
106287: PUSH
106288: LD_VAR 0 2
106292: PUSH
106293: LD_INT 4
106295: MINUS
106296: PUSH
106297: LD_INT 2
106299: PUSH
106300: EMPTY
106301: LIST
106302: LIST
106303: LIST
106304: PUSH
106305: EMPTY
106306: LIST
106307: LIST
106308: LIST
106309: LIST
106310: LIST
106311: ST_TO_ADDR
// end ; 5 :
106312: GO 106452
106314: LD_INT 5
106316: DOUBLE
106317: EQUAL
106318: IFTRUE 106322
106320: GO 106451
106322: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
106323: LD_ADDR_VAR 0 5
106327: PUSH
106328: LD_VAR 0 1
106332: PUSH
106333: LD_INT 4
106335: MINUS
106336: PUSH
106337: LD_VAR 0 2
106341: PUSH
106342: LD_INT 1
106344: PUSH
106345: EMPTY
106346: LIST
106347: LIST
106348: LIST
106349: PUSH
106350: LD_VAR 0 1
106354: PUSH
106355: LD_VAR 0 2
106359: PUSH
106360: LD_INT 4
106362: MINUS
106363: PUSH
106364: LD_INT 3
106366: PUSH
106367: EMPTY
106368: LIST
106369: LIST
106370: LIST
106371: PUSH
106372: LD_VAR 0 1
106376: PUSH
106377: LD_INT 4
106379: PLUS
106380: PUSH
106381: LD_VAR 0 2
106385: PUSH
106386: LD_INT 4
106388: PLUS
106389: PUSH
106390: LD_INT 5
106392: PUSH
106393: EMPTY
106394: LIST
106395: LIST
106396: LIST
106397: PUSH
106398: LD_VAR 0 1
106402: PUSH
106403: LD_INT 3
106405: PLUS
106406: PUSH
106407: LD_VAR 0 2
106411: PUSH
106412: LD_INT 4
106414: PUSH
106415: EMPTY
106416: LIST
106417: LIST
106418: LIST
106419: PUSH
106420: LD_VAR 0 1
106424: PUSH
106425: LD_VAR 0 2
106429: PUSH
106430: LD_INT 3
106432: PLUS
106433: PUSH
106434: LD_INT 0
106436: PUSH
106437: EMPTY
106438: LIST
106439: LIST
106440: LIST
106441: PUSH
106442: EMPTY
106443: LIST
106444: LIST
106445: LIST
106446: LIST
106447: LIST
106448: ST_TO_ADDR
// end ; end ;
106449: GO 106452
106451: POP
// result := list ;
106452: LD_ADDR_VAR 0 4
106456: PUSH
106457: LD_VAR 0 5
106461: ST_TO_ADDR
// end ;
106462: LD_VAR 0 4
106466: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
106467: LD_INT 0
106469: PPUSH
106470: PPUSH
106471: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
106472: LD_VAR 0 1
106476: NOT
106477: PUSH
106478: LD_VAR 0 2
106482: PUSH
106483: LD_INT 1
106485: PUSH
106486: LD_INT 2
106488: PUSH
106489: LD_INT 3
106491: PUSH
106492: LD_INT 4
106494: PUSH
106495: EMPTY
106496: LIST
106497: LIST
106498: LIST
106499: LIST
106500: IN
106501: NOT
106502: OR
106503: IFFALSE 106507
// exit ;
106505: GO 106590
// tmp := [ ] ;
106507: LD_ADDR_VAR 0 5
106511: PUSH
106512: EMPTY
106513: ST_TO_ADDR
// for i in units do
106514: LD_ADDR_VAR 0 4
106518: PUSH
106519: LD_VAR 0 1
106523: PUSH
106524: FOR_IN
106525: IFFALSE 106559
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
106527: LD_ADDR_VAR 0 5
106531: PUSH
106532: LD_VAR 0 5
106536: PPUSH
106537: LD_VAR 0 4
106541: PPUSH
106542: LD_VAR 0 2
106546: PPUSH
106547: CALL_OW 259
106551: PPUSH
106552: CALL 107963 0 2
106556: ST_TO_ADDR
106557: GO 106524
106559: POP
106560: POP
// if not tmp then
106561: LD_VAR 0 5
106565: NOT
106566: IFFALSE 106570
// exit ;
106568: GO 106590
// result := SortListByListDesc ( units , tmp ) ;
106570: LD_ADDR_VAR 0 3
106574: PUSH
106575: LD_VAR 0 1
106579: PPUSH
106580: LD_VAR 0 5
106584: PPUSH
106585: CALL_OW 77
106589: ST_TO_ADDR
// end ;
106590: LD_VAR 0 3
106594: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
106595: LD_INT 0
106597: PPUSH
106598: PPUSH
106599: PPUSH
// result := false ;
106600: LD_ADDR_VAR 0 3
106604: PUSH
106605: LD_INT 0
106607: ST_TO_ADDR
// if not building then
106608: LD_VAR 0 2
106612: NOT
106613: IFFALSE 106617
// exit ;
106615: GO 106755
// x := GetX ( building ) ;
106617: LD_ADDR_VAR 0 4
106621: PUSH
106622: LD_VAR 0 2
106626: PPUSH
106627: CALL_OW 250
106631: ST_TO_ADDR
// y := GetY ( building ) ;
106632: LD_ADDR_VAR 0 5
106636: PUSH
106637: LD_VAR 0 2
106641: PPUSH
106642: CALL_OW 251
106646: ST_TO_ADDR
// if not x or not y then
106647: LD_VAR 0 4
106651: NOT
106652: PUSH
106653: LD_VAR 0 5
106657: NOT
106658: OR
106659: IFFALSE 106663
// exit ;
106661: GO 106755
// if GetTaskList ( unit ) then
106663: LD_VAR 0 1
106667: PPUSH
106668: CALL_OW 437
106672: IFFALSE 106755
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106674: LD_STRING e
106676: PUSH
106677: LD_VAR 0 1
106681: PPUSH
106682: CALL_OW 437
106686: PUSH
106687: LD_INT 1
106689: ARRAY
106690: PUSH
106691: LD_INT 1
106693: ARRAY
106694: EQUAL
106695: PUSH
106696: LD_VAR 0 4
106700: PUSH
106701: LD_VAR 0 1
106705: PPUSH
106706: CALL_OW 437
106710: PUSH
106711: LD_INT 1
106713: ARRAY
106714: PUSH
106715: LD_INT 2
106717: ARRAY
106718: EQUAL
106719: AND
106720: PUSH
106721: LD_VAR 0 5
106725: PUSH
106726: LD_VAR 0 1
106730: PPUSH
106731: CALL_OW 437
106735: PUSH
106736: LD_INT 1
106738: ARRAY
106739: PUSH
106740: LD_INT 3
106742: ARRAY
106743: EQUAL
106744: AND
106745: IFFALSE 106755
// result := true end ;
106747: LD_ADDR_VAR 0 3
106751: PUSH
106752: LD_INT 1
106754: ST_TO_ADDR
// end ;
106755: LD_VAR 0 3
106759: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
106760: LD_INT 0
106762: PPUSH
// result := false ;
106763: LD_ADDR_VAR 0 4
106767: PUSH
106768: LD_INT 0
106770: ST_TO_ADDR
// if GetTaskList ( unit ) then
106771: LD_VAR 0 1
106775: PPUSH
106776: CALL_OW 437
106780: IFFALSE 106863
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106782: LD_STRING M
106784: PUSH
106785: LD_VAR 0 1
106789: PPUSH
106790: CALL_OW 437
106794: PUSH
106795: LD_INT 1
106797: ARRAY
106798: PUSH
106799: LD_INT 1
106801: ARRAY
106802: EQUAL
106803: PUSH
106804: LD_VAR 0 2
106808: PUSH
106809: LD_VAR 0 1
106813: PPUSH
106814: CALL_OW 437
106818: PUSH
106819: LD_INT 1
106821: ARRAY
106822: PUSH
106823: LD_INT 2
106825: ARRAY
106826: EQUAL
106827: AND
106828: PUSH
106829: LD_VAR 0 3
106833: PUSH
106834: LD_VAR 0 1
106838: PPUSH
106839: CALL_OW 437
106843: PUSH
106844: LD_INT 1
106846: ARRAY
106847: PUSH
106848: LD_INT 3
106850: ARRAY
106851: EQUAL
106852: AND
106853: IFFALSE 106863
// result := true ;
106855: LD_ADDR_VAR 0 4
106859: PUSH
106860: LD_INT 1
106862: ST_TO_ADDR
// end ; end ;
106863: LD_VAR 0 4
106867: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
106868: LD_INT 0
106870: PPUSH
106871: PPUSH
106872: PPUSH
106873: PPUSH
// if not unit or not area then
106874: LD_VAR 0 1
106878: NOT
106879: PUSH
106880: LD_VAR 0 2
106884: NOT
106885: OR
106886: IFFALSE 106890
// exit ;
106888: GO 107066
// tmp := AreaToList ( area , i ) ;
106890: LD_ADDR_VAR 0 6
106894: PUSH
106895: LD_VAR 0 2
106899: PPUSH
106900: LD_VAR 0 5
106904: PPUSH
106905: CALL_OW 517
106909: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
106910: LD_ADDR_VAR 0 5
106914: PUSH
106915: DOUBLE
106916: LD_INT 1
106918: DEC
106919: ST_TO_ADDR
106920: LD_VAR 0 6
106924: PUSH
106925: LD_INT 1
106927: ARRAY
106928: PUSH
106929: FOR_TO
106930: IFFALSE 107064
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
106932: LD_ADDR_VAR 0 7
106936: PUSH
106937: LD_VAR 0 6
106941: PUSH
106942: LD_INT 1
106944: ARRAY
106945: PUSH
106946: LD_VAR 0 5
106950: ARRAY
106951: PUSH
106952: LD_VAR 0 6
106956: PUSH
106957: LD_INT 2
106959: ARRAY
106960: PUSH
106961: LD_VAR 0 5
106965: ARRAY
106966: PUSH
106967: EMPTY
106968: LIST
106969: LIST
106970: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
106971: LD_INT 92
106973: PUSH
106974: LD_VAR 0 7
106978: PUSH
106979: LD_INT 1
106981: ARRAY
106982: PUSH
106983: LD_VAR 0 7
106987: PUSH
106988: LD_INT 2
106990: ARRAY
106991: PUSH
106992: LD_INT 2
106994: PUSH
106995: EMPTY
106996: LIST
106997: LIST
106998: LIST
106999: LIST
107000: PPUSH
107001: CALL_OW 69
107005: PUSH
107006: LD_INT 0
107008: EQUAL
107009: IFFALSE 107062
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
107011: LD_VAR 0 1
107015: PPUSH
107016: LD_VAR 0 7
107020: PUSH
107021: LD_INT 1
107023: ARRAY
107024: PPUSH
107025: LD_VAR 0 7
107029: PUSH
107030: LD_INT 2
107032: ARRAY
107033: PPUSH
107034: LD_VAR 0 3
107038: PPUSH
107039: CALL_OW 48
// result := IsPlaced ( unit ) ;
107043: LD_ADDR_VAR 0 4
107047: PUSH
107048: LD_VAR 0 1
107052: PPUSH
107053: CALL_OW 305
107057: ST_TO_ADDR
// exit ;
107058: POP
107059: POP
107060: GO 107066
// end ; end ;
107062: GO 106929
107064: POP
107065: POP
// end ;
107066: LD_VAR 0 4
107070: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
107071: LD_INT 0
107073: PPUSH
107074: PPUSH
107075: PPUSH
// if not side or side > 8 then
107076: LD_VAR 0 1
107080: NOT
107081: PUSH
107082: LD_VAR 0 1
107086: PUSH
107087: LD_INT 8
107089: GREATER
107090: OR
107091: IFFALSE 107095
// exit ;
107093: GO 107282
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
107095: LD_ADDR_VAR 0 4
107099: PUSH
107100: LD_INT 22
107102: PUSH
107103: LD_VAR 0 1
107107: PUSH
107108: EMPTY
107109: LIST
107110: LIST
107111: PUSH
107112: LD_INT 21
107114: PUSH
107115: LD_INT 3
107117: PUSH
107118: EMPTY
107119: LIST
107120: LIST
107121: PUSH
107122: EMPTY
107123: LIST
107124: LIST
107125: PPUSH
107126: CALL_OW 69
107130: ST_TO_ADDR
// if not tmp then
107131: LD_VAR 0 4
107135: NOT
107136: IFFALSE 107140
// exit ;
107138: GO 107282
// enable_addtolog := true ;
107140: LD_ADDR_OWVAR 81
107144: PUSH
107145: LD_INT 1
107147: ST_TO_ADDR
// AddToLog ( [ ) ;
107148: LD_STRING [
107150: PPUSH
107151: CALL_OW 561
// for i in tmp do
107155: LD_ADDR_VAR 0 3
107159: PUSH
107160: LD_VAR 0 4
107164: PUSH
107165: FOR_IN
107166: IFFALSE 107273
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
107168: LD_STRING [
107170: PUSH
107171: LD_VAR 0 3
107175: PPUSH
107176: CALL_OW 266
107180: STR
107181: PUSH
107182: LD_STRING , 
107184: STR
107185: PUSH
107186: LD_VAR 0 3
107190: PPUSH
107191: CALL_OW 250
107195: STR
107196: PUSH
107197: LD_STRING , 
107199: STR
107200: PUSH
107201: LD_VAR 0 3
107205: PPUSH
107206: CALL_OW 251
107210: STR
107211: PUSH
107212: LD_STRING , 
107214: STR
107215: PUSH
107216: LD_VAR 0 3
107220: PPUSH
107221: CALL_OW 254
107225: STR
107226: PUSH
107227: LD_STRING , 
107229: STR
107230: PUSH
107231: LD_VAR 0 3
107235: PPUSH
107236: LD_INT 1
107238: PPUSH
107239: CALL_OW 268
107243: STR
107244: PUSH
107245: LD_STRING , 
107247: STR
107248: PUSH
107249: LD_VAR 0 3
107253: PPUSH
107254: LD_INT 2
107256: PPUSH
107257: CALL_OW 268
107261: STR
107262: PUSH
107263: LD_STRING ],
107265: STR
107266: PPUSH
107267: CALL_OW 561
// end ;
107271: GO 107165
107273: POP
107274: POP
// AddToLog ( ]; ) ;
107275: LD_STRING ];
107277: PPUSH
107278: CALL_OW 561
// end ;
107282: LD_VAR 0 2
107286: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
107287: LD_INT 0
107289: PPUSH
107290: PPUSH
107291: PPUSH
107292: PPUSH
107293: PPUSH
// if not area or not rate or not max then
107294: LD_VAR 0 1
107298: NOT
107299: PUSH
107300: LD_VAR 0 2
107304: NOT
107305: OR
107306: PUSH
107307: LD_VAR 0 4
107311: NOT
107312: OR
107313: IFFALSE 107317
// exit ;
107315: GO 107506
// while 1 do
107317: LD_INT 1
107319: IFFALSE 107506
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
107321: LD_ADDR_VAR 0 9
107325: PUSH
107326: LD_VAR 0 1
107330: PPUSH
107331: LD_INT 1
107333: PPUSH
107334: CALL_OW 287
107338: PUSH
107339: LD_INT 10
107341: MUL
107342: ST_TO_ADDR
// r := rate / 10 ;
107343: LD_ADDR_VAR 0 7
107347: PUSH
107348: LD_VAR 0 2
107352: PUSH
107353: LD_INT 10
107355: DIVREAL
107356: ST_TO_ADDR
// time := 1 1$00 ;
107357: LD_ADDR_VAR 0 8
107361: PUSH
107362: LD_INT 2100
107364: ST_TO_ADDR
// if amount < min then
107365: LD_VAR 0 9
107369: PUSH
107370: LD_VAR 0 3
107374: LESS
107375: IFFALSE 107393
// r := r * 2 else
107377: LD_ADDR_VAR 0 7
107381: PUSH
107382: LD_VAR 0 7
107386: PUSH
107387: LD_INT 2
107389: MUL
107390: ST_TO_ADDR
107391: GO 107419
// if amount > max then
107393: LD_VAR 0 9
107397: PUSH
107398: LD_VAR 0 4
107402: GREATER
107403: IFFALSE 107419
// r := r / 2 ;
107405: LD_ADDR_VAR 0 7
107409: PUSH
107410: LD_VAR 0 7
107414: PUSH
107415: LD_INT 2
107417: DIVREAL
107418: ST_TO_ADDR
// time := time / r ;
107419: LD_ADDR_VAR 0 8
107423: PUSH
107424: LD_VAR 0 8
107428: PUSH
107429: LD_VAR 0 7
107433: DIVREAL
107434: ST_TO_ADDR
// if time < 0 then
107435: LD_VAR 0 8
107439: PUSH
107440: LD_INT 0
107442: LESS
107443: IFFALSE 107460
// time := time * - 1 ;
107445: LD_ADDR_VAR 0 8
107449: PUSH
107450: LD_VAR 0 8
107454: PUSH
107455: LD_INT 1
107457: NEG
107458: MUL
107459: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
107460: LD_VAR 0 8
107464: PUSH
107465: LD_INT 35
107467: PPUSH
107468: LD_INT 875
107470: PPUSH
107471: CALL_OW 12
107475: PLUS
107476: PPUSH
107477: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
107481: LD_INT 1
107483: PPUSH
107484: LD_INT 5
107486: PPUSH
107487: CALL_OW 12
107491: PPUSH
107492: LD_VAR 0 1
107496: PPUSH
107497: LD_INT 1
107499: PPUSH
107500: CALL_OW 55
// end ;
107504: GO 107317
// end ;
107506: LD_VAR 0 5
107510: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
107511: LD_INT 0
107513: PPUSH
107514: PPUSH
107515: PPUSH
107516: PPUSH
107517: PPUSH
107518: PPUSH
107519: PPUSH
107520: PPUSH
// if not turrets or not factories then
107521: LD_VAR 0 1
107525: NOT
107526: PUSH
107527: LD_VAR 0 2
107531: NOT
107532: OR
107533: IFFALSE 107537
// exit ;
107535: GO 107844
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
107537: LD_ADDR_VAR 0 10
107541: PUSH
107542: LD_INT 5
107544: PUSH
107545: LD_INT 6
107547: PUSH
107548: EMPTY
107549: LIST
107550: LIST
107551: PUSH
107552: LD_INT 2
107554: PUSH
107555: LD_INT 4
107557: PUSH
107558: EMPTY
107559: LIST
107560: LIST
107561: PUSH
107562: LD_INT 3
107564: PUSH
107565: LD_INT 5
107567: PUSH
107568: EMPTY
107569: LIST
107570: LIST
107571: PUSH
107572: EMPTY
107573: LIST
107574: LIST
107575: LIST
107576: PUSH
107577: LD_INT 24
107579: PUSH
107580: LD_INT 25
107582: PUSH
107583: EMPTY
107584: LIST
107585: LIST
107586: PUSH
107587: LD_INT 23
107589: PUSH
107590: LD_INT 27
107592: PUSH
107593: EMPTY
107594: LIST
107595: LIST
107596: PUSH
107597: EMPTY
107598: LIST
107599: LIST
107600: PUSH
107601: LD_INT 42
107603: PUSH
107604: LD_INT 43
107606: PUSH
107607: EMPTY
107608: LIST
107609: LIST
107610: PUSH
107611: LD_INT 44
107613: PUSH
107614: LD_INT 46
107616: PUSH
107617: EMPTY
107618: LIST
107619: LIST
107620: PUSH
107621: LD_INT 45
107623: PUSH
107624: LD_INT 47
107626: PUSH
107627: EMPTY
107628: LIST
107629: LIST
107630: PUSH
107631: EMPTY
107632: LIST
107633: LIST
107634: LIST
107635: PUSH
107636: EMPTY
107637: LIST
107638: LIST
107639: LIST
107640: ST_TO_ADDR
// result := [ ] ;
107641: LD_ADDR_VAR 0 3
107645: PUSH
107646: EMPTY
107647: ST_TO_ADDR
// for i in turrets do
107648: LD_ADDR_VAR 0 4
107652: PUSH
107653: LD_VAR 0 1
107657: PUSH
107658: FOR_IN
107659: IFFALSE 107842
// begin nat := GetNation ( i ) ;
107661: LD_ADDR_VAR 0 7
107665: PUSH
107666: LD_VAR 0 4
107670: PPUSH
107671: CALL_OW 248
107675: ST_TO_ADDR
// weapon := 0 ;
107676: LD_ADDR_VAR 0 8
107680: PUSH
107681: LD_INT 0
107683: ST_TO_ADDR
// if not nat then
107684: LD_VAR 0 7
107688: NOT
107689: IFFALSE 107693
// continue ;
107691: GO 107658
// for j in list [ nat ] do
107693: LD_ADDR_VAR 0 5
107697: PUSH
107698: LD_VAR 0 10
107702: PUSH
107703: LD_VAR 0 7
107707: ARRAY
107708: PUSH
107709: FOR_IN
107710: IFFALSE 107751
// if GetBWeapon ( i ) = j [ 1 ] then
107712: LD_VAR 0 4
107716: PPUSH
107717: CALL_OW 269
107721: PUSH
107722: LD_VAR 0 5
107726: PUSH
107727: LD_INT 1
107729: ARRAY
107730: EQUAL
107731: IFFALSE 107749
// begin weapon := j [ 2 ] ;
107733: LD_ADDR_VAR 0 8
107737: PUSH
107738: LD_VAR 0 5
107742: PUSH
107743: LD_INT 2
107745: ARRAY
107746: ST_TO_ADDR
// break ;
107747: GO 107751
// end ;
107749: GO 107709
107751: POP
107752: POP
// if not weapon then
107753: LD_VAR 0 8
107757: NOT
107758: IFFALSE 107762
// continue ;
107760: GO 107658
// for k in factories do
107762: LD_ADDR_VAR 0 6
107766: PUSH
107767: LD_VAR 0 2
107771: PUSH
107772: FOR_IN
107773: IFFALSE 107838
// begin weapons := AvailableWeaponList ( k ) ;
107775: LD_ADDR_VAR 0 9
107779: PUSH
107780: LD_VAR 0 6
107784: PPUSH
107785: CALL_OW 478
107789: ST_TO_ADDR
// if not weapons then
107790: LD_VAR 0 9
107794: NOT
107795: IFFALSE 107799
// continue ;
107797: GO 107772
// if weapon in weapons then
107799: LD_VAR 0 8
107803: PUSH
107804: LD_VAR 0 9
107808: IN
107809: IFFALSE 107836
// begin result := [ i , weapon ] ;
107811: LD_ADDR_VAR 0 3
107815: PUSH
107816: LD_VAR 0 4
107820: PUSH
107821: LD_VAR 0 8
107825: PUSH
107826: EMPTY
107827: LIST
107828: LIST
107829: ST_TO_ADDR
// exit ;
107830: POP
107831: POP
107832: POP
107833: POP
107834: GO 107844
// end ; end ;
107836: GO 107772
107838: POP
107839: POP
// end ;
107840: GO 107658
107842: POP
107843: POP
// end ;
107844: LD_VAR 0 3
107848: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
107849: LD_INT 0
107851: PPUSH
// if not side or side > 8 then
107852: LD_VAR 0 3
107856: NOT
107857: PUSH
107858: LD_VAR 0 3
107862: PUSH
107863: LD_INT 8
107865: GREATER
107866: OR
107867: IFFALSE 107871
// exit ;
107869: GO 107930
// if not range then
107871: LD_VAR 0 4
107875: NOT
107876: IFFALSE 107887
// range := - 12 ;
107878: LD_ADDR_VAR 0 4
107882: PUSH
107883: LD_INT 12
107885: NEG
107886: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
107887: LD_VAR 0 1
107891: PPUSH
107892: LD_VAR 0 2
107896: PPUSH
107897: LD_VAR 0 3
107901: PPUSH
107902: LD_VAR 0 4
107906: PPUSH
107907: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
107911: LD_VAR 0 1
107915: PPUSH
107916: LD_VAR 0 2
107920: PPUSH
107921: LD_VAR 0 3
107925: PPUSH
107926: CALL_OW 331
// end ;
107930: LD_VAR 0 5
107934: RET
// export function Video ( mode ) ; begin
107935: LD_INT 0
107937: PPUSH
// ingame_video = mode ;
107938: LD_ADDR_OWVAR 52
107942: PUSH
107943: LD_VAR 0 1
107947: ST_TO_ADDR
// interface_hidden = mode ;
107948: LD_ADDR_OWVAR 54
107952: PUSH
107953: LD_VAR 0 1
107957: ST_TO_ADDR
// end ;
107958: LD_VAR 0 2
107962: RET
// export function Join ( array , element ) ; begin
107963: LD_INT 0
107965: PPUSH
// result := Replace ( array , array + 1 , element ) ;
107966: LD_ADDR_VAR 0 3
107970: PUSH
107971: LD_VAR 0 1
107975: PPUSH
107976: LD_VAR 0 1
107980: PUSH
107981: LD_INT 1
107983: PLUS
107984: PPUSH
107985: LD_VAR 0 2
107989: PPUSH
107990: CALL_OW 1
107994: ST_TO_ADDR
// end ;
107995: LD_VAR 0 3
107999: RET
// export function JoinUnion ( array , element ) ; begin
108000: LD_INT 0
108002: PPUSH
// result := array union element ;
108003: LD_ADDR_VAR 0 3
108007: PUSH
108008: LD_VAR 0 1
108012: PUSH
108013: LD_VAR 0 2
108017: UNION
108018: ST_TO_ADDR
// end ;
108019: LD_VAR 0 3
108023: RET
// export function GetBehemoths ( side ) ; begin
108024: LD_INT 0
108026: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
108027: LD_ADDR_VAR 0 2
108031: PUSH
108032: LD_INT 22
108034: PUSH
108035: LD_VAR 0 1
108039: PUSH
108040: EMPTY
108041: LIST
108042: LIST
108043: PUSH
108044: LD_INT 31
108046: PUSH
108047: LD_INT 25
108049: PUSH
108050: EMPTY
108051: LIST
108052: LIST
108053: PUSH
108054: EMPTY
108055: LIST
108056: LIST
108057: PPUSH
108058: CALL_OW 69
108062: ST_TO_ADDR
// end ;
108063: LD_VAR 0 2
108067: RET
// export function Shuffle ( array ) ; var i , index ; begin
108068: LD_INT 0
108070: PPUSH
108071: PPUSH
108072: PPUSH
// result := [ ] ;
108073: LD_ADDR_VAR 0 2
108077: PUSH
108078: EMPTY
108079: ST_TO_ADDR
// if not array then
108080: LD_VAR 0 1
108084: NOT
108085: IFFALSE 108089
// exit ;
108087: GO 108188
// Randomize ;
108089: CALL_OW 10
// for i = array downto 1 do
108093: LD_ADDR_VAR 0 3
108097: PUSH
108098: DOUBLE
108099: LD_VAR 0 1
108103: INC
108104: ST_TO_ADDR
108105: LD_INT 1
108107: PUSH
108108: FOR_DOWNTO
108109: IFFALSE 108186
// begin index := rand ( 1 , array ) ;
108111: LD_ADDR_VAR 0 4
108115: PUSH
108116: LD_INT 1
108118: PPUSH
108119: LD_VAR 0 1
108123: PPUSH
108124: CALL_OW 12
108128: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
108129: LD_ADDR_VAR 0 2
108133: PUSH
108134: LD_VAR 0 2
108138: PPUSH
108139: LD_VAR 0 2
108143: PUSH
108144: LD_INT 1
108146: PLUS
108147: PPUSH
108148: LD_VAR 0 1
108152: PUSH
108153: LD_VAR 0 4
108157: ARRAY
108158: PPUSH
108159: CALL_OW 2
108163: ST_TO_ADDR
// array := Delete ( array , index ) ;
108164: LD_ADDR_VAR 0 1
108168: PUSH
108169: LD_VAR 0 1
108173: PPUSH
108174: LD_VAR 0 4
108178: PPUSH
108179: CALL_OW 3
108183: ST_TO_ADDR
// end ;
108184: GO 108108
108186: POP
108187: POP
// end ;
108188: LD_VAR 0 2
108192: RET
// export function GetBaseMaterials ( base ) ; begin
108193: LD_INT 0
108195: PPUSH
// result := [ 0 , 0 , 0 ] ;
108196: LD_ADDR_VAR 0 2
108200: PUSH
108201: LD_INT 0
108203: PUSH
108204: LD_INT 0
108206: PUSH
108207: LD_INT 0
108209: PUSH
108210: EMPTY
108211: LIST
108212: LIST
108213: LIST
108214: ST_TO_ADDR
// if not base then
108215: LD_VAR 0 1
108219: NOT
108220: IFFALSE 108224
// exit ;
108222: GO 108273
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
108224: LD_ADDR_VAR 0 2
108228: PUSH
108229: LD_VAR 0 1
108233: PPUSH
108234: LD_INT 1
108236: PPUSH
108237: CALL_OW 275
108241: PUSH
108242: LD_VAR 0 1
108246: PPUSH
108247: LD_INT 2
108249: PPUSH
108250: CALL_OW 275
108254: PUSH
108255: LD_VAR 0 1
108259: PPUSH
108260: LD_INT 3
108262: PPUSH
108263: CALL_OW 275
108267: PUSH
108268: EMPTY
108269: LIST
108270: LIST
108271: LIST
108272: ST_TO_ADDR
// end ;
108273: LD_VAR 0 2
108277: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
108278: LD_INT 0
108280: PPUSH
108281: PPUSH
// result := array ;
108282: LD_ADDR_VAR 0 3
108286: PUSH
108287: LD_VAR 0 1
108291: ST_TO_ADDR
// if size >= result then
108292: LD_VAR 0 2
108296: PUSH
108297: LD_VAR 0 3
108301: GREATEREQUAL
108302: IFFALSE 108306
// exit ;
108304: GO 108356
// if size then
108306: LD_VAR 0 2
108310: IFFALSE 108356
// for i := array downto size do
108312: LD_ADDR_VAR 0 4
108316: PUSH
108317: DOUBLE
108318: LD_VAR 0 1
108322: INC
108323: ST_TO_ADDR
108324: LD_VAR 0 2
108328: PUSH
108329: FOR_DOWNTO
108330: IFFALSE 108354
// result := Delete ( result , result ) ;
108332: LD_ADDR_VAR 0 3
108336: PUSH
108337: LD_VAR 0 3
108341: PPUSH
108342: LD_VAR 0 3
108346: PPUSH
108347: CALL_OW 3
108351: ST_TO_ADDR
108352: GO 108329
108354: POP
108355: POP
// end ;
108356: LD_VAR 0 3
108360: RET
// export function ComExit ( unit ) ; var tmp ; begin
108361: LD_INT 0
108363: PPUSH
108364: PPUSH
// if not IsInUnit ( unit ) then
108365: LD_VAR 0 1
108369: PPUSH
108370: CALL_OW 310
108374: NOT
108375: IFFALSE 108379
// exit ;
108377: GO 108439
// tmp := IsInUnit ( unit ) ;
108379: LD_ADDR_VAR 0 3
108383: PUSH
108384: LD_VAR 0 1
108388: PPUSH
108389: CALL_OW 310
108393: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
108394: LD_VAR 0 3
108398: PPUSH
108399: CALL_OW 247
108403: PUSH
108404: LD_INT 2
108406: EQUAL
108407: IFFALSE 108420
// ComExitVehicle ( unit ) else
108409: LD_VAR 0 1
108413: PPUSH
108414: CALL_OW 121
108418: GO 108429
// ComExitBuilding ( unit ) ;
108420: LD_VAR 0 1
108424: PPUSH
108425: CALL_OW 122
// result := tmp ;
108429: LD_ADDR_VAR 0 2
108433: PUSH
108434: LD_VAR 0 3
108438: ST_TO_ADDR
// end ;
108439: LD_VAR 0 2
108443: RET
// export function ComExitAll ( units ) ; var i ; begin
108444: LD_INT 0
108446: PPUSH
108447: PPUSH
// if not units then
108448: LD_VAR 0 1
108452: NOT
108453: IFFALSE 108457
// exit ;
108455: GO 108483
// for i in units do
108457: LD_ADDR_VAR 0 3
108461: PUSH
108462: LD_VAR 0 1
108466: PUSH
108467: FOR_IN
108468: IFFALSE 108481
// ComExit ( i ) ;
108470: LD_VAR 0 3
108474: PPUSH
108475: CALL 108361 0 1
108479: GO 108467
108481: POP
108482: POP
// end ;
108483: LD_VAR 0 2
108487: RET
// export function ResetHc ; begin
108488: LD_INT 0
108490: PPUSH
// InitHc ;
108491: CALL_OW 19
// hc_importance := 0 ;
108495: LD_ADDR_OWVAR 32
108499: PUSH
108500: LD_INT 0
108502: ST_TO_ADDR
// end ;
108503: LD_VAR 0 1
108507: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
108508: LD_INT 0
108510: PPUSH
108511: PPUSH
108512: PPUSH
// _x := ( x1 + x2 ) div 2 ;
108513: LD_ADDR_VAR 0 6
108517: PUSH
108518: LD_VAR 0 1
108522: PUSH
108523: LD_VAR 0 3
108527: PLUS
108528: PUSH
108529: LD_INT 2
108531: DIV
108532: ST_TO_ADDR
// if _x < 0 then
108533: LD_VAR 0 6
108537: PUSH
108538: LD_INT 0
108540: LESS
108541: IFFALSE 108558
// _x := _x * - 1 ;
108543: LD_ADDR_VAR 0 6
108547: PUSH
108548: LD_VAR 0 6
108552: PUSH
108553: LD_INT 1
108555: NEG
108556: MUL
108557: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
108558: LD_ADDR_VAR 0 7
108562: PUSH
108563: LD_VAR 0 2
108567: PUSH
108568: LD_VAR 0 4
108572: PLUS
108573: PUSH
108574: LD_INT 2
108576: DIV
108577: ST_TO_ADDR
// if _y < 0 then
108578: LD_VAR 0 7
108582: PUSH
108583: LD_INT 0
108585: LESS
108586: IFFALSE 108603
// _y := _y * - 1 ;
108588: LD_ADDR_VAR 0 7
108592: PUSH
108593: LD_VAR 0 7
108597: PUSH
108598: LD_INT 1
108600: NEG
108601: MUL
108602: ST_TO_ADDR
// result := [ _x , _y ] ;
108603: LD_ADDR_VAR 0 5
108607: PUSH
108608: LD_VAR 0 6
108612: PUSH
108613: LD_VAR 0 7
108617: PUSH
108618: EMPTY
108619: LIST
108620: LIST
108621: ST_TO_ADDR
// end ;
108622: LD_VAR 0 5
108626: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
108627: LD_INT 0
108629: PPUSH
108630: PPUSH
108631: PPUSH
108632: PPUSH
// task := GetTaskList ( unit ) ;
108633: LD_ADDR_VAR 0 7
108637: PUSH
108638: LD_VAR 0 1
108642: PPUSH
108643: CALL_OW 437
108647: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
108648: LD_VAR 0 7
108652: NOT
108653: PUSH
108654: LD_VAR 0 1
108658: PPUSH
108659: LD_VAR 0 2
108663: PPUSH
108664: CALL_OW 308
108668: NOT
108669: AND
108670: IFFALSE 108674
// exit ;
108672: GO 108792
// if IsInArea ( unit , area ) then
108674: LD_VAR 0 1
108678: PPUSH
108679: LD_VAR 0 2
108683: PPUSH
108684: CALL_OW 308
108688: IFFALSE 108706
// begin ComMoveToArea ( unit , goAway ) ;
108690: LD_VAR 0 1
108694: PPUSH
108695: LD_VAR 0 3
108699: PPUSH
108700: CALL_OW 113
// exit ;
108704: GO 108792
// end ; if task [ 1 ] [ 1 ] <> M then
108706: LD_VAR 0 7
108710: PUSH
108711: LD_INT 1
108713: ARRAY
108714: PUSH
108715: LD_INT 1
108717: ARRAY
108718: PUSH
108719: LD_STRING M
108721: NONEQUAL
108722: IFFALSE 108726
// exit ;
108724: GO 108792
// x := task [ 1 ] [ 2 ] ;
108726: LD_ADDR_VAR 0 5
108730: PUSH
108731: LD_VAR 0 7
108735: PUSH
108736: LD_INT 1
108738: ARRAY
108739: PUSH
108740: LD_INT 2
108742: ARRAY
108743: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
108744: LD_ADDR_VAR 0 6
108748: PUSH
108749: LD_VAR 0 7
108753: PUSH
108754: LD_INT 1
108756: ARRAY
108757: PUSH
108758: LD_INT 3
108760: ARRAY
108761: ST_TO_ADDR
// if InArea ( x , y , area ) then
108762: LD_VAR 0 5
108766: PPUSH
108767: LD_VAR 0 6
108771: PPUSH
108772: LD_VAR 0 2
108776: PPUSH
108777: CALL_OW 309
108781: IFFALSE 108792
// ComStop ( unit ) ;
108783: LD_VAR 0 1
108787: PPUSH
108788: CALL_OW 141
// end ;
108792: LD_VAR 0 4
108796: RET
// export function Abs ( value ) ; begin
108797: LD_INT 0
108799: PPUSH
// result := value ;
108800: LD_ADDR_VAR 0 2
108804: PUSH
108805: LD_VAR 0 1
108809: ST_TO_ADDR
// if value < 0 then
108810: LD_VAR 0 1
108814: PUSH
108815: LD_INT 0
108817: LESS
108818: IFFALSE 108835
// result := value * - 1 ;
108820: LD_ADDR_VAR 0 2
108824: PUSH
108825: LD_VAR 0 1
108829: PUSH
108830: LD_INT 1
108832: NEG
108833: MUL
108834: ST_TO_ADDR
// end ;
108835: LD_VAR 0 2
108839: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
108840: LD_INT 0
108842: PPUSH
108843: PPUSH
108844: PPUSH
108845: PPUSH
108846: PPUSH
108847: PPUSH
108848: PPUSH
108849: PPUSH
// if not unit or not building then
108850: LD_VAR 0 1
108854: NOT
108855: PUSH
108856: LD_VAR 0 2
108860: NOT
108861: OR
108862: IFFALSE 108866
// exit ;
108864: GO 109092
// x := GetX ( building ) ;
108866: LD_ADDR_VAR 0 4
108870: PUSH
108871: LD_VAR 0 2
108875: PPUSH
108876: CALL_OW 250
108880: ST_TO_ADDR
// y := GetY ( building ) ;
108881: LD_ADDR_VAR 0 6
108885: PUSH
108886: LD_VAR 0 2
108890: PPUSH
108891: CALL_OW 251
108895: ST_TO_ADDR
// d := GetDir ( building ) ;
108896: LD_ADDR_VAR 0 8
108900: PUSH
108901: LD_VAR 0 2
108905: PPUSH
108906: CALL_OW 254
108910: ST_TO_ADDR
// r := 4 ;
108911: LD_ADDR_VAR 0 9
108915: PUSH
108916: LD_INT 4
108918: ST_TO_ADDR
// for i := 1 to 5 do
108919: LD_ADDR_VAR 0 10
108923: PUSH
108924: DOUBLE
108925: LD_INT 1
108927: DEC
108928: ST_TO_ADDR
108929: LD_INT 5
108931: PUSH
108932: FOR_TO
108933: IFFALSE 109090
// begin _x := ShiftX ( x , d , r + i ) ;
108935: LD_ADDR_VAR 0 5
108939: PUSH
108940: LD_VAR 0 4
108944: PPUSH
108945: LD_VAR 0 8
108949: PPUSH
108950: LD_VAR 0 9
108954: PUSH
108955: LD_VAR 0 10
108959: PLUS
108960: PPUSH
108961: CALL_OW 272
108965: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
108966: LD_ADDR_VAR 0 7
108970: PUSH
108971: LD_VAR 0 6
108975: PPUSH
108976: LD_VAR 0 8
108980: PPUSH
108981: LD_VAR 0 9
108985: PUSH
108986: LD_VAR 0 10
108990: PLUS
108991: PPUSH
108992: CALL_OW 273
108996: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
108997: LD_VAR 0 5
109001: PPUSH
109002: LD_VAR 0 7
109006: PPUSH
109007: CALL_OW 488
109011: PUSH
109012: LD_VAR 0 5
109016: PPUSH
109017: LD_VAR 0 7
109021: PPUSH
109022: CALL_OW 428
109026: PPUSH
109027: CALL_OW 247
109031: PUSH
109032: LD_INT 3
109034: PUSH
109035: LD_INT 2
109037: PUSH
109038: EMPTY
109039: LIST
109040: LIST
109041: IN
109042: NOT
109043: AND
109044: IFFALSE 109088
// begin ComMoveXY ( unit , _x , _y ) ;
109046: LD_VAR 0 1
109050: PPUSH
109051: LD_VAR 0 5
109055: PPUSH
109056: LD_VAR 0 7
109060: PPUSH
109061: CALL_OW 111
// result := [ _x , _y ] ;
109065: LD_ADDR_VAR 0 3
109069: PUSH
109070: LD_VAR 0 5
109074: PUSH
109075: LD_VAR 0 7
109079: PUSH
109080: EMPTY
109081: LIST
109082: LIST
109083: ST_TO_ADDR
// exit ;
109084: POP
109085: POP
109086: GO 109092
// end ; end ;
109088: GO 108932
109090: POP
109091: POP
// end ;
109092: LD_VAR 0 3
109096: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
109097: LD_INT 0
109099: PPUSH
109100: PPUSH
109101: PPUSH
// result := 0 ;
109102: LD_ADDR_VAR 0 3
109106: PUSH
109107: LD_INT 0
109109: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
109110: LD_VAR 0 1
109114: PUSH
109115: LD_INT 0
109117: LESS
109118: PUSH
109119: LD_VAR 0 1
109123: PUSH
109124: LD_INT 8
109126: GREATER
109127: OR
109128: PUSH
109129: LD_VAR 0 2
109133: PUSH
109134: LD_INT 0
109136: LESS
109137: OR
109138: PUSH
109139: LD_VAR 0 2
109143: PUSH
109144: LD_INT 8
109146: GREATER
109147: OR
109148: IFFALSE 109152
// exit ;
109150: GO 109227
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
109152: LD_ADDR_VAR 0 4
109156: PUSH
109157: LD_INT 22
109159: PUSH
109160: LD_VAR 0 2
109164: PUSH
109165: EMPTY
109166: LIST
109167: LIST
109168: PPUSH
109169: CALL_OW 69
109173: PUSH
109174: FOR_IN
109175: IFFALSE 109225
// begin un := UnitShoot ( i ) ;
109177: LD_ADDR_VAR 0 5
109181: PUSH
109182: LD_VAR 0 4
109186: PPUSH
109187: CALL_OW 504
109191: ST_TO_ADDR
// if GetSide ( un ) = side1 then
109192: LD_VAR 0 5
109196: PPUSH
109197: CALL_OW 255
109201: PUSH
109202: LD_VAR 0 1
109206: EQUAL
109207: IFFALSE 109223
// begin result := un ;
109209: LD_ADDR_VAR 0 3
109213: PUSH
109214: LD_VAR 0 5
109218: ST_TO_ADDR
// exit ;
109219: POP
109220: POP
109221: GO 109227
// end ; end ;
109223: GO 109174
109225: POP
109226: POP
// end ;
109227: LD_VAR 0 3
109231: RET
// export function GetCargoBay ( units ) ; begin
109232: LD_INT 0
109234: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
109235: LD_ADDR_VAR 0 2
109239: PUSH
109240: LD_VAR 0 1
109244: PPUSH
109245: LD_INT 2
109247: PUSH
109248: LD_INT 34
109250: PUSH
109251: LD_INT 12
109253: PUSH
109254: EMPTY
109255: LIST
109256: LIST
109257: PUSH
109258: LD_INT 34
109260: PUSH
109261: LD_INT 51
109263: PUSH
109264: EMPTY
109265: LIST
109266: LIST
109267: PUSH
109268: LD_INT 34
109270: PUSH
109271: LD_INT 32
109273: PUSH
109274: EMPTY
109275: LIST
109276: LIST
109277: PUSH
109278: LD_INT 34
109280: PUSH
109281: LD_INT 89
109283: PUSH
109284: EMPTY
109285: LIST
109286: LIST
109287: PUSH
109288: EMPTY
109289: LIST
109290: LIST
109291: LIST
109292: LIST
109293: LIST
109294: PPUSH
109295: CALL_OW 72
109299: ST_TO_ADDR
// end ;
109300: LD_VAR 0 2
109304: RET
// export function Negate ( value ) ; begin
109305: LD_INT 0
109307: PPUSH
// result := not value ;
109308: LD_ADDR_VAR 0 2
109312: PUSH
109313: LD_VAR 0 1
109317: NOT
109318: ST_TO_ADDR
// end ;
109319: LD_VAR 0 2
109323: RET
// export function Inc ( value ) ; begin
109324: LD_INT 0
109326: PPUSH
// result := value + 1 ;
109327: LD_ADDR_VAR 0 2
109331: PUSH
109332: LD_VAR 0 1
109336: PUSH
109337: LD_INT 1
109339: PLUS
109340: ST_TO_ADDR
// end ;
109341: LD_VAR 0 2
109345: RET
// export function Dec ( value ) ; begin
109346: LD_INT 0
109348: PPUSH
// result := value - 1 ;
109349: LD_ADDR_VAR 0 2
109353: PUSH
109354: LD_VAR 0 1
109358: PUSH
109359: LD_INT 1
109361: MINUS
109362: ST_TO_ADDR
// end ;
109363: LD_VAR 0 2
109367: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
109368: LD_INT 0
109370: PPUSH
109371: PPUSH
109372: PPUSH
109373: PPUSH
109374: PPUSH
109375: PPUSH
109376: PPUSH
109377: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
109378: LD_VAR 0 1
109382: PPUSH
109383: LD_VAR 0 2
109387: PPUSH
109388: CALL_OW 488
109392: NOT
109393: PUSH
109394: LD_VAR 0 3
109398: PPUSH
109399: LD_VAR 0 4
109403: PPUSH
109404: CALL_OW 488
109408: NOT
109409: OR
109410: IFFALSE 109423
// begin result := - 1 ;
109412: LD_ADDR_VAR 0 5
109416: PUSH
109417: LD_INT 1
109419: NEG
109420: ST_TO_ADDR
// exit ;
109421: GO 109658
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
109423: LD_ADDR_VAR 0 12
109427: PUSH
109428: LD_VAR 0 1
109432: PPUSH
109433: LD_VAR 0 2
109437: PPUSH
109438: LD_VAR 0 3
109442: PPUSH
109443: LD_VAR 0 4
109447: PPUSH
109448: CALL 108508 0 4
109452: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
109453: LD_ADDR_VAR 0 11
109457: PUSH
109458: LD_VAR 0 1
109462: PPUSH
109463: LD_VAR 0 2
109467: PPUSH
109468: LD_VAR 0 12
109472: PUSH
109473: LD_INT 1
109475: ARRAY
109476: PPUSH
109477: LD_VAR 0 12
109481: PUSH
109482: LD_INT 2
109484: ARRAY
109485: PPUSH
109486: CALL_OW 298
109490: ST_TO_ADDR
// distance := 9999 ;
109491: LD_ADDR_VAR 0 10
109495: PUSH
109496: LD_INT 9999
109498: ST_TO_ADDR
// for i := 0 to 5 do
109499: LD_ADDR_VAR 0 6
109503: PUSH
109504: DOUBLE
109505: LD_INT 0
109507: DEC
109508: ST_TO_ADDR
109509: LD_INT 5
109511: PUSH
109512: FOR_TO
109513: IFFALSE 109656
// begin _x := ShiftX ( x1 , i , centerDist ) ;
109515: LD_ADDR_VAR 0 7
109519: PUSH
109520: LD_VAR 0 1
109524: PPUSH
109525: LD_VAR 0 6
109529: PPUSH
109530: LD_VAR 0 11
109534: PPUSH
109535: CALL_OW 272
109539: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
109540: LD_ADDR_VAR 0 8
109544: PUSH
109545: LD_VAR 0 2
109549: PPUSH
109550: LD_VAR 0 6
109554: PPUSH
109555: LD_VAR 0 11
109559: PPUSH
109560: CALL_OW 273
109564: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
109565: LD_VAR 0 7
109569: PPUSH
109570: LD_VAR 0 8
109574: PPUSH
109575: CALL_OW 488
109579: NOT
109580: IFFALSE 109584
// continue ;
109582: GO 109512
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
109584: LD_ADDR_VAR 0 9
109588: PUSH
109589: LD_VAR 0 12
109593: PUSH
109594: LD_INT 1
109596: ARRAY
109597: PPUSH
109598: LD_VAR 0 12
109602: PUSH
109603: LD_INT 2
109605: ARRAY
109606: PPUSH
109607: LD_VAR 0 7
109611: PPUSH
109612: LD_VAR 0 8
109616: PPUSH
109617: CALL_OW 298
109621: ST_TO_ADDR
// if tmp < distance then
109622: LD_VAR 0 9
109626: PUSH
109627: LD_VAR 0 10
109631: LESS
109632: IFFALSE 109654
// begin result := i ;
109634: LD_ADDR_VAR 0 5
109638: PUSH
109639: LD_VAR 0 6
109643: ST_TO_ADDR
// distance := tmp ;
109644: LD_ADDR_VAR 0 10
109648: PUSH
109649: LD_VAR 0 9
109653: ST_TO_ADDR
// end ; end ;
109654: GO 109512
109656: POP
109657: POP
// end ;
109658: LD_VAR 0 5
109662: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
109663: LD_INT 0
109665: PPUSH
109666: PPUSH
// if not driver or not IsInUnit ( driver ) then
109667: LD_VAR 0 1
109671: NOT
109672: PUSH
109673: LD_VAR 0 1
109677: PPUSH
109678: CALL_OW 310
109682: NOT
109683: OR
109684: IFFALSE 109688
// exit ;
109686: GO 109778
// vehicle := IsInUnit ( driver ) ;
109688: LD_ADDR_VAR 0 3
109692: PUSH
109693: LD_VAR 0 1
109697: PPUSH
109698: CALL_OW 310
109702: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
109703: LD_VAR 0 1
109707: PPUSH
109708: LD_STRING \
109710: PUSH
109711: LD_INT 0
109713: PUSH
109714: LD_INT 0
109716: PUSH
109717: LD_INT 0
109719: PUSH
109720: LD_INT 0
109722: PUSH
109723: LD_INT 0
109725: PUSH
109726: LD_INT 0
109728: PUSH
109729: EMPTY
109730: LIST
109731: LIST
109732: LIST
109733: LIST
109734: LIST
109735: LIST
109736: LIST
109737: PUSH
109738: LD_STRING E
109740: PUSH
109741: LD_INT 0
109743: PUSH
109744: LD_INT 0
109746: PUSH
109747: LD_VAR 0 3
109751: PUSH
109752: LD_INT 0
109754: PUSH
109755: LD_INT 0
109757: PUSH
109758: LD_INT 0
109760: PUSH
109761: EMPTY
109762: LIST
109763: LIST
109764: LIST
109765: LIST
109766: LIST
109767: LIST
109768: LIST
109769: PUSH
109770: EMPTY
109771: LIST
109772: LIST
109773: PPUSH
109774: CALL_OW 446
// end ;
109778: LD_VAR 0 2
109782: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
109783: LD_INT 0
109785: PPUSH
109786: PPUSH
// if not driver or not IsInUnit ( driver ) then
109787: LD_VAR 0 1
109791: NOT
109792: PUSH
109793: LD_VAR 0 1
109797: PPUSH
109798: CALL_OW 310
109802: NOT
109803: OR
109804: IFFALSE 109808
// exit ;
109806: GO 109898
// vehicle := IsInUnit ( driver ) ;
109808: LD_ADDR_VAR 0 3
109812: PUSH
109813: LD_VAR 0 1
109817: PPUSH
109818: CALL_OW 310
109822: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
109823: LD_VAR 0 1
109827: PPUSH
109828: LD_STRING \
109830: PUSH
109831: LD_INT 0
109833: PUSH
109834: LD_INT 0
109836: PUSH
109837: LD_INT 0
109839: PUSH
109840: LD_INT 0
109842: PUSH
109843: LD_INT 0
109845: PUSH
109846: LD_INT 0
109848: PUSH
109849: EMPTY
109850: LIST
109851: LIST
109852: LIST
109853: LIST
109854: LIST
109855: LIST
109856: LIST
109857: PUSH
109858: LD_STRING E
109860: PUSH
109861: LD_INT 0
109863: PUSH
109864: LD_INT 0
109866: PUSH
109867: LD_VAR 0 3
109871: PUSH
109872: LD_INT 0
109874: PUSH
109875: LD_INT 0
109877: PUSH
109878: LD_INT 0
109880: PUSH
109881: EMPTY
109882: LIST
109883: LIST
109884: LIST
109885: LIST
109886: LIST
109887: LIST
109888: LIST
109889: PUSH
109890: EMPTY
109891: LIST
109892: LIST
109893: PPUSH
109894: CALL_OW 447
// end ;
109898: LD_VAR 0 2
109902: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
109903: LD_INT 0
109905: PPUSH
109906: PPUSH
109907: PPUSH
// tmp := [ ] ;
109908: LD_ADDR_VAR 0 5
109912: PUSH
109913: EMPTY
109914: ST_TO_ADDR
// for i in units do
109915: LD_ADDR_VAR 0 4
109919: PUSH
109920: LD_VAR 0 1
109924: PUSH
109925: FOR_IN
109926: IFFALSE 109964
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
109928: LD_ADDR_VAR 0 5
109932: PUSH
109933: LD_VAR 0 5
109937: PPUSH
109938: LD_VAR 0 5
109942: PUSH
109943: LD_INT 1
109945: PLUS
109946: PPUSH
109947: LD_VAR 0 4
109951: PPUSH
109952: CALL_OW 256
109956: PPUSH
109957: CALL_OW 2
109961: ST_TO_ADDR
109962: GO 109925
109964: POP
109965: POP
// if not tmp then
109966: LD_VAR 0 5
109970: NOT
109971: IFFALSE 109975
// exit ;
109973: GO 110023
// if asc then
109975: LD_VAR 0 2
109979: IFFALSE 110003
// result := SortListByListAsc ( units , tmp ) else
109981: LD_ADDR_VAR 0 3
109985: PUSH
109986: LD_VAR 0 1
109990: PPUSH
109991: LD_VAR 0 5
109995: PPUSH
109996: CALL_OW 76
110000: ST_TO_ADDR
110001: GO 110023
// result := SortListByListDesc ( units , tmp ) ;
110003: LD_ADDR_VAR 0 3
110007: PUSH
110008: LD_VAR 0 1
110012: PPUSH
110013: LD_VAR 0 5
110017: PPUSH
110018: CALL_OW 77
110022: ST_TO_ADDR
// end ;
110023: LD_VAR 0 3
110027: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
110028: LD_INT 0
110030: PPUSH
110031: PPUSH
// task := GetTaskList ( mech ) ;
110032: LD_ADDR_VAR 0 4
110036: PUSH
110037: LD_VAR 0 1
110041: PPUSH
110042: CALL_OW 437
110046: ST_TO_ADDR
// if not task then
110047: LD_VAR 0 4
110051: NOT
110052: IFFALSE 110056
// exit ;
110054: GO 110098
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
110056: LD_ADDR_VAR 0 3
110060: PUSH
110061: LD_VAR 0 4
110065: PUSH
110066: LD_INT 1
110068: ARRAY
110069: PUSH
110070: LD_INT 1
110072: ARRAY
110073: PUSH
110074: LD_STRING r
110076: EQUAL
110077: PUSH
110078: LD_VAR 0 4
110082: PUSH
110083: LD_INT 1
110085: ARRAY
110086: PUSH
110087: LD_INT 4
110089: ARRAY
110090: PUSH
110091: LD_VAR 0 2
110095: EQUAL
110096: AND
110097: ST_TO_ADDR
// end ;
110098: LD_VAR 0 3
110102: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
110103: LD_INT 0
110105: PPUSH
// SetDir ( unit , d ) ;
110106: LD_VAR 0 1
110110: PPUSH
110111: LD_VAR 0 4
110115: PPUSH
110116: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
110120: LD_VAR 0 1
110124: PPUSH
110125: LD_VAR 0 2
110129: PPUSH
110130: LD_VAR 0 3
110134: PPUSH
110135: LD_VAR 0 5
110139: PPUSH
110140: CALL_OW 48
// end ;
110144: LD_VAR 0 6
110148: RET
// export function ToNaturalNumber ( number ) ; begin
110149: LD_INT 0
110151: PPUSH
// result := number div 1 ;
110152: LD_ADDR_VAR 0 2
110156: PUSH
110157: LD_VAR 0 1
110161: PUSH
110162: LD_INT 1
110164: DIV
110165: ST_TO_ADDR
// if number < 0 then
110166: LD_VAR 0 1
110170: PUSH
110171: LD_INT 0
110173: LESS
110174: IFFALSE 110184
// result := 0 ;
110176: LD_ADDR_VAR 0 2
110180: PUSH
110181: LD_INT 0
110183: ST_TO_ADDR
// end ;
110184: LD_VAR 0 2
110188: RET
// export function SortByClass ( units , class ) ; var un ; begin
110189: LD_INT 0
110191: PPUSH
110192: PPUSH
// if not units or not class then
110193: LD_VAR 0 1
110197: NOT
110198: PUSH
110199: LD_VAR 0 2
110203: NOT
110204: OR
110205: IFFALSE 110209
// exit ;
110207: GO 110304
// result := [ ] ;
110209: LD_ADDR_VAR 0 3
110213: PUSH
110214: EMPTY
110215: ST_TO_ADDR
// for un in units do
110216: LD_ADDR_VAR 0 4
110220: PUSH
110221: LD_VAR 0 1
110225: PUSH
110226: FOR_IN
110227: IFFALSE 110302
// if GetClass ( un ) = class then
110229: LD_VAR 0 4
110233: PPUSH
110234: CALL_OW 257
110238: PUSH
110239: LD_VAR 0 2
110243: EQUAL
110244: IFFALSE 110271
// result := Insert ( result , 1 , un ) else
110246: LD_ADDR_VAR 0 3
110250: PUSH
110251: LD_VAR 0 3
110255: PPUSH
110256: LD_INT 1
110258: PPUSH
110259: LD_VAR 0 4
110263: PPUSH
110264: CALL_OW 2
110268: ST_TO_ADDR
110269: GO 110300
// result := Replace ( result , result + 1 , un ) ;
110271: LD_ADDR_VAR 0 3
110275: PUSH
110276: LD_VAR 0 3
110280: PPUSH
110281: LD_VAR 0 3
110285: PUSH
110286: LD_INT 1
110288: PLUS
110289: PPUSH
110290: LD_VAR 0 4
110294: PPUSH
110295: CALL_OW 1
110299: ST_TO_ADDR
110300: GO 110226
110302: POP
110303: POP
// end ;
110304: LD_VAR 0 3
110308: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
110309: LD_INT 0
110311: PPUSH
110312: PPUSH
110313: PPUSH
110314: PPUSH
110315: PPUSH
110316: PPUSH
110317: PPUSH
// result := [ ] ;
110318: LD_ADDR_VAR 0 4
110322: PUSH
110323: EMPTY
110324: ST_TO_ADDR
// if x - r < 0 then
110325: LD_VAR 0 1
110329: PUSH
110330: LD_VAR 0 3
110334: MINUS
110335: PUSH
110336: LD_INT 0
110338: LESS
110339: IFFALSE 110351
// min_x := 0 else
110341: LD_ADDR_VAR 0 8
110345: PUSH
110346: LD_INT 0
110348: ST_TO_ADDR
110349: GO 110367
// min_x := x - r ;
110351: LD_ADDR_VAR 0 8
110355: PUSH
110356: LD_VAR 0 1
110360: PUSH
110361: LD_VAR 0 3
110365: MINUS
110366: ST_TO_ADDR
// if y - r < 0 then
110367: LD_VAR 0 2
110371: PUSH
110372: LD_VAR 0 3
110376: MINUS
110377: PUSH
110378: LD_INT 0
110380: LESS
110381: IFFALSE 110393
// min_y := 0 else
110383: LD_ADDR_VAR 0 7
110387: PUSH
110388: LD_INT 0
110390: ST_TO_ADDR
110391: GO 110409
// min_y := y - r ;
110393: LD_ADDR_VAR 0 7
110397: PUSH
110398: LD_VAR 0 2
110402: PUSH
110403: LD_VAR 0 3
110407: MINUS
110408: ST_TO_ADDR
// max_x := x + r ;
110409: LD_ADDR_VAR 0 9
110413: PUSH
110414: LD_VAR 0 1
110418: PUSH
110419: LD_VAR 0 3
110423: PLUS
110424: ST_TO_ADDR
// max_y := y + r ;
110425: LD_ADDR_VAR 0 10
110429: PUSH
110430: LD_VAR 0 2
110434: PUSH
110435: LD_VAR 0 3
110439: PLUS
110440: ST_TO_ADDR
// for _x = min_x to max_x do
110441: LD_ADDR_VAR 0 5
110445: PUSH
110446: DOUBLE
110447: LD_VAR 0 8
110451: DEC
110452: ST_TO_ADDR
110453: LD_VAR 0 9
110457: PUSH
110458: FOR_TO
110459: IFFALSE 110560
// for _y = min_y to max_y do
110461: LD_ADDR_VAR 0 6
110465: PUSH
110466: DOUBLE
110467: LD_VAR 0 7
110471: DEC
110472: ST_TO_ADDR
110473: LD_VAR 0 10
110477: PUSH
110478: FOR_TO
110479: IFFALSE 110556
// begin if not ValidHex ( _x , _y ) then
110481: LD_VAR 0 5
110485: PPUSH
110486: LD_VAR 0 6
110490: PPUSH
110491: CALL_OW 488
110495: NOT
110496: IFFALSE 110500
// continue ;
110498: GO 110478
// if GetResourceTypeXY ( _x , _y ) then
110500: LD_VAR 0 5
110504: PPUSH
110505: LD_VAR 0 6
110509: PPUSH
110510: CALL_OW 283
110514: IFFALSE 110554
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
110516: LD_ADDR_VAR 0 4
110520: PUSH
110521: LD_VAR 0 4
110525: PPUSH
110526: LD_VAR 0 4
110530: PUSH
110531: LD_INT 1
110533: PLUS
110534: PPUSH
110535: LD_VAR 0 5
110539: PUSH
110540: LD_VAR 0 6
110544: PUSH
110545: EMPTY
110546: LIST
110547: LIST
110548: PPUSH
110549: CALL_OW 1
110553: ST_TO_ADDR
// end ;
110554: GO 110478
110556: POP
110557: POP
110558: GO 110458
110560: POP
110561: POP
// end ;
110562: LD_VAR 0 4
110566: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
110567: LD_INT 0
110569: PPUSH
110570: PPUSH
110571: PPUSH
110572: PPUSH
110573: PPUSH
110574: PPUSH
110575: PPUSH
110576: PPUSH
// if not units then
110577: LD_VAR 0 1
110581: NOT
110582: IFFALSE 110586
// exit ;
110584: GO 111114
// result := UnitFilter ( units , [ f_ok ] ) ;
110586: LD_ADDR_VAR 0 3
110590: PUSH
110591: LD_VAR 0 1
110595: PPUSH
110596: LD_INT 50
110598: PUSH
110599: EMPTY
110600: LIST
110601: PPUSH
110602: CALL_OW 72
110606: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
110607: LD_ADDR_VAR 0 8
110611: PUSH
110612: LD_VAR 0 1
110616: PUSH
110617: LD_INT 1
110619: ARRAY
110620: PPUSH
110621: CALL_OW 255
110625: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
110626: LD_ADDR_VAR 0 10
110630: PUSH
110631: LD_INT 29
110633: PUSH
110634: LD_INT 91
110636: PUSH
110637: LD_INT 49
110639: PUSH
110640: EMPTY
110641: LIST
110642: LIST
110643: LIST
110644: ST_TO_ADDR
// if not result then
110645: LD_VAR 0 3
110649: NOT
110650: IFFALSE 110654
// exit ;
110652: GO 111114
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
110654: LD_ADDR_VAR 0 5
110658: PUSH
110659: LD_INT 81
110661: PUSH
110662: LD_VAR 0 8
110666: PUSH
110667: EMPTY
110668: LIST
110669: LIST
110670: PPUSH
110671: CALL_OW 69
110675: ST_TO_ADDR
// for i in result do
110676: LD_ADDR_VAR 0 4
110680: PUSH
110681: LD_VAR 0 3
110685: PUSH
110686: FOR_IN
110687: IFFALSE 111112
// begin tag := GetTag ( i ) + 1 ;
110689: LD_ADDR_VAR 0 9
110693: PUSH
110694: LD_VAR 0 4
110698: PPUSH
110699: CALL_OW 110
110703: PUSH
110704: LD_INT 1
110706: PLUS
110707: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
110708: LD_ADDR_VAR 0 7
110712: PUSH
110713: LD_VAR 0 4
110717: PPUSH
110718: CALL_OW 250
110722: PPUSH
110723: LD_VAR 0 4
110727: PPUSH
110728: CALL_OW 251
110732: PPUSH
110733: LD_INT 4
110735: PPUSH
110736: CALL 110309 0 3
110740: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
110741: LD_VAR 0 4
110745: PPUSH
110746: CALL_OW 247
110750: PUSH
110751: LD_INT 2
110753: EQUAL
110754: PUSH
110755: LD_VAR 0 7
110759: PUSH
110760: LD_INT 2
110762: GREATER
110763: AND
110764: PUSH
110765: LD_VAR 0 4
110769: PPUSH
110770: CALL_OW 264
110774: PUSH
110775: LD_VAR 0 10
110779: IN
110780: NOT
110781: AND
110782: IFFALSE 110821
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
110784: LD_VAR 0 4
110788: PPUSH
110789: LD_VAR 0 7
110793: PUSH
110794: LD_INT 1
110796: ARRAY
110797: PUSH
110798: LD_INT 1
110800: ARRAY
110801: PPUSH
110802: LD_VAR 0 7
110806: PUSH
110807: LD_INT 1
110809: ARRAY
110810: PUSH
110811: LD_INT 2
110813: ARRAY
110814: PPUSH
110815: CALL_OW 116
110819: GO 111110
// if path > tag then
110821: LD_VAR 0 2
110825: PUSH
110826: LD_VAR 0 9
110830: GREATER
110831: IFFALSE 111039
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
110833: LD_ADDR_VAR 0 6
110837: PUSH
110838: LD_VAR 0 5
110842: PPUSH
110843: LD_INT 91
110845: PUSH
110846: LD_VAR 0 4
110850: PUSH
110851: LD_INT 8
110853: PUSH
110854: EMPTY
110855: LIST
110856: LIST
110857: LIST
110858: PPUSH
110859: CALL_OW 72
110863: ST_TO_ADDR
// if nearEnemy then
110864: LD_VAR 0 6
110868: IFFALSE 110937
// begin if GetWeapon ( i ) = ru_time_lapser then
110870: LD_VAR 0 4
110874: PPUSH
110875: CALL_OW 264
110879: PUSH
110880: LD_INT 49
110882: EQUAL
110883: IFFALSE 110911
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
110885: LD_VAR 0 4
110889: PPUSH
110890: LD_VAR 0 6
110894: PPUSH
110895: LD_VAR 0 4
110899: PPUSH
110900: CALL_OW 74
110904: PPUSH
110905: CALL_OW 112
110909: GO 110935
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
110911: LD_VAR 0 4
110915: PPUSH
110916: LD_VAR 0 6
110920: PPUSH
110921: LD_VAR 0 4
110925: PPUSH
110926: CALL_OW 74
110930: PPUSH
110931: CALL 112185 0 2
// end else
110935: GO 111037
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
110937: LD_VAR 0 4
110941: PPUSH
110942: LD_VAR 0 2
110946: PUSH
110947: LD_VAR 0 9
110951: ARRAY
110952: PUSH
110953: LD_INT 1
110955: ARRAY
110956: PPUSH
110957: LD_VAR 0 2
110961: PUSH
110962: LD_VAR 0 9
110966: ARRAY
110967: PUSH
110968: LD_INT 2
110970: ARRAY
110971: PPUSH
110972: CALL_OW 297
110976: PUSH
110977: LD_INT 6
110979: GREATER
110980: IFFALSE 111023
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
110982: LD_VAR 0 4
110986: PPUSH
110987: LD_VAR 0 2
110991: PUSH
110992: LD_VAR 0 9
110996: ARRAY
110997: PUSH
110998: LD_INT 1
111000: ARRAY
111001: PPUSH
111002: LD_VAR 0 2
111006: PUSH
111007: LD_VAR 0 9
111011: ARRAY
111012: PUSH
111013: LD_INT 2
111015: ARRAY
111016: PPUSH
111017: CALL_OW 114
111021: GO 111037
// SetTag ( i , tag ) ;
111023: LD_VAR 0 4
111027: PPUSH
111028: LD_VAR 0 9
111032: PPUSH
111033: CALL_OW 109
// end else
111037: GO 111110
// if enemy then
111039: LD_VAR 0 5
111043: IFFALSE 111110
// begin if GetWeapon ( i ) = ru_time_lapser then
111045: LD_VAR 0 4
111049: PPUSH
111050: CALL_OW 264
111054: PUSH
111055: LD_INT 49
111057: EQUAL
111058: IFFALSE 111086
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
111060: LD_VAR 0 4
111064: PPUSH
111065: LD_VAR 0 5
111069: PPUSH
111070: LD_VAR 0 4
111074: PPUSH
111075: CALL_OW 74
111079: PPUSH
111080: CALL_OW 112
111084: GO 111110
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
111086: LD_VAR 0 4
111090: PPUSH
111091: LD_VAR 0 5
111095: PPUSH
111096: LD_VAR 0 4
111100: PPUSH
111101: CALL_OW 74
111105: PPUSH
111106: CALL 112185 0 2
// end ; end ;
111110: GO 110686
111112: POP
111113: POP
// end ;
111114: LD_VAR 0 3
111118: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
111119: LD_INT 0
111121: PPUSH
111122: PPUSH
111123: PPUSH
// if not unit or IsInUnit ( unit ) then
111124: LD_VAR 0 1
111128: NOT
111129: PUSH
111130: LD_VAR 0 1
111134: PPUSH
111135: CALL_OW 310
111139: OR
111140: IFFALSE 111144
// exit ;
111142: GO 111235
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
111144: LD_ADDR_VAR 0 4
111148: PUSH
111149: LD_VAR 0 1
111153: PPUSH
111154: CALL_OW 250
111158: PPUSH
111159: LD_VAR 0 2
111163: PPUSH
111164: LD_INT 1
111166: PPUSH
111167: CALL_OW 272
111171: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
111172: LD_ADDR_VAR 0 5
111176: PUSH
111177: LD_VAR 0 1
111181: PPUSH
111182: CALL_OW 251
111186: PPUSH
111187: LD_VAR 0 2
111191: PPUSH
111192: LD_INT 1
111194: PPUSH
111195: CALL_OW 273
111199: ST_TO_ADDR
// if ValidHex ( x , y ) then
111200: LD_VAR 0 4
111204: PPUSH
111205: LD_VAR 0 5
111209: PPUSH
111210: CALL_OW 488
111214: IFFALSE 111235
// ComTurnXY ( unit , x , y ) ;
111216: LD_VAR 0 1
111220: PPUSH
111221: LD_VAR 0 4
111225: PPUSH
111226: LD_VAR 0 5
111230: PPUSH
111231: CALL_OW 118
// end ;
111235: LD_VAR 0 3
111239: RET
// export function SeeUnits ( side , units ) ; var i ; begin
111240: LD_INT 0
111242: PPUSH
111243: PPUSH
// result := false ;
111244: LD_ADDR_VAR 0 3
111248: PUSH
111249: LD_INT 0
111251: ST_TO_ADDR
// if not units then
111252: LD_VAR 0 2
111256: NOT
111257: IFFALSE 111261
// exit ;
111259: GO 111306
// for i in units do
111261: LD_ADDR_VAR 0 4
111265: PUSH
111266: LD_VAR 0 2
111270: PUSH
111271: FOR_IN
111272: IFFALSE 111304
// if See ( side , i ) then
111274: LD_VAR 0 1
111278: PPUSH
111279: LD_VAR 0 4
111283: PPUSH
111284: CALL_OW 292
111288: IFFALSE 111302
// begin result := true ;
111290: LD_ADDR_VAR 0 3
111294: PUSH
111295: LD_INT 1
111297: ST_TO_ADDR
// exit ;
111298: POP
111299: POP
111300: GO 111306
// end ;
111302: GO 111271
111304: POP
111305: POP
// end ;
111306: LD_VAR 0 3
111310: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
111311: LD_INT 0
111313: PPUSH
111314: PPUSH
111315: PPUSH
111316: PPUSH
// if not unit or not points then
111317: LD_VAR 0 1
111321: NOT
111322: PUSH
111323: LD_VAR 0 2
111327: NOT
111328: OR
111329: IFFALSE 111333
// exit ;
111331: GO 111423
// dist := 99999 ;
111333: LD_ADDR_VAR 0 5
111337: PUSH
111338: LD_INT 99999
111340: ST_TO_ADDR
// for i in points do
111341: LD_ADDR_VAR 0 4
111345: PUSH
111346: LD_VAR 0 2
111350: PUSH
111351: FOR_IN
111352: IFFALSE 111421
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
111354: LD_ADDR_VAR 0 6
111358: PUSH
111359: LD_VAR 0 1
111363: PPUSH
111364: LD_VAR 0 4
111368: PUSH
111369: LD_INT 1
111371: ARRAY
111372: PPUSH
111373: LD_VAR 0 4
111377: PUSH
111378: LD_INT 2
111380: ARRAY
111381: PPUSH
111382: CALL_OW 297
111386: ST_TO_ADDR
// if tmpDist < dist then
111387: LD_VAR 0 6
111391: PUSH
111392: LD_VAR 0 5
111396: LESS
111397: IFFALSE 111419
// begin result := i ;
111399: LD_ADDR_VAR 0 3
111403: PUSH
111404: LD_VAR 0 4
111408: ST_TO_ADDR
// dist := tmpDist ;
111409: LD_ADDR_VAR 0 5
111413: PUSH
111414: LD_VAR 0 6
111418: ST_TO_ADDR
// end ; end ;
111419: GO 111351
111421: POP
111422: POP
// end ;
111423: LD_VAR 0 3
111427: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
111428: LD_INT 0
111430: PPUSH
// uc_side := side ;
111431: LD_ADDR_OWVAR 20
111435: PUSH
111436: LD_VAR 0 1
111440: ST_TO_ADDR
// uc_nation := 3 ;
111441: LD_ADDR_OWVAR 21
111445: PUSH
111446: LD_INT 3
111448: ST_TO_ADDR
// vc_chassis := 25 ;
111449: LD_ADDR_OWVAR 37
111453: PUSH
111454: LD_INT 25
111456: ST_TO_ADDR
// vc_engine := engine_siberite ;
111457: LD_ADDR_OWVAR 39
111461: PUSH
111462: LD_INT 3
111464: ST_TO_ADDR
// vc_control := control_computer ;
111465: LD_ADDR_OWVAR 38
111469: PUSH
111470: LD_INT 3
111472: ST_TO_ADDR
// vc_weapon := 59 ;
111473: LD_ADDR_OWVAR 40
111477: PUSH
111478: LD_INT 59
111480: ST_TO_ADDR
// result := CreateVehicle ;
111481: LD_ADDR_VAR 0 5
111485: PUSH
111486: CALL_OW 45
111490: ST_TO_ADDR
// SetDir ( result , d ) ;
111491: LD_VAR 0 5
111495: PPUSH
111496: LD_VAR 0 4
111500: PPUSH
111501: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
111505: LD_VAR 0 5
111509: PPUSH
111510: LD_VAR 0 2
111514: PPUSH
111515: LD_VAR 0 3
111519: PPUSH
111520: LD_INT 0
111522: PPUSH
111523: CALL_OW 48
// end ;
111527: LD_VAR 0 5
111531: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
111532: LD_INT 0
111534: PPUSH
111535: PPUSH
111536: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
111537: LD_ADDR_VAR 0 2
111541: PUSH
111542: LD_INT 0
111544: PUSH
111545: LD_INT 0
111547: PUSH
111548: LD_INT 0
111550: PUSH
111551: LD_INT 0
111553: PUSH
111554: EMPTY
111555: LIST
111556: LIST
111557: LIST
111558: LIST
111559: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
111560: LD_VAR 0 1
111564: NOT
111565: PUSH
111566: LD_VAR 0 1
111570: PPUSH
111571: CALL_OW 264
111575: PUSH
111576: LD_INT 12
111578: PUSH
111579: LD_INT 51
111581: PUSH
111582: LD_INT 32
111584: PUSH
111585: LD_INT 89
111587: PUSH
111588: EMPTY
111589: LIST
111590: LIST
111591: LIST
111592: LIST
111593: IN
111594: NOT
111595: OR
111596: IFFALSE 111600
// exit ;
111598: GO 111698
// for i := 1 to 3 do
111600: LD_ADDR_VAR 0 3
111604: PUSH
111605: DOUBLE
111606: LD_INT 1
111608: DEC
111609: ST_TO_ADDR
111610: LD_INT 3
111612: PUSH
111613: FOR_TO
111614: IFFALSE 111696
// begin tmp := GetCargo ( cargo , i ) ;
111616: LD_ADDR_VAR 0 4
111620: PUSH
111621: LD_VAR 0 1
111625: PPUSH
111626: LD_VAR 0 3
111630: PPUSH
111631: CALL_OW 289
111635: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
111636: LD_ADDR_VAR 0 2
111640: PUSH
111641: LD_VAR 0 2
111645: PPUSH
111646: LD_VAR 0 3
111650: PPUSH
111651: LD_VAR 0 4
111655: PPUSH
111656: CALL_OW 1
111660: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
111661: LD_ADDR_VAR 0 2
111665: PUSH
111666: LD_VAR 0 2
111670: PPUSH
111671: LD_INT 4
111673: PPUSH
111674: LD_VAR 0 2
111678: PUSH
111679: LD_INT 4
111681: ARRAY
111682: PUSH
111683: LD_VAR 0 4
111687: PLUS
111688: PPUSH
111689: CALL_OW 1
111693: ST_TO_ADDR
// end ;
111694: GO 111613
111696: POP
111697: POP
// end ;
111698: LD_VAR 0 2
111702: RET
// export function Length ( array ) ; begin
111703: LD_INT 0
111705: PPUSH
// result := array + 0 ;
111706: LD_ADDR_VAR 0 2
111710: PUSH
111711: LD_VAR 0 1
111715: PUSH
111716: LD_INT 0
111718: PLUS
111719: ST_TO_ADDR
// end ;
111720: LD_VAR 0 2
111724: RET
// export function PrepareArray ( array ) ; begin
111725: LD_INT 0
111727: PPUSH
// result := array diff 0 ;
111728: LD_ADDR_VAR 0 2
111732: PUSH
111733: LD_VAR 0 1
111737: PUSH
111738: LD_INT 0
111740: DIFF
111741: ST_TO_ADDR
// if not result [ 1 ] then
111742: LD_VAR 0 2
111746: PUSH
111747: LD_INT 1
111749: ARRAY
111750: NOT
111751: IFFALSE 111771
// result := Delete ( result , 1 ) ;
111753: LD_ADDR_VAR 0 2
111757: PUSH
111758: LD_VAR 0 2
111762: PPUSH
111763: LD_INT 1
111765: PPUSH
111766: CALL_OW 3
111770: ST_TO_ADDR
// end ;
111771: LD_VAR 0 2
111775: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
111776: LD_INT 0
111778: PPUSH
111779: PPUSH
111780: PPUSH
111781: PPUSH
// sibRocketRange := 25 ;
111782: LD_ADDR_VAR 0 6
111786: PUSH
111787: LD_INT 25
111789: ST_TO_ADDR
// result := false ;
111790: LD_ADDR_VAR 0 4
111794: PUSH
111795: LD_INT 0
111797: ST_TO_ADDR
// for i := 0 to 5 do
111798: LD_ADDR_VAR 0 5
111802: PUSH
111803: DOUBLE
111804: LD_INT 0
111806: DEC
111807: ST_TO_ADDR
111808: LD_INT 5
111810: PUSH
111811: FOR_TO
111812: IFFALSE 111879
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
111814: LD_VAR 0 1
111818: PPUSH
111819: LD_VAR 0 5
111823: PPUSH
111824: LD_VAR 0 6
111828: PPUSH
111829: CALL_OW 272
111833: PPUSH
111834: LD_VAR 0 2
111838: PPUSH
111839: LD_VAR 0 5
111843: PPUSH
111844: LD_VAR 0 6
111848: PPUSH
111849: CALL_OW 273
111853: PPUSH
111854: LD_VAR 0 3
111858: PPUSH
111859: CALL_OW 309
111863: IFFALSE 111877
// begin result := true ;
111865: LD_ADDR_VAR 0 4
111869: PUSH
111870: LD_INT 1
111872: ST_TO_ADDR
// exit ;
111873: POP
111874: POP
111875: GO 111881
// end ;
111877: GO 111811
111879: POP
111880: POP
// end ;
111881: LD_VAR 0 4
111885: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
111886: LD_INT 0
111888: PPUSH
111889: PPUSH
111890: PPUSH
// if btype = b_depot then
111891: LD_VAR 0 2
111895: PUSH
111896: LD_INT 0
111898: EQUAL
111899: IFFALSE 111911
// begin result := true ;
111901: LD_ADDR_VAR 0 3
111905: PUSH
111906: LD_INT 1
111908: ST_TO_ADDR
// exit ;
111909: GO 112027
// end ; pom := GetBase ( depot ) ;
111911: LD_ADDR_VAR 0 4
111915: PUSH
111916: LD_VAR 0 1
111920: PPUSH
111921: CALL_OW 274
111925: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
111926: LD_ADDR_VAR 0 5
111930: PUSH
111931: LD_VAR 0 2
111935: PPUSH
111936: LD_VAR 0 1
111940: PPUSH
111941: CALL_OW 248
111945: PPUSH
111946: CALL_OW 450
111950: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
111951: LD_ADDR_VAR 0 3
111955: PUSH
111956: LD_VAR 0 4
111960: PPUSH
111961: LD_INT 1
111963: PPUSH
111964: CALL_OW 275
111968: PUSH
111969: LD_VAR 0 5
111973: PUSH
111974: LD_INT 1
111976: ARRAY
111977: GREATEREQUAL
111978: PUSH
111979: LD_VAR 0 4
111983: PPUSH
111984: LD_INT 2
111986: PPUSH
111987: CALL_OW 275
111991: PUSH
111992: LD_VAR 0 5
111996: PUSH
111997: LD_INT 2
111999: ARRAY
112000: GREATEREQUAL
112001: AND
112002: PUSH
112003: LD_VAR 0 4
112007: PPUSH
112008: LD_INT 3
112010: PPUSH
112011: CALL_OW 275
112015: PUSH
112016: LD_VAR 0 5
112020: PUSH
112021: LD_INT 3
112023: ARRAY
112024: GREATEREQUAL
112025: AND
112026: ST_TO_ADDR
// end ;
112027: LD_VAR 0 3
112031: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
112032: LD_INT 0
112034: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
112035: LD_VAR 0 1
112039: PPUSH
112040: LD_VAR 0 2
112044: PPUSH
112045: LD_INT 0
112047: PPUSH
112048: LD_INT 0
112050: PPUSH
112051: LD_INT 1
112053: PPUSH
112054: LD_INT 0
112056: PPUSH
112057: CALL_OW 587
// end ;
112061: LD_VAR 0 3
112065: RET
// export function CenterOnNow ( unit ) ; begin
112066: LD_INT 0
112068: PPUSH
// result := IsInUnit ( unit ) ;
112069: LD_ADDR_VAR 0 2
112073: PUSH
112074: LD_VAR 0 1
112078: PPUSH
112079: CALL_OW 310
112083: ST_TO_ADDR
// if not result then
112084: LD_VAR 0 2
112088: NOT
112089: IFFALSE 112101
// result := unit ;
112091: LD_ADDR_VAR 0 2
112095: PUSH
112096: LD_VAR 0 1
112100: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
112101: LD_VAR 0 1
112105: PPUSH
112106: CALL_OW 87
// end ;
112110: LD_VAR 0 2
112114: RET
// export function ComMoveHex ( unit , hex ) ; begin
112115: LD_INT 0
112117: PPUSH
// if not hex then
112118: LD_VAR 0 2
112122: NOT
112123: IFFALSE 112127
// exit ;
112125: GO 112180
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
112127: LD_VAR 0 2
112131: PUSH
112132: LD_INT 1
112134: ARRAY
112135: PPUSH
112136: LD_VAR 0 2
112140: PUSH
112141: LD_INT 2
112143: ARRAY
112144: PPUSH
112145: CALL_OW 428
112149: IFFALSE 112153
// exit ;
112151: GO 112180
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
112153: LD_VAR 0 1
112157: PPUSH
112158: LD_VAR 0 2
112162: PUSH
112163: LD_INT 1
112165: ARRAY
112166: PPUSH
112167: LD_VAR 0 2
112171: PUSH
112172: LD_INT 2
112174: ARRAY
112175: PPUSH
112176: CALL_OW 111
// end ;
112180: LD_VAR 0 3
112184: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
112185: LD_INT 0
112187: PPUSH
112188: PPUSH
112189: PPUSH
// if not unit or not enemy then
112190: LD_VAR 0 1
112194: NOT
112195: PUSH
112196: LD_VAR 0 2
112200: NOT
112201: OR
112202: IFFALSE 112206
// exit ;
112204: GO 112330
// x := GetX ( enemy ) ;
112206: LD_ADDR_VAR 0 4
112210: PUSH
112211: LD_VAR 0 2
112215: PPUSH
112216: CALL_OW 250
112220: ST_TO_ADDR
// y := GetY ( enemy ) ;
112221: LD_ADDR_VAR 0 5
112225: PUSH
112226: LD_VAR 0 2
112230: PPUSH
112231: CALL_OW 251
112235: ST_TO_ADDR
// if ValidHex ( x , y ) then
112236: LD_VAR 0 4
112240: PPUSH
112241: LD_VAR 0 5
112245: PPUSH
112246: CALL_OW 488
112250: IFFALSE 112330
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
112252: LD_VAR 0 2
112256: PPUSH
112257: CALL_OW 247
112261: PUSH
112262: LD_INT 3
112264: PUSH
112265: LD_INT 2
112267: PUSH
112268: EMPTY
112269: LIST
112270: LIST
112271: IN
112272: PUSH
112273: LD_VAR 0 1
112277: PPUSH
112278: CALL_OW 255
112282: PPUSH
112283: LD_VAR 0 2
112287: PPUSH
112288: CALL_OW 292
112292: OR
112293: IFFALSE 112311
// ComAttackUnit ( unit , enemy ) else
112295: LD_VAR 0 1
112299: PPUSH
112300: LD_VAR 0 2
112304: PPUSH
112305: CALL_OW 115
112309: GO 112330
// ComAgressiveMove ( unit , x , y ) ;
112311: LD_VAR 0 1
112315: PPUSH
112316: LD_VAR 0 4
112320: PPUSH
112321: LD_VAR 0 5
112325: PPUSH
112326: CALL_OW 114
// end ;
112330: LD_VAR 0 3
112334: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
112335: LD_INT 0
112337: PPUSH
112338: PPUSH
112339: PPUSH
// list := AreaToList ( area , 0 ) ;
112340: LD_ADDR_VAR 0 5
112344: PUSH
112345: LD_VAR 0 1
112349: PPUSH
112350: LD_INT 0
112352: PPUSH
112353: CALL_OW 517
112357: ST_TO_ADDR
// if not list then
112358: LD_VAR 0 5
112362: NOT
112363: IFFALSE 112367
// exit ;
112365: GO 112497
// if all then
112367: LD_VAR 0 2
112371: IFFALSE 112459
// begin for i := 1 to list [ 1 ] do
112373: LD_ADDR_VAR 0 4
112377: PUSH
112378: DOUBLE
112379: LD_INT 1
112381: DEC
112382: ST_TO_ADDR
112383: LD_VAR 0 5
112387: PUSH
112388: LD_INT 1
112390: ARRAY
112391: PUSH
112392: FOR_TO
112393: IFFALSE 112455
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
112395: LD_ADDR_VAR 0 3
112399: PUSH
112400: LD_VAR 0 3
112404: PPUSH
112405: LD_VAR 0 3
112409: PUSH
112410: LD_INT 1
112412: PLUS
112413: PPUSH
112414: LD_VAR 0 5
112418: PUSH
112419: LD_INT 1
112421: ARRAY
112422: PUSH
112423: LD_VAR 0 4
112427: ARRAY
112428: PUSH
112429: LD_VAR 0 5
112433: PUSH
112434: LD_INT 2
112436: ARRAY
112437: PUSH
112438: LD_VAR 0 4
112442: ARRAY
112443: PUSH
112444: EMPTY
112445: LIST
112446: LIST
112447: PPUSH
112448: CALL_OW 1
112452: ST_TO_ADDR
112453: GO 112392
112455: POP
112456: POP
// exit ;
112457: GO 112497
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
112459: LD_ADDR_VAR 0 3
112463: PUSH
112464: LD_VAR 0 5
112468: PUSH
112469: LD_INT 1
112471: ARRAY
112472: PUSH
112473: LD_INT 1
112475: ARRAY
112476: PUSH
112477: LD_VAR 0 5
112481: PUSH
112482: LD_INT 2
112484: ARRAY
112485: PUSH
112486: LD_INT 1
112488: ARRAY
112489: PUSH
112490: EMPTY
112491: LIST
112492: LIST
112493: PUSH
112494: EMPTY
112495: LIST
112496: ST_TO_ADDR
// end ;
112497: LD_VAR 0 3
112501: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
112502: LD_INT 0
112504: PPUSH
112505: PPUSH
// list := AreaToList ( area , 0 ) ;
112506: LD_ADDR_VAR 0 4
112510: PUSH
112511: LD_VAR 0 1
112515: PPUSH
112516: LD_INT 0
112518: PPUSH
112519: CALL_OW 517
112523: ST_TO_ADDR
// if not list then
112524: LD_VAR 0 4
112528: NOT
112529: IFFALSE 112533
// exit ;
112531: GO 112574
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
112533: LD_ADDR_VAR 0 3
112537: PUSH
112538: LD_VAR 0 4
112542: PUSH
112543: LD_INT 1
112545: ARRAY
112546: PUSH
112547: LD_INT 1
112549: ARRAY
112550: PUSH
112551: LD_VAR 0 4
112555: PUSH
112556: LD_INT 2
112558: ARRAY
112559: PUSH
112560: LD_INT 1
112562: ARRAY
112563: PUSH
112564: LD_VAR 0 2
112568: PUSH
112569: EMPTY
112570: LIST
112571: LIST
112572: LIST
112573: ST_TO_ADDR
// end ;
112574: LD_VAR 0 3
112578: RET
// export function First ( array ) ; begin
112579: LD_INT 0
112581: PPUSH
// if not array then
112582: LD_VAR 0 1
112586: NOT
112587: IFFALSE 112591
// exit ;
112589: GO 112605
// result := array [ 1 ] ;
112591: LD_ADDR_VAR 0 2
112595: PUSH
112596: LD_VAR 0 1
112600: PUSH
112601: LD_INT 1
112603: ARRAY
112604: ST_TO_ADDR
// end ;
112605: LD_VAR 0 2
112609: RET
// export function Last ( array ) ; begin
112610: LD_INT 0
112612: PPUSH
// if not array then
112613: LD_VAR 0 1
112617: NOT
112618: IFFALSE 112622
// exit ;
112620: GO 112638
// result := array [ array ] ;
112622: LD_ADDR_VAR 0 2
112626: PUSH
112627: LD_VAR 0 1
112631: PUSH
112632: LD_VAR 0 1
112636: ARRAY
112637: ST_TO_ADDR
// end ;
112638: LD_VAR 0 2
112642: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
112643: LD_INT 0
112645: PPUSH
112646: PPUSH
// result := [ ] ;
112647: LD_ADDR_VAR 0 5
112651: PUSH
112652: EMPTY
112653: ST_TO_ADDR
// if not array then
112654: LD_VAR 0 1
112658: NOT
112659: IFFALSE 112663
// exit ;
112661: GO 112775
// for i := 1 to array do
112663: LD_ADDR_VAR 0 6
112667: PUSH
112668: DOUBLE
112669: LD_INT 1
112671: DEC
112672: ST_TO_ADDR
112673: LD_VAR 0 1
112677: PUSH
112678: FOR_TO
112679: IFFALSE 112773
// if array [ i ] [ index ] = value then
112681: LD_VAR 0 1
112685: PUSH
112686: LD_VAR 0 6
112690: ARRAY
112691: PUSH
112692: LD_VAR 0 2
112696: ARRAY
112697: PUSH
112698: LD_VAR 0 3
112702: EQUAL
112703: IFFALSE 112771
// begin if indexColumn then
112705: LD_VAR 0 4
112709: IFFALSE 112745
// result := Join ( result , array [ i ] [ indexColumn ] ) else
112711: LD_ADDR_VAR 0 5
112715: PUSH
112716: LD_VAR 0 5
112720: PPUSH
112721: LD_VAR 0 1
112725: PUSH
112726: LD_VAR 0 6
112730: ARRAY
112731: PUSH
112732: LD_VAR 0 4
112736: ARRAY
112737: PPUSH
112738: CALL 107963 0 2
112742: ST_TO_ADDR
112743: GO 112771
// result := Join ( result , array [ i ] ) ;
112745: LD_ADDR_VAR 0 5
112749: PUSH
112750: LD_VAR 0 5
112754: PPUSH
112755: LD_VAR 0 1
112759: PUSH
112760: LD_VAR 0 6
112764: ARRAY
112765: PPUSH
112766: CALL 107963 0 2
112770: ST_TO_ADDR
// end ;
112771: GO 112678
112773: POP
112774: POP
// end ;
112775: LD_VAR 0 5
112779: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
112780: LD_INT 0
112782: PPUSH
// if not vehicles or not parkingPoint then
112783: LD_VAR 0 1
112787: NOT
112788: PUSH
112789: LD_VAR 0 2
112793: NOT
112794: OR
112795: IFFALSE 112799
// exit ;
112797: GO 112897
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
112799: LD_ADDR_VAR 0 1
112803: PUSH
112804: LD_VAR 0 1
112808: PPUSH
112809: LD_INT 50
112811: PUSH
112812: EMPTY
112813: LIST
112814: PUSH
112815: LD_INT 3
112817: PUSH
112818: LD_INT 92
112820: PUSH
112821: LD_VAR 0 2
112825: PUSH
112826: LD_INT 1
112828: ARRAY
112829: PUSH
112830: LD_VAR 0 2
112834: PUSH
112835: LD_INT 2
112837: ARRAY
112838: PUSH
112839: LD_INT 8
112841: PUSH
112842: EMPTY
112843: LIST
112844: LIST
112845: LIST
112846: LIST
112847: PUSH
112848: EMPTY
112849: LIST
112850: LIST
112851: PUSH
112852: EMPTY
112853: LIST
112854: LIST
112855: PPUSH
112856: CALL_OW 72
112860: ST_TO_ADDR
// if not vehicles then
112861: LD_VAR 0 1
112865: NOT
112866: IFFALSE 112870
// exit ;
112868: GO 112897
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
112870: LD_VAR 0 1
112874: PPUSH
112875: LD_VAR 0 2
112879: PUSH
112880: LD_INT 1
112882: ARRAY
112883: PPUSH
112884: LD_VAR 0 2
112888: PUSH
112889: LD_INT 2
112891: ARRAY
112892: PPUSH
112893: CALL_OW 111
// end ;
112897: LD_VAR 0 3
112901: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
112902: LD_INT 0
112904: PPUSH
112905: PPUSH
112906: PPUSH
// if not side or not area then
112907: LD_VAR 0 1
112911: NOT
112912: PUSH
112913: LD_VAR 0 2
112917: NOT
112918: OR
112919: IFFALSE 112923
// exit ;
112921: GO 113042
// tmp := AreaToList ( area , 0 ) ;
112923: LD_ADDR_VAR 0 5
112927: PUSH
112928: LD_VAR 0 2
112932: PPUSH
112933: LD_INT 0
112935: PPUSH
112936: CALL_OW 517
112940: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
112941: LD_ADDR_VAR 0 4
112945: PUSH
112946: DOUBLE
112947: LD_INT 1
112949: DEC
112950: ST_TO_ADDR
112951: LD_VAR 0 5
112955: PUSH
112956: LD_INT 1
112958: ARRAY
112959: PUSH
112960: FOR_TO
112961: IFFALSE 113040
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
112963: LD_VAR 0 5
112967: PUSH
112968: LD_INT 1
112970: ARRAY
112971: PUSH
112972: LD_VAR 0 4
112976: ARRAY
112977: PPUSH
112978: LD_VAR 0 5
112982: PUSH
112983: LD_INT 2
112985: ARRAY
112986: PUSH
112987: LD_VAR 0 4
112991: ARRAY
112992: PPUSH
112993: CALL_OW 351
112997: IFFALSE 113038
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
112999: LD_VAR 0 5
113003: PUSH
113004: LD_INT 1
113006: ARRAY
113007: PUSH
113008: LD_VAR 0 4
113012: ARRAY
113013: PPUSH
113014: LD_VAR 0 5
113018: PUSH
113019: LD_INT 2
113021: ARRAY
113022: PUSH
113023: LD_VAR 0 4
113027: ARRAY
113028: PPUSH
113029: LD_VAR 0 1
113033: PPUSH
113034: CALL_OW 244
// end ;
113038: GO 112960
113040: POP
113041: POP
// end ; end_of_file end_of_file
113042: LD_VAR 0 3
113046: RET
// export globalGameSaveCounter ; every 0 0$1 do
113047: GO 113049
113049: DISABLE
// begin enable ;
113050: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
113051: LD_STRING updateTimer(
113053: PUSH
113054: LD_OWVAR 1
113058: STR
113059: PUSH
113060: LD_STRING );
113062: STR
113063: PPUSH
113064: CALL_OW 559
// end ;
113068: END
// every 0 0$1 do
113069: GO 113071
113071: DISABLE
// begin globalGameSaveCounter := 0 ;
113072: LD_ADDR_EXP 147
113076: PUSH
113077: LD_INT 0
113079: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
113080: LD_STRING setGameSaveCounter(0)
113082: PPUSH
113083: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
113087: LD_STRING initStreamRollete();
113089: PPUSH
113090: CALL_OW 559
// InitStreamMode ;
113094: CALL 114437 0 0
// DefineStreamItems ( false ) ;
113098: LD_INT 0
113100: PPUSH
113101: CALL 114901 0 1
// end ;
113105: END
// export function SOS_MapStart ( ) ; begin
113106: LD_INT 0
113108: PPUSH
// if streamModeActive then
113109: LD_EXP 148
113113: IFFALSE 113122
// DefineStreamItems ( true ) ;
113115: LD_INT 1
113117: PPUSH
113118: CALL 114901 0 1
// UpdateLuaVariables ( ) ;
113122: CALL 113139 0 0
// UpdateFactoryWaypoints ( ) ;
113126: CALL 127770 0 0
// UpdateWarehouseGatheringPoints ( ) ;
113130: CALL 128027 0 0
// end ;
113134: LD_VAR 0 1
113138: RET
// function UpdateLuaVariables ( ) ; begin
113139: LD_INT 0
113141: PPUSH
// if globalGameSaveCounter then
113142: LD_EXP 147
113146: IFFALSE 113180
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
113148: LD_ADDR_EXP 147
113152: PUSH
113153: LD_EXP 147
113157: PPUSH
113158: CALL 109324 0 1
113162: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
113163: LD_STRING setGameSaveCounter(
113165: PUSH
113166: LD_EXP 147
113170: STR
113171: PUSH
113172: LD_STRING )
113174: STR
113175: PPUSH
113176: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
113180: LD_STRING setGameDifficulty(
113182: PUSH
113183: LD_OWVAR 67
113187: STR
113188: PUSH
113189: LD_STRING )
113191: STR
113192: PPUSH
113193: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
113197: LD_STRING displayDifficulty(
113199: PUSH
113200: LD_OWVAR 67
113204: STR
113205: PUSH
113206: LD_STRING )
113208: STR
113209: PPUSH
113210: CALL_OW 559
// end ;
113214: LD_VAR 0 1
113218: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
113219: LD_INT 0
113221: PPUSH
// if p2 = stream_mode then
113222: LD_VAR 0 2
113226: PUSH
113227: LD_INT 100
113229: EQUAL
113230: IFFALSE 114233
// begin if not StreamModeActive then
113232: LD_EXP 148
113236: NOT
113237: IFFALSE 113247
// StreamModeActive := true ;
113239: LD_ADDR_EXP 148
113243: PUSH
113244: LD_INT 1
113246: ST_TO_ADDR
// if p3 = 0 then
113247: LD_VAR 0 3
113251: PUSH
113252: LD_INT 0
113254: EQUAL
113255: IFFALSE 113261
// InitStreamMode ;
113257: CALL 114437 0 0
// if p3 = 1 then
113261: LD_VAR 0 3
113265: PUSH
113266: LD_INT 1
113268: EQUAL
113269: IFFALSE 113279
// sRocket := true ;
113271: LD_ADDR_EXP 153
113275: PUSH
113276: LD_INT 1
113278: ST_TO_ADDR
// if p3 = 2 then
113279: LD_VAR 0 3
113283: PUSH
113284: LD_INT 2
113286: EQUAL
113287: IFFALSE 113297
// sSpeed := true ;
113289: LD_ADDR_EXP 152
113293: PUSH
113294: LD_INT 1
113296: ST_TO_ADDR
// if p3 = 3 then
113297: LD_VAR 0 3
113301: PUSH
113302: LD_INT 3
113304: EQUAL
113305: IFFALSE 113315
// sEngine := true ;
113307: LD_ADDR_EXP 154
113311: PUSH
113312: LD_INT 1
113314: ST_TO_ADDR
// if p3 = 4 then
113315: LD_VAR 0 3
113319: PUSH
113320: LD_INT 4
113322: EQUAL
113323: IFFALSE 113333
// sSpec := true ;
113325: LD_ADDR_EXP 151
113329: PUSH
113330: LD_INT 1
113332: ST_TO_ADDR
// if p3 = 5 then
113333: LD_VAR 0 3
113337: PUSH
113338: LD_INT 5
113340: EQUAL
113341: IFFALSE 113351
// sLevel := true ;
113343: LD_ADDR_EXP 155
113347: PUSH
113348: LD_INT 1
113350: ST_TO_ADDR
// if p3 = 6 then
113351: LD_VAR 0 3
113355: PUSH
113356: LD_INT 6
113358: EQUAL
113359: IFFALSE 113369
// sArmoury := true ;
113361: LD_ADDR_EXP 156
113365: PUSH
113366: LD_INT 1
113368: ST_TO_ADDR
// if p3 = 7 then
113369: LD_VAR 0 3
113373: PUSH
113374: LD_INT 7
113376: EQUAL
113377: IFFALSE 113387
// sRadar := true ;
113379: LD_ADDR_EXP 157
113383: PUSH
113384: LD_INT 1
113386: ST_TO_ADDR
// if p3 = 8 then
113387: LD_VAR 0 3
113391: PUSH
113392: LD_INT 8
113394: EQUAL
113395: IFFALSE 113405
// sBunker := true ;
113397: LD_ADDR_EXP 158
113401: PUSH
113402: LD_INT 1
113404: ST_TO_ADDR
// if p3 = 9 then
113405: LD_VAR 0 3
113409: PUSH
113410: LD_INT 9
113412: EQUAL
113413: IFFALSE 113423
// sHack := true ;
113415: LD_ADDR_EXP 159
113419: PUSH
113420: LD_INT 1
113422: ST_TO_ADDR
// if p3 = 10 then
113423: LD_VAR 0 3
113427: PUSH
113428: LD_INT 10
113430: EQUAL
113431: IFFALSE 113441
// sFire := true ;
113433: LD_ADDR_EXP 160
113437: PUSH
113438: LD_INT 1
113440: ST_TO_ADDR
// if p3 = 11 then
113441: LD_VAR 0 3
113445: PUSH
113446: LD_INT 11
113448: EQUAL
113449: IFFALSE 113459
// sRefresh := true ;
113451: LD_ADDR_EXP 161
113455: PUSH
113456: LD_INT 1
113458: ST_TO_ADDR
// if p3 = 12 then
113459: LD_VAR 0 3
113463: PUSH
113464: LD_INT 12
113466: EQUAL
113467: IFFALSE 113477
// sExp := true ;
113469: LD_ADDR_EXP 162
113473: PUSH
113474: LD_INT 1
113476: ST_TO_ADDR
// if p3 = 13 then
113477: LD_VAR 0 3
113481: PUSH
113482: LD_INT 13
113484: EQUAL
113485: IFFALSE 113495
// sDepot := true ;
113487: LD_ADDR_EXP 163
113491: PUSH
113492: LD_INT 1
113494: ST_TO_ADDR
// if p3 = 14 then
113495: LD_VAR 0 3
113499: PUSH
113500: LD_INT 14
113502: EQUAL
113503: IFFALSE 113513
// sFlag := true ;
113505: LD_ADDR_EXP 164
113509: PUSH
113510: LD_INT 1
113512: ST_TO_ADDR
// if p3 = 15 then
113513: LD_VAR 0 3
113517: PUSH
113518: LD_INT 15
113520: EQUAL
113521: IFFALSE 113531
// sKamikadze := true ;
113523: LD_ADDR_EXP 172
113527: PUSH
113528: LD_INT 1
113530: ST_TO_ADDR
// if p3 = 16 then
113531: LD_VAR 0 3
113535: PUSH
113536: LD_INT 16
113538: EQUAL
113539: IFFALSE 113549
// sTroll := true ;
113541: LD_ADDR_EXP 173
113545: PUSH
113546: LD_INT 1
113548: ST_TO_ADDR
// if p3 = 17 then
113549: LD_VAR 0 3
113553: PUSH
113554: LD_INT 17
113556: EQUAL
113557: IFFALSE 113567
// sSlow := true ;
113559: LD_ADDR_EXP 174
113563: PUSH
113564: LD_INT 1
113566: ST_TO_ADDR
// if p3 = 18 then
113567: LD_VAR 0 3
113571: PUSH
113572: LD_INT 18
113574: EQUAL
113575: IFFALSE 113585
// sLack := true ;
113577: LD_ADDR_EXP 175
113581: PUSH
113582: LD_INT 1
113584: ST_TO_ADDR
// if p3 = 19 then
113585: LD_VAR 0 3
113589: PUSH
113590: LD_INT 19
113592: EQUAL
113593: IFFALSE 113603
// sTank := true ;
113595: LD_ADDR_EXP 177
113599: PUSH
113600: LD_INT 1
113602: ST_TO_ADDR
// if p3 = 20 then
113603: LD_VAR 0 3
113607: PUSH
113608: LD_INT 20
113610: EQUAL
113611: IFFALSE 113621
// sRemote := true ;
113613: LD_ADDR_EXP 178
113617: PUSH
113618: LD_INT 1
113620: ST_TO_ADDR
// if p3 = 21 then
113621: LD_VAR 0 3
113625: PUSH
113626: LD_INT 21
113628: EQUAL
113629: IFFALSE 113639
// sPowell := true ;
113631: LD_ADDR_EXP 179
113635: PUSH
113636: LD_INT 1
113638: ST_TO_ADDR
// if p3 = 22 then
113639: LD_VAR 0 3
113643: PUSH
113644: LD_INT 22
113646: EQUAL
113647: IFFALSE 113657
// sTeleport := true ;
113649: LD_ADDR_EXP 182
113653: PUSH
113654: LD_INT 1
113656: ST_TO_ADDR
// if p3 = 23 then
113657: LD_VAR 0 3
113661: PUSH
113662: LD_INT 23
113664: EQUAL
113665: IFFALSE 113675
// sOilTower := true ;
113667: LD_ADDR_EXP 184
113671: PUSH
113672: LD_INT 1
113674: ST_TO_ADDR
// if p3 = 24 then
113675: LD_VAR 0 3
113679: PUSH
113680: LD_INT 24
113682: EQUAL
113683: IFFALSE 113693
// sShovel := true ;
113685: LD_ADDR_EXP 185
113689: PUSH
113690: LD_INT 1
113692: ST_TO_ADDR
// if p3 = 25 then
113693: LD_VAR 0 3
113697: PUSH
113698: LD_INT 25
113700: EQUAL
113701: IFFALSE 113711
// sSheik := true ;
113703: LD_ADDR_EXP 186
113707: PUSH
113708: LD_INT 1
113710: ST_TO_ADDR
// if p3 = 26 then
113711: LD_VAR 0 3
113715: PUSH
113716: LD_INT 26
113718: EQUAL
113719: IFFALSE 113729
// sEarthquake := true ;
113721: LD_ADDR_EXP 188
113725: PUSH
113726: LD_INT 1
113728: ST_TO_ADDR
// if p3 = 27 then
113729: LD_VAR 0 3
113733: PUSH
113734: LD_INT 27
113736: EQUAL
113737: IFFALSE 113747
// sAI := true ;
113739: LD_ADDR_EXP 189
113743: PUSH
113744: LD_INT 1
113746: ST_TO_ADDR
// if p3 = 28 then
113747: LD_VAR 0 3
113751: PUSH
113752: LD_INT 28
113754: EQUAL
113755: IFFALSE 113765
// sCargo := true ;
113757: LD_ADDR_EXP 192
113761: PUSH
113762: LD_INT 1
113764: ST_TO_ADDR
// if p3 = 29 then
113765: LD_VAR 0 3
113769: PUSH
113770: LD_INT 29
113772: EQUAL
113773: IFFALSE 113783
// sDLaser := true ;
113775: LD_ADDR_EXP 193
113779: PUSH
113780: LD_INT 1
113782: ST_TO_ADDR
// if p3 = 30 then
113783: LD_VAR 0 3
113787: PUSH
113788: LD_INT 30
113790: EQUAL
113791: IFFALSE 113801
// sExchange := true ;
113793: LD_ADDR_EXP 194
113797: PUSH
113798: LD_INT 1
113800: ST_TO_ADDR
// if p3 = 31 then
113801: LD_VAR 0 3
113805: PUSH
113806: LD_INT 31
113808: EQUAL
113809: IFFALSE 113819
// sFac := true ;
113811: LD_ADDR_EXP 195
113815: PUSH
113816: LD_INT 1
113818: ST_TO_ADDR
// if p3 = 32 then
113819: LD_VAR 0 3
113823: PUSH
113824: LD_INT 32
113826: EQUAL
113827: IFFALSE 113837
// sPower := true ;
113829: LD_ADDR_EXP 196
113833: PUSH
113834: LD_INT 1
113836: ST_TO_ADDR
// if p3 = 33 then
113837: LD_VAR 0 3
113841: PUSH
113842: LD_INT 33
113844: EQUAL
113845: IFFALSE 113855
// sRandom := true ;
113847: LD_ADDR_EXP 197
113851: PUSH
113852: LD_INT 1
113854: ST_TO_ADDR
// if p3 = 34 then
113855: LD_VAR 0 3
113859: PUSH
113860: LD_INT 34
113862: EQUAL
113863: IFFALSE 113873
// sShield := true ;
113865: LD_ADDR_EXP 198
113869: PUSH
113870: LD_INT 1
113872: ST_TO_ADDR
// if p3 = 35 then
113873: LD_VAR 0 3
113877: PUSH
113878: LD_INT 35
113880: EQUAL
113881: IFFALSE 113891
// sTime := true ;
113883: LD_ADDR_EXP 199
113887: PUSH
113888: LD_INT 1
113890: ST_TO_ADDR
// if p3 = 36 then
113891: LD_VAR 0 3
113895: PUSH
113896: LD_INT 36
113898: EQUAL
113899: IFFALSE 113909
// sTools := true ;
113901: LD_ADDR_EXP 200
113905: PUSH
113906: LD_INT 1
113908: ST_TO_ADDR
// if p3 = 101 then
113909: LD_VAR 0 3
113913: PUSH
113914: LD_INT 101
113916: EQUAL
113917: IFFALSE 113927
// sSold := true ;
113919: LD_ADDR_EXP 165
113923: PUSH
113924: LD_INT 1
113926: ST_TO_ADDR
// if p3 = 102 then
113927: LD_VAR 0 3
113931: PUSH
113932: LD_INT 102
113934: EQUAL
113935: IFFALSE 113945
// sDiff := true ;
113937: LD_ADDR_EXP 166
113941: PUSH
113942: LD_INT 1
113944: ST_TO_ADDR
// if p3 = 103 then
113945: LD_VAR 0 3
113949: PUSH
113950: LD_INT 103
113952: EQUAL
113953: IFFALSE 113963
// sFog := true ;
113955: LD_ADDR_EXP 169
113959: PUSH
113960: LD_INT 1
113962: ST_TO_ADDR
// if p3 = 104 then
113963: LD_VAR 0 3
113967: PUSH
113968: LD_INT 104
113970: EQUAL
113971: IFFALSE 113981
// sReset := true ;
113973: LD_ADDR_EXP 170
113977: PUSH
113978: LD_INT 1
113980: ST_TO_ADDR
// if p3 = 105 then
113981: LD_VAR 0 3
113985: PUSH
113986: LD_INT 105
113988: EQUAL
113989: IFFALSE 113999
// sSun := true ;
113991: LD_ADDR_EXP 171
113995: PUSH
113996: LD_INT 1
113998: ST_TO_ADDR
// if p3 = 106 then
113999: LD_VAR 0 3
114003: PUSH
114004: LD_INT 106
114006: EQUAL
114007: IFFALSE 114017
// sTiger := true ;
114009: LD_ADDR_EXP 167
114013: PUSH
114014: LD_INT 1
114016: ST_TO_ADDR
// if p3 = 107 then
114017: LD_VAR 0 3
114021: PUSH
114022: LD_INT 107
114024: EQUAL
114025: IFFALSE 114035
// sBomb := true ;
114027: LD_ADDR_EXP 168
114031: PUSH
114032: LD_INT 1
114034: ST_TO_ADDR
// if p3 = 108 then
114035: LD_VAR 0 3
114039: PUSH
114040: LD_INT 108
114042: EQUAL
114043: IFFALSE 114053
// sWound := true ;
114045: LD_ADDR_EXP 176
114049: PUSH
114050: LD_INT 1
114052: ST_TO_ADDR
// if p3 = 109 then
114053: LD_VAR 0 3
114057: PUSH
114058: LD_INT 109
114060: EQUAL
114061: IFFALSE 114071
// sBetray := true ;
114063: LD_ADDR_EXP 180
114067: PUSH
114068: LD_INT 1
114070: ST_TO_ADDR
// if p3 = 110 then
114071: LD_VAR 0 3
114075: PUSH
114076: LD_INT 110
114078: EQUAL
114079: IFFALSE 114089
// sContamin := true ;
114081: LD_ADDR_EXP 181
114085: PUSH
114086: LD_INT 1
114088: ST_TO_ADDR
// if p3 = 111 then
114089: LD_VAR 0 3
114093: PUSH
114094: LD_INT 111
114096: EQUAL
114097: IFFALSE 114107
// sOil := true ;
114099: LD_ADDR_EXP 183
114103: PUSH
114104: LD_INT 1
114106: ST_TO_ADDR
// if p3 = 112 then
114107: LD_VAR 0 3
114111: PUSH
114112: LD_INT 112
114114: EQUAL
114115: IFFALSE 114125
// sStu := true ;
114117: LD_ADDR_EXP 187
114121: PUSH
114122: LD_INT 1
114124: ST_TO_ADDR
// if p3 = 113 then
114125: LD_VAR 0 3
114129: PUSH
114130: LD_INT 113
114132: EQUAL
114133: IFFALSE 114143
// sBazooka := true ;
114135: LD_ADDR_EXP 190
114139: PUSH
114140: LD_INT 1
114142: ST_TO_ADDR
// if p3 = 114 then
114143: LD_VAR 0 3
114147: PUSH
114148: LD_INT 114
114150: EQUAL
114151: IFFALSE 114161
// sMortar := true ;
114153: LD_ADDR_EXP 191
114157: PUSH
114158: LD_INT 1
114160: ST_TO_ADDR
// if p3 = 115 then
114161: LD_VAR 0 3
114165: PUSH
114166: LD_INT 115
114168: EQUAL
114169: IFFALSE 114179
// sRanger := true ;
114171: LD_ADDR_EXP 201
114175: PUSH
114176: LD_INT 1
114178: ST_TO_ADDR
// if p3 = 116 then
114179: LD_VAR 0 3
114183: PUSH
114184: LD_INT 116
114186: EQUAL
114187: IFFALSE 114197
// sComputer := true ;
114189: LD_ADDR_EXP 202
114193: PUSH
114194: LD_INT 1
114196: ST_TO_ADDR
// if p3 = 117 then
114197: LD_VAR 0 3
114201: PUSH
114202: LD_INT 117
114204: EQUAL
114205: IFFALSE 114215
// s30 := true ;
114207: LD_ADDR_EXP 203
114211: PUSH
114212: LD_INT 1
114214: ST_TO_ADDR
// if p3 = 118 then
114215: LD_VAR 0 3
114219: PUSH
114220: LD_INT 118
114222: EQUAL
114223: IFFALSE 114233
// s60 := true ;
114225: LD_ADDR_EXP 204
114229: PUSH
114230: LD_INT 1
114232: ST_TO_ADDR
// end ; if p2 = hack_mode then
114233: LD_VAR 0 2
114237: PUSH
114238: LD_INT 101
114240: EQUAL
114241: IFFALSE 114369
// begin case p3 of 1 :
114243: LD_VAR 0 3
114247: PUSH
114248: LD_INT 1
114250: DOUBLE
114251: EQUAL
114252: IFTRUE 114256
114254: GO 114263
114256: POP
// hHackUnlimitedResources ; 2 :
114257: CALL 126516 0 0
114261: GO 114369
114263: LD_INT 2
114265: DOUBLE
114266: EQUAL
114267: IFTRUE 114271
114269: GO 114278
114271: POP
// hHackSetLevel10 ; 3 :
114272: CALL 126649 0 0
114276: GO 114369
114278: LD_INT 3
114280: DOUBLE
114281: EQUAL
114282: IFTRUE 114286
114284: GO 114293
114286: POP
// hHackSetLevel10YourUnits ; 4 :
114287: CALL 126734 0 0
114291: GO 114369
114293: LD_INT 4
114295: DOUBLE
114296: EQUAL
114297: IFTRUE 114301
114299: GO 114308
114301: POP
// hHackInvincible ; 5 :
114302: CALL 127182 0 0
114306: GO 114369
114308: LD_INT 5
114310: DOUBLE
114311: EQUAL
114312: IFTRUE 114316
114314: GO 114323
114316: POP
// hHackInvisible ; 6 :
114317: CALL 127293 0 0
114321: GO 114369
114323: LD_INT 6
114325: DOUBLE
114326: EQUAL
114327: IFTRUE 114331
114329: GO 114338
114331: POP
// hHackChangeYourSide ; 7 :
114332: CALL 127350 0 0
114336: GO 114369
114338: LD_INT 7
114340: DOUBLE
114341: EQUAL
114342: IFTRUE 114346
114344: GO 114353
114346: POP
// hHackChangeUnitSide ; 8 :
114347: CALL 127392 0 0
114351: GO 114369
114353: LD_INT 8
114355: DOUBLE
114356: EQUAL
114357: IFTRUE 114361
114359: GO 114368
114361: POP
// hHackFog ; end ;
114362: CALL 127493 0 0
114366: GO 114369
114368: POP
// end ; if p2 = game_save_mode then
114369: LD_VAR 0 2
114373: PUSH
114374: LD_INT 102
114376: EQUAL
114377: IFFALSE 114432
// begin if p3 = 1 then
114379: LD_VAR 0 3
114383: PUSH
114384: LD_INT 1
114386: EQUAL
114387: IFFALSE 114399
// globalGameSaveCounter := p4 ;
114389: LD_ADDR_EXP 147
114393: PUSH
114394: LD_VAR 0 4
114398: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
114399: LD_VAR 0 3
114403: PUSH
114404: LD_INT 2
114406: EQUAL
114407: PUSH
114408: LD_EXP 147
114412: AND
114413: IFFALSE 114432
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
114415: LD_STRING setGameSaveCounter(
114417: PUSH
114418: LD_EXP 147
114422: STR
114423: PUSH
114424: LD_STRING )
114426: STR
114427: PPUSH
114428: CALL_OW 559
// end ; end ;
114432: LD_VAR 0 7
114436: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
114437: LD_INT 0
114439: PPUSH
// streamModeActive := false ;
114440: LD_ADDR_EXP 148
114444: PUSH
114445: LD_INT 0
114447: ST_TO_ADDR
// normalCounter := 36 ;
114448: LD_ADDR_EXP 149
114452: PUSH
114453: LD_INT 36
114455: ST_TO_ADDR
// hardcoreCounter := 18 ;
114456: LD_ADDR_EXP 150
114460: PUSH
114461: LD_INT 18
114463: ST_TO_ADDR
// sRocket := false ;
114464: LD_ADDR_EXP 153
114468: PUSH
114469: LD_INT 0
114471: ST_TO_ADDR
// sSpeed := false ;
114472: LD_ADDR_EXP 152
114476: PUSH
114477: LD_INT 0
114479: ST_TO_ADDR
// sEngine := false ;
114480: LD_ADDR_EXP 154
114484: PUSH
114485: LD_INT 0
114487: ST_TO_ADDR
// sSpec := false ;
114488: LD_ADDR_EXP 151
114492: PUSH
114493: LD_INT 0
114495: ST_TO_ADDR
// sLevel := false ;
114496: LD_ADDR_EXP 155
114500: PUSH
114501: LD_INT 0
114503: ST_TO_ADDR
// sArmoury := false ;
114504: LD_ADDR_EXP 156
114508: PUSH
114509: LD_INT 0
114511: ST_TO_ADDR
// sRadar := false ;
114512: LD_ADDR_EXP 157
114516: PUSH
114517: LD_INT 0
114519: ST_TO_ADDR
// sBunker := false ;
114520: LD_ADDR_EXP 158
114524: PUSH
114525: LD_INT 0
114527: ST_TO_ADDR
// sHack := false ;
114528: LD_ADDR_EXP 159
114532: PUSH
114533: LD_INT 0
114535: ST_TO_ADDR
// sFire := false ;
114536: LD_ADDR_EXP 160
114540: PUSH
114541: LD_INT 0
114543: ST_TO_ADDR
// sRefresh := false ;
114544: LD_ADDR_EXP 161
114548: PUSH
114549: LD_INT 0
114551: ST_TO_ADDR
// sExp := false ;
114552: LD_ADDR_EXP 162
114556: PUSH
114557: LD_INT 0
114559: ST_TO_ADDR
// sDepot := false ;
114560: LD_ADDR_EXP 163
114564: PUSH
114565: LD_INT 0
114567: ST_TO_ADDR
// sFlag := false ;
114568: LD_ADDR_EXP 164
114572: PUSH
114573: LD_INT 0
114575: ST_TO_ADDR
// sKamikadze := false ;
114576: LD_ADDR_EXP 172
114580: PUSH
114581: LD_INT 0
114583: ST_TO_ADDR
// sTroll := false ;
114584: LD_ADDR_EXP 173
114588: PUSH
114589: LD_INT 0
114591: ST_TO_ADDR
// sSlow := false ;
114592: LD_ADDR_EXP 174
114596: PUSH
114597: LD_INT 0
114599: ST_TO_ADDR
// sLack := false ;
114600: LD_ADDR_EXP 175
114604: PUSH
114605: LD_INT 0
114607: ST_TO_ADDR
// sTank := false ;
114608: LD_ADDR_EXP 177
114612: PUSH
114613: LD_INT 0
114615: ST_TO_ADDR
// sRemote := false ;
114616: LD_ADDR_EXP 178
114620: PUSH
114621: LD_INT 0
114623: ST_TO_ADDR
// sPowell := false ;
114624: LD_ADDR_EXP 179
114628: PUSH
114629: LD_INT 0
114631: ST_TO_ADDR
// sTeleport := false ;
114632: LD_ADDR_EXP 182
114636: PUSH
114637: LD_INT 0
114639: ST_TO_ADDR
// sOilTower := false ;
114640: LD_ADDR_EXP 184
114644: PUSH
114645: LD_INT 0
114647: ST_TO_ADDR
// sShovel := false ;
114648: LD_ADDR_EXP 185
114652: PUSH
114653: LD_INT 0
114655: ST_TO_ADDR
// sSheik := false ;
114656: LD_ADDR_EXP 186
114660: PUSH
114661: LD_INT 0
114663: ST_TO_ADDR
// sEarthquake := false ;
114664: LD_ADDR_EXP 188
114668: PUSH
114669: LD_INT 0
114671: ST_TO_ADDR
// sAI := false ;
114672: LD_ADDR_EXP 189
114676: PUSH
114677: LD_INT 0
114679: ST_TO_ADDR
// sCargo := false ;
114680: LD_ADDR_EXP 192
114684: PUSH
114685: LD_INT 0
114687: ST_TO_ADDR
// sDLaser := false ;
114688: LD_ADDR_EXP 193
114692: PUSH
114693: LD_INT 0
114695: ST_TO_ADDR
// sExchange := false ;
114696: LD_ADDR_EXP 194
114700: PUSH
114701: LD_INT 0
114703: ST_TO_ADDR
// sFac := false ;
114704: LD_ADDR_EXP 195
114708: PUSH
114709: LD_INT 0
114711: ST_TO_ADDR
// sPower := false ;
114712: LD_ADDR_EXP 196
114716: PUSH
114717: LD_INT 0
114719: ST_TO_ADDR
// sRandom := false ;
114720: LD_ADDR_EXP 197
114724: PUSH
114725: LD_INT 0
114727: ST_TO_ADDR
// sShield := false ;
114728: LD_ADDR_EXP 198
114732: PUSH
114733: LD_INT 0
114735: ST_TO_ADDR
// sTime := false ;
114736: LD_ADDR_EXP 199
114740: PUSH
114741: LD_INT 0
114743: ST_TO_ADDR
// sTools := false ;
114744: LD_ADDR_EXP 200
114748: PUSH
114749: LD_INT 0
114751: ST_TO_ADDR
// sSold := false ;
114752: LD_ADDR_EXP 165
114756: PUSH
114757: LD_INT 0
114759: ST_TO_ADDR
// sDiff := false ;
114760: LD_ADDR_EXP 166
114764: PUSH
114765: LD_INT 0
114767: ST_TO_ADDR
// sFog := false ;
114768: LD_ADDR_EXP 169
114772: PUSH
114773: LD_INT 0
114775: ST_TO_ADDR
// sReset := false ;
114776: LD_ADDR_EXP 170
114780: PUSH
114781: LD_INT 0
114783: ST_TO_ADDR
// sSun := false ;
114784: LD_ADDR_EXP 171
114788: PUSH
114789: LD_INT 0
114791: ST_TO_ADDR
// sTiger := false ;
114792: LD_ADDR_EXP 167
114796: PUSH
114797: LD_INT 0
114799: ST_TO_ADDR
// sBomb := false ;
114800: LD_ADDR_EXP 168
114804: PUSH
114805: LD_INT 0
114807: ST_TO_ADDR
// sWound := false ;
114808: LD_ADDR_EXP 176
114812: PUSH
114813: LD_INT 0
114815: ST_TO_ADDR
// sBetray := false ;
114816: LD_ADDR_EXP 180
114820: PUSH
114821: LD_INT 0
114823: ST_TO_ADDR
// sContamin := false ;
114824: LD_ADDR_EXP 181
114828: PUSH
114829: LD_INT 0
114831: ST_TO_ADDR
// sOil := false ;
114832: LD_ADDR_EXP 183
114836: PUSH
114837: LD_INT 0
114839: ST_TO_ADDR
// sStu := false ;
114840: LD_ADDR_EXP 187
114844: PUSH
114845: LD_INT 0
114847: ST_TO_ADDR
// sBazooka := false ;
114848: LD_ADDR_EXP 190
114852: PUSH
114853: LD_INT 0
114855: ST_TO_ADDR
// sMortar := false ;
114856: LD_ADDR_EXP 191
114860: PUSH
114861: LD_INT 0
114863: ST_TO_ADDR
// sRanger := false ;
114864: LD_ADDR_EXP 201
114868: PUSH
114869: LD_INT 0
114871: ST_TO_ADDR
// sComputer := false ;
114872: LD_ADDR_EXP 202
114876: PUSH
114877: LD_INT 0
114879: ST_TO_ADDR
// s30 := false ;
114880: LD_ADDR_EXP 203
114884: PUSH
114885: LD_INT 0
114887: ST_TO_ADDR
// s60 := false ;
114888: LD_ADDR_EXP 204
114892: PUSH
114893: LD_INT 0
114895: ST_TO_ADDR
// end ;
114896: LD_VAR 0 1
114900: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
114901: LD_INT 0
114903: PPUSH
114904: PPUSH
114905: PPUSH
114906: PPUSH
114907: PPUSH
114908: PPUSH
114909: PPUSH
// result := [ ] ;
114910: LD_ADDR_VAR 0 2
114914: PUSH
114915: EMPTY
114916: ST_TO_ADDR
// if campaign_id = 1 then
114917: LD_OWVAR 69
114921: PUSH
114922: LD_INT 1
114924: EQUAL
114925: IFFALSE 118091
// begin case mission_number of 1 :
114927: LD_OWVAR 70
114931: PUSH
114932: LD_INT 1
114934: DOUBLE
114935: EQUAL
114936: IFTRUE 114940
114938: GO 115016
114940: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
114941: LD_ADDR_VAR 0 2
114945: PUSH
114946: LD_INT 2
114948: PUSH
114949: LD_INT 4
114951: PUSH
114952: LD_INT 11
114954: PUSH
114955: LD_INT 12
114957: PUSH
114958: LD_INT 15
114960: PUSH
114961: LD_INT 16
114963: PUSH
114964: LD_INT 22
114966: PUSH
114967: LD_INT 23
114969: PUSH
114970: LD_INT 26
114972: PUSH
114973: EMPTY
114974: LIST
114975: LIST
114976: LIST
114977: LIST
114978: LIST
114979: LIST
114980: LIST
114981: LIST
114982: LIST
114983: PUSH
114984: LD_INT 101
114986: PUSH
114987: LD_INT 102
114989: PUSH
114990: LD_INT 106
114992: PUSH
114993: LD_INT 116
114995: PUSH
114996: LD_INT 117
114998: PUSH
114999: LD_INT 118
115001: PUSH
115002: EMPTY
115003: LIST
115004: LIST
115005: LIST
115006: LIST
115007: LIST
115008: LIST
115009: PUSH
115010: EMPTY
115011: LIST
115012: LIST
115013: ST_TO_ADDR
115014: GO 118089
115016: LD_INT 2
115018: DOUBLE
115019: EQUAL
115020: IFTRUE 115024
115022: GO 115108
115024: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
115025: LD_ADDR_VAR 0 2
115029: PUSH
115030: LD_INT 2
115032: PUSH
115033: LD_INT 4
115035: PUSH
115036: LD_INT 11
115038: PUSH
115039: LD_INT 12
115041: PUSH
115042: LD_INT 15
115044: PUSH
115045: LD_INT 16
115047: PUSH
115048: LD_INT 22
115050: PUSH
115051: LD_INT 23
115053: PUSH
115054: LD_INT 26
115056: PUSH
115057: EMPTY
115058: LIST
115059: LIST
115060: LIST
115061: LIST
115062: LIST
115063: LIST
115064: LIST
115065: LIST
115066: LIST
115067: PUSH
115068: LD_INT 101
115070: PUSH
115071: LD_INT 102
115073: PUSH
115074: LD_INT 105
115076: PUSH
115077: LD_INT 106
115079: PUSH
115080: LD_INT 108
115082: PUSH
115083: LD_INT 116
115085: PUSH
115086: LD_INT 117
115088: PUSH
115089: LD_INT 118
115091: PUSH
115092: EMPTY
115093: LIST
115094: LIST
115095: LIST
115096: LIST
115097: LIST
115098: LIST
115099: LIST
115100: LIST
115101: PUSH
115102: EMPTY
115103: LIST
115104: LIST
115105: ST_TO_ADDR
115106: GO 118089
115108: LD_INT 3
115110: DOUBLE
115111: EQUAL
115112: IFTRUE 115116
115114: GO 115204
115116: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
115117: LD_ADDR_VAR 0 2
115121: PUSH
115122: LD_INT 2
115124: PUSH
115125: LD_INT 4
115127: PUSH
115128: LD_INT 5
115130: PUSH
115131: LD_INT 11
115133: PUSH
115134: LD_INT 12
115136: PUSH
115137: LD_INT 15
115139: PUSH
115140: LD_INT 16
115142: PUSH
115143: LD_INT 22
115145: PUSH
115146: LD_INT 26
115148: PUSH
115149: LD_INT 36
115151: PUSH
115152: EMPTY
115153: LIST
115154: LIST
115155: LIST
115156: LIST
115157: LIST
115158: LIST
115159: LIST
115160: LIST
115161: LIST
115162: LIST
115163: PUSH
115164: LD_INT 101
115166: PUSH
115167: LD_INT 102
115169: PUSH
115170: LD_INT 105
115172: PUSH
115173: LD_INT 106
115175: PUSH
115176: LD_INT 108
115178: PUSH
115179: LD_INT 116
115181: PUSH
115182: LD_INT 117
115184: PUSH
115185: LD_INT 118
115187: PUSH
115188: EMPTY
115189: LIST
115190: LIST
115191: LIST
115192: LIST
115193: LIST
115194: LIST
115195: LIST
115196: LIST
115197: PUSH
115198: EMPTY
115199: LIST
115200: LIST
115201: ST_TO_ADDR
115202: GO 118089
115204: LD_INT 4
115206: DOUBLE
115207: EQUAL
115208: IFTRUE 115212
115210: GO 115308
115212: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
115213: LD_ADDR_VAR 0 2
115217: PUSH
115218: LD_INT 2
115220: PUSH
115221: LD_INT 4
115223: PUSH
115224: LD_INT 5
115226: PUSH
115227: LD_INT 8
115229: PUSH
115230: LD_INT 11
115232: PUSH
115233: LD_INT 12
115235: PUSH
115236: LD_INT 15
115238: PUSH
115239: LD_INT 16
115241: PUSH
115242: LD_INT 22
115244: PUSH
115245: LD_INT 23
115247: PUSH
115248: LD_INT 26
115250: PUSH
115251: LD_INT 36
115253: PUSH
115254: EMPTY
115255: LIST
115256: LIST
115257: LIST
115258: LIST
115259: LIST
115260: LIST
115261: LIST
115262: LIST
115263: LIST
115264: LIST
115265: LIST
115266: LIST
115267: PUSH
115268: LD_INT 101
115270: PUSH
115271: LD_INT 102
115273: PUSH
115274: LD_INT 105
115276: PUSH
115277: LD_INT 106
115279: PUSH
115280: LD_INT 108
115282: PUSH
115283: LD_INT 116
115285: PUSH
115286: LD_INT 117
115288: PUSH
115289: LD_INT 118
115291: PUSH
115292: EMPTY
115293: LIST
115294: LIST
115295: LIST
115296: LIST
115297: LIST
115298: LIST
115299: LIST
115300: LIST
115301: PUSH
115302: EMPTY
115303: LIST
115304: LIST
115305: ST_TO_ADDR
115306: GO 118089
115308: LD_INT 5
115310: DOUBLE
115311: EQUAL
115312: IFTRUE 115316
115314: GO 115428
115316: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
115317: LD_ADDR_VAR 0 2
115321: PUSH
115322: LD_INT 2
115324: PUSH
115325: LD_INT 4
115327: PUSH
115328: LD_INT 5
115330: PUSH
115331: LD_INT 6
115333: PUSH
115334: LD_INT 8
115336: PUSH
115337: LD_INT 11
115339: PUSH
115340: LD_INT 12
115342: PUSH
115343: LD_INT 15
115345: PUSH
115346: LD_INT 16
115348: PUSH
115349: LD_INT 22
115351: PUSH
115352: LD_INT 23
115354: PUSH
115355: LD_INT 25
115357: PUSH
115358: LD_INT 26
115360: PUSH
115361: LD_INT 36
115363: PUSH
115364: EMPTY
115365: LIST
115366: LIST
115367: LIST
115368: LIST
115369: LIST
115370: LIST
115371: LIST
115372: LIST
115373: LIST
115374: LIST
115375: LIST
115376: LIST
115377: LIST
115378: LIST
115379: PUSH
115380: LD_INT 101
115382: PUSH
115383: LD_INT 102
115385: PUSH
115386: LD_INT 105
115388: PUSH
115389: LD_INT 106
115391: PUSH
115392: LD_INT 108
115394: PUSH
115395: LD_INT 109
115397: PUSH
115398: LD_INT 112
115400: PUSH
115401: LD_INT 116
115403: PUSH
115404: LD_INT 117
115406: PUSH
115407: LD_INT 118
115409: PUSH
115410: EMPTY
115411: LIST
115412: LIST
115413: LIST
115414: LIST
115415: LIST
115416: LIST
115417: LIST
115418: LIST
115419: LIST
115420: LIST
115421: PUSH
115422: EMPTY
115423: LIST
115424: LIST
115425: ST_TO_ADDR
115426: GO 118089
115428: LD_INT 6
115430: DOUBLE
115431: EQUAL
115432: IFTRUE 115436
115434: GO 115568
115436: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
115437: LD_ADDR_VAR 0 2
115441: PUSH
115442: LD_INT 2
115444: PUSH
115445: LD_INT 4
115447: PUSH
115448: LD_INT 5
115450: PUSH
115451: LD_INT 6
115453: PUSH
115454: LD_INT 8
115456: PUSH
115457: LD_INT 11
115459: PUSH
115460: LD_INT 12
115462: PUSH
115463: LD_INT 15
115465: PUSH
115466: LD_INT 16
115468: PUSH
115469: LD_INT 20
115471: PUSH
115472: LD_INT 21
115474: PUSH
115475: LD_INT 22
115477: PUSH
115478: LD_INT 23
115480: PUSH
115481: LD_INT 25
115483: PUSH
115484: LD_INT 26
115486: PUSH
115487: LD_INT 30
115489: PUSH
115490: LD_INT 31
115492: PUSH
115493: LD_INT 32
115495: PUSH
115496: LD_INT 36
115498: PUSH
115499: EMPTY
115500: LIST
115501: LIST
115502: LIST
115503: LIST
115504: LIST
115505: LIST
115506: LIST
115507: LIST
115508: LIST
115509: LIST
115510: LIST
115511: LIST
115512: LIST
115513: LIST
115514: LIST
115515: LIST
115516: LIST
115517: LIST
115518: LIST
115519: PUSH
115520: LD_INT 101
115522: PUSH
115523: LD_INT 102
115525: PUSH
115526: LD_INT 105
115528: PUSH
115529: LD_INT 106
115531: PUSH
115532: LD_INT 108
115534: PUSH
115535: LD_INT 109
115537: PUSH
115538: LD_INT 112
115540: PUSH
115541: LD_INT 116
115543: PUSH
115544: LD_INT 117
115546: PUSH
115547: LD_INT 118
115549: PUSH
115550: EMPTY
115551: LIST
115552: LIST
115553: LIST
115554: LIST
115555: LIST
115556: LIST
115557: LIST
115558: LIST
115559: LIST
115560: LIST
115561: PUSH
115562: EMPTY
115563: LIST
115564: LIST
115565: ST_TO_ADDR
115566: GO 118089
115568: LD_INT 7
115570: DOUBLE
115571: EQUAL
115572: IFTRUE 115576
115574: GO 115688
115576: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
115577: LD_ADDR_VAR 0 2
115581: PUSH
115582: LD_INT 2
115584: PUSH
115585: LD_INT 4
115587: PUSH
115588: LD_INT 5
115590: PUSH
115591: LD_INT 7
115593: PUSH
115594: LD_INT 11
115596: PUSH
115597: LD_INT 12
115599: PUSH
115600: LD_INT 15
115602: PUSH
115603: LD_INT 16
115605: PUSH
115606: LD_INT 20
115608: PUSH
115609: LD_INT 21
115611: PUSH
115612: LD_INT 22
115614: PUSH
115615: LD_INT 23
115617: PUSH
115618: LD_INT 25
115620: PUSH
115621: LD_INT 26
115623: PUSH
115624: EMPTY
115625: LIST
115626: LIST
115627: LIST
115628: LIST
115629: LIST
115630: LIST
115631: LIST
115632: LIST
115633: LIST
115634: LIST
115635: LIST
115636: LIST
115637: LIST
115638: LIST
115639: PUSH
115640: LD_INT 101
115642: PUSH
115643: LD_INT 102
115645: PUSH
115646: LD_INT 103
115648: PUSH
115649: LD_INT 105
115651: PUSH
115652: LD_INT 106
115654: PUSH
115655: LD_INT 108
115657: PUSH
115658: LD_INT 112
115660: PUSH
115661: LD_INT 116
115663: PUSH
115664: LD_INT 117
115666: PUSH
115667: LD_INT 118
115669: PUSH
115670: EMPTY
115671: LIST
115672: LIST
115673: LIST
115674: LIST
115675: LIST
115676: LIST
115677: LIST
115678: LIST
115679: LIST
115680: LIST
115681: PUSH
115682: EMPTY
115683: LIST
115684: LIST
115685: ST_TO_ADDR
115686: GO 118089
115688: LD_INT 8
115690: DOUBLE
115691: EQUAL
115692: IFTRUE 115696
115694: GO 115836
115696: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
115697: LD_ADDR_VAR 0 2
115701: PUSH
115702: LD_INT 2
115704: PUSH
115705: LD_INT 4
115707: PUSH
115708: LD_INT 5
115710: PUSH
115711: LD_INT 6
115713: PUSH
115714: LD_INT 7
115716: PUSH
115717: LD_INT 8
115719: PUSH
115720: LD_INT 11
115722: PUSH
115723: LD_INT 12
115725: PUSH
115726: LD_INT 15
115728: PUSH
115729: LD_INT 16
115731: PUSH
115732: LD_INT 20
115734: PUSH
115735: LD_INT 21
115737: PUSH
115738: LD_INT 22
115740: PUSH
115741: LD_INT 23
115743: PUSH
115744: LD_INT 25
115746: PUSH
115747: LD_INT 26
115749: PUSH
115750: LD_INT 30
115752: PUSH
115753: LD_INT 31
115755: PUSH
115756: LD_INT 32
115758: PUSH
115759: LD_INT 36
115761: PUSH
115762: EMPTY
115763: LIST
115764: LIST
115765: LIST
115766: LIST
115767: LIST
115768: LIST
115769: LIST
115770: LIST
115771: LIST
115772: LIST
115773: LIST
115774: LIST
115775: LIST
115776: LIST
115777: LIST
115778: LIST
115779: LIST
115780: LIST
115781: LIST
115782: LIST
115783: PUSH
115784: LD_INT 101
115786: PUSH
115787: LD_INT 102
115789: PUSH
115790: LD_INT 103
115792: PUSH
115793: LD_INT 105
115795: PUSH
115796: LD_INT 106
115798: PUSH
115799: LD_INT 108
115801: PUSH
115802: LD_INT 109
115804: PUSH
115805: LD_INT 112
115807: PUSH
115808: LD_INT 116
115810: PUSH
115811: LD_INT 117
115813: PUSH
115814: LD_INT 118
115816: PUSH
115817: EMPTY
115818: LIST
115819: LIST
115820: LIST
115821: LIST
115822: LIST
115823: LIST
115824: LIST
115825: LIST
115826: LIST
115827: LIST
115828: LIST
115829: PUSH
115830: EMPTY
115831: LIST
115832: LIST
115833: ST_TO_ADDR
115834: GO 118089
115836: LD_INT 9
115838: DOUBLE
115839: EQUAL
115840: IFTRUE 115844
115842: GO 115992
115844: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
115845: LD_ADDR_VAR 0 2
115849: PUSH
115850: LD_INT 2
115852: PUSH
115853: LD_INT 4
115855: PUSH
115856: LD_INT 5
115858: PUSH
115859: LD_INT 6
115861: PUSH
115862: LD_INT 7
115864: PUSH
115865: LD_INT 8
115867: PUSH
115868: LD_INT 11
115870: PUSH
115871: LD_INT 12
115873: PUSH
115874: LD_INT 15
115876: PUSH
115877: LD_INT 16
115879: PUSH
115880: LD_INT 20
115882: PUSH
115883: LD_INT 21
115885: PUSH
115886: LD_INT 22
115888: PUSH
115889: LD_INT 23
115891: PUSH
115892: LD_INT 25
115894: PUSH
115895: LD_INT 26
115897: PUSH
115898: LD_INT 28
115900: PUSH
115901: LD_INT 30
115903: PUSH
115904: LD_INT 31
115906: PUSH
115907: LD_INT 32
115909: PUSH
115910: LD_INT 36
115912: PUSH
115913: EMPTY
115914: LIST
115915: LIST
115916: LIST
115917: LIST
115918: LIST
115919: LIST
115920: LIST
115921: LIST
115922: LIST
115923: LIST
115924: LIST
115925: LIST
115926: LIST
115927: LIST
115928: LIST
115929: LIST
115930: LIST
115931: LIST
115932: LIST
115933: LIST
115934: LIST
115935: PUSH
115936: LD_INT 101
115938: PUSH
115939: LD_INT 102
115941: PUSH
115942: LD_INT 103
115944: PUSH
115945: LD_INT 105
115947: PUSH
115948: LD_INT 106
115950: PUSH
115951: LD_INT 108
115953: PUSH
115954: LD_INT 109
115956: PUSH
115957: LD_INT 112
115959: PUSH
115960: LD_INT 114
115962: PUSH
115963: LD_INT 116
115965: PUSH
115966: LD_INT 117
115968: PUSH
115969: LD_INT 118
115971: PUSH
115972: EMPTY
115973: LIST
115974: LIST
115975: LIST
115976: LIST
115977: LIST
115978: LIST
115979: LIST
115980: LIST
115981: LIST
115982: LIST
115983: LIST
115984: LIST
115985: PUSH
115986: EMPTY
115987: LIST
115988: LIST
115989: ST_TO_ADDR
115990: GO 118089
115992: LD_INT 10
115994: DOUBLE
115995: EQUAL
115996: IFTRUE 116000
115998: GO 116196
116000: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
116001: LD_ADDR_VAR 0 2
116005: PUSH
116006: LD_INT 2
116008: PUSH
116009: LD_INT 4
116011: PUSH
116012: LD_INT 5
116014: PUSH
116015: LD_INT 6
116017: PUSH
116018: LD_INT 7
116020: PUSH
116021: LD_INT 8
116023: PUSH
116024: LD_INT 9
116026: PUSH
116027: LD_INT 10
116029: PUSH
116030: LD_INT 11
116032: PUSH
116033: LD_INT 12
116035: PUSH
116036: LD_INT 13
116038: PUSH
116039: LD_INT 14
116041: PUSH
116042: LD_INT 15
116044: PUSH
116045: LD_INT 16
116047: PUSH
116048: LD_INT 17
116050: PUSH
116051: LD_INT 18
116053: PUSH
116054: LD_INT 19
116056: PUSH
116057: LD_INT 20
116059: PUSH
116060: LD_INT 21
116062: PUSH
116063: LD_INT 22
116065: PUSH
116066: LD_INT 23
116068: PUSH
116069: LD_INT 24
116071: PUSH
116072: LD_INT 25
116074: PUSH
116075: LD_INT 26
116077: PUSH
116078: LD_INT 28
116080: PUSH
116081: LD_INT 30
116083: PUSH
116084: LD_INT 31
116086: PUSH
116087: LD_INT 32
116089: PUSH
116090: LD_INT 36
116092: PUSH
116093: EMPTY
116094: LIST
116095: LIST
116096: LIST
116097: LIST
116098: LIST
116099: LIST
116100: LIST
116101: LIST
116102: LIST
116103: LIST
116104: LIST
116105: LIST
116106: LIST
116107: LIST
116108: LIST
116109: LIST
116110: LIST
116111: LIST
116112: LIST
116113: LIST
116114: LIST
116115: LIST
116116: LIST
116117: LIST
116118: LIST
116119: LIST
116120: LIST
116121: LIST
116122: LIST
116123: PUSH
116124: LD_INT 101
116126: PUSH
116127: LD_INT 102
116129: PUSH
116130: LD_INT 103
116132: PUSH
116133: LD_INT 104
116135: PUSH
116136: LD_INT 105
116138: PUSH
116139: LD_INT 106
116141: PUSH
116142: LD_INT 107
116144: PUSH
116145: LD_INT 108
116147: PUSH
116148: LD_INT 109
116150: PUSH
116151: LD_INT 110
116153: PUSH
116154: LD_INT 111
116156: PUSH
116157: LD_INT 112
116159: PUSH
116160: LD_INT 114
116162: PUSH
116163: LD_INT 116
116165: PUSH
116166: LD_INT 117
116168: PUSH
116169: LD_INT 118
116171: PUSH
116172: EMPTY
116173: LIST
116174: LIST
116175: LIST
116176: LIST
116177: LIST
116178: LIST
116179: LIST
116180: LIST
116181: LIST
116182: LIST
116183: LIST
116184: LIST
116185: LIST
116186: LIST
116187: LIST
116188: LIST
116189: PUSH
116190: EMPTY
116191: LIST
116192: LIST
116193: ST_TO_ADDR
116194: GO 118089
116196: LD_INT 11
116198: DOUBLE
116199: EQUAL
116200: IFTRUE 116204
116202: GO 116408
116204: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
116205: LD_ADDR_VAR 0 2
116209: PUSH
116210: LD_INT 2
116212: PUSH
116213: LD_INT 3
116215: PUSH
116216: LD_INT 4
116218: PUSH
116219: LD_INT 5
116221: PUSH
116222: LD_INT 6
116224: PUSH
116225: LD_INT 7
116227: PUSH
116228: LD_INT 8
116230: PUSH
116231: LD_INT 9
116233: PUSH
116234: LD_INT 10
116236: PUSH
116237: LD_INT 11
116239: PUSH
116240: LD_INT 12
116242: PUSH
116243: LD_INT 13
116245: PUSH
116246: LD_INT 14
116248: PUSH
116249: LD_INT 15
116251: PUSH
116252: LD_INT 16
116254: PUSH
116255: LD_INT 17
116257: PUSH
116258: LD_INT 18
116260: PUSH
116261: LD_INT 19
116263: PUSH
116264: LD_INT 20
116266: PUSH
116267: LD_INT 21
116269: PUSH
116270: LD_INT 22
116272: PUSH
116273: LD_INT 23
116275: PUSH
116276: LD_INT 24
116278: PUSH
116279: LD_INT 25
116281: PUSH
116282: LD_INT 26
116284: PUSH
116285: LD_INT 28
116287: PUSH
116288: LD_INT 30
116290: PUSH
116291: LD_INT 31
116293: PUSH
116294: LD_INT 32
116296: PUSH
116297: LD_INT 34
116299: PUSH
116300: LD_INT 36
116302: PUSH
116303: EMPTY
116304: LIST
116305: LIST
116306: LIST
116307: LIST
116308: LIST
116309: LIST
116310: LIST
116311: LIST
116312: LIST
116313: LIST
116314: LIST
116315: LIST
116316: LIST
116317: LIST
116318: LIST
116319: LIST
116320: LIST
116321: LIST
116322: LIST
116323: LIST
116324: LIST
116325: LIST
116326: LIST
116327: LIST
116328: LIST
116329: LIST
116330: LIST
116331: LIST
116332: LIST
116333: LIST
116334: LIST
116335: PUSH
116336: LD_INT 101
116338: PUSH
116339: LD_INT 102
116341: PUSH
116342: LD_INT 103
116344: PUSH
116345: LD_INT 104
116347: PUSH
116348: LD_INT 105
116350: PUSH
116351: LD_INT 106
116353: PUSH
116354: LD_INT 107
116356: PUSH
116357: LD_INT 108
116359: PUSH
116360: LD_INT 109
116362: PUSH
116363: LD_INT 110
116365: PUSH
116366: LD_INT 111
116368: PUSH
116369: LD_INT 112
116371: PUSH
116372: LD_INT 114
116374: PUSH
116375: LD_INT 116
116377: PUSH
116378: LD_INT 117
116380: PUSH
116381: LD_INT 118
116383: PUSH
116384: EMPTY
116385: LIST
116386: LIST
116387: LIST
116388: LIST
116389: LIST
116390: LIST
116391: LIST
116392: LIST
116393: LIST
116394: LIST
116395: LIST
116396: LIST
116397: LIST
116398: LIST
116399: LIST
116400: LIST
116401: PUSH
116402: EMPTY
116403: LIST
116404: LIST
116405: ST_TO_ADDR
116406: GO 118089
116408: LD_INT 12
116410: DOUBLE
116411: EQUAL
116412: IFTRUE 116416
116414: GO 116636
116416: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
116417: LD_ADDR_VAR 0 2
116421: PUSH
116422: LD_INT 1
116424: PUSH
116425: LD_INT 2
116427: PUSH
116428: LD_INT 3
116430: PUSH
116431: LD_INT 4
116433: PUSH
116434: LD_INT 5
116436: PUSH
116437: LD_INT 6
116439: PUSH
116440: LD_INT 7
116442: PUSH
116443: LD_INT 8
116445: PUSH
116446: LD_INT 9
116448: PUSH
116449: LD_INT 10
116451: PUSH
116452: LD_INT 11
116454: PUSH
116455: LD_INT 12
116457: PUSH
116458: LD_INT 13
116460: PUSH
116461: LD_INT 14
116463: PUSH
116464: LD_INT 15
116466: PUSH
116467: LD_INT 16
116469: PUSH
116470: LD_INT 17
116472: PUSH
116473: LD_INT 18
116475: PUSH
116476: LD_INT 19
116478: PUSH
116479: LD_INT 20
116481: PUSH
116482: LD_INT 21
116484: PUSH
116485: LD_INT 22
116487: PUSH
116488: LD_INT 23
116490: PUSH
116491: LD_INT 24
116493: PUSH
116494: LD_INT 25
116496: PUSH
116497: LD_INT 26
116499: PUSH
116500: LD_INT 27
116502: PUSH
116503: LD_INT 28
116505: PUSH
116506: LD_INT 30
116508: PUSH
116509: LD_INT 31
116511: PUSH
116512: LD_INT 32
116514: PUSH
116515: LD_INT 33
116517: PUSH
116518: LD_INT 34
116520: PUSH
116521: LD_INT 36
116523: PUSH
116524: EMPTY
116525: LIST
116526: LIST
116527: LIST
116528: LIST
116529: LIST
116530: LIST
116531: LIST
116532: LIST
116533: LIST
116534: LIST
116535: LIST
116536: LIST
116537: LIST
116538: LIST
116539: LIST
116540: LIST
116541: LIST
116542: LIST
116543: LIST
116544: LIST
116545: LIST
116546: LIST
116547: LIST
116548: LIST
116549: LIST
116550: LIST
116551: LIST
116552: LIST
116553: LIST
116554: LIST
116555: LIST
116556: LIST
116557: LIST
116558: LIST
116559: PUSH
116560: LD_INT 101
116562: PUSH
116563: LD_INT 102
116565: PUSH
116566: LD_INT 103
116568: PUSH
116569: LD_INT 104
116571: PUSH
116572: LD_INT 105
116574: PUSH
116575: LD_INT 106
116577: PUSH
116578: LD_INT 107
116580: PUSH
116581: LD_INT 108
116583: PUSH
116584: LD_INT 109
116586: PUSH
116587: LD_INT 110
116589: PUSH
116590: LD_INT 111
116592: PUSH
116593: LD_INT 112
116595: PUSH
116596: LD_INT 113
116598: PUSH
116599: LD_INT 114
116601: PUSH
116602: LD_INT 116
116604: PUSH
116605: LD_INT 117
116607: PUSH
116608: LD_INT 118
116610: PUSH
116611: EMPTY
116612: LIST
116613: LIST
116614: LIST
116615: LIST
116616: LIST
116617: LIST
116618: LIST
116619: LIST
116620: LIST
116621: LIST
116622: LIST
116623: LIST
116624: LIST
116625: LIST
116626: LIST
116627: LIST
116628: LIST
116629: PUSH
116630: EMPTY
116631: LIST
116632: LIST
116633: ST_TO_ADDR
116634: GO 118089
116636: LD_INT 13
116638: DOUBLE
116639: EQUAL
116640: IFTRUE 116644
116642: GO 116852
116644: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
116645: LD_ADDR_VAR 0 2
116649: PUSH
116650: LD_INT 1
116652: PUSH
116653: LD_INT 2
116655: PUSH
116656: LD_INT 3
116658: PUSH
116659: LD_INT 4
116661: PUSH
116662: LD_INT 5
116664: PUSH
116665: LD_INT 8
116667: PUSH
116668: LD_INT 9
116670: PUSH
116671: LD_INT 10
116673: PUSH
116674: LD_INT 11
116676: PUSH
116677: LD_INT 12
116679: PUSH
116680: LD_INT 14
116682: PUSH
116683: LD_INT 15
116685: PUSH
116686: LD_INT 16
116688: PUSH
116689: LD_INT 17
116691: PUSH
116692: LD_INT 18
116694: PUSH
116695: LD_INT 19
116697: PUSH
116698: LD_INT 20
116700: PUSH
116701: LD_INT 21
116703: PUSH
116704: LD_INT 22
116706: PUSH
116707: LD_INT 23
116709: PUSH
116710: LD_INT 24
116712: PUSH
116713: LD_INT 25
116715: PUSH
116716: LD_INT 26
116718: PUSH
116719: LD_INT 27
116721: PUSH
116722: LD_INT 28
116724: PUSH
116725: LD_INT 30
116727: PUSH
116728: LD_INT 31
116730: PUSH
116731: LD_INT 32
116733: PUSH
116734: LD_INT 33
116736: PUSH
116737: LD_INT 34
116739: PUSH
116740: LD_INT 36
116742: PUSH
116743: EMPTY
116744: LIST
116745: LIST
116746: LIST
116747: LIST
116748: LIST
116749: LIST
116750: LIST
116751: LIST
116752: LIST
116753: LIST
116754: LIST
116755: LIST
116756: LIST
116757: LIST
116758: LIST
116759: LIST
116760: LIST
116761: LIST
116762: LIST
116763: LIST
116764: LIST
116765: LIST
116766: LIST
116767: LIST
116768: LIST
116769: LIST
116770: LIST
116771: LIST
116772: LIST
116773: LIST
116774: LIST
116775: PUSH
116776: LD_INT 101
116778: PUSH
116779: LD_INT 102
116781: PUSH
116782: LD_INT 103
116784: PUSH
116785: LD_INT 104
116787: PUSH
116788: LD_INT 105
116790: PUSH
116791: LD_INT 106
116793: PUSH
116794: LD_INT 107
116796: PUSH
116797: LD_INT 108
116799: PUSH
116800: LD_INT 109
116802: PUSH
116803: LD_INT 110
116805: PUSH
116806: LD_INT 111
116808: PUSH
116809: LD_INT 112
116811: PUSH
116812: LD_INT 113
116814: PUSH
116815: LD_INT 114
116817: PUSH
116818: LD_INT 116
116820: PUSH
116821: LD_INT 117
116823: PUSH
116824: LD_INT 118
116826: PUSH
116827: EMPTY
116828: LIST
116829: LIST
116830: LIST
116831: LIST
116832: LIST
116833: LIST
116834: LIST
116835: LIST
116836: LIST
116837: LIST
116838: LIST
116839: LIST
116840: LIST
116841: LIST
116842: LIST
116843: LIST
116844: LIST
116845: PUSH
116846: EMPTY
116847: LIST
116848: LIST
116849: ST_TO_ADDR
116850: GO 118089
116852: LD_INT 14
116854: DOUBLE
116855: EQUAL
116856: IFTRUE 116860
116858: GO 117084
116860: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
116861: LD_ADDR_VAR 0 2
116865: PUSH
116866: LD_INT 1
116868: PUSH
116869: LD_INT 2
116871: PUSH
116872: LD_INT 3
116874: PUSH
116875: LD_INT 4
116877: PUSH
116878: LD_INT 5
116880: PUSH
116881: LD_INT 6
116883: PUSH
116884: LD_INT 7
116886: PUSH
116887: LD_INT 8
116889: PUSH
116890: LD_INT 9
116892: PUSH
116893: LD_INT 10
116895: PUSH
116896: LD_INT 11
116898: PUSH
116899: LD_INT 12
116901: PUSH
116902: LD_INT 13
116904: PUSH
116905: LD_INT 14
116907: PUSH
116908: LD_INT 15
116910: PUSH
116911: LD_INT 16
116913: PUSH
116914: LD_INT 17
116916: PUSH
116917: LD_INT 18
116919: PUSH
116920: LD_INT 19
116922: PUSH
116923: LD_INT 20
116925: PUSH
116926: LD_INT 21
116928: PUSH
116929: LD_INT 22
116931: PUSH
116932: LD_INT 23
116934: PUSH
116935: LD_INT 24
116937: PUSH
116938: LD_INT 25
116940: PUSH
116941: LD_INT 26
116943: PUSH
116944: LD_INT 27
116946: PUSH
116947: LD_INT 28
116949: PUSH
116950: LD_INT 29
116952: PUSH
116953: LD_INT 30
116955: PUSH
116956: LD_INT 31
116958: PUSH
116959: LD_INT 32
116961: PUSH
116962: LD_INT 33
116964: PUSH
116965: LD_INT 34
116967: PUSH
116968: LD_INT 36
116970: PUSH
116971: EMPTY
116972: LIST
116973: LIST
116974: LIST
116975: LIST
116976: LIST
116977: LIST
116978: LIST
116979: LIST
116980: LIST
116981: LIST
116982: LIST
116983: LIST
116984: LIST
116985: LIST
116986: LIST
116987: LIST
116988: LIST
116989: LIST
116990: LIST
116991: LIST
116992: LIST
116993: LIST
116994: LIST
116995: LIST
116996: LIST
116997: LIST
116998: LIST
116999: LIST
117000: LIST
117001: LIST
117002: LIST
117003: LIST
117004: LIST
117005: LIST
117006: LIST
117007: PUSH
117008: LD_INT 101
117010: PUSH
117011: LD_INT 102
117013: PUSH
117014: LD_INT 103
117016: PUSH
117017: LD_INT 104
117019: PUSH
117020: LD_INT 105
117022: PUSH
117023: LD_INT 106
117025: PUSH
117026: LD_INT 107
117028: PUSH
117029: LD_INT 108
117031: PUSH
117032: LD_INT 109
117034: PUSH
117035: LD_INT 110
117037: PUSH
117038: LD_INT 111
117040: PUSH
117041: LD_INT 112
117043: PUSH
117044: LD_INT 113
117046: PUSH
117047: LD_INT 114
117049: PUSH
117050: LD_INT 116
117052: PUSH
117053: LD_INT 117
117055: PUSH
117056: LD_INT 118
117058: PUSH
117059: EMPTY
117060: LIST
117061: LIST
117062: LIST
117063: LIST
117064: LIST
117065: LIST
117066: LIST
117067: LIST
117068: LIST
117069: LIST
117070: LIST
117071: LIST
117072: LIST
117073: LIST
117074: LIST
117075: LIST
117076: LIST
117077: PUSH
117078: EMPTY
117079: LIST
117080: LIST
117081: ST_TO_ADDR
117082: GO 118089
117084: LD_INT 15
117086: DOUBLE
117087: EQUAL
117088: IFTRUE 117092
117090: GO 117316
117092: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
117093: LD_ADDR_VAR 0 2
117097: PUSH
117098: LD_INT 1
117100: PUSH
117101: LD_INT 2
117103: PUSH
117104: LD_INT 3
117106: PUSH
117107: LD_INT 4
117109: PUSH
117110: LD_INT 5
117112: PUSH
117113: LD_INT 6
117115: PUSH
117116: LD_INT 7
117118: PUSH
117119: LD_INT 8
117121: PUSH
117122: LD_INT 9
117124: PUSH
117125: LD_INT 10
117127: PUSH
117128: LD_INT 11
117130: PUSH
117131: LD_INT 12
117133: PUSH
117134: LD_INT 13
117136: PUSH
117137: LD_INT 14
117139: PUSH
117140: LD_INT 15
117142: PUSH
117143: LD_INT 16
117145: PUSH
117146: LD_INT 17
117148: PUSH
117149: LD_INT 18
117151: PUSH
117152: LD_INT 19
117154: PUSH
117155: LD_INT 20
117157: PUSH
117158: LD_INT 21
117160: PUSH
117161: LD_INT 22
117163: PUSH
117164: LD_INT 23
117166: PUSH
117167: LD_INT 24
117169: PUSH
117170: LD_INT 25
117172: PUSH
117173: LD_INT 26
117175: PUSH
117176: LD_INT 27
117178: PUSH
117179: LD_INT 28
117181: PUSH
117182: LD_INT 29
117184: PUSH
117185: LD_INT 30
117187: PUSH
117188: LD_INT 31
117190: PUSH
117191: LD_INT 32
117193: PUSH
117194: LD_INT 33
117196: PUSH
117197: LD_INT 34
117199: PUSH
117200: LD_INT 36
117202: PUSH
117203: EMPTY
117204: LIST
117205: LIST
117206: LIST
117207: LIST
117208: LIST
117209: LIST
117210: LIST
117211: LIST
117212: LIST
117213: LIST
117214: LIST
117215: LIST
117216: LIST
117217: LIST
117218: LIST
117219: LIST
117220: LIST
117221: LIST
117222: LIST
117223: LIST
117224: LIST
117225: LIST
117226: LIST
117227: LIST
117228: LIST
117229: LIST
117230: LIST
117231: LIST
117232: LIST
117233: LIST
117234: LIST
117235: LIST
117236: LIST
117237: LIST
117238: LIST
117239: PUSH
117240: LD_INT 101
117242: PUSH
117243: LD_INT 102
117245: PUSH
117246: LD_INT 103
117248: PUSH
117249: LD_INT 104
117251: PUSH
117252: LD_INT 105
117254: PUSH
117255: LD_INT 106
117257: PUSH
117258: LD_INT 107
117260: PUSH
117261: LD_INT 108
117263: PUSH
117264: LD_INT 109
117266: PUSH
117267: LD_INT 110
117269: PUSH
117270: LD_INT 111
117272: PUSH
117273: LD_INT 112
117275: PUSH
117276: LD_INT 113
117278: PUSH
117279: LD_INT 114
117281: PUSH
117282: LD_INT 116
117284: PUSH
117285: LD_INT 117
117287: PUSH
117288: LD_INT 118
117290: PUSH
117291: EMPTY
117292: LIST
117293: LIST
117294: LIST
117295: LIST
117296: LIST
117297: LIST
117298: LIST
117299: LIST
117300: LIST
117301: LIST
117302: LIST
117303: LIST
117304: LIST
117305: LIST
117306: LIST
117307: LIST
117308: LIST
117309: PUSH
117310: EMPTY
117311: LIST
117312: LIST
117313: ST_TO_ADDR
117314: GO 118089
117316: LD_INT 16
117318: DOUBLE
117319: EQUAL
117320: IFTRUE 117324
117322: GO 117460
117324: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
117325: LD_ADDR_VAR 0 2
117329: PUSH
117330: LD_INT 2
117332: PUSH
117333: LD_INT 4
117335: PUSH
117336: LD_INT 5
117338: PUSH
117339: LD_INT 7
117341: PUSH
117342: LD_INT 11
117344: PUSH
117345: LD_INT 12
117347: PUSH
117348: LD_INT 15
117350: PUSH
117351: LD_INT 16
117353: PUSH
117354: LD_INT 20
117356: PUSH
117357: LD_INT 21
117359: PUSH
117360: LD_INT 22
117362: PUSH
117363: LD_INT 23
117365: PUSH
117366: LD_INT 25
117368: PUSH
117369: LD_INT 26
117371: PUSH
117372: LD_INT 30
117374: PUSH
117375: LD_INT 31
117377: PUSH
117378: LD_INT 32
117380: PUSH
117381: LD_INT 33
117383: PUSH
117384: LD_INT 34
117386: PUSH
117387: EMPTY
117388: LIST
117389: LIST
117390: LIST
117391: LIST
117392: LIST
117393: LIST
117394: LIST
117395: LIST
117396: LIST
117397: LIST
117398: LIST
117399: LIST
117400: LIST
117401: LIST
117402: LIST
117403: LIST
117404: LIST
117405: LIST
117406: LIST
117407: PUSH
117408: LD_INT 101
117410: PUSH
117411: LD_INT 102
117413: PUSH
117414: LD_INT 103
117416: PUSH
117417: LD_INT 106
117419: PUSH
117420: LD_INT 108
117422: PUSH
117423: LD_INT 112
117425: PUSH
117426: LD_INT 113
117428: PUSH
117429: LD_INT 114
117431: PUSH
117432: LD_INT 116
117434: PUSH
117435: LD_INT 117
117437: PUSH
117438: LD_INT 118
117440: PUSH
117441: EMPTY
117442: LIST
117443: LIST
117444: LIST
117445: LIST
117446: LIST
117447: LIST
117448: LIST
117449: LIST
117450: LIST
117451: LIST
117452: LIST
117453: PUSH
117454: EMPTY
117455: LIST
117456: LIST
117457: ST_TO_ADDR
117458: GO 118089
117460: LD_INT 17
117462: DOUBLE
117463: EQUAL
117464: IFTRUE 117468
117466: GO 117692
117468: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
117469: LD_ADDR_VAR 0 2
117473: PUSH
117474: LD_INT 1
117476: PUSH
117477: LD_INT 2
117479: PUSH
117480: LD_INT 3
117482: PUSH
117483: LD_INT 4
117485: PUSH
117486: LD_INT 5
117488: PUSH
117489: LD_INT 6
117491: PUSH
117492: LD_INT 7
117494: PUSH
117495: LD_INT 8
117497: PUSH
117498: LD_INT 9
117500: PUSH
117501: LD_INT 10
117503: PUSH
117504: LD_INT 11
117506: PUSH
117507: LD_INT 12
117509: PUSH
117510: LD_INT 13
117512: PUSH
117513: LD_INT 14
117515: PUSH
117516: LD_INT 15
117518: PUSH
117519: LD_INT 16
117521: PUSH
117522: LD_INT 17
117524: PUSH
117525: LD_INT 18
117527: PUSH
117528: LD_INT 19
117530: PUSH
117531: LD_INT 20
117533: PUSH
117534: LD_INT 21
117536: PUSH
117537: LD_INT 22
117539: PUSH
117540: LD_INT 23
117542: PUSH
117543: LD_INT 24
117545: PUSH
117546: LD_INT 25
117548: PUSH
117549: LD_INT 26
117551: PUSH
117552: LD_INT 27
117554: PUSH
117555: LD_INT 28
117557: PUSH
117558: LD_INT 29
117560: PUSH
117561: LD_INT 30
117563: PUSH
117564: LD_INT 31
117566: PUSH
117567: LD_INT 32
117569: PUSH
117570: LD_INT 33
117572: PUSH
117573: LD_INT 34
117575: PUSH
117576: LD_INT 36
117578: PUSH
117579: EMPTY
117580: LIST
117581: LIST
117582: LIST
117583: LIST
117584: LIST
117585: LIST
117586: LIST
117587: LIST
117588: LIST
117589: LIST
117590: LIST
117591: LIST
117592: LIST
117593: LIST
117594: LIST
117595: LIST
117596: LIST
117597: LIST
117598: LIST
117599: LIST
117600: LIST
117601: LIST
117602: LIST
117603: LIST
117604: LIST
117605: LIST
117606: LIST
117607: LIST
117608: LIST
117609: LIST
117610: LIST
117611: LIST
117612: LIST
117613: LIST
117614: LIST
117615: PUSH
117616: LD_INT 101
117618: PUSH
117619: LD_INT 102
117621: PUSH
117622: LD_INT 103
117624: PUSH
117625: LD_INT 104
117627: PUSH
117628: LD_INT 105
117630: PUSH
117631: LD_INT 106
117633: PUSH
117634: LD_INT 107
117636: PUSH
117637: LD_INT 108
117639: PUSH
117640: LD_INT 109
117642: PUSH
117643: LD_INT 110
117645: PUSH
117646: LD_INT 111
117648: PUSH
117649: LD_INT 112
117651: PUSH
117652: LD_INT 113
117654: PUSH
117655: LD_INT 114
117657: PUSH
117658: LD_INT 116
117660: PUSH
117661: LD_INT 117
117663: PUSH
117664: LD_INT 118
117666: PUSH
117667: EMPTY
117668: LIST
117669: LIST
117670: LIST
117671: LIST
117672: LIST
117673: LIST
117674: LIST
117675: LIST
117676: LIST
117677: LIST
117678: LIST
117679: LIST
117680: LIST
117681: LIST
117682: LIST
117683: LIST
117684: LIST
117685: PUSH
117686: EMPTY
117687: LIST
117688: LIST
117689: ST_TO_ADDR
117690: GO 118089
117692: LD_INT 18
117694: DOUBLE
117695: EQUAL
117696: IFTRUE 117700
117698: GO 117848
117700: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
117701: LD_ADDR_VAR 0 2
117705: PUSH
117706: LD_INT 2
117708: PUSH
117709: LD_INT 4
117711: PUSH
117712: LD_INT 5
117714: PUSH
117715: LD_INT 7
117717: PUSH
117718: LD_INT 11
117720: PUSH
117721: LD_INT 12
117723: PUSH
117724: LD_INT 15
117726: PUSH
117727: LD_INT 16
117729: PUSH
117730: LD_INT 20
117732: PUSH
117733: LD_INT 21
117735: PUSH
117736: LD_INT 22
117738: PUSH
117739: LD_INT 23
117741: PUSH
117742: LD_INT 25
117744: PUSH
117745: LD_INT 26
117747: PUSH
117748: LD_INT 30
117750: PUSH
117751: LD_INT 31
117753: PUSH
117754: LD_INT 32
117756: PUSH
117757: LD_INT 33
117759: PUSH
117760: LD_INT 34
117762: PUSH
117763: LD_INT 35
117765: PUSH
117766: LD_INT 36
117768: PUSH
117769: EMPTY
117770: LIST
117771: LIST
117772: LIST
117773: LIST
117774: LIST
117775: LIST
117776: LIST
117777: LIST
117778: LIST
117779: LIST
117780: LIST
117781: LIST
117782: LIST
117783: LIST
117784: LIST
117785: LIST
117786: LIST
117787: LIST
117788: LIST
117789: LIST
117790: LIST
117791: PUSH
117792: LD_INT 101
117794: PUSH
117795: LD_INT 102
117797: PUSH
117798: LD_INT 103
117800: PUSH
117801: LD_INT 106
117803: PUSH
117804: LD_INT 108
117806: PUSH
117807: LD_INT 112
117809: PUSH
117810: LD_INT 113
117812: PUSH
117813: LD_INT 114
117815: PUSH
117816: LD_INT 115
117818: PUSH
117819: LD_INT 116
117821: PUSH
117822: LD_INT 117
117824: PUSH
117825: LD_INT 118
117827: PUSH
117828: EMPTY
117829: LIST
117830: LIST
117831: LIST
117832: LIST
117833: LIST
117834: LIST
117835: LIST
117836: LIST
117837: LIST
117838: LIST
117839: LIST
117840: LIST
117841: PUSH
117842: EMPTY
117843: LIST
117844: LIST
117845: ST_TO_ADDR
117846: GO 118089
117848: LD_INT 19
117850: DOUBLE
117851: EQUAL
117852: IFTRUE 117856
117854: GO 118088
117856: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
117857: LD_ADDR_VAR 0 2
117861: PUSH
117862: LD_INT 1
117864: PUSH
117865: LD_INT 2
117867: PUSH
117868: LD_INT 3
117870: PUSH
117871: LD_INT 4
117873: PUSH
117874: LD_INT 5
117876: PUSH
117877: LD_INT 6
117879: PUSH
117880: LD_INT 7
117882: PUSH
117883: LD_INT 8
117885: PUSH
117886: LD_INT 9
117888: PUSH
117889: LD_INT 10
117891: PUSH
117892: LD_INT 11
117894: PUSH
117895: LD_INT 12
117897: PUSH
117898: LD_INT 13
117900: PUSH
117901: LD_INT 14
117903: PUSH
117904: LD_INT 15
117906: PUSH
117907: LD_INT 16
117909: PUSH
117910: LD_INT 17
117912: PUSH
117913: LD_INT 18
117915: PUSH
117916: LD_INT 19
117918: PUSH
117919: LD_INT 20
117921: PUSH
117922: LD_INT 21
117924: PUSH
117925: LD_INT 22
117927: PUSH
117928: LD_INT 23
117930: PUSH
117931: LD_INT 24
117933: PUSH
117934: LD_INT 25
117936: PUSH
117937: LD_INT 26
117939: PUSH
117940: LD_INT 27
117942: PUSH
117943: LD_INT 28
117945: PUSH
117946: LD_INT 29
117948: PUSH
117949: LD_INT 30
117951: PUSH
117952: LD_INT 31
117954: PUSH
117955: LD_INT 32
117957: PUSH
117958: LD_INT 33
117960: PUSH
117961: LD_INT 34
117963: PUSH
117964: LD_INT 35
117966: PUSH
117967: LD_INT 36
117969: PUSH
117970: EMPTY
117971: LIST
117972: LIST
117973: LIST
117974: LIST
117975: LIST
117976: LIST
117977: LIST
117978: LIST
117979: LIST
117980: LIST
117981: LIST
117982: LIST
117983: LIST
117984: LIST
117985: LIST
117986: LIST
117987: LIST
117988: LIST
117989: LIST
117990: LIST
117991: LIST
117992: LIST
117993: LIST
117994: LIST
117995: LIST
117996: LIST
117997: LIST
117998: LIST
117999: LIST
118000: LIST
118001: LIST
118002: LIST
118003: LIST
118004: LIST
118005: LIST
118006: LIST
118007: PUSH
118008: LD_INT 101
118010: PUSH
118011: LD_INT 102
118013: PUSH
118014: LD_INT 103
118016: PUSH
118017: LD_INT 104
118019: PUSH
118020: LD_INT 105
118022: PUSH
118023: LD_INT 106
118025: PUSH
118026: LD_INT 107
118028: PUSH
118029: LD_INT 108
118031: PUSH
118032: LD_INT 109
118034: PUSH
118035: LD_INT 110
118037: PUSH
118038: LD_INT 111
118040: PUSH
118041: LD_INT 112
118043: PUSH
118044: LD_INT 113
118046: PUSH
118047: LD_INT 114
118049: PUSH
118050: LD_INT 115
118052: PUSH
118053: LD_INT 116
118055: PUSH
118056: LD_INT 117
118058: PUSH
118059: LD_INT 118
118061: PUSH
118062: EMPTY
118063: LIST
118064: LIST
118065: LIST
118066: LIST
118067: LIST
118068: LIST
118069: LIST
118070: LIST
118071: LIST
118072: LIST
118073: LIST
118074: LIST
118075: LIST
118076: LIST
118077: LIST
118078: LIST
118079: LIST
118080: LIST
118081: PUSH
118082: EMPTY
118083: LIST
118084: LIST
118085: ST_TO_ADDR
118086: GO 118089
118088: POP
// end else
118089: GO 118320
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
118091: LD_ADDR_VAR 0 2
118095: PUSH
118096: LD_INT 1
118098: PUSH
118099: LD_INT 2
118101: PUSH
118102: LD_INT 3
118104: PUSH
118105: LD_INT 4
118107: PUSH
118108: LD_INT 5
118110: PUSH
118111: LD_INT 6
118113: PUSH
118114: LD_INT 7
118116: PUSH
118117: LD_INT 8
118119: PUSH
118120: LD_INT 9
118122: PUSH
118123: LD_INT 10
118125: PUSH
118126: LD_INT 11
118128: PUSH
118129: LD_INT 12
118131: PUSH
118132: LD_INT 13
118134: PUSH
118135: LD_INT 14
118137: PUSH
118138: LD_INT 15
118140: PUSH
118141: LD_INT 16
118143: PUSH
118144: LD_INT 17
118146: PUSH
118147: LD_INT 18
118149: PUSH
118150: LD_INT 19
118152: PUSH
118153: LD_INT 20
118155: PUSH
118156: LD_INT 21
118158: PUSH
118159: LD_INT 22
118161: PUSH
118162: LD_INT 23
118164: PUSH
118165: LD_INT 24
118167: PUSH
118168: LD_INT 25
118170: PUSH
118171: LD_INT 26
118173: PUSH
118174: LD_INT 27
118176: PUSH
118177: LD_INT 28
118179: PUSH
118180: LD_INT 29
118182: PUSH
118183: LD_INT 30
118185: PUSH
118186: LD_INT 31
118188: PUSH
118189: LD_INT 32
118191: PUSH
118192: LD_INT 33
118194: PUSH
118195: LD_INT 34
118197: PUSH
118198: LD_INT 35
118200: PUSH
118201: LD_INT 36
118203: PUSH
118204: EMPTY
118205: LIST
118206: LIST
118207: LIST
118208: LIST
118209: LIST
118210: LIST
118211: LIST
118212: LIST
118213: LIST
118214: LIST
118215: LIST
118216: LIST
118217: LIST
118218: LIST
118219: LIST
118220: LIST
118221: LIST
118222: LIST
118223: LIST
118224: LIST
118225: LIST
118226: LIST
118227: LIST
118228: LIST
118229: LIST
118230: LIST
118231: LIST
118232: LIST
118233: LIST
118234: LIST
118235: LIST
118236: LIST
118237: LIST
118238: LIST
118239: LIST
118240: LIST
118241: PUSH
118242: LD_INT 101
118244: PUSH
118245: LD_INT 102
118247: PUSH
118248: LD_INT 103
118250: PUSH
118251: LD_INT 104
118253: PUSH
118254: LD_INT 105
118256: PUSH
118257: LD_INT 106
118259: PUSH
118260: LD_INT 107
118262: PUSH
118263: LD_INT 108
118265: PUSH
118266: LD_INT 109
118268: PUSH
118269: LD_INT 110
118271: PUSH
118272: LD_INT 111
118274: PUSH
118275: LD_INT 112
118277: PUSH
118278: LD_INT 113
118280: PUSH
118281: LD_INT 114
118283: PUSH
118284: LD_INT 115
118286: PUSH
118287: LD_INT 116
118289: PUSH
118290: LD_INT 117
118292: PUSH
118293: LD_INT 118
118295: PUSH
118296: EMPTY
118297: LIST
118298: LIST
118299: LIST
118300: LIST
118301: LIST
118302: LIST
118303: LIST
118304: LIST
118305: LIST
118306: LIST
118307: LIST
118308: LIST
118309: LIST
118310: LIST
118311: LIST
118312: LIST
118313: LIST
118314: LIST
118315: PUSH
118316: EMPTY
118317: LIST
118318: LIST
118319: ST_TO_ADDR
// if result then
118320: LD_VAR 0 2
118324: IFFALSE 119110
// begin normal :=  ;
118326: LD_ADDR_VAR 0 5
118330: PUSH
118331: LD_STRING 
118333: ST_TO_ADDR
// hardcore :=  ;
118334: LD_ADDR_VAR 0 6
118338: PUSH
118339: LD_STRING 
118341: ST_TO_ADDR
// active :=  ;
118342: LD_ADDR_VAR 0 7
118346: PUSH
118347: LD_STRING 
118349: ST_TO_ADDR
// for i = 1 to normalCounter do
118350: LD_ADDR_VAR 0 8
118354: PUSH
118355: DOUBLE
118356: LD_INT 1
118358: DEC
118359: ST_TO_ADDR
118360: LD_EXP 149
118364: PUSH
118365: FOR_TO
118366: IFFALSE 118467
// begin tmp := 0 ;
118368: LD_ADDR_VAR 0 3
118372: PUSH
118373: LD_STRING 0
118375: ST_TO_ADDR
// if result [ 1 ] then
118376: LD_VAR 0 2
118380: PUSH
118381: LD_INT 1
118383: ARRAY
118384: IFFALSE 118449
// if result [ 1 ] [ 1 ] = i then
118386: LD_VAR 0 2
118390: PUSH
118391: LD_INT 1
118393: ARRAY
118394: PUSH
118395: LD_INT 1
118397: ARRAY
118398: PUSH
118399: LD_VAR 0 8
118403: EQUAL
118404: IFFALSE 118449
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
118406: LD_ADDR_VAR 0 2
118410: PUSH
118411: LD_VAR 0 2
118415: PPUSH
118416: LD_INT 1
118418: PPUSH
118419: LD_VAR 0 2
118423: PUSH
118424: LD_INT 1
118426: ARRAY
118427: PPUSH
118428: LD_INT 1
118430: PPUSH
118431: CALL_OW 3
118435: PPUSH
118436: CALL_OW 1
118440: ST_TO_ADDR
// tmp := 1 ;
118441: LD_ADDR_VAR 0 3
118445: PUSH
118446: LD_STRING 1
118448: ST_TO_ADDR
// end ; normal := normal & tmp ;
118449: LD_ADDR_VAR 0 5
118453: PUSH
118454: LD_VAR 0 5
118458: PUSH
118459: LD_VAR 0 3
118463: STR
118464: ST_TO_ADDR
// end ;
118465: GO 118365
118467: POP
118468: POP
// for i = 1 to hardcoreCounter do
118469: LD_ADDR_VAR 0 8
118473: PUSH
118474: DOUBLE
118475: LD_INT 1
118477: DEC
118478: ST_TO_ADDR
118479: LD_EXP 150
118483: PUSH
118484: FOR_TO
118485: IFFALSE 118590
// begin tmp := 0 ;
118487: LD_ADDR_VAR 0 3
118491: PUSH
118492: LD_STRING 0
118494: ST_TO_ADDR
// if result [ 2 ] then
118495: LD_VAR 0 2
118499: PUSH
118500: LD_INT 2
118502: ARRAY
118503: IFFALSE 118572
// if result [ 2 ] [ 1 ] = 100 + i then
118505: LD_VAR 0 2
118509: PUSH
118510: LD_INT 2
118512: ARRAY
118513: PUSH
118514: LD_INT 1
118516: ARRAY
118517: PUSH
118518: LD_INT 100
118520: PUSH
118521: LD_VAR 0 8
118525: PLUS
118526: EQUAL
118527: IFFALSE 118572
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
118529: LD_ADDR_VAR 0 2
118533: PUSH
118534: LD_VAR 0 2
118538: PPUSH
118539: LD_INT 2
118541: PPUSH
118542: LD_VAR 0 2
118546: PUSH
118547: LD_INT 2
118549: ARRAY
118550: PPUSH
118551: LD_INT 1
118553: PPUSH
118554: CALL_OW 3
118558: PPUSH
118559: CALL_OW 1
118563: ST_TO_ADDR
// tmp := 1 ;
118564: LD_ADDR_VAR 0 3
118568: PUSH
118569: LD_STRING 1
118571: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
118572: LD_ADDR_VAR 0 6
118576: PUSH
118577: LD_VAR 0 6
118581: PUSH
118582: LD_VAR 0 3
118586: STR
118587: ST_TO_ADDR
// end ;
118588: GO 118484
118590: POP
118591: POP
// if isGameLoad then
118592: LD_VAR 0 1
118596: IFFALSE 119071
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
118598: LD_ADDR_VAR 0 4
118602: PUSH
118603: LD_EXP 153
118607: PUSH
118608: LD_EXP 152
118612: PUSH
118613: LD_EXP 154
118617: PUSH
118618: LD_EXP 151
118622: PUSH
118623: LD_EXP 155
118627: PUSH
118628: LD_EXP 156
118632: PUSH
118633: LD_EXP 157
118637: PUSH
118638: LD_EXP 158
118642: PUSH
118643: LD_EXP 159
118647: PUSH
118648: LD_EXP 160
118652: PUSH
118653: LD_EXP 161
118657: PUSH
118658: LD_EXP 162
118662: PUSH
118663: LD_EXP 163
118667: PUSH
118668: LD_EXP 164
118672: PUSH
118673: LD_EXP 172
118677: PUSH
118678: LD_EXP 173
118682: PUSH
118683: LD_EXP 174
118687: PUSH
118688: LD_EXP 175
118692: PUSH
118693: LD_EXP 177
118697: PUSH
118698: LD_EXP 178
118702: PUSH
118703: LD_EXP 179
118707: PUSH
118708: LD_EXP 182
118712: PUSH
118713: LD_EXP 184
118717: PUSH
118718: LD_EXP 185
118722: PUSH
118723: LD_EXP 186
118727: PUSH
118728: LD_EXP 188
118732: PUSH
118733: LD_EXP 189
118737: PUSH
118738: LD_EXP 192
118742: PUSH
118743: LD_EXP 193
118747: PUSH
118748: LD_EXP 194
118752: PUSH
118753: LD_EXP 195
118757: PUSH
118758: LD_EXP 196
118762: PUSH
118763: LD_EXP 197
118767: PUSH
118768: LD_EXP 198
118772: PUSH
118773: LD_EXP 199
118777: PUSH
118778: LD_EXP 200
118782: PUSH
118783: LD_EXP 165
118787: PUSH
118788: LD_EXP 166
118792: PUSH
118793: LD_EXP 169
118797: PUSH
118798: LD_EXP 170
118802: PUSH
118803: LD_EXP 171
118807: PUSH
118808: LD_EXP 167
118812: PUSH
118813: LD_EXP 168
118817: PUSH
118818: LD_EXP 176
118822: PUSH
118823: LD_EXP 180
118827: PUSH
118828: LD_EXP 181
118832: PUSH
118833: LD_EXP 183
118837: PUSH
118838: LD_EXP 187
118842: PUSH
118843: LD_EXP 190
118847: PUSH
118848: LD_EXP 191
118852: PUSH
118853: LD_EXP 201
118857: PUSH
118858: LD_EXP 202
118862: PUSH
118863: LD_EXP 203
118867: PUSH
118868: LD_EXP 204
118872: PUSH
118873: EMPTY
118874: LIST
118875: LIST
118876: LIST
118877: LIST
118878: LIST
118879: LIST
118880: LIST
118881: LIST
118882: LIST
118883: LIST
118884: LIST
118885: LIST
118886: LIST
118887: LIST
118888: LIST
118889: LIST
118890: LIST
118891: LIST
118892: LIST
118893: LIST
118894: LIST
118895: LIST
118896: LIST
118897: LIST
118898: LIST
118899: LIST
118900: LIST
118901: LIST
118902: LIST
118903: LIST
118904: LIST
118905: LIST
118906: LIST
118907: LIST
118908: LIST
118909: LIST
118910: LIST
118911: LIST
118912: LIST
118913: LIST
118914: LIST
118915: LIST
118916: LIST
118917: LIST
118918: LIST
118919: LIST
118920: LIST
118921: LIST
118922: LIST
118923: LIST
118924: LIST
118925: LIST
118926: LIST
118927: LIST
118928: ST_TO_ADDR
// tmp :=  ;
118929: LD_ADDR_VAR 0 3
118933: PUSH
118934: LD_STRING 
118936: ST_TO_ADDR
// for i = 1 to normalCounter do
118937: LD_ADDR_VAR 0 8
118941: PUSH
118942: DOUBLE
118943: LD_INT 1
118945: DEC
118946: ST_TO_ADDR
118947: LD_EXP 149
118951: PUSH
118952: FOR_TO
118953: IFFALSE 118989
// begin if flags [ i ] then
118955: LD_VAR 0 4
118959: PUSH
118960: LD_VAR 0 8
118964: ARRAY
118965: IFFALSE 118987
// tmp := tmp & i & ; ;
118967: LD_ADDR_VAR 0 3
118971: PUSH
118972: LD_VAR 0 3
118976: PUSH
118977: LD_VAR 0 8
118981: STR
118982: PUSH
118983: LD_STRING ;
118985: STR
118986: ST_TO_ADDR
// end ;
118987: GO 118952
118989: POP
118990: POP
// for i = 1 to hardcoreCounter do
118991: LD_ADDR_VAR 0 8
118995: PUSH
118996: DOUBLE
118997: LD_INT 1
118999: DEC
119000: ST_TO_ADDR
119001: LD_EXP 150
119005: PUSH
119006: FOR_TO
119007: IFFALSE 119053
// begin if flags [ normalCounter + i ] then
119009: LD_VAR 0 4
119013: PUSH
119014: LD_EXP 149
119018: PUSH
119019: LD_VAR 0 8
119023: PLUS
119024: ARRAY
119025: IFFALSE 119051
// tmp := tmp & ( 100 + i ) & ; ;
119027: LD_ADDR_VAR 0 3
119031: PUSH
119032: LD_VAR 0 3
119036: PUSH
119037: LD_INT 100
119039: PUSH
119040: LD_VAR 0 8
119044: PLUS
119045: STR
119046: PUSH
119047: LD_STRING ;
119049: STR
119050: ST_TO_ADDR
// end ;
119051: GO 119006
119053: POP
119054: POP
// if tmp then
119055: LD_VAR 0 3
119059: IFFALSE 119071
// active := tmp ;
119061: LD_ADDR_VAR 0 7
119065: PUSH
119066: LD_VAR 0 3
119070: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
119071: LD_STRING getStreamItemsFromMission("
119073: PUSH
119074: LD_VAR 0 5
119078: STR
119079: PUSH
119080: LD_STRING ","
119082: STR
119083: PUSH
119084: LD_VAR 0 6
119088: STR
119089: PUSH
119090: LD_STRING ","
119092: STR
119093: PUSH
119094: LD_VAR 0 7
119098: STR
119099: PUSH
119100: LD_STRING ")
119102: STR
119103: PPUSH
119104: CALL_OW 559
// end else
119108: GO 119117
// ToLua ( getStreamItemsFromMission("","","") ) ;
119110: LD_STRING getStreamItemsFromMission("","","")
119112: PPUSH
119113: CALL_OW 559
// end ;
119117: LD_VAR 0 2
119121: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
119122: LD_EXP 148
119126: PUSH
119127: LD_EXP 153
119131: AND
119132: IFFALSE 119256
119134: GO 119136
119136: DISABLE
119137: LD_INT 0
119139: PPUSH
119140: PPUSH
// begin enable ;
119141: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
119142: LD_ADDR_VAR 0 2
119146: PUSH
119147: LD_INT 22
119149: PUSH
119150: LD_OWVAR 2
119154: PUSH
119155: EMPTY
119156: LIST
119157: LIST
119158: PUSH
119159: LD_INT 2
119161: PUSH
119162: LD_INT 34
119164: PUSH
119165: LD_INT 7
119167: PUSH
119168: EMPTY
119169: LIST
119170: LIST
119171: PUSH
119172: LD_INT 34
119174: PUSH
119175: LD_INT 45
119177: PUSH
119178: EMPTY
119179: LIST
119180: LIST
119181: PUSH
119182: LD_INT 34
119184: PUSH
119185: LD_INT 28
119187: PUSH
119188: EMPTY
119189: LIST
119190: LIST
119191: PUSH
119192: LD_INT 34
119194: PUSH
119195: LD_INT 47
119197: PUSH
119198: EMPTY
119199: LIST
119200: LIST
119201: PUSH
119202: EMPTY
119203: LIST
119204: LIST
119205: LIST
119206: LIST
119207: LIST
119208: PUSH
119209: EMPTY
119210: LIST
119211: LIST
119212: PPUSH
119213: CALL_OW 69
119217: ST_TO_ADDR
// if not tmp then
119218: LD_VAR 0 2
119222: NOT
119223: IFFALSE 119227
// exit ;
119225: GO 119256
// for i in tmp do
119227: LD_ADDR_VAR 0 1
119231: PUSH
119232: LD_VAR 0 2
119236: PUSH
119237: FOR_IN
119238: IFFALSE 119254
// begin SetLives ( i , 0 ) ;
119240: LD_VAR 0 1
119244: PPUSH
119245: LD_INT 0
119247: PPUSH
119248: CALL_OW 234
// end ;
119252: GO 119237
119254: POP
119255: POP
// end ;
119256: PPOPN 2
119258: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
119259: LD_EXP 148
119263: PUSH
119264: LD_EXP 154
119268: AND
119269: IFFALSE 119353
119271: GO 119273
119273: DISABLE
119274: LD_INT 0
119276: PPUSH
119277: PPUSH
// begin enable ;
119278: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
119279: LD_ADDR_VAR 0 2
119283: PUSH
119284: LD_INT 22
119286: PUSH
119287: LD_OWVAR 2
119291: PUSH
119292: EMPTY
119293: LIST
119294: LIST
119295: PUSH
119296: LD_INT 32
119298: PUSH
119299: LD_INT 3
119301: PUSH
119302: EMPTY
119303: LIST
119304: LIST
119305: PUSH
119306: EMPTY
119307: LIST
119308: LIST
119309: PPUSH
119310: CALL_OW 69
119314: ST_TO_ADDR
// if not tmp then
119315: LD_VAR 0 2
119319: NOT
119320: IFFALSE 119324
// exit ;
119322: GO 119353
// for i in tmp do
119324: LD_ADDR_VAR 0 1
119328: PUSH
119329: LD_VAR 0 2
119333: PUSH
119334: FOR_IN
119335: IFFALSE 119351
// begin SetLives ( i , 0 ) ;
119337: LD_VAR 0 1
119341: PPUSH
119342: LD_INT 0
119344: PPUSH
119345: CALL_OW 234
// end ;
119349: GO 119334
119351: POP
119352: POP
// end ;
119353: PPOPN 2
119355: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
119356: LD_EXP 148
119360: PUSH
119361: LD_EXP 151
119365: AND
119366: IFFALSE 119459
119368: GO 119370
119370: DISABLE
119371: LD_INT 0
119373: PPUSH
// begin enable ;
119374: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
119375: LD_ADDR_VAR 0 1
119379: PUSH
119380: LD_INT 22
119382: PUSH
119383: LD_OWVAR 2
119387: PUSH
119388: EMPTY
119389: LIST
119390: LIST
119391: PUSH
119392: LD_INT 2
119394: PUSH
119395: LD_INT 25
119397: PUSH
119398: LD_INT 5
119400: PUSH
119401: EMPTY
119402: LIST
119403: LIST
119404: PUSH
119405: LD_INT 25
119407: PUSH
119408: LD_INT 9
119410: PUSH
119411: EMPTY
119412: LIST
119413: LIST
119414: PUSH
119415: LD_INT 25
119417: PUSH
119418: LD_INT 8
119420: PUSH
119421: EMPTY
119422: LIST
119423: LIST
119424: PUSH
119425: EMPTY
119426: LIST
119427: LIST
119428: LIST
119429: LIST
119430: PUSH
119431: EMPTY
119432: LIST
119433: LIST
119434: PPUSH
119435: CALL_OW 69
119439: PUSH
119440: FOR_IN
119441: IFFALSE 119457
// begin SetClass ( i , 1 ) ;
119443: LD_VAR 0 1
119447: PPUSH
119448: LD_INT 1
119450: PPUSH
119451: CALL_OW 336
// end ;
119455: GO 119440
119457: POP
119458: POP
// end ;
119459: PPOPN 1
119461: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
119462: LD_EXP 148
119466: PUSH
119467: LD_EXP 152
119471: AND
119472: PUSH
119473: LD_OWVAR 65
119477: PUSH
119478: LD_INT 7
119480: LESS
119481: AND
119482: IFFALSE 119496
119484: GO 119486
119486: DISABLE
// begin enable ;
119487: ENABLE
// game_speed := 7 ;
119488: LD_ADDR_OWVAR 65
119492: PUSH
119493: LD_INT 7
119495: ST_TO_ADDR
// end ;
119496: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
119497: LD_EXP 148
119501: PUSH
119502: LD_EXP 155
119506: AND
119507: IFFALSE 119709
119509: GO 119511
119511: DISABLE
119512: LD_INT 0
119514: PPUSH
119515: PPUSH
119516: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
119517: LD_ADDR_VAR 0 3
119521: PUSH
119522: LD_INT 81
119524: PUSH
119525: LD_OWVAR 2
119529: PUSH
119530: EMPTY
119531: LIST
119532: LIST
119533: PUSH
119534: LD_INT 21
119536: PUSH
119537: LD_INT 1
119539: PUSH
119540: EMPTY
119541: LIST
119542: LIST
119543: PUSH
119544: EMPTY
119545: LIST
119546: LIST
119547: PPUSH
119548: CALL_OW 69
119552: ST_TO_ADDR
// if not tmp then
119553: LD_VAR 0 3
119557: NOT
119558: IFFALSE 119562
// exit ;
119560: GO 119709
// if tmp > 5 then
119562: LD_VAR 0 3
119566: PUSH
119567: LD_INT 5
119569: GREATER
119570: IFFALSE 119582
// k := 5 else
119572: LD_ADDR_VAR 0 2
119576: PUSH
119577: LD_INT 5
119579: ST_TO_ADDR
119580: GO 119592
// k := tmp ;
119582: LD_ADDR_VAR 0 2
119586: PUSH
119587: LD_VAR 0 3
119591: ST_TO_ADDR
// for i := 1 to k do
119592: LD_ADDR_VAR 0 1
119596: PUSH
119597: DOUBLE
119598: LD_INT 1
119600: DEC
119601: ST_TO_ADDR
119602: LD_VAR 0 2
119606: PUSH
119607: FOR_TO
119608: IFFALSE 119707
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
119610: LD_VAR 0 3
119614: PUSH
119615: LD_VAR 0 1
119619: ARRAY
119620: PPUSH
119621: LD_VAR 0 1
119625: PUSH
119626: LD_INT 4
119628: MOD
119629: PUSH
119630: LD_INT 1
119632: PLUS
119633: PPUSH
119634: CALL_OW 259
119638: PUSH
119639: LD_INT 10
119641: LESS
119642: IFFALSE 119705
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
119644: LD_VAR 0 3
119648: PUSH
119649: LD_VAR 0 1
119653: ARRAY
119654: PPUSH
119655: LD_VAR 0 1
119659: PUSH
119660: LD_INT 4
119662: MOD
119663: PUSH
119664: LD_INT 1
119666: PLUS
119667: PPUSH
119668: LD_VAR 0 3
119672: PUSH
119673: LD_VAR 0 1
119677: ARRAY
119678: PPUSH
119679: LD_VAR 0 1
119683: PUSH
119684: LD_INT 4
119686: MOD
119687: PUSH
119688: LD_INT 1
119690: PLUS
119691: PPUSH
119692: CALL_OW 259
119696: PUSH
119697: LD_INT 1
119699: PLUS
119700: PPUSH
119701: CALL_OW 237
119705: GO 119607
119707: POP
119708: POP
// end ;
119709: PPOPN 3
119711: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
119712: LD_EXP 148
119716: PUSH
119717: LD_EXP 156
119721: AND
119722: IFFALSE 119742
119724: GO 119726
119726: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
119727: LD_INT 4
119729: PPUSH
119730: LD_OWVAR 2
119734: PPUSH
119735: LD_INT 0
119737: PPUSH
119738: CALL_OW 324
119742: END
// every 0 0$1 trigger StreamModeActive and sShovel do
119743: LD_EXP 148
119747: PUSH
119748: LD_EXP 185
119752: AND
119753: IFFALSE 119773
119755: GO 119757
119757: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
119758: LD_INT 19
119760: PPUSH
119761: LD_OWVAR 2
119765: PPUSH
119766: LD_INT 0
119768: PPUSH
119769: CALL_OW 324
119773: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
119774: LD_EXP 148
119778: PUSH
119779: LD_EXP 157
119783: AND
119784: IFFALSE 119886
119786: GO 119788
119788: DISABLE
119789: LD_INT 0
119791: PPUSH
119792: PPUSH
// begin enable ;
119793: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
119794: LD_ADDR_VAR 0 2
119798: PUSH
119799: LD_INT 22
119801: PUSH
119802: LD_OWVAR 2
119806: PUSH
119807: EMPTY
119808: LIST
119809: LIST
119810: PUSH
119811: LD_INT 2
119813: PUSH
119814: LD_INT 34
119816: PUSH
119817: LD_INT 11
119819: PUSH
119820: EMPTY
119821: LIST
119822: LIST
119823: PUSH
119824: LD_INT 34
119826: PUSH
119827: LD_INT 30
119829: PUSH
119830: EMPTY
119831: LIST
119832: LIST
119833: PUSH
119834: EMPTY
119835: LIST
119836: LIST
119837: LIST
119838: PUSH
119839: EMPTY
119840: LIST
119841: LIST
119842: PPUSH
119843: CALL_OW 69
119847: ST_TO_ADDR
// if not tmp then
119848: LD_VAR 0 2
119852: NOT
119853: IFFALSE 119857
// exit ;
119855: GO 119886
// for i in tmp do
119857: LD_ADDR_VAR 0 1
119861: PUSH
119862: LD_VAR 0 2
119866: PUSH
119867: FOR_IN
119868: IFFALSE 119884
// begin SetLives ( i , 0 ) ;
119870: LD_VAR 0 1
119874: PPUSH
119875: LD_INT 0
119877: PPUSH
119878: CALL_OW 234
// end ;
119882: GO 119867
119884: POP
119885: POP
// end ;
119886: PPOPN 2
119888: END
// every 0 0$1 trigger StreamModeActive and sBunker do
119889: LD_EXP 148
119893: PUSH
119894: LD_EXP 158
119898: AND
119899: IFFALSE 119919
119901: GO 119903
119903: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
119904: LD_INT 32
119906: PPUSH
119907: LD_OWVAR 2
119911: PPUSH
119912: LD_INT 0
119914: PPUSH
119915: CALL_OW 324
119919: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
119920: LD_EXP 148
119924: PUSH
119925: LD_EXP 159
119929: AND
119930: IFFALSE 120111
119932: GO 119934
119934: DISABLE
119935: LD_INT 0
119937: PPUSH
119938: PPUSH
119939: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
119940: LD_ADDR_VAR 0 2
119944: PUSH
119945: LD_INT 22
119947: PUSH
119948: LD_OWVAR 2
119952: PUSH
119953: EMPTY
119954: LIST
119955: LIST
119956: PUSH
119957: LD_INT 33
119959: PUSH
119960: LD_INT 3
119962: PUSH
119963: EMPTY
119964: LIST
119965: LIST
119966: PUSH
119967: EMPTY
119968: LIST
119969: LIST
119970: PPUSH
119971: CALL_OW 69
119975: ST_TO_ADDR
// if not tmp then
119976: LD_VAR 0 2
119980: NOT
119981: IFFALSE 119985
// exit ;
119983: GO 120111
// side := 0 ;
119985: LD_ADDR_VAR 0 3
119989: PUSH
119990: LD_INT 0
119992: ST_TO_ADDR
// for i := 1 to 8 do
119993: LD_ADDR_VAR 0 1
119997: PUSH
119998: DOUBLE
119999: LD_INT 1
120001: DEC
120002: ST_TO_ADDR
120003: LD_INT 8
120005: PUSH
120006: FOR_TO
120007: IFFALSE 120055
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
120009: LD_OWVAR 2
120013: PUSH
120014: LD_VAR 0 1
120018: NONEQUAL
120019: PUSH
120020: LD_OWVAR 2
120024: PPUSH
120025: LD_VAR 0 1
120029: PPUSH
120030: CALL_OW 81
120034: PUSH
120035: LD_INT 2
120037: EQUAL
120038: AND
120039: IFFALSE 120053
// begin side := i ;
120041: LD_ADDR_VAR 0 3
120045: PUSH
120046: LD_VAR 0 1
120050: ST_TO_ADDR
// break ;
120051: GO 120055
// end ;
120053: GO 120006
120055: POP
120056: POP
// if not side then
120057: LD_VAR 0 3
120061: NOT
120062: IFFALSE 120066
// exit ;
120064: GO 120111
// for i := 1 to tmp do
120066: LD_ADDR_VAR 0 1
120070: PUSH
120071: DOUBLE
120072: LD_INT 1
120074: DEC
120075: ST_TO_ADDR
120076: LD_VAR 0 2
120080: PUSH
120081: FOR_TO
120082: IFFALSE 120109
// if Prob ( 60 ) then
120084: LD_INT 60
120086: PPUSH
120087: CALL_OW 13
120091: IFFALSE 120107
// SetSide ( i , side ) ;
120093: LD_VAR 0 1
120097: PPUSH
120098: LD_VAR 0 3
120102: PPUSH
120103: CALL_OW 235
120107: GO 120081
120109: POP
120110: POP
// end ;
120111: PPOPN 3
120113: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
120114: LD_EXP 148
120118: PUSH
120119: LD_EXP 161
120123: AND
120124: IFFALSE 120243
120126: GO 120128
120128: DISABLE
120129: LD_INT 0
120131: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
120132: LD_ADDR_VAR 0 1
120136: PUSH
120137: LD_INT 22
120139: PUSH
120140: LD_OWVAR 2
120144: PUSH
120145: EMPTY
120146: LIST
120147: LIST
120148: PUSH
120149: LD_INT 21
120151: PUSH
120152: LD_INT 1
120154: PUSH
120155: EMPTY
120156: LIST
120157: LIST
120158: PUSH
120159: LD_INT 3
120161: PUSH
120162: LD_INT 23
120164: PUSH
120165: LD_INT 0
120167: PUSH
120168: EMPTY
120169: LIST
120170: LIST
120171: PUSH
120172: EMPTY
120173: LIST
120174: LIST
120175: PUSH
120176: EMPTY
120177: LIST
120178: LIST
120179: LIST
120180: PPUSH
120181: CALL_OW 69
120185: PUSH
120186: FOR_IN
120187: IFFALSE 120241
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
120189: LD_VAR 0 1
120193: PPUSH
120194: CALL_OW 257
120198: PUSH
120199: LD_INT 1
120201: PUSH
120202: LD_INT 2
120204: PUSH
120205: LD_INT 3
120207: PUSH
120208: LD_INT 4
120210: PUSH
120211: EMPTY
120212: LIST
120213: LIST
120214: LIST
120215: LIST
120216: IN
120217: IFFALSE 120239
// SetClass ( un , rand ( 1 , 4 ) ) ;
120219: LD_VAR 0 1
120223: PPUSH
120224: LD_INT 1
120226: PPUSH
120227: LD_INT 4
120229: PPUSH
120230: CALL_OW 12
120234: PPUSH
120235: CALL_OW 336
120239: GO 120186
120241: POP
120242: POP
// end ;
120243: PPOPN 1
120245: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
120246: LD_EXP 148
120250: PUSH
120251: LD_EXP 160
120255: AND
120256: IFFALSE 120335
120258: GO 120260
120260: DISABLE
120261: LD_INT 0
120263: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
120264: LD_ADDR_VAR 0 1
120268: PUSH
120269: LD_INT 22
120271: PUSH
120272: LD_OWVAR 2
120276: PUSH
120277: EMPTY
120278: LIST
120279: LIST
120280: PUSH
120281: LD_INT 21
120283: PUSH
120284: LD_INT 3
120286: PUSH
120287: EMPTY
120288: LIST
120289: LIST
120290: PUSH
120291: EMPTY
120292: LIST
120293: LIST
120294: PPUSH
120295: CALL_OW 69
120299: ST_TO_ADDR
// if not tmp then
120300: LD_VAR 0 1
120304: NOT
120305: IFFALSE 120309
// exit ;
120307: GO 120335
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
120309: LD_VAR 0 1
120313: PUSH
120314: LD_INT 1
120316: PPUSH
120317: LD_VAR 0 1
120321: PPUSH
120322: CALL_OW 12
120326: ARRAY
120327: PPUSH
120328: LD_INT 100
120330: PPUSH
120331: CALL_OW 234
// end ;
120335: PPOPN 1
120337: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
120338: LD_EXP 148
120342: PUSH
120343: LD_EXP 162
120347: AND
120348: IFFALSE 120446
120350: GO 120352
120352: DISABLE
120353: LD_INT 0
120355: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
120356: LD_ADDR_VAR 0 1
120360: PUSH
120361: LD_INT 22
120363: PUSH
120364: LD_OWVAR 2
120368: PUSH
120369: EMPTY
120370: LIST
120371: LIST
120372: PUSH
120373: LD_INT 21
120375: PUSH
120376: LD_INT 1
120378: PUSH
120379: EMPTY
120380: LIST
120381: LIST
120382: PUSH
120383: EMPTY
120384: LIST
120385: LIST
120386: PPUSH
120387: CALL_OW 69
120391: ST_TO_ADDR
// if not tmp then
120392: LD_VAR 0 1
120396: NOT
120397: IFFALSE 120401
// exit ;
120399: GO 120446
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
120401: LD_VAR 0 1
120405: PUSH
120406: LD_INT 1
120408: PPUSH
120409: LD_VAR 0 1
120413: PPUSH
120414: CALL_OW 12
120418: ARRAY
120419: PPUSH
120420: LD_INT 1
120422: PPUSH
120423: LD_INT 4
120425: PPUSH
120426: CALL_OW 12
120430: PPUSH
120431: LD_INT 3000
120433: PPUSH
120434: LD_INT 9000
120436: PPUSH
120437: CALL_OW 12
120441: PPUSH
120442: CALL_OW 492
// end ;
120446: PPOPN 1
120448: END
// every 0 0$1 trigger StreamModeActive and sDepot do
120449: LD_EXP 148
120453: PUSH
120454: LD_EXP 163
120458: AND
120459: IFFALSE 120479
120461: GO 120463
120463: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
120464: LD_INT 1
120466: PPUSH
120467: LD_OWVAR 2
120471: PPUSH
120472: LD_INT 0
120474: PPUSH
120475: CALL_OW 324
120479: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
120480: LD_EXP 148
120484: PUSH
120485: LD_EXP 164
120489: AND
120490: IFFALSE 120573
120492: GO 120494
120494: DISABLE
120495: LD_INT 0
120497: PPUSH
120498: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
120499: LD_ADDR_VAR 0 2
120503: PUSH
120504: LD_INT 22
120506: PUSH
120507: LD_OWVAR 2
120511: PUSH
120512: EMPTY
120513: LIST
120514: LIST
120515: PUSH
120516: LD_INT 21
120518: PUSH
120519: LD_INT 3
120521: PUSH
120522: EMPTY
120523: LIST
120524: LIST
120525: PUSH
120526: EMPTY
120527: LIST
120528: LIST
120529: PPUSH
120530: CALL_OW 69
120534: ST_TO_ADDR
// if not tmp then
120535: LD_VAR 0 2
120539: NOT
120540: IFFALSE 120544
// exit ;
120542: GO 120573
// for i in tmp do
120544: LD_ADDR_VAR 0 1
120548: PUSH
120549: LD_VAR 0 2
120553: PUSH
120554: FOR_IN
120555: IFFALSE 120571
// SetBLevel ( i , 10 ) ;
120557: LD_VAR 0 1
120561: PPUSH
120562: LD_INT 10
120564: PPUSH
120565: CALL_OW 241
120569: GO 120554
120571: POP
120572: POP
// end ;
120573: PPOPN 2
120575: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
120576: LD_EXP 148
120580: PUSH
120581: LD_EXP 165
120585: AND
120586: IFFALSE 120697
120588: GO 120590
120590: DISABLE
120591: LD_INT 0
120593: PPUSH
120594: PPUSH
120595: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
120596: LD_ADDR_VAR 0 3
120600: PUSH
120601: LD_INT 22
120603: PUSH
120604: LD_OWVAR 2
120608: PUSH
120609: EMPTY
120610: LIST
120611: LIST
120612: PUSH
120613: LD_INT 25
120615: PUSH
120616: LD_INT 1
120618: PUSH
120619: EMPTY
120620: LIST
120621: LIST
120622: PUSH
120623: EMPTY
120624: LIST
120625: LIST
120626: PPUSH
120627: CALL_OW 69
120631: ST_TO_ADDR
// if not tmp then
120632: LD_VAR 0 3
120636: NOT
120637: IFFALSE 120641
// exit ;
120639: GO 120697
// un := tmp [ rand ( 1 , tmp ) ] ;
120641: LD_ADDR_VAR 0 2
120645: PUSH
120646: LD_VAR 0 3
120650: PUSH
120651: LD_INT 1
120653: PPUSH
120654: LD_VAR 0 3
120658: PPUSH
120659: CALL_OW 12
120663: ARRAY
120664: ST_TO_ADDR
// if Crawls ( un ) then
120665: LD_VAR 0 2
120669: PPUSH
120670: CALL_OW 318
120674: IFFALSE 120685
// ComWalk ( un ) ;
120676: LD_VAR 0 2
120680: PPUSH
120681: CALL_OW 138
// SetClass ( un , class_sniper ) ;
120685: LD_VAR 0 2
120689: PPUSH
120690: LD_INT 5
120692: PPUSH
120693: CALL_OW 336
// end ;
120697: PPOPN 3
120699: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
120700: LD_EXP 148
120704: PUSH
120705: LD_EXP 166
120709: AND
120710: PUSH
120711: LD_OWVAR 67
120715: PUSH
120716: LD_INT 4
120718: LESS
120719: AND
120720: IFFALSE 120739
120722: GO 120724
120724: DISABLE
// begin Difficulty := Difficulty + 1 ;
120725: LD_ADDR_OWVAR 67
120729: PUSH
120730: LD_OWVAR 67
120734: PUSH
120735: LD_INT 1
120737: PLUS
120738: ST_TO_ADDR
// end ;
120739: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
120740: LD_EXP 148
120744: PUSH
120745: LD_EXP 167
120749: AND
120750: IFFALSE 120853
120752: GO 120754
120754: DISABLE
120755: LD_INT 0
120757: PPUSH
// begin for i := 1 to 5 do
120758: LD_ADDR_VAR 0 1
120762: PUSH
120763: DOUBLE
120764: LD_INT 1
120766: DEC
120767: ST_TO_ADDR
120768: LD_INT 5
120770: PUSH
120771: FOR_TO
120772: IFFALSE 120851
// begin uc_nation := nation_nature ;
120774: LD_ADDR_OWVAR 21
120778: PUSH
120779: LD_INT 0
120781: ST_TO_ADDR
// uc_side := 0 ;
120782: LD_ADDR_OWVAR 20
120786: PUSH
120787: LD_INT 0
120789: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
120790: LD_ADDR_OWVAR 29
120794: PUSH
120795: LD_INT 12
120797: PUSH
120798: LD_INT 12
120800: PUSH
120801: EMPTY
120802: LIST
120803: LIST
120804: ST_TO_ADDR
// hc_agressivity := 20 ;
120805: LD_ADDR_OWVAR 35
120809: PUSH
120810: LD_INT 20
120812: ST_TO_ADDR
// hc_class := class_tiger ;
120813: LD_ADDR_OWVAR 28
120817: PUSH
120818: LD_INT 14
120820: ST_TO_ADDR
// hc_gallery :=  ;
120821: LD_ADDR_OWVAR 33
120825: PUSH
120826: LD_STRING 
120828: ST_TO_ADDR
// hc_name :=  ;
120829: LD_ADDR_OWVAR 26
120833: PUSH
120834: LD_STRING 
120836: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
120837: CALL_OW 44
120841: PPUSH
120842: LD_INT 0
120844: PPUSH
120845: CALL_OW 51
// end ;
120849: GO 120771
120851: POP
120852: POP
// end ;
120853: PPOPN 1
120855: END
// every 0 0$1 trigger StreamModeActive and sBomb do
120856: LD_EXP 148
120860: PUSH
120861: LD_EXP 168
120865: AND
120866: IFFALSE 120875
120868: GO 120870
120870: DISABLE
// StreamSibBomb ;
120871: CALL 120876 0 0
120875: END
// export function StreamSibBomb ; var i , x , y ; begin
120876: LD_INT 0
120878: PPUSH
120879: PPUSH
120880: PPUSH
120881: PPUSH
// result := false ;
120882: LD_ADDR_VAR 0 1
120886: PUSH
120887: LD_INT 0
120889: ST_TO_ADDR
// for i := 1 to 16 do
120890: LD_ADDR_VAR 0 2
120894: PUSH
120895: DOUBLE
120896: LD_INT 1
120898: DEC
120899: ST_TO_ADDR
120900: LD_INT 16
120902: PUSH
120903: FOR_TO
120904: IFFALSE 121103
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
120906: LD_ADDR_VAR 0 3
120910: PUSH
120911: LD_INT 10
120913: PUSH
120914: LD_INT 20
120916: PUSH
120917: LD_INT 30
120919: PUSH
120920: LD_INT 40
120922: PUSH
120923: LD_INT 50
120925: PUSH
120926: LD_INT 60
120928: PUSH
120929: LD_INT 70
120931: PUSH
120932: LD_INT 80
120934: PUSH
120935: LD_INT 90
120937: PUSH
120938: LD_INT 100
120940: PUSH
120941: LD_INT 110
120943: PUSH
120944: LD_INT 120
120946: PUSH
120947: LD_INT 130
120949: PUSH
120950: LD_INT 140
120952: PUSH
120953: LD_INT 150
120955: PUSH
120956: EMPTY
120957: LIST
120958: LIST
120959: LIST
120960: LIST
120961: LIST
120962: LIST
120963: LIST
120964: LIST
120965: LIST
120966: LIST
120967: LIST
120968: LIST
120969: LIST
120970: LIST
120971: LIST
120972: PUSH
120973: LD_INT 1
120975: PPUSH
120976: LD_INT 15
120978: PPUSH
120979: CALL_OW 12
120983: ARRAY
120984: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
120985: LD_ADDR_VAR 0 4
120989: PUSH
120990: LD_INT 10
120992: PUSH
120993: LD_INT 20
120995: PUSH
120996: LD_INT 30
120998: PUSH
120999: LD_INT 40
121001: PUSH
121002: LD_INT 50
121004: PUSH
121005: LD_INT 60
121007: PUSH
121008: LD_INT 70
121010: PUSH
121011: LD_INT 80
121013: PUSH
121014: LD_INT 90
121016: PUSH
121017: LD_INT 100
121019: PUSH
121020: LD_INT 110
121022: PUSH
121023: LD_INT 120
121025: PUSH
121026: LD_INT 130
121028: PUSH
121029: LD_INT 140
121031: PUSH
121032: LD_INT 150
121034: PUSH
121035: EMPTY
121036: LIST
121037: LIST
121038: LIST
121039: LIST
121040: LIST
121041: LIST
121042: LIST
121043: LIST
121044: LIST
121045: LIST
121046: LIST
121047: LIST
121048: LIST
121049: LIST
121050: LIST
121051: PUSH
121052: LD_INT 1
121054: PPUSH
121055: LD_INT 15
121057: PPUSH
121058: CALL_OW 12
121062: ARRAY
121063: ST_TO_ADDR
// if ValidHex ( x , y ) then
121064: LD_VAR 0 3
121068: PPUSH
121069: LD_VAR 0 4
121073: PPUSH
121074: CALL_OW 488
121078: IFFALSE 121101
// begin result := [ x , y ] ;
121080: LD_ADDR_VAR 0 1
121084: PUSH
121085: LD_VAR 0 3
121089: PUSH
121090: LD_VAR 0 4
121094: PUSH
121095: EMPTY
121096: LIST
121097: LIST
121098: ST_TO_ADDR
// break ;
121099: GO 121103
// end ; end ;
121101: GO 120903
121103: POP
121104: POP
// if result then
121105: LD_VAR 0 1
121109: IFFALSE 121169
// begin ToLua ( playSibBomb() ) ;
121111: LD_STRING playSibBomb()
121113: PPUSH
121114: CALL_OW 559
// wait ( 0 0$14 ) ;
121118: LD_INT 490
121120: PPUSH
121121: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
121125: LD_VAR 0 1
121129: PUSH
121130: LD_INT 1
121132: ARRAY
121133: PPUSH
121134: LD_VAR 0 1
121138: PUSH
121139: LD_INT 2
121141: ARRAY
121142: PPUSH
121143: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
121147: LD_VAR 0 1
121151: PUSH
121152: LD_INT 1
121154: ARRAY
121155: PPUSH
121156: LD_VAR 0 1
121160: PUSH
121161: LD_INT 2
121163: ARRAY
121164: PPUSH
121165: CALL_OW 429
// end ; end ;
121169: LD_VAR 0 1
121173: RET
// every 0 0$1 trigger StreamModeActive and sReset do
121174: LD_EXP 148
121178: PUSH
121179: LD_EXP 170
121183: AND
121184: IFFALSE 121196
121186: GO 121188
121188: DISABLE
// YouLost (  ) ;
121189: LD_STRING 
121191: PPUSH
121192: CALL_OW 104
121196: END
// every 0 0$1 trigger StreamModeActive and sFog do
121197: LD_EXP 148
121201: PUSH
121202: LD_EXP 169
121206: AND
121207: IFFALSE 121221
121209: GO 121211
121211: DISABLE
// FogOff ( your_side ) ;
121212: LD_OWVAR 2
121216: PPUSH
121217: CALL_OW 344
121221: END
// every 0 0$1 trigger StreamModeActive and sSun do
121222: LD_EXP 148
121226: PUSH
121227: LD_EXP 171
121231: AND
121232: IFFALSE 121260
121234: GO 121236
121236: DISABLE
// begin solar_recharge_percent := 0 ;
121237: LD_ADDR_OWVAR 79
121241: PUSH
121242: LD_INT 0
121244: ST_TO_ADDR
// wait ( 5 5$00 ) ;
121245: LD_INT 10500
121247: PPUSH
121248: CALL_OW 67
// solar_recharge_percent := 100 ;
121252: LD_ADDR_OWVAR 79
121256: PUSH
121257: LD_INT 100
121259: ST_TO_ADDR
// end ;
121260: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
121261: LD_EXP 148
121265: PUSH
121266: LD_EXP 172
121270: AND
121271: IFFALSE 121510
121273: GO 121275
121275: DISABLE
121276: LD_INT 0
121278: PPUSH
121279: PPUSH
121280: PPUSH
// begin tmp := [ ] ;
121281: LD_ADDR_VAR 0 3
121285: PUSH
121286: EMPTY
121287: ST_TO_ADDR
// for i := 1 to 6 do
121288: LD_ADDR_VAR 0 1
121292: PUSH
121293: DOUBLE
121294: LD_INT 1
121296: DEC
121297: ST_TO_ADDR
121298: LD_INT 6
121300: PUSH
121301: FOR_TO
121302: IFFALSE 121407
// begin uc_nation := nation_nature ;
121304: LD_ADDR_OWVAR 21
121308: PUSH
121309: LD_INT 0
121311: ST_TO_ADDR
// uc_side := 0 ;
121312: LD_ADDR_OWVAR 20
121316: PUSH
121317: LD_INT 0
121319: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
121320: LD_ADDR_OWVAR 29
121324: PUSH
121325: LD_INT 12
121327: PUSH
121328: LD_INT 12
121330: PUSH
121331: EMPTY
121332: LIST
121333: LIST
121334: ST_TO_ADDR
// hc_agressivity := 20 ;
121335: LD_ADDR_OWVAR 35
121339: PUSH
121340: LD_INT 20
121342: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
121343: LD_ADDR_OWVAR 28
121347: PUSH
121348: LD_INT 17
121350: ST_TO_ADDR
// hc_gallery :=  ;
121351: LD_ADDR_OWVAR 33
121355: PUSH
121356: LD_STRING 
121358: ST_TO_ADDR
// hc_name :=  ;
121359: LD_ADDR_OWVAR 26
121363: PUSH
121364: LD_STRING 
121366: ST_TO_ADDR
// un := CreateHuman ;
121367: LD_ADDR_VAR 0 2
121371: PUSH
121372: CALL_OW 44
121376: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
121377: LD_VAR 0 2
121381: PPUSH
121382: LD_INT 1
121384: PPUSH
121385: CALL_OW 51
// tmp := tmp ^ un ;
121389: LD_ADDR_VAR 0 3
121393: PUSH
121394: LD_VAR 0 3
121398: PUSH
121399: LD_VAR 0 2
121403: ADD
121404: ST_TO_ADDR
// end ;
121405: GO 121301
121407: POP
121408: POP
// repeat wait ( 0 0$1 ) ;
121409: LD_INT 35
121411: PPUSH
121412: CALL_OW 67
// for un in tmp do
121416: LD_ADDR_VAR 0 2
121420: PUSH
121421: LD_VAR 0 3
121425: PUSH
121426: FOR_IN
121427: IFFALSE 121501
// begin if IsDead ( un ) then
121429: LD_VAR 0 2
121433: PPUSH
121434: CALL_OW 301
121438: IFFALSE 121458
// begin tmp := tmp diff un ;
121440: LD_ADDR_VAR 0 3
121444: PUSH
121445: LD_VAR 0 3
121449: PUSH
121450: LD_VAR 0 2
121454: DIFF
121455: ST_TO_ADDR
// continue ;
121456: GO 121426
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
121458: LD_VAR 0 2
121462: PPUSH
121463: LD_INT 3
121465: PUSH
121466: LD_INT 22
121468: PUSH
121469: LD_INT 0
121471: PUSH
121472: EMPTY
121473: LIST
121474: LIST
121475: PUSH
121476: EMPTY
121477: LIST
121478: LIST
121479: PPUSH
121480: CALL_OW 69
121484: PPUSH
121485: LD_VAR 0 2
121489: PPUSH
121490: CALL_OW 74
121494: PPUSH
121495: CALL_OW 115
// end ;
121499: GO 121426
121501: POP
121502: POP
// until not tmp ;
121503: LD_VAR 0 3
121507: NOT
121508: IFFALSE 121409
// end ;
121510: PPOPN 3
121512: END
// every 0 0$1 trigger StreamModeActive and sTroll do
121513: LD_EXP 148
121517: PUSH
121518: LD_EXP 173
121522: AND
121523: IFFALSE 121577
121525: GO 121527
121527: DISABLE
// begin ToLua ( displayTroll(); ) ;
121528: LD_STRING displayTroll();
121530: PPUSH
121531: CALL_OW 559
// wait ( 3 3$00 ) ;
121535: LD_INT 6300
121537: PPUSH
121538: CALL_OW 67
// ToLua ( hideTroll(); ) ;
121542: LD_STRING hideTroll();
121544: PPUSH
121545: CALL_OW 559
// wait ( 1 1$00 ) ;
121549: LD_INT 2100
121551: PPUSH
121552: CALL_OW 67
// ToLua ( displayTroll(); ) ;
121556: LD_STRING displayTroll();
121558: PPUSH
121559: CALL_OW 559
// wait ( 1 1$00 ) ;
121563: LD_INT 2100
121565: PPUSH
121566: CALL_OW 67
// ToLua ( hideTroll(); ) ;
121570: LD_STRING hideTroll();
121572: PPUSH
121573: CALL_OW 559
// end ;
121577: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
121578: LD_EXP 148
121582: PUSH
121583: LD_EXP 174
121587: AND
121588: IFFALSE 121651
121590: GO 121592
121592: DISABLE
121593: LD_INT 0
121595: PPUSH
// begin p := 0 ;
121596: LD_ADDR_VAR 0 1
121600: PUSH
121601: LD_INT 0
121603: ST_TO_ADDR
// repeat game_speed := 1 ;
121604: LD_ADDR_OWVAR 65
121608: PUSH
121609: LD_INT 1
121611: ST_TO_ADDR
// wait ( 0 0$1 ) ;
121612: LD_INT 35
121614: PPUSH
121615: CALL_OW 67
// p := p + 1 ;
121619: LD_ADDR_VAR 0 1
121623: PUSH
121624: LD_VAR 0 1
121628: PUSH
121629: LD_INT 1
121631: PLUS
121632: ST_TO_ADDR
// until p >= 60 ;
121633: LD_VAR 0 1
121637: PUSH
121638: LD_INT 60
121640: GREATEREQUAL
121641: IFFALSE 121604
// game_speed := 4 ;
121643: LD_ADDR_OWVAR 65
121647: PUSH
121648: LD_INT 4
121650: ST_TO_ADDR
// end ;
121651: PPOPN 1
121653: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
121654: LD_EXP 148
121658: PUSH
121659: LD_EXP 175
121663: AND
121664: IFFALSE 121810
121666: GO 121668
121668: DISABLE
121669: LD_INT 0
121671: PPUSH
121672: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
121673: LD_ADDR_VAR 0 1
121677: PUSH
121678: LD_INT 22
121680: PUSH
121681: LD_OWVAR 2
121685: PUSH
121686: EMPTY
121687: LIST
121688: LIST
121689: PUSH
121690: LD_INT 2
121692: PUSH
121693: LD_INT 30
121695: PUSH
121696: LD_INT 0
121698: PUSH
121699: EMPTY
121700: LIST
121701: LIST
121702: PUSH
121703: LD_INT 30
121705: PUSH
121706: LD_INT 1
121708: PUSH
121709: EMPTY
121710: LIST
121711: LIST
121712: PUSH
121713: EMPTY
121714: LIST
121715: LIST
121716: LIST
121717: PUSH
121718: EMPTY
121719: LIST
121720: LIST
121721: PPUSH
121722: CALL_OW 69
121726: ST_TO_ADDR
// if not depot then
121727: LD_VAR 0 1
121731: NOT
121732: IFFALSE 121736
// exit ;
121734: GO 121810
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
121736: LD_ADDR_VAR 0 2
121740: PUSH
121741: LD_VAR 0 1
121745: PUSH
121746: LD_INT 1
121748: PPUSH
121749: LD_VAR 0 1
121753: PPUSH
121754: CALL_OW 12
121758: ARRAY
121759: PPUSH
121760: CALL_OW 274
121764: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
121765: LD_VAR 0 2
121769: PPUSH
121770: LD_INT 1
121772: PPUSH
121773: LD_INT 0
121775: PPUSH
121776: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
121780: LD_VAR 0 2
121784: PPUSH
121785: LD_INT 2
121787: PPUSH
121788: LD_INT 0
121790: PPUSH
121791: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
121795: LD_VAR 0 2
121799: PPUSH
121800: LD_INT 3
121802: PPUSH
121803: LD_INT 0
121805: PPUSH
121806: CALL_OW 277
// end ;
121810: PPOPN 2
121812: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
121813: LD_EXP 148
121817: PUSH
121818: LD_EXP 176
121822: AND
121823: IFFALSE 121920
121825: GO 121827
121827: DISABLE
121828: LD_INT 0
121830: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
121831: LD_ADDR_VAR 0 1
121835: PUSH
121836: LD_INT 22
121838: PUSH
121839: LD_OWVAR 2
121843: PUSH
121844: EMPTY
121845: LIST
121846: LIST
121847: PUSH
121848: LD_INT 21
121850: PUSH
121851: LD_INT 1
121853: PUSH
121854: EMPTY
121855: LIST
121856: LIST
121857: PUSH
121858: LD_INT 3
121860: PUSH
121861: LD_INT 23
121863: PUSH
121864: LD_INT 0
121866: PUSH
121867: EMPTY
121868: LIST
121869: LIST
121870: PUSH
121871: EMPTY
121872: LIST
121873: LIST
121874: PUSH
121875: EMPTY
121876: LIST
121877: LIST
121878: LIST
121879: PPUSH
121880: CALL_OW 69
121884: ST_TO_ADDR
// if not tmp then
121885: LD_VAR 0 1
121889: NOT
121890: IFFALSE 121894
// exit ;
121892: GO 121920
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
121894: LD_VAR 0 1
121898: PUSH
121899: LD_INT 1
121901: PPUSH
121902: LD_VAR 0 1
121906: PPUSH
121907: CALL_OW 12
121911: ARRAY
121912: PPUSH
121913: LD_INT 200
121915: PPUSH
121916: CALL_OW 234
// end ;
121920: PPOPN 1
121922: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
121923: LD_EXP 148
121927: PUSH
121928: LD_EXP 177
121932: AND
121933: IFFALSE 122012
121935: GO 121937
121937: DISABLE
121938: LD_INT 0
121940: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
121941: LD_ADDR_VAR 0 1
121945: PUSH
121946: LD_INT 22
121948: PUSH
121949: LD_OWVAR 2
121953: PUSH
121954: EMPTY
121955: LIST
121956: LIST
121957: PUSH
121958: LD_INT 21
121960: PUSH
121961: LD_INT 2
121963: PUSH
121964: EMPTY
121965: LIST
121966: LIST
121967: PUSH
121968: EMPTY
121969: LIST
121970: LIST
121971: PPUSH
121972: CALL_OW 69
121976: ST_TO_ADDR
// if not tmp then
121977: LD_VAR 0 1
121981: NOT
121982: IFFALSE 121986
// exit ;
121984: GO 122012
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
121986: LD_VAR 0 1
121990: PUSH
121991: LD_INT 1
121993: PPUSH
121994: LD_VAR 0 1
121998: PPUSH
121999: CALL_OW 12
122003: ARRAY
122004: PPUSH
122005: LD_INT 60
122007: PPUSH
122008: CALL_OW 234
// end ;
122012: PPOPN 1
122014: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
122015: LD_EXP 148
122019: PUSH
122020: LD_EXP 178
122024: AND
122025: IFFALSE 122124
122027: GO 122029
122029: DISABLE
122030: LD_INT 0
122032: PPUSH
122033: PPUSH
// begin enable ;
122034: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
122035: LD_ADDR_VAR 0 1
122039: PUSH
122040: LD_INT 22
122042: PUSH
122043: LD_OWVAR 2
122047: PUSH
122048: EMPTY
122049: LIST
122050: LIST
122051: PUSH
122052: LD_INT 61
122054: PUSH
122055: EMPTY
122056: LIST
122057: PUSH
122058: LD_INT 33
122060: PUSH
122061: LD_INT 2
122063: PUSH
122064: EMPTY
122065: LIST
122066: LIST
122067: PUSH
122068: EMPTY
122069: LIST
122070: LIST
122071: LIST
122072: PPUSH
122073: CALL_OW 69
122077: ST_TO_ADDR
// if not tmp then
122078: LD_VAR 0 1
122082: NOT
122083: IFFALSE 122087
// exit ;
122085: GO 122124
// for i in tmp do
122087: LD_ADDR_VAR 0 2
122091: PUSH
122092: LD_VAR 0 1
122096: PUSH
122097: FOR_IN
122098: IFFALSE 122122
// if IsControledBy ( i ) then
122100: LD_VAR 0 2
122104: PPUSH
122105: CALL_OW 312
122109: IFFALSE 122120
// ComUnlink ( i ) ;
122111: LD_VAR 0 2
122115: PPUSH
122116: CALL_OW 136
122120: GO 122097
122122: POP
122123: POP
// end ;
122124: PPOPN 2
122126: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
122127: LD_EXP 148
122131: PUSH
122132: LD_EXP 179
122136: AND
122137: IFFALSE 122277
122139: GO 122141
122141: DISABLE
122142: LD_INT 0
122144: PPUSH
122145: PPUSH
// begin ToLua ( displayPowell(); ) ;
122146: LD_STRING displayPowell();
122148: PPUSH
122149: CALL_OW 559
// uc_side := 0 ;
122153: LD_ADDR_OWVAR 20
122157: PUSH
122158: LD_INT 0
122160: ST_TO_ADDR
// uc_nation := 2 ;
122161: LD_ADDR_OWVAR 21
122165: PUSH
122166: LD_INT 2
122168: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
122169: LD_ADDR_OWVAR 37
122173: PUSH
122174: LD_INT 14
122176: ST_TO_ADDR
// vc_engine := engine_siberite ;
122177: LD_ADDR_OWVAR 39
122181: PUSH
122182: LD_INT 3
122184: ST_TO_ADDR
// vc_control := control_apeman ;
122185: LD_ADDR_OWVAR 38
122189: PUSH
122190: LD_INT 5
122192: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
122193: LD_ADDR_OWVAR 40
122197: PUSH
122198: LD_INT 29
122200: ST_TO_ADDR
// un := CreateVehicle ;
122201: LD_ADDR_VAR 0 2
122205: PUSH
122206: CALL_OW 45
122210: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
122211: LD_VAR 0 2
122215: PPUSH
122216: LD_INT 1
122218: PPUSH
122219: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
122223: LD_INT 35
122225: PPUSH
122226: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
122230: LD_VAR 0 2
122234: PPUSH
122235: LD_INT 22
122237: PUSH
122238: LD_OWVAR 2
122242: PUSH
122243: EMPTY
122244: LIST
122245: LIST
122246: PPUSH
122247: CALL_OW 69
122251: PPUSH
122252: LD_VAR 0 2
122256: PPUSH
122257: CALL_OW 74
122261: PPUSH
122262: CALL_OW 115
// until IsDead ( un ) ;
122266: LD_VAR 0 2
122270: PPUSH
122271: CALL_OW 301
122275: IFFALSE 122223
// end ;
122277: PPOPN 2
122279: END
// every 0 0$1 trigger StreamModeActive and sStu do
122280: LD_EXP 148
122284: PUSH
122285: LD_EXP 187
122289: AND
122290: IFFALSE 122306
122292: GO 122294
122294: DISABLE
// begin ToLua ( displayStucuk(); ) ;
122295: LD_STRING displayStucuk();
122297: PPUSH
122298: CALL_OW 559
// ResetFog ;
122302: CALL_OW 335
// end ;
122306: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
122307: LD_EXP 148
122311: PUSH
122312: LD_EXP 180
122316: AND
122317: IFFALSE 122458
122319: GO 122321
122321: DISABLE
122322: LD_INT 0
122324: PPUSH
122325: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
122326: LD_ADDR_VAR 0 2
122330: PUSH
122331: LD_INT 22
122333: PUSH
122334: LD_OWVAR 2
122338: PUSH
122339: EMPTY
122340: LIST
122341: LIST
122342: PUSH
122343: LD_INT 21
122345: PUSH
122346: LD_INT 1
122348: PUSH
122349: EMPTY
122350: LIST
122351: LIST
122352: PUSH
122353: EMPTY
122354: LIST
122355: LIST
122356: PPUSH
122357: CALL_OW 69
122361: ST_TO_ADDR
// if not tmp then
122362: LD_VAR 0 2
122366: NOT
122367: IFFALSE 122371
// exit ;
122369: GO 122458
// un := tmp [ rand ( 1 , tmp ) ] ;
122371: LD_ADDR_VAR 0 1
122375: PUSH
122376: LD_VAR 0 2
122380: PUSH
122381: LD_INT 1
122383: PPUSH
122384: LD_VAR 0 2
122388: PPUSH
122389: CALL_OW 12
122393: ARRAY
122394: ST_TO_ADDR
// SetSide ( un , 0 ) ;
122395: LD_VAR 0 1
122399: PPUSH
122400: LD_INT 0
122402: PPUSH
122403: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
122407: LD_VAR 0 1
122411: PPUSH
122412: LD_OWVAR 3
122416: PUSH
122417: LD_VAR 0 1
122421: DIFF
122422: PPUSH
122423: LD_VAR 0 1
122427: PPUSH
122428: CALL_OW 74
122432: PPUSH
122433: CALL_OW 115
// wait ( 0 0$20 ) ;
122437: LD_INT 700
122439: PPUSH
122440: CALL_OW 67
// SetSide ( un , your_side ) ;
122444: LD_VAR 0 1
122448: PPUSH
122449: LD_OWVAR 2
122453: PPUSH
122454: CALL_OW 235
// end ;
122458: PPOPN 2
122460: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
122461: LD_EXP 148
122465: PUSH
122466: LD_EXP 181
122470: AND
122471: IFFALSE 122577
122473: GO 122475
122475: DISABLE
122476: LD_INT 0
122478: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
122479: LD_ADDR_VAR 0 1
122483: PUSH
122484: LD_INT 22
122486: PUSH
122487: LD_OWVAR 2
122491: PUSH
122492: EMPTY
122493: LIST
122494: LIST
122495: PUSH
122496: LD_INT 2
122498: PUSH
122499: LD_INT 30
122501: PUSH
122502: LD_INT 0
122504: PUSH
122505: EMPTY
122506: LIST
122507: LIST
122508: PUSH
122509: LD_INT 30
122511: PUSH
122512: LD_INT 1
122514: PUSH
122515: EMPTY
122516: LIST
122517: LIST
122518: PUSH
122519: EMPTY
122520: LIST
122521: LIST
122522: LIST
122523: PUSH
122524: EMPTY
122525: LIST
122526: LIST
122527: PPUSH
122528: CALL_OW 69
122532: ST_TO_ADDR
// if not depot then
122533: LD_VAR 0 1
122537: NOT
122538: IFFALSE 122542
// exit ;
122540: GO 122577
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
122542: LD_VAR 0 1
122546: PUSH
122547: LD_INT 1
122549: ARRAY
122550: PPUSH
122551: CALL_OW 250
122555: PPUSH
122556: LD_VAR 0 1
122560: PUSH
122561: LD_INT 1
122563: ARRAY
122564: PPUSH
122565: CALL_OW 251
122569: PPUSH
122570: LD_INT 70
122572: PPUSH
122573: CALL_OW 495
// end ;
122577: PPOPN 1
122579: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
122580: LD_EXP 148
122584: PUSH
122585: LD_EXP 182
122589: AND
122590: IFFALSE 122801
122592: GO 122594
122594: DISABLE
122595: LD_INT 0
122597: PPUSH
122598: PPUSH
122599: PPUSH
122600: PPUSH
122601: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
122602: LD_ADDR_VAR 0 5
122606: PUSH
122607: LD_INT 22
122609: PUSH
122610: LD_OWVAR 2
122614: PUSH
122615: EMPTY
122616: LIST
122617: LIST
122618: PUSH
122619: LD_INT 21
122621: PUSH
122622: LD_INT 1
122624: PUSH
122625: EMPTY
122626: LIST
122627: LIST
122628: PUSH
122629: EMPTY
122630: LIST
122631: LIST
122632: PPUSH
122633: CALL_OW 69
122637: ST_TO_ADDR
// if not tmp then
122638: LD_VAR 0 5
122642: NOT
122643: IFFALSE 122647
// exit ;
122645: GO 122801
// for i in tmp do
122647: LD_ADDR_VAR 0 1
122651: PUSH
122652: LD_VAR 0 5
122656: PUSH
122657: FOR_IN
122658: IFFALSE 122799
// begin d := rand ( 0 , 5 ) ;
122660: LD_ADDR_VAR 0 4
122664: PUSH
122665: LD_INT 0
122667: PPUSH
122668: LD_INT 5
122670: PPUSH
122671: CALL_OW 12
122675: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
122676: LD_ADDR_VAR 0 2
122680: PUSH
122681: LD_VAR 0 1
122685: PPUSH
122686: CALL_OW 250
122690: PPUSH
122691: LD_VAR 0 4
122695: PPUSH
122696: LD_INT 3
122698: PPUSH
122699: LD_INT 12
122701: PPUSH
122702: CALL_OW 12
122706: PPUSH
122707: CALL_OW 272
122711: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
122712: LD_ADDR_VAR 0 3
122716: PUSH
122717: LD_VAR 0 1
122721: PPUSH
122722: CALL_OW 251
122726: PPUSH
122727: LD_VAR 0 4
122731: PPUSH
122732: LD_INT 3
122734: PPUSH
122735: LD_INT 12
122737: PPUSH
122738: CALL_OW 12
122742: PPUSH
122743: CALL_OW 273
122747: ST_TO_ADDR
// if ValidHex ( x , y ) then
122748: LD_VAR 0 2
122752: PPUSH
122753: LD_VAR 0 3
122757: PPUSH
122758: CALL_OW 488
122762: IFFALSE 122797
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
122764: LD_VAR 0 1
122768: PPUSH
122769: LD_VAR 0 2
122773: PPUSH
122774: LD_VAR 0 3
122778: PPUSH
122779: LD_INT 3
122781: PPUSH
122782: LD_INT 6
122784: PPUSH
122785: CALL_OW 12
122789: PPUSH
122790: LD_INT 1
122792: PPUSH
122793: CALL_OW 483
// end ;
122797: GO 122657
122799: POP
122800: POP
// end ;
122801: PPOPN 5
122803: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
122804: LD_EXP 148
122808: PUSH
122809: LD_EXP 183
122813: AND
122814: IFFALSE 122908
122816: GO 122818
122818: DISABLE
122819: LD_INT 0
122821: PPUSH
122822: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
122823: LD_ADDR_VAR 0 2
122827: PUSH
122828: LD_INT 22
122830: PUSH
122831: LD_OWVAR 2
122835: PUSH
122836: EMPTY
122837: LIST
122838: LIST
122839: PUSH
122840: LD_INT 32
122842: PUSH
122843: LD_INT 1
122845: PUSH
122846: EMPTY
122847: LIST
122848: LIST
122849: PUSH
122850: LD_INT 21
122852: PUSH
122853: LD_INT 2
122855: PUSH
122856: EMPTY
122857: LIST
122858: LIST
122859: PUSH
122860: EMPTY
122861: LIST
122862: LIST
122863: LIST
122864: PPUSH
122865: CALL_OW 69
122869: ST_TO_ADDR
// if not tmp then
122870: LD_VAR 0 2
122874: NOT
122875: IFFALSE 122879
// exit ;
122877: GO 122908
// for i in tmp do
122879: LD_ADDR_VAR 0 1
122883: PUSH
122884: LD_VAR 0 2
122888: PUSH
122889: FOR_IN
122890: IFFALSE 122906
// SetFuel ( i , 0 ) ;
122892: LD_VAR 0 1
122896: PPUSH
122897: LD_INT 0
122899: PPUSH
122900: CALL_OW 240
122904: GO 122889
122906: POP
122907: POP
// end ;
122908: PPOPN 2
122910: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
122911: LD_EXP 148
122915: PUSH
122916: LD_EXP 184
122920: AND
122921: IFFALSE 122987
122923: GO 122925
122925: DISABLE
122926: LD_INT 0
122928: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
122929: LD_ADDR_VAR 0 1
122933: PUSH
122934: LD_INT 22
122936: PUSH
122937: LD_OWVAR 2
122941: PUSH
122942: EMPTY
122943: LIST
122944: LIST
122945: PUSH
122946: LD_INT 30
122948: PUSH
122949: LD_INT 29
122951: PUSH
122952: EMPTY
122953: LIST
122954: LIST
122955: PUSH
122956: EMPTY
122957: LIST
122958: LIST
122959: PPUSH
122960: CALL_OW 69
122964: ST_TO_ADDR
// if not tmp then
122965: LD_VAR 0 1
122969: NOT
122970: IFFALSE 122974
// exit ;
122972: GO 122987
// DestroyUnit ( tmp [ 1 ] ) ;
122974: LD_VAR 0 1
122978: PUSH
122979: LD_INT 1
122981: ARRAY
122982: PPUSH
122983: CALL_OW 65
// end ;
122987: PPOPN 1
122989: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
122990: LD_EXP 148
122994: PUSH
122995: LD_EXP 186
122999: AND
123000: IFFALSE 123129
123002: GO 123004
123004: DISABLE
123005: LD_INT 0
123007: PPUSH
// begin uc_side := 0 ;
123008: LD_ADDR_OWVAR 20
123012: PUSH
123013: LD_INT 0
123015: ST_TO_ADDR
// uc_nation := nation_arabian ;
123016: LD_ADDR_OWVAR 21
123020: PUSH
123021: LD_INT 2
123023: ST_TO_ADDR
// hc_gallery :=  ;
123024: LD_ADDR_OWVAR 33
123028: PUSH
123029: LD_STRING 
123031: ST_TO_ADDR
// hc_name :=  ;
123032: LD_ADDR_OWVAR 26
123036: PUSH
123037: LD_STRING 
123039: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
123040: LD_INT 1
123042: PPUSH
123043: LD_INT 11
123045: PPUSH
123046: LD_INT 10
123048: PPUSH
123049: CALL_OW 380
// un := CreateHuman ;
123053: LD_ADDR_VAR 0 1
123057: PUSH
123058: CALL_OW 44
123062: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
123063: LD_VAR 0 1
123067: PPUSH
123068: LD_INT 1
123070: PPUSH
123071: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
123075: LD_INT 35
123077: PPUSH
123078: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
123082: LD_VAR 0 1
123086: PPUSH
123087: LD_INT 22
123089: PUSH
123090: LD_OWVAR 2
123094: PUSH
123095: EMPTY
123096: LIST
123097: LIST
123098: PPUSH
123099: CALL_OW 69
123103: PPUSH
123104: LD_VAR 0 1
123108: PPUSH
123109: CALL_OW 74
123113: PPUSH
123114: CALL_OW 115
// until IsDead ( un ) ;
123118: LD_VAR 0 1
123122: PPUSH
123123: CALL_OW 301
123127: IFFALSE 123075
// end ;
123129: PPOPN 1
123131: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
123132: LD_EXP 148
123136: PUSH
123137: LD_EXP 188
123141: AND
123142: IFFALSE 123154
123144: GO 123146
123146: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
123147: LD_STRING earthquake(getX(game), 0, 32)
123149: PPUSH
123150: CALL_OW 559
123154: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
123155: LD_EXP 148
123159: PUSH
123160: LD_EXP 189
123164: AND
123165: IFFALSE 123256
123167: GO 123169
123169: DISABLE
123170: LD_INT 0
123172: PPUSH
// begin enable ;
123173: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
123174: LD_ADDR_VAR 0 1
123178: PUSH
123179: LD_INT 22
123181: PUSH
123182: LD_OWVAR 2
123186: PUSH
123187: EMPTY
123188: LIST
123189: LIST
123190: PUSH
123191: LD_INT 21
123193: PUSH
123194: LD_INT 2
123196: PUSH
123197: EMPTY
123198: LIST
123199: LIST
123200: PUSH
123201: LD_INT 33
123203: PUSH
123204: LD_INT 3
123206: PUSH
123207: EMPTY
123208: LIST
123209: LIST
123210: PUSH
123211: EMPTY
123212: LIST
123213: LIST
123214: LIST
123215: PPUSH
123216: CALL_OW 69
123220: ST_TO_ADDR
// if not tmp then
123221: LD_VAR 0 1
123225: NOT
123226: IFFALSE 123230
// exit ;
123228: GO 123256
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
123230: LD_VAR 0 1
123234: PUSH
123235: LD_INT 1
123237: PPUSH
123238: LD_VAR 0 1
123242: PPUSH
123243: CALL_OW 12
123247: ARRAY
123248: PPUSH
123249: LD_INT 1
123251: PPUSH
123252: CALL_OW 234
// end ;
123256: PPOPN 1
123258: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
123259: LD_EXP 148
123263: PUSH
123264: LD_EXP 190
123268: AND
123269: IFFALSE 123410
123271: GO 123273
123273: DISABLE
123274: LD_INT 0
123276: PPUSH
123277: PPUSH
123278: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
123279: LD_ADDR_VAR 0 3
123283: PUSH
123284: LD_INT 22
123286: PUSH
123287: LD_OWVAR 2
123291: PUSH
123292: EMPTY
123293: LIST
123294: LIST
123295: PUSH
123296: LD_INT 25
123298: PUSH
123299: LD_INT 1
123301: PUSH
123302: EMPTY
123303: LIST
123304: LIST
123305: PUSH
123306: EMPTY
123307: LIST
123308: LIST
123309: PPUSH
123310: CALL_OW 69
123314: ST_TO_ADDR
// if not tmp then
123315: LD_VAR 0 3
123319: NOT
123320: IFFALSE 123324
// exit ;
123322: GO 123410
// un := tmp [ rand ( 1 , tmp ) ] ;
123324: LD_ADDR_VAR 0 2
123328: PUSH
123329: LD_VAR 0 3
123333: PUSH
123334: LD_INT 1
123336: PPUSH
123337: LD_VAR 0 3
123341: PPUSH
123342: CALL_OW 12
123346: ARRAY
123347: ST_TO_ADDR
// if Crawls ( un ) then
123348: LD_VAR 0 2
123352: PPUSH
123353: CALL_OW 318
123357: IFFALSE 123368
// ComWalk ( un ) ;
123359: LD_VAR 0 2
123363: PPUSH
123364: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
123368: LD_VAR 0 2
123372: PPUSH
123373: LD_INT 9
123375: PPUSH
123376: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
123380: LD_INT 28
123382: PPUSH
123383: LD_OWVAR 2
123387: PPUSH
123388: LD_INT 2
123390: PPUSH
123391: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
123395: LD_INT 29
123397: PPUSH
123398: LD_OWVAR 2
123402: PPUSH
123403: LD_INT 2
123405: PPUSH
123406: CALL_OW 322
// end ;
123410: PPOPN 3
123412: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
123413: LD_EXP 148
123417: PUSH
123418: LD_EXP 191
123422: AND
123423: IFFALSE 123534
123425: GO 123427
123427: DISABLE
123428: LD_INT 0
123430: PPUSH
123431: PPUSH
123432: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
123433: LD_ADDR_VAR 0 3
123437: PUSH
123438: LD_INT 22
123440: PUSH
123441: LD_OWVAR 2
123445: PUSH
123446: EMPTY
123447: LIST
123448: LIST
123449: PUSH
123450: LD_INT 25
123452: PUSH
123453: LD_INT 1
123455: PUSH
123456: EMPTY
123457: LIST
123458: LIST
123459: PUSH
123460: EMPTY
123461: LIST
123462: LIST
123463: PPUSH
123464: CALL_OW 69
123468: ST_TO_ADDR
// if not tmp then
123469: LD_VAR 0 3
123473: NOT
123474: IFFALSE 123478
// exit ;
123476: GO 123534
// un := tmp [ rand ( 1 , tmp ) ] ;
123478: LD_ADDR_VAR 0 2
123482: PUSH
123483: LD_VAR 0 3
123487: PUSH
123488: LD_INT 1
123490: PPUSH
123491: LD_VAR 0 3
123495: PPUSH
123496: CALL_OW 12
123500: ARRAY
123501: ST_TO_ADDR
// if Crawls ( un ) then
123502: LD_VAR 0 2
123506: PPUSH
123507: CALL_OW 318
123511: IFFALSE 123522
// ComWalk ( un ) ;
123513: LD_VAR 0 2
123517: PPUSH
123518: CALL_OW 138
// SetClass ( un , class_mortar ) ;
123522: LD_VAR 0 2
123526: PPUSH
123527: LD_INT 8
123529: PPUSH
123530: CALL_OW 336
// end ;
123534: PPOPN 3
123536: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
123537: LD_EXP 148
123541: PUSH
123542: LD_EXP 192
123546: AND
123547: IFFALSE 123691
123549: GO 123551
123551: DISABLE
123552: LD_INT 0
123554: PPUSH
123555: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
123556: LD_ADDR_VAR 0 2
123560: PUSH
123561: LD_INT 22
123563: PUSH
123564: LD_OWVAR 2
123568: PUSH
123569: EMPTY
123570: LIST
123571: LIST
123572: PUSH
123573: LD_INT 21
123575: PUSH
123576: LD_INT 2
123578: PUSH
123579: EMPTY
123580: LIST
123581: LIST
123582: PUSH
123583: LD_INT 2
123585: PUSH
123586: LD_INT 34
123588: PUSH
123589: LD_INT 12
123591: PUSH
123592: EMPTY
123593: LIST
123594: LIST
123595: PUSH
123596: LD_INT 34
123598: PUSH
123599: LD_INT 51
123601: PUSH
123602: EMPTY
123603: LIST
123604: LIST
123605: PUSH
123606: LD_INT 34
123608: PUSH
123609: LD_INT 32
123611: PUSH
123612: EMPTY
123613: LIST
123614: LIST
123615: PUSH
123616: EMPTY
123617: LIST
123618: LIST
123619: LIST
123620: LIST
123621: PUSH
123622: EMPTY
123623: LIST
123624: LIST
123625: LIST
123626: PPUSH
123627: CALL_OW 69
123631: ST_TO_ADDR
// if not tmp then
123632: LD_VAR 0 2
123636: NOT
123637: IFFALSE 123641
// exit ;
123639: GO 123691
// for i in tmp do
123641: LD_ADDR_VAR 0 1
123645: PUSH
123646: LD_VAR 0 2
123650: PUSH
123651: FOR_IN
123652: IFFALSE 123689
// if GetCargo ( i , mat_artifact ) = 0 then
123654: LD_VAR 0 1
123658: PPUSH
123659: LD_INT 4
123661: PPUSH
123662: CALL_OW 289
123666: PUSH
123667: LD_INT 0
123669: EQUAL
123670: IFFALSE 123687
// SetCargo ( i , mat_siberit , 100 ) ;
123672: LD_VAR 0 1
123676: PPUSH
123677: LD_INT 3
123679: PPUSH
123680: LD_INT 100
123682: PPUSH
123683: CALL_OW 290
123687: GO 123651
123689: POP
123690: POP
// end ;
123691: PPOPN 2
123693: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
123694: LD_EXP 148
123698: PUSH
123699: LD_EXP 193
123703: AND
123704: IFFALSE 123887
123706: GO 123708
123708: DISABLE
123709: LD_INT 0
123711: PPUSH
123712: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
123713: LD_ADDR_VAR 0 2
123717: PUSH
123718: LD_INT 22
123720: PUSH
123721: LD_OWVAR 2
123725: PUSH
123726: EMPTY
123727: LIST
123728: LIST
123729: PPUSH
123730: CALL_OW 69
123734: ST_TO_ADDR
// if not tmp then
123735: LD_VAR 0 2
123739: NOT
123740: IFFALSE 123744
// exit ;
123742: GO 123887
// for i := 1 to 2 do
123744: LD_ADDR_VAR 0 1
123748: PUSH
123749: DOUBLE
123750: LD_INT 1
123752: DEC
123753: ST_TO_ADDR
123754: LD_INT 2
123756: PUSH
123757: FOR_TO
123758: IFFALSE 123885
// begin uc_side := your_side ;
123760: LD_ADDR_OWVAR 20
123764: PUSH
123765: LD_OWVAR 2
123769: ST_TO_ADDR
// uc_nation := nation_american ;
123770: LD_ADDR_OWVAR 21
123774: PUSH
123775: LD_INT 1
123777: ST_TO_ADDR
// vc_chassis := us_morphling ;
123778: LD_ADDR_OWVAR 37
123782: PUSH
123783: LD_INT 5
123785: ST_TO_ADDR
// vc_engine := engine_siberite ;
123786: LD_ADDR_OWVAR 39
123790: PUSH
123791: LD_INT 3
123793: ST_TO_ADDR
// vc_control := control_computer ;
123794: LD_ADDR_OWVAR 38
123798: PUSH
123799: LD_INT 3
123801: ST_TO_ADDR
// vc_weapon := us_double_laser ;
123802: LD_ADDR_OWVAR 40
123806: PUSH
123807: LD_INT 10
123809: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
123810: LD_VAR 0 2
123814: PUSH
123815: LD_INT 1
123817: ARRAY
123818: PPUSH
123819: CALL_OW 310
123823: NOT
123824: IFFALSE 123871
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
123826: CALL_OW 45
123830: PPUSH
123831: LD_VAR 0 2
123835: PUSH
123836: LD_INT 1
123838: ARRAY
123839: PPUSH
123840: CALL_OW 250
123844: PPUSH
123845: LD_VAR 0 2
123849: PUSH
123850: LD_INT 1
123852: ARRAY
123853: PPUSH
123854: CALL_OW 251
123858: PPUSH
123859: LD_INT 12
123861: PPUSH
123862: LD_INT 1
123864: PPUSH
123865: CALL_OW 50
123869: GO 123883
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
123871: CALL_OW 45
123875: PPUSH
123876: LD_INT 1
123878: PPUSH
123879: CALL_OW 51
// end ;
123883: GO 123757
123885: POP
123886: POP
// end ;
123887: PPOPN 2
123889: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
123890: LD_EXP 148
123894: PUSH
123895: LD_EXP 194
123899: AND
123900: IFFALSE 124122
123902: GO 123904
123904: DISABLE
123905: LD_INT 0
123907: PPUSH
123908: PPUSH
123909: PPUSH
123910: PPUSH
123911: PPUSH
123912: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
123913: LD_ADDR_VAR 0 6
123917: PUSH
123918: LD_INT 22
123920: PUSH
123921: LD_OWVAR 2
123925: PUSH
123926: EMPTY
123927: LIST
123928: LIST
123929: PUSH
123930: LD_INT 21
123932: PUSH
123933: LD_INT 1
123935: PUSH
123936: EMPTY
123937: LIST
123938: LIST
123939: PUSH
123940: LD_INT 3
123942: PUSH
123943: LD_INT 23
123945: PUSH
123946: LD_INT 0
123948: PUSH
123949: EMPTY
123950: LIST
123951: LIST
123952: PUSH
123953: EMPTY
123954: LIST
123955: LIST
123956: PUSH
123957: EMPTY
123958: LIST
123959: LIST
123960: LIST
123961: PPUSH
123962: CALL_OW 69
123966: ST_TO_ADDR
// if not tmp then
123967: LD_VAR 0 6
123971: NOT
123972: IFFALSE 123976
// exit ;
123974: GO 124122
// s1 := rand ( 1 , 4 ) ;
123976: LD_ADDR_VAR 0 2
123980: PUSH
123981: LD_INT 1
123983: PPUSH
123984: LD_INT 4
123986: PPUSH
123987: CALL_OW 12
123991: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
123992: LD_ADDR_VAR 0 4
123996: PUSH
123997: LD_VAR 0 6
124001: PUSH
124002: LD_INT 1
124004: ARRAY
124005: PPUSH
124006: LD_VAR 0 2
124010: PPUSH
124011: CALL_OW 259
124015: ST_TO_ADDR
// if s1 = 1 then
124016: LD_VAR 0 2
124020: PUSH
124021: LD_INT 1
124023: EQUAL
124024: IFFALSE 124044
// s2 := rand ( 2 , 4 ) else
124026: LD_ADDR_VAR 0 3
124030: PUSH
124031: LD_INT 2
124033: PPUSH
124034: LD_INT 4
124036: PPUSH
124037: CALL_OW 12
124041: ST_TO_ADDR
124042: GO 124052
// s2 := 1 ;
124044: LD_ADDR_VAR 0 3
124048: PUSH
124049: LD_INT 1
124051: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
124052: LD_ADDR_VAR 0 5
124056: PUSH
124057: LD_VAR 0 6
124061: PUSH
124062: LD_INT 1
124064: ARRAY
124065: PPUSH
124066: LD_VAR 0 3
124070: PPUSH
124071: CALL_OW 259
124075: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
124076: LD_VAR 0 6
124080: PUSH
124081: LD_INT 1
124083: ARRAY
124084: PPUSH
124085: LD_VAR 0 2
124089: PPUSH
124090: LD_VAR 0 5
124094: PPUSH
124095: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
124099: LD_VAR 0 6
124103: PUSH
124104: LD_INT 1
124106: ARRAY
124107: PPUSH
124108: LD_VAR 0 3
124112: PPUSH
124113: LD_VAR 0 4
124117: PPUSH
124118: CALL_OW 237
// end ;
124122: PPOPN 6
124124: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
124125: LD_EXP 148
124129: PUSH
124130: LD_EXP 195
124134: AND
124135: IFFALSE 124214
124137: GO 124139
124139: DISABLE
124140: LD_INT 0
124142: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
124143: LD_ADDR_VAR 0 1
124147: PUSH
124148: LD_INT 22
124150: PUSH
124151: LD_OWVAR 2
124155: PUSH
124156: EMPTY
124157: LIST
124158: LIST
124159: PUSH
124160: LD_INT 30
124162: PUSH
124163: LD_INT 3
124165: PUSH
124166: EMPTY
124167: LIST
124168: LIST
124169: PUSH
124170: EMPTY
124171: LIST
124172: LIST
124173: PPUSH
124174: CALL_OW 69
124178: ST_TO_ADDR
// if not tmp then
124179: LD_VAR 0 1
124183: NOT
124184: IFFALSE 124188
// exit ;
124186: GO 124214
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
124188: LD_VAR 0 1
124192: PUSH
124193: LD_INT 1
124195: PPUSH
124196: LD_VAR 0 1
124200: PPUSH
124201: CALL_OW 12
124205: ARRAY
124206: PPUSH
124207: LD_INT 1
124209: PPUSH
124210: CALL_OW 234
// end ;
124214: PPOPN 1
124216: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
124217: LD_EXP 148
124221: PUSH
124222: LD_EXP 196
124226: AND
124227: IFFALSE 124339
124229: GO 124231
124231: DISABLE
124232: LD_INT 0
124234: PPUSH
124235: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
124236: LD_ADDR_VAR 0 2
124240: PUSH
124241: LD_INT 22
124243: PUSH
124244: LD_OWVAR 2
124248: PUSH
124249: EMPTY
124250: LIST
124251: LIST
124252: PUSH
124253: LD_INT 2
124255: PUSH
124256: LD_INT 30
124258: PUSH
124259: LD_INT 27
124261: PUSH
124262: EMPTY
124263: LIST
124264: LIST
124265: PUSH
124266: LD_INT 30
124268: PUSH
124269: LD_INT 26
124271: PUSH
124272: EMPTY
124273: LIST
124274: LIST
124275: PUSH
124276: LD_INT 30
124278: PUSH
124279: LD_INT 28
124281: PUSH
124282: EMPTY
124283: LIST
124284: LIST
124285: PUSH
124286: EMPTY
124287: LIST
124288: LIST
124289: LIST
124290: LIST
124291: PUSH
124292: EMPTY
124293: LIST
124294: LIST
124295: PPUSH
124296: CALL_OW 69
124300: ST_TO_ADDR
// if not tmp then
124301: LD_VAR 0 2
124305: NOT
124306: IFFALSE 124310
// exit ;
124308: GO 124339
// for i in tmp do
124310: LD_ADDR_VAR 0 1
124314: PUSH
124315: LD_VAR 0 2
124319: PUSH
124320: FOR_IN
124321: IFFALSE 124337
// SetLives ( i , 1 ) ;
124323: LD_VAR 0 1
124327: PPUSH
124328: LD_INT 1
124330: PPUSH
124331: CALL_OW 234
124335: GO 124320
124337: POP
124338: POP
// end ;
124339: PPOPN 2
124341: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
124342: LD_EXP 148
124346: PUSH
124347: LD_EXP 197
124351: AND
124352: IFFALSE 124639
124354: GO 124356
124356: DISABLE
124357: LD_INT 0
124359: PPUSH
124360: PPUSH
124361: PPUSH
// begin i := rand ( 1 , 7 ) ;
124362: LD_ADDR_VAR 0 1
124366: PUSH
124367: LD_INT 1
124369: PPUSH
124370: LD_INT 7
124372: PPUSH
124373: CALL_OW 12
124377: ST_TO_ADDR
// case i of 1 :
124378: LD_VAR 0 1
124382: PUSH
124383: LD_INT 1
124385: DOUBLE
124386: EQUAL
124387: IFTRUE 124391
124389: GO 124401
124391: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
124392: LD_STRING earthquake(getX(game), 0, 32)
124394: PPUSH
124395: CALL_OW 559
124399: GO 124639
124401: LD_INT 2
124403: DOUBLE
124404: EQUAL
124405: IFTRUE 124409
124407: GO 124423
124409: POP
// begin ToLua ( displayStucuk(); ) ;
124410: LD_STRING displayStucuk();
124412: PPUSH
124413: CALL_OW 559
// ResetFog ;
124417: CALL_OW 335
// end ; 3 :
124421: GO 124639
124423: LD_INT 3
124425: DOUBLE
124426: EQUAL
124427: IFTRUE 124431
124429: GO 124535
124431: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
124432: LD_ADDR_VAR 0 2
124436: PUSH
124437: LD_INT 22
124439: PUSH
124440: LD_OWVAR 2
124444: PUSH
124445: EMPTY
124446: LIST
124447: LIST
124448: PUSH
124449: LD_INT 25
124451: PUSH
124452: LD_INT 1
124454: PUSH
124455: EMPTY
124456: LIST
124457: LIST
124458: PUSH
124459: EMPTY
124460: LIST
124461: LIST
124462: PPUSH
124463: CALL_OW 69
124467: ST_TO_ADDR
// if not tmp then
124468: LD_VAR 0 2
124472: NOT
124473: IFFALSE 124477
// exit ;
124475: GO 124639
// un := tmp [ rand ( 1 , tmp ) ] ;
124477: LD_ADDR_VAR 0 3
124481: PUSH
124482: LD_VAR 0 2
124486: PUSH
124487: LD_INT 1
124489: PPUSH
124490: LD_VAR 0 2
124494: PPUSH
124495: CALL_OW 12
124499: ARRAY
124500: ST_TO_ADDR
// if Crawls ( un ) then
124501: LD_VAR 0 3
124505: PPUSH
124506: CALL_OW 318
124510: IFFALSE 124521
// ComWalk ( un ) ;
124512: LD_VAR 0 3
124516: PPUSH
124517: CALL_OW 138
// SetClass ( un , class_mortar ) ;
124521: LD_VAR 0 3
124525: PPUSH
124526: LD_INT 8
124528: PPUSH
124529: CALL_OW 336
// end ; 4 :
124533: GO 124639
124535: LD_INT 4
124537: DOUBLE
124538: EQUAL
124539: IFTRUE 124543
124541: GO 124617
124543: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
124544: LD_ADDR_VAR 0 2
124548: PUSH
124549: LD_INT 22
124551: PUSH
124552: LD_OWVAR 2
124556: PUSH
124557: EMPTY
124558: LIST
124559: LIST
124560: PUSH
124561: LD_INT 30
124563: PUSH
124564: LD_INT 29
124566: PUSH
124567: EMPTY
124568: LIST
124569: LIST
124570: PUSH
124571: EMPTY
124572: LIST
124573: LIST
124574: PPUSH
124575: CALL_OW 69
124579: ST_TO_ADDR
// if not tmp then
124580: LD_VAR 0 2
124584: NOT
124585: IFFALSE 124589
// exit ;
124587: GO 124639
// CenterNowOnUnits ( tmp [ 1 ] ) ;
124589: LD_VAR 0 2
124593: PUSH
124594: LD_INT 1
124596: ARRAY
124597: PPUSH
124598: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
124602: LD_VAR 0 2
124606: PUSH
124607: LD_INT 1
124609: ARRAY
124610: PPUSH
124611: CALL_OW 65
// end ; 5 .. 7 :
124615: GO 124639
124617: LD_INT 5
124619: DOUBLE
124620: GREATEREQUAL
124621: IFFALSE 124629
124623: LD_INT 7
124625: DOUBLE
124626: LESSEQUAL
124627: IFTRUE 124631
124629: GO 124638
124631: POP
// StreamSibBomb ; end ;
124632: CALL 120876 0 0
124636: GO 124639
124638: POP
// end ;
124639: PPOPN 3
124641: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
124642: LD_EXP 148
124646: PUSH
124647: LD_EXP 198
124651: AND
124652: IFFALSE 124808
124654: GO 124656
124656: DISABLE
124657: LD_INT 0
124659: PPUSH
124660: PPUSH
124661: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
124662: LD_ADDR_VAR 0 2
124666: PUSH
124667: LD_INT 81
124669: PUSH
124670: LD_OWVAR 2
124674: PUSH
124675: EMPTY
124676: LIST
124677: LIST
124678: PUSH
124679: LD_INT 2
124681: PUSH
124682: LD_INT 21
124684: PUSH
124685: LD_INT 1
124687: PUSH
124688: EMPTY
124689: LIST
124690: LIST
124691: PUSH
124692: LD_INT 21
124694: PUSH
124695: LD_INT 2
124697: PUSH
124698: EMPTY
124699: LIST
124700: LIST
124701: PUSH
124702: EMPTY
124703: LIST
124704: LIST
124705: LIST
124706: PUSH
124707: EMPTY
124708: LIST
124709: LIST
124710: PPUSH
124711: CALL_OW 69
124715: ST_TO_ADDR
// if not tmp then
124716: LD_VAR 0 2
124720: NOT
124721: IFFALSE 124725
// exit ;
124723: GO 124808
// p := 0 ;
124725: LD_ADDR_VAR 0 3
124729: PUSH
124730: LD_INT 0
124732: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
124733: LD_INT 35
124735: PPUSH
124736: CALL_OW 67
// p := p + 1 ;
124740: LD_ADDR_VAR 0 3
124744: PUSH
124745: LD_VAR 0 3
124749: PUSH
124750: LD_INT 1
124752: PLUS
124753: ST_TO_ADDR
// for i in tmp do
124754: LD_ADDR_VAR 0 1
124758: PUSH
124759: LD_VAR 0 2
124763: PUSH
124764: FOR_IN
124765: IFFALSE 124796
// if GetLives ( i ) < 1000 then
124767: LD_VAR 0 1
124771: PPUSH
124772: CALL_OW 256
124776: PUSH
124777: LD_INT 1000
124779: LESS
124780: IFFALSE 124794
// SetLives ( i , 1000 ) ;
124782: LD_VAR 0 1
124786: PPUSH
124787: LD_INT 1000
124789: PPUSH
124790: CALL_OW 234
124794: GO 124764
124796: POP
124797: POP
// until p > 20 ;
124798: LD_VAR 0 3
124802: PUSH
124803: LD_INT 20
124805: GREATER
124806: IFFALSE 124733
// end ;
124808: PPOPN 3
124810: END
// every 0 0$1 trigger StreamModeActive and sTime do
124811: LD_EXP 148
124815: PUSH
124816: LD_EXP 199
124820: AND
124821: IFFALSE 124856
124823: GO 124825
124825: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
124826: LD_INT 28
124828: PPUSH
124829: LD_OWVAR 2
124833: PPUSH
124834: LD_INT 2
124836: PPUSH
124837: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
124841: LD_INT 30
124843: PPUSH
124844: LD_OWVAR 2
124848: PPUSH
124849: LD_INT 2
124851: PPUSH
124852: CALL_OW 322
// end ;
124856: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
124857: LD_EXP 148
124861: PUSH
124862: LD_EXP 200
124866: AND
124867: IFFALSE 124988
124869: GO 124871
124871: DISABLE
124872: LD_INT 0
124874: PPUSH
124875: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
124876: LD_ADDR_VAR 0 2
124880: PUSH
124881: LD_INT 22
124883: PUSH
124884: LD_OWVAR 2
124888: PUSH
124889: EMPTY
124890: LIST
124891: LIST
124892: PUSH
124893: LD_INT 21
124895: PUSH
124896: LD_INT 1
124898: PUSH
124899: EMPTY
124900: LIST
124901: LIST
124902: PUSH
124903: LD_INT 3
124905: PUSH
124906: LD_INT 23
124908: PUSH
124909: LD_INT 0
124911: PUSH
124912: EMPTY
124913: LIST
124914: LIST
124915: PUSH
124916: EMPTY
124917: LIST
124918: LIST
124919: PUSH
124920: EMPTY
124921: LIST
124922: LIST
124923: LIST
124924: PPUSH
124925: CALL_OW 69
124929: ST_TO_ADDR
// if not tmp then
124930: LD_VAR 0 2
124934: NOT
124935: IFFALSE 124939
// exit ;
124937: GO 124988
// for i in tmp do
124939: LD_ADDR_VAR 0 1
124943: PUSH
124944: LD_VAR 0 2
124948: PUSH
124949: FOR_IN
124950: IFFALSE 124986
// begin if Crawls ( i ) then
124952: LD_VAR 0 1
124956: PPUSH
124957: CALL_OW 318
124961: IFFALSE 124972
// ComWalk ( i ) ;
124963: LD_VAR 0 1
124967: PPUSH
124968: CALL_OW 138
// SetClass ( i , 2 ) ;
124972: LD_VAR 0 1
124976: PPUSH
124977: LD_INT 2
124979: PPUSH
124980: CALL_OW 336
// end ;
124984: GO 124949
124986: POP
124987: POP
// end ;
124988: PPOPN 2
124990: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
124991: LD_EXP 148
124995: PUSH
124996: LD_EXP 201
125000: AND
125001: IFFALSE 125289
125003: GO 125005
125005: DISABLE
125006: LD_INT 0
125008: PPUSH
125009: PPUSH
125010: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
125011: LD_OWVAR 2
125015: PPUSH
125016: LD_INT 9
125018: PPUSH
125019: LD_INT 1
125021: PPUSH
125022: LD_INT 1
125024: PPUSH
125025: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
125029: LD_INT 9
125031: PPUSH
125032: LD_OWVAR 2
125036: PPUSH
125037: CALL_OW 343
// uc_side := 9 ;
125041: LD_ADDR_OWVAR 20
125045: PUSH
125046: LD_INT 9
125048: ST_TO_ADDR
// uc_nation := 2 ;
125049: LD_ADDR_OWVAR 21
125053: PUSH
125054: LD_INT 2
125056: ST_TO_ADDR
// hc_name := Dark Warrior ;
125057: LD_ADDR_OWVAR 26
125061: PUSH
125062: LD_STRING Dark Warrior
125064: ST_TO_ADDR
// hc_gallery :=  ;
125065: LD_ADDR_OWVAR 33
125069: PUSH
125070: LD_STRING 
125072: ST_TO_ADDR
// hc_noskilllimit := true ;
125073: LD_ADDR_OWVAR 76
125077: PUSH
125078: LD_INT 1
125080: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
125081: LD_ADDR_OWVAR 31
125085: PUSH
125086: LD_INT 30
125088: PUSH
125089: LD_INT 30
125091: PUSH
125092: LD_INT 30
125094: PUSH
125095: LD_INT 30
125097: PUSH
125098: EMPTY
125099: LIST
125100: LIST
125101: LIST
125102: LIST
125103: ST_TO_ADDR
// un := CreateHuman ;
125104: LD_ADDR_VAR 0 3
125108: PUSH
125109: CALL_OW 44
125113: ST_TO_ADDR
// hc_noskilllimit := false ;
125114: LD_ADDR_OWVAR 76
125118: PUSH
125119: LD_INT 0
125121: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
125122: LD_VAR 0 3
125126: PPUSH
125127: LD_INT 1
125129: PPUSH
125130: CALL_OW 51
// ToLua ( playRanger() ) ;
125134: LD_STRING playRanger()
125136: PPUSH
125137: CALL_OW 559
// p := 0 ;
125141: LD_ADDR_VAR 0 2
125145: PUSH
125146: LD_INT 0
125148: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
125149: LD_INT 35
125151: PPUSH
125152: CALL_OW 67
// p := p + 1 ;
125156: LD_ADDR_VAR 0 2
125160: PUSH
125161: LD_VAR 0 2
125165: PUSH
125166: LD_INT 1
125168: PLUS
125169: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
125170: LD_VAR 0 3
125174: PPUSH
125175: CALL_OW 256
125179: PUSH
125180: LD_INT 1000
125182: LESS
125183: IFFALSE 125197
// SetLives ( un , 1000 ) ;
125185: LD_VAR 0 3
125189: PPUSH
125190: LD_INT 1000
125192: PPUSH
125193: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
125197: LD_VAR 0 3
125201: PPUSH
125202: LD_INT 81
125204: PUSH
125205: LD_OWVAR 2
125209: PUSH
125210: EMPTY
125211: LIST
125212: LIST
125213: PUSH
125214: LD_INT 91
125216: PUSH
125217: LD_VAR 0 3
125221: PUSH
125222: LD_INT 30
125224: PUSH
125225: EMPTY
125226: LIST
125227: LIST
125228: LIST
125229: PUSH
125230: EMPTY
125231: LIST
125232: LIST
125233: PPUSH
125234: CALL_OW 69
125238: PPUSH
125239: LD_VAR 0 3
125243: PPUSH
125244: CALL_OW 74
125248: PPUSH
125249: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
125253: LD_VAR 0 2
125257: PUSH
125258: LD_INT 80
125260: GREATER
125261: PUSH
125262: LD_VAR 0 3
125266: PPUSH
125267: CALL_OW 301
125271: OR
125272: IFFALSE 125149
// if un then
125274: LD_VAR 0 3
125278: IFFALSE 125289
// RemoveUnit ( un ) ;
125280: LD_VAR 0 3
125284: PPUSH
125285: CALL_OW 64
// end ;
125289: PPOPN 3
125291: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
125292: LD_EXP 202
125296: IFFALSE 125412
125298: GO 125300
125300: DISABLE
125301: LD_INT 0
125303: PPUSH
125304: PPUSH
125305: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
125306: LD_ADDR_VAR 0 2
125310: PUSH
125311: LD_INT 81
125313: PUSH
125314: LD_OWVAR 2
125318: PUSH
125319: EMPTY
125320: LIST
125321: LIST
125322: PUSH
125323: LD_INT 21
125325: PUSH
125326: LD_INT 1
125328: PUSH
125329: EMPTY
125330: LIST
125331: LIST
125332: PUSH
125333: EMPTY
125334: LIST
125335: LIST
125336: PPUSH
125337: CALL_OW 69
125341: ST_TO_ADDR
// ToLua ( playComputer() ) ;
125342: LD_STRING playComputer()
125344: PPUSH
125345: CALL_OW 559
// if not tmp then
125349: LD_VAR 0 2
125353: NOT
125354: IFFALSE 125358
// exit ;
125356: GO 125412
// for i in tmp do
125358: LD_ADDR_VAR 0 1
125362: PUSH
125363: LD_VAR 0 2
125367: PUSH
125368: FOR_IN
125369: IFFALSE 125410
// for j := 1 to 4 do
125371: LD_ADDR_VAR 0 3
125375: PUSH
125376: DOUBLE
125377: LD_INT 1
125379: DEC
125380: ST_TO_ADDR
125381: LD_INT 4
125383: PUSH
125384: FOR_TO
125385: IFFALSE 125406
// SetSkill ( i , j , 10 ) ;
125387: LD_VAR 0 1
125391: PPUSH
125392: LD_VAR 0 3
125396: PPUSH
125397: LD_INT 10
125399: PPUSH
125400: CALL_OW 237
125404: GO 125384
125406: POP
125407: POP
125408: GO 125368
125410: POP
125411: POP
// end ;
125412: PPOPN 3
125414: END
// every 0 0$1 trigger s30 do var i , tmp ;
125415: LD_EXP 203
125419: IFFALSE 125488
125421: GO 125423
125423: DISABLE
125424: LD_INT 0
125426: PPUSH
125427: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
125428: LD_ADDR_VAR 0 2
125432: PUSH
125433: LD_INT 22
125435: PUSH
125436: LD_OWVAR 2
125440: PUSH
125441: EMPTY
125442: LIST
125443: LIST
125444: PPUSH
125445: CALL_OW 69
125449: ST_TO_ADDR
// if not tmp then
125450: LD_VAR 0 2
125454: NOT
125455: IFFALSE 125459
// exit ;
125457: GO 125488
// for i in tmp do
125459: LD_ADDR_VAR 0 1
125463: PUSH
125464: LD_VAR 0 2
125468: PUSH
125469: FOR_IN
125470: IFFALSE 125486
// SetLives ( i , 300 ) ;
125472: LD_VAR 0 1
125476: PPUSH
125477: LD_INT 300
125479: PPUSH
125480: CALL_OW 234
125484: GO 125469
125486: POP
125487: POP
// end ;
125488: PPOPN 2
125490: END
// every 0 0$1 trigger s60 do var i , tmp ;
125491: LD_EXP 204
125495: IFFALSE 125564
125497: GO 125499
125499: DISABLE
125500: LD_INT 0
125502: PPUSH
125503: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
125504: LD_ADDR_VAR 0 2
125508: PUSH
125509: LD_INT 22
125511: PUSH
125512: LD_OWVAR 2
125516: PUSH
125517: EMPTY
125518: LIST
125519: LIST
125520: PPUSH
125521: CALL_OW 69
125525: ST_TO_ADDR
// if not tmp then
125526: LD_VAR 0 2
125530: NOT
125531: IFFALSE 125535
// exit ;
125533: GO 125564
// for i in tmp do
125535: LD_ADDR_VAR 0 1
125539: PUSH
125540: LD_VAR 0 2
125544: PUSH
125545: FOR_IN
125546: IFFALSE 125562
// SetLives ( i , 600 ) ;
125548: LD_VAR 0 1
125552: PPUSH
125553: LD_INT 600
125555: PPUSH
125556: CALL_OW 234
125560: GO 125545
125562: POP
125563: POP
// end ;
125564: PPOPN 2
125566: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
125567: LD_INT 0
125569: PPUSH
// case cmd of 301 :
125570: LD_VAR 0 1
125574: PUSH
125575: LD_INT 301
125577: DOUBLE
125578: EQUAL
125579: IFTRUE 125583
125581: GO 125615
125583: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
125584: LD_VAR 0 6
125588: PPUSH
125589: LD_VAR 0 7
125593: PPUSH
125594: LD_VAR 0 8
125598: PPUSH
125599: LD_VAR 0 4
125603: PPUSH
125604: LD_VAR 0 5
125608: PPUSH
125609: CALL 126824 0 5
125613: GO 125736
125615: LD_INT 302
125617: DOUBLE
125618: EQUAL
125619: IFTRUE 125623
125621: GO 125660
125623: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
125624: LD_VAR 0 6
125628: PPUSH
125629: LD_VAR 0 7
125633: PPUSH
125634: LD_VAR 0 8
125638: PPUSH
125639: LD_VAR 0 9
125643: PPUSH
125644: LD_VAR 0 4
125648: PPUSH
125649: LD_VAR 0 5
125653: PPUSH
125654: CALL 126915 0 6
125658: GO 125736
125660: LD_INT 303
125662: DOUBLE
125663: EQUAL
125664: IFTRUE 125668
125666: GO 125705
125668: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
125669: LD_VAR 0 6
125673: PPUSH
125674: LD_VAR 0 7
125678: PPUSH
125679: LD_VAR 0 8
125683: PPUSH
125684: LD_VAR 0 9
125688: PPUSH
125689: LD_VAR 0 4
125693: PPUSH
125694: LD_VAR 0 5
125698: PPUSH
125699: CALL 125741 0 6
125703: GO 125736
125705: LD_INT 304
125707: DOUBLE
125708: EQUAL
125709: IFTRUE 125713
125711: GO 125735
125713: POP
// hHackTeleport ( unit , x , y ) ; end ;
125714: LD_VAR 0 2
125718: PPUSH
125719: LD_VAR 0 4
125723: PPUSH
125724: LD_VAR 0 5
125728: PPUSH
125729: CALL 127508 0 3
125733: GO 125736
125735: POP
// end ;
125736: LD_VAR 0 12
125740: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
125741: LD_INT 0
125743: PPUSH
125744: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
125745: LD_VAR 0 1
125749: PUSH
125750: LD_INT 1
125752: LESS
125753: PUSH
125754: LD_VAR 0 1
125758: PUSH
125759: LD_INT 3
125761: GREATER
125762: OR
125763: PUSH
125764: LD_VAR 0 5
125768: PPUSH
125769: LD_VAR 0 6
125773: PPUSH
125774: CALL_OW 428
125778: OR
125779: IFFALSE 125783
// exit ;
125781: GO 126511
// uc_side := your_side ;
125783: LD_ADDR_OWVAR 20
125787: PUSH
125788: LD_OWVAR 2
125792: ST_TO_ADDR
// uc_nation := nation ;
125793: LD_ADDR_OWVAR 21
125797: PUSH
125798: LD_VAR 0 1
125802: ST_TO_ADDR
// bc_level = 1 ;
125803: LD_ADDR_OWVAR 43
125807: PUSH
125808: LD_INT 1
125810: ST_TO_ADDR
// case btype of 1 :
125811: LD_VAR 0 2
125815: PUSH
125816: LD_INT 1
125818: DOUBLE
125819: EQUAL
125820: IFTRUE 125824
125822: GO 125835
125824: POP
// bc_type := b_depot ; 2 :
125825: LD_ADDR_OWVAR 42
125829: PUSH
125830: LD_INT 0
125832: ST_TO_ADDR
125833: GO 126455
125835: LD_INT 2
125837: DOUBLE
125838: EQUAL
125839: IFTRUE 125843
125841: GO 125854
125843: POP
// bc_type := b_warehouse ; 3 :
125844: LD_ADDR_OWVAR 42
125848: PUSH
125849: LD_INT 1
125851: ST_TO_ADDR
125852: GO 126455
125854: LD_INT 3
125856: DOUBLE
125857: EQUAL
125858: IFTRUE 125862
125860: GO 125873
125862: POP
// bc_type := b_lab ; 4 .. 9 :
125863: LD_ADDR_OWVAR 42
125867: PUSH
125868: LD_INT 6
125870: ST_TO_ADDR
125871: GO 126455
125873: LD_INT 4
125875: DOUBLE
125876: GREATEREQUAL
125877: IFFALSE 125885
125879: LD_INT 9
125881: DOUBLE
125882: LESSEQUAL
125883: IFTRUE 125887
125885: GO 125947
125887: POP
// begin bc_type := b_lab_half ;
125888: LD_ADDR_OWVAR 42
125892: PUSH
125893: LD_INT 7
125895: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
125896: LD_ADDR_OWVAR 44
125900: PUSH
125901: LD_INT 10
125903: PUSH
125904: LD_INT 11
125906: PUSH
125907: LD_INT 12
125909: PUSH
125910: LD_INT 15
125912: PUSH
125913: LD_INT 14
125915: PUSH
125916: LD_INT 13
125918: PUSH
125919: EMPTY
125920: LIST
125921: LIST
125922: LIST
125923: LIST
125924: LIST
125925: LIST
125926: PUSH
125927: LD_VAR 0 2
125931: PUSH
125932: LD_INT 3
125934: MINUS
125935: ARRAY
125936: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
125937: LD_ADDR_OWVAR 45
125941: PUSH
125942: LD_INT 9
125944: ST_TO_ADDR
// end ; 10 .. 13 :
125945: GO 126455
125947: LD_INT 10
125949: DOUBLE
125950: GREATEREQUAL
125951: IFFALSE 125959
125953: LD_INT 13
125955: DOUBLE
125956: LESSEQUAL
125957: IFTRUE 125961
125959: GO 126038
125961: POP
// begin bc_type := b_lab_full ;
125962: LD_ADDR_OWVAR 42
125966: PUSH
125967: LD_INT 8
125969: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
125970: LD_ADDR_OWVAR 44
125974: PUSH
125975: LD_INT 10
125977: PUSH
125978: LD_INT 12
125980: PUSH
125981: LD_INT 14
125983: PUSH
125984: LD_INT 13
125986: PUSH
125987: EMPTY
125988: LIST
125989: LIST
125990: LIST
125991: LIST
125992: PUSH
125993: LD_VAR 0 2
125997: PUSH
125998: LD_INT 9
126000: MINUS
126001: ARRAY
126002: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
126003: LD_ADDR_OWVAR 45
126007: PUSH
126008: LD_INT 11
126010: PUSH
126011: LD_INT 15
126013: PUSH
126014: LD_INT 12
126016: PUSH
126017: LD_INT 15
126019: PUSH
126020: EMPTY
126021: LIST
126022: LIST
126023: LIST
126024: LIST
126025: PUSH
126026: LD_VAR 0 2
126030: PUSH
126031: LD_INT 9
126033: MINUS
126034: ARRAY
126035: ST_TO_ADDR
// end ; 14 :
126036: GO 126455
126038: LD_INT 14
126040: DOUBLE
126041: EQUAL
126042: IFTRUE 126046
126044: GO 126057
126046: POP
// bc_type := b_workshop ; 15 :
126047: LD_ADDR_OWVAR 42
126051: PUSH
126052: LD_INT 2
126054: ST_TO_ADDR
126055: GO 126455
126057: LD_INT 15
126059: DOUBLE
126060: EQUAL
126061: IFTRUE 126065
126063: GO 126076
126065: POP
// bc_type := b_factory ; 16 :
126066: LD_ADDR_OWVAR 42
126070: PUSH
126071: LD_INT 3
126073: ST_TO_ADDR
126074: GO 126455
126076: LD_INT 16
126078: DOUBLE
126079: EQUAL
126080: IFTRUE 126084
126082: GO 126095
126084: POP
// bc_type := b_ext_gun ; 17 :
126085: LD_ADDR_OWVAR 42
126089: PUSH
126090: LD_INT 17
126092: ST_TO_ADDR
126093: GO 126455
126095: LD_INT 17
126097: DOUBLE
126098: EQUAL
126099: IFTRUE 126103
126101: GO 126131
126103: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
126104: LD_ADDR_OWVAR 42
126108: PUSH
126109: LD_INT 19
126111: PUSH
126112: LD_INT 23
126114: PUSH
126115: LD_INT 19
126117: PUSH
126118: EMPTY
126119: LIST
126120: LIST
126121: LIST
126122: PUSH
126123: LD_VAR 0 1
126127: ARRAY
126128: ST_TO_ADDR
126129: GO 126455
126131: LD_INT 18
126133: DOUBLE
126134: EQUAL
126135: IFTRUE 126139
126137: GO 126150
126139: POP
// bc_type := b_ext_radar ; 19 :
126140: LD_ADDR_OWVAR 42
126144: PUSH
126145: LD_INT 20
126147: ST_TO_ADDR
126148: GO 126455
126150: LD_INT 19
126152: DOUBLE
126153: EQUAL
126154: IFTRUE 126158
126156: GO 126169
126158: POP
// bc_type := b_ext_radio ; 20 :
126159: LD_ADDR_OWVAR 42
126163: PUSH
126164: LD_INT 22
126166: ST_TO_ADDR
126167: GO 126455
126169: LD_INT 20
126171: DOUBLE
126172: EQUAL
126173: IFTRUE 126177
126175: GO 126188
126177: POP
// bc_type := b_ext_siberium ; 21 :
126178: LD_ADDR_OWVAR 42
126182: PUSH
126183: LD_INT 21
126185: ST_TO_ADDR
126186: GO 126455
126188: LD_INT 21
126190: DOUBLE
126191: EQUAL
126192: IFTRUE 126196
126194: GO 126207
126196: POP
// bc_type := b_ext_computer ; 22 :
126197: LD_ADDR_OWVAR 42
126201: PUSH
126202: LD_INT 24
126204: ST_TO_ADDR
126205: GO 126455
126207: LD_INT 22
126209: DOUBLE
126210: EQUAL
126211: IFTRUE 126215
126213: GO 126226
126215: POP
// bc_type := b_ext_track ; 23 :
126216: LD_ADDR_OWVAR 42
126220: PUSH
126221: LD_INT 16
126223: ST_TO_ADDR
126224: GO 126455
126226: LD_INT 23
126228: DOUBLE
126229: EQUAL
126230: IFTRUE 126234
126232: GO 126245
126234: POP
// bc_type := b_ext_laser ; 24 :
126235: LD_ADDR_OWVAR 42
126239: PUSH
126240: LD_INT 25
126242: ST_TO_ADDR
126243: GO 126455
126245: LD_INT 24
126247: DOUBLE
126248: EQUAL
126249: IFTRUE 126253
126251: GO 126264
126253: POP
// bc_type := b_control_tower ; 25 :
126254: LD_ADDR_OWVAR 42
126258: PUSH
126259: LD_INT 36
126261: ST_TO_ADDR
126262: GO 126455
126264: LD_INT 25
126266: DOUBLE
126267: EQUAL
126268: IFTRUE 126272
126270: GO 126283
126272: POP
// bc_type := b_breastwork ; 26 :
126273: LD_ADDR_OWVAR 42
126277: PUSH
126278: LD_INT 31
126280: ST_TO_ADDR
126281: GO 126455
126283: LD_INT 26
126285: DOUBLE
126286: EQUAL
126287: IFTRUE 126291
126289: GO 126302
126291: POP
// bc_type := b_bunker ; 27 :
126292: LD_ADDR_OWVAR 42
126296: PUSH
126297: LD_INT 32
126299: ST_TO_ADDR
126300: GO 126455
126302: LD_INT 27
126304: DOUBLE
126305: EQUAL
126306: IFTRUE 126310
126308: GO 126321
126310: POP
// bc_type := b_turret ; 28 :
126311: LD_ADDR_OWVAR 42
126315: PUSH
126316: LD_INT 33
126318: ST_TO_ADDR
126319: GO 126455
126321: LD_INT 28
126323: DOUBLE
126324: EQUAL
126325: IFTRUE 126329
126327: GO 126340
126329: POP
// bc_type := b_armoury ; 29 :
126330: LD_ADDR_OWVAR 42
126334: PUSH
126335: LD_INT 4
126337: ST_TO_ADDR
126338: GO 126455
126340: LD_INT 29
126342: DOUBLE
126343: EQUAL
126344: IFTRUE 126348
126346: GO 126359
126348: POP
// bc_type := b_barracks ; 30 :
126349: LD_ADDR_OWVAR 42
126353: PUSH
126354: LD_INT 5
126356: ST_TO_ADDR
126357: GO 126455
126359: LD_INT 30
126361: DOUBLE
126362: EQUAL
126363: IFTRUE 126367
126365: GO 126378
126367: POP
// bc_type := b_solar_power ; 31 :
126368: LD_ADDR_OWVAR 42
126372: PUSH
126373: LD_INT 27
126375: ST_TO_ADDR
126376: GO 126455
126378: LD_INT 31
126380: DOUBLE
126381: EQUAL
126382: IFTRUE 126386
126384: GO 126397
126386: POP
// bc_type := b_oil_power ; 32 :
126387: LD_ADDR_OWVAR 42
126391: PUSH
126392: LD_INT 26
126394: ST_TO_ADDR
126395: GO 126455
126397: LD_INT 32
126399: DOUBLE
126400: EQUAL
126401: IFTRUE 126405
126403: GO 126416
126405: POP
// bc_type := b_siberite_power ; 33 :
126406: LD_ADDR_OWVAR 42
126410: PUSH
126411: LD_INT 28
126413: ST_TO_ADDR
126414: GO 126455
126416: LD_INT 33
126418: DOUBLE
126419: EQUAL
126420: IFTRUE 126424
126422: GO 126435
126424: POP
// bc_type := b_oil_mine ; 34 :
126425: LD_ADDR_OWVAR 42
126429: PUSH
126430: LD_INT 29
126432: ST_TO_ADDR
126433: GO 126455
126435: LD_INT 34
126437: DOUBLE
126438: EQUAL
126439: IFTRUE 126443
126441: GO 126454
126443: POP
// bc_type := b_siberite_mine ; end ;
126444: LD_ADDR_OWVAR 42
126448: PUSH
126449: LD_INT 30
126451: ST_TO_ADDR
126452: GO 126455
126454: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
126455: LD_ADDR_VAR 0 8
126459: PUSH
126460: LD_VAR 0 5
126464: PPUSH
126465: LD_VAR 0 6
126469: PPUSH
126470: LD_VAR 0 3
126474: PPUSH
126475: CALL_OW 47
126479: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
126480: LD_OWVAR 42
126484: PUSH
126485: LD_INT 32
126487: PUSH
126488: LD_INT 33
126490: PUSH
126491: EMPTY
126492: LIST
126493: LIST
126494: IN
126495: IFFALSE 126511
// PlaceWeaponTurret ( b , weapon ) ;
126497: LD_VAR 0 8
126501: PPUSH
126502: LD_VAR 0 4
126506: PPUSH
126507: CALL_OW 431
// end ;
126511: LD_VAR 0 7
126515: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
126516: LD_INT 0
126518: PPUSH
126519: PPUSH
126520: PPUSH
126521: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
126522: LD_ADDR_VAR 0 4
126526: PUSH
126527: LD_INT 22
126529: PUSH
126530: LD_OWVAR 2
126534: PUSH
126535: EMPTY
126536: LIST
126537: LIST
126538: PUSH
126539: LD_INT 2
126541: PUSH
126542: LD_INT 30
126544: PUSH
126545: LD_INT 0
126547: PUSH
126548: EMPTY
126549: LIST
126550: LIST
126551: PUSH
126552: LD_INT 30
126554: PUSH
126555: LD_INT 1
126557: PUSH
126558: EMPTY
126559: LIST
126560: LIST
126561: PUSH
126562: EMPTY
126563: LIST
126564: LIST
126565: LIST
126566: PUSH
126567: EMPTY
126568: LIST
126569: LIST
126570: PPUSH
126571: CALL_OW 69
126575: ST_TO_ADDR
// if not tmp then
126576: LD_VAR 0 4
126580: NOT
126581: IFFALSE 126585
// exit ;
126583: GO 126644
// for i in tmp do
126585: LD_ADDR_VAR 0 2
126589: PUSH
126590: LD_VAR 0 4
126594: PUSH
126595: FOR_IN
126596: IFFALSE 126642
// for j = 1 to 3 do
126598: LD_ADDR_VAR 0 3
126602: PUSH
126603: DOUBLE
126604: LD_INT 1
126606: DEC
126607: ST_TO_ADDR
126608: LD_INT 3
126610: PUSH
126611: FOR_TO
126612: IFFALSE 126638
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
126614: LD_VAR 0 2
126618: PPUSH
126619: CALL_OW 274
126623: PPUSH
126624: LD_VAR 0 3
126628: PPUSH
126629: LD_INT 99999
126631: PPUSH
126632: CALL_OW 277
126636: GO 126611
126638: POP
126639: POP
126640: GO 126595
126642: POP
126643: POP
// end ;
126644: LD_VAR 0 1
126648: RET
// export function hHackSetLevel10 ; var i , j ; begin
126649: LD_INT 0
126651: PPUSH
126652: PPUSH
126653: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
126654: LD_ADDR_VAR 0 2
126658: PUSH
126659: LD_INT 21
126661: PUSH
126662: LD_INT 1
126664: PUSH
126665: EMPTY
126666: LIST
126667: LIST
126668: PPUSH
126669: CALL_OW 69
126673: PUSH
126674: FOR_IN
126675: IFFALSE 126727
// if IsSelected ( i ) then
126677: LD_VAR 0 2
126681: PPUSH
126682: CALL_OW 306
126686: IFFALSE 126725
// begin for j := 1 to 4 do
126688: LD_ADDR_VAR 0 3
126692: PUSH
126693: DOUBLE
126694: LD_INT 1
126696: DEC
126697: ST_TO_ADDR
126698: LD_INT 4
126700: PUSH
126701: FOR_TO
126702: IFFALSE 126723
// SetSkill ( i , j , 10 ) ;
126704: LD_VAR 0 2
126708: PPUSH
126709: LD_VAR 0 3
126713: PPUSH
126714: LD_INT 10
126716: PPUSH
126717: CALL_OW 237
126721: GO 126701
126723: POP
126724: POP
// end ;
126725: GO 126674
126727: POP
126728: POP
// end ;
126729: LD_VAR 0 1
126733: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
126734: LD_INT 0
126736: PPUSH
126737: PPUSH
126738: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
126739: LD_ADDR_VAR 0 2
126743: PUSH
126744: LD_INT 22
126746: PUSH
126747: LD_OWVAR 2
126751: PUSH
126752: EMPTY
126753: LIST
126754: LIST
126755: PUSH
126756: LD_INT 21
126758: PUSH
126759: LD_INT 1
126761: PUSH
126762: EMPTY
126763: LIST
126764: LIST
126765: PUSH
126766: EMPTY
126767: LIST
126768: LIST
126769: PPUSH
126770: CALL_OW 69
126774: PUSH
126775: FOR_IN
126776: IFFALSE 126817
// begin for j := 1 to 4 do
126778: LD_ADDR_VAR 0 3
126782: PUSH
126783: DOUBLE
126784: LD_INT 1
126786: DEC
126787: ST_TO_ADDR
126788: LD_INT 4
126790: PUSH
126791: FOR_TO
126792: IFFALSE 126813
// SetSkill ( i , j , 10 ) ;
126794: LD_VAR 0 2
126798: PPUSH
126799: LD_VAR 0 3
126803: PPUSH
126804: LD_INT 10
126806: PPUSH
126807: CALL_OW 237
126811: GO 126791
126813: POP
126814: POP
// end ;
126815: GO 126775
126817: POP
126818: POP
// end ;
126819: LD_VAR 0 1
126823: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
126824: LD_INT 0
126826: PPUSH
// uc_side := your_side ;
126827: LD_ADDR_OWVAR 20
126831: PUSH
126832: LD_OWVAR 2
126836: ST_TO_ADDR
// uc_nation := nation ;
126837: LD_ADDR_OWVAR 21
126841: PUSH
126842: LD_VAR 0 1
126846: ST_TO_ADDR
// InitHc ;
126847: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
126851: LD_INT 0
126853: PPUSH
126854: LD_VAR 0 2
126858: PPUSH
126859: LD_VAR 0 3
126863: PPUSH
126864: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
126868: LD_VAR 0 4
126872: PPUSH
126873: LD_VAR 0 5
126877: PPUSH
126878: CALL_OW 428
126882: PUSH
126883: LD_INT 0
126885: EQUAL
126886: IFFALSE 126910
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
126888: CALL_OW 44
126892: PPUSH
126893: LD_VAR 0 4
126897: PPUSH
126898: LD_VAR 0 5
126902: PPUSH
126903: LD_INT 1
126905: PPUSH
126906: CALL_OW 48
// end ;
126910: LD_VAR 0 6
126914: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
126915: LD_INT 0
126917: PPUSH
126918: PPUSH
// uc_side := your_side ;
126919: LD_ADDR_OWVAR 20
126923: PUSH
126924: LD_OWVAR 2
126928: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
126929: LD_VAR 0 1
126933: PUSH
126934: LD_INT 1
126936: PUSH
126937: LD_INT 2
126939: PUSH
126940: LD_INT 3
126942: PUSH
126943: LD_INT 4
126945: PUSH
126946: LD_INT 5
126948: PUSH
126949: EMPTY
126950: LIST
126951: LIST
126952: LIST
126953: LIST
126954: LIST
126955: IN
126956: IFFALSE 126968
// uc_nation := nation_american else
126958: LD_ADDR_OWVAR 21
126962: PUSH
126963: LD_INT 1
126965: ST_TO_ADDR
126966: GO 127011
// if chassis in [ 11 , 12 , 13 , 14 ] then
126968: LD_VAR 0 1
126972: PUSH
126973: LD_INT 11
126975: PUSH
126976: LD_INT 12
126978: PUSH
126979: LD_INT 13
126981: PUSH
126982: LD_INT 14
126984: PUSH
126985: EMPTY
126986: LIST
126987: LIST
126988: LIST
126989: LIST
126990: IN
126991: IFFALSE 127003
// uc_nation := nation_arabian else
126993: LD_ADDR_OWVAR 21
126997: PUSH
126998: LD_INT 2
127000: ST_TO_ADDR
127001: GO 127011
// uc_nation := nation_russian ;
127003: LD_ADDR_OWVAR 21
127007: PUSH
127008: LD_INT 3
127010: ST_TO_ADDR
// vc_chassis := chassis ;
127011: LD_ADDR_OWVAR 37
127015: PUSH
127016: LD_VAR 0 1
127020: ST_TO_ADDR
// vc_engine := engine ;
127021: LD_ADDR_OWVAR 39
127025: PUSH
127026: LD_VAR 0 2
127030: ST_TO_ADDR
// vc_control := control ;
127031: LD_ADDR_OWVAR 38
127035: PUSH
127036: LD_VAR 0 3
127040: ST_TO_ADDR
// vc_weapon := weapon ;
127041: LD_ADDR_OWVAR 40
127045: PUSH
127046: LD_VAR 0 4
127050: ST_TO_ADDR
// un := CreateVehicle ;
127051: LD_ADDR_VAR 0 8
127055: PUSH
127056: CALL_OW 45
127060: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
127061: LD_VAR 0 8
127065: PPUSH
127066: LD_INT 0
127068: PPUSH
127069: LD_INT 5
127071: PPUSH
127072: CALL_OW 12
127076: PPUSH
127077: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
127081: LD_VAR 0 8
127085: PPUSH
127086: LD_VAR 0 5
127090: PPUSH
127091: LD_VAR 0 6
127095: PPUSH
127096: LD_INT 1
127098: PPUSH
127099: CALL_OW 48
// end ;
127103: LD_VAR 0 7
127107: RET
// export hInvincible ; every 1 do
127108: GO 127110
127110: DISABLE
// hInvincible := [ ] ;
127111: LD_ADDR_EXP 205
127115: PUSH
127116: EMPTY
127117: ST_TO_ADDR
127118: END
// every 10 do var i ;
127119: GO 127121
127121: DISABLE
127122: LD_INT 0
127124: PPUSH
// begin enable ;
127125: ENABLE
// if not hInvincible then
127126: LD_EXP 205
127130: NOT
127131: IFFALSE 127135
// exit ;
127133: GO 127179
// for i in hInvincible do
127135: LD_ADDR_VAR 0 1
127139: PUSH
127140: LD_EXP 205
127144: PUSH
127145: FOR_IN
127146: IFFALSE 127177
// if GetLives ( i ) < 1000 then
127148: LD_VAR 0 1
127152: PPUSH
127153: CALL_OW 256
127157: PUSH
127158: LD_INT 1000
127160: LESS
127161: IFFALSE 127175
// SetLives ( i , 1000 ) ;
127163: LD_VAR 0 1
127167: PPUSH
127168: LD_INT 1000
127170: PPUSH
127171: CALL_OW 234
127175: GO 127145
127177: POP
127178: POP
// end ;
127179: PPOPN 1
127181: END
// export function hHackInvincible ; var i ; begin
127182: LD_INT 0
127184: PPUSH
127185: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
127186: LD_ADDR_VAR 0 2
127190: PUSH
127191: LD_INT 2
127193: PUSH
127194: LD_INT 21
127196: PUSH
127197: LD_INT 1
127199: PUSH
127200: EMPTY
127201: LIST
127202: LIST
127203: PUSH
127204: LD_INT 21
127206: PUSH
127207: LD_INT 2
127209: PUSH
127210: EMPTY
127211: LIST
127212: LIST
127213: PUSH
127214: EMPTY
127215: LIST
127216: LIST
127217: LIST
127218: PPUSH
127219: CALL_OW 69
127223: PUSH
127224: FOR_IN
127225: IFFALSE 127286
// if IsSelected ( i ) then
127227: LD_VAR 0 2
127231: PPUSH
127232: CALL_OW 306
127236: IFFALSE 127284
// begin if i in hInvincible then
127238: LD_VAR 0 2
127242: PUSH
127243: LD_EXP 205
127247: IN
127248: IFFALSE 127268
// hInvincible := hInvincible diff i else
127250: LD_ADDR_EXP 205
127254: PUSH
127255: LD_EXP 205
127259: PUSH
127260: LD_VAR 0 2
127264: DIFF
127265: ST_TO_ADDR
127266: GO 127284
// hInvincible := hInvincible union i ;
127268: LD_ADDR_EXP 205
127272: PUSH
127273: LD_EXP 205
127277: PUSH
127278: LD_VAR 0 2
127282: UNION
127283: ST_TO_ADDR
// end ;
127284: GO 127224
127286: POP
127287: POP
// end ;
127288: LD_VAR 0 1
127292: RET
// export function hHackInvisible ; var i , j ; begin
127293: LD_INT 0
127295: PPUSH
127296: PPUSH
127297: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
127298: LD_ADDR_VAR 0 2
127302: PUSH
127303: LD_INT 21
127305: PUSH
127306: LD_INT 1
127308: PUSH
127309: EMPTY
127310: LIST
127311: LIST
127312: PPUSH
127313: CALL_OW 69
127317: PUSH
127318: FOR_IN
127319: IFFALSE 127343
// if IsSelected ( i ) then
127321: LD_VAR 0 2
127325: PPUSH
127326: CALL_OW 306
127330: IFFALSE 127341
// ComForceInvisible ( i ) ;
127332: LD_VAR 0 2
127336: PPUSH
127337: CALL_OW 496
127341: GO 127318
127343: POP
127344: POP
// end ;
127345: LD_VAR 0 1
127349: RET
// export function hHackChangeYourSide ; begin
127350: LD_INT 0
127352: PPUSH
// if your_side = 8 then
127353: LD_OWVAR 2
127357: PUSH
127358: LD_INT 8
127360: EQUAL
127361: IFFALSE 127373
// your_side := 0 else
127363: LD_ADDR_OWVAR 2
127367: PUSH
127368: LD_INT 0
127370: ST_TO_ADDR
127371: GO 127387
// your_side := your_side + 1 ;
127373: LD_ADDR_OWVAR 2
127377: PUSH
127378: LD_OWVAR 2
127382: PUSH
127383: LD_INT 1
127385: PLUS
127386: ST_TO_ADDR
// end ;
127387: LD_VAR 0 1
127391: RET
// export function hHackChangeUnitSide ; var i , j ; begin
127392: LD_INT 0
127394: PPUSH
127395: PPUSH
127396: PPUSH
// for i in all_units do
127397: LD_ADDR_VAR 0 2
127401: PUSH
127402: LD_OWVAR 3
127406: PUSH
127407: FOR_IN
127408: IFFALSE 127486
// if IsSelected ( i ) then
127410: LD_VAR 0 2
127414: PPUSH
127415: CALL_OW 306
127419: IFFALSE 127484
// begin j := GetSide ( i ) ;
127421: LD_ADDR_VAR 0 3
127425: PUSH
127426: LD_VAR 0 2
127430: PPUSH
127431: CALL_OW 255
127435: ST_TO_ADDR
// if j = 8 then
127436: LD_VAR 0 3
127440: PUSH
127441: LD_INT 8
127443: EQUAL
127444: IFFALSE 127456
// j := 0 else
127446: LD_ADDR_VAR 0 3
127450: PUSH
127451: LD_INT 0
127453: ST_TO_ADDR
127454: GO 127470
// j := j + 1 ;
127456: LD_ADDR_VAR 0 3
127460: PUSH
127461: LD_VAR 0 3
127465: PUSH
127466: LD_INT 1
127468: PLUS
127469: ST_TO_ADDR
// SetSide ( i , j ) ;
127470: LD_VAR 0 2
127474: PPUSH
127475: LD_VAR 0 3
127479: PPUSH
127480: CALL_OW 235
// end ;
127484: GO 127407
127486: POP
127487: POP
// end ;
127488: LD_VAR 0 1
127492: RET
// export function hHackFog ; begin
127493: LD_INT 0
127495: PPUSH
// FogOff ( true ) ;
127496: LD_INT 1
127498: PPUSH
127499: CALL_OW 344
// end ;
127503: LD_VAR 0 1
127507: RET
// export function hHackTeleport ( unit , x , y ) ; begin
127508: LD_INT 0
127510: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
127511: LD_VAR 0 1
127515: PPUSH
127516: LD_VAR 0 2
127520: PPUSH
127521: LD_VAR 0 3
127525: PPUSH
127526: LD_INT 1
127528: PPUSH
127529: LD_INT 1
127531: PPUSH
127532: CALL_OW 483
// CenterOnXY ( x , y ) ;
127536: LD_VAR 0 2
127540: PPUSH
127541: LD_VAR 0 3
127545: PPUSH
127546: CALL_OW 84
// end ;
127550: LD_VAR 0 4
127554: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
127555: LD_INT 0
127557: PPUSH
127558: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
127559: LD_VAR 0 1
127563: NOT
127564: PUSH
127565: LD_VAR 0 2
127569: PPUSH
127570: LD_VAR 0 3
127574: PPUSH
127575: CALL_OW 488
127579: NOT
127580: OR
127581: PUSH
127582: LD_VAR 0 1
127586: PPUSH
127587: CALL_OW 266
127591: PUSH
127592: LD_INT 3
127594: NONEQUAL
127595: PUSH
127596: LD_VAR 0 1
127600: PPUSH
127601: CALL_OW 247
127605: PUSH
127606: LD_INT 1
127608: EQUAL
127609: NOT
127610: AND
127611: OR
127612: IFFALSE 127616
// exit ;
127614: GO 127765
// if GetType ( factory ) = unit_human then
127616: LD_VAR 0 1
127620: PPUSH
127621: CALL_OW 247
127625: PUSH
127626: LD_INT 1
127628: EQUAL
127629: IFFALSE 127646
// factory := IsInUnit ( factory ) ;
127631: LD_ADDR_VAR 0 1
127635: PUSH
127636: LD_VAR 0 1
127640: PPUSH
127641: CALL_OW 310
127645: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
127646: LD_VAR 0 1
127650: PPUSH
127651: CALL_OW 266
127655: PUSH
127656: LD_INT 3
127658: NONEQUAL
127659: IFFALSE 127663
// exit ;
127661: GO 127765
// if HexInfo ( x , y ) = factory then
127663: LD_VAR 0 2
127667: PPUSH
127668: LD_VAR 0 3
127672: PPUSH
127673: CALL_OW 428
127677: PUSH
127678: LD_VAR 0 1
127682: EQUAL
127683: IFFALSE 127710
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
127685: LD_ADDR_EXP 206
127689: PUSH
127690: LD_EXP 206
127694: PPUSH
127695: LD_VAR 0 1
127699: PPUSH
127700: LD_INT 0
127702: PPUSH
127703: CALL_OW 1
127707: ST_TO_ADDR
127708: GO 127761
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
127710: LD_ADDR_EXP 206
127714: PUSH
127715: LD_EXP 206
127719: PPUSH
127720: LD_VAR 0 1
127724: PPUSH
127725: LD_VAR 0 1
127729: PPUSH
127730: CALL_OW 255
127734: PUSH
127735: LD_VAR 0 1
127739: PUSH
127740: LD_VAR 0 2
127744: PUSH
127745: LD_VAR 0 3
127749: PUSH
127750: EMPTY
127751: LIST
127752: LIST
127753: LIST
127754: LIST
127755: PPUSH
127756: CALL_OW 1
127760: ST_TO_ADDR
// UpdateFactoryWaypoints ;
127761: CALL 127770 0 0
// end ;
127765: LD_VAR 0 4
127769: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
127770: LD_INT 0
127772: PPUSH
127773: PPUSH
127774: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
127775: LD_STRING resetFactoryWaypoint();
127777: PPUSH
127778: CALL_OW 559
// if factoryWaypoints then
127782: LD_EXP 206
127786: IFFALSE 127912
// begin list := PrepareArray ( factoryWaypoints ) ;
127788: LD_ADDR_VAR 0 3
127792: PUSH
127793: LD_EXP 206
127797: PPUSH
127798: CALL 111725 0 1
127802: ST_TO_ADDR
// for i := 1 to list do
127803: LD_ADDR_VAR 0 2
127807: PUSH
127808: DOUBLE
127809: LD_INT 1
127811: DEC
127812: ST_TO_ADDR
127813: LD_VAR 0 3
127817: PUSH
127818: FOR_TO
127819: IFFALSE 127910
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
127821: LD_STRING setFactoryWaypointXY(
127823: PUSH
127824: LD_VAR 0 3
127828: PUSH
127829: LD_VAR 0 2
127833: ARRAY
127834: PUSH
127835: LD_INT 1
127837: ARRAY
127838: STR
127839: PUSH
127840: LD_STRING ,
127842: STR
127843: PUSH
127844: LD_VAR 0 3
127848: PUSH
127849: LD_VAR 0 2
127853: ARRAY
127854: PUSH
127855: LD_INT 2
127857: ARRAY
127858: STR
127859: PUSH
127860: LD_STRING ,
127862: STR
127863: PUSH
127864: LD_VAR 0 3
127868: PUSH
127869: LD_VAR 0 2
127873: ARRAY
127874: PUSH
127875: LD_INT 3
127877: ARRAY
127878: STR
127879: PUSH
127880: LD_STRING ,
127882: STR
127883: PUSH
127884: LD_VAR 0 3
127888: PUSH
127889: LD_VAR 0 2
127893: ARRAY
127894: PUSH
127895: LD_INT 4
127897: ARRAY
127898: STR
127899: PUSH
127900: LD_STRING )
127902: STR
127903: PPUSH
127904: CALL_OW 559
127908: GO 127818
127910: POP
127911: POP
// end ; end ;
127912: LD_VAR 0 1
127916: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
127917: LD_INT 0
127919: PPUSH
// if HexInfo ( x , y ) = warehouse then
127920: LD_VAR 0 2
127924: PPUSH
127925: LD_VAR 0 3
127929: PPUSH
127930: CALL_OW 428
127934: PUSH
127935: LD_VAR 0 1
127939: EQUAL
127940: IFFALSE 127967
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
127942: LD_ADDR_EXP 207
127946: PUSH
127947: LD_EXP 207
127951: PPUSH
127952: LD_VAR 0 1
127956: PPUSH
127957: LD_INT 0
127959: PPUSH
127960: CALL_OW 1
127964: ST_TO_ADDR
127965: GO 128018
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
127967: LD_ADDR_EXP 207
127971: PUSH
127972: LD_EXP 207
127976: PPUSH
127977: LD_VAR 0 1
127981: PPUSH
127982: LD_VAR 0 1
127986: PPUSH
127987: CALL_OW 255
127991: PUSH
127992: LD_VAR 0 1
127996: PUSH
127997: LD_VAR 0 2
128001: PUSH
128002: LD_VAR 0 3
128006: PUSH
128007: EMPTY
128008: LIST
128009: LIST
128010: LIST
128011: LIST
128012: PPUSH
128013: CALL_OW 1
128017: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
128018: CALL 128027 0 0
// end ;
128022: LD_VAR 0 4
128026: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
128027: LD_INT 0
128029: PPUSH
128030: PPUSH
128031: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
128032: LD_STRING resetWarehouseGatheringPoints();
128034: PPUSH
128035: CALL_OW 559
// if warehouseGatheringPoints then
128039: LD_EXP 207
128043: IFFALSE 128169
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
128045: LD_ADDR_VAR 0 3
128049: PUSH
128050: LD_EXP 207
128054: PPUSH
128055: CALL 111725 0 1
128059: ST_TO_ADDR
// for i := 1 to list do
128060: LD_ADDR_VAR 0 2
128064: PUSH
128065: DOUBLE
128066: LD_INT 1
128068: DEC
128069: ST_TO_ADDR
128070: LD_VAR 0 3
128074: PUSH
128075: FOR_TO
128076: IFFALSE 128167
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
128078: LD_STRING setWarehouseGatheringPointXY(
128080: PUSH
128081: LD_VAR 0 3
128085: PUSH
128086: LD_VAR 0 2
128090: ARRAY
128091: PUSH
128092: LD_INT 1
128094: ARRAY
128095: STR
128096: PUSH
128097: LD_STRING ,
128099: STR
128100: PUSH
128101: LD_VAR 0 3
128105: PUSH
128106: LD_VAR 0 2
128110: ARRAY
128111: PUSH
128112: LD_INT 2
128114: ARRAY
128115: STR
128116: PUSH
128117: LD_STRING ,
128119: STR
128120: PUSH
128121: LD_VAR 0 3
128125: PUSH
128126: LD_VAR 0 2
128130: ARRAY
128131: PUSH
128132: LD_INT 3
128134: ARRAY
128135: STR
128136: PUSH
128137: LD_STRING ,
128139: STR
128140: PUSH
128141: LD_VAR 0 3
128145: PUSH
128146: LD_VAR 0 2
128150: ARRAY
128151: PUSH
128152: LD_INT 4
128154: ARRAY
128155: STR
128156: PUSH
128157: LD_STRING )
128159: STR
128160: PPUSH
128161: CALL_OW 559
128165: GO 128075
128167: POP
128168: POP
// end ; end ;
128169: LD_VAR 0 1
128173: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
128174: LD_EXP 207
128178: IFFALSE 128863
128180: GO 128182
128182: DISABLE
128183: LD_INT 0
128185: PPUSH
128186: PPUSH
128187: PPUSH
128188: PPUSH
128189: PPUSH
128190: PPUSH
128191: PPUSH
128192: PPUSH
128193: PPUSH
// begin enable ;
128194: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
128195: LD_ADDR_VAR 0 3
128199: PUSH
128200: LD_EXP 207
128204: PPUSH
128205: CALL 111725 0 1
128209: ST_TO_ADDR
// if not list then
128210: LD_VAR 0 3
128214: NOT
128215: IFFALSE 128219
// exit ;
128217: GO 128863
// for i := 1 to list do
128219: LD_ADDR_VAR 0 1
128223: PUSH
128224: DOUBLE
128225: LD_INT 1
128227: DEC
128228: ST_TO_ADDR
128229: LD_VAR 0 3
128233: PUSH
128234: FOR_TO
128235: IFFALSE 128861
// begin depot := list [ i ] [ 2 ] ;
128237: LD_ADDR_VAR 0 8
128241: PUSH
128242: LD_VAR 0 3
128246: PUSH
128247: LD_VAR 0 1
128251: ARRAY
128252: PUSH
128253: LD_INT 2
128255: ARRAY
128256: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
128257: LD_ADDR_VAR 0 5
128261: PUSH
128262: LD_VAR 0 3
128266: PUSH
128267: LD_VAR 0 1
128271: ARRAY
128272: PUSH
128273: LD_INT 1
128275: ARRAY
128276: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
128277: LD_VAR 0 8
128281: PPUSH
128282: CALL_OW 301
128286: PUSH
128287: LD_VAR 0 5
128291: PUSH
128292: LD_VAR 0 8
128296: PPUSH
128297: CALL_OW 255
128301: NONEQUAL
128302: OR
128303: IFFALSE 128332
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
128305: LD_ADDR_EXP 207
128309: PUSH
128310: LD_EXP 207
128314: PPUSH
128315: LD_VAR 0 8
128319: PPUSH
128320: LD_INT 0
128322: PPUSH
128323: CALL_OW 1
128327: ST_TO_ADDR
// exit ;
128328: POP
128329: POP
128330: GO 128863
// end ; x := list [ i ] [ 3 ] ;
128332: LD_ADDR_VAR 0 6
128336: PUSH
128337: LD_VAR 0 3
128341: PUSH
128342: LD_VAR 0 1
128346: ARRAY
128347: PUSH
128348: LD_INT 3
128350: ARRAY
128351: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
128352: LD_ADDR_VAR 0 7
128356: PUSH
128357: LD_VAR 0 3
128361: PUSH
128362: LD_VAR 0 1
128366: ARRAY
128367: PUSH
128368: LD_INT 4
128370: ARRAY
128371: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
128372: LD_ADDR_VAR 0 9
128376: PUSH
128377: LD_VAR 0 6
128381: PPUSH
128382: LD_VAR 0 7
128386: PPUSH
128387: LD_INT 16
128389: PPUSH
128390: CALL 110309 0 3
128394: ST_TO_ADDR
// if not cratesNearbyPoint then
128395: LD_VAR 0 9
128399: NOT
128400: IFFALSE 128406
// exit ;
128402: POP
128403: POP
128404: GO 128863
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
128406: LD_ADDR_VAR 0 4
128410: PUSH
128411: LD_INT 22
128413: PUSH
128414: LD_VAR 0 5
128418: PUSH
128419: EMPTY
128420: LIST
128421: LIST
128422: PUSH
128423: LD_INT 3
128425: PUSH
128426: LD_INT 60
128428: PUSH
128429: EMPTY
128430: LIST
128431: PUSH
128432: EMPTY
128433: LIST
128434: LIST
128435: PUSH
128436: LD_INT 91
128438: PUSH
128439: LD_VAR 0 8
128443: PUSH
128444: LD_INT 6
128446: PUSH
128447: EMPTY
128448: LIST
128449: LIST
128450: LIST
128451: PUSH
128452: LD_INT 2
128454: PUSH
128455: LD_INT 25
128457: PUSH
128458: LD_INT 2
128460: PUSH
128461: EMPTY
128462: LIST
128463: LIST
128464: PUSH
128465: LD_INT 25
128467: PUSH
128468: LD_INT 16
128470: PUSH
128471: EMPTY
128472: LIST
128473: LIST
128474: PUSH
128475: EMPTY
128476: LIST
128477: LIST
128478: LIST
128479: PUSH
128480: EMPTY
128481: LIST
128482: LIST
128483: LIST
128484: LIST
128485: PPUSH
128486: CALL_OW 69
128490: PUSH
128491: LD_VAR 0 8
128495: PPUSH
128496: CALL_OW 313
128500: PPUSH
128501: LD_INT 3
128503: PUSH
128504: LD_INT 60
128506: PUSH
128507: EMPTY
128508: LIST
128509: PUSH
128510: EMPTY
128511: LIST
128512: LIST
128513: PUSH
128514: LD_INT 2
128516: PUSH
128517: LD_INT 25
128519: PUSH
128520: LD_INT 2
128522: PUSH
128523: EMPTY
128524: LIST
128525: LIST
128526: PUSH
128527: LD_INT 25
128529: PUSH
128530: LD_INT 16
128532: PUSH
128533: EMPTY
128534: LIST
128535: LIST
128536: PUSH
128537: EMPTY
128538: LIST
128539: LIST
128540: LIST
128541: PUSH
128542: EMPTY
128543: LIST
128544: LIST
128545: PPUSH
128546: CALL_OW 72
128550: UNION
128551: ST_TO_ADDR
// if tmp then
128552: LD_VAR 0 4
128556: IFFALSE 128636
// begin tmp := ShrinkArray ( tmp , 3 ) ;
128558: LD_ADDR_VAR 0 4
128562: PUSH
128563: LD_VAR 0 4
128567: PPUSH
128568: LD_INT 3
128570: PPUSH
128571: CALL 108278 0 2
128575: ST_TO_ADDR
// for j in tmp do
128576: LD_ADDR_VAR 0 2
128580: PUSH
128581: LD_VAR 0 4
128585: PUSH
128586: FOR_IN
128587: IFFALSE 128630
// begin if IsInUnit ( j ) then
128589: LD_VAR 0 2
128593: PPUSH
128594: CALL_OW 310
128598: IFFALSE 128609
// ComExit ( j ) ;
128600: LD_VAR 0 2
128604: PPUSH
128605: CALL 108361 0 1
// AddComCollect ( j , x , y ) ;
128609: LD_VAR 0 2
128613: PPUSH
128614: LD_VAR 0 6
128618: PPUSH
128619: LD_VAR 0 7
128623: PPUSH
128624: CALL_OW 177
// end ;
128628: GO 128586
128630: POP
128631: POP
// exit ;
128632: POP
128633: POP
128634: GO 128863
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
128636: LD_ADDR_VAR 0 4
128640: PUSH
128641: LD_INT 22
128643: PUSH
128644: LD_VAR 0 5
128648: PUSH
128649: EMPTY
128650: LIST
128651: LIST
128652: PUSH
128653: LD_INT 91
128655: PUSH
128656: LD_VAR 0 8
128660: PUSH
128661: LD_INT 8
128663: PUSH
128664: EMPTY
128665: LIST
128666: LIST
128667: LIST
128668: PUSH
128669: LD_INT 2
128671: PUSH
128672: LD_INT 34
128674: PUSH
128675: LD_INT 12
128677: PUSH
128678: EMPTY
128679: LIST
128680: LIST
128681: PUSH
128682: LD_INT 34
128684: PUSH
128685: LD_INT 51
128687: PUSH
128688: EMPTY
128689: LIST
128690: LIST
128691: PUSH
128692: LD_INT 34
128694: PUSH
128695: LD_INT 32
128697: PUSH
128698: EMPTY
128699: LIST
128700: LIST
128701: PUSH
128702: LD_INT 34
128704: PUSH
128705: LD_INT 89
128707: PUSH
128708: EMPTY
128709: LIST
128710: LIST
128711: PUSH
128712: EMPTY
128713: LIST
128714: LIST
128715: LIST
128716: LIST
128717: LIST
128718: PUSH
128719: EMPTY
128720: LIST
128721: LIST
128722: LIST
128723: PPUSH
128724: CALL_OW 69
128728: ST_TO_ADDR
// if tmp then
128729: LD_VAR 0 4
128733: IFFALSE 128859
// begin for j in tmp do
128735: LD_ADDR_VAR 0 2
128739: PUSH
128740: LD_VAR 0 4
128744: PUSH
128745: FOR_IN
128746: IFFALSE 128857
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
128748: LD_VAR 0 2
128752: PPUSH
128753: CALL_OW 262
128757: PUSH
128758: LD_INT 3
128760: EQUAL
128761: PUSH
128762: LD_VAR 0 2
128766: PPUSH
128767: CALL_OW 261
128771: PUSH
128772: LD_INT 20
128774: GREATER
128775: OR
128776: PUSH
128777: LD_VAR 0 2
128781: PPUSH
128782: CALL_OW 314
128786: NOT
128787: AND
128788: PUSH
128789: LD_VAR 0 2
128793: PPUSH
128794: CALL_OW 263
128798: PUSH
128799: LD_INT 1
128801: NONEQUAL
128802: PUSH
128803: LD_VAR 0 2
128807: PPUSH
128808: CALL_OW 311
128812: OR
128813: AND
128814: IFFALSE 128855
// begin ComCollect ( j , x , y ) ;
128816: LD_VAR 0 2
128820: PPUSH
128821: LD_VAR 0 6
128825: PPUSH
128826: LD_VAR 0 7
128830: PPUSH
128831: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
128835: LD_VAR 0 2
128839: PPUSH
128840: LD_VAR 0 8
128844: PPUSH
128845: CALL_OW 172
// exit ;
128849: POP
128850: POP
128851: POP
128852: POP
128853: GO 128863
// end ;
128855: GO 128745
128857: POP
128858: POP
// end ; end ;
128859: GO 128234
128861: POP
128862: POP
// end ; end_of_file
128863: PPOPN 9
128865: END
// export function SOS_UnitDestroyed ( un ) ; begin
128866: LD_INT 0
128868: PPUSH
// ComRadiation ( un ) ;
128869: LD_VAR 0 1
128873: PPUSH
128874: CALL 129812 0 1
// end ;
128878: LD_VAR 0 2
128882: RET
// export function SOS_UnitKamikazed ( un ) ; begin
128883: LD_INT 0
128885: PPUSH
// ComRadiation ( un ) ;
128886: LD_VAR 0 1
128890: PPUSH
128891: CALL 129812 0 1
// end ;
128895: LD_VAR 0 2
128899: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
128900: LD_INT 0
128902: PPUSH
// end ;
128903: LD_VAR 0 4
128907: RET
// export function SOS_Command ( cmd ) ; begin
128908: LD_INT 0
128910: PPUSH
// end ;
128911: LD_VAR 0 2
128915: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
128916: LD_INT 0
128918: PPUSH
// end ;
128919: LD_VAR 0 6
128923: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var tag , driver , hex ; begin
128924: LD_INT 0
128926: PPUSH
128927: PPUSH
128928: PPUSH
128929: PPUSH
// if not vehicle or not factory then
128930: LD_VAR 0 1
128934: NOT
128935: PUSH
128936: LD_VAR 0 2
128940: NOT
128941: OR
128942: IFFALSE 128946
// exit ;
128944: GO 129403
// if factoryWaypoints >= factory then
128946: LD_EXP 206
128950: PUSH
128951: LD_VAR 0 2
128955: GREATEREQUAL
128956: IFFALSE 129403
// if factoryWaypoints [ factory ] then
128958: LD_EXP 206
128962: PUSH
128963: LD_VAR 0 2
128967: ARRAY
128968: IFFALSE 129403
// begin if GetControl ( vehicle ) = control_manual then
128970: LD_VAR 0 1
128974: PPUSH
128975: CALL_OW 263
128979: PUSH
128980: LD_INT 1
128982: EQUAL
128983: IFFALSE 129290
// begin driver := IsDrivenBy ( vehicle ) ;
128985: LD_ADDR_VAR 0 5
128989: PUSH
128990: LD_VAR 0 1
128994: PPUSH
128995: CALL_OW 311
128999: ST_TO_ADDR
// tag := GetTag ( driver ) ;
129000: LD_ADDR_VAR 0 4
129004: PUSH
129005: LD_VAR 0 5
129009: PPUSH
129010: CALL_OW 110
129014: ST_TO_ADDR
// if tag = tDriver or GetTag ( vehicle ) = tDriver then
129015: LD_VAR 0 4
129019: PUSH
129020: LD_INT 501
129022: EQUAL
129023: PUSH
129024: LD_VAR 0 1
129028: PPUSH
129029: CALL_OW 110
129033: PUSH
129034: LD_INT 501
129036: EQUAL
129037: OR
129038: IFFALSE 129042
// exit ;
129040: GO 129403
// if not HasTask ( driver ) then
129042: LD_VAR 0 5
129046: PPUSH
129047: CALL_OW 314
129051: NOT
129052: IFFALSE 129288
// begin SetTag ( driver , tDriver ) ;
129054: LD_VAR 0 5
129058: PPUSH
129059: LD_INT 501
129061: PPUSH
129062: CALL_OW 109
// SetTag ( vehicle , tDriver ) ;
129066: LD_VAR 0 1
129070: PPUSH
129071: LD_INT 501
129073: PPUSH
129074: CALL_OW 109
// hex := HexInfo ( factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
129078: LD_ADDR_VAR 0 6
129082: PUSH
129083: LD_EXP 206
129087: PUSH
129088: LD_VAR 0 2
129092: ARRAY
129093: PUSH
129094: LD_INT 3
129096: ARRAY
129097: PPUSH
129098: LD_EXP 206
129102: PUSH
129103: LD_VAR 0 2
129107: ARRAY
129108: PUSH
129109: LD_INT 4
129111: ARRAY
129112: PPUSH
129113: CALL_OW 428
129117: ST_TO_ADDR
// if hex then
129118: LD_VAR 0 6
129122: IFFALSE 129140
// ComMoveUnit ( driver , hex ) else
129124: LD_VAR 0 5
129128: PPUSH
129129: LD_VAR 0 6
129133: PPUSH
129134: CALL_OW 112
129138: GO 129179
// ComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
129140: LD_VAR 0 5
129144: PPUSH
129145: LD_EXP 206
129149: PUSH
129150: LD_VAR 0 2
129154: ARRAY
129155: PUSH
129156: LD_INT 3
129158: ARRAY
129159: PPUSH
129160: LD_EXP 206
129164: PUSH
129165: LD_VAR 0 2
129169: ARRAY
129170: PUSH
129171: LD_INT 4
129173: ARRAY
129174: PPUSH
129175: CALL_OW 111
// AddComExitVehicle ( driver ) ;
129179: LD_VAR 0 5
129183: PPUSH
129184: CALL_OW 181
// if Multiplayer then
129188: LD_OWVAR 4
129192: IFFALSE 129241
// begin repeat wait ( 10 ) ;
129194: LD_INT 10
129196: PPUSH
129197: CALL_OW 67
// until not IsInUnit ( driver ) ;
129201: LD_VAR 0 5
129205: PPUSH
129206: CALL_OW 310
129210: NOT
129211: IFFALSE 129194
// if not HasTask ( driver ) then
129213: LD_VAR 0 5
129217: PPUSH
129218: CALL_OW 314
129222: NOT
129223: IFFALSE 129239
// ComEnterUnit ( driver , factory ) ;
129225: LD_VAR 0 5
129229: PPUSH
129230: LD_VAR 0 2
129234: PPUSH
129235: CALL_OW 120
// end else
129239: GO 129255
// AddComEnterUnit ( driver , factory ) ;
129241: LD_VAR 0 5
129245: PPUSH
129246: LD_VAR 0 2
129250: PPUSH
129251: CALL_OW 180
// wait ( 0 0$1 ) ;
129255: LD_INT 35
129257: PPUSH
129258: CALL_OW 67
// SetTag ( driver , tag ) ;
129262: LD_VAR 0 5
129266: PPUSH
129267: LD_VAR 0 4
129271: PPUSH
129272: CALL_OW 109
// SetTag ( vehicle , 0 ) ;
129276: LD_VAR 0 1
129280: PPUSH
129281: LD_INT 0
129283: PPUSH
129284: CALL_OW 109
// end ; end else
129288: GO 129403
// if GetControl ( vehicle ) = control_remote then
129290: LD_VAR 0 1
129294: PPUSH
129295: CALL_OW 263
129299: PUSH
129300: LD_INT 2
129302: EQUAL
129303: IFFALSE 129364
// begin wait ( 0 0$2 ) ;
129305: LD_INT 70
129307: PPUSH
129308: CALL_OW 67
// if Connect ( vehicle ) then
129312: LD_VAR 0 1
129316: PPUSH
129317: CALL 78580 0 1
129321: IFFALSE 129362
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
129323: LD_VAR 0 1
129327: PPUSH
129328: LD_EXP 206
129332: PUSH
129333: LD_VAR 0 2
129337: ARRAY
129338: PUSH
129339: LD_INT 3
129341: ARRAY
129342: PPUSH
129343: LD_EXP 206
129347: PUSH
129348: LD_VAR 0 2
129352: ARRAY
129353: PUSH
129354: LD_INT 4
129356: ARRAY
129357: PPUSH
129358: CALL_OW 171
// end else
129362: GO 129403
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
129364: LD_VAR 0 1
129368: PPUSH
129369: LD_EXP 206
129373: PUSH
129374: LD_VAR 0 2
129378: ARRAY
129379: PUSH
129380: LD_INT 3
129382: ARRAY
129383: PPUSH
129384: LD_EXP 206
129388: PUSH
129389: LD_VAR 0 2
129393: ARRAY
129394: PUSH
129395: LD_INT 4
129397: ARRAY
129398: PPUSH
129399: CALL_OW 171
// end ; end ;
129403: LD_VAR 0 3
129407: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
129408: LD_INT 0
129410: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
129411: LD_VAR 0 1
129415: PUSH
129416: LD_INT 250
129418: EQUAL
129419: PUSH
129420: LD_VAR 0 2
129424: PPUSH
129425: CALL_OW 264
129429: PUSH
129430: LD_INT 81
129432: EQUAL
129433: AND
129434: IFFALSE 129455
// MinerPlaceMine ( unit , x , y ) ;
129436: LD_VAR 0 2
129440: PPUSH
129441: LD_VAR 0 4
129445: PPUSH
129446: LD_VAR 0 5
129450: PPUSH
129451: CALL 132547 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
129455: LD_VAR 0 1
129459: PUSH
129460: LD_INT 251
129462: EQUAL
129463: PUSH
129464: LD_VAR 0 2
129468: PPUSH
129469: CALL_OW 264
129473: PUSH
129474: LD_INT 81
129476: EQUAL
129477: AND
129478: IFFALSE 129499
// MinerDetonateMine ( unit , x , y ) ;
129480: LD_VAR 0 2
129484: PPUSH
129485: LD_VAR 0 4
129489: PPUSH
129490: LD_VAR 0 5
129494: PPUSH
129495: CALL 132822 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
129499: LD_VAR 0 1
129503: PUSH
129504: LD_INT 252
129506: EQUAL
129507: PUSH
129508: LD_VAR 0 2
129512: PPUSH
129513: CALL_OW 264
129517: PUSH
129518: LD_INT 81
129520: EQUAL
129521: AND
129522: IFFALSE 129543
// MinerCreateMinefield ( unit , x , y ) ;
129524: LD_VAR 0 2
129528: PPUSH
129529: LD_VAR 0 4
129533: PPUSH
129534: LD_VAR 0 5
129538: PPUSH
129539: CALL 133239 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
129543: LD_VAR 0 1
129547: PUSH
129548: LD_INT 253
129550: EQUAL
129551: PUSH
129552: LD_VAR 0 2
129556: PPUSH
129557: CALL_OW 257
129561: PUSH
129562: LD_INT 5
129564: EQUAL
129565: AND
129566: IFFALSE 129587
// ComBinocular ( unit , x , y ) ;
129568: LD_VAR 0 2
129572: PPUSH
129573: LD_VAR 0 4
129577: PPUSH
129578: LD_VAR 0 5
129582: PPUSH
129583: CALL 133608 0 3
// if selectedUnit then
129587: LD_VAR 0 3
129591: IFFALSE 129647
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
129593: LD_VAR 0 1
129597: PUSH
129598: LD_INT 254
129600: EQUAL
129601: PUSH
129602: LD_VAR 0 2
129606: PPUSH
129607: CALL_OW 264
129611: PUSH
129612: LD_INT 99
129614: EQUAL
129615: AND
129616: PUSH
129617: LD_VAR 0 3
129621: PPUSH
129622: CALL_OW 263
129626: PUSH
129627: LD_INT 3
129629: EQUAL
129630: AND
129631: IFFALSE 129647
// HackDestroyVehicle ( unit , selectedUnit ) ;
129633: LD_VAR 0 2
129637: PPUSH
129638: LD_VAR 0 3
129642: PPUSH
129643: CALL 131911 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
129647: LD_VAR 0 1
129651: PUSH
129652: LD_INT 255
129654: EQUAL
129655: PUSH
129656: LD_VAR 0 2
129660: PPUSH
129661: CALL_OW 264
129665: PUSH
129666: LD_INT 14
129668: PUSH
129669: LD_INT 53
129671: PUSH
129672: EMPTY
129673: LIST
129674: LIST
129675: IN
129676: AND
129677: PUSH
129678: LD_VAR 0 4
129682: PPUSH
129683: LD_VAR 0 5
129687: PPUSH
129688: CALL_OW 488
129692: AND
129693: IFFALSE 129717
// CutTreeXYR ( unit , x , y , 12 ) ;
129695: LD_VAR 0 2
129699: PPUSH
129700: LD_VAR 0 4
129704: PPUSH
129705: LD_VAR 0 5
129709: PPUSH
129710: LD_INT 12
129712: PPUSH
129713: CALL 129908 0 4
// if cmd = 256 then
129717: LD_VAR 0 1
129721: PUSH
129722: LD_INT 256
129724: EQUAL
129725: IFFALSE 129746
// SetFactoryWaypoint ( unit , x , y ) ;
129727: LD_VAR 0 2
129731: PPUSH
129732: LD_VAR 0 4
129736: PPUSH
129737: LD_VAR 0 5
129741: PPUSH
129742: CALL 127555 0 3
// if cmd = 257 then
129746: LD_VAR 0 1
129750: PUSH
129751: LD_INT 257
129753: EQUAL
129754: IFFALSE 129775
// SetWarehouseGatheringPoint ( unit , x , y ) ;
129756: LD_VAR 0 2
129760: PPUSH
129761: LD_VAR 0 4
129765: PPUSH
129766: LD_VAR 0 5
129770: PPUSH
129771: CALL 127917 0 3
// if cmd = 258 then
129775: LD_VAR 0 1
129779: PUSH
129780: LD_INT 258
129782: EQUAL
129783: IFFALSE 129807
// BurnTreeXYR ( unit , x , y , 8 ) ;
129785: LD_VAR 0 2
129789: PPUSH
129790: LD_VAR 0 4
129794: PPUSH
129795: LD_VAR 0 5
129799: PPUSH
129800: LD_INT 8
129802: PPUSH
129803: CALL 130302 0 4
// end ;
129807: LD_VAR 0 6
129811: RET
// export function ComRadiation ( un ) ; var eff ; begin
129812: LD_INT 0
129814: PPUSH
129815: PPUSH
// if GetWeapon ( un ) <> ar_bio_bomb then
129816: LD_VAR 0 1
129820: PPUSH
129821: CALL_OW 264
129825: PUSH
129826: LD_INT 91
129828: NONEQUAL
129829: IFFALSE 129833
// exit ;
129831: GO 129903
// if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
129833: LD_INT 68
129835: PPUSH
129836: LD_VAR 0 1
129840: PPUSH
129841: CALL_OW 255
129845: PPUSH
129846: CALL_OW 321
129850: PUSH
129851: LD_INT 2
129853: EQUAL
129854: IFFALSE 129866
// eff := 70 else
129856: LD_ADDR_VAR 0 3
129860: PUSH
129861: LD_INT 70
129863: ST_TO_ADDR
129864: GO 129874
// eff := 30 ;
129866: LD_ADDR_VAR 0 3
129870: PUSH
129871: LD_INT 30
129873: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
129874: LD_VAR 0 1
129878: PPUSH
129879: CALL_OW 250
129883: PPUSH
129884: LD_VAR 0 1
129888: PPUSH
129889: CALL_OW 251
129893: PPUSH
129894: LD_VAR 0 3
129898: PPUSH
129899: CALL_OW 495
// end ;
129903: LD_VAR 0 2
129907: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
129908: LD_INT 0
129910: PPUSH
129911: PPUSH
129912: PPUSH
129913: PPUSH
129914: PPUSH
129915: PPUSH
129916: PPUSH
129917: PPUSH
129918: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
129919: LD_VAR 0 1
129923: PPUSH
129924: CALL_OW 302
129928: NOT
129929: PUSH
129930: LD_VAR 0 2
129934: PPUSH
129935: LD_VAR 0 3
129939: PPUSH
129940: CALL_OW 488
129944: NOT
129945: OR
129946: PUSH
129947: LD_VAR 0 4
129951: NOT
129952: OR
129953: IFFALSE 129957
// exit ;
129955: GO 130297
// list := [ ] ;
129957: LD_ADDR_VAR 0 13
129961: PUSH
129962: EMPTY
129963: ST_TO_ADDR
// if x - r < 0 then
129964: LD_VAR 0 2
129968: PUSH
129969: LD_VAR 0 4
129973: MINUS
129974: PUSH
129975: LD_INT 0
129977: LESS
129978: IFFALSE 129990
// min_x := 0 else
129980: LD_ADDR_VAR 0 7
129984: PUSH
129985: LD_INT 0
129987: ST_TO_ADDR
129988: GO 130006
// min_x := x - r ;
129990: LD_ADDR_VAR 0 7
129994: PUSH
129995: LD_VAR 0 2
129999: PUSH
130000: LD_VAR 0 4
130004: MINUS
130005: ST_TO_ADDR
// if y - r < 0 then
130006: LD_VAR 0 3
130010: PUSH
130011: LD_VAR 0 4
130015: MINUS
130016: PUSH
130017: LD_INT 0
130019: LESS
130020: IFFALSE 130032
// min_y := 0 else
130022: LD_ADDR_VAR 0 8
130026: PUSH
130027: LD_INT 0
130029: ST_TO_ADDR
130030: GO 130048
// min_y := y - r ;
130032: LD_ADDR_VAR 0 8
130036: PUSH
130037: LD_VAR 0 3
130041: PUSH
130042: LD_VAR 0 4
130046: MINUS
130047: ST_TO_ADDR
// max_x := x + r ;
130048: LD_ADDR_VAR 0 9
130052: PUSH
130053: LD_VAR 0 2
130057: PUSH
130058: LD_VAR 0 4
130062: PLUS
130063: ST_TO_ADDR
// max_y := y + r ;
130064: LD_ADDR_VAR 0 10
130068: PUSH
130069: LD_VAR 0 3
130073: PUSH
130074: LD_VAR 0 4
130078: PLUS
130079: ST_TO_ADDR
// for _x = min_x to max_x do
130080: LD_ADDR_VAR 0 11
130084: PUSH
130085: DOUBLE
130086: LD_VAR 0 7
130090: DEC
130091: ST_TO_ADDR
130092: LD_VAR 0 9
130096: PUSH
130097: FOR_TO
130098: IFFALSE 130215
// for _y = min_y to max_y do
130100: LD_ADDR_VAR 0 12
130104: PUSH
130105: DOUBLE
130106: LD_VAR 0 8
130110: DEC
130111: ST_TO_ADDR
130112: LD_VAR 0 10
130116: PUSH
130117: FOR_TO
130118: IFFALSE 130211
// begin if not ValidHex ( _x , _y ) then
130120: LD_VAR 0 11
130124: PPUSH
130125: LD_VAR 0 12
130129: PPUSH
130130: CALL_OW 488
130134: NOT
130135: IFFALSE 130139
// continue ;
130137: GO 130117
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
130139: LD_VAR 0 11
130143: PPUSH
130144: LD_VAR 0 12
130148: PPUSH
130149: CALL_OW 351
130153: PUSH
130154: LD_VAR 0 11
130158: PPUSH
130159: LD_VAR 0 12
130163: PPUSH
130164: CALL_OW 554
130168: AND
130169: IFFALSE 130209
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
130171: LD_ADDR_VAR 0 13
130175: PUSH
130176: LD_VAR 0 13
130180: PPUSH
130181: LD_VAR 0 13
130185: PUSH
130186: LD_INT 1
130188: PLUS
130189: PPUSH
130190: LD_VAR 0 11
130194: PUSH
130195: LD_VAR 0 12
130199: PUSH
130200: EMPTY
130201: LIST
130202: LIST
130203: PPUSH
130204: CALL_OW 2
130208: ST_TO_ADDR
// end ;
130209: GO 130117
130211: POP
130212: POP
130213: GO 130097
130215: POP
130216: POP
// if not list then
130217: LD_VAR 0 13
130221: NOT
130222: IFFALSE 130226
// exit ;
130224: GO 130297
// for i in list do
130226: LD_ADDR_VAR 0 6
130230: PUSH
130231: LD_VAR 0 13
130235: PUSH
130236: FOR_IN
130237: IFFALSE 130295
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
130239: LD_VAR 0 1
130243: PPUSH
130244: LD_STRING M
130246: PUSH
130247: LD_VAR 0 6
130251: PUSH
130252: LD_INT 1
130254: ARRAY
130255: PUSH
130256: LD_VAR 0 6
130260: PUSH
130261: LD_INT 2
130263: ARRAY
130264: PUSH
130265: LD_INT 0
130267: PUSH
130268: LD_INT 0
130270: PUSH
130271: LD_INT 0
130273: PUSH
130274: LD_INT 0
130276: PUSH
130277: EMPTY
130278: LIST
130279: LIST
130280: LIST
130281: LIST
130282: LIST
130283: LIST
130284: LIST
130285: PUSH
130286: EMPTY
130287: LIST
130288: PPUSH
130289: CALL_OW 447
130293: GO 130236
130295: POP
130296: POP
// end ;
130297: LD_VAR 0 5
130301: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
130302: LD_INT 0
130304: PPUSH
130305: PPUSH
130306: PPUSH
130307: PPUSH
130308: PPUSH
130309: PPUSH
130310: PPUSH
130311: PPUSH
130312: PPUSH
130313: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
130314: LD_VAR 0 1
130318: PPUSH
130319: CALL_OW 302
130323: NOT
130324: PUSH
130325: LD_VAR 0 2
130329: PPUSH
130330: LD_VAR 0 3
130334: PPUSH
130335: CALL_OW 488
130339: NOT
130340: OR
130341: PUSH
130342: LD_VAR 0 4
130346: NOT
130347: OR
130348: IFFALSE 130352
// exit ;
130350: GO 130865
// list := [ ] ;
130352: LD_ADDR_VAR 0 13
130356: PUSH
130357: EMPTY
130358: ST_TO_ADDR
// if x - r < 0 then
130359: LD_VAR 0 2
130363: PUSH
130364: LD_VAR 0 4
130368: MINUS
130369: PUSH
130370: LD_INT 0
130372: LESS
130373: IFFALSE 130385
// min_x := 0 else
130375: LD_ADDR_VAR 0 7
130379: PUSH
130380: LD_INT 0
130382: ST_TO_ADDR
130383: GO 130401
// min_x := x - r ;
130385: LD_ADDR_VAR 0 7
130389: PUSH
130390: LD_VAR 0 2
130394: PUSH
130395: LD_VAR 0 4
130399: MINUS
130400: ST_TO_ADDR
// if y - r < 0 then
130401: LD_VAR 0 3
130405: PUSH
130406: LD_VAR 0 4
130410: MINUS
130411: PUSH
130412: LD_INT 0
130414: LESS
130415: IFFALSE 130427
// min_y := 0 else
130417: LD_ADDR_VAR 0 8
130421: PUSH
130422: LD_INT 0
130424: ST_TO_ADDR
130425: GO 130443
// min_y := y - r ;
130427: LD_ADDR_VAR 0 8
130431: PUSH
130432: LD_VAR 0 3
130436: PUSH
130437: LD_VAR 0 4
130441: MINUS
130442: ST_TO_ADDR
// max_x := x + r ;
130443: LD_ADDR_VAR 0 9
130447: PUSH
130448: LD_VAR 0 2
130452: PUSH
130453: LD_VAR 0 4
130457: PLUS
130458: ST_TO_ADDR
// max_y := y + r ;
130459: LD_ADDR_VAR 0 10
130463: PUSH
130464: LD_VAR 0 3
130468: PUSH
130469: LD_VAR 0 4
130473: PLUS
130474: ST_TO_ADDR
// for _x = min_x to max_x do
130475: LD_ADDR_VAR 0 11
130479: PUSH
130480: DOUBLE
130481: LD_VAR 0 7
130485: DEC
130486: ST_TO_ADDR
130487: LD_VAR 0 9
130491: PUSH
130492: FOR_TO
130493: IFFALSE 130610
// for _y = min_y to max_y do
130495: LD_ADDR_VAR 0 12
130499: PUSH
130500: DOUBLE
130501: LD_VAR 0 8
130505: DEC
130506: ST_TO_ADDR
130507: LD_VAR 0 10
130511: PUSH
130512: FOR_TO
130513: IFFALSE 130606
// begin if not ValidHex ( _x , _y ) then
130515: LD_VAR 0 11
130519: PPUSH
130520: LD_VAR 0 12
130524: PPUSH
130525: CALL_OW 488
130529: NOT
130530: IFFALSE 130534
// continue ;
130532: GO 130512
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
130534: LD_VAR 0 11
130538: PPUSH
130539: LD_VAR 0 12
130543: PPUSH
130544: CALL_OW 351
130548: PUSH
130549: LD_VAR 0 11
130553: PPUSH
130554: LD_VAR 0 12
130558: PPUSH
130559: CALL_OW 554
130563: AND
130564: IFFALSE 130604
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
130566: LD_ADDR_VAR 0 13
130570: PUSH
130571: LD_VAR 0 13
130575: PPUSH
130576: LD_VAR 0 13
130580: PUSH
130581: LD_INT 1
130583: PLUS
130584: PPUSH
130585: LD_VAR 0 11
130589: PUSH
130590: LD_VAR 0 12
130594: PUSH
130595: EMPTY
130596: LIST
130597: LIST
130598: PPUSH
130599: CALL_OW 2
130603: ST_TO_ADDR
// end ;
130604: GO 130512
130606: POP
130607: POP
130608: GO 130492
130610: POP
130611: POP
// if not list then
130612: LD_VAR 0 13
130616: NOT
130617: IFFALSE 130621
// exit ;
130619: GO 130865
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
130621: LD_ADDR_VAR 0 13
130625: PUSH
130626: LD_VAR 0 1
130630: PPUSH
130631: LD_VAR 0 13
130635: PPUSH
130636: LD_INT 1
130638: PPUSH
130639: LD_INT 1
130641: PPUSH
130642: CALL 75722 0 4
130646: ST_TO_ADDR
// ComStop ( flame ) ;
130647: LD_VAR 0 1
130651: PPUSH
130652: CALL_OW 141
// for i in list do
130656: LD_ADDR_VAR 0 6
130660: PUSH
130661: LD_VAR 0 13
130665: PUSH
130666: FOR_IN
130667: IFFALSE 130698
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
130669: LD_VAR 0 1
130673: PPUSH
130674: LD_VAR 0 6
130678: PUSH
130679: LD_INT 1
130681: ARRAY
130682: PPUSH
130683: LD_VAR 0 6
130687: PUSH
130688: LD_INT 2
130690: ARRAY
130691: PPUSH
130692: CALL_OW 176
130696: GO 130666
130698: POP
130699: POP
// repeat wait ( 0 0$1 ) ;
130700: LD_INT 35
130702: PPUSH
130703: CALL_OW 67
// task := GetTaskList ( flame ) ;
130707: LD_ADDR_VAR 0 14
130711: PUSH
130712: LD_VAR 0 1
130716: PPUSH
130717: CALL_OW 437
130721: ST_TO_ADDR
// if not task then
130722: LD_VAR 0 14
130726: NOT
130727: IFFALSE 130731
// exit ;
130729: GO 130865
// if task [ 1 ] [ 1 ] <> | then
130731: LD_VAR 0 14
130735: PUSH
130736: LD_INT 1
130738: ARRAY
130739: PUSH
130740: LD_INT 1
130742: ARRAY
130743: PUSH
130744: LD_STRING |
130746: NONEQUAL
130747: IFFALSE 130751
// exit ;
130749: GO 130865
// _x := task [ 1 ] [ 2 ] ;
130751: LD_ADDR_VAR 0 11
130755: PUSH
130756: LD_VAR 0 14
130760: PUSH
130761: LD_INT 1
130763: ARRAY
130764: PUSH
130765: LD_INT 2
130767: ARRAY
130768: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
130769: LD_ADDR_VAR 0 12
130773: PUSH
130774: LD_VAR 0 14
130778: PUSH
130779: LD_INT 1
130781: ARRAY
130782: PUSH
130783: LD_INT 3
130785: ARRAY
130786: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
130787: LD_VAR 0 11
130791: PPUSH
130792: LD_VAR 0 12
130796: PPUSH
130797: CALL_OW 351
130801: NOT
130802: PUSH
130803: LD_VAR 0 11
130807: PPUSH
130808: LD_VAR 0 12
130812: PPUSH
130813: CALL_OW 554
130817: NOT
130818: OR
130819: IFFALSE 130853
// begin task := Delete ( task , 1 ) ;
130821: LD_ADDR_VAR 0 14
130825: PUSH
130826: LD_VAR 0 14
130830: PPUSH
130831: LD_INT 1
130833: PPUSH
130834: CALL_OW 3
130838: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
130839: LD_VAR 0 1
130843: PPUSH
130844: LD_VAR 0 14
130848: PPUSH
130849: CALL_OW 446
// end ; until not HasTask ( flame ) ;
130853: LD_VAR 0 1
130857: PPUSH
130858: CALL_OW 314
130862: NOT
130863: IFFALSE 130700
// end ;
130865: LD_VAR 0 5
130869: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
130870: LD_EXP 209
130874: NOT
130875: IFFALSE 130925
130877: GO 130879
130879: DISABLE
// begin initHack := true ;
130880: LD_ADDR_EXP 209
130884: PUSH
130885: LD_INT 1
130887: ST_TO_ADDR
// hackTanks := [ ] ;
130888: LD_ADDR_EXP 210
130892: PUSH
130893: EMPTY
130894: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
130895: LD_ADDR_EXP 211
130899: PUSH
130900: EMPTY
130901: ST_TO_ADDR
// hackLimit := 3 ;
130902: LD_ADDR_EXP 212
130906: PUSH
130907: LD_INT 3
130909: ST_TO_ADDR
// hackDist := 12 ;
130910: LD_ADDR_EXP 213
130914: PUSH
130915: LD_INT 12
130917: ST_TO_ADDR
// hackCounter := [ ] ;
130918: LD_ADDR_EXP 214
130922: PUSH
130923: EMPTY
130924: ST_TO_ADDR
// end ;
130925: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
130926: LD_EXP 209
130930: PUSH
130931: LD_INT 34
130933: PUSH
130934: LD_INT 99
130936: PUSH
130937: EMPTY
130938: LIST
130939: LIST
130940: PPUSH
130941: CALL_OW 69
130945: AND
130946: IFFALSE 131199
130948: GO 130950
130950: DISABLE
130951: LD_INT 0
130953: PPUSH
130954: PPUSH
// begin enable ;
130955: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
130956: LD_ADDR_VAR 0 1
130960: PUSH
130961: LD_INT 34
130963: PUSH
130964: LD_INT 99
130966: PUSH
130967: EMPTY
130968: LIST
130969: LIST
130970: PPUSH
130971: CALL_OW 69
130975: PUSH
130976: FOR_IN
130977: IFFALSE 131197
// begin if not i in hackTanks then
130979: LD_VAR 0 1
130983: PUSH
130984: LD_EXP 210
130988: IN
130989: NOT
130990: IFFALSE 131073
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
130992: LD_ADDR_EXP 210
130996: PUSH
130997: LD_EXP 210
131001: PPUSH
131002: LD_EXP 210
131006: PUSH
131007: LD_INT 1
131009: PLUS
131010: PPUSH
131011: LD_VAR 0 1
131015: PPUSH
131016: CALL_OW 1
131020: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
131021: LD_ADDR_EXP 211
131025: PUSH
131026: LD_EXP 211
131030: PPUSH
131031: LD_EXP 211
131035: PUSH
131036: LD_INT 1
131038: PLUS
131039: PPUSH
131040: EMPTY
131041: PPUSH
131042: CALL_OW 1
131046: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
131047: LD_ADDR_EXP 214
131051: PUSH
131052: LD_EXP 214
131056: PPUSH
131057: LD_EXP 214
131061: PUSH
131062: LD_INT 1
131064: PLUS
131065: PPUSH
131066: EMPTY
131067: PPUSH
131068: CALL_OW 1
131072: ST_TO_ADDR
// end ; if not IsOk ( i ) then
131073: LD_VAR 0 1
131077: PPUSH
131078: CALL_OW 302
131082: NOT
131083: IFFALSE 131096
// begin HackUnlinkAll ( i ) ;
131085: LD_VAR 0 1
131089: PPUSH
131090: CALL 131202 0 1
// continue ;
131094: GO 130976
// end ; HackCheckCapturedStatus ( i ) ;
131096: LD_VAR 0 1
131100: PPUSH
131101: CALL 131645 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
131105: LD_ADDR_VAR 0 2
131109: PUSH
131110: LD_INT 81
131112: PUSH
131113: LD_VAR 0 1
131117: PPUSH
131118: CALL_OW 255
131122: PUSH
131123: EMPTY
131124: LIST
131125: LIST
131126: PUSH
131127: LD_INT 33
131129: PUSH
131130: LD_INT 3
131132: PUSH
131133: EMPTY
131134: LIST
131135: LIST
131136: PUSH
131137: LD_INT 91
131139: PUSH
131140: LD_VAR 0 1
131144: PUSH
131145: LD_EXP 213
131149: PUSH
131150: EMPTY
131151: LIST
131152: LIST
131153: LIST
131154: PUSH
131155: LD_INT 50
131157: PUSH
131158: EMPTY
131159: LIST
131160: PUSH
131161: EMPTY
131162: LIST
131163: LIST
131164: LIST
131165: LIST
131166: PPUSH
131167: CALL_OW 69
131171: ST_TO_ADDR
// if not tmp then
131172: LD_VAR 0 2
131176: NOT
131177: IFFALSE 131181
// continue ;
131179: GO 130976
// HackLink ( i , tmp ) ;
131181: LD_VAR 0 1
131185: PPUSH
131186: LD_VAR 0 2
131190: PPUSH
131191: CALL 131338 0 2
// end ;
131195: GO 130976
131197: POP
131198: POP
// end ;
131199: PPOPN 2
131201: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
131202: LD_INT 0
131204: PPUSH
131205: PPUSH
131206: PPUSH
// if not hack in hackTanks then
131207: LD_VAR 0 1
131211: PUSH
131212: LD_EXP 210
131216: IN
131217: NOT
131218: IFFALSE 131222
// exit ;
131220: GO 131333
// index := GetElementIndex ( hackTanks , hack ) ;
131222: LD_ADDR_VAR 0 4
131226: PUSH
131227: LD_EXP 210
131231: PPUSH
131232: LD_VAR 0 1
131236: PPUSH
131237: CALL 75019 0 2
131241: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
131242: LD_EXP 211
131246: PUSH
131247: LD_VAR 0 4
131251: ARRAY
131252: IFFALSE 131333
// begin for i in hackTanksCaptured [ index ] do
131254: LD_ADDR_VAR 0 3
131258: PUSH
131259: LD_EXP 211
131263: PUSH
131264: LD_VAR 0 4
131268: ARRAY
131269: PUSH
131270: FOR_IN
131271: IFFALSE 131297
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
131273: LD_VAR 0 3
131277: PUSH
131278: LD_INT 1
131280: ARRAY
131281: PPUSH
131282: LD_VAR 0 3
131286: PUSH
131287: LD_INT 2
131289: ARRAY
131290: PPUSH
131291: CALL_OW 235
131295: GO 131270
131297: POP
131298: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
131299: LD_ADDR_EXP 211
131303: PUSH
131304: LD_EXP 211
131308: PPUSH
131309: LD_VAR 0 4
131313: PPUSH
131314: EMPTY
131315: PPUSH
131316: CALL_OW 1
131320: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
131321: LD_VAR 0 1
131325: PPUSH
131326: LD_INT 0
131328: PPUSH
131329: CALL_OW 505
// end ; end ;
131333: LD_VAR 0 2
131337: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
131338: LD_INT 0
131340: PPUSH
131341: PPUSH
131342: PPUSH
// if not hack in hackTanks or not vehicles then
131343: LD_VAR 0 1
131347: PUSH
131348: LD_EXP 210
131352: IN
131353: NOT
131354: PUSH
131355: LD_VAR 0 2
131359: NOT
131360: OR
131361: IFFALSE 131365
// exit ;
131363: GO 131640
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
131365: LD_ADDR_VAR 0 2
131369: PUSH
131370: LD_VAR 0 1
131374: PPUSH
131375: LD_VAR 0 2
131379: PPUSH
131380: LD_INT 1
131382: PPUSH
131383: LD_INT 1
131385: PPUSH
131386: CALL 75669 0 4
131390: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
131391: LD_ADDR_VAR 0 5
131395: PUSH
131396: LD_EXP 210
131400: PPUSH
131401: LD_VAR 0 1
131405: PPUSH
131406: CALL 75019 0 2
131410: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
131411: LD_EXP 211
131415: PUSH
131416: LD_VAR 0 5
131420: ARRAY
131421: PUSH
131422: LD_EXP 212
131426: LESS
131427: IFFALSE 131616
// begin for i := 1 to vehicles do
131429: LD_ADDR_VAR 0 4
131433: PUSH
131434: DOUBLE
131435: LD_INT 1
131437: DEC
131438: ST_TO_ADDR
131439: LD_VAR 0 2
131443: PUSH
131444: FOR_TO
131445: IFFALSE 131614
// begin if hackTanksCaptured [ index ] = hackLimit then
131447: LD_EXP 211
131451: PUSH
131452: LD_VAR 0 5
131456: ARRAY
131457: PUSH
131458: LD_EXP 212
131462: EQUAL
131463: IFFALSE 131467
// break ;
131465: GO 131614
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
131467: LD_ADDR_EXP 214
131471: PUSH
131472: LD_EXP 214
131476: PPUSH
131477: LD_VAR 0 5
131481: PPUSH
131482: LD_EXP 214
131486: PUSH
131487: LD_VAR 0 5
131491: ARRAY
131492: PUSH
131493: LD_INT 1
131495: PLUS
131496: PPUSH
131497: CALL_OW 1
131501: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
131502: LD_ADDR_EXP 211
131506: PUSH
131507: LD_EXP 211
131511: PPUSH
131512: LD_VAR 0 5
131516: PUSH
131517: LD_EXP 211
131521: PUSH
131522: LD_VAR 0 5
131526: ARRAY
131527: PUSH
131528: LD_INT 1
131530: PLUS
131531: PUSH
131532: EMPTY
131533: LIST
131534: LIST
131535: PPUSH
131536: LD_VAR 0 2
131540: PUSH
131541: LD_VAR 0 4
131545: ARRAY
131546: PUSH
131547: LD_VAR 0 2
131551: PUSH
131552: LD_VAR 0 4
131556: ARRAY
131557: PPUSH
131558: CALL_OW 255
131562: PUSH
131563: EMPTY
131564: LIST
131565: LIST
131566: PPUSH
131567: CALL 75234 0 3
131571: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
131572: LD_VAR 0 2
131576: PUSH
131577: LD_VAR 0 4
131581: ARRAY
131582: PPUSH
131583: LD_VAR 0 1
131587: PPUSH
131588: CALL_OW 255
131592: PPUSH
131593: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
131597: LD_VAR 0 2
131601: PUSH
131602: LD_VAR 0 4
131606: ARRAY
131607: PPUSH
131608: CALL_OW 141
// end ;
131612: GO 131444
131614: POP
131615: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
131616: LD_VAR 0 1
131620: PPUSH
131621: LD_EXP 211
131625: PUSH
131626: LD_VAR 0 5
131630: ARRAY
131631: PUSH
131632: LD_INT 0
131634: PLUS
131635: PPUSH
131636: CALL_OW 505
// end ;
131640: LD_VAR 0 3
131644: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
131645: LD_INT 0
131647: PPUSH
131648: PPUSH
131649: PPUSH
131650: PPUSH
// if not hack in hackTanks then
131651: LD_VAR 0 1
131655: PUSH
131656: LD_EXP 210
131660: IN
131661: NOT
131662: IFFALSE 131666
// exit ;
131664: GO 131906
// index := GetElementIndex ( hackTanks , hack ) ;
131666: LD_ADDR_VAR 0 4
131670: PUSH
131671: LD_EXP 210
131675: PPUSH
131676: LD_VAR 0 1
131680: PPUSH
131681: CALL 75019 0 2
131685: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
131686: LD_ADDR_VAR 0 3
131690: PUSH
131691: DOUBLE
131692: LD_EXP 211
131696: PUSH
131697: LD_VAR 0 4
131701: ARRAY
131702: INC
131703: ST_TO_ADDR
131704: LD_INT 1
131706: PUSH
131707: FOR_DOWNTO
131708: IFFALSE 131880
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
131710: LD_ADDR_VAR 0 5
131714: PUSH
131715: LD_EXP 211
131719: PUSH
131720: LD_VAR 0 4
131724: ARRAY
131725: PUSH
131726: LD_VAR 0 3
131730: ARRAY
131731: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
131732: LD_VAR 0 5
131736: PUSH
131737: LD_INT 1
131739: ARRAY
131740: PPUSH
131741: CALL_OW 302
131745: NOT
131746: PUSH
131747: LD_VAR 0 5
131751: PUSH
131752: LD_INT 1
131754: ARRAY
131755: PPUSH
131756: CALL_OW 255
131760: PUSH
131761: LD_VAR 0 1
131765: PPUSH
131766: CALL_OW 255
131770: NONEQUAL
131771: OR
131772: IFFALSE 131878
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
131774: LD_VAR 0 5
131778: PUSH
131779: LD_INT 1
131781: ARRAY
131782: PPUSH
131783: CALL_OW 305
131787: PUSH
131788: LD_VAR 0 5
131792: PUSH
131793: LD_INT 1
131795: ARRAY
131796: PPUSH
131797: CALL_OW 255
131801: PUSH
131802: LD_VAR 0 1
131806: PPUSH
131807: CALL_OW 255
131811: EQUAL
131812: AND
131813: IFFALSE 131837
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
131815: LD_VAR 0 5
131819: PUSH
131820: LD_INT 1
131822: ARRAY
131823: PPUSH
131824: LD_VAR 0 5
131828: PUSH
131829: LD_INT 2
131831: ARRAY
131832: PPUSH
131833: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
131837: LD_ADDR_EXP 211
131841: PUSH
131842: LD_EXP 211
131846: PPUSH
131847: LD_VAR 0 4
131851: PPUSH
131852: LD_EXP 211
131856: PUSH
131857: LD_VAR 0 4
131861: ARRAY
131862: PPUSH
131863: LD_VAR 0 3
131867: PPUSH
131868: CALL_OW 3
131872: PPUSH
131873: CALL_OW 1
131877: ST_TO_ADDR
// end ; end ;
131878: GO 131707
131880: POP
131881: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
131882: LD_VAR 0 1
131886: PPUSH
131887: LD_EXP 211
131891: PUSH
131892: LD_VAR 0 4
131896: ARRAY
131897: PUSH
131898: LD_INT 0
131900: PLUS
131901: PPUSH
131902: CALL_OW 505
// end ;
131906: LD_VAR 0 2
131910: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
131911: LD_INT 0
131913: PPUSH
131914: PPUSH
131915: PPUSH
131916: PPUSH
// if not hack in hackTanks then
131917: LD_VAR 0 1
131921: PUSH
131922: LD_EXP 210
131926: IN
131927: NOT
131928: IFFALSE 131932
// exit ;
131930: GO 132017
// index := GetElementIndex ( hackTanks , hack ) ;
131932: LD_ADDR_VAR 0 5
131936: PUSH
131937: LD_EXP 210
131941: PPUSH
131942: LD_VAR 0 1
131946: PPUSH
131947: CALL 75019 0 2
131951: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
131952: LD_ADDR_VAR 0 4
131956: PUSH
131957: DOUBLE
131958: LD_INT 1
131960: DEC
131961: ST_TO_ADDR
131962: LD_EXP 211
131966: PUSH
131967: LD_VAR 0 5
131971: ARRAY
131972: PUSH
131973: FOR_TO
131974: IFFALSE 132015
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
131976: LD_EXP 211
131980: PUSH
131981: LD_VAR 0 5
131985: ARRAY
131986: PUSH
131987: LD_VAR 0 4
131991: ARRAY
131992: PUSH
131993: LD_INT 1
131995: ARRAY
131996: PUSH
131997: LD_VAR 0 2
132001: EQUAL
132002: IFFALSE 132013
// KillUnit ( vehicle ) ;
132004: LD_VAR 0 2
132008: PPUSH
132009: CALL_OW 66
132013: GO 131973
132015: POP
132016: POP
// end ;
132017: LD_VAR 0 3
132021: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
132022: LD_EXP 215
132026: NOT
132027: IFFALSE 132062
132029: GO 132031
132031: DISABLE
// begin initMiner := true ;
132032: LD_ADDR_EXP 215
132036: PUSH
132037: LD_INT 1
132039: ST_TO_ADDR
// minersList := [ ] ;
132040: LD_ADDR_EXP 216
132044: PUSH
132045: EMPTY
132046: ST_TO_ADDR
// minerMinesList := [ ] ;
132047: LD_ADDR_EXP 217
132051: PUSH
132052: EMPTY
132053: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
132054: LD_ADDR_EXP 218
132058: PUSH
132059: LD_INT 5
132061: ST_TO_ADDR
// end ;
132062: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
132063: LD_EXP 215
132067: PUSH
132068: LD_INT 34
132070: PUSH
132071: LD_INT 81
132073: PUSH
132074: EMPTY
132075: LIST
132076: LIST
132077: PPUSH
132078: CALL_OW 69
132082: AND
132083: IFFALSE 132544
132085: GO 132087
132087: DISABLE
132088: LD_INT 0
132090: PPUSH
132091: PPUSH
132092: PPUSH
132093: PPUSH
// begin enable ;
132094: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
132095: LD_ADDR_VAR 0 1
132099: PUSH
132100: LD_INT 34
132102: PUSH
132103: LD_INT 81
132105: PUSH
132106: EMPTY
132107: LIST
132108: LIST
132109: PPUSH
132110: CALL_OW 69
132114: PUSH
132115: FOR_IN
132116: IFFALSE 132188
// begin if not i in minersList then
132118: LD_VAR 0 1
132122: PUSH
132123: LD_EXP 216
132127: IN
132128: NOT
132129: IFFALSE 132186
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
132131: LD_ADDR_EXP 216
132135: PUSH
132136: LD_EXP 216
132140: PPUSH
132141: LD_EXP 216
132145: PUSH
132146: LD_INT 1
132148: PLUS
132149: PPUSH
132150: LD_VAR 0 1
132154: PPUSH
132155: CALL_OW 1
132159: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
132160: LD_ADDR_EXP 217
132164: PUSH
132165: LD_EXP 217
132169: PPUSH
132170: LD_EXP 217
132174: PUSH
132175: LD_INT 1
132177: PLUS
132178: PPUSH
132179: EMPTY
132180: PPUSH
132181: CALL_OW 1
132185: ST_TO_ADDR
// end end ;
132186: GO 132115
132188: POP
132189: POP
// for i := minerMinesList downto 1 do
132190: LD_ADDR_VAR 0 1
132194: PUSH
132195: DOUBLE
132196: LD_EXP 217
132200: INC
132201: ST_TO_ADDR
132202: LD_INT 1
132204: PUSH
132205: FOR_DOWNTO
132206: IFFALSE 132542
// begin if IsLive ( minersList [ i ] ) then
132208: LD_EXP 216
132212: PUSH
132213: LD_VAR 0 1
132217: ARRAY
132218: PPUSH
132219: CALL_OW 300
132223: IFFALSE 132251
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
132225: LD_EXP 216
132229: PUSH
132230: LD_VAR 0 1
132234: ARRAY
132235: PPUSH
132236: LD_EXP 217
132240: PUSH
132241: LD_VAR 0 1
132245: ARRAY
132246: PPUSH
132247: CALL_OW 505
// if not minerMinesList [ i ] then
132251: LD_EXP 217
132255: PUSH
132256: LD_VAR 0 1
132260: ARRAY
132261: NOT
132262: IFFALSE 132266
// continue ;
132264: GO 132205
// for j := minerMinesList [ i ] downto 1 do
132266: LD_ADDR_VAR 0 2
132270: PUSH
132271: DOUBLE
132272: LD_EXP 217
132276: PUSH
132277: LD_VAR 0 1
132281: ARRAY
132282: INC
132283: ST_TO_ADDR
132284: LD_INT 1
132286: PUSH
132287: FOR_DOWNTO
132288: IFFALSE 132538
// begin side := GetSide ( minersList [ i ] ) ;
132290: LD_ADDR_VAR 0 3
132294: PUSH
132295: LD_EXP 216
132299: PUSH
132300: LD_VAR 0 1
132304: ARRAY
132305: PPUSH
132306: CALL_OW 255
132310: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
132311: LD_ADDR_VAR 0 4
132315: PUSH
132316: LD_EXP 217
132320: PUSH
132321: LD_VAR 0 1
132325: ARRAY
132326: PUSH
132327: LD_VAR 0 2
132331: ARRAY
132332: PUSH
132333: LD_INT 1
132335: ARRAY
132336: PPUSH
132337: LD_EXP 217
132341: PUSH
132342: LD_VAR 0 1
132346: ARRAY
132347: PUSH
132348: LD_VAR 0 2
132352: ARRAY
132353: PUSH
132354: LD_INT 2
132356: ARRAY
132357: PPUSH
132358: CALL_OW 428
132362: ST_TO_ADDR
// if not tmp then
132363: LD_VAR 0 4
132367: NOT
132368: IFFALSE 132372
// continue ;
132370: GO 132287
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
132372: LD_VAR 0 4
132376: PUSH
132377: LD_INT 81
132379: PUSH
132380: LD_VAR 0 3
132384: PUSH
132385: EMPTY
132386: LIST
132387: LIST
132388: PPUSH
132389: CALL_OW 69
132393: IN
132394: PUSH
132395: LD_EXP 217
132399: PUSH
132400: LD_VAR 0 1
132404: ARRAY
132405: PUSH
132406: LD_VAR 0 2
132410: ARRAY
132411: PUSH
132412: LD_INT 1
132414: ARRAY
132415: PPUSH
132416: LD_EXP 217
132420: PUSH
132421: LD_VAR 0 1
132425: ARRAY
132426: PUSH
132427: LD_VAR 0 2
132431: ARRAY
132432: PUSH
132433: LD_INT 2
132435: ARRAY
132436: PPUSH
132437: CALL_OW 458
132441: AND
132442: IFFALSE 132536
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
132444: LD_EXP 217
132448: PUSH
132449: LD_VAR 0 1
132453: ARRAY
132454: PUSH
132455: LD_VAR 0 2
132459: ARRAY
132460: PUSH
132461: LD_INT 1
132463: ARRAY
132464: PPUSH
132465: LD_EXP 217
132469: PUSH
132470: LD_VAR 0 1
132474: ARRAY
132475: PUSH
132476: LD_VAR 0 2
132480: ARRAY
132481: PUSH
132482: LD_INT 2
132484: ARRAY
132485: PPUSH
132486: LD_VAR 0 3
132490: PPUSH
132491: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
132495: LD_ADDR_EXP 217
132499: PUSH
132500: LD_EXP 217
132504: PPUSH
132505: LD_VAR 0 1
132509: PPUSH
132510: LD_EXP 217
132514: PUSH
132515: LD_VAR 0 1
132519: ARRAY
132520: PPUSH
132521: LD_VAR 0 2
132525: PPUSH
132526: CALL_OW 3
132530: PPUSH
132531: CALL_OW 1
132535: ST_TO_ADDR
// end ; end ;
132536: GO 132287
132538: POP
132539: POP
// end ;
132540: GO 132205
132542: POP
132543: POP
// end ;
132544: PPOPN 4
132546: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
132547: LD_INT 0
132549: PPUSH
132550: PPUSH
// result := false ;
132551: LD_ADDR_VAR 0 4
132555: PUSH
132556: LD_INT 0
132558: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
132559: LD_VAR 0 1
132563: PPUSH
132564: CALL_OW 264
132568: PUSH
132569: LD_INT 81
132571: EQUAL
132572: NOT
132573: IFFALSE 132577
// exit ;
132575: GO 132817
// index := GetElementIndex ( minersList , unit ) ;
132577: LD_ADDR_VAR 0 5
132581: PUSH
132582: LD_EXP 216
132586: PPUSH
132587: LD_VAR 0 1
132591: PPUSH
132592: CALL 75019 0 2
132596: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
132597: LD_EXP 217
132601: PUSH
132602: LD_VAR 0 5
132606: ARRAY
132607: PUSH
132608: LD_EXP 218
132612: GREATEREQUAL
132613: IFFALSE 132617
// exit ;
132615: GO 132817
// ComMoveXY ( unit , x , y ) ;
132617: LD_VAR 0 1
132621: PPUSH
132622: LD_VAR 0 2
132626: PPUSH
132627: LD_VAR 0 3
132631: PPUSH
132632: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
132636: LD_INT 35
132638: PPUSH
132639: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
132643: LD_VAR 0 1
132647: PPUSH
132648: LD_VAR 0 2
132652: PPUSH
132653: LD_VAR 0 3
132657: PPUSH
132658: CALL 106760 0 3
132662: NOT
132663: PUSH
132664: LD_VAR 0 1
132668: PPUSH
132669: CALL_OW 314
132673: AND
132674: IFFALSE 132678
// exit ;
132676: GO 132817
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
132678: LD_VAR 0 2
132682: PPUSH
132683: LD_VAR 0 3
132687: PPUSH
132688: CALL_OW 428
132692: PUSH
132693: LD_VAR 0 1
132697: EQUAL
132698: PUSH
132699: LD_VAR 0 1
132703: PPUSH
132704: CALL_OW 314
132708: NOT
132709: AND
132710: IFFALSE 132636
// PlaySoundXY ( x , y , PlantMine ) ;
132712: LD_VAR 0 2
132716: PPUSH
132717: LD_VAR 0 3
132721: PPUSH
132722: LD_STRING PlantMine
132724: PPUSH
132725: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
132729: LD_VAR 0 2
132733: PPUSH
132734: LD_VAR 0 3
132738: PPUSH
132739: LD_VAR 0 1
132743: PPUSH
132744: CALL_OW 255
132748: PPUSH
132749: LD_INT 0
132751: PPUSH
132752: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
132756: LD_ADDR_EXP 217
132760: PUSH
132761: LD_EXP 217
132765: PPUSH
132766: LD_VAR 0 5
132770: PUSH
132771: LD_EXP 217
132775: PUSH
132776: LD_VAR 0 5
132780: ARRAY
132781: PUSH
132782: LD_INT 1
132784: PLUS
132785: PUSH
132786: EMPTY
132787: LIST
132788: LIST
132789: PPUSH
132790: LD_VAR 0 2
132794: PUSH
132795: LD_VAR 0 3
132799: PUSH
132800: EMPTY
132801: LIST
132802: LIST
132803: PPUSH
132804: CALL 75234 0 3
132808: ST_TO_ADDR
// result := true ;
132809: LD_ADDR_VAR 0 4
132813: PUSH
132814: LD_INT 1
132816: ST_TO_ADDR
// end ;
132817: LD_VAR 0 4
132821: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
132822: LD_INT 0
132824: PPUSH
132825: PPUSH
132826: PPUSH
// if not unit in minersList then
132827: LD_VAR 0 1
132831: PUSH
132832: LD_EXP 216
132836: IN
132837: NOT
132838: IFFALSE 132842
// exit ;
132840: GO 133234
// index := GetElementIndex ( minersList , unit ) ;
132842: LD_ADDR_VAR 0 6
132846: PUSH
132847: LD_EXP 216
132851: PPUSH
132852: LD_VAR 0 1
132856: PPUSH
132857: CALL 75019 0 2
132861: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
132862: LD_ADDR_VAR 0 5
132866: PUSH
132867: DOUBLE
132868: LD_EXP 217
132872: PUSH
132873: LD_VAR 0 6
132877: ARRAY
132878: INC
132879: ST_TO_ADDR
132880: LD_INT 1
132882: PUSH
132883: FOR_DOWNTO
132884: IFFALSE 133045
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
132886: LD_EXP 217
132890: PUSH
132891: LD_VAR 0 6
132895: ARRAY
132896: PUSH
132897: LD_VAR 0 5
132901: ARRAY
132902: PUSH
132903: LD_INT 1
132905: ARRAY
132906: PUSH
132907: LD_VAR 0 2
132911: EQUAL
132912: PUSH
132913: LD_EXP 217
132917: PUSH
132918: LD_VAR 0 6
132922: ARRAY
132923: PUSH
132924: LD_VAR 0 5
132928: ARRAY
132929: PUSH
132930: LD_INT 2
132932: ARRAY
132933: PUSH
132934: LD_VAR 0 3
132938: EQUAL
132939: AND
132940: IFFALSE 133043
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
132942: LD_EXP 217
132946: PUSH
132947: LD_VAR 0 6
132951: ARRAY
132952: PUSH
132953: LD_VAR 0 5
132957: ARRAY
132958: PUSH
132959: LD_INT 1
132961: ARRAY
132962: PPUSH
132963: LD_EXP 217
132967: PUSH
132968: LD_VAR 0 6
132972: ARRAY
132973: PUSH
132974: LD_VAR 0 5
132978: ARRAY
132979: PUSH
132980: LD_INT 2
132982: ARRAY
132983: PPUSH
132984: LD_VAR 0 1
132988: PPUSH
132989: CALL_OW 255
132993: PPUSH
132994: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
132998: LD_ADDR_EXP 217
133002: PUSH
133003: LD_EXP 217
133007: PPUSH
133008: LD_VAR 0 6
133012: PPUSH
133013: LD_EXP 217
133017: PUSH
133018: LD_VAR 0 6
133022: ARRAY
133023: PPUSH
133024: LD_VAR 0 5
133028: PPUSH
133029: CALL_OW 3
133033: PPUSH
133034: CALL_OW 1
133038: ST_TO_ADDR
// exit ;
133039: POP
133040: POP
133041: GO 133234
// end ; end ;
133043: GO 132883
133045: POP
133046: POP
// for i := minerMinesList [ index ] downto 1 do
133047: LD_ADDR_VAR 0 5
133051: PUSH
133052: DOUBLE
133053: LD_EXP 217
133057: PUSH
133058: LD_VAR 0 6
133062: ARRAY
133063: INC
133064: ST_TO_ADDR
133065: LD_INT 1
133067: PUSH
133068: FOR_DOWNTO
133069: IFFALSE 133232
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
133071: LD_EXP 217
133075: PUSH
133076: LD_VAR 0 6
133080: ARRAY
133081: PUSH
133082: LD_VAR 0 5
133086: ARRAY
133087: PUSH
133088: LD_INT 1
133090: ARRAY
133091: PPUSH
133092: LD_EXP 217
133096: PUSH
133097: LD_VAR 0 6
133101: ARRAY
133102: PUSH
133103: LD_VAR 0 5
133107: ARRAY
133108: PUSH
133109: LD_INT 2
133111: ARRAY
133112: PPUSH
133113: LD_VAR 0 2
133117: PPUSH
133118: LD_VAR 0 3
133122: PPUSH
133123: CALL_OW 298
133127: PUSH
133128: LD_INT 6
133130: LESS
133131: IFFALSE 133230
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
133133: LD_EXP 217
133137: PUSH
133138: LD_VAR 0 6
133142: ARRAY
133143: PUSH
133144: LD_VAR 0 5
133148: ARRAY
133149: PUSH
133150: LD_INT 1
133152: ARRAY
133153: PPUSH
133154: LD_EXP 217
133158: PUSH
133159: LD_VAR 0 6
133163: ARRAY
133164: PUSH
133165: LD_VAR 0 5
133169: ARRAY
133170: PUSH
133171: LD_INT 2
133173: ARRAY
133174: PPUSH
133175: LD_VAR 0 1
133179: PPUSH
133180: CALL_OW 255
133184: PPUSH
133185: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
133189: LD_ADDR_EXP 217
133193: PUSH
133194: LD_EXP 217
133198: PPUSH
133199: LD_VAR 0 6
133203: PPUSH
133204: LD_EXP 217
133208: PUSH
133209: LD_VAR 0 6
133213: ARRAY
133214: PPUSH
133215: LD_VAR 0 5
133219: PPUSH
133220: CALL_OW 3
133224: PPUSH
133225: CALL_OW 1
133229: ST_TO_ADDR
// end ; end ;
133230: GO 133068
133232: POP
133233: POP
// end ;
133234: LD_VAR 0 4
133238: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
133239: LD_INT 0
133241: PPUSH
133242: PPUSH
133243: PPUSH
133244: PPUSH
133245: PPUSH
133246: PPUSH
133247: PPUSH
133248: PPUSH
133249: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
133250: LD_VAR 0 1
133254: PPUSH
133255: CALL_OW 264
133259: PUSH
133260: LD_INT 81
133262: EQUAL
133263: NOT
133264: PUSH
133265: LD_VAR 0 1
133269: PUSH
133270: LD_EXP 216
133274: IN
133275: NOT
133276: OR
133277: IFFALSE 133281
// exit ;
133279: GO 133603
// index := GetElementIndex ( minersList , unit ) ;
133281: LD_ADDR_VAR 0 6
133285: PUSH
133286: LD_EXP 216
133290: PPUSH
133291: LD_VAR 0 1
133295: PPUSH
133296: CALL 75019 0 2
133300: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
133301: LD_ADDR_VAR 0 8
133305: PUSH
133306: LD_EXP 218
133310: PUSH
133311: LD_EXP 217
133315: PUSH
133316: LD_VAR 0 6
133320: ARRAY
133321: MINUS
133322: ST_TO_ADDR
// if not minesFreeAmount then
133323: LD_VAR 0 8
133327: NOT
133328: IFFALSE 133332
// exit ;
133330: GO 133603
// tmp := [ ] ;
133332: LD_ADDR_VAR 0 7
133336: PUSH
133337: EMPTY
133338: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
133339: LD_ADDR_VAR 0 5
133343: PUSH
133344: DOUBLE
133345: LD_INT 1
133347: DEC
133348: ST_TO_ADDR
133349: LD_VAR 0 8
133353: PUSH
133354: FOR_TO
133355: IFFALSE 133550
// begin _d := rand ( 0 , 5 ) ;
133357: LD_ADDR_VAR 0 11
133361: PUSH
133362: LD_INT 0
133364: PPUSH
133365: LD_INT 5
133367: PPUSH
133368: CALL_OW 12
133372: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
133373: LD_ADDR_VAR 0 12
133377: PUSH
133378: LD_INT 2
133380: PPUSH
133381: LD_INT 6
133383: PPUSH
133384: CALL_OW 12
133388: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
133389: LD_ADDR_VAR 0 9
133393: PUSH
133394: LD_VAR 0 2
133398: PPUSH
133399: LD_VAR 0 11
133403: PPUSH
133404: LD_VAR 0 12
133408: PPUSH
133409: CALL_OW 272
133413: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
133414: LD_ADDR_VAR 0 10
133418: PUSH
133419: LD_VAR 0 3
133423: PPUSH
133424: LD_VAR 0 11
133428: PPUSH
133429: LD_VAR 0 12
133433: PPUSH
133434: CALL_OW 273
133438: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
133439: LD_VAR 0 9
133443: PPUSH
133444: LD_VAR 0 10
133448: PPUSH
133449: CALL_OW 488
133453: PUSH
133454: LD_VAR 0 9
133458: PUSH
133459: LD_VAR 0 10
133463: PUSH
133464: EMPTY
133465: LIST
133466: LIST
133467: PUSH
133468: LD_VAR 0 7
133472: IN
133473: NOT
133474: AND
133475: PUSH
133476: LD_VAR 0 9
133480: PPUSH
133481: LD_VAR 0 10
133485: PPUSH
133486: CALL_OW 458
133490: NOT
133491: AND
133492: IFFALSE 133534
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
133494: LD_ADDR_VAR 0 7
133498: PUSH
133499: LD_VAR 0 7
133503: PPUSH
133504: LD_VAR 0 7
133508: PUSH
133509: LD_INT 1
133511: PLUS
133512: PPUSH
133513: LD_VAR 0 9
133517: PUSH
133518: LD_VAR 0 10
133522: PUSH
133523: EMPTY
133524: LIST
133525: LIST
133526: PPUSH
133527: CALL_OW 1
133531: ST_TO_ADDR
133532: GO 133548
// i := i - 1 ;
133534: LD_ADDR_VAR 0 5
133538: PUSH
133539: LD_VAR 0 5
133543: PUSH
133544: LD_INT 1
133546: MINUS
133547: ST_TO_ADDR
// end ;
133548: GO 133354
133550: POP
133551: POP
// for i in tmp do
133552: LD_ADDR_VAR 0 5
133556: PUSH
133557: LD_VAR 0 7
133561: PUSH
133562: FOR_IN
133563: IFFALSE 133601
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
133565: LD_VAR 0 1
133569: PPUSH
133570: LD_VAR 0 5
133574: PUSH
133575: LD_INT 1
133577: ARRAY
133578: PPUSH
133579: LD_VAR 0 5
133583: PUSH
133584: LD_INT 2
133586: ARRAY
133587: PPUSH
133588: CALL 132547 0 3
133592: NOT
133593: IFFALSE 133599
// exit ;
133595: POP
133596: POP
133597: GO 133603
133599: GO 133562
133601: POP
133602: POP
// end ;
133603: LD_VAR 0 4
133607: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , dir , viewRange , _x , _y , _d , p ; begin
133608: LD_INT 0
133610: PPUSH
133611: PPUSH
133612: PPUSH
133613: PPUSH
133614: PPUSH
133615: PPUSH
133616: PPUSH
133617: PPUSH
133618: PPUSH
// if GetClass ( unit ) <> class_sniper then
133619: LD_VAR 0 1
133623: PPUSH
133624: CALL_OW 257
133628: PUSH
133629: LD_INT 5
133631: NONEQUAL
133632: IFFALSE 133636
// exit ;
133634: GO 134102
// dist := 8 ;
133636: LD_ADDR_VAR 0 5
133640: PUSH
133641: LD_INT 8
133643: ST_TO_ADDR
// viewRange := 12 ;
133644: LD_ADDR_VAR 0 8
133648: PUSH
133649: LD_INT 12
133651: ST_TO_ADDR
// side := GetSide ( unit ) ;
133652: LD_ADDR_VAR 0 6
133656: PUSH
133657: LD_VAR 0 1
133661: PPUSH
133662: CALL_OW 255
133666: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
133667: LD_INT 61
133669: PPUSH
133670: LD_VAR 0 6
133674: PPUSH
133675: CALL_OW 321
133679: PUSH
133680: LD_INT 2
133682: EQUAL
133683: IFFALSE 133693
// viewRange := 16 ;
133685: LD_ADDR_VAR 0 8
133689: PUSH
133690: LD_INT 16
133692: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
133693: LD_VAR 0 1
133697: PPUSH
133698: LD_VAR 0 2
133702: PPUSH
133703: LD_VAR 0 3
133707: PPUSH
133708: CALL_OW 297
133712: PUSH
133713: LD_VAR 0 5
133717: GREATER
133718: IFFALSE 133797
// begin ComMoveXY ( unit , x , y ) ;
133720: LD_VAR 0 1
133724: PPUSH
133725: LD_VAR 0 2
133729: PPUSH
133730: LD_VAR 0 3
133734: PPUSH
133735: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
133739: LD_INT 35
133741: PPUSH
133742: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
133746: LD_VAR 0 1
133750: PPUSH
133751: LD_VAR 0 2
133755: PPUSH
133756: LD_VAR 0 3
133760: PPUSH
133761: CALL 106760 0 3
133765: NOT
133766: IFFALSE 133770
// exit ;
133768: GO 134102
// until GetDistUnitXY ( unit , x , y ) < dist ;
133770: LD_VAR 0 1
133774: PPUSH
133775: LD_VAR 0 2
133779: PPUSH
133780: LD_VAR 0 3
133784: PPUSH
133785: CALL_OW 297
133789: PUSH
133790: LD_VAR 0 5
133794: LESS
133795: IFFALSE 133739
// end ; ComTurnXY ( unit , x , y ) ;
133797: LD_VAR 0 1
133801: PPUSH
133802: LD_VAR 0 2
133806: PPUSH
133807: LD_VAR 0 3
133811: PPUSH
133812: CALL_OW 118
// repeat if Multiplayer then
133816: LD_OWVAR 4
133820: IFFALSE 133831
// wait ( 35 ) else
133822: LD_INT 35
133824: PPUSH
133825: CALL_OW 67
133829: GO 133838
// wait ( 5 ) ;
133831: LD_INT 5
133833: PPUSH
133834: CALL_OW 67
// _d := GetDir ( unit ) ;
133838: LD_ADDR_VAR 0 11
133842: PUSH
133843: LD_VAR 0 1
133847: PPUSH
133848: CALL_OW 254
133852: ST_TO_ADDR
// dir := GetDirFromHex ( GetX ( unit ) , GetY ( unit ) , x , y ) ;
133853: LD_ADDR_VAR 0 7
133857: PUSH
133858: LD_VAR 0 1
133862: PPUSH
133863: CALL_OW 250
133867: PPUSH
133868: LD_VAR 0 1
133872: PPUSH
133873: CALL_OW 251
133877: PPUSH
133878: LD_VAR 0 2
133882: PPUSH
133883: LD_VAR 0 3
133887: PPUSH
133888: CALL 109368 0 4
133892: ST_TO_ADDR
// until dir = _d ;
133893: LD_VAR 0 7
133897: PUSH
133898: LD_VAR 0 11
133902: EQUAL
133903: IFFALSE 133816
// _x := ShiftX ( GetX ( unit ) , dir , dist ) ;
133905: LD_ADDR_VAR 0 9
133909: PUSH
133910: LD_VAR 0 1
133914: PPUSH
133915: CALL_OW 250
133919: PPUSH
133920: LD_VAR 0 7
133924: PPUSH
133925: LD_VAR 0 5
133929: PPUSH
133930: CALL_OW 272
133934: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , dir , dist ) ;
133935: LD_ADDR_VAR 0 10
133939: PUSH
133940: LD_VAR 0 1
133944: PPUSH
133945: CALL_OW 251
133949: PPUSH
133950: LD_VAR 0 7
133954: PPUSH
133955: LD_VAR 0 5
133959: PPUSH
133960: CALL_OW 273
133964: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
133965: LD_VAR 0 9
133969: PPUSH
133970: LD_VAR 0 10
133974: PPUSH
133975: CALL_OW 488
133979: NOT
133980: IFFALSE 133984
// exit ;
133982: GO 134102
// ComAnimCustom ( unit , 1 ) ;
133984: LD_VAR 0 1
133988: PPUSH
133989: LD_INT 1
133991: PPUSH
133992: CALL_OW 592
// p := 0 ;
133996: LD_ADDR_VAR 0 12
134000: PUSH
134001: LD_INT 0
134003: ST_TO_ADDR
// PlaceSeeing ( _x , _y , side , viewRange ) ;
134004: LD_VAR 0 9
134008: PPUSH
134009: LD_VAR 0 10
134013: PPUSH
134014: LD_VAR 0 6
134018: PPUSH
134019: LD_VAR 0 8
134023: PPUSH
134024: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
134028: LD_INT 35
134030: PPUSH
134031: CALL_OW 67
// p := Inc ( p ) ;
134035: LD_ADDR_VAR 0 12
134039: PUSH
134040: LD_VAR 0 12
134044: PPUSH
134045: CALL 109324 0 1
134049: ST_TO_ADDR
// until p = 3 or not IsOk ( unit ) or IsDead ( unit ) ;
134050: LD_VAR 0 12
134054: PUSH
134055: LD_INT 3
134057: EQUAL
134058: PUSH
134059: LD_VAR 0 1
134063: PPUSH
134064: CALL_OW 302
134068: NOT
134069: OR
134070: PUSH
134071: LD_VAR 0 1
134075: PPUSH
134076: CALL_OW 301
134080: OR
134081: IFFALSE 134028
// RemoveSeeing ( _x , _y , side ) ;
134083: LD_VAR 0 9
134087: PPUSH
134088: LD_VAR 0 10
134092: PPUSH
134093: LD_VAR 0 6
134097: PPUSH
134098: CALL_OW 331
// end ; end_of_file
134102: LD_VAR 0 4
134106: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
134107: LD_INT 0
134109: PPUSH
134110: PPUSH
134111: PPUSH
134112: PPUSH
134113: PPUSH
134114: PPUSH
134115: PPUSH
134116: PPUSH
134117: PPUSH
134118: PPUSH
134119: PPUSH
134120: PPUSH
134121: PPUSH
134122: PPUSH
134123: PPUSH
134124: PPUSH
134125: PPUSH
134126: PPUSH
134127: PPUSH
134128: PPUSH
134129: PPUSH
134130: PPUSH
134131: PPUSH
134132: PPUSH
134133: PPUSH
134134: PPUSH
134135: PPUSH
134136: PPUSH
134137: PPUSH
134138: PPUSH
134139: PPUSH
134140: PPUSH
134141: PPUSH
134142: PPUSH
// if not list then
134143: LD_VAR 0 1
134147: NOT
134148: IFFALSE 134152
// exit ;
134150: GO 138811
// base := list [ 1 ] ;
134152: LD_ADDR_VAR 0 3
134156: PUSH
134157: LD_VAR 0 1
134161: PUSH
134162: LD_INT 1
134164: ARRAY
134165: ST_TO_ADDR
// group := list [ 2 ] ;
134166: LD_ADDR_VAR 0 4
134170: PUSH
134171: LD_VAR 0 1
134175: PUSH
134176: LD_INT 2
134178: ARRAY
134179: ST_TO_ADDR
// path := list [ 3 ] ;
134180: LD_ADDR_VAR 0 5
134184: PUSH
134185: LD_VAR 0 1
134189: PUSH
134190: LD_INT 3
134192: ARRAY
134193: ST_TO_ADDR
// flags := list [ 4 ] ;
134194: LD_ADDR_VAR 0 6
134198: PUSH
134199: LD_VAR 0 1
134203: PUSH
134204: LD_INT 4
134206: ARRAY
134207: ST_TO_ADDR
// mined := [ ] ;
134208: LD_ADDR_VAR 0 27
134212: PUSH
134213: EMPTY
134214: ST_TO_ADDR
// bombed := [ ] ;
134215: LD_ADDR_VAR 0 28
134219: PUSH
134220: EMPTY
134221: ST_TO_ADDR
// healers := [ ] ;
134222: LD_ADDR_VAR 0 31
134226: PUSH
134227: EMPTY
134228: ST_TO_ADDR
// to_heal := [ ] ;
134229: LD_ADDR_VAR 0 30
134233: PUSH
134234: EMPTY
134235: ST_TO_ADDR
// repairs := [ ] ;
134236: LD_ADDR_VAR 0 33
134240: PUSH
134241: EMPTY
134242: ST_TO_ADDR
// to_repair := [ ] ;
134243: LD_ADDR_VAR 0 32
134247: PUSH
134248: EMPTY
134249: ST_TO_ADDR
// if not group or not path then
134250: LD_VAR 0 4
134254: NOT
134255: PUSH
134256: LD_VAR 0 5
134260: NOT
134261: OR
134262: IFFALSE 134266
// exit ;
134264: GO 138811
// side := GetSide ( group [ 1 ] ) ;
134266: LD_ADDR_VAR 0 35
134270: PUSH
134271: LD_VAR 0 4
134275: PUSH
134276: LD_INT 1
134278: ARRAY
134279: PPUSH
134280: CALL_OW 255
134284: ST_TO_ADDR
// if flags then
134285: LD_VAR 0 6
134289: IFFALSE 134433
// begin f_ignore_area := flags [ 1 ] ;
134291: LD_ADDR_VAR 0 17
134295: PUSH
134296: LD_VAR 0 6
134300: PUSH
134301: LD_INT 1
134303: ARRAY
134304: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
134305: LD_ADDR_VAR 0 18
134309: PUSH
134310: LD_VAR 0 6
134314: PUSH
134315: LD_INT 2
134317: ARRAY
134318: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
134319: LD_ADDR_VAR 0 19
134323: PUSH
134324: LD_VAR 0 6
134328: PUSH
134329: LD_INT 3
134331: ARRAY
134332: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
134333: LD_ADDR_VAR 0 20
134337: PUSH
134338: LD_VAR 0 6
134342: PUSH
134343: LD_INT 4
134345: ARRAY
134346: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
134347: LD_ADDR_VAR 0 21
134351: PUSH
134352: LD_VAR 0 6
134356: PUSH
134357: LD_INT 5
134359: ARRAY
134360: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
134361: LD_ADDR_VAR 0 22
134365: PUSH
134366: LD_VAR 0 6
134370: PUSH
134371: LD_INT 6
134373: ARRAY
134374: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
134375: LD_ADDR_VAR 0 23
134379: PUSH
134380: LD_VAR 0 6
134384: PUSH
134385: LD_INT 7
134387: ARRAY
134388: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
134389: LD_ADDR_VAR 0 24
134393: PUSH
134394: LD_VAR 0 6
134398: PUSH
134399: LD_INT 8
134401: ARRAY
134402: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
134403: LD_ADDR_VAR 0 25
134407: PUSH
134408: LD_VAR 0 6
134412: PUSH
134413: LD_INT 9
134415: ARRAY
134416: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
134417: LD_ADDR_VAR 0 26
134421: PUSH
134422: LD_VAR 0 6
134426: PUSH
134427: LD_INT 10
134429: ARRAY
134430: ST_TO_ADDR
// end else
134431: GO 134513
// begin f_ignore_area := false ;
134433: LD_ADDR_VAR 0 17
134437: PUSH
134438: LD_INT 0
134440: ST_TO_ADDR
// f_capture := false ;
134441: LD_ADDR_VAR 0 18
134445: PUSH
134446: LD_INT 0
134448: ST_TO_ADDR
// f_ignore_civ := false ;
134449: LD_ADDR_VAR 0 19
134453: PUSH
134454: LD_INT 0
134456: ST_TO_ADDR
// f_murder := false ;
134457: LD_ADDR_VAR 0 20
134461: PUSH
134462: LD_INT 0
134464: ST_TO_ADDR
// f_mines := false ;
134465: LD_ADDR_VAR 0 21
134469: PUSH
134470: LD_INT 0
134472: ST_TO_ADDR
// f_repair := false ;
134473: LD_ADDR_VAR 0 22
134477: PUSH
134478: LD_INT 0
134480: ST_TO_ADDR
// f_heal := false ;
134481: LD_ADDR_VAR 0 23
134485: PUSH
134486: LD_INT 0
134488: ST_TO_ADDR
// f_spacetime := false ;
134489: LD_ADDR_VAR 0 24
134493: PUSH
134494: LD_INT 0
134496: ST_TO_ADDR
// f_attack_depot := false ;
134497: LD_ADDR_VAR 0 25
134501: PUSH
134502: LD_INT 0
134504: ST_TO_ADDR
// f_crawl := false ;
134505: LD_ADDR_VAR 0 26
134509: PUSH
134510: LD_INT 0
134512: ST_TO_ADDR
// end ; if f_heal then
134513: LD_VAR 0 23
134517: IFFALSE 134544
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
134519: LD_ADDR_VAR 0 31
134523: PUSH
134524: LD_VAR 0 4
134528: PPUSH
134529: LD_INT 25
134531: PUSH
134532: LD_INT 4
134534: PUSH
134535: EMPTY
134536: LIST
134537: LIST
134538: PPUSH
134539: CALL_OW 72
134543: ST_TO_ADDR
// if f_repair then
134544: LD_VAR 0 22
134548: IFFALSE 134575
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
134550: LD_ADDR_VAR 0 33
134554: PUSH
134555: LD_VAR 0 4
134559: PPUSH
134560: LD_INT 25
134562: PUSH
134563: LD_INT 3
134565: PUSH
134566: EMPTY
134567: LIST
134568: LIST
134569: PPUSH
134570: CALL_OW 72
134574: ST_TO_ADDR
// units_path := [ ] ;
134575: LD_ADDR_VAR 0 16
134579: PUSH
134580: EMPTY
134581: ST_TO_ADDR
// for i = 1 to group do
134582: LD_ADDR_VAR 0 7
134586: PUSH
134587: DOUBLE
134588: LD_INT 1
134590: DEC
134591: ST_TO_ADDR
134592: LD_VAR 0 4
134596: PUSH
134597: FOR_TO
134598: IFFALSE 134627
// units_path := Replace ( units_path , i , path ) ;
134600: LD_ADDR_VAR 0 16
134604: PUSH
134605: LD_VAR 0 16
134609: PPUSH
134610: LD_VAR 0 7
134614: PPUSH
134615: LD_VAR 0 5
134619: PPUSH
134620: CALL_OW 1
134624: ST_TO_ADDR
134625: GO 134597
134627: POP
134628: POP
// repeat for i = group downto 1 do
134629: LD_ADDR_VAR 0 7
134633: PUSH
134634: DOUBLE
134635: LD_VAR 0 4
134639: INC
134640: ST_TO_ADDR
134641: LD_INT 1
134643: PUSH
134644: FOR_DOWNTO
134645: IFFALSE 138767
// begin wait ( 5 ) ;
134647: LD_INT 5
134649: PPUSH
134650: CALL_OW 67
// tmp := [ ] ;
134654: LD_ADDR_VAR 0 14
134658: PUSH
134659: EMPTY
134660: ST_TO_ADDR
// attacking := false ;
134661: LD_ADDR_VAR 0 29
134665: PUSH
134666: LD_INT 0
134668: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
134669: LD_VAR 0 4
134673: PUSH
134674: LD_VAR 0 7
134678: ARRAY
134679: PPUSH
134680: CALL_OW 301
134684: PUSH
134685: LD_VAR 0 4
134689: PUSH
134690: LD_VAR 0 7
134694: ARRAY
134695: NOT
134696: OR
134697: IFFALSE 134806
// begin if GetType ( group [ i ] ) = unit_human then
134699: LD_VAR 0 4
134703: PUSH
134704: LD_VAR 0 7
134708: ARRAY
134709: PPUSH
134710: CALL_OW 247
134714: PUSH
134715: LD_INT 1
134717: EQUAL
134718: IFFALSE 134764
// begin to_heal := to_heal diff group [ i ] ;
134720: LD_ADDR_VAR 0 30
134724: PUSH
134725: LD_VAR 0 30
134729: PUSH
134730: LD_VAR 0 4
134734: PUSH
134735: LD_VAR 0 7
134739: ARRAY
134740: DIFF
134741: ST_TO_ADDR
// healers := healers diff group [ i ] ;
134742: LD_ADDR_VAR 0 31
134746: PUSH
134747: LD_VAR 0 31
134751: PUSH
134752: LD_VAR 0 4
134756: PUSH
134757: LD_VAR 0 7
134761: ARRAY
134762: DIFF
134763: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
134764: LD_ADDR_VAR 0 4
134768: PUSH
134769: LD_VAR 0 4
134773: PPUSH
134774: LD_VAR 0 7
134778: PPUSH
134779: CALL_OW 3
134783: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
134784: LD_ADDR_VAR 0 16
134788: PUSH
134789: LD_VAR 0 16
134793: PPUSH
134794: LD_VAR 0 7
134798: PPUSH
134799: CALL_OW 3
134803: ST_TO_ADDR
// continue ;
134804: GO 134644
// end ; if f_repair then
134806: LD_VAR 0 22
134810: IFFALSE 135299
// begin if GetType ( group [ i ] ) = unit_vehicle then
134812: LD_VAR 0 4
134816: PUSH
134817: LD_VAR 0 7
134821: ARRAY
134822: PPUSH
134823: CALL_OW 247
134827: PUSH
134828: LD_INT 2
134830: EQUAL
134831: IFFALSE 135021
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
134833: LD_VAR 0 4
134837: PUSH
134838: LD_VAR 0 7
134842: ARRAY
134843: PPUSH
134844: CALL_OW 256
134848: PUSH
134849: LD_INT 700
134851: LESS
134852: PUSH
134853: LD_VAR 0 4
134857: PUSH
134858: LD_VAR 0 7
134862: ARRAY
134863: PUSH
134864: LD_VAR 0 32
134868: IN
134869: NOT
134870: AND
134871: IFFALSE 134895
// to_repair := to_repair union group [ i ] ;
134873: LD_ADDR_VAR 0 32
134877: PUSH
134878: LD_VAR 0 32
134882: PUSH
134883: LD_VAR 0 4
134887: PUSH
134888: LD_VAR 0 7
134892: ARRAY
134893: UNION
134894: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
134895: LD_VAR 0 4
134899: PUSH
134900: LD_VAR 0 7
134904: ARRAY
134905: PPUSH
134906: CALL_OW 256
134910: PUSH
134911: LD_INT 1000
134913: EQUAL
134914: PUSH
134915: LD_VAR 0 4
134919: PUSH
134920: LD_VAR 0 7
134924: ARRAY
134925: PUSH
134926: LD_VAR 0 32
134930: IN
134931: AND
134932: IFFALSE 134956
// to_repair := to_repair diff group [ i ] ;
134934: LD_ADDR_VAR 0 32
134938: PUSH
134939: LD_VAR 0 32
134943: PUSH
134944: LD_VAR 0 4
134948: PUSH
134949: LD_VAR 0 7
134953: ARRAY
134954: DIFF
134955: ST_TO_ADDR
// if group [ i ] in to_repair then
134956: LD_VAR 0 4
134960: PUSH
134961: LD_VAR 0 7
134965: ARRAY
134966: PUSH
134967: LD_VAR 0 32
134971: IN
134972: IFFALSE 135019
// begin if not IsInArea ( group [ i ] , f_repair ) then
134974: LD_VAR 0 4
134978: PUSH
134979: LD_VAR 0 7
134983: ARRAY
134984: PPUSH
134985: LD_VAR 0 22
134989: PPUSH
134990: CALL_OW 308
134994: NOT
134995: IFFALSE 135017
// ComMoveToArea ( group [ i ] , f_repair ) ;
134997: LD_VAR 0 4
135001: PUSH
135002: LD_VAR 0 7
135006: ARRAY
135007: PPUSH
135008: LD_VAR 0 22
135012: PPUSH
135013: CALL_OW 113
// continue ;
135017: GO 134644
// end ; end else
135019: GO 135299
// if group [ i ] in repairs then
135021: LD_VAR 0 4
135025: PUSH
135026: LD_VAR 0 7
135030: ARRAY
135031: PUSH
135032: LD_VAR 0 33
135036: IN
135037: IFFALSE 135299
// begin if IsInUnit ( group [ i ] ) then
135039: LD_VAR 0 4
135043: PUSH
135044: LD_VAR 0 7
135048: ARRAY
135049: PPUSH
135050: CALL_OW 310
135054: IFFALSE 135122
// begin z := IsInUnit ( group [ i ] ) ;
135056: LD_ADDR_VAR 0 13
135060: PUSH
135061: LD_VAR 0 4
135065: PUSH
135066: LD_VAR 0 7
135070: ARRAY
135071: PPUSH
135072: CALL_OW 310
135076: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
135077: LD_VAR 0 13
135081: PUSH
135082: LD_VAR 0 32
135086: IN
135087: PUSH
135088: LD_VAR 0 13
135092: PPUSH
135093: LD_VAR 0 22
135097: PPUSH
135098: CALL_OW 308
135102: AND
135103: IFFALSE 135120
// ComExitVehicle ( group [ i ] ) ;
135105: LD_VAR 0 4
135109: PUSH
135110: LD_VAR 0 7
135114: ARRAY
135115: PPUSH
135116: CALL_OW 121
// end else
135120: GO 135299
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
135122: LD_ADDR_VAR 0 13
135126: PUSH
135127: LD_VAR 0 4
135131: PPUSH
135132: LD_INT 95
135134: PUSH
135135: LD_VAR 0 22
135139: PUSH
135140: EMPTY
135141: LIST
135142: LIST
135143: PUSH
135144: LD_INT 58
135146: PUSH
135147: EMPTY
135148: LIST
135149: PUSH
135150: EMPTY
135151: LIST
135152: LIST
135153: PPUSH
135154: CALL_OW 72
135158: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
135159: LD_VAR 0 4
135163: PUSH
135164: LD_VAR 0 7
135168: ARRAY
135169: PPUSH
135170: CALL_OW 314
135174: NOT
135175: IFFALSE 135297
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
135177: LD_ADDR_VAR 0 10
135181: PUSH
135182: LD_VAR 0 13
135186: PPUSH
135187: LD_VAR 0 4
135191: PUSH
135192: LD_VAR 0 7
135196: ARRAY
135197: PPUSH
135198: CALL_OW 74
135202: ST_TO_ADDR
// if not x then
135203: LD_VAR 0 10
135207: NOT
135208: IFFALSE 135212
// continue ;
135210: GO 134644
// if GetLives ( x ) < 1000 then
135212: LD_VAR 0 10
135216: PPUSH
135217: CALL_OW 256
135221: PUSH
135222: LD_INT 1000
135224: LESS
135225: IFFALSE 135249
// ComRepairVehicle ( group [ i ] , x ) else
135227: LD_VAR 0 4
135231: PUSH
135232: LD_VAR 0 7
135236: ARRAY
135237: PPUSH
135238: LD_VAR 0 10
135242: PPUSH
135243: CALL_OW 129
135247: GO 135297
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
135249: LD_VAR 0 23
135253: PUSH
135254: LD_VAR 0 4
135258: PUSH
135259: LD_VAR 0 7
135263: ARRAY
135264: PPUSH
135265: CALL_OW 256
135269: PUSH
135270: LD_INT 1000
135272: LESS
135273: AND
135274: NOT
135275: IFFALSE 135297
// ComEnterUnit ( group [ i ] , x ) ;
135277: LD_VAR 0 4
135281: PUSH
135282: LD_VAR 0 7
135286: ARRAY
135287: PPUSH
135288: LD_VAR 0 10
135292: PPUSH
135293: CALL_OW 120
// end ; continue ;
135297: GO 134644
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
135299: LD_VAR 0 23
135303: PUSH
135304: LD_VAR 0 4
135308: PUSH
135309: LD_VAR 0 7
135313: ARRAY
135314: PPUSH
135315: CALL_OW 247
135319: PUSH
135320: LD_INT 1
135322: EQUAL
135323: AND
135324: IFFALSE 135802
// begin if group [ i ] in healers then
135326: LD_VAR 0 4
135330: PUSH
135331: LD_VAR 0 7
135335: ARRAY
135336: PUSH
135337: LD_VAR 0 31
135341: IN
135342: IFFALSE 135615
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
135344: LD_VAR 0 4
135348: PUSH
135349: LD_VAR 0 7
135353: ARRAY
135354: PPUSH
135355: LD_VAR 0 23
135359: PPUSH
135360: CALL_OW 308
135364: NOT
135365: PUSH
135366: LD_VAR 0 4
135370: PUSH
135371: LD_VAR 0 7
135375: ARRAY
135376: PPUSH
135377: CALL_OW 314
135381: NOT
135382: AND
135383: IFFALSE 135407
// ComMoveToArea ( group [ i ] , f_heal ) else
135385: LD_VAR 0 4
135389: PUSH
135390: LD_VAR 0 7
135394: ARRAY
135395: PPUSH
135396: LD_VAR 0 23
135400: PPUSH
135401: CALL_OW 113
135405: GO 135613
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
135407: LD_VAR 0 4
135411: PUSH
135412: LD_VAR 0 7
135416: ARRAY
135417: PPUSH
135418: CALL 105343 0 1
135422: PPUSH
135423: CALL_OW 256
135427: PUSH
135428: LD_INT 1000
135430: EQUAL
135431: IFFALSE 135450
// ComStop ( group [ i ] ) else
135433: LD_VAR 0 4
135437: PUSH
135438: LD_VAR 0 7
135442: ARRAY
135443: PPUSH
135444: CALL_OW 141
135448: GO 135613
// if not HasTask ( group [ i ] ) and to_heal then
135450: LD_VAR 0 4
135454: PUSH
135455: LD_VAR 0 7
135459: ARRAY
135460: PPUSH
135461: CALL_OW 314
135465: NOT
135466: PUSH
135467: LD_VAR 0 30
135471: AND
135472: IFFALSE 135613
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
135474: LD_ADDR_VAR 0 13
135478: PUSH
135479: LD_VAR 0 30
135483: PPUSH
135484: LD_INT 3
135486: PUSH
135487: LD_INT 54
135489: PUSH
135490: EMPTY
135491: LIST
135492: PUSH
135493: EMPTY
135494: LIST
135495: LIST
135496: PPUSH
135497: CALL_OW 72
135501: PPUSH
135502: LD_VAR 0 4
135506: PUSH
135507: LD_VAR 0 7
135511: ARRAY
135512: PPUSH
135513: CALL_OW 74
135517: ST_TO_ADDR
// if z then
135518: LD_VAR 0 13
135522: IFFALSE 135613
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
135524: LD_INT 91
135526: PUSH
135527: LD_VAR 0 13
135531: PUSH
135532: LD_INT 10
135534: PUSH
135535: EMPTY
135536: LIST
135537: LIST
135538: LIST
135539: PUSH
135540: LD_INT 81
135542: PUSH
135543: LD_VAR 0 13
135547: PPUSH
135548: CALL_OW 255
135552: PUSH
135553: EMPTY
135554: LIST
135555: LIST
135556: PUSH
135557: EMPTY
135558: LIST
135559: LIST
135560: PPUSH
135561: CALL_OW 69
135565: PUSH
135566: LD_INT 0
135568: EQUAL
135569: IFFALSE 135593
// ComHeal ( group [ i ] , z ) else
135571: LD_VAR 0 4
135575: PUSH
135576: LD_VAR 0 7
135580: ARRAY
135581: PPUSH
135582: LD_VAR 0 13
135586: PPUSH
135587: CALL_OW 128
135591: GO 135613
// ComMoveToArea ( group [ i ] , f_heal ) ;
135593: LD_VAR 0 4
135597: PUSH
135598: LD_VAR 0 7
135602: ARRAY
135603: PPUSH
135604: LD_VAR 0 23
135608: PPUSH
135609: CALL_OW 113
// end ; continue ;
135613: GO 134644
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
135615: LD_VAR 0 4
135619: PUSH
135620: LD_VAR 0 7
135624: ARRAY
135625: PPUSH
135626: CALL_OW 256
135630: PUSH
135631: LD_INT 700
135633: LESS
135634: PUSH
135635: LD_VAR 0 4
135639: PUSH
135640: LD_VAR 0 7
135644: ARRAY
135645: PUSH
135646: LD_VAR 0 30
135650: IN
135651: NOT
135652: AND
135653: IFFALSE 135677
// to_heal := to_heal union group [ i ] ;
135655: LD_ADDR_VAR 0 30
135659: PUSH
135660: LD_VAR 0 30
135664: PUSH
135665: LD_VAR 0 4
135669: PUSH
135670: LD_VAR 0 7
135674: ARRAY
135675: UNION
135676: ST_TO_ADDR
// if group [ i ] in to_heal then
135677: LD_VAR 0 4
135681: PUSH
135682: LD_VAR 0 7
135686: ARRAY
135687: PUSH
135688: LD_VAR 0 30
135692: IN
135693: IFFALSE 135802
// begin if GetLives ( group [ i ] ) = 1000 then
135695: LD_VAR 0 4
135699: PUSH
135700: LD_VAR 0 7
135704: ARRAY
135705: PPUSH
135706: CALL_OW 256
135710: PUSH
135711: LD_INT 1000
135713: EQUAL
135714: IFFALSE 135740
// to_heal := to_heal diff group [ i ] else
135716: LD_ADDR_VAR 0 30
135720: PUSH
135721: LD_VAR 0 30
135725: PUSH
135726: LD_VAR 0 4
135730: PUSH
135731: LD_VAR 0 7
135735: ARRAY
135736: DIFF
135737: ST_TO_ADDR
135738: GO 135802
// begin if not IsInArea ( group [ i ] , to_heal ) then
135740: LD_VAR 0 4
135744: PUSH
135745: LD_VAR 0 7
135749: ARRAY
135750: PPUSH
135751: LD_VAR 0 30
135755: PPUSH
135756: CALL_OW 308
135760: NOT
135761: IFFALSE 135785
// ComMoveToArea ( group [ i ] , f_heal ) else
135763: LD_VAR 0 4
135767: PUSH
135768: LD_VAR 0 7
135772: ARRAY
135773: PPUSH
135774: LD_VAR 0 23
135778: PPUSH
135779: CALL_OW 113
135783: GO 135800
// ComHold ( group [ i ] ) ;
135785: LD_VAR 0 4
135789: PUSH
135790: LD_VAR 0 7
135794: ARRAY
135795: PPUSH
135796: CALL_OW 140
// continue ;
135800: GO 134644
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
135802: LD_VAR 0 4
135806: PUSH
135807: LD_VAR 0 7
135811: ARRAY
135812: PPUSH
135813: LD_INT 10
135815: PPUSH
135816: CALL 103125 0 2
135820: NOT
135821: PUSH
135822: LD_VAR 0 16
135826: PUSH
135827: LD_VAR 0 7
135831: ARRAY
135832: PUSH
135833: EMPTY
135834: EQUAL
135835: NOT
135836: AND
135837: IFFALSE 136103
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
135839: LD_VAR 0 4
135843: PUSH
135844: LD_VAR 0 7
135848: ARRAY
135849: PPUSH
135850: CALL_OW 262
135854: PUSH
135855: LD_INT 1
135857: PUSH
135858: LD_INT 2
135860: PUSH
135861: EMPTY
135862: LIST
135863: LIST
135864: IN
135865: IFFALSE 135906
// if GetFuel ( group [ i ] ) < 10 then
135867: LD_VAR 0 4
135871: PUSH
135872: LD_VAR 0 7
135876: ARRAY
135877: PPUSH
135878: CALL_OW 261
135882: PUSH
135883: LD_INT 10
135885: LESS
135886: IFFALSE 135906
// SetFuel ( group [ i ] , 12 ) ;
135888: LD_VAR 0 4
135892: PUSH
135893: LD_VAR 0 7
135897: ARRAY
135898: PPUSH
135899: LD_INT 12
135901: PPUSH
135902: CALL_OW 240
// if units_path [ i ] then
135906: LD_VAR 0 16
135910: PUSH
135911: LD_VAR 0 7
135915: ARRAY
135916: IFFALSE 136101
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
135918: LD_VAR 0 4
135922: PUSH
135923: LD_VAR 0 7
135927: ARRAY
135928: PPUSH
135929: LD_VAR 0 16
135933: PUSH
135934: LD_VAR 0 7
135938: ARRAY
135939: PUSH
135940: LD_INT 1
135942: ARRAY
135943: PUSH
135944: LD_INT 1
135946: ARRAY
135947: PPUSH
135948: LD_VAR 0 16
135952: PUSH
135953: LD_VAR 0 7
135957: ARRAY
135958: PUSH
135959: LD_INT 1
135961: ARRAY
135962: PUSH
135963: LD_INT 2
135965: ARRAY
135966: PPUSH
135967: CALL_OW 297
135971: PUSH
135972: LD_INT 6
135974: GREATER
135975: IFFALSE 136050
// begin if not HasTask ( group [ i ] ) then
135977: LD_VAR 0 4
135981: PUSH
135982: LD_VAR 0 7
135986: ARRAY
135987: PPUSH
135988: CALL_OW 314
135992: NOT
135993: IFFALSE 136048
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
135995: LD_VAR 0 4
135999: PUSH
136000: LD_VAR 0 7
136004: ARRAY
136005: PPUSH
136006: LD_VAR 0 16
136010: PUSH
136011: LD_VAR 0 7
136015: ARRAY
136016: PUSH
136017: LD_INT 1
136019: ARRAY
136020: PUSH
136021: LD_INT 1
136023: ARRAY
136024: PPUSH
136025: LD_VAR 0 16
136029: PUSH
136030: LD_VAR 0 7
136034: ARRAY
136035: PUSH
136036: LD_INT 1
136038: ARRAY
136039: PUSH
136040: LD_INT 2
136042: ARRAY
136043: PPUSH
136044: CALL_OW 114
// end else
136048: GO 136101
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
136050: LD_ADDR_VAR 0 15
136054: PUSH
136055: LD_VAR 0 16
136059: PUSH
136060: LD_VAR 0 7
136064: ARRAY
136065: PPUSH
136066: LD_INT 1
136068: PPUSH
136069: CALL_OW 3
136073: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
136074: LD_ADDR_VAR 0 16
136078: PUSH
136079: LD_VAR 0 16
136083: PPUSH
136084: LD_VAR 0 7
136088: PPUSH
136089: LD_VAR 0 15
136093: PPUSH
136094: CALL_OW 1
136098: ST_TO_ADDR
// continue ;
136099: GO 134644
// end ; end ; end else
136101: GO 138765
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
136103: LD_ADDR_VAR 0 14
136107: PUSH
136108: LD_INT 81
136110: PUSH
136111: LD_VAR 0 4
136115: PUSH
136116: LD_VAR 0 7
136120: ARRAY
136121: PPUSH
136122: CALL_OW 255
136126: PUSH
136127: EMPTY
136128: LIST
136129: LIST
136130: PPUSH
136131: CALL_OW 69
136135: ST_TO_ADDR
// if not tmp then
136136: LD_VAR 0 14
136140: NOT
136141: IFFALSE 136145
// continue ;
136143: GO 134644
// if f_ignore_area then
136145: LD_VAR 0 17
136149: IFFALSE 136237
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
136151: LD_ADDR_VAR 0 15
136155: PUSH
136156: LD_VAR 0 14
136160: PPUSH
136161: LD_INT 3
136163: PUSH
136164: LD_INT 92
136166: PUSH
136167: LD_VAR 0 17
136171: PUSH
136172: LD_INT 1
136174: ARRAY
136175: PUSH
136176: LD_VAR 0 17
136180: PUSH
136181: LD_INT 2
136183: ARRAY
136184: PUSH
136185: LD_VAR 0 17
136189: PUSH
136190: LD_INT 3
136192: ARRAY
136193: PUSH
136194: EMPTY
136195: LIST
136196: LIST
136197: LIST
136198: LIST
136199: PUSH
136200: EMPTY
136201: LIST
136202: LIST
136203: PPUSH
136204: CALL_OW 72
136208: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
136209: LD_VAR 0 14
136213: PUSH
136214: LD_VAR 0 15
136218: DIFF
136219: IFFALSE 136237
// tmp := tmp diff tmp2 ;
136221: LD_ADDR_VAR 0 14
136225: PUSH
136226: LD_VAR 0 14
136230: PUSH
136231: LD_VAR 0 15
136235: DIFF
136236: ST_TO_ADDR
// end ; if not f_murder then
136237: LD_VAR 0 20
136241: NOT
136242: IFFALSE 136300
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
136244: LD_ADDR_VAR 0 15
136248: PUSH
136249: LD_VAR 0 14
136253: PPUSH
136254: LD_INT 3
136256: PUSH
136257: LD_INT 50
136259: PUSH
136260: EMPTY
136261: LIST
136262: PUSH
136263: EMPTY
136264: LIST
136265: LIST
136266: PPUSH
136267: CALL_OW 72
136271: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
136272: LD_VAR 0 14
136276: PUSH
136277: LD_VAR 0 15
136281: DIFF
136282: IFFALSE 136300
// tmp := tmp diff tmp2 ;
136284: LD_ADDR_VAR 0 14
136288: PUSH
136289: LD_VAR 0 14
136293: PUSH
136294: LD_VAR 0 15
136298: DIFF
136299: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
136300: LD_ADDR_VAR 0 14
136304: PUSH
136305: LD_VAR 0 4
136309: PUSH
136310: LD_VAR 0 7
136314: ARRAY
136315: PPUSH
136316: LD_VAR 0 14
136320: PPUSH
136321: LD_INT 1
136323: PPUSH
136324: LD_INT 1
136326: PPUSH
136327: CALL 75669 0 4
136331: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
136332: LD_VAR 0 4
136336: PUSH
136337: LD_VAR 0 7
136341: ARRAY
136342: PPUSH
136343: CALL_OW 257
136347: PUSH
136348: LD_INT 1
136350: EQUAL
136351: IFFALSE 136799
// begin if WantPlant ( group [ i ] ) then
136353: LD_VAR 0 4
136357: PUSH
136358: LD_VAR 0 7
136362: ARRAY
136363: PPUSH
136364: CALL 75170 0 1
136368: IFFALSE 136372
// continue ;
136370: GO 134644
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
136372: LD_VAR 0 18
136376: PUSH
136377: LD_VAR 0 4
136381: PUSH
136382: LD_VAR 0 7
136386: ARRAY
136387: PPUSH
136388: CALL_OW 310
136392: NOT
136393: AND
136394: PUSH
136395: LD_VAR 0 14
136399: PUSH
136400: LD_INT 1
136402: ARRAY
136403: PUSH
136404: LD_VAR 0 14
136408: PPUSH
136409: LD_INT 21
136411: PUSH
136412: LD_INT 2
136414: PUSH
136415: EMPTY
136416: LIST
136417: LIST
136418: PUSH
136419: LD_INT 58
136421: PUSH
136422: EMPTY
136423: LIST
136424: PUSH
136425: EMPTY
136426: LIST
136427: LIST
136428: PPUSH
136429: CALL_OW 72
136433: IN
136434: AND
136435: IFFALSE 136471
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
136437: LD_VAR 0 4
136441: PUSH
136442: LD_VAR 0 7
136446: ARRAY
136447: PPUSH
136448: LD_VAR 0 14
136452: PUSH
136453: LD_INT 1
136455: ARRAY
136456: PPUSH
136457: CALL_OW 120
// attacking := true ;
136461: LD_ADDR_VAR 0 29
136465: PUSH
136466: LD_INT 1
136468: ST_TO_ADDR
// continue ;
136469: GO 134644
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
136471: LD_VAR 0 26
136475: PUSH
136476: LD_VAR 0 4
136480: PUSH
136481: LD_VAR 0 7
136485: ARRAY
136486: PPUSH
136487: CALL_OW 257
136491: PUSH
136492: LD_INT 1
136494: EQUAL
136495: AND
136496: PUSH
136497: LD_VAR 0 4
136501: PUSH
136502: LD_VAR 0 7
136506: ARRAY
136507: PPUSH
136508: CALL_OW 256
136512: PUSH
136513: LD_INT 800
136515: LESS
136516: AND
136517: PUSH
136518: LD_VAR 0 4
136522: PUSH
136523: LD_VAR 0 7
136527: ARRAY
136528: PPUSH
136529: CALL_OW 318
136533: NOT
136534: AND
136535: IFFALSE 136552
// ComCrawl ( group [ i ] ) ;
136537: LD_VAR 0 4
136541: PUSH
136542: LD_VAR 0 7
136546: ARRAY
136547: PPUSH
136548: CALL_OW 137
// if f_mines then
136552: LD_VAR 0 21
136556: IFFALSE 136799
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
136558: LD_VAR 0 14
136562: PUSH
136563: LD_INT 1
136565: ARRAY
136566: PPUSH
136567: CALL_OW 247
136571: PUSH
136572: LD_INT 3
136574: EQUAL
136575: PUSH
136576: LD_VAR 0 14
136580: PUSH
136581: LD_INT 1
136583: ARRAY
136584: PUSH
136585: LD_VAR 0 27
136589: IN
136590: NOT
136591: AND
136592: IFFALSE 136799
// begin x := GetX ( tmp [ 1 ] ) ;
136594: LD_ADDR_VAR 0 10
136598: PUSH
136599: LD_VAR 0 14
136603: PUSH
136604: LD_INT 1
136606: ARRAY
136607: PPUSH
136608: CALL_OW 250
136612: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
136613: LD_ADDR_VAR 0 11
136617: PUSH
136618: LD_VAR 0 14
136622: PUSH
136623: LD_INT 1
136625: ARRAY
136626: PPUSH
136627: CALL_OW 251
136631: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
136632: LD_ADDR_VAR 0 12
136636: PUSH
136637: LD_VAR 0 4
136641: PUSH
136642: LD_VAR 0 7
136646: ARRAY
136647: PPUSH
136648: CALL 103210 0 1
136652: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
136653: LD_VAR 0 4
136657: PUSH
136658: LD_VAR 0 7
136662: ARRAY
136663: PPUSH
136664: LD_VAR 0 10
136668: PPUSH
136669: LD_VAR 0 11
136673: PPUSH
136674: LD_VAR 0 14
136678: PUSH
136679: LD_INT 1
136681: ARRAY
136682: PPUSH
136683: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
136687: LD_VAR 0 4
136691: PUSH
136692: LD_VAR 0 7
136696: ARRAY
136697: PPUSH
136698: LD_VAR 0 10
136702: PPUSH
136703: LD_VAR 0 12
136707: PPUSH
136708: LD_INT 7
136710: PPUSH
136711: CALL_OW 272
136715: PPUSH
136716: LD_VAR 0 11
136720: PPUSH
136721: LD_VAR 0 12
136725: PPUSH
136726: LD_INT 7
136728: PPUSH
136729: CALL_OW 273
136733: PPUSH
136734: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
136738: LD_VAR 0 4
136742: PUSH
136743: LD_VAR 0 7
136747: ARRAY
136748: PPUSH
136749: LD_INT 71
136751: PPUSH
136752: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
136756: LD_ADDR_VAR 0 27
136760: PUSH
136761: LD_VAR 0 27
136765: PPUSH
136766: LD_VAR 0 27
136770: PUSH
136771: LD_INT 1
136773: PLUS
136774: PPUSH
136775: LD_VAR 0 14
136779: PUSH
136780: LD_INT 1
136782: ARRAY
136783: PPUSH
136784: CALL_OW 1
136788: ST_TO_ADDR
// attacking := true ;
136789: LD_ADDR_VAR 0 29
136793: PUSH
136794: LD_INT 1
136796: ST_TO_ADDR
// continue ;
136797: GO 134644
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
136799: LD_VAR 0 4
136803: PUSH
136804: LD_VAR 0 7
136808: ARRAY
136809: PPUSH
136810: CALL_OW 257
136814: PUSH
136815: LD_INT 17
136817: EQUAL
136818: PUSH
136819: LD_VAR 0 4
136823: PUSH
136824: LD_VAR 0 7
136828: ARRAY
136829: PPUSH
136830: CALL_OW 110
136834: PUSH
136835: LD_INT 71
136837: EQUAL
136838: NOT
136839: AND
136840: IFFALSE 136986
// begin attacking := false ;
136842: LD_ADDR_VAR 0 29
136846: PUSH
136847: LD_INT 0
136849: ST_TO_ADDR
// k := 5 ;
136850: LD_ADDR_VAR 0 9
136854: PUSH
136855: LD_INT 5
136857: ST_TO_ADDR
// if tmp < k then
136858: LD_VAR 0 14
136862: PUSH
136863: LD_VAR 0 9
136867: LESS
136868: IFFALSE 136880
// k := tmp ;
136870: LD_ADDR_VAR 0 9
136874: PUSH
136875: LD_VAR 0 14
136879: ST_TO_ADDR
// for j = 1 to k do
136880: LD_ADDR_VAR 0 8
136884: PUSH
136885: DOUBLE
136886: LD_INT 1
136888: DEC
136889: ST_TO_ADDR
136890: LD_VAR 0 9
136894: PUSH
136895: FOR_TO
136896: IFFALSE 136984
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
136898: LD_VAR 0 14
136902: PUSH
136903: LD_VAR 0 8
136907: ARRAY
136908: PUSH
136909: LD_VAR 0 14
136913: PPUSH
136914: LD_INT 58
136916: PUSH
136917: EMPTY
136918: LIST
136919: PPUSH
136920: CALL_OW 72
136924: IN
136925: NOT
136926: IFFALSE 136982
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
136928: LD_VAR 0 4
136932: PUSH
136933: LD_VAR 0 7
136937: ARRAY
136938: PPUSH
136939: LD_VAR 0 14
136943: PUSH
136944: LD_VAR 0 8
136948: ARRAY
136949: PPUSH
136950: CALL_OW 115
// attacking := true ;
136954: LD_ADDR_VAR 0 29
136958: PUSH
136959: LD_INT 1
136961: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
136962: LD_VAR 0 4
136966: PUSH
136967: LD_VAR 0 7
136971: ARRAY
136972: PPUSH
136973: LD_INT 71
136975: PPUSH
136976: CALL_OW 109
// continue ;
136980: GO 136895
// end ; end ;
136982: GO 136895
136984: POP
136985: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
136986: LD_VAR 0 4
136990: PUSH
136991: LD_VAR 0 7
136995: ARRAY
136996: PPUSH
136997: CALL_OW 257
137001: PUSH
137002: LD_INT 8
137004: EQUAL
137005: PUSH
137006: LD_VAR 0 4
137010: PUSH
137011: LD_VAR 0 7
137015: ARRAY
137016: PPUSH
137017: CALL_OW 264
137021: PUSH
137022: LD_INT 28
137024: PUSH
137025: LD_INT 45
137027: PUSH
137028: LD_INT 7
137030: PUSH
137031: LD_INT 47
137033: PUSH
137034: EMPTY
137035: LIST
137036: LIST
137037: LIST
137038: LIST
137039: IN
137040: OR
137041: IFFALSE 137297
// begin attacking := false ;
137043: LD_ADDR_VAR 0 29
137047: PUSH
137048: LD_INT 0
137050: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
137051: LD_VAR 0 14
137055: PUSH
137056: LD_INT 1
137058: ARRAY
137059: PPUSH
137060: CALL_OW 266
137064: PUSH
137065: LD_INT 32
137067: PUSH
137068: LD_INT 31
137070: PUSH
137071: LD_INT 33
137073: PUSH
137074: LD_INT 4
137076: PUSH
137077: LD_INT 5
137079: PUSH
137080: EMPTY
137081: LIST
137082: LIST
137083: LIST
137084: LIST
137085: LIST
137086: IN
137087: IFFALSE 137273
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
137089: LD_ADDR_VAR 0 9
137093: PUSH
137094: LD_VAR 0 14
137098: PUSH
137099: LD_INT 1
137101: ARRAY
137102: PPUSH
137103: CALL_OW 266
137107: PPUSH
137108: LD_VAR 0 14
137112: PUSH
137113: LD_INT 1
137115: ARRAY
137116: PPUSH
137117: CALL_OW 250
137121: PPUSH
137122: LD_VAR 0 14
137126: PUSH
137127: LD_INT 1
137129: ARRAY
137130: PPUSH
137131: CALL_OW 251
137135: PPUSH
137136: LD_VAR 0 14
137140: PUSH
137141: LD_INT 1
137143: ARRAY
137144: PPUSH
137145: CALL_OW 254
137149: PPUSH
137150: LD_VAR 0 14
137154: PUSH
137155: LD_INT 1
137157: ARRAY
137158: PPUSH
137159: CALL_OW 248
137163: PPUSH
137164: LD_INT 0
137166: PPUSH
137167: CALL 84580 0 6
137171: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
137172: LD_ADDR_VAR 0 8
137176: PUSH
137177: LD_VAR 0 4
137181: PUSH
137182: LD_VAR 0 7
137186: ARRAY
137187: PPUSH
137188: LD_VAR 0 9
137192: PPUSH
137193: CALL 103323 0 2
137197: ST_TO_ADDR
// if j then
137198: LD_VAR 0 8
137202: IFFALSE 137271
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
137204: LD_VAR 0 8
137208: PUSH
137209: LD_INT 1
137211: ARRAY
137212: PPUSH
137213: LD_VAR 0 8
137217: PUSH
137218: LD_INT 2
137220: ARRAY
137221: PPUSH
137222: CALL_OW 488
137226: IFFALSE 137271
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
137228: LD_VAR 0 4
137232: PUSH
137233: LD_VAR 0 7
137237: ARRAY
137238: PPUSH
137239: LD_VAR 0 8
137243: PUSH
137244: LD_INT 1
137246: ARRAY
137247: PPUSH
137248: LD_VAR 0 8
137252: PUSH
137253: LD_INT 2
137255: ARRAY
137256: PPUSH
137257: CALL_OW 116
// attacking := true ;
137261: LD_ADDR_VAR 0 29
137265: PUSH
137266: LD_INT 1
137268: ST_TO_ADDR
// continue ;
137269: GO 134644
// end ; end else
137271: GO 137297
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
137273: LD_VAR 0 4
137277: PUSH
137278: LD_VAR 0 7
137282: ARRAY
137283: PPUSH
137284: LD_VAR 0 14
137288: PUSH
137289: LD_INT 1
137291: ARRAY
137292: PPUSH
137293: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
137297: LD_VAR 0 4
137301: PUSH
137302: LD_VAR 0 7
137306: ARRAY
137307: PPUSH
137308: CALL_OW 265
137312: PUSH
137313: LD_INT 11
137315: EQUAL
137316: IFFALSE 137594
// begin k := 10 ;
137318: LD_ADDR_VAR 0 9
137322: PUSH
137323: LD_INT 10
137325: ST_TO_ADDR
// x := 0 ;
137326: LD_ADDR_VAR 0 10
137330: PUSH
137331: LD_INT 0
137333: ST_TO_ADDR
// if tmp < k then
137334: LD_VAR 0 14
137338: PUSH
137339: LD_VAR 0 9
137343: LESS
137344: IFFALSE 137356
// k := tmp ;
137346: LD_ADDR_VAR 0 9
137350: PUSH
137351: LD_VAR 0 14
137355: ST_TO_ADDR
// for j = k downto 1 do
137356: LD_ADDR_VAR 0 8
137360: PUSH
137361: DOUBLE
137362: LD_VAR 0 9
137366: INC
137367: ST_TO_ADDR
137368: LD_INT 1
137370: PUSH
137371: FOR_DOWNTO
137372: IFFALSE 137447
// begin if GetType ( tmp [ j ] ) = unit_human then
137374: LD_VAR 0 14
137378: PUSH
137379: LD_VAR 0 8
137383: ARRAY
137384: PPUSH
137385: CALL_OW 247
137389: PUSH
137390: LD_INT 1
137392: EQUAL
137393: IFFALSE 137445
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
137395: LD_VAR 0 4
137399: PUSH
137400: LD_VAR 0 7
137404: ARRAY
137405: PPUSH
137406: LD_VAR 0 14
137410: PUSH
137411: LD_VAR 0 8
137415: ARRAY
137416: PPUSH
137417: CALL 103577 0 2
// x := tmp [ j ] ;
137421: LD_ADDR_VAR 0 10
137425: PUSH
137426: LD_VAR 0 14
137430: PUSH
137431: LD_VAR 0 8
137435: ARRAY
137436: ST_TO_ADDR
// attacking := true ;
137437: LD_ADDR_VAR 0 29
137441: PUSH
137442: LD_INT 1
137444: ST_TO_ADDR
// end ; end ;
137445: GO 137371
137447: POP
137448: POP
// if not x then
137449: LD_VAR 0 10
137453: NOT
137454: IFFALSE 137594
// begin attacking := true ;
137456: LD_ADDR_VAR 0 29
137460: PUSH
137461: LD_INT 1
137463: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
137464: LD_VAR 0 4
137468: PUSH
137469: LD_VAR 0 7
137473: ARRAY
137474: PPUSH
137475: CALL_OW 250
137479: PPUSH
137480: LD_VAR 0 4
137484: PUSH
137485: LD_VAR 0 7
137489: ARRAY
137490: PPUSH
137491: CALL_OW 251
137495: PPUSH
137496: CALL_OW 546
137500: PUSH
137501: LD_INT 2
137503: ARRAY
137504: PUSH
137505: LD_VAR 0 14
137509: PUSH
137510: LD_INT 1
137512: ARRAY
137513: PPUSH
137514: CALL_OW 250
137518: PPUSH
137519: LD_VAR 0 14
137523: PUSH
137524: LD_INT 1
137526: ARRAY
137527: PPUSH
137528: CALL_OW 251
137532: PPUSH
137533: CALL_OW 546
137537: PUSH
137538: LD_INT 2
137540: ARRAY
137541: EQUAL
137542: IFFALSE 137570
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
137544: LD_VAR 0 4
137548: PUSH
137549: LD_VAR 0 7
137553: ARRAY
137554: PPUSH
137555: LD_VAR 0 14
137559: PUSH
137560: LD_INT 1
137562: ARRAY
137563: PPUSH
137564: CALL 103577 0 2
137568: GO 137594
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
137570: LD_VAR 0 4
137574: PUSH
137575: LD_VAR 0 7
137579: ARRAY
137580: PPUSH
137581: LD_VAR 0 14
137585: PUSH
137586: LD_INT 1
137588: ARRAY
137589: PPUSH
137590: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
137594: LD_VAR 0 4
137598: PUSH
137599: LD_VAR 0 7
137603: ARRAY
137604: PPUSH
137605: CALL_OW 264
137609: PUSH
137610: LD_INT 29
137612: EQUAL
137613: IFFALSE 137979
// begin if WantsToAttack ( group [ i ] ) in bombed then
137615: LD_VAR 0 4
137619: PUSH
137620: LD_VAR 0 7
137624: ARRAY
137625: PPUSH
137626: CALL_OW 319
137630: PUSH
137631: LD_VAR 0 28
137635: IN
137636: IFFALSE 137640
// continue ;
137638: GO 134644
// k := 8 ;
137640: LD_ADDR_VAR 0 9
137644: PUSH
137645: LD_INT 8
137647: ST_TO_ADDR
// x := 0 ;
137648: LD_ADDR_VAR 0 10
137652: PUSH
137653: LD_INT 0
137655: ST_TO_ADDR
// if tmp < k then
137656: LD_VAR 0 14
137660: PUSH
137661: LD_VAR 0 9
137665: LESS
137666: IFFALSE 137678
// k := tmp ;
137668: LD_ADDR_VAR 0 9
137672: PUSH
137673: LD_VAR 0 14
137677: ST_TO_ADDR
// for j = 1 to k do
137678: LD_ADDR_VAR 0 8
137682: PUSH
137683: DOUBLE
137684: LD_INT 1
137686: DEC
137687: ST_TO_ADDR
137688: LD_VAR 0 9
137692: PUSH
137693: FOR_TO
137694: IFFALSE 137826
// begin if GetType ( tmp [ j ] ) = unit_building then
137696: LD_VAR 0 14
137700: PUSH
137701: LD_VAR 0 8
137705: ARRAY
137706: PPUSH
137707: CALL_OW 247
137711: PUSH
137712: LD_INT 3
137714: EQUAL
137715: IFFALSE 137824
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
137717: LD_VAR 0 14
137721: PUSH
137722: LD_VAR 0 8
137726: ARRAY
137727: PUSH
137728: LD_VAR 0 28
137732: IN
137733: NOT
137734: PUSH
137735: LD_VAR 0 14
137739: PUSH
137740: LD_VAR 0 8
137744: ARRAY
137745: PPUSH
137746: CALL_OW 313
137750: AND
137751: IFFALSE 137824
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
137753: LD_VAR 0 4
137757: PUSH
137758: LD_VAR 0 7
137762: ARRAY
137763: PPUSH
137764: LD_VAR 0 14
137768: PUSH
137769: LD_VAR 0 8
137773: ARRAY
137774: PPUSH
137775: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
137779: LD_ADDR_VAR 0 28
137783: PUSH
137784: LD_VAR 0 28
137788: PPUSH
137789: LD_VAR 0 28
137793: PUSH
137794: LD_INT 1
137796: PLUS
137797: PPUSH
137798: LD_VAR 0 14
137802: PUSH
137803: LD_VAR 0 8
137807: ARRAY
137808: PPUSH
137809: CALL_OW 1
137813: ST_TO_ADDR
// attacking := true ;
137814: LD_ADDR_VAR 0 29
137818: PUSH
137819: LD_INT 1
137821: ST_TO_ADDR
// break ;
137822: GO 137826
// end ; end ;
137824: GO 137693
137826: POP
137827: POP
// if not attacking and f_attack_depot then
137828: LD_VAR 0 29
137832: NOT
137833: PUSH
137834: LD_VAR 0 25
137838: AND
137839: IFFALSE 137934
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
137841: LD_ADDR_VAR 0 13
137845: PUSH
137846: LD_VAR 0 14
137850: PPUSH
137851: LD_INT 2
137853: PUSH
137854: LD_INT 30
137856: PUSH
137857: LD_INT 0
137859: PUSH
137860: EMPTY
137861: LIST
137862: LIST
137863: PUSH
137864: LD_INT 30
137866: PUSH
137867: LD_INT 1
137869: PUSH
137870: EMPTY
137871: LIST
137872: LIST
137873: PUSH
137874: EMPTY
137875: LIST
137876: LIST
137877: LIST
137878: PPUSH
137879: CALL_OW 72
137883: ST_TO_ADDR
// if z then
137884: LD_VAR 0 13
137888: IFFALSE 137934
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
137890: LD_VAR 0 4
137894: PUSH
137895: LD_VAR 0 7
137899: ARRAY
137900: PPUSH
137901: LD_VAR 0 13
137905: PPUSH
137906: LD_VAR 0 4
137910: PUSH
137911: LD_VAR 0 7
137915: ARRAY
137916: PPUSH
137917: CALL_OW 74
137921: PPUSH
137922: CALL_OW 115
// attacking := true ;
137926: LD_ADDR_VAR 0 29
137930: PUSH
137931: LD_INT 1
137933: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
137934: LD_VAR 0 4
137938: PUSH
137939: LD_VAR 0 7
137943: ARRAY
137944: PPUSH
137945: CALL_OW 256
137949: PUSH
137950: LD_INT 500
137952: LESS
137953: IFFALSE 137979
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
137955: LD_VAR 0 4
137959: PUSH
137960: LD_VAR 0 7
137964: ARRAY
137965: PPUSH
137966: LD_VAR 0 14
137970: PUSH
137971: LD_INT 1
137973: ARRAY
137974: PPUSH
137975: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
137979: LD_VAR 0 4
137983: PUSH
137984: LD_VAR 0 7
137988: ARRAY
137989: PPUSH
137990: CALL_OW 264
137994: PUSH
137995: LD_INT 49
137997: EQUAL
137998: IFFALSE 138119
// begin if not HasTask ( group [ i ] ) then
138000: LD_VAR 0 4
138004: PUSH
138005: LD_VAR 0 7
138009: ARRAY
138010: PPUSH
138011: CALL_OW 314
138015: NOT
138016: IFFALSE 138119
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
138018: LD_ADDR_VAR 0 9
138022: PUSH
138023: LD_INT 81
138025: PUSH
138026: LD_VAR 0 4
138030: PUSH
138031: LD_VAR 0 7
138035: ARRAY
138036: PPUSH
138037: CALL_OW 255
138041: PUSH
138042: EMPTY
138043: LIST
138044: LIST
138045: PPUSH
138046: CALL_OW 69
138050: PPUSH
138051: LD_VAR 0 4
138055: PUSH
138056: LD_VAR 0 7
138060: ARRAY
138061: PPUSH
138062: CALL_OW 74
138066: ST_TO_ADDR
// if k then
138067: LD_VAR 0 9
138071: IFFALSE 138119
// if GetDistUnits ( group [ i ] , k ) > 10 then
138073: LD_VAR 0 4
138077: PUSH
138078: LD_VAR 0 7
138082: ARRAY
138083: PPUSH
138084: LD_VAR 0 9
138088: PPUSH
138089: CALL_OW 296
138093: PUSH
138094: LD_INT 10
138096: GREATER
138097: IFFALSE 138119
// ComMoveUnit ( group [ i ] , k ) ;
138099: LD_VAR 0 4
138103: PUSH
138104: LD_VAR 0 7
138108: ARRAY
138109: PPUSH
138110: LD_VAR 0 9
138114: PPUSH
138115: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
138119: LD_VAR 0 4
138123: PUSH
138124: LD_VAR 0 7
138128: ARRAY
138129: PPUSH
138130: CALL_OW 256
138134: PUSH
138135: LD_INT 250
138137: LESS
138138: PUSH
138139: LD_VAR 0 4
138143: PUSH
138144: LD_VAR 0 7
138148: ARRAY
138149: PUSH
138150: LD_INT 21
138152: PUSH
138153: LD_INT 2
138155: PUSH
138156: EMPTY
138157: LIST
138158: LIST
138159: PUSH
138160: LD_INT 23
138162: PUSH
138163: LD_INT 2
138165: PUSH
138166: EMPTY
138167: LIST
138168: LIST
138169: PUSH
138170: EMPTY
138171: LIST
138172: LIST
138173: PPUSH
138174: CALL_OW 69
138178: IN
138179: AND
138180: IFFALSE 138305
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
138182: LD_ADDR_VAR 0 9
138186: PUSH
138187: LD_OWVAR 3
138191: PUSH
138192: LD_VAR 0 4
138196: PUSH
138197: LD_VAR 0 7
138201: ARRAY
138202: DIFF
138203: PPUSH
138204: LD_VAR 0 4
138208: PUSH
138209: LD_VAR 0 7
138213: ARRAY
138214: PPUSH
138215: CALL_OW 74
138219: ST_TO_ADDR
// if not k then
138220: LD_VAR 0 9
138224: NOT
138225: IFFALSE 138229
// continue ;
138227: GO 134644
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
138229: LD_VAR 0 9
138233: PUSH
138234: LD_INT 81
138236: PUSH
138237: LD_VAR 0 4
138241: PUSH
138242: LD_VAR 0 7
138246: ARRAY
138247: PPUSH
138248: CALL_OW 255
138252: PUSH
138253: EMPTY
138254: LIST
138255: LIST
138256: PPUSH
138257: CALL_OW 69
138261: IN
138262: PUSH
138263: LD_VAR 0 9
138267: PPUSH
138268: LD_VAR 0 4
138272: PUSH
138273: LD_VAR 0 7
138277: ARRAY
138278: PPUSH
138279: CALL_OW 296
138283: PUSH
138284: LD_INT 5
138286: LESS
138287: AND
138288: IFFALSE 138305
// ComAutodestruct ( group [ i ] ) ;
138290: LD_VAR 0 4
138294: PUSH
138295: LD_VAR 0 7
138299: ARRAY
138300: PPUSH
138301: CALL 103475 0 1
// end ; if f_attack_depot then
138305: LD_VAR 0 25
138309: IFFALSE 138421
// begin k := 6 ;
138311: LD_ADDR_VAR 0 9
138315: PUSH
138316: LD_INT 6
138318: ST_TO_ADDR
// if tmp < k then
138319: LD_VAR 0 14
138323: PUSH
138324: LD_VAR 0 9
138328: LESS
138329: IFFALSE 138341
// k := tmp ;
138331: LD_ADDR_VAR 0 9
138335: PUSH
138336: LD_VAR 0 14
138340: ST_TO_ADDR
// for j = 1 to k do
138341: LD_ADDR_VAR 0 8
138345: PUSH
138346: DOUBLE
138347: LD_INT 1
138349: DEC
138350: ST_TO_ADDR
138351: LD_VAR 0 9
138355: PUSH
138356: FOR_TO
138357: IFFALSE 138419
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
138359: LD_VAR 0 8
138363: PPUSH
138364: CALL_OW 266
138368: PUSH
138369: LD_INT 0
138371: PUSH
138372: LD_INT 1
138374: PUSH
138375: EMPTY
138376: LIST
138377: LIST
138378: IN
138379: IFFALSE 138417
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
138381: LD_VAR 0 4
138385: PUSH
138386: LD_VAR 0 7
138390: ARRAY
138391: PPUSH
138392: LD_VAR 0 14
138396: PUSH
138397: LD_VAR 0 8
138401: ARRAY
138402: PPUSH
138403: CALL_OW 115
// attacking := true ;
138407: LD_ADDR_VAR 0 29
138411: PUSH
138412: LD_INT 1
138414: ST_TO_ADDR
// break ;
138415: GO 138419
// end ;
138417: GO 138356
138419: POP
138420: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
138421: LD_VAR 0 4
138425: PUSH
138426: LD_VAR 0 7
138430: ARRAY
138431: PPUSH
138432: CALL_OW 302
138436: PUSH
138437: LD_VAR 0 29
138441: NOT
138442: AND
138443: IFFALSE 138765
// begin if GetTag ( group [ i ] ) = 71 then
138445: LD_VAR 0 4
138449: PUSH
138450: LD_VAR 0 7
138454: ARRAY
138455: PPUSH
138456: CALL_OW 110
138460: PUSH
138461: LD_INT 71
138463: EQUAL
138464: IFFALSE 138505
// begin if HasTask ( group [ i ] ) then
138466: LD_VAR 0 4
138470: PUSH
138471: LD_VAR 0 7
138475: ARRAY
138476: PPUSH
138477: CALL_OW 314
138481: IFFALSE 138487
// continue else
138483: GO 134644
138485: GO 138505
// SetTag ( group [ i ] , 0 ) ;
138487: LD_VAR 0 4
138491: PUSH
138492: LD_VAR 0 7
138496: ARRAY
138497: PPUSH
138498: LD_INT 0
138500: PPUSH
138501: CALL_OW 109
// end ; k := 8 ;
138505: LD_ADDR_VAR 0 9
138509: PUSH
138510: LD_INT 8
138512: ST_TO_ADDR
// x := 0 ;
138513: LD_ADDR_VAR 0 10
138517: PUSH
138518: LD_INT 0
138520: ST_TO_ADDR
// if tmp < k then
138521: LD_VAR 0 14
138525: PUSH
138526: LD_VAR 0 9
138530: LESS
138531: IFFALSE 138543
// k := tmp ;
138533: LD_ADDR_VAR 0 9
138537: PUSH
138538: LD_VAR 0 14
138542: ST_TO_ADDR
// for j = 1 to k do
138543: LD_ADDR_VAR 0 8
138547: PUSH
138548: DOUBLE
138549: LD_INT 1
138551: DEC
138552: ST_TO_ADDR
138553: LD_VAR 0 9
138557: PUSH
138558: FOR_TO
138559: IFFALSE 138657
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
138561: LD_VAR 0 14
138565: PUSH
138566: LD_VAR 0 8
138570: ARRAY
138571: PPUSH
138572: CALL_OW 247
138576: PUSH
138577: LD_INT 1
138579: EQUAL
138580: PUSH
138581: LD_VAR 0 14
138585: PUSH
138586: LD_VAR 0 8
138590: ARRAY
138591: PPUSH
138592: CALL_OW 256
138596: PUSH
138597: LD_INT 250
138599: LESS
138600: PUSH
138601: LD_VAR 0 20
138605: AND
138606: PUSH
138607: LD_VAR 0 20
138611: NOT
138612: PUSH
138613: LD_VAR 0 14
138617: PUSH
138618: LD_VAR 0 8
138622: ARRAY
138623: PPUSH
138624: CALL_OW 256
138628: PUSH
138629: LD_INT 250
138631: GREATEREQUAL
138632: AND
138633: OR
138634: AND
138635: IFFALSE 138655
// begin x := tmp [ j ] ;
138637: LD_ADDR_VAR 0 10
138641: PUSH
138642: LD_VAR 0 14
138646: PUSH
138647: LD_VAR 0 8
138651: ARRAY
138652: ST_TO_ADDR
// break ;
138653: GO 138657
// end ;
138655: GO 138558
138657: POP
138658: POP
// if x then
138659: LD_VAR 0 10
138663: IFFALSE 138687
// ComAttackUnit ( group [ i ] , x ) else
138665: LD_VAR 0 4
138669: PUSH
138670: LD_VAR 0 7
138674: ARRAY
138675: PPUSH
138676: LD_VAR 0 10
138680: PPUSH
138681: CALL_OW 115
138685: GO 138711
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
138687: LD_VAR 0 4
138691: PUSH
138692: LD_VAR 0 7
138696: ARRAY
138697: PPUSH
138698: LD_VAR 0 14
138702: PUSH
138703: LD_INT 1
138705: ARRAY
138706: PPUSH
138707: CALL_OW 115
// if not HasTask ( group [ i ] ) then
138711: LD_VAR 0 4
138715: PUSH
138716: LD_VAR 0 7
138720: ARRAY
138721: PPUSH
138722: CALL_OW 314
138726: NOT
138727: IFFALSE 138765
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
138729: LD_VAR 0 4
138733: PUSH
138734: LD_VAR 0 7
138738: ARRAY
138739: PPUSH
138740: LD_VAR 0 14
138744: PPUSH
138745: LD_VAR 0 4
138749: PUSH
138750: LD_VAR 0 7
138754: ARRAY
138755: PPUSH
138756: CALL_OW 74
138760: PPUSH
138761: CALL_OW 115
// end ; end ; end ;
138765: GO 134644
138767: POP
138768: POP
// wait ( 0 0$2 ) ;
138769: LD_INT 70
138771: PPUSH
138772: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
138776: LD_VAR 0 4
138780: NOT
138781: PUSH
138782: LD_VAR 0 4
138786: PUSH
138787: EMPTY
138788: EQUAL
138789: OR
138790: PUSH
138791: LD_INT 81
138793: PUSH
138794: LD_VAR 0 35
138798: PUSH
138799: EMPTY
138800: LIST
138801: LIST
138802: PPUSH
138803: CALL_OW 69
138807: NOT
138808: OR
138809: IFFALSE 134629
// end ;
138811: LD_VAR 0 2
138815: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
138816: LD_INT 0
138818: PPUSH
138819: PPUSH
138820: PPUSH
138821: PPUSH
138822: PPUSH
138823: PPUSH
// if not base or not mc_bases [ base ] or not solds then
138824: LD_VAR 0 1
138828: NOT
138829: PUSH
138830: LD_EXP 102
138834: PUSH
138835: LD_VAR 0 1
138839: ARRAY
138840: NOT
138841: OR
138842: PUSH
138843: LD_VAR 0 2
138847: NOT
138848: OR
138849: IFFALSE 138853
// exit ;
138851: GO 139407
// side := mc_sides [ base ] ;
138853: LD_ADDR_VAR 0 6
138857: PUSH
138858: LD_EXP 128
138862: PUSH
138863: LD_VAR 0 1
138867: ARRAY
138868: ST_TO_ADDR
// if not side then
138869: LD_VAR 0 6
138873: NOT
138874: IFFALSE 138878
// exit ;
138876: GO 139407
// for i in solds do
138878: LD_ADDR_VAR 0 7
138882: PUSH
138883: LD_VAR 0 2
138887: PUSH
138888: FOR_IN
138889: IFFALSE 138950
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
138891: LD_VAR 0 7
138895: PPUSH
138896: CALL_OW 310
138900: PPUSH
138901: CALL_OW 266
138905: PUSH
138906: LD_INT 32
138908: PUSH
138909: LD_INT 31
138911: PUSH
138912: EMPTY
138913: LIST
138914: LIST
138915: IN
138916: IFFALSE 138936
// solds := solds diff i else
138918: LD_ADDR_VAR 0 2
138922: PUSH
138923: LD_VAR 0 2
138927: PUSH
138928: LD_VAR 0 7
138932: DIFF
138933: ST_TO_ADDR
138934: GO 138948
// SetTag ( i , 18 ) ;
138936: LD_VAR 0 7
138940: PPUSH
138941: LD_INT 18
138943: PPUSH
138944: CALL_OW 109
138948: GO 138888
138950: POP
138951: POP
// if not solds then
138952: LD_VAR 0 2
138956: NOT
138957: IFFALSE 138961
// exit ;
138959: GO 139407
// repeat wait ( 0 0$2 ) ;
138961: LD_INT 70
138963: PPUSH
138964: CALL_OW 67
// enemy := mc_scan [ base ] ;
138968: LD_ADDR_VAR 0 4
138972: PUSH
138973: LD_EXP 125
138977: PUSH
138978: LD_VAR 0 1
138982: ARRAY
138983: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
138984: LD_EXP 102
138988: PUSH
138989: LD_VAR 0 1
138993: ARRAY
138994: NOT
138995: PUSH
138996: LD_EXP 102
139000: PUSH
139001: LD_VAR 0 1
139005: ARRAY
139006: PUSH
139007: EMPTY
139008: EQUAL
139009: OR
139010: IFFALSE 139047
// begin for i in solds do
139012: LD_ADDR_VAR 0 7
139016: PUSH
139017: LD_VAR 0 2
139021: PUSH
139022: FOR_IN
139023: IFFALSE 139036
// ComStop ( i ) ;
139025: LD_VAR 0 7
139029: PPUSH
139030: CALL_OW 141
139034: GO 139022
139036: POP
139037: POP
// solds := [ ] ;
139038: LD_ADDR_VAR 0 2
139042: PUSH
139043: EMPTY
139044: ST_TO_ADDR
// exit ;
139045: GO 139407
// end ; for i in solds do
139047: LD_ADDR_VAR 0 7
139051: PUSH
139052: LD_VAR 0 2
139056: PUSH
139057: FOR_IN
139058: IFFALSE 139379
// begin if IsInUnit ( i ) then
139060: LD_VAR 0 7
139064: PPUSH
139065: CALL_OW 310
139069: IFFALSE 139080
// ComExitBuilding ( i ) ;
139071: LD_VAR 0 7
139075: PPUSH
139076: CALL_OW 122
// if GetLives ( i ) > 500 then
139080: LD_VAR 0 7
139084: PPUSH
139085: CALL_OW 256
139089: PUSH
139090: LD_INT 500
139092: GREATER
139093: IFFALSE 139146
// begin e := NearestUnitToUnit ( enemy , i ) ;
139095: LD_ADDR_VAR 0 5
139099: PUSH
139100: LD_VAR 0 4
139104: PPUSH
139105: LD_VAR 0 7
139109: PPUSH
139110: CALL_OW 74
139114: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
139115: LD_VAR 0 7
139119: PPUSH
139120: LD_VAR 0 5
139124: PPUSH
139125: CALL_OW 250
139129: PPUSH
139130: LD_VAR 0 5
139134: PPUSH
139135: CALL_OW 251
139139: PPUSH
139140: CALL_OW 114
// end else
139144: GO 139377
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
139146: LD_VAR 0 7
139150: PPUSH
139151: LD_EXP 102
139155: PUSH
139156: LD_VAR 0 1
139160: ARRAY
139161: PPUSH
139162: LD_INT 2
139164: PUSH
139165: LD_INT 30
139167: PUSH
139168: LD_INT 0
139170: PUSH
139171: EMPTY
139172: LIST
139173: LIST
139174: PUSH
139175: LD_INT 30
139177: PUSH
139178: LD_INT 1
139180: PUSH
139181: EMPTY
139182: LIST
139183: LIST
139184: PUSH
139185: LD_INT 30
139187: PUSH
139188: LD_INT 6
139190: PUSH
139191: EMPTY
139192: LIST
139193: LIST
139194: PUSH
139195: EMPTY
139196: LIST
139197: LIST
139198: LIST
139199: LIST
139200: PPUSH
139201: CALL_OW 72
139205: PPUSH
139206: LD_VAR 0 7
139210: PPUSH
139211: CALL_OW 74
139215: PPUSH
139216: CALL_OW 296
139220: PUSH
139221: LD_INT 10
139223: GREATER
139224: IFFALSE 139377
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
139226: LD_ADDR_VAR 0 8
139230: PUSH
139231: LD_EXP 102
139235: PUSH
139236: LD_VAR 0 1
139240: ARRAY
139241: PPUSH
139242: LD_INT 2
139244: PUSH
139245: LD_INT 30
139247: PUSH
139248: LD_INT 0
139250: PUSH
139251: EMPTY
139252: LIST
139253: LIST
139254: PUSH
139255: LD_INT 30
139257: PUSH
139258: LD_INT 1
139260: PUSH
139261: EMPTY
139262: LIST
139263: LIST
139264: PUSH
139265: LD_INT 30
139267: PUSH
139268: LD_INT 6
139270: PUSH
139271: EMPTY
139272: LIST
139273: LIST
139274: PUSH
139275: EMPTY
139276: LIST
139277: LIST
139278: LIST
139279: LIST
139280: PPUSH
139281: CALL_OW 72
139285: PPUSH
139286: LD_VAR 0 7
139290: PPUSH
139291: CALL_OW 74
139295: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
139296: LD_VAR 0 7
139300: PPUSH
139301: LD_VAR 0 8
139305: PPUSH
139306: CALL_OW 250
139310: PPUSH
139311: LD_INT 3
139313: PPUSH
139314: LD_INT 5
139316: PPUSH
139317: CALL_OW 272
139321: PPUSH
139322: LD_VAR 0 8
139326: PPUSH
139327: CALL_OW 251
139331: PPUSH
139332: LD_INT 3
139334: PPUSH
139335: LD_INT 5
139337: PPUSH
139338: CALL_OW 273
139342: PPUSH
139343: CALL_OW 111
// SetTag ( i , 0 ) ;
139347: LD_VAR 0 7
139351: PPUSH
139352: LD_INT 0
139354: PPUSH
139355: CALL_OW 109
// solds := solds diff i ;
139359: LD_ADDR_VAR 0 2
139363: PUSH
139364: LD_VAR 0 2
139368: PUSH
139369: LD_VAR 0 7
139373: DIFF
139374: ST_TO_ADDR
// continue ;
139375: GO 139057
// end ; end ;
139377: GO 139057
139379: POP
139380: POP
// until not solds or not enemy ;
139381: LD_VAR 0 2
139385: NOT
139386: PUSH
139387: LD_VAR 0 4
139391: NOT
139392: OR
139393: IFFALSE 138961
// MC_Reset ( base , 18 ) ;
139395: LD_VAR 0 1
139399: PPUSH
139400: LD_INT 18
139402: PPUSH
139403: CALL 43733 0 2
// end ;
139407: LD_VAR 0 3
139411: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
139412: LD_INT 0
139414: PPUSH
139415: PPUSH
139416: PPUSH
139417: PPUSH
139418: PPUSH
139419: PPUSH
139420: PPUSH
139421: PPUSH
139422: PPUSH
139423: PPUSH
139424: PPUSH
139425: PPUSH
139426: PPUSH
139427: PPUSH
139428: PPUSH
139429: PPUSH
139430: PPUSH
139431: PPUSH
139432: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
139433: LD_ADDR_VAR 0 12
139437: PUSH
139438: LD_EXP 102
139442: PUSH
139443: LD_VAR 0 1
139447: ARRAY
139448: PPUSH
139449: LD_INT 25
139451: PUSH
139452: LD_INT 3
139454: PUSH
139455: EMPTY
139456: LIST
139457: LIST
139458: PPUSH
139459: CALL_OW 72
139463: ST_TO_ADDR
// if mc_remote_driver [ base ] then
139464: LD_EXP 142
139468: PUSH
139469: LD_VAR 0 1
139473: ARRAY
139474: IFFALSE 139498
// mechs := mechs diff mc_remote_driver [ base ] ;
139476: LD_ADDR_VAR 0 12
139480: PUSH
139481: LD_VAR 0 12
139485: PUSH
139486: LD_EXP 142
139490: PUSH
139491: LD_VAR 0 1
139495: ARRAY
139496: DIFF
139497: ST_TO_ADDR
// for i in mechs do
139498: LD_ADDR_VAR 0 4
139502: PUSH
139503: LD_VAR 0 12
139507: PUSH
139508: FOR_IN
139509: IFFALSE 139544
// if GetTag ( i ) > 0 then
139511: LD_VAR 0 4
139515: PPUSH
139516: CALL_OW 110
139520: PUSH
139521: LD_INT 0
139523: GREATER
139524: IFFALSE 139542
// mechs := mechs diff i ;
139526: LD_ADDR_VAR 0 12
139530: PUSH
139531: LD_VAR 0 12
139535: PUSH
139536: LD_VAR 0 4
139540: DIFF
139541: ST_TO_ADDR
139542: GO 139508
139544: POP
139545: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
139546: LD_ADDR_VAR 0 8
139550: PUSH
139551: LD_EXP 102
139555: PUSH
139556: LD_VAR 0 1
139560: ARRAY
139561: PPUSH
139562: LD_INT 2
139564: PUSH
139565: LD_INT 25
139567: PUSH
139568: LD_INT 1
139570: PUSH
139571: EMPTY
139572: LIST
139573: LIST
139574: PUSH
139575: LD_INT 25
139577: PUSH
139578: LD_INT 5
139580: PUSH
139581: EMPTY
139582: LIST
139583: LIST
139584: PUSH
139585: LD_INT 25
139587: PUSH
139588: LD_INT 8
139590: PUSH
139591: EMPTY
139592: LIST
139593: LIST
139594: PUSH
139595: LD_INT 25
139597: PUSH
139598: LD_INT 9
139600: PUSH
139601: EMPTY
139602: LIST
139603: LIST
139604: PUSH
139605: EMPTY
139606: LIST
139607: LIST
139608: LIST
139609: LIST
139610: LIST
139611: PPUSH
139612: CALL_OW 72
139616: ST_TO_ADDR
// if not defenders and not solds then
139617: LD_VAR 0 2
139621: NOT
139622: PUSH
139623: LD_VAR 0 8
139627: NOT
139628: AND
139629: IFFALSE 139633
// exit ;
139631: GO 141403
// depot_under_attack := false ;
139633: LD_ADDR_VAR 0 16
139637: PUSH
139638: LD_INT 0
139640: ST_TO_ADDR
// sold_defenders := [ ] ;
139641: LD_ADDR_VAR 0 17
139645: PUSH
139646: EMPTY
139647: ST_TO_ADDR
// if mechs then
139648: LD_VAR 0 12
139652: IFFALSE 139805
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
139654: LD_ADDR_VAR 0 4
139658: PUSH
139659: LD_VAR 0 2
139663: PPUSH
139664: LD_INT 21
139666: PUSH
139667: LD_INT 2
139669: PUSH
139670: EMPTY
139671: LIST
139672: LIST
139673: PPUSH
139674: CALL_OW 72
139678: PUSH
139679: FOR_IN
139680: IFFALSE 139803
// begin if GetTag ( i ) <> 20 then
139682: LD_VAR 0 4
139686: PPUSH
139687: CALL_OW 110
139691: PUSH
139692: LD_INT 20
139694: NONEQUAL
139695: IFFALSE 139709
// SetTag ( i , 20 ) ;
139697: LD_VAR 0 4
139701: PPUSH
139702: LD_INT 20
139704: PPUSH
139705: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
139709: LD_VAR 0 4
139713: PPUSH
139714: CALL_OW 263
139718: PUSH
139719: LD_INT 1
139721: EQUAL
139722: PUSH
139723: LD_VAR 0 4
139727: PPUSH
139728: CALL_OW 311
139732: NOT
139733: AND
139734: IFFALSE 139801
// begin un := mechs [ 1 ] ;
139736: LD_ADDR_VAR 0 10
139740: PUSH
139741: LD_VAR 0 12
139745: PUSH
139746: LD_INT 1
139748: ARRAY
139749: ST_TO_ADDR
// ComExit ( un ) ;
139750: LD_VAR 0 10
139754: PPUSH
139755: CALL 108361 0 1
// AddComEnterUnit ( un , i ) ;
139759: LD_VAR 0 10
139763: PPUSH
139764: LD_VAR 0 4
139768: PPUSH
139769: CALL_OW 180
// SetTag ( un , 19 ) ;
139773: LD_VAR 0 10
139777: PPUSH
139778: LD_INT 19
139780: PPUSH
139781: CALL_OW 109
// mechs := mechs diff un ;
139785: LD_ADDR_VAR 0 12
139789: PUSH
139790: LD_VAR 0 12
139794: PUSH
139795: LD_VAR 0 10
139799: DIFF
139800: ST_TO_ADDR
// end ; end ;
139801: GO 139679
139803: POP
139804: POP
// if solds then
139805: LD_VAR 0 8
139809: IFFALSE 139868
// for i in solds do
139811: LD_ADDR_VAR 0 4
139815: PUSH
139816: LD_VAR 0 8
139820: PUSH
139821: FOR_IN
139822: IFFALSE 139866
// if not GetTag ( i ) then
139824: LD_VAR 0 4
139828: PPUSH
139829: CALL_OW 110
139833: NOT
139834: IFFALSE 139864
// begin defenders := defenders union i ;
139836: LD_ADDR_VAR 0 2
139840: PUSH
139841: LD_VAR 0 2
139845: PUSH
139846: LD_VAR 0 4
139850: UNION
139851: ST_TO_ADDR
// SetTag ( i , 18 ) ;
139852: LD_VAR 0 4
139856: PPUSH
139857: LD_INT 18
139859: PPUSH
139860: CALL_OW 109
// end ;
139864: GO 139821
139866: POP
139867: POP
// repeat wait ( 0 0$2 ) ;
139868: LD_INT 70
139870: PPUSH
139871: CALL_OW 67
// enemy := mc_scan [ base ] ;
139875: LD_ADDR_VAR 0 21
139879: PUSH
139880: LD_EXP 125
139884: PUSH
139885: LD_VAR 0 1
139889: ARRAY
139890: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
139891: LD_EXP 102
139895: PUSH
139896: LD_VAR 0 1
139900: ARRAY
139901: NOT
139902: PUSH
139903: LD_EXP 102
139907: PUSH
139908: LD_VAR 0 1
139912: ARRAY
139913: PUSH
139914: EMPTY
139915: EQUAL
139916: OR
139917: IFFALSE 139954
// begin for i in defenders do
139919: LD_ADDR_VAR 0 4
139923: PUSH
139924: LD_VAR 0 2
139928: PUSH
139929: FOR_IN
139930: IFFALSE 139943
// ComStop ( i ) ;
139932: LD_VAR 0 4
139936: PPUSH
139937: CALL_OW 141
139941: GO 139929
139943: POP
139944: POP
// defenders := [ ] ;
139945: LD_ADDR_VAR 0 2
139949: PUSH
139950: EMPTY
139951: ST_TO_ADDR
// exit ;
139952: GO 141403
// end ; for i in defenders do
139954: LD_ADDR_VAR 0 4
139958: PUSH
139959: LD_VAR 0 2
139963: PUSH
139964: FOR_IN
139965: IFFALSE 140863
// begin e := NearestUnitToUnit ( enemy , i ) ;
139967: LD_ADDR_VAR 0 13
139971: PUSH
139972: LD_VAR 0 21
139976: PPUSH
139977: LD_VAR 0 4
139981: PPUSH
139982: CALL_OW 74
139986: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
139987: LD_ADDR_VAR 0 7
139991: PUSH
139992: LD_EXP 102
139996: PUSH
139997: LD_VAR 0 1
140001: ARRAY
140002: PPUSH
140003: LD_INT 2
140005: PUSH
140006: LD_INT 30
140008: PUSH
140009: LD_INT 0
140011: PUSH
140012: EMPTY
140013: LIST
140014: LIST
140015: PUSH
140016: LD_INT 30
140018: PUSH
140019: LD_INT 1
140021: PUSH
140022: EMPTY
140023: LIST
140024: LIST
140025: PUSH
140026: EMPTY
140027: LIST
140028: LIST
140029: LIST
140030: PPUSH
140031: CALL_OW 72
140035: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
140036: LD_ADDR_VAR 0 16
140040: PUSH
140041: LD_VAR 0 7
140045: NOT
140046: PUSH
140047: LD_VAR 0 7
140051: PPUSH
140052: LD_INT 3
140054: PUSH
140055: LD_INT 24
140057: PUSH
140058: LD_INT 600
140060: PUSH
140061: EMPTY
140062: LIST
140063: LIST
140064: PUSH
140065: EMPTY
140066: LIST
140067: LIST
140068: PPUSH
140069: CALL_OW 72
140073: OR
140074: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
140075: LD_VAR 0 4
140079: PPUSH
140080: CALL_OW 247
140084: PUSH
140085: LD_INT 2
140087: DOUBLE
140088: EQUAL
140089: IFTRUE 140093
140091: GO 140489
140093: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
140094: LD_VAR 0 4
140098: PPUSH
140099: CALL_OW 256
140103: PUSH
140104: LD_INT 1000
140106: EQUAL
140107: PUSH
140108: LD_VAR 0 4
140112: PPUSH
140113: LD_VAR 0 13
140117: PPUSH
140118: CALL_OW 296
140122: PUSH
140123: LD_INT 40
140125: LESS
140126: PUSH
140127: LD_VAR 0 13
140131: PPUSH
140132: LD_EXP 127
140136: PUSH
140137: LD_VAR 0 1
140141: ARRAY
140142: PPUSH
140143: CALL_OW 308
140147: OR
140148: AND
140149: IFFALSE 140271
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
140151: LD_VAR 0 4
140155: PPUSH
140156: CALL_OW 262
140160: PUSH
140161: LD_INT 1
140163: EQUAL
140164: PUSH
140165: LD_VAR 0 4
140169: PPUSH
140170: CALL_OW 261
140174: PUSH
140175: LD_INT 30
140177: LESS
140178: AND
140179: PUSH
140180: LD_VAR 0 7
140184: AND
140185: IFFALSE 140255
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
140187: LD_VAR 0 4
140191: PPUSH
140192: LD_VAR 0 7
140196: PPUSH
140197: LD_VAR 0 4
140201: PPUSH
140202: CALL_OW 74
140206: PPUSH
140207: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
140211: LD_VAR 0 4
140215: PPUSH
140216: LD_VAR 0 7
140220: PPUSH
140221: LD_VAR 0 4
140225: PPUSH
140226: CALL_OW 74
140230: PPUSH
140231: CALL_OW 296
140235: PUSH
140236: LD_INT 6
140238: LESS
140239: IFFALSE 140253
// SetFuel ( i , 100 ) ;
140241: LD_VAR 0 4
140245: PPUSH
140246: LD_INT 100
140248: PPUSH
140249: CALL_OW 240
// end else
140253: GO 140269
// ComAttackUnit ( i , e ) ;
140255: LD_VAR 0 4
140259: PPUSH
140260: LD_VAR 0 13
140264: PPUSH
140265: CALL_OW 115
// end else
140269: GO 140372
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
140271: LD_VAR 0 13
140275: PPUSH
140276: LD_EXP 127
140280: PUSH
140281: LD_VAR 0 1
140285: ARRAY
140286: PPUSH
140287: CALL_OW 308
140291: NOT
140292: PUSH
140293: LD_VAR 0 4
140297: PPUSH
140298: LD_VAR 0 13
140302: PPUSH
140303: CALL_OW 296
140307: PUSH
140308: LD_INT 40
140310: GREATEREQUAL
140311: AND
140312: PUSH
140313: LD_VAR 0 4
140317: PPUSH
140318: CALL_OW 256
140322: PUSH
140323: LD_INT 650
140325: LESSEQUAL
140326: OR
140327: PUSH
140328: LD_VAR 0 4
140332: PPUSH
140333: LD_EXP 126
140337: PUSH
140338: LD_VAR 0 1
140342: ARRAY
140343: PPUSH
140344: CALL_OW 308
140348: NOT
140349: AND
140350: IFFALSE 140372
// ComMoveToArea ( i , mc_parking [ base ] ) ;
140352: LD_VAR 0 4
140356: PPUSH
140357: LD_EXP 126
140361: PUSH
140362: LD_VAR 0 1
140366: ARRAY
140367: PPUSH
140368: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
140372: LD_VAR 0 4
140376: PPUSH
140377: CALL_OW 256
140381: PUSH
140382: LD_INT 1000
140384: LESS
140385: PUSH
140386: LD_VAR 0 4
140390: PPUSH
140391: CALL_OW 263
140395: PUSH
140396: LD_INT 1
140398: EQUAL
140399: AND
140400: PUSH
140401: LD_VAR 0 4
140405: PPUSH
140406: CALL_OW 311
140410: AND
140411: PUSH
140412: LD_VAR 0 4
140416: PPUSH
140417: LD_EXP 126
140421: PUSH
140422: LD_VAR 0 1
140426: ARRAY
140427: PPUSH
140428: CALL_OW 308
140432: AND
140433: IFFALSE 140487
// begin mech := IsDrivenBy ( i ) ;
140435: LD_ADDR_VAR 0 9
140439: PUSH
140440: LD_VAR 0 4
140444: PPUSH
140445: CALL_OW 311
140449: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
140450: LD_VAR 0 9
140454: PPUSH
140455: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
140459: LD_VAR 0 9
140463: PPUSH
140464: LD_VAR 0 4
140468: PPUSH
140469: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
140473: LD_VAR 0 9
140477: PPUSH
140478: LD_VAR 0 4
140482: PPUSH
140483: CALL_OW 180
// end ; end ; unit_human :
140487: GO 140834
140489: LD_INT 1
140491: DOUBLE
140492: EQUAL
140493: IFTRUE 140497
140495: GO 140833
140497: POP
// begin b := IsInUnit ( i ) ;
140498: LD_ADDR_VAR 0 18
140502: PUSH
140503: LD_VAR 0 4
140507: PPUSH
140508: CALL_OW 310
140512: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
140513: LD_ADDR_VAR 0 19
140517: PUSH
140518: LD_VAR 0 18
140522: NOT
140523: PUSH
140524: LD_VAR 0 18
140528: PPUSH
140529: CALL_OW 266
140533: PUSH
140534: LD_INT 32
140536: PUSH
140537: LD_INT 31
140539: PUSH
140540: EMPTY
140541: LIST
140542: LIST
140543: IN
140544: OR
140545: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
140546: LD_VAR 0 18
140550: PPUSH
140551: CALL_OW 266
140555: PUSH
140556: LD_INT 5
140558: EQUAL
140559: PUSH
140560: LD_VAR 0 4
140564: PPUSH
140565: CALL_OW 257
140569: PUSH
140570: LD_INT 1
140572: PUSH
140573: LD_INT 2
140575: PUSH
140576: LD_INT 3
140578: PUSH
140579: LD_INT 4
140581: PUSH
140582: EMPTY
140583: LIST
140584: LIST
140585: LIST
140586: LIST
140587: IN
140588: AND
140589: IFFALSE 140626
// begin class := AllowSpecClass ( i ) ;
140591: LD_ADDR_VAR 0 20
140595: PUSH
140596: LD_VAR 0 4
140600: PPUSH
140601: CALL 72058 0 1
140605: ST_TO_ADDR
// if class then
140606: LD_VAR 0 20
140610: IFFALSE 140626
// ComChangeProfession ( i , class ) ;
140612: LD_VAR 0 4
140616: PPUSH
140617: LD_VAR 0 20
140621: PPUSH
140622: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
140626: LD_VAR 0 16
140630: PUSH
140631: LD_VAR 0 2
140635: PPUSH
140636: LD_INT 21
140638: PUSH
140639: LD_INT 2
140641: PUSH
140642: EMPTY
140643: LIST
140644: LIST
140645: PPUSH
140646: CALL_OW 72
140650: PUSH
140651: LD_INT 1
140653: LESSEQUAL
140654: OR
140655: PUSH
140656: LD_VAR 0 19
140660: AND
140661: PUSH
140662: LD_VAR 0 4
140666: PUSH
140667: LD_VAR 0 17
140671: IN
140672: NOT
140673: AND
140674: IFFALSE 140767
// begin if b then
140676: LD_VAR 0 18
140680: IFFALSE 140729
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
140682: LD_VAR 0 18
140686: PPUSH
140687: LD_VAR 0 21
140691: PPUSH
140692: LD_VAR 0 18
140696: PPUSH
140697: CALL_OW 74
140701: PPUSH
140702: CALL_OW 296
140706: PUSH
140707: LD_INT 10
140709: LESS
140710: PUSH
140711: LD_VAR 0 18
140715: PPUSH
140716: CALL_OW 461
140720: PUSH
140721: LD_INT 7
140723: NONEQUAL
140724: AND
140725: IFFALSE 140729
// continue ;
140727: GO 139964
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
140729: LD_ADDR_VAR 0 17
140733: PUSH
140734: LD_VAR 0 17
140738: PPUSH
140739: LD_VAR 0 17
140743: PUSH
140744: LD_INT 1
140746: PLUS
140747: PPUSH
140748: LD_VAR 0 4
140752: PPUSH
140753: CALL_OW 1
140757: ST_TO_ADDR
// ComExitBuilding ( i ) ;
140758: LD_VAR 0 4
140762: PPUSH
140763: CALL_OW 122
// end ; if sold_defenders then
140767: LD_VAR 0 17
140771: IFFALSE 140831
// if i in sold_defenders then
140773: LD_VAR 0 4
140777: PUSH
140778: LD_VAR 0 17
140782: IN
140783: IFFALSE 140831
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
140785: LD_VAR 0 4
140789: PPUSH
140790: CALL_OW 314
140794: NOT
140795: PUSH
140796: LD_VAR 0 4
140800: PPUSH
140801: LD_VAR 0 13
140805: PPUSH
140806: CALL_OW 296
140810: PUSH
140811: LD_INT 30
140813: LESS
140814: AND
140815: IFFALSE 140831
// ComAttackUnit ( i , e ) ;
140817: LD_VAR 0 4
140821: PPUSH
140822: LD_VAR 0 13
140826: PPUSH
140827: CALL_OW 115
// end ; end ; end ;
140831: GO 140834
140833: POP
// if IsDead ( i ) then
140834: LD_VAR 0 4
140838: PPUSH
140839: CALL_OW 301
140843: IFFALSE 140861
// defenders := defenders diff i ;
140845: LD_ADDR_VAR 0 2
140849: PUSH
140850: LD_VAR 0 2
140854: PUSH
140855: LD_VAR 0 4
140859: DIFF
140860: ST_TO_ADDR
// end ;
140861: GO 139964
140863: POP
140864: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
140865: LD_VAR 0 21
140869: NOT
140870: PUSH
140871: LD_VAR 0 2
140875: NOT
140876: OR
140877: PUSH
140878: LD_EXP 102
140882: PUSH
140883: LD_VAR 0 1
140887: ARRAY
140888: NOT
140889: OR
140890: IFFALSE 139868
// MC_Reset ( base , 18 ) ;
140892: LD_VAR 0 1
140896: PPUSH
140897: LD_INT 18
140899: PPUSH
140900: CALL 43733 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
140904: LD_ADDR_VAR 0 2
140908: PUSH
140909: LD_VAR 0 2
140913: PUSH
140914: LD_VAR 0 2
140918: PPUSH
140919: LD_INT 2
140921: PUSH
140922: LD_INT 25
140924: PUSH
140925: LD_INT 1
140927: PUSH
140928: EMPTY
140929: LIST
140930: LIST
140931: PUSH
140932: LD_INT 25
140934: PUSH
140935: LD_INT 5
140937: PUSH
140938: EMPTY
140939: LIST
140940: LIST
140941: PUSH
140942: LD_INT 25
140944: PUSH
140945: LD_INT 8
140947: PUSH
140948: EMPTY
140949: LIST
140950: LIST
140951: PUSH
140952: LD_INT 25
140954: PUSH
140955: LD_INT 9
140957: PUSH
140958: EMPTY
140959: LIST
140960: LIST
140961: PUSH
140962: EMPTY
140963: LIST
140964: LIST
140965: LIST
140966: LIST
140967: LIST
140968: PPUSH
140969: CALL_OW 72
140973: DIFF
140974: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
140975: LD_VAR 0 21
140979: NOT
140980: PUSH
140981: LD_VAR 0 2
140985: PPUSH
140986: LD_INT 21
140988: PUSH
140989: LD_INT 2
140991: PUSH
140992: EMPTY
140993: LIST
140994: LIST
140995: PPUSH
140996: CALL_OW 72
141000: AND
141001: IFFALSE 141339
// begin tmp := FilterByTag ( defenders , 19 ) ;
141003: LD_ADDR_VAR 0 11
141007: PUSH
141008: LD_VAR 0 2
141012: PPUSH
141013: LD_INT 19
141015: PPUSH
141016: CALL 105532 0 2
141020: ST_TO_ADDR
// if tmp then
141021: LD_VAR 0 11
141025: IFFALSE 141095
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
141027: LD_ADDR_VAR 0 11
141031: PUSH
141032: LD_VAR 0 11
141036: PPUSH
141037: LD_INT 25
141039: PUSH
141040: LD_INT 3
141042: PUSH
141043: EMPTY
141044: LIST
141045: LIST
141046: PPUSH
141047: CALL_OW 72
141051: ST_TO_ADDR
// if tmp then
141052: LD_VAR 0 11
141056: IFFALSE 141095
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
141058: LD_ADDR_EXP 114
141062: PUSH
141063: LD_EXP 114
141067: PPUSH
141068: LD_VAR 0 1
141072: PPUSH
141073: LD_EXP 114
141077: PUSH
141078: LD_VAR 0 1
141082: ARRAY
141083: PUSH
141084: LD_VAR 0 11
141088: UNION
141089: PPUSH
141090: CALL_OW 1
141094: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
141095: LD_VAR 0 1
141099: PPUSH
141100: LD_INT 19
141102: PPUSH
141103: CALL 43733 0 2
// repeat wait ( 0 0$1 ) ;
141107: LD_INT 35
141109: PPUSH
141110: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
141114: LD_EXP 102
141118: PUSH
141119: LD_VAR 0 1
141123: ARRAY
141124: NOT
141125: PUSH
141126: LD_EXP 102
141130: PUSH
141131: LD_VAR 0 1
141135: ARRAY
141136: PUSH
141137: EMPTY
141138: EQUAL
141139: OR
141140: IFFALSE 141177
// begin for i in defenders do
141142: LD_ADDR_VAR 0 4
141146: PUSH
141147: LD_VAR 0 2
141151: PUSH
141152: FOR_IN
141153: IFFALSE 141166
// ComStop ( i ) ;
141155: LD_VAR 0 4
141159: PPUSH
141160: CALL_OW 141
141164: GO 141152
141166: POP
141167: POP
// defenders := [ ] ;
141168: LD_ADDR_VAR 0 2
141172: PUSH
141173: EMPTY
141174: ST_TO_ADDR
// exit ;
141175: GO 141403
// end ; for i in defenders do
141177: LD_ADDR_VAR 0 4
141181: PUSH
141182: LD_VAR 0 2
141186: PUSH
141187: FOR_IN
141188: IFFALSE 141277
// begin if not IsInArea ( i , mc_parking [ base ] ) then
141190: LD_VAR 0 4
141194: PPUSH
141195: LD_EXP 126
141199: PUSH
141200: LD_VAR 0 1
141204: ARRAY
141205: PPUSH
141206: CALL_OW 308
141210: NOT
141211: IFFALSE 141235
// ComMoveToArea ( i , mc_parking [ base ] ) else
141213: LD_VAR 0 4
141217: PPUSH
141218: LD_EXP 126
141222: PUSH
141223: LD_VAR 0 1
141227: ARRAY
141228: PPUSH
141229: CALL_OW 113
141233: GO 141275
// if GetControl ( i ) = control_manual then
141235: LD_VAR 0 4
141239: PPUSH
141240: CALL_OW 263
141244: PUSH
141245: LD_INT 1
141247: EQUAL
141248: IFFALSE 141275
// if IsDrivenBy ( i ) then
141250: LD_VAR 0 4
141254: PPUSH
141255: CALL_OW 311
141259: IFFALSE 141275
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
141261: LD_VAR 0 4
141265: PPUSH
141266: CALL_OW 311
141270: PPUSH
141271: CALL_OW 121
// end ;
141275: GO 141187
141277: POP
141278: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
141279: LD_VAR 0 2
141283: PPUSH
141284: LD_INT 95
141286: PUSH
141287: LD_EXP 126
141291: PUSH
141292: LD_VAR 0 1
141296: ARRAY
141297: PUSH
141298: EMPTY
141299: LIST
141300: LIST
141301: PPUSH
141302: CALL_OW 72
141306: PUSH
141307: LD_VAR 0 2
141311: EQUAL
141312: PUSH
141313: LD_EXP 125
141317: PUSH
141318: LD_VAR 0 1
141322: ARRAY
141323: OR
141324: PUSH
141325: LD_EXP 102
141329: PUSH
141330: LD_VAR 0 1
141334: ARRAY
141335: NOT
141336: OR
141337: IFFALSE 141107
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
141339: LD_ADDR_EXP 124
141343: PUSH
141344: LD_EXP 124
141348: PPUSH
141349: LD_VAR 0 1
141353: PPUSH
141354: LD_VAR 0 2
141358: PPUSH
141359: LD_INT 21
141361: PUSH
141362: LD_INT 2
141364: PUSH
141365: EMPTY
141366: LIST
141367: LIST
141368: PPUSH
141369: CALL_OW 72
141373: PPUSH
141374: CALL_OW 1
141378: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
141379: LD_VAR 0 1
141383: PPUSH
141384: LD_INT 19
141386: PPUSH
141387: CALL 43733 0 2
// MC_Reset ( base , 20 ) ;
141391: LD_VAR 0 1
141395: PPUSH
141396: LD_INT 20
141398: PPUSH
141399: CALL 43733 0 2
// end ; end_of_file
141403: LD_VAR 0 3
141407: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
141408: LD_VAR 0 1
141412: PUSH
141413: LD_INT 200
141415: DOUBLE
141416: GREATEREQUAL
141417: IFFALSE 141425
141419: LD_INT 299
141421: DOUBLE
141422: LESSEQUAL
141423: IFTRUE 141427
141425: GO 141459
141427: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
141428: LD_VAR 0 1
141432: PPUSH
141433: LD_VAR 0 2
141437: PPUSH
141438: LD_VAR 0 3
141442: PPUSH
141443: LD_VAR 0 4
141447: PPUSH
141448: LD_VAR 0 5
141452: PPUSH
141453: CALL 129408 0 5
141457: GO 141536
141459: LD_INT 300
141461: DOUBLE
141462: GREATEREQUAL
141463: IFFALSE 141471
141465: LD_INT 399
141467: DOUBLE
141468: LESSEQUAL
141469: IFTRUE 141473
141471: GO 141535
141473: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
141474: LD_VAR 0 1
141478: PPUSH
141479: LD_VAR 0 2
141483: PPUSH
141484: LD_VAR 0 3
141488: PPUSH
141489: LD_VAR 0 4
141493: PPUSH
141494: LD_VAR 0 5
141498: PPUSH
141499: LD_VAR 0 6
141503: PPUSH
141504: LD_VAR 0 7
141508: PPUSH
141509: LD_VAR 0 8
141513: PPUSH
141514: LD_VAR 0 9
141518: PPUSH
141519: LD_VAR 0 10
141523: PPUSH
141524: LD_VAR 0 11
141528: PPUSH
141529: CALL 125567 0 11
141533: GO 141536
141535: POP
// end ;
141536: PPOPN 11
141538: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
141539: LD_VAR 0 1
141543: PPUSH
141544: LD_VAR 0 2
141548: PPUSH
141549: LD_VAR 0 3
141553: PPUSH
141554: LD_VAR 0 4
141558: PPUSH
141559: LD_VAR 0 5
141563: PPUSH
141564: CALL 128916 0 5
// end ; end_of_file
141568: PPOPN 5
141570: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
141571: LD_VAR 0 1
141575: PPUSH
141576: LD_VAR 0 2
141580: PPUSH
141581: LD_VAR 0 3
141585: PPUSH
141586: LD_VAR 0 4
141590: PPUSH
141591: LD_VAR 0 5
141595: PPUSH
141596: LD_VAR 0 6
141600: PPUSH
141601: CALL 113219 0 6
// end ;
141605: PPOPN 6
141607: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
141608: LD_INT 0
141610: PPUSH
// begin if not units then
141611: LD_VAR 0 1
141615: NOT
141616: IFFALSE 141620
// exit ;
141618: GO 141620
// end ;
141620: PPOPN 7
141622: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
141623: CALL 113106 0 0
// end ;
141627: PPOPN 1
141629: END
