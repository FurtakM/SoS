// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 38962 0 0
// InitNature ;
  19: CALL 38830 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 12667 0 0
// PrepareRussian ;
  40: CALL 7543 0 0
// PrepareLegion ;
  44: CALL 4619 0 0
// PreparePowell ;
  48: CALL 3153 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 17597 0 0
// MC_Start ( ) ;
  60: CALL 41142 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 126
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 127
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 63938 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 64031 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 63381 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 3
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 3
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 63196 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 63938 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 64031 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 63196 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 63381 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 63811 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 62859 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 63938 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 64031 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 131
 971: PUSH
 972: LD_EXP 131
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 63196 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 63938 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 64031 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 63088 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 64349 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 63520 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 63811 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 63811 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 64143 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 63196 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 63762 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker , Mike , DeltaDoctor ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 69670 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1900
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 74510 0 5
1898: GO 1959
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1900: LD_EXP 4
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 1
1911: ARRAY
1912: PPUSH
1913: LD_EXP 4
1917: PUSH
1918: LD_INT 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_EXP 4
1930: PUSH
1931: LD_INT 3
1933: ARRAY
1934: PUSH
1935: LD_INT 1
1937: ARRAY
1938: PPUSH
1939: LD_EXP 4
1943: PUSH
1944: LD_INT 4
1946: ARRAY
1947: PUSH
1948: LD_INT 1
1950: ARRAY
1951: PPUSH
1952: LD_INT 30
1954: PPUSH
1955: CALL 74510 0 5
// JMMNewVeh := CreateVehicle ;
1959: LD_ADDR_EXP 59
1963: PUSH
1964: CALL_OW 45
1968: ST_TO_ADDR
// if not JMMNewVeh then
1969: LD_EXP 59
1973: NOT
1974: IFFALSE 2005
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1976: LD_INT 5
1978: PPUSH
1979: LD_INT 3
1981: PPUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 9
1987: PPUSH
1988: LD_INT 100
1990: PPUSH
1991: CALL 74510 0 5
// JMMNewVeh := CreateVehicle ;
1995: LD_ADDR_EXP 59
1999: PUSH
2000: CALL_OW 45
2004: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2005: LD_EXP 59
2009: PPUSH
2010: LD_INT 4
2012: PPUSH
2013: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2017: LD_EXP 59
2021: PPUSH
2022: LD_INT 79
2024: PPUSH
2025: LD_INT 91
2027: PPUSH
2028: LD_INT 0
2030: PPUSH
2031: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2035: LD_EXP 40
2039: PPUSH
2040: LD_EXP 59
2044: PPUSH
2045: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2049: LD_EXP 6
2053: PUSH
2054: LD_EXP 2
2058: NOT
2059: AND
2060: IFFALSE 2318
// begin if not JMMGirlVeh then
2062: LD_EXP 5
2066: NOT
2067: IFFALSE 2090
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2069: LD_INT 3
2071: PPUSH
2072: LD_INT 3
2074: PPUSH
2075: LD_INT 1
2077: PPUSH
2078: LD_INT 9
2080: PPUSH
2081: LD_INT 100
2083: PPUSH
2084: CALL 74510 0 5
2088: GO 2149
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2090: LD_EXP 5
2094: PUSH
2095: LD_INT 1
2097: ARRAY
2098: PUSH
2099: LD_INT 1
2101: ARRAY
2102: PPUSH
2103: LD_EXP 5
2107: PUSH
2108: LD_INT 2
2110: ARRAY
2111: PUSH
2112: LD_INT 1
2114: ARRAY
2115: PPUSH
2116: LD_EXP 5
2120: PUSH
2121: LD_INT 3
2123: ARRAY
2124: PUSH
2125: LD_INT 1
2127: ARRAY
2128: PPUSH
2129: LD_EXP 5
2133: PUSH
2134: LD_INT 4
2136: ARRAY
2137: PUSH
2138: LD_INT 1
2140: ARRAY
2141: PPUSH
2142: LD_INT 30
2144: PPUSH
2145: CALL 74510 0 5
// GirlNewVeh := CreateVehicle ;
2149: LD_ADDR_EXP 60
2153: PUSH
2154: CALL_OW 45
2158: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2159: LD_EXP 60
2163: PPUSH
2164: LD_INT 4
2166: PPUSH
2167: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2171: LD_EXP 60
2175: PPUSH
2176: LD_INT 82
2178: PPUSH
2179: LD_INT 96
2181: PPUSH
2182: LD_INT 0
2184: PPUSH
2185: CALL_OW 48
// if JMMGirl = 1 then
2189: LD_EXP 7
2193: PUSH
2194: LD_INT 1
2196: EQUAL
2197: IFFALSE 2232
// begin Joan := PrepareUnit ( Joan , true , 14_ ) ;
2199: LD_ADDR_EXP 41
2203: PUSH
2204: LD_STRING Joan
2206: PPUSH
2207: LD_INT 1
2209: PPUSH
2210: LD_STRING 14_
2212: PPUSH
2213: CALL 69670 0 3
2217: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2218: LD_EXP 41
2222: PPUSH
2223: LD_EXP 60
2227: PPUSH
2228: CALL_OW 52
// end ; if JMMGirl = 2 then
2232: LD_EXP 7
2236: PUSH
2237: LD_INT 2
2239: EQUAL
2240: IFFALSE 2275
// begin Lisa := PrepareUnit ( Lisa , true , 14_ ) ;
2242: LD_ADDR_EXP 43
2246: PUSH
2247: LD_STRING Lisa
2249: PPUSH
2250: LD_INT 1
2252: PPUSH
2253: LD_STRING 14_
2255: PPUSH
2256: CALL 69670 0 3
2260: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2261: LD_EXP 43
2265: PPUSH
2266: LD_EXP 60
2270: PPUSH
2271: CALL_OW 52
// end ; if JMMGirl = 3 then
2275: LD_EXP 7
2279: PUSH
2280: LD_INT 3
2282: EQUAL
2283: IFFALSE 2318
// begin Connie := PrepareUnit ( Connie , true , 14_ ) ;
2285: LD_ADDR_EXP 55
2289: PUSH
2290: LD_STRING Connie
2292: PPUSH
2293: LD_INT 1
2295: PPUSH
2296: LD_STRING 14_
2298: PPUSH
2299: CALL 69670 0 3
2303: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2304: LD_EXP 55
2308: PPUSH
2309: LD_EXP 60
2313: PPUSH
2314: CALL_OW 52
// end ; end ; end ;
2318: LD_VAR 0 1
2322: RET
// export function PrepareStevensSquad ; var tmp ; begin
2323: LD_INT 0
2325: PPUSH
2326: PPUSH
// uc_side := 1 ;
2327: LD_ADDR_OWVAR 20
2331: PUSH
2332: LD_INT 1
2334: ST_TO_ADDR
// uc_nation := 1 ;
2335: LD_ADDR_OWVAR 21
2339: PUSH
2340: LD_INT 1
2342: ST_TO_ADDR
// tmp := [ ] ;
2343: LD_ADDR_VAR 0 2
2347: PUSH
2348: EMPTY
2349: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2350: LD_ADDR_EXP 42
2354: PUSH
2355: LD_STRING Stevens
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13f_
2366: PPUSH
2367: CALL 69670 0 3
2371: ST_TO_ADDR
// if not Stevens then
2372: LD_EXP 42
2376: NOT
2377: IFFALSE 2491
// begin hc_name = Baker Smith ;
2379: LD_ADDR_OWVAR 26
2383: PUSH
2384: LD_STRING Baker Smith
2386: ST_TO_ADDR
// hc_gallery = us ;
2387: LD_ADDR_OWVAR 33
2391: PUSH
2392: LD_STRING us
2394: ST_TO_ADDR
// hc_face_number := 29 ;
2395: LD_ADDR_OWVAR 34
2399: PUSH
2400: LD_INT 29
2402: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2403: LD_INT 1
2405: PPUSH
2406: LD_INT 10
2408: PPUSH
2409: CALL_OW 384
// hc_basic_skills := [ 2 , 2 , 0 , 2 ] ;
2413: LD_ADDR_OWVAR 30
2417: PUSH
2418: LD_INT 2
2420: PUSH
2421: LD_INT 2
2423: PUSH
2424: LD_INT 0
2426: PUSH
2427: LD_INT 2
2429: PUSH
2430: EMPTY
2431: LIST
2432: LIST
2433: LIST
2434: LIST
2435: ST_TO_ADDR
// hc_skills := [ 4 , 5 , 2 , 10 ] ;
2436: LD_ADDR_OWVAR 31
2440: PUSH
2441: LD_INT 4
2443: PUSH
2444: LD_INT 5
2446: PUSH
2447: LD_INT 2
2449: PUSH
2450: LD_INT 10
2452: PUSH
2453: EMPTY
2454: LIST
2455: LIST
2456: LIST
2457: LIST
2458: ST_TO_ADDR
// Baker := CreateHuman ;
2459: LD_ADDR_EXP 56
2463: PUSH
2464: CALL_OW 44
2468: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2469: LD_ADDR_VAR 0 2
2473: PUSH
2474: LD_VAR 0 2
2478: PUSH
2479: LD_EXP 56
2483: ADD
2484: ST_TO_ADDR
// InitHc ;
2485: CALL_OW 19
// end else
2489: GO 2507
// tmp := tmp ^ Stevens ;
2491: LD_ADDR_VAR 0 2
2495: PUSH
2496: LD_VAR 0 2
2500: PUSH
2501: LD_EXP 42
2505: ADD
2506: ST_TO_ADDR
// if not Lisa then
2507: LD_EXP 43
2511: NOT
2512: IFFALSE 2558
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2514: LD_ADDR_EXP 43
2518: PUSH
2519: LD_STRING Lisa
2521: PPUSH
2522: LD_EXP 1
2526: NOT
2527: PPUSH
2528: LD_STRING 13f_
2530: PPUSH
2531: CALL 69670 0 3
2535: ST_TO_ADDR
// if Lisa then
2536: LD_EXP 43
2540: IFFALSE 2558
// tmp := tmp ^ Lisa ;
2542: LD_ADDR_VAR 0 2
2546: PUSH
2547: LD_VAR 0 2
2551: PUSH
2552: LD_EXP 43
2556: ADD
2557: ST_TO_ADDR
// end ; if not Donaldson then
2558: LD_EXP 44
2562: NOT
2563: IFFALSE 2609
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2565: LD_ADDR_EXP 44
2569: PUSH
2570: LD_STRING Donaldson
2572: PPUSH
2573: LD_EXP 1
2577: NOT
2578: PPUSH
2579: LD_STRING 13f_
2581: PPUSH
2582: CALL 69670 0 3
2586: ST_TO_ADDR
// if Donaldson then
2587: LD_EXP 44
2591: IFFALSE 2609
// tmp := tmp ^ Donaldson ;
2593: LD_ADDR_VAR 0 2
2597: PUSH
2598: LD_VAR 0 2
2602: PUSH
2603: LD_EXP 44
2607: ADD
2608: ST_TO_ADDR
// end ; if not Bobby then
2609: LD_EXP 45
2613: NOT
2614: IFFALSE 2660
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2616: LD_ADDR_EXP 45
2620: PUSH
2621: LD_STRING Bobby
2623: PPUSH
2624: LD_EXP 1
2628: NOT
2629: PPUSH
2630: LD_STRING 13f_
2632: PPUSH
2633: CALL 69670 0 3
2637: ST_TO_ADDR
// if Bobby then
2638: LD_EXP 45
2642: IFFALSE 2660
// tmp := tmp ^ Bobby ;
2644: LD_ADDR_VAR 0 2
2648: PUSH
2649: LD_VAR 0 2
2653: PUSH
2654: LD_EXP 45
2658: ADD
2659: ST_TO_ADDR
// end ; if not Cyrus then
2660: LD_EXP 46
2664: NOT
2665: IFFALSE 2711
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2667: LD_ADDR_EXP 46
2671: PUSH
2672: LD_STRING Cyrus
2674: PPUSH
2675: LD_EXP 1
2679: NOT
2680: PPUSH
2681: LD_STRING 13f_
2683: PPUSH
2684: CALL 69670 0 3
2688: ST_TO_ADDR
// if Cyrus then
2689: LD_EXP 46
2693: IFFALSE 2711
// tmp := tmp ^ Cyrus ;
2695: LD_ADDR_VAR 0 2
2699: PUSH
2700: LD_VAR 0 2
2704: PUSH
2705: LD_EXP 46
2709: ADD
2710: ST_TO_ADDR
// end ; if not Brown then
2711: LD_EXP 48
2715: NOT
2716: IFFALSE 2762
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2718: LD_ADDR_EXP 48
2722: PUSH
2723: LD_STRING Brown
2725: PPUSH
2726: LD_EXP 1
2730: NOT
2731: PPUSH
2732: LD_STRING 13f_
2734: PPUSH
2735: CALL 69670 0 3
2739: ST_TO_ADDR
// if Brown then
2740: LD_EXP 48
2744: IFFALSE 2762
// tmp := tmp ^ Brown ;
2746: LD_ADDR_VAR 0 2
2750: PUSH
2751: LD_VAR 0 2
2755: PUSH
2756: LD_EXP 48
2760: ADD
2761: ST_TO_ADDR
// end ; if not Gladstone then
2762: LD_EXP 49
2766: NOT
2767: IFFALSE 2813
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2769: LD_ADDR_EXP 49
2773: PUSH
2774: LD_STRING Gladstone
2776: PPUSH
2777: LD_EXP 1
2781: NOT
2782: PPUSH
2783: LD_STRING 13f_
2785: PPUSH
2786: CALL 69670 0 3
2790: ST_TO_ADDR
// if Gladstone then
2791: LD_EXP 49
2795: IFFALSE 2813
// tmp := tmp ^ Gladstone ;
2797: LD_ADDR_VAR 0 2
2801: PUSH
2802: LD_VAR 0 2
2806: PUSH
2807: LD_EXP 49
2811: ADD
2812: ST_TO_ADDR
// end ; if not Houten then
2813: LD_EXP 50
2817: NOT
2818: IFFALSE 2864
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2820: LD_ADDR_EXP 50
2824: PUSH
2825: LD_STRING Houten
2827: PPUSH
2828: LD_EXP 1
2832: NOT
2833: PPUSH
2834: LD_STRING 13f_
2836: PPUSH
2837: CALL 69670 0 3
2841: ST_TO_ADDR
// if Houten then
2842: LD_EXP 50
2846: IFFALSE 2864
// tmp := tmp ^ Houten ;
2848: LD_ADDR_VAR 0 2
2852: PUSH
2853: LD_VAR 0 2
2857: PUSH
2858: LD_EXP 50
2862: ADD
2863: ST_TO_ADDR
// end ; if not Cornel then
2864: LD_EXP 51
2868: NOT
2869: IFFALSE 2915
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2871: LD_ADDR_EXP 51
2875: PUSH
2876: LD_STRING Cornell
2878: PPUSH
2879: LD_EXP 1
2883: NOT
2884: PPUSH
2885: LD_STRING 13f_
2887: PPUSH
2888: CALL 69670 0 3
2892: ST_TO_ADDR
// if Cornel then
2893: LD_EXP 51
2897: IFFALSE 2915
// tmp := tmp ^ Cornel ;
2899: LD_ADDR_VAR 0 2
2903: PUSH
2904: LD_VAR 0 2
2908: PUSH
2909: LD_EXP 51
2913: ADD
2914: ST_TO_ADDR
// end ; if not Gary then
2915: LD_EXP 52
2919: NOT
2920: IFFALSE 2966
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2922: LD_ADDR_EXP 52
2926: PUSH
2927: LD_STRING Gary
2929: PPUSH
2930: LD_EXP 1
2934: NOT
2935: PPUSH
2936: LD_STRING 13f_
2938: PPUSH
2939: CALL 69670 0 3
2943: ST_TO_ADDR
// if Gary then
2944: LD_EXP 52
2948: IFFALSE 2966
// tmp := tmp ^ Gary ;
2950: LD_ADDR_VAR 0 2
2954: PUSH
2955: LD_VAR 0 2
2959: PUSH
2960: LD_EXP 52
2964: ADD
2965: ST_TO_ADDR
// end ; if not Frank then
2966: LD_EXP 53
2970: NOT
2971: IFFALSE 3017
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2973: LD_ADDR_EXP 53
2977: PUSH
2978: LD_STRING Frank
2980: PPUSH
2981: LD_EXP 1
2985: NOT
2986: PPUSH
2987: LD_STRING 13f_
2989: PPUSH
2990: CALL 69670 0 3
2994: ST_TO_ADDR
// if Frank then
2995: LD_EXP 53
2999: IFFALSE 3017
// tmp := tmp ^ Frank ;
3001: LD_ADDR_VAR 0 2
3005: PUSH
3006: LD_VAR 0 2
3010: PUSH
3011: LD_EXP 53
3015: ADD
3016: ST_TO_ADDR
// end ; if not Kikuchi then
3017: LD_EXP 54
3021: NOT
3022: IFFALSE 3068
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
3024: LD_ADDR_EXP 54
3028: PUSH
3029: LD_STRING Kikuchi
3031: PPUSH
3032: LD_EXP 1
3036: NOT
3037: PPUSH
3038: LD_STRING 13f_
3040: PPUSH
3041: CALL 69670 0 3
3045: ST_TO_ADDR
// if Kikuchi then
3046: LD_EXP 54
3050: IFFALSE 3068
// tmp := tmp ^ Kikuchi ;
3052: LD_ADDR_VAR 0 2
3056: PUSH
3057: LD_VAR 0 2
3061: PUSH
3062: LD_EXP 54
3066: ADD
3067: ST_TO_ADDR
// end ; if not DeltaDoctor then
3068: LD_EXP 58
3072: NOT
3073: IFFALSE 3119
// begin DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13f_ ) ;
3075: LD_ADDR_EXP 58
3079: PUSH
3080: LD_STRING DeltaDoctor
3082: PPUSH
3083: LD_EXP 1
3087: NOT
3088: PPUSH
3089: LD_STRING 13f_
3091: PPUSH
3092: CALL 69670 0 3
3096: ST_TO_ADDR
// if Bobby then
3097: LD_EXP 45
3101: IFFALSE 3119
// tmp := tmp ^ DeltaDoctor ;
3103: LD_ADDR_VAR 0 2
3107: PUSH
3108: LD_VAR 0 2
3112: PUSH
3113: LD_EXP 58
3117: ADD
3118: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3119: LD_ADDR_VAR 0 2
3123: PUSH
3124: LD_VAR 0 2
3128: PUSH
3129: LD_STRING 13_other_survivors
3131: PPUSH
3132: CALL_OW 31
3136: UNION
3137: ST_TO_ADDR
// result := tmp ;
3138: LD_ADDR_VAR 0 1
3142: PUSH
3143: LD_VAR 0 2
3147: ST_TO_ADDR
// end ; end_of_file
3148: LD_VAR 0 1
3152: RET
// export Powell ; export vip , extraSquad ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3153: LD_INT 0
3155: PPUSH
3156: PPUSH
3157: PPUSH
3158: PPUSH
3159: PPUSH
3160: PPUSH
3161: PPUSH
3162: PPUSH
3163: PPUSH
3164: PPUSH
// uc_side := 4 ;
3165: LD_ADDR_OWVAR 20
3169: PUSH
3170: LD_INT 4
3172: ST_TO_ADDR
// uc_nation := 1 ;
3173: LD_ADDR_OWVAR 21
3177: PUSH
3178: LD_INT 1
3180: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3181: LD_INT 387
3183: PPUSH
3184: CALL_OW 274
3188: PPUSH
3189: LD_INT 1
3191: PPUSH
3192: LD_INT 3500
3194: PUSH
3195: LD_INT 3000
3197: PUSH
3198: LD_INT 2500
3200: PUSH
3201: LD_INT 2000
3203: PUSH
3204: EMPTY
3205: LIST
3206: LIST
3207: LIST
3208: LIST
3209: PUSH
3210: LD_OWVAR 67
3214: ARRAY
3215: PPUSH
3216: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3220: LD_INT 387
3222: PPUSH
3223: CALL_OW 274
3227: PPUSH
3228: LD_INT 2
3230: PPUSH
3231: LD_INT 400
3233: PPUSH
3234: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3238: LD_INT 387
3240: PPUSH
3241: CALL_OW 274
3245: PPUSH
3246: LD_INT 3
3248: PPUSH
3249: LD_INT 10
3251: PPUSH
3252: CALL_OW 277
// SetBName ( am_depot , sigma ) ;
3256: LD_INT 387
3258: PPUSH
3259: LD_STRING sigma
3261: PPUSH
3262: CALL_OW 500
// Powell := NewCharacter ( Powell ) ;
3266: LD_ADDR_EXP 61
3270: PUSH
3271: LD_STRING Powell
3273: PPUSH
3274: CALL_OW 25
3278: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3279: LD_EXP 61
3283: PPUSH
3284: LD_INT 57
3286: PPUSH
3287: LD_INT 94
3289: PPUSH
3290: LD_INT 0
3292: PPUSH
3293: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3297: LD_EXP 61
3301: PPUSH
3302: LD_INT 58
3304: PPUSH
3305: LD_INT 94
3307: PPUSH
3308: CALL_OW 118
// vip := [ ] ;
3312: LD_ADDR_EXP 62
3316: PUSH
3317: EMPTY
3318: ST_TO_ADDR
// extraSquad := [ ] ;
3319: LD_ADDR_EXP 63
3323: PUSH
3324: EMPTY
3325: ST_TO_ADDR
// tmp := [ ] ;
3326: LD_ADDR_VAR 0 5
3330: PUSH
3331: EMPTY
3332: ST_TO_ADDR
// if JMMGirl <> 2 then
3333: LD_EXP 7
3337: PUSH
3338: LD_INT 2
3340: NONEQUAL
3341: IFFALSE 3365
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3343: LD_ADDR_EXP 43
3347: PUSH
3348: LD_STRING Lisa
3350: PPUSH
3351: LD_EXP 1
3355: NOT
3356: PPUSH
3357: LD_STRING 13s_
3359: PPUSH
3360: CALL 69670 0 3
3364: ST_TO_ADDR
// if Lisa then
3365: LD_EXP 43
3369: IFFALSE 3387
// tmp := tmp ^ Lisa ;
3371: LD_ADDR_VAR 0 5
3375: PUSH
3376: LD_VAR 0 5
3380: PUSH
3381: LD_EXP 43
3385: ADD
3386: ST_TO_ADDR
// if JMMGirl < 3 then
3387: LD_EXP 7
3391: PUSH
3392: LD_INT 3
3394: LESS
3395: IFFALSE 3426
// begin Connie := NewCharacter ( Coonie ) ;
3397: LD_ADDR_EXP 55
3401: PUSH
3402: LD_STRING Coonie
3404: PPUSH
3405: CALL_OW 25
3409: ST_TO_ADDR
// tmp := tmp ^ Connie ;
3410: LD_ADDR_VAR 0 5
3414: PUSH
3415: LD_VAR 0 5
3419: PUSH
3420: LD_EXP 55
3424: ADD
3425: ST_TO_ADDR
// end ; Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3426: LD_ADDR_EXP 44
3430: PUSH
3431: LD_STRING Donaldson
3433: PPUSH
3434: LD_EXP 1
3438: NOT
3439: PPUSH
3440: LD_STRING 13s_
3442: PPUSH
3443: CALL 69670 0 3
3447: ST_TO_ADDR
// if Donaldson then
3448: LD_EXP 44
3452: IFFALSE 3470
// tmp := tmp ^ Donaldson ;
3454: LD_ADDR_VAR 0 5
3458: PUSH
3459: LD_VAR 0 5
3463: PUSH
3464: LD_EXP 44
3468: ADD
3469: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3470: LD_ADDR_EXP 45
3474: PUSH
3475: LD_STRING Bobby
3477: PPUSH
3478: LD_EXP 1
3482: NOT
3483: PPUSH
3484: LD_STRING 13s_
3486: PPUSH
3487: CALL 69670 0 3
3491: ST_TO_ADDR
// if Bobby then
3492: LD_EXP 45
3496: IFFALSE 3514
// tmp := tmp ^ Bobby ;
3498: LD_ADDR_VAR 0 5
3502: PUSH
3503: LD_VAR 0 5
3507: PUSH
3508: LD_EXP 45
3512: ADD
3513: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3514: LD_ADDR_EXP 46
3518: PUSH
3519: LD_STRING Cyrus
3521: PPUSH
3522: LD_EXP 1
3526: NOT
3527: PPUSH
3528: LD_STRING 13s_
3530: PPUSH
3531: CALL 69670 0 3
3535: ST_TO_ADDR
// if Cyrus then
3536: LD_EXP 46
3540: IFFALSE 3558
// tmp := tmp ^ Cyrus ;
3542: LD_ADDR_VAR 0 5
3546: PUSH
3547: LD_VAR 0 5
3551: PUSH
3552: LD_EXP 46
3556: ADD
3557: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3558: LD_ADDR_EXP 47
3562: PUSH
3563: LD_STRING Denis
3565: PPUSH
3566: LD_EXP 1
3570: NOT
3571: PPUSH
3572: LD_STRING 13s_
3574: PPUSH
3575: CALL 69670 0 3
3579: ST_TO_ADDR
// if not Denis then
3580: LD_EXP 47
3584: NOT
3585: IFFALSE 3609
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3587: LD_ADDR_EXP 47
3591: PUSH
3592: LD_STRING Denis
3594: PPUSH
3595: LD_EXP 1
3599: NOT
3600: PPUSH
3601: LD_STRING 13f_
3603: PPUSH
3604: CALL 69670 0 3
3608: ST_TO_ADDR
// if Denis then
3609: LD_EXP 47
3613: IFFALSE 3631
// tmp := tmp ^ Denis ;
3615: LD_ADDR_VAR 0 5
3619: PUSH
3620: LD_VAR 0 5
3624: PUSH
3625: LD_EXP 47
3629: ADD
3630: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3631: LD_ADDR_EXP 48
3635: PUSH
3636: LD_STRING Brown
3638: PPUSH
3639: LD_EXP 1
3643: NOT
3644: PPUSH
3645: LD_STRING 13s_
3647: PPUSH
3648: CALL 69670 0 3
3652: ST_TO_ADDR
// if Brown then
3653: LD_EXP 48
3657: IFFALSE 3675
// tmp := tmp ^ Brown ;
3659: LD_ADDR_VAR 0 5
3663: PUSH
3664: LD_VAR 0 5
3668: PUSH
3669: LD_EXP 48
3673: ADD
3674: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3675: LD_ADDR_EXP 49
3679: PUSH
3680: LD_STRING Gladstone
3682: PPUSH
3683: LD_EXP 1
3687: NOT
3688: PPUSH
3689: LD_STRING 13s_
3691: PPUSH
3692: CALL 69670 0 3
3696: ST_TO_ADDR
// if Gladstone then
3697: LD_EXP 49
3701: IFFALSE 3719
// tmp := tmp ^ Gladstone ;
3703: LD_ADDR_VAR 0 5
3707: PUSH
3708: LD_VAR 0 5
3712: PUSH
3713: LD_EXP 49
3717: ADD
3718: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3719: LD_ADDR_EXP 50
3723: PUSH
3724: LD_STRING Houten
3726: PPUSH
3727: LD_EXP 1
3731: NOT
3732: PPUSH
3733: LD_STRING 13s_
3735: PPUSH
3736: CALL 69670 0 3
3740: ST_TO_ADDR
// if Houten then
3741: LD_EXP 50
3745: IFFALSE 3763
// tmp := tmp ^ Houten ;
3747: LD_ADDR_VAR 0 5
3751: PUSH
3752: LD_VAR 0 5
3756: PUSH
3757: LD_EXP 50
3761: ADD
3762: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3763: LD_ADDR_EXP 51
3767: PUSH
3768: LD_STRING Cornel
3770: PPUSH
3771: LD_EXP 1
3775: NOT
3776: PPUSH
3777: LD_STRING 13s_
3779: PPUSH
3780: CALL 69670 0 3
3784: ST_TO_ADDR
// if Cornel then
3785: LD_EXP 51
3789: IFFALSE 3807
// tmp := tmp ^ Cornel ;
3791: LD_ADDR_VAR 0 5
3795: PUSH
3796: LD_VAR 0 5
3800: PUSH
3801: LD_EXP 51
3805: ADD
3806: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3807: LD_ADDR_EXP 52
3811: PUSH
3812: LD_STRING Gary
3814: PPUSH
3815: LD_EXP 1
3819: NOT
3820: PPUSH
3821: LD_STRING 13s_
3823: PPUSH
3824: CALL 69670 0 3
3828: ST_TO_ADDR
// if Gary then
3829: LD_EXP 52
3833: IFFALSE 3851
// tmp := tmp ^ Gary ;
3835: LD_ADDR_VAR 0 5
3839: PUSH
3840: LD_VAR 0 5
3844: PUSH
3845: LD_EXP 52
3849: ADD
3850: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3851: LD_ADDR_EXP 53
3855: PUSH
3856: LD_STRING Frank
3858: PPUSH
3859: LD_EXP 1
3863: NOT
3864: PPUSH
3865: LD_STRING 13s_
3867: PPUSH
3868: CALL 69670 0 3
3872: ST_TO_ADDR
// if Frank then
3873: LD_EXP 53
3877: IFFALSE 3895
// tmp := tmp ^ Frank ;
3879: LD_ADDR_VAR 0 5
3883: PUSH
3884: LD_VAR 0 5
3888: PUSH
3889: LD_EXP 53
3893: ADD
3894: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3895: LD_ADDR_EXP 54
3899: PUSH
3900: LD_STRING Kikuchi
3902: PPUSH
3903: LD_EXP 1
3907: NOT
3908: PPUSH
3909: LD_STRING 13s_
3911: PPUSH
3912: CALL 69670 0 3
3916: ST_TO_ADDR
// if Kikuchi then
3917: LD_EXP 54
3921: IFFALSE 3939
// tmp := tmp ^ Kikuchi ;
3923: LD_ADDR_VAR 0 5
3927: PUSH
3928: LD_VAR 0 5
3932: PUSH
3933: LD_EXP 54
3937: ADD
3938: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13s_ ) ;
3939: LD_ADDR_EXP 58
3943: PUSH
3944: LD_STRING DeltaDoctor
3946: PPUSH
3947: LD_EXP 1
3951: NOT
3952: PPUSH
3953: LD_STRING 13s_
3955: PPUSH
3956: CALL 69670 0 3
3960: ST_TO_ADDR
// if DeltaDoctor then
3961: LD_EXP 58
3965: IFFALSE 3983
// tmp := tmp ^ DeltaDoctor ;
3967: LD_ADDR_VAR 0 5
3971: PUSH
3972: LD_VAR 0 5
3976: PUSH
3977: LD_EXP 58
3981: ADD
3982: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 10c_ ) ;
3983: LD_ADDR_EXP 57
3987: PUSH
3988: LD_STRING Mike
3990: PPUSH
3991: LD_EXP 1
3995: NOT
3996: PPUSH
3997: LD_STRING 10c_
3999: PPUSH
4000: CALL 69670 0 3
4004: ST_TO_ADDR
// if Mike then
4005: LD_EXP 57
4009: IFFALSE 4032
// PlaceUnitXYR ( Mike , 61 , 89 , 8 , false ) ;
4011: LD_EXP 57
4015: PPUSH
4016: LD_INT 61
4018: PPUSH
4019: LD_INT 89
4021: PPUSH
4022: LD_INT 8
4024: PPUSH
4025: LD_INT 0
4027: PPUSH
4028: CALL_OW 50
// vip := tmp ;
4032: LD_ADDR_EXP 62
4036: PUSH
4037: LD_VAR 0 5
4041: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
4042: LD_ADDR_VAR 0 5
4046: PUSH
4047: LD_VAR 0 5
4051: PUSH
4052: LD_STRING 13s_others
4054: PPUSH
4055: CALL_OW 31
4059: UNION
4060: ST_TO_ADDR
// if tmp < 18 then
4061: LD_VAR 0 5
4065: PUSH
4066: LD_INT 18
4068: LESS
4069: IFFALSE 4174
// begin InitHC_All ( ) ;
4071: CALL_OW 584
// for i = 1 to 18 - tmp do
4075: LD_ADDR_VAR 0 2
4079: PUSH
4080: DOUBLE
4081: LD_INT 1
4083: DEC
4084: ST_TO_ADDR
4085: LD_INT 18
4087: PUSH
4088: LD_VAR 0 5
4092: MINUS
4093: PUSH
4094: FOR_TO
4095: IFFALSE 4172
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
4097: LD_INT 1
4099: PPUSH
4100: LD_VAR 0 2
4104: PUSH
4105: LD_INT 4
4107: MOD
4108: PUSH
4109: LD_INT 1
4111: PLUS
4112: PPUSH
4113: LD_INT 4
4115: PPUSH
4116: CALL_OW 380
// un := CreateHuman ;
4120: LD_ADDR_VAR 0 10
4124: PUSH
4125: CALL_OW 44
4129: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
4130: LD_ADDR_VAR 0 5
4134: PUSH
4135: LD_VAR 0 5
4139: PPUSH
4140: LD_VAR 0 10
4144: PPUSH
4145: CALL 107361 0 2
4149: ST_TO_ADDR
// extraSquad := Join ( extraSquad , un ) ;
4150: LD_ADDR_EXP 63
4154: PUSH
4155: LD_EXP 63
4159: PPUSH
4160: LD_VAR 0 10
4164: PPUSH
4165: CALL 107361 0 2
4169: ST_TO_ADDR
// end ;
4170: GO 4094
4172: POP
4173: POP
// end ; depot := HexInfo ( 53 , 94 ) ;
4174: LD_ADDR_VAR 0 6
4178: PUSH
4179: LD_INT 53
4181: PPUSH
4182: LD_INT 94
4184: PPUSH
4185: CALL_OW 428
4189: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
4190: LD_ADDR_VAR 0 7
4194: PUSH
4195: LD_INT 56
4197: PPUSH
4198: LD_INT 101
4200: PPUSH
4201: CALL_OW 428
4205: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
4206: LD_ADDR_VAR 0 8
4210: PUSH
4211: LD_INT 67
4213: PPUSH
4214: LD_INT 101
4216: PPUSH
4217: CALL_OW 428
4221: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
4222: LD_ADDR_VAR 0 9
4226: PUSH
4227: LD_INT 54
4229: PPUSH
4230: LD_INT 85
4232: PPUSH
4233: CALL_OW 428
4237: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
4238: LD_ADDR_VAR 0 3
4242: PUSH
4243: LD_VAR 0 8
4247: PUSH
4248: LD_VAR 0 6
4252: PUSH
4253: LD_VAR 0 9
4257: PUSH
4258: LD_VAR 0 7
4262: PUSH
4263: EMPTY
4264: LIST
4265: LIST
4266: LIST
4267: LIST
4268: ST_TO_ADDR
// for i in tmp do
4269: LD_ADDR_VAR 0 2
4273: PUSH
4274: LD_VAR 0 5
4278: PUSH
4279: FOR_IN
4280: IFFALSE 4475
// begin case GetBType ( b [ 1 ] ) of b_armoury :
4282: LD_VAR 0 3
4286: PUSH
4287: LD_INT 1
4289: ARRAY
4290: PPUSH
4291: CALL_OW 266
4295: PUSH
4296: LD_INT 4
4298: DOUBLE
4299: EQUAL
4300: IFTRUE 4304
4302: GO 4319
4304: POP
// SetClass ( i , class_soldier ) ; b_depot :
4305: LD_VAR 0 2
4309: PPUSH
4310: LD_INT 1
4312: PPUSH
4313: CALL_OW 336
4317: GO 4389
4319: LD_INT 0
4321: DOUBLE
4322: EQUAL
4323: IFTRUE 4327
4325: GO 4342
4327: POP
// SetClass ( i , class_engineer ) ; b_workshop :
4328: LD_VAR 0 2
4332: PPUSH
4333: LD_INT 2
4335: PPUSH
4336: CALL_OW 336
4340: GO 4389
4342: LD_INT 2
4344: DOUBLE
4345: EQUAL
4346: IFTRUE 4350
4348: GO 4365
4350: POP
// SetClass ( i , class_mechanic ) ; b_lab :
4351: LD_VAR 0 2
4355: PPUSH
4356: LD_INT 3
4358: PPUSH
4359: CALL_OW 336
4363: GO 4389
4365: LD_INT 6
4367: DOUBLE
4368: EQUAL
4369: IFTRUE 4373
4371: GO 4388
4373: POP
// SetClass ( i , class_scientistic ) ; end ;
4374: LD_VAR 0 2
4378: PPUSH
4379: LD_INT 4
4381: PPUSH
4382: CALL_OW 336
4386: GO 4389
4388: POP
// if UnitsInside ( b [ 1 ] ) = 6 then
4389: LD_VAR 0 3
4393: PUSH
4394: LD_INT 1
4396: ARRAY
4397: PPUSH
4398: CALL_OW 313
4402: PUSH
4403: LD_INT 6
4405: EQUAL
4406: IFFALSE 4426
// b := Delete ( b , 1 ) ;
4408: LD_ADDR_VAR 0 3
4412: PUSH
4413: LD_VAR 0 3
4417: PPUSH
4418: LD_INT 1
4420: PPUSH
4421: CALL_OW 3
4425: ST_TO_ADDR
// if b then
4426: LD_VAR 0 3
4430: IFFALSE 4452
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4432: LD_VAR 0 2
4436: PPUSH
4437: LD_VAR 0 3
4441: PUSH
4442: LD_INT 1
4444: ARRAY
4445: PPUSH
4446: CALL_OW 52
4450: GO 4473
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4452: LD_VAR 0 2
4456: PPUSH
4457: LD_INT 61
4459: PPUSH
4460: LD_INT 89
4462: PPUSH
4463: LD_INT 8
4465: PPUSH
4466: LD_INT 0
4468: PPUSH
4469: CALL_OW 50
// end ;
4473: GO 4279
4475: POP
4476: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4477: LD_INT 2
4479: PPUSH
4480: LD_INT 1
4482: PPUSH
4483: LD_INT 1
4485: PPUSH
4486: LD_INT 12
4488: PPUSH
4489: LD_INT 100
4491: PPUSH
4492: CALL 74510 0 5
// veh := CreateVehicle ;
4496: LD_ADDR_VAR 0 4
4500: PUSH
4501: CALL_OW 45
4505: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4506: LD_VAR 0 4
4510: PPUSH
4511: LD_INT 4
4513: PPUSH
4514: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4518: LD_VAR 0 4
4522: PPUSH
4523: LD_INT 49
4525: PPUSH
4526: LD_INT 88
4528: PPUSH
4529: LD_INT 0
4531: PPUSH
4532: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4536: LD_VAR 0 4
4540: PPUSH
4541: LD_INT 1
4543: PPUSH
4544: LD_INT 100
4546: PPUSH
4547: CALL_OW 290
// uc_side := 0 ;
4551: LD_ADDR_OWVAR 20
4555: PUSH
4556: LD_INT 0
4558: ST_TO_ADDR
// uc_nation := 0 ;
4559: LD_ADDR_OWVAR 21
4563: PUSH
4564: LD_INT 0
4566: ST_TO_ADDR
// for i := 1 to 3 do
4567: LD_ADDR_VAR 0 2
4571: PUSH
4572: DOUBLE
4573: LD_INT 1
4575: DEC
4576: ST_TO_ADDR
4577: LD_INT 3
4579: PUSH
4580: FOR_TO
4581: IFFALSE 4612
// begin InitHc ;
4583: CALL_OW 19
// hc_class := class_apeman ;
4587: LD_ADDR_OWVAR 28
4591: PUSH
4592: LD_INT 12
4594: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4595: CALL_OW 44
4599: PPUSH
4600: LD_INT 13
4602: PPUSH
4603: LD_INT 0
4605: PPUSH
4606: CALL_OW 49
// end ;
4610: GO 4580
4612: POP
4613: POP
// end ; end_of_file
4614: LD_VAR 0 1
4618: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4619: LD_INT 0
4621: PPUSH
4622: PPUSH
4623: PPUSH
4624: PPUSH
4625: PPUSH
// side := 8 ;
4626: LD_ADDR_VAR 0 3
4630: PUSH
4631: LD_INT 8
4633: ST_TO_ADDR
// uc_side := side ;
4634: LD_ADDR_OWVAR 20
4638: PUSH
4639: LD_VAR 0 3
4643: ST_TO_ADDR
// uc_nation := 2 ;
4644: LD_ADDR_OWVAR 21
4648: PUSH
4649: LD_INT 2
4651: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4652: LD_ADDR_VAR 0 2
4656: PUSH
4657: LD_INT 22
4659: PUSH
4660: LD_VAR 0 3
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: PUSH
4669: LD_INT 21
4671: PUSH
4672: LD_INT 3
4674: PUSH
4675: EMPTY
4676: LIST
4677: LIST
4678: PUSH
4679: EMPTY
4680: LIST
4681: LIST
4682: PPUSH
4683: CALL_OW 69
4687: PUSH
4688: FOR_IN
4689: IFFALSE 4705
// SetBLevel ( i , 10 ) ;
4691: LD_VAR 0 2
4695: PPUSH
4696: LD_INT 10
4698: PPUSH
4699: CALL_OW 241
4703: GO 4688
4705: POP
4706: POP
// if KurtStatus then
4707: LD_EXP 3
4711: IFFALSE 4734
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4713: LD_ADDR_EXP 64
4717: PUSH
4718: LD_STRING Kurt
4720: PPUSH
4721: LD_INT 0
4723: PPUSH
4724: LD_STRING 
4726: PPUSH
4727: CALL 69670 0 3
4731: ST_TO_ADDR
4732: GO 4756
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4734: LD_ADDR_EXP 64
4738: PUSH
4739: LD_STRING AltKurt
4741: PPUSH
4742: LD_EXP 1
4746: NOT
4747: PPUSH
4748: LD_STRING 
4750: PPUSH
4751: CALL 69670 0 3
4755: ST_TO_ADDR
// if not Kurt then
4756: LD_EXP 64
4760: NOT
4761: IFFALSE 4787
// begin InitHc ;
4763: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4767: LD_INT 1
4769: PPUSH
4770: LD_INT 10
4772: PPUSH
4773: CALL_OW 381
// Kurt := CreateHuman ;
4777: LD_ADDR_EXP 64
4781: PUSH
4782: CALL_OW 44
4786: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4787: LD_EXP 64
4791: PPUSH
4792: LD_INT 324
4794: PPUSH
4795: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4799: LD_ADDR_EXP 65
4803: PUSH
4804: LD_STRING Kozlov
4806: PPUSH
4807: LD_INT 0
4809: PPUSH
4810: LD_STRING 
4812: PPUSH
4813: CALL 69670 0 3
4817: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4818: LD_EXP 65
4822: PPUSH
4823: LD_INT 22
4825: PUSH
4826: LD_INT 8
4828: PUSH
4829: EMPTY
4830: LIST
4831: LIST
4832: PUSH
4833: LD_INT 23
4835: PUSH
4836: LD_INT 3
4838: PUSH
4839: EMPTY
4840: LIST
4841: LIST
4842: PUSH
4843: LD_INT 30
4845: PUSH
4846: LD_INT 8
4848: PUSH
4849: EMPTY
4850: LIST
4851: LIST
4852: PUSH
4853: EMPTY
4854: LIST
4855: LIST
4856: LIST
4857: PPUSH
4858: CALL_OW 69
4862: PUSH
4863: LD_INT 1
4865: ARRAY
4866: PPUSH
4867: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4871: LD_EXP 65
4875: PPUSH
4876: LD_INT 3
4878: PPUSH
4879: LD_INT 10
4881: PPUSH
4882: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4886: LD_EXP 65
4890: PPUSH
4891: LD_INT 4
4893: PPUSH
4894: LD_INT 10
4896: PPUSH
4897: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4901: LD_ADDR_VAR 0 5
4905: PUSH
4906: LD_INT 22
4908: PUSH
4909: LD_VAR 0 3
4913: PUSH
4914: EMPTY
4915: LIST
4916: LIST
4917: PUSH
4918: LD_INT 30
4920: PUSH
4921: LD_INT 32
4923: PUSH
4924: EMPTY
4925: LIST
4926: LIST
4927: PUSH
4928: LD_INT 58
4930: PUSH
4931: EMPTY
4932: LIST
4933: PUSH
4934: EMPTY
4935: LIST
4936: LIST
4937: LIST
4938: PPUSH
4939: CALL_OW 69
4943: ST_TO_ADDR
// for i = 1 to 10 do
4944: LD_ADDR_VAR 0 2
4948: PUSH
4949: DOUBLE
4950: LD_INT 1
4952: DEC
4953: ST_TO_ADDR
4954: LD_INT 10
4956: PUSH
4957: FOR_TO
4958: IFFALSE 5030
// begin uc_nation := nation_nature ;
4960: LD_ADDR_OWVAR 21
4964: PUSH
4965: LD_INT 0
4967: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4968: LD_ADDR_OWVAR 28
4972: PUSH
4973: LD_INT 15
4975: ST_TO_ADDR
// hc_gallery :=  ;
4976: LD_ADDR_OWVAR 33
4980: PUSH
4981: LD_STRING 
4983: ST_TO_ADDR
// hc_name :=  ;
4984: LD_ADDR_OWVAR 26
4988: PUSH
4989: LD_STRING 
4991: ST_TO_ADDR
// un := CreateHuman ;
4992: LD_ADDR_VAR 0 4
4996: PUSH
4997: CALL_OW 44
5001: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
5002: LD_VAR 0 4
5006: PPUSH
5007: LD_VAR 0 5
5011: PUSH
5012: LD_VAR 0 5
5016: PUSH
5017: LD_VAR 0 2
5021: MINUS
5022: ARRAY
5023: PPUSH
5024: CALL_OW 52
// end ;
5028: GO 4957
5030: POP
5031: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
5032: LD_ADDR_VAR 0 5
5036: PUSH
5037: LD_STRING 12_kurt_squad
5039: PPUSH
5040: CALL_OW 31
5044: ST_TO_ADDR
// if tmp then
5045: LD_VAR 0 5
5049: IFFALSE 5083
// for i in tmp do
5051: LD_ADDR_VAR 0 2
5055: PUSH
5056: LD_VAR 0 5
5060: PUSH
5061: FOR_IN
5062: IFFALSE 5081
// PlaceUnitArea ( i , legionBaseArea , false ) ;
5064: LD_VAR 0 2
5068: PPUSH
5069: LD_INT 5
5071: PPUSH
5072: LD_INT 0
5074: PPUSH
5075: CALL_OW 49
5079: GO 5061
5081: POP
5082: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
5083: LD_INT 324
5085: PPUSH
5086: LD_INT 5
5088: PPUSH
5089: LD_STRING 
5091: PPUSH
5092: LD_INT 8
5094: PUSH
5095: LD_INT 9
5097: PUSH
5098: LD_INT 10
5100: PUSH
5101: LD_INT 10
5103: PUSH
5104: EMPTY
5105: LIST
5106: LIST
5107: LIST
5108: LIST
5109: PUSH
5110: LD_OWVAR 67
5114: ARRAY
5115: PPUSH
5116: LD_INT 3000
5118: PUSH
5119: LD_INT 500
5121: PUSH
5122: LD_INT 150
5124: PUSH
5125: EMPTY
5126: LIST
5127: LIST
5128: LIST
5129: PPUSH
5130: LD_INT 16
5132: PUSH
5133: LD_INT 6
5135: PUSH
5136: LD_INT 6
5138: PUSH
5139: LD_INT 8
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: LIST
5146: LIST
5147: PPUSH
5148: CALL 78331 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
5152: LD_ADDR_EXP 102
5156: PUSH
5157: LD_EXP 102
5161: PPUSH
5162: LD_INT 3
5164: PPUSH
5165: LD_INT 22
5167: PUSH
5168: LD_VAR 0 3
5172: PUSH
5173: EMPTY
5174: LIST
5175: LIST
5176: PUSH
5177: LD_INT 23
5179: PUSH
5180: LD_INT 2
5182: PUSH
5183: EMPTY
5184: LIST
5185: LIST
5186: PUSH
5187: LD_INT 3
5189: PUSH
5190: LD_INT 21
5192: PUSH
5193: LD_INT 2
5195: PUSH
5196: EMPTY
5197: LIST
5198: LIST
5199: PUSH
5200: EMPTY
5201: LIST
5202: LIST
5203: PUSH
5204: EMPTY
5205: LIST
5206: LIST
5207: LIST
5208: PPUSH
5209: CALL_OW 69
5213: PUSH
5214: LD_EXP 64
5218: DIFF
5219: PPUSH
5220: CALL_OW 1
5224: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
5225: LD_INT 1
5227: PPUSH
5228: LD_INT 7
5230: PPUSH
5231: CALL_OW 383
// hc_name := Ali Hadrach ;
5235: LD_ADDR_OWVAR 26
5239: PUSH
5240: LD_STRING Ali Hadrach
5242: ST_TO_ADDR
// hc_face_number := 31 ;
5243: LD_ADDR_OWVAR 34
5247: PUSH
5248: LD_INT 31
5250: ST_TO_ADDR
// Friend := CreateHuman ;
5251: LD_ADDR_EXP 66
5255: PUSH
5256: CALL_OW 44
5260: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
5261: LD_INT 14
5263: PPUSH
5264: LD_INT 3
5266: PPUSH
5267: LD_INT 1
5269: PPUSH
5270: LD_INT 29
5272: PPUSH
5273: LD_INT 100
5275: PPUSH
5276: CALL 74510 0 5
// powellBomb := CreateVehicle ;
5280: LD_ADDR_EXP 67
5284: PUSH
5285: CALL_OW 45
5289: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
5290: LD_EXP 67
5294: PPUSH
5295: LD_INT 90
5297: PPUSH
5298: LD_INT 51
5300: PPUSH
5301: LD_INT 0
5303: PPUSH
5304: CALL_OW 48
// end ;
5308: LD_VAR 0 1
5312: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
5313: LD_INT 0
5315: PPUSH
5316: PPUSH
5317: PPUSH
// if IsLive ( kozlov_fac ) then
5318: LD_INT 332
5320: PPUSH
5321: CALL_OW 300
5325: IFFALSE 5329
// exit ;
5327: GO 5896
// ComExitBuilding ( Kozlov ) ;
5329: LD_EXP 65
5333: PPUSH
5334: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
5338: LD_EXP 65
5342: PPUSH
5343: CALL_OW 257
5347: PUSH
5348: LD_INT 2
5350: NONEQUAL
5351: IFFALSE 5386
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
5353: LD_EXP 65
5357: PPUSH
5358: LD_INT 324
5360: PPUSH
5361: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
5365: LD_EXP 65
5369: PPUSH
5370: LD_INT 2
5372: PPUSH
5373: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
5377: LD_EXP 65
5381: PPUSH
5382: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
5386: LD_EXP 65
5390: PPUSH
5391: LD_INT 2
5393: PPUSH
5394: LD_INT 93
5396: PPUSH
5397: LD_INT 32
5399: PPUSH
5400: LD_INT 3
5402: PPUSH
5403: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5407: LD_INT 35
5409: PPUSH
5410: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5414: LD_INT 22
5416: PUSH
5417: LD_INT 8
5419: PUSH
5420: EMPTY
5421: LIST
5422: LIST
5423: PUSH
5424: LD_INT 30
5426: PUSH
5427: LD_INT 3
5429: PUSH
5430: EMPTY
5431: LIST
5432: LIST
5433: PUSH
5434: LD_INT 23
5436: PUSH
5437: LD_INT 3
5439: PUSH
5440: EMPTY
5441: LIST
5442: LIST
5443: PUSH
5444: LD_INT 57
5446: PUSH
5447: EMPTY
5448: LIST
5449: PUSH
5450: EMPTY
5451: LIST
5452: LIST
5453: LIST
5454: LIST
5455: PPUSH
5456: CALL_OW 69
5460: IFFALSE 5407
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5462: LD_ADDR_VAR 0 2
5466: PUSH
5467: LD_INT 22
5469: PUSH
5470: LD_INT 8
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: PUSH
5477: LD_INT 30
5479: PUSH
5480: LD_INT 3
5482: PUSH
5483: EMPTY
5484: LIST
5485: LIST
5486: PUSH
5487: LD_INT 23
5489: PUSH
5490: LD_INT 3
5492: PUSH
5493: EMPTY
5494: LIST
5495: LIST
5496: PUSH
5497: LD_INT 57
5499: PUSH
5500: EMPTY
5501: LIST
5502: PUSH
5503: EMPTY
5504: LIST
5505: LIST
5506: LIST
5507: LIST
5508: PPUSH
5509: CALL_OW 69
5513: PUSH
5514: LD_INT 1
5516: ARRAY
5517: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5518: LD_INT 22
5520: PUSH
5521: LD_INT 8
5523: PUSH
5524: EMPTY
5525: LIST
5526: LIST
5527: PUSH
5528: LD_INT 23
5530: PUSH
5531: LD_INT 3
5533: PUSH
5534: EMPTY
5535: LIST
5536: LIST
5537: PUSH
5538: LD_INT 30
5540: PUSH
5541: LD_INT 21
5543: PUSH
5544: EMPTY
5545: LIST
5546: LIST
5547: PUSH
5548: EMPTY
5549: LIST
5550: LIST
5551: LIST
5552: PPUSH
5553: CALL_OW 69
5557: NOT
5558: IFFALSE 5636
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5560: LD_EXP 65
5564: PPUSH
5565: LD_INT 21
5567: PPUSH
5568: LD_INT 97
5570: PPUSH
5571: LD_INT 36
5573: PPUSH
5574: LD_INT 5
5576: PPUSH
5577: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5581: LD_INT 35
5583: PPUSH
5584: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5588: LD_INT 22
5590: PUSH
5591: LD_INT 8
5593: PUSH
5594: EMPTY
5595: LIST
5596: LIST
5597: PUSH
5598: LD_INT 23
5600: PUSH
5601: LD_INT 3
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: PUSH
5608: LD_INT 30
5610: PUSH
5611: LD_INT 21
5613: PUSH
5614: EMPTY
5615: LIST
5616: LIST
5617: PUSH
5618: LD_INT 57
5620: PUSH
5621: EMPTY
5622: LIST
5623: PUSH
5624: EMPTY
5625: LIST
5626: LIST
5627: LIST
5628: LIST
5629: PPUSH
5630: CALL_OW 69
5634: IFFALSE 5581
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5636: LD_INT 22
5638: PUSH
5639: LD_INT 8
5641: PUSH
5642: EMPTY
5643: LIST
5644: LIST
5645: PUSH
5646: LD_INT 23
5648: PUSH
5649: LD_INT 3
5651: PUSH
5652: EMPTY
5653: LIST
5654: LIST
5655: PUSH
5656: LD_INT 30
5658: PUSH
5659: LD_INT 18
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: PUSH
5666: EMPTY
5667: LIST
5668: LIST
5669: LIST
5670: PPUSH
5671: CALL_OW 69
5675: NOT
5676: IFFALSE 5754
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5678: LD_EXP 65
5682: PPUSH
5683: LD_INT 18
5685: PPUSH
5686: LD_INT 89
5688: PPUSH
5689: LD_INT 32
5691: PPUSH
5692: LD_INT 1
5694: PPUSH
5695: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5699: LD_INT 35
5701: PPUSH
5702: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5706: LD_INT 22
5708: PUSH
5709: LD_INT 8
5711: PUSH
5712: EMPTY
5713: LIST
5714: LIST
5715: PUSH
5716: LD_INT 23
5718: PUSH
5719: LD_INT 3
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: PUSH
5726: LD_INT 30
5728: PUSH
5729: LD_INT 18
5731: PUSH
5732: EMPTY
5733: LIST
5734: LIST
5735: PUSH
5736: LD_INT 57
5738: PUSH
5739: EMPTY
5740: LIST
5741: PUSH
5742: EMPTY
5743: LIST
5744: LIST
5745: LIST
5746: LIST
5747: PPUSH
5748: CALL_OW 69
5752: IFFALSE 5699
// end ; lab := kozlov_lab ;
5754: LD_ADDR_VAR 0 3
5758: PUSH
5759: LD_INT 336
5761: ST_TO_ADDR
// if not lab then
5762: LD_VAR 0 3
5766: NOT
5767: IFFALSE 5771
// exit ;
5769: GO 5896
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5771: LD_EXP 65
5775: PPUSH
5776: LD_VAR 0 3
5780: PUSH
5781: LD_INT 1
5783: ARRAY
5784: PPUSH
5785: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5789: LD_EXP 65
5793: PPUSH
5794: LD_INT 4
5796: PPUSH
5797: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5801: LD_VAR 0 3
5805: PUSH
5806: LD_INT 1
5808: ARRAY
5809: PPUSH
5810: LD_INT 25
5812: PPUSH
5813: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5817: LD_INT 35
5819: PPUSH
5820: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5824: LD_INT 25
5826: PPUSH
5827: LD_INT 8
5829: PPUSH
5830: CALL_OW 321
5834: PUSH
5835: LD_INT 2
5837: EQUAL
5838: IFFALSE 5817
// ComExitBuilding ( Kozlov ) ;
5840: LD_EXP 65
5844: PPUSH
5845: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5849: LD_EXP 65
5853: PPUSH
5854: LD_VAR 0 2
5858: PPUSH
5859: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5863: LD_EXP 65
5867: PPUSH
5868: LD_INT 3
5870: PPUSH
5871: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5875: LD_VAR 0 2
5879: PPUSH
5880: LD_INT 23
5882: PPUSH
5883: LD_INT 3
5885: PPUSH
5886: LD_INT 1
5888: PPUSH
5889: LD_INT 48
5891: PPUSH
5892: CALL_OW 125
// end ;
5896: LD_VAR 0 1
5900: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5901: LD_EXP 22
5905: NOT
5906: PUSH
5907: LD_EXP 15
5911: PUSH
5912: LD_INT 6
5914: GREATEREQUAL
5915: AND
5916: IFFALSE 5997
5918: GO 5920
5920: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5921: LD_INT 3
5923: PPUSH
5924: LD_INT 3
5926: PPUSH
5927: CALL 63381 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5931: LD_INT 3
5933: PPUSH
5934: LD_INT 14
5936: PUSH
5937: LD_INT 1
5939: PUSH
5940: LD_INT 1
5942: PUSH
5943: LD_INT 28
5945: PUSH
5946: EMPTY
5947: LIST
5948: LIST
5949: LIST
5950: LIST
5951: PUSH
5952: LD_INT 14
5954: PUSH
5955: LD_INT 1
5957: PUSH
5958: LD_INT 1
5960: PUSH
5961: LD_INT 28
5963: PUSH
5964: EMPTY
5965: LIST
5966: LIST
5967: LIST
5968: LIST
5969: PUSH
5970: LD_INT 14
5972: PUSH
5973: LD_INT 1
5975: PUSH
5976: LD_INT 1
5978: PUSH
5979: LD_INT 28
5981: PUSH
5982: EMPTY
5983: LIST
5984: LIST
5985: LIST
5986: LIST
5987: PUSH
5988: EMPTY
5989: LIST
5990: LIST
5991: LIST
5992: PPUSH
5993: CALL 63244 0 2
// end ;
5997: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target , p ;
5998: LD_EXP 22
6002: NOT
6003: PUSH
6004: LD_EXP 15
6008: PUSH
6009: LD_INT 6
6011: GREATEREQUAL
6012: AND
6013: PUSH
6014: LD_INT 3
6016: PPUSH
6017: LD_INT 1
6019: PPUSH
6020: CALL 64662 0 2
6024: NOT
6025: AND
6026: IFFALSE 6979
6028: GO 6030
6030: DISABLE
6031: LD_INT 0
6033: PPUSH
6034: PPUSH
6035: PPUSH
6036: PPUSH
// begin enable ;
6037: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
6038: LD_INT 22
6040: PUSH
6041: LD_INT 8
6043: PUSH
6044: EMPTY
6045: LIST
6046: LIST
6047: PUSH
6048: LD_INT 23
6050: PUSH
6051: LD_INT 2
6053: PUSH
6054: EMPTY
6055: LIST
6056: LIST
6057: PUSH
6058: LD_INT 30
6060: PUSH
6061: LD_INT 3
6063: PUSH
6064: EMPTY
6065: LIST
6066: LIST
6067: PUSH
6068: EMPTY
6069: LIST
6070: LIST
6071: LIST
6072: PPUSH
6073: CALL_OW 69
6077: NOT
6078: IFFALSE 6082
// exit ;
6080: GO 6979
// if Prob ( 40 ) then
6082: LD_INT 40
6084: PPUSH
6085: CALL_OW 13
6089: IFFALSE 6216
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6091: LD_INT 3
6093: PPUSH
6094: LD_INT 14
6096: PUSH
6097: LD_INT 1
6099: PUSH
6100: LD_INT 2
6102: PUSH
6103: LD_INT 28
6105: PUSH
6106: EMPTY
6107: LIST
6108: LIST
6109: LIST
6110: LIST
6111: PUSH
6112: LD_INT 14
6114: PUSH
6115: LD_INT 1
6117: PUSH
6118: LD_INT 2
6120: PUSH
6121: LD_INT 28
6123: PUSH
6124: EMPTY
6125: LIST
6126: LIST
6127: LIST
6128: LIST
6129: PUSH
6130: LD_INT 14
6132: PUSH
6133: LD_INT 1
6135: PUSH
6136: LD_INT 2
6138: PUSH
6139: LD_INT 28
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: LIST
6147: PUSH
6148: LD_INT 14
6150: PUSH
6151: LD_INT 1
6153: PUSH
6154: LD_INT 2
6156: PUSH
6157: LD_INT 28
6159: PUSH
6160: EMPTY
6161: LIST
6162: LIST
6163: LIST
6164: LIST
6165: PUSH
6166: LD_INT 14
6168: PUSH
6169: LD_INT 1
6171: PUSH
6172: LD_INT 2
6174: PUSH
6175: LD_INT 28
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: LIST
6182: LIST
6183: PUSH
6184: LD_INT 14
6186: PUSH
6187: LD_INT 1
6189: PUSH
6190: LD_INT 2
6192: PUSH
6193: LD_INT 26
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: LIST
6200: LIST
6201: PUSH
6202: EMPTY
6203: LIST
6204: LIST
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: PPUSH
6210: CALL 63244 0 2
// end else
6214: GO 6423
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6216: LD_INT 3
6218: PPUSH
6219: LD_INT 14
6221: PUSH
6222: LD_INT 1
6224: PUSH
6225: LD_INT 2
6227: PUSH
6228: LD_INT 27
6230: PUSH
6231: LD_INT 26
6233: PUSH
6234: LD_INT 26
6236: PUSH
6237: LD_INT 28
6239: PUSH
6240: EMPTY
6241: LIST
6242: LIST
6243: LIST
6244: LIST
6245: PUSH
6246: LD_OWVAR 67
6250: ARRAY
6251: PUSH
6252: EMPTY
6253: LIST
6254: LIST
6255: LIST
6256: LIST
6257: PUSH
6258: LD_INT 14
6260: PUSH
6261: LD_INT 1
6263: PUSH
6264: LD_INT 2
6266: PUSH
6267: LD_INT 27
6269: PUSH
6270: LD_INT 26
6272: PUSH
6273: LD_INT 26
6275: PUSH
6276: LD_INT 26
6278: PUSH
6279: EMPTY
6280: LIST
6281: LIST
6282: LIST
6283: LIST
6284: PUSH
6285: LD_OWVAR 67
6289: ARRAY
6290: PUSH
6291: EMPTY
6292: LIST
6293: LIST
6294: LIST
6295: LIST
6296: PUSH
6297: LD_INT 14
6299: PUSH
6300: LD_INT 1
6302: PUSH
6303: LD_INT 2
6305: PUSH
6306: LD_INT 26
6308: PUSH
6309: LD_INT 26
6311: PUSH
6312: LD_INT 29
6314: PUSH
6315: LD_INT 29
6317: PUSH
6318: EMPTY
6319: LIST
6320: LIST
6321: LIST
6322: LIST
6323: PUSH
6324: LD_OWVAR 67
6328: ARRAY
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: LIST
6334: LIST
6335: PUSH
6336: LD_INT 13
6338: PUSH
6339: LD_INT 1
6341: PUSH
6342: LD_INT 2
6344: PUSH
6345: LD_INT 26
6347: PUSH
6348: LD_INT 29
6350: PUSH
6351: LD_INT 29
6353: PUSH
6354: LD_INT 29
6356: PUSH
6357: EMPTY
6358: LIST
6359: LIST
6360: LIST
6361: LIST
6362: PUSH
6363: LD_OWVAR 67
6367: ARRAY
6368: PUSH
6369: EMPTY
6370: LIST
6371: LIST
6372: LIST
6373: LIST
6374: PUSH
6375: LD_INT 13
6377: PUSH
6378: LD_INT 1
6380: PUSH
6381: LD_INT 2
6383: PUSH
6384: LD_INT 29
6386: PUSH
6387: EMPTY
6388: LIST
6389: LIST
6390: LIST
6391: LIST
6392: PUSH
6393: LD_INT 14
6395: PUSH
6396: LD_INT 1
6398: PUSH
6399: LD_INT 2
6401: PUSH
6402: LD_INT 26
6404: PUSH
6405: EMPTY
6406: LIST
6407: LIST
6408: LIST
6409: LIST
6410: PUSH
6411: EMPTY
6412: LIST
6413: LIST
6414: LIST
6415: LIST
6416: LIST
6417: LIST
6418: PPUSH
6419: CALL 63244 0 2
// end ; wait ( 2 2$00 ) ;
6423: LD_INT 4200
6425: PPUSH
6426: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] , [ f_not , [ f_weapon , ar_crane ] ] ] ) diff mc_defender [ 3 ] ;
6430: LD_ADDR_VAR 0 2
6434: PUSH
6435: LD_INT 22
6437: PUSH
6438: LD_INT 8
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: PUSH
6445: LD_INT 21
6447: PUSH
6448: LD_INT 2
6450: PUSH
6451: EMPTY
6452: LIST
6453: LIST
6454: PUSH
6455: LD_INT 3
6457: PUSH
6458: LD_INT 34
6460: PUSH
6461: LD_INT 31
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: PUSH
6468: EMPTY
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 3
6474: PUSH
6475: LD_INT 34
6477: PUSH
6478: LD_INT 32
6480: PUSH
6481: EMPTY
6482: LIST
6483: LIST
6484: PUSH
6485: EMPTY
6486: LIST
6487: LIST
6488: PUSH
6489: LD_INT 3
6491: PUSH
6492: LD_INT 34
6494: PUSH
6495: LD_INT 88
6497: PUSH
6498: EMPTY
6499: LIST
6500: LIST
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: PUSH
6506: EMPTY
6507: LIST
6508: LIST
6509: LIST
6510: LIST
6511: LIST
6512: PPUSH
6513: CALL_OW 69
6517: PUSH
6518: LD_EXP 124
6522: PUSH
6523: LD_INT 3
6525: ARRAY
6526: DIFF
6527: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6528: LD_ADDR_EXP 121
6532: PUSH
6533: LD_EXP 121
6537: PPUSH
6538: LD_INT 3
6540: PPUSH
6541: LD_EXP 121
6545: PUSH
6546: LD_INT 3
6548: ARRAY
6549: PUSH
6550: LD_VAR 0 2
6554: DIFF
6555: PPUSH
6556: CALL_OW 1
6560: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6561: LD_ADDR_VAR 0 3
6565: PUSH
6566: LD_INT 0
6568: PPUSH
6569: LD_INT 2
6571: PPUSH
6572: CALL_OW 12
6576: ST_TO_ADDR
// if target then
6577: LD_VAR 0 3
6581: IFFALSE 6739
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6583: LD_ADDR_VAR 0 2
6587: PUSH
6588: LD_VAR 0 2
6592: PPUSH
6593: LD_INT 50
6595: PUSH
6596: EMPTY
6597: LIST
6598: PPUSH
6599: CALL_OW 72
6603: ST_TO_ADDR
// if not tmp then
6604: LD_VAR 0 2
6608: NOT
6609: IFFALSE 6613
// break ;
6611: GO 6737
// for i in tmp do
6613: LD_ADDR_VAR 0 1
6617: PUSH
6618: LD_VAR 0 2
6622: PUSH
6623: FOR_IN
6624: IFFALSE 6664
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6626: LD_VAR 0 1
6630: PPUSH
6631: LD_INT 89
6633: PPUSH
6634: LD_INT 71
6636: PPUSH
6637: CALL_OW 297
6641: PUSH
6642: LD_INT 9
6644: GREATER
6645: IFFALSE 6662
// ComMoveXY ( i , 89 , 71 ) ;
6647: LD_VAR 0 1
6651: PPUSH
6652: LD_INT 89
6654: PPUSH
6655: LD_INT 71
6657: PPUSH
6658: CALL_OW 111
6662: GO 6623
6664: POP
6665: POP
// wait ( 0 0$1 ) ;
6666: LD_INT 35
6668: PPUSH
6669: CALL_OW 67
// p := Inc ( p ) ;
6673: LD_ADDR_VAR 0 4
6677: PUSH
6678: LD_VAR 0 4
6682: PPUSH
6683: CALL 108722 0 1
6687: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6688: LD_VAR 0 2
6692: PPUSH
6693: LD_INT 92
6695: PUSH
6696: LD_INT 89
6698: PUSH
6699: LD_INT 71
6701: PUSH
6702: LD_INT 9
6704: PUSH
6705: EMPTY
6706: LIST
6707: LIST
6708: LIST
6709: LIST
6710: PPUSH
6711: CALL_OW 72
6715: PUSH
6716: LD_VAR 0 2
6720: PUSH
6721: LD_INT 1
6723: MINUS
6724: GREATEREQUAL
6725: PUSH
6726: LD_VAR 0 4
6730: PUSH
6731: LD_INT 30
6733: GREATER
6734: OR
6735: IFFALSE 6583
// end else
6737: GO 6893
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6739: LD_ADDR_VAR 0 2
6743: PUSH
6744: LD_VAR 0 2
6748: PPUSH
6749: LD_INT 50
6751: PUSH
6752: EMPTY
6753: LIST
6754: PPUSH
6755: CALL_OW 72
6759: ST_TO_ADDR
// if not tmp then
6760: LD_VAR 0 2
6764: NOT
6765: IFFALSE 6769
// break ;
6767: GO 6893
// for i in tmp do
6769: LD_ADDR_VAR 0 1
6773: PUSH
6774: LD_VAR 0 2
6778: PUSH
6779: FOR_IN
6780: IFFALSE 6820
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6782: LD_VAR 0 1
6786: PPUSH
6787: LD_INT 125
6789: PPUSH
6790: LD_INT 129
6792: PPUSH
6793: CALL_OW 297
6797: PUSH
6798: LD_INT 9
6800: GREATER
6801: IFFALSE 6818
// ComMoveXY ( i , 125 , 129 ) ;
6803: LD_VAR 0 1
6807: PPUSH
6808: LD_INT 125
6810: PPUSH
6811: LD_INT 129
6813: PPUSH
6814: CALL_OW 111
6818: GO 6779
6820: POP
6821: POP
// wait ( 0 0$1 ) ;
6822: LD_INT 35
6824: PPUSH
6825: CALL_OW 67
// p := Inc ( p ) ;
6829: LD_ADDR_VAR 0 4
6833: PUSH
6834: LD_VAR 0 4
6838: PPUSH
6839: CALL 108722 0 1
6843: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6844: LD_VAR 0 2
6848: PPUSH
6849: LD_INT 92
6851: PUSH
6852: LD_INT 125
6854: PUSH
6855: LD_INT 129
6857: PUSH
6858: LD_INT 9
6860: PUSH
6861: EMPTY
6862: LIST
6863: LIST
6864: LIST
6865: LIST
6866: PPUSH
6867: CALL_OW 72
6871: PUSH
6872: LD_VAR 0 2
6876: PUSH
6877: LD_INT 1
6879: MINUS
6880: GREATEREQUAL
6881: PUSH
6882: LD_VAR 0 4
6886: PUSH
6887: LD_INT 30
6889: GREATER
6890: OR
6891: IFFALSE 6739
// end ; repeat wait ( 0 0$1 ) ;
6893: LD_INT 35
6895: PPUSH
6896: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6900: LD_ADDR_VAR 0 2
6904: PUSH
6905: LD_VAR 0 2
6909: PPUSH
6910: LD_INT 50
6912: PUSH
6913: EMPTY
6914: LIST
6915: PPUSH
6916: CALL_OW 72
6920: ST_TO_ADDR
// for i in tmp do
6921: LD_ADDR_VAR 0 1
6925: PUSH
6926: LD_VAR 0 2
6930: PUSH
6931: FOR_IN
6932: IFFALSE 6970
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6934: LD_VAR 0 1
6938: PPUSH
6939: LD_INT 81
6941: PUSH
6942: LD_INT 8
6944: PUSH
6945: EMPTY
6946: LIST
6947: LIST
6948: PPUSH
6949: CALL_OW 69
6953: PPUSH
6954: LD_VAR 0 1
6958: PPUSH
6959: CALL_OW 74
6963: PPUSH
6964: CALL_OW 115
6968: GO 6931
6970: POP
6971: POP
// until not tmp ;
6972: LD_VAR 0 2
6976: NOT
6977: IFFALSE 6893
// end ;
6979: PPOPN 4
6981: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6982: LD_EXP 22
6986: NOT
6987: PUSH
6988: LD_EXP 15
6992: PUSH
6993: LD_INT 6
6995: GREATEREQUAL
6996: AND
6997: PUSH
6998: LD_OWVAR 67
7002: PUSH
7003: LD_INT 1
7005: GREATER
7006: AND
7007: IFFALSE 7540
7009: GO 7011
7011: DISABLE
7012: LD_INT 0
7014: PPUSH
7015: PPUSH
7016: PPUSH
// begin enable ;
7017: ENABLE
// tmp := [ ] ;
7018: LD_ADDR_VAR 0 3
7022: PUSH
7023: EMPTY
7024: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
7025: LD_ADDR_VAR 0 1
7029: PUSH
7030: DOUBLE
7031: LD_INT 1
7033: DEC
7034: ST_TO_ADDR
7035: LD_INT 4
7037: PUSH
7038: LD_INT 6
7040: PUSH
7041: LD_INT 7
7043: PUSH
7044: LD_INT 8
7046: PUSH
7047: EMPTY
7048: LIST
7049: LIST
7050: LIST
7051: LIST
7052: PUSH
7053: LD_OWVAR 67
7057: ARRAY
7058: PUSH
7059: FOR_TO
7060: IFFALSE 7220
// begin uc_side := 8 ;
7062: LD_ADDR_OWVAR 20
7066: PUSH
7067: LD_INT 8
7069: ST_TO_ADDR
// uc_nation := 2 ;
7070: LD_ADDR_OWVAR 21
7074: PUSH
7075: LD_INT 2
7077: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
7078: LD_INT 13
7080: PUSH
7081: LD_INT 14
7083: PUSH
7084: EMPTY
7085: LIST
7086: LIST
7087: PUSH
7088: LD_INT 1
7090: PPUSH
7091: LD_INT 2
7093: PPUSH
7094: CALL_OW 12
7098: ARRAY
7099: PPUSH
7100: LD_INT 1
7102: PPUSH
7103: LD_INT 5
7105: PPUSH
7106: LD_INT 27
7108: PUSH
7109: LD_INT 28
7111: PUSH
7112: LD_INT 26
7114: PUSH
7115: LD_INT 25
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: LIST
7122: LIST
7123: PUSH
7124: LD_INT 1
7126: PPUSH
7127: LD_INT 4
7129: PPUSH
7130: CALL_OW 12
7134: ARRAY
7135: PPUSH
7136: LD_INT 88
7138: PPUSH
7139: CALL 74510 0 5
// un := CreateVehicle ;
7143: LD_ADDR_VAR 0 2
7147: PUSH
7148: CALL_OW 45
7152: ST_TO_ADDR
// tmp := tmp ^ un ;
7153: LD_ADDR_VAR 0 3
7157: PUSH
7158: LD_VAR 0 3
7162: PUSH
7163: LD_VAR 0 2
7167: ADD
7168: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7169: LD_VAR 0 2
7173: PPUSH
7174: LD_INT 3
7176: PPUSH
7177: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7181: LD_VAR 0 2
7185: PPUSH
7186: LD_INT 30
7188: PPUSH
7189: LD_INT 0
7191: PPUSH
7192: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7196: LD_VAR 0 2
7200: PPUSH
7201: LD_INT 16
7203: PPUSH
7204: LD_INT 11
7206: PPUSH
7207: CALL_OW 111
// wait ( 0 0$2 ) ;
7211: LD_INT 70
7213: PPUSH
7214: CALL_OW 67
// end ;
7218: GO 7059
7220: POP
7221: POP
// for i = 1 to Difficulty do
7222: LD_ADDR_VAR 0 1
7226: PUSH
7227: DOUBLE
7228: LD_INT 1
7230: DEC
7231: ST_TO_ADDR
7232: LD_OWVAR 67
7236: PUSH
7237: FOR_TO
7238: IFFALSE 7367
// begin uc_side := 8 ;
7240: LD_ADDR_OWVAR 20
7244: PUSH
7245: LD_INT 8
7247: ST_TO_ADDR
// uc_nation := 2 ;
7248: LD_ADDR_OWVAR 21
7252: PUSH
7253: LD_INT 2
7255: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
7256: LD_INT 0
7258: PPUSH
7259: LD_INT 8
7261: PPUSH
7262: LD_INT 8
7264: PUSH
7265: LD_INT 8
7267: PUSH
7268: LD_INT 9
7270: PUSH
7271: LD_INT 10
7273: PUSH
7274: EMPTY
7275: LIST
7276: LIST
7277: LIST
7278: LIST
7279: PUSH
7280: LD_OWVAR 67
7284: ARRAY
7285: PPUSH
7286: CALL_OW 380
// un := CreateHuman ;
7290: LD_ADDR_VAR 0 2
7294: PUSH
7295: CALL_OW 44
7299: ST_TO_ADDR
// tmp := tmp ^ un ;
7300: LD_ADDR_VAR 0 3
7304: PUSH
7305: LD_VAR 0 3
7309: PUSH
7310: LD_VAR 0 2
7314: ADD
7315: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7316: LD_VAR 0 2
7320: PPUSH
7321: LD_INT 3
7323: PPUSH
7324: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7328: LD_VAR 0 2
7332: PPUSH
7333: LD_INT 30
7335: PPUSH
7336: LD_INT 0
7338: PPUSH
7339: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7343: LD_VAR 0 2
7347: PPUSH
7348: LD_INT 16
7350: PPUSH
7351: LD_INT 11
7353: PPUSH
7354: CALL_OW 111
// wait ( 0 0$2 ) ;
7358: LD_INT 70
7360: PPUSH
7361: CALL_OW 67
// end ;
7365: GO 7237
7367: POP
7368: POP
// repeat wait ( 0 0$1 ) ;
7369: LD_INT 35
7371: PPUSH
7372: CALL_OW 67
// if legionDestroyed then
7376: LD_EXP 22
7380: IFFALSE 7384
// exit ;
7382: GO 7540
// for i in tmp do
7384: LD_ADDR_VAR 0 1
7388: PUSH
7389: LD_VAR 0 3
7393: PUSH
7394: FOR_IN
7395: IFFALSE 7531
// begin if GetLives ( i ) > 250 then
7397: LD_VAR 0 1
7401: PPUSH
7402: CALL_OW 256
7406: PUSH
7407: LD_INT 250
7409: GREATER
7410: IFFALSE 7502
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
7412: LD_INT 81
7414: PUSH
7415: LD_INT 8
7417: PUSH
7418: EMPTY
7419: LIST
7420: LIST
7421: PUSH
7422: LD_INT 91
7424: PUSH
7425: LD_VAR 0 1
7429: PUSH
7430: LD_INT 10
7432: PUSH
7433: EMPTY
7434: LIST
7435: LIST
7436: LIST
7437: PUSH
7438: EMPTY
7439: LIST
7440: LIST
7441: PPUSH
7442: CALL_OW 69
7446: NOT
7447: IFFALSE 7466
// ComAgressiveMove ( i , 67 , 110 ) else
7449: LD_VAR 0 1
7453: PPUSH
7454: LD_INT 67
7456: PPUSH
7457: LD_INT 110
7459: PPUSH
7460: CALL_OW 114
7464: GO 7500
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7466: LD_VAR 0 1
7470: PPUSH
7471: LD_INT 81
7473: PUSH
7474: LD_INT 8
7476: PUSH
7477: EMPTY
7478: LIST
7479: LIST
7480: PPUSH
7481: CALL_OW 69
7485: PPUSH
7486: LD_VAR 0 1
7490: PPUSH
7491: CALL_OW 74
7495: PPUSH
7496: CALL_OW 115
// end else
7500: GO 7529
// if IsDead ( i ) then
7502: LD_VAR 0 1
7506: PPUSH
7507: CALL_OW 301
7511: IFFALSE 7529
// tmp := tmp diff i ;
7513: LD_ADDR_VAR 0 3
7517: PUSH
7518: LD_VAR 0 3
7522: PUSH
7523: LD_VAR 0 1
7527: DIFF
7528: ST_TO_ADDR
// end ;
7529: GO 7394
7531: POP
7532: POP
// until not tmp ;
7533: LD_VAR 0 3
7537: NOT
7538: IFFALSE 7369
// end ; end_of_file
7540: PPOPN 3
7542: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
7543: LD_INT 0
7545: PPUSH
7546: PPUSH
7547: PPUSH
7548: PPUSH
7549: PPUSH
7550: PPUSH
7551: PPUSH
7552: PPUSH
7553: PPUSH
7554: PPUSH
// side := 3 ;
7555: LD_ADDR_VAR 0 6
7559: PUSH
7560: LD_INT 3
7562: ST_TO_ADDR
// uc_side := side ;
7563: LD_ADDR_OWVAR 20
7567: PUSH
7568: LD_VAR 0 6
7572: ST_TO_ADDR
// uc_nation := 3 ;
7573: LD_ADDR_OWVAR 21
7577: PUSH
7578: LD_INT 3
7580: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7581: LD_ADDR_VAR 0 2
7585: PUSH
7586: LD_INT 22
7588: PUSH
7589: LD_VAR 0 6
7593: PUSH
7594: EMPTY
7595: LIST
7596: LIST
7597: PUSH
7598: LD_INT 21
7600: PUSH
7601: LD_INT 3
7603: PUSH
7604: EMPTY
7605: LIST
7606: LIST
7607: PUSH
7608: EMPTY
7609: LIST
7610: LIST
7611: PPUSH
7612: CALL_OW 69
7616: PUSH
7617: FOR_IN
7618: IFFALSE 7634
// SetBLevel ( i , 10 ) ;
7620: LD_VAR 0 2
7624: PPUSH
7625: LD_INT 10
7627: PPUSH
7628: CALL_OW 241
7632: GO 7617
7634: POP
7635: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7636: LD_ADDR_VAR 0 10
7640: PUSH
7641: LD_INT 22
7643: PUSH
7644: LD_VAR 0 6
7648: PUSH
7649: EMPTY
7650: LIST
7651: LIST
7652: PUSH
7653: LD_INT 30
7655: PUSH
7656: LD_INT 34
7658: PUSH
7659: EMPTY
7660: LIST
7661: LIST
7662: PUSH
7663: EMPTY
7664: LIST
7665: LIST
7666: PPUSH
7667: CALL_OW 69
7671: ST_TO_ADDR
// if teleport then
7672: LD_VAR 0 10
7676: IFFALSE 7697
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7678: LD_VAR 0 10
7682: PUSH
7683: LD_INT 1
7685: ARRAY
7686: PPUSH
7687: LD_INT 123
7689: PPUSH
7690: LD_INT 122
7692: PPUSH
7693: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7697: LD_ADDR_EXP 68
7701: PUSH
7702: LD_STRING Platonov
7704: PPUSH
7705: CALL_OW 25
7709: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7710: LD_ADDR_EXP 69
7714: PUSH
7715: LD_STRING Kovalyuk
7717: PPUSH
7718: CALL_OW 25
7722: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7723: LD_ADDR_EXP 71
7727: PUSH
7728: LD_STRING Yakotich
7730: PPUSH
7731: LD_EXP 1
7735: NOT
7736: PPUSH
7737: LD_STRING 09_
7739: PPUSH
7740: CALL 69670 0 3
7744: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7745: LD_ADDR_EXP 70
7749: PUSH
7750: LD_STRING Bystrov
7752: PPUSH
7753: CALL_OW 25
7757: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7758: LD_ADDR_EXP 72
7762: PUSH
7763: LD_STRING Gleb
7765: PPUSH
7766: CALL_OW 25
7770: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7771: LD_STRING 03_Cornel
7773: PPUSH
7774: CALL_OW 28
7778: IFFALSE 7826
// begin Bierezov := NewCharacter ( Mikhail ) ;
7780: LD_ADDR_EXP 73
7784: PUSH
7785: LD_STRING Mikhail
7787: PPUSH
7788: CALL_OW 25
7792: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7793: LD_EXP 73
7797: PPUSH
7798: LD_INT 197
7800: PPUSH
7801: LD_INT 111
7803: PPUSH
7804: LD_INT 9
7806: PPUSH
7807: LD_INT 0
7809: PPUSH
7810: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7814: LD_EXP 73
7818: PPUSH
7819: LD_INT 3
7821: PPUSH
7822: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7826: LD_EXP 68
7830: PPUSH
7831: LD_INT 126
7833: PPUSH
7834: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7838: LD_EXP 69
7842: PPUSH
7843: LD_INT 134
7845: PPUSH
7846: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7850: LD_EXP 71
7854: PPUSH
7855: LD_INT 197
7857: PPUSH
7858: LD_INT 111
7860: PPUSH
7861: LD_INT 9
7863: PPUSH
7864: LD_INT 0
7866: PPUSH
7867: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7871: LD_EXP 70
7875: PPUSH
7876: LD_INT 197
7878: PPUSH
7879: LD_INT 111
7881: PPUSH
7882: LD_INT 9
7884: PPUSH
7885: LD_INT 0
7887: PPUSH
7888: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7892: LD_EXP 72
7896: PPUSH
7897: LD_INT 197
7899: PPUSH
7900: LD_INT 111
7902: PPUSH
7903: LD_INT 9
7905: PPUSH
7906: LD_INT 0
7908: PPUSH
7909: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 12 , 6 ] ) ;
7913: LD_ADDR_VAR 0 5
7917: PUSH
7918: LD_INT 126
7920: PPUSH
7921: LD_INT 4
7923: PPUSH
7924: LD_STRING zhukov
7926: PPUSH
7927: LD_INT 9
7929: PUSH
7930: LD_INT 10
7932: PUSH
7933: LD_INT 10
7935: PUSH
7936: LD_INT 10
7938: PUSH
7939: EMPTY
7940: LIST
7941: LIST
7942: LIST
7943: LIST
7944: PUSH
7945: LD_OWVAR 67
7949: ARRAY
7950: PPUSH
7951: LD_INT 90000
7953: PUSH
7954: LD_INT 1000
7956: PUSH
7957: LD_INT 300
7959: PUSH
7960: EMPTY
7961: LIST
7962: LIST
7963: LIST
7964: PPUSH
7965: LD_INT 18
7967: PUSH
7968: LD_INT 8
7970: PUSH
7971: LD_INT 12
7973: PUSH
7974: LD_INT 6
7976: PUSH
7977: EMPTY
7978: LIST
7979: LIST
7980: LIST
7981: LIST
7982: PPUSH
7983: CALL 78331 0 6
7987: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Bystrov , Gleb , Bierezov ] ) ;
7988: LD_ADDR_EXP 102
7992: PUSH
7993: LD_EXP 102
7997: PPUSH
7998: LD_INT 2
8000: PPUSH
8001: LD_VAR 0 5
8005: PUSH
8006: LD_EXP 71
8010: PUSH
8011: LD_EXP 70
8015: PUSH
8016: LD_EXP 72
8020: PUSH
8021: LD_EXP 73
8025: PUSH
8026: EMPTY
8027: LIST
8028: LIST
8029: LIST
8030: LIST
8031: UNION
8032: PPUSH
8033: CALL_OW 1
8037: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8038: LD_ADDR_VAR 0 4
8042: PUSH
8043: LD_INT 267
8045: PPUSH
8046: CALL_OW 274
8050: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8051: LD_VAR 0 4
8055: PPUSH
8056: LD_INT 1
8058: PPUSH
8059: LD_INT 5000
8061: PPUSH
8062: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8066: LD_VAR 0 4
8070: PPUSH
8071: LD_INT 2
8073: PPUSH
8074: LD_INT 200
8076: PPUSH
8077: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8081: LD_VAR 0 4
8085: PPUSH
8086: LD_INT 3
8088: PPUSH
8089: LD_INT 200
8091: PPUSH
8092: CALL_OW 277
// for i := 1 to 6 do
8096: LD_ADDR_VAR 0 2
8100: PUSH
8101: DOUBLE
8102: LD_INT 1
8104: DEC
8105: ST_TO_ADDR
8106: LD_INT 6
8108: PUSH
8109: FOR_TO
8110: IFFALSE 8193
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
8112: LD_INT 0
8114: PPUSH
8115: LD_INT 8
8117: PUSH
8118: LD_INT 9
8120: PUSH
8121: LD_INT 10
8123: PUSH
8124: LD_INT 10
8126: PUSH
8127: EMPTY
8128: LIST
8129: LIST
8130: LIST
8131: LIST
8132: PUSH
8133: LD_OWVAR 67
8137: ARRAY
8138: PPUSH
8139: CALL_OW 381
// un := CreateHuman ;
8143: LD_ADDR_VAR 0 8
8147: PUSH
8148: CALL_OW 44
8152: ST_TO_ADDR
// if i mod 2 = 0 then
8153: LD_VAR 0 2
8157: PUSH
8158: LD_INT 2
8160: MOD
8161: PUSH
8162: LD_INT 0
8164: EQUAL
8165: IFFALSE 8179
// SetClass ( un , class_bazooker ) ;
8167: LD_VAR 0 8
8171: PPUSH
8172: LD_INT 9
8174: PPUSH
8175: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
8179: LD_VAR 0 8
8183: PPUSH
8184: LD_INT 460
8186: PPUSH
8187: CALL_OW 52
// end ;
8191: GO 8109
8193: POP
8194: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
8195: LD_INT 21
8197: PPUSH
8198: LD_INT 3
8200: PPUSH
8201: LD_INT 3
8203: PPUSH
8204: LD_INT 52
8206: PPUSH
8207: LD_INT 100
8209: PPUSH
8210: CALL 74510 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
8214: CALL_OW 45
8218: PPUSH
8219: LD_INT 259
8221: PPUSH
8222: LD_INT 145
8224: PPUSH
8225: LD_INT 3
8227: PPUSH
8228: LD_INT 0
8230: PPUSH
8231: CALL 109501 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
8235: CALL_OW 45
8239: PPUSH
8240: LD_INT 245
8242: PPUSH
8243: LD_INT 139
8245: PPUSH
8246: LD_INT 3
8248: PPUSH
8249: LD_INT 0
8251: PPUSH
8252: CALL 109501 0 5
// behemoths := [ ] ;
8256: LD_ADDR_EXP 76
8260: PUSH
8261: EMPTY
8262: ST_TO_ADDR
// behemothBuilders := [ ] ;
8263: LD_ADDR_EXP 77
8267: PUSH
8268: EMPTY
8269: ST_TO_ADDR
// if Kovalyuk then
8270: LD_EXP 69
8274: IFFALSE 8296
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
8276: LD_ADDR_EXP 77
8280: PUSH
8281: LD_EXP 77
8285: PPUSH
8286: LD_EXP 69
8290: PPUSH
8291: CALL 107361 0 2
8295: ST_TO_ADDR
// j := 3 ;
8296: LD_ADDR_VAR 0 3
8300: PUSH
8301: LD_INT 3
8303: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
8304: LD_ADDR_VAR 0 2
8308: PUSH
8309: LD_INT 22
8311: PUSH
8312: LD_INT 3
8314: PUSH
8315: EMPTY
8316: LIST
8317: LIST
8318: PUSH
8319: LD_INT 25
8321: PUSH
8322: LD_INT 3
8324: PUSH
8325: EMPTY
8326: LIST
8327: LIST
8328: PUSH
8329: EMPTY
8330: LIST
8331: LIST
8332: PPUSH
8333: CALL_OW 69
8337: PUSH
8338: LD_EXP 69
8342: DIFF
8343: PUSH
8344: FOR_IN
8345: IFFALSE 8395
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8347: LD_ADDR_EXP 77
8351: PUSH
8352: LD_EXP 77
8356: PPUSH
8357: LD_VAR 0 2
8361: PPUSH
8362: CALL 107361 0 2
8366: ST_TO_ADDR
// j := j - 1 ;
8367: LD_ADDR_VAR 0 3
8371: PUSH
8372: LD_VAR 0 3
8376: PUSH
8377: LD_INT 1
8379: MINUS
8380: ST_TO_ADDR
// if j = 0 then
8381: LD_VAR 0 3
8385: PUSH
8386: LD_INT 0
8388: EQUAL
8389: IFFALSE 8393
// break ;
8391: GO 8395
// end ;
8393: GO 8344
8395: POP
8396: POP
// end ;
8397: LD_VAR 0 1
8401: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8402: LD_INT 0
8404: PPUSH
8405: PPUSH
8406: PPUSH
8407: PPUSH
8408: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8409: LD_ADDR_VAR 0 4
8413: PUSH
8414: LD_INT 209
8416: PUSH
8417: LD_INT 149
8419: PUSH
8420: EMPTY
8421: LIST
8422: LIST
8423: PUSH
8424: LD_INT 219
8426: PUSH
8427: LD_INT 154
8429: PUSH
8430: EMPTY
8431: LIST
8432: LIST
8433: PUSH
8434: LD_INT 223
8436: PUSH
8437: LD_INT 149
8439: PUSH
8440: EMPTY
8441: LIST
8442: LIST
8443: PUSH
8444: LD_INT 232
8446: PUSH
8447: LD_INT 155
8449: PUSH
8450: EMPTY
8451: LIST
8452: LIST
8453: PUSH
8454: EMPTY
8455: LIST
8456: LIST
8457: LIST
8458: LIST
8459: ST_TO_ADDR
// if not behemothBuilders then
8460: LD_EXP 77
8464: NOT
8465: IFFALSE 8469
// exit ;
8467: GO 8600
// j := 1 ;
8469: LD_ADDR_VAR 0 3
8473: PUSH
8474: LD_INT 1
8476: ST_TO_ADDR
// for i in behemothBuilders do
8477: LD_ADDR_VAR 0 2
8481: PUSH
8482: LD_EXP 77
8486: PUSH
8487: FOR_IN
8488: IFFALSE 8598
// begin if GetClass ( i ) <> class_mechanic then
8490: LD_VAR 0 2
8494: PPUSH
8495: CALL_OW 257
8499: PUSH
8500: LD_INT 3
8502: NONEQUAL
8503: IFFALSE 8517
// SetClass ( i , class_mechanic ) ;
8505: LD_VAR 0 2
8509: PPUSH
8510: LD_INT 3
8512: PPUSH
8513: CALL_OW 336
// if IsInUnit ( i ) then
8517: LD_VAR 0 2
8521: PPUSH
8522: CALL_OW 310
8526: IFFALSE 8537
// ComExitBuilding ( i ) ;
8528: LD_VAR 0 2
8532: PPUSH
8533: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8537: LD_VAR 0 2
8541: PPUSH
8542: LD_INT 37
8544: PPUSH
8545: LD_VAR 0 4
8549: PUSH
8550: LD_VAR 0 3
8554: ARRAY
8555: PUSH
8556: LD_INT 1
8558: ARRAY
8559: PPUSH
8560: LD_VAR 0 4
8564: PUSH
8565: LD_VAR 0 3
8569: ARRAY
8570: PUSH
8571: LD_INT 2
8573: ARRAY
8574: PPUSH
8575: LD_INT 0
8577: PPUSH
8578: CALL_OW 230
// j := j + 1 ;
8582: LD_ADDR_VAR 0 3
8586: PUSH
8587: LD_VAR 0 3
8591: PUSH
8592: LD_INT 1
8594: PLUS
8595: ST_TO_ADDR
// end ;
8596: GO 8487
8598: POP
8599: POP
// end ;
8600: LD_VAR 0 1
8604: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
8605: LD_INT 24
8607: PPUSH
8608: LD_INT 30
8610: PUSH
8611: LD_INT 37
8613: PUSH
8614: EMPTY
8615: LIST
8616: LIST
8617: PPUSH
8618: CALL_OW 70
8622: IFFALSE 8635
8624: GO 8626
8626: DISABLE
// behemothUnderConstruct := true ;
8627: LD_ADDR_EXP 26
8631: PUSH
8632: LD_INT 1
8634: ST_TO_ADDR
8635: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8636: LD_INT 3
8638: PPUSH
8639: CALL 107422 0 1
8643: PUSH
8644: LD_INT 22
8646: PUSH
8647: LD_INT 3
8649: PUSH
8650: EMPTY
8651: LIST
8652: LIST
8653: PUSH
8654: LD_INT 30
8656: PUSH
8657: LD_INT 37
8659: PUSH
8660: EMPTY
8661: LIST
8662: LIST
8663: PUSH
8664: EMPTY
8665: LIST
8666: LIST
8667: PPUSH
8668: CALL_OW 69
8672: NOT
8673: AND
8674: IFFALSE 8860
8676: GO 8678
8678: DISABLE
8679: LD_INT 0
8681: PPUSH
8682: PPUSH
// begin enable ;
8683: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8684: LD_ADDR_VAR 0 2
8688: PUSH
8689: LD_INT 3
8691: PPUSH
8692: CALL 107422 0 1
8696: ST_TO_ADDR
// for i in tmp do
8697: LD_ADDR_VAR 0 1
8701: PUSH
8702: LD_VAR 0 2
8706: PUSH
8707: FOR_IN
8708: IFFALSE 8858
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8710: LD_VAR 0 1
8714: PPUSH
8715: LD_INT 9
8717: PPUSH
8718: CALL_OW 308
8722: PUSH
8723: LD_VAR 0 1
8727: PPUSH
8728: CALL_OW 110
8732: PUSH
8733: LD_INT 2
8735: EQUAL
8736: NOT
8737: AND
8738: IFFALSE 8752
// SetTag ( i , 2 ) ;
8740: LD_VAR 0 1
8744: PPUSH
8745: LD_INT 2
8747: PPUSH
8748: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8752: LD_INT 81
8754: PUSH
8755: LD_INT 3
8757: PUSH
8758: EMPTY
8759: LIST
8760: LIST
8761: PUSH
8762: LD_INT 91
8764: PUSH
8765: LD_VAR 0 1
8769: PUSH
8770: LD_INT 12
8772: PUSH
8773: EMPTY
8774: LIST
8775: LIST
8776: LIST
8777: PUSH
8778: EMPTY
8779: LIST
8780: LIST
8781: PPUSH
8782: CALL_OW 69
8786: NOT
8787: PUSH
8788: LD_VAR 0 1
8792: PPUSH
8793: CALL_OW 110
8797: PUSH
8798: LD_INT 2
8800: EQUAL
8801: NOT
8802: AND
8803: IFFALSE 8822
// ComAgressiveMove ( i , 64 , 93 ) else
8805: LD_VAR 0 1
8809: PPUSH
8810: LD_INT 64
8812: PPUSH
8813: LD_INT 93
8815: PPUSH
8816: CALL_OW 114
8820: GO 8856
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8822: LD_VAR 0 1
8826: PPUSH
8827: LD_INT 81
8829: PUSH
8830: LD_INT 3
8832: PUSH
8833: EMPTY
8834: LIST
8835: LIST
8836: PPUSH
8837: CALL_OW 69
8841: PPUSH
8842: LD_VAR 0 1
8846: PPUSH
8847: CALL_OW 74
8851: PPUSH
8852: CALL_OW 115
// end ;
8856: GO 8707
8858: POP
8859: POP
// end ;
8860: PPOPN 2
8862: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8863: LD_INT 0
8865: PPUSH
8866: PPUSH
8867: PPUSH
// result := [ ] ;
8868: LD_ADDR_VAR 0 2
8872: PUSH
8873: EMPTY
8874: ST_TO_ADDR
// uc_side := 6 ;
8875: LD_ADDR_OWVAR 20
8879: PUSH
8880: LD_INT 6
8882: ST_TO_ADDR
// uc_nation := 3 ;
8883: LD_ADDR_OWVAR 21
8887: PUSH
8888: LD_INT 3
8890: ST_TO_ADDR
// case strength of 1 :
8891: LD_VAR 0 1
8895: PUSH
8896: LD_INT 1
8898: DOUBLE
8899: EQUAL
8900: IFTRUE 8904
8902: GO 9046
8904: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8905: LD_ADDR_VAR 0 3
8909: PUSH
8910: DOUBLE
8911: LD_INT 1
8913: DEC
8914: ST_TO_ADDR
8915: LD_INT 4
8917: PUSH
8918: LD_INT 5
8920: PUSH
8921: LD_INT 6
8923: PUSH
8924: LD_INT 7
8926: PUSH
8927: EMPTY
8928: LIST
8929: LIST
8930: LIST
8931: LIST
8932: PUSH
8933: LD_OWVAR 67
8937: ARRAY
8938: PUSH
8939: FOR_TO
8940: IFFALSE 9042
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8942: LD_INT 22
8944: PUSH
8945: LD_INT 24
8947: PUSH
8948: EMPTY
8949: LIST
8950: LIST
8951: PUSH
8952: LD_VAR 0 3
8956: PUSH
8957: LD_INT 2
8959: MOD
8960: PUSH
8961: LD_INT 1
8963: PLUS
8964: ARRAY
8965: PPUSH
8966: LD_INT 1
8968: PUSH
8969: LD_INT 3
8971: PUSH
8972: EMPTY
8973: LIST
8974: LIST
8975: PUSH
8976: LD_INT 1
8978: PPUSH
8979: LD_INT 2
8981: PPUSH
8982: CALL_OW 12
8986: ARRAY
8987: PPUSH
8988: LD_INT 3
8990: PPUSH
8991: LD_INT 43
8993: PUSH
8994: LD_INT 44
8996: PUSH
8997: LD_INT 45
8999: PUSH
9000: EMPTY
9001: LIST
9002: LIST
9003: LIST
9004: PUSH
9005: LD_INT 1
9007: PPUSH
9008: LD_INT 3
9010: PPUSH
9011: CALL_OW 12
9015: ARRAY
9016: PPUSH
9017: LD_INT 80
9019: PPUSH
9020: CALL 74510 0 5
// result := result union CreateVehicle ;
9024: LD_ADDR_VAR 0 2
9028: PUSH
9029: LD_VAR 0 2
9033: PUSH
9034: CALL_OW 45
9038: UNION
9039: ST_TO_ADDR
// end ;
9040: GO 8939
9042: POP
9043: POP
// end ; 2 :
9044: GO 10041
9046: LD_INT 2
9048: DOUBLE
9049: EQUAL
9050: IFTRUE 9054
9052: GO 9222
9054: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
9055: LD_ADDR_VAR 0 3
9059: PUSH
9060: DOUBLE
9061: LD_INT 1
9063: DEC
9064: ST_TO_ADDR
9065: LD_INT 5
9067: PUSH
9068: LD_INT 6
9070: PUSH
9071: LD_INT 7
9073: PUSH
9074: LD_INT 8
9076: PUSH
9077: EMPTY
9078: LIST
9079: LIST
9080: LIST
9081: LIST
9082: PUSH
9083: LD_OWVAR 67
9087: ARRAY
9088: PUSH
9089: FOR_TO
9090: IFFALSE 9218
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
9092: LD_INT 22
9094: PUSH
9095: LD_INT 24
9097: PUSH
9098: LD_INT 24
9100: PUSH
9101: EMPTY
9102: LIST
9103: LIST
9104: LIST
9105: PUSH
9106: LD_VAR 0 3
9110: PUSH
9111: LD_INT 3
9113: MOD
9114: PUSH
9115: LD_INT 1
9117: PLUS
9118: ARRAY
9119: PPUSH
9120: LD_INT 1
9122: PUSH
9123: LD_INT 3
9125: PUSH
9126: EMPTY
9127: LIST
9128: LIST
9129: PUSH
9130: LD_INT 1
9132: PPUSH
9133: LD_INT 2
9135: PPUSH
9136: CALL_OW 12
9140: ARRAY
9141: PPUSH
9142: LD_INT 3
9144: PPUSH
9145: LD_INT 43
9147: PUSH
9148: LD_INT 44
9150: PUSH
9151: LD_INT 45
9153: PUSH
9154: LD_INT 44
9156: PUSH
9157: LD_INT 46
9159: PUSH
9160: LD_INT 46
9162: PUSH
9163: LD_INT 49
9165: PUSH
9166: LD_INT 49
9168: PUSH
9169: EMPTY
9170: LIST
9171: LIST
9172: LIST
9173: LIST
9174: LIST
9175: LIST
9176: LIST
9177: LIST
9178: PUSH
9179: LD_VAR 0 3
9183: PUSH
9184: LD_INT 8
9186: MOD
9187: PUSH
9188: LD_INT 1
9190: PLUS
9191: ARRAY
9192: PPUSH
9193: LD_INT 80
9195: PPUSH
9196: CALL 74510 0 5
// result := result union CreateVehicle ;
9200: LD_ADDR_VAR 0 2
9204: PUSH
9205: LD_VAR 0 2
9209: PUSH
9210: CALL_OW 45
9214: UNION
9215: ST_TO_ADDR
// end ;
9216: GO 9089
9218: POP
9219: POP
// end ; 3 :
9220: GO 10041
9222: LD_INT 3
9224: DOUBLE
9225: EQUAL
9226: IFTRUE 9230
9228: GO 9402
9230: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
9231: LD_ADDR_VAR 0 3
9235: PUSH
9236: DOUBLE
9237: LD_INT 1
9239: DEC
9240: ST_TO_ADDR
9241: LD_INT 6
9243: PUSH
9244: LD_INT 7
9246: PUSH
9247: LD_INT 8
9249: PUSH
9250: LD_INT 9
9252: PUSH
9253: EMPTY
9254: LIST
9255: LIST
9256: LIST
9257: LIST
9258: PUSH
9259: LD_OWVAR 67
9263: ARRAY
9264: PUSH
9265: FOR_TO
9266: IFFALSE 9398
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9268: LD_INT 22
9270: PUSH
9271: LD_INT 24
9273: PUSH
9274: LD_INT 24
9276: PUSH
9277: EMPTY
9278: LIST
9279: LIST
9280: LIST
9281: PUSH
9282: LD_VAR 0 3
9286: PUSH
9287: LD_INT 3
9289: MOD
9290: PUSH
9291: LD_INT 1
9293: PLUS
9294: ARRAY
9295: PPUSH
9296: LD_INT 1
9298: PUSH
9299: LD_INT 3
9301: PUSH
9302: EMPTY
9303: LIST
9304: LIST
9305: PUSH
9306: LD_INT 1
9308: PPUSH
9309: LD_INT 2
9311: PPUSH
9312: CALL_OW 12
9316: ARRAY
9317: PPUSH
9318: LD_INT 3
9320: PPUSH
9321: LD_INT 43
9323: PUSH
9324: LD_INT 47
9326: PUSH
9327: LD_INT 45
9329: PUSH
9330: LD_INT 45
9332: PUSH
9333: LD_INT 46
9335: PUSH
9336: LD_INT 46
9338: PUSH
9339: LD_INT 49
9341: PUSH
9342: LD_INT 49
9344: PUSH
9345: LD_INT 49
9347: PUSH
9348: EMPTY
9349: LIST
9350: LIST
9351: LIST
9352: LIST
9353: LIST
9354: LIST
9355: LIST
9356: LIST
9357: LIST
9358: PUSH
9359: LD_VAR 0 3
9363: PUSH
9364: LD_INT 9
9366: MOD
9367: PUSH
9368: LD_INT 1
9370: PLUS
9371: ARRAY
9372: PPUSH
9373: LD_INT 80
9375: PPUSH
9376: CALL 74510 0 5
// result := result union CreateVehicle ;
9380: LD_ADDR_VAR 0 2
9384: PUSH
9385: LD_VAR 0 2
9389: PUSH
9390: CALL_OW 45
9394: UNION
9395: ST_TO_ADDR
// end ;
9396: GO 9265
9398: POP
9399: POP
// end ; 4 :
9400: GO 10041
9402: LD_INT 4
9404: DOUBLE
9405: EQUAL
9406: IFTRUE 9410
9408: GO 10040
9410: POP
// begin uc_nation := 3 ;
9411: LD_ADDR_OWVAR 21
9415: PUSH
9416: LD_INT 3
9418: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
9419: LD_ADDR_VAR 0 3
9423: PUSH
9424: DOUBLE
9425: LD_INT 1
9427: DEC
9428: ST_TO_ADDR
9429: LD_INT 6
9431: PUSH
9432: LD_INT 8
9434: PUSH
9435: LD_INT 9
9437: PUSH
9438: LD_INT 10
9440: PUSH
9441: EMPTY
9442: LIST
9443: LIST
9444: LIST
9445: LIST
9446: PUSH
9447: LD_OWVAR 67
9451: ARRAY
9452: PUSH
9453: FOR_TO
9454: IFFALSE 9586
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9456: LD_INT 22
9458: PUSH
9459: LD_INT 24
9461: PUSH
9462: LD_INT 24
9464: PUSH
9465: EMPTY
9466: LIST
9467: LIST
9468: LIST
9469: PUSH
9470: LD_VAR 0 3
9474: PUSH
9475: LD_INT 3
9477: MOD
9478: PUSH
9479: LD_INT 1
9481: PLUS
9482: ARRAY
9483: PPUSH
9484: LD_INT 1
9486: PUSH
9487: LD_INT 3
9489: PUSH
9490: EMPTY
9491: LIST
9492: LIST
9493: PUSH
9494: LD_INT 1
9496: PPUSH
9497: LD_INT 2
9499: PPUSH
9500: CALL_OW 12
9504: ARRAY
9505: PPUSH
9506: LD_INT 3
9508: PPUSH
9509: LD_INT 45
9511: PUSH
9512: LD_INT 47
9514: PUSH
9515: LD_INT 47
9517: PUSH
9518: LD_INT 45
9520: PUSH
9521: LD_INT 46
9523: PUSH
9524: LD_INT 46
9526: PUSH
9527: LD_INT 49
9529: PUSH
9530: LD_INT 49
9532: PUSH
9533: LD_INT 49
9535: PUSH
9536: EMPTY
9537: LIST
9538: LIST
9539: LIST
9540: LIST
9541: LIST
9542: LIST
9543: LIST
9544: LIST
9545: LIST
9546: PUSH
9547: LD_VAR 0 3
9551: PUSH
9552: LD_INT 9
9554: MOD
9555: PUSH
9556: LD_INT 1
9558: PLUS
9559: ARRAY
9560: PPUSH
9561: LD_INT 80
9563: PPUSH
9564: CALL 74510 0 5
// result := result union CreateVehicle ;
9568: LD_ADDR_VAR 0 2
9572: PUSH
9573: LD_VAR 0 2
9577: PUSH
9578: CALL_OW 45
9582: UNION
9583: ST_TO_ADDR
// end ;
9584: GO 9453
9586: POP
9587: POP
// if not KappaStatus then
9588: LD_EXP 2
9592: NOT
9593: IFFALSE 9828
// begin uc_nation := 1 ;
9595: LD_ADDR_OWVAR 21
9599: PUSH
9600: LD_INT 1
9602: ST_TO_ADDR
// for i = 1 to 3 do
9603: LD_ADDR_VAR 0 3
9607: PUSH
9608: DOUBLE
9609: LD_INT 1
9611: DEC
9612: ST_TO_ADDR
9613: LD_INT 3
9615: PUSH
9616: FOR_TO
9617: IFFALSE 9753
// begin j := rand ( 0 , 1 ) ;
9619: LD_ADDR_VAR 0 4
9623: PUSH
9624: LD_INT 0
9626: PPUSH
9627: LD_INT 1
9629: PPUSH
9630: CALL_OW 12
9634: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9635: LD_INT 3
9637: PUSH
9638: LD_INT 5
9640: PUSH
9641: LD_INT 5
9643: PUSH
9644: LD_INT 4
9646: PUSH
9647: EMPTY
9648: LIST
9649: LIST
9650: LIST
9651: LIST
9652: PUSH
9653: LD_VAR 0 4
9657: PUSH
9658: LD_INT 1
9660: PPUSH
9661: LD_INT 3
9663: PPUSH
9664: CALL_OW 12
9668: PLUS
9669: ARRAY
9670: PPUSH
9671: LD_INT 1
9673: PUSH
9674: LD_INT 3
9676: PUSH
9677: EMPTY
9678: LIST
9679: LIST
9680: PUSH
9681: LD_INT 1
9683: PPUSH
9684: LD_INT 2
9686: PPUSH
9687: CALL_OW 12
9691: ARRAY
9692: PPUSH
9693: LD_INT 3
9695: PPUSH
9696: LD_INT 9
9698: PUSH
9699: LD_INT 7
9701: PUSH
9702: LD_INT 6
9704: PUSH
9705: EMPTY
9706: LIST
9707: LIST
9708: LIST
9709: PUSH
9710: LD_VAR 0 4
9714: PUSH
9715: LD_INT 1
9717: PPUSH
9718: LD_INT 2
9720: PPUSH
9721: CALL_OW 12
9725: PLUS
9726: ARRAY
9727: PPUSH
9728: LD_INT 85
9730: PPUSH
9731: CALL 74510 0 5
// result := result union CreateVehicle ;
9735: LD_ADDR_VAR 0 2
9739: PUSH
9740: LD_VAR 0 2
9744: PUSH
9745: CALL_OW 45
9749: UNION
9750: ST_TO_ADDR
// end ;
9751: GO 9616
9753: POP
9754: POP
// if vsevolodFirstAttack then
9755: LD_EXP 24
9759: IFFALSE 9826
// begin vsevolodFirstAttack := false ;
9761: LD_ADDR_EXP 24
9765: PUSH
9766: LD_INT 0
9768: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9769: LD_INT 5
9771: PPUSH
9772: LD_INT 3
9774: PPUSH
9775: LD_INT 1
9777: PPUSH
9778: LD_INT 6
9780: PPUSH
9781: LD_INT 100
9783: PPUSH
9784: CALL 74510 0 5
// sewiVeh := CreateVehicle ;
9788: LD_ADDR_EXP 75
9792: PUSH
9793: CALL_OW 45
9797: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9798: LD_EXP 75
9802: PPUSH
9803: LD_INT 1
9805: PPUSH
9806: CALL_OW 242
// result := result union sewiVeh ;
9810: LD_ADDR_VAR 0 2
9814: PUSH
9815: LD_VAR 0 2
9819: PUSH
9820: LD_EXP 75
9824: UNION
9825: ST_TO_ADDR
// end ; end else
9826: GO 10038
// if vsevolodFirstAttack then
9828: LD_EXP 24
9832: IFFALSE 10038
// begin vsevolodFirstAttack := false ;
9834: LD_ADDR_EXP 24
9838: PUSH
9839: LD_INT 0
9841: ST_TO_ADDR
// uc_nation := 3 ;
9842: LD_ADDR_OWVAR 21
9846: PUSH
9847: LD_INT 3
9849: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9850: LD_ADDR_VAR 0 3
9854: PUSH
9855: DOUBLE
9856: LD_INT 1
9858: DEC
9859: ST_TO_ADDR
9860: LD_INT 2
9862: PUSH
9863: LD_OWVAR 67
9867: PLUS
9868: PUSH
9869: FOR_TO
9870: IFFALSE 9978
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9872: LD_INT 22
9874: PUSH
9875: LD_INT 24
9877: PUSH
9878: LD_INT 24
9880: PUSH
9881: EMPTY
9882: LIST
9883: LIST
9884: LIST
9885: PUSH
9886: LD_VAR 0 3
9890: PUSH
9891: LD_INT 3
9893: MOD
9894: PUSH
9895: LD_INT 1
9897: PLUS
9898: ARRAY
9899: PPUSH
9900: LD_INT 1
9902: PUSH
9903: LD_INT 3
9905: PUSH
9906: EMPTY
9907: LIST
9908: LIST
9909: PUSH
9910: LD_INT 1
9912: PPUSH
9913: LD_INT 2
9915: PPUSH
9916: CALL_OW 12
9920: ARRAY
9921: PPUSH
9922: LD_INT 1
9924: PPUSH
9925: LD_INT 45
9927: PUSH
9928: LD_INT 47
9930: PUSH
9931: LD_INT 47
9933: PUSH
9934: EMPTY
9935: LIST
9936: LIST
9937: LIST
9938: PUSH
9939: LD_VAR 0 3
9943: PUSH
9944: LD_INT 3
9946: MOD
9947: PUSH
9948: LD_INT 1
9950: PLUS
9951: ARRAY
9952: PPUSH
9953: LD_INT 80
9955: PPUSH
9956: CALL 74510 0 5
// result := result union CreateVehicle ;
9960: LD_ADDR_VAR 0 2
9964: PUSH
9965: LD_VAR 0 2
9969: PUSH
9970: CALL_OW 45
9974: UNION
9975: ST_TO_ADDR
// end ;
9976: GO 9869
9978: POP
9979: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9980: LD_INT 24
9982: PPUSH
9983: LD_INT 3
9985: PPUSH
9986: LD_INT 1
9988: PPUSH
9989: LD_INT 47
9991: PPUSH
9992: LD_INT 100
9994: PPUSH
9995: CALL 74510 0 5
// sewiVeh := CreateVehicle ;
9999: LD_ADDR_EXP 75
10003: PUSH
10004: CALL_OW 45
10008: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
10009: LD_EXP 75
10013: PPUSH
10014: LD_INT 6
10016: NEG
10017: PPUSH
10018: CALL_OW 242
// result := result union sewiVeh ;
10022: LD_ADDR_VAR 0 2
10026: PUSH
10027: LD_VAR 0 2
10031: PUSH
10032: LD_EXP 75
10036: UNION
10037: ST_TO_ADDR
// end ; end ; end ;
10038: GO 10041
10040: POP
// end ;
10041: LD_VAR 0 2
10045: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
10046: LD_EXP 16
10050: IFFALSE 10791
10052: GO 10054
10054: DISABLE
10055: LD_INT 0
10057: PPUSH
10058: PPUSH
10059: PPUSH
10060: PPUSH
10061: PPUSH
10062: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
10063: LD_ADDR_VAR 0 4
10067: PUSH
10068: LD_INT 11
10070: PUSH
10071: LD_INT 12
10073: PUSH
10074: EMPTY
10075: LIST
10076: LIST
10077: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
10078: LD_ADDR_VAR 0 3
10082: PUSH
10083: LD_INT 11550
10085: PUSH
10086: LD_INT 10150
10088: PUSH
10089: LD_INT 9800
10091: PUSH
10092: LD_INT 9450
10094: PUSH
10095: EMPTY
10096: LIST
10097: LIST
10098: LIST
10099: LIST
10100: PUSH
10101: LD_OWVAR 67
10105: ARRAY
10106: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
10107: LD_ADDR_VAR 0 6
10111: PUSH
10112: LD_INT 70
10114: PUSH
10115: LD_INT 118
10117: PUSH
10118: EMPTY
10119: LIST
10120: LIST
10121: PUSH
10122: LD_INT 78
10124: PUSH
10125: LD_INT 31
10127: PUSH
10128: EMPTY
10129: LIST
10130: LIST
10131: PUSH
10132: EMPTY
10133: LIST
10134: LIST
10135: ST_TO_ADDR
// repeat if missionStage = 2 then
10136: LD_EXP 15
10140: PUSH
10141: LD_INT 2
10143: EQUAL
10144: IFFALSE 10155
// wait ( 1 1$30 ) else
10146: LD_INT 3150
10148: PPUSH
10149: CALL_OW 67
10153: GO 10164
// wait ( time ) ;
10155: LD_VAR 0 3
10159: PPUSH
10160: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
10164: LD_EXP 15
10168: PUSH
10169: LD_INT 6
10171: EQUAL
10172: PUSH
10173: LD_OWVAR 67
10177: PUSH
10178: LD_INT 2
10180: GREATER
10181: OR
10182: IFFALSE 10210
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
10184: LD_INT 51
10186: PPUSH
10187: LD_INT 6
10189: PPUSH
10190: LD_INT 2
10192: PPUSH
10193: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
10197: LD_INT 57
10199: PPUSH
10200: LD_INT 6
10202: PPUSH
10203: LD_INT 2
10205: PPUSH
10206: CALL_OW 322
// end ; if missionStage = 8 then
10210: LD_EXP 15
10214: PUSH
10215: LD_INT 8
10217: EQUAL
10218: IFFALSE 10246
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
10220: LD_INT 52
10222: PPUSH
10223: LD_INT 6
10225: PPUSH
10226: LD_INT 2
10228: PPUSH
10229: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
10233: LD_INT 58
10235: PPUSH
10236: LD_INT 6
10238: PPUSH
10239: LD_INT 2
10241: PPUSH
10242: CALL_OW 322
// end ; if Difficulty = 4 or missionStage = 10 then
10246: LD_OWVAR 67
10250: PUSH
10251: LD_INT 4
10253: EQUAL
10254: PUSH
10255: LD_EXP 15
10259: PUSH
10260: LD_INT 10
10262: EQUAL
10263: OR
10264: IFFALSE 10292
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
10266: LD_INT 53
10268: PPUSH
10269: LD_INT 6
10271: PPUSH
10272: LD_INT 2
10274: PPUSH
10275: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
10279: LD_INT 59
10281: PPUSH
10282: LD_INT 6
10284: PPUSH
10285: LD_INT 2
10287: PPUSH
10288: CALL_OW 322
// end ; if activeAttacks then
10292: LD_EXP 16
10296: IFFALSE 10785
// begin if missionStage = 2 then
10298: LD_EXP 15
10302: PUSH
10303: LD_INT 2
10305: EQUAL
10306: IFFALSE 10316
// strength := 1 ;
10308: LD_ADDR_VAR 0 5
10312: PUSH
10313: LD_INT 1
10315: ST_TO_ADDR
// if missionStage > 2 then
10316: LD_EXP 15
10320: PUSH
10321: LD_INT 2
10323: GREATER
10324: IFFALSE 10334
// strength := 2 ;
10326: LD_ADDR_VAR 0 5
10330: PUSH
10331: LD_INT 2
10333: ST_TO_ADDR
// if missionStage > 6 then
10334: LD_EXP 15
10338: PUSH
10339: LD_INT 6
10341: GREATER
10342: IFFALSE 10352
// strength := 3 ;
10344: LD_ADDR_VAR 0 5
10348: PUSH
10349: LD_INT 3
10351: ST_TO_ADDR
// if missionStage > 10 then
10352: LD_EXP 15
10356: PUSH
10357: LD_INT 10
10359: GREATER
10360: IFFALSE 10370
// strength := 4 ;
10362: LD_ADDR_VAR 0 5
10366: PUSH
10367: LD_INT 4
10369: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
10370: LD_ADDR_VAR 0 2
10374: PUSH
10375: LD_VAR 0 5
10379: PPUSH
10380: CALL 8863 0 1
10384: ST_TO_ADDR
// for i in tmp do
10385: LD_ADDR_VAR 0 1
10389: PUSH
10390: LD_VAR 0 2
10394: PUSH
10395: FOR_IN
10396: IFFALSE 10654
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
10398: LD_VAR 0 1
10402: PPUSH
10403: LD_VAR 0 4
10407: PUSH
10408: LD_INT 1
10410: PPUSH
10411: LD_INT 2
10413: PPUSH
10414: CALL_OW 12
10418: ARRAY
10419: PPUSH
10420: LD_INT 0
10422: PPUSH
10423: CALL_OW 49
// if i = sewiVeh then
10427: LD_VAR 0 1
10431: PUSH
10432: LD_EXP 75
10436: EQUAL
10437: IFFALSE 10474
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
10439: LD_ADDR_EXP 74
10443: PUSH
10444: LD_STRING Vsevolod
10446: PPUSH
10447: LD_INT 0
10449: PPUSH
10450: LD_STRING 
10452: PPUSH
10453: CALL 69670 0 3
10457: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
10458: LD_EXP 74
10462: PPUSH
10463: LD_VAR 0 1
10467: PPUSH
10468: CALL_OW 52
// end else
10472: GO 10555
// if GetControl ( i ) = control_manual then
10474: LD_VAR 0 1
10478: PPUSH
10479: CALL_OW 263
10483: PUSH
10484: LD_INT 1
10486: EQUAL
10487: IFFALSE 10555
// begin uc_side := 6 ;
10489: LD_ADDR_OWVAR 20
10493: PUSH
10494: LD_INT 6
10496: ST_TO_ADDR
// uc_nation := 3 ;
10497: LD_ADDR_OWVAR 21
10501: PUSH
10502: LD_INT 3
10504: ST_TO_ADDR
// hc_gallery :=  ;
10505: LD_ADDR_OWVAR 33
10509: PUSH
10510: LD_STRING 
10512: ST_TO_ADDR
// hc_name :=  ;
10513: LD_ADDR_OWVAR 26
10517: PUSH
10518: LD_STRING 
10520: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
10521: LD_INT 0
10523: PPUSH
10524: LD_INT 3
10526: PPUSH
10527: LD_INT 10
10529: PPUSH
10530: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
10534: CALL_OW 44
10538: PPUSH
10539: LD_VAR 0 1
10543: PPUSH
10544: CALL_OW 52
// wait ( 0 0$0.3 ) ;
10548: LD_INT 10
10550: PPUSH
10551: CALL_OW 67
// end ; case rand ( 1 , 3 ) of 1 :
10555: LD_INT 1
10557: PPUSH
10558: LD_INT 3
10560: PPUSH
10561: CALL_OW 12
10565: PUSH
10566: LD_INT 1
10568: DOUBLE
10569: EQUAL
10570: IFTRUE 10574
10572: GO 10592
10574: POP
// ComMoveXY ( i , 111 , 197 ) ; 2 :
10575: LD_VAR 0 1
10579: PPUSH
10580: LD_INT 111
10582: PPUSH
10583: LD_INT 197
10585: PPUSH
10586: CALL_OW 111
10590: GO 10645
10592: LD_INT 2
10594: DOUBLE
10595: EQUAL
10596: IFTRUE 10600
10598: GO 10618
10600: POP
// ComMoveXY ( i , 91 , 165 ) ; 3 :
10601: LD_VAR 0 1
10605: PPUSH
10606: LD_INT 91
10608: PPUSH
10609: LD_INT 165
10611: PPUSH
10612: CALL_OW 111
10616: GO 10645
10618: LD_INT 3
10620: DOUBLE
10621: EQUAL
10622: IFTRUE 10626
10624: GO 10644
10626: POP
// ComMoveXY ( i , 137 , 157 ) ; end ;
10627: LD_VAR 0 1
10631: PPUSH
10632: LD_INT 137
10634: PPUSH
10635: LD_INT 157
10637: PPUSH
10638: CALL_OW 111
10642: GO 10645
10644: POP
// wait ( 0 0$2 ) ;
10645: LD_INT 70
10647: PPUSH
10648: CALL_OW 67
// end ;
10652: GO 10395
10654: POP
10655: POP
// repeat wait ( 0 0$1 ) ;
10656: LD_INT 35
10658: PPUSH
10659: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
10663: LD_ADDR_VAR 0 1
10667: PUSH
10668: LD_VAR 0 2
10672: PPUSH
10673: LD_INT 50
10675: PUSH
10676: EMPTY
10677: LIST
10678: PPUSH
10679: CALL_OW 72
10683: PUSH
10684: FOR_IN
10685: IFFALSE 10744
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10687: LD_VAR 0 1
10691: PPUSH
10692: LD_INT 108
10694: PUSH
10695: LD_INT 153
10697: PUSH
10698: EMPTY
10699: LIST
10700: LIST
10701: PUSH
10702: LD_INT 105
10704: PUSH
10705: LD_INT 149
10707: PUSH
10708: EMPTY
10709: LIST
10710: LIST
10711: PUSH
10712: LD_INT 85
10714: PUSH
10715: LD_INT 131
10717: PUSH
10718: EMPTY
10719: LIST
10720: LIST
10721: PUSH
10722: LD_INT 64
10724: PUSH
10725: LD_INT 105
10727: PUSH
10728: EMPTY
10729: LIST
10730: LIST
10731: PUSH
10732: EMPTY
10733: LIST
10734: LIST
10735: LIST
10736: LIST
10737: PPUSH
10738: CALL 109965 0 2
10742: GO 10684
10744: POP
10745: POP
// until not UnitFilter ( tmp , [ [ f_not , [ f_weapon , ru_time_lapser ] ] , [ f_ok ] ] ) ;
10746: LD_VAR 0 2
10750: PPUSH
10751: LD_INT 3
10753: PUSH
10754: LD_INT 34
10756: PUSH
10757: LD_INT 49
10759: PUSH
10760: EMPTY
10761: LIST
10762: LIST
10763: PUSH
10764: EMPTY
10765: LIST
10766: LIST
10767: PUSH
10768: LD_INT 50
10770: PUSH
10771: EMPTY
10772: LIST
10773: PUSH
10774: EMPTY
10775: LIST
10776: LIST
10777: PPUSH
10778: CALL_OW 72
10782: NOT
10783: IFFALSE 10656
// end ; until russianDestroyed ;
10785: LD_EXP 21
10789: IFFALSE 10136
// end ;
10791: PPOPN 6
10793: END
// every 7 7$30 trigger debug do var i , tmp , target , teleport , p ;
10794: LD_EXP 1
10798: IFFALSE 11835
10800: GO 10802
10802: DISABLE
10803: LD_INT 0
10805: PPUSH
10806: PPUSH
10807: PPUSH
10808: PPUSH
10809: PPUSH
// begin enable ;
10810: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10811: LD_INT 22
10813: PUSH
10814: LD_INT 3
10816: PUSH
10817: EMPTY
10818: LIST
10819: LIST
10820: PUSH
10821: LD_INT 30
10823: PUSH
10824: LD_INT 3
10826: PUSH
10827: EMPTY
10828: LIST
10829: LIST
10830: PUSH
10831: EMPTY
10832: LIST
10833: LIST
10834: PPUSH
10835: CALL_OW 69
10839: NOT
10840: IFFALSE 10844
// exit ;
10842: GO 11835
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10844: LD_ADDR_VAR 0 4
10848: PUSH
10849: LD_INT 22
10851: PUSH
10852: LD_INT 3
10854: PUSH
10855: EMPTY
10856: LIST
10857: LIST
10858: PUSH
10859: LD_INT 30
10861: PUSH
10862: LD_INT 34
10864: PUSH
10865: EMPTY
10866: LIST
10867: LIST
10868: PUSH
10869: EMPTY
10870: LIST
10871: LIST
10872: PPUSH
10873: CALL_OW 69
10877: ST_TO_ADDR
// if Prob ( 40 ) then
10878: LD_INT 40
10880: PPUSH
10881: CALL_OW 13
10885: IFFALSE 11031
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10887: LD_INT 2
10889: PPUSH
10890: LD_INT 22
10892: PUSH
10893: LD_INT 3
10895: PUSH
10896: LD_INT 3
10898: PUSH
10899: LD_INT 49
10901: PUSH
10902: EMPTY
10903: LIST
10904: LIST
10905: LIST
10906: LIST
10907: PUSH
10908: LD_INT 22
10910: PUSH
10911: LD_INT 3
10913: PUSH
10914: LD_INT 3
10916: PUSH
10917: LD_INT 49
10919: PUSH
10920: EMPTY
10921: LIST
10922: LIST
10923: LIST
10924: LIST
10925: PUSH
10926: LD_INT 22
10928: PUSH
10929: LD_INT 3
10931: PUSH
10932: LD_INT 3
10934: PUSH
10935: LD_INT 49
10937: PUSH
10938: EMPTY
10939: LIST
10940: LIST
10941: LIST
10942: LIST
10943: PUSH
10944: LD_INT 24
10946: PUSH
10947: LD_INT 3
10949: PUSH
10950: LD_INT 3
10952: PUSH
10953: LD_INT 46
10955: PUSH
10956: EMPTY
10957: LIST
10958: LIST
10959: LIST
10960: LIST
10961: PUSH
10962: LD_INT 24
10964: PUSH
10965: LD_INT 3
10967: PUSH
10968: LD_INT 3
10970: PUSH
10971: LD_INT 46
10973: PUSH
10974: EMPTY
10975: LIST
10976: LIST
10977: LIST
10978: LIST
10979: PUSH
10980: LD_INT 24
10982: PUSH
10983: LD_INT 3
10985: PUSH
10986: LD_INT 3
10988: PUSH
10989: LD_INT 46
10991: PUSH
10992: EMPTY
10993: LIST
10994: LIST
10995: LIST
10996: LIST
10997: PUSH
10998: LD_INT 24
11000: PUSH
11001: LD_INT 3
11003: PUSH
11004: LD_INT 3
11006: PUSH
11007: LD_INT 46
11009: PUSH
11010: EMPTY
11011: LIST
11012: LIST
11013: LIST
11014: LIST
11015: PUSH
11016: EMPTY
11017: LIST
11018: LIST
11019: LIST
11020: LIST
11021: LIST
11022: LIST
11023: LIST
11024: PPUSH
11025: CALL 63244 0 2
// end else
11029: GO 11173
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
11031: LD_INT 2
11033: PPUSH
11034: LD_INT 24
11036: PUSH
11037: LD_INT 3
11039: PUSH
11040: LD_INT 3
11042: PUSH
11043: LD_INT 47
11045: PUSH
11046: EMPTY
11047: LIST
11048: LIST
11049: LIST
11050: LIST
11051: PUSH
11052: LD_INT 24
11054: PUSH
11055: LD_INT 3
11057: PUSH
11058: LD_INT 3
11060: PUSH
11061: LD_INT 47
11063: PUSH
11064: EMPTY
11065: LIST
11066: LIST
11067: LIST
11068: LIST
11069: PUSH
11070: LD_INT 24
11072: PUSH
11073: LD_INT 3
11075: PUSH
11076: LD_INT 3
11078: PUSH
11079: LD_INT 47
11081: PUSH
11082: EMPTY
11083: LIST
11084: LIST
11085: LIST
11086: LIST
11087: PUSH
11088: LD_INT 24
11090: PUSH
11091: LD_INT 3
11093: PUSH
11094: LD_INT 3
11096: PUSH
11097: LD_INT 46
11099: PUSH
11100: EMPTY
11101: LIST
11102: LIST
11103: LIST
11104: LIST
11105: PUSH
11106: LD_INT 24
11108: PUSH
11109: LD_INT 3
11111: PUSH
11112: LD_INT 3
11114: PUSH
11115: LD_INT 46
11117: PUSH
11118: EMPTY
11119: LIST
11120: LIST
11121: LIST
11122: LIST
11123: PUSH
11124: LD_INT 24
11126: PUSH
11127: LD_INT 3
11129: PUSH
11130: LD_INT 3
11132: PUSH
11133: LD_INT 46
11135: PUSH
11136: EMPTY
11137: LIST
11138: LIST
11139: LIST
11140: LIST
11141: PUSH
11142: LD_INT 24
11144: PUSH
11145: LD_INT 3
11147: PUSH
11148: LD_INT 3
11150: PUSH
11151: LD_INT 46
11153: PUSH
11154: EMPTY
11155: LIST
11156: LIST
11157: LIST
11158: LIST
11159: PUSH
11160: EMPTY
11161: LIST
11162: LIST
11163: LIST
11164: LIST
11165: LIST
11166: LIST
11167: LIST
11168: PPUSH
11169: CALL 63244 0 2
// end ; wait ( 2 2$00 ) ;
11173: LD_INT 4200
11175: PPUSH
11176: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_siberium_rocket ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 2 ] ;
11180: LD_ADDR_VAR 0 2
11184: PUSH
11185: LD_INT 22
11187: PUSH
11188: LD_INT 3
11190: PUSH
11191: EMPTY
11192: LIST
11193: LIST
11194: PUSH
11195: LD_INT 23
11197: PUSH
11198: LD_INT 3
11200: PUSH
11201: EMPTY
11202: LIST
11203: LIST
11204: PUSH
11205: LD_INT 21
11207: PUSH
11208: LD_INT 2
11210: PUSH
11211: EMPTY
11212: LIST
11213: LIST
11214: PUSH
11215: LD_INT 3
11217: PUSH
11218: LD_INT 34
11220: PUSH
11221: LD_INT 48
11223: PUSH
11224: EMPTY
11225: LIST
11226: LIST
11227: PUSH
11228: EMPTY
11229: LIST
11230: LIST
11231: PUSH
11232: LD_INT 3
11234: PUSH
11235: LD_INT 34
11237: PUSH
11238: LD_INT 51
11240: PUSH
11241: EMPTY
11242: LIST
11243: LIST
11244: PUSH
11245: EMPTY
11246: LIST
11247: LIST
11248: PUSH
11249: LD_INT 3
11251: PUSH
11252: LD_INT 34
11254: PUSH
11255: LD_INT 52
11257: PUSH
11258: EMPTY
11259: LIST
11260: LIST
11261: PUSH
11262: EMPTY
11263: LIST
11264: LIST
11265: PUSH
11266: EMPTY
11267: LIST
11268: LIST
11269: LIST
11270: LIST
11271: LIST
11272: LIST
11273: PPUSH
11274: CALL_OW 69
11278: PUSH
11279: LD_EXP 124
11283: PUSH
11284: LD_INT 2
11286: ARRAY
11287: DIFF
11288: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
11289: LD_ADDR_EXP 121
11293: PUSH
11294: LD_EXP 121
11298: PPUSH
11299: LD_INT 2
11301: PPUSH
11302: LD_EXP 121
11306: PUSH
11307: LD_INT 2
11309: ARRAY
11310: PUSH
11311: LD_VAR 0 2
11315: DIFF
11316: PPUSH
11317: CALL_OW 1
11321: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
11322: LD_ADDR_VAR 0 3
11326: PUSH
11327: LD_INT 0
11329: PPUSH
11330: LD_INT 1
11332: PPUSH
11333: CALL_OW 12
11337: ST_TO_ADDR
// p := 0 ;
11338: LD_ADDR_VAR 0 5
11342: PUSH
11343: LD_INT 0
11345: ST_TO_ADDR
// if target then
11346: LD_VAR 0 3
11350: IFFALSE 11499
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11352: LD_ADDR_VAR 0 2
11356: PUSH
11357: LD_VAR 0 2
11361: PPUSH
11362: LD_INT 50
11364: PUSH
11365: EMPTY
11366: LIST
11367: PPUSH
11368: CALL_OW 72
11372: ST_TO_ADDR
// for i in tmp do
11373: LD_ADDR_VAR 0 1
11377: PUSH
11378: LD_VAR 0 2
11382: PUSH
11383: FOR_IN
11384: IFFALSE 11424
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
11386: LD_VAR 0 1
11390: PPUSH
11391: LD_INT 139
11393: PPUSH
11394: LD_INT 89
11396: PPUSH
11397: CALL_OW 297
11401: PUSH
11402: LD_INT 9
11404: GREATER
11405: IFFALSE 11422
// ComMoveXY ( i , 139 , 89 ) ;
11407: LD_VAR 0 1
11411: PPUSH
11412: LD_INT 139
11414: PPUSH
11415: LD_INT 89
11417: PPUSH
11418: CALL_OW 111
11422: GO 11383
11424: POP
11425: POP
// wait ( 0 0$1 ) ;
11426: LD_INT 35
11428: PPUSH
11429: CALL_OW 67
// p := Inc ( p ) ;
11433: LD_ADDR_VAR 0 5
11437: PUSH
11438: LD_VAR 0 5
11442: PPUSH
11443: CALL 108722 0 1
11447: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11448: LD_VAR 0 2
11452: PPUSH
11453: LD_INT 92
11455: PUSH
11456: LD_INT 139
11458: PUSH
11459: LD_INT 89
11461: PUSH
11462: LD_INT 9
11464: PUSH
11465: EMPTY
11466: LIST
11467: LIST
11468: LIST
11469: LIST
11470: PPUSH
11471: CALL_OW 72
11475: PUSH
11476: LD_VAR 0 2
11480: PUSH
11481: LD_INT 1
11483: MINUS
11484: GREATEREQUAL
11485: PUSH
11486: LD_VAR 0 5
11490: PUSH
11491: LD_INT 60
11493: GREATER
11494: OR
11495: IFFALSE 11352
// end else
11497: GO 11662
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11499: LD_VAR 0 2
11503: PPUSH
11504: LD_VAR 0 4
11508: PUSH
11509: LD_INT 1
11511: ARRAY
11512: PPUSH
11513: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11517: LD_ADDR_VAR 0 2
11521: PUSH
11522: LD_VAR 0 2
11526: PPUSH
11527: LD_INT 50
11529: PUSH
11530: EMPTY
11531: LIST
11532: PPUSH
11533: CALL_OW 72
11537: ST_TO_ADDR
// for i in tmp do
11538: LD_ADDR_VAR 0 1
11542: PUSH
11543: LD_VAR 0 2
11547: PUSH
11548: FOR_IN
11549: IFFALSE 11589
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11551: LD_VAR 0 1
11555: PPUSH
11556: LD_INT 124
11558: PPUSH
11559: LD_INT 139
11561: PPUSH
11562: CALL_OW 297
11566: PUSH
11567: LD_INT 9
11569: GREATER
11570: IFFALSE 11587
// ComMoveXY ( i , 124 , 139 ) ;
11572: LD_VAR 0 1
11576: PPUSH
11577: LD_INT 124
11579: PPUSH
11580: LD_INT 139
11582: PPUSH
11583: CALL_OW 111
11587: GO 11548
11589: POP
11590: POP
// wait ( 0 0$1 ) ;
11591: LD_INT 35
11593: PPUSH
11594: CALL_OW 67
// p := Inc ( p ) ;
11598: LD_ADDR_VAR 0 5
11602: PUSH
11603: LD_VAR 0 5
11607: PPUSH
11608: CALL 108722 0 1
11612: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11613: LD_VAR 0 2
11617: PPUSH
11618: LD_INT 92
11620: PUSH
11621: LD_INT 124
11623: PUSH
11624: LD_INT 139
11626: PUSH
11627: LD_INT 9
11629: PUSH
11630: EMPTY
11631: LIST
11632: LIST
11633: LIST
11634: LIST
11635: PPUSH
11636: CALL_OW 72
11640: PUSH
11641: LD_VAR 0 2
11645: PUSH
11646: LD_INT 1
11648: MINUS
11649: GREATEREQUAL
11650: PUSH
11651: LD_VAR 0 5
11655: PUSH
11656: LD_INT 60
11658: GREATER
11659: OR
11660: IFFALSE 11517
// end ; repeat wait ( 0 0$1 ) ;
11662: LD_INT 35
11664: PPUSH
11665: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11669: LD_ADDR_VAR 0 2
11673: PUSH
11674: LD_VAR 0 2
11678: PPUSH
11679: LD_INT 50
11681: PUSH
11682: EMPTY
11683: LIST
11684: PPUSH
11685: CALL_OW 72
11689: ST_TO_ADDR
// for i in tmp do
11690: LD_ADDR_VAR 0 1
11694: PUSH
11695: LD_VAR 0 2
11699: PUSH
11700: FOR_IN
11701: IFFALSE 11826
// begin if GetWeapon ( i ) = ru_time_lapser then
11703: LD_VAR 0 1
11707: PPUSH
11708: CALL_OW 264
11712: PUSH
11713: LD_INT 49
11715: EQUAL
11716: IFFALSE 11772
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11718: LD_VAR 0 1
11722: PPUSH
11723: LD_INT 2
11725: PUSH
11726: LD_INT 22
11728: PUSH
11729: LD_INT 1
11731: PUSH
11732: EMPTY
11733: LIST
11734: LIST
11735: PUSH
11736: LD_INT 22
11738: PUSH
11739: LD_INT 8
11741: PUSH
11742: EMPTY
11743: LIST
11744: LIST
11745: PUSH
11746: EMPTY
11747: LIST
11748: LIST
11749: LIST
11750: PPUSH
11751: CALL_OW 69
11755: PPUSH
11756: LD_VAR 0 1
11760: PPUSH
11761: CALL_OW 74
11765: PPUSH
11766: CALL_OW 112
11770: GO 11824
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11772: LD_VAR 0 1
11776: PPUSH
11777: LD_INT 2
11779: PUSH
11780: LD_INT 22
11782: PUSH
11783: LD_INT 1
11785: PUSH
11786: EMPTY
11787: LIST
11788: LIST
11789: PUSH
11790: LD_INT 22
11792: PUSH
11793: LD_INT 8
11795: PUSH
11796: EMPTY
11797: LIST
11798: LIST
11799: PUSH
11800: EMPTY
11801: LIST
11802: LIST
11803: LIST
11804: PPUSH
11805: CALL_OW 69
11809: PPUSH
11810: LD_VAR 0 1
11814: PPUSH
11815: CALL_OW 74
11819: PPUSH
11820: CALL_OW 115
// end ;
11824: GO 11700
11826: POP
11827: POP
// until not tmp ;
11828: LD_VAR 0 2
11832: NOT
11833: IFFALSE 11662
// end ;
11835: PPOPN 5
11837: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 7 and Difficulty > 1 do var i , veh , un ;
11838: LD_EXP 15
11842: PUSH
11843: LD_INT 7
11845: GREATEREQUAL
11846: PUSH
11847: LD_OWVAR 67
11851: PUSH
11852: LD_INT 1
11854: GREATER
11855: AND
11856: IFFALSE 12148
11858: GO 11860
11860: DISABLE
11861: LD_INT 0
11863: PPUSH
11864: PPUSH
11865: PPUSH
// begin ruMobile := [ ] ;
11866: LD_ADDR_EXP 78
11870: PUSH
11871: EMPTY
11872: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 ] [ Difficulty - 1 ] do
11873: LD_ADDR_VAR 0 1
11877: PUSH
11878: DOUBLE
11879: LD_INT 1
11881: DEC
11882: ST_TO_ADDR
11883: LD_INT 4
11885: PUSH
11886: LD_INT 5
11888: PUSH
11889: LD_INT 6
11891: PUSH
11892: EMPTY
11893: LIST
11894: LIST
11895: LIST
11896: PUSH
11897: LD_OWVAR 67
11901: PUSH
11902: LD_INT 1
11904: MINUS
11905: ARRAY
11906: PUSH
11907: FOR_TO
11908: IFFALSE 12146
// begin uc_side := 3 ;
11910: LD_ADDR_OWVAR 20
11914: PUSH
11915: LD_INT 3
11917: ST_TO_ADDR
// uc_nation := 1 ;
11918: LD_ADDR_OWVAR 21
11922: PUSH
11923: LD_INT 1
11925: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_laser , us_rocket_launcher ] [ i mod 2 + 1 ] , 100 ) ;
11926: LD_INT 5
11928: PPUSH
11929: LD_INT 3
11931: PPUSH
11932: LD_INT 1
11934: PPUSH
11935: LD_INT 9
11937: PUSH
11938: LD_INT 7
11940: PUSH
11941: EMPTY
11942: LIST
11943: LIST
11944: PUSH
11945: LD_VAR 0 1
11949: PUSH
11950: LD_INT 2
11952: MOD
11953: PUSH
11954: LD_INT 1
11956: PLUS
11957: ARRAY
11958: PPUSH
11959: LD_INT 100
11961: PPUSH
11962: CALL 74510 0 5
// veh := CreateVehicle ;
11966: LD_ADDR_VAR 0 2
11970: PUSH
11971: CALL_OW 45
11975: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11976: LD_VAR 0 2
11980: PPUSH
11981: LD_INT 3
11983: PPUSH
11984: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11988: LD_VAR 0 2
11992: PPUSH
11993: LD_INT 29
11995: PPUSH
11996: LD_INT 0
11998: PPUSH
11999: CALL_OW 49
// uc_nation := 3 ;
12003: LD_ADDR_OWVAR 21
12007: PUSH
12008: LD_INT 3
12010: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
12011: LD_INT 0
12013: PPUSH
12014: LD_INT 10
12016: PPUSH
12017: CALL_OW 383
// un := CreateHuman ;
12021: LD_ADDR_VAR 0 3
12025: PUSH
12026: CALL_OW 44
12030: ST_TO_ADDR
// SetTag ( un , 105 ) ;
12031: LD_VAR 0 3
12035: PPUSH
12036: LD_INT 105
12038: PPUSH
12039: CALL_OW 109
// if GetSkill ( un , skill_mechanical ) < [ 8 , 9 , 10 ] [ Difficulty ] then
12043: LD_VAR 0 3
12047: PPUSH
12048: LD_INT 3
12050: PPUSH
12051: CALL_OW 259
12055: PUSH
12056: LD_INT 8
12058: PUSH
12059: LD_INT 9
12061: PUSH
12062: LD_INT 10
12064: PUSH
12065: EMPTY
12066: LIST
12067: LIST
12068: LIST
12069: PUSH
12070: LD_OWVAR 67
12074: ARRAY
12075: LESS
12076: IFFALSE 12110
// SetSkill ( un , skill_mechanical , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
12078: LD_VAR 0 3
12082: PPUSH
12083: LD_INT 3
12085: PPUSH
12086: LD_INT 8
12088: PUSH
12089: LD_INT 9
12091: PUSH
12092: LD_INT 10
12094: PUSH
12095: EMPTY
12096: LIST
12097: LIST
12098: LIST
12099: PUSH
12100: LD_OWVAR 67
12104: ARRAY
12105: PPUSH
12106: CALL_OW 237
// PlaceHumanInUnit ( un , veh ) ;
12110: LD_VAR 0 3
12114: PPUSH
12115: LD_VAR 0 2
12119: PPUSH
12120: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
12124: LD_ADDR_EXP 78
12128: PUSH
12129: LD_EXP 78
12133: PPUSH
12134: LD_VAR 0 2
12138: PPUSH
12139: CALL 107361 0 2
12143: ST_TO_ADDR
// end ;
12144: GO 11907
12146: POP
12147: POP
// end ;
12148: PPOPN 3
12150: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
12151: LD_EXP 78
12155: IFFALSE 12664
12157: GO 12159
12159: DISABLE
12160: LD_INT 0
12162: PPUSH
12163: PPUSH
12164: PPUSH
// begin enable ;
12165: ENABLE
// if not ruMobile then
12166: LD_EXP 78
12170: NOT
12171: IFFALSE 12176
// begin disable ;
12173: DISABLE
// exit ;
12174: GO 12664
// end ; for i in ruMobile do
12176: LD_ADDR_VAR 0 1
12180: PUSH
12181: LD_EXP 78
12185: PUSH
12186: FOR_IN
12187: IFFALSE 12662
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
12189: LD_VAR 0 1
12193: PPUSH
12194: CALL_OW 302
12198: NOT
12199: PUSH
12200: LD_VAR 0 1
12204: PPUSH
12205: CALL_OW 255
12209: PUSH
12210: LD_INT 3
12212: NONEQUAL
12213: OR
12214: IFFALSE 12234
// begin ruMobile := ruMobile diff i ;
12216: LD_ADDR_EXP 78
12220: PUSH
12221: LD_EXP 78
12225: PUSH
12226: LD_VAR 0 1
12230: DIFF
12231: ST_TO_ADDR
// continue ;
12232: GO 12186
// end ; if GetTag ( i ) = 300 then
12234: LD_VAR 0 1
12238: PPUSH
12239: CALL_OW 110
12243: PUSH
12244: LD_INT 300
12246: EQUAL
12247: IFFALSE 12297
// begin ComMoveXY ( i , 160 , 81 ) ;
12249: LD_VAR 0 1
12253: PPUSH
12254: LD_INT 160
12256: PPUSH
12257: LD_INT 81
12259: PPUSH
12260: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
12264: LD_VAR 0 1
12268: PPUSH
12269: LD_INT 160
12271: PPUSH
12272: LD_INT 81
12274: PPUSH
12275: CALL_OW 297
12279: PUSH
12280: LD_INT 8
12282: LESS
12283: IFFALSE 12297
// SetTag ( i , 301 ) ;
12285: LD_VAR 0 1
12289: PPUSH
12290: LD_INT 301
12292: PPUSH
12293: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
12297: LD_VAR 0 1
12301: PPUSH
12302: CALL_OW 110
12306: PUSH
12307: LD_INT 301
12309: EQUAL
12310: IFFALSE 12353
// begin if not IsInArea ( i , ruMobileParkingArea ) then
12312: LD_VAR 0 1
12316: PPUSH
12317: LD_INT 33
12319: PPUSH
12320: CALL_OW 308
12324: NOT
12325: IFFALSE 12341
// ComMoveToArea ( i , ruMobileParkingArea ) else
12327: LD_VAR 0 1
12331: PPUSH
12332: LD_INT 33
12334: PPUSH
12335: CALL_OW 113
12339: GO 12353
// SetTag ( i , 302 ) ;
12341: LD_VAR 0 1
12345: PPUSH
12346: LD_INT 302
12348: PPUSH
12349: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
12353: LD_VAR 0 1
12357: PPUSH
12358: CALL_OW 110
12362: PUSH
12363: LD_INT 302
12365: EQUAL
12366: IFFALSE 12496
// begin if GetLives ( i ) < 1000 then
12368: LD_VAR 0 1
12372: PPUSH
12373: CALL_OW 256
12377: PUSH
12378: LD_INT 1000
12380: LESS
12381: IFFALSE 12473
// begin if not IsDrivenBy ( i ) then
12383: LD_VAR 0 1
12387: PPUSH
12388: CALL_OW 311
12392: NOT
12393: IFFALSE 12397
// continue ;
12395: GO 12186
// mech := IsDrivenBy ( i ) ;
12397: LD_ADDR_VAR 0 2
12401: PUSH
12402: LD_VAR 0 1
12406: PPUSH
12407: CALL_OW 311
12411: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
12412: LD_VAR 0 2
12416: PPUSH
12417: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
12421: LD_VAR 0 2
12425: PPUSH
12426: LD_VAR 0 1
12430: PPUSH
12431: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
12435: LD_INT 35
12437: PPUSH
12438: CALL_OW 67
// until GetLives ( i ) = 1000 ;
12442: LD_VAR 0 1
12446: PPUSH
12447: CALL_OW 256
12451: PUSH
12452: LD_INT 1000
12454: EQUAL
12455: IFFALSE 12435
// ComEnterUnit ( mech , i ) ;
12457: LD_VAR 0 2
12461: PPUSH
12462: LD_VAR 0 1
12466: PPUSH
12467: CALL_OW 120
// end else
12471: GO 12496
// if IsDrivenBy ( i ) then
12473: LD_VAR 0 1
12477: PPUSH
12478: CALL_OW 311
12482: IFFALSE 12496
// SetTag ( i , 0 ) ;
12484: LD_VAR 0 1
12488: PPUSH
12489: LD_INT 0
12491: PPUSH
12492: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
12496: LD_VAR 0 1
12500: PPUSH
12501: CALL_OW 110
12505: PUSH
12506: LD_INT 300
12508: LESS
12509: IFFALSE 12660
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
12511: LD_ADDR_VAR 0 3
12515: PUSH
12516: LD_INT 4
12518: PPUSH
12519: LD_INT 81
12521: PUSH
12522: LD_INT 3
12524: PUSH
12525: EMPTY
12526: LIST
12527: LIST
12528: PPUSH
12529: CALL_OW 70
12533: ST_TO_ADDR
// if GetLives ( i ) < 650 then
12534: LD_VAR 0 1
12538: PPUSH
12539: CALL_OW 256
12543: PUSH
12544: LD_INT 650
12546: LESS
12547: IFFALSE 12572
// begin ComStop ( i ) ;
12549: LD_VAR 0 1
12553: PPUSH
12554: CALL_OW 141
// SetTag ( i , 300 ) ;
12558: LD_VAR 0 1
12562: PPUSH
12563: LD_INT 300
12565: PPUSH
12566: CALL_OW 109
// continue ;
12570: GO 12186
// end ; if enemy then
12572: LD_VAR 0 3
12576: IFFALSE 12616
// begin if not HasTask ( i ) then
12578: LD_VAR 0 1
12582: PPUSH
12583: CALL_OW 314
12587: NOT
12588: IFFALSE 12614
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
12590: LD_VAR 0 1
12594: PPUSH
12595: LD_VAR 0 3
12599: PPUSH
12600: LD_VAR 0 1
12604: PPUSH
12605: CALL_OW 74
12609: PPUSH
12610: CALL_OW 115
// end else
12614: GO 12660
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
12616: LD_VAR 0 1
12620: PPUSH
12621: LD_INT 158
12623: PUSH
12624: LD_INT 61
12626: PUSH
12627: EMPTY
12628: LIST
12629: LIST
12630: PUSH
12631: LD_INT 98
12633: PUSH
12634: LD_INT 100
12636: PUSH
12637: EMPTY
12638: LIST
12639: LIST
12640: PUSH
12641: LD_INT 78
12643: PUSH
12644: LD_INT 93
12646: PUSH
12647: EMPTY
12648: LIST
12649: LIST
12650: PUSH
12651: EMPTY
12652: LIST
12653: LIST
12654: LIST
12655: PPUSH
12656: CALL 109965 0 2
// end ; end ;
12660: GO 12186
12662: POP
12663: POP
// end ; end_of_file
12664: PPOPN 3
12666: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport , b ; begin
12667: LD_INT 0
12669: PPUSH
12670: PPUSH
12671: PPUSH
12672: PPUSH
12673: PPUSH
12674: PPUSH
12675: PPUSH
// if Difficulty = 1 then
12676: LD_OWVAR 67
12680: PUSH
12681: LD_INT 1
12683: EQUAL
12684: IFFALSE 12722
// for i in FilterAllUnits ( [ f_inarea , delBuildingsArea ] ) do
12686: LD_ADDR_VAR 0 2
12690: PUSH
12691: LD_INT 95
12693: PUSH
12694: LD_INT 34
12696: PUSH
12697: EMPTY
12698: LIST
12699: LIST
12700: PPUSH
12701: CALL_OW 69
12705: PUSH
12706: FOR_IN
12707: IFFALSE 12720
// RemoveUnit ( i ) ;
12709: LD_VAR 0 2
12713: PPUSH
12714: CALL_OW 64
12718: GO 12706
12720: POP
12721: POP
// SetInvulnrability ( alien , true ) ;
12722: LD_INT 1
12724: PPUSH
12725: LD_INT 1
12727: PPUSH
12728: CALL_OW 607
// side := 7 ;
12732: LD_ADDR_VAR 0 5
12736: PUSH
12737: LD_INT 7
12739: ST_TO_ADDR
// uc_side := side ;
12740: LD_ADDR_OWVAR 20
12744: PUSH
12745: LD_VAR 0 5
12749: ST_TO_ADDR
// uc_nation := 1 ;
12750: LD_ADDR_OWVAR 21
12754: PUSH
12755: LD_INT 1
12757: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
12758: LD_ADDR_VAR 0 2
12762: PUSH
12763: LD_INT 22
12765: PUSH
12766: LD_VAR 0 5
12770: PUSH
12771: EMPTY
12772: LIST
12773: LIST
12774: PUSH
12775: LD_INT 21
12777: PUSH
12778: LD_INT 3
12780: PUSH
12781: EMPTY
12782: LIST
12783: LIST
12784: PUSH
12785: EMPTY
12786: LIST
12787: LIST
12788: PPUSH
12789: CALL_OW 69
12793: PUSH
12794: FOR_IN
12795: IFFALSE 12811
// SetBLevel ( i , 10 ) ;
12797: LD_VAR 0 2
12801: PPUSH
12802: LD_INT 10
12804: PPUSH
12805: CALL_OW 241
12809: GO 12794
12811: POP
12812: POP
// base := GetBase ( al_depot ) ;
12813: LD_ADDR_VAR 0 4
12817: PUSH
12818: LD_INT 2
12820: PPUSH
12821: CALL_OW 274
12825: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
12826: LD_ADDR_VAR 0 6
12830: PUSH
12831: LD_INT 22
12833: PUSH
12834: LD_VAR 0 5
12838: PUSH
12839: EMPTY
12840: LIST
12841: LIST
12842: PUSH
12843: LD_INT 30
12845: PUSH
12846: LD_INT 34
12848: PUSH
12849: EMPTY
12850: LIST
12851: LIST
12852: PUSH
12853: EMPTY
12854: LIST
12855: LIST
12856: PPUSH
12857: CALL_OW 69
12861: ST_TO_ADDR
// if teleport then
12862: LD_VAR 0 6
12866: IFFALSE 12887
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
12868: LD_VAR 0 6
12872: PUSH
12873: LD_INT 1
12875: ARRAY
12876: PPUSH
12877: LD_INT 262
12879: PPUSH
12880: LD_INT 119
12882: PPUSH
12883: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
12887: LD_VAR 0 4
12891: PPUSH
12892: LD_INT 1
12894: PPUSH
12895: LD_INT 19500
12897: PPUSH
12898: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
12902: LD_VAR 0 4
12906: PPUSH
12907: LD_INT 2
12909: PPUSH
12910: LD_INT 200
12912: PPUSH
12913: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
12917: LD_VAR 0 4
12921: PPUSH
12922: LD_INT 3
12924: PPUSH
12925: LD_INT 650
12927: PPUSH
12928: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12932: LD_ADDR_EXP 79
12936: PUSH
12937: LD_STRING Roth
12939: PPUSH
12940: CALL_OW 25
12944: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12945: LD_ADDR_EXP 80
12949: PUSH
12950: LD_STRING Simms
12952: PPUSH
12953: LD_EXP 1
12957: NOT
12958: PPUSH
12959: LD_STRING 10c_
12961: PPUSH
12962: CALL 69670 0 3
12966: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
12967: LD_EXP 80
12971: PPUSH
12972: LD_INT 4
12974: PPUSH
12975: CALL_OW 336
// if not Simms then
12979: LD_EXP 80
12983: NOT
12984: IFFALSE 13014
// begin uc_nation := 1 ;
12986: LD_ADDR_OWVAR 21
12990: PUSH
12991: LD_INT 1
12993: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12994: LD_INT 2
12996: PPUSH
12997: LD_INT 10
12999: PPUSH
13000: CALL_OW 384
// Simms := CreateHuman ;
13004: LD_ADDR_EXP 80
13008: PUSH
13009: CALL_OW 44
13013: ST_TO_ADDR
// end ; uc_nation := 3 ;
13014: LD_ADDR_OWVAR 21
13018: PUSH
13019: LD_INT 3
13021: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
13022: LD_ADDR_EXP 81
13026: PUSH
13027: LD_STRING Kirilenkova
13029: PPUSH
13030: CALL_OW 25
13034: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
13035: LD_ADDR_EXP 95
13039: PUSH
13040: LD_STRING Oblukov
13042: PPUSH
13043: CALL_OW 25
13047: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
13048: LD_ADDR_EXP 82
13052: PUSH
13053: LD_STRING Dolgov
13055: PPUSH
13056: CALL_OW 25
13060: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
13061: LD_ADDR_EXP 83
13065: PUSH
13066: LD_STRING Petrosyan
13068: PPUSH
13069: CALL_OW 25
13073: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
13074: LD_ADDR_EXP 94
13078: PUSH
13079: LD_STRING Scholtze
13081: PPUSH
13082: CALL_OW 25
13086: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
13087: LD_ADDR_EXP 93
13091: PUSH
13092: LD_STRING Kapitsova
13094: PPUSH
13095: CALL_OW 25
13099: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
13100: LD_ADDR_EXP 84
13104: PUSH
13105: LD_STRING Petrovova
13107: PPUSH
13108: CALL_OW 25
13112: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
13113: LD_ADDR_EXP 85
13117: PUSH
13118: LD_STRING Kuzmov
13120: PPUSH
13121: CALL_OW 25
13125: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
13126: LD_ADDR_EXP 92
13130: PUSH
13131: LD_STRING Karamazov
13133: PPUSH
13134: CALL_OW 25
13138: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
13139: LD_STRING 13_Lipshchin_1
13141: PPUSH
13142: LD_INT 0
13144: PPUSH
13145: CALL_OW 30
13149: IFFALSE 13164
// Lipshchin := NewCharacter ( Lipshchin ) ;
13151: LD_ADDR_EXP 86
13155: PUSH
13156: LD_STRING Lipshchin
13158: PPUSH
13159: CALL_OW 25
13163: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
13164: LD_STRING 13_Titov_1
13166: PPUSH
13167: LD_INT 0
13169: PPUSH
13170: CALL_OW 30
13174: IFFALSE 13189
// Titov := NewCharacter ( Titov ) ;
13176: LD_ADDR_EXP 88
13180: PUSH
13181: LD_STRING Titov
13183: PPUSH
13184: CALL_OW 25
13188: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
13189: LD_STRING 13_Gnyevko_1
13191: PPUSH
13192: LD_INT 0
13194: PPUSH
13195: CALL_OW 30
13199: IFFALSE 13214
// Gnyevko := NewCharacter ( Gnyevko ) ;
13201: LD_ADDR_EXP 87
13205: PUSH
13206: LD_STRING Gnyevko
13208: PPUSH
13209: CALL_OW 25
13213: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
13214: LD_STRING 13_Xavier_1
13216: PPUSH
13217: LD_INT 0
13219: PPUSH
13220: CALL_OW 30
13224: IFFALSE 13239
// Xavier := NewCharacter ( Xavier2 ) ;
13226: LD_ADDR_EXP 89
13230: PUSH
13231: LD_STRING Xavier2
13233: PPUSH
13234: CALL_OW 25
13238: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
13239: LD_STRING 13_Belkov_1
13241: PPUSH
13242: LD_INT 0
13244: PPUSH
13245: CALL_OW 30
13249: IFFALSE 13264
// Belkov := NewCharacter ( Belkov ) ;
13251: LD_ADDR_EXP 90
13255: PUSH
13256: LD_STRING Belkov
13258: PPUSH
13259: CALL_OW 25
13263: ST_TO_ADDR
// if not BurlakStatus then
13264: LD_EXP 9
13268: NOT
13269: IFFALSE 13284
// Burlak = NewCharacter ( Burlak ) ;
13271: LD_ADDR_EXP 91
13275: PUSH
13276: LD_STRING Burlak
13278: PPUSH
13279: CALL_OW 25
13283: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
13284: LD_ADDR_VAR 0 3
13288: PUSH
13289: LD_EXP 79
13293: PUSH
13294: LD_EXP 81
13298: PUSH
13299: LD_EXP 95
13303: PUSH
13304: LD_EXP 82
13308: PUSH
13309: LD_EXP 83
13313: PUSH
13314: LD_EXP 94
13318: PUSH
13319: LD_EXP 93
13323: PUSH
13324: LD_EXP 84
13328: PUSH
13329: LD_EXP 85
13333: PUSH
13334: LD_EXP 92
13338: PUSH
13339: EMPTY
13340: LIST
13341: LIST
13342: LIST
13343: LIST
13344: LIST
13345: LIST
13346: LIST
13347: LIST
13348: LIST
13349: LIST
13350: ST_TO_ADDR
// if Simms then
13351: LD_EXP 80
13355: IFFALSE 13373
// tmp := tmp ^ Simms ;
13357: LD_ADDR_VAR 0 3
13361: PUSH
13362: LD_VAR 0 3
13366: PUSH
13367: LD_EXP 80
13371: ADD
13372: ST_TO_ADDR
// if Titov then
13373: LD_EXP 88
13377: IFFALSE 13395
// tmp := tmp ^ Titov ;
13379: LD_ADDR_VAR 0 3
13383: PUSH
13384: LD_VAR 0 3
13388: PUSH
13389: LD_EXP 88
13393: ADD
13394: ST_TO_ADDR
// if Lipshchin then
13395: LD_EXP 86
13399: IFFALSE 13417
// tmp := tmp ^ Lipshchin ;
13401: LD_ADDR_VAR 0 3
13405: PUSH
13406: LD_VAR 0 3
13410: PUSH
13411: LD_EXP 86
13415: ADD
13416: ST_TO_ADDR
// if Gnyevko then
13417: LD_EXP 87
13421: IFFALSE 13439
// tmp := tmp ^ Gnyevko ;
13423: LD_ADDR_VAR 0 3
13427: PUSH
13428: LD_VAR 0 3
13432: PUSH
13433: LD_EXP 87
13437: ADD
13438: ST_TO_ADDR
// if Xavier then
13439: LD_EXP 89
13443: IFFALSE 13461
// tmp := tmp ^ Xavier ;
13445: LD_ADDR_VAR 0 3
13449: PUSH
13450: LD_VAR 0 3
13454: PUSH
13455: LD_EXP 89
13459: ADD
13460: ST_TO_ADDR
// if Belkov then
13461: LD_EXP 90
13465: IFFALSE 13483
// tmp := tmp ^ Belkov ;
13467: LD_ADDR_VAR 0 3
13471: PUSH
13472: LD_VAR 0 3
13476: PUSH
13477: LD_EXP 90
13481: ADD
13482: ST_TO_ADDR
// if Burlak then
13483: LD_EXP 91
13487: IFFALSE 13505
// tmp := tmp ^ Burlak ;
13489: LD_ADDR_VAR 0 3
13493: PUSH
13494: LD_VAR 0 3
13498: PUSH
13499: LD_EXP 91
13503: ADD
13504: ST_TO_ADDR
// for i = 1 to 11 do
13505: LD_ADDR_VAR 0 2
13509: PUSH
13510: DOUBLE
13511: LD_INT 1
13513: DEC
13514: ST_TO_ADDR
13515: LD_INT 11
13517: PUSH
13518: FOR_TO
13519: IFFALSE 13587
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
13521: LD_ADDR_OWVAR 21
13525: PUSH
13526: LD_INT 1
13528: PUSH
13529: LD_INT 3
13531: PUSH
13532: EMPTY
13533: LIST
13534: LIST
13535: PUSH
13536: LD_INT 1
13538: PPUSH
13539: LD_INT 2
13541: PPUSH
13542: CALL_OW 12
13546: ARRAY
13547: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 10 ) ;
13548: LD_INT 0
13550: PPUSH
13551: LD_INT 1
13553: PPUSH
13554: LD_INT 4
13556: PPUSH
13557: CALL_OW 12
13561: PPUSH
13562: LD_INT 10
13564: PPUSH
13565: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
13569: LD_ADDR_VAR 0 3
13573: PUSH
13574: LD_VAR 0 3
13578: PUSH
13579: CALL_OW 44
13583: ADD
13584: ST_TO_ADDR
// end ;
13585: GO 13518
13587: POP
13588: POP
// for i in tmp do
13589: LD_ADDR_VAR 0 2
13593: PUSH
13594: LD_VAR 0 3
13598: PUSH
13599: FOR_IN
13600: IFFALSE 13625
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
13602: LD_VAR 0 2
13606: PPUSH
13607: LD_INT 260
13609: PPUSH
13610: LD_INT 235
13612: PPUSH
13613: LD_INT 8
13615: PPUSH
13616: LD_INT 0
13618: PPUSH
13619: CALL_OW 50
13623: GO 13599
13625: POP
13626: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
13627: LD_ADDR_EXP 102
13631: PUSH
13632: LD_EXP 102
13636: PPUSH
13637: LD_INT 1
13639: PPUSH
13640: LD_INT 22
13642: PUSH
13643: LD_VAR 0 5
13647: PUSH
13648: EMPTY
13649: LIST
13650: LIST
13651: PUSH
13652: LD_INT 3
13654: PUSH
13655: LD_INT 21
13657: PUSH
13658: LD_INT 2
13660: PUSH
13661: EMPTY
13662: LIST
13663: LIST
13664: PUSH
13665: EMPTY
13666: LIST
13667: LIST
13668: PUSH
13669: EMPTY
13670: LIST
13671: LIST
13672: PPUSH
13673: CALL_OW 69
13677: PUSH
13678: LD_EXP 79
13682: PUSH
13683: LD_EXP 80
13687: PUSH
13688: EMPTY
13689: LIST
13690: LIST
13691: DIFF
13692: PPUSH
13693: CALL_OW 1
13697: ST_TO_ADDR
// uc_side := 0 ;
13698: LD_ADDR_OWVAR 20
13702: PUSH
13703: LD_INT 0
13705: ST_TO_ADDR
// uc_nation := 0 ;
13706: LD_ADDR_OWVAR 21
13710: PUSH
13711: LD_INT 0
13713: ST_TO_ADDR
// for i = 1 to 5 do
13714: LD_ADDR_VAR 0 2
13718: PUSH
13719: DOUBLE
13720: LD_INT 1
13722: DEC
13723: ST_TO_ADDR
13724: LD_INT 5
13726: PUSH
13727: FOR_TO
13728: IFFALSE 13765
// begin InitHc ;
13730: CALL_OW 19
// hc_class := class_apeman ;
13734: LD_ADDR_OWVAR 28
13738: PUSH
13739: LD_INT 12
13741: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
13742: CALL_OW 44
13746: PPUSH
13747: LD_INT 299
13749: PPUSH
13750: LD_INT 229
13752: PPUSH
13753: LD_INT 10
13755: PPUSH
13756: LD_INT 0
13758: PPUSH
13759: CALL_OW 50
// end ;
13763: GO 13727
13765: POP
13766: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
13767: LD_EXP 79
13771: PPUSH
13772: LD_INT 259
13774: PPUSH
13775: LD_INT 235
13777: PPUSH
13778: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
13782: LD_EXP 79
13786: PPUSH
13787: LD_INT 262
13789: PPUSH
13790: LD_INT 235
13792: PPUSH
13793: CALL_OW 178
// if Simms then
13797: LD_EXP 80
13801: IFFALSE 13832
// begin ComMoveXY ( Simms , 262 , 235 ) ;
13803: LD_EXP 80
13807: PPUSH
13808: LD_INT 262
13810: PPUSH
13811: LD_INT 235
13813: PPUSH
13814: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
13818: LD_EXP 80
13822: PPUSH
13823: LD_EXP 79
13827: PPUSH
13828: CALL_OW 179
// end ; uc_side := 7 ;
13832: LD_ADDR_OWVAR 20
13836: PUSH
13837: LD_INT 7
13839: ST_TO_ADDR
// uc_nation := 1 ;
13840: LD_ADDR_OWVAR 21
13844: PUSH
13845: LD_INT 1
13847: ST_TO_ADDR
// bc_type := b_control_tower ;
13848: LD_ADDR_OWVAR 42
13852: PUSH
13853: LD_INT 36
13855: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 268 , 251 , 4 ) ;
13856: LD_ADDR_VAR 0 7
13860: PUSH
13861: LD_INT 268
13863: PPUSH
13864: LD_INT 251
13866: PPUSH
13867: LD_INT 4
13869: PPUSH
13870: CALL_OW 47
13874: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
13875: LD_INT 0
13877: PPUSH
13878: LD_INT 10
13880: PPUSH
13881: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , b ) ;
13885: CALL_OW 44
13889: PPUSH
13890: LD_VAR 0 7
13894: PPUSH
13895: CALL_OW 52
// end ;
13899: LD_VAR 0 1
13903: RET
// every 9 9$00 trigger allianceActive and not allianceDestroyed and FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_lab_full ] ] ) do var i , tmp , target ;
13904: LD_EXP 31
13908: PUSH
13909: LD_EXP 23
13913: NOT
13914: AND
13915: PUSH
13916: LD_INT 22
13918: PUSH
13919: LD_INT 7
13921: PUSH
13922: EMPTY
13923: LIST
13924: LIST
13925: PUSH
13926: LD_INT 30
13928: PUSH
13929: LD_INT 8
13931: PUSH
13932: EMPTY
13933: LIST
13934: LIST
13935: PUSH
13936: EMPTY
13937: LIST
13938: LIST
13939: PPUSH
13940: CALL_OW 69
13944: AND
13945: IFFALSE 14173
13947: GO 13949
13949: DISABLE
13950: LD_INT 0
13952: PPUSH
13953: PPUSH
13954: PPUSH
// begin enable ;
13955: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
13956: LD_ADDR_VAR 0 2
13960: PUSH
13961: LD_INT 81
13963: PUSH
13964: LD_INT 7
13966: PUSH
13967: EMPTY
13968: LIST
13969: LIST
13970: PUSH
13971: LD_INT 2
13973: PUSH
13974: LD_INT 32
13976: PUSH
13977: LD_INT 3
13979: PUSH
13980: EMPTY
13981: LIST
13982: LIST
13983: PUSH
13984: LD_INT 30
13986: PUSH
13987: LD_INT 30
13989: PUSH
13990: EMPTY
13991: LIST
13992: LIST
13993: PUSH
13994: LD_INT 30
13996: PUSH
13997: LD_INT 28
13999: PUSH
14000: EMPTY
14001: LIST
14002: LIST
14003: PUSH
14004: LD_INT 34
14006: PUSH
14007: LD_INT 49
14009: PUSH
14010: EMPTY
14011: LIST
14012: LIST
14013: PUSH
14014: LD_INT 34
14016: PUSH
14017: LD_INT 10
14019: PUSH
14020: EMPTY
14021: LIST
14022: LIST
14023: PUSH
14024: LD_INT 34
14026: PUSH
14027: LD_INT 8
14029: PUSH
14030: EMPTY
14031: LIST
14032: LIST
14033: PUSH
14034: EMPTY
14035: LIST
14036: LIST
14037: LIST
14038: LIST
14039: LIST
14040: LIST
14041: LIST
14042: PUSH
14043: EMPTY
14044: LIST
14045: LIST
14046: PPUSH
14047: CALL_OW 69
14051: ST_TO_ADDR
// if not tmp then
14052: LD_VAR 0 2
14056: NOT
14057: IFFALSE 14061
// exit ;
14059: GO 14173
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
14061: LD_VAR 0 2
14065: PPUSH
14066: LD_INT 34
14068: PUSH
14069: LD_INT 8
14071: PUSH
14072: EMPTY
14073: LIST
14074: LIST
14075: PPUSH
14076: CALL_OW 72
14080: IFFALSE 14113
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
14082: LD_ADDR_VAR 0 3
14086: PUSH
14087: LD_VAR 0 2
14091: PPUSH
14092: LD_INT 34
14094: PUSH
14095: LD_INT 8
14097: PUSH
14098: EMPTY
14099: LIST
14100: LIST
14101: PPUSH
14102: CALL_OW 72
14106: PUSH
14107: LD_INT 1
14109: ARRAY
14110: ST_TO_ADDR
14111: GO 14137
// target := tmp [ rand ( 1 , tmp ) ] ;
14113: LD_ADDR_VAR 0 3
14117: PUSH
14118: LD_VAR 0 2
14122: PUSH
14123: LD_INT 1
14125: PPUSH
14126: LD_VAR 0 2
14130: PPUSH
14131: CALL_OW 12
14135: ARRAY
14136: ST_TO_ADDR
// if GetSide ( target ) = 1 then
14137: LD_VAR 0 3
14141: PPUSH
14142: CALL_OW 255
14146: PUSH
14147: LD_INT 1
14149: EQUAL
14150: IFFALSE 14161
// CenterNowOnUnits ( target ) ;
14152: LD_VAR 0 3
14156: PPUSH
14157: CALL_OW 87
// SetLives ( target , 0 ) ;
14161: LD_VAR 0 3
14165: PPUSH
14166: LD_INT 0
14168: PPUSH
14169: CALL_OW 234
// end ;
14173: PPOPN 3
14175: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
14176: LD_EXP 23
14180: NOT
14181: PUSH
14182: LD_EXP 31
14186: AND
14187: IFFALSE 14703
14189: GO 14191
14191: DISABLE
14192: LD_INT 0
14194: PPUSH
14195: PPUSH
14196: PPUSH
// begin uc_side := 7 ;
14197: LD_ADDR_OWVAR 20
14201: PUSH
14202: LD_INT 7
14204: ST_TO_ADDR
// uc_nation := 1 ;
14205: LD_ADDR_OWVAR 21
14209: PUSH
14210: LD_INT 1
14212: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] , [ 94 , 114 ] ] ) ;
14213: LD_ADDR_VAR 0 3
14217: PUSH
14218: LD_INT 125
14220: PUSH
14221: LD_INT 163
14223: PUSH
14224: EMPTY
14225: LIST
14226: LIST
14227: PUSH
14228: LD_INT 185
14230: PUSH
14231: LD_INT 168
14233: PUSH
14234: EMPTY
14235: LIST
14236: LIST
14237: PUSH
14238: LD_INT 111
14240: PUSH
14241: LD_INT 97
14243: PUSH
14244: EMPTY
14245: LIST
14246: LIST
14247: PUSH
14248: LD_INT 94
14250: PUSH
14251: LD_INT 114
14253: PUSH
14254: EMPTY
14255: LIST
14256: LIST
14257: PUSH
14258: EMPTY
14259: LIST
14260: LIST
14261: LIST
14262: LIST
14263: PPUSH
14264: CALL 107466 0 1
14268: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
14269: LD_ADDR_EXP 96
14273: PUSH
14274: EMPTY
14275: ST_TO_ADDR
// for i = 1 to Difficulty do
14276: LD_ADDR_VAR 0 1
14280: PUSH
14281: DOUBLE
14282: LD_INT 1
14284: DEC
14285: ST_TO_ADDR
14286: LD_OWVAR 67
14290: PUSH
14291: FOR_TO
14292: IFFALSE 14450
// begin InitHc ;
14294: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
14298: LD_INT 0
14300: PPUSH
14301: LD_INT 8
14303: PPUSH
14304: CALL_OW 381
// un := CreateHuman ;
14308: LD_ADDR_VAR 0 2
14312: PUSH
14313: CALL_OW 44
14317: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
14318: LD_VAR 0 2
14322: PPUSH
14323: LD_INT 258
14325: PPUSH
14326: LD_INT 267
14328: PPUSH
14329: LD_INT 4
14331: PPUSH
14332: LD_INT 0
14334: PPUSH
14335: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
14339: LD_ADDR_EXP 96
14343: PUSH
14344: LD_EXP 96
14348: PUSH
14349: LD_VAR 0 2
14353: UNION
14354: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
14355: LD_VAR 0 2
14359: PPUSH
14360: LD_VAR 0 3
14364: PUSH
14365: LD_VAR 0 1
14369: ARRAY
14370: PUSH
14371: LD_INT 1
14373: ARRAY
14374: PPUSH
14375: LD_VAR 0 3
14379: PUSH
14380: LD_VAR 0 1
14384: ARRAY
14385: PUSH
14386: LD_INT 2
14388: ARRAY
14389: PPUSH
14390: LD_INT 4
14392: PPUSH
14393: LD_INT 1
14395: PPUSH
14396: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
14400: LD_VAR 0 2
14404: PPUSH
14405: LD_VAR 0 3
14409: PUSH
14410: LD_VAR 0 1
14414: ARRAY
14415: PUSH
14416: LD_INT 1
14418: ARRAY
14419: PPUSH
14420: LD_VAR 0 3
14424: PUSH
14425: LD_VAR 0 1
14429: ARRAY
14430: PUSH
14431: LD_INT 2
14433: ARRAY
14434: PPUSH
14435: CALL_OW 171
// AddComInvisible ( un ) ;
14439: LD_VAR 0 2
14443: PPUSH
14444: CALL_OW 212
// end ;
14448: GO 14291
14450: POP
14451: POP
// repeat wait ( 0 0$45 ) ;
14452: LD_INT 1575
14454: PPUSH
14455: CALL_OW 67
// for i in allianceSpecialForce do
14459: LD_ADDR_VAR 0 1
14463: PUSH
14464: LD_EXP 96
14468: PUSH
14469: FOR_IN
14470: IFFALSE 14688
// begin if IsInvisible ( i ) then
14472: LD_VAR 0 1
14476: PPUSH
14477: CALL_OW 571
14481: IFFALSE 14657
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , 25 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
14483: LD_ADDR_VAR 0 3
14487: PUSH
14488: LD_INT 22
14490: PUSH
14491: LD_INT 1
14493: PUSH
14494: EMPTY
14495: LIST
14496: LIST
14497: PUSH
14498: LD_INT 50
14500: PUSH
14501: EMPTY
14502: LIST
14503: PUSH
14504: LD_INT 56
14506: PUSH
14507: EMPTY
14508: LIST
14509: PUSH
14510: LD_INT 91
14512: PUSH
14513: LD_VAR 0 1
14517: PUSH
14518: LD_INT 25
14520: PUSH
14521: EMPTY
14522: LIST
14523: LIST
14524: LIST
14525: PUSH
14526: LD_INT 2
14528: PUSH
14529: LD_INT 25
14531: PUSH
14532: LD_INT 1
14534: PUSH
14535: EMPTY
14536: LIST
14537: LIST
14538: PUSH
14539: LD_INT 25
14541: PUSH
14542: LD_INT 2
14544: PUSH
14545: EMPTY
14546: LIST
14547: LIST
14548: PUSH
14549: LD_INT 25
14551: PUSH
14552: LD_INT 3
14554: PUSH
14555: EMPTY
14556: LIST
14557: LIST
14558: PUSH
14559: LD_INT 25
14561: PUSH
14562: LD_INT 4
14564: PUSH
14565: EMPTY
14566: LIST
14567: LIST
14568: PUSH
14569: LD_INT 25
14571: PUSH
14572: LD_INT 5
14574: PUSH
14575: EMPTY
14576: LIST
14577: LIST
14578: PUSH
14579: LD_INT 25
14581: PUSH
14582: LD_INT 8
14584: PUSH
14585: EMPTY
14586: LIST
14587: LIST
14588: PUSH
14589: EMPTY
14590: LIST
14591: LIST
14592: LIST
14593: LIST
14594: LIST
14595: LIST
14596: LIST
14597: PUSH
14598: EMPTY
14599: LIST
14600: LIST
14601: LIST
14602: LIST
14603: LIST
14604: PPUSH
14605: CALL_OW 69
14609: ST_TO_ADDR
// if not tmp then
14610: LD_VAR 0 3
14614: NOT
14615: IFFALSE 14619
// continue ;
14617: GO 14469
// if Prob ( 30 * Difficulty ) then
14619: LD_INT 30
14621: PUSH
14622: LD_OWVAR 67
14626: MUL
14627: PPUSH
14628: CALL_OW 13
14632: IFFALSE 14657
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
14634: LD_VAR 0 3
14638: PUSH
14639: LD_INT 1
14641: PPUSH
14642: LD_VAR 0 3
14646: PPUSH
14647: CALL_OW 12
14651: ARRAY
14652: PPUSH
14653: CALL 34760 0 1
// end ; if IsDead ( i ) then
14657: LD_VAR 0 1
14661: PPUSH
14662: CALL_OW 301
14666: IFFALSE 14686
// begin allianceSpecialForce := allianceSpecialForce diff i ;
14668: LD_ADDR_EXP 96
14672: PUSH
14673: LD_EXP 96
14677: PUSH
14678: LD_VAR 0 1
14682: DIFF
14683: ST_TO_ADDR
// continue ;
14684: GO 14469
// end ; end ;
14686: GO 14469
14688: POP
14689: POP
// until allianceDestroyed or not allianceSpecialForce ;
14690: LD_EXP 23
14694: PUSH
14695: LD_EXP 96
14699: NOT
14700: OR
14701: IFFALSE 14452
// end ;
14703: PPOPN 3
14705: END
// every 0 0$30 trigger allianceActive and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_bweapon , us_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ] ) do var i , un , tmp , e ;
14706: LD_EXP 31
14710: PUSH
14711: LD_INT 22
14713: PUSH
14714: LD_INT 1
14716: PUSH
14717: EMPTY
14718: LIST
14719: LIST
14720: PUSH
14721: LD_INT 2
14723: PUSH
14724: LD_INT 35
14726: PUSH
14727: LD_INT 8
14729: PUSH
14730: EMPTY
14731: LIST
14732: LIST
14733: PUSH
14734: LD_INT 34
14736: PUSH
14737: LD_INT 8
14739: PUSH
14740: EMPTY
14741: LIST
14742: LIST
14743: PUSH
14744: EMPTY
14745: LIST
14746: LIST
14747: LIST
14748: PUSH
14749: EMPTY
14750: LIST
14751: LIST
14752: PPUSH
14753: CALL_OW 69
14757: AND
14758: IFFALSE 15158
14760: GO 14762
14762: DISABLE
14763: LD_INT 0
14765: PPUSH
14766: PPUSH
14767: PPUSH
14768: PPUSH
// begin for i := 1 to [ 6 , 8 , 10 , 12 ] [ Difficulty ] do
14769: LD_ADDR_VAR 0 1
14773: PUSH
14774: DOUBLE
14775: LD_INT 1
14777: DEC
14778: ST_TO_ADDR
14779: LD_INT 6
14781: PUSH
14782: LD_INT 8
14784: PUSH
14785: LD_INT 10
14787: PUSH
14788: LD_INT 12
14790: PUSH
14791: EMPTY
14792: LIST
14793: LIST
14794: LIST
14795: LIST
14796: PUSH
14797: LD_OWVAR 67
14801: ARRAY
14802: PUSH
14803: FOR_TO
14804: IFFALSE 14996
// begin uc_side := 7 ;
14806: LD_ADDR_OWVAR 20
14810: PUSH
14811: LD_INT 7
14813: ST_TO_ADDR
// uc_nation := 1 ;
14814: LD_ADDR_OWVAR 21
14818: PUSH
14819: LD_INT 1
14821: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , [ control_remote , control_computer ] [ rand ( 1 , 2 ) ] , [ us_heavy_gun , us_laser ] [ rand ( 1 , 2 ) ] , 100 ) ;
14822: LD_INT 5
14824: PPUSH
14825: LD_INT 3
14827: PPUSH
14828: LD_INT 2
14830: PUSH
14831: LD_INT 3
14833: PUSH
14834: EMPTY
14835: LIST
14836: LIST
14837: PUSH
14838: LD_INT 1
14840: PPUSH
14841: LD_INT 2
14843: PPUSH
14844: CALL_OW 12
14848: ARRAY
14849: PPUSH
14850: LD_INT 6
14852: PUSH
14853: LD_INT 9
14855: PUSH
14856: EMPTY
14857: LIST
14858: LIST
14859: PUSH
14860: LD_INT 1
14862: PPUSH
14863: LD_INT 2
14865: PPUSH
14866: CALL_OW 12
14870: ARRAY
14871: PPUSH
14872: LD_INT 100
14874: PPUSH
14875: CALL 74510 0 5
// un := CreateVehicle ;
14879: LD_ADDR_VAR 0 2
14883: PUSH
14884: CALL_OW 45
14888: ST_TO_ADDR
// SetDir ( un , 4 ) ;
14889: LD_VAR 0 2
14893: PPUSH
14894: LD_INT 4
14896: PPUSH
14897: CALL_OW 233
// PlaceUnitXYR ( un , 307 , 219 , 6 , false ) ;
14901: LD_VAR 0 2
14905: PPUSH
14906: LD_INT 307
14908: PPUSH
14909: LD_INT 219
14911: PPUSH
14912: LD_INT 6
14914: PPUSH
14915: LD_INT 0
14917: PPUSH
14918: CALL_OW 50
// if GetControl ( un ) = control_remote then
14922: LD_VAR 0 2
14926: PPUSH
14927: CALL_OW 263
14931: PUSH
14932: LD_INT 2
14934: EQUAL
14935: IFFALSE 14946
// Connect ( un ) ;
14937: LD_VAR 0 2
14941: PPUSH
14942: CALL 77978 0 1
// TeleportUnit ( un , 124 , 92 , 12 , true ) ;
14946: LD_VAR 0 2
14950: PPUSH
14951: LD_INT 124
14953: PPUSH
14954: LD_INT 92
14956: PPUSH
14957: LD_INT 12
14959: PPUSH
14960: LD_INT 1
14962: PPUSH
14963: CALL_OW 483
// tmp := Join ( tmp , un ) ;
14967: LD_ADDR_VAR 0 3
14971: PUSH
14972: LD_VAR 0 3
14976: PPUSH
14977: LD_VAR 0 2
14981: PPUSH
14982: CALL 107361 0 2
14986: ST_TO_ADDR
// wait ( 0 0$0.3 ) ;
14987: LD_INT 10
14989: PPUSH
14990: CALL_OW 67
// end ;
14994: GO 14803
14996: POP
14997: POP
// repeat wait ( 0 0$2 ) ;
14998: LD_INT 70
15000: PPUSH
15001: CALL_OW 67
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) ;
15005: LD_ADDR_VAR 0 4
15009: PUSH
15010: LD_INT 22
15012: PUSH
15013: LD_INT 1
15015: PUSH
15016: EMPTY
15017: LIST
15018: LIST
15019: PUSH
15020: LD_INT 34
15022: PUSH
15023: LD_INT 8
15025: PUSH
15026: EMPTY
15027: LIST
15028: LIST
15029: PUSH
15030: EMPTY
15031: LIST
15032: LIST
15033: PPUSH
15034: CALL_OW 69
15038: ST_TO_ADDR
// if not e then
15039: LD_VAR 0 4
15043: NOT
15044: IFFALSE 15080
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
15046: LD_ADDR_VAR 0 4
15050: PUSH
15051: LD_INT 22
15053: PUSH
15054: LD_INT 1
15056: PUSH
15057: EMPTY
15058: LIST
15059: LIST
15060: PUSH
15061: LD_INT 21
15063: PUSH
15064: LD_INT 2
15066: PUSH
15067: EMPTY
15068: LIST
15069: LIST
15070: PUSH
15071: EMPTY
15072: LIST
15073: LIST
15074: PPUSH
15075: CALL_OW 69
15079: ST_TO_ADDR
// for i in tmp do
15080: LD_ADDR_VAR 0 1
15084: PUSH
15085: LD_VAR 0 3
15089: PUSH
15090: FOR_IN
15091: IFFALSE 15149
// if not IsOK ( i ) then
15093: LD_VAR 0 1
15097: PPUSH
15098: CALL_OW 302
15102: NOT
15103: IFFALSE 15123
// tmp := tmp diff i else
15105: LD_ADDR_VAR 0 3
15109: PUSH
15110: LD_VAR 0 3
15114: PUSH
15115: LD_VAR 0 1
15119: DIFF
15120: ST_TO_ADDR
15121: GO 15147
// ComAttackUnit ( i , NearestUnitToUnit ( e , i ) ) ;
15123: LD_VAR 0 1
15127: PPUSH
15128: LD_VAR 0 4
15132: PPUSH
15133: LD_VAR 0 1
15137: PPUSH
15138: CALL_OW 74
15142: PPUSH
15143: CALL_OW 115
15147: GO 15090
15149: POP
15150: POP
// until not tmp ;
15151: LD_VAR 0 3
15155: NOT
15156: IFFALSE 14998
// end ;
15158: PPOPN 4
15160: END
// every 8 8$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport , p ;
15161: LD_EXP 23
15165: NOT
15166: PUSH
15167: LD_EXP 31
15171: AND
15172: IFFALSE 16246
15174: GO 15176
15176: DISABLE
15177: LD_INT 0
15179: PPUSH
15180: PPUSH
15181: PPUSH
15182: PPUSH
15183: PPUSH
// begin enable ;
15184: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
15185: LD_INT 22
15187: PUSH
15188: LD_INT 7
15190: PUSH
15191: EMPTY
15192: LIST
15193: LIST
15194: PUSH
15195: LD_INT 30
15197: PUSH
15198: LD_INT 3
15200: PUSH
15201: EMPTY
15202: LIST
15203: LIST
15204: PUSH
15205: EMPTY
15206: LIST
15207: LIST
15208: PPUSH
15209: CALL_OW 69
15213: NOT
15214: IFFALSE 15218
// exit ;
15216: GO 16246
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
15218: LD_ADDR_VAR 0 4
15222: PUSH
15223: LD_INT 22
15225: PUSH
15226: LD_INT 7
15228: PUSH
15229: EMPTY
15230: LIST
15231: LIST
15232: PUSH
15233: LD_INT 30
15235: PUSH
15236: LD_INT 34
15238: PUSH
15239: EMPTY
15240: LIST
15241: LIST
15242: PUSH
15243: EMPTY
15244: LIST
15245: LIST
15246: PPUSH
15247: CALL_OW 69
15251: ST_TO_ADDR
// if Prob ( 40 ) then
15252: LD_INT 40
15254: PPUSH
15255: CALL_OW 13
15259: IFFALSE 15405
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
15261: LD_INT 1
15263: PPUSH
15264: LD_INT 5
15266: PUSH
15267: LD_INT 3
15269: PUSH
15270: LD_INT 2
15272: PUSH
15273: LD_INT 6
15275: PUSH
15276: EMPTY
15277: LIST
15278: LIST
15279: LIST
15280: LIST
15281: PUSH
15282: LD_INT 5
15284: PUSH
15285: LD_INT 3
15287: PUSH
15288: LD_INT 2
15290: PUSH
15291: LD_INT 6
15293: PUSH
15294: EMPTY
15295: LIST
15296: LIST
15297: LIST
15298: LIST
15299: PUSH
15300: LD_INT 5
15302: PUSH
15303: LD_INT 3
15305: PUSH
15306: LD_INT 2
15308: PUSH
15309: LD_INT 6
15311: PUSH
15312: EMPTY
15313: LIST
15314: LIST
15315: LIST
15316: LIST
15317: PUSH
15318: LD_INT 5
15320: PUSH
15321: LD_INT 3
15323: PUSH
15324: LD_INT 2
15326: PUSH
15327: LD_INT 9
15329: PUSH
15330: EMPTY
15331: LIST
15332: LIST
15333: LIST
15334: LIST
15335: PUSH
15336: LD_INT 24
15338: PUSH
15339: LD_INT 3
15341: PUSH
15342: LD_INT 3
15344: PUSH
15345: LD_INT 45
15347: PUSH
15348: EMPTY
15349: LIST
15350: LIST
15351: LIST
15352: LIST
15353: PUSH
15354: LD_INT 24
15356: PUSH
15357: LD_INT 3
15359: PUSH
15360: LD_INT 3
15362: PUSH
15363: LD_INT 47
15365: PUSH
15366: EMPTY
15367: LIST
15368: LIST
15369: LIST
15370: LIST
15371: PUSH
15372: LD_INT 24
15374: PUSH
15375: LD_INT 3
15377: PUSH
15378: LD_INT 3
15380: PUSH
15381: LD_INT 45
15383: PUSH
15384: EMPTY
15385: LIST
15386: LIST
15387: LIST
15388: LIST
15389: PUSH
15390: EMPTY
15391: LIST
15392: LIST
15393: LIST
15394: LIST
15395: LIST
15396: LIST
15397: LIST
15398: PPUSH
15399: CALL 63244 0 2
// end else
15403: GO 15547
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
15405: LD_INT 1
15407: PPUSH
15408: LD_INT 24
15410: PUSH
15411: LD_INT 3
15413: PUSH
15414: LD_INT 3
15416: PUSH
15417: LD_INT 47
15419: PUSH
15420: EMPTY
15421: LIST
15422: LIST
15423: LIST
15424: LIST
15425: PUSH
15426: LD_INT 24
15428: PUSH
15429: LD_INT 3
15431: PUSH
15432: LD_INT 3
15434: PUSH
15435: LD_INT 47
15437: PUSH
15438: EMPTY
15439: LIST
15440: LIST
15441: LIST
15442: LIST
15443: PUSH
15444: LD_INT 5
15446: PUSH
15447: LD_INT 3
15449: PUSH
15450: LD_INT 2
15452: PUSH
15453: LD_INT 9
15455: PUSH
15456: EMPTY
15457: LIST
15458: LIST
15459: LIST
15460: LIST
15461: PUSH
15462: LD_INT 5
15464: PUSH
15465: LD_INT 3
15467: PUSH
15468: LD_INT 2
15470: PUSH
15471: LD_INT 9
15473: PUSH
15474: EMPTY
15475: LIST
15476: LIST
15477: LIST
15478: LIST
15479: PUSH
15480: LD_INT 5
15482: PUSH
15483: LD_INT 3
15485: PUSH
15486: LD_INT 2
15488: PUSH
15489: LD_INT 9
15491: PUSH
15492: EMPTY
15493: LIST
15494: LIST
15495: LIST
15496: LIST
15497: PUSH
15498: LD_INT 24
15500: PUSH
15501: LD_INT 1
15503: PUSH
15504: LD_INT 3
15506: PUSH
15507: LD_INT 45
15509: PUSH
15510: EMPTY
15511: LIST
15512: LIST
15513: LIST
15514: LIST
15515: PUSH
15516: LD_INT 24
15518: PUSH
15519: LD_INT 1
15521: PUSH
15522: LD_INT 3
15524: PUSH
15525: LD_INT 45
15527: PUSH
15528: EMPTY
15529: LIST
15530: LIST
15531: LIST
15532: LIST
15533: PUSH
15534: EMPTY
15535: LIST
15536: LIST
15537: LIST
15538: LIST
15539: LIST
15540: LIST
15541: LIST
15542: PPUSH
15543: CALL 63244 0 2
// end ; wait ( 2 2$00 ) ;
15547: LD_INT 4200
15549: PPUSH
15550: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_crane ] ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 1 ] ;
15554: LD_ADDR_VAR 0 2
15558: PUSH
15559: LD_INT 22
15561: PUSH
15562: LD_INT 7
15564: PUSH
15565: EMPTY
15566: LIST
15567: LIST
15568: PUSH
15569: LD_INT 21
15571: PUSH
15572: LD_INT 2
15574: PUSH
15575: EMPTY
15576: LIST
15577: LIST
15578: PUSH
15579: LD_INT 3
15581: PUSH
15582: LD_INT 34
15584: PUSH
15585: LD_INT 13
15587: PUSH
15588: EMPTY
15589: LIST
15590: LIST
15591: PUSH
15592: EMPTY
15593: LIST
15594: LIST
15595: PUSH
15596: LD_INT 3
15598: PUSH
15599: LD_INT 34
15601: PUSH
15602: LD_INT 12
15604: PUSH
15605: EMPTY
15606: LIST
15607: LIST
15608: PUSH
15609: EMPTY
15610: LIST
15611: LIST
15612: PUSH
15613: LD_INT 3
15615: PUSH
15616: LD_INT 34
15618: PUSH
15619: LD_INT 51
15621: PUSH
15622: EMPTY
15623: LIST
15624: LIST
15625: PUSH
15626: EMPTY
15627: LIST
15628: LIST
15629: PUSH
15630: LD_INT 3
15632: PUSH
15633: LD_INT 34
15635: PUSH
15636: LD_INT 52
15638: PUSH
15639: EMPTY
15640: LIST
15641: LIST
15642: PUSH
15643: EMPTY
15644: LIST
15645: LIST
15646: PUSH
15647: EMPTY
15648: LIST
15649: LIST
15650: LIST
15651: LIST
15652: LIST
15653: LIST
15654: PPUSH
15655: CALL_OW 69
15659: PUSH
15660: LD_EXP 124
15664: PUSH
15665: LD_INT 1
15667: ARRAY
15668: DIFF
15669: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
15670: LD_ADDR_EXP 121
15674: PUSH
15675: LD_EXP 121
15679: PPUSH
15680: LD_INT 1
15682: PPUSH
15683: LD_EXP 121
15687: PUSH
15688: LD_INT 1
15690: ARRAY
15691: PUSH
15692: LD_VAR 0 2
15696: DIFF
15697: PPUSH
15698: CALL_OW 1
15702: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
15703: LD_ADDR_VAR 0 3
15707: PUSH
15708: LD_INT 0
15710: PPUSH
15711: LD_INT 1
15713: PPUSH
15714: CALL_OW 12
15718: ST_TO_ADDR
// p := 0 ;
15719: LD_ADDR_VAR 0 5
15723: PUSH
15724: LD_INT 0
15726: ST_TO_ADDR
// if target then
15727: LD_VAR 0 3
15731: IFFALSE 15922
// begin for i in tmp do
15733: LD_ADDR_VAR 0 1
15737: PUSH
15738: LD_VAR 0 2
15742: PUSH
15743: FOR_IN
15744: IFFALSE 15769
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
15746: LD_VAR 0 1
15750: PPUSH
15751: LD_INT 179
15753: PPUSH
15754: LD_INT 209
15756: PPUSH
15757: LD_INT 8
15759: PPUSH
15760: LD_INT 1
15762: PPUSH
15763: CALL_OW 483
15767: GO 15743
15769: POP
15770: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15771: LD_ADDR_VAR 0 2
15775: PUSH
15776: LD_VAR 0 2
15780: PPUSH
15781: LD_INT 24
15783: PUSH
15784: LD_INT 250
15786: PUSH
15787: EMPTY
15788: LIST
15789: LIST
15790: PPUSH
15791: CALL_OW 72
15795: ST_TO_ADDR
// for i in tmp do
15796: LD_ADDR_VAR 0 1
15800: PUSH
15801: LD_VAR 0 2
15805: PUSH
15806: FOR_IN
15807: IFFALSE 15847
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
15809: LD_VAR 0 1
15813: PPUSH
15814: LD_INT 179
15816: PPUSH
15817: LD_INT 209
15819: PPUSH
15820: CALL_OW 297
15824: PUSH
15825: LD_INT 9
15827: GREATER
15828: IFFALSE 15845
// ComMoveXY ( i , 179 , 209 ) ;
15830: LD_VAR 0 1
15834: PPUSH
15835: LD_INT 179
15837: PPUSH
15838: LD_INT 209
15840: PPUSH
15841: CALL_OW 111
15845: GO 15806
15847: POP
15848: POP
// wait ( 0 0$1 ) ;
15849: LD_INT 35
15851: PPUSH
15852: CALL_OW 67
// p := Inc ( p ) ;
15856: LD_ADDR_VAR 0 5
15860: PUSH
15861: LD_VAR 0 5
15865: PPUSH
15866: CALL 108722 0 1
15870: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
15871: LD_VAR 0 2
15875: PPUSH
15876: LD_INT 92
15878: PUSH
15879: LD_INT 179
15881: PUSH
15882: LD_INT 209
15884: PUSH
15885: LD_INT 9
15887: PUSH
15888: EMPTY
15889: LIST
15890: LIST
15891: LIST
15892: LIST
15893: PPUSH
15894: CALL_OW 72
15898: PUSH
15899: LD_VAR 0 2
15903: PUSH
15904: LD_INT 1
15906: MINUS
15907: GREATEREQUAL
15908: PUSH
15909: LD_VAR 0 5
15913: PUSH
15914: LD_INT 30
15916: GREATER
15917: OR
15918: IFFALSE 15771
// end else
15920: GO 16109
// begin for i in tmp do
15922: LD_ADDR_VAR 0 1
15926: PUSH
15927: LD_VAR 0 2
15931: PUSH
15932: FOR_IN
15933: IFFALSE 15958
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
15935: LD_VAR 0 1
15939: PPUSH
15940: LD_INT 285
15942: PPUSH
15943: LD_INT 163
15945: PPUSH
15946: LD_INT 8
15948: PPUSH
15949: LD_INT 1
15951: PPUSH
15952: CALL_OW 483
15956: GO 15932
15958: POP
15959: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15960: LD_ADDR_VAR 0 2
15964: PUSH
15965: LD_VAR 0 2
15969: PPUSH
15970: LD_INT 24
15972: PUSH
15973: LD_INT 250
15975: PUSH
15976: EMPTY
15977: LIST
15978: LIST
15979: PPUSH
15980: CALL_OW 72
15984: ST_TO_ADDR
// for i in tmp do
15985: LD_ADDR_VAR 0 1
15989: PUSH
15990: LD_VAR 0 2
15994: PUSH
15995: FOR_IN
15996: IFFALSE 16036
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
15998: LD_VAR 0 1
16002: PPUSH
16003: LD_INT 285
16005: PPUSH
16006: LD_INT 163
16008: PPUSH
16009: CALL_OW 297
16013: PUSH
16014: LD_INT 9
16016: GREATER
16017: IFFALSE 16034
// ComMoveXY ( i , 285 , 163 ) ;
16019: LD_VAR 0 1
16023: PPUSH
16024: LD_INT 285
16026: PPUSH
16027: LD_INT 163
16029: PPUSH
16030: CALL_OW 111
16034: GO 15995
16036: POP
16037: POP
// wait ( 0 0$1 ) ;
16038: LD_INT 35
16040: PPUSH
16041: CALL_OW 67
// p := Inc ( p ) ;
16045: LD_ADDR_VAR 0 5
16049: PUSH
16050: LD_VAR 0 5
16054: PPUSH
16055: CALL 108722 0 1
16059: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
16060: LD_VAR 0 2
16064: PPUSH
16065: LD_INT 92
16067: PUSH
16068: LD_INT 285
16070: PUSH
16071: LD_INT 163
16073: PUSH
16074: LD_INT 9
16076: PUSH
16077: EMPTY
16078: LIST
16079: LIST
16080: LIST
16081: LIST
16082: PPUSH
16083: CALL_OW 72
16087: PUSH
16088: LD_VAR 0 2
16092: PUSH
16093: LD_INT 1
16095: MINUS
16096: GREATEREQUAL
16097: PUSH
16098: LD_VAR 0 5
16102: PUSH
16103: LD_INT 30
16105: GREATER
16106: OR
16107: IFFALSE 15960
// end ; repeat wait ( 0 0$1 ) ;
16109: LD_INT 35
16111: PPUSH
16112: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
16116: LD_ADDR_VAR 0 2
16120: PUSH
16121: LD_VAR 0 2
16125: PPUSH
16126: LD_INT 50
16128: PUSH
16129: EMPTY
16130: LIST
16131: PPUSH
16132: CALL_OW 72
16136: ST_TO_ADDR
// for i in tmp do
16137: LD_ADDR_VAR 0 1
16141: PUSH
16142: LD_VAR 0 2
16146: PUSH
16147: FOR_IN
16148: IFFALSE 16237
// if GetWeapon ( i ) = ru_time_lapser then
16150: LD_VAR 0 1
16154: PPUSH
16155: CALL_OW 264
16159: PUSH
16160: LD_INT 49
16162: EQUAL
16163: IFFALSE 16201
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
16165: LD_VAR 0 1
16169: PPUSH
16170: LD_INT 81
16172: PUSH
16173: LD_INT 7
16175: PUSH
16176: EMPTY
16177: LIST
16178: LIST
16179: PPUSH
16180: CALL_OW 69
16184: PPUSH
16185: LD_VAR 0 1
16189: PPUSH
16190: CALL_OW 74
16194: PPUSH
16195: CALL_OW 112
16199: GO 16235
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
16201: LD_VAR 0 1
16205: PPUSH
16206: LD_INT 81
16208: PUSH
16209: LD_INT 7
16211: PUSH
16212: EMPTY
16213: LIST
16214: LIST
16215: PPUSH
16216: CALL_OW 69
16220: PPUSH
16221: LD_VAR 0 1
16225: PPUSH
16226: CALL_OW 74
16230: PPUSH
16231: CALL_OW 115
16235: GO 16147
16237: POP
16238: POP
// until not tmp ;
16239: LD_VAR 0 2
16243: NOT
16244: IFFALSE 16109
// end ;
16246: PPOPN 5
16248: END
// every 1 1$30 trigger allianceActive and IsOk ( Roth ) and Difficulty > 2 do
16249: LD_EXP 31
16253: PUSH
16254: LD_EXP 79
16258: PPUSH
16259: CALL_OW 302
16263: AND
16264: PUSH
16265: LD_OWVAR 67
16269: PUSH
16270: LD_INT 2
16272: GREATER
16273: AND
16274: IFFALSE 16374
16276: GO 16278
16278: DISABLE
// begin enable ;
16279: ENABLE
// if GetDistUnitXY ( Roth , 245 , 234 ) > 6 then
16280: LD_EXP 79
16284: PPUSH
16285: LD_INT 245
16287: PPUSH
16288: LD_INT 234
16290: PPUSH
16291: CALL_OW 297
16295: PUSH
16296: LD_INT 6
16298: GREATER
16299: IFFALSE 16318
// ComMoveXY ( Roth , 245 , 234 ) else
16301: LD_EXP 79
16305: PPUSH
16306: LD_INT 245
16308: PPUSH
16309: LD_INT 234
16311: PPUSH
16312: CALL_OW 111
16316: GO 16374
// ComMoveHex ( Roth , [ [ 259 , 235 ] , [ 252 , 209 ] , [ 275 , 235 ] ] [ rand ( 1 , 3 ) ] ) ;
16318: LD_EXP 79
16322: PPUSH
16323: LD_INT 259
16325: PUSH
16326: LD_INT 235
16328: PUSH
16329: EMPTY
16330: LIST
16331: LIST
16332: PUSH
16333: LD_INT 252
16335: PUSH
16336: LD_INT 209
16338: PUSH
16339: EMPTY
16340: LIST
16341: LIST
16342: PUSH
16343: LD_INT 275
16345: PUSH
16346: LD_INT 235
16348: PUSH
16349: EMPTY
16350: LIST
16351: LIST
16352: PUSH
16353: EMPTY
16354: LIST
16355: LIST
16356: LIST
16357: PUSH
16358: LD_INT 1
16360: PPUSH
16361: LD_INT 3
16363: PPUSH
16364: CALL_OW 12
16368: ARRAY
16369: PPUSH
16370: CALL 111509 0 2
// end ; end_of_file
16374: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
16375: LD_INT 0
16377: PPUSH
16378: PPUSH
16379: PPUSH
16380: PPUSH
// missionStage := 13 ;
16381: LD_ADDR_EXP 15
16385: PUSH
16386: LD_INT 13
16388: ST_TO_ADDR
// uc_side := 2 ;
16389: LD_ADDR_OWVAR 20
16393: PUSH
16394: LD_INT 2
16396: ST_TO_ADDR
// uc_nation := 2 ;
16397: LD_ADDR_OWVAR 21
16401: PUSH
16402: LD_INT 2
16404: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
16405: LD_ADDR_EXP 97
16409: PUSH
16410: LD_STRING Omar
16412: PPUSH
16413: CALL_OW 25
16417: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
16418: LD_EXP 97
16422: PPUSH
16423: LD_INT 4
16425: PPUSH
16426: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
16430: LD_EXP 97
16434: PPUSH
16435: LD_INT 242
16437: PPUSH
16438: LD_INT 75
16440: PPUSH
16441: LD_INT 0
16443: PPUSH
16444: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
16448: LD_ADDR_EXP 98
16452: PUSH
16453: LD_STRING Heike
16455: PPUSH
16456: CALL_OW 25
16460: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
16461: LD_INT 14
16463: PPUSH
16464: LD_INT 3
16466: PPUSH
16467: LD_INT 1
16469: PPUSH
16470: LD_INT 27
16472: PPUSH
16473: LD_INT 100
16475: PPUSH
16476: CALL 74510 0 5
// veh := CreateVehicle ;
16480: LD_ADDR_VAR 0 3
16484: PUSH
16485: CALL_OW 45
16489: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
16490: LD_VAR 0 3
16494: PPUSH
16495: LD_INT 2
16497: NEG
16498: PPUSH
16499: CALL_OW 242
// SetDir ( veh , 4 ) ;
16503: LD_VAR 0 3
16507: PPUSH
16508: LD_INT 4
16510: PPUSH
16511: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
16515: LD_VAR 0 3
16519: PPUSH
16520: LD_INT 241
16522: PPUSH
16523: LD_INT 72
16525: PPUSH
16526: LD_INT 0
16528: PPUSH
16529: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
16533: LD_EXP 98
16537: PPUSH
16538: LD_VAR 0 3
16542: PPUSH
16543: CALL_OW 52
// if KhatamStatus then
16547: LD_EXP 8
16551: IFFALSE 16614
// begin Khatam := NewCharacter ( Khatam ) ;
16553: LD_ADDR_EXP 99
16557: PUSH
16558: LD_STRING Khatam
16560: PPUSH
16561: CALL_OW 25
16565: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
16566: LD_EXP 99
16570: PPUSH
16571: LD_INT 245
16573: PPUSH
16574: LD_INT 78
16576: PPUSH
16577: LD_INT 3
16579: PPUSH
16580: LD_INT 0
16582: PPUSH
16583: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
16587: LD_EXP 99
16591: PPUSH
16592: LD_INT 4
16594: PPUSH
16595: LD_INT 10
16597: PPUSH
16598: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
16602: LD_EXP 99
16606: PPUSH
16607: LD_INT 4
16609: PPUSH
16610: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
16614: LD_ADDR_VAR 0 2
16618: PUSH
16619: DOUBLE
16620: LD_INT 1
16622: DEC
16623: ST_TO_ADDR
16624: LD_INT 2
16626: PUSH
16627: LD_INT 2
16629: PUSH
16630: LD_INT 3
16632: PUSH
16633: LD_INT 3
16635: PUSH
16636: EMPTY
16637: LIST
16638: LIST
16639: LIST
16640: LIST
16641: PUSH
16642: LD_OWVAR 67
16646: ARRAY
16647: PUSH
16648: FOR_TO
16649: IFFALSE 16715
// begin PrepareScientist ( false , 6 + Difficulty ) ;
16651: LD_INT 0
16653: PPUSH
16654: LD_INT 6
16656: PUSH
16657: LD_OWVAR 67
16661: PLUS
16662: PPUSH
16663: CALL_OW 384
// un := CreateHuman ;
16667: LD_ADDR_VAR 0 4
16671: PUSH
16672: CALL_OW 44
16676: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
16677: LD_VAR 0 4
16681: PPUSH
16682: LD_INT 28
16684: PUSH
16685: LD_INT 29
16687: PUSH
16688: EMPTY
16689: LIST
16690: LIST
16691: PUSH
16692: LD_VAR 0 2
16696: PUSH
16697: LD_INT 2
16699: MOD
16700: PUSH
16701: LD_INT 1
16703: PLUS
16704: ARRAY
16705: PPUSH
16706: LD_INT 0
16708: PPUSH
16709: CALL_OW 49
// end ;
16713: GO 16648
16715: POP
16716: POP
// for i = 1 to 6 do
16717: LD_ADDR_VAR 0 2
16721: PUSH
16722: DOUBLE
16723: LD_INT 1
16725: DEC
16726: ST_TO_ADDR
16727: LD_INT 6
16729: PUSH
16730: FOR_TO
16731: IFFALSE 16776
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
16733: LD_INT 0
16735: PPUSH
16736: LD_INT 6
16738: PUSH
16739: LD_OWVAR 67
16743: PLUS
16744: PPUSH
16745: CALL_OW 381
// un := CreateHuman ;
16749: LD_ADDR_VAR 0 4
16753: PUSH
16754: CALL_OW 44
16758: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16759: LD_VAR 0 4
16763: PPUSH
16764: LD_INT 32
16766: PPUSH
16767: LD_INT 0
16769: PPUSH
16770: CALL_OW 49
// end ;
16774: GO 16730
16776: POP
16777: POP
// for i = 1 to 3 do
16778: LD_ADDR_VAR 0 2
16782: PUSH
16783: DOUBLE
16784: LD_INT 1
16786: DEC
16787: ST_TO_ADDR
16788: LD_INT 3
16790: PUSH
16791: FOR_TO
16792: IFFALSE 16840
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
16794: LD_INT 0
16796: PPUSH
16797: LD_INT 8
16799: PPUSH
16800: LD_INT 6
16802: PUSH
16803: LD_OWVAR 67
16807: PLUS
16808: PPUSH
16809: CALL_OW 380
// un := CreateHuman ;
16813: LD_ADDR_VAR 0 4
16817: PUSH
16818: CALL_OW 44
16822: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16823: LD_VAR 0 4
16827: PPUSH
16828: LD_INT 32
16830: PPUSH
16831: LD_INT 0
16833: PPUSH
16834: CALL_OW 49
// end ;
16838: GO 16791
16840: POP
16841: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
16842: LD_ADDR_VAR 0 2
16846: PUSH
16847: DOUBLE
16848: LD_INT 1
16850: DEC
16851: ST_TO_ADDR
16852: LD_INT 2
16854: PUSH
16855: LD_INT 3
16857: PUSH
16858: LD_INT 4
16860: PUSH
16861: LD_INT 4
16863: PUSH
16864: EMPTY
16865: LIST
16866: LIST
16867: LIST
16868: LIST
16869: PUSH
16870: LD_OWVAR 67
16874: ARRAY
16875: PUSH
16876: FOR_TO
16877: IFFALSE 16967
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
16879: LD_INT 14
16881: PPUSH
16882: LD_INT 2
16884: PPUSH
16885: LD_INT 1
16887: PPUSH
16888: LD_INT 28
16890: PPUSH
16891: LD_INT 80
16893: PPUSH
16894: CALL 74510 0 5
// veh := CreateVehicle ;
16898: LD_ADDR_VAR 0 3
16902: PUSH
16903: CALL_OW 45
16907: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
16908: LD_VAR 0 3
16912: PPUSH
16913: LD_INT 3
16915: PPUSH
16916: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
16920: LD_VAR 0 3
16924: PPUSH
16925: LD_INT 29
16927: PPUSH
16928: LD_INT 0
16930: PPUSH
16931: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16935: LD_INT 0
16937: PPUSH
16938: LD_INT 6
16940: PUSH
16941: LD_OWVAR 67
16945: PLUS
16946: PPUSH
16947: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
16951: CALL_OW 44
16955: PPUSH
16956: LD_VAR 0 3
16960: PPUSH
16961: CALL_OW 52
// end ;
16965: GO 16876
16967: POP
16968: POP
// for i = 1 to 5 + Difficulty do
16969: LD_ADDR_VAR 0 2
16973: PUSH
16974: DOUBLE
16975: LD_INT 1
16977: DEC
16978: ST_TO_ADDR
16979: LD_INT 5
16981: PUSH
16982: LD_OWVAR 67
16986: PLUS
16987: PUSH
16988: FOR_TO
16989: IFFALSE 17116
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
16991: LD_INT 14
16993: PPUSH
16994: LD_INT 1
16996: PPUSH
16997: LD_INT 3
16999: PPUSH
17000: CALL_OW 12
17004: PPUSH
17005: LD_INT 1
17007: PPUSH
17008: LD_INT 28
17010: PUSH
17011: LD_INT 26
17013: PUSH
17014: LD_INT 27
17016: PUSH
17017: LD_INT 25
17019: PUSH
17020: EMPTY
17021: LIST
17022: LIST
17023: LIST
17024: LIST
17025: PUSH
17026: LD_VAR 0 2
17030: PUSH
17031: LD_INT 4
17033: MOD
17034: PUSH
17035: LD_INT 1
17037: PLUS
17038: ARRAY
17039: PPUSH
17040: LD_INT 80
17042: PPUSH
17043: CALL 74510 0 5
// veh := CreateVehicle ;
17047: LD_ADDR_VAR 0 3
17051: PUSH
17052: CALL_OW 45
17056: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
17057: LD_VAR 0 3
17061: PPUSH
17062: LD_INT 4
17064: PPUSH
17065: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
17069: LD_VAR 0 3
17073: PPUSH
17074: LD_INT 28
17076: PPUSH
17077: LD_INT 0
17079: PPUSH
17080: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
17084: LD_INT 0
17086: PPUSH
17087: LD_INT 6
17089: PUSH
17090: LD_OWVAR 67
17094: PLUS
17095: PPUSH
17096: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
17100: CALL_OW 44
17104: PPUSH
17105: LD_VAR 0 3
17109: PPUSH
17110: CALL_OW 52
// end ;
17114: GO 16988
17116: POP
17117: POP
// for i = 1 to Difficulty do
17118: LD_ADDR_VAR 0 2
17122: PUSH
17123: DOUBLE
17124: LD_INT 1
17126: DEC
17127: ST_TO_ADDR
17128: LD_OWVAR 67
17132: PUSH
17133: FOR_TO
17134: IFFALSE 17194
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
17136: LD_INT 14
17138: PPUSH
17139: LD_INT 3
17141: PPUSH
17142: LD_INT 5
17144: PPUSH
17145: LD_INT 29
17147: PPUSH
17148: LD_INT 80
17150: PPUSH
17151: CALL 74510 0 5
// veh := CreateVehicle ;
17155: LD_ADDR_VAR 0 3
17159: PUSH
17160: CALL_OW 45
17164: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
17165: LD_VAR 0 3
17169: PPUSH
17170: LD_INT 4
17172: PPUSH
17173: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
17177: LD_VAR 0 3
17181: PPUSH
17182: LD_INT 28
17184: PPUSH
17185: LD_INT 0
17187: PPUSH
17188: CALL_OW 49
// end ;
17192: GO 17133
17194: POP
17195: POP
// end ;
17196: LD_VAR 0 1
17200: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
17201: LD_INT 22
17203: PUSH
17204: LD_INT 2
17206: PUSH
17207: EMPTY
17208: LIST
17209: LIST
17210: PPUSH
17211: CALL_OW 69
17215: IFFALSE 17594
17217: GO 17219
17219: DISABLE
17220: LD_INT 0
17222: PPUSH
17223: PPUSH
17224: PPUSH
17225: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
17226: LD_ADDR_VAR 0 3
17230: PUSH
17231: LD_INT 22
17233: PUSH
17234: LD_INT 2
17236: PUSH
17237: EMPTY
17238: LIST
17239: LIST
17240: PUSH
17241: LD_INT 25
17243: PUSH
17244: LD_INT 4
17246: PUSH
17247: EMPTY
17248: LIST
17249: LIST
17250: PUSH
17251: EMPTY
17252: LIST
17253: LIST
17254: PPUSH
17255: CALL_OW 69
17259: PUSH
17260: LD_EXP 99
17264: DIFF
17265: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
17266: LD_ADDR_VAR 0 2
17270: PUSH
17271: LD_INT 22
17273: PUSH
17274: LD_INT 2
17276: PUSH
17277: EMPTY
17278: LIST
17279: LIST
17280: PPUSH
17281: CALL_OW 69
17285: PUSH
17286: LD_EXP 99
17290: PUSH
17291: LD_VAR 0 3
17295: UNION
17296: DIFF
17297: ST_TO_ADDR
// if Khatam then
17298: LD_EXP 99
17302: IFFALSE 17319
// ComMoveXY ( Khatam , 211 , 92 ) ;
17304: LD_EXP 99
17308: PPUSH
17309: LD_INT 211
17311: PPUSH
17312: LD_INT 92
17314: PPUSH
17315: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
17319: LD_INT 197
17321: PPUSH
17322: LD_INT 80
17324: PPUSH
17325: LD_INT 2
17327: PPUSH
17328: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
17332: LD_INT 213
17334: PPUSH
17335: LD_INT 90
17337: PPUSH
17338: LD_INT 2
17340: PPUSH
17341: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
17345: LD_INT 215
17347: PPUSH
17348: LD_INT 129
17350: PPUSH
17351: LD_INT 2
17353: PPUSH
17354: CALL_OW 441
// if sci then
17358: LD_VAR 0 3
17362: IFFALSE 17383
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
17364: LD_VAR 0 3
17368: PUSH
17369: LD_INT 1
17371: ARRAY
17372: PPUSH
17373: LD_INT 197
17375: PPUSH
17376: LD_INT 80
17378: PPUSH
17379: CALL_OW 158
// if sci > 1 then
17383: LD_VAR 0 3
17387: PUSH
17388: LD_INT 1
17390: GREATER
17391: IFFALSE 17412
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
17393: LD_VAR 0 3
17397: PUSH
17398: LD_INT 2
17400: ARRAY
17401: PPUSH
17402: LD_INT 213
17404: PPUSH
17405: LD_INT 90
17407: PPUSH
17408: CALL_OW 158
// if sci > 2 then
17412: LD_VAR 0 3
17416: PUSH
17417: LD_INT 2
17419: GREATER
17420: IFFALSE 17441
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
17422: LD_VAR 0 3
17426: PUSH
17427: LD_INT 3
17429: ARRAY
17430: PPUSH
17431: LD_INT 215
17433: PPUSH
17434: LD_INT 129
17436: PPUSH
17437: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
17441: LD_VAR 0 2
17445: PPUSH
17446: LD_INT 195
17448: PPUSH
17449: LD_INT 102
17451: PPUSH
17452: CALL_OW 114
// wait ( 0 0$5 ) ;
17456: LD_INT 175
17458: PPUSH
17459: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
17463: LD_INT 70
17465: PPUSH
17466: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
17470: LD_ADDR_VAR 0 4
17474: PUSH
17475: LD_INT 92
17477: PUSH
17478: LD_INT 195
17480: PUSH
17481: LD_INT 102
17483: PUSH
17484: LD_INT 36
17486: PUSH
17487: EMPTY
17488: LIST
17489: LIST
17490: LIST
17491: LIST
17492: PUSH
17493: LD_INT 22
17495: PUSH
17496: LD_INT 1
17498: PUSH
17499: EMPTY
17500: LIST
17501: LIST
17502: PUSH
17503: EMPTY
17504: LIST
17505: LIST
17506: PPUSH
17507: CALL_OW 69
17511: ST_TO_ADDR
// for i in tmp do
17512: LD_ADDR_VAR 0 1
17516: PUSH
17517: LD_VAR 0 2
17521: PUSH
17522: FOR_IN
17523: IFFALSE 17574
// if enemy then
17525: LD_VAR 0 4
17529: IFFALSE 17557
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
17531: LD_VAR 0 1
17535: PPUSH
17536: LD_VAR 0 4
17540: PPUSH
17541: LD_VAR 0 1
17545: PPUSH
17546: CALL_OW 74
17550: PPUSH
17551: CALL_OW 115
17555: GO 17572
// ComAgressiveMove ( i , 195 , 102 ) ;
17557: LD_VAR 0 1
17561: PPUSH
17562: LD_INT 195
17564: PPUSH
17565: LD_INT 102
17567: PPUSH
17568: CALL_OW 114
17572: GO 17522
17574: POP
17575: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
17576: LD_VAR 0 2
17580: PPUSH
17581: LD_INT 50
17583: PUSH
17584: EMPTY
17585: LIST
17586: PPUSH
17587: CALL_OW 72
17591: NOT
17592: IFFALSE 17463
// end ; end_of_file
17594: PPOPN 4
17596: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
17597: LD_INT 0
17599: PPUSH
17600: PPUSH
17601: PPUSH
17602: PPUSH
17603: PPUSH
17604: PPUSH
17605: PPUSH
17606: PPUSH
17607: PPUSH
// Video ( true ) ;
17608: LD_INT 1
17610: PPUSH
17611: CALL 107333 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
17615: LD_ADDR_VAR 0 5
17619: PUSH
17620: LD_INT 7
17622: PPUSH
17623: LD_INT 0
17625: PPUSH
17626: CALL_OW 517
17630: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
17631: LD_ADDR_VAR 0 2
17635: PUSH
17636: DOUBLE
17637: LD_INT 1
17639: DEC
17640: ST_TO_ADDR
17641: LD_VAR 0 5
17645: PUSH
17646: LD_INT 1
17648: ARRAY
17649: PUSH
17650: FOR_TO
17651: IFFALSE 17696
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
17653: LD_VAR 0 5
17657: PUSH
17658: LD_INT 1
17660: ARRAY
17661: PUSH
17662: LD_VAR 0 2
17666: ARRAY
17667: PPUSH
17668: LD_VAR 0 5
17672: PUSH
17673: LD_INT 2
17675: ARRAY
17676: PUSH
17677: LD_VAR 0 2
17681: ARRAY
17682: PPUSH
17683: LD_INT 1
17685: PPUSH
17686: LD_INT 15
17688: NEG
17689: PPUSH
17690: CALL 107247 0 4
17694: GO 17650
17696: POP
17697: POP
// CenterNowOnUnits ( Powell ) ;
17698: LD_EXP 61
17702: PPUSH
17703: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
17707: LD_ADDR_VAR 0 5
17711: PUSH
17712: LD_EXP 59
17716: PUSH
17717: EMPTY
17718: LIST
17719: ST_TO_ADDR
// if GirlNewVeh then
17720: LD_EXP 60
17724: IFFALSE 17742
// tmp := tmp ^ GirlNewVeh ;
17726: LD_ADDR_VAR 0 5
17730: PUSH
17731: LD_VAR 0 5
17735: PUSH
17736: LD_EXP 60
17740: ADD
17741: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
17742: LD_VAR 0 5
17746: PPUSH
17747: LD_INT 60
17749: PPUSH
17750: LD_INT 109
17752: PPUSH
17753: CALL_OW 111
// if KappaStatus then
17757: LD_EXP 2
17761: IFFALSE 17813
// begin Say ( JMM , D1nT-JMM-1 ) ;
17763: LD_EXP 40
17767: PPUSH
17768: LD_STRING D1nT-JMM-1
17770: PPUSH
17771: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17775: LD_EXP 61
17779: PPUSH
17780: LD_STRING D1T-Pow-1
17782: PPUSH
17783: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
17787: LD_EXP 40
17791: PPUSH
17792: LD_STRING D1T-JMM-2
17794: PPUSH
17795: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
17799: LD_EXP 61
17803: PPUSH
17804: LD_STRING D1T-Pow-2
17806: PPUSH
17807: CALL_OW 88
// end else
17811: GO 18019
// if JMMGirlStatus then
17813: LD_EXP 6
17817: IFFALSE 17962
// begin Say ( JMM , D1T-JMM-1 ) ;
17819: LD_EXP 40
17823: PPUSH
17824: LD_STRING D1T-JMM-1
17826: PPUSH
17827: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17831: LD_EXP 61
17835: PPUSH
17836: LD_STRING D1T-Pow-1
17838: PPUSH
17839: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
17843: LD_EXP 40
17847: PPUSH
17848: LD_STRING D1T-JMM-3
17850: PPUSH
17851: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
17855: LD_EXP 61
17859: PPUSH
17860: LD_STRING D1T-Pow-3
17862: PPUSH
17863: CALL_OW 88
// if JMMGirl then
17867: LD_EXP 7
17871: IFFALSE 17960
// begin case JMMGirl of 1 :
17873: LD_EXP 7
17877: PUSH
17878: LD_INT 1
17880: DOUBLE
17881: EQUAL
17882: IFTRUE 17886
17884: GO 17901
17886: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
17887: LD_EXP 41
17891: PPUSH
17892: LD_STRING D1T-Joan-3
17894: PPUSH
17895: CALL_OW 88
17899: GO 17948
17901: LD_INT 2
17903: DOUBLE
17904: EQUAL
17905: IFTRUE 17909
17907: GO 17924
17909: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
17910: LD_EXP 43
17914: PPUSH
17915: LD_STRING D1T-Lisa-3
17917: PPUSH
17918: CALL_OW 88
17922: GO 17948
17924: LD_INT 3
17926: DOUBLE
17927: EQUAL
17928: IFTRUE 17932
17930: GO 17947
17932: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
17933: LD_EXP 55
17937: PPUSH
17938: LD_STRING D1T-Con-3
17940: PPUSH
17941: CALL_OW 88
17945: GO 17948
17947: POP
// Say ( Powell , D1T-Pow-4 ) ;
17948: LD_EXP 61
17952: PPUSH
17953: LD_STRING D1T-Pow-4
17955: PPUSH
17956: CALL_OW 88
// end ; end else
17960: GO 18019
// if not FastEnd then
17962: LD_EXP 11
17966: NOT
17967: IFFALSE 17995
// begin Say ( JMM , D1T-JMM-4 ) ;
17969: LD_EXP 40
17973: PPUSH
17974: LD_STRING D1T-JMM-4
17976: PPUSH
17977: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
17981: LD_EXP 61
17985: PPUSH
17986: LD_STRING D1T-Pow-5
17988: PPUSH
17989: CALL_OW 88
// end else
17993: GO 18019
// begin Say ( JMM , D1nT-JMM-1 ) ;
17995: LD_EXP 40
17999: PPUSH
18000: LD_STRING D1nT-JMM-1
18002: PPUSH
18003: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
18007: LD_EXP 61
18011: PPUSH
18012: LD_STRING D1nT-Pow-1
18014: PPUSH
18015: CALL_OW 88
// end ; repeat wait ( 3 ) ;
18019: LD_INT 3
18021: PPUSH
18022: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
18026: LD_EXP 59
18030: PPUSH
18031: CALL_OW 314
18035: NOT
18036: IFFALSE 18019
// ComExitVehicle ( JMM ) ;
18038: LD_EXP 40
18042: PPUSH
18043: CALL_OW 121
// repeat wait ( 3 ) ;
18047: LD_INT 3
18049: PPUSH
18050: CALL_OW 67
// until not IsInUnit ( JMM ) ;
18054: LD_EXP 40
18058: PPUSH
18059: CALL_OW 310
18063: NOT
18064: IFFALSE 18047
// ComMoveXY ( JMM , 60 , 94 ) ;
18066: LD_EXP 40
18070: PPUSH
18071: LD_INT 60
18073: PPUSH
18074: LD_INT 94
18076: PPUSH
18077: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
18081: LD_EXP 40
18085: PPUSH
18086: LD_EXP 61
18090: PPUSH
18091: CALL_OW 179
// if Joan then
18095: LD_EXP 41
18099: IFFALSE 18153
// begin ComExitVehicle ( Joan ) ;
18101: LD_EXP 41
18105: PPUSH
18106: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
18110: LD_EXP 41
18114: PPUSH
18115: LD_INT 35
18117: PPUSH
18118: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
18122: LD_EXP 41
18126: PPUSH
18127: LD_INT 65
18129: PPUSH
18130: LD_INT 104
18132: PPUSH
18133: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
18137: LD_EXP 41
18141: PPUSH
18142: LD_EXP 40
18146: PPUSH
18147: CALL_OW 179
// end else
18151: GO 18287
// if Lisa and JMMGirl = 2 then
18153: LD_EXP 43
18157: PUSH
18158: LD_EXP 7
18162: PUSH
18163: LD_INT 2
18165: EQUAL
18166: AND
18167: IFFALSE 18221
// begin ComExitVehicle ( Lisa ) ;
18169: LD_EXP 43
18173: PPUSH
18174: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
18178: LD_EXP 43
18182: PPUSH
18183: LD_INT 35
18185: PPUSH
18186: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
18190: LD_EXP 43
18194: PPUSH
18195: LD_INT 65
18197: PPUSH
18198: LD_INT 104
18200: PPUSH
18201: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
18205: LD_EXP 43
18209: PPUSH
18210: LD_EXP 40
18214: PPUSH
18215: CALL_OW 179
// end else
18219: GO 18287
// if Connie and JMMGirl = 3 then
18221: LD_EXP 55
18225: PUSH
18226: LD_EXP 7
18230: PUSH
18231: LD_INT 3
18233: EQUAL
18234: AND
18235: IFFALSE 18287
// begin ComExitVehicle ( Connie ) ;
18237: LD_EXP 55
18241: PPUSH
18242: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
18246: LD_EXP 55
18250: PPUSH
18251: LD_INT 35
18253: PPUSH
18254: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
18258: LD_EXP 55
18262: PPUSH
18263: LD_INT 65
18265: PPUSH
18266: LD_INT 104
18268: PPUSH
18269: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
18273: LD_EXP 55
18277: PPUSH
18278: LD_EXP 40
18282: PPUSH
18283: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
18287: LD_INT 35
18289: PPUSH
18290: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
18294: LD_EXP 40
18298: PPUSH
18299: LD_EXP 61
18303: PPUSH
18304: CALL_OW 296
18308: PUSH
18309: LD_INT 8
18311: LESS
18312: IFFALSE 18287
// wait ( 0 0$0.5 ) ;
18314: LD_INT 18
18316: PPUSH
18317: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
18321: LD_EXP 40
18325: PPUSH
18326: LD_STRING D1-JMM-1
18328: PPUSH
18329: CALL_OW 88
// async ;
18333: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
18334: LD_EXP 61
18338: PPUSH
18339: LD_STRING D1-Pow-1
18341: PPUSH
18342: CALL_OW 88
// if not dialogue_skipped then
18346: LD_OWVAR 59
18350: NOT
18351: IFFALSE 18360
// wait ( 0 0$2 ) ;
18353: LD_INT 70
18355: PPUSH
18356: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
18360: LD_INT 170
18362: PPUSH
18363: LD_INT 99
18365: PPUSH
18366: LD_INT 1
18368: PPUSH
18369: LD_INT 6
18371: NEG
18372: PPUSH
18373: CALL 107247 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
18377: LD_INT 174
18379: PPUSH
18380: LD_INT 115
18382: PPUSH
18383: LD_INT 1
18385: PPUSH
18386: LD_INT 6
18388: NEG
18389: PPUSH
18390: CALL 107247 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
18394: LD_INT 169
18396: PPUSH
18397: LD_INT 71
18399: PPUSH
18400: LD_INT 1
18402: PPUSH
18403: LD_INT 6
18405: NEG
18406: PPUSH
18407: CALL 107247 0 4
// if not dialogue_skipped then
18411: LD_OWVAR 59
18415: NOT
18416: IFFALSE 18435
// begin CenterOnXY ( 170 , 99 ) ;
18418: LD_INT 170
18420: PPUSH
18421: LD_INT 99
18423: PPUSH
18424: CALL_OW 84
// wait ( 0 0$2.3 ) ;
18428: LD_INT 80
18430: PPUSH
18431: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
18435: LD_INT 75
18437: PPUSH
18438: LD_INT 53
18440: PPUSH
18441: LD_INT 1
18443: PPUSH
18444: LD_INT 9
18446: NEG
18447: PPUSH
18448: CALL 107247 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
18452: LD_INT 54
18454: PPUSH
18455: LD_INT 42
18457: PPUSH
18458: LD_INT 1
18460: PPUSH
18461: LD_INT 9
18463: NEG
18464: PPUSH
18465: CALL 107247 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
18469: LD_INT 62
18471: PPUSH
18472: LD_INT 51
18474: PPUSH
18475: LD_INT 1
18477: PPUSH
18478: LD_INT 9
18480: NEG
18481: PPUSH
18482: CALL 107247 0 4
// if not dialogue_skipped then
18486: LD_OWVAR 59
18490: NOT
18491: IFFALSE 18510
// begin CenterOnXY ( 75 , 53 ) ;
18493: LD_INT 75
18495: PPUSH
18496: LD_INT 53
18498: PPUSH
18499: CALL_OW 84
// wait ( 0 0$4 ) ;
18503: LD_INT 140
18505: PPUSH
18506: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
18510: LD_EXP 61
18514: PPUSH
18515: CALL_OW 87
// if not dialogue_skipped then
18519: LD_OWVAR 59
18523: NOT
18524: IFFALSE 18533
// wait ( 0 0$2 ) ;
18526: LD_INT 70
18528: PPUSH
18529: CALL_OW 67
// sync ;
18533: SYNC
// Say ( JMM , D1-JMM-2 ) ;
18534: LD_EXP 40
18538: PPUSH
18539: LD_STRING D1-JMM-2
18541: PPUSH
18542: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
18546: LD_EXP 61
18550: PPUSH
18551: LD_STRING D1-Pow-2
18553: PPUSH
18554: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
18558: LD_EXP 40
18562: PPUSH
18563: LD_STRING D1-JMM-3
18565: PPUSH
18566: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
18570: LD_EXP 61
18574: PPUSH
18575: LD_STRING D1-Pow-3
18577: PPUSH
18578: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
18582: LD_EXP 40
18586: PPUSH
18587: LD_STRING D1-JMM-4
18589: PPUSH
18590: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
18594: LD_EXP 61
18598: PPUSH
18599: LD_STRING D1-Pow-4
18601: PPUSH
18602: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
18606: LD_EXP 40
18610: PPUSH
18611: LD_STRING D1-JMM-5
18613: PPUSH
18614: CALL_OW 88
// async ;
18618: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
18619: LD_EXP 61
18623: PPUSH
18624: LD_STRING D1-Pow-5
18626: PPUSH
18627: CALL_OW 88
// if not dialogue_skipped then
18631: LD_OWVAR 59
18635: NOT
18636: IFFALSE 18645
// wait ( 0 0$3.6 ) ;
18638: LD_INT 126
18640: PPUSH
18641: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
18645: LD_INT 134
18647: PPUSH
18648: LD_INT 210
18650: PPUSH
18651: LD_INT 1
18653: PPUSH
18654: LD_INT 11
18656: NEG
18657: PPUSH
18658: CALL 107247 0 4
// if not dialogue_skipped then
18662: LD_OWVAR 59
18666: NOT
18667: IFFALSE 18686
// begin CenterOnXY ( 134 , 210 ) ;
18669: LD_INT 134
18671: PPUSH
18672: LD_INT 210
18674: PPUSH
18675: CALL_OW 84
// wait ( 0 0$2 ) ;
18679: LD_INT 70
18681: PPUSH
18682: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
18686: LD_INT 101
18688: PPUSH
18689: LD_INT 159
18691: PPUSH
18692: LD_INT 1
18694: PPUSH
18695: LD_INT 10
18697: NEG
18698: PPUSH
18699: CALL 107247 0 4
// if not dialogue_skipped then
18703: LD_OWVAR 59
18707: NOT
18708: IFFALSE 18727
// begin CenterOnXY ( 101 , 159 ) ;
18710: LD_INT 101
18712: PPUSH
18713: LD_INT 159
18715: PPUSH
18716: CALL_OW 84
// wait ( 0 0$2 ) ;
18720: LD_INT 70
18722: PPUSH
18723: CALL_OW 67
// end ; sync ;
18727: SYNC
// CenterNowOnUnits ( Powell ) ;
18728: LD_EXP 61
18732: PPUSH
18733: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
18737: LD_ADDR_VAR 0 6
18741: PUSH
18742: LD_INT 1
18744: PUSH
18745: LD_INT 2
18747: PUSH
18748: LD_INT 3
18750: PUSH
18751: LD_INT 4
18753: PUSH
18754: LD_INT 5
18756: PUSH
18757: LD_INT 6
18759: PUSH
18760: EMPTY
18761: LIST
18762: LIST
18763: LIST
18764: LIST
18765: LIST
18766: LIST
18767: ST_TO_ADDR
// if not dialogue_skipped then
18768: LD_OWVAR 59
18772: NOT
18773: IFFALSE 18942
// begin game_speed := 4 ;
18775: LD_ADDR_OWVAR 65
18779: PUSH
18780: LD_INT 4
18782: ST_TO_ADDR
// wait ( 0 0$6 ) ;
18783: LD_INT 210
18785: PPUSH
18786: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
18790: LD_ADDR_VAR 0 7
18794: PUSH
18795: LD_STRING Q1
18797: PPUSH
18798: LD_VAR 0 6
18802: PPUSH
18803: CALL_OW 98
18807: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
18808: LD_ADDR_VAR 0 7
18812: PUSH
18813: LD_STRING Q1
18815: PPUSH
18816: LD_VAR 0 6
18820: PPUSH
18821: CALL_OW 98
18825: ST_TO_ADDR
// options := options diff dec ;
18826: LD_ADDR_VAR 0 6
18830: PUSH
18831: LD_VAR 0 6
18835: PUSH
18836: LD_VAR 0 7
18840: DIFF
18841: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
18842: LD_VAR 0 7
18846: PPUSH
18847: LD_VAR 0 6
18851: PPUSH
18852: CALL 20506 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
18856: LD_VAR 0 7
18860: PUSH
18861: LD_INT 5
18863: PUSH
18864: LD_INT 6
18866: PUSH
18867: EMPTY
18868: LIST
18869: LIST
18870: IN
18871: PUSH
18872: LD_VAR 0 6
18876: PUSH
18877: LD_INT 2
18879: EQUAL
18880: OR
18881: IFFALSE 18808
// if not ( dec in [ 5 , 6 ] ) then
18883: LD_VAR 0 7
18887: PUSH
18888: LD_INT 5
18890: PUSH
18891: LD_INT 6
18893: PUSH
18894: EMPTY
18895: LIST
18896: LIST
18897: IN
18898: NOT
18899: IFFALSE 18942
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
18901: LD_ADDR_VAR 0 7
18905: PUSH
18906: LD_STRING Q1a
18908: PPUSH
18909: LD_INT 1
18911: PUSH
18912: LD_INT 2
18914: PUSH
18915: EMPTY
18916: LIST
18917: LIST
18918: PPUSH
18919: CALL_OW 98
18923: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
18924: LD_VAR 0 7
18928: PUSH
18929: LD_INT 4
18931: PLUS
18932: PPUSH
18933: LD_VAR 0 6
18937: PPUSH
18938: CALL 20506 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
18942: LD_INT 81
18944: PPUSH
18945: LD_INT 127
18947: PPUSH
18948: CALL_OW 84
// amount := 8 ;
18952: LD_ADDR_VAR 0 8
18956: PUSH
18957: LD_INT 8
18959: ST_TO_ADDR
// macmilan_squad := [ ] ;
18960: LD_ADDR_VAR 0 9
18964: PUSH
18965: EMPTY
18966: ST_TO_ADDR
// if vip < amount then
18967: LD_EXP 62
18971: PUSH
18972: LD_VAR 0 8
18976: LESS
18977: IFFALSE 19021
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
18979: LD_ADDR_VAR 0 5
18983: PUSH
18984: LD_EXP 62
18988: PUSH
18989: LD_INT 22
18991: PUSH
18992: LD_INT 4
18994: PUSH
18995: EMPTY
18996: LIST
18997: LIST
18998: PUSH
18999: LD_INT 21
19001: PUSH
19002: LD_INT 1
19004: PUSH
19005: EMPTY
19006: LIST
19007: LIST
19008: PUSH
19009: EMPTY
19010: LIST
19011: LIST
19012: PPUSH
19013: CALL_OW 69
19017: UNION
19018: ST_TO_ADDR
19019: GO 19031
// tmp := vip ;
19021: LD_ADDR_VAR 0 5
19025: PUSH
19026: LD_EXP 62
19030: ST_TO_ADDR
// tmp := tmp diff Powell ;
19031: LD_ADDR_VAR 0 5
19035: PUSH
19036: LD_VAR 0 5
19040: PUSH
19041: LD_EXP 61
19045: DIFF
19046: ST_TO_ADDR
// if tmp < amount then
19047: LD_VAR 0 5
19051: PUSH
19052: LD_VAR 0 8
19056: LESS
19057: IFFALSE 19069
// amount := tmp ;
19059: LD_ADDR_VAR 0 8
19063: PUSH
19064: LD_VAR 0 5
19068: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
19069: LD_VAR 0 5
19073: PUSH
19074: LD_INT 1
19076: ARRAY
19077: PPUSH
19078: CALL_OW 257
19082: PUSH
19083: LD_INT 2
19085: NONEQUAL
19086: IFFALSE 19184
// begin if IsInUnit ( tmp [ 1 ] ) then
19088: LD_VAR 0 5
19092: PUSH
19093: LD_INT 1
19095: ARRAY
19096: PPUSH
19097: CALL_OW 310
19101: IFFALSE 19116
// ComExitBuilding ( tmp [ 1 ] ) ;
19103: LD_VAR 0 5
19107: PUSH
19108: LD_INT 1
19110: ARRAY
19111: PPUSH
19112: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
19116: LD_INT 387
19118: PPUSH
19119: CALL_OW 313
19123: PUSH
19124: LD_INT 6
19126: EQUAL
19127: IFFALSE 19152
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
19129: LD_INT 387
19131: PPUSH
19132: CALL_OW 313
19136: PUSH
19137: LD_INT 1
19139: ARRAY
19140: PPUSH
19141: CALL_OW 122
// wait ( 3 ) ;
19145: LD_INT 3
19147: PPUSH
19148: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
19152: LD_VAR 0 5
19156: PUSH
19157: LD_INT 1
19159: ARRAY
19160: PPUSH
19161: LD_INT 387
19163: PPUSH
19164: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
19168: LD_VAR 0 5
19172: PUSH
19173: LD_INT 1
19175: ARRAY
19176: PPUSH
19177: LD_INT 2
19179: PPUSH
19180: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
19184: LD_EXP 40
19188: PPUSH
19189: LD_INT 82
19191: PPUSH
19192: LD_INT 129
19194: PPUSH
19195: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
19199: LD_EXP 40
19203: PPUSH
19204: LD_EXP 61
19208: PPUSH
19209: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
19213: LD_INT 22
19215: PUSH
19216: LD_INT 1
19218: PUSH
19219: EMPTY
19220: LIST
19221: LIST
19222: PPUSH
19223: CALL_OW 69
19227: PUSH
19228: LD_EXP 40
19232: DIFF
19233: PPUSH
19234: LD_INT 84
19236: PPUSH
19237: LD_INT 128
19239: PPUSH
19240: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
19244: LD_INT 22
19246: PUSH
19247: LD_INT 1
19249: PUSH
19250: EMPTY
19251: LIST
19252: LIST
19253: PPUSH
19254: CALL_OW 69
19258: PUSH
19259: LD_EXP 40
19263: DIFF
19264: PPUSH
19265: LD_EXP 40
19269: PPUSH
19270: CALL_OW 179
// for i = 1 to amount do
19274: LD_ADDR_VAR 0 2
19278: PUSH
19279: DOUBLE
19280: LD_INT 1
19282: DEC
19283: ST_TO_ADDR
19284: LD_VAR 0 8
19288: PUSH
19289: FOR_TO
19290: IFFALSE 19458
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
19292: LD_ADDR_VAR 0 9
19296: PUSH
19297: LD_VAR 0 9
19301: PUSH
19302: LD_VAR 0 5
19306: PUSH
19307: LD_VAR 0 2
19311: ARRAY
19312: ADD
19313: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
19314: LD_VAR 0 5
19318: PUSH
19319: LD_VAR 0 2
19323: ARRAY
19324: PPUSH
19325: CALL_OW 310
19329: IFFALSE 19346
// AddComExitBuilding ( tmp [ i ] ) ;
19331: LD_VAR 0 5
19335: PUSH
19336: LD_VAR 0 2
19340: ARRAY
19341: PPUSH
19342: CALL_OW 182
// if i = 2 and JMMNewVeh then
19346: LD_VAR 0 2
19350: PUSH
19351: LD_INT 2
19353: EQUAL
19354: PUSH
19355: LD_EXP 59
19359: AND
19360: IFFALSE 19418
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
19362: LD_VAR 0 5
19366: PUSH
19367: LD_VAR 0 2
19371: ARRAY
19372: PPUSH
19373: LD_EXP 59
19377: PPUSH
19378: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
19382: LD_VAR 0 5
19386: PUSH
19387: LD_VAR 0 2
19391: ARRAY
19392: PPUSH
19393: LD_INT 86
19395: PPUSH
19396: LD_INT 133
19398: PPUSH
19399: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
19403: LD_VAR 0 5
19407: PUSH
19408: LD_VAR 0 2
19412: ARRAY
19413: PPUSH
19414: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
19418: LD_VAR 0 5
19422: PUSH
19423: LD_VAR 0 2
19427: ARRAY
19428: PPUSH
19429: LD_INT 8
19431: PPUSH
19432: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
19436: LD_VAR 0 5
19440: PUSH
19441: LD_VAR 0 2
19445: ARRAY
19446: PPUSH
19447: LD_EXP 40
19451: PPUSH
19452: CALL_OW 179
// end ;
19456: GO 19289
19458: POP
19459: POP
// if GirlNewVeh then
19460: LD_EXP 60
19464: IFFALSE 19478
// SetSide ( GirlNewVeh , 4 ) ;
19466: LD_EXP 60
19470: PPUSH
19471: LD_INT 4
19473: PPUSH
19474: CALL_OW 235
// if Mike then
19478: LD_EXP 57
19482: IFFALSE 19519
// begin macmilan_squad := Join ( macmilan_squad , Mike ) ;
19484: LD_ADDR_VAR 0 9
19488: PUSH
19489: LD_VAR 0 9
19493: PPUSH
19494: LD_EXP 57
19498: PPUSH
19499: CALL 107361 0 2
19503: ST_TO_ADDR
// ComMoveXY ( Mike , 86 , 133 ) ;
19504: LD_EXP 57
19508: PPUSH
19509: LD_INT 86
19511: PPUSH
19512: LD_INT 133
19514: PPUSH
19515: CALL_OW 111
// end ; repeat wait ( 0 0$1 ) ;
19519: LD_INT 35
19521: PPUSH
19522: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
19526: LD_VAR 0 9
19530: PPUSH
19531: LD_INT 95
19533: PUSH
19534: LD_INT 9
19536: PUSH
19537: EMPTY
19538: LIST
19539: LIST
19540: PPUSH
19541: CALL_OW 72
19545: PUSH
19546: LD_INT 0
19548: EQUAL
19549: PUSH
19550: LD_EXP 40
19554: PPUSH
19555: LD_INT 9
19557: PPUSH
19558: CALL_OW 308
19562: NOT
19563: AND
19564: IFFALSE 19519
// wait ( 0 0$2 ) ;
19566: LD_INT 70
19568: PPUSH
19569: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
19573: LD_VAR 0 9
19577: PPUSH
19578: LD_INT 1
19580: PPUSH
19581: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
19585: LD_INT 21
19587: PUSH
19588: LD_INT 2
19590: PUSH
19591: EMPTY
19592: LIST
19593: LIST
19594: PUSH
19595: LD_INT 92
19597: PUSH
19598: LD_INT 83
19600: PUSH
19601: LD_INT 130
19603: PUSH
19604: LD_INT 10
19606: PUSH
19607: EMPTY
19608: LIST
19609: LIST
19610: LIST
19611: LIST
19612: PUSH
19613: EMPTY
19614: LIST
19615: LIST
19616: PPUSH
19617: CALL_OW 69
19621: PPUSH
19622: LD_INT 1
19624: PPUSH
19625: CALL_OW 235
// tick := 0 ;
19629: LD_ADDR_OWVAR 1
19633: PUSH
19634: LD_INT 0
19636: ST_TO_ADDR
// Video ( false ) ;
19637: LD_INT 0
19639: PPUSH
19640: CALL 107333 0 1
// ChangeMissionObjectives ( M1 ) ;
19644: LD_STRING M1
19646: PPUSH
19647: CALL_OW 337
// SaveForQuickRestart ;
19651: CALL_OW 22
// missionStart := true ;
19655: LD_ADDR_EXP 13
19659: PUSH
19660: LD_INT 1
19662: ST_TO_ADDR
// missionStage := 2 ;
19663: LD_ADDR_EXP 15
19667: PUSH
19668: LD_INT 2
19670: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19671: LD_INT 35
19673: PPUSH
19674: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
19678: LD_ADDR_VAR 0 5
19682: PUSH
19683: LD_INT 22
19685: PUSH
19686: LD_INT 4
19688: PUSH
19689: EMPTY
19690: LIST
19691: LIST
19692: PUSH
19693: LD_INT 21
19695: PUSH
19696: LD_INT 1
19698: PUSH
19699: EMPTY
19700: LIST
19701: LIST
19702: PUSH
19703: EMPTY
19704: LIST
19705: LIST
19706: PPUSH
19707: CALL_OW 69
19711: PUSH
19712: LD_EXP 61
19716: DIFF
19717: ST_TO_ADDR
// if not tmp then
19718: LD_VAR 0 5
19722: NOT
19723: IFFALSE 19738
// tmp := [ Powell ] ;
19725: LD_ADDR_VAR 0 5
19729: PUSH
19730: LD_EXP 61
19734: PUSH
19735: EMPTY
19736: LIST
19737: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
19738: LD_ADDR_VAR 0 4
19742: PUSH
19743: LD_INT 22
19745: PUSH
19746: LD_INT 4
19748: PUSH
19749: EMPTY
19750: LIST
19751: LIST
19752: PUSH
19753: LD_INT 34
19755: PUSH
19756: LD_INT 12
19758: PUSH
19759: EMPTY
19760: LIST
19761: LIST
19762: PUSH
19763: EMPTY
19764: LIST
19765: LIST
19766: PPUSH
19767: CALL_OW 69
19771: PUSH
19772: LD_INT 1
19774: ARRAY
19775: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
19776: LD_VAR 0 5
19780: PUSH
19781: LD_INT 1
19783: ARRAY
19784: PPUSH
19785: CALL_OW 310
19789: IFFALSE 19804
// ComExitBuilding ( tmp [ 1 ] ) ;
19791: LD_VAR 0 5
19795: PUSH
19796: LD_INT 1
19798: ARRAY
19799: PPUSH
19800: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
19804: LD_VAR 0 5
19808: PUSH
19809: LD_INT 1
19811: ARRAY
19812: PPUSH
19813: LD_VAR 0 4
19817: PPUSH
19818: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
19822: LD_VAR 0 5
19826: PUSH
19827: LD_INT 1
19829: ARRAY
19830: PPUSH
19831: LD_INT 80
19833: PPUSH
19834: LD_INT 136
19836: PPUSH
19837: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
19841: LD_VAR 0 5
19845: PUSH
19846: LD_INT 1
19848: ARRAY
19849: PPUSH
19850: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
19854: LD_VAR 0 5
19858: PUSH
19859: LD_INT 1
19861: ARRAY
19862: PPUSH
19863: LD_INT 59
19865: PPUSH
19866: LD_INT 112
19868: PPUSH
19869: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
19873: LD_VAR 0 5
19877: PUSH
19878: LD_INT 1
19880: ARRAY
19881: PPUSH
19882: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
19886: LD_EXP 41
19890: PUSH
19891: LD_EXP 41
19895: PPUSH
19896: CALL_OW 255
19900: PUSH
19901: LD_INT 1
19903: EQUAL
19904: AND
19905: IFFALSE 19931
// begin Say ( Joan , D3W-Joan-1 ) ;
19907: LD_EXP 41
19911: PPUSH
19912: LD_STRING D3W-Joan-1
19914: PPUSH
19915: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19919: LD_EXP 40
19923: PPUSH
19924: LD_STRING D3W-JMM-1
19926: PPUSH
19927: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
19931: LD_EXP 43
19935: PUSH
19936: LD_EXP 43
19940: PPUSH
19941: CALL_OW 255
19945: PUSH
19946: LD_INT 1
19948: EQUAL
19949: AND
19950: PUSH
19951: LD_EXP 43
19955: PUSH
19956: LD_EXP 62
19960: IN
19961: NOT
19962: AND
19963: IFFALSE 19989
// begin Say ( Lisa , D3W-Lisa-1 ) ;
19965: LD_EXP 43
19969: PPUSH
19970: LD_STRING D3W-Lisa-1
19972: PPUSH
19973: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19977: LD_EXP 40
19981: PPUSH
19982: LD_STRING D3W-JMM-1
19984: PPUSH
19985: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
19989: LD_EXP 55
19993: PUSH
19994: LD_EXP 55
19998: PPUSH
19999: CALL_OW 255
20003: PUSH
20004: LD_INT 1
20006: EQUAL
20007: AND
20008: IFFALSE 20034
// begin Say ( Connie , D3W-Con-1 ) ;
20010: LD_EXP 55
20014: PPUSH
20015: LD_STRING D3W-Con-1
20017: PPUSH
20018: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
20022: LD_EXP 40
20026: PPUSH
20027: LD_STRING D3W-JMM-1
20029: PPUSH
20030: CALL_OW 88
// end ; wait ( 0 0$0.5 ) ;
20034: LD_INT 18
20036: PPUSH
20037: CALL_OW 67
// if Lisa in vip and GetSide ( Lisa ) = 1 then
20041: LD_EXP 43
20045: PUSH
20046: LD_EXP 62
20050: IN
20051: PUSH
20052: LD_EXP 43
20056: PPUSH
20057: CALL_OW 255
20061: PUSH
20062: LD_INT 1
20064: EQUAL
20065: AND
20066: IFFALSE 20082
// Say ( Lisa , D3nW-Lisa-1 ) else
20068: LD_EXP 43
20072: PPUSH
20073: LD_STRING D3nW-Lisa-1
20075: PPUSH
20076: CALL_OW 88
20080: GO 20326
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
20082: LD_EXP 46
20086: PUSH
20087: LD_EXP 62
20091: IN
20092: PUSH
20093: LD_EXP 46
20097: PPUSH
20098: CALL_OW 255
20102: PUSH
20103: LD_INT 1
20105: EQUAL
20106: AND
20107: IFFALSE 20123
// Say ( Cyrus , D3nW-Cyrus-1 ) else
20109: LD_EXP 46
20113: PPUSH
20114: LD_STRING D3nW-Cyrus-1
20116: PPUSH
20117: CALL_OW 88
20121: GO 20326
// if Bobby in vip and GetSide ( Bobby ) = 1 then
20123: LD_EXP 45
20127: PUSH
20128: LD_EXP 62
20132: IN
20133: PUSH
20134: LD_EXP 45
20138: PPUSH
20139: CALL_OW 255
20143: PUSH
20144: LD_INT 1
20146: EQUAL
20147: AND
20148: IFFALSE 20164
// Say ( Bobby , D3nW-Bobby-1 ) else
20150: LD_EXP 45
20154: PPUSH
20155: LD_STRING D3nW-Bobby-1
20157: PPUSH
20158: CALL_OW 88
20162: GO 20326
// if Gary in vip and GetSide ( Gary ) = 1 then
20164: LD_EXP 52
20168: PUSH
20169: LD_EXP 62
20173: IN
20174: PUSH
20175: LD_EXP 52
20179: PPUSH
20180: CALL_OW 255
20184: PUSH
20185: LD_INT 1
20187: EQUAL
20188: AND
20189: IFFALSE 20205
// Say ( Gary , D3nW-Gary-1 ) else
20191: LD_EXP 52
20195: PPUSH
20196: LD_STRING D3nW-Gary-1
20198: PPUSH
20199: CALL_OW 88
20203: GO 20326
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
20205: LD_EXP 44
20209: PUSH
20210: LD_EXP 62
20214: IN
20215: PUSH
20216: LD_EXP 44
20220: PPUSH
20221: CALL_OW 255
20225: PUSH
20226: LD_INT 1
20228: EQUAL
20229: AND
20230: IFFALSE 20246
// Say ( Donaldson , D3nW-Don-1 ) else
20232: LD_EXP 44
20236: PPUSH
20237: LD_STRING D3nW-Don-1
20239: PPUSH
20240: CALL_OW 88
20244: GO 20326
// if Cornel in vip and GetSide ( Cornel ) = 1 then
20246: LD_EXP 51
20250: PUSH
20251: LD_EXP 62
20255: IN
20256: PUSH
20257: LD_EXP 51
20261: PPUSH
20262: CALL_OW 255
20266: PUSH
20267: LD_INT 1
20269: EQUAL
20270: AND
20271: IFFALSE 20287
// Say ( Cornel , D3nW-Corn-1 ) else
20273: LD_EXP 51
20277: PPUSH
20278: LD_STRING D3nW-Corn-1
20280: PPUSH
20281: CALL_OW 88
20285: GO 20326
// if Frank in vip and GetSide ( Frank ) = 1 then
20287: LD_EXP 53
20291: PUSH
20292: LD_EXP 62
20296: IN
20297: PUSH
20298: LD_EXP 53
20302: PPUSH
20303: CALL_OW 255
20307: PUSH
20308: LD_INT 1
20310: EQUAL
20311: AND
20312: IFFALSE 20326
// Say ( Frank , D3nW-Frank-1 ) ;
20314: LD_EXP 53
20318: PPUSH
20319: LD_STRING D3nW-Frank-1
20321: PPUSH
20322: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
20326: LD_EXP 62
20330: PPUSH
20331: LD_INT 22
20333: PUSH
20334: LD_INT 1
20336: PUSH
20337: EMPTY
20338: LIST
20339: LIST
20340: PPUSH
20341: CALL_OW 72
20345: IFFALSE 20371
// begin Say ( JMM , D3nW-JMM-1 ) ;
20347: LD_EXP 40
20351: PPUSH
20352: LD_STRING D3nW-JMM-1
20354: PPUSH
20355: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
20359: LD_EXP 40
20363: PPUSH
20364: LD_STRING D3nW-JMM-1a
20366: PPUSH
20367: CALL_OW 88
// end ; t := 0 0$00 ;
20371: LD_ADDR_VAR 0 3
20375: PUSH
20376: LD_INT 0
20378: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20379: LD_INT 35
20381: PPUSH
20382: CALL_OW 67
// t := t + 0 0$1 ;
20386: LD_ADDR_VAR 0 3
20390: PUSH
20391: LD_VAR 0 3
20395: PUSH
20396: LD_INT 35
20398: PLUS
20399: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
20400: LD_INT 59
20402: PPUSH
20403: LD_INT 112
20405: PPUSH
20406: CALL_OW 428
20410: PUSH
20411: LD_VAR 0 3
20415: PUSH
20416: LD_INT 2100
20418: GREATER
20419: OR
20420: IFFALSE 20379
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
20422: LD_ADDR_EXP 102
20426: PUSH
20427: LD_EXP 102
20431: PPUSH
20432: LD_INT 4
20434: PPUSH
20435: LD_INT 22
20437: PUSH
20438: LD_INT 4
20440: PUSH
20441: EMPTY
20442: LIST
20443: LIST
20444: PUSH
20445: LD_INT 23
20447: PUSH
20448: LD_INT 1
20450: PUSH
20451: EMPTY
20452: LIST
20453: LIST
20454: PUSH
20455: LD_INT 3
20457: PUSH
20458: LD_INT 21
20460: PUSH
20461: LD_INT 2
20463: PUSH
20464: EMPTY
20465: LIST
20466: LIST
20467: PUSH
20468: EMPTY
20469: LIST
20470: LIST
20471: PUSH
20472: EMPTY
20473: LIST
20474: LIST
20475: LIST
20476: PPUSH
20477: CALL_OW 69
20481: PUSH
20482: LD_EXP 61
20486: DIFF
20487: PPUSH
20488: CALL_OW 1
20492: ST_TO_ADDR
// activeAttacks := true ;
20493: LD_ADDR_EXP 16
20497: PUSH
20498: LD_INT 1
20500: ST_TO_ADDR
// end ;
20501: LD_VAR 0 1
20505: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
20506: LD_INT 0
20508: PPUSH
// case question of 1 :
20509: LD_VAR 0 1
20513: PUSH
20514: LD_INT 1
20516: DOUBLE
20517: EQUAL
20518: IFTRUE 20522
20520: GO 20573
20522: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
20523: LD_EXP 40
20527: PPUSH
20528: LD_STRING D2Mot-JMM-1
20530: PPUSH
20531: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
20535: LD_EXP 61
20539: PPUSH
20540: LD_STRING D2Mot-Pow-1
20542: PPUSH
20543: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
20547: LD_EXP 40
20551: PPUSH
20552: LD_STRING D2Mot-JMM-2
20554: PPUSH
20555: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
20559: LD_EXP 61
20563: PPUSH
20564: LD_STRING D2Mot-Pow-2
20566: PPUSH
20567: CALL_OW 88
// end ; 2 :
20571: GO 20924
20573: LD_INT 2
20575: DOUBLE
20576: EQUAL
20577: IFTRUE 20581
20579: GO 20657
20581: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
20582: LD_EXP 40
20586: PPUSH
20587: LD_STRING D2Rus-JMM-1
20589: PPUSH
20590: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
20594: LD_EXP 61
20598: PPUSH
20599: LD_STRING D2Rus-Pow-1
20601: PPUSH
20602: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
20606: LD_EXP 40
20610: PPUSH
20611: LD_STRING D2Rus-JMM-2
20613: PPUSH
20614: CALL_OW 88
// if not ( 3 in list_of_q ) then
20618: LD_INT 3
20620: PUSH
20621: LD_VAR 0 2
20625: IN
20626: NOT
20627: IFFALSE 20643
// Say ( Powell , D2Rus-Pow-2 ) else
20629: LD_EXP 61
20633: PPUSH
20634: LD_STRING D2Rus-Pow-2
20636: PPUSH
20637: CALL_OW 88
20641: GO 20655
// Say ( Powell , D2Rus-Pow-2a ) ;
20643: LD_EXP 61
20647: PPUSH
20648: LD_STRING D2Rus-Pow-2a
20650: PPUSH
20651: CALL_OW 88
// end ; 3 :
20655: GO 20924
20657: LD_INT 3
20659: DOUBLE
20660: EQUAL
20661: IFTRUE 20665
20663: GO 20750
20665: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
20666: LD_EXP 40
20670: PPUSH
20671: LD_STRING D2Leg-JMM-1
20673: PPUSH
20674: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
20678: LD_EXP 61
20682: PPUSH
20683: LD_STRING D2Leg-Pow-1
20685: PPUSH
20686: CALL_OW 88
// if 2 in list_of_q then
20690: LD_INT 2
20692: PUSH
20693: LD_VAR 0 2
20697: IN
20698: IFFALSE 20724
// begin Say ( JMM , D2Leg-JMM-2 ) ;
20700: LD_EXP 40
20704: PPUSH
20705: LD_STRING D2Leg-JMM-2
20707: PPUSH
20708: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
20712: LD_EXP 61
20716: PPUSH
20717: LD_STRING D2Leg-Pow-2
20719: PPUSH
20720: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
20724: LD_EXP 40
20728: PPUSH
20729: LD_STRING D2Leg-JMM-3
20731: PPUSH
20732: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
20736: LD_EXP 61
20740: PPUSH
20741: LD_STRING D2Leg-Pow-3
20743: PPUSH
20744: CALL_OW 88
// end ; 4 :
20748: GO 20924
20750: LD_INT 4
20752: DOUBLE
20753: EQUAL
20754: IFTRUE 20758
20756: GO 20833
20758: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
20759: LD_EXP 40
20763: PPUSH
20764: LD_STRING D2Ar-JMM-1
20766: PPUSH
20767: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
20771: LD_EXP 61
20775: PPUSH
20776: LD_STRING D2Ar-Pow-1
20778: PPUSH
20779: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
20783: LD_EXP 40
20787: PPUSH
20788: LD_STRING D2Ar-JMM-2
20790: PPUSH
20791: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
20795: LD_EXP 61
20799: PPUSH
20800: LD_STRING D2Ar-Pow-2
20802: PPUSH
20803: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
20807: LD_EXP 40
20811: PPUSH
20812: LD_STRING D2Ar-JMM-3
20814: PPUSH
20815: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
20819: LD_EXP 61
20823: PPUSH
20824: LD_STRING D2Ar-Pow-3
20826: PPUSH
20827: CALL_OW 88
// end ; 5 :
20831: GO 20924
20833: LD_INT 5
20835: DOUBLE
20836: EQUAL
20837: IFTRUE 20841
20839: GO 20856
20841: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
20842: LD_EXP 40
20846: PPUSH
20847: LD_STRING D2Conf-JMM-1
20849: PPUSH
20850: CALL_OW 88
20854: GO 20924
20856: LD_INT 6
20858: DOUBLE
20859: EQUAL
20860: IFTRUE 20864
20862: GO 20923
20864: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
20865: LD_EXP 40
20869: PPUSH
20870: LD_STRING D2Com-JMM-1
20872: PPUSH
20873: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
20877: LD_EXP 61
20881: PPUSH
20882: LD_STRING D2Com-Pow-1
20884: PPUSH
20885: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
20889: LD_EXP 40
20893: PPUSH
20894: LD_STRING D2Com-JMM-2
20896: PPUSH
20897: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
20901: LD_EXP 61
20905: PPUSH
20906: LD_STRING D2Com-Pow-2
20908: PPUSH
20909: CALL_OW 88
// powellAngerQuery := true ;
20913: LD_ADDR_EXP 36
20917: PUSH
20918: LD_INT 1
20920: ST_TO_ADDR
// end ; end ;
20921: GO 20924
20923: POP
// end ;
20924: LD_VAR 0 3
20928: RET
// every 0 0$5 trigger missionStart do var tmp ;
20929: LD_EXP 13
20933: IFFALSE 21258
20935: GO 20937
20937: DISABLE
20938: LD_INT 0
20940: PPUSH
// begin repeat wait ( 0 0$1 ) ;
20941: LD_INT 35
20943: PPUSH
20944: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
20948: LD_INT 14
20950: PPUSH
20951: LD_INT 22
20953: PUSH
20954: LD_INT 1
20956: PUSH
20957: EMPTY
20958: LIST
20959: LIST
20960: PUSH
20961: LD_INT 3
20963: PUSH
20964: LD_INT 21
20966: PUSH
20967: LD_INT 3
20969: PUSH
20970: EMPTY
20971: LIST
20972: LIST
20973: PUSH
20974: EMPTY
20975: LIST
20976: LIST
20977: PUSH
20978: EMPTY
20979: LIST
20980: LIST
20981: PPUSH
20982: CALL_OW 70
20986: PUSH
20987: LD_EXP 15
20991: PUSH
20992: LD_INT 2
20994: PUSH
20995: LD_INT 3
20997: PUSH
20998: LD_INT 4
21000: PUSH
21001: LD_INT 5
21003: PUSH
21004: EMPTY
21005: LIST
21006: LIST
21007: LIST
21008: LIST
21009: IN
21010: AND
21011: IFFALSE 21248
// begin powellAnger := powellAnger + 1 ;
21013: LD_ADDR_EXP 17
21017: PUSH
21018: LD_EXP 17
21022: PUSH
21023: LD_INT 1
21025: PLUS
21026: ST_TO_ADDR
// Video ( true ) ;
21027: LD_INT 1
21029: PPUSH
21030: CALL 107333 0 1
// CenterNowOnUnits ( tmp ) ;
21034: LD_VAR 0 1
21038: PPUSH
21039: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
21043: LD_INT 14
21045: PPUSH
21046: LD_INT 22
21048: PUSH
21049: LD_INT 1
21051: PUSH
21052: EMPTY
21053: LIST
21054: LIST
21055: PPUSH
21056: CALL_OW 70
21060: PPUSH
21061: LD_INT 86
21063: PPUSH
21064: LD_INT 133
21066: PPUSH
21067: CALL_OW 111
// async ;
21071: ASYNC
// case powellAnger of 1 :
21072: LD_EXP 17
21076: PUSH
21077: LD_INT 1
21079: DOUBLE
21080: EQUAL
21081: IFTRUE 21085
21083: GO 21100
21085: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
21086: LD_EXP 61
21090: PPUSH
21091: LD_STRING DBack1-Pow-1
21093: PPUSH
21094: CALL_OW 88
21098: GO 21147
21100: LD_INT 2
21102: DOUBLE
21103: EQUAL
21104: IFTRUE 21108
21106: GO 21123
21108: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
21109: LD_EXP 61
21113: PPUSH
21114: LD_STRING DBack2-Pow-1
21116: PPUSH
21117: CALL_OW 88
21121: GO 21147
21123: LD_INT 3
21125: DOUBLE
21126: EQUAL
21127: IFTRUE 21131
21129: GO 21146
21131: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
21132: LD_EXP 61
21136: PPUSH
21137: LD_STRING DBack3-Pow-1
21139: PPUSH
21140: CALL_OW 88
21144: GO 21147
21146: POP
// sync ;
21147: SYNC
// repeat wait ( 0 0$1 ) ;
21148: LD_INT 35
21150: PPUSH
21151: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
21155: LD_INT 14
21157: PPUSH
21158: LD_INT 22
21160: PUSH
21161: LD_INT 1
21163: PUSH
21164: EMPTY
21165: LIST
21166: LIST
21167: PPUSH
21168: CALL_OW 70
21172: PPUSH
21173: LD_INT 86
21175: PPUSH
21176: LD_INT 133
21178: PPUSH
21179: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21183: LD_INT 14
21185: PPUSH
21186: LD_INT 22
21188: PUSH
21189: LD_INT 1
21191: PUSH
21192: EMPTY
21193: LIST
21194: LIST
21195: PUSH
21196: LD_INT 3
21198: PUSH
21199: LD_INT 21
21201: PUSH
21202: LD_INT 3
21204: PUSH
21205: EMPTY
21206: LIST
21207: LIST
21208: PUSH
21209: EMPTY
21210: LIST
21211: LIST
21212: PUSH
21213: EMPTY
21214: LIST
21215: LIST
21216: PPUSH
21217: CALL_OW 70
21221: NOT
21222: IFFALSE 21148
// if powellAnger >= 3 then
21224: LD_EXP 17
21228: PUSH
21229: LD_INT 3
21231: GREATEREQUAL
21232: IFFALSE 21241
// YouLost ( Dismissed ) ;
21234: LD_STRING Dismissed
21236: PPUSH
21237: CALL_OW 104
// Video ( false ) ;
21241: LD_INT 0
21243: PPUSH
21244: CALL 107333 0 1
// end ; until missionStage > 5 ;
21248: LD_EXP 15
21252: PUSH
21253: LD_INT 5
21255: GREATER
21256: IFFALSE 20941
// end ;
21258: PPOPN 1
21260: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t , p ;
21261: LD_EXP 13
21265: PUSH
21266: LD_INT 22
21268: PUSH
21269: LD_INT 4
21271: PUSH
21272: EMPTY
21273: LIST
21274: LIST
21275: PUSH
21276: LD_INT 21
21278: PUSH
21279: LD_INT 2
21281: PUSH
21282: EMPTY
21283: LIST
21284: LIST
21285: PUSH
21286: EMPTY
21287: LIST
21288: LIST
21289: PPUSH
21290: CALL_OW 69
21294: PUSH
21295: LD_INT 4
21297: GREATEREQUAL
21298: AND
21299: PUSH
21300: LD_EXP 15
21304: PUSH
21305: LD_INT 2
21307: EQUAL
21308: AND
21309: IFFALSE 23559
21311: GO 21313
21313: DISABLE
21314: LD_INT 0
21316: PPUSH
21317: PPUSH
21318: PPUSH
21319: PPUSH
21320: PPUSH
21321: PPUSH
21322: PPUSH
21323: PPUSH
21324: PPUSH
21325: PPUSH
21326: PPUSH
// begin missionStage := 3 ;
21327: LD_ADDR_EXP 15
21331: PUSH
21332: LD_INT 3
21334: ST_TO_ADDR
// retreat := false ;
21335: LD_ADDR_VAR 0 4
21339: PUSH
21340: LD_INT 0
21342: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
21343: LD_ADDR_VAR 0 5
21347: PUSH
21348: LD_INT 22
21350: PUSH
21351: LD_INT 4
21353: PUSH
21354: EMPTY
21355: LIST
21356: LIST
21357: PUSH
21358: LD_INT 30
21360: PUSH
21361: LD_INT 4
21363: PUSH
21364: EMPTY
21365: LIST
21366: LIST
21367: PUSH
21368: EMPTY
21369: LIST
21370: LIST
21371: PPUSH
21372: CALL_OW 69
21376: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21377: LD_ADDR_VAR 0 6
21381: PUSH
21382: LD_INT 22
21384: PUSH
21385: LD_INT 4
21387: PUSH
21388: EMPTY
21389: LIST
21390: LIST
21391: PUSH
21392: LD_INT 30
21394: PUSH
21395: LD_INT 5
21397: PUSH
21398: EMPTY
21399: LIST
21400: LIST
21401: PUSH
21402: EMPTY
21403: LIST
21404: LIST
21405: PPUSH
21406: CALL_OW 69
21410: ST_TO_ADDR
// if not bar then
21411: LD_VAR 0 6
21415: NOT
21416: IFFALSE 21469
// begin repeat wait ( 0 0$1 ) ;
21418: LD_INT 35
21420: PPUSH
21421: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
21425: LD_INT 22
21427: PUSH
21428: LD_INT 4
21430: PUSH
21431: EMPTY
21432: LIST
21433: LIST
21434: PUSH
21435: LD_INT 3
21437: PUSH
21438: LD_INT 57
21440: PUSH
21441: EMPTY
21442: LIST
21443: PUSH
21444: EMPTY
21445: LIST
21446: LIST
21447: PUSH
21448: LD_INT 30
21450: PUSH
21451: LD_INT 5
21453: PUSH
21454: EMPTY
21455: LIST
21456: LIST
21457: PUSH
21458: EMPTY
21459: LIST
21460: LIST
21461: LIST
21462: PPUSH
21463: CALL_OW 69
21467: IFFALSE 21418
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21469: LD_ADDR_VAR 0 6
21473: PUSH
21474: LD_INT 22
21476: PUSH
21477: LD_INT 4
21479: PUSH
21480: EMPTY
21481: LIST
21482: LIST
21483: PUSH
21484: LD_INT 30
21486: PUSH
21487: LD_INT 5
21489: PUSH
21490: EMPTY
21491: LIST
21492: LIST
21493: PUSH
21494: EMPTY
21495: LIST
21496: LIST
21497: PPUSH
21498: CALL_OW 69
21502: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21503: LD_INT 35
21505: PPUSH
21506: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
21510: LD_EXP 121
21514: PUSH
21515: LD_INT 4
21517: ARRAY
21518: PUSH
21519: LD_INT 4
21521: GREATEREQUAL
21522: IFFALSE 21503
// tmp := [ ] ;
21524: LD_ADDR_VAR 0 2
21528: PUSH
21529: EMPTY
21530: ST_TO_ADDR
// tmp2 := [ ] ;
21531: LD_ADDR_VAR 0 3
21535: PUSH
21536: EMPTY
21537: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell union vip ) do
21538: LD_ADDR_VAR 0 1
21542: PUSH
21543: LD_INT 22
21545: PUSH
21546: LD_INT 4
21548: PUSH
21549: EMPTY
21550: LIST
21551: LIST
21552: PUSH
21553: LD_INT 2
21555: PUSH
21556: LD_INT 25
21558: PUSH
21559: LD_INT 1
21561: PUSH
21562: EMPTY
21563: LIST
21564: LIST
21565: PUSH
21566: LD_INT 25
21568: PUSH
21569: LD_INT 2
21571: PUSH
21572: EMPTY
21573: LIST
21574: LIST
21575: PUSH
21576: LD_INT 25
21578: PUSH
21579: LD_INT 3
21581: PUSH
21582: EMPTY
21583: LIST
21584: LIST
21585: PUSH
21586: LD_INT 25
21588: PUSH
21589: LD_INT 4
21591: PUSH
21592: EMPTY
21593: LIST
21594: LIST
21595: PUSH
21596: LD_INT 25
21598: PUSH
21599: LD_INT 5
21601: PUSH
21602: EMPTY
21603: LIST
21604: LIST
21605: PUSH
21606: EMPTY
21607: LIST
21608: LIST
21609: LIST
21610: LIST
21611: LIST
21612: LIST
21613: PUSH
21614: EMPTY
21615: LIST
21616: LIST
21617: PPUSH
21618: CALL_OW 69
21622: PUSH
21623: LD_EXP 61
21627: PUSH
21628: LD_EXP 62
21632: UNION
21633: DIFF
21634: PUSH
21635: FOR_IN
21636: IFFALSE 21698
// if not i in extraSquad then
21638: LD_VAR 0 1
21642: PUSH
21643: LD_EXP 63
21647: IN
21648: NOT
21649: IFFALSE 21673
// tmp := Join ( tmp , i ) else
21651: LD_ADDR_VAR 0 2
21655: PUSH
21656: LD_VAR 0 2
21660: PPUSH
21661: LD_VAR 0 1
21665: PPUSH
21666: CALL 107361 0 2
21670: ST_TO_ADDR
21671: GO 21696
// tmp := Insert ( tmp , 1 , i ) ;
21673: LD_ADDR_VAR 0 2
21677: PUSH
21678: LD_VAR 0 2
21682: PPUSH
21683: LD_INT 1
21685: PPUSH
21686: LD_VAR 0 1
21690: PPUSH
21691: CALL_OW 2
21695: ST_TO_ADDR
21696: GO 21635
21698: POP
21699: POP
// for i in UnitFilter ( tmp , [ f_sex , sex_male ] ) do
21700: LD_ADDR_VAR 0 1
21704: PUSH
21705: LD_VAR 0 2
21709: PPUSH
21710: LD_INT 26
21712: PUSH
21713: LD_INT 1
21715: PUSH
21716: EMPTY
21717: LIST
21718: LIST
21719: PPUSH
21720: CALL_OW 72
21724: PUSH
21725: FOR_IN
21726: IFFALSE 21777
// begin p := Inc ( p ) ;
21728: LD_ADDR_VAR 0 11
21732: PUSH
21733: LD_VAR 0 11
21737: PPUSH
21738: CALL 108722 0 1
21742: ST_TO_ADDR
// tmp2 := Join ( tmp2 , i ) ;
21743: LD_ADDR_VAR 0 3
21747: PUSH
21748: LD_VAR 0 3
21752: PPUSH
21753: LD_VAR 0 1
21757: PPUSH
21758: CALL 107361 0 2
21762: ST_TO_ADDR
// if p = 4 then
21763: LD_VAR 0 11
21767: PUSH
21768: LD_INT 4
21770: EQUAL
21771: IFFALSE 21775
// break ;
21773: GO 21777
// end ;
21775: GO 21725
21777: POP
21778: POP
// tmp := tmp diff tmp2 ;
21779: LD_ADDR_VAR 0 2
21783: PUSH
21784: LD_VAR 0 2
21788: PUSH
21789: LD_VAR 0 3
21793: DIFF
21794: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
21795: LD_ADDR_VAR 0 2
21799: PUSH
21800: LD_VAR 0 2
21804: PPUSH
21805: LD_INT 3
21807: PPUSH
21808: CALL 105865 0 2
21812: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
21813: LD_ADDR_VAR 0 3
21817: PUSH
21818: LD_VAR 0 3
21822: PPUSH
21823: LD_INT 3
21825: PPUSH
21826: CALL 105865 0 2
21830: ST_TO_ADDR
// for i := 1 to 4 do
21831: LD_ADDR_VAR 0 1
21835: PUSH
21836: DOUBLE
21837: LD_INT 1
21839: DEC
21840: ST_TO_ADDR
21841: LD_INT 4
21843: PUSH
21844: FOR_TO
21845: IFFALSE 21998
// begin if tmp2 then
21847: LD_VAR 0 3
21851: IFFALSE 21919
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
21853: LD_ADDR_EXP 18
21857: PUSH
21858: LD_EXP 18
21862: PPUSH
21863: LD_INT 1
21865: PPUSH
21866: LD_EXP 18
21870: PUSH
21871: LD_INT 1
21873: ARRAY
21874: PUSH
21875: LD_VAR 0 3
21879: PUSH
21880: LD_VAR 0 3
21884: ARRAY
21885: ADD
21886: PPUSH
21887: CALL_OW 1
21891: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
21892: LD_VAR 0 3
21896: PUSH
21897: LD_VAR 0 3
21901: ARRAY
21902: PPUSH
21903: LD_INT 1
21905: PPUSH
21906: CALL_OW 109
// tmp2 := [ ] ;
21910: LD_ADDR_VAR 0 3
21914: PUSH
21915: EMPTY
21916: ST_TO_ADDR
// end else
21917: GO 21996
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
21919: LD_ADDR_EXP 18
21923: PUSH
21924: LD_EXP 18
21928: PPUSH
21929: LD_INT 1
21931: PPUSH
21932: LD_EXP 18
21936: PUSH
21937: LD_INT 1
21939: ARRAY
21940: PUSH
21941: LD_VAR 0 2
21945: PUSH
21946: LD_VAR 0 2
21950: ARRAY
21951: ADD
21952: PPUSH
21953: CALL_OW 1
21957: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
21958: LD_VAR 0 2
21962: PUSH
21963: LD_VAR 0 2
21967: ARRAY
21968: PPUSH
21969: LD_INT 1
21971: PPUSH
21972: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
21976: LD_ADDR_VAR 0 2
21980: PUSH
21981: LD_VAR 0 2
21985: PPUSH
21986: LD_VAR 0 2
21990: PPUSH
21991: CALL_OW 3
21995: ST_TO_ADDR
// end ; end ;
21996: GO 21844
21998: POP
21999: POP
// if tmp2 then
22000: LD_VAR 0 3
22004: IFFALSE 22022
// tmp := tmp union tmp2 ;
22006: LD_ADDR_VAR 0 2
22010: PUSH
22011: LD_VAR 0 2
22015: PUSH
22016: LD_VAR 0 3
22020: UNION
22021: ST_TO_ADDR
// for i := 1 to 4 do
22022: LD_ADDR_VAR 0 1
22026: PUSH
22027: DOUBLE
22028: LD_INT 1
22030: DEC
22031: ST_TO_ADDR
22032: LD_INT 4
22034: PUSH
22035: FOR_TO
22036: IFFALSE 22085
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
22038: LD_ADDR_EXP 18
22042: PUSH
22043: LD_EXP 18
22047: PPUSH
22048: LD_INT 2
22050: PPUSH
22051: LD_EXP 18
22055: PUSH
22056: LD_INT 2
22058: ARRAY
22059: PUSH
22060: LD_VAR 0 2
22064: PUSH
22065: LD_VAR 0 2
22069: PUSH
22070: LD_VAR 0 1
22074: MINUS
22075: ARRAY
22076: ADD
22077: PPUSH
22078: CALL_OW 1
22082: ST_TO_ADDR
22083: GO 22035
22085: POP
22086: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
22087: LD_ADDR_EXP 102
22091: PUSH
22092: LD_EXP 102
22096: PPUSH
22097: LD_INT 4
22099: PPUSH
22100: LD_EXP 102
22104: PUSH
22105: LD_INT 4
22107: ARRAY
22108: PUSH
22109: LD_EXP 18
22113: PUSH
22114: LD_INT 1
22116: ARRAY
22117: DIFF
22118: PPUSH
22119: CALL_OW 1
22123: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
22124: LD_VAR 0 5
22128: PUSH
22129: LD_INT 1
22131: ARRAY
22132: PPUSH
22133: CALL_OW 313
22137: IFFALSE 22192
// begin for i in UnitsInside ( arm [ 1 ] ) do
22139: LD_ADDR_VAR 0 1
22143: PUSH
22144: LD_VAR 0 5
22148: PUSH
22149: LD_INT 1
22151: ARRAY
22152: PPUSH
22153: CALL_OW 313
22157: PUSH
22158: FOR_IN
22159: IFFALSE 22190
// begin ComExitBuilding ( i ) ;
22161: LD_VAR 0 1
22165: PPUSH
22166: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
22170: LD_VAR 0 1
22174: PPUSH
22175: LD_VAR 0 6
22179: PUSH
22180: LD_INT 1
22182: ARRAY
22183: PPUSH
22184: CALL_OW 180
// end ;
22188: GO 22158
22190: POP
22191: POP
// end ; wait ( 0 0$3 ) ;
22192: LD_INT 105
22194: PPUSH
22195: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
22199: LD_ADDR_VAR 0 1
22203: PUSH
22204: LD_EXP 18
22208: PUSH
22209: LD_INT 1
22211: ARRAY
22212: PUSH
22213: FOR_IN
22214: IFFALSE 22321
// begin if IsInUnit ( i ) then
22216: LD_VAR 0 1
22220: PPUSH
22221: CALL_OW 310
22225: IFFALSE 22236
// ComExitBuilding ( i ) ;
22227: LD_VAR 0 1
22231: PPUSH
22232: CALL_OW 122
// if GetClass ( i ) <> 1 then
22236: LD_VAR 0 1
22240: PPUSH
22241: CALL_OW 257
22245: PUSH
22246: LD_INT 1
22248: NONEQUAL
22249: IFFALSE 22290
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
22251: LD_VAR 0 1
22255: PPUSH
22256: LD_VAR 0 5
22260: PUSH
22261: LD_INT 1
22263: ARRAY
22264: PPUSH
22265: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
22269: LD_VAR 0 1
22273: PPUSH
22274: LD_INT 1
22276: PPUSH
22277: CALL_OW 183
// AddComExitBuilding ( i ) ;
22281: LD_VAR 0 1
22285: PPUSH
22286: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
22290: LD_VAR 0 1
22294: PPUSH
22295: LD_INT 60
22297: PPUSH
22298: LD_INT 94
22300: PPUSH
22301: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
22305: LD_VAR 0 1
22309: PPUSH
22310: LD_EXP 61
22314: PPUSH
22315: CALL_OW 179
// end ;
22319: GO 22213
22321: POP
22322: POP
// wait ( 0 0$45 ) ;
22323: LD_INT 1575
22325: PPUSH
22326: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
22330: LD_EXP 61
22334: PPUSH
22335: LD_STRING D4-Pow-1
22337: PPUSH
22338: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
22342: LD_ADDR_VAR 0 2
22346: PUSH
22347: LD_EXP 18
22351: PUSH
22352: LD_INT 1
22354: ARRAY
22355: PPUSH
22356: LD_INT 26
22358: PUSH
22359: LD_INT 1
22361: PUSH
22362: EMPTY
22363: LIST
22364: LIST
22365: PPUSH
22366: CALL_OW 72
22370: ST_TO_ADDR
// if tmp then
22371: LD_VAR 0 2
22375: IFFALSE 22393
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
22377: LD_VAR 0 2
22381: PUSH
22382: LD_INT 1
22384: ARRAY
22385: PPUSH
22386: LD_STRING D4-Sol1-1
22388: PPUSH
22389: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
22393: LD_EXP 61
22397: PPUSH
22398: LD_STRING D4-Pow-2
22400: PPUSH
22401: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
22405: LD_ADDR_VAR 0 1
22409: PUSH
22410: DOUBLE
22411: LD_INT 1
22413: DEC
22414: ST_TO_ADDR
22415: LD_EXP 18
22419: PUSH
22420: LD_INT 1
22422: ARRAY
22423: PUSH
22424: FOR_TO
22425: IFFALSE 22518
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
22427: LD_EXP 18
22431: PUSH
22432: LD_INT 1
22434: ARRAY
22435: PUSH
22436: LD_VAR 0 1
22440: ARRAY
22441: PPUSH
22442: LD_EXP 121
22446: PUSH
22447: LD_INT 4
22449: ARRAY
22450: PUSH
22451: LD_INT 1
22453: ARRAY
22454: PPUSH
22455: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
22459: LD_ADDR_EXP 121
22463: PUSH
22464: LD_EXP 121
22468: PPUSH
22469: LD_INT 4
22471: PPUSH
22472: LD_EXP 121
22476: PUSH
22477: LD_INT 4
22479: ARRAY
22480: PPUSH
22481: LD_INT 1
22483: PPUSH
22484: CALL_OW 3
22488: PPUSH
22489: CALL_OW 1
22493: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
22494: LD_INT 8
22496: PPUSH
22497: LD_EXP 18
22501: PUSH
22502: LD_INT 1
22504: ARRAY
22505: PUSH
22506: LD_VAR 0 1
22510: ARRAY
22511: PPUSH
22512: CALL_OW 471
// end ;
22516: GO 22424
22518: POP
22519: POP
// repeat wait ( 0 0$1 ) ;
22520: LD_INT 35
22522: PPUSH
22523: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
22527: LD_EXP 18
22531: PUSH
22532: LD_INT 1
22534: ARRAY
22535: PPUSH
22536: LD_INT 55
22538: PUSH
22539: EMPTY
22540: LIST
22541: PPUSH
22542: CALL_OW 72
22546: PUSH
22547: LD_INT 4
22549: GREATEREQUAL
22550: IFFALSE 22520
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
22552: LD_EXP 18
22556: PUSH
22557: LD_INT 1
22559: ARRAY
22560: PPUSH
22561: LD_INT 69
22563: PPUSH
22564: LD_INT 94
22566: PPUSH
22567: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
22571: LD_EXP 18
22575: PUSH
22576: LD_INT 1
22578: ARRAY
22579: PPUSH
22580: LD_INT 82
22582: PPUSH
22583: LD_INT 83
22585: PPUSH
22586: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
22590: LD_EXP 18
22594: PUSH
22595: LD_INT 1
22597: ARRAY
22598: PPUSH
22599: LD_INT 77
22601: PPUSH
22602: LD_INT 69
22604: PPUSH
22605: CALL_OW 174
// repeat wait ( 3 ) ;
22609: LD_INT 3
22611: PPUSH
22612: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
22616: LD_ADDR_VAR 0 1
22620: PUSH
22621: LD_EXP 18
22625: PUSH
22626: LD_INT 1
22628: ARRAY
22629: PUSH
22630: FOR_IN
22631: IFFALSE 22767
// begin if GetLives ( i ) < 990 then
22633: LD_VAR 0 1
22637: PPUSH
22638: CALL_OW 256
22642: PUSH
22643: LD_INT 990
22645: LESS
22646: IFFALSE 22660
// SetLives ( i , 1000 ) ;
22648: LD_VAR 0 1
22652: PPUSH
22653: LD_INT 1000
22655: PPUSH
22656: CALL_OW 234
// if not IsInUnit ( i ) then
22660: LD_VAR 0 1
22664: PPUSH
22665: CALL_OW 310
22669: NOT
22670: IFFALSE 22765
// begin if not HasTask ( i ) then
22672: LD_VAR 0 1
22676: PPUSH
22677: CALL_OW 314
22681: NOT
22682: IFFALSE 22699
// ComMoveXY ( i , 64 , 93 ) ;
22684: LD_VAR 0 1
22688: PPUSH
22689: LD_INT 64
22691: PPUSH
22692: LD_INT 93
22694: PPUSH
22695: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
22699: LD_VAR 0 4
22703: NOT
22704: PUSH
22705: LD_VAR 0 1
22709: PPUSH
22710: CALL_OW 258
22714: PUSH
22715: LD_INT 1
22717: EQUAL
22718: AND
22719: IFFALSE 22765
// begin retreat := true ;
22721: LD_ADDR_VAR 0 4
22725: PUSH
22726: LD_INT 1
22728: ST_TO_ADDR
// SetTag ( i , 2 ) ;
22729: LD_VAR 0 1
22733: PPUSH
22734: LD_INT 2
22736: PPUSH
22737: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
22741: LD_VAR 0 1
22745: PPUSH
22746: LD_STRING D4a-Sol1-1
22748: PPUSH
22749: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
22753: LD_EXP 61
22757: PPUSH
22758: LD_STRING D4a-Pow-1
22760: PPUSH
22761: CALL_OW 88
// end ; end ; end ;
22765: GO 22630
22767: POP
22768: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
22769: LD_EXP 18
22773: PUSH
22774: LD_INT 1
22776: ARRAY
22777: PPUSH
22778: LD_INT 95
22780: PUSH
22781: LD_INT 9
22783: PUSH
22784: EMPTY
22785: LIST
22786: LIST
22787: PUSH
22788: LD_INT 3
22790: PUSH
22791: LD_INT 55
22793: PUSH
22794: EMPTY
22795: LIST
22796: PUSH
22797: EMPTY
22798: LIST
22799: LIST
22800: PUSH
22801: EMPTY
22802: LIST
22803: LIST
22804: PPUSH
22805: CALL_OW 72
22809: PUSH
22810: LD_INT 4
22812: GREATEREQUAL
22813: IFFALSE 22609
// for i in powellSquadAttack [ 1 ] do
22815: LD_ADDR_VAR 0 1
22819: PUSH
22820: LD_EXP 18
22824: PUSH
22825: LD_INT 1
22827: ARRAY
22828: PUSH
22829: FOR_IN
22830: IFFALSE 22966
// begin if GetTag ( i ) = 2 then
22832: LD_VAR 0 1
22836: PPUSH
22837: CALL_OW 110
22841: PUSH
22842: LD_INT 2
22844: EQUAL
22845: IFFALSE 22907
// begin ComMoveXY ( i , 60 , 94 ) ;
22847: LD_VAR 0 1
22851: PPUSH
22852: LD_INT 60
22854: PPUSH
22855: LD_INT 94
22857: PPUSH
22858: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
22862: LD_VAR 0 1
22866: PPUSH
22867: LD_EXP 61
22871: PPUSH
22872: CALL_OW 179
// wait ( 0 0$3 ) ;
22876: LD_INT 105
22878: PPUSH
22879: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
22883: LD_VAR 0 1
22887: PPUSH
22888: LD_STRING D4a-Sol1-2
22890: PPUSH
22891: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
22895: LD_EXP 61
22899: PPUSH
22900: LD_STRING D4a-Pow-2
22902: PPUSH
22903: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
22907: LD_VAR 0 1
22911: PPUSH
22912: LD_INT 0
22914: PPUSH
22915: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
22919: LD_ADDR_EXP 102
22923: PUSH
22924: LD_EXP 102
22928: PPUSH
22929: LD_INT 4
22931: PPUSH
22932: LD_EXP 102
22936: PUSH
22937: LD_INT 4
22939: ARRAY
22940: PUSH
22941: LD_VAR 0 1
22945: UNION
22946: PPUSH
22947: CALL_OW 1
22951: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
22952: LD_INT 8
22954: PPUSH
22955: LD_VAR 0 1
22959: PPUSH
22960: CALL_OW 472
// end ;
22964: GO 22829
22966: POP
22967: POP
// wait ( 2 2$00 ) ;
22968: LD_INT 4200
22970: PPUSH
22971: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
22975: LD_ADDR_VAR 0 9
22979: PUSH
22980: LD_INT 22
22982: PUSH
22983: LD_INT 4
22985: PUSH
22986: EMPTY
22987: LIST
22988: LIST
22989: PUSH
22990: LD_INT 30
22992: PUSH
22993: LD_INT 32
22995: PUSH
22996: EMPTY
22997: LIST
22998: LIST
22999: PUSH
23000: LD_INT 58
23002: PUSH
23003: EMPTY
23004: LIST
23005: PUSH
23006: EMPTY
23007: LIST
23008: LIST
23009: LIST
23010: PPUSH
23011: CALL_OW 69
23015: ST_TO_ADDR
// if tmp then
23016: LD_VAR 0 2
23020: IFFALSE 23260
// begin for i := 1 to tmp do
23022: LD_ADDR_VAR 0 1
23026: PUSH
23027: DOUBLE
23028: LD_INT 1
23030: DEC
23031: ST_TO_ADDR
23032: LD_VAR 0 2
23036: PUSH
23037: FOR_TO
23038: IFFALSE 23251
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
23040: LD_ADDR_EXP 102
23044: PUSH
23045: LD_EXP 102
23049: PPUSH
23050: LD_INT 4
23052: PPUSH
23053: LD_EXP 102
23057: PUSH
23058: LD_INT 4
23060: ARRAY
23061: PUSH
23062: LD_VAR 0 2
23066: PUSH
23067: LD_VAR 0 1
23071: ARRAY
23072: DIFF
23073: PPUSH
23074: CALL_OW 1
23078: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
23079: LD_ADDR_VAR 0 10
23083: PUSH
23084: LD_VAR 0 2
23088: PUSH
23089: LD_VAR 0 1
23093: ARRAY
23094: PPUSH
23095: CALL_OW 310
23099: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
23100: LD_VAR 0 10
23104: PUSH
23105: LD_VAR 0 10
23109: PPUSH
23110: CALL_OW 266
23114: PUSH
23115: LD_INT 32
23117: EQUAL
23118: AND
23119: IFFALSE 23123
// continue ;
23121: GO 23037
// if t then
23123: LD_VAR 0 10
23127: IFFALSE 23144
// ComExitBuilding ( tmp [ i ] ) ;
23129: LD_VAR 0 2
23133: PUSH
23134: LD_VAR 0 1
23138: ARRAY
23139: PPUSH
23140: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
23144: LD_VAR 0 2
23148: PUSH
23149: LD_VAR 0 1
23153: ARRAY
23154: PPUSH
23155: LD_VAR 0 5
23159: PUSH
23160: LD_INT 1
23162: ARRAY
23163: PPUSH
23164: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
23168: LD_VAR 0 2
23172: PUSH
23173: LD_VAR 0 1
23177: ARRAY
23178: PPUSH
23179: LD_INT 1
23181: PPUSH
23182: CALL_OW 183
// if emptyTowers then
23186: LD_VAR 0 9
23190: IFFALSE 23249
// begin AddComExitBuilding ( tmp [ i ] ) ;
23192: LD_VAR 0 2
23196: PUSH
23197: LD_VAR 0 1
23201: ARRAY
23202: PPUSH
23203: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
23207: LD_VAR 0 2
23211: PUSH
23212: LD_VAR 0 1
23216: ARRAY
23217: PPUSH
23218: LD_VAR 0 9
23222: PUSH
23223: LD_INT 1
23225: ARRAY
23226: PPUSH
23227: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
23231: LD_ADDR_VAR 0 9
23235: PUSH
23236: LD_VAR 0 9
23240: PPUSH
23241: LD_INT 1
23243: PPUSH
23244: CALL_OW 3
23248: ST_TO_ADDR
// end ; end ;
23249: GO 23037
23251: POP
23252: POP
// wait ( 0 0$30 ) ;
23253: LD_INT 1050
23255: PPUSH
23256: CALL_OW 67
// end ; uc_side := 6 ;
23260: LD_ADDR_OWVAR 20
23264: PUSH
23265: LD_INT 6
23267: ST_TO_ADDR
// uc_nation := 3 ;
23268: LD_ADDR_OWVAR 21
23272: PUSH
23273: LD_INT 3
23275: ST_TO_ADDR
// ru := [ ] ;
23276: LD_ADDR_VAR 0 7
23280: PUSH
23281: EMPTY
23282: ST_TO_ADDR
// for i = 1 to 5 do
23283: LD_ADDR_VAR 0 1
23287: PUSH
23288: DOUBLE
23289: LD_INT 1
23291: DEC
23292: ST_TO_ADDR
23293: LD_INT 5
23295: PUSH
23296: FOR_TO
23297: IFFALSE 23417
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
23299: LD_INT 22
23301: PUSH
23302: LD_INT 23
23304: PUSH
23305: EMPTY
23306: LIST
23307: LIST
23308: PUSH
23309: LD_INT 1
23311: PPUSH
23312: LD_INT 2
23314: PPUSH
23315: CALL_OW 12
23319: ARRAY
23320: PPUSH
23321: LD_INT 1
23323: PPUSH
23324: LD_INT 3
23326: PPUSH
23327: LD_INT 43
23329: PUSH
23330: LD_INT 44
23332: PUSH
23333: EMPTY
23334: LIST
23335: LIST
23336: PUSH
23337: LD_INT 1
23339: PPUSH
23340: LD_INT 2
23342: PPUSH
23343: CALL_OW 12
23347: ARRAY
23348: PPUSH
23349: LD_INT 89
23351: PPUSH
23352: CALL 74510 0 5
// un := CreateVehicle ;
23356: LD_ADDR_VAR 0 8
23360: PUSH
23361: CALL_OW 45
23365: ST_TO_ADDR
// SetDir ( un , 4 ) ;
23366: LD_VAR 0 8
23370: PPUSH
23371: LD_INT 4
23373: PPUSH
23374: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
23378: LD_VAR 0 8
23382: PPUSH
23383: LD_INT 136
23385: PPUSH
23386: LD_INT 90
23388: PPUSH
23389: LD_INT 8
23391: PPUSH
23392: LD_INT 0
23394: PPUSH
23395: CALL_OW 50
// ru := ru ^ un ;
23399: LD_ADDR_VAR 0 7
23403: PUSH
23404: LD_VAR 0 7
23408: PUSH
23409: LD_VAR 0 8
23413: ADD
23414: ST_TO_ADDR
// end ;
23415: GO 23296
23417: POP
23418: POP
// if ru then
23419: LD_VAR 0 7
23423: IFFALSE 23440
// ComAgressiveMove ( ru , 57 , 94 ) ;
23425: LD_VAR 0 7
23429: PPUSH
23430: LD_INT 57
23432: PPUSH
23433: LD_INT 94
23435: PPUSH
23436: CALL_OW 114
// wait ( 3 3$00 ) ;
23440: LD_INT 6300
23442: PPUSH
23443: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
23447: LD_INT 4
23449: PPUSH
23450: LD_INT 3
23452: PUSH
23453: LD_INT 1
23455: PUSH
23456: LD_INT 1
23458: PUSH
23459: LD_INT 5
23461: PUSH
23462: EMPTY
23463: LIST
23464: LIST
23465: LIST
23466: LIST
23467: PUSH
23468: LD_INT 4
23470: PUSH
23471: LD_INT 1
23473: PUSH
23474: LD_INT 1
23476: PUSH
23477: LD_INT 6
23479: PUSH
23480: EMPTY
23481: LIST
23482: LIST
23483: LIST
23484: LIST
23485: PUSH
23486: LD_INT 4
23488: PUSH
23489: LD_INT 1
23491: PUSH
23492: LD_INT 1
23494: PUSH
23495: LD_INT 7
23497: PUSH
23498: EMPTY
23499: LIST
23500: LIST
23501: LIST
23502: LIST
23503: PUSH
23504: LD_INT 3
23506: PUSH
23507: LD_INT 1
23509: PUSH
23510: LD_INT 1
23512: PUSH
23513: LD_INT 7
23515: PUSH
23516: EMPTY
23517: LIST
23518: LIST
23519: LIST
23520: LIST
23521: PUSH
23522: LD_INT 3
23524: PUSH
23525: LD_INT 1
23527: PUSH
23528: LD_INT 1
23530: PUSH
23531: LD_INT 5
23533: PUSH
23534: EMPTY
23535: LIST
23536: LIST
23537: LIST
23538: LIST
23539: PUSH
23540: EMPTY
23541: LIST
23542: LIST
23543: LIST
23544: LIST
23545: LIST
23546: PPUSH
23547: CALL 63196 0 2
// missionStage := 4 ;
23551: LD_ADDR_EXP 15
23555: PUSH
23556: LD_INT 4
23558: ST_TO_ADDR
// end ;
23559: PPOPN 11
23561: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
23562: LD_EXP 15
23566: PUSH
23567: LD_INT 4
23569: EQUAL
23570: PUSH
23571: LD_INT 22
23573: PUSH
23574: LD_INT 4
23576: PUSH
23577: EMPTY
23578: LIST
23579: LIST
23580: PUSH
23581: LD_INT 21
23583: PUSH
23584: LD_INT 2
23586: PUSH
23587: EMPTY
23588: LIST
23589: LIST
23590: PUSH
23591: EMPTY
23592: LIST
23593: LIST
23594: PPUSH
23595: CALL_OW 69
23599: PUSH
23600: LD_INT 5
23602: GREATEREQUAL
23603: AND
23604: IFFALSE 27871
23606: GO 23608
23608: DISABLE
23609: LD_INT 0
23611: PPUSH
23612: PPUSH
23613: PPUSH
23614: PPUSH
23615: PPUSH
23616: PPUSH
23617: PPUSH
23618: PPUSH
23619: PPUSH
23620: PPUSH
23621: PPUSH
23622: PPUSH
23623: PPUSH
// begin wait ( 0 0$10 ) ;
23624: LD_INT 350
23626: PPUSH
23627: CALL_OW 67
// missionStage := 5 ;
23631: LD_ADDR_EXP 15
23635: PUSH
23636: LD_INT 5
23638: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
23639: LD_ADDR_VAR 0 10
23643: PUSH
23644: LD_INT 22
23646: PUSH
23647: LD_INT 4
23649: PUSH
23650: EMPTY
23651: LIST
23652: LIST
23653: PUSH
23654: LD_INT 2
23656: PUSH
23657: LD_INT 30
23659: PUSH
23660: LD_INT 4
23662: PUSH
23663: EMPTY
23664: LIST
23665: LIST
23666: PUSH
23667: LD_INT 30
23669: PUSH
23670: LD_INT 5
23672: PUSH
23673: EMPTY
23674: LIST
23675: LIST
23676: PUSH
23677: EMPTY
23678: LIST
23679: LIST
23680: LIST
23681: PUSH
23682: EMPTY
23683: LIST
23684: LIST
23685: PPUSH
23686: CALL_OW 69
23690: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
23691: LD_ADDR_VAR 0 6
23695: PUSH
23696: LD_INT 22
23698: PUSH
23699: LD_INT 4
23701: PUSH
23702: EMPTY
23703: LIST
23704: LIST
23705: PUSH
23706: LD_INT 21
23708: PUSH
23709: LD_INT 1
23711: PUSH
23712: EMPTY
23713: LIST
23714: LIST
23715: PUSH
23716: LD_INT 3
23718: PUSH
23719: LD_INT 25
23721: PUSH
23722: LD_INT 16
23724: PUSH
23725: EMPTY
23726: LIST
23727: LIST
23728: PUSH
23729: EMPTY
23730: LIST
23731: LIST
23732: PUSH
23733: LD_INT 3
23735: PUSH
23736: LD_INT 25
23738: PUSH
23739: LD_INT 12
23741: PUSH
23742: EMPTY
23743: LIST
23744: LIST
23745: PUSH
23746: EMPTY
23747: LIST
23748: LIST
23749: PUSH
23750: EMPTY
23751: LIST
23752: LIST
23753: LIST
23754: LIST
23755: PPUSH
23756: CALL_OW 69
23760: PUSH
23761: LD_EXP 61
23765: DIFF
23766: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
23767: LD_ADDR_VAR 0 9
23771: PUSH
23772: LD_INT 22
23774: PUSH
23775: LD_INT 4
23777: PUSH
23778: EMPTY
23779: LIST
23780: LIST
23781: PUSH
23782: LD_INT 30
23784: PUSH
23785: LD_INT 3
23787: PUSH
23788: EMPTY
23789: LIST
23790: LIST
23791: PUSH
23792: EMPTY
23793: LIST
23794: LIST
23795: PPUSH
23796: CALL_OW 69
23800: PUSH
23801: LD_INT 1
23803: ARRAY
23804: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
23805: LD_INT 350
23807: PPUSH
23808: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
23812: LD_EXP 121
23816: PUSH
23817: LD_INT 4
23819: ARRAY
23820: PUSH
23821: LD_INT 5
23823: LESS
23824: PUSH
23825: LD_VAR 0 9
23829: PPUSH
23830: CALL_OW 461
23834: PUSH
23835: LD_INT 2
23837: EQUAL
23838: AND
23839: IFFALSE 23869
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
23841: LD_INT 4
23843: PPUSH
23844: LD_INT 3
23846: PUSH
23847: LD_INT 1
23849: PUSH
23850: LD_INT 1
23852: PUSH
23853: LD_INT 5
23855: PUSH
23856: EMPTY
23857: LIST
23858: LIST
23859: LIST
23860: LIST
23861: PUSH
23862: EMPTY
23863: LIST
23864: PPUSH
23865: CALL 63244 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
23869: LD_EXP 121
23873: PUSH
23874: LD_INT 4
23876: ARRAY
23877: PUSH
23878: LD_INT 5
23880: GREATEREQUAL
23881: PUSH
23882: LD_EXP 121
23886: PUSH
23887: LD_INT 4
23889: ARRAY
23890: PPUSH
23891: LD_INT 58
23893: PUSH
23894: EMPTY
23895: LIST
23896: PPUSH
23897: CALL_OW 72
23901: PUSH
23902: LD_INT 5
23904: GREATEREQUAL
23905: AND
23906: IFFALSE 23805
// powellAllowRetreat := false ;
23908: LD_ADDR_EXP 19
23912: PUSH
23913: LD_INT 0
23915: ST_TO_ADDR
// activeAttacks := false ;
23916: LD_ADDR_EXP 16
23920: PUSH
23921: LD_INT 0
23923: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
23924: LD_INT 35
23926: PPUSH
23927: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
23931: LD_INT 22
23933: PUSH
23934: LD_INT 6
23936: PUSH
23937: EMPTY
23938: LIST
23939: LIST
23940: PPUSH
23941: CALL_OW 69
23945: PUSH
23946: LD_INT 0
23948: EQUAL
23949: IFFALSE 23924
// tmp := mc_vehicles [ 4 ] ;
23951: LD_ADDR_VAR 0 3
23955: PUSH
23956: LD_EXP 121
23960: PUSH
23961: LD_INT 4
23963: ARRAY
23964: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
23965: LD_ADDR_VAR 0 1
23969: PUSH
23970: DOUBLE
23971: LD_INT 1
23973: DEC
23974: ST_TO_ADDR
23975: LD_EXP 18
23979: PUSH
23980: FOR_TO
23981: IFFALSE 24242
// begin for j in powellSquadAttack [ i ] do
23983: LD_ADDR_VAR 0 2
23987: PUSH
23988: LD_EXP 18
23992: PUSH
23993: LD_VAR 0 1
23997: ARRAY
23998: PUSH
23999: FOR_IN
24000: IFFALSE 24238
// begin forces := forces diff j ;
24002: LD_ADDR_VAR 0 6
24006: PUSH
24007: LD_VAR 0 6
24011: PUSH
24012: LD_VAR 0 2
24016: DIFF
24017: ST_TO_ADDR
// SetTag ( j , 1 ) ;
24018: LD_VAR 0 2
24022: PPUSH
24023: LD_INT 1
24025: PPUSH
24026: CALL_OW 109
// wait ( 0 0$2 ) ;
24030: LD_INT 70
24032: PPUSH
24033: CALL_OW 67
// if IsInUnit ( j ) then
24037: LD_VAR 0 2
24041: PPUSH
24042: CALL_OW 310
24046: IFFALSE 24057
// ComExitBuilding ( j ) ;
24048: LD_VAR 0 2
24052: PPUSH
24053: CALL_OW 122
// if GetClass ( j ) <> 1 then
24057: LD_VAR 0 2
24061: PPUSH
24062: CALL_OW 257
24066: PUSH
24067: LD_INT 1
24069: NONEQUAL
24070: IFFALSE 24150
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
24072: LD_VAR 0 10
24076: PUSH
24077: LD_INT 1
24079: ARRAY
24080: PPUSH
24081: CALL_OW 313
24085: PUSH
24086: LD_INT 5
24088: GREATEREQUAL
24089: IFFALSE 24111
// AddComEnterUnit ( j , arm [ 2 ] ) else
24091: LD_VAR 0 2
24095: PPUSH
24096: LD_VAR 0 10
24100: PUSH
24101: LD_INT 2
24103: ARRAY
24104: PPUSH
24105: CALL_OW 180
24109: GO 24129
// AddComEnterUnit ( j , arm [ 1 ] ) ;
24111: LD_VAR 0 2
24115: PPUSH
24116: LD_VAR 0 10
24120: PUSH
24121: LD_INT 1
24123: ARRAY
24124: PPUSH
24125: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
24129: LD_VAR 0 2
24133: PPUSH
24134: LD_INT 1
24136: PPUSH
24137: CALL_OW 183
// AddComExitBuilding ( j ) ;
24141: LD_VAR 0 2
24145: PPUSH
24146: CALL_OW 182
// end ; if i = 2 then
24150: LD_VAR 0 1
24154: PUSH
24155: LD_INT 2
24157: EQUAL
24158: IFFALSE 24175
// AddComMoveXY ( j , 61 , 93 ) ;
24160: LD_VAR 0 2
24164: PPUSH
24165: LD_INT 61
24167: PPUSH
24168: LD_INT 93
24170: PPUSH
24171: CALL_OW 171
// if i = 1 then
24175: LD_VAR 0 1
24179: PUSH
24180: LD_INT 1
24182: EQUAL
24183: IFFALSE 24236
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
24185: LD_VAR 0 2
24189: PPUSH
24190: LD_VAR 0 3
24194: PUSH
24195: LD_INT 1
24197: ARRAY
24198: PPUSH
24199: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
24203: LD_ADDR_VAR 0 3
24207: PUSH
24208: LD_VAR 0 3
24212: PPUSH
24213: LD_INT 1
24215: PPUSH
24216: CALL_OW 3
24220: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
24221: LD_VAR 0 2
24225: PPUSH
24226: LD_INT 69
24228: PPUSH
24229: LD_INT 94
24231: PPUSH
24232: CALL_OW 171
// end ; end ;
24236: GO 23999
24238: POP
24239: POP
// end ;
24240: GO 23980
24242: POP
24243: POP
// wait ( 0 0$30 ) ;
24244: LD_INT 1050
24246: PPUSH
24247: CALL_OW 67
// MC_Kill ( 4 ) ;
24251: LD_INT 4
24253: PPUSH
24254: CALL 39219 0 1
// tmp := UnitsInside ( fac ) ;
24258: LD_ADDR_VAR 0 3
24262: PUSH
24263: LD_VAR 0 9
24267: PPUSH
24268: CALL_OW 313
24272: ST_TO_ADDR
// if tmp then
24273: LD_VAR 0 3
24277: IFFALSE 24398
// for i in tmp do
24279: LD_ADDR_VAR 0 1
24283: PUSH
24284: LD_VAR 0 3
24288: PUSH
24289: FOR_IN
24290: IFFALSE 24396
// begin ComExitBuilding ( i ) ;
24292: LD_VAR 0 1
24296: PPUSH
24297: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
24301: LD_VAR 0 10
24305: PUSH
24306: LD_INT 2
24308: ARRAY
24309: PPUSH
24310: CALL_OW 313
24314: PUSH
24315: LD_INT 6
24317: LESS
24318: IFFALSE 24340
// AddComEnterUnit ( i , arm [ 2 ] ) else
24320: LD_VAR 0 1
24324: PPUSH
24325: LD_VAR 0 10
24329: PUSH
24330: LD_INT 2
24332: ARRAY
24333: PPUSH
24334: CALL_OW 180
24338: GO 24394
// if UnitsInside ( arm [ 1 ] ) < 6 then
24340: LD_VAR 0 10
24344: PUSH
24345: LD_INT 1
24347: ARRAY
24348: PPUSH
24349: CALL_OW 313
24353: PUSH
24354: LD_INT 6
24356: LESS
24357: IFFALSE 24379
// AddComEnterUnit ( i , arm [ 1 ] ) else
24359: LD_VAR 0 1
24363: PPUSH
24364: LD_VAR 0 10
24368: PUSH
24369: LD_INT 1
24371: ARRAY
24372: PPUSH
24373: CALL_OW 180
24377: GO 24394
// AddComMoveXY ( i , 37 , 68 ) ;
24379: LD_VAR 0 1
24383: PPUSH
24384: LD_INT 37
24386: PPUSH
24387: LD_INT 68
24389: PPUSH
24390: CALL_OW 171
// end ;
24394: GO 24289
24396: POP
24397: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
24398: LD_ADDR_VAR 0 11
24402: PUSH
24403: LD_VAR 0 6
24407: PPUSH
24408: LD_INT 26
24410: PUSH
24411: LD_INT 1
24413: PUSH
24414: EMPTY
24415: LIST
24416: LIST
24417: PPUSH
24418: CALL_OW 72
24422: PUSH
24423: LD_EXP 62
24427: DIFF
24428: ST_TO_ADDR
// if not speaker then
24429: LD_VAR 0 11
24433: NOT
24434: IFFALSE 24461
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
24436: LD_ADDR_VAR 0 11
24440: PUSH
24441: LD_VAR 0 6
24445: PPUSH
24446: LD_INT 26
24448: PUSH
24449: LD_INT 1
24451: PUSH
24452: EMPTY
24453: LIST
24454: LIST
24455: PPUSH
24456: CALL_OW 72
24460: ST_TO_ADDR
// if speaker then
24461: LD_VAR 0 11
24465: IFFALSE 24481
// speaker := speaker [ 1 ] ;
24467: LD_ADDR_VAR 0 11
24471: PUSH
24472: LD_VAR 0 11
24476: PUSH
24477: LD_INT 1
24479: ARRAY
24480: ST_TO_ADDR
// Video ( true ) ;
24481: LD_INT 1
24483: PPUSH
24484: CALL 107333 0 1
// CenterNowOnUnits ( Powell ) ;
24488: LD_EXP 61
24492: PPUSH
24493: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
24497: LD_ADDR_VAR 0 3
24501: PUSH
24502: LD_VAR 0 6
24506: PPUSH
24507: LD_INT 3
24509: PUSH
24510: LD_INT 25
24512: PUSH
24513: LD_INT 1
24515: PUSH
24516: EMPTY
24517: LIST
24518: LIST
24519: PUSH
24520: EMPTY
24521: LIST
24522: LIST
24523: PPUSH
24524: CALL_OW 72
24528: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
24529: LD_ADDR_VAR 0 12
24533: PUSH
24534: LD_INT 22
24536: PUSH
24537: LD_INT 4
24539: PUSH
24540: EMPTY
24541: LIST
24542: LIST
24543: PUSH
24544: LD_INT 30
24546: PUSH
24547: LD_INT 32
24549: PUSH
24550: EMPTY
24551: LIST
24552: LIST
24553: PUSH
24554: LD_INT 58
24556: PUSH
24557: EMPTY
24558: LIST
24559: PUSH
24560: EMPTY
24561: LIST
24562: LIST
24563: LIST
24564: PPUSH
24565: CALL_OW 69
24569: ST_TO_ADDR
// for i := 1 to 4 do
24570: LD_ADDR_VAR 0 1
24574: PUSH
24575: DOUBLE
24576: LD_INT 1
24578: DEC
24579: ST_TO_ADDR
24580: LD_INT 4
24582: PUSH
24583: FOR_TO
24584: IFFALSE 24730
// begin if IsInUnit ( tmp [ i ] ) then
24586: LD_VAR 0 3
24590: PUSH
24591: LD_VAR 0 1
24595: ARRAY
24596: PPUSH
24597: CALL_OW 310
24601: IFFALSE 24618
// ComExitBuilding ( tmp [ i ] ) ;
24603: LD_VAR 0 3
24607: PUSH
24608: LD_VAR 0 1
24612: ARRAY
24613: PPUSH
24614: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
24618: LD_VAR 0 3
24622: PUSH
24623: LD_VAR 0 1
24627: ARRAY
24628: PPUSH
24629: LD_VAR 0 10
24633: PUSH
24634: LD_INT 1
24636: ARRAY
24637: PPUSH
24638: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
24642: LD_VAR 0 3
24646: PUSH
24647: LD_VAR 0 1
24651: ARRAY
24652: PPUSH
24653: LD_INT 1
24655: PPUSH
24656: CALL_OW 183
// if Count ( emp_towers ) then
24660: LD_VAR 0 12
24664: PPUSH
24665: CALL 71772 0 1
24669: IFFALSE 24728
// begin AddComExitBuilding ( tmp [ i ] ) ;
24671: LD_VAR 0 3
24675: PUSH
24676: LD_VAR 0 1
24680: ARRAY
24681: PPUSH
24682: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
24686: LD_VAR 0 3
24690: PUSH
24691: LD_VAR 0 1
24695: ARRAY
24696: PPUSH
24697: LD_VAR 0 12
24701: PUSH
24702: LD_INT 1
24704: ARRAY
24705: PPUSH
24706: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
24710: LD_ADDR_VAR 0 12
24714: PUSH
24715: LD_VAR 0 12
24719: PPUSH
24720: LD_INT 1
24722: PPUSH
24723: CALL_OW 3
24727: ST_TO_ADDR
// end ; end ;
24728: GO 24583
24730: POP
24731: POP
// wait ( 0 0$5 ) ;
24732: LD_INT 175
24734: PPUSH
24735: CALL_OW 67
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
24739: LD_VAR 0 3
24743: PPUSH
24744: LD_INT 3
24746: PUSH
24747: LD_INT 54
24749: PUSH
24750: EMPTY
24751: LIST
24752: PUSH
24753: EMPTY
24754: LIST
24755: LIST
24756: PPUSH
24757: CALL_OW 72
24761: IFFALSE 24781
// ComEnterUnit ( tmp , arm [ 1 ] ) ;
24763: LD_VAR 0 3
24767: PPUSH
24768: LD_VAR 0 10
24772: PUSH
24773: LD_INT 1
24775: ARRAY
24776: PPUSH
24777: CALL_OW 120
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
24781: LD_ADDR_VAR 0 3
24785: PUSH
24786: LD_EXP 18
24790: PUSH
24791: LD_INT 1
24793: ARRAY
24794: PUSH
24795: LD_EXP 18
24799: PUSH
24800: LD_INT 2
24802: ARRAY
24803: ADD
24804: PPUSH
24805: LD_INT 26
24807: PUSH
24808: LD_INT 1
24810: PUSH
24811: EMPTY
24812: LIST
24813: LIST
24814: PPUSH
24815: CALL_OW 72
24819: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
24820: LD_ADDR_VAR 0 1
24824: PUSH
24825: LD_EXP 18
24829: PUSH
24830: LD_INT 2
24832: ARRAY
24833: PUSH
24834: FOR_IN
24835: IFFALSE 24853
// ComTurnUnit ( i , Powell ) ;
24837: LD_VAR 0 1
24841: PPUSH
24842: LD_EXP 61
24846: PPUSH
24847: CALL_OW 119
24851: GO 24834
24853: POP
24854: POP
// Say ( Powell , D5-Pow-1 ) ;
24855: LD_EXP 61
24859: PPUSH
24860: LD_STRING D5-Pow-1
24862: PPUSH
24863: CALL_OW 88
// if tmp then
24867: LD_VAR 0 3
24871: IFFALSE 24889
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
24873: LD_VAR 0 3
24877: PUSH
24878: LD_INT 1
24880: ARRAY
24881: PPUSH
24882: LD_STRING D5-Sol2-1
24884: PPUSH
24885: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
24889: LD_EXP 61
24893: PPUSH
24894: LD_STRING D5-Pow-2
24896: PPUSH
24897: CALL_OW 88
// if tmp > 1 then
24901: LD_VAR 0 3
24905: PUSH
24906: LD_INT 1
24908: GREATER
24909: IFFALSE 24927
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
24911: LD_VAR 0 3
24915: PUSH
24916: LD_INT 2
24918: ARRAY
24919: PPUSH
24920: LD_STRING D5-Sol2-2
24922: PPUSH
24923: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
24927: LD_EXP 61
24931: PPUSH
24932: LD_STRING D5-Pow-3
24934: PPUSH
24935: CALL_OW 88
// wait ( 0 0$1 ) ;
24939: LD_INT 35
24941: PPUSH
24942: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
24946: LD_ADDR_VAR 0 3
24950: PUSH
24951: LD_EXP 18
24955: PUSH
24956: LD_INT 1
24958: ARRAY
24959: PUSH
24960: LD_EXP 18
24964: PUSH
24965: LD_INT 2
24967: ARRAY
24968: UNION
24969: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
24970: LD_VAR 0 3
24974: PPUSH
24975: LD_INT 80
24977: PPUSH
24978: LD_INT 67
24980: PPUSH
24981: CALL_OW 114
// wait ( 0 0$2 ) ;
24985: LD_INT 70
24987: PPUSH
24988: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
24992: LD_INT 79
24994: PPUSH
24995: LD_INT 72
24997: PPUSH
24998: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
25002: LD_INT 70
25004: PPUSH
25005: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
25009: LD_VAR 0 3
25013: PPUSH
25014: LD_INT 3
25016: PUSH
25017: LD_INT 24
25019: PUSH
25020: LD_INT 1000
25022: PUSH
25023: EMPTY
25024: LIST
25025: LIST
25026: PUSH
25027: EMPTY
25028: LIST
25029: LIST
25030: PPUSH
25031: CALL_OW 72
25035: IFFALSE 25002
// Say ( Powell , D5a-Pow-1 ) ;
25037: LD_EXP 61
25041: PPUSH
25042: LD_STRING D5a-Pow-1
25044: PPUSH
25045: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
25049: LD_EXP 61
25053: PPUSH
25054: LD_STRING D5a-Pow-1a
25056: PPUSH
25057: CALL_OW 88
// wait ( 0 0$0.7 ) ;
25061: LD_INT 24
25063: PPUSH
25064: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
25068: LD_EXP 61
25072: PPUSH
25073: LD_STRING D5a-Pow-1b
25075: PPUSH
25076: CALL_OW 88
// wait ( 0 0$0.3 ) ;
25080: LD_INT 10
25082: PPUSH
25083: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
25087: LD_EXP 61
25091: PPUSH
25092: LD_STRING D5a-Pow-1c
25094: PPUSH
25095: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
25099: LD_VAR 0 3
25103: PPUSH
25104: LD_INT 68
25106: PPUSH
25107: LD_INT 63
25109: PPUSH
25110: CALL_OW 111
// wait ( 0 0$0.5 ) ;
25114: LD_INT 18
25116: PPUSH
25117: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
25121: LD_EXP 61
25125: PPUSH
25126: LD_STRING D5a-Pow-1d
25128: PPUSH
25129: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
25133: LD_INT 35
25135: PPUSH
25136: CALL_OW 67
// if not HasTask ( tmp ) then
25140: LD_VAR 0 3
25144: PPUSH
25145: CALL_OW 314
25149: NOT
25150: IFFALSE 25167
// ComAgressiveMove ( tmp , 68 , 63 ) ;
25152: LD_VAR 0 3
25156: PPUSH
25157: LD_INT 68
25159: PPUSH
25160: LD_INT 63
25162: PPUSH
25163: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
25167: LD_VAR 0 3
25171: PPUSH
25172: LD_INT 24
25174: PUSH
25175: LD_INT 1
25177: PUSH
25178: EMPTY
25179: LIST
25180: LIST
25181: PPUSH
25182: CALL_OW 72
25186: NOT
25187: IFFALSE 25133
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
25189: LD_ADDR_VAR 0 3
25193: PUSH
25194: LD_INT 22
25196: PUSH
25197: LD_INT 4
25199: PUSH
25200: EMPTY
25201: LIST
25202: LIST
25203: PUSH
25204: LD_INT 92
25206: PUSH
25207: LD_INT 60
25209: PUSH
25210: LD_INT 93
25212: PUSH
25213: LD_INT 10
25215: PUSH
25216: EMPTY
25217: LIST
25218: LIST
25219: LIST
25220: LIST
25221: PUSH
25222: LD_INT 3
25224: PUSH
25225: LD_INT 54
25227: PUSH
25228: EMPTY
25229: LIST
25230: PUSH
25231: EMPTY
25232: LIST
25233: LIST
25234: PUSH
25235: EMPTY
25236: LIST
25237: LIST
25238: LIST
25239: PPUSH
25240: CALL_OW 69
25244: PUSH
25245: LD_EXP 61
25249: DIFF
25250: ST_TO_ADDR
// if tmp then
25251: LD_VAR 0 3
25255: IFFALSE 25289
// for i in tmp do
25257: LD_ADDR_VAR 0 1
25261: PUSH
25262: LD_VAR 0 3
25266: PUSH
25267: FOR_IN
25268: IFFALSE 25287
// ComMoveXY ( i , 36 , 67 ) ;
25270: LD_VAR 0 1
25274: PPUSH
25275: LD_INT 36
25277: PPUSH
25278: LD_INT 67
25280: PPUSH
25281: CALL_OW 111
25285: GO 25267
25287: POP
25288: POP
// wait ( 0 0$3 ) ;
25289: LD_INT 105
25291: PPUSH
25292: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
25296: LD_VAR 0 11
25300: PPUSH
25301: LD_STRING D6-Sol3-1
25303: PPUSH
25304: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
25308: LD_EXP 61
25312: PPUSH
25313: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
25317: LD_EXP 61
25321: PPUSH
25322: LD_STRING D6-Pow-1
25324: PPUSH
25325: CALL_OW 88
// tmp := [ ] ;
25329: LD_ADDR_VAR 0 3
25333: PUSH
25334: EMPTY
25335: ST_TO_ADDR
// for i = 1 to 2 do
25336: LD_ADDR_VAR 0 1
25340: PUSH
25341: DOUBLE
25342: LD_INT 1
25344: DEC
25345: ST_TO_ADDR
25346: LD_INT 2
25348: PUSH
25349: FOR_TO
25350: IFFALSE 25464
// begin uc_side := 8 ;
25352: LD_ADDR_OWVAR 20
25356: PUSH
25357: LD_INT 8
25359: ST_TO_ADDR
// uc_nation := 2 ;
25360: LD_ADDR_OWVAR 21
25364: PUSH
25365: LD_INT 2
25367: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
25368: LD_INT 14
25370: PPUSH
25371: LD_INT 3
25373: PPUSH
25374: LD_INT 2
25376: PPUSH
25377: LD_INT 29
25379: PPUSH
25380: LD_INT 100
25382: PPUSH
25383: CALL 74510 0 5
// veh := CreateVehicle ;
25387: LD_ADDR_VAR 0 13
25391: PUSH
25392: CALL_OW 45
25396: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
25397: LD_VAR 0 13
25401: PPUSH
25402: LD_INT 4
25404: PPUSH
25405: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
25409: LD_VAR 0 13
25413: PPUSH
25414: LD_INT 99
25416: PPUSH
25417: LD_INT 83
25419: PPUSH
25420: LD_INT 3
25422: PPUSH
25423: LD_INT 0
25425: PPUSH
25426: CALL_OW 50
// wait ( 3 ) ;
25430: LD_INT 3
25432: PPUSH
25433: CALL_OW 67
// Connect ( veh ) ;
25437: LD_VAR 0 13
25441: PPUSH
25442: CALL 77978 0 1
// tmp := tmp ^ veh ;
25446: LD_ADDR_VAR 0 3
25450: PUSH
25451: LD_VAR 0 3
25455: PUSH
25456: LD_VAR 0 13
25460: ADD
25461: ST_TO_ADDR
// end ;
25462: GO 25349
25464: POP
25465: POP
// wait ( 0 0$1 ) ;
25466: LD_INT 35
25468: PPUSH
25469: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
25473: LD_INT 99
25475: PPUSH
25476: LD_INT 83
25478: PPUSH
25479: LD_INT 1
25481: PPUSH
25482: LD_INT 10
25484: PPUSH
25485: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
25489: LD_INT 99
25491: PPUSH
25492: LD_INT 83
25494: PPUSH
25495: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
25499: LD_VAR 0 11
25503: PPUSH
25504: LD_STRING D6-Sol3-2
25506: PPUSH
25507: CALL_OW 88
// async ;
25511: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
25512: LD_EXP 61
25516: PPUSH
25517: LD_STRING D6-Pow-2
25519: PPUSH
25520: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
25524: LD_VAR 0 3
25528: PUSH
25529: LD_INT 1
25531: ARRAY
25532: PPUSH
25533: LD_VAR 0 9
25537: PPUSH
25538: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
25542: LD_VAR 0 3
25546: PUSH
25547: LD_INT 2
25549: ARRAY
25550: PPUSH
25551: LD_INT 22
25553: PUSH
25554: LD_INT 4
25556: PUSH
25557: EMPTY
25558: LIST
25559: LIST
25560: PUSH
25561: LD_INT 21
25563: PUSH
25564: LD_INT 3
25566: PUSH
25567: EMPTY
25568: LIST
25569: LIST
25570: PUSH
25571: EMPTY
25572: LIST
25573: LIST
25574: PPUSH
25575: CALL_OW 69
25579: PPUSH
25580: LD_VAR 0 3
25584: PUSH
25585: LD_INT 2
25587: ARRAY
25588: PPUSH
25589: CALL_OW 74
25593: PPUSH
25594: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
25598: LD_EXP 61
25602: PPUSH
25603: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
25607: LD_INT 99
25609: PPUSH
25610: LD_INT 83
25612: PPUSH
25613: LD_INT 1
25615: PPUSH
25616: CALL_OW 331
// repeat wait ( 4 ) ;
25620: LD_INT 4
25622: PPUSH
25623: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
25627: LD_VAR 0 3
25631: PUSH
25632: LD_INT 1
25634: ARRAY
25635: PPUSH
25636: CALL_OW 256
25640: PUSH
25641: LD_INT 1000
25643: LESS
25644: IFFALSE 25662
// SetLives ( tmp [ 1 ] , 1000 ) ;
25646: LD_VAR 0 3
25650: PUSH
25651: LD_INT 1
25653: ARRAY
25654: PPUSH
25655: LD_INT 1000
25657: PPUSH
25658: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
25662: LD_INT 22
25664: PUSH
25665: LD_INT 4
25667: PUSH
25668: EMPTY
25669: LIST
25670: LIST
25671: PUSH
25672: LD_INT 30
25674: PUSH
25675: LD_INT 3
25677: PUSH
25678: EMPTY
25679: LIST
25680: LIST
25681: PUSH
25682: EMPTY
25683: LIST
25684: LIST
25685: PPUSH
25686: CALL_OW 69
25690: PUSH
25691: LD_INT 0
25693: EQUAL
25694: IFFALSE 25620
// skirmish := false ;
25696: LD_ADDR_EXP 100
25700: PUSH
25701: LD_INT 0
25703: ST_TO_ADDR
// sync ;
25704: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
25705: LD_EXP 61
25709: PPUSH
25710: LD_STRING D6a-Pow-1
25712: PPUSH
25713: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
25717: LD_VAR 0 11
25721: PPUSH
25722: LD_STRING D6a-Sol3-1
25724: PPUSH
25725: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
25729: LD_EXP 61
25733: PPUSH
25734: LD_STRING D6a-Pow-2
25736: PPUSH
25737: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
25741: LD_VAR 0 11
25745: PPUSH
25746: LD_STRING D6a-Sol3-2
25748: PPUSH
25749: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
25753: LD_EXP 61
25757: PPUSH
25758: LD_STRING D6a-Pow-3
25760: PPUSH
25761: CALL_OW 88
// powellCenterCameraMode := true ;
25765: LD_ADDR_EXP 20
25769: PUSH
25770: LD_INT 1
25772: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
25773: LD_ADDR_VAR 0 1
25777: PUSH
25778: LD_INT 22
25780: PUSH
25781: LD_INT 8
25783: PUSH
25784: EMPTY
25785: LIST
25786: LIST
25787: PUSH
25788: LD_INT 25
25790: PUSH
25791: LD_INT 2
25793: PUSH
25794: EMPTY
25795: LIST
25796: LIST
25797: PUSH
25798: EMPTY
25799: LIST
25800: LIST
25801: PPUSH
25802: CALL_OW 69
25806: PUSH
25807: FOR_IN
25808: IFFALSE 25863
// begin SetTag ( i , 1 ) ;
25810: LD_VAR 0 1
25814: PPUSH
25815: LD_INT 1
25817: PPUSH
25818: CALL_OW 109
// ComExitBuilding ( i ) ;
25822: LD_VAR 0 1
25826: PPUSH
25827: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
25831: LD_VAR 0 1
25835: PPUSH
25836: LD_INT 35
25838: PPUSH
25839: LD_INT 6
25841: PPUSH
25842: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
25846: LD_VAR 0 1
25850: PPUSH
25851: LD_INT 53
25853: PPUSH
25854: LD_INT 4
25856: PPUSH
25857: CALL_OW 171
// end ;
25861: GO 25807
25863: POP
25864: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
25865: LD_ADDR_VAR 0 3
25869: PUSH
25870: LD_INT 22
25872: PUSH
25873: LD_INT 4
25875: PUSH
25876: EMPTY
25877: LIST
25878: LIST
25879: PUSH
25880: LD_INT 21
25882: PUSH
25883: LD_INT 2
25885: PUSH
25886: EMPTY
25887: LIST
25888: LIST
25889: PUSH
25890: LD_INT 3
25892: PUSH
25893: LD_INT 34
25895: PUSH
25896: LD_INT 12
25898: PUSH
25899: EMPTY
25900: LIST
25901: LIST
25902: PUSH
25903: EMPTY
25904: LIST
25905: LIST
25906: PUSH
25907: EMPTY
25908: LIST
25909: LIST
25910: LIST
25911: PPUSH
25912: CALL_OW 69
25916: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
25917: LD_EXP 61
25921: PPUSH
25922: LD_VAR 0 3
25926: PPUSH
25927: LD_EXP 61
25931: PPUSH
25932: CALL_OW 74
25936: PPUSH
25937: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
25941: LD_EXP 61
25945: PPUSH
25946: LD_INT 100
25948: PPUSH
25949: LD_INT 88
25951: PPUSH
25952: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
25956: LD_EXP 61
25960: PPUSH
25961: LD_INT 100
25963: PPUSH
25964: LD_INT 75
25966: PPUSH
25967: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
25971: LD_EXP 61
25975: PPUSH
25976: LD_INT 88
25978: PPUSH
25979: LD_INT 53
25981: PPUSH
25982: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
25986: LD_INT 8
25988: PPUSH
25989: LD_EXP 61
25993: PPUSH
25994: CALL_OW 471
// repeat wait ( 3 ) ;
25998: LD_INT 3
26000: PPUSH
26001: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
26005: LD_INT 22
26007: PUSH
26008: LD_INT 4
26010: PUSH
26011: EMPTY
26012: LIST
26013: LIST
26014: PUSH
26015: LD_INT 92
26017: PUSH
26018: LD_INT 100
26020: PUSH
26021: LD_INT 75
26023: PUSH
26024: LD_INT 6
26026: PUSH
26027: EMPTY
26028: LIST
26029: LIST
26030: LIST
26031: LIST
26032: PUSH
26033: EMPTY
26034: LIST
26035: LIST
26036: PPUSH
26037: CALL_OW 69
26041: IFFALSE 25998
// async ;
26043: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
26044: LD_EXP 61
26048: PPUSH
26049: LD_STRING D6b-Pow-1
26051: PPUSH
26052: CALL_OW 88
// repeat wait ( 3 ) ;
26056: LD_INT 3
26058: PPUSH
26059: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
26063: LD_EXP 61
26067: PPUSH
26068: CALL_OW 310
26072: PPUSH
26073: CALL_OW 256
26077: PUSH
26078: LD_INT 1000
26080: LESS
26081: IFFALSE 26100
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
26083: LD_EXP 61
26087: PPUSH
26088: CALL_OW 310
26092: PPUSH
26093: LD_INT 1000
26095: PPUSH
26096: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
26100: LD_EXP 61
26104: PPUSH
26105: CALL_OW 256
26109: PUSH
26110: LD_INT 1000
26112: LESS
26113: IFFALSE 26127
// SetLives ( Powell , 1000 ) ;
26115: LD_EXP 61
26119: PPUSH
26120: LD_INT 1000
26122: PPUSH
26123: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
26127: LD_EXP 61
26131: PPUSH
26132: LD_EXP 67
26136: PPUSH
26137: CALL_OW 296
26141: PUSH
26142: LD_INT 5
26144: LESS
26145: PUSH
26146: LD_EXP 61
26150: PPUSH
26151: CALL_OW 310
26155: PPUSH
26156: LD_EXP 67
26160: PPUSH
26161: CALL_OW 296
26165: PUSH
26166: LD_INT 5
26168: LESS
26169: OR
26170: IFFALSE 26189
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
26172: LD_EXP 61
26176: PPUSH
26177: CALL_OW 310
26181: PPUSH
26182: LD_INT 100
26184: PPUSH
26185: CALL_OW 234
// until not IsInUnit ( Powell ) ;
26189: LD_EXP 61
26193: PPUSH
26194: CALL_OW 310
26198: NOT
26199: IFFALSE 26056
// DoNotAttack ( 8 , powellBomb ) ;
26201: LD_INT 8
26203: PPUSH
26204: LD_EXP 67
26208: PPUSH
26209: CALL_OW 471
// game_speed := 4 ;
26213: LD_ADDR_OWVAR 65
26217: PUSH
26218: LD_INT 4
26220: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
26221: LD_EXP 61
26225: PPUSH
26226: LD_STRING D6b-Pow-1a
26228: PPUSH
26229: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
26233: LD_EXP 61
26237: PPUSH
26238: LD_EXP 67
26242: PPUSH
26243: CALL_OW 180
// sync ;
26247: SYNC
// repeat wait ( 0 0$1 ) ;
26248: LD_INT 35
26250: PPUSH
26251: CALL_OW 67
// until IsInUnit ( Powell ) ;
26255: LD_EXP 61
26259: PPUSH
26260: CALL_OW 310
26264: IFFALSE 26248
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
26266: LD_INT 8
26268: PPUSH
26269: LD_EXP 61
26273: PPUSH
26274: CALL_OW 310
26278: PPUSH
26279: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
26283: LD_EXP 61
26287: PPUSH
26288: LD_INT 91
26290: PPUSH
26291: LD_INT 44
26293: PPUSH
26294: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26298: LD_EXP 61
26302: PPUSH
26303: LD_INT 96
26305: PPUSH
26306: LD_INT 44
26308: PPUSH
26309: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26313: LD_EXP 61
26317: PPUSH
26318: LD_INT 96
26320: PPUSH
26321: LD_INT 41
26323: PPUSH
26324: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
26328: LD_EXP 61
26332: PPUSH
26333: LD_INT 92
26335: PPUSH
26336: LD_INT 39
26338: PPUSH
26339: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
26343: LD_EXP 61
26347: PPUSH
26348: LD_INT 88
26350: PPUSH
26351: LD_INT 41
26353: PPUSH
26354: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
26358: LD_EXP 61
26362: PPUSH
26363: LD_INT 91
26365: PPUSH
26366: LD_INT 44
26368: PPUSH
26369: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26373: LD_EXP 61
26377: PPUSH
26378: LD_INT 96
26380: PPUSH
26381: LD_INT 44
26383: PPUSH
26384: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26388: LD_EXP 61
26392: PPUSH
26393: LD_INT 96
26395: PPUSH
26396: LD_INT 41
26398: PPUSH
26399: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
26403: LD_EXP 61
26407: PPUSH
26408: LD_INT 92
26410: PPUSH
26411: LD_INT 39
26413: PPUSH
26414: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
26418: LD_EXP 61
26422: PPUSH
26423: LD_INT 88
26425: PPUSH
26426: LD_INT 41
26428: PPUSH
26429: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
26433: LD_EXP 61
26437: PPUSH
26438: LD_INT 91
26440: PPUSH
26441: LD_INT 44
26443: PPUSH
26444: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
26448: LD_EXP 61
26452: PPUSH
26453: LD_INT 93
26455: PPUSH
26456: LD_INT 39
26458: PPUSH
26459: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
26463: LD_EXP 61
26467: PPUSH
26468: LD_INT 93
26470: PPUSH
26471: LD_INT 36
26473: PPUSH
26474: CALL_OW 171
// wait ( 0 0$3.5 ) ;
26478: LD_INT 122
26480: PPUSH
26481: CALL_OW 67
// game_speed := 4 ;
26485: LD_ADDR_OWVAR 65
26489: PUSH
26490: LD_INT 4
26492: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
26493: LD_EXP 61
26497: PPUSH
26498: LD_STRING D6b-Pow-1b
26500: PPUSH
26501: CALL_OW 88
// tmp := [ ] ;
26505: LD_ADDR_VAR 0 3
26509: PUSH
26510: EMPTY
26511: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
26512: LD_ADDR_VAR 0 5
26516: PUSH
26517: LD_INT 78
26519: PUSH
26520: LD_INT 47
26522: PUSH
26523: EMPTY
26524: LIST
26525: LIST
26526: PUSH
26527: LD_INT 106
26529: PUSH
26530: LD_INT 53
26532: PUSH
26533: EMPTY
26534: LIST
26535: LIST
26536: PUSH
26537: EMPTY
26538: LIST
26539: LIST
26540: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
26541: LD_ADDR_VAR 0 1
26545: PUSH
26546: LD_INT 22
26548: PUSH
26549: LD_INT 8
26551: PUSH
26552: EMPTY
26553: LIST
26554: LIST
26555: PUSH
26556: LD_INT 21
26558: PUSH
26559: LD_INT 3
26561: PUSH
26562: EMPTY
26563: LIST
26564: LIST
26565: PUSH
26566: LD_INT 92
26568: PUSH
26569: LD_INT 90
26571: PUSH
26572: LD_INT 52
26574: PUSH
26575: LD_INT 12
26577: PUSH
26578: EMPTY
26579: LIST
26580: LIST
26581: LIST
26582: LIST
26583: PUSH
26584: EMPTY
26585: LIST
26586: LIST
26587: LIST
26588: PPUSH
26589: CALL_OW 69
26593: PUSH
26594: FOR_IN
26595: IFFALSE 26620
// tmp := tmp ^ UnitsInside ( i ) ;
26597: LD_ADDR_VAR 0 3
26601: PUSH
26602: LD_VAR 0 3
26606: PUSH
26607: LD_VAR 0 1
26611: PPUSH
26612: CALL_OW 313
26616: ADD
26617: ST_TO_ADDR
26618: GO 26594
26620: POP
26621: POP
// for i in tmp do
26622: LD_ADDR_VAR 0 1
26626: PUSH
26627: LD_VAR 0 3
26631: PUSH
26632: FOR_IN
26633: IFFALSE 26795
// begin dist := 9999 ;
26635: LD_ADDR_VAR 0 8
26639: PUSH
26640: LD_INT 9999
26642: ST_TO_ADDR
// _xy := [ ] ;
26643: LD_ADDR_VAR 0 7
26647: PUSH
26648: EMPTY
26649: ST_TO_ADDR
// SetTag ( i , 1 ) ;
26650: LD_VAR 0 1
26654: PPUSH
26655: LD_INT 1
26657: PPUSH
26658: CALL_OW 109
// ComExitBuilding ( i ) ;
26662: LD_VAR 0 1
26666: PPUSH
26667: CALL_OW 122
// for j in xy do
26671: LD_ADDR_VAR 0 2
26675: PUSH
26676: LD_VAR 0 5
26680: PUSH
26681: FOR_IN
26682: IFFALSE 26764
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
26684: LD_VAR 0 1
26688: PPUSH
26689: LD_VAR 0 2
26693: PUSH
26694: LD_INT 1
26696: ARRAY
26697: PPUSH
26698: LD_VAR 0 2
26702: PUSH
26703: LD_INT 2
26705: ARRAY
26706: PPUSH
26707: CALL_OW 297
26711: PUSH
26712: LD_VAR 0 8
26716: LESS
26717: IFFALSE 26762
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
26719: LD_ADDR_VAR 0 8
26723: PUSH
26724: LD_VAR 0 1
26728: PPUSH
26729: LD_VAR 0 2
26733: PUSH
26734: LD_INT 1
26736: ARRAY
26737: PPUSH
26738: LD_VAR 0 2
26742: PUSH
26743: LD_INT 2
26745: ARRAY
26746: PPUSH
26747: CALL_OW 297
26751: ST_TO_ADDR
// _xy := j ;
26752: LD_ADDR_VAR 0 7
26756: PUSH
26757: LD_VAR 0 2
26761: ST_TO_ADDR
// end ;
26762: GO 26681
26764: POP
26765: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
26766: LD_VAR 0 1
26770: PPUSH
26771: LD_VAR 0 7
26775: PUSH
26776: LD_INT 1
26778: ARRAY
26779: PPUSH
26780: LD_VAR 0 7
26784: PUSH
26785: LD_INT 2
26787: ARRAY
26788: PPUSH
26789: CALL_OW 171
// end ;
26793: GO 26632
26795: POP
26796: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
26797: LD_ADDR_VAR 0 4
26801: PUSH
26802: LD_VAR 0 3
26806: PPUSH
26807: LD_INT 26
26809: PUSH
26810: LD_INT 1
26812: PUSH
26813: EMPTY
26814: LIST
26815: LIST
26816: PUSH
26817: LD_INT 25
26819: PUSH
26820: LD_INT 1
26822: PUSH
26823: EMPTY
26824: LIST
26825: LIST
26826: PUSH
26827: EMPTY
26828: LIST
26829: LIST
26830: PPUSH
26831: CALL_OW 72
26835: ST_TO_ADDR
// if tmp2 < 2 then
26836: LD_VAR 0 4
26840: PUSH
26841: LD_INT 2
26843: LESS
26844: IFFALSE 26913
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
26846: LD_ADDR_VAR 0 4
26850: PUSH
26851: LD_INT 22
26853: PUSH
26854: LD_INT 8
26856: PUSH
26857: EMPTY
26858: LIST
26859: LIST
26860: PUSH
26861: LD_INT 26
26863: PUSH
26864: LD_INT 1
26866: PUSH
26867: EMPTY
26868: LIST
26869: LIST
26870: PUSH
26871: LD_INT 3
26873: PUSH
26874: LD_INT 25
26876: PUSH
26877: LD_INT 15
26879: PUSH
26880: EMPTY
26881: LIST
26882: LIST
26883: PUSH
26884: EMPTY
26885: LIST
26886: LIST
26887: PUSH
26888: EMPTY
26889: LIST
26890: LIST
26891: LIST
26892: PPUSH
26893: CALL_OW 69
26897: PUSH
26898: LD_EXP 64
26902: PUSH
26903: LD_EXP 65
26907: PUSH
26908: EMPTY
26909: LIST
26910: LIST
26911: DIFF
26912: ST_TO_ADDR
// if tmp2 then
26913: LD_VAR 0 4
26917: IFFALSE 26935
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
26919: LD_VAR 0 4
26923: PUSH
26924: LD_INT 1
26926: ARRAY
26927: PPUSH
26928: LD_STRING D6b-ArSol1-1
26930: PPUSH
26931: CALL_OW 88
// async ;
26935: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
26936: LD_EXP 61
26940: PPUSH
26941: LD_STRING D6b-Pow-2
26943: PPUSH
26944: CALL_OW 88
// wait ( 0 0$0.5 ) ;
26948: LD_INT 18
26950: PPUSH
26951: CALL_OW 67
// if tmp2 > 1 then
26955: LD_VAR 0 4
26959: PUSH
26960: LD_INT 1
26962: GREATER
26963: IFFALSE 26981
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
26965: LD_VAR 0 4
26969: PUSH
26970: LD_INT 2
26972: ARRAY
26973: PPUSH
26974: LD_STRING D6b-ArSol2-1
26976: PPUSH
26977: CALL_OW 88
// sync ;
26981: SYNC
// repeat wait ( 5 ) ;
26982: LD_INT 5
26984: PPUSH
26985: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
26989: LD_INT 93
26991: PPUSH
26992: LD_INT 36
26994: PPUSH
26995: CALL_OW 428
26999: PPUSH
27000: CALL_OW 255
27004: PUSH
27005: LD_INT 4
27007: EQUAL
27008: IFFALSE 26982
// DialogueOn ;
27010: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
27014: LD_INT 10
27016: PPUSH
27017: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
27021: LD_EXP 61
27025: PPUSH
27026: LD_STRING D6b-Pow-2a
27028: PPUSH
27029: CALL_OW 88
// DialogueOff ;
27033: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
27037: LD_EXP 61
27041: PPUSH
27042: CALL_OW 310
27046: PPUSH
27047: LD_INT 332
27049: PPUSH
27050: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
27054: LD_INT 93
27056: PPUSH
27057: LD_INT 35
27059: PPUSH
27060: LD_INT 1
27062: PPUSH
27063: LD_INT 6
27065: NEG
27066: PPUSH
27067: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
27071: LD_INT 35
27073: PPUSH
27074: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
27078: LD_INT 332
27080: PPUSH
27081: CALL_OW 256
27085: PUSH
27086: LD_INT 1000
27088: LESS
27089: PUSH
27090: LD_INT 332
27092: PPUSH
27093: CALL_OW 300
27097: AND
27098: IFFALSE 27110
// SetLives ( kozlov_fac , 0 ) ;
27100: LD_INT 332
27102: PPUSH
27103: LD_INT 0
27105: PPUSH
27106: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
27110: LD_INT 332
27112: PPUSH
27113: CALL_OW 301
27117: PUSH
27118: LD_EXP 61
27122: PPUSH
27123: CALL_OW 301
27127: OR
27128: IFFALSE 27071
// game_speed := 4 ;
27130: LD_ADDR_OWVAR 65
27134: PUSH
27135: LD_INT 4
27137: ST_TO_ADDR
// powellCenterCameraMode := false ;
27138: LD_ADDR_EXP 20
27142: PUSH
27143: LD_INT 0
27145: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
27146: LD_ADDR_VAR 0 1
27150: PUSH
27151: LD_VAR 0 3
27155: PUSH
27156: LD_INT 22
27158: PUSH
27159: LD_INT 8
27161: PUSH
27162: EMPTY
27163: LIST
27164: LIST
27165: PUSH
27166: LD_INT 25
27168: PUSH
27169: LD_INT 2
27171: PUSH
27172: EMPTY
27173: LIST
27174: LIST
27175: PUSH
27176: EMPTY
27177: LIST
27178: LIST
27179: PPUSH
27180: CALL_OW 69
27184: UNION
27185: PUSH
27186: FOR_IN
27187: IFFALSE 27203
// SetTag ( i , 0 ) ;
27189: LD_VAR 0 1
27193: PPUSH
27194: LD_INT 0
27196: PPUSH
27197: CALL_OW 109
27201: GO 27186
27203: POP
27204: POP
// wait ( 0 0$3 ) ;
27205: LD_INT 105
27207: PPUSH
27208: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
27212: LD_INT 93
27214: PPUSH
27215: LD_INT 35
27217: PPUSH
27218: LD_INT 1
27220: PPUSH
27221: CALL_OW 331
// DialogueOn ;
27225: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
27229: LD_VAR 0 11
27233: PPUSH
27234: LD_STRING D6c-Sol3-1
27236: PPUSH
27237: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
27241: LD_INT 10
27243: PPUSH
27244: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
27248: LD_EXP 40
27252: PPUSH
27253: LD_STRING D6c-JMM-1
27255: PPUSH
27256: CALL_OW 88
// if Cyrus then
27260: LD_EXP 46
27264: IFFALSE 27278
// Say ( Cyrus , D6c-Cyrus-1 ) ;
27266: LD_EXP 46
27270: PPUSH
27271: LD_STRING D6c-Cyrus-1
27273: PPUSH
27274: CALL_OW 88
// if Bobby then
27278: LD_EXP 45
27282: IFFALSE 27296
// Say ( Bobby , D6c-Bobby-1 ) ;
27284: LD_EXP 45
27288: PPUSH
27289: LD_STRING D6c-Bobby-1
27291: PPUSH
27292: CALL_OW 88
// if Cornel then
27296: LD_EXP 51
27300: IFFALSE 27314
// Say ( Cornel , D6c-Corn-1 ) ;
27302: LD_EXP 51
27306: PPUSH
27307: LD_STRING D6c-Corn-1
27309: PPUSH
27310: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
27314: LD_ADDR_VAR 0 4
27318: PUSH
27319: LD_INT 2
27321: PUSH
27322: LD_INT 22
27324: PUSH
27325: LD_INT 1
27327: PUSH
27328: EMPTY
27329: LIST
27330: LIST
27331: PUSH
27332: LD_INT 22
27334: PUSH
27335: LD_INT 4
27337: PUSH
27338: EMPTY
27339: LIST
27340: LIST
27341: PUSH
27342: EMPTY
27343: LIST
27344: LIST
27345: LIST
27346: PUSH
27347: LD_INT 26
27349: PUSH
27350: LD_INT 1
27352: PUSH
27353: EMPTY
27354: LIST
27355: LIST
27356: PUSH
27357: LD_INT 23
27359: PUSH
27360: LD_INT 1
27362: PUSH
27363: EMPTY
27364: LIST
27365: LIST
27366: PUSH
27367: EMPTY
27368: LIST
27369: LIST
27370: LIST
27371: PPUSH
27372: CALL_OW 69
27376: PUSH
27377: LD_VAR 0 11
27381: PUSH
27382: LD_EXP 40
27386: UNION
27387: PUSH
27388: LD_EXP 62
27392: UNION
27393: DIFF
27394: ST_TO_ADDR
// if tmp2 then
27395: LD_VAR 0 4
27399: IFFALSE 27417
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
27401: LD_VAR 0 4
27405: PUSH
27406: LD_INT 1
27408: ARRAY
27409: PPUSH
27410: LD_STRING D6c-Sol1-1
27412: PPUSH
27413: CALL_OW 88
// if Lisa then
27417: LD_EXP 43
27421: IFFALSE 27435
// Say ( Lisa , D6c-Lisa-1 ) ;
27423: LD_EXP 43
27427: PPUSH
27428: LD_STRING D6c-Lisa-1
27430: PPUSH
27431: CALL_OW 88
// if Gary then
27435: LD_EXP 52
27439: IFFALSE 27453
// Say ( Gary , D6c-Gary-1 ) ;
27441: LD_EXP 52
27445: PPUSH
27446: LD_STRING D6c-Gary-1
27448: PPUSH
27449: CALL_OW 88
// if Donaldson then
27453: LD_EXP 44
27457: IFFALSE 27471
// Say ( Donaldson , D6c-Don-1 ) ;
27459: LD_EXP 44
27463: PPUSH
27464: LD_STRING D6c-Don-1
27466: PPUSH
27467: CALL_OW 88
// if tmp2 > 1 then
27471: LD_VAR 0 4
27475: PUSH
27476: LD_INT 1
27478: GREATER
27479: IFFALSE 27497
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
27481: LD_VAR 0 4
27485: PUSH
27486: LD_INT 2
27488: ARRAY
27489: PPUSH
27490: LD_STRING D6c-Sol2-1
27492: PPUSH
27493: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
27497: LD_VAR 0 11
27501: PPUSH
27502: LD_STRING D6c-Sol3-2
27504: PPUSH
27505: CALL_OW 88
// if IsInUnit ( JMM ) then
27509: LD_EXP 40
27513: PPUSH
27514: CALL_OW 310
27518: IFFALSE 27536
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
27520: LD_EXP 40
27524: PPUSH
27525: CALL_OW 310
27529: PPUSH
27530: CALL_OW 87
27534: GO 27545
// CenterNowOnUnits ( JMM ) ;
27536: LD_EXP 40
27540: PPUSH
27541: CALL_OW 87
// dwait ( 0 0$2 ) ;
27545: LD_INT 70
27547: PPUSH
27548: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
27552: LD_EXP 40
27556: PPUSH
27557: LD_STRING D6c-JMM-2
27559: PPUSH
27560: CALL_OW 88
// DialogueOff ;
27564: CALL_OW 7
// Video ( false ) ;
27568: LD_INT 0
27570: PPUSH
27571: CALL 107333 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
27575: LD_INT 22
27577: PUSH
27578: LD_INT 4
27580: PUSH
27581: EMPTY
27582: LIST
27583: LIST
27584: PPUSH
27585: CALL_OW 69
27589: PPUSH
27590: LD_INT 1
27592: PPUSH
27593: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
27597: LD_INT 4
27599: PPUSH
27600: LD_INT 4
27602: PPUSH
27603: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
27607: LD_ADDR_VAR 0 1
27611: PUSH
27612: LD_INT 4
27614: PPUSH
27615: LD_INT 1
27617: PPUSH
27618: LD_INT 2
27620: PPUSH
27621: CALL 69733 0 3
27625: PUSH
27626: FOR_IN
27627: IFFALSE 27664
// if GetTech ( i , 1 ) <> state_researched then
27629: LD_VAR 0 1
27633: PPUSH
27634: LD_INT 1
27636: PPUSH
27637: CALL_OW 321
27641: PUSH
27642: LD_INT 2
27644: NONEQUAL
27645: IFFALSE 27662
// SetTech ( i , 1 , state_researched ) ;
27647: LD_VAR 0 1
27651: PPUSH
27652: LD_INT 1
27654: PPUSH
27655: LD_INT 2
27657: PPUSH
27658: CALL_OW 322
27662: GO 27626
27664: POP
27665: POP
// missionStage := 6 ;
27666: LD_ADDR_EXP 15
27670: PUSH
27671: LD_INT 6
27673: ST_TO_ADDR
// activeAttacks := true ;
27674: LD_ADDR_EXP 16
27678: PUSH
27679: LD_INT 1
27681: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
27682: LD_STRING M2
27684: PPUSH
27685: CALL_OW 337
// SaveForQuickRestart ;
27689: CALL_OW 22
// wait ( 0 0$40 ) ;
27693: LD_INT 1400
27695: PPUSH
27696: CALL_OW 67
// DialogueOn ;
27700: CALL_OW 6
// SayRadioNoFaceNoName ( Friend , D7-Friend-1 ) ;
27704: LD_EXP 66
27708: PPUSH
27709: LD_STRING D7-Friend-1
27711: PPUSH
27712: CALL 111426 0 2
// Say ( JMM , D7-JMM-1 ) ;
27716: LD_EXP 40
27720: PPUSH
27721: LD_STRING D7-JMM-1
27723: PPUSH
27724: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-2 ) ;
27728: LD_EXP 66
27732: PPUSH
27733: LD_STRING D7-Friend-2
27735: PPUSH
27736: CALL 111426 0 2
// Say ( JMM , D7-JMM-2 ) ;
27740: LD_EXP 40
27744: PPUSH
27745: LD_STRING D7-JMM-2
27747: PPUSH
27748: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-3 ) ;
27752: LD_EXP 66
27756: PPUSH
27757: LD_STRING D7-Friend-3
27759: PPUSH
27760: CALL 111426 0 2
// Say ( JMM , D7-JMM-3 ) ;
27764: LD_EXP 40
27768: PPUSH
27769: LD_STRING D7-JMM-3
27771: PPUSH
27772: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-4 ) ;
27776: LD_EXP 66
27780: PPUSH
27781: LD_STRING D7-Friend-4
27783: PPUSH
27784: CALL 111426 0 2
// Say ( JMM , D7-JMM-4 ) ;
27788: LD_EXP 40
27792: PPUSH
27793: LD_STRING D7-JMM-4
27795: PPUSH
27796: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-5 ) ;
27800: LD_EXP 66
27804: PPUSH
27805: LD_STRING D7-Friend-5
27807: PPUSH
27808: CALL 111426 0 2
// Say ( JMM , D7-JMM-5 ) ;
27812: LD_EXP 40
27816: PPUSH
27817: LD_STRING D7-JMM-5
27819: PPUSH
27820: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-6 ) ;
27824: LD_EXP 66
27828: PPUSH
27829: LD_STRING D7-Friend-6
27831: PPUSH
27832: CALL 111426 0 2
// Say ( JMM , D7-JMM-6 ) ;
27836: LD_EXP 40
27840: PPUSH
27841: LD_STRING D7-JMM-6
27843: PPUSH
27844: CALL_OW 88
// DialogueOff ;
27848: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
27852: LD_STRING Mlegion
27854: PPUSH
27855: CALL_OW 337
// skirmish := true ;
27859: LD_ADDR_EXP 100
27863: PUSH
27864: LD_INT 1
27866: ST_TO_ADDR
// RebuildKozlovFactory ;
27867: CALL 5313 0 0
// end ;
27871: PPOPN 13
27873: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
27874: LD_EXP 20
27878: PUSH
27879: LD_EXP 61
27883: PPUSH
27884: CALL_OW 300
27888: AND
27889: IFFALSE 27931
27891: GO 27893
27893: DISABLE
// begin enable ;
27894: ENABLE
// if IsInUnit ( Powell ) then
27895: LD_EXP 61
27899: PPUSH
27900: CALL_OW 310
27904: IFFALSE 27922
// CenterOnUnits ( IsInUnit ( Powell ) ) else
27906: LD_EXP 61
27910: PPUSH
27911: CALL_OW 310
27915: PPUSH
27916: CALL_OW 85
27920: GO 27931
// CenterOnUnits ( Powell ) ;
27922: LD_EXP 61
27926: PPUSH
27927: CALL_OW 85
// end ;
27931: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
27932: LD_INT 22
27934: PUSH
27935: LD_INT 8
27937: PUSH
27938: EMPTY
27939: LIST
27940: LIST
27941: PUSH
27942: LD_INT 34
27944: PUSH
27945: LD_INT 48
27947: PUSH
27948: EMPTY
27949: LIST
27950: LIST
27951: PUSH
27952: EMPTY
27953: LIST
27954: LIST
27955: PPUSH
27956: CALL_OW 69
27960: IFFALSE 28234
27962: GO 27964
27964: DISABLE
27965: LD_INT 0
27967: PPUSH
27968: PPUSH
// begin if missionStage < 9 then
27969: LD_EXP 15
27973: PUSH
27974: LD_INT 9
27976: LESS
27977: IFFALSE 27987
// missionStage := 9 ;
27979: LD_ADDR_EXP 15
27983: PUSH
27984: LD_INT 9
27986: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27987: LD_ADDR_VAR 0 1
27991: PUSH
27992: LD_INT 22
27994: PUSH
27995: LD_INT 8
27997: PUSH
27998: EMPTY
27999: LIST
28000: LIST
28001: PUSH
28002: LD_INT 34
28004: PUSH
28005: LD_INT 48
28007: PUSH
28008: EMPTY
28009: LIST
28010: LIST
28011: PUSH
28012: EMPTY
28013: LIST
28014: LIST
28015: PPUSH
28016: CALL_OW 69
28020: PUSH
28021: LD_INT 1
28023: ARRAY
28024: ST_TO_ADDR
// wait ( 0 0$05 ) ;
28025: LD_INT 175
28027: PPUSH
28028: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
28032: LD_EXP 12
28036: PUSH
28037: LD_EXP 3
28041: PUSH
28042: LD_INT 0
28044: PUSH
28045: LD_INT 2
28047: PUSH
28048: EMPTY
28049: LIST
28050: LIST
28051: IN
28052: OR
28053: IFFALSE 28076
// target := [ 68 , 108 , 1 ] else
28055: LD_ADDR_VAR 0 2
28059: PUSH
28060: LD_INT 68
28062: PUSH
28063: LD_INT 108
28065: PUSH
28066: LD_INT 1
28068: PUSH
28069: EMPTY
28070: LIST
28071: LIST
28072: LIST
28073: ST_TO_ADDR
28074: GO 28095
// target := [ 181 , 88 , 2 ] ;
28076: LD_ADDR_VAR 0 2
28080: PUSH
28081: LD_INT 181
28083: PUSH
28084: LD_INT 88
28086: PUSH
28087: LD_INT 2
28089: PUSH
28090: EMPTY
28091: LIST
28092: LIST
28093: LIST
28094: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
28095: LD_VAR 0 1
28099: PPUSH
28100: LD_VAR 0 2
28104: PUSH
28105: LD_INT 1
28107: ARRAY
28108: PPUSH
28109: LD_VAR 0 2
28113: PUSH
28114: LD_INT 2
28116: ARRAY
28117: PPUSH
28118: CALL_OW 176
// if target [ 3 ] = 1 then
28122: LD_VAR 0 2
28126: PUSH
28127: LD_INT 3
28129: ARRAY
28130: PUSH
28131: LD_INT 1
28133: EQUAL
28134: IFFALSE 28150
// SayRadio ( Kurt , D12-Kurt-1 ) else
28136: LD_EXP 64
28140: PPUSH
28141: LD_STRING D12-Kurt-1
28143: PPUSH
28144: CALL_OW 94
28148: GO 28174
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
28150: LD_EXP 64
28154: PPUSH
28155: LD_STRING D12a-Kurt-1
28157: PPUSH
28158: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
28162: LD_EXP 79
28166: PPUSH
28167: LD_STRING D12a-Roth-1
28169: PPUSH
28170: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
28174: LD_INT 350
28176: PPUSH
28177: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
28181: LD_VAR 0 1
28185: PPUSH
28186: LD_INT 22
28188: PUSH
28189: LD_INT 8
28191: PUSH
28192: EMPTY
28193: LIST
28194: LIST
28195: PUSH
28196: LD_INT 23
28198: PUSH
28199: LD_INT 2
28201: PUSH
28202: EMPTY
28203: LIST
28204: LIST
28205: PUSH
28206: LD_INT 30
28208: PUSH
28209: LD_INT 3
28211: PUSH
28212: EMPTY
28213: LIST
28214: LIST
28215: PUSH
28216: EMPTY
28217: LIST
28218: LIST
28219: LIST
28220: PPUSH
28221: CALL_OW 69
28225: PUSH
28226: LD_INT 1
28228: ARRAY
28229: PPUSH
28230: CALL_OW 228
// end ;
28234: PPOPN 2
28236: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
28237: LD_EXP 64
28241: PPUSH
28242: CALL_OW 256
28246: PUSH
28247: LD_INT 999
28249: LESS
28250: PUSH
28251: LD_INT 22
28253: PUSH
28254: LD_INT 8
28256: PUSH
28257: EMPTY
28258: LIST
28259: LIST
28260: PUSH
28261: LD_INT 21
28263: PUSH
28264: LD_INT 1
28266: PUSH
28267: EMPTY
28268: LIST
28269: LIST
28270: PUSH
28271: LD_INT 23
28273: PUSH
28274: LD_INT 2
28276: PUSH
28277: EMPTY
28278: LIST
28279: LIST
28280: PUSH
28281: EMPTY
28282: LIST
28283: LIST
28284: LIST
28285: PPUSH
28286: CALL_OW 69
28290: PUSH
28291: LD_INT 9
28293: PUSH
28294: LD_INT 8
28296: PUSH
28297: LD_INT 7
28299: PUSH
28300: LD_INT 6
28302: PUSH
28303: EMPTY
28304: LIST
28305: LIST
28306: LIST
28307: LIST
28308: PUSH
28309: LD_OWVAR 67
28313: ARRAY
28314: LESSEQUAL
28315: OR
28316: PUSH
28317: LD_INT 22
28319: PUSH
28320: LD_INT 8
28322: PUSH
28323: EMPTY
28324: LIST
28325: LIST
28326: PUSH
28327: LD_INT 34
28329: PUSH
28330: LD_INT 48
28332: PUSH
28333: EMPTY
28334: LIST
28335: LIST
28336: PUSH
28337: EMPTY
28338: LIST
28339: LIST
28340: PPUSH
28341: CALL_OW 69
28345: NOT
28346: AND
28347: PUSH
28348: LD_EXP 64
28352: PPUSH
28353: CALL_OW 302
28357: AND
28358: PUSH
28359: LD_INT 5
28361: PPUSH
28362: LD_INT 22
28364: PUSH
28365: LD_INT 1
28367: PUSH
28368: EMPTY
28369: LIST
28370: LIST
28371: PPUSH
28372: CALL_OW 70
28376: AND
28377: IFFALSE 29139
28379: GO 28381
28381: DISABLE
28382: LD_INT 0
28384: PPUSH
28385: PPUSH
28386: PPUSH
// begin legionDestroyed := true ;
28387: LD_ADDR_EXP 22
28391: PUSH
28392: LD_INT 1
28394: ST_TO_ADDR
// DialogueOn ;
28395: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
28399: LD_EXP 40
28403: PPUSH
28404: LD_STRING D13-JMM-1
28406: PPUSH
28407: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
28411: LD_EXP 64
28415: PPUSH
28416: LD_STRING D13-Kurt-1
28418: PPUSH
28419: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
28423: LD_EXP 40
28427: PPUSH
28428: LD_STRING D13-JMM-2
28430: PPUSH
28431: CALL_OW 88
// if FakeInfo then
28435: LD_EXP 12
28439: IFFALSE 28459
// begin Say ( Kurt , D13-Kurt-2 ) ;
28441: LD_EXP 64
28445: PPUSH
28446: LD_STRING D13-Kurt-2
28448: PPUSH
28449: CALL_OW 88
// DialogueOff ;
28453: CALL_OW 7
// exit ;
28457: GO 29139
// end ; if not KurtStatus then
28459: LD_EXP 3
28463: NOT
28464: IFFALSE 28480
// Say ( Kurt , D13-Kurt-2b ) else
28466: LD_EXP 64
28470: PPUSH
28471: LD_STRING D13-Kurt-2b
28473: PPUSH
28474: CALL_OW 88
28478: GO 28492
// Say ( Kurt , D13-Kurt-2a ) ;
28480: LD_EXP 64
28484: PPUSH
28485: LD_STRING D13-Kurt-2a
28487: PPUSH
28488: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
28492: LD_EXP 40
28496: PPUSH
28497: LD_STRING D13-JMM-3
28499: PPUSH
28500: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
28504: LD_EXP 64
28508: PPUSH
28509: LD_STRING D13-Kurt-3
28511: PPUSH
28512: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
28516: LD_EXP 40
28520: PPUSH
28521: LD_STRING D13-JMM-4
28523: PPUSH
28524: CALL_OW 88
// DialogueOff ;
28528: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
28532: LD_STRING MlegionOut
28534: PPUSH
28535: CALL_OW 337
// MC_Kill ( 3 ) ;
28539: LD_INT 3
28541: PPUSH
28542: CALL 39219 0 1
// KillUnit ( Kozlov ) ;
28546: LD_EXP 65
28550: PPUSH
28551: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
28555: LD_ADDR_VAR 0 1
28559: PUSH
28560: LD_INT 22
28562: PUSH
28563: LD_INT 8
28565: PUSH
28566: EMPTY
28567: LIST
28568: LIST
28569: PUSH
28570: LD_INT 23
28572: PUSH
28573: LD_INT 3
28575: PUSH
28576: EMPTY
28577: LIST
28578: LIST
28579: PUSH
28580: LD_INT 3
28582: PUSH
28583: LD_INT 21
28585: PUSH
28586: LD_INT 33
28588: PUSH
28589: EMPTY
28590: LIST
28591: LIST
28592: PUSH
28593: EMPTY
28594: LIST
28595: LIST
28596: PUSH
28597: EMPTY
28598: LIST
28599: LIST
28600: LIST
28601: PPUSH
28602: CALL_OW 69
28606: PUSH
28607: FOR_IN
28608: IFFALSE 28621
// KillUnit ( i ) ;
28610: LD_VAR 0 1
28614: PPUSH
28615: CALL_OW 66
28619: GO 28607
28621: POP
28622: POP
// ChangeSideFog ( 8 , 1 ) ;
28623: LD_INT 8
28625: PPUSH
28626: LD_INT 1
28628: PPUSH
28629: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
28633: LD_ADDR_VAR 0 2
28637: PUSH
28638: LD_INT 22
28640: PUSH
28641: LD_INT 8
28643: PUSH
28644: EMPTY
28645: LIST
28646: LIST
28647: PUSH
28648: LD_INT 21
28650: PUSH
28651: LD_INT 1
28653: PUSH
28654: EMPTY
28655: LIST
28656: LIST
28657: PUSH
28658: EMPTY
28659: LIST
28660: LIST
28661: PPUSH
28662: CALL_OW 69
28666: PUSH
28667: LD_EXP 65
28671: PUSH
28672: LD_EXP 64
28676: PUSH
28677: EMPTY
28678: LIST
28679: LIST
28680: DIFF
28681: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
28682: LD_VAR 0 2
28686: PUSH
28687: LD_INT 6
28689: PUSH
28690: LD_INT 5
28692: PUSH
28693: LD_INT 4
28695: PUSH
28696: LD_INT 3
28698: PUSH
28699: EMPTY
28700: LIST
28701: LIST
28702: LIST
28703: LIST
28704: PUSH
28705: LD_OWVAR 67
28709: ARRAY
28710: GREATEREQUAL
28711: IFFALSE 28863
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
28713: LD_ADDR_VAR 0 3
28717: PUSH
28718: LD_INT 6
28720: PUSH
28721: LD_INT 5
28723: PUSH
28724: LD_INT 4
28726: PUSH
28727: LD_INT 3
28729: PUSH
28730: EMPTY
28731: LIST
28732: LIST
28733: LIST
28734: LIST
28735: PUSH
28736: LD_OWVAR 67
28740: ARRAY
28741: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
28742: LD_ADDR_VAR 0 1
28746: PUSH
28747: DOUBLE
28748: LD_VAR 0 2
28752: PUSH
28753: LD_VAR 0 3
28757: PUSH
28758: LD_INT 1
28760: PLUS
28761: MINUS
28762: INC
28763: ST_TO_ADDR
28764: LD_INT 1
28766: PUSH
28767: FOR_DOWNTO
28768: IFFALSE 28859
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
28770: LD_ADDR_EXP 38
28774: PUSH
28775: LD_EXP 38
28779: PUSH
28780: LD_VAR 0 2
28784: PUSH
28785: LD_VAR 0 1
28789: ARRAY
28790: ADD
28791: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
28792: LD_VAR 0 2
28796: PUSH
28797: LD_VAR 0 1
28801: ARRAY
28802: PPUSH
28803: CALL_OW 310
28807: IFFALSE 28824
// ComExit ( tmp [ i ] ) ;
28809: LD_VAR 0 2
28813: PUSH
28814: LD_VAR 0 1
28818: ARRAY
28819: PPUSH
28820: CALL 107759 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
28824: LD_VAR 0 2
28828: PUSH
28829: LD_VAR 0 1
28833: ARRAY
28834: PPUSH
28835: LD_INT 34
28837: PUSH
28838: LD_INT 0
28840: PPUSH
28841: LD_INT 6
28843: PPUSH
28844: CALL_OW 12
28848: PLUS
28849: PPUSH
28850: LD_INT 1
28852: PPUSH
28853: CALL_OW 171
// end ;
28857: GO 28767
28859: POP
28860: POP
// end else
28861: GO 28873
// x := tmp ;
28863: LD_ADDR_VAR 0 3
28867: PUSH
28868: LD_VAR 0 2
28872: ST_TO_ADDR
// for i := tmp downto tmp - x do
28873: LD_ADDR_VAR 0 1
28877: PUSH
28878: DOUBLE
28879: LD_VAR 0 2
28883: INC
28884: ST_TO_ADDR
28885: LD_VAR 0 2
28889: PUSH
28890: LD_VAR 0 3
28894: MINUS
28895: PUSH
28896: FOR_DOWNTO
28897: IFFALSE 28969
// begin if IsInUnit ( tmp [ i ] ) then
28899: LD_VAR 0 2
28903: PUSH
28904: LD_VAR 0 1
28908: ARRAY
28909: PPUSH
28910: CALL_OW 310
28914: IFFALSE 28931
// ComExit ( tmp [ i ] ) ;
28916: LD_VAR 0 2
28920: PUSH
28921: LD_VAR 0 1
28925: ARRAY
28926: PPUSH
28927: CALL 107759 0 1
// SetSide ( tmp [ i ] , 1 ) ;
28931: LD_VAR 0 2
28935: PUSH
28936: LD_VAR 0 1
28940: ARRAY
28941: PPUSH
28942: LD_INT 1
28944: PPUSH
28945: CALL_OW 235
// SetLives ( tmp [ i ] , 1000 ) ;
28949: LD_VAR 0 2
28953: PUSH
28954: LD_VAR 0 1
28958: ARRAY
28959: PPUSH
28960: LD_INT 1000
28962: PPUSH
28963: CALL_OW 234
// end ;
28967: GO 28896
28969: POP
28970: POP
// wait ( 0 0$0.3 ) ;
28971: LD_INT 10
28973: PPUSH
28974: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
28978: LD_ADDR_VAR 0 1
28982: PUSH
28983: LD_INT 22
28985: PUSH
28986: LD_INT 8
28988: PUSH
28989: EMPTY
28990: LIST
28991: LIST
28992: PUSH
28993: LD_INT 21
28995: PUSH
28996: LD_INT 2
28998: PUSH
28999: EMPTY
29000: LIST
29001: LIST
29002: PUSH
29003: EMPTY
29004: LIST
29005: LIST
29006: PPUSH
29007: CALL_OW 69
29011: PUSH
29012: FOR_IN
29013: IFFALSE 29026
// KillUnit ( i ) ;
29015: LD_VAR 0 1
29019: PPUSH
29020: CALL_OW 66
29024: GO 29012
29026: POP
29027: POP
// SetSide ( Kurt , 1 ) ;
29028: LD_EXP 64
29032: PPUSH
29033: LD_INT 1
29035: PPUSH
29036: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
29040: LD_INT 22
29042: PUSH
29043: LD_INT 8
29045: PUSH
29046: EMPTY
29047: LIST
29048: LIST
29049: PUSH
29050: LD_INT 21
29052: PUSH
29053: LD_INT 3
29055: PUSH
29056: EMPTY
29057: LIST
29058: LIST
29059: PUSH
29060: EMPTY
29061: LIST
29062: LIST
29063: PPUSH
29064: CALL_OW 69
29068: PPUSH
29069: LD_INT 1
29071: PPUSH
29072: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
29076: LD_INT 8
29078: PPUSH
29079: LD_INT 1
29081: PPUSH
29082: LD_INT 1
29084: PPUSH
29085: LD_INT 1
29087: PPUSH
29088: CALL_OW 80
// wait ( 1 1$20 ) ;
29092: LD_INT 2800
29094: PPUSH
29095: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
29099: LD_EXP 66
29103: PPUSH
29104: LD_INT 37
29106: PPUSH
29107: LD_INT 1
29109: PPUSH
29110: LD_INT 0
29112: PPUSH
29113: CALL_OW 48
// wait ( 0 0$1 ) ;
29117: LD_INT 35
29119: PPUSH
29120: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
29124: LD_EXP 66
29128: PPUSH
29129: LD_INT 60
29131: PPUSH
29132: LD_INT 95
29134: PPUSH
29135: CALL_OW 111
// end ;
29139: PPOPN 3
29141: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
29142: LD_EXP 22
29146: NOT
29147: PUSH
29148: LD_INT 22
29150: PUSH
29151: LD_INT 8
29153: PUSH
29154: EMPTY
29155: LIST
29156: LIST
29157: PUSH
29158: LD_INT 21
29160: PUSH
29161: LD_INT 1
29163: PUSH
29164: EMPTY
29165: LIST
29166: LIST
29167: PUSH
29168: EMPTY
29169: LIST
29170: LIST
29171: PPUSH
29172: CALL_OW 69
29176: PUSH
29177: LD_INT 0
29179: EQUAL
29180: AND
29181: IFFALSE 29201
29183: GO 29185
29185: DISABLE
// begin legionDestroyed := true ;
29186: LD_ADDR_EXP 22
29190: PUSH
29191: LD_INT 1
29193: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
29194: LD_STRING MlegionOut
29196: PPUSH
29197: CALL_OW 337
// end ;
29201: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
29202: LD_EXP 38
29206: IFFALSE 29281
29208: GO 29210
29210: DISABLE
29211: LD_INT 0
29213: PPUSH
// begin enable ;
29214: ENABLE
// for i in legionEscapeUnits do
29215: LD_ADDR_VAR 0 1
29219: PUSH
29220: LD_EXP 38
29224: PUSH
29225: FOR_IN
29226: IFFALSE 29279
// begin if IsInArea ( i , legionEscapeArea ) then
29228: LD_VAR 0 1
29232: PPUSH
29233: LD_INT 31
29235: PPUSH
29236: CALL_OW 308
29240: IFFALSE 29253
// RemoveUnit ( i ) else
29242: LD_VAR 0 1
29246: PPUSH
29247: CALL_OW 64
29251: GO 29277
// if not HasTask ( i ) then
29253: LD_VAR 0 1
29257: PPUSH
29258: CALL_OW 314
29262: NOT
29263: IFFALSE 29277
// ComMoveToArea ( i , legionEscapeArea ) ;
29265: LD_VAR 0 1
29269: PPUSH
29270: LD_INT 31
29272: PPUSH
29273: CALL_OW 113
// end ;
29277: GO 29225
29279: POP
29280: POP
// end ;
29281: PPOPN 1
29283: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
29284: LD_INT 1
29286: PPUSH
29287: LD_EXP 66
29291: PPUSH
29292: CALL_OW 292
29296: IFFALSE 29594
29298: GO 29300
29300: DISABLE
29301: LD_INT 0
29303: PPUSH
// begin wait ( 0 0$2 ) ;
29304: LD_INT 70
29306: PPUSH
29307: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
29311: LD_EXP 66
29315: PPUSH
29316: CALL_OW 87
// DialogueOn ;
29320: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
29324: LD_EXP 40
29328: PPUSH
29329: LD_STRING D14-JMM-1
29331: PPUSH
29332: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
29336: LD_EXP 66
29340: PPUSH
29341: LD_STRING D14-Friend-1
29343: PPUSH
29344: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
29348: LD_EXP 40
29352: PPUSH
29353: LD_STRING D14-JMM-2
29355: PPUSH
29356: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
29360: LD_EXP 66
29364: PPUSH
29365: LD_STRING D14-Friend-2
29367: PPUSH
29368: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
29372: LD_EXP 40
29376: PPUSH
29377: LD_STRING D14-JMM-3
29379: PPUSH
29380: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
29384: LD_EXP 66
29388: PPUSH
29389: LD_STRING D14-Friend-3
29391: PPUSH
29392: CALL_OW 88
// DialogueOff ;
29396: CALL_OW 7
// dec := Query ( Q14 ) ;
29400: LD_ADDR_VAR 0 1
29404: PUSH
29405: LD_STRING Q14
29407: PPUSH
29408: CALL_OW 97
29412: ST_TO_ADDR
// if dec = 1 then
29413: LD_VAR 0 1
29417: PUSH
29418: LD_INT 1
29420: EQUAL
29421: IFFALSE 29455
// begin DialogueOn ;
29423: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
29427: LD_EXP 40
29431: PPUSH
29432: LD_STRING D14a-JMM-1
29434: PPUSH
29435: CALL_OW 88
// DialogueOff ;
29439: CALL_OW 7
// SetSide ( Friend , 1 ) ;
29443: LD_EXP 66
29447: PPUSH
29448: LD_INT 1
29450: PPUSH
29451: CALL_OW 235
// end ; if dec = 2 then
29455: LD_VAR 0 1
29459: PUSH
29460: LD_INT 2
29462: EQUAL
29463: IFFALSE 29516
// begin DialogueOn ;
29465: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
29469: LD_EXP 40
29473: PPUSH
29474: LD_STRING D14b-JMM-1
29476: PPUSH
29477: CALL_OW 88
// DialogueOff ;
29481: CALL_OW 7
// wait ( 0 0$1 ) ;
29485: LD_INT 35
29487: PPUSH
29488: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
29492: LD_EXP 66
29496: PPUSH
29497: LD_INT 9
29499: PPUSH
29500: LD_INT 2
29502: PPUSH
29503: CALL_OW 111
// AddComHold ( Friend ) ;
29507: LD_EXP 66
29511: PPUSH
29512: CALL_OW 200
// end ; if dec = 3 then
29516: LD_VAR 0 1
29520: PUSH
29521: LD_INT 3
29523: EQUAL
29524: IFFALSE 29594
// begin DialogueOn ;
29526: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
29530: LD_EXP 40
29534: PPUSH
29535: LD_STRING D14c-JMM-1
29537: PPUSH
29538: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
29542: LD_EXP 66
29546: PPUSH
29547: LD_STRING D14c-Friend-1
29549: PPUSH
29550: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
29554: LD_EXP 40
29558: PPUSH
29559: LD_STRING D14c-JMM-2
29561: PPUSH
29562: CALL_OW 88
// DialogueOff ;
29566: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
29570: LD_EXP 66
29574: PPUSH
29575: LD_INT 9
29577: PPUSH
29578: LD_INT 2
29580: PPUSH
29581: CALL_OW 111
// AddComHold ( Friend ) ;
29585: LD_EXP 66
29589: PPUSH
29590: CALL_OW 200
// end ; end ;
29594: PPOPN 1
29596: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
29597: LD_INT 9
29599: PPUSH
29600: LD_INT 2
29602: PPUSH
29603: CALL_OW 428
29607: PUSH
29608: LD_EXP 66
29612: EQUAL
29613: PUSH
29614: LD_EXP 66
29618: PPUSH
29619: CALL_OW 255
29623: PUSH
29624: LD_INT 8
29626: EQUAL
29627: AND
29628: IFFALSE 29642
29630: GO 29632
29632: DISABLE
// RemoveUnit ( Friend ) ;
29633: LD_EXP 66
29637: PPUSH
29638: CALL_OW 64
29642: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
29643: LD_EXP 14
29647: PUSH
29648: LD_INT 31500
29650: GREATEREQUAL
29651: PUSH
29652: LD_EXP 7
29656: AND
29657: PUSH
29658: LD_EXP 2
29662: AND
29663: IFFALSE 30109
29665: GO 29667
29667: DISABLE
29668: LD_INT 0
29670: PPUSH
29671: PPUSH
29672: PPUSH
// begin missionStage := 7 ;
29673: LD_ADDR_EXP 15
29677: PUSH
29678: LD_INT 7
29680: ST_TO_ADDR
// for i := 1 to 5 do
29681: LD_ADDR_VAR 0 1
29685: PUSH
29686: DOUBLE
29687: LD_INT 1
29689: DEC
29690: ST_TO_ADDR
29691: LD_INT 5
29693: PUSH
29694: FOR_TO
29695: IFFALSE 29807
// begin uc_side = 1 ;
29697: LD_ADDR_OWVAR 20
29701: PUSH
29702: LD_INT 1
29704: ST_TO_ADDR
// uc_nation = 1 ;
29705: LD_ADDR_OWVAR 21
29709: PUSH
29710: LD_INT 1
29712: ST_TO_ADDR
// vc_engine = 3 ;
29713: LD_ADDR_OWVAR 39
29717: PUSH
29718: LD_INT 3
29720: ST_TO_ADDR
// vc_control = 3 ;
29721: LD_ADDR_OWVAR 38
29725: PUSH
29726: LD_INT 3
29728: ST_TO_ADDR
// vc_chassis = 3 ;
29729: LD_ADDR_OWVAR 37
29733: PUSH
29734: LD_INT 3
29736: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
29737: LD_ADDR_OWVAR 40
29741: PUSH
29742: LD_INT 5
29744: PUSH
29745: LD_INT 9
29747: PUSH
29748: LD_INT 7
29750: PUSH
29751: EMPTY
29752: LIST
29753: LIST
29754: LIST
29755: PUSH
29756: LD_INT 1
29758: PPUSH
29759: LD_INT 3
29761: PPUSH
29762: CALL_OW 12
29766: ARRAY
29767: ST_TO_ADDR
// veh = CreateVehicle ;
29768: LD_ADDR_VAR 0 2
29772: PUSH
29773: CALL_OW 45
29777: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
29778: LD_VAR 0 2
29782: PPUSH
29783: LD_INT 1
29785: PPUSH
29786: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
29790: LD_VAR 0 2
29794: PPUSH
29795: LD_INT 19
29797: PPUSH
29798: LD_INT 0
29800: PPUSH
29801: CALL_OW 49
// end ;
29805: GO 29694
29807: POP
29808: POP
// uc_side = 1 ;
29809: LD_ADDR_OWVAR 20
29813: PUSH
29814: LD_INT 1
29816: ST_TO_ADDR
// uc_nation = 1 ;
29817: LD_ADDR_OWVAR 21
29821: PUSH
29822: LD_INT 1
29824: ST_TO_ADDR
// vc_engine = 3 ;
29825: LD_ADDR_OWVAR 39
29829: PUSH
29830: LD_INT 3
29832: ST_TO_ADDR
// vc_control = 1 ;
29833: LD_ADDR_OWVAR 38
29837: PUSH
29838: LD_INT 1
29840: ST_TO_ADDR
// vc_chassis = 3 ;
29841: LD_ADDR_OWVAR 37
29845: PUSH
29846: LD_INT 3
29848: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
29849: LD_ADDR_OWVAR 40
29853: PUSH
29854: LD_INT 5
29856: PUSH
29857: LD_INT 9
29859: PUSH
29860: LD_INT 7
29862: PUSH
29863: EMPTY
29864: LIST
29865: LIST
29866: LIST
29867: PUSH
29868: LD_INT 1
29870: PPUSH
29871: LD_INT 3
29873: PPUSH
29874: CALL_OW 12
29878: ARRAY
29879: ST_TO_ADDR
// vehG = CreateVehicle ;
29880: LD_ADDR_VAR 0 3
29884: PUSH
29885: CALL_OW 45
29889: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
29890: LD_VAR 0 3
29894: PPUSH
29895: LD_INT 1
29897: PPUSH
29898: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
29902: LD_VAR 0 3
29906: PPUSH
29907: LD_INT 19
29909: PPUSH
29910: LD_INT 0
29912: PPUSH
29913: CALL_OW 49
// if JMMGirl = 1 then
29917: LD_EXP 7
29921: PUSH
29922: LD_INT 1
29924: EQUAL
29925: IFFALSE 29981
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
29927: LD_ADDR_EXP 41
29931: PUSH
29932: LD_STRING Joan
29934: PPUSH
29935: LD_INT 1
29937: PPUSH
29938: LD_STRING 14_
29940: PPUSH
29941: CALL 69670 0 3
29945: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
29946: LD_EXP 41
29950: PPUSH
29951: LD_VAR 0 3
29955: PPUSH
29956: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29960: LD_VAR 0 3
29964: PPUSH
29965: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
29969: LD_EXP 41
29973: PPUSH
29974: LD_STRING D10BW-Joan-1
29976: PPUSH
29977: CALL_OW 94
// end ; if JMMGirl = 2 then
29981: LD_EXP 7
29985: PUSH
29986: LD_INT 2
29988: EQUAL
29989: IFFALSE 30045
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
29991: LD_ADDR_EXP 43
29995: PUSH
29996: LD_STRING Lisa
29998: PPUSH
29999: LD_INT 1
30001: PPUSH
30002: LD_STRING 14_
30004: PPUSH
30005: CALL 69670 0 3
30009: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
30010: LD_EXP 43
30014: PPUSH
30015: LD_VAR 0 3
30019: PPUSH
30020: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30024: LD_VAR 0 3
30028: PPUSH
30029: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
30033: LD_EXP 43
30037: PPUSH
30038: LD_STRING D10BW-Lisa-1
30040: PPUSH
30041: CALL_OW 94
// end ; if JMMGirl = 3 then
30045: LD_EXP 7
30049: PUSH
30050: LD_INT 3
30052: EQUAL
30053: IFFALSE 30109
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
30055: LD_ADDR_EXP 55
30059: PUSH
30060: LD_STRING Connie
30062: PPUSH
30063: LD_INT 1
30065: PPUSH
30066: LD_STRING 14_
30068: PPUSH
30069: CALL 69670 0 3
30073: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
30074: LD_EXP 55
30078: PPUSH
30079: LD_VAR 0 3
30083: PPUSH
30084: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30088: LD_VAR 0 3
30092: PPUSH
30093: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
30097: LD_EXP 55
30101: PPUSH
30102: LD_STRING D10BW-Con-1
30104: PPUSH
30105: CALL_OW 94
// end ; end ;
30109: PPOPN 3
30111: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
30112: LD_EXP 14
30116: PUSH
30117: LD_INT 94500
30119: GREATEREQUAL
30120: IFFALSE 30532
30122: GO 30124
30124: DISABLE
30125: LD_INT 0
30127: PPUSH
30128: PPUSH
30129: PPUSH
// begin tmp := PrepareStevensSquad ;
30130: LD_ADDR_VAR 0 3
30134: PUSH
30135: CALL 2323 0 0
30139: ST_TO_ADDR
// if not tmp then
30140: LD_VAR 0 3
30144: NOT
30145: IFFALSE 30149
// exit ;
30147: GO 30532
// uc_side := 1 ;
30149: LD_ADDR_OWVAR 20
30153: PUSH
30154: LD_INT 1
30156: ST_TO_ADDR
// uc_nation := 1 ;
30157: LD_ADDR_OWVAR 21
30161: PUSH
30162: LD_INT 1
30164: ST_TO_ADDR
// for i in tmp do
30165: LD_ADDR_VAR 0 1
30169: PUSH
30170: LD_VAR 0 3
30174: PUSH
30175: FOR_IN
30176: IFFALSE 30273
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
30178: LD_INT 3
30180: PPUSH
30181: LD_INT 3
30183: PPUSH
30184: LD_INT 1
30186: PPUSH
30187: LD_INT 5
30189: PUSH
30190: LD_INT 9
30192: PUSH
30193: LD_INT 7
30195: PUSH
30196: EMPTY
30197: LIST
30198: LIST
30199: LIST
30200: PUSH
30201: LD_INT 1
30203: PPUSH
30204: LD_INT 3
30206: PPUSH
30207: CALL_OW 12
30211: ARRAY
30212: PPUSH
30213: LD_INT 40
30215: PPUSH
30216: CALL 74510 0 5
// veh := CreateVehicle ;
30220: LD_ADDR_VAR 0 2
30224: PUSH
30225: CALL_OW 45
30229: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
30230: LD_VAR 0 2
30234: PPUSH
30235: LD_INT 1
30237: PPUSH
30238: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
30242: LD_VAR 0 2
30246: PPUSH
30247: LD_INT 19
30249: PPUSH
30250: LD_INT 0
30252: PPUSH
30253: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
30257: LD_VAR 0 1
30261: PPUSH
30262: LD_VAR 0 2
30266: PPUSH
30267: CALL_OW 52
// end ;
30271: GO 30175
30273: POP
30274: POP
// missionStage := 8 ;
30275: LD_ADDR_EXP 15
30279: PUSH
30280: LD_INT 8
30282: ST_TO_ADDR
// DialogueOn ;
30283: CALL_OW 6
// if Stevens then
30287: LD_EXP 42
30291: IFFALSE 30405
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
30293: LD_EXP 42
30297: PPUSH
30298: CALL_OW 310
30302: PPUSH
30303: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
30307: LD_EXP 42
30311: PPUSH
30312: LD_STRING D8-Huck-1
30314: PPUSH
30315: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
30319: LD_EXP 40
30323: PPUSH
30324: LD_STRING D8-JMM-1
30326: PPUSH
30327: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
30331: LD_EXP 42
30335: PPUSH
30336: LD_STRING D8-Huck-2
30338: PPUSH
30339: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
30343: LD_EXP 40
30347: PPUSH
30348: LD_STRING D8-JMM-2
30350: PPUSH
30351: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
30355: LD_EXP 42
30359: PPUSH
30360: LD_STRING D8-Huck-3
30362: PPUSH
30363: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
30367: LD_EXP 40
30371: PPUSH
30372: LD_STRING D8-JMM-3
30374: PPUSH
30375: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
30379: LD_EXP 42
30383: PPUSH
30384: LD_STRING D8-Huck-4
30386: PPUSH
30387: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
30391: LD_EXP 40
30395: PPUSH
30396: LD_STRING D8-JMM-4
30398: PPUSH
30399: CALL_OW 88
// end else
30403: GO 30515
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
30405: LD_EXP 56
30409: PPUSH
30410: CALL_OW 310
30414: PPUSH
30415: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
30419: LD_EXP 56
30423: PPUSH
30424: LD_STRING D8-Huck-1
30426: PPUSH
30427: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
30431: LD_EXP 40
30435: PPUSH
30436: LD_STRING D8-JMM-1a
30438: PPUSH
30439: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
30443: LD_EXP 56
30447: PPUSH
30448: LD_STRING D8-Huck-2
30450: PPUSH
30451: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
30455: LD_EXP 40
30459: PPUSH
30460: LD_STRING D8-JMM-2
30462: PPUSH
30463: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
30467: LD_EXP 56
30471: PPUSH
30472: LD_STRING D8-Huck-3
30474: PPUSH
30475: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
30479: LD_EXP 40
30483: PPUSH
30484: LD_STRING D8-JMM-3
30486: PPUSH
30487: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
30491: LD_EXP 56
30495: PPUSH
30496: LD_STRING D8-Huck-4
30498: PPUSH
30499: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
30503: LD_EXP 40
30507: PPUSH
30508: LD_STRING D8-JMM-4
30510: PPUSH
30511: CALL_OW 88
// end ; DialogueOff ;
30515: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
30519: LD_INT 25
30521: PPUSH
30522: LD_INT 1
30524: PPUSH
30525: LD_INT 1
30527: PPUSH
30528: CALL_OW 322
// end ;
30532: PPOPN 3
30534: END
// every 0 0$1 trigger IsOk ( sewiVeh ) and See ( 1 , sewiVeh ) do
30535: LD_EXP 75
30539: PPUSH
30540: CALL_OW 302
30544: PUSH
30545: LD_INT 1
30547: PPUSH
30548: LD_EXP 75
30552: PPUSH
30553: CALL_OW 292
30557: AND
30558: IFFALSE 30809
30560: GO 30562
30562: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
30563: LD_EXP 75
30567: PPUSH
30568: CALL_OW 87
// DialogueOn ;
30572: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
30576: LD_EXP 40
30580: PPUSH
30581: LD_STRING D10nB-JMM-1
30583: PPUSH
30584: CALL_OW 88
// if BurlakStatus = 1 then
30588: LD_EXP 9
30592: PUSH
30593: LD_INT 1
30595: EQUAL
30596: IFFALSE 30610
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
30598: LD_EXP 74
30602: PPUSH
30603: LD_STRING D10nB-Vse-1a
30605: PPUSH
30606: CALL_OW 94
// end ; if BurlakStatus = 0 then
30610: LD_EXP 9
30614: PUSH
30615: LD_INT 0
30617: EQUAL
30618: IFFALSE 30632
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
30620: LD_EXP 74
30624: PPUSH
30625: LD_STRING D10nB-Vse-1
30627: PPUSH
30628: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
30632: LD_EXP 40
30636: PPUSH
30637: LD_STRING D10nB-JMM-2
30639: PPUSH
30640: CALL_OW 88
// if KappaStatus then
30644: LD_EXP 2
30648: IFFALSE 30662
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
30650: LD_EXP 74
30654: PPUSH
30655: LD_STRING D10nB-Vse-5a
30657: PPUSH
30658: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
30662: LD_EXP 2
30666: NOT
30667: PUSH
30668: LD_EXP 6
30672: PUSH
30673: LD_INT 0
30675: EQUAL
30676: AND
30677: IFFALSE 30805
// begin if JMMGirl = 1 then
30679: LD_EXP 7
30683: PUSH
30684: LD_INT 1
30686: EQUAL
30687: IFFALSE 30737
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
30689: LD_EXP 74
30693: PPUSH
30694: LD_STRING D10nB-Vse-2
30696: PPUSH
30697: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
30701: LD_EXP 40
30705: PPUSH
30706: LD_STRING D10nB-JMM-3
30708: PPUSH
30709: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
30713: LD_EXP 74
30717: PPUSH
30718: LD_STRING D10nB-Vse-3
30720: PPUSH
30721: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
30725: LD_EXP 40
30729: PPUSH
30730: LD_STRING D10nB-JMM-4
30732: PPUSH
30733: CALL_OW 88
// end ; if JMMGirl = 2 then
30737: LD_EXP 7
30741: PUSH
30742: LD_INT 2
30744: EQUAL
30745: IFFALSE 30771
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
30747: LD_EXP 74
30751: PPUSH
30752: LD_STRING D10nB-Vse-4
30754: PPUSH
30755: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
30759: LD_EXP 40
30763: PPUSH
30764: LD_STRING D10nB-JMM-5
30766: PPUSH
30767: CALL_OW 88
// end ; if JMMGirl = 3 then
30771: LD_EXP 7
30775: PUSH
30776: LD_INT 3
30778: EQUAL
30779: IFFALSE 30805
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
30781: LD_EXP 74
30785: PPUSH
30786: LD_STRING D10nB-Vse-5
30788: PPUSH
30789: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
30793: LD_EXP 40
30797: PPUSH
30798: LD_STRING D10nB-JMM-6
30800: PPUSH
30801: CALL_OW 88
// end ; end ; DialogueOff ;
30805: CALL_OW 7
// end ;
30809: END
// every 0 0$1 trigger missionTime >= 55 55$00 and IsOk ( Kovalyuk ) and IsOk ( ru_depot2 ) do var tmp ;
30810: LD_EXP 14
30814: PUSH
30815: LD_INT 115500
30817: GREATEREQUAL
30818: PUSH
30819: LD_EXP 69
30823: PPUSH
30824: CALL_OW 302
30828: AND
30829: PUSH
30830: LD_INT 267
30832: PPUSH
30833: CALL_OW 302
30837: AND
30838: IFFALSE 31214
30840: GO 30842
30842: DISABLE
30843: LD_INT 0
30845: PPUSH
// begin missionStage := 10 ;
30846: LD_ADDR_EXP 15
30850: PUSH
30851: LD_INT 10
30853: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
30854: LD_ADDR_VAR 0 1
30858: PUSH
30859: LD_INT 22
30861: PUSH
30862: LD_INT 1
30864: PUSH
30865: EMPTY
30866: LIST
30867: LIST
30868: PUSH
30869: LD_INT 23
30871: PUSH
30872: LD_INT 1
30874: PUSH
30875: EMPTY
30876: LIST
30877: LIST
30878: PUSH
30879: LD_INT 26
30881: PUSH
30882: LD_INT 1
30884: PUSH
30885: EMPTY
30886: LIST
30887: LIST
30888: PUSH
30889: LD_INT 3
30891: PUSH
30892: LD_INT 25
30894: PUSH
30895: LD_INT 12
30897: PUSH
30898: EMPTY
30899: LIST
30900: LIST
30901: PUSH
30902: EMPTY
30903: LIST
30904: LIST
30905: PUSH
30906: LD_INT 3
30908: PUSH
30909: LD_INT 25
30911: PUSH
30912: LD_INT 16
30914: PUSH
30915: EMPTY
30916: LIST
30917: LIST
30918: PUSH
30919: EMPTY
30920: LIST
30921: LIST
30922: PUSH
30923: EMPTY
30924: LIST
30925: LIST
30926: LIST
30927: LIST
30928: LIST
30929: PPUSH
30930: CALL_OW 69
30934: PUSH
30935: LD_EXP 40
30939: PUSH
30940: LD_EXP 64
30944: PUSH
30945: LD_EXP 42
30949: PUSH
30950: LD_EXP 56
30954: PUSH
30955: LD_EXP 43
30959: PUSH
30960: LD_EXP 44
30964: PUSH
30965: LD_EXP 45
30969: PUSH
30970: LD_EXP 46
30974: PUSH
30975: LD_EXP 47
30979: PUSH
30980: LD_EXP 48
30984: PUSH
30985: LD_EXP 49
30989: PUSH
30990: LD_EXP 50
30994: PUSH
30995: LD_EXP 51
30999: PUSH
31000: LD_EXP 52
31004: PUSH
31005: LD_EXP 53
31009: PUSH
31010: LD_EXP 54
31014: PUSH
31015: EMPTY
31016: LIST
31017: LIST
31018: LIST
31019: LIST
31020: LIST
31021: LIST
31022: LIST
31023: LIST
31024: LIST
31025: LIST
31026: LIST
31027: LIST
31028: LIST
31029: LIST
31030: LIST
31031: LIST
31032: DIFF
31033: ST_TO_ADDR
// if not tmp and Brown then
31034: LD_VAR 0 1
31038: NOT
31039: PUSH
31040: LD_EXP 48
31044: AND
31045: IFFALSE 31060
// tmp := [ Brown ] ;
31047: LD_ADDR_VAR 0 1
31051: PUSH
31052: LD_EXP 48
31056: PUSH
31057: EMPTY
31058: LIST
31059: ST_TO_ADDR
// DialogueOn ;
31060: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
31064: LD_VAR 0 1
31068: PUSH
31069: LD_INT 1
31071: ARRAY
31072: PPUSH
31073: LD_STRING D11-Sol1-1
31075: PPUSH
31076: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
31080: LD_EXP 68
31084: PPUSH
31085: LD_STRING D11-Pla-1
31087: PPUSH
31088: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
31092: LD_EXP 69
31096: PPUSH
31097: LD_STRING D11-Kov-1
31099: PPUSH
31100: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
31104: LD_EXP 68
31108: PPUSH
31109: LD_STRING D11-Pla-2
31111: PPUSH
31112: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
31116: LD_VAR 0 1
31120: PUSH
31121: LD_INT 1
31123: ARRAY
31124: PPUSH
31125: LD_STRING D11-Sol1-2
31127: PPUSH
31128: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
31132: LD_EXP 40
31136: PPUSH
31137: LD_STRING D11-JMM-2
31139: PPUSH
31140: CALL_OW 88
// DialogueOff ;
31144: CALL_OW 7
// allowBehemothConstruct := true ;
31148: LD_ADDR_EXP 25
31152: PUSH
31153: LD_INT 1
31155: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
31156: LD_STRING M4
31158: PPUSH
31159: CALL_OW 337
// BuildBehemoths ;
31163: CALL 8402 0 0
// repeat wait ( 15 15$00 ) ;
31167: LD_INT 31500
31169: PPUSH
31170: CALL_OW 67
// if behemothDestroyedBeforeFinish then
31174: LD_EXP 27
31178: IFFALSE 31182
// break ;
31180: GO 31214
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
31182: LD_INT 267
31184: PPUSH
31185: CALL_OW 274
31189: PPUSH
31190: LD_INT 1
31192: PPUSH
31193: CALL_OW 275
31197: PUSH
31198: LD_INT 1000
31200: GREATEREQUAL
31201: IFFALSE 31207
// BuildBehemoths ;
31203: CALL 8402 0 0
// until not behemothBuilders ;
31207: LD_EXP 77
31211: NOT
31212: IFFALSE 31167
// end ;
31214: PPOPN 1
31216: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
31217: LD_EXP 77
31221: NOT
31222: PUSH
31223: LD_EXP 28
31227: NOT
31228: AND
31229: PUSH
31230: LD_EXP 25
31234: AND
31235: IFFALSE 31255
31237: GO 31239
31239: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
31240: LD_STRING M4a
31242: PPUSH
31243: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
31247: LD_ADDR_EXP 27
31251: PUSH
31252: LD_INT 1
31254: ST_TO_ADDR
// end ;
31255: END
// every 0 0$1 trigger behemothDone do
31256: LD_EXP 28
31260: IFFALSE 31272
31262: GO 31264
31264: DISABLE
// ChangeMissionObjectives ( M4b ) ;
31265: LD_STRING M4b
31267: PPUSH
31268: CALL_OW 337
31272: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
31273: LD_EXP 29
31277: NOT
31278: IFFALSE 31474
31280: GO 31282
31282: DISABLE
31283: LD_INT 0
31285: PPUSH
31286: PPUSH
// begin enable ;
31287: ENABLE
// tmp := GetBehemoths ( 3 ) ;
31288: LD_ADDR_VAR 0 1
31292: PUSH
31293: LD_INT 3
31295: PPUSH
31296: CALL 107422 0 1
31300: ST_TO_ADDR
// if not tmp and not behemothDone then
31301: LD_VAR 0 1
31305: NOT
31306: PUSH
31307: LD_EXP 28
31311: NOT
31312: AND
31313: IFFALSE 31349
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
31315: LD_ADDR_VAR 0 1
31319: PUSH
31320: LD_INT 22
31322: PUSH
31323: LD_INT 3
31325: PUSH
31326: EMPTY
31327: LIST
31328: LIST
31329: PUSH
31330: LD_INT 30
31332: PUSH
31333: LD_INT 37
31335: PUSH
31336: EMPTY
31337: LIST
31338: LIST
31339: PUSH
31340: EMPTY
31341: LIST
31342: LIST
31343: PPUSH
31344: CALL_OW 69
31348: ST_TO_ADDR
// if not tmp then
31349: LD_VAR 0 1
31353: NOT
31354: IFFALSE 31358
// exit ;
31356: GO 31474
// for i in tmp do
31358: LD_ADDR_VAR 0 2
31362: PUSH
31363: LD_VAR 0 1
31367: PUSH
31368: FOR_IN
31369: IFFALSE 31472
// if See ( 1 , i ) then
31371: LD_INT 1
31373: PPUSH
31374: LD_VAR 0 2
31378: PPUSH
31379: CALL_OW 292
31383: IFFALSE 31470
// begin if GetType ( i ) = unit_building then
31385: LD_VAR 0 2
31389: PPUSH
31390: CALL_OW 247
31394: PUSH
31395: LD_INT 3
31397: EQUAL
31398: IFFALSE 31436
// begin disable ;
31400: DISABLE
// CenterNowOnUnits ( i ) ;
31401: LD_VAR 0 2
31405: PPUSH
31406: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
31410: LD_EXP 40
31414: PPUSH
31415: LD_STRING D17a-JMM-1
31417: PPUSH
31418: CALL_OW 88
// seeBehemoth := true ;
31422: LD_ADDR_EXP 29
31426: PUSH
31427: LD_INT 1
31429: ST_TO_ADDR
// exit ;
31430: POP
31431: POP
31432: GO 31474
// end else
31434: GO 31470
// begin disable ;
31436: DISABLE
// CenterNowOnUnits ( i ) ;
31437: LD_VAR 0 2
31441: PPUSH
31442: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
31446: LD_EXP 40
31450: PPUSH
31451: LD_STRING D17b-JMM-1
31453: PPUSH
31454: CALL_OW 88
// seeBehemoth := true ;
31458: LD_ADDR_EXP 29
31462: PUSH
31463: LD_INT 1
31465: ST_TO_ADDR
// exit ;
31466: POP
31467: POP
31468: GO 31474
// end ; end ;
31470: GO 31368
31472: POP
31473: POP
// end ;
31474: PPOPN 2
31476: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
31477: LD_EXP 14
31481: PUSH
31482: LD_INT 123200
31484: GREATEREQUAL
31485: IFFALSE 32685
31487: GO 31489
31489: DISABLE
31490: LD_INT 0
31492: PPUSH
31493: PPUSH
31494: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
31495: LD_INT 2
31497: PPUSH
31498: LD_INT 23
31500: PUSH
31501: LD_INT 3
31503: PUSH
31504: LD_INT 3
31506: PUSH
31507: LD_INT 48
31509: PUSH
31510: EMPTY
31511: LIST
31512: LIST
31513: LIST
31514: LIST
31515: PUSH
31516: EMPTY
31517: LIST
31518: PPUSH
31519: CALL 63244 0 2
// repeat wait ( 0 0$1 ) ;
31523: LD_INT 35
31525: PPUSH
31526: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
31530: LD_INT 22
31532: PUSH
31533: LD_INT 3
31535: PUSH
31536: EMPTY
31537: LIST
31538: LIST
31539: PUSH
31540: LD_INT 34
31542: PUSH
31543: LD_INT 48
31545: PUSH
31546: EMPTY
31547: LIST
31548: LIST
31549: PUSH
31550: EMPTY
31551: LIST
31552: LIST
31553: PPUSH
31554: CALL_OW 69
31558: IFFALSE 31523
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
31560: LD_ADDR_VAR 0 1
31564: PUSH
31565: LD_INT 22
31567: PUSH
31568: LD_INT 3
31570: PUSH
31571: EMPTY
31572: LIST
31573: LIST
31574: PUSH
31575: LD_INT 34
31577: PUSH
31578: LD_INT 48
31580: PUSH
31581: EMPTY
31582: LIST
31583: LIST
31584: PUSH
31585: EMPTY
31586: LIST
31587: LIST
31588: PPUSH
31589: CALL_OW 69
31593: PUSH
31594: LD_INT 1
31596: ARRAY
31597: ST_TO_ADDR
// missionStage := 12 ;
31598: LD_ADDR_EXP 15
31602: PUSH
31603: LD_INT 12
31605: ST_TO_ADDR
// platonovHasBomb := true ;
31606: LD_ADDR_EXP 30
31610: PUSH
31611: LD_INT 1
31613: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
31614: LD_VAR 0 1
31618: PPUSH
31619: LD_INT 181
31621: PPUSH
31622: LD_INT 86
31624: PPUSH
31625: CALL_OW 171
// AddComHold ( bomb ) ;
31629: LD_VAR 0 1
31633: PPUSH
31634: CALL_OW 200
// wait ( 0 0$10 ) ;
31638: LD_INT 350
31640: PPUSH
31641: CALL_OW 67
// DialogueOn ;
31645: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
31649: LD_EXP 68
31653: PPUSH
31654: LD_STRING D15-Pla-1
31656: PPUSH
31657: CALL_OW 94
// dec := Query ( Q15a ) ;
31661: LD_ADDR_VAR 0 2
31665: PUSH
31666: LD_STRING Q15a
31668: PPUSH
31669: CALL_OW 97
31673: ST_TO_ADDR
// if dec = 1 then
31674: LD_VAR 0 2
31678: PUSH
31679: LD_INT 1
31681: EQUAL
31682: IFFALSE 31705
// begin Say ( JMM , D15a-JMM-1 ) ;
31684: LD_EXP 40
31688: PPUSH
31689: LD_STRING D15a-JMM-1
31691: PPUSH
31692: CALL_OW 88
// YouLost ( Surrender ) ;
31696: LD_STRING Surrender
31698: PPUSH
31699: CALL_OW 104
// exit ;
31703: GO 32685
// end ; if dec = 2 then
31705: LD_VAR 0 2
31709: PUSH
31710: LD_INT 2
31712: EQUAL
31713: IFFALSE 31782
// begin Say ( JMM , D15b-JMM-1 ) ;
31715: LD_EXP 40
31719: PPUSH
31720: LD_STRING D15b-JMM-1
31722: PPUSH
31723: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
31727: LD_EXP 68
31731: PPUSH
31732: LD_STRING D15b-Pla-1
31734: PPUSH
31735: CALL_OW 94
// DialogueOff ;
31739: CALL_OW 7
// wait ( 3 3$00 ) ;
31743: LD_INT 6300
31745: PPUSH
31746: CALL_OW 67
// DialogueOn ;
31750: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
31754: LD_EXP 40
31758: PPUSH
31759: LD_STRING D15d-JMM-1a
31761: PPUSH
31762: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
31766: LD_EXP 68
31770: PPUSH
31771: LD_STRING D15d-Pla-1
31773: PPUSH
31774: CALL_OW 94
// DialogueOff ;
31778: CALL_OW 7
// end ; if dec = 3 then
31782: LD_VAR 0 2
31786: PUSH
31787: LD_INT 3
31789: EQUAL
31790: IFFALSE 31844
// begin Say ( JMM , D15c-JMM-1 ) ;
31792: LD_EXP 40
31796: PPUSH
31797: LD_STRING D15c-JMM-1
31799: PPUSH
31800: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
31804: LD_EXP 68
31808: PPUSH
31809: LD_STRING D15c-Pla-1
31811: PPUSH
31812: CALL_OW 94
// DialogueOff ;
31816: CALL_OW 7
// wait ( 0 0$15 ) ;
31820: LD_INT 525
31822: PPUSH
31823: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
31827: LD_VAR 0 1
31831: PPUSH
31832: LD_INT 60
31834: PPUSH
31835: LD_INT 95
31837: PPUSH
31838: CALL_OW 116
// exit ;
31842: GO 32685
// end ; if dec = 4 then
31844: LD_VAR 0 2
31848: PUSH
31849: LD_INT 4
31851: EQUAL
31852: IFFALSE 31882
// begin Say ( JMM , D15d-JMM-1 ) ;
31854: LD_EXP 40
31858: PPUSH
31859: LD_STRING D15d-JMM-1
31861: PPUSH
31862: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
31866: LD_EXP 68
31870: PPUSH
31871: LD_STRING D15d-Pla-1
31873: PPUSH
31874: CALL_OW 94
// DialogueOff ;
31878: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
31882: LD_EXP 66
31886: PPUSH
31887: CALL_OW 302
31891: PUSH
31892: LD_EXP 66
31896: PPUSH
31897: CALL_OW 255
31901: PUSH
31902: LD_INT 1
31904: EQUAL
31905: AND
31906: PUSH
31907: LD_INT 22
31909: PUSH
31910: LD_INT 1
31912: PUSH
31913: EMPTY
31914: LIST
31915: LIST
31916: PUSH
31917: LD_INT 34
31919: PUSH
31920: LD_INT 8
31922: PUSH
31923: EMPTY
31924: LIST
31925: LIST
31926: PUSH
31927: EMPTY
31928: LIST
31929: LIST
31930: PPUSH
31931: CALL_OW 69
31935: NOT
31936: AND
31937: IFFALSE 32586
// begin SetSide ( Friend , 8 ) ;
31939: LD_EXP 66
31943: PPUSH
31944: LD_INT 8
31946: PPUSH
31947: CALL_OW 235
// if IsInUnit ( Friend ) then
31951: LD_EXP 66
31955: PPUSH
31956: CALL_OW 310
31960: IFFALSE 31971
// ComExitBuilding ( Friend ) ;
31962: LD_EXP 66
31966: PPUSH
31967: CALL_OW 122
// if IsDriver ( Friend ) then
31971: LD_EXP 66
31975: PPUSH
31976: CALL 104965 0 1
31980: IFFALSE 31991
// ComExitVehicle ( Friend ) ;
31982: LD_EXP 66
31986: PPUSH
31987: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
31991: LD_EXP 66
31995: PPUSH
31996: LD_INT 9
31998: PPUSH
31999: LD_INT 2
32001: PPUSH
32002: CALL_OW 171
// wait ( 0 0$05 ) ;
32006: LD_INT 175
32008: PPUSH
32009: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
32013: LD_EXP 66
32017: PPUSH
32018: CALL_OW 87
// DialogueOn ;
32022: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
32026: LD_EXP 40
32030: PPUSH
32031: LD_STRING D16-JMM-1
32033: PPUSH
32034: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
32038: LD_EXP 66
32042: PPUSH
32043: LD_STRING D16-Friend-1
32045: PPUSH
32046: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
32050: LD_EXP 40
32054: PPUSH
32055: LD_STRING D16-JMM-2
32057: PPUSH
32058: CALL_OW 88
// DialogueOff ;
32062: CALL_OW 7
// SetSide ( Friend , 1 ) ;
32066: LD_EXP 66
32070: PPUSH
32071: LD_INT 1
32073: PPUSH
32074: CALL_OW 235
// ComHold ( Friend ) ;
32078: LD_EXP 66
32082: PPUSH
32083: CALL_OW 140
// wait ( 0 0$20 ) ;
32087: LD_INT 700
32089: PPUSH
32090: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
32094: LD_EXP 66
32098: PPUSH
32099: LD_INT 9
32101: PPUSH
32102: LD_INT 2
32104: PPUSH
32105: CALL_OW 297
32109: PUSH
32110: LD_INT 30
32112: LESS
32113: IFFALSE 32182
// begin SetSide ( Friend , 8 ) ;
32115: LD_EXP 66
32119: PPUSH
32120: LD_INT 8
32122: PPUSH
32123: CALL_OW 235
// if IsInUnit ( Friend ) then
32127: LD_EXP 66
32131: PPUSH
32132: CALL_OW 310
32136: IFFALSE 32147
// ComExitBuilding ( Friend ) ;
32138: LD_EXP 66
32142: PPUSH
32143: CALL_OW 122
// if IsDriver ( Friend ) then
32147: LD_EXP 66
32151: PPUSH
32152: CALL 104965 0 1
32156: IFFALSE 32167
// ComExitVehicle ( Friend ) ;
32158: LD_EXP 66
32162: PPUSH
32163: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
32167: LD_EXP 66
32171: PPUSH
32172: LD_INT 9
32174: PPUSH
32175: LD_INT 2
32177: PPUSH
32178: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
32182: LD_INT 1050
32184: PPUSH
32185: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32189: LD_INT 22
32191: PUSH
32192: LD_INT 1
32194: PUSH
32195: EMPTY
32196: LIST
32197: LIST
32198: PUSH
32199: LD_INT 34
32201: PUSH
32202: LD_INT 8
32204: PUSH
32205: EMPTY
32206: LIST
32207: LIST
32208: PUSH
32209: EMPTY
32210: LIST
32211: LIST
32212: PPUSH
32213: CALL_OW 69
32217: NOT
32218: IFFALSE 32564
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
32220: LD_ADDR_VAR 0 3
32224: PUSH
32225: LD_INT 22
32227: PUSH
32228: LD_INT 1
32230: PUSH
32231: EMPTY
32232: LIST
32233: LIST
32234: PUSH
32235: LD_INT 26
32237: PUSH
32238: LD_INT 1
32240: PUSH
32241: EMPTY
32242: LIST
32243: LIST
32244: PUSH
32245: LD_INT 3
32247: PUSH
32248: LD_INT 25
32250: PUSH
32251: LD_INT 12
32253: PUSH
32254: EMPTY
32255: LIST
32256: LIST
32257: PUSH
32258: LD_INT 25
32260: PUSH
32261: LD_INT 16
32263: PUSH
32264: EMPTY
32265: LIST
32266: LIST
32267: PUSH
32268: EMPTY
32269: LIST
32270: LIST
32271: LIST
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: LIST
32277: PPUSH
32278: CALL_OW 69
32282: PUSH
32283: LD_EXP 40
32287: PUSH
32288: LD_EXP 42
32292: PUSH
32293: LD_EXP 56
32297: PUSH
32298: LD_EXP 43
32302: PUSH
32303: LD_EXP 44
32307: PUSH
32308: LD_EXP 45
32312: PUSH
32313: LD_EXP 46
32317: PUSH
32318: LD_EXP 47
32322: PUSH
32323: LD_EXP 48
32327: PUSH
32328: LD_EXP 49
32332: PUSH
32333: LD_EXP 50
32337: PUSH
32338: LD_EXP 51
32342: PUSH
32343: LD_EXP 52
32347: PUSH
32348: LD_EXP 53
32352: PUSH
32353: LD_EXP 54
32357: PUSH
32358: EMPTY
32359: LIST
32360: LIST
32361: LIST
32362: LIST
32363: LIST
32364: LIST
32365: LIST
32366: LIST
32367: LIST
32368: LIST
32369: LIST
32370: LIST
32371: LIST
32372: LIST
32373: LIST
32374: DIFF
32375: ST_TO_ADDR
// DialogueOn ;
32376: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
32380: LD_EXP 68
32384: PPUSH
32385: LD_STRING D16a-Pla-1
32387: PPUSH
32388: CALL_OW 94
// if Stevens then
32392: LD_EXP 42
32396: IFFALSE 32412
// Say ( Stevens , D16a-Huck-1 ) else
32398: LD_EXP 42
32402: PPUSH
32403: LD_STRING D16a-Huck-1
32405: PPUSH
32406: CALL_OW 88
32410: GO 32454
// if Baker then
32412: LD_EXP 56
32416: IFFALSE 32432
// Say ( Baker , D16a-Huck-1 ) else
32418: LD_EXP 56
32422: PPUSH
32423: LD_STRING D16a-Huck-1
32425: PPUSH
32426: CALL_OW 88
32430: GO 32454
// if tmp then
32432: LD_VAR 0 3
32436: IFFALSE 32454
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
32438: LD_VAR 0 3
32442: PUSH
32443: LD_INT 1
32445: ARRAY
32446: PPUSH
32447: LD_STRING D16a-Sol1-1
32449: PPUSH
32450: CALL_OW 88
// if GetSide ( Friend ) = 8 then
32454: LD_EXP 66
32458: PPUSH
32459: CALL_OW 255
32463: PUSH
32464: LD_INT 8
32466: EQUAL
32467: IFFALSE 32483
// Say ( JMM , D16a-JMM-1 ) else
32469: LD_EXP 40
32473: PPUSH
32474: LD_STRING D16a-JMM-1
32476: PPUSH
32477: CALL_OW 88
32481: GO 32543
// begin Say ( JMM , D16a-JMM-1a ) ;
32483: LD_EXP 40
32487: PPUSH
32488: LD_STRING D16a-JMM-1a
32490: PPUSH
32491: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
32495: LD_EXP 66
32499: PPUSH
32500: LD_STRING D16a-Friend-1
32502: PPUSH
32503: CALL_OW 88
// ComExitBuilding ( Friend ) ;
32507: LD_EXP 66
32511: PPUSH
32512: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
32516: LD_EXP 66
32520: PPUSH
32521: LD_INT 191
32523: PPUSH
32524: LD_INT 103
32526: PPUSH
32527: CALL_OW 171
// SetSide ( Friend , 3 ) ;
32531: LD_EXP 66
32535: PPUSH
32536: LD_INT 3
32538: PPUSH
32539: CALL_OW 235
// end ; DialogueOff ;
32543: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
32547: LD_VAR 0 1
32551: PPUSH
32552: LD_INT 60
32554: PPUSH
32555: LD_INT 95
32557: PPUSH
32558: CALL_OW 116
// end else
32562: GO 32584
// begin DialogueOn ;
32564: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
32568: LD_EXP 68
32572: PPUSH
32573: LD_STRING D16c-Pla-1
32575: PPUSH
32576: CALL_OW 94
// DialogueOff ;
32580: CALL_OW 7
// end ; end else
32584: GO 32685
// begin wait ( 3 3$00 ) ;
32586: LD_INT 6300
32588: PPUSH
32589: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32593: LD_INT 22
32595: PUSH
32596: LD_INT 1
32598: PUSH
32599: EMPTY
32600: LIST
32601: LIST
32602: PUSH
32603: LD_INT 34
32605: PUSH
32606: LD_INT 8
32608: PUSH
32609: EMPTY
32610: LIST
32611: LIST
32612: PUSH
32613: EMPTY
32614: LIST
32615: LIST
32616: PPUSH
32617: CALL_OW 69
32621: NOT
32622: IFFALSE 32665
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
32624: LD_EXP 68
32628: PPUSH
32629: LD_STRING D16b-Pla-1
32631: PPUSH
32632: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
32636: LD_EXP 40
32640: PPUSH
32641: LD_STRING D16b-JMM-1
32643: PPUSH
32644: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
32648: LD_VAR 0 1
32652: PPUSH
32653: LD_INT 60
32655: PPUSH
32656: LD_INT 95
32658: PPUSH
32659: CALL_OW 116
// end else
32663: GO 32685
// begin DialogueOn ;
32665: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
32669: LD_EXP 68
32673: PPUSH
32674: LD_STRING D16c-Pla-1
32676: PPUSH
32677: CALL_OW 94
// DialogueOff ;
32681: CALL_OW 7
// end ; end ; end ;
32685: PPOPN 3
32687: END
// every 0 0$10 trigger ( GetTech ( tech_SibFiss , 1 ) = state_researched or missionTime >= 60 60$00 ) and not allianceDestroyed and IsOk ( Roth ) do var dec ;
32688: LD_INT 25
32690: PPUSH
32691: LD_INT 1
32693: PPUSH
32694: CALL_OW 321
32698: PUSH
32699: LD_INT 2
32701: EQUAL
32702: PUSH
32703: LD_EXP 14
32707: PUSH
32708: LD_INT 126000
32710: GREATEREQUAL
32711: OR
32712: PUSH
32713: LD_EXP 23
32717: NOT
32718: AND
32719: PUSH
32720: LD_EXP 79
32724: PPUSH
32725: CALL_OW 302
32729: AND
32730: IFFALSE 33088
32732: GO 32734
32734: DISABLE
32735: LD_INT 0
32737: PPUSH
// begin missionStage := 11 ;
32738: LD_ADDR_EXP 15
32742: PUSH
32743: LD_INT 11
32745: ST_TO_ADDR
// DialogueOn ;
32746: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
32750: LD_EXP 79
32754: PPUSH
32755: LD_STRING D9-Roth-1
32757: PPUSH
32758: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
32762: LD_EXP 40
32766: PPUSH
32767: LD_STRING D9-JMM-1
32769: PPUSH
32770: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
32774: LD_EXP 79
32778: PPUSH
32779: LD_STRING D9-Roth-2
32781: PPUSH
32782: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
32786: LD_EXP 79
32790: PPUSH
32791: LD_STRING D9-Roth-2a
32793: PPUSH
32794: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
32798: LD_EXP 68
32802: PPUSH
32803: LD_STRING D9-Pla-2
32805: PPUSH
32806: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
32810: LD_EXP 79
32814: PPUSH
32815: LD_STRING D9-Roth-3
32817: PPUSH
32818: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
32822: LD_EXP 68
32826: PPUSH
32827: LD_STRING D9-Pla-3
32829: PPUSH
32830: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
32834: LD_EXP 79
32838: PPUSH
32839: LD_STRING D9-Roth-4
32841: PPUSH
32842: CALL_OW 94
// dec := Query ( Q9 ) ;
32846: LD_ADDR_VAR 0 1
32850: PUSH
32851: LD_STRING Q9
32853: PPUSH
32854: CALL_OW 97
32858: ST_TO_ADDR
// if dec = 1 then
32859: LD_VAR 0 1
32863: PUSH
32864: LD_INT 1
32866: EQUAL
32867: IFFALSE 32881
// SayRadio ( Roth , D9a-Roth-1 ) ;
32869: LD_EXP 79
32873: PPUSH
32874: LD_STRING D9a-Roth-1
32876: PPUSH
32877: CALL_OW 94
// if dec = 2 then
32881: LD_VAR 0 1
32885: PUSH
32886: LD_INT 2
32888: EQUAL
32889: IFFALSE 32915
// begin Say ( JMM , D9b-JMM-1 ) ;
32891: LD_EXP 40
32895: PPUSH
32896: LD_STRING D9b-JMM-1
32898: PPUSH
32899: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
32903: LD_EXP 79
32907: PPUSH
32908: LD_STRING D9b-Roth-1
32910: PPUSH
32911: CALL_OW 94
// end ; if dec = 3 then
32915: LD_VAR 0 1
32919: PUSH
32920: LD_INT 3
32922: EQUAL
32923: IFFALSE 32985
// begin Say ( JMM , D9c-JMM-1 ) ;
32925: LD_EXP 40
32929: PPUSH
32930: LD_STRING D9c-JMM-1
32932: PPUSH
32933: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
32937: LD_EXP 79
32941: PPUSH
32942: LD_STRING D9c-Roth-1
32944: PPUSH
32945: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
32949: LD_EXP 40
32953: PPUSH
32954: LD_STRING D9c-JMM-2
32956: PPUSH
32957: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
32961: LD_EXP 79
32965: PPUSH
32966: LD_STRING D9c-Roth-2
32968: PPUSH
32969: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
32973: LD_EXP 40
32977: PPUSH
32978: LD_STRING D9c-JMM-3
32980: PPUSH
32981: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
32985: LD_EXP 79
32989: PPUSH
32990: LD_STRING D9c-Roth-3
32992: PPUSH
32993: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
32997: LD_EXP 79
33001: PPUSH
33002: LD_STRING D9cont-Roth-1
33004: PPUSH
33005: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
33009: LD_EXP 40
33013: PPUSH
33014: LD_STRING D9cont-JMM-1
33016: PPUSH
33017: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
33021: LD_EXP 79
33025: PPUSH
33026: LD_STRING D9cont-Roth-2
33028: PPUSH
33029: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
33033: LD_EXP 40
33037: PPUSH
33038: LD_STRING D9cont-JMM-2
33040: PPUSH
33041: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
33045: LD_EXP 79
33049: PPUSH
33050: LD_STRING D9cont-Roth-3
33052: PPUSH
33053: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
33057: LD_EXP 40
33061: PPUSH
33062: LD_STRING D9cont-JMM-3
33064: PPUSH
33065: CALL_OW 88
// DialogueOff ;
33069: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
33073: LD_STRING M3
33075: PPUSH
33076: CALL_OW 337
// allianceActive := true ;
33080: LD_ADDR_EXP 31
33084: PUSH
33085: LD_INT 1
33087: ST_TO_ADDR
// end ;
33088: PPOPN 1
33090: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
33091: LD_INT 1
33093: PPUSH
33094: LD_INT 126
33096: PPUSH
33097: CALL_OW 292
33101: PUSH
33102: LD_EXP 68
33106: PPUSH
33107: CALL_OW 310
33111: AND
33112: IFFALSE 33265
33114: GO 33116
33116: DISABLE
33117: LD_INT 0
33119: PPUSH
// begin ComExitBuilding ( Platonov ) ;
33120: LD_EXP 68
33124: PPUSH
33125: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
33129: LD_ADDR_VAR 0 1
33133: PUSH
33134: LD_INT 4
33136: PPUSH
33137: LD_INT 22
33139: PUSH
33140: LD_INT 1
33142: PUSH
33143: EMPTY
33144: LIST
33145: LIST
33146: PPUSH
33147: CALL_OW 70
33151: PPUSH
33152: LD_EXP 68
33156: PPUSH
33157: CALL_OW 74
33161: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
33162: LD_EXP 68
33166: PPUSH
33167: LD_VAR 0 1
33171: PUSH
33172: LD_INT 1
33174: ARRAY
33175: PPUSH
33176: CALL_OW 175
// SayRadio ( Platonov , D18-Pla-1 ) ;
33180: LD_EXP 68
33184: PPUSH
33185: LD_STRING D18-Pla-1
33187: PPUSH
33188: CALL_OW 94
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
33192: LD_INT 22
33194: PUSH
33195: LD_INT 3
33197: PUSH
33198: EMPTY
33199: LIST
33200: LIST
33201: PUSH
33202: LD_INT 34
33204: PUSH
33205: LD_INT 48
33207: PUSH
33208: EMPTY
33209: LIST
33210: LIST
33211: PUSH
33212: EMPTY
33213: LIST
33214: LIST
33215: PPUSH
33216: CALL_OW 69
33220: IFFALSE 33265
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 111 , 97 ) ;
33222: LD_INT 22
33224: PUSH
33225: LD_INT 3
33227: PUSH
33228: EMPTY
33229: LIST
33230: LIST
33231: PUSH
33232: LD_INT 34
33234: PUSH
33235: LD_INT 48
33237: PUSH
33238: EMPTY
33239: LIST
33240: LIST
33241: PUSH
33242: EMPTY
33243: LIST
33244: LIST
33245: PPUSH
33246: CALL_OW 69
33250: PUSH
33251: LD_INT 1
33253: ARRAY
33254: PPUSH
33255: LD_INT 111
33257: PPUSH
33258: LD_INT 97
33260: PPUSH
33261: CALL_OW 116
// end ;
33265: PPOPN 1
33267: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
33268: LD_EXP 68
33272: PPUSH
33273: CALL_OW 301
33277: PUSH
33278: LD_EXP 71
33282: PPUSH
33283: CALL_OW 301
33287: AND
33288: PUSH
33289: LD_INT 22
33291: PUSH
33292: LD_INT 3
33294: PUSH
33295: EMPTY
33296: LIST
33297: LIST
33298: PUSH
33299: LD_INT 21
33301: PUSH
33302: LD_INT 1
33304: PUSH
33305: EMPTY
33306: LIST
33307: LIST
33308: PUSH
33309: LD_INT 50
33311: PUSH
33312: EMPTY
33313: LIST
33314: PUSH
33315: EMPTY
33316: LIST
33317: LIST
33318: LIST
33319: PPUSH
33320: CALL_OW 69
33324: PUSH
33325: LD_INT 7
33327: PUSH
33328: LD_INT 8
33330: PUSH
33331: LD_INT 9
33333: PUSH
33334: LD_INT 10
33336: PUSH
33337: EMPTY
33338: LIST
33339: LIST
33340: LIST
33341: LIST
33342: PUSH
33343: LD_OWVAR 67
33347: ARRAY
33348: LESS
33349: AND
33350: IFFALSE 34149
33352: GO 33354
33354: DISABLE
33355: LD_INT 0
33357: PPUSH
33358: PPUSH
33359: PPUSH
33360: PPUSH
// begin MC_Kill ( 2 ) ;
33361: LD_INT 2
33363: PPUSH
33364: CALL 39219 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
33368: LD_INT 1
33370: PPUSH
33371: LD_INT 3
33373: PPUSH
33374: LD_INT 1
33376: PPUSH
33377: LD_INT 1
33379: PPUSH
33380: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
33384: LD_ADDR_VAR 0 2
33388: PUSH
33389: LD_INT 22
33391: PUSH
33392: LD_INT 3
33394: PUSH
33395: EMPTY
33396: LIST
33397: LIST
33398: PUSH
33399: LD_INT 21
33401: PUSH
33402: LD_INT 1
33404: PUSH
33405: EMPTY
33406: LIST
33407: LIST
33408: PUSH
33409: LD_INT 50
33411: PUSH
33412: EMPTY
33413: LIST
33414: PUSH
33415: LD_INT 26
33417: PUSH
33418: LD_INT 1
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: EMPTY
33426: LIST
33427: LIST
33428: LIST
33429: LIST
33430: PPUSH
33431: CALL_OW 69
33435: ST_TO_ADDR
// if not tmp then
33436: LD_VAR 0 2
33440: NOT
33441: IFFALSE 33497
// begin uc_side = 3 ;
33443: LD_ADDR_OWVAR 20
33447: PUSH
33448: LD_INT 3
33450: ST_TO_ADDR
// uc_nation = 3 ;
33451: LD_ADDR_OWVAR 21
33455: PUSH
33456: LD_INT 3
33458: ST_TO_ADDR
// hc_name =  ;
33459: LD_ADDR_OWVAR 26
33463: PUSH
33464: LD_STRING 
33466: ST_TO_ADDR
// hc_gallery =  ;
33467: LD_ADDR_OWVAR 33
33471: PUSH
33472: LD_STRING 
33474: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
33475: LD_INT 1
33477: PPUSH
33478: LD_INT 10
33480: PPUSH
33481: CALL_OW 381
// tmp = CreateHuman ;
33485: LD_ADDR_VAR 0 2
33489: PUSH
33490: CALL_OW 44
33494: ST_TO_ADDR
// end else
33495: GO 33511
// tmp := tmp [ 1 ] ;
33497: LD_ADDR_VAR 0 2
33501: PUSH
33502: LD_VAR 0 2
33506: PUSH
33507: LD_INT 1
33509: ARRAY
33510: ST_TO_ADDR
// DialogueOn ;
33511: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
33515: LD_VAR 0 2
33519: PPUSH
33520: LD_STRING DSurrenderRussians-RSol1-1a
33522: PPUSH
33523: CALL_OW 94
// DialogueOff ;
33527: CALL_OW 7
// russianDestroyed := true ;
33531: LD_ADDR_EXP 21
33535: PUSH
33536: LD_INT 1
33538: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
33539: LD_ADDR_VAR 0 1
33543: PUSH
33544: LD_INT 22
33546: PUSH
33547: LD_INT 6
33549: PUSH
33550: EMPTY
33551: LIST
33552: LIST
33553: PPUSH
33554: CALL_OW 69
33558: PUSH
33559: FOR_IN
33560: IFFALSE 33573
// KillUnit ( i ) ;
33562: LD_VAR 0 1
33566: PPUSH
33567: CALL_OW 66
33571: GO 33559
33573: POP
33574: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
33575: LD_INT 22
33577: PUSH
33578: LD_INT 3
33580: PUSH
33581: EMPTY
33582: LIST
33583: LIST
33584: PUSH
33585: LD_INT 21
33587: PUSH
33588: LD_INT 1
33590: PUSH
33591: EMPTY
33592: LIST
33593: LIST
33594: PUSH
33595: EMPTY
33596: LIST
33597: LIST
33598: PPUSH
33599: CALL_OW 69
33603: PPUSH
33604: CALL_OW 122
// wait ( 0 0$1 ) ;
33608: LD_INT 35
33610: PPUSH
33611: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
33615: LD_INT 22
33617: PUSH
33618: LD_INT 3
33620: PUSH
33621: EMPTY
33622: LIST
33623: LIST
33624: PUSH
33625: LD_INT 21
33627: PUSH
33628: LD_INT 1
33630: PUSH
33631: EMPTY
33632: LIST
33633: LIST
33634: PUSH
33635: EMPTY
33636: LIST
33637: LIST
33638: PPUSH
33639: CALL_OW 69
33643: PPUSH
33644: LD_INT 25
33646: PPUSH
33647: CALL_OW 173
// wait ( 0 0$35 ) ;
33651: LD_INT 1225
33653: PPUSH
33654: CALL_OW 67
// PrepareOmarInvasion ;
33658: CALL 16375 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
33662: LD_ADDR_VAR 0 2
33666: PUSH
33667: LD_EXP 97
33671: PPUSH
33672: CALL_OW 250
33676: PUSH
33677: LD_EXP 97
33681: PPUSH
33682: CALL_OW 251
33686: PUSH
33687: EMPTY
33688: LIST
33689: LIST
33690: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
33691: LD_VAR 0 2
33695: PUSH
33696: LD_INT 1
33698: ARRAY
33699: PPUSH
33700: LD_VAR 0 2
33704: PUSH
33705: LD_INT 2
33707: ARRAY
33708: PPUSH
33709: LD_INT 1
33711: PPUSH
33712: LD_INT 8
33714: NEG
33715: PPUSH
33716: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
33720: LD_EXP 97
33724: PPUSH
33725: CALL_OW 87
// DialogueOn ;
33729: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
33733: LD_EXP 40
33737: PPUSH
33738: LD_STRING D19-JMM-1
33740: PPUSH
33741: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Kurt , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
33745: LD_ADDR_VAR 0 3
33749: PUSH
33750: LD_INT 22
33752: PUSH
33753: LD_INT 1
33755: PUSH
33756: EMPTY
33757: LIST
33758: LIST
33759: PUSH
33760: LD_INT 26
33762: PUSH
33763: LD_INT 1
33765: PUSH
33766: EMPTY
33767: LIST
33768: LIST
33769: PUSH
33770: LD_INT 2
33772: PUSH
33773: LD_INT 25
33775: PUSH
33776: LD_INT 1
33778: PUSH
33779: EMPTY
33780: LIST
33781: LIST
33782: PUSH
33783: LD_INT 25
33785: PUSH
33786: LD_INT 2
33788: PUSH
33789: EMPTY
33790: LIST
33791: LIST
33792: PUSH
33793: LD_INT 25
33795: PUSH
33796: LD_INT 3
33798: PUSH
33799: EMPTY
33800: LIST
33801: LIST
33802: PUSH
33803: LD_INT 25
33805: PUSH
33806: LD_INT 4
33808: PUSH
33809: EMPTY
33810: LIST
33811: LIST
33812: PUSH
33813: LD_INT 25
33815: PUSH
33816: LD_INT 5
33818: PUSH
33819: EMPTY
33820: LIST
33821: LIST
33822: PUSH
33823: LD_INT 25
33825: PUSH
33826: LD_INT 8
33828: PUSH
33829: EMPTY
33830: LIST
33831: LIST
33832: PUSH
33833: EMPTY
33834: LIST
33835: LIST
33836: LIST
33837: LIST
33838: LIST
33839: LIST
33840: LIST
33841: PUSH
33842: EMPTY
33843: LIST
33844: LIST
33845: LIST
33846: PPUSH
33847: CALL_OW 69
33851: PUSH
33852: LD_EXP 40
33856: PUSH
33857: LD_EXP 41
33861: PUSH
33862: LD_EXP 64
33866: PUSH
33867: LD_EXP 42
33871: PUSH
33872: LD_EXP 43
33876: PUSH
33877: LD_EXP 44
33881: PUSH
33882: LD_EXP 45
33886: PUSH
33887: LD_EXP 46
33891: PUSH
33892: LD_EXP 47
33896: PUSH
33897: LD_EXP 48
33901: PUSH
33902: LD_EXP 49
33906: PUSH
33907: LD_EXP 50
33911: PUSH
33912: LD_EXP 51
33916: PUSH
33917: LD_EXP 52
33921: PUSH
33922: LD_EXP 53
33926: PUSH
33927: LD_EXP 54
33931: PUSH
33932: LD_EXP 55
33936: PUSH
33937: LD_EXP 56
33941: PUSH
33942: EMPTY
33943: LIST
33944: LIST
33945: LIST
33946: LIST
33947: LIST
33948: LIST
33949: LIST
33950: LIST
33951: LIST
33952: LIST
33953: LIST
33954: LIST
33955: LIST
33956: LIST
33957: LIST
33958: LIST
33959: LIST
33960: LIST
33961: DIFF
33962: ST_TO_ADDR
// if tmp2 then
33963: LD_VAR 0 3
33967: IFFALSE 33985
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
33969: LD_VAR 0 3
33973: PUSH
33974: LD_INT 1
33976: ARRAY
33977: PPUSH
33978: LD_STRING D19-Sol1-1
33980: PPUSH
33981: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
33985: LD_EXP 40
33989: PPUSH
33990: LD_STRING D19-JMM-2
33992: PPUSH
33993: CALL_OW 88
// DialogueOff ;
33997: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
34001: LD_VAR 0 2
34005: PUSH
34006: LD_INT 1
34008: ARRAY
34009: PPUSH
34010: LD_VAR 0 2
34014: PUSH
34015: LD_INT 2
34017: ARRAY
34018: PPUSH
34019: LD_INT 1
34021: PPUSH
34022: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
34026: LD_STRING M5
34028: PPUSH
34029: CALL_OW 337
// omarOnMotherLode := false ;
34033: LD_ADDR_VAR 0 4
34037: PUSH
34038: LD_INT 0
34040: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
34041: LD_INT 35
34043: PPUSH
34044: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
34048: LD_EXP 97
34052: PPUSH
34053: LD_INT 215
34055: PPUSH
34056: LD_INT 100
34058: PPUSH
34059: CALL_OW 297
34063: PUSH
34064: LD_INT 10
34066: LESS
34067: PUSH
34068: LD_VAR 0 4
34072: NOT
34073: AND
34074: IFFALSE 34108
// begin omarOnMotherLode := true ;
34076: LD_ADDR_VAR 0 4
34080: PUSH
34081: LD_INT 1
34083: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
34084: LD_EXP 40
34088: PPUSH
34089: LD_STRING D19b-JMM-1
34091: PPUSH
34092: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
34096: LD_EXP 97
34100: PPUSH
34101: LD_STRING DOmarContam-Omar-1
34103: PPUSH
34104: CALL_OW 88
// end ; until IsDead ( Omar ) ;
34108: LD_EXP 97
34112: PPUSH
34113: CALL_OW 301
34117: IFFALSE 34041
// Say ( JMM , D19a-JMM-1 ) ;
34119: LD_EXP 40
34123: PPUSH
34124: LD_STRING D19a-JMM-1
34126: PPUSH
34127: CALL_OW 88
// if Heike then
34131: LD_EXP 98
34135: IFFALSE 34149
// Say ( Heike , D19a-Hke-1 ) ;
34137: LD_EXP 98
34141: PPUSH
34142: LD_STRING D19a-Hke-1
34144: PPUSH
34145: CALL_OW 88
// end ;
34149: PPOPN 4
34151: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
34152: LD_INT 22
34154: PUSH
34155: LD_INT 3
34157: PUSH
34158: EMPTY
34159: LIST
34160: LIST
34161: PUSH
34162: LD_INT 21
34164: PUSH
34165: LD_INT 1
34167: PUSH
34168: EMPTY
34169: LIST
34170: LIST
34171: PUSH
34172: EMPTY
34173: LIST
34174: LIST
34175: PPUSH
34176: CALL_OW 69
34180: PUSH
34181: LD_EXP 21
34185: AND
34186: IFFALSE 34254
34188: GO 34190
34190: DISABLE
34191: LD_INT 0
34193: PPUSH
34194: PPUSH
// begin enable ;
34195: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
34196: LD_ADDR_VAR 0 2
34200: PUSH
34201: LD_INT 25
34203: PPUSH
34204: LD_INT 22
34206: PUSH
34207: LD_INT 3
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PPUSH
34214: CALL_OW 70
34218: ST_TO_ADDR
// if not tmp then
34219: LD_VAR 0 2
34223: NOT
34224: IFFALSE 34228
// exit ;
34226: GO 34254
// for i in tmp do
34228: LD_ADDR_VAR 0 1
34232: PUSH
34233: LD_VAR 0 2
34237: PUSH
34238: FOR_IN
34239: IFFALSE 34252
// RemoveUnit ( i ) ;
34241: LD_VAR 0 1
34245: PPUSH
34246: CALL_OW 64
34250: GO 34238
34252: POP
34253: POP
// end ;
34254: PPOPN 2
34256: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
34257: LD_INT 22
34259: PUSH
34260: LD_INT 7
34262: PUSH
34263: EMPTY
34264: LIST
34265: LIST
34266: PUSH
34267: LD_INT 21
34269: PUSH
34270: LD_INT 1
34272: PUSH
34273: EMPTY
34274: LIST
34275: LIST
34276: PUSH
34277: EMPTY
34278: LIST
34279: LIST
34280: PPUSH
34281: CALL_OW 69
34285: PUSH
34286: LD_INT 6
34288: LESS
34289: IFFALSE 34757
34291: GO 34293
34293: DISABLE
34294: LD_INT 0
34296: PPUSH
34297: PPUSH
// begin MC_Kill ( 1 ) ;
34298: LD_INT 1
34300: PPUSH
34301: CALL 39219 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
34305: LD_INT 7
34307: PPUSH
34308: LD_INT 1
34310: PPUSH
34311: LD_INT 1
34313: PPUSH
34314: LD_INT 1
34316: PPUSH
34317: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
34321: LD_ADDR_VAR 0 1
34325: PUSH
34326: LD_INT 22
34328: PUSH
34329: LD_INT 7
34331: PUSH
34332: EMPTY
34333: LIST
34334: LIST
34335: PUSH
34336: LD_INT 26
34338: PUSH
34339: LD_INT 1
34341: PUSH
34342: EMPTY
34343: LIST
34344: LIST
34345: PUSH
34346: EMPTY
34347: LIST
34348: LIST
34349: PPUSH
34350: CALL_OW 69
34354: PUSH
34355: LD_EXP 79
34359: DIFF
34360: ST_TO_ADDR
// if tmp then
34361: LD_VAR 0 1
34365: IFFALSE 34383
// tmp := tmp [ 1 ] else
34367: LD_ADDR_VAR 0 1
34371: PUSH
34372: LD_VAR 0 1
34376: PUSH
34377: LD_INT 1
34379: ARRAY
34380: ST_TO_ADDR
34381: GO 34419
// begin uc_side := 7 ;
34383: LD_ADDR_OWVAR 20
34387: PUSH
34388: LD_INT 7
34390: ST_TO_ADDR
// uc_nation := 1 ;
34391: LD_ADDR_OWVAR 21
34395: PUSH
34396: LD_INT 1
34398: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
34399: LD_INT 1
34401: PPUSH
34402: LD_INT 8
34404: PPUSH
34405: CALL_OW 384
// tmp := CreateHuman ;
34409: LD_ADDR_VAR 0 1
34413: PUSH
34414: CALL_OW 44
34418: ST_TO_ADDR
// end ; DialogueOn ;
34419: CALL_OW 6
// if IsOK ( Roth ) then
34423: LD_EXP 79
34427: PPUSH
34428: CALL_OW 302
34432: IFFALSE 34446
// Say ( JMM , DAb-JMM-1 ) ;
34434: LD_EXP 40
34438: PPUSH
34439: LD_STRING DAb-JMM-1
34441: PPUSH
34442: CALL_OW 88
// if IsOK ( Roth ) then
34446: LD_EXP 79
34450: PPUSH
34451: CALL_OW 302
34455: IFFALSE 34479
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
34457: LD_EXP 79
34461: PPUSH
34462: LD_STRING DSurrenderAlliance-Roth-1
34464: PPUSH
34465: CALL_OW 88
// RothCaptured := true ;
34469: LD_ADDR_EXP 33
34473: PUSH
34474: LD_INT 1
34476: ST_TO_ADDR
// end else
34477: GO 34491
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
34479: LD_VAR 0 1
34483: PPUSH
34484: LD_STRING DSurrenderAlliance-Sci1-1
34486: PPUSH
34487: CALL_OW 88
// DialogueOff ;
34491: CALL_OW 7
// allianceDestroyed := true ;
34495: LD_ADDR_EXP 23
34499: PUSH
34500: LD_INT 1
34502: ST_TO_ADDR
// if capturedUnit = 0 then
34503: LD_EXP 34
34507: PUSH
34508: LD_INT 0
34510: EQUAL
34511: IFFALSE 34520
// SetAchievement ( ACH_ALLIANCE ) ;
34513: LD_STRING ACH_ALLIANCE
34515: PPUSH
34516: CALL_OW 543
// if trueAmericans then
34520: LD_EXP 35
34524: IFFALSE 34600
// begin if trueAmericans = 1 then
34526: LD_EXP 35
34530: PUSH
34531: LD_INT 1
34533: EQUAL
34534: IFFALSE 34550
// Say ( JMM , DAb-JMM-1a ) else
34536: LD_EXP 40
34540: PPUSH
34541: LD_STRING DAb-JMM-1a
34543: PPUSH
34544: CALL_OW 88
34548: GO 34562
// Say ( JMM , DAb-JMM-1b ) ;
34550: LD_EXP 40
34554: PPUSH
34555: LD_STRING DAb-JMM-1b
34557: PPUSH
34558: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
34562: LD_EXP 35
34566: PPUSH
34567: CALL_OW 87
// for i in trueAmericans do
34571: LD_ADDR_VAR 0 2
34575: PUSH
34576: LD_EXP 35
34580: PUSH
34581: FOR_IN
34582: IFFALSE 34598
// SetSide ( i , 1 ) ;
34584: LD_VAR 0 2
34588: PPUSH
34589: LD_INT 1
34591: PPUSH
34592: CALL_OW 235
34596: GO 34581
34598: POP
34599: POP
// end ; repeat wait ( 0 0$1 ) ;
34600: LD_INT 35
34602: PPUSH
34603: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
34607: LD_ADDR_VAR 0 2
34611: PUSH
34612: LD_INT 22
34614: PUSH
34615: LD_INT 7
34617: PUSH
34618: EMPTY
34619: LIST
34620: LIST
34621: PUSH
34622: LD_INT 21
34624: PUSH
34625: LD_INT 1
34627: PUSH
34628: EMPTY
34629: LIST
34630: LIST
34631: PUSH
34632: EMPTY
34633: LIST
34634: LIST
34635: PPUSH
34636: CALL_OW 69
34640: PUSH
34641: FOR_IN
34642: IFFALSE 34724
// begin if IsInUnit ( i ) then
34644: LD_VAR 0 2
34648: PPUSH
34649: CALL_OW 310
34653: IFFALSE 34664
// ComExitBuilding ( i ) ;
34655: LD_VAR 0 2
34659: PPUSH
34660: CALL_OW 122
// if IsDriver ( i ) then
34664: LD_VAR 0 2
34668: PPUSH
34669: CALL 104965 0 1
34673: IFFALSE 34684
// ComExitVehicle ( i ) ;
34675: LD_VAR 0 2
34679: PPUSH
34680: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
34684: LD_VAR 0 2
34688: PPUSH
34689: LD_INT 26
34691: PPUSH
34692: CALL_OW 308
34696: NOT
34697: IFFALSE 34713
// AddComMoveToArea ( i , allianceEscapeArea ) else
34699: LD_VAR 0 2
34703: PPUSH
34704: LD_INT 26
34706: PPUSH
34707: CALL_OW 173
34711: GO 34722
// RemoveUnit ( i ) ;
34713: LD_VAR 0 2
34717: PPUSH
34718: CALL_OW 64
// end ;
34722: GO 34641
34724: POP
34725: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
34726: LD_INT 22
34728: PUSH
34729: LD_INT 7
34731: PUSH
34732: EMPTY
34733: LIST
34734: LIST
34735: PUSH
34736: LD_INT 21
34738: PUSH
34739: LD_INT 1
34741: PUSH
34742: EMPTY
34743: LIST
34744: LIST
34745: PUSH
34746: EMPTY
34747: LIST
34748: LIST
34749: PPUSH
34750: CALL_OW 69
34754: NOT
34755: IFFALSE 34600
// end ;
34757: PPOPN 2
34759: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
34760: LD_INT 0
34762: PPUSH
34763: PPUSH
// if not unit then
34764: LD_VAR 0 1
34768: NOT
34769: IFFALSE 34773
// exit ;
34771: GO 36287
// DoNotAttack ( 7 , unit ) ;
34773: LD_INT 7
34775: PPUSH
34776: LD_VAR 0 1
34780: PPUSH
34781: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
34785: LD_VAR 0 1
34789: PPUSH
34790: LD_INT 260
34792: PPUSH
34793: LD_INT 235
34795: PPUSH
34796: LD_INT 3
34798: PPUSH
34799: LD_INT 1
34801: PPUSH
34802: CALL_OW 483
// SetSide ( unit , 4 ) ;
34806: LD_VAR 0 1
34810: PPUSH
34811: LD_INT 4
34813: PPUSH
34814: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
34818: LD_ADDR_EXP 34
34822: PUSH
34823: LD_EXP 34
34827: PUSH
34828: LD_INT 1
34830: PLUS
34831: ST_TO_ADDR
// wait ( 0 0$2 ) ;
34832: LD_INT 70
34834: PPUSH
34835: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
34839: LD_INT 260
34841: PPUSH
34842: LD_INT 235
34844: PPUSH
34845: LD_INT 1
34847: PPUSH
34848: LD_INT 8
34850: NEG
34851: PPUSH
34852: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
34856: LD_VAR 0 1
34860: PPUSH
34861: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
34865: LD_VAR 0 1
34869: PPUSH
34870: LD_EXP 79
34874: PPUSH
34875: CALL_OW 119
// DialogueOn ;
34879: CALL_OW 6
// case unit of JMM :
34883: LD_VAR 0 1
34887: PUSH
34888: LD_EXP 40
34892: DOUBLE
34893: EQUAL
34894: IFTRUE 34898
34896: GO 34913
34898: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
34899: LD_EXP 40
34903: PPUSH
34904: LD_STRING DA1-JMM-1
34906: PPUSH
34907: CALL_OW 91
34911: GO 35355
34913: LD_EXP 41
34917: DOUBLE
34918: EQUAL
34919: IFTRUE 34923
34921: GO 34938
34923: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
34924: LD_EXP 41
34928: PPUSH
34929: LD_STRING DA1-Joan-1
34931: PPUSH
34932: CALL_OW 91
34936: GO 35355
34938: LD_EXP 43
34942: DOUBLE
34943: EQUAL
34944: IFTRUE 34948
34946: GO 34963
34948: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
34949: LD_EXP 43
34953: PPUSH
34954: LD_STRING DA1-Lisa-1
34956: PPUSH
34957: CALL_OW 91
34961: GO 35355
34963: LD_EXP 44
34967: DOUBLE
34968: EQUAL
34969: IFTRUE 34973
34971: GO 34988
34973: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
34974: LD_EXP 44
34978: PPUSH
34979: LD_STRING DA1-Don-1
34981: PPUSH
34982: CALL_OW 91
34986: GO 35355
34988: LD_EXP 51
34992: DOUBLE
34993: EQUAL
34994: IFTRUE 34998
34996: GO 35013
34998: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
34999: LD_EXP 51
35003: PPUSH
35004: LD_STRING DA1-Corn-1
35006: PPUSH
35007: CALL_OW 91
35011: GO 35355
35013: LD_EXP 47
35017: DOUBLE
35018: EQUAL
35019: IFTRUE 35023
35021: GO 35038
35023: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
35024: LD_EXP 47
35028: PPUSH
35029: LD_STRING DA1-Den-1
35031: PPUSH
35032: CALL_OW 91
35036: GO 35355
35038: LD_EXP 45
35042: DOUBLE
35043: EQUAL
35044: IFTRUE 35048
35046: GO 35063
35048: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
35049: LD_EXP 45
35053: PPUSH
35054: LD_STRING DA1-Bobby-1
35056: PPUSH
35057: CALL_OW 91
35061: GO 35355
35063: LD_EXP 49
35067: DOUBLE
35068: EQUAL
35069: IFTRUE 35073
35071: GO 35088
35073: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
35074: LD_EXP 49
35078: PPUSH
35079: LD_STRING DA1-Glad-1
35081: PPUSH
35082: CALL_OW 91
35086: GO 35355
35088: LD_EXP 46
35092: DOUBLE
35093: EQUAL
35094: IFTRUE 35098
35096: GO 35113
35098: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
35099: LD_EXP 46
35103: PPUSH
35104: LD_STRING DA1-Cyrus-1
35106: PPUSH
35107: CALL_OW 91
35111: GO 35355
35113: LD_EXP 42
35117: DOUBLE
35118: EQUAL
35119: IFTRUE 35123
35121: GO 35138
35123: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
35124: LD_EXP 42
35128: PPUSH
35129: LD_STRING DA1-Huck-1
35131: PPUSH
35132: CALL_OW 91
35136: GO 35355
35138: LD_EXP 56
35142: DOUBLE
35143: EQUAL
35144: IFTRUE 35148
35146: GO 35163
35148: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
35149: LD_EXP 56
35153: PPUSH
35154: LD_STRING DA1-Huck-1
35156: PPUSH
35157: CALL_OW 91
35161: GO 35355
35163: LD_EXP 48
35167: DOUBLE
35168: EQUAL
35169: IFTRUE 35173
35171: GO 35188
35173: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
35174: LD_EXP 48
35178: PPUSH
35179: LD_STRING DA1-Brown-1
35181: PPUSH
35182: CALL_OW 91
35186: GO 35355
35188: LD_EXP 52
35192: DOUBLE
35193: EQUAL
35194: IFTRUE 35198
35196: GO 35213
35198: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
35199: LD_EXP 52
35203: PPUSH
35204: LD_STRING DA1-Gary-1
35206: PPUSH
35207: CALL_OW 91
35211: GO 35355
35213: LD_EXP 55
35217: DOUBLE
35218: EQUAL
35219: IFTRUE 35223
35221: GO 35238
35223: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
35224: LD_EXP 55
35228: PPUSH
35229: LD_STRING DA1-Con-1
35231: PPUSH
35232: CALL_OW 91
35236: GO 35355
35238: LD_EXP 64
35242: DOUBLE
35243: EQUAL
35244: IFTRUE 35248
35246: GO 35263
35248: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
35249: LD_EXP 64
35253: PPUSH
35254: LD_STRING DA1-Kurt-1
35256: PPUSH
35257: CALL_OW 91
35261: GO 35355
35263: LD_EXP 54
35267: DOUBLE
35268: EQUAL
35269: IFTRUE 35273
35271: GO 35288
35273: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
35274: LD_EXP 54
35278: PPUSH
35279: LD_STRING DA1-Yam-1
35281: PPUSH
35282: CALL_OW 91
35286: GO 35355
35288: LD_EXP 53
35292: DOUBLE
35293: EQUAL
35294: IFTRUE 35298
35296: GO 35313
35298: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
35299: LD_EXP 53
35303: PPUSH
35304: LD_STRING DA1-Frank-1
35306: PPUSH
35307: CALL_OW 91
35311: GO 35355
35313: POP
// begin if GetSex ( unit ) = sex_male then
35314: LD_VAR 0 1
35318: PPUSH
35319: CALL_OW 258
35323: PUSH
35324: LD_INT 1
35326: EQUAL
35327: IFFALSE 35343
// ForceSay ( unit , DA1-Sol1-1 ) else
35329: LD_VAR 0 1
35333: PPUSH
35334: LD_STRING DA1-Sol1-1
35336: PPUSH
35337: CALL_OW 91
35341: GO 35355
// ForceSay ( unit , DA1-FSol1-1 ) ;
35343: LD_VAR 0 1
35347: PPUSH
35348: LD_STRING DA1-FSol1-1
35350: PPUSH
35351: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
35355: LD_EXP 79
35359: PPUSH
35360: LD_STRING DA-Roth-1
35362: PPUSH
35363: CALL_OW 88
// if capturedUnit = 1 then
35367: LD_EXP 34
35371: PUSH
35372: LD_INT 1
35374: EQUAL
35375: IFFALSE 35403
// begin Say ( Simms , DA-Sim-1 ) ;
35377: LD_EXP 80
35381: PPUSH
35382: LD_STRING DA-Sim-1
35384: PPUSH
35385: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
35389: LD_EXP 79
35393: PPUSH
35394: LD_STRING DA-Roth-2
35396: PPUSH
35397: CALL_OW 88
// end else
35401: GO 35415
// Say ( Simms , DA-Sim-2 ) ;
35403: LD_EXP 80
35407: PPUSH
35408: LD_STRING DA-Sim-2
35410: PPUSH
35411: CALL_OW 88
// case unit of JMM :
35415: LD_VAR 0 1
35419: PUSH
35420: LD_EXP 40
35424: DOUBLE
35425: EQUAL
35426: IFTRUE 35430
35428: GO 35445
35430: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
35431: LD_EXP 40
35435: PPUSH
35436: LD_STRING DA1-JMM-1a
35438: PPUSH
35439: CALL_OW 91
35443: GO 35962
35445: LD_EXP 41
35449: DOUBLE
35450: EQUAL
35451: IFTRUE 35455
35453: GO 35470
35455: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
35456: LD_EXP 41
35460: PPUSH
35461: LD_STRING DA1-Joan-1a
35463: PPUSH
35464: CALL_OW 91
35468: GO 35962
35470: LD_EXP 43
35474: DOUBLE
35475: EQUAL
35476: IFTRUE 35480
35478: GO 35495
35480: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
35481: LD_EXP 43
35485: PPUSH
35486: LD_STRING DA1-Lisa-1a
35488: PPUSH
35489: CALL_OW 91
35493: GO 35962
35495: LD_EXP 44
35499: DOUBLE
35500: EQUAL
35501: IFTRUE 35505
35503: GO 35520
35505: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
35506: LD_EXP 44
35510: PPUSH
35511: LD_STRING DA1-Don-1a
35513: PPUSH
35514: CALL_OW 91
35518: GO 35962
35520: LD_EXP 51
35524: DOUBLE
35525: EQUAL
35526: IFTRUE 35530
35528: GO 35545
35530: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
35531: LD_EXP 51
35535: PPUSH
35536: LD_STRING DA1-Corn-1a
35538: PPUSH
35539: CALL_OW 91
35543: GO 35962
35545: LD_EXP 47
35549: DOUBLE
35550: EQUAL
35551: IFTRUE 35555
35553: GO 35570
35555: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
35556: LD_EXP 47
35560: PPUSH
35561: LD_STRING DA1-Den-1a
35563: PPUSH
35564: CALL_OW 91
35568: GO 35962
35570: LD_EXP 45
35574: DOUBLE
35575: EQUAL
35576: IFTRUE 35580
35578: GO 35595
35580: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
35581: LD_EXP 45
35585: PPUSH
35586: LD_STRING DA1-Bobby-1a
35588: PPUSH
35589: CALL_OW 91
35593: GO 35962
35595: LD_EXP 49
35599: DOUBLE
35600: EQUAL
35601: IFTRUE 35605
35603: GO 35620
35605: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
35606: LD_EXP 49
35610: PPUSH
35611: LD_STRING DA1-Glad-1a
35613: PPUSH
35614: CALL_OW 91
35618: GO 35962
35620: LD_EXP 46
35624: DOUBLE
35625: EQUAL
35626: IFTRUE 35630
35628: GO 35645
35630: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
35631: LD_EXP 46
35635: PPUSH
35636: LD_STRING DA1-Cyrus-1a
35638: PPUSH
35639: CALL_OW 91
35643: GO 35962
35645: LD_EXP 42
35649: DOUBLE
35650: EQUAL
35651: IFTRUE 35655
35653: GO 35670
35655: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
35656: LD_EXP 42
35660: PPUSH
35661: LD_STRING DA1-Huck-1a
35663: PPUSH
35664: CALL_OW 91
35668: GO 35962
35670: LD_EXP 56
35674: DOUBLE
35675: EQUAL
35676: IFTRUE 35680
35678: GO 35695
35680: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
35681: LD_EXP 56
35685: PPUSH
35686: LD_STRING DA1-Huck-1a
35688: PPUSH
35689: CALL_OW 91
35693: GO 35962
35695: LD_EXP 48
35699: DOUBLE
35700: EQUAL
35701: IFTRUE 35705
35703: GO 35720
35705: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
35706: LD_EXP 48
35710: PPUSH
35711: LD_STRING DA1-Brown-1a
35713: PPUSH
35714: CALL_OW 91
35718: GO 35962
35720: LD_EXP 52
35724: DOUBLE
35725: EQUAL
35726: IFTRUE 35730
35728: GO 35745
35730: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
35731: LD_EXP 52
35735: PPUSH
35736: LD_STRING DA1-Gary-1a
35738: PPUSH
35739: CALL_OW 91
35743: GO 35962
35745: LD_EXP 55
35749: DOUBLE
35750: EQUAL
35751: IFTRUE 35755
35753: GO 35780
35755: POP
// if JMMGirl = 3 then
35756: LD_EXP 7
35760: PUSH
35761: LD_INT 3
35763: EQUAL
35764: IFFALSE 35778
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
35766: LD_EXP 55
35770: PPUSH
35771: LD_STRING DA1-Con-1a
35773: PPUSH
35774: CALL_OW 91
35778: GO 35962
35780: LD_EXP 64
35784: DOUBLE
35785: EQUAL
35786: IFTRUE 35790
35788: GO 35805
35790: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
35791: LD_EXP 64
35795: PPUSH
35796: LD_STRING DA1-Kurt-1a
35798: PPUSH
35799: CALL_OW 91
35803: GO 35962
35805: LD_EXP 54
35809: DOUBLE
35810: EQUAL
35811: IFTRUE 35815
35813: GO 35830
35815: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
35816: LD_EXP 54
35820: PPUSH
35821: LD_STRING DA1-Yam-1a
35823: PPUSH
35824: CALL_OW 91
35828: GO 35962
35830: LD_EXP 53
35834: DOUBLE
35835: EQUAL
35836: IFTRUE 35840
35838: GO 35855
35840: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
35841: LD_EXP 53
35845: PPUSH
35846: LD_STRING DA1-Frank-1a
35848: PPUSH
35849: CALL_OW 91
35853: GO 35962
35855: POP
// begin join := rand ( 0 , 1 ) ;
35856: LD_ADDR_VAR 0 3
35860: PUSH
35861: LD_INT 0
35863: PPUSH
35864: LD_INT 1
35866: PPUSH
35867: CALL_OW 12
35871: ST_TO_ADDR
// if join then
35872: LD_VAR 0 3
35876: IFFALSE 35921
// begin if GetSex ( unit ) = sex_male then
35878: LD_VAR 0 1
35882: PPUSH
35883: CALL_OW 258
35887: PUSH
35888: LD_INT 1
35890: EQUAL
35891: IFFALSE 35907
// ForceSay ( unit , DA1-Sol1-1b ) else
35893: LD_VAR 0 1
35897: PPUSH
35898: LD_STRING DA1-Sol1-1b
35900: PPUSH
35901: CALL_OW 91
35905: GO 35919
// ForceSay ( unit , DA1-FSol1-1b ) ;
35907: LD_VAR 0 1
35911: PPUSH
35912: LD_STRING DA1-FSol1-1b
35914: PPUSH
35915: CALL_OW 91
// end else
35919: GO 35962
// begin if GetSex ( unit ) = sex_male then
35921: LD_VAR 0 1
35925: PPUSH
35926: CALL_OW 258
35930: PUSH
35931: LD_INT 1
35933: EQUAL
35934: IFFALSE 35950
// ForceSay ( unit , DA1-Sol1-1a ) else
35936: LD_VAR 0 1
35940: PPUSH
35941: LD_STRING DA1-Sol1-1a
35943: PPUSH
35944: CALL_OW 91
35948: GO 35962
// ForceSay ( unit , DA1-FSol1-1a ) ;
35950: LD_VAR 0 1
35954: PPUSH
35955: LD_STRING DA1-FSol1-1a
35957: PPUSH
35958: CALL_OW 91
// end ; end ; end ; if unit = JMM then
35962: LD_VAR 0 1
35966: PUSH
35967: LD_EXP 40
35971: EQUAL
35972: IFFALSE 35983
// begin YouLost ( JMMCaptured ) ;
35974: LD_STRING JMMCaptured
35976: PPUSH
35977: CALL_OW 104
// exit ;
35981: GO 36287
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi , DeltaDoctor ] or join then
35983: LD_VAR 0 1
35987: PUSH
35988: LD_EXP 44
35992: PUSH
35993: LD_EXP 47
35997: PUSH
35998: LD_EXP 45
36002: PUSH
36003: LD_EXP 42
36007: PUSH
36008: LD_EXP 56
36012: PUSH
36013: LD_EXP 48
36017: PUSH
36018: LD_EXP 54
36022: PUSH
36023: LD_EXP 58
36027: PUSH
36028: EMPTY
36029: LIST
36030: LIST
36031: LIST
36032: LIST
36033: LIST
36034: LIST
36035: LIST
36036: LIST
36037: IN
36038: PUSH
36039: LD_VAR 0 3
36043: OR
36044: IFFALSE 36143
// begin Say ( Roth , DA-Roth-3 ) ;
36046: LD_EXP 79
36050: PPUSH
36051: LD_STRING DA-Roth-3
36053: PPUSH
36054: CALL_OW 88
// SetSide ( unit , 7 ) ;
36058: LD_VAR 0 1
36062: PPUSH
36063: LD_INT 7
36065: PPUSH
36066: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
36070: LD_ADDR_EXP 102
36074: PUSH
36075: LD_EXP 102
36079: PPUSH
36080: LD_INT 1
36082: PPUSH
36083: LD_EXP 102
36087: PUSH
36088: LD_INT 1
36090: ARRAY
36091: PUSH
36092: LD_VAR 0 1
36096: ADD
36097: PPUSH
36098: CALL_OW 1
36102: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
36103: LD_INT 260
36105: PPUSH
36106: LD_INT 235
36108: PPUSH
36109: LD_INT 1
36111: PPUSH
36112: CALL_OW 331
// SetLives ( unit , 1000 ) ;
36116: LD_VAR 0 1
36120: PPUSH
36121: LD_INT 1000
36123: PPUSH
36124: CALL_OW 234
// DialogueOff ;
36128: CALL_OW 7
// ComFree ( unit ) ;
36132: LD_VAR 0 1
36136: PPUSH
36137: CALL_OW 139
// end else
36141: GO 36224
// begin Say ( Roth , DA-Roth-3a ) ;
36143: LD_EXP 79
36147: PPUSH
36148: LD_STRING DA-Roth-3a
36150: PPUSH
36151: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
36155: LD_ADDR_EXP 35
36159: PUSH
36160: LD_EXP 35
36164: PUSH
36165: LD_VAR 0 1
36169: ADD
36170: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
36171: LD_INT 260
36173: PPUSH
36174: LD_INT 235
36176: PPUSH
36177: LD_INT 1
36179: PPUSH
36180: CALL_OW 331
// SetLives ( unit , 1000 ) ;
36184: LD_VAR 0 1
36188: PPUSH
36189: LD_INT 1000
36191: PPUSH
36192: CALL_OW 234
// DialogueOff ;
36196: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
36200: LD_VAR 0 1
36204: PPUSH
36205: LD_INT 272
36207: PPUSH
36208: LD_INT 254
36210: PPUSH
36211: CALL_OW 111
// AddComHold ( unit ) ;
36215: LD_VAR 0 1
36219: PPUSH
36220: CALL_OW 200
// end ; if capturedUnit = 1 then
36224: LD_EXP 34
36228: PUSH
36229: LD_INT 1
36231: EQUAL
36232: IFFALSE 36287
// begin DialogueOn ;
36234: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
36238: LD_EXP 40
36242: PPUSH
36243: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
36247: LD_EXP 40
36251: PPUSH
36252: LD_STRING DAa-JMM-1
36254: PPUSH
36255: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
36259: LD_EXP 40
36263: PPUSH
36264: LD_STRING DAa-JMM-1a
36266: PPUSH
36267: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
36271: LD_EXP 40
36275: PPUSH
36276: LD_STRING DAa-JMM-1b
36278: PPUSH
36279: CALL_OW 88
// DialogueOff ;
36283: CALL_OW 7
// end ; end ;
36287: LD_VAR 0 2
36291: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
36292: LD_EXP 15
36296: PUSH
36297: LD_INT 13
36299: GREATEREQUAL
36300: PUSH
36301: LD_INT 22
36303: PUSH
36304: LD_INT 2
36306: PUSH
36307: EMPTY
36308: LIST
36309: LIST
36310: PUSH
36311: LD_INT 21
36313: PUSH
36314: LD_INT 1
36316: PUSH
36317: EMPTY
36318: LIST
36319: LIST
36320: PUSH
36321: EMPTY
36322: LIST
36323: LIST
36324: PPUSH
36325: CALL_OW 69
36329: PUSH
36330: LD_INT 0
36332: EQUAL
36333: AND
36334: PUSH
36335: LD_INT 22
36337: PUSH
36338: LD_INT 2
36340: PUSH
36341: EMPTY
36342: LIST
36343: LIST
36344: PUSH
36345: LD_INT 33
36347: PUSH
36348: LD_INT 5
36350: PUSH
36351: EMPTY
36352: LIST
36353: LIST
36354: PUSH
36355: LD_INT 21
36357: PUSH
36358: LD_INT 2
36360: PUSH
36361: EMPTY
36362: LIST
36363: LIST
36364: PUSH
36365: LD_INT 50
36367: PUSH
36368: EMPTY
36369: LIST
36370: PUSH
36371: EMPTY
36372: LIST
36373: LIST
36374: LIST
36375: LIST
36376: PPUSH
36377: CALL_OW 69
36381: PUSH
36382: LD_INT 0
36384: EQUAL
36385: AND
36386: PUSH
36387: LD_EXP 21
36391: AND
36392: PUSH
36393: LD_EXP 22
36397: AND
36398: PUSH
36399: LD_EXP 23
36403: AND
36404: IFFALSE 37173
36406: GO 36408
36408: DISABLE
36409: LD_INT 0
36411: PPUSH
36412: PPUSH
36413: PPUSH
// begin wait ( 0 0$05 ) ;
36414: LD_INT 175
36416: PPUSH
36417: CALL_OW 67
// if Count ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 2 then
36421: LD_INT 22
36423: PUSH
36424: LD_INT 1
36426: PUSH
36427: EMPTY
36428: LIST
36429: LIST
36430: PUSH
36431: LD_INT 21
36433: PUSH
36434: LD_INT 1
36436: PUSH
36437: EMPTY
36438: LIST
36439: LIST
36440: PUSH
36441: LD_INT 23
36443: PUSH
36444: LD_INT 1
36446: PUSH
36447: EMPTY
36448: LIST
36449: LIST
36450: PUSH
36451: LD_INT 50
36453: PUSH
36454: EMPTY
36455: LIST
36456: PUSH
36457: EMPTY
36458: LIST
36459: LIST
36460: LIST
36461: LIST
36462: PPUSH
36463: CALL_OW 69
36467: PPUSH
36468: CALL 71772 0 1
36472: PUSH
36473: LD_INT 2
36475: LESS
36476: IFFALSE 36487
// begin YouLost ( LostVictory ) ;
36478: LD_STRING LostVictory
36480: PPUSH
36481: CALL_OW 104
// exit ;
36485: GO 37173
// end ; m1 := false ;
36487: LD_ADDR_VAR 0 1
36491: PUSH
36492: LD_INT 0
36494: ST_TO_ADDR
// m2 := false ;
36495: LD_ADDR_VAR 0 2
36499: PUSH
36500: LD_INT 0
36502: ST_TO_ADDR
// m3 := false ;
36503: LD_ADDR_VAR 0 3
36507: PUSH
36508: LD_INT 0
36510: ST_TO_ADDR
// if not bombExploded then
36511: LD_EXP 37
36515: NOT
36516: IFFALSE 36525
// SetAchievement ( ACH_SIBROCKET ) ;
36518: LD_STRING ACH_SIBROCKET
36520: PPUSH
36521: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
36525: LD_EXP 66
36529: PPUSH
36530: CALL_OW 255
36534: PUSH
36535: LD_INT 1
36537: EQUAL
36538: PUSH
36539: LD_EXP 66
36543: PPUSH
36544: CALL_OW 302
36548: AND
36549: IFFALSE 36565
// begin wait ( 3 ) ;
36551: LD_INT 3
36553: PPUSH
36554: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
36558: LD_STRING ACH_OPO
36560: PPUSH
36561: CALL_OW 543
// end ; if tick <= 120 120$00 then
36565: LD_OWVAR 1
36569: PUSH
36570: LD_INT 252000
36572: LESSEQUAL
36573: IFFALSE 36589
// begin wait ( 3 ) ;
36575: LD_INT 3
36577: PPUSH
36578: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
36582: LD_STRING ACH_ASPEED_15
36584: PPUSH
36585: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
36589: LD_EXP 40
36593: PPUSH
36594: CALL_OW 87
// music_class := 5 ;
36598: LD_ADDR_OWVAR 72
36602: PUSH
36603: LD_INT 5
36605: ST_TO_ADDR
// music_nat := 5 ;
36606: LD_ADDR_OWVAR 71
36610: PUSH
36611: LD_INT 5
36613: ST_TO_ADDR
// DialogueOn ;
36614: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
36618: LD_EXP 40
36622: PPUSH
36623: LD_STRING D20-JMM-1
36625: PPUSH
36626: CALL_OW 88
// if IsOK ( Joan ) then
36630: LD_EXP 41
36634: PPUSH
36635: CALL_OW 302
36639: IFFALSE 36653
// Say ( Joan , D20-Joan-1 ) ;
36641: LD_EXP 41
36645: PPUSH
36646: LD_STRING D20-Joan-1
36648: PPUSH
36649: CALL_OW 88
// if IsOk ( Lisa ) then
36653: LD_EXP 43
36657: PPUSH
36658: CALL_OW 302
36662: IFFALSE 36676
// Say ( Lisa , D20-Lisa-1 ) ;
36664: LD_EXP 43
36668: PPUSH
36669: LD_STRING D20-Lisa-1
36671: PPUSH
36672: CALL_OW 88
// if IsOk ( Donaldson ) then
36676: LD_EXP 44
36680: PPUSH
36681: CALL_OW 302
36685: IFFALSE 36699
// Say ( Donaldson , D20-Don-1 ) ;
36687: LD_EXP 44
36691: PPUSH
36692: LD_STRING D20-Don-1
36694: PPUSH
36695: CALL_OW 88
// if IsOK ( Cornel ) then
36699: LD_EXP 51
36703: PPUSH
36704: CALL_OW 302
36708: IFFALSE 36722
// Say ( Cornel , D20-Corn-1 ) ;
36710: LD_EXP 51
36714: PPUSH
36715: LD_STRING D20-Corn-1
36717: PPUSH
36718: CALL_OW 88
// if IsOk ( Denis ) then
36722: LD_EXP 47
36726: PPUSH
36727: CALL_OW 302
36731: IFFALSE 36745
// Say ( Denis , D20-Den-1 ) ;
36733: LD_EXP 47
36737: PPUSH
36738: LD_STRING D20-Den-1
36740: PPUSH
36741: CALL_OW 88
// if IsOk ( Bobby ) then
36745: LD_EXP 45
36749: PPUSH
36750: CALL_OW 302
36754: IFFALSE 36768
// Say ( Bobby , D20-Bobby-1 ) ;
36756: LD_EXP 45
36760: PPUSH
36761: LD_STRING D20-Bobby-1
36763: PPUSH
36764: CALL_OW 88
// if IsOk ( Gladstone ) then
36768: LD_EXP 49
36772: PPUSH
36773: CALL_OW 302
36777: IFFALSE 36791
// Say ( Gladstone , D20-Glad-1 ) ;
36779: LD_EXP 49
36783: PPUSH
36784: LD_STRING D20-Glad-1
36786: PPUSH
36787: CALL_OW 88
// if IsOk ( Cyrus ) then
36791: LD_EXP 46
36795: PPUSH
36796: CALL_OW 302
36800: IFFALSE 36814
// Say ( Cyrus , D20-Cyrus-1 ) ;
36802: LD_EXP 46
36806: PPUSH
36807: LD_STRING D20-Cyrus-1
36809: PPUSH
36810: CALL_OW 88
// if IsOk ( Stevens ) then
36814: LD_EXP 42
36818: PPUSH
36819: CALL_OW 302
36823: IFFALSE 36837
// Say ( Stevens , D20-Huck-1 ) ;
36825: LD_EXP 42
36829: PPUSH
36830: LD_STRING D20-Huck-1
36832: PPUSH
36833: CALL_OW 88
// if IsOk ( Brown ) then
36837: LD_EXP 48
36841: PPUSH
36842: CALL_OW 302
36846: IFFALSE 36860
// Say ( Brown , D20-Brown-1 ) ;
36848: LD_EXP 48
36852: PPUSH
36853: LD_STRING D20-Brown-1
36855: PPUSH
36856: CALL_OW 88
// if IsOk ( Gary ) then
36860: LD_EXP 52
36864: PPUSH
36865: CALL_OW 302
36869: IFFALSE 36883
// Say ( Gary , D20-Gary-1 ) ;
36871: LD_EXP 52
36875: PPUSH
36876: LD_STRING D20-Gary-1
36878: PPUSH
36879: CALL_OW 88
// if IsOk ( Connie ) then
36883: LD_EXP 55
36887: PPUSH
36888: CALL_OW 302
36892: IFFALSE 36906
// Say ( Connie , D20-Con-1 ) ;
36894: LD_EXP 55
36898: PPUSH
36899: LD_STRING D20-Con-1
36901: PPUSH
36902: CALL_OW 88
// if IsOk ( Kurt ) then
36906: LD_EXP 64
36910: PPUSH
36911: CALL_OW 302
36915: IFFALSE 36929
// Say ( Kurt , D20-Kurt-1 ) ;
36917: LD_EXP 64
36921: PPUSH
36922: LD_STRING D20-Kurt-1
36924: PPUSH
36925: CALL_OW 88
// if IsOk ( Kikuchi ) then
36929: LD_EXP 54
36933: PPUSH
36934: CALL_OW 302
36938: IFFALSE 36952
// Say ( Kikuchi , D20-Yam-1 ) ;
36940: LD_EXP 54
36944: PPUSH
36945: LD_STRING D20-Yam-1
36947: PPUSH
36948: CALL_OW 88
// if IsOk ( Frank ) then
36952: LD_EXP 53
36956: PPUSH
36957: CALL_OW 302
36961: IFFALSE 36975
// Say ( Frank , D20-Frank-1 ) ;
36963: LD_EXP 53
36967: PPUSH
36968: LD_STRING D20-Frank-1
36970: PPUSH
36971: CALL_OW 88
// DialogueOff ;
36975: CALL_OW 7
// if RothCaptured then
36979: LD_EXP 33
36983: IFFALSE 37005
// begin m1 := true ;
36985: LD_ADDR_VAR 0 1
36989: PUSH
36990: LD_INT 1
36992: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
36993: LD_STRING Roth
36995: PPUSH
36996: LD_INT 1
36998: PPUSH
36999: CALL_OW 101
// end else
37003: GO 37016
// AddMedal ( Roth , - 1 ) ;
37005: LD_STRING Roth
37007: PPUSH
37008: LD_INT 1
37010: NEG
37011: PPUSH
37012: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish or not behemothDone then
37016: LD_EXP 25
37020: NOT
37021: PUSH
37022: LD_EXP 27
37026: OR
37027: PUSH
37028: LD_EXP 28
37032: NOT
37033: OR
37034: IFFALSE 37056
// begin m2 := true ;
37036: LD_ADDR_VAR 0 2
37040: PUSH
37041: LD_INT 1
37043: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
37044: LD_STRING Project
37046: PPUSH
37047: LD_INT 1
37049: PPUSH
37050: CALL_OW 101
// end else
37054: GO 37067
// AddMedal ( Project , - 1 ) ;
37056: LD_STRING Project
37058: PPUSH
37059: LD_INT 1
37061: NEG
37062: PPUSH
37063: CALL_OW 101
// if lostCounter = 0 then
37067: LD_EXP 32
37071: PUSH
37072: LD_INT 0
37074: EQUAL
37075: IFFALSE 37097
// begin m3 := true ;
37077: LD_ADDR_VAR 0 3
37081: PUSH
37082: LD_INT 1
37084: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
37085: LD_STRING NoLosses
37087: PPUSH
37088: LD_INT 1
37090: PPUSH
37091: CALL_OW 101
// end else
37095: GO 37108
// AddMedal ( NoLosses , - 1 ) ;
37097: LD_STRING NoLosses
37099: PPUSH
37100: LD_INT 1
37102: NEG
37103: PPUSH
37104: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
37108: LD_VAR 0 1
37112: PUSH
37113: LD_VAR 0 2
37117: AND
37118: PUSH
37119: LD_VAR 0 3
37123: AND
37124: PUSH
37125: LD_OWVAR 67
37129: PUSH
37130: LD_INT 3
37132: GREATEREQUAL
37133: AND
37134: IFFALSE 37146
// SetAchievementEX ( ACH_AMER , 15 ) ;
37136: LD_STRING ACH_AMER
37138: PPUSH
37139: LD_INT 15
37141: PPUSH
37142: CALL_OW 564
// GiveMedals ( MAIN ) ;
37146: LD_STRING MAIN
37148: PPUSH
37149: CALL_OW 102
// music_class := 4 ;
37153: LD_ADDR_OWVAR 72
37157: PUSH
37158: LD_INT 4
37160: ST_TO_ADDR
// music_nat := 1 ;
37161: LD_ADDR_OWVAR 71
37165: PUSH
37166: LD_INT 1
37168: ST_TO_ADDR
// YouWin ;
37169: CALL_OW 103
// end ; end_of_file
37173: PPOPN 3
37175: END
// export function CustomEvent ( event ) ; begin
37176: LD_INT 0
37178: PPUSH
// end ;
37179: LD_VAR 0 2
37183: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
37184: LD_VAR 0 1
37188: PUSH
37189: LD_INT 1
37191: EQUAL
37192: PUSH
37193: LD_VAR 0 2
37197: PUSH
37198: LD_INT 4
37200: EQUAL
37201: AND
37202: PUSH
37203: LD_EXP 61
37207: PPUSH
37208: CALL_OW 300
37212: AND
37213: IFFALSE 37229
// begin wait ( 0 0$2 ) ;
37215: LD_INT 70
37217: PPUSH
37218: CALL_OW 67
// YouLost ( Dismissed ) ;
37222: LD_STRING Dismissed
37224: PPUSH
37225: CALL_OW 104
// end ; end ;
37229: PPOPN 2
37231: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
37232: LD_VAR 0 2
37236: PPUSH
37237: LD_VAR 0 3
37241: PPUSH
37242: LD_INT 18
37244: PPUSH
37245: CALL_OW 309
37249: IFFALSE 37258
// YouLost ( Motherlode3 ) ;
37251: LD_STRING Motherlode3
37253: PPUSH
37254: CALL_OW 104
// end ;
37258: PPOPN 3
37260: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
37261: LD_EXP 27
37265: NOT
37266: IFFALSE 37276
// behemothDone := true ;
37268: LD_ADDR_EXP 28
37272: PUSH
37273: LD_INT 1
37275: ST_TO_ADDR
// end ;
37276: PPOPN 1
37278: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
37279: LD_VAR 0 1
37283: PPUSH
37284: CALL_OW 255
37288: PUSH
37289: LD_INT 1
37291: EQUAL
37292: IFFALSE 37302
// bombExploded := true ;
37294: LD_ADDR_EXP 37
37298: PUSH
37299: LD_INT 1
37301: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
37302: LD_VAR 0 1
37306: PPUSH
37307: CALL_OW 255
37311: PUSH
37312: LD_INT 3
37314: EQUAL
37315: IFFALSE 37345
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
37317: LD_INT 2
37319: PPUSH
37320: LD_INT 23
37322: PUSH
37323: LD_INT 3
37325: PUSH
37326: LD_INT 3
37328: PUSH
37329: LD_INT 48
37331: PUSH
37332: EMPTY
37333: LIST
37334: LIST
37335: LIST
37336: LIST
37337: PUSH
37338: EMPTY
37339: LIST
37340: PPUSH
37341: CALL 63244 0 2
// if GetSide ( unit ) = 1 and GetSide ( Friend ) = 1 and IsOk ( Friend ) and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
37345: LD_VAR 0 1
37349: PPUSH
37350: CALL_OW 255
37354: PUSH
37355: LD_INT 1
37357: EQUAL
37358: PUSH
37359: LD_EXP 66
37363: PPUSH
37364: CALL_OW 255
37368: PUSH
37369: LD_INT 1
37371: EQUAL
37372: AND
37373: PUSH
37374: LD_EXP 66
37378: PPUSH
37379: CALL_OW 302
37383: AND
37384: PUSH
37385: LD_EXP 30
37389: AND
37390: PUSH
37391: LD_INT 22
37393: PUSH
37394: LD_INT 3
37396: PUSH
37397: EMPTY
37398: LIST
37399: LIST
37400: PUSH
37401: LD_INT 34
37403: PUSH
37404: LD_INT 48
37406: PUSH
37407: EMPTY
37408: LIST
37409: LIST
37410: PUSH
37411: EMPTY
37412: LIST
37413: LIST
37414: PPUSH
37415: CALL_OW 69
37419: AND
37420: PUSH
37421: LD_INT 22
37423: PUSH
37424: LD_INT 1
37426: PUSH
37427: EMPTY
37428: LIST
37429: LIST
37430: PUSH
37431: LD_INT 34
37433: PUSH
37434: LD_INT 8
37436: PUSH
37437: EMPTY
37438: LIST
37439: LIST
37440: PUSH
37441: EMPTY
37442: LIST
37443: LIST
37444: PPUSH
37445: CALL_OW 69
37449: NOT
37450: AND
37451: IFFALSE 37503
// begin wait ( 0 0$5 ) ;
37453: LD_INT 175
37455: PPUSH
37456: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
37460: LD_INT 22
37462: PUSH
37463: LD_INT 3
37465: PUSH
37466: EMPTY
37467: LIST
37468: LIST
37469: PUSH
37470: LD_INT 34
37472: PUSH
37473: LD_INT 48
37475: PUSH
37476: EMPTY
37477: LIST
37478: LIST
37479: PUSH
37480: EMPTY
37481: LIST
37482: LIST
37483: PPUSH
37484: CALL_OW 69
37488: PUSH
37489: LD_INT 1
37491: ARRAY
37492: PPUSH
37493: LD_INT 60
37495: PPUSH
37496: LD_INT 95
37498: PPUSH
37499: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
37503: LD_VAR 0 2
37507: PPUSH
37508: LD_VAR 0 3
37512: PPUSH
37513: LD_INT 18
37515: PPUSH
37516: CALL_OW 309
37520: PUSH
37521: LD_VAR 0 2
37525: PPUSH
37526: LD_VAR 0 3
37530: PPUSH
37531: LD_INT 18
37533: PPUSH
37534: CALL 111170 0 3
37538: OR
37539: IFFALSE 37586
// begin if GetSide ( unit ) = 1 then
37541: LD_VAR 0 1
37545: PPUSH
37546: CALL_OW 255
37550: PUSH
37551: LD_INT 1
37553: EQUAL
37554: IFFALSE 37572
// begin wait ( 0 0$6 ) ;
37556: LD_INT 210
37558: PPUSH
37559: CALL_OW 67
// YouLost ( Motherlode2 ) ;
37563: LD_STRING Motherlode2
37565: PPUSH
37566: CALL_OW 104
// end else
37570: GO 37586
// begin wait ( 0 0$6 ) ;
37572: LD_INT 210
37574: PPUSH
37575: CALL_OW 67
// YouLost ( Motherlode1 ) ;
37579: LD_STRING Motherlode1
37581: PPUSH
37582: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
37586: LD_VAR 0 1
37590: PPUSH
37591: CALL_OW 255
37595: PUSH
37596: LD_INT 3
37598: EQUAL
37599: IFFALSE 37620
// begin wait ( 0 0$5 ) ;
37601: LD_INT 175
37603: PPUSH
37604: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
37608: LD_EXP 68
37612: PPUSH
37613: LD_STRING D18-Pla-1
37615: PPUSH
37616: CALL_OW 94
// end ; end ;
37620: PPOPN 3
37622: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
37623: LD_VAR 0 1
37627: PPUSH
37628: CALL 128260 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
37632: LD_VAR 0 1
37636: PUSH
37637: LD_INT 22
37639: PUSH
37640: LD_INT 1
37642: PUSH
37643: EMPTY
37644: LIST
37645: LIST
37646: PUSH
37647: LD_INT 21
37649: PUSH
37650: LD_INT 1
37652: PUSH
37653: EMPTY
37654: LIST
37655: LIST
37656: PUSH
37657: LD_INT 23
37659: PUSH
37660: LD_INT 1
37662: PUSH
37663: EMPTY
37664: LIST
37665: LIST
37666: PUSH
37667: EMPTY
37668: LIST
37669: LIST
37670: LIST
37671: PPUSH
37672: CALL_OW 69
37676: IN
37677: IFFALSE 37693
// lostCounter := lostCounter + 1 ;
37679: LD_ADDR_EXP 32
37683: PUSH
37684: LD_EXP 32
37688: PUSH
37689: LD_INT 1
37691: PLUS
37692: ST_TO_ADDR
// if un in behemothBuilders then
37693: LD_VAR 0 1
37697: PUSH
37698: LD_EXP 77
37702: IN
37703: IFFALSE 37723
// begin behemothBuilders := behemothBuilders diff un ;
37705: LD_ADDR_EXP 77
37709: PUSH
37710: LD_EXP 77
37714: PUSH
37715: LD_VAR 0 1
37719: DIFF
37720: ST_TO_ADDR
// exit ;
37721: GO 37753
// end ; if un = JMM then
37723: LD_VAR 0 1
37727: PUSH
37728: LD_EXP 40
37732: EQUAL
37733: IFFALSE 37744
// begin YouLost ( JMM ) ;
37735: LD_STRING JMM
37737: PPUSH
37738: CALL_OW 104
// exit ;
37742: GO 37753
// end ; MCE_UnitDestroyed ( un ) ;
37744: LD_VAR 0 1
37748: PPUSH
37749: CALL 66686 0 1
// end ;
37753: PPOPN 1
37755: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
37756: LD_VAR 0 1
37760: PPUSH
37761: LD_VAR 0 2
37765: PPUSH
37766: CALL 69018 0 2
// end ;
37770: PPOPN 2
37772: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
37773: LD_VAR 0 1
37777: PPUSH
37778: CALL 68086 0 1
// end ;
37782: PPOPN 1
37784: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
37785: LD_VAR 0 1
37789: PUSH
37790: LD_INT 22
37792: PUSH
37793: LD_INT 8
37795: PUSH
37796: EMPTY
37797: LIST
37798: LIST
37799: PUSH
37800: LD_INT 30
37802: PUSH
37803: LD_INT 2
37805: PUSH
37806: EMPTY
37807: LIST
37808: LIST
37809: PUSH
37810: LD_INT 23
37812: PUSH
37813: LD_INT 3
37815: PUSH
37816: EMPTY
37817: LIST
37818: LIST
37819: PUSH
37820: EMPTY
37821: LIST
37822: LIST
37823: LIST
37824: PPUSH
37825: CALL_OW 69
37829: IN
37830: IFFALSE 37857
// begin ComUpgrade ( building ) ;
37832: LD_VAR 0 1
37836: PPUSH
37837: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
37841: LD_EXP 65
37845: PPUSH
37846: LD_VAR 0 1
37850: PPUSH
37851: CALL 77870 0 2
// exit ;
37855: GO 37866
// end ; MCE_BuildingComplete ( building ) ;
37857: LD_VAR 0 1
37861: PPUSH
37862: CALL 68327 0 1
// end ;
37866: PPOPN 1
37868: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
37869: LD_VAR 0 1
37873: PPUSH
37874: LD_VAR 0 2
37878: PPUSH
37879: CALL 66382 0 2
// end ;
37883: PPOPN 2
37885: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
37886: LD_VAR 0 1
37890: PPUSH
37891: LD_VAR 0 2
37895: PPUSH
37896: LD_VAR 0 3
37900: PPUSH
37901: LD_VAR 0 4
37905: PPUSH
37906: LD_VAR 0 5
37910: PPUSH
37911: CALL 66002 0 5
// end ;
37915: PPOPN 5
37917: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
37918: LD_VAR 0 1
37922: PPUSH
37923: CALL_OW 255
37927: PUSH
37928: LD_INT 1
37930: EQUAL
37931: IFFALSE 37948
// amConstructCounter := Inc ( amConstructCounter ) ;
37933: LD_ADDR_EXP 39
37937: PUSH
37938: LD_EXP 39
37942: PPUSH
37943: CALL 108722 0 1
37947: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
37948: LD_VAR 0 1
37952: PPUSH
37953: LD_VAR 0 2
37957: PPUSH
37958: CALL 128380 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
37962: LD_VAR 0 1
37966: PPUSH
37967: LD_VAR 0 2
37971: PPUSH
37972: CALL 65555 0 2
// end ;
37976: PPOPN 2
37978: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
37979: LD_VAR 0 1
37983: PPUSH
37984: LD_VAR 0 2
37988: PPUSH
37989: LD_VAR 0 3
37993: PPUSH
37994: LD_VAR 0 4
37998: PPUSH
37999: CALL 65393 0 4
// end ;
38003: PPOPN 4
38005: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
38006: LD_VAR 0 1
38010: PPUSH
38011: LD_VAR 0 2
38015: PPUSH
38016: LD_VAR 0 3
38020: PPUSH
38021: CALL 65168 0 3
// end ;
38025: PPOPN 3
38027: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
38028: LD_VAR 0 1
38032: PPUSH
38033: LD_VAR 0 2
38037: PPUSH
38038: CALL 65053 0 2
// end ;
38042: PPOPN 2
38044: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
38045: LD_VAR 0 1
38049: PPUSH
38050: LD_VAR 0 2
38054: PPUSH
38055: CALL 69313 0 2
// end ;
38059: PPOPN 2
38061: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
38062: LD_VAR 0 1
38066: PUSH
38067: LD_INT 460
38069: EQUAL
38070: IFFALSE 38092
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
38072: LD_VAR 0 2
38076: PPUSH
38077: LD_INT 227
38079: PPUSH
38080: LD_INT 136
38082: PPUSH
38083: CALL_OW 428
38087: PPUSH
38088: CALL_OW 120
// end ;
38092: PPOPN 2
38094: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
38095: LD_VAR 0 1
38099: PPUSH
38100: CALL_OW 255
38104: PUSH
38105: LD_INT 4
38107: EQUAL
38108: PUSH
38109: LD_VAR 0 1
38113: PUSH
38114: LD_EXP 18
38118: PUSH
38119: LD_INT 1
38121: ARRAY
38122: IN
38123: AND
38124: PUSH
38125: LD_EXP 19
38129: AND
38130: IFFALSE 38149
// begin ComMoveXY ( driver , 61 , 93 ) ;
38132: LD_VAR 0 1
38136: PPUSH
38137: LD_INT 61
38139: PPUSH
38140: LD_INT 93
38142: PPUSH
38143: CALL_OW 111
// exit ;
38147: GO 38218
// end ; if GetSide ( driver ) = 3 and GetTag ( driver ) = 105 then
38149: LD_VAR 0 1
38153: PPUSH
38154: CALL_OW 255
38158: PUSH
38159: LD_INT 3
38161: EQUAL
38162: PUSH
38163: LD_VAR 0 1
38167: PPUSH
38168: CALL_OW 110
38172: PUSH
38173: LD_INT 105
38175: EQUAL
38176: AND
38177: IFFALSE 38194
// begin ComMoveXY ( driver , 187 , 92 ) ;
38179: LD_VAR 0 1
38183: PPUSH
38184: LD_INT 187
38186: PPUSH
38187: LD_INT 92
38189: PPUSH
38190: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
38194: LD_VAR 0 1
38198: PPUSH
38199: LD_VAR 0 2
38203: PPUSH
38204: LD_VAR 0 3
38208: PPUSH
38209: LD_VAR 0 4
38213: PPUSH
38214: CALL 69529 0 4
// end ;
38218: PPOPN 4
38220: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
38221: LD_VAR 0 1
38225: PPUSH
38226: LD_VAR 0 2
38230: PPUSH
38231: CALL 64862 0 2
// end ;
38235: PPOPN 2
38237: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
38238: LD_VAR 0 1
38242: PPUSH
38243: CALL 128364 0 1
// end ; end_of_file
38247: PPOPN 1
38249: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
38250: LD_EXP 15
38254: PUSH
38255: LD_INT 2
38257: EQUAL
38258: IFFALSE 38775
38260: GO 38262
38262: DISABLE
38263: LD_INT 0
38265: PPUSH
38266: PPUSH
// begin time := 0 0$35 ;
38267: LD_ADDR_VAR 0 2
38271: PUSH
38272: LD_INT 1225
38274: ST_TO_ADDR
// repeat wait ( time ) ;
38275: LD_VAR 0 2
38279: PPUSH
38280: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
38284: LD_INT 1
38286: PPUSH
38287: LD_INT 5
38289: PPUSH
38290: CALL_OW 12
38294: PPUSH
38295: LD_INT 106
38297: PPUSH
38298: LD_INT 150
38300: PPUSH
38301: LD_INT 19
38303: PPUSH
38304: LD_INT 1
38306: PPUSH
38307: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
38311: LD_INT 455
38313: PPUSH
38314: LD_INT 770
38316: PPUSH
38317: CALL_OW 12
38321: PPUSH
38322: CALL_OW 67
// if Prob ( 50 ) then
38326: LD_INT 50
38328: PPUSH
38329: CALL_OW 13
38333: IFFALSE 38362
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
38335: LD_INT 1
38337: PPUSH
38338: LD_INT 5
38340: PPUSH
38341: CALL_OW 12
38345: PPUSH
38346: LD_INT 62
38348: PPUSH
38349: LD_INT 108
38351: PPUSH
38352: LD_INT 10
38354: PPUSH
38355: LD_INT 1
38357: PPUSH
38358: CALL_OW 56
// until missionStage > 4 ;
38362: LD_EXP 15
38366: PUSH
38367: LD_INT 4
38369: GREATER
38370: IFFALSE 38275
// repeat wait ( 0 0$1 ) ;
38372: LD_INT 35
38374: PPUSH
38375: CALL_OW 67
// until missionStage = 6 ;
38379: LD_EXP 15
38383: PUSH
38384: LD_INT 6
38386: EQUAL
38387: IFFALSE 38372
// time := 0 0$20 ;
38389: LD_ADDR_VAR 0 2
38393: PUSH
38394: LD_INT 700
38396: ST_TO_ADDR
// repeat wait ( time ) ;
38397: LD_VAR 0 2
38401: PPUSH
38402: CALL_OW 67
// if Prob ( 90 ) then
38406: LD_INT 90
38408: PPUSH
38409: CALL_OW 13
38413: IFFALSE 38456
// begin time := time + 0 0$2 ;
38415: LD_ADDR_VAR 0 2
38419: PUSH
38420: LD_VAR 0 2
38424: PUSH
38425: LD_INT 70
38427: PLUS
38428: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
38429: LD_INT 1
38431: PPUSH
38432: LD_INT 5
38434: PPUSH
38435: CALL_OW 12
38439: PPUSH
38440: LD_INT 106
38442: PPUSH
38443: LD_INT 89
38445: PPUSH
38446: LD_INT 45
38448: PPUSH
38449: LD_INT 1
38451: PPUSH
38452: CALL_OW 56
// end ; if Prob ( 45 ) then
38456: LD_INT 45
38458: PPUSH
38459: CALL_OW 13
38463: IFFALSE 38519
// begin for i := 1 to 4 do
38465: LD_ADDR_VAR 0 1
38469: PUSH
38470: DOUBLE
38471: LD_INT 1
38473: DEC
38474: ST_TO_ADDR
38475: LD_INT 4
38477: PUSH
38478: FOR_TO
38479: IFFALSE 38517
// begin wait ( 0 0$5 ) ;
38481: LD_INT 175
38483: PPUSH
38484: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
38488: LD_INT 1
38490: PPUSH
38491: LD_INT 5
38493: PPUSH
38494: CALL_OW 12
38498: PPUSH
38499: LD_INT 113
38501: PPUSH
38502: LD_INT 117
38504: PPUSH
38505: LD_INT 25
38507: PPUSH
38508: LD_INT 1
38510: PPUSH
38511: CALL_OW 56
// end ;
38515: GO 38478
38517: POP
38518: POP
// end ; if Prob ( 40 ) then
38519: LD_INT 40
38521: PPUSH
38522: CALL_OW 13
38526: IFFALSE 38572
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
38528: LD_INT 385
38530: PPUSH
38531: LD_INT 945
38533: PPUSH
38534: CALL_OW 12
38538: PPUSH
38539: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
38543: LD_INT 1
38545: PPUSH
38546: LD_INT 5
38548: PPUSH
38549: CALL_OW 12
38553: PPUSH
38554: LD_INT 21
38556: PPUSH
38557: LD_INT 26
38559: PPUSH
38560: LD_INT 12
38562: PPUSH
38563: LD_INT 1
38565: PPUSH
38566: CALL_OW 56
// end else
38570: GO 38608
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
38572: LD_INT 700
38574: PPUSH
38575: LD_INT 1225
38577: PPUSH
38578: CALL_OW 12
38582: PPUSH
38583: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
38587: LD_INT 1
38589: PPUSH
38590: LD_INT 5
38592: PPUSH
38593: CALL_OW 12
38597: PPUSH
38598: LD_INT 16
38600: PPUSH
38601: LD_INT 1
38603: PPUSH
38604: CALL_OW 55
// end ; if Prob ( 50 ) then
38608: LD_INT 50
38610: PPUSH
38611: CALL_OW 13
38615: IFFALSE 38661
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
38617: LD_INT 700
38619: PPUSH
38620: LD_INT 1050
38622: PPUSH
38623: CALL_OW 12
38627: PPUSH
38628: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
38632: LD_INT 1
38634: PPUSH
38635: LD_INT 5
38637: PPUSH
38638: CALL_OW 12
38642: PPUSH
38643: LD_INT 168
38645: PPUSH
38646: LD_INT 168
38648: PPUSH
38649: LD_INT 16
38651: PPUSH
38652: LD_INT 1
38654: PPUSH
38655: CALL_OW 56
// end else
38659: GO 38697
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
38661: LD_INT 350
38663: PPUSH
38664: LD_INT 525
38666: PPUSH
38667: CALL_OW 12
38671: PPUSH
38672: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
38676: LD_INT 1
38678: PPUSH
38679: LD_INT 5
38681: PPUSH
38682: CALL_OW 12
38686: PPUSH
38687: LD_INT 15
38689: PPUSH
38690: LD_INT 1
38692: PPUSH
38693: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
38697: LD_INT 175
38699: PPUSH
38700: LD_INT 315
38702: PPUSH
38703: CALL_OW 12
38707: PPUSH
38708: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
38712: LD_INT 1
38714: PPUSH
38715: LD_INT 5
38717: PPUSH
38718: CALL_OW 12
38722: PPUSH
38723: LD_INT 103
38725: PPUSH
38726: LD_INT 140
38728: PPUSH
38729: LD_INT 20
38731: PPUSH
38732: LD_INT 1
38734: PPUSH
38735: CALL_OW 56
// time := time + 0 0$2 ;
38739: LD_ADDR_VAR 0 2
38743: PUSH
38744: LD_VAR 0 2
38748: PUSH
38749: LD_INT 70
38751: PLUS
38752: ST_TO_ADDR
// if time > 1 1$20 then
38753: LD_VAR 0 2
38757: PUSH
38758: LD_INT 2800
38760: GREATER
38761: IFFALSE 38771
// time := 0 0$30 ;
38763: LD_ADDR_VAR 0 2
38767: PUSH
38768: LD_INT 1050
38770: ST_TO_ADDR
// until false ;
38771: LD_INT 0
38773: IFFALSE 38397
// end ; end_of_file
38775: PPOPN 2
38777: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
38778: LD_EXP 13
38782: PUSH
38783: LD_EXP 15
38787: PUSH
38788: LD_INT 6
38790: GREATEREQUAL
38791: AND
38792: IFFALSE 38829
38794: GO 38796
38796: DISABLE
// begin enable ;
38797: ENABLE
// missionTime := missionTime + 0 0$1 ;
38798: LD_ADDR_EXP 14
38802: PUSH
38803: LD_EXP 14
38807: PUSH
38808: LD_INT 35
38810: PLUS
38811: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
38812: LD_ADDR_OWVAR 47
38816: PUSH
38817: LD_STRING #Am15-1
38819: PUSH
38820: LD_EXP 14
38824: PUSH
38825: EMPTY
38826: LIST
38827: LIST
38828: ST_TO_ADDR
// end ; end_of_file
38829: END
// export function InitNature ; begin
38830: LD_INT 0
38832: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
38833: LD_INT 3
38835: PPUSH
38836: LD_INT 3
38838: PPUSH
38839: LD_INT 2
38841: PPUSH
38842: LD_INT 1
38844: PPUSH
38845: LD_INT 1
38847: PPUSH
38848: LD_INT 0
38850: PPUSH
38851: LD_INT 0
38853: PPUSH
38854: LD_INT 20
38856: PPUSH
38857: LD_INT 0
38859: PPUSH
38860: CALL 104038 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
38864: LD_INT 2
38866: PPUSH
38867: LD_INT 1
38869: PPUSH
38870: LD_INT 1
38872: PPUSH
38873: LD_INT 1
38875: PPUSH
38876: LD_INT 1
38878: PPUSH
38879: LD_INT 0
38881: PPUSH
38882: LD_INT 0
38884: PPUSH
38885: LD_INT 21
38887: PPUSH
38888: LD_INT 0
38890: PPUSH
38891: CALL 104038 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
38895: LD_INT 4
38897: PPUSH
38898: LD_INT 1
38900: PPUSH
38901: LD_INT 2
38903: PPUSH
38904: LD_INT 4
38906: PPUSH
38907: LD_INT 2
38909: PPUSH
38910: LD_INT 1
38912: PPUSH
38913: LD_INT 0
38915: PPUSH
38916: LD_INT 22
38918: PPUSH
38919: LD_INT 0
38921: PPUSH
38922: CALL 104038 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
38926: LD_INT 0
38928: PPUSH
38929: LD_INT 0
38931: PPUSH
38932: LD_INT 0
38934: PPUSH
38935: LD_INT 0
38937: PPUSH
38938: LD_INT 0
38940: PPUSH
38941: LD_INT 0
38943: PPUSH
38944: LD_INT 9
38946: PPUSH
38947: LD_INT 0
38949: PPUSH
38950: LD_INT 23
38952: PPUSH
38953: CALL 104038 0 9
// end ; end_of_file
38957: LD_VAR 0 1
38961: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
38962: LD_INT 0
38964: PPUSH
38965: PPUSH
// skirmish := false ;
38966: LD_ADDR_EXP 100
38970: PUSH
38971: LD_INT 0
38973: ST_TO_ADDR
// debug_mc := false ;
38974: LD_ADDR_EXP 101
38978: PUSH
38979: LD_INT 0
38981: ST_TO_ADDR
// mc_bases := [ ] ;
38982: LD_ADDR_EXP 102
38986: PUSH
38987: EMPTY
38988: ST_TO_ADDR
// mc_sides := [ ] ;
38989: LD_ADDR_EXP 128
38993: PUSH
38994: EMPTY
38995: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
38996: LD_ADDR_EXP 103
39000: PUSH
39001: EMPTY
39002: ST_TO_ADDR
// mc_building_repairs := [ ] ;
39003: LD_ADDR_EXP 104
39007: PUSH
39008: EMPTY
39009: ST_TO_ADDR
// mc_need_heal := [ ] ;
39010: LD_ADDR_EXP 105
39014: PUSH
39015: EMPTY
39016: ST_TO_ADDR
// mc_healers := [ ] ;
39017: LD_ADDR_EXP 106
39021: PUSH
39022: EMPTY
39023: ST_TO_ADDR
// mc_build_list := [ ] ;
39024: LD_ADDR_EXP 107
39028: PUSH
39029: EMPTY
39030: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
39031: LD_ADDR_EXP 134
39035: PUSH
39036: EMPTY
39037: ST_TO_ADDR
// mc_builders := [ ] ;
39038: LD_ADDR_EXP 108
39042: PUSH
39043: EMPTY
39044: ST_TO_ADDR
// mc_construct_list := [ ] ;
39045: LD_ADDR_EXP 109
39049: PUSH
39050: EMPTY
39051: ST_TO_ADDR
// mc_turret_list := [ ] ;
39052: LD_ADDR_EXP 110
39056: PUSH
39057: EMPTY
39058: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
39059: LD_ADDR_EXP 111
39063: PUSH
39064: EMPTY
39065: ST_TO_ADDR
// mc_miners := [ ] ;
39066: LD_ADDR_EXP 116
39070: PUSH
39071: EMPTY
39072: ST_TO_ADDR
// mc_mines := [ ] ;
39073: LD_ADDR_EXP 115
39077: PUSH
39078: EMPTY
39079: ST_TO_ADDR
// mc_minefields := [ ] ;
39080: LD_ADDR_EXP 117
39084: PUSH
39085: EMPTY
39086: ST_TO_ADDR
// mc_crates := [ ] ;
39087: LD_ADDR_EXP 118
39091: PUSH
39092: EMPTY
39093: ST_TO_ADDR
// mc_crates_collector := [ ] ;
39094: LD_ADDR_EXP 119
39098: PUSH
39099: EMPTY
39100: ST_TO_ADDR
// mc_crates_area := [ ] ;
39101: LD_ADDR_EXP 120
39105: PUSH
39106: EMPTY
39107: ST_TO_ADDR
// mc_vehicles := [ ] ;
39108: LD_ADDR_EXP 121
39112: PUSH
39113: EMPTY
39114: ST_TO_ADDR
// mc_attack := [ ] ;
39115: LD_ADDR_EXP 122
39119: PUSH
39120: EMPTY
39121: ST_TO_ADDR
// mc_produce := [ ] ;
39122: LD_ADDR_EXP 123
39126: PUSH
39127: EMPTY
39128: ST_TO_ADDR
// mc_defender := [ ] ;
39129: LD_ADDR_EXP 124
39133: PUSH
39134: EMPTY
39135: ST_TO_ADDR
// mc_parking := [ ] ;
39136: LD_ADDR_EXP 126
39140: PUSH
39141: EMPTY
39142: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
39143: LD_ADDR_EXP 112
39147: PUSH
39148: EMPTY
39149: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
39150: LD_ADDR_EXP 114
39154: PUSH
39155: EMPTY
39156: ST_TO_ADDR
// mc_scan := [ ] ;
39157: LD_ADDR_EXP 125
39161: PUSH
39162: EMPTY
39163: ST_TO_ADDR
// mc_scan_area := [ ] ;
39164: LD_ADDR_EXP 127
39168: PUSH
39169: EMPTY
39170: ST_TO_ADDR
// mc_tech := [ ] ;
39171: LD_ADDR_EXP 129
39175: PUSH
39176: EMPTY
39177: ST_TO_ADDR
// mc_class := [ ] ;
39178: LD_ADDR_EXP 143
39182: PUSH
39183: EMPTY
39184: ST_TO_ADDR
// mc_class_case_use := [ ] ;
39185: LD_ADDR_EXP 144
39189: PUSH
39190: EMPTY
39191: ST_TO_ADDR
// mc_is_defending := [ ] ;
39192: LD_ADDR_EXP 145
39196: PUSH
39197: EMPTY
39198: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
39199: LD_ADDR_EXP 136
39203: PUSH
39204: EMPTY
39205: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
39206: LD_ADDR_EXP 146
39210: PUSH
39211: LD_INT 0
39213: ST_TO_ADDR
// end ;
39214: LD_VAR 0 1
39218: RET
// export function MC_Kill ( base ) ; begin
39219: LD_INT 0
39221: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
39222: LD_ADDR_EXP 102
39226: PUSH
39227: LD_EXP 102
39231: PPUSH
39232: LD_VAR 0 1
39236: PPUSH
39237: EMPTY
39238: PPUSH
39239: CALL_OW 1
39243: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
39244: LD_ADDR_EXP 103
39248: PUSH
39249: LD_EXP 103
39253: PPUSH
39254: LD_VAR 0 1
39258: PPUSH
39259: EMPTY
39260: PPUSH
39261: CALL_OW 1
39265: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
39266: LD_ADDR_EXP 104
39270: PUSH
39271: LD_EXP 104
39275: PPUSH
39276: LD_VAR 0 1
39280: PPUSH
39281: EMPTY
39282: PPUSH
39283: CALL_OW 1
39287: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
39288: LD_ADDR_EXP 105
39292: PUSH
39293: LD_EXP 105
39297: PPUSH
39298: LD_VAR 0 1
39302: PPUSH
39303: EMPTY
39304: PPUSH
39305: CALL_OW 1
39309: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
39310: LD_ADDR_EXP 106
39314: PUSH
39315: LD_EXP 106
39319: PPUSH
39320: LD_VAR 0 1
39324: PPUSH
39325: EMPTY
39326: PPUSH
39327: CALL_OW 1
39331: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
39332: LD_ADDR_EXP 107
39336: PUSH
39337: LD_EXP 107
39341: PPUSH
39342: LD_VAR 0 1
39346: PPUSH
39347: EMPTY
39348: PPUSH
39349: CALL_OW 1
39353: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
39354: LD_ADDR_EXP 108
39358: PUSH
39359: LD_EXP 108
39363: PPUSH
39364: LD_VAR 0 1
39368: PPUSH
39369: EMPTY
39370: PPUSH
39371: CALL_OW 1
39375: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
39376: LD_ADDR_EXP 109
39380: PUSH
39381: LD_EXP 109
39385: PPUSH
39386: LD_VAR 0 1
39390: PPUSH
39391: EMPTY
39392: PPUSH
39393: CALL_OW 1
39397: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
39398: LD_ADDR_EXP 110
39402: PUSH
39403: LD_EXP 110
39407: PPUSH
39408: LD_VAR 0 1
39412: PPUSH
39413: EMPTY
39414: PPUSH
39415: CALL_OW 1
39419: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
39420: LD_ADDR_EXP 111
39424: PUSH
39425: LD_EXP 111
39429: PPUSH
39430: LD_VAR 0 1
39434: PPUSH
39435: EMPTY
39436: PPUSH
39437: CALL_OW 1
39441: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
39442: LD_ADDR_EXP 112
39446: PUSH
39447: LD_EXP 112
39451: PPUSH
39452: LD_VAR 0 1
39456: PPUSH
39457: EMPTY
39458: PPUSH
39459: CALL_OW 1
39463: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
39464: LD_ADDR_EXP 113
39468: PUSH
39469: LD_EXP 113
39473: PPUSH
39474: LD_VAR 0 1
39478: PPUSH
39479: LD_INT 0
39481: PPUSH
39482: CALL_OW 1
39486: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
39487: LD_ADDR_EXP 114
39491: PUSH
39492: LD_EXP 114
39496: PPUSH
39497: LD_VAR 0 1
39501: PPUSH
39502: EMPTY
39503: PPUSH
39504: CALL_OW 1
39508: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
39509: LD_ADDR_EXP 115
39513: PUSH
39514: LD_EXP 115
39518: PPUSH
39519: LD_VAR 0 1
39523: PPUSH
39524: EMPTY
39525: PPUSH
39526: CALL_OW 1
39530: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
39531: LD_ADDR_EXP 116
39535: PUSH
39536: LD_EXP 116
39540: PPUSH
39541: LD_VAR 0 1
39545: PPUSH
39546: EMPTY
39547: PPUSH
39548: CALL_OW 1
39552: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
39553: LD_ADDR_EXP 117
39557: PUSH
39558: LD_EXP 117
39562: PPUSH
39563: LD_VAR 0 1
39567: PPUSH
39568: EMPTY
39569: PPUSH
39570: CALL_OW 1
39574: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
39575: LD_ADDR_EXP 118
39579: PUSH
39580: LD_EXP 118
39584: PPUSH
39585: LD_VAR 0 1
39589: PPUSH
39590: EMPTY
39591: PPUSH
39592: CALL_OW 1
39596: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
39597: LD_ADDR_EXP 119
39601: PUSH
39602: LD_EXP 119
39606: PPUSH
39607: LD_VAR 0 1
39611: PPUSH
39612: EMPTY
39613: PPUSH
39614: CALL_OW 1
39618: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
39619: LD_ADDR_EXP 120
39623: PUSH
39624: LD_EXP 120
39628: PPUSH
39629: LD_VAR 0 1
39633: PPUSH
39634: EMPTY
39635: PPUSH
39636: CALL_OW 1
39640: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
39641: LD_ADDR_EXP 121
39645: PUSH
39646: LD_EXP 121
39650: PPUSH
39651: LD_VAR 0 1
39655: PPUSH
39656: EMPTY
39657: PPUSH
39658: CALL_OW 1
39662: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
39663: LD_ADDR_EXP 122
39667: PUSH
39668: LD_EXP 122
39672: PPUSH
39673: LD_VAR 0 1
39677: PPUSH
39678: EMPTY
39679: PPUSH
39680: CALL_OW 1
39684: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
39685: LD_ADDR_EXP 123
39689: PUSH
39690: LD_EXP 123
39694: PPUSH
39695: LD_VAR 0 1
39699: PPUSH
39700: EMPTY
39701: PPUSH
39702: CALL_OW 1
39706: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
39707: LD_ADDR_EXP 124
39711: PUSH
39712: LD_EXP 124
39716: PPUSH
39717: LD_VAR 0 1
39721: PPUSH
39722: EMPTY
39723: PPUSH
39724: CALL_OW 1
39728: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
39729: LD_ADDR_EXP 125
39733: PUSH
39734: LD_EXP 125
39738: PPUSH
39739: LD_VAR 0 1
39743: PPUSH
39744: EMPTY
39745: PPUSH
39746: CALL_OW 1
39750: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
39751: LD_ADDR_EXP 126
39755: PUSH
39756: LD_EXP 126
39760: PPUSH
39761: LD_VAR 0 1
39765: PPUSH
39766: EMPTY
39767: PPUSH
39768: CALL_OW 1
39772: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
39773: LD_ADDR_EXP 127
39777: PUSH
39778: LD_EXP 127
39782: PPUSH
39783: LD_VAR 0 1
39787: PPUSH
39788: EMPTY
39789: PPUSH
39790: CALL_OW 1
39794: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
39795: LD_ADDR_EXP 129
39799: PUSH
39800: LD_EXP 129
39804: PPUSH
39805: LD_VAR 0 1
39809: PPUSH
39810: EMPTY
39811: PPUSH
39812: CALL_OW 1
39816: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
39817: LD_ADDR_EXP 131
39821: PUSH
39822: LD_EXP 131
39826: PPUSH
39827: LD_VAR 0 1
39831: PPUSH
39832: EMPTY
39833: PPUSH
39834: CALL_OW 1
39838: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
39839: LD_ADDR_EXP 132
39843: PUSH
39844: LD_EXP 132
39848: PPUSH
39849: LD_VAR 0 1
39853: PPUSH
39854: EMPTY
39855: PPUSH
39856: CALL_OW 1
39860: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
39861: LD_ADDR_EXP 133
39865: PUSH
39866: LD_EXP 133
39870: PPUSH
39871: LD_VAR 0 1
39875: PPUSH
39876: EMPTY
39877: PPUSH
39878: CALL_OW 1
39882: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
39883: LD_ADDR_EXP 134
39887: PUSH
39888: LD_EXP 134
39892: PPUSH
39893: LD_VAR 0 1
39897: PPUSH
39898: EMPTY
39899: PPUSH
39900: CALL_OW 1
39904: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
39905: LD_ADDR_EXP 135
39909: PUSH
39910: LD_EXP 135
39914: PPUSH
39915: LD_VAR 0 1
39919: PPUSH
39920: EMPTY
39921: PPUSH
39922: CALL_OW 1
39926: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
39927: LD_ADDR_EXP 136
39931: PUSH
39932: LD_EXP 136
39936: PPUSH
39937: LD_VAR 0 1
39941: PPUSH
39942: EMPTY
39943: PPUSH
39944: CALL_OW 1
39948: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
39949: LD_ADDR_EXP 137
39953: PUSH
39954: LD_EXP 137
39958: PPUSH
39959: LD_VAR 0 1
39963: PPUSH
39964: EMPTY
39965: PPUSH
39966: CALL_OW 1
39970: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
39971: LD_ADDR_EXP 138
39975: PUSH
39976: LD_EXP 138
39980: PPUSH
39981: LD_VAR 0 1
39985: PPUSH
39986: EMPTY
39987: PPUSH
39988: CALL_OW 1
39992: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
39993: LD_ADDR_EXP 139
39997: PUSH
39998: LD_EXP 139
40002: PPUSH
40003: LD_VAR 0 1
40007: PPUSH
40008: EMPTY
40009: PPUSH
40010: CALL_OW 1
40014: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
40015: LD_ADDR_EXP 140
40019: PUSH
40020: LD_EXP 140
40024: PPUSH
40025: LD_VAR 0 1
40029: PPUSH
40030: EMPTY
40031: PPUSH
40032: CALL_OW 1
40036: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
40037: LD_ADDR_EXP 141
40041: PUSH
40042: LD_EXP 141
40046: PPUSH
40047: LD_VAR 0 1
40051: PPUSH
40052: EMPTY
40053: PPUSH
40054: CALL_OW 1
40058: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
40059: LD_ADDR_EXP 142
40063: PUSH
40064: LD_EXP 142
40068: PPUSH
40069: LD_VAR 0 1
40073: PPUSH
40074: EMPTY
40075: PPUSH
40076: CALL_OW 1
40080: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
40081: LD_ADDR_EXP 143
40085: PUSH
40086: LD_EXP 143
40090: PPUSH
40091: LD_VAR 0 1
40095: PPUSH
40096: EMPTY
40097: PPUSH
40098: CALL_OW 1
40102: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
40103: LD_ADDR_EXP 144
40107: PUSH
40108: LD_EXP 144
40112: PPUSH
40113: LD_VAR 0 1
40117: PPUSH
40118: LD_INT 0
40120: PPUSH
40121: CALL_OW 1
40125: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
40126: LD_ADDR_EXP 145
40130: PUSH
40131: LD_EXP 145
40135: PPUSH
40136: LD_VAR 0 1
40140: PPUSH
40141: LD_INT 0
40143: PPUSH
40144: CALL_OW 1
40148: ST_TO_ADDR
// end ;
40149: LD_VAR 0 2
40153: RET
// export function MC_Add ( side , units ) ; var base ; begin
40154: LD_INT 0
40156: PPUSH
40157: PPUSH
// base := mc_bases + 1 ;
40158: LD_ADDR_VAR 0 4
40162: PUSH
40163: LD_EXP 102
40167: PUSH
40168: LD_INT 1
40170: PLUS
40171: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
40172: LD_ADDR_EXP 128
40176: PUSH
40177: LD_EXP 128
40181: PPUSH
40182: LD_VAR 0 4
40186: PPUSH
40187: LD_VAR 0 1
40191: PPUSH
40192: CALL_OW 1
40196: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
40197: LD_ADDR_EXP 102
40201: PUSH
40202: LD_EXP 102
40206: PPUSH
40207: LD_VAR 0 4
40211: PPUSH
40212: LD_VAR 0 2
40216: PPUSH
40217: CALL_OW 1
40221: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
40222: LD_ADDR_EXP 103
40226: PUSH
40227: LD_EXP 103
40231: PPUSH
40232: LD_VAR 0 4
40236: PPUSH
40237: EMPTY
40238: PPUSH
40239: CALL_OW 1
40243: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
40244: LD_ADDR_EXP 104
40248: PUSH
40249: LD_EXP 104
40253: PPUSH
40254: LD_VAR 0 4
40258: PPUSH
40259: EMPTY
40260: PPUSH
40261: CALL_OW 1
40265: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
40266: LD_ADDR_EXP 105
40270: PUSH
40271: LD_EXP 105
40275: PPUSH
40276: LD_VAR 0 4
40280: PPUSH
40281: EMPTY
40282: PPUSH
40283: CALL_OW 1
40287: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
40288: LD_ADDR_EXP 106
40292: PUSH
40293: LD_EXP 106
40297: PPUSH
40298: LD_VAR 0 4
40302: PPUSH
40303: EMPTY
40304: PPUSH
40305: CALL_OW 1
40309: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
40310: LD_ADDR_EXP 107
40314: PUSH
40315: LD_EXP 107
40319: PPUSH
40320: LD_VAR 0 4
40324: PPUSH
40325: EMPTY
40326: PPUSH
40327: CALL_OW 1
40331: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
40332: LD_ADDR_EXP 108
40336: PUSH
40337: LD_EXP 108
40341: PPUSH
40342: LD_VAR 0 4
40346: PPUSH
40347: EMPTY
40348: PPUSH
40349: CALL_OW 1
40353: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
40354: LD_ADDR_EXP 109
40358: PUSH
40359: LD_EXP 109
40363: PPUSH
40364: LD_VAR 0 4
40368: PPUSH
40369: EMPTY
40370: PPUSH
40371: CALL_OW 1
40375: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
40376: LD_ADDR_EXP 110
40380: PUSH
40381: LD_EXP 110
40385: PPUSH
40386: LD_VAR 0 4
40390: PPUSH
40391: EMPTY
40392: PPUSH
40393: CALL_OW 1
40397: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
40398: LD_ADDR_EXP 111
40402: PUSH
40403: LD_EXP 111
40407: PPUSH
40408: LD_VAR 0 4
40412: PPUSH
40413: EMPTY
40414: PPUSH
40415: CALL_OW 1
40419: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
40420: LD_ADDR_EXP 112
40424: PUSH
40425: LD_EXP 112
40429: PPUSH
40430: LD_VAR 0 4
40434: PPUSH
40435: EMPTY
40436: PPUSH
40437: CALL_OW 1
40441: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
40442: LD_ADDR_EXP 113
40446: PUSH
40447: LD_EXP 113
40451: PPUSH
40452: LD_VAR 0 4
40456: PPUSH
40457: LD_INT 0
40459: PPUSH
40460: CALL_OW 1
40464: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
40465: LD_ADDR_EXP 114
40469: PUSH
40470: LD_EXP 114
40474: PPUSH
40475: LD_VAR 0 4
40479: PPUSH
40480: EMPTY
40481: PPUSH
40482: CALL_OW 1
40486: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
40487: LD_ADDR_EXP 115
40491: PUSH
40492: LD_EXP 115
40496: PPUSH
40497: LD_VAR 0 4
40501: PPUSH
40502: EMPTY
40503: PPUSH
40504: CALL_OW 1
40508: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
40509: LD_ADDR_EXP 116
40513: PUSH
40514: LD_EXP 116
40518: PPUSH
40519: LD_VAR 0 4
40523: PPUSH
40524: EMPTY
40525: PPUSH
40526: CALL_OW 1
40530: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
40531: LD_ADDR_EXP 117
40535: PUSH
40536: LD_EXP 117
40540: PPUSH
40541: LD_VAR 0 4
40545: PPUSH
40546: EMPTY
40547: PPUSH
40548: CALL_OW 1
40552: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
40553: LD_ADDR_EXP 118
40557: PUSH
40558: LD_EXP 118
40562: PPUSH
40563: LD_VAR 0 4
40567: PPUSH
40568: EMPTY
40569: PPUSH
40570: CALL_OW 1
40574: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
40575: LD_ADDR_EXP 119
40579: PUSH
40580: LD_EXP 119
40584: PPUSH
40585: LD_VAR 0 4
40589: PPUSH
40590: EMPTY
40591: PPUSH
40592: CALL_OW 1
40596: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
40597: LD_ADDR_EXP 120
40601: PUSH
40602: LD_EXP 120
40606: PPUSH
40607: LD_VAR 0 4
40611: PPUSH
40612: EMPTY
40613: PPUSH
40614: CALL_OW 1
40618: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
40619: LD_ADDR_EXP 121
40623: PUSH
40624: LD_EXP 121
40628: PPUSH
40629: LD_VAR 0 4
40633: PPUSH
40634: EMPTY
40635: PPUSH
40636: CALL_OW 1
40640: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
40641: LD_ADDR_EXP 122
40645: PUSH
40646: LD_EXP 122
40650: PPUSH
40651: LD_VAR 0 4
40655: PPUSH
40656: EMPTY
40657: PPUSH
40658: CALL_OW 1
40662: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
40663: LD_ADDR_EXP 123
40667: PUSH
40668: LD_EXP 123
40672: PPUSH
40673: LD_VAR 0 4
40677: PPUSH
40678: EMPTY
40679: PPUSH
40680: CALL_OW 1
40684: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
40685: LD_ADDR_EXP 124
40689: PUSH
40690: LD_EXP 124
40694: PPUSH
40695: LD_VAR 0 4
40699: PPUSH
40700: EMPTY
40701: PPUSH
40702: CALL_OW 1
40706: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
40707: LD_ADDR_EXP 125
40711: PUSH
40712: LD_EXP 125
40716: PPUSH
40717: LD_VAR 0 4
40721: PPUSH
40722: EMPTY
40723: PPUSH
40724: CALL_OW 1
40728: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
40729: LD_ADDR_EXP 126
40733: PUSH
40734: LD_EXP 126
40738: PPUSH
40739: LD_VAR 0 4
40743: PPUSH
40744: EMPTY
40745: PPUSH
40746: CALL_OW 1
40750: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
40751: LD_ADDR_EXP 127
40755: PUSH
40756: LD_EXP 127
40760: PPUSH
40761: LD_VAR 0 4
40765: PPUSH
40766: EMPTY
40767: PPUSH
40768: CALL_OW 1
40772: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
40773: LD_ADDR_EXP 129
40777: PUSH
40778: LD_EXP 129
40782: PPUSH
40783: LD_VAR 0 4
40787: PPUSH
40788: EMPTY
40789: PPUSH
40790: CALL_OW 1
40794: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
40795: LD_ADDR_EXP 131
40799: PUSH
40800: LD_EXP 131
40804: PPUSH
40805: LD_VAR 0 4
40809: PPUSH
40810: EMPTY
40811: PPUSH
40812: CALL_OW 1
40816: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
40817: LD_ADDR_EXP 132
40821: PUSH
40822: LD_EXP 132
40826: PPUSH
40827: LD_VAR 0 4
40831: PPUSH
40832: EMPTY
40833: PPUSH
40834: CALL_OW 1
40838: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
40839: LD_ADDR_EXP 133
40843: PUSH
40844: LD_EXP 133
40848: PPUSH
40849: LD_VAR 0 4
40853: PPUSH
40854: EMPTY
40855: PPUSH
40856: CALL_OW 1
40860: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
40861: LD_ADDR_EXP 134
40865: PUSH
40866: LD_EXP 134
40870: PPUSH
40871: LD_VAR 0 4
40875: PPUSH
40876: EMPTY
40877: PPUSH
40878: CALL_OW 1
40882: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
40883: LD_ADDR_EXP 135
40887: PUSH
40888: LD_EXP 135
40892: PPUSH
40893: LD_VAR 0 4
40897: PPUSH
40898: EMPTY
40899: PPUSH
40900: CALL_OW 1
40904: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
40905: LD_ADDR_EXP 136
40909: PUSH
40910: LD_EXP 136
40914: PPUSH
40915: LD_VAR 0 4
40919: PPUSH
40920: EMPTY
40921: PPUSH
40922: CALL_OW 1
40926: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
40927: LD_ADDR_EXP 137
40931: PUSH
40932: LD_EXP 137
40936: PPUSH
40937: LD_VAR 0 4
40941: PPUSH
40942: EMPTY
40943: PPUSH
40944: CALL_OW 1
40948: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
40949: LD_ADDR_EXP 138
40953: PUSH
40954: LD_EXP 138
40958: PPUSH
40959: LD_VAR 0 4
40963: PPUSH
40964: EMPTY
40965: PPUSH
40966: CALL_OW 1
40970: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
40971: LD_ADDR_EXP 139
40975: PUSH
40976: LD_EXP 139
40980: PPUSH
40981: LD_VAR 0 4
40985: PPUSH
40986: EMPTY
40987: PPUSH
40988: CALL_OW 1
40992: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
40993: LD_ADDR_EXP 140
40997: PUSH
40998: LD_EXP 140
41002: PPUSH
41003: LD_VAR 0 4
41007: PPUSH
41008: EMPTY
41009: PPUSH
41010: CALL_OW 1
41014: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
41015: LD_ADDR_EXP 141
41019: PUSH
41020: LD_EXP 141
41024: PPUSH
41025: LD_VAR 0 4
41029: PPUSH
41030: EMPTY
41031: PPUSH
41032: CALL_OW 1
41036: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
41037: LD_ADDR_EXP 142
41041: PUSH
41042: LD_EXP 142
41046: PPUSH
41047: LD_VAR 0 4
41051: PPUSH
41052: EMPTY
41053: PPUSH
41054: CALL_OW 1
41058: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
41059: LD_ADDR_EXP 143
41063: PUSH
41064: LD_EXP 143
41068: PPUSH
41069: LD_VAR 0 4
41073: PPUSH
41074: EMPTY
41075: PPUSH
41076: CALL_OW 1
41080: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
41081: LD_ADDR_EXP 144
41085: PUSH
41086: LD_EXP 144
41090: PPUSH
41091: LD_VAR 0 4
41095: PPUSH
41096: LD_INT 0
41098: PPUSH
41099: CALL_OW 1
41103: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
41104: LD_ADDR_EXP 145
41108: PUSH
41109: LD_EXP 145
41113: PPUSH
41114: LD_VAR 0 4
41118: PPUSH
41119: LD_INT 0
41121: PPUSH
41122: CALL_OW 1
41126: ST_TO_ADDR
// result := base ;
41127: LD_ADDR_VAR 0 3
41131: PUSH
41132: LD_VAR 0 4
41136: ST_TO_ADDR
// end ;
41137: LD_VAR 0 3
41141: RET
// export function MC_Start ( ) ; var i ; begin
41142: LD_INT 0
41144: PPUSH
41145: PPUSH
// for i = 1 to mc_bases do
41146: LD_ADDR_VAR 0 2
41150: PUSH
41151: DOUBLE
41152: LD_INT 1
41154: DEC
41155: ST_TO_ADDR
41156: LD_EXP 102
41160: PUSH
41161: FOR_TO
41162: IFFALSE 42262
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
41164: LD_ADDR_EXP 102
41168: PUSH
41169: LD_EXP 102
41173: PPUSH
41174: LD_VAR 0 2
41178: PPUSH
41179: LD_EXP 102
41183: PUSH
41184: LD_VAR 0 2
41188: ARRAY
41189: PUSH
41190: LD_INT 0
41192: DIFF
41193: PPUSH
41194: CALL_OW 1
41198: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
41199: LD_ADDR_EXP 103
41203: PUSH
41204: LD_EXP 103
41208: PPUSH
41209: LD_VAR 0 2
41213: PPUSH
41214: EMPTY
41215: PPUSH
41216: CALL_OW 1
41220: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
41221: LD_ADDR_EXP 104
41225: PUSH
41226: LD_EXP 104
41230: PPUSH
41231: LD_VAR 0 2
41235: PPUSH
41236: EMPTY
41237: PPUSH
41238: CALL_OW 1
41242: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
41243: LD_ADDR_EXP 105
41247: PUSH
41248: LD_EXP 105
41252: PPUSH
41253: LD_VAR 0 2
41257: PPUSH
41258: EMPTY
41259: PPUSH
41260: CALL_OW 1
41264: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
41265: LD_ADDR_EXP 106
41269: PUSH
41270: LD_EXP 106
41274: PPUSH
41275: LD_VAR 0 2
41279: PPUSH
41280: EMPTY
41281: PUSH
41282: EMPTY
41283: PUSH
41284: EMPTY
41285: LIST
41286: LIST
41287: PPUSH
41288: CALL_OW 1
41292: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
41293: LD_ADDR_EXP 107
41297: PUSH
41298: LD_EXP 107
41302: PPUSH
41303: LD_VAR 0 2
41307: PPUSH
41308: EMPTY
41309: PPUSH
41310: CALL_OW 1
41314: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
41315: LD_ADDR_EXP 134
41319: PUSH
41320: LD_EXP 134
41324: PPUSH
41325: LD_VAR 0 2
41329: PPUSH
41330: EMPTY
41331: PPUSH
41332: CALL_OW 1
41336: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
41337: LD_ADDR_EXP 108
41341: PUSH
41342: LD_EXP 108
41346: PPUSH
41347: LD_VAR 0 2
41351: PPUSH
41352: EMPTY
41353: PPUSH
41354: CALL_OW 1
41358: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
41359: LD_ADDR_EXP 109
41363: PUSH
41364: LD_EXP 109
41368: PPUSH
41369: LD_VAR 0 2
41373: PPUSH
41374: EMPTY
41375: PPUSH
41376: CALL_OW 1
41380: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
41381: LD_ADDR_EXP 110
41385: PUSH
41386: LD_EXP 110
41390: PPUSH
41391: LD_VAR 0 2
41395: PPUSH
41396: LD_EXP 102
41400: PUSH
41401: LD_VAR 0 2
41405: ARRAY
41406: PPUSH
41407: LD_INT 2
41409: PUSH
41410: LD_INT 30
41412: PUSH
41413: LD_INT 32
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 30
41422: PUSH
41423: LD_INT 33
41425: PUSH
41426: EMPTY
41427: LIST
41428: LIST
41429: PUSH
41430: EMPTY
41431: LIST
41432: LIST
41433: LIST
41434: PPUSH
41435: CALL_OW 72
41439: PPUSH
41440: CALL_OW 1
41444: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
41445: LD_ADDR_EXP 111
41449: PUSH
41450: LD_EXP 111
41454: PPUSH
41455: LD_VAR 0 2
41459: PPUSH
41460: LD_EXP 102
41464: PUSH
41465: LD_VAR 0 2
41469: ARRAY
41470: PPUSH
41471: LD_INT 2
41473: PUSH
41474: LD_INT 30
41476: PUSH
41477: LD_INT 32
41479: PUSH
41480: EMPTY
41481: LIST
41482: LIST
41483: PUSH
41484: LD_INT 30
41486: PUSH
41487: LD_INT 31
41489: PUSH
41490: EMPTY
41491: LIST
41492: LIST
41493: PUSH
41494: EMPTY
41495: LIST
41496: LIST
41497: LIST
41498: PUSH
41499: LD_INT 58
41501: PUSH
41502: EMPTY
41503: LIST
41504: PUSH
41505: EMPTY
41506: LIST
41507: LIST
41508: PPUSH
41509: CALL_OW 72
41513: PPUSH
41514: CALL_OW 1
41518: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
41519: LD_ADDR_EXP 112
41523: PUSH
41524: LD_EXP 112
41528: PPUSH
41529: LD_VAR 0 2
41533: PPUSH
41534: EMPTY
41535: PPUSH
41536: CALL_OW 1
41540: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
41541: LD_ADDR_EXP 116
41545: PUSH
41546: LD_EXP 116
41550: PPUSH
41551: LD_VAR 0 2
41555: PPUSH
41556: EMPTY
41557: PPUSH
41558: CALL_OW 1
41562: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
41563: LD_ADDR_EXP 115
41567: PUSH
41568: LD_EXP 115
41572: PPUSH
41573: LD_VAR 0 2
41577: PPUSH
41578: EMPTY
41579: PPUSH
41580: CALL_OW 1
41584: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
41585: LD_ADDR_EXP 117
41589: PUSH
41590: LD_EXP 117
41594: PPUSH
41595: LD_VAR 0 2
41599: PPUSH
41600: EMPTY
41601: PPUSH
41602: CALL_OW 1
41606: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
41607: LD_ADDR_EXP 118
41611: PUSH
41612: LD_EXP 118
41616: PPUSH
41617: LD_VAR 0 2
41621: PPUSH
41622: EMPTY
41623: PPUSH
41624: CALL_OW 1
41628: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
41629: LD_ADDR_EXP 119
41633: PUSH
41634: LD_EXP 119
41638: PPUSH
41639: LD_VAR 0 2
41643: PPUSH
41644: EMPTY
41645: PPUSH
41646: CALL_OW 1
41650: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
41651: LD_ADDR_EXP 120
41655: PUSH
41656: LD_EXP 120
41660: PPUSH
41661: LD_VAR 0 2
41665: PPUSH
41666: EMPTY
41667: PPUSH
41668: CALL_OW 1
41672: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
41673: LD_ADDR_EXP 121
41677: PUSH
41678: LD_EXP 121
41682: PPUSH
41683: LD_VAR 0 2
41687: PPUSH
41688: EMPTY
41689: PPUSH
41690: CALL_OW 1
41694: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
41695: LD_ADDR_EXP 122
41699: PUSH
41700: LD_EXP 122
41704: PPUSH
41705: LD_VAR 0 2
41709: PPUSH
41710: EMPTY
41711: PPUSH
41712: CALL_OW 1
41716: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
41717: LD_ADDR_EXP 123
41721: PUSH
41722: LD_EXP 123
41726: PPUSH
41727: LD_VAR 0 2
41731: PPUSH
41732: EMPTY
41733: PPUSH
41734: CALL_OW 1
41738: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
41739: LD_ADDR_EXP 124
41743: PUSH
41744: LD_EXP 124
41748: PPUSH
41749: LD_VAR 0 2
41753: PPUSH
41754: EMPTY
41755: PPUSH
41756: CALL_OW 1
41760: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
41761: LD_ADDR_EXP 113
41765: PUSH
41766: LD_EXP 113
41770: PPUSH
41771: LD_VAR 0 2
41775: PPUSH
41776: LD_INT 0
41778: PPUSH
41779: CALL_OW 1
41783: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
41784: LD_ADDR_EXP 126
41788: PUSH
41789: LD_EXP 126
41793: PPUSH
41794: LD_VAR 0 2
41798: PPUSH
41799: LD_INT 0
41801: PPUSH
41802: CALL_OW 1
41806: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
41807: LD_ADDR_EXP 114
41811: PUSH
41812: LD_EXP 114
41816: PPUSH
41817: LD_VAR 0 2
41821: PPUSH
41822: EMPTY
41823: PPUSH
41824: CALL_OW 1
41828: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
41829: LD_ADDR_EXP 125
41833: PUSH
41834: LD_EXP 125
41838: PPUSH
41839: LD_VAR 0 2
41843: PPUSH
41844: LD_INT 0
41846: PPUSH
41847: CALL_OW 1
41851: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
41852: LD_ADDR_EXP 127
41856: PUSH
41857: LD_EXP 127
41861: PPUSH
41862: LD_VAR 0 2
41866: PPUSH
41867: EMPTY
41868: PPUSH
41869: CALL_OW 1
41873: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
41874: LD_ADDR_EXP 130
41878: PUSH
41879: LD_EXP 130
41883: PPUSH
41884: LD_VAR 0 2
41888: PPUSH
41889: LD_INT 0
41891: PPUSH
41892: CALL_OW 1
41896: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
41897: LD_ADDR_EXP 131
41901: PUSH
41902: LD_EXP 131
41906: PPUSH
41907: LD_VAR 0 2
41911: PPUSH
41912: EMPTY
41913: PPUSH
41914: CALL_OW 1
41918: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
41919: LD_ADDR_EXP 132
41923: PUSH
41924: LD_EXP 132
41928: PPUSH
41929: LD_VAR 0 2
41933: PPUSH
41934: EMPTY
41935: PPUSH
41936: CALL_OW 1
41940: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
41941: LD_ADDR_EXP 133
41945: PUSH
41946: LD_EXP 133
41950: PPUSH
41951: LD_VAR 0 2
41955: PPUSH
41956: EMPTY
41957: PPUSH
41958: CALL_OW 1
41962: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
41963: LD_ADDR_EXP 135
41967: PUSH
41968: LD_EXP 135
41972: PPUSH
41973: LD_VAR 0 2
41977: PPUSH
41978: LD_EXP 102
41982: PUSH
41983: LD_VAR 0 2
41987: ARRAY
41988: PPUSH
41989: LD_INT 2
41991: PUSH
41992: LD_INT 30
41994: PUSH
41995: LD_INT 6
41997: PUSH
41998: EMPTY
41999: LIST
42000: LIST
42001: PUSH
42002: LD_INT 30
42004: PUSH
42005: LD_INT 7
42007: PUSH
42008: EMPTY
42009: LIST
42010: LIST
42011: PUSH
42012: LD_INT 30
42014: PUSH
42015: LD_INT 8
42017: PUSH
42018: EMPTY
42019: LIST
42020: LIST
42021: PUSH
42022: EMPTY
42023: LIST
42024: LIST
42025: LIST
42026: LIST
42027: PPUSH
42028: CALL_OW 72
42032: PPUSH
42033: CALL_OW 1
42037: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
42038: LD_ADDR_EXP 136
42042: PUSH
42043: LD_EXP 136
42047: PPUSH
42048: LD_VAR 0 2
42052: PPUSH
42053: EMPTY
42054: PPUSH
42055: CALL_OW 1
42059: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
42060: LD_ADDR_EXP 137
42064: PUSH
42065: LD_EXP 137
42069: PPUSH
42070: LD_VAR 0 2
42074: PPUSH
42075: EMPTY
42076: PPUSH
42077: CALL_OW 1
42081: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
42082: LD_ADDR_EXP 138
42086: PUSH
42087: LD_EXP 138
42091: PPUSH
42092: LD_VAR 0 2
42096: PPUSH
42097: EMPTY
42098: PPUSH
42099: CALL_OW 1
42103: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
42104: LD_ADDR_EXP 139
42108: PUSH
42109: LD_EXP 139
42113: PPUSH
42114: LD_VAR 0 2
42118: PPUSH
42119: EMPTY
42120: PPUSH
42121: CALL_OW 1
42125: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42126: LD_ADDR_EXP 140
42130: PUSH
42131: LD_EXP 140
42135: PPUSH
42136: LD_VAR 0 2
42140: PPUSH
42141: EMPTY
42142: PPUSH
42143: CALL_OW 1
42147: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
42148: LD_ADDR_EXP 141
42152: PUSH
42153: LD_EXP 141
42157: PPUSH
42158: LD_VAR 0 2
42162: PPUSH
42163: EMPTY
42164: PPUSH
42165: CALL_OW 1
42169: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
42170: LD_ADDR_EXP 142
42174: PUSH
42175: LD_EXP 142
42179: PPUSH
42180: LD_VAR 0 2
42184: PPUSH
42185: EMPTY
42186: PPUSH
42187: CALL_OW 1
42191: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
42192: LD_ADDR_EXP 143
42196: PUSH
42197: LD_EXP 143
42201: PPUSH
42202: LD_VAR 0 2
42206: PPUSH
42207: EMPTY
42208: PPUSH
42209: CALL_OW 1
42213: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
42214: LD_ADDR_EXP 144
42218: PUSH
42219: LD_EXP 144
42223: PPUSH
42224: LD_VAR 0 2
42228: PPUSH
42229: LD_INT 0
42231: PPUSH
42232: CALL_OW 1
42236: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
42237: LD_ADDR_EXP 145
42241: PUSH
42242: LD_EXP 145
42246: PPUSH
42247: LD_VAR 0 2
42251: PPUSH
42252: LD_INT 0
42254: PPUSH
42255: CALL_OW 1
42259: ST_TO_ADDR
// end ;
42260: GO 41161
42262: POP
42263: POP
// MC_InitSides ( ) ;
42264: CALL 42550 0 0
// MC_InitResearch ( ) ;
42268: CALL 42289 0 0
// CustomInitMacro ( ) ;
42272: CALL 475 0 0
// skirmish := true ;
42276: LD_ADDR_EXP 100
42280: PUSH
42281: LD_INT 1
42283: ST_TO_ADDR
// end ;
42284: LD_VAR 0 1
42288: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
42289: LD_INT 0
42291: PPUSH
42292: PPUSH
42293: PPUSH
42294: PPUSH
42295: PPUSH
42296: PPUSH
// if not mc_bases then
42297: LD_EXP 102
42301: NOT
42302: IFFALSE 42306
// exit ;
42304: GO 42545
// for i = 1 to 8 do
42306: LD_ADDR_VAR 0 2
42310: PUSH
42311: DOUBLE
42312: LD_INT 1
42314: DEC
42315: ST_TO_ADDR
42316: LD_INT 8
42318: PUSH
42319: FOR_TO
42320: IFFALSE 42346
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
42322: LD_ADDR_EXP 129
42326: PUSH
42327: LD_EXP 129
42331: PPUSH
42332: LD_VAR 0 2
42336: PPUSH
42337: EMPTY
42338: PPUSH
42339: CALL_OW 1
42343: ST_TO_ADDR
42344: GO 42319
42346: POP
42347: POP
// tmp := [ ] ;
42348: LD_ADDR_VAR 0 5
42352: PUSH
42353: EMPTY
42354: ST_TO_ADDR
// for i = 1 to mc_sides do
42355: LD_ADDR_VAR 0 2
42359: PUSH
42360: DOUBLE
42361: LD_INT 1
42363: DEC
42364: ST_TO_ADDR
42365: LD_EXP 128
42369: PUSH
42370: FOR_TO
42371: IFFALSE 42429
// if not mc_sides [ i ] in tmp then
42373: LD_EXP 128
42377: PUSH
42378: LD_VAR 0 2
42382: ARRAY
42383: PUSH
42384: LD_VAR 0 5
42388: IN
42389: NOT
42390: IFFALSE 42427
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
42392: LD_ADDR_VAR 0 5
42396: PUSH
42397: LD_VAR 0 5
42401: PPUSH
42402: LD_VAR 0 5
42406: PUSH
42407: LD_INT 1
42409: PLUS
42410: PPUSH
42411: LD_EXP 128
42415: PUSH
42416: LD_VAR 0 2
42420: ARRAY
42421: PPUSH
42422: CALL_OW 2
42426: ST_TO_ADDR
42427: GO 42370
42429: POP
42430: POP
// if not tmp then
42431: LD_VAR 0 5
42435: NOT
42436: IFFALSE 42440
// exit ;
42438: GO 42545
// for j in tmp do
42440: LD_ADDR_VAR 0 3
42444: PUSH
42445: LD_VAR 0 5
42449: PUSH
42450: FOR_IN
42451: IFFALSE 42543
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
42453: LD_ADDR_VAR 0 6
42457: PUSH
42458: LD_INT 22
42460: PUSH
42461: LD_VAR 0 3
42465: PUSH
42466: EMPTY
42467: LIST
42468: LIST
42469: PPUSH
42470: CALL_OW 69
42474: ST_TO_ADDR
// if not un then
42475: LD_VAR 0 6
42479: NOT
42480: IFFALSE 42484
// continue ;
42482: GO 42450
// nation := GetNation ( un [ 1 ] ) ;
42484: LD_ADDR_VAR 0 4
42488: PUSH
42489: LD_VAR 0 6
42493: PUSH
42494: LD_INT 1
42496: ARRAY
42497: PPUSH
42498: CALL_OW 248
42502: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
42503: LD_ADDR_EXP 129
42507: PUSH
42508: LD_EXP 129
42512: PPUSH
42513: LD_VAR 0 3
42517: PPUSH
42518: LD_VAR 0 3
42522: PPUSH
42523: LD_VAR 0 4
42527: PPUSH
42528: LD_INT 1
42530: PPUSH
42531: CALL 69733 0 3
42535: PPUSH
42536: CALL_OW 1
42540: ST_TO_ADDR
// end ;
42541: GO 42450
42543: POP
42544: POP
// end ;
42545: LD_VAR 0 1
42549: RET
// export function MC_InitSides ( ) ; var i ; begin
42550: LD_INT 0
42552: PPUSH
42553: PPUSH
// if not mc_bases then
42554: LD_EXP 102
42558: NOT
42559: IFFALSE 42563
// exit ;
42561: GO 42637
// for i = 1 to mc_bases do
42563: LD_ADDR_VAR 0 2
42567: PUSH
42568: DOUBLE
42569: LD_INT 1
42571: DEC
42572: ST_TO_ADDR
42573: LD_EXP 102
42577: PUSH
42578: FOR_TO
42579: IFFALSE 42635
// if mc_bases [ i ] then
42581: LD_EXP 102
42585: PUSH
42586: LD_VAR 0 2
42590: ARRAY
42591: IFFALSE 42633
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
42593: LD_ADDR_EXP 128
42597: PUSH
42598: LD_EXP 128
42602: PPUSH
42603: LD_VAR 0 2
42607: PPUSH
42608: LD_EXP 102
42612: PUSH
42613: LD_VAR 0 2
42617: ARRAY
42618: PUSH
42619: LD_INT 1
42621: ARRAY
42622: PPUSH
42623: CALL_OW 255
42627: PPUSH
42628: CALL_OW 1
42632: ST_TO_ADDR
42633: GO 42578
42635: POP
42636: POP
// end ;
42637: LD_VAR 0 1
42641: RET
// every 0 0$03 trigger skirmish do
42642: LD_EXP 100
42646: IFFALSE 42800
42648: GO 42650
42650: DISABLE
// begin enable ;
42651: ENABLE
// MC_CheckBuildings ( ) ;
42652: CALL 47312 0 0
// MC_CheckPeopleLife ( ) ;
42656: CALL 47473 0 0
// RaiseSailEvent ( 100 ) ;
42660: LD_INT 100
42662: PPUSH
42663: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
42667: LD_INT 103
42669: PPUSH
42670: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
42674: LD_INT 104
42676: PPUSH
42677: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
42681: LD_INT 105
42683: PPUSH
42684: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
42688: LD_INT 106
42690: PPUSH
42691: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
42695: LD_INT 107
42697: PPUSH
42698: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
42702: LD_INT 108
42704: PPUSH
42705: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
42709: LD_INT 109
42711: PPUSH
42712: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
42716: LD_INT 110
42718: PPUSH
42719: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
42723: LD_INT 111
42725: PPUSH
42726: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
42730: LD_INT 112
42732: PPUSH
42733: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
42737: LD_INT 113
42739: PPUSH
42740: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
42744: LD_INT 120
42746: PPUSH
42747: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
42751: LD_INT 121
42753: PPUSH
42754: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
42758: LD_INT 122
42760: PPUSH
42761: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
42765: LD_INT 123
42767: PPUSH
42768: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
42772: LD_INT 124
42774: PPUSH
42775: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
42779: LD_INT 125
42781: PPUSH
42782: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
42786: LD_INT 126
42788: PPUSH
42789: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
42793: LD_INT 200
42795: PPUSH
42796: CALL_OW 427
// end ;
42800: END
// on SailEvent ( event ) do begin if event < 100 then
42801: LD_VAR 0 1
42805: PUSH
42806: LD_INT 100
42808: LESS
42809: IFFALSE 42820
// CustomEvent ( event ) ;
42811: LD_VAR 0 1
42815: PPUSH
42816: CALL 37176 0 1
// if event = 100 then
42820: LD_VAR 0 1
42824: PUSH
42825: LD_INT 100
42827: EQUAL
42828: IFFALSE 42834
// MC_ClassManager ( ) ;
42830: CALL 43226 0 0
// if event = 101 then
42834: LD_VAR 0 1
42838: PUSH
42839: LD_INT 101
42841: EQUAL
42842: IFFALSE 42848
// MC_RepairBuildings ( ) ;
42844: CALL 48058 0 0
// if event = 102 then
42848: LD_VAR 0 1
42852: PUSH
42853: LD_INT 102
42855: EQUAL
42856: IFFALSE 42862
// MC_Heal ( ) ;
42858: CALL 48993 0 0
// if event = 103 then
42862: LD_VAR 0 1
42866: PUSH
42867: LD_INT 103
42869: EQUAL
42870: IFFALSE 42876
// MC_Build ( ) ;
42872: CALL 49415 0 0
// if event = 104 then
42876: LD_VAR 0 1
42880: PUSH
42881: LD_INT 104
42883: EQUAL
42884: IFFALSE 42890
// MC_TurretWeapon ( ) ;
42886: CALL 51049 0 0
// if event = 105 then
42890: LD_VAR 0 1
42894: PUSH
42895: LD_INT 105
42897: EQUAL
42898: IFFALSE 42904
// MC_BuildUpgrade ( ) ;
42900: CALL 50600 0 0
// if event = 106 then
42904: LD_VAR 0 1
42908: PUSH
42909: LD_INT 106
42911: EQUAL
42912: IFFALSE 42918
// MC_PlantMines ( ) ;
42914: CALL 51479 0 0
// if event = 107 then
42918: LD_VAR 0 1
42922: PUSH
42923: LD_INT 107
42925: EQUAL
42926: IFFALSE 42932
// MC_CollectCrates ( ) ;
42928: CALL 52277 0 0
// if event = 108 then
42932: LD_VAR 0 1
42936: PUSH
42937: LD_INT 108
42939: EQUAL
42940: IFFALSE 42946
// MC_LinkRemoteControl ( ) ;
42942: CALL 54127 0 0
// if event = 109 then
42946: LD_VAR 0 1
42950: PUSH
42951: LD_INT 109
42953: EQUAL
42954: IFFALSE 42960
// MC_ProduceVehicle ( ) ;
42956: CALL 54308 0 0
// if event = 110 then
42960: LD_VAR 0 1
42964: PUSH
42965: LD_INT 110
42967: EQUAL
42968: IFFALSE 42974
// MC_SendAttack ( ) ;
42970: CALL 54774 0 0
// if event = 111 then
42974: LD_VAR 0 1
42978: PUSH
42979: LD_INT 111
42981: EQUAL
42982: IFFALSE 42988
// MC_Defend ( ) ;
42984: CALL 54882 0 0
// if event = 112 then
42988: LD_VAR 0 1
42992: PUSH
42993: LD_INT 112
42995: EQUAL
42996: IFFALSE 43002
// MC_Research ( ) ;
42998: CALL 55762 0 0
// if event = 113 then
43002: LD_VAR 0 1
43006: PUSH
43007: LD_INT 113
43009: EQUAL
43010: IFFALSE 43016
// MC_MinesTrigger ( ) ;
43012: CALL 56876 0 0
// if event = 120 then
43016: LD_VAR 0 1
43020: PUSH
43021: LD_INT 120
43023: EQUAL
43024: IFFALSE 43030
// MC_RepairVehicle ( ) ;
43026: CALL 56975 0 0
// if event = 121 then
43030: LD_VAR 0 1
43034: PUSH
43035: LD_INT 121
43037: EQUAL
43038: IFFALSE 43044
// MC_TameApe ( ) ;
43040: CALL 57744 0 0
// if event = 122 then
43044: LD_VAR 0 1
43048: PUSH
43049: LD_INT 122
43051: EQUAL
43052: IFFALSE 43058
// MC_ChangeApeClass ( ) ;
43054: CALL 58573 0 0
// if event = 123 then
43058: LD_VAR 0 1
43062: PUSH
43063: LD_INT 123
43065: EQUAL
43066: IFFALSE 43072
// MC_Bazooka ( ) ;
43068: CALL 59223 0 0
// if event = 124 then
43072: LD_VAR 0 1
43076: PUSH
43077: LD_INT 124
43079: EQUAL
43080: IFFALSE 43086
// MC_TeleportExit ( ) ;
43082: CALL 59421 0 0
// if event = 125 then
43086: LD_VAR 0 1
43090: PUSH
43091: LD_INT 125
43093: EQUAL
43094: IFFALSE 43100
// MC_Deposits ( ) ;
43096: CALL 60068 0 0
// if event = 126 then
43100: LD_VAR 0 1
43104: PUSH
43105: LD_INT 126
43107: EQUAL
43108: IFFALSE 43114
// MC_RemoteDriver ( ) ;
43110: CALL 60693 0 0
// if event = 200 then
43114: LD_VAR 0 1
43118: PUSH
43119: LD_INT 200
43121: EQUAL
43122: IFFALSE 43128
// MC_Idle ( ) ;
43124: CALL 62600 0 0
// end ;
43128: PPOPN 1
43130: END
// export function MC_Reset ( base , tag ) ; var i ; begin
43131: LD_INT 0
43133: PPUSH
43134: PPUSH
// if not mc_bases [ base ] or not tag then
43135: LD_EXP 102
43139: PUSH
43140: LD_VAR 0 1
43144: ARRAY
43145: NOT
43146: PUSH
43147: LD_VAR 0 2
43151: NOT
43152: OR
43153: IFFALSE 43157
// exit ;
43155: GO 43221
// for i in mc_bases [ base ] union mc_ape [ base ] do
43157: LD_ADDR_VAR 0 4
43161: PUSH
43162: LD_EXP 102
43166: PUSH
43167: LD_VAR 0 1
43171: ARRAY
43172: PUSH
43173: LD_EXP 131
43177: PUSH
43178: LD_VAR 0 1
43182: ARRAY
43183: UNION
43184: PUSH
43185: FOR_IN
43186: IFFALSE 43219
// if GetTag ( i ) = tag then
43188: LD_VAR 0 4
43192: PPUSH
43193: CALL_OW 110
43197: PUSH
43198: LD_VAR 0 2
43202: EQUAL
43203: IFFALSE 43217
// SetTag ( i , 0 ) ;
43205: LD_VAR 0 4
43209: PPUSH
43210: LD_INT 0
43212: PPUSH
43213: CALL_OW 109
43217: GO 43185
43219: POP
43220: POP
// end ;
43221: LD_VAR 0 3
43225: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
43226: LD_INT 0
43228: PPUSH
43229: PPUSH
43230: PPUSH
43231: PPUSH
43232: PPUSH
43233: PPUSH
43234: PPUSH
43235: PPUSH
// if not mc_bases then
43236: LD_EXP 102
43240: NOT
43241: IFFALSE 43245
// exit ;
43243: GO 43694
// for i = 1 to mc_bases do
43245: LD_ADDR_VAR 0 2
43249: PUSH
43250: DOUBLE
43251: LD_INT 1
43253: DEC
43254: ST_TO_ADDR
43255: LD_EXP 102
43259: PUSH
43260: FOR_TO
43261: IFFALSE 43692
// begin tmp := MC_ClassCheckReq ( i ) ;
43263: LD_ADDR_VAR 0 4
43267: PUSH
43268: LD_VAR 0 2
43272: PPUSH
43273: CALL 43699 0 1
43277: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
43278: LD_ADDR_EXP 143
43282: PUSH
43283: LD_EXP 143
43287: PPUSH
43288: LD_VAR 0 2
43292: PPUSH
43293: LD_VAR 0 4
43297: PPUSH
43298: CALL_OW 1
43302: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
43303: LD_ADDR_VAR 0 6
43307: PUSH
43308: LD_EXP 102
43312: PUSH
43313: LD_VAR 0 2
43317: ARRAY
43318: PPUSH
43319: LD_INT 2
43321: PUSH
43322: LD_INT 30
43324: PUSH
43325: LD_INT 4
43327: PUSH
43328: EMPTY
43329: LIST
43330: LIST
43331: PUSH
43332: LD_INT 30
43334: PUSH
43335: LD_INT 5
43337: PUSH
43338: EMPTY
43339: LIST
43340: LIST
43341: PUSH
43342: EMPTY
43343: LIST
43344: LIST
43345: LIST
43346: PPUSH
43347: CALL_OW 72
43351: PUSH
43352: LD_EXP 102
43356: PUSH
43357: LD_VAR 0 2
43361: ARRAY
43362: PPUSH
43363: LD_INT 2
43365: PUSH
43366: LD_INT 30
43368: PUSH
43369: LD_INT 0
43371: PUSH
43372: EMPTY
43373: LIST
43374: LIST
43375: PUSH
43376: LD_INT 30
43378: PUSH
43379: LD_INT 1
43381: PUSH
43382: EMPTY
43383: LIST
43384: LIST
43385: PUSH
43386: EMPTY
43387: LIST
43388: LIST
43389: LIST
43390: PPUSH
43391: CALL_OW 72
43395: PUSH
43396: LD_EXP 102
43400: PUSH
43401: LD_VAR 0 2
43405: ARRAY
43406: PPUSH
43407: LD_INT 30
43409: PUSH
43410: LD_INT 3
43412: PUSH
43413: EMPTY
43414: LIST
43415: LIST
43416: PPUSH
43417: CALL_OW 72
43421: PUSH
43422: LD_EXP 102
43426: PUSH
43427: LD_VAR 0 2
43431: ARRAY
43432: PPUSH
43433: LD_INT 2
43435: PUSH
43436: LD_INT 30
43438: PUSH
43439: LD_INT 6
43441: PUSH
43442: EMPTY
43443: LIST
43444: LIST
43445: PUSH
43446: LD_INT 30
43448: PUSH
43449: LD_INT 7
43451: PUSH
43452: EMPTY
43453: LIST
43454: LIST
43455: PUSH
43456: LD_INT 30
43458: PUSH
43459: LD_INT 8
43461: PUSH
43462: EMPTY
43463: LIST
43464: LIST
43465: PUSH
43466: EMPTY
43467: LIST
43468: LIST
43469: LIST
43470: LIST
43471: PPUSH
43472: CALL_OW 72
43476: PUSH
43477: EMPTY
43478: LIST
43479: LIST
43480: LIST
43481: LIST
43482: ST_TO_ADDR
// for j := 1 to 4 do
43483: LD_ADDR_VAR 0 3
43487: PUSH
43488: DOUBLE
43489: LD_INT 1
43491: DEC
43492: ST_TO_ADDR
43493: LD_INT 4
43495: PUSH
43496: FOR_TO
43497: IFFALSE 43688
// begin if not tmp [ j ] then
43499: LD_VAR 0 4
43503: PUSH
43504: LD_VAR 0 3
43508: ARRAY
43509: NOT
43510: IFFALSE 43514
// continue ;
43512: GO 43496
// for p in tmp [ j ] do
43514: LD_ADDR_VAR 0 5
43518: PUSH
43519: LD_VAR 0 4
43523: PUSH
43524: LD_VAR 0 3
43528: ARRAY
43529: PUSH
43530: FOR_IN
43531: IFFALSE 43684
// begin if not b [ j ] then
43533: LD_VAR 0 6
43537: PUSH
43538: LD_VAR 0 3
43542: ARRAY
43543: NOT
43544: IFFALSE 43548
// break ;
43546: GO 43684
// e := 0 ;
43548: LD_ADDR_VAR 0 7
43552: PUSH
43553: LD_INT 0
43555: ST_TO_ADDR
// for k in b [ j ] do
43556: LD_ADDR_VAR 0 8
43560: PUSH
43561: LD_VAR 0 6
43565: PUSH
43566: LD_VAR 0 3
43570: ARRAY
43571: PUSH
43572: FOR_IN
43573: IFFALSE 43600
// if IsNotFull ( k ) then
43575: LD_VAR 0 8
43579: PPUSH
43580: CALL 71854 0 1
43584: IFFALSE 43598
// begin e := k ;
43586: LD_ADDR_VAR 0 7
43590: PUSH
43591: LD_VAR 0 8
43595: ST_TO_ADDR
// break ;
43596: GO 43600
// end ;
43598: GO 43572
43600: POP
43601: POP
// if e and not UnitGoingToBuilding ( p , e ) then
43602: LD_VAR 0 7
43606: PUSH
43607: LD_VAR 0 5
43611: PPUSH
43612: LD_VAR 0 7
43616: PPUSH
43617: CALL 105993 0 2
43621: NOT
43622: AND
43623: IFFALSE 43682
// begin if IsInUnit ( p ) then
43625: LD_VAR 0 5
43629: PPUSH
43630: CALL_OW 310
43634: IFFALSE 43645
// ComExitBuilding ( p ) ;
43636: LD_VAR 0 5
43640: PPUSH
43641: CALL_OW 122
// ComEnterUnit ( p , e ) ;
43645: LD_VAR 0 5
43649: PPUSH
43650: LD_VAR 0 7
43654: PPUSH
43655: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
43659: LD_VAR 0 5
43663: PPUSH
43664: LD_VAR 0 3
43668: PPUSH
43669: CALL_OW 183
// AddComExitBuilding ( p ) ;
43673: LD_VAR 0 5
43677: PPUSH
43678: CALL_OW 182
// end ; end ;
43682: GO 43530
43684: POP
43685: POP
// end ;
43686: GO 43496
43688: POP
43689: POP
// end ;
43690: GO 43260
43692: POP
43693: POP
// end ;
43694: LD_VAR 0 1
43698: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
43699: LD_INT 0
43701: PPUSH
43702: PPUSH
43703: PPUSH
43704: PPUSH
43705: PPUSH
43706: PPUSH
43707: PPUSH
43708: PPUSH
43709: PPUSH
43710: PPUSH
43711: PPUSH
43712: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
43713: LD_ADDR_VAR 0 2
43717: PUSH
43718: LD_INT 0
43720: PUSH
43721: LD_INT 0
43723: PUSH
43724: LD_INT 0
43726: PUSH
43727: LD_INT 0
43729: PUSH
43730: EMPTY
43731: LIST
43732: LIST
43733: LIST
43734: LIST
43735: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
43736: LD_VAR 0 1
43740: NOT
43741: PUSH
43742: LD_EXP 102
43746: PUSH
43747: LD_VAR 0 1
43751: ARRAY
43752: NOT
43753: OR
43754: PUSH
43755: LD_EXP 102
43759: PUSH
43760: LD_VAR 0 1
43764: ARRAY
43765: PPUSH
43766: LD_INT 2
43768: PUSH
43769: LD_INT 30
43771: PUSH
43772: LD_INT 0
43774: PUSH
43775: EMPTY
43776: LIST
43777: LIST
43778: PUSH
43779: LD_INT 30
43781: PUSH
43782: LD_INT 1
43784: PUSH
43785: EMPTY
43786: LIST
43787: LIST
43788: PUSH
43789: EMPTY
43790: LIST
43791: LIST
43792: LIST
43793: PPUSH
43794: CALL_OW 72
43798: NOT
43799: OR
43800: IFFALSE 43804
// exit ;
43802: GO 47307
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
43804: LD_ADDR_VAR 0 4
43808: PUSH
43809: LD_EXP 102
43813: PUSH
43814: LD_VAR 0 1
43818: ARRAY
43819: PPUSH
43820: LD_INT 2
43822: PUSH
43823: LD_INT 25
43825: PUSH
43826: LD_INT 1
43828: PUSH
43829: EMPTY
43830: LIST
43831: LIST
43832: PUSH
43833: LD_INT 25
43835: PUSH
43836: LD_INT 2
43838: PUSH
43839: EMPTY
43840: LIST
43841: LIST
43842: PUSH
43843: LD_INT 25
43845: PUSH
43846: LD_INT 3
43848: PUSH
43849: EMPTY
43850: LIST
43851: LIST
43852: PUSH
43853: LD_INT 25
43855: PUSH
43856: LD_INT 4
43858: PUSH
43859: EMPTY
43860: LIST
43861: LIST
43862: PUSH
43863: LD_INT 25
43865: PUSH
43866: LD_INT 5
43868: PUSH
43869: EMPTY
43870: LIST
43871: LIST
43872: PUSH
43873: LD_INT 25
43875: PUSH
43876: LD_INT 8
43878: PUSH
43879: EMPTY
43880: LIST
43881: LIST
43882: PUSH
43883: LD_INT 25
43885: PUSH
43886: LD_INT 9
43888: PUSH
43889: EMPTY
43890: LIST
43891: LIST
43892: PUSH
43893: EMPTY
43894: LIST
43895: LIST
43896: LIST
43897: LIST
43898: LIST
43899: LIST
43900: LIST
43901: LIST
43902: PPUSH
43903: CALL_OW 72
43907: ST_TO_ADDR
// if not tmp then
43908: LD_VAR 0 4
43912: NOT
43913: IFFALSE 43917
// exit ;
43915: GO 47307
// for i in tmp do
43917: LD_ADDR_VAR 0 3
43921: PUSH
43922: LD_VAR 0 4
43926: PUSH
43927: FOR_IN
43928: IFFALSE 43959
// if GetTag ( i ) then
43930: LD_VAR 0 3
43934: PPUSH
43935: CALL_OW 110
43939: IFFALSE 43957
// tmp := tmp diff i ;
43941: LD_ADDR_VAR 0 4
43945: PUSH
43946: LD_VAR 0 4
43950: PUSH
43951: LD_VAR 0 3
43955: DIFF
43956: ST_TO_ADDR
43957: GO 43927
43959: POP
43960: POP
// if not tmp then
43961: LD_VAR 0 4
43965: NOT
43966: IFFALSE 43970
// exit ;
43968: GO 47307
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
43970: LD_ADDR_VAR 0 5
43974: PUSH
43975: LD_EXP 102
43979: PUSH
43980: LD_VAR 0 1
43984: ARRAY
43985: PPUSH
43986: LD_INT 2
43988: PUSH
43989: LD_INT 25
43991: PUSH
43992: LD_INT 1
43994: PUSH
43995: EMPTY
43996: LIST
43997: LIST
43998: PUSH
43999: LD_INT 25
44001: PUSH
44002: LD_INT 5
44004: PUSH
44005: EMPTY
44006: LIST
44007: LIST
44008: PUSH
44009: LD_INT 25
44011: PUSH
44012: LD_INT 8
44014: PUSH
44015: EMPTY
44016: LIST
44017: LIST
44018: PUSH
44019: LD_INT 25
44021: PUSH
44022: LD_INT 9
44024: PUSH
44025: EMPTY
44026: LIST
44027: LIST
44028: PUSH
44029: EMPTY
44030: LIST
44031: LIST
44032: LIST
44033: LIST
44034: LIST
44035: PPUSH
44036: CALL_OW 72
44040: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
44041: LD_ADDR_VAR 0 6
44045: PUSH
44046: LD_EXP 102
44050: PUSH
44051: LD_VAR 0 1
44055: ARRAY
44056: PPUSH
44057: LD_INT 25
44059: PUSH
44060: LD_INT 2
44062: PUSH
44063: EMPTY
44064: LIST
44065: LIST
44066: PPUSH
44067: CALL_OW 72
44071: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
44072: LD_ADDR_VAR 0 7
44076: PUSH
44077: LD_EXP 102
44081: PUSH
44082: LD_VAR 0 1
44086: ARRAY
44087: PPUSH
44088: LD_INT 25
44090: PUSH
44091: LD_INT 3
44093: PUSH
44094: EMPTY
44095: LIST
44096: LIST
44097: PPUSH
44098: CALL_OW 72
44102: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
44103: LD_ADDR_VAR 0 8
44107: PUSH
44108: LD_EXP 102
44112: PUSH
44113: LD_VAR 0 1
44117: ARRAY
44118: PPUSH
44119: LD_INT 25
44121: PUSH
44122: LD_INT 4
44124: PUSH
44125: EMPTY
44126: LIST
44127: LIST
44128: PUSH
44129: LD_INT 24
44131: PUSH
44132: LD_INT 251
44134: PUSH
44135: EMPTY
44136: LIST
44137: LIST
44138: PUSH
44139: EMPTY
44140: LIST
44141: LIST
44142: PPUSH
44143: CALL_OW 72
44147: ST_TO_ADDR
// if mc_is_defending [ base ] then
44148: LD_EXP 145
44152: PUSH
44153: LD_VAR 0 1
44157: ARRAY
44158: IFFALSE 44619
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
44160: LD_ADDR_EXP 144
44164: PUSH
44165: LD_EXP 144
44169: PPUSH
44170: LD_VAR 0 1
44174: PPUSH
44175: LD_INT 4
44177: PPUSH
44178: CALL_OW 1
44182: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
44183: LD_ADDR_VAR 0 12
44187: PUSH
44188: LD_EXP 102
44192: PUSH
44193: LD_VAR 0 1
44197: ARRAY
44198: PPUSH
44199: LD_INT 2
44201: PUSH
44202: LD_INT 30
44204: PUSH
44205: LD_INT 4
44207: PUSH
44208: EMPTY
44209: LIST
44210: LIST
44211: PUSH
44212: LD_INT 30
44214: PUSH
44215: LD_INT 5
44217: PUSH
44218: EMPTY
44219: LIST
44220: LIST
44221: PUSH
44222: EMPTY
44223: LIST
44224: LIST
44225: LIST
44226: PPUSH
44227: CALL_OW 72
44231: ST_TO_ADDR
// if not b then
44232: LD_VAR 0 12
44236: NOT
44237: IFFALSE 44241
// exit ;
44239: GO 47307
// p := [ ] ;
44241: LD_ADDR_VAR 0 11
44245: PUSH
44246: EMPTY
44247: ST_TO_ADDR
// if sci >= 2 then
44248: LD_VAR 0 8
44252: PUSH
44253: LD_INT 2
44255: GREATEREQUAL
44256: IFFALSE 44287
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
44258: LD_ADDR_VAR 0 8
44262: PUSH
44263: LD_VAR 0 8
44267: PUSH
44268: LD_INT 1
44270: ARRAY
44271: PUSH
44272: LD_VAR 0 8
44276: PUSH
44277: LD_INT 2
44279: ARRAY
44280: PUSH
44281: EMPTY
44282: LIST
44283: LIST
44284: ST_TO_ADDR
44285: GO 44348
// if sci = 1 then
44287: LD_VAR 0 8
44291: PUSH
44292: LD_INT 1
44294: EQUAL
44295: IFFALSE 44316
// sci := [ sci [ 1 ] ] else
44297: LD_ADDR_VAR 0 8
44301: PUSH
44302: LD_VAR 0 8
44306: PUSH
44307: LD_INT 1
44309: ARRAY
44310: PUSH
44311: EMPTY
44312: LIST
44313: ST_TO_ADDR
44314: GO 44348
// if sci = 0 then
44316: LD_VAR 0 8
44320: PUSH
44321: LD_INT 0
44323: EQUAL
44324: IFFALSE 44348
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
44326: LD_ADDR_VAR 0 11
44330: PUSH
44331: LD_VAR 0 4
44335: PPUSH
44336: LD_INT 4
44338: PPUSH
44339: CALL 105865 0 2
44343: PUSH
44344: LD_INT 1
44346: ARRAY
44347: ST_TO_ADDR
// if eng > 4 then
44348: LD_VAR 0 6
44352: PUSH
44353: LD_INT 4
44355: GREATER
44356: IFFALSE 44402
// for i = eng downto 4 do
44358: LD_ADDR_VAR 0 3
44362: PUSH
44363: DOUBLE
44364: LD_VAR 0 6
44368: INC
44369: ST_TO_ADDR
44370: LD_INT 4
44372: PUSH
44373: FOR_DOWNTO
44374: IFFALSE 44400
// eng := eng diff eng [ i ] ;
44376: LD_ADDR_VAR 0 6
44380: PUSH
44381: LD_VAR 0 6
44385: PUSH
44386: LD_VAR 0 6
44390: PUSH
44391: LD_VAR 0 3
44395: ARRAY
44396: DIFF
44397: ST_TO_ADDR
44398: GO 44373
44400: POP
44401: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
44402: LD_ADDR_VAR 0 4
44406: PUSH
44407: LD_VAR 0 4
44411: PUSH
44412: LD_VAR 0 5
44416: PUSH
44417: LD_VAR 0 6
44421: UNION
44422: PUSH
44423: LD_VAR 0 7
44427: UNION
44428: PUSH
44429: LD_VAR 0 8
44433: UNION
44434: DIFF
44435: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
44436: LD_ADDR_VAR 0 13
44440: PUSH
44441: LD_EXP 102
44445: PUSH
44446: LD_VAR 0 1
44450: ARRAY
44451: PPUSH
44452: LD_INT 2
44454: PUSH
44455: LD_INT 30
44457: PUSH
44458: LD_INT 32
44460: PUSH
44461: EMPTY
44462: LIST
44463: LIST
44464: PUSH
44465: LD_INT 30
44467: PUSH
44468: LD_INT 31
44470: PUSH
44471: EMPTY
44472: LIST
44473: LIST
44474: PUSH
44475: EMPTY
44476: LIST
44477: LIST
44478: LIST
44479: PPUSH
44480: CALL_OW 72
44484: PUSH
44485: LD_EXP 102
44489: PUSH
44490: LD_VAR 0 1
44494: ARRAY
44495: PPUSH
44496: LD_INT 2
44498: PUSH
44499: LD_INT 30
44501: PUSH
44502: LD_INT 4
44504: PUSH
44505: EMPTY
44506: LIST
44507: LIST
44508: PUSH
44509: LD_INT 30
44511: PUSH
44512: LD_INT 5
44514: PUSH
44515: EMPTY
44516: LIST
44517: LIST
44518: PUSH
44519: EMPTY
44520: LIST
44521: LIST
44522: LIST
44523: PPUSH
44524: CALL_OW 72
44528: PUSH
44529: LD_INT 6
44531: MUL
44532: PLUS
44533: ST_TO_ADDR
// if bcount < tmp then
44534: LD_VAR 0 13
44538: PUSH
44539: LD_VAR 0 4
44543: LESS
44544: IFFALSE 44590
// for i = tmp downto bcount do
44546: LD_ADDR_VAR 0 3
44550: PUSH
44551: DOUBLE
44552: LD_VAR 0 4
44556: INC
44557: ST_TO_ADDR
44558: LD_VAR 0 13
44562: PUSH
44563: FOR_DOWNTO
44564: IFFALSE 44588
// tmp := Delete ( tmp , tmp ) ;
44566: LD_ADDR_VAR 0 4
44570: PUSH
44571: LD_VAR 0 4
44575: PPUSH
44576: LD_VAR 0 4
44580: PPUSH
44581: CALL_OW 3
44585: ST_TO_ADDR
44586: GO 44563
44588: POP
44589: POP
// result := [ tmp , 0 , 0 , p ] ;
44590: LD_ADDR_VAR 0 2
44594: PUSH
44595: LD_VAR 0 4
44599: PUSH
44600: LD_INT 0
44602: PUSH
44603: LD_INT 0
44605: PUSH
44606: LD_VAR 0 11
44610: PUSH
44611: EMPTY
44612: LIST
44613: LIST
44614: LIST
44615: LIST
44616: ST_TO_ADDR
// exit ;
44617: GO 47307
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
44619: LD_EXP 102
44623: PUSH
44624: LD_VAR 0 1
44628: ARRAY
44629: PPUSH
44630: LD_INT 2
44632: PUSH
44633: LD_INT 30
44635: PUSH
44636: LD_INT 6
44638: PUSH
44639: EMPTY
44640: LIST
44641: LIST
44642: PUSH
44643: LD_INT 30
44645: PUSH
44646: LD_INT 7
44648: PUSH
44649: EMPTY
44650: LIST
44651: LIST
44652: PUSH
44653: LD_INT 30
44655: PUSH
44656: LD_INT 8
44658: PUSH
44659: EMPTY
44660: LIST
44661: LIST
44662: PUSH
44663: EMPTY
44664: LIST
44665: LIST
44666: LIST
44667: LIST
44668: PPUSH
44669: CALL_OW 72
44673: NOT
44674: PUSH
44675: LD_EXP 102
44679: PUSH
44680: LD_VAR 0 1
44684: ARRAY
44685: PPUSH
44686: LD_INT 30
44688: PUSH
44689: LD_INT 3
44691: PUSH
44692: EMPTY
44693: LIST
44694: LIST
44695: PPUSH
44696: CALL_OW 72
44700: NOT
44701: AND
44702: IFFALSE 44774
// begin if eng = tmp then
44704: LD_VAR 0 6
44708: PUSH
44709: LD_VAR 0 4
44713: EQUAL
44714: IFFALSE 44718
// exit ;
44716: GO 47307
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
44718: LD_ADDR_EXP 144
44722: PUSH
44723: LD_EXP 144
44727: PPUSH
44728: LD_VAR 0 1
44732: PPUSH
44733: LD_INT 1
44735: PPUSH
44736: CALL_OW 1
44740: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
44741: LD_ADDR_VAR 0 2
44745: PUSH
44746: LD_INT 0
44748: PUSH
44749: LD_VAR 0 4
44753: PUSH
44754: LD_VAR 0 6
44758: DIFF
44759: PUSH
44760: LD_INT 0
44762: PUSH
44763: LD_INT 0
44765: PUSH
44766: EMPTY
44767: LIST
44768: LIST
44769: LIST
44770: LIST
44771: ST_TO_ADDR
// exit ;
44772: GO 47307
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
44774: LD_EXP 129
44778: PUSH
44779: LD_EXP 128
44783: PUSH
44784: LD_VAR 0 1
44788: ARRAY
44789: ARRAY
44790: PUSH
44791: LD_EXP 102
44795: PUSH
44796: LD_VAR 0 1
44800: ARRAY
44801: PPUSH
44802: LD_INT 2
44804: PUSH
44805: LD_INT 30
44807: PUSH
44808: LD_INT 6
44810: PUSH
44811: EMPTY
44812: LIST
44813: LIST
44814: PUSH
44815: LD_INT 30
44817: PUSH
44818: LD_INT 7
44820: PUSH
44821: EMPTY
44822: LIST
44823: LIST
44824: PUSH
44825: LD_INT 30
44827: PUSH
44828: LD_INT 8
44830: PUSH
44831: EMPTY
44832: LIST
44833: LIST
44834: PUSH
44835: EMPTY
44836: LIST
44837: LIST
44838: LIST
44839: LIST
44840: PPUSH
44841: CALL_OW 72
44845: AND
44846: PUSH
44847: LD_EXP 102
44851: PUSH
44852: LD_VAR 0 1
44856: ARRAY
44857: PPUSH
44858: LD_INT 30
44860: PUSH
44861: LD_INT 3
44863: PUSH
44864: EMPTY
44865: LIST
44866: LIST
44867: PPUSH
44868: CALL_OW 72
44872: NOT
44873: AND
44874: IFFALSE 45088
// begin if sci >= 6 then
44876: LD_VAR 0 8
44880: PUSH
44881: LD_INT 6
44883: GREATEREQUAL
44884: IFFALSE 44888
// exit ;
44886: GO 47307
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
44888: LD_ADDR_EXP 144
44892: PUSH
44893: LD_EXP 144
44897: PPUSH
44898: LD_VAR 0 1
44902: PPUSH
44903: LD_INT 2
44905: PPUSH
44906: CALL_OW 1
44910: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
44911: LD_ADDR_VAR 0 9
44915: PUSH
44916: LD_VAR 0 4
44920: PUSH
44921: LD_VAR 0 8
44925: DIFF
44926: PPUSH
44927: LD_INT 4
44929: PPUSH
44930: CALL 105865 0 2
44934: ST_TO_ADDR
// p := [ ] ;
44935: LD_ADDR_VAR 0 11
44939: PUSH
44940: EMPTY
44941: ST_TO_ADDR
// if sci < 6 and sort > 6 then
44942: LD_VAR 0 8
44946: PUSH
44947: LD_INT 6
44949: LESS
44950: PUSH
44951: LD_VAR 0 9
44955: PUSH
44956: LD_INT 6
44958: GREATER
44959: AND
44960: IFFALSE 45041
// begin for i = 1 to 6 - sci do
44962: LD_ADDR_VAR 0 3
44966: PUSH
44967: DOUBLE
44968: LD_INT 1
44970: DEC
44971: ST_TO_ADDR
44972: LD_INT 6
44974: PUSH
44975: LD_VAR 0 8
44979: MINUS
44980: PUSH
44981: FOR_TO
44982: IFFALSE 45037
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
44984: LD_ADDR_VAR 0 11
44988: PUSH
44989: LD_VAR 0 11
44993: PPUSH
44994: LD_VAR 0 11
44998: PUSH
44999: LD_INT 1
45001: PLUS
45002: PPUSH
45003: LD_VAR 0 9
45007: PUSH
45008: LD_INT 1
45010: ARRAY
45011: PPUSH
45012: CALL_OW 2
45016: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
45017: LD_ADDR_VAR 0 9
45021: PUSH
45022: LD_VAR 0 9
45026: PPUSH
45027: LD_INT 1
45029: PPUSH
45030: CALL_OW 3
45034: ST_TO_ADDR
// end ;
45035: GO 44981
45037: POP
45038: POP
// end else
45039: GO 45061
// if sort then
45041: LD_VAR 0 9
45045: IFFALSE 45061
// p := sort [ 1 ] ;
45047: LD_ADDR_VAR 0 11
45051: PUSH
45052: LD_VAR 0 9
45056: PUSH
45057: LD_INT 1
45059: ARRAY
45060: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
45061: LD_ADDR_VAR 0 2
45065: PUSH
45066: LD_INT 0
45068: PUSH
45069: LD_INT 0
45071: PUSH
45072: LD_INT 0
45074: PUSH
45075: LD_VAR 0 11
45079: PUSH
45080: EMPTY
45081: LIST
45082: LIST
45083: LIST
45084: LIST
45085: ST_TO_ADDR
// exit ;
45086: GO 47307
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
45088: LD_EXP 129
45092: PUSH
45093: LD_EXP 128
45097: PUSH
45098: LD_VAR 0 1
45102: ARRAY
45103: ARRAY
45104: PUSH
45105: LD_EXP 102
45109: PUSH
45110: LD_VAR 0 1
45114: ARRAY
45115: PPUSH
45116: LD_INT 2
45118: PUSH
45119: LD_INT 30
45121: PUSH
45122: LD_INT 6
45124: PUSH
45125: EMPTY
45126: LIST
45127: LIST
45128: PUSH
45129: LD_INT 30
45131: PUSH
45132: LD_INT 7
45134: PUSH
45135: EMPTY
45136: LIST
45137: LIST
45138: PUSH
45139: LD_INT 30
45141: PUSH
45142: LD_INT 8
45144: PUSH
45145: EMPTY
45146: LIST
45147: LIST
45148: PUSH
45149: EMPTY
45150: LIST
45151: LIST
45152: LIST
45153: LIST
45154: PPUSH
45155: CALL_OW 72
45159: AND
45160: PUSH
45161: LD_EXP 102
45165: PUSH
45166: LD_VAR 0 1
45170: ARRAY
45171: PPUSH
45172: LD_INT 30
45174: PUSH
45175: LD_INT 3
45177: PUSH
45178: EMPTY
45179: LIST
45180: LIST
45181: PPUSH
45182: CALL_OW 72
45186: AND
45187: IFFALSE 45921
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
45189: LD_ADDR_EXP 144
45193: PUSH
45194: LD_EXP 144
45198: PPUSH
45199: LD_VAR 0 1
45203: PPUSH
45204: LD_INT 3
45206: PPUSH
45207: CALL_OW 1
45211: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
45212: LD_ADDR_VAR 0 2
45216: PUSH
45217: LD_INT 0
45219: PUSH
45220: LD_INT 0
45222: PUSH
45223: LD_INT 0
45225: PUSH
45226: LD_INT 0
45228: PUSH
45229: EMPTY
45230: LIST
45231: LIST
45232: LIST
45233: LIST
45234: ST_TO_ADDR
// if not eng then
45235: LD_VAR 0 6
45239: NOT
45240: IFFALSE 45303
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
45242: LD_ADDR_VAR 0 11
45246: PUSH
45247: LD_VAR 0 4
45251: PPUSH
45252: LD_INT 2
45254: PPUSH
45255: CALL 105865 0 2
45259: PUSH
45260: LD_INT 1
45262: ARRAY
45263: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
45264: LD_ADDR_VAR 0 2
45268: PUSH
45269: LD_VAR 0 2
45273: PPUSH
45274: LD_INT 2
45276: PPUSH
45277: LD_VAR 0 11
45281: PPUSH
45282: CALL_OW 1
45286: ST_TO_ADDR
// tmp := tmp diff p ;
45287: LD_ADDR_VAR 0 4
45291: PUSH
45292: LD_VAR 0 4
45296: PUSH
45297: LD_VAR 0 11
45301: DIFF
45302: ST_TO_ADDR
// end ; if tmp and sci < 6 then
45303: LD_VAR 0 4
45307: PUSH
45308: LD_VAR 0 8
45312: PUSH
45313: LD_INT 6
45315: LESS
45316: AND
45317: IFFALSE 45505
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
45319: LD_ADDR_VAR 0 9
45323: PUSH
45324: LD_VAR 0 4
45328: PUSH
45329: LD_VAR 0 8
45333: PUSH
45334: LD_VAR 0 7
45338: UNION
45339: DIFF
45340: PPUSH
45341: LD_INT 4
45343: PPUSH
45344: CALL 105865 0 2
45348: ST_TO_ADDR
// p := [ ] ;
45349: LD_ADDR_VAR 0 11
45353: PUSH
45354: EMPTY
45355: ST_TO_ADDR
// if sort then
45356: LD_VAR 0 9
45360: IFFALSE 45476
// for i = 1 to 6 - sci do
45362: LD_ADDR_VAR 0 3
45366: PUSH
45367: DOUBLE
45368: LD_INT 1
45370: DEC
45371: ST_TO_ADDR
45372: LD_INT 6
45374: PUSH
45375: LD_VAR 0 8
45379: MINUS
45380: PUSH
45381: FOR_TO
45382: IFFALSE 45474
// begin if i = sort then
45384: LD_VAR 0 3
45388: PUSH
45389: LD_VAR 0 9
45393: EQUAL
45394: IFFALSE 45398
// break ;
45396: GO 45474
// if GetClass ( i ) = 4 then
45398: LD_VAR 0 3
45402: PPUSH
45403: CALL_OW 257
45407: PUSH
45408: LD_INT 4
45410: EQUAL
45411: IFFALSE 45415
// continue ;
45413: GO 45381
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45415: LD_ADDR_VAR 0 11
45419: PUSH
45420: LD_VAR 0 11
45424: PPUSH
45425: LD_VAR 0 11
45429: PUSH
45430: LD_INT 1
45432: PLUS
45433: PPUSH
45434: LD_VAR 0 9
45438: PUSH
45439: LD_VAR 0 3
45443: ARRAY
45444: PPUSH
45445: CALL_OW 2
45449: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45450: LD_ADDR_VAR 0 4
45454: PUSH
45455: LD_VAR 0 4
45459: PUSH
45460: LD_VAR 0 9
45464: PUSH
45465: LD_VAR 0 3
45469: ARRAY
45470: DIFF
45471: ST_TO_ADDR
// end ;
45472: GO 45381
45474: POP
45475: POP
// if p then
45476: LD_VAR 0 11
45480: IFFALSE 45505
// result := Replace ( result , 4 , p ) ;
45482: LD_ADDR_VAR 0 2
45486: PUSH
45487: LD_VAR 0 2
45491: PPUSH
45492: LD_INT 4
45494: PPUSH
45495: LD_VAR 0 11
45499: PPUSH
45500: CALL_OW 1
45504: ST_TO_ADDR
// end ; if tmp and mech < 6 then
45505: LD_VAR 0 4
45509: PUSH
45510: LD_VAR 0 7
45514: PUSH
45515: LD_INT 6
45517: LESS
45518: AND
45519: IFFALSE 45707
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
45521: LD_ADDR_VAR 0 9
45525: PUSH
45526: LD_VAR 0 4
45530: PUSH
45531: LD_VAR 0 8
45535: PUSH
45536: LD_VAR 0 7
45540: UNION
45541: DIFF
45542: PPUSH
45543: LD_INT 3
45545: PPUSH
45546: CALL 105865 0 2
45550: ST_TO_ADDR
// p := [ ] ;
45551: LD_ADDR_VAR 0 11
45555: PUSH
45556: EMPTY
45557: ST_TO_ADDR
// if sort then
45558: LD_VAR 0 9
45562: IFFALSE 45678
// for i = 1 to 6 - mech do
45564: LD_ADDR_VAR 0 3
45568: PUSH
45569: DOUBLE
45570: LD_INT 1
45572: DEC
45573: ST_TO_ADDR
45574: LD_INT 6
45576: PUSH
45577: LD_VAR 0 7
45581: MINUS
45582: PUSH
45583: FOR_TO
45584: IFFALSE 45676
// begin if i = sort then
45586: LD_VAR 0 3
45590: PUSH
45591: LD_VAR 0 9
45595: EQUAL
45596: IFFALSE 45600
// break ;
45598: GO 45676
// if GetClass ( i ) = 3 then
45600: LD_VAR 0 3
45604: PPUSH
45605: CALL_OW 257
45609: PUSH
45610: LD_INT 3
45612: EQUAL
45613: IFFALSE 45617
// continue ;
45615: GO 45583
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45617: LD_ADDR_VAR 0 11
45621: PUSH
45622: LD_VAR 0 11
45626: PPUSH
45627: LD_VAR 0 11
45631: PUSH
45632: LD_INT 1
45634: PLUS
45635: PPUSH
45636: LD_VAR 0 9
45640: PUSH
45641: LD_VAR 0 3
45645: ARRAY
45646: PPUSH
45647: CALL_OW 2
45651: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45652: LD_ADDR_VAR 0 4
45656: PUSH
45657: LD_VAR 0 4
45661: PUSH
45662: LD_VAR 0 9
45666: PUSH
45667: LD_VAR 0 3
45671: ARRAY
45672: DIFF
45673: ST_TO_ADDR
// end ;
45674: GO 45583
45676: POP
45677: POP
// if p then
45678: LD_VAR 0 11
45682: IFFALSE 45707
// result := Replace ( result , 3 , p ) ;
45684: LD_ADDR_VAR 0 2
45688: PUSH
45689: LD_VAR 0 2
45693: PPUSH
45694: LD_INT 3
45696: PPUSH
45697: LD_VAR 0 11
45701: PPUSH
45702: CALL_OW 1
45706: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
45707: LD_VAR 0 4
45711: PUSH
45712: LD_INT 6
45714: GREATER
45715: PUSH
45716: LD_VAR 0 6
45720: PUSH
45721: LD_INT 6
45723: LESS
45724: AND
45725: IFFALSE 45919
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
45727: LD_ADDR_VAR 0 9
45731: PUSH
45732: LD_VAR 0 4
45736: PUSH
45737: LD_VAR 0 8
45741: PUSH
45742: LD_VAR 0 7
45746: UNION
45747: PUSH
45748: LD_VAR 0 6
45752: UNION
45753: DIFF
45754: PPUSH
45755: LD_INT 2
45757: PPUSH
45758: CALL 105865 0 2
45762: ST_TO_ADDR
// p := [ ] ;
45763: LD_ADDR_VAR 0 11
45767: PUSH
45768: EMPTY
45769: ST_TO_ADDR
// if sort then
45770: LD_VAR 0 9
45774: IFFALSE 45890
// for i = 1 to 6 - eng do
45776: LD_ADDR_VAR 0 3
45780: PUSH
45781: DOUBLE
45782: LD_INT 1
45784: DEC
45785: ST_TO_ADDR
45786: LD_INT 6
45788: PUSH
45789: LD_VAR 0 6
45793: MINUS
45794: PUSH
45795: FOR_TO
45796: IFFALSE 45888
// begin if i = sort then
45798: LD_VAR 0 3
45802: PUSH
45803: LD_VAR 0 9
45807: EQUAL
45808: IFFALSE 45812
// break ;
45810: GO 45888
// if GetClass ( i ) = 2 then
45812: LD_VAR 0 3
45816: PPUSH
45817: CALL_OW 257
45821: PUSH
45822: LD_INT 2
45824: EQUAL
45825: IFFALSE 45829
// continue ;
45827: GO 45795
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45829: LD_ADDR_VAR 0 11
45833: PUSH
45834: LD_VAR 0 11
45838: PPUSH
45839: LD_VAR 0 11
45843: PUSH
45844: LD_INT 1
45846: PLUS
45847: PPUSH
45848: LD_VAR 0 9
45852: PUSH
45853: LD_VAR 0 3
45857: ARRAY
45858: PPUSH
45859: CALL_OW 2
45863: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45864: LD_ADDR_VAR 0 4
45868: PUSH
45869: LD_VAR 0 4
45873: PUSH
45874: LD_VAR 0 9
45878: PUSH
45879: LD_VAR 0 3
45883: ARRAY
45884: DIFF
45885: ST_TO_ADDR
// end ;
45886: GO 45795
45888: POP
45889: POP
// if p then
45890: LD_VAR 0 11
45894: IFFALSE 45919
// result := Replace ( result , 2 , p ) ;
45896: LD_ADDR_VAR 0 2
45900: PUSH
45901: LD_VAR 0 2
45905: PPUSH
45906: LD_INT 2
45908: PPUSH
45909: LD_VAR 0 11
45913: PPUSH
45914: CALL_OW 1
45918: ST_TO_ADDR
// end ; exit ;
45919: GO 47307
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
45921: LD_EXP 129
45925: PUSH
45926: LD_EXP 128
45930: PUSH
45931: LD_VAR 0 1
45935: ARRAY
45936: ARRAY
45937: NOT
45938: PUSH
45939: LD_EXP 102
45943: PUSH
45944: LD_VAR 0 1
45948: ARRAY
45949: PPUSH
45950: LD_INT 30
45952: PUSH
45953: LD_INT 3
45955: PUSH
45956: EMPTY
45957: LIST
45958: LIST
45959: PPUSH
45960: CALL_OW 72
45964: AND
45965: PUSH
45966: LD_EXP 107
45970: PUSH
45971: LD_VAR 0 1
45975: ARRAY
45976: AND
45977: IFFALSE 46585
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
45979: LD_ADDR_EXP 144
45983: PUSH
45984: LD_EXP 144
45988: PPUSH
45989: LD_VAR 0 1
45993: PPUSH
45994: LD_INT 5
45996: PPUSH
45997: CALL_OW 1
46001: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
46002: LD_ADDR_VAR 0 2
46006: PUSH
46007: LD_INT 0
46009: PUSH
46010: LD_INT 0
46012: PUSH
46013: LD_INT 0
46015: PUSH
46016: LD_INT 0
46018: PUSH
46019: EMPTY
46020: LIST
46021: LIST
46022: LIST
46023: LIST
46024: ST_TO_ADDR
// if sci > 1 then
46025: LD_VAR 0 8
46029: PUSH
46030: LD_INT 1
46032: GREATER
46033: IFFALSE 46061
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
46035: LD_ADDR_VAR 0 4
46039: PUSH
46040: LD_VAR 0 4
46044: PUSH
46045: LD_VAR 0 8
46049: PUSH
46050: LD_VAR 0 8
46054: PUSH
46055: LD_INT 1
46057: ARRAY
46058: DIFF
46059: DIFF
46060: ST_TO_ADDR
// if tmp and not sci then
46061: LD_VAR 0 4
46065: PUSH
46066: LD_VAR 0 8
46070: NOT
46071: AND
46072: IFFALSE 46141
// begin sort := SortBySkill ( tmp , 4 ) ;
46074: LD_ADDR_VAR 0 9
46078: PUSH
46079: LD_VAR 0 4
46083: PPUSH
46084: LD_INT 4
46086: PPUSH
46087: CALL 105865 0 2
46091: ST_TO_ADDR
// if sort then
46092: LD_VAR 0 9
46096: IFFALSE 46112
// p := sort [ 1 ] ;
46098: LD_ADDR_VAR 0 11
46102: PUSH
46103: LD_VAR 0 9
46107: PUSH
46108: LD_INT 1
46110: ARRAY
46111: ST_TO_ADDR
// if p then
46112: LD_VAR 0 11
46116: IFFALSE 46141
// result := Replace ( result , 4 , p ) ;
46118: LD_ADDR_VAR 0 2
46122: PUSH
46123: LD_VAR 0 2
46127: PPUSH
46128: LD_INT 4
46130: PPUSH
46131: LD_VAR 0 11
46135: PPUSH
46136: CALL_OW 1
46140: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
46141: LD_ADDR_VAR 0 4
46145: PUSH
46146: LD_VAR 0 4
46150: PUSH
46151: LD_VAR 0 7
46155: DIFF
46156: ST_TO_ADDR
// if tmp and mech < 6 then
46157: LD_VAR 0 4
46161: PUSH
46162: LD_VAR 0 7
46166: PUSH
46167: LD_INT 6
46169: LESS
46170: AND
46171: IFFALSE 46359
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
46173: LD_ADDR_VAR 0 9
46177: PUSH
46178: LD_VAR 0 4
46182: PUSH
46183: LD_VAR 0 8
46187: PUSH
46188: LD_VAR 0 7
46192: UNION
46193: DIFF
46194: PPUSH
46195: LD_INT 3
46197: PPUSH
46198: CALL 105865 0 2
46202: ST_TO_ADDR
// p := [ ] ;
46203: LD_ADDR_VAR 0 11
46207: PUSH
46208: EMPTY
46209: ST_TO_ADDR
// if sort then
46210: LD_VAR 0 9
46214: IFFALSE 46330
// for i = 1 to 6 - mech do
46216: LD_ADDR_VAR 0 3
46220: PUSH
46221: DOUBLE
46222: LD_INT 1
46224: DEC
46225: ST_TO_ADDR
46226: LD_INT 6
46228: PUSH
46229: LD_VAR 0 7
46233: MINUS
46234: PUSH
46235: FOR_TO
46236: IFFALSE 46328
// begin if i = sort then
46238: LD_VAR 0 3
46242: PUSH
46243: LD_VAR 0 9
46247: EQUAL
46248: IFFALSE 46252
// break ;
46250: GO 46328
// if GetClass ( i ) = 3 then
46252: LD_VAR 0 3
46256: PPUSH
46257: CALL_OW 257
46261: PUSH
46262: LD_INT 3
46264: EQUAL
46265: IFFALSE 46269
// continue ;
46267: GO 46235
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46269: LD_ADDR_VAR 0 11
46273: PUSH
46274: LD_VAR 0 11
46278: PPUSH
46279: LD_VAR 0 11
46283: PUSH
46284: LD_INT 1
46286: PLUS
46287: PPUSH
46288: LD_VAR 0 9
46292: PUSH
46293: LD_VAR 0 3
46297: ARRAY
46298: PPUSH
46299: CALL_OW 2
46303: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46304: LD_ADDR_VAR 0 4
46308: PUSH
46309: LD_VAR 0 4
46313: PUSH
46314: LD_VAR 0 9
46318: PUSH
46319: LD_VAR 0 3
46323: ARRAY
46324: DIFF
46325: ST_TO_ADDR
// end ;
46326: GO 46235
46328: POP
46329: POP
// if p then
46330: LD_VAR 0 11
46334: IFFALSE 46359
// result := Replace ( result , 3 , p ) ;
46336: LD_ADDR_VAR 0 2
46340: PUSH
46341: LD_VAR 0 2
46345: PPUSH
46346: LD_INT 3
46348: PPUSH
46349: LD_VAR 0 11
46353: PPUSH
46354: CALL_OW 1
46358: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
46359: LD_ADDR_VAR 0 4
46363: PUSH
46364: LD_VAR 0 4
46368: PUSH
46369: LD_VAR 0 6
46373: DIFF
46374: ST_TO_ADDR
// if tmp and eng < 6 then
46375: LD_VAR 0 4
46379: PUSH
46380: LD_VAR 0 6
46384: PUSH
46385: LD_INT 6
46387: LESS
46388: AND
46389: IFFALSE 46583
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
46391: LD_ADDR_VAR 0 9
46395: PUSH
46396: LD_VAR 0 4
46400: PUSH
46401: LD_VAR 0 8
46405: PUSH
46406: LD_VAR 0 7
46410: UNION
46411: PUSH
46412: LD_VAR 0 6
46416: UNION
46417: DIFF
46418: PPUSH
46419: LD_INT 2
46421: PPUSH
46422: CALL 105865 0 2
46426: ST_TO_ADDR
// p := [ ] ;
46427: LD_ADDR_VAR 0 11
46431: PUSH
46432: EMPTY
46433: ST_TO_ADDR
// if sort then
46434: LD_VAR 0 9
46438: IFFALSE 46554
// for i = 1 to 6 - eng do
46440: LD_ADDR_VAR 0 3
46444: PUSH
46445: DOUBLE
46446: LD_INT 1
46448: DEC
46449: ST_TO_ADDR
46450: LD_INT 6
46452: PUSH
46453: LD_VAR 0 6
46457: MINUS
46458: PUSH
46459: FOR_TO
46460: IFFALSE 46552
// begin if i = sort then
46462: LD_VAR 0 3
46466: PUSH
46467: LD_VAR 0 9
46471: EQUAL
46472: IFFALSE 46476
// break ;
46474: GO 46552
// if GetClass ( i ) = 2 then
46476: LD_VAR 0 3
46480: PPUSH
46481: CALL_OW 257
46485: PUSH
46486: LD_INT 2
46488: EQUAL
46489: IFFALSE 46493
// continue ;
46491: GO 46459
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46493: LD_ADDR_VAR 0 11
46497: PUSH
46498: LD_VAR 0 11
46502: PPUSH
46503: LD_VAR 0 11
46507: PUSH
46508: LD_INT 1
46510: PLUS
46511: PPUSH
46512: LD_VAR 0 9
46516: PUSH
46517: LD_VAR 0 3
46521: ARRAY
46522: PPUSH
46523: CALL_OW 2
46527: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46528: LD_ADDR_VAR 0 4
46532: PUSH
46533: LD_VAR 0 4
46537: PUSH
46538: LD_VAR 0 9
46542: PUSH
46543: LD_VAR 0 3
46547: ARRAY
46548: DIFF
46549: ST_TO_ADDR
// end ;
46550: GO 46459
46552: POP
46553: POP
// if p then
46554: LD_VAR 0 11
46558: IFFALSE 46583
// result := Replace ( result , 2 , p ) ;
46560: LD_ADDR_VAR 0 2
46564: PUSH
46565: LD_VAR 0 2
46569: PPUSH
46570: LD_INT 2
46572: PPUSH
46573: LD_VAR 0 11
46577: PPUSH
46578: CALL_OW 1
46582: ST_TO_ADDR
// end ; exit ;
46583: GO 47307
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
46585: LD_EXP 129
46589: PUSH
46590: LD_EXP 128
46594: PUSH
46595: LD_VAR 0 1
46599: ARRAY
46600: ARRAY
46601: NOT
46602: PUSH
46603: LD_EXP 102
46607: PUSH
46608: LD_VAR 0 1
46612: ARRAY
46613: PPUSH
46614: LD_INT 30
46616: PUSH
46617: LD_INT 3
46619: PUSH
46620: EMPTY
46621: LIST
46622: LIST
46623: PPUSH
46624: CALL_OW 72
46628: AND
46629: PUSH
46630: LD_EXP 107
46634: PUSH
46635: LD_VAR 0 1
46639: ARRAY
46640: NOT
46641: AND
46642: IFFALSE 47307
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
46644: LD_ADDR_EXP 144
46648: PUSH
46649: LD_EXP 144
46653: PPUSH
46654: LD_VAR 0 1
46658: PPUSH
46659: LD_INT 6
46661: PPUSH
46662: CALL_OW 1
46666: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
46667: LD_ADDR_VAR 0 2
46671: PUSH
46672: LD_INT 0
46674: PUSH
46675: LD_INT 0
46677: PUSH
46678: LD_INT 0
46680: PUSH
46681: LD_INT 0
46683: PUSH
46684: EMPTY
46685: LIST
46686: LIST
46687: LIST
46688: LIST
46689: ST_TO_ADDR
// if sci >= 1 then
46690: LD_VAR 0 8
46694: PUSH
46695: LD_INT 1
46697: GREATEREQUAL
46698: IFFALSE 46720
// tmp := tmp diff sci [ 1 ] ;
46700: LD_ADDR_VAR 0 4
46704: PUSH
46705: LD_VAR 0 4
46709: PUSH
46710: LD_VAR 0 8
46714: PUSH
46715: LD_INT 1
46717: ARRAY
46718: DIFF
46719: ST_TO_ADDR
// if tmp and not sci then
46720: LD_VAR 0 4
46724: PUSH
46725: LD_VAR 0 8
46729: NOT
46730: AND
46731: IFFALSE 46800
// begin sort := SortBySkill ( tmp , 4 ) ;
46733: LD_ADDR_VAR 0 9
46737: PUSH
46738: LD_VAR 0 4
46742: PPUSH
46743: LD_INT 4
46745: PPUSH
46746: CALL 105865 0 2
46750: ST_TO_ADDR
// if sort then
46751: LD_VAR 0 9
46755: IFFALSE 46771
// p := sort [ 1 ] ;
46757: LD_ADDR_VAR 0 11
46761: PUSH
46762: LD_VAR 0 9
46766: PUSH
46767: LD_INT 1
46769: ARRAY
46770: ST_TO_ADDR
// if p then
46771: LD_VAR 0 11
46775: IFFALSE 46800
// result := Replace ( result , 4 , p ) ;
46777: LD_ADDR_VAR 0 2
46781: PUSH
46782: LD_VAR 0 2
46786: PPUSH
46787: LD_INT 4
46789: PPUSH
46790: LD_VAR 0 11
46794: PPUSH
46795: CALL_OW 1
46799: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
46800: LD_ADDR_VAR 0 4
46804: PUSH
46805: LD_VAR 0 4
46809: PUSH
46810: LD_VAR 0 7
46814: DIFF
46815: ST_TO_ADDR
// if tmp and mech < 6 then
46816: LD_VAR 0 4
46820: PUSH
46821: LD_VAR 0 7
46825: PUSH
46826: LD_INT 6
46828: LESS
46829: AND
46830: IFFALSE 47012
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
46832: LD_ADDR_VAR 0 9
46836: PUSH
46837: LD_VAR 0 4
46841: PUSH
46842: LD_VAR 0 7
46846: DIFF
46847: PPUSH
46848: LD_INT 3
46850: PPUSH
46851: CALL 105865 0 2
46855: ST_TO_ADDR
// p := [ ] ;
46856: LD_ADDR_VAR 0 11
46860: PUSH
46861: EMPTY
46862: ST_TO_ADDR
// if sort then
46863: LD_VAR 0 9
46867: IFFALSE 46983
// for i = 1 to 6 - mech do
46869: LD_ADDR_VAR 0 3
46873: PUSH
46874: DOUBLE
46875: LD_INT 1
46877: DEC
46878: ST_TO_ADDR
46879: LD_INT 6
46881: PUSH
46882: LD_VAR 0 7
46886: MINUS
46887: PUSH
46888: FOR_TO
46889: IFFALSE 46981
// begin if i = sort then
46891: LD_VAR 0 3
46895: PUSH
46896: LD_VAR 0 9
46900: EQUAL
46901: IFFALSE 46905
// break ;
46903: GO 46981
// if GetClass ( i ) = 3 then
46905: LD_VAR 0 3
46909: PPUSH
46910: CALL_OW 257
46914: PUSH
46915: LD_INT 3
46917: EQUAL
46918: IFFALSE 46922
// continue ;
46920: GO 46888
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46922: LD_ADDR_VAR 0 11
46926: PUSH
46927: LD_VAR 0 11
46931: PPUSH
46932: LD_VAR 0 11
46936: PUSH
46937: LD_INT 1
46939: PLUS
46940: PPUSH
46941: LD_VAR 0 9
46945: PUSH
46946: LD_VAR 0 3
46950: ARRAY
46951: PPUSH
46952: CALL_OW 2
46956: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46957: LD_ADDR_VAR 0 4
46961: PUSH
46962: LD_VAR 0 4
46966: PUSH
46967: LD_VAR 0 9
46971: PUSH
46972: LD_VAR 0 3
46976: ARRAY
46977: DIFF
46978: ST_TO_ADDR
// end ;
46979: GO 46888
46981: POP
46982: POP
// if p then
46983: LD_VAR 0 11
46987: IFFALSE 47012
// result := Replace ( result , 3 , p ) ;
46989: LD_ADDR_VAR 0 2
46993: PUSH
46994: LD_VAR 0 2
46998: PPUSH
46999: LD_INT 3
47001: PPUSH
47002: LD_VAR 0 11
47006: PPUSH
47007: CALL_OW 1
47011: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
47012: LD_ADDR_VAR 0 4
47016: PUSH
47017: LD_VAR 0 4
47021: PUSH
47022: LD_VAR 0 6
47026: DIFF
47027: ST_TO_ADDR
// if tmp and eng < 4 then
47028: LD_VAR 0 4
47032: PUSH
47033: LD_VAR 0 6
47037: PUSH
47038: LD_INT 4
47040: LESS
47041: AND
47042: IFFALSE 47232
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
47044: LD_ADDR_VAR 0 9
47048: PUSH
47049: LD_VAR 0 4
47053: PUSH
47054: LD_VAR 0 7
47058: PUSH
47059: LD_VAR 0 6
47063: UNION
47064: DIFF
47065: PPUSH
47066: LD_INT 2
47068: PPUSH
47069: CALL 105865 0 2
47073: ST_TO_ADDR
// p := [ ] ;
47074: LD_ADDR_VAR 0 11
47078: PUSH
47079: EMPTY
47080: ST_TO_ADDR
// if sort then
47081: LD_VAR 0 9
47085: IFFALSE 47201
// for i = 1 to 4 - eng do
47087: LD_ADDR_VAR 0 3
47091: PUSH
47092: DOUBLE
47093: LD_INT 1
47095: DEC
47096: ST_TO_ADDR
47097: LD_INT 4
47099: PUSH
47100: LD_VAR 0 6
47104: MINUS
47105: PUSH
47106: FOR_TO
47107: IFFALSE 47199
// begin if i = sort then
47109: LD_VAR 0 3
47113: PUSH
47114: LD_VAR 0 9
47118: EQUAL
47119: IFFALSE 47123
// break ;
47121: GO 47199
// if GetClass ( i ) = 2 then
47123: LD_VAR 0 3
47127: PPUSH
47128: CALL_OW 257
47132: PUSH
47133: LD_INT 2
47135: EQUAL
47136: IFFALSE 47140
// continue ;
47138: GO 47106
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47140: LD_ADDR_VAR 0 11
47144: PUSH
47145: LD_VAR 0 11
47149: PPUSH
47150: LD_VAR 0 11
47154: PUSH
47155: LD_INT 1
47157: PLUS
47158: PPUSH
47159: LD_VAR 0 9
47163: PUSH
47164: LD_VAR 0 3
47168: ARRAY
47169: PPUSH
47170: CALL_OW 2
47174: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47175: LD_ADDR_VAR 0 4
47179: PUSH
47180: LD_VAR 0 4
47184: PUSH
47185: LD_VAR 0 9
47189: PUSH
47190: LD_VAR 0 3
47194: ARRAY
47195: DIFF
47196: ST_TO_ADDR
// end ;
47197: GO 47106
47199: POP
47200: POP
// if p then
47201: LD_VAR 0 11
47205: IFFALSE 47230
// result := Replace ( result , 2 , p ) ;
47207: LD_ADDR_VAR 0 2
47211: PUSH
47212: LD_VAR 0 2
47216: PPUSH
47217: LD_INT 2
47219: PPUSH
47220: LD_VAR 0 11
47224: PPUSH
47225: CALL_OW 1
47229: ST_TO_ADDR
// end else
47230: GO 47276
// for i = eng downto 5 do
47232: LD_ADDR_VAR 0 3
47236: PUSH
47237: DOUBLE
47238: LD_VAR 0 6
47242: INC
47243: ST_TO_ADDR
47244: LD_INT 5
47246: PUSH
47247: FOR_DOWNTO
47248: IFFALSE 47274
// tmp := tmp union eng [ i ] ;
47250: LD_ADDR_VAR 0 4
47254: PUSH
47255: LD_VAR 0 4
47259: PUSH
47260: LD_VAR 0 6
47264: PUSH
47265: LD_VAR 0 3
47269: ARRAY
47270: UNION
47271: ST_TO_ADDR
47272: GO 47247
47274: POP
47275: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
47276: LD_ADDR_VAR 0 2
47280: PUSH
47281: LD_VAR 0 2
47285: PPUSH
47286: LD_INT 1
47288: PPUSH
47289: LD_VAR 0 4
47293: PUSH
47294: LD_VAR 0 5
47298: DIFF
47299: PPUSH
47300: CALL_OW 1
47304: ST_TO_ADDR
// exit ;
47305: GO 47307
// end ; end ;
47307: LD_VAR 0 2
47311: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
47312: LD_INT 0
47314: PPUSH
47315: PPUSH
47316: PPUSH
// if not mc_bases then
47317: LD_EXP 102
47321: NOT
47322: IFFALSE 47326
// exit ;
47324: GO 47468
// for i = 1 to mc_bases do
47326: LD_ADDR_VAR 0 2
47330: PUSH
47331: DOUBLE
47332: LD_INT 1
47334: DEC
47335: ST_TO_ADDR
47336: LD_EXP 102
47340: PUSH
47341: FOR_TO
47342: IFFALSE 47459
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
47344: LD_ADDR_VAR 0 3
47348: PUSH
47349: LD_EXP 102
47353: PUSH
47354: LD_VAR 0 2
47358: ARRAY
47359: PPUSH
47360: LD_INT 21
47362: PUSH
47363: LD_INT 3
47365: PUSH
47366: EMPTY
47367: LIST
47368: LIST
47369: PUSH
47370: LD_INT 3
47372: PUSH
47373: LD_INT 2
47375: PUSH
47376: LD_INT 30
47378: PUSH
47379: LD_INT 29
47381: PUSH
47382: EMPTY
47383: LIST
47384: LIST
47385: PUSH
47386: LD_INT 30
47388: PUSH
47389: LD_INT 30
47391: PUSH
47392: EMPTY
47393: LIST
47394: LIST
47395: PUSH
47396: EMPTY
47397: LIST
47398: LIST
47399: LIST
47400: PUSH
47401: EMPTY
47402: LIST
47403: LIST
47404: PUSH
47405: LD_INT 3
47407: PUSH
47408: LD_INT 24
47410: PUSH
47411: LD_INT 1000
47413: PUSH
47414: EMPTY
47415: LIST
47416: LIST
47417: PUSH
47418: EMPTY
47419: LIST
47420: LIST
47421: PUSH
47422: EMPTY
47423: LIST
47424: LIST
47425: LIST
47426: PPUSH
47427: CALL_OW 72
47431: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
47432: LD_ADDR_EXP 103
47436: PUSH
47437: LD_EXP 103
47441: PPUSH
47442: LD_VAR 0 2
47446: PPUSH
47447: LD_VAR 0 3
47451: PPUSH
47452: CALL_OW 1
47456: ST_TO_ADDR
// end ;
47457: GO 47341
47459: POP
47460: POP
// RaiseSailEvent ( 101 ) ;
47461: LD_INT 101
47463: PPUSH
47464: CALL_OW 427
// end ;
47468: LD_VAR 0 1
47472: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
47473: LD_INT 0
47475: PPUSH
47476: PPUSH
47477: PPUSH
47478: PPUSH
47479: PPUSH
47480: PPUSH
47481: PPUSH
// if not mc_bases then
47482: LD_EXP 102
47486: NOT
47487: IFFALSE 47491
// exit ;
47489: GO 48053
// for i = 1 to mc_bases do
47491: LD_ADDR_VAR 0 2
47495: PUSH
47496: DOUBLE
47497: LD_INT 1
47499: DEC
47500: ST_TO_ADDR
47501: LD_EXP 102
47505: PUSH
47506: FOR_TO
47507: IFFALSE 48044
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
47509: LD_ADDR_VAR 0 5
47513: PUSH
47514: LD_EXP 102
47518: PUSH
47519: LD_VAR 0 2
47523: ARRAY
47524: PUSH
47525: LD_EXP 131
47529: PUSH
47530: LD_VAR 0 2
47534: ARRAY
47535: UNION
47536: PPUSH
47537: LD_INT 21
47539: PUSH
47540: LD_INT 1
47542: PUSH
47543: EMPTY
47544: LIST
47545: LIST
47546: PUSH
47547: LD_INT 1
47549: PUSH
47550: LD_INT 3
47552: PUSH
47553: LD_INT 54
47555: PUSH
47556: EMPTY
47557: LIST
47558: PUSH
47559: EMPTY
47560: LIST
47561: LIST
47562: PUSH
47563: LD_INT 3
47565: PUSH
47566: LD_INT 24
47568: PUSH
47569: LD_INT 1000
47571: PUSH
47572: EMPTY
47573: LIST
47574: LIST
47575: PUSH
47576: EMPTY
47577: LIST
47578: LIST
47579: PUSH
47580: EMPTY
47581: LIST
47582: LIST
47583: LIST
47584: PUSH
47585: EMPTY
47586: LIST
47587: LIST
47588: PPUSH
47589: CALL_OW 72
47593: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
47594: LD_ADDR_VAR 0 6
47598: PUSH
47599: LD_EXP 102
47603: PUSH
47604: LD_VAR 0 2
47608: ARRAY
47609: PPUSH
47610: LD_INT 21
47612: PUSH
47613: LD_INT 1
47615: PUSH
47616: EMPTY
47617: LIST
47618: LIST
47619: PUSH
47620: LD_INT 1
47622: PUSH
47623: LD_INT 3
47625: PUSH
47626: LD_INT 54
47628: PUSH
47629: EMPTY
47630: LIST
47631: PUSH
47632: EMPTY
47633: LIST
47634: LIST
47635: PUSH
47636: LD_INT 3
47638: PUSH
47639: LD_INT 24
47641: PUSH
47642: LD_INT 250
47644: PUSH
47645: EMPTY
47646: LIST
47647: LIST
47648: PUSH
47649: EMPTY
47650: LIST
47651: LIST
47652: PUSH
47653: EMPTY
47654: LIST
47655: LIST
47656: LIST
47657: PUSH
47658: EMPTY
47659: LIST
47660: LIST
47661: PPUSH
47662: CALL_OW 72
47666: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
47667: LD_ADDR_VAR 0 7
47671: PUSH
47672: LD_VAR 0 5
47676: PUSH
47677: LD_VAR 0 6
47681: DIFF
47682: ST_TO_ADDR
// if not need_heal_1 then
47683: LD_VAR 0 6
47687: NOT
47688: IFFALSE 47721
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
47690: LD_ADDR_EXP 105
47694: PUSH
47695: LD_EXP 105
47699: PPUSH
47700: LD_VAR 0 2
47704: PUSH
47705: LD_INT 1
47707: PUSH
47708: EMPTY
47709: LIST
47710: LIST
47711: PPUSH
47712: EMPTY
47713: PPUSH
47714: CALL 74632 0 3
47718: ST_TO_ADDR
47719: GO 47791
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
47721: LD_ADDR_EXP 105
47725: PUSH
47726: LD_EXP 105
47730: PPUSH
47731: LD_VAR 0 2
47735: PUSH
47736: LD_INT 1
47738: PUSH
47739: EMPTY
47740: LIST
47741: LIST
47742: PPUSH
47743: LD_EXP 105
47747: PUSH
47748: LD_VAR 0 2
47752: ARRAY
47753: PUSH
47754: LD_INT 1
47756: ARRAY
47757: PPUSH
47758: LD_INT 3
47760: PUSH
47761: LD_INT 24
47763: PUSH
47764: LD_INT 1000
47766: PUSH
47767: EMPTY
47768: LIST
47769: LIST
47770: PUSH
47771: EMPTY
47772: LIST
47773: LIST
47774: PPUSH
47775: CALL_OW 72
47779: PUSH
47780: LD_VAR 0 6
47784: UNION
47785: PPUSH
47786: CALL 74632 0 3
47790: ST_TO_ADDR
// if not need_heal_2 then
47791: LD_VAR 0 7
47795: NOT
47796: IFFALSE 47829
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
47798: LD_ADDR_EXP 105
47802: PUSH
47803: LD_EXP 105
47807: PPUSH
47808: LD_VAR 0 2
47812: PUSH
47813: LD_INT 2
47815: PUSH
47816: EMPTY
47817: LIST
47818: LIST
47819: PPUSH
47820: EMPTY
47821: PPUSH
47822: CALL 74632 0 3
47826: ST_TO_ADDR
47827: GO 47861
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
47829: LD_ADDR_EXP 105
47833: PUSH
47834: LD_EXP 105
47838: PPUSH
47839: LD_VAR 0 2
47843: PUSH
47844: LD_INT 2
47846: PUSH
47847: EMPTY
47848: LIST
47849: LIST
47850: PPUSH
47851: LD_VAR 0 7
47855: PPUSH
47856: CALL 74632 0 3
47860: ST_TO_ADDR
// if need_heal_2 then
47861: LD_VAR 0 7
47865: IFFALSE 48026
// for j in need_heal_2 do
47867: LD_ADDR_VAR 0 3
47871: PUSH
47872: LD_VAR 0 7
47876: PUSH
47877: FOR_IN
47878: IFFALSE 48024
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47880: LD_ADDR_VAR 0 5
47884: PUSH
47885: LD_EXP 102
47889: PUSH
47890: LD_VAR 0 2
47894: ARRAY
47895: PPUSH
47896: LD_INT 2
47898: PUSH
47899: LD_INT 30
47901: PUSH
47902: LD_INT 6
47904: PUSH
47905: EMPTY
47906: LIST
47907: LIST
47908: PUSH
47909: LD_INT 30
47911: PUSH
47912: LD_INT 7
47914: PUSH
47915: EMPTY
47916: LIST
47917: LIST
47918: PUSH
47919: LD_INT 30
47921: PUSH
47922: LD_INT 8
47924: PUSH
47925: EMPTY
47926: LIST
47927: LIST
47928: PUSH
47929: LD_INT 30
47931: PUSH
47932: LD_INT 0
47934: PUSH
47935: EMPTY
47936: LIST
47937: LIST
47938: PUSH
47939: LD_INT 30
47941: PUSH
47942: LD_INT 1
47944: PUSH
47945: EMPTY
47946: LIST
47947: LIST
47948: PUSH
47949: EMPTY
47950: LIST
47951: LIST
47952: LIST
47953: LIST
47954: LIST
47955: LIST
47956: PPUSH
47957: CALL_OW 72
47961: ST_TO_ADDR
// if tmp then
47962: LD_VAR 0 5
47966: IFFALSE 48022
// begin k := NearestUnitToUnit ( tmp , j ) ;
47968: LD_ADDR_VAR 0 4
47972: PUSH
47973: LD_VAR 0 5
47977: PPUSH
47978: LD_VAR 0 3
47982: PPUSH
47983: CALL_OW 74
47987: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
47988: LD_VAR 0 3
47992: PPUSH
47993: LD_VAR 0 4
47997: PPUSH
47998: CALL_OW 296
48002: PUSH
48003: LD_INT 5
48005: GREATER
48006: IFFALSE 48022
// ComMoveToNearbyEntrance ( j , k ) ;
48008: LD_VAR 0 3
48012: PPUSH
48013: LD_VAR 0 4
48017: PPUSH
48018: CALL 108238 0 2
// end ; end ;
48022: GO 47877
48024: POP
48025: POP
// if not need_heal_1 and not need_heal_2 then
48026: LD_VAR 0 6
48030: NOT
48031: PUSH
48032: LD_VAR 0 7
48036: NOT
48037: AND
48038: IFFALSE 48042
// continue ;
48040: GO 47506
// end ;
48042: GO 47506
48044: POP
48045: POP
// RaiseSailEvent ( 102 ) ;
48046: LD_INT 102
48048: PPUSH
48049: CALL_OW 427
// end ;
48053: LD_VAR 0 1
48057: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
48058: LD_INT 0
48060: PPUSH
48061: PPUSH
48062: PPUSH
48063: PPUSH
48064: PPUSH
48065: PPUSH
48066: PPUSH
48067: PPUSH
// if not mc_bases then
48068: LD_EXP 102
48072: NOT
48073: IFFALSE 48077
// exit ;
48075: GO 48988
// for i = 1 to mc_bases do
48077: LD_ADDR_VAR 0 2
48081: PUSH
48082: DOUBLE
48083: LD_INT 1
48085: DEC
48086: ST_TO_ADDR
48087: LD_EXP 102
48091: PUSH
48092: FOR_TO
48093: IFFALSE 48986
// begin if not mc_building_need_repair [ i ] then
48095: LD_EXP 103
48099: PUSH
48100: LD_VAR 0 2
48104: ARRAY
48105: NOT
48106: IFFALSE 48291
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
48108: LD_ADDR_VAR 0 6
48112: PUSH
48113: LD_EXP 121
48117: PUSH
48118: LD_VAR 0 2
48122: ARRAY
48123: PPUSH
48124: LD_INT 3
48126: PUSH
48127: LD_INT 24
48129: PUSH
48130: LD_INT 1000
48132: PUSH
48133: EMPTY
48134: LIST
48135: LIST
48136: PUSH
48137: EMPTY
48138: LIST
48139: LIST
48140: PUSH
48141: LD_INT 2
48143: PUSH
48144: LD_INT 34
48146: PUSH
48147: LD_INT 13
48149: PUSH
48150: EMPTY
48151: LIST
48152: LIST
48153: PUSH
48154: LD_INT 34
48156: PUSH
48157: LD_INT 52
48159: PUSH
48160: EMPTY
48161: LIST
48162: LIST
48163: PUSH
48164: LD_INT 34
48166: PUSH
48167: LD_INT 88
48169: PUSH
48170: EMPTY
48171: LIST
48172: LIST
48173: PUSH
48174: EMPTY
48175: LIST
48176: LIST
48177: LIST
48178: LIST
48179: PUSH
48180: EMPTY
48181: LIST
48182: LIST
48183: PPUSH
48184: CALL_OW 72
48188: ST_TO_ADDR
// if cranes then
48189: LD_VAR 0 6
48193: IFFALSE 48255
// for j in cranes do
48195: LD_ADDR_VAR 0 3
48199: PUSH
48200: LD_VAR 0 6
48204: PUSH
48205: FOR_IN
48206: IFFALSE 48253
// if not IsInArea ( j , mc_parking [ i ] ) then
48208: LD_VAR 0 3
48212: PPUSH
48213: LD_EXP 126
48217: PUSH
48218: LD_VAR 0 2
48222: ARRAY
48223: PPUSH
48224: CALL_OW 308
48228: NOT
48229: IFFALSE 48251
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48231: LD_VAR 0 3
48235: PPUSH
48236: LD_EXP 126
48240: PUSH
48241: LD_VAR 0 2
48245: ARRAY
48246: PPUSH
48247: CALL_OW 113
48251: GO 48205
48253: POP
48254: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
48255: LD_ADDR_EXP 104
48259: PUSH
48260: LD_EXP 104
48264: PPUSH
48265: LD_VAR 0 2
48269: PPUSH
48270: EMPTY
48271: PPUSH
48272: CALL_OW 1
48276: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
48277: LD_VAR 0 2
48281: PPUSH
48282: LD_INT 101
48284: PPUSH
48285: CALL 43131 0 2
// continue ;
48289: GO 48092
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
48291: LD_ADDR_EXP 108
48295: PUSH
48296: LD_EXP 108
48300: PPUSH
48301: LD_VAR 0 2
48305: PPUSH
48306: EMPTY
48307: PPUSH
48308: CALL_OW 1
48312: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
48313: LD_VAR 0 2
48317: PPUSH
48318: LD_INT 103
48320: PPUSH
48321: CALL 43131 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
48325: LD_ADDR_VAR 0 5
48329: PUSH
48330: LD_EXP 102
48334: PUSH
48335: LD_VAR 0 2
48339: ARRAY
48340: PUSH
48341: LD_EXP 131
48345: PUSH
48346: LD_VAR 0 2
48350: ARRAY
48351: UNION
48352: PPUSH
48353: LD_INT 2
48355: PUSH
48356: LD_INT 25
48358: PUSH
48359: LD_INT 2
48361: PUSH
48362: EMPTY
48363: LIST
48364: LIST
48365: PUSH
48366: LD_INT 25
48368: PUSH
48369: LD_INT 16
48371: PUSH
48372: EMPTY
48373: LIST
48374: LIST
48375: PUSH
48376: EMPTY
48377: LIST
48378: LIST
48379: LIST
48380: PUSH
48381: EMPTY
48382: LIST
48383: PPUSH
48384: CALL_OW 72
48388: ST_TO_ADDR
// if mc_need_heal [ i ] then
48389: LD_EXP 105
48393: PUSH
48394: LD_VAR 0 2
48398: ARRAY
48399: IFFALSE 48443
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
48401: LD_ADDR_VAR 0 5
48405: PUSH
48406: LD_VAR 0 5
48410: PUSH
48411: LD_EXP 105
48415: PUSH
48416: LD_VAR 0 2
48420: ARRAY
48421: PUSH
48422: LD_INT 1
48424: ARRAY
48425: PUSH
48426: LD_EXP 105
48430: PUSH
48431: LD_VAR 0 2
48435: ARRAY
48436: PUSH
48437: LD_INT 2
48439: ARRAY
48440: UNION
48441: DIFF
48442: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
48443: LD_ADDR_VAR 0 6
48447: PUSH
48448: LD_EXP 121
48452: PUSH
48453: LD_VAR 0 2
48457: ARRAY
48458: PPUSH
48459: LD_INT 2
48461: PUSH
48462: LD_INT 34
48464: PUSH
48465: LD_INT 13
48467: PUSH
48468: EMPTY
48469: LIST
48470: LIST
48471: PUSH
48472: LD_INT 34
48474: PUSH
48475: LD_INT 52
48477: PUSH
48478: EMPTY
48479: LIST
48480: LIST
48481: PUSH
48482: LD_INT 34
48484: PUSH
48485: LD_INT 88
48487: PUSH
48488: EMPTY
48489: LIST
48490: LIST
48491: PUSH
48492: EMPTY
48493: LIST
48494: LIST
48495: LIST
48496: LIST
48497: PPUSH
48498: CALL_OW 72
48502: ST_TO_ADDR
// if cranes then
48503: LD_VAR 0 6
48507: IFFALSE 48675
// begin for j in cranes do
48509: LD_ADDR_VAR 0 3
48513: PUSH
48514: LD_VAR 0 6
48518: PUSH
48519: FOR_IN
48520: IFFALSE 48673
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
48522: LD_VAR 0 3
48526: PPUSH
48527: CALL_OW 256
48531: PUSH
48532: LD_INT 1000
48534: EQUAL
48535: PUSH
48536: LD_VAR 0 3
48540: PPUSH
48541: CALL_OW 314
48545: NOT
48546: AND
48547: IFFALSE 48613
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
48549: LD_ADDR_VAR 0 8
48553: PUSH
48554: LD_EXP 103
48558: PUSH
48559: LD_VAR 0 2
48563: ARRAY
48564: PPUSH
48565: LD_VAR 0 3
48569: PPUSH
48570: CALL_OW 74
48574: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
48575: LD_VAR 0 8
48579: PPUSH
48580: LD_INT 16
48582: PPUSH
48583: CALL 77597 0 2
48587: PUSH
48588: LD_INT 4
48590: ARRAY
48591: PUSH
48592: LD_INT 10
48594: LESS
48595: IFFALSE 48611
// ComRepairBuilding ( j , to_repair ) ;
48597: LD_VAR 0 3
48601: PPUSH
48602: LD_VAR 0 8
48606: PPUSH
48607: CALL_OW 130
// end else
48611: GO 48671
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
48613: LD_VAR 0 3
48617: PPUSH
48618: CALL_OW 256
48622: PUSH
48623: LD_INT 500
48625: LESS
48626: PUSH
48627: LD_VAR 0 3
48631: PPUSH
48632: LD_EXP 126
48636: PUSH
48637: LD_VAR 0 2
48641: ARRAY
48642: PPUSH
48643: CALL_OW 308
48647: NOT
48648: AND
48649: IFFALSE 48671
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48651: LD_VAR 0 3
48655: PPUSH
48656: LD_EXP 126
48660: PUSH
48661: LD_VAR 0 2
48665: ARRAY
48666: PPUSH
48667: CALL_OW 113
// end ;
48671: GO 48519
48673: POP
48674: POP
// end ; if tmp > 3 then
48675: LD_VAR 0 5
48679: PUSH
48680: LD_INT 3
48682: GREATER
48683: IFFALSE 48703
// tmp := ShrinkArray ( tmp , 4 ) ;
48685: LD_ADDR_VAR 0 5
48689: PUSH
48690: LD_VAR 0 5
48694: PPUSH
48695: LD_INT 4
48697: PPUSH
48698: CALL 107676 0 2
48702: ST_TO_ADDR
// if not tmp then
48703: LD_VAR 0 5
48707: NOT
48708: IFFALSE 48712
// continue ;
48710: GO 48092
// for j in tmp do
48712: LD_ADDR_VAR 0 3
48716: PUSH
48717: LD_VAR 0 5
48721: PUSH
48722: FOR_IN
48723: IFFALSE 48982
// begin if IsInUnit ( j ) then
48725: LD_VAR 0 3
48729: PPUSH
48730: CALL_OW 310
48734: IFFALSE 48745
// ComExitBuilding ( j ) ;
48736: LD_VAR 0 3
48740: PPUSH
48741: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
48745: LD_VAR 0 3
48749: PUSH
48750: LD_EXP 104
48754: PUSH
48755: LD_VAR 0 2
48759: ARRAY
48760: IN
48761: NOT
48762: IFFALSE 48820
// begin SetTag ( j , 101 ) ;
48764: LD_VAR 0 3
48768: PPUSH
48769: LD_INT 101
48771: PPUSH
48772: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
48776: LD_ADDR_EXP 104
48780: PUSH
48781: LD_EXP 104
48785: PPUSH
48786: LD_VAR 0 2
48790: PUSH
48791: LD_EXP 104
48795: PUSH
48796: LD_VAR 0 2
48800: ARRAY
48801: PUSH
48802: LD_INT 1
48804: PLUS
48805: PUSH
48806: EMPTY
48807: LIST
48808: LIST
48809: PPUSH
48810: LD_VAR 0 3
48814: PPUSH
48815: CALL 74632 0 3
48819: ST_TO_ADDR
// end ; wait ( 1 ) ;
48820: LD_INT 1
48822: PPUSH
48823: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
48827: LD_ADDR_VAR 0 7
48831: PUSH
48832: LD_EXP 103
48836: PUSH
48837: LD_VAR 0 2
48841: ARRAY
48842: ST_TO_ADDR
// if mc_scan [ i ] then
48843: LD_EXP 125
48847: PUSH
48848: LD_VAR 0 2
48852: ARRAY
48853: IFFALSE 48915
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
48855: LD_ADDR_VAR 0 7
48859: PUSH
48860: LD_EXP 103
48864: PUSH
48865: LD_VAR 0 2
48869: ARRAY
48870: PPUSH
48871: LD_INT 3
48873: PUSH
48874: LD_INT 30
48876: PUSH
48877: LD_INT 32
48879: PUSH
48880: EMPTY
48881: LIST
48882: LIST
48883: PUSH
48884: LD_INT 30
48886: PUSH
48887: LD_INT 33
48889: PUSH
48890: EMPTY
48891: LIST
48892: LIST
48893: PUSH
48894: LD_INT 30
48896: PUSH
48897: LD_INT 31
48899: PUSH
48900: EMPTY
48901: LIST
48902: LIST
48903: PUSH
48904: EMPTY
48905: LIST
48906: LIST
48907: LIST
48908: LIST
48909: PPUSH
48910: CALL_OW 72
48914: ST_TO_ADDR
// if not to_repair_tmp then
48915: LD_VAR 0 7
48919: NOT
48920: IFFALSE 48924
// continue ;
48922: GO 48722
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
48924: LD_ADDR_VAR 0 8
48928: PUSH
48929: LD_VAR 0 7
48933: PPUSH
48934: LD_VAR 0 3
48938: PPUSH
48939: CALL_OW 74
48943: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
48944: LD_VAR 0 8
48948: PPUSH
48949: LD_INT 16
48951: PPUSH
48952: CALL 77597 0 2
48956: PUSH
48957: LD_INT 4
48959: ARRAY
48960: PUSH
48961: LD_INT 14
48963: LESS
48964: IFFALSE 48980
// ComRepairBuilding ( j , to_repair ) ;
48966: LD_VAR 0 3
48970: PPUSH
48971: LD_VAR 0 8
48975: PPUSH
48976: CALL_OW 130
// end ;
48980: GO 48722
48982: POP
48983: POP
// end ;
48984: GO 48092
48986: POP
48987: POP
// end ;
48988: LD_VAR 0 1
48992: RET
// export function MC_Heal ; var i , j , tmp ; begin
48993: LD_INT 0
48995: PPUSH
48996: PPUSH
48997: PPUSH
48998: PPUSH
// if not mc_bases then
48999: LD_EXP 102
49003: NOT
49004: IFFALSE 49008
// exit ;
49006: GO 49410
// for i = 1 to mc_bases do
49008: LD_ADDR_VAR 0 2
49012: PUSH
49013: DOUBLE
49014: LD_INT 1
49016: DEC
49017: ST_TO_ADDR
49018: LD_EXP 102
49022: PUSH
49023: FOR_TO
49024: IFFALSE 49408
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
49026: LD_EXP 105
49030: PUSH
49031: LD_VAR 0 2
49035: ARRAY
49036: PUSH
49037: LD_INT 1
49039: ARRAY
49040: NOT
49041: PUSH
49042: LD_EXP 105
49046: PUSH
49047: LD_VAR 0 2
49051: ARRAY
49052: PUSH
49053: LD_INT 2
49055: ARRAY
49056: NOT
49057: AND
49058: IFFALSE 49096
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
49060: LD_ADDR_EXP 106
49064: PUSH
49065: LD_EXP 106
49069: PPUSH
49070: LD_VAR 0 2
49074: PPUSH
49075: EMPTY
49076: PPUSH
49077: CALL_OW 1
49081: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
49082: LD_VAR 0 2
49086: PPUSH
49087: LD_INT 102
49089: PPUSH
49090: CALL 43131 0 2
// continue ;
49094: GO 49023
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
49096: LD_ADDR_VAR 0 4
49100: PUSH
49101: LD_EXP 102
49105: PUSH
49106: LD_VAR 0 2
49110: ARRAY
49111: PPUSH
49112: LD_INT 25
49114: PUSH
49115: LD_INT 4
49117: PUSH
49118: EMPTY
49119: LIST
49120: LIST
49121: PPUSH
49122: CALL_OW 72
49126: ST_TO_ADDR
// if not tmp then
49127: LD_VAR 0 4
49131: NOT
49132: IFFALSE 49136
// continue ;
49134: GO 49023
// if mc_taming [ i ] then
49136: LD_EXP 133
49140: PUSH
49141: LD_VAR 0 2
49145: ARRAY
49146: IFFALSE 49170
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
49148: LD_ADDR_EXP 133
49152: PUSH
49153: LD_EXP 133
49157: PPUSH
49158: LD_VAR 0 2
49162: PPUSH
49163: EMPTY
49164: PPUSH
49165: CALL_OW 1
49169: ST_TO_ADDR
// for j in tmp do
49170: LD_ADDR_VAR 0 3
49174: PUSH
49175: LD_VAR 0 4
49179: PUSH
49180: FOR_IN
49181: IFFALSE 49404
// begin if IsInUnit ( j ) then
49183: LD_VAR 0 3
49187: PPUSH
49188: CALL_OW 310
49192: IFFALSE 49203
// ComExitBuilding ( j ) ;
49194: LD_VAR 0 3
49198: PPUSH
49199: CALL_OW 122
// if not j in mc_healers [ i ] then
49203: LD_VAR 0 3
49207: PUSH
49208: LD_EXP 106
49212: PUSH
49213: LD_VAR 0 2
49217: ARRAY
49218: IN
49219: NOT
49220: IFFALSE 49266
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
49222: LD_ADDR_EXP 106
49226: PUSH
49227: LD_EXP 106
49231: PPUSH
49232: LD_VAR 0 2
49236: PUSH
49237: LD_EXP 106
49241: PUSH
49242: LD_VAR 0 2
49246: ARRAY
49247: PUSH
49248: LD_INT 1
49250: PLUS
49251: PUSH
49252: EMPTY
49253: LIST
49254: LIST
49255: PPUSH
49256: LD_VAR 0 3
49260: PPUSH
49261: CALL 74632 0 3
49265: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
49266: LD_VAR 0 3
49270: PPUSH
49271: CALL_OW 110
49275: PUSH
49276: LD_INT 102
49278: NONEQUAL
49279: IFFALSE 49293
// SetTag ( j , 102 ) ;
49281: LD_VAR 0 3
49285: PPUSH
49286: LD_INT 102
49288: PPUSH
49289: CALL_OW 109
// Wait ( 3 ) ;
49293: LD_INT 3
49295: PPUSH
49296: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
49300: LD_EXP 105
49304: PUSH
49305: LD_VAR 0 2
49309: ARRAY
49310: PUSH
49311: LD_INT 1
49313: ARRAY
49314: IFFALSE 49346
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
49316: LD_VAR 0 3
49320: PPUSH
49321: LD_EXP 105
49325: PUSH
49326: LD_VAR 0 2
49330: ARRAY
49331: PUSH
49332: LD_INT 1
49334: ARRAY
49335: PUSH
49336: LD_INT 1
49338: ARRAY
49339: PPUSH
49340: CALL_OW 128
49344: GO 49402
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
49346: LD_VAR 0 3
49350: PPUSH
49351: CALL_OW 314
49355: NOT
49356: PUSH
49357: LD_EXP 105
49361: PUSH
49362: LD_VAR 0 2
49366: ARRAY
49367: PUSH
49368: LD_INT 2
49370: ARRAY
49371: AND
49372: IFFALSE 49402
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
49374: LD_VAR 0 3
49378: PPUSH
49379: LD_EXP 105
49383: PUSH
49384: LD_VAR 0 2
49388: ARRAY
49389: PUSH
49390: LD_INT 2
49392: ARRAY
49393: PUSH
49394: LD_INT 1
49396: ARRAY
49397: PPUSH
49398: CALL_OW 128
// end ;
49402: GO 49180
49404: POP
49405: POP
// end ;
49406: GO 49023
49408: POP
49409: POP
// end ;
49410: LD_VAR 0 1
49414: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
49415: LD_INT 0
49417: PPUSH
49418: PPUSH
49419: PPUSH
49420: PPUSH
49421: PPUSH
49422: PPUSH
// if not mc_bases then
49423: LD_EXP 102
49427: NOT
49428: IFFALSE 49432
// exit ;
49430: GO 50595
// for i = 1 to mc_bases do
49432: LD_ADDR_VAR 0 2
49436: PUSH
49437: DOUBLE
49438: LD_INT 1
49440: DEC
49441: ST_TO_ADDR
49442: LD_EXP 102
49446: PUSH
49447: FOR_TO
49448: IFFALSE 50593
// begin if mc_scan [ i ] then
49450: LD_EXP 125
49454: PUSH
49455: LD_VAR 0 2
49459: ARRAY
49460: IFFALSE 49464
// continue ;
49462: GO 49447
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
49464: LD_EXP 107
49468: PUSH
49469: LD_VAR 0 2
49473: ARRAY
49474: NOT
49475: PUSH
49476: LD_EXP 109
49480: PUSH
49481: LD_VAR 0 2
49485: ARRAY
49486: NOT
49487: AND
49488: PUSH
49489: LD_EXP 108
49493: PUSH
49494: LD_VAR 0 2
49498: ARRAY
49499: AND
49500: IFFALSE 49538
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
49502: LD_ADDR_EXP 108
49506: PUSH
49507: LD_EXP 108
49511: PPUSH
49512: LD_VAR 0 2
49516: PPUSH
49517: EMPTY
49518: PPUSH
49519: CALL_OW 1
49523: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
49524: LD_VAR 0 2
49528: PPUSH
49529: LD_INT 103
49531: PPUSH
49532: CALL 43131 0 2
// continue ;
49536: GO 49447
// end ; if mc_construct_list [ i ] then
49538: LD_EXP 109
49542: PUSH
49543: LD_VAR 0 2
49547: ARRAY
49548: IFFALSE 49768
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
49550: LD_ADDR_VAR 0 5
49554: PUSH
49555: LD_EXP 102
49559: PUSH
49560: LD_VAR 0 2
49564: ARRAY
49565: PPUSH
49566: LD_INT 25
49568: PUSH
49569: LD_INT 2
49571: PUSH
49572: EMPTY
49573: LIST
49574: LIST
49575: PPUSH
49576: CALL_OW 72
49580: PUSH
49581: LD_EXP 104
49585: PUSH
49586: LD_VAR 0 2
49590: ARRAY
49591: DIFF
49592: ST_TO_ADDR
// if not tmp then
49593: LD_VAR 0 5
49597: NOT
49598: IFFALSE 49602
// continue ;
49600: GO 49447
// for j in tmp do
49602: LD_ADDR_VAR 0 3
49606: PUSH
49607: LD_VAR 0 5
49611: PUSH
49612: FOR_IN
49613: IFFALSE 49764
// begin if not mc_builders [ i ] then
49615: LD_EXP 108
49619: PUSH
49620: LD_VAR 0 2
49624: ARRAY
49625: NOT
49626: IFFALSE 49684
// begin SetTag ( j , 103 ) ;
49628: LD_VAR 0 3
49632: PPUSH
49633: LD_INT 103
49635: PPUSH
49636: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
49640: LD_ADDR_EXP 108
49644: PUSH
49645: LD_EXP 108
49649: PPUSH
49650: LD_VAR 0 2
49654: PUSH
49655: LD_EXP 108
49659: PUSH
49660: LD_VAR 0 2
49664: ARRAY
49665: PUSH
49666: LD_INT 1
49668: PLUS
49669: PUSH
49670: EMPTY
49671: LIST
49672: LIST
49673: PPUSH
49674: LD_VAR 0 3
49678: PPUSH
49679: CALL 74632 0 3
49683: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
49684: LD_VAR 0 3
49688: PPUSH
49689: CALL_OW 310
49693: IFFALSE 49704
// ComExitBuilding ( j ) ;
49695: LD_VAR 0 3
49699: PPUSH
49700: CALL_OW 122
// wait ( 3 ) ;
49704: LD_INT 3
49706: PPUSH
49707: CALL_OW 67
// if not mc_construct_list [ i ] then
49711: LD_EXP 109
49715: PUSH
49716: LD_VAR 0 2
49720: ARRAY
49721: NOT
49722: IFFALSE 49726
// break ;
49724: GO 49764
// if not HasTask ( j ) then
49726: LD_VAR 0 3
49730: PPUSH
49731: CALL_OW 314
49735: NOT
49736: IFFALSE 49762
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
49738: LD_VAR 0 3
49742: PPUSH
49743: LD_EXP 109
49747: PUSH
49748: LD_VAR 0 2
49752: ARRAY
49753: PUSH
49754: LD_INT 1
49756: ARRAY
49757: PPUSH
49758: CALL 77870 0 2
// end ;
49762: GO 49612
49764: POP
49765: POP
// end else
49766: GO 50591
// if mc_build_list [ i ] then
49768: LD_EXP 107
49772: PUSH
49773: LD_VAR 0 2
49777: ARRAY
49778: IFFALSE 50591
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
49780: LD_EXP 107
49784: PUSH
49785: LD_VAR 0 2
49789: ARRAY
49790: PUSH
49791: LD_INT 1
49793: ARRAY
49794: PUSH
49795: LD_INT 1
49797: ARRAY
49798: PPUSH
49799: CALL 77694 0 1
49803: PUSH
49804: LD_EXP 102
49808: PUSH
49809: LD_VAR 0 2
49813: ARRAY
49814: PPUSH
49815: LD_INT 2
49817: PUSH
49818: LD_INT 30
49820: PUSH
49821: LD_INT 2
49823: PUSH
49824: EMPTY
49825: LIST
49826: LIST
49827: PUSH
49828: LD_INT 30
49830: PUSH
49831: LD_INT 3
49833: PUSH
49834: EMPTY
49835: LIST
49836: LIST
49837: PUSH
49838: EMPTY
49839: LIST
49840: LIST
49841: LIST
49842: PPUSH
49843: CALL_OW 72
49847: NOT
49848: AND
49849: IFFALSE 49954
// begin for j = 1 to mc_build_list [ i ] do
49851: LD_ADDR_VAR 0 3
49855: PUSH
49856: DOUBLE
49857: LD_INT 1
49859: DEC
49860: ST_TO_ADDR
49861: LD_EXP 107
49865: PUSH
49866: LD_VAR 0 2
49870: ARRAY
49871: PUSH
49872: FOR_TO
49873: IFFALSE 49952
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
49875: LD_EXP 107
49879: PUSH
49880: LD_VAR 0 2
49884: ARRAY
49885: PUSH
49886: LD_VAR 0 3
49890: ARRAY
49891: PUSH
49892: LD_INT 1
49894: ARRAY
49895: PUSH
49896: LD_INT 2
49898: EQUAL
49899: IFFALSE 49950
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
49901: LD_ADDR_EXP 107
49905: PUSH
49906: LD_EXP 107
49910: PPUSH
49911: LD_VAR 0 2
49915: PPUSH
49916: LD_EXP 107
49920: PUSH
49921: LD_VAR 0 2
49925: ARRAY
49926: PPUSH
49927: LD_VAR 0 3
49931: PPUSH
49932: LD_INT 1
49934: PPUSH
49935: LD_INT 0
49937: PPUSH
49938: CALL 74050 0 4
49942: PPUSH
49943: CALL_OW 1
49947: ST_TO_ADDR
// break ;
49948: GO 49952
// end ;
49950: GO 49872
49952: POP
49953: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49954: LD_ADDR_VAR 0 6
49958: PUSH
49959: LD_EXP 102
49963: PUSH
49964: LD_VAR 0 2
49968: ARRAY
49969: PPUSH
49970: LD_INT 2
49972: PUSH
49973: LD_INT 30
49975: PUSH
49976: LD_INT 0
49978: PUSH
49979: EMPTY
49980: LIST
49981: LIST
49982: PUSH
49983: LD_INT 30
49985: PUSH
49986: LD_INT 1
49988: PUSH
49989: EMPTY
49990: LIST
49991: LIST
49992: PUSH
49993: EMPTY
49994: LIST
49995: LIST
49996: LIST
49997: PPUSH
49998: CALL_OW 72
50002: ST_TO_ADDR
// for k := 1 to depot do
50003: LD_ADDR_VAR 0 4
50007: PUSH
50008: DOUBLE
50009: LD_INT 1
50011: DEC
50012: ST_TO_ADDR
50013: LD_VAR 0 6
50017: PUSH
50018: FOR_TO
50019: IFFALSE 50589
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
50021: LD_EXP 107
50025: PUSH
50026: LD_VAR 0 2
50030: ARRAY
50031: PUSH
50032: LD_INT 1
50034: ARRAY
50035: PUSH
50036: LD_INT 1
50038: ARRAY
50039: PUSH
50040: LD_INT 0
50042: EQUAL
50043: PUSH
50044: LD_VAR 0 6
50048: PUSH
50049: LD_VAR 0 4
50053: ARRAY
50054: PPUSH
50055: LD_EXP 107
50059: PUSH
50060: LD_VAR 0 2
50064: ARRAY
50065: PUSH
50066: LD_INT 1
50068: ARRAY
50069: PUSH
50070: LD_INT 1
50072: ARRAY
50073: PPUSH
50074: LD_EXP 107
50078: PUSH
50079: LD_VAR 0 2
50083: ARRAY
50084: PUSH
50085: LD_INT 1
50087: ARRAY
50088: PUSH
50089: LD_INT 2
50091: ARRAY
50092: PPUSH
50093: LD_EXP 107
50097: PUSH
50098: LD_VAR 0 2
50102: ARRAY
50103: PUSH
50104: LD_INT 1
50106: ARRAY
50107: PUSH
50108: LD_INT 3
50110: ARRAY
50111: PPUSH
50112: LD_EXP 107
50116: PUSH
50117: LD_VAR 0 2
50121: ARRAY
50122: PUSH
50123: LD_INT 1
50125: ARRAY
50126: PUSH
50127: LD_INT 4
50129: ARRAY
50130: PPUSH
50131: CALL 83106 0 5
50135: OR
50136: IFFALSE 50417
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
50138: LD_ADDR_VAR 0 5
50142: PUSH
50143: LD_EXP 102
50147: PUSH
50148: LD_VAR 0 2
50152: ARRAY
50153: PPUSH
50154: LD_INT 25
50156: PUSH
50157: LD_INT 2
50159: PUSH
50160: EMPTY
50161: LIST
50162: LIST
50163: PPUSH
50164: CALL_OW 72
50168: PUSH
50169: LD_EXP 104
50173: PUSH
50174: LD_VAR 0 2
50178: ARRAY
50179: DIFF
50180: ST_TO_ADDR
// if not tmp then
50181: LD_VAR 0 5
50185: NOT
50186: IFFALSE 50190
// continue ;
50188: GO 50018
// for j in tmp do
50190: LD_ADDR_VAR 0 3
50194: PUSH
50195: LD_VAR 0 5
50199: PUSH
50200: FOR_IN
50201: IFFALSE 50413
// begin if not mc_builders [ i ] then
50203: LD_EXP 108
50207: PUSH
50208: LD_VAR 0 2
50212: ARRAY
50213: NOT
50214: IFFALSE 50272
// begin SetTag ( j , 103 ) ;
50216: LD_VAR 0 3
50220: PPUSH
50221: LD_INT 103
50223: PPUSH
50224: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
50228: LD_ADDR_EXP 108
50232: PUSH
50233: LD_EXP 108
50237: PPUSH
50238: LD_VAR 0 2
50242: PUSH
50243: LD_EXP 108
50247: PUSH
50248: LD_VAR 0 2
50252: ARRAY
50253: PUSH
50254: LD_INT 1
50256: PLUS
50257: PUSH
50258: EMPTY
50259: LIST
50260: LIST
50261: PPUSH
50262: LD_VAR 0 3
50266: PPUSH
50267: CALL 74632 0 3
50271: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
50272: LD_VAR 0 3
50276: PPUSH
50277: CALL_OW 310
50281: IFFALSE 50292
// ComExitBuilding ( j ) ;
50283: LD_VAR 0 3
50287: PPUSH
50288: CALL_OW 122
// wait ( 3 ) ;
50292: LD_INT 3
50294: PPUSH
50295: CALL_OW 67
// if not mc_build_list [ i ] then
50299: LD_EXP 107
50303: PUSH
50304: LD_VAR 0 2
50308: ARRAY
50309: NOT
50310: IFFALSE 50314
// break ;
50312: GO 50413
// if not HasTask ( j ) then
50314: LD_VAR 0 3
50318: PPUSH
50319: CALL_OW 314
50323: NOT
50324: IFFALSE 50411
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
50326: LD_VAR 0 3
50330: PPUSH
50331: LD_EXP 107
50335: PUSH
50336: LD_VAR 0 2
50340: ARRAY
50341: PUSH
50342: LD_INT 1
50344: ARRAY
50345: PUSH
50346: LD_INT 1
50348: ARRAY
50349: PPUSH
50350: LD_EXP 107
50354: PUSH
50355: LD_VAR 0 2
50359: ARRAY
50360: PUSH
50361: LD_INT 1
50363: ARRAY
50364: PUSH
50365: LD_INT 2
50367: ARRAY
50368: PPUSH
50369: LD_EXP 107
50373: PUSH
50374: LD_VAR 0 2
50378: ARRAY
50379: PUSH
50380: LD_INT 1
50382: ARRAY
50383: PUSH
50384: LD_INT 3
50386: ARRAY
50387: PPUSH
50388: LD_EXP 107
50392: PUSH
50393: LD_VAR 0 2
50397: ARRAY
50398: PUSH
50399: LD_INT 1
50401: ARRAY
50402: PUSH
50403: LD_INT 4
50405: ARRAY
50406: PPUSH
50407: CALL_OW 145
// end ;
50411: GO 50200
50413: POP
50414: POP
// end else
50415: GO 50587
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
50417: LD_EXP 102
50421: PUSH
50422: LD_VAR 0 2
50426: ARRAY
50427: PPUSH
50428: LD_EXP 107
50432: PUSH
50433: LD_VAR 0 2
50437: ARRAY
50438: PUSH
50439: LD_INT 1
50441: ARRAY
50442: PUSH
50443: LD_INT 1
50445: ARRAY
50446: PPUSH
50447: LD_EXP 107
50451: PUSH
50452: LD_VAR 0 2
50456: ARRAY
50457: PUSH
50458: LD_INT 1
50460: ARRAY
50461: PUSH
50462: LD_INT 2
50464: ARRAY
50465: PPUSH
50466: LD_EXP 107
50470: PUSH
50471: LD_VAR 0 2
50475: ARRAY
50476: PUSH
50477: LD_INT 1
50479: ARRAY
50480: PUSH
50481: LD_INT 3
50483: ARRAY
50484: PPUSH
50485: LD_EXP 107
50489: PUSH
50490: LD_VAR 0 2
50494: ARRAY
50495: PUSH
50496: LD_INT 1
50498: ARRAY
50499: PUSH
50500: LD_INT 4
50502: ARRAY
50503: PPUSH
50504: LD_EXP 102
50508: PUSH
50509: LD_VAR 0 2
50513: ARRAY
50514: PPUSH
50515: LD_INT 21
50517: PUSH
50518: LD_INT 3
50520: PUSH
50521: EMPTY
50522: LIST
50523: LIST
50524: PPUSH
50525: CALL_OW 72
50529: PPUSH
50530: EMPTY
50531: PPUSH
50532: CALL 81860 0 7
50536: NOT
50537: IFFALSE 50587
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
50539: LD_ADDR_EXP 107
50543: PUSH
50544: LD_EXP 107
50548: PPUSH
50549: LD_VAR 0 2
50553: PPUSH
50554: LD_EXP 107
50558: PUSH
50559: LD_VAR 0 2
50563: ARRAY
50564: PPUSH
50565: LD_INT 1
50567: PPUSH
50568: LD_INT 1
50570: NEG
50571: PPUSH
50572: LD_INT 0
50574: PPUSH
50575: CALL 74050 0 4
50579: PPUSH
50580: CALL_OW 1
50584: ST_TO_ADDR
// continue ;
50585: GO 50018
// end ; end ;
50587: GO 50018
50589: POP
50590: POP
// end ; end ;
50591: GO 49447
50593: POP
50594: POP
// end ;
50595: LD_VAR 0 1
50599: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
50600: LD_INT 0
50602: PPUSH
50603: PPUSH
50604: PPUSH
50605: PPUSH
50606: PPUSH
50607: PPUSH
// if not mc_bases then
50608: LD_EXP 102
50612: NOT
50613: IFFALSE 50617
// exit ;
50615: GO 51044
// for i = 1 to mc_bases do
50617: LD_ADDR_VAR 0 2
50621: PUSH
50622: DOUBLE
50623: LD_INT 1
50625: DEC
50626: ST_TO_ADDR
50627: LD_EXP 102
50631: PUSH
50632: FOR_TO
50633: IFFALSE 51042
// begin tmp := mc_build_upgrade [ i ] ;
50635: LD_ADDR_VAR 0 4
50639: PUSH
50640: LD_EXP 134
50644: PUSH
50645: LD_VAR 0 2
50649: ARRAY
50650: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
50651: LD_ADDR_VAR 0 6
50655: PUSH
50656: LD_EXP 135
50660: PUSH
50661: LD_VAR 0 2
50665: ARRAY
50666: PPUSH
50667: LD_INT 2
50669: PUSH
50670: LD_INT 30
50672: PUSH
50673: LD_INT 6
50675: PUSH
50676: EMPTY
50677: LIST
50678: LIST
50679: PUSH
50680: LD_INT 30
50682: PUSH
50683: LD_INT 7
50685: PUSH
50686: EMPTY
50687: LIST
50688: LIST
50689: PUSH
50690: EMPTY
50691: LIST
50692: LIST
50693: LIST
50694: PPUSH
50695: CALL_OW 72
50699: ST_TO_ADDR
// if not tmp and not lab then
50700: LD_VAR 0 4
50704: NOT
50705: PUSH
50706: LD_VAR 0 6
50710: NOT
50711: AND
50712: IFFALSE 50716
// continue ;
50714: GO 50632
// if tmp then
50716: LD_VAR 0 4
50720: IFFALSE 50840
// for j in tmp do
50722: LD_ADDR_VAR 0 3
50726: PUSH
50727: LD_VAR 0 4
50731: PUSH
50732: FOR_IN
50733: IFFALSE 50838
// begin if UpgradeCost ( j ) then
50735: LD_VAR 0 3
50739: PPUSH
50740: CALL 81520 0 1
50744: IFFALSE 50836
// begin ComUpgrade ( j ) ;
50746: LD_VAR 0 3
50750: PPUSH
50751: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
50755: LD_ADDR_EXP 134
50759: PUSH
50760: LD_EXP 134
50764: PPUSH
50765: LD_VAR 0 2
50769: PPUSH
50770: LD_EXP 134
50774: PUSH
50775: LD_VAR 0 2
50779: ARRAY
50780: PUSH
50781: LD_VAR 0 3
50785: DIFF
50786: PPUSH
50787: CALL_OW 1
50791: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
50792: LD_ADDR_EXP 109
50796: PUSH
50797: LD_EXP 109
50801: PPUSH
50802: LD_VAR 0 2
50806: PUSH
50807: LD_EXP 109
50811: PUSH
50812: LD_VAR 0 2
50816: ARRAY
50817: PUSH
50818: LD_INT 1
50820: PLUS
50821: PUSH
50822: EMPTY
50823: LIST
50824: LIST
50825: PPUSH
50826: LD_VAR 0 3
50830: PPUSH
50831: CALL 74632 0 3
50835: ST_TO_ADDR
// end ; end ;
50836: GO 50732
50838: POP
50839: POP
// if not lab or not mc_lab_upgrade [ i ] then
50840: LD_VAR 0 6
50844: NOT
50845: PUSH
50846: LD_EXP 136
50850: PUSH
50851: LD_VAR 0 2
50855: ARRAY
50856: NOT
50857: OR
50858: IFFALSE 50862
// continue ;
50860: GO 50632
// for j in lab do
50862: LD_ADDR_VAR 0 3
50866: PUSH
50867: LD_VAR 0 6
50871: PUSH
50872: FOR_IN
50873: IFFALSE 51038
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
50875: LD_VAR 0 3
50879: PPUSH
50880: CALL_OW 266
50884: PUSH
50885: LD_INT 6
50887: PUSH
50888: LD_INT 7
50890: PUSH
50891: EMPTY
50892: LIST
50893: LIST
50894: IN
50895: PUSH
50896: LD_VAR 0 3
50900: PPUSH
50901: CALL_OW 461
50905: PUSH
50906: LD_INT 1
50908: NONEQUAL
50909: AND
50910: IFFALSE 51036
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
50912: LD_VAR 0 3
50916: PPUSH
50917: LD_EXP 136
50921: PUSH
50922: LD_VAR 0 2
50926: ARRAY
50927: PUSH
50928: LD_INT 1
50930: ARRAY
50931: PPUSH
50932: CALL 81725 0 2
50936: IFFALSE 51036
// begin ComCancel ( j ) ;
50938: LD_VAR 0 3
50942: PPUSH
50943: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
50947: LD_VAR 0 3
50951: PPUSH
50952: LD_EXP 136
50956: PUSH
50957: LD_VAR 0 2
50961: ARRAY
50962: PUSH
50963: LD_INT 1
50965: ARRAY
50966: PPUSH
50967: CALL_OW 207
// if not j in mc_construct_list [ i ] then
50971: LD_VAR 0 3
50975: PUSH
50976: LD_EXP 109
50980: PUSH
50981: LD_VAR 0 2
50985: ARRAY
50986: IN
50987: NOT
50988: IFFALSE 51034
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
50990: LD_ADDR_EXP 109
50994: PUSH
50995: LD_EXP 109
50999: PPUSH
51000: LD_VAR 0 2
51004: PUSH
51005: LD_EXP 109
51009: PUSH
51010: LD_VAR 0 2
51014: ARRAY
51015: PUSH
51016: LD_INT 1
51018: PLUS
51019: PUSH
51020: EMPTY
51021: LIST
51022: LIST
51023: PPUSH
51024: LD_VAR 0 3
51028: PPUSH
51029: CALL 74632 0 3
51033: ST_TO_ADDR
// break ;
51034: GO 51038
// end ; end ; end ;
51036: GO 50872
51038: POP
51039: POP
// end ;
51040: GO 50632
51042: POP
51043: POP
// end ;
51044: LD_VAR 0 1
51048: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
51049: LD_INT 0
51051: PPUSH
51052: PPUSH
51053: PPUSH
51054: PPUSH
51055: PPUSH
51056: PPUSH
51057: PPUSH
51058: PPUSH
51059: PPUSH
// if not mc_bases then
51060: LD_EXP 102
51064: NOT
51065: IFFALSE 51069
// exit ;
51067: GO 51474
// for i = 1 to mc_bases do
51069: LD_ADDR_VAR 0 2
51073: PUSH
51074: DOUBLE
51075: LD_INT 1
51077: DEC
51078: ST_TO_ADDR
51079: LD_EXP 102
51083: PUSH
51084: FOR_TO
51085: IFFALSE 51472
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
51087: LD_EXP 110
51091: PUSH
51092: LD_VAR 0 2
51096: ARRAY
51097: NOT
51098: PUSH
51099: LD_EXP 102
51103: PUSH
51104: LD_VAR 0 2
51108: ARRAY
51109: PPUSH
51110: LD_INT 30
51112: PUSH
51113: LD_INT 3
51115: PUSH
51116: EMPTY
51117: LIST
51118: LIST
51119: PPUSH
51120: CALL_OW 72
51124: NOT
51125: OR
51126: IFFALSE 51130
// continue ;
51128: GO 51084
// busy := false ;
51130: LD_ADDR_VAR 0 8
51134: PUSH
51135: LD_INT 0
51137: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51138: LD_ADDR_VAR 0 4
51142: PUSH
51143: LD_EXP 102
51147: PUSH
51148: LD_VAR 0 2
51152: ARRAY
51153: PPUSH
51154: LD_INT 30
51156: PUSH
51157: LD_INT 3
51159: PUSH
51160: EMPTY
51161: LIST
51162: LIST
51163: PPUSH
51164: CALL_OW 72
51168: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
51169: LD_ADDR_VAR 0 6
51173: PUSH
51174: LD_EXP 110
51178: PUSH
51179: LD_VAR 0 2
51183: ARRAY
51184: PPUSH
51185: LD_INT 2
51187: PUSH
51188: LD_INT 30
51190: PUSH
51191: LD_INT 32
51193: PUSH
51194: EMPTY
51195: LIST
51196: LIST
51197: PUSH
51198: LD_INT 30
51200: PUSH
51201: LD_INT 33
51203: PUSH
51204: EMPTY
51205: LIST
51206: LIST
51207: PUSH
51208: EMPTY
51209: LIST
51210: LIST
51211: LIST
51212: PPUSH
51213: CALL_OW 72
51217: ST_TO_ADDR
// if not t then
51218: LD_VAR 0 6
51222: NOT
51223: IFFALSE 51227
// continue ;
51225: GO 51084
// for j in tmp do
51227: LD_ADDR_VAR 0 3
51231: PUSH
51232: LD_VAR 0 4
51236: PUSH
51237: FOR_IN
51238: IFFALSE 51268
// if not BuildingStatus ( j ) = bs_idle then
51240: LD_VAR 0 3
51244: PPUSH
51245: CALL_OW 461
51249: PUSH
51250: LD_INT 2
51252: EQUAL
51253: NOT
51254: IFFALSE 51266
// begin busy := true ;
51256: LD_ADDR_VAR 0 8
51260: PUSH
51261: LD_INT 1
51263: ST_TO_ADDR
// break ;
51264: GO 51268
// end ;
51266: GO 51237
51268: POP
51269: POP
// if busy then
51270: LD_VAR 0 8
51274: IFFALSE 51278
// continue ;
51276: GO 51084
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
51278: LD_ADDR_VAR 0 7
51282: PUSH
51283: LD_VAR 0 6
51287: PPUSH
51288: LD_INT 35
51290: PUSH
51291: LD_INT 0
51293: PUSH
51294: EMPTY
51295: LIST
51296: LIST
51297: PPUSH
51298: CALL_OW 72
51302: ST_TO_ADDR
// if tw then
51303: LD_VAR 0 7
51307: IFFALSE 51384
// begin tw := tw [ 1 ] ;
51309: LD_ADDR_VAR 0 7
51313: PUSH
51314: LD_VAR 0 7
51318: PUSH
51319: LD_INT 1
51321: ARRAY
51322: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
51323: LD_ADDR_VAR 0 9
51327: PUSH
51328: LD_VAR 0 7
51332: PPUSH
51333: LD_EXP 127
51337: PUSH
51338: LD_VAR 0 2
51342: ARRAY
51343: PPUSH
51344: CALL 80017 0 2
51348: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
51349: LD_EXP 141
51353: PUSH
51354: LD_VAR 0 2
51358: ARRAY
51359: IFFALSE 51382
// if not weapon in mc_allowed_tower_weapons [ i ] then
51361: LD_VAR 0 9
51365: PUSH
51366: LD_EXP 141
51370: PUSH
51371: LD_VAR 0 2
51375: ARRAY
51376: IN
51377: NOT
51378: IFFALSE 51382
// continue ;
51380: GO 51084
// end else
51382: GO 51447
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
51384: LD_ADDR_VAR 0 5
51388: PUSH
51389: LD_EXP 110
51393: PUSH
51394: LD_VAR 0 2
51398: ARRAY
51399: PPUSH
51400: LD_VAR 0 4
51404: PPUSH
51405: CALL 106909 0 2
51409: ST_TO_ADDR
// if not tmp2 then
51410: LD_VAR 0 5
51414: NOT
51415: IFFALSE 51419
// continue ;
51417: GO 51084
// tw := tmp2 [ 1 ] ;
51419: LD_ADDR_VAR 0 7
51423: PUSH
51424: LD_VAR 0 5
51428: PUSH
51429: LD_INT 1
51431: ARRAY
51432: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
51433: LD_ADDR_VAR 0 9
51437: PUSH
51438: LD_VAR 0 5
51442: PUSH
51443: LD_INT 2
51445: ARRAY
51446: ST_TO_ADDR
// end ; if not weapon then
51447: LD_VAR 0 9
51451: NOT
51452: IFFALSE 51456
// continue ;
51454: GO 51084
// ComPlaceWeapon ( tw , weapon ) ;
51456: LD_VAR 0 7
51460: PPUSH
51461: LD_VAR 0 9
51465: PPUSH
51466: CALL_OW 148
// end ;
51470: GO 51084
51472: POP
51473: POP
// end ;
51474: LD_VAR 0 1
51478: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
51479: LD_INT 0
51481: PPUSH
51482: PPUSH
51483: PPUSH
51484: PPUSH
51485: PPUSH
51486: PPUSH
51487: PPUSH
// if not mc_bases then
51488: LD_EXP 102
51492: NOT
51493: IFFALSE 51497
// exit ;
51495: GO 52272
// for i = 1 to mc_bases do
51497: LD_ADDR_VAR 0 2
51501: PUSH
51502: DOUBLE
51503: LD_INT 1
51505: DEC
51506: ST_TO_ADDR
51507: LD_EXP 102
51511: PUSH
51512: FOR_TO
51513: IFFALSE 52270
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
51515: LD_EXP 115
51519: PUSH
51520: LD_VAR 0 2
51524: ARRAY
51525: NOT
51526: PUSH
51527: LD_EXP 115
51531: PUSH
51532: LD_VAR 0 2
51536: ARRAY
51537: PUSH
51538: LD_EXP 116
51542: PUSH
51543: LD_VAR 0 2
51547: ARRAY
51548: EQUAL
51549: OR
51550: PUSH
51551: LD_EXP 125
51555: PUSH
51556: LD_VAR 0 2
51560: ARRAY
51561: OR
51562: IFFALSE 51566
// continue ;
51564: GO 51512
// if mc_miners [ i ] then
51566: LD_EXP 116
51570: PUSH
51571: LD_VAR 0 2
51575: ARRAY
51576: IFFALSE 51957
// begin for j = mc_miners [ i ] downto 1 do
51578: LD_ADDR_VAR 0 3
51582: PUSH
51583: DOUBLE
51584: LD_EXP 116
51588: PUSH
51589: LD_VAR 0 2
51593: ARRAY
51594: INC
51595: ST_TO_ADDR
51596: LD_INT 1
51598: PUSH
51599: FOR_DOWNTO
51600: IFFALSE 51955
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
51602: LD_EXP 116
51606: PUSH
51607: LD_VAR 0 2
51611: ARRAY
51612: PUSH
51613: LD_VAR 0 3
51617: ARRAY
51618: PPUSH
51619: CALL_OW 301
51623: PUSH
51624: LD_EXP 116
51628: PUSH
51629: LD_VAR 0 2
51633: ARRAY
51634: PUSH
51635: LD_VAR 0 3
51639: ARRAY
51640: PPUSH
51641: CALL_OW 257
51645: PUSH
51646: LD_INT 1
51648: NONEQUAL
51649: OR
51650: IFFALSE 51713
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
51652: LD_ADDR_VAR 0 5
51656: PUSH
51657: LD_EXP 116
51661: PUSH
51662: LD_VAR 0 2
51666: ARRAY
51667: PUSH
51668: LD_EXP 116
51672: PUSH
51673: LD_VAR 0 2
51677: ARRAY
51678: PUSH
51679: LD_VAR 0 3
51683: ARRAY
51684: DIFF
51685: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
51686: LD_ADDR_EXP 116
51690: PUSH
51691: LD_EXP 116
51695: PPUSH
51696: LD_VAR 0 2
51700: PPUSH
51701: LD_VAR 0 5
51705: PPUSH
51706: CALL_OW 1
51710: ST_TO_ADDR
// continue ;
51711: GO 51599
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
51713: LD_EXP 116
51717: PUSH
51718: LD_VAR 0 2
51722: ARRAY
51723: PUSH
51724: LD_VAR 0 3
51728: ARRAY
51729: PPUSH
51730: CALL_OW 257
51734: PUSH
51735: LD_INT 1
51737: EQUAL
51738: PUSH
51739: LD_EXP 116
51743: PUSH
51744: LD_VAR 0 2
51748: ARRAY
51749: PUSH
51750: LD_VAR 0 3
51754: ARRAY
51755: PPUSH
51756: CALL_OW 459
51760: NOT
51761: AND
51762: PUSH
51763: LD_EXP 116
51767: PUSH
51768: LD_VAR 0 2
51772: ARRAY
51773: PUSH
51774: LD_VAR 0 3
51778: ARRAY
51779: PPUSH
51780: CALL_OW 314
51784: NOT
51785: AND
51786: IFFALSE 51953
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
51788: LD_EXP 116
51792: PUSH
51793: LD_VAR 0 2
51797: ARRAY
51798: PUSH
51799: LD_VAR 0 3
51803: ARRAY
51804: PPUSH
51805: CALL_OW 310
51809: IFFALSE 51832
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
51811: LD_EXP 116
51815: PUSH
51816: LD_VAR 0 2
51820: ARRAY
51821: PUSH
51822: LD_VAR 0 3
51826: ARRAY
51827: PPUSH
51828: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
51832: LD_EXP 116
51836: PUSH
51837: LD_VAR 0 2
51841: ARRAY
51842: PUSH
51843: LD_VAR 0 3
51847: ARRAY
51848: PPUSH
51849: CALL_OW 314
51853: NOT
51854: IFFALSE 51953
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
51856: LD_ADDR_VAR 0 7
51860: PUSH
51861: LD_VAR 0 3
51865: PUSH
51866: LD_EXP 115
51870: PUSH
51871: LD_VAR 0 2
51875: ARRAY
51876: PPUSH
51877: CALL 71772 0 1
51881: MOD
51882: PUSH
51883: LD_INT 1
51885: PLUS
51886: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
51887: LD_EXP 116
51891: PUSH
51892: LD_VAR 0 2
51896: ARRAY
51897: PUSH
51898: LD_VAR 0 3
51902: ARRAY
51903: PPUSH
51904: LD_EXP 115
51908: PUSH
51909: LD_VAR 0 2
51913: ARRAY
51914: PUSH
51915: LD_VAR 0 7
51919: ARRAY
51920: PUSH
51921: LD_INT 1
51923: ARRAY
51924: PPUSH
51925: LD_EXP 115
51929: PUSH
51930: LD_VAR 0 2
51934: ARRAY
51935: PUSH
51936: LD_VAR 0 7
51940: ARRAY
51941: PUSH
51942: LD_INT 2
51944: ARRAY
51945: PPUSH
51946: LD_INT 0
51948: PPUSH
51949: CALL_OW 193
// end ; end ; end ;
51953: GO 51599
51955: POP
51956: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
51957: LD_ADDR_VAR 0 5
51961: PUSH
51962: LD_EXP 102
51966: PUSH
51967: LD_VAR 0 2
51971: ARRAY
51972: PPUSH
51973: LD_INT 2
51975: PUSH
51976: LD_INT 30
51978: PUSH
51979: LD_INT 4
51981: PUSH
51982: EMPTY
51983: LIST
51984: LIST
51985: PUSH
51986: LD_INT 30
51988: PUSH
51989: LD_INT 5
51991: PUSH
51992: EMPTY
51993: LIST
51994: LIST
51995: PUSH
51996: LD_INT 30
51998: PUSH
51999: LD_INT 32
52001: PUSH
52002: EMPTY
52003: LIST
52004: LIST
52005: PUSH
52006: EMPTY
52007: LIST
52008: LIST
52009: LIST
52010: LIST
52011: PPUSH
52012: CALL_OW 72
52016: ST_TO_ADDR
// if not tmp then
52017: LD_VAR 0 5
52021: NOT
52022: IFFALSE 52026
// continue ;
52024: GO 51512
// list := [ ] ;
52026: LD_ADDR_VAR 0 6
52030: PUSH
52031: EMPTY
52032: ST_TO_ADDR
// for j in tmp do
52033: LD_ADDR_VAR 0 3
52037: PUSH
52038: LD_VAR 0 5
52042: PUSH
52043: FOR_IN
52044: IFFALSE 52113
// begin for k in UnitsInside ( j ) do
52046: LD_ADDR_VAR 0 4
52050: PUSH
52051: LD_VAR 0 3
52055: PPUSH
52056: CALL_OW 313
52060: PUSH
52061: FOR_IN
52062: IFFALSE 52109
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
52064: LD_VAR 0 4
52068: PPUSH
52069: CALL_OW 257
52073: PUSH
52074: LD_INT 1
52076: EQUAL
52077: PUSH
52078: LD_VAR 0 4
52082: PPUSH
52083: CALL_OW 459
52087: NOT
52088: AND
52089: IFFALSE 52107
// list := list ^ k ;
52091: LD_ADDR_VAR 0 6
52095: PUSH
52096: LD_VAR 0 6
52100: PUSH
52101: LD_VAR 0 4
52105: ADD
52106: ST_TO_ADDR
52107: GO 52061
52109: POP
52110: POP
// end ;
52111: GO 52043
52113: POP
52114: POP
// list := list diff mc_miners [ i ] ;
52115: LD_ADDR_VAR 0 6
52119: PUSH
52120: LD_VAR 0 6
52124: PUSH
52125: LD_EXP 116
52129: PUSH
52130: LD_VAR 0 2
52134: ARRAY
52135: DIFF
52136: ST_TO_ADDR
// if not list then
52137: LD_VAR 0 6
52141: NOT
52142: IFFALSE 52146
// continue ;
52144: GO 51512
// k := mc_mines [ i ] - mc_miners [ i ] ;
52146: LD_ADDR_VAR 0 4
52150: PUSH
52151: LD_EXP 115
52155: PUSH
52156: LD_VAR 0 2
52160: ARRAY
52161: PUSH
52162: LD_EXP 116
52166: PUSH
52167: LD_VAR 0 2
52171: ARRAY
52172: MINUS
52173: ST_TO_ADDR
// if k > list then
52174: LD_VAR 0 4
52178: PUSH
52179: LD_VAR 0 6
52183: GREATER
52184: IFFALSE 52196
// k := list ;
52186: LD_ADDR_VAR 0 4
52190: PUSH
52191: LD_VAR 0 6
52195: ST_TO_ADDR
// for j = 1 to k do
52196: LD_ADDR_VAR 0 3
52200: PUSH
52201: DOUBLE
52202: LD_INT 1
52204: DEC
52205: ST_TO_ADDR
52206: LD_VAR 0 4
52210: PUSH
52211: FOR_TO
52212: IFFALSE 52266
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
52214: LD_ADDR_EXP 116
52218: PUSH
52219: LD_EXP 116
52223: PPUSH
52224: LD_VAR 0 2
52228: PUSH
52229: LD_EXP 116
52233: PUSH
52234: LD_VAR 0 2
52238: ARRAY
52239: PUSH
52240: LD_INT 1
52242: PLUS
52243: PUSH
52244: EMPTY
52245: LIST
52246: LIST
52247: PPUSH
52248: LD_VAR 0 6
52252: PUSH
52253: LD_VAR 0 3
52257: ARRAY
52258: PPUSH
52259: CALL 74632 0 3
52263: ST_TO_ADDR
52264: GO 52211
52266: POP
52267: POP
// end ;
52268: GO 51512
52270: POP
52271: POP
// end ;
52272: LD_VAR 0 1
52276: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
52277: LD_INT 0
52279: PPUSH
52280: PPUSH
52281: PPUSH
52282: PPUSH
52283: PPUSH
52284: PPUSH
52285: PPUSH
52286: PPUSH
52287: PPUSH
52288: PPUSH
52289: PPUSH
// if not mc_bases then
52290: LD_EXP 102
52294: NOT
52295: IFFALSE 52299
// exit ;
52297: GO 54122
// for i = 1 to mc_bases do
52299: LD_ADDR_VAR 0 2
52303: PUSH
52304: DOUBLE
52305: LD_INT 1
52307: DEC
52308: ST_TO_ADDR
52309: LD_EXP 102
52313: PUSH
52314: FOR_TO
52315: IFFALSE 54120
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
52317: LD_EXP 102
52321: PUSH
52322: LD_VAR 0 2
52326: ARRAY
52327: NOT
52328: PUSH
52329: LD_EXP 109
52333: PUSH
52334: LD_VAR 0 2
52338: ARRAY
52339: OR
52340: IFFALSE 52344
// continue ;
52342: GO 52314
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
52344: LD_EXP 118
52348: PUSH
52349: LD_VAR 0 2
52353: ARRAY
52354: NOT
52355: PUSH
52356: LD_EXP 119
52360: PUSH
52361: LD_VAR 0 2
52365: ARRAY
52366: AND
52367: IFFALSE 52405
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
52369: LD_ADDR_EXP 119
52373: PUSH
52374: LD_EXP 119
52378: PPUSH
52379: LD_VAR 0 2
52383: PPUSH
52384: EMPTY
52385: PPUSH
52386: CALL_OW 1
52390: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
52391: LD_VAR 0 2
52395: PPUSH
52396: LD_INT 107
52398: PPUSH
52399: CALL 43131 0 2
// continue ;
52403: GO 52314
// end ; target := [ ] ;
52405: LD_ADDR_VAR 0 7
52409: PUSH
52410: EMPTY
52411: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52412: LD_ADDR_VAR 0 6
52416: PUSH
52417: LD_EXP 102
52421: PUSH
52422: LD_VAR 0 2
52426: ARRAY
52427: PUSH
52428: LD_INT 1
52430: ARRAY
52431: PPUSH
52432: CALL_OW 255
52436: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52437: LD_ADDR_VAR 0 9
52441: PUSH
52442: LD_EXP 102
52446: PUSH
52447: LD_VAR 0 2
52451: ARRAY
52452: PPUSH
52453: LD_INT 2
52455: PUSH
52456: LD_INT 30
52458: PUSH
52459: LD_INT 0
52461: PUSH
52462: EMPTY
52463: LIST
52464: LIST
52465: PUSH
52466: LD_INT 30
52468: PUSH
52469: LD_INT 1
52471: PUSH
52472: EMPTY
52473: LIST
52474: LIST
52475: PUSH
52476: EMPTY
52477: LIST
52478: LIST
52479: LIST
52480: PPUSH
52481: CALL_OW 72
52485: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
52486: LD_ADDR_VAR 0 3
52490: PUSH
52491: DOUBLE
52492: LD_EXP 118
52496: PUSH
52497: LD_VAR 0 2
52501: ARRAY
52502: INC
52503: ST_TO_ADDR
52504: LD_INT 1
52506: PUSH
52507: FOR_DOWNTO
52508: IFFALSE 52753
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
52510: LD_EXP 118
52514: PUSH
52515: LD_VAR 0 2
52519: ARRAY
52520: PUSH
52521: LD_VAR 0 3
52525: ARRAY
52526: PUSH
52527: LD_INT 2
52529: ARRAY
52530: PPUSH
52531: LD_EXP 118
52535: PUSH
52536: LD_VAR 0 2
52540: ARRAY
52541: PUSH
52542: LD_VAR 0 3
52546: ARRAY
52547: PUSH
52548: LD_INT 3
52550: ARRAY
52551: PPUSH
52552: CALL_OW 488
52556: PUSH
52557: LD_EXP 118
52561: PUSH
52562: LD_VAR 0 2
52566: ARRAY
52567: PUSH
52568: LD_VAR 0 3
52572: ARRAY
52573: PUSH
52574: LD_INT 2
52576: ARRAY
52577: PPUSH
52578: LD_EXP 118
52582: PUSH
52583: LD_VAR 0 2
52587: ARRAY
52588: PUSH
52589: LD_VAR 0 3
52593: ARRAY
52594: PUSH
52595: LD_INT 3
52597: ARRAY
52598: PPUSH
52599: CALL_OW 284
52603: PUSH
52604: LD_INT 0
52606: EQUAL
52607: AND
52608: IFFALSE 52663
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
52610: LD_ADDR_VAR 0 5
52614: PUSH
52615: LD_EXP 118
52619: PUSH
52620: LD_VAR 0 2
52624: ARRAY
52625: PPUSH
52626: LD_VAR 0 3
52630: PPUSH
52631: CALL_OW 3
52635: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
52636: LD_ADDR_EXP 118
52640: PUSH
52641: LD_EXP 118
52645: PPUSH
52646: LD_VAR 0 2
52650: PPUSH
52651: LD_VAR 0 5
52655: PPUSH
52656: CALL_OW 1
52660: ST_TO_ADDR
// continue ;
52661: GO 52507
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
52663: LD_VAR 0 6
52667: PPUSH
52668: LD_EXP 118
52672: PUSH
52673: LD_VAR 0 2
52677: ARRAY
52678: PUSH
52679: LD_VAR 0 3
52683: ARRAY
52684: PUSH
52685: LD_INT 2
52687: ARRAY
52688: PPUSH
52689: LD_EXP 118
52693: PUSH
52694: LD_VAR 0 2
52698: ARRAY
52699: PUSH
52700: LD_VAR 0 3
52704: ARRAY
52705: PUSH
52706: LD_INT 3
52708: ARRAY
52709: PPUSH
52710: LD_INT 30
52712: PPUSH
52713: CALL 75896 0 4
52717: PUSH
52718: LD_INT 4
52720: ARRAY
52721: PUSH
52722: LD_INT 0
52724: EQUAL
52725: IFFALSE 52751
// begin target := mc_crates [ i ] [ j ] ;
52727: LD_ADDR_VAR 0 7
52731: PUSH
52732: LD_EXP 118
52736: PUSH
52737: LD_VAR 0 2
52741: ARRAY
52742: PUSH
52743: LD_VAR 0 3
52747: ARRAY
52748: ST_TO_ADDR
// break ;
52749: GO 52753
// end ; end ;
52751: GO 52507
52753: POP
52754: POP
// if not target then
52755: LD_VAR 0 7
52759: NOT
52760: IFFALSE 52764
// continue ;
52762: GO 52314
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
52764: LD_ADDR_VAR 0 8
52768: PUSH
52769: LD_EXP 121
52773: PUSH
52774: LD_VAR 0 2
52778: ARRAY
52779: PPUSH
52780: LD_INT 2
52782: PUSH
52783: LD_INT 3
52785: PUSH
52786: LD_INT 58
52788: PUSH
52789: EMPTY
52790: LIST
52791: PUSH
52792: EMPTY
52793: LIST
52794: LIST
52795: PUSH
52796: LD_INT 61
52798: PUSH
52799: EMPTY
52800: LIST
52801: PUSH
52802: LD_INT 33
52804: PUSH
52805: LD_INT 5
52807: PUSH
52808: EMPTY
52809: LIST
52810: LIST
52811: PUSH
52812: LD_INT 33
52814: PUSH
52815: LD_INT 3
52817: PUSH
52818: EMPTY
52819: LIST
52820: LIST
52821: PUSH
52822: EMPTY
52823: LIST
52824: LIST
52825: LIST
52826: LIST
52827: LIST
52828: PUSH
52829: LD_INT 2
52831: PUSH
52832: LD_INT 34
52834: PUSH
52835: LD_INT 32
52837: PUSH
52838: EMPTY
52839: LIST
52840: LIST
52841: PUSH
52842: LD_INT 34
52844: PUSH
52845: LD_INT 51
52847: PUSH
52848: EMPTY
52849: LIST
52850: LIST
52851: PUSH
52852: LD_INT 34
52854: PUSH
52855: LD_INT 12
52857: PUSH
52858: EMPTY
52859: LIST
52860: LIST
52861: PUSH
52862: EMPTY
52863: LIST
52864: LIST
52865: LIST
52866: LIST
52867: PUSH
52868: EMPTY
52869: LIST
52870: LIST
52871: PPUSH
52872: CALL_OW 72
52876: ST_TO_ADDR
// if not cargo then
52877: LD_VAR 0 8
52881: NOT
52882: IFFALSE 53588
// begin if mc_crates_collector [ i ] < 5 then
52884: LD_EXP 119
52888: PUSH
52889: LD_VAR 0 2
52893: ARRAY
52894: PUSH
52895: LD_INT 5
52897: LESS
52898: IFFALSE 53264
// begin if mc_ape [ i ] then
52900: LD_EXP 131
52904: PUSH
52905: LD_VAR 0 2
52909: ARRAY
52910: IFFALSE 52957
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
52912: LD_ADDR_VAR 0 5
52916: PUSH
52917: LD_EXP 131
52921: PUSH
52922: LD_VAR 0 2
52926: ARRAY
52927: PPUSH
52928: LD_INT 25
52930: PUSH
52931: LD_INT 16
52933: PUSH
52934: EMPTY
52935: LIST
52936: LIST
52937: PUSH
52938: LD_INT 24
52940: PUSH
52941: LD_INT 750
52943: PUSH
52944: EMPTY
52945: LIST
52946: LIST
52947: PUSH
52948: EMPTY
52949: LIST
52950: LIST
52951: PPUSH
52952: CALL_OW 72
52956: ST_TO_ADDR
// if not tmp then
52957: LD_VAR 0 5
52961: NOT
52962: IFFALSE 53009
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
52964: LD_ADDR_VAR 0 5
52968: PUSH
52969: LD_EXP 102
52973: PUSH
52974: LD_VAR 0 2
52978: ARRAY
52979: PPUSH
52980: LD_INT 25
52982: PUSH
52983: LD_INT 2
52985: PUSH
52986: EMPTY
52987: LIST
52988: LIST
52989: PUSH
52990: LD_INT 24
52992: PUSH
52993: LD_INT 750
52995: PUSH
52996: EMPTY
52997: LIST
52998: LIST
52999: PUSH
53000: EMPTY
53001: LIST
53002: LIST
53003: PPUSH
53004: CALL_OW 72
53008: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
53009: LD_EXP 131
53013: PUSH
53014: LD_VAR 0 2
53018: ARRAY
53019: PUSH
53020: LD_EXP 102
53024: PUSH
53025: LD_VAR 0 2
53029: ARRAY
53030: PPUSH
53031: LD_INT 25
53033: PUSH
53034: LD_INT 2
53036: PUSH
53037: EMPTY
53038: LIST
53039: LIST
53040: PUSH
53041: LD_INT 24
53043: PUSH
53044: LD_INT 750
53046: PUSH
53047: EMPTY
53048: LIST
53049: LIST
53050: PUSH
53051: EMPTY
53052: LIST
53053: LIST
53054: PPUSH
53055: CALL_OW 72
53059: AND
53060: PUSH
53061: LD_VAR 0 5
53065: PUSH
53066: LD_INT 5
53068: LESS
53069: AND
53070: IFFALSE 53152
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
53072: LD_ADDR_VAR 0 3
53076: PUSH
53077: LD_EXP 102
53081: PUSH
53082: LD_VAR 0 2
53086: ARRAY
53087: PPUSH
53088: LD_INT 25
53090: PUSH
53091: LD_INT 2
53093: PUSH
53094: EMPTY
53095: LIST
53096: LIST
53097: PUSH
53098: LD_INT 24
53100: PUSH
53101: LD_INT 750
53103: PUSH
53104: EMPTY
53105: LIST
53106: LIST
53107: PUSH
53108: EMPTY
53109: LIST
53110: LIST
53111: PPUSH
53112: CALL_OW 72
53116: PUSH
53117: FOR_IN
53118: IFFALSE 53150
// begin tmp := tmp union j ;
53120: LD_ADDR_VAR 0 5
53124: PUSH
53125: LD_VAR 0 5
53129: PUSH
53130: LD_VAR 0 3
53134: UNION
53135: ST_TO_ADDR
// if tmp >= 5 then
53136: LD_VAR 0 5
53140: PUSH
53141: LD_INT 5
53143: GREATEREQUAL
53144: IFFALSE 53148
// break ;
53146: GO 53150
// end ;
53148: GO 53117
53150: POP
53151: POP
// end ; if not tmp then
53152: LD_VAR 0 5
53156: NOT
53157: IFFALSE 53161
// continue ;
53159: GO 52314
// for j in tmp do
53161: LD_ADDR_VAR 0 3
53165: PUSH
53166: LD_VAR 0 5
53170: PUSH
53171: FOR_IN
53172: IFFALSE 53262
// if not GetTag ( j ) then
53174: LD_VAR 0 3
53178: PPUSH
53179: CALL_OW 110
53183: NOT
53184: IFFALSE 53260
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
53186: LD_ADDR_EXP 119
53190: PUSH
53191: LD_EXP 119
53195: PPUSH
53196: LD_VAR 0 2
53200: PUSH
53201: LD_EXP 119
53205: PUSH
53206: LD_VAR 0 2
53210: ARRAY
53211: PUSH
53212: LD_INT 1
53214: PLUS
53215: PUSH
53216: EMPTY
53217: LIST
53218: LIST
53219: PPUSH
53220: LD_VAR 0 3
53224: PPUSH
53225: CALL 74632 0 3
53229: ST_TO_ADDR
// SetTag ( j , 107 ) ;
53230: LD_VAR 0 3
53234: PPUSH
53235: LD_INT 107
53237: PPUSH
53238: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
53242: LD_EXP 119
53246: PUSH
53247: LD_VAR 0 2
53251: ARRAY
53252: PUSH
53253: LD_INT 5
53255: GREATEREQUAL
53256: IFFALSE 53260
// break ;
53258: GO 53262
// end ;
53260: GO 53171
53262: POP
53263: POP
// end ; if mc_crates_collector [ i ] and target then
53264: LD_EXP 119
53268: PUSH
53269: LD_VAR 0 2
53273: ARRAY
53274: PUSH
53275: LD_VAR 0 7
53279: AND
53280: IFFALSE 53586
// begin if mc_crates_collector [ i ] < target [ 1 ] then
53282: LD_EXP 119
53286: PUSH
53287: LD_VAR 0 2
53291: ARRAY
53292: PUSH
53293: LD_VAR 0 7
53297: PUSH
53298: LD_INT 1
53300: ARRAY
53301: LESS
53302: IFFALSE 53322
// tmp := mc_crates_collector [ i ] else
53304: LD_ADDR_VAR 0 5
53308: PUSH
53309: LD_EXP 119
53313: PUSH
53314: LD_VAR 0 2
53318: ARRAY
53319: ST_TO_ADDR
53320: GO 53336
// tmp := target [ 1 ] ;
53322: LD_ADDR_VAR 0 5
53326: PUSH
53327: LD_VAR 0 7
53331: PUSH
53332: LD_INT 1
53334: ARRAY
53335: ST_TO_ADDR
// k := 0 ;
53336: LD_ADDR_VAR 0 4
53340: PUSH
53341: LD_INT 0
53343: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
53344: LD_ADDR_VAR 0 3
53348: PUSH
53349: LD_EXP 119
53353: PUSH
53354: LD_VAR 0 2
53358: ARRAY
53359: PUSH
53360: FOR_IN
53361: IFFALSE 53584
// begin k := k + 1 ;
53363: LD_ADDR_VAR 0 4
53367: PUSH
53368: LD_VAR 0 4
53372: PUSH
53373: LD_INT 1
53375: PLUS
53376: ST_TO_ADDR
// if k > tmp then
53377: LD_VAR 0 4
53381: PUSH
53382: LD_VAR 0 5
53386: GREATER
53387: IFFALSE 53391
// break ;
53389: GO 53584
// if not GetClass ( j ) in [ 2 , 16 ] then
53391: LD_VAR 0 3
53395: PPUSH
53396: CALL_OW 257
53400: PUSH
53401: LD_INT 2
53403: PUSH
53404: LD_INT 16
53406: PUSH
53407: EMPTY
53408: LIST
53409: LIST
53410: IN
53411: NOT
53412: IFFALSE 53465
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
53414: LD_ADDR_EXP 119
53418: PUSH
53419: LD_EXP 119
53423: PPUSH
53424: LD_VAR 0 2
53428: PPUSH
53429: LD_EXP 119
53433: PUSH
53434: LD_VAR 0 2
53438: ARRAY
53439: PUSH
53440: LD_VAR 0 3
53444: DIFF
53445: PPUSH
53446: CALL_OW 1
53450: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53451: LD_VAR 0 3
53455: PPUSH
53456: LD_INT 0
53458: PPUSH
53459: CALL_OW 109
// continue ;
53463: GO 53360
// end ; if IsInUnit ( j ) then
53465: LD_VAR 0 3
53469: PPUSH
53470: CALL_OW 310
53474: IFFALSE 53485
// ComExitBuilding ( j ) ;
53476: LD_VAR 0 3
53480: PPUSH
53481: CALL_OW 122
// wait ( 3 ) ;
53485: LD_INT 3
53487: PPUSH
53488: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
53492: LD_VAR 0 3
53496: PPUSH
53497: CALL_OW 314
53501: PUSH
53502: LD_VAR 0 6
53506: PPUSH
53507: LD_VAR 0 7
53511: PUSH
53512: LD_INT 2
53514: ARRAY
53515: PPUSH
53516: LD_VAR 0 7
53520: PUSH
53521: LD_INT 3
53523: ARRAY
53524: PPUSH
53525: LD_INT 30
53527: PPUSH
53528: CALL 75896 0 4
53532: PUSH
53533: LD_INT 4
53535: ARRAY
53536: AND
53537: IFFALSE 53555
// ComStandNearbyBuilding ( j , depot ) else
53539: LD_VAR 0 3
53543: PPUSH
53544: LD_VAR 0 9
53548: PPUSH
53549: CALL 71234 0 2
53553: GO 53582
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
53555: LD_VAR 0 3
53559: PPUSH
53560: LD_VAR 0 7
53564: PUSH
53565: LD_INT 2
53567: ARRAY
53568: PPUSH
53569: LD_VAR 0 7
53573: PUSH
53574: LD_INT 3
53576: ARRAY
53577: PPUSH
53578: CALL_OW 117
// end ;
53582: GO 53360
53584: POP
53585: POP
// end ; end else
53586: GO 54118
// begin for j in cargo do
53588: LD_ADDR_VAR 0 3
53592: PUSH
53593: LD_VAR 0 8
53597: PUSH
53598: FOR_IN
53599: IFFALSE 54116
// begin if GetTag ( j ) <> 0 then
53601: LD_VAR 0 3
53605: PPUSH
53606: CALL_OW 110
53610: PUSH
53611: LD_INT 0
53613: NONEQUAL
53614: IFFALSE 53618
// continue ;
53616: GO 53598
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
53618: LD_VAR 0 3
53622: PPUSH
53623: CALL_OW 256
53627: PUSH
53628: LD_INT 1000
53630: LESS
53631: PUSH
53632: LD_VAR 0 3
53636: PPUSH
53637: LD_EXP 126
53641: PUSH
53642: LD_VAR 0 2
53646: ARRAY
53647: PPUSH
53648: CALL_OW 308
53652: NOT
53653: AND
53654: IFFALSE 53676
// ComMoveToArea ( j , mc_parking [ i ] ) ;
53656: LD_VAR 0 3
53660: PPUSH
53661: LD_EXP 126
53665: PUSH
53666: LD_VAR 0 2
53670: ARRAY
53671: PPUSH
53672: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
53676: LD_VAR 0 3
53680: PPUSH
53681: CALL_OW 256
53685: PUSH
53686: LD_INT 1000
53688: LESS
53689: PUSH
53690: LD_VAR 0 3
53694: PPUSH
53695: LD_EXP 126
53699: PUSH
53700: LD_VAR 0 2
53704: ARRAY
53705: PPUSH
53706: CALL_OW 308
53710: AND
53711: IFFALSE 53715
// continue ;
53713: GO 53598
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
53715: LD_VAR 0 3
53719: PPUSH
53720: CALL_OW 262
53724: PUSH
53725: LD_INT 2
53727: EQUAL
53728: PUSH
53729: LD_VAR 0 3
53733: PPUSH
53734: CALL_OW 261
53738: PUSH
53739: LD_INT 15
53741: LESS
53742: AND
53743: IFFALSE 53747
// continue ;
53745: GO 53598
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
53747: LD_VAR 0 3
53751: PPUSH
53752: CALL_OW 262
53756: PUSH
53757: LD_INT 1
53759: EQUAL
53760: PUSH
53761: LD_VAR 0 3
53765: PPUSH
53766: CALL_OW 261
53770: PUSH
53771: LD_INT 10
53773: LESS
53774: AND
53775: IFFALSE 54055
// begin if not depot then
53777: LD_VAR 0 9
53781: NOT
53782: IFFALSE 53786
// continue ;
53784: GO 53598
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
53786: LD_VAR 0 3
53790: PPUSH
53791: LD_VAR 0 9
53795: PPUSH
53796: LD_VAR 0 3
53800: PPUSH
53801: CALL_OW 74
53805: PPUSH
53806: CALL_OW 296
53810: PUSH
53811: LD_INT 6
53813: LESS
53814: IFFALSE 53830
// SetFuel ( j , 100 ) else
53816: LD_VAR 0 3
53820: PPUSH
53821: LD_INT 100
53823: PPUSH
53824: CALL_OW 240
53828: GO 54055
// if GetFuel ( j ) = 0 then
53830: LD_VAR 0 3
53834: PPUSH
53835: CALL_OW 261
53839: PUSH
53840: LD_INT 0
53842: EQUAL
53843: IFFALSE 54055
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
53845: LD_ADDR_EXP 121
53849: PUSH
53850: LD_EXP 121
53854: PPUSH
53855: LD_VAR 0 2
53859: PPUSH
53860: LD_EXP 121
53864: PUSH
53865: LD_VAR 0 2
53869: ARRAY
53870: PUSH
53871: LD_VAR 0 3
53875: DIFF
53876: PPUSH
53877: CALL_OW 1
53881: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
53882: LD_VAR 0 3
53886: PPUSH
53887: CALL_OW 263
53891: PUSH
53892: LD_INT 1
53894: EQUAL
53895: IFFALSE 53911
// ComExitVehicle ( IsInUnit ( j ) ) ;
53897: LD_VAR 0 3
53901: PPUSH
53902: CALL_OW 310
53906: PPUSH
53907: CALL_OW 121
// if GetControl ( j ) = control_remote then
53911: LD_VAR 0 3
53915: PPUSH
53916: CALL_OW 263
53920: PUSH
53921: LD_INT 2
53923: EQUAL
53924: IFFALSE 53935
// ComUnlink ( j ) ;
53926: LD_VAR 0 3
53930: PPUSH
53931: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
53935: LD_ADDR_VAR 0 10
53939: PUSH
53940: LD_VAR 0 2
53944: PPUSH
53945: LD_INT 3
53947: PPUSH
53948: CALL 63699 0 2
53952: ST_TO_ADDR
// if fac then
53953: LD_VAR 0 10
53957: IFFALSE 54053
// begin for k in fac do
53959: LD_ADDR_VAR 0 4
53963: PUSH
53964: LD_VAR 0 10
53968: PUSH
53969: FOR_IN
53970: IFFALSE 54051
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
53972: LD_ADDR_VAR 0 11
53976: PUSH
53977: LD_VAR 0 10
53981: PPUSH
53982: LD_VAR 0 3
53986: PPUSH
53987: CALL_OW 265
53991: PPUSH
53992: LD_VAR 0 3
53996: PPUSH
53997: CALL_OW 262
54001: PPUSH
54002: LD_VAR 0 3
54006: PPUSH
54007: CALL_OW 263
54011: PPUSH
54012: LD_VAR 0 3
54016: PPUSH
54017: CALL_OW 264
54021: PPUSH
54022: CALL 72130 0 5
54026: ST_TO_ADDR
// if components then
54027: LD_VAR 0 11
54031: IFFALSE 54049
// begin MC_InsertProduceList ( i , components ) ;
54033: LD_VAR 0 2
54037: PPUSH
54038: LD_VAR 0 11
54042: PPUSH
54043: CALL 63244 0 2
// break ;
54047: GO 54051
// end ; end ;
54049: GO 53969
54051: POP
54052: POP
// end ; continue ;
54053: GO 53598
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
54055: LD_VAR 0 3
54059: PPUSH
54060: LD_INT 1
54062: PPUSH
54063: CALL_OW 289
54067: PUSH
54068: LD_INT 100
54070: LESS
54071: PUSH
54072: LD_VAR 0 3
54076: PPUSH
54077: CALL_OW 314
54081: NOT
54082: AND
54083: IFFALSE 54112
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
54085: LD_VAR 0 3
54089: PPUSH
54090: LD_VAR 0 7
54094: PUSH
54095: LD_INT 2
54097: ARRAY
54098: PPUSH
54099: LD_VAR 0 7
54103: PUSH
54104: LD_INT 3
54106: ARRAY
54107: PPUSH
54108: CALL_OW 117
// break ;
54112: GO 54116
// end ;
54114: GO 53598
54116: POP
54117: POP
// end ; end ;
54118: GO 52314
54120: POP
54121: POP
// end ;
54122: LD_VAR 0 1
54126: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
54127: LD_INT 0
54129: PPUSH
54130: PPUSH
54131: PPUSH
54132: PPUSH
// if not mc_bases then
54133: LD_EXP 102
54137: NOT
54138: IFFALSE 54142
// exit ;
54140: GO 54303
// for i = 1 to mc_bases do
54142: LD_ADDR_VAR 0 2
54146: PUSH
54147: DOUBLE
54148: LD_INT 1
54150: DEC
54151: ST_TO_ADDR
54152: LD_EXP 102
54156: PUSH
54157: FOR_TO
54158: IFFALSE 54301
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
54160: LD_ADDR_VAR 0 4
54164: PUSH
54165: LD_EXP 121
54169: PUSH
54170: LD_VAR 0 2
54174: ARRAY
54175: PUSH
54176: LD_EXP 124
54180: PUSH
54181: LD_VAR 0 2
54185: ARRAY
54186: UNION
54187: PPUSH
54188: LD_INT 33
54190: PUSH
54191: LD_INT 2
54193: PUSH
54194: EMPTY
54195: LIST
54196: LIST
54197: PPUSH
54198: CALL_OW 72
54202: ST_TO_ADDR
// if tmp then
54203: LD_VAR 0 4
54207: IFFALSE 54299
// for j in tmp do
54209: LD_ADDR_VAR 0 3
54213: PUSH
54214: LD_VAR 0 4
54218: PUSH
54219: FOR_IN
54220: IFFALSE 54297
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
54222: LD_VAR 0 3
54226: PPUSH
54227: CALL_OW 312
54231: NOT
54232: PUSH
54233: LD_VAR 0 3
54237: PPUSH
54238: CALL_OW 256
54242: PUSH
54243: LD_INT 250
54245: GREATEREQUAL
54246: AND
54247: IFFALSE 54260
// Connect ( j ) else
54249: LD_VAR 0 3
54253: PPUSH
54254: CALL 77978 0 1
54258: GO 54295
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
54260: LD_VAR 0 3
54264: PPUSH
54265: CALL_OW 256
54269: PUSH
54270: LD_INT 250
54272: LESS
54273: PUSH
54274: LD_VAR 0 3
54278: PPUSH
54279: CALL_OW 312
54283: AND
54284: IFFALSE 54295
// ComUnlink ( j ) ;
54286: LD_VAR 0 3
54290: PPUSH
54291: CALL_OW 136
54295: GO 54219
54297: POP
54298: POP
// end ;
54299: GO 54157
54301: POP
54302: POP
// end ;
54303: LD_VAR 0 1
54307: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
54308: LD_INT 0
54310: PPUSH
54311: PPUSH
54312: PPUSH
54313: PPUSH
54314: PPUSH
// if not mc_bases then
54315: LD_EXP 102
54319: NOT
54320: IFFALSE 54324
// exit ;
54322: GO 54769
// for i = 1 to mc_bases do
54324: LD_ADDR_VAR 0 2
54328: PUSH
54329: DOUBLE
54330: LD_INT 1
54332: DEC
54333: ST_TO_ADDR
54334: LD_EXP 102
54338: PUSH
54339: FOR_TO
54340: IFFALSE 54767
// begin if not mc_produce [ i ] then
54342: LD_EXP 123
54346: PUSH
54347: LD_VAR 0 2
54351: ARRAY
54352: NOT
54353: IFFALSE 54357
// continue ;
54355: GO 54339
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54357: LD_ADDR_VAR 0 5
54361: PUSH
54362: LD_EXP 102
54366: PUSH
54367: LD_VAR 0 2
54371: ARRAY
54372: PPUSH
54373: LD_INT 30
54375: PUSH
54376: LD_INT 3
54378: PUSH
54379: EMPTY
54380: LIST
54381: LIST
54382: PPUSH
54383: CALL_OW 72
54387: ST_TO_ADDR
// if not fac then
54388: LD_VAR 0 5
54392: NOT
54393: IFFALSE 54397
// continue ;
54395: GO 54339
// for j in fac do
54397: LD_ADDR_VAR 0 3
54401: PUSH
54402: LD_VAR 0 5
54406: PUSH
54407: FOR_IN
54408: IFFALSE 54763
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
54410: LD_VAR 0 3
54414: PPUSH
54415: CALL_OW 461
54419: PUSH
54420: LD_INT 2
54422: NONEQUAL
54423: PUSH
54424: LD_VAR 0 3
54428: PPUSH
54429: LD_INT 15
54431: PPUSH
54432: CALL 77597 0 2
54436: PUSH
54437: LD_INT 4
54439: ARRAY
54440: OR
54441: IFFALSE 54445
// continue ;
54443: GO 54407
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
54445: LD_VAR 0 3
54449: PPUSH
54450: LD_EXP 123
54454: PUSH
54455: LD_VAR 0 2
54459: ARRAY
54460: PUSH
54461: LD_INT 1
54463: ARRAY
54464: PUSH
54465: LD_INT 1
54467: ARRAY
54468: PPUSH
54469: LD_EXP 123
54473: PUSH
54474: LD_VAR 0 2
54478: ARRAY
54479: PUSH
54480: LD_INT 1
54482: ARRAY
54483: PUSH
54484: LD_INT 2
54486: ARRAY
54487: PPUSH
54488: LD_EXP 123
54492: PUSH
54493: LD_VAR 0 2
54497: ARRAY
54498: PUSH
54499: LD_INT 1
54501: ARRAY
54502: PUSH
54503: LD_INT 3
54505: ARRAY
54506: PPUSH
54507: LD_EXP 123
54511: PUSH
54512: LD_VAR 0 2
54516: ARRAY
54517: PUSH
54518: LD_INT 1
54520: ARRAY
54521: PUSH
54522: LD_INT 4
54524: ARRAY
54525: PPUSH
54526: CALL_OW 448
54530: PUSH
54531: LD_VAR 0 3
54535: PPUSH
54536: LD_EXP 123
54540: PUSH
54541: LD_VAR 0 2
54545: ARRAY
54546: PUSH
54547: LD_INT 1
54549: ARRAY
54550: PUSH
54551: LD_INT 1
54553: ARRAY
54554: PUSH
54555: LD_EXP 123
54559: PUSH
54560: LD_VAR 0 2
54564: ARRAY
54565: PUSH
54566: LD_INT 1
54568: ARRAY
54569: PUSH
54570: LD_INT 2
54572: ARRAY
54573: PUSH
54574: LD_EXP 123
54578: PUSH
54579: LD_VAR 0 2
54583: ARRAY
54584: PUSH
54585: LD_INT 1
54587: ARRAY
54588: PUSH
54589: LD_INT 3
54591: ARRAY
54592: PUSH
54593: LD_EXP 123
54597: PUSH
54598: LD_VAR 0 2
54602: ARRAY
54603: PUSH
54604: LD_INT 1
54606: ARRAY
54607: PUSH
54608: LD_INT 4
54610: ARRAY
54611: PUSH
54612: EMPTY
54613: LIST
54614: LIST
54615: LIST
54616: LIST
54617: PPUSH
54618: CALL 81373 0 2
54622: AND
54623: IFFALSE 54761
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
54625: LD_VAR 0 3
54629: PPUSH
54630: LD_EXP 123
54634: PUSH
54635: LD_VAR 0 2
54639: ARRAY
54640: PUSH
54641: LD_INT 1
54643: ARRAY
54644: PUSH
54645: LD_INT 1
54647: ARRAY
54648: PPUSH
54649: LD_EXP 123
54653: PUSH
54654: LD_VAR 0 2
54658: ARRAY
54659: PUSH
54660: LD_INT 1
54662: ARRAY
54663: PUSH
54664: LD_INT 2
54666: ARRAY
54667: PPUSH
54668: LD_EXP 123
54672: PUSH
54673: LD_VAR 0 2
54677: ARRAY
54678: PUSH
54679: LD_INT 1
54681: ARRAY
54682: PUSH
54683: LD_INT 3
54685: ARRAY
54686: PPUSH
54687: LD_EXP 123
54691: PUSH
54692: LD_VAR 0 2
54696: ARRAY
54697: PUSH
54698: LD_INT 1
54700: ARRAY
54701: PUSH
54702: LD_INT 4
54704: ARRAY
54705: PPUSH
54706: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
54710: LD_ADDR_VAR 0 4
54714: PUSH
54715: LD_EXP 123
54719: PUSH
54720: LD_VAR 0 2
54724: ARRAY
54725: PPUSH
54726: LD_INT 1
54728: PPUSH
54729: CALL_OW 3
54733: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
54734: LD_ADDR_EXP 123
54738: PUSH
54739: LD_EXP 123
54743: PPUSH
54744: LD_VAR 0 2
54748: PPUSH
54749: LD_VAR 0 4
54753: PPUSH
54754: CALL_OW 1
54758: ST_TO_ADDR
// break ;
54759: GO 54763
// end ; end ;
54761: GO 54407
54763: POP
54764: POP
// end ;
54765: GO 54339
54767: POP
54768: POP
// end ;
54769: LD_VAR 0 1
54773: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
54774: LD_INT 0
54776: PPUSH
54777: PPUSH
54778: PPUSH
// if not mc_bases then
54779: LD_EXP 102
54783: NOT
54784: IFFALSE 54788
// exit ;
54786: GO 54877
// for i = 1 to mc_bases do
54788: LD_ADDR_VAR 0 2
54792: PUSH
54793: DOUBLE
54794: LD_INT 1
54796: DEC
54797: ST_TO_ADDR
54798: LD_EXP 102
54802: PUSH
54803: FOR_TO
54804: IFFALSE 54875
// begin if mc_attack [ i ] then
54806: LD_EXP 122
54810: PUSH
54811: LD_VAR 0 2
54815: ARRAY
54816: IFFALSE 54873
// begin tmp := mc_attack [ i ] [ 1 ] ;
54818: LD_ADDR_VAR 0 3
54822: PUSH
54823: LD_EXP 122
54827: PUSH
54828: LD_VAR 0 2
54832: ARRAY
54833: PUSH
54834: LD_INT 1
54836: ARRAY
54837: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
54838: LD_ADDR_EXP 122
54842: PUSH
54843: LD_EXP 122
54847: PPUSH
54848: LD_VAR 0 2
54852: PPUSH
54853: EMPTY
54854: PPUSH
54855: CALL_OW 1
54859: ST_TO_ADDR
// Attack ( tmp ) ;
54860: LD_VAR 0 3
54864: PPUSH
54865: CALL 133154 0 1
// exit ;
54869: POP
54870: POP
54871: GO 54877
// end ; end ;
54873: GO 54803
54875: POP
54876: POP
// end ;
54877: LD_VAR 0 1
54881: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
54882: LD_INT 0
54884: PPUSH
54885: PPUSH
54886: PPUSH
54887: PPUSH
54888: PPUSH
54889: PPUSH
54890: PPUSH
// if not mc_bases then
54891: LD_EXP 102
54895: NOT
54896: IFFALSE 54900
// exit ;
54898: GO 55757
// for i = 1 to mc_bases do
54900: LD_ADDR_VAR 0 2
54904: PUSH
54905: DOUBLE
54906: LD_INT 1
54908: DEC
54909: ST_TO_ADDR
54910: LD_EXP 102
54914: PUSH
54915: FOR_TO
54916: IFFALSE 55755
// begin if not mc_bases [ i ] then
54918: LD_EXP 102
54922: PUSH
54923: LD_VAR 0 2
54927: ARRAY
54928: NOT
54929: IFFALSE 54933
// continue ;
54931: GO 54915
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
54933: LD_ADDR_VAR 0 7
54937: PUSH
54938: LD_EXP 102
54942: PUSH
54943: LD_VAR 0 2
54947: ARRAY
54948: PUSH
54949: LD_INT 1
54951: ARRAY
54952: PPUSH
54953: CALL 71456 0 1
54957: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
54958: LD_ADDR_EXP 125
54962: PUSH
54963: LD_EXP 125
54967: PPUSH
54968: LD_VAR 0 2
54972: PPUSH
54973: LD_EXP 102
54977: PUSH
54978: LD_VAR 0 2
54982: ARRAY
54983: PUSH
54984: LD_INT 1
54986: ARRAY
54987: PPUSH
54988: CALL_OW 255
54992: PPUSH
54993: LD_EXP 127
54997: PUSH
54998: LD_VAR 0 2
55002: ARRAY
55003: PPUSH
55004: CALL 71421 0 2
55008: PPUSH
55009: CALL_OW 1
55013: ST_TO_ADDR
// if not mc_scan [ i ] then
55014: LD_EXP 125
55018: PUSH
55019: LD_VAR 0 2
55023: ARRAY
55024: NOT
55025: IFFALSE 55203
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
55027: LD_ADDR_EXP 145
55031: PUSH
55032: LD_EXP 145
55036: PPUSH
55037: LD_VAR 0 2
55041: PPUSH
55042: LD_INT 0
55044: PPUSH
55045: CALL_OW 1
55049: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55050: LD_ADDR_VAR 0 4
55054: PUSH
55055: LD_EXP 102
55059: PUSH
55060: LD_VAR 0 2
55064: ARRAY
55065: PPUSH
55066: LD_INT 2
55068: PUSH
55069: LD_INT 25
55071: PUSH
55072: LD_INT 5
55074: PUSH
55075: EMPTY
55076: LIST
55077: LIST
55078: PUSH
55079: LD_INT 25
55081: PUSH
55082: LD_INT 8
55084: PUSH
55085: EMPTY
55086: LIST
55087: LIST
55088: PUSH
55089: LD_INT 25
55091: PUSH
55092: LD_INT 9
55094: PUSH
55095: EMPTY
55096: LIST
55097: LIST
55098: PUSH
55099: EMPTY
55100: LIST
55101: LIST
55102: LIST
55103: LIST
55104: PPUSH
55105: CALL_OW 72
55109: ST_TO_ADDR
// if not tmp then
55110: LD_VAR 0 4
55114: NOT
55115: IFFALSE 55119
// continue ;
55117: GO 54915
// for j in tmp do
55119: LD_ADDR_VAR 0 3
55123: PUSH
55124: LD_VAR 0 4
55128: PUSH
55129: FOR_IN
55130: IFFALSE 55201
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
55132: LD_VAR 0 3
55136: PPUSH
55137: CALL_OW 310
55141: PPUSH
55142: CALL_OW 266
55146: PUSH
55147: LD_INT 5
55149: EQUAL
55150: PUSH
55151: LD_VAR 0 3
55155: PPUSH
55156: CALL_OW 257
55160: PUSH
55161: LD_INT 1
55163: EQUAL
55164: AND
55165: PUSH
55166: LD_VAR 0 3
55170: PPUSH
55171: CALL_OW 459
55175: NOT
55176: AND
55177: PUSH
55178: LD_VAR 0 7
55182: AND
55183: IFFALSE 55199
// ComChangeProfession ( j , class ) ;
55185: LD_VAR 0 3
55189: PPUSH
55190: LD_VAR 0 7
55194: PPUSH
55195: CALL_OW 123
55199: GO 55129
55201: POP
55202: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
55203: LD_EXP 125
55207: PUSH
55208: LD_VAR 0 2
55212: ARRAY
55213: PUSH
55214: LD_EXP 145
55218: PUSH
55219: LD_VAR 0 2
55223: ARRAY
55224: NOT
55225: AND
55226: PUSH
55227: LD_EXP 124
55231: PUSH
55232: LD_VAR 0 2
55236: ARRAY
55237: NOT
55238: AND
55239: PUSH
55240: LD_EXP 102
55244: PUSH
55245: LD_VAR 0 2
55249: ARRAY
55250: PPUSH
55251: LD_INT 50
55253: PUSH
55254: EMPTY
55255: LIST
55256: PUSH
55257: LD_INT 2
55259: PUSH
55260: LD_INT 30
55262: PUSH
55263: LD_INT 32
55265: PUSH
55266: EMPTY
55267: LIST
55268: LIST
55269: PUSH
55270: LD_INT 30
55272: PUSH
55273: LD_INT 33
55275: PUSH
55276: EMPTY
55277: LIST
55278: LIST
55279: PUSH
55280: LD_INT 30
55282: PUSH
55283: LD_INT 4
55285: PUSH
55286: EMPTY
55287: LIST
55288: LIST
55289: PUSH
55290: LD_INT 30
55292: PUSH
55293: LD_INT 5
55295: PUSH
55296: EMPTY
55297: LIST
55298: LIST
55299: PUSH
55300: EMPTY
55301: LIST
55302: LIST
55303: LIST
55304: LIST
55305: LIST
55306: PUSH
55307: EMPTY
55308: LIST
55309: LIST
55310: PPUSH
55311: CALL_OW 72
55315: PUSH
55316: LD_INT 4
55318: LESS
55319: PUSH
55320: LD_EXP 102
55324: PUSH
55325: LD_VAR 0 2
55329: ARRAY
55330: PPUSH
55331: LD_INT 3
55333: PUSH
55334: LD_INT 24
55336: PUSH
55337: LD_INT 1000
55339: PUSH
55340: EMPTY
55341: LIST
55342: LIST
55343: PUSH
55344: EMPTY
55345: LIST
55346: LIST
55347: PUSH
55348: LD_INT 2
55350: PUSH
55351: LD_INT 30
55353: PUSH
55354: LD_INT 0
55356: PUSH
55357: EMPTY
55358: LIST
55359: LIST
55360: PUSH
55361: LD_INT 30
55363: PUSH
55364: LD_INT 1
55366: PUSH
55367: EMPTY
55368: LIST
55369: LIST
55370: PUSH
55371: EMPTY
55372: LIST
55373: LIST
55374: LIST
55375: PUSH
55376: EMPTY
55377: LIST
55378: LIST
55379: PPUSH
55380: CALL_OW 72
55384: OR
55385: AND
55386: IFFALSE 55637
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
55388: LD_ADDR_EXP 145
55392: PUSH
55393: LD_EXP 145
55397: PPUSH
55398: LD_VAR 0 2
55402: PPUSH
55403: LD_INT 1
55405: PPUSH
55406: CALL_OW 1
55410: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55411: LD_ADDR_VAR 0 4
55415: PUSH
55416: LD_EXP 102
55420: PUSH
55421: LD_VAR 0 2
55425: ARRAY
55426: PPUSH
55427: LD_INT 2
55429: PUSH
55430: LD_INT 25
55432: PUSH
55433: LD_INT 1
55435: PUSH
55436: EMPTY
55437: LIST
55438: LIST
55439: PUSH
55440: LD_INT 25
55442: PUSH
55443: LD_INT 5
55445: PUSH
55446: EMPTY
55447: LIST
55448: LIST
55449: PUSH
55450: LD_INT 25
55452: PUSH
55453: LD_INT 8
55455: PUSH
55456: EMPTY
55457: LIST
55458: LIST
55459: PUSH
55460: LD_INT 25
55462: PUSH
55463: LD_INT 9
55465: PUSH
55466: EMPTY
55467: LIST
55468: LIST
55469: PUSH
55470: EMPTY
55471: LIST
55472: LIST
55473: LIST
55474: LIST
55475: LIST
55476: PPUSH
55477: CALL_OW 72
55481: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
55482: LD_ADDR_VAR 0 4
55486: PUSH
55487: LD_VAR 0 4
55491: PUSH
55492: LD_VAR 0 4
55496: PPUSH
55497: LD_INT 18
55499: PPUSH
55500: CALL 104930 0 2
55504: DIFF
55505: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
55506: LD_VAR 0 4
55510: NOT
55511: PUSH
55512: LD_EXP 102
55516: PUSH
55517: LD_VAR 0 2
55521: ARRAY
55522: PPUSH
55523: LD_INT 2
55525: PUSH
55526: LD_INT 30
55528: PUSH
55529: LD_INT 4
55531: PUSH
55532: EMPTY
55533: LIST
55534: LIST
55535: PUSH
55536: LD_INT 30
55538: PUSH
55539: LD_INT 5
55541: PUSH
55542: EMPTY
55543: LIST
55544: LIST
55545: PUSH
55546: EMPTY
55547: LIST
55548: LIST
55549: LIST
55550: PPUSH
55551: CALL_OW 72
55555: NOT
55556: AND
55557: IFFALSE 55619
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
55559: LD_ADDR_VAR 0 4
55563: PUSH
55564: LD_EXP 102
55568: PUSH
55569: LD_VAR 0 2
55573: ARRAY
55574: PPUSH
55575: LD_INT 2
55577: PUSH
55578: LD_INT 25
55580: PUSH
55581: LD_INT 2
55583: PUSH
55584: EMPTY
55585: LIST
55586: LIST
55587: PUSH
55588: LD_INT 25
55590: PUSH
55591: LD_INT 3
55593: PUSH
55594: EMPTY
55595: LIST
55596: LIST
55597: PUSH
55598: LD_INT 25
55600: PUSH
55601: LD_INT 4
55603: PUSH
55604: EMPTY
55605: LIST
55606: LIST
55607: PUSH
55608: EMPTY
55609: LIST
55610: LIST
55611: LIST
55612: LIST
55613: PPUSH
55614: CALL_OW 72
55618: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
55619: LD_VAR 0 2
55623: PPUSH
55624: LD_VAR 0 4
55628: PPUSH
55629: CALL 137863 0 2
// exit ;
55633: POP
55634: POP
55635: GO 55757
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
55637: LD_EXP 125
55641: PUSH
55642: LD_VAR 0 2
55646: ARRAY
55647: PUSH
55648: LD_EXP 145
55652: PUSH
55653: LD_VAR 0 2
55657: ARRAY
55658: NOT
55659: AND
55660: PUSH
55661: LD_EXP 124
55665: PUSH
55666: LD_VAR 0 2
55670: ARRAY
55671: AND
55672: IFFALSE 55753
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
55674: LD_ADDR_EXP 145
55678: PUSH
55679: LD_EXP 145
55683: PPUSH
55684: LD_VAR 0 2
55688: PPUSH
55689: LD_INT 1
55691: PPUSH
55692: CALL_OW 1
55696: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
55697: LD_ADDR_VAR 0 4
55701: PUSH
55702: LD_EXP 124
55706: PUSH
55707: LD_VAR 0 2
55711: ARRAY
55712: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
55713: LD_ADDR_EXP 124
55717: PUSH
55718: LD_EXP 124
55722: PPUSH
55723: LD_VAR 0 2
55727: PPUSH
55728: EMPTY
55729: PPUSH
55730: CALL_OW 1
55734: ST_TO_ADDR
// Defend ( i , tmp ) ;
55735: LD_VAR 0 2
55739: PPUSH
55740: LD_VAR 0 4
55744: PPUSH
55745: CALL 138459 0 2
// exit ;
55749: POP
55750: POP
55751: GO 55757
// end ; end ;
55753: GO 54915
55755: POP
55756: POP
// end ;
55757: LD_VAR 0 1
55761: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
55762: LD_INT 0
55764: PPUSH
55765: PPUSH
55766: PPUSH
55767: PPUSH
55768: PPUSH
55769: PPUSH
55770: PPUSH
55771: PPUSH
55772: PPUSH
55773: PPUSH
55774: PPUSH
// if not mc_bases then
55775: LD_EXP 102
55779: NOT
55780: IFFALSE 55784
// exit ;
55782: GO 56871
// for i = 1 to mc_bases do
55784: LD_ADDR_VAR 0 2
55788: PUSH
55789: DOUBLE
55790: LD_INT 1
55792: DEC
55793: ST_TO_ADDR
55794: LD_EXP 102
55798: PUSH
55799: FOR_TO
55800: IFFALSE 56869
// begin tmp := mc_lab [ i ] ;
55802: LD_ADDR_VAR 0 6
55806: PUSH
55807: LD_EXP 135
55811: PUSH
55812: LD_VAR 0 2
55816: ARRAY
55817: ST_TO_ADDR
// if not tmp then
55818: LD_VAR 0 6
55822: NOT
55823: IFFALSE 55827
// continue ;
55825: GO 55799
// idle_lab := 0 ;
55827: LD_ADDR_VAR 0 11
55831: PUSH
55832: LD_INT 0
55834: ST_TO_ADDR
// for j in tmp do
55835: LD_ADDR_VAR 0 3
55839: PUSH
55840: LD_VAR 0 6
55844: PUSH
55845: FOR_IN
55846: IFFALSE 56865
// begin researching := false ;
55848: LD_ADDR_VAR 0 10
55852: PUSH
55853: LD_INT 0
55855: ST_TO_ADDR
// side := GetSide ( j ) ;
55856: LD_ADDR_VAR 0 4
55860: PUSH
55861: LD_VAR 0 3
55865: PPUSH
55866: CALL_OW 255
55870: ST_TO_ADDR
// if not mc_tech [ side ] then
55871: LD_EXP 129
55875: PUSH
55876: LD_VAR 0 4
55880: ARRAY
55881: NOT
55882: IFFALSE 55886
// continue ;
55884: GO 55845
// if BuildingStatus ( j ) = bs_idle then
55886: LD_VAR 0 3
55890: PPUSH
55891: CALL_OW 461
55895: PUSH
55896: LD_INT 2
55898: EQUAL
55899: IFFALSE 56087
// begin if idle_lab and UnitsInside ( j ) < 6 then
55901: LD_VAR 0 11
55905: PUSH
55906: LD_VAR 0 3
55910: PPUSH
55911: CALL_OW 313
55915: PUSH
55916: LD_INT 6
55918: LESS
55919: AND
55920: IFFALSE 55991
// begin tmp2 := UnitsInside ( idle_lab ) ;
55922: LD_ADDR_VAR 0 9
55926: PUSH
55927: LD_VAR 0 11
55931: PPUSH
55932: CALL_OW 313
55936: ST_TO_ADDR
// if tmp2 then
55937: LD_VAR 0 9
55941: IFFALSE 55983
// for x in tmp2 do
55943: LD_ADDR_VAR 0 7
55947: PUSH
55948: LD_VAR 0 9
55952: PUSH
55953: FOR_IN
55954: IFFALSE 55981
// begin ComExitBuilding ( x ) ;
55956: LD_VAR 0 7
55960: PPUSH
55961: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
55965: LD_VAR 0 7
55969: PPUSH
55970: LD_VAR 0 3
55974: PPUSH
55975: CALL_OW 180
// end ;
55979: GO 55953
55981: POP
55982: POP
// idle_lab := 0 ;
55983: LD_ADDR_VAR 0 11
55987: PUSH
55988: LD_INT 0
55990: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
55991: LD_ADDR_VAR 0 5
55995: PUSH
55996: LD_EXP 129
56000: PUSH
56001: LD_VAR 0 4
56005: ARRAY
56006: PUSH
56007: FOR_IN
56008: IFFALSE 56068
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
56010: LD_VAR 0 3
56014: PPUSH
56015: LD_VAR 0 5
56019: PPUSH
56020: CALL_OW 430
56024: PUSH
56025: LD_VAR 0 4
56029: PPUSH
56030: LD_VAR 0 5
56034: PPUSH
56035: CALL 70526 0 2
56039: AND
56040: IFFALSE 56066
// begin researching := true ;
56042: LD_ADDR_VAR 0 10
56046: PUSH
56047: LD_INT 1
56049: ST_TO_ADDR
// ComResearch ( j , t ) ;
56050: LD_VAR 0 3
56054: PPUSH
56055: LD_VAR 0 5
56059: PPUSH
56060: CALL_OW 124
// break ;
56064: GO 56068
// end ;
56066: GO 56007
56068: POP
56069: POP
// if not researching then
56070: LD_VAR 0 10
56074: NOT
56075: IFFALSE 56087
// idle_lab := j ;
56077: LD_ADDR_VAR 0 11
56081: PUSH
56082: LD_VAR 0 3
56086: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
56087: LD_VAR 0 3
56091: PPUSH
56092: CALL_OW 461
56096: PUSH
56097: LD_INT 10
56099: EQUAL
56100: IFFALSE 56688
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
56102: LD_EXP 131
56106: PUSH
56107: LD_VAR 0 2
56111: ARRAY
56112: NOT
56113: PUSH
56114: LD_EXP 132
56118: PUSH
56119: LD_VAR 0 2
56123: ARRAY
56124: NOT
56125: AND
56126: PUSH
56127: LD_EXP 129
56131: PUSH
56132: LD_VAR 0 4
56136: ARRAY
56137: PUSH
56138: LD_INT 1
56140: GREATER
56141: AND
56142: IFFALSE 56273
// begin ComCancel ( j ) ;
56144: LD_VAR 0 3
56148: PPUSH
56149: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
56153: LD_ADDR_EXP 129
56157: PUSH
56158: LD_EXP 129
56162: PPUSH
56163: LD_VAR 0 4
56167: PPUSH
56168: LD_EXP 129
56172: PUSH
56173: LD_VAR 0 4
56177: ARRAY
56178: PPUSH
56179: LD_EXP 129
56183: PUSH
56184: LD_VAR 0 4
56188: ARRAY
56189: PUSH
56190: LD_INT 1
56192: MINUS
56193: PPUSH
56194: LD_EXP 129
56198: PUSH
56199: LD_VAR 0 4
56203: ARRAY
56204: PPUSH
56205: LD_INT 0
56207: PPUSH
56208: CALL 74050 0 4
56212: PPUSH
56213: CALL_OW 1
56217: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
56218: LD_ADDR_EXP 129
56222: PUSH
56223: LD_EXP 129
56227: PPUSH
56228: LD_VAR 0 4
56232: PPUSH
56233: LD_EXP 129
56237: PUSH
56238: LD_VAR 0 4
56242: ARRAY
56243: PPUSH
56244: LD_EXP 129
56248: PUSH
56249: LD_VAR 0 4
56253: ARRAY
56254: PPUSH
56255: LD_INT 1
56257: PPUSH
56258: LD_INT 0
56260: PPUSH
56261: CALL 74050 0 4
56265: PPUSH
56266: CALL_OW 1
56270: ST_TO_ADDR
// continue ;
56271: GO 55845
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
56273: LD_EXP 131
56277: PUSH
56278: LD_VAR 0 2
56282: ARRAY
56283: PUSH
56284: LD_EXP 132
56288: PUSH
56289: LD_VAR 0 2
56293: ARRAY
56294: NOT
56295: AND
56296: IFFALSE 56423
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
56298: LD_ADDR_EXP 132
56302: PUSH
56303: LD_EXP 132
56307: PPUSH
56308: LD_VAR 0 2
56312: PUSH
56313: LD_EXP 132
56317: PUSH
56318: LD_VAR 0 2
56322: ARRAY
56323: PUSH
56324: LD_INT 1
56326: PLUS
56327: PUSH
56328: EMPTY
56329: LIST
56330: LIST
56331: PPUSH
56332: LD_EXP 131
56336: PUSH
56337: LD_VAR 0 2
56341: ARRAY
56342: PUSH
56343: LD_INT 1
56345: ARRAY
56346: PPUSH
56347: CALL 74632 0 3
56351: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
56352: LD_EXP 131
56356: PUSH
56357: LD_VAR 0 2
56361: ARRAY
56362: PUSH
56363: LD_INT 1
56365: ARRAY
56366: PPUSH
56367: LD_INT 112
56369: PPUSH
56370: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
56374: LD_ADDR_VAR 0 9
56378: PUSH
56379: LD_EXP 131
56383: PUSH
56384: LD_VAR 0 2
56388: ARRAY
56389: PPUSH
56390: LD_INT 1
56392: PPUSH
56393: CALL_OW 3
56397: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
56398: LD_ADDR_EXP 131
56402: PUSH
56403: LD_EXP 131
56407: PPUSH
56408: LD_VAR 0 2
56412: PPUSH
56413: LD_VAR 0 9
56417: PPUSH
56418: CALL_OW 1
56422: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
56423: LD_EXP 131
56427: PUSH
56428: LD_VAR 0 2
56432: ARRAY
56433: PUSH
56434: LD_EXP 132
56438: PUSH
56439: LD_VAR 0 2
56443: ARRAY
56444: AND
56445: PUSH
56446: LD_EXP 132
56450: PUSH
56451: LD_VAR 0 2
56455: ARRAY
56456: PUSH
56457: LD_INT 1
56459: ARRAY
56460: PPUSH
56461: CALL_OW 310
56465: NOT
56466: AND
56467: PUSH
56468: LD_VAR 0 3
56472: PPUSH
56473: CALL_OW 313
56477: PUSH
56478: LD_INT 6
56480: EQUAL
56481: AND
56482: IFFALSE 56538
// begin tmp2 := UnitsInside ( j ) ;
56484: LD_ADDR_VAR 0 9
56488: PUSH
56489: LD_VAR 0 3
56493: PPUSH
56494: CALL_OW 313
56498: ST_TO_ADDR
// if tmp2 = 6 then
56499: LD_VAR 0 9
56503: PUSH
56504: LD_INT 6
56506: EQUAL
56507: IFFALSE 56538
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
56509: LD_VAR 0 9
56513: PUSH
56514: LD_INT 1
56516: ARRAY
56517: PPUSH
56518: LD_INT 112
56520: PPUSH
56521: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
56525: LD_VAR 0 9
56529: PUSH
56530: LD_INT 1
56532: ARRAY
56533: PPUSH
56534: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
56538: LD_EXP 132
56542: PUSH
56543: LD_VAR 0 2
56547: ARRAY
56548: PUSH
56549: LD_EXP 132
56553: PUSH
56554: LD_VAR 0 2
56558: ARRAY
56559: PUSH
56560: LD_INT 1
56562: ARRAY
56563: PPUSH
56564: CALL_OW 314
56568: NOT
56569: AND
56570: PUSH
56571: LD_EXP 132
56575: PUSH
56576: LD_VAR 0 2
56580: ARRAY
56581: PUSH
56582: LD_INT 1
56584: ARRAY
56585: PPUSH
56586: CALL_OW 310
56590: NOT
56591: AND
56592: IFFALSE 56618
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
56594: LD_EXP 132
56598: PUSH
56599: LD_VAR 0 2
56603: ARRAY
56604: PUSH
56605: LD_INT 1
56607: ARRAY
56608: PPUSH
56609: LD_VAR 0 3
56613: PPUSH
56614: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
56618: LD_EXP 132
56622: PUSH
56623: LD_VAR 0 2
56627: ARRAY
56628: PUSH
56629: LD_INT 1
56631: ARRAY
56632: PPUSH
56633: CALL_OW 310
56637: PUSH
56638: LD_EXP 132
56642: PUSH
56643: LD_VAR 0 2
56647: ARRAY
56648: PUSH
56649: LD_INT 1
56651: ARRAY
56652: PPUSH
56653: CALL_OW 310
56657: PPUSH
56658: CALL_OW 461
56662: PUSH
56663: LD_INT 3
56665: NONEQUAL
56666: AND
56667: IFFALSE 56688
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
56669: LD_EXP 132
56673: PUSH
56674: LD_VAR 0 2
56678: ARRAY
56679: PUSH
56680: LD_INT 1
56682: ARRAY
56683: PPUSH
56684: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
56688: LD_VAR 0 3
56692: PPUSH
56693: CALL_OW 461
56697: PUSH
56698: LD_INT 6
56700: EQUAL
56701: PUSH
56702: LD_VAR 0 6
56706: PUSH
56707: LD_INT 1
56709: GREATER
56710: AND
56711: IFFALSE 56863
// begin sci := [ ] ;
56713: LD_ADDR_VAR 0 8
56717: PUSH
56718: EMPTY
56719: ST_TO_ADDR
// for x in ( tmp diff j ) do
56720: LD_ADDR_VAR 0 7
56724: PUSH
56725: LD_VAR 0 6
56729: PUSH
56730: LD_VAR 0 3
56734: DIFF
56735: PUSH
56736: FOR_IN
56737: IFFALSE 56789
// begin if sci = 6 then
56739: LD_VAR 0 8
56743: PUSH
56744: LD_INT 6
56746: EQUAL
56747: IFFALSE 56751
// break ;
56749: GO 56789
// if BuildingStatus ( x ) = bs_idle then
56751: LD_VAR 0 7
56755: PPUSH
56756: CALL_OW 461
56760: PUSH
56761: LD_INT 2
56763: EQUAL
56764: IFFALSE 56787
// sci := sci ^ UnitsInside ( x ) ;
56766: LD_ADDR_VAR 0 8
56770: PUSH
56771: LD_VAR 0 8
56775: PUSH
56776: LD_VAR 0 7
56780: PPUSH
56781: CALL_OW 313
56785: ADD
56786: ST_TO_ADDR
// end ;
56787: GO 56736
56789: POP
56790: POP
// if not sci then
56791: LD_VAR 0 8
56795: NOT
56796: IFFALSE 56800
// continue ;
56798: GO 55845
// for x in sci do
56800: LD_ADDR_VAR 0 7
56804: PUSH
56805: LD_VAR 0 8
56809: PUSH
56810: FOR_IN
56811: IFFALSE 56861
// if IsInUnit ( x ) and not HasTask ( x ) then
56813: LD_VAR 0 7
56817: PPUSH
56818: CALL_OW 310
56822: PUSH
56823: LD_VAR 0 7
56827: PPUSH
56828: CALL_OW 314
56832: NOT
56833: AND
56834: IFFALSE 56859
// begin ComExitBuilding ( x ) ;
56836: LD_VAR 0 7
56840: PPUSH
56841: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
56845: LD_VAR 0 7
56849: PPUSH
56850: LD_VAR 0 3
56854: PPUSH
56855: CALL_OW 180
// end ;
56859: GO 56810
56861: POP
56862: POP
// end ; end ;
56863: GO 55845
56865: POP
56866: POP
// end ;
56867: GO 55799
56869: POP
56870: POP
// end ;
56871: LD_VAR 0 1
56875: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
56876: LD_INT 0
56878: PPUSH
56879: PPUSH
// if not mc_bases then
56880: LD_EXP 102
56884: NOT
56885: IFFALSE 56889
// exit ;
56887: GO 56970
// for i = 1 to mc_bases do
56889: LD_ADDR_VAR 0 2
56893: PUSH
56894: DOUBLE
56895: LD_INT 1
56897: DEC
56898: ST_TO_ADDR
56899: LD_EXP 102
56903: PUSH
56904: FOR_TO
56905: IFFALSE 56968
// if mc_mines [ i ] and mc_miners [ i ] then
56907: LD_EXP 115
56911: PUSH
56912: LD_VAR 0 2
56916: ARRAY
56917: PUSH
56918: LD_EXP 116
56922: PUSH
56923: LD_VAR 0 2
56927: ARRAY
56928: AND
56929: IFFALSE 56966
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
56931: LD_EXP 116
56935: PUSH
56936: LD_VAR 0 2
56940: ARRAY
56941: PUSH
56942: LD_INT 1
56944: ARRAY
56945: PPUSH
56946: CALL_OW 255
56950: PPUSH
56951: LD_EXP 115
56955: PUSH
56956: LD_VAR 0 2
56960: ARRAY
56961: PPUSH
56962: CALL 71609 0 2
56966: GO 56904
56968: POP
56969: POP
// end ;
56970: LD_VAR 0 1
56974: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
56975: LD_INT 0
56977: PPUSH
56978: PPUSH
56979: PPUSH
56980: PPUSH
56981: PPUSH
56982: PPUSH
56983: PPUSH
56984: PPUSH
// if not mc_bases or not mc_parking then
56985: LD_EXP 102
56989: NOT
56990: PUSH
56991: LD_EXP 126
56995: NOT
56996: OR
56997: IFFALSE 57001
// exit ;
56999: GO 57739
// for i = 1 to mc_bases do
57001: LD_ADDR_VAR 0 2
57005: PUSH
57006: DOUBLE
57007: LD_INT 1
57009: DEC
57010: ST_TO_ADDR
57011: LD_EXP 102
57015: PUSH
57016: FOR_TO
57017: IFFALSE 57737
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
57019: LD_EXP 102
57023: PUSH
57024: LD_VAR 0 2
57028: ARRAY
57029: NOT
57030: PUSH
57031: LD_EXP 126
57035: PUSH
57036: LD_VAR 0 2
57040: ARRAY
57041: NOT
57042: OR
57043: IFFALSE 57047
// continue ;
57045: GO 57016
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
57047: LD_ADDR_VAR 0 5
57051: PUSH
57052: LD_EXP 102
57056: PUSH
57057: LD_VAR 0 2
57061: ARRAY
57062: PUSH
57063: LD_INT 1
57065: ARRAY
57066: PPUSH
57067: CALL_OW 255
57071: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
57072: LD_ADDR_VAR 0 6
57076: PUSH
57077: LD_EXP 102
57081: PUSH
57082: LD_VAR 0 2
57086: ARRAY
57087: PPUSH
57088: LD_INT 30
57090: PUSH
57091: LD_INT 3
57093: PUSH
57094: EMPTY
57095: LIST
57096: LIST
57097: PPUSH
57098: CALL_OW 72
57102: ST_TO_ADDR
// if not fac then
57103: LD_VAR 0 6
57107: NOT
57108: IFFALSE 57159
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57110: LD_ADDR_VAR 0 6
57114: PUSH
57115: LD_EXP 102
57119: PUSH
57120: LD_VAR 0 2
57124: ARRAY
57125: PPUSH
57126: LD_INT 2
57128: PUSH
57129: LD_INT 30
57131: PUSH
57132: LD_INT 0
57134: PUSH
57135: EMPTY
57136: LIST
57137: LIST
57138: PUSH
57139: LD_INT 30
57141: PUSH
57142: LD_INT 1
57144: PUSH
57145: EMPTY
57146: LIST
57147: LIST
57148: PUSH
57149: EMPTY
57150: LIST
57151: LIST
57152: LIST
57153: PPUSH
57154: CALL_OW 72
57158: ST_TO_ADDR
// if not fac then
57159: LD_VAR 0 6
57163: NOT
57164: IFFALSE 57168
// continue ;
57166: GO 57016
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
57168: LD_ADDR_VAR 0 7
57172: PUSH
57173: LD_EXP 126
57177: PUSH
57178: LD_VAR 0 2
57182: ARRAY
57183: PPUSH
57184: LD_INT 22
57186: PUSH
57187: LD_VAR 0 5
57191: PUSH
57192: EMPTY
57193: LIST
57194: LIST
57195: PUSH
57196: LD_INT 21
57198: PUSH
57199: LD_INT 2
57201: PUSH
57202: EMPTY
57203: LIST
57204: LIST
57205: PUSH
57206: LD_INT 3
57208: PUSH
57209: LD_INT 60
57211: PUSH
57212: EMPTY
57213: LIST
57214: PUSH
57215: EMPTY
57216: LIST
57217: LIST
57218: PUSH
57219: LD_INT 3
57221: PUSH
57222: LD_INT 24
57224: PUSH
57225: LD_INT 1000
57227: PUSH
57228: EMPTY
57229: LIST
57230: LIST
57231: PUSH
57232: EMPTY
57233: LIST
57234: LIST
57235: PUSH
57236: EMPTY
57237: LIST
57238: LIST
57239: LIST
57240: LIST
57241: PPUSH
57242: CALL_OW 70
57246: ST_TO_ADDR
// for j in fac do
57247: LD_ADDR_VAR 0 3
57251: PUSH
57252: LD_VAR 0 6
57256: PUSH
57257: FOR_IN
57258: IFFALSE 57353
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
57260: LD_ADDR_VAR 0 7
57264: PUSH
57265: LD_VAR 0 7
57269: PUSH
57270: LD_INT 22
57272: PUSH
57273: LD_VAR 0 5
57277: PUSH
57278: EMPTY
57279: LIST
57280: LIST
57281: PUSH
57282: LD_INT 91
57284: PUSH
57285: LD_VAR 0 3
57289: PUSH
57290: LD_INT 15
57292: PUSH
57293: EMPTY
57294: LIST
57295: LIST
57296: LIST
57297: PUSH
57298: LD_INT 21
57300: PUSH
57301: LD_INT 2
57303: PUSH
57304: EMPTY
57305: LIST
57306: LIST
57307: PUSH
57308: LD_INT 3
57310: PUSH
57311: LD_INT 60
57313: PUSH
57314: EMPTY
57315: LIST
57316: PUSH
57317: EMPTY
57318: LIST
57319: LIST
57320: PUSH
57321: LD_INT 3
57323: PUSH
57324: LD_INT 24
57326: PUSH
57327: LD_INT 1000
57329: PUSH
57330: EMPTY
57331: LIST
57332: LIST
57333: PUSH
57334: EMPTY
57335: LIST
57336: LIST
57337: PUSH
57338: EMPTY
57339: LIST
57340: LIST
57341: LIST
57342: LIST
57343: LIST
57344: PPUSH
57345: CALL_OW 69
57349: UNION
57350: ST_TO_ADDR
57351: GO 57257
57353: POP
57354: POP
// if not vehs then
57355: LD_VAR 0 7
57359: NOT
57360: IFFALSE 57386
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57362: LD_ADDR_EXP 114
57366: PUSH
57367: LD_EXP 114
57371: PPUSH
57372: LD_VAR 0 2
57376: PPUSH
57377: EMPTY
57378: PPUSH
57379: CALL_OW 1
57383: ST_TO_ADDR
// continue ;
57384: GO 57016
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
57386: LD_ADDR_VAR 0 8
57390: PUSH
57391: LD_EXP 102
57395: PUSH
57396: LD_VAR 0 2
57400: ARRAY
57401: PPUSH
57402: LD_INT 30
57404: PUSH
57405: LD_INT 3
57407: PUSH
57408: EMPTY
57409: LIST
57410: LIST
57411: PPUSH
57412: CALL_OW 72
57416: ST_TO_ADDR
// if tmp then
57417: LD_VAR 0 8
57421: IFFALSE 57524
// begin for j in tmp do
57423: LD_ADDR_VAR 0 3
57427: PUSH
57428: LD_VAR 0 8
57432: PUSH
57433: FOR_IN
57434: IFFALSE 57522
// for k in UnitsInside ( j ) do
57436: LD_ADDR_VAR 0 4
57440: PUSH
57441: LD_VAR 0 3
57445: PPUSH
57446: CALL_OW 313
57450: PUSH
57451: FOR_IN
57452: IFFALSE 57518
// if k then
57454: LD_VAR 0 4
57458: IFFALSE 57516
// if not k in mc_repair_vehicle [ i ] then
57460: LD_VAR 0 4
57464: PUSH
57465: LD_EXP 114
57469: PUSH
57470: LD_VAR 0 2
57474: ARRAY
57475: IN
57476: NOT
57477: IFFALSE 57516
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
57479: LD_ADDR_EXP 114
57483: PUSH
57484: LD_EXP 114
57488: PPUSH
57489: LD_VAR 0 2
57493: PPUSH
57494: LD_EXP 114
57498: PUSH
57499: LD_VAR 0 2
57503: ARRAY
57504: PUSH
57505: LD_VAR 0 4
57509: UNION
57510: PPUSH
57511: CALL_OW 1
57515: ST_TO_ADDR
57516: GO 57451
57518: POP
57519: POP
57520: GO 57433
57522: POP
57523: POP
// end ; if not mc_repair_vehicle [ i ] then
57524: LD_EXP 114
57528: PUSH
57529: LD_VAR 0 2
57533: ARRAY
57534: NOT
57535: IFFALSE 57539
// continue ;
57537: GO 57016
// for j in mc_repair_vehicle [ i ] do
57539: LD_ADDR_VAR 0 3
57543: PUSH
57544: LD_EXP 114
57548: PUSH
57549: LD_VAR 0 2
57553: ARRAY
57554: PUSH
57555: FOR_IN
57556: IFFALSE 57733
// begin if GetClass ( j ) <> 3 then
57558: LD_VAR 0 3
57562: PPUSH
57563: CALL_OW 257
57567: PUSH
57568: LD_INT 3
57570: NONEQUAL
57571: IFFALSE 57612
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
57573: LD_ADDR_EXP 114
57577: PUSH
57578: LD_EXP 114
57582: PPUSH
57583: LD_VAR 0 2
57587: PPUSH
57588: LD_EXP 114
57592: PUSH
57593: LD_VAR 0 2
57597: ARRAY
57598: PUSH
57599: LD_VAR 0 3
57603: DIFF
57604: PPUSH
57605: CALL_OW 1
57609: ST_TO_ADDR
// continue ;
57610: GO 57555
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
57612: LD_VAR 0 3
57616: PPUSH
57617: CALL_OW 311
57621: NOT
57622: PUSH
57623: LD_VAR 0 3
57627: PUSH
57628: LD_EXP 105
57632: PUSH
57633: LD_VAR 0 2
57637: ARRAY
57638: PUSH
57639: LD_INT 1
57641: ARRAY
57642: IN
57643: NOT
57644: AND
57645: PUSH
57646: LD_VAR 0 3
57650: PUSH
57651: LD_EXP 105
57655: PUSH
57656: LD_VAR 0 2
57660: ARRAY
57661: PUSH
57662: LD_INT 2
57664: ARRAY
57665: IN
57666: NOT
57667: AND
57668: IFFALSE 57731
// begin if IsInUnit ( j ) then
57670: LD_VAR 0 3
57674: PPUSH
57675: CALL_OW 310
57679: IFFALSE 57692
// ComExitBuilding ( j ) else
57681: LD_VAR 0 3
57685: PPUSH
57686: CALL_OW 122
57690: GO 57731
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
57692: LD_VAR 0 3
57696: PPUSH
57697: LD_VAR 0 7
57701: PUSH
57702: LD_INT 1
57704: ARRAY
57705: PPUSH
57706: CALL 109426 0 2
57710: NOT
57711: IFFALSE 57731
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
57713: LD_VAR 0 3
57717: PPUSH
57718: LD_VAR 0 7
57722: PUSH
57723: LD_INT 1
57725: ARRAY
57726: PPUSH
57727: CALL_OW 129
// end ; end ;
57731: GO 57555
57733: POP
57734: POP
// end ;
57735: GO 57016
57737: POP
57738: POP
// end ;
57739: LD_VAR 0 1
57743: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
57744: LD_INT 0
57746: PPUSH
57747: PPUSH
57748: PPUSH
57749: PPUSH
57750: PPUSH
57751: PPUSH
57752: PPUSH
57753: PPUSH
57754: PPUSH
57755: PPUSH
57756: PPUSH
// if not mc_bases then
57757: LD_EXP 102
57761: NOT
57762: IFFALSE 57766
// exit ;
57764: GO 58568
// for i = 1 to mc_bases do
57766: LD_ADDR_VAR 0 2
57770: PUSH
57771: DOUBLE
57772: LD_INT 1
57774: DEC
57775: ST_TO_ADDR
57776: LD_EXP 102
57780: PUSH
57781: FOR_TO
57782: IFFALSE 58566
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
57784: LD_EXP 130
57788: PUSH
57789: LD_VAR 0 2
57793: ARRAY
57794: NOT
57795: PUSH
57796: LD_EXP 105
57800: PUSH
57801: LD_VAR 0 2
57805: ARRAY
57806: PUSH
57807: LD_INT 1
57809: ARRAY
57810: OR
57811: PUSH
57812: LD_EXP 105
57816: PUSH
57817: LD_VAR 0 2
57821: ARRAY
57822: PUSH
57823: LD_INT 2
57825: ARRAY
57826: OR
57827: PUSH
57828: LD_EXP 128
57832: PUSH
57833: LD_VAR 0 2
57837: ARRAY
57838: PPUSH
57839: LD_INT 1
57841: PPUSH
57842: CALL_OW 325
57846: NOT
57847: OR
57848: PUSH
57849: LD_EXP 125
57853: PUSH
57854: LD_VAR 0 2
57858: ARRAY
57859: OR
57860: IFFALSE 57864
// continue ;
57862: GO 57781
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
57864: LD_ADDR_VAR 0 8
57868: PUSH
57869: LD_EXP 102
57873: PUSH
57874: LD_VAR 0 2
57878: ARRAY
57879: PPUSH
57880: LD_INT 25
57882: PUSH
57883: LD_INT 4
57885: PUSH
57886: EMPTY
57887: LIST
57888: LIST
57889: PUSH
57890: LD_INT 50
57892: PUSH
57893: EMPTY
57894: LIST
57895: PUSH
57896: LD_INT 3
57898: PUSH
57899: LD_INT 60
57901: PUSH
57902: EMPTY
57903: LIST
57904: PUSH
57905: EMPTY
57906: LIST
57907: LIST
57908: PUSH
57909: EMPTY
57910: LIST
57911: LIST
57912: LIST
57913: PPUSH
57914: CALL_OW 72
57918: PUSH
57919: LD_EXP 106
57923: PUSH
57924: LD_VAR 0 2
57928: ARRAY
57929: DIFF
57930: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57931: LD_ADDR_VAR 0 9
57935: PUSH
57936: LD_EXP 102
57940: PUSH
57941: LD_VAR 0 2
57945: ARRAY
57946: PPUSH
57947: LD_INT 2
57949: PUSH
57950: LD_INT 30
57952: PUSH
57953: LD_INT 0
57955: PUSH
57956: EMPTY
57957: LIST
57958: LIST
57959: PUSH
57960: LD_INT 30
57962: PUSH
57963: LD_INT 1
57965: PUSH
57966: EMPTY
57967: LIST
57968: LIST
57969: PUSH
57970: EMPTY
57971: LIST
57972: LIST
57973: LIST
57974: PPUSH
57975: CALL_OW 72
57979: ST_TO_ADDR
// if not tmp or not dep then
57980: LD_VAR 0 8
57984: NOT
57985: PUSH
57986: LD_VAR 0 9
57990: NOT
57991: OR
57992: IFFALSE 57996
// continue ;
57994: GO 57781
// side := GetSide ( tmp [ 1 ] ) ;
57996: LD_ADDR_VAR 0 11
58000: PUSH
58001: LD_VAR 0 8
58005: PUSH
58006: LD_INT 1
58008: ARRAY
58009: PPUSH
58010: CALL_OW 255
58014: ST_TO_ADDR
// dep := dep [ 1 ] ;
58015: LD_ADDR_VAR 0 9
58019: PUSH
58020: LD_VAR 0 9
58024: PUSH
58025: LD_INT 1
58027: ARRAY
58028: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
58029: LD_ADDR_VAR 0 7
58033: PUSH
58034: LD_EXP 130
58038: PUSH
58039: LD_VAR 0 2
58043: ARRAY
58044: PPUSH
58045: LD_INT 22
58047: PUSH
58048: LD_INT 0
58050: PUSH
58051: EMPTY
58052: LIST
58053: LIST
58054: PUSH
58055: LD_INT 25
58057: PUSH
58058: LD_INT 12
58060: PUSH
58061: EMPTY
58062: LIST
58063: LIST
58064: PUSH
58065: EMPTY
58066: LIST
58067: LIST
58068: PPUSH
58069: CALL_OW 70
58073: PUSH
58074: LD_INT 22
58076: PUSH
58077: LD_INT 0
58079: PUSH
58080: EMPTY
58081: LIST
58082: LIST
58083: PUSH
58084: LD_INT 25
58086: PUSH
58087: LD_INT 12
58089: PUSH
58090: EMPTY
58091: LIST
58092: LIST
58093: PUSH
58094: LD_INT 91
58096: PUSH
58097: LD_VAR 0 9
58101: PUSH
58102: LD_INT 20
58104: PUSH
58105: EMPTY
58106: LIST
58107: LIST
58108: LIST
58109: PUSH
58110: EMPTY
58111: LIST
58112: LIST
58113: LIST
58114: PPUSH
58115: CALL_OW 69
58119: UNION
58120: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
58121: LD_ADDR_VAR 0 10
58125: PUSH
58126: LD_EXP 130
58130: PUSH
58131: LD_VAR 0 2
58135: ARRAY
58136: PPUSH
58137: LD_INT 81
58139: PUSH
58140: LD_VAR 0 11
58144: PUSH
58145: EMPTY
58146: LIST
58147: LIST
58148: PPUSH
58149: CALL_OW 70
58153: ST_TO_ADDR
// if not apes or danger_at_area then
58154: LD_VAR 0 7
58158: NOT
58159: PUSH
58160: LD_VAR 0 10
58164: OR
58165: IFFALSE 58215
// begin if mc_taming [ i ] then
58167: LD_EXP 133
58171: PUSH
58172: LD_VAR 0 2
58176: ARRAY
58177: IFFALSE 58213
// begin MC_Reset ( i , 121 ) ;
58179: LD_VAR 0 2
58183: PPUSH
58184: LD_INT 121
58186: PPUSH
58187: CALL 43131 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
58191: LD_ADDR_EXP 133
58195: PUSH
58196: LD_EXP 133
58200: PPUSH
58201: LD_VAR 0 2
58205: PPUSH
58206: EMPTY
58207: PPUSH
58208: CALL_OW 1
58212: ST_TO_ADDR
// end ; continue ;
58213: GO 57781
// end ; for j in tmp do
58215: LD_ADDR_VAR 0 3
58219: PUSH
58220: LD_VAR 0 8
58224: PUSH
58225: FOR_IN
58226: IFFALSE 58562
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
58228: LD_VAR 0 3
58232: PUSH
58233: LD_EXP 133
58237: PUSH
58238: LD_VAR 0 2
58242: ARRAY
58243: IN
58244: NOT
58245: PUSH
58246: LD_EXP 133
58250: PUSH
58251: LD_VAR 0 2
58255: ARRAY
58256: PUSH
58257: LD_INT 3
58259: LESS
58260: AND
58261: IFFALSE 58319
// begin SetTag ( j , 121 ) ;
58263: LD_VAR 0 3
58267: PPUSH
58268: LD_INT 121
58270: PPUSH
58271: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
58275: LD_ADDR_EXP 133
58279: PUSH
58280: LD_EXP 133
58284: PPUSH
58285: LD_VAR 0 2
58289: PUSH
58290: LD_EXP 133
58294: PUSH
58295: LD_VAR 0 2
58299: ARRAY
58300: PUSH
58301: LD_INT 1
58303: PLUS
58304: PUSH
58305: EMPTY
58306: LIST
58307: LIST
58308: PPUSH
58309: LD_VAR 0 3
58313: PPUSH
58314: CALL 74632 0 3
58318: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
58319: LD_VAR 0 3
58323: PUSH
58324: LD_EXP 133
58328: PUSH
58329: LD_VAR 0 2
58333: ARRAY
58334: IN
58335: IFFALSE 58560
// begin if GetClass ( j ) <> 4 then
58337: LD_VAR 0 3
58341: PPUSH
58342: CALL_OW 257
58346: PUSH
58347: LD_INT 4
58349: NONEQUAL
58350: IFFALSE 58403
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
58352: LD_ADDR_EXP 133
58356: PUSH
58357: LD_EXP 133
58361: PPUSH
58362: LD_VAR 0 2
58366: PPUSH
58367: LD_EXP 133
58371: PUSH
58372: LD_VAR 0 2
58376: ARRAY
58377: PUSH
58378: LD_VAR 0 3
58382: DIFF
58383: PPUSH
58384: CALL_OW 1
58388: ST_TO_ADDR
// SetTag ( j , 0 ) ;
58389: LD_VAR 0 3
58393: PPUSH
58394: LD_INT 0
58396: PPUSH
58397: CALL_OW 109
// continue ;
58401: GO 58225
// end ; if IsInUnit ( j ) then
58403: LD_VAR 0 3
58407: PPUSH
58408: CALL_OW 310
58412: IFFALSE 58423
// ComExitBuilding ( j ) ;
58414: LD_VAR 0 3
58418: PPUSH
58419: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
58423: LD_ADDR_VAR 0 6
58427: PUSH
58428: LD_VAR 0 7
58432: PPUSH
58433: LD_VAR 0 3
58437: PPUSH
58438: CALL_OW 74
58442: ST_TO_ADDR
// if not ape then
58443: LD_VAR 0 6
58447: NOT
58448: IFFALSE 58452
// break ;
58450: GO 58562
// x := GetX ( ape ) ;
58452: LD_ADDR_VAR 0 4
58456: PUSH
58457: LD_VAR 0 6
58461: PPUSH
58462: CALL_OW 250
58466: ST_TO_ADDR
// y := GetY ( ape ) ;
58467: LD_ADDR_VAR 0 5
58471: PUSH
58472: LD_VAR 0 6
58476: PPUSH
58477: CALL_OW 251
58481: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
58482: LD_VAR 0 4
58486: PPUSH
58487: LD_VAR 0 5
58491: PPUSH
58492: CALL_OW 488
58496: NOT
58497: PUSH
58498: LD_VAR 0 11
58502: PPUSH
58503: LD_VAR 0 4
58507: PPUSH
58508: LD_VAR 0 5
58512: PPUSH
58513: LD_INT 20
58515: PPUSH
58516: CALL 75896 0 4
58520: PUSH
58521: LD_INT 4
58523: ARRAY
58524: OR
58525: IFFALSE 58529
// break ;
58527: GO 58562
// if not HasTask ( j ) then
58529: LD_VAR 0 3
58533: PPUSH
58534: CALL_OW 314
58538: NOT
58539: IFFALSE 58560
// ComTameXY ( j , x , y ) ;
58541: LD_VAR 0 3
58545: PPUSH
58546: LD_VAR 0 4
58550: PPUSH
58551: LD_VAR 0 5
58555: PPUSH
58556: CALL_OW 131
// end ; end ;
58560: GO 58225
58562: POP
58563: POP
// end ;
58564: GO 57781
58566: POP
58567: POP
// end ;
58568: LD_VAR 0 1
58572: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
58573: LD_INT 0
58575: PPUSH
58576: PPUSH
58577: PPUSH
58578: PPUSH
58579: PPUSH
58580: PPUSH
58581: PPUSH
58582: PPUSH
// if not mc_bases then
58583: LD_EXP 102
58587: NOT
58588: IFFALSE 58592
// exit ;
58590: GO 59218
// for i = 1 to mc_bases do
58592: LD_ADDR_VAR 0 2
58596: PUSH
58597: DOUBLE
58598: LD_INT 1
58600: DEC
58601: ST_TO_ADDR
58602: LD_EXP 102
58606: PUSH
58607: FOR_TO
58608: IFFALSE 59216
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
58610: LD_EXP 131
58614: PUSH
58615: LD_VAR 0 2
58619: ARRAY
58620: NOT
58621: PUSH
58622: LD_EXP 131
58626: PUSH
58627: LD_VAR 0 2
58631: ARRAY
58632: PPUSH
58633: LD_INT 25
58635: PUSH
58636: LD_INT 12
58638: PUSH
58639: EMPTY
58640: LIST
58641: LIST
58642: PPUSH
58643: CALL_OW 72
58647: NOT
58648: OR
58649: IFFALSE 58653
// continue ;
58651: GO 58607
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
58653: LD_ADDR_VAR 0 5
58657: PUSH
58658: LD_EXP 131
58662: PUSH
58663: LD_VAR 0 2
58667: ARRAY
58668: PUSH
58669: LD_INT 1
58671: ARRAY
58672: PPUSH
58673: CALL_OW 255
58677: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
58678: LD_VAR 0 5
58682: PPUSH
58683: LD_INT 2
58685: PPUSH
58686: CALL_OW 325
58690: IFFALSE 58943
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
58692: LD_ADDR_VAR 0 4
58696: PUSH
58697: LD_EXP 131
58701: PUSH
58702: LD_VAR 0 2
58706: ARRAY
58707: PPUSH
58708: LD_INT 25
58710: PUSH
58711: LD_INT 16
58713: PUSH
58714: EMPTY
58715: LIST
58716: LIST
58717: PPUSH
58718: CALL_OW 72
58722: ST_TO_ADDR
// if tmp < 6 then
58723: LD_VAR 0 4
58727: PUSH
58728: LD_INT 6
58730: LESS
58731: IFFALSE 58943
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58733: LD_ADDR_VAR 0 6
58737: PUSH
58738: LD_EXP 102
58742: PUSH
58743: LD_VAR 0 2
58747: ARRAY
58748: PPUSH
58749: LD_INT 2
58751: PUSH
58752: LD_INT 30
58754: PUSH
58755: LD_INT 0
58757: PUSH
58758: EMPTY
58759: LIST
58760: LIST
58761: PUSH
58762: LD_INT 30
58764: PUSH
58765: LD_INT 1
58767: PUSH
58768: EMPTY
58769: LIST
58770: LIST
58771: PUSH
58772: EMPTY
58773: LIST
58774: LIST
58775: LIST
58776: PPUSH
58777: CALL_OW 72
58781: ST_TO_ADDR
// if depot then
58782: LD_VAR 0 6
58786: IFFALSE 58943
// begin selected := 0 ;
58788: LD_ADDR_VAR 0 7
58792: PUSH
58793: LD_INT 0
58795: ST_TO_ADDR
// for j in depot do
58796: LD_ADDR_VAR 0 3
58800: PUSH
58801: LD_VAR 0 6
58805: PUSH
58806: FOR_IN
58807: IFFALSE 58838
// begin if UnitsInside ( j ) < 6 then
58809: LD_VAR 0 3
58813: PPUSH
58814: CALL_OW 313
58818: PUSH
58819: LD_INT 6
58821: LESS
58822: IFFALSE 58836
// begin selected := j ;
58824: LD_ADDR_VAR 0 7
58828: PUSH
58829: LD_VAR 0 3
58833: ST_TO_ADDR
// break ;
58834: GO 58838
// end ; end ;
58836: GO 58806
58838: POP
58839: POP
// if selected then
58840: LD_VAR 0 7
58844: IFFALSE 58943
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
58846: LD_ADDR_VAR 0 3
58850: PUSH
58851: LD_EXP 131
58855: PUSH
58856: LD_VAR 0 2
58860: ARRAY
58861: PPUSH
58862: LD_INT 25
58864: PUSH
58865: LD_INT 12
58867: PUSH
58868: EMPTY
58869: LIST
58870: LIST
58871: PPUSH
58872: CALL_OW 72
58876: PUSH
58877: FOR_IN
58878: IFFALSE 58941
// if not HasTask ( j ) then
58880: LD_VAR 0 3
58884: PPUSH
58885: CALL_OW 314
58889: NOT
58890: IFFALSE 58939
// begin if not IsInUnit ( j ) then
58892: LD_VAR 0 3
58896: PPUSH
58897: CALL_OW 310
58901: NOT
58902: IFFALSE 58918
// ComEnterUnit ( j , selected ) ;
58904: LD_VAR 0 3
58908: PPUSH
58909: LD_VAR 0 7
58913: PPUSH
58914: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
58918: LD_VAR 0 3
58922: PPUSH
58923: LD_INT 16
58925: PPUSH
58926: CALL_OW 183
// AddComExitBuilding ( j ) ;
58930: LD_VAR 0 3
58934: PPUSH
58935: CALL_OW 182
// end ;
58939: GO 58877
58941: POP
58942: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
58943: LD_VAR 0 5
58947: PPUSH
58948: LD_INT 11
58950: PPUSH
58951: CALL_OW 325
58955: IFFALSE 59214
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
58957: LD_ADDR_VAR 0 4
58961: PUSH
58962: LD_EXP 131
58966: PUSH
58967: LD_VAR 0 2
58971: ARRAY
58972: PPUSH
58973: LD_INT 25
58975: PUSH
58976: LD_INT 16
58978: PUSH
58979: EMPTY
58980: LIST
58981: LIST
58982: PPUSH
58983: CALL_OW 72
58987: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
58988: LD_VAR 0 4
58992: PUSH
58993: LD_INT 6
58995: GREATEREQUAL
58996: PUSH
58997: LD_VAR 0 5
59001: PPUSH
59002: LD_INT 2
59004: PPUSH
59005: CALL_OW 325
59009: NOT
59010: OR
59011: IFFALSE 59214
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
59013: LD_ADDR_VAR 0 8
59017: PUSH
59018: LD_EXP 102
59022: PUSH
59023: LD_VAR 0 2
59027: ARRAY
59028: PPUSH
59029: LD_INT 2
59031: PUSH
59032: LD_INT 30
59034: PUSH
59035: LD_INT 4
59037: PUSH
59038: EMPTY
59039: LIST
59040: LIST
59041: PUSH
59042: LD_INT 30
59044: PUSH
59045: LD_INT 5
59047: PUSH
59048: EMPTY
59049: LIST
59050: LIST
59051: PUSH
59052: EMPTY
59053: LIST
59054: LIST
59055: LIST
59056: PPUSH
59057: CALL_OW 72
59061: ST_TO_ADDR
// if barracks then
59062: LD_VAR 0 8
59066: IFFALSE 59214
// begin selected := 0 ;
59068: LD_ADDR_VAR 0 7
59072: PUSH
59073: LD_INT 0
59075: ST_TO_ADDR
// for j in barracks do
59076: LD_ADDR_VAR 0 3
59080: PUSH
59081: LD_VAR 0 8
59085: PUSH
59086: FOR_IN
59087: IFFALSE 59118
// begin if UnitsInside ( j ) < 6 then
59089: LD_VAR 0 3
59093: PPUSH
59094: CALL_OW 313
59098: PUSH
59099: LD_INT 6
59101: LESS
59102: IFFALSE 59116
// begin selected := j ;
59104: LD_ADDR_VAR 0 7
59108: PUSH
59109: LD_VAR 0 3
59113: ST_TO_ADDR
// break ;
59114: GO 59118
// end ; end ;
59116: GO 59086
59118: POP
59119: POP
// if selected then
59120: LD_VAR 0 7
59124: IFFALSE 59214
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
59126: LD_ADDR_VAR 0 3
59130: PUSH
59131: LD_EXP 131
59135: PUSH
59136: LD_VAR 0 2
59140: ARRAY
59141: PPUSH
59142: LD_INT 25
59144: PUSH
59145: LD_INT 12
59147: PUSH
59148: EMPTY
59149: LIST
59150: LIST
59151: PPUSH
59152: CALL_OW 72
59156: PUSH
59157: FOR_IN
59158: IFFALSE 59212
// if not IsInUnit ( j ) and not HasTask ( j ) then
59160: LD_VAR 0 3
59164: PPUSH
59165: CALL_OW 310
59169: NOT
59170: PUSH
59171: LD_VAR 0 3
59175: PPUSH
59176: CALL_OW 314
59180: NOT
59181: AND
59182: IFFALSE 59210
// begin ComEnterUnit ( j , selected ) ;
59184: LD_VAR 0 3
59188: PPUSH
59189: LD_VAR 0 7
59193: PPUSH
59194: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
59198: LD_VAR 0 3
59202: PPUSH
59203: LD_INT 15
59205: PPUSH
59206: CALL_OW 183
// end ;
59210: GO 59157
59212: POP
59213: POP
// end ; end ; end ; end ; end ;
59214: GO 58607
59216: POP
59217: POP
// end ;
59218: LD_VAR 0 1
59222: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
59223: LD_INT 0
59225: PPUSH
59226: PPUSH
59227: PPUSH
59228: PPUSH
// if not mc_bases then
59229: LD_EXP 102
59233: NOT
59234: IFFALSE 59238
// exit ;
59236: GO 59416
// for i = 1 to mc_bases do
59238: LD_ADDR_VAR 0 2
59242: PUSH
59243: DOUBLE
59244: LD_INT 1
59246: DEC
59247: ST_TO_ADDR
59248: LD_EXP 102
59252: PUSH
59253: FOR_TO
59254: IFFALSE 59414
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
59256: LD_ADDR_VAR 0 4
59260: PUSH
59261: LD_EXP 102
59265: PUSH
59266: LD_VAR 0 2
59270: ARRAY
59271: PPUSH
59272: LD_INT 25
59274: PUSH
59275: LD_INT 9
59277: PUSH
59278: EMPTY
59279: LIST
59280: LIST
59281: PPUSH
59282: CALL_OW 72
59286: ST_TO_ADDR
// if not tmp then
59287: LD_VAR 0 4
59291: NOT
59292: IFFALSE 59296
// continue ;
59294: GO 59253
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
59296: LD_EXP 128
59300: PUSH
59301: LD_VAR 0 2
59305: ARRAY
59306: PPUSH
59307: LD_INT 29
59309: PPUSH
59310: CALL_OW 325
59314: NOT
59315: PUSH
59316: LD_EXP 128
59320: PUSH
59321: LD_VAR 0 2
59325: ARRAY
59326: PPUSH
59327: LD_INT 28
59329: PPUSH
59330: CALL_OW 325
59334: NOT
59335: AND
59336: IFFALSE 59340
// continue ;
59338: GO 59253
// for j in tmp do
59340: LD_ADDR_VAR 0 3
59344: PUSH
59345: LD_VAR 0 4
59349: PUSH
59350: FOR_IN
59351: IFFALSE 59410
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
59353: LD_VAR 0 3
59357: PUSH
59358: LD_EXP 105
59362: PUSH
59363: LD_VAR 0 2
59367: ARRAY
59368: PUSH
59369: LD_INT 1
59371: ARRAY
59372: IN
59373: NOT
59374: PUSH
59375: LD_VAR 0 3
59379: PUSH
59380: LD_EXP 105
59384: PUSH
59385: LD_VAR 0 2
59389: ARRAY
59390: PUSH
59391: LD_INT 2
59393: ARRAY
59394: IN
59395: NOT
59396: AND
59397: IFFALSE 59408
// ComSpaceTimeShoot ( j ) ;
59399: LD_VAR 0 3
59403: PPUSH
59404: CALL 70617 0 1
59408: GO 59350
59410: POP
59411: POP
// end ;
59412: GO 59253
59414: POP
59415: POP
// end ;
59416: LD_VAR 0 1
59420: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
59421: LD_INT 0
59423: PPUSH
59424: PPUSH
59425: PPUSH
59426: PPUSH
59427: PPUSH
59428: PPUSH
59429: PPUSH
59430: PPUSH
59431: PPUSH
// if not mc_bases then
59432: LD_EXP 102
59436: NOT
59437: IFFALSE 59441
// exit ;
59439: GO 60063
// for i = 1 to mc_bases do
59441: LD_ADDR_VAR 0 2
59445: PUSH
59446: DOUBLE
59447: LD_INT 1
59449: DEC
59450: ST_TO_ADDR
59451: LD_EXP 102
59455: PUSH
59456: FOR_TO
59457: IFFALSE 60061
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
59459: LD_EXP 137
59463: PUSH
59464: LD_VAR 0 2
59468: ARRAY
59469: NOT
59470: PUSH
59471: LD_INT 38
59473: PPUSH
59474: LD_EXP 128
59478: PUSH
59479: LD_VAR 0 2
59483: ARRAY
59484: PPUSH
59485: CALL_OW 321
59489: PUSH
59490: LD_INT 2
59492: NONEQUAL
59493: OR
59494: IFFALSE 59498
// continue ;
59496: GO 59456
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
59498: LD_ADDR_VAR 0 8
59502: PUSH
59503: LD_EXP 102
59507: PUSH
59508: LD_VAR 0 2
59512: ARRAY
59513: PPUSH
59514: LD_INT 30
59516: PUSH
59517: LD_INT 34
59519: PUSH
59520: EMPTY
59521: LIST
59522: LIST
59523: PPUSH
59524: CALL_OW 72
59528: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
59529: LD_ADDR_VAR 0 9
59533: PUSH
59534: LD_EXP 102
59538: PUSH
59539: LD_VAR 0 2
59543: ARRAY
59544: PPUSH
59545: LD_INT 25
59547: PUSH
59548: LD_INT 4
59550: PUSH
59551: EMPTY
59552: LIST
59553: LIST
59554: PPUSH
59555: CALL_OW 72
59559: PPUSH
59560: LD_INT 0
59562: PPUSH
59563: CALL 104930 0 2
59567: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
59568: LD_VAR 0 9
59572: NOT
59573: PUSH
59574: LD_VAR 0 8
59578: NOT
59579: OR
59580: PUSH
59581: LD_EXP 102
59585: PUSH
59586: LD_VAR 0 2
59590: ARRAY
59591: PPUSH
59592: LD_INT 124
59594: PPUSH
59595: CALL 104930 0 2
59599: OR
59600: IFFALSE 59604
// continue ;
59602: GO 59456
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
59604: LD_EXP 138
59608: PUSH
59609: LD_VAR 0 2
59613: ARRAY
59614: PUSH
59615: LD_EXP 137
59619: PUSH
59620: LD_VAR 0 2
59624: ARRAY
59625: LESS
59626: PUSH
59627: LD_EXP 138
59631: PUSH
59632: LD_VAR 0 2
59636: ARRAY
59637: PUSH
59638: LD_VAR 0 8
59642: LESS
59643: AND
59644: IFFALSE 60059
// begin tmp := sci [ 1 ] ;
59646: LD_ADDR_VAR 0 7
59650: PUSH
59651: LD_VAR 0 9
59655: PUSH
59656: LD_INT 1
59658: ARRAY
59659: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
59660: LD_VAR 0 7
59664: PPUSH
59665: LD_INT 124
59667: PPUSH
59668: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
59672: LD_ADDR_VAR 0 3
59676: PUSH
59677: DOUBLE
59678: LD_EXP 137
59682: PUSH
59683: LD_VAR 0 2
59687: ARRAY
59688: INC
59689: ST_TO_ADDR
59690: LD_EXP 137
59694: PUSH
59695: LD_VAR 0 2
59699: ARRAY
59700: PUSH
59701: FOR_DOWNTO
59702: IFFALSE 60045
// begin if IsInUnit ( tmp ) then
59704: LD_VAR 0 7
59708: PPUSH
59709: CALL_OW 310
59713: IFFALSE 59724
// ComExitBuilding ( tmp ) ;
59715: LD_VAR 0 7
59719: PPUSH
59720: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
59724: LD_INT 35
59726: PPUSH
59727: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
59731: LD_VAR 0 7
59735: PPUSH
59736: CALL_OW 310
59740: NOT
59741: PUSH
59742: LD_VAR 0 7
59746: PPUSH
59747: CALL_OW 314
59751: NOT
59752: AND
59753: IFFALSE 59724
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
59755: LD_ADDR_VAR 0 6
59759: PUSH
59760: LD_VAR 0 7
59764: PPUSH
59765: CALL_OW 250
59769: PUSH
59770: LD_VAR 0 7
59774: PPUSH
59775: CALL_OW 251
59779: PUSH
59780: EMPTY
59781: LIST
59782: LIST
59783: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
59784: LD_INT 35
59786: PPUSH
59787: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
59791: LD_ADDR_VAR 0 4
59795: PUSH
59796: LD_EXP 137
59800: PUSH
59801: LD_VAR 0 2
59805: ARRAY
59806: PUSH
59807: LD_VAR 0 3
59811: ARRAY
59812: PUSH
59813: LD_INT 1
59815: ARRAY
59816: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
59817: LD_ADDR_VAR 0 5
59821: PUSH
59822: LD_EXP 137
59826: PUSH
59827: LD_VAR 0 2
59831: ARRAY
59832: PUSH
59833: LD_VAR 0 3
59837: ARRAY
59838: PUSH
59839: LD_INT 2
59841: ARRAY
59842: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
59843: LD_VAR 0 7
59847: PPUSH
59848: LD_INT 10
59850: PPUSH
59851: CALL 77597 0 2
59855: PUSH
59856: LD_INT 4
59858: ARRAY
59859: IFFALSE 59897
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
59861: LD_VAR 0 7
59865: PPUSH
59866: LD_VAR 0 6
59870: PUSH
59871: LD_INT 1
59873: ARRAY
59874: PPUSH
59875: LD_VAR 0 6
59879: PUSH
59880: LD_INT 2
59882: ARRAY
59883: PPUSH
59884: CALL_OW 111
// wait ( 0 0$10 ) ;
59888: LD_INT 350
59890: PPUSH
59891: CALL_OW 67
// end else
59895: GO 59923
// begin ComMoveXY ( tmp , x , y ) ;
59897: LD_VAR 0 7
59901: PPUSH
59902: LD_VAR 0 4
59906: PPUSH
59907: LD_VAR 0 5
59911: PPUSH
59912: CALL_OW 111
// wait ( 0 0$3 ) ;
59916: LD_INT 105
59918: PPUSH
59919: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
59923: LD_VAR 0 7
59927: PPUSH
59928: LD_VAR 0 4
59932: PPUSH
59933: LD_VAR 0 5
59937: PPUSH
59938: CALL_OW 307
59942: IFFALSE 59784
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
59944: LD_VAR 0 7
59948: PPUSH
59949: LD_VAR 0 4
59953: PPUSH
59954: LD_VAR 0 5
59958: PPUSH
59959: LD_VAR 0 8
59963: PUSH
59964: LD_VAR 0 3
59968: ARRAY
59969: PPUSH
59970: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
59974: LD_INT 35
59976: PPUSH
59977: CALL_OW 67
// until not HasTask ( tmp ) ;
59981: LD_VAR 0 7
59985: PPUSH
59986: CALL_OW 314
59990: NOT
59991: IFFALSE 59974
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
59993: LD_ADDR_EXP 138
59997: PUSH
59998: LD_EXP 138
60002: PPUSH
60003: LD_VAR 0 2
60007: PUSH
60008: LD_EXP 138
60012: PUSH
60013: LD_VAR 0 2
60017: ARRAY
60018: PUSH
60019: LD_INT 1
60021: PLUS
60022: PUSH
60023: EMPTY
60024: LIST
60025: LIST
60026: PPUSH
60027: LD_VAR 0 8
60031: PUSH
60032: LD_VAR 0 3
60036: ARRAY
60037: PPUSH
60038: CALL 74632 0 3
60042: ST_TO_ADDR
// end ;
60043: GO 59701
60045: POP
60046: POP
// MC_Reset ( i , 124 ) ;
60047: LD_VAR 0 2
60051: PPUSH
60052: LD_INT 124
60054: PPUSH
60055: CALL 43131 0 2
// end ; end ;
60059: GO 59456
60061: POP
60062: POP
// end ;
60063: LD_VAR 0 1
60067: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
60068: LD_INT 0
60070: PPUSH
60071: PPUSH
60072: PPUSH
// if not mc_bases then
60073: LD_EXP 102
60077: NOT
60078: IFFALSE 60082
// exit ;
60080: GO 60688
// for i = 1 to mc_bases do
60082: LD_ADDR_VAR 0 2
60086: PUSH
60087: DOUBLE
60088: LD_INT 1
60090: DEC
60091: ST_TO_ADDR
60092: LD_EXP 102
60096: PUSH
60097: FOR_TO
60098: IFFALSE 60686
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
60100: LD_ADDR_VAR 0 3
60104: PUSH
60105: LD_EXP 102
60109: PUSH
60110: LD_VAR 0 2
60114: ARRAY
60115: PPUSH
60116: LD_INT 25
60118: PUSH
60119: LD_INT 4
60121: PUSH
60122: EMPTY
60123: LIST
60124: LIST
60125: PPUSH
60126: CALL_OW 72
60130: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
60131: LD_VAR 0 3
60135: NOT
60136: PUSH
60137: LD_EXP 139
60141: PUSH
60142: LD_VAR 0 2
60146: ARRAY
60147: NOT
60148: OR
60149: PUSH
60150: LD_EXP 102
60154: PUSH
60155: LD_VAR 0 2
60159: ARRAY
60160: PPUSH
60161: LD_INT 2
60163: PUSH
60164: LD_INT 30
60166: PUSH
60167: LD_INT 0
60169: PUSH
60170: EMPTY
60171: LIST
60172: LIST
60173: PUSH
60174: LD_INT 30
60176: PUSH
60177: LD_INT 1
60179: PUSH
60180: EMPTY
60181: LIST
60182: LIST
60183: PUSH
60184: EMPTY
60185: LIST
60186: LIST
60187: LIST
60188: PPUSH
60189: CALL_OW 72
60193: NOT
60194: OR
60195: IFFALSE 60245
// begin if mc_deposits_finder [ i ] then
60197: LD_EXP 140
60201: PUSH
60202: LD_VAR 0 2
60206: ARRAY
60207: IFFALSE 60243
// begin MC_Reset ( i , 125 ) ;
60209: LD_VAR 0 2
60213: PPUSH
60214: LD_INT 125
60216: PPUSH
60217: CALL 43131 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60221: LD_ADDR_EXP 140
60225: PUSH
60226: LD_EXP 140
60230: PPUSH
60231: LD_VAR 0 2
60235: PPUSH
60236: EMPTY
60237: PPUSH
60238: CALL_OW 1
60242: ST_TO_ADDR
// end ; continue ;
60243: GO 60097
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
60245: LD_EXP 139
60249: PUSH
60250: LD_VAR 0 2
60254: ARRAY
60255: PUSH
60256: LD_INT 1
60258: ARRAY
60259: PUSH
60260: LD_INT 3
60262: ARRAY
60263: PUSH
60264: LD_INT 1
60266: EQUAL
60267: PUSH
60268: LD_INT 20
60270: PPUSH
60271: LD_EXP 128
60275: PUSH
60276: LD_VAR 0 2
60280: ARRAY
60281: PPUSH
60282: CALL_OW 321
60286: PUSH
60287: LD_INT 2
60289: NONEQUAL
60290: AND
60291: IFFALSE 60341
// begin if mc_deposits_finder [ i ] then
60293: LD_EXP 140
60297: PUSH
60298: LD_VAR 0 2
60302: ARRAY
60303: IFFALSE 60339
// begin MC_Reset ( i , 125 ) ;
60305: LD_VAR 0 2
60309: PPUSH
60310: LD_INT 125
60312: PPUSH
60313: CALL 43131 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60317: LD_ADDR_EXP 140
60321: PUSH
60322: LD_EXP 140
60326: PPUSH
60327: LD_VAR 0 2
60331: PPUSH
60332: EMPTY
60333: PPUSH
60334: CALL_OW 1
60338: ST_TO_ADDR
// end ; continue ;
60339: GO 60097
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
60341: LD_EXP 139
60345: PUSH
60346: LD_VAR 0 2
60350: ARRAY
60351: PUSH
60352: LD_INT 1
60354: ARRAY
60355: PUSH
60356: LD_INT 1
60358: ARRAY
60359: PPUSH
60360: LD_EXP 139
60364: PUSH
60365: LD_VAR 0 2
60369: ARRAY
60370: PUSH
60371: LD_INT 1
60373: ARRAY
60374: PUSH
60375: LD_INT 2
60377: ARRAY
60378: PPUSH
60379: LD_EXP 128
60383: PUSH
60384: LD_VAR 0 2
60388: ARRAY
60389: PPUSH
60390: CALL_OW 440
60394: IFFALSE 60437
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
60396: LD_ADDR_EXP 139
60400: PUSH
60401: LD_EXP 139
60405: PPUSH
60406: LD_VAR 0 2
60410: PPUSH
60411: LD_EXP 139
60415: PUSH
60416: LD_VAR 0 2
60420: ARRAY
60421: PPUSH
60422: LD_INT 1
60424: PPUSH
60425: CALL_OW 3
60429: PPUSH
60430: CALL_OW 1
60434: ST_TO_ADDR
60435: GO 60684
// begin if not mc_deposits_finder [ i ] then
60437: LD_EXP 140
60441: PUSH
60442: LD_VAR 0 2
60446: ARRAY
60447: NOT
60448: IFFALSE 60500
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
60450: LD_ADDR_EXP 140
60454: PUSH
60455: LD_EXP 140
60459: PPUSH
60460: LD_VAR 0 2
60464: PPUSH
60465: LD_VAR 0 3
60469: PUSH
60470: LD_INT 1
60472: ARRAY
60473: PUSH
60474: EMPTY
60475: LIST
60476: PPUSH
60477: CALL_OW 1
60481: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
60482: LD_VAR 0 3
60486: PUSH
60487: LD_INT 1
60489: ARRAY
60490: PPUSH
60491: LD_INT 125
60493: PPUSH
60494: CALL_OW 109
// end else
60498: GO 60684
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
60500: LD_EXP 140
60504: PUSH
60505: LD_VAR 0 2
60509: ARRAY
60510: PUSH
60511: LD_INT 1
60513: ARRAY
60514: PPUSH
60515: CALL_OW 310
60519: IFFALSE 60542
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
60521: LD_EXP 140
60525: PUSH
60526: LD_VAR 0 2
60530: ARRAY
60531: PUSH
60532: LD_INT 1
60534: ARRAY
60535: PPUSH
60536: CALL_OW 122
60540: GO 60684
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
60542: LD_EXP 140
60546: PUSH
60547: LD_VAR 0 2
60551: ARRAY
60552: PUSH
60553: LD_INT 1
60555: ARRAY
60556: PPUSH
60557: CALL_OW 314
60561: NOT
60562: PUSH
60563: LD_EXP 140
60567: PUSH
60568: LD_VAR 0 2
60572: ARRAY
60573: PUSH
60574: LD_INT 1
60576: ARRAY
60577: PPUSH
60578: LD_EXP 139
60582: PUSH
60583: LD_VAR 0 2
60587: ARRAY
60588: PUSH
60589: LD_INT 1
60591: ARRAY
60592: PUSH
60593: LD_INT 1
60595: ARRAY
60596: PPUSH
60597: LD_EXP 139
60601: PUSH
60602: LD_VAR 0 2
60606: ARRAY
60607: PUSH
60608: LD_INT 1
60610: ARRAY
60611: PUSH
60612: LD_INT 2
60614: ARRAY
60615: PPUSH
60616: CALL_OW 297
60620: PUSH
60621: LD_INT 6
60623: GREATER
60624: AND
60625: IFFALSE 60684
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
60627: LD_EXP 140
60631: PUSH
60632: LD_VAR 0 2
60636: ARRAY
60637: PUSH
60638: LD_INT 1
60640: ARRAY
60641: PPUSH
60642: LD_EXP 139
60646: PUSH
60647: LD_VAR 0 2
60651: ARRAY
60652: PUSH
60653: LD_INT 1
60655: ARRAY
60656: PUSH
60657: LD_INT 1
60659: ARRAY
60660: PPUSH
60661: LD_EXP 139
60665: PUSH
60666: LD_VAR 0 2
60670: ARRAY
60671: PUSH
60672: LD_INT 1
60674: ARRAY
60675: PUSH
60676: LD_INT 2
60678: ARRAY
60679: PPUSH
60680: CALL_OW 111
// end ; end ; end ;
60684: GO 60097
60686: POP
60687: POP
// end ;
60688: LD_VAR 0 1
60692: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
60693: LD_INT 0
60695: PPUSH
60696: PPUSH
60697: PPUSH
60698: PPUSH
60699: PPUSH
60700: PPUSH
60701: PPUSH
60702: PPUSH
60703: PPUSH
60704: PPUSH
60705: PPUSH
// if not mc_bases then
60706: LD_EXP 102
60710: NOT
60711: IFFALSE 60715
// exit ;
60713: GO 61655
// for i = 1 to mc_bases do
60715: LD_ADDR_VAR 0 2
60719: PUSH
60720: DOUBLE
60721: LD_INT 1
60723: DEC
60724: ST_TO_ADDR
60725: LD_EXP 102
60729: PUSH
60730: FOR_TO
60731: IFFALSE 61653
// begin if not mc_bases [ i ] or mc_scan [ i ] then
60733: LD_EXP 102
60737: PUSH
60738: LD_VAR 0 2
60742: ARRAY
60743: NOT
60744: PUSH
60745: LD_EXP 125
60749: PUSH
60750: LD_VAR 0 2
60754: ARRAY
60755: OR
60756: IFFALSE 60760
// continue ;
60758: GO 60730
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
60760: LD_ADDR_VAR 0 7
60764: PUSH
60765: LD_EXP 102
60769: PUSH
60770: LD_VAR 0 2
60774: ARRAY
60775: PUSH
60776: LD_INT 1
60778: ARRAY
60779: PPUSH
60780: CALL_OW 248
60784: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
60785: LD_VAR 0 7
60789: PUSH
60790: LD_INT 3
60792: EQUAL
60793: PUSH
60794: LD_EXP 121
60798: PUSH
60799: LD_VAR 0 2
60803: ARRAY
60804: PUSH
60805: LD_EXP 124
60809: PUSH
60810: LD_VAR 0 2
60814: ARRAY
60815: UNION
60816: PPUSH
60817: LD_INT 33
60819: PUSH
60820: LD_INT 2
60822: PUSH
60823: EMPTY
60824: LIST
60825: LIST
60826: PPUSH
60827: CALL_OW 72
60831: NOT
60832: OR
60833: IFFALSE 60837
// continue ;
60835: GO 60730
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
60837: LD_ADDR_VAR 0 9
60841: PUSH
60842: LD_EXP 102
60846: PUSH
60847: LD_VAR 0 2
60851: ARRAY
60852: PPUSH
60853: LD_INT 30
60855: PUSH
60856: LD_INT 36
60858: PUSH
60859: EMPTY
60860: LIST
60861: LIST
60862: PPUSH
60863: CALL_OW 72
60867: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
60868: LD_ADDR_VAR 0 10
60872: PUSH
60873: LD_EXP 121
60877: PUSH
60878: LD_VAR 0 2
60882: ARRAY
60883: PPUSH
60884: LD_INT 34
60886: PUSH
60887: LD_INT 31
60889: PUSH
60890: EMPTY
60891: LIST
60892: LIST
60893: PPUSH
60894: CALL_OW 72
60898: ST_TO_ADDR
// if not cts and not mcts then
60899: LD_VAR 0 9
60903: NOT
60904: PUSH
60905: LD_VAR 0 10
60909: NOT
60910: AND
60911: IFFALSE 60915
// continue ;
60913: GO 60730
// x := cts ;
60915: LD_ADDR_VAR 0 11
60919: PUSH
60920: LD_VAR 0 9
60924: ST_TO_ADDR
// if not x then
60925: LD_VAR 0 11
60929: NOT
60930: IFFALSE 60942
// x := mcts ;
60932: LD_ADDR_VAR 0 11
60936: PUSH
60937: LD_VAR 0 10
60941: ST_TO_ADDR
// if not x then
60942: LD_VAR 0 11
60946: NOT
60947: IFFALSE 60951
// continue ;
60949: GO 60730
// if mc_remote_driver [ i ] then
60951: LD_EXP 142
60955: PUSH
60956: LD_VAR 0 2
60960: ARRAY
60961: IFFALSE 61348
// for j in mc_remote_driver [ i ] do
60963: LD_ADDR_VAR 0 3
60967: PUSH
60968: LD_EXP 142
60972: PUSH
60973: LD_VAR 0 2
60977: ARRAY
60978: PUSH
60979: FOR_IN
60980: IFFALSE 61346
// begin if GetClass ( j ) <> 3 then
60982: LD_VAR 0 3
60986: PPUSH
60987: CALL_OW 257
60991: PUSH
60992: LD_INT 3
60994: NONEQUAL
60995: IFFALSE 61048
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
60997: LD_ADDR_EXP 142
61001: PUSH
61002: LD_EXP 142
61006: PPUSH
61007: LD_VAR 0 2
61011: PPUSH
61012: LD_EXP 142
61016: PUSH
61017: LD_VAR 0 2
61021: ARRAY
61022: PUSH
61023: LD_VAR 0 3
61027: DIFF
61028: PPUSH
61029: CALL_OW 1
61033: ST_TO_ADDR
// SetTag ( j , 0 ) ;
61034: LD_VAR 0 3
61038: PPUSH
61039: LD_INT 0
61041: PPUSH
61042: CALL_OW 109
// continue ;
61046: GO 60979
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
61048: LD_EXP 121
61052: PUSH
61053: LD_VAR 0 2
61057: ARRAY
61058: PPUSH
61059: LD_INT 34
61061: PUSH
61062: LD_INT 31
61064: PUSH
61065: EMPTY
61066: LIST
61067: LIST
61068: PUSH
61069: LD_INT 58
61071: PUSH
61072: EMPTY
61073: LIST
61074: PUSH
61075: EMPTY
61076: LIST
61077: LIST
61078: PPUSH
61079: CALL_OW 72
61083: PUSH
61084: LD_VAR 0 3
61088: PPUSH
61089: CALL 104965 0 1
61093: NOT
61094: AND
61095: IFFALSE 61166
// begin if IsInUnit ( j ) then
61097: LD_VAR 0 3
61101: PPUSH
61102: CALL_OW 310
61106: IFFALSE 61117
// ComExitBuilding ( j ) ;
61108: LD_VAR 0 3
61112: PPUSH
61113: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
61117: LD_VAR 0 3
61121: PPUSH
61122: LD_EXP 121
61126: PUSH
61127: LD_VAR 0 2
61131: ARRAY
61132: PPUSH
61133: LD_INT 34
61135: PUSH
61136: LD_INT 31
61138: PUSH
61139: EMPTY
61140: LIST
61141: LIST
61142: PUSH
61143: LD_INT 58
61145: PUSH
61146: EMPTY
61147: LIST
61148: PUSH
61149: EMPTY
61150: LIST
61151: LIST
61152: PPUSH
61153: CALL_OW 72
61157: PUSH
61158: LD_INT 1
61160: ARRAY
61161: PPUSH
61162: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
61166: LD_VAR 0 3
61170: PPUSH
61171: CALL_OW 310
61175: NOT
61176: PUSH
61177: LD_VAR 0 3
61181: PPUSH
61182: CALL_OW 310
61186: PPUSH
61187: CALL_OW 266
61191: PUSH
61192: LD_INT 36
61194: NONEQUAL
61195: PUSH
61196: LD_VAR 0 3
61200: PPUSH
61201: CALL 104965 0 1
61205: NOT
61206: AND
61207: OR
61208: IFFALSE 61344
// begin if IsInUnit ( j ) then
61210: LD_VAR 0 3
61214: PPUSH
61215: CALL_OW 310
61219: IFFALSE 61230
// ComExitBuilding ( j ) ;
61221: LD_VAR 0 3
61225: PPUSH
61226: CALL_OW 122
// ct := 0 ;
61230: LD_ADDR_VAR 0 8
61234: PUSH
61235: LD_INT 0
61237: ST_TO_ADDR
// for k in x do
61238: LD_ADDR_VAR 0 4
61242: PUSH
61243: LD_VAR 0 11
61247: PUSH
61248: FOR_IN
61249: IFFALSE 61322
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
61251: LD_VAR 0 4
61255: PPUSH
61256: CALL_OW 264
61260: PUSH
61261: LD_INT 31
61263: EQUAL
61264: PUSH
61265: LD_VAR 0 4
61269: PPUSH
61270: CALL_OW 311
61274: NOT
61275: AND
61276: PUSH
61277: LD_VAR 0 4
61281: PPUSH
61282: CALL_OW 266
61286: PUSH
61287: LD_INT 36
61289: EQUAL
61290: PUSH
61291: LD_VAR 0 4
61295: PPUSH
61296: CALL_OW 313
61300: PUSH
61301: LD_INT 3
61303: LESS
61304: AND
61305: OR
61306: IFFALSE 61320
// begin ct := k ;
61308: LD_ADDR_VAR 0 8
61312: PUSH
61313: LD_VAR 0 4
61317: ST_TO_ADDR
// break ;
61318: GO 61322
// end ;
61320: GO 61248
61322: POP
61323: POP
// if ct then
61324: LD_VAR 0 8
61328: IFFALSE 61344
// ComEnterUnit ( j , ct ) ;
61330: LD_VAR 0 3
61334: PPUSH
61335: LD_VAR 0 8
61339: PPUSH
61340: CALL_OW 120
// end ; end ;
61344: GO 60979
61346: POP
61347: POP
// places := 0 ;
61348: LD_ADDR_VAR 0 5
61352: PUSH
61353: LD_INT 0
61355: ST_TO_ADDR
// for j = 1 to x do
61356: LD_ADDR_VAR 0 3
61360: PUSH
61361: DOUBLE
61362: LD_INT 1
61364: DEC
61365: ST_TO_ADDR
61366: LD_VAR 0 11
61370: PUSH
61371: FOR_TO
61372: IFFALSE 61448
// if GetWeapon ( x [ j ] ) = ar_control_tower then
61374: LD_VAR 0 11
61378: PUSH
61379: LD_VAR 0 3
61383: ARRAY
61384: PPUSH
61385: CALL_OW 264
61389: PUSH
61390: LD_INT 31
61392: EQUAL
61393: IFFALSE 61411
// places := places + 1 else
61395: LD_ADDR_VAR 0 5
61399: PUSH
61400: LD_VAR 0 5
61404: PUSH
61405: LD_INT 1
61407: PLUS
61408: ST_TO_ADDR
61409: GO 61446
// if GetBType ( x [ j ] ) = b_control_tower then
61411: LD_VAR 0 11
61415: PUSH
61416: LD_VAR 0 3
61420: ARRAY
61421: PPUSH
61422: CALL_OW 266
61426: PUSH
61427: LD_INT 36
61429: EQUAL
61430: IFFALSE 61446
// places := places + 3 ;
61432: LD_ADDR_VAR 0 5
61436: PUSH
61437: LD_VAR 0 5
61441: PUSH
61442: LD_INT 3
61444: PLUS
61445: ST_TO_ADDR
61446: GO 61371
61448: POP
61449: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
61450: LD_VAR 0 5
61454: PUSH
61455: LD_INT 0
61457: EQUAL
61458: PUSH
61459: LD_VAR 0 5
61463: PUSH
61464: LD_EXP 142
61468: PUSH
61469: LD_VAR 0 2
61473: ARRAY
61474: LESSEQUAL
61475: OR
61476: IFFALSE 61480
// continue ;
61478: GO 60730
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
61480: LD_ADDR_VAR 0 6
61484: PUSH
61485: LD_EXP 102
61489: PUSH
61490: LD_VAR 0 2
61494: ARRAY
61495: PPUSH
61496: LD_INT 25
61498: PUSH
61499: LD_INT 3
61501: PUSH
61502: EMPTY
61503: LIST
61504: LIST
61505: PPUSH
61506: CALL_OW 72
61510: PUSH
61511: LD_EXP 142
61515: PUSH
61516: LD_VAR 0 2
61520: ARRAY
61521: DIFF
61522: PPUSH
61523: LD_INT 3
61525: PPUSH
61526: CALL 105865 0 2
61530: ST_TO_ADDR
// for j in tmp do
61531: LD_ADDR_VAR 0 3
61535: PUSH
61536: LD_VAR 0 6
61540: PUSH
61541: FOR_IN
61542: IFFALSE 61577
// if GetTag ( j ) > 0 then
61544: LD_VAR 0 3
61548: PPUSH
61549: CALL_OW 110
61553: PUSH
61554: LD_INT 0
61556: GREATER
61557: IFFALSE 61575
// tmp := tmp diff j ;
61559: LD_ADDR_VAR 0 6
61563: PUSH
61564: LD_VAR 0 6
61568: PUSH
61569: LD_VAR 0 3
61573: DIFF
61574: ST_TO_ADDR
61575: GO 61541
61577: POP
61578: POP
// if not tmp then
61579: LD_VAR 0 6
61583: NOT
61584: IFFALSE 61588
// continue ;
61586: GO 60730
// if places then
61588: LD_VAR 0 5
61592: IFFALSE 61651
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
61594: LD_ADDR_EXP 142
61598: PUSH
61599: LD_EXP 142
61603: PPUSH
61604: LD_VAR 0 2
61608: PPUSH
61609: LD_EXP 142
61613: PUSH
61614: LD_VAR 0 2
61618: ARRAY
61619: PUSH
61620: LD_VAR 0 6
61624: PUSH
61625: LD_INT 1
61627: ARRAY
61628: UNION
61629: PPUSH
61630: CALL_OW 1
61634: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
61635: LD_VAR 0 6
61639: PUSH
61640: LD_INT 1
61642: ARRAY
61643: PPUSH
61644: LD_INT 126
61646: PPUSH
61647: CALL_OW 109
// end ; end ;
61651: GO 60730
61653: POP
61654: POP
// end ;
61655: LD_VAR 0 1
61659: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
61660: LD_INT 0
61662: PPUSH
61663: PPUSH
61664: PPUSH
61665: PPUSH
61666: PPUSH
61667: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
61668: LD_VAR 0 1
61672: NOT
61673: PUSH
61674: LD_VAR 0 2
61678: NOT
61679: OR
61680: PUSH
61681: LD_VAR 0 3
61685: NOT
61686: OR
61687: PUSH
61688: LD_VAR 0 4
61692: PUSH
61693: LD_INT 1
61695: PUSH
61696: LD_INT 2
61698: PUSH
61699: LD_INT 3
61701: PUSH
61702: LD_INT 4
61704: PUSH
61705: LD_INT 5
61707: PUSH
61708: LD_INT 8
61710: PUSH
61711: LD_INT 9
61713: PUSH
61714: LD_INT 15
61716: PUSH
61717: LD_INT 16
61719: PUSH
61720: EMPTY
61721: LIST
61722: LIST
61723: LIST
61724: LIST
61725: LIST
61726: LIST
61727: LIST
61728: LIST
61729: LIST
61730: IN
61731: NOT
61732: OR
61733: IFFALSE 61737
// exit ;
61735: GO 62595
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
61737: LD_ADDR_VAR 0 2
61741: PUSH
61742: LD_VAR 0 2
61746: PPUSH
61747: LD_INT 21
61749: PUSH
61750: LD_INT 3
61752: PUSH
61753: EMPTY
61754: LIST
61755: LIST
61756: PUSH
61757: LD_INT 24
61759: PUSH
61760: LD_INT 250
61762: PUSH
61763: EMPTY
61764: LIST
61765: LIST
61766: PUSH
61767: EMPTY
61768: LIST
61769: LIST
61770: PPUSH
61771: CALL_OW 72
61775: ST_TO_ADDR
// case class of 1 , 15 :
61776: LD_VAR 0 4
61780: PUSH
61781: LD_INT 1
61783: DOUBLE
61784: EQUAL
61785: IFTRUE 61795
61787: LD_INT 15
61789: DOUBLE
61790: EQUAL
61791: IFTRUE 61795
61793: GO 61880
61795: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
61796: LD_ADDR_VAR 0 8
61800: PUSH
61801: LD_VAR 0 2
61805: PPUSH
61806: LD_INT 2
61808: PUSH
61809: LD_INT 30
61811: PUSH
61812: LD_INT 32
61814: PUSH
61815: EMPTY
61816: LIST
61817: LIST
61818: PUSH
61819: LD_INT 30
61821: PUSH
61822: LD_INT 31
61824: PUSH
61825: EMPTY
61826: LIST
61827: LIST
61828: PUSH
61829: EMPTY
61830: LIST
61831: LIST
61832: LIST
61833: PPUSH
61834: CALL_OW 72
61838: PUSH
61839: LD_VAR 0 2
61843: PPUSH
61844: LD_INT 2
61846: PUSH
61847: LD_INT 30
61849: PUSH
61850: LD_INT 4
61852: PUSH
61853: EMPTY
61854: LIST
61855: LIST
61856: PUSH
61857: LD_INT 30
61859: PUSH
61860: LD_INT 5
61862: PUSH
61863: EMPTY
61864: LIST
61865: LIST
61866: PUSH
61867: EMPTY
61868: LIST
61869: LIST
61870: LIST
61871: PPUSH
61872: CALL_OW 72
61876: ADD
61877: ST_TO_ADDR
61878: GO 62126
61880: LD_INT 2
61882: DOUBLE
61883: EQUAL
61884: IFTRUE 61894
61886: LD_INT 16
61888: DOUBLE
61889: EQUAL
61890: IFTRUE 61894
61892: GO 61940
61894: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
61895: LD_ADDR_VAR 0 8
61899: PUSH
61900: LD_VAR 0 2
61904: PPUSH
61905: LD_INT 2
61907: PUSH
61908: LD_INT 30
61910: PUSH
61911: LD_INT 0
61913: PUSH
61914: EMPTY
61915: LIST
61916: LIST
61917: PUSH
61918: LD_INT 30
61920: PUSH
61921: LD_INT 1
61923: PUSH
61924: EMPTY
61925: LIST
61926: LIST
61927: PUSH
61928: EMPTY
61929: LIST
61930: LIST
61931: LIST
61932: PPUSH
61933: CALL_OW 72
61937: ST_TO_ADDR
61938: GO 62126
61940: LD_INT 3
61942: DOUBLE
61943: EQUAL
61944: IFTRUE 61948
61946: GO 61994
61948: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
61949: LD_ADDR_VAR 0 8
61953: PUSH
61954: LD_VAR 0 2
61958: PPUSH
61959: LD_INT 2
61961: PUSH
61962: LD_INT 30
61964: PUSH
61965: LD_INT 2
61967: PUSH
61968: EMPTY
61969: LIST
61970: LIST
61971: PUSH
61972: LD_INT 30
61974: PUSH
61975: LD_INT 3
61977: PUSH
61978: EMPTY
61979: LIST
61980: LIST
61981: PUSH
61982: EMPTY
61983: LIST
61984: LIST
61985: LIST
61986: PPUSH
61987: CALL_OW 72
61991: ST_TO_ADDR
61992: GO 62126
61994: LD_INT 4
61996: DOUBLE
61997: EQUAL
61998: IFTRUE 62002
62000: GO 62059
62002: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
62003: LD_ADDR_VAR 0 8
62007: PUSH
62008: LD_VAR 0 2
62012: PPUSH
62013: LD_INT 2
62015: PUSH
62016: LD_INT 30
62018: PUSH
62019: LD_INT 6
62021: PUSH
62022: EMPTY
62023: LIST
62024: LIST
62025: PUSH
62026: LD_INT 30
62028: PUSH
62029: LD_INT 7
62031: PUSH
62032: EMPTY
62033: LIST
62034: LIST
62035: PUSH
62036: LD_INT 30
62038: PUSH
62039: LD_INT 8
62041: PUSH
62042: EMPTY
62043: LIST
62044: LIST
62045: PUSH
62046: EMPTY
62047: LIST
62048: LIST
62049: LIST
62050: LIST
62051: PPUSH
62052: CALL_OW 72
62056: ST_TO_ADDR
62057: GO 62126
62059: LD_INT 5
62061: DOUBLE
62062: EQUAL
62063: IFTRUE 62079
62065: LD_INT 8
62067: DOUBLE
62068: EQUAL
62069: IFTRUE 62079
62071: LD_INT 9
62073: DOUBLE
62074: EQUAL
62075: IFTRUE 62079
62077: GO 62125
62079: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
62080: LD_ADDR_VAR 0 8
62084: PUSH
62085: LD_VAR 0 2
62089: PPUSH
62090: LD_INT 2
62092: PUSH
62093: LD_INT 30
62095: PUSH
62096: LD_INT 4
62098: PUSH
62099: EMPTY
62100: LIST
62101: LIST
62102: PUSH
62103: LD_INT 30
62105: PUSH
62106: LD_INT 5
62108: PUSH
62109: EMPTY
62110: LIST
62111: LIST
62112: PUSH
62113: EMPTY
62114: LIST
62115: LIST
62116: LIST
62117: PPUSH
62118: CALL_OW 72
62122: ST_TO_ADDR
62123: GO 62126
62125: POP
// if not tmp then
62126: LD_VAR 0 8
62130: NOT
62131: IFFALSE 62135
// exit ;
62133: GO 62595
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
62135: LD_VAR 0 4
62139: PUSH
62140: LD_INT 1
62142: PUSH
62143: LD_INT 15
62145: PUSH
62146: EMPTY
62147: LIST
62148: LIST
62149: IN
62150: PUSH
62151: LD_EXP 111
62155: PUSH
62156: LD_VAR 0 1
62160: ARRAY
62161: AND
62162: IFFALSE 62318
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
62164: LD_ADDR_VAR 0 9
62168: PUSH
62169: LD_EXP 111
62173: PUSH
62174: LD_VAR 0 1
62178: ARRAY
62179: PUSH
62180: LD_INT 1
62182: ARRAY
62183: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
62184: LD_VAR 0 9
62188: PUSH
62189: LD_EXP 112
62193: PUSH
62194: LD_VAR 0 1
62198: ARRAY
62199: IN
62200: NOT
62201: IFFALSE 62316
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
62203: LD_ADDR_EXP 112
62207: PUSH
62208: LD_EXP 112
62212: PPUSH
62213: LD_VAR 0 1
62217: PUSH
62218: LD_EXP 112
62222: PUSH
62223: LD_VAR 0 1
62227: ARRAY
62228: PUSH
62229: LD_INT 1
62231: PLUS
62232: PUSH
62233: EMPTY
62234: LIST
62235: LIST
62236: PPUSH
62237: LD_VAR 0 9
62241: PPUSH
62242: CALL 74632 0 3
62246: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
62247: LD_ADDR_EXP 111
62251: PUSH
62252: LD_EXP 111
62256: PPUSH
62257: LD_VAR 0 1
62261: PPUSH
62262: LD_EXP 111
62266: PUSH
62267: LD_VAR 0 1
62271: ARRAY
62272: PUSH
62273: LD_VAR 0 9
62277: DIFF
62278: PPUSH
62279: CALL_OW 1
62283: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
62284: LD_VAR 0 3
62288: PPUSH
62289: LD_EXP 112
62293: PUSH
62294: LD_VAR 0 1
62298: ARRAY
62299: PUSH
62300: LD_EXP 112
62304: PUSH
62305: LD_VAR 0 1
62309: ARRAY
62310: ARRAY
62311: PPUSH
62312: CALL_OW 120
// end ; exit ;
62316: GO 62595
// end ; if tmp > 1 then
62318: LD_VAR 0 8
62322: PUSH
62323: LD_INT 1
62325: GREATER
62326: IFFALSE 62430
// for i = 2 to tmp do
62328: LD_ADDR_VAR 0 6
62332: PUSH
62333: DOUBLE
62334: LD_INT 2
62336: DEC
62337: ST_TO_ADDR
62338: LD_VAR 0 8
62342: PUSH
62343: FOR_TO
62344: IFFALSE 62428
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
62346: LD_VAR 0 8
62350: PUSH
62351: LD_VAR 0 6
62355: ARRAY
62356: PPUSH
62357: CALL_OW 461
62361: PUSH
62362: LD_INT 6
62364: EQUAL
62365: IFFALSE 62426
// begin x := tmp [ i ] ;
62367: LD_ADDR_VAR 0 9
62371: PUSH
62372: LD_VAR 0 8
62376: PUSH
62377: LD_VAR 0 6
62381: ARRAY
62382: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
62383: LD_ADDR_VAR 0 8
62387: PUSH
62388: LD_VAR 0 8
62392: PPUSH
62393: LD_VAR 0 6
62397: PPUSH
62398: CALL_OW 3
62402: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
62403: LD_ADDR_VAR 0 8
62407: PUSH
62408: LD_VAR 0 8
62412: PPUSH
62413: LD_INT 1
62415: PPUSH
62416: LD_VAR 0 9
62420: PPUSH
62421: CALL_OW 2
62425: ST_TO_ADDR
// end ;
62426: GO 62343
62428: POP
62429: POP
// for i in tmp do
62430: LD_ADDR_VAR 0 6
62434: PUSH
62435: LD_VAR 0 8
62439: PUSH
62440: FOR_IN
62441: IFFALSE 62468
// begin if IsNotFull ( i ) then
62443: LD_VAR 0 6
62447: PPUSH
62448: CALL 71854 0 1
62452: IFFALSE 62466
// begin j := i ;
62454: LD_ADDR_VAR 0 7
62458: PUSH
62459: LD_VAR 0 6
62463: ST_TO_ADDR
// break ;
62464: GO 62468
// end ; end ;
62466: GO 62440
62468: POP
62469: POP
// if j then
62470: LD_VAR 0 7
62474: IFFALSE 62492
// ComEnterUnit ( unit , j ) else
62476: LD_VAR 0 3
62480: PPUSH
62481: LD_VAR 0 7
62485: PPUSH
62486: CALL_OW 120
62490: GO 62595
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62492: LD_ADDR_VAR 0 10
62496: PUSH
62497: LD_VAR 0 2
62501: PPUSH
62502: LD_INT 2
62504: PUSH
62505: LD_INT 30
62507: PUSH
62508: LD_INT 0
62510: PUSH
62511: EMPTY
62512: LIST
62513: LIST
62514: PUSH
62515: LD_INT 30
62517: PUSH
62518: LD_INT 1
62520: PUSH
62521: EMPTY
62522: LIST
62523: LIST
62524: PUSH
62525: EMPTY
62526: LIST
62527: LIST
62528: LIST
62529: PPUSH
62530: CALL_OW 72
62534: ST_TO_ADDR
// if depot then
62535: LD_VAR 0 10
62539: IFFALSE 62595
// begin depot := NearestUnitToUnit ( depot , unit ) ;
62541: LD_ADDR_VAR 0 10
62545: PUSH
62546: LD_VAR 0 10
62550: PPUSH
62551: LD_VAR 0 3
62555: PPUSH
62556: CALL_OW 74
62560: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
62561: LD_VAR 0 3
62565: PPUSH
62566: LD_VAR 0 10
62570: PPUSH
62571: CALL_OW 296
62575: PUSH
62576: LD_INT 10
62578: GREATER
62579: IFFALSE 62595
// ComStandNearbyBuilding ( unit , depot ) ;
62581: LD_VAR 0 3
62585: PPUSH
62586: LD_VAR 0 10
62590: PPUSH
62591: CALL 71234 0 2
// end ; end ; end ;
62595: LD_VAR 0 5
62599: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
62600: LD_INT 0
62602: PPUSH
62603: PPUSH
62604: PPUSH
62605: PPUSH
// if not mc_bases then
62606: LD_EXP 102
62610: NOT
62611: IFFALSE 62615
// exit ;
62613: GO 62854
// for i = 1 to mc_bases do
62615: LD_ADDR_VAR 0 2
62619: PUSH
62620: DOUBLE
62621: LD_INT 1
62623: DEC
62624: ST_TO_ADDR
62625: LD_EXP 102
62629: PUSH
62630: FOR_TO
62631: IFFALSE 62852
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
62633: LD_ADDR_VAR 0 4
62637: PUSH
62638: LD_EXP 102
62642: PUSH
62643: LD_VAR 0 2
62647: ARRAY
62648: PPUSH
62649: LD_INT 21
62651: PUSH
62652: LD_INT 1
62654: PUSH
62655: EMPTY
62656: LIST
62657: LIST
62658: PPUSH
62659: CALL_OW 72
62663: PUSH
62664: LD_EXP 131
62668: PUSH
62669: LD_VAR 0 2
62673: ARRAY
62674: UNION
62675: ST_TO_ADDR
// if not tmp then
62676: LD_VAR 0 4
62680: NOT
62681: IFFALSE 62685
// continue ;
62683: GO 62630
// for j in tmp do
62685: LD_ADDR_VAR 0 3
62689: PUSH
62690: LD_VAR 0 4
62694: PUSH
62695: FOR_IN
62696: IFFALSE 62848
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
62698: LD_VAR 0 3
62702: PPUSH
62703: CALL_OW 110
62707: NOT
62708: PUSH
62709: LD_VAR 0 3
62713: PPUSH
62714: CALL_OW 314
62718: NOT
62719: AND
62720: PUSH
62721: LD_VAR 0 3
62725: PPUSH
62726: CALL_OW 311
62730: NOT
62731: AND
62732: PUSH
62733: LD_VAR 0 3
62737: PPUSH
62738: CALL_OW 310
62742: NOT
62743: AND
62744: PUSH
62745: LD_VAR 0 3
62749: PUSH
62750: LD_EXP 105
62754: PUSH
62755: LD_VAR 0 2
62759: ARRAY
62760: PUSH
62761: LD_INT 1
62763: ARRAY
62764: IN
62765: NOT
62766: AND
62767: PUSH
62768: LD_VAR 0 3
62772: PUSH
62773: LD_EXP 105
62777: PUSH
62778: LD_VAR 0 2
62782: ARRAY
62783: PUSH
62784: LD_INT 2
62786: ARRAY
62787: IN
62788: NOT
62789: AND
62790: PUSH
62791: LD_VAR 0 3
62795: PUSH
62796: LD_EXP 114
62800: PUSH
62801: LD_VAR 0 2
62805: ARRAY
62806: IN
62807: NOT
62808: AND
62809: IFFALSE 62846
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
62811: LD_VAR 0 2
62815: PPUSH
62816: LD_EXP 102
62820: PUSH
62821: LD_VAR 0 2
62825: ARRAY
62826: PPUSH
62827: LD_VAR 0 3
62831: PPUSH
62832: LD_VAR 0 3
62836: PPUSH
62837: CALL_OW 257
62841: PPUSH
62842: CALL 61660 0 4
// end ;
62846: GO 62695
62848: POP
62849: POP
// end ;
62850: GO 62630
62852: POP
62853: POP
// end ;
62854: LD_VAR 0 1
62858: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
62859: LD_INT 0
62861: PPUSH
62862: PPUSH
62863: PPUSH
62864: PPUSH
62865: PPUSH
62866: PPUSH
// if not mc_bases [ base ] then
62867: LD_EXP 102
62871: PUSH
62872: LD_VAR 0 1
62876: ARRAY
62877: NOT
62878: IFFALSE 62882
// exit ;
62880: GO 63083
// tmp := [ ] ;
62882: LD_ADDR_VAR 0 6
62886: PUSH
62887: EMPTY
62888: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
62889: LD_ADDR_VAR 0 7
62893: PUSH
62894: LD_VAR 0 3
62898: PPUSH
62899: LD_INT 0
62901: PPUSH
62902: CALL_OW 517
62906: ST_TO_ADDR
// if not list then
62907: LD_VAR 0 7
62911: NOT
62912: IFFALSE 62916
// exit ;
62914: GO 63083
// c := Count ( list [ 1 ] ) ;
62916: LD_ADDR_VAR 0 9
62920: PUSH
62921: LD_VAR 0 7
62925: PUSH
62926: LD_INT 1
62928: ARRAY
62929: PPUSH
62930: CALL 71772 0 1
62934: ST_TO_ADDR
// if amount > c then
62935: LD_VAR 0 2
62939: PUSH
62940: LD_VAR 0 9
62944: GREATER
62945: IFFALSE 62957
// amount := c ;
62947: LD_ADDR_VAR 0 2
62951: PUSH
62952: LD_VAR 0 9
62956: ST_TO_ADDR
// for i := 1 to amount do
62957: LD_ADDR_VAR 0 5
62961: PUSH
62962: DOUBLE
62963: LD_INT 1
62965: DEC
62966: ST_TO_ADDR
62967: LD_VAR 0 2
62971: PUSH
62972: FOR_TO
62973: IFFALSE 63031
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
62975: LD_ADDR_VAR 0 6
62979: PUSH
62980: LD_VAR 0 6
62984: PPUSH
62985: LD_VAR 0 5
62989: PPUSH
62990: LD_VAR 0 7
62994: PUSH
62995: LD_INT 1
62997: ARRAY
62998: PUSH
62999: LD_VAR 0 5
63003: ARRAY
63004: PUSH
63005: LD_VAR 0 7
63009: PUSH
63010: LD_INT 2
63012: ARRAY
63013: PUSH
63014: LD_VAR 0 5
63018: ARRAY
63019: PUSH
63020: EMPTY
63021: LIST
63022: LIST
63023: PPUSH
63024: CALL_OW 1
63028: ST_TO_ADDR
63029: GO 62972
63031: POP
63032: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
63033: LD_ADDR_EXP 115
63037: PUSH
63038: LD_EXP 115
63042: PPUSH
63043: LD_VAR 0 1
63047: PPUSH
63048: LD_VAR 0 6
63052: PPUSH
63053: CALL_OW 1
63057: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
63058: LD_ADDR_EXP 117
63062: PUSH
63063: LD_EXP 117
63067: PPUSH
63068: LD_VAR 0 1
63072: PPUSH
63073: LD_VAR 0 3
63077: PPUSH
63078: CALL_OW 1
63082: ST_TO_ADDR
// end ;
63083: LD_VAR 0 4
63087: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
63088: LD_INT 0
63090: PPUSH
// if not mc_bases [ base ] then
63091: LD_EXP 102
63095: PUSH
63096: LD_VAR 0 1
63100: ARRAY
63101: NOT
63102: IFFALSE 63106
// exit ;
63104: GO 63131
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
63106: LD_ADDR_EXP 107
63110: PUSH
63111: LD_EXP 107
63115: PPUSH
63116: LD_VAR 0 1
63120: PPUSH
63121: LD_VAR 0 2
63125: PPUSH
63126: CALL_OW 1
63130: ST_TO_ADDR
// end ;
63131: LD_VAR 0 3
63135: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
63136: LD_INT 0
63138: PPUSH
// if not mc_bases [ base ] then
63139: LD_EXP 102
63143: PUSH
63144: LD_VAR 0 1
63148: ARRAY
63149: NOT
63150: IFFALSE 63154
// exit ;
63152: GO 63191
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
63154: LD_ADDR_EXP 107
63158: PUSH
63159: LD_EXP 107
63163: PPUSH
63164: LD_VAR 0 1
63168: PPUSH
63169: LD_EXP 107
63173: PUSH
63174: LD_VAR 0 1
63178: ARRAY
63179: PUSH
63180: LD_VAR 0 2
63184: UNION
63185: PPUSH
63186: CALL_OW 1
63190: ST_TO_ADDR
// end ;
63191: LD_VAR 0 3
63195: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
63196: LD_INT 0
63198: PPUSH
// if not mc_bases [ base ] then
63199: LD_EXP 102
63203: PUSH
63204: LD_VAR 0 1
63208: ARRAY
63209: NOT
63210: IFFALSE 63214
// exit ;
63212: GO 63239
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
63214: LD_ADDR_EXP 123
63218: PUSH
63219: LD_EXP 123
63223: PPUSH
63224: LD_VAR 0 1
63228: PPUSH
63229: LD_VAR 0 2
63233: PPUSH
63234: CALL_OW 1
63238: ST_TO_ADDR
// end ;
63239: LD_VAR 0 3
63243: RET
// export function MC_InsertProduceList ( base , components ) ; begin
63244: LD_INT 0
63246: PPUSH
// if not mc_bases [ base ] then
63247: LD_EXP 102
63251: PUSH
63252: LD_VAR 0 1
63256: ARRAY
63257: NOT
63258: IFFALSE 63262
// exit ;
63260: GO 63299
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
63262: LD_ADDR_EXP 123
63266: PUSH
63267: LD_EXP 123
63271: PPUSH
63272: LD_VAR 0 1
63276: PPUSH
63277: LD_EXP 123
63281: PUSH
63282: LD_VAR 0 1
63286: ARRAY
63287: PUSH
63288: LD_VAR 0 2
63292: ADD
63293: PPUSH
63294: CALL_OW 1
63298: ST_TO_ADDR
// end ;
63299: LD_VAR 0 3
63303: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
63304: LD_INT 0
63306: PPUSH
// if not mc_bases [ base ] then
63307: LD_EXP 102
63311: PUSH
63312: LD_VAR 0 1
63316: ARRAY
63317: NOT
63318: IFFALSE 63322
// exit ;
63320: GO 63376
// mc_defender := Replace ( mc_defender , base , deflist ) ;
63322: LD_ADDR_EXP 124
63326: PUSH
63327: LD_EXP 124
63331: PPUSH
63332: LD_VAR 0 1
63336: PPUSH
63337: LD_VAR 0 2
63341: PPUSH
63342: CALL_OW 1
63346: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
63347: LD_ADDR_EXP 113
63351: PUSH
63352: LD_EXP 113
63356: PPUSH
63357: LD_VAR 0 1
63361: PPUSH
63362: LD_VAR 0 2
63366: PUSH
63367: LD_INT 0
63369: PLUS
63370: PPUSH
63371: CALL_OW 1
63375: ST_TO_ADDR
// end ;
63376: LD_VAR 0 3
63380: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
63381: LD_INT 0
63383: PPUSH
// if not mc_bases [ base ] then
63384: LD_EXP 102
63388: PUSH
63389: LD_VAR 0 1
63393: ARRAY
63394: NOT
63395: IFFALSE 63399
// exit ;
63397: GO 63424
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
63399: LD_ADDR_EXP 113
63403: PUSH
63404: LD_EXP 113
63408: PPUSH
63409: LD_VAR 0 1
63413: PPUSH
63414: LD_VAR 0 2
63418: PPUSH
63419: CALL_OW 1
63423: ST_TO_ADDR
// end ;
63424: LD_VAR 0 3
63428: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
63429: LD_INT 0
63431: PPUSH
63432: PPUSH
63433: PPUSH
63434: PPUSH
// if not mc_bases [ base ] then
63435: LD_EXP 102
63439: PUSH
63440: LD_VAR 0 1
63444: ARRAY
63445: NOT
63446: IFFALSE 63450
// exit ;
63448: GO 63515
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
63450: LD_ADDR_EXP 122
63454: PUSH
63455: LD_EXP 122
63459: PPUSH
63460: LD_VAR 0 1
63464: PUSH
63465: LD_EXP 122
63469: PUSH
63470: LD_VAR 0 1
63474: ARRAY
63475: PUSH
63476: LD_INT 1
63478: PLUS
63479: PUSH
63480: EMPTY
63481: LIST
63482: LIST
63483: PPUSH
63484: LD_VAR 0 1
63488: PUSH
63489: LD_VAR 0 2
63493: PUSH
63494: LD_VAR 0 3
63498: PUSH
63499: LD_VAR 0 4
63503: PUSH
63504: EMPTY
63505: LIST
63506: LIST
63507: LIST
63508: LIST
63509: PPUSH
63510: CALL 74632 0 3
63514: ST_TO_ADDR
// end ;
63515: LD_VAR 0 5
63519: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
63520: LD_INT 0
63522: PPUSH
// if not mc_bases [ base ] then
63523: LD_EXP 102
63527: PUSH
63528: LD_VAR 0 1
63532: ARRAY
63533: NOT
63534: IFFALSE 63538
// exit ;
63536: GO 63563
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
63538: LD_ADDR_EXP 139
63542: PUSH
63543: LD_EXP 139
63547: PPUSH
63548: LD_VAR 0 1
63552: PPUSH
63553: LD_VAR 0 2
63557: PPUSH
63558: CALL_OW 1
63562: ST_TO_ADDR
// end ;
63563: LD_VAR 0 3
63567: RET
// export function MC_GetMinesField ( base ) ; begin
63568: LD_INT 0
63570: PPUSH
// result := mc_mines [ base ] ;
63571: LD_ADDR_VAR 0 2
63575: PUSH
63576: LD_EXP 115
63580: PUSH
63581: LD_VAR 0 1
63585: ARRAY
63586: ST_TO_ADDR
// end ;
63587: LD_VAR 0 2
63591: RET
// export function MC_GetProduceList ( base ) ; begin
63592: LD_INT 0
63594: PPUSH
// result := mc_produce [ base ] ;
63595: LD_ADDR_VAR 0 2
63599: PUSH
63600: LD_EXP 123
63604: PUSH
63605: LD_VAR 0 1
63609: ARRAY
63610: ST_TO_ADDR
// end ;
63611: LD_VAR 0 2
63615: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
63616: LD_INT 0
63618: PPUSH
63619: PPUSH
// if not mc_bases then
63620: LD_EXP 102
63624: NOT
63625: IFFALSE 63629
// exit ;
63627: GO 63694
// if mc_bases [ base ] then
63629: LD_EXP 102
63633: PUSH
63634: LD_VAR 0 1
63638: ARRAY
63639: IFFALSE 63694
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
63641: LD_ADDR_VAR 0 3
63645: PUSH
63646: LD_EXP 102
63650: PUSH
63651: LD_VAR 0 1
63655: ARRAY
63656: PPUSH
63657: LD_INT 30
63659: PUSH
63660: LD_VAR 0 2
63664: PUSH
63665: EMPTY
63666: LIST
63667: LIST
63668: PPUSH
63669: CALL_OW 72
63673: ST_TO_ADDR
// if result then
63674: LD_VAR 0 3
63678: IFFALSE 63694
// result := result [ 1 ] ;
63680: LD_ADDR_VAR 0 3
63684: PUSH
63685: LD_VAR 0 3
63689: PUSH
63690: LD_INT 1
63692: ARRAY
63693: ST_TO_ADDR
// end ; end ;
63694: LD_VAR 0 3
63698: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
63699: LD_INT 0
63701: PPUSH
63702: PPUSH
// if not mc_bases then
63703: LD_EXP 102
63707: NOT
63708: IFFALSE 63712
// exit ;
63710: GO 63757
// if mc_bases [ base ] then
63712: LD_EXP 102
63716: PUSH
63717: LD_VAR 0 1
63721: ARRAY
63722: IFFALSE 63757
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
63724: LD_ADDR_VAR 0 3
63728: PUSH
63729: LD_EXP 102
63733: PUSH
63734: LD_VAR 0 1
63738: ARRAY
63739: PPUSH
63740: LD_INT 30
63742: PUSH
63743: LD_VAR 0 2
63747: PUSH
63748: EMPTY
63749: LIST
63750: LIST
63751: PPUSH
63752: CALL_OW 72
63756: ST_TO_ADDR
// end ;
63757: LD_VAR 0 3
63761: RET
// export function MC_SetTame ( base , area ) ; begin
63762: LD_INT 0
63764: PPUSH
// if not mc_bases or not base then
63765: LD_EXP 102
63769: NOT
63770: PUSH
63771: LD_VAR 0 1
63775: NOT
63776: OR
63777: IFFALSE 63781
// exit ;
63779: GO 63806
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
63781: LD_ADDR_EXP 130
63785: PUSH
63786: LD_EXP 130
63790: PPUSH
63791: LD_VAR 0 1
63795: PPUSH
63796: LD_VAR 0 2
63800: PPUSH
63801: CALL_OW 1
63805: ST_TO_ADDR
// end ;
63806: LD_VAR 0 3
63810: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
63811: LD_INT 0
63813: PPUSH
63814: PPUSH
// if not mc_bases or not base then
63815: LD_EXP 102
63819: NOT
63820: PUSH
63821: LD_VAR 0 1
63825: NOT
63826: OR
63827: IFFALSE 63831
// exit ;
63829: GO 63933
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
63831: LD_ADDR_VAR 0 4
63835: PUSH
63836: LD_EXP 102
63840: PUSH
63841: LD_VAR 0 1
63845: ARRAY
63846: PPUSH
63847: LD_INT 30
63849: PUSH
63850: LD_VAR 0 2
63854: PUSH
63855: EMPTY
63856: LIST
63857: LIST
63858: PPUSH
63859: CALL_OW 72
63863: ST_TO_ADDR
// if not tmp then
63864: LD_VAR 0 4
63868: NOT
63869: IFFALSE 63873
// exit ;
63871: GO 63933
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
63873: LD_ADDR_EXP 134
63877: PUSH
63878: LD_EXP 134
63882: PPUSH
63883: LD_VAR 0 1
63887: PPUSH
63888: LD_EXP 134
63892: PUSH
63893: LD_VAR 0 1
63897: ARRAY
63898: PPUSH
63899: LD_EXP 134
63903: PUSH
63904: LD_VAR 0 1
63908: ARRAY
63909: PUSH
63910: LD_INT 1
63912: PLUS
63913: PPUSH
63914: LD_VAR 0 4
63918: PUSH
63919: LD_INT 1
63921: ARRAY
63922: PPUSH
63923: CALL_OW 2
63927: PPUSH
63928: CALL_OW 1
63932: ST_TO_ADDR
// end ;
63933: LD_VAR 0 3
63937: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
63938: LD_INT 0
63940: PPUSH
63941: PPUSH
// if not mc_bases or not base or not kinds then
63942: LD_EXP 102
63946: NOT
63947: PUSH
63948: LD_VAR 0 1
63952: NOT
63953: OR
63954: PUSH
63955: LD_VAR 0 2
63959: NOT
63960: OR
63961: IFFALSE 63965
// exit ;
63963: GO 64026
// for i in kinds do
63965: LD_ADDR_VAR 0 4
63969: PUSH
63970: LD_VAR 0 2
63974: PUSH
63975: FOR_IN
63976: IFFALSE 64024
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
63978: LD_ADDR_EXP 136
63982: PUSH
63983: LD_EXP 136
63987: PPUSH
63988: LD_VAR 0 1
63992: PUSH
63993: LD_EXP 136
63997: PUSH
63998: LD_VAR 0 1
64002: ARRAY
64003: PUSH
64004: LD_INT 1
64006: PLUS
64007: PUSH
64008: EMPTY
64009: LIST
64010: LIST
64011: PPUSH
64012: LD_VAR 0 4
64016: PPUSH
64017: CALL 74632 0 3
64021: ST_TO_ADDR
64022: GO 63975
64024: POP
64025: POP
// end ;
64026: LD_VAR 0 3
64030: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
64031: LD_INT 0
64033: PPUSH
// if not mc_bases or not base or not areas then
64034: LD_EXP 102
64038: NOT
64039: PUSH
64040: LD_VAR 0 1
64044: NOT
64045: OR
64046: PUSH
64047: LD_VAR 0 2
64051: NOT
64052: OR
64053: IFFALSE 64057
// exit ;
64055: GO 64082
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
64057: LD_ADDR_EXP 120
64061: PUSH
64062: LD_EXP 120
64066: PPUSH
64067: LD_VAR 0 1
64071: PPUSH
64072: LD_VAR 0 2
64076: PPUSH
64077: CALL_OW 1
64081: ST_TO_ADDR
// end ;
64082: LD_VAR 0 3
64086: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
64087: LD_INT 0
64089: PPUSH
// if not mc_bases or not base or not teleports_exit then
64090: LD_EXP 102
64094: NOT
64095: PUSH
64096: LD_VAR 0 1
64100: NOT
64101: OR
64102: PUSH
64103: LD_VAR 0 2
64107: NOT
64108: OR
64109: IFFALSE 64113
// exit ;
64111: GO 64138
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
64113: LD_ADDR_EXP 137
64117: PUSH
64118: LD_EXP 137
64122: PPUSH
64123: LD_VAR 0 1
64127: PPUSH
64128: LD_VAR 0 2
64132: PPUSH
64133: CALL_OW 1
64137: ST_TO_ADDR
// end ;
64138: LD_VAR 0 3
64142: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
64143: LD_INT 0
64145: PPUSH
64146: PPUSH
64147: PPUSH
// if not mc_bases or not base or not ext_list then
64148: LD_EXP 102
64152: NOT
64153: PUSH
64154: LD_VAR 0 1
64158: NOT
64159: OR
64160: PUSH
64161: LD_VAR 0 5
64165: NOT
64166: OR
64167: IFFALSE 64171
// exit ;
64169: GO 64344
// tmp := GetFacExtXYD ( x , y , d ) ;
64171: LD_ADDR_VAR 0 8
64175: PUSH
64176: LD_VAR 0 2
64180: PPUSH
64181: LD_VAR 0 3
64185: PPUSH
64186: LD_VAR 0 4
64190: PPUSH
64191: CALL 104995 0 3
64195: ST_TO_ADDR
// if not tmp then
64196: LD_VAR 0 8
64200: NOT
64201: IFFALSE 64205
// exit ;
64203: GO 64344
// for i in tmp do
64205: LD_ADDR_VAR 0 7
64209: PUSH
64210: LD_VAR 0 8
64214: PUSH
64215: FOR_IN
64216: IFFALSE 64342
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
64218: LD_ADDR_EXP 107
64222: PUSH
64223: LD_EXP 107
64227: PPUSH
64228: LD_VAR 0 1
64232: PPUSH
64233: LD_EXP 107
64237: PUSH
64238: LD_VAR 0 1
64242: ARRAY
64243: PPUSH
64244: LD_EXP 107
64248: PUSH
64249: LD_VAR 0 1
64253: ARRAY
64254: PUSH
64255: LD_INT 1
64257: PLUS
64258: PPUSH
64259: LD_VAR 0 5
64263: PUSH
64264: LD_INT 1
64266: ARRAY
64267: PUSH
64268: LD_VAR 0 7
64272: PUSH
64273: LD_INT 1
64275: ARRAY
64276: PUSH
64277: LD_VAR 0 7
64281: PUSH
64282: LD_INT 2
64284: ARRAY
64285: PUSH
64286: LD_VAR 0 7
64290: PUSH
64291: LD_INT 3
64293: ARRAY
64294: PUSH
64295: EMPTY
64296: LIST
64297: LIST
64298: LIST
64299: LIST
64300: PPUSH
64301: CALL_OW 2
64305: PPUSH
64306: CALL_OW 1
64310: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
64311: LD_ADDR_VAR 0 5
64315: PUSH
64316: LD_VAR 0 5
64320: PPUSH
64321: LD_INT 1
64323: PPUSH
64324: CALL_OW 3
64328: ST_TO_ADDR
// if not ext_list then
64329: LD_VAR 0 5
64333: NOT
64334: IFFALSE 64340
// exit ;
64336: POP
64337: POP
64338: GO 64344
// end ;
64340: GO 64215
64342: POP
64343: POP
// end ;
64344: LD_VAR 0 6
64348: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
64349: LD_INT 0
64351: PPUSH
// if not mc_bases or not base or not weapon_list then
64352: LD_EXP 102
64356: NOT
64357: PUSH
64358: LD_VAR 0 1
64362: NOT
64363: OR
64364: PUSH
64365: LD_VAR 0 2
64369: NOT
64370: OR
64371: IFFALSE 64375
// exit ;
64373: GO 64400
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
64375: LD_ADDR_EXP 141
64379: PUSH
64380: LD_EXP 141
64384: PPUSH
64385: LD_VAR 0 1
64389: PPUSH
64390: LD_VAR 0 2
64394: PPUSH
64395: CALL_OW 1
64399: ST_TO_ADDR
// end ;
64400: LD_VAR 0 3
64404: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
64405: LD_INT 0
64407: PPUSH
// if not mc_bases or not base or not tech_list then
64408: LD_EXP 102
64412: NOT
64413: PUSH
64414: LD_VAR 0 1
64418: NOT
64419: OR
64420: PUSH
64421: LD_VAR 0 2
64425: NOT
64426: OR
64427: IFFALSE 64431
// exit ;
64429: GO 64456
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
64431: LD_ADDR_EXP 129
64435: PUSH
64436: LD_EXP 129
64440: PPUSH
64441: LD_VAR 0 1
64445: PPUSH
64446: LD_VAR 0 2
64450: PPUSH
64451: CALL_OW 1
64455: ST_TO_ADDR
// end ;
64456: LD_VAR 0 3
64460: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
64461: LD_INT 0
64463: PPUSH
// if not mc_bases or not parking_area or not base then
64464: LD_EXP 102
64468: NOT
64469: PUSH
64470: LD_VAR 0 2
64474: NOT
64475: OR
64476: PUSH
64477: LD_VAR 0 1
64481: NOT
64482: OR
64483: IFFALSE 64487
// exit ;
64485: GO 64512
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
64487: LD_ADDR_EXP 126
64491: PUSH
64492: LD_EXP 126
64496: PPUSH
64497: LD_VAR 0 1
64501: PPUSH
64502: LD_VAR 0 2
64506: PPUSH
64507: CALL_OW 1
64511: ST_TO_ADDR
// end ;
64512: LD_VAR 0 3
64516: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
64517: LD_INT 0
64519: PPUSH
// if not mc_bases or not base or not scan_area then
64520: LD_EXP 102
64524: NOT
64525: PUSH
64526: LD_VAR 0 1
64530: NOT
64531: OR
64532: PUSH
64533: LD_VAR 0 2
64537: NOT
64538: OR
64539: IFFALSE 64543
// exit ;
64541: GO 64568
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
64543: LD_ADDR_EXP 127
64547: PUSH
64548: LD_EXP 127
64552: PPUSH
64553: LD_VAR 0 1
64557: PPUSH
64558: LD_VAR 0 2
64562: PPUSH
64563: CALL_OW 1
64567: ST_TO_ADDR
// end ;
64568: LD_VAR 0 3
64572: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
64573: LD_INT 0
64575: PPUSH
64576: PPUSH
// if not mc_bases or not base then
64577: LD_EXP 102
64581: NOT
64582: PUSH
64583: LD_VAR 0 1
64587: NOT
64588: OR
64589: IFFALSE 64593
// exit ;
64591: GO 64657
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
64593: LD_ADDR_VAR 0 3
64597: PUSH
64598: LD_INT 1
64600: PUSH
64601: LD_INT 2
64603: PUSH
64604: LD_INT 3
64606: PUSH
64607: LD_INT 4
64609: PUSH
64610: LD_INT 11
64612: PUSH
64613: EMPTY
64614: LIST
64615: LIST
64616: LIST
64617: LIST
64618: LIST
64619: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
64620: LD_ADDR_EXP 129
64624: PUSH
64625: LD_EXP 129
64629: PPUSH
64630: LD_VAR 0 1
64634: PPUSH
64635: LD_EXP 129
64639: PUSH
64640: LD_VAR 0 1
64644: ARRAY
64645: PUSH
64646: LD_VAR 0 3
64650: DIFF
64651: PPUSH
64652: CALL_OW 1
64656: ST_TO_ADDR
// end ;
64657: LD_VAR 0 2
64661: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
64662: LD_INT 0
64664: PPUSH
// result := mc_vehicles [ base ] ;
64665: LD_ADDR_VAR 0 3
64669: PUSH
64670: LD_EXP 121
64674: PUSH
64675: LD_VAR 0 1
64679: ARRAY
64680: ST_TO_ADDR
// if onlyCombat then
64681: LD_VAR 0 2
64685: IFFALSE 64857
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
64687: LD_ADDR_VAR 0 3
64691: PUSH
64692: LD_VAR 0 3
64696: PUSH
64697: LD_VAR 0 3
64701: PPUSH
64702: LD_INT 2
64704: PUSH
64705: LD_INT 34
64707: PUSH
64708: LD_INT 12
64710: PUSH
64711: EMPTY
64712: LIST
64713: LIST
64714: PUSH
64715: LD_INT 34
64717: PUSH
64718: LD_INT 51
64720: PUSH
64721: EMPTY
64722: LIST
64723: LIST
64724: PUSH
64725: LD_INT 34
64727: PUSH
64728: LD_INT 89
64730: PUSH
64731: EMPTY
64732: LIST
64733: LIST
64734: PUSH
64735: LD_INT 34
64737: PUSH
64738: LD_INT 32
64740: PUSH
64741: EMPTY
64742: LIST
64743: LIST
64744: PUSH
64745: LD_INT 34
64747: PUSH
64748: LD_INT 13
64750: PUSH
64751: EMPTY
64752: LIST
64753: LIST
64754: PUSH
64755: LD_INT 34
64757: PUSH
64758: LD_INT 52
64760: PUSH
64761: EMPTY
64762: LIST
64763: LIST
64764: PUSH
64765: LD_INT 34
64767: PUSH
64768: LD_INT 88
64770: PUSH
64771: EMPTY
64772: LIST
64773: LIST
64774: PUSH
64775: LD_INT 34
64777: PUSH
64778: LD_INT 14
64780: PUSH
64781: EMPTY
64782: LIST
64783: LIST
64784: PUSH
64785: LD_INT 34
64787: PUSH
64788: LD_INT 53
64790: PUSH
64791: EMPTY
64792: LIST
64793: LIST
64794: PUSH
64795: LD_INT 34
64797: PUSH
64798: LD_INT 98
64800: PUSH
64801: EMPTY
64802: LIST
64803: LIST
64804: PUSH
64805: LD_INT 34
64807: PUSH
64808: LD_INT 31
64810: PUSH
64811: EMPTY
64812: LIST
64813: LIST
64814: PUSH
64815: LD_INT 34
64817: PUSH
64818: LD_INT 48
64820: PUSH
64821: EMPTY
64822: LIST
64823: LIST
64824: PUSH
64825: LD_INT 34
64827: PUSH
64828: LD_INT 8
64830: PUSH
64831: EMPTY
64832: LIST
64833: LIST
64834: PUSH
64835: EMPTY
64836: LIST
64837: LIST
64838: LIST
64839: LIST
64840: LIST
64841: LIST
64842: LIST
64843: LIST
64844: LIST
64845: LIST
64846: LIST
64847: LIST
64848: LIST
64849: LIST
64850: PPUSH
64851: CALL_OW 72
64855: DIFF
64856: ST_TO_ADDR
// end ; end_of_file
64857: LD_VAR 0 3
64861: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
64862: LD_INT 0
64864: PPUSH
64865: PPUSH
64866: PPUSH
// if not mc_bases or not skirmish then
64867: LD_EXP 102
64871: NOT
64872: PUSH
64873: LD_EXP 100
64877: NOT
64878: OR
64879: IFFALSE 64883
// exit ;
64881: GO 65048
// for i = 1 to mc_bases do
64883: LD_ADDR_VAR 0 4
64887: PUSH
64888: DOUBLE
64889: LD_INT 1
64891: DEC
64892: ST_TO_ADDR
64893: LD_EXP 102
64897: PUSH
64898: FOR_TO
64899: IFFALSE 65046
// begin if sci in mc_bases [ i ] then
64901: LD_VAR 0 2
64905: PUSH
64906: LD_EXP 102
64910: PUSH
64911: LD_VAR 0 4
64915: ARRAY
64916: IN
64917: IFFALSE 65044
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
64919: LD_ADDR_EXP 131
64923: PUSH
64924: LD_EXP 131
64928: PPUSH
64929: LD_VAR 0 4
64933: PUSH
64934: LD_EXP 131
64938: PUSH
64939: LD_VAR 0 4
64943: ARRAY
64944: PUSH
64945: LD_INT 1
64947: PLUS
64948: PUSH
64949: EMPTY
64950: LIST
64951: LIST
64952: PPUSH
64953: LD_VAR 0 1
64957: PPUSH
64958: CALL 74632 0 3
64962: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
64963: LD_ADDR_VAR 0 5
64967: PUSH
64968: LD_EXP 102
64972: PUSH
64973: LD_VAR 0 4
64977: ARRAY
64978: PPUSH
64979: LD_INT 2
64981: PUSH
64982: LD_INT 30
64984: PUSH
64985: LD_INT 0
64987: PUSH
64988: EMPTY
64989: LIST
64990: LIST
64991: PUSH
64992: LD_INT 30
64994: PUSH
64995: LD_INT 1
64997: PUSH
64998: EMPTY
64999: LIST
65000: LIST
65001: PUSH
65002: EMPTY
65003: LIST
65004: LIST
65005: LIST
65006: PPUSH
65007: CALL_OW 72
65011: PPUSH
65012: LD_VAR 0 1
65016: PPUSH
65017: CALL_OW 74
65021: ST_TO_ADDR
// if tmp then
65022: LD_VAR 0 5
65026: IFFALSE 65042
// ComStandNearbyBuilding ( ape , tmp ) ;
65028: LD_VAR 0 1
65032: PPUSH
65033: LD_VAR 0 5
65037: PPUSH
65038: CALL 71234 0 2
// break ;
65042: GO 65046
// end ; end ;
65044: GO 64898
65046: POP
65047: POP
// end ;
65048: LD_VAR 0 3
65052: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
65053: LD_INT 0
65055: PPUSH
65056: PPUSH
65057: PPUSH
// if not mc_bases or not skirmish then
65058: LD_EXP 102
65062: NOT
65063: PUSH
65064: LD_EXP 100
65068: NOT
65069: OR
65070: IFFALSE 65074
// exit ;
65072: GO 65163
// for i = 1 to mc_bases do
65074: LD_ADDR_VAR 0 4
65078: PUSH
65079: DOUBLE
65080: LD_INT 1
65082: DEC
65083: ST_TO_ADDR
65084: LD_EXP 102
65088: PUSH
65089: FOR_TO
65090: IFFALSE 65161
// begin if building in mc_busy_turret_list [ i ] then
65092: LD_VAR 0 1
65096: PUSH
65097: LD_EXP 112
65101: PUSH
65102: LD_VAR 0 4
65106: ARRAY
65107: IN
65108: IFFALSE 65159
// begin tmp := mc_busy_turret_list [ i ] diff building ;
65110: LD_ADDR_VAR 0 5
65114: PUSH
65115: LD_EXP 112
65119: PUSH
65120: LD_VAR 0 4
65124: ARRAY
65125: PUSH
65126: LD_VAR 0 1
65130: DIFF
65131: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
65132: LD_ADDR_EXP 112
65136: PUSH
65137: LD_EXP 112
65141: PPUSH
65142: LD_VAR 0 4
65146: PPUSH
65147: LD_VAR 0 5
65151: PPUSH
65152: CALL_OW 1
65156: ST_TO_ADDR
// break ;
65157: GO 65161
// end ; end ;
65159: GO 65089
65161: POP
65162: POP
// end ;
65163: LD_VAR 0 3
65167: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
65168: LD_INT 0
65170: PPUSH
65171: PPUSH
65172: PPUSH
// if not mc_bases or not skirmish then
65173: LD_EXP 102
65177: NOT
65178: PUSH
65179: LD_EXP 100
65183: NOT
65184: OR
65185: IFFALSE 65189
// exit ;
65187: GO 65388
// for i = 1 to mc_bases do
65189: LD_ADDR_VAR 0 5
65193: PUSH
65194: DOUBLE
65195: LD_INT 1
65197: DEC
65198: ST_TO_ADDR
65199: LD_EXP 102
65203: PUSH
65204: FOR_TO
65205: IFFALSE 65386
// if building in mc_bases [ i ] then
65207: LD_VAR 0 1
65211: PUSH
65212: LD_EXP 102
65216: PUSH
65217: LD_VAR 0 5
65221: ARRAY
65222: IN
65223: IFFALSE 65384
// begin tmp := mc_bases [ i ] diff building ;
65225: LD_ADDR_VAR 0 6
65229: PUSH
65230: LD_EXP 102
65234: PUSH
65235: LD_VAR 0 5
65239: ARRAY
65240: PUSH
65241: LD_VAR 0 1
65245: DIFF
65246: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
65247: LD_ADDR_EXP 102
65251: PUSH
65252: LD_EXP 102
65256: PPUSH
65257: LD_VAR 0 5
65261: PPUSH
65262: LD_VAR 0 6
65266: PPUSH
65267: CALL_OW 1
65271: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
65272: LD_VAR 0 1
65276: PUSH
65277: LD_EXP 110
65281: PUSH
65282: LD_VAR 0 5
65286: ARRAY
65287: IN
65288: IFFALSE 65327
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
65290: LD_ADDR_EXP 110
65294: PUSH
65295: LD_EXP 110
65299: PPUSH
65300: LD_VAR 0 5
65304: PPUSH
65305: LD_EXP 110
65309: PUSH
65310: LD_VAR 0 5
65314: ARRAY
65315: PUSH
65316: LD_VAR 0 1
65320: DIFF
65321: PPUSH
65322: CALL_OW 1
65326: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
65327: LD_VAR 0 1
65331: PUSH
65332: LD_EXP 111
65336: PUSH
65337: LD_VAR 0 5
65341: ARRAY
65342: IN
65343: IFFALSE 65382
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
65345: LD_ADDR_EXP 111
65349: PUSH
65350: LD_EXP 111
65354: PPUSH
65355: LD_VAR 0 5
65359: PPUSH
65360: LD_EXP 111
65364: PUSH
65365: LD_VAR 0 5
65369: ARRAY
65370: PUSH
65371: LD_VAR 0 1
65375: DIFF
65376: PPUSH
65377: CALL_OW 1
65381: ST_TO_ADDR
// break ;
65382: GO 65386
// end ;
65384: GO 65204
65386: POP
65387: POP
// end ;
65388: LD_VAR 0 4
65392: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
65393: LD_INT 0
65395: PPUSH
65396: PPUSH
65397: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
65398: LD_EXP 102
65402: NOT
65403: PUSH
65404: LD_EXP 100
65408: NOT
65409: OR
65410: PUSH
65411: LD_VAR 0 3
65415: PUSH
65416: LD_EXP 128
65420: IN
65421: NOT
65422: OR
65423: IFFALSE 65427
// exit ;
65425: GO 65550
// for i = 1 to mc_vehicles do
65427: LD_ADDR_VAR 0 6
65431: PUSH
65432: DOUBLE
65433: LD_INT 1
65435: DEC
65436: ST_TO_ADDR
65437: LD_EXP 121
65441: PUSH
65442: FOR_TO
65443: IFFALSE 65548
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
65445: LD_VAR 0 2
65449: PUSH
65450: LD_EXP 121
65454: PUSH
65455: LD_VAR 0 6
65459: ARRAY
65460: IN
65461: PUSH
65462: LD_VAR 0 1
65466: PUSH
65467: LD_EXP 121
65471: PUSH
65472: LD_VAR 0 6
65476: ARRAY
65477: IN
65478: OR
65479: IFFALSE 65546
// begin tmp := mc_vehicles [ i ] diff old ;
65481: LD_ADDR_VAR 0 7
65485: PUSH
65486: LD_EXP 121
65490: PUSH
65491: LD_VAR 0 6
65495: ARRAY
65496: PUSH
65497: LD_VAR 0 2
65501: DIFF
65502: ST_TO_ADDR
// tmp := tmp diff new ;
65503: LD_ADDR_VAR 0 7
65507: PUSH
65508: LD_VAR 0 7
65512: PUSH
65513: LD_VAR 0 1
65517: DIFF
65518: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
65519: LD_ADDR_EXP 121
65523: PUSH
65524: LD_EXP 121
65528: PPUSH
65529: LD_VAR 0 6
65533: PPUSH
65534: LD_VAR 0 7
65538: PPUSH
65539: CALL_OW 1
65543: ST_TO_ADDR
// break ;
65544: GO 65548
// end ;
65546: GO 65442
65548: POP
65549: POP
// end ;
65550: LD_VAR 0 5
65554: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
65555: LD_INT 0
65557: PPUSH
65558: PPUSH
65559: PPUSH
65560: PPUSH
// if not mc_bases or not skirmish then
65561: LD_EXP 102
65565: NOT
65566: PUSH
65567: LD_EXP 100
65571: NOT
65572: OR
65573: IFFALSE 65577
// exit ;
65575: GO 65997
// repeat wait ( 0 0$1 ) ;
65577: LD_INT 35
65579: PPUSH
65580: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
65584: LD_EXP 146
65588: NOT
65589: IFFALSE 65577
// mc_block_vehicle_constructed_thread := true ;
65591: LD_ADDR_EXP 146
65595: PUSH
65596: LD_INT 1
65598: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
65599: LD_ADDR_VAR 0 5
65603: PUSH
65604: LD_VAR 0 1
65608: PPUSH
65609: CALL_OW 255
65613: ST_TO_ADDR
// for i = 1 to mc_bases do
65614: LD_ADDR_VAR 0 4
65618: PUSH
65619: DOUBLE
65620: LD_INT 1
65622: DEC
65623: ST_TO_ADDR
65624: LD_EXP 102
65628: PUSH
65629: FOR_TO
65630: IFFALSE 65987
// begin if factory in mc_bases [ i ] then
65632: LD_VAR 0 2
65636: PUSH
65637: LD_EXP 102
65641: PUSH
65642: LD_VAR 0 4
65646: ARRAY
65647: IN
65648: IFFALSE 65985
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
65650: LD_EXP 124
65654: PUSH
65655: LD_VAR 0 4
65659: ARRAY
65660: PUSH
65661: LD_EXP 113
65665: PUSH
65666: LD_VAR 0 4
65670: ARRAY
65671: LESS
65672: PUSH
65673: LD_VAR 0 1
65677: PPUSH
65678: CALL_OW 264
65682: PUSH
65683: LD_INT 31
65685: PUSH
65686: LD_INT 32
65688: PUSH
65689: LD_INT 51
65691: PUSH
65692: LD_INT 89
65694: PUSH
65695: LD_INT 12
65697: PUSH
65698: LD_INT 30
65700: PUSH
65701: LD_INT 98
65703: PUSH
65704: LD_INT 11
65706: PUSH
65707: LD_INT 53
65709: PUSH
65710: LD_INT 14
65712: PUSH
65713: LD_INT 91
65715: PUSH
65716: LD_INT 29
65718: PUSH
65719: LD_INT 99
65721: PUSH
65722: LD_INT 13
65724: PUSH
65725: LD_INT 52
65727: PUSH
65728: LD_INT 88
65730: PUSH
65731: LD_INT 48
65733: PUSH
65734: LD_INT 8
65736: PUSH
65737: EMPTY
65738: LIST
65739: LIST
65740: LIST
65741: LIST
65742: LIST
65743: LIST
65744: LIST
65745: LIST
65746: LIST
65747: LIST
65748: LIST
65749: LIST
65750: LIST
65751: LIST
65752: LIST
65753: LIST
65754: LIST
65755: LIST
65756: IN
65757: NOT
65758: AND
65759: IFFALSE 65807
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
65761: LD_ADDR_EXP 124
65765: PUSH
65766: LD_EXP 124
65770: PPUSH
65771: LD_VAR 0 4
65775: PUSH
65776: LD_EXP 124
65780: PUSH
65781: LD_VAR 0 4
65785: ARRAY
65786: PUSH
65787: LD_INT 1
65789: PLUS
65790: PUSH
65791: EMPTY
65792: LIST
65793: LIST
65794: PPUSH
65795: LD_VAR 0 1
65799: PPUSH
65800: CALL 74632 0 3
65804: ST_TO_ADDR
65805: GO 65851
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
65807: LD_ADDR_EXP 121
65811: PUSH
65812: LD_EXP 121
65816: PPUSH
65817: LD_VAR 0 4
65821: PUSH
65822: LD_EXP 121
65826: PUSH
65827: LD_VAR 0 4
65831: ARRAY
65832: PUSH
65833: LD_INT 1
65835: PLUS
65836: PUSH
65837: EMPTY
65838: LIST
65839: LIST
65840: PPUSH
65841: LD_VAR 0 1
65845: PPUSH
65846: CALL 74632 0 3
65850: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
65851: LD_ADDR_EXP 146
65855: PUSH
65856: LD_INT 0
65858: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
65859: LD_VAR 0 1
65863: PPUSH
65864: CALL_OW 263
65868: PUSH
65869: LD_INT 2
65871: EQUAL
65872: IFFALSE 65901
// begin repeat wait ( 0 0$3 ) ;
65874: LD_INT 105
65876: PPUSH
65877: CALL_OW 67
// Connect ( vehicle ) ;
65881: LD_VAR 0 1
65885: PPUSH
65886: CALL 77978 0 1
// until IsControledBy ( vehicle ) ;
65890: LD_VAR 0 1
65894: PPUSH
65895: CALL_OW 312
65899: IFFALSE 65874
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
65901: LD_VAR 0 1
65905: PPUSH
65906: LD_EXP 126
65910: PUSH
65911: LD_VAR 0 4
65915: ARRAY
65916: PPUSH
65917: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
65921: LD_VAR 0 1
65925: PPUSH
65926: CALL_OW 263
65930: PUSH
65931: LD_INT 1
65933: NONEQUAL
65934: IFFALSE 65938
// break ;
65936: GO 65987
// repeat wait ( 0 0$1 ) ;
65938: LD_INT 35
65940: PPUSH
65941: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
65945: LD_VAR 0 1
65949: PPUSH
65950: LD_EXP 126
65954: PUSH
65955: LD_VAR 0 4
65959: ARRAY
65960: PPUSH
65961: CALL_OW 308
65965: IFFALSE 65938
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
65967: LD_VAR 0 1
65971: PPUSH
65972: CALL_OW 311
65976: PPUSH
65977: CALL_OW 121
// exit ;
65981: POP
65982: POP
65983: GO 65997
// end ; end ;
65985: GO 65629
65987: POP
65988: POP
// mc_block_vehicle_constructed_thread := false ;
65989: LD_ADDR_EXP 146
65993: PUSH
65994: LD_INT 0
65996: ST_TO_ADDR
// end ;
65997: LD_VAR 0 3
66001: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
66002: LD_INT 0
66004: PPUSH
66005: PPUSH
66006: PPUSH
66007: PPUSH
// if not mc_bases or not skirmish then
66008: LD_EXP 102
66012: NOT
66013: PUSH
66014: LD_EXP 100
66018: NOT
66019: OR
66020: IFFALSE 66024
// exit ;
66022: GO 66377
// repeat wait ( 0 0$1 ) ;
66024: LD_INT 35
66026: PPUSH
66027: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
66031: LD_VAR 0 2
66035: PPUSH
66036: LD_VAR 0 3
66040: PPUSH
66041: CALL_OW 284
66045: IFFALSE 66024
// if GetResourceTypeXY ( x , y ) = mat_artefact then
66047: LD_VAR 0 2
66051: PPUSH
66052: LD_VAR 0 3
66056: PPUSH
66057: CALL_OW 283
66061: PUSH
66062: LD_INT 4
66064: EQUAL
66065: IFFALSE 66069
// exit ;
66067: GO 66377
// for i = 1 to mc_bases do
66069: LD_ADDR_VAR 0 7
66073: PUSH
66074: DOUBLE
66075: LD_INT 1
66077: DEC
66078: ST_TO_ADDR
66079: LD_EXP 102
66083: PUSH
66084: FOR_TO
66085: IFFALSE 66375
// begin if mc_crates_area [ i ] then
66087: LD_EXP 120
66091: PUSH
66092: LD_VAR 0 7
66096: ARRAY
66097: IFFALSE 66208
// for j in mc_crates_area [ i ] do
66099: LD_ADDR_VAR 0 8
66103: PUSH
66104: LD_EXP 120
66108: PUSH
66109: LD_VAR 0 7
66113: ARRAY
66114: PUSH
66115: FOR_IN
66116: IFFALSE 66206
// if InArea ( x , y , j ) then
66118: LD_VAR 0 2
66122: PPUSH
66123: LD_VAR 0 3
66127: PPUSH
66128: LD_VAR 0 8
66132: PPUSH
66133: CALL_OW 309
66137: IFFALSE 66204
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
66139: LD_ADDR_EXP 118
66143: PUSH
66144: LD_EXP 118
66148: PPUSH
66149: LD_VAR 0 7
66153: PUSH
66154: LD_EXP 118
66158: PUSH
66159: LD_VAR 0 7
66163: ARRAY
66164: PUSH
66165: LD_INT 1
66167: PLUS
66168: PUSH
66169: EMPTY
66170: LIST
66171: LIST
66172: PPUSH
66173: LD_VAR 0 4
66177: PUSH
66178: LD_VAR 0 2
66182: PUSH
66183: LD_VAR 0 3
66187: PUSH
66188: EMPTY
66189: LIST
66190: LIST
66191: LIST
66192: PPUSH
66193: CALL 74632 0 3
66197: ST_TO_ADDR
// exit ;
66198: POP
66199: POP
66200: POP
66201: POP
66202: GO 66377
// end ;
66204: GO 66115
66206: POP
66207: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66208: LD_ADDR_VAR 0 9
66212: PUSH
66213: LD_EXP 102
66217: PUSH
66218: LD_VAR 0 7
66222: ARRAY
66223: PPUSH
66224: LD_INT 2
66226: PUSH
66227: LD_INT 30
66229: PUSH
66230: LD_INT 0
66232: PUSH
66233: EMPTY
66234: LIST
66235: LIST
66236: PUSH
66237: LD_INT 30
66239: PUSH
66240: LD_INT 1
66242: PUSH
66243: EMPTY
66244: LIST
66245: LIST
66246: PUSH
66247: EMPTY
66248: LIST
66249: LIST
66250: LIST
66251: PPUSH
66252: CALL_OW 72
66256: ST_TO_ADDR
// if not depot then
66257: LD_VAR 0 9
66261: NOT
66262: IFFALSE 66266
// continue ;
66264: GO 66084
// for j in depot do
66266: LD_ADDR_VAR 0 8
66270: PUSH
66271: LD_VAR 0 9
66275: PUSH
66276: FOR_IN
66277: IFFALSE 66371
// if GetDistUnitXY ( j , x , y ) < 30 then
66279: LD_VAR 0 8
66283: PPUSH
66284: LD_VAR 0 2
66288: PPUSH
66289: LD_VAR 0 3
66293: PPUSH
66294: CALL_OW 297
66298: PUSH
66299: LD_INT 30
66301: LESS
66302: IFFALSE 66369
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
66304: LD_ADDR_EXP 118
66308: PUSH
66309: LD_EXP 118
66313: PPUSH
66314: LD_VAR 0 7
66318: PUSH
66319: LD_EXP 118
66323: PUSH
66324: LD_VAR 0 7
66328: ARRAY
66329: PUSH
66330: LD_INT 1
66332: PLUS
66333: PUSH
66334: EMPTY
66335: LIST
66336: LIST
66337: PPUSH
66338: LD_VAR 0 4
66342: PUSH
66343: LD_VAR 0 2
66347: PUSH
66348: LD_VAR 0 3
66352: PUSH
66353: EMPTY
66354: LIST
66355: LIST
66356: LIST
66357: PPUSH
66358: CALL 74632 0 3
66362: ST_TO_ADDR
// exit ;
66363: POP
66364: POP
66365: POP
66366: POP
66367: GO 66377
// end ;
66369: GO 66276
66371: POP
66372: POP
// end ;
66373: GO 66084
66375: POP
66376: POP
// end ;
66377: LD_VAR 0 6
66381: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
66382: LD_INT 0
66384: PPUSH
66385: PPUSH
66386: PPUSH
66387: PPUSH
// if not mc_bases or not skirmish then
66388: LD_EXP 102
66392: NOT
66393: PUSH
66394: LD_EXP 100
66398: NOT
66399: OR
66400: IFFALSE 66404
// exit ;
66402: GO 66681
// side := GetSide ( lab ) ;
66404: LD_ADDR_VAR 0 4
66408: PUSH
66409: LD_VAR 0 2
66413: PPUSH
66414: CALL_OW 255
66418: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
66419: LD_VAR 0 4
66423: PUSH
66424: LD_EXP 128
66428: IN
66429: NOT
66430: PUSH
66431: LD_EXP 129
66435: NOT
66436: OR
66437: PUSH
66438: LD_EXP 102
66442: NOT
66443: OR
66444: IFFALSE 66448
// exit ;
66446: GO 66681
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
66448: LD_ADDR_EXP 129
66452: PUSH
66453: LD_EXP 129
66457: PPUSH
66458: LD_VAR 0 4
66462: PPUSH
66463: LD_EXP 129
66467: PUSH
66468: LD_VAR 0 4
66472: ARRAY
66473: PUSH
66474: LD_VAR 0 1
66478: DIFF
66479: PPUSH
66480: CALL_OW 1
66484: ST_TO_ADDR
// for i = 1 to mc_bases do
66485: LD_ADDR_VAR 0 5
66489: PUSH
66490: DOUBLE
66491: LD_INT 1
66493: DEC
66494: ST_TO_ADDR
66495: LD_EXP 102
66499: PUSH
66500: FOR_TO
66501: IFFALSE 66679
// begin if lab in mc_bases [ i ] then
66503: LD_VAR 0 2
66507: PUSH
66508: LD_EXP 102
66512: PUSH
66513: LD_VAR 0 5
66517: ARRAY
66518: IN
66519: IFFALSE 66677
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
66521: LD_VAR 0 1
66525: PUSH
66526: LD_INT 11
66528: PUSH
66529: LD_INT 4
66531: PUSH
66532: LD_INT 3
66534: PUSH
66535: LD_INT 2
66537: PUSH
66538: EMPTY
66539: LIST
66540: LIST
66541: LIST
66542: LIST
66543: IN
66544: PUSH
66545: LD_EXP 132
66549: PUSH
66550: LD_VAR 0 5
66554: ARRAY
66555: AND
66556: IFFALSE 66677
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
66558: LD_ADDR_VAR 0 6
66562: PUSH
66563: LD_EXP 132
66567: PUSH
66568: LD_VAR 0 5
66572: ARRAY
66573: PUSH
66574: LD_INT 1
66576: ARRAY
66577: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
66578: LD_ADDR_EXP 132
66582: PUSH
66583: LD_EXP 132
66587: PPUSH
66588: LD_VAR 0 5
66592: PPUSH
66593: EMPTY
66594: PPUSH
66595: CALL_OW 1
66599: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
66600: LD_VAR 0 6
66604: PPUSH
66605: LD_INT 0
66607: PPUSH
66608: CALL_OW 109
// ComExitBuilding ( tmp ) ;
66612: LD_VAR 0 6
66616: PPUSH
66617: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
66621: LD_ADDR_EXP 131
66625: PUSH
66626: LD_EXP 131
66630: PPUSH
66631: LD_VAR 0 5
66635: PPUSH
66636: LD_EXP 131
66640: PUSH
66641: LD_VAR 0 5
66645: ARRAY
66646: PPUSH
66647: LD_INT 1
66649: PPUSH
66650: LD_VAR 0 6
66654: PPUSH
66655: CALL_OW 2
66659: PPUSH
66660: CALL_OW 1
66664: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
66665: LD_VAR 0 5
66669: PPUSH
66670: LD_INT 112
66672: PPUSH
66673: CALL 43131 0 2
// end ; end ; end ;
66677: GO 66500
66679: POP
66680: POP
// end ;
66681: LD_VAR 0 3
66685: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
66686: LD_INT 0
66688: PPUSH
66689: PPUSH
66690: PPUSH
66691: PPUSH
66692: PPUSH
66693: PPUSH
66694: PPUSH
66695: PPUSH
// if not mc_bases or not skirmish then
66696: LD_EXP 102
66700: NOT
66701: PUSH
66702: LD_EXP 100
66706: NOT
66707: OR
66708: IFFALSE 66712
// exit ;
66710: GO 68081
// for i = 1 to mc_bases do
66712: LD_ADDR_VAR 0 3
66716: PUSH
66717: DOUBLE
66718: LD_INT 1
66720: DEC
66721: ST_TO_ADDR
66722: LD_EXP 102
66726: PUSH
66727: FOR_TO
66728: IFFALSE 68079
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
66730: LD_VAR 0 1
66734: PUSH
66735: LD_EXP 102
66739: PUSH
66740: LD_VAR 0 3
66744: ARRAY
66745: IN
66746: PUSH
66747: LD_VAR 0 1
66751: PUSH
66752: LD_EXP 109
66756: PUSH
66757: LD_VAR 0 3
66761: ARRAY
66762: IN
66763: OR
66764: PUSH
66765: LD_VAR 0 1
66769: PUSH
66770: LD_EXP 124
66774: PUSH
66775: LD_VAR 0 3
66779: ARRAY
66780: IN
66781: OR
66782: PUSH
66783: LD_VAR 0 1
66787: PUSH
66788: LD_EXP 121
66792: PUSH
66793: LD_VAR 0 3
66797: ARRAY
66798: IN
66799: OR
66800: PUSH
66801: LD_VAR 0 1
66805: PUSH
66806: LD_EXP 131
66810: PUSH
66811: LD_VAR 0 3
66815: ARRAY
66816: IN
66817: OR
66818: PUSH
66819: LD_VAR 0 1
66823: PUSH
66824: LD_EXP 132
66828: PUSH
66829: LD_VAR 0 3
66833: ARRAY
66834: IN
66835: OR
66836: IFFALSE 68077
// begin if un in mc_ape [ i ] then
66838: LD_VAR 0 1
66842: PUSH
66843: LD_EXP 131
66847: PUSH
66848: LD_VAR 0 3
66852: ARRAY
66853: IN
66854: IFFALSE 66893
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
66856: LD_ADDR_EXP 131
66860: PUSH
66861: LD_EXP 131
66865: PPUSH
66866: LD_VAR 0 3
66870: PPUSH
66871: LD_EXP 131
66875: PUSH
66876: LD_VAR 0 3
66880: ARRAY
66881: PUSH
66882: LD_VAR 0 1
66886: DIFF
66887: PPUSH
66888: CALL_OW 1
66892: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
66893: LD_VAR 0 1
66897: PUSH
66898: LD_EXP 132
66902: PUSH
66903: LD_VAR 0 3
66907: ARRAY
66908: IN
66909: IFFALSE 66933
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
66911: LD_ADDR_EXP 132
66915: PUSH
66916: LD_EXP 132
66920: PPUSH
66921: LD_VAR 0 3
66925: PPUSH
66926: EMPTY
66927: PPUSH
66928: CALL_OW 1
66932: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
66933: LD_VAR 0 1
66937: PPUSH
66938: CALL_OW 247
66942: PUSH
66943: LD_INT 2
66945: EQUAL
66946: PUSH
66947: LD_VAR 0 1
66951: PPUSH
66952: CALL_OW 110
66956: PUSH
66957: LD_INT 20
66959: EQUAL
66960: PUSH
66961: LD_VAR 0 1
66965: PUSH
66966: LD_EXP 124
66970: PUSH
66971: LD_VAR 0 3
66975: ARRAY
66976: IN
66977: OR
66978: PUSH
66979: LD_VAR 0 1
66983: PPUSH
66984: CALL_OW 264
66988: PUSH
66989: LD_INT 12
66991: PUSH
66992: LD_INT 51
66994: PUSH
66995: LD_INT 89
66997: PUSH
66998: LD_INT 32
67000: PUSH
67001: LD_INT 13
67003: PUSH
67004: LD_INT 52
67006: PUSH
67007: LD_INT 31
67009: PUSH
67010: EMPTY
67011: LIST
67012: LIST
67013: LIST
67014: LIST
67015: LIST
67016: LIST
67017: LIST
67018: IN
67019: OR
67020: AND
67021: IFFALSE 67329
// begin if un in mc_defender [ i ] then
67023: LD_VAR 0 1
67027: PUSH
67028: LD_EXP 124
67032: PUSH
67033: LD_VAR 0 3
67037: ARRAY
67038: IN
67039: IFFALSE 67078
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
67041: LD_ADDR_EXP 124
67045: PUSH
67046: LD_EXP 124
67050: PPUSH
67051: LD_VAR 0 3
67055: PPUSH
67056: LD_EXP 124
67060: PUSH
67061: LD_VAR 0 3
67065: ARRAY
67066: PUSH
67067: LD_VAR 0 1
67071: DIFF
67072: PPUSH
67073: CALL_OW 1
67077: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
67078: LD_ADDR_VAR 0 8
67082: PUSH
67083: LD_VAR 0 3
67087: PPUSH
67088: LD_INT 3
67090: PPUSH
67091: CALL 63699 0 2
67095: ST_TO_ADDR
// if fac then
67096: LD_VAR 0 8
67100: IFFALSE 67329
// begin for j in fac do
67102: LD_ADDR_VAR 0 4
67106: PUSH
67107: LD_VAR 0 8
67111: PUSH
67112: FOR_IN
67113: IFFALSE 67327
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
67115: LD_ADDR_VAR 0 9
67119: PUSH
67120: LD_VAR 0 8
67124: PPUSH
67125: LD_VAR 0 1
67129: PPUSH
67130: CALL_OW 265
67134: PPUSH
67135: LD_VAR 0 1
67139: PPUSH
67140: CALL_OW 262
67144: PPUSH
67145: LD_VAR 0 1
67149: PPUSH
67150: CALL_OW 263
67154: PPUSH
67155: LD_VAR 0 1
67159: PPUSH
67160: CALL_OW 264
67164: PPUSH
67165: CALL 72130 0 5
67169: ST_TO_ADDR
// if components then
67170: LD_VAR 0 9
67174: IFFALSE 67325
// begin if GetWeapon ( un ) = ar_control_tower then
67176: LD_VAR 0 1
67180: PPUSH
67181: CALL_OW 264
67185: PUSH
67186: LD_INT 31
67188: EQUAL
67189: IFFALSE 67306
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
67191: LD_VAR 0 1
67195: PPUSH
67196: CALL_OW 311
67200: PPUSH
67201: LD_INT 0
67203: PPUSH
67204: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
67208: LD_ADDR_EXP 142
67212: PUSH
67213: LD_EXP 142
67217: PPUSH
67218: LD_VAR 0 3
67222: PPUSH
67223: LD_EXP 142
67227: PUSH
67228: LD_VAR 0 3
67232: ARRAY
67233: PUSH
67234: LD_VAR 0 1
67238: PPUSH
67239: CALL_OW 311
67243: DIFF
67244: PPUSH
67245: CALL_OW 1
67249: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
67250: LD_ADDR_VAR 0 7
67254: PUSH
67255: LD_EXP 123
67259: PUSH
67260: LD_VAR 0 3
67264: ARRAY
67265: PPUSH
67266: LD_INT 1
67268: PPUSH
67269: LD_VAR 0 9
67273: PPUSH
67274: CALL_OW 2
67278: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
67279: LD_ADDR_EXP 123
67283: PUSH
67284: LD_EXP 123
67288: PPUSH
67289: LD_VAR 0 3
67293: PPUSH
67294: LD_VAR 0 7
67298: PPUSH
67299: CALL_OW 1
67303: ST_TO_ADDR
// end else
67304: GO 67323
// MC_InsertProduceList ( i , [ components ] ) ;
67306: LD_VAR 0 3
67310: PPUSH
67311: LD_VAR 0 9
67315: PUSH
67316: EMPTY
67317: LIST
67318: PPUSH
67319: CALL 63244 0 2
// break ;
67323: GO 67327
// end ; end ;
67325: GO 67112
67327: POP
67328: POP
// end ; end ; if GetType ( un ) = unit_building then
67329: LD_VAR 0 1
67333: PPUSH
67334: CALL_OW 247
67338: PUSH
67339: LD_INT 3
67341: EQUAL
67342: IFFALSE 67745
// begin btype := GetBType ( un ) ;
67344: LD_ADDR_VAR 0 5
67348: PUSH
67349: LD_VAR 0 1
67353: PPUSH
67354: CALL_OW 266
67358: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
67359: LD_VAR 0 5
67363: PUSH
67364: LD_INT 29
67366: PUSH
67367: LD_INT 30
67369: PUSH
67370: EMPTY
67371: LIST
67372: LIST
67373: IN
67374: IFFALSE 67447
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
67376: LD_VAR 0 1
67380: PPUSH
67381: CALL_OW 250
67385: PPUSH
67386: LD_VAR 0 1
67390: PPUSH
67391: CALL_OW 251
67395: PPUSH
67396: LD_VAR 0 1
67400: PPUSH
67401: CALL_OW 255
67405: PPUSH
67406: CALL_OW 440
67410: NOT
67411: IFFALSE 67447
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
67413: LD_VAR 0 1
67417: PPUSH
67418: CALL_OW 250
67422: PPUSH
67423: LD_VAR 0 1
67427: PPUSH
67428: CALL_OW 251
67432: PPUSH
67433: LD_VAR 0 1
67437: PPUSH
67438: CALL_OW 255
67442: PPUSH
67443: CALL_OW 441
// end ; if btype = b_warehouse then
67447: LD_VAR 0 5
67451: PUSH
67452: LD_INT 1
67454: EQUAL
67455: IFFALSE 67473
// begin btype := b_depot ;
67457: LD_ADDR_VAR 0 5
67461: PUSH
67462: LD_INT 0
67464: ST_TO_ADDR
// pos := 1 ;
67465: LD_ADDR_VAR 0 6
67469: PUSH
67470: LD_INT 1
67472: ST_TO_ADDR
// end ; if btype = b_factory then
67473: LD_VAR 0 5
67477: PUSH
67478: LD_INT 3
67480: EQUAL
67481: IFFALSE 67499
// begin btype := b_workshop ;
67483: LD_ADDR_VAR 0 5
67487: PUSH
67488: LD_INT 2
67490: ST_TO_ADDR
// pos := 1 ;
67491: LD_ADDR_VAR 0 6
67495: PUSH
67496: LD_INT 1
67498: ST_TO_ADDR
// end ; if btype = b_barracks then
67499: LD_VAR 0 5
67503: PUSH
67504: LD_INT 5
67506: EQUAL
67507: IFFALSE 67517
// btype := b_armoury ;
67509: LD_ADDR_VAR 0 5
67513: PUSH
67514: LD_INT 4
67516: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
67517: LD_VAR 0 5
67521: PUSH
67522: LD_INT 7
67524: PUSH
67525: LD_INT 8
67527: PUSH
67528: EMPTY
67529: LIST
67530: LIST
67531: IN
67532: IFFALSE 67542
// btype := b_lab ;
67534: LD_ADDR_VAR 0 5
67538: PUSH
67539: LD_INT 6
67541: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
67542: LD_ADDR_EXP 107
67546: PUSH
67547: LD_EXP 107
67551: PPUSH
67552: LD_VAR 0 3
67556: PUSH
67557: LD_EXP 107
67561: PUSH
67562: LD_VAR 0 3
67566: ARRAY
67567: PUSH
67568: LD_INT 1
67570: PLUS
67571: PUSH
67572: EMPTY
67573: LIST
67574: LIST
67575: PPUSH
67576: LD_VAR 0 5
67580: PUSH
67581: LD_VAR 0 1
67585: PPUSH
67586: CALL_OW 250
67590: PUSH
67591: LD_VAR 0 1
67595: PPUSH
67596: CALL_OW 251
67600: PUSH
67601: LD_VAR 0 1
67605: PPUSH
67606: CALL_OW 254
67610: PUSH
67611: EMPTY
67612: LIST
67613: LIST
67614: LIST
67615: LIST
67616: PPUSH
67617: CALL 74632 0 3
67621: ST_TO_ADDR
// if pos = 1 then
67622: LD_VAR 0 6
67626: PUSH
67627: LD_INT 1
67629: EQUAL
67630: IFFALSE 67745
// begin tmp := mc_build_list [ i ] ;
67632: LD_ADDR_VAR 0 7
67636: PUSH
67637: LD_EXP 107
67641: PUSH
67642: LD_VAR 0 3
67646: ARRAY
67647: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
67648: LD_VAR 0 7
67652: PPUSH
67653: LD_INT 2
67655: PUSH
67656: LD_INT 30
67658: PUSH
67659: LD_INT 0
67661: PUSH
67662: EMPTY
67663: LIST
67664: LIST
67665: PUSH
67666: LD_INT 30
67668: PUSH
67669: LD_INT 1
67671: PUSH
67672: EMPTY
67673: LIST
67674: LIST
67675: PUSH
67676: EMPTY
67677: LIST
67678: LIST
67679: LIST
67680: PPUSH
67681: CALL_OW 72
67685: IFFALSE 67695
// pos := 2 ;
67687: LD_ADDR_VAR 0 6
67691: PUSH
67692: LD_INT 2
67694: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
67695: LD_ADDR_VAR 0 7
67699: PUSH
67700: LD_VAR 0 7
67704: PPUSH
67705: LD_VAR 0 6
67709: PPUSH
67710: LD_VAR 0 7
67714: PPUSH
67715: CALL 74958 0 3
67719: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
67720: LD_ADDR_EXP 107
67724: PUSH
67725: LD_EXP 107
67729: PPUSH
67730: LD_VAR 0 3
67734: PPUSH
67735: LD_VAR 0 7
67739: PPUSH
67740: CALL_OW 1
67744: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
67745: LD_VAR 0 1
67749: PUSH
67750: LD_EXP 102
67754: PUSH
67755: LD_VAR 0 3
67759: ARRAY
67760: IN
67761: IFFALSE 67800
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
67763: LD_ADDR_EXP 102
67767: PUSH
67768: LD_EXP 102
67772: PPUSH
67773: LD_VAR 0 3
67777: PPUSH
67778: LD_EXP 102
67782: PUSH
67783: LD_VAR 0 3
67787: ARRAY
67788: PUSH
67789: LD_VAR 0 1
67793: DIFF
67794: PPUSH
67795: CALL_OW 1
67799: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
67800: LD_VAR 0 1
67804: PUSH
67805: LD_EXP 109
67809: PUSH
67810: LD_VAR 0 3
67814: ARRAY
67815: IN
67816: IFFALSE 67855
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
67818: LD_ADDR_EXP 109
67822: PUSH
67823: LD_EXP 109
67827: PPUSH
67828: LD_VAR 0 3
67832: PPUSH
67833: LD_EXP 109
67837: PUSH
67838: LD_VAR 0 3
67842: ARRAY
67843: PUSH
67844: LD_VAR 0 1
67848: DIFF
67849: PPUSH
67850: CALL_OW 1
67854: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
67855: LD_VAR 0 1
67859: PUSH
67860: LD_EXP 121
67864: PUSH
67865: LD_VAR 0 3
67869: ARRAY
67870: IN
67871: IFFALSE 67910
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
67873: LD_ADDR_EXP 121
67877: PUSH
67878: LD_EXP 121
67882: PPUSH
67883: LD_VAR 0 3
67887: PPUSH
67888: LD_EXP 121
67892: PUSH
67893: LD_VAR 0 3
67897: ARRAY
67898: PUSH
67899: LD_VAR 0 1
67903: DIFF
67904: PPUSH
67905: CALL_OW 1
67909: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
67910: LD_VAR 0 1
67914: PUSH
67915: LD_EXP 124
67919: PUSH
67920: LD_VAR 0 3
67924: ARRAY
67925: IN
67926: IFFALSE 67965
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
67928: LD_ADDR_EXP 124
67932: PUSH
67933: LD_EXP 124
67937: PPUSH
67938: LD_VAR 0 3
67942: PPUSH
67943: LD_EXP 124
67947: PUSH
67948: LD_VAR 0 3
67952: ARRAY
67953: PUSH
67954: LD_VAR 0 1
67958: DIFF
67959: PPUSH
67960: CALL_OW 1
67964: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
67965: LD_VAR 0 1
67969: PUSH
67970: LD_EXP 111
67974: PUSH
67975: LD_VAR 0 3
67979: ARRAY
67980: IN
67981: IFFALSE 68020
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
67983: LD_ADDR_EXP 111
67987: PUSH
67988: LD_EXP 111
67992: PPUSH
67993: LD_VAR 0 3
67997: PPUSH
67998: LD_EXP 111
68002: PUSH
68003: LD_VAR 0 3
68007: ARRAY
68008: PUSH
68009: LD_VAR 0 1
68013: DIFF
68014: PPUSH
68015: CALL_OW 1
68019: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
68020: LD_VAR 0 1
68024: PUSH
68025: LD_EXP 110
68029: PUSH
68030: LD_VAR 0 3
68034: ARRAY
68035: IN
68036: IFFALSE 68075
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
68038: LD_ADDR_EXP 110
68042: PUSH
68043: LD_EXP 110
68047: PPUSH
68048: LD_VAR 0 3
68052: PPUSH
68053: LD_EXP 110
68057: PUSH
68058: LD_VAR 0 3
68062: ARRAY
68063: PUSH
68064: LD_VAR 0 1
68068: DIFF
68069: PPUSH
68070: CALL_OW 1
68074: ST_TO_ADDR
// end ; break ;
68075: GO 68079
// end ;
68077: GO 66727
68079: POP
68080: POP
// end ;
68081: LD_VAR 0 2
68085: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
68086: LD_INT 0
68088: PPUSH
68089: PPUSH
68090: PPUSH
// if not mc_bases or not skirmish then
68091: LD_EXP 102
68095: NOT
68096: PUSH
68097: LD_EXP 100
68101: NOT
68102: OR
68103: IFFALSE 68107
// exit ;
68105: GO 68322
// for i = 1 to mc_bases do
68107: LD_ADDR_VAR 0 3
68111: PUSH
68112: DOUBLE
68113: LD_INT 1
68115: DEC
68116: ST_TO_ADDR
68117: LD_EXP 102
68121: PUSH
68122: FOR_TO
68123: IFFALSE 68320
// begin if building in mc_construct_list [ i ] then
68125: LD_VAR 0 1
68129: PUSH
68130: LD_EXP 109
68134: PUSH
68135: LD_VAR 0 3
68139: ARRAY
68140: IN
68141: IFFALSE 68318
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
68143: LD_ADDR_EXP 109
68147: PUSH
68148: LD_EXP 109
68152: PPUSH
68153: LD_VAR 0 3
68157: PPUSH
68158: LD_EXP 109
68162: PUSH
68163: LD_VAR 0 3
68167: ARRAY
68168: PUSH
68169: LD_VAR 0 1
68173: DIFF
68174: PPUSH
68175: CALL_OW 1
68179: ST_TO_ADDR
// if building in mc_lab [ i ] then
68180: LD_VAR 0 1
68184: PUSH
68185: LD_EXP 135
68189: PUSH
68190: LD_VAR 0 3
68194: ARRAY
68195: IN
68196: IFFALSE 68251
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
68198: LD_ADDR_EXP 136
68202: PUSH
68203: LD_EXP 136
68207: PPUSH
68208: LD_VAR 0 3
68212: PPUSH
68213: LD_EXP 136
68217: PUSH
68218: LD_VAR 0 3
68222: ARRAY
68223: PPUSH
68224: LD_INT 1
68226: PPUSH
68227: LD_EXP 136
68231: PUSH
68232: LD_VAR 0 3
68236: ARRAY
68237: PPUSH
68238: LD_INT 0
68240: PPUSH
68241: CALL 74050 0 4
68245: PPUSH
68246: CALL_OW 1
68250: ST_TO_ADDR
// if not building in mc_bases [ i ] then
68251: LD_VAR 0 1
68255: PUSH
68256: LD_EXP 102
68260: PUSH
68261: LD_VAR 0 3
68265: ARRAY
68266: IN
68267: NOT
68268: IFFALSE 68314
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
68270: LD_ADDR_EXP 102
68274: PUSH
68275: LD_EXP 102
68279: PPUSH
68280: LD_VAR 0 3
68284: PUSH
68285: LD_EXP 102
68289: PUSH
68290: LD_VAR 0 3
68294: ARRAY
68295: PUSH
68296: LD_INT 1
68298: PLUS
68299: PUSH
68300: EMPTY
68301: LIST
68302: LIST
68303: PPUSH
68304: LD_VAR 0 1
68308: PPUSH
68309: CALL 74632 0 3
68313: ST_TO_ADDR
// exit ;
68314: POP
68315: POP
68316: GO 68322
// end ; end ;
68318: GO 68122
68320: POP
68321: POP
// end ;
68322: LD_VAR 0 2
68326: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
68327: LD_INT 0
68329: PPUSH
68330: PPUSH
68331: PPUSH
68332: PPUSH
68333: PPUSH
68334: PPUSH
68335: PPUSH
// if not mc_bases or not skirmish then
68336: LD_EXP 102
68340: NOT
68341: PUSH
68342: LD_EXP 100
68346: NOT
68347: OR
68348: IFFALSE 68352
// exit ;
68350: GO 69013
// for i = 1 to mc_bases do
68352: LD_ADDR_VAR 0 3
68356: PUSH
68357: DOUBLE
68358: LD_INT 1
68360: DEC
68361: ST_TO_ADDR
68362: LD_EXP 102
68366: PUSH
68367: FOR_TO
68368: IFFALSE 69011
// begin if building in mc_construct_list [ i ] then
68370: LD_VAR 0 1
68374: PUSH
68375: LD_EXP 109
68379: PUSH
68380: LD_VAR 0 3
68384: ARRAY
68385: IN
68386: IFFALSE 69009
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
68388: LD_ADDR_EXP 109
68392: PUSH
68393: LD_EXP 109
68397: PPUSH
68398: LD_VAR 0 3
68402: PPUSH
68403: LD_EXP 109
68407: PUSH
68408: LD_VAR 0 3
68412: ARRAY
68413: PUSH
68414: LD_VAR 0 1
68418: DIFF
68419: PPUSH
68420: CALL_OW 1
68424: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
68425: LD_ADDR_EXP 102
68429: PUSH
68430: LD_EXP 102
68434: PPUSH
68435: LD_VAR 0 3
68439: PUSH
68440: LD_EXP 102
68444: PUSH
68445: LD_VAR 0 3
68449: ARRAY
68450: PUSH
68451: LD_INT 1
68453: PLUS
68454: PUSH
68455: EMPTY
68456: LIST
68457: LIST
68458: PPUSH
68459: LD_VAR 0 1
68463: PPUSH
68464: CALL 74632 0 3
68468: ST_TO_ADDR
// btype := GetBType ( building ) ;
68469: LD_ADDR_VAR 0 5
68473: PUSH
68474: LD_VAR 0 1
68478: PPUSH
68479: CALL_OW 266
68483: ST_TO_ADDR
// side := GetSide ( building ) ;
68484: LD_ADDR_VAR 0 8
68488: PUSH
68489: LD_VAR 0 1
68493: PPUSH
68494: CALL_OW 255
68498: ST_TO_ADDR
// if btype = b_lab then
68499: LD_VAR 0 5
68503: PUSH
68504: LD_INT 6
68506: EQUAL
68507: IFFALSE 68557
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
68509: LD_ADDR_EXP 135
68513: PUSH
68514: LD_EXP 135
68518: PPUSH
68519: LD_VAR 0 3
68523: PUSH
68524: LD_EXP 135
68528: PUSH
68529: LD_VAR 0 3
68533: ARRAY
68534: PUSH
68535: LD_INT 1
68537: PLUS
68538: PUSH
68539: EMPTY
68540: LIST
68541: LIST
68542: PPUSH
68543: LD_VAR 0 1
68547: PPUSH
68548: CALL 74632 0 3
68552: ST_TO_ADDR
// exit ;
68553: POP
68554: POP
68555: GO 69013
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
68557: LD_VAR 0 5
68561: PUSH
68562: LD_INT 0
68564: PUSH
68565: LD_INT 2
68567: PUSH
68568: LD_INT 4
68570: PUSH
68571: EMPTY
68572: LIST
68573: LIST
68574: LIST
68575: IN
68576: IFFALSE 68700
// begin if btype = b_armoury then
68578: LD_VAR 0 5
68582: PUSH
68583: LD_INT 4
68585: EQUAL
68586: IFFALSE 68596
// btype := b_barracks ;
68588: LD_ADDR_VAR 0 5
68592: PUSH
68593: LD_INT 5
68595: ST_TO_ADDR
// if btype = b_depot then
68596: LD_VAR 0 5
68600: PUSH
68601: LD_INT 0
68603: EQUAL
68604: IFFALSE 68614
// btype := b_warehouse ;
68606: LD_ADDR_VAR 0 5
68610: PUSH
68611: LD_INT 1
68613: ST_TO_ADDR
// if btype = b_workshop then
68614: LD_VAR 0 5
68618: PUSH
68619: LD_INT 2
68621: EQUAL
68622: IFFALSE 68632
// btype := b_factory ;
68624: LD_ADDR_VAR 0 5
68628: PUSH
68629: LD_INT 3
68631: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
68632: LD_VAR 0 5
68636: PPUSH
68637: LD_VAR 0 8
68641: PPUSH
68642: CALL_OW 323
68646: PUSH
68647: LD_INT 1
68649: EQUAL
68650: IFFALSE 68696
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
68652: LD_ADDR_EXP 134
68656: PUSH
68657: LD_EXP 134
68661: PPUSH
68662: LD_VAR 0 3
68666: PUSH
68667: LD_EXP 134
68671: PUSH
68672: LD_VAR 0 3
68676: ARRAY
68677: PUSH
68678: LD_INT 1
68680: PLUS
68681: PUSH
68682: EMPTY
68683: LIST
68684: LIST
68685: PPUSH
68686: LD_VAR 0 1
68690: PPUSH
68691: CALL 74632 0 3
68695: ST_TO_ADDR
// exit ;
68696: POP
68697: POP
68698: GO 69013
// end ; if btype in [ b_bunker , b_turret ] then
68700: LD_VAR 0 5
68704: PUSH
68705: LD_INT 32
68707: PUSH
68708: LD_INT 33
68710: PUSH
68711: EMPTY
68712: LIST
68713: LIST
68714: IN
68715: IFFALSE 69005
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
68717: LD_ADDR_EXP 110
68721: PUSH
68722: LD_EXP 110
68726: PPUSH
68727: LD_VAR 0 3
68731: PUSH
68732: LD_EXP 110
68736: PUSH
68737: LD_VAR 0 3
68741: ARRAY
68742: PUSH
68743: LD_INT 1
68745: PLUS
68746: PUSH
68747: EMPTY
68748: LIST
68749: LIST
68750: PPUSH
68751: LD_VAR 0 1
68755: PPUSH
68756: CALL 74632 0 3
68760: ST_TO_ADDR
// if btype = b_bunker then
68761: LD_VAR 0 5
68765: PUSH
68766: LD_INT 32
68768: EQUAL
68769: IFFALSE 69005
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
68771: LD_ADDR_EXP 111
68775: PUSH
68776: LD_EXP 111
68780: PPUSH
68781: LD_VAR 0 3
68785: PUSH
68786: LD_EXP 111
68790: PUSH
68791: LD_VAR 0 3
68795: ARRAY
68796: PUSH
68797: LD_INT 1
68799: PLUS
68800: PUSH
68801: EMPTY
68802: LIST
68803: LIST
68804: PPUSH
68805: LD_VAR 0 1
68809: PPUSH
68810: CALL 74632 0 3
68814: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
68815: LD_ADDR_VAR 0 6
68819: PUSH
68820: LD_EXP 102
68824: PUSH
68825: LD_VAR 0 3
68829: ARRAY
68830: PPUSH
68831: LD_INT 25
68833: PUSH
68834: LD_INT 1
68836: PUSH
68837: EMPTY
68838: LIST
68839: LIST
68840: PUSH
68841: LD_INT 3
68843: PUSH
68844: LD_INT 54
68846: PUSH
68847: EMPTY
68848: LIST
68849: PUSH
68850: EMPTY
68851: LIST
68852: LIST
68853: PUSH
68854: EMPTY
68855: LIST
68856: LIST
68857: PPUSH
68858: CALL_OW 72
68862: ST_TO_ADDR
// if tmp then
68863: LD_VAR 0 6
68867: IFFALSE 68873
// exit ;
68869: POP
68870: POP
68871: GO 69013
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
68873: LD_ADDR_VAR 0 6
68877: PUSH
68878: LD_EXP 102
68882: PUSH
68883: LD_VAR 0 3
68887: ARRAY
68888: PPUSH
68889: LD_INT 2
68891: PUSH
68892: LD_INT 30
68894: PUSH
68895: LD_INT 4
68897: PUSH
68898: EMPTY
68899: LIST
68900: LIST
68901: PUSH
68902: LD_INT 30
68904: PUSH
68905: LD_INT 5
68907: PUSH
68908: EMPTY
68909: LIST
68910: LIST
68911: PUSH
68912: EMPTY
68913: LIST
68914: LIST
68915: LIST
68916: PPUSH
68917: CALL_OW 72
68921: ST_TO_ADDR
// if not tmp then
68922: LD_VAR 0 6
68926: NOT
68927: IFFALSE 68933
// exit ;
68929: POP
68930: POP
68931: GO 69013
// for j in tmp do
68933: LD_ADDR_VAR 0 4
68937: PUSH
68938: LD_VAR 0 6
68942: PUSH
68943: FOR_IN
68944: IFFALSE 69003
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
68946: LD_ADDR_VAR 0 7
68950: PUSH
68951: LD_VAR 0 4
68955: PPUSH
68956: CALL_OW 313
68960: PPUSH
68961: LD_INT 25
68963: PUSH
68964: LD_INT 1
68966: PUSH
68967: EMPTY
68968: LIST
68969: LIST
68970: PPUSH
68971: CALL_OW 72
68975: ST_TO_ADDR
// if units then
68976: LD_VAR 0 7
68980: IFFALSE 69001
// begin ComExitBuilding ( units [ 1 ] ) ;
68982: LD_VAR 0 7
68986: PUSH
68987: LD_INT 1
68989: ARRAY
68990: PPUSH
68991: CALL_OW 122
// exit ;
68995: POP
68996: POP
68997: POP
68998: POP
68999: GO 69013
// end ; end ;
69001: GO 68943
69003: POP
69004: POP
// end ; end ; exit ;
69005: POP
69006: POP
69007: GO 69013
// end ; end ;
69009: GO 68367
69011: POP
69012: POP
// end ;
69013: LD_VAR 0 2
69017: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
69018: LD_INT 0
69020: PPUSH
69021: PPUSH
69022: PPUSH
69023: PPUSH
69024: PPUSH
69025: PPUSH
69026: PPUSH
// if not mc_bases or not skirmish then
69027: LD_EXP 102
69031: NOT
69032: PUSH
69033: LD_EXP 100
69037: NOT
69038: OR
69039: IFFALSE 69043
// exit ;
69041: GO 69308
// btype := GetBType ( building ) ;
69043: LD_ADDR_VAR 0 6
69047: PUSH
69048: LD_VAR 0 1
69052: PPUSH
69053: CALL_OW 266
69057: ST_TO_ADDR
// x := GetX ( building ) ;
69058: LD_ADDR_VAR 0 7
69062: PUSH
69063: LD_VAR 0 1
69067: PPUSH
69068: CALL_OW 250
69072: ST_TO_ADDR
// y := GetY ( building ) ;
69073: LD_ADDR_VAR 0 8
69077: PUSH
69078: LD_VAR 0 1
69082: PPUSH
69083: CALL_OW 251
69087: ST_TO_ADDR
// d := GetDir ( building ) ;
69088: LD_ADDR_VAR 0 9
69092: PUSH
69093: LD_VAR 0 1
69097: PPUSH
69098: CALL_OW 254
69102: ST_TO_ADDR
// for i = 1 to mc_bases do
69103: LD_ADDR_VAR 0 4
69107: PUSH
69108: DOUBLE
69109: LD_INT 1
69111: DEC
69112: ST_TO_ADDR
69113: LD_EXP 102
69117: PUSH
69118: FOR_TO
69119: IFFALSE 69306
// begin if not mc_build_list [ i ] then
69121: LD_EXP 107
69125: PUSH
69126: LD_VAR 0 4
69130: ARRAY
69131: NOT
69132: IFFALSE 69136
// continue ;
69134: GO 69118
// for j := 1 to mc_build_list [ i ] do
69136: LD_ADDR_VAR 0 5
69140: PUSH
69141: DOUBLE
69142: LD_INT 1
69144: DEC
69145: ST_TO_ADDR
69146: LD_EXP 107
69150: PUSH
69151: LD_VAR 0 4
69155: ARRAY
69156: PUSH
69157: FOR_TO
69158: IFFALSE 69302
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
69160: LD_VAR 0 6
69164: PUSH
69165: LD_VAR 0 7
69169: PUSH
69170: LD_VAR 0 8
69174: PUSH
69175: LD_VAR 0 9
69179: PUSH
69180: EMPTY
69181: LIST
69182: LIST
69183: LIST
69184: LIST
69185: PPUSH
69186: LD_EXP 107
69190: PUSH
69191: LD_VAR 0 4
69195: ARRAY
69196: PUSH
69197: LD_VAR 0 5
69201: ARRAY
69202: PPUSH
69203: CALL 81189 0 2
69207: IFFALSE 69300
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
69209: LD_ADDR_EXP 107
69213: PUSH
69214: LD_EXP 107
69218: PPUSH
69219: LD_VAR 0 4
69223: PPUSH
69224: LD_EXP 107
69228: PUSH
69229: LD_VAR 0 4
69233: ARRAY
69234: PPUSH
69235: LD_VAR 0 5
69239: PPUSH
69240: CALL_OW 3
69244: PPUSH
69245: CALL_OW 1
69249: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
69250: LD_ADDR_EXP 109
69254: PUSH
69255: LD_EXP 109
69259: PPUSH
69260: LD_VAR 0 4
69264: PUSH
69265: LD_EXP 109
69269: PUSH
69270: LD_VAR 0 4
69274: ARRAY
69275: PUSH
69276: LD_INT 1
69278: PLUS
69279: PUSH
69280: EMPTY
69281: LIST
69282: LIST
69283: PPUSH
69284: LD_VAR 0 1
69288: PPUSH
69289: CALL 74632 0 3
69293: ST_TO_ADDR
// exit ;
69294: POP
69295: POP
69296: POP
69297: POP
69298: GO 69308
// end ;
69300: GO 69157
69302: POP
69303: POP
// end ;
69304: GO 69118
69306: POP
69307: POP
// end ;
69308: LD_VAR 0 3
69312: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
69313: LD_INT 0
69315: PPUSH
69316: PPUSH
69317: PPUSH
// if not mc_bases or not skirmish then
69318: LD_EXP 102
69322: NOT
69323: PUSH
69324: LD_EXP 100
69328: NOT
69329: OR
69330: IFFALSE 69334
// exit ;
69332: GO 69524
// for i = 1 to mc_bases do
69334: LD_ADDR_VAR 0 4
69338: PUSH
69339: DOUBLE
69340: LD_INT 1
69342: DEC
69343: ST_TO_ADDR
69344: LD_EXP 102
69348: PUSH
69349: FOR_TO
69350: IFFALSE 69437
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
69352: LD_VAR 0 1
69356: PUSH
69357: LD_EXP 110
69361: PUSH
69362: LD_VAR 0 4
69366: ARRAY
69367: IN
69368: PUSH
69369: LD_VAR 0 1
69373: PUSH
69374: LD_EXP 111
69378: PUSH
69379: LD_VAR 0 4
69383: ARRAY
69384: IN
69385: NOT
69386: AND
69387: IFFALSE 69435
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
69389: LD_ADDR_EXP 111
69393: PUSH
69394: LD_EXP 111
69398: PPUSH
69399: LD_VAR 0 4
69403: PUSH
69404: LD_EXP 111
69408: PUSH
69409: LD_VAR 0 4
69413: ARRAY
69414: PUSH
69415: LD_INT 1
69417: PLUS
69418: PUSH
69419: EMPTY
69420: LIST
69421: LIST
69422: PPUSH
69423: LD_VAR 0 1
69427: PPUSH
69428: CALL 74632 0 3
69432: ST_TO_ADDR
// break ;
69433: GO 69437
// end ; end ;
69435: GO 69349
69437: POP
69438: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
69439: LD_VAR 0 1
69443: PPUSH
69444: CALL_OW 257
69448: PUSH
69449: LD_EXP 128
69453: IN
69454: PUSH
69455: LD_VAR 0 1
69459: PPUSH
69460: CALL_OW 266
69464: PUSH
69465: LD_INT 5
69467: EQUAL
69468: AND
69469: PUSH
69470: LD_VAR 0 2
69474: PPUSH
69475: CALL_OW 110
69479: PUSH
69480: LD_INT 18
69482: NONEQUAL
69483: AND
69484: IFFALSE 69524
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
69486: LD_VAR 0 2
69490: PPUSH
69491: CALL_OW 257
69495: PUSH
69496: LD_INT 5
69498: PUSH
69499: LD_INT 8
69501: PUSH
69502: LD_INT 9
69504: PUSH
69505: EMPTY
69506: LIST
69507: LIST
69508: LIST
69509: IN
69510: IFFALSE 69524
// SetClass ( unit , 1 ) ;
69512: LD_VAR 0 2
69516: PPUSH
69517: LD_INT 1
69519: PPUSH
69520: CALL_OW 336
// end ;
69524: LD_VAR 0 3
69528: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
69529: LD_INT 0
69531: PPUSH
69532: PPUSH
// if not mc_bases or not skirmish then
69533: LD_EXP 102
69537: NOT
69538: PUSH
69539: LD_EXP 100
69543: NOT
69544: OR
69545: IFFALSE 69549
// exit ;
69547: GO 69665
// if GetLives ( abandoned_vehicle ) > 250 then
69549: LD_VAR 0 2
69553: PPUSH
69554: CALL_OW 256
69558: PUSH
69559: LD_INT 250
69561: GREATER
69562: IFFALSE 69566
// exit ;
69564: GO 69665
// for i = 1 to mc_bases do
69566: LD_ADDR_VAR 0 6
69570: PUSH
69571: DOUBLE
69572: LD_INT 1
69574: DEC
69575: ST_TO_ADDR
69576: LD_EXP 102
69580: PUSH
69581: FOR_TO
69582: IFFALSE 69663
// begin if driver in mc_bases [ i ] then
69584: LD_VAR 0 1
69588: PUSH
69589: LD_EXP 102
69593: PUSH
69594: LD_VAR 0 6
69598: ARRAY
69599: IN
69600: IFFALSE 69661
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
69602: LD_VAR 0 1
69606: PPUSH
69607: LD_EXP 102
69611: PUSH
69612: LD_VAR 0 6
69616: ARRAY
69617: PPUSH
69618: LD_INT 2
69620: PUSH
69621: LD_INT 30
69623: PUSH
69624: LD_INT 0
69626: PUSH
69627: EMPTY
69628: LIST
69629: LIST
69630: PUSH
69631: LD_INT 30
69633: PUSH
69634: LD_INT 1
69636: PUSH
69637: EMPTY
69638: LIST
69639: LIST
69640: PUSH
69641: EMPTY
69642: LIST
69643: LIST
69644: LIST
69645: PPUSH
69646: CALL_OW 72
69650: PUSH
69651: LD_INT 1
69653: ARRAY
69654: PPUSH
69655: CALL 108238 0 2
// break ;
69659: GO 69663
// end ; end ;
69661: GO 69581
69663: POP
69664: POP
// end ; end_of_file
69665: LD_VAR 0 5
69669: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
69670: LD_INT 0
69672: PPUSH
69673: PPUSH
// if exist_mode then
69674: LD_VAR 0 2
69678: IFFALSE 69703
// unit := CreateCharacter ( prefix & ident ) else
69680: LD_ADDR_VAR 0 5
69684: PUSH
69685: LD_VAR 0 3
69689: PUSH
69690: LD_VAR 0 1
69694: STR
69695: PPUSH
69696: CALL_OW 34
69700: ST_TO_ADDR
69701: GO 69718
// unit := NewCharacter ( ident ) ;
69703: LD_ADDR_VAR 0 5
69707: PUSH
69708: LD_VAR 0 1
69712: PPUSH
69713: CALL_OW 25
69717: ST_TO_ADDR
// result := unit ;
69718: LD_ADDR_VAR 0 4
69722: PUSH
69723: LD_VAR 0 5
69727: ST_TO_ADDR
// end ;
69728: LD_VAR 0 4
69732: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
69733: LD_INT 0
69735: PPUSH
69736: PPUSH
// if not side or not nation then
69737: LD_VAR 0 1
69741: NOT
69742: PUSH
69743: LD_VAR 0 2
69747: NOT
69748: OR
69749: IFFALSE 69753
// exit ;
69751: GO 70521
// case nation of nation_american :
69753: LD_VAR 0 2
69757: PUSH
69758: LD_INT 1
69760: DOUBLE
69761: EQUAL
69762: IFTRUE 69766
69764: GO 69980
69766: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
69767: LD_ADDR_VAR 0 4
69771: PUSH
69772: LD_INT 35
69774: PUSH
69775: LD_INT 45
69777: PUSH
69778: LD_INT 46
69780: PUSH
69781: LD_INT 47
69783: PUSH
69784: LD_INT 82
69786: PUSH
69787: LD_INT 83
69789: PUSH
69790: LD_INT 84
69792: PUSH
69793: LD_INT 85
69795: PUSH
69796: LD_INT 86
69798: PUSH
69799: LD_INT 1
69801: PUSH
69802: LD_INT 2
69804: PUSH
69805: LD_INT 6
69807: PUSH
69808: LD_INT 15
69810: PUSH
69811: LD_INT 16
69813: PUSH
69814: LD_INT 7
69816: PUSH
69817: LD_INT 12
69819: PUSH
69820: LD_INT 13
69822: PUSH
69823: LD_INT 10
69825: PUSH
69826: LD_INT 14
69828: PUSH
69829: LD_INT 20
69831: PUSH
69832: LD_INT 21
69834: PUSH
69835: LD_INT 22
69837: PUSH
69838: LD_INT 25
69840: PUSH
69841: LD_INT 32
69843: PUSH
69844: LD_INT 27
69846: PUSH
69847: LD_INT 36
69849: PUSH
69850: LD_INT 69
69852: PUSH
69853: LD_INT 39
69855: PUSH
69856: LD_INT 34
69858: PUSH
69859: LD_INT 40
69861: PUSH
69862: LD_INT 48
69864: PUSH
69865: LD_INT 49
69867: PUSH
69868: LD_INT 50
69870: PUSH
69871: LD_INT 51
69873: PUSH
69874: LD_INT 52
69876: PUSH
69877: LD_INT 53
69879: PUSH
69880: LD_INT 54
69882: PUSH
69883: LD_INT 55
69885: PUSH
69886: LD_INT 56
69888: PUSH
69889: LD_INT 57
69891: PUSH
69892: LD_INT 58
69894: PUSH
69895: LD_INT 59
69897: PUSH
69898: LD_INT 60
69900: PUSH
69901: LD_INT 61
69903: PUSH
69904: LD_INT 62
69906: PUSH
69907: LD_INT 80
69909: PUSH
69910: LD_INT 82
69912: PUSH
69913: LD_INT 83
69915: PUSH
69916: LD_INT 84
69918: PUSH
69919: LD_INT 85
69921: PUSH
69922: LD_INT 86
69924: PUSH
69925: EMPTY
69926: LIST
69927: LIST
69928: LIST
69929: LIST
69930: LIST
69931: LIST
69932: LIST
69933: LIST
69934: LIST
69935: LIST
69936: LIST
69937: LIST
69938: LIST
69939: LIST
69940: LIST
69941: LIST
69942: LIST
69943: LIST
69944: LIST
69945: LIST
69946: LIST
69947: LIST
69948: LIST
69949: LIST
69950: LIST
69951: LIST
69952: LIST
69953: LIST
69954: LIST
69955: LIST
69956: LIST
69957: LIST
69958: LIST
69959: LIST
69960: LIST
69961: LIST
69962: LIST
69963: LIST
69964: LIST
69965: LIST
69966: LIST
69967: LIST
69968: LIST
69969: LIST
69970: LIST
69971: LIST
69972: LIST
69973: LIST
69974: LIST
69975: LIST
69976: LIST
69977: ST_TO_ADDR
69978: GO 70445
69980: LD_INT 2
69982: DOUBLE
69983: EQUAL
69984: IFTRUE 69988
69986: GO 70214
69988: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
69989: LD_ADDR_VAR 0 4
69993: PUSH
69994: LD_INT 35
69996: PUSH
69997: LD_INT 45
69999: PUSH
70000: LD_INT 46
70002: PUSH
70003: LD_INT 47
70005: PUSH
70006: LD_INT 82
70008: PUSH
70009: LD_INT 83
70011: PUSH
70012: LD_INT 84
70014: PUSH
70015: LD_INT 85
70017: PUSH
70018: LD_INT 87
70020: PUSH
70021: LD_INT 70
70023: PUSH
70024: LD_INT 1
70026: PUSH
70027: LD_INT 11
70029: PUSH
70030: LD_INT 3
70032: PUSH
70033: LD_INT 4
70035: PUSH
70036: LD_INT 5
70038: PUSH
70039: LD_INT 6
70041: PUSH
70042: LD_INT 15
70044: PUSH
70045: LD_INT 18
70047: PUSH
70048: LD_INT 7
70050: PUSH
70051: LD_INT 17
70053: PUSH
70054: LD_INT 8
70056: PUSH
70057: LD_INT 20
70059: PUSH
70060: LD_INT 21
70062: PUSH
70063: LD_INT 22
70065: PUSH
70066: LD_INT 72
70068: PUSH
70069: LD_INT 26
70071: PUSH
70072: LD_INT 69
70074: PUSH
70075: LD_INT 39
70077: PUSH
70078: LD_INT 40
70080: PUSH
70081: LD_INT 41
70083: PUSH
70084: LD_INT 42
70086: PUSH
70087: LD_INT 43
70089: PUSH
70090: LD_INT 48
70092: PUSH
70093: LD_INT 49
70095: PUSH
70096: LD_INT 50
70098: PUSH
70099: LD_INT 51
70101: PUSH
70102: LD_INT 52
70104: PUSH
70105: LD_INT 53
70107: PUSH
70108: LD_INT 54
70110: PUSH
70111: LD_INT 55
70113: PUSH
70114: LD_INT 56
70116: PUSH
70117: LD_INT 60
70119: PUSH
70120: LD_INT 61
70122: PUSH
70123: LD_INT 62
70125: PUSH
70126: LD_INT 66
70128: PUSH
70129: LD_INT 67
70131: PUSH
70132: LD_INT 68
70134: PUSH
70135: LD_INT 81
70137: PUSH
70138: LD_INT 82
70140: PUSH
70141: LD_INT 83
70143: PUSH
70144: LD_INT 84
70146: PUSH
70147: LD_INT 85
70149: PUSH
70150: LD_INT 87
70152: PUSH
70153: LD_INT 88
70155: PUSH
70156: EMPTY
70157: LIST
70158: LIST
70159: LIST
70160: LIST
70161: LIST
70162: LIST
70163: LIST
70164: LIST
70165: LIST
70166: LIST
70167: LIST
70168: LIST
70169: LIST
70170: LIST
70171: LIST
70172: LIST
70173: LIST
70174: LIST
70175: LIST
70176: LIST
70177: LIST
70178: LIST
70179: LIST
70180: LIST
70181: LIST
70182: LIST
70183: LIST
70184: LIST
70185: LIST
70186: LIST
70187: LIST
70188: LIST
70189: LIST
70190: LIST
70191: LIST
70192: LIST
70193: LIST
70194: LIST
70195: LIST
70196: LIST
70197: LIST
70198: LIST
70199: LIST
70200: LIST
70201: LIST
70202: LIST
70203: LIST
70204: LIST
70205: LIST
70206: LIST
70207: LIST
70208: LIST
70209: LIST
70210: LIST
70211: ST_TO_ADDR
70212: GO 70445
70214: LD_INT 3
70216: DOUBLE
70217: EQUAL
70218: IFTRUE 70222
70220: GO 70444
70222: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
70223: LD_ADDR_VAR 0 4
70227: PUSH
70228: LD_INT 46
70230: PUSH
70231: LD_INT 47
70233: PUSH
70234: LD_INT 1
70236: PUSH
70237: LD_INT 2
70239: PUSH
70240: LD_INT 82
70242: PUSH
70243: LD_INT 83
70245: PUSH
70246: LD_INT 84
70248: PUSH
70249: LD_INT 85
70251: PUSH
70252: LD_INT 86
70254: PUSH
70255: LD_INT 11
70257: PUSH
70258: LD_INT 9
70260: PUSH
70261: LD_INT 20
70263: PUSH
70264: LD_INT 19
70266: PUSH
70267: LD_INT 21
70269: PUSH
70270: LD_INT 24
70272: PUSH
70273: LD_INT 22
70275: PUSH
70276: LD_INT 25
70278: PUSH
70279: LD_INT 28
70281: PUSH
70282: LD_INT 29
70284: PUSH
70285: LD_INT 30
70287: PUSH
70288: LD_INT 31
70290: PUSH
70291: LD_INT 37
70293: PUSH
70294: LD_INT 38
70296: PUSH
70297: LD_INT 32
70299: PUSH
70300: LD_INT 27
70302: PUSH
70303: LD_INT 33
70305: PUSH
70306: LD_INT 69
70308: PUSH
70309: LD_INT 39
70311: PUSH
70312: LD_INT 34
70314: PUSH
70315: LD_INT 40
70317: PUSH
70318: LD_INT 71
70320: PUSH
70321: LD_INT 23
70323: PUSH
70324: LD_INT 44
70326: PUSH
70327: LD_INT 48
70329: PUSH
70330: LD_INT 49
70332: PUSH
70333: LD_INT 50
70335: PUSH
70336: LD_INT 51
70338: PUSH
70339: LD_INT 52
70341: PUSH
70342: LD_INT 53
70344: PUSH
70345: LD_INT 54
70347: PUSH
70348: LD_INT 55
70350: PUSH
70351: LD_INT 56
70353: PUSH
70354: LD_INT 57
70356: PUSH
70357: LD_INT 58
70359: PUSH
70360: LD_INT 59
70362: PUSH
70363: LD_INT 63
70365: PUSH
70366: LD_INT 64
70368: PUSH
70369: LD_INT 65
70371: PUSH
70372: LD_INT 82
70374: PUSH
70375: LD_INT 83
70377: PUSH
70378: LD_INT 84
70380: PUSH
70381: LD_INT 85
70383: PUSH
70384: LD_INT 86
70386: PUSH
70387: EMPTY
70388: LIST
70389: LIST
70390: LIST
70391: LIST
70392: LIST
70393: LIST
70394: LIST
70395: LIST
70396: LIST
70397: LIST
70398: LIST
70399: LIST
70400: LIST
70401: LIST
70402: LIST
70403: LIST
70404: LIST
70405: LIST
70406: LIST
70407: LIST
70408: LIST
70409: LIST
70410: LIST
70411: LIST
70412: LIST
70413: LIST
70414: LIST
70415: LIST
70416: LIST
70417: LIST
70418: LIST
70419: LIST
70420: LIST
70421: LIST
70422: LIST
70423: LIST
70424: LIST
70425: LIST
70426: LIST
70427: LIST
70428: LIST
70429: LIST
70430: LIST
70431: LIST
70432: LIST
70433: LIST
70434: LIST
70435: LIST
70436: LIST
70437: LIST
70438: LIST
70439: LIST
70440: LIST
70441: ST_TO_ADDR
70442: GO 70445
70444: POP
// if state > - 1 and state < 3 then
70445: LD_VAR 0 3
70449: PUSH
70450: LD_INT 1
70452: NEG
70453: GREATER
70454: PUSH
70455: LD_VAR 0 3
70459: PUSH
70460: LD_INT 3
70462: LESS
70463: AND
70464: IFFALSE 70521
// for i in result do
70466: LD_ADDR_VAR 0 5
70470: PUSH
70471: LD_VAR 0 4
70475: PUSH
70476: FOR_IN
70477: IFFALSE 70519
// if GetTech ( i , side ) <> state then
70479: LD_VAR 0 5
70483: PPUSH
70484: LD_VAR 0 1
70488: PPUSH
70489: CALL_OW 321
70493: PUSH
70494: LD_VAR 0 3
70498: NONEQUAL
70499: IFFALSE 70517
// result := result diff i ;
70501: LD_ADDR_VAR 0 4
70505: PUSH
70506: LD_VAR 0 4
70510: PUSH
70511: LD_VAR 0 5
70515: DIFF
70516: ST_TO_ADDR
70517: GO 70476
70519: POP
70520: POP
// end ;
70521: LD_VAR 0 4
70525: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
70526: LD_INT 0
70528: PPUSH
70529: PPUSH
70530: PPUSH
// result := true ;
70531: LD_ADDR_VAR 0 3
70535: PUSH
70536: LD_INT 1
70538: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
70539: LD_ADDR_VAR 0 5
70543: PUSH
70544: LD_VAR 0 2
70548: PPUSH
70549: CALL_OW 480
70553: ST_TO_ADDR
// if not tmp then
70554: LD_VAR 0 5
70558: NOT
70559: IFFALSE 70563
// exit ;
70561: GO 70612
// for i in tmp do
70563: LD_ADDR_VAR 0 4
70567: PUSH
70568: LD_VAR 0 5
70572: PUSH
70573: FOR_IN
70574: IFFALSE 70610
// if GetTech ( i , side ) <> state_researched then
70576: LD_VAR 0 4
70580: PPUSH
70581: LD_VAR 0 1
70585: PPUSH
70586: CALL_OW 321
70590: PUSH
70591: LD_INT 2
70593: NONEQUAL
70594: IFFALSE 70608
// begin result := false ;
70596: LD_ADDR_VAR 0 3
70600: PUSH
70601: LD_INT 0
70603: ST_TO_ADDR
// exit ;
70604: POP
70605: POP
70606: GO 70612
// end ;
70608: GO 70573
70610: POP
70611: POP
// end ;
70612: LD_VAR 0 3
70616: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
70617: LD_INT 0
70619: PPUSH
70620: PPUSH
70621: PPUSH
70622: PPUSH
70623: PPUSH
70624: PPUSH
70625: PPUSH
70626: PPUSH
70627: PPUSH
70628: PPUSH
70629: PPUSH
70630: PPUSH
70631: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
70632: LD_VAR 0 1
70636: NOT
70637: PUSH
70638: LD_VAR 0 1
70642: PPUSH
70643: CALL_OW 257
70647: PUSH
70648: LD_INT 9
70650: NONEQUAL
70651: OR
70652: IFFALSE 70656
// exit ;
70654: GO 71229
// side := GetSide ( unit ) ;
70656: LD_ADDR_VAR 0 9
70660: PUSH
70661: LD_VAR 0 1
70665: PPUSH
70666: CALL_OW 255
70670: ST_TO_ADDR
// tech_space := tech_spacanom ;
70671: LD_ADDR_VAR 0 12
70675: PUSH
70676: LD_INT 29
70678: ST_TO_ADDR
// tech_time := tech_taurad ;
70679: LD_ADDR_VAR 0 13
70683: PUSH
70684: LD_INT 28
70686: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
70687: LD_ADDR_VAR 0 11
70691: PUSH
70692: LD_VAR 0 1
70696: PPUSH
70697: CALL_OW 310
70701: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
70702: LD_VAR 0 11
70706: PPUSH
70707: CALL_OW 247
70711: PUSH
70712: LD_INT 2
70714: EQUAL
70715: IFFALSE 70719
// exit ;
70717: GO 71229
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
70719: LD_ADDR_VAR 0 8
70723: PUSH
70724: LD_INT 81
70726: PUSH
70727: LD_VAR 0 9
70731: PUSH
70732: EMPTY
70733: LIST
70734: LIST
70735: PUSH
70736: LD_INT 3
70738: PUSH
70739: LD_INT 21
70741: PUSH
70742: LD_INT 3
70744: PUSH
70745: EMPTY
70746: LIST
70747: LIST
70748: PUSH
70749: EMPTY
70750: LIST
70751: LIST
70752: PUSH
70753: EMPTY
70754: LIST
70755: LIST
70756: PPUSH
70757: CALL_OW 69
70761: ST_TO_ADDR
// if not tmp then
70762: LD_VAR 0 8
70766: NOT
70767: IFFALSE 70771
// exit ;
70769: GO 71229
// if in_unit then
70771: LD_VAR 0 11
70775: IFFALSE 70799
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
70777: LD_ADDR_VAR 0 10
70781: PUSH
70782: LD_VAR 0 8
70786: PPUSH
70787: LD_VAR 0 11
70791: PPUSH
70792: CALL_OW 74
70796: ST_TO_ADDR
70797: GO 70819
// enemy := NearestUnitToUnit ( tmp , unit ) ;
70799: LD_ADDR_VAR 0 10
70803: PUSH
70804: LD_VAR 0 8
70808: PPUSH
70809: LD_VAR 0 1
70813: PPUSH
70814: CALL_OW 74
70818: ST_TO_ADDR
// if not enemy then
70819: LD_VAR 0 10
70823: NOT
70824: IFFALSE 70828
// exit ;
70826: GO 71229
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
70828: LD_VAR 0 11
70832: PUSH
70833: LD_VAR 0 11
70837: PPUSH
70838: LD_VAR 0 10
70842: PPUSH
70843: CALL_OW 296
70847: PUSH
70848: LD_INT 13
70850: GREATER
70851: AND
70852: PUSH
70853: LD_VAR 0 1
70857: PPUSH
70858: LD_VAR 0 10
70862: PPUSH
70863: CALL_OW 296
70867: PUSH
70868: LD_INT 12
70870: GREATER
70871: OR
70872: IFFALSE 70876
// exit ;
70874: GO 71229
// missile := [ 1 ] ;
70876: LD_ADDR_VAR 0 14
70880: PUSH
70881: LD_INT 1
70883: PUSH
70884: EMPTY
70885: LIST
70886: ST_TO_ADDR
// if Researched ( side , tech_space ) then
70887: LD_VAR 0 9
70891: PPUSH
70892: LD_VAR 0 12
70896: PPUSH
70897: CALL_OW 325
70901: IFFALSE 70930
// missile := Replace ( missile , missile + 1 , 2 ) ;
70903: LD_ADDR_VAR 0 14
70907: PUSH
70908: LD_VAR 0 14
70912: PPUSH
70913: LD_VAR 0 14
70917: PUSH
70918: LD_INT 1
70920: PLUS
70921: PPUSH
70922: LD_INT 2
70924: PPUSH
70925: CALL_OW 1
70929: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
70930: LD_VAR 0 9
70934: PPUSH
70935: LD_VAR 0 13
70939: PPUSH
70940: CALL_OW 325
70944: PUSH
70945: LD_VAR 0 10
70949: PPUSH
70950: CALL_OW 255
70954: PPUSH
70955: LD_VAR 0 13
70959: PPUSH
70960: CALL_OW 325
70964: NOT
70965: AND
70966: IFFALSE 70995
// missile := Replace ( missile , missile + 1 , 3 ) ;
70968: LD_ADDR_VAR 0 14
70972: PUSH
70973: LD_VAR 0 14
70977: PPUSH
70978: LD_VAR 0 14
70982: PUSH
70983: LD_INT 1
70985: PLUS
70986: PPUSH
70987: LD_INT 3
70989: PPUSH
70990: CALL_OW 1
70994: ST_TO_ADDR
// if missile < 2 then
70995: LD_VAR 0 14
70999: PUSH
71000: LD_INT 2
71002: LESS
71003: IFFALSE 71007
// exit ;
71005: GO 71229
// x := GetX ( enemy ) ;
71007: LD_ADDR_VAR 0 4
71011: PUSH
71012: LD_VAR 0 10
71016: PPUSH
71017: CALL_OW 250
71021: ST_TO_ADDR
// y := GetY ( enemy ) ;
71022: LD_ADDR_VAR 0 5
71026: PUSH
71027: LD_VAR 0 10
71031: PPUSH
71032: CALL_OW 251
71036: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
71037: LD_ADDR_VAR 0 6
71041: PUSH
71042: LD_VAR 0 4
71046: PUSH
71047: LD_INT 1
71049: NEG
71050: PPUSH
71051: LD_INT 1
71053: PPUSH
71054: CALL_OW 12
71058: PLUS
71059: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
71060: LD_ADDR_VAR 0 7
71064: PUSH
71065: LD_VAR 0 5
71069: PUSH
71070: LD_INT 1
71072: NEG
71073: PPUSH
71074: LD_INT 1
71076: PPUSH
71077: CALL_OW 12
71081: PLUS
71082: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
71083: LD_VAR 0 6
71087: PPUSH
71088: LD_VAR 0 7
71092: PPUSH
71093: CALL_OW 488
71097: NOT
71098: IFFALSE 71120
// begin _x := x ;
71100: LD_ADDR_VAR 0 6
71104: PUSH
71105: LD_VAR 0 4
71109: ST_TO_ADDR
// _y := y ;
71110: LD_ADDR_VAR 0 7
71114: PUSH
71115: LD_VAR 0 5
71119: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
71120: LD_ADDR_VAR 0 3
71124: PUSH
71125: LD_INT 1
71127: PPUSH
71128: LD_VAR 0 14
71132: PPUSH
71133: CALL_OW 12
71137: ST_TO_ADDR
// case i of 1 :
71138: LD_VAR 0 3
71142: PUSH
71143: LD_INT 1
71145: DOUBLE
71146: EQUAL
71147: IFTRUE 71151
71149: GO 71168
71151: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
71152: LD_VAR 0 1
71156: PPUSH
71157: LD_VAR 0 10
71161: PPUSH
71162: CALL_OW 115
71166: GO 71229
71168: LD_INT 2
71170: DOUBLE
71171: EQUAL
71172: IFTRUE 71176
71174: GO 71198
71176: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
71177: LD_VAR 0 1
71181: PPUSH
71182: LD_VAR 0 6
71186: PPUSH
71187: LD_VAR 0 7
71191: PPUSH
71192: CALL_OW 153
71196: GO 71229
71198: LD_INT 3
71200: DOUBLE
71201: EQUAL
71202: IFTRUE 71206
71204: GO 71228
71206: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
71207: LD_VAR 0 1
71211: PPUSH
71212: LD_VAR 0 6
71216: PPUSH
71217: LD_VAR 0 7
71221: PPUSH
71222: CALL_OW 154
71226: GO 71229
71228: POP
// end ;
71229: LD_VAR 0 2
71233: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
71234: LD_INT 0
71236: PPUSH
71237: PPUSH
71238: PPUSH
71239: PPUSH
71240: PPUSH
71241: PPUSH
// if not unit or not building then
71242: LD_VAR 0 1
71246: NOT
71247: PUSH
71248: LD_VAR 0 2
71252: NOT
71253: OR
71254: IFFALSE 71258
// exit ;
71256: GO 71416
// x := GetX ( building ) ;
71258: LD_ADDR_VAR 0 5
71262: PUSH
71263: LD_VAR 0 2
71267: PPUSH
71268: CALL_OW 250
71272: ST_TO_ADDR
// y := GetY ( building ) ;
71273: LD_ADDR_VAR 0 6
71277: PUSH
71278: LD_VAR 0 2
71282: PPUSH
71283: CALL_OW 251
71287: ST_TO_ADDR
// for i = 0 to 5 do
71288: LD_ADDR_VAR 0 4
71292: PUSH
71293: DOUBLE
71294: LD_INT 0
71296: DEC
71297: ST_TO_ADDR
71298: LD_INT 5
71300: PUSH
71301: FOR_TO
71302: IFFALSE 71414
// begin _x := ShiftX ( x , i , 3 ) ;
71304: LD_ADDR_VAR 0 7
71308: PUSH
71309: LD_VAR 0 5
71313: PPUSH
71314: LD_VAR 0 4
71318: PPUSH
71319: LD_INT 3
71321: PPUSH
71322: CALL_OW 272
71326: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
71327: LD_ADDR_VAR 0 8
71331: PUSH
71332: LD_VAR 0 6
71336: PPUSH
71337: LD_VAR 0 4
71341: PPUSH
71342: LD_INT 3
71344: PPUSH
71345: CALL_OW 273
71349: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
71350: LD_VAR 0 7
71354: PPUSH
71355: LD_VAR 0 8
71359: PPUSH
71360: CALL_OW 488
71364: NOT
71365: IFFALSE 71369
// continue ;
71367: GO 71301
// if HexInfo ( _x , _y ) = 0 then
71369: LD_VAR 0 7
71373: PPUSH
71374: LD_VAR 0 8
71378: PPUSH
71379: CALL_OW 428
71383: PUSH
71384: LD_INT 0
71386: EQUAL
71387: IFFALSE 71412
// begin ComMoveXY ( unit , _x , _y ) ;
71389: LD_VAR 0 1
71393: PPUSH
71394: LD_VAR 0 7
71398: PPUSH
71399: LD_VAR 0 8
71403: PPUSH
71404: CALL_OW 111
// exit ;
71408: POP
71409: POP
71410: GO 71416
// end ; end ;
71412: GO 71301
71414: POP
71415: POP
// end ;
71416: LD_VAR 0 3
71420: RET
// export function ScanBase ( side , base_area ) ; begin
71421: LD_INT 0
71423: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
71424: LD_ADDR_VAR 0 3
71428: PUSH
71429: LD_VAR 0 2
71433: PPUSH
71434: LD_INT 81
71436: PUSH
71437: LD_VAR 0 1
71441: PUSH
71442: EMPTY
71443: LIST
71444: LIST
71445: PPUSH
71446: CALL_OW 70
71450: ST_TO_ADDR
// end ;
71451: LD_VAR 0 3
71455: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
71456: LD_INT 0
71458: PPUSH
71459: PPUSH
71460: PPUSH
71461: PPUSH
// result := false ;
71462: LD_ADDR_VAR 0 2
71466: PUSH
71467: LD_INT 0
71469: ST_TO_ADDR
// side := GetSide ( unit ) ;
71470: LD_ADDR_VAR 0 3
71474: PUSH
71475: LD_VAR 0 1
71479: PPUSH
71480: CALL_OW 255
71484: ST_TO_ADDR
// nat := GetNation ( unit ) ;
71485: LD_ADDR_VAR 0 4
71489: PUSH
71490: LD_VAR 0 1
71494: PPUSH
71495: CALL_OW 248
71499: ST_TO_ADDR
// case nat of 1 :
71500: LD_VAR 0 4
71504: PUSH
71505: LD_INT 1
71507: DOUBLE
71508: EQUAL
71509: IFTRUE 71513
71511: GO 71524
71513: POP
// tech := tech_lassight ; 2 :
71514: LD_ADDR_VAR 0 5
71518: PUSH
71519: LD_INT 12
71521: ST_TO_ADDR
71522: GO 71563
71524: LD_INT 2
71526: DOUBLE
71527: EQUAL
71528: IFTRUE 71532
71530: GO 71543
71532: POP
// tech := tech_mortar ; 3 :
71533: LD_ADDR_VAR 0 5
71537: PUSH
71538: LD_INT 41
71540: ST_TO_ADDR
71541: GO 71563
71543: LD_INT 3
71545: DOUBLE
71546: EQUAL
71547: IFTRUE 71551
71549: GO 71562
71551: POP
// tech := tech_bazooka ; end ;
71552: LD_ADDR_VAR 0 5
71556: PUSH
71557: LD_INT 44
71559: ST_TO_ADDR
71560: GO 71563
71562: POP
// if Researched ( side , tech ) then
71563: LD_VAR 0 3
71567: PPUSH
71568: LD_VAR 0 5
71572: PPUSH
71573: CALL_OW 325
71577: IFFALSE 71604
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
71579: LD_ADDR_VAR 0 2
71583: PUSH
71584: LD_INT 5
71586: PUSH
71587: LD_INT 8
71589: PUSH
71590: LD_INT 9
71592: PUSH
71593: EMPTY
71594: LIST
71595: LIST
71596: LIST
71597: PUSH
71598: LD_VAR 0 4
71602: ARRAY
71603: ST_TO_ADDR
// end ;
71604: LD_VAR 0 2
71608: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
71609: LD_INT 0
71611: PPUSH
71612: PPUSH
71613: PPUSH
// if not mines then
71614: LD_VAR 0 2
71618: NOT
71619: IFFALSE 71623
// exit ;
71621: GO 71767
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71623: LD_ADDR_VAR 0 5
71627: PUSH
71628: LD_INT 81
71630: PUSH
71631: LD_VAR 0 1
71635: PUSH
71636: EMPTY
71637: LIST
71638: LIST
71639: PUSH
71640: LD_INT 3
71642: PUSH
71643: LD_INT 21
71645: PUSH
71646: LD_INT 3
71648: PUSH
71649: EMPTY
71650: LIST
71651: LIST
71652: PUSH
71653: EMPTY
71654: LIST
71655: LIST
71656: PUSH
71657: EMPTY
71658: LIST
71659: LIST
71660: PPUSH
71661: CALL_OW 69
71665: ST_TO_ADDR
// for i in mines do
71666: LD_ADDR_VAR 0 4
71670: PUSH
71671: LD_VAR 0 2
71675: PUSH
71676: FOR_IN
71677: IFFALSE 71765
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
71679: LD_VAR 0 4
71683: PUSH
71684: LD_INT 1
71686: ARRAY
71687: PPUSH
71688: LD_VAR 0 4
71692: PUSH
71693: LD_INT 2
71695: ARRAY
71696: PPUSH
71697: CALL_OW 458
71701: NOT
71702: IFFALSE 71706
// continue ;
71704: GO 71676
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
71706: LD_VAR 0 4
71710: PUSH
71711: LD_INT 1
71713: ARRAY
71714: PPUSH
71715: LD_VAR 0 4
71719: PUSH
71720: LD_INT 2
71722: ARRAY
71723: PPUSH
71724: CALL_OW 428
71728: PUSH
71729: LD_VAR 0 5
71733: IN
71734: IFFALSE 71763
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
71736: LD_VAR 0 4
71740: PUSH
71741: LD_INT 1
71743: ARRAY
71744: PPUSH
71745: LD_VAR 0 4
71749: PUSH
71750: LD_INT 2
71752: ARRAY
71753: PPUSH
71754: LD_VAR 0 1
71758: PPUSH
71759: CALL_OW 456
// end ;
71763: GO 71676
71765: POP
71766: POP
// end ;
71767: LD_VAR 0 3
71771: RET
// export function Count ( array ) ; begin
71772: LD_INT 0
71774: PPUSH
// result := array + 0 ;
71775: LD_ADDR_VAR 0 2
71779: PUSH
71780: LD_VAR 0 1
71784: PUSH
71785: LD_INT 0
71787: PLUS
71788: ST_TO_ADDR
// end ;
71789: LD_VAR 0 2
71793: RET
// export function IsEmpty ( building ) ; begin
71794: LD_INT 0
71796: PPUSH
// if not building then
71797: LD_VAR 0 1
71801: NOT
71802: IFFALSE 71806
// exit ;
71804: GO 71849
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
71806: LD_ADDR_VAR 0 2
71810: PUSH
71811: LD_VAR 0 1
71815: PUSH
71816: LD_INT 22
71818: PUSH
71819: LD_VAR 0 1
71823: PPUSH
71824: CALL_OW 255
71828: PUSH
71829: EMPTY
71830: LIST
71831: LIST
71832: PUSH
71833: LD_INT 58
71835: PUSH
71836: EMPTY
71837: LIST
71838: PUSH
71839: EMPTY
71840: LIST
71841: LIST
71842: PPUSH
71843: CALL_OW 69
71847: IN
71848: ST_TO_ADDR
// end ;
71849: LD_VAR 0 2
71853: RET
// export function IsNotFull ( building ) ; var places ; begin
71854: LD_INT 0
71856: PPUSH
71857: PPUSH
// if not building then
71858: LD_VAR 0 1
71862: NOT
71863: IFFALSE 71867
// exit ;
71865: GO 71895
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
71867: LD_ADDR_VAR 0 2
71871: PUSH
71872: LD_VAR 0 1
71876: PPUSH
71877: LD_INT 3
71879: PUSH
71880: LD_INT 62
71882: PUSH
71883: EMPTY
71884: LIST
71885: PUSH
71886: EMPTY
71887: LIST
71888: LIST
71889: PPUSH
71890: CALL_OW 72
71894: ST_TO_ADDR
// end ;
71895: LD_VAR 0 2
71899: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
71900: LD_INT 0
71902: PPUSH
71903: PPUSH
71904: PPUSH
71905: PPUSH
// tmp := [ ] ;
71906: LD_ADDR_VAR 0 3
71910: PUSH
71911: EMPTY
71912: ST_TO_ADDR
// list := [ ] ;
71913: LD_ADDR_VAR 0 5
71917: PUSH
71918: EMPTY
71919: ST_TO_ADDR
// for i = 16 to 25 do
71920: LD_ADDR_VAR 0 4
71924: PUSH
71925: DOUBLE
71926: LD_INT 16
71928: DEC
71929: ST_TO_ADDR
71930: LD_INT 25
71932: PUSH
71933: FOR_TO
71934: IFFALSE 72007
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
71936: LD_ADDR_VAR 0 3
71940: PUSH
71941: LD_VAR 0 3
71945: PUSH
71946: LD_INT 22
71948: PUSH
71949: LD_VAR 0 1
71953: PPUSH
71954: CALL_OW 255
71958: PUSH
71959: EMPTY
71960: LIST
71961: LIST
71962: PUSH
71963: LD_INT 91
71965: PUSH
71966: LD_VAR 0 1
71970: PUSH
71971: LD_INT 6
71973: PUSH
71974: EMPTY
71975: LIST
71976: LIST
71977: LIST
71978: PUSH
71979: LD_INT 30
71981: PUSH
71982: LD_VAR 0 4
71986: PUSH
71987: EMPTY
71988: LIST
71989: LIST
71990: PUSH
71991: EMPTY
71992: LIST
71993: LIST
71994: LIST
71995: PUSH
71996: EMPTY
71997: LIST
71998: PPUSH
71999: CALL_OW 69
72003: ADD
72004: ST_TO_ADDR
72005: GO 71933
72007: POP
72008: POP
// for i = 1 to tmp do
72009: LD_ADDR_VAR 0 4
72013: PUSH
72014: DOUBLE
72015: LD_INT 1
72017: DEC
72018: ST_TO_ADDR
72019: LD_VAR 0 3
72023: PUSH
72024: FOR_TO
72025: IFFALSE 72113
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
72027: LD_ADDR_VAR 0 5
72031: PUSH
72032: LD_VAR 0 5
72036: PUSH
72037: LD_VAR 0 3
72041: PUSH
72042: LD_VAR 0 4
72046: ARRAY
72047: PPUSH
72048: CALL_OW 266
72052: PUSH
72053: LD_VAR 0 3
72057: PUSH
72058: LD_VAR 0 4
72062: ARRAY
72063: PPUSH
72064: CALL_OW 250
72068: PUSH
72069: LD_VAR 0 3
72073: PUSH
72074: LD_VAR 0 4
72078: ARRAY
72079: PPUSH
72080: CALL_OW 251
72084: PUSH
72085: LD_VAR 0 3
72089: PUSH
72090: LD_VAR 0 4
72094: ARRAY
72095: PPUSH
72096: CALL_OW 254
72100: PUSH
72101: EMPTY
72102: LIST
72103: LIST
72104: LIST
72105: LIST
72106: PUSH
72107: EMPTY
72108: LIST
72109: ADD
72110: ST_TO_ADDR
72111: GO 72024
72113: POP
72114: POP
// result := list ;
72115: LD_ADDR_VAR 0 2
72119: PUSH
72120: LD_VAR 0 5
72124: ST_TO_ADDR
// end ;
72125: LD_VAR 0 2
72129: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
72130: LD_INT 0
72132: PPUSH
72133: PPUSH
72134: PPUSH
72135: PPUSH
72136: PPUSH
72137: PPUSH
72138: PPUSH
// if not factory then
72139: LD_VAR 0 1
72143: NOT
72144: IFFALSE 72148
// exit ;
72146: GO 72741
// if control = control_apeman then
72148: LD_VAR 0 4
72152: PUSH
72153: LD_INT 5
72155: EQUAL
72156: IFFALSE 72265
// begin tmp := UnitsInside ( factory ) ;
72158: LD_ADDR_VAR 0 8
72162: PUSH
72163: LD_VAR 0 1
72167: PPUSH
72168: CALL_OW 313
72172: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
72173: LD_VAR 0 8
72177: PPUSH
72178: LD_INT 25
72180: PUSH
72181: LD_INT 12
72183: PUSH
72184: EMPTY
72185: LIST
72186: LIST
72187: PPUSH
72188: CALL_OW 72
72192: NOT
72193: IFFALSE 72203
// control := control_manual ;
72195: LD_ADDR_VAR 0 4
72199: PUSH
72200: LD_INT 1
72202: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
72203: LD_ADDR_VAR 0 8
72207: PUSH
72208: LD_VAR 0 1
72212: PPUSH
72213: CALL 71900 0 1
72217: ST_TO_ADDR
// if tmp then
72218: LD_VAR 0 8
72222: IFFALSE 72265
// begin for i in tmp do
72224: LD_ADDR_VAR 0 7
72228: PUSH
72229: LD_VAR 0 8
72233: PUSH
72234: FOR_IN
72235: IFFALSE 72263
// if i [ 1 ] = b_ext_radio then
72237: LD_VAR 0 7
72241: PUSH
72242: LD_INT 1
72244: ARRAY
72245: PUSH
72246: LD_INT 22
72248: EQUAL
72249: IFFALSE 72261
// begin control := control_remote ;
72251: LD_ADDR_VAR 0 4
72255: PUSH
72256: LD_INT 2
72258: ST_TO_ADDR
// break ;
72259: GO 72263
// end ;
72261: GO 72234
72263: POP
72264: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
72265: LD_VAR 0 1
72269: PPUSH
72270: LD_VAR 0 2
72274: PPUSH
72275: LD_VAR 0 3
72279: PPUSH
72280: LD_VAR 0 4
72284: PPUSH
72285: LD_VAR 0 5
72289: PPUSH
72290: CALL_OW 448
72294: IFFALSE 72329
// begin result := [ chassis , engine , control , weapon ] ;
72296: LD_ADDR_VAR 0 6
72300: PUSH
72301: LD_VAR 0 2
72305: PUSH
72306: LD_VAR 0 3
72310: PUSH
72311: LD_VAR 0 4
72315: PUSH
72316: LD_VAR 0 5
72320: PUSH
72321: EMPTY
72322: LIST
72323: LIST
72324: LIST
72325: LIST
72326: ST_TO_ADDR
// exit ;
72327: GO 72741
// end ; _chassis := AvailableChassisList ( factory ) ;
72329: LD_ADDR_VAR 0 9
72333: PUSH
72334: LD_VAR 0 1
72338: PPUSH
72339: CALL_OW 475
72343: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
72344: LD_ADDR_VAR 0 11
72348: PUSH
72349: LD_VAR 0 1
72353: PPUSH
72354: CALL_OW 476
72358: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
72359: LD_ADDR_VAR 0 12
72363: PUSH
72364: LD_VAR 0 1
72368: PPUSH
72369: CALL_OW 477
72373: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
72374: LD_ADDR_VAR 0 10
72378: PUSH
72379: LD_VAR 0 1
72383: PPUSH
72384: CALL_OW 478
72388: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
72389: LD_VAR 0 9
72393: NOT
72394: PUSH
72395: LD_VAR 0 11
72399: NOT
72400: OR
72401: PUSH
72402: LD_VAR 0 12
72406: NOT
72407: OR
72408: PUSH
72409: LD_VAR 0 10
72413: NOT
72414: OR
72415: IFFALSE 72450
// begin result := [ chassis , engine , control , weapon ] ;
72417: LD_ADDR_VAR 0 6
72421: PUSH
72422: LD_VAR 0 2
72426: PUSH
72427: LD_VAR 0 3
72431: PUSH
72432: LD_VAR 0 4
72436: PUSH
72437: LD_VAR 0 5
72441: PUSH
72442: EMPTY
72443: LIST
72444: LIST
72445: LIST
72446: LIST
72447: ST_TO_ADDR
// exit ;
72448: GO 72741
// end ; if not chassis in _chassis then
72450: LD_VAR 0 2
72454: PUSH
72455: LD_VAR 0 9
72459: IN
72460: NOT
72461: IFFALSE 72487
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
72463: LD_ADDR_VAR 0 2
72467: PUSH
72468: LD_VAR 0 9
72472: PUSH
72473: LD_INT 1
72475: PPUSH
72476: LD_VAR 0 9
72480: PPUSH
72481: CALL_OW 12
72485: ARRAY
72486: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
72487: LD_VAR 0 2
72491: PPUSH
72492: LD_VAR 0 3
72496: PPUSH
72497: CALL 72746 0 2
72501: NOT
72502: IFFALSE 72561
// repeat engine := _engine [ 1 ] ;
72504: LD_ADDR_VAR 0 3
72508: PUSH
72509: LD_VAR 0 11
72513: PUSH
72514: LD_INT 1
72516: ARRAY
72517: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
72518: LD_ADDR_VAR 0 11
72522: PUSH
72523: LD_VAR 0 11
72527: PPUSH
72528: LD_INT 1
72530: PPUSH
72531: CALL_OW 3
72535: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
72536: LD_VAR 0 2
72540: PPUSH
72541: LD_VAR 0 3
72545: PPUSH
72546: CALL 72746 0 2
72550: PUSH
72551: LD_VAR 0 11
72555: PUSH
72556: EMPTY
72557: EQUAL
72558: OR
72559: IFFALSE 72504
// if not control in _control then
72561: LD_VAR 0 4
72565: PUSH
72566: LD_VAR 0 12
72570: IN
72571: NOT
72572: IFFALSE 72598
// control := _control [ rand ( 1 , _control ) ] ;
72574: LD_ADDR_VAR 0 4
72578: PUSH
72579: LD_VAR 0 12
72583: PUSH
72584: LD_INT 1
72586: PPUSH
72587: LD_VAR 0 12
72591: PPUSH
72592: CALL_OW 12
72596: ARRAY
72597: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
72598: LD_VAR 0 2
72602: PPUSH
72603: LD_VAR 0 5
72607: PPUSH
72608: CALL 72966 0 2
72612: NOT
72613: IFFALSE 72672
// repeat weapon := _weapon [ 1 ] ;
72615: LD_ADDR_VAR 0 5
72619: PUSH
72620: LD_VAR 0 10
72624: PUSH
72625: LD_INT 1
72627: ARRAY
72628: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
72629: LD_ADDR_VAR 0 10
72633: PUSH
72634: LD_VAR 0 10
72638: PPUSH
72639: LD_INT 1
72641: PPUSH
72642: CALL_OW 3
72646: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
72647: LD_VAR 0 2
72651: PPUSH
72652: LD_VAR 0 5
72656: PPUSH
72657: CALL 72966 0 2
72661: PUSH
72662: LD_VAR 0 10
72666: PUSH
72667: EMPTY
72668: EQUAL
72669: OR
72670: IFFALSE 72615
// result := [ ] ;
72672: LD_ADDR_VAR 0 6
72676: PUSH
72677: EMPTY
72678: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
72679: LD_VAR 0 1
72683: PPUSH
72684: LD_VAR 0 2
72688: PPUSH
72689: LD_VAR 0 3
72693: PPUSH
72694: LD_VAR 0 4
72698: PPUSH
72699: LD_VAR 0 5
72703: PPUSH
72704: CALL_OW 448
72708: IFFALSE 72741
// result := [ chassis , engine , control , weapon ] ;
72710: LD_ADDR_VAR 0 6
72714: PUSH
72715: LD_VAR 0 2
72719: PUSH
72720: LD_VAR 0 3
72724: PUSH
72725: LD_VAR 0 4
72729: PUSH
72730: LD_VAR 0 5
72734: PUSH
72735: EMPTY
72736: LIST
72737: LIST
72738: LIST
72739: LIST
72740: ST_TO_ADDR
// end ;
72741: LD_VAR 0 6
72745: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
72746: LD_INT 0
72748: PPUSH
// if not chassis or not engine then
72749: LD_VAR 0 1
72753: NOT
72754: PUSH
72755: LD_VAR 0 2
72759: NOT
72760: OR
72761: IFFALSE 72765
// exit ;
72763: GO 72961
// case engine of engine_solar :
72765: LD_VAR 0 2
72769: PUSH
72770: LD_INT 2
72772: DOUBLE
72773: EQUAL
72774: IFTRUE 72778
72776: GO 72816
72778: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
72779: LD_ADDR_VAR 0 3
72783: PUSH
72784: LD_INT 11
72786: PUSH
72787: LD_INT 12
72789: PUSH
72790: LD_INT 13
72792: PUSH
72793: LD_INT 14
72795: PUSH
72796: LD_INT 1
72798: PUSH
72799: LD_INT 2
72801: PUSH
72802: LD_INT 3
72804: PUSH
72805: EMPTY
72806: LIST
72807: LIST
72808: LIST
72809: LIST
72810: LIST
72811: LIST
72812: LIST
72813: ST_TO_ADDR
72814: GO 72945
72816: LD_INT 1
72818: DOUBLE
72819: EQUAL
72820: IFTRUE 72824
72822: GO 72886
72824: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
72825: LD_ADDR_VAR 0 3
72829: PUSH
72830: LD_INT 11
72832: PUSH
72833: LD_INT 12
72835: PUSH
72836: LD_INT 13
72838: PUSH
72839: LD_INT 14
72841: PUSH
72842: LD_INT 1
72844: PUSH
72845: LD_INT 2
72847: PUSH
72848: LD_INT 3
72850: PUSH
72851: LD_INT 4
72853: PUSH
72854: LD_INT 5
72856: PUSH
72857: LD_INT 21
72859: PUSH
72860: LD_INT 23
72862: PUSH
72863: LD_INT 22
72865: PUSH
72866: LD_INT 24
72868: PUSH
72869: EMPTY
72870: LIST
72871: LIST
72872: LIST
72873: LIST
72874: LIST
72875: LIST
72876: LIST
72877: LIST
72878: LIST
72879: LIST
72880: LIST
72881: LIST
72882: LIST
72883: ST_TO_ADDR
72884: GO 72945
72886: LD_INT 3
72888: DOUBLE
72889: EQUAL
72890: IFTRUE 72894
72892: GO 72944
72894: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
72895: LD_ADDR_VAR 0 3
72899: PUSH
72900: LD_INT 13
72902: PUSH
72903: LD_INT 14
72905: PUSH
72906: LD_INT 2
72908: PUSH
72909: LD_INT 3
72911: PUSH
72912: LD_INT 4
72914: PUSH
72915: LD_INT 5
72917: PUSH
72918: LD_INT 21
72920: PUSH
72921: LD_INT 22
72923: PUSH
72924: LD_INT 23
72926: PUSH
72927: LD_INT 24
72929: PUSH
72930: EMPTY
72931: LIST
72932: LIST
72933: LIST
72934: LIST
72935: LIST
72936: LIST
72937: LIST
72938: LIST
72939: LIST
72940: LIST
72941: ST_TO_ADDR
72942: GO 72945
72944: POP
// result := ( chassis in result ) ;
72945: LD_ADDR_VAR 0 3
72949: PUSH
72950: LD_VAR 0 1
72954: PUSH
72955: LD_VAR 0 3
72959: IN
72960: ST_TO_ADDR
// end ;
72961: LD_VAR 0 3
72965: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
72966: LD_INT 0
72968: PPUSH
// if not chassis or not weapon then
72969: LD_VAR 0 1
72973: NOT
72974: PUSH
72975: LD_VAR 0 2
72979: NOT
72980: OR
72981: IFFALSE 72985
// exit ;
72983: GO 74045
// case weapon of us_machine_gun :
72985: LD_VAR 0 2
72989: PUSH
72990: LD_INT 2
72992: DOUBLE
72993: EQUAL
72994: IFTRUE 72998
72996: GO 73028
72998: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
72999: LD_ADDR_VAR 0 3
73003: PUSH
73004: LD_INT 1
73006: PUSH
73007: LD_INT 2
73009: PUSH
73010: LD_INT 3
73012: PUSH
73013: LD_INT 4
73015: PUSH
73016: LD_INT 5
73018: PUSH
73019: EMPTY
73020: LIST
73021: LIST
73022: LIST
73023: LIST
73024: LIST
73025: ST_TO_ADDR
73026: GO 74029
73028: LD_INT 3
73030: DOUBLE
73031: EQUAL
73032: IFTRUE 73036
73034: GO 73066
73036: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
73037: LD_ADDR_VAR 0 3
73041: PUSH
73042: LD_INT 1
73044: PUSH
73045: LD_INT 2
73047: PUSH
73048: LD_INT 3
73050: PUSH
73051: LD_INT 4
73053: PUSH
73054: LD_INT 5
73056: PUSH
73057: EMPTY
73058: LIST
73059: LIST
73060: LIST
73061: LIST
73062: LIST
73063: ST_TO_ADDR
73064: GO 74029
73066: LD_INT 11
73068: DOUBLE
73069: EQUAL
73070: IFTRUE 73074
73072: GO 73104
73074: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
73075: LD_ADDR_VAR 0 3
73079: PUSH
73080: LD_INT 1
73082: PUSH
73083: LD_INT 2
73085: PUSH
73086: LD_INT 3
73088: PUSH
73089: LD_INT 4
73091: PUSH
73092: LD_INT 5
73094: PUSH
73095: EMPTY
73096: LIST
73097: LIST
73098: LIST
73099: LIST
73100: LIST
73101: ST_TO_ADDR
73102: GO 74029
73104: LD_INT 4
73106: DOUBLE
73107: EQUAL
73108: IFTRUE 73112
73110: GO 73138
73112: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
73113: LD_ADDR_VAR 0 3
73117: PUSH
73118: LD_INT 2
73120: PUSH
73121: LD_INT 3
73123: PUSH
73124: LD_INT 4
73126: PUSH
73127: LD_INT 5
73129: PUSH
73130: EMPTY
73131: LIST
73132: LIST
73133: LIST
73134: LIST
73135: ST_TO_ADDR
73136: GO 74029
73138: LD_INT 5
73140: DOUBLE
73141: EQUAL
73142: IFTRUE 73146
73144: GO 73172
73146: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
73147: LD_ADDR_VAR 0 3
73151: PUSH
73152: LD_INT 2
73154: PUSH
73155: LD_INT 3
73157: PUSH
73158: LD_INT 4
73160: PUSH
73161: LD_INT 5
73163: PUSH
73164: EMPTY
73165: LIST
73166: LIST
73167: LIST
73168: LIST
73169: ST_TO_ADDR
73170: GO 74029
73172: LD_INT 9
73174: DOUBLE
73175: EQUAL
73176: IFTRUE 73180
73178: GO 73206
73180: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
73181: LD_ADDR_VAR 0 3
73185: PUSH
73186: LD_INT 2
73188: PUSH
73189: LD_INT 3
73191: PUSH
73192: LD_INT 4
73194: PUSH
73195: LD_INT 5
73197: PUSH
73198: EMPTY
73199: LIST
73200: LIST
73201: LIST
73202: LIST
73203: ST_TO_ADDR
73204: GO 74029
73206: LD_INT 7
73208: DOUBLE
73209: EQUAL
73210: IFTRUE 73214
73212: GO 73240
73214: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
73215: LD_ADDR_VAR 0 3
73219: PUSH
73220: LD_INT 2
73222: PUSH
73223: LD_INT 3
73225: PUSH
73226: LD_INT 4
73228: PUSH
73229: LD_INT 5
73231: PUSH
73232: EMPTY
73233: LIST
73234: LIST
73235: LIST
73236: LIST
73237: ST_TO_ADDR
73238: GO 74029
73240: LD_INT 12
73242: DOUBLE
73243: EQUAL
73244: IFTRUE 73248
73246: GO 73274
73248: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
73249: LD_ADDR_VAR 0 3
73253: PUSH
73254: LD_INT 2
73256: PUSH
73257: LD_INT 3
73259: PUSH
73260: LD_INT 4
73262: PUSH
73263: LD_INT 5
73265: PUSH
73266: EMPTY
73267: LIST
73268: LIST
73269: LIST
73270: LIST
73271: ST_TO_ADDR
73272: GO 74029
73274: LD_INT 13
73276: DOUBLE
73277: EQUAL
73278: IFTRUE 73282
73280: GO 73308
73282: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
73283: LD_ADDR_VAR 0 3
73287: PUSH
73288: LD_INT 2
73290: PUSH
73291: LD_INT 3
73293: PUSH
73294: LD_INT 4
73296: PUSH
73297: LD_INT 5
73299: PUSH
73300: EMPTY
73301: LIST
73302: LIST
73303: LIST
73304: LIST
73305: ST_TO_ADDR
73306: GO 74029
73308: LD_INT 14
73310: DOUBLE
73311: EQUAL
73312: IFTRUE 73316
73314: GO 73334
73316: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
73317: LD_ADDR_VAR 0 3
73321: PUSH
73322: LD_INT 4
73324: PUSH
73325: LD_INT 5
73327: PUSH
73328: EMPTY
73329: LIST
73330: LIST
73331: ST_TO_ADDR
73332: GO 74029
73334: LD_INT 6
73336: DOUBLE
73337: EQUAL
73338: IFTRUE 73342
73340: GO 73360
73342: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
73343: LD_ADDR_VAR 0 3
73347: PUSH
73348: LD_INT 4
73350: PUSH
73351: LD_INT 5
73353: PUSH
73354: EMPTY
73355: LIST
73356: LIST
73357: ST_TO_ADDR
73358: GO 74029
73360: LD_INT 10
73362: DOUBLE
73363: EQUAL
73364: IFTRUE 73368
73366: GO 73386
73368: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
73369: LD_ADDR_VAR 0 3
73373: PUSH
73374: LD_INT 4
73376: PUSH
73377: LD_INT 5
73379: PUSH
73380: EMPTY
73381: LIST
73382: LIST
73383: ST_TO_ADDR
73384: GO 74029
73386: LD_INT 22
73388: DOUBLE
73389: EQUAL
73390: IFTRUE 73394
73392: GO 73420
73394: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
73395: LD_ADDR_VAR 0 3
73399: PUSH
73400: LD_INT 11
73402: PUSH
73403: LD_INT 12
73405: PUSH
73406: LD_INT 13
73408: PUSH
73409: LD_INT 14
73411: PUSH
73412: EMPTY
73413: LIST
73414: LIST
73415: LIST
73416: LIST
73417: ST_TO_ADDR
73418: GO 74029
73420: LD_INT 23
73422: DOUBLE
73423: EQUAL
73424: IFTRUE 73428
73426: GO 73454
73428: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
73429: LD_ADDR_VAR 0 3
73433: PUSH
73434: LD_INT 11
73436: PUSH
73437: LD_INT 12
73439: PUSH
73440: LD_INT 13
73442: PUSH
73443: LD_INT 14
73445: PUSH
73446: EMPTY
73447: LIST
73448: LIST
73449: LIST
73450: LIST
73451: ST_TO_ADDR
73452: GO 74029
73454: LD_INT 24
73456: DOUBLE
73457: EQUAL
73458: IFTRUE 73462
73460: GO 73488
73462: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
73463: LD_ADDR_VAR 0 3
73467: PUSH
73468: LD_INT 11
73470: PUSH
73471: LD_INT 12
73473: PUSH
73474: LD_INT 13
73476: PUSH
73477: LD_INT 14
73479: PUSH
73480: EMPTY
73481: LIST
73482: LIST
73483: LIST
73484: LIST
73485: ST_TO_ADDR
73486: GO 74029
73488: LD_INT 30
73490: DOUBLE
73491: EQUAL
73492: IFTRUE 73496
73494: GO 73522
73496: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
73497: LD_ADDR_VAR 0 3
73501: PUSH
73502: LD_INT 11
73504: PUSH
73505: LD_INT 12
73507: PUSH
73508: LD_INT 13
73510: PUSH
73511: LD_INT 14
73513: PUSH
73514: EMPTY
73515: LIST
73516: LIST
73517: LIST
73518: LIST
73519: ST_TO_ADDR
73520: GO 74029
73522: LD_INT 25
73524: DOUBLE
73525: EQUAL
73526: IFTRUE 73530
73528: GO 73548
73530: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
73531: LD_ADDR_VAR 0 3
73535: PUSH
73536: LD_INT 13
73538: PUSH
73539: LD_INT 14
73541: PUSH
73542: EMPTY
73543: LIST
73544: LIST
73545: ST_TO_ADDR
73546: GO 74029
73548: LD_INT 27
73550: DOUBLE
73551: EQUAL
73552: IFTRUE 73556
73554: GO 73574
73556: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
73557: LD_ADDR_VAR 0 3
73561: PUSH
73562: LD_INT 13
73564: PUSH
73565: LD_INT 14
73567: PUSH
73568: EMPTY
73569: LIST
73570: LIST
73571: ST_TO_ADDR
73572: GO 74029
73574: LD_INT 92
73576: DOUBLE
73577: EQUAL
73578: IFTRUE 73582
73580: GO 73608
73582: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
73583: LD_ADDR_VAR 0 3
73587: PUSH
73588: LD_INT 11
73590: PUSH
73591: LD_INT 12
73593: PUSH
73594: LD_INT 13
73596: PUSH
73597: LD_INT 14
73599: PUSH
73600: EMPTY
73601: LIST
73602: LIST
73603: LIST
73604: LIST
73605: ST_TO_ADDR
73606: GO 74029
73608: LD_INT 28
73610: DOUBLE
73611: EQUAL
73612: IFTRUE 73616
73614: GO 73634
73616: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
73617: LD_ADDR_VAR 0 3
73621: PUSH
73622: LD_INT 13
73624: PUSH
73625: LD_INT 14
73627: PUSH
73628: EMPTY
73629: LIST
73630: LIST
73631: ST_TO_ADDR
73632: GO 74029
73634: LD_INT 29
73636: DOUBLE
73637: EQUAL
73638: IFTRUE 73642
73640: GO 73660
73642: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
73643: LD_ADDR_VAR 0 3
73647: PUSH
73648: LD_INT 13
73650: PUSH
73651: LD_INT 14
73653: PUSH
73654: EMPTY
73655: LIST
73656: LIST
73657: ST_TO_ADDR
73658: GO 74029
73660: LD_INT 31
73662: DOUBLE
73663: EQUAL
73664: IFTRUE 73668
73666: GO 73686
73668: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
73669: LD_ADDR_VAR 0 3
73673: PUSH
73674: LD_INT 13
73676: PUSH
73677: LD_INT 14
73679: PUSH
73680: EMPTY
73681: LIST
73682: LIST
73683: ST_TO_ADDR
73684: GO 74029
73686: LD_INT 26
73688: DOUBLE
73689: EQUAL
73690: IFTRUE 73694
73692: GO 73712
73694: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
73695: LD_ADDR_VAR 0 3
73699: PUSH
73700: LD_INT 13
73702: PUSH
73703: LD_INT 14
73705: PUSH
73706: EMPTY
73707: LIST
73708: LIST
73709: ST_TO_ADDR
73710: GO 74029
73712: LD_INT 42
73714: DOUBLE
73715: EQUAL
73716: IFTRUE 73720
73718: GO 73746
73720: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
73721: LD_ADDR_VAR 0 3
73725: PUSH
73726: LD_INT 21
73728: PUSH
73729: LD_INT 22
73731: PUSH
73732: LD_INT 23
73734: PUSH
73735: LD_INT 24
73737: PUSH
73738: EMPTY
73739: LIST
73740: LIST
73741: LIST
73742: LIST
73743: ST_TO_ADDR
73744: GO 74029
73746: LD_INT 43
73748: DOUBLE
73749: EQUAL
73750: IFTRUE 73754
73752: GO 73780
73754: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
73755: LD_ADDR_VAR 0 3
73759: PUSH
73760: LD_INT 21
73762: PUSH
73763: LD_INT 22
73765: PUSH
73766: LD_INT 23
73768: PUSH
73769: LD_INT 24
73771: PUSH
73772: EMPTY
73773: LIST
73774: LIST
73775: LIST
73776: LIST
73777: ST_TO_ADDR
73778: GO 74029
73780: LD_INT 44
73782: DOUBLE
73783: EQUAL
73784: IFTRUE 73788
73786: GO 73814
73788: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
73789: LD_ADDR_VAR 0 3
73793: PUSH
73794: LD_INT 21
73796: PUSH
73797: LD_INT 22
73799: PUSH
73800: LD_INT 23
73802: PUSH
73803: LD_INT 24
73805: PUSH
73806: EMPTY
73807: LIST
73808: LIST
73809: LIST
73810: LIST
73811: ST_TO_ADDR
73812: GO 74029
73814: LD_INT 45
73816: DOUBLE
73817: EQUAL
73818: IFTRUE 73822
73820: GO 73848
73822: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
73823: LD_ADDR_VAR 0 3
73827: PUSH
73828: LD_INT 21
73830: PUSH
73831: LD_INT 22
73833: PUSH
73834: LD_INT 23
73836: PUSH
73837: LD_INT 24
73839: PUSH
73840: EMPTY
73841: LIST
73842: LIST
73843: LIST
73844: LIST
73845: ST_TO_ADDR
73846: GO 74029
73848: LD_INT 49
73850: DOUBLE
73851: EQUAL
73852: IFTRUE 73856
73854: GO 73882
73856: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
73857: LD_ADDR_VAR 0 3
73861: PUSH
73862: LD_INT 21
73864: PUSH
73865: LD_INT 22
73867: PUSH
73868: LD_INT 23
73870: PUSH
73871: LD_INT 24
73873: PUSH
73874: EMPTY
73875: LIST
73876: LIST
73877: LIST
73878: LIST
73879: ST_TO_ADDR
73880: GO 74029
73882: LD_INT 51
73884: DOUBLE
73885: EQUAL
73886: IFTRUE 73890
73888: GO 73916
73890: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
73891: LD_ADDR_VAR 0 3
73895: PUSH
73896: LD_INT 21
73898: PUSH
73899: LD_INT 22
73901: PUSH
73902: LD_INT 23
73904: PUSH
73905: LD_INT 24
73907: PUSH
73908: EMPTY
73909: LIST
73910: LIST
73911: LIST
73912: LIST
73913: ST_TO_ADDR
73914: GO 74029
73916: LD_INT 52
73918: DOUBLE
73919: EQUAL
73920: IFTRUE 73924
73922: GO 73950
73924: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
73925: LD_ADDR_VAR 0 3
73929: PUSH
73930: LD_INT 21
73932: PUSH
73933: LD_INT 22
73935: PUSH
73936: LD_INT 23
73938: PUSH
73939: LD_INT 24
73941: PUSH
73942: EMPTY
73943: LIST
73944: LIST
73945: LIST
73946: LIST
73947: ST_TO_ADDR
73948: GO 74029
73950: LD_INT 53
73952: DOUBLE
73953: EQUAL
73954: IFTRUE 73958
73956: GO 73976
73958: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
73959: LD_ADDR_VAR 0 3
73963: PUSH
73964: LD_INT 23
73966: PUSH
73967: LD_INT 24
73969: PUSH
73970: EMPTY
73971: LIST
73972: LIST
73973: ST_TO_ADDR
73974: GO 74029
73976: LD_INT 46
73978: DOUBLE
73979: EQUAL
73980: IFTRUE 73984
73982: GO 74002
73984: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
73985: LD_ADDR_VAR 0 3
73989: PUSH
73990: LD_INT 23
73992: PUSH
73993: LD_INT 24
73995: PUSH
73996: EMPTY
73997: LIST
73998: LIST
73999: ST_TO_ADDR
74000: GO 74029
74002: LD_INT 47
74004: DOUBLE
74005: EQUAL
74006: IFTRUE 74010
74008: GO 74028
74010: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
74011: LD_ADDR_VAR 0 3
74015: PUSH
74016: LD_INT 23
74018: PUSH
74019: LD_INT 24
74021: PUSH
74022: EMPTY
74023: LIST
74024: LIST
74025: ST_TO_ADDR
74026: GO 74029
74028: POP
// result := ( chassis in result ) ;
74029: LD_ADDR_VAR 0 3
74033: PUSH
74034: LD_VAR 0 1
74038: PUSH
74039: LD_VAR 0 3
74043: IN
74044: ST_TO_ADDR
// end ;
74045: LD_VAR 0 3
74049: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
74050: LD_INT 0
74052: PPUSH
74053: PPUSH
74054: PPUSH
74055: PPUSH
74056: PPUSH
74057: PPUSH
74058: PPUSH
// result := array ;
74059: LD_ADDR_VAR 0 5
74063: PUSH
74064: LD_VAR 0 1
74068: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
74069: LD_VAR 0 1
74073: NOT
74074: PUSH
74075: LD_VAR 0 2
74079: NOT
74080: OR
74081: PUSH
74082: LD_VAR 0 3
74086: NOT
74087: OR
74088: PUSH
74089: LD_VAR 0 2
74093: PUSH
74094: LD_VAR 0 1
74098: GREATER
74099: OR
74100: PUSH
74101: LD_VAR 0 3
74105: PUSH
74106: LD_VAR 0 1
74110: GREATER
74111: OR
74112: IFFALSE 74116
// exit ;
74114: GO 74412
// if direction then
74116: LD_VAR 0 4
74120: IFFALSE 74184
// begin d := 1 ;
74122: LD_ADDR_VAR 0 9
74126: PUSH
74127: LD_INT 1
74129: ST_TO_ADDR
// if i_from > i_to then
74130: LD_VAR 0 2
74134: PUSH
74135: LD_VAR 0 3
74139: GREATER
74140: IFFALSE 74166
// length := ( array - i_from ) + i_to else
74142: LD_ADDR_VAR 0 11
74146: PUSH
74147: LD_VAR 0 1
74151: PUSH
74152: LD_VAR 0 2
74156: MINUS
74157: PUSH
74158: LD_VAR 0 3
74162: PLUS
74163: ST_TO_ADDR
74164: GO 74182
// length := i_to - i_from ;
74166: LD_ADDR_VAR 0 11
74170: PUSH
74171: LD_VAR 0 3
74175: PUSH
74176: LD_VAR 0 2
74180: MINUS
74181: ST_TO_ADDR
// end else
74182: GO 74245
// begin d := - 1 ;
74184: LD_ADDR_VAR 0 9
74188: PUSH
74189: LD_INT 1
74191: NEG
74192: ST_TO_ADDR
// if i_from > i_to then
74193: LD_VAR 0 2
74197: PUSH
74198: LD_VAR 0 3
74202: GREATER
74203: IFFALSE 74223
// length := i_from - i_to else
74205: LD_ADDR_VAR 0 11
74209: PUSH
74210: LD_VAR 0 2
74214: PUSH
74215: LD_VAR 0 3
74219: MINUS
74220: ST_TO_ADDR
74221: GO 74245
// length := ( array - i_to ) + i_from ;
74223: LD_ADDR_VAR 0 11
74227: PUSH
74228: LD_VAR 0 1
74232: PUSH
74233: LD_VAR 0 3
74237: MINUS
74238: PUSH
74239: LD_VAR 0 2
74243: PLUS
74244: ST_TO_ADDR
// end ; if not length then
74245: LD_VAR 0 11
74249: NOT
74250: IFFALSE 74254
// exit ;
74252: GO 74412
// tmp := array ;
74254: LD_ADDR_VAR 0 10
74258: PUSH
74259: LD_VAR 0 1
74263: ST_TO_ADDR
// for i = 1 to length do
74264: LD_ADDR_VAR 0 6
74268: PUSH
74269: DOUBLE
74270: LD_INT 1
74272: DEC
74273: ST_TO_ADDR
74274: LD_VAR 0 11
74278: PUSH
74279: FOR_TO
74280: IFFALSE 74400
// begin for j = 1 to array do
74282: LD_ADDR_VAR 0 7
74286: PUSH
74287: DOUBLE
74288: LD_INT 1
74290: DEC
74291: ST_TO_ADDR
74292: LD_VAR 0 1
74296: PUSH
74297: FOR_TO
74298: IFFALSE 74386
// begin k := j + d ;
74300: LD_ADDR_VAR 0 8
74304: PUSH
74305: LD_VAR 0 7
74309: PUSH
74310: LD_VAR 0 9
74314: PLUS
74315: ST_TO_ADDR
// if k > array then
74316: LD_VAR 0 8
74320: PUSH
74321: LD_VAR 0 1
74325: GREATER
74326: IFFALSE 74336
// k := 1 ;
74328: LD_ADDR_VAR 0 8
74332: PUSH
74333: LD_INT 1
74335: ST_TO_ADDR
// if not k then
74336: LD_VAR 0 8
74340: NOT
74341: IFFALSE 74353
// k := array ;
74343: LD_ADDR_VAR 0 8
74347: PUSH
74348: LD_VAR 0 1
74352: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
74353: LD_ADDR_VAR 0 10
74357: PUSH
74358: LD_VAR 0 10
74362: PPUSH
74363: LD_VAR 0 8
74367: PPUSH
74368: LD_VAR 0 1
74372: PUSH
74373: LD_VAR 0 7
74377: ARRAY
74378: PPUSH
74379: CALL_OW 1
74383: ST_TO_ADDR
// end ;
74384: GO 74297
74386: POP
74387: POP
// array := tmp ;
74388: LD_ADDR_VAR 0 1
74392: PUSH
74393: LD_VAR 0 10
74397: ST_TO_ADDR
// end ;
74398: GO 74279
74400: POP
74401: POP
// result := array ;
74402: LD_ADDR_VAR 0 5
74406: PUSH
74407: LD_VAR 0 1
74411: ST_TO_ADDR
// end ;
74412: LD_VAR 0 5
74416: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
74417: LD_INT 0
74419: PPUSH
74420: PPUSH
// result := 0 ;
74421: LD_ADDR_VAR 0 3
74425: PUSH
74426: LD_INT 0
74428: ST_TO_ADDR
// if not array or not value in array then
74429: LD_VAR 0 1
74433: NOT
74434: PUSH
74435: LD_VAR 0 2
74439: PUSH
74440: LD_VAR 0 1
74444: IN
74445: NOT
74446: OR
74447: IFFALSE 74451
// exit ;
74449: GO 74505
// for i = 1 to array do
74451: LD_ADDR_VAR 0 4
74455: PUSH
74456: DOUBLE
74457: LD_INT 1
74459: DEC
74460: ST_TO_ADDR
74461: LD_VAR 0 1
74465: PUSH
74466: FOR_TO
74467: IFFALSE 74503
// if value = array [ i ] then
74469: LD_VAR 0 2
74473: PUSH
74474: LD_VAR 0 1
74478: PUSH
74479: LD_VAR 0 4
74483: ARRAY
74484: EQUAL
74485: IFFALSE 74501
// begin result := i ;
74487: LD_ADDR_VAR 0 3
74491: PUSH
74492: LD_VAR 0 4
74496: ST_TO_ADDR
// exit ;
74497: POP
74498: POP
74499: GO 74505
// end ;
74501: GO 74466
74503: POP
74504: POP
// end ;
74505: LD_VAR 0 3
74509: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
74510: LD_INT 0
74512: PPUSH
// vc_chassis := chassis ;
74513: LD_ADDR_OWVAR 37
74517: PUSH
74518: LD_VAR 0 1
74522: ST_TO_ADDR
// vc_engine := engine ;
74523: LD_ADDR_OWVAR 39
74527: PUSH
74528: LD_VAR 0 2
74532: ST_TO_ADDR
// vc_control := control ;
74533: LD_ADDR_OWVAR 38
74537: PUSH
74538: LD_VAR 0 3
74542: ST_TO_ADDR
// vc_weapon := weapon ;
74543: LD_ADDR_OWVAR 40
74547: PUSH
74548: LD_VAR 0 4
74552: ST_TO_ADDR
// vc_fuel_battery := fuel ;
74553: LD_ADDR_OWVAR 41
74557: PUSH
74558: LD_VAR 0 5
74562: ST_TO_ADDR
// end ;
74563: LD_VAR 0 6
74567: RET
// export function WantPlant ( unit ) ; var task ; begin
74568: LD_INT 0
74570: PPUSH
74571: PPUSH
// result := false ;
74572: LD_ADDR_VAR 0 2
74576: PUSH
74577: LD_INT 0
74579: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
74580: LD_ADDR_VAR 0 3
74584: PUSH
74585: LD_VAR 0 1
74589: PPUSH
74590: CALL_OW 437
74594: ST_TO_ADDR
// if task then
74595: LD_VAR 0 3
74599: IFFALSE 74627
// if task [ 1 ] [ 1 ] = p then
74601: LD_VAR 0 3
74605: PUSH
74606: LD_INT 1
74608: ARRAY
74609: PUSH
74610: LD_INT 1
74612: ARRAY
74613: PUSH
74614: LD_STRING p
74616: EQUAL
74617: IFFALSE 74627
// result := true ;
74619: LD_ADDR_VAR 0 2
74623: PUSH
74624: LD_INT 1
74626: ST_TO_ADDR
// end ;
74627: LD_VAR 0 2
74631: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
74632: LD_INT 0
74634: PPUSH
74635: PPUSH
74636: PPUSH
74637: PPUSH
// if pos < 1 then
74638: LD_VAR 0 2
74642: PUSH
74643: LD_INT 1
74645: LESS
74646: IFFALSE 74650
// exit ;
74648: GO 74953
// if pos = 1 then
74650: LD_VAR 0 2
74654: PUSH
74655: LD_INT 1
74657: EQUAL
74658: IFFALSE 74691
// result := Replace ( arr , pos [ 1 ] , value ) else
74660: LD_ADDR_VAR 0 4
74664: PUSH
74665: LD_VAR 0 1
74669: PPUSH
74670: LD_VAR 0 2
74674: PUSH
74675: LD_INT 1
74677: ARRAY
74678: PPUSH
74679: LD_VAR 0 3
74683: PPUSH
74684: CALL_OW 1
74688: ST_TO_ADDR
74689: GO 74953
// begin tmp := arr ;
74691: LD_ADDR_VAR 0 6
74695: PUSH
74696: LD_VAR 0 1
74700: ST_TO_ADDR
// s_arr := [ tmp ] ;
74701: LD_ADDR_VAR 0 7
74705: PUSH
74706: LD_VAR 0 6
74710: PUSH
74711: EMPTY
74712: LIST
74713: ST_TO_ADDR
// for i = 1 to pos - 1 do
74714: LD_ADDR_VAR 0 5
74718: PUSH
74719: DOUBLE
74720: LD_INT 1
74722: DEC
74723: ST_TO_ADDR
74724: LD_VAR 0 2
74728: PUSH
74729: LD_INT 1
74731: MINUS
74732: PUSH
74733: FOR_TO
74734: IFFALSE 74779
// begin tmp := tmp [ pos [ i ] ] ;
74736: LD_ADDR_VAR 0 6
74740: PUSH
74741: LD_VAR 0 6
74745: PUSH
74746: LD_VAR 0 2
74750: PUSH
74751: LD_VAR 0 5
74755: ARRAY
74756: ARRAY
74757: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
74758: LD_ADDR_VAR 0 7
74762: PUSH
74763: LD_VAR 0 7
74767: PUSH
74768: LD_VAR 0 6
74772: PUSH
74773: EMPTY
74774: LIST
74775: ADD
74776: ST_TO_ADDR
// end ;
74777: GO 74733
74779: POP
74780: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
74781: LD_ADDR_VAR 0 6
74785: PUSH
74786: LD_VAR 0 6
74790: PPUSH
74791: LD_VAR 0 2
74795: PUSH
74796: LD_VAR 0 2
74800: ARRAY
74801: PPUSH
74802: LD_VAR 0 3
74806: PPUSH
74807: CALL_OW 1
74811: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
74812: LD_ADDR_VAR 0 7
74816: PUSH
74817: LD_VAR 0 7
74821: PPUSH
74822: LD_VAR 0 7
74826: PPUSH
74827: LD_VAR 0 6
74831: PPUSH
74832: CALL_OW 1
74836: ST_TO_ADDR
// for i = s_arr downto 2 do
74837: LD_ADDR_VAR 0 5
74841: PUSH
74842: DOUBLE
74843: LD_VAR 0 7
74847: INC
74848: ST_TO_ADDR
74849: LD_INT 2
74851: PUSH
74852: FOR_DOWNTO
74853: IFFALSE 74937
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
74855: LD_ADDR_VAR 0 6
74859: PUSH
74860: LD_VAR 0 7
74864: PUSH
74865: LD_VAR 0 5
74869: PUSH
74870: LD_INT 1
74872: MINUS
74873: ARRAY
74874: PPUSH
74875: LD_VAR 0 2
74879: PUSH
74880: LD_VAR 0 5
74884: PUSH
74885: LD_INT 1
74887: MINUS
74888: ARRAY
74889: PPUSH
74890: LD_VAR 0 7
74894: PUSH
74895: LD_VAR 0 5
74899: ARRAY
74900: PPUSH
74901: CALL_OW 1
74905: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
74906: LD_ADDR_VAR 0 7
74910: PUSH
74911: LD_VAR 0 7
74915: PPUSH
74916: LD_VAR 0 5
74920: PUSH
74921: LD_INT 1
74923: MINUS
74924: PPUSH
74925: LD_VAR 0 6
74929: PPUSH
74930: CALL_OW 1
74934: ST_TO_ADDR
// end ;
74935: GO 74852
74937: POP
74938: POP
// result := s_arr [ 1 ] ;
74939: LD_ADDR_VAR 0 4
74943: PUSH
74944: LD_VAR 0 7
74948: PUSH
74949: LD_INT 1
74951: ARRAY
74952: ST_TO_ADDR
// end ; end ;
74953: LD_VAR 0 4
74957: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
74958: LD_INT 0
74960: PPUSH
74961: PPUSH
// if not list then
74962: LD_VAR 0 1
74966: NOT
74967: IFFALSE 74971
// exit ;
74969: GO 75062
// i := list [ pos1 ] ;
74971: LD_ADDR_VAR 0 5
74975: PUSH
74976: LD_VAR 0 1
74980: PUSH
74981: LD_VAR 0 2
74985: ARRAY
74986: ST_TO_ADDR
// if not i then
74987: LD_VAR 0 5
74991: NOT
74992: IFFALSE 74996
// exit ;
74994: GO 75062
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
74996: LD_ADDR_VAR 0 1
75000: PUSH
75001: LD_VAR 0 1
75005: PPUSH
75006: LD_VAR 0 2
75010: PPUSH
75011: LD_VAR 0 1
75015: PUSH
75016: LD_VAR 0 3
75020: ARRAY
75021: PPUSH
75022: CALL_OW 1
75026: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
75027: LD_ADDR_VAR 0 1
75031: PUSH
75032: LD_VAR 0 1
75036: PPUSH
75037: LD_VAR 0 3
75041: PPUSH
75042: LD_VAR 0 5
75046: PPUSH
75047: CALL_OW 1
75051: ST_TO_ADDR
// result := list ;
75052: LD_ADDR_VAR 0 4
75056: PUSH
75057: LD_VAR 0 1
75061: ST_TO_ADDR
// end ;
75062: LD_VAR 0 4
75066: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
75067: LD_INT 0
75069: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
75070: LD_ADDR_VAR 0 5
75074: PUSH
75075: LD_VAR 0 1
75079: PPUSH
75080: CALL_OW 250
75084: PPUSH
75085: LD_VAR 0 1
75089: PPUSH
75090: CALL_OW 251
75094: PPUSH
75095: LD_VAR 0 2
75099: PPUSH
75100: LD_VAR 0 3
75104: PPUSH
75105: LD_VAR 0 4
75109: PPUSH
75110: CALL 75488 0 5
75114: ST_TO_ADDR
// end ;
75115: LD_VAR 0 5
75119: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
75120: LD_INT 0
75122: PPUSH
75123: PPUSH
75124: PPUSH
75125: PPUSH
// if not list or not unit then
75126: LD_VAR 0 2
75130: NOT
75131: PUSH
75132: LD_VAR 0 1
75136: NOT
75137: OR
75138: IFFALSE 75142
// exit ;
75140: GO 75483
// result := [ ] ;
75142: LD_ADDR_VAR 0 5
75146: PUSH
75147: EMPTY
75148: ST_TO_ADDR
// for i in list do
75149: LD_ADDR_VAR 0 6
75153: PUSH
75154: LD_VAR 0 2
75158: PUSH
75159: FOR_IN
75160: IFFALSE 75378
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
75162: LD_ADDR_VAR 0 8
75166: PUSH
75167: LD_VAR 0 1
75171: PPUSH
75172: LD_VAR 0 6
75176: PUSH
75177: LD_INT 1
75179: ARRAY
75180: PPUSH
75181: LD_VAR 0 6
75185: PUSH
75186: LD_INT 2
75188: ARRAY
75189: PPUSH
75190: CALL_OW 297
75194: ST_TO_ADDR
// if not Count ( result ) then
75195: LD_VAR 0 5
75199: PPUSH
75200: CALL 71772 0 1
75204: NOT
75205: IFFALSE 75238
// begin result := Join ( result , [ i , tmp ] ) ;
75207: LD_ADDR_VAR 0 5
75211: PUSH
75212: LD_VAR 0 5
75216: PPUSH
75217: LD_VAR 0 6
75221: PUSH
75222: LD_VAR 0 8
75226: PUSH
75227: EMPTY
75228: LIST
75229: LIST
75230: PPUSH
75231: CALL 107361 0 2
75235: ST_TO_ADDR
// continue ;
75236: GO 75159
// end ; if result [ result ] [ 2 ] <= tmp then
75238: LD_VAR 0 5
75242: PUSH
75243: LD_VAR 0 5
75247: ARRAY
75248: PUSH
75249: LD_INT 2
75251: ARRAY
75252: PUSH
75253: LD_VAR 0 8
75257: LESSEQUAL
75258: IFFALSE 75291
// result := Join ( result , [ i , tmp ] ) else
75260: LD_ADDR_VAR 0 5
75264: PUSH
75265: LD_VAR 0 5
75269: PPUSH
75270: LD_VAR 0 6
75274: PUSH
75275: LD_VAR 0 8
75279: PUSH
75280: EMPTY
75281: LIST
75282: LIST
75283: PPUSH
75284: CALL 107361 0 2
75288: ST_TO_ADDR
75289: GO 75376
// begin for j := 1 to Count ( result ) do
75291: LD_ADDR_VAR 0 7
75295: PUSH
75296: DOUBLE
75297: LD_INT 1
75299: DEC
75300: ST_TO_ADDR
75301: LD_VAR 0 5
75305: PPUSH
75306: CALL 71772 0 1
75310: PUSH
75311: FOR_TO
75312: IFFALSE 75374
// begin if tmp < result [ j ] [ 2 ] then
75314: LD_VAR 0 8
75318: PUSH
75319: LD_VAR 0 5
75323: PUSH
75324: LD_VAR 0 7
75328: ARRAY
75329: PUSH
75330: LD_INT 2
75332: ARRAY
75333: LESS
75334: IFFALSE 75372
// begin result := Insert ( result , j , [ i , tmp ] ) ;
75336: LD_ADDR_VAR 0 5
75340: PUSH
75341: LD_VAR 0 5
75345: PPUSH
75346: LD_VAR 0 7
75350: PPUSH
75351: LD_VAR 0 6
75355: PUSH
75356: LD_VAR 0 8
75360: PUSH
75361: EMPTY
75362: LIST
75363: LIST
75364: PPUSH
75365: CALL_OW 2
75369: ST_TO_ADDR
// break ;
75370: GO 75374
// end ; end ;
75372: GO 75311
75374: POP
75375: POP
// end ; end ;
75376: GO 75159
75378: POP
75379: POP
// if result and not asc then
75380: LD_VAR 0 5
75384: PUSH
75385: LD_VAR 0 3
75389: NOT
75390: AND
75391: IFFALSE 75408
// result := ReverseArray ( result ) ;
75393: LD_ADDR_VAR 0 5
75397: PUSH
75398: LD_VAR 0 5
75402: PPUSH
75403: CALL 102648 0 1
75407: ST_TO_ADDR
// tmp := [ ] ;
75408: LD_ADDR_VAR 0 8
75412: PUSH
75413: EMPTY
75414: ST_TO_ADDR
// if mode then
75415: LD_VAR 0 4
75419: IFFALSE 75483
// begin for i := 1 to result do
75421: LD_ADDR_VAR 0 6
75425: PUSH
75426: DOUBLE
75427: LD_INT 1
75429: DEC
75430: ST_TO_ADDR
75431: LD_VAR 0 5
75435: PUSH
75436: FOR_TO
75437: IFFALSE 75471
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
75439: LD_ADDR_VAR 0 8
75443: PUSH
75444: LD_VAR 0 8
75448: PPUSH
75449: LD_VAR 0 5
75453: PUSH
75454: LD_VAR 0 6
75458: ARRAY
75459: PUSH
75460: LD_INT 1
75462: ARRAY
75463: PPUSH
75464: CALL 107361 0 2
75468: ST_TO_ADDR
75469: GO 75436
75471: POP
75472: POP
// result := tmp ;
75473: LD_ADDR_VAR 0 5
75477: PUSH
75478: LD_VAR 0 8
75482: ST_TO_ADDR
// end ; end ;
75483: LD_VAR 0 5
75487: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
75488: LD_INT 0
75490: PPUSH
75491: PPUSH
75492: PPUSH
75493: PPUSH
// if not list then
75494: LD_VAR 0 3
75498: NOT
75499: IFFALSE 75503
// exit ;
75501: GO 75891
// result := [ ] ;
75503: LD_ADDR_VAR 0 6
75507: PUSH
75508: EMPTY
75509: ST_TO_ADDR
// for i in list do
75510: LD_ADDR_VAR 0 7
75514: PUSH
75515: LD_VAR 0 3
75519: PUSH
75520: FOR_IN
75521: IFFALSE 75723
// begin tmp := GetDistUnitXY ( i , x , y ) ;
75523: LD_ADDR_VAR 0 9
75527: PUSH
75528: LD_VAR 0 7
75532: PPUSH
75533: LD_VAR 0 1
75537: PPUSH
75538: LD_VAR 0 2
75542: PPUSH
75543: CALL_OW 297
75547: ST_TO_ADDR
// if not result then
75548: LD_VAR 0 6
75552: NOT
75553: IFFALSE 75579
// result := [ [ i , tmp ] ] else
75555: LD_ADDR_VAR 0 6
75559: PUSH
75560: LD_VAR 0 7
75564: PUSH
75565: LD_VAR 0 9
75569: PUSH
75570: EMPTY
75571: LIST
75572: LIST
75573: PUSH
75574: EMPTY
75575: LIST
75576: ST_TO_ADDR
75577: GO 75721
// begin if result [ result ] [ 2 ] < tmp then
75579: LD_VAR 0 6
75583: PUSH
75584: LD_VAR 0 6
75588: ARRAY
75589: PUSH
75590: LD_INT 2
75592: ARRAY
75593: PUSH
75594: LD_VAR 0 9
75598: LESS
75599: IFFALSE 75641
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
75601: LD_ADDR_VAR 0 6
75605: PUSH
75606: LD_VAR 0 6
75610: PPUSH
75611: LD_VAR 0 6
75615: PUSH
75616: LD_INT 1
75618: PLUS
75619: PPUSH
75620: LD_VAR 0 7
75624: PUSH
75625: LD_VAR 0 9
75629: PUSH
75630: EMPTY
75631: LIST
75632: LIST
75633: PPUSH
75634: CALL_OW 2
75638: ST_TO_ADDR
75639: GO 75721
// for j = 1 to result do
75641: LD_ADDR_VAR 0 8
75645: PUSH
75646: DOUBLE
75647: LD_INT 1
75649: DEC
75650: ST_TO_ADDR
75651: LD_VAR 0 6
75655: PUSH
75656: FOR_TO
75657: IFFALSE 75719
// begin if tmp < result [ j ] [ 2 ] then
75659: LD_VAR 0 9
75663: PUSH
75664: LD_VAR 0 6
75668: PUSH
75669: LD_VAR 0 8
75673: ARRAY
75674: PUSH
75675: LD_INT 2
75677: ARRAY
75678: LESS
75679: IFFALSE 75717
// begin result := Insert ( result , j , [ i , tmp ] ) ;
75681: LD_ADDR_VAR 0 6
75685: PUSH
75686: LD_VAR 0 6
75690: PPUSH
75691: LD_VAR 0 8
75695: PPUSH
75696: LD_VAR 0 7
75700: PUSH
75701: LD_VAR 0 9
75705: PUSH
75706: EMPTY
75707: LIST
75708: LIST
75709: PPUSH
75710: CALL_OW 2
75714: ST_TO_ADDR
// break ;
75715: GO 75719
// end ; end ;
75717: GO 75656
75719: POP
75720: POP
// end ; end ;
75721: GO 75520
75723: POP
75724: POP
// if result and not asc then
75725: LD_VAR 0 6
75729: PUSH
75730: LD_VAR 0 4
75734: NOT
75735: AND
75736: IFFALSE 75811
// begin tmp := result ;
75738: LD_ADDR_VAR 0 9
75742: PUSH
75743: LD_VAR 0 6
75747: ST_TO_ADDR
// for i = tmp downto 1 do
75748: LD_ADDR_VAR 0 7
75752: PUSH
75753: DOUBLE
75754: LD_VAR 0 9
75758: INC
75759: ST_TO_ADDR
75760: LD_INT 1
75762: PUSH
75763: FOR_DOWNTO
75764: IFFALSE 75809
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
75766: LD_ADDR_VAR 0 6
75770: PUSH
75771: LD_VAR 0 6
75775: PPUSH
75776: LD_VAR 0 9
75780: PUSH
75781: LD_VAR 0 7
75785: MINUS
75786: PUSH
75787: LD_INT 1
75789: PLUS
75790: PPUSH
75791: LD_VAR 0 9
75795: PUSH
75796: LD_VAR 0 7
75800: ARRAY
75801: PPUSH
75802: CALL_OW 1
75806: ST_TO_ADDR
75807: GO 75763
75809: POP
75810: POP
// end ; tmp := [ ] ;
75811: LD_ADDR_VAR 0 9
75815: PUSH
75816: EMPTY
75817: ST_TO_ADDR
// if mode then
75818: LD_VAR 0 5
75822: IFFALSE 75891
// begin for i = 1 to result do
75824: LD_ADDR_VAR 0 7
75828: PUSH
75829: DOUBLE
75830: LD_INT 1
75832: DEC
75833: ST_TO_ADDR
75834: LD_VAR 0 6
75838: PUSH
75839: FOR_TO
75840: IFFALSE 75879
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
75842: LD_ADDR_VAR 0 9
75846: PUSH
75847: LD_VAR 0 9
75851: PPUSH
75852: LD_VAR 0 7
75856: PPUSH
75857: LD_VAR 0 6
75861: PUSH
75862: LD_VAR 0 7
75866: ARRAY
75867: PUSH
75868: LD_INT 1
75870: ARRAY
75871: PPUSH
75872: CALL_OW 1
75876: ST_TO_ADDR
75877: GO 75839
75879: POP
75880: POP
// result := tmp ;
75881: LD_ADDR_VAR 0 6
75885: PUSH
75886: LD_VAR 0 9
75890: ST_TO_ADDR
// end ; end ;
75891: LD_VAR 0 6
75895: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
75896: LD_INT 0
75898: PPUSH
75899: PPUSH
75900: PPUSH
75901: PPUSH
75902: PPUSH
75903: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
75904: LD_ADDR_VAR 0 5
75908: PUSH
75909: LD_INT 0
75911: PUSH
75912: LD_INT 0
75914: PUSH
75915: LD_INT 0
75917: PUSH
75918: EMPTY
75919: PUSH
75920: EMPTY
75921: LIST
75922: LIST
75923: LIST
75924: LIST
75925: ST_TO_ADDR
// if not x or not y then
75926: LD_VAR 0 2
75930: NOT
75931: PUSH
75932: LD_VAR 0 3
75936: NOT
75937: OR
75938: IFFALSE 75942
// exit ;
75940: GO 77592
// if not range then
75942: LD_VAR 0 4
75946: NOT
75947: IFFALSE 75957
// range := 10 ;
75949: LD_ADDR_VAR 0 4
75953: PUSH
75954: LD_INT 10
75956: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
75957: LD_ADDR_VAR 0 8
75961: PUSH
75962: LD_INT 81
75964: PUSH
75965: LD_VAR 0 1
75969: PUSH
75970: EMPTY
75971: LIST
75972: LIST
75973: PUSH
75974: LD_INT 92
75976: PUSH
75977: LD_VAR 0 2
75981: PUSH
75982: LD_VAR 0 3
75986: PUSH
75987: LD_VAR 0 4
75991: PUSH
75992: EMPTY
75993: LIST
75994: LIST
75995: LIST
75996: LIST
75997: PUSH
75998: LD_INT 3
76000: PUSH
76001: LD_INT 21
76003: PUSH
76004: LD_INT 3
76006: PUSH
76007: EMPTY
76008: LIST
76009: LIST
76010: PUSH
76011: EMPTY
76012: LIST
76013: LIST
76014: PUSH
76015: EMPTY
76016: LIST
76017: LIST
76018: LIST
76019: PPUSH
76020: CALL_OW 69
76024: ST_TO_ADDR
// if not tmp then
76025: LD_VAR 0 8
76029: NOT
76030: IFFALSE 76034
// exit ;
76032: GO 77592
// for i in tmp do
76034: LD_ADDR_VAR 0 6
76038: PUSH
76039: LD_VAR 0 8
76043: PUSH
76044: FOR_IN
76045: IFFALSE 77567
// begin points := [ 0 , 0 , 0 ] ;
76047: LD_ADDR_VAR 0 9
76051: PUSH
76052: LD_INT 0
76054: PUSH
76055: LD_INT 0
76057: PUSH
76058: LD_INT 0
76060: PUSH
76061: EMPTY
76062: LIST
76063: LIST
76064: LIST
76065: ST_TO_ADDR
// bpoints := 1 ;
76066: LD_ADDR_VAR 0 10
76070: PUSH
76071: LD_INT 1
76073: ST_TO_ADDR
// case GetType ( i ) of unit_human :
76074: LD_VAR 0 6
76078: PPUSH
76079: CALL_OW 247
76083: PUSH
76084: LD_INT 1
76086: DOUBLE
76087: EQUAL
76088: IFTRUE 76092
76090: GO 76670
76092: POP
// begin if GetClass ( i ) = 1 then
76093: LD_VAR 0 6
76097: PPUSH
76098: CALL_OW 257
76102: PUSH
76103: LD_INT 1
76105: EQUAL
76106: IFFALSE 76127
// points := [ 10 , 5 , 3 ] ;
76108: LD_ADDR_VAR 0 9
76112: PUSH
76113: LD_INT 10
76115: PUSH
76116: LD_INT 5
76118: PUSH
76119: LD_INT 3
76121: PUSH
76122: EMPTY
76123: LIST
76124: LIST
76125: LIST
76126: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
76127: LD_VAR 0 6
76131: PPUSH
76132: CALL_OW 257
76136: PUSH
76137: LD_INT 2
76139: PUSH
76140: LD_INT 3
76142: PUSH
76143: LD_INT 4
76145: PUSH
76146: EMPTY
76147: LIST
76148: LIST
76149: LIST
76150: IN
76151: IFFALSE 76172
// points := [ 3 , 2 , 1 ] ;
76153: LD_ADDR_VAR 0 9
76157: PUSH
76158: LD_INT 3
76160: PUSH
76161: LD_INT 2
76163: PUSH
76164: LD_INT 1
76166: PUSH
76167: EMPTY
76168: LIST
76169: LIST
76170: LIST
76171: ST_TO_ADDR
// if GetClass ( i ) = 5 then
76172: LD_VAR 0 6
76176: PPUSH
76177: CALL_OW 257
76181: PUSH
76182: LD_INT 5
76184: EQUAL
76185: IFFALSE 76206
// points := [ 130 , 5 , 2 ] ;
76187: LD_ADDR_VAR 0 9
76191: PUSH
76192: LD_INT 130
76194: PUSH
76195: LD_INT 5
76197: PUSH
76198: LD_INT 2
76200: PUSH
76201: EMPTY
76202: LIST
76203: LIST
76204: LIST
76205: ST_TO_ADDR
// if GetClass ( i ) = 8 then
76206: LD_VAR 0 6
76210: PPUSH
76211: CALL_OW 257
76215: PUSH
76216: LD_INT 8
76218: EQUAL
76219: IFFALSE 76240
// points := [ 35 , 35 , 30 ] ;
76221: LD_ADDR_VAR 0 9
76225: PUSH
76226: LD_INT 35
76228: PUSH
76229: LD_INT 35
76231: PUSH
76232: LD_INT 30
76234: PUSH
76235: EMPTY
76236: LIST
76237: LIST
76238: LIST
76239: ST_TO_ADDR
// if GetClass ( i ) = 9 then
76240: LD_VAR 0 6
76244: PPUSH
76245: CALL_OW 257
76249: PUSH
76250: LD_INT 9
76252: EQUAL
76253: IFFALSE 76274
// points := [ 20 , 55 , 40 ] ;
76255: LD_ADDR_VAR 0 9
76259: PUSH
76260: LD_INT 20
76262: PUSH
76263: LD_INT 55
76265: PUSH
76266: LD_INT 40
76268: PUSH
76269: EMPTY
76270: LIST
76271: LIST
76272: LIST
76273: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
76274: LD_VAR 0 6
76278: PPUSH
76279: CALL_OW 257
76283: PUSH
76284: LD_INT 12
76286: PUSH
76287: LD_INT 16
76289: PUSH
76290: EMPTY
76291: LIST
76292: LIST
76293: IN
76294: IFFALSE 76315
// points := [ 5 , 3 , 2 ] ;
76296: LD_ADDR_VAR 0 9
76300: PUSH
76301: LD_INT 5
76303: PUSH
76304: LD_INT 3
76306: PUSH
76307: LD_INT 2
76309: PUSH
76310: EMPTY
76311: LIST
76312: LIST
76313: LIST
76314: ST_TO_ADDR
// if GetClass ( i ) = 17 then
76315: LD_VAR 0 6
76319: PPUSH
76320: CALL_OW 257
76324: PUSH
76325: LD_INT 17
76327: EQUAL
76328: IFFALSE 76349
// points := [ 100 , 50 , 75 ] ;
76330: LD_ADDR_VAR 0 9
76334: PUSH
76335: LD_INT 100
76337: PUSH
76338: LD_INT 50
76340: PUSH
76341: LD_INT 75
76343: PUSH
76344: EMPTY
76345: LIST
76346: LIST
76347: LIST
76348: ST_TO_ADDR
// if GetClass ( i ) = 15 then
76349: LD_VAR 0 6
76353: PPUSH
76354: CALL_OW 257
76358: PUSH
76359: LD_INT 15
76361: EQUAL
76362: IFFALSE 76383
// points := [ 10 , 5 , 3 ] ;
76364: LD_ADDR_VAR 0 9
76368: PUSH
76369: LD_INT 10
76371: PUSH
76372: LD_INT 5
76374: PUSH
76375: LD_INT 3
76377: PUSH
76378: EMPTY
76379: LIST
76380: LIST
76381: LIST
76382: ST_TO_ADDR
// if GetClass ( i ) = 14 then
76383: LD_VAR 0 6
76387: PPUSH
76388: CALL_OW 257
76392: PUSH
76393: LD_INT 14
76395: EQUAL
76396: IFFALSE 76417
// points := [ 10 , 0 , 0 ] ;
76398: LD_ADDR_VAR 0 9
76402: PUSH
76403: LD_INT 10
76405: PUSH
76406: LD_INT 0
76408: PUSH
76409: LD_INT 0
76411: PUSH
76412: EMPTY
76413: LIST
76414: LIST
76415: LIST
76416: ST_TO_ADDR
// if GetClass ( i ) = 11 then
76417: LD_VAR 0 6
76421: PPUSH
76422: CALL_OW 257
76426: PUSH
76427: LD_INT 11
76429: EQUAL
76430: IFFALSE 76451
// points := [ 30 , 10 , 5 ] ;
76432: LD_ADDR_VAR 0 9
76436: PUSH
76437: LD_INT 30
76439: PUSH
76440: LD_INT 10
76442: PUSH
76443: LD_INT 5
76445: PUSH
76446: EMPTY
76447: LIST
76448: LIST
76449: LIST
76450: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
76451: LD_VAR 0 1
76455: PPUSH
76456: LD_INT 5
76458: PPUSH
76459: CALL_OW 321
76463: PUSH
76464: LD_INT 2
76466: EQUAL
76467: IFFALSE 76484
// bpoints := bpoints * 1.8 ;
76469: LD_ADDR_VAR 0 10
76473: PUSH
76474: LD_VAR 0 10
76478: PUSH
76479: LD_REAL  1.80000000000000E+0000
76482: MUL
76483: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
76484: LD_VAR 0 6
76488: PPUSH
76489: CALL_OW 257
76493: PUSH
76494: LD_INT 1
76496: PUSH
76497: LD_INT 2
76499: PUSH
76500: LD_INT 3
76502: PUSH
76503: LD_INT 4
76505: PUSH
76506: EMPTY
76507: LIST
76508: LIST
76509: LIST
76510: LIST
76511: IN
76512: PUSH
76513: LD_VAR 0 1
76517: PPUSH
76518: LD_INT 51
76520: PPUSH
76521: CALL_OW 321
76525: PUSH
76526: LD_INT 2
76528: EQUAL
76529: AND
76530: IFFALSE 76547
// bpoints := bpoints * 1.2 ;
76532: LD_ADDR_VAR 0 10
76536: PUSH
76537: LD_VAR 0 10
76541: PUSH
76542: LD_REAL  1.20000000000000E+0000
76545: MUL
76546: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
76547: LD_VAR 0 6
76551: PPUSH
76552: CALL_OW 257
76556: PUSH
76557: LD_INT 5
76559: PUSH
76560: LD_INT 7
76562: PUSH
76563: LD_INT 9
76565: PUSH
76566: EMPTY
76567: LIST
76568: LIST
76569: LIST
76570: IN
76571: PUSH
76572: LD_VAR 0 1
76576: PPUSH
76577: LD_INT 52
76579: PPUSH
76580: CALL_OW 321
76584: PUSH
76585: LD_INT 2
76587: EQUAL
76588: AND
76589: IFFALSE 76606
// bpoints := bpoints * 1.5 ;
76591: LD_ADDR_VAR 0 10
76595: PUSH
76596: LD_VAR 0 10
76600: PUSH
76601: LD_REAL  1.50000000000000E+0000
76604: MUL
76605: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
76606: LD_VAR 0 1
76610: PPUSH
76611: LD_INT 66
76613: PPUSH
76614: CALL_OW 321
76618: PUSH
76619: LD_INT 2
76621: EQUAL
76622: IFFALSE 76639
// bpoints := bpoints * 1.1 ;
76624: LD_ADDR_VAR 0 10
76628: PUSH
76629: LD_VAR 0 10
76633: PUSH
76634: LD_REAL  1.10000000000000E+0000
76637: MUL
76638: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
76639: LD_ADDR_VAR 0 10
76643: PUSH
76644: LD_VAR 0 10
76648: PUSH
76649: LD_VAR 0 6
76653: PPUSH
76654: LD_INT 1
76656: PPUSH
76657: CALL_OW 259
76661: PUSH
76662: LD_REAL  1.15000000000000E+0000
76665: MUL
76666: MUL
76667: ST_TO_ADDR
// end ; unit_vehicle :
76668: GO 77496
76670: LD_INT 2
76672: DOUBLE
76673: EQUAL
76674: IFTRUE 76678
76676: GO 77484
76678: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
76679: LD_VAR 0 6
76683: PPUSH
76684: CALL_OW 264
76688: PUSH
76689: LD_INT 2
76691: PUSH
76692: LD_INT 42
76694: PUSH
76695: LD_INT 24
76697: PUSH
76698: EMPTY
76699: LIST
76700: LIST
76701: LIST
76702: IN
76703: IFFALSE 76724
// points := [ 25 , 5 , 3 ] ;
76705: LD_ADDR_VAR 0 9
76709: PUSH
76710: LD_INT 25
76712: PUSH
76713: LD_INT 5
76715: PUSH
76716: LD_INT 3
76718: PUSH
76719: EMPTY
76720: LIST
76721: LIST
76722: LIST
76723: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
76724: LD_VAR 0 6
76728: PPUSH
76729: CALL_OW 264
76733: PUSH
76734: LD_INT 4
76736: PUSH
76737: LD_INT 43
76739: PUSH
76740: LD_INT 25
76742: PUSH
76743: EMPTY
76744: LIST
76745: LIST
76746: LIST
76747: IN
76748: IFFALSE 76769
// points := [ 40 , 15 , 5 ] ;
76750: LD_ADDR_VAR 0 9
76754: PUSH
76755: LD_INT 40
76757: PUSH
76758: LD_INT 15
76760: PUSH
76761: LD_INT 5
76763: PUSH
76764: EMPTY
76765: LIST
76766: LIST
76767: LIST
76768: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
76769: LD_VAR 0 6
76773: PPUSH
76774: CALL_OW 264
76778: PUSH
76779: LD_INT 3
76781: PUSH
76782: LD_INT 23
76784: PUSH
76785: EMPTY
76786: LIST
76787: LIST
76788: IN
76789: IFFALSE 76810
// points := [ 7 , 25 , 8 ] ;
76791: LD_ADDR_VAR 0 9
76795: PUSH
76796: LD_INT 7
76798: PUSH
76799: LD_INT 25
76801: PUSH
76802: LD_INT 8
76804: PUSH
76805: EMPTY
76806: LIST
76807: LIST
76808: LIST
76809: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
76810: LD_VAR 0 6
76814: PPUSH
76815: CALL_OW 264
76819: PUSH
76820: LD_INT 5
76822: PUSH
76823: LD_INT 27
76825: PUSH
76826: LD_INT 44
76828: PUSH
76829: EMPTY
76830: LIST
76831: LIST
76832: LIST
76833: IN
76834: IFFALSE 76855
// points := [ 14 , 50 , 16 ] ;
76836: LD_ADDR_VAR 0 9
76840: PUSH
76841: LD_INT 14
76843: PUSH
76844: LD_INT 50
76846: PUSH
76847: LD_INT 16
76849: PUSH
76850: EMPTY
76851: LIST
76852: LIST
76853: LIST
76854: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
76855: LD_VAR 0 6
76859: PPUSH
76860: CALL_OW 264
76864: PUSH
76865: LD_INT 6
76867: PUSH
76868: LD_INT 46
76870: PUSH
76871: EMPTY
76872: LIST
76873: LIST
76874: IN
76875: IFFALSE 76896
// points := [ 32 , 120 , 70 ] ;
76877: LD_ADDR_VAR 0 9
76881: PUSH
76882: LD_INT 32
76884: PUSH
76885: LD_INT 120
76887: PUSH
76888: LD_INT 70
76890: PUSH
76891: EMPTY
76892: LIST
76893: LIST
76894: LIST
76895: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
76896: LD_VAR 0 6
76900: PPUSH
76901: CALL_OW 264
76905: PUSH
76906: LD_INT 7
76908: PUSH
76909: LD_INT 28
76911: PUSH
76912: LD_INT 45
76914: PUSH
76915: LD_INT 92
76917: PUSH
76918: EMPTY
76919: LIST
76920: LIST
76921: LIST
76922: LIST
76923: IN
76924: IFFALSE 76945
// points := [ 35 , 20 , 45 ] ;
76926: LD_ADDR_VAR 0 9
76930: PUSH
76931: LD_INT 35
76933: PUSH
76934: LD_INT 20
76936: PUSH
76937: LD_INT 45
76939: PUSH
76940: EMPTY
76941: LIST
76942: LIST
76943: LIST
76944: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
76945: LD_VAR 0 6
76949: PPUSH
76950: CALL_OW 264
76954: PUSH
76955: LD_INT 47
76957: PUSH
76958: EMPTY
76959: LIST
76960: IN
76961: IFFALSE 76982
// points := [ 67 , 45 , 75 ] ;
76963: LD_ADDR_VAR 0 9
76967: PUSH
76968: LD_INT 67
76970: PUSH
76971: LD_INT 45
76973: PUSH
76974: LD_INT 75
76976: PUSH
76977: EMPTY
76978: LIST
76979: LIST
76980: LIST
76981: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
76982: LD_VAR 0 6
76986: PPUSH
76987: CALL_OW 264
76991: PUSH
76992: LD_INT 26
76994: PUSH
76995: EMPTY
76996: LIST
76997: IN
76998: IFFALSE 77019
// points := [ 120 , 30 , 80 ] ;
77000: LD_ADDR_VAR 0 9
77004: PUSH
77005: LD_INT 120
77007: PUSH
77008: LD_INT 30
77010: PUSH
77011: LD_INT 80
77013: PUSH
77014: EMPTY
77015: LIST
77016: LIST
77017: LIST
77018: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
77019: LD_VAR 0 6
77023: PPUSH
77024: CALL_OW 264
77028: PUSH
77029: LD_INT 22
77031: PUSH
77032: EMPTY
77033: LIST
77034: IN
77035: IFFALSE 77056
// points := [ 40 , 1 , 1 ] ;
77037: LD_ADDR_VAR 0 9
77041: PUSH
77042: LD_INT 40
77044: PUSH
77045: LD_INT 1
77047: PUSH
77048: LD_INT 1
77050: PUSH
77051: EMPTY
77052: LIST
77053: LIST
77054: LIST
77055: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
77056: LD_VAR 0 6
77060: PPUSH
77061: CALL_OW 264
77065: PUSH
77066: LD_INT 29
77068: PUSH
77069: EMPTY
77070: LIST
77071: IN
77072: IFFALSE 77093
// points := [ 70 , 200 , 400 ] ;
77074: LD_ADDR_VAR 0 9
77078: PUSH
77079: LD_INT 70
77081: PUSH
77082: LD_INT 200
77084: PUSH
77085: LD_INT 400
77087: PUSH
77088: EMPTY
77089: LIST
77090: LIST
77091: LIST
77092: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
77093: LD_VAR 0 6
77097: PPUSH
77098: CALL_OW 264
77102: PUSH
77103: LD_INT 14
77105: PUSH
77106: LD_INT 53
77108: PUSH
77109: EMPTY
77110: LIST
77111: LIST
77112: IN
77113: IFFALSE 77134
// points := [ 40 , 10 , 20 ] ;
77115: LD_ADDR_VAR 0 9
77119: PUSH
77120: LD_INT 40
77122: PUSH
77123: LD_INT 10
77125: PUSH
77126: LD_INT 20
77128: PUSH
77129: EMPTY
77130: LIST
77131: LIST
77132: LIST
77133: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
77134: LD_VAR 0 6
77138: PPUSH
77139: CALL_OW 264
77143: PUSH
77144: LD_INT 9
77146: PUSH
77147: EMPTY
77148: LIST
77149: IN
77150: IFFALSE 77171
// points := [ 5 , 70 , 20 ] ;
77152: LD_ADDR_VAR 0 9
77156: PUSH
77157: LD_INT 5
77159: PUSH
77160: LD_INT 70
77162: PUSH
77163: LD_INT 20
77165: PUSH
77166: EMPTY
77167: LIST
77168: LIST
77169: LIST
77170: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
77171: LD_VAR 0 6
77175: PPUSH
77176: CALL_OW 264
77180: PUSH
77181: LD_INT 10
77183: PUSH
77184: EMPTY
77185: LIST
77186: IN
77187: IFFALSE 77208
// points := [ 35 , 110 , 70 ] ;
77189: LD_ADDR_VAR 0 9
77193: PUSH
77194: LD_INT 35
77196: PUSH
77197: LD_INT 110
77199: PUSH
77200: LD_INT 70
77202: PUSH
77203: EMPTY
77204: LIST
77205: LIST
77206: LIST
77207: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
77208: LD_VAR 0 6
77212: PPUSH
77213: CALL_OW 265
77217: PUSH
77218: LD_INT 25
77220: EQUAL
77221: IFFALSE 77242
// points := [ 80 , 65 , 100 ] ;
77223: LD_ADDR_VAR 0 9
77227: PUSH
77228: LD_INT 80
77230: PUSH
77231: LD_INT 65
77233: PUSH
77234: LD_INT 100
77236: PUSH
77237: EMPTY
77238: LIST
77239: LIST
77240: LIST
77241: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
77242: LD_VAR 0 6
77246: PPUSH
77247: CALL_OW 263
77251: PUSH
77252: LD_INT 1
77254: EQUAL
77255: IFFALSE 77290
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
77257: LD_ADDR_VAR 0 10
77261: PUSH
77262: LD_VAR 0 10
77266: PUSH
77267: LD_VAR 0 6
77271: PPUSH
77272: CALL_OW 311
77276: PPUSH
77277: LD_INT 3
77279: PPUSH
77280: CALL_OW 259
77284: PUSH
77285: LD_INT 4
77287: MUL
77288: MUL
77289: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
77290: LD_VAR 0 6
77294: PPUSH
77295: CALL_OW 263
77299: PUSH
77300: LD_INT 2
77302: EQUAL
77303: IFFALSE 77354
// begin j := IsControledBy ( i ) ;
77305: LD_ADDR_VAR 0 7
77309: PUSH
77310: LD_VAR 0 6
77314: PPUSH
77315: CALL_OW 312
77319: ST_TO_ADDR
// if j then
77320: LD_VAR 0 7
77324: IFFALSE 77354
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
77326: LD_ADDR_VAR 0 10
77330: PUSH
77331: LD_VAR 0 10
77335: PUSH
77336: LD_VAR 0 7
77340: PPUSH
77341: LD_INT 3
77343: PPUSH
77344: CALL_OW 259
77348: PUSH
77349: LD_INT 3
77351: MUL
77352: MUL
77353: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
77354: LD_VAR 0 6
77358: PPUSH
77359: CALL_OW 264
77363: PUSH
77364: LD_INT 5
77366: PUSH
77367: LD_INT 6
77369: PUSH
77370: LD_INT 46
77372: PUSH
77373: LD_INT 44
77375: PUSH
77376: LD_INT 47
77378: PUSH
77379: LD_INT 45
77381: PUSH
77382: LD_INT 28
77384: PUSH
77385: LD_INT 7
77387: PUSH
77388: LD_INT 27
77390: PUSH
77391: LD_INT 29
77393: PUSH
77394: EMPTY
77395: LIST
77396: LIST
77397: LIST
77398: LIST
77399: LIST
77400: LIST
77401: LIST
77402: LIST
77403: LIST
77404: LIST
77405: IN
77406: PUSH
77407: LD_VAR 0 1
77411: PPUSH
77412: LD_INT 52
77414: PPUSH
77415: CALL_OW 321
77419: PUSH
77420: LD_INT 2
77422: EQUAL
77423: AND
77424: IFFALSE 77441
// bpoints := bpoints * 1.2 ;
77426: LD_ADDR_VAR 0 10
77430: PUSH
77431: LD_VAR 0 10
77435: PUSH
77436: LD_REAL  1.20000000000000E+0000
77439: MUL
77440: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
77441: LD_VAR 0 6
77445: PPUSH
77446: CALL_OW 264
77450: PUSH
77451: LD_INT 6
77453: PUSH
77454: LD_INT 46
77456: PUSH
77457: LD_INT 47
77459: PUSH
77460: EMPTY
77461: LIST
77462: LIST
77463: LIST
77464: IN
77465: IFFALSE 77482
// bpoints := bpoints * 1.2 ;
77467: LD_ADDR_VAR 0 10
77471: PUSH
77472: LD_VAR 0 10
77476: PUSH
77477: LD_REAL  1.20000000000000E+0000
77480: MUL
77481: ST_TO_ADDR
// end ; unit_building :
77482: GO 77496
77484: LD_INT 3
77486: DOUBLE
77487: EQUAL
77488: IFTRUE 77492
77490: GO 77495
77492: POP
// ; end ;
77493: GO 77496
77495: POP
// for j = 1 to 3 do
77496: LD_ADDR_VAR 0 7
77500: PUSH
77501: DOUBLE
77502: LD_INT 1
77504: DEC
77505: ST_TO_ADDR
77506: LD_INT 3
77508: PUSH
77509: FOR_TO
77510: IFFALSE 77563
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
77512: LD_ADDR_VAR 0 5
77516: PUSH
77517: LD_VAR 0 5
77521: PPUSH
77522: LD_VAR 0 7
77526: PPUSH
77527: LD_VAR 0 5
77531: PUSH
77532: LD_VAR 0 7
77536: ARRAY
77537: PUSH
77538: LD_VAR 0 9
77542: PUSH
77543: LD_VAR 0 7
77547: ARRAY
77548: PUSH
77549: LD_VAR 0 10
77553: MUL
77554: PLUS
77555: PPUSH
77556: CALL_OW 1
77560: ST_TO_ADDR
77561: GO 77509
77563: POP
77564: POP
// end ;
77565: GO 76044
77567: POP
77568: POP
// result := Replace ( result , 4 , tmp ) ;
77569: LD_ADDR_VAR 0 5
77573: PUSH
77574: LD_VAR 0 5
77578: PPUSH
77579: LD_INT 4
77581: PPUSH
77582: LD_VAR 0 8
77586: PPUSH
77587: CALL_OW 1
77591: ST_TO_ADDR
// end ;
77592: LD_VAR 0 5
77596: RET
// export function DangerAtRange ( unit , range ) ; begin
77597: LD_INT 0
77599: PPUSH
// if not unit then
77600: LD_VAR 0 1
77604: NOT
77605: IFFALSE 77609
// exit ;
77607: GO 77654
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
77609: LD_ADDR_VAR 0 3
77613: PUSH
77614: LD_VAR 0 1
77618: PPUSH
77619: CALL_OW 255
77623: PPUSH
77624: LD_VAR 0 1
77628: PPUSH
77629: CALL_OW 250
77633: PPUSH
77634: LD_VAR 0 1
77638: PPUSH
77639: CALL_OW 251
77643: PPUSH
77644: LD_VAR 0 2
77648: PPUSH
77649: CALL 75896 0 4
77653: ST_TO_ADDR
// end ;
77654: LD_VAR 0 3
77658: RET
// export function DangerInArea ( side , area ) ; begin
77659: LD_INT 0
77661: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
77662: LD_ADDR_VAR 0 3
77666: PUSH
77667: LD_VAR 0 2
77671: PPUSH
77672: LD_INT 81
77674: PUSH
77675: LD_VAR 0 1
77679: PUSH
77680: EMPTY
77681: LIST
77682: LIST
77683: PPUSH
77684: CALL_OW 70
77688: ST_TO_ADDR
// end ;
77689: LD_VAR 0 3
77693: RET
// export function IsExtension ( b ) ; begin
77694: LD_INT 0
77696: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
77697: LD_ADDR_VAR 0 2
77701: PUSH
77702: LD_VAR 0 1
77706: PUSH
77707: LD_INT 23
77709: PUSH
77710: LD_INT 20
77712: PUSH
77713: LD_INT 22
77715: PUSH
77716: LD_INT 17
77718: PUSH
77719: LD_INT 24
77721: PUSH
77722: LD_INT 21
77724: PUSH
77725: LD_INT 19
77727: PUSH
77728: LD_INT 16
77730: PUSH
77731: LD_INT 25
77733: PUSH
77734: LD_INT 18
77736: PUSH
77737: EMPTY
77738: LIST
77739: LIST
77740: LIST
77741: LIST
77742: LIST
77743: LIST
77744: LIST
77745: LIST
77746: LIST
77747: LIST
77748: IN
77749: ST_TO_ADDR
// end ;
77750: LD_VAR 0 2
77754: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
77755: LD_INT 0
77757: PPUSH
77758: PPUSH
77759: PPUSH
// result := [ ] ;
77760: LD_ADDR_VAR 0 4
77764: PUSH
77765: EMPTY
77766: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
77767: LD_ADDR_VAR 0 5
77771: PUSH
77772: LD_VAR 0 2
77776: PPUSH
77777: LD_INT 21
77779: PUSH
77780: LD_INT 3
77782: PUSH
77783: EMPTY
77784: LIST
77785: LIST
77786: PPUSH
77787: CALL_OW 70
77791: ST_TO_ADDR
// if not tmp then
77792: LD_VAR 0 5
77796: NOT
77797: IFFALSE 77801
// exit ;
77799: GO 77865
// if checkLink then
77801: LD_VAR 0 3
77805: IFFALSE 77855
// begin for i in tmp do
77807: LD_ADDR_VAR 0 6
77811: PUSH
77812: LD_VAR 0 5
77816: PUSH
77817: FOR_IN
77818: IFFALSE 77853
// if GetBase ( i ) <> base then
77820: LD_VAR 0 6
77824: PPUSH
77825: CALL_OW 274
77829: PUSH
77830: LD_VAR 0 1
77834: NONEQUAL
77835: IFFALSE 77851
// ComLinkToBase ( base , i ) ;
77837: LD_VAR 0 1
77841: PPUSH
77842: LD_VAR 0 6
77846: PPUSH
77847: CALL_OW 169
77851: GO 77817
77853: POP
77854: POP
// end ; result := tmp ;
77855: LD_ADDR_VAR 0 4
77859: PUSH
77860: LD_VAR 0 5
77864: ST_TO_ADDR
// end ;
77865: LD_VAR 0 4
77869: RET
// export function ComComplete ( units , b ) ; var i ; begin
77870: LD_INT 0
77872: PPUSH
77873: PPUSH
// if not units then
77874: LD_VAR 0 1
77878: NOT
77879: IFFALSE 77883
// exit ;
77881: GO 77973
// for i in units do
77883: LD_ADDR_VAR 0 4
77887: PUSH
77888: LD_VAR 0 1
77892: PUSH
77893: FOR_IN
77894: IFFALSE 77971
// if BuildingStatus ( b ) = bs_build then
77896: LD_VAR 0 2
77900: PPUSH
77901: CALL_OW 461
77905: PUSH
77906: LD_INT 1
77908: EQUAL
77909: IFFALSE 77969
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
77911: LD_VAR 0 4
77915: PPUSH
77916: LD_STRING h
77918: PUSH
77919: LD_VAR 0 2
77923: PPUSH
77924: CALL_OW 250
77928: PUSH
77929: LD_VAR 0 2
77933: PPUSH
77934: CALL_OW 251
77938: PUSH
77939: LD_VAR 0 2
77943: PUSH
77944: LD_INT 0
77946: PUSH
77947: LD_INT 0
77949: PUSH
77950: LD_INT 0
77952: PUSH
77953: EMPTY
77954: LIST
77955: LIST
77956: LIST
77957: LIST
77958: LIST
77959: LIST
77960: LIST
77961: PUSH
77962: EMPTY
77963: LIST
77964: PPUSH
77965: CALL_OW 446
77969: GO 77893
77971: POP
77972: POP
// end ;
77973: LD_VAR 0 3
77977: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
77978: LD_INT 0
77980: PPUSH
77981: PPUSH
77982: PPUSH
77983: PPUSH
77984: PPUSH
77985: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
77986: LD_VAR 0 1
77990: NOT
77991: PUSH
77992: LD_VAR 0 1
77996: PPUSH
77997: CALL_OW 263
78001: PUSH
78002: LD_INT 2
78004: NONEQUAL
78005: OR
78006: IFFALSE 78010
// exit ;
78008: GO 78326
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
78010: LD_ADDR_VAR 0 6
78014: PUSH
78015: LD_INT 22
78017: PUSH
78018: LD_VAR 0 1
78022: PPUSH
78023: CALL_OW 255
78027: PUSH
78028: EMPTY
78029: LIST
78030: LIST
78031: PUSH
78032: LD_INT 2
78034: PUSH
78035: LD_INT 30
78037: PUSH
78038: LD_INT 36
78040: PUSH
78041: EMPTY
78042: LIST
78043: LIST
78044: PUSH
78045: LD_INT 34
78047: PUSH
78048: LD_INT 31
78050: PUSH
78051: EMPTY
78052: LIST
78053: LIST
78054: PUSH
78055: EMPTY
78056: LIST
78057: LIST
78058: LIST
78059: PUSH
78060: EMPTY
78061: LIST
78062: LIST
78063: PPUSH
78064: CALL_OW 69
78068: ST_TO_ADDR
// if not tmp then
78069: LD_VAR 0 6
78073: NOT
78074: IFFALSE 78078
// exit ;
78076: GO 78326
// result := [ ] ;
78078: LD_ADDR_VAR 0 2
78082: PUSH
78083: EMPTY
78084: ST_TO_ADDR
// for i in tmp do
78085: LD_ADDR_VAR 0 3
78089: PUSH
78090: LD_VAR 0 6
78094: PUSH
78095: FOR_IN
78096: IFFALSE 78167
// begin t := UnitsInside ( i ) ;
78098: LD_ADDR_VAR 0 4
78102: PUSH
78103: LD_VAR 0 3
78107: PPUSH
78108: CALL_OW 313
78112: ST_TO_ADDR
// if t then
78113: LD_VAR 0 4
78117: IFFALSE 78165
// for j in t do
78119: LD_ADDR_VAR 0 7
78123: PUSH
78124: LD_VAR 0 4
78128: PUSH
78129: FOR_IN
78130: IFFALSE 78163
// result := Replace ( result , result + 1 , j ) ;
78132: LD_ADDR_VAR 0 2
78136: PUSH
78137: LD_VAR 0 2
78141: PPUSH
78142: LD_VAR 0 2
78146: PUSH
78147: LD_INT 1
78149: PLUS
78150: PPUSH
78151: LD_VAR 0 7
78155: PPUSH
78156: CALL_OW 1
78160: ST_TO_ADDR
78161: GO 78129
78163: POP
78164: POP
// end ;
78165: GO 78095
78167: POP
78168: POP
// if not result then
78169: LD_VAR 0 2
78173: NOT
78174: IFFALSE 78178
// exit ;
78176: GO 78326
// mech := result [ 1 ] ;
78178: LD_ADDR_VAR 0 5
78182: PUSH
78183: LD_VAR 0 2
78187: PUSH
78188: LD_INT 1
78190: ARRAY
78191: ST_TO_ADDR
// if result > 1 then
78192: LD_VAR 0 2
78196: PUSH
78197: LD_INT 1
78199: GREATER
78200: IFFALSE 78312
// begin for i = 2 to result do
78202: LD_ADDR_VAR 0 3
78206: PUSH
78207: DOUBLE
78208: LD_INT 2
78210: DEC
78211: ST_TO_ADDR
78212: LD_VAR 0 2
78216: PUSH
78217: FOR_TO
78218: IFFALSE 78310
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
78220: LD_ADDR_VAR 0 4
78224: PUSH
78225: LD_VAR 0 2
78229: PUSH
78230: LD_VAR 0 3
78234: ARRAY
78235: PPUSH
78236: LD_INT 3
78238: PPUSH
78239: CALL_OW 259
78243: PUSH
78244: LD_VAR 0 2
78248: PUSH
78249: LD_VAR 0 3
78253: ARRAY
78254: PPUSH
78255: CALL_OW 432
78259: MINUS
78260: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
78261: LD_VAR 0 4
78265: PUSH
78266: LD_VAR 0 5
78270: PPUSH
78271: LD_INT 3
78273: PPUSH
78274: CALL_OW 259
78278: PUSH
78279: LD_VAR 0 5
78283: PPUSH
78284: CALL_OW 432
78288: MINUS
78289: GREATEREQUAL
78290: IFFALSE 78308
// mech := result [ i ] ;
78292: LD_ADDR_VAR 0 5
78296: PUSH
78297: LD_VAR 0 2
78301: PUSH
78302: LD_VAR 0 3
78306: ARRAY
78307: ST_TO_ADDR
// end ;
78308: GO 78217
78310: POP
78311: POP
// end ; ComLinkTo ( vehicle , mech ) ;
78312: LD_VAR 0 1
78316: PPUSH
78317: LD_VAR 0 5
78321: PPUSH
78322: CALL_OW 135
// end ;
78326: LD_VAR 0 2
78330: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
78331: LD_INT 0
78333: PPUSH
78334: PPUSH
78335: PPUSH
78336: PPUSH
78337: PPUSH
78338: PPUSH
78339: PPUSH
78340: PPUSH
78341: PPUSH
78342: PPUSH
78343: PPUSH
78344: PPUSH
78345: PPUSH
// result := [ ] ;
78346: LD_ADDR_VAR 0 7
78350: PUSH
78351: EMPTY
78352: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
78353: LD_VAR 0 1
78357: PPUSH
78358: CALL_OW 266
78362: PUSH
78363: LD_INT 0
78365: PUSH
78366: LD_INT 1
78368: PUSH
78369: EMPTY
78370: LIST
78371: LIST
78372: IN
78373: NOT
78374: IFFALSE 78378
// exit ;
78376: GO 80012
// if name then
78378: LD_VAR 0 3
78382: IFFALSE 78398
// SetBName ( base_dep , name ) ;
78384: LD_VAR 0 1
78388: PPUSH
78389: LD_VAR 0 3
78393: PPUSH
78394: CALL_OW 500
// base := GetBase ( base_dep ) ;
78398: LD_ADDR_VAR 0 15
78402: PUSH
78403: LD_VAR 0 1
78407: PPUSH
78408: CALL_OW 274
78412: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
78413: LD_ADDR_VAR 0 16
78417: PUSH
78418: LD_VAR 0 1
78422: PPUSH
78423: CALL_OW 255
78427: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
78428: LD_ADDR_VAR 0 17
78432: PUSH
78433: LD_VAR 0 1
78437: PPUSH
78438: CALL_OW 248
78442: ST_TO_ADDR
// if sources then
78443: LD_VAR 0 5
78447: IFFALSE 78494
// for i = 1 to 3 do
78449: LD_ADDR_VAR 0 8
78453: PUSH
78454: DOUBLE
78455: LD_INT 1
78457: DEC
78458: ST_TO_ADDR
78459: LD_INT 3
78461: PUSH
78462: FOR_TO
78463: IFFALSE 78492
// AddResourceType ( base , i , sources [ i ] ) ;
78465: LD_VAR 0 15
78469: PPUSH
78470: LD_VAR 0 8
78474: PPUSH
78475: LD_VAR 0 5
78479: PUSH
78480: LD_VAR 0 8
78484: ARRAY
78485: PPUSH
78486: CALL_OW 276
78490: GO 78462
78492: POP
78493: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
78494: LD_ADDR_VAR 0 18
78498: PUSH
78499: LD_VAR 0 15
78503: PPUSH
78504: LD_VAR 0 2
78508: PPUSH
78509: LD_INT 1
78511: PPUSH
78512: CALL 77755 0 3
78516: ST_TO_ADDR
// InitHc ;
78517: CALL_OW 19
// InitUc ;
78521: CALL_OW 18
// uc_side := side ;
78525: LD_ADDR_OWVAR 20
78529: PUSH
78530: LD_VAR 0 16
78534: ST_TO_ADDR
// uc_nation := nation ;
78535: LD_ADDR_OWVAR 21
78539: PUSH
78540: LD_VAR 0 17
78544: ST_TO_ADDR
// if buildings then
78545: LD_VAR 0 18
78549: IFFALSE 79871
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
78551: LD_ADDR_VAR 0 19
78555: PUSH
78556: LD_VAR 0 18
78560: PPUSH
78561: LD_INT 2
78563: PUSH
78564: LD_INT 30
78566: PUSH
78567: LD_INT 29
78569: PUSH
78570: EMPTY
78571: LIST
78572: LIST
78573: PUSH
78574: LD_INT 30
78576: PUSH
78577: LD_INT 30
78579: PUSH
78580: EMPTY
78581: LIST
78582: LIST
78583: PUSH
78584: EMPTY
78585: LIST
78586: LIST
78587: LIST
78588: PPUSH
78589: CALL_OW 72
78593: ST_TO_ADDR
// if tmp then
78594: LD_VAR 0 19
78598: IFFALSE 78646
// for i in tmp do
78600: LD_ADDR_VAR 0 8
78604: PUSH
78605: LD_VAR 0 19
78609: PUSH
78610: FOR_IN
78611: IFFALSE 78644
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
78613: LD_VAR 0 8
78617: PPUSH
78618: CALL_OW 250
78622: PPUSH
78623: LD_VAR 0 8
78627: PPUSH
78628: CALL_OW 251
78632: PPUSH
78633: LD_VAR 0 16
78637: PPUSH
78638: CALL_OW 441
78642: GO 78610
78644: POP
78645: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
78646: LD_VAR 0 18
78650: PPUSH
78651: LD_INT 2
78653: PUSH
78654: LD_INT 30
78656: PUSH
78657: LD_INT 32
78659: PUSH
78660: EMPTY
78661: LIST
78662: LIST
78663: PUSH
78664: LD_INT 30
78666: PUSH
78667: LD_INT 33
78669: PUSH
78670: EMPTY
78671: LIST
78672: LIST
78673: PUSH
78674: EMPTY
78675: LIST
78676: LIST
78677: LIST
78678: PPUSH
78679: CALL_OW 72
78683: IFFALSE 78771
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
78685: LD_ADDR_VAR 0 8
78689: PUSH
78690: LD_VAR 0 18
78694: PPUSH
78695: LD_INT 2
78697: PUSH
78698: LD_INT 30
78700: PUSH
78701: LD_INT 32
78703: PUSH
78704: EMPTY
78705: LIST
78706: LIST
78707: PUSH
78708: LD_INT 30
78710: PUSH
78711: LD_INT 33
78713: PUSH
78714: EMPTY
78715: LIST
78716: LIST
78717: PUSH
78718: EMPTY
78719: LIST
78720: LIST
78721: LIST
78722: PPUSH
78723: CALL_OW 72
78727: PUSH
78728: FOR_IN
78729: IFFALSE 78769
// begin if not GetBWeapon ( i ) then
78731: LD_VAR 0 8
78735: PPUSH
78736: CALL_OW 269
78740: NOT
78741: IFFALSE 78767
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
78743: LD_VAR 0 8
78747: PPUSH
78748: LD_VAR 0 8
78752: PPUSH
78753: LD_VAR 0 2
78757: PPUSH
78758: CALL 80017 0 2
78762: PPUSH
78763: CALL_OW 431
// end ;
78767: GO 78728
78769: POP
78770: POP
// end ; for i = 1 to personel do
78771: LD_ADDR_VAR 0 8
78775: PUSH
78776: DOUBLE
78777: LD_INT 1
78779: DEC
78780: ST_TO_ADDR
78781: LD_VAR 0 6
78785: PUSH
78786: FOR_TO
78787: IFFALSE 79851
// begin if i > 4 then
78789: LD_VAR 0 8
78793: PUSH
78794: LD_INT 4
78796: GREATER
78797: IFFALSE 78801
// break ;
78799: GO 79851
// case i of 1 :
78801: LD_VAR 0 8
78805: PUSH
78806: LD_INT 1
78808: DOUBLE
78809: EQUAL
78810: IFTRUE 78814
78812: GO 78894
78814: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
78815: LD_ADDR_VAR 0 12
78819: PUSH
78820: LD_VAR 0 18
78824: PPUSH
78825: LD_INT 22
78827: PUSH
78828: LD_VAR 0 16
78832: PUSH
78833: EMPTY
78834: LIST
78835: LIST
78836: PUSH
78837: LD_INT 58
78839: PUSH
78840: EMPTY
78841: LIST
78842: PUSH
78843: LD_INT 2
78845: PUSH
78846: LD_INT 30
78848: PUSH
78849: LD_INT 32
78851: PUSH
78852: EMPTY
78853: LIST
78854: LIST
78855: PUSH
78856: LD_INT 30
78858: PUSH
78859: LD_INT 4
78861: PUSH
78862: EMPTY
78863: LIST
78864: LIST
78865: PUSH
78866: LD_INT 30
78868: PUSH
78869: LD_INT 5
78871: PUSH
78872: EMPTY
78873: LIST
78874: LIST
78875: PUSH
78876: EMPTY
78877: LIST
78878: LIST
78879: LIST
78880: LIST
78881: PUSH
78882: EMPTY
78883: LIST
78884: LIST
78885: LIST
78886: PPUSH
78887: CALL_OW 72
78891: ST_TO_ADDR
78892: GO 79116
78894: LD_INT 2
78896: DOUBLE
78897: EQUAL
78898: IFTRUE 78902
78900: GO 78964
78902: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
78903: LD_ADDR_VAR 0 12
78907: PUSH
78908: LD_VAR 0 18
78912: PPUSH
78913: LD_INT 22
78915: PUSH
78916: LD_VAR 0 16
78920: PUSH
78921: EMPTY
78922: LIST
78923: LIST
78924: PUSH
78925: LD_INT 2
78927: PUSH
78928: LD_INT 30
78930: PUSH
78931: LD_INT 0
78933: PUSH
78934: EMPTY
78935: LIST
78936: LIST
78937: PUSH
78938: LD_INT 30
78940: PUSH
78941: LD_INT 1
78943: PUSH
78944: EMPTY
78945: LIST
78946: LIST
78947: PUSH
78948: EMPTY
78949: LIST
78950: LIST
78951: LIST
78952: PUSH
78953: EMPTY
78954: LIST
78955: LIST
78956: PPUSH
78957: CALL_OW 72
78961: ST_TO_ADDR
78962: GO 79116
78964: LD_INT 3
78966: DOUBLE
78967: EQUAL
78968: IFTRUE 78972
78970: GO 79034
78972: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
78973: LD_ADDR_VAR 0 12
78977: PUSH
78978: LD_VAR 0 18
78982: PPUSH
78983: LD_INT 22
78985: PUSH
78986: LD_VAR 0 16
78990: PUSH
78991: EMPTY
78992: LIST
78993: LIST
78994: PUSH
78995: LD_INT 2
78997: PUSH
78998: LD_INT 30
79000: PUSH
79001: LD_INT 2
79003: PUSH
79004: EMPTY
79005: LIST
79006: LIST
79007: PUSH
79008: LD_INT 30
79010: PUSH
79011: LD_INT 3
79013: PUSH
79014: EMPTY
79015: LIST
79016: LIST
79017: PUSH
79018: EMPTY
79019: LIST
79020: LIST
79021: LIST
79022: PUSH
79023: EMPTY
79024: LIST
79025: LIST
79026: PPUSH
79027: CALL_OW 72
79031: ST_TO_ADDR
79032: GO 79116
79034: LD_INT 4
79036: DOUBLE
79037: EQUAL
79038: IFTRUE 79042
79040: GO 79115
79042: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
79043: LD_ADDR_VAR 0 12
79047: PUSH
79048: LD_VAR 0 18
79052: PPUSH
79053: LD_INT 22
79055: PUSH
79056: LD_VAR 0 16
79060: PUSH
79061: EMPTY
79062: LIST
79063: LIST
79064: PUSH
79065: LD_INT 2
79067: PUSH
79068: LD_INT 30
79070: PUSH
79071: LD_INT 6
79073: PUSH
79074: EMPTY
79075: LIST
79076: LIST
79077: PUSH
79078: LD_INT 30
79080: PUSH
79081: LD_INT 7
79083: PUSH
79084: EMPTY
79085: LIST
79086: LIST
79087: PUSH
79088: LD_INT 30
79090: PUSH
79091: LD_INT 8
79093: PUSH
79094: EMPTY
79095: LIST
79096: LIST
79097: PUSH
79098: EMPTY
79099: LIST
79100: LIST
79101: LIST
79102: LIST
79103: PUSH
79104: EMPTY
79105: LIST
79106: LIST
79107: PPUSH
79108: CALL_OW 72
79112: ST_TO_ADDR
79113: GO 79116
79115: POP
// if i = 1 then
79116: LD_VAR 0 8
79120: PUSH
79121: LD_INT 1
79123: EQUAL
79124: IFFALSE 79235
// begin tmp := [ ] ;
79126: LD_ADDR_VAR 0 19
79130: PUSH
79131: EMPTY
79132: ST_TO_ADDR
// for j in f do
79133: LD_ADDR_VAR 0 9
79137: PUSH
79138: LD_VAR 0 12
79142: PUSH
79143: FOR_IN
79144: IFFALSE 79217
// if GetBType ( j ) = b_bunker then
79146: LD_VAR 0 9
79150: PPUSH
79151: CALL_OW 266
79155: PUSH
79156: LD_INT 32
79158: EQUAL
79159: IFFALSE 79186
// tmp := Insert ( tmp , 1 , j ) else
79161: LD_ADDR_VAR 0 19
79165: PUSH
79166: LD_VAR 0 19
79170: PPUSH
79171: LD_INT 1
79173: PPUSH
79174: LD_VAR 0 9
79178: PPUSH
79179: CALL_OW 2
79183: ST_TO_ADDR
79184: GO 79215
// tmp := Insert ( tmp , tmp + 1 , j ) ;
79186: LD_ADDR_VAR 0 19
79190: PUSH
79191: LD_VAR 0 19
79195: PPUSH
79196: LD_VAR 0 19
79200: PUSH
79201: LD_INT 1
79203: PLUS
79204: PPUSH
79205: LD_VAR 0 9
79209: PPUSH
79210: CALL_OW 2
79214: ST_TO_ADDR
79215: GO 79143
79217: POP
79218: POP
// if tmp then
79219: LD_VAR 0 19
79223: IFFALSE 79235
// f := tmp ;
79225: LD_ADDR_VAR 0 12
79229: PUSH
79230: LD_VAR 0 19
79234: ST_TO_ADDR
// end ; x := personel [ i ] ;
79235: LD_ADDR_VAR 0 13
79239: PUSH
79240: LD_VAR 0 6
79244: PUSH
79245: LD_VAR 0 8
79249: ARRAY
79250: ST_TO_ADDR
// if x = - 1 then
79251: LD_VAR 0 13
79255: PUSH
79256: LD_INT 1
79258: NEG
79259: EQUAL
79260: IFFALSE 79469
// begin for j in f do
79262: LD_ADDR_VAR 0 9
79266: PUSH
79267: LD_VAR 0 12
79271: PUSH
79272: FOR_IN
79273: IFFALSE 79465
// repeat InitHc ;
79275: CALL_OW 19
// if GetBType ( j ) = b_barracks then
79279: LD_VAR 0 9
79283: PPUSH
79284: CALL_OW 266
79288: PUSH
79289: LD_INT 5
79291: EQUAL
79292: IFFALSE 79362
// begin if UnitsInside ( j ) < 3 then
79294: LD_VAR 0 9
79298: PPUSH
79299: CALL_OW 313
79303: PUSH
79304: LD_INT 3
79306: LESS
79307: IFFALSE 79343
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
79309: LD_INT 0
79311: PPUSH
79312: LD_INT 5
79314: PUSH
79315: LD_INT 8
79317: PUSH
79318: LD_INT 9
79320: PUSH
79321: EMPTY
79322: LIST
79323: LIST
79324: LIST
79325: PUSH
79326: LD_VAR 0 17
79330: ARRAY
79331: PPUSH
79332: LD_VAR 0 4
79336: PPUSH
79337: CALL_OW 380
79341: GO 79360
// PrepareHuman ( false , i , skill ) ;
79343: LD_INT 0
79345: PPUSH
79346: LD_VAR 0 8
79350: PPUSH
79351: LD_VAR 0 4
79355: PPUSH
79356: CALL_OW 380
// end else
79360: GO 79379
// PrepareHuman ( false , i , skill ) ;
79362: LD_INT 0
79364: PPUSH
79365: LD_VAR 0 8
79369: PPUSH
79370: LD_VAR 0 4
79374: PPUSH
79375: CALL_OW 380
// un := CreateHuman ;
79379: LD_ADDR_VAR 0 14
79383: PUSH
79384: CALL_OW 44
79388: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
79389: LD_ADDR_VAR 0 7
79393: PUSH
79394: LD_VAR 0 7
79398: PPUSH
79399: LD_INT 1
79401: PPUSH
79402: LD_VAR 0 14
79406: PPUSH
79407: CALL_OW 2
79411: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
79412: LD_VAR 0 14
79416: PPUSH
79417: LD_VAR 0 9
79421: PPUSH
79422: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
79426: LD_VAR 0 9
79430: PPUSH
79431: CALL_OW 313
79435: PUSH
79436: LD_INT 6
79438: EQUAL
79439: PUSH
79440: LD_VAR 0 9
79444: PPUSH
79445: CALL_OW 266
79449: PUSH
79450: LD_INT 32
79452: PUSH
79453: LD_INT 31
79455: PUSH
79456: EMPTY
79457: LIST
79458: LIST
79459: IN
79460: OR
79461: IFFALSE 79275
79463: GO 79272
79465: POP
79466: POP
// end else
79467: GO 79849
// for j = 1 to x do
79469: LD_ADDR_VAR 0 9
79473: PUSH
79474: DOUBLE
79475: LD_INT 1
79477: DEC
79478: ST_TO_ADDR
79479: LD_VAR 0 13
79483: PUSH
79484: FOR_TO
79485: IFFALSE 79847
// begin InitHc ;
79487: CALL_OW 19
// if not f then
79491: LD_VAR 0 12
79495: NOT
79496: IFFALSE 79585
// begin PrepareHuman ( false , i , skill ) ;
79498: LD_INT 0
79500: PPUSH
79501: LD_VAR 0 8
79505: PPUSH
79506: LD_VAR 0 4
79510: PPUSH
79511: CALL_OW 380
// un := CreateHuman ;
79515: LD_ADDR_VAR 0 14
79519: PUSH
79520: CALL_OW 44
79524: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
79525: LD_ADDR_VAR 0 7
79529: PUSH
79530: LD_VAR 0 7
79534: PPUSH
79535: LD_INT 1
79537: PPUSH
79538: LD_VAR 0 14
79542: PPUSH
79543: CALL_OW 2
79547: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
79548: LD_VAR 0 14
79552: PPUSH
79553: LD_VAR 0 1
79557: PPUSH
79558: CALL_OW 250
79562: PPUSH
79563: LD_VAR 0 1
79567: PPUSH
79568: CALL_OW 251
79572: PPUSH
79573: LD_INT 10
79575: PPUSH
79576: LD_INT 0
79578: PPUSH
79579: CALL_OW 50
// continue ;
79583: GO 79484
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
79585: LD_VAR 0 12
79589: PUSH
79590: LD_INT 1
79592: ARRAY
79593: PPUSH
79594: CALL_OW 313
79598: PUSH
79599: LD_VAR 0 12
79603: PUSH
79604: LD_INT 1
79606: ARRAY
79607: PPUSH
79608: CALL_OW 266
79612: PUSH
79613: LD_INT 32
79615: PUSH
79616: LD_INT 31
79618: PUSH
79619: EMPTY
79620: LIST
79621: LIST
79622: IN
79623: AND
79624: PUSH
79625: LD_VAR 0 12
79629: PUSH
79630: LD_INT 1
79632: ARRAY
79633: PPUSH
79634: CALL_OW 313
79638: PUSH
79639: LD_INT 6
79641: EQUAL
79642: OR
79643: IFFALSE 79663
// f := Delete ( f , 1 ) ;
79645: LD_ADDR_VAR 0 12
79649: PUSH
79650: LD_VAR 0 12
79654: PPUSH
79655: LD_INT 1
79657: PPUSH
79658: CALL_OW 3
79662: ST_TO_ADDR
// if not f then
79663: LD_VAR 0 12
79667: NOT
79668: IFFALSE 79686
// begin x := x + 2 ;
79670: LD_ADDR_VAR 0 13
79674: PUSH
79675: LD_VAR 0 13
79679: PUSH
79680: LD_INT 2
79682: PLUS
79683: ST_TO_ADDR
// continue ;
79684: GO 79484
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
79686: LD_VAR 0 12
79690: PUSH
79691: LD_INT 1
79693: ARRAY
79694: PPUSH
79695: CALL_OW 266
79699: PUSH
79700: LD_INT 5
79702: EQUAL
79703: IFFALSE 79777
// begin if UnitsInside ( f [ 1 ] ) < 3 then
79705: LD_VAR 0 12
79709: PUSH
79710: LD_INT 1
79712: ARRAY
79713: PPUSH
79714: CALL_OW 313
79718: PUSH
79719: LD_INT 3
79721: LESS
79722: IFFALSE 79758
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
79724: LD_INT 0
79726: PPUSH
79727: LD_INT 5
79729: PUSH
79730: LD_INT 8
79732: PUSH
79733: LD_INT 9
79735: PUSH
79736: EMPTY
79737: LIST
79738: LIST
79739: LIST
79740: PUSH
79741: LD_VAR 0 17
79745: ARRAY
79746: PPUSH
79747: LD_VAR 0 4
79751: PPUSH
79752: CALL_OW 380
79756: GO 79775
// PrepareHuman ( false , i , skill ) ;
79758: LD_INT 0
79760: PPUSH
79761: LD_VAR 0 8
79765: PPUSH
79766: LD_VAR 0 4
79770: PPUSH
79771: CALL_OW 380
// end else
79775: GO 79794
// PrepareHuman ( false , i , skill ) ;
79777: LD_INT 0
79779: PPUSH
79780: LD_VAR 0 8
79784: PPUSH
79785: LD_VAR 0 4
79789: PPUSH
79790: CALL_OW 380
// un := CreateHuman ;
79794: LD_ADDR_VAR 0 14
79798: PUSH
79799: CALL_OW 44
79803: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
79804: LD_ADDR_VAR 0 7
79808: PUSH
79809: LD_VAR 0 7
79813: PPUSH
79814: LD_INT 1
79816: PPUSH
79817: LD_VAR 0 14
79821: PPUSH
79822: CALL_OW 2
79826: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
79827: LD_VAR 0 14
79831: PPUSH
79832: LD_VAR 0 12
79836: PUSH
79837: LD_INT 1
79839: ARRAY
79840: PPUSH
79841: CALL_OW 52
// end ;
79845: GO 79484
79847: POP
79848: POP
// end ;
79849: GO 78786
79851: POP
79852: POP
// result := result ^ buildings ;
79853: LD_ADDR_VAR 0 7
79857: PUSH
79858: LD_VAR 0 7
79862: PUSH
79863: LD_VAR 0 18
79867: ADD
79868: ST_TO_ADDR
// end else
79869: GO 80012
// begin for i = 1 to personel do
79871: LD_ADDR_VAR 0 8
79875: PUSH
79876: DOUBLE
79877: LD_INT 1
79879: DEC
79880: ST_TO_ADDR
79881: LD_VAR 0 6
79885: PUSH
79886: FOR_TO
79887: IFFALSE 80010
// begin if i > 4 then
79889: LD_VAR 0 8
79893: PUSH
79894: LD_INT 4
79896: GREATER
79897: IFFALSE 79901
// break ;
79899: GO 80010
// x := personel [ i ] ;
79901: LD_ADDR_VAR 0 13
79905: PUSH
79906: LD_VAR 0 6
79910: PUSH
79911: LD_VAR 0 8
79915: ARRAY
79916: ST_TO_ADDR
// if x = - 1 then
79917: LD_VAR 0 13
79921: PUSH
79922: LD_INT 1
79924: NEG
79925: EQUAL
79926: IFFALSE 79930
// continue ;
79928: GO 79886
// PrepareHuman ( false , i , skill ) ;
79930: LD_INT 0
79932: PPUSH
79933: LD_VAR 0 8
79937: PPUSH
79938: LD_VAR 0 4
79942: PPUSH
79943: CALL_OW 380
// un := CreateHuman ;
79947: LD_ADDR_VAR 0 14
79951: PUSH
79952: CALL_OW 44
79956: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
79957: LD_VAR 0 14
79961: PPUSH
79962: LD_VAR 0 1
79966: PPUSH
79967: CALL_OW 250
79971: PPUSH
79972: LD_VAR 0 1
79976: PPUSH
79977: CALL_OW 251
79981: PPUSH
79982: LD_INT 10
79984: PPUSH
79985: LD_INT 0
79987: PPUSH
79988: CALL_OW 50
// result := result ^ un ;
79992: LD_ADDR_VAR 0 7
79996: PUSH
79997: LD_VAR 0 7
80001: PUSH
80002: LD_VAR 0 14
80006: ADD
80007: ST_TO_ADDR
// end ;
80008: GO 79886
80010: POP
80011: POP
// end ; end ;
80012: LD_VAR 0 7
80016: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
80017: LD_INT 0
80019: PPUSH
80020: PPUSH
80021: PPUSH
80022: PPUSH
80023: PPUSH
80024: PPUSH
80025: PPUSH
80026: PPUSH
80027: PPUSH
80028: PPUSH
80029: PPUSH
80030: PPUSH
80031: PPUSH
80032: PPUSH
80033: PPUSH
80034: PPUSH
// result := false ;
80035: LD_ADDR_VAR 0 3
80039: PUSH
80040: LD_INT 0
80042: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
80043: LD_VAR 0 1
80047: NOT
80048: PUSH
80049: LD_VAR 0 1
80053: PPUSH
80054: CALL_OW 266
80058: PUSH
80059: LD_INT 32
80061: PUSH
80062: LD_INT 33
80064: PUSH
80065: EMPTY
80066: LIST
80067: LIST
80068: IN
80069: NOT
80070: OR
80071: IFFALSE 80075
// exit ;
80073: GO 81184
// nat := GetNation ( tower ) ;
80075: LD_ADDR_VAR 0 12
80079: PUSH
80080: LD_VAR 0 1
80084: PPUSH
80085: CALL_OW 248
80089: ST_TO_ADDR
// side := GetSide ( tower ) ;
80090: LD_ADDR_VAR 0 16
80094: PUSH
80095: LD_VAR 0 1
80099: PPUSH
80100: CALL_OW 255
80104: ST_TO_ADDR
// x := GetX ( tower ) ;
80105: LD_ADDR_VAR 0 10
80109: PUSH
80110: LD_VAR 0 1
80114: PPUSH
80115: CALL_OW 250
80119: ST_TO_ADDR
// y := GetY ( tower ) ;
80120: LD_ADDR_VAR 0 11
80124: PUSH
80125: LD_VAR 0 1
80129: PPUSH
80130: CALL_OW 251
80134: ST_TO_ADDR
// if not x or not y then
80135: LD_VAR 0 10
80139: NOT
80140: PUSH
80141: LD_VAR 0 11
80145: NOT
80146: OR
80147: IFFALSE 80151
// exit ;
80149: GO 81184
// weapon := 0 ;
80151: LD_ADDR_VAR 0 18
80155: PUSH
80156: LD_INT 0
80158: ST_TO_ADDR
// fac_list := [ ] ;
80159: LD_ADDR_VAR 0 17
80163: PUSH
80164: EMPTY
80165: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
80166: LD_ADDR_VAR 0 6
80170: PUSH
80171: LD_VAR 0 1
80175: PPUSH
80176: CALL_OW 274
80180: PPUSH
80181: LD_VAR 0 2
80185: PPUSH
80186: LD_INT 0
80188: PPUSH
80189: CALL 77755 0 3
80193: PPUSH
80194: LD_INT 30
80196: PUSH
80197: LD_INT 3
80199: PUSH
80200: EMPTY
80201: LIST
80202: LIST
80203: PPUSH
80204: CALL_OW 72
80208: ST_TO_ADDR
// if not factories then
80209: LD_VAR 0 6
80213: NOT
80214: IFFALSE 80218
// exit ;
80216: GO 81184
// for i in factories do
80218: LD_ADDR_VAR 0 8
80222: PUSH
80223: LD_VAR 0 6
80227: PUSH
80228: FOR_IN
80229: IFFALSE 80254
// fac_list := fac_list union AvailableWeaponList ( i ) ;
80231: LD_ADDR_VAR 0 17
80235: PUSH
80236: LD_VAR 0 17
80240: PUSH
80241: LD_VAR 0 8
80245: PPUSH
80246: CALL_OW 478
80250: UNION
80251: ST_TO_ADDR
80252: GO 80228
80254: POP
80255: POP
// if not fac_list then
80256: LD_VAR 0 17
80260: NOT
80261: IFFALSE 80265
// exit ;
80263: GO 81184
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
80265: LD_ADDR_VAR 0 5
80269: PUSH
80270: LD_INT 4
80272: PUSH
80273: LD_INT 5
80275: PUSH
80276: LD_INT 9
80278: PUSH
80279: LD_INT 10
80281: PUSH
80282: LD_INT 6
80284: PUSH
80285: LD_INT 7
80287: PUSH
80288: LD_INT 11
80290: PUSH
80291: EMPTY
80292: LIST
80293: LIST
80294: LIST
80295: LIST
80296: LIST
80297: LIST
80298: LIST
80299: PUSH
80300: LD_INT 27
80302: PUSH
80303: LD_INT 28
80305: PUSH
80306: LD_INT 26
80308: PUSH
80309: LD_INT 30
80311: PUSH
80312: EMPTY
80313: LIST
80314: LIST
80315: LIST
80316: LIST
80317: PUSH
80318: LD_INT 43
80320: PUSH
80321: LD_INT 44
80323: PUSH
80324: LD_INT 46
80326: PUSH
80327: LD_INT 45
80329: PUSH
80330: LD_INT 47
80332: PUSH
80333: LD_INT 49
80335: PUSH
80336: EMPTY
80337: LIST
80338: LIST
80339: LIST
80340: LIST
80341: LIST
80342: LIST
80343: PUSH
80344: EMPTY
80345: LIST
80346: LIST
80347: LIST
80348: PUSH
80349: LD_VAR 0 12
80353: ARRAY
80354: ST_TO_ADDR
// list := list isect fac_list ;
80355: LD_ADDR_VAR 0 5
80359: PUSH
80360: LD_VAR 0 5
80364: PUSH
80365: LD_VAR 0 17
80369: ISECT
80370: ST_TO_ADDR
// if not list then
80371: LD_VAR 0 5
80375: NOT
80376: IFFALSE 80380
// exit ;
80378: GO 81184
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
80380: LD_VAR 0 12
80384: PUSH
80385: LD_INT 3
80387: EQUAL
80388: PUSH
80389: LD_INT 49
80391: PUSH
80392: LD_VAR 0 5
80396: IN
80397: AND
80398: PUSH
80399: LD_INT 31
80401: PPUSH
80402: LD_VAR 0 16
80406: PPUSH
80407: CALL_OW 321
80411: PUSH
80412: LD_INT 2
80414: EQUAL
80415: AND
80416: IFFALSE 80476
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
80418: LD_INT 22
80420: PUSH
80421: LD_VAR 0 16
80425: PUSH
80426: EMPTY
80427: LIST
80428: LIST
80429: PUSH
80430: LD_INT 35
80432: PUSH
80433: LD_INT 49
80435: PUSH
80436: EMPTY
80437: LIST
80438: LIST
80439: PUSH
80440: LD_INT 91
80442: PUSH
80443: LD_VAR 0 1
80447: PUSH
80448: LD_INT 10
80450: PUSH
80451: EMPTY
80452: LIST
80453: LIST
80454: LIST
80455: PUSH
80456: EMPTY
80457: LIST
80458: LIST
80459: LIST
80460: PPUSH
80461: CALL_OW 69
80465: NOT
80466: IFFALSE 80476
// weapon := ru_time_lapser ;
80468: LD_ADDR_VAR 0 18
80472: PUSH
80473: LD_INT 49
80475: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
80476: LD_VAR 0 12
80480: PUSH
80481: LD_INT 1
80483: PUSH
80484: LD_INT 2
80486: PUSH
80487: EMPTY
80488: LIST
80489: LIST
80490: IN
80491: PUSH
80492: LD_INT 11
80494: PUSH
80495: LD_VAR 0 5
80499: IN
80500: PUSH
80501: LD_INT 30
80503: PUSH
80504: LD_VAR 0 5
80508: IN
80509: OR
80510: AND
80511: PUSH
80512: LD_INT 6
80514: PPUSH
80515: LD_VAR 0 16
80519: PPUSH
80520: CALL_OW 321
80524: PUSH
80525: LD_INT 2
80527: EQUAL
80528: AND
80529: IFFALSE 80694
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
80531: LD_INT 22
80533: PUSH
80534: LD_VAR 0 16
80538: PUSH
80539: EMPTY
80540: LIST
80541: LIST
80542: PUSH
80543: LD_INT 2
80545: PUSH
80546: LD_INT 35
80548: PUSH
80549: LD_INT 11
80551: PUSH
80552: EMPTY
80553: LIST
80554: LIST
80555: PUSH
80556: LD_INT 35
80558: PUSH
80559: LD_INT 30
80561: PUSH
80562: EMPTY
80563: LIST
80564: LIST
80565: PUSH
80566: EMPTY
80567: LIST
80568: LIST
80569: LIST
80570: PUSH
80571: LD_INT 91
80573: PUSH
80574: LD_VAR 0 1
80578: PUSH
80579: LD_INT 18
80581: PUSH
80582: EMPTY
80583: LIST
80584: LIST
80585: LIST
80586: PUSH
80587: EMPTY
80588: LIST
80589: LIST
80590: LIST
80591: PPUSH
80592: CALL_OW 69
80596: NOT
80597: PUSH
80598: LD_INT 22
80600: PUSH
80601: LD_VAR 0 16
80605: PUSH
80606: EMPTY
80607: LIST
80608: LIST
80609: PUSH
80610: LD_INT 2
80612: PUSH
80613: LD_INT 30
80615: PUSH
80616: LD_INT 32
80618: PUSH
80619: EMPTY
80620: LIST
80621: LIST
80622: PUSH
80623: LD_INT 30
80625: PUSH
80626: LD_INT 33
80628: PUSH
80629: EMPTY
80630: LIST
80631: LIST
80632: PUSH
80633: EMPTY
80634: LIST
80635: LIST
80636: LIST
80637: PUSH
80638: LD_INT 91
80640: PUSH
80641: LD_VAR 0 1
80645: PUSH
80646: LD_INT 12
80648: PUSH
80649: EMPTY
80650: LIST
80651: LIST
80652: LIST
80653: PUSH
80654: EMPTY
80655: LIST
80656: LIST
80657: LIST
80658: PUSH
80659: EMPTY
80660: LIST
80661: PPUSH
80662: CALL_OW 69
80666: PUSH
80667: LD_INT 2
80669: GREATER
80670: AND
80671: IFFALSE 80694
// weapon := [ us_radar , ar_radar ] [ nat ] ;
80673: LD_ADDR_VAR 0 18
80677: PUSH
80678: LD_INT 11
80680: PUSH
80681: LD_INT 30
80683: PUSH
80684: EMPTY
80685: LIST
80686: LIST
80687: PUSH
80688: LD_VAR 0 12
80692: ARRAY
80693: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
80694: LD_VAR 0 18
80698: NOT
80699: PUSH
80700: LD_INT 40
80702: PPUSH
80703: LD_VAR 0 16
80707: PPUSH
80708: CALL_OW 321
80712: PUSH
80713: LD_INT 2
80715: EQUAL
80716: AND
80717: PUSH
80718: LD_INT 7
80720: PUSH
80721: LD_VAR 0 5
80725: IN
80726: PUSH
80727: LD_INT 28
80729: PUSH
80730: LD_VAR 0 5
80734: IN
80735: OR
80736: PUSH
80737: LD_INT 45
80739: PUSH
80740: LD_VAR 0 5
80744: IN
80745: OR
80746: AND
80747: IFFALSE 81001
// begin hex := GetHexInfo ( x , y ) ;
80749: LD_ADDR_VAR 0 4
80753: PUSH
80754: LD_VAR 0 10
80758: PPUSH
80759: LD_VAR 0 11
80763: PPUSH
80764: CALL_OW 546
80768: ST_TO_ADDR
// if hex [ 1 ] then
80769: LD_VAR 0 4
80773: PUSH
80774: LD_INT 1
80776: ARRAY
80777: IFFALSE 80781
// exit ;
80779: GO 81184
// height := hex [ 2 ] ;
80781: LD_ADDR_VAR 0 15
80785: PUSH
80786: LD_VAR 0 4
80790: PUSH
80791: LD_INT 2
80793: ARRAY
80794: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
80795: LD_ADDR_VAR 0 14
80799: PUSH
80800: LD_INT 0
80802: PUSH
80803: LD_INT 2
80805: PUSH
80806: LD_INT 3
80808: PUSH
80809: LD_INT 5
80811: PUSH
80812: EMPTY
80813: LIST
80814: LIST
80815: LIST
80816: LIST
80817: ST_TO_ADDR
// for i in tmp do
80818: LD_ADDR_VAR 0 8
80822: PUSH
80823: LD_VAR 0 14
80827: PUSH
80828: FOR_IN
80829: IFFALSE 80999
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
80831: LD_ADDR_VAR 0 9
80835: PUSH
80836: LD_VAR 0 10
80840: PPUSH
80841: LD_VAR 0 8
80845: PPUSH
80846: LD_INT 5
80848: PPUSH
80849: CALL_OW 272
80853: PUSH
80854: LD_VAR 0 11
80858: PPUSH
80859: LD_VAR 0 8
80863: PPUSH
80864: LD_INT 5
80866: PPUSH
80867: CALL_OW 273
80871: PUSH
80872: EMPTY
80873: LIST
80874: LIST
80875: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
80876: LD_VAR 0 9
80880: PUSH
80881: LD_INT 1
80883: ARRAY
80884: PPUSH
80885: LD_VAR 0 9
80889: PUSH
80890: LD_INT 2
80892: ARRAY
80893: PPUSH
80894: CALL_OW 488
80898: IFFALSE 80997
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
80900: LD_ADDR_VAR 0 4
80904: PUSH
80905: LD_VAR 0 9
80909: PUSH
80910: LD_INT 1
80912: ARRAY
80913: PPUSH
80914: LD_VAR 0 9
80918: PUSH
80919: LD_INT 2
80921: ARRAY
80922: PPUSH
80923: CALL_OW 546
80927: ST_TO_ADDR
// if hex [ 1 ] then
80928: LD_VAR 0 4
80932: PUSH
80933: LD_INT 1
80935: ARRAY
80936: IFFALSE 80940
// continue ;
80938: GO 80828
// h := hex [ 2 ] ;
80940: LD_ADDR_VAR 0 13
80944: PUSH
80945: LD_VAR 0 4
80949: PUSH
80950: LD_INT 2
80952: ARRAY
80953: ST_TO_ADDR
// if h + 7 < height then
80954: LD_VAR 0 13
80958: PUSH
80959: LD_INT 7
80961: PLUS
80962: PUSH
80963: LD_VAR 0 15
80967: LESS
80968: IFFALSE 80997
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
80970: LD_ADDR_VAR 0 18
80974: PUSH
80975: LD_INT 7
80977: PUSH
80978: LD_INT 28
80980: PUSH
80981: LD_INT 45
80983: PUSH
80984: EMPTY
80985: LIST
80986: LIST
80987: LIST
80988: PUSH
80989: LD_VAR 0 12
80993: ARRAY
80994: ST_TO_ADDR
// break ;
80995: GO 80999
// end ; end ; end ;
80997: GO 80828
80999: POP
81000: POP
// end ; if not weapon then
81001: LD_VAR 0 18
81005: NOT
81006: IFFALSE 81066
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
81008: LD_ADDR_VAR 0 5
81012: PUSH
81013: LD_VAR 0 5
81017: PUSH
81018: LD_INT 11
81020: PUSH
81021: LD_INT 30
81023: PUSH
81024: LD_INT 49
81026: PUSH
81027: EMPTY
81028: LIST
81029: LIST
81030: LIST
81031: DIFF
81032: ST_TO_ADDR
// if not list then
81033: LD_VAR 0 5
81037: NOT
81038: IFFALSE 81042
// exit ;
81040: GO 81184
// weapon := list [ rand ( 1 , list ) ] ;
81042: LD_ADDR_VAR 0 18
81046: PUSH
81047: LD_VAR 0 5
81051: PUSH
81052: LD_INT 1
81054: PPUSH
81055: LD_VAR 0 5
81059: PPUSH
81060: CALL_OW 12
81064: ARRAY
81065: ST_TO_ADDR
// end ; if weapon then
81066: LD_VAR 0 18
81070: IFFALSE 81184
// begin tmp := CostOfWeapon ( weapon ) ;
81072: LD_ADDR_VAR 0 14
81076: PUSH
81077: LD_VAR 0 18
81081: PPUSH
81082: CALL_OW 451
81086: ST_TO_ADDR
// j := GetBase ( tower ) ;
81087: LD_ADDR_VAR 0 9
81091: PUSH
81092: LD_VAR 0 1
81096: PPUSH
81097: CALL_OW 274
81101: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
81102: LD_VAR 0 9
81106: PPUSH
81107: LD_INT 1
81109: PPUSH
81110: CALL_OW 275
81114: PUSH
81115: LD_VAR 0 14
81119: PUSH
81120: LD_INT 1
81122: ARRAY
81123: GREATEREQUAL
81124: PUSH
81125: LD_VAR 0 9
81129: PPUSH
81130: LD_INT 2
81132: PPUSH
81133: CALL_OW 275
81137: PUSH
81138: LD_VAR 0 14
81142: PUSH
81143: LD_INT 2
81145: ARRAY
81146: GREATEREQUAL
81147: AND
81148: PUSH
81149: LD_VAR 0 9
81153: PPUSH
81154: LD_INT 3
81156: PPUSH
81157: CALL_OW 275
81161: PUSH
81162: LD_VAR 0 14
81166: PUSH
81167: LD_INT 3
81169: ARRAY
81170: GREATEREQUAL
81171: AND
81172: IFFALSE 81184
// result := weapon ;
81174: LD_ADDR_VAR 0 3
81178: PUSH
81179: LD_VAR 0 18
81183: ST_TO_ADDR
// end ; end ;
81184: LD_VAR 0 3
81188: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
81189: LD_INT 0
81191: PPUSH
81192: PPUSH
// result := true ;
81193: LD_ADDR_VAR 0 3
81197: PUSH
81198: LD_INT 1
81200: ST_TO_ADDR
// if array1 = array2 then
81201: LD_VAR 0 1
81205: PUSH
81206: LD_VAR 0 2
81210: EQUAL
81211: IFFALSE 81271
// begin for i = 1 to array1 do
81213: LD_ADDR_VAR 0 4
81217: PUSH
81218: DOUBLE
81219: LD_INT 1
81221: DEC
81222: ST_TO_ADDR
81223: LD_VAR 0 1
81227: PUSH
81228: FOR_TO
81229: IFFALSE 81267
// if array1 [ i ] <> array2 [ i ] then
81231: LD_VAR 0 1
81235: PUSH
81236: LD_VAR 0 4
81240: ARRAY
81241: PUSH
81242: LD_VAR 0 2
81246: PUSH
81247: LD_VAR 0 4
81251: ARRAY
81252: NONEQUAL
81253: IFFALSE 81265
// begin result := false ;
81255: LD_ADDR_VAR 0 3
81259: PUSH
81260: LD_INT 0
81262: ST_TO_ADDR
// break ;
81263: GO 81267
// end ;
81265: GO 81228
81267: POP
81268: POP
// end else
81269: GO 81279
// result := false ;
81271: LD_ADDR_VAR 0 3
81275: PUSH
81276: LD_INT 0
81278: ST_TO_ADDR
// end ;
81279: LD_VAR 0 3
81283: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
81284: LD_INT 0
81286: PPUSH
81287: PPUSH
// if not array1 or not array2 then
81288: LD_VAR 0 1
81292: NOT
81293: PUSH
81294: LD_VAR 0 2
81298: NOT
81299: OR
81300: IFFALSE 81304
// exit ;
81302: GO 81368
// result := true ;
81304: LD_ADDR_VAR 0 3
81308: PUSH
81309: LD_INT 1
81311: ST_TO_ADDR
// for i = 1 to array1 do
81312: LD_ADDR_VAR 0 4
81316: PUSH
81317: DOUBLE
81318: LD_INT 1
81320: DEC
81321: ST_TO_ADDR
81322: LD_VAR 0 1
81326: PUSH
81327: FOR_TO
81328: IFFALSE 81366
// if array1 [ i ] <> array2 [ i ] then
81330: LD_VAR 0 1
81334: PUSH
81335: LD_VAR 0 4
81339: ARRAY
81340: PUSH
81341: LD_VAR 0 2
81345: PUSH
81346: LD_VAR 0 4
81350: ARRAY
81351: NONEQUAL
81352: IFFALSE 81364
// begin result := false ;
81354: LD_ADDR_VAR 0 3
81358: PUSH
81359: LD_INT 0
81361: ST_TO_ADDR
// break ;
81362: GO 81366
// end ;
81364: GO 81327
81366: POP
81367: POP
// end ;
81368: LD_VAR 0 3
81372: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
81373: LD_INT 0
81375: PPUSH
81376: PPUSH
81377: PPUSH
// pom := GetBase ( fac ) ;
81378: LD_ADDR_VAR 0 5
81382: PUSH
81383: LD_VAR 0 1
81387: PPUSH
81388: CALL_OW 274
81392: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
81393: LD_ADDR_VAR 0 4
81397: PUSH
81398: LD_VAR 0 2
81402: PUSH
81403: LD_INT 1
81405: ARRAY
81406: PPUSH
81407: LD_VAR 0 2
81411: PUSH
81412: LD_INT 2
81414: ARRAY
81415: PPUSH
81416: LD_VAR 0 2
81420: PUSH
81421: LD_INT 3
81423: ARRAY
81424: PPUSH
81425: LD_VAR 0 2
81429: PUSH
81430: LD_INT 4
81432: ARRAY
81433: PPUSH
81434: CALL_OW 449
81438: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
81439: LD_ADDR_VAR 0 3
81443: PUSH
81444: LD_VAR 0 5
81448: PPUSH
81449: LD_INT 1
81451: PPUSH
81452: CALL_OW 275
81456: PUSH
81457: LD_VAR 0 4
81461: PUSH
81462: LD_INT 1
81464: ARRAY
81465: GREATEREQUAL
81466: PUSH
81467: LD_VAR 0 5
81471: PPUSH
81472: LD_INT 2
81474: PPUSH
81475: CALL_OW 275
81479: PUSH
81480: LD_VAR 0 4
81484: PUSH
81485: LD_INT 2
81487: ARRAY
81488: GREATEREQUAL
81489: AND
81490: PUSH
81491: LD_VAR 0 5
81495: PPUSH
81496: LD_INT 3
81498: PPUSH
81499: CALL_OW 275
81503: PUSH
81504: LD_VAR 0 4
81508: PUSH
81509: LD_INT 3
81511: ARRAY
81512: GREATEREQUAL
81513: AND
81514: ST_TO_ADDR
// end ;
81515: LD_VAR 0 3
81519: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
81520: LD_INT 0
81522: PPUSH
81523: PPUSH
81524: PPUSH
81525: PPUSH
// pom := GetBase ( building ) ;
81526: LD_ADDR_VAR 0 3
81530: PUSH
81531: LD_VAR 0 1
81535: PPUSH
81536: CALL_OW 274
81540: ST_TO_ADDR
// if not pom then
81541: LD_VAR 0 3
81545: NOT
81546: IFFALSE 81550
// exit ;
81548: GO 81720
// btype := GetBType ( building ) ;
81550: LD_ADDR_VAR 0 5
81554: PUSH
81555: LD_VAR 0 1
81559: PPUSH
81560: CALL_OW 266
81564: ST_TO_ADDR
// if btype = b_armoury then
81565: LD_VAR 0 5
81569: PUSH
81570: LD_INT 4
81572: EQUAL
81573: IFFALSE 81583
// btype := b_barracks ;
81575: LD_ADDR_VAR 0 5
81579: PUSH
81580: LD_INT 5
81582: ST_TO_ADDR
// if btype = b_depot then
81583: LD_VAR 0 5
81587: PUSH
81588: LD_INT 0
81590: EQUAL
81591: IFFALSE 81601
// btype := b_warehouse ;
81593: LD_ADDR_VAR 0 5
81597: PUSH
81598: LD_INT 1
81600: ST_TO_ADDR
// if btype = b_workshop then
81601: LD_VAR 0 5
81605: PUSH
81606: LD_INT 2
81608: EQUAL
81609: IFFALSE 81619
// btype := b_factory ;
81611: LD_ADDR_VAR 0 5
81615: PUSH
81616: LD_INT 3
81618: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
81619: LD_ADDR_VAR 0 4
81623: PUSH
81624: LD_VAR 0 5
81628: PPUSH
81629: LD_VAR 0 1
81633: PPUSH
81634: CALL_OW 248
81638: PPUSH
81639: CALL_OW 450
81643: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
81644: LD_ADDR_VAR 0 2
81648: PUSH
81649: LD_VAR 0 3
81653: PPUSH
81654: LD_INT 1
81656: PPUSH
81657: CALL_OW 275
81661: PUSH
81662: LD_VAR 0 4
81666: PUSH
81667: LD_INT 1
81669: ARRAY
81670: GREATEREQUAL
81671: PUSH
81672: LD_VAR 0 3
81676: PPUSH
81677: LD_INT 2
81679: PPUSH
81680: CALL_OW 275
81684: PUSH
81685: LD_VAR 0 4
81689: PUSH
81690: LD_INT 2
81692: ARRAY
81693: GREATEREQUAL
81694: AND
81695: PUSH
81696: LD_VAR 0 3
81700: PPUSH
81701: LD_INT 3
81703: PPUSH
81704: CALL_OW 275
81708: PUSH
81709: LD_VAR 0 4
81713: PUSH
81714: LD_INT 3
81716: ARRAY
81717: GREATEREQUAL
81718: AND
81719: ST_TO_ADDR
// end ;
81720: LD_VAR 0 2
81724: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
81725: LD_INT 0
81727: PPUSH
81728: PPUSH
81729: PPUSH
// pom := GetBase ( building ) ;
81730: LD_ADDR_VAR 0 4
81734: PUSH
81735: LD_VAR 0 1
81739: PPUSH
81740: CALL_OW 274
81744: ST_TO_ADDR
// if not pom then
81745: LD_VAR 0 4
81749: NOT
81750: IFFALSE 81754
// exit ;
81752: GO 81855
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
81754: LD_ADDR_VAR 0 5
81758: PUSH
81759: LD_VAR 0 2
81763: PPUSH
81764: LD_VAR 0 1
81768: PPUSH
81769: CALL_OW 248
81773: PPUSH
81774: CALL_OW 450
81778: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
81779: LD_ADDR_VAR 0 3
81783: PUSH
81784: LD_VAR 0 4
81788: PPUSH
81789: LD_INT 1
81791: PPUSH
81792: CALL_OW 275
81796: PUSH
81797: LD_VAR 0 5
81801: PUSH
81802: LD_INT 1
81804: ARRAY
81805: GREATEREQUAL
81806: PUSH
81807: LD_VAR 0 4
81811: PPUSH
81812: LD_INT 2
81814: PPUSH
81815: CALL_OW 275
81819: PUSH
81820: LD_VAR 0 5
81824: PUSH
81825: LD_INT 2
81827: ARRAY
81828: GREATEREQUAL
81829: AND
81830: PUSH
81831: LD_VAR 0 4
81835: PPUSH
81836: LD_INT 3
81838: PPUSH
81839: CALL_OW 275
81843: PUSH
81844: LD_VAR 0 5
81848: PUSH
81849: LD_INT 3
81851: ARRAY
81852: GREATEREQUAL
81853: AND
81854: ST_TO_ADDR
// end ;
81855: LD_VAR 0 3
81859: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
81860: LD_INT 0
81862: PPUSH
81863: PPUSH
81864: PPUSH
81865: PPUSH
81866: PPUSH
81867: PPUSH
81868: PPUSH
81869: PPUSH
81870: PPUSH
81871: PPUSH
81872: PPUSH
// result := false ;
81873: LD_ADDR_VAR 0 8
81877: PUSH
81878: LD_INT 0
81880: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
81881: LD_VAR 0 5
81885: NOT
81886: PUSH
81887: LD_VAR 0 1
81891: NOT
81892: OR
81893: PUSH
81894: LD_VAR 0 2
81898: NOT
81899: OR
81900: PUSH
81901: LD_VAR 0 3
81905: NOT
81906: OR
81907: IFFALSE 81911
// exit ;
81909: GO 82725
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
81911: LD_ADDR_VAR 0 14
81915: PUSH
81916: LD_VAR 0 1
81920: PPUSH
81921: LD_VAR 0 2
81925: PPUSH
81926: LD_VAR 0 3
81930: PPUSH
81931: LD_VAR 0 4
81935: PPUSH
81936: LD_VAR 0 5
81940: PUSH
81941: LD_INT 1
81943: ARRAY
81944: PPUSH
81945: CALL_OW 248
81949: PPUSH
81950: LD_INT 0
81952: PPUSH
81953: CALL 83978 0 6
81957: ST_TO_ADDR
// if not hexes then
81958: LD_VAR 0 14
81962: NOT
81963: IFFALSE 81967
// exit ;
81965: GO 82725
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
81967: LD_ADDR_VAR 0 17
81971: PUSH
81972: LD_VAR 0 5
81976: PPUSH
81977: LD_INT 22
81979: PUSH
81980: LD_VAR 0 13
81984: PPUSH
81985: CALL_OW 255
81989: PUSH
81990: EMPTY
81991: LIST
81992: LIST
81993: PUSH
81994: LD_INT 2
81996: PUSH
81997: LD_INT 30
81999: PUSH
82000: LD_INT 0
82002: PUSH
82003: EMPTY
82004: LIST
82005: LIST
82006: PUSH
82007: LD_INT 30
82009: PUSH
82010: LD_INT 1
82012: PUSH
82013: EMPTY
82014: LIST
82015: LIST
82016: PUSH
82017: EMPTY
82018: LIST
82019: LIST
82020: LIST
82021: PUSH
82022: EMPTY
82023: LIST
82024: LIST
82025: PPUSH
82026: CALL_OW 72
82030: ST_TO_ADDR
// for i = 1 to hexes do
82031: LD_ADDR_VAR 0 9
82035: PUSH
82036: DOUBLE
82037: LD_INT 1
82039: DEC
82040: ST_TO_ADDR
82041: LD_VAR 0 14
82045: PUSH
82046: FOR_TO
82047: IFFALSE 82723
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
82049: LD_ADDR_VAR 0 13
82053: PUSH
82054: LD_VAR 0 14
82058: PUSH
82059: LD_VAR 0 9
82063: ARRAY
82064: PUSH
82065: LD_INT 1
82067: ARRAY
82068: PPUSH
82069: LD_VAR 0 14
82073: PUSH
82074: LD_VAR 0 9
82078: ARRAY
82079: PUSH
82080: LD_INT 2
82082: ARRAY
82083: PPUSH
82084: CALL_OW 428
82088: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
82089: LD_VAR 0 14
82093: PUSH
82094: LD_VAR 0 9
82098: ARRAY
82099: PUSH
82100: LD_INT 1
82102: ARRAY
82103: PPUSH
82104: LD_VAR 0 14
82108: PUSH
82109: LD_VAR 0 9
82113: ARRAY
82114: PUSH
82115: LD_INT 2
82117: ARRAY
82118: PPUSH
82119: CALL_OW 351
82123: PUSH
82124: LD_VAR 0 14
82128: PUSH
82129: LD_VAR 0 9
82133: ARRAY
82134: PUSH
82135: LD_INT 1
82137: ARRAY
82138: PPUSH
82139: LD_VAR 0 14
82143: PUSH
82144: LD_VAR 0 9
82148: ARRAY
82149: PUSH
82150: LD_INT 2
82152: ARRAY
82153: PPUSH
82154: CALL_OW 488
82158: NOT
82159: OR
82160: PUSH
82161: LD_VAR 0 13
82165: PPUSH
82166: CALL_OW 247
82170: PUSH
82171: LD_INT 3
82173: EQUAL
82174: OR
82175: IFFALSE 82181
// exit ;
82177: POP
82178: POP
82179: GO 82725
// if not tmp then
82181: LD_VAR 0 13
82185: NOT
82186: IFFALSE 82190
// continue ;
82188: GO 82046
// result := true ;
82190: LD_ADDR_VAR 0 8
82194: PUSH
82195: LD_INT 1
82197: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
82198: LD_VAR 0 6
82202: PUSH
82203: LD_VAR 0 13
82207: PPUSH
82208: CALL_OW 247
82212: PUSH
82213: LD_INT 2
82215: EQUAL
82216: AND
82217: PUSH
82218: LD_VAR 0 13
82222: PPUSH
82223: CALL_OW 263
82227: PUSH
82228: LD_INT 1
82230: EQUAL
82231: AND
82232: IFFALSE 82396
// begin if IsDrivenBy ( tmp ) then
82234: LD_VAR 0 13
82238: PPUSH
82239: CALL_OW 311
82243: IFFALSE 82247
// continue ;
82245: GO 82046
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
82247: LD_VAR 0 6
82251: PPUSH
82252: LD_INT 3
82254: PUSH
82255: LD_INT 60
82257: PUSH
82258: EMPTY
82259: LIST
82260: PUSH
82261: EMPTY
82262: LIST
82263: LIST
82264: PUSH
82265: LD_INT 3
82267: PUSH
82268: LD_INT 55
82270: PUSH
82271: EMPTY
82272: LIST
82273: PUSH
82274: EMPTY
82275: LIST
82276: LIST
82277: PUSH
82278: EMPTY
82279: LIST
82280: LIST
82281: PPUSH
82282: CALL_OW 72
82286: IFFALSE 82394
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
82288: LD_ADDR_VAR 0 18
82292: PUSH
82293: LD_VAR 0 6
82297: PPUSH
82298: LD_INT 3
82300: PUSH
82301: LD_INT 60
82303: PUSH
82304: EMPTY
82305: LIST
82306: PUSH
82307: EMPTY
82308: LIST
82309: LIST
82310: PUSH
82311: LD_INT 3
82313: PUSH
82314: LD_INT 55
82316: PUSH
82317: EMPTY
82318: LIST
82319: PUSH
82320: EMPTY
82321: LIST
82322: LIST
82323: PUSH
82324: EMPTY
82325: LIST
82326: LIST
82327: PPUSH
82328: CALL_OW 72
82332: PUSH
82333: LD_INT 1
82335: ARRAY
82336: ST_TO_ADDR
// if IsInUnit ( driver ) then
82337: LD_VAR 0 18
82341: PPUSH
82342: CALL_OW 310
82346: IFFALSE 82357
// ComExit ( driver ) ;
82348: LD_VAR 0 18
82352: PPUSH
82353: CALL 107759 0 1
// AddComEnterUnit ( driver , tmp ) ;
82357: LD_VAR 0 18
82361: PPUSH
82362: LD_VAR 0 13
82366: PPUSH
82367: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
82371: LD_VAR 0 18
82375: PPUSH
82376: LD_VAR 0 7
82380: PPUSH
82381: CALL_OW 173
// AddComExitVehicle ( driver ) ;
82385: LD_VAR 0 18
82389: PPUSH
82390: CALL_OW 181
// end ; continue ;
82394: GO 82046
// end ; if not cleaners or not tmp in cleaners then
82396: LD_VAR 0 6
82400: NOT
82401: PUSH
82402: LD_VAR 0 13
82406: PUSH
82407: LD_VAR 0 6
82411: IN
82412: NOT
82413: OR
82414: IFFALSE 82721
// begin if dep then
82416: LD_VAR 0 17
82420: IFFALSE 82556
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
82422: LD_ADDR_VAR 0 16
82426: PUSH
82427: LD_VAR 0 17
82431: PUSH
82432: LD_INT 1
82434: ARRAY
82435: PPUSH
82436: CALL_OW 250
82440: PPUSH
82441: LD_VAR 0 17
82445: PUSH
82446: LD_INT 1
82448: ARRAY
82449: PPUSH
82450: CALL_OW 254
82454: PPUSH
82455: LD_INT 5
82457: PPUSH
82458: CALL_OW 272
82462: PUSH
82463: LD_VAR 0 17
82467: PUSH
82468: LD_INT 1
82470: ARRAY
82471: PPUSH
82472: CALL_OW 251
82476: PPUSH
82477: LD_VAR 0 17
82481: PUSH
82482: LD_INT 1
82484: ARRAY
82485: PPUSH
82486: CALL_OW 254
82490: PPUSH
82491: LD_INT 5
82493: PPUSH
82494: CALL_OW 273
82498: PUSH
82499: EMPTY
82500: LIST
82501: LIST
82502: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
82503: LD_VAR 0 16
82507: PUSH
82508: LD_INT 1
82510: ARRAY
82511: PPUSH
82512: LD_VAR 0 16
82516: PUSH
82517: LD_INT 2
82519: ARRAY
82520: PPUSH
82521: CALL_OW 488
82525: IFFALSE 82556
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
82527: LD_VAR 0 13
82531: PPUSH
82532: LD_VAR 0 16
82536: PUSH
82537: LD_INT 1
82539: ARRAY
82540: PPUSH
82541: LD_VAR 0 16
82545: PUSH
82546: LD_INT 2
82548: ARRAY
82549: PPUSH
82550: CALL_OW 111
// continue ;
82554: GO 82046
// end ; end ; r := GetDir ( tmp ) ;
82556: LD_ADDR_VAR 0 15
82560: PUSH
82561: LD_VAR 0 13
82565: PPUSH
82566: CALL_OW 254
82570: ST_TO_ADDR
// if r = 5 then
82571: LD_VAR 0 15
82575: PUSH
82576: LD_INT 5
82578: EQUAL
82579: IFFALSE 82589
// r := 0 ;
82581: LD_ADDR_VAR 0 15
82585: PUSH
82586: LD_INT 0
82588: ST_TO_ADDR
// for j = r to 5 do
82589: LD_ADDR_VAR 0 10
82593: PUSH
82594: DOUBLE
82595: LD_VAR 0 15
82599: DEC
82600: ST_TO_ADDR
82601: LD_INT 5
82603: PUSH
82604: FOR_TO
82605: IFFALSE 82719
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
82607: LD_ADDR_VAR 0 11
82611: PUSH
82612: LD_VAR 0 13
82616: PPUSH
82617: CALL_OW 250
82621: PPUSH
82622: LD_VAR 0 10
82626: PPUSH
82627: LD_INT 2
82629: PPUSH
82630: CALL_OW 272
82634: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
82635: LD_ADDR_VAR 0 12
82639: PUSH
82640: LD_VAR 0 13
82644: PPUSH
82645: CALL_OW 251
82649: PPUSH
82650: LD_VAR 0 10
82654: PPUSH
82655: LD_INT 2
82657: PPUSH
82658: CALL_OW 273
82662: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
82663: LD_VAR 0 11
82667: PPUSH
82668: LD_VAR 0 12
82672: PPUSH
82673: CALL_OW 488
82677: PUSH
82678: LD_VAR 0 11
82682: PPUSH
82683: LD_VAR 0 12
82687: PPUSH
82688: CALL_OW 428
82692: NOT
82693: AND
82694: IFFALSE 82717
// begin ComMoveXY ( tmp , _x , _y ) ;
82696: LD_VAR 0 13
82700: PPUSH
82701: LD_VAR 0 11
82705: PPUSH
82706: LD_VAR 0 12
82710: PPUSH
82711: CALL_OW 111
// break ;
82715: GO 82719
// end ; end ;
82717: GO 82604
82719: POP
82720: POP
// end ; end ;
82721: GO 82046
82723: POP
82724: POP
// end ;
82725: LD_VAR 0 8
82729: RET
// export function BuildingTechInvented ( side , btype ) ; begin
82730: LD_INT 0
82732: PPUSH
// result := true ;
82733: LD_ADDR_VAR 0 3
82737: PUSH
82738: LD_INT 1
82740: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
82741: LD_VAR 0 2
82745: PUSH
82746: LD_INT 24
82748: DOUBLE
82749: EQUAL
82750: IFTRUE 82760
82752: LD_INT 33
82754: DOUBLE
82755: EQUAL
82756: IFTRUE 82760
82758: GO 82785
82760: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
82761: LD_ADDR_VAR 0 3
82765: PUSH
82766: LD_INT 32
82768: PPUSH
82769: LD_VAR 0 1
82773: PPUSH
82774: CALL_OW 321
82778: PUSH
82779: LD_INT 2
82781: EQUAL
82782: ST_TO_ADDR
82783: GO 83101
82785: LD_INT 20
82787: DOUBLE
82788: EQUAL
82789: IFTRUE 82793
82791: GO 82818
82793: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
82794: LD_ADDR_VAR 0 3
82798: PUSH
82799: LD_INT 6
82801: PPUSH
82802: LD_VAR 0 1
82806: PPUSH
82807: CALL_OW 321
82811: PUSH
82812: LD_INT 2
82814: EQUAL
82815: ST_TO_ADDR
82816: GO 83101
82818: LD_INT 22
82820: DOUBLE
82821: EQUAL
82822: IFTRUE 82832
82824: LD_INT 36
82826: DOUBLE
82827: EQUAL
82828: IFTRUE 82832
82830: GO 82857
82832: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
82833: LD_ADDR_VAR 0 3
82837: PUSH
82838: LD_INT 15
82840: PPUSH
82841: LD_VAR 0 1
82845: PPUSH
82846: CALL_OW 321
82850: PUSH
82851: LD_INT 2
82853: EQUAL
82854: ST_TO_ADDR
82855: GO 83101
82857: LD_INT 30
82859: DOUBLE
82860: EQUAL
82861: IFTRUE 82865
82863: GO 82890
82865: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
82866: LD_ADDR_VAR 0 3
82870: PUSH
82871: LD_INT 20
82873: PPUSH
82874: LD_VAR 0 1
82878: PPUSH
82879: CALL_OW 321
82883: PUSH
82884: LD_INT 2
82886: EQUAL
82887: ST_TO_ADDR
82888: GO 83101
82890: LD_INT 28
82892: DOUBLE
82893: EQUAL
82894: IFTRUE 82904
82896: LD_INT 21
82898: DOUBLE
82899: EQUAL
82900: IFTRUE 82904
82902: GO 82929
82904: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
82905: LD_ADDR_VAR 0 3
82909: PUSH
82910: LD_INT 21
82912: PPUSH
82913: LD_VAR 0 1
82917: PPUSH
82918: CALL_OW 321
82922: PUSH
82923: LD_INT 2
82925: EQUAL
82926: ST_TO_ADDR
82927: GO 83101
82929: LD_INT 16
82931: DOUBLE
82932: EQUAL
82933: IFTRUE 82937
82935: GO 82962
82937: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
82938: LD_ADDR_VAR 0 3
82942: PUSH
82943: LD_INT 84
82945: PPUSH
82946: LD_VAR 0 1
82950: PPUSH
82951: CALL_OW 321
82955: PUSH
82956: LD_INT 2
82958: EQUAL
82959: ST_TO_ADDR
82960: GO 83101
82962: LD_INT 19
82964: DOUBLE
82965: EQUAL
82966: IFTRUE 82976
82968: LD_INT 23
82970: DOUBLE
82971: EQUAL
82972: IFTRUE 82976
82974: GO 83001
82976: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
82977: LD_ADDR_VAR 0 3
82981: PUSH
82982: LD_INT 83
82984: PPUSH
82985: LD_VAR 0 1
82989: PPUSH
82990: CALL_OW 321
82994: PUSH
82995: LD_INT 2
82997: EQUAL
82998: ST_TO_ADDR
82999: GO 83101
83001: LD_INT 17
83003: DOUBLE
83004: EQUAL
83005: IFTRUE 83009
83007: GO 83034
83009: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
83010: LD_ADDR_VAR 0 3
83014: PUSH
83015: LD_INT 39
83017: PPUSH
83018: LD_VAR 0 1
83022: PPUSH
83023: CALL_OW 321
83027: PUSH
83028: LD_INT 2
83030: EQUAL
83031: ST_TO_ADDR
83032: GO 83101
83034: LD_INT 18
83036: DOUBLE
83037: EQUAL
83038: IFTRUE 83042
83040: GO 83067
83042: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
83043: LD_ADDR_VAR 0 3
83047: PUSH
83048: LD_INT 40
83050: PPUSH
83051: LD_VAR 0 1
83055: PPUSH
83056: CALL_OW 321
83060: PUSH
83061: LD_INT 2
83063: EQUAL
83064: ST_TO_ADDR
83065: GO 83101
83067: LD_INT 27
83069: DOUBLE
83070: EQUAL
83071: IFTRUE 83075
83073: GO 83100
83075: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
83076: LD_ADDR_VAR 0 3
83080: PUSH
83081: LD_INT 35
83083: PPUSH
83084: LD_VAR 0 1
83088: PPUSH
83089: CALL_OW 321
83093: PUSH
83094: LD_INT 2
83096: EQUAL
83097: ST_TO_ADDR
83098: GO 83101
83100: POP
// end ;
83101: LD_VAR 0 3
83105: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
83106: LD_INT 0
83108: PPUSH
83109: PPUSH
83110: PPUSH
83111: PPUSH
83112: PPUSH
83113: PPUSH
83114: PPUSH
83115: PPUSH
83116: PPUSH
83117: PPUSH
83118: PPUSH
// result := false ;
83119: LD_ADDR_VAR 0 6
83123: PUSH
83124: LD_INT 0
83126: ST_TO_ADDR
// if btype = b_depot then
83127: LD_VAR 0 2
83131: PUSH
83132: LD_INT 0
83134: EQUAL
83135: IFFALSE 83147
// begin result := true ;
83137: LD_ADDR_VAR 0 6
83141: PUSH
83142: LD_INT 1
83144: ST_TO_ADDR
// exit ;
83145: GO 83973
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
83147: LD_VAR 0 1
83151: NOT
83152: PUSH
83153: LD_VAR 0 1
83157: PPUSH
83158: CALL_OW 266
83162: PUSH
83163: LD_INT 0
83165: PUSH
83166: LD_INT 1
83168: PUSH
83169: EMPTY
83170: LIST
83171: LIST
83172: IN
83173: NOT
83174: OR
83175: PUSH
83176: LD_VAR 0 2
83180: NOT
83181: OR
83182: PUSH
83183: LD_VAR 0 5
83187: PUSH
83188: LD_INT 0
83190: PUSH
83191: LD_INT 1
83193: PUSH
83194: LD_INT 2
83196: PUSH
83197: LD_INT 3
83199: PUSH
83200: LD_INT 4
83202: PUSH
83203: LD_INT 5
83205: PUSH
83206: EMPTY
83207: LIST
83208: LIST
83209: LIST
83210: LIST
83211: LIST
83212: LIST
83213: IN
83214: NOT
83215: OR
83216: PUSH
83217: LD_VAR 0 3
83221: PPUSH
83222: LD_VAR 0 4
83226: PPUSH
83227: CALL_OW 488
83231: NOT
83232: OR
83233: IFFALSE 83237
// exit ;
83235: GO 83973
// side := GetSide ( depot ) ;
83237: LD_ADDR_VAR 0 9
83241: PUSH
83242: LD_VAR 0 1
83246: PPUSH
83247: CALL_OW 255
83251: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
83252: LD_VAR 0 9
83256: PPUSH
83257: LD_VAR 0 2
83261: PPUSH
83262: CALL 82730 0 2
83266: NOT
83267: IFFALSE 83271
// exit ;
83269: GO 83973
// pom := GetBase ( depot ) ;
83271: LD_ADDR_VAR 0 10
83275: PUSH
83276: LD_VAR 0 1
83280: PPUSH
83281: CALL_OW 274
83285: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
83286: LD_ADDR_VAR 0 11
83290: PUSH
83291: LD_VAR 0 2
83295: PPUSH
83296: LD_VAR 0 1
83300: PPUSH
83301: CALL_OW 248
83305: PPUSH
83306: CALL_OW 450
83310: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
83311: LD_VAR 0 10
83315: PPUSH
83316: LD_INT 1
83318: PPUSH
83319: CALL_OW 275
83323: PUSH
83324: LD_VAR 0 11
83328: PUSH
83329: LD_INT 1
83331: ARRAY
83332: GREATEREQUAL
83333: PUSH
83334: LD_VAR 0 10
83338: PPUSH
83339: LD_INT 2
83341: PPUSH
83342: CALL_OW 275
83346: PUSH
83347: LD_VAR 0 11
83351: PUSH
83352: LD_INT 2
83354: ARRAY
83355: GREATEREQUAL
83356: AND
83357: PUSH
83358: LD_VAR 0 10
83362: PPUSH
83363: LD_INT 3
83365: PPUSH
83366: CALL_OW 275
83370: PUSH
83371: LD_VAR 0 11
83375: PUSH
83376: LD_INT 3
83378: ARRAY
83379: GREATEREQUAL
83380: AND
83381: NOT
83382: IFFALSE 83386
// exit ;
83384: GO 83973
// if GetBType ( depot ) = b_depot then
83386: LD_VAR 0 1
83390: PPUSH
83391: CALL_OW 266
83395: PUSH
83396: LD_INT 0
83398: EQUAL
83399: IFFALSE 83411
// dist := 28 else
83401: LD_ADDR_VAR 0 14
83405: PUSH
83406: LD_INT 28
83408: ST_TO_ADDR
83409: GO 83419
// dist := 36 ;
83411: LD_ADDR_VAR 0 14
83415: PUSH
83416: LD_INT 36
83418: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
83419: LD_VAR 0 1
83423: PPUSH
83424: LD_VAR 0 3
83428: PPUSH
83429: LD_VAR 0 4
83433: PPUSH
83434: CALL_OW 297
83438: PUSH
83439: LD_VAR 0 14
83443: GREATER
83444: IFFALSE 83448
// exit ;
83446: GO 83973
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
83448: LD_ADDR_VAR 0 12
83452: PUSH
83453: LD_VAR 0 2
83457: PPUSH
83458: LD_VAR 0 3
83462: PPUSH
83463: LD_VAR 0 4
83467: PPUSH
83468: LD_VAR 0 5
83472: PPUSH
83473: LD_VAR 0 1
83477: PPUSH
83478: CALL_OW 248
83482: PPUSH
83483: LD_INT 0
83485: PPUSH
83486: CALL 83978 0 6
83490: ST_TO_ADDR
// if not hexes then
83491: LD_VAR 0 12
83495: NOT
83496: IFFALSE 83500
// exit ;
83498: GO 83973
// hex := GetHexInfo ( x , y ) ;
83500: LD_ADDR_VAR 0 15
83504: PUSH
83505: LD_VAR 0 3
83509: PPUSH
83510: LD_VAR 0 4
83514: PPUSH
83515: CALL_OW 546
83519: ST_TO_ADDR
// if hex [ 1 ] then
83520: LD_VAR 0 15
83524: PUSH
83525: LD_INT 1
83527: ARRAY
83528: IFFALSE 83532
// exit ;
83530: GO 83973
// height := hex [ 2 ] ;
83532: LD_ADDR_VAR 0 13
83536: PUSH
83537: LD_VAR 0 15
83541: PUSH
83542: LD_INT 2
83544: ARRAY
83545: ST_TO_ADDR
// for i = 1 to hexes do
83546: LD_ADDR_VAR 0 7
83550: PUSH
83551: DOUBLE
83552: LD_INT 1
83554: DEC
83555: ST_TO_ADDR
83556: LD_VAR 0 12
83560: PUSH
83561: FOR_TO
83562: IFFALSE 83892
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
83564: LD_VAR 0 12
83568: PUSH
83569: LD_VAR 0 7
83573: ARRAY
83574: PUSH
83575: LD_INT 1
83577: ARRAY
83578: PPUSH
83579: LD_VAR 0 12
83583: PUSH
83584: LD_VAR 0 7
83588: ARRAY
83589: PUSH
83590: LD_INT 2
83592: ARRAY
83593: PPUSH
83594: CALL_OW 488
83598: NOT
83599: PUSH
83600: LD_VAR 0 12
83604: PUSH
83605: LD_VAR 0 7
83609: ARRAY
83610: PUSH
83611: LD_INT 1
83613: ARRAY
83614: PPUSH
83615: LD_VAR 0 12
83619: PUSH
83620: LD_VAR 0 7
83624: ARRAY
83625: PUSH
83626: LD_INT 2
83628: ARRAY
83629: PPUSH
83630: CALL_OW 428
83634: PUSH
83635: LD_INT 0
83637: GREATER
83638: OR
83639: PUSH
83640: LD_VAR 0 12
83644: PUSH
83645: LD_VAR 0 7
83649: ARRAY
83650: PUSH
83651: LD_INT 1
83653: ARRAY
83654: PPUSH
83655: LD_VAR 0 12
83659: PUSH
83660: LD_VAR 0 7
83664: ARRAY
83665: PUSH
83666: LD_INT 2
83668: ARRAY
83669: PPUSH
83670: CALL_OW 351
83674: OR
83675: IFFALSE 83681
// exit ;
83677: POP
83678: POP
83679: GO 83973
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
83681: LD_ADDR_VAR 0 8
83685: PUSH
83686: LD_VAR 0 12
83690: PUSH
83691: LD_VAR 0 7
83695: ARRAY
83696: PUSH
83697: LD_INT 1
83699: ARRAY
83700: PPUSH
83701: LD_VAR 0 12
83705: PUSH
83706: LD_VAR 0 7
83710: ARRAY
83711: PUSH
83712: LD_INT 2
83714: ARRAY
83715: PPUSH
83716: CALL_OW 546
83720: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
83721: LD_VAR 0 8
83725: PUSH
83726: LD_INT 1
83728: ARRAY
83729: PUSH
83730: LD_VAR 0 8
83734: PUSH
83735: LD_INT 2
83737: ARRAY
83738: PUSH
83739: LD_VAR 0 13
83743: PUSH
83744: LD_INT 2
83746: PLUS
83747: GREATER
83748: OR
83749: PUSH
83750: LD_VAR 0 8
83754: PUSH
83755: LD_INT 2
83757: ARRAY
83758: PUSH
83759: LD_VAR 0 13
83763: PUSH
83764: LD_INT 2
83766: MINUS
83767: LESS
83768: OR
83769: PUSH
83770: LD_VAR 0 8
83774: PUSH
83775: LD_INT 3
83777: ARRAY
83778: PUSH
83779: LD_INT 0
83781: PUSH
83782: LD_INT 8
83784: PUSH
83785: LD_INT 9
83787: PUSH
83788: LD_INT 10
83790: PUSH
83791: LD_INT 11
83793: PUSH
83794: LD_INT 12
83796: PUSH
83797: LD_INT 13
83799: PUSH
83800: LD_INT 16
83802: PUSH
83803: LD_INT 17
83805: PUSH
83806: LD_INT 18
83808: PUSH
83809: LD_INT 19
83811: PUSH
83812: LD_INT 20
83814: PUSH
83815: LD_INT 21
83817: PUSH
83818: EMPTY
83819: LIST
83820: LIST
83821: LIST
83822: LIST
83823: LIST
83824: LIST
83825: LIST
83826: LIST
83827: LIST
83828: LIST
83829: LIST
83830: LIST
83831: LIST
83832: IN
83833: NOT
83834: OR
83835: PUSH
83836: LD_VAR 0 8
83840: PUSH
83841: LD_INT 5
83843: ARRAY
83844: NOT
83845: OR
83846: PUSH
83847: LD_VAR 0 8
83851: PUSH
83852: LD_INT 6
83854: ARRAY
83855: PUSH
83856: LD_INT 1
83858: PUSH
83859: LD_INT 2
83861: PUSH
83862: LD_INT 7
83864: PUSH
83865: LD_INT 9
83867: PUSH
83868: LD_INT 10
83870: PUSH
83871: LD_INT 11
83873: PUSH
83874: EMPTY
83875: LIST
83876: LIST
83877: LIST
83878: LIST
83879: LIST
83880: LIST
83881: IN
83882: NOT
83883: OR
83884: IFFALSE 83890
// exit ;
83886: POP
83887: POP
83888: GO 83973
// end ;
83890: GO 83561
83892: POP
83893: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
83894: LD_VAR 0 9
83898: PPUSH
83899: LD_VAR 0 3
83903: PPUSH
83904: LD_VAR 0 4
83908: PPUSH
83909: LD_INT 20
83911: PPUSH
83912: CALL 75896 0 4
83916: PUSH
83917: LD_INT 4
83919: ARRAY
83920: IFFALSE 83924
// exit ;
83922: GO 83973
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
83924: LD_VAR 0 2
83928: PUSH
83929: LD_INT 29
83931: PUSH
83932: LD_INT 30
83934: PUSH
83935: EMPTY
83936: LIST
83937: LIST
83938: IN
83939: PUSH
83940: LD_VAR 0 3
83944: PPUSH
83945: LD_VAR 0 4
83949: PPUSH
83950: LD_VAR 0 9
83954: PPUSH
83955: CALL_OW 440
83959: NOT
83960: AND
83961: IFFALSE 83965
// exit ;
83963: GO 83973
// result := true ;
83965: LD_ADDR_VAR 0 6
83969: PUSH
83970: LD_INT 1
83972: ST_TO_ADDR
// end ;
83973: LD_VAR 0 6
83977: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
83978: LD_INT 0
83980: PPUSH
83981: PPUSH
83982: PPUSH
83983: PPUSH
83984: PPUSH
83985: PPUSH
83986: PPUSH
83987: PPUSH
83988: PPUSH
83989: PPUSH
83990: PPUSH
83991: PPUSH
83992: PPUSH
83993: PPUSH
83994: PPUSH
83995: PPUSH
83996: PPUSH
83997: PPUSH
83998: PPUSH
83999: PPUSH
84000: PPUSH
84001: PPUSH
84002: PPUSH
84003: PPUSH
84004: PPUSH
84005: PPUSH
84006: PPUSH
84007: PPUSH
84008: PPUSH
84009: PPUSH
84010: PPUSH
84011: PPUSH
84012: PPUSH
84013: PPUSH
84014: PPUSH
84015: PPUSH
84016: PPUSH
84017: PPUSH
84018: PPUSH
84019: PPUSH
84020: PPUSH
84021: PPUSH
84022: PPUSH
84023: PPUSH
84024: PPUSH
84025: PPUSH
84026: PPUSH
84027: PPUSH
84028: PPUSH
84029: PPUSH
84030: PPUSH
84031: PPUSH
84032: PPUSH
84033: PPUSH
84034: PPUSH
84035: PPUSH
84036: PPUSH
84037: PPUSH
// result = [ ] ;
84038: LD_ADDR_VAR 0 7
84042: PUSH
84043: EMPTY
84044: ST_TO_ADDR
// temp_list = [ ] ;
84045: LD_ADDR_VAR 0 9
84049: PUSH
84050: EMPTY
84051: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
84052: LD_VAR 0 4
84056: PUSH
84057: LD_INT 0
84059: PUSH
84060: LD_INT 1
84062: PUSH
84063: LD_INT 2
84065: PUSH
84066: LD_INT 3
84068: PUSH
84069: LD_INT 4
84071: PUSH
84072: LD_INT 5
84074: PUSH
84075: EMPTY
84076: LIST
84077: LIST
84078: LIST
84079: LIST
84080: LIST
84081: LIST
84082: IN
84083: NOT
84084: PUSH
84085: LD_VAR 0 1
84089: PUSH
84090: LD_INT 0
84092: PUSH
84093: LD_INT 1
84095: PUSH
84096: EMPTY
84097: LIST
84098: LIST
84099: IN
84100: PUSH
84101: LD_VAR 0 5
84105: PUSH
84106: LD_INT 1
84108: PUSH
84109: LD_INT 2
84111: PUSH
84112: LD_INT 3
84114: PUSH
84115: EMPTY
84116: LIST
84117: LIST
84118: LIST
84119: IN
84120: NOT
84121: AND
84122: OR
84123: IFFALSE 84127
// exit ;
84125: GO 102518
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
84127: LD_VAR 0 1
84131: PUSH
84132: LD_INT 6
84134: PUSH
84135: LD_INT 7
84137: PUSH
84138: LD_INT 8
84140: PUSH
84141: LD_INT 13
84143: PUSH
84144: LD_INT 12
84146: PUSH
84147: LD_INT 15
84149: PUSH
84150: LD_INT 11
84152: PUSH
84153: LD_INT 14
84155: PUSH
84156: LD_INT 10
84158: PUSH
84159: EMPTY
84160: LIST
84161: LIST
84162: LIST
84163: LIST
84164: LIST
84165: LIST
84166: LIST
84167: LIST
84168: LIST
84169: IN
84170: IFFALSE 84180
// btype = b_lab ;
84172: LD_ADDR_VAR 0 1
84176: PUSH
84177: LD_INT 6
84179: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
84180: LD_VAR 0 6
84184: PUSH
84185: LD_INT 0
84187: PUSH
84188: LD_INT 1
84190: PUSH
84191: LD_INT 2
84193: PUSH
84194: EMPTY
84195: LIST
84196: LIST
84197: LIST
84198: IN
84199: NOT
84200: PUSH
84201: LD_VAR 0 1
84205: PUSH
84206: LD_INT 0
84208: PUSH
84209: LD_INT 1
84211: PUSH
84212: LD_INT 2
84214: PUSH
84215: LD_INT 3
84217: PUSH
84218: LD_INT 6
84220: PUSH
84221: LD_INT 36
84223: PUSH
84224: LD_INT 4
84226: PUSH
84227: LD_INT 5
84229: PUSH
84230: LD_INT 31
84232: PUSH
84233: LD_INT 32
84235: PUSH
84236: LD_INT 33
84238: PUSH
84239: EMPTY
84240: LIST
84241: LIST
84242: LIST
84243: LIST
84244: LIST
84245: LIST
84246: LIST
84247: LIST
84248: LIST
84249: LIST
84250: LIST
84251: IN
84252: NOT
84253: PUSH
84254: LD_VAR 0 6
84258: PUSH
84259: LD_INT 1
84261: EQUAL
84262: AND
84263: OR
84264: PUSH
84265: LD_VAR 0 1
84269: PUSH
84270: LD_INT 2
84272: PUSH
84273: LD_INT 3
84275: PUSH
84276: EMPTY
84277: LIST
84278: LIST
84279: IN
84280: NOT
84281: PUSH
84282: LD_VAR 0 6
84286: PUSH
84287: LD_INT 2
84289: EQUAL
84290: AND
84291: OR
84292: IFFALSE 84302
// mode = 0 ;
84294: LD_ADDR_VAR 0 6
84298: PUSH
84299: LD_INT 0
84301: ST_TO_ADDR
// case mode of 0 :
84302: LD_VAR 0 6
84306: PUSH
84307: LD_INT 0
84309: DOUBLE
84310: EQUAL
84311: IFTRUE 84315
84313: GO 95768
84315: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
84316: LD_ADDR_VAR 0 11
84320: PUSH
84321: LD_INT 0
84323: PUSH
84324: LD_INT 0
84326: PUSH
84327: EMPTY
84328: LIST
84329: LIST
84330: PUSH
84331: LD_INT 0
84333: PUSH
84334: LD_INT 1
84336: NEG
84337: PUSH
84338: EMPTY
84339: LIST
84340: LIST
84341: PUSH
84342: LD_INT 1
84344: PUSH
84345: LD_INT 0
84347: PUSH
84348: EMPTY
84349: LIST
84350: LIST
84351: PUSH
84352: LD_INT 1
84354: PUSH
84355: LD_INT 1
84357: PUSH
84358: EMPTY
84359: LIST
84360: LIST
84361: PUSH
84362: LD_INT 0
84364: PUSH
84365: LD_INT 1
84367: PUSH
84368: EMPTY
84369: LIST
84370: LIST
84371: PUSH
84372: LD_INT 1
84374: NEG
84375: PUSH
84376: LD_INT 0
84378: PUSH
84379: EMPTY
84380: LIST
84381: LIST
84382: PUSH
84383: LD_INT 1
84385: NEG
84386: PUSH
84387: LD_INT 1
84389: NEG
84390: PUSH
84391: EMPTY
84392: LIST
84393: LIST
84394: PUSH
84395: LD_INT 1
84397: NEG
84398: PUSH
84399: LD_INT 2
84401: NEG
84402: PUSH
84403: EMPTY
84404: LIST
84405: LIST
84406: PUSH
84407: LD_INT 0
84409: PUSH
84410: LD_INT 2
84412: NEG
84413: PUSH
84414: EMPTY
84415: LIST
84416: LIST
84417: PUSH
84418: LD_INT 1
84420: PUSH
84421: LD_INT 1
84423: NEG
84424: PUSH
84425: EMPTY
84426: LIST
84427: LIST
84428: PUSH
84429: LD_INT 1
84431: PUSH
84432: LD_INT 2
84434: PUSH
84435: EMPTY
84436: LIST
84437: LIST
84438: PUSH
84439: LD_INT 0
84441: PUSH
84442: LD_INT 2
84444: PUSH
84445: EMPTY
84446: LIST
84447: LIST
84448: PUSH
84449: LD_INT 1
84451: NEG
84452: PUSH
84453: LD_INT 1
84455: PUSH
84456: EMPTY
84457: LIST
84458: LIST
84459: PUSH
84460: LD_INT 1
84462: PUSH
84463: LD_INT 3
84465: PUSH
84466: EMPTY
84467: LIST
84468: LIST
84469: PUSH
84470: LD_INT 0
84472: PUSH
84473: LD_INT 3
84475: PUSH
84476: EMPTY
84477: LIST
84478: LIST
84479: PUSH
84480: LD_INT 1
84482: NEG
84483: PUSH
84484: LD_INT 2
84486: PUSH
84487: EMPTY
84488: LIST
84489: LIST
84490: PUSH
84491: EMPTY
84492: LIST
84493: LIST
84494: LIST
84495: LIST
84496: LIST
84497: LIST
84498: LIST
84499: LIST
84500: LIST
84501: LIST
84502: LIST
84503: LIST
84504: LIST
84505: LIST
84506: LIST
84507: LIST
84508: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
84509: LD_ADDR_VAR 0 12
84513: PUSH
84514: LD_INT 0
84516: PUSH
84517: LD_INT 0
84519: PUSH
84520: EMPTY
84521: LIST
84522: LIST
84523: PUSH
84524: LD_INT 0
84526: PUSH
84527: LD_INT 1
84529: NEG
84530: PUSH
84531: EMPTY
84532: LIST
84533: LIST
84534: PUSH
84535: LD_INT 1
84537: PUSH
84538: LD_INT 0
84540: PUSH
84541: EMPTY
84542: LIST
84543: LIST
84544: PUSH
84545: LD_INT 1
84547: PUSH
84548: LD_INT 1
84550: PUSH
84551: EMPTY
84552: LIST
84553: LIST
84554: PUSH
84555: LD_INT 0
84557: PUSH
84558: LD_INT 1
84560: PUSH
84561: EMPTY
84562: LIST
84563: LIST
84564: PUSH
84565: LD_INT 1
84567: NEG
84568: PUSH
84569: LD_INT 0
84571: PUSH
84572: EMPTY
84573: LIST
84574: LIST
84575: PUSH
84576: LD_INT 1
84578: NEG
84579: PUSH
84580: LD_INT 1
84582: NEG
84583: PUSH
84584: EMPTY
84585: LIST
84586: LIST
84587: PUSH
84588: LD_INT 1
84590: PUSH
84591: LD_INT 1
84593: NEG
84594: PUSH
84595: EMPTY
84596: LIST
84597: LIST
84598: PUSH
84599: LD_INT 2
84601: PUSH
84602: LD_INT 0
84604: PUSH
84605: EMPTY
84606: LIST
84607: LIST
84608: PUSH
84609: LD_INT 2
84611: PUSH
84612: LD_INT 1
84614: PUSH
84615: EMPTY
84616: LIST
84617: LIST
84618: PUSH
84619: LD_INT 1
84621: NEG
84622: PUSH
84623: LD_INT 1
84625: PUSH
84626: EMPTY
84627: LIST
84628: LIST
84629: PUSH
84630: LD_INT 2
84632: NEG
84633: PUSH
84634: LD_INT 0
84636: PUSH
84637: EMPTY
84638: LIST
84639: LIST
84640: PUSH
84641: LD_INT 2
84643: NEG
84644: PUSH
84645: LD_INT 1
84647: NEG
84648: PUSH
84649: EMPTY
84650: LIST
84651: LIST
84652: PUSH
84653: LD_INT 2
84655: NEG
84656: PUSH
84657: LD_INT 1
84659: PUSH
84660: EMPTY
84661: LIST
84662: LIST
84663: PUSH
84664: LD_INT 3
84666: NEG
84667: PUSH
84668: LD_INT 0
84670: PUSH
84671: EMPTY
84672: LIST
84673: LIST
84674: PUSH
84675: LD_INT 3
84677: NEG
84678: PUSH
84679: LD_INT 1
84681: NEG
84682: PUSH
84683: EMPTY
84684: LIST
84685: LIST
84686: PUSH
84687: EMPTY
84688: LIST
84689: LIST
84690: LIST
84691: LIST
84692: LIST
84693: LIST
84694: LIST
84695: LIST
84696: LIST
84697: LIST
84698: LIST
84699: LIST
84700: LIST
84701: LIST
84702: LIST
84703: LIST
84704: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84705: LD_ADDR_VAR 0 13
84709: PUSH
84710: LD_INT 0
84712: PUSH
84713: LD_INT 0
84715: PUSH
84716: EMPTY
84717: LIST
84718: LIST
84719: PUSH
84720: LD_INT 0
84722: PUSH
84723: LD_INT 1
84725: NEG
84726: PUSH
84727: EMPTY
84728: LIST
84729: LIST
84730: PUSH
84731: LD_INT 1
84733: PUSH
84734: LD_INT 0
84736: PUSH
84737: EMPTY
84738: LIST
84739: LIST
84740: PUSH
84741: LD_INT 1
84743: PUSH
84744: LD_INT 1
84746: PUSH
84747: EMPTY
84748: LIST
84749: LIST
84750: PUSH
84751: LD_INT 0
84753: PUSH
84754: LD_INT 1
84756: PUSH
84757: EMPTY
84758: LIST
84759: LIST
84760: PUSH
84761: LD_INT 1
84763: NEG
84764: PUSH
84765: LD_INT 0
84767: PUSH
84768: EMPTY
84769: LIST
84770: LIST
84771: PUSH
84772: LD_INT 1
84774: NEG
84775: PUSH
84776: LD_INT 1
84778: NEG
84779: PUSH
84780: EMPTY
84781: LIST
84782: LIST
84783: PUSH
84784: LD_INT 1
84786: NEG
84787: PUSH
84788: LD_INT 2
84790: NEG
84791: PUSH
84792: EMPTY
84793: LIST
84794: LIST
84795: PUSH
84796: LD_INT 2
84798: PUSH
84799: LD_INT 1
84801: PUSH
84802: EMPTY
84803: LIST
84804: LIST
84805: PUSH
84806: LD_INT 2
84808: PUSH
84809: LD_INT 2
84811: PUSH
84812: EMPTY
84813: LIST
84814: LIST
84815: PUSH
84816: LD_INT 1
84818: PUSH
84819: LD_INT 2
84821: PUSH
84822: EMPTY
84823: LIST
84824: LIST
84825: PUSH
84826: LD_INT 2
84828: NEG
84829: PUSH
84830: LD_INT 1
84832: NEG
84833: PUSH
84834: EMPTY
84835: LIST
84836: LIST
84837: PUSH
84838: LD_INT 2
84840: NEG
84841: PUSH
84842: LD_INT 2
84844: NEG
84845: PUSH
84846: EMPTY
84847: LIST
84848: LIST
84849: PUSH
84850: LD_INT 2
84852: NEG
84853: PUSH
84854: LD_INT 3
84856: NEG
84857: PUSH
84858: EMPTY
84859: LIST
84860: LIST
84861: PUSH
84862: LD_INT 3
84864: NEG
84865: PUSH
84866: LD_INT 2
84868: NEG
84869: PUSH
84870: EMPTY
84871: LIST
84872: LIST
84873: PUSH
84874: LD_INT 3
84876: NEG
84877: PUSH
84878: LD_INT 3
84880: NEG
84881: PUSH
84882: EMPTY
84883: LIST
84884: LIST
84885: PUSH
84886: EMPTY
84887: LIST
84888: LIST
84889: LIST
84890: LIST
84891: LIST
84892: LIST
84893: LIST
84894: LIST
84895: LIST
84896: LIST
84897: LIST
84898: LIST
84899: LIST
84900: LIST
84901: LIST
84902: LIST
84903: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
84904: LD_ADDR_VAR 0 14
84908: PUSH
84909: LD_INT 0
84911: PUSH
84912: LD_INT 0
84914: PUSH
84915: EMPTY
84916: LIST
84917: LIST
84918: PUSH
84919: LD_INT 0
84921: PUSH
84922: LD_INT 1
84924: NEG
84925: PUSH
84926: EMPTY
84927: LIST
84928: LIST
84929: PUSH
84930: LD_INT 1
84932: PUSH
84933: LD_INT 0
84935: PUSH
84936: EMPTY
84937: LIST
84938: LIST
84939: PUSH
84940: LD_INT 1
84942: PUSH
84943: LD_INT 1
84945: PUSH
84946: EMPTY
84947: LIST
84948: LIST
84949: PUSH
84950: LD_INT 0
84952: PUSH
84953: LD_INT 1
84955: PUSH
84956: EMPTY
84957: LIST
84958: LIST
84959: PUSH
84960: LD_INT 1
84962: NEG
84963: PUSH
84964: LD_INT 0
84966: PUSH
84967: EMPTY
84968: LIST
84969: LIST
84970: PUSH
84971: LD_INT 1
84973: NEG
84974: PUSH
84975: LD_INT 1
84977: NEG
84978: PUSH
84979: EMPTY
84980: LIST
84981: LIST
84982: PUSH
84983: LD_INT 1
84985: NEG
84986: PUSH
84987: LD_INT 2
84989: NEG
84990: PUSH
84991: EMPTY
84992: LIST
84993: LIST
84994: PUSH
84995: LD_INT 0
84997: PUSH
84998: LD_INT 2
85000: NEG
85001: PUSH
85002: EMPTY
85003: LIST
85004: LIST
85005: PUSH
85006: LD_INT 1
85008: PUSH
85009: LD_INT 1
85011: NEG
85012: PUSH
85013: EMPTY
85014: LIST
85015: LIST
85016: PUSH
85017: LD_INT 1
85019: PUSH
85020: LD_INT 2
85022: PUSH
85023: EMPTY
85024: LIST
85025: LIST
85026: PUSH
85027: LD_INT 0
85029: PUSH
85030: LD_INT 2
85032: PUSH
85033: EMPTY
85034: LIST
85035: LIST
85036: PUSH
85037: LD_INT 1
85039: NEG
85040: PUSH
85041: LD_INT 1
85043: PUSH
85044: EMPTY
85045: LIST
85046: LIST
85047: PUSH
85048: LD_INT 1
85050: NEG
85051: PUSH
85052: LD_INT 3
85054: NEG
85055: PUSH
85056: EMPTY
85057: LIST
85058: LIST
85059: PUSH
85060: LD_INT 0
85062: PUSH
85063: LD_INT 3
85065: NEG
85066: PUSH
85067: EMPTY
85068: LIST
85069: LIST
85070: PUSH
85071: LD_INT 1
85073: PUSH
85074: LD_INT 2
85076: NEG
85077: PUSH
85078: EMPTY
85079: LIST
85080: LIST
85081: PUSH
85082: EMPTY
85083: LIST
85084: LIST
85085: LIST
85086: LIST
85087: LIST
85088: LIST
85089: LIST
85090: LIST
85091: LIST
85092: LIST
85093: LIST
85094: LIST
85095: LIST
85096: LIST
85097: LIST
85098: LIST
85099: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
85100: LD_ADDR_VAR 0 15
85104: PUSH
85105: LD_INT 0
85107: PUSH
85108: LD_INT 0
85110: PUSH
85111: EMPTY
85112: LIST
85113: LIST
85114: PUSH
85115: LD_INT 0
85117: PUSH
85118: LD_INT 1
85120: NEG
85121: PUSH
85122: EMPTY
85123: LIST
85124: LIST
85125: PUSH
85126: LD_INT 1
85128: PUSH
85129: LD_INT 0
85131: PUSH
85132: EMPTY
85133: LIST
85134: LIST
85135: PUSH
85136: LD_INT 1
85138: PUSH
85139: LD_INT 1
85141: PUSH
85142: EMPTY
85143: LIST
85144: LIST
85145: PUSH
85146: LD_INT 0
85148: PUSH
85149: LD_INT 1
85151: PUSH
85152: EMPTY
85153: LIST
85154: LIST
85155: PUSH
85156: LD_INT 1
85158: NEG
85159: PUSH
85160: LD_INT 0
85162: PUSH
85163: EMPTY
85164: LIST
85165: LIST
85166: PUSH
85167: LD_INT 1
85169: NEG
85170: PUSH
85171: LD_INT 1
85173: NEG
85174: PUSH
85175: EMPTY
85176: LIST
85177: LIST
85178: PUSH
85179: LD_INT 1
85181: PUSH
85182: LD_INT 1
85184: NEG
85185: PUSH
85186: EMPTY
85187: LIST
85188: LIST
85189: PUSH
85190: LD_INT 2
85192: PUSH
85193: LD_INT 0
85195: PUSH
85196: EMPTY
85197: LIST
85198: LIST
85199: PUSH
85200: LD_INT 2
85202: PUSH
85203: LD_INT 1
85205: PUSH
85206: EMPTY
85207: LIST
85208: LIST
85209: PUSH
85210: LD_INT 1
85212: NEG
85213: PUSH
85214: LD_INT 1
85216: PUSH
85217: EMPTY
85218: LIST
85219: LIST
85220: PUSH
85221: LD_INT 2
85223: NEG
85224: PUSH
85225: LD_INT 0
85227: PUSH
85228: EMPTY
85229: LIST
85230: LIST
85231: PUSH
85232: LD_INT 2
85234: NEG
85235: PUSH
85236: LD_INT 1
85238: NEG
85239: PUSH
85240: EMPTY
85241: LIST
85242: LIST
85243: PUSH
85244: LD_INT 2
85246: PUSH
85247: LD_INT 1
85249: NEG
85250: PUSH
85251: EMPTY
85252: LIST
85253: LIST
85254: PUSH
85255: LD_INT 3
85257: PUSH
85258: LD_INT 0
85260: PUSH
85261: EMPTY
85262: LIST
85263: LIST
85264: PUSH
85265: LD_INT 3
85267: PUSH
85268: LD_INT 1
85270: PUSH
85271: EMPTY
85272: LIST
85273: LIST
85274: PUSH
85275: EMPTY
85276: LIST
85277: LIST
85278: LIST
85279: LIST
85280: LIST
85281: LIST
85282: LIST
85283: LIST
85284: LIST
85285: LIST
85286: LIST
85287: LIST
85288: LIST
85289: LIST
85290: LIST
85291: LIST
85292: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
85293: LD_ADDR_VAR 0 16
85297: PUSH
85298: LD_INT 0
85300: PUSH
85301: LD_INT 0
85303: PUSH
85304: EMPTY
85305: LIST
85306: LIST
85307: PUSH
85308: LD_INT 0
85310: PUSH
85311: LD_INT 1
85313: NEG
85314: PUSH
85315: EMPTY
85316: LIST
85317: LIST
85318: PUSH
85319: LD_INT 1
85321: PUSH
85322: LD_INT 0
85324: PUSH
85325: EMPTY
85326: LIST
85327: LIST
85328: PUSH
85329: LD_INT 1
85331: PUSH
85332: LD_INT 1
85334: PUSH
85335: EMPTY
85336: LIST
85337: LIST
85338: PUSH
85339: LD_INT 0
85341: PUSH
85342: LD_INT 1
85344: PUSH
85345: EMPTY
85346: LIST
85347: LIST
85348: PUSH
85349: LD_INT 1
85351: NEG
85352: PUSH
85353: LD_INT 0
85355: PUSH
85356: EMPTY
85357: LIST
85358: LIST
85359: PUSH
85360: LD_INT 1
85362: NEG
85363: PUSH
85364: LD_INT 1
85366: NEG
85367: PUSH
85368: EMPTY
85369: LIST
85370: LIST
85371: PUSH
85372: LD_INT 1
85374: NEG
85375: PUSH
85376: LD_INT 2
85378: NEG
85379: PUSH
85380: EMPTY
85381: LIST
85382: LIST
85383: PUSH
85384: LD_INT 2
85386: PUSH
85387: LD_INT 1
85389: PUSH
85390: EMPTY
85391: LIST
85392: LIST
85393: PUSH
85394: LD_INT 2
85396: PUSH
85397: LD_INT 2
85399: PUSH
85400: EMPTY
85401: LIST
85402: LIST
85403: PUSH
85404: LD_INT 1
85406: PUSH
85407: LD_INT 2
85409: PUSH
85410: EMPTY
85411: LIST
85412: LIST
85413: PUSH
85414: LD_INT 2
85416: NEG
85417: PUSH
85418: LD_INT 1
85420: NEG
85421: PUSH
85422: EMPTY
85423: LIST
85424: LIST
85425: PUSH
85426: LD_INT 2
85428: NEG
85429: PUSH
85430: LD_INT 2
85432: NEG
85433: PUSH
85434: EMPTY
85435: LIST
85436: LIST
85437: PUSH
85438: LD_INT 3
85440: PUSH
85441: LD_INT 2
85443: PUSH
85444: EMPTY
85445: LIST
85446: LIST
85447: PUSH
85448: LD_INT 3
85450: PUSH
85451: LD_INT 3
85453: PUSH
85454: EMPTY
85455: LIST
85456: LIST
85457: PUSH
85458: LD_INT 2
85460: PUSH
85461: LD_INT 3
85463: PUSH
85464: EMPTY
85465: LIST
85466: LIST
85467: PUSH
85468: EMPTY
85469: LIST
85470: LIST
85471: LIST
85472: LIST
85473: LIST
85474: LIST
85475: LIST
85476: LIST
85477: LIST
85478: LIST
85479: LIST
85480: LIST
85481: LIST
85482: LIST
85483: LIST
85484: LIST
85485: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85486: LD_ADDR_VAR 0 17
85490: PUSH
85491: LD_INT 0
85493: PUSH
85494: LD_INT 0
85496: PUSH
85497: EMPTY
85498: LIST
85499: LIST
85500: PUSH
85501: LD_INT 0
85503: PUSH
85504: LD_INT 1
85506: NEG
85507: PUSH
85508: EMPTY
85509: LIST
85510: LIST
85511: PUSH
85512: LD_INT 1
85514: PUSH
85515: LD_INT 0
85517: PUSH
85518: EMPTY
85519: LIST
85520: LIST
85521: PUSH
85522: LD_INT 1
85524: PUSH
85525: LD_INT 1
85527: PUSH
85528: EMPTY
85529: LIST
85530: LIST
85531: PUSH
85532: LD_INT 0
85534: PUSH
85535: LD_INT 1
85537: PUSH
85538: EMPTY
85539: LIST
85540: LIST
85541: PUSH
85542: LD_INT 1
85544: NEG
85545: PUSH
85546: LD_INT 0
85548: PUSH
85549: EMPTY
85550: LIST
85551: LIST
85552: PUSH
85553: LD_INT 1
85555: NEG
85556: PUSH
85557: LD_INT 1
85559: NEG
85560: PUSH
85561: EMPTY
85562: LIST
85563: LIST
85564: PUSH
85565: LD_INT 1
85567: NEG
85568: PUSH
85569: LD_INT 2
85571: NEG
85572: PUSH
85573: EMPTY
85574: LIST
85575: LIST
85576: PUSH
85577: LD_INT 0
85579: PUSH
85580: LD_INT 2
85582: NEG
85583: PUSH
85584: EMPTY
85585: LIST
85586: LIST
85587: PUSH
85588: LD_INT 1
85590: PUSH
85591: LD_INT 1
85593: NEG
85594: PUSH
85595: EMPTY
85596: LIST
85597: LIST
85598: PUSH
85599: LD_INT 2
85601: PUSH
85602: LD_INT 0
85604: PUSH
85605: EMPTY
85606: LIST
85607: LIST
85608: PUSH
85609: LD_INT 2
85611: PUSH
85612: LD_INT 1
85614: PUSH
85615: EMPTY
85616: LIST
85617: LIST
85618: PUSH
85619: LD_INT 2
85621: PUSH
85622: LD_INT 2
85624: PUSH
85625: EMPTY
85626: LIST
85627: LIST
85628: PUSH
85629: LD_INT 1
85631: PUSH
85632: LD_INT 2
85634: PUSH
85635: EMPTY
85636: LIST
85637: LIST
85638: PUSH
85639: LD_INT 0
85641: PUSH
85642: LD_INT 2
85644: PUSH
85645: EMPTY
85646: LIST
85647: LIST
85648: PUSH
85649: LD_INT 1
85651: NEG
85652: PUSH
85653: LD_INT 1
85655: PUSH
85656: EMPTY
85657: LIST
85658: LIST
85659: PUSH
85660: LD_INT 2
85662: NEG
85663: PUSH
85664: LD_INT 0
85666: PUSH
85667: EMPTY
85668: LIST
85669: LIST
85670: PUSH
85671: LD_INT 2
85673: NEG
85674: PUSH
85675: LD_INT 1
85677: NEG
85678: PUSH
85679: EMPTY
85680: LIST
85681: LIST
85682: PUSH
85683: LD_INT 2
85685: NEG
85686: PUSH
85687: LD_INT 2
85689: NEG
85690: PUSH
85691: EMPTY
85692: LIST
85693: LIST
85694: PUSH
85695: EMPTY
85696: LIST
85697: LIST
85698: LIST
85699: LIST
85700: LIST
85701: LIST
85702: LIST
85703: LIST
85704: LIST
85705: LIST
85706: LIST
85707: LIST
85708: LIST
85709: LIST
85710: LIST
85711: LIST
85712: LIST
85713: LIST
85714: LIST
85715: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85716: LD_ADDR_VAR 0 18
85720: PUSH
85721: LD_INT 0
85723: PUSH
85724: LD_INT 0
85726: PUSH
85727: EMPTY
85728: LIST
85729: LIST
85730: PUSH
85731: LD_INT 0
85733: PUSH
85734: LD_INT 1
85736: NEG
85737: PUSH
85738: EMPTY
85739: LIST
85740: LIST
85741: PUSH
85742: LD_INT 1
85744: PUSH
85745: LD_INT 0
85747: PUSH
85748: EMPTY
85749: LIST
85750: LIST
85751: PUSH
85752: LD_INT 1
85754: PUSH
85755: LD_INT 1
85757: PUSH
85758: EMPTY
85759: LIST
85760: LIST
85761: PUSH
85762: LD_INT 0
85764: PUSH
85765: LD_INT 1
85767: PUSH
85768: EMPTY
85769: LIST
85770: LIST
85771: PUSH
85772: LD_INT 1
85774: NEG
85775: PUSH
85776: LD_INT 0
85778: PUSH
85779: EMPTY
85780: LIST
85781: LIST
85782: PUSH
85783: LD_INT 1
85785: NEG
85786: PUSH
85787: LD_INT 1
85789: NEG
85790: PUSH
85791: EMPTY
85792: LIST
85793: LIST
85794: PUSH
85795: LD_INT 1
85797: NEG
85798: PUSH
85799: LD_INT 2
85801: NEG
85802: PUSH
85803: EMPTY
85804: LIST
85805: LIST
85806: PUSH
85807: LD_INT 0
85809: PUSH
85810: LD_INT 2
85812: NEG
85813: PUSH
85814: EMPTY
85815: LIST
85816: LIST
85817: PUSH
85818: LD_INT 1
85820: PUSH
85821: LD_INT 1
85823: NEG
85824: PUSH
85825: EMPTY
85826: LIST
85827: LIST
85828: PUSH
85829: LD_INT 2
85831: PUSH
85832: LD_INT 0
85834: PUSH
85835: EMPTY
85836: LIST
85837: LIST
85838: PUSH
85839: LD_INT 2
85841: PUSH
85842: LD_INT 1
85844: PUSH
85845: EMPTY
85846: LIST
85847: LIST
85848: PUSH
85849: LD_INT 2
85851: PUSH
85852: LD_INT 2
85854: PUSH
85855: EMPTY
85856: LIST
85857: LIST
85858: PUSH
85859: LD_INT 1
85861: PUSH
85862: LD_INT 2
85864: PUSH
85865: EMPTY
85866: LIST
85867: LIST
85868: PUSH
85869: LD_INT 0
85871: PUSH
85872: LD_INT 2
85874: PUSH
85875: EMPTY
85876: LIST
85877: LIST
85878: PUSH
85879: LD_INT 1
85881: NEG
85882: PUSH
85883: LD_INT 1
85885: PUSH
85886: EMPTY
85887: LIST
85888: LIST
85889: PUSH
85890: LD_INT 2
85892: NEG
85893: PUSH
85894: LD_INT 0
85896: PUSH
85897: EMPTY
85898: LIST
85899: LIST
85900: PUSH
85901: LD_INT 2
85903: NEG
85904: PUSH
85905: LD_INT 1
85907: NEG
85908: PUSH
85909: EMPTY
85910: LIST
85911: LIST
85912: PUSH
85913: LD_INT 2
85915: NEG
85916: PUSH
85917: LD_INT 2
85919: NEG
85920: PUSH
85921: EMPTY
85922: LIST
85923: LIST
85924: PUSH
85925: EMPTY
85926: LIST
85927: LIST
85928: LIST
85929: LIST
85930: LIST
85931: LIST
85932: LIST
85933: LIST
85934: LIST
85935: LIST
85936: LIST
85937: LIST
85938: LIST
85939: LIST
85940: LIST
85941: LIST
85942: LIST
85943: LIST
85944: LIST
85945: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85946: LD_ADDR_VAR 0 19
85950: PUSH
85951: LD_INT 0
85953: PUSH
85954: LD_INT 0
85956: PUSH
85957: EMPTY
85958: LIST
85959: LIST
85960: PUSH
85961: LD_INT 0
85963: PUSH
85964: LD_INT 1
85966: NEG
85967: PUSH
85968: EMPTY
85969: LIST
85970: LIST
85971: PUSH
85972: LD_INT 1
85974: PUSH
85975: LD_INT 0
85977: PUSH
85978: EMPTY
85979: LIST
85980: LIST
85981: PUSH
85982: LD_INT 1
85984: PUSH
85985: LD_INT 1
85987: PUSH
85988: EMPTY
85989: LIST
85990: LIST
85991: PUSH
85992: LD_INT 0
85994: PUSH
85995: LD_INT 1
85997: PUSH
85998: EMPTY
85999: LIST
86000: LIST
86001: PUSH
86002: LD_INT 1
86004: NEG
86005: PUSH
86006: LD_INT 0
86008: PUSH
86009: EMPTY
86010: LIST
86011: LIST
86012: PUSH
86013: LD_INT 1
86015: NEG
86016: PUSH
86017: LD_INT 1
86019: NEG
86020: PUSH
86021: EMPTY
86022: LIST
86023: LIST
86024: PUSH
86025: LD_INT 1
86027: NEG
86028: PUSH
86029: LD_INT 2
86031: NEG
86032: PUSH
86033: EMPTY
86034: LIST
86035: LIST
86036: PUSH
86037: LD_INT 0
86039: PUSH
86040: LD_INT 2
86042: NEG
86043: PUSH
86044: EMPTY
86045: LIST
86046: LIST
86047: PUSH
86048: LD_INT 1
86050: PUSH
86051: LD_INT 1
86053: NEG
86054: PUSH
86055: EMPTY
86056: LIST
86057: LIST
86058: PUSH
86059: LD_INT 2
86061: PUSH
86062: LD_INT 0
86064: PUSH
86065: EMPTY
86066: LIST
86067: LIST
86068: PUSH
86069: LD_INT 2
86071: PUSH
86072: LD_INT 1
86074: PUSH
86075: EMPTY
86076: LIST
86077: LIST
86078: PUSH
86079: LD_INT 2
86081: PUSH
86082: LD_INT 2
86084: PUSH
86085: EMPTY
86086: LIST
86087: LIST
86088: PUSH
86089: LD_INT 1
86091: PUSH
86092: LD_INT 2
86094: PUSH
86095: EMPTY
86096: LIST
86097: LIST
86098: PUSH
86099: LD_INT 0
86101: PUSH
86102: LD_INT 2
86104: PUSH
86105: EMPTY
86106: LIST
86107: LIST
86108: PUSH
86109: LD_INT 1
86111: NEG
86112: PUSH
86113: LD_INT 1
86115: PUSH
86116: EMPTY
86117: LIST
86118: LIST
86119: PUSH
86120: LD_INT 2
86122: NEG
86123: PUSH
86124: LD_INT 0
86126: PUSH
86127: EMPTY
86128: LIST
86129: LIST
86130: PUSH
86131: LD_INT 2
86133: NEG
86134: PUSH
86135: LD_INT 1
86137: NEG
86138: PUSH
86139: EMPTY
86140: LIST
86141: LIST
86142: PUSH
86143: LD_INT 2
86145: NEG
86146: PUSH
86147: LD_INT 2
86149: NEG
86150: PUSH
86151: EMPTY
86152: LIST
86153: LIST
86154: PUSH
86155: EMPTY
86156: LIST
86157: LIST
86158: LIST
86159: LIST
86160: LIST
86161: LIST
86162: LIST
86163: LIST
86164: LIST
86165: LIST
86166: LIST
86167: LIST
86168: LIST
86169: LIST
86170: LIST
86171: LIST
86172: LIST
86173: LIST
86174: LIST
86175: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86176: LD_ADDR_VAR 0 20
86180: PUSH
86181: LD_INT 0
86183: PUSH
86184: LD_INT 0
86186: PUSH
86187: EMPTY
86188: LIST
86189: LIST
86190: PUSH
86191: LD_INT 0
86193: PUSH
86194: LD_INT 1
86196: NEG
86197: PUSH
86198: EMPTY
86199: LIST
86200: LIST
86201: PUSH
86202: LD_INT 1
86204: PUSH
86205: LD_INT 0
86207: PUSH
86208: EMPTY
86209: LIST
86210: LIST
86211: PUSH
86212: LD_INT 1
86214: PUSH
86215: LD_INT 1
86217: PUSH
86218: EMPTY
86219: LIST
86220: LIST
86221: PUSH
86222: LD_INT 0
86224: PUSH
86225: LD_INT 1
86227: PUSH
86228: EMPTY
86229: LIST
86230: LIST
86231: PUSH
86232: LD_INT 1
86234: NEG
86235: PUSH
86236: LD_INT 0
86238: PUSH
86239: EMPTY
86240: LIST
86241: LIST
86242: PUSH
86243: LD_INT 1
86245: NEG
86246: PUSH
86247: LD_INT 1
86249: NEG
86250: PUSH
86251: EMPTY
86252: LIST
86253: LIST
86254: PUSH
86255: LD_INT 1
86257: NEG
86258: PUSH
86259: LD_INT 2
86261: NEG
86262: PUSH
86263: EMPTY
86264: LIST
86265: LIST
86266: PUSH
86267: LD_INT 0
86269: PUSH
86270: LD_INT 2
86272: NEG
86273: PUSH
86274: EMPTY
86275: LIST
86276: LIST
86277: PUSH
86278: LD_INT 1
86280: PUSH
86281: LD_INT 1
86283: NEG
86284: PUSH
86285: EMPTY
86286: LIST
86287: LIST
86288: PUSH
86289: LD_INT 2
86291: PUSH
86292: LD_INT 0
86294: PUSH
86295: EMPTY
86296: LIST
86297: LIST
86298: PUSH
86299: LD_INT 2
86301: PUSH
86302: LD_INT 1
86304: PUSH
86305: EMPTY
86306: LIST
86307: LIST
86308: PUSH
86309: LD_INT 2
86311: PUSH
86312: LD_INT 2
86314: PUSH
86315: EMPTY
86316: LIST
86317: LIST
86318: PUSH
86319: LD_INT 1
86321: PUSH
86322: LD_INT 2
86324: PUSH
86325: EMPTY
86326: LIST
86327: LIST
86328: PUSH
86329: LD_INT 0
86331: PUSH
86332: LD_INT 2
86334: PUSH
86335: EMPTY
86336: LIST
86337: LIST
86338: PUSH
86339: LD_INT 1
86341: NEG
86342: PUSH
86343: LD_INT 1
86345: PUSH
86346: EMPTY
86347: LIST
86348: LIST
86349: PUSH
86350: LD_INT 2
86352: NEG
86353: PUSH
86354: LD_INT 0
86356: PUSH
86357: EMPTY
86358: LIST
86359: LIST
86360: PUSH
86361: LD_INT 2
86363: NEG
86364: PUSH
86365: LD_INT 1
86367: NEG
86368: PUSH
86369: EMPTY
86370: LIST
86371: LIST
86372: PUSH
86373: LD_INT 2
86375: NEG
86376: PUSH
86377: LD_INT 2
86379: NEG
86380: PUSH
86381: EMPTY
86382: LIST
86383: LIST
86384: PUSH
86385: EMPTY
86386: LIST
86387: LIST
86388: LIST
86389: LIST
86390: LIST
86391: LIST
86392: LIST
86393: LIST
86394: LIST
86395: LIST
86396: LIST
86397: LIST
86398: LIST
86399: LIST
86400: LIST
86401: LIST
86402: LIST
86403: LIST
86404: LIST
86405: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86406: LD_ADDR_VAR 0 21
86410: PUSH
86411: LD_INT 0
86413: PUSH
86414: LD_INT 0
86416: PUSH
86417: EMPTY
86418: LIST
86419: LIST
86420: PUSH
86421: LD_INT 0
86423: PUSH
86424: LD_INT 1
86426: NEG
86427: PUSH
86428: EMPTY
86429: LIST
86430: LIST
86431: PUSH
86432: LD_INT 1
86434: PUSH
86435: LD_INT 0
86437: PUSH
86438: EMPTY
86439: LIST
86440: LIST
86441: PUSH
86442: LD_INT 1
86444: PUSH
86445: LD_INT 1
86447: PUSH
86448: EMPTY
86449: LIST
86450: LIST
86451: PUSH
86452: LD_INT 0
86454: PUSH
86455: LD_INT 1
86457: PUSH
86458: EMPTY
86459: LIST
86460: LIST
86461: PUSH
86462: LD_INT 1
86464: NEG
86465: PUSH
86466: LD_INT 0
86468: PUSH
86469: EMPTY
86470: LIST
86471: LIST
86472: PUSH
86473: LD_INT 1
86475: NEG
86476: PUSH
86477: LD_INT 1
86479: NEG
86480: PUSH
86481: EMPTY
86482: LIST
86483: LIST
86484: PUSH
86485: LD_INT 1
86487: NEG
86488: PUSH
86489: LD_INT 2
86491: NEG
86492: PUSH
86493: EMPTY
86494: LIST
86495: LIST
86496: PUSH
86497: LD_INT 0
86499: PUSH
86500: LD_INT 2
86502: NEG
86503: PUSH
86504: EMPTY
86505: LIST
86506: LIST
86507: PUSH
86508: LD_INT 1
86510: PUSH
86511: LD_INT 1
86513: NEG
86514: PUSH
86515: EMPTY
86516: LIST
86517: LIST
86518: PUSH
86519: LD_INT 2
86521: PUSH
86522: LD_INT 0
86524: PUSH
86525: EMPTY
86526: LIST
86527: LIST
86528: PUSH
86529: LD_INT 2
86531: PUSH
86532: LD_INT 1
86534: PUSH
86535: EMPTY
86536: LIST
86537: LIST
86538: PUSH
86539: LD_INT 2
86541: PUSH
86542: LD_INT 2
86544: PUSH
86545: EMPTY
86546: LIST
86547: LIST
86548: PUSH
86549: LD_INT 1
86551: PUSH
86552: LD_INT 2
86554: PUSH
86555: EMPTY
86556: LIST
86557: LIST
86558: PUSH
86559: LD_INT 0
86561: PUSH
86562: LD_INT 2
86564: PUSH
86565: EMPTY
86566: LIST
86567: LIST
86568: PUSH
86569: LD_INT 1
86571: NEG
86572: PUSH
86573: LD_INT 1
86575: PUSH
86576: EMPTY
86577: LIST
86578: LIST
86579: PUSH
86580: LD_INT 2
86582: NEG
86583: PUSH
86584: LD_INT 0
86586: PUSH
86587: EMPTY
86588: LIST
86589: LIST
86590: PUSH
86591: LD_INT 2
86593: NEG
86594: PUSH
86595: LD_INT 1
86597: NEG
86598: PUSH
86599: EMPTY
86600: LIST
86601: LIST
86602: PUSH
86603: LD_INT 2
86605: NEG
86606: PUSH
86607: LD_INT 2
86609: NEG
86610: PUSH
86611: EMPTY
86612: LIST
86613: LIST
86614: PUSH
86615: EMPTY
86616: LIST
86617: LIST
86618: LIST
86619: LIST
86620: LIST
86621: LIST
86622: LIST
86623: LIST
86624: LIST
86625: LIST
86626: LIST
86627: LIST
86628: LIST
86629: LIST
86630: LIST
86631: LIST
86632: LIST
86633: LIST
86634: LIST
86635: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86636: LD_ADDR_VAR 0 22
86640: PUSH
86641: LD_INT 0
86643: PUSH
86644: LD_INT 0
86646: PUSH
86647: EMPTY
86648: LIST
86649: LIST
86650: PUSH
86651: LD_INT 0
86653: PUSH
86654: LD_INT 1
86656: NEG
86657: PUSH
86658: EMPTY
86659: LIST
86660: LIST
86661: PUSH
86662: LD_INT 1
86664: PUSH
86665: LD_INT 0
86667: PUSH
86668: EMPTY
86669: LIST
86670: LIST
86671: PUSH
86672: LD_INT 1
86674: PUSH
86675: LD_INT 1
86677: PUSH
86678: EMPTY
86679: LIST
86680: LIST
86681: PUSH
86682: LD_INT 0
86684: PUSH
86685: LD_INT 1
86687: PUSH
86688: EMPTY
86689: LIST
86690: LIST
86691: PUSH
86692: LD_INT 1
86694: NEG
86695: PUSH
86696: LD_INT 0
86698: PUSH
86699: EMPTY
86700: LIST
86701: LIST
86702: PUSH
86703: LD_INT 1
86705: NEG
86706: PUSH
86707: LD_INT 1
86709: NEG
86710: PUSH
86711: EMPTY
86712: LIST
86713: LIST
86714: PUSH
86715: LD_INT 1
86717: NEG
86718: PUSH
86719: LD_INT 2
86721: NEG
86722: PUSH
86723: EMPTY
86724: LIST
86725: LIST
86726: PUSH
86727: LD_INT 0
86729: PUSH
86730: LD_INT 2
86732: NEG
86733: PUSH
86734: EMPTY
86735: LIST
86736: LIST
86737: PUSH
86738: LD_INT 1
86740: PUSH
86741: LD_INT 1
86743: NEG
86744: PUSH
86745: EMPTY
86746: LIST
86747: LIST
86748: PUSH
86749: LD_INT 2
86751: PUSH
86752: LD_INT 0
86754: PUSH
86755: EMPTY
86756: LIST
86757: LIST
86758: PUSH
86759: LD_INT 2
86761: PUSH
86762: LD_INT 1
86764: PUSH
86765: EMPTY
86766: LIST
86767: LIST
86768: PUSH
86769: LD_INT 2
86771: PUSH
86772: LD_INT 2
86774: PUSH
86775: EMPTY
86776: LIST
86777: LIST
86778: PUSH
86779: LD_INT 1
86781: PUSH
86782: LD_INT 2
86784: PUSH
86785: EMPTY
86786: LIST
86787: LIST
86788: PUSH
86789: LD_INT 0
86791: PUSH
86792: LD_INT 2
86794: PUSH
86795: EMPTY
86796: LIST
86797: LIST
86798: PUSH
86799: LD_INT 1
86801: NEG
86802: PUSH
86803: LD_INT 1
86805: PUSH
86806: EMPTY
86807: LIST
86808: LIST
86809: PUSH
86810: LD_INT 2
86812: NEG
86813: PUSH
86814: LD_INT 0
86816: PUSH
86817: EMPTY
86818: LIST
86819: LIST
86820: PUSH
86821: LD_INT 2
86823: NEG
86824: PUSH
86825: LD_INT 1
86827: NEG
86828: PUSH
86829: EMPTY
86830: LIST
86831: LIST
86832: PUSH
86833: LD_INT 2
86835: NEG
86836: PUSH
86837: LD_INT 2
86839: NEG
86840: PUSH
86841: EMPTY
86842: LIST
86843: LIST
86844: PUSH
86845: EMPTY
86846: LIST
86847: LIST
86848: LIST
86849: LIST
86850: LIST
86851: LIST
86852: LIST
86853: LIST
86854: LIST
86855: LIST
86856: LIST
86857: LIST
86858: LIST
86859: LIST
86860: LIST
86861: LIST
86862: LIST
86863: LIST
86864: LIST
86865: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
86866: LD_ADDR_VAR 0 23
86870: PUSH
86871: LD_INT 0
86873: PUSH
86874: LD_INT 0
86876: PUSH
86877: EMPTY
86878: LIST
86879: LIST
86880: PUSH
86881: LD_INT 0
86883: PUSH
86884: LD_INT 1
86886: NEG
86887: PUSH
86888: EMPTY
86889: LIST
86890: LIST
86891: PUSH
86892: LD_INT 1
86894: PUSH
86895: LD_INT 0
86897: PUSH
86898: EMPTY
86899: LIST
86900: LIST
86901: PUSH
86902: LD_INT 1
86904: PUSH
86905: LD_INT 1
86907: PUSH
86908: EMPTY
86909: LIST
86910: LIST
86911: PUSH
86912: LD_INT 0
86914: PUSH
86915: LD_INT 1
86917: PUSH
86918: EMPTY
86919: LIST
86920: LIST
86921: PUSH
86922: LD_INT 1
86924: NEG
86925: PUSH
86926: LD_INT 0
86928: PUSH
86929: EMPTY
86930: LIST
86931: LIST
86932: PUSH
86933: LD_INT 1
86935: NEG
86936: PUSH
86937: LD_INT 1
86939: NEG
86940: PUSH
86941: EMPTY
86942: LIST
86943: LIST
86944: PUSH
86945: LD_INT 1
86947: NEG
86948: PUSH
86949: LD_INT 2
86951: NEG
86952: PUSH
86953: EMPTY
86954: LIST
86955: LIST
86956: PUSH
86957: LD_INT 0
86959: PUSH
86960: LD_INT 2
86962: NEG
86963: PUSH
86964: EMPTY
86965: LIST
86966: LIST
86967: PUSH
86968: LD_INT 1
86970: PUSH
86971: LD_INT 1
86973: NEG
86974: PUSH
86975: EMPTY
86976: LIST
86977: LIST
86978: PUSH
86979: LD_INT 2
86981: PUSH
86982: LD_INT 0
86984: PUSH
86985: EMPTY
86986: LIST
86987: LIST
86988: PUSH
86989: LD_INT 2
86991: PUSH
86992: LD_INT 1
86994: PUSH
86995: EMPTY
86996: LIST
86997: LIST
86998: PUSH
86999: LD_INT 2
87001: PUSH
87002: LD_INT 2
87004: PUSH
87005: EMPTY
87006: LIST
87007: LIST
87008: PUSH
87009: LD_INT 1
87011: PUSH
87012: LD_INT 2
87014: PUSH
87015: EMPTY
87016: LIST
87017: LIST
87018: PUSH
87019: LD_INT 0
87021: PUSH
87022: LD_INT 2
87024: PUSH
87025: EMPTY
87026: LIST
87027: LIST
87028: PUSH
87029: LD_INT 1
87031: NEG
87032: PUSH
87033: LD_INT 1
87035: PUSH
87036: EMPTY
87037: LIST
87038: LIST
87039: PUSH
87040: LD_INT 2
87042: NEG
87043: PUSH
87044: LD_INT 0
87046: PUSH
87047: EMPTY
87048: LIST
87049: LIST
87050: PUSH
87051: LD_INT 2
87053: NEG
87054: PUSH
87055: LD_INT 1
87057: NEG
87058: PUSH
87059: EMPTY
87060: LIST
87061: LIST
87062: PUSH
87063: LD_INT 2
87065: NEG
87066: PUSH
87067: LD_INT 2
87069: NEG
87070: PUSH
87071: EMPTY
87072: LIST
87073: LIST
87074: PUSH
87075: LD_INT 2
87077: NEG
87078: PUSH
87079: LD_INT 3
87081: NEG
87082: PUSH
87083: EMPTY
87084: LIST
87085: LIST
87086: PUSH
87087: LD_INT 1
87089: NEG
87090: PUSH
87091: LD_INT 3
87093: NEG
87094: PUSH
87095: EMPTY
87096: LIST
87097: LIST
87098: PUSH
87099: LD_INT 1
87101: PUSH
87102: LD_INT 2
87104: NEG
87105: PUSH
87106: EMPTY
87107: LIST
87108: LIST
87109: PUSH
87110: LD_INT 2
87112: PUSH
87113: LD_INT 1
87115: NEG
87116: PUSH
87117: EMPTY
87118: LIST
87119: LIST
87120: PUSH
87121: EMPTY
87122: LIST
87123: LIST
87124: LIST
87125: LIST
87126: LIST
87127: LIST
87128: LIST
87129: LIST
87130: LIST
87131: LIST
87132: LIST
87133: LIST
87134: LIST
87135: LIST
87136: LIST
87137: LIST
87138: LIST
87139: LIST
87140: LIST
87141: LIST
87142: LIST
87143: LIST
87144: LIST
87145: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
87146: LD_ADDR_VAR 0 24
87150: PUSH
87151: LD_INT 0
87153: PUSH
87154: LD_INT 0
87156: PUSH
87157: EMPTY
87158: LIST
87159: LIST
87160: PUSH
87161: LD_INT 0
87163: PUSH
87164: LD_INT 1
87166: NEG
87167: PUSH
87168: EMPTY
87169: LIST
87170: LIST
87171: PUSH
87172: LD_INT 1
87174: PUSH
87175: LD_INT 0
87177: PUSH
87178: EMPTY
87179: LIST
87180: LIST
87181: PUSH
87182: LD_INT 1
87184: PUSH
87185: LD_INT 1
87187: PUSH
87188: EMPTY
87189: LIST
87190: LIST
87191: PUSH
87192: LD_INT 0
87194: PUSH
87195: LD_INT 1
87197: PUSH
87198: EMPTY
87199: LIST
87200: LIST
87201: PUSH
87202: LD_INT 1
87204: NEG
87205: PUSH
87206: LD_INT 0
87208: PUSH
87209: EMPTY
87210: LIST
87211: LIST
87212: PUSH
87213: LD_INT 1
87215: NEG
87216: PUSH
87217: LD_INT 1
87219: NEG
87220: PUSH
87221: EMPTY
87222: LIST
87223: LIST
87224: PUSH
87225: LD_INT 1
87227: NEG
87228: PUSH
87229: LD_INT 2
87231: NEG
87232: PUSH
87233: EMPTY
87234: LIST
87235: LIST
87236: PUSH
87237: LD_INT 0
87239: PUSH
87240: LD_INT 2
87242: NEG
87243: PUSH
87244: EMPTY
87245: LIST
87246: LIST
87247: PUSH
87248: LD_INT 1
87250: PUSH
87251: LD_INT 1
87253: NEG
87254: PUSH
87255: EMPTY
87256: LIST
87257: LIST
87258: PUSH
87259: LD_INT 2
87261: PUSH
87262: LD_INT 0
87264: PUSH
87265: EMPTY
87266: LIST
87267: LIST
87268: PUSH
87269: LD_INT 2
87271: PUSH
87272: LD_INT 1
87274: PUSH
87275: EMPTY
87276: LIST
87277: LIST
87278: PUSH
87279: LD_INT 2
87281: PUSH
87282: LD_INT 2
87284: PUSH
87285: EMPTY
87286: LIST
87287: LIST
87288: PUSH
87289: LD_INT 1
87291: PUSH
87292: LD_INT 2
87294: PUSH
87295: EMPTY
87296: LIST
87297: LIST
87298: PUSH
87299: LD_INT 0
87301: PUSH
87302: LD_INT 2
87304: PUSH
87305: EMPTY
87306: LIST
87307: LIST
87308: PUSH
87309: LD_INT 1
87311: NEG
87312: PUSH
87313: LD_INT 1
87315: PUSH
87316: EMPTY
87317: LIST
87318: LIST
87319: PUSH
87320: LD_INT 2
87322: NEG
87323: PUSH
87324: LD_INT 0
87326: PUSH
87327: EMPTY
87328: LIST
87329: LIST
87330: PUSH
87331: LD_INT 2
87333: NEG
87334: PUSH
87335: LD_INT 1
87337: NEG
87338: PUSH
87339: EMPTY
87340: LIST
87341: LIST
87342: PUSH
87343: LD_INT 2
87345: NEG
87346: PUSH
87347: LD_INT 2
87349: NEG
87350: PUSH
87351: EMPTY
87352: LIST
87353: LIST
87354: PUSH
87355: LD_INT 1
87357: PUSH
87358: LD_INT 2
87360: NEG
87361: PUSH
87362: EMPTY
87363: LIST
87364: LIST
87365: PUSH
87366: LD_INT 2
87368: PUSH
87369: LD_INT 1
87371: NEG
87372: PUSH
87373: EMPTY
87374: LIST
87375: LIST
87376: PUSH
87377: LD_INT 3
87379: PUSH
87380: LD_INT 1
87382: PUSH
87383: EMPTY
87384: LIST
87385: LIST
87386: PUSH
87387: LD_INT 3
87389: PUSH
87390: LD_INT 2
87392: PUSH
87393: EMPTY
87394: LIST
87395: LIST
87396: PUSH
87397: EMPTY
87398: LIST
87399: LIST
87400: LIST
87401: LIST
87402: LIST
87403: LIST
87404: LIST
87405: LIST
87406: LIST
87407: LIST
87408: LIST
87409: LIST
87410: LIST
87411: LIST
87412: LIST
87413: LIST
87414: LIST
87415: LIST
87416: LIST
87417: LIST
87418: LIST
87419: LIST
87420: LIST
87421: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
87422: LD_ADDR_VAR 0 25
87426: PUSH
87427: LD_INT 0
87429: PUSH
87430: LD_INT 0
87432: PUSH
87433: EMPTY
87434: LIST
87435: LIST
87436: PUSH
87437: LD_INT 0
87439: PUSH
87440: LD_INT 1
87442: NEG
87443: PUSH
87444: EMPTY
87445: LIST
87446: LIST
87447: PUSH
87448: LD_INT 1
87450: PUSH
87451: LD_INT 0
87453: PUSH
87454: EMPTY
87455: LIST
87456: LIST
87457: PUSH
87458: LD_INT 1
87460: PUSH
87461: LD_INT 1
87463: PUSH
87464: EMPTY
87465: LIST
87466: LIST
87467: PUSH
87468: LD_INT 0
87470: PUSH
87471: LD_INT 1
87473: PUSH
87474: EMPTY
87475: LIST
87476: LIST
87477: PUSH
87478: LD_INT 1
87480: NEG
87481: PUSH
87482: LD_INT 0
87484: PUSH
87485: EMPTY
87486: LIST
87487: LIST
87488: PUSH
87489: LD_INT 1
87491: NEG
87492: PUSH
87493: LD_INT 1
87495: NEG
87496: PUSH
87497: EMPTY
87498: LIST
87499: LIST
87500: PUSH
87501: LD_INT 1
87503: NEG
87504: PUSH
87505: LD_INT 2
87507: NEG
87508: PUSH
87509: EMPTY
87510: LIST
87511: LIST
87512: PUSH
87513: LD_INT 0
87515: PUSH
87516: LD_INT 2
87518: NEG
87519: PUSH
87520: EMPTY
87521: LIST
87522: LIST
87523: PUSH
87524: LD_INT 1
87526: PUSH
87527: LD_INT 1
87529: NEG
87530: PUSH
87531: EMPTY
87532: LIST
87533: LIST
87534: PUSH
87535: LD_INT 2
87537: PUSH
87538: LD_INT 0
87540: PUSH
87541: EMPTY
87542: LIST
87543: LIST
87544: PUSH
87545: LD_INT 2
87547: PUSH
87548: LD_INT 1
87550: PUSH
87551: EMPTY
87552: LIST
87553: LIST
87554: PUSH
87555: LD_INT 2
87557: PUSH
87558: LD_INT 2
87560: PUSH
87561: EMPTY
87562: LIST
87563: LIST
87564: PUSH
87565: LD_INT 1
87567: PUSH
87568: LD_INT 2
87570: PUSH
87571: EMPTY
87572: LIST
87573: LIST
87574: PUSH
87575: LD_INT 0
87577: PUSH
87578: LD_INT 2
87580: PUSH
87581: EMPTY
87582: LIST
87583: LIST
87584: PUSH
87585: LD_INT 1
87587: NEG
87588: PUSH
87589: LD_INT 1
87591: PUSH
87592: EMPTY
87593: LIST
87594: LIST
87595: PUSH
87596: LD_INT 2
87598: NEG
87599: PUSH
87600: LD_INT 0
87602: PUSH
87603: EMPTY
87604: LIST
87605: LIST
87606: PUSH
87607: LD_INT 2
87609: NEG
87610: PUSH
87611: LD_INT 1
87613: NEG
87614: PUSH
87615: EMPTY
87616: LIST
87617: LIST
87618: PUSH
87619: LD_INT 2
87621: NEG
87622: PUSH
87623: LD_INT 2
87625: NEG
87626: PUSH
87627: EMPTY
87628: LIST
87629: LIST
87630: PUSH
87631: LD_INT 3
87633: PUSH
87634: LD_INT 1
87636: PUSH
87637: EMPTY
87638: LIST
87639: LIST
87640: PUSH
87641: LD_INT 3
87643: PUSH
87644: LD_INT 2
87646: PUSH
87647: EMPTY
87648: LIST
87649: LIST
87650: PUSH
87651: LD_INT 2
87653: PUSH
87654: LD_INT 3
87656: PUSH
87657: EMPTY
87658: LIST
87659: LIST
87660: PUSH
87661: LD_INT 1
87663: PUSH
87664: LD_INT 3
87666: PUSH
87667: EMPTY
87668: LIST
87669: LIST
87670: PUSH
87671: EMPTY
87672: LIST
87673: LIST
87674: LIST
87675: LIST
87676: LIST
87677: LIST
87678: LIST
87679: LIST
87680: LIST
87681: LIST
87682: LIST
87683: LIST
87684: LIST
87685: LIST
87686: LIST
87687: LIST
87688: LIST
87689: LIST
87690: LIST
87691: LIST
87692: LIST
87693: LIST
87694: LIST
87695: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
87696: LD_ADDR_VAR 0 26
87700: PUSH
87701: LD_INT 0
87703: PUSH
87704: LD_INT 0
87706: PUSH
87707: EMPTY
87708: LIST
87709: LIST
87710: PUSH
87711: LD_INT 0
87713: PUSH
87714: LD_INT 1
87716: NEG
87717: PUSH
87718: EMPTY
87719: LIST
87720: LIST
87721: PUSH
87722: LD_INT 1
87724: PUSH
87725: LD_INT 0
87727: PUSH
87728: EMPTY
87729: LIST
87730: LIST
87731: PUSH
87732: LD_INT 1
87734: PUSH
87735: LD_INT 1
87737: PUSH
87738: EMPTY
87739: LIST
87740: LIST
87741: PUSH
87742: LD_INT 0
87744: PUSH
87745: LD_INT 1
87747: PUSH
87748: EMPTY
87749: LIST
87750: LIST
87751: PUSH
87752: LD_INT 1
87754: NEG
87755: PUSH
87756: LD_INT 0
87758: PUSH
87759: EMPTY
87760: LIST
87761: LIST
87762: PUSH
87763: LD_INT 1
87765: NEG
87766: PUSH
87767: LD_INT 1
87769: NEG
87770: PUSH
87771: EMPTY
87772: LIST
87773: LIST
87774: PUSH
87775: LD_INT 1
87777: NEG
87778: PUSH
87779: LD_INT 2
87781: NEG
87782: PUSH
87783: EMPTY
87784: LIST
87785: LIST
87786: PUSH
87787: LD_INT 0
87789: PUSH
87790: LD_INT 2
87792: NEG
87793: PUSH
87794: EMPTY
87795: LIST
87796: LIST
87797: PUSH
87798: LD_INT 1
87800: PUSH
87801: LD_INT 1
87803: NEG
87804: PUSH
87805: EMPTY
87806: LIST
87807: LIST
87808: PUSH
87809: LD_INT 2
87811: PUSH
87812: LD_INT 0
87814: PUSH
87815: EMPTY
87816: LIST
87817: LIST
87818: PUSH
87819: LD_INT 2
87821: PUSH
87822: LD_INT 1
87824: PUSH
87825: EMPTY
87826: LIST
87827: LIST
87828: PUSH
87829: LD_INT 2
87831: PUSH
87832: LD_INT 2
87834: PUSH
87835: EMPTY
87836: LIST
87837: LIST
87838: PUSH
87839: LD_INT 1
87841: PUSH
87842: LD_INT 2
87844: PUSH
87845: EMPTY
87846: LIST
87847: LIST
87848: PUSH
87849: LD_INT 0
87851: PUSH
87852: LD_INT 2
87854: PUSH
87855: EMPTY
87856: LIST
87857: LIST
87858: PUSH
87859: LD_INT 1
87861: NEG
87862: PUSH
87863: LD_INT 1
87865: PUSH
87866: EMPTY
87867: LIST
87868: LIST
87869: PUSH
87870: LD_INT 2
87872: NEG
87873: PUSH
87874: LD_INT 0
87876: PUSH
87877: EMPTY
87878: LIST
87879: LIST
87880: PUSH
87881: LD_INT 2
87883: NEG
87884: PUSH
87885: LD_INT 1
87887: NEG
87888: PUSH
87889: EMPTY
87890: LIST
87891: LIST
87892: PUSH
87893: LD_INT 2
87895: NEG
87896: PUSH
87897: LD_INT 2
87899: NEG
87900: PUSH
87901: EMPTY
87902: LIST
87903: LIST
87904: PUSH
87905: LD_INT 2
87907: PUSH
87908: LD_INT 3
87910: PUSH
87911: EMPTY
87912: LIST
87913: LIST
87914: PUSH
87915: LD_INT 1
87917: PUSH
87918: LD_INT 3
87920: PUSH
87921: EMPTY
87922: LIST
87923: LIST
87924: PUSH
87925: LD_INT 1
87927: NEG
87928: PUSH
87929: LD_INT 2
87931: PUSH
87932: EMPTY
87933: LIST
87934: LIST
87935: PUSH
87936: LD_INT 2
87938: NEG
87939: PUSH
87940: LD_INT 1
87942: PUSH
87943: EMPTY
87944: LIST
87945: LIST
87946: PUSH
87947: EMPTY
87948: LIST
87949: LIST
87950: LIST
87951: LIST
87952: LIST
87953: LIST
87954: LIST
87955: LIST
87956: LIST
87957: LIST
87958: LIST
87959: LIST
87960: LIST
87961: LIST
87962: LIST
87963: LIST
87964: LIST
87965: LIST
87966: LIST
87967: LIST
87968: LIST
87969: LIST
87970: LIST
87971: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
87972: LD_ADDR_VAR 0 27
87976: PUSH
87977: LD_INT 0
87979: PUSH
87980: LD_INT 0
87982: PUSH
87983: EMPTY
87984: LIST
87985: LIST
87986: PUSH
87987: LD_INT 0
87989: PUSH
87990: LD_INT 1
87992: NEG
87993: PUSH
87994: EMPTY
87995: LIST
87996: LIST
87997: PUSH
87998: LD_INT 1
88000: PUSH
88001: LD_INT 0
88003: PUSH
88004: EMPTY
88005: LIST
88006: LIST
88007: PUSH
88008: LD_INT 1
88010: PUSH
88011: LD_INT 1
88013: PUSH
88014: EMPTY
88015: LIST
88016: LIST
88017: PUSH
88018: LD_INT 0
88020: PUSH
88021: LD_INT 1
88023: PUSH
88024: EMPTY
88025: LIST
88026: LIST
88027: PUSH
88028: LD_INT 1
88030: NEG
88031: PUSH
88032: LD_INT 0
88034: PUSH
88035: EMPTY
88036: LIST
88037: LIST
88038: PUSH
88039: LD_INT 1
88041: NEG
88042: PUSH
88043: LD_INT 1
88045: NEG
88046: PUSH
88047: EMPTY
88048: LIST
88049: LIST
88050: PUSH
88051: LD_INT 1
88053: NEG
88054: PUSH
88055: LD_INT 2
88057: NEG
88058: PUSH
88059: EMPTY
88060: LIST
88061: LIST
88062: PUSH
88063: LD_INT 0
88065: PUSH
88066: LD_INT 2
88068: NEG
88069: PUSH
88070: EMPTY
88071: LIST
88072: LIST
88073: PUSH
88074: LD_INT 1
88076: PUSH
88077: LD_INT 1
88079: NEG
88080: PUSH
88081: EMPTY
88082: LIST
88083: LIST
88084: PUSH
88085: LD_INT 2
88087: PUSH
88088: LD_INT 0
88090: PUSH
88091: EMPTY
88092: LIST
88093: LIST
88094: PUSH
88095: LD_INT 2
88097: PUSH
88098: LD_INT 1
88100: PUSH
88101: EMPTY
88102: LIST
88103: LIST
88104: PUSH
88105: LD_INT 2
88107: PUSH
88108: LD_INT 2
88110: PUSH
88111: EMPTY
88112: LIST
88113: LIST
88114: PUSH
88115: LD_INT 1
88117: PUSH
88118: LD_INT 2
88120: PUSH
88121: EMPTY
88122: LIST
88123: LIST
88124: PUSH
88125: LD_INT 0
88127: PUSH
88128: LD_INT 2
88130: PUSH
88131: EMPTY
88132: LIST
88133: LIST
88134: PUSH
88135: LD_INT 1
88137: NEG
88138: PUSH
88139: LD_INT 1
88141: PUSH
88142: EMPTY
88143: LIST
88144: LIST
88145: PUSH
88146: LD_INT 2
88148: NEG
88149: PUSH
88150: LD_INT 0
88152: PUSH
88153: EMPTY
88154: LIST
88155: LIST
88156: PUSH
88157: LD_INT 2
88159: NEG
88160: PUSH
88161: LD_INT 1
88163: NEG
88164: PUSH
88165: EMPTY
88166: LIST
88167: LIST
88168: PUSH
88169: LD_INT 2
88171: NEG
88172: PUSH
88173: LD_INT 2
88175: NEG
88176: PUSH
88177: EMPTY
88178: LIST
88179: LIST
88180: PUSH
88181: LD_INT 1
88183: NEG
88184: PUSH
88185: LD_INT 2
88187: PUSH
88188: EMPTY
88189: LIST
88190: LIST
88191: PUSH
88192: LD_INT 2
88194: NEG
88195: PUSH
88196: LD_INT 1
88198: PUSH
88199: EMPTY
88200: LIST
88201: LIST
88202: PUSH
88203: LD_INT 3
88205: NEG
88206: PUSH
88207: LD_INT 1
88209: NEG
88210: PUSH
88211: EMPTY
88212: LIST
88213: LIST
88214: PUSH
88215: LD_INT 3
88217: NEG
88218: PUSH
88219: LD_INT 2
88221: NEG
88222: PUSH
88223: EMPTY
88224: LIST
88225: LIST
88226: PUSH
88227: EMPTY
88228: LIST
88229: LIST
88230: LIST
88231: LIST
88232: LIST
88233: LIST
88234: LIST
88235: LIST
88236: LIST
88237: LIST
88238: LIST
88239: LIST
88240: LIST
88241: LIST
88242: LIST
88243: LIST
88244: LIST
88245: LIST
88246: LIST
88247: LIST
88248: LIST
88249: LIST
88250: LIST
88251: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
88252: LD_ADDR_VAR 0 28
88256: PUSH
88257: LD_INT 0
88259: PUSH
88260: LD_INT 0
88262: PUSH
88263: EMPTY
88264: LIST
88265: LIST
88266: PUSH
88267: LD_INT 0
88269: PUSH
88270: LD_INT 1
88272: NEG
88273: PUSH
88274: EMPTY
88275: LIST
88276: LIST
88277: PUSH
88278: LD_INT 1
88280: PUSH
88281: LD_INT 0
88283: PUSH
88284: EMPTY
88285: LIST
88286: LIST
88287: PUSH
88288: LD_INT 1
88290: PUSH
88291: LD_INT 1
88293: PUSH
88294: EMPTY
88295: LIST
88296: LIST
88297: PUSH
88298: LD_INT 0
88300: PUSH
88301: LD_INT 1
88303: PUSH
88304: EMPTY
88305: LIST
88306: LIST
88307: PUSH
88308: LD_INT 1
88310: NEG
88311: PUSH
88312: LD_INT 0
88314: PUSH
88315: EMPTY
88316: LIST
88317: LIST
88318: PUSH
88319: LD_INT 1
88321: NEG
88322: PUSH
88323: LD_INT 1
88325: NEG
88326: PUSH
88327: EMPTY
88328: LIST
88329: LIST
88330: PUSH
88331: LD_INT 1
88333: NEG
88334: PUSH
88335: LD_INT 2
88337: NEG
88338: PUSH
88339: EMPTY
88340: LIST
88341: LIST
88342: PUSH
88343: LD_INT 0
88345: PUSH
88346: LD_INT 2
88348: NEG
88349: PUSH
88350: EMPTY
88351: LIST
88352: LIST
88353: PUSH
88354: LD_INT 1
88356: PUSH
88357: LD_INT 1
88359: NEG
88360: PUSH
88361: EMPTY
88362: LIST
88363: LIST
88364: PUSH
88365: LD_INT 2
88367: PUSH
88368: LD_INT 0
88370: PUSH
88371: EMPTY
88372: LIST
88373: LIST
88374: PUSH
88375: LD_INT 2
88377: PUSH
88378: LD_INT 1
88380: PUSH
88381: EMPTY
88382: LIST
88383: LIST
88384: PUSH
88385: LD_INT 2
88387: PUSH
88388: LD_INT 2
88390: PUSH
88391: EMPTY
88392: LIST
88393: LIST
88394: PUSH
88395: LD_INT 1
88397: PUSH
88398: LD_INT 2
88400: PUSH
88401: EMPTY
88402: LIST
88403: LIST
88404: PUSH
88405: LD_INT 0
88407: PUSH
88408: LD_INT 2
88410: PUSH
88411: EMPTY
88412: LIST
88413: LIST
88414: PUSH
88415: LD_INT 1
88417: NEG
88418: PUSH
88419: LD_INT 1
88421: PUSH
88422: EMPTY
88423: LIST
88424: LIST
88425: PUSH
88426: LD_INT 2
88428: NEG
88429: PUSH
88430: LD_INT 0
88432: PUSH
88433: EMPTY
88434: LIST
88435: LIST
88436: PUSH
88437: LD_INT 2
88439: NEG
88440: PUSH
88441: LD_INT 1
88443: NEG
88444: PUSH
88445: EMPTY
88446: LIST
88447: LIST
88448: PUSH
88449: LD_INT 2
88451: NEG
88452: PUSH
88453: LD_INT 2
88455: NEG
88456: PUSH
88457: EMPTY
88458: LIST
88459: LIST
88460: PUSH
88461: LD_INT 2
88463: NEG
88464: PUSH
88465: LD_INT 3
88467: NEG
88468: PUSH
88469: EMPTY
88470: LIST
88471: LIST
88472: PUSH
88473: LD_INT 1
88475: NEG
88476: PUSH
88477: LD_INT 3
88479: NEG
88480: PUSH
88481: EMPTY
88482: LIST
88483: LIST
88484: PUSH
88485: LD_INT 3
88487: NEG
88488: PUSH
88489: LD_INT 1
88491: NEG
88492: PUSH
88493: EMPTY
88494: LIST
88495: LIST
88496: PUSH
88497: LD_INT 3
88499: NEG
88500: PUSH
88501: LD_INT 2
88503: NEG
88504: PUSH
88505: EMPTY
88506: LIST
88507: LIST
88508: PUSH
88509: EMPTY
88510: LIST
88511: LIST
88512: LIST
88513: LIST
88514: LIST
88515: LIST
88516: LIST
88517: LIST
88518: LIST
88519: LIST
88520: LIST
88521: LIST
88522: LIST
88523: LIST
88524: LIST
88525: LIST
88526: LIST
88527: LIST
88528: LIST
88529: LIST
88530: LIST
88531: LIST
88532: LIST
88533: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
88534: LD_ADDR_VAR 0 29
88538: PUSH
88539: LD_INT 0
88541: PUSH
88542: LD_INT 0
88544: PUSH
88545: EMPTY
88546: LIST
88547: LIST
88548: PUSH
88549: LD_INT 0
88551: PUSH
88552: LD_INT 1
88554: NEG
88555: PUSH
88556: EMPTY
88557: LIST
88558: LIST
88559: PUSH
88560: LD_INT 1
88562: PUSH
88563: LD_INT 0
88565: PUSH
88566: EMPTY
88567: LIST
88568: LIST
88569: PUSH
88570: LD_INT 1
88572: PUSH
88573: LD_INT 1
88575: PUSH
88576: EMPTY
88577: LIST
88578: LIST
88579: PUSH
88580: LD_INT 0
88582: PUSH
88583: LD_INT 1
88585: PUSH
88586: EMPTY
88587: LIST
88588: LIST
88589: PUSH
88590: LD_INT 1
88592: NEG
88593: PUSH
88594: LD_INT 0
88596: PUSH
88597: EMPTY
88598: LIST
88599: LIST
88600: PUSH
88601: LD_INT 1
88603: NEG
88604: PUSH
88605: LD_INT 1
88607: NEG
88608: PUSH
88609: EMPTY
88610: LIST
88611: LIST
88612: PUSH
88613: LD_INT 1
88615: NEG
88616: PUSH
88617: LD_INT 2
88619: NEG
88620: PUSH
88621: EMPTY
88622: LIST
88623: LIST
88624: PUSH
88625: LD_INT 0
88627: PUSH
88628: LD_INT 2
88630: NEG
88631: PUSH
88632: EMPTY
88633: LIST
88634: LIST
88635: PUSH
88636: LD_INT 1
88638: PUSH
88639: LD_INT 1
88641: NEG
88642: PUSH
88643: EMPTY
88644: LIST
88645: LIST
88646: PUSH
88647: LD_INT 2
88649: PUSH
88650: LD_INT 0
88652: PUSH
88653: EMPTY
88654: LIST
88655: LIST
88656: PUSH
88657: LD_INT 2
88659: PUSH
88660: LD_INT 1
88662: PUSH
88663: EMPTY
88664: LIST
88665: LIST
88666: PUSH
88667: LD_INT 1
88669: PUSH
88670: LD_INT 2
88672: PUSH
88673: EMPTY
88674: LIST
88675: LIST
88676: PUSH
88677: LD_INT 0
88679: PUSH
88680: LD_INT 2
88682: PUSH
88683: EMPTY
88684: LIST
88685: LIST
88686: PUSH
88687: LD_INT 1
88689: NEG
88690: PUSH
88691: LD_INT 1
88693: PUSH
88694: EMPTY
88695: LIST
88696: LIST
88697: PUSH
88698: LD_INT 2
88700: NEG
88701: PUSH
88702: LD_INT 1
88704: NEG
88705: PUSH
88706: EMPTY
88707: LIST
88708: LIST
88709: PUSH
88710: LD_INT 2
88712: NEG
88713: PUSH
88714: LD_INT 2
88716: NEG
88717: PUSH
88718: EMPTY
88719: LIST
88720: LIST
88721: PUSH
88722: LD_INT 2
88724: NEG
88725: PUSH
88726: LD_INT 3
88728: NEG
88729: PUSH
88730: EMPTY
88731: LIST
88732: LIST
88733: PUSH
88734: LD_INT 2
88736: PUSH
88737: LD_INT 1
88739: NEG
88740: PUSH
88741: EMPTY
88742: LIST
88743: LIST
88744: PUSH
88745: LD_INT 3
88747: PUSH
88748: LD_INT 1
88750: PUSH
88751: EMPTY
88752: LIST
88753: LIST
88754: PUSH
88755: LD_INT 1
88757: PUSH
88758: LD_INT 3
88760: PUSH
88761: EMPTY
88762: LIST
88763: LIST
88764: PUSH
88765: LD_INT 1
88767: NEG
88768: PUSH
88769: LD_INT 2
88771: PUSH
88772: EMPTY
88773: LIST
88774: LIST
88775: PUSH
88776: LD_INT 3
88778: NEG
88779: PUSH
88780: LD_INT 2
88782: NEG
88783: PUSH
88784: EMPTY
88785: LIST
88786: LIST
88787: PUSH
88788: EMPTY
88789: LIST
88790: LIST
88791: LIST
88792: LIST
88793: LIST
88794: LIST
88795: LIST
88796: LIST
88797: LIST
88798: LIST
88799: LIST
88800: LIST
88801: LIST
88802: LIST
88803: LIST
88804: LIST
88805: LIST
88806: LIST
88807: LIST
88808: LIST
88809: LIST
88810: LIST
88811: LIST
88812: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
88813: LD_ADDR_VAR 0 30
88817: PUSH
88818: LD_INT 0
88820: PUSH
88821: LD_INT 0
88823: PUSH
88824: EMPTY
88825: LIST
88826: LIST
88827: PUSH
88828: LD_INT 0
88830: PUSH
88831: LD_INT 1
88833: NEG
88834: PUSH
88835: EMPTY
88836: LIST
88837: LIST
88838: PUSH
88839: LD_INT 1
88841: PUSH
88842: LD_INT 0
88844: PUSH
88845: EMPTY
88846: LIST
88847: LIST
88848: PUSH
88849: LD_INT 1
88851: PUSH
88852: LD_INT 1
88854: PUSH
88855: EMPTY
88856: LIST
88857: LIST
88858: PUSH
88859: LD_INT 0
88861: PUSH
88862: LD_INT 1
88864: PUSH
88865: EMPTY
88866: LIST
88867: LIST
88868: PUSH
88869: LD_INT 1
88871: NEG
88872: PUSH
88873: LD_INT 0
88875: PUSH
88876: EMPTY
88877: LIST
88878: LIST
88879: PUSH
88880: LD_INT 1
88882: NEG
88883: PUSH
88884: LD_INT 1
88886: NEG
88887: PUSH
88888: EMPTY
88889: LIST
88890: LIST
88891: PUSH
88892: LD_INT 1
88894: NEG
88895: PUSH
88896: LD_INT 2
88898: NEG
88899: PUSH
88900: EMPTY
88901: LIST
88902: LIST
88903: PUSH
88904: LD_INT 0
88906: PUSH
88907: LD_INT 2
88909: NEG
88910: PUSH
88911: EMPTY
88912: LIST
88913: LIST
88914: PUSH
88915: LD_INT 1
88917: PUSH
88918: LD_INT 1
88920: NEG
88921: PUSH
88922: EMPTY
88923: LIST
88924: LIST
88925: PUSH
88926: LD_INT 2
88928: PUSH
88929: LD_INT 0
88931: PUSH
88932: EMPTY
88933: LIST
88934: LIST
88935: PUSH
88936: LD_INT 2
88938: PUSH
88939: LD_INT 1
88941: PUSH
88942: EMPTY
88943: LIST
88944: LIST
88945: PUSH
88946: LD_INT 2
88948: PUSH
88949: LD_INT 2
88951: PUSH
88952: EMPTY
88953: LIST
88954: LIST
88955: PUSH
88956: LD_INT 1
88958: PUSH
88959: LD_INT 2
88961: PUSH
88962: EMPTY
88963: LIST
88964: LIST
88965: PUSH
88966: LD_INT 1
88968: NEG
88969: PUSH
88970: LD_INT 1
88972: PUSH
88973: EMPTY
88974: LIST
88975: LIST
88976: PUSH
88977: LD_INT 2
88979: NEG
88980: PUSH
88981: LD_INT 0
88983: PUSH
88984: EMPTY
88985: LIST
88986: LIST
88987: PUSH
88988: LD_INT 2
88990: NEG
88991: PUSH
88992: LD_INT 1
88994: NEG
88995: PUSH
88996: EMPTY
88997: LIST
88998: LIST
88999: PUSH
89000: LD_INT 1
89002: NEG
89003: PUSH
89004: LD_INT 3
89006: NEG
89007: PUSH
89008: EMPTY
89009: LIST
89010: LIST
89011: PUSH
89012: LD_INT 1
89014: PUSH
89015: LD_INT 2
89017: NEG
89018: PUSH
89019: EMPTY
89020: LIST
89021: LIST
89022: PUSH
89023: LD_INT 3
89025: PUSH
89026: LD_INT 2
89028: PUSH
89029: EMPTY
89030: LIST
89031: LIST
89032: PUSH
89033: LD_INT 2
89035: PUSH
89036: LD_INT 3
89038: PUSH
89039: EMPTY
89040: LIST
89041: LIST
89042: PUSH
89043: LD_INT 2
89045: NEG
89046: PUSH
89047: LD_INT 1
89049: PUSH
89050: EMPTY
89051: LIST
89052: LIST
89053: PUSH
89054: LD_INT 3
89056: NEG
89057: PUSH
89058: LD_INT 1
89060: NEG
89061: PUSH
89062: EMPTY
89063: LIST
89064: LIST
89065: PUSH
89066: EMPTY
89067: LIST
89068: LIST
89069: LIST
89070: LIST
89071: LIST
89072: LIST
89073: LIST
89074: LIST
89075: LIST
89076: LIST
89077: LIST
89078: LIST
89079: LIST
89080: LIST
89081: LIST
89082: LIST
89083: LIST
89084: LIST
89085: LIST
89086: LIST
89087: LIST
89088: LIST
89089: LIST
89090: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
89091: LD_ADDR_VAR 0 31
89095: PUSH
89096: LD_INT 0
89098: PUSH
89099: LD_INT 0
89101: PUSH
89102: EMPTY
89103: LIST
89104: LIST
89105: PUSH
89106: LD_INT 0
89108: PUSH
89109: LD_INT 1
89111: NEG
89112: PUSH
89113: EMPTY
89114: LIST
89115: LIST
89116: PUSH
89117: LD_INT 1
89119: PUSH
89120: LD_INT 0
89122: PUSH
89123: EMPTY
89124: LIST
89125: LIST
89126: PUSH
89127: LD_INT 1
89129: PUSH
89130: LD_INT 1
89132: PUSH
89133: EMPTY
89134: LIST
89135: LIST
89136: PUSH
89137: LD_INT 0
89139: PUSH
89140: LD_INT 1
89142: PUSH
89143: EMPTY
89144: LIST
89145: LIST
89146: PUSH
89147: LD_INT 1
89149: NEG
89150: PUSH
89151: LD_INT 0
89153: PUSH
89154: EMPTY
89155: LIST
89156: LIST
89157: PUSH
89158: LD_INT 1
89160: NEG
89161: PUSH
89162: LD_INT 1
89164: NEG
89165: PUSH
89166: EMPTY
89167: LIST
89168: LIST
89169: PUSH
89170: LD_INT 1
89172: NEG
89173: PUSH
89174: LD_INT 2
89176: NEG
89177: PUSH
89178: EMPTY
89179: LIST
89180: LIST
89181: PUSH
89182: LD_INT 1
89184: PUSH
89185: LD_INT 1
89187: NEG
89188: PUSH
89189: EMPTY
89190: LIST
89191: LIST
89192: PUSH
89193: LD_INT 2
89195: PUSH
89196: LD_INT 0
89198: PUSH
89199: EMPTY
89200: LIST
89201: LIST
89202: PUSH
89203: LD_INT 2
89205: PUSH
89206: LD_INT 1
89208: PUSH
89209: EMPTY
89210: LIST
89211: LIST
89212: PUSH
89213: LD_INT 2
89215: PUSH
89216: LD_INT 2
89218: PUSH
89219: EMPTY
89220: LIST
89221: LIST
89222: PUSH
89223: LD_INT 1
89225: PUSH
89226: LD_INT 2
89228: PUSH
89229: EMPTY
89230: LIST
89231: LIST
89232: PUSH
89233: LD_INT 0
89235: PUSH
89236: LD_INT 2
89238: PUSH
89239: EMPTY
89240: LIST
89241: LIST
89242: PUSH
89243: LD_INT 1
89245: NEG
89246: PUSH
89247: LD_INT 1
89249: PUSH
89250: EMPTY
89251: LIST
89252: LIST
89253: PUSH
89254: LD_INT 2
89256: NEG
89257: PUSH
89258: LD_INT 1
89260: NEG
89261: PUSH
89262: EMPTY
89263: LIST
89264: LIST
89265: PUSH
89266: LD_INT 2
89268: NEG
89269: PUSH
89270: LD_INT 2
89272: NEG
89273: PUSH
89274: EMPTY
89275: LIST
89276: LIST
89277: PUSH
89278: LD_INT 2
89280: NEG
89281: PUSH
89282: LD_INT 3
89284: NEG
89285: PUSH
89286: EMPTY
89287: LIST
89288: LIST
89289: PUSH
89290: LD_INT 2
89292: PUSH
89293: LD_INT 1
89295: NEG
89296: PUSH
89297: EMPTY
89298: LIST
89299: LIST
89300: PUSH
89301: LD_INT 3
89303: PUSH
89304: LD_INT 1
89306: PUSH
89307: EMPTY
89308: LIST
89309: LIST
89310: PUSH
89311: LD_INT 1
89313: PUSH
89314: LD_INT 3
89316: PUSH
89317: EMPTY
89318: LIST
89319: LIST
89320: PUSH
89321: LD_INT 1
89323: NEG
89324: PUSH
89325: LD_INT 2
89327: PUSH
89328: EMPTY
89329: LIST
89330: LIST
89331: PUSH
89332: LD_INT 3
89334: NEG
89335: PUSH
89336: LD_INT 2
89338: NEG
89339: PUSH
89340: EMPTY
89341: LIST
89342: LIST
89343: PUSH
89344: EMPTY
89345: LIST
89346: LIST
89347: LIST
89348: LIST
89349: LIST
89350: LIST
89351: LIST
89352: LIST
89353: LIST
89354: LIST
89355: LIST
89356: LIST
89357: LIST
89358: LIST
89359: LIST
89360: LIST
89361: LIST
89362: LIST
89363: LIST
89364: LIST
89365: LIST
89366: LIST
89367: LIST
89368: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
89369: LD_ADDR_VAR 0 32
89373: PUSH
89374: LD_INT 0
89376: PUSH
89377: LD_INT 0
89379: PUSH
89380: EMPTY
89381: LIST
89382: LIST
89383: PUSH
89384: LD_INT 0
89386: PUSH
89387: LD_INT 1
89389: NEG
89390: PUSH
89391: EMPTY
89392: LIST
89393: LIST
89394: PUSH
89395: LD_INT 1
89397: PUSH
89398: LD_INT 0
89400: PUSH
89401: EMPTY
89402: LIST
89403: LIST
89404: PUSH
89405: LD_INT 1
89407: PUSH
89408: LD_INT 1
89410: PUSH
89411: EMPTY
89412: LIST
89413: LIST
89414: PUSH
89415: LD_INT 0
89417: PUSH
89418: LD_INT 1
89420: PUSH
89421: EMPTY
89422: LIST
89423: LIST
89424: PUSH
89425: LD_INT 1
89427: NEG
89428: PUSH
89429: LD_INT 0
89431: PUSH
89432: EMPTY
89433: LIST
89434: LIST
89435: PUSH
89436: LD_INT 1
89438: NEG
89439: PUSH
89440: LD_INT 1
89442: NEG
89443: PUSH
89444: EMPTY
89445: LIST
89446: LIST
89447: PUSH
89448: LD_INT 1
89450: NEG
89451: PUSH
89452: LD_INT 2
89454: NEG
89455: PUSH
89456: EMPTY
89457: LIST
89458: LIST
89459: PUSH
89460: LD_INT 0
89462: PUSH
89463: LD_INT 2
89465: NEG
89466: PUSH
89467: EMPTY
89468: LIST
89469: LIST
89470: PUSH
89471: LD_INT 1
89473: PUSH
89474: LD_INT 1
89476: NEG
89477: PUSH
89478: EMPTY
89479: LIST
89480: LIST
89481: PUSH
89482: LD_INT 2
89484: PUSH
89485: LD_INT 1
89487: PUSH
89488: EMPTY
89489: LIST
89490: LIST
89491: PUSH
89492: LD_INT 2
89494: PUSH
89495: LD_INT 2
89497: PUSH
89498: EMPTY
89499: LIST
89500: LIST
89501: PUSH
89502: LD_INT 1
89504: PUSH
89505: LD_INT 2
89507: PUSH
89508: EMPTY
89509: LIST
89510: LIST
89511: PUSH
89512: LD_INT 0
89514: PUSH
89515: LD_INT 2
89517: PUSH
89518: EMPTY
89519: LIST
89520: LIST
89521: PUSH
89522: LD_INT 1
89524: NEG
89525: PUSH
89526: LD_INT 1
89528: PUSH
89529: EMPTY
89530: LIST
89531: LIST
89532: PUSH
89533: LD_INT 2
89535: NEG
89536: PUSH
89537: LD_INT 0
89539: PUSH
89540: EMPTY
89541: LIST
89542: LIST
89543: PUSH
89544: LD_INT 2
89546: NEG
89547: PUSH
89548: LD_INT 1
89550: NEG
89551: PUSH
89552: EMPTY
89553: LIST
89554: LIST
89555: PUSH
89556: LD_INT 1
89558: NEG
89559: PUSH
89560: LD_INT 3
89562: NEG
89563: PUSH
89564: EMPTY
89565: LIST
89566: LIST
89567: PUSH
89568: LD_INT 1
89570: PUSH
89571: LD_INT 2
89573: NEG
89574: PUSH
89575: EMPTY
89576: LIST
89577: LIST
89578: PUSH
89579: LD_INT 3
89581: PUSH
89582: LD_INT 2
89584: PUSH
89585: EMPTY
89586: LIST
89587: LIST
89588: PUSH
89589: LD_INT 2
89591: PUSH
89592: LD_INT 3
89594: PUSH
89595: EMPTY
89596: LIST
89597: LIST
89598: PUSH
89599: LD_INT 2
89601: NEG
89602: PUSH
89603: LD_INT 1
89605: PUSH
89606: EMPTY
89607: LIST
89608: LIST
89609: PUSH
89610: LD_INT 3
89612: NEG
89613: PUSH
89614: LD_INT 1
89616: NEG
89617: PUSH
89618: EMPTY
89619: LIST
89620: LIST
89621: PUSH
89622: EMPTY
89623: LIST
89624: LIST
89625: LIST
89626: LIST
89627: LIST
89628: LIST
89629: LIST
89630: LIST
89631: LIST
89632: LIST
89633: LIST
89634: LIST
89635: LIST
89636: LIST
89637: LIST
89638: LIST
89639: LIST
89640: LIST
89641: LIST
89642: LIST
89643: LIST
89644: LIST
89645: LIST
89646: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
89647: LD_ADDR_VAR 0 33
89651: PUSH
89652: LD_INT 0
89654: PUSH
89655: LD_INT 0
89657: PUSH
89658: EMPTY
89659: LIST
89660: LIST
89661: PUSH
89662: LD_INT 0
89664: PUSH
89665: LD_INT 1
89667: NEG
89668: PUSH
89669: EMPTY
89670: LIST
89671: LIST
89672: PUSH
89673: LD_INT 1
89675: PUSH
89676: LD_INT 0
89678: PUSH
89679: EMPTY
89680: LIST
89681: LIST
89682: PUSH
89683: LD_INT 1
89685: PUSH
89686: LD_INT 1
89688: PUSH
89689: EMPTY
89690: LIST
89691: LIST
89692: PUSH
89693: LD_INT 0
89695: PUSH
89696: LD_INT 1
89698: PUSH
89699: EMPTY
89700: LIST
89701: LIST
89702: PUSH
89703: LD_INT 1
89705: NEG
89706: PUSH
89707: LD_INT 0
89709: PUSH
89710: EMPTY
89711: LIST
89712: LIST
89713: PUSH
89714: LD_INT 1
89716: NEG
89717: PUSH
89718: LD_INT 1
89720: NEG
89721: PUSH
89722: EMPTY
89723: LIST
89724: LIST
89725: PUSH
89726: LD_INT 1
89728: NEG
89729: PUSH
89730: LD_INT 2
89732: NEG
89733: PUSH
89734: EMPTY
89735: LIST
89736: LIST
89737: PUSH
89738: LD_INT 1
89740: PUSH
89741: LD_INT 1
89743: NEG
89744: PUSH
89745: EMPTY
89746: LIST
89747: LIST
89748: PUSH
89749: LD_INT 2
89751: PUSH
89752: LD_INT 0
89754: PUSH
89755: EMPTY
89756: LIST
89757: LIST
89758: PUSH
89759: LD_INT 2
89761: PUSH
89762: LD_INT 1
89764: PUSH
89765: EMPTY
89766: LIST
89767: LIST
89768: PUSH
89769: LD_INT 1
89771: PUSH
89772: LD_INT 2
89774: PUSH
89775: EMPTY
89776: LIST
89777: LIST
89778: PUSH
89779: LD_INT 0
89781: PUSH
89782: LD_INT 2
89784: PUSH
89785: EMPTY
89786: LIST
89787: LIST
89788: PUSH
89789: LD_INT 1
89791: NEG
89792: PUSH
89793: LD_INT 1
89795: PUSH
89796: EMPTY
89797: LIST
89798: LIST
89799: PUSH
89800: LD_INT 2
89802: NEG
89803: PUSH
89804: LD_INT 0
89806: PUSH
89807: EMPTY
89808: LIST
89809: LIST
89810: PUSH
89811: LD_INT 2
89813: NEG
89814: PUSH
89815: LD_INT 1
89817: NEG
89818: PUSH
89819: EMPTY
89820: LIST
89821: LIST
89822: PUSH
89823: LD_INT 2
89825: NEG
89826: PUSH
89827: LD_INT 2
89829: NEG
89830: PUSH
89831: EMPTY
89832: LIST
89833: LIST
89834: PUSH
89835: LD_INT 2
89837: NEG
89838: PUSH
89839: LD_INT 3
89841: NEG
89842: PUSH
89843: EMPTY
89844: LIST
89845: LIST
89846: PUSH
89847: LD_INT 2
89849: PUSH
89850: LD_INT 1
89852: NEG
89853: PUSH
89854: EMPTY
89855: LIST
89856: LIST
89857: PUSH
89858: LD_INT 3
89860: PUSH
89861: LD_INT 1
89863: PUSH
89864: EMPTY
89865: LIST
89866: LIST
89867: PUSH
89868: LD_INT 1
89870: PUSH
89871: LD_INT 3
89873: PUSH
89874: EMPTY
89875: LIST
89876: LIST
89877: PUSH
89878: LD_INT 1
89880: NEG
89881: PUSH
89882: LD_INT 2
89884: PUSH
89885: EMPTY
89886: LIST
89887: LIST
89888: PUSH
89889: LD_INT 3
89891: NEG
89892: PUSH
89893: LD_INT 2
89895: NEG
89896: PUSH
89897: EMPTY
89898: LIST
89899: LIST
89900: PUSH
89901: EMPTY
89902: LIST
89903: LIST
89904: LIST
89905: LIST
89906: LIST
89907: LIST
89908: LIST
89909: LIST
89910: LIST
89911: LIST
89912: LIST
89913: LIST
89914: LIST
89915: LIST
89916: LIST
89917: LIST
89918: LIST
89919: LIST
89920: LIST
89921: LIST
89922: LIST
89923: LIST
89924: LIST
89925: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
89926: LD_ADDR_VAR 0 34
89930: PUSH
89931: LD_INT 0
89933: PUSH
89934: LD_INT 0
89936: PUSH
89937: EMPTY
89938: LIST
89939: LIST
89940: PUSH
89941: LD_INT 0
89943: PUSH
89944: LD_INT 1
89946: NEG
89947: PUSH
89948: EMPTY
89949: LIST
89950: LIST
89951: PUSH
89952: LD_INT 1
89954: PUSH
89955: LD_INT 0
89957: PUSH
89958: EMPTY
89959: LIST
89960: LIST
89961: PUSH
89962: LD_INT 1
89964: PUSH
89965: LD_INT 1
89967: PUSH
89968: EMPTY
89969: LIST
89970: LIST
89971: PUSH
89972: LD_INT 0
89974: PUSH
89975: LD_INT 1
89977: PUSH
89978: EMPTY
89979: LIST
89980: LIST
89981: PUSH
89982: LD_INT 1
89984: NEG
89985: PUSH
89986: LD_INT 0
89988: PUSH
89989: EMPTY
89990: LIST
89991: LIST
89992: PUSH
89993: LD_INT 1
89995: NEG
89996: PUSH
89997: LD_INT 1
89999: NEG
90000: PUSH
90001: EMPTY
90002: LIST
90003: LIST
90004: PUSH
90005: LD_INT 1
90007: NEG
90008: PUSH
90009: LD_INT 2
90011: NEG
90012: PUSH
90013: EMPTY
90014: LIST
90015: LIST
90016: PUSH
90017: LD_INT 0
90019: PUSH
90020: LD_INT 2
90022: NEG
90023: PUSH
90024: EMPTY
90025: LIST
90026: LIST
90027: PUSH
90028: LD_INT 1
90030: PUSH
90031: LD_INT 1
90033: NEG
90034: PUSH
90035: EMPTY
90036: LIST
90037: LIST
90038: PUSH
90039: LD_INT 2
90041: PUSH
90042: LD_INT 1
90044: PUSH
90045: EMPTY
90046: LIST
90047: LIST
90048: PUSH
90049: LD_INT 2
90051: PUSH
90052: LD_INT 2
90054: PUSH
90055: EMPTY
90056: LIST
90057: LIST
90058: PUSH
90059: LD_INT 1
90061: PUSH
90062: LD_INT 2
90064: PUSH
90065: EMPTY
90066: LIST
90067: LIST
90068: PUSH
90069: LD_INT 1
90071: NEG
90072: PUSH
90073: LD_INT 1
90075: PUSH
90076: EMPTY
90077: LIST
90078: LIST
90079: PUSH
90080: LD_INT 2
90082: NEG
90083: PUSH
90084: LD_INT 0
90086: PUSH
90087: EMPTY
90088: LIST
90089: LIST
90090: PUSH
90091: LD_INT 2
90093: NEG
90094: PUSH
90095: LD_INT 1
90097: NEG
90098: PUSH
90099: EMPTY
90100: LIST
90101: LIST
90102: PUSH
90103: LD_INT 2
90105: NEG
90106: PUSH
90107: LD_INT 2
90109: NEG
90110: PUSH
90111: EMPTY
90112: LIST
90113: LIST
90114: PUSH
90115: LD_INT 1
90117: NEG
90118: PUSH
90119: LD_INT 3
90121: NEG
90122: PUSH
90123: EMPTY
90124: LIST
90125: LIST
90126: PUSH
90127: LD_INT 1
90129: PUSH
90130: LD_INT 2
90132: NEG
90133: PUSH
90134: EMPTY
90135: LIST
90136: LIST
90137: PUSH
90138: LD_INT 3
90140: PUSH
90141: LD_INT 2
90143: PUSH
90144: EMPTY
90145: LIST
90146: LIST
90147: PUSH
90148: LD_INT 2
90150: PUSH
90151: LD_INT 3
90153: PUSH
90154: EMPTY
90155: LIST
90156: LIST
90157: PUSH
90158: LD_INT 2
90160: NEG
90161: PUSH
90162: LD_INT 1
90164: PUSH
90165: EMPTY
90166: LIST
90167: LIST
90168: PUSH
90169: LD_INT 3
90171: NEG
90172: PUSH
90173: LD_INT 1
90175: NEG
90176: PUSH
90177: EMPTY
90178: LIST
90179: LIST
90180: PUSH
90181: EMPTY
90182: LIST
90183: LIST
90184: LIST
90185: LIST
90186: LIST
90187: LIST
90188: LIST
90189: LIST
90190: LIST
90191: LIST
90192: LIST
90193: LIST
90194: LIST
90195: LIST
90196: LIST
90197: LIST
90198: LIST
90199: LIST
90200: LIST
90201: LIST
90202: LIST
90203: LIST
90204: LIST
90205: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
90206: LD_ADDR_VAR 0 35
90210: PUSH
90211: LD_INT 0
90213: PUSH
90214: LD_INT 0
90216: PUSH
90217: EMPTY
90218: LIST
90219: LIST
90220: PUSH
90221: LD_INT 0
90223: PUSH
90224: LD_INT 1
90226: NEG
90227: PUSH
90228: EMPTY
90229: LIST
90230: LIST
90231: PUSH
90232: LD_INT 1
90234: PUSH
90235: LD_INT 0
90237: PUSH
90238: EMPTY
90239: LIST
90240: LIST
90241: PUSH
90242: LD_INT 1
90244: PUSH
90245: LD_INT 1
90247: PUSH
90248: EMPTY
90249: LIST
90250: LIST
90251: PUSH
90252: LD_INT 0
90254: PUSH
90255: LD_INT 1
90257: PUSH
90258: EMPTY
90259: LIST
90260: LIST
90261: PUSH
90262: LD_INT 1
90264: NEG
90265: PUSH
90266: LD_INT 0
90268: PUSH
90269: EMPTY
90270: LIST
90271: LIST
90272: PUSH
90273: LD_INT 1
90275: NEG
90276: PUSH
90277: LD_INT 1
90279: NEG
90280: PUSH
90281: EMPTY
90282: LIST
90283: LIST
90284: PUSH
90285: LD_INT 2
90287: PUSH
90288: LD_INT 1
90290: PUSH
90291: EMPTY
90292: LIST
90293: LIST
90294: PUSH
90295: LD_INT 2
90297: NEG
90298: PUSH
90299: LD_INT 1
90301: NEG
90302: PUSH
90303: EMPTY
90304: LIST
90305: LIST
90306: PUSH
90307: EMPTY
90308: LIST
90309: LIST
90310: LIST
90311: LIST
90312: LIST
90313: LIST
90314: LIST
90315: LIST
90316: LIST
90317: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
90318: LD_ADDR_VAR 0 36
90322: PUSH
90323: LD_INT 0
90325: PUSH
90326: LD_INT 0
90328: PUSH
90329: EMPTY
90330: LIST
90331: LIST
90332: PUSH
90333: LD_INT 0
90335: PUSH
90336: LD_INT 1
90338: NEG
90339: PUSH
90340: EMPTY
90341: LIST
90342: LIST
90343: PUSH
90344: LD_INT 1
90346: PUSH
90347: LD_INT 0
90349: PUSH
90350: EMPTY
90351: LIST
90352: LIST
90353: PUSH
90354: LD_INT 1
90356: PUSH
90357: LD_INT 1
90359: PUSH
90360: EMPTY
90361: LIST
90362: LIST
90363: PUSH
90364: LD_INT 0
90366: PUSH
90367: LD_INT 1
90369: PUSH
90370: EMPTY
90371: LIST
90372: LIST
90373: PUSH
90374: LD_INT 1
90376: NEG
90377: PUSH
90378: LD_INT 0
90380: PUSH
90381: EMPTY
90382: LIST
90383: LIST
90384: PUSH
90385: LD_INT 1
90387: NEG
90388: PUSH
90389: LD_INT 1
90391: NEG
90392: PUSH
90393: EMPTY
90394: LIST
90395: LIST
90396: PUSH
90397: LD_INT 1
90399: NEG
90400: PUSH
90401: LD_INT 2
90403: NEG
90404: PUSH
90405: EMPTY
90406: LIST
90407: LIST
90408: PUSH
90409: LD_INT 1
90411: PUSH
90412: LD_INT 2
90414: PUSH
90415: EMPTY
90416: LIST
90417: LIST
90418: PUSH
90419: EMPTY
90420: LIST
90421: LIST
90422: LIST
90423: LIST
90424: LIST
90425: LIST
90426: LIST
90427: LIST
90428: LIST
90429: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
90430: LD_ADDR_VAR 0 37
90434: PUSH
90435: LD_INT 0
90437: PUSH
90438: LD_INT 0
90440: PUSH
90441: EMPTY
90442: LIST
90443: LIST
90444: PUSH
90445: LD_INT 0
90447: PUSH
90448: LD_INT 1
90450: NEG
90451: PUSH
90452: EMPTY
90453: LIST
90454: LIST
90455: PUSH
90456: LD_INT 1
90458: PUSH
90459: LD_INT 0
90461: PUSH
90462: EMPTY
90463: LIST
90464: LIST
90465: PUSH
90466: LD_INT 1
90468: PUSH
90469: LD_INT 1
90471: PUSH
90472: EMPTY
90473: LIST
90474: LIST
90475: PUSH
90476: LD_INT 0
90478: PUSH
90479: LD_INT 1
90481: PUSH
90482: EMPTY
90483: LIST
90484: LIST
90485: PUSH
90486: LD_INT 1
90488: NEG
90489: PUSH
90490: LD_INT 0
90492: PUSH
90493: EMPTY
90494: LIST
90495: LIST
90496: PUSH
90497: LD_INT 1
90499: NEG
90500: PUSH
90501: LD_INT 1
90503: NEG
90504: PUSH
90505: EMPTY
90506: LIST
90507: LIST
90508: PUSH
90509: LD_INT 1
90511: PUSH
90512: LD_INT 1
90514: NEG
90515: PUSH
90516: EMPTY
90517: LIST
90518: LIST
90519: PUSH
90520: LD_INT 1
90522: NEG
90523: PUSH
90524: LD_INT 1
90526: PUSH
90527: EMPTY
90528: LIST
90529: LIST
90530: PUSH
90531: EMPTY
90532: LIST
90533: LIST
90534: LIST
90535: LIST
90536: LIST
90537: LIST
90538: LIST
90539: LIST
90540: LIST
90541: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
90542: LD_ADDR_VAR 0 38
90546: PUSH
90547: LD_INT 0
90549: PUSH
90550: LD_INT 0
90552: PUSH
90553: EMPTY
90554: LIST
90555: LIST
90556: PUSH
90557: LD_INT 0
90559: PUSH
90560: LD_INT 1
90562: NEG
90563: PUSH
90564: EMPTY
90565: LIST
90566: LIST
90567: PUSH
90568: LD_INT 1
90570: PUSH
90571: LD_INT 0
90573: PUSH
90574: EMPTY
90575: LIST
90576: LIST
90577: PUSH
90578: LD_INT 1
90580: PUSH
90581: LD_INT 1
90583: PUSH
90584: EMPTY
90585: LIST
90586: LIST
90587: PUSH
90588: LD_INT 0
90590: PUSH
90591: LD_INT 1
90593: PUSH
90594: EMPTY
90595: LIST
90596: LIST
90597: PUSH
90598: LD_INT 1
90600: NEG
90601: PUSH
90602: LD_INT 0
90604: PUSH
90605: EMPTY
90606: LIST
90607: LIST
90608: PUSH
90609: LD_INT 1
90611: NEG
90612: PUSH
90613: LD_INT 1
90615: NEG
90616: PUSH
90617: EMPTY
90618: LIST
90619: LIST
90620: PUSH
90621: LD_INT 2
90623: PUSH
90624: LD_INT 1
90626: PUSH
90627: EMPTY
90628: LIST
90629: LIST
90630: PUSH
90631: LD_INT 2
90633: NEG
90634: PUSH
90635: LD_INT 1
90637: NEG
90638: PUSH
90639: EMPTY
90640: LIST
90641: LIST
90642: PUSH
90643: EMPTY
90644: LIST
90645: LIST
90646: LIST
90647: LIST
90648: LIST
90649: LIST
90650: LIST
90651: LIST
90652: LIST
90653: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
90654: LD_ADDR_VAR 0 39
90658: PUSH
90659: LD_INT 0
90661: PUSH
90662: LD_INT 0
90664: PUSH
90665: EMPTY
90666: LIST
90667: LIST
90668: PUSH
90669: LD_INT 0
90671: PUSH
90672: LD_INT 1
90674: NEG
90675: PUSH
90676: EMPTY
90677: LIST
90678: LIST
90679: PUSH
90680: LD_INT 1
90682: PUSH
90683: LD_INT 0
90685: PUSH
90686: EMPTY
90687: LIST
90688: LIST
90689: PUSH
90690: LD_INT 1
90692: PUSH
90693: LD_INT 1
90695: PUSH
90696: EMPTY
90697: LIST
90698: LIST
90699: PUSH
90700: LD_INT 0
90702: PUSH
90703: LD_INT 1
90705: PUSH
90706: EMPTY
90707: LIST
90708: LIST
90709: PUSH
90710: LD_INT 1
90712: NEG
90713: PUSH
90714: LD_INT 0
90716: PUSH
90717: EMPTY
90718: LIST
90719: LIST
90720: PUSH
90721: LD_INT 1
90723: NEG
90724: PUSH
90725: LD_INT 1
90727: NEG
90728: PUSH
90729: EMPTY
90730: LIST
90731: LIST
90732: PUSH
90733: LD_INT 1
90735: NEG
90736: PUSH
90737: LD_INT 2
90739: NEG
90740: PUSH
90741: EMPTY
90742: LIST
90743: LIST
90744: PUSH
90745: LD_INT 1
90747: PUSH
90748: LD_INT 2
90750: PUSH
90751: EMPTY
90752: LIST
90753: LIST
90754: PUSH
90755: EMPTY
90756: LIST
90757: LIST
90758: LIST
90759: LIST
90760: LIST
90761: LIST
90762: LIST
90763: LIST
90764: LIST
90765: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
90766: LD_ADDR_VAR 0 40
90770: PUSH
90771: LD_INT 0
90773: PUSH
90774: LD_INT 0
90776: PUSH
90777: EMPTY
90778: LIST
90779: LIST
90780: PUSH
90781: LD_INT 0
90783: PUSH
90784: LD_INT 1
90786: NEG
90787: PUSH
90788: EMPTY
90789: LIST
90790: LIST
90791: PUSH
90792: LD_INT 1
90794: PUSH
90795: LD_INT 0
90797: PUSH
90798: EMPTY
90799: LIST
90800: LIST
90801: PUSH
90802: LD_INT 1
90804: PUSH
90805: LD_INT 1
90807: PUSH
90808: EMPTY
90809: LIST
90810: LIST
90811: PUSH
90812: LD_INT 0
90814: PUSH
90815: LD_INT 1
90817: PUSH
90818: EMPTY
90819: LIST
90820: LIST
90821: PUSH
90822: LD_INT 1
90824: NEG
90825: PUSH
90826: LD_INT 0
90828: PUSH
90829: EMPTY
90830: LIST
90831: LIST
90832: PUSH
90833: LD_INT 1
90835: NEG
90836: PUSH
90837: LD_INT 1
90839: NEG
90840: PUSH
90841: EMPTY
90842: LIST
90843: LIST
90844: PUSH
90845: LD_INT 1
90847: PUSH
90848: LD_INT 1
90850: NEG
90851: PUSH
90852: EMPTY
90853: LIST
90854: LIST
90855: PUSH
90856: LD_INT 1
90858: NEG
90859: PUSH
90860: LD_INT 1
90862: PUSH
90863: EMPTY
90864: LIST
90865: LIST
90866: PUSH
90867: EMPTY
90868: LIST
90869: LIST
90870: LIST
90871: LIST
90872: LIST
90873: LIST
90874: LIST
90875: LIST
90876: LIST
90877: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90878: LD_ADDR_VAR 0 41
90882: PUSH
90883: LD_INT 0
90885: PUSH
90886: LD_INT 0
90888: PUSH
90889: EMPTY
90890: LIST
90891: LIST
90892: PUSH
90893: LD_INT 0
90895: PUSH
90896: LD_INT 1
90898: NEG
90899: PUSH
90900: EMPTY
90901: LIST
90902: LIST
90903: PUSH
90904: LD_INT 1
90906: PUSH
90907: LD_INT 0
90909: PUSH
90910: EMPTY
90911: LIST
90912: LIST
90913: PUSH
90914: LD_INT 1
90916: PUSH
90917: LD_INT 1
90919: PUSH
90920: EMPTY
90921: LIST
90922: LIST
90923: PUSH
90924: LD_INT 0
90926: PUSH
90927: LD_INT 1
90929: PUSH
90930: EMPTY
90931: LIST
90932: LIST
90933: PUSH
90934: LD_INT 1
90936: NEG
90937: PUSH
90938: LD_INT 0
90940: PUSH
90941: EMPTY
90942: LIST
90943: LIST
90944: PUSH
90945: LD_INT 1
90947: NEG
90948: PUSH
90949: LD_INT 1
90951: NEG
90952: PUSH
90953: EMPTY
90954: LIST
90955: LIST
90956: PUSH
90957: LD_INT 1
90959: NEG
90960: PUSH
90961: LD_INT 2
90963: NEG
90964: PUSH
90965: EMPTY
90966: LIST
90967: LIST
90968: PUSH
90969: LD_INT 1
90971: PUSH
90972: LD_INT 1
90974: NEG
90975: PUSH
90976: EMPTY
90977: LIST
90978: LIST
90979: PUSH
90980: LD_INT 2
90982: PUSH
90983: LD_INT 0
90985: PUSH
90986: EMPTY
90987: LIST
90988: LIST
90989: PUSH
90990: LD_INT 2
90992: PUSH
90993: LD_INT 1
90995: PUSH
90996: EMPTY
90997: LIST
90998: LIST
90999: PUSH
91000: LD_INT 2
91002: PUSH
91003: LD_INT 2
91005: PUSH
91006: EMPTY
91007: LIST
91008: LIST
91009: PUSH
91010: LD_INT 1
91012: PUSH
91013: LD_INT 2
91015: PUSH
91016: EMPTY
91017: LIST
91018: LIST
91019: PUSH
91020: LD_INT 1
91022: NEG
91023: PUSH
91024: LD_INT 1
91026: PUSH
91027: EMPTY
91028: LIST
91029: LIST
91030: PUSH
91031: LD_INT 2
91033: NEG
91034: PUSH
91035: LD_INT 0
91037: PUSH
91038: EMPTY
91039: LIST
91040: LIST
91041: PUSH
91042: LD_INT 2
91044: NEG
91045: PUSH
91046: LD_INT 1
91048: NEG
91049: PUSH
91050: EMPTY
91051: LIST
91052: LIST
91053: PUSH
91054: LD_INT 2
91056: NEG
91057: PUSH
91058: LD_INT 2
91060: NEG
91061: PUSH
91062: EMPTY
91063: LIST
91064: LIST
91065: PUSH
91066: LD_INT 2
91068: NEG
91069: PUSH
91070: LD_INT 3
91072: NEG
91073: PUSH
91074: EMPTY
91075: LIST
91076: LIST
91077: PUSH
91078: LD_INT 2
91080: PUSH
91081: LD_INT 1
91083: NEG
91084: PUSH
91085: EMPTY
91086: LIST
91087: LIST
91088: PUSH
91089: LD_INT 3
91091: PUSH
91092: LD_INT 0
91094: PUSH
91095: EMPTY
91096: LIST
91097: LIST
91098: PUSH
91099: LD_INT 3
91101: PUSH
91102: LD_INT 1
91104: PUSH
91105: EMPTY
91106: LIST
91107: LIST
91108: PUSH
91109: LD_INT 3
91111: PUSH
91112: LD_INT 2
91114: PUSH
91115: EMPTY
91116: LIST
91117: LIST
91118: PUSH
91119: LD_INT 3
91121: PUSH
91122: LD_INT 3
91124: PUSH
91125: EMPTY
91126: LIST
91127: LIST
91128: PUSH
91129: LD_INT 2
91131: PUSH
91132: LD_INT 3
91134: PUSH
91135: EMPTY
91136: LIST
91137: LIST
91138: PUSH
91139: LD_INT 2
91141: NEG
91142: PUSH
91143: LD_INT 1
91145: PUSH
91146: EMPTY
91147: LIST
91148: LIST
91149: PUSH
91150: LD_INT 3
91152: NEG
91153: PUSH
91154: LD_INT 0
91156: PUSH
91157: EMPTY
91158: LIST
91159: LIST
91160: PUSH
91161: LD_INT 3
91163: NEG
91164: PUSH
91165: LD_INT 1
91167: NEG
91168: PUSH
91169: EMPTY
91170: LIST
91171: LIST
91172: PUSH
91173: LD_INT 3
91175: NEG
91176: PUSH
91177: LD_INT 2
91179: NEG
91180: PUSH
91181: EMPTY
91182: LIST
91183: LIST
91184: PUSH
91185: LD_INT 3
91187: NEG
91188: PUSH
91189: LD_INT 3
91191: NEG
91192: PUSH
91193: EMPTY
91194: LIST
91195: LIST
91196: PUSH
91197: EMPTY
91198: LIST
91199: LIST
91200: LIST
91201: LIST
91202: LIST
91203: LIST
91204: LIST
91205: LIST
91206: LIST
91207: LIST
91208: LIST
91209: LIST
91210: LIST
91211: LIST
91212: LIST
91213: LIST
91214: LIST
91215: LIST
91216: LIST
91217: LIST
91218: LIST
91219: LIST
91220: LIST
91221: LIST
91222: LIST
91223: LIST
91224: LIST
91225: LIST
91226: LIST
91227: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91228: LD_ADDR_VAR 0 42
91232: PUSH
91233: LD_INT 0
91235: PUSH
91236: LD_INT 0
91238: PUSH
91239: EMPTY
91240: LIST
91241: LIST
91242: PUSH
91243: LD_INT 0
91245: PUSH
91246: LD_INT 1
91248: NEG
91249: PUSH
91250: EMPTY
91251: LIST
91252: LIST
91253: PUSH
91254: LD_INT 1
91256: PUSH
91257: LD_INT 0
91259: PUSH
91260: EMPTY
91261: LIST
91262: LIST
91263: PUSH
91264: LD_INT 1
91266: PUSH
91267: LD_INT 1
91269: PUSH
91270: EMPTY
91271: LIST
91272: LIST
91273: PUSH
91274: LD_INT 0
91276: PUSH
91277: LD_INT 1
91279: PUSH
91280: EMPTY
91281: LIST
91282: LIST
91283: PUSH
91284: LD_INT 1
91286: NEG
91287: PUSH
91288: LD_INT 0
91290: PUSH
91291: EMPTY
91292: LIST
91293: LIST
91294: PUSH
91295: LD_INT 1
91297: NEG
91298: PUSH
91299: LD_INT 1
91301: NEG
91302: PUSH
91303: EMPTY
91304: LIST
91305: LIST
91306: PUSH
91307: LD_INT 1
91309: NEG
91310: PUSH
91311: LD_INT 2
91313: NEG
91314: PUSH
91315: EMPTY
91316: LIST
91317: LIST
91318: PUSH
91319: LD_INT 0
91321: PUSH
91322: LD_INT 2
91324: NEG
91325: PUSH
91326: EMPTY
91327: LIST
91328: LIST
91329: PUSH
91330: LD_INT 1
91332: PUSH
91333: LD_INT 1
91335: NEG
91336: PUSH
91337: EMPTY
91338: LIST
91339: LIST
91340: PUSH
91341: LD_INT 2
91343: PUSH
91344: LD_INT 1
91346: PUSH
91347: EMPTY
91348: LIST
91349: LIST
91350: PUSH
91351: LD_INT 2
91353: PUSH
91354: LD_INT 2
91356: PUSH
91357: EMPTY
91358: LIST
91359: LIST
91360: PUSH
91361: LD_INT 1
91363: PUSH
91364: LD_INT 2
91366: PUSH
91367: EMPTY
91368: LIST
91369: LIST
91370: PUSH
91371: LD_INT 0
91373: PUSH
91374: LD_INT 2
91376: PUSH
91377: EMPTY
91378: LIST
91379: LIST
91380: PUSH
91381: LD_INT 1
91383: NEG
91384: PUSH
91385: LD_INT 1
91387: PUSH
91388: EMPTY
91389: LIST
91390: LIST
91391: PUSH
91392: LD_INT 2
91394: NEG
91395: PUSH
91396: LD_INT 1
91398: NEG
91399: PUSH
91400: EMPTY
91401: LIST
91402: LIST
91403: PUSH
91404: LD_INT 2
91406: NEG
91407: PUSH
91408: LD_INT 2
91410: NEG
91411: PUSH
91412: EMPTY
91413: LIST
91414: LIST
91415: PUSH
91416: LD_INT 2
91418: NEG
91419: PUSH
91420: LD_INT 3
91422: NEG
91423: PUSH
91424: EMPTY
91425: LIST
91426: LIST
91427: PUSH
91428: LD_INT 1
91430: NEG
91431: PUSH
91432: LD_INT 3
91434: NEG
91435: PUSH
91436: EMPTY
91437: LIST
91438: LIST
91439: PUSH
91440: LD_INT 0
91442: PUSH
91443: LD_INT 3
91445: NEG
91446: PUSH
91447: EMPTY
91448: LIST
91449: LIST
91450: PUSH
91451: LD_INT 1
91453: PUSH
91454: LD_INT 2
91456: NEG
91457: PUSH
91458: EMPTY
91459: LIST
91460: LIST
91461: PUSH
91462: LD_INT 3
91464: PUSH
91465: LD_INT 2
91467: PUSH
91468: EMPTY
91469: LIST
91470: LIST
91471: PUSH
91472: LD_INT 3
91474: PUSH
91475: LD_INT 3
91477: PUSH
91478: EMPTY
91479: LIST
91480: LIST
91481: PUSH
91482: LD_INT 2
91484: PUSH
91485: LD_INT 3
91487: PUSH
91488: EMPTY
91489: LIST
91490: LIST
91491: PUSH
91492: LD_INT 1
91494: PUSH
91495: LD_INT 3
91497: PUSH
91498: EMPTY
91499: LIST
91500: LIST
91501: PUSH
91502: LD_INT 0
91504: PUSH
91505: LD_INT 3
91507: PUSH
91508: EMPTY
91509: LIST
91510: LIST
91511: PUSH
91512: LD_INT 1
91514: NEG
91515: PUSH
91516: LD_INT 2
91518: PUSH
91519: EMPTY
91520: LIST
91521: LIST
91522: PUSH
91523: LD_INT 3
91525: NEG
91526: PUSH
91527: LD_INT 2
91529: NEG
91530: PUSH
91531: EMPTY
91532: LIST
91533: LIST
91534: PUSH
91535: LD_INT 3
91537: NEG
91538: PUSH
91539: LD_INT 3
91541: NEG
91542: PUSH
91543: EMPTY
91544: LIST
91545: LIST
91546: PUSH
91547: EMPTY
91548: LIST
91549: LIST
91550: LIST
91551: LIST
91552: LIST
91553: LIST
91554: LIST
91555: LIST
91556: LIST
91557: LIST
91558: LIST
91559: LIST
91560: LIST
91561: LIST
91562: LIST
91563: LIST
91564: LIST
91565: LIST
91566: LIST
91567: LIST
91568: LIST
91569: LIST
91570: LIST
91571: LIST
91572: LIST
91573: LIST
91574: LIST
91575: LIST
91576: LIST
91577: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91578: LD_ADDR_VAR 0 43
91582: PUSH
91583: LD_INT 0
91585: PUSH
91586: LD_INT 0
91588: PUSH
91589: EMPTY
91590: LIST
91591: LIST
91592: PUSH
91593: LD_INT 0
91595: PUSH
91596: LD_INT 1
91598: NEG
91599: PUSH
91600: EMPTY
91601: LIST
91602: LIST
91603: PUSH
91604: LD_INT 1
91606: PUSH
91607: LD_INT 0
91609: PUSH
91610: EMPTY
91611: LIST
91612: LIST
91613: PUSH
91614: LD_INT 1
91616: PUSH
91617: LD_INT 1
91619: PUSH
91620: EMPTY
91621: LIST
91622: LIST
91623: PUSH
91624: LD_INT 0
91626: PUSH
91627: LD_INT 1
91629: PUSH
91630: EMPTY
91631: LIST
91632: LIST
91633: PUSH
91634: LD_INT 1
91636: NEG
91637: PUSH
91638: LD_INT 0
91640: PUSH
91641: EMPTY
91642: LIST
91643: LIST
91644: PUSH
91645: LD_INT 1
91647: NEG
91648: PUSH
91649: LD_INT 1
91651: NEG
91652: PUSH
91653: EMPTY
91654: LIST
91655: LIST
91656: PUSH
91657: LD_INT 1
91659: NEG
91660: PUSH
91661: LD_INT 2
91663: NEG
91664: PUSH
91665: EMPTY
91666: LIST
91667: LIST
91668: PUSH
91669: LD_INT 0
91671: PUSH
91672: LD_INT 2
91674: NEG
91675: PUSH
91676: EMPTY
91677: LIST
91678: LIST
91679: PUSH
91680: LD_INT 1
91682: PUSH
91683: LD_INT 1
91685: NEG
91686: PUSH
91687: EMPTY
91688: LIST
91689: LIST
91690: PUSH
91691: LD_INT 2
91693: PUSH
91694: LD_INT 0
91696: PUSH
91697: EMPTY
91698: LIST
91699: LIST
91700: PUSH
91701: LD_INT 2
91703: PUSH
91704: LD_INT 1
91706: PUSH
91707: EMPTY
91708: LIST
91709: LIST
91710: PUSH
91711: LD_INT 1
91713: PUSH
91714: LD_INT 2
91716: PUSH
91717: EMPTY
91718: LIST
91719: LIST
91720: PUSH
91721: LD_INT 0
91723: PUSH
91724: LD_INT 2
91726: PUSH
91727: EMPTY
91728: LIST
91729: LIST
91730: PUSH
91731: LD_INT 1
91733: NEG
91734: PUSH
91735: LD_INT 1
91737: PUSH
91738: EMPTY
91739: LIST
91740: LIST
91741: PUSH
91742: LD_INT 2
91744: NEG
91745: PUSH
91746: LD_INT 0
91748: PUSH
91749: EMPTY
91750: LIST
91751: LIST
91752: PUSH
91753: LD_INT 2
91755: NEG
91756: PUSH
91757: LD_INT 1
91759: NEG
91760: PUSH
91761: EMPTY
91762: LIST
91763: LIST
91764: PUSH
91765: LD_INT 1
91767: NEG
91768: PUSH
91769: LD_INT 3
91771: NEG
91772: PUSH
91773: EMPTY
91774: LIST
91775: LIST
91776: PUSH
91777: LD_INT 0
91779: PUSH
91780: LD_INT 3
91782: NEG
91783: PUSH
91784: EMPTY
91785: LIST
91786: LIST
91787: PUSH
91788: LD_INT 1
91790: PUSH
91791: LD_INT 2
91793: NEG
91794: PUSH
91795: EMPTY
91796: LIST
91797: LIST
91798: PUSH
91799: LD_INT 2
91801: PUSH
91802: LD_INT 1
91804: NEG
91805: PUSH
91806: EMPTY
91807: LIST
91808: LIST
91809: PUSH
91810: LD_INT 3
91812: PUSH
91813: LD_INT 0
91815: PUSH
91816: EMPTY
91817: LIST
91818: LIST
91819: PUSH
91820: LD_INT 3
91822: PUSH
91823: LD_INT 1
91825: PUSH
91826: EMPTY
91827: LIST
91828: LIST
91829: PUSH
91830: LD_INT 1
91832: PUSH
91833: LD_INT 3
91835: PUSH
91836: EMPTY
91837: LIST
91838: LIST
91839: PUSH
91840: LD_INT 0
91842: PUSH
91843: LD_INT 3
91845: PUSH
91846: EMPTY
91847: LIST
91848: LIST
91849: PUSH
91850: LD_INT 1
91852: NEG
91853: PUSH
91854: LD_INT 2
91856: PUSH
91857: EMPTY
91858: LIST
91859: LIST
91860: PUSH
91861: LD_INT 2
91863: NEG
91864: PUSH
91865: LD_INT 1
91867: PUSH
91868: EMPTY
91869: LIST
91870: LIST
91871: PUSH
91872: LD_INT 3
91874: NEG
91875: PUSH
91876: LD_INT 0
91878: PUSH
91879: EMPTY
91880: LIST
91881: LIST
91882: PUSH
91883: LD_INT 3
91885: NEG
91886: PUSH
91887: LD_INT 1
91889: NEG
91890: PUSH
91891: EMPTY
91892: LIST
91893: LIST
91894: PUSH
91895: EMPTY
91896: LIST
91897: LIST
91898: LIST
91899: LIST
91900: LIST
91901: LIST
91902: LIST
91903: LIST
91904: LIST
91905: LIST
91906: LIST
91907: LIST
91908: LIST
91909: LIST
91910: LIST
91911: LIST
91912: LIST
91913: LIST
91914: LIST
91915: LIST
91916: LIST
91917: LIST
91918: LIST
91919: LIST
91920: LIST
91921: LIST
91922: LIST
91923: LIST
91924: LIST
91925: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91926: LD_ADDR_VAR 0 44
91930: PUSH
91931: LD_INT 0
91933: PUSH
91934: LD_INT 0
91936: PUSH
91937: EMPTY
91938: LIST
91939: LIST
91940: PUSH
91941: LD_INT 0
91943: PUSH
91944: LD_INT 1
91946: NEG
91947: PUSH
91948: EMPTY
91949: LIST
91950: LIST
91951: PUSH
91952: LD_INT 1
91954: PUSH
91955: LD_INT 0
91957: PUSH
91958: EMPTY
91959: LIST
91960: LIST
91961: PUSH
91962: LD_INT 1
91964: PUSH
91965: LD_INT 1
91967: PUSH
91968: EMPTY
91969: LIST
91970: LIST
91971: PUSH
91972: LD_INT 0
91974: PUSH
91975: LD_INT 1
91977: PUSH
91978: EMPTY
91979: LIST
91980: LIST
91981: PUSH
91982: LD_INT 1
91984: NEG
91985: PUSH
91986: LD_INT 0
91988: PUSH
91989: EMPTY
91990: LIST
91991: LIST
91992: PUSH
91993: LD_INT 1
91995: NEG
91996: PUSH
91997: LD_INT 1
91999: NEG
92000: PUSH
92001: EMPTY
92002: LIST
92003: LIST
92004: PUSH
92005: LD_INT 1
92007: NEG
92008: PUSH
92009: LD_INT 2
92011: NEG
92012: PUSH
92013: EMPTY
92014: LIST
92015: LIST
92016: PUSH
92017: LD_INT 1
92019: PUSH
92020: LD_INT 1
92022: NEG
92023: PUSH
92024: EMPTY
92025: LIST
92026: LIST
92027: PUSH
92028: LD_INT 2
92030: PUSH
92031: LD_INT 0
92033: PUSH
92034: EMPTY
92035: LIST
92036: LIST
92037: PUSH
92038: LD_INT 2
92040: PUSH
92041: LD_INT 1
92043: PUSH
92044: EMPTY
92045: LIST
92046: LIST
92047: PUSH
92048: LD_INT 2
92050: PUSH
92051: LD_INT 2
92053: PUSH
92054: EMPTY
92055: LIST
92056: LIST
92057: PUSH
92058: LD_INT 1
92060: PUSH
92061: LD_INT 2
92063: PUSH
92064: EMPTY
92065: LIST
92066: LIST
92067: PUSH
92068: LD_INT 1
92070: NEG
92071: PUSH
92072: LD_INT 1
92074: PUSH
92075: EMPTY
92076: LIST
92077: LIST
92078: PUSH
92079: LD_INT 2
92081: NEG
92082: PUSH
92083: LD_INT 0
92085: PUSH
92086: EMPTY
92087: LIST
92088: LIST
92089: PUSH
92090: LD_INT 2
92092: NEG
92093: PUSH
92094: LD_INT 1
92096: NEG
92097: PUSH
92098: EMPTY
92099: LIST
92100: LIST
92101: PUSH
92102: LD_INT 2
92104: NEG
92105: PUSH
92106: LD_INT 2
92108: NEG
92109: PUSH
92110: EMPTY
92111: LIST
92112: LIST
92113: PUSH
92114: LD_INT 2
92116: NEG
92117: PUSH
92118: LD_INT 3
92120: NEG
92121: PUSH
92122: EMPTY
92123: LIST
92124: LIST
92125: PUSH
92126: LD_INT 2
92128: PUSH
92129: LD_INT 1
92131: NEG
92132: PUSH
92133: EMPTY
92134: LIST
92135: LIST
92136: PUSH
92137: LD_INT 3
92139: PUSH
92140: LD_INT 0
92142: PUSH
92143: EMPTY
92144: LIST
92145: LIST
92146: PUSH
92147: LD_INT 3
92149: PUSH
92150: LD_INT 1
92152: PUSH
92153: EMPTY
92154: LIST
92155: LIST
92156: PUSH
92157: LD_INT 3
92159: PUSH
92160: LD_INT 2
92162: PUSH
92163: EMPTY
92164: LIST
92165: LIST
92166: PUSH
92167: LD_INT 3
92169: PUSH
92170: LD_INT 3
92172: PUSH
92173: EMPTY
92174: LIST
92175: LIST
92176: PUSH
92177: LD_INT 2
92179: PUSH
92180: LD_INT 3
92182: PUSH
92183: EMPTY
92184: LIST
92185: LIST
92186: PUSH
92187: LD_INT 2
92189: NEG
92190: PUSH
92191: LD_INT 1
92193: PUSH
92194: EMPTY
92195: LIST
92196: LIST
92197: PUSH
92198: LD_INT 3
92200: NEG
92201: PUSH
92202: LD_INT 0
92204: PUSH
92205: EMPTY
92206: LIST
92207: LIST
92208: PUSH
92209: LD_INT 3
92211: NEG
92212: PUSH
92213: LD_INT 1
92215: NEG
92216: PUSH
92217: EMPTY
92218: LIST
92219: LIST
92220: PUSH
92221: LD_INT 3
92223: NEG
92224: PUSH
92225: LD_INT 2
92227: NEG
92228: PUSH
92229: EMPTY
92230: LIST
92231: LIST
92232: PUSH
92233: LD_INT 3
92235: NEG
92236: PUSH
92237: LD_INT 3
92239: NEG
92240: PUSH
92241: EMPTY
92242: LIST
92243: LIST
92244: PUSH
92245: EMPTY
92246: LIST
92247: LIST
92248: LIST
92249: LIST
92250: LIST
92251: LIST
92252: LIST
92253: LIST
92254: LIST
92255: LIST
92256: LIST
92257: LIST
92258: LIST
92259: LIST
92260: LIST
92261: LIST
92262: LIST
92263: LIST
92264: LIST
92265: LIST
92266: LIST
92267: LIST
92268: LIST
92269: LIST
92270: LIST
92271: LIST
92272: LIST
92273: LIST
92274: LIST
92275: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92276: LD_ADDR_VAR 0 45
92280: PUSH
92281: LD_INT 0
92283: PUSH
92284: LD_INT 0
92286: PUSH
92287: EMPTY
92288: LIST
92289: LIST
92290: PUSH
92291: LD_INT 0
92293: PUSH
92294: LD_INT 1
92296: NEG
92297: PUSH
92298: EMPTY
92299: LIST
92300: LIST
92301: PUSH
92302: LD_INT 1
92304: PUSH
92305: LD_INT 0
92307: PUSH
92308: EMPTY
92309: LIST
92310: LIST
92311: PUSH
92312: LD_INT 1
92314: PUSH
92315: LD_INT 1
92317: PUSH
92318: EMPTY
92319: LIST
92320: LIST
92321: PUSH
92322: LD_INT 0
92324: PUSH
92325: LD_INT 1
92327: PUSH
92328: EMPTY
92329: LIST
92330: LIST
92331: PUSH
92332: LD_INT 1
92334: NEG
92335: PUSH
92336: LD_INT 0
92338: PUSH
92339: EMPTY
92340: LIST
92341: LIST
92342: PUSH
92343: LD_INT 1
92345: NEG
92346: PUSH
92347: LD_INT 1
92349: NEG
92350: PUSH
92351: EMPTY
92352: LIST
92353: LIST
92354: PUSH
92355: LD_INT 1
92357: NEG
92358: PUSH
92359: LD_INT 2
92361: NEG
92362: PUSH
92363: EMPTY
92364: LIST
92365: LIST
92366: PUSH
92367: LD_INT 0
92369: PUSH
92370: LD_INT 2
92372: NEG
92373: PUSH
92374: EMPTY
92375: LIST
92376: LIST
92377: PUSH
92378: LD_INT 1
92380: PUSH
92381: LD_INT 1
92383: NEG
92384: PUSH
92385: EMPTY
92386: LIST
92387: LIST
92388: PUSH
92389: LD_INT 2
92391: PUSH
92392: LD_INT 1
92394: PUSH
92395: EMPTY
92396: LIST
92397: LIST
92398: PUSH
92399: LD_INT 2
92401: PUSH
92402: LD_INT 2
92404: PUSH
92405: EMPTY
92406: LIST
92407: LIST
92408: PUSH
92409: LD_INT 1
92411: PUSH
92412: LD_INT 2
92414: PUSH
92415: EMPTY
92416: LIST
92417: LIST
92418: PUSH
92419: LD_INT 0
92421: PUSH
92422: LD_INT 2
92424: PUSH
92425: EMPTY
92426: LIST
92427: LIST
92428: PUSH
92429: LD_INT 1
92431: NEG
92432: PUSH
92433: LD_INT 1
92435: PUSH
92436: EMPTY
92437: LIST
92438: LIST
92439: PUSH
92440: LD_INT 2
92442: NEG
92443: PUSH
92444: LD_INT 1
92446: NEG
92447: PUSH
92448: EMPTY
92449: LIST
92450: LIST
92451: PUSH
92452: LD_INT 2
92454: NEG
92455: PUSH
92456: LD_INT 2
92458: NEG
92459: PUSH
92460: EMPTY
92461: LIST
92462: LIST
92463: PUSH
92464: LD_INT 2
92466: NEG
92467: PUSH
92468: LD_INT 3
92470: NEG
92471: PUSH
92472: EMPTY
92473: LIST
92474: LIST
92475: PUSH
92476: LD_INT 1
92478: NEG
92479: PUSH
92480: LD_INT 3
92482: NEG
92483: PUSH
92484: EMPTY
92485: LIST
92486: LIST
92487: PUSH
92488: LD_INT 0
92490: PUSH
92491: LD_INT 3
92493: NEG
92494: PUSH
92495: EMPTY
92496: LIST
92497: LIST
92498: PUSH
92499: LD_INT 1
92501: PUSH
92502: LD_INT 2
92504: NEG
92505: PUSH
92506: EMPTY
92507: LIST
92508: LIST
92509: PUSH
92510: LD_INT 3
92512: PUSH
92513: LD_INT 2
92515: PUSH
92516: EMPTY
92517: LIST
92518: LIST
92519: PUSH
92520: LD_INT 3
92522: PUSH
92523: LD_INT 3
92525: PUSH
92526: EMPTY
92527: LIST
92528: LIST
92529: PUSH
92530: LD_INT 2
92532: PUSH
92533: LD_INT 3
92535: PUSH
92536: EMPTY
92537: LIST
92538: LIST
92539: PUSH
92540: LD_INT 1
92542: PUSH
92543: LD_INT 3
92545: PUSH
92546: EMPTY
92547: LIST
92548: LIST
92549: PUSH
92550: LD_INT 0
92552: PUSH
92553: LD_INT 3
92555: PUSH
92556: EMPTY
92557: LIST
92558: LIST
92559: PUSH
92560: LD_INT 1
92562: NEG
92563: PUSH
92564: LD_INT 2
92566: PUSH
92567: EMPTY
92568: LIST
92569: LIST
92570: PUSH
92571: LD_INT 3
92573: NEG
92574: PUSH
92575: LD_INT 2
92577: NEG
92578: PUSH
92579: EMPTY
92580: LIST
92581: LIST
92582: PUSH
92583: LD_INT 3
92585: NEG
92586: PUSH
92587: LD_INT 3
92589: NEG
92590: PUSH
92591: EMPTY
92592: LIST
92593: LIST
92594: PUSH
92595: EMPTY
92596: LIST
92597: LIST
92598: LIST
92599: LIST
92600: LIST
92601: LIST
92602: LIST
92603: LIST
92604: LIST
92605: LIST
92606: LIST
92607: LIST
92608: LIST
92609: LIST
92610: LIST
92611: LIST
92612: LIST
92613: LIST
92614: LIST
92615: LIST
92616: LIST
92617: LIST
92618: LIST
92619: LIST
92620: LIST
92621: LIST
92622: LIST
92623: LIST
92624: LIST
92625: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92626: LD_ADDR_VAR 0 46
92630: PUSH
92631: LD_INT 0
92633: PUSH
92634: LD_INT 0
92636: PUSH
92637: EMPTY
92638: LIST
92639: LIST
92640: PUSH
92641: LD_INT 0
92643: PUSH
92644: LD_INT 1
92646: NEG
92647: PUSH
92648: EMPTY
92649: LIST
92650: LIST
92651: PUSH
92652: LD_INT 1
92654: PUSH
92655: LD_INT 0
92657: PUSH
92658: EMPTY
92659: LIST
92660: LIST
92661: PUSH
92662: LD_INT 1
92664: PUSH
92665: LD_INT 1
92667: PUSH
92668: EMPTY
92669: LIST
92670: LIST
92671: PUSH
92672: LD_INT 0
92674: PUSH
92675: LD_INT 1
92677: PUSH
92678: EMPTY
92679: LIST
92680: LIST
92681: PUSH
92682: LD_INT 1
92684: NEG
92685: PUSH
92686: LD_INT 0
92688: PUSH
92689: EMPTY
92690: LIST
92691: LIST
92692: PUSH
92693: LD_INT 1
92695: NEG
92696: PUSH
92697: LD_INT 1
92699: NEG
92700: PUSH
92701: EMPTY
92702: LIST
92703: LIST
92704: PUSH
92705: LD_INT 1
92707: NEG
92708: PUSH
92709: LD_INT 2
92711: NEG
92712: PUSH
92713: EMPTY
92714: LIST
92715: LIST
92716: PUSH
92717: LD_INT 0
92719: PUSH
92720: LD_INT 2
92722: NEG
92723: PUSH
92724: EMPTY
92725: LIST
92726: LIST
92727: PUSH
92728: LD_INT 1
92730: PUSH
92731: LD_INT 1
92733: NEG
92734: PUSH
92735: EMPTY
92736: LIST
92737: LIST
92738: PUSH
92739: LD_INT 2
92741: PUSH
92742: LD_INT 0
92744: PUSH
92745: EMPTY
92746: LIST
92747: LIST
92748: PUSH
92749: LD_INT 2
92751: PUSH
92752: LD_INT 1
92754: PUSH
92755: EMPTY
92756: LIST
92757: LIST
92758: PUSH
92759: LD_INT 1
92761: PUSH
92762: LD_INT 2
92764: PUSH
92765: EMPTY
92766: LIST
92767: LIST
92768: PUSH
92769: LD_INT 0
92771: PUSH
92772: LD_INT 2
92774: PUSH
92775: EMPTY
92776: LIST
92777: LIST
92778: PUSH
92779: LD_INT 1
92781: NEG
92782: PUSH
92783: LD_INT 1
92785: PUSH
92786: EMPTY
92787: LIST
92788: LIST
92789: PUSH
92790: LD_INT 2
92792: NEG
92793: PUSH
92794: LD_INT 0
92796: PUSH
92797: EMPTY
92798: LIST
92799: LIST
92800: PUSH
92801: LD_INT 2
92803: NEG
92804: PUSH
92805: LD_INT 1
92807: NEG
92808: PUSH
92809: EMPTY
92810: LIST
92811: LIST
92812: PUSH
92813: LD_INT 1
92815: NEG
92816: PUSH
92817: LD_INT 3
92819: NEG
92820: PUSH
92821: EMPTY
92822: LIST
92823: LIST
92824: PUSH
92825: LD_INT 0
92827: PUSH
92828: LD_INT 3
92830: NEG
92831: PUSH
92832: EMPTY
92833: LIST
92834: LIST
92835: PUSH
92836: LD_INT 1
92838: PUSH
92839: LD_INT 2
92841: NEG
92842: PUSH
92843: EMPTY
92844: LIST
92845: LIST
92846: PUSH
92847: LD_INT 2
92849: PUSH
92850: LD_INT 1
92852: NEG
92853: PUSH
92854: EMPTY
92855: LIST
92856: LIST
92857: PUSH
92858: LD_INT 3
92860: PUSH
92861: LD_INT 0
92863: PUSH
92864: EMPTY
92865: LIST
92866: LIST
92867: PUSH
92868: LD_INT 3
92870: PUSH
92871: LD_INT 1
92873: PUSH
92874: EMPTY
92875: LIST
92876: LIST
92877: PUSH
92878: LD_INT 1
92880: PUSH
92881: LD_INT 3
92883: PUSH
92884: EMPTY
92885: LIST
92886: LIST
92887: PUSH
92888: LD_INT 0
92890: PUSH
92891: LD_INT 3
92893: PUSH
92894: EMPTY
92895: LIST
92896: LIST
92897: PUSH
92898: LD_INT 1
92900: NEG
92901: PUSH
92902: LD_INT 2
92904: PUSH
92905: EMPTY
92906: LIST
92907: LIST
92908: PUSH
92909: LD_INT 2
92911: NEG
92912: PUSH
92913: LD_INT 1
92915: PUSH
92916: EMPTY
92917: LIST
92918: LIST
92919: PUSH
92920: LD_INT 3
92922: NEG
92923: PUSH
92924: LD_INT 0
92926: PUSH
92927: EMPTY
92928: LIST
92929: LIST
92930: PUSH
92931: LD_INT 3
92933: NEG
92934: PUSH
92935: LD_INT 1
92937: NEG
92938: PUSH
92939: EMPTY
92940: LIST
92941: LIST
92942: PUSH
92943: EMPTY
92944: LIST
92945: LIST
92946: LIST
92947: LIST
92948: LIST
92949: LIST
92950: LIST
92951: LIST
92952: LIST
92953: LIST
92954: LIST
92955: LIST
92956: LIST
92957: LIST
92958: LIST
92959: LIST
92960: LIST
92961: LIST
92962: LIST
92963: LIST
92964: LIST
92965: LIST
92966: LIST
92967: LIST
92968: LIST
92969: LIST
92970: LIST
92971: LIST
92972: LIST
92973: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92974: LD_ADDR_VAR 0 47
92978: PUSH
92979: LD_INT 0
92981: PUSH
92982: LD_INT 0
92984: PUSH
92985: EMPTY
92986: LIST
92987: LIST
92988: PUSH
92989: LD_INT 0
92991: PUSH
92992: LD_INT 1
92994: NEG
92995: PUSH
92996: EMPTY
92997: LIST
92998: LIST
92999: PUSH
93000: LD_INT 1
93002: PUSH
93003: LD_INT 0
93005: PUSH
93006: EMPTY
93007: LIST
93008: LIST
93009: PUSH
93010: LD_INT 1
93012: PUSH
93013: LD_INT 1
93015: PUSH
93016: EMPTY
93017: LIST
93018: LIST
93019: PUSH
93020: LD_INT 0
93022: PUSH
93023: LD_INT 1
93025: PUSH
93026: EMPTY
93027: LIST
93028: LIST
93029: PUSH
93030: LD_INT 1
93032: NEG
93033: PUSH
93034: LD_INT 0
93036: PUSH
93037: EMPTY
93038: LIST
93039: LIST
93040: PUSH
93041: LD_INT 1
93043: NEG
93044: PUSH
93045: LD_INT 1
93047: NEG
93048: PUSH
93049: EMPTY
93050: LIST
93051: LIST
93052: PUSH
93053: LD_INT 1
93055: NEG
93056: PUSH
93057: LD_INT 2
93059: NEG
93060: PUSH
93061: EMPTY
93062: LIST
93063: LIST
93064: PUSH
93065: LD_INT 0
93067: PUSH
93068: LD_INT 2
93070: NEG
93071: PUSH
93072: EMPTY
93073: LIST
93074: LIST
93075: PUSH
93076: LD_INT 1
93078: PUSH
93079: LD_INT 1
93081: NEG
93082: PUSH
93083: EMPTY
93084: LIST
93085: LIST
93086: PUSH
93087: LD_INT 2
93089: NEG
93090: PUSH
93091: LD_INT 1
93093: NEG
93094: PUSH
93095: EMPTY
93096: LIST
93097: LIST
93098: PUSH
93099: LD_INT 2
93101: NEG
93102: PUSH
93103: LD_INT 2
93105: NEG
93106: PUSH
93107: EMPTY
93108: LIST
93109: LIST
93110: PUSH
93111: EMPTY
93112: LIST
93113: LIST
93114: LIST
93115: LIST
93116: LIST
93117: LIST
93118: LIST
93119: LIST
93120: LIST
93121: LIST
93122: LIST
93123: LIST
93124: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
93125: LD_ADDR_VAR 0 48
93129: PUSH
93130: LD_INT 0
93132: PUSH
93133: LD_INT 0
93135: PUSH
93136: EMPTY
93137: LIST
93138: LIST
93139: PUSH
93140: LD_INT 0
93142: PUSH
93143: LD_INT 1
93145: NEG
93146: PUSH
93147: EMPTY
93148: LIST
93149: LIST
93150: PUSH
93151: LD_INT 1
93153: PUSH
93154: LD_INT 0
93156: PUSH
93157: EMPTY
93158: LIST
93159: LIST
93160: PUSH
93161: LD_INT 1
93163: PUSH
93164: LD_INT 1
93166: PUSH
93167: EMPTY
93168: LIST
93169: LIST
93170: PUSH
93171: LD_INT 0
93173: PUSH
93174: LD_INT 1
93176: PUSH
93177: EMPTY
93178: LIST
93179: LIST
93180: PUSH
93181: LD_INT 1
93183: NEG
93184: PUSH
93185: LD_INT 0
93187: PUSH
93188: EMPTY
93189: LIST
93190: LIST
93191: PUSH
93192: LD_INT 1
93194: NEG
93195: PUSH
93196: LD_INT 1
93198: NEG
93199: PUSH
93200: EMPTY
93201: LIST
93202: LIST
93203: PUSH
93204: LD_INT 1
93206: NEG
93207: PUSH
93208: LD_INT 2
93210: NEG
93211: PUSH
93212: EMPTY
93213: LIST
93214: LIST
93215: PUSH
93216: LD_INT 0
93218: PUSH
93219: LD_INT 2
93221: NEG
93222: PUSH
93223: EMPTY
93224: LIST
93225: LIST
93226: PUSH
93227: LD_INT 1
93229: PUSH
93230: LD_INT 1
93232: NEG
93233: PUSH
93234: EMPTY
93235: LIST
93236: LIST
93237: PUSH
93238: LD_INT 2
93240: PUSH
93241: LD_INT 0
93243: PUSH
93244: EMPTY
93245: LIST
93246: LIST
93247: PUSH
93248: LD_INT 2
93250: PUSH
93251: LD_INT 1
93253: PUSH
93254: EMPTY
93255: LIST
93256: LIST
93257: PUSH
93258: EMPTY
93259: LIST
93260: LIST
93261: LIST
93262: LIST
93263: LIST
93264: LIST
93265: LIST
93266: LIST
93267: LIST
93268: LIST
93269: LIST
93270: LIST
93271: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
93272: LD_ADDR_VAR 0 49
93276: PUSH
93277: LD_INT 0
93279: PUSH
93280: LD_INT 0
93282: PUSH
93283: EMPTY
93284: LIST
93285: LIST
93286: PUSH
93287: LD_INT 0
93289: PUSH
93290: LD_INT 1
93292: NEG
93293: PUSH
93294: EMPTY
93295: LIST
93296: LIST
93297: PUSH
93298: LD_INT 1
93300: PUSH
93301: LD_INT 0
93303: PUSH
93304: EMPTY
93305: LIST
93306: LIST
93307: PUSH
93308: LD_INT 1
93310: PUSH
93311: LD_INT 1
93313: PUSH
93314: EMPTY
93315: LIST
93316: LIST
93317: PUSH
93318: LD_INT 0
93320: PUSH
93321: LD_INT 1
93323: PUSH
93324: EMPTY
93325: LIST
93326: LIST
93327: PUSH
93328: LD_INT 1
93330: NEG
93331: PUSH
93332: LD_INT 0
93334: PUSH
93335: EMPTY
93336: LIST
93337: LIST
93338: PUSH
93339: LD_INT 1
93341: NEG
93342: PUSH
93343: LD_INT 1
93345: NEG
93346: PUSH
93347: EMPTY
93348: LIST
93349: LIST
93350: PUSH
93351: LD_INT 1
93353: PUSH
93354: LD_INT 1
93356: NEG
93357: PUSH
93358: EMPTY
93359: LIST
93360: LIST
93361: PUSH
93362: LD_INT 2
93364: PUSH
93365: LD_INT 0
93367: PUSH
93368: EMPTY
93369: LIST
93370: LIST
93371: PUSH
93372: LD_INT 2
93374: PUSH
93375: LD_INT 1
93377: PUSH
93378: EMPTY
93379: LIST
93380: LIST
93381: PUSH
93382: LD_INT 2
93384: PUSH
93385: LD_INT 2
93387: PUSH
93388: EMPTY
93389: LIST
93390: LIST
93391: PUSH
93392: LD_INT 1
93394: PUSH
93395: LD_INT 2
93397: PUSH
93398: EMPTY
93399: LIST
93400: LIST
93401: PUSH
93402: EMPTY
93403: LIST
93404: LIST
93405: LIST
93406: LIST
93407: LIST
93408: LIST
93409: LIST
93410: LIST
93411: LIST
93412: LIST
93413: LIST
93414: LIST
93415: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
93416: LD_ADDR_VAR 0 50
93420: PUSH
93421: LD_INT 0
93423: PUSH
93424: LD_INT 0
93426: PUSH
93427: EMPTY
93428: LIST
93429: LIST
93430: PUSH
93431: LD_INT 0
93433: PUSH
93434: LD_INT 1
93436: NEG
93437: PUSH
93438: EMPTY
93439: LIST
93440: LIST
93441: PUSH
93442: LD_INT 1
93444: PUSH
93445: LD_INT 0
93447: PUSH
93448: EMPTY
93449: LIST
93450: LIST
93451: PUSH
93452: LD_INT 1
93454: PUSH
93455: LD_INT 1
93457: PUSH
93458: EMPTY
93459: LIST
93460: LIST
93461: PUSH
93462: LD_INT 0
93464: PUSH
93465: LD_INT 1
93467: PUSH
93468: EMPTY
93469: LIST
93470: LIST
93471: PUSH
93472: LD_INT 1
93474: NEG
93475: PUSH
93476: LD_INT 0
93478: PUSH
93479: EMPTY
93480: LIST
93481: LIST
93482: PUSH
93483: LD_INT 1
93485: NEG
93486: PUSH
93487: LD_INT 1
93489: NEG
93490: PUSH
93491: EMPTY
93492: LIST
93493: LIST
93494: PUSH
93495: LD_INT 2
93497: PUSH
93498: LD_INT 1
93500: PUSH
93501: EMPTY
93502: LIST
93503: LIST
93504: PUSH
93505: LD_INT 2
93507: PUSH
93508: LD_INT 2
93510: PUSH
93511: EMPTY
93512: LIST
93513: LIST
93514: PUSH
93515: LD_INT 1
93517: PUSH
93518: LD_INT 2
93520: PUSH
93521: EMPTY
93522: LIST
93523: LIST
93524: PUSH
93525: LD_INT 0
93527: PUSH
93528: LD_INT 2
93530: PUSH
93531: EMPTY
93532: LIST
93533: LIST
93534: PUSH
93535: LD_INT 1
93537: NEG
93538: PUSH
93539: LD_INT 1
93541: PUSH
93542: EMPTY
93543: LIST
93544: LIST
93545: PUSH
93546: EMPTY
93547: LIST
93548: LIST
93549: LIST
93550: LIST
93551: LIST
93552: LIST
93553: LIST
93554: LIST
93555: LIST
93556: LIST
93557: LIST
93558: LIST
93559: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
93560: LD_ADDR_VAR 0 51
93564: PUSH
93565: LD_INT 0
93567: PUSH
93568: LD_INT 0
93570: PUSH
93571: EMPTY
93572: LIST
93573: LIST
93574: PUSH
93575: LD_INT 0
93577: PUSH
93578: LD_INT 1
93580: NEG
93581: PUSH
93582: EMPTY
93583: LIST
93584: LIST
93585: PUSH
93586: LD_INT 1
93588: PUSH
93589: LD_INT 0
93591: PUSH
93592: EMPTY
93593: LIST
93594: LIST
93595: PUSH
93596: LD_INT 1
93598: PUSH
93599: LD_INT 1
93601: PUSH
93602: EMPTY
93603: LIST
93604: LIST
93605: PUSH
93606: LD_INT 0
93608: PUSH
93609: LD_INT 1
93611: PUSH
93612: EMPTY
93613: LIST
93614: LIST
93615: PUSH
93616: LD_INT 1
93618: NEG
93619: PUSH
93620: LD_INT 0
93622: PUSH
93623: EMPTY
93624: LIST
93625: LIST
93626: PUSH
93627: LD_INT 1
93629: NEG
93630: PUSH
93631: LD_INT 1
93633: NEG
93634: PUSH
93635: EMPTY
93636: LIST
93637: LIST
93638: PUSH
93639: LD_INT 1
93641: PUSH
93642: LD_INT 2
93644: PUSH
93645: EMPTY
93646: LIST
93647: LIST
93648: PUSH
93649: LD_INT 0
93651: PUSH
93652: LD_INT 2
93654: PUSH
93655: EMPTY
93656: LIST
93657: LIST
93658: PUSH
93659: LD_INT 1
93661: NEG
93662: PUSH
93663: LD_INT 1
93665: PUSH
93666: EMPTY
93667: LIST
93668: LIST
93669: PUSH
93670: LD_INT 2
93672: NEG
93673: PUSH
93674: LD_INT 0
93676: PUSH
93677: EMPTY
93678: LIST
93679: LIST
93680: PUSH
93681: LD_INT 2
93683: NEG
93684: PUSH
93685: LD_INT 1
93687: NEG
93688: PUSH
93689: EMPTY
93690: LIST
93691: LIST
93692: PUSH
93693: EMPTY
93694: LIST
93695: LIST
93696: LIST
93697: LIST
93698: LIST
93699: LIST
93700: LIST
93701: LIST
93702: LIST
93703: LIST
93704: LIST
93705: LIST
93706: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93707: LD_ADDR_VAR 0 52
93711: PUSH
93712: LD_INT 0
93714: PUSH
93715: LD_INT 0
93717: PUSH
93718: EMPTY
93719: LIST
93720: LIST
93721: PUSH
93722: LD_INT 0
93724: PUSH
93725: LD_INT 1
93727: NEG
93728: PUSH
93729: EMPTY
93730: LIST
93731: LIST
93732: PUSH
93733: LD_INT 1
93735: PUSH
93736: LD_INT 0
93738: PUSH
93739: EMPTY
93740: LIST
93741: LIST
93742: PUSH
93743: LD_INT 1
93745: PUSH
93746: LD_INT 1
93748: PUSH
93749: EMPTY
93750: LIST
93751: LIST
93752: PUSH
93753: LD_INT 0
93755: PUSH
93756: LD_INT 1
93758: PUSH
93759: EMPTY
93760: LIST
93761: LIST
93762: PUSH
93763: LD_INT 1
93765: NEG
93766: PUSH
93767: LD_INT 0
93769: PUSH
93770: EMPTY
93771: LIST
93772: LIST
93773: PUSH
93774: LD_INT 1
93776: NEG
93777: PUSH
93778: LD_INT 1
93780: NEG
93781: PUSH
93782: EMPTY
93783: LIST
93784: LIST
93785: PUSH
93786: LD_INT 1
93788: NEG
93789: PUSH
93790: LD_INT 2
93792: NEG
93793: PUSH
93794: EMPTY
93795: LIST
93796: LIST
93797: PUSH
93798: LD_INT 1
93800: NEG
93801: PUSH
93802: LD_INT 1
93804: PUSH
93805: EMPTY
93806: LIST
93807: LIST
93808: PUSH
93809: LD_INT 2
93811: NEG
93812: PUSH
93813: LD_INT 0
93815: PUSH
93816: EMPTY
93817: LIST
93818: LIST
93819: PUSH
93820: LD_INT 2
93822: NEG
93823: PUSH
93824: LD_INT 1
93826: NEG
93827: PUSH
93828: EMPTY
93829: LIST
93830: LIST
93831: PUSH
93832: LD_INT 2
93834: NEG
93835: PUSH
93836: LD_INT 2
93838: NEG
93839: PUSH
93840: EMPTY
93841: LIST
93842: LIST
93843: PUSH
93844: EMPTY
93845: LIST
93846: LIST
93847: LIST
93848: LIST
93849: LIST
93850: LIST
93851: LIST
93852: LIST
93853: LIST
93854: LIST
93855: LIST
93856: LIST
93857: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93858: LD_ADDR_VAR 0 53
93862: PUSH
93863: LD_INT 0
93865: PUSH
93866: LD_INT 0
93868: PUSH
93869: EMPTY
93870: LIST
93871: LIST
93872: PUSH
93873: LD_INT 0
93875: PUSH
93876: LD_INT 1
93878: NEG
93879: PUSH
93880: EMPTY
93881: LIST
93882: LIST
93883: PUSH
93884: LD_INT 1
93886: PUSH
93887: LD_INT 0
93889: PUSH
93890: EMPTY
93891: LIST
93892: LIST
93893: PUSH
93894: LD_INT 1
93896: PUSH
93897: LD_INT 1
93899: PUSH
93900: EMPTY
93901: LIST
93902: LIST
93903: PUSH
93904: LD_INT 0
93906: PUSH
93907: LD_INT 1
93909: PUSH
93910: EMPTY
93911: LIST
93912: LIST
93913: PUSH
93914: LD_INT 1
93916: NEG
93917: PUSH
93918: LD_INT 0
93920: PUSH
93921: EMPTY
93922: LIST
93923: LIST
93924: PUSH
93925: LD_INT 1
93927: NEG
93928: PUSH
93929: LD_INT 1
93931: NEG
93932: PUSH
93933: EMPTY
93934: LIST
93935: LIST
93936: PUSH
93937: LD_INT 1
93939: NEG
93940: PUSH
93941: LD_INT 2
93943: NEG
93944: PUSH
93945: EMPTY
93946: LIST
93947: LIST
93948: PUSH
93949: LD_INT 0
93951: PUSH
93952: LD_INT 2
93954: NEG
93955: PUSH
93956: EMPTY
93957: LIST
93958: LIST
93959: PUSH
93960: LD_INT 1
93962: PUSH
93963: LD_INT 1
93965: NEG
93966: PUSH
93967: EMPTY
93968: LIST
93969: LIST
93970: PUSH
93971: LD_INT 2
93973: PUSH
93974: LD_INT 0
93976: PUSH
93977: EMPTY
93978: LIST
93979: LIST
93980: PUSH
93981: LD_INT 2
93983: PUSH
93984: LD_INT 1
93986: PUSH
93987: EMPTY
93988: LIST
93989: LIST
93990: PUSH
93991: LD_INT 2
93993: PUSH
93994: LD_INT 2
93996: PUSH
93997: EMPTY
93998: LIST
93999: LIST
94000: PUSH
94001: LD_INT 1
94003: PUSH
94004: LD_INT 2
94006: PUSH
94007: EMPTY
94008: LIST
94009: LIST
94010: PUSH
94011: LD_INT 0
94013: PUSH
94014: LD_INT 2
94016: PUSH
94017: EMPTY
94018: LIST
94019: LIST
94020: PUSH
94021: LD_INT 1
94023: NEG
94024: PUSH
94025: LD_INT 1
94027: PUSH
94028: EMPTY
94029: LIST
94030: LIST
94031: PUSH
94032: LD_INT 2
94034: NEG
94035: PUSH
94036: LD_INT 0
94038: PUSH
94039: EMPTY
94040: LIST
94041: LIST
94042: PUSH
94043: LD_INT 2
94045: NEG
94046: PUSH
94047: LD_INT 1
94049: NEG
94050: PUSH
94051: EMPTY
94052: LIST
94053: LIST
94054: PUSH
94055: LD_INT 2
94057: NEG
94058: PUSH
94059: LD_INT 2
94061: NEG
94062: PUSH
94063: EMPTY
94064: LIST
94065: LIST
94066: PUSH
94067: EMPTY
94068: LIST
94069: LIST
94070: LIST
94071: LIST
94072: LIST
94073: LIST
94074: LIST
94075: LIST
94076: LIST
94077: LIST
94078: LIST
94079: LIST
94080: LIST
94081: LIST
94082: LIST
94083: LIST
94084: LIST
94085: LIST
94086: LIST
94087: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94088: LD_ADDR_VAR 0 54
94092: PUSH
94093: LD_INT 0
94095: PUSH
94096: LD_INT 0
94098: PUSH
94099: EMPTY
94100: LIST
94101: LIST
94102: PUSH
94103: LD_INT 0
94105: PUSH
94106: LD_INT 1
94108: NEG
94109: PUSH
94110: EMPTY
94111: LIST
94112: LIST
94113: PUSH
94114: LD_INT 1
94116: PUSH
94117: LD_INT 0
94119: PUSH
94120: EMPTY
94121: LIST
94122: LIST
94123: PUSH
94124: LD_INT 1
94126: PUSH
94127: LD_INT 1
94129: PUSH
94130: EMPTY
94131: LIST
94132: LIST
94133: PUSH
94134: LD_INT 0
94136: PUSH
94137: LD_INT 1
94139: PUSH
94140: EMPTY
94141: LIST
94142: LIST
94143: PUSH
94144: LD_INT 1
94146: NEG
94147: PUSH
94148: LD_INT 0
94150: PUSH
94151: EMPTY
94152: LIST
94153: LIST
94154: PUSH
94155: LD_INT 1
94157: NEG
94158: PUSH
94159: LD_INT 1
94161: NEG
94162: PUSH
94163: EMPTY
94164: LIST
94165: LIST
94166: PUSH
94167: LD_INT 1
94169: NEG
94170: PUSH
94171: LD_INT 2
94173: NEG
94174: PUSH
94175: EMPTY
94176: LIST
94177: LIST
94178: PUSH
94179: LD_INT 0
94181: PUSH
94182: LD_INT 2
94184: NEG
94185: PUSH
94186: EMPTY
94187: LIST
94188: LIST
94189: PUSH
94190: LD_INT 1
94192: PUSH
94193: LD_INT 1
94195: NEG
94196: PUSH
94197: EMPTY
94198: LIST
94199: LIST
94200: PUSH
94201: LD_INT 2
94203: PUSH
94204: LD_INT 0
94206: PUSH
94207: EMPTY
94208: LIST
94209: LIST
94210: PUSH
94211: LD_INT 2
94213: PUSH
94214: LD_INT 1
94216: PUSH
94217: EMPTY
94218: LIST
94219: LIST
94220: PUSH
94221: LD_INT 2
94223: PUSH
94224: LD_INT 2
94226: PUSH
94227: EMPTY
94228: LIST
94229: LIST
94230: PUSH
94231: LD_INT 1
94233: PUSH
94234: LD_INT 2
94236: PUSH
94237: EMPTY
94238: LIST
94239: LIST
94240: PUSH
94241: LD_INT 0
94243: PUSH
94244: LD_INT 2
94246: PUSH
94247: EMPTY
94248: LIST
94249: LIST
94250: PUSH
94251: LD_INT 1
94253: NEG
94254: PUSH
94255: LD_INT 1
94257: PUSH
94258: EMPTY
94259: LIST
94260: LIST
94261: PUSH
94262: LD_INT 2
94264: NEG
94265: PUSH
94266: LD_INT 0
94268: PUSH
94269: EMPTY
94270: LIST
94271: LIST
94272: PUSH
94273: LD_INT 2
94275: NEG
94276: PUSH
94277: LD_INT 1
94279: NEG
94280: PUSH
94281: EMPTY
94282: LIST
94283: LIST
94284: PUSH
94285: LD_INT 2
94287: NEG
94288: PUSH
94289: LD_INT 2
94291: NEG
94292: PUSH
94293: EMPTY
94294: LIST
94295: LIST
94296: PUSH
94297: EMPTY
94298: LIST
94299: LIST
94300: LIST
94301: LIST
94302: LIST
94303: LIST
94304: LIST
94305: LIST
94306: LIST
94307: LIST
94308: LIST
94309: LIST
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94318: LD_ADDR_VAR 0 55
94322: PUSH
94323: LD_INT 0
94325: PUSH
94326: LD_INT 0
94328: PUSH
94329: EMPTY
94330: LIST
94331: LIST
94332: PUSH
94333: LD_INT 0
94335: PUSH
94336: LD_INT 1
94338: NEG
94339: PUSH
94340: EMPTY
94341: LIST
94342: LIST
94343: PUSH
94344: LD_INT 1
94346: PUSH
94347: LD_INT 0
94349: PUSH
94350: EMPTY
94351: LIST
94352: LIST
94353: PUSH
94354: LD_INT 1
94356: PUSH
94357: LD_INT 1
94359: PUSH
94360: EMPTY
94361: LIST
94362: LIST
94363: PUSH
94364: LD_INT 0
94366: PUSH
94367: LD_INT 1
94369: PUSH
94370: EMPTY
94371: LIST
94372: LIST
94373: PUSH
94374: LD_INT 1
94376: NEG
94377: PUSH
94378: LD_INT 0
94380: PUSH
94381: EMPTY
94382: LIST
94383: LIST
94384: PUSH
94385: LD_INT 1
94387: NEG
94388: PUSH
94389: LD_INT 1
94391: NEG
94392: PUSH
94393: EMPTY
94394: LIST
94395: LIST
94396: PUSH
94397: LD_INT 1
94399: NEG
94400: PUSH
94401: LD_INT 2
94403: NEG
94404: PUSH
94405: EMPTY
94406: LIST
94407: LIST
94408: PUSH
94409: LD_INT 0
94411: PUSH
94412: LD_INT 2
94414: NEG
94415: PUSH
94416: EMPTY
94417: LIST
94418: LIST
94419: PUSH
94420: LD_INT 1
94422: PUSH
94423: LD_INT 1
94425: NEG
94426: PUSH
94427: EMPTY
94428: LIST
94429: LIST
94430: PUSH
94431: LD_INT 2
94433: PUSH
94434: LD_INT 0
94436: PUSH
94437: EMPTY
94438: LIST
94439: LIST
94440: PUSH
94441: LD_INT 2
94443: PUSH
94444: LD_INT 1
94446: PUSH
94447: EMPTY
94448: LIST
94449: LIST
94450: PUSH
94451: LD_INT 2
94453: PUSH
94454: LD_INT 2
94456: PUSH
94457: EMPTY
94458: LIST
94459: LIST
94460: PUSH
94461: LD_INT 1
94463: PUSH
94464: LD_INT 2
94466: PUSH
94467: EMPTY
94468: LIST
94469: LIST
94470: PUSH
94471: LD_INT 0
94473: PUSH
94474: LD_INT 2
94476: PUSH
94477: EMPTY
94478: LIST
94479: LIST
94480: PUSH
94481: LD_INT 1
94483: NEG
94484: PUSH
94485: LD_INT 1
94487: PUSH
94488: EMPTY
94489: LIST
94490: LIST
94491: PUSH
94492: LD_INT 2
94494: NEG
94495: PUSH
94496: LD_INT 0
94498: PUSH
94499: EMPTY
94500: LIST
94501: LIST
94502: PUSH
94503: LD_INT 2
94505: NEG
94506: PUSH
94507: LD_INT 1
94509: NEG
94510: PUSH
94511: EMPTY
94512: LIST
94513: LIST
94514: PUSH
94515: LD_INT 2
94517: NEG
94518: PUSH
94519: LD_INT 2
94521: NEG
94522: PUSH
94523: EMPTY
94524: LIST
94525: LIST
94526: PUSH
94527: EMPTY
94528: LIST
94529: LIST
94530: LIST
94531: LIST
94532: LIST
94533: LIST
94534: LIST
94535: LIST
94536: LIST
94537: LIST
94538: LIST
94539: LIST
94540: LIST
94541: LIST
94542: LIST
94543: LIST
94544: LIST
94545: LIST
94546: LIST
94547: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94548: LD_ADDR_VAR 0 56
94552: PUSH
94553: LD_INT 0
94555: PUSH
94556: LD_INT 0
94558: PUSH
94559: EMPTY
94560: LIST
94561: LIST
94562: PUSH
94563: LD_INT 0
94565: PUSH
94566: LD_INT 1
94568: NEG
94569: PUSH
94570: EMPTY
94571: LIST
94572: LIST
94573: PUSH
94574: LD_INT 1
94576: PUSH
94577: LD_INT 0
94579: PUSH
94580: EMPTY
94581: LIST
94582: LIST
94583: PUSH
94584: LD_INT 1
94586: PUSH
94587: LD_INT 1
94589: PUSH
94590: EMPTY
94591: LIST
94592: LIST
94593: PUSH
94594: LD_INT 0
94596: PUSH
94597: LD_INT 1
94599: PUSH
94600: EMPTY
94601: LIST
94602: LIST
94603: PUSH
94604: LD_INT 1
94606: NEG
94607: PUSH
94608: LD_INT 0
94610: PUSH
94611: EMPTY
94612: LIST
94613: LIST
94614: PUSH
94615: LD_INT 1
94617: NEG
94618: PUSH
94619: LD_INT 1
94621: NEG
94622: PUSH
94623: EMPTY
94624: LIST
94625: LIST
94626: PUSH
94627: LD_INT 1
94629: NEG
94630: PUSH
94631: LD_INT 2
94633: NEG
94634: PUSH
94635: EMPTY
94636: LIST
94637: LIST
94638: PUSH
94639: LD_INT 0
94641: PUSH
94642: LD_INT 2
94644: NEG
94645: PUSH
94646: EMPTY
94647: LIST
94648: LIST
94649: PUSH
94650: LD_INT 1
94652: PUSH
94653: LD_INT 1
94655: NEG
94656: PUSH
94657: EMPTY
94658: LIST
94659: LIST
94660: PUSH
94661: LD_INT 2
94663: PUSH
94664: LD_INT 0
94666: PUSH
94667: EMPTY
94668: LIST
94669: LIST
94670: PUSH
94671: LD_INT 2
94673: PUSH
94674: LD_INT 1
94676: PUSH
94677: EMPTY
94678: LIST
94679: LIST
94680: PUSH
94681: LD_INT 2
94683: PUSH
94684: LD_INT 2
94686: PUSH
94687: EMPTY
94688: LIST
94689: LIST
94690: PUSH
94691: LD_INT 1
94693: PUSH
94694: LD_INT 2
94696: PUSH
94697: EMPTY
94698: LIST
94699: LIST
94700: PUSH
94701: LD_INT 0
94703: PUSH
94704: LD_INT 2
94706: PUSH
94707: EMPTY
94708: LIST
94709: LIST
94710: PUSH
94711: LD_INT 1
94713: NEG
94714: PUSH
94715: LD_INT 1
94717: PUSH
94718: EMPTY
94719: LIST
94720: LIST
94721: PUSH
94722: LD_INT 2
94724: NEG
94725: PUSH
94726: LD_INT 0
94728: PUSH
94729: EMPTY
94730: LIST
94731: LIST
94732: PUSH
94733: LD_INT 2
94735: NEG
94736: PUSH
94737: LD_INT 1
94739: NEG
94740: PUSH
94741: EMPTY
94742: LIST
94743: LIST
94744: PUSH
94745: LD_INT 2
94747: NEG
94748: PUSH
94749: LD_INT 2
94751: NEG
94752: PUSH
94753: EMPTY
94754: LIST
94755: LIST
94756: PUSH
94757: EMPTY
94758: LIST
94759: LIST
94760: LIST
94761: LIST
94762: LIST
94763: LIST
94764: LIST
94765: LIST
94766: LIST
94767: LIST
94768: LIST
94769: LIST
94770: LIST
94771: LIST
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94778: LD_ADDR_VAR 0 57
94782: PUSH
94783: LD_INT 0
94785: PUSH
94786: LD_INT 0
94788: PUSH
94789: EMPTY
94790: LIST
94791: LIST
94792: PUSH
94793: LD_INT 0
94795: PUSH
94796: LD_INT 1
94798: NEG
94799: PUSH
94800: EMPTY
94801: LIST
94802: LIST
94803: PUSH
94804: LD_INT 1
94806: PUSH
94807: LD_INT 0
94809: PUSH
94810: EMPTY
94811: LIST
94812: LIST
94813: PUSH
94814: LD_INT 1
94816: PUSH
94817: LD_INT 1
94819: PUSH
94820: EMPTY
94821: LIST
94822: LIST
94823: PUSH
94824: LD_INT 0
94826: PUSH
94827: LD_INT 1
94829: PUSH
94830: EMPTY
94831: LIST
94832: LIST
94833: PUSH
94834: LD_INT 1
94836: NEG
94837: PUSH
94838: LD_INT 0
94840: PUSH
94841: EMPTY
94842: LIST
94843: LIST
94844: PUSH
94845: LD_INT 1
94847: NEG
94848: PUSH
94849: LD_INT 1
94851: NEG
94852: PUSH
94853: EMPTY
94854: LIST
94855: LIST
94856: PUSH
94857: LD_INT 1
94859: NEG
94860: PUSH
94861: LD_INT 2
94863: NEG
94864: PUSH
94865: EMPTY
94866: LIST
94867: LIST
94868: PUSH
94869: LD_INT 0
94871: PUSH
94872: LD_INT 2
94874: NEG
94875: PUSH
94876: EMPTY
94877: LIST
94878: LIST
94879: PUSH
94880: LD_INT 1
94882: PUSH
94883: LD_INT 1
94885: NEG
94886: PUSH
94887: EMPTY
94888: LIST
94889: LIST
94890: PUSH
94891: LD_INT 2
94893: PUSH
94894: LD_INT 0
94896: PUSH
94897: EMPTY
94898: LIST
94899: LIST
94900: PUSH
94901: LD_INT 2
94903: PUSH
94904: LD_INT 1
94906: PUSH
94907: EMPTY
94908: LIST
94909: LIST
94910: PUSH
94911: LD_INT 2
94913: PUSH
94914: LD_INT 2
94916: PUSH
94917: EMPTY
94918: LIST
94919: LIST
94920: PUSH
94921: LD_INT 1
94923: PUSH
94924: LD_INT 2
94926: PUSH
94927: EMPTY
94928: LIST
94929: LIST
94930: PUSH
94931: LD_INT 0
94933: PUSH
94934: LD_INT 2
94936: PUSH
94937: EMPTY
94938: LIST
94939: LIST
94940: PUSH
94941: LD_INT 1
94943: NEG
94944: PUSH
94945: LD_INT 1
94947: PUSH
94948: EMPTY
94949: LIST
94950: LIST
94951: PUSH
94952: LD_INT 2
94954: NEG
94955: PUSH
94956: LD_INT 0
94958: PUSH
94959: EMPTY
94960: LIST
94961: LIST
94962: PUSH
94963: LD_INT 2
94965: NEG
94966: PUSH
94967: LD_INT 1
94969: NEG
94970: PUSH
94971: EMPTY
94972: LIST
94973: LIST
94974: PUSH
94975: LD_INT 2
94977: NEG
94978: PUSH
94979: LD_INT 2
94981: NEG
94982: PUSH
94983: EMPTY
94984: LIST
94985: LIST
94986: PUSH
94987: EMPTY
94988: LIST
94989: LIST
94990: LIST
94991: LIST
94992: LIST
94993: LIST
94994: LIST
94995: LIST
94996: LIST
94997: LIST
94998: LIST
94999: LIST
95000: LIST
95001: LIST
95002: LIST
95003: LIST
95004: LIST
95005: LIST
95006: LIST
95007: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95008: LD_ADDR_VAR 0 58
95012: PUSH
95013: LD_INT 0
95015: PUSH
95016: LD_INT 0
95018: PUSH
95019: EMPTY
95020: LIST
95021: LIST
95022: PUSH
95023: LD_INT 0
95025: PUSH
95026: LD_INT 1
95028: NEG
95029: PUSH
95030: EMPTY
95031: LIST
95032: LIST
95033: PUSH
95034: LD_INT 1
95036: PUSH
95037: LD_INT 0
95039: PUSH
95040: EMPTY
95041: LIST
95042: LIST
95043: PUSH
95044: LD_INT 1
95046: PUSH
95047: LD_INT 1
95049: PUSH
95050: EMPTY
95051: LIST
95052: LIST
95053: PUSH
95054: LD_INT 0
95056: PUSH
95057: LD_INT 1
95059: PUSH
95060: EMPTY
95061: LIST
95062: LIST
95063: PUSH
95064: LD_INT 1
95066: NEG
95067: PUSH
95068: LD_INT 0
95070: PUSH
95071: EMPTY
95072: LIST
95073: LIST
95074: PUSH
95075: LD_INT 1
95077: NEG
95078: PUSH
95079: LD_INT 1
95081: NEG
95082: PUSH
95083: EMPTY
95084: LIST
95085: LIST
95086: PUSH
95087: LD_INT 1
95089: NEG
95090: PUSH
95091: LD_INT 2
95093: NEG
95094: PUSH
95095: EMPTY
95096: LIST
95097: LIST
95098: PUSH
95099: LD_INT 0
95101: PUSH
95102: LD_INT 2
95104: NEG
95105: PUSH
95106: EMPTY
95107: LIST
95108: LIST
95109: PUSH
95110: LD_INT 1
95112: PUSH
95113: LD_INT 1
95115: NEG
95116: PUSH
95117: EMPTY
95118: LIST
95119: LIST
95120: PUSH
95121: LD_INT 2
95123: PUSH
95124: LD_INT 0
95126: PUSH
95127: EMPTY
95128: LIST
95129: LIST
95130: PUSH
95131: LD_INT 2
95133: PUSH
95134: LD_INT 1
95136: PUSH
95137: EMPTY
95138: LIST
95139: LIST
95140: PUSH
95141: LD_INT 2
95143: PUSH
95144: LD_INT 2
95146: PUSH
95147: EMPTY
95148: LIST
95149: LIST
95150: PUSH
95151: LD_INT 1
95153: PUSH
95154: LD_INT 2
95156: PUSH
95157: EMPTY
95158: LIST
95159: LIST
95160: PUSH
95161: LD_INT 0
95163: PUSH
95164: LD_INT 2
95166: PUSH
95167: EMPTY
95168: LIST
95169: LIST
95170: PUSH
95171: LD_INT 1
95173: NEG
95174: PUSH
95175: LD_INT 1
95177: PUSH
95178: EMPTY
95179: LIST
95180: LIST
95181: PUSH
95182: LD_INT 2
95184: NEG
95185: PUSH
95186: LD_INT 0
95188: PUSH
95189: EMPTY
95190: LIST
95191: LIST
95192: PUSH
95193: LD_INT 2
95195: NEG
95196: PUSH
95197: LD_INT 1
95199: NEG
95200: PUSH
95201: EMPTY
95202: LIST
95203: LIST
95204: PUSH
95205: LD_INT 2
95207: NEG
95208: PUSH
95209: LD_INT 2
95211: NEG
95212: PUSH
95213: EMPTY
95214: LIST
95215: LIST
95216: PUSH
95217: EMPTY
95218: LIST
95219: LIST
95220: LIST
95221: LIST
95222: LIST
95223: LIST
95224: LIST
95225: LIST
95226: LIST
95227: LIST
95228: LIST
95229: LIST
95230: LIST
95231: LIST
95232: LIST
95233: LIST
95234: LIST
95235: LIST
95236: LIST
95237: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95238: LD_ADDR_VAR 0 59
95242: PUSH
95243: LD_INT 0
95245: PUSH
95246: LD_INT 0
95248: PUSH
95249: EMPTY
95250: LIST
95251: LIST
95252: PUSH
95253: LD_INT 0
95255: PUSH
95256: LD_INT 1
95258: NEG
95259: PUSH
95260: EMPTY
95261: LIST
95262: LIST
95263: PUSH
95264: LD_INT 1
95266: PUSH
95267: LD_INT 0
95269: PUSH
95270: EMPTY
95271: LIST
95272: LIST
95273: PUSH
95274: LD_INT 1
95276: PUSH
95277: LD_INT 1
95279: PUSH
95280: EMPTY
95281: LIST
95282: LIST
95283: PUSH
95284: LD_INT 0
95286: PUSH
95287: LD_INT 1
95289: PUSH
95290: EMPTY
95291: LIST
95292: LIST
95293: PUSH
95294: LD_INT 1
95296: NEG
95297: PUSH
95298: LD_INT 0
95300: PUSH
95301: EMPTY
95302: LIST
95303: LIST
95304: PUSH
95305: LD_INT 1
95307: NEG
95308: PUSH
95309: LD_INT 1
95311: NEG
95312: PUSH
95313: EMPTY
95314: LIST
95315: LIST
95316: PUSH
95317: EMPTY
95318: LIST
95319: LIST
95320: LIST
95321: LIST
95322: LIST
95323: LIST
95324: LIST
95325: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95326: LD_ADDR_VAR 0 60
95330: PUSH
95331: LD_INT 0
95333: PUSH
95334: LD_INT 0
95336: PUSH
95337: EMPTY
95338: LIST
95339: LIST
95340: PUSH
95341: LD_INT 0
95343: PUSH
95344: LD_INT 1
95346: NEG
95347: PUSH
95348: EMPTY
95349: LIST
95350: LIST
95351: PUSH
95352: LD_INT 1
95354: PUSH
95355: LD_INT 0
95357: PUSH
95358: EMPTY
95359: LIST
95360: LIST
95361: PUSH
95362: LD_INT 1
95364: PUSH
95365: LD_INT 1
95367: PUSH
95368: EMPTY
95369: LIST
95370: LIST
95371: PUSH
95372: LD_INT 0
95374: PUSH
95375: LD_INT 1
95377: PUSH
95378: EMPTY
95379: LIST
95380: LIST
95381: PUSH
95382: LD_INT 1
95384: NEG
95385: PUSH
95386: LD_INT 0
95388: PUSH
95389: EMPTY
95390: LIST
95391: LIST
95392: PUSH
95393: LD_INT 1
95395: NEG
95396: PUSH
95397: LD_INT 1
95399: NEG
95400: PUSH
95401: EMPTY
95402: LIST
95403: LIST
95404: PUSH
95405: EMPTY
95406: LIST
95407: LIST
95408: LIST
95409: LIST
95410: LIST
95411: LIST
95412: LIST
95413: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95414: LD_ADDR_VAR 0 61
95418: PUSH
95419: LD_INT 0
95421: PUSH
95422: LD_INT 0
95424: PUSH
95425: EMPTY
95426: LIST
95427: LIST
95428: PUSH
95429: LD_INT 0
95431: PUSH
95432: LD_INT 1
95434: NEG
95435: PUSH
95436: EMPTY
95437: LIST
95438: LIST
95439: PUSH
95440: LD_INT 1
95442: PUSH
95443: LD_INT 0
95445: PUSH
95446: EMPTY
95447: LIST
95448: LIST
95449: PUSH
95450: LD_INT 1
95452: PUSH
95453: LD_INT 1
95455: PUSH
95456: EMPTY
95457: LIST
95458: LIST
95459: PUSH
95460: LD_INT 0
95462: PUSH
95463: LD_INT 1
95465: PUSH
95466: EMPTY
95467: LIST
95468: LIST
95469: PUSH
95470: LD_INT 1
95472: NEG
95473: PUSH
95474: LD_INT 0
95476: PUSH
95477: EMPTY
95478: LIST
95479: LIST
95480: PUSH
95481: LD_INT 1
95483: NEG
95484: PUSH
95485: LD_INT 1
95487: NEG
95488: PUSH
95489: EMPTY
95490: LIST
95491: LIST
95492: PUSH
95493: EMPTY
95494: LIST
95495: LIST
95496: LIST
95497: LIST
95498: LIST
95499: LIST
95500: LIST
95501: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95502: LD_ADDR_VAR 0 62
95506: PUSH
95507: LD_INT 0
95509: PUSH
95510: LD_INT 0
95512: PUSH
95513: EMPTY
95514: LIST
95515: LIST
95516: PUSH
95517: LD_INT 0
95519: PUSH
95520: LD_INT 1
95522: NEG
95523: PUSH
95524: EMPTY
95525: LIST
95526: LIST
95527: PUSH
95528: LD_INT 1
95530: PUSH
95531: LD_INT 0
95533: PUSH
95534: EMPTY
95535: LIST
95536: LIST
95537: PUSH
95538: LD_INT 1
95540: PUSH
95541: LD_INT 1
95543: PUSH
95544: EMPTY
95545: LIST
95546: LIST
95547: PUSH
95548: LD_INT 0
95550: PUSH
95551: LD_INT 1
95553: PUSH
95554: EMPTY
95555: LIST
95556: LIST
95557: PUSH
95558: LD_INT 1
95560: NEG
95561: PUSH
95562: LD_INT 0
95564: PUSH
95565: EMPTY
95566: LIST
95567: LIST
95568: PUSH
95569: LD_INT 1
95571: NEG
95572: PUSH
95573: LD_INT 1
95575: NEG
95576: PUSH
95577: EMPTY
95578: LIST
95579: LIST
95580: PUSH
95581: EMPTY
95582: LIST
95583: LIST
95584: LIST
95585: LIST
95586: LIST
95587: LIST
95588: LIST
95589: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95590: LD_ADDR_VAR 0 63
95594: PUSH
95595: LD_INT 0
95597: PUSH
95598: LD_INT 0
95600: PUSH
95601: EMPTY
95602: LIST
95603: LIST
95604: PUSH
95605: LD_INT 0
95607: PUSH
95608: LD_INT 1
95610: NEG
95611: PUSH
95612: EMPTY
95613: LIST
95614: LIST
95615: PUSH
95616: LD_INT 1
95618: PUSH
95619: LD_INT 0
95621: PUSH
95622: EMPTY
95623: LIST
95624: LIST
95625: PUSH
95626: LD_INT 1
95628: PUSH
95629: LD_INT 1
95631: PUSH
95632: EMPTY
95633: LIST
95634: LIST
95635: PUSH
95636: LD_INT 0
95638: PUSH
95639: LD_INT 1
95641: PUSH
95642: EMPTY
95643: LIST
95644: LIST
95645: PUSH
95646: LD_INT 1
95648: NEG
95649: PUSH
95650: LD_INT 0
95652: PUSH
95653: EMPTY
95654: LIST
95655: LIST
95656: PUSH
95657: LD_INT 1
95659: NEG
95660: PUSH
95661: LD_INT 1
95663: NEG
95664: PUSH
95665: EMPTY
95666: LIST
95667: LIST
95668: PUSH
95669: EMPTY
95670: LIST
95671: LIST
95672: LIST
95673: LIST
95674: LIST
95675: LIST
95676: LIST
95677: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95678: LD_ADDR_VAR 0 64
95682: PUSH
95683: LD_INT 0
95685: PUSH
95686: LD_INT 0
95688: PUSH
95689: EMPTY
95690: LIST
95691: LIST
95692: PUSH
95693: LD_INT 0
95695: PUSH
95696: LD_INT 1
95698: NEG
95699: PUSH
95700: EMPTY
95701: LIST
95702: LIST
95703: PUSH
95704: LD_INT 1
95706: PUSH
95707: LD_INT 0
95709: PUSH
95710: EMPTY
95711: LIST
95712: LIST
95713: PUSH
95714: LD_INT 1
95716: PUSH
95717: LD_INT 1
95719: PUSH
95720: EMPTY
95721: LIST
95722: LIST
95723: PUSH
95724: LD_INT 0
95726: PUSH
95727: LD_INT 1
95729: PUSH
95730: EMPTY
95731: LIST
95732: LIST
95733: PUSH
95734: LD_INT 1
95736: NEG
95737: PUSH
95738: LD_INT 0
95740: PUSH
95741: EMPTY
95742: LIST
95743: LIST
95744: PUSH
95745: LD_INT 1
95747: NEG
95748: PUSH
95749: LD_INT 1
95751: NEG
95752: PUSH
95753: EMPTY
95754: LIST
95755: LIST
95756: PUSH
95757: EMPTY
95758: LIST
95759: LIST
95760: LIST
95761: LIST
95762: LIST
95763: LIST
95764: LIST
95765: ST_TO_ADDR
// end ; 1 :
95766: GO 101663
95768: LD_INT 1
95770: DOUBLE
95771: EQUAL
95772: IFTRUE 95776
95774: GO 98399
95776: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
95777: LD_ADDR_VAR 0 11
95781: PUSH
95782: LD_INT 1
95784: NEG
95785: PUSH
95786: LD_INT 3
95788: NEG
95789: PUSH
95790: EMPTY
95791: LIST
95792: LIST
95793: PUSH
95794: LD_INT 0
95796: PUSH
95797: LD_INT 3
95799: NEG
95800: PUSH
95801: EMPTY
95802: LIST
95803: LIST
95804: PUSH
95805: LD_INT 1
95807: PUSH
95808: LD_INT 2
95810: NEG
95811: PUSH
95812: EMPTY
95813: LIST
95814: LIST
95815: PUSH
95816: EMPTY
95817: LIST
95818: LIST
95819: LIST
95820: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
95821: LD_ADDR_VAR 0 12
95825: PUSH
95826: LD_INT 2
95828: PUSH
95829: LD_INT 1
95831: NEG
95832: PUSH
95833: EMPTY
95834: LIST
95835: LIST
95836: PUSH
95837: LD_INT 3
95839: PUSH
95840: LD_INT 0
95842: PUSH
95843: EMPTY
95844: LIST
95845: LIST
95846: PUSH
95847: LD_INT 3
95849: PUSH
95850: LD_INT 1
95852: PUSH
95853: EMPTY
95854: LIST
95855: LIST
95856: PUSH
95857: EMPTY
95858: LIST
95859: LIST
95860: LIST
95861: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
95862: LD_ADDR_VAR 0 13
95866: PUSH
95867: LD_INT 3
95869: PUSH
95870: LD_INT 2
95872: PUSH
95873: EMPTY
95874: LIST
95875: LIST
95876: PUSH
95877: LD_INT 3
95879: PUSH
95880: LD_INT 3
95882: PUSH
95883: EMPTY
95884: LIST
95885: LIST
95886: PUSH
95887: LD_INT 2
95889: PUSH
95890: LD_INT 3
95892: PUSH
95893: EMPTY
95894: LIST
95895: LIST
95896: PUSH
95897: EMPTY
95898: LIST
95899: LIST
95900: LIST
95901: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
95902: LD_ADDR_VAR 0 14
95906: PUSH
95907: LD_INT 1
95909: PUSH
95910: LD_INT 3
95912: PUSH
95913: EMPTY
95914: LIST
95915: LIST
95916: PUSH
95917: LD_INT 0
95919: PUSH
95920: LD_INT 3
95922: PUSH
95923: EMPTY
95924: LIST
95925: LIST
95926: PUSH
95927: LD_INT 1
95929: NEG
95930: PUSH
95931: LD_INT 2
95933: PUSH
95934: EMPTY
95935: LIST
95936: LIST
95937: PUSH
95938: EMPTY
95939: LIST
95940: LIST
95941: LIST
95942: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
95943: LD_ADDR_VAR 0 15
95947: PUSH
95948: LD_INT 2
95950: NEG
95951: PUSH
95952: LD_INT 1
95954: PUSH
95955: EMPTY
95956: LIST
95957: LIST
95958: PUSH
95959: LD_INT 3
95961: NEG
95962: PUSH
95963: LD_INT 0
95965: PUSH
95966: EMPTY
95967: LIST
95968: LIST
95969: PUSH
95970: LD_INT 3
95972: NEG
95973: PUSH
95974: LD_INT 1
95976: NEG
95977: PUSH
95978: EMPTY
95979: LIST
95980: LIST
95981: PUSH
95982: EMPTY
95983: LIST
95984: LIST
95985: LIST
95986: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
95987: LD_ADDR_VAR 0 16
95991: PUSH
95992: LD_INT 2
95994: NEG
95995: PUSH
95996: LD_INT 3
95998: NEG
95999: PUSH
96000: EMPTY
96001: LIST
96002: LIST
96003: PUSH
96004: LD_INT 3
96006: NEG
96007: PUSH
96008: LD_INT 2
96010: NEG
96011: PUSH
96012: EMPTY
96013: LIST
96014: LIST
96015: PUSH
96016: LD_INT 3
96018: NEG
96019: PUSH
96020: LD_INT 3
96022: NEG
96023: PUSH
96024: EMPTY
96025: LIST
96026: LIST
96027: PUSH
96028: EMPTY
96029: LIST
96030: LIST
96031: LIST
96032: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
96033: LD_ADDR_VAR 0 17
96037: PUSH
96038: LD_INT 1
96040: NEG
96041: PUSH
96042: LD_INT 3
96044: NEG
96045: PUSH
96046: EMPTY
96047: LIST
96048: LIST
96049: PUSH
96050: LD_INT 0
96052: PUSH
96053: LD_INT 3
96055: NEG
96056: PUSH
96057: EMPTY
96058: LIST
96059: LIST
96060: PUSH
96061: LD_INT 1
96063: PUSH
96064: LD_INT 2
96066: NEG
96067: PUSH
96068: EMPTY
96069: LIST
96070: LIST
96071: PUSH
96072: EMPTY
96073: LIST
96074: LIST
96075: LIST
96076: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
96077: LD_ADDR_VAR 0 18
96081: PUSH
96082: LD_INT 2
96084: PUSH
96085: LD_INT 1
96087: NEG
96088: PUSH
96089: EMPTY
96090: LIST
96091: LIST
96092: PUSH
96093: LD_INT 3
96095: PUSH
96096: LD_INT 0
96098: PUSH
96099: EMPTY
96100: LIST
96101: LIST
96102: PUSH
96103: LD_INT 3
96105: PUSH
96106: LD_INT 1
96108: PUSH
96109: EMPTY
96110: LIST
96111: LIST
96112: PUSH
96113: EMPTY
96114: LIST
96115: LIST
96116: LIST
96117: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
96118: LD_ADDR_VAR 0 19
96122: PUSH
96123: LD_INT 3
96125: PUSH
96126: LD_INT 2
96128: PUSH
96129: EMPTY
96130: LIST
96131: LIST
96132: PUSH
96133: LD_INT 3
96135: PUSH
96136: LD_INT 3
96138: PUSH
96139: EMPTY
96140: LIST
96141: LIST
96142: PUSH
96143: LD_INT 2
96145: PUSH
96146: LD_INT 3
96148: PUSH
96149: EMPTY
96150: LIST
96151: LIST
96152: PUSH
96153: EMPTY
96154: LIST
96155: LIST
96156: LIST
96157: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
96158: LD_ADDR_VAR 0 20
96162: PUSH
96163: LD_INT 1
96165: PUSH
96166: LD_INT 3
96168: PUSH
96169: EMPTY
96170: LIST
96171: LIST
96172: PUSH
96173: LD_INT 0
96175: PUSH
96176: LD_INT 3
96178: PUSH
96179: EMPTY
96180: LIST
96181: LIST
96182: PUSH
96183: LD_INT 1
96185: NEG
96186: PUSH
96187: LD_INT 2
96189: PUSH
96190: EMPTY
96191: LIST
96192: LIST
96193: PUSH
96194: EMPTY
96195: LIST
96196: LIST
96197: LIST
96198: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
96199: LD_ADDR_VAR 0 21
96203: PUSH
96204: LD_INT 2
96206: NEG
96207: PUSH
96208: LD_INT 1
96210: PUSH
96211: EMPTY
96212: LIST
96213: LIST
96214: PUSH
96215: LD_INT 3
96217: NEG
96218: PUSH
96219: LD_INT 0
96221: PUSH
96222: EMPTY
96223: LIST
96224: LIST
96225: PUSH
96226: LD_INT 3
96228: NEG
96229: PUSH
96230: LD_INT 1
96232: NEG
96233: PUSH
96234: EMPTY
96235: LIST
96236: LIST
96237: PUSH
96238: EMPTY
96239: LIST
96240: LIST
96241: LIST
96242: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
96243: LD_ADDR_VAR 0 22
96247: PUSH
96248: LD_INT 2
96250: NEG
96251: PUSH
96252: LD_INT 3
96254: NEG
96255: PUSH
96256: EMPTY
96257: LIST
96258: LIST
96259: PUSH
96260: LD_INT 3
96262: NEG
96263: PUSH
96264: LD_INT 2
96266: NEG
96267: PUSH
96268: EMPTY
96269: LIST
96270: LIST
96271: PUSH
96272: LD_INT 3
96274: NEG
96275: PUSH
96276: LD_INT 3
96278: NEG
96279: PUSH
96280: EMPTY
96281: LIST
96282: LIST
96283: PUSH
96284: EMPTY
96285: LIST
96286: LIST
96287: LIST
96288: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
96289: LD_ADDR_VAR 0 23
96293: PUSH
96294: LD_INT 0
96296: PUSH
96297: LD_INT 3
96299: NEG
96300: PUSH
96301: EMPTY
96302: LIST
96303: LIST
96304: PUSH
96305: LD_INT 1
96307: NEG
96308: PUSH
96309: LD_INT 4
96311: NEG
96312: PUSH
96313: EMPTY
96314: LIST
96315: LIST
96316: PUSH
96317: LD_INT 1
96319: PUSH
96320: LD_INT 3
96322: NEG
96323: PUSH
96324: EMPTY
96325: LIST
96326: LIST
96327: PUSH
96328: EMPTY
96329: LIST
96330: LIST
96331: LIST
96332: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
96333: LD_ADDR_VAR 0 24
96337: PUSH
96338: LD_INT 3
96340: PUSH
96341: LD_INT 0
96343: PUSH
96344: EMPTY
96345: LIST
96346: LIST
96347: PUSH
96348: LD_INT 3
96350: PUSH
96351: LD_INT 1
96353: NEG
96354: PUSH
96355: EMPTY
96356: LIST
96357: LIST
96358: PUSH
96359: LD_INT 4
96361: PUSH
96362: LD_INT 1
96364: PUSH
96365: EMPTY
96366: LIST
96367: LIST
96368: PUSH
96369: EMPTY
96370: LIST
96371: LIST
96372: LIST
96373: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
96374: LD_ADDR_VAR 0 25
96378: PUSH
96379: LD_INT 3
96381: PUSH
96382: LD_INT 3
96384: PUSH
96385: EMPTY
96386: LIST
96387: LIST
96388: PUSH
96389: LD_INT 4
96391: PUSH
96392: LD_INT 3
96394: PUSH
96395: EMPTY
96396: LIST
96397: LIST
96398: PUSH
96399: LD_INT 3
96401: PUSH
96402: LD_INT 4
96404: PUSH
96405: EMPTY
96406: LIST
96407: LIST
96408: PUSH
96409: EMPTY
96410: LIST
96411: LIST
96412: LIST
96413: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
96414: LD_ADDR_VAR 0 26
96418: PUSH
96419: LD_INT 0
96421: PUSH
96422: LD_INT 3
96424: PUSH
96425: EMPTY
96426: LIST
96427: LIST
96428: PUSH
96429: LD_INT 1
96431: PUSH
96432: LD_INT 4
96434: PUSH
96435: EMPTY
96436: LIST
96437: LIST
96438: PUSH
96439: LD_INT 1
96441: NEG
96442: PUSH
96443: LD_INT 3
96445: PUSH
96446: EMPTY
96447: LIST
96448: LIST
96449: PUSH
96450: EMPTY
96451: LIST
96452: LIST
96453: LIST
96454: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
96455: LD_ADDR_VAR 0 27
96459: PUSH
96460: LD_INT 3
96462: NEG
96463: PUSH
96464: LD_INT 0
96466: PUSH
96467: EMPTY
96468: LIST
96469: LIST
96470: PUSH
96471: LD_INT 3
96473: NEG
96474: PUSH
96475: LD_INT 1
96477: PUSH
96478: EMPTY
96479: LIST
96480: LIST
96481: PUSH
96482: LD_INT 4
96484: NEG
96485: PUSH
96486: LD_INT 1
96488: NEG
96489: PUSH
96490: EMPTY
96491: LIST
96492: LIST
96493: PUSH
96494: EMPTY
96495: LIST
96496: LIST
96497: LIST
96498: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
96499: LD_ADDR_VAR 0 28
96503: PUSH
96504: LD_INT 3
96506: NEG
96507: PUSH
96508: LD_INT 3
96510: NEG
96511: PUSH
96512: EMPTY
96513: LIST
96514: LIST
96515: PUSH
96516: LD_INT 3
96518: NEG
96519: PUSH
96520: LD_INT 4
96522: NEG
96523: PUSH
96524: EMPTY
96525: LIST
96526: LIST
96527: PUSH
96528: LD_INT 4
96530: NEG
96531: PUSH
96532: LD_INT 3
96534: NEG
96535: PUSH
96536: EMPTY
96537: LIST
96538: LIST
96539: PUSH
96540: EMPTY
96541: LIST
96542: LIST
96543: LIST
96544: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
96545: LD_ADDR_VAR 0 29
96549: PUSH
96550: LD_INT 1
96552: NEG
96553: PUSH
96554: LD_INT 3
96556: NEG
96557: PUSH
96558: EMPTY
96559: LIST
96560: LIST
96561: PUSH
96562: LD_INT 0
96564: PUSH
96565: LD_INT 3
96567: NEG
96568: PUSH
96569: EMPTY
96570: LIST
96571: LIST
96572: PUSH
96573: LD_INT 1
96575: PUSH
96576: LD_INT 2
96578: NEG
96579: PUSH
96580: EMPTY
96581: LIST
96582: LIST
96583: PUSH
96584: LD_INT 1
96586: NEG
96587: PUSH
96588: LD_INT 4
96590: NEG
96591: PUSH
96592: EMPTY
96593: LIST
96594: LIST
96595: PUSH
96596: LD_INT 0
96598: PUSH
96599: LD_INT 4
96601: NEG
96602: PUSH
96603: EMPTY
96604: LIST
96605: LIST
96606: PUSH
96607: LD_INT 1
96609: PUSH
96610: LD_INT 3
96612: NEG
96613: PUSH
96614: EMPTY
96615: LIST
96616: LIST
96617: PUSH
96618: LD_INT 1
96620: NEG
96621: PUSH
96622: LD_INT 5
96624: NEG
96625: PUSH
96626: EMPTY
96627: LIST
96628: LIST
96629: PUSH
96630: LD_INT 0
96632: PUSH
96633: LD_INT 5
96635: NEG
96636: PUSH
96637: EMPTY
96638: LIST
96639: LIST
96640: PUSH
96641: LD_INT 1
96643: PUSH
96644: LD_INT 4
96646: NEG
96647: PUSH
96648: EMPTY
96649: LIST
96650: LIST
96651: PUSH
96652: LD_INT 1
96654: NEG
96655: PUSH
96656: LD_INT 6
96658: NEG
96659: PUSH
96660: EMPTY
96661: LIST
96662: LIST
96663: PUSH
96664: LD_INT 0
96666: PUSH
96667: LD_INT 6
96669: NEG
96670: PUSH
96671: EMPTY
96672: LIST
96673: LIST
96674: PUSH
96675: LD_INT 1
96677: PUSH
96678: LD_INT 5
96680: NEG
96681: PUSH
96682: EMPTY
96683: LIST
96684: LIST
96685: PUSH
96686: EMPTY
96687: LIST
96688: LIST
96689: LIST
96690: LIST
96691: LIST
96692: LIST
96693: LIST
96694: LIST
96695: LIST
96696: LIST
96697: LIST
96698: LIST
96699: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
96700: LD_ADDR_VAR 0 30
96704: PUSH
96705: LD_INT 2
96707: PUSH
96708: LD_INT 1
96710: NEG
96711: PUSH
96712: EMPTY
96713: LIST
96714: LIST
96715: PUSH
96716: LD_INT 3
96718: PUSH
96719: LD_INT 0
96721: PUSH
96722: EMPTY
96723: LIST
96724: LIST
96725: PUSH
96726: LD_INT 3
96728: PUSH
96729: LD_INT 1
96731: PUSH
96732: EMPTY
96733: LIST
96734: LIST
96735: PUSH
96736: LD_INT 3
96738: PUSH
96739: LD_INT 1
96741: NEG
96742: PUSH
96743: EMPTY
96744: LIST
96745: LIST
96746: PUSH
96747: LD_INT 4
96749: PUSH
96750: LD_INT 0
96752: PUSH
96753: EMPTY
96754: LIST
96755: LIST
96756: PUSH
96757: LD_INT 4
96759: PUSH
96760: LD_INT 1
96762: PUSH
96763: EMPTY
96764: LIST
96765: LIST
96766: PUSH
96767: LD_INT 4
96769: PUSH
96770: LD_INT 1
96772: NEG
96773: PUSH
96774: EMPTY
96775: LIST
96776: LIST
96777: PUSH
96778: LD_INT 5
96780: PUSH
96781: LD_INT 0
96783: PUSH
96784: EMPTY
96785: LIST
96786: LIST
96787: PUSH
96788: LD_INT 5
96790: PUSH
96791: LD_INT 1
96793: PUSH
96794: EMPTY
96795: LIST
96796: LIST
96797: PUSH
96798: LD_INT 5
96800: PUSH
96801: LD_INT 1
96803: NEG
96804: PUSH
96805: EMPTY
96806: LIST
96807: LIST
96808: PUSH
96809: LD_INT 6
96811: PUSH
96812: LD_INT 0
96814: PUSH
96815: EMPTY
96816: LIST
96817: LIST
96818: PUSH
96819: LD_INT 6
96821: PUSH
96822: LD_INT 1
96824: PUSH
96825: EMPTY
96826: LIST
96827: LIST
96828: PUSH
96829: EMPTY
96830: LIST
96831: LIST
96832: LIST
96833: LIST
96834: LIST
96835: LIST
96836: LIST
96837: LIST
96838: LIST
96839: LIST
96840: LIST
96841: LIST
96842: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
96843: LD_ADDR_VAR 0 31
96847: PUSH
96848: LD_INT 3
96850: PUSH
96851: LD_INT 2
96853: PUSH
96854: EMPTY
96855: LIST
96856: LIST
96857: PUSH
96858: LD_INT 3
96860: PUSH
96861: LD_INT 3
96863: PUSH
96864: EMPTY
96865: LIST
96866: LIST
96867: PUSH
96868: LD_INT 2
96870: PUSH
96871: LD_INT 3
96873: PUSH
96874: EMPTY
96875: LIST
96876: LIST
96877: PUSH
96878: LD_INT 4
96880: PUSH
96881: LD_INT 3
96883: PUSH
96884: EMPTY
96885: LIST
96886: LIST
96887: PUSH
96888: LD_INT 4
96890: PUSH
96891: LD_INT 4
96893: PUSH
96894: EMPTY
96895: LIST
96896: LIST
96897: PUSH
96898: LD_INT 3
96900: PUSH
96901: LD_INT 4
96903: PUSH
96904: EMPTY
96905: LIST
96906: LIST
96907: PUSH
96908: LD_INT 5
96910: PUSH
96911: LD_INT 4
96913: PUSH
96914: EMPTY
96915: LIST
96916: LIST
96917: PUSH
96918: LD_INT 5
96920: PUSH
96921: LD_INT 5
96923: PUSH
96924: EMPTY
96925: LIST
96926: LIST
96927: PUSH
96928: LD_INT 4
96930: PUSH
96931: LD_INT 5
96933: PUSH
96934: EMPTY
96935: LIST
96936: LIST
96937: PUSH
96938: LD_INT 6
96940: PUSH
96941: LD_INT 5
96943: PUSH
96944: EMPTY
96945: LIST
96946: LIST
96947: PUSH
96948: LD_INT 6
96950: PUSH
96951: LD_INT 6
96953: PUSH
96954: EMPTY
96955: LIST
96956: LIST
96957: PUSH
96958: LD_INT 5
96960: PUSH
96961: LD_INT 6
96963: PUSH
96964: EMPTY
96965: LIST
96966: LIST
96967: PUSH
96968: EMPTY
96969: LIST
96970: LIST
96971: LIST
96972: LIST
96973: LIST
96974: LIST
96975: LIST
96976: LIST
96977: LIST
96978: LIST
96979: LIST
96980: LIST
96981: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
96982: LD_ADDR_VAR 0 32
96986: PUSH
96987: LD_INT 1
96989: PUSH
96990: LD_INT 3
96992: PUSH
96993: EMPTY
96994: LIST
96995: LIST
96996: PUSH
96997: LD_INT 0
96999: PUSH
97000: LD_INT 3
97002: PUSH
97003: EMPTY
97004: LIST
97005: LIST
97006: PUSH
97007: LD_INT 1
97009: NEG
97010: PUSH
97011: LD_INT 2
97013: PUSH
97014: EMPTY
97015: LIST
97016: LIST
97017: PUSH
97018: LD_INT 1
97020: PUSH
97021: LD_INT 4
97023: PUSH
97024: EMPTY
97025: LIST
97026: LIST
97027: PUSH
97028: LD_INT 0
97030: PUSH
97031: LD_INT 4
97033: PUSH
97034: EMPTY
97035: LIST
97036: LIST
97037: PUSH
97038: LD_INT 1
97040: NEG
97041: PUSH
97042: LD_INT 3
97044: PUSH
97045: EMPTY
97046: LIST
97047: LIST
97048: PUSH
97049: LD_INT 1
97051: PUSH
97052: LD_INT 5
97054: PUSH
97055: EMPTY
97056: LIST
97057: LIST
97058: PUSH
97059: LD_INT 0
97061: PUSH
97062: LD_INT 5
97064: PUSH
97065: EMPTY
97066: LIST
97067: LIST
97068: PUSH
97069: LD_INT 1
97071: NEG
97072: PUSH
97073: LD_INT 4
97075: PUSH
97076: EMPTY
97077: LIST
97078: LIST
97079: PUSH
97080: LD_INT 1
97082: PUSH
97083: LD_INT 6
97085: PUSH
97086: EMPTY
97087: LIST
97088: LIST
97089: PUSH
97090: LD_INT 0
97092: PUSH
97093: LD_INT 6
97095: PUSH
97096: EMPTY
97097: LIST
97098: LIST
97099: PUSH
97100: LD_INT 1
97102: NEG
97103: PUSH
97104: LD_INT 5
97106: PUSH
97107: EMPTY
97108: LIST
97109: LIST
97110: PUSH
97111: EMPTY
97112: LIST
97113: LIST
97114: LIST
97115: LIST
97116: LIST
97117: LIST
97118: LIST
97119: LIST
97120: LIST
97121: LIST
97122: LIST
97123: LIST
97124: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
97125: LD_ADDR_VAR 0 33
97129: PUSH
97130: LD_INT 2
97132: NEG
97133: PUSH
97134: LD_INT 1
97136: PUSH
97137: EMPTY
97138: LIST
97139: LIST
97140: PUSH
97141: LD_INT 3
97143: NEG
97144: PUSH
97145: LD_INT 0
97147: PUSH
97148: EMPTY
97149: LIST
97150: LIST
97151: PUSH
97152: LD_INT 3
97154: NEG
97155: PUSH
97156: LD_INT 1
97158: NEG
97159: PUSH
97160: EMPTY
97161: LIST
97162: LIST
97163: PUSH
97164: LD_INT 3
97166: NEG
97167: PUSH
97168: LD_INT 1
97170: PUSH
97171: EMPTY
97172: LIST
97173: LIST
97174: PUSH
97175: LD_INT 4
97177: NEG
97178: PUSH
97179: LD_INT 0
97181: PUSH
97182: EMPTY
97183: LIST
97184: LIST
97185: PUSH
97186: LD_INT 4
97188: NEG
97189: PUSH
97190: LD_INT 1
97192: NEG
97193: PUSH
97194: EMPTY
97195: LIST
97196: LIST
97197: PUSH
97198: LD_INT 4
97200: NEG
97201: PUSH
97202: LD_INT 1
97204: PUSH
97205: EMPTY
97206: LIST
97207: LIST
97208: PUSH
97209: LD_INT 5
97211: NEG
97212: PUSH
97213: LD_INT 0
97215: PUSH
97216: EMPTY
97217: LIST
97218: LIST
97219: PUSH
97220: LD_INT 5
97222: NEG
97223: PUSH
97224: LD_INT 1
97226: NEG
97227: PUSH
97228: EMPTY
97229: LIST
97230: LIST
97231: PUSH
97232: LD_INT 5
97234: NEG
97235: PUSH
97236: LD_INT 1
97238: PUSH
97239: EMPTY
97240: LIST
97241: LIST
97242: PUSH
97243: LD_INT 6
97245: NEG
97246: PUSH
97247: LD_INT 0
97249: PUSH
97250: EMPTY
97251: LIST
97252: LIST
97253: PUSH
97254: LD_INT 6
97256: NEG
97257: PUSH
97258: LD_INT 1
97260: NEG
97261: PUSH
97262: EMPTY
97263: LIST
97264: LIST
97265: PUSH
97266: EMPTY
97267: LIST
97268: LIST
97269: LIST
97270: LIST
97271: LIST
97272: LIST
97273: LIST
97274: LIST
97275: LIST
97276: LIST
97277: LIST
97278: LIST
97279: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
97280: LD_ADDR_VAR 0 34
97284: PUSH
97285: LD_INT 2
97287: NEG
97288: PUSH
97289: LD_INT 3
97291: NEG
97292: PUSH
97293: EMPTY
97294: LIST
97295: LIST
97296: PUSH
97297: LD_INT 3
97299: NEG
97300: PUSH
97301: LD_INT 2
97303: NEG
97304: PUSH
97305: EMPTY
97306: LIST
97307: LIST
97308: PUSH
97309: LD_INT 3
97311: NEG
97312: PUSH
97313: LD_INT 3
97315: NEG
97316: PUSH
97317: EMPTY
97318: LIST
97319: LIST
97320: PUSH
97321: LD_INT 3
97323: NEG
97324: PUSH
97325: LD_INT 4
97327: NEG
97328: PUSH
97329: EMPTY
97330: LIST
97331: LIST
97332: PUSH
97333: LD_INT 4
97335: NEG
97336: PUSH
97337: LD_INT 3
97339: NEG
97340: PUSH
97341: EMPTY
97342: LIST
97343: LIST
97344: PUSH
97345: LD_INT 4
97347: NEG
97348: PUSH
97349: LD_INT 4
97351: NEG
97352: PUSH
97353: EMPTY
97354: LIST
97355: LIST
97356: PUSH
97357: LD_INT 4
97359: NEG
97360: PUSH
97361: LD_INT 5
97363: NEG
97364: PUSH
97365: EMPTY
97366: LIST
97367: LIST
97368: PUSH
97369: LD_INT 5
97371: NEG
97372: PUSH
97373: LD_INT 4
97375: NEG
97376: PUSH
97377: EMPTY
97378: LIST
97379: LIST
97380: PUSH
97381: LD_INT 5
97383: NEG
97384: PUSH
97385: LD_INT 5
97387: NEG
97388: PUSH
97389: EMPTY
97390: LIST
97391: LIST
97392: PUSH
97393: LD_INT 5
97395: NEG
97396: PUSH
97397: LD_INT 6
97399: NEG
97400: PUSH
97401: EMPTY
97402: LIST
97403: LIST
97404: PUSH
97405: LD_INT 6
97407: NEG
97408: PUSH
97409: LD_INT 5
97411: NEG
97412: PUSH
97413: EMPTY
97414: LIST
97415: LIST
97416: PUSH
97417: LD_INT 6
97419: NEG
97420: PUSH
97421: LD_INT 6
97423: NEG
97424: PUSH
97425: EMPTY
97426: LIST
97427: LIST
97428: PUSH
97429: EMPTY
97430: LIST
97431: LIST
97432: LIST
97433: LIST
97434: LIST
97435: LIST
97436: LIST
97437: LIST
97438: LIST
97439: LIST
97440: LIST
97441: LIST
97442: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
97443: LD_ADDR_VAR 0 41
97447: PUSH
97448: LD_INT 0
97450: PUSH
97451: LD_INT 2
97453: NEG
97454: PUSH
97455: EMPTY
97456: LIST
97457: LIST
97458: PUSH
97459: LD_INT 1
97461: NEG
97462: PUSH
97463: LD_INT 3
97465: NEG
97466: PUSH
97467: EMPTY
97468: LIST
97469: LIST
97470: PUSH
97471: LD_INT 1
97473: PUSH
97474: LD_INT 2
97476: NEG
97477: PUSH
97478: EMPTY
97479: LIST
97480: LIST
97481: PUSH
97482: EMPTY
97483: LIST
97484: LIST
97485: LIST
97486: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
97487: LD_ADDR_VAR 0 42
97491: PUSH
97492: LD_INT 2
97494: PUSH
97495: LD_INT 0
97497: PUSH
97498: EMPTY
97499: LIST
97500: LIST
97501: PUSH
97502: LD_INT 2
97504: PUSH
97505: LD_INT 1
97507: NEG
97508: PUSH
97509: EMPTY
97510: LIST
97511: LIST
97512: PUSH
97513: LD_INT 3
97515: PUSH
97516: LD_INT 1
97518: PUSH
97519: EMPTY
97520: LIST
97521: LIST
97522: PUSH
97523: EMPTY
97524: LIST
97525: LIST
97526: LIST
97527: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
97528: LD_ADDR_VAR 0 43
97532: PUSH
97533: LD_INT 2
97535: PUSH
97536: LD_INT 2
97538: PUSH
97539: EMPTY
97540: LIST
97541: LIST
97542: PUSH
97543: LD_INT 3
97545: PUSH
97546: LD_INT 2
97548: PUSH
97549: EMPTY
97550: LIST
97551: LIST
97552: PUSH
97553: LD_INT 2
97555: PUSH
97556: LD_INT 3
97558: PUSH
97559: EMPTY
97560: LIST
97561: LIST
97562: PUSH
97563: EMPTY
97564: LIST
97565: LIST
97566: LIST
97567: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
97568: LD_ADDR_VAR 0 44
97572: PUSH
97573: LD_INT 0
97575: PUSH
97576: LD_INT 2
97578: PUSH
97579: EMPTY
97580: LIST
97581: LIST
97582: PUSH
97583: LD_INT 1
97585: PUSH
97586: LD_INT 3
97588: PUSH
97589: EMPTY
97590: LIST
97591: LIST
97592: PUSH
97593: LD_INT 1
97595: NEG
97596: PUSH
97597: LD_INT 2
97599: PUSH
97600: EMPTY
97601: LIST
97602: LIST
97603: PUSH
97604: EMPTY
97605: LIST
97606: LIST
97607: LIST
97608: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
97609: LD_ADDR_VAR 0 45
97613: PUSH
97614: LD_INT 2
97616: NEG
97617: PUSH
97618: LD_INT 0
97620: PUSH
97621: EMPTY
97622: LIST
97623: LIST
97624: PUSH
97625: LD_INT 2
97627: NEG
97628: PUSH
97629: LD_INT 1
97631: PUSH
97632: EMPTY
97633: LIST
97634: LIST
97635: PUSH
97636: LD_INT 3
97638: NEG
97639: PUSH
97640: LD_INT 1
97642: NEG
97643: PUSH
97644: EMPTY
97645: LIST
97646: LIST
97647: PUSH
97648: EMPTY
97649: LIST
97650: LIST
97651: LIST
97652: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
97653: LD_ADDR_VAR 0 46
97657: PUSH
97658: LD_INT 2
97660: NEG
97661: PUSH
97662: LD_INT 2
97664: NEG
97665: PUSH
97666: EMPTY
97667: LIST
97668: LIST
97669: PUSH
97670: LD_INT 2
97672: NEG
97673: PUSH
97674: LD_INT 3
97676: NEG
97677: PUSH
97678: EMPTY
97679: LIST
97680: LIST
97681: PUSH
97682: LD_INT 3
97684: NEG
97685: PUSH
97686: LD_INT 2
97688: NEG
97689: PUSH
97690: EMPTY
97691: LIST
97692: LIST
97693: PUSH
97694: EMPTY
97695: LIST
97696: LIST
97697: LIST
97698: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
97699: LD_ADDR_VAR 0 47
97703: PUSH
97704: LD_INT 2
97706: NEG
97707: PUSH
97708: LD_INT 3
97710: NEG
97711: PUSH
97712: EMPTY
97713: LIST
97714: LIST
97715: PUSH
97716: LD_INT 1
97718: NEG
97719: PUSH
97720: LD_INT 3
97722: NEG
97723: PUSH
97724: EMPTY
97725: LIST
97726: LIST
97727: PUSH
97728: EMPTY
97729: LIST
97730: LIST
97731: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
97732: LD_ADDR_VAR 0 48
97736: PUSH
97737: LD_INT 1
97739: PUSH
97740: LD_INT 2
97742: NEG
97743: PUSH
97744: EMPTY
97745: LIST
97746: LIST
97747: PUSH
97748: LD_INT 2
97750: PUSH
97751: LD_INT 1
97753: NEG
97754: PUSH
97755: EMPTY
97756: LIST
97757: LIST
97758: PUSH
97759: EMPTY
97760: LIST
97761: LIST
97762: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
97763: LD_ADDR_VAR 0 49
97767: PUSH
97768: LD_INT 3
97770: PUSH
97771: LD_INT 1
97773: PUSH
97774: EMPTY
97775: LIST
97776: LIST
97777: PUSH
97778: LD_INT 3
97780: PUSH
97781: LD_INT 2
97783: PUSH
97784: EMPTY
97785: LIST
97786: LIST
97787: PUSH
97788: EMPTY
97789: LIST
97790: LIST
97791: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
97792: LD_ADDR_VAR 0 50
97796: PUSH
97797: LD_INT 2
97799: PUSH
97800: LD_INT 3
97802: PUSH
97803: EMPTY
97804: LIST
97805: LIST
97806: PUSH
97807: LD_INT 1
97809: PUSH
97810: LD_INT 3
97812: PUSH
97813: EMPTY
97814: LIST
97815: LIST
97816: PUSH
97817: EMPTY
97818: LIST
97819: LIST
97820: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
97821: LD_ADDR_VAR 0 51
97825: PUSH
97826: LD_INT 1
97828: NEG
97829: PUSH
97830: LD_INT 2
97832: PUSH
97833: EMPTY
97834: LIST
97835: LIST
97836: PUSH
97837: LD_INT 2
97839: NEG
97840: PUSH
97841: LD_INT 1
97843: PUSH
97844: EMPTY
97845: LIST
97846: LIST
97847: PUSH
97848: EMPTY
97849: LIST
97850: LIST
97851: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
97852: LD_ADDR_VAR 0 52
97856: PUSH
97857: LD_INT 3
97859: NEG
97860: PUSH
97861: LD_INT 1
97863: NEG
97864: PUSH
97865: EMPTY
97866: LIST
97867: LIST
97868: PUSH
97869: LD_INT 3
97871: NEG
97872: PUSH
97873: LD_INT 2
97875: NEG
97876: PUSH
97877: EMPTY
97878: LIST
97879: LIST
97880: PUSH
97881: EMPTY
97882: LIST
97883: LIST
97884: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
97885: LD_ADDR_VAR 0 53
97889: PUSH
97890: LD_INT 1
97892: NEG
97893: PUSH
97894: LD_INT 3
97896: NEG
97897: PUSH
97898: EMPTY
97899: LIST
97900: LIST
97901: PUSH
97902: LD_INT 0
97904: PUSH
97905: LD_INT 3
97907: NEG
97908: PUSH
97909: EMPTY
97910: LIST
97911: LIST
97912: PUSH
97913: LD_INT 1
97915: PUSH
97916: LD_INT 2
97918: NEG
97919: PUSH
97920: EMPTY
97921: LIST
97922: LIST
97923: PUSH
97924: EMPTY
97925: LIST
97926: LIST
97927: LIST
97928: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
97929: LD_ADDR_VAR 0 54
97933: PUSH
97934: LD_INT 2
97936: PUSH
97937: LD_INT 1
97939: NEG
97940: PUSH
97941: EMPTY
97942: LIST
97943: LIST
97944: PUSH
97945: LD_INT 3
97947: PUSH
97948: LD_INT 0
97950: PUSH
97951: EMPTY
97952: LIST
97953: LIST
97954: PUSH
97955: LD_INT 3
97957: PUSH
97958: LD_INT 1
97960: PUSH
97961: EMPTY
97962: LIST
97963: LIST
97964: PUSH
97965: EMPTY
97966: LIST
97967: LIST
97968: LIST
97969: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
97970: LD_ADDR_VAR 0 55
97974: PUSH
97975: LD_INT 3
97977: PUSH
97978: LD_INT 2
97980: PUSH
97981: EMPTY
97982: LIST
97983: LIST
97984: PUSH
97985: LD_INT 3
97987: PUSH
97988: LD_INT 3
97990: PUSH
97991: EMPTY
97992: LIST
97993: LIST
97994: PUSH
97995: LD_INT 2
97997: PUSH
97998: LD_INT 3
98000: PUSH
98001: EMPTY
98002: LIST
98003: LIST
98004: PUSH
98005: EMPTY
98006: LIST
98007: LIST
98008: LIST
98009: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
98010: LD_ADDR_VAR 0 56
98014: PUSH
98015: LD_INT 1
98017: PUSH
98018: LD_INT 3
98020: PUSH
98021: EMPTY
98022: LIST
98023: LIST
98024: PUSH
98025: LD_INT 0
98027: PUSH
98028: LD_INT 3
98030: PUSH
98031: EMPTY
98032: LIST
98033: LIST
98034: PUSH
98035: LD_INT 1
98037: NEG
98038: PUSH
98039: LD_INT 2
98041: PUSH
98042: EMPTY
98043: LIST
98044: LIST
98045: PUSH
98046: EMPTY
98047: LIST
98048: LIST
98049: LIST
98050: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
98051: LD_ADDR_VAR 0 57
98055: PUSH
98056: LD_INT 2
98058: NEG
98059: PUSH
98060: LD_INT 1
98062: PUSH
98063: EMPTY
98064: LIST
98065: LIST
98066: PUSH
98067: LD_INT 3
98069: NEG
98070: PUSH
98071: LD_INT 0
98073: PUSH
98074: EMPTY
98075: LIST
98076: LIST
98077: PUSH
98078: LD_INT 3
98080: NEG
98081: PUSH
98082: LD_INT 1
98084: NEG
98085: PUSH
98086: EMPTY
98087: LIST
98088: LIST
98089: PUSH
98090: EMPTY
98091: LIST
98092: LIST
98093: LIST
98094: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
98095: LD_ADDR_VAR 0 58
98099: PUSH
98100: LD_INT 2
98102: NEG
98103: PUSH
98104: LD_INT 3
98106: NEG
98107: PUSH
98108: EMPTY
98109: LIST
98110: LIST
98111: PUSH
98112: LD_INT 3
98114: NEG
98115: PUSH
98116: LD_INT 2
98118: NEG
98119: PUSH
98120: EMPTY
98121: LIST
98122: LIST
98123: PUSH
98124: LD_INT 3
98126: NEG
98127: PUSH
98128: LD_INT 3
98130: NEG
98131: PUSH
98132: EMPTY
98133: LIST
98134: LIST
98135: PUSH
98136: EMPTY
98137: LIST
98138: LIST
98139: LIST
98140: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
98141: LD_ADDR_VAR 0 59
98145: PUSH
98146: LD_INT 1
98148: NEG
98149: PUSH
98150: LD_INT 2
98152: NEG
98153: PUSH
98154: EMPTY
98155: LIST
98156: LIST
98157: PUSH
98158: LD_INT 0
98160: PUSH
98161: LD_INT 2
98163: NEG
98164: PUSH
98165: EMPTY
98166: LIST
98167: LIST
98168: PUSH
98169: LD_INT 1
98171: PUSH
98172: LD_INT 1
98174: NEG
98175: PUSH
98176: EMPTY
98177: LIST
98178: LIST
98179: PUSH
98180: EMPTY
98181: LIST
98182: LIST
98183: LIST
98184: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
98185: LD_ADDR_VAR 0 60
98189: PUSH
98190: LD_INT 1
98192: PUSH
98193: LD_INT 1
98195: NEG
98196: PUSH
98197: EMPTY
98198: LIST
98199: LIST
98200: PUSH
98201: LD_INT 2
98203: PUSH
98204: LD_INT 0
98206: PUSH
98207: EMPTY
98208: LIST
98209: LIST
98210: PUSH
98211: LD_INT 2
98213: PUSH
98214: LD_INT 1
98216: PUSH
98217: EMPTY
98218: LIST
98219: LIST
98220: PUSH
98221: EMPTY
98222: LIST
98223: LIST
98224: LIST
98225: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
98226: LD_ADDR_VAR 0 61
98230: PUSH
98231: LD_INT 2
98233: PUSH
98234: LD_INT 1
98236: PUSH
98237: EMPTY
98238: LIST
98239: LIST
98240: PUSH
98241: LD_INT 2
98243: PUSH
98244: LD_INT 2
98246: PUSH
98247: EMPTY
98248: LIST
98249: LIST
98250: PUSH
98251: LD_INT 1
98253: PUSH
98254: LD_INT 2
98256: PUSH
98257: EMPTY
98258: LIST
98259: LIST
98260: PUSH
98261: EMPTY
98262: LIST
98263: LIST
98264: LIST
98265: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
98266: LD_ADDR_VAR 0 62
98270: PUSH
98271: LD_INT 1
98273: PUSH
98274: LD_INT 2
98276: PUSH
98277: EMPTY
98278: LIST
98279: LIST
98280: PUSH
98281: LD_INT 0
98283: PUSH
98284: LD_INT 2
98286: PUSH
98287: EMPTY
98288: LIST
98289: LIST
98290: PUSH
98291: LD_INT 1
98293: NEG
98294: PUSH
98295: LD_INT 1
98297: PUSH
98298: EMPTY
98299: LIST
98300: LIST
98301: PUSH
98302: EMPTY
98303: LIST
98304: LIST
98305: LIST
98306: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
98307: LD_ADDR_VAR 0 63
98311: PUSH
98312: LD_INT 1
98314: NEG
98315: PUSH
98316: LD_INT 1
98318: PUSH
98319: EMPTY
98320: LIST
98321: LIST
98322: PUSH
98323: LD_INT 2
98325: NEG
98326: PUSH
98327: LD_INT 0
98329: PUSH
98330: EMPTY
98331: LIST
98332: LIST
98333: PUSH
98334: LD_INT 2
98336: NEG
98337: PUSH
98338: LD_INT 1
98340: NEG
98341: PUSH
98342: EMPTY
98343: LIST
98344: LIST
98345: PUSH
98346: EMPTY
98347: LIST
98348: LIST
98349: LIST
98350: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
98351: LD_ADDR_VAR 0 64
98355: PUSH
98356: LD_INT 1
98358: NEG
98359: PUSH
98360: LD_INT 2
98362: NEG
98363: PUSH
98364: EMPTY
98365: LIST
98366: LIST
98367: PUSH
98368: LD_INT 2
98370: NEG
98371: PUSH
98372: LD_INT 1
98374: NEG
98375: PUSH
98376: EMPTY
98377: LIST
98378: LIST
98379: PUSH
98380: LD_INT 2
98382: NEG
98383: PUSH
98384: LD_INT 2
98386: NEG
98387: PUSH
98388: EMPTY
98389: LIST
98390: LIST
98391: PUSH
98392: EMPTY
98393: LIST
98394: LIST
98395: LIST
98396: ST_TO_ADDR
// end ; 2 :
98397: GO 101663
98399: LD_INT 2
98401: DOUBLE
98402: EQUAL
98403: IFTRUE 98407
98405: GO 101662
98407: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
98408: LD_ADDR_VAR 0 29
98412: PUSH
98413: LD_INT 4
98415: PUSH
98416: LD_INT 0
98418: PUSH
98419: EMPTY
98420: LIST
98421: LIST
98422: PUSH
98423: LD_INT 4
98425: PUSH
98426: LD_INT 1
98428: NEG
98429: PUSH
98430: EMPTY
98431: LIST
98432: LIST
98433: PUSH
98434: LD_INT 5
98436: PUSH
98437: LD_INT 0
98439: PUSH
98440: EMPTY
98441: LIST
98442: LIST
98443: PUSH
98444: LD_INT 5
98446: PUSH
98447: LD_INT 1
98449: PUSH
98450: EMPTY
98451: LIST
98452: LIST
98453: PUSH
98454: LD_INT 4
98456: PUSH
98457: LD_INT 1
98459: PUSH
98460: EMPTY
98461: LIST
98462: LIST
98463: PUSH
98464: LD_INT 3
98466: PUSH
98467: LD_INT 0
98469: PUSH
98470: EMPTY
98471: LIST
98472: LIST
98473: PUSH
98474: LD_INT 3
98476: PUSH
98477: LD_INT 1
98479: NEG
98480: PUSH
98481: EMPTY
98482: LIST
98483: LIST
98484: PUSH
98485: LD_INT 3
98487: PUSH
98488: LD_INT 2
98490: NEG
98491: PUSH
98492: EMPTY
98493: LIST
98494: LIST
98495: PUSH
98496: LD_INT 5
98498: PUSH
98499: LD_INT 2
98501: PUSH
98502: EMPTY
98503: LIST
98504: LIST
98505: PUSH
98506: LD_INT 3
98508: PUSH
98509: LD_INT 3
98511: PUSH
98512: EMPTY
98513: LIST
98514: LIST
98515: PUSH
98516: LD_INT 3
98518: PUSH
98519: LD_INT 2
98521: PUSH
98522: EMPTY
98523: LIST
98524: LIST
98525: PUSH
98526: LD_INT 4
98528: PUSH
98529: LD_INT 3
98531: PUSH
98532: EMPTY
98533: LIST
98534: LIST
98535: PUSH
98536: LD_INT 4
98538: PUSH
98539: LD_INT 4
98541: PUSH
98542: EMPTY
98543: LIST
98544: LIST
98545: PUSH
98546: LD_INT 3
98548: PUSH
98549: LD_INT 4
98551: PUSH
98552: EMPTY
98553: LIST
98554: LIST
98555: PUSH
98556: LD_INT 2
98558: PUSH
98559: LD_INT 3
98561: PUSH
98562: EMPTY
98563: LIST
98564: LIST
98565: PUSH
98566: LD_INT 2
98568: PUSH
98569: LD_INT 2
98571: PUSH
98572: EMPTY
98573: LIST
98574: LIST
98575: PUSH
98576: LD_INT 4
98578: PUSH
98579: LD_INT 2
98581: PUSH
98582: EMPTY
98583: LIST
98584: LIST
98585: PUSH
98586: LD_INT 2
98588: PUSH
98589: LD_INT 4
98591: PUSH
98592: EMPTY
98593: LIST
98594: LIST
98595: PUSH
98596: LD_INT 0
98598: PUSH
98599: LD_INT 4
98601: PUSH
98602: EMPTY
98603: LIST
98604: LIST
98605: PUSH
98606: LD_INT 0
98608: PUSH
98609: LD_INT 3
98611: PUSH
98612: EMPTY
98613: LIST
98614: LIST
98615: PUSH
98616: LD_INT 1
98618: PUSH
98619: LD_INT 4
98621: PUSH
98622: EMPTY
98623: LIST
98624: LIST
98625: PUSH
98626: LD_INT 1
98628: PUSH
98629: LD_INT 5
98631: PUSH
98632: EMPTY
98633: LIST
98634: LIST
98635: PUSH
98636: LD_INT 0
98638: PUSH
98639: LD_INT 5
98641: PUSH
98642: EMPTY
98643: LIST
98644: LIST
98645: PUSH
98646: LD_INT 1
98648: NEG
98649: PUSH
98650: LD_INT 4
98652: PUSH
98653: EMPTY
98654: LIST
98655: LIST
98656: PUSH
98657: LD_INT 1
98659: NEG
98660: PUSH
98661: LD_INT 3
98663: PUSH
98664: EMPTY
98665: LIST
98666: LIST
98667: PUSH
98668: LD_INT 2
98670: PUSH
98671: LD_INT 5
98673: PUSH
98674: EMPTY
98675: LIST
98676: LIST
98677: PUSH
98678: LD_INT 2
98680: NEG
98681: PUSH
98682: LD_INT 3
98684: PUSH
98685: EMPTY
98686: LIST
98687: LIST
98688: PUSH
98689: LD_INT 3
98691: NEG
98692: PUSH
98693: LD_INT 0
98695: PUSH
98696: EMPTY
98697: LIST
98698: LIST
98699: PUSH
98700: LD_INT 3
98702: NEG
98703: PUSH
98704: LD_INT 1
98706: NEG
98707: PUSH
98708: EMPTY
98709: LIST
98710: LIST
98711: PUSH
98712: LD_INT 2
98714: NEG
98715: PUSH
98716: LD_INT 0
98718: PUSH
98719: EMPTY
98720: LIST
98721: LIST
98722: PUSH
98723: LD_INT 2
98725: NEG
98726: PUSH
98727: LD_INT 1
98729: PUSH
98730: EMPTY
98731: LIST
98732: LIST
98733: PUSH
98734: LD_INT 3
98736: NEG
98737: PUSH
98738: LD_INT 1
98740: PUSH
98741: EMPTY
98742: LIST
98743: LIST
98744: PUSH
98745: LD_INT 4
98747: NEG
98748: PUSH
98749: LD_INT 0
98751: PUSH
98752: EMPTY
98753: LIST
98754: LIST
98755: PUSH
98756: LD_INT 4
98758: NEG
98759: PUSH
98760: LD_INT 1
98762: NEG
98763: PUSH
98764: EMPTY
98765: LIST
98766: LIST
98767: PUSH
98768: LD_INT 4
98770: NEG
98771: PUSH
98772: LD_INT 2
98774: NEG
98775: PUSH
98776: EMPTY
98777: LIST
98778: LIST
98779: PUSH
98780: LD_INT 2
98782: NEG
98783: PUSH
98784: LD_INT 2
98786: PUSH
98787: EMPTY
98788: LIST
98789: LIST
98790: PUSH
98791: LD_INT 4
98793: NEG
98794: PUSH
98795: LD_INT 4
98797: NEG
98798: PUSH
98799: EMPTY
98800: LIST
98801: LIST
98802: PUSH
98803: LD_INT 4
98805: NEG
98806: PUSH
98807: LD_INT 5
98809: NEG
98810: PUSH
98811: EMPTY
98812: LIST
98813: LIST
98814: PUSH
98815: LD_INT 3
98817: NEG
98818: PUSH
98819: LD_INT 4
98821: NEG
98822: PUSH
98823: EMPTY
98824: LIST
98825: LIST
98826: PUSH
98827: LD_INT 3
98829: NEG
98830: PUSH
98831: LD_INT 3
98833: NEG
98834: PUSH
98835: EMPTY
98836: LIST
98837: LIST
98838: PUSH
98839: LD_INT 4
98841: NEG
98842: PUSH
98843: LD_INT 3
98845: NEG
98846: PUSH
98847: EMPTY
98848: LIST
98849: LIST
98850: PUSH
98851: LD_INT 5
98853: NEG
98854: PUSH
98855: LD_INT 4
98857: NEG
98858: PUSH
98859: EMPTY
98860: LIST
98861: LIST
98862: PUSH
98863: LD_INT 5
98865: NEG
98866: PUSH
98867: LD_INT 5
98869: NEG
98870: PUSH
98871: EMPTY
98872: LIST
98873: LIST
98874: PUSH
98875: LD_INT 3
98877: NEG
98878: PUSH
98879: LD_INT 5
98881: NEG
98882: PUSH
98883: EMPTY
98884: LIST
98885: LIST
98886: PUSH
98887: LD_INT 5
98889: NEG
98890: PUSH
98891: LD_INT 3
98893: NEG
98894: PUSH
98895: EMPTY
98896: LIST
98897: LIST
98898: PUSH
98899: EMPTY
98900: LIST
98901: LIST
98902: LIST
98903: LIST
98904: LIST
98905: LIST
98906: LIST
98907: LIST
98908: LIST
98909: LIST
98910: LIST
98911: LIST
98912: LIST
98913: LIST
98914: LIST
98915: LIST
98916: LIST
98917: LIST
98918: LIST
98919: LIST
98920: LIST
98921: LIST
98922: LIST
98923: LIST
98924: LIST
98925: LIST
98926: LIST
98927: LIST
98928: LIST
98929: LIST
98930: LIST
98931: LIST
98932: LIST
98933: LIST
98934: LIST
98935: LIST
98936: LIST
98937: LIST
98938: LIST
98939: LIST
98940: LIST
98941: LIST
98942: LIST
98943: LIST
98944: LIST
98945: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
98946: LD_ADDR_VAR 0 30
98950: PUSH
98951: LD_INT 4
98953: PUSH
98954: LD_INT 4
98956: PUSH
98957: EMPTY
98958: LIST
98959: LIST
98960: PUSH
98961: LD_INT 4
98963: PUSH
98964: LD_INT 3
98966: PUSH
98967: EMPTY
98968: LIST
98969: LIST
98970: PUSH
98971: LD_INT 5
98973: PUSH
98974: LD_INT 4
98976: PUSH
98977: EMPTY
98978: LIST
98979: LIST
98980: PUSH
98981: LD_INT 5
98983: PUSH
98984: LD_INT 5
98986: PUSH
98987: EMPTY
98988: LIST
98989: LIST
98990: PUSH
98991: LD_INT 4
98993: PUSH
98994: LD_INT 5
98996: PUSH
98997: EMPTY
98998: LIST
98999: LIST
99000: PUSH
99001: LD_INT 3
99003: PUSH
99004: LD_INT 4
99006: PUSH
99007: EMPTY
99008: LIST
99009: LIST
99010: PUSH
99011: LD_INT 3
99013: PUSH
99014: LD_INT 3
99016: PUSH
99017: EMPTY
99018: LIST
99019: LIST
99020: PUSH
99021: LD_INT 5
99023: PUSH
99024: LD_INT 3
99026: PUSH
99027: EMPTY
99028: LIST
99029: LIST
99030: PUSH
99031: LD_INT 3
99033: PUSH
99034: LD_INT 5
99036: PUSH
99037: EMPTY
99038: LIST
99039: LIST
99040: PUSH
99041: LD_INT 0
99043: PUSH
99044: LD_INT 3
99046: PUSH
99047: EMPTY
99048: LIST
99049: LIST
99050: PUSH
99051: LD_INT 0
99053: PUSH
99054: LD_INT 2
99056: PUSH
99057: EMPTY
99058: LIST
99059: LIST
99060: PUSH
99061: LD_INT 1
99063: PUSH
99064: LD_INT 3
99066: PUSH
99067: EMPTY
99068: LIST
99069: LIST
99070: PUSH
99071: LD_INT 1
99073: PUSH
99074: LD_INT 4
99076: PUSH
99077: EMPTY
99078: LIST
99079: LIST
99080: PUSH
99081: LD_INT 0
99083: PUSH
99084: LD_INT 4
99086: PUSH
99087: EMPTY
99088: LIST
99089: LIST
99090: PUSH
99091: LD_INT 1
99093: NEG
99094: PUSH
99095: LD_INT 3
99097: PUSH
99098: EMPTY
99099: LIST
99100: LIST
99101: PUSH
99102: LD_INT 1
99104: NEG
99105: PUSH
99106: LD_INT 2
99108: PUSH
99109: EMPTY
99110: LIST
99111: LIST
99112: PUSH
99113: LD_INT 2
99115: PUSH
99116: LD_INT 4
99118: PUSH
99119: EMPTY
99120: LIST
99121: LIST
99122: PUSH
99123: LD_INT 2
99125: NEG
99126: PUSH
99127: LD_INT 2
99129: PUSH
99130: EMPTY
99131: LIST
99132: LIST
99133: PUSH
99134: LD_INT 4
99136: NEG
99137: PUSH
99138: LD_INT 0
99140: PUSH
99141: EMPTY
99142: LIST
99143: LIST
99144: PUSH
99145: LD_INT 4
99147: NEG
99148: PUSH
99149: LD_INT 1
99151: NEG
99152: PUSH
99153: EMPTY
99154: LIST
99155: LIST
99156: PUSH
99157: LD_INT 3
99159: NEG
99160: PUSH
99161: LD_INT 0
99163: PUSH
99164: EMPTY
99165: LIST
99166: LIST
99167: PUSH
99168: LD_INT 3
99170: NEG
99171: PUSH
99172: LD_INT 1
99174: PUSH
99175: EMPTY
99176: LIST
99177: LIST
99178: PUSH
99179: LD_INT 4
99181: NEG
99182: PUSH
99183: LD_INT 1
99185: PUSH
99186: EMPTY
99187: LIST
99188: LIST
99189: PUSH
99190: LD_INT 5
99192: NEG
99193: PUSH
99194: LD_INT 0
99196: PUSH
99197: EMPTY
99198: LIST
99199: LIST
99200: PUSH
99201: LD_INT 5
99203: NEG
99204: PUSH
99205: LD_INT 1
99207: NEG
99208: PUSH
99209: EMPTY
99210: LIST
99211: LIST
99212: PUSH
99213: LD_INT 5
99215: NEG
99216: PUSH
99217: LD_INT 2
99219: NEG
99220: PUSH
99221: EMPTY
99222: LIST
99223: LIST
99224: PUSH
99225: LD_INT 3
99227: NEG
99228: PUSH
99229: LD_INT 2
99231: PUSH
99232: EMPTY
99233: LIST
99234: LIST
99235: PUSH
99236: LD_INT 3
99238: NEG
99239: PUSH
99240: LD_INT 3
99242: NEG
99243: PUSH
99244: EMPTY
99245: LIST
99246: LIST
99247: PUSH
99248: LD_INT 3
99250: NEG
99251: PUSH
99252: LD_INT 4
99254: NEG
99255: PUSH
99256: EMPTY
99257: LIST
99258: LIST
99259: PUSH
99260: LD_INT 2
99262: NEG
99263: PUSH
99264: LD_INT 3
99266: NEG
99267: PUSH
99268: EMPTY
99269: LIST
99270: LIST
99271: PUSH
99272: LD_INT 2
99274: NEG
99275: PUSH
99276: LD_INT 2
99278: NEG
99279: PUSH
99280: EMPTY
99281: LIST
99282: LIST
99283: PUSH
99284: LD_INT 3
99286: NEG
99287: PUSH
99288: LD_INT 2
99290: NEG
99291: PUSH
99292: EMPTY
99293: LIST
99294: LIST
99295: PUSH
99296: LD_INT 4
99298: NEG
99299: PUSH
99300: LD_INT 3
99302: NEG
99303: PUSH
99304: EMPTY
99305: LIST
99306: LIST
99307: PUSH
99308: LD_INT 4
99310: NEG
99311: PUSH
99312: LD_INT 4
99314: NEG
99315: PUSH
99316: EMPTY
99317: LIST
99318: LIST
99319: PUSH
99320: LD_INT 2
99322: NEG
99323: PUSH
99324: LD_INT 4
99326: NEG
99327: PUSH
99328: EMPTY
99329: LIST
99330: LIST
99331: PUSH
99332: LD_INT 4
99334: NEG
99335: PUSH
99336: LD_INT 2
99338: NEG
99339: PUSH
99340: EMPTY
99341: LIST
99342: LIST
99343: PUSH
99344: LD_INT 0
99346: PUSH
99347: LD_INT 4
99349: NEG
99350: PUSH
99351: EMPTY
99352: LIST
99353: LIST
99354: PUSH
99355: LD_INT 0
99357: PUSH
99358: LD_INT 5
99360: NEG
99361: PUSH
99362: EMPTY
99363: LIST
99364: LIST
99365: PUSH
99366: LD_INT 1
99368: PUSH
99369: LD_INT 4
99371: NEG
99372: PUSH
99373: EMPTY
99374: LIST
99375: LIST
99376: PUSH
99377: LD_INT 1
99379: PUSH
99380: LD_INT 3
99382: NEG
99383: PUSH
99384: EMPTY
99385: LIST
99386: LIST
99387: PUSH
99388: LD_INT 0
99390: PUSH
99391: LD_INT 3
99393: NEG
99394: PUSH
99395: EMPTY
99396: LIST
99397: LIST
99398: PUSH
99399: LD_INT 1
99401: NEG
99402: PUSH
99403: LD_INT 4
99405: NEG
99406: PUSH
99407: EMPTY
99408: LIST
99409: LIST
99410: PUSH
99411: LD_INT 1
99413: NEG
99414: PUSH
99415: LD_INT 5
99417: NEG
99418: PUSH
99419: EMPTY
99420: LIST
99421: LIST
99422: PUSH
99423: LD_INT 2
99425: PUSH
99426: LD_INT 3
99428: NEG
99429: PUSH
99430: EMPTY
99431: LIST
99432: LIST
99433: PUSH
99434: LD_INT 2
99436: NEG
99437: PUSH
99438: LD_INT 5
99440: NEG
99441: PUSH
99442: EMPTY
99443: LIST
99444: LIST
99445: PUSH
99446: EMPTY
99447: LIST
99448: LIST
99449: LIST
99450: LIST
99451: LIST
99452: LIST
99453: LIST
99454: LIST
99455: LIST
99456: LIST
99457: LIST
99458: LIST
99459: LIST
99460: LIST
99461: LIST
99462: LIST
99463: LIST
99464: LIST
99465: LIST
99466: LIST
99467: LIST
99468: LIST
99469: LIST
99470: LIST
99471: LIST
99472: LIST
99473: LIST
99474: LIST
99475: LIST
99476: LIST
99477: LIST
99478: LIST
99479: LIST
99480: LIST
99481: LIST
99482: LIST
99483: LIST
99484: LIST
99485: LIST
99486: LIST
99487: LIST
99488: LIST
99489: LIST
99490: LIST
99491: LIST
99492: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
99493: LD_ADDR_VAR 0 31
99497: PUSH
99498: LD_INT 0
99500: PUSH
99501: LD_INT 4
99503: PUSH
99504: EMPTY
99505: LIST
99506: LIST
99507: PUSH
99508: LD_INT 0
99510: PUSH
99511: LD_INT 3
99513: PUSH
99514: EMPTY
99515: LIST
99516: LIST
99517: PUSH
99518: LD_INT 1
99520: PUSH
99521: LD_INT 4
99523: PUSH
99524: EMPTY
99525: LIST
99526: LIST
99527: PUSH
99528: LD_INT 1
99530: PUSH
99531: LD_INT 5
99533: PUSH
99534: EMPTY
99535: LIST
99536: LIST
99537: PUSH
99538: LD_INT 0
99540: PUSH
99541: LD_INT 5
99543: PUSH
99544: EMPTY
99545: LIST
99546: LIST
99547: PUSH
99548: LD_INT 1
99550: NEG
99551: PUSH
99552: LD_INT 4
99554: PUSH
99555: EMPTY
99556: LIST
99557: LIST
99558: PUSH
99559: LD_INT 1
99561: NEG
99562: PUSH
99563: LD_INT 3
99565: PUSH
99566: EMPTY
99567: LIST
99568: LIST
99569: PUSH
99570: LD_INT 2
99572: PUSH
99573: LD_INT 5
99575: PUSH
99576: EMPTY
99577: LIST
99578: LIST
99579: PUSH
99580: LD_INT 2
99582: NEG
99583: PUSH
99584: LD_INT 3
99586: PUSH
99587: EMPTY
99588: LIST
99589: LIST
99590: PUSH
99591: LD_INT 3
99593: NEG
99594: PUSH
99595: LD_INT 0
99597: PUSH
99598: EMPTY
99599: LIST
99600: LIST
99601: PUSH
99602: LD_INT 3
99604: NEG
99605: PUSH
99606: LD_INT 1
99608: NEG
99609: PUSH
99610: EMPTY
99611: LIST
99612: LIST
99613: PUSH
99614: LD_INT 2
99616: NEG
99617: PUSH
99618: LD_INT 0
99620: PUSH
99621: EMPTY
99622: LIST
99623: LIST
99624: PUSH
99625: LD_INT 2
99627: NEG
99628: PUSH
99629: LD_INT 1
99631: PUSH
99632: EMPTY
99633: LIST
99634: LIST
99635: PUSH
99636: LD_INT 3
99638: NEG
99639: PUSH
99640: LD_INT 1
99642: PUSH
99643: EMPTY
99644: LIST
99645: LIST
99646: PUSH
99647: LD_INT 4
99649: NEG
99650: PUSH
99651: LD_INT 0
99653: PUSH
99654: EMPTY
99655: LIST
99656: LIST
99657: PUSH
99658: LD_INT 4
99660: NEG
99661: PUSH
99662: LD_INT 1
99664: NEG
99665: PUSH
99666: EMPTY
99667: LIST
99668: LIST
99669: PUSH
99670: LD_INT 4
99672: NEG
99673: PUSH
99674: LD_INT 2
99676: NEG
99677: PUSH
99678: EMPTY
99679: LIST
99680: LIST
99681: PUSH
99682: LD_INT 2
99684: NEG
99685: PUSH
99686: LD_INT 2
99688: PUSH
99689: EMPTY
99690: LIST
99691: LIST
99692: PUSH
99693: LD_INT 4
99695: NEG
99696: PUSH
99697: LD_INT 4
99699: NEG
99700: PUSH
99701: EMPTY
99702: LIST
99703: LIST
99704: PUSH
99705: LD_INT 4
99707: NEG
99708: PUSH
99709: LD_INT 5
99711: NEG
99712: PUSH
99713: EMPTY
99714: LIST
99715: LIST
99716: PUSH
99717: LD_INT 3
99719: NEG
99720: PUSH
99721: LD_INT 4
99723: NEG
99724: PUSH
99725: EMPTY
99726: LIST
99727: LIST
99728: PUSH
99729: LD_INT 3
99731: NEG
99732: PUSH
99733: LD_INT 3
99735: NEG
99736: PUSH
99737: EMPTY
99738: LIST
99739: LIST
99740: PUSH
99741: LD_INT 4
99743: NEG
99744: PUSH
99745: LD_INT 3
99747: NEG
99748: PUSH
99749: EMPTY
99750: LIST
99751: LIST
99752: PUSH
99753: LD_INT 5
99755: NEG
99756: PUSH
99757: LD_INT 4
99759: NEG
99760: PUSH
99761: EMPTY
99762: LIST
99763: LIST
99764: PUSH
99765: LD_INT 5
99767: NEG
99768: PUSH
99769: LD_INT 5
99771: NEG
99772: PUSH
99773: EMPTY
99774: LIST
99775: LIST
99776: PUSH
99777: LD_INT 3
99779: NEG
99780: PUSH
99781: LD_INT 5
99783: NEG
99784: PUSH
99785: EMPTY
99786: LIST
99787: LIST
99788: PUSH
99789: LD_INT 5
99791: NEG
99792: PUSH
99793: LD_INT 3
99795: NEG
99796: PUSH
99797: EMPTY
99798: LIST
99799: LIST
99800: PUSH
99801: LD_INT 0
99803: PUSH
99804: LD_INT 3
99806: NEG
99807: PUSH
99808: EMPTY
99809: LIST
99810: LIST
99811: PUSH
99812: LD_INT 0
99814: PUSH
99815: LD_INT 4
99817: NEG
99818: PUSH
99819: EMPTY
99820: LIST
99821: LIST
99822: PUSH
99823: LD_INT 1
99825: PUSH
99826: LD_INT 3
99828: NEG
99829: PUSH
99830: EMPTY
99831: LIST
99832: LIST
99833: PUSH
99834: LD_INT 1
99836: PUSH
99837: LD_INT 2
99839: NEG
99840: PUSH
99841: EMPTY
99842: LIST
99843: LIST
99844: PUSH
99845: LD_INT 0
99847: PUSH
99848: LD_INT 2
99850: NEG
99851: PUSH
99852: EMPTY
99853: LIST
99854: LIST
99855: PUSH
99856: LD_INT 1
99858: NEG
99859: PUSH
99860: LD_INT 3
99862: NEG
99863: PUSH
99864: EMPTY
99865: LIST
99866: LIST
99867: PUSH
99868: LD_INT 1
99870: NEG
99871: PUSH
99872: LD_INT 4
99874: NEG
99875: PUSH
99876: EMPTY
99877: LIST
99878: LIST
99879: PUSH
99880: LD_INT 2
99882: PUSH
99883: LD_INT 2
99885: NEG
99886: PUSH
99887: EMPTY
99888: LIST
99889: LIST
99890: PUSH
99891: LD_INT 2
99893: NEG
99894: PUSH
99895: LD_INT 4
99897: NEG
99898: PUSH
99899: EMPTY
99900: LIST
99901: LIST
99902: PUSH
99903: LD_INT 4
99905: PUSH
99906: LD_INT 0
99908: PUSH
99909: EMPTY
99910: LIST
99911: LIST
99912: PUSH
99913: LD_INT 4
99915: PUSH
99916: LD_INT 1
99918: NEG
99919: PUSH
99920: EMPTY
99921: LIST
99922: LIST
99923: PUSH
99924: LD_INT 5
99926: PUSH
99927: LD_INT 0
99929: PUSH
99930: EMPTY
99931: LIST
99932: LIST
99933: PUSH
99934: LD_INT 5
99936: PUSH
99937: LD_INT 1
99939: PUSH
99940: EMPTY
99941: LIST
99942: LIST
99943: PUSH
99944: LD_INT 4
99946: PUSH
99947: LD_INT 1
99949: PUSH
99950: EMPTY
99951: LIST
99952: LIST
99953: PUSH
99954: LD_INT 3
99956: PUSH
99957: LD_INT 0
99959: PUSH
99960: EMPTY
99961: LIST
99962: LIST
99963: PUSH
99964: LD_INT 3
99966: PUSH
99967: LD_INT 1
99969: NEG
99970: PUSH
99971: EMPTY
99972: LIST
99973: LIST
99974: PUSH
99975: LD_INT 3
99977: PUSH
99978: LD_INT 2
99980: NEG
99981: PUSH
99982: EMPTY
99983: LIST
99984: LIST
99985: PUSH
99986: LD_INT 5
99988: PUSH
99989: LD_INT 2
99991: PUSH
99992: EMPTY
99993: LIST
99994: LIST
99995: PUSH
99996: EMPTY
99997: LIST
99998: LIST
99999: LIST
100000: LIST
100001: LIST
100002: LIST
100003: LIST
100004: LIST
100005: LIST
100006: LIST
100007: LIST
100008: LIST
100009: LIST
100010: LIST
100011: LIST
100012: LIST
100013: LIST
100014: LIST
100015: LIST
100016: LIST
100017: LIST
100018: LIST
100019: LIST
100020: LIST
100021: LIST
100022: LIST
100023: LIST
100024: LIST
100025: LIST
100026: LIST
100027: LIST
100028: LIST
100029: LIST
100030: LIST
100031: LIST
100032: LIST
100033: LIST
100034: LIST
100035: LIST
100036: LIST
100037: LIST
100038: LIST
100039: LIST
100040: LIST
100041: LIST
100042: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
100043: LD_ADDR_VAR 0 32
100047: PUSH
100048: LD_INT 4
100050: NEG
100051: PUSH
100052: LD_INT 0
100054: PUSH
100055: EMPTY
100056: LIST
100057: LIST
100058: PUSH
100059: LD_INT 4
100061: NEG
100062: PUSH
100063: LD_INT 1
100065: NEG
100066: PUSH
100067: EMPTY
100068: LIST
100069: LIST
100070: PUSH
100071: LD_INT 3
100073: NEG
100074: PUSH
100075: LD_INT 0
100077: PUSH
100078: EMPTY
100079: LIST
100080: LIST
100081: PUSH
100082: LD_INT 3
100084: NEG
100085: PUSH
100086: LD_INT 1
100088: PUSH
100089: EMPTY
100090: LIST
100091: LIST
100092: PUSH
100093: LD_INT 4
100095: NEG
100096: PUSH
100097: LD_INT 1
100099: PUSH
100100: EMPTY
100101: LIST
100102: LIST
100103: PUSH
100104: LD_INT 5
100106: NEG
100107: PUSH
100108: LD_INT 0
100110: PUSH
100111: EMPTY
100112: LIST
100113: LIST
100114: PUSH
100115: LD_INT 5
100117: NEG
100118: PUSH
100119: LD_INT 1
100121: NEG
100122: PUSH
100123: EMPTY
100124: LIST
100125: LIST
100126: PUSH
100127: LD_INT 5
100129: NEG
100130: PUSH
100131: LD_INT 2
100133: NEG
100134: PUSH
100135: EMPTY
100136: LIST
100137: LIST
100138: PUSH
100139: LD_INT 3
100141: NEG
100142: PUSH
100143: LD_INT 2
100145: PUSH
100146: EMPTY
100147: LIST
100148: LIST
100149: PUSH
100150: LD_INT 3
100152: NEG
100153: PUSH
100154: LD_INT 3
100156: NEG
100157: PUSH
100158: EMPTY
100159: LIST
100160: LIST
100161: PUSH
100162: LD_INT 3
100164: NEG
100165: PUSH
100166: LD_INT 4
100168: NEG
100169: PUSH
100170: EMPTY
100171: LIST
100172: LIST
100173: PUSH
100174: LD_INT 2
100176: NEG
100177: PUSH
100178: LD_INT 3
100180: NEG
100181: PUSH
100182: EMPTY
100183: LIST
100184: LIST
100185: PUSH
100186: LD_INT 2
100188: NEG
100189: PUSH
100190: LD_INT 2
100192: NEG
100193: PUSH
100194: EMPTY
100195: LIST
100196: LIST
100197: PUSH
100198: LD_INT 3
100200: NEG
100201: PUSH
100202: LD_INT 2
100204: NEG
100205: PUSH
100206: EMPTY
100207: LIST
100208: LIST
100209: PUSH
100210: LD_INT 4
100212: NEG
100213: PUSH
100214: LD_INT 3
100216: NEG
100217: PUSH
100218: EMPTY
100219: LIST
100220: LIST
100221: PUSH
100222: LD_INT 4
100224: NEG
100225: PUSH
100226: LD_INT 4
100228: NEG
100229: PUSH
100230: EMPTY
100231: LIST
100232: LIST
100233: PUSH
100234: LD_INT 2
100236: NEG
100237: PUSH
100238: LD_INT 4
100240: NEG
100241: PUSH
100242: EMPTY
100243: LIST
100244: LIST
100245: PUSH
100246: LD_INT 4
100248: NEG
100249: PUSH
100250: LD_INT 2
100252: NEG
100253: PUSH
100254: EMPTY
100255: LIST
100256: LIST
100257: PUSH
100258: LD_INT 0
100260: PUSH
100261: LD_INT 4
100263: NEG
100264: PUSH
100265: EMPTY
100266: LIST
100267: LIST
100268: PUSH
100269: LD_INT 0
100271: PUSH
100272: LD_INT 5
100274: NEG
100275: PUSH
100276: EMPTY
100277: LIST
100278: LIST
100279: PUSH
100280: LD_INT 1
100282: PUSH
100283: LD_INT 4
100285: NEG
100286: PUSH
100287: EMPTY
100288: LIST
100289: LIST
100290: PUSH
100291: LD_INT 1
100293: PUSH
100294: LD_INT 3
100296: NEG
100297: PUSH
100298: EMPTY
100299: LIST
100300: LIST
100301: PUSH
100302: LD_INT 0
100304: PUSH
100305: LD_INT 3
100307: NEG
100308: PUSH
100309: EMPTY
100310: LIST
100311: LIST
100312: PUSH
100313: LD_INT 1
100315: NEG
100316: PUSH
100317: LD_INT 4
100319: NEG
100320: PUSH
100321: EMPTY
100322: LIST
100323: LIST
100324: PUSH
100325: LD_INT 1
100327: NEG
100328: PUSH
100329: LD_INT 5
100331: NEG
100332: PUSH
100333: EMPTY
100334: LIST
100335: LIST
100336: PUSH
100337: LD_INT 2
100339: PUSH
100340: LD_INT 3
100342: NEG
100343: PUSH
100344: EMPTY
100345: LIST
100346: LIST
100347: PUSH
100348: LD_INT 2
100350: NEG
100351: PUSH
100352: LD_INT 5
100354: NEG
100355: PUSH
100356: EMPTY
100357: LIST
100358: LIST
100359: PUSH
100360: LD_INT 3
100362: PUSH
100363: LD_INT 0
100365: PUSH
100366: EMPTY
100367: LIST
100368: LIST
100369: PUSH
100370: LD_INT 3
100372: PUSH
100373: LD_INT 1
100375: NEG
100376: PUSH
100377: EMPTY
100378: LIST
100379: LIST
100380: PUSH
100381: LD_INT 4
100383: PUSH
100384: LD_INT 0
100386: PUSH
100387: EMPTY
100388: LIST
100389: LIST
100390: PUSH
100391: LD_INT 4
100393: PUSH
100394: LD_INT 1
100396: PUSH
100397: EMPTY
100398: LIST
100399: LIST
100400: PUSH
100401: LD_INT 3
100403: PUSH
100404: LD_INT 1
100406: PUSH
100407: EMPTY
100408: LIST
100409: LIST
100410: PUSH
100411: LD_INT 2
100413: PUSH
100414: LD_INT 0
100416: PUSH
100417: EMPTY
100418: LIST
100419: LIST
100420: PUSH
100421: LD_INT 2
100423: PUSH
100424: LD_INT 1
100426: NEG
100427: PUSH
100428: EMPTY
100429: LIST
100430: LIST
100431: PUSH
100432: LD_INT 2
100434: PUSH
100435: LD_INT 2
100437: NEG
100438: PUSH
100439: EMPTY
100440: LIST
100441: LIST
100442: PUSH
100443: LD_INT 4
100445: PUSH
100446: LD_INT 2
100448: PUSH
100449: EMPTY
100450: LIST
100451: LIST
100452: PUSH
100453: LD_INT 4
100455: PUSH
100456: LD_INT 4
100458: PUSH
100459: EMPTY
100460: LIST
100461: LIST
100462: PUSH
100463: LD_INT 4
100465: PUSH
100466: LD_INT 3
100468: PUSH
100469: EMPTY
100470: LIST
100471: LIST
100472: PUSH
100473: LD_INT 5
100475: PUSH
100476: LD_INT 4
100478: PUSH
100479: EMPTY
100480: LIST
100481: LIST
100482: PUSH
100483: LD_INT 5
100485: PUSH
100486: LD_INT 5
100488: PUSH
100489: EMPTY
100490: LIST
100491: LIST
100492: PUSH
100493: LD_INT 4
100495: PUSH
100496: LD_INT 5
100498: PUSH
100499: EMPTY
100500: LIST
100501: LIST
100502: PUSH
100503: LD_INT 3
100505: PUSH
100506: LD_INT 4
100508: PUSH
100509: EMPTY
100510: LIST
100511: LIST
100512: PUSH
100513: LD_INT 3
100515: PUSH
100516: LD_INT 3
100518: PUSH
100519: EMPTY
100520: LIST
100521: LIST
100522: PUSH
100523: LD_INT 5
100525: PUSH
100526: LD_INT 3
100528: PUSH
100529: EMPTY
100530: LIST
100531: LIST
100532: PUSH
100533: LD_INT 3
100535: PUSH
100536: LD_INT 5
100538: PUSH
100539: EMPTY
100540: LIST
100541: LIST
100542: PUSH
100543: EMPTY
100544: LIST
100545: LIST
100546: LIST
100547: LIST
100548: LIST
100549: LIST
100550: LIST
100551: LIST
100552: LIST
100553: LIST
100554: LIST
100555: LIST
100556: LIST
100557: LIST
100558: LIST
100559: LIST
100560: LIST
100561: LIST
100562: LIST
100563: LIST
100564: LIST
100565: LIST
100566: LIST
100567: LIST
100568: LIST
100569: LIST
100570: LIST
100571: LIST
100572: LIST
100573: LIST
100574: LIST
100575: LIST
100576: LIST
100577: LIST
100578: LIST
100579: LIST
100580: LIST
100581: LIST
100582: LIST
100583: LIST
100584: LIST
100585: LIST
100586: LIST
100587: LIST
100588: LIST
100589: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
100590: LD_ADDR_VAR 0 33
100594: PUSH
100595: LD_INT 4
100597: NEG
100598: PUSH
100599: LD_INT 4
100601: NEG
100602: PUSH
100603: EMPTY
100604: LIST
100605: LIST
100606: PUSH
100607: LD_INT 4
100609: NEG
100610: PUSH
100611: LD_INT 5
100613: NEG
100614: PUSH
100615: EMPTY
100616: LIST
100617: LIST
100618: PUSH
100619: LD_INT 3
100621: NEG
100622: PUSH
100623: LD_INT 4
100625: NEG
100626: PUSH
100627: EMPTY
100628: LIST
100629: LIST
100630: PUSH
100631: LD_INT 3
100633: NEG
100634: PUSH
100635: LD_INT 3
100637: NEG
100638: PUSH
100639: EMPTY
100640: LIST
100641: LIST
100642: PUSH
100643: LD_INT 4
100645: NEG
100646: PUSH
100647: LD_INT 3
100649: NEG
100650: PUSH
100651: EMPTY
100652: LIST
100653: LIST
100654: PUSH
100655: LD_INT 5
100657: NEG
100658: PUSH
100659: LD_INT 4
100661: NEG
100662: PUSH
100663: EMPTY
100664: LIST
100665: LIST
100666: PUSH
100667: LD_INT 5
100669: NEG
100670: PUSH
100671: LD_INT 5
100673: NEG
100674: PUSH
100675: EMPTY
100676: LIST
100677: LIST
100678: PUSH
100679: LD_INT 3
100681: NEG
100682: PUSH
100683: LD_INT 5
100685: NEG
100686: PUSH
100687: EMPTY
100688: LIST
100689: LIST
100690: PUSH
100691: LD_INT 5
100693: NEG
100694: PUSH
100695: LD_INT 3
100697: NEG
100698: PUSH
100699: EMPTY
100700: LIST
100701: LIST
100702: PUSH
100703: LD_INT 0
100705: PUSH
100706: LD_INT 3
100708: NEG
100709: PUSH
100710: EMPTY
100711: LIST
100712: LIST
100713: PUSH
100714: LD_INT 0
100716: PUSH
100717: LD_INT 4
100719: NEG
100720: PUSH
100721: EMPTY
100722: LIST
100723: LIST
100724: PUSH
100725: LD_INT 1
100727: PUSH
100728: LD_INT 3
100730: NEG
100731: PUSH
100732: EMPTY
100733: LIST
100734: LIST
100735: PUSH
100736: LD_INT 1
100738: PUSH
100739: LD_INT 2
100741: NEG
100742: PUSH
100743: EMPTY
100744: LIST
100745: LIST
100746: PUSH
100747: LD_INT 0
100749: PUSH
100750: LD_INT 2
100752: NEG
100753: PUSH
100754: EMPTY
100755: LIST
100756: LIST
100757: PUSH
100758: LD_INT 1
100760: NEG
100761: PUSH
100762: LD_INT 3
100764: NEG
100765: PUSH
100766: EMPTY
100767: LIST
100768: LIST
100769: PUSH
100770: LD_INT 1
100772: NEG
100773: PUSH
100774: LD_INT 4
100776: NEG
100777: PUSH
100778: EMPTY
100779: LIST
100780: LIST
100781: PUSH
100782: LD_INT 2
100784: PUSH
100785: LD_INT 2
100787: NEG
100788: PUSH
100789: EMPTY
100790: LIST
100791: LIST
100792: PUSH
100793: LD_INT 2
100795: NEG
100796: PUSH
100797: LD_INT 4
100799: NEG
100800: PUSH
100801: EMPTY
100802: LIST
100803: LIST
100804: PUSH
100805: LD_INT 4
100807: PUSH
100808: LD_INT 0
100810: PUSH
100811: EMPTY
100812: LIST
100813: LIST
100814: PUSH
100815: LD_INT 4
100817: PUSH
100818: LD_INT 1
100820: NEG
100821: PUSH
100822: EMPTY
100823: LIST
100824: LIST
100825: PUSH
100826: LD_INT 5
100828: PUSH
100829: LD_INT 0
100831: PUSH
100832: EMPTY
100833: LIST
100834: LIST
100835: PUSH
100836: LD_INT 5
100838: PUSH
100839: LD_INT 1
100841: PUSH
100842: EMPTY
100843: LIST
100844: LIST
100845: PUSH
100846: LD_INT 4
100848: PUSH
100849: LD_INT 1
100851: PUSH
100852: EMPTY
100853: LIST
100854: LIST
100855: PUSH
100856: LD_INT 3
100858: PUSH
100859: LD_INT 0
100861: PUSH
100862: EMPTY
100863: LIST
100864: LIST
100865: PUSH
100866: LD_INT 3
100868: PUSH
100869: LD_INT 1
100871: NEG
100872: PUSH
100873: EMPTY
100874: LIST
100875: LIST
100876: PUSH
100877: LD_INT 3
100879: PUSH
100880: LD_INT 2
100882: NEG
100883: PUSH
100884: EMPTY
100885: LIST
100886: LIST
100887: PUSH
100888: LD_INT 5
100890: PUSH
100891: LD_INT 2
100893: PUSH
100894: EMPTY
100895: LIST
100896: LIST
100897: PUSH
100898: LD_INT 3
100900: PUSH
100901: LD_INT 3
100903: PUSH
100904: EMPTY
100905: LIST
100906: LIST
100907: PUSH
100908: LD_INT 3
100910: PUSH
100911: LD_INT 2
100913: PUSH
100914: EMPTY
100915: LIST
100916: LIST
100917: PUSH
100918: LD_INT 4
100920: PUSH
100921: LD_INT 3
100923: PUSH
100924: EMPTY
100925: LIST
100926: LIST
100927: PUSH
100928: LD_INT 4
100930: PUSH
100931: LD_INT 4
100933: PUSH
100934: EMPTY
100935: LIST
100936: LIST
100937: PUSH
100938: LD_INT 3
100940: PUSH
100941: LD_INT 4
100943: PUSH
100944: EMPTY
100945: LIST
100946: LIST
100947: PUSH
100948: LD_INT 2
100950: PUSH
100951: LD_INT 3
100953: PUSH
100954: EMPTY
100955: LIST
100956: LIST
100957: PUSH
100958: LD_INT 2
100960: PUSH
100961: LD_INT 2
100963: PUSH
100964: EMPTY
100965: LIST
100966: LIST
100967: PUSH
100968: LD_INT 4
100970: PUSH
100971: LD_INT 2
100973: PUSH
100974: EMPTY
100975: LIST
100976: LIST
100977: PUSH
100978: LD_INT 2
100980: PUSH
100981: LD_INT 4
100983: PUSH
100984: EMPTY
100985: LIST
100986: LIST
100987: PUSH
100988: LD_INT 0
100990: PUSH
100991: LD_INT 4
100993: PUSH
100994: EMPTY
100995: LIST
100996: LIST
100997: PUSH
100998: LD_INT 0
101000: PUSH
101001: LD_INT 3
101003: PUSH
101004: EMPTY
101005: LIST
101006: LIST
101007: PUSH
101008: LD_INT 1
101010: PUSH
101011: LD_INT 4
101013: PUSH
101014: EMPTY
101015: LIST
101016: LIST
101017: PUSH
101018: LD_INT 1
101020: PUSH
101021: LD_INT 5
101023: PUSH
101024: EMPTY
101025: LIST
101026: LIST
101027: PUSH
101028: LD_INT 0
101030: PUSH
101031: LD_INT 5
101033: PUSH
101034: EMPTY
101035: LIST
101036: LIST
101037: PUSH
101038: LD_INT 1
101040: NEG
101041: PUSH
101042: LD_INT 4
101044: PUSH
101045: EMPTY
101046: LIST
101047: LIST
101048: PUSH
101049: LD_INT 1
101051: NEG
101052: PUSH
101053: LD_INT 3
101055: PUSH
101056: EMPTY
101057: LIST
101058: LIST
101059: PUSH
101060: LD_INT 2
101062: PUSH
101063: LD_INT 5
101065: PUSH
101066: EMPTY
101067: LIST
101068: LIST
101069: PUSH
101070: LD_INT 2
101072: NEG
101073: PUSH
101074: LD_INT 3
101076: PUSH
101077: EMPTY
101078: LIST
101079: LIST
101080: PUSH
101081: EMPTY
101082: LIST
101083: LIST
101084: LIST
101085: LIST
101086: LIST
101087: LIST
101088: LIST
101089: LIST
101090: LIST
101091: LIST
101092: LIST
101093: LIST
101094: LIST
101095: LIST
101096: LIST
101097: LIST
101098: LIST
101099: LIST
101100: LIST
101101: LIST
101102: LIST
101103: LIST
101104: LIST
101105: LIST
101106: LIST
101107: LIST
101108: LIST
101109: LIST
101110: LIST
101111: LIST
101112: LIST
101113: LIST
101114: LIST
101115: LIST
101116: LIST
101117: LIST
101118: LIST
101119: LIST
101120: LIST
101121: LIST
101122: LIST
101123: LIST
101124: LIST
101125: LIST
101126: LIST
101127: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
101128: LD_ADDR_VAR 0 34
101132: PUSH
101133: LD_INT 0
101135: PUSH
101136: LD_INT 4
101138: NEG
101139: PUSH
101140: EMPTY
101141: LIST
101142: LIST
101143: PUSH
101144: LD_INT 0
101146: PUSH
101147: LD_INT 5
101149: NEG
101150: PUSH
101151: EMPTY
101152: LIST
101153: LIST
101154: PUSH
101155: LD_INT 1
101157: PUSH
101158: LD_INT 4
101160: NEG
101161: PUSH
101162: EMPTY
101163: LIST
101164: LIST
101165: PUSH
101166: LD_INT 1
101168: PUSH
101169: LD_INT 3
101171: NEG
101172: PUSH
101173: EMPTY
101174: LIST
101175: LIST
101176: PUSH
101177: LD_INT 0
101179: PUSH
101180: LD_INT 3
101182: NEG
101183: PUSH
101184: EMPTY
101185: LIST
101186: LIST
101187: PUSH
101188: LD_INT 1
101190: NEG
101191: PUSH
101192: LD_INT 4
101194: NEG
101195: PUSH
101196: EMPTY
101197: LIST
101198: LIST
101199: PUSH
101200: LD_INT 1
101202: NEG
101203: PUSH
101204: LD_INT 5
101206: NEG
101207: PUSH
101208: EMPTY
101209: LIST
101210: LIST
101211: PUSH
101212: LD_INT 2
101214: PUSH
101215: LD_INT 3
101217: NEG
101218: PUSH
101219: EMPTY
101220: LIST
101221: LIST
101222: PUSH
101223: LD_INT 2
101225: NEG
101226: PUSH
101227: LD_INT 5
101229: NEG
101230: PUSH
101231: EMPTY
101232: LIST
101233: LIST
101234: PUSH
101235: LD_INT 3
101237: PUSH
101238: LD_INT 0
101240: PUSH
101241: EMPTY
101242: LIST
101243: LIST
101244: PUSH
101245: LD_INT 3
101247: PUSH
101248: LD_INT 1
101250: NEG
101251: PUSH
101252: EMPTY
101253: LIST
101254: LIST
101255: PUSH
101256: LD_INT 4
101258: PUSH
101259: LD_INT 0
101261: PUSH
101262: EMPTY
101263: LIST
101264: LIST
101265: PUSH
101266: LD_INT 4
101268: PUSH
101269: LD_INT 1
101271: PUSH
101272: EMPTY
101273: LIST
101274: LIST
101275: PUSH
101276: LD_INT 3
101278: PUSH
101279: LD_INT 1
101281: PUSH
101282: EMPTY
101283: LIST
101284: LIST
101285: PUSH
101286: LD_INT 2
101288: PUSH
101289: LD_INT 0
101291: PUSH
101292: EMPTY
101293: LIST
101294: LIST
101295: PUSH
101296: LD_INT 2
101298: PUSH
101299: LD_INT 1
101301: NEG
101302: PUSH
101303: EMPTY
101304: LIST
101305: LIST
101306: PUSH
101307: LD_INT 2
101309: PUSH
101310: LD_INT 2
101312: NEG
101313: PUSH
101314: EMPTY
101315: LIST
101316: LIST
101317: PUSH
101318: LD_INT 4
101320: PUSH
101321: LD_INT 2
101323: PUSH
101324: EMPTY
101325: LIST
101326: LIST
101327: PUSH
101328: LD_INT 4
101330: PUSH
101331: LD_INT 4
101333: PUSH
101334: EMPTY
101335: LIST
101336: LIST
101337: PUSH
101338: LD_INT 4
101340: PUSH
101341: LD_INT 3
101343: PUSH
101344: EMPTY
101345: LIST
101346: LIST
101347: PUSH
101348: LD_INT 5
101350: PUSH
101351: LD_INT 4
101353: PUSH
101354: EMPTY
101355: LIST
101356: LIST
101357: PUSH
101358: LD_INT 5
101360: PUSH
101361: LD_INT 5
101363: PUSH
101364: EMPTY
101365: LIST
101366: LIST
101367: PUSH
101368: LD_INT 4
101370: PUSH
101371: LD_INT 5
101373: PUSH
101374: EMPTY
101375: LIST
101376: LIST
101377: PUSH
101378: LD_INT 3
101380: PUSH
101381: LD_INT 4
101383: PUSH
101384: EMPTY
101385: LIST
101386: LIST
101387: PUSH
101388: LD_INT 3
101390: PUSH
101391: LD_INT 3
101393: PUSH
101394: EMPTY
101395: LIST
101396: LIST
101397: PUSH
101398: LD_INT 5
101400: PUSH
101401: LD_INT 3
101403: PUSH
101404: EMPTY
101405: LIST
101406: LIST
101407: PUSH
101408: LD_INT 3
101410: PUSH
101411: LD_INT 5
101413: PUSH
101414: EMPTY
101415: LIST
101416: LIST
101417: PUSH
101418: LD_INT 0
101420: PUSH
101421: LD_INT 3
101423: PUSH
101424: EMPTY
101425: LIST
101426: LIST
101427: PUSH
101428: LD_INT 0
101430: PUSH
101431: LD_INT 2
101433: PUSH
101434: EMPTY
101435: LIST
101436: LIST
101437: PUSH
101438: LD_INT 1
101440: PUSH
101441: LD_INT 3
101443: PUSH
101444: EMPTY
101445: LIST
101446: LIST
101447: PUSH
101448: LD_INT 1
101450: PUSH
101451: LD_INT 4
101453: PUSH
101454: EMPTY
101455: LIST
101456: LIST
101457: PUSH
101458: LD_INT 0
101460: PUSH
101461: LD_INT 4
101463: PUSH
101464: EMPTY
101465: LIST
101466: LIST
101467: PUSH
101468: LD_INT 1
101470: NEG
101471: PUSH
101472: LD_INT 3
101474: PUSH
101475: EMPTY
101476: LIST
101477: LIST
101478: PUSH
101479: LD_INT 1
101481: NEG
101482: PUSH
101483: LD_INT 2
101485: PUSH
101486: EMPTY
101487: LIST
101488: LIST
101489: PUSH
101490: LD_INT 2
101492: PUSH
101493: LD_INT 4
101495: PUSH
101496: EMPTY
101497: LIST
101498: LIST
101499: PUSH
101500: LD_INT 2
101502: NEG
101503: PUSH
101504: LD_INT 2
101506: PUSH
101507: EMPTY
101508: LIST
101509: LIST
101510: PUSH
101511: LD_INT 4
101513: NEG
101514: PUSH
101515: LD_INT 0
101517: PUSH
101518: EMPTY
101519: LIST
101520: LIST
101521: PUSH
101522: LD_INT 4
101524: NEG
101525: PUSH
101526: LD_INT 1
101528: NEG
101529: PUSH
101530: EMPTY
101531: LIST
101532: LIST
101533: PUSH
101534: LD_INT 3
101536: NEG
101537: PUSH
101538: LD_INT 0
101540: PUSH
101541: EMPTY
101542: LIST
101543: LIST
101544: PUSH
101545: LD_INT 3
101547: NEG
101548: PUSH
101549: LD_INT 1
101551: PUSH
101552: EMPTY
101553: LIST
101554: LIST
101555: PUSH
101556: LD_INT 4
101558: NEG
101559: PUSH
101560: LD_INT 1
101562: PUSH
101563: EMPTY
101564: LIST
101565: LIST
101566: PUSH
101567: LD_INT 5
101569: NEG
101570: PUSH
101571: LD_INT 0
101573: PUSH
101574: EMPTY
101575: LIST
101576: LIST
101577: PUSH
101578: LD_INT 5
101580: NEG
101581: PUSH
101582: LD_INT 1
101584: NEG
101585: PUSH
101586: EMPTY
101587: LIST
101588: LIST
101589: PUSH
101590: LD_INT 5
101592: NEG
101593: PUSH
101594: LD_INT 2
101596: NEG
101597: PUSH
101598: EMPTY
101599: LIST
101600: LIST
101601: PUSH
101602: LD_INT 3
101604: NEG
101605: PUSH
101606: LD_INT 2
101608: PUSH
101609: EMPTY
101610: LIST
101611: LIST
101612: PUSH
101613: EMPTY
101614: LIST
101615: LIST
101616: LIST
101617: LIST
101618: LIST
101619: LIST
101620: LIST
101621: LIST
101622: LIST
101623: LIST
101624: LIST
101625: LIST
101626: LIST
101627: LIST
101628: LIST
101629: LIST
101630: LIST
101631: LIST
101632: LIST
101633: LIST
101634: LIST
101635: LIST
101636: LIST
101637: LIST
101638: LIST
101639: LIST
101640: LIST
101641: LIST
101642: LIST
101643: LIST
101644: LIST
101645: LIST
101646: LIST
101647: LIST
101648: LIST
101649: LIST
101650: LIST
101651: LIST
101652: LIST
101653: LIST
101654: LIST
101655: LIST
101656: LIST
101657: LIST
101658: LIST
101659: ST_TO_ADDR
// end ; end ;
101660: GO 101663
101662: POP
// case btype of b_depot , b_warehouse :
101663: LD_VAR 0 1
101667: PUSH
101668: LD_INT 0
101670: DOUBLE
101671: EQUAL
101672: IFTRUE 101682
101674: LD_INT 1
101676: DOUBLE
101677: EQUAL
101678: IFTRUE 101682
101680: GO 101883
101682: POP
// case nation of nation_american :
101683: LD_VAR 0 5
101687: PUSH
101688: LD_INT 1
101690: DOUBLE
101691: EQUAL
101692: IFTRUE 101696
101694: GO 101752
101696: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
101697: LD_ADDR_VAR 0 9
101701: PUSH
101702: LD_VAR 0 11
101706: PUSH
101707: LD_VAR 0 12
101711: PUSH
101712: LD_VAR 0 13
101716: PUSH
101717: LD_VAR 0 14
101721: PUSH
101722: LD_VAR 0 15
101726: PUSH
101727: LD_VAR 0 16
101731: PUSH
101732: EMPTY
101733: LIST
101734: LIST
101735: LIST
101736: LIST
101737: LIST
101738: LIST
101739: PUSH
101740: LD_VAR 0 4
101744: PUSH
101745: LD_INT 1
101747: PLUS
101748: ARRAY
101749: ST_TO_ADDR
101750: GO 101881
101752: LD_INT 2
101754: DOUBLE
101755: EQUAL
101756: IFTRUE 101760
101758: GO 101816
101760: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
101761: LD_ADDR_VAR 0 9
101765: PUSH
101766: LD_VAR 0 17
101770: PUSH
101771: LD_VAR 0 18
101775: PUSH
101776: LD_VAR 0 19
101780: PUSH
101781: LD_VAR 0 20
101785: PUSH
101786: LD_VAR 0 21
101790: PUSH
101791: LD_VAR 0 22
101795: PUSH
101796: EMPTY
101797: LIST
101798: LIST
101799: LIST
101800: LIST
101801: LIST
101802: LIST
101803: PUSH
101804: LD_VAR 0 4
101808: PUSH
101809: LD_INT 1
101811: PLUS
101812: ARRAY
101813: ST_TO_ADDR
101814: GO 101881
101816: LD_INT 3
101818: DOUBLE
101819: EQUAL
101820: IFTRUE 101824
101822: GO 101880
101824: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
101825: LD_ADDR_VAR 0 9
101829: PUSH
101830: LD_VAR 0 23
101834: PUSH
101835: LD_VAR 0 24
101839: PUSH
101840: LD_VAR 0 25
101844: PUSH
101845: LD_VAR 0 26
101849: PUSH
101850: LD_VAR 0 27
101854: PUSH
101855: LD_VAR 0 28
101859: PUSH
101860: EMPTY
101861: LIST
101862: LIST
101863: LIST
101864: LIST
101865: LIST
101866: LIST
101867: PUSH
101868: LD_VAR 0 4
101872: PUSH
101873: LD_INT 1
101875: PLUS
101876: ARRAY
101877: ST_TO_ADDR
101878: GO 101881
101880: POP
101881: GO 102436
101883: LD_INT 2
101885: DOUBLE
101886: EQUAL
101887: IFTRUE 101897
101889: LD_INT 3
101891: DOUBLE
101892: EQUAL
101893: IFTRUE 101897
101895: GO 101953
101897: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
101898: LD_ADDR_VAR 0 9
101902: PUSH
101903: LD_VAR 0 29
101907: PUSH
101908: LD_VAR 0 30
101912: PUSH
101913: LD_VAR 0 31
101917: PUSH
101918: LD_VAR 0 32
101922: PUSH
101923: LD_VAR 0 33
101927: PUSH
101928: LD_VAR 0 34
101932: PUSH
101933: EMPTY
101934: LIST
101935: LIST
101936: LIST
101937: LIST
101938: LIST
101939: LIST
101940: PUSH
101941: LD_VAR 0 4
101945: PUSH
101946: LD_INT 1
101948: PLUS
101949: ARRAY
101950: ST_TO_ADDR
101951: GO 102436
101953: LD_INT 16
101955: DOUBLE
101956: EQUAL
101957: IFTRUE 102015
101959: LD_INT 17
101961: DOUBLE
101962: EQUAL
101963: IFTRUE 102015
101965: LD_INT 18
101967: DOUBLE
101968: EQUAL
101969: IFTRUE 102015
101971: LD_INT 19
101973: DOUBLE
101974: EQUAL
101975: IFTRUE 102015
101977: LD_INT 22
101979: DOUBLE
101980: EQUAL
101981: IFTRUE 102015
101983: LD_INT 20
101985: DOUBLE
101986: EQUAL
101987: IFTRUE 102015
101989: LD_INT 21
101991: DOUBLE
101992: EQUAL
101993: IFTRUE 102015
101995: LD_INT 23
101997: DOUBLE
101998: EQUAL
101999: IFTRUE 102015
102001: LD_INT 24
102003: DOUBLE
102004: EQUAL
102005: IFTRUE 102015
102007: LD_INT 25
102009: DOUBLE
102010: EQUAL
102011: IFTRUE 102015
102013: GO 102071
102015: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
102016: LD_ADDR_VAR 0 9
102020: PUSH
102021: LD_VAR 0 35
102025: PUSH
102026: LD_VAR 0 36
102030: PUSH
102031: LD_VAR 0 37
102035: PUSH
102036: LD_VAR 0 38
102040: PUSH
102041: LD_VAR 0 39
102045: PUSH
102046: LD_VAR 0 40
102050: PUSH
102051: EMPTY
102052: LIST
102053: LIST
102054: LIST
102055: LIST
102056: LIST
102057: LIST
102058: PUSH
102059: LD_VAR 0 4
102063: PUSH
102064: LD_INT 1
102066: PLUS
102067: ARRAY
102068: ST_TO_ADDR
102069: GO 102436
102071: LD_INT 6
102073: DOUBLE
102074: EQUAL
102075: IFTRUE 102127
102077: LD_INT 7
102079: DOUBLE
102080: EQUAL
102081: IFTRUE 102127
102083: LD_INT 8
102085: DOUBLE
102086: EQUAL
102087: IFTRUE 102127
102089: LD_INT 13
102091: DOUBLE
102092: EQUAL
102093: IFTRUE 102127
102095: LD_INT 12
102097: DOUBLE
102098: EQUAL
102099: IFTRUE 102127
102101: LD_INT 15
102103: DOUBLE
102104: EQUAL
102105: IFTRUE 102127
102107: LD_INT 11
102109: DOUBLE
102110: EQUAL
102111: IFTRUE 102127
102113: LD_INT 14
102115: DOUBLE
102116: EQUAL
102117: IFTRUE 102127
102119: LD_INT 10
102121: DOUBLE
102122: EQUAL
102123: IFTRUE 102127
102125: GO 102183
102127: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
102128: LD_ADDR_VAR 0 9
102132: PUSH
102133: LD_VAR 0 41
102137: PUSH
102138: LD_VAR 0 42
102142: PUSH
102143: LD_VAR 0 43
102147: PUSH
102148: LD_VAR 0 44
102152: PUSH
102153: LD_VAR 0 45
102157: PUSH
102158: LD_VAR 0 46
102162: PUSH
102163: EMPTY
102164: LIST
102165: LIST
102166: LIST
102167: LIST
102168: LIST
102169: LIST
102170: PUSH
102171: LD_VAR 0 4
102175: PUSH
102176: LD_INT 1
102178: PLUS
102179: ARRAY
102180: ST_TO_ADDR
102181: GO 102436
102183: LD_INT 36
102185: DOUBLE
102186: EQUAL
102187: IFTRUE 102191
102189: GO 102247
102191: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
102192: LD_ADDR_VAR 0 9
102196: PUSH
102197: LD_VAR 0 47
102201: PUSH
102202: LD_VAR 0 48
102206: PUSH
102207: LD_VAR 0 49
102211: PUSH
102212: LD_VAR 0 50
102216: PUSH
102217: LD_VAR 0 51
102221: PUSH
102222: LD_VAR 0 52
102226: PUSH
102227: EMPTY
102228: LIST
102229: LIST
102230: LIST
102231: LIST
102232: LIST
102233: LIST
102234: PUSH
102235: LD_VAR 0 4
102239: PUSH
102240: LD_INT 1
102242: PLUS
102243: ARRAY
102244: ST_TO_ADDR
102245: GO 102436
102247: LD_INT 4
102249: DOUBLE
102250: EQUAL
102251: IFTRUE 102273
102253: LD_INT 5
102255: DOUBLE
102256: EQUAL
102257: IFTRUE 102273
102259: LD_INT 34
102261: DOUBLE
102262: EQUAL
102263: IFTRUE 102273
102265: LD_INT 37
102267: DOUBLE
102268: EQUAL
102269: IFTRUE 102273
102271: GO 102329
102273: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
102274: LD_ADDR_VAR 0 9
102278: PUSH
102279: LD_VAR 0 53
102283: PUSH
102284: LD_VAR 0 54
102288: PUSH
102289: LD_VAR 0 55
102293: PUSH
102294: LD_VAR 0 56
102298: PUSH
102299: LD_VAR 0 57
102303: PUSH
102304: LD_VAR 0 58
102308: PUSH
102309: EMPTY
102310: LIST
102311: LIST
102312: LIST
102313: LIST
102314: LIST
102315: LIST
102316: PUSH
102317: LD_VAR 0 4
102321: PUSH
102322: LD_INT 1
102324: PLUS
102325: ARRAY
102326: ST_TO_ADDR
102327: GO 102436
102329: LD_INT 31
102331: DOUBLE
102332: EQUAL
102333: IFTRUE 102379
102335: LD_INT 32
102337: DOUBLE
102338: EQUAL
102339: IFTRUE 102379
102341: LD_INT 33
102343: DOUBLE
102344: EQUAL
102345: IFTRUE 102379
102347: LD_INT 27
102349: DOUBLE
102350: EQUAL
102351: IFTRUE 102379
102353: LD_INT 26
102355: DOUBLE
102356: EQUAL
102357: IFTRUE 102379
102359: LD_INT 28
102361: DOUBLE
102362: EQUAL
102363: IFTRUE 102379
102365: LD_INT 29
102367: DOUBLE
102368: EQUAL
102369: IFTRUE 102379
102371: LD_INT 30
102373: DOUBLE
102374: EQUAL
102375: IFTRUE 102379
102377: GO 102435
102379: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
102380: LD_ADDR_VAR 0 9
102384: PUSH
102385: LD_VAR 0 59
102389: PUSH
102390: LD_VAR 0 60
102394: PUSH
102395: LD_VAR 0 61
102399: PUSH
102400: LD_VAR 0 62
102404: PUSH
102405: LD_VAR 0 63
102409: PUSH
102410: LD_VAR 0 64
102414: PUSH
102415: EMPTY
102416: LIST
102417: LIST
102418: LIST
102419: LIST
102420: LIST
102421: LIST
102422: PUSH
102423: LD_VAR 0 4
102427: PUSH
102428: LD_INT 1
102430: PLUS
102431: ARRAY
102432: ST_TO_ADDR
102433: GO 102436
102435: POP
// temp_list2 = [ ] ;
102436: LD_ADDR_VAR 0 10
102440: PUSH
102441: EMPTY
102442: ST_TO_ADDR
// for i in temp_list do
102443: LD_ADDR_VAR 0 8
102447: PUSH
102448: LD_VAR 0 9
102452: PUSH
102453: FOR_IN
102454: IFFALSE 102506
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
102456: LD_ADDR_VAR 0 10
102460: PUSH
102461: LD_VAR 0 10
102465: PUSH
102466: LD_VAR 0 8
102470: PUSH
102471: LD_INT 1
102473: ARRAY
102474: PUSH
102475: LD_VAR 0 2
102479: PLUS
102480: PUSH
102481: LD_VAR 0 8
102485: PUSH
102486: LD_INT 2
102488: ARRAY
102489: PUSH
102490: LD_VAR 0 3
102494: PLUS
102495: PUSH
102496: EMPTY
102497: LIST
102498: LIST
102499: PUSH
102500: EMPTY
102501: LIST
102502: ADD
102503: ST_TO_ADDR
102504: GO 102453
102506: POP
102507: POP
// result = temp_list2 ;
102508: LD_ADDR_VAR 0 7
102512: PUSH
102513: LD_VAR 0 10
102517: ST_TO_ADDR
// end ;
102518: LD_VAR 0 7
102522: RET
// export function EnemyInRange ( unit , dist ) ; begin
102523: LD_INT 0
102525: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
102526: LD_ADDR_VAR 0 3
102530: PUSH
102531: LD_VAR 0 1
102535: PPUSH
102536: CALL_OW 255
102540: PPUSH
102541: LD_VAR 0 1
102545: PPUSH
102546: CALL_OW 250
102550: PPUSH
102551: LD_VAR 0 1
102555: PPUSH
102556: CALL_OW 251
102560: PPUSH
102561: LD_VAR 0 2
102565: PPUSH
102566: CALL 75896 0 4
102570: PUSH
102571: LD_INT 4
102573: ARRAY
102574: ST_TO_ADDR
// end ;
102575: LD_VAR 0 3
102579: RET
// export function PlayerSeeMe ( unit ) ; begin
102580: LD_INT 0
102582: PPUSH
// result := See ( your_side , unit ) ;
102583: LD_ADDR_VAR 0 2
102587: PUSH
102588: LD_OWVAR 2
102592: PPUSH
102593: LD_VAR 0 1
102597: PPUSH
102598: CALL_OW 292
102602: ST_TO_ADDR
// end ;
102603: LD_VAR 0 2
102607: RET
// export function ReverseDir ( unit ) ; begin
102608: LD_INT 0
102610: PPUSH
// if not unit then
102611: LD_VAR 0 1
102615: NOT
102616: IFFALSE 102620
// exit ;
102618: GO 102643
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
102620: LD_ADDR_VAR 0 2
102624: PUSH
102625: LD_VAR 0 1
102629: PPUSH
102630: CALL_OW 254
102634: PUSH
102635: LD_INT 3
102637: PLUS
102638: PUSH
102639: LD_INT 6
102641: MOD
102642: ST_TO_ADDR
// end ;
102643: LD_VAR 0 2
102647: RET
// export function ReverseArray ( array ) ; var i ; begin
102648: LD_INT 0
102650: PPUSH
102651: PPUSH
// if not array then
102652: LD_VAR 0 1
102656: NOT
102657: IFFALSE 102661
// exit ;
102659: GO 102716
// result := [ ] ;
102661: LD_ADDR_VAR 0 2
102665: PUSH
102666: EMPTY
102667: ST_TO_ADDR
// for i := array downto 1 do
102668: LD_ADDR_VAR 0 3
102672: PUSH
102673: DOUBLE
102674: LD_VAR 0 1
102678: INC
102679: ST_TO_ADDR
102680: LD_INT 1
102682: PUSH
102683: FOR_DOWNTO
102684: IFFALSE 102714
// result := Join ( result , array [ i ] ) ;
102686: LD_ADDR_VAR 0 2
102690: PUSH
102691: LD_VAR 0 2
102695: PPUSH
102696: LD_VAR 0 1
102700: PUSH
102701: LD_VAR 0 3
102705: ARRAY
102706: PPUSH
102707: CALL 107361 0 2
102711: ST_TO_ADDR
102712: GO 102683
102714: POP
102715: POP
// end ;
102716: LD_VAR 0 2
102720: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
102721: LD_INT 0
102723: PPUSH
102724: PPUSH
102725: PPUSH
102726: PPUSH
102727: PPUSH
102728: PPUSH
// if not unit or not hexes then
102729: LD_VAR 0 1
102733: NOT
102734: PUSH
102735: LD_VAR 0 2
102739: NOT
102740: OR
102741: IFFALSE 102745
// exit ;
102743: GO 102868
// dist := 9999 ;
102745: LD_ADDR_VAR 0 5
102749: PUSH
102750: LD_INT 9999
102752: ST_TO_ADDR
// for i = 1 to hexes do
102753: LD_ADDR_VAR 0 4
102757: PUSH
102758: DOUBLE
102759: LD_INT 1
102761: DEC
102762: ST_TO_ADDR
102763: LD_VAR 0 2
102767: PUSH
102768: FOR_TO
102769: IFFALSE 102856
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
102771: LD_ADDR_VAR 0 6
102775: PUSH
102776: LD_VAR 0 1
102780: PPUSH
102781: LD_VAR 0 2
102785: PUSH
102786: LD_VAR 0 4
102790: ARRAY
102791: PUSH
102792: LD_INT 1
102794: ARRAY
102795: PPUSH
102796: LD_VAR 0 2
102800: PUSH
102801: LD_VAR 0 4
102805: ARRAY
102806: PUSH
102807: LD_INT 2
102809: ARRAY
102810: PPUSH
102811: CALL_OW 297
102815: ST_TO_ADDR
// if tdist < dist then
102816: LD_VAR 0 6
102820: PUSH
102821: LD_VAR 0 5
102825: LESS
102826: IFFALSE 102854
// begin hex := hexes [ i ] ;
102828: LD_ADDR_VAR 0 8
102832: PUSH
102833: LD_VAR 0 2
102837: PUSH
102838: LD_VAR 0 4
102842: ARRAY
102843: ST_TO_ADDR
// dist := tdist ;
102844: LD_ADDR_VAR 0 5
102848: PUSH
102849: LD_VAR 0 6
102853: ST_TO_ADDR
// end ; end ;
102854: GO 102768
102856: POP
102857: POP
// result := hex ;
102858: LD_ADDR_VAR 0 3
102862: PUSH
102863: LD_VAR 0 8
102867: ST_TO_ADDR
// end ;
102868: LD_VAR 0 3
102872: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
102873: LD_INT 0
102875: PPUSH
102876: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
102877: LD_VAR 0 1
102881: NOT
102882: PUSH
102883: LD_VAR 0 1
102887: PUSH
102888: LD_INT 21
102890: PUSH
102891: LD_INT 2
102893: PUSH
102894: EMPTY
102895: LIST
102896: LIST
102897: PUSH
102898: LD_INT 23
102900: PUSH
102901: LD_INT 2
102903: PUSH
102904: EMPTY
102905: LIST
102906: LIST
102907: PUSH
102908: EMPTY
102909: LIST
102910: LIST
102911: PPUSH
102912: CALL_OW 69
102916: IN
102917: NOT
102918: OR
102919: IFFALSE 102923
// exit ;
102921: GO 102970
// for i = 1 to 3 do
102923: LD_ADDR_VAR 0 3
102927: PUSH
102928: DOUBLE
102929: LD_INT 1
102931: DEC
102932: ST_TO_ADDR
102933: LD_INT 3
102935: PUSH
102936: FOR_TO
102937: IFFALSE 102968
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
102939: LD_VAR 0 1
102943: PPUSH
102944: CALL_OW 250
102948: PPUSH
102949: LD_VAR 0 1
102953: PPUSH
102954: CALL_OW 251
102958: PPUSH
102959: LD_INT 1
102961: PPUSH
102962: CALL_OW 453
102966: GO 102936
102968: POP
102969: POP
// end ;
102970: LD_VAR 0 2
102974: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
102975: LD_INT 0
102977: PPUSH
102978: PPUSH
102979: PPUSH
102980: PPUSH
102981: PPUSH
102982: PPUSH
// if not unit or not enemy_unit then
102983: LD_VAR 0 1
102987: NOT
102988: PUSH
102989: LD_VAR 0 2
102993: NOT
102994: OR
102995: IFFALSE 102999
// exit ;
102997: GO 103466
// if GetLives ( i ) < 250 then
102999: LD_VAR 0 4
103003: PPUSH
103004: CALL_OW 256
103008: PUSH
103009: LD_INT 250
103011: LESS
103012: IFFALSE 103025
// begin ComAutodestruct ( i ) ;
103014: LD_VAR 0 4
103018: PPUSH
103019: CALL 102873 0 1
// exit ;
103023: GO 103466
// end ; x := GetX ( enemy_unit ) ;
103025: LD_ADDR_VAR 0 7
103029: PUSH
103030: LD_VAR 0 2
103034: PPUSH
103035: CALL_OW 250
103039: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
103040: LD_ADDR_VAR 0 8
103044: PUSH
103045: LD_VAR 0 2
103049: PPUSH
103050: CALL_OW 251
103054: ST_TO_ADDR
// if not x or not y then
103055: LD_VAR 0 7
103059: NOT
103060: PUSH
103061: LD_VAR 0 8
103065: NOT
103066: OR
103067: IFFALSE 103071
// exit ;
103069: GO 103466
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
103071: LD_ADDR_VAR 0 6
103075: PUSH
103076: LD_VAR 0 7
103080: PPUSH
103081: LD_INT 0
103083: PPUSH
103084: LD_INT 4
103086: PPUSH
103087: CALL_OW 272
103091: PUSH
103092: LD_VAR 0 8
103096: PPUSH
103097: LD_INT 0
103099: PPUSH
103100: LD_INT 4
103102: PPUSH
103103: CALL_OW 273
103107: PUSH
103108: EMPTY
103109: LIST
103110: LIST
103111: PUSH
103112: LD_VAR 0 7
103116: PPUSH
103117: LD_INT 1
103119: PPUSH
103120: LD_INT 4
103122: PPUSH
103123: CALL_OW 272
103127: PUSH
103128: LD_VAR 0 8
103132: PPUSH
103133: LD_INT 1
103135: PPUSH
103136: LD_INT 4
103138: PPUSH
103139: CALL_OW 273
103143: PUSH
103144: EMPTY
103145: LIST
103146: LIST
103147: PUSH
103148: LD_VAR 0 7
103152: PPUSH
103153: LD_INT 2
103155: PPUSH
103156: LD_INT 4
103158: PPUSH
103159: CALL_OW 272
103163: PUSH
103164: LD_VAR 0 8
103168: PPUSH
103169: LD_INT 2
103171: PPUSH
103172: LD_INT 4
103174: PPUSH
103175: CALL_OW 273
103179: PUSH
103180: EMPTY
103181: LIST
103182: LIST
103183: PUSH
103184: LD_VAR 0 7
103188: PPUSH
103189: LD_INT 3
103191: PPUSH
103192: LD_INT 4
103194: PPUSH
103195: CALL_OW 272
103199: PUSH
103200: LD_VAR 0 8
103204: PPUSH
103205: LD_INT 3
103207: PPUSH
103208: LD_INT 4
103210: PPUSH
103211: CALL_OW 273
103215: PUSH
103216: EMPTY
103217: LIST
103218: LIST
103219: PUSH
103220: LD_VAR 0 7
103224: PPUSH
103225: LD_INT 4
103227: PPUSH
103228: LD_INT 4
103230: PPUSH
103231: CALL_OW 272
103235: PUSH
103236: LD_VAR 0 8
103240: PPUSH
103241: LD_INT 4
103243: PPUSH
103244: LD_INT 4
103246: PPUSH
103247: CALL_OW 273
103251: PUSH
103252: EMPTY
103253: LIST
103254: LIST
103255: PUSH
103256: LD_VAR 0 7
103260: PPUSH
103261: LD_INT 5
103263: PPUSH
103264: LD_INT 4
103266: PPUSH
103267: CALL_OW 272
103271: PUSH
103272: LD_VAR 0 8
103276: PPUSH
103277: LD_INT 5
103279: PPUSH
103280: LD_INT 4
103282: PPUSH
103283: CALL_OW 273
103287: PUSH
103288: EMPTY
103289: LIST
103290: LIST
103291: PUSH
103292: EMPTY
103293: LIST
103294: LIST
103295: LIST
103296: LIST
103297: LIST
103298: LIST
103299: ST_TO_ADDR
// for i = tmp downto 1 do
103300: LD_ADDR_VAR 0 4
103304: PUSH
103305: DOUBLE
103306: LD_VAR 0 6
103310: INC
103311: ST_TO_ADDR
103312: LD_INT 1
103314: PUSH
103315: FOR_DOWNTO
103316: IFFALSE 103417
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
103318: LD_VAR 0 6
103322: PUSH
103323: LD_VAR 0 4
103327: ARRAY
103328: PUSH
103329: LD_INT 1
103331: ARRAY
103332: PPUSH
103333: LD_VAR 0 6
103337: PUSH
103338: LD_VAR 0 4
103342: ARRAY
103343: PUSH
103344: LD_INT 2
103346: ARRAY
103347: PPUSH
103348: CALL_OW 488
103352: NOT
103353: PUSH
103354: LD_VAR 0 6
103358: PUSH
103359: LD_VAR 0 4
103363: ARRAY
103364: PUSH
103365: LD_INT 1
103367: ARRAY
103368: PPUSH
103369: LD_VAR 0 6
103373: PUSH
103374: LD_VAR 0 4
103378: ARRAY
103379: PUSH
103380: LD_INT 2
103382: ARRAY
103383: PPUSH
103384: CALL_OW 428
103388: PUSH
103389: LD_INT 0
103391: NONEQUAL
103392: OR
103393: IFFALSE 103415
// tmp := Delete ( tmp , i ) ;
103395: LD_ADDR_VAR 0 6
103399: PUSH
103400: LD_VAR 0 6
103404: PPUSH
103405: LD_VAR 0 4
103409: PPUSH
103410: CALL_OW 3
103414: ST_TO_ADDR
103415: GO 103315
103417: POP
103418: POP
// j := GetClosestHex ( unit , tmp ) ;
103419: LD_ADDR_VAR 0 5
103423: PUSH
103424: LD_VAR 0 1
103428: PPUSH
103429: LD_VAR 0 6
103433: PPUSH
103434: CALL 102721 0 2
103438: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
103439: LD_VAR 0 1
103443: PPUSH
103444: LD_VAR 0 5
103448: PUSH
103449: LD_INT 1
103451: ARRAY
103452: PPUSH
103453: LD_VAR 0 5
103457: PUSH
103458: LD_INT 2
103460: ARRAY
103461: PPUSH
103462: CALL_OW 111
// end ;
103466: LD_VAR 0 3
103470: RET
// export function PrepareApemanSoldier ( ) ; begin
103471: LD_INT 0
103473: PPUSH
// uc_nation := 0 ;
103474: LD_ADDR_OWVAR 21
103478: PUSH
103479: LD_INT 0
103481: ST_TO_ADDR
// hc_sex := sex_male ;
103482: LD_ADDR_OWVAR 27
103486: PUSH
103487: LD_INT 1
103489: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
103490: LD_ADDR_OWVAR 28
103494: PUSH
103495: LD_INT 15
103497: ST_TO_ADDR
// hc_gallery :=  ;
103498: LD_ADDR_OWVAR 33
103502: PUSH
103503: LD_STRING 
103505: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
103506: LD_ADDR_OWVAR 31
103510: PUSH
103511: LD_INT 0
103513: PPUSH
103514: LD_INT 3
103516: PPUSH
103517: CALL_OW 12
103521: PUSH
103522: LD_INT 0
103524: PPUSH
103525: LD_INT 3
103527: PPUSH
103528: CALL_OW 12
103532: PUSH
103533: LD_INT 0
103535: PUSH
103536: LD_INT 0
103538: PUSH
103539: EMPTY
103540: LIST
103541: LIST
103542: LIST
103543: LIST
103544: ST_TO_ADDR
// end ;
103545: LD_VAR 0 1
103549: RET
// export function PrepareApemanEngineer ( ) ; begin
103550: LD_INT 0
103552: PPUSH
// uc_nation := 0 ;
103553: LD_ADDR_OWVAR 21
103557: PUSH
103558: LD_INT 0
103560: ST_TO_ADDR
// hc_sex := sex_male ;
103561: LD_ADDR_OWVAR 27
103565: PUSH
103566: LD_INT 1
103568: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
103569: LD_ADDR_OWVAR 28
103573: PUSH
103574: LD_INT 16
103576: ST_TO_ADDR
// hc_gallery :=  ;
103577: LD_ADDR_OWVAR 33
103581: PUSH
103582: LD_STRING 
103584: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
103585: LD_ADDR_OWVAR 31
103589: PUSH
103590: LD_INT 0
103592: PPUSH
103593: LD_INT 3
103595: PPUSH
103596: CALL_OW 12
103600: PUSH
103601: LD_INT 0
103603: PPUSH
103604: LD_INT 3
103606: PPUSH
103607: CALL_OW 12
103611: PUSH
103612: LD_INT 0
103614: PUSH
103615: LD_INT 0
103617: PUSH
103618: EMPTY
103619: LIST
103620: LIST
103621: LIST
103622: LIST
103623: ST_TO_ADDR
// end ;
103624: LD_VAR 0 1
103628: RET
// export function PrepareApeman ( agressivity ) ; begin
103629: LD_INT 0
103631: PPUSH
// uc_side := 0 ;
103632: LD_ADDR_OWVAR 20
103636: PUSH
103637: LD_INT 0
103639: ST_TO_ADDR
// uc_nation := 0 ;
103640: LD_ADDR_OWVAR 21
103644: PUSH
103645: LD_INT 0
103647: ST_TO_ADDR
// hc_sex := sex_male ;
103648: LD_ADDR_OWVAR 27
103652: PUSH
103653: LD_INT 1
103655: ST_TO_ADDR
// hc_class := class_apeman ;
103656: LD_ADDR_OWVAR 28
103660: PUSH
103661: LD_INT 12
103663: ST_TO_ADDR
// hc_gallery :=  ;
103664: LD_ADDR_OWVAR 33
103668: PUSH
103669: LD_STRING 
103671: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
103672: LD_ADDR_OWVAR 35
103676: PUSH
103677: LD_VAR 0 1
103681: NEG
103682: PPUSH
103683: LD_VAR 0 1
103687: PPUSH
103688: CALL_OW 12
103692: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
103693: LD_ADDR_OWVAR 31
103697: PUSH
103698: LD_INT 0
103700: PPUSH
103701: LD_INT 3
103703: PPUSH
103704: CALL_OW 12
103708: PUSH
103709: LD_INT 0
103711: PPUSH
103712: LD_INT 3
103714: PPUSH
103715: CALL_OW 12
103719: PUSH
103720: LD_INT 0
103722: PUSH
103723: LD_INT 0
103725: PUSH
103726: EMPTY
103727: LIST
103728: LIST
103729: LIST
103730: LIST
103731: ST_TO_ADDR
// end ;
103732: LD_VAR 0 2
103736: RET
// export function PrepareTiger ( agressivity ) ; begin
103737: LD_INT 0
103739: PPUSH
// uc_side := 0 ;
103740: LD_ADDR_OWVAR 20
103744: PUSH
103745: LD_INT 0
103747: ST_TO_ADDR
// uc_nation := 0 ;
103748: LD_ADDR_OWVAR 21
103752: PUSH
103753: LD_INT 0
103755: ST_TO_ADDR
// hc_class := class_tiger ;
103756: LD_ADDR_OWVAR 28
103760: PUSH
103761: LD_INT 14
103763: ST_TO_ADDR
// hc_gallery :=  ;
103764: LD_ADDR_OWVAR 33
103768: PUSH
103769: LD_STRING 
103771: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
103772: LD_ADDR_OWVAR 35
103776: PUSH
103777: LD_VAR 0 1
103781: NEG
103782: PPUSH
103783: LD_VAR 0 1
103787: PPUSH
103788: CALL_OW 12
103792: ST_TO_ADDR
// end ;
103793: LD_VAR 0 2
103797: RET
// export function PrepareEnchidna ( ) ; begin
103798: LD_INT 0
103800: PPUSH
// uc_side := 0 ;
103801: LD_ADDR_OWVAR 20
103805: PUSH
103806: LD_INT 0
103808: ST_TO_ADDR
// uc_nation := 0 ;
103809: LD_ADDR_OWVAR 21
103813: PUSH
103814: LD_INT 0
103816: ST_TO_ADDR
// hc_class := class_baggie ;
103817: LD_ADDR_OWVAR 28
103821: PUSH
103822: LD_INT 13
103824: ST_TO_ADDR
// hc_gallery :=  ;
103825: LD_ADDR_OWVAR 33
103829: PUSH
103830: LD_STRING 
103832: ST_TO_ADDR
// end ;
103833: LD_VAR 0 1
103837: RET
// export function PrepareFrog ( ) ; begin
103838: LD_INT 0
103840: PPUSH
// uc_side := 0 ;
103841: LD_ADDR_OWVAR 20
103845: PUSH
103846: LD_INT 0
103848: ST_TO_ADDR
// uc_nation := 0 ;
103849: LD_ADDR_OWVAR 21
103853: PUSH
103854: LD_INT 0
103856: ST_TO_ADDR
// hc_class := class_frog ;
103857: LD_ADDR_OWVAR 28
103861: PUSH
103862: LD_INT 19
103864: ST_TO_ADDR
// hc_gallery :=  ;
103865: LD_ADDR_OWVAR 33
103869: PUSH
103870: LD_STRING 
103872: ST_TO_ADDR
// end ;
103873: LD_VAR 0 1
103877: RET
// export function PrepareFish ( ) ; begin
103878: LD_INT 0
103880: PPUSH
// uc_side := 0 ;
103881: LD_ADDR_OWVAR 20
103885: PUSH
103886: LD_INT 0
103888: ST_TO_ADDR
// uc_nation := 0 ;
103889: LD_ADDR_OWVAR 21
103893: PUSH
103894: LD_INT 0
103896: ST_TO_ADDR
// hc_class := class_fish ;
103897: LD_ADDR_OWVAR 28
103901: PUSH
103902: LD_INT 20
103904: ST_TO_ADDR
// hc_gallery :=  ;
103905: LD_ADDR_OWVAR 33
103909: PUSH
103910: LD_STRING 
103912: ST_TO_ADDR
// end ;
103913: LD_VAR 0 1
103917: RET
// export function PrepareBird ( ) ; begin
103918: LD_INT 0
103920: PPUSH
// uc_side := 0 ;
103921: LD_ADDR_OWVAR 20
103925: PUSH
103926: LD_INT 0
103928: ST_TO_ADDR
// uc_nation := 0 ;
103929: LD_ADDR_OWVAR 21
103933: PUSH
103934: LD_INT 0
103936: ST_TO_ADDR
// hc_class := class_phororhacos ;
103937: LD_ADDR_OWVAR 28
103941: PUSH
103942: LD_INT 18
103944: ST_TO_ADDR
// hc_gallery :=  ;
103945: LD_ADDR_OWVAR 33
103949: PUSH
103950: LD_STRING 
103952: ST_TO_ADDR
// end ;
103953: LD_VAR 0 1
103957: RET
// export function PrepareHorse ( ) ; begin
103958: LD_INT 0
103960: PPUSH
// uc_side := 0 ;
103961: LD_ADDR_OWVAR 20
103965: PUSH
103966: LD_INT 0
103968: ST_TO_ADDR
// uc_nation := 0 ;
103969: LD_ADDR_OWVAR 21
103973: PUSH
103974: LD_INT 0
103976: ST_TO_ADDR
// hc_class := class_horse ;
103977: LD_ADDR_OWVAR 28
103981: PUSH
103982: LD_INT 21
103984: ST_TO_ADDR
// hc_gallery :=  ;
103985: LD_ADDR_OWVAR 33
103989: PUSH
103990: LD_STRING 
103992: ST_TO_ADDR
// end ;
103993: LD_VAR 0 1
103997: RET
// export function PrepareMastodont ( ) ; begin
103998: LD_INT 0
104000: PPUSH
// uc_side := 0 ;
104001: LD_ADDR_OWVAR 20
104005: PUSH
104006: LD_INT 0
104008: ST_TO_ADDR
// uc_nation := 0 ;
104009: LD_ADDR_OWVAR 21
104013: PUSH
104014: LD_INT 0
104016: ST_TO_ADDR
// vc_chassis := class_mastodont ;
104017: LD_ADDR_OWVAR 37
104021: PUSH
104022: LD_INT 31
104024: ST_TO_ADDR
// vc_control := control_rider ;
104025: LD_ADDR_OWVAR 38
104029: PUSH
104030: LD_INT 4
104032: ST_TO_ADDR
// end ;
104033: LD_VAR 0 1
104037: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
104038: LD_INT 0
104040: PPUSH
104041: PPUSH
104042: PPUSH
// uc_side = 0 ;
104043: LD_ADDR_OWVAR 20
104047: PUSH
104048: LD_INT 0
104050: ST_TO_ADDR
// uc_nation = 0 ;
104051: LD_ADDR_OWVAR 21
104055: PUSH
104056: LD_INT 0
104058: ST_TO_ADDR
// InitHc_All ( ) ;
104059: CALL_OW 584
// InitVc ;
104063: CALL_OW 20
// if mastodonts then
104067: LD_VAR 0 6
104071: IFFALSE 104138
// for i = 1 to mastodonts do
104073: LD_ADDR_VAR 0 11
104077: PUSH
104078: DOUBLE
104079: LD_INT 1
104081: DEC
104082: ST_TO_ADDR
104083: LD_VAR 0 6
104087: PUSH
104088: FOR_TO
104089: IFFALSE 104136
// begin vc_chassis := 31 ;
104091: LD_ADDR_OWVAR 37
104095: PUSH
104096: LD_INT 31
104098: ST_TO_ADDR
// vc_control := control_rider ;
104099: LD_ADDR_OWVAR 38
104103: PUSH
104104: LD_INT 4
104106: ST_TO_ADDR
// animal := CreateVehicle ;
104107: LD_ADDR_VAR 0 12
104111: PUSH
104112: CALL_OW 45
104116: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104117: LD_VAR 0 12
104121: PPUSH
104122: LD_VAR 0 8
104126: PPUSH
104127: LD_INT 0
104129: PPUSH
104130: CALL 106266 0 3
// end ;
104134: GO 104088
104136: POP
104137: POP
// if horses then
104138: LD_VAR 0 5
104142: IFFALSE 104209
// for i = 1 to horses do
104144: LD_ADDR_VAR 0 11
104148: PUSH
104149: DOUBLE
104150: LD_INT 1
104152: DEC
104153: ST_TO_ADDR
104154: LD_VAR 0 5
104158: PUSH
104159: FOR_TO
104160: IFFALSE 104207
// begin hc_class := 21 ;
104162: LD_ADDR_OWVAR 28
104166: PUSH
104167: LD_INT 21
104169: ST_TO_ADDR
// hc_gallery :=  ;
104170: LD_ADDR_OWVAR 33
104174: PUSH
104175: LD_STRING 
104177: ST_TO_ADDR
// animal := CreateHuman ;
104178: LD_ADDR_VAR 0 12
104182: PUSH
104183: CALL_OW 44
104187: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104188: LD_VAR 0 12
104192: PPUSH
104193: LD_VAR 0 8
104197: PPUSH
104198: LD_INT 0
104200: PPUSH
104201: CALL 106266 0 3
// end ;
104205: GO 104159
104207: POP
104208: POP
// if birds then
104209: LD_VAR 0 1
104213: IFFALSE 104280
// for i = 1 to birds do
104215: LD_ADDR_VAR 0 11
104219: PUSH
104220: DOUBLE
104221: LD_INT 1
104223: DEC
104224: ST_TO_ADDR
104225: LD_VAR 0 1
104229: PUSH
104230: FOR_TO
104231: IFFALSE 104278
// begin hc_class := 18 ;
104233: LD_ADDR_OWVAR 28
104237: PUSH
104238: LD_INT 18
104240: ST_TO_ADDR
// hc_gallery =  ;
104241: LD_ADDR_OWVAR 33
104245: PUSH
104246: LD_STRING 
104248: ST_TO_ADDR
// animal := CreateHuman ;
104249: LD_ADDR_VAR 0 12
104253: PUSH
104254: CALL_OW 44
104258: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104259: LD_VAR 0 12
104263: PPUSH
104264: LD_VAR 0 8
104268: PPUSH
104269: LD_INT 0
104271: PPUSH
104272: CALL 106266 0 3
// end ;
104276: GO 104230
104278: POP
104279: POP
// if tigers then
104280: LD_VAR 0 2
104284: IFFALSE 104368
// for i = 1 to tigers do
104286: LD_ADDR_VAR 0 11
104290: PUSH
104291: DOUBLE
104292: LD_INT 1
104294: DEC
104295: ST_TO_ADDR
104296: LD_VAR 0 2
104300: PUSH
104301: FOR_TO
104302: IFFALSE 104366
// begin hc_class = class_tiger ;
104304: LD_ADDR_OWVAR 28
104308: PUSH
104309: LD_INT 14
104311: ST_TO_ADDR
// hc_gallery =  ;
104312: LD_ADDR_OWVAR 33
104316: PUSH
104317: LD_STRING 
104319: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
104320: LD_ADDR_OWVAR 35
104324: PUSH
104325: LD_INT 7
104327: NEG
104328: PPUSH
104329: LD_INT 7
104331: PPUSH
104332: CALL_OW 12
104336: ST_TO_ADDR
// animal := CreateHuman ;
104337: LD_ADDR_VAR 0 12
104341: PUSH
104342: CALL_OW 44
104346: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104347: LD_VAR 0 12
104351: PPUSH
104352: LD_VAR 0 8
104356: PPUSH
104357: LD_INT 0
104359: PPUSH
104360: CALL 106266 0 3
// end ;
104364: GO 104301
104366: POP
104367: POP
// if apemans then
104368: LD_VAR 0 3
104372: IFFALSE 104495
// for i = 1 to apemans do
104374: LD_ADDR_VAR 0 11
104378: PUSH
104379: DOUBLE
104380: LD_INT 1
104382: DEC
104383: ST_TO_ADDR
104384: LD_VAR 0 3
104388: PUSH
104389: FOR_TO
104390: IFFALSE 104493
// begin hc_class = class_apeman ;
104392: LD_ADDR_OWVAR 28
104396: PUSH
104397: LD_INT 12
104399: ST_TO_ADDR
// hc_gallery =  ;
104400: LD_ADDR_OWVAR 33
104404: PUSH
104405: LD_STRING 
104407: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
104408: LD_ADDR_OWVAR 35
104412: PUSH
104413: LD_INT 2
104415: NEG
104416: PPUSH
104417: LD_INT 2
104419: PPUSH
104420: CALL_OW 12
104424: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
104425: LD_ADDR_OWVAR 31
104429: PUSH
104430: LD_INT 1
104432: PPUSH
104433: LD_INT 3
104435: PPUSH
104436: CALL_OW 12
104440: PUSH
104441: LD_INT 1
104443: PPUSH
104444: LD_INT 3
104446: PPUSH
104447: CALL_OW 12
104451: PUSH
104452: LD_INT 0
104454: PUSH
104455: LD_INT 0
104457: PUSH
104458: EMPTY
104459: LIST
104460: LIST
104461: LIST
104462: LIST
104463: ST_TO_ADDR
// animal := CreateHuman ;
104464: LD_ADDR_VAR 0 12
104468: PUSH
104469: CALL_OW 44
104473: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104474: LD_VAR 0 12
104478: PPUSH
104479: LD_VAR 0 8
104483: PPUSH
104484: LD_INT 0
104486: PPUSH
104487: CALL 106266 0 3
// end ;
104491: GO 104389
104493: POP
104494: POP
// if enchidnas then
104495: LD_VAR 0 4
104499: IFFALSE 104566
// for i = 1 to enchidnas do
104501: LD_ADDR_VAR 0 11
104505: PUSH
104506: DOUBLE
104507: LD_INT 1
104509: DEC
104510: ST_TO_ADDR
104511: LD_VAR 0 4
104515: PUSH
104516: FOR_TO
104517: IFFALSE 104564
// begin hc_class = 13 ;
104519: LD_ADDR_OWVAR 28
104523: PUSH
104524: LD_INT 13
104526: ST_TO_ADDR
// hc_gallery =  ;
104527: LD_ADDR_OWVAR 33
104531: PUSH
104532: LD_STRING 
104534: ST_TO_ADDR
// animal := CreateHuman ;
104535: LD_ADDR_VAR 0 12
104539: PUSH
104540: CALL_OW 44
104544: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104545: LD_VAR 0 12
104549: PPUSH
104550: LD_VAR 0 8
104554: PPUSH
104555: LD_INT 0
104557: PPUSH
104558: CALL 106266 0 3
// end ;
104562: GO 104516
104564: POP
104565: POP
// if fishes then
104566: LD_VAR 0 7
104570: IFFALSE 104637
// for i = 1 to fishes do
104572: LD_ADDR_VAR 0 11
104576: PUSH
104577: DOUBLE
104578: LD_INT 1
104580: DEC
104581: ST_TO_ADDR
104582: LD_VAR 0 7
104586: PUSH
104587: FOR_TO
104588: IFFALSE 104635
// begin hc_class = 20 ;
104590: LD_ADDR_OWVAR 28
104594: PUSH
104595: LD_INT 20
104597: ST_TO_ADDR
// hc_gallery =  ;
104598: LD_ADDR_OWVAR 33
104602: PUSH
104603: LD_STRING 
104605: ST_TO_ADDR
// animal := CreateHuman ;
104606: LD_ADDR_VAR 0 12
104610: PUSH
104611: CALL_OW 44
104615: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
104616: LD_VAR 0 12
104620: PPUSH
104621: LD_VAR 0 9
104625: PPUSH
104626: LD_INT 0
104628: PPUSH
104629: CALL 106266 0 3
// end ;
104633: GO 104587
104635: POP
104636: POP
// end ;
104637: LD_VAR 0 10
104641: RET
// export function WantHeal ( sci , unit ) ; begin
104642: LD_INT 0
104644: PPUSH
// if GetTaskList ( sci ) > 0 then
104645: LD_VAR 0 1
104649: PPUSH
104650: CALL_OW 437
104654: PUSH
104655: LD_INT 0
104657: GREATER
104658: IFFALSE 104728
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
104660: LD_VAR 0 1
104664: PPUSH
104665: CALL_OW 437
104669: PUSH
104670: LD_INT 1
104672: ARRAY
104673: PUSH
104674: LD_INT 1
104676: ARRAY
104677: PUSH
104678: LD_STRING l
104680: EQUAL
104681: PUSH
104682: LD_VAR 0 1
104686: PPUSH
104687: CALL_OW 437
104691: PUSH
104692: LD_INT 1
104694: ARRAY
104695: PUSH
104696: LD_INT 4
104698: ARRAY
104699: PUSH
104700: LD_VAR 0 2
104704: EQUAL
104705: AND
104706: IFFALSE 104718
// result := true else
104708: LD_ADDR_VAR 0 3
104712: PUSH
104713: LD_INT 1
104715: ST_TO_ADDR
104716: GO 104726
// result := false ;
104718: LD_ADDR_VAR 0 3
104722: PUSH
104723: LD_INT 0
104725: ST_TO_ADDR
// end else
104726: GO 104736
// result := false ;
104728: LD_ADDR_VAR 0 3
104732: PUSH
104733: LD_INT 0
104735: ST_TO_ADDR
// end ;
104736: LD_VAR 0 3
104740: RET
// export function HealTarget ( sci ) ; begin
104741: LD_INT 0
104743: PPUSH
// if not sci then
104744: LD_VAR 0 1
104748: NOT
104749: IFFALSE 104753
// exit ;
104751: GO 104818
// result := 0 ;
104753: LD_ADDR_VAR 0 2
104757: PUSH
104758: LD_INT 0
104760: ST_TO_ADDR
// if GetTaskList ( sci ) then
104761: LD_VAR 0 1
104765: PPUSH
104766: CALL_OW 437
104770: IFFALSE 104818
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
104772: LD_VAR 0 1
104776: PPUSH
104777: CALL_OW 437
104781: PUSH
104782: LD_INT 1
104784: ARRAY
104785: PUSH
104786: LD_INT 1
104788: ARRAY
104789: PUSH
104790: LD_STRING l
104792: EQUAL
104793: IFFALSE 104818
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
104795: LD_ADDR_VAR 0 2
104799: PUSH
104800: LD_VAR 0 1
104804: PPUSH
104805: CALL_OW 437
104809: PUSH
104810: LD_INT 1
104812: ARRAY
104813: PUSH
104814: LD_INT 4
104816: ARRAY
104817: ST_TO_ADDR
// end ;
104818: LD_VAR 0 2
104822: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
104823: LD_INT 0
104825: PPUSH
104826: PPUSH
104827: PPUSH
104828: PPUSH
// if not base_units then
104829: LD_VAR 0 1
104833: NOT
104834: IFFALSE 104838
// exit ;
104836: GO 104925
// result := false ;
104838: LD_ADDR_VAR 0 2
104842: PUSH
104843: LD_INT 0
104845: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
104846: LD_ADDR_VAR 0 5
104850: PUSH
104851: LD_VAR 0 1
104855: PPUSH
104856: LD_INT 21
104858: PUSH
104859: LD_INT 3
104861: PUSH
104862: EMPTY
104863: LIST
104864: LIST
104865: PPUSH
104866: CALL_OW 72
104870: ST_TO_ADDR
// if not tmp then
104871: LD_VAR 0 5
104875: NOT
104876: IFFALSE 104880
// exit ;
104878: GO 104925
// for i in tmp do
104880: LD_ADDR_VAR 0 3
104884: PUSH
104885: LD_VAR 0 5
104889: PUSH
104890: FOR_IN
104891: IFFALSE 104923
// begin result := EnemyInRange ( i , 22 ) ;
104893: LD_ADDR_VAR 0 2
104897: PUSH
104898: LD_VAR 0 3
104902: PPUSH
104903: LD_INT 22
104905: PPUSH
104906: CALL 102523 0 2
104910: ST_TO_ADDR
// if result then
104911: LD_VAR 0 2
104915: IFFALSE 104921
// exit ;
104917: POP
104918: POP
104919: GO 104925
// end ;
104921: GO 104890
104923: POP
104924: POP
// end ;
104925: LD_VAR 0 2
104929: RET
// export function FilterByTag ( units , tag ) ; begin
104930: LD_INT 0
104932: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
104933: LD_ADDR_VAR 0 3
104937: PUSH
104938: LD_VAR 0 1
104942: PPUSH
104943: LD_INT 120
104945: PUSH
104946: LD_VAR 0 2
104950: PUSH
104951: EMPTY
104952: LIST
104953: LIST
104954: PPUSH
104955: CALL_OW 72
104959: ST_TO_ADDR
// end ;
104960: LD_VAR 0 3
104964: RET
// export function IsDriver ( un ) ; begin
104965: LD_INT 0
104967: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
104968: LD_ADDR_VAR 0 2
104972: PUSH
104973: LD_VAR 0 1
104977: PUSH
104978: LD_INT 55
104980: PUSH
104981: EMPTY
104982: LIST
104983: PPUSH
104984: CALL_OW 69
104988: IN
104989: ST_TO_ADDR
// end ;
104990: LD_VAR 0 2
104994: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
104995: LD_INT 0
104997: PPUSH
104998: PPUSH
// list := [ ] ;
104999: LD_ADDR_VAR 0 5
105003: PUSH
105004: EMPTY
105005: ST_TO_ADDR
// case d of 0 :
105006: LD_VAR 0 3
105010: PUSH
105011: LD_INT 0
105013: DOUBLE
105014: EQUAL
105015: IFTRUE 105019
105017: GO 105152
105019: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
105020: LD_ADDR_VAR 0 5
105024: PUSH
105025: LD_VAR 0 1
105029: PUSH
105030: LD_INT 4
105032: MINUS
105033: PUSH
105034: LD_VAR 0 2
105038: PUSH
105039: LD_INT 4
105041: MINUS
105042: PUSH
105043: LD_INT 2
105045: PUSH
105046: EMPTY
105047: LIST
105048: LIST
105049: LIST
105050: PUSH
105051: LD_VAR 0 1
105055: PUSH
105056: LD_INT 3
105058: MINUS
105059: PUSH
105060: LD_VAR 0 2
105064: PUSH
105065: LD_INT 1
105067: PUSH
105068: EMPTY
105069: LIST
105070: LIST
105071: LIST
105072: PUSH
105073: LD_VAR 0 1
105077: PUSH
105078: LD_INT 4
105080: PLUS
105081: PUSH
105082: LD_VAR 0 2
105086: PUSH
105087: LD_INT 4
105089: PUSH
105090: EMPTY
105091: LIST
105092: LIST
105093: LIST
105094: PUSH
105095: LD_VAR 0 1
105099: PUSH
105100: LD_INT 3
105102: PLUS
105103: PUSH
105104: LD_VAR 0 2
105108: PUSH
105109: LD_INT 3
105111: PLUS
105112: PUSH
105113: LD_INT 5
105115: PUSH
105116: EMPTY
105117: LIST
105118: LIST
105119: LIST
105120: PUSH
105121: LD_VAR 0 1
105125: PUSH
105126: LD_VAR 0 2
105130: PUSH
105131: LD_INT 4
105133: PLUS
105134: PUSH
105135: LD_INT 0
105137: PUSH
105138: EMPTY
105139: LIST
105140: LIST
105141: LIST
105142: PUSH
105143: EMPTY
105144: LIST
105145: LIST
105146: LIST
105147: LIST
105148: LIST
105149: ST_TO_ADDR
// end ; 1 :
105150: GO 105850
105152: LD_INT 1
105154: DOUBLE
105155: EQUAL
105156: IFTRUE 105160
105158: GO 105293
105160: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
105161: LD_ADDR_VAR 0 5
105165: PUSH
105166: LD_VAR 0 1
105170: PUSH
105171: LD_VAR 0 2
105175: PUSH
105176: LD_INT 4
105178: MINUS
105179: PUSH
105180: LD_INT 3
105182: PUSH
105183: EMPTY
105184: LIST
105185: LIST
105186: LIST
105187: PUSH
105188: LD_VAR 0 1
105192: PUSH
105193: LD_INT 3
105195: MINUS
105196: PUSH
105197: LD_VAR 0 2
105201: PUSH
105202: LD_INT 3
105204: MINUS
105205: PUSH
105206: LD_INT 2
105208: PUSH
105209: EMPTY
105210: LIST
105211: LIST
105212: LIST
105213: PUSH
105214: LD_VAR 0 1
105218: PUSH
105219: LD_INT 4
105221: MINUS
105222: PUSH
105223: LD_VAR 0 2
105227: PUSH
105228: LD_INT 1
105230: PUSH
105231: EMPTY
105232: LIST
105233: LIST
105234: LIST
105235: PUSH
105236: LD_VAR 0 1
105240: PUSH
105241: LD_VAR 0 2
105245: PUSH
105246: LD_INT 3
105248: PLUS
105249: PUSH
105250: LD_INT 0
105252: PUSH
105253: EMPTY
105254: LIST
105255: LIST
105256: LIST
105257: PUSH
105258: LD_VAR 0 1
105262: PUSH
105263: LD_INT 4
105265: PLUS
105266: PUSH
105267: LD_VAR 0 2
105271: PUSH
105272: LD_INT 4
105274: PLUS
105275: PUSH
105276: LD_INT 5
105278: PUSH
105279: EMPTY
105280: LIST
105281: LIST
105282: LIST
105283: PUSH
105284: EMPTY
105285: LIST
105286: LIST
105287: LIST
105288: LIST
105289: LIST
105290: ST_TO_ADDR
// end ; 2 :
105291: GO 105850
105293: LD_INT 2
105295: DOUBLE
105296: EQUAL
105297: IFTRUE 105301
105299: GO 105430
105301: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
105302: LD_ADDR_VAR 0 5
105306: PUSH
105307: LD_VAR 0 1
105311: PUSH
105312: LD_VAR 0 2
105316: PUSH
105317: LD_INT 3
105319: MINUS
105320: PUSH
105321: LD_INT 3
105323: PUSH
105324: EMPTY
105325: LIST
105326: LIST
105327: LIST
105328: PUSH
105329: LD_VAR 0 1
105333: PUSH
105334: LD_INT 4
105336: PLUS
105337: PUSH
105338: LD_VAR 0 2
105342: PUSH
105343: LD_INT 4
105345: PUSH
105346: EMPTY
105347: LIST
105348: LIST
105349: LIST
105350: PUSH
105351: LD_VAR 0 1
105355: PUSH
105356: LD_VAR 0 2
105360: PUSH
105361: LD_INT 4
105363: PLUS
105364: PUSH
105365: LD_INT 0
105367: PUSH
105368: EMPTY
105369: LIST
105370: LIST
105371: LIST
105372: PUSH
105373: LD_VAR 0 1
105377: PUSH
105378: LD_INT 3
105380: MINUS
105381: PUSH
105382: LD_VAR 0 2
105386: PUSH
105387: LD_INT 1
105389: PUSH
105390: EMPTY
105391: LIST
105392: LIST
105393: LIST
105394: PUSH
105395: LD_VAR 0 1
105399: PUSH
105400: LD_INT 4
105402: MINUS
105403: PUSH
105404: LD_VAR 0 2
105408: PUSH
105409: LD_INT 4
105411: MINUS
105412: PUSH
105413: LD_INT 2
105415: PUSH
105416: EMPTY
105417: LIST
105418: LIST
105419: LIST
105420: PUSH
105421: EMPTY
105422: LIST
105423: LIST
105424: LIST
105425: LIST
105426: LIST
105427: ST_TO_ADDR
// end ; 3 :
105428: GO 105850
105430: LD_INT 3
105432: DOUBLE
105433: EQUAL
105434: IFTRUE 105438
105436: GO 105571
105438: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
105439: LD_ADDR_VAR 0 5
105443: PUSH
105444: LD_VAR 0 1
105448: PUSH
105449: LD_INT 3
105451: PLUS
105452: PUSH
105453: LD_VAR 0 2
105457: PUSH
105458: LD_INT 4
105460: PUSH
105461: EMPTY
105462: LIST
105463: LIST
105464: LIST
105465: PUSH
105466: LD_VAR 0 1
105470: PUSH
105471: LD_INT 4
105473: PLUS
105474: PUSH
105475: LD_VAR 0 2
105479: PUSH
105480: LD_INT 4
105482: PLUS
105483: PUSH
105484: LD_INT 5
105486: PUSH
105487: EMPTY
105488: LIST
105489: LIST
105490: LIST
105491: PUSH
105492: LD_VAR 0 1
105496: PUSH
105497: LD_INT 4
105499: MINUS
105500: PUSH
105501: LD_VAR 0 2
105505: PUSH
105506: LD_INT 1
105508: PUSH
105509: EMPTY
105510: LIST
105511: LIST
105512: LIST
105513: PUSH
105514: LD_VAR 0 1
105518: PUSH
105519: LD_VAR 0 2
105523: PUSH
105524: LD_INT 4
105526: MINUS
105527: PUSH
105528: LD_INT 3
105530: PUSH
105531: EMPTY
105532: LIST
105533: LIST
105534: LIST
105535: PUSH
105536: LD_VAR 0 1
105540: PUSH
105541: LD_INT 3
105543: MINUS
105544: PUSH
105545: LD_VAR 0 2
105549: PUSH
105550: LD_INT 3
105552: MINUS
105553: PUSH
105554: LD_INT 2
105556: PUSH
105557: EMPTY
105558: LIST
105559: LIST
105560: LIST
105561: PUSH
105562: EMPTY
105563: LIST
105564: LIST
105565: LIST
105566: LIST
105567: LIST
105568: ST_TO_ADDR
// end ; 4 :
105569: GO 105850
105571: LD_INT 4
105573: DOUBLE
105574: EQUAL
105575: IFTRUE 105579
105577: GO 105712
105579: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
105580: LD_ADDR_VAR 0 5
105584: PUSH
105585: LD_VAR 0 1
105589: PUSH
105590: LD_VAR 0 2
105594: PUSH
105595: LD_INT 4
105597: PLUS
105598: PUSH
105599: LD_INT 0
105601: PUSH
105602: EMPTY
105603: LIST
105604: LIST
105605: LIST
105606: PUSH
105607: LD_VAR 0 1
105611: PUSH
105612: LD_INT 3
105614: PLUS
105615: PUSH
105616: LD_VAR 0 2
105620: PUSH
105621: LD_INT 3
105623: PLUS
105624: PUSH
105625: LD_INT 5
105627: PUSH
105628: EMPTY
105629: LIST
105630: LIST
105631: LIST
105632: PUSH
105633: LD_VAR 0 1
105637: PUSH
105638: LD_INT 4
105640: PLUS
105641: PUSH
105642: LD_VAR 0 2
105646: PUSH
105647: LD_INT 4
105649: PUSH
105650: EMPTY
105651: LIST
105652: LIST
105653: LIST
105654: PUSH
105655: LD_VAR 0 1
105659: PUSH
105660: LD_VAR 0 2
105664: PUSH
105665: LD_INT 3
105667: MINUS
105668: PUSH
105669: LD_INT 3
105671: PUSH
105672: EMPTY
105673: LIST
105674: LIST
105675: LIST
105676: PUSH
105677: LD_VAR 0 1
105681: PUSH
105682: LD_INT 4
105684: MINUS
105685: PUSH
105686: LD_VAR 0 2
105690: PUSH
105691: LD_INT 4
105693: MINUS
105694: PUSH
105695: LD_INT 2
105697: PUSH
105698: EMPTY
105699: LIST
105700: LIST
105701: LIST
105702: PUSH
105703: EMPTY
105704: LIST
105705: LIST
105706: LIST
105707: LIST
105708: LIST
105709: ST_TO_ADDR
// end ; 5 :
105710: GO 105850
105712: LD_INT 5
105714: DOUBLE
105715: EQUAL
105716: IFTRUE 105720
105718: GO 105849
105720: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
105721: LD_ADDR_VAR 0 5
105725: PUSH
105726: LD_VAR 0 1
105730: PUSH
105731: LD_INT 4
105733: MINUS
105734: PUSH
105735: LD_VAR 0 2
105739: PUSH
105740: LD_INT 1
105742: PUSH
105743: EMPTY
105744: LIST
105745: LIST
105746: LIST
105747: PUSH
105748: LD_VAR 0 1
105752: PUSH
105753: LD_VAR 0 2
105757: PUSH
105758: LD_INT 4
105760: MINUS
105761: PUSH
105762: LD_INT 3
105764: PUSH
105765: EMPTY
105766: LIST
105767: LIST
105768: LIST
105769: PUSH
105770: LD_VAR 0 1
105774: PUSH
105775: LD_INT 4
105777: PLUS
105778: PUSH
105779: LD_VAR 0 2
105783: PUSH
105784: LD_INT 4
105786: PLUS
105787: PUSH
105788: LD_INT 5
105790: PUSH
105791: EMPTY
105792: LIST
105793: LIST
105794: LIST
105795: PUSH
105796: LD_VAR 0 1
105800: PUSH
105801: LD_INT 3
105803: PLUS
105804: PUSH
105805: LD_VAR 0 2
105809: PUSH
105810: LD_INT 4
105812: PUSH
105813: EMPTY
105814: LIST
105815: LIST
105816: LIST
105817: PUSH
105818: LD_VAR 0 1
105822: PUSH
105823: LD_VAR 0 2
105827: PUSH
105828: LD_INT 3
105830: PLUS
105831: PUSH
105832: LD_INT 0
105834: PUSH
105835: EMPTY
105836: LIST
105837: LIST
105838: LIST
105839: PUSH
105840: EMPTY
105841: LIST
105842: LIST
105843: LIST
105844: LIST
105845: LIST
105846: ST_TO_ADDR
// end ; end ;
105847: GO 105850
105849: POP
// result := list ;
105850: LD_ADDR_VAR 0 4
105854: PUSH
105855: LD_VAR 0 5
105859: ST_TO_ADDR
// end ;
105860: LD_VAR 0 4
105864: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
105865: LD_INT 0
105867: PPUSH
105868: PPUSH
105869: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
105870: LD_VAR 0 1
105874: NOT
105875: PUSH
105876: LD_VAR 0 2
105880: PUSH
105881: LD_INT 1
105883: PUSH
105884: LD_INT 2
105886: PUSH
105887: LD_INT 3
105889: PUSH
105890: LD_INT 4
105892: PUSH
105893: EMPTY
105894: LIST
105895: LIST
105896: LIST
105897: LIST
105898: IN
105899: NOT
105900: OR
105901: IFFALSE 105905
// exit ;
105903: GO 105988
// tmp := [ ] ;
105905: LD_ADDR_VAR 0 5
105909: PUSH
105910: EMPTY
105911: ST_TO_ADDR
// for i in units do
105912: LD_ADDR_VAR 0 4
105916: PUSH
105917: LD_VAR 0 1
105921: PUSH
105922: FOR_IN
105923: IFFALSE 105957
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
105925: LD_ADDR_VAR 0 5
105929: PUSH
105930: LD_VAR 0 5
105934: PPUSH
105935: LD_VAR 0 4
105939: PPUSH
105940: LD_VAR 0 2
105944: PPUSH
105945: CALL_OW 259
105949: PPUSH
105950: CALL 107361 0 2
105954: ST_TO_ADDR
105955: GO 105922
105957: POP
105958: POP
// if not tmp then
105959: LD_VAR 0 5
105963: NOT
105964: IFFALSE 105968
// exit ;
105966: GO 105988
// result := SortListByListDesc ( units , tmp ) ;
105968: LD_ADDR_VAR 0 3
105972: PUSH
105973: LD_VAR 0 1
105977: PPUSH
105978: LD_VAR 0 5
105982: PPUSH
105983: CALL_OW 77
105987: ST_TO_ADDR
// end ;
105988: LD_VAR 0 3
105992: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
105993: LD_INT 0
105995: PPUSH
105996: PPUSH
105997: PPUSH
// result := false ;
105998: LD_ADDR_VAR 0 3
106002: PUSH
106003: LD_INT 0
106005: ST_TO_ADDR
// if not building then
106006: LD_VAR 0 2
106010: NOT
106011: IFFALSE 106015
// exit ;
106013: GO 106153
// x := GetX ( building ) ;
106015: LD_ADDR_VAR 0 4
106019: PUSH
106020: LD_VAR 0 2
106024: PPUSH
106025: CALL_OW 250
106029: ST_TO_ADDR
// y := GetY ( building ) ;
106030: LD_ADDR_VAR 0 5
106034: PUSH
106035: LD_VAR 0 2
106039: PPUSH
106040: CALL_OW 251
106044: ST_TO_ADDR
// if not x or not y then
106045: LD_VAR 0 4
106049: NOT
106050: PUSH
106051: LD_VAR 0 5
106055: NOT
106056: OR
106057: IFFALSE 106061
// exit ;
106059: GO 106153
// if GetTaskList ( unit ) then
106061: LD_VAR 0 1
106065: PPUSH
106066: CALL_OW 437
106070: IFFALSE 106153
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106072: LD_STRING e
106074: PUSH
106075: LD_VAR 0 1
106079: PPUSH
106080: CALL_OW 437
106084: PUSH
106085: LD_INT 1
106087: ARRAY
106088: PUSH
106089: LD_INT 1
106091: ARRAY
106092: EQUAL
106093: PUSH
106094: LD_VAR 0 4
106098: PUSH
106099: LD_VAR 0 1
106103: PPUSH
106104: CALL_OW 437
106108: PUSH
106109: LD_INT 1
106111: ARRAY
106112: PUSH
106113: LD_INT 2
106115: ARRAY
106116: EQUAL
106117: AND
106118: PUSH
106119: LD_VAR 0 5
106123: PUSH
106124: LD_VAR 0 1
106128: PPUSH
106129: CALL_OW 437
106133: PUSH
106134: LD_INT 1
106136: ARRAY
106137: PUSH
106138: LD_INT 3
106140: ARRAY
106141: EQUAL
106142: AND
106143: IFFALSE 106153
// result := true end ;
106145: LD_ADDR_VAR 0 3
106149: PUSH
106150: LD_INT 1
106152: ST_TO_ADDR
// end ;
106153: LD_VAR 0 3
106157: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
106158: LD_INT 0
106160: PPUSH
// result := false ;
106161: LD_ADDR_VAR 0 4
106165: PUSH
106166: LD_INT 0
106168: ST_TO_ADDR
// if GetTaskList ( unit ) then
106169: LD_VAR 0 1
106173: PPUSH
106174: CALL_OW 437
106178: IFFALSE 106261
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106180: LD_STRING M
106182: PUSH
106183: LD_VAR 0 1
106187: PPUSH
106188: CALL_OW 437
106192: PUSH
106193: LD_INT 1
106195: ARRAY
106196: PUSH
106197: LD_INT 1
106199: ARRAY
106200: EQUAL
106201: PUSH
106202: LD_VAR 0 2
106206: PUSH
106207: LD_VAR 0 1
106211: PPUSH
106212: CALL_OW 437
106216: PUSH
106217: LD_INT 1
106219: ARRAY
106220: PUSH
106221: LD_INT 2
106223: ARRAY
106224: EQUAL
106225: AND
106226: PUSH
106227: LD_VAR 0 3
106231: PUSH
106232: LD_VAR 0 1
106236: PPUSH
106237: CALL_OW 437
106241: PUSH
106242: LD_INT 1
106244: ARRAY
106245: PUSH
106246: LD_INT 3
106248: ARRAY
106249: EQUAL
106250: AND
106251: IFFALSE 106261
// result := true ;
106253: LD_ADDR_VAR 0 4
106257: PUSH
106258: LD_INT 1
106260: ST_TO_ADDR
// end ; end ;
106261: LD_VAR 0 4
106265: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
106266: LD_INT 0
106268: PPUSH
106269: PPUSH
106270: PPUSH
106271: PPUSH
// if not unit or not area then
106272: LD_VAR 0 1
106276: NOT
106277: PUSH
106278: LD_VAR 0 2
106282: NOT
106283: OR
106284: IFFALSE 106288
// exit ;
106286: GO 106464
// tmp := AreaToList ( area , i ) ;
106288: LD_ADDR_VAR 0 6
106292: PUSH
106293: LD_VAR 0 2
106297: PPUSH
106298: LD_VAR 0 5
106302: PPUSH
106303: CALL_OW 517
106307: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
106308: LD_ADDR_VAR 0 5
106312: PUSH
106313: DOUBLE
106314: LD_INT 1
106316: DEC
106317: ST_TO_ADDR
106318: LD_VAR 0 6
106322: PUSH
106323: LD_INT 1
106325: ARRAY
106326: PUSH
106327: FOR_TO
106328: IFFALSE 106462
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
106330: LD_ADDR_VAR 0 7
106334: PUSH
106335: LD_VAR 0 6
106339: PUSH
106340: LD_INT 1
106342: ARRAY
106343: PUSH
106344: LD_VAR 0 5
106348: ARRAY
106349: PUSH
106350: LD_VAR 0 6
106354: PUSH
106355: LD_INT 2
106357: ARRAY
106358: PUSH
106359: LD_VAR 0 5
106363: ARRAY
106364: PUSH
106365: EMPTY
106366: LIST
106367: LIST
106368: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
106369: LD_INT 92
106371: PUSH
106372: LD_VAR 0 7
106376: PUSH
106377: LD_INT 1
106379: ARRAY
106380: PUSH
106381: LD_VAR 0 7
106385: PUSH
106386: LD_INT 2
106388: ARRAY
106389: PUSH
106390: LD_INT 2
106392: PUSH
106393: EMPTY
106394: LIST
106395: LIST
106396: LIST
106397: LIST
106398: PPUSH
106399: CALL_OW 69
106403: PUSH
106404: LD_INT 0
106406: EQUAL
106407: IFFALSE 106460
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
106409: LD_VAR 0 1
106413: PPUSH
106414: LD_VAR 0 7
106418: PUSH
106419: LD_INT 1
106421: ARRAY
106422: PPUSH
106423: LD_VAR 0 7
106427: PUSH
106428: LD_INT 2
106430: ARRAY
106431: PPUSH
106432: LD_VAR 0 3
106436: PPUSH
106437: CALL_OW 48
// result := IsPlaced ( unit ) ;
106441: LD_ADDR_VAR 0 4
106445: PUSH
106446: LD_VAR 0 1
106450: PPUSH
106451: CALL_OW 305
106455: ST_TO_ADDR
// exit ;
106456: POP
106457: POP
106458: GO 106464
// end ; end ;
106460: GO 106327
106462: POP
106463: POP
// end ;
106464: LD_VAR 0 4
106468: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
106469: LD_INT 0
106471: PPUSH
106472: PPUSH
106473: PPUSH
// if not side or side > 8 then
106474: LD_VAR 0 1
106478: NOT
106479: PUSH
106480: LD_VAR 0 1
106484: PUSH
106485: LD_INT 8
106487: GREATER
106488: OR
106489: IFFALSE 106493
// exit ;
106491: GO 106680
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
106493: LD_ADDR_VAR 0 4
106497: PUSH
106498: LD_INT 22
106500: PUSH
106501: LD_VAR 0 1
106505: PUSH
106506: EMPTY
106507: LIST
106508: LIST
106509: PUSH
106510: LD_INT 21
106512: PUSH
106513: LD_INT 3
106515: PUSH
106516: EMPTY
106517: LIST
106518: LIST
106519: PUSH
106520: EMPTY
106521: LIST
106522: LIST
106523: PPUSH
106524: CALL_OW 69
106528: ST_TO_ADDR
// if not tmp then
106529: LD_VAR 0 4
106533: NOT
106534: IFFALSE 106538
// exit ;
106536: GO 106680
// enable_addtolog := true ;
106538: LD_ADDR_OWVAR 81
106542: PUSH
106543: LD_INT 1
106545: ST_TO_ADDR
// AddToLog ( [ ) ;
106546: LD_STRING [
106548: PPUSH
106549: CALL_OW 561
// for i in tmp do
106553: LD_ADDR_VAR 0 3
106557: PUSH
106558: LD_VAR 0 4
106562: PUSH
106563: FOR_IN
106564: IFFALSE 106671
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
106566: LD_STRING [
106568: PUSH
106569: LD_VAR 0 3
106573: PPUSH
106574: CALL_OW 266
106578: STR
106579: PUSH
106580: LD_STRING , 
106582: STR
106583: PUSH
106584: LD_VAR 0 3
106588: PPUSH
106589: CALL_OW 250
106593: STR
106594: PUSH
106595: LD_STRING , 
106597: STR
106598: PUSH
106599: LD_VAR 0 3
106603: PPUSH
106604: CALL_OW 251
106608: STR
106609: PUSH
106610: LD_STRING , 
106612: STR
106613: PUSH
106614: LD_VAR 0 3
106618: PPUSH
106619: CALL_OW 254
106623: STR
106624: PUSH
106625: LD_STRING , 
106627: STR
106628: PUSH
106629: LD_VAR 0 3
106633: PPUSH
106634: LD_INT 1
106636: PPUSH
106637: CALL_OW 268
106641: STR
106642: PUSH
106643: LD_STRING , 
106645: STR
106646: PUSH
106647: LD_VAR 0 3
106651: PPUSH
106652: LD_INT 2
106654: PPUSH
106655: CALL_OW 268
106659: STR
106660: PUSH
106661: LD_STRING ],
106663: STR
106664: PPUSH
106665: CALL_OW 561
// end ;
106669: GO 106563
106671: POP
106672: POP
// AddToLog ( ]; ) ;
106673: LD_STRING ];
106675: PPUSH
106676: CALL_OW 561
// end ;
106680: LD_VAR 0 2
106684: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
106685: LD_INT 0
106687: PPUSH
106688: PPUSH
106689: PPUSH
106690: PPUSH
106691: PPUSH
// if not area or not rate or not max then
106692: LD_VAR 0 1
106696: NOT
106697: PUSH
106698: LD_VAR 0 2
106702: NOT
106703: OR
106704: PUSH
106705: LD_VAR 0 4
106709: NOT
106710: OR
106711: IFFALSE 106715
// exit ;
106713: GO 106904
// while 1 do
106715: LD_INT 1
106717: IFFALSE 106904
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
106719: LD_ADDR_VAR 0 9
106723: PUSH
106724: LD_VAR 0 1
106728: PPUSH
106729: LD_INT 1
106731: PPUSH
106732: CALL_OW 287
106736: PUSH
106737: LD_INT 10
106739: MUL
106740: ST_TO_ADDR
// r := rate / 10 ;
106741: LD_ADDR_VAR 0 7
106745: PUSH
106746: LD_VAR 0 2
106750: PUSH
106751: LD_INT 10
106753: DIVREAL
106754: ST_TO_ADDR
// time := 1 1$00 ;
106755: LD_ADDR_VAR 0 8
106759: PUSH
106760: LD_INT 2100
106762: ST_TO_ADDR
// if amount < min then
106763: LD_VAR 0 9
106767: PUSH
106768: LD_VAR 0 3
106772: LESS
106773: IFFALSE 106791
// r := r * 2 else
106775: LD_ADDR_VAR 0 7
106779: PUSH
106780: LD_VAR 0 7
106784: PUSH
106785: LD_INT 2
106787: MUL
106788: ST_TO_ADDR
106789: GO 106817
// if amount > max then
106791: LD_VAR 0 9
106795: PUSH
106796: LD_VAR 0 4
106800: GREATER
106801: IFFALSE 106817
// r := r / 2 ;
106803: LD_ADDR_VAR 0 7
106807: PUSH
106808: LD_VAR 0 7
106812: PUSH
106813: LD_INT 2
106815: DIVREAL
106816: ST_TO_ADDR
// time := time / r ;
106817: LD_ADDR_VAR 0 8
106821: PUSH
106822: LD_VAR 0 8
106826: PUSH
106827: LD_VAR 0 7
106831: DIVREAL
106832: ST_TO_ADDR
// if time < 0 then
106833: LD_VAR 0 8
106837: PUSH
106838: LD_INT 0
106840: LESS
106841: IFFALSE 106858
// time := time * - 1 ;
106843: LD_ADDR_VAR 0 8
106847: PUSH
106848: LD_VAR 0 8
106852: PUSH
106853: LD_INT 1
106855: NEG
106856: MUL
106857: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
106858: LD_VAR 0 8
106862: PUSH
106863: LD_INT 35
106865: PPUSH
106866: LD_INT 875
106868: PPUSH
106869: CALL_OW 12
106873: PLUS
106874: PPUSH
106875: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
106879: LD_INT 1
106881: PPUSH
106882: LD_INT 5
106884: PPUSH
106885: CALL_OW 12
106889: PPUSH
106890: LD_VAR 0 1
106894: PPUSH
106895: LD_INT 1
106897: PPUSH
106898: CALL_OW 55
// end ;
106902: GO 106715
// end ;
106904: LD_VAR 0 5
106908: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
106909: LD_INT 0
106911: PPUSH
106912: PPUSH
106913: PPUSH
106914: PPUSH
106915: PPUSH
106916: PPUSH
106917: PPUSH
106918: PPUSH
// if not turrets or not factories then
106919: LD_VAR 0 1
106923: NOT
106924: PUSH
106925: LD_VAR 0 2
106929: NOT
106930: OR
106931: IFFALSE 106935
// exit ;
106933: GO 107242
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
106935: LD_ADDR_VAR 0 10
106939: PUSH
106940: LD_INT 5
106942: PUSH
106943: LD_INT 6
106945: PUSH
106946: EMPTY
106947: LIST
106948: LIST
106949: PUSH
106950: LD_INT 2
106952: PUSH
106953: LD_INT 4
106955: PUSH
106956: EMPTY
106957: LIST
106958: LIST
106959: PUSH
106960: LD_INT 3
106962: PUSH
106963: LD_INT 5
106965: PUSH
106966: EMPTY
106967: LIST
106968: LIST
106969: PUSH
106970: EMPTY
106971: LIST
106972: LIST
106973: LIST
106974: PUSH
106975: LD_INT 24
106977: PUSH
106978: LD_INT 25
106980: PUSH
106981: EMPTY
106982: LIST
106983: LIST
106984: PUSH
106985: LD_INT 23
106987: PUSH
106988: LD_INT 27
106990: PUSH
106991: EMPTY
106992: LIST
106993: LIST
106994: PUSH
106995: EMPTY
106996: LIST
106997: LIST
106998: PUSH
106999: LD_INT 42
107001: PUSH
107002: LD_INT 43
107004: PUSH
107005: EMPTY
107006: LIST
107007: LIST
107008: PUSH
107009: LD_INT 44
107011: PUSH
107012: LD_INT 46
107014: PUSH
107015: EMPTY
107016: LIST
107017: LIST
107018: PUSH
107019: LD_INT 45
107021: PUSH
107022: LD_INT 47
107024: PUSH
107025: EMPTY
107026: LIST
107027: LIST
107028: PUSH
107029: EMPTY
107030: LIST
107031: LIST
107032: LIST
107033: PUSH
107034: EMPTY
107035: LIST
107036: LIST
107037: LIST
107038: ST_TO_ADDR
// result := [ ] ;
107039: LD_ADDR_VAR 0 3
107043: PUSH
107044: EMPTY
107045: ST_TO_ADDR
// for i in turrets do
107046: LD_ADDR_VAR 0 4
107050: PUSH
107051: LD_VAR 0 1
107055: PUSH
107056: FOR_IN
107057: IFFALSE 107240
// begin nat := GetNation ( i ) ;
107059: LD_ADDR_VAR 0 7
107063: PUSH
107064: LD_VAR 0 4
107068: PPUSH
107069: CALL_OW 248
107073: ST_TO_ADDR
// weapon := 0 ;
107074: LD_ADDR_VAR 0 8
107078: PUSH
107079: LD_INT 0
107081: ST_TO_ADDR
// if not nat then
107082: LD_VAR 0 7
107086: NOT
107087: IFFALSE 107091
// continue ;
107089: GO 107056
// for j in list [ nat ] do
107091: LD_ADDR_VAR 0 5
107095: PUSH
107096: LD_VAR 0 10
107100: PUSH
107101: LD_VAR 0 7
107105: ARRAY
107106: PUSH
107107: FOR_IN
107108: IFFALSE 107149
// if GetBWeapon ( i ) = j [ 1 ] then
107110: LD_VAR 0 4
107114: PPUSH
107115: CALL_OW 269
107119: PUSH
107120: LD_VAR 0 5
107124: PUSH
107125: LD_INT 1
107127: ARRAY
107128: EQUAL
107129: IFFALSE 107147
// begin weapon := j [ 2 ] ;
107131: LD_ADDR_VAR 0 8
107135: PUSH
107136: LD_VAR 0 5
107140: PUSH
107141: LD_INT 2
107143: ARRAY
107144: ST_TO_ADDR
// break ;
107145: GO 107149
// end ;
107147: GO 107107
107149: POP
107150: POP
// if not weapon then
107151: LD_VAR 0 8
107155: NOT
107156: IFFALSE 107160
// continue ;
107158: GO 107056
// for k in factories do
107160: LD_ADDR_VAR 0 6
107164: PUSH
107165: LD_VAR 0 2
107169: PUSH
107170: FOR_IN
107171: IFFALSE 107236
// begin weapons := AvailableWeaponList ( k ) ;
107173: LD_ADDR_VAR 0 9
107177: PUSH
107178: LD_VAR 0 6
107182: PPUSH
107183: CALL_OW 478
107187: ST_TO_ADDR
// if not weapons then
107188: LD_VAR 0 9
107192: NOT
107193: IFFALSE 107197
// continue ;
107195: GO 107170
// if weapon in weapons then
107197: LD_VAR 0 8
107201: PUSH
107202: LD_VAR 0 9
107206: IN
107207: IFFALSE 107234
// begin result := [ i , weapon ] ;
107209: LD_ADDR_VAR 0 3
107213: PUSH
107214: LD_VAR 0 4
107218: PUSH
107219: LD_VAR 0 8
107223: PUSH
107224: EMPTY
107225: LIST
107226: LIST
107227: ST_TO_ADDR
// exit ;
107228: POP
107229: POP
107230: POP
107231: POP
107232: GO 107242
// end ; end ;
107234: GO 107170
107236: POP
107237: POP
// end ;
107238: GO 107056
107240: POP
107241: POP
// end ;
107242: LD_VAR 0 3
107246: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
107247: LD_INT 0
107249: PPUSH
// if not side or side > 8 then
107250: LD_VAR 0 3
107254: NOT
107255: PUSH
107256: LD_VAR 0 3
107260: PUSH
107261: LD_INT 8
107263: GREATER
107264: OR
107265: IFFALSE 107269
// exit ;
107267: GO 107328
// if not range then
107269: LD_VAR 0 4
107273: NOT
107274: IFFALSE 107285
// range := - 12 ;
107276: LD_ADDR_VAR 0 4
107280: PUSH
107281: LD_INT 12
107283: NEG
107284: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
107285: LD_VAR 0 1
107289: PPUSH
107290: LD_VAR 0 2
107294: PPUSH
107295: LD_VAR 0 3
107299: PPUSH
107300: LD_VAR 0 4
107304: PPUSH
107305: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
107309: LD_VAR 0 1
107313: PPUSH
107314: LD_VAR 0 2
107318: PPUSH
107319: LD_VAR 0 3
107323: PPUSH
107324: CALL_OW 331
// end ;
107328: LD_VAR 0 5
107332: RET
// export function Video ( mode ) ; begin
107333: LD_INT 0
107335: PPUSH
// ingame_video = mode ;
107336: LD_ADDR_OWVAR 52
107340: PUSH
107341: LD_VAR 0 1
107345: ST_TO_ADDR
// interface_hidden = mode ;
107346: LD_ADDR_OWVAR 54
107350: PUSH
107351: LD_VAR 0 1
107355: ST_TO_ADDR
// end ;
107356: LD_VAR 0 2
107360: RET
// export function Join ( array , element ) ; begin
107361: LD_INT 0
107363: PPUSH
// result := Replace ( array , array + 1 , element ) ;
107364: LD_ADDR_VAR 0 3
107368: PUSH
107369: LD_VAR 0 1
107373: PPUSH
107374: LD_VAR 0 1
107378: PUSH
107379: LD_INT 1
107381: PLUS
107382: PPUSH
107383: LD_VAR 0 2
107387: PPUSH
107388: CALL_OW 1
107392: ST_TO_ADDR
// end ;
107393: LD_VAR 0 3
107397: RET
// export function JoinUnion ( array , element ) ; begin
107398: LD_INT 0
107400: PPUSH
// result := array union element ;
107401: LD_ADDR_VAR 0 3
107405: PUSH
107406: LD_VAR 0 1
107410: PUSH
107411: LD_VAR 0 2
107415: UNION
107416: ST_TO_ADDR
// end ;
107417: LD_VAR 0 3
107421: RET
// export function GetBehemoths ( side ) ; begin
107422: LD_INT 0
107424: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
107425: LD_ADDR_VAR 0 2
107429: PUSH
107430: LD_INT 22
107432: PUSH
107433: LD_VAR 0 1
107437: PUSH
107438: EMPTY
107439: LIST
107440: LIST
107441: PUSH
107442: LD_INT 31
107444: PUSH
107445: LD_INT 25
107447: PUSH
107448: EMPTY
107449: LIST
107450: LIST
107451: PUSH
107452: EMPTY
107453: LIST
107454: LIST
107455: PPUSH
107456: CALL_OW 69
107460: ST_TO_ADDR
// end ;
107461: LD_VAR 0 2
107465: RET
// export function Shuffle ( array ) ; var i , index ; begin
107466: LD_INT 0
107468: PPUSH
107469: PPUSH
107470: PPUSH
// result := [ ] ;
107471: LD_ADDR_VAR 0 2
107475: PUSH
107476: EMPTY
107477: ST_TO_ADDR
// if not array then
107478: LD_VAR 0 1
107482: NOT
107483: IFFALSE 107487
// exit ;
107485: GO 107586
// Randomize ;
107487: CALL_OW 10
// for i = array downto 1 do
107491: LD_ADDR_VAR 0 3
107495: PUSH
107496: DOUBLE
107497: LD_VAR 0 1
107501: INC
107502: ST_TO_ADDR
107503: LD_INT 1
107505: PUSH
107506: FOR_DOWNTO
107507: IFFALSE 107584
// begin index := rand ( 1 , array ) ;
107509: LD_ADDR_VAR 0 4
107513: PUSH
107514: LD_INT 1
107516: PPUSH
107517: LD_VAR 0 1
107521: PPUSH
107522: CALL_OW 12
107526: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
107527: LD_ADDR_VAR 0 2
107531: PUSH
107532: LD_VAR 0 2
107536: PPUSH
107537: LD_VAR 0 2
107541: PUSH
107542: LD_INT 1
107544: PLUS
107545: PPUSH
107546: LD_VAR 0 1
107550: PUSH
107551: LD_VAR 0 4
107555: ARRAY
107556: PPUSH
107557: CALL_OW 2
107561: ST_TO_ADDR
// array := Delete ( array , index ) ;
107562: LD_ADDR_VAR 0 1
107566: PUSH
107567: LD_VAR 0 1
107571: PPUSH
107572: LD_VAR 0 4
107576: PPUSH
107577: CALL_OW 3
107581: ST_TO_ADDR
// end ;
107582: GO 107506
107584: POP
107585: POP
// end ;
107586: LD_VAR 0 2
107590: RET
// export function GetBaseMaterials ( base ) ; begin
107591: LD_INT 0
107593: PPUSH
// result := [ 0 , 0 , 0 ] ;
107594: LD_ADDR_VAR 0 2
107598: PUSH
107599: LD_INT 0
107601: PUSH
107602: LD_INT 0
107604: PUSH
107605: LD_INT 0
107607: PUSH
107608: EMPTY
107609: LIST
107610: LIST
107611: LIST
107612: ST_TO_ADDR
// if not base then
107613: LD_VAR 0 1
107617: NOT
107618: IFFALSE 107622
// exit ;
107620: GO 107671
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
107622: LD_ADDR_VAR 0 2
107626: PUSH
107627: LD_VAR 0 1
107631: PPUSH
107632: LD_INT 1
107634: PPUSH
107635: CALL_OW 275
107639: PUSH
107640: LD_VAR 0 1
107644: PPUSH
107645: LD_INT 2
107647: PPUSH
107648: CALL_OW 275
107652: PUSH
107653: LD_VAR 0 1
107657: PPUSH
107658: LD_INT 3
107660: PPUSH
107661: CALL_OW 275
107665: PUSH
107666: EMPTY
107667: LIST
107668: LIST
107669: LIST
107670: ST_TO_ADDR
// end ;
107671: LD_VAR 0 2
107675: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
107676: LD_INT 0
107678: PPUSH
107679: PPUSH
// result := array ;
107680: LD_ADDR_VAR 0 3
107684: PUSH
107685: LD_VAR 0 1
107689: ST_TO_ADDR
// if size >= result then
107690: LD_VAR 0 2
107694: PUSH
107695: LD_VAR 0 3
107699: GREATEREQUAL
107700: IFFALSE 107704
// exit ;
107702: GO 107754
// if size then
107704: LD_VAR 0 2
107708: IFFALSE 107754
// for i := array downto size do
107710: LD_ADDR_VAR 0 4
107714: PUSH
107715: DOUBLE
107716: LD_VAR 0 1
107720: INC
107721: ST_TO_ADDR
107722: LD_VAR 0 2
107726: PUSH
107727: FOR_DOWNTO
107728: IFFALSE 107752
// result := Delete ( result , result ) ;
107730: LD_ADDR_VAR 0 3
107734: PUSH
107735: LD_VAR 0 3
107739: PPUSH
107740: LD_VAR 0 3
107744: PPUSH
107745: CALL_OW 3
107749: ST_TO_ADDR
107750: GO 107727
107752: POP
107753: POP
// end ;
107754: LD_VAR 0 3
107758: RET
// export function ComExit ( unit ) ; var tmp ; begin
107759: LD_INT 0
107761: PPUSH
107762: PPUSH
// if not IsInUnit ( unit ) then
107763: LD_VAR 0 1
107767: PPUSH
107768: CALL_OW 310
107772: NOT
107773: IFFALSE 107777
// exit ;
107775: GO 107837
// tmp := IsInUnit ( unit ) ;
107777: LD_ADDR_VAR 0 3
107781: PUSH
107782: LD_VAR 0 1
107786: PPUSH
107787: CALL_OW 310
107791: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
107792: LD_VAR 0 3
107796: PPUSH
107797: CALL_OW 247
107801: PUSH
107802: LD_INT 2
107804: EQUAL
107805: IFFALSE 107818
// ComExitVehicle ( unit ) else
107807: LD_VAR 0 1
107811: PPUSH
107812: CALL_OW 121
107816: GO 107827
// ComExitBuilding ( unit ) ;
107818: LD_VAR 0 1
107822: PPUSH
107823: CALL_OW 122
// result := tmp ;
107827: LD_ADDR_VAR 0 2
107831: PUSH
107832: LD_VAR 0 3
107836: ST_TO_ADDR
// end ;
107837: LD_VAR 0 2
107841: RET
// export function ComExitAll ( units ) ; var i ; begin
107842: LD_INT 0
107844: PPUSH
107845: PPUSH
// if not units then
107846: LD_VAR 0 1
107850: NOT
107851: IFFALSE 107855
// exit ;
107853: GO 107881
// for i in units do
107855: LD_ADDR_VAR 0 3
107859: PUSH
107860: LD_VAR 0 1
107864: PUSH
107865: FOR_IN
107866: IFFALSE 107879
// ComExit ( i ) ;
107868: LD_VAR 0 3
107872: PPUSH
107873: CALL 107759 0 1
107877: GO 107865
107879: POP
107880: POP
// end ;
107881: LD_VAR 0 2
107885: RET
// export function ResetHc ; begin
107886: LD_INT 0
107888: PPUSH
// InitHc ;
107889: CALL_OW 19
// hc_importance := 0 ;
107893: LD_ADDR_OWVAR 32
107897: PUSH
107898: LD_INT 0
107900: ST_TO_ADDR
// end ;
107901: LD_VAR 0 1
107905: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
107906: LD_INT 0
107908: PPUSH
107909: PPUSH
107910: PPUSH
// _x := ( x1 + x2 ) div 2 ;
107911: LD_ADDR_VAR 0 6
107915: PUSH
107916: LD_VAR 0 1
107920: PUSH
107921: LD_VAR 0 3
107925: PLUS
107926: PUSH
107927: LD_INT 2
107929: DIV
107930: ST_TO_ADDR
// if _x < 0 then
107931: LD_VAR 0 6
107935: PUSH
107936: LD_INT 0
107938: LESS
107939: IFFALSE 107956
// _x := _x * - 1 ;
107941: LD_ADDR_VAR 0 6
107945: PUSH
107946: LD_VAR 0 6
107950: PUSH
107951: LD_INT 1
107953: NEG
107954: MUL
107955: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
107956: LD_ADDR_VAR 0 7
107960: PUSH
107961: LD_VAR 0 2
107965: PUSH
107966: LD_VAR 0 4
107970: PLUS
107971: PUSH
107972: LD_INT 2
107974: DIV
107975: ST_TO_ADDR
// if _y < 0 then
107976: LD_VAR 0 7
107980: PUSH
107981: LD_INT 0
107983: LESS
107984: IFFALSE 108001
// _y := _y * - 1 ;
107986: LD_ADDR_VAR 0 7
107990: PUSH
107991: LD_VAR 0 7
107995: PUSH
107996: LD_INT 1
107998: NEG
107999: MUL
108000: ST_TO_ADDR
// result := [ _x , _y ] ;
108001: LD_ADDR_VAR 0 5
108005: PUSH
108006: LD_VAR 0 6
108010: PUSH
108011: LD_VAR 0 7
108015: PUSH
108016: EMPTY
108017: LIST
108018: LIST
108019: ST_TO_ADDR
// end ;
108020: LD_VAR 0 5
108024: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
108025: LD_INT 0
108027: PPUSH
108028: PPUSH
108029: PPUSH
108030: PPUSH
// task := GetTaskList ( unit ) ;
108031: LD_ADDR_VAR 0 7
108035: PUSH
108036: LD_VAR 0 1
108040: PPUSH
108041: CALL_OW 437
108045: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
108046: LD_VAR 0 7
108050: NOT
108051: PUSH
108052: LD_VAR 0 1
108056: PPUSH
108057: LD_VAR 0 2
108061: PPUSH
108062: CALL_OW 308
108066: NOT
108067: AND
108068: IFFALSE 108072
// exit ;
108070: GO 108190
// if IsInArea ( unit , area ) then
108072: LD_VAR 0 1
108076: PPUSH
108077: LD_VAR 0 2
108081: PPUSH
108082: CALL_OW 308
108086: IFFALSE 108104
// begin ComMoveToArea ( unit , goAway ) ;
108088: LD_VAR 0 1
108092: PPUSH
108093: LD_VAR 0 3
108097: PPUSH
108098: CALL_OW 113
// exit ;
108102: GO 108190
// end ; if task [ 1 ] [ 1 ] <> M then
108104: LD_VAR 0 7
108108: PUSH
108109: LD_INT 1
108111: ARRAY
108112: PUSH
108113: LD_INT 1
108115: ARRAY
108116: PUSH
108117: LD_STRING M
108119: NONEQUAL
108120: IFFALSE 108124
// exit ;
108122: GO 108190
// x := task [ 1 ] [ 2 ] ;
108124: LD_ADDR_VAR 0 5
108128: PUSH
108129: LD_VAR 0 7
108133: PUSH
108134: LD_INT 1
108136: ARRAY
108137: PUSH
108138: LD_INT 2
108140: ARRAY
108141: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
108142: LD_ADDR_VAR 0 6
108146: PUSH
108147: LD_VAR 0 7
108151: PUSH
108152: LD_INT 1
108154: ARRAY
108155: PUSH
108156: LD_INT 3
108158: ARRAY
108159: ST_TO_ADDR
// if InArea ( x , y , area ) then
108160: LD_VAR 0 5
108164: PPUSH
108165: LD_VAR 0 6
108169: PPUSH
108170: LD_VAR 0 2
108174: PPUSH
108175: CALL_OW 309
108179: IFFALSE 108190
// ComStop ( unit ) ;
108181: LD_VAR 0 1
108185: PPUSH
108186: CALL_OW 141
// end ;
108190: LD_VAR 0 4
108194: RET
// export function Abs ( value ) ; begin
108195: LD_INT 0
108197: PPUSH
// result := value ;
108198: LD_ADDR_VAR 0 2
108202: PUSH
108203: LD_VAR 0 1
108207: ST_TO_ADDR
// if value < 0 then
108208: LD_VAR 0 1
108212: PUSH
108213: LD_INT 0
108215: LESS
108216: IFFALSE 108233
// result := value * - 1 ;
108218: LD_ADDR_VAR 0 2
108222: PUSH
108223: LD_VAR 0 1
108227: PUSH
108228: LD_INT 1
108230: NEG
108231: MUL
108232: ST_TO_ADDR
// end ;
108233: LD_VAR 0 2
108237: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
108238: LD_INT 0
108240: PPUSH
108241: PPUSH
108242: PPUSH
108243: PPUSH
108244: PPUSH
108245: PPUSH
108246: PPUSH
108247: PPUSH
// if not unit or not building then
108248: LD_VAR 0 1
108252: NOT
108253: PUSH
108254: LD_VAR 0 2
108258: NOT
108259: OR
108260: IFFALSE 108264
// exit ;
108262: GO 108490
// x := GetX ( building ) ;
108264: LD_ADDR_VAR 0 4
108268: PUSH
108269: LD_VAR 0 2
108273: PPUSH
108274: CALL_OW 250
108278: ST_TO_ADDR
// y := GetY ( building ) ;
108279: LD_ADDR_VAR 0 6
108283: PUSH
108284: LD_VAR 0 2
108288: PPUSH
108289: CALL_OW 251
108293: ST_TO_ADDR
// d := GetDir ( building ) ;
108294: LD_ADDR_VAR 0 8
108298: PUSH
108299: LD_VAR 0 2
108303: PPUSH
108304: CALL_OW 254
108308: ST_TO_ADDR
// r := 4 ;
108309: LD_ADDR_VAR 0 9
108313: PUSH
108314: LD_INT 4
108316: ST_TO_ADDR
// for i := 1 to 5 do
108317: LD_ADDR_VAR 0 10
108321: PUSH
108322: DOUBLE
108323: LD_INT 1
108325: DEC
108326: ST_TO_ADDR
108327: LD_INT 5
108329: PUSH
108330: FOR_TO
108331: IFFALSE 108488
// begin _x := ShiftX ( x , d , r + i ) ;
108333: LD_ADDR_VAR 0 5
108337: PUSH
108338: LD_VAR 0 4
108342: PPUSH
108343: LD_VAR 0 8
108347: PPUSH
108348: LD_VAR 0 9
108352: PUSH
108353: LD_VAR 0 10
108357: PLUS
108358: PPUSH
108359: CALL_OW 272
108363: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
108364: LD_ADDR_VAR 0 7
108368: PUSH
108369: LD_VAR 0 6
108373: PPUSH
108374: LD_VAR 0 8
108378: PPUSH
108379: LD_VAR 0 9
108383: PUSH
108384: LD_VAR 0 10
108388: PLUS
108389: PPUSH
108390: CALL_OW 273
108394: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
108395: LD_VAR 0 5
108399: PPUSH
108400: LD_VAR 0 7
108404: PPUSH
108405: CALL_OW 488
108409: PUSH
108410: LD_VAR 0 5
108414: PPUSH
108415: LD_VAR 0 7
108419: PPUSH
108420: CALL_OW 428
108424: PPUSH
108425: CALL_OW 247
108429: PUSH
108430: LD_INT 3
108432: PUSH
108433: LD_INT 2
108435: PUSH
108436: EMPTY
108437: LIST
108438: LIST
108439: IN
108440: NOT
108441: AND
108442: IFFALSE 108486
// begin ComMoveXY ( unit , _x , _y ) ;
108444: LD_VAR 0 1
108448: PPUSH
108449: LD_VAR 0 5
108453: PPUSH
108454: LD_VAR 0 7
108458: PPUSH
108459: CALL_OW 111
// result := [ _x , _y ] ;
108463: LD_ADDR_VAR 0 3
108467: PUSH
108468: LD_VAR 0 5
108472: PUSH
108473: LD_VAR 0 7
108477: PUSH
108478: EMPTY
108479: LIST
108480: LIST
108481: ST_TO_ADDR
// exit ;
108482: POP
108483: POP
108484: GO 108490
// end ; end ;
108486: GO 108330
108488: POP
108489: POP
// end ;
108490: LD_VAR 0 3
108494: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
108495: LD_INT 0
108497: PPUSH
108498: PPUSH
108499: PPUSH
// result := 0 ;
108500: LD_ADDR_VAR 0 3
108504: PUSH
108505: LD_INT 0
108507: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
108508: LD_VAR 0 1
108512: PUSH
108513: LD_INT 0
108515: LESS
108516: PUSH
108517: LD_VAR 0 1
108521: PUSH
108522: LD_INT 8
108524: GREATER
108525: OR
108526: PUSH
108527: LD_VAR 0 2
108531: PUSH
108532: LD_INT 0
108534: LESS
108535: OR
108536: PUSH
108537: LD_VAR 0 2
108541: PUSH
108542: LD_INT 8
108544: GREATER
108545: OR
108546: IFFALSE 108550
// exit ;
108548: GO 108625
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
108550: LD_ADDR_VAR 0 4
108554: PUSH
108555: LD_INT 22
108557: PUSH
108558: LD_VAR 0 2
108562: PUSH
108563: EMPTY
108564: LIST
108565: LIST
108566: PPUSH
108567: CALL_OW 69
108571: PUSH
108572: FOR_IN
108573: IFFALSE 108623
// begin un := UnitShoot ( i ) ;
108575: LD_ADDR_VAR 0 5
108579: PUSH
108580: LD_VAR 0 4
108584: PPUSH
108585: CALL_OW 504
108589: ST_TO_ADDR
// if GetSide ( un ) = side1 then
108590: LD_VAR 0 5
108594: PPUSH
108595: CALL_OW 255
108599: PUSH
108600: LD_VAR 0 1
108604: EQUAL
108605: IFFALSE 108621
// begin result := un ;
108607: LD_ADDR_VAR 0 3
108611: PUSH
108612: LD_VAR 0 5
108616: ST_TO_ADDR
// exit ;
108617: POP
108618: POP
108619: GO 108625
// end ; end ;
108621: GO 108572
108623: POP
108624: POP
// end ;
108625: LD_VAR 0 3
108629: RET
// export function GetCargoBay ( units ) ; begin
108630: LD_INT 0
108632: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
108633: LD_ADDR_VAR 0 2
108637: PUSH
108638: LD_VAR 0 1
108642: PPUSH
108643: LD_INT 2
108645: PUSH
108646: LD_INT 34
108648: PUSH
108649: LD_INT 12
108651: PUSH
108652: EMPTY
108653: LIST
108654: LIST
108655: PUSH
108656: LD_INT 34
108658: PUSH
108659: LD_INT 51
108661: PUSH
108662: EMPTY
108663: LIST
108664: LIST
108665: PUSH
108666: LD_INT 34
108668: PUSH
108669: LD_INT 32
108671: PUSH
108672: EMPTY
108673: LIST
108674: LIST
108675: PUSH
108676: LD_INT 34
108678: PUSH
108679: LD_INT 89
108681: PUSH
108682: EMPTY
108683: LIST
108684: LIST
108685: PUSH
108686: EMPTY
108687: LIST
108688: LIST
108689: LIST
108690: LIST
108691: LIST
108692: PPUSH
108693: CALL_OW 72
108697: ST_TO_ADDR
// end ;
108698: LD_VAR 0 2
108702: RET
// export function Negate ( value ) ; begin
108703: LD_INT 0
108705: PPUSH
// result := not value ;
108706: LD_ADDR_VAR 0 2
108710: PUSH
108711: LD_VAR 0 1
108715: NOT
108716: ST_TO_ADDR
// end ;
108717: LD_VAR 0 2
108721: RET
// export function Inc ( value ) ; begin
108722: LD_INT 0
108724: PPUSH
// result := value + 1 ;
108725: LD_ADDR_VAR 0 2
108729: PUSH
108730: LD_VAR 0 1
108734: PUSH
108735: LD_INT 1
108737: PLUS
108738: ST_TO_ADDR
// end ;
108739: LD_VAR 0 2
108743: RET
// export function Dec ( value ) ; begin
108744: LD_INT 0
108746: PPUSH
// result := value - 1 ;
108747: LD_ADDR_VAR 0 2
108751: PUSH
108752: LD_VAR 0 1
108756: PUSH
108757: LD_INT 1
108759: MINUS
108760: ST_TO_ADDR
// end ;
108761: LD_VAR 0 2
108765: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
108766: LD_INT 0
108768: PPUSH
108769: PPUSH
108770: PPUSH
108771: PPUSH
108772: PPUSH
108773: PPUSH
108774: PPUSH
108775: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
108776: LD_VAR 0 1
108780: PPUSH
108781: LD_VAR 0 2
108785: PPUSH
108786: CALL_OW 488
108790: NOT
108791: PUSH
108792: LD_VAR 0 3
108796: PPUSH
108797: LD_VAR 0 4
108801: PPUSH
108802: CALL_OW 488
108806: NOT
108807: OR
108808: IFFALSE 108821
// begin result := - 1 ;
108810: LD_ADDR_VAR 0 5
108814: PUSH
108815: LD_INT 1
108817: NEG
108818: ST_TO_ADDR
// exit ;
108819: GO 109056
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
108821: LD_ADDR_VAR 0 12
108825: PUSH
108826: LD_VAR 0 1
108830: PPUSH
108831: LD_VAR 0 2
108835: PPUSH
108836: LD_VAR 0 3
108840: PPUSH
108841: LD_VAR 0 4
108845: PPUSH
108846: CALL 107906 0 4
108850: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
108851: LD_ADDR_VAR 0 11
108855: PUSH
108856: LD_VAR 0 1
108860: PPUSH
108861: LD_VAR 0 2
108865: PPUSH
108866: LD_VAR 0 12
108870: PUSH
108871: LD_INT 1
108873: ARRAY
108874: PPUSH
108875: LD_VAR 0 12
108879: PUSH
108880: LD_INT 2
108882: ARRAY
108883: PPUSH
108884: CALL_OW 298
108888: ST_TO_ADDR
// distance := 9999 ;
108889: LD_ADDR_VAR 0 10
108893: PUSH
108894: LD_INT 9999
108896: ST_TO_ADDR
// for i := 0 to 5 do
108897: LD_ADDR_VAR 0 6
108901: PUSH
108902: DOUBLE
108903: LD_INT 0
108905: DEC
108906: ST_TO_ADDR
108907: LD_INT 5
108909: PUSH
108910: FOR_TO
108911: IFFALSE 109054
// begin _x := ShiftX ( x1 , i , centerDist ) ;
108913: LD_ADDR_VAR 0 7
108917: PUSH
108918: LD_VAR 0 1
108922: PPUSH
108923: LD_VAR 0 6
108927: PPUSH
108928: LD_VAR 0 11
108932: PPUSH
108933: CALL_OW 272
108937: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
108938: LD_ADDR_VAR 0 8
108942: PUSH
108943: LD_VAR 0 2
108947: PPUSH
108948: LD_VAR 0 6
108952: PPUSH
108953: LD_VAR 0 11
108957: PPUSH
108958: CALL_OW 273
108962: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
108963: LD_VAR 0 7
108967: PPUSH
108968: LD_VAR 0 8
108972: PPUSH
108973: CALL_OW 488
108977: NOT
108978: IFFALSE 108982
// continue ;
108980: GO 108910
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
108982: LD_ADDR_VAR 0 9
108986: PUSH
108987: LD_VAR 0 12
108991: PUSH
108992: LD_INT 1
108994: ARRAY
108995: PPUSH
108996: LD_VAR 0 12
109000: PUSH
109001: LD_INT 2
109003: ARRAY
109004: PPUSH
109005: LD_VAR 0 7
109009: PPUSH
109010: LD_VAR 0 8
109014: PPUSH
109015: CALL_OW 298
109019: ST_TO_ADDR
// if tmp < distance then
109020: LD_VAR 0 9
109024: PUSH
109025: LD_VAR 0 10
109029: LESS
109030: IFFALSE 109052
// begin result := i ;
109032: LD_ADDR_VAR 0 5
109036: PUSH
109037: LD_VAR 0 6
109041: ST_TO_ADDR
// distance := tmp ;
109042: LD_ADDR_VAR 0 10
109046: PUSH
109047: LD_VAR 0 9
109051: ST_TO_ADDR
// end ; end ;
109052: GO 108910
109054: POP
109055: POP
// end ;
109056: LD_VAR 0 5
109060: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
109061: LD_INT 0
109063: PPUSH
109064: PPUSH
// if not driver or not IsInUnit ( driver ) then
109065: LD_VAR 0 1
109069: NOT
109070: PUSH
109071: LD_VAR 0 1
109075: PPUSH
109076: CALL_OW 310
109080: NOT
109081: OR
109082: IFFALSE 109086
// exit ;
109084: GO 109176
// vehicle := IsInUnit ( driver ) ;
109086: LD_ADDR_VAR 0 3
109090: PUSH
109091: LD_VAR 0 1
109095: PPUSH
109096: CALL_OW 310
109100: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
109101: LD_VAR 0 1
109105: PPUSH
109106: LD_STRING \
109108: PUSH
109109: LD_INT 0
109111: PUSH
109112: LD_INT 0
109114: PUSH
109115: LD_INT 0
109117: PUSH
109118: LD_INT 0
109120: PUSH
109121: LD_INT 0
109123: PUSH
109124: LD_INT 0
109126: PUSH
109127: EMPTY
109128: LIST
109129: LIST
109130: LIST
109131: LIST
109132: LIST
109133: LIST
109134: LIST
109135: PUSH
109136: LD_STRING E
109138: PUSH
109139: LD_INT 0
109141: PUSH
109142: LD_INT 0
109144: PUSH
109145: LD_VAR 0 3
109149: PUSH
109150: LD_INT 0
109152: PUSH
109153: LD_INT 0
109155: PUSH
109156: LD_INT 0
109158: PUSH
109159: EMPTY
109160: LIST
109161: LIST
109162: LIST
109163: LIST
109164: LIST
109165: LIST
109166: LIST
109167: PUSH
109168: EMPTY
109169: LIST
109170: LIST
109171: PPUSH
109172: CALL_OW 446
// end ;
109176: LD_VAR 0 2
109180: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
109181: LD_INT 0
109183: PPUSH
109184: PPUSH
// if not driver or not IsInUnit ( driver ) then
109185: LD_VAR 0 1
109189: NOT
109190: PUSH
109191: LD_VAR 0 1
109195: PPUSH
109196: CALL_OW 310
109200: NOT
109201: OR
109202: IFFALSE 109206
// exit ;
109204: GO 109296
// vehicle := IsInUnit ( driver ) ;
109206: LD_ADDR_VAR 0 3
109210: PUSH
109211: LD_VAR 0 1
109215: PPUSH
109216: CALL_OW 310
109220: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
109221: LD_VAR 0 1
109225: PPUSH
109226: LD_STRING \
109228: PUSH
109229: LD_INT 0
109231: PUSH
109232: LD_INT 0
109234: PUSH
109235: LD_INT 0
109237: PUSH
109238: LD_INT 0
109240: PUSH
109241: LD_INT 0
109243: PUSH
109244: LD_INT 0
109246: PUSH
109247: EMPTY
109248: LIST
109249: LIST
109250: LIST
109251: LIST
109252: LIST
109253: LIST
109254: LIST
109255: PUSH
109256: LD_STRING E
109258: PUSH
109259: LD_INT 0
109261: PUSH
109262: LD_INT 0
109264: PUSH
109265: LD_VAR 0 3
109269: PUSH
109270: LD_INT 0
109272: PUSH
109273: LD_INT 0
109275: PUSH
109276: LD_INT 0
109278: PUSH
109279: EMPTY
109280: LIST
109281: LIST
109282: LIST
109283: LIST
109284: LIST
109285: LIST
109286: LIST
109287: PUSH
109288: EMPTY
109289: LIST
109290: LIST
109291: PPUSH
109292: CALL_OW 447
// end ;
109296: LD_VAR 0 2
109300: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
109301: LD_INT 0
109303: PPUSH
109304: PPUSH
109305: PPUSH
// tmp := [ ] ;
109306: LD_ADDR_VAR 0 5
109310: PUSH
109311: EMPTY
109312: ST_TO_ADDR
// for i in units do
109313: LD_ADDR_VAR 0 4
109317: PUSH
109318: LD_VAR 0 1
109322: PUSH
109323: FOR_IN
109324: IFFALSE 109362
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
109326: LD_ADDR_VAR 0 5
109330: PUSH
109331: LD_VAR 0 5
109335: PPUSH
109336: LD_VAR 0 5
109340: PUSH
109341: LD_INT 1
109343: PLUS
109344: PPUSH
109345: LD_VAR 0 4
109349: PPUSH
109350: CALL_OW 256
109354: PPUSH
109355: CALL_OW 2
109359: ST_TO_ADDR
109360: GO 109323
109362: POP
109363: POP
// if not tmp then
109364: LD_VAR 0 5
109368: NOT
109369: IFFALSE 109373
// exit ;
109371: GO 109421
// if asc then
109373: LD_VAR 0 2
109377: IFFALSE 109401
// result := SortListByListAsc ( units , tmp ) else
109379: LD_ADDR_VAR 0 3
109383: PUSH
109384: LD_VAR 0 1
109388: PPUSH
109389: LD_VAR 0 5
109393: PPUSH
109394: CALL_OW 76
109398: ST_TO_ADDR
109399: GO 109421
// result := SortListByListDesc ( units , tmp ) ;
109401: LD_ADDR_VAR 0 3
109405: PUSH
109406: LD_VAR 0 1
109410: PPUSH
109411: LD_VAR 0 5
109415: PPUSH
109416: CALL_OW 77
109420: ST_TO_ADDR
// end ;
109421: LD_VAR 0 3
109425: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
109426: LD_INT 0
109428: PPUSH
109429: PPUSH
// task := GetTaskList ( mech ) ;
109430: LD_ADDR_VAR 0 4
109434: PUSH
109435: LD_VAR 0 1
109439: PPUSH
109440: CALL_OW 437
109444: ST_TO_ADDR
// if not task then
109445: LD_VAR 0 4
109449: NOT
109450: IFFALSE 109454
// exit ;
109452: GO 109496
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
109454: LD_ADDR_VAR 0 3
109458: PUSH
109459: LD_VAR 0 4
109463: PUSH
109464: LD_INT 1
109466: ARRAY
109467: PUSH
109468: LD_INT 1
109470: ARRAY
109471: PUSH
109472: LD_STRING r
109474: EQUAL
109475: PUSH
109476: LD_VAR 0 4
109480: PUSH
109481: LD_INT 1
109483: ARRAY
109484: PUSH
109485: LD_INT 4
109487: ARRAY
109488: PUSH
109489: LD_VAR 0 2
109493: EQUAL
109494: AND
109495: ST_TO_ADDR
// end ;
109496: LD_VAR 0 3
109500: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
109501: LD_INT 0
109503: PPUSH
// SetDir ( unit , d ) ;
109504: LD_VAR 0 1
109508: PPUSH
109509: LD_VAR 0 4
109513: PPUSH
109514: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
109518: LD_VAR 0 1
109522: PPUSH
109523: LD_VAR 0 2
109527: PPUSH
109528: LD_VAR 0 3
109532: PPUSH
109533: LD_VAR 0 5
109537: PPUSH
109538: CALL_OW 48
// end ;
109542: LD_VAR 0 6
109546: RET
// export function ToNaturalNumber ( number ) ; begin
109547: LD_INT 0
109549: PPUSH
// result := number div 1 ;
109550: LD_ADDR_VAR 0 2
109554: PUSH
109555: LD_VAR 0 1
109559: PUSH
109560: LD_INT 1
109562: DIV
109563: ST_TO_ADDR
// if number < 0 then
109564: LD_VAR 0 1
109568: PUSH
109569: LD_INT 0
109571: LESS
109572: IFFALSE 109582
// result := 0 ;
109574: LD_ADDR_VAR 0 2
109578: PUSH
109579: LD_INT 0
109581: ST_TO_ADDR
// end ;
109582: LD_VAR 0 2
109586: RET
// export function SortByClass ( units , class ) ; var un ; begin
109587: LD_INT 0
109589: PPUSH
109590: PPUSH
// if not units or not class then
109591: LD_VAR 0 1
109595: NOT
109596: PUSH
109597: LD_VAR 0 2
109601: NOT
109602: OR
109603: IFFALSE 109607
// exit ;
109605: GO 109702
// result := [ ] ;
109607: LD_ADDR_VAR 0 3
109611: PUSH
109612: EMPTY
109613: ST_TO_ADDR
// for un in units do
109614: LD_ADDR_VAR 0 4
109618: PUSH
109619: LD_VAR 0 1
109623: PUSH
109624: FOR_IN
109625: IFFALSE 109700
// if GetClass ( un ) = class then
109627: LD_VAR 0 4
109631: PPUSH
109632: CALL_OW 257
109636: PUSH
109637: LD_VAR 0 2
109641: EQUAL
109642: IFFALSE 109669
// result := Insert ( result , 1 , un ) else
109644: LD_ADDR_VAR 0 3
109648: PUSH
109649: LD_VAR 0 3
109653: PPUSH
109654: LD_INT 1
109656: PPUSH
109657: LD_VAR 0 4
109661: PPUSH
109662: CALL_OW 2
109666: ST_TO_ADDR
109667: GO 109698
// result := Replace ( result , result + 1 , un ) ;
109669: LD_ADDR_VAR 0 3
109673: PUSH
109674: LD_VAR 0 3
109678: PPUSH
109679: LD_VAR 0 3
109683: PUSH
109684: LD_INT 1
109686: PLUS
109687: PPUSH
109688: LD_VAR 0 4
109692: PPUSH
109693: CALL_OW 1
109697: ST_TO_ADDR
109698: GO 109624
109700: POP
109701: POP
// end ;
109702: LD_VAR 0 3
109706: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
109707: LD_INT 0
109709: PPUSH
109710: PPUSH
109711: PPUSH
109712: PPUSH
109713: PPUSH
109714: PPUSH
109715: PPUSH
// result := [ ] ;
109716: LD_ADDR_VAR 0 4
109720: PUSH
109721: EMPTY
109722: ST_TO_ADDR
// if x - r < 0 then
109723: LD_VAR 0 1
109727: PUSH
109728: LD_VAR 0 3
109732: MINUS
109733: PUSH
109734: LD_INT 0
109736: LESS
109737: IFFALSE 109749
// min_x := 0 else
109739: LD_ADDR_VAR 0 8
109743: PUSH
109744: LD_INT 0
109746: ST_TO_ADDR
109747: GO 109765
// min_x := x - r ;
109749: LD_ADDR_VAR 0 8
109753: PUSH
109754: LD_VAR 0 1
109758: PUSH
109759: LD_VAR 0 3
109763: MINUS
109764: ST_TO_ADDR
// if y - r < 0 then
109765: LD_VAR 0 2
109769: PUSH
109770: LD_VAR 0 3
109774: MINUS
109775: PUSH
109776: LD_INT 0
109778: LESS
109779: IFFALSE 109791
// min_y := 0 else
109781: LD_ADDR_VAR 0 7
109785: PUSH
109786: LD_INT 0
109788: ST_TO_ADDR
109789: GO 109807
// min_y := y - r ;
109791: LD_ADDR_VAR 0 7
109795: PUSH
109796: LD_VAR 0 2
109800: PUSH
109801: LD_VAR 0 3
109805: MINUS
109806: ST_TO_ADDR
// max_x := x + r ;
109807: LD_ADDR_VAR 0 9
109811: PUSH
109812: LD_VAR 0 1
109816: PUSH
109817: LD_VAR 0 3
109821: PLUS
109822: ST_TO_ADDR
// max_y := y + r ;
109823: LD_ADDR_VAR 0 10
109827: PUSH
109828: LD_VAR 0 2
109832: PUSH
109833: LD_VAR 0 3
109837: PLUS
109838: ST_TO_ADDR
// for _x = min_x to max_x do
109839: LD_ADDR_VAR 0 5
109843: PUSH
109844: DOUBLE
109845: LD_VAR 0 8
109849: DEC
109850: ST_TO_ADDR
109851: LD_VAR 0 9
109855: PUSH
109856: FOR_TO
109857: IFFALSE 109958
// for _y = min_y to max_y do
109859: LD_ADDR_VAR 0 6
109863: PUSH
109864: DOUBLE
109865: LD_VAR 0 7
109869: DEC
109870: ST_TO_ADDR
109871: LD_VAR 0 10
109875: PUSH
109876: FOR_TO
109877: IFFALSE 109954
// begin if not ValidHex ( _x , _y ) then
109879: LD_VAR 0 5
109883: PPUSH
109884: LD_VAR 0 6
109888: PPUSH
109889: CALL_OW 488
109893: NOT
109894: IFFALSE 109898
// continue ;
109896: GO 109876
// if GetResourceTypeXY ( _x , _y ) then
109898: LD_VAR 0 5
109902: PPUSH
109903: LD_VAR 0 6
109907: PPUSH
109908: CALL_OW 283
109912: IFFALSE 109952
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
109914: LD_ADDR_VAR 0 4
109918: PUSH
109919: LD_VAR 0 4
109923: PPUSH
109924: LD_VAR 0 4
109928: PUSH
109929: LD_INT 1
109931: PLUS
109932: PPUSH
109933: LD_VAR 0 5
109937: PUSH
109938: LD_VAR 0 6
109942: PUSH
109943: EMPTY
109944: LIST
109945: LIST
109946: PPUSH
109947: CALL_OW 1
109951: ST_TO_ADDR
// end ;
109952: GO 109876
109954: POP
109955: POP
109956: GO 109856
109958: POP
109959: POP
// end ;
109960: LD_VAR 0 4
109964: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
109965: LD_INT 0
109967: PPUSH
109968: PPUSH
109969: PPUSH
109970: PPUSH
109971: PPUSH
109972: PPUSH
109973: PPUSH
109974: PPUSH
// if not units then
109975: LD_VAR 0 1
109979: NOT
109980: IFFALSE 109984
// exit ;
109982: GO 110508
// result := UnitFilter ( units , [ f_ok ] ) ;
109984: LD_ADDR_VAR 0 3
109988: PUSH
109989: LD_VAR 0 1
109993: PPUSH
109994: LD_INT 50
109996: PUSH
109997: EMPTY
109998: LIST
109999: PPUSH
110000: CALL_OW 72
110004: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
110005: LD_ADDR_VAR 0 8
110009: PUSH
110010: LD_VAR 0 1
110014: PUSH
110015: LD_INT 1
110017: ARRAY
110018: PPUSH
110019: CALL_OW 255
110023: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
110024: LD_ADDR_VAR 0 10
110028: PUSH
110029: LD_INT 29
110031: PUSH
110032: LD_INT 91
110034: PUSH
110035: LD_INT 49
110037: PUSH
110038: EMPTY
110039: LIST
110040: LIST
110041: LIST
110042: ST_TO_ADDR
// if not result then
110043: LD_VAR 0 3
110047: NOT
110048: IFFALSE 110052
// exit ;
110050: GO 110508
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
110052: LD_ADDR_VAR 0 5
110056: PUSH
110057: LD_INT 81
110059: PUSH
110060: LD_VAR 0 8
110064: PUSH
110065: EMPTY
110066: LIST
110067: LIST
110068: PPUSH
110069: CALL_OW 69
110073: ST_TO_ADDR
// for i in result do
110074: LD_ADDR_VAR 0 4
110078: PUSH
110079: LD_VAR 0 3
110083: PUSH
110084: FOR_IN
110085: IFFALSE 110506
// begin tag := GetTag ( i ) + 1 ;
110087: LD_ADDR_VAR 0 9
110091: PUSH
110092: LD_VAR 0 4
110096: PPUSH
110097: CALL_OW 110
110101: PUSH
110102: LD_INT 1
110104: PLUS
110105: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
110106: LD_ADDR_VAR 0 7
110110: PUSH
110111: LD_VAR 0 4
110115: PPUSH
110116: CALL_OW 250
110120: PPUSH
110121: LD_VAR 0 4
110125: PPUSH
110126: CALL_OW 251
110130: PPUSH
110131: LD_INT 6
110133: PPUSH
110134: CALL 109707 0 3
110138: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
110139: LD_VAR 0 4
110143: PPUSH
110144: CALL_OW 247
110148: PUSH
110149: LD_INT 2
110151: EQUAL
110152: PUSH
110153: LD_VAR 0 7
110157: AND
110158: PUSH
110159: LD_VAR 0 4
110163: PPUSH
110164: CALL_OW 264
110168: PUSH
110169: LD_VAR 0 10
110173: IN
110174: NOT
110175: AND
110176: IFFALSE 110215
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
110178: LD_VAR 0 4
110182: PPUSH
110183: LD_VAR 0 7
110187: PUSH
110188: LD_INT 1
110190: ARRAY
110191: PUSH
110192: LD_INT 1
110194: ARRAY
110195: PPUSH
110196: LD_VAR 0 7
110200: PUSH
110201: LD_INT 1
110203: ARRAY
110204: PUSH
110205: LD_INT 2
110207: ARRAY
110208: PPUSH
110209: CALL_OW 116
110213: GO 110504
// if path > tag then
110215: LD_VAR 0 2
110219: PUSH
110220: LD_VAR 0 9
110224: GREATER
110225: IFFALSE 110433
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
110227: LD_ADDR_VAR 0 6
110231: PUSH
110232: LD_VAR 0 5
110236: PPUSH
110237: LD_INT 91
110239: PUSH
110240: LD_VAR 0 4
110244: PUSH
110245: LD_INT 8
110247: PUSH
110248: EMPTY
110249: LIST
110250: LIST
110251: LIST
110252: PPUSH
110253: CALL_OW 72
110257: ST_TO_ADDR
// if nearEnemy then
110258: LD_VAR 0 6
110262: IFFALSE 110331
// begin if GetWeapon ( i ) = ru_time_lapser then
110264: LD_VAR 0 4
110268: PPUSH
110269: CALL_OW 264
110273: PUSH
110274: LD_INT 49
110276: EQUAL
110277: IFFALSE 110305
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
110279: LD_VAR 0 4
110283: PPUSH
110284: LD_VAR 0 6
110288: PPUSH
110289: LD_VAR 0 4
110293: PPUSH
110294: CALL_OW 74
110298: PPUSH
110299: CALL_OW 112
110303: GO 110329
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
110305: LD_VAR 0 4
110309: PPUSH
110310: LD_VAR 0 6
110314: PPUSH
110315: LD_VAR 0 4
110319: PPUSH
110320: CALL_OW 74
110324: PPUSH
110325: CALL 111579 0 2
// end else
110329: GO 110431
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
110331: LD_VAR 0 4
110335: PPUSH
110336: LD_VAR 0 2
110340: PUSH
110341: LD_VAR 0 9
110345: ARRAY
110346: PUSH
110347: LD_INT 1
110349: ARRAY
110350: PPUSH
110351: LD_VAR 0 2
110355: PUSH
110356: LD_VAR 0 9
110360: ARRAY
110361: PUSH
110362: LD_INT 2
110364: ARRAY
110365: PPUSH
110366: CALL_OW 297
110370: PUSH
110371: LD_INT 6
110373: GREATER
110374: IFFALSE 110417
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
110376: LD_VAR 0 4
110380: PPUSH
110381: LD_VAR 0 2
110385: PUSH
110386: LD_VAR 0 9
110390: ARRAY
110391: PUSH
110392: LD_INT 1
110394: ARRAY
110395: PPUSH
110396: LD_VAR 0 2
110400: PUSH
110401: LD_VAR 0 9
110405: ARRAY
110406: PUSH
110407: LD_INT 2
110409: ARRAY
110410: PPUSH
110411: CALL_OW 114
110415: GO 110431
// SetTag ( i , tag ) ;
110417: LD_VAR 0 4
110421: PPUSH
110422: LD_VAR 0 9
110426: PPUSH
110427: CALL_OW 109
// end else
110431: GO 110504
// if enemy then
110433: LD_VAR 0 5
110437: IFFALSE 110504
// begin if GetWeapon ( i ) = ru_time_lapser then
110439: LD_VAR 0 4
110443: PPUSH
110444: CALL_OW 264
110448: PUSH
110449: LD_INT 49
110451: EQUAL
110452: IFFALSE 110480
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
110454: LD_VAR 0 4
110458: PPUSH
110459: LD_VAR 0 5
110463: PPUSH
110464: LD_VAR 0 4
110468: PPUSH
110469: CALL_OW 74
110473: PPUSH
110474: CALL_OW 112
110478: GO 110504
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
110480: LD_VAR 0 4
110484: PPUSH
110485: LD_VAR 0 5
110489: PPUSH
110490: LD_VAR 0 4
110494: PPUSH
110495: CALL_OW 74
110499: PPUSH
110500: CALL 111579 0 2
// end ; end ;
110504: GO 110084
110506: POP
110507: POP
// end ;
110508: LD_VAR 0 3
110512: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
110513: LD_INT 0
110515: PPUSH
110516: PPUSH
110517: PPUSH
// if not unit or IsInUnit ( unit ) then
110518: LD_VAR 0 1
110522: NOT
110523: PUSH
110524: LD_VAR 0 1
110528: PPUSH
110529: CALL_OW 310
110533: OR
110534: IFFALSE 110538
// exit ;
110536: GO 110629
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
110538: LD_ADDR_VAR 0 4
110542: PUSH
110543: LD_VAR 0 1
110547: PPUSH
110548: CALL_OW 250
110552: PPUSH
110553: LD_VAR 0 2
110557: PPUSH
110558: LD_INT 1
110560: PPUSH
110561: CALL_OW 272
110565: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
110566: LD_ADDR_VAR 0 5
110570: PUSH
110571: LD_VAR 0 1
110575: PPUSH
110576: CALL_OW 251
110580: PPUSH
110581: LD_VAR 0 2
110585: PPUSH
110586: LD_INT 1
110588: PPUSH
110589: CALL_OW 273
110593: ST_TO_ADDR
// if ValidHex ( x , y ) then
110594: LD_VAR 0 4
110598: PPUSH
110599: LD_VAR 0 5
110603: PPUSH
110604: CALL_OW 488
110608: IFFALSE 110629
// ComTurnXY ( unit , x , y ) ;
110610: LD_VAR 0 1
110614: PPUSH
110615: LD_VAR 0 4
110619: PPUSH
110620: LD_VAR 0 5
110624: PPUSH
110625: CALL_OW 118
// end ;
110629: LD_VAR 0 3
110633: RET
// export function SeeUnits ( side , units ) ; var i ; begin
110634: LD_INT 0
110636: PPUSH
110637: PPUSH
// result := false ;
110638: LD_ADDR_VAR 0 3
110642: PUSH
110643: LD_INT 0
110645: ST_TO_ADDR
// if not units then
110646: LD_VAR 0 2
110650: NOT
110651: IFFALSE 110655
// exit ;
110653: GO 110700
// for i in units do
110655: LD_ADDR_VAR 0 4
110659: PUSH
110660: LD_VAR 0 2
110664: PUSH
110665: FOR_IN
110666: IFFALSE 110698
// if See ( side , i ) then
110668: LD_VAR 0 1
110672: PPUSH
110673: LD_VAR 0 4
110677: PPUSH
110678: CALL_OW 292
110682: IFFALSE 110696
// begin result := true ;
110684: LD_ADDR_VAR 0 3
110688: PUSH
110689: LD_INT 1
110691: ST_TO_ADDR
// exit ;
110692: POP
110693: POP
110694: GO 110700
// end ;
110696: GO 110665
110698: POP
110699: POP
// end ;
110700: LD_VAR 0 3
110704: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
110705: LD_INT 0
110707: PPUSH
110708: PPUSH
110709: PPUSH
110710: PPUSH
// if not unit or not points then
110711: LD_VAR 0 1
110715: NOT
110716: PUSH
110717: LD_VAR 0 2
110721: NOT
110722: OR
110723: IFFALSE 110727
// exit ;
110725: GO 110817
// dist := 99999 ;
110727: LD_ADDR_VAR 0 5
110731: PUSH
110732: LD_INT 99999
110734: ST_TO_ADDR
// for i in points do
110735: LD_ADDR_VAR 0 4
110739: PUSH
110740: LD_VAR 0 2
110744: PUSH
110745: FOR_IN
110746: IFFALSE 110815
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
110748: LD_ADDR_VAR 0 6
110752: PUSH
110753: LD_VAR 0 1
110757: PPUSH
110758: LD_VAR 0 4
110762: PUSH
110763: LD_INT 1
110765: ARRAY
110766: PPUSH
110767: LD_VAR 0 4
110771: PUSH
110772: LD_INT 2
110774: ARRAY
110775: PPUSH
110776: CALL_OW 297
110780: ST_TO_ADDR
// if tmpDist < dist then
110781: LD_VAR 0 6
110785: PUSH
110786: LD_VAR 0 5
110790: LESS
110791: IFFALSE 110813
// begin result := i ;
110793: LD_ADDR_VAR 0 3
110797: PUSH
110798: LD_VAR 0 4
110802: ST_TO_ADDR
// dist := tmpDist ;
110803: LD_ADDR_VAR 0 5
110807: PUSH
110808: LD_VAR 0 6
110812: ST_TO_ADDR
// end ; end ;
110813: GO 110745
110815: POP
110816: POP
// end ;
110817: LD_VAR 0 3
110821: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
110822: LD_INT 0
110824: PPUSH
// uc_side := side ;
110825: LD_ADDR_OWVAR 20
110829: PUSH
110830: LD_VAR 0 1
110834: ST_TO_ADDR
// uc_nation := 3 ;
110835: LD_ADDR_OWVAR 21
110839: PUSH
110840: LD_INT 3
110842: ST_TO_ADDR
// vc_chassis := 25 ;
110843: LD_ADDR_OWVAR 37
110847: PUSH
110848: LD_INT 25
110850: ST_TO_ADDR
// vc_engine := engine_siberite ;
110851: LD_ADDR_OWVAR 39
110855: PUSH
110856: LD_INT 3
110858: ST_TO_ADDR
// vc_control := control_computer ;
110859: LD_ADDR_OWVAR 38
110863: PUSH
110864: LD_INT 3
110866: ST_TO_ADDR
// vc_weapon := 59 ;
110867: LD_ADDR_OWVAR 40
110871: PUSH
110872: LD_INT 59
110874: ST_TO_ADDR
// result := CreateVehicle ;
110875: LD_ADDR_VAR 0 5
110879: PUSH
110880: CALL_OW 45
110884: ST_TO_ADDR
// SetDir ( result , d ) ;
110885: LD_VAR 0 5
110889: PPUSH
110890: LD_VAR 0 4
110894: PPUSH
110895: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
110899: LD_VAR 0 5
110903: PPUSH
110904: LD_VAR 0 2
110908: PPUSH
110909: LD_VAR 0 3
110913: PPUSH
110914: LD_INT 0
110916: PPUSH
110917: CALL_OW 48
// end ;
110921: LD_VAR 0 5
110925: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
110926: LD_INT 0
110928: PPUSH
110929: PPUSH
110930: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
110931: LD_ADDR_VAR 0 2
110935: PUSH
110936: LD_INT 0
110938: PUSH
110939: LD_INT 0
110941: PUSH
110942: LD_INT 0
110944: PUSH
110945: LD_INT 0
110947: PUSH
110948: EMPTY
110949: LIST
110950: LIST
110951: LIST
110952: LIST
110953: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
110954: LD_VAR 0 1
110958: NOT
110959: PUSH
110960: LD_VAR 0 1
110964: PPUSH
110965: CALL_OW 264
110969: PUSH
110970: LD_INT 12
110972: PUSH
110973: LD_INT 51
110975: PUSH
110976: LD_INT 32
110978: PUSH
110979: LD_INT 89
110981: PUSH
110982: EMPTY
110983: LIST
110984: LIST
110985: LIST
110986: LIST
110987: IN
110988: NOT
110989: OR
110990: IFFALSE 110994
// exit ;
110992: GO 111092
// for i := 1 to 3 do
110994: LD_ADDR_VAR 0 3
110998: PUSH
110999: DOUBLE
111000: LD_INT 1
111002: DEC
111003: ST_TO_ADDR
111004: LD_INT 3
111006: PUSH
111007: FOR_TO
111008: IFFALSE 111090
// begin tmp := GetCargo ( cargo , i ) ;
111010: LD_ADDR_VAR 0 4
111014: PUSH
111015: LD_VAR 0 1
111019: PPUSH
111020: LD_VAR 0 3
111024: PPUSH
111025: CALL_OW 289
111029: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
111030: LD_ADDR_VAR 0 2
111034: PUSH
111035: LD_VAR 0 2
111039: PPUSH
111040: LD_VAR 0 3
111044: PPUSH
111045: LD_VAR 0 4
111049: PPUSH
111050: CALL_OW 1
111054: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
111055: LD_ADDR_VAR 0 2
111059: PUSH
111060: LD_VAR 0 2
111064: PPUSH
111065: LD_INT 4
111067: PPUSH
111068: LD_VAR 0 2
111072: PUSH
111073: LD_INT 4
111075: ARRAY
111076: PUSH
111077: LD_VAR 0 4
111081: PLUS
111082: PPUSH
111083: CALL_OW 1
111087: ST_TO_ADDR
// end ;
111088: GO 111007
111090: POP
111091: POP
// end ;
111092: LD_VAR 0 2
111096: RET
// export function Length ( array ) ; begin
111097: LD_INT 0
111099: PPUSH
// result := array + 0 ;
111100: LD_ADDR_VAR 0 2
111104: PUSH
111105: LD_VAR 0 1
111109: PUSH
111110: LD_INT 0
111112: PLUS
111113: ST_TO_ADDR
// end ;
111114: LD_VAR 0 2
111118: RET
// export function PrepareArray ( array ) ; begin
111119: LD_INT 0
111121: PPUSH
// result := array diff 0 ;
111122: LD_ADDR_VAR 0 2
111126: PUSH
111127: LD_VAR 0 1
111131: PUSH
111132: LD_INT 0
111134: DIFF
111135: ST_TO_ADDR
// if not result [ 1 ] then
111136: LD_VAR 0 2
111140: PUSH
111141: LD_INT 1
111143: ARRAY
111144: NOT
111145: IFFALSE 111165
// result := Delete ( result , 1 ) ;
111147: LD_ADDR_VAR 0 2
111151: PUSH
111152: LD_VAR 0 2
111156: PPUSH
111157: LD_INT 1
111159: PPUSH
111160: CALL_OW 3
111164: ST_TO_ADDR
// end ;
111165: LD_VAR 0 2
111169: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
111170: LD_INT 0
111172: PPUSH
111173: PPUSH
111174: PPUSH
111175: PPUSH
// sibRocketRange := 25 ;
111176: LD_ADDR_VAR 0 6
111180: PUSH
111181: LD_INT 25
111183: ST_TO_ADDR
// result := false ;
111184: LD_ADDR_VAR 0 4
111188: PUSH
111189: LD_INT 0
111191: ST_TO_ADDR
// for i := 0 to 5 do
111192: LD_ADDR_VAR 0 5
111196: PUSH
111197: DOUBLE
111198: LD_INT 0
111200: DEC
111201: ST_TO_ADDR
111202: LD_INT 5
111204: PUSH
111205: FOR_TO
111206: IFFALSE 111273
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
111208: LD_VAR 0 1
111212: PPUSH
111213: LD_VAR 0 5
111217: PPUSH
111218: LD_VAR 0 6
111222: PPUSH
111223: CALL_OW 272
111227: PPUSH
111228: LD_VAR 0 2
111232: PPUSH
111233: LD_VAR 0 5
111237: PPUSH
111238: LD_VAR 0 6
111242: PPUSH
111243: CALL_OW 273
111247: PPUSH
111248: LD_VAR 0 3
111252: PPUSH
111253: CALL_OW 309
111257: IFFALSE 111271
// begin result := true ;
111259: LD_ADDR_VAR 0 4
111263: PUSH
111264: LD_INT 1
111266: ST_TO_ADDR
// exit ;
111267: POP
111268: POP
111269: GO 111275
// end ;
111271: GO 111205
111273: POP
111274: POP
// end ;
111275: LD_VAR 0 4
111279: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
111280: LD_INT 0
111282: PPUSH
111283: PPUSH
111284: PPUSH
// if btype = b_depot then
111285: LD_VAR 0 2
111289: PUSH
111290: LD_INT 0
111292: EQUAL
111293: IFFALSE 111305
// begin result := true ;
111295: LD_ADDR_VAR 0 3
111299: PUSH
111300: LD_INT 1
111302: ST_TO_ADDR
// exit ;
111303: GO 111421
// end ; pom := GetBase ( depot ) ;
111305: LD_ADDR_VAR 0 4
111309: PUSH
111310: LD_VAR 0 1
111314: PPUSH
111315: CALL_OW 274
111319: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
111320: LD_ADDR_VAR 0 5
111324: PUSH
111325: LD_VAR 0 2
111329: PPUSH
111330: LD_VAR 0 1
111334: PPUSH
111335: CALL_OW 248
111339: PPUSH
111340: CALL_OW 450
111344: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
111345: LD_ADDR_VAR 0 3
111349: PUSH
111350: LD_VAR 0 4
111354: PPUSH
111355: LD_INT 1
111357: PPUSH
111358: CALL_OW 275
111362: PUSH
111363: LD_VAR 0 5
111367: PUSH
111368: LD_INT 1
111370: ARRAY
111371: GREATEREQUAL
111372: PUSH
111373: LD_VAR 0 4
111377: PPUSH
111378: LD_INT 2
111380: PPUSH
111381: CALL_OW 275
111385: PUSH
111386: LD_VAR 0 5
111390: PUSH
111391: LD_INT 2
111393: ARRAY
111394: GREATEREQUAL
111395: AND
111396: PUSH
111397: LD_VAR 0 4
111401: PPUSH
111402: LD_INT 3
111404: PPUSH
111405: CALL_OW 275
111409: PUSH
111410: LD_VAR 0 5
111414: PUSH
111415: LD_INT 3
111417: ARRAY
111418: GREATEREQUAL
111419: AND
111420: ST_TO_ADDR
// end ;
111421: LD_VAR 0 3
111425: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
111426: LD_INT 0
111428: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
111429: LD_VAR 0 1
111433: PPUSH
111434: LD_VAR 0 2
111438: PPUSH
111439: LD_INT 0
111441: PPUSH
111442: LD_INT 0
111444: PPUSH
111445: LD_INT 1
111447: PPUSH
111448: LD_INT 0
111450: PPUSH
111451: CALL_OW 587
// end ;
111455: LD_VAR 0 3
111459: RET
// export function CenterOnNow ( unit ) ; begin
111460: LD_INT 0
111462: PPUSH
// result := IsInUnit ( unit ) ;
111463: LD_ADDR_VAR 0 2
111467: PUSH
111468: LD_VAR 0 1
111472: PPUSH
111473: CALL_OW 310
111477: ST_TO_ADDR
// if not result then
111478: LD_VAR 0 2
111482: NOT
111483: IFFALSE 111495
// result := unit ;
111485: LD_ADDR_VAR 0 2
111489: PUSH
111490: LD_VAR 0 1
111494: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
111495: LD_VAR 0 1
111499: PPUSH
111500: CALL_OW 87
// end ;
111504: LD_VAR 0 2
111508: RET
// export function ComMoveHex ( unit , hex ) ; begin
111509: LD_INT 0
111511: PPUSH
// if not hex then
111512: LD_VAR 0 2
111516: NOT
111517: IFFALSE 111521
// exit ;
111519: GO 111574
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
111521: LD_VAR 0 2
111525: PUSH
111526: LD_INT 1
111528: ARRAY
111529: PPUSH
111530: LD_VAR 0 2
111534: PUSH
111535: LD_INT 2
111537: ARRAY
111538: PPUSH
111539: CALL_OW 428
111543: IFFALSE 111547
// exit ;
111545: GO 111574
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
111547: LD_VAR 0 1
111551: PPUSH
111552: LD_VAR 0 2
111556: PUSH
111557: LD_INT 1
111559: ARRAY
111560: PPUSH
111561: LD_VAR 0 2
111565: PUSH
111566: LD_INT 2
111568: ARRAY
111569: PPUSH
111570: CALL_OW 111
// end ;
111574: LD_VAR 0 3
111578: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
111579: LD_INT 0
111581: PPUSH
111582: PPUSH
111583: PPUSH
// if not unit or not enemy then
111584: LD_VAR 0 1
111588: NOT
111589: PUSH
111590: LD_VAR 0 2
111594: NOT
111595: OR
111596: IFFALSE 111600
// exit ;
111598: GO 111724
// x := GetX ( enemy ) ;
111600: LD_ADDR_VAR 0 4
111604: PUSH
111605: LD_VAR 0 2
111609: PPUSH
111610: CALL_OW 250
111614: ST_TO_ADDR
// y := GetY ( enemy ) ;
111615: LD_ADDR_VAR 0 5
111619: PUSH
111620: LD_VAR 0 2
111624: PPUSH
111625: CALL_OW 251
111629: ST_TO_ADDR
// if ValidHex ( x , y ) then
111630: LD_VAR 0 4
111634: PPUSH
111635: LD_VAR 0 5
111639: PPUSH
111640: CALL_OW 488
111644: IFFALSE 111724
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
111646: LD_VAR 0 2
111650: PPUSH
111651: CALL_OW 247
111655: PUSH
111656: LD_INT 3
111658: PUSH
111659: LD_INT 2
111661: PUSH
111662: EMPTY
111663: LIST
111664: LIST
111665: IN
111666: PUSH
111667: LD_VAR 0 1
111671: PPUSH
111672: CALL_OW 255
111676: PPUSH
111677: LD_VAR 0 2
111681: PPUSH
111682: CALL_OW 292
111686: OR
111687: IFFALSE 111705
// ComAttackUnit ( unit , enemy ) else
111689: LD_VAR 0 1
111693: PPUSH
111694: LD_VAR 0 2
111698: PPUSH
111699: CALL_OW 115
111703: GO 111724
// ComAgressiveMove ( unit , x , y ) ;
111705: LD_VAR 0 1
111709: PPUSH
111710: LD_VAR 0 4
111714: PPUSH
111715: LD_VAR 0 5
111719: PPUSH
111720: CALL_OW 114
// end ;
111724: LD_VAR 0 3
111728: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
111729: LD_INT 0
111731: PPUSH
111732: PPUSH
111733: PPUSH
// list := AreaToList ( area , 0 ) ;
111734: LD_ADDR_VAR 0 5
111738: PUSH
111739: LD_VAR 0 1
111743: PPUSH
111744: LD_INT 0
111746: PPUSH
111747: CALL_OW 517
111751: ST_TO_ADDR
// if not list then
111752: LD_VAR 0 5
111756: NOT
111757: IFFALSE 111761
// exit ;
111759: GO 111891
// if all then
111761: LD_VAR 0 2
111765: IFFALSE 111853
// begin for i := 1 to list [ 1 ] do
111767: LD_ADDR_VAR 0 4
111771: PUSH
111772: DOUBLE
111773: LD_INT 1
111775: DEC
111776: ST_TO_ADDR
111777: LD_VAR 0 5
111781: PUSH
111782: LD_INT 1
111784: ARRAY
111785: PUSH
111786: FOR_TO
111787: IFFALSE 111849
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
111789: LD_ADDR_VAR 0 3
111793: PUSH
111794: LD_VAR 0 3
111798: PPUSH
111799: LD_VAR 0 3
111803: PUSH
111804: LD_INT 1
111806: PLUS
111807: PPUSH
111808: LD_VAR 0 5
111812: PUSH
111813: LD_INT 1
111815: ARRAY
111816: PUSH
111817: LD_VAR 0 4
111821: ARRAY
111822: PUSH
111823: LD_VAR 0 5
111827: PUSH
111828: LD_INT 2
111830: ARRAY
111831: PUSH
111832: LD_VAR 0 4
111836: ARRAY
111837: PUSH
111838: EMPTY
111839: LIST
111840: LIST
111841: PPUSH
111842: CALL_OW 1
111846: ST_TO_ADDR
111847: GO 111786
111849: POP
111850: POP
// exit ;
111851: GO 111891
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
111853: LD_ADDR_VAR 0 3
111857: PUSH
111858: LD_VAR 0 5
111862: PUSH
111863: LD_INT 1
111865: ARRAY
111866: PUSH
111867: LD_INT 1
111869: ARRAY
111870: PUSH
111871: LD_VAR 0 5
111875: PUSH
111876: LD_INT 2
111878: ARRAY
111879: PUSH
111880: LD_INT 1
111882: ARRAY
111883: PUSH
111884: EMPTY
111885: LIST
111886: LIST
111887: PUSH
111888: EMPTY
111889: LIST
111890: ST_TO_ADDR
// end ;
111891: LD_VAR 0 3
111895: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
111896: LD_INT 0
111898: PPUSH
111899: PPUSH
// list := AreaToList ( area , 0 ) ;
111900: LD_ADDR_VAR 0 4
111904: PUSH
111905: LD_VAR 0 1
111909: PPUSH
111910: LD_INT 0
111912: PPUSH
111913: CALL_OW 517
111917: ST_TO_ADDR
// if not list then
111918: LD_VAR 0 4
111922: NOT
111923: IFFALSE 111927
// exit ;
111925: GO 111968
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
111927: LD_ADDR_VAR 0 3
111931: PUSH
111932: LD_VAR 0 4
111936: PUSH
111937: LD_INT 1
111939: ARRAY
111940: PUSH
111941: LD_INT 1
111943: ARRAY
111944: PUSH
111945: LD_VAR 0 4
111949: PUSH
111950: LD_INT 2
111952: ARRAY
111953: PUSH
111954: LD_INT 1
111956: ARRAY
111957: PUSH
111958: LD_VAR 0 2
111962: PUSH
111963: EMPTY
111964: LIST
111965: LIST
111966: LIST
111967: ST_TO_ADDR
// end ;
111968: LD_VAR 0 3
111972: RET
// export function First ( array ) ; begin
111973: LD_INT 0
111975: PPUSH
// if not array then
111976: LD_VAR 0 1
111980: NOT
111981: IFFALSE 111985
// exit ;
111983: GO 111999
// result := array [ 1 ] ;
111985: LD_ADDR_VAR 0 2
111989: PUSH
111990: LD_VAR 0 1
111994: PUSH
111995: LD_INT 1
111997: ARRAY
111998: ST_TO_ADDR
// end ;
111999: LD_VAR 0 2
112003: RET
// export function Last ( array ) ; begin
112004: LD_INT 0
112006: PPUSH
// if not array then
112007: LD_VAR 0 1
112011: NOT
112012: IFFALSE 112016
// exit ;
112014: GO 112032
// result := array [ array ] ;
112016: LD_ADDR_VAR 0 2
112020: PUSH
112021: LD_VAR 0 1
112025: PUSH
112026: LD_VAR 0 1
112030: ARRAY
112031: ST_TO_ADDR
// end ;
112032: LD_VAR 0 2
112036: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
112037: LD_INT 0
112039: PPUSH
112040: PPUSH
// result := [ ] ;
112041: LD_ADDR_VAR 0 5
112045: PUSH
112046: EMPTY
112047: ST_TO_ADDR
// if not array then
112048: LD_VAR 0 1
112052: NOT
112053: IFFALSE 112057
// exit ;
112055: GO 112169
// for i := 1 to array do
112057: LD_ADDR_VAR 0 6
112061: PUSH
112062: DOUBLE
112063: LD_INT 1
112065: DEC
112066: ST_TO_ADDR
112067: LD_VAR 0 1
112071: PUSH
112072: FOR_TO
112073: IFFALSE 112167
// if array [ i ] [ index ] = value then
112075: LD_VAR 0 1
112079: PUSH
112080: LD_VAR 0 6
112084: ARRAY
112085: PUSH
112086: LD_VAR 0 2
112090: ARRAY
112091: PUSH
112092: LD_VAR 0 3
112096: EQUAL
112097: IFFALSE 112165
// begin if indexColumn then
112099: LD_VAR 0 4
112103: IFFALSE 112139
// result := Join ( result , array [ i ] [ indexColumn ] ) else
112105: LD_ADDR_VAR 0 5
112109: PUSH
112110: LD_VAR 0 5
112114: PPUSH
112115: LD_VAR 0 1
112119: PUSH
112120: LD_VAR 0 6
112124: ARRAY
112125: PUSH
112126: LD_VAR 0 4
112130: ARRAY
112131: PPUSH
112132: CALL 107361 0 2
112136: ST_TO_ADDR
112137: GO 112165
// result := Join ( result , array [ i ] ) ;
112139: LD_ADDR_VAR 0 5
112143: PUSH
112144: LD_VAR 0 5
112148: PPUSH
112149: LD_VAR 0 1
112153: PUSH
112154: LD_VAR 0 6
112158: ARRAY
112159: PPUSH
112160: CALL 107361 0 2
112164: ST_TO_ADDR
// end ;
112165: GO 112072
112167: POP
112168: POP
// end ;
112169: LD_VAR 0 5
112173: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
112174: LD_INT 0
112176: PPUSH
// if not vehicles or not parkingPoint then
112177: LD_VAR 0 1
112181: NOT
112182: PUSH
112183: LD_VAR 0 2
112187: NOT
112188: OR
112189: IFFALSE 112193
// exit ;
112191: GO 112291
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
112193: LD_ADDR_VAR 0 1
112197: PUSH
112198: LD_VAR 0 1
112202: PPUSH
112203: LD_INT 50
112205: PUSH
112206: EMPTY
112207: LIST
112208: PUSH
112209: LD_INT 3
112211: PUSH
112212: LD_INT 92
112214: PUSH
112215: LD_VAR 0 2
112219: PUSH
112220: LD_INT 1
112222: ARRAY
112223: PUSH
112224: LD_VAR 0 2
112228: PUSH
112229: LD_INT 2
112231: ARRAY
112232: PUSH
112233: LD_INT 8
112235: PUSH
112236: EMPTY
112237: LIST
112238: LIST
112239: LIST
112240: LIST
112241: PUSH
112242: EMPTY
112243: LIST
112244: LIST
112245: PUSH
112246: EMPTY
112247: LIST
112248: LIST
112249: PPUSH
112250: CALL_OW 72
112254: ST_TO_ADDR
// if not vehicles then
112255: LD_VAR 0 1
112259: NOT
112260: IFFALSE 112264
// exit ;
112262: GO 112291
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
112264: LD_VAR 0 1
112268: PPUSH
112269: LD_VAR 0 2
112273: PUSH
112274: LD_INT 1
112276: ARRAY
112277: PPUSH
112278: LD_VAR 0 2
112282: PUSH
112283: LD_INT 2
112285: ARRAY
112286: PPUSH
112287: CALL_OW 111
// end ;
112291: LD_VAR 0 3
112295: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
112296: LD_INT 0
112298: PPUSH
112299: PPUSH
112300: PPUSH
// if not side or not area then
112301: LD_VAR 0 1
112305: NOT
112306: PUSH
112307: LD_VAR 0 2
112311: NOT
112312: OR
112313: IFFALSE 112317
// exit ;
112315: GO 112436
// tmp := AreaToList ( area , 0 ) ;
112317: LD_ADDR_VAR 0 5
112321: PUSH
112322: LD_VAR 0 2
112326: PPUSH
112327: LD_INT 0
112329: PPUSH
112330: CALL_OW 517
112334: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
112335: LD_ADDR_VAR 0 4
112339: PUSH
112340: DOUBLE
112341: LD_INT 1
112343: DEC
112344: ST_TO_ADDR
112345: LD_VAR 0 5
112349: PUSH
112350: LD_INT 1
112352: ARRAY
112353: PUSH
112354: FOR_TO
112355: IFFALSE 112434
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
112357: LD_VAR 0 5
112361: PUSH
112362: LD_INT 1
112364: ARRAY
112365: PUSH
112366: LD_VAR 0 4
112370: ARRAY
112371: PPUSH
112372: LD_VAR 0 5
112376: PUSH
112377: LD_INT 2
112379: ARRAY
112380: PUSH
112381: LD_VAR 0 4
112385: ARRAY
112386: PPUSH
112387: CALL_OW 351
112391: IFFALSE 112432
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
112393: LD_VAR 0 5
112397: PUSH
112398: LD_INT 1
112400: ARRAY
112401: PUSH
112402: LD_VAR 0 4
112406: ARRAY
112407: PPUSH
112408: LD_VAR 0 5
112412: PUSH
112413: LD_INT 2
112415: ARRAY
112416: PUSH
112417: LD_VAR 0 4
112421: ARRAY
112422: PPUSH
112423: LD_VAR 0 1
112427: PPUSH
112428: CALL_OW 244
// end ;
112432: GO 112354
112434: POP
112435: POP
// end ; end_of_file end_of_file
112436: LD_VAR 0 3
112440: RET
// export globalGameSaveCounter ; every 0 0$1 do
112441: GO 112443
112443: DISABLE
// begin enable ;
112444: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
112445: LD_STRING updateTimer(
112447: PUSH
112448: LD_OWVAR 1
112452: STR
112453: PUSH
112454: LD_STRING );
112456: STR
112457: PPUSH
112458: CALL_OW 559
// end ;
112462: END
// every 0 0$1 do
112463: GO 112465
112465: DISABLE
// begin globalGameSaveCounter := 0 ;
112466: LD_ADDR_EXP 147
112470: PUSH
112471: LD_INT 0
112473: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
112474: LD_STRING setGameSaveCounter(0)
112476: PPUSH
112477: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
112481: LD_STRING initStreamRollete();
112483: PPUSH
112484: CALL_OW 559
// InitStreamMode ;
112488: CALL 113831 0 0
// DefineStreamItems ( false ) ;
112492: LD_INT 0
112494: PPUSH
112495: CALL 114295 0 1
// end ;
112499: END
// export function SOS_MapStart ( ) ; begin
112500: LD_INT 0
112502: PPUSH
// if streamModeActive then
112503: LD_EXP 148
112507: IFFALSE 112516
// DefineStreamItems ( true ) ;
112509: LD_INT 1
112511: PPUSH
112512: CALL 114295 0 1
// UpdateLuaVariables ( ) ;
112516: CALL 112533 0 0
// UpdateFactoryWaypoints ( ) ;
112520: CALL 127164 0 0
// UpdateWarehouseGatheringPoints ( ) ;
112524: CALL 127421 0 0
// end ;
112528: LD_VAR 0 1
112532: RET
// function UpdateLuaVariables ( ) ; begin
112533: LD_INT 0
112535: PPUSH
// if globalGameSaveCounter then
112536: LD_EXP 147
112540: IFFALSE 112574
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
112542: LD_ADDR_EXP 147
112546: PUSH
112547: LD_EXP 147
112551: PPUSH
112552: CALL 108722 0 1
112556: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
112557: LD_STRING setGameSaveCounter(
112559: PUSH
112560: LD_EXP 147
112564: STR
112565: PUSH
112566: LD_STRING )
112568: STR
112569: PPUSH
112570: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
112574: LD_STRING setGameDifficulty(
112576: PUSH
112577: LD_OWVAR 67
112581: STR
112582: PUSH
112583: LD_STRING )
112585: STR
112586: PPUSH
112587: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
112591: LD_STRING displayDifficulty(
112593: PUSH
112594: LD_OWVAR 67
112598: STR
112599: PUSH
112600: LD_STRING )
112602: STR
112603: PPUSH
112604: CALL_OW 559
// end ;
112608: LD_VAR 0 1
112612: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
112613: LD_INT 0
112615: PPUSH
// if p2 = stream_mode then
112616: LD_VAR 0 2
112620: PUSH
112621: LD_INT 100
112623: EQUAL
112624: IFFALSE 113627
// begin if not StreamModeActive then
112626: LD_EXP 148
112630: NOT
112631: IFFALSE 112641
// StreamModeActive := true ;
112633: LD_ADDR_EXP 148
112637: PUSH
112638: LD_INT 1
112640: ST_TO_ADDR
// if p3 = 0 then
112641: LD_VAR 0 3
112645: PUSH
112646: LD_INT 0
112648: EQUAL
112649: IFFALSE 112655
// InitStreamMode ;
112651: CALL 113831 0 0
// if p3 = 1 then
112655: LD_VAR 0 3
112659: PUSH
112660: LD_INT 1
112662: EQUAL
112663: IFFALSE 112673
// sRocket := true ;
112665: LD_ADDR_EXP 153
112669: PUSH
112670: LD_INT 1
112672: ST_TO_ADDR
// if p3 = 2 then
112673: LD_VAR 0 3
112677: PUSH
112678: LD_INT 2
112680: EQUAL
112681: IFFALSE 112691
// sSpeed := true ;
112683: LD_ADDR_EXP 152
112687: PUSH
112688: LD_INT 1
112690: ST_TO_ADDR
// if p3 = 3 then
112691: LD_VAR 0 3
112695: PUSH
112696: LD_INT 3
112698: EQUAL
112699: IFFALSE 112709
// sEngine := true ;
112701: LD_ADDR_EXP 154
112705: PUSH
112706: LD_INT 1
112708: ST_TO_ADDR
// if p3 = 4 then
112709: LD_VAR 0 3
112713: PUSH
112714: LD_INT 4
112716: EQUAL
112717: IFFALSE 112727
// sSpec := true ;
112719: LD_ADDR_EXP 151
112723: PUSH
112724: LD_INT 1
112726: ST_TO_ADDR
// if p3 = 5 then
112727: LD_VAR 0 3
112731: PUSH
112732: LD_INT 5
112734: EQUAL
112735: IFFALSE 112745
// sLevel := true ;
112737: LD_ADDR_EXP 155
112741: PUSH
112742: LD_INT 1
112744: ST_TO_ADDR
// if p3 = 6 then
112745: LD_VAR 0 3
112749: PUSH
112750: LD_INT 6
112752: EQUAL
112753: IFFALSE 112763
// sArmoury := true ;
112755: LD_ADDR_EXP 156
112759: PUSH
112760: LD_INT 1
112762: ST_TO_ADDR
// if p3 = 7 then
112763: LD_VAR 0 3
112767: PUSH
112768: LD_INT 7
112770: EQUAL
112771: IFFALSE 112781
// sRadar := true ;
112773: LD_ADDR_EXP 157
112777: PUSH
112778: LD_INT 1
112780: ST_TO_ADDR
// if p3 = 8 then
112781: LD_VAR 0 3
112785: PUSH
112786: LD_INT 8
112788: EQUAL
112789: IFFALSE 112799
// sBunker := true ;
112791: LD_ADDR_EXP 158
112795: PUSH
112796: LD_INT 1
112798: ST_TO_ADDR
// if p3 = 9 then
112799: LD_VAR 0 3
112803: PUSH
112804: LD_INT 9
112806: EQUAL
112807: IFFALSE 112817
// sHack := true ;
112809: LD_ADDR_EXP 159
112813: PUSH
112814: LD_INT 1
112816: ST_TO_ADDR
// if p3 = 10 then
112817: LD_VAR 0 3
112821: PUSH
112822: LD_INT 10
112824: EQUAL
112825: IFFALSE 112835
// sFire := true ;
112827: LD_ADDR_EXP 160
112831: PUSH
112832: LD_INT 1
112834: ST_TO_ADDR
// if p3 = 11 then
112835: LD_VAR 0 3
112839: PUSH
112840: LD_INT 11
112842: EQUAL
112843: IFFALSE 112853
// sRefresh := true ;
112845: LD_ADDR_EXP 161
112849: PUSH
112850: LD_INT 1
112852: ST_TO_ADDR
// if p3 = 12 then
112853: LD_VAR 0 3
112857: PUSH
112858: LD_INT 12
112860: EQUAL
112861: IFFALSE 112871
// sExp := true ;
112863: LD_ADDR_EXP 162
112867: PUSH
112868: LD_INT 1
112870: ST_TO_ADDR
// if p3 = 13 then
112871: LD_VAR 0 3
112875: PUSH
112876: LD_INT 13
112878: EQUAL
112879: IFFALSE 112889
// sDepot := true ;
112881: LD_ADDR_EXP 163
112885: PUSH
112886: LD_INT 1
112888: ST_TO_ADDR
// if p3 = 14 then
112889: LD_VAR 0 3
112893: PUSH
112894: LD_INT 14
112896: EQUAL
112897: IFFALSE 112907
// sFlag := true ;
112899: LD_ADDR_EXP 164
112903: PUSH
112904: LD_INT 1
112906: ST_TO_ADDR
// if p3 = 15 then
112907: LD_VAR 0 3
112911: PUSH
112912: LD_INT 15
112914: EQUAL
112915: IFFALSE 112925
// sKamikadze := true ;
112917: LD_ADDR_EXP 172
112921: PUSH
112922: LD_INT 1
112924: ST_TO_ADDR
// if p3 = 16 then
112925: LD_VAR 0 3
112929: PUSH
112930: LD_INT 16
112932: EQUAL
112933: IFFALSE 112943
// sTroll := true ;
112935: LD_ADDR_EXP 173
112939: PUSH
112940: LD_INT 1
112942: ST_TO_ADDR
// if p3 = 17 then
112943: LD_VAR 0 3
112947: PUSH
112948: LD_INT 17
112950: EQUAL
112951: IFFALSE 112961
// sSlow := true ;
112953: LD_ADDR_EXP 174
112957: PUSH
112958: LD_INT 1
112960: ST_TO_ADDR
// if p3 = 18 then
112961: LD_VAR 0 3
112965: PUSH
112966: LD_INT 18
112968: EQUAL
112969: IFFALSE 112979
// sLack := true ;
112971: LD_ADDR_EXP 175
112975: PUSH
112976: LD_INT 1
112978: ST_TO_ADDR
// if p3 = 19 then
112979: LD_VAR 0 3
112983: PUSH
112984: LD_INT 19
112986: EQUAL
112987: IFFALSE 112997
// sTank := true ;
112989: LD_ADDR_EXP 177
112993: PUSH
112994: LD_INT 1
112996: ST_TO_ADDR
// if p3 = 20 then
112997: LD_VAR 0 3
113001: PUSH
113002: LD_INT 20
113004: EQUAL
113005: IFFALSE 113015
// sRemote := true ;
113007: LD_ADDR_EXP 178
113011: PUSH
113012: LD_INT 1
113014: ST_TO_ADDR
// if p3 = 21 then
113015: LD_VAR 0 3
113019: PUSH
113020: LD_INT 21
113022: EQUAL
113023: IFFALSE 113033
// sPowell := true ;
113025: LD_ADDR_EXP 179
113029: PUSH
113030: LD_INT 1
113032: ST_TO_ADDR
// if p3 = 22 then
113033: LD_VAR 0 3
113037: PUSH
113038: LD_INT 22
113040: EQUAL
113041: IFFALSE 113051
// sTeleport := true ;
113043: LD_ADDR_EXP 182
113047: PUSH
113048: LD_INT 1
113050: ST_TO_ADDR
// if p3 = 23 then
113051: LD_VAR 0 3
113055: PUSH
113056: LD_INT 23
113058: EQUAL
113059: IFFALSE 113069
// sOilTower := true ;
113061: LD_ADDR_EXP 184
113065: PUSH
113066: LD_INT 1
113068: ST_TO_ADDR
// if p3 = 24 then
113069: LD_VAR 0 3
113073: PUSH
113074: LD_INT 24
113076: EQUAL
113077: IFFALSE 113087
// sShovel := true ;
113079: LD_ADDR_EXP 185
113083: PUSH
113084: LD_INT 1
113086: ST_TO_ADDR
// if p3 = 25 then
113087: LD_VAR 0 3
113091: PUSH
113092: LD_INT 25
113094: EQUAL
113095: IFFALSE 113105
// sSheik := true ;
113097: LD_ADDR_EXP 186
113101: PUSH
113102: LD_INT 1
113104: ST_TO_ADDR
// if p3 = 26 then
113105: LD_VAR 0 3
113109: PUSH
113110: LD_INT 26
113112: EQUAL
113113: IFFALSE 113123
// sEarthquake := true ;
113115: LD_ADDR_EXP 188
113119: PUSH
113120: LD_INT 1
113122: ST_TO_ADDR
// if p3 = 27 then
113123: LD_VAR 0 3
113127: PUSH
113128: LD_INT 27
113130: EQUAL
113131: IFFALSE 113141
// sAI := true ;
113133: LD_ADDR_EXP 189
113137: PUSH
113138: LD_INT 1
113140: ST_TO_ADDR
// if p3 = 28 then
113141: LD_VAR 0 3
113145: PUSH
113146: LD_INT 28
113148: EQUAL
113149: IFFALSE 113159
// sCargo := true ;
113151: LD_ADDR_EXP 192
113155: PUSH
113156: LD_INT 1
113158: ST_TO_ADDR
// if p3 = 29 then
113159: LD_VAR 0 3
113163: PUSH
113164: LD_INT 29
113166: EQUAL
113167: IFFALSE 113177
// sDLaser := true ;
113169: LD_ADDR_EXP 193
113173: PUSH
113174: LD_INT 1
113176: ST_TO_ADDR
// if p3 = 30 then
113177: LD_VAR 0 3
113181: PUSH
113182: LD_INT 30
113184: EQUAL
113185: IFFALSE 113195
// sExchange := true ;
113187: LD_ADDR_EXP 194
113191: PUSH
113192: LD_INT 1
113194: ST_TO_ADDR
// if p3 = 31 then
113195: LD_VAR 0 3
113199: PUSH
113200: LD_INT 31
113202: EQUAL
113203: IFFALSE 113213
// sFac := true ;
113205: LD_ADDR_EXP 195
113209: PUSH
113210: LD_INT 1
113212: ST_TO_ADDR
// if p3 = 32 then
113213: LD_VAR 0 3
113217: PUSH
113218: LD_INT 32
113220: EQUAL
113221: IFFALSE 113231
// sPower := true ;
113223: LD_ADDR_EXP 196
113227: PUSH
113228: LD_INT 1
113230: ST_TO_ADDR
// if p3 = 33 then
113231: LD_VAR 0 3
113235: PUSH
113236: LD_INT 33
113238: EQUAL
113239: IFFALSE 113249
// sRandom := true ;
113241: LD_ADDR_EXP 197
113245: PUSH
113246: LD_INT 1
113248: ST_TO_ADDR
// if p3 = 34 then
113249: LD_VAR 0 3
113253: PUSH
113254: LD_INT 34
113256: EQUAL
113257: IFFALSE 113267
// sShield := true ;
113259: LD_ADDR_EXP 198
113263: PUSH
113264: LD_INT 1
113266: ST_TO_ADDR
// if p3 = 35 then
113267: LD_VAR 0 3
113271: PUSH
113272: LD_INT 35
113274: EQUAL
113275: IFFALSE 113285
// sTime := true ;
113277: LD_ADDR_EXP 199
113281: PUSH
113282: LD_INT 1
113284: ST_TO_ADDR
// if p3 = 36 then
113285: LD_VAR 0 3
113289: PUSH
113290: LD_INT 36
113292: EQUAL
113293: IFFALSE 113303
// sTools := true ;
113295: LD_ADDR_EXP 200
113299: PUSH
113300: LD_INT 1
113302: ST_TO_ADDR
// if p3 = 101 then
113303: LD_VAR 0 3
113307: PUSH
113308: LD_INT 101
113310: EQUAL
113311: IFFALSE 113321
// sSold := true ;
113313: LD_ADDR_EXP 165
113317: PUSH
113318: LD_INT 1
113320: ST_TO_ADDR
// if p3 = 102 then
113321: LD_VAR 0 3
113325: PUSH
113326: LD_INT 102
113328: EQUAL
113329: IFFALSE 113339
// sDiff := true ;
113331: LD_ADDR_EXP 166
113335: PUSH
113336: LD_INT 1
113338: ST_TO_ADDR
// if p3 = 103 then
113339: LD_VAR 0 3
113343: PUSH
113344: LD_INT 103
113346: EQUAL
113347: IFFALSE 113357
// sFog := true ;
113349: LD_ADDR_EXP 169
113353: PUSH
113354: LD_INT 1
113356: ST_TO_ADDR
// if p3 = 104 then
113357: LD_VAR 0 3
113361: PUSH
113362: LD_INT 104
113364: EQUAL
113365: IFFALSE 113375
// sReset := true ;
113367: LD_ADDR_EXP 170
113371: PUSH
113372: LD_INT 1
113374: ST_TO_ADDR
// if p3 = 105 then
113375: LD_VAR 0 3
113379: PUSH
113380: LD_INT 105
113382: EQUAL
113383: IFFALSE 113393
// sSun := true ;
113385: LD_ADDR_EXP 171
113389: PUSH
113390: LD_INT 1
113392: ST_TO_ADDR
// if p3 = 106 then
113393: LD_VAR 0 3
113397: PUSH
113398: LD_INT 106
113400: EQUAL
113401: IFFALSE 113411
// sTiger := true ;
113403: LD_ADDR_EXP 167
113407: PUSH
113408: LD_INT 1
113410: ST_TO_ADDR
// if p3 = 107 then
113411: LD_VAR 0 3
113415: PUSH
113416: LD_INT 107
113418: EQUAL
113419: IFFALSE 113429
// sBomb := true ;
113421: LD_ADDR_EXP 168
113425: PUSH
113426: LD_INT 1
113428: ST_TO_ADDR
// if p3 = 108 then
113429: LD_VAR 0 3
113433: PUSH
113434: LD_INT 108
113436: EQUAL
113437: IFFALSE 113447
// sWound := true ;
113439: LD_ADDR_EXP 176
113443: PUSH
113444: LD_INT 1
113446: ST_TO_ADDR
// if p3 = 109 then
113447: LD_VAR 0 3
113451: PUSH
113452: LD_INT 109
113454: EQUAL
113455: IFFALSE 113465
// sBetray := true ;
113457: LD_ADDR_EXP 180
113461: PUSH
113462: LD_INT 1
113464: ST_TO_ADDR
// if p3 = 110 then
113465: LD_VAR 0 3
113469: PUSH
113470: LD_INT 110
113472: EQUAL
113473: IFFALSE 113483
// sContamin := true ;
113475: LD_ADDR_EXP 181
113479: PUSH
113480: LD_INT 1
113482: ST_TO_ADDR
// if p3 = 111 then
113483: LD_VAR 0 3
113487: PUSH
113488: LD_INT 111
113490: EQUAL
113491: IFFALSE 113501
// sOil := true ;
113493: LD_ADDR_EXP 183
113497: PUSH
113498: LD_INT 1
113500: ST_TO_ADDR
// if p3 = 112 then
113501: LD_VAR 0 3
113505: PUSH
113506: LD_INT 112
113508: EQUAL
113509: IFFALSE 113519
// sStu := true ;
113511: LD_ADDR_EXP 187
113515: PUSH
113516: LD_INT 1
113518: ST_TO_ADDR
// if p3 = 113 then
113519: LD_VAR 0 3
113523: PUSH
113524: LD_INT 113
113526: EQUAL
113527: IFFALSE 113537
// sBazooka := true ;
113529: LD_ADDR_EXP 190
113533: PUSH
113534: LD_INT 1
113536: ST_TO_ADDR
// if p3 = 114 then
113537: LD_VAR 0 3
113541: PUSH
113542: LD_INT 114
113544: EQUAL
113545: IFFALSE 113555
// sMortar := true ;
113547: LD_ADDR_EXP 191
113551: PUSH
113552: LD_INT 1
113554: ST_TO_ADDR
// if p3 = 115 then
113555: LD_VAR 0 3
113559: PUSH
113560: LD_INT 115
113562: EQUAL
113563: IFFALSE 113573
// sRanger := true ;
113565: LD_ADDR_EXP 201
113569: PUSH
113570: LD_INT 1
113572: ST_TO_ADDR
// if p3 = 116 then
113573: LD_VAR 0 3
113577: PUSH
113578: LD_INT 116
113580: EQUAL
113581: IFFALSE 113591
// sComputer := true ;
113583: LD_ADDR_EXP 202
113587: PUSH
113588: LD_INT 1
113590: ST_TO_ADDR
// if p3 = 117 then
113591: LD_VAR 0 3
113595: PUSH
113596: LD_INT 117
113598: EQUAL
113599: IFFALSE 113609
// s30 := true ;
113601: LD_ADDR_EXP 203
113605: PUSH
113606: LD_INT 1
113608: ST_TO_ADDR
// if p3 = 118 then
113609: LD_VAR 0 3
113613: PUSH
113614: LD_INT 118
113616: EQUAL
113617: IFFALSE 113627
// s60 := true ;
113619: LD_ADDR_EXP 204
113623: PUSH
113624: LD_INT 1
113626: ST_TO_ADDR
// end ; if p2 = hack_mode then
113627: LD_VAR 0 2
113631: PUSH
113632: LD_INT 101
113634: EQUAL
113635: IFFALSE 113763
// begin case p3 of 1 :
113637: LD_VAR 0 3
113641: PUSH
113642: LD_INT 1
113644: DOUBLE
113645: EQUAL
113646: IFTRUE 113650
113648: GO 113657
113650: POP
// hHackUnlimitedResources ; 2 :
113651: CALL 125910 0 0
113655: GO 113763
113657: LD_INT 2
113659: DOUBLE
113660: EQUAL
113661: IFTRUE 113665
113663: GO 113672
113665: POP
// hHackSetLevel10 ; 3 :
113666: CALL 126043 0 0
113670: GO 113763
113672: LD_INT 3
113674: DOUBLE
113675: EQUAL
113676: IFTRUE 113680
113678: GO 113687
113680: POP
// hHackSetLevel10YourUnits ; 4 :
113681: CALL 126128 0 0
113685: GO 113763
113687: LD_INT 4
113689: DOUBLE
113690: EQUAL
113691: IFTRUE 113695
113693: GO 113702
113695: POP
// hHackInvincible ; 5 :
113696: CALL 126576 0 0
113700: GO 113763
113702: LD_INT 5
113704: DOUBLE
113705: EQUAL
113706: IFTRUE 113710
113708: GO 113717
113710: POP
// hHackInvisible ; 6 :
113711: CALL 126687 0 0
113715: GO 113763
113717: LD_INT 6
113719: DOUBLE
113720: EQUAL
113721: IFTRUE 113725
113723: GO 113732
113725: POP
// hHackChangeYourSide ; 7 :
113726: CALL 126744 0 0
113730: GO 113763
113732: LD_INT 7
113734: DOUBLE
113735: EQUAL
113736: IFTRUE 113740
113738: GO 113747
113740: POP
// hHackChangeUnitSide ; 8 :
113741: CALL 126786 0 0
113745: GO 113763
113747: LD_INT 8
113749: DOUBLE
113750: EQUAL
113751: IFTRUE 113755
113753: GO 113762
113755: POP
// hHackFog ; end ;
113756: CALL 126887 0 0
113760: GO 113763
113762: POP
// end ; if p2 = game_save_mode then
113763: LD_VAR 0 2
113767: PUSH
113768: LD_INT 102
113770: EQUAL
113771: IFFALSE 113826
// begin if p3 = 1 then
113773: LD_VAR 0 3
113777: PUSH
113778: LD_INT 1
113780: EQUAL
113781: IFFALSE 113793
// globalGameSaveCounter := p4 ;
113783: LD_ADDR_EXP 147
113787: PUSH
113788: LD_VAR 0 4
113792: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
113793: LD_VAR 0 3
113797: PUSH
113798: LD_INT 2
113800: EQUAL
113801: PUSH
113802: LD_EXP 147
113806: AND
113807: IFFALSE 113826
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
113809: LD_STRING setGameSaveCounter(
113811: PUSH
113812: LD_EXP 147
113816: STR
113817: PUSH
113818: LD_STRING )
113820: STR
113821: PPUSH
113822: CALL_OW 559
// end ; end ;
113826: LD_VAR 0 7
113830: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
113831: LD_INT 0
113833: PPUSH
// streamModeActive := false ;
113834: LD_ADDR_EXP 148
113838: PUSH
113839: LD_INT 0
113841: ST_TO_ADDR
// normalCounter := 36 ;
113842: LD_ADDR_EXP 149
113846: PUSH
113847: LD_INT 36
113849: ST_TO_ADDR
// hardcoreCounter := 18 ;
113850: LD_ADDR_EXP 150
113854: PUSH
113855: LD_INT 18
113857: ST_TO_ADDR
// sRocket := false ;
113858: LD_ADDR_EXP 153
113862: PUSH
113863: LD_INT 0
113865: ST_TO_ADDR
// sSpeed := false ;
113866: LD_ADDR_EXP 152
113870: PUSH
113871: LD_INT 0
113873: ST_TO_ADDR
// sEngine := false ;
113874: LD_ADDR_EXP 154
113878: PUSH
113879: LD_INT 0
113881: ST_TO_ADDR
// sSpec := false ;
113882: LD_ADDR_EXP 151
113886: PUSH
113887: LD_INT 0
113889: ST_TO_ADDR
// sLevel := false ;
113890: LD_ADDR_EXP 155
113894: PUSH
113895: LD_INT 0
113897: ST_TO_ADDR
// sArmoury := false ;
113898: LD_ADDR_EXP 156
113902: PUSH
113903: LD_INT 0
113905: ST_TO_ADDR
// sRadar := false ;
113906: LD_ADDR_EXP 157
113910: PUSH
113911: LD_INT 0
113913: ST_TO_ADDR
// sBunker := false ;
113914: LD_ADDR_EXP 158
113918: PUSH
113919: LD_INT 0
113921: ST_TO_ADDR
// sHack := false ;
113922: LD_ADDR_EXP 159
113926: PUSH
113927: LD_INT 0
113929: ST_TO_ADDR
// sFire := false ;
113930: LD_ADDR_EXP 160
113934: PUSH
113935: LD_INT 0
113937: ST_TO_ADDR
// sRefresh := false ;
113938: LD_ADDR_EXP 161
113942: PUSH
113943: LD_INT 0
113945: ST_TO_ADDR
// sExp := false ;
113946: LD_ADDR_EXP 162
113950: PUSH
113951: LD_INT 0
113953: ST_TO_ADDR
// sDepot := false ;
113954: LD_ADDR_EXP 163
113958: PUSH
113959: LD_INT 0
113961: ST_TO_ADDR
// sFlag := false ;
113962: LD_ADDR_EXP 164
113966: PUSH
113967: LD_INT 0
113969: ST_TO_ADDR
// sKamikadze := false ;
113970: LD_ADDR_EXP 172
113974: PUSH
113975: LD_INT 0
113977: ST_TO_ADDR
// sTroll := false ;
113978: LD_ADDR_EXP 173
113982: PUSH
113983: LD_INT 0
113985: ST_TO_ADDR
// sSlow := false ;
113986: LD_ADDR_EXP 174
113990: PUSH
113991: LD_INT 0
113993: ST_TO_ADDR
// sLack := false ;
113994: LD_ADDR_EXP 175
113998: PUSH
113999: LD_INT 0
114001: ST_TO_ADDR
// sTank := false ;
114002: LD_ADDR_EXP 177
114006: PUSH
114007: LD_INT 0
114009: ST_TO_ADDR
// sRemote := false ;
114010: LD_ADDR_EXP 178
114014: PUSH
114015: LD_INT 0
114017: ST_TO_ADDR
// sPowell := false ;
114018: LD_ADDR_EXP 179
114022: PUSH
114023: LD_INT 0
114025: ST_TO_ADDR
// sTeleport := false ;
114026: LD_ADDR_EXP 182
114030: PUSH
114031: LD_INT 0
114033: ST_TO_ADDR
// sOilTower := false ;
114034: LD_ADDR_EXP 184
114038: PUSH
114039: LD_INT 0
114041: ST_TO_ADDR
// sShovel := false ;
114042: LD_ADDR_EXP 185
114046: PUSH
114047: LD_INT 0
114049: ST_TO_ADDR
// sSheik := false ;
114050: LD_ADDR_EXP 186
114054: PUSH
114055: LD_INT 0
114057: ST_TO_ADDR
// sEarthquake := false ;
114058: LD_ADDR_EXP 188
114062: PUSH
114063: LD_INT 0
114065: ST_TO_ADDR
// sAI := false ;
114066: LD_ADDR_EXP 189
114070: PUSH
114071: LD_INT 0
114073: ST_TO_ADDR
// sCargo := false ;
114074: LD_ADDR_EXP 192
114078: PUSH
114079: LD_INT 0
114081: ST_TO_ADDR
// sDLaser := false ;
114082: LD_ADDR_EXP 193
114086: PUSH
114087: LD_INT 0
114089: ST_TO_ADDR
// sExchange := false ;
114090: LD_ADDR_EXP 194
114094: PUSH
114095: LD_INT 0
114097: ST_TO_ADDR
// sFac := false ;
114098: LD_ADDR_EXP 195
114102: PUSH
114103: LD_INT 0
114105: ST_TO_ADDR
// sPower := false ;
114106: LD_ADDR_EXP 196
114110: PUSH
114111: LD_INT 0
114113: ST_TO_ADDR
// sRandom := false ;
114114: LD_ADDR_EXP 197
114118: PUSH
114119: LD_INT 0
114121: ST_TO_ADDR
// sShield := false ;
114122: LD_ADDR_EXP 198
114126: PUSH
114127: LD_INT 0
114129: ST_TO_ADDR
// sTime := false ;
114130: LD_ADDR_EXP 199
114134: PUSH
114135: LD_INT 0
114137: ST_TO_ADDR
// sTools := false ;
114138: LD_ADDR_EXP 200
114142: PUSH
114143: LD_INT 0
114145: ST_TO_ADDR
// sSold := false ;
114146: LD_ADDR_EXP 165
114150: PUSH
114151: LD_INT 0
114153: ST_TO_ADDR
// sDiff := false ;
114154: LD_ADDR_EXP 166
114158: PUSH
114159: LD_INT 0
114161: ST_TO_ADDR
// sFog := false ;
114162: LD_ADDR_EXP 169
114166: PUSH
114167: LD_INT 0
114169: ST_TO_ADDR
// sReset := false ;
114170: LD_ADDR_EXP 170
114174: PUSH
114175: LD_INT 0
114177: ST_TO_ADDR
// sSun := false ;
114178: LD_ADDR_EXP 171
114182: PUSH
114183: LD_INT 0
114185: ST_TO_ADDR
// sTiger := false ;
114186: LD_ADDR_EXP 167
114190: PUSH
114191: LD_INT 0
114193: ST_TO_ADDR
// sBomb := false ;
114194: LD_ADDR_EXP 168
114198: PUSH
114199: LD_INT 0
114201: ST_TO_ADDR
// sWound := false ;
114202: LD_ADDR_EXP 176
114206: PUSH
114207: LD_INT 0
114209: ST_TO_ADDR
// sBetray := false ;
114210: LD_ADDR_EXP 180
114214: PUSH
114215: LD_INT 0
114217: ST_TO_ADDR
// sContamin := false ;
114218: LD_ADDR_EXP 181
114222: PUSH
114223: LD_INT 0
114225: ST_TO_ADDR
// sOil := false ;
114226: LD_ADDR_EXP 183
114230: PUSH
114231: LD_INT 0
114233: ST_TO_ADDR
// sStu := false ;
114234: LD_ADDR_EXP 187
114238: PUSH
114239: LD_INT 0
114241: ST_TO_ADDR
// sBazooka := false ;
114242: LD_ADDR_EXP 190
114246: PUSH
114247: LD_INT 0
114249: ST_TO_ADDR
// sMortar := false ;
114250: LD_ADDR_EXP 191
114254: PUSH
114255: LD_INT 0
114257: ST_TO_ADDR
// sRanger := false ;
114258: LD_ADDR_EXP 201
114262: PUSH
114263: LD_INT 0
114265: ST_TO_ADDR
// sComputer := false ;
114266: LD_ADDR_EXP 202
114270: PUSH
114271: LD_INT 0
114273: ST_TO_ADDR
// s30 := false ;
114274: LD_ADDR_EXP 203
114278: PUSH
114279: LD_INT 0
114281: ST_TO_ADDR
// s60 := false ;
114282: LD_ADDR_EXP 204
114286: PUSH
114287: LD_INT 0
114289: ST_TO_ADDR
// end ;
114290: LD_VAR 0 1
114294: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
114295: LD_INT 0
114297: PPUSH
114298: PPUSH
114299: PPUSH
114300: PPUSH
114301: PPUSH
114302: PPUSH
114303: PPUSH
// result := [ ] ;
114304: LD_ADDR_VAR 0 2
114308: PUSH
114309: EMPTY
114310: ST_TO_ADDR
// if campaign_id = 1 then
114311: LD_OWVAR 69
114315: PUSH
114316: LD_INT 1
114318: EQUAL
114319: IFFALSE 117485
// begin case mission_number of 1 :
114321: LD_OWVAR 70
114325: PUSH
114326: LD_INT 1
114328: DOUBLE
114329: EQUAL
114330: IFTRUE 114334
114332: GO 114410
114334: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
114335: LD_ADDR_VAR 0 2
114339: PUSH
114340: LD_INT 2
114342: PUSH
114343: LD_INT 4
114345: PUSH
114346: LD_INT 11
114348: PUSH
114349: LD_INT 12
114351: PUSH
114352: LD_INT 15
114354: PUSH
114355: LD_INT 16
114357: PUSH
114358: LD_INT 22
114360: PUSH
114361: LD_INT 23
114363: PUSH
114364: LD_INT 26
114366: PUSH
114367: EMPTY
114368: LIST
114369: LIST
114370: LIST
114371: LIST
114372: LIST
114373: LIST
114374: LIST
114375: LIST
114376: LIST
114377: PUSH
114378: LD_INT 101
114380: PUSH
114381: LD_INT 102
114383: PUSH
114384: LD_INT 106
114386: PUSH
114387: LD_INT 116
114389: PUSH
114390: LD_INT 117
114392: PUSH
114393: LD_INT 118
114395: PUSH
114396: EMPTY
114397: LIST
114398: LIST
114399: LIST
114400: LIST
114401: LIST
114402: LIST
114403: PUSH
114404: EMPTY
114405: LIST
114406: LIST
114407: ST_TO_ADDR
114408: GO 117483
114410: LD_INT 2
114412: DOUBLE
114413: EQUAL
114414: IFTRUE 114418
114416: GO 114502
114418: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
114419: LD_ADDR_VAR 0 2
114423: PUSH
114424: LD_INT 2
114426: PUSH
114427: LD_INT 4
114429: PUSH
114430: LD_INT 11
114432: PUSH
114433: LD_INT 12
114435: PUSH
114436: LD_INT 15
114438: PUSH
114439: LD_INT 16
114441: PUSH
114442: LD_INT 22
114444: PUSH
114445: LD_INT 23
114447: PUSH
114448: LD_INT 26
114450: PUSH
114451: EMPTY
114452: LIST
114453: LIST
114454: LIST
114455: LIST
114456: LIST
114457: LIST
114458: LIST
114459: LIST
114460: LIST
114461: PUSH
114462: LD_INT 101
114464: PUSH
114465: LD_INT 102
114467: PUSH
114468: LD_INT 105
114470: PUSH
114471: LD_INT 106
114473: PUSH
114474: LD_INT 108
114476: PUSH
114477: LD_INT 116
114479: PUSH
114480: LD_INT 117
114482: PUSH
114483: LD_INT 118
114485: PUSH
114486: EMPTY
114487: LIST
114488: LIST
114489: LIST
114490: LIST
114491: LIST
114492: LIST
114493: LIST
114494: LIST
114495: PUSH
114496: EMPTY
114497: LIST
114498: LIST
114499: ST_TO_ADDR
114500: GO 117483
114502: LD_INT 3
114504: DOUBLE
114505: EQUAL
114506: IFTRUE 114510
114508: GO 114598
114510: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
114511: LD_ADDR_VAR 0 2
114515: PUSH
114516: LD_INT 2
114518: PUSH
114519: LD_INT 4
114521: PUSH
114522: LD_INT 5
114524: PUSH
114525: LD_INT 11
114527: PUSH
114528: LD_INT 12
114530: PUSH
114531: LD_INT 15
114533: PUSH
114534: LD_INT 16
114536: PUSH
114537: LD_INT 22
114539: PUSH
114540: LD_INT 26
114542: PUSH
114543: LD_INT 36
114545: PUSH
114546: EMPTY
114547: LIST
114548: LIST
114549: LIST
114550: LIST
114551: LIST
114552: LIST
114553: LIST
114554: LIST
114555: LIST
114556: LIST
114557: PUSH
114558: LD_INT 101
114560: PUSH
114561: LD_INT 102
114563: PUSH
114564: LD_INT 105
114566: PUSH
114567: LD_INT 106
114569: PUSH
114570: LD_INT 108
114572: PUSH
114573: LD_INT 116
114575: PUSH
114576: LD_INT 117
114578: PUSH
114579: LD_INT 118
114581: PUSH
114582: EMPTY
114583: LIST
114584: LIST
114585: LIST
114586: LIST
114587: LIST
114588: LIST
114589: LIST
114590: LIST
114591: PUSH
114592: EMPTY
114593: LIST
114594: LIST
114595: ST_TO_ADDR
114596: GO 117483
114598: LD_INT 4
114600: DOUBLE
114601: EQUAL
114602: IFTRUE 114606
114604: GO 114702
114606: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
114607: LD_ADDR_VAR 0 2
114611: PUSH
114612: LD_INT 2
114614: PUSH
114615: LD_INT 4
114617: PUSH
114618: LD_INT 5
114620: PUSH
114621: LD_INT 8
114623: PUSH
114624: LD_INT 11
114626: PUSH
114627: LD_INT 12
114629: PUSH
114630: LD_INT 15
114632: PUSH
114633: LD_INT 16
114635: PUSH
114636: LD_INT 22
114638: PUSH
114639: LD_INT 23
114641: PUSH
114642: LD_INT 26
114644: PUSH
114645: LD_INT 36
114647: PUSH
114648: EMPTY
114649: LIST
114650: LIST
114651: LIST
114652: LIST
114653: LIST
114654: LIST
114655: LIST
114656: LIST
114657: LIST
114658: LIST
114659: LIST
114660: LIST
114661: PUSH
114662: LD_INT 101
114664: PUSH
114665: LD_INT 102
114667: PUSH
114668: LD_INT 105
114670: PUSH
114671: LD_INT 106
114673: PUSH
114674: LD_INT 108
114676: PUSH
114677: LD_INT 116
114679: PUSH
114680: LD_INT 117
114682: PUSH
114683: LD_INT 118
114685: PUSH
114686: EMPTY
114687: LIST
114688: LIST
114689: LIST
114690: LIST
114691: LIST
114692: LIST
114693: LIST
114694: LIST
114695: PUSH
114696: EMPTY
114697: LIST
114698: LIST
114699: ST_TO_ADDR
114700: GO 117483
114702: LD_INT 5
114704: DOUBLE
114705: EQUAL
114706: IFTRUE 114710
114708: GO 114822
114710: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
114711: LD_ADDR_VAR 0 2
114715: PUSH
114716: LD_INT 2
114718: PUSH
114719: LD_INT 4
114721: PUSH
114722: LD_INT 5
114724: PUSH
114725: LD_INT 6
114727: PUSH
114728: LD_INT 8
114730: PUSH
114731: LD_INT 11
114733: PUSH
114734: LD_INT 12
114736: PUSH
114737: LD_INT 15
114739: PUSH
114740: LD_INT 16
114742: PUSH
114743: LD_INT 22
114745: PUSH
114746: LD_INT 23
114748: PUSH
114749: LD_INT 25
114751: PUSH
114752: LD_INT 26
114754: PUSH
114755: LD_INT 36
114757: PUSH
114758: EMPTY
114759: LIST
114760: LIST
114761: LIST
114762: LIST
114763: LIST
114764: LIST
114765: LIST
114766: LIST
114767: LIST
114768: LIST
114769: LIST
114770: LIST
114771: LIST
114772: LIST
114773: PUSH
114774: LD_INT 101
114776: PUSH
114777: LD_INT 102
114779: PUSH
114780: LD_INT 105
114782: PUSH
114783: LD_INT 106
114785: PUSH
114786: LD_INT 108
114788: PUSH
114789: LD_INT 109
114791: PUSH
114792: LD_INT 112
114794: PUSH
114795: LD_INT 116
114797: PUSH
114798: LD_INT 117
114800: PUSH
114801: LD_INT 118
114803: PUSH
114804: EMPTY
114805: LIST
114806: LIST
114807: LIST
114808: LIST
114809: LIST
114810: LIST
114811: LIST
114812: LIST
114813: LIST
114814: LIST
114815: PUSH
114816: EMPTY
114817: LIST
114818: LIST
114819: ST_TO_ADDR
114820: GO 117483
114822: LD_INT 6
114824: DOUBLE
114825: EQUAL
114826: IFTRUE 114830
114828: GO 114962
114830: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
114831: LD_ADDR_VAR 0 2
114835: PUSH
114836: LD_INT 2
114838: PUSH
114839: LD_INT 4
114841: PUSH
114842: LD_INT 5
114844: PUSH
114845: LD_INT 6
114847: PUSH
114848: LD_INT 8
114850: PUSH
114851: LD_INT 11
114853: PUSH
114854: LD_INT 12
114856: PUSH
114857: LD_INT 15
114859: PUSH
114860: LD_INT 16
114862: PUSH
114863: LD_INT 20
114865: PUSH
114866: LD_INT 21
114868: PUSH
114869: LD_INT 22
114871: PUSH
114872: LD_INT 23
114874: PUSH
114875: LD_INT 25
114877: PUSH
114878: LD_INT 26
114880: PUSH
114881: LD_INT 30
114883: PUSH
114884: LD_INT 31
114886: PUSH
114887: LD_INT 32
114889: PUSH
114890: LD_INT 36
114892: PUSH
114893: EMPTY
114894: LIST
114895: LIST
114896: LIST
114897: LIST
114898: LIST
114899: LIST
114900: LIST
114901: LIST
114902: LIST
114903: LIST
114904: LIST
114905: LIST
114906: LIST
114907: LIST
114908: LIST
114909: LIST
114910: LIST
114911: LIST
114912: LIST
114913: PUSH
114914: LD_INT 101
114916: PUSH
114917: LD_INT 102
114919: PUSH
114920: LD_INT 105
114922: PUSH
114923: LD_INT 106
114925: PUSH
114926: LD_INT 108
114928: PUSH
114929: LD_INT 109
114931: PUSH
114932: LD_INT 112
114934: PUSH
114935: LD_INT 116
114937: PUSH
114938: LD_INT 117
114940: PUSH
114941: LD_INT 118
114943: PUSH
114944: EMPTY
114945: LIST
114946: LIST
114947: LIST
114948: LIST
114949: LIST
114950: LIST
114951: LIST
114952: LIST
114953: LIST
114954: LIST
114955: PUSH
114956: EMPTY
114957: LIST
114958: LIST
114959: ST_TO_ADDR
114960: GO 117483
114962: LD_INT 7
114964: DOUBLE
114965: EQUAL
114966: IFTRUE 114970
114968: GO 115082
114970: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
114971: LD_ADDR_VAR 0 2
114975: PUSH
114976: LD_INT 2
114978: PUSH
114979: LD_INT 4
114981: PUSH
114982: LD_INT 5
114984: PUSH
114985: LD_INT 7
114987: PUSH
114988: LD_INT 11
114990: PUSH
114991: LD_INT 12
114993: PUSH
114994: LD_INT 15
114996: PUSH
114997: LD_INT 16
114999: PUSH
115000: LD_INT 20
115002: PUSH
115003: LD_INT 21
115005: PUSH
115006: LD_INT 22
115008: PUSH
115009: LD_INT 23
115011: PUSH
115012: LD_INT 25
115014: PUSH
115015: LD_INT 26
115017: PUSH
115018: EMPTY
115019: LIST
115020: LIST
115021: LIST
115022: LIST
115023: LIST
115024: LIST
115025: LIST
115026: LIST
115027: LIST
115028: LIST
115029: LIST
115030: LIST
115031: LIST
115032: LIST
115033: PUSH
115034: LD_INT 101
115036: PUSH
115037: LD_INT 102
115039: PUSH
115040: LD_INT 103
115042: PUSH
115043: LD_INT 105
115045: PUSH
115046: LD_INT 106
115048: PUSH
115049: LD_INT 108
115051: PUSH
115052: LD_INT 112
115054: PUSH
115055: LD_INT 116
115057: PUSH
115058: LD_INT 117
115060: PUSH
115061: LD_INT 118
115063: PUSH
115064: EMPTY
115065: LIST
115066: LIST
115067: LIST
115068: LIST
115069: LIST
115070: LIST
115071: LIST
115072: LIST
115073: LIST
115074: LIST
115075: PUSH
115076: EMPTY
115077: LIST
115078: LIST
115079: ST_TO_ADDR
115080: GO 117483
115082: LD_INT 8
115084: DOUBLE
115085: EQUAL
115086: IFTRUE 115090
115088: GO 115230
115090: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
115091: LD_ADDR_VAR 0 2
115095: PUSH
115096: LD_INT 2
115098: PUSH
115099: LD_INT 4
115101: PUSH
115102: LD_INT 5
115104: PUSH
115105: LD_INT 6
115107: PUSH
115108: LD_INT 7
115110: PUSH
115111: LD_INT 8
115113: PUSH
115114: LD_INT 11
115116: PUSH
115117: LD_INT 12
115119: PUSH
115120: LD_INT 15
115122: PUSH
115123: LD_INT 16
115125: PUSH
115126: LD_INT 20
115128: PUSH
115129: LD_INT 21
115131: PUSH
115132: LD_INT 22
115134: PUSH
115135: LD_INT 23
115137: PUSH
115138: LD_INT 25
115140: PUSH
115141: LD_INT 26
115143: PUSH
115144: LD_INT 30
115146: PUSH
115147: LD_INT 31
115149: PUSH
115150: LD_INT 32
115152: PUSH
115153: LD_INT 36
115155: PUSH
115156: EMPTY
115157: LIST
115158: LIST
115159: LIST
115160: LIST
115161: LIST
115162: LIST
115163: LIST
115164: LIST
115165: LIST
115166: LIST
115167: LIST
115168: LIST
115169: LIST
115170: LIST
115171: LIST
115172: LIST
115173: LIST
115174: LIST
115175: LIST
115176: LIST
115177: PUSH
115178: LD_INT 101
115180: PUSH
115181: LD_INT 102
115183: PUSH
115184: LD_INT 103
115186: PUSH
115187: LD_INT 105
115189: PUSH
115190: LD_INT 106
115192: PUSH
115193: LD_INT 108
115195: PUSH
115196: LD_INT 109
115198: PUSH
115199: LD_INT 112
115201: PUSH
115202: LD_INT 116
115204: PUSH
115205: LD_INT 117
115207: PUSH
115208: LD_INT 118
115210: PUSH
115211: EMPTY
115212: LIST
115213: LIST
115214: LIST
115215: LIST
115216: LIST
115217: LIST
115218: LIST
115219: LIST
115220: LIST
115221: LIST
115222: LIST
115223: PUSH
115224: EMPTY
115225: LIST
115226: LIST
115227: ST_TO_ADDR
115228: GO 117483
115230: LD_INT 9
115232: DOUBLE
115233: EQUAL
115234: IFTRUE 115238
115236: GO 115386
115238: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
115239: LD_ADDR_VAR 0 2
115243: PUSH
115244: LD_INT 2
115246: PUSH
115247: LD_INT 4
115249: PUSH
115250: LD_INT 5
115252: PUSH
115253: LD_INT 6
115255: PUSH
115256: LD_INT 7
115258: PUSH
115259: LD_INT 8
115261: PUSH
115262: LD_INT 11
115264: PUSH
115265: LD_INT 12
115267: PUSH
115268: LD_INT 15
115270: PUSH
115271: LD_INT 16
115273: PUSH
115274: LD_INT 20
115276: PUSH
115277: LD_INT 21
115279: PUSH
115280: LD_INT 22
115282: PUSH
115283: LD_INT 23
115285: PUSH
115286: LD_INT 25
115288: PUSH
115289: LD_INT 26
115291: PUSH
115292: LD_INT 28
115294: PUSH
115295: LD_INT 30
115297: PUSH
115298: LD_INT 31
115300: PUSH
115301: LD_INT 32
115303: PUSH
115304: LD_INT 36
115306: PUSH
115307: EMPTY
115308: LIST
115309: LIST
115310: LIST
115311: LIST
115312: LIST
115313: LIST
115314: LIST
115315: LIST
115316: LIST
115317: LIST
115318: LIST
115319: LIST
115320: LIST
115321: LIST
115322: LIST
115323: LIST
115324: LIST
115325: LIST
115326: LIST
115327: LIST
115328: LIST
115329: PUSH
115330: LD_INT 101
115332: PUSH
115333: LD_INT 102
115335: PUSH
115336: LD_INT 103
115338: PUSH
115339: LD_INT 105
115341: PUSH
115342: LD_INT 106
115344: PUSH
115345: LD_INT 108
115347: PUSH
115348: LD_INT 109
115350: PUSH
115351: LD_INT 112
115353: PUSH
115354: LD_INT 114
115356: PUSH
115357: LD_INT 116
115359: PUSH
115360: LD_INT 117
115362: PUSH
115363: LD_INT 118
115365: PUSH
115366: EMPTY
115367: LIST
115368: LIST
115369: LIST
115370: LIST
115371: LIST
115372: LIST
115373: LIST
115374: LIST
115375: LIST
115376: LIST
115377: LIST
115378: LIST
115379: PUSH
115380: EMPTY
115381: LIST
115382: LIST
115383: ST_TO_ADDR
115384: GO 117483
115386: LD_INT 10
115388: DOUBLE
115389: EQUAL
115390: IFTRUE 115394
115392: GO 115590
115394: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
115395: LD_ADDR_VAR 0 2
115399: PUSH
115400: LD_INT 2
115402: PUSH
115403: LD_INT 4
115405: PUSH
115406: LD_INT 5
115408: PUSH
115409: LD_INT 6
115411: PUSH
115412: LD_INT 7
115414: PUSH
115415: LD_INT 8
115417: PUSH
115418: LD_INT 9
115420: PUSH
115421: LD_INT 10
115423: PUSH
115424: LD_INT 11
115426: PUSH
115427: LD_INT 12
115429: PUSH
115430: LD_INT 13
115432: PUSH
115433: LD_INT 14
115435: PUSH
115436: LD_INT 15
115438: PUSH
115439: LD_INT 16
115441: PUSH
115442: LD_INT 17
115444: PUSH
115445: LD_INT 18
115447: PUSH
115448: LD_INT 19
115450: PUSH
115451: LD_INT 20
115453: PUSH
115454: LD_INT 21
115456: PUSH
115457: LD_INT 22
115459: PUSH
115460: LD_INT 23
115462: PUSH
115463: LD_INT 24
115465: PUSH
115466: LD_INT 25
115468: PUSH
115469: LD_INT 26
115471: PUSH
115472: LD_INT 28
115474: PUSH
115475: LD_INT 30
115477: PUSH
115478: LD_INT 31
115480: PUSH
115481: LD_INT 32
115483: PUSH
115484: LD_INT 36
115486: PUSH
115487: EMPTY
115488: LIST
115489: LIST
115490: LIST
115491: LIST
115492: LIST
115493: LIST
115494: LIST
115495: LIST
115496: LIST
115497: LIST
115498: LIST
115499: LIST
115500: LIST
115501: LIST
115502: LIST
115503: LIST
115504: LIST
115505: LIST
115506: LIST
115507: LIST
115508: LIST
115509: LIST
115510: LIST
115511: LIST
115512: LIST
115513: LIST
115514: LIST
115515: LIST
115516: LIST
115517: PUSH
115518: LD_INT 101
115520: PUSH
115521: LD_INT 102
115523: PUSH
115524: LD_INT 103
115526: PUSH
115527: LD_INT 104
115529: PUSH
115530: LD_INT 105
115532: PUSH
115533: LD_INT 106
115535: PUSH
115536: LD_INT 107
115538: PUSH
115539: LD_INT 108
115541: PUSH
115542: LD_INT 109
115544: PUSH
115545: LD_INT 110
115547: PUSH
115548: LD_INT 111
115550: PUSH
115551: LD_INT 112
115553: PUSH
115554: LD_INT 114
115556: PUSH
115557: LD_INT 116
115559: PUSH
115560: LD_INT 117
115562: PUSH
115563: LD_INT 118
115565: PUSH
115566: EMPTY
115567: LIST
115568: LIST
115569: LIST
115570: LIST
115571: LIST
115572: LIST
115573: LIST
115574: LIST
115575: LIST
115576: LIST
115577: LIST
115578: LIST
115579: LIST
115580: LIST
115581: LIST
115582: LIST
115583: PUSH
115584: EMPTY
115585: LIST
115586: LIST
115587: ST_TO_ADDR
115588: GO 117483
115590: LD_INT 11
115592: DOUBLE
115593: EQUAL
115594: IFTRUE 115598
115596: GO 115802
115598: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
115599: LD_ADDR_VAR 0 2
115603: PUSH
115604: LD_INT 2
115606: PUSH
115607: LD_INT 3
115609: PUSH
115610: LD_INT 4
115612: PUSH
115613: LD_INT 5
115615: PUSH
115616: LD_INT 6
115618: PUSH
115619: LD_INT 7
115621: PUSH
115622: LD_INT 8
115624: PUSH
115625: LD_INT 9
115627: PUSH
115628: LD_INT 10
115630: PUSH
115631: LD_INT 11
115633: PUSH
115634: LD_INT 12
115636: PUSH
115637: LD_INT 13
115639: PUSH
115640: LD_INT 14
115642: PUSH
115643: LD_INT 15
115645: PUSH
115646: LD_INT 16
115648: PUSH
115649: LD_INT 17
115651: PUSH
115652: LD_INT 18
115654: PUSH
115655: LD_INT 19
115657: PUSH
115658: LD_INT 20
115660: PUSH
115661: LD_INT 21
115663: PUSH
115664: LD_INT 22
115666: PUSH
115667: LD_INT 23
115669: PUSH
115670: LD_INT 24
115672: PUSH
115673: LD_INT 25
115675: PUSH
115676: LD_INT 26
115678: PUSH
115679: LD_INT 28
115681: PUSH
115682: LD_INT 30
115684: PUSH
115685: LD_INT 31
115687: PUSH
115688: LD_INT 32
115690: PUSH
115691: LD_INT 34
115693: PUSH
115694: LD_INT 36
115696: PUSH
115697: EMPTY
115698: LIST
115699: LIST
115700: LIST
115701: LIST
115702: LIST
115703: LIST
115704: LIST
115705: LIST
115706: LIST
115707: LIST
115708: LIST
115709: LIST
115710: LIST
115711: LIST
115712: LIST
115713: LIST
115714: LIST
115715: LIST
115716: LIST
115717: LIST
115718: LIST
115719: LIST
115720: LIST
115721: LIST
115722: LIST
115723: LIST
115724: LIST
115725: LIST
115726: LIST
115727: LIST
115728: LIST
115729: PUSH
115730: LD_INT 101
115732: PUSH
115733: LD_INT 102
115735: PUSH
115736: LD_INT 103
115738: PUSH
115739: LD_INT 104
115741: PUSH
115742: LD_INT 105
115744: PUSH
115745: LD_INT 106
115747: PUSH
115748: LD_INT 107
115750: PUSH
115751: LD_INT 108
115753: PUSH
115754: LD_INT 109
115756: PUSH
115757: LD_INT 110
115759: PUSH
115760: LD_INT 111
115762: PUSH
115763: LD_INT 112
115765: PUSH
115766: LD_INT 114
115768: PUSH
115769: LD_INT 116
115771: PUSH
115772: LD_INT 117
115774: PUSH
115775: LD_INT 118
115777: PUSH
115778: EMPTY
115779: LIST
115780: LIST
115781: LIST
115782: LIST
115783: LIST
115784: LIST
115785: LIST
115786: LIST
115787: LIST
115788: LIST
115789: LIST
115790: LIST
115791: LIST
115792: LIST
115793: LIST
115794: LIST
115795: PUSH
115796: EMPTY
115797: LIST
115798: LIST
115799: ST_TO_ADDR
115800: GO 117483
115802: LD_INT 12
115804: DOUBLE
115805: EQUAL
115806: IFTRUE 115810
115808: GO 116030
115810: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
115811: LD_ADDR_VAR 0 2
115815: PUSH
115816: LD_INT 1
115818: PUSH
115819: LD_INT 2
115821: PUSH
115822: LD_INT 3
115824: PUSH
115825: LD_INT 4
115827: PUSH
115828: LD_INT 5
115830: PUSH
115831: LD_INT 6
115833: PUSH
115834: LD_INT 7
115836: PUSH
115837: LD_INT 8
115839: PUSH
115840: LD_INT 9
115842: PUSH
115843: LD_INT 10
115845: PUSH
115846: LD_INT 11
115848: PUSH
115849: LD_INT 12
115851: PUSH
115852: LD_INT 13
115854: PUSH
115855: LD_INT 14
115857: PUSH
115858: LD_INT 15
115860: PUSH
115861: LD_INT 16
115863: PUSH
115864: LD_INT 17
115866: PUSH
115867: LD_INT 18
115869: PUSH
115870: LD_INT 19
115872: PUSH
115873: LD_INT 20
115875: PUSH
115876: LD_INT 21
115878: PUSH
115879: LD_INT 22
115881: PUSH
115882: LD_INT 23
115884: PUSH
115885: LD_INT 24
115887: PUSH
115888: LD_INT 25
115890: PUSH
115891: LD_INT 26
115893: PUSH
115894: LD_INT 27
115896: PUSH
115897: LD_INT 28
115899: PUSH
115900: LD_INT 30
115902: PUSH
115903: LD_INT 31
115905: PUSH
115906: LD_INT 32
115908: PUSH
115909: LD_INT 33
115911: PUSH
115912: LD_INT 34
115914: PUSH
115915: LD_INT 36
115917: PUSH
115918: EMPTY
115919: LIST
115920: LIST
115921: LIST
115922: LIST
115923: LIST
115924: LIST
115925: LIST
115926: LIST
115927: LIST
115928: LIST
115929: LIST
115930: LIST
115931: LIST
115932: LIST
115933: LIST
115934: LIST
115935: LIST
115936: LIST
115937: LIST
115938: LIST
115939: LIST
115940: LIST
115941: LIST
115942: LIST
115943: LIST
115944: LIST
115945: LIST
115946: LIST
115947: LIST
115948: LIST
115949: LIST
115950: LIST
115951: LIST
115952: LIST
115953: PUSH
115954: LD_INT 101
115956: PUSH
115957: LD_INT 102
115959: PUSH
115960: LD_INT 103
115962: PUSH
115963: LD_INT 104
115965: PUSH
115966: LD_INT 105
115968: PUSH
115969: LD_INT 106
115971: PUSH
115972: LD_INT 107
115974: PUSH
115975: LD_INT 108
115977: PUSH
115978: LD_INT 109
115980: PUSH
115981: LD_INT 110
115983: PUSH
115984: LD_INT 111
115986: PUSH
115987: LD_INT 112
115989: PUSH
115990: LD_INT 113
115992: PUSH
115993: LD_INT 114
115995: PUSH
115996: LD_INT 116
115998: PUSH
115999: LD_INT 117
116001: PUSH
116002: LD_INT 118
116004: PUSH
116005: EMPTY
116006: LIST
116007: LIST
116008: LIST
116009: LIST
116010: LIST
116011: LIST
116012: LIST
116013: LIST
116014: LIST
116015: LIST
116016: LIST
116017: LIST
116018: LIST
116019: LIST
116020: LIST
116021: LIST
116022: LIST
116023: PUSH
116024: EMPTY
116025: LIST
116026: LIST
116027: ST_TO_ADDR
116028: GO 117483
116030: LD_INT 13
116032: DOUBLE
116033: EQUAL
116034: IFTRUE 116038
116036: GO 116246
116038: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
116039: LD_ADDR_VAR 0 2
116043: PUSH
116044: LD_INT 1
116046: PUSH
116047: LD_INT 2
116049: PUSH
116050: LD_INT 3
116052: PUSH
116053: LD_INT 4
116055: PUSH
116056: LD_INT 5
116058: PUSH
116059: LD_INT 8
116061: PUSH
116062: LD_INT 9
116064: PUSH
116065: LD_INT 10
116067: PUSH
116068: LD_INT 11
116070: PUSH
116071: LD_INT 12
116073: PUSH
116074: LD_INT 14
116076: PUSH
116077: LD_INT 15
116079: PUSH
116080: LD_INT 16
116082: PUSH
116083: LD_INT 17
116085: PUSH
116086: LD_INT 18
116088: PUSH
116089: LD_INT 19
116091: PUSH
116092: LD_INT 20
116094: PUSH
116095: LD_INT 21
116097: PUSH
116098: LD_INT 22
116100: PUSH
116101: LD_INT 23
116103: PUSH
116104: LD_INT 24
116106: PUSH
116107: LD_INT 25
116109: PUSH
116110: LD_INT 26
116112: PUSH
116113: LD_INT 27
116115: PUSH
116116: LD_INT 28
116118: PUSH
116119: LD_INT 30
116121: PUSH
116122: LD_INT 31
116124: PUSH
116125: LD_INT 32
116127: PUSH
116128: LD_INT 33
116130: PUSH
116131: LD_INT 34
116133: PUSH
116134: LD_INT 36
116136: PUSH
116137: EMPTY
116138: LIST
116139: LIST
116140: LIST
116141: LIST
116142: LIST
116143: LIST
116144: LIST
116145: LIST
116146: LIST
116147: LIST
116148: LIST
116149: LIST
116150: LIST
116151: LIST
116152: LIST
116153: LIST
116154: LIST
116155: LIST
116156: LIST
116157: LIST
116158: LIST
116159: LIST
116160: LIST
116161: LIST
116162: LIST
116163: LIST
116164: LIST
116165: LIST
116166: LIST
116167: LIST
116168: LIST
116169: PUSH
116170: LD_INT 101
116172: PUSH
116173: LD_INT 102
116175: PUSH
116176: LD_INT 103
116178: PUSH
116179: LD_INT 104
116181: PUSH
116182: LD_INT 105
116184: PUSH
116185: LD_INT 106
116187: PUSH
116188: LD_INT 107
116190: PUSH
116191: LD_INT 108
116193: PUSH
116194: LD_INT 109
116196: PUSH
116197: LD_INT 110
116199: PUSH
116200: LD_INT 111
116202: PUSH
116203: LD_INT 112
116205: PUSH
116206: LD_INT 113
116208: PUSH
116209: LD_INT 114
116211: PUSH
116212: LD_INT 116
116214: PUSH
116215: LD_INT 117
116217: PUSH
116218: LD_INT 118
116220: PUSH
116221: EMPTY
116222: LIST
116223: LIST
116224: LIST
116225: LIST
116226: LIST
116227: LIST
116228: LIST
116229: LIST
116230: LIST
116231: LIST
116232: LIST
116233: LIST
116234: LIST
116235: LIST
116236: LIST
116237: LIST
116238: LIST
116239: PUSH
116240: EMPTY
116241: LIST
116242: LIST
116243: ST_TO_ADDR
116244: GO 117483
116246: LD_INT 14
116248: DOUBLE
116249: EQUAL
116250: IFTRUE 116254
116252: GO 116478
116254: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
116255: LD_ADDR_VAR 0 2
116259: PUSH
116260: LD_INT 1
116262: PUSH
116263: LD_INT 2
116265: PUSH
116266: LD_INT 3
116268: PUSH
116269: LD_INT 4
116271: PUSH
116272: LD_INT 5
116274: PUSH
116275: LD_INT 6
116277: PUSH
116278: LD_INT 7
116280: PUSH
116281: LD_INT 8
116283: PUSH
116284: LD_INT 9
116286: PUSH
116287: LD_INT 10
116289: PUSH
116290: LD_INT 11
116292: PUSH
116293: LD_INT 12
116295: PUSH
116296: LD_INT 13
116298: PUSH
116299: LD_INT 14
116301: PUSH
116302: LD_INT 15
116304: PUSH
116305: LD_INT 16
116307: PUSH
116308: LD_INT 17
116310: PUSH
116311: LD_INT 18
116313: PUSH
116314: LD_INT 19
116316: PUSH
116317: LD_INT 20
116319: PUSH
116320: LD_INT 21
116322: PUSH
116323: LD_INT 22
116325: PUSH
116326: LD_INT 23
116328: PUSH
116329: LD_INT 24
116331: PUSH
116332: LD_INT 25
116334: PUSH
116335: LD_INT 26
116337: PUSH
116338: LD_INT 27
116340: PUSH
116341: LD_INT 28
116343: PUSH
116344: LD_INT 29
116346: PUSH
116347: LD_INT 30
116349: PUSH
116350: LD_INT 31
116352: PUSH
116353: LD_INT 32
116355: PUSH
116356: LD_INT 33
116358: PUSH
116359: LD_INT 34
116361: PUSH
116362: LD_INT 36
116364: PUSH
116365: EMPTY
116366: LIST
116367: LIST
116368: LIST
116369: LIST
116370: LIST
116371: LIST
116372: LIST
116373: LIST
116374: LIST
116375: LIST
116376: LIST
116377: LIST
116378: LIST
116379: LIST
116380: LIST
116381: LIST
116382: LIST
116383: LIST
116384: LIST
116385: LIST
116386: LIST
116387: LIST
116388: LIST
116389: LIST
116390: LIST
116391: LIST
116392: LIST
116393: LIST
116394: LIST
116395: LIST
116396: LIST
116397: LIST
116398: LIST
116399: LIST
116400: LIST
116401: PUSH
116402: LD_INT 101
116404: PUSH
116405: LD_INT 102
116407: PUSH
116408: LD_INT 103
116410: PUSH
116411: LD_INT 104
116413: PUSH
116414: LD_INT 105
116416: PUSH
116417: LD_INT 106
116419: PUSH
116420: LD_INT 107
116422: PUSH
116423: LD_INT 108
116425: PUSH
116426: LD_INT 109
116428: PUSH
116429: LD_INT 110
116431: PUSH
116432: LD_INT 111
116434: PUSH
116435: LD_INT 112
116437: PUSH
116438: LD_INT 113
116440: PUSH
116441: LD_INT 114
116443: PUSH
116444: LD_INT 116
116446: PUSH
116447: LD_INT 117
116449: PUSH
116450: LD_INT 118
116452: PUSH
116453: EMPTY
116454: LIST
116455: LIST
116456: LIST
116457: LIST
116458: LIST
116459: LIST
116460: LIST
116461: LIST
116462: LIST
116463: LIST
116464: LIST
116465: LIST
116466: LIST
116467: LIST
116468: LIST
116469: LIST
116470: LIST
116471: PUSH
116472: EMPTY
116473: LIST
116474: LIST
116475: ST_TO_ADDR
116476: GO 117483
116478: LD_INT 15
116480: DOUBLE
116481: EQUAL
116482: IFTRUE 116486
116484: GO 116710
116486: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
116487: LD_ADDR_VAR 0 2
116491: PUSH
116492: LD_INT 1
116494: PUSH
116495: LD_INT 2
116497: PUSH
116498: LD_INT 3
116500: PUSH
116501: LD_INT 4
116503: PUSH
116504: LD_INT 5
116506: PUSH
116507: LD_INT 6
116509: PUSH
116510: LD_INT 7
116512: PUSH
116513: LD_INT 8
116515: PUSH
116516: LD_INT 9
116518: PUSH
116519: LD_INT 10
116521: PUSH
116522: LD_INT 11
116524: PUSH
116525: LD_INT 12
116527: PUSH
116528: LD_INT 13
116530: PUSH
116531: LD_INT 14
116533: PUSH
116534: LD_INT 15
116536: PUSH
116537: LD_INT 16
116539: PUSH
116540: LD_INT 17
116542: PUSH
116543: LD_INT 18
116545: PUSH
116546: LD_INT 19
116548: PUSH
116549: LD_INT 20
116551: PUSH
116552: LD_INT 21
116554: PUSH
116555: LD_INT 22
116557: PUSH
116558: LD_INT 23
116560: PUSH
116561: LD_INT 24
116563: PUSH
116564: LD_INT 25
116566: PUSH
116567: LD_INT 26
116569: PUSH
116570: LD_INT 27
116572: PUSH
116573: LD_INT 28
116575: PUSH
116576: LD_INT 29
116578: PUSH
116579: LD_INT 30
116581: PUSH
116582: LD_INT 31
116584: PUSH
116585: LD_INT 32
116587: PUSH
116588: LD_INT 33
116590: PUSH
116591: LD_INT 34
116593: PUSH
116594: LD_INT 36
116596: PUSH
116597: EMPTY
116598: LIST
116599: LIST
116600: LIST
116601: LIST
116602: LIST
116603: LIST
116604: LIST
116605: LIST
116606: LIST
116607: LIST
116608: LIST
116609: LIST
116610: LIST
116611: LIST
116612: LIST
116613: LIST
116614: LIST
116615: LIST
116616: LIST
116617: LIST
116618: LIST
116619: LIST
116620: LIST
116621: LIST
116622: LIST
116623: LIST
116624: LIST
116625: LIST
116626: LIST
116627: LIST
116628: LIST
116629: LIST
116630: LIST
116631: LIST
116632: LIST
116633: PUSH
116634: LD_INT 101
116636: PUSH
116637: LD_INT 102
116639: PUSH
116640: LD_INT 103
116642: PUSH
116643: LD_INT 104
116645: PUSH
116646: LD_INT 105
116648: PUSH
116649: LD_INT 106
116651: PUSH
116652: LD_INT 107
116654: PUSH
116655: LD_INT 108
116657: PUSH
116658: LD_INT 109
116660: PUSH
116661: LD_INT 110
116663: PUSH
116664: LD_INT 111
116666: PUSH
116667: LD_INT 112
116669: PUSH
116670: LD_INT 113
116672: PUSH
116673: LD_INT 114
116675: PUSH
116676: LD_INT 116
116678: PUSH
116679: LD_INT 117
116681: PUSH
116682: LD_INT 118
116684: PUSH
116685: EMPTY
116686: LIST
116687: LIST
116688: LIST
116689: LIST
116690: LIST
116691: LIST
116692: LIST
116693: LIST
116694: LIST
116695: LIST
116696: LIST
116697: LIST
116698: LIST
116699: LIST
116700: LIST
116701: LIST
116702: LIST
116703: PUSH
116704: EMPTY
116705: LIST
116706: LIST
116707: ST_TO_ADDR
116708: GO 117483
116710: LD_INT 16
116712: DOUBLE
116713: EQUAL
116714: IFTRUE 116718
116716: GO 116854
116718: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
116719: LD_ADDR_VAR 0 2
116723: PUSH
116724: LD_INT 2
116726: PUSH
116727: LD_INT 4
116729: PUSH
116730: LD_INT 5
116732: PUSH
116733: LD_INT 7
116735: PUSH
116736: LD_INT 11
116738: PUSH
116739: LD_INT 12
116741: PUSH
116742: LD_INT 15
116744: PUSH
116745: LD_INT 16
116747: PUSH
116748: LD_INT 20
116750: PUSH
116751: LD_INT 21
116753: PUSH
116754: LD_INT 22
116756: PUSH
116757: LD_INT 23
116759: PUSH
116760: LD_INT 25
116762: PUSH
116763: LD_INT 26
116765: PUSH
116766: LD_INT 30
116768: PUSH
116769: LD_INT 31
116771: PUSH
116772: LD_INT 32
116774: PUSH
116775: LD_INT 33
116777: PUSH
116778: LD_INT 34
116780: PUSH
116781: EMPTY
116782: LIST
116783: LIST
116784: LIST
116785: LIST
116786: LIST
116787: LIST
116788: LIST
116789: LIST
116790: LIST
116791: LIST
116792: LIST
116793: LIST
116794: LIST
116795: LIST
116796: LIST
116797: LIST
116798: LIST
116799: LIST
116800: LIST
116801: PUSH
116802: LD_INT 101
116804: PUSH
116805: LD_INT 102
116807: PUSH
116808: LD_INT 103
116810: PUSH
116811: LD_INT 106
116813: PUSH
116814: LD_INT 108
116816: PUSH
116817: LD_INT 112
116819: PUSH
116820: LD_INT 113
116822: PUSH
116823: LD_INT 114
116825: PUSH
116826: LD_INT 116
116828: PUSH
116829: LD_INT 117
116831: PUSH
116832: LD_INT 118
116834: PUSH
116835: EMPTY
116836: LIST
116837: LIST
116838: LIST
116839: LIST
116840: LIST
116841: LIST
116842: LIST
116843: LIST
116844: LIST
116845: LIST
116846: LIST
116847: PUSH
116848: EMPTY
116849: LIST
116850: LIST
116851: ST_TO_ADDR
116852: GO 117483
116854: LD_INT 17
116856: DOUBLE
116857: EQUAL
116858: IFTRUE 116862
116860: GO 117086
116862: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
116863: LD_ADDR_VAR 0 2
116867: PUSH
116868: LD_INT 1
116870: PUSH
116871: LD_INT 2
116873: PUSH
116874: LD_INT 3
116876: PUSH
116877: LD_INT 4
116879: PUSH
116880: LD_INT 5
116882: PUSH
116883: LD_INT 6
116885: PUSH
116886: LD_INT 7
116888: PUSH
116889: LD_INT 8
116891: PUSH
116892: LD_INT 9
116894: PUSH
116895: LD_INT 10
116897: PUSH
116898: LD_INT 11
116900: PUSH
116901: LD_INT 12
116903: PUSH
116904: LD_INT 13
116906: PUSH
116907: LD_INT 14
116909: PUSH
116910: LD_INT 15
116912: PUSH
116913: LD_INT 16
116915: PUSH
116916: LD_INT 17
116918: PUSH
116919: LD_INT 18
116921: PUSH
116922: LD_INT 19
116924: PUSH
116925: LD_INT 20
116927: PUSH
116928: LD_INT 21
116930: PUSH
116931: LD_INT 22
116933: PUSH
116934: LD_INT 23
116936: PUSH
116937: LD_INT 24
116939: PUSH
116940: LD_INT 25
116942: PUSH
116943: LD_INT 26
116945: PUSH
116946: LD_INT 27
116948: PUSH
116949: LD_INT 28
116951: PUSH
116952: LD_INT 29
116954: PUSH
116955: LD_INT 30
116957: PUSH
116958: LD_INT 31
116960: PUSH
116961: LD_INT 32
116963: PUSH
116964: LD_INT 33
116966: PUSH
116967: LD_INT 34
116969: PUSH
116970: LD_INT 36
116972: PUSH
116973: EMPTY
116974: LIST
116975: LIST
116976: LIST
116977: LIST
116978: LIST
116979: LIST
116980: LIST
116981: LIST
116982: LIST
116983: LIST
116984: LIST
116985: LIST
116986: LIST
116987: LIST
116988: LIST
116989: LIST
116990: LIST
116991: LIST
116992: LIST
116993: LIST
116994: LIST
116995: LIST
116996: LIST
116997: LIST
116998: LIST
116999: LIST
117000: LIST
117001: LIST
117002: LIST
117003: LIST
117004: LIST
117005: LIST
117006: LIST
117007: LIST
117008: LIST
117009: PUSH
117010: LD_INT 101
117012: PUSH
117013: LD_INT 102
117015: PUSH
117016: LD_INT 103
117018: PUSH
117019: LD_INT 104
117021: PUSH
117022: LD_INT 105
117024: PUSH
117025: LD_INT 106
117027: PUSH
117028: LD_INT 107
117030: PUSH
117031: LD_INT 108
117033: PUSH
117034: LD_INT 109
117036: PUSH
117037: LD_INT 110
117039: PUSH
117040: LD_INT 111
117042: PUSH
117043: LD_INT 112
117045: PUSH
117046: LD_INT 113
117048: PUSH
117049: LD_INT 114
117051: PUSH
117052: LD_INT 116
117054: PUSH
117055: LD_INT 117
117057: PUSH
117058: LD_INT 118
117060: PUSH
117061: EMPTY
117062: LIST
117063: LIST
117064: LIST
117065: LIST
117066: LIST
117067: LIST
117068: LIST
117069: LIST
117070: LIST
117071: LIST
117072: LIST
117073: LIST
117074: LIST
117075: LIST
117076: LIST
117077: LIST
117078: LIST
117079: PUSH
117080: EMPTY
117081: LIST
117082: LIST
117083: ST_TO_ADDR
117084: GO 117483
117086: LD_INT 18
117088: DOUBLE
117089: EQUAL
117090: IFTRUE 117094
117092: GO 117242
117094: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
117095: LD_ADDR_VAR 0 2
117099: PUSH
117100: LD_INT 2
117102: PUSH
117103: LD_INT 4
117105: PUSH
117106: LD_INT 5
117108: PUSH
117109: LD_INT 7
117111: PUSH
117112: LD_INT 11
117114: PUSH
117115: LD_INT 12
117117: PUSH
117118: LD_INT 15
117120: PUSH
117121: LD_INT 16
117123: PUSH
117124: LD_INT 20
117126: PUSH
117127: LD_INT 21
117129: PUSH
117130: LD_INT 22
117132: PUSH
117133: LD_INT 23
117135: PUSH
117136: LD_INT 25
117138: PUSH
117139: LD_INT 26
117141: PUSH
117142: LD_INT 30
117144: PUSH
117145: LD_INT 31
117147: PUSH
117148: LD_INT 32
117150: PUSH
117151: LD_INT 33
117153: PUSH
117154: LD_INT 34
117156: PUSH
117157: LD_INT 35
117159: PUSH
117160: LD_INT 36
117162: PUSH
117163: EMPTY
117164: LIST
117165: LIST
117166: LIST
117167: LIST
117168: LIST
117169: LIST
117170: LIST
117171: LIST
117172: LIST
117173: LIST
117174: LIST
117175: LIST
117176: LIST
117177: LIST
117178: LIST
117179: LIST
117180: LIST
117181: LIST
117182: LIST
117183: LIST
117184: LIST
117185: PUSH
117186: LD_INT 101
117188: PUSH
117189: LD_INT 102
117191: PUSH
117192: LD_INT 103
117194: PUSH
117195: LD_INT 106
117197: PUSH
117198: LD_INT 108
117200: PUSH
117201: LD_INT 112
117203: PUSH
117204: LD_INT 113
117206: PUSH
117207: LD_INT 114
117209: PUSH
117210: LD_INT 115
117212: PUSH
117213: LD_INT 116
117215: PUSH
117216: LD_INT 117
117218: PUSH
117219: LD_INT 118
117221: PUSH
117222: EMPTY
117223: LIST
117224: LIST
117225: LIST
117226: LIST
117227: LIST
117228: LIST
117229: LIST
117230: LIST
117231: LIST
117232: LIST
117233: LIST
117234: LIST
117235: PUSH
117236: EMPTY
117237: LIST
117238: LIST
117239: ST_TO_ADDR
117240: GO 117483
117242: LD_INT 19
117244: DOUBLE
117245: EQUAL
117246: IFTRUE 117250
117248: GO 117482
117250: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
117251: LD_ADDR_VAR 0 2
117255: PUSH
117256: LD_INT 1
117258: PUSH
117259: LD_INT 2
117261: PUSH
117262: LD_INT 3
117264: PUSH
117265: LD_INT 4
117267: PUSH
117268: LD_INT 5
117270: PUSH
117271: LD_INT 6
117273: PUSH
117274: LD_INT 7
117276: PUSH
117277: LD_INT 8
117279: PUSH
117280: LD_INT 9
117282: PUSH
117283: LD_INT 10
117285: PUSH
117286: LD_INT 11
117288: PUSH
117289: LD_INT 12
117291: PUSH
117292: LD_INT 13
117294: PUSH
117295: LD_INT 14
117297: PUSH
117298: LD_INT 15
117300: PUSH
117301: LD_INT 16
117303: PUSH
117304: LD_INT 17
117306: PUSH
117307: LD_INT 18
117309: PUSH
117310: LD_INT 19
117312: PUSH
117313: LD_INT 20
117315: PUSH
117316: LD_INT 21
117318: PUSH
117319: LD_INT 22
117321: PUSH
117322: LD_INT 23
117324: PUSH
117325: LD_INT 24
117327: PUSH
117328: LD_INT 25
117330: PUSH
117331: LD_INT 26
117333: PUSH
117334: LD_INT 27
117336: PUSH
117337: LD_INT 28
117339: PUSH
117340: LD_INT 29
117342: PUSH
117343: LD_INT 30
117345: PUSH
117346: LD_INT 31
117348: PUSH
117349: LD_INT 32
117351: PUSH
117352: LD_INT 33
117354: PUSH
117355: LD_INT 34
117357: PUSH
117358: LD_INT 35
117360: PUSH
117361: LD_INT 36
117363: PUSH
117364: EMPTY
117365: LIST
117366: LIST
117367: LIST
117368: LIST
117369: LIST
117370: LIST
117371: LIST
117372: LIST
117373: LIST
117374: LIST
117375: LIST
117376: LIST
117377: LIST
117378: LIST
117379: LIST
117380: LIST
117381: LIST
117382: LIST
117383: LIST
117384: LIST
117385: LIST
117386: LIST
117387: LIST
117388: LIST
117389: LIST
117390: LIST
117391: LIST
117392: LIST
117393: LIST
117394: LIST
117395: LIST
117396: LIST
117397: LIST
117398: LIST
117399: LIST
117400: LIST
117401: PUSH
117402: LD_INT 101
117404: PUSH
117405: LD_INT 102
117407: PUSH
117408: LD_INT 103
117410: PUSH
117411: LD_INT 104
117413: PUSH
117414: LD_INT 105
117416: PUSH
117417: LD_INT 106
117419: PUSH
117420: LD_INT 107
117422: PUSH
117423: LD_INT 108
117425: PUSH
117426: LD_INT 109
117428: PUSH
117429: LD_INT 110
117431: PUSH
117432: LD_INT 111
117434: PUSH
117435: LD_INT 112
117437: PUSH
117438: LD_INT 113
117440: PUSH
117441: LD_INT 114
117443: PUSH
117444: LD_INT 115
117446: PUSH
117447: LD_INT 116
117449: PUSH
117450: LD_INT 117
117452: PUSH
117453: LD_INT 118
117455: PUSH
117456: EMPTY
117457: LIST
117458: LIST
117459: LIST
117460: LIST
117461: LIST
117462: LIST
117463: LIST
117464: LIST
117465: LIST
117466: LIST
117467: LIST
117468: LIST
117469: LIST
117470: LIST
117471: LIST
117472: LIST
117473: LIST
117474: LIST
117475: PUSH
117476: EMPTY
117477: LIST
117478: LIST
117479: ST_TO_ADDR
117480: GO 117483
117482: POP
// end else
117483: GO 117714
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
117485: LD_ADDR_VAR 0 2
117489: PUSH
117490: LD_INT 1
117492: PUSH
117493: LD_INT 2
117495: PUSH
117496: LD_INT 3
117498: PUSH
117499: LD_INT 4
117501: PUSH
117502: LD_INT 5
117504: PUSH
117505: LD_INT 6
117507: PUSH
117508: LD_INT 7
117510: PUSH
117511: LD_INT 8
117513: PUSH
117514: LD_INT 9
117516: PUSH
117517: LD_INT 10
117519: PUSH
117520: LD_INT 11
117522: PUSH
117523: LD_INT 12
117525: PUSH
117526: LD_INT 13
117528: PUSH
117529: LD_INT 14
117531: PUSH
117532: LD_INT 15
117534: PUSH
117535: LD_INT 16
117537: PUSH
117538: LD_INT 17
117540: PUSH
117541: LD_INT 18
117543: PUSH
117544: LD_INT 19
117546: PUSH
117547: LD_INT 20
117549: PUSH
117550: LD_INT 21
117552: PUSH
117553: LD_INT 22
117555: PUSH
117556: LD_INT 23
117558: PUSH
117559: LD_INT 24
117561: PUSH
117562: LD_INT 25
117564: PUSH
117565: LD_INT 26
117567: PUSH
117568: LD_INT 27
117570: PUSH
117571: LD_INT 28
117573: PUSH
117574: LD_INT 29
117576: PUSH
117577: LD_INT 30
117579: PUSH
117580: LD_INT 31
117582: PUSH
117583: LD_INT 32
117585: PUSH
117586: LD_INT 33
117588: PUSH
117589: LD_INT 34
117591: PUSH
117592: LD_INT 35
117594: PUSH
117595: LD_INT 36
117597: PUSH
117598: EMPTY
117599: LIST
117600: LIST
117601: LIST
117602: LIST
117603: LIST
117604: LIST
117605: LIST
117606: LIST
117607: LIST
117608: LIST
117609: LIST
117610: LIST
117611: LIST
117612: LIST
117613: LIST
117614: LIST
117615: LIST
117616: LIST
117617: LIST
117618: LIST
117619: LIST
117620: LIST
117621: LIST
117622: LIST
117623: LIST
117624: LIST
117625: LIST
117626: LIST
117627: LIST
117628: LIST
117629: LIST
117630: LIST
117631: LIST
117632: LIST
117633: LIST
117634: LIST
117635: PUSH
117636: LD_INT 101
117638: PUSH
117639: LD_INT 102
117641: PUSH
117642: LD_INT 103
117644: PUSH
117645: LD_INT 104
117647: PUSH
117648: LD_INT 105
117650: PUSH
117651: LD_INT 106
117653: PUSH
117654: LD_INT 107
117656: PUSH
117657: LD_INT 108
117659: PUSH
117660: LD_INT 109
117662: PUSH
117663: LD_INT 110
117665: PUSH
117666: LD_INT 111
117668: PUSH
117669: LD_INT 112
117671: PUSH
117672: LD_INT 113
117674: PUSH
117675: LD_INT 114
117677: PUSH
117678: LD_INT 115
117680: PUSH
117681: LD_INT 116
117683: PUSH
117684: LD_INT 117
117686: PUSH
117687: LD_INT 118
117689: PUSH
117690: EMPTY
117691: LIST
117692: LIST
117693: LIST
117694: LIST
117695: LIST
117696: LIST
117697: LIST
117698: LIST
117699: LIST
117700: LIST
117701: LIST
117702: LIST
117703: LIST
117704: LIST
117705: LIST
117706: LIST
117707: LIST
117708: LIST
117709: PUSH
117710: EMPTY
117711: LIST
117712: LIST
117713: ST_TO_ADDR
// if result then
117714: LD_VAR 0 2
117718: IFFALSE 118504
// begin normal :=  ;
117720: LD_ADDR_VAR 0 5
117724: PUSH
117725: LD_STRING 
117727: ST_TO_ADDR
// hardcore :=  ;
117728: LD_ADDR_VAR 0 6
117732: PUSH
117733: LD_STRING 
117735: ST_TO_ADDR
// active :=  ;
117736: LD_ADDR_VAR 0 7
117740: PUSH
117741: LD_STRING 
117743: ST_TO_ADDR
// for i = 1 to normalCounter do
117744: LD_ADDR_VAR 0 8
117748: PUSH
117749: DOUBLE
117750: LD_INT 1
117752: DEC
117753: ST_TO_ADDR
117754: LD_EXP 149
117758: PUSH
117759: FOR_TO
117760: IFFALSE 117861
// begin tmp := 0 ;
117762: LD_ADDR_VAR 0 3
117766: PUSH
117767: LD_STRING 0
117769: ST_TO_ADDR
// if result [ 1 ] then
117770: LD_VAR 0 2
117774: PUSH
117775: LD_INT 1
117777: ARRAY
117778: IFFALSE 117843
// if result [ 1 ] [ 1 ] = i then
117780: LD_VAR 0 2
117784: PUSH
117785: LD_INT 1
117787: ARRAY
117788: PUSH
117789: LD_INT 1
117791: ARRAY
117792: PUSH
117793: LD_VAR 0 8
117797: EQUAL
117798: IFFALSE 117843
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
117800: LD_ADDR_VAR 0 2
117804: PUSH
117805: LD_VAR 0 2
117809: PPUSH
117810: LD_INT 1
117812: PPUSH
117813: LD_VAR 0 2
117817: PUSH
117818: LD_INT 1
117820: ARRAY
117821: PPUSH
117822: LD_INT 1
117824: PPUSH
117825: CALL_OW 3
117829: PPUSH
117830: CALL_OW 1
117834: ST_TO_ADDR
// tmp := 1 ;
117835: LD_ADDR_VAR 0 3
117839: PUSH
117840: LD_STRING 1
117842: ST_TO_ADDR
// end ; normal := normal & tmp ;
117843: LD_ADDR_VAR 0 5
117847: PUSH
117848: LD_VAR 0 5
117852: PUSH
117853: LD_VAR 0 3
117857: STR
117858: ST_TO_ADDR
// end ;
117859: GO 117759
117861: POP
117862: POP
// for i = 1 to hardcoreCounter do
117863: LD_ADDR_VAR 0 8
117867: PUSH
117868: DOUBLE
117869: LD_INT 1
117871: DEC
117872: ST_TO_ADDR
117873: LD_EXP 150
117877: PUSH
117878: FOR_TO
117879: IFFALSE 117984
// begin tmp := 0 ;
117881: LD_ADDR_VAR 0 3
117885: PUSH
117886: LD_STRING 0
117888: ST_TO_ADDR
// if result [ 2 ] then
117889: LD_VAR 0 2
117893: PUSH
117894: LD_INT 2
117896: ARRAY
117897: IFFALSE 117966
// if result [ 2 ] [ 1 ] = 100 + i then
117899: LD_VAR 0 2
117903: PUSH
117904: LD_INT 2
117906: ARRAY
117907: PUSH
117908: LD_INT 1
117910: ARRAY
117911: PUSH
117912: LD_INT 100
117914: PUSH
117915: LD_VAR 0 8
117919: PLUS
117920: EQUAL
117921: IFFALSE 117966
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
117923: LD_ADDR_VAR 0 2
117927: PUSH
117928: LD_VAR 0 2
117932: PPUSH
117933: LD_INT 2
117935: PPUSH
117936: LD_VAR 0 2
117940: PUSH
117941: LD_INT 2
117943: ARRAY
117944: PPUSH
117945: LD_INT 1
117947: PPUSH
117948: CALL_OW 3
117952: PPUSH
117953: CALL_OW 1
117957: ST_TO_ADDR
// tmp := 1 ;
117958: LD_ADDR_VAR 0 3
117962: PUSH
117963: LD_STRING 1
117965: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
117966: LD_ADDR_VAR 0 6
117970: PUSH
117971: LD_VAR 0 6
117975: PUSH
117976: LD_VAR 0 3
117980: STR
117981: ST_TO_ADDR
// end ;
117982: GO 117878
117984: POP
117985: POP
// if isGameLoad then
117986: LD_VAR 0 1
117990: IFFALSE 118465
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
117992: LD_ADDR_VAR 0 4
117996: PUSH
117997: LD_EXP 153
118001: PUSH
118002: LD_EXP 152
118006: PUSH
118007: LD_EXP 154
118011: PUSH
118012: LD_EXP 151
118016: PUSH
118017: LD_EXP 155
118021: PUSH
118022: LD_EXP 156
118026: PUSH
118027: LD_EXP 157
118031: PUSH
118032: LD_EXP 158
118036: PUSH
118037: LD_EXP 159
118041: PUSH
118042: LD_EXP 160
118046: PUSH
118047: LD_EXP 161
118051: PUSH
118052: LD_EXP 162
118056: PUSH
118057: LD_EXP 163
118061: PUSH
118062: LD_EXP 164
118066: PUSH
118067: LD_EXP 172
118071: PUSH
118072: LD_EXP 173
118076: PUSH
118077: LD_EXP 174
118081: PUSH
118082: LD_EXP 175
118086: PUSH
118087: LD_EXP 177
118091: PUSH
118092: LD_EXP 178
118096: PUSH
118097: LD_EXP 179
118101: PUSH
118102: LD_EXP 182
118106: PUSH
118107: LD_EXP 184
118111: PUSH
118112: LD_EXP 185
118116: PUSH
118117: LD_EXP 186
118121: PUSH
118122: LD_EXP 188
118126: PUSH
118127: LD_EXP 189
118131: PUSH
118132: LD_EXP 192
118136: PUSH
118137: LD_EXP 193
118141: PUSH
118142: LD_EXP 194
118146: PUSH
118147: LD_EXP 195
118151: PUSH
118152: LD_EXP 196
118156: PUSH
118157: LD_EXP 197
118161: PUSH
118162: LD_EXP 198
118166: PUSH
118167: LD_EXP 199
118171: PUSH
118172: LD_EXP 200
118176: PUSH
118177: LD_EXP 165
118181: PUSH
118182: LD_EXP 166
118186: PUSH
118187: LD_EXP 169
118191: PUSH
118192: LD_EXP 170
118196: PUSH
118197: LD_EXP 171
118201: PUSH
118202: LD_EXP 167
118206: PUSH
118207: LD_EXP 168
118211: PUSH
118212: LD_EXP 176
118216: PUSH
118217: LD_EXP 180
118221: PUSH
118222: LD_EXP 181
118226: PUSH
118227: LD_EXP 183
118231: PUSH
118232: LD_EXP 187
118236: PUSH
118237: LD_EXP 190
118241: PUSH
118242: LD_EXP 191
118246: PUSH
118247: LD_EXP 201
118251: PUSH
118252: LD_EXP 202
118256: PUSH
118257: LD_EXP 203
118261: PUSH
118262: LD_EXP 204
118266: PUSH
118267: EMPTY
118268: LIST
118269: LIST
118270: LIST
118271: LIST
118272: LIST
118273: LIST
118274: LIST
118275: LIST
118276: LIST
118277: LIST
118278: LIST
118279: LIST
118280: LIST
118281: LIST
118282: LIST
118283: LIST
118284: LIST
118285: LIST
118286: LIST
118287: LIST
118288: LIST
118289: LIST
118290: LIST
118291: LIST
118292: LIST
118293: LIST
118294: LIST
118295: LIST
118296: LIST
118297: LIST
118298: LIST
118299: LIST
118300: LIST
118301: LIST
118302: LIST
118303: LIST
118304: LIST
118305: LIST
118306: LIST
118307: LIST
118308: LIST
118309: LIST
118310: LIST
118311: LIST
118312: LIST
118313: LIST
118314: LIST
118315: LIST
118316: LIST
118317: LIST
118318: LIST
118319: LIST
118320: LIST
118321: LIST
118322: ST_TO_ADDR
// tmp :=  ;
118323: LD_ADDR_VAR 0 3
118327: PUSH
118328: LD_STRING 
118330: ST_TO_ADDR
// for i = 1 to normalCounter do
118331: LD_ADDR_VAR 0 8
118335: PUSH
118336: DOUBLE
118337: LD_INT 1
118339: DEC
118340: ST_TO_ADDR
118341: LD_EXP 149
118345: PUSH
118346: FOR_TO
118347: IFFALSE 118383
// begin if flags [ i ] then
118349: LD_VAR 0 4
118353: PUSH
118354: LD_VAR 0 8
118358: ARRAY
118359: IFFALSE 118381
// tmp := tmp & i & ; ;
118361: LD_ADDR_VAR 0 3
118365: PUSH
118366: LD_VAR 0 3
118370: PUSH
118371: LD_VAR 0 8
118375: STR
118376: PUSH
118377: LD_STRING ;
118379: STR
118380: ST_TO_ADDR
// end ;
118381: GO 118346
118383: POP
118384: POP
// for i = 1 to hardcoreCounter do
118385: LD_ADDR_VAR 0 8
118389: PUSH
118390: DOUBLE
118391: LD_INT 1
118393: DEC
118394: ST_TO_ADDR
118395: LD_EXP 150
118399: PUSH
118400: FOR_TO
118401: IFFALSE 118447
// begin if flags [ normalCounter + i ] then
118403: LD_VAR 0 4
118407: PUSH
118408: LD_EXP 149
118412: PUSH
118413: LD_VAR 0 8
118417: PLUS
118418: ARRAY
118419: IFFALSE 118445
// tmp := tmp & ( 100 + i ) & ; ;
118421: LD_ADDR_VAR 0 3
118425: PUSH
118426: LD_VAR 0 3
118430: PUSH
118431: LD_INT 100
118433: PUSH
118434: LD_VAR 0 8
118438: PLUS
118439: STR
118440: PUSH
118441: LD_STRING ;
118443: STR
118444: ST_TO_ADDR
// end ;
118445: GO 118400
118447: POP
118448: POP
// if tmp then
118449: LD_VAR 0 3
118453: IFFALSE 118465
// active := tmp ;
118455: LD_ADDR_VAR 0 7
118459: PUSH
118460: LD_VAR 0 3
118464: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
118465: LD_STRING getStreamItemsFromMission("
118467: PUSH
118468: LD_VAR 0 5
118472: STR
118473: PUSH
118474: LD_STRING ","
118476: STR
118477: PUSH
118478: LD_VAR 0 6
118482: STR
118483: PUSH
118484: LD_STRING ","
118486: STR
118487: PUSH
118488: LD_VAR 0 7
118492: STR
118493: PUSH
118494: LD_STRING ")
118496: STR
118497: PPUSH
118498: CALL_OW 559
// end else
118502: GO 118511
// ToLua ( getStreamItemsFromMission("","","") ) ;
118504: LD_STRING getStreamItemsFromMission("","","")
118506: PPUSH
118507: CALL_OW 559
// end ;
118511: LD_VAR 0 2
118515: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
118516: LD_EXP 148
118520: PUSH
118521: LD_EXP 153
118525: AND
118526: IFFALSE 118650
118528: GO 118530
118530: DISABLE
118531: LD_INT 0
118533: PPUSH
118534: PPUSH
// begin enable ;
118535: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
118536: LD_ADDR_VAR 0 2
118540: PUSH
118541: LD_INT 22
118543: PUSH
118544: LD_OWVAR 2
118548: PUSH
118549: EMPTY
118550: LIST
118551: LIST
118552: PUSH
118553: LD_INT 2
118555: PUSH
118556: LD_INT 34
118558: PUSH
118559: LD_INT 7
118561: PUSH
118562: EMPTY
118563: LIST
118564: LIST
118565: PUSH
118566: LD_INT 34
118568: PUSH
118569: LD_INT 45
118571: PUSH
118572: EMPTY
118573: LIST
118574: LIST
118575: PUSH
118576: LD_INT 34
118578: PUSH
118579: LD_INT 28
118581: PUSH
118582: EMPTY
118583: LIST
118584: LIST
118585: PUSH
118586: LD_INT 34
118588: PUSH
118589: LD_INT 47
118591: PUSH
118592: EMPTY
118593: LIST
118594: LIST
118595: PUSH
118596: EMPTY
118597: LIST
118598: LIST
118599: LIST
118600: LIST
118601: LIST
118602: PUSH
118603: EMPTY
118604: LIST
118605: LIST
118606: PPUSH
118607: CALL_OW 69
118611: ST_TO_ADDR
// if not tmp then
118612: LD_VAR 0 2
118616: NOT
118617: IFFALSE 118621
// exit ;
118619: GO 118650
// for i in tmp do
118621: LD_ADDR_VAR 0 1
118625: PUSH
118626: LD_VAR 0 2
118630: PUSH
118631: FOR_IN
118632: IFFALSE 118648
// begin SetLives ( i , 0 ) ;
118634: LD_VAR 0 1
118638: PPUSH
118639: LD_INT 0
118641: PPUSH
118642: CALL_OW 234
// end ;
118646: GO 118631
118648: POP
118649: POP
// end ;
118650: PPOPN 2
118652: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
118653: LD_EXP 148
118657: PUSH
118658: LD_EXP 154
118662: AND
118663: IFFALSE 118747
118665: GO 118667
118667: DISABLE
118668: LD_INT 0
118670: PPUSH
118671: PPUSH
// begin enable ;
118672: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
118673: LD_ADDR_VAR 0 2
118677: PUSH
118678: LD_INT 22
118680: PUSH
118681: LD_OWVAR 2
118685: PUSH
118686: EMPTY
118687: LIST
118688: LIST
118689: PUSH
118690: LD_INT 32
118692: PUSH
118693: LD_INT 3
118695: PUSH
118696: EMPTY
118697: LIST
118698: LIST
118699: PUSH
118700: EMPTY
118701: LIST
118702: LIST
118703: PPUSH
118704: CALL_OW 69
118708: ST_TO_ADDR
// if not tmp then
118709: LD_VAR 0 2
118713: NOT
118714: IFFALSE 118718
// exit ;
118716: GO 118747
// for i in tmp do
118718: LD_ADDR_VAR 0 1
118722: PUSH
118723: LD_VAR 0 2
118727: PUSH
118728: FOR_IN
118729: IFFALSE 118745
// begin SetLives ( i , 0 ) ;
118731: LD_VAR 0 1
118735: PPUSH
118736: LD_INT 0
118738: PPUSH
118739: CALL_OW 234
// end ;
118743: GO 118728
118745: POP
118746: POP
// end ;
118747: PPOPN 2
118749: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
118750: LD_EXP 148
118754: PUSH
118755: LD_EXP 151
118759: AND
118760: IFFALSE 118853
118762: GO 118764
118764: DISABLE
118765: LD_INT 0
118767: PPUSH
// begin enable ;
118768: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
118769: LD_ADDR_VAR 0 1
118773: PUSH
118774: LD_INT 22
118776: PUSH
118777: LD_OWVAR 2
118781: PUSH
118782: EMPTY
118783: LIST
118784: LIST
118785: PUSH
118786: LD_INT 2
118788: PUSH
118789: LD_INT 25
118791: PUSH
118792: LD_INT 5
118794: PUSH
118795: EMPTY
118796: LIST
118797: LIST
118798: PUSH
118799: LD_INT 25
118801: PUSH
118802: LD_INT 9
118804: PUSH
118805: EMPTY
118806: LIST
118807: LIST
118808: PUSH
118809: LD_INT 25
118811: PUSH
118812: LD_INT 8
118814: PUSH
118815: EMPTY
118816: LIST
118817: LIST
118818: PUSH
118819: EMPTY
118820: LIST
118821: LIST
118822: LIST
118823: LIST
118824: PUSH
118825: EMPTY
118826: LIST
118827: LIST
118828: PPUSH
118829: CALL_OW 69
118833: PUSH
118834: FOR_IN
118835: IFFALSE 118851
// begin SetClass ( i , 1 ) ;
118837: LD_VAR 0 1
118841: PPUSH
118842: LD_INT 1
118844: PPUSH
118845: CALL_OW 336
// end ;
118849: GO 118834
118851: POP
118852: POP
// end ;
118853: PPOPN 1
118855: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
118856: LD_EXP 148
118860: PUSH
118861: LD_EXP 152
118865: AND
118866: PUSH
118867: LD_OWVAR 65
118871: PUSH
118872: LD_INT 7
118874: LESS
118875: AND
118876: IFFALSE 118890
118878: GO 118880
118880: DISABLE
// begin enable ;
118881: ENABLE
// game_speed := 7 ;
118882: LD_ADDR_OWVAR 65
118886: PUSH
118887: LD_INT 7
118889: ST_TO_ADDR
// end ;
118890: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
118891: LD_EXP 148
118895: PUSH
118896: LD_EXP 155
118900: AND
118901: IFFALSE 119103
118903: GO 118905
118905: DISABLE
118906: LD_INT 0
118908: PPUSH
118909: PPUSH
118910: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
118911: LD_ADDR_VAR 0 3
118915: PUSH
118916: LD_INT 81
118918: PUSH
118919: LD_OWVAR 2
118923: PUSH
118924: EMPTY
118925: LIST
118926: LIST
118927: PUSH
118928: LD_INT 21
118930: PUSH
118931: LD_INT 1
118933: PUSH
118934: EMPTY
118935: LIST
118936: LIST
118937: PUSH
118938: EMPTY
118939: LIST
118940: LIST
118941: PPUSH
118942: CALL_OW 69
118946: ST_TO_ADDR
// if not tmp then
118947: LD_VAR 0 3
118951: NOT
118952: IFFALSE 118956
// exit ;
118954: GO 119103
// if tmp > 5 then
118956: LD_VAR 0 3
118960: PUSH
118961: LD_INT 5
118963: GREATER
118964: IFFALSE 118976
// k := 5 else
118966: LD_ADDR_VAR 0 2
118970: PUSH
118971: LD_INT 5
118973: ST_TO_ADDR
118974: GO 118986
// k := tmp ;
118976: LD_ADDR_VAR 0 2
118980: PUSH
118981: LD_VAR 0 3
118985: ST_TO_ADDR
// for i := 1 to k do
118986: LD_ADDR_VAR 0 1
118990: PUSH
118991: DOUBLE
118992: LD_INT 1
118994: DEC
118995: ST_TO_ADDR
118996: LD_VAR 0 2
119000: PUSH
119001: FOR_TO
119002: IFFALSE 119101
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
119004: LD_VAR 0 3
119008: PUSH
119009: LD_VAR 0 1
119013: ARRAY
119014: PPUSH
119015: LD_VAR 0 1
119019: PUSH
119020: LD_INT 4
119022: MOD
119023: PUSH
119024: LD_INT 1
119026: PLUS
119027: PPUSH
119028: CALL_OW 259
119032: PUSH
119033: LD_INT 10
119035: LESS
119036: IFFALSE 119099
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
119038: LD_VAR 0 3
119042: PUSH
119043: LD_VAR 0 1
119047: ARRAY
119048: PPUSH
119049: LD_VAR 0 1
119053: PUSH
119054: LD_INT 4
119056: MOD
119057: PUSH
119058: LD_INT 1
119060: PLUS
119061: PPUSH
119062: LD_VAR 0 3
119066: PUSH
119067: LD_VAR 0 1
119071: ARRAY
119072: PPUSH
119073: LD_VAR 0 1
119077: PUSH
119078: LD_INT 4
119080: MOD
119081: PUSH
119082: LD_INT 1
119084: PLUS
119085: PPUSH
119086: CALL_OW 259
119090: PUSH
119091: LD_INT 1
119093: PLUS
119094: PPUSH
119095: CALL_OW 237
119099: GO 119001
119101: POP
119102: POP
// end ;
119103: PPOPN 3
119105: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
119106: LD_EXP 148
119110: PUSH
119111: LD_EXP 156
119115: AND
119116: IFFALSE 119136
119118: GO 119120
119120: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
119121: LD_INT 4
119123: PPUSH
119124: LD_OWVAR 2
119128: PPUSH
119129: LD_INT 0
119131: PPUSH
119132: CALL_OW 324
119136: END
// every 0 0$1 trigger StreamModeActive and sShovel do
119137: LD_EXP 148
119141: PUSH
119142: LD_EXP 185
119146: AND
119147: IFFALSE 119167
119149: GO 119151
119151: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
119152: LD_INT 19
119154: PPUSH
119155: LD_OWVAR 2
119159: PPUSH
119160: LD_INT 0
119162: PPUSH
119163: CALL_OW 324
119167: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
119168: LD_EXP 148
119172: PUSH
119173: LD_EXP 157
119177: AND
119178: IFFALSE 119280
119180: GO 119182
119182: DISABLE
119183: LD_INT 0
119185: PPUSH
119186: PPUSH
// begin enable ;
119187: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
119188: LD_ADDR_VAR 0 2
119192: PUSH
119193: LD_INT 22
119195: PUSH
119196: LD_OWVAR 2
119200: PUSH
119201: EMPTY
119202: LIST
119203: LIST
119204: PUSH
119205: LD_INT 2
119207: PUSH
119208: LD_INT 34
119210: PUSH
119211: LD_INT 11
119213: PUSH
119214: EMPTY
119215: LIST
119216: LIST
119217: PUSH
119218: LD_INT 34
119220: PUSH
119221: LD_INT 30
119223: PUSH
119224: EMPTY
119225: LIST
119226: LIST
119227: PUSH
119228: EMPTY
119229: LIST
119230: LIST
119231: LIST
119232: PUSH
119233: EMPTY
119234: LIST
119235: LIST
119236: PPUSH
119237: CALL_OW 69
119241: ST_TO_ADDR
// if not tmp then
119242: LD_VAR 0 2
119246: NOT
119247: IFFALSE 119251
// exit ;
119249: GO 119280
// for i in tmp do
119251: LD_ADDR_VAR 0 1
119255: PUSH
119256: LD_VAR 0 2
119260: PUSH
119261: FOR_IN
119262: IFFALSE 119278
// begin SetLives ( i , 0 ) ;
119264: LD_VAR 0 1
119268: PPUSH
119269: LD_INT 0
119271: PPUSH
119272: CALL_OW 234
// end ;
119276: GO 119261
119278: POP
119279: POP
// end ;
119280: PPOPN 2
119282: END
// every 0 0$1 trigger StreamModeActive and sBunker do
119283: LD_EXP 148
119287: PUSH
119288: LD_EXP 158
119292: AND
119293: IFFALSE 119313
119295: GO 119297
119297: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
119298: LD_INT 32
119300: PPUSH
119301: LD_OWVAR 2
119305: PPUSH
119306: LD_INT 0
119308: PPUSH
119309: CALL_OW 324
119313: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
119314: LD_EXP 148
119318: PUSH
119319: LD_EXP 159
119323: AND
119324: IFFALSE 119505
119326: GO 119328
119328: DISABLE
119329: LD_INT 0
119331: PPUSH
119332: PPUSH
119333: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
119334: LD_ADDR_VAR 0 2
119338: PUSH
119339: LD_INT 22
119341: PUSH
119342: LD_OWVAR 2
119346: PUSH
119347: EMPTY
119348: LIST
119349: LIST
119350: PUSH
119351: LD_INT 33
119353: PUSH
119354: LD_INT 3
119356: PUSH
119357: EMPTY
119358: LIST
119359: LIST
119360: PUSH
119361: EMPTY
119362: LIST
119363: LIST
119364: PPUSH
119365: CALL_OW 69
119369: ST_TO_ADDR
// if not tmp then
119370: LD_VAR 0 2
119374: NOT
119375: IFFALSE 119379
// exit ;
119377: GO 119505
// side := 0 ;
119379: LD_ADDR_VAR 0 3
119383: PUSH
119384: LD_INT 0
119386: ST_TO_ADDR
// for i := 1 to 8 do
119387: LD_ADDR_VAR 0 1
119391: PUSH
119392: DOUBLE
119393: LD_INT 1
119395: DEC
119396: ST_TO_ADDR
119397: LD_INT 8
119399: PUSH
119400: FOR_TO
119401: IFFALSE 119449
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
119403: LD_OWVAR 2
119407: PUSH
119408: LD_VAR 0 1
119412: NONEQUAL
119413: PUSH
119414: LD_OWVAR 2
119418: PPUSH
119419: LD_VAR 0 1
119423: PPUSH
119424: CALL_OW 81
119428: PUSH
119429: LD_INT 2
119431: EQUAL
119432: AND
119433: IFFALSE 119447
// begin side := i ;
119435: LD_ADDR_VAR 0 3
119439: PUSH
119440: LD_VAR 0 1
119444: ST_TO_ADDR
// break ;
119445: GO 119449
// end ;
119447: GO 119400
119449: POP
119450: POP
// if not side then
119451: LD_VAR 0 3
119455: NOT
119456: IFFALSE 119460
// exit ;
119458: GO 119505
// for i := 1 to tmp do
119460: LD_ADDR_VAR 0 1
119464: PUSH
119465: DOUBLE
119466: LD_INT 1
119468: DEC
119469: ST_TO_ADDR
119470: LD_VAR 0 2
119474: PUSH
119475: FOR_TO
119476: IFFALSE 119503
// if Prob ( 60 ) then
119478: LD_INT 60
119480: PPUSH
119481: CALL_OW 13
119485: IFFALSE 119501
// SetSide ( i , side ) ;
119487: LD_VAR 0 1
119491: PPUSH
119492: LD_VAR 0 3
119496: PPUSH
119497: CALL_OW 235
119501: GO 119475
119503: POP
119504: POP
// end ;
119505: PPOPN 3
119507: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
119508: LD_EXP 148
119512: PUSH
119513: LD_EXP 161
119517: AND
119518: IFFALSE 119637
119520: GO 119522
119522: DISABLE
119523: LD_INT 0
119525: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
119526: LD_ADDR_VAR 0 1
119530: PUSH
119531: LD_INT 22
119533: PUSH
119534: LD_OWVAR 2
119538: PUSH
119539: EMPTY
119540: LIST
119541: LIST
119542: PUSH
119543: LD_INT 21
119545: PUSH
119546: LD_INT 1
119548: PUSH
119549: EMPTY
119550: LIST
119551: LIST
119552: PUSH
119553: LD_INT 3
119555: PUSH
119556: LD_INT 23
119558: PUSH
119559: LD_INT 0
119561: PUSH
119562: EMPTY
119563: LIST
119564: LIST
119565: PUSH
119566: EMPTY
119567: LIST
119568: LIST
119569: PUSH
119570: EMPTY
119571: LIST
119572: LIST
119573: LIST
119574: PPUSH
119575: CALL_OW 69
119579: PUSH
119580: FOR_IN
119581: IFFALSE 119635
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
119583: LD_VAR 0 1
119587: PPUSH
119588: CALL_OW 257
119592: PUSH
119593: LD_INT 1
119595: PUSH
119596: LD_INT 2
119598: PUSH
119599: LD_INT 3
119601: PUSH
119602: LD_INT 4
119604: PUSH
119605: EMPTY
119606: LIST
119607: LIST
119608: LIST
119609: LIST
119610: IN
119611: IFFALSE 119633
// SetClass ( un , rand ( 1 , 4 ) ) ;
119613: LD_VAR 0 1
119617: PPUSH
119618: LD_INT 1
119620: PPUSH
119621: LD_INT 4
119623: PPUSH
119624: CALL_OW 12
119628: PPUSH
119629: CALL_OW 336
119633: GO 119580
119635: POP
119636: POP
// end ;
119637: PPOPN 1
119639: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
119640: LD_EXP 148
119644: PUSH
119645: LD_EXP 160
119649: AND
119650: IFFALSE 119729
119652: GO 119654
119654: DISABLE
119655: LD_INT 0
119657: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
119658: LD_ADDR_VAR 0 1
119662: PUSH
119663: LD_INT 22
119665: PUSH
119666: LD_OWVAR 2
119670: PUSH
119671: EMPTY
119672: LIST
119673: LIST
119674: PUSH
119675: LD_INT 21
119677: PUSH
119678: LD_INT 3
119680: PUSH
119681: EMPTY
119682: LIST
119683: LIST
119684: PUSH
119685: EMPTY
119686: LIST
119687: LIST
119688: PPUSH
119689: CALL_OW 69
119693: ST_TO_ADDR
// if not tmp then
119694: LD_VAR 0 1
119698: NOT
119699: IFFALSE 119703
// exit ;
119701: GO 119729
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
119703: LD_VAR 0 1
119707: PUSH
119708: LD_INT 1
119710: PPUSH
119711: LD_VAR 0 1
119715: PPUSH
119716: CALL_OW 12
119720: ARRAY
119721: PPUSH
119722: LD_INT 100
119724: PPUSH
119725: CALL_OW 234
// end ;
119729: PPOPN 1
119731: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
119732: LD_EXP 148
119736: PUSH
119737: LD_EXP 162
119741: AND
119742: IFFALSE 119840
119744: GO 119746
119746: DISABLE
119747: LD_INT 0
119749: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
119750: LD_ADDR_VAR 0 1
119754: PUSH
119755: LD_INT 22
119757: PUSH
119758: LD_OWVAR 2
119762: PUSH
119763: EMPTY
119764: LIST
119765: LIST
119766: PUSH
119767: LD_INT 21
119769: PUSH
119770: LD_INT 1
119772: PUSH
119773: EMPTY
119774: LIST
119775: LIST
119776: PUSH
119777: EMPTY
119778: LIST
119779: LIST
119780: PPUSH
119781: CALL_OW 69
119785: ST_TO_ADDR
// if not tmp then
119786: LD_VAR 0 1
119790: NOT
119791: IFFALSE 119795
// exit ;
119793: GO 119840
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
119795: LD_VAR 0 1
119799: PUSH
119800: LD_INT 1
119802: PPUSH
119803: LD_VAR 0 1
119807: PPUSH
119808: CALL_OW 12
119812: ARRAY
119813: PPUSH
119814: LD_INT 1
119816: PPUSH
119817: LD_INT 4
119819: PPUSH
119820: CALL_OW 12
119824: PPUSH
119825: LD_INT 3000
119827: PPUSH
119828: LD_INT 9000
119830: PPUSH
119831: CALL_OW 12
119835: PPUSH
119836: CALL_OW 492
// end ;
119840: PPOPN 1
119842: END
// every 0 0$1 trigger StreamModeActive and sDepot do
119843: LD_EXP 148
119847: PUSH
119848: LD_EXP 163
119852: AND
119853: IFFALSE 119873
119855: GO 119857
119857: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
119858: LD_INT 1
119860: PPUSH
119861: LD_OWVAR 2
119865: PPUSH
119866: LD_INT 0
119868: PPUSH
119869: CALL_OW 324
119873: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
119874: LD_EXP 148
119878: PUSH
119879: LD_EXP 164
119883: AND
119884: IFFALSE 119967
119886: GO 119888
119888: DISABLE
119889: LD_INT 0
119891: PPUSH
119892: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
119893: LD_ADDR_VAR 0 2
119897: PUSH
119898: LD_INT 22
119900: PUSH
119901: LD_OWVAR 2
119905: PUSH
119906: EMPTY
119907: LIST
119908: LIST
119909: PUSH
119910: LD_INT 21
119912: PUSH
119913: LD_INT 3
119915: PUSH
119916: EMPTY
119917: LIST
119918: LIST
119919: PUSH
119920: EMPTY
119921: LIST
119922: LIST
119923: PPUSH
119924: CALL_OW 69
119928: ST_TO_ADDR
// if not tmp then
119929: LD_VAR 0 2
119933: NOT
119934: IFFALSE 119938
// exit ;
119936: GO 119967
// for i in tmp do
119938: LD_ADDR_VAR 0 1
119942: PUSH
119943: LD_VAR 0 2
119947: PUSH
119948: FOR_IN
119949: IFFALSE 119965
// SetBLevel ( i , 10 ) ;
119951: LD_VAR 0 1
119955: PPUSH
119956: LD_INT 10
119958: PPUSH
119959: CALL_OW 241
119963: GO 119948
119965: POP
119966: POP
// end ;
119967: PPOPN 2
119969: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
119970: LD_EXP 148
119974: PUSH
119975: LD_EXP 165
119979: AND
119980: IFFALSE 120091
119982: GO 119984
119984: DISABLE
119985: LD_INT 0
119987: PPUSH
119988: PPUSH
119989: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
119990: LD_ADDR_VAR 0 3
119994: PUSH
119995: LD_INT 22
119997: PUSH
119998: LD_OWVAR 2
120002: PUSH
120003: EMPTY
120004: LIST
120005: LIST
120006: PUSH
120007: LD_INT 25
120009: PUSH
120010: LD_INT 1
120012: PUSH
120013: EMPTY
120014: LIST
120015: LIST
120016: PUSH
120017: EMPTY
120018: LIST
120019: LIST
120020: PPUSH
120021: CALL_OW 69
120025: ST_TO_ADDR
// if not tmp then
120026: LD_VAR 0 3
120030: NOT
120031: IFFALSE 120035
// exit ;
120033: GO 120091
// un := tmp [ rand ( 1 , tmp ) ] ;
120035: LD_ADDR_VAR 0 2
120039: PUSH
120040: LD_VAR 0 3
120044: PUSH
120045: LD_INT 1
120047: PPUSH
120048: LD_VAR 0 3
120052: PPUSH
120053: CALL_OW 12
120057: ARRAY
120058: ST_TO_ADDR
// if Crawls ( un ) then
120059: LD_VAR 0 2
120063: PPUSH
120064: CALL_OW 318
120068: IFFALSE 120079
// ComWalk ( un ) ;
120070: LD_VAR 0 2
120074: PPUSH
120075: CALL_OW 138
// SetClass ( un , class_sniper ) ;
120079: LD_VAR 0 2
120083: PPUSH
120084: LD_INT 5
120086: PPUSH
120087: CALL_OW 336
// end ;
120091: PPOPN 3
120093: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
120094: LD_EXP 148
120098: PUSH
120099: LD_EXP 166
120103: AND
120104: PUSH
120105: LD_OWVAR 67
120109: PUSH
120110: LD_INT 4
120112: LESS
120113: AND
120114: IFFALSE 120133
120116: GO 120118
120118: DISABLE
// begin Difficulty := Difficulty + 1 ;
120119: LD_ADDR_OWVAR 67
120123: PUSH
120124: LD_OWVAR 67
120128: PUSH
120129: LD_INT 1
120131: PLUS
120132: ST_TO_ADDR
// end ;
120133: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
120134: LD_EXP 148
120138: PUSH
120139: LD_EXP 167
120143: AND
120144: IFFALSE 120247
120146: GO 120148
120148: DISABLE
120149: LD_INT 0
120151: PPUSH
// begin for i := 1 to 5 do
120152: LD_ADDR_VAR 0 1
120156: PUSH
120157: DOUBLE
120158: LD_INT 1
120160: DEC
120161: ST_TO_ADDR
120162: LD_INT 5
120164: PUSH
120165: FOR_TO
120166: IFFALSE 120245
// begin uc_nation := nation_nature ;
120168: LD_ADDR_OWVAR 21
120172: PUSH
120173: LD_INT 0
120175: ST_TO_ADDR
// uc_side := 0 ;
120176: LD_ADDR_OWVAR 20
120180: PUSH
120181: LD_INT 0
120183: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
120184: LD_ADDR_OWVAR 29
120188: PUSH
120189: LD_INT 12
120191: PUSH
120192: LD_INT 12
120194: PUSH
120195: EMPTY
120196: LIST
120197: LIST
120198: ST_TO_ADDR
// hc_agressivity := 20 ;
120199: LD_ADDR_OWVAR 35
120203: PUSH
120204: LD_INT 20
120206: ST_TO_ADDR
// hc_class := class_tiger ;
120207: LD_ADDR_OWVAR 28
120211: PUSH
120212: LD_INT 14
120214: ST_TO_ADDR
// hc_gallery :=  ;
120215: LD_ADDR_OWVAR 33
120219: PUSH
120220: LD_STRING 
120222: ST_TO_ADDR
// hc_name :=  ;
120223: LD_ADDR_OWVAR 26
120227: PUSH
120228: LD_STRING 
120230: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
120231: CALL_OW 44
120235: PPUSH
120236: LD_INT 0
120238: PPUSH
120239: CALL_OW 51
// end ;
120243: GO 120165
120245: POP
120246: POP
// end ;
120247: PPOPN 1
120249: END
// every 0 0$1 trigger StreamModeActive and sBomb do
120250: LD_EXP 148
120254: PUSH
120255: LD_EXP 168
120259: AND
120260: IFFALSE 120269
120262: GO 120264
120264: DISABLE
// StreamSibBomb ;
120265: CALL 120270 0 0
120269: END
// export function StreamSibBomb ; var i , x , y ; begin
120270: LD_INT 0
120272: PPUSH
120273: PPUSH
120274: PPUSH
120275: PPUSH
// result := false ;
120276: LD_ADDR_VAR 0 1
120280: PUSH
120281: LD_INT 0
120283: ST_TO_ADDR
// for i := 1 to 16 do
120284: LD_ADDR_VAR 0 2
120288: PUSH
120289: DOUBLE
120290: LD_INT 1
120292: DEC
120293: ST_TO_ADDR
120294: LD_INT 16
120296: PUSH
120297: FOR_TO
120298: IFFALSE 120497
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
120300: LD_ADDR_VAR 0 3
120304: PUSH
120305: LD_INT 10
120307: PUSH
120308: LD_INT 20
120310: PUSH
120311: LD_INT 30
120313: PUSH
120314: LD_INT 40
120316: PUSH
120317: LD_INT 50
120319: PUSH
120320: LD_INT 60
120322: PUSH
120323: LD_INT 70
120325: PUSH
120326: LD_INT 80
120328: PUSH
120329: LD_INT 90
120331: PUSH
120332: LD_INT 100
120334: PUSH
120335: LD_INT 110
120337: PUSH
120338: LD_INT 120
120340: PUSH
120341: LD_INT 130
120343: PUSH
120344: LD_INT 140
120346: PUSH
120347: LD_INT 150
120349: PUSH
120350: EMPTY
120351: LIST
120352: LIST
120353: LIST
120354: LIST
120355: LIST
120356: LIST
120357: LIST
120358: LIST
120359: LIST
120360: LIST
120361: LIST
120362: LIST
120363: LIST
120364: LIST
120365: LIST
120366: PUSH
120367: LD_INT 1
120369: PPUSH
120370: LD_INT 15
120372: PPUSH
120373: CALL_OW 12
120377: ARRAY
120378: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
120379: LD_ADDR_VAR 0 4
120383: PUSH
120384: LD_INT 10
120386: PUSH
120387: LD_INT 20
120389: PUSH
120390: LD_INT 30
120392: PUSH
120393: LD_INT 40
120395: PUSH
120396: LD_INT 50
120398: PUSH
120399: LD_INT 60
120401: PUSH
120402: LD_INT 70
120404: PUSH
120405: LD_INT 80
120407: PUSH
120408: LD_INT 90
120410: PUSH
120411: LD_INT 100
120413: PUSH
120414: LD_INT 110
120416: PUSH
120417: LD_INT 120
120419: PUSH
120420: LD_INT 130
120422: PUSH
120423: LD_INT 140
120425: PUSH
120426: LD_INT 150
120428: PUSH
120429: EMPTY
120430: LIST
120431: LIST
120432: LIST
120433: LIST
120434: LIST
120435: LIST
120436: LIST
120437: LIST
120438: LIST
120439: LIST
120440: LIST
120441: LIST
120442: LIST
120443: LIST
120444: LIST
120445: PUSH
120446: LD_INT 1
120448: PPUSH
120449: LD_INT 15
120451: PPUSH
120452: CALL_OW 12
120456: ARRAY
120457: ST_TO_ADDR
// if ValidHex ( x , y ) then
120458: LD_VAR 0 3
120462: PPUSH
120463: LD_VAR 0 4
120467: PPUSH
120468: CALL_OW 488
120472: IFFALSE 120495
// begin result := [ x , y ] ;
120474: LD_ADDR_VAR 0 1
120478: PUSH
120479: LD_VAR 0 3
120483: PUSH
120484: LD_VAR 0 4
120488: PUSH
120489: EMPTY
120490: LIST
120491: LIST
120492: ST_TO_ADDR
// break ;
120493: GO 120497
// end ; end ;
120495: GO 120297
120497: POP
120498: POP
// if result then
120499: LD_VAR 0 1
120503: IFFALSE 120563
// begin ToLua ( playSibBomb() ) ;
120505: LD_STRING playSibBomb()
120507: PPUSH
120508: CALL_OW 559
// wait ( 0 0$14 ) ;
120512: LD_INT 490
120514: PPUSH
120515: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
120519: LD_VAR 0 1
120523: PUSH
120524: LD_INT 1
120526: ARRAY
120527: PPUSH
120528: LD_VAR 0 1
120532: PUSH
120533: LD_INT 2
120535: ARRAY
120536: PPUSH
120537: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
120541: LD_VAR 0 1
120545: PUSH
120546: LD_INT 1
120548: ARRAY
120549: PPUSH
120550: LD_VAR 0 1
120554: PUSH
120555: LD_INT 2
120557: ARRAY
120558: PPUSH
120559: CALL_OW 429
// end ; end ;
120563: LD_VAR 0 1
120567: RET
// every 0 0$1 trigger StreamModeActive and sReset do
120568: LD_EXP 148
120572: PUSH
120573: LD_EXP 170
120577: AND
120578: IFFALSE 120590
120580: GO 120582
120582: DISABLE
// YouLost (  ) ;
120583: LD_STRING 
120585: PPUSH
120586: CALL_OW 104
120590: END
// every 0 0$1 trigger StreamModeActive and sFog do
120591: LD_EXP 148
120595: PUSH
120596: LD_EXP 169
120600: AND
120601: IFFALSE 120615
120603: GO 120605
120605: DISABLE
// FogOff ( your_side ) ;
120606: LD_OWVAR 2
120610: PPUSH
120611: CALL_OW 344
120615: END
// every 0 0$1 trigger StreamModeActive and sSun do
120616: LD_EXP 148
120620: PUSH
120621: LD_EXP 171
120625: AND
120626: IFFALSE 120654
120628: GO 120630
120630: DISABLE
// begin solar_recharge_percent := 0 ;
120631: LD_ADDR_OWVAR 79
120635: PUSH
120636: LD_INT 0
120638: ST_TO_ADDR
// wait ( 5 5$00 ) ;
120639: LD_INT 10500
120641: PPUSH
120642: CALL_OW 67
// solar_recharge_percent := 100 ;
120646: LD_ADDR_OWVAR 79
120650: PUSH
120651: LD_INT 100
120653: ST_TO_ADDR
// end ;
120654: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
120655: LD_EXP 148
120659: PUSH
120660: LD_EXP 172
120664: AND
120665: IFFALSE 120904
120667: GO 120669
120669: DISABLE
120670: LD_INT 0
120672: PPUSH
120673: PPUSH
120674: PPUSH
// begin tmp := [ ] ;
120675: LD_ADDR_VAR 0 3
120679: PUSH
120680: EMPTY
120681: ST_TO_ADDR
// for i := 1 to 6 do
120682: LD_ADDR_VAR 0 1
120686: PUSH
120687: DOUBLE
120688: LD_INT 1
120690: DEC
120691: ST_TO_ADDR
120692: LD_INT 6
120694: PUSH
120695: FOR_TO
120696: IFFALSE 120801
// begin uc_nation := nation_nature ;
120698: LD_ADDR_OWVAR 21
120702: PUSH
120703: LD_INT 0
120705: ST_TO_ADDR
// uc_side := 0 ;
120706: LD_ADDR_OWVAR 20
120710: PUSH
120711: LD_INT 0
120713: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
120714: LD_ADDR_OWVAR 29
120718: PUSH
120719: LD_INT 12
120721: PUSH
120722: LD_INT 12
120724: PUSH
120725: EMPTY
120726: LIST
120727: LIST
120728: ST_TO_ADDR
// hc_agressivity := 20 ;
120729: LD_ADDR_OWVAR 35
120733: PUSH
120734: LD_INT 20
120736: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
120737: LD_ADDR_OWVAR 28
120741: PUSH
120742: LD_INT 17
120744: ST_TO_ADDR
// hc_gallery :=  ;
120745: LD_ADDR_OWVAR 33
120749: PUSH
120750: LD_STRING 
120752: ST_TO_ADDR
// hc_name :=  ;
120753: LD_ADDR_OWVAR 26
120757: PUSH
120758: LD_STRING 
120760: ST_TO_ADDR
// un := CreateHuman ;
120761: LD_ADDR_VAR 0 2
120765: PUSH
120766: CALL_OW 44
120770: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
120771: LD_VAR 0 2
120775: PPUSH
120776: LD_INT 1
120778: PPUSH
120779: CALL_OW 51
// tmp := tmp ^ un ;
120783: LD_ADDR_VAR 0 3
120787: PUSH
120788: LD_VAR 0 3
120792: PUSH
120793: LD_VAR 0 2
120797: ADD
120798: ST_TO_ADDR
// end ;
120799: GO 120695
120801: POP
120802: POP
// repeat wait ( 0 0$1 ) ;
120803: LD_INT 35
120805: PPUSH
120806: CALL_OW 67
// for un in tmp do
120810: LD_ADDR_VAR 0 2
120814: PUSH
120815: LD_VAR 0 3
120819: PUSH
120820: FOR_IN
120821: IFFALSE 120895
// begin if IsDead ( un ) then
120823: LD_VAR 0 2
120827: PPUSH
120828: CALL_OW 301
120832: IFFALSE 120852
// begin tmp := tmp diff un ;
120834: LD_ADDR_VAR 0 3
120838: PUSH
120839: LD_VAR 0 3
120843: PUSH
120844: LD_VAR 0 2
120848: DIFF
120849: ST_TO_ADDR
// continue ;
120850: GO 120820
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
120852: LD_VAR 0 2
120856: PPUSH
120857: LD_INT 3
120859: PUSH
120860: LD_INT 22
120862: PUSH
120863: LD_INT 0
120865: PUSH
120866: EMPTY
120867: LIST
120868: LIST
120869: PUSH
120870: EMPTY
120871: LIST
120872: LIST
120873: PPUSH
120874: CALL_OW 69
120878: PPUSH
120879: LD_VAR 0 2
120883: PPUSH
120884: CALL_OW 74
120888: PPUSH
120889: CALL_OW 115
// end ;
120893: GO 120820
120895: POP
120896: POP
// until not tmp ;
120897: LD_VAR 0 3
120901: NOT
120902: IFFALSE 120803
// end ;
120904: PPOPN 3
120906: END
// every 0 0$1 trigger StreamModeActive and sTroll do
120907: LD_EXP 148
120911: PUSH
120912: LD_EXP 173
120916: AND
120917: IFFALSE 120971
120919: GO 120921
120921: DISABLE
// begin ToLua ( displayTroll(); ) ;
120922: LD_STRING displayTroll();
120924: PPUSH
120925: CALL_OW 559
// wait ( 3 3$00 ) ;
120929: LD_INT 6300
120931: PPUSH
120932: CALL_OW 67
// ToLua ( hideTroll(); ) ;
120936: LD_STRING hideTroll();
120938: PPUSH
120939: CALL_OW 559
// wait ( 1 1$00 ) ;
120943: LD_INT 2100
120945: PPUSH
120946: CALL_OW 67
// ToLua ( displayTroll(); ) ;
120950: LD_STRING displayTroll();
120952: PPUSH
120953: CALL_OW 559
// wait ( 1 1$00 ) ;
120957: LD_INT 2100
120959: PPUSH
120960: CALL_OW 67
// ToLua ( hideTroll(); ) ;
120964: LD_STRING hideTroll();
120966: PPUSH
120967: CALL_OW 559
// end ;
120971: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
120972: LD_EXP 148
120976: PUSH
120977: LD_EXP 174
120981: AND
120982: IFFALSE 121045
120984: GO 120986
120986: DISABLE
120987: LD_INT 0
120989: PPUSH
// begin p := 0 ;
120990: LD_ADDR_VAR 0 1
120994: PUSH
120995: LD_INT 0
120997: ST_TO_ADDR
// repeat game_speed := 1 ;
120998: LD_ADDR_OWVAR 65
121002: PUSH
121003: LD_INT 1
121005: ST_TO_ADDR
// wait ( 0 0$1 ) ;
121006: LD_INT 35
121008: PPUSH
121009: CALL_OW 67
// p := p + 1 ;
121013: LD_ADDR_VAR 0 1
121017: PUSH
121018: LD_VAR 0 1
121022: PUSH
121023: LD_INT 1
121025: PLUS
121026: ST_TO_ADDR
// until p >= 60 ;
121027: LD_VAR 0 1
121031: PUSH
121032: LD_INT 60
121034: GREATEREQUAL
121035: IFFALSE 120998
// game_speed := 4 ;
121037: LD_ADDR_OWVAR 65
121041: PUSH
121042: LD_INT 4
121044: ST_TO_ADDR
// end ;
121045: PPOPN 1
121047: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
121048: LD_EXP 148
121052: PUSH
121053: LD_EXP 175
121057: AND
121058: IFFALSE 121204
121060: GO 121062
121062: DISABLE
121063: LD_INT 0
121065: PPUSH
121066: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
121067: LD_ADDR_VAR 0 1
121071: PUSH
121072: LD_INT 22
121074: PUSH
121075: LD_OWVAR 2
121079: PUSH
121080: EMPTY
121081: LIST
121082: LIST
121083: PUSH
121084: LD_INT 2
121086: PUSH
121087: LD_INT 30
121089: PUSH
121090: LD_INT 0
121092: PUSH
121093: EMPTY
121094: LIST
121095: LIST
121096: PUSH
121097: LD_INT 30
121099: PUSH
121100: LD_INT 1
121102: PUSH
121103: EMPTY
121104: LIST
121105: LIST
121106: PUSH
121107: EMPTY
121108: LIST
121109: LIST
121110: LIST
121111: PUSH
121112: EMPTY
121113: LIST
121114: LIST
121115: PPUSH
121116: CALL_OW 69
121120: ST_TO_ADDR
// if not depot then
121121: LD_VAR 0 1
121125: NOT
121126: IFFALSE 121130
// exit ;
121128: GO 121204
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
121130: LD_ADDR_VAR 0 2
121134: PUSH
121135: LD_VAR 0 1
121139: PUSH
121140: LD_INT 1
121142: PPUSH
121143: LD_VAR 0 1
121147: PPUSH
121148: CALL_OW 12
121152: ARRAY
121153: PPUSH
121154: CALL_OW 274
121158: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
121159: LD_VAR 0 2
121163: PPUSH
121164: LD_INT 1
121166: PPUSH
121167: LD_INT 0
121169: PPUSH
121170: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
121174: LD_VAR 0 2
121178: PPUSH
121179: LD_INT 2
121181: PPUSH
121182: LD_INT 0
121184: PPUSH
121185: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
121189: LD_VAR 0 2
121193: PPUSH
121194: LD_INT 3
121196: PPUSH
121197: LD_INT 0
121199: PPUSH
121200: CALL_OW 277
// end ;
121204: PPOPN 2
121206: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
121207: LD_EXP 148
121211: PUSH
121212: LD_EXP 176
121216: AND
121217: IFFALSE 121314
121219: GO 121221
121221: DISABLE
121222: LD_INT 0
121224: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
121225: LD_ADDR_VAR 0 1
121229: PUSH
121230: LD_INT 22
121232: PUSH
121233: LD_OWVAR 2
121237: PUSH
121238: EMPTY
121239: LIST
121240: LIST
121241: PUSH
121242: LD_INT 21
121244: PUSH
121245: LD_INT 1
121247: PUSH
121248: EMPTY
121249: LIST
121250: LIST
121251: PUSH
121252: LD_INT 3
121254: PUSH
121255: LD_INT 23
121257: PUSH
121258: LD_INT 0
121260: PUSH
121261: EMPTY
121262: LIST
121263: LIST
121264: PUSH
121265: EMPTY
121266: LIST
121267: LIST
121268: PUSH
121269: EMPTY
121270: LIST
121271: LIST
121272: LIST
121273: PPUSH
121274: CALL_OW 69
121278: ST_TO_ADDR
// if not tmp then
121279: LD_VAR 0 1
121283: NOT
121284: IFFALSE 121288
// exit ;
121286: GO 121314
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
121288: LD_VAR 0 1
121292: PUSH
121293: LD_INT 1
121295: PPUSH
121296: LD_VAR 0 1
121300: PPUSH
121301: CALL_OW 12
121305: ARRAY
121306: PPUSH
121307: LD_INT 200
121309: PPUSH
121310: CALL_OW 234
// end ;
121314: PPOPN 1
121316: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
121317: LD_EXP 148
121321: PUSH
121322: LD_EXP 177
121326: AND
121327: IFFALSE 121406
121329: GO 121331
121331: DISABLE
121332: LD_INT 0
121334: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
121335: LD_ADDR_VAR 0 1
121339: PUSH
121340: LD_INT 22
121342: PUSH
121343: LD_OWVAR 2
121347: PUSH
121348: EMPTY
121349: LIST
121350: LIST
121351: PUSH
121352: LD_INT 21
121354: PUSH
121355: LD_INT 2
121357: PUSH
121358: EMPTY
121359: LIST
121360: LIST
121361: PUSH
121362: EMPTY
121363: LIST
121364: LIST
121365: PPUSH
121366: CALL_OW 69
121370: ST_TO_ADDR
// if not tmp then
121371: LD_VAR 0 1
121375: NOT
121376: IFFALSE 121380
// exit ;
121378: GO 121406
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
121380: LD_VAR 0 1
121384: PUSH
121385: LD_INT 1
121387: PPUSH
121388: LD_VAR 0 1
121392: PPUSH
121393: CALL_OW 12
121397: ARRAY
121398: PPUSH
121399: LD_INT 60
121401: PPUSH
121402: CALL_OW 234
// end ;
121406: PPOPN 1
121408: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
121409: LD_EXP 148
121413: PUSH
121414: LD_EXP 178
121418: AND
121419: IFFALSE 121518
121421: GO 121423
121423: DISABLE
121424: LD_INT 0
121426: PPUSH
121427: PPUSH
// begin enable ;
121428: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
121429: LD_ADDR_VAR 0 1
121433: PUSH
121434: LD_INT 22
121436: PUSH
121437: LD_OWVAR 2
121441: PUSH
121442: EMPTY
121443: LIST
121444: LIST
121445: PUSH
121446: LD_INT 61
121448: PUSH
121449: EMPTY
121450: LIST
121451: PUSH
121452: LD_INT 33
121454: PUSH
121455: LD_INT 2
121457: PUSH
121458: EMPTY
121459: LIST
121460: LIST
121461: PUSH
121462: EMPTY
121463: LIST
121464: LIST
121465: LIST
121466: PPUSH
121467: CALL_OW 69
121471: ST_TO_ADDR
// if not tmp then
121472: LD_VAR 0 1
121476: NOT
121477: IFFALSE 121481
// exit ;
121479: GO 121518
// for i in tmp do
121481: LD_ADDR_VAR 0 2
121485: PUSH
121486: LD_VAR 0 1
121490: PUSH
121491: FOR_IN
121492: IFFALSE 121516
// if IsControledBy ( i ) then
121494: LD_VAR 0 2
121498: PPUSH
121499: CALL_OW 312
121503: IFFALSE 121514
// ComUnlink ( i ) ;
121505: LD_VAR 0 2
121509: PPUSH
121510: CALL_OW 136
121514: GO 121491
121516: POP
121517: POP
// end ;
121518: PPOPN 2
121520: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
121521: LD_EXP 148
121525: PUSH
121526: LD_EXP 179
121530: AND
121531: IFFALSE 121671
121533: GO 121535
121535: DISABLE
121536: LD_INT 0
121538: PPUSH
121539: PPUSH
// begin ToLua ( displayPowell(); ) ;
121540: LD_STRING displayPowell();
121542: PPUSH
121543: CALL_OW 559
// uc_side := 0 ;
121547: LD_ADDR_OWVAR 20
121551: PUSH
121552: LD_INT 0
121554: ST_TO_ADDR
// uc_nation := 2 ;
121555: LD_ADDR_OWVAR 21
121559: PUSH
121560: LD_INT 2
121562: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
121563: LD_ADDR_OWVAR 37
121567: PUSH
121568: LD_INT 14
121570: ST_TO_ADDR
// vc_engine := engine_siberite ;
121571: LD_ADDR_OWVAR 39
121575: PUSH
121576: LD_INT 3
121578: ST_TO_ADDR
// vc_control := control_apeman ;
121579: LD_ADDR_OWVAR 38
121583: PUSH
121584: LD_INT 5
121586: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
121587: LD_ADDR_OWVAR 40
121591: PUSH
121592: LD_INT 29
121594: ST_TO_ADDR
// un := CreateVehicle ;
121595: LD_ADDR_VAR 0 2
121599: PUSH
121600: CALL_OW 45
121604: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
121605: LD_VAR 0 2
121609: PPUSH
121610: LD_INT 1
121612: PPUSH
121613: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
121617: LD_INT 35
121619: PPUSH
121620: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
121624: LD_VAR 0 2
121628: PPUSH
121629: LD_INT 22
121631: PUSH
121632: LD_OWVAR 2
121636: PUSH
121637: EMPTY
121638: LIST
121639: LIST
121640: PPUSH
121641: CALL_OW 69
121645: PPUSH
121646: LD_VAR 0 2
121650: PPUSH
121651: CALL_OW 74
121655: PPUSH
121656: CALL_OW 115
// until IsDead ( un ) ;
121660: LD_VAR 0 2
121664: PPUSH
121665: CALL_OW 301
121669: IFFALSE 121617
// end ;
121671: PPOPN 2
121673: END
// every 0 0$1 trigger StreamModeActive and sStu do
121674: LD_EXP 148
121678: PUSH
121679: LD_EXP 187
121683: AND
121684: IFFALSE 121700
121686: GO 121688
121688: DISABLE
// begin ToLua ( displayStucuk(); ) ;
121689: LD_STRING displayStucuk();
121691: PPUSH
121692: CALL_OW 559
// ResetFog ;
121696: CALL_OW 335
// end ;
121700: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
121701: LD_EXP 148
121705: PUSH
121706: LD_EXP 180
121710: AND
121711: IFFALSE 121852
121713: GO 121715
121715: DISABLE
121716: LD_INT 0
121718: PPUSH
121719: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
121720: LD_ADDR_VAR 0 2
121724: PUSH
121725: LD_INT 22
121727: PUSH
121728: LD_OWVAR 2
121732: PUSH
121733: EMPTY
121734: LIST
121735: LIST
121736: PUSH
121737: LD_INT 21
121739: PUSH
121740: LD_INT 1
121742: PUSH
121743: EMPTY
121744: LIST
121745: LIST
121746: PUSH
121747: EMPTY
121748: LIST
121749: LIST
121750: PPUSH
121751: CALL_OW 69
121755: ST_TO_ADDR
// if not tmp then
121756: LD_VAR 0 2
121760: NOT
121761: IFFALSE 121765
// exit ;
121763: GO 121852
// un := tmp [ rand ( 1 , tmp ) ] ;
121765: LD_ADDR_VAR 0 1
121769: PUSH
121770: LD_VAR 0 2
121774: PUSH
121775: LD_INT 1
121777: PPUSH
121778: LD_VAR 0 2
121782: PPUSH
121783: CALL_OW 12
121787: ARRAY
121788: ST_TO_ADDR
// SetSide ( un , 0 ) ;
121789: LD_VAR 0 1
121793: PPUSH
121794: LD_INT 0
121796: PPUSH
121797: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
121801: LD_VAR 0 1
121805: PPUSH
121806: LD_OWVAR 3
121810: PUSH
121811: LD_VAR 0 1
121815: DIFF
121816: PPUSH
121817: LD_VAR 0 1
121821: PPUSH
121822: CALL_OW 74
121826: PPUSH
121827: CALL_OW 115
// wait ( 0 0$20 ) ;
121831: LD_INT 700
121833: PPUSH
121834: CALL_OW 67
// SetSide ( un , your_side ) ;
121838: LD_VAR 0 1
121842: PPUSH
121843: LD_OWVAR 2
121847: PPUSH
121848: CALL_OW 235
// end ;
121852: PPOPN 2
121854: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
121855: LD_EXP 148
121859: PUSH
121860: LD_EXP 181
121864: AND
121865: IFFALSE 121971
121867: GO 121869
121869: DISABLE
121870: LD_INT 0
121872: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
121873: LD_ADDR_VAR 0 1
121877: PUSH
121878: LD_INT 22
121880: PUSH
121881: LD_OWVAR 2
121885: PUSH
121886: EMPTY
121887: LIST
121888: LIST
121889: PUSH
121890: LD_INT 2
121892: PUSH
121893: LD_INT 30
121895: PUSH
121896: LD_INT 0
121898: PUSH
121899: EMPTY
121900: LIST
121901: LIST
121902: PUSH
121903: LD_INT 30
121905: PUSH
121906: LD_INT 1
121908: PUSH
121909: EMPTY
121910: LIST
121911: LIST
121912: PUSH
121913: EMPTY
121914: LIST
121915: LIST
121916: LIST
121917: PUSH
121918: EMPTY
121919: LIST
121920: LIST
121921: PPUSH
121922: CALL_OW 69
121926: ST_TO_ADDR
// if not depot then
121927: LD_VAR 0 1
121931: NOT
121932: IFFALSE 121936
// exit ;
121934: GO 121971
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
121936: LD_VAR 0 1
121940: PUSH
121941: LD_INT 1
121943: ARRAY
121944: PPUSH
121945: CALL_OW 250
121949: PPUSH
121950: LD_VAR 0 1
121954: PUSH
121955: LD_INT 1
121957: ARRAY
121958: PPUSH
121959: CALL_OW 251
121963: PPUSH
121964: LD_INT 70
121966: PPUSH
121967: CALL_OW 495
// end ;
121971: PPOPN 1
121973: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
121974: LD_EXP 148
121978: PUSH
121979: LD_EXP 182
121983: AND
121984: IFFALSE 122195
121986: GO 121988
121988: DISABLE
121989: LD_INT 0
121991: PPUSH
121992: PPUSH
121993: PPUSH
121994: PPUSH
121995: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
121996: LD_ADDR_VAR 0 5
122000: PUSH
122001: LD_INT 22
122003: PUSH
122004: LD_OWVAR 2
122008: PUSH
122009: EMPTY
122010: LIST
122011: LIST
122012: PUSH
122013: LD_INT 21
122015: PUSH
122016: LD_INT 1
122018: PUSH
122019: EMPTY
122020: LIST
122021: LIST
122022: PUSH
122023: EMPTY
122024: LIST
122025: LIST
122026: PPUSH
122027: CALL_OW 69
122031: ST_TO_ADDR
// if not tmp then
122032: LD_VAR 0 5
122036: NOT
122037: IFFALSE 122041
// exit ;
122039: GO 122195
// for i in tmp do
122041: LD_ADDR_VAR 0 1
122045: PUSH
122046: LD_VAR 0 5
122050: PUSH
122051: FOR_IN
122052: IFFALSE 122193
// begin d := rand ( 0 , 5 ) ;
122054: LD_ADDR_VAR 0 4
122058: PUSH
122059: LD_INT 0
122061: PPUSH
122062: LD_INT 5
122064: PPUSH
122065: CALL_OW 12
122069: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
122070: LD_ADDR_VAR 0 2
122074: PUSH
122075: LD_VAR 0 1
122079: PPUSH
122080: CALL_OW 250
122084: PPUSH
122085: LD_VAR 0 4
122089: PPUSH
122090: LD_INT 3
122092: PPUSH
122093: LD_INT 12
122095: PPUSH
122096: CALL_OW 12
122100: PPUSH
122101: CALL_OW 272
122105: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
122106: LD_ADDR_VAR 0 3
122110: PUSH
122111: LD_VAR 0 1
122115: PPUSH
122116: CALL_OW 251
122120: PPUSH
122121: LD_VAR 0 4
122125: PPUSH
122126: LD_INT 3
122128: PPUSH
122129: LD_INT 12
122131: PPUSH
122132: CALL_OW 12
122136: PPUSH
122137: CALL_OW 273
122141: ST_TO_ADDR
// if ValidHex ( x , y ) then
122142: LD_VAR 0 2
122146: PPUSH
122147: LD_VAR 0 3
122151: PPUSH
122152: CALL_OW 488
122156: IFFALSE 122191
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
122158: LD_VAR 0 1
122162: PPUSH
122163: LD_VAR 0 2
122167: PPUSH
122168: LD_VAR 0 3
122172: PPUSH
122173: LD_INT 3
122175: PPUSH
122176: LD_INT 6
122178: PPUSH
122179: CALL_OW 12
122183: PPUSH
122184: LD_INT 1
122186: PPUSH
122187: CALL_OW 483
// end ;
122191: GO 122051
122193: POP
122194: POP
// end ;
122195: PPOPN 5
122197: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
122198: LD_EXP 148
122202: PUSH
122203: LD_EXP 183
122207: AND
122208: IFFALSE 122302
122210: GO 122212
122212: DISABLE
122213: LD_INT 0
122215: PPUSH
122216: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
122217: LD_ADDR_VAR 0 2
122221: PUSH
122222: LD_INT 22
122224: PUSH
122225: LD_OWVAR 2
122229: PUSH
122230: EMPTY
122231: LIST
122232: LIST
122233: PUSH
122234: LD_INT 32
122236: PUSH
122237: LD_INT 1
122239: PUSH
122240: EMPTY
122241: LIST
122242: LIST
122243: PUSH
122244: LD_INT 21
122246: PUSH
122247: LD_INT 2
122249: PUSH
122250: EMPTY
122251: LIST
122252: LIST
122253: PUSH
122254: EMPTY
122255: LIST
122256: LIST
122257: LIST
122258: PPUSH
122259: CALL_OW 69
122263: ST_TO_ADDR
// if not tmp then
122264: LD_VAR 0 2
122268: NOT
122269: IFFALSE 122273
// exit ;
122271: GO 122302
// for i in tmp do
122273: LD_ADDR_VAR 0 1
122277: PUSH
122278: LD_VAR 0 2
122282: PUSH
122283: FOR_IN
122284: IFFALSE 122300
// SetFuel ( i , 0 ) ;
122286: LD_VAR 0 1
122290: PPUSH
122291: LD_INT 0
122293: PPUSH
122294: CALL_OW 240
122298: GO 122283
122300: POP
122301: POP
// end ;
122302: PPOPN 2
122304: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
122305: LD_EXP 148
122309: PUSH
122310: LD_EXP 184
122314: AND
122315: IFFALSE 122381
122317: GO 122319
122319: DISABLE
122320: LD_INT 0
122322: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
122323: LD_ADDR_VAR 0 1
122327: PUSH
122328: LD_INT 22
122330: PUSH
122331: LD_OWVAR 2
122335: PUSH
122336: EMPTY
122337: LIST
122338: LIST
122339: PUSH
122340: LD_INT 30
122342: PUSH
122343: LD_INT 29
122345: PUSH
122346: EMPTY
122347: LIST
122348: LIST
122349: PUSH
122350: EMPTY
122351: LIST
122352: LIST
122353: PPUSH
122354: CALL_OW 69
122358: ST_TO_ADDR
// if not tmp then
122359: LD_VAR 0 1
122363: NOT
122364: IFFALSE 122368
// exit ;
122366: GO 122381
// DestroyUnit ( tmp [ 1 ] ) ;
122368: LD_VAR 0 1
122372: PUSH
122373: LD_INT 1
122375: ARRAY
122376: PPUSH
122377: CALL_OW 65
// end ;
122381: PPOPN 1
122383: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
122384: LD_EXP 148
122388: PUSH
122389: LD_EXP 186
122393: AND
122394: IFFALSE 122523
122396: GO 122398
122398: DISABLE
122399: LD_INT 0
122401: PPUSH
// begin uc_side := 0 ;
122402: LD_ADDR_OWVAR 20
122406: PUSH
122407: LD_INT 0
122409: ST_TO_ADDR
// uc_nation := nation_arabian ;
122410: LD_ADDR_OWVAR 21
122414: PUSH
122415: LD_INT 2
122417: ST_TO_ADDR
// hc_gallery :=  ;
122418: LD_ADDR_OWVAR 33
122422: PUSH
122423: LD_STRING 
122425: ST_TO_ADDR
// hc_name :=  ;
122426: LD_ADDR_OWVAR 26
122430: PUSH
122431: LD_STRING 
122433: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
122434: LD_INT 1
122436: PPUSH
122437: LD_INT 11
122439: PPUSH
122440: LD_INT 10
122442: PPUSH
122443: CALL_OW 380
// un := CreateHuman ;
122447: LD_ADDR_VAR 0 1
122451: PUSH
122452: CALL_OW 44
122456: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
122457: LD_VAR 0 1
122461: PPUSH
122462: LD_INT 1
122464: PPUSH
122465: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
122469: LD_INT 35
122471: PPUSH
122472: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
122476: LD_VAR 0 1
122480: PPUSH
122481: LD_INT 22
122483: PUSH
122484: LD_OWVAR 2
122488: PUSH
122489: EMPTY
122490: LIST
122491: LIST
122492: PPUSH
122493: CALL_OW 69
122497: PPUSH
122498: LD_VAR 0 1
122502: PPUSH
122503: CALL_OW 74
122507: PPUSH
122508: CALL_OW 115
// until IsDead ( un ) ;
122512: LD_VAR 0 1
122516: PPUSH
122517: CALL_OW 301
122521: IFFALSE 122469
// end ;
122523: PPOPN 1
122525: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
122526: LD_EXP 148
122530: PUSH
122531: LD_EXP 188
122535: AND
122536: IFFALSE 122548
122538: GO 122540
122540: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
122541: LD_STRING earthquake(getX(game), 0, 32)
122543: PPUSH
122544: CALL_OW 559
122548: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
122549: LD_EXP 148
122553: PUSH
122554: LD_EXP 189
122558: AND
122559: IFFALSE 122650
122561: GO 122563
122563: DISABLE
122564: LD_INT 0
122566: PPUSH
// begin enable ;
122567: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
122568: LD_ADDR_VAR 0 1
122572: PUSH
122573: LD_INT 22
122575: PUSH
122576: LD_OWVAR 2
122580: PUSH
122581: EMPTY
122582: LIST
122583: LIST
122584: PUSH
122585: LD_INT 21
122587: PUSH
122588: LD_INT 2
122590: PUSH
122591: EMPTY
122592: LIST
122593: LIST
122594: PUSH
122595: LD_INT 33
122597: PUSH
122598: LD_INT 3
122600: PUSH
122601: EMPTY
122602: LIST
122603: LIST
122604: PUSH
122605: EMPTY
122606: LIST
122607: LIST
122608: LIST
122609: PPUSH
122610: CALL_OW 69
122614: ST_TO_ADDR
// if not tmp then
122615: LD_VAR 0 1
122619: NOT
122620: IFFALSE 122624
// exit ;
122622: GO 122650
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
122624: LD_VAR 0 1
122628: PUSH
122629: LD_INT 1
122631: PPUSH
122632: LD_VAR 0 1
122636: PPUSH
122637: CALL_OW 12
122641: ARRAY
122642: PPUSH
122643: LD_INT 1
122645: PPUSH
122646: CALL_OW 234
// end ;
122650: PPOPN 1
122652: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
122653: LD_EXP 148
122657: PUSH
122658: LD_EXP 190
122662: AND
122663: IFFALSE 122804
122665: GO 122667
122667: DISABLE
122668: LD_INT 0
122670: PPUSH
122671: PPUSH
122672: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
122673: LD_ADDR_VAR 0 3
122677: PUSH
122678: LD_INT 22
122680: PUSH
122681: LD_OWVAR 2
122685: PUSH
122686: EMPTY
122687: LIST
122688: LIST
122689: PUSH
122690: LD_INT 25
122692: PUSH
122693: LD_INT 1
122695: PUSH
122696: EMPTY
122697: LIST
122698: LIST
122699: PUSH
122700: EMPTY
122701: LIST
122702: LIST
122703: PPUSH
122704: CALL_OW 69
122708: ST_TO_ADDR
// if not tmp then
122709: LD_VAR 0 3
122713: NOT
122714: IFFALSE 122718
// exit ;
122716: GO 122804
// un := tmp [ rand ( 1 , tmp ) ] ;
122718: LD_ADDR_VAR 0 2
122722: PUSH
122723: LD_VAR 0 3
122727: PUSH
122728: LD_INT 1
122730: PPUSH
122731: LD_VAR 0 3
122735: PPUSH
122736: CALL_OW 12
122740: ARRAY
122741: ST_TO_ADDR
// if Crawls ( un ) then
122742: LD_VAR 0 2
122746: PPUSH
122747: CALL_OW 318
122751: IFFALSE 122762
// ComWalk ( un ) ;
122753: LD_VAR 0 2
122757: PPUSH
122758: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
122762: LD_VAR 0 2
122766: PPUSH
122767: LD_INT 9
122769: PPUSH
122770: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
122774: LD_INT 28
122776: PPUSH
122777: LD_OWVAR 2
122781: PPUSH
122782: LD_INT 2
122784: PPUSH
122785: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
122789: LD_INT 29
122791: PPUSH
122792: LD_OWVAR 2
122796: PPUSH
122797: LD_INT 2
122799: PPUSH
122800: CALL_OW 322
// end ;
122804: PPOPN 3
122806: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
122807: LD_EXP 148
122811: PUSH
122812: LD_EXP 191
122816: AND
122817: IFFALSE 122928
122819: GO 122821
122821: DISABLE
122822: LD_INT 0
122824: PPUSH
122825: PPUSH
122826: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
122827: LD_ADDR_VAR 0 3
122831: PUSH
122832: LD_INT 22
122834: PUSH
122835: LD_OWVAR 2
122839: PUSH
122840: EMPTY
122841: LIST
122842: LIST
122843: PUSH
122844: LD_INT 25
122846: PUSH
122847: LD_INT 1
122849: PUSH
122850: EMPTY
122851: LIST
122852: LIST
122853: PUSH
122854: EMPTY
122855: LIST
122856: LIST
122857: PPUSH
122858: CALL_OW 69
122862: ST_TO_ADDR
// if not tmp then
122863: LD_VAR 0 3
122867: NOT
122868: IFFALSE 122872
// exit ;
122870: GO 122928
// un := tmp [ rand ( 1 , tmp ) ] ;
122872: LD_ADDR_VAR 0 2
122876: PUSH
122877: LD_VAR 0 3
122881: PUSH
122882: LD_INT 1
122884: PPUSH
122885: LD_VAR 0 3
122889: PPUSH
122890: CALL_OW 12
122894: ARRAY
122895: ST_TO_ADDR
// if Crawls ( un ) then
122896: LD_VAR 0 2
122900: PPUSH
122901: CALL_OW 318
122905: IFFALSE 122916
// ComWalk ( un ) ;
122907: LD_VAR 0 2
122911: PPUSH
122912: CALL_OW 138
// SetClass ( un , class_mortar ) ;
122916: LD_VAR 0 2
122920: PPUSH
122921: LD_INT 8
122923: PPUSH
122924: CALL_OW 336
// end ;
122928: PPOPN 3
122930: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
122931: LD_EXP 148
122935: PUSH
122936: LD_EXP 192
122940: AND
122941: IFFALSE 123085
122943: GO 122945
122945: DISABLE
122946: LD_INT 0
122948: PPUSH
122949: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
122950: LD_ADDR_VAR 0 2
122954: PUSH
122955: LD_INT 22
122957: PUSH
122958: LD_OWVAR 2
122962: PUSH
122963: EMPTY
122964: LIST
122965: LIST
122966: PUSH
122967: LD_INT 21
122969: PUSH
122970: LD_INT 2
122972: PUSH
122973: EMPTY
122974: LIST
122975: LIST
122976: PUSH
122977: LD_INT 2
122979: PUSH
122980: LD_INT 34
122982: PUSH
122983: LD_INT 12
122985: PUSH
122986: EMPTY
122987: LIST
122988: LIST
122989: PUSH
122990: LD_INT 34
122992: PUSH
122993: LD_INT 51
122995: PUSH
122996: EMPTY
122997: LIST
122998: LIST
122999: PUSH
123000: LD_INT 34
123002: PUSH
123003: LD_INT 32
123005: PUSH
123006: EMPTY
123007: LIST
123008: LIST
123009: PUSH
123010: EMPTY
123011: LIST
123012: LIST
123013: LIST
123014: LIST
123015: PUSH
123016: EMPTY
123017: LIST
123018: LIST
123019: LIST
123020: PPUSH
123021: CALL_OW 69
123025: ST_TO_ADDR
// if not tmp then
123026: LD_VAR 0 2
123030: NOT
123031: IFFALSE 123035
// exit ;
123033: GO 123085
// for i in tmp do
123035: LD_ADDR_VAR 0 1
123039: PUSH
123040: LD_VAR 0 2
123044: PUSH
123045: FOR_IN
123046: IFFALSE 123083
// if GetCargo ( i , mat_artifact ) = 0 then
123048: LD_VAR 0 1
123052: PPUSH
123053: LD_INT 4
123055: PPUSH
123056: CALL_OW 289
123060: PUSH
123061: LD_INT 0
123063: EQUAL
123064: IFFALSE 123081
// SetCargo ( i , mat_siberit , 100 ) ;
123066: LD_VAR 0 1
123070: PPUSH
123071: LD_INT 3
123073: PPUSH
123074: LD_INT 100
123076: PPUSH
123077: CALL_OW 290
123081: GO 123045
123083: POP
123084: POP
// end ;
123085: PPOPN 2
123087: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
123088: LD_EXP 148
123092: PUSH
123093: LD_EXP 193
123097: AND
123098: IFFALSE 123281
123100: GO 123102
123102: DISABLE
123103: LD_INT 0
123105: PPUSH
123106: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
123107: LD_ADDR_VAR 0 2
123111: PUSH
123112: LD_INT 22
123114: PUSH
123115: LD_OWVAR 2
123119: PUSH
123120: EMPTY
123121: LIST
123122: LIST
123123: PPUSH
123124: CALL_OW 69
123128: ST_TO_ADDR
// if not tmp then
123129: LD_VAR 0 2
123133: NOT
123134: IFFALSE 123138
// exit ;
123136: GO 123281
// for i := 1 to 2 do
123138: LD_ADDR_VAR 0 1
123142: PUSH
123143: DOUBLE
123144: LD_INT 1
123146: DEC
123147: ST_TO_ADDR
123148: LD_INT 2
123150: PUSH
123151: FOR_TO
123152: IFFALSE 123279
// begin uc_side := your_side ;
123154: LD_ADDR_OWVAR 20
123158: PUSH
123159: LD_OWVAR 2
123163: ST_TO_ADDR
// uc_nation := nation_american ;
123164: LD_ADDR_OWVAR 21
123168: PUSH
123169: LD_INT 1
123171: ST_TO_ADDR
// vc_chassis := us_morphling ;
123172: LD_ADDR_OWVAR 37
123176: PUSH
123177: LD_INT 5
123179: ST_TO_ADDR
// vc_engine := engine_siberite ;
123180: LD_ADDR_OWVAR 39
123184: PUSH
123185: LD_INT 3
123187: ST_TO_ADDR
// vc_control := control_computer ;
123188: LD_ADDR_OWVAR 38
123192: PUSH
123193: LD_INT 3
123195: ST_TO_ADDR
// vc_weapon := us_double_laser ;
123196: LD_ADDR_OWVAR 40
123200: PUSH
123201: LD_INT 10
123203: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
123204: LD_VAR 0 2
123208: PUSH
123209: LD_INT 1
123211: ARRAY
123212: PPUSH
123213: CALL_OW 310
123217: NOT
123218: IFFALSE 123265
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
123220: CALL_OW 45
123224: PPUSH
123225: LD_VAR 0 2
123229: PUSH
123230: LD_INT 1
123232: ARRAY
123233: PPUSH
123234: CALL_OW 250
123238: PPUSH
123239: LD_VAR 0 2
123243: PUSH
123244: LD_INT 1
123246: ARRAY
123247: PPUSH
123248: CALL_OW 251
123252: PPUSH
123253: LD_INT 12
123255: PPUSH
123256: LD_INT 1
123258: PPUSH
123259: CALL_OW 50
123263: GO 123277
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
123265: CALL_OW 45
123269: PPUSH
123270: LD_INT 1
123272: PPUSH
123273: CALL_OW 51
// end ;
123277: GO 123151
123279: POP
123280: POP
// end ;
123281: PPOPN 2
123283: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
123284: LD_EXP 148
123288: PUSH
123289: LD_EXP 194
123293: AND
123294: IFFALSE 123516
123296: GO 123298
123298: DISABLE
123299: LD_INT 0
123301: PPUSH
123302: PPUSH
123303: PPUSH
123304: PPUSH
123305: PPUSH
123306: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
123307: LD_ADDR_VAR 0 6
123311: PUSH
123312: LD_INT 22
123314: PUSH
123315: LD_OWVAR 2
123319: PUSH
123320: EMPTY
123321: LIST
123322: LIST
123323: PUSH
123324: LD_INT 21
123326: PUSH
123327: LD_INT 1
123329: PUSH
123330: EMPTY
123331: LIST
123332: LIST
123333: PUSH
123334: LD_INT 3
123336: PUSH
123337: LD_INT 23
123339: PUSH
123340: LD_INT 0
123342: PUSH
123343: EMPTY
123344: LIST
123345: LIST
123346: PUSH
123347: EMPTY
123348: LIST
123349: LIST
123350: PUSH
123351: EMPTY
123352: LIST
123353: LIST
123354: LIST
123355: PPUSH
123356: CALL_OW 69
123360: ST_TO_ADDR
// if not tmp then
123361: LD_VAR 0 6
123365: NOT
123366: IFFALSE 123370
// exit ;
123368: GO 123516
// s1 := rand ( 1 , 4 ) ;
123370: LD_ADDR_VAR 0 2
123374: PUSH
123375: LD_INT 1
123377: PPUSH
123378: LD_INT 4
123380: PPUSH
123381: CALL_OW 12
123385: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
123386: LD_ADDR_VAR 0 4
123390: PUSH
123391: LD_VAR 0 6
123395: PUSH
123396: LD_INT 1
123398: ARRAY
123399: PPUSH
123400: LD_VAR 0 2
123404: PPUSH
123405: CALL_OW 259
123409: ST_TO_ADDR
// if s1 = 1 then
123410: LD_VAR 0 2
123414: PUSH
123415: LD_INT 1
123417: EQUAL
123418: IFFALSE 123438
// s2 := rand ( 2 , 4 ) else
123420: LD_ADDR_VAR 0 3
123424: PUSH
123425: LD_INT 2
123427: PPUSH
123428: LD_INT 4
123430: PPUSH
123431: CALL_OW 12
123435: ST_TO_ADDR
123436: GO 123446
// s2 := 1 ;
123438: LD_ADDR_VAR 0 3
123442: PUSH
123443: LD_INT 1
123445: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
123446: LD_ADDR_VAR 0 5
123450: PUSH
123451: LD_VAR 0 6
123455: PUSH
123456: LD_INT 1
123458: ARRAY
123459: PPUSH
123460: LD_VAR 0 3
123464: PPUSH
123465: CALL_OW 259
123469: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
123470: LD_VAR 0 6
123474: PUSH
123475: LD_INT 1
123477: ARRAY
123478: PPUSH
123479: LD_VAR 0 2
123483: PPUSH
123484: LD_VAR 0 5
123488: PPUSH
123489: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
123493: LD_VAR 0 6
123497: PUSH
123498: LD_INT 1
123500: ARRAY
123501: PPUSH
123502: LD_VAR 0 3
123506: PPUSH
123507: LD_VAR 0 4
123511: PPUSH
123512: CALL_OW 237
// end ;
123516: PPOPN 6
123518: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
123519: LD_EXP 148
123523: PUSH
123524: LD_EXP 195
123528: AND
123529: IFFALSE 123608
123531: GO 123533
123533: DISABLE
123534: LD_INT 0
123536: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
123537: LD_ADDR_VAR 0 1
123541: PUSH
123542: LD_INT 22
123544: PUSH
123545: LD_OWVAR 2
123549: PUSH
123550: EMPTY
123551: LIST
123552: LIST
123553: PUSH
123554: LD_INT 30
123556: PUSH
123557: LD_INT 3
123559: PUSH
123560: EMPTY
123561: LIST
123562: LIST
123563: PUSH
123564: EMPTY
123565: LIST
123566: LIST
123567: PPUSH
123568: CALL_OW 69
123572: ST_TO_ADDR
// if not tmp then
123573: LD_VAR 0 1
123577: NOT
123578: IFFALSE 123582
// exit ;
123580: GO 123608
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
123582: LD_VAR 0 1
123586: PUSH
123587: LD_INT 1
123589: PPUSH
123590: LD_VAR 0 1
123594: PPUSH
123595: CALL_OW 12
123599: ARRAY
123600: PPUSH
123601: LD_INT 1
123603: PPUSH
123604: CALL_OW 234
// end ;
123608: PPOPN 1
123610: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
123611: LD_EXP 148
123615: PUSH
123616: LD_EXP 196
123620: AND
123621: IFFALSE 123733
123623: GO 123625
123625: DISABLE
123626: LD_INT 0
123628: PPUSH
123629: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
123630: LD_ADDR_VAR 0 2
123634: PUSH
123635: LD_INT 22
123637: PUSH
123638: LD_OWVAR 2
123642: PUSH
123643: EMPTY
123644: LIST
123645: LIST
123646: PUSH
123647: LD_INT 2
123649: PUSH
123650: LD_INT 30
123652: PUSH
123653: LD_INT 27
123655: PUSH
123656: EMPTY
123657: LIST
123658: LIST
123659: PUSH
123660: LD_INT 30
123662: PUSH
123663: LD_INT 26
123665: PUSH
123666: EMPTY
123667: LIST
123668: LIST
123669: PUSH
123670: LD_INT 30
123672: PUSH
123673: LD_INT 28
123675: PUSH
123676: EMPTY
123677: LIST
123678: LIST
123679: PUSH
123680: EMPTY
123681: LIST
123682: LIST
123683: LIST
123684: LIST
123685: PUSH
123686: EMPTY
123687: LIST
123688: LIST
123689: PPUSH
123690: CALL_OW 69
123694: ST_TO_ADDR
// if not tmp then
123695: LD_VAR 0 2
123699: NOT
123700: IFFALSE 123704
// exit ;
123702: GO 123733
// for i in tmp do
123704: LD_ADDR_VAR 0 1
123708: PUSH
123709: LD_VAR 0 2
123713: PUSH
123714: FOR_IN
123715: IFFALSE 123731
// SetLives ( i , 1 ) ;
123717: LD_VAR 0 1
123721: PPUSH
123722: LD_INT 1
123724: PPUSH
123725: CALL_OW 234
123729: GO 123714
123731: POP
123732: POP
// end ;
123733: PPOPN 2
123735: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
123736: LD_EXP 148
123740: PUSH
123741: LD_EXP 197
123745: AND
123746: IFFALSE 124033
123748: GO 123750
123750: DISABLE
123751: LD_INT 0
123753: PPUSH
123754: PPUSH
123755: PPUSH
// begin i := rand ( 1 , 7 ) ;
123756: LD_ADDR_VAR 0 1
123760: PUSH
123761: LD_INT 1
123763: PPUSH
123764: LD_INT 7
123766: PPUSH
123767: CALL_OW 12
123771: ST_TO_ADDR
// case i of 1 :
123772: LD_VAR 0 1
123776: PUSH
123777: LD_INT 1
123779: DOUBLE
123780: EQUAL
123781: IFTRUE 123785
123783: GO 123795
123785: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
123786: LD_STRING earthquake(getX(game), 0, 32)
123788: PPUSH
123789: CALL_OW 559
123793: GO 124033
123795: LD_INT 2
123797: DOUBLE
123798: EQUAL
123799: IFTRUE 123803
123801: GO 123817
123803: POP
// begin ToLua ( displayStucuk(); ) ;
123804: LD_STRING displayStucuk();
123806: PPUSH
123807: CALL_OW 559
// ResetFog ;
123811: CALL_OW 335
// end ; 3 :
123815: GO 124033
123817: LD_INT 3
123819: DOUBLE
123820: EQUAL
123821: IFTRUE 123825
123823: GO 123929
123825: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
123826: LD_ADDR_VAR 0 2
123830: PUSH
123831: LD_INT 22
123833: PUSH
123834: LD_OWVAR 2
123838: PUSH
123839: EMPTY
123840: LIST
123841: LIST
123842: PUSH
123843: LD_INT 25
123845: PUSH
123846: LD_INT 1
123848: PUSH
123849: EMPTY
123850: LIST
123851: LIST
123852: PUSH
123853: EMPTY
123854: LIST
123855: LIST
123856: PPUSH
123857: CALL_OW 69
123861: ST_TO_ADDR
// if not tmp then
123862: LD_VAR 0 2
123866: NOT
123867: IFFALSE 123871
// exit ;
123869: GO 124033
// un := tmp [ rand ( 1 , tmp ) ] ;
123871: LD_ADDR_VAR 0 3
123875: PUSH
123876: LD_VAR 0 2
123880: PUSH
123881: LD_INT 1
123883: PPUSH
123884: LD_VAR 0 2
123888: PPUSH
123889: CALL_OW 12
123893: ARRAY
123894: ST_TO_ADDR
// if Crawls ( un ) then
123895: LD_VAR 0 3
123899: PPUSH
123900: CALL_OW 318
123904: IFFALSE 123915
// ComWalk ( un ) ;
123906: LD_VAR 0 3
123910: PPUSH
123911: CALL_OW 138
// SetClass ( un , class_mortar ) ;
123915: LD_VAR 0 3
123919: PPUSH
123920: LD_INT 8
123922: PPUSH
123923: CALL_OW 336
// end ; 4 :
123927: GO 124033
123929: LD_INT 4
123931: DOUBLE
123932: EQUAL
123933: IFTRUE 123937
123935: GO 124011
123937: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
123938: LD_ADDR_VAR 0 2
123942: PUSH
123943: LD_INT 22
123945: PUSH
123946: LD_OWVAR 2
123950: PUSH
123951: EMPTY
123952: LIST
123953: LIST
123954: PUSH
123955: LD_INT 30
123957: PUSH
123958: LD_INT 29
123960: PUSH
123961: EMPTY
123962: LIST
123963: LIST
123964: PUSH
123965: EMPTY
123966: LIST
123967: LIST
123968: PPUSH
123969: CALL_OW 69
123973: ST_TO_ADDR
// if not tmp then
123974: LD_VAR 0 2
123978: NOT
123979: IFFALSE 123983
// exit ;
123981: GO 124033
// CenterNowOnUnits ( tmp [ 1 ] ) ;
123983: LD_VAR 0 2
123987: PUSH
123988: LD_INT 1
123990: ARRAY
123991: PPUSH
123992: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
123996: LD_VAR 0 2
124000: PUSH
124001: LD_INT 1
124003: ARRAY
124004: PPUSH
124005: CALL_OW 65
// end ; 5 .. 7 :
124009: GO 124033
124011: LD_INT 5
124013: DOUBLE
124014: GREATEREQUAL
124015: IFFALSE 124023
124017: LD_INT 7
124019: DOUBLE
124020: LESSEQUAL
124021: IFTRUE 124025
124023: GO 124032
124025: POP
// StreamSibBomb ; end ;
124026: CALL 120270 0 0
124030: GO 124033
124032: POP
// end ;
124033: PPOPN 3
124035: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
124036: LD_EXP 148
124040: PUSH
124041: LD_EXP 198
124045: AND
124046: IFFALSE 124202
124048: GO 124050
124050: DISABLE
124051: LD_INT 0
124053: PPUSH
124054: PPUSH
124055: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
124056: LD_ADDR_VAR 0 2
124060: PUSH
124061: LD_INT 81
124063: PUSH
124064: LD_OWVAR 2
124068: PUSH
124069: EMPTY
124070: LIST
124071: LIST
124072: PUSH
124073: LD_INT 2
124075: PUSH
124076: LD_INT 21
124078: PUSH
124079: LD_INT 1
124081: PUSH
124082: EMPTY
124083: LIST
124084: LIST
124085: PUSH
124086: LD_INT 21
124088: PUSH
124089: LD_INT 2
124091: PUSH
124092: EMPTY
124093: LIST
124094: LIST
124095: PUSH
124096: EMPTY
124097: LIST
124098: LIST
124099: LIST
124100: PUSH
124101: EMPTY
124102: LIST
124103: LIST
124104: PPUSH
124105: CALL_OW 69
124109: ST_TO_ADDR
// if not tmp then
124110: LD_VAR 0 2
124114: NOT
124115: IFFALSE 124119
// exit ;
124117: GO 124202
// p := 0 ;
124119: LD_ADDR_VAR 0 3
124123: PUSH
124124: LD_INT 0
124126: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
124127: LD_INT 35
124129: PPUSH
124130: CALL_OW 67
// p := p + 1 ;
124134: LD_ADDR_VAR 0 3
124138: PUSH
124139: LD_VAR 0 3
124143: PUSH
124144: LD_INT 1
124146: PLUS
124147: ST_TO_ADDR
// for i in tmp do
124148: LD_ADDR_VAR 0 1
124152: PUSH
124153: LD_VAR 0 2
124157: PUSH
124158: FOR_IN
124159: IFFALSE 124190
// if GetLives ( i ) < 1000 then
124161: LD_VAR 0 1
124165: PPUSH
124166: CALL_OW 256
124170: PUSH
124171: LD_INT 1000
124173: LESS
124174: IFFALSE 124188
// SetLives ( i , 1000 ) ;
124176: LD_VAR 0 1
124180: PPUSH
124181: LD_INT 1000
124183: PPUSH
124184: CALL_OW 234
124188: GO 124158
124190: POP
124191: POP
// until p > 20 ;
124192: LD_VAR 0 3
124196: PUSH
124197: LD_INT 20
124199: GREATER
124200: IFFALSE 124127
// end ;
124202: PPOPN 3
124204: END
// every 0 0$1 trigger StreamModeActive and sTime do
124205: LD_EXP 148
124209: PUSH
124210: LD_EXP 199
124214: AND
124215: IFFALSE 124250
124217: GO 124219
124219: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
124220: LD_INT 28
124222: PPUSH
124223: LD_OWVAR 2
124227: PPUSH
124228: LD_INT 2
124230: PPUSH
124231: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
124235: LD_INT 30
124237: PPUSH
124238: LD_OWVAR 2
124242: PPUSH
124243: LD_INT 2
124245: PPUSH
124246: CALL_OW 322
// end ;
124250: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
124251: LD_EXP 148
124255: PUSH
124256: LD_EXP 200
124260: AND
124261: IFFALSE 124382
124263: GO 124265
124265: DISABLE
124266: LD_INT 0
124268: PPUSH
124269: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
124270: LD_ADDR_VAR 0 2
124274: PUSH
124275: LD_INT 22
124277: PUSH
124278: LD_OWVAR 2
124282: PUSH
124283: EMPTY
124284: LIST
124285: LIST
124286: PUSH
124287: LD_INT 21
124289: PUSH
124290: LD_INT 1
124292: PUSH
124293: EMPTY
124294: LIST
124295: LIST
124296: PUSH
124297: LD_INT 3
124299: PUSH
124300: LD_INT 23
124302: PUSH
124303: LD_INT 0
124305: PUSH
124306: EMPTY
124307: LIST
124308: LIST
124309: PUSH
124310: EMPTY
124311: LIST
124312: LIST
124313: PUSH
124314: EMPTY
124315: LIST
124316: LIST
124317: LIST
124318: PPUSH
124319: CALL_OW 69
124323: ST_TO_ADDR
// if not tmp then
124324: LD_VAR 0 2
124328: NOT
124329: IFFALSE 124333
// exit ;
124331: GO 124382
// for i in tmp do
124333: LD_ADDR_VAR 0 1
124337: PUSH
124338: LD_VAR 0 2
124342: PUSH
124343: FOR_IN
124344: IFFALSE 124380
// begin if Crawls ( i ) then
124346: LD_VAR 0 1
124350: PPUSH
124351: CALL_OW 318
124355: IFFALSE 124366
// ComWalk ( i ) ;
124357: LD_VAR 0 1
124361: PPUSH
124362: CALL_OW 138
// SetClass ( i , 2 ) ;
124366: LD_VAR 0 1
124370: PPUSH
124371: LD_INT 2
124373: PPUSH
124374: CALL_OW 336
// end ;
124378: GO 124343
124380: POP
124381: POP
// end ;
124382: PPOPN 2
124384: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
124385: LD_EXP 148
124389: PUSH
124390: LD_EXP 201
124394: AND
124395: IFFALSE 124683
124397: GO 124399
124399: DISABLE
124400: LD_INT 0
124402: PPUSH
124403: PPUSH
124404: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
124405: LD_OWVAR 2
124409: PPUSH
124410: LD_INT 9
124412: PPUSH
124413: LD_INT 1
124415: PPUSH
124416: LD_INT 1
124418: PPUSH
124419: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
124423: LD_INT 9
124425: PPUSH
124426: LD_OWVAR 2
124430: PPUSH
124431: CALL_OW 343
// uc_side := 9 ;
124435: LD_ADDR_OWVAR 20
124439: PUSH
124440: LD_INT 9
124442: ST_TO_ADDR
// uc_nation := 2 ;
124443: LD_ADDR_OWVAR 21
124447: PUSH
124448: LD_INT 2
124450: ST_TO_ADDR
// hc_name := Dark Warrior ;
124451: LD_ADDR_OWVAR 26
124455: PUSH
124456: LD_STRING Dark Warrior
124458: ST_TO_ADDR
// hc_gallery :=  ;
124459: LD_ADDR_OWVAR 33
124463: PUSH
124464: LD_STRING 
124466: ST_TO_ADDR
// hc_noskilllimit := true ;
124467: LD_ADDR_OWVAR 76
124471: PUSH
124472: LD_INT 1
124474: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
124475: LD_ADDR_OWVAR 31
124479: PUSH
124480: LD_INT 30
124482: PUSH
124483: LD_INT 30
124485: PUSH
124486: LD_INT 30
124488: PUSH
124489: LD_INT 30
124491: PUSH
124492: EMPTY
124493: LIST
124494: LIST
124495: LIST
124496: LIST
124497: ST_TO_ADDR
// un := CreateHuman ;
124498: LD_ADDR_VAR 0 3
124502: PUSH
124503: CALL_OW 44
124507: ST_TO_ADDR
// hc_noskilllimit := false ;
124508: LD_ADDR_OWVAR 76
124512: PUSH
124513: LD_INT 0
124515: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
124516: LD_VAR 0 3
124520: PPUSH
124521: LD_INT 1
124523: PPUSH
124524: CALL_OW 51
// ToLua ( playRanger() ) ;
124528: LD_STRING playRanger()
124530: PPUSH
124531: CALL_OW 559
// p := 0 ;
124535: LD_ADDR_VAR 0 2
124539: PUSH
124540: LD_INT 0
124542: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
124543: LD_INT 35
124545: PPUSH
124546: CALL_OW 67
// p := p + 1 ;
124550: LD_ADDR_VAR 0 2
124554: PUSH
124555: LD_VAR 0 2
124559: PUSH
124560: LD_INT 1
124562: PLUS
124563: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
124564: LD_VAR 0 3
124568: PPUSH
124569: CALL_OW 256
124573: PUSH
124574: LD_INT 1000
124576: LESS
124577: IFFALSE 124591
// SetLives ( un , 1000 ) ;
124579: LD_VAR 0 3
124583: PPUSH
124584: LD_INT 1000
124586: PPUSH
124587: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
124591: LD_VAR 0 3
124595: PPUSH
124596: LD_INT 81
124598: PUSH
124599: LD_OWVAR 2
124603: PUSH
124604: EMPTY
124605: LIST
124606: LIST
124607: PUSH
124608: LD_INT 91
124610: PUSH
124611: LD_VAR 0 3
124615: PUSH
124616: LD_INT 30
124618: PUSH
124619: EMPTY
124620: LIST
124621: LIST
124622: LIST
124623: PUSH
124624: EMPTY
124625: LIST
124626: LIST
124627: PPUSH
124628: CALL_OW 69
124632: PPUSH
124633: LD_VAR 0 3
124637: PPUSH
124638: CALL_OW 74
124642: PPUSH
124643: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
124647: LD_VAR 0 2
124651: PUSH
124652: LD_INT 80
124654: GREATER
124655: PUSH
124656: LD_VAR 0 3
124660: PPUSH
124661: CALL_OW 301
124665: OR
124666: IFFALSE 124543
// if un then
124668: LD_VAR 0 3
124672: IFFALSE 124683
// RemoveUnit ( un ) ;
124674: LD_VAR 0 3
124678: PPUSH
124679: CALL_OW 64
// end ;
124683: PPOPN 3
124685: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
124686: LD_EXP 202
124690: IFFALSE 124806
124692: GO 124694
124694: DISABLE
124695: LD_INT 0
124697: PPUSH
124698: PPUSH
124699: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
124700: LD_ADDR_VAR 0 2
124704: PUSH
124705: LD_INT 81
124707: PUSH
124708: LD_OWVAR 2
124712: PUSH
124713: EMPTY
124714: LIST
124715: LIST
124716: PUSH
124717: LD_INT 21
124719: PUSH
124720: LD_INT 1
124722: PUSH
124723: EMPTY
124724: LIST
124725: LIST
124726: PUSH
124727: EMPTY
124728: LIST
124729: LIST
124730: PPUSH
124731: CALL_OW 69
124735: ST_TO_ADDR
// ToLua ( playComputer() ) ;
124736: LD_STRING playComputer()
124738: PPUSH
124739: CALL_OW 559
// if not tmp then
124743: LD_VAR 0 2
124747: NOT
124748: IFFALSE 124752
// exit ;
124750: GO 124806
// for i in tmp do
124752: LD_ADDR_VAR 0 1
124756: PUSH
124757: LD_VAR 0 2
124761: PUSH
124762: FOR_IN
124763: IFFALSE 124804
// for j := 1 to 4 do
124765: LD_ADDR_VAR 0 3
124769: PUSH
124770: DOUBLE
124771: LD_INT 1
124773: DEC
124774: ST_TO_ADDR
124775: LD_INT 4
124777: PUSH
124778: FOR_TO
124779: IFFALSE 124800
// SetSkill ( i , j , 10 ) ;
124781: LD_VAR 0 1
124785: PPUSH
124786: LD_VAR 0 3
124790: PPUSH
124791: LD_INT 10
124793: PPUSH
124794: CALL_OW 237
124798: GO 124778
124800: POP
124801: POP
124802: GO 124762
124804: POP
124805: POP
// end ;
124806: PPOPN 3
124808: END
// every 0 0$1 trigger s30 do var i , tmp ;
124809: LD_EXP 203
124813: IFFALSE 124882
124815: GO 124817
124817: DISABLE
124818: LD_INT 0
124820: PPUSH
124821: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
124822: LD_ADDR_VAR 0 2
124826: PUSH
124827: LD_INT 22
124829: PUSH
124830: LD_OWVAR 2
124834: PUSH
124835: EMPTY
124836: LIST
124837: LIST
124838: PPUSH
124839: CALL_OW 69
124843: ST_TO_ADDR
// if not tmp then
124844: LD_VAR 0 2
124848: NOT
124849: IFFALSE 124853
// exit ;
124851: GO 124882
// for i in tmp do
124853: LD_ADDR_VAR 0 1
124857: PUSH
124858: LD_VAR 0 2
124862: PUSH
124863: FOR_IN
124864: IFFALSE 124880
// SetLives ( i , 300 ) ;
124866: LD_VAR 0 1
124870: PPUSH
124871: LD_INT 300
124873: PPUSH
124874: CALL_OW 234
124878: GO 124863
124880: POP
124881: POP
// end ;
124882: PPOPN 2
124884: END
// every 0 0$1 trigger s60 do var i , tmp ;
124885: LD_EXP 204
124889: IFFALSE 124958
124891: GO 124893
124893: DISABLE
124894: LD_INT 0
124896: PPUSH
124897: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
124898: LD_ADDR_VAR 0 2
124902: PUSH
124903: LD_INT 22
124905: PUSH
124906: LD_OWVAR 2
124910: PUSH
124911: EMPTY
124912: LIST
124913: LIST
124914: PPUSH
124915: CALL_OW 69
124919: ST_TO_ADDR
// if not tmp then
124920: LD_VAR 0 2
124924: NOT
124925: IFFALSE 124929
// exit ;
124927: GO 124958
// for i in tmp do
124929: LD_ADDR_VAR 0 1
124933: PUSH
124934: LD_VAR 0 2
124938: PUSH
124939: FOR_IN
124940: IFFALSE 124956
// SetLives ( i , 600 ) ;
124942: LD_VAR 0 1
124946: PPUSH
124947: LD_INT 600
124949: PPUSH
124950: CALL_OW 234
124954: GO 124939
124956: POP
124957: POP
// end ;
124958: PPOPN 2
124960: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
124961: LD_INT 0
124963: PPUSH
// case cmd of 301 :
124964: LD_VAR 0 1
124968: PUSH
124969: LD_INT 301
124971: DOUBLE
124972: EQUAL
124973: IFTRUE 124977
124975: GO 125009
124977: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
124978: LD_VAR 0 6
124982: PPUSH
124983: LD_VAR 0 7
124987: PPUSH
124988: LD_VAR 0 8
124992: PPUSH
124993: LD_VAR 0 4
124997: PPUSH
124998: LD_VAR 0 5
125002: PPUSH
125003: CALL 126218 0 5
125007: GO 125130
125009: LD_INT 302
125011: DOUBLE
125012: EQUAL
125013: IFTRUE 125017
125015: GO 125054
125017: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
125018: LD_VAR 0 6
125022: PPUSH
125023: LD_VAR 0 7
125027: PPUSH
125028: LD_VAR 0 8
125032: PPUSH
125033: LD_VAR 0 9
125037: PPUSH
125038: LD_VAR 0 4
125042: PPUSH
125043: LD_VAR 0 5
125047: PPUSH
125048: CALL 126309 0 6
125052: GO 125130
125054: LD_INT 303
125056: DOUBLE
125057: EQUAL
125058: IFTRUE 125062
125060: GO 125099
125062: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
125063: LD_VAR 0 6
125067: PPUSH
125068: LD_VAR 0 7
125072: PPUSH
125073: LD_VAR 0 8
125077: PPUSH
125078: LD_VAR 0 9
125082: PPUSH
125083: LD_VAR 0 4
125087: PPUSH
125088: LD_VAR 0 5
125092: PPUSH
125093: CALL 125135 0 6
125097: GO 125130
125099: LD_INT 304
125101: DOUBLE
125102: EQUAL
125103: IFTRUE 125107
125105: GO 125129
125107: POP
// hHackTeleport ( unit , x , y ) ; end ;
125108: LD_VAR 0 2
125112: PPUSH
125113: LD_VAR 0 4
125117: PPUSH
125118: LD_VAR 0 5
125122: PPUSH
125123: CALL 126902 0 3
125127: GO 125130
125129: POP
// end ;
125130: LD_VAR 0 12
125134: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
125135: LD_INT 0
125137: PPUSH
125138: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
125139: LD_VAR 0 1
125143: PUSH
125144: LD_INT 1
125146: LESS
125147: PUSH
125148: LD_VAR 0 1
125152: PUSH
125153: LD_INT 3
125155: GREATER
125156: OR
125157: PUSH
125158: LD_VAR 0 5
125162: PPUSH
125163: LD_VAR 0 6
125167: PPUSH
125168: CALL_OW 428
125172: OR
125173: IFFALSE 125177
// exit ;
125175: GO 125905
// uc_side := your_side ;
125177: LD_ADDR_OWVAR 20
125181: PUSH
125182: LD_OWVAR 2
125186: ST_TO_ADDR
// uc_nation := nation ;
125187: LD_ADDR_OWVAR 21
125191: PUSH
125192: LD_VAR 0 1
125196: ST_TO_ADDR
// bc_level = 1 ;
125197: LD_ADDR_OWVAR 43
125201: PUSH
125202: LD_INT 1
125204: ST_TO_ADDR
// case btype of 1 :
125205: LD_VAR 0 2
125209: PUSH
125210: LD_INT 1
125212: DOUBLE
125213: EQUAL
125214: IFTRUE 125218
125216: GO 125229
125218: POP
// bc_type := b_depot ; 2 :
125219: LD_ADDR_OWVAR 42
125223: PUSH
125224: LD_INT 0
125226: ST_TO_ADDR
125227: GO 125849
125229: LD_INT 2
125231: DOUBLE
125232: EQUAL
125233: IFTRUE 125237
125235: GO 125248
125237: POP
// bc_type := b_warehouse ; 3 :
125238: LD_ADDR_OWVAR 42
125242: PUSH
125243: LD_INT 1
125245: ST_TO_ADDR
125246: GO 125849
125248: LD_INT 3
125250: DOUBLE
125251: EQUAL
125252: IFTRUE 125256
125254: GO 125267
125256: POP
// bc_type := b_lab ; 4 .. 9 :
125257: LD_ADDR_OWVAR 42
125261: PUSH
125262: LD_INT 6
125264: ST_TO_ADDR
125265: GO 125849
125267: LD_INT 4
125269: DOUBLE
125270: GREATEREQUAL
125271: IFFALSE 125279
125273: LD_INT 9
125275: DOUBLE
125276: LESSEQUAL
125277: IFTRUE 125281
125279: GO 125341
125281: POP
// begin bc_type := b_lab_half ;
125282: LD_ADDR_OWVAR 42
125286: PUSH
125287: LD_INT 7
125289: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
125290: LD_ADDR_OWVAR 44
125294: PUSH
125295: LD_INT 10
125297: PUSH
125298: LD_INT 11
125300: PUSH
125301: LD_INT 12
125303: PUSH
125304: LD_INT 15
125306: PUSH
125307: LD_INT 14
125309: PUSH
125310: LD_INT 13
125312: PUSH
125313: EMPTY
125314: LIST
125315: LIST
125316: LIST
125317: LIST
125318: LIST
125319: LIST
125320: PUSH
125321: LD_VAR 0 2
125325: PUSH
125326: LD_INT 3
125328: MINUS
125329: ARRAY
125330: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
125331: LD_ADDR_OWVAR 45
125335: PUSH
125336: LD_INT 9
125338: ST_TO_ADDR
// end ; 10 .. 13 :
125339: GO 125849
125341: LD_INT 10
125343: DOUBLE
125344: GREATEREQUAL
125345: IFFALSE 125353
125347: LD_INT 13
125349: DOUBLE
125350: LESSEQUAL
125351: IFTRUE 125355
125353: GO 125432
125355: POP
// begin bc_type := b_lab_full ;
125356: LD_ADDR_OWVAR 42
125360: PUSH
125361: LD_INT 8
125363: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
125364: LD_ADDR_OWVAR 44
125368: PUSH
125369: LD_INT 10
125371: PUSH
125372: LD_INT 12
125374: PUSH
125375: LD_INT 14
125377: PUSH
125378: LD_INT 13
125380: PUSH
125381: EMPTY
125382: LIST
125383: LIST
125384: LIST
125385: LIST
125386: PUSH
125387: LD_VAR 0 2
125391: PUSH
125392: LD_INT 9
125394: MINUS
125395: ARRAY
125396: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
125397: LD_ADDR_OWVAR 45
125401: PUSH
125402: LD_INT 11
125404: PUSH
125405: LD_INT 15
125407: PUSH
125408: LD_INT 12
125410: PUSH
125411: LD_INT 15
125413: PUSH
125414: EMPTY
125415: LIST
125416: LIST
125417: LIST
125418: LIST
125419: PUSH
125420: LD_VAR 0 2
125424: PUSH
125425: LD_INT 9
125427: MINUS
125428: ARRAY
125429: ST_TO_ADDR
// end ; 14 :
125430: GO 125849
125432: LD_INT 14
125434: DOUBLE
125435: EQUAL
125436: IFTRUE 125440
125438: GO 125451
125440: POP
// bc_type := b_workshop ; 15 :
125441: LD_ADDR_OWVAR 42
125445: PUSH
125446: LD_INT 2
125448: ST_TO_ADDR
125449: GO 125849
125451: LD_INT 15
125453: DOUBLE
125454: EQUAL
125455: IFTRUE 125459
125457: GO 125470
125459: POP
// bc_type := b_factory ; 16 :
125460: LD_ADDR_OWVAR 42
125464: PUSH
125465: LD_INT 3
125467: ST_TO_ADDR
125468: GO 125849
125470: LD_INT 16
125472: DOUBLE
125473: EQUAL
125474: IFTRUE 125478
125476: GO 125489
125478: POP
// bc_type := b_ext_gun ; 17 :
125479: LD_ADDR_OWVAR 42
125483: PUSH
125484: LD_INT 17
125486: ST_TO_ADDR
125487: GO 125849
125489: LD_INT 17
125491: DOUBLE
125492: EQUAL
125493: IFTRUE 125497
125495: GO 125525
125497: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
125498: LD_ADDR_OWVAR 42
125502: PUSH
125503: LD_INT 19
125505: PUSH
125506: LD_INT 23
125508: PUSH
125509: LD_INT 19
125511: PUSH
125512: EMPTY
125513: LIST
125514: LIST
125515: LIST
125516: PUSH
125517: LD_VAR 0 1
125521: ARRAY
125522: ST_TO_ADDR
125523: GO 125849
125525: LD_INT 18
125527: DOUBLE
125528: EQUAL
125529: IFTRUE 125533
125531: GO 125544
125533: POP
// bc_type := b_ext_radar ; 19 :
125534: LD_ADDR_OWVAR 42
125538: PUSH
125539: LD_INT 20
125541: ST_TO_ADDR
125542: GO 125849
125544: LD_INT 19
125546: DOUBLE
125547: EQUAL
125548: IFTRUE 125552
125550: GO 125563
125552: POP
// bc_type := b_ext_radio ; 20 :
125553: LD_ADDR_OWVAR 42
125557: PUSH
125558: LD_INT 22
125560: ST_TO_ADDR
125561: GO 125849
125563: LD_INT 20
125565: DOUBLE
125566: EQUAL
125567: IFTRUE 125571
125569: GO 125582
125571: POP
// bc_type := b_ext_siberium ; 21 :
125572: LD_ADDR_OWVAR 42
125576: PUSH
125577: LD_INT 21
125579: ST_TO_ADDR
125580: GO 125849
125582: LD_INT 21
125584: DOUBLE
125585: EQUAL
125586: IFTRUE 125590
125588: GO 125601
125590: POP
// bc_type := b_ext_computer ; 22 :
125591: LD_ADDR_OWVAR 42
125595: PUSH
125596: LD_INT 24
125598: ST_TO_ADDR
125599: GO 125849
125601: LD_INT 22
125603: DOUBLE
125604: EQUAL
125605: IFTRUE 125609
125607: GO 125620
125609: POP
// bc_type := b_ext_track ; 23 :
125610: LD_ADDR_OWVAR 42
125614: PUSH
125615: LD_INT 16
125617: ST_TO_ADDR
125618: GO 125849
125620: LD_INT 23
125622: DOUBLE
125623: EQUAL
125624: IFTRUE 125628
125626: GO 125639
125628: POP
// bc_type := b_ext_laser ; 24 :
125629: LD_ADDR_OWVAR 42
125633: PUSH
125634: LD_INT 25
125636: ST_TO_ADDR
125637: GO 125849
125639: LD_INT 24
125641: DOUBLE
125642: EQUAL
125643: IFTRUE 125647
125645: GO 125658
125647: POP
// bc_type := b_control_tower ; 25 :
125648: LD_ADDR_OWVAR 42
125652: PUSH
125653: LD_INT 36
125655: ST_TO_ADDR
125656: GO 125849
125658: LD_INT 25
125660: DOUBLE
125661: EQUAL
125662: IFTRUE 125666
125664: GO 125677
125666: POP
// bc_type := b_breastwork ; 26 :
125667: LD_ADDR_OWVAR 42
125671: PUSH
125672: LD_INT 31
125674: ST_TO_ADDR
125675: GO 125849
125677: LD_INT 26
125679: DOUBLE
125680: EQUAL
125681: IFTRUE 125685
125683: GO 125696
125685: POP
// bc_type := b_bunker ; 27 :
125686: LD_ADDR_OWVAR 42
125690: PUSH
125691: LD_INT 32
125693: ST_TO_ADDR
125694: GO 125849
125696: LD_INT 27
125698: DOUBLE
125699: EQUAL
125700: IFTRUE 125704
125702: GO 125715
125704: POP
// bc_type := b_turret ; 28 :
125705: LD_ADDR_OWVAR 42
125709: PUSH
125710: LD_INT 33
125712: ST_TO_ADDR
125713: GO 125849
125715: LD_INT 28
125717: DOUBLE
125718: EQUAL
125719: IFTRUE 125723
125721: GO 125734
125723: POP
// bc_type := b_armoury ; 29 :
125724: LD_ADDR_OWVAR 42
125728: PUSH
125729: LD_INT 4
125731: ST_TO_ADDR
125732: GO 125849
125734: LD_INT 29
125736: DOUBLE
125737: EQUAL
125738: IFTRUE 125742
125740: GO 125753
125742: POP
// bc_type := b_barracks ; 30 :
125743: LD_ADDR_OWVAR 42
125747: PUSH
125748: LD_INT 5
125750: ST_TO_ADDR
125751: GO 125849
125753: LD_INT 30
125755: DOUBLE
125756: EQUAL
125757: IFTRUE 125761
125759: GO 125772
125761: POP
// bc_type := b_solar_power ; 31 :
125762: LD_ADDR_OWVAR 42
125766: PUSH
125767: LD_INT 27
125769: ST_TO_ADDR
125770: GO 125849
125772: LD_INT 31
125774: DOUBLE
125775: EQUAL
125776: IFTRUE 125780
125778: GO 125791
125780: POP
// bc_type := b_oil_power ; 32 :
125781: LD_ADDR_OWVAR 42
125785: PUSH
125786: LD_INT 26
125788: ST_TO_ADDR
125789: GO 125849
125791: LD_INT 32
125793: DOUBLE
125794: EQUAL
125795: IFTRUE 125799
125797: GO 125810
125799: POP
// bc_type := b_siberite_power ; 33 :
125800: LD_ADDR_OWVAR 42
125804: PUSH
125805: LD_INT 28
125807: ST_TO_ADDR
125808: GO 125849
125810: LD_INT 33
125812: DOUBLE
125813: EQUAL
125814: IFTRUE 125818
125816: GO 125829
125818: POP
// bc_type := b_oil_mine ; 34 :
125819: LD_ADDR_OWVAR 42
125823: PUSH
125824: LD_INT 29
125826: ST_TO_ADDR
125827: GO 125849
125829: LD_INT 34
125831: DOUBLE
125832: EQUAL
125833: IFTRUE 125837
125835: GO 125848
125837: POP
// bc_type := b_siberite_mine ; end ;
125838: LD_ADDR_OWVAR 42
125842: PUSH
125843: LD_INT 30
125845: ST_TO_ADDR
125846: GO 125849
125848: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
125849: LD_ADDR_VAR 0 8
125853: PUSH
125854: LD_VAR 0 5
125858: PPUSH
125859: LD_VAR 0 6
125863: PPUSH
125864: LD_VAR 0 3
125868: PPUSH
125869: CALL_OW 47
125873: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
125874: LD_OWVAR 42
125878: PUSH
125879: LD_INT 32
125881: PUSH
125882: LD_INT 33
125884: PUSH
125885: EMPTY
125886: LIST
125887: LIST
125888: IN
125889: IFFALSE 125905
// PlaceWeaponTurret ( b , weapon ) ;
125891: LD_VAR 0 8
125895: PPUSH
125896: LD_VAR 0 4
125900: PPUSH
125901: CALL_OW 431
// end ;
125905: LD_VAR 0 7
125909: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
125910: LD_INT 0
125912: PPUSH
125913: PPUSH
125914: PPUSH
125915: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
125916: LD_ADDR_VAR 0 4
125920: PUSH
125921: LD_INT 22
125923: PUSH
125924: LD_OWVAR 2
125928: PUSH
125929: EMPTY
125930: LIST
125931: LIST
125932: PUSH
125933: LD_INT 2
125935: PUSH
125936: LD_INT 30
125938: PUSH
125939: LD_INT 0
125941: PUSH
125942: EMPTY
125943: LIST
125944: LIST
125945: PUSH
125946: LD_INT 30
125948: PUSH
125949: LD_INT 1
125951: PUSH
125952: EMPTY
125953: LIST
125954: LIST
125955: PUSH
125956: EMPTY
125957: LIST
125958: LIST
125959: LIST
125960: PUSH
125961: EMPTY
125962: LIST
125963: LIST
125964: PPUSH
125965: CALL_OW 69
125969: ST_TO_ADDR
// if not tmp then
125970: LD_VAR 0 4
125974: NOT
125975: IFFALSE 125979
// exit ;
125977: GO 126038
// for i in tmp do
125979: LD_ADDR_VAR 0 2
125983: PUSH
125984: LD_VAR 0 4
125988: PUSH
125989: FOR_IN
125990: IFFALSE 126036
// for j = 1 to 3 do
125992: LD_ADDR_VAR 0 3
125996: PUSH
125997: DOUBLE
125998: LD_INT 1
126000: DEC
126001: ST_TO_ADDR
126002: LD_INT 3
126004: PUSH
126005: FOR_TO
126006: IFFALSE 126032
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
126008: LD_VAR 0 2
126012: PPUSH
126013: CALL_OW 274
126017: PPUSH
126018: LD_VAR 0 3
126022: PPUSH
126023: LD_INT 99999
126025: PPUSH
126026: CALL_OW 277
126030: GO 126005
126032: POP
126033: POP
126034: GO 125989
126036: POP
126037: POP
// end ;
126038: LD_VAR 0 1
126042: RET
// export function hHackSetLevel10 ; var i , j ; begin
126043: LD_INT 0
126045: PPUSH
126046: PPUSH
126047: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
126048: LD_ADDR_VAR 0 2
126052: PUSH
126053: LD_INT 21
126055: PUSH
126056: LD_INT 1
126058: PUSH
126059: EMPTY
126060: LIST
126061: LIST
126062: PPUSH
126063: CALL_OW 69
126067: PUSH
126068: FOR_IN
126069: IFFALSE 126121
// if IsSelected ( i ) then
126071: LD_VAR 0 2
126075: PPUSH
126076: CALL_OW 306
126080: IFFALSE 126119
// begin for j := 1 to 4 do
126082: LD_ADDR_VAR 0 3
126086: PUSH
126087: DOUBLE
126088: LD_INT 1
126090: DEC
126091: ST_TO_ADDR
126092: LD_INT 4
126094: PUSH
126095: FOR_TO
126096: IFFALSE 126117
// SetSkill ( i , j , 10 ) ;
126098: LD_VAR 0 2
126102: PPUSH
126103: LD_VAR 0 3
126107: PPUSH
126108: LD_INT 10
126110: PPUSH
126111: CALL_OW 237
126115: GO 126095
126117: POP
126118: POP
// end ;
126119: GO 126068
126121: POP
126122: POP
// end ;
126123: LD_VAR 0 1
126127: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
126128: LD_INT 0
126130: PPUSH
126131: PPUSH
126132: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
126133: LD_ADDR_VAR 0 2
126137: PUSH
126138: LD_INT 22
126140: PUSH
126141: LD_OWVAR 2
126145: PUSH
126146: EMPTY
126147: LIST
126148: LIST
126149: PUSH
126150: LD_INT 21
126152: PUSH
126153: LD_INT 1
126155: PUSH
126156: EMPTY
126157: LIST
126158: LIST
126159: PUSH
126160: EMPTY
126161: LIST
126162: LIST
126163: PPUSH
126164: CALL_OW 69
126168: PUSH
126169: FOR_IN
126170: IFFALSE 126211
// begin for j := 1 to 4 do
126172: LD_ADDR_VAR 0 3
126176: PUSH
126177: DOUBLE
126178: LD_INT 1
126180: DEC
126181: ST_TO_ADDR
126182: LD_INT 4
126184: PUSH
126185: FOR_TO
126186: IFFALSE 126207
// SetSkill ( i , j , 10 ) ;
126188: LD_VAR 0 2
126192: PPUSH
126193: LD_VAR 0 3
126197: PPUSH
126198: LD_INT 10
126200: PPUSH
126201: CALL_OW 237
126205: GO 126185
126207: POP
126208: POP
// end ;
126209: GO 126169
126211: POP
126212: POP
// end ;
126213: LD_VAR 0 1
126217: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
126218: LD_INT 0
126220: PPUSH
// uc_side := your_side ;
126221: LD_ADDR_OWVAR 20
126225: PUSH
126226: LD_OWVAR 2
126230: ST_TO_ADDR
// uc_nation := nation ;
126231: LD_ADDR_OWVAR 21
126235: PUSH
126236: LD_VAR 0 1
126240: ST_TO_ADDR
// InitHc ;
126241: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
126245: LD_INT 0
126247: PPUSH
126248: LD_VAR 0 2
126252: PPUSH
126253: LD_VAR 0 3
126257: PPUSH
126258: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
126262: LD_VAR 0 4
126266: PPUSH
126267: LD_VAR 0 5
126271: PPUSH
126272: CALL_OW 428
126276: PUSH
126277: LD_INT 0
126279: EQUAL
126280: IFFALSE 126304
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
126282: CALL_OW 44
126286: PPUSH
126287: LD_VAR 0 4
126291: PPUSH
126292: LD_VAR 0 5
126296: PPUSH
126297: LD_INT 1
126299: PPUSH
126300: CALL_OW 48
// end ;
126304: LD_VAR 0 6
126308: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
126309: LD_INT 0
126311: PPUSH
126312: PPUSH
// uc_side := your_side ;
126313: LD_ADDR_OWVAR 20
126317: PUSH
126318: LD_OWVAR 2
126322: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
126323: LD_VAR 0 1
126327: PUSH
126328: LD_INT 1
126330: PUSH
126331: LD_INT 2
126333: PUSH
126334: LD_INT 3
126336: PUSH
126337: LD_INT 4
126339: PUSH
126340: LD_INT 5
126342: PUSH
126343: EMPTY
126344: LIST
126345: LIST
126346: LIST
126347: LIST
126348: LIST
126349: IN
126350: IFFALSE 126362
// uc_nation := nation_american else
126352: LD_ADDR_OWVAR 21
126356: PUSH
126357: LD_INT 1
126359: ST_TO_ADDR
126360: GO 126405
// if chassis in [ 11 , 12 , 13 , 14 ] then
126362: LD_VAR 0 1
126366: PUSH
126367: LD_INT 11
126369: PUSH
126370: LD_INT 12
126372: PUSH
126373: LD_INT 13
126375: PUSH
126376: LD_INT 14
126378: PUSH
126379: EMPTY
126380: LIST
126381: LIST
126382: LIST
126383: LIST
126384: IN
126385: IFFALSE 126397
// uc_nation := nation_arabian else
126387: LD_ADDR_OWVAR 21
126391: PUSH
126392: LD_INT 2
126394: ST_TO_ADDR
126395: GO 126405
// uc_nation := nation_russian ;
126397: LD_ADDR_OWVAR 21
126401: PUSH
126402: LD_INT 3
126404: ST_TO_ADDR
// vc_chassis := chassis ;
126405: LD_ADDR_OWVAR 37
126409: PUSH
126410: LD_VAR 0 1
126414: ST_TO_ADDR
// vc_engine := engine ;
126415: LD_ADDR_OWVAR 39
126419: PUSH
126420: LD_VAR 0 2
126424: ST_TO_ADDR
// vc_control := control ;
126425: LD_ADDR_OWVAR 38
126429: PUSH
126430: LD_VAR 0 3
126434: ST_TO_ADDR
// vc_weapon := weapon ;
126435: LD_ADDR_OWVAR 40
126439: PUSH
126440: LD_VAR 0 4
126444: ST_TO_ADDR
// un := CreateVehicle ;
126445: LD_ADDR_VAR 0 8
126449: PUSH
126450: CALL_OW 45
126454: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
126455: LD_VAR 0 8
126459: PPUSH
126460: LD_INT 0
126462: PPUSH
126463: LD_INT 5
126465: PPUSH
126466: CALL_OW 12
126470: PPUSH
126471: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
126475: LD_VAR 0 8
126479: PPUSH
126480: LD_VAR 0 5
126484: PPUSH
126485: LD_VAR 0 6
126489: PPUSH
126490: LD_INT 1
126492: PPUSH
126493: CALL_OW 48
// end ;
126497: LD_VAR 0 7
126501: RET
// export hInvincible ; every 1 do
126502: GO 126504
126504: DISABLE
// hInvincible := [ ] ;
126505: LD_ADDR_EXP 205
126509: PUSH
126510: EMPTY
126511: ST_TO_ADDR
126512: END
// every 10 do var i ;
126513: GO 126515
126515: DISABLE
126516: LD_INT 0
126518: PPUSH
// begin enable ;
126519: ENABLE
// if not hInvincible then
126520: LD_EXP 205
126524: NOT
126525: IFFALSE 126529
// exit ;
126527: GO 126573
// for i in hInvincible do
126529: LD_ADDR_VAR 0 1
126533: PUSH
126534: LD_EXP 205
126538: PUSH
126539: FOR_IN
126540: IFFALSE 126571
// if GetLives ( i ) < 1000 then
126542: LD_VAR 0 1
126546: PPUSH
126547: CALL_OW 256
126551: PUSH
126552: LD_INT 1000
126554: LESS
126555: IFFALSE 126569
// SetLives ( i , 1000 ) ;
126557: LD_VAR 0 1
126561: PPUSH
126562: LD_INT 1000
126564: PPUSH
126565: CALL_OW 234
126569: GO 126539
126571: POP
126572: POP
// end ;
126573: PPOPN 1
126575: END
// export function hHackInvincible ; var i ; begin
126576: LD_INT 0
126578: PPUSH
126579: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
126580: LD_ADDR_VAR 0 2
126584: PUSH
126585: LD_INT 2
126587: PUSH
126588: LD_INT 21
126590: PUSH
126591: LD_INT 1
126593: PUSH
126594: EMPTY
126595: LIST
126596: LIST
126597: PUSH
126598: LD_INT 21
126600: PUSH
126601: LD_INT 2
126603: PUSH
126604: EMPTY
126605: LIST
126606: LIST
126607: PUSH
126608: EMPTY
126609: LIST
126610: LIST
126611: LIST
126612: PPUSH
126613: CALL_OW 69
126617: PUSH
126618: FOR_IN
126619: IFFALSE 126680
// if IsSelected ( i ) then
126621: LD_VAR 0 2
126625: PPUSH
126626: CALL_OW 306
126630: IFFALSE 126678
// begin if i in hInvincible then
126632: LD_VAR 0 2
126636: PUSH
126637: LD_EXP 205
126641: IN
126642: IFFALSE 126662
// hInvincible := hInvincible diff i else
126644: LD_ADDR_EXP 205
126648: PUSH
126649: LD_EXP 205
126653: PUSH
126654: LD_VAR 0 2
126658: DIFF
126659: ST_TO_ADDR
126660: GO 126678
// hInvincible := hInvincible union i ;
126662: LD_ADDR_EXP 205
126666: PUSH
126667: LD_EXP 205
126671: PUSH
126672: LD_VAR 0 2
126676: UNION
126677: ST_TO_ADDR
// end ;
126678: GO 126618
126680: POP
126681: POP
// end ;
126682: LD_VAR 0 1
126686: RET
// export function hHackInvisible ; var i , j ; begin
126687: LD_INT 0
126689: PPUSH
126690: PPUSH
126691: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
126692: LD_ADDR_VAR 0 2
126696: PUSH
126697: LD_INT 21
126699: PUSH
126700: LD_INT 1
126702: PUSH
126703: EMPTY
126704: LIST
126705: LIST
126706: PPUSH
126707: CALL_OW 69
126711: PUSH
126712: FOR_IN
126713: IFFALSE 126737
// if IsSelected ( i ) then
126715: LD_VAR 0 2
126719: PPUSH
126720: CALL_OW 306
126724: IFFALSE 126735
// ComForceInvisible ( i ) ;
126726: LD_VAR 0 2
126730: PPUSH
126731: CALL_OW 496
126735: GO 126712
126737: POP
126738: POP
// end ;
126739: LD_VAR 0 1
126743: RET
// export function hHackChangeYourSide ; begin
126744: LD_INT 0
126746: PPUSH
// if your_side = 8 then
126747: LD_OWVAR 2
126751: PUSH
126752: LD_INT 8
126754: EQUAL
126755: IFFALSE 126767
// your_side := 0 else
126757: LD_ADDR_OWVAR 2
126761: PUSH
126762: LD_INT 0
126764: ST_TO_ADDR
126765: GO 126781
// your_side := your_side + 1 ;
126767: LD_ADDR_OWVAR 2
126771: PUSH
126772: LD_OWVAR 2
126776: PUSH
126777: LD_INT 1
126779: PLUS
126780: ST_TO_ADDR
// end ;
126781: LD_VAR 0 1
126785: RET
// export function hHackChangeUnitSide ; var i , j ; begin
126786: LD_INT 0
126788: PPUSH
126789: PPUSH
126790: PPUSH
// for i in all_units do
126791: LD_ADDR_VAR 0 2
126795: PUSH
126796: LD_OWVAR 3
126800: PUSH
126801: FOR_IN
126802: IFFALSE 126880
// if IsSelected ( i ) then
126804: LD_VAR 0 2
126808: PPUSH
126809: CALL_OW 306
126813: IFFALSE 126878
// begin j := GetSide ( i ) ;
126815: LD_ADDR_VAR 0 3
126819: PUSH
126820: LD_VAR 0 2
126824: PPUSH
126825: CALL_OW 255
126829: ST_TO_ADDR
// if j = 8 then
126830: LD_VAR 0 3
126834: PUSH
126835: LD_INT 8
126837: EQUAL
126838: IFFALSE 126850
// j := 0 else
126840: LD_ADDR_VAR 0 3
126844: PUSH
126845: LD_INT 0
126847: ST_TO_ADDR
126848: GO 126864
// j := j + 1 ;
126850: LD_ADDR_VAR 0 3
126854: PUSH
126855: LD_VAR 0 3
126859: PUSH
126860: LD_INT 1
126862: PLUS
126863: ST_TO_ADDR
// SetSide ( i , j ) ;
126864: LD_VAR 0 2
126868: PPUSH
126869: LD_VAR 0 3
126873: PPUSH
126874: CALL_OW 235
// end ;
126878: GO 126801
126880: POP
126881: POP
// end ;
126882: LD_VAR 0 1
126886: RET
// export function hHackFog ; begin
126887: LD_INT 0
126889: PPUSH
// FogOff ( true ) ;
126890: LD_INT 1
126892: PPUSH
126893: CALL_OW 344
// end ;
126897: LD_VAR 0 1
126901: RET
// export function hHackTeleport ( unit , x , y ) ; begin
126902: LD_INT 0
126904: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
126905: LD_VAR 0 1
126909: PPUSH
126910: LD_VAR 0 2
126914: PPUSH
126915: LD_VAR 0 3
126919: PPUSH
126920: LD_INT 1
126922: PPUSH
126923: LD_INT 1
126925: PPUSH
126926: CALL_OW 483
// CenterOnXY ( x , y ) ;
126930: LD_VAR 0 2
126934: PPUSH
126935: LD_VAR 0 3
126939: PPUSH
126940: CALL_OW 84
// end ;
126944: LD_VAR 0 4
126948: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
126949: LD_INT 0
126951: PPUSH
126952: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
126953: LD_VAR 0 1
126957: NOT
126958: PUSH
126959: LD_VAR 0 2
126963: PPUSH
126964: LD_VAR 0 3
126968: PPUSH
126969: CALL_OW 488
126973: NOT
126974: OR
126975: PUSH
126976: LD_VAR 0 1
126980: PPUSH
126981: CALL_OW 266
126985: PUSH
126986: LD_INT 3
126988: NONEQUAL
126989: PUSH
126990: LD_VAR 0 1
126994: PPUSH
126995: CALL_OW 247
126999: PUSH
127000: LD_INT 1
127002: EQUAL
127003: NOT
127004: AND
127005: OR
127006: IFFALSE 127010
// exit ;
127008: GO 127159
// if GetType ( factory ) = unit_human then
127010: LD_VAR 0 1
127014: PPUSH
127015: CALL_OW 247
127019: PUSH
127020: LD_INT 1
127022: EQUAL
127023: IFFALSE 127040
// factory := IsInUnit ( factory ) ;
127025: LD_ADDR_VAR 0 1
127029: PUSH
127030: LD_VAR 0 1
127034: PPUSH
127035: CALL_OW 310
127039: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
127040: LD_VAR 0 1
127044: PPUSH
127045: CALL_OW 266
127049: PUSH
127050: LD_INT 3
127052: NONEQUAL
127053: IFFALSE 127057
// exit ;
127055: GO 127159
// if HexInfo ( x , y ) = factory then
127057: LD_VAR 0 2
127061: PPUSH
127062: LD_VAR 0 3
127066: PPUSH
127067: CALL_OW 428
127071: PUSH
127072: LD_VAR 0 1
127076: EQUAL
127077: IFFALSE 127104
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
127079: LD_ADDR_EXP 206
127083: PUSH
127084: LD_EXP 206
127088: PPUSH
127089: LD_VAR 0 1
127093: PPUSH
127094: LD_INT 0
127096: PPUSH
127097: CALL_OW 1
127101: ST_TO_ADDR
127102: GO 127155
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
127104: LD_ADDR_EXP 206
127108: PUSH
127109: LD_EXP 206
127113: PPUSH
127114: LD_VAR 0 1
127118: PPUSH
127119: LD_VAR 0 1
127123: PPUSH
127124: CALL_OW 255
127128: PUSH
127129: LD_VAR 0 1
127133: PUSH
127134: LD_VAR 0 2
127138: PUSH
127139: LD_VAR 0 3
127143: PUSH
127144: EMPTY
127145: LIST
127146: LIST
127147: LIST
127148: LIST
127149: PPUSH
127150: CALL_OW 1
127154: ST_TO_ADDR
// UpdateFactoryWaypoints ;
127155: CALL 127164 0 0
// end ;
127159: LD_VAR 0 4
127163: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
127164: LD_INT 0
127166: PPUSH
127167: PPUSH
127168: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
127169: LD_STRING resetFactoryWaypoint();
127171: PPUSH
127172: CALL_OW 559
// if factoryWaypoints then
127176: LD_EXP 206
127180: IFFALSE 127306
// begin list := PrepareArray ( factoryWaypoints ) ;
127182: LD_ADDR_VAR 0 3
127186: PUSH
127187: LD_EXP 206
127191: PPUSH
127192: CALL 111119 0 1
127196: ST_TO_ADDR
// for i := 1 to list do
127197: LD_ADDR_VAR 0 2
127201: PUSH
127202: DOUBLE
127203: LD_INT 1
127205: DEC
127206: ST_TO_ADDR
127207: LD_VAR 0 3
127211: PUSH
127212: FOR_TO
127213: IFFALSE 127304
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
127215: LD_STRING setFactoryWaypointXY(
127217: PUSH
127218: LD_VAR 0 3
127222: PUSH
127223: LD_VAR 0 2
127227: ARRAY
127228: PUSH
127229: LD_INT 1
127231: ARRAY
127232: STR
127233: PUSH
127234: LD_STRING ,
127236: STR
127237: PUSH
127238: LD_VAR 0 3
127242: PUSH
127243: LD_VAR 0 2
127247: ARRAY
127248: PUSH
127249: LD_INT 2
127251: ARRAY
127252: STR
127253: PUSH
127254: LD_STRING ,
127256: STR
127257: PUSH
127258: LD_VAR 0 3
127262: PUSH
127263: LD_VAR 0 2
127267: ARRAY
127268: PUSH
127269: LD_INT 3
127271: ARRAY
127272: STR
127273: PUSH
127274: LD_STRING ,
127276: STR
127277: PUSH
127278: LD_VAR 0 3
127282: PUSH
127283: LD_VAR 0 2
127287: ARRAY
127288: PUSH
127289: LD_INT 4
127291: ARRAY
127292: STR
127293: PUSH
127294: LD_STRING )
127296: STR
127297: PPUSH
127298: CALL_OW 559
127302: GO 127212
127304: POP
127305: POP
// end ; end ;
127306: LD_VAR 0 1
127310: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
127311: LD_INT 0
127313: PPUSH
// if HexInfo ( x , y ) = warehouse then
127314: LD_VAR 0 2
127318: PPUSH
127319: LD_VAR 0 3
127323: PPUSH
127324: CALL_OW 428
127328: PUSH
127329: LD_VAR 0 1
127333: EQUAL
127334: IFFALSE 127361
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
127336: LD_ADDR_EXP 207
127340: PUSH
127341: LD_EXP 207
127345: PPUSH
127346: LD_VAR 0 1
127350: PPUSH
127351: LD_INT 0
127353: PPUSH
127354: CALL_OW 1
127358: ST_TO_ADDR
127359: GO 127412
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
127361: LD_ADDR_EXP 207
127365: PUSH
127366: LD_EXP 207
127370: PPUSH
127371: LD_VAR 0 1
127375: PPUSH
127376: LD_VAR 0 1
127380: PPUSH
127381: CALL_OW 255
127385: PUSH
127386: LD_VAR 0 1
127390: PUSH
127391: LD_VAR 0 2
127395: PUSH
127396: LD_VAR 0 3
127400: PUSH
127401: EMPTY
127402: LIST
127403: LIST
127404: LIST
127405: LIST
127406: PPUSH
127407: CALL_OW 1
127411: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
127412: CALL 127421 0 0
// end ;
127416: LD_VAR 0 4
127420: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
127421: LD_INT 0
127423: PPUSH
127424: PPUSH
127425: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
127426: LD_STRING resetWarehouseGatheringPoints();
127428: PPUSH
127429: CALL_OW 559
// if warehouseGatheringPoints then
127433: LD_EXP 207
127437: IFFALSE 127563
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
127439: LD_ADDR_VAR 0 3
127443: PUSH
127444: LD_EXP 207
127448: PPUSH
127449: CALL 111119 0 1
127453: ST_TO_ADDR
// for i := 1 to list do
127454: LD_ADDR_VAR 0 2
127458: PUSH
127459: DOUBLE
127460: LD_INT 1
127462: DEC
127463: ST_TO_ADDR
127464: LD_VAR 0 3
127468: PUSH
127469: FOR_TO
127470: IFFALSE 127561
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
127472: LD_STRING setWarehouseGatheringPointXY(
127474: PUSH
127475: LD_VAR 0 3
127479: PUSH
127480: LD_VAR 0 2
127484: ARRAY
127485: PUSH
127486: LD_INT 1
127488: ARRAY
127489: STR
127490: PUSH
127491: LD_STRING ,
127493: STR
127494: PUSH
127495: LD_VAR 0 3
127499: PUSH
127500: LD_VAR 0 2
127504: ARRAY
127505: PUSH
127506: LD_INT 2
127508: ARRAY
127509: STR
127510: PUSH
127511: LD_STRING ,
127513: STR
127514: PUSH
127515: LD_VAR 0 3
127519: PUSH
127520: LD_VAR 0 2
127524: ARRAY
127525: PUSH
127526: LD_INT 3
127528: ARRAY
127529: STR
127530: PUSH
127531: LD_STRING ,
127533: STR
127534: PUSH
127535: LD_VAR 0 3
127539: PUSH
127540: LD_VAR 0 2
127544: ARRAY
127545: PUSH
127546: LD_INT 4
127548: ARRAY
127549: STR
127550: PUSH
127551: LD_STRING )
127553: STR
127554: PPUSH
127555: CALL_OW 559
127559: GO 127469
127561: POP
127562: POP
// end ; end ;
127563: LD_VAR 0 1
127567: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
127568: LD_EXP 207
127572: IFFALSE 128257
127574: GO 127576
127576: DISABLE
127577: LD_INT 0
127579: PPUSH
127580: PPUSH
127581: PPUSH
127582: PPUSH
127583: PPUSH
127584: PPUSH
127585: PPUSH
127586: PPUSH
127587: PPUSH
// begin enable ;
127588: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
127589: LD_ADDR_VAR 0 3
127593: PUSH
127594: LD_EXP 207
127598: PPUSH
127599: CALL 111119 0 1
127603: ST_TO_ADDR
// if not list then
127604: LD_VAR 0 3
127608: NOT
127609: IFFALSE 127613
// exit ;
127611: GO 128257
// for i := 1 to list do
127613: LD_ADDR_VAR 0 1
127617: PUSH
127618: DOUBLE
127619: LD_INT 1
127621: DEC
127622: ST_TO_ADDR
127623: LD_VAR 0 3
127627: PUSH
127628: FOR_TO
127629: IFFALSE 128255
// begin depot := list [ i ] [ 2 ] ;
127631: LD_ADDR_VAR 0 8
127635: PUSH
127636: LD_VAR 0 3
127640: PUSH
127641: LD_VAR 0 1
127645: ARRAY
127646: PUSH
127647: LD_INT 2
127649: ARRAY
127650: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
127651: LD_ADDR_VAR 0 5
127655: PUSH
127656: LD_VAR 0 3
127660: PUSH
127661: LD_VAR 0 1
127665: ARRAY
127666: PUSH
127667: LD_INT 1
127669: ARRAY
127670: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
127671: LD_VAR 0 8
127675: PPUSH
127676: CALL_OW 301
127680: PUSH
127681: LD_VAR 0 5
127685: PUSH
127686: LD_VAR 0 8
127690: PPUSH
127691: CALL_OW 255
127695: NONEQUAL
127696: OR
127697: IFFALSE 127726
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
127699: LD_ADDR_EXP 207
127703: PUSH
127704: LD_EXP 207
127708: PPUSH
127709: LD_VAR 0 8
127713: PPUSH
127714: LD_INT 0
127716: PPUSH
127717: CALL_OW 1
127721: ST_TO_ADDR
// exit ;
127722: POP
127723: POP
127724: GO 128257
// end ; x := list [ i ] [ 3 ] ;
127726: LD_ADDR_VAR 0 6
127730: PUSH
127731: LD_VAR 0 3
127735: PUSH
127736: LD_VAR 0 1
127740: ARRAY
127741: PUSH
127742: LD_INT 3
127744: ARRAY
127745: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
127746: LD_ADDR_VAR 0 7
127750: PUSH
127751: LD_VAR 0 3
127755: PUSH
127756: LD_VAR 0 1
127760: ARRAY
127761: PUSH
127762: LD_INT 4
127764: ARRAY
127765: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
127766: LD_ADDR_VAR 0 9
127770: PUSH
127771: LD_VAR 0 6
127775: PPUSH
127776: LD_VAR 0 7
127780: PPUSH
127781: LD_INT 16
127783: PPUSH
127784: CALL 109707 0 3
127788: ST_TO_ADDR
// if not cratesNearbyPoint then
127789: LD_VAR 0 9
127793: NOT
127794: IFFALSE 127800
// exit ;
127796: POP
127797: POP
127798: GO 128257
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
127800: LD_ADDR_VAR 0 4
127804: PUSH
127805: LD_INT 22
127807: PUSH
127808: LD_VAR 0 5
127812: PUSH
127813: EMPTY
127814: LIST
127815: LIST
127816: PUSH
127817: LD_INT 3
127819: PUSH
127820: LD_INT 60
127822: PUSH
127823: EMPTY
127824: LIST
127825: PUSH
127826: EMPTY
127827: LIST
127828: LIST
127829: PUSH
127830: LD_INT 91
127832: PUSH
127833: LD_VAR 0 8
127837: PUSH
127838: LD_INT 6
127840: PUSH
127841: EMPTY
127842: LIST
127843: LIST
127844: LIST
127845: PUSH
127846: LD_INT 2
127848: PUSH
127849: LD_INT 25
127851: PUSH
127852: LD_INT 2
127854: PUSH
127855: EMPTY
127856: LIST
127857: LIST
127858: PUSH
127859: LD_INT 25
127861: PUSH
127862: LD_INT 16
127864: PUSH
127865: EMPTY
127866: LIST
127867: LIST
127868: PUSH
127869: EMPTY
127870: LIST
127871: LIST
127872: LIST
127873: PUSH
127874: EMPTY
127875: LIST
127876: LIST
127877: LIST
127878: LIST
127879: PPUSH
127880: CALL_OW 69
127884: PUSH
127885: LD_VAR 0 8
127889: PPUSH
127890: CALL_OW 313
127894: PPUSH
127895: LD_INT 3
127897: PUSH
127898: LD_INT 60
127900: PUSH
127901: EMPTY
127902: LIST
127903: PUSH
127904: EMPTY
127905: LIST
127906: LIST
127907: PUSH
127908: LD_INT 2
127910: PUSH
127911: LD_INT 25
127913: PUSH
127914: LD_INT 2
127916: PUSH
127917: EMPTY
127918: LIST
127919: LIST
127920: PUSH
127921: LD_INT 25
127923: PUSH
127924: LD_INT 16
127926: PUSH
127927: EMPTY
127928: LIST
127929: LIST
127930: PUSH
127931: EMPTY
127932: LIST
127933: LIST
127934: LIST
127935: PUSH
127936: EMPTY
127937: LIST
127938: LIST
127939: PPUSH
127940: CALL_OW 72
127944: UNION
127945: ST_TO_ADDR
// if tmp then
127946: LD_VAR 0 4
127950: IFFALSE 128030
// begin tmp := ShrinkArray ( tmp , 3 ) ;
127952: LD_ADDR_VAR 0 4
127956: PUSH
127957: LD_VAR 0 4
127961: PPUSH
127962: LD_INT 3
127964: PPUSH
127965: CALL 107676 0 2
127969: ST_TO_ADDR
// for j in tmp do
127970: LD_ADDR_VAR 0 2
127974: PUSH
127975: LD_VAR 0 4
127979: PUSH
127980: FOR_IN
127981: IFFALSE 128024
// begin if IsInUnit ( j ) then
127983: LD_VAR 0 2
127987: PPUSH
127988: CALL_OW 310
127992: IFFALSE 128003
// ComExit ( j ) ;
127994: LD_VAR 0 2
127998: PPUSH
127999: CALL 107759 0 1
// AddComCollect ( j , x , y ) ;
128003: LD_VAR 0 2
128007: PPUSH
128008: LD_VAR 0 6
128012: PPUSH
128013: LD_VAR 0 7
128017: PPUSH
128018: CALL_OW 177
// end ;
128022: GO 127980
128024: POP
128025: POP
// exit ;
128026: POP
128027: POP
128028: GO 128257
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
128030: LD_ADDR_VAR 0 4
128034: PUSH
128035: LD_INT 22
128037: PUSH
128038: LD_VAR 0 5
128042: PUSH
128043: EMPTY
128044: LIST
128045: LIST
128046: PUSH
128047: LD_INT 91
128049: PUSH
128050: LD_VAR 0 8
128054: PUSH
128055: LD_INT 8
128057: PUSH
128058: EMPTY
128059: LIST
128060: LIST
128061: LIST
128062: PUSH
128063: LD_INT 2
128065: PUSH
128066: LD_INT 34
128068: PUSH
128069: LD_INT 12
128071: PUSH
128072: EMPTY
128073: LIST
128074: LIST
128075: PUSH
128076: LD_INT 34
128078: PUSH
128079: LD_INT 51
128081: PUSH
128082: EMPTY
128083: LIST
128084: LIST
128085: PUSH
128086: LD_INT 34
128088: PUSH
128089: LD_INT 32
128091: PUSH
128092: EMPTY
128093: LIST
128094: LIST
128095: PUSH
128096: LD_INT 34
128098: PUSH
128099: LD_INT 89
128101: PUSH
128102: EMPTY
128103: LIST
128104: LIST
128105: PUSH
128106: EMPTY
128107: LIST
128108: LIST
128109: LIST
128110: LIST
128111: LIST
128112: PUSH
128113: EMPTY
128114: LIST
128115: LIST
128116: LIST
128117: PPUSH
128118: CALL_OW 69
128122: ST_TO_ADDR
// if tmp then
128123: LD_VAR 0 4
128127: IFFALSE 128253
// begin for j in tmp do
128129: LD_ADDR_VAR 0 2
128133: PUSH
128134: LD_VAR 0 4
128138: PUSH
128139: FOR_IN
128140: IFFALSE 128251
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
128142: LD_VAR 0 2
128146: PPUSH
128147: CALL_OW 262
128151: PUSH
128152: LD_INT 3
128154: EQUAL
128155: PUSH
128156: LD_VAR 0 2
128160: PPUSH
128161: CALL_OW 261
128165: PUSH
128166: LD_INT 20
128168: GREATER
128169: OR
128170: PUSH
128171: LD_VAR 0 2
128175: PPUSH
128176: CALL_OW 314
128180: NOT
128181: AND
128182: PUSH
128183: LD_VAR 0 2
128187: PPUSH
128188: CALL_OW 263
128192: PUSH
128193: LD_INT 1
128195: NONEQUAL
128196: PUSH
128197: LD_VAR 0 2
128201: PPUSH
128202: CALL_OW 311
128206: OR
128207: AND
128208: IFFALSE 128249
// begin ComCollect ( j , x , y ) ;
128210: LD_VAR 0 2
128214: PPUSH
128215: LD_VAR 0 6
128219: PPUSH
128220: LD_VAR 0 7
128224: PPUSH
128225: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
128229: LD_VAR 0 2
128233: PPUSH
128234: LD_VAR 0 8
128238: PPUSH
128239: CALL_OW 172
// exit ;
128243: POP
128244: POP
128245: POP
128246: POP
128247: GO 128257
// end ;
128249: GO 128139
128251: POP
128252: POP
// end ; end ;
128253: GO 127628
128255: POP
128256: POP
// end ; end_of_file
128257: PPOPN 9
128259: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
128260: LD_INT 0
128262: PPUSH
128263: PPUSH
128264: PPUSH
128265: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
128266: LD_VAR 0 1
128270: PPUSH
128271: CALL_OW 264
128275: PUSH
128276: LD_INT 91
128278: EQUAL
128279: IFFALSE 128351
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
128281: LD_INT 68
128283: PPUSH
128284: LD_VAR 0 1
128288: PPUSH
128289: CALL_OW 255
128293: PPUSH
128294: CALL_OW 321
128298: PUSH
128299: LD_INT 2
128301: EQUAL
128302: IFFALSE 128314
// eff := 70 else
128304: LD_ADDR_VAR 0 4
128308: PUSH
128309: LD_INT 70
128311: ST_TO_ADDR
128312: GO 128322
// eff := 30 ;
128314: LD_ADDR_VAR 0 4
128318: PUSH
128319: LD_INT 30
128321: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
128322: LD_VAR 0 1
128326: PPUSH
128327: CALL_OW 250
128331: PPUSH
128332: LD_VAR 0 1
128336: PPUSH
128337: CALL_OW 251
128341: PPUSH
128342: LD_VAR 0 4
128346: PPUSH
128347: CALL_OW 495
// end ; end ;
128351: LD_VAR 0 2
128355: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
128356: LD_INT 0
128358: PPUSH
// end ;
128359: LD_VAR 0 4
128363: RET
// export function SOS_Command ( cmd ) ; begin
128364: LD_INT 0
128366: PPUSH
// end ;
128367: LD_VAR 0 2
128371: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
128372: LD_INT 0
128374: PPUSH
// end ;
128375: LD_VAR 0 6
128379: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
128380: LD_INT 0
128382: PPUSH
128383: PPUSH
// if not vehicle or not factory then
128384: LD_VAR 0 1
128388: NOT
128389: PUSH
128390: LD_VAR 0 2
128394: NOT
128395: OR
128396: IFFALSE 128400
// exit ;
128398: GO 128631
// if factoryWaypoints >= factory then
128400: LD_EXP 206
128404: PUSH
128405: LD_VAR 0 2
128409: GREATEREQUAL
128410: IFFALSE 128631
// if factoryWaypoints [ factory ] then
128412: LD_EXP 206
128416: PUSH
128417: LD_VAR 0 2
128421: ARRAY
128422: IFFALSE 128631
// begin if GetControl ( vehicle ) = control_manual then
128424: LD_VAR 0 1
128428: PPUSH
128429: CALL_OW 263
128433: PUSH
128434: LD_INT 1
128436: EQUAL
128437: IFFALSE 128518
// begin driver := IsDrivenBy ( vehicle ) ;
128439: LD_ADDR_VAR 0 4
128443: PUSH
128444: LD_VAR 0 1
128448: PPUSH
128449: CALL_OW 311
128453: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
128454: LD_VAR 0 4
128458: PPUSH
128459: LD_EXP 206
128463: PUSH
128464: LD_VAR 0 2
128468: ARRAY
128469: PUSH
128470: LD_INT 3
128472: ARRAY
128473: PPUSH
128474: LD_EXP 206
128478: PUSH
128479: LD_VAR 0 2
128483: ARRAY
128484: PUSH
128485: LD_INT 4
128487: ARRAY
128488: PPUSH
128489: CALL_OW 171
// AddComExitVehicle ( driver ) ;
128493: LD_VAR 0 4
128497: PPUSH
128498: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
128502: LD_VAR 0 4
128506: PPUSH
128507: LD_VAR 0 2
128511: PPUSH
128512: CALL_OW 180
// end else
128516: GO 128631
// if GetControl ( vehicle ) = control_remote then
128518: LD_VAR 0 1
128522: PPUSH
128523: CALL_OW 263
128527: PUSH
128528: LD_INT 2
128530: EQUAL
128531: IFFALSE 128592
// begin wait ( 0 0$2 ) ;
128533: LD_INT 70
128535: PPUSH
128536: CALL_OW 67
// if Connect ( vehicle ) then
128540: LD_VAR 0 1
128544: PPUSH
128545: CALL 77978 0 1
128549: IFFALSE 128590
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
128551: LD_VAR 0 1
128555: PPUSH
128556: LD_EXP 206
128560: PUSH
128561: LD_VAR 0 2
128565: ARRAY
128566: PUSH
128567: LD_INT 3
128569: ARRAY
128570: PPUSH
128571: LD_EXP 206
128575: PUSH
128576: LD_VAR 0 2
128580: ARRAY
128581: PUSH
128582: LD_INT 4
128584: ARRAY
128585: PPUSH
128586: CALL_OW 171
// end else
128590: GO 128631
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
128592: LD_VAR 0 1
128596: PPUSH
128597: LD_EXP 206
128601: PUSH
128602: LD_VAR 0 2
128606: ARRAY
128607: PUSH
128608: LD_INT 3
128610: ARRAY
128611: PPUSH
128612: LD_EXP 206
128616: PUSH
128617: LD_VAR 0 2
128621: ARRAY
128622: PUSH
128623: LD_INT 4
128625: ARRAY
128626: PPUSH
128627: CALL_OW 171
// end ; end ;
128631: LD_VAR 0 3
128635: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
128636: LD_INT 0
128638: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
128639: LD_VAR 0 1
128643: PUSH
128644: LD_INT 250
128646: EQUAL
128647: PUSH
128648: LD_VAR 0 2
128652: PPUSH
128653: CALL_OW 264
128657: PUSH
128658: LD_INT 81
128660: EQUAL
128661: AND
128662: IFFALSE 128683
// MinerPlaceMine ( unit , x , y ) ;
128664: LD_VAR 0 2
128668: PPUSH
128669: LD_VAR 0 4
128673: PPUSH
128674: LD_VAR 0 5
128678: PPUSH
128679: CALL 131673 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
128683: LD_VAR 0 1
128687: PUSH
128688: LD_INT 251
128690: EQUAL
128691: PUSH
128692: LD_VAR 0 2
128696: PPUSH
128697: CALL_OW 264
128701: PUSH
128702: LD_INT 81
128704: EQUAL
128705: AND
128706: IFFALSE 128727
// MinerDetonateMine ( unit , x , y ) ;
128708: LD_VAR 0 2
128712: PPUSH
128713: LD_VAR 0 4
128717: PPUSH
128718: LD_VAR 0 5
128722: PPUSH
128723: CALL 131948 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
128727: LD_VAR 0 1
128731: PUSH
128732: LD_INT 252
128734: EQUAL
128735: PUSH
128736: LD_VAR 0 2
128740: PPUSH
128741: CALL_OW 264
128745: PUSH
128746: LD_INT 81
128748: EQUAL
128749: AND
128750: IFFALSE 128771
// MinerCreateMinefield ( unit , x , y ) ;
128752: LD_VAR 0 2
128756: PPUSH
128757: LD_VAR 0 4
128761: PPUSH
128762: LD_VAR 0 5
128766: PPUSH
128767: CALL 132365 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
128771: LD_VAR 0 1
128775: PUSH
128776: LD_INT 253
128778: EQUAL
128779: PUSH
128780: LD_VAR 0 2
128784: PPUSH
128785: CALL_OW 257
128789: PUSH
128790: LD_INT 5
128792: EQUAL
128793: AND
128794: IFFALSE 128815
// ComBinocular ( unit , x , y ) ;
128796: LD_VAR 0 2
128800: PPUSH
128801: LD_VAR 0 4
128805: PPUSH
128806: LD_VAR 0 5
128810: PPUSH
128811: CALL 132734 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
128815: LD_VAR 0 1
128819: PUSH
128820: LD_INT 254
128822: EQUAL
128823: PUSH
128824: LD_VAR 0 2
128828: PPUSH
128829: CALL_OW 264
128833: PUSH
128834: LD_INT 99
128836: EQUAL
128837: AND
128838: PUSH
128839: LD_VAR 0 3
128843: PPUSH
128844: CALL_OW 263
128848: PUSH
128849: LD_INT 3
128851: EQUAL
128852: AND
128853: IFFALSE 128869
// HackDestroyVehicle ( unit , selectedUnit ) ;
128855: LD_VAR 0 2
128859: PPUSH
128860: LD_VAR 0 3
128864: PPUSH
128865: CALL 131037 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
128869: LD_VAR 0 1
128873: PUSH
128874: LD_INT 255
128876: EQUAL
128877: PUSH
128878: LD_VAR 0 2
128882: PPUSH
128883: CALL_OW 264
128887: PUSH
128888: LD_INT 14
128890: PUSH
128891: LD_INT 53
128893: PUSH
128894: EMPTY
128895: LIST
128896: LIST
128897: IN
128898: AND
128899: PUSH
128900: LD_VAR 0 4
128904: PPUSH
128905: LD_VAR 0 5
128909: PPUSH
128910: CALL_OW 488
128914: AND
128915: IFFALSE 128939
// CutTreeXYR ( unit , x , y , 12 ) ;
128917: LD_VAR 0 2
128921: PPUSH
128922: LD_VAR 0 4
128926: PPUSH
128927: LD_VAR 0 5
128931: PPUSH
128932: LD_INT 12
128934: PPUSH
128935: CALL 129034 0 4
// if cmd = 256 then
128939: LD_VAR 0 1
128943: PUSH
128944: LD_INT 256
128946: EQUAL
128947: IFFALSE 128968
// SetFactoryWaypoint ( unit , x , y ) ;
128949: LD_VAR 0 2
128953: PPUSH
128954: LD_VAR 0 4
128958: PPUSH
128959: LD_VAR 0 5
128963: PPUSH
128964: CALL 126949 0 3
// if cmd = 257 then
128968: LD_VAR 0 1
128972: PUSH
128973: LD_INT 257
128975: EQUAL
128976: IFFALSE 128997
// SetWarehouseGatheringPoint ( unit , x , y ) ;
128978: LD_VAR 0 2
128982: PPUSH
128983: LD_VAR 0 4
128987: PPUSH
128988: LD_VAR 0 5
128992: PPUSH
128993: CALL 127311 0 3
// if cmd = 258 then
128997: LD_VAR 0 1
129001: PUSH
129002: LD_INT 258
129004: EQUAL
129005: IFFALSE 129029
// BurnTreeXYR ( unit , x , y , 8 ) ;
129007: LD_VAR 0 2
129011: PPUSH
129012: LD_VAR 0 4
129016: PPUSH
129017: LD_VAR 0 5
129021: PPUSH
129022: LD_INT 8
129024: PPUSH
129025: CALL 129428 0 4
// end ;
129029: LD_VAR 0 6
129033: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
129034: LD_INT 0
129036: PPUSH
129037: PPUSH
129038: PPUSH
129039: PPUSH
129040: PPUSH
129041: PPUSH
129042: PPUSH
129043: PPUSH
129044: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
129045: LD_VAR 0 1
129049: PPUSH
129050: CALL_OW 302
129054: NOT
129055: PUSH
129056: LD_VAR 0 2
129060: PPUSH
129061: LD_VAR 0 3
129065: PPUSH
129066: CALL_OW 488
129070: NOT
129071: OR
129072: PUSH
129073: LD_VAR 0 4
129077: NOT
129078: OR
129079: IFFALSE 129083
// exit ;
129081: GO 129423
// list := [ ] ;
129083: LD_ADDR_VAR 0 13
129087: PUSH
129088: EMPTY
129089: ST_TO_ADDR
// if x - r < 0 then
129090: LD_VAR 0 2
129094: PUSH
129095: LD_VAR 0 4
129099: MINUS
129100: PUSH
129101: LD_INT 0
129103: LESS
129104: IFFALSE 129116
// min_x := 0 else
129106: LD_ADDR_VAR 0 7
129110: PUSH
129111: LD_INT 0
129113: ST_TO_ADDR
129114: GO 129132
// min_x := x - r ;
129116: LD_ADDR_VAR 0 7
129120: PUSH
129121: LD_VAR 0 2
129125: PUSH
129126: LD_VAR 0 4
129130: MINUS
129131: ST_TO_ADDR
// if y - r < 0 then
129132: LD_VAR 0 3
129136: PUSH
129137: LD_VAR 0 4
129141: MINUS
129142: PUSH
129143: LD_INT 0
129145: LESS
129146: IFFALSE 129158
// min_y := 0 else
129148: LD_ADDR_VAR 0 8
129152: PUSH
129153: LD_INT 0
129155: ST_TO_ADDR
129156: GO 129174
// min_y := y - r ;
129158: LD_ADDR_VAR 0 8
129162: PUSH
129163: LD_VAR 0 3
129167: PUSH
129168: LD_VAR 0 4
129172: MINUS
129173: ST_TO_ADDR
// max_x := x + r ;
129174: LD_ADDR_VAR 0 9
129178: PUSH
129179: LD_VAR 0 2
129183: PUSH
129184: LD_VAR 0 4
129188: PLUS
129189: ST_TO_ADDR
// max_y := y + r ;
129190: LD_ADDR_VAR 0 10
129194: PUSH
129195: LD_VAR 0 3
129199: PUSH
129200: LD_VAR 0 4
129204: PLUS
129205: ST_TO_ADDR
// for _x = min_x to max_x do
129206: LD_ADDR_VAR 0 11
129210: PUSH
129211: DOUBLE
129212: LD_VAR 0 7
129216: DEC
129217: ST_TO_ADDR
129218: LD_VAR 0 9
129222: PUSH
129223: FOR_TO
129224: IFFALSE 129341
// for _y = min_y to max_y do
129226: LD_ADDR_VAR 0 12
129230: PUSH
129231: DOUBLE
129232: LD_VAR 0 8
129236: DEC
129237: ST_TO_ADDR
129238: LD_VAR 0 10
129242: PUSH
129243: FOR_TO
129244: IFFALSE 129337
// begin if not ValidHex ( _x , _y ) then
129246: LD_VAR 0 11
129250: PPUSH
129251: LD_VAR 0 12
129255: PPUSH
129256: CALL_OW 488
129260: NOT
129261: IFFALSE 129265
// continue ;
129263: GO 129243
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
129265: LD_VAR 0 11
129269: PPUSH
129270: LD_VAR 0 12
129274: PPUSH
129275: CALL_OW 351
129279: PUSH
129280: LD_VAR 0 11
129284: PPUSH
129285: LD_VAR 0 12
129289: PPUSH
129290: CALL_OW 554
129294: AND
129295: IFFALSE 129335
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
129297: LD_ADDR_VAR 0 13
129301: PUSH
129302: LD_VAR 0 13
129306: PPUSH
129307: LD_VAR 0 13
129311: PUSH
129312: LD_INT 1
129314: PLUS
129315: PPUSH
129316: LD_VAR 0 11
129320: PUSH
129321: LD_VAR 0 12
129325: PUSH
129326: EMPTY
129327: LIST
129328: LIST
129329: PPUSH
129330: CALL_OW 2
129334: ST_TO_ADDR
// end ;
129335: GO 129243
129337: POP
129338: POP
129339: GO 129223
129341: POP
129342: POP
// if not list then
129343: LD_VAR 0 13
129347: NOT
129348: IFFALSE 129352
// exit ;
129350: GO 129423
// for i in list do
129352: LD_ADDR_VAR 0 6
129356: PUSH
129357: LD_VAR 0 13
129361: PUSH
129362: FOR_IN
129363: IFFALSE 129421
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
129365: LD_VAR 0 1
129369: PPUSH
129370: LD_STRING M
129372: PUSH
129373: LD_VAR 0 6
129377: PUSH
129378: LD_INT 1
129380: ARRAY
129381: PUSH
129382: LD_VAR 0 6
129386: PUSH
129387: LD_INT 2
129389: ARRAY
129390: PUSH
129391: LD_INT 0
129393: PUSH
129394: LD_INT 0
129396: PUSH
129397: LD_INT 0
129399: PUSH
129400: LD_INT 0
129402: PUSH
129403: EMPTY
129404: LIST
129405: LIST
129406: LIST
129407: LIST
129408: LIST
129409: LIST
129410: LIST
129411: PUSH
129412: EMPTY
129413: LIST
129414: PPUSH
129415: CALL_OW 447
129419: GO 129362
129421: POP
129422: POP
// end ;
129423: LD_VAR 0 5
129427: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
129428: LD_INT 0
129430: PPUSH
129431: PPUSH
129432: PPUSH
129433: PPUSH
129434: PPUSH
129435: PPUSH
129436: PPUSH
129437: PPUSH
129438: PPUSH
129439: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
129440: LD_VAR 0 1
129444: PPUSH
129445: CALL_OW 302
129449: NOT
129450: PUSH
129451: LD_VAR 0 2
129455: PPUSH
129456: LD_VAR 0 3
129460: PPUSH
129461: CALL_OW 488
129465: NOT
129466: OR
129467: PUSH
129468: LD_VAR 0 4
129472: NOT
129473: OR
129474: IFFALSE 129478
// exit ;
129476: GO 129991
// list := [ ] ;
129478: LD_ADDR_VAR 0 13
129482: PUSH
129483: EMPTY
129484: ST_TO_ADDR
// if x - r < 0 then
129485: LD_VAR 0 2
129489: PUSH
129490: LD_VAR 0 4
129494: MINUS
129495: PUSH
129496: LD_INT 0
129498: LESS
129499: IFFALSE 129511
// min_x := 0 else
129501: LD_ADDR_VAR 0 7
129505: PUSH
129506: LD_INT 0
129508: ST_TO_ADDR
129509: GO 129527
// min_x := x - r ;
129511: LD_ADDR_VAR 0 7
129515: PUSH
129516: LD_VAR 0 2
129520: PUSH
129521: LD_VAR 0 4
129525: MINUS
129526: ST_TO_ADDR
// if y - r < 0 then
129527: LD_VAR 0 3
129531: PUSH
129532: LD_VAR 0 4
129536: MINUS
129537: PUSH
129538: LD_INT 0
129540: LESS
129541: IFFALSE 129553
// min_y := 0 else
129543: LD_ADDR_VAR 0 8
129547: PUSH
129548: LD_INT 0
129550: ST_TO_ADDR
129551: GO 129569
// min_y := y - r ;
129553: LD_ADDR_VAR 0 8
129557: PUSH
129558: LD_VAR 0 3
129562: PUSH
129563: LD_VAR 0 4
129567: MINUS
129568: ST_TO_ADDR
// max_x := x + r ;
129569: LD_ADDR_VAR 0 9
129573: PUSH
129574: LD_VAR 0 2
129578: PUSH
129579: LD_VAR 0 4
129583: PLUS
129584: ST_TO_ADDR
// max_y := y + r ;
129585: LD_ADDR_VAR 0 10
129589: PUSH
129590: LD_VAR 0 3
129594: PUSH
129595: LD_VAR 0 4
129599: PLUS
129600: ST_TO_ADDR
// for _x = min_x to max_x do
129601: LD_ADDR_VAR 0 11
129605: PUSH
129606: DOUBLE
129607: LD_VAR 0 7
129611: DEC
129612: ST_TO_ADDR
129613: LD_VAR 0 9
129617: PUSH
129618: FOR_TO
129619: IFFALSE 129736
// for _y = min_y to max_y do
129621: LD_ADDR_VAR 0 12
129625: PUSH
129626: DOUBLE
129627: LD_VAR 0 8
129631: DEC
129632: ST_TO_ADDR
129633: LD_VAR 0 10
129637: PUSH
129638: FOR_TO
129639: IFFALSE 129732
// begin if not ValidHex ( _x , _y ) then
129641: LD_VAR 0 11
129645: PPUSH
129646: LD_VAR 0 12
129650: PPUSH
129651: CALL_OW 488
129655: NOT
129656: IFFALSE 129660
// continue ;
129658: GO 129638
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
129660: LD_VAR 0 11
129664: PPUSH
129665: LD_VAR 0 12
129669: PPUSH
129670: CALL_OW 351
129674: PUSH
129675: LD_VAR 0 11
129679: PPUSH
129680: LD_VAR 0 12
129684: PPUSH
129685: CALL_OW 554
129689: AND
129690: IFFALSE 129730
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
129692: LD_ADDR_VAR 0 13
129696: PUSH
129697: LD_VAR 0 13
129701: PPUSH
129702: LD_VAR 0 13
129706: PUSH
129707: LD_INT 1
129709: PLUS
129710: PPUSH
129711: LD_VAR 0 11
129715: PUSH
129716: LD_VAR 0 12
129720: PUSH
129721: EMPTY
129722: LIST
129723: LIST
129724: PPUSH
129725: CALL_OW 2
129729: ST_TO_ADDR
// end ;
129730: GO 129638
129732: POP
129733: POP
129734: GO 129618
129736: POP
129737: POP
// if not list then
129738: LD_VAR 0 13
129742: NOT
129743: IFFALSE 129747
// exit ;
129745: GO 129991
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
129747: LD_ADDR_VAR 0 13
129751: PUSH
129752: LD_VAR 0 1
129756: PPUSH
129757: LD_VAR 0 13
129761: PPUSH
129762: LD_INT 1
129764: PPUSH
129765: LD_INT 1
129767: PPUSH
129768: CALL 75120 0 4
129772: ST_TO_ADDR
// ComStop ( flame ) ;
129773: LD_VAR 0 1
129777: PPUSH
129778: CALL_OW 141
// for i in list do
129782: LD_ADDR_VAR 0 6
129786: PUSH
129787: LD_VAR 0 13
129791: PUSH
129792: FOR_IN
129793: IFFALSE 129824
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
129795: LD_VAR 0 1
129799: PPUSH
129800: LD_VAR 0 6
129804: PUSH
129805: LD_INT 1
129807: ARRAY
129808: PPUSH
129809: LD_VAR 0 6
129813: PUSH
129814: LD_INT 2
129816: ARRAY
129817: PPUSH
129818: CALL_OW 176
129822: GO 129792
129824: POP
129825: POP
// repeat wait ( 0 0$1 ) ;
129826: LD_INT 35
129828: PPUSH
129829: CALL_OW 67
// task := GetTaskList ( flame ) ;
129833: LD_ADDR_VAR 0 14
129837: PUSH
129838: LD_VAR 0 1
129842: PPUSH
129843: CALL_OW 437
129847: ST_TO_ADDR
// if not task then
129848: LD_VAR 0 14
129852: NOT
129853: IFFALSE 129857
// exit ;
129855: GO 129991
// if task [ 1 ] [ 1 ] <> | then
129857: LD_VAR 0 14
129861: PUSH
129862: LD_INT 1
129864: ARRAY
129865: PUSH
129866: LD_INT 1
129868: ARRAY
129869: PUSH
129870: LD_STRING |
129872: NONEQUAL
129873: IFFALSE 129877
// exit ;
129875: GO 129991
// _x := task [ 1 ] [ 2 ] ;
129877: LD_ADDR_VAR 0 11
129881: PUSH
129882: LD_VAR 0 14
129886: PUSH
129887: LD_INT 1
129889: ARRAY
129890: PUSH
129891: LD_INT 2
129893: ARRAY
129894: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
129895: LD_ADDR_VAR 0 12
129899: PUSH
129900: LD_VAR 0 14
129904: PUSH
129905: LD_INT 1
129907: ARRAY
129908: PUSH
129909: LD_INT 3
129911: ARRAY
129912: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
129913: LD_VAR 0 11
129917: PPUSH
129918: LD_VAR 0 12
129922: PPUSH
129923: CALL_OW 351
129927: NOT
129928: PUSH
129929: LD_VAR 0 11
129933: PPUSH
129934: LD_VAR 0 12
129938: PPUSH
129939: CALL_OW 554
129943: NOT
129944: OR
129945: IFFALSE 129979
// begin task := Delete ( task , 1 ) ;
129947: LD_ADDR_VAR 0 14
129951: PUSH
129952: LD_VAR 0 14
129956: PPUSH
129957: LD_INT 1
129959: PPUSH
129960: CALL_OW 3
129964: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
129965: LD_VAR 0 1
129969: PPUSH
129970: LD_VAR 0 14
129974: PPUSH
129975: CALL_OW 446
// end ; until not HasTask ( flame ) ;
129979: LD_VAR 0 1
129983: PPUSH
129984: CALL_OW 314
129988: NOT
129989: IFFALSE 129826
// end ;
129991: LD_VAR 0 5
129995: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
129996: LD_EXP 209
130000: NOT
130001: IFFALSE 130051
130003: GO 130005
130005: DISABLE
// begin initHack := true ;
130006: LD_ADDR_EXP 209
130010: PUSH
130011: LD_INT 1
130013: ST_TO_ADDR
// hackTanks := [ ] ;
130014: LD_ADDR_EXP 210
130018: PUSH
130019: EMPTY
130020: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
130021: LD_ADDR_EXP 211
130025: PUSH
130026: EMPTY
130027: ST_TO_ADDR
// hackLimit := 3 ;
130028: LD_ADDR_EXP 212
130032: PUSH
130033: LD_INT 3
130035: ST_TO_ADDR
// hackDist := 12 ;
130036: LD_ADDR_EXP 213
130040: PUSH
130041: LD_INT 12
130043: ST_TO_ADDR
// hackCounter := [ ] ;
130044: LD_ADDR_EXP 214
130048: PUSH
130049: EMPTY
130050: ST_TO_ADDR
// end ;
130051: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
130052: LD_EXP 209
130056: PUSH
130057: LD_INT 34
130059: PUSH
130060: LD_INT 99
130062: PUSH
130063: EMPTY
130064: LIST
130065: LIST
130066: PPUSH
130067: CALL_OW 69
130071: AND
130072: IFFALSE 130325
130074: GO 130076
130076: DISABLE
130077: LD_INT 0
130079: PPUSH
130080: PPUSH
// begin enable ;
130081: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
130082: LD_ADDR_VAR 0 1
130086: PUSH
130087: LD_INT 34
130089: PUSH
130090: LD_INT 99
130092: PUSH
130093: EMPTY
130094: LIST
130095: LIST
130096: PPUSH
130097: CALL_OW 69
130101: PUSH
130102: FOR_IN
130103: IFFALSE 130323
// begin if not i in hackTanks then
130105: LD_VAR 0 1
130109: PUSH
130110: LD_EXP 210
130114: IN
130115: NOT
130116: IFFALSE 130199
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
130118: LD_ADDR_EXP 210
130122: PUSH
130123: LD_EXP 210
130127: PPUSH
130128: LD_EXP 210
130132: PUSH
130133: LD_INT 1
130135: PLUS
130136: PPUSH
130137: LD_VAR 0 1
130141: PPUSH
130142: CALL_OW 1
130146: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
130147: LD_ADDR_EXP 211
130151: PUSH
130152: LD_EXP 211
130156: PPUSH
130157: LD_EXP 211
130161: PUSH
130162: LD_INT 1
130164: PLUS
130165: PPUSH
130166: EMPTY
130167: PPUSH
130168: CALL_OW 1
130172: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
130173: LD_ADDR_EXP 214
130177: PUSH
130178: LD_EXP 214
130182: PPUSH
130183: LD_EXP 214
130187: PUSH
130188: LD_INT 1
130190: PLUS
130191: PPUSH
130192: EMPTY
130193: PPUSH
130194: CALL_OW 1
130198: ST_TO_ADDR
// end ; if not IsOk ( i ) then
130199: LD_VAR 0 1
130203: PPUSH
130204: CALL_OW 302
130208: NOT
130209: IFFALSE 130222
// begin HackUnlinkAll ( i ) ;
130211: LD_VAR 0 1
130215: PPUSH
130216: CALL 130328 0 1
// continue ;
130220: GO 130102
// end ; HackCheckCapturedStatus ( i ) ;
130222: LD_VAR 0 1
130226: PPUSH
130227: CALL 130771 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
130231: LD_ADDR_VAR 0 2
130235: PUSH
130236: LD_INT 81
130238: PUSH
130239: LD_VAR 0 1
130243: PPUSH
130244: CALL_OW 255
130248: PUSH
130249: EMPTY
130250: LIST
130251: LIST
130252: PUSH
130253: LD_INT 33
130255: PUSH
130256: LD_INT 3
130258: PUSH
130259: EMPTY
130260: LIST
130261: LIST
130262: PUSH
130263: LD_INT 91
130265: PUSH
130266: LD_VAR 0 1
130270: PUSH
130271: LD_EXP 213
130275: PUSH
130276: EMPTY
130277: LIST
130278: LIST
130279: LIST
130280: PUSH
130281: LD_INT 50
130283: PUSH
130284: EMPTY
130285: LIST
130286: PUSH
130287: EMPTY
130288: LIST
130289: LIST
130290: LIST
130291: LIST
130292: PPUSH
130293: CALL_OW 69
130297: ST_TO_ADDR
// if not tmp then
130298: LD_VAR 0 2
130302: NOT
130303: IFFALSE 130307
// continue ;
130305: GO 130102
// HackLink ( i , tmp ) ;
130307: LD_VAR 0 1
130311: PPUSH
130312: LD_VAR 0 2
130316: PPUSH
130317: CALL 130464 0 2
// end ;
130321: GO 130102
130323: POP
130324: POP
// end ;
130325: PPOPN 2
130327: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
130328: LD_INT 0
130330: PPUSH
130331: PPUSH
130332: PPUSH
// if not hack in hackTanks then
130333: LD_VAR 0 1
130337: PUSH
130338: LD_EXP 210
130342: IN
130343: NOT
130344: IFFALSE 130348
// exit ;
130346: GO 130459
// index := GetElementIndex ( hackTanks , hack ) ;
130348: LD_ADDR_VAR 0 4
130352: PUSH
130353: LD_EXP 210
130357: PPUSH
130358: LD_VAR 0 1
130362: PPUSH
130363: CALL 74417 0 2
130367: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
130368: LD_EXP 211
130372: PUSH
130373: LD_VAR 0 4
130377: ARRAY
130378: IFFALSE 130459
// begin for i in hackTanksCaptured [ index ] do
130380: LD_ADDR_VAR 0 3
130384: PUSH
130385: LD_EXP 211
130389: PUSH
130390: LD_VAR 0 4
130394: ARRAY
130395: PUSH
130396: FOR_IN
130397: IFFALSE 130423
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
130399: LD_VAR 0 3
130403: PUSH
130404: LD_INT 1
130406: ARRAY
130407: PPUSH
130408: LD_VAR 0 3
130412: PUSH
130413: LD_INT 2
130415: ARRAY
130416: PPUSH
130417: CALL_OW 235
130421: GO 130396
130423: POP
130424: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
130425: LD_ADDR_EXP 211
130429: PUSH
130430: LD_EXP 211
130434: PPUSH
130435: LD_VAR 0 4
130439: PPUSH
130440: EMPTY
130441: PPUSH
130442: CALL_OW 1
130446: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
130447: LD_VAR 0 1
130451: PPUSH
130452: LD_INT 0
130454: PPUSH
130455: CALL_OW 505
// end ; end ;
130459: LD_VAR 0 2
130463: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
130464: LD_INT 0
130466: PPUSH
130467: PPUSH
130468: PPUSH
// if not hack in hackTanks or not vehicles then
130469: LD_VAR 0 1
130473: PUSH
130474: LD_EXP 210
130478: IN
130479: NOT
130480: PUSH
130481: LD_VAR 0 2
130485: NOT
130486: OR
130487: IFFALSE 130491
// exit ;
130489: GO 130766
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
130491: LD_ADDR_VAR 0 2
130495: PUSH
130496: LD_VAR 0 1
130500: PPUSH
130501: LD_VAR 0 2
130505: PPUSH
130506: LD_INT 1
130508: PPUSH
130509: LD_INT 1
130511: PPUSH
130512: CALL 75067 0 4
130516: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
130517: LD_ADDR_VAR 0 5
130521: PUSH
130522: LD_EXP 210
130526: PPUSH
130527: LD_VAR 0 1
130531: PPUSH
130532: CALL 74417 0 2
130536: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
130537: LD_EXP 211
130541: PUSH
130542: LD_VAR 0 5
130546: ARRAY
130547: PUSH
130548: LD_EXP 212
130552: LESS
130553: IFFALSE 130742
// begin for i := 1 to vehicles do
130555: LD_ADDR_VAR 0 4
130559: PUSH
130560: DOUBLE
130561: LD_INT 1
130563: DEC
130564: ST_TO_ADDR
130565: LD_VAR 0 2
130569: PUSH
130570: FOR_TO
130571: IFFALSE 130740
// begin if hackTanksCaptured [ index ] = hackLimit then
130573: LD_EXP 211
130577: PUSH
130578: LD_VAR 0 5
130582: ARRAY
130583: PUSH
130584: LD_EXP 212
130588: EQUAL
130589: IFFALSE 130593
// break ;
130591: GO 130740
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
130593: LD_ADDR_EXP 214
130597: PUSH
130598: LD_EXP 214
130602: PPUSH
130603: LD_VAR 0 5
130607: PPUSH
130608: LD_EXP 214
130612: PUSH
130613: LD_VAR 0 5
130617: ARRAY
130618: PUSH
130619: LD_INT 1
130621: PLUS
130622: PPUSH
130623: CALL_OW 1
130627: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
130628: LD_ADDR_EXP 211
130632: PUSH
130633: LD_EXP 211
130637: PPUSH
130638: LD_VAR 0 5
130642: PUSH
130643: LD_EXP 211
130647: PUSH
130648: LD_VAR 0 5
130652: ARRAY
130653: PUSH
130654: LD_INT 1
130656: PLUS
130657: PUSH
130658: EMPTY
130659: LIST
130660: LIST
130661: PPUSH
130662: LD_VAR 0 2
130666: PUSH
130667: LD_VAR 0 4
130671: ARRAY
130672: PUSH
130673: LD_VAR 0 2
130677: PUSH
130678: LD_VAR 0 4
130682: ARRAY
130683: PPUSH
130684: CALL_OW 255
130688: PUSH
130689: EMPTY
130690: LIST
130691: LIST
130692: PPUSH
130693: CALL 74632 0 3
130697: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
130698: LD_VAR 0 2
130702: PUSH
130703: LD_VAR 0 4
130707: ARRAY
130708: PPUSH
130709: LD_VAR 0 1
130713: PPUSH
130714: CALL_OW 255
130718: PPUSH
130719: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
130723: LD_VAR 0 2
130727: PUSH
130728: LD_VAR 0 4
130732: ARRAY
130733: PPUSH
130734: CALL_OW 141
// end ;
130738: GO 130570
130740: POP
130741: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
130742: LD_VAR 0 1
130746: PPUSH
130747: LD_EXP 211
130751: PUSH
130752: LD_VAR 0 5
130756: ARRAY
130757: PUSH
130758: LD_INT 0
130760: PLUS
130761: PPUSH
130762: CALL_OW 505
// end ;
130766: LD_VAR 0 3
130770: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
130771: LD_INT 0
130773: PPUSH
130774: PPUSH
130775: PPUSH
130776: PPUSH
// if not hack in hackTanks then
130777: LD_VAR 0 1
130781: PUSH
130782: LD_EXP 210
130786: IN
130787: NOT
130788: IFFALSE 130792
// exit ;
130790: GO 131032
// index := GetElementIndex ( hackTanks , hack ) ;
130792: LD_ADDR_VAR 0 4
130796: PUSH
130797: LD_EXP 210
130801: PPUSH
130802: LD_VAR 0 1
130806: PPUSH
130807: CALL 74417 0 2
130811: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
130812: LD_ADDR_VAR 0 3
130816: PUSH
130817: DOUBLE
130818: LD_EXP 211
130822: PUSH
130823: LD_VAR 0 4
130827: ARRAY
130828: INC
130829: ST_TO_ADDR
130830: LD_INT 1
130832: PUSH
130833: FOR_DOWNTO
130834: IFFALSE 131006
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
130836: LD_ADDR_VAR 0 5
130840: PUSH
130841: LD_EXP 211
130845: PUSH
130846: LD_VAR 0 4
130850: ARRAY
130851: PUSH
130852: LD_VAR 0 3
130856: ARRAY
130857: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
130858: LD_VAR 0 5
130862: PUSH
130863: LD_INT 1
130865: ARRAY
130866: PPUSH
130867: CALL_OW 302
130871: NOT
130872: PUSH
130873: LD_VAR 0 5
130877: PUSH
130878: LD_INT 1
130880: ARRAY
130881: PPUSH
130882: CALL_OW 255
130886: PUSH
130887: LD_VAR 0 1
130891: PPUSH
130892: CALL_OW 255
130896: NONEQUAL
130897: OR
130898: IFFALSE 131004
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
130900: LD_VAR 0 5
130904: PUSH
130905: LD_INT 1
130907: ARRAY
130908: PPUSH
130909: CALL_OW 305
130913: PUSH
130914: LD_VAR 0 5
130918: PUSH
130919: LD_INT 1
130921: ARRAY
130922: PPUSH
130923: CALL_OW 255
130927: PUSH
130928: LD_VAR 0 1
130932: PPUSH
130933: CALL_OW 255
130937: EQUAL
130938: AND
130939: IFFALSE 130963
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
130941: LD_VAR 0 5
130945: PUSH
130946: LD_INT 1
130948: ARRAY
130949: PPUSH
130950: LD_VAR 0 5
130954: PUSH
130955: LD_INT 2
130957: ARRAY
130958: PPUSH
130959: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
130963: LD_ADDR_EXP 211
130967: PUSH
130968: LD_EXP 211
130972: PPUSH
130973: LD_VAR 0 4
130977: PPUSH
130978: LD_EXP 211
130982: PUSH
130983: LD_VAR 0 4
130987: ARRAY
130988: PPUSH
130989: LD_VAR 0 3
130993: PPUSH
130994: CALL_OW 3
130998: PPUSH
130999: CALL_OW 1
131003: ST_TO_ADDR
// end ; end ;
131004: GO 130833
131006: POP
131007: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
131008: LD_VAR 0 1
131012: PPUSH
131013: LD_EXP 211
131017: PUSH
131018: LD_VAR 0 4
131022: ARRAY
131023: PUSH
131024: LD_INT 0
131026: PLUS
131027: PPUSH
131028: CALL_OW 505
// end ;
131032: LD_VAR 0 2
131036: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
131037: LD_INT 0
131039: PPUSH
131040: PPUSH
131041: PPUSH
131042: PPUSH
// if not hack in hackTanks then
131043: LD_VAR 0 1
131047: PUSH
131048: LD_EXP 210
131052: IN
131053: NOT
131054: IFFALSE 131058
// exit ;
131056: GO 131143
// index := GetElementIndex ( hackTanks , hack ) ;
131058: LD_ADDR_VAR 0 5
131062: PUSH
131063: LD_EXP 210
131067: PPUSH
131068: LD_VAR 0 1
131072: PPUSH
131073: CALL 74417 0 2
131077: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
131078: LD_ADDR_VAR 0 4
131082: PUSH
131083: DOUBLE
131084: LD_INT 1
131086: DEC
131087: ST_TO_ADDR
131088: LD_EXP 211
131092: PUSH
131093: LD_VAR 0 5
131097: ARRAY
131098: PUSH
131099: FOR_TO
131100: IFFALSE 131141
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
131102: LD_EXP 211
131106: PUSH
131107: LD_VAR 0 5
131111: ARRAY
131112: PUSH
131113: LD_VAR 0 4
131117: ARRAY
131118: PUSH
131119: LD_INT 1
131121: ARRAY
131122: PUSH
131123: LD_VAR 0 2
131127: EQUAL
131128: IFFALSE 131139
// KillUnit ( vehicle ) ;
131130: LD_VAR 0 2
131134: PPUSH
131135: CALL_OW 66
131139: GO 131099
131141: POP
131142: POP
// end ;
131143: LD_VAR 0 3
131147: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
131148: LD_EXP 215
131152: NOT
131153: IFFALSE 131188
131155: GO 131157
131157: DISABLE
// begin initMiner := true ;
131158: LD_ADDR_EXP 215
131162: PUSH
131163: LD_INT 1
131165: ST_TO_ADDR
// minersList := [ ] ;
131166: LD_ADDR_EXP 216
131170: PUSH
131171: EMPTY
131172: ST_TO_ADDR
// minerMinesList := [ ] ;
131173: LD_ADDR_EXP 217
131177: PUSH
131178: EMPTY
131179: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
131180: LD_ADDR_EXP 218
131184: PUSH
131185: LD_INT 5
131187: ST_TO_ADDR
// end ;
131188: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
131189: LD_EXP 215
131193: PUSH
131194: LD_INT 34
131196: PUSH
131197: LD_INT 81
131199: PUSH
131200: EMPTY
131201: LIST
131202: LIST
131203: PPUSH
131204: CALL_OW 69
131208: AND
131209: IFFALSE 131670
131211: GO 131213
131213: DISABLE
131214: LD_INT 0
131216: PPUSH
131217: PPUSH
131218: PPUSH
131219: PPUSH
// begin enable ;
131220: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
131221: LD_ADDR_VAR 0 1
131225: PUSH
131226: LD_INT 34
131228: PUSH
131229: LD_INT 81
131231: PUSH
131232: EMPTY
131233: LIST
131234: LIST
131235: PPUSH
131236: CALL_OW 69
131240: PUSH
131241: FOR_IN
131242: IFFALSE 131314
// begin if not i in minersList then
131244: LD_VAR 0 1
131248: PUSH
131249: LD_EXP 216
131253: IN
131254: NOT
131255: IFFALSE 131312
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
131257: LD_ADDR_EXP 216
131261: PUSH
131262: LD_EXP 216
131266: PPUSH
131267: LD_EXP 216
131271: PUSH
131272: LD_INT 1
131274: PLUS
131275: PPUSH
131276: LD_VAR 0 1
131280: PPUSH
131281: CALL_OW 1
131285: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
131286: LD_ADDR_EXP 217
131290: PUSH
131291: LD_EXP 217
131295: PPUSH
131296: LD_EXP 217
131300: PUSH
131301: LD_INT 1
131303: PLUS
131304: PPUSH
131305: EMPTY
131306: PPUSH
131307: CALL_OW 1
131311: ST_TO_ADDR
// end end ;
131312: GO 131241
131314: POP
131315: POP
// for i := minerMinesList downto 1 do
131316: LD_ADDR_VAR 0 1
131320: PUSH
131321: DOUBLE
131322: LD_EXP 217
131326: INC
131327: ST_TO_ADDR
131328: LD_INT 1
131330: PUSH
131331: FOR_DOWNTO
131332: IFFALSE 131668
// begin if IsLive ( minersList [ i ] ) then
131334: LD_EXP 216
131338: PUSH
131339: LD_VAR 0 1
131343: ARRAY
131344: PPUSH
131345: CALL_OW 300
131349: IFFALSE 131377
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
131351: LD_EXP 216
131355: PUSH
131356: LD_VAR 0 1
131360: ARRAY
131361: PPUSH
131362: LD_EXP 217
131366: PUSH
131367: LD_VAR 0 1
131371: ARRAY
131372: PPUSH
131373: CALL_OW 505
// if not minerMinesList [ i ] then
131377: LD_EXP 217
131381: PUSH
131382: LD_VAR 0 1
131386: ARRAY
131387: NOT
131388: IFFALSE 131392
// continue ;
131390: GO 131331
// for j := minerMinesList [ i ] downto 1 do
131392: LD_ADDR_VAR 0 2
131396: PUSH
131397: DOUBLE
131398: LD_EXP 217
131402: PUSH
131403: LD_VAR 0 1
131407: ARRAY
131408: INC
131409: ST_TO_ADDR
131410: LD_INT 1
131412: PUSH
131413: FOR_DOWNTO
131414: IFFALSE 131664
// begin side := GetSide ( minersList [ i ] ) ;
131416: LD_ADDR_VAR 0 3
131420: PUSH
131421: LD_EXP 216
131425: PUSH
131426: LD_VAR 0 1
131430: ARRAY
131431: PPUSH
131432: CALL_OW 255
131436: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
131437: LD_ADDR_VAR 0 4
131441: PUSH
131442: LD_EXP 217
131446: PUSH
131447: LD_VAR 0 1
131451: ARRAY
131452: PUSH
131453: LD_VAR 0 2
131457: ARRAY
131458: PUSH
131459: LD_INT 1
131461: ARRAY
131462: PPUSH
131463: LD_EXP 217
131467: PUSH
131468: LD_VAR 0 1
131472: ARRAY
131473: PUSH
131474: LD_VAR 0 2
131478: ARRAY
131479: PUSH
131480: LD_INT 2
131482: ARRAY
131483: PPUSH
131484: CALL_OW 428
131488: ST_TO_ADDR
// if not tmp then
131489: LD_VAR 0 4
131493: NOT
131494: IFFALSE 131498
// continue ;
131496: GO 131413
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
131498: LD_VAR 0 4
131502: PUSH
131503: LD_INT 81
131505: PUSH
131506: LD_VAR 0 3
131510: PUSH
131511: EMPTY
131512: LIST
131513: LIST
131514: PPUSH
131515: CALL_OW 69
131519: IN
131520: PUSH
131521: LD_EXP 217
131525: PUSH
131526: LD_VAR 0 1
131530: ARRAY
131531: PUSH
131532: LD_VAR 0 2
131536: ARRAY
131537: PUSH
131538: LD_INT 1
131540: ARRAY
131541: PPUSH
131542: LD_EXP 217
131546: PUSH
131547: LD_VAR 0 1
131551: ARRAY
131552: PUSH
131553: LD_VAR 0 2
131557: ARRAY
131558: PUSH
131559: LD_INT 2
131561: ARRAY
131562: PPUSH
131563: CALL_OW 458
131567: AND
131568: IFFALSE 131662
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
131570: LD_EXP 217
131574: PUSH
131575: LD_VAR 0 1
131579: ARRAY
131580: PUSH
131581: LD_VAR 0 2
131585: ARRAY
131586: PUSH
131587: LD_INT 1
131589: ARRAY
131590: PPUSH
131591: LD_EXP 217
131595: PUSH
131596: LD_VAR 0 1
131600: ARRAY
131601: PUSH
131602: LD_VAR 0 2
131606: ARRAY
131607: PUSH
131608: LD_INT 2
131610: ARRAY
131611: PPUSH
131612: LD_VAR 0 3
131616: PPUSH
131617: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
131621: LD_ADDR_EXP 217
131625: PUSH
131626: LD_EXP 217
131630: PPUSH
131631: LD_VAR 0 1
131635: PPUSH
131636: LD_EXP 217
131640: PUSH
131641: LD_VAR 0 1
131645: ARRAY
131646: PPUSH
131647: LD_VAR 0 2
131651: PPUSH
131652: CALL_OW 3
131656: PPUSH
131657: CALL_OW 1
131661: ST_TO_ADDR
// end ; end ;
131662: GO 131413
131664: POP
131665: POP
// end ;
131666: GO 131331
131668: POP
131669: POP
// end ;
131670: PPOPN 4
131672: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
131673: LD_INT 0
131675: PPUSH
131676: PPUSH
// result := false ;
131677: LD_ADDR_VAR 0 4
131681: PUSH
131682: LD_INT 0
131684: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
131685: LD_VAR 0 1
131689: PPUSH
131690: CALL_OW 264
131694: PUSH
131695: LD_INT 81
131697: EQUAL
131698: NOT
131699: IFFALSE 131703
// exit ;
131701: GO 131943
// index := GetElementIndex ( minersList , unit ) ;
131703: LD_ADDR_VAR 0 5
131707: PUSH
131708: LD_EXP 216
131712: PPUSH
131713: LD_VAR 0 1
131717: PPUSH
131718: CALL 74417 0 2
131722: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
131723: LD_EXP 217
131727: PUSH
131728: LD_VAR 0 5
131732: ARRAY
131733: PUSH
131734: LD_EXP 218
131738: GREATEREQUAL
131739: IFFALSE 131743
// exit ;
131741: GO 131943
// ComMoveXY ( unit , x , y ) ;
131743: LD_VAR 0 1
131747: PPUSH
131748: LD_VAR 0 2
131752: PPUSH
131753: LD_VAR 0 3
131757: PPUSH
131758: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
131762: LD_INT 35
131764: PPUSH
131765: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
131769: LD_VAR 0 1
131773: PPUSH
131774: LD_VAR 0 2
131778: PPUSH
131779: LD_VAR 0 3
131783: PPUSH
131784: CALL 106158 0 3
131788: NOT
131789: PUSH
131790: LD_VAR 0 1
131794: PPUSH
131795: CALL_OW 314
131799: AND
131800: IFFALSE 131804
// exit ;
131802: GO 131943
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
131804: LD_VAR 0 2
131808: PPUSH
131809: LD_VAR 0 3
131813: PPUSH
131814: CALL_OW 428
131818: PUSH
131819: LD_VAR 0 1
131823: EQUAL
131824: PUSH
131825: LD_VAR 0 1
131829: PPUSH
131830: CALL_OW 314
131834: NOT
131835: AND
131836: IFFALSE 131762
// PlaySoundXY ( x , y , PlantMine ) ;
131838: LD_VAR 0 2
131842: PPUSH
131843: LD_VAR 0 3
131847: PPUSH
131848: LD_STRING PlantMine
131850: PPUSH
131851: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
131855: LD_VAR 0 2
131859: PPUSH
131860: LD_VAR 0 3
131864: PPUSH
131865: LD_VAR 0 1
131869: PPUSH
131870: CALL_OW 255
131874: PPUSH
131875: LD_INT 0
131877: PPUSH
131878: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
131882: LD_ADDR_EXP 217
131886: PUSH
131887: LD_EXP 217
131891: PPUSH
131892: LD_VAR 0 5
131896: PUSH
131897: LD_EXP 217
131901: PUSH
131902: LD_VAR 0 5
131906: ARRAY
131907: PUSH
131908: LD_INT 1
131910: PLUS
131911: PUSH
131912: EMPTY
131913: LIST
131914: LIST
131915: PPUSH
131916: LD_VAR 0 2
131920: PUSH
131921: LD_VAR 0 3
131925: PUSH
131926: EMPTY
131927: LIST
131928: LIST
131929: PPUSH
131930: CALL 74632 0 3
131934: ST_TO_ADDR
// result := true ;
131935: LD_ADDR_VAR 0 4
131939: PUSH
131940: LD_INT 1
131942: ST_TO_ADDR
// end ;
131943: LD_VAR 0 4
131947: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
131948: LD_INT 0
131950: PPUSH
131951: PPUSH
131952: PPUSH
// if not unit in minersList then
131953: LD_VAR 0 1
131957: PUSH
131958: LD_EXP 216
131962: IN
131963: NOT
131964: IFFALSE 131968
// exit ;
131966: GO 132360
// index := GetElementIndex ( minersList , unit ) ;
131968: LD_ADDR_VAR 0 6
131972: PUSH
131973: LD_EXP 216
131977: PPUSH
131978: LD_VAR 0 1
131982: PPUSH
131983: CALL 74417 0 2
131987: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
131988: LD_ADDR_VAR 0 5
131992: PUSH
131993: DOUBLE
131994: LD_EXP 217
131998: PUSH
131999: LD_VAR 0 6
132003: ARRAY
132004: INC
132005: ST_TO_ADDR
132006: LD_INT 1
132008: PUSH
132009: FOR_DOWNTO
132010: IFFALSE 132171
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
132012: LD_EXP 217
132016: PUSH
132017: LD_VAR 0 6
132021: ARRAY
132022: PUSH
132023: LD_VAR 0 5
132027: ARRAY
132028: PUSH
132029: LD_INT 1
132031: ARRAY
132032: PUSH
132033: LD_VAR 0 2
132037: EQUAL
132038: PUSH
132039: LD_EXP 217
132043: PUSH
132044: LD_VAR 0 6
132048: ARRAY
132049: PUSH
132050: LD_VAR 0 5
132054: ARRAY
132055: PUSH
132056: LD_INT 2
132058: ARRAY
132059: PUSH
132060: LD_VAR 0 3
132064: EQUAL
132065: AND
132066: IFFALSE 132169
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
132068: LD_EXP 217
132072: PUSH
132073: LD_VAR 0 6
132077: ARRAY
132078: PUSH
132079: LD_VAR 0 5
132083: ARRAY
132084: PUSH
132085: LD_INT 1
132087: ARRAY
132088: PPUSH
132089: LD_EXP 217
132093: PUSH
132094: LD_VAR 0 6
132098: ARRAY
132099: PUSH
132100: LD_VAR 0 5
132104: ARRAY
132105: PUSH
132106: LD_INT 2
132108: ARRAY
132109: PPUSH
132110: LD_VAR 0 1
132114: PPUSH
132115: CALL_OW 255
132119: PPUSH
132120: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
132124: LD_ADDR_EXP 217
132128: PUSH
132129: LD_EXP 217
132133: PPUSH
132134: LD_VAR 0 6
132138: PPUSH
132139: LD_EXP 217
132143: PUSH
132144: LD_VAR 0 6
132148: ARRAY
132149: PPUSH
132150: LD_VAR 0 5
132154: PPUSH
132155: CALL_OW 3
132159: PPUSH
132160: CALL_OW 1
132164: ST_TO_ADDR
// exit ;
132165: POP
132166: POP
132167: GO 132360
// end ; end ;
132169: GO 132009
132171: POP
132172: POP
// for i := minerMinesList [ index ] downto 1 do
132173: LD_ADDR_VAR 0 5
132177: PUSH
132178: DOUBLE
132179: LD_EXP 217
132183: PUSH
132184: LD_VAR 0 6
132188: ARRAY
132189: INC
132190: ST_TO_ADDR
132191: LD_INT 1
132193: PUSH
132194: FOR_DOWNTO
132195: IFFALSE 132358
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
132197: LD_EXP 217
132201: PUSH
132202: LD_VAR 0 6
132206: ARRAY
132207: PUSH
132208: LD_VAR 0 5
132212: ARRAY
132213: PUSH
132214: LD_INT 1
132216: ARRAY
132217: PPUSH
132218: LD_EXP 217
132222: PUSH
132223: LD_VAR 0 6
132227: ARRAY
132228: PUSH
132229: LD_VAR 0 5
132233: ARRAY
132234: PUSH
132235: LD_INT 2
132237: ARRAY
132238: PPUSH
132239: LD_VAR 0 2
132243: PPUSH
132244: LD_VAR 0 3
132248: PPUSH
132249: CALL_OW 298
132253: PUSH
132254: LD_INT 6
132256: LESS
132257: IFFALSE 132356
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
132259: LD_EXP 217
132263: PUSH
132264: LD_VAR 0 6
132268: ARRAY
132269: PUSH
132270: LD_VAR 0 5
132274: ARRAY
132275: PUSH
132276: LD_INT 1
132278: ARRAY
132279: PPUSH
132280: LD_EXP 217
132284: PUSH
132285: LD_VAR 0 6
132289: ARRAY
132290: PUSH
132291: LD_VAR 0 5
132295: ARRAY
132296: PUSH
132297: LD_INT 2
132299: ARRAY
132300: PPUSH
132301: LD_VAR 0 1
132305: PPUSH
132306: CALL_OW 255
132310: PPUSH
132311: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
132315: LD_ADDR_EXP 217
132319: PUSH
132320: LD_EXP 217
132324: PPUSH
132325: LD_VAR 0 6
132329: PPUSH
132330: LD_EXP 217
132334: PUSH
132335: LD_VAR 0 6
132339: ARRAY
132340: PPUSH
132341: LD_VAR 0 5
132345: PPUSH
132346: CALL_OW 3
132350: PPUSH
132351: CALL_OW 1
132355: ST_TO_ADDR
// end ; end ;
132356: GO 132194
132358: POP
132359: POP
// end ;
132360: LD_VAR 0 4
132364: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
132365: LD_INT 0
132367: PPUSH
132368: PPUSH
132369: PPUSH
132370: PPUSH
132371: PPUSH
132372: PPUSH
132373: PPUSH
132374: PPUSH
132375: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
132376: LD_VAR 0 1
132380: PPUSH
132381: CALL_OW 264
132385: PUSH
132386: LD_INT 81
132388: EQUAL
132389: NOT
132390: PUSH
132391: LD_VAR 0 1
132395: PUSH
132396: LD_EXP 216
132400: IN
132401: NOT
132402: OR
132403: IFFALSE 132407
// exit ;
132405: GO 132729
// index := GetElementIndex ( minersList , unit ) ;
132407: LD_ADDR_VAR 0 6
132411: PUSH
132412: LD_EXP 216
132416: PPUSH
132417: LD_VAR 0 1
132421: PPUSH
132422: CALL 74417 0 2
132426: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
132427: LD_ADDR_VAR 0 8
132431: PUSH
132432: LD_EXP 218
132436: PUSH
132437: LD_EXP 217
132441: PUSH
132442: LD_VAR 0 6
132446: ARRAY
132447: MINUS
132448: ST_TO_ADDR
// if not minesFreeAmount then
132449: LD_VAR 0 8
132453: NOT
132454: IFFALSE 132458
// exit ;
132456: GO 132729
// tmp := [ ] ;
132458: LD_ADDR_VAR 0 7
132462: PUSH
132463: EMPTY
132464: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
132465: LD_ADDR_VAR 0 5
132469: PUSH
132470: DOUBLE
132471: LD_INT 1
132473: DEC
132474: ST_TO_ADDR
132475: LD_VAR 0 8
132479: PUSH
132480: FOR_TO
132481: IFFALSE 132676
// begin _d := rand ( 0 , 5 ) ;
132483: LD_ADDR_VAR 0 11
132487: PUSH
132488: LD_INT 0
132490: PPUSH
132491: LD_INT 5
132493: PPUSH
132494: CALL_OW 12
132498: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
132499: LD_ADDR_VAR 0 12
132503: PUSH
132504: LD_INT 2
132506: PPUSH
132507: LD_INT 6
132509: PPUSH
132510: CALL_OW 12
132514: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
132515: LD_ADDR_VAR 0 9
132519: PUSH
132520: LD_VAR 0 2
132524: PPUSH
132525: LD_VAR 0 11
132529: PPUSH
132530: LD_VAR 0 12
132534: PPUSH
132535: CALL_OW 272
132539: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
132540: LD_ADDR_VAR 0 10
132544: PUSH
132545: LD_VAR 0 3
132549: PPUSH
132550: LD_VAR 0 11
132554: PPUSH
132555: LD_VAR 0 12
132559: PPUSH
132560: CALL_OW 273
132564: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
132565: LD_VAR 0 9
132569: PPUSH
132570: LD_VAR 0 10
132574: PPUSH
132575: CALL_OW 488
132579: PUSH
132580: LD_VAR 0 9
132584: PUSH
132585: LD_VAR 0 10
132589: PUSH
132590: EMPTY
132591: LIST
132592: LIST
132593: PUSH
132594: LD_VAR 0 7
132598: IN
132599: NOT
132600: AND
132601: PUSH
132602: LD_VAR 0 9
132606: PPUSH
132607: LD_VAR 0 10
132611: PPUSH
132612: CALL_OW 458
132616: NOT
132617: AND
132618: IFFALSE 132660
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
132620: LD_ADDR_VAR 0 7
132624: PUSH
132625: LD_VAR 0 7
132629: PPUSH
132630: LD_VAR 0 7
132634: PUSH
132635: LD_INT 1
132637: PLUS
132638: PPUSH
132639: LD_VAR 0 9
132643: PUSH
132644: LD_VAR 0 10
132648: PUSH
132649: EMPTY
132650: LIST
132651: LIST
132652: PPUSH
132653: CALL_OW 1
132657: ST_TO_ADDR
132658: GO 132674
// i := i - 1 ;
132660: LD_ADDR_VAR 0 5
132664: PUSH
132665: LD_VAR 0 5
132669: PUSH
132670: LD_INT 1
132672: MINUS
132673: ST_TO_ADDR
// end ;
132674: GO 132480
132676: POP
132677: POP
// for i in tmp do
132678: LD_ADDR_VAR 0 5
132682: PUSH
132683: LD_VAR 0 7
132687: PUSH
132688: FOR_IN
132689: IFFALSE 132727
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
132691: LD_VAR 0 1
132695: PPUSH
132696: LD_VAR 0 5
132700: PUSH
132701: LD_INT 1
132703: ARRAY
132704: PPUSH
132705: LD_VAR 0 5
132709: PUSH
132710: LD_INT 2
132712: ARRAY
132713: PPUSH
132714: CALL 131673 0 3
132718: NOT
132719: IFFALSE 132725
// exit ;
132721: POP
132722: POP
132723: GO 132729
132725: GO 132688
132727: POP
132728: POP
// end ;
132729: LD_VAR 0 4
132733: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
132734: LD_INT 0
132736: PPUSH
132737: PPUSH
132738: PPUSH
132739: PPUSH
132740: PPUSH
132741: PPUSH
132742: PPUSH
// if not GetClass ( unit ) = class_sniper then
132743: LD_VAR 0 1
132747: PPUSH
132748: CALL_OW 257
132752: PUSH
132753: LD_INT 5
132755: EQUAL
132756: NOT
132757: IFFALSE 132761
// exit ;
132759: GO 133149
// dist := 8 ;
132761: LD_ADDR_VAR 0 5
132765: PUSH
132766: LD_INT 8
132768: ST_TO_ADDR
// viewRange := 12 ;
132769: LD_ADDR_VAR 0 7
132773: PUSH
132774: LD_INT 12
132776: ST_TO_ADDR
// side := GetSide ( unit ) ;
132777: LD_ADDR_VAR 0 6
132781: PUSH
132782: LD_VAR 0 1
132786: PPUSH
132787: CALL_OW 255
132791: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
132792: LD_INT 61
132794: PPUSH
132795: LD_VAR 0 6
132799: PPUSH
132800: CALL_OW 321
132804: PUSH
132805: LD_INT 2
132807: EQUAL
132808: IFFALSE 132818
// viewRange := 16 ;
132810: LD_ADDR_VAR 0 7
132814: PUSH
132815: LD_INT 16
132817: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
132818: LD_VAR 0 1
132822: PPUSH
132823: LD_VAR 0 2
132827: PPUSH
132828: LD_VAR 0 3
132832: PPUSH
132833: CALL_OW 297
132837: PUSH
132838: LD_VAR 0 5
132842: GREATER
132843: IFFALSE 132922
// begin ComMoveXY ( unit , x , y ) ;
132845: LD_VAR 0 1
132849: PPUSH
132850: LD_VAR 0 2
132854: PPUSH
132855: LD_VAR 0 3
132859: PPUSH
132860: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
132864: LD_INT 35
132866: PPUSH
132867: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
132871: LD_VAR 0 1
132875: PPUSH
132876: LD_VAR 0 2
132880: PPUSH
132881: LD_VAR 0 3
132885: PPUSH
132886: CALL 106158 0 3
132890: NOT
132891: IFFALSE 132895
// exit ;
132893: GO 133149
// until GetDistUnitXY ( unit , x , y ) < dist ;
132895: LD_VAR 0 1
132899: PPUSH
132900: LD_VAR 0 2
132904: PPUSH
132905: LD_VAR 0 3
132909: PPUSH
132910: CALL_OW 297
132914: PUSH
132915: LD_VAR 0 5
132919: LESS
132920: IFFALSE 132864
// end ; ComTurnXY ( unit , x , y ) ;
132922: LD_VAR 0 1
132926: PPUSH
132927: LD_VAR 0 2
132931: PPUSH
132932: LD_VAR 0 3
132936: PPUSH
132937: CALL_OW 118
// wait ( 5 ) ;
132941: LD_INT 5
132943: PPUSH
132944: CALL_OW 67
// _d := GetDir ( unit ) ;
132948: LD_ADDR_VAR 0 10
132952: PUSH
132953: LD_VAR 0 1
132957: PPUSH
132958: CALL_OW 254
132962: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
132963: LD_ADDR_VAR 0 8
132967: PUSH
132968: LD_VAR 0 1
132972: PPUSH
132973: CALL_OW 250
132977: PPUSH
132978: LD_VAR 0 10
132982: PPUSH
132983: LD_VAR 0 5
132987: PPUSH
132988: CALL_OW 272
132992: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
132993: LD_ADDR_VAR 0 9
132997: PUSH
132998: LD_VAR 0 1
133002: PPUSH
133003: CALL_OW 251
133007: PPUSH
133008: LD_VAR 0 10
133012: PPUSH
133013: LD_VAR 0 5
133017: PPUSH
133018: CALL_OW 273
133022: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
133023: LD_VAR 0 8
133027: PPUSH
133028: LD_VAR 0 9
133032: PPUSH
133033: CALL_OW 488
133037: NOT
133038: IFFALSE 133042
// exit ;
133040: GO 133149
// ComAnimCustom ( unit , 1 ) ;
133042: LD_VAR 0 1
133046: PPUSH
133047: LD_INT 1
133049: PPUSH
133050: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
133054: LD_VAR 0 8
133058: PPUSH
133059: LD_VAR 0 9
133063: PPUSH
133064: LD_VAR 0 6
133068: PPUSH
133069: LD_VAR 0 7
133073: PPUSH
133074: CALL_OW 330
// repeat wait ( 1 ) ;
133078: LD_INT 1
133080: PPUSH
133081: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
133085: LD_VAR 0 1
133089: PPUSH
133090: CALL_OW 316
133094: PUSH
133095: LD_VAR 0 1
133099: PPUSH
133100: CALL_OW 314
133104: OR
133105: PUSH
133106: LD_VAR 0 1
133110: PPUSH
133111: CALL_OW 302
133115: NOT
133116: OR
133117: PUSH
133118: LD_VAR 0 1
133122: PPUSH
133123: CALL_OW 301
133127: OR
133128: IFFALSE 133078
// RemoveSeeing ( _x , _y , side ) ;
133130: LD_VAR 0 8
133134: PPUSH
133135: LD_VAR 0 9
133139: PPUSH
133140: LD_VAR 0 6
133144: PPUSH
133145: CALL_OW 331
// end ; end_of_file
133149: LD_VAR 0 4
133153: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
133154: LD_INT 0
133156: PPUSH
133157: PPUSH
133158: PPUSH
133159: PPUSH
133160: PPUSH
133161: PPUSH
133162: PPUSH
133163: PPUSH
133164: PPUSH
133165: PPUSH
133166: PPUSH
133167: PPUSH
133168: PPUSH
133169: PPUSH
133170: PPUSH
133171: PPUSH
133172: PPUSH
133173: PPUSH
133174: PPUSH
133175: PPUSH
133176: PPUSH
133177: PPUSH
133178: PPUSH
133179: PPUSH
133180: PPUSH
133181: PPUSH
133182: PPUSH
133183: PPUSH
133184: PPUSH
133185: PPUSH
133186: PPUSH
133187: PPUSH
133188: PPUSH
133189: PPUSH
// if not list then
133190: LD_VAR 0 1
133194: NOT
133195: IFFALSE 133199
// exit ;
133197: GO 137858
// base := list [ 1 ] ;
133199: LD_ADDR_VAR 0 3
133203: PUSH
133204: LD_VAR 0 1
133208: PUSH
133209: LD_INT 1
133211: ARRAY
133212: ST_TO_ADDR
// group := list [ 2 ] ;
133213: LD_ADDR_VAR 0 4
133217: PUSH
133218: LD_VAR 0 1
133222: PUSH
133223: LD_INT 2
133225: ARRAY
133226: ST_TO_ADDR
// path := list [ 3 ] ;
133227: LD_ADDR_VAR 0 5
133231: PUSH
133232: LD_VAR 0 1
133236: PUSH
133237: LD_INT 3
133239: ARRAY
133240: ST_TO_ADDR
// flags := list [ 4 ] ;
133241: LD_ADDR_VAR 0 6
133245: PUSH
133246: LD_VAR 0 1
133250: PUSH
133251: LD_INT 4
133253: ARRAY
133254: ST_TO_ADDR
// mined := [ ] ;
133255: LD_ADDR_VAR 0 27
133259: PUSH
133260: EMPTY
133261: ST_TO_ADDR
// bombed := [ ] ;
133262: LD_ADDR_VAR 0 28
133266: PUSH
133267: EMPTY
133268: ST_TO_ADDR
// healers := [ ] ;
133269: LD_ADDR_VAR 0 31
133273: PUSH
133274: EMPTY
133275: ST_TO_ADDR
// to_heal := [ ] ;
133276: LD_ADDR_VAR 0 30
133280: PUSH
133281: EMPTY
133282: ST_TO_ADDR
// repairs := [ ] ;
133283: LD_ADDR_VAR 0 33
133287: PUSH
133288: EMPTY
133289: ST_TO_ADDR
// to_repair := [ ] ;
133290: LD_ADDR_VAR 0 32
133294: PUSH
133295: EMPTY
133296: ST_TO_ADDR
// if not group or not path then
133297: LD_VAR 0 4
133301: NOT
133302: PUSH
133303: LD_VAR 0 5
133307: NOT
133308: OR
133309: IFFALSE 133313
// exit ;
133311: GO 137858
// side := GetSide ( group [ 1 ] ) ;
133313: LD_ADDR_VAR 0 35
133317: PUSH
133318: LD_VAR 0 4
133322: PUSH
133323: LD_INT 1
133325: ARRAY
133326: PPUSH
133327: CALL_OW 255
133331: ST_TO_ADDR
// if flags then
133332: LD_VAR 0 6
133336: IFFALSE 133480
// begin f_ignore_area := flags [ 1 ] ;
133338: LD_ADDR_VAR 0 17
133342: PUSH
133343: LD_VAR 0 6
133347: PUSH
133348: LD_INT 1
133350: ARRAY
133351: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
133352: LD_ADDR_VAR 0 18
133356: PUSH
133357: LD_VAR 0 6
133361: PUSH
133362: LD_INT 2
133364: ARRAY
133365: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
133366: LD_ADDR_VAR 0 19
133370: PUSH
133371: LD_VAR 0 6
133375: PUSH
133376: LD_INT 3
133378: ARRAY
133379: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
133380: LD_ADDR_VAR 0 20
133384: PUSH
133385: LD_VAR 0 6
133389: PUSH
133390: LD_INT 4
133392: ARRAY
133393: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
133394: LD_ADDR_VAR 0 21
133398: PUSH
133399: LD_VAR 0 6
133403: PUSH
133404: LD_INT 5
133406: ARRAY
133407: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
133408: LD_ADDR_VAR 0 22
133412: PUSH
133413: LD_VAR 0 6
133417: PUSH
133418: LD_INT 6
133420: ARRAY
133421: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
133422: LD_ADDR_VAR 0 23
133426: PUSH
133427: LD_VAR 0 6
133431: PUSH
133432: LD_INT 7
133434: ARRAY
133435: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
133436: LD_ADDR_VAR 0 24
133440: PUSH
133441: LD_VAR 0 6
133445: PUSH
133446: LD_INT 8
133448: ARRAY
133449: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
133450: LD_ADDR_VAR 0 25
133454: PUSH
133455: LD_VAR 0 6
133459: PUSH
133460: LD_INT 9
133462: ARRAY
133463: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
133464: LD_ADDR_VAR 0 26
133468: PUSH
133469: LD_VAR 0 6
133473: PUSH
133474: LD_INT 10
133476: ARRAY
133477: ST_TO_ADDR
// end else
133478: GO 133560
// begin f_ignore_area := false ;
133480: LD_ADDR_VAR 0 17
133484: PUSH
133485: LD_INT 0
133487: ST_TO_ADDR
// f_capture := false ;
133488: LD_ADDR_VAR 0 18
133492: PUSH
133493: LD_INT 0
133495: ST_TO_ADDR
// f_ignore_civ := false ;
133496: LD_ADDR_VAR 0 19
133500: PUSH
133501: LD_INT 0
133503: ST_TO_ADDR
// f_murder := false ;
133504: LD_ADDR_VAR 0 20
133508: PUSH
133509: LD_INT 0
133511: ST_TO_ADDR
// f_mines := false ;
133512: LD_ADDR_VAR 0 21
133516: PUSH
133517: LD_INT 0
133519: ST_TO_ADDR
// f_repair := false ;
133520: LD_ADDR_VAR 0 22
133524: PUSH
133525: LD_INT 0
133527: ST_TO_ADDR
// f_heal := false ;
133528: LD_ADDR_VAR 0 23
133532: PUSH
133533: LD_INT 0
133535: ST_TO_ADDR
// f_spacetime := false ;
133536: LD_ADDR_VAR 0 24
133540: PUSH
133541: LD_INT 0
133543: ST_TO_ADDR
// f_attack_depot := false ;
133544: LD_ADDR_VAR 0 25
133548: PUSH
133549: LD_INT 0
133551: ST_TO_ADDR
// f_crawl := false ;
133552: LD_ADDR_VAR 0 26
133556: PUSH
133557: LD_INT 0
133559: ST_TO_ADDR
// end ; if f_heal then
133560: LD_VAR 0 23
133564: IFFALSE 133591
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
133566: LD_ADDR_VAR 0 31
133570: PUSH
133571: LD_VAR 0 4
133575: PPUSH
133576: LD_INT 25
133578: PUSH
133579: LD_INT 4
133581: PUSH
133582: EMPTY
133583: LIST
133584: LIST
133585: PPUSH
133586: CALL_OW 72
133590: ST_TO_ADDR
// if f_repair then
133591: LD_VAR 0 22
133595: IFFALSE 133622
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
133597: LD_ADDR_VAR 0 33
133601: PUSH
133602: LD_VAR 0 4
133606: PPUSH
133607: LD_INT 25
133609: PUSH
133610: LD_INT 3
133612: PUSH
133613: EMPTY
133614: LIST
133615: LIST
133616: PPUSH
133617: CALL_OW 72
133621: ST_TO_ADDR
// units_path := [ ] ;
133622: LD_ADDR_VAR 0 16
133626: PUSH
133627: EMPTY
133628: ST_TO_ADDR
// for i = 1 to group do
133629: LD_ADDR_VAR 0 7
133633: PUSH
133634: DOUBLE
133635: LD_INT 1
133637: DEC
133638: ST_TO_ADDR
133639: LD_VAR 0 4
133643: PUSH
133644: FOR_TO
133645: IFFALSE 133674
// units_path := Replace ( units_path , i , path ) ;
133647: LD_ADDR_VAR 0 16
133651: PUSH
133652: LD_VAR 0 16
133656: PPUSH
133657: LD_VAR 0 7
133661: PPUSH
133662: LD_VAR 0 5
133666: PPUSH
133667: CALL_OW 1
133671: ST_TO_ADDR
133672: GO 133644
133674: POP
133675: POP
// repeat for i = group downto 1 do
133676: LD_ADDR_VAR 0 7
133680: PUSH
133681: DOUBLE
133682: LD_VAR 0 4
133686: INC
133687: ST_TO_ADDR
133688: LD_INT 1
133690: PUSH
133691: FOR_DOWNTO
133692: IFFALSE 137814
// begin wait ( 5 ) ;
133694: LD_INT 5
133696: PPUSH
133697: CALL_OW 67
// tmp := [ ] ;
133701: LD_ADDR_VAR 0 14
133705: PUSH
133706: EMPTY
133707: ST_TO_ADDR
// attacking := false ;
133708: LD_ADDR_VAR 0 29
133712: PUSH
133713: LD_INT 0
133715: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
133716: LD_VAR 0 4
133720: PUSH
133721: LD_VAR 0 7
133725: ARRAY
133726: PPUSH
133727: CALL_OW 301
133731: PUSH
133732: LD_VAR 0 4
133736: PUSH
133737: LD_VAR 0 7
133741: ARRAY
133742: NOT
133743: OR
133744: IFFALSE 133853
// begin if GetType ( group [ i ] ) = unit_human then
133746: LD_VAR 0 4
133750: PUSH
133751: LD_VAR 0 7
133755: ARRAY
133756: PPUSH
133757: CALL_OW 247
133761: PUSH
133762: LD_INT 1
133764: EQUAL
133765: IFFALSE 133811
// begin to_heal := to_heal diff group [ i ] ;
133767: LD_ADDR_VAR 0 30
133771: PUSH
133772: LD_VAR 0 30
133776: PUSH
133777: LD_VAR 0 4
133781: PUSH
133782: LD_VAR 0 7
133786: ARRAY
133787: DIFF
133788: ST_TO_ADDR
// healers := healers diff group [ i ] ;
133789: LD_ADDR_VAR 0 31
133793: PUSH
133794: LD_VAR 0 31
133798: PUSH
133799: LD_VAR 0 4
133803: PUSH
133804: LD_VAR 0 7
133808: ARRAY
133809: DIFF
133810: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
133811: LD_ADDR_VAR 0 4
133815: PUSH
133816: LD_VAR 0 4
133820: PPUSH
133821: LD_VAR 0 7
133825: PPUSH
133826: CALL_OW 3
133830: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
133831: LD_ADDR_VAR 0 16
133835: PUSH
133836: LD_VAR 0 16
133840: PPUSH
133841: LD_VAR 0 7
133845: PPUSH
133846: CALL_OW 3
133850: ST_TO_ADDR
// continue ;
133851: GO 133691
// end ; if f_repair then
133853: LD_VAR 0 22
133857: IFFALSE 134346
// begin if GetType ( group [ i ] ) = unit_vehicle then
133859: LD_VAR 0 4
133863: PUSH
133864: LD_VAR 0 7
133868: ARRAY
133869: PPUSH
133870: CALL_OW 247
133874: PUSH
133875: LD_INT 2
133877: EQUAL
133878: IFFALSE 134068
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
133880: LD_VAR 0 4
133884: PUSH
133885: LD_VAR 0 7
133889: ARRAY
133890: PPUSH
133891: CALL_OW 256
133895: PUSH
133896: LD_INT 700
133898: LESS
133899: PUSH
133900: LD_VAR 0 4
133904: PUSH
133905: LD_VAR 0 7
133909: ARRAY
133910: PUSH
133911: LD_VAR 0 32
133915: IN
133916: NOT
133917: AND
133918: IFFALSE 133942
// to_repair := to_repair union group [ i ] ;
133920: LD_ADDR_VAR 0 32
133924: PUSH
133925: LD_VAR 0 32
133929: PUSH
133930: LD_VAR 0 4
133934: PUSH
133935: LD_VAR 0 7
133939: ARRAY
133940: UNION
133941: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
133942: LD_VAR 0 4
133946: PUSH
133947: LD_VAR 0 7
133951: ARRAY
133952: PPUSH
133953: CALL_OW 256
133957: PUSH
133958: LD_INT 1000
133960: EQUAL
133961: PUSH
133962: LD_VAR 0 4
133966: PUSH
133967: LD_VAR 0 7
133971: ARRAY
133972: PUSH
133973: LD_VAR 0 32
133977: IN
133978: AND
133979: IFFALSE 134003
// to_repair := to_repair diff group [ i ] ;
133981: LD_ADDR_VAR 0 32
133985: PUSH
133986: LD_VAR 0 32
133990: PUSH
133991: LD_VAR 0 4
133995: PUSH
133996: LD_VAR 0 7
134000: ARRAY
134001: DIFF
134002: ST_TO_ADDR
// if group [ i ] in to_repair then
134003: LD_VAR 0 4
134007: PUSH
134008: LD_VAR 0 7
134012: ARRAY
134013: PUSH
134014: LD_VAR 0 32
134018: IN
134019: IFFALSE 134066
// begin if not IsInArea ( group [ i ] , f_repair ) then
134021: LD_VAR 0 4
134025: PUSH
134026: LD_VAR 0 7
134030: ARRAY
134031: PPUSH
134032: LD_VAR 0 22
134036: PPUSH
134037: CALL_OW 308
134041: NOT
134042: IFFALSE 134064
// ComMoveToArea ( group [ i ] , f_repair ) ;
134044: LD_VAR 0 4
134048: PUSH
134049: LD_VAR 0 7
134053: ARRAY
134054: PPUSH
134055: LD_VAR 0 22
134059: PPUSH
134060: CALL_OW 113
// continue ;
134064: GO 133691
// end ; end else
134066: GO 134346
// if group [ i ] in repairs then
134068: LD_VAR 0 4
134072: PUSH
134073: LD_VAR 0 7
134077: ARRAY
134078: PUSH
134079: LD_VAR 0 33
134083: IN
134084: IFFALSE 134346
// begin if IsInUnit ( group [ i ] ) then
134086: LD_VAR 0 4
134090: PUSH
134091: LD_VAR 0 7
134095: ARRAY
134096: PPUSH
134097: CALL_OW 310
134101: IFFALSE 134169
// begin z := IsInUnit ( group [ i ] ) ;
134103: LD_ADDR_VAR 0 13
134107: PUSH
134108: LD_VAR 0 4
134112: PUSH
134113: LD_VAR 0 7
134117: ARRAY
134118: PPUSH
134119: CALL_OW 310
134123: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
134124: LD_VAR 0 13
134128: PUSH
134129: LD_VAR 0 32
134133: IN
134134: PUSH
134135: LD_VAR 0 13
134139: PPUSH
134140: LD_VAR 0 22
134144: PPUSH
134145: CALL_OW 308
134149: AND
134150: IFFALSE 134167
// ComExitVehicle ( group [ i ] ) ;
134152: LD_VAR 0 4
134156: PUSH
134157: LD_VAR 0 7
134161: ARRAY
134162: PPUSH
134163: CALL_OW 121
// end else
134167: GO 134346
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
134169: LD_ADDR_VAR 0 13
134173: PUSH
134174: LD_VAR 0 4
134178: PPUSH
134179: LD_INT 95
134181: PUSH
134182: LD_VAR 0 22
134186: PUSH
134187: EMPTY
134188: LIST
134189: LIST
134190: PUSH
134191: LD_INT 58
134193: PUSH
134194: EMPTY
134195: LIST
134196: PUSH
134197: EMPTY
134198: LIST
134199: LIST
134200: PPUSH
134201: CALL_OW 72
134205: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
134206: LD_VAR 0 4
134210: PUSH
134211: LD_VAR 0 7
134215: ARRAY
134216: PPUSH
134217: CALL_OW 314
134221: NOT
134222: IFFALSE 134344
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
134224: LD_ADDR_VAR 0 10
134228: PUSH
134229: LD_VAR 0 13
134233: PPUSH
134234: LD_VAR 0 4
134238: PUSH
134239: LD_VAR 0 7
134243: ARRAY
134244: PPUSH
134245: CALL_OW 74
134249: ST_TO_ADDR
// if not x then
134250: LD_VAR 0 10
134254: NOT
134255: IFFALSE 134259
// continue ;
134257: GO 133691
// if GetLives ( x ) < 1000 then
134259: LD_VAR 0 10
134263: PPUSH
134264: CALL_OW 256
134268: PUSH
134269: LD_INT 1000
134271: LESS
134272: IFFALSE 134296
// ComRepairVehicle ( group [ i ] , x ) else
134274: LD_VAR 0 4
134278: PUSH
134279: LD_VAR 0 7
134283: ARRAY
134284: PPUSH
134285: LD_VAR 0 10
134289: PPUSH
134290: CALL_OW 129
134294: GO 134344
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
134296: LD_VAR 0 23
134300: PUSH
134301: LD_VAR 0 4
134305: PUSH
134306: LD_VAR 0 7
134310: ARRAY
134311: PPUSH
134312: CALL_OW 256
134316: PUSH
134317: LD_INT 1000
134319: LESS
134320: AND
134321: NOT
134322: IFFALSE 134344
// ComEnterUnit ( group [ i ] , x ) ;
134324: LD_VAR 0 4
134328: PUSH
134329: LD_VAR 0 7
134333: ARRAY
134334: PPUSH
134335: LD_VAR 0 10
134339: PPUSH
134340: CALL_OW 120
// end ; continue ;
134344: GO 133691
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
134346: LD_VAR 0 23
134350: PUSH
134351: LD_VAR 0 4
134355: PUSH
134356: LD_VAR 0 7
134360: ARRAY
134361: PPUSH
134362: CALL_OW 247
134366: PUSH
134367: LD_INT 1
134369: EQUAL
134370: AND
134371: IFFALSE 134849
// begin if group [ i ] in healers then
134373: LD_VAR 0 4
134377: PUSH
134378: LD_VAR 0 7
134382: ARRAY
134383: PUSH
134384: LD_VAR 0 31
134388: IN
134389: IFFALSE 134662
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
134391: LD_VAR 0 4
134395: PUSH
134396: LD_VAR 0 7
134400: ARRAY
134401: PPUSH
134402: LD_VAR 0 23
134406: PPUSH
134407: CALL_OW 308
134411: NOT
134412: PUSH
134413: LD_VAR 0 4
134417: PUSH
134418: LD_VAR 0 7
134422: ARRAY
134423: PPUSH
134424: CALL_OW 314
134428: NOT
134429: AND
134430: IFFALSE 134454
// ComMoveToArea ( group [ i ] , f_heal ) else
134432: LD_VAR 0 4
134436: PUSH
134437: LD_VAR 0 7
134441: ARRAY
134442: PPUSH
134443: LD_VAR 0 23
134447: PPUSH
134448: CALL_OW 113
134452: GO 134660
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
134454: LD_VAR 0 4
134458: PUSH
134459: LD_VAR 0 7
134463: ARRAY
134464: PPUSH
134465: CALL 104741 0 1
134469: PPUSH
134470: CALL_OW 256
134474: PUSH
134475: LD_INT 1000
134477: EQUAL
134478: IFFALSE 134497
// ComStop ( group [ i ] ) else
134480: LD_VAR 0 4
134484: PUSH
134485: LD_VAR 0 7
134489: ARRAY
134490: PPUSH
134491: CALL_OW 141
134495: GO 134660
// if not HasTask ( group [ i ] ) and to_heal then
134497: LD_VAR 0 4
134501: PUSH
134502: LD_VAR 0 7
134506: ARRAY
134507: PPUSH
134508: CALL_OW 314
134512: NOT
134513: PUSH
134514: LD_VAR 0 30
134518: AND
134519: IFFALSE 134660
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
134521: LD_ADDR_VAR 0 13
134525: PUSH
134526: LD_VAR 0 30
134530: PPUSH
134531: LD_INT 3
134533: PUSH
134534: LD_INT 54
134536: PUSH
134537: EMPTY
134538: LIST
134539: PUSH
134540: EMPTY
134541: LIST
134542: LIST
134543: PPUSH
134544: CALL_OW 72
134548: PPUSH
134549: LD_VAR 0 4
134553: PUSH
134554: LD_VAR 0 7
134558: ARRAY
134559: PPUSH
134560: CALL_OW 74
134564: ST_TO_ADDR
// if z then
134565: LD_VAR 0 13
134569: IFFALSE 134660
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
134571: LD_INT 91
134573: PUSH
134574: LD_VAR 0 13
134578: PUSH
134579: LD_INT 10
134581: PUSH
134582: EMPTY
134583: LIST
134584: LIST
134585: LIST
134586: PUSH
134587: LD_INT 81
134589: PUSH
134590: LD_VAR 0 13
134594: PPUSH
134595: CALL_OW 255
134599: PUSH
134600: EMPTY
134601: LIST
134602: LIST
134603: PUSH
134604: EMPTY
134605: LIST
134606: LIST
134607: PPUSH
134608: CALL_OW 69
134612: PUSH
134613: LD_INT 0
134615: EQUAL
134616: IFFALSE 134640
// ComHeal ( group [ i ] , z ) else
134618: LD_VAR 0 4
134622: PUSH
134623: LD_VAR 0 7
134627: ARRAY
134628: PPUSH
134629: LD_VAR 0 13
134633: PPUSH
134634: CALL_OW 128
134638: GO 134660
// ComMoveToArea ( group [ i ] , f_heal ) ;
134640: LD_VAR 0 4
134644: PUSH
134645: LD_VAR 0 7
134649: ARRAY
134650: PPUSH
134651: LD_VAR 0 23
134655: PPUSH
134656: CALL_OW 113
// end ; continue ;
134660: GO 133691
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
134662: LD_VAR 0 4
134666: PUSH
134667: LD_VAR 0 7
134671: ARRAY
134672: PPUSH
134673: CALL_OW 256
134677: PUSH
134678: LD_INT 700
134680: LESS
134681: PUSH
134682: LD_VAR 0 4
134686: PUSH
134687: LD_VAR 0 7
134691: ARRAY
134692: PUSH
134693: LD_VAR 0 30
134697: IN
134698: NOT
134699: AND
134700: IFFALSE 134724
// to_heal := to_heal union group [ i ] ;
134702: LD_ADDR_VAR 0 30
134706: PUSH
134707: LD_VAR 0 30
134711: PUSH
134712: LD_VAR 0 4
134716: PUSH
134717: LD_VAR 0 7
134721: ARRAY
134722: UNION
134723: ST_TO_ADDR
// if group [ i ] in to_heal then
134724: LD_VAR 0 4
134728: PUSH
134729: LD_VAR 0 7
134733: ARRAY
134734: PUSH
134735: LD_VAR 0 30
134739: IN
134740: IFFALSE 134849
// begin if GetLives ( group [ i ] ) = 1000 then
134742: LD_VAR 0 4
134746: PUSH
134747: LD_VAR 0 7
134751: ARRAY
134752: PPUSH
134753: CALL_OW 256
134757: PUSH
134758: LD_INT 1000
134760: EQUAL
134761: IFFALSE 134787
// to_heal := to_heal diff group [ i ] else
134763: LD_ADDR_VAR 0 30
134767: PUSH
134768: LD_VAR 0 30
134772: PUSH
134773: LD_VAR 0 4
134777: PUSH
134778: LD_VAR 0 7
134782: ARRAY
134783: DIFF
134784: ST_TO_ADDR
134785: GO 134849
// begin if not IsInArea ( group [ i ] , to_heal ) then
134787: LD_VAR 0 4
134791: PUSH
134792: LD_VAR 0 7
134796: ARRAY
134797: PPUSH
134798: LD_VAR 0 30
134802: PPUSH
134803: CALL_OW 308
134807: NOT
134808: IFFALSE 134832
// ComMoveToArea ( group [ i ] , f_heal ) else
134810: LD_VAR 0 4
134814: PUSH
134815: LD_VAR 0 7
134819: ARRAY
134820: PPUSH
134821: LD_VAR 0 23
134825: PPUSH
134826: CALL_OW 113
134830: GO 134847
// ComHold ( group [ i ] ) ;
134832: LD_VAR 0 4
134836: PUSH
134837: LD_VAR 0 7
134841: ARRAY
134842: PPUSH
134843: CALL_OW 140
// continue ;
134847: GO 133691
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
134849: LD_VAR 0 4
134853: PUSH
134854: LD_VAR 0 7
134858: ARRAY
134859: PPUSH
134860: LD_INT 10
134862: PPUSH
134863: CALL 102523 0 2
134867: NOT
134868: PUSH
134869: LD_VAR 0 16
134873: PUSH
134874: LD_VAR 0 7
134878: ARRAY
134879: PUSH
134880: EMPTY
134881: EQUAL
134882: NOT
134883: AND
134884: IFFALSE 135150
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
134886: LD_VAR 0 4
134890: PUSH
134891: LD_VAR 0 7
134895: ARRAY
134896: PPUSH
134897: CALL_OW 262
134901: PUSH
134902: LD_INT 1
134904: PUSH
134905: LD_INT 2
134907: PUSH
134908: EMPTY
134909: LIST
134910: LIST
134911: IN
134912: IFFALSE 134953
// if GetFuel ( group [ i ] ) < 10 then
134914: LD_VAR 0 4
134918: PUSH
134919: LD_VAR 0 7
134923: ARRAY
134924: PPUSH
134925: CALL_OW 261
134929: PUSH
134930: LD_INT 10
134932: LESS
134933: IFFALSE 134953
// SetFuel ( group [ i ] , 12 ) ;
134935: LD_VAR 0 4
134939: PUSH
134940: LD_VAR 0 7
134944: ARRAY
134945: PPUSH
134946: LD_INT 12
134948: PPUSH
134949: CALL_OW 240
// if units_path [ i ] then
134953: LD_VAR 0 16
134957: PUSH
134958: LD_VAR 0 7
134962: ARRAY
134963: IFFALSE 135148
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
134965: LD_VAR 0 4
134969: PUSH
134970: LD_VAR 0 7
134974: ARRAY
134975: PPUSH
134976: LD_VAR 0 16
134980: PUSH
134981: LD_VAR 0 7
134985: ARRAY
134986: PUSH
134987: LD_INT 1
134989: ARRAY
134990: PUSH
134991: LD_INT 1
134993: ARRAY
134994: PPUSH
134995: LD_VAR 0 16
134999: PUSH
135000: LD_VAR 0 7
135004: ARRAY
135005: PUSH
135006: LD_INT 1
135008: ARRAY
135009: PUSH
135010: LD_INT 2
135012: ARRAY
135013: PPUSH
135014: CALL_OW 297
135018: PUSH
135019: LD_INT 6
135021: GREATER
135022: IFFALSE 135097
// begin if not HasTask ( group [ i ] ) then
135024: LD_VAR 0 4
135028: PUSH
135029: LD_VAR 0 7
135033: ARRAY
135034: PPUSH
135035: CALL_OW 314
135039: NOT
135040: IFFALSE 135095
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
135042: LD_VAR 0 4
135046: PUSH
135047: LD_VAR 0 7
135051: ARRAY
135052: PPUSH
135053: LD_VAR 0 16
135057: PUSH
135058: LD_VAR 0 7
135062: ARRAY
135063: PUSH
135064: LD_INT 1
135066: ARRAY
135067: PUSH
135068: LD_INT 1
135070: ARRAY
135071: PPUSH
135072: LD_VAR 0 16
135076: PUSH
135077: LD_VAR 0 7
135081: ARRAY
135082: PUSH
135083: LD_INT 1
135085: ARRAY
135086: PUSH
135087: LD_INT 2
135089: ARRAY
135090: PPUSH
135091: CALL_OW 114
// end else
135095: GO 135148
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
135097: LD_ADDR_VAR 0 15
135101: PUSH
135102: LD_VAR 0 16
135106: PUSH
135107: LD_VAR 0 7
135111: ARRAY
135112: PPUSH
135113: LD_INT 1
135115: PPUSH
135116: CALL_OW 3
135120: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
135121: LD_ADDR_VAR 0 16
135125: PUSH
135126: LD_VAR 0 16
135130: PPUSH
135131: LD_VAR 0 7
135135: PPUSH
135136: LD_VAR 0 15
135140: PPUSH
135141: CALL_OW 1
135145: ST_TO_ADDR
// continue ;
135146: GO 133691
// end ; end ; end else
135148: GO 137812
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
135150: LD_ADDR_VAR 0 14
135154: PUSH
135155: LD_INT 81
135157: PUSH
135158: LD_VAR 0 4
135162: PUSH
135163: LD_VAR 0 7
135167: ARRAY
135168: PPUSH
135169: CALL_OW 255
135173: PUSH
135174: EMPTY
135175: LIST
135176: LIST
135177: PPUSH
135178: CALL_OW 69
135182: ST_TO_ADDR
// if not tmp then
135183: LD_VAR 0 14
135187: NOT
135188: IFFALSE 135192
// continue ;
135190: GO 133691
// if f_ignore_area then
135192: LD_VAR 0 17
135196: IFFALSE 135284
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
135198: LD_ADDR_VAR 0 15
135202: PUSH
135203: LD_VAR 0 14
135207: PPUSH
135208: LD_INT 3
135210: PUSH
135211: LD_INT 92
135213: PUSH
135214: LD_VAR 0 17
135218: PUSH
135219: LD_INT 1
135221: ARRAY
135222: PUSH
135223: LD_VAR 0 17
135227: PUSH
135228: LD_INT 2
135230: ARRAY
135231: PUSH
135232: LD_VAR 0 17
135236: PUSH
135237: LD_INT 3
135239: ARRAY
135240: PUSH
135241: EMPTY
135242: LIST
135243: LIST
135244: LIST
135245: LIST
135246: PUSH
135247: EMPTY
135248: LIST
135249: LIST
135250: PPUSH
135251: CALL_OW 72
135255: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
135256: LD_VAR 0 14
135260: PUSH
135261: LD_VAR 0 15
135265: DIFF
135266: IFFALSE 135284
// tmp := tmp diff tmp2 ;
135268: LD_ADDR_VAR 0 14
135272: PUSH
135273: LD_VAR 0 14
135277: PUSH
135278: LD_VAR 0 15
135282: DIFF
135283: ST_TO_ADDR
// end ; if not f_murder then
135284: LD_VAR 0 20
135288: NOT
135289: IFFALSE 135347
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
135291: LD_ADDR_VAR 0 15
135295: PUSH
135296: LD_VAR 0 14
135300: PPUSH
135301: LD_INT 3
135303: PUSH
135304: LD_INT 50
135306: PUSH
135307: EMPTY
135308: LIST
135309: PUSH
135310: EMPTY
135311: LIST
135312: LIST
135313: PPUSH
135314: CALL_OW 72
135318: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
135319: LD_VAR 0 14
135323: PUSH
135324: LD_VAR 0 15
135328: DIFF
135329: IFFALSE 135347
// tmp := tmp diff tmp2 ;
135331: LD_ADDR_VAR 0 14
135335: PUSH
135336: LD_VAR 0 14
135340: PUSH
135341: LD_VAR 0 15
135345: DIFF
135346: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
135347: LD_ADDR_VAR 0 14
135351: PUSH
135352: LD_VAR 0 4
135356: PUSH
135357: LD_VAR 0 7
135361: ARRAY
135362: PPUSH
135363: LD_VAR 0 14
135367: PPUSH
135368: LD_INT 1
135370: PPUSH
135371: LD_INT 1
135373: PPUSH
135374: CALL 75067 0 4
135378: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
135379: LD_VAR 0 4
135383: PUSH
135384: LD_VAR 0 7
135388: ARRAY
135389: PPUSH
135390: CALL_OW 257
135394: PUSH
135395: LD_INT 1
135397: EQUAL
135398: IFFALSE 135846
// begin if WantPlant ( group [ i ] ) then
135400: LD_VAR 0 4
135404: PUSH
135405: LD_VAR 0 7
135409: ARRAY
135410: PPUSH
135411: CALL 74568 0 1
135415: IFFALSE 135419
// continue ;
135417: GO 133691
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
135419: LD_VAR 0 18
135423: PUSH
135424: LD_VAR 0 4
135428: PUSH
135429: LD_VAR 0 7
135433: ARRAY
135434: PPUSH
135435: CALL_OW 310
135439: NOT
135440: AND
135441: PUSH
135442: LD_VAR 0 14
135446: PUSH
135447: LD_INT 1
135449: ARRAY
135450: PUSH
135451: LD_VAR 0 14
135455: PPUSH
135456: LD_INT 21
135458: PUSH
135459: LD_INT 2
135461: PUSH
135462: EMPTY
135463: LIST
135464: LIST
135465: PUSH
135466: LD_INT 58
135468: PUSH
135469: EMPTY
135470: LIST
135471: PUSH
135472: EMPTY
135473: LIST
135474: LIST
135475: PPUSH
135476: CALL_OW 72
135480: IN
135481: AND
135482: IFFALSE 135518
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
135484: LD_VAR 0 4
135488: PUSH
135489: LD_VAR 0 7
135493: ARRAY
135494: PPUSH
135495: LD_VAR 0 14
135499: PUSH
135500: LD_INT 1
135502: ARRAY
135503: PPUSH
135504: CALL_OW 120
// attacking := true ;
135508: LD_ADDR_VAR 0 29
135512: PUSH
135513: LD_INT 1
135515: ST_TO_ADDR
// continue ;
135516: GO 133691
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
135518: LD_VAR 0 26
135522: PUSH
135523: LD_VAR 0 4
135527: PUSH
135528: LD_VAR 0 7
135532: ARRAY
135533: PPUSH
135534: CALL_OW 257
135538: PUSH
135539: LD_INT 1
135541: EQUAL
135542: AND
135543: PUSH
135544: LD_VAR 0 4
135548: PUSH
135549: LD_VAR 0 7
135553: ARRAY
135554: PPUSH
135555: CALL_OW 256
135559: PUSH
135560: LD_INT 800
135562: LESS
135563: AND
135564: PUSH
135565: LD_VAR 0 4
135569: PUSH
135570: LD_VAR 0 7
135574: ARRAY
135575: PPUSH
135576: CALL_OW 318
135580: NOT
135581: AND
135582: IFFALSE 135599
// ComCrawl ( group [ i ] ) ;
135584: LD_VAR 0 4
135588: PUSH
135589: LD_VAR 0 7
135593: ARRAY
135594: PPUSH
135595: CALL_OW 137
// if f_mines then
135599: LD_VAR 0 21
135603: IFFALSE 135846
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
135605: LD_VAR 0 14
135609: PUSH
135610: LD_INT 1
135612: ARRAY
135613: PPUSH
135614: CALL_OW 247
135618: PUSH
135619: LD_INT 3
135621: EQUAL
135622: PUSH
135623: LD_VAR 0 14
135627: PUSH
135628: LD_INT 1
135630: ARRAY
135631: PUSH
135632: LD_VAR 0 27
135636: IN
135637: NOT
135638: AND
135639: IFFALSE 135846
// begin x := GetX ( tmp [ 1 ] ) ;
135641: LD_ADDR_VAR 0 10
135645: PUSH
135646: LD_VAR 0 14
135650: PUSH
135651: LD_INT 1
135653: ARRAY
135654: PPUSH
135655: CALL_OW 250
135659: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
135660: LD_ADDR_VAR 0 11
135664: PUSH
135665: LD_VAR 0 14
135669: PUSH
135670: LD_INT 1
135672: ARRAY
135673: PPUSH
135674: CALL_OW 251
135678: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
135679: LD_ADDR_VAR 0 12
135683: PUSH
135684: LD_VAR 0 4
135688: PUSH
135689: LD_VAR 0 7
135693: ARRAY
135694: PPUSH
135695: CALL 102608 0 1
135699: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
135700: LD_VAR 0 4
135704: PUSH
135705: LD_VAR 0 7
135709: ARRAY
135710: PPUSH
135711: LD_VAR 0 10
135715: PPUSH
135716: LD_VAR 0 11
135720: PPUSH
135721: LD_VAR 0 14
135725: PUSH
135726: LD_INT 1
135728: ARRAY
135729: PPUSH
135730: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
135734: LD_VAR 0 4
135738: PUSH
135739: LD_VAR 0 7
135743: ARRAY
135744: PPUSH
135745: LD_VAR 0 10
135749: PPUSH
135750: LD_VAR 0 12
135754: PPUSH
135755: LD_INT 7
135757: PPUSH
135758: CALL_OW 272
135762: PPUSH
135763: LD_VAR 0 11
135767: PPUSH
135768: LD_VAR 0 12
135772: PPUSH
135773: LD_INT 7
135775: PPUSH
135776: CALL_OW 273
135780: PPUSH
135781: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
135785: LD_VAR 0 4
135789: PUSH
135790: LD_VAR 0 7
135794: ARRAY
135795: PPUSH
135796: LD_INT 71
135798: PPUSH
135799: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
135803: LD_ADDR_VAR 0 27
135807: PUSH
135808: LD_VAR 0 27
135812: PPUSH
135813: LD_VAR 0 27
135817: PUSH
135818: LD_INT 1
135820: PLUS
135821: PPUSH
135822: LD_VAR 0 14
135826: PUSH
135827: LD_INT 1
135829: ARRAY
135830: PPUSH
135831: CALL_OW 1
135835: ST_TO_ADDR
// attacking := true ;
135836: LD_ADDR_VAR 0 29
135840: PUSH
135841: LD_INT 1
135843: ST_TO_ADDR
// continue ;
135844: GO 133691
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
135846: LD_VAR 0 4
135850: PUSH
135851: LD_VAR 0 7
135855: ARRAY
135856: PPUSH
135857: CALL_OW 257
135861: PUSH
135862: LD_INT 17
135864: EQUAL
135865: PUSH
135866: LD_VAR 0 4
135870: PUSH
135871: LD_VAR 0 7
135875: ARRAY
135876: PPUSH
135877: CALL_OW 110
135881: PUSH
135882: LD_INT 71
135884: EQUAL
135885: NOT
135886: AND
135887: IFFALSE 136033
// begin attacking := false ;
135889: LD_ADDR_VAR 0 29
135893: PUSH
135894: LD_INT 0
135896: ST_TO_ADDR
// k := 5 ;
135897: LD_ADDR_VAR 0 9
135901: PUSH
135902: LD_INT 5
135904: ST_TO_ADDR
// if tmp < k then
135905: LD_VAR 0 14
135909: PUSH
135910: LD_VAR 0 9
135914: LESS
135915: IFFALSE 135927
// k := tmp ;
135917: LD_ADDR_VAR 0 9
135921: PUSH
135922: LD_VAR 0 14
135926: ST_TO_ADDR
// for j = 1 to k do
135927: LD_ADDR_VAR 0 8
135931: PUSH
135932: DOUBLE
135933: LD_INT 1
135935: DEC
135936: ST_TO_ADDR
135937: LD_VAR 0 9
135941: PUSH
135942: FOR_TO
135943: IFFALSE 136031
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
135945: LD_VAR 0 14
135949: PUSH
135950: LD_VAR 0 8
135954: ARRAY
135955: PUSH
135956: LD_VAR 0 14
135960: PPUSH
135961: LD_INT 58
135963: PUSH
135964: EMPTY
135965: LIST
135966: PPUSH
135967: CALL_OW 72
135971: IN
135972: NOT
135973: IFFALSE 136029
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
135975: LD_VAR 0 4
135979: PUSH
135980: LD_VAR 0 7
135984: ARRAY
135985: PPUSH
135986: LD_VAR 0 14
135990: PUSH
135991: LD_VAR 0 8
135995: ARRAY
135996: PPUSH
135997: CALL_OW 115
// attacking := true ;
136001: LD_ADDR_VAR 0 29
136005: PUSH
136006: LD_INT 1
136008: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
136009: LD_VAR 0 4
136013: PUSH
136014: LD_VAR 0 7
136018: ARRAY
136019: PPUSH
136020: LD_INT 71
136022: PPUSH
136023: CALL_OW 109
// continue ;
136027: GO 135942
// end ; end ;
136029: GO 135942
136031: POP
136032: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
136033: LD_VAR 0 4
136037: PUSH
136038: LD_VAR 0 7
136042: ARRAY
136043: PPUSH
136044: CALL_OW 257
136048: PUSH
136049: LD_INT 8
136051: EQUAL
136052: PUSH
136053: LD_VAR 0 4
136057: PUSH
136058: LD_VAR 0 7
136062: ARRAY
136063: PPUSH
136064: CALL_OW 264
136068: PUSH
136069: LD_INT 28
136071: PUSH
136072: LD_INT 45
136074: PUSH
136075: LD_INT 7
136077: PUSH
136078: LD_INT 47
136080: PUSH
136081: EMPTY
136082: LIST
136083: LIST
136084: LIST
136085: LIST
136086: IN
136087: OR
136088: IFFALSE 136344
// begin attacking := false ;
136090: LD_ADDR_VAR 0 29
136094: PUSH
136095: LD_INT 0
136097: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
136098: LD_VAR 0 14
136102: PUSH
136103: LD_INT 1
136105: ARRAY
136106: PPUSH
136107: CALL_OW 266
136111: PUSH
136112: LD_INT 32
136114: PUSH
136115: LD_INT 31
136117: PUSH
136118: LD_INT 33
136120: PUSH
136121: LD_INT 4
136123: PUSH
136124: LD_INT 5
136126: PUSH
136127: EMPTY
136128: LIST
136129: LIST
136130: LIST
136131: LIST
136132: LIST
136133: IN
136134: IFFALSE 136320
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
136136: LD_ADDR_VAR 0 9
136140: PUSH
136141: LD_VAR 0 14
136145: PUSH
136146: LD_INT 1
136148: ARRAY
136149: PPUSH
136150: CALL_OW 266
136154: PPUSH
136155: LD_VAR 0 14
136159: PUSH
136160: LD_INT 1
136162: ARRAY
136163: PPUSH
136164: CALL_OW 250
136168: PPUSH
136169: LD_VAR 0 14
136173: PUSH
136174: LD_INT 1
136176: ARRAY
136177: PPUSH
136178: CALL_OW 251
136182: PPUSH
136183: LD_VAR 0 14
136187: PUSH
136188: LD_INT 1
136190: ARRAY
136191: PPUSH
136192: CALL_OW 254
136196: PPUSH
136197: LD_VAR 0 14
136201: PUSH
136202: LD_INT 1
136204: ARRAY
136205: PPUSH
136206: CALL_OW 248
136210: PPUSH
136211: LD_INT 0
136213: PPUSH
136214: CALL 83978 0 6
136218: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
136219: LD_ADDR_VAR 0 8
136223: PUSH
136224: LD_VAR 0 4
136228: PUSH
136229: LD_VAR 0 7
136233: ARRAY
136234: PPUSH
136235: LD_VAR 0 9
136239: PPUSH
136240: CALL 102721 0 2
136244: ST_TO_ADDR
// if j then
136245: LD_VAR 0 8
136249: IFFALSE 136318
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
136251: LD_VAR 0 8
136255: PUSH
136256: LD_INT 1
136258: ARRAY
136259: PPUSH
136260: LD_VAR 0 8
136264: PUSH
136265: LD_INT 2
136267: ARRAY
136268: PPUSH
136269: CALL_OW 488
136273: IFFALSE 136318
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
136275: LD_VAR 0 4
136279: PUSH
136280: LD_VAR 0 7
136284: ARRAY
136285: PPUSH
136286: LD_VAR 0 8
136290: PUSH
136291: LD_INT 1
136293: ARRAY
136294: PPUSH
136295: LD_VAR 0 8
136299: PUSH
136300: LD_INT 2
136302: ARRAY
136303: PPUSH
136304: CALL_OW 116
// attacking := true ;
136308: LD_ADDR_VAR 0 29
136312: PUSH
136313: LD_INT 1
136315: ST_TO_ADDR
// continue ;
136316: GO 133691
// end ; end else
136318: GO 136344
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
136320: LD_VAR 0 4
136324: PUSH
136325: LD_VAR 0 7
136329: ARRAY
136330: PPUSH
136331: LD_VAR 0 14
136335: PUSH
136336: LD_INT 1
136338: ARRAY
136339: PPUSH
136340: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
136344: LD_VAR 0 4
136348: PUSH
136349: LD_VAR 0 7
136353: ARRAY
136354: PPUSH
136355: CALL_OW 265
136359: PUSH
136360: LD_INT 11
136362: EQUAL
136363: IFFALSE 136641
// begin k := 10 ;
136365: LD_ADDR_VAR 0 9
136369: PUSH
136370: LD_INT 10
136372: ST_TO_ADDR
// x := 0 ;
136373: LD_ADDR_VAR 0 10
136377: PUSH
136378: LD_INT 0
136380: ST_TO_ADDR
// if tmp < k then
136381: LD_VAR 0 14
136385: PUSH
136386: LD_VAR 0 9
136390: LESS
136391: IFFALSE 136403
// k := tmp ;
136393: LD_ADDR_VAR 0 9
136397: PUSH
136398: LD_VAR 0 14
136402: ST_TO_ADDR
// for j = k downto 1 do
136403: LD_ADDR_VAR 0 8
136407: PUSH
136408: DOUBLE
136409: LD_VAR 0 9
136413: INC
136414: ST_TO_ADDR
136415: LD_INT 1
136417: PUSH
136418: FOR_DOWNTO
136419: IFFALSE 136494
// begin if GetType ( tmp [ j ] ) = unit_human then
136421: LD_VAR 0 14
136425: PUSH
136426: LD_VAR 0 8
136430: ARRAY
136431: PPUSH
136432: CALL_OW 247
136436: PUSH
136437: LD_INT 1
136439: EQUAL
136440: IFFALSE 136492
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
136442: LD_VAR 0 4
136446: PUSH
136447: LD_VAR 0 7
136451: ARRAY
136452: PPUSH
136453: LD_VAR 0 14
136457: PUSH
136458: LD_VAR 0 8
136462: ARRAY
136463: PPUSH
136464: CALL 102975 0 2
// x := tmp [ j ] ;
136468: LD_ADDR_VAR 0 10
136472: PUSH
136473: LD_VAR 0 14
136477: PUSH
136478: LD_VAR 0 8
136482: ARRAY
136483: ST_TO_ADDR
// attacking := true ;
136484: LD_ADDR_VAR 0 29
136488: PUSH
136489: LD_INT 1
136491: ST_TO_ADDR
// end ; end ;
136492: GO 136418
136494: POP
136495: POP
// if not x then
136496: LD_VAR 0 10
136500: NOT
136501: IFFALSE 136641
// begin attacking := true ;
136503: LD_ADDR_VAR 0 29
136507: PUSH
136508: LD_INT 1
136510: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
136511: LD_VAR 0 4
136515: PUSH
136516: LD_VAR 0 7
136520: ARRAY
136521: PPUSH
136522: CALL_OW 250
136526: PPUSH
136527: LD_VAR 0 4
136531: PUSH
136532: LD_VAR 0 7
136536: ARRAY
136537: PPUSH
136538: CALL_OW 251
136542: PPUSH
136543: CALL_OW 546
136547: PUSH
136548: LD_INT 2
136550: ARRAY
136551: PUSH
136552: LD_VAR 0 14
136556: PUSH
136557: LD_INT 1
136559: ARRAY
136560: PPUSH
136561: CALL_OW 250
136565: PPUSH
136566: LD_VAR 0 14
136570: PUSH
136571: LD_INT 1
136573: ARRAY
136574: PPUSH
136575: CALL_OW 251
136579: PPUSH
136580: CALL_OW 546
136584: PUSH
136585: LD_INT 2
136587: ARRAY
136588: EQUAL
136589: IFFALSE 136617
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
136591: LD_VAR 0 4
136595: PUSH
136596: LD_VAR 0 7
136600: ARRAY
136601: PPUSH
136602: LD_VAR 0 14
136606: PUSH
136607: LD_INT 1
136609: ARRAY
136610: PPUSH
136611: CALL 102975 0 2
136615: GO 136641
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
136617: LD_VAR 0 4
136621: PUSH
136622: LD_VAR 0 7
136626: ARRAY
136627: PPUSH
136628: LD_VAR 0 14
136632: PUSH
136633: LD_INT 1
136635: ARRAY
136636: PPUSH
136637: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
136641: LD_VAR 0 4
136645: PUSH
136646: LD_VAR 0 7
136650: ARRAY
136651: PPUSH
136652: CALL_OW 264
136656: PUSH
136657: LD_INT 29
136659: EQUAL
136660: IFFALSE 137026
// begin if WantsToAttack ( group [ i ] ) in bombed then
136662: LD_VAR 0 4
136666: PUSH
136667: LD_VAR 0 7
136671: ARRAY
136672: PPUSH
136673: CALL_OW 319
136677: PUSH
136678: LD_VAR 0 28
136682: IN
136683: IFFALSE 136687
// continue ;
136685: GO 133691
// k := 8 ;
136687: LD_ADDR_VAR 0 9
136691: PUSH
136692: LD_INT 8
136694: ST_TO_ADDR
// x := 0 ;
136695: LD_ADDR_VAR 0 10
136699: PUSH
136700: LD_INT 0
136702: ST_TO_ADDR
// if tmp < k then
136703: LD_VAR 0 14
136707: PUSH
136708: LD_VAR 0 9
136712: LESS
136713: IFFALSE 136725
// k := tmp ;
136715: LD_ADDR_VAR 0 9
136719: PUSH
136720: LD_VAR 0 14
136724: ST_TO_ADDR
// for j = 1 to k do
136725: LD_ADDR_VAR 0 8
136729: PUSH
136730: DOUBLE
136731: LD_INT 1
136733: DEC
136734: ST_TO_ADDR
136735: LD_VAR 0 9
136739: PUSH
136740: FOR_TO
136741: IFFALSE 136873
// begin if GetType ( tmp [ j ] ) = unit_building then
136743: LD_VAR 0 14
136747: PUSH
136748: LD_VAR 0 8
136752: ARRAY
136753: PPUSH
136754: CALL_OW 247
136758: PUSH
136759: LD_INT 3
136761: EQUAL
136762: IFFALSE 136871
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
136764: LD_VAR 0 14
136768: PUSH
136769: LD_VAR 0 8
136773: ARRAY
136774: PUSH
136775: LD_VAR 0 28
136779: IN
136780: NOT
136781: PUSH
136782: LD_VAR 0 14
136786: PUSH
136787: LD_VAR 0 8
136791: ARRAY
136792: PPUSH
136793: CALL_OW 313
136797: AND
136798: IFFALSE 136871
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
136800: LD_VAR 0 4
136804: PUSH
136805: LD_VAR 0 7
136809: ARRAY
136810: PPUSH
136811: LD_VAR 0 14
136815: PUSH
136816: LD_VAR 0 8
136820: ARRAY
136821: PPUSH
136822: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
136826: LD_ADDR_VAR 0 28
136830: PUSH
136831: LD_VAR 0 28
136835: PPUSH
136836: LD_VAR 0 28
136840: PUSH
136841: LD_INT 1
136843: PLUS
136844: PPUSH
136845: LD_VAR 0 14
136849: PUSH
136850: LD_VAR 0 8
136854: ARRAY
136855: PPUSH
136856: CALL_OW 1
136860: ST_TO_ADDR
// attacking := true ;
136861: LD_ADDR_VAR 0 29
136865: PUSH
136866: LD_INT 1
136868: ST_TO_ADDR
// break ;
136869: GO 136873
// end ; end ;
136871: GO 136740
136873: POP
136874: POP
// if not attacking and f_attack_depot then
136875: LD_VAR 0 29
136879: NOT
136880: PUSH
136881: LD_VAR 0 25
136885: AND
136886: IFFALSE 136981
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
136888: LD_ADDR_VAR 0 13
136892: PUSH
136893: LD_VAR 0 14
136897: PPUSH
136898: LD_INT 2
136900: PUSH
136901: LD_INT 30
136903: PUSH
136904: LD_INT 0
136906: PUSH
136907: EMPTY
136908: LIST
136909: LIST
136910: PUSH
136911: LD_INT 30
136913: PUSH
136914: LD_INT 1
136916: PUSH
136917: EMPTY
136918: LIST
136919: LIST
136920: PUSH
136921: EMPTY
136922: LIST
136923: LIST
136924: LIST
136925: PPUSH
136926: CALL_OW 72
136930: ST_TO_ADDR
// if z then
136931: LD_VAR 0 13
136935: IFFALSE 136981
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
136937: LD_VAR 0 4
136941: PUSH
136942: LD_VAR 0 7
136946: ARRAY
136947: PPUSH
136948: LD_VAR 0 13
136952: PPUSH
136953: LD_VAR 0 4
136957: PUSH
136958: LD_VAR 0 7
136962: ARRAY
136963: PPUSH
136964: CALL_OW 74
136968: PPUSH
136969: CALL_OW 115
// attacking := true ;
136973: LD_ADDR_VAR 0 29
136977: PUSH
136978: LD_INT 1
136980: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
136981: LD_VAR 0 4
136985: PUSH
136986: LD_VAR 0 7
136990: ARRAY
136991: PPUSH
136992: CALL_OW 256
136996: PUSH
136997: LD_INT 500
136999: LESS
137000: IFFALSE 137026
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
137002: LD_VAR 0 4
137006: PUSH
137007: LD_VAR 0 7
137011: ARRAY
137012: PPUSH
137013: LD_VAR 0 14
137017: PUSH
137018: LD_INT 1
137020: ARRAY
137021: PPUSH
137022: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
137026: LD_VAR 0 4
137030: PUSH
137031: LD_VAR 0 7
137035: ARRAY
137036: PPUSH
137037: CALL_OW 264
137041: PUSH
137042: LD_INT 49
137044: EQUAL
137045: IFFALSE 137166
// begin if not HasTask ( group [ i ] ) then
137047: LD_VAR 0 4
137051: PUSH
137052: LD_VAR 0 7
137056: ARRAY
137057: PPUSH
137058: CALL_OW 314
137062: NOT
137063: IFFALSE 137166
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
137065: LD_ADDR_VAR 0 9
137069: PUSH
137070: LD_INT 81
137072: PUSH
137073: LD_VAR 0 4
137077: PUSH
137078: LD_VAR 0 7
137082: ARRAY
137083: PPUSH
137084: CALL_OW 255
137088: PUSH
137089: EMPTY
137090: LIST
137091: LIST
137092: PPUSH
137093: CALL_OW 69
137097: PPUSH
137098: LD_VAR 0 4
137102: PUSH
137103: LD_VAR 0 7
137107: ARRAY
137108: PPUSH
137109: CALL_OW 74
137113: ST_TO_ADDR
// if k then
137114: LD_VAR 0 9
137118: IFFALSE 137166
// if GetDistUnits ( group [ i ] , k ) > 10 then
137120: LD_VAR 0 4
137124: PUSH
137125: LD_VAR 0 7
137129: ARRAY
137130: PPUSH
137131: LD_VAR 0 9
137135: PPUSH
137136: CALL_OW 296
137140: PUSH
137141: LD_INT 10
137143: GREATER
137144: IFFALSE 137166
// ComMoveUnit ( group [ i ] , k ) ;
137146: LD_VAR 0 4
137150: PUSH
137151: LD_VAR 0 7
137155: ARRAY
137156: PPUSH
137157: LD_VAR 0 9
137161: PPUSH
137162: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
137166: LD_VAR 0 4
137170: PUSH
137171: LD_VAR 0 7
137175: ARRAY
137176: PPUSH
137177: CALL_OW 256
137181: PUSH
137182: LD_INT 250
137184: LESS
137185: PUSH
137186: LD_VAR 0 4
137190: PUSH
137191: LD_VAR 0 7
137195: ARRAY
137196: PUSH
137197: LD_INT 21
137199: PUSH
137200: LD_INT 2
137202: PUSH
137203: EMPTY
137204: LIST
137205: LIST
137206: PUSH
137207: LD_INT 23
137209: PUSH
137210: LD_INT 2
137212: PUSH
137213: EMPTY
137214: LIST
137215: LIST
137216: PUSH
137217: EMPTY
137218: LIST
137219: LIST
137220: PPUSH
137221: CALL_OW 69
137225: IN
137226: AND
137227: IFFALSE 137352
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
137229: LD_ADDR_VAR 0 9
137233: PUSH
137234: LD_OWVAR 3
137238: PUSH
137239: LD_VAR 0 4
137243: PUSH
137244: LD_VAR 0 7
137248: ARRAY
137249: DIFF
137250: PPUSH
137251: LD_VAR 0 4
137255: PUSH
137256: LD_VAR 0 7
137260: ARRAY
137261: PPUSH
137262: CALL_OW 74
137266: ST_TO_ADDR
// if not k then
137267: LD_VAR 0 9
137271: NOT
137272: IFFALSE 137276
// continue ;
137274: GO 133691
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
137276: LD_VAR 0 9
137280: PUSH
137281: LD_INT 81
137283: PUSH
137284: LD_VAR 0 4
137288: PUSH
137289: LD_VAR 0 7
137293: ARRAY
137294: PPUSH
137295: CALL_OW 255
137299: PUSH
137300: EMPTY
137301: LIST
137302: LIST
137303: PPUSH
137304: CALL_OW 69
137308: IN
137309: PUSH
137310: LD_VAR 0 9
137314: PPUSH
137315: LD_VAR 0 4
137319: PUSH
137320: LD_VAR 0 7
137324: ARRAY
137325: PPUSH
137326: CALL_OW 296
137330: PUSH
137331: LD_INT 5
137333: LESS
137334: AND
137335: IFFALSE 137352
// ComAutodestruct ( group [ i ] ) ;
137337: LD_VAR 0 4
137341: PUSH
137342: LD_VAR 0 7
137346: ARRAY
137347: PPUSH
137348: CALL 102873 0 1
// end ; if f_attack_depot then
137352: LD_VAR 0 25
137356: IFFALSE 137468
// begin k := 6 ;
137358: LD_ADDR_VAR 0 9
137362: PUSH
137363: LD_INT 6
137365: ST_TO_ADDR
// if tmp < k then
137366: LD_VAR 0 14
137370: PUSH
137371: LD_VAR 0 9
137375: LESS
137376: IFFALSE 137388
// k := tmp ;
137378: LD_ADDR_VAR 0 9
137382: PUSH
137383: LD_VAR 0 14
137387: ST_TO_ADDR
// for j = 1 to k do
137388: LD_ADDR_VAR 0 8
137392: PUSH
137393: DOUBLE
137394: LD_INT 1
137396: DEC
137397: ST_TO_ADDR
137398: LD_VAR 0 9
137402: PUSH
137403: FOR_TO
137404: IFFALSE 137466
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
137406: LD_VAR 0 8
137410: PPUSH
137411: CALL_OW 266
137415: PUSH
137416: LD_INT 0
137418: PUSH
137419: LD_INT 1
137421: PUSH
137422: EMPTY
137423: LIST
137424: LIST
137425: IN
137426: IFFALSE 137464
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
137428: LD_VAR 0 4
137432: PUSH
137433: LD_VAR 0 7
137437: ARRAY
137438: PPUSH
137439: LD_VAR 0 14
137443: PUSH
137444: LD_VAR 0 8
137448: ARRAY
137449: PPUSH
137450: CALL_OW 115
// attacking := true ;
137454: LD_ADDR_VAR 0 29
137458: PUSH
137459: LD_INT 1
137461: ST_TO_ADDR
// break ;
137462: GO 137466
// end ;
137464: GO 137403
137466: POP
137467: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
137468: LD_VAR 0 4
137472: PUSH
137473: LD_VAR 0 7
137477: ARRAY
137478: PPUSH
137479: CALL_OW 302
137483: PUSH
137484: LD_VAR 0 29
137488: NOT
137489: AND
137490: IFFALSE 137812
// begin if GetTag ( group [ i ] ) = 71 then
137492: LD_VAR 0 4
137496: PUSH
137497: LD_VAR 0 7
137501: ARRAY
137502: PPUSH
137503: CALL_OW 110
137507: PUSH
137508: LD_INT 71
137510: EQUAL
137511: IFFALSE 137552
// begin if HasTask ( group [ i ] ) then
137513: LD_VAR 0 4
137517: PUSH
137518: LD_VAR 0 7
137522: ARRAY
137523: PPUSH
137524: CALL_OW 314
137528: IFFALSE 137534
// continue else
137530: GO 133691
137532: GO 137552
// SetTag ( group [ i ] , 0 ) ;
137534: LD_VAR 0 4
137538: PUSH
137539: LD_VAR 0 7
137543: ARRAY
137544: PPUSH
137545: LD_INT 0
137547: PPUSH
137548: CALL_OW 109
// end ; k := 8 ;
137552: LD_ADDR_VAR 0 9
137556: PUSH
137557: LD_INT 8
137559: ST_TO_ADDR
// x := 0 ;
137560: LD_ADDR_VAR 0 10
137564: PUSH
137565: LD_INT 0
137567: ST_TO_ADDR
// if tmp < k then
137568: LD_VAR 0 14
137572: PUSH
137573: LD_VAR 0 9
137577: LESS
137578: IFFALSE 137590
// k := tmp ;
137580: LD_ADDR_VAR 0 9
137584: PUSH
137585: LD_VAR 0 14
137589: ST_TO_ADDR
// for j = 1 to k do
137590: LD_ADDR_VAR 0 8
137594: PUSH
137595: DOUBLE
137596: LD_INT 1
137598: DEC
137599: ST_TO_ADDR
137600: LD_VAR 0 9
137604: PUSH
137605: FOR_TO
137606: IFFALSE 137704
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
137608: LD_VAR 0 14
137612: PUSH
137613: LD_VAR 0 8
137617: ARRAY
137618: PPUSH
137619: CALL_OW 247
137623: PUSH
137624: LD_INT 1
137626: EQUAL
137627: PUSH
137628: LD_VAR 0 14
137632: PUSH
137633: LD_VAR 0 8
137637: ARRAY
137638: PPUSH
137639: CALL_OW 256
137643: PUSH
137644: LD_INT 250
137646: LESS
137647: PUSH
137648: LD_VAR 0 20
137652: AND
137653: PUSH
137654: LD_VAR 0 20
137658: NOT
137659: PUSH
137660: LD_VAR 0 14
137664: PUSH
137665: LD_VAR 0 8
137669: ARRAY
137670: PPUSH
137671: CALL_OW 256
137675: PUSH
137676: LD_INT 250
137678: GREATEREQUAL
137679: AND
137680: OR
137681: AND
137682: IFFALSE 137702
// begin x := tmp [ j ] ;
137684: LD_ADDR_VAR 0 10
137688: PUSH
137689: LD_VAR 0 14
137693: PUSH
137694: LD_VAR 0 8
137698: ARRAY
137699: ST_TO_ADDR
// break ;
137700: GO 137704
// end ;
137702: GO 137605
137704: POP
137705: POP
// if x then
137706: LD_VAR 0 10
137710: IFFALSE 137734
// ComAttackUnit ( group [ i ] , x ) else
137712: LD_VAR 0 4
137716: PUSH
137717: LD_VAR 0 7
137721: ARRAY
137722: PPUSH
137723: LD_VAR 0 10
137727: PPUSH
137728: CALL_OW 115
137732: GO 137758
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
137734: LD_VAR 0 4
137738: PUSH
137739: LD_VAR 0 7
137743: ARRAY
137744: PPUSH
137745: LD_VAR 0 14
137749: PUSH
137750: LD_INT 1
137752: ARRAY
137753: PPUSH
137754: CALL_OW 115
// if not HasTask ( group [ i ] ) then
137758: LD_VAR 0 4
137762: PUSH
137763: LD_VAR 0 7
137767: ARRAY
137768: PPUSH
137769: CALL_OW 314
137773: NOT
137774: IFFALSE 137812
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
137776: LD_VAR 0 4
137780: PUSH
137781: LD_VAR 0 7
137785: ARRAY
137786: PPUSH
137787: LD_VAR 0 14
137791: PPUSH
137792: LD_VAR 0 4
137796: PUSH
137797: LD_VAR 0 7
137801: ARRAY
137802: PPUSH
137803: CALL_OW 74
137807: PPUSH
137808: CALL_OW 115
// end ; end ; end ;
137812: GO 133691
137814: POP
137815: POP
// wait ( 0 0$2 ) ;
137816: LD_INT 70
137818: PPUSH
137819: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
137823: LD_VAR 0 4
137827: NOT
137828: PUSH
137829: LD_VAR 0 4
137833: PUSH
137834: EMPTY
137835: EQUAL
137836: OR
137837: PUSH
137838: LD_INT 81
137840: PUSH
137841: LD_VAR 0 35
137845: PUSH
137846: EMPTY
137847: LIST
137848: LIST
137849: PPUSH
137850: CALL_OW 69
137854: NOT
137855: OR
137856: IFFALSE 133676
// end ;
137858: LD_VAR 0 2
137862: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
137863: LD_INT 0
137865: PPUSH
137866: PPUSH
137867: PPUSH
137868: PPUSH
137869: PPUSH
137870: PPUSH
// if not base or not mc_bases [ base ] or not solds then
137871: LD_VAR 0 1
137875: NOT
137876: PUSH
137877: LD_EXP 102
137881: PUSH
137882: LD_VAR 0 1
137886: ARRAY
137887: NOT
137888: OR
137889: PUSH
137890: LD_VAR 0 2
137894: NOT
137895: OR
137896: IFFALSE 137900
// exit ;
137898: GO 138454
// side := mc_sides [ base ] ;
137900: LD_ADDR_VAR 0 6
137904: PUSH
137905: LD_EXP 128
137909: PUSH
137910: LD_VAR 0 1
137914: ARRAY
137915: ST_TO_ADDR
// if not side then
137916: LD_VAR 0 6
137920: NOT
137921: IFFALSE 137925
// exit ;
137923: GO 138454
// for i in solds do
137925: LD_ADDR_VAR 0 7
137929: PUSH
137930: LD_VAR 0 2
137934: PUSH
137935: FOR_IN
137936: IFFALSE 137997
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
137938: LD_VAR 0 7
137942: PPUSH
137943: CALL_OW 310
137947: PPUSH
137948: CALL_OW 266
137952: PUSH
137953: LD_INT 32
137955: PUSH
137956: LD_INT 31
137958: PUSH
137959: EMPTY
137960: LIST
137961: LIST
137962: IN
137963: IFFALSE 137983
// solds := solds diff i else
137965: LD_ADDR_VAR 0 2
137969: PUSH
137970: LD_VAR 0 2
137974: PUSH
137975: LD_VAR 0 7
137979: DIFF
137980: ST_TO_ADDR
137981: GO 137995
// SetTag ( i , 18 ) ;
137983: LD_VAR 0 7
137987: PPUSH
137988: LD_INT 18
137990: PPUSH
137991: CALL_OW 109
137995: GO 137935
137997: POP
137998: POP
// if not solds then
137999: LD_VAR 0 2
138003: NOT
138004: IFFALSE 138008
// exit ;
138006: GO 138454
// repeat wait ( 0 0$2 ) ;
138008: LD_INT 70
138010: PPUSH
138011: CALL_OW 67
// enemy := mc_scan [ base ] ;
138015: LD_ADDR_VAR 0 4
138019: PUSH
138020: LD_EXP 125
138024: PUSH
138025: LD_VAR 0 1
138029: ARRAY
138030: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
138031: LD_EXP 102
138035: PUSH
138036: LD_VAR 0 1
138040: ARRAY
138041: NOT
138042: PUSH
138043: LD_EXP 102
138047: PUSH
138048: LD_VAR 0 1
138052: ARRAY
138053: PUSH
138054: EMPTY
138055: EQUAL
138056: OR
138057: IFFALSE 138094
// begin for i in solds do
138059: LD_ADDR_VAR 0 7
138063: PUSH
138064: LD_VAR 0 2
138068: PUSH
138069: FOR_IN
138070: IFFALSE 138083
// ComStop ( i ) ;
138072: LD_VAR 0 7
138076: PPUSH
138077: CALL_OW 141
138081: GO 138069
138083: POP
138084: POP
// solds := [ ] ;
138085: LD_ADDR_VAR 0 2
138089: PUSH
138090: EMPTY
138091: ST_TO_ADDR
// exit ;
138092: GO 138454
// end ; for i in solds do
138094: LD_ADDR_VAR 0 7
138098: PUSH
138099: LD_VAR 0 2
138103: PUSH
138104: FOR_IN
138105: IFFALSE 138426
// begin if IsInUnit ( i ) then
138107: LD_VAR 0 7
138111: PPUSH
138112: CALL_OW 310
138116: IFFALSE 138127
// ComExitBuilding ( i ) ;
138118: LD_VAR 0 7
138122: PPUSH
138123: CALL_OW 122
// if GetLives ( i ) > 500 then
138127: LD_VAR 0 7
138131: PPUSH
138132: CALL_OW 256
138136: PUSH
138137: LD_INT 500
138139: GREATER
138140: IFFALSE 138193
// begin e := NearestUnitToUnit ( enemy , i ) ;
138142: LD_ADDR_VAR 0 5
138146: PUSH
138147: LD_VAR 0 4
138151: PPUSH
138152: LD_VAR 0 7
138156: PPUSH
138157: CALL_OW 74
138161: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
138162: LD_VAR 0 7
138166: PPUSH
138167: LD_VAR 0 5
138171: PPUSH
138172: CALL_OW 250
138176: PPUSH
138177: LD_VAR 0 5
138181: PPUSH
138182: CALL_OW 251
138186: PPUSH
138187: CALL_OW 114
// end else
138191: GO 138424
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
138193: LD_VAR 0 7
138197: PPUSH
138198: LD_EXP 102
138202: PUSH
138203: LD_VAR 0 1
138207: ARRAY
138208: PPUSH
138209: LD_INT 2
138211: PUSH
138212: LD_INT 30
138214: PUSH
138215: LD_INT 0
138217: PUSH
138218: EMPTY
138219: LIST
138220: LIST
138221: PUSH
138222: LD_INT 30
138224: PUSH
138225: LD_INT 1
138227: PUSH
138228: EMPTY
138229: LIST
138230: LIST
138231: PUSH
138232: LD_INT 30
138234: PUSH
138235: LD_INT 6
138237: PUSH
138238: EMPTY
138239: LIST
138240: LIST
138241: PUSH
138242: EMPTY
138243: LIST
138244: LIST
138245: LIST
138246: LIST
138247: PPUSH
138248: CALL_OW 72
138252: PPUSH
138253: LD_VAR 0 7
138257: PPUSH
138258: CALL_OW 74
138262: PPUSH
138263: CALL_OW 296
138267: PUSH
138268: LD_INT 10
138270: GREATER
138271: IFFALSE 138424
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
138273: LD_ADDR_VAR 0 8
138277: PUSH
138278: LD_EXP 102
138282: PUSH
138283: LD_VAR 0 1
138287: ARRAY
138288: PPUSH
138289: LD_INT 2
138291: PUSH
138292: LD_INT 30
138294: PUSH
138295: LD_INT 0
138297: PUSH
138298: EMPTY
138299: LIST
138300: LIST
138301: PUSH
138302: LD_INT 30
138304: PUSH
138305: LD_INT 1
138307: PUSH
138308: EMPTY
138309: LIST
138310: LIST
138311: PUSH
138312: LD_INT 30
138314: PUSH
138315: LD_INT 6
138317: PUSH
138318: EMPTY
138319: LIST
138320: LIST
138321: PUSH
138322: EMPTY
138323: LIST
138324: LIST
138325: LIST
138326: LIST
138327: PPUSH
138328: CALL_OW 72
138332: PPUSH
138333: LD_VAR 0 7
138337: PPUSH
138338: CALL_OW 74
138342: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
138343: LD_VAR 0 7
138347: PPUSH
138348: LD_VAR 0 8
138352: PPUSH
138353: CALL_OW 250
138357: PPUSH
138358: LD_INT 3
138360: PPUSH
138361: LD_INT 5
138363: PPUSH
138364: CALL_OW 272
138368: PPUSH
138369: LD_VAR 0 8
138373: PPUSH
138374: CALL_OW 251
138378: PPUSH
138379: LD_INT 3
138381: PPUSH
138382: LD_INT 5
138384: PPUSH
138385: CALL_OW 273
138389: PPUSH
138390: CALL_OW 111
// SetTag ( i , 0 ) ;
138394: LD_VAR 0 7
138398: PPUSH
138399: LD_INT 0
138401: PPUSH
138402: CALL_OW 109
// solds := solds diff i ;
138406: LD_ADDR_VAR 0 2
138410: PUSH
138411: LD_VAR 0 2
138415: PUSH
138416: LD_VAR 0 7
138420: DIFF
138421: ST_TO_ADDR
// continue ;
138422: GO 138104
// end ; end ;
138424: GO 138104
138426: POP
138427: POP
// until not solds or not enemy ;
138428: LD_VAR 0 2
138432: NOT
138433: PUSH
138434: LD_VAR 0 4
138438: NOT
138439: OR
138440: IFFALSE 138008
// MC_Reset ( base , 18 ) ;
138442: LD_VAR 0 1
138446: PPUSH
138447: LD_INT 18
138449: PPUSH
138450: CALL 43131 0 2
// end ;
138454: LD_VAR 0 3
138458: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
138459: LD_INT 0
138461: PPUSH
138462: PPUSH
138463: PPUSH
138464: PPUSH
138465: PPUSH
138466: PPUSH
138467: PPUSH
138468: PPUSH
138469: PPUSH
138470: PPUSH
138471: PPUSH
138472: PPUSH
138473: PPUSH
138474: PPUSH
138475: PPUSH
138476: PPUSH
138477: PPUSH
138478: PPUSH
138479: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
138480: LD_ADDR_VAR 0 12
138484: PUSH
138485: LD_EXP 102
138489: PUSH
138490: LD_VAR 0 1
138494: ARRAY
138495: PPUSH
138496: LD_INT 25
138498: PUSH
138499: LD_INT 3
138501: PUSH
138502: EMPTY
138503: LIST
138504: LIST
138505: PPUSH
138506: CALL_OW 72
138510: ST_TO_ADDR
// if mc_remote_driver [ base ] then
138511: LD_EXP 142
138515: PUSH
138516: LD_VAR 0 1
138520: ARRAY
138521: IFFALSE 138545
// mechs := mechs diff mc_remote_driver [ base ] ;
138523: LD_ADDR_VAR 0 12
138527: PUSH
138528: LD_VAR 0 12
138532: PUSH
138533: LD_EXP 142
138537: PUSH
138538: LD_VAR 0 1
138542: ARRAY
138543: DIFF
138544: ST_TO_ADDR
// for i in mechs do
138545: LD_ADDR_VAR 0 4
138549: PUSH
138550: LD_VAR 0 12
138554: PUSH
138555: FOR_IN
138556: IFFALSE 138591
// if GetTag ( i ) > 0 then
138558: LD_VAR 0 4
138562: PPUSH
138563: CALL_OW 110
138567: PUSH
138568: LD_INT 0
138570: GREATER
138571: IFFALSE 138589
// mechs := mechs diff i ;
138573: LD_ADDR_VAR 0 12
138577: PUSH
138578: LD_VAR 0 12
138582: PUSH
138583: LD_VAR 0 4
138587: DIFF
138588: ST_TO_ADDR
138589: GO 138555
138591: POP
138592: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
138593: LD_ADDR_VAR 0 8
138597: PUSH
138598: LD_EXP 102
138602: PUSH
138603: LD_VAR 0 1
138607: ARRAY
138608: PPUSH
138609: LD_INT 2
138611: PUSH
138612: LD_INT 25
138614: PUSH
138615: LD_INT 1
138617: PUSH
138618: EMPTY
138619: LIST
138620: LIST
138621: PUSH
138622: LD_INT 25
138624: PUSH
138625: LD_INT 5
138627: PUSH
138628: EMPTY
138629: LIST
138630: LIST
138631: PUSH
138632: LD_INT 25
138634: PUSH
138635: LD_INT 8
138637: PUSH
138638: EMPTY
138639: LIST
138640: LIST
138641: PUSH
138642: LD_INT 25
138644: PUSH
138645: LD_INT 9
138647: PUSH
138648: EMPTY
138649: LIST
138650: LIST
138651: PUSH
138652: EMPTY
138653: LIST
138654: LIST
138655: LIST
138656: LIST
138657: LIST
138658: PPUSH
138659: CALL_OW 72
138663: ST_TO_ADDR
// if not defenders and not solds then
138664: LD_VAR 0 2
138668: NOT
138669: PUSH
138670: LD_VAR 0 8
138674: NOT
138675: AND
138676: IFFALSE 138680
// exit ;
138678: GO 140450
// depot_under_attack := false ;
138680: LD_ADDR_VAR 0 16
138684: PUSH
138685: LD_INT 0
138687: ST_TO_ADDR
// sold_defenders := [ ] ;
138688: LD_ADDR_VAR 0 17
138692: PUSH
138693: EMPTY
138694: ST_TO_ADDR
// if mechs then
138695: LD_VAR 0 12
138699: IFFALSE 138852
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
138701: LD_ADDR_VAR 0 4
138705: PUSH
138706: LD_VAR 0 2
138710: PPUSH
138711: LD_INT 21
138713: PUSH
138714: LD_INT 2
138716: PUSH
138717: EMPTY
138718: LIST
138719: LIST
138720: PPUSH
138721: CALL_OW 72
138725: PUSH
138726: FOR_IN
138727: IFFALSE 138850
// begin if GetTag ( i ) <> 20 then
138729: LD_VAR 0 4
138733: PPUSH
138734: CALL_OW 110
138738: PUSH
138739: LD_INT 20
138741: NONEQUAL
138742: IFFALSE 138756
// SetTag ( i , 20 ) ;
138744: LD_VAR 0 4
138748: PPUSH
138749: LD_INT 20
138751: PPUSH
138752: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
138756: LD_VAR 0 4
138760: PPUSH
138761: CALL_OW 263
138765: PUSH
138766: LD_INT 1
138768: EQUAL
138769: PUSH
138770: LD_VAR 0 4
138774: PPUSH
138775: CALL_OW 311
138779: NOT
138780: AND
138781: IFFALSE 138848
// begin un := mechs [ 1 ] ;
138783: LD_ADDR_VAR 0 10
138787: PUSH
138788: LD_VAR 0 12
138792: PUSH
138793: LD_INT 1
138795: ARRAY
138796: ST_TO_ADDR
// ComExit ( un ) ;
138797: LD_VAR 0 10
138801: PPUSH
138802: CALL 107759 0 1
// AddComEnterUnit ( un , i ) ;
138806: LD_VAR 0 10
138810: PPUSH
138811: LD_VAR 0 4
138815: PPUSH
138816: CALL_OW 180
// SetTag ( un , 19 ) ;
138820: LD_VAR 0 10
138824: PPUSH
138825: LD_INT 19
138827: PPUSH
138828: CALL_OW 109
// mechs := mechs diff un ;
138832: LD_ADDR_VAR 0 12
138836: PUSH
138837: LD_VAR 0 12
138841: PUSH
138842: LD_VAR 0 10
138846: DIFF
138847: ST_TO_ADDR
// end ; end ;
138848: GO 138726
138850: POP
138851: POP
// if solds then
138852: LD_VAR 0 8
138856: IFFALSE 138915
// for i in solds do
138858: LD_ADDR_VAR 0 4
138862: PUSH
138863: LD_VAR 0 8
138867: PUSH
138868: FOR_IN
138869: IFFALSE 138913
// if not GetTag ( i ) then
138871: LD_VAR 0 4
138875: PPUSH
138876: CALL_OW 110
138880: NOT
138881: IFFALSE 138911
// begin defenders := defenders union i ;
138883: LD_ADDR_VAR 0 2
138887: PUSH
138888: LD_VAR 0 2
138892: PUSH
138893: LD_VAR 0 4
138897: UNION
138898: ST_TO_ADDR
// SetTag ( i , 18 ) ;
138899: LD_VAR 0 4
138903: PPUSH
138904: LD_INT 18
138906: PPUSH
138907: CALL_OW 109
// end ;
138911: GO 138868
138913: POP
138914: POP
// repeat wait ( 0 0$2 ) ;
138915: LD_INT 70
138917: PPUSH
138918: CALL_OW 67
// enemy := mc_scan [ base ] ;
138922: LD_ADDR_VAR 0 21
138926: PUSH
138927: LD_EXP 125
138931: PUSH
138932: LD_VAR 0 1
138936: ARRAY
138937: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
138938: LD_EXP 102
138942: PUSH
138943: LD_VAR 0 1
138947: ARRAY
138948: NOT
138949: PUSH
138950: LD_EXP 102
138954: PUSH
138955: LD_VAR 0 1
138959: ARRAY
138960: PUSH
138961: EMPTY
138962: EQUAL
138963: OR
138964: IFFALSE 139001
// begin for i in defenders do
138966: LD_ADDR_VAR 0 4
138970: PUSH
138971: LD_VAR 0 2
138975: PUSH
138976: FOR_IN
138977: IFFALSE 138990
// ComStop ( i ) ;
138979: LD_VAR 0 4
138983: PPUSH
138984: CALL_OW 141
138988: GO 138976
138990: POP
138991: POP
// defenders := [ ] ;
138992: LD_ADDR_VAR 0 2
138996: PUSH
138997: EMPTY
138998: ST_TO_ADDR
// exit ;
138999: GO 140450
// end ; for i in defenders do
139001: LD_ADDR_VAR 0 4
139005: PUSH
139006: LD_VAR 0 2
139010: PUSH
139011: FOR_IN
139012: IFFALSE 139910
// begin e := NearestUnitToUnit ( enemy , i ) ;
139014: LD_ADDR_VAR 0 13
139018: PUSH
139019: LD_VAR 0 21
139023: PPUSH
139024: LD_VAR 0 4
139028: PPUSH
139029: CALL_OW 74
139033: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
139034: LD_ADDR_VAR 0 7
139038: PUSH
139039: LD_EXP 102
139043: PUSH
139044: LD_VAR 0 1
139048: ARRAY
139049: PPUSH
139050: LD_INT 2
139052: PUSH
139053: LD_INT 30
139055: PUSH
139056: LD_INT 0
139058: PUSH
139059: EMPTY
139060: LIST
139061: LIST
139062: PUSH
139063: LD_INT 30
139065: PUSH
139066: LD_INT 1
139068: PUSH
139069: EMPTY
139070: LIST
139071: LIST
139072: PUSH
139073: EMPTY
139074: LIST
139075: LIST
139076: LIST
139077: PPUSH
139078: CALL_OW 72
139082: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
139083: LD_ADDR_VAR 0 16
139087: PUSH
139088: LD_VAR 0 7
139092: NOT
139093: PUSH
139094: LD_VAR 0 7
139098: PPUSH
139099: LD_INT 3
139101: PUSH
139102: LD_INT 24
139104: PUSH
139105: LD_INT 600
139107: PUSH
139108: EMPTY
139109: LIST
139110: LIST
139111: PUSH
139112: EMPTY
139113: LIST
139114: LIST
139115: PPUSH
139116: CALL_OW 72
139120: OR
139121: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
139122: LD_VAR 0 4
139126: PPUSH
139127: CALL_OW 247
139131: PUSH
139132: LD_INT 2
139134: DOUBLE
139135: EQUAL
139136: IFTRUE 139140
139138: GO 139536
139140: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
139141: LD_VAR 0 4
139145: PPUSH
139146: CALL_OW 256
139150: PUSH
139151: LD_INT 1000
139153: EQUAL
139154: PUSH
139155: LD_VAR 0 4
139159: PPUSH
139160: LD_VAR 0 13
139164: PPUSH
139165: CALL_OW 296
139169: PUSH
139170: LD_INT 40
139172: LESS
139173: PUSH
139174: LD_VAR 0 13
139178: PPUSH
139179: LD_EXP 127
139183: PUSH
139184: LD_VAR 0 1
139188: ARRAY
139189: PPUSH
139190: CALL_OW 308
139194: OR
139195: AND
139196: IFFALSE 139318
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
139198: LD_VAR 0 4
139202: PPUSH
139203: CALL_OW 262
139207: PUSH
139208: LD_INT 1
139210: EQUAL
139211: PUSH
139212: LD_VAR 0 4
139216: PPUSH
139217: CALL_OW 261
139221: PUSH
139222: LD_INT 30
139224: LESS
139225: AND
139226: PUSH
139227: LD_VAR 0 7
139231: AND
139232: IFFALSE 139302
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
139234: LD_VAR 0 4
139238: PPUSH
139239: LD_VAR 0 7
139243: PPUSH
139244: LD_VAR 0 4
139248: PPUSH
139249: CALL_OW 74
139253: PPUSH
139254: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
139258: LD_VAR 0 4
139262: PPUSH
139263: LD_VAR 0 7
139267: PPUSH
139268: LD_VAR 0 4
139272: PPUSH
139273: CALL_OW 74
139277: PPUSH
139278: CALL_OW 296
139282: PUSH
139283: LD_INT 6
139285: LESS
139286: IFFALSE 139300
// SetFuel ( i , 100 ) ;
139288: LD_VAR 0 4
139292: PPUSH
139293: LD_INT 100
139295: PPUSH
139296: CALL_OW 240
// end else
139300: GO 139316
// ComAttackUnit ( i , e ) ;
139302: LD_VAR 0 4
139306: PPUSH
139307: LD_VAR 0 13
139311: PPUSH
139312: CALL_OW 115
// end else
139316: GO 139419
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
139318: LD_VAR 0 13
139322: PPUSH
139323: LD_EXP 127
139327: PUSH
139328: LD_VAR 0 1
139332: ARRAY
139333: PPUSH
139334: CALL_OW 308
139338: NOT
139339: PUSH
139340: LD_VAR 0 4
139344: PPUSH
139345: LD_VAR 0 13
139349: PPUSH
139350: CALL_OW 296
139354: PUSH
139355: LD_INT 40
139357: GREATEREQUAL
139358: AND
139359: PUSH
139360: LD_VAR 0 4
139364: PPUSH
139365: CALL_OW 256
139369: PUSH
139370: LD_INT 650
139372: LESSEQUAL
139373: OR
139374: PUSH
139375: LD_VAR 0 4
139379: PPUSH
139380: LD_EXP 126
139384: PUSH
139385: LD_VAR 0 1
139389: ARRAY
139390: PPUSH
139391: CALL_OW 308
139395: NOT
139396: AND
139397: IFFALSE 139419
// ComMoveToArea ( i , mc_parking [ base ] ) ;
139399: LD_VAR 0 4
139403: PPUSH
139404: LD_EXP 126
139408: PUSH
139409: LD_VAR 0 1
139413: ARRAY
139414: PPUSH
139415: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
139419: LD_VAR 0 4
139423: PPUSH
139424: CALL_OW 256
139428: PUSH
139429: LD_INT 1000
139431: LESS
139432: PUSH
139433: LD_VAR 0 4
139437: PPUSH
139438: CALL_OW 263
139442: PUSH
139443: LD_INT 1
139445: EQUAL
139446: AND
139447: PUSH
139448: LD_VAR 0 4
139452: PPUSH
139453: CALL_OW 311
139457: AND
139458: PUSH
139459: LD_VAR 0 4
139463: PPUSH
139464: LD_EXP 126
139468: PUSH
139469: LD_VAR 0 1
139473: ARRAY
139474: PPUSH
139475: CALL_OW 308
139479: AND
139480: IFFALSE 139534
// begin mech := IsDrivenBy ( i ) ;
139482: LD_ADDR_VAR 0 9
139486: PUSH
139487: LD_VAR 0 4
139491: PPUSH
139492: CALL_OW 311
139496: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
139497: LD_VAR 0 9
139501: PPUSH
139502: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
139506: LD_VAR 0 9
139510: PPUSH
139511: LD_VAR 0 4
139515: PPUSH
139516: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
139520: LD_VAR 0 9
139524: PPUSH
139525: LD_VAR 0 4
139529: PPUSH
139530: CALL_OW 180
// end ; end ; unit_human :
139534: GO 139881
139536: LD_INT 1
139538: DOUBLE
139539: EQUAL
139540: IFTRUE 139544
139542: GO 139880
139544: POP
// begin b := IsInUnit ( i ) ;
139545: LD_ADDR_VAR 0 18
139549: PUSH
139550: LD_VAR 0 4
139554: PPUSH
139555: CALL_OW 310
139559: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
139560: LD_ADDR_VAR 0 19
139564: PUSH
139565: LD_VAR 0 18
139569: NOT
139570: PUSH
139571: LD_VAR 0 18
139575: PPUSH
139576: CALL_OW 266
139580: PUSH
139581: LD_INT 32
139583: PUSH
139584: LD_INT 31
139586: PUSH
139587: EMPTY
139588: LIST
139589: LIST
139590: IN
139591: OR
139592: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
139593: LD_VAR 0 18
139597: PPUSH
139598: CALL_OW 266
139602: PUSH
139603: LD_INT 5
139605: EQUAL
139606: PUSH
139607: LD_VAR 0 4
139611: PPUSH
139612: CALL_OW 257
139616: PUSH
139617: LD_INT 1
139619: PUSH
139620: LD_INT 2
139622: PUSH
139623: LD_INT 3
139625: PUSH
139626: LD_INT 4
139628: PUSH
139629: EMPTY
139630: LIST
139631: LIST
139632: LIST
139633: LIST
139634: IN
139635: AND
139636: IFFALSE 139673
// begin class := AllowSpecClass ( i ) ;
139638: LD_ADDR_VAR 0 20
139642: PUSH
139643: LD_VAR 0 4
139647: PPUSH
139648: CALL 71456 0 1
139652: ST_TO_ADDR
// if class then
139653: LD_VAR 0 20
139657: IFFALSE 139673
// ComChangeProfession ( i , class ) ;
139659: LD_VAR 0 4
139663: PPUSH
139664: LD_VAR 0 20
139668: PPUSH
139669: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
139673: LD_VAR 0 16
139677: PUSH
139678: LD_VAR 0 2
139682: PPUSH
139683: LD_INT 21
139685: PUSH
139686: LD_INT 2
139688: PUSH
139689: EMPTY
139690: LIST
139691: LIST
139692: PPUSH
139693: CALL_OW 72
139697: PUSH
139698: LD_INT 1
139700: LESSEQUAL
139701: OR
139702: PUSH
139703: LD_VAR 0 19
139707: AND
139708: PUSH
139709: LD_VAR 0 4
139713: PUSH
139714: LD_VAR 0 17
139718: IN
139719: NOT
139720: AND
139721: IFFALSE 139814
// begin if b then
139723: LD_VAR 0 18
139727: IFFALSE 139776
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
139729: LD_VAR 0 18
139733: PPUSH
139734: LD_VAR 0 21
139738: PPUSH
139739: LD_VAR 0 18
139743: PPUSH
139744: CALL_OW 74
139748: PPUSH
139749: CALL_OW 296
139753: PUSH
139754: LD_INT 10
139756: LESS
139757: PUSH
139758: LD_VAR 0 18
139762: PPUSH
139763: CALL_OW 461
139767: PUSH
139768: LD_INT 7
139770: NONEQUAL
139771: AND
139772: IFFALSE 139776
// continue ;
139774: GO 139011
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
139776: LD_ADDR_VAR 0 17
139780: PUSH
139781: LD_VAR 0 17
139785: PPUSH
139786: LD_VAR 0 17
139790: PUSH
139791: LD_INT 1
139793: PLUS
139794: PPUSH
139795: LD_VAR 0 4
139799: PPUSH
139800: CALL_OW 1
139804: ST_TO_ADDR
// ComExitBuilding ( i ) ;
139805: LD_VAR 0 4
139809: PPUSH
139810: CALL_OW 122
// end ; if sold_defenders then
139814: LD_VAR 0 17
139818: IFFALSE 139878
// if i in sold_defenders then
139820: LD_VAR 0 4
139824: PUSH
139825: LD_VAR 0 17
139829: IN
139830: IFFALSE 139878
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
139832: LD_VAR 0 4
139836: PPUSH
139837: CALL_OW 314
139841: NOT
139842: PUSH
139843: LD_VAR 0 4
139847: PPUSH
139848: LD_VAR 0 13
139852: PPUSH
139853: CALL_OW 296
139857: PUSH
139858: LD_INT 30
139860: LESS
139861: AND
139862: IFFALSE 139878
// ComAttackUnit ( i , e ) ;
139864: LD_VAR 0 4
139868: PPUSH
139869: LD_VAR 0 13
139873: PPUSH
139874: CALL_OW 115
// end ; end ; end ;
139878: GO 139881
139880: POP
// if IsDead ( i ) then
139881: LD_VAR 0 4
139885: PPUSH
139886: CALL_OW 301
139890: IFFALSE 139908
// defenders := defenders diff i ;
139892: LD_ADDR_VAR 0 2
139896: PUSH
139897: LD_VAR 0 2
139901: PUSH
139902: LD_VAR 0 4
139906: DIFF
139907: ST_TO_ADDR
// end ;
139908: GO 139011
139910: POP
139911: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
139912: LD_VAR 0 21
139916: NOT
139917: PUSH
139918: LD_VAR 0 2
139922: NOT
139923: OR
139924: PUSH
139925: LD_EXP 102
139929: PUSH
139930: LD_VAR 0 1
139934: ARRAY
139935: NOT
139936: OR
139937: IFFALSE 138915
// MC_Reset ( base , 18 ) ;
139939: LD_VAR 0 1
139943: PPUSH
139944: LD_INT 18
139946: PPUSH
139947: CALL 43131 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
139951: LD_ADDR_VAR 0 2
139955: PUSH
139956: LD_VAR 0 2
139960: PUSH
139961: LD_VAR 0 2
139965: PPUSH
139966: LD_INT 2
139968: PUSH
139969: LD_INT 25
139971: PUSH
139972: LD_INT 1
139974: PUSH
139975: EMPTY
139976: LIST
139977: LIST
139978: PUSH
139979: LD_INT 25
139981: PUSH
139982: LD_INT 5
139984: PUSH
139985: EMPTY
139986: LIST
139987: LIST
139988: PUSH
139989: LD_INT 25
139991: PUSH
139992: LD_INT 8
139994: PUSH
139995: EMPTY
139996: LIST
139997: LIST
139998: PUSH
139999: LD_INT 25
140001: PUSH
140002: LD_INT 9
140004: PUSH
140005: EMPTY
140006: LIST
140007: LIST
140008: PUSH
140009: EMPTY
140010: LIST
140011: LIST
140012: LIST
140013: LIST
140014: LIST
140015: PPUSH
140016: CALL_OW 72
140020: DIFF
140021: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
140022: LD_VAR 0 21
140026: NOT
140027: PUSH
140028: LD_VAR 0 2
140032: PPUSH
140033: LD_INT 21
140035: PUSH
140036: LD_INT 2
140038: PUSH
140039: EMPTY
140040: LIST
140041: LIST
140042: PPUSH
140043: CALL_OW 72
140047: AND
140048: IFFALSE 140386
// begin tmp := FilterByTag ( defenders , 19 ) ;
140050: LD_ADDR_VAR 0 11
140054: PUSH
140055: LD_VAR 0 2
140059: PPUSH
140060: LD_INT 19
140062: PPUSH
140063: CALL 104930 0 2
140067: ST_TO_ADDR
// if tmp then
140068: LD_VAR 0 11
140072: IFFALSE 140142
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
140074: LD_ADDR_VAR 0 11
140078: PUSH
140079: LD_VAR 0 11
140083: PPUSH
140084: LD_INT 25
140086: PUSH
140087: LD_INT 3
140089: PUSH
140090: EMPTY
140091: LIST
140092: LIST
140093: PPUSH
140094: CALL_OW 72
140098: ST_TO_ADDR
// if tmp then
140099: LD_VAR 0 11
140103: IFFALSE 140142
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
140105: LD_ADDR_EXP 114
140109: PUSH
140110: LD_EXP 114
140114: PPUSH
140115: LD_VAR 0 1
140119: PPUSH
140120: LD_EXP 114
140124: PUSH
140125: LD_VAR 0 1
140129: ARRAY
140130: PUSH
140131: LD_VAR 0 11
140135: UNION
140136: PPUSH
140137: CALL_OW 1
140141: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
140142: LD_VAR 0 1
140146: PPUSH
140147: LD_INT 19
140149: PPUSH
140150: CALL 43131 0 2
// repeat wait ( 0 0$1 ) ;
140154: LD_INT 35
140156: PPUSH
140157: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
140161: LD_EXP 102
140165: PUSH
140166: LD_VAR 0 1
140170: ARRAY
140171: NOT
140172: PUSH
140173: LD_EXP 102
140177: PUSH
140178: LD_VAR 0 1
140182: ARRAY
140183: PUSH
140184: EMPTY
140185: EQUAL
140186: OR
140187: IFFALSE 140224
// begin for i in defenders do
140189: LD_ADDR_VAR 0 4
140193: PUSH
140194: LD_VAR 0 2
140198: PUSH
140199: FOR_IN
140200: IFFALSE 140213
// ComStop ( i ) ;
140202: LD_VAR 0 4
140206: PPUSH
140207: CALL_OW 141
140211: GO 140199
140213: POP
140214: POP
// defenders := [ ] ;
140215: LD_ADDR_VAR 0 2
140219: PUSH
140220: EMPTY
140221: ST_TO_ADDR
// exit ;
140222: GO 140450
// end ; for i in defenders do
140224: LD_ADDR_VAR 0 4
140228: PUSH
140229: LD_VAR 0 2
140233: PUSH
140234: FOR_IN
140235: IFFALSE 140324
// begin if not IsInArea ( i , mc_parking [ base ] ) then
140237: LD_VAR 0 4
140241: PPUSH
140242: LD_EXP 126
140246: PUSH
140247: LD_VAR 0 1
140251: ARRAY
140252: PPUSH
140253: CALL_OW 308
140257: NOT
140258: IFFALSE 140282
// ComMoveToArea ( i , mc_parking [ base ] ) else
140260: LD_VAR 0 4
140264: PPUSH
140265: LD_EXP 126
140269: PUSH
140270: LD_VAR 0 1
140274: ARRAY
140275: PPUSH
140276: CALL_OW 113
140280: GO 140322
// if GetControl ( i ) = control_manual then
140282: LD_VAR 0 4
140286: PPUSH
140287: CALL_OW 263
140291: PUSH
140292: LD_INT 1
140294: EQUAL
140295: IFFALSE 140322
// if IsDrivenBy ( i ) then
140297: LD_VAR 0 4
140301: PPUSH
140302: CALL_OW 311
140306: IFFALSE 140322
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
140308: LD_VAR 0 4
140312: PPUSH
140313: CALL_OW 311
140317: PPUSH
140318: CALL_OW 121
// end ;
140322: GO 140234
140324: POP
140325: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
140326: LD_VAR 0 2
140330: PPUSH
140331: LD_INT 95
140333: PUSH
140334: LD_EXP 126
140338: PUSH
140339: LD_VAR 0 1
140343: ARRAY
140344: PUSH
140345: EMPTY
140346: LIST
140347: LIST
140348: PPUSH
140349: CALL_OW 72
140353: PUSH
140354: LD_VAR 0 2
140358: EQUAL
140359: PUSH
140360: LD_EXP 125
140364: PUSH
140365: LD_VAR 0 1
140369: ARRAY
140370: OR
140371: PUSH
140372: LD_EXP 102
140376: PUSH
140377: LD_VAR 0 1
140381: ARRAY
140382: NOT
140383: OR
140384: IFFALSE 140154
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
140386: LD_ADDR_EXP 124
140390: PUSH
140391: LD_EXP 124
140395: PPUSH
140396: LD_VAR 0 1
140400: PPUSH
140401: LD_VAR 0 2
140405: PPUSH
140406: LD_INT 21
140408: PUSH
140409: LD_INT 2
140411: PUSH
140412: EMPTY
140413: LIST
140414: LIST
140415: PPUSH
140416: CALL_OW 72
140420: PPUSH
140421: CALL_OW 1
140425: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
140426: LD_VAR 0 1
140430: PPUSH
140431: LD_INT 19
140433: PPUSH
140434: CALL 43131 0 2
// MC_Reset ( base , 20 ) ;
140438: LD_VAR 0 1
140442: PPUSH
140443: LD_INT 20
140445: PPUSH
140446: CALL 43131 0 2
// end ; end_of_file
140450: LD_VAR 0 3
140454: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
140455: LD_VAR 0 1
140459: PUSH
140460: LD_INT 200
140462: DOUBLE
140463: GREATEREQUAL
140464: IFFALSE 140472
140466: LD_INT 299
140468: DOUBLE
140469: LESSEQUAL
140470: IFTRUE 140474
140472: GO 140506
140474: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
140475: LD_VAR 0 1
140479: PPUSH
140480: LD_VAR 0 2
140484: PPUSH
140485: LD_VAR 0 3
140489: PPUSH
140490: LD_VAR 0 4
140494: PPUSH
140495: LD_VAR 0 5
140499: PPUSH
140500: CALL 128636 0 5
140504: GO 140583
140506: LD_INT 300
140508: DOUBLE
140509: GREATEREQUAL
140510: IFFALSE 140518
140512: LD_INT 399
140514: DOUBLE
140515: LESSEQUAL
140516: IFTRUE 140520
140518: GO 140582
140520: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
140521: LD_VAR 0 1
140525: PPUSH
140526: LD_VAR 0 2
140530: PPUSH
140531: LD_VAR 0 3
140535: PPUSH
140536: LD_VAR 0 4
140540: PPUSH
140541: LD_VAR 0 5
140545: PPUSH
140546: LD_VAR 0 6
140550: PPUSH
140551: LD_VAR 0 7
140555: PPUSH
140556: LD_VAR 0 8
140560: PPUSH
140561: LD_VAR 0 9
140565: PPUSH
140566: LD_VAR 0 10
140570: PPUSH
140571: LD_VAR 0 11
140575: PPUSH
140576: CALL 124961 0 11
140580: GO 140583
140582: POP
// end ;
140583: PPOPN 11
140585: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
140586: LD_VAR 0 1
140590: PPUSH
140591: LD_VAR 0 2
140595: PPUSH
140596: LD_VAR 0 3
140600: PPUSH
140601: LD_VAR 0 4
140605: PPUSH
140606: LD_VAR 0 5
140610: PPUSH
140611: CALL 128372 0 5
// end ; end_of_file
140615: PPOPN 5
140617: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
140618: LD_VAR 0 1
140622: PPUSH
140623: LD_VAR 0 2
140627: PPUSH
140628: LD_VAR 0 3
140632: PPUSH
140633: LD_VAR 0 4
140637: PPUSH
140638: LD_VAR 0 5
140642: PPUSH
140643: LD_VAR 0 6
140647: PPUSH
140648: CALL 112613 0 6
// end ;
140652: PPOPN 6
140654: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
140655: LD_INT 0
140657: PPUSH
// begin if not units then
140658: LD_VAR 0 1
140662: NOT
140663: IFFALSE 140667
// exit ;
140665: GO 140667
// end ;
140667: PPOPN 7
140669: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
140670: CALL 112500 0 0
// end ;
140674: PPOPN 1
140676: END
