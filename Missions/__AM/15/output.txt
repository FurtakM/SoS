// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 39564 0 0
// InitNature ;
  19: CALL 39432 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 12660 0 0
// PrepareRussian ;
  40: CALL 7610 0 0
// PrepareLegion ;
  44: CALL 4678 0 0
// PreparePowell ;
  48: CALL 3212 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 17590 0 0
// MC_Start ( ) ;
  60: CALL 41744 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 126
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 127
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 64540 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 64633 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 63983 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 3
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 3
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 63798 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 64540 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 64633 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 63798 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 63983 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 64413 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 63461 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 64540 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 64633 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 131
 971: PUSH
 972: LD_EXP 131
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 63798 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 64540 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 64633 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 63690 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 64951 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 64122 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 64413 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 64413 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 64745 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 63798 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 64364 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker , Mike , DeltaDoctor ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 70272 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1942
// PrepareVehicle ( [ us_morphling , us_morphling , us_medium_tracked , us_medium_tracked ] [ Difficulty ] , engine_siberite , control_manual , [ us_laser , us_laser , us_double_gun , us_double_gun ] [ Difficulty ] , 100 ) else
1879: LD_INT 5
1881: PUSH
1882: LD_INT 5
1884: PUSH
1885: LD_INT 3
1887: PUSH
1888: LD_INT 3
1890: PUSH
1891: EMPTY
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: PUSH
1897: LD_OWVAR 67
1901: ARRAY
1902: PPUSH
1903: LD_INT 3
1905: PPUSH
1906: LD_INT 1
1908: PPUSH
1909: LD_INT 9
1911: PUSH
1912: LD_INT 9
1914: PUSH
1915: LD_INT 5
1917: PUSH
1918: LD_INT 5
1920: PUSH
1921: EMPTY
1922: LIST
1923: LIST
1924: LIST
1925: LIST
1926: PUSH
1927: LD_OWVAR 67
1931: ARRAY
1932: PPUSH
1933: LD_INT 100
1935: PPUSH
1936: CALL 75133 0 5
1940: GO 2001
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1942: LD_EXP 4
1946: PUSH
1947: LD_INT 1
1949: ARRAY
1950: PUSH
1951: LD_INT 1
1953: ARRAY
1954: PPUSH
1955: LD_EXP 4
1959: PUSH
1960: LD_INT 2
1962: ARRAY
1963: PUSH
1964: LD_INT 1
1966: ARRAY
1967: PPUSH
1968: LD_EXP 4
1972: PUSH
1973: LD_INT 3
1975: ARRAY
1976: PUSH
1977: LD_INT 1
1979: ARRAY
1980: PPUSH
1981: LD_EXP 4
1985: PUSH
1986: LD_INT 4
1988: ARRAY
1989: PUSH
1990: LD_INT 1
1992: ARRAY
1993: PPUSH
1994: LD_INT 30
1996: PPUSH
1997: CALL 75133 0 5
// JMMNewVeh := CreateVehicle ;
2001: LD_ADDR_EXP 59
2005: PUSH
2006: CALL_OW 45
2010: ST_TO_ADDR
// if not JMMNewVeh then
2011: LD_EXP 59
2015: NOT
2016: IFFALSE 2047
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
2018: LD_INT 5
2020: PPUSH
2021: LD_INT 3
2023: PPUSH
2024: LD_INT 1
2026: PPUSH
2027: LD_INT 9
2029: PPUSH
2030: LD_INT 100
2032: PPUSH
2033: CALL 75133 0 5
// JMMNewVeh := CreateVehicle ;
2037: LD_ADDR_EXP 59
2041: PUSH
2042: CALL_OW 45
2046: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2047: LD_EXP 59
2051: PPUSH
2052: LD_INT 4
2054: PPUSH
2055: CALL_OW 233
// SetMark ( JMMNewVeh , - 1 ) ;
2059: LD_EXP 59
2063: PPUSH
2064: LD_INT 1
2066: NEG
2067: PPUSH
2068: CALL_OW 242
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2072: LD_EXP 59
2076: PPUSH
2077: LD_INT 79
2079: PPUSH
2080: LD_INT 91
2082: PPUSH
2083: LD_INT 0
2085: PPUSH
2086: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2090: LD_EXP 40
2094: PPUSH
2095: LD_EXP 59
2099: PPUSH
2100: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2104: LD_EXP 6
2108: PUSH
2109: LD_EXP 2
2113: NOT
2114: AND
2115: IFFALSE 2373
// begin if not JMMGirlVeh then
2117: LD_EXP 5
2121: NOT
2122: IFFALSE 2145
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2124: LD_INT 3
2126: PPUSH
2127: LD_INT 3
2129: PPUSH
2130: LD_INT 1
2132: PPUSH
2133: LD_INT 9
2135: PPUSH
2136: LD_INT 100
2138: PPUSH
2139: CALL 75133 0 5
2143: GO 2204
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2145: LD_EXP 5
2149: PUSH
2150: LD_INT 1
2152: ARRAY
2153: PUSH
2154: LD_INT 1
2156: ARRAY
2157: PPUSH
2158: LD_EXP 5
2162: PUSH
2163: LD_INT 2
2165: ARRAY
2166: PUSH
2167: LD_INT 1
2169: ARRAY
2170: PPUSH
2171: LD_EXP 5
2175: PUSH
2176: LD_INT 3
2178: ARRAY
2179: PUSH
2180: LD_INT 1
2182: ARRAY
2183: PPUSH
2184: LD_EXP 5
2188: PUSH
2189: LD_INT 4
2191: ARRAY
2192: PUSH
2193: LD_INT 1
2195: ARRAY
2196: PPUSH
2197: LD_INT 30
2199: PPUSH
2200: CALL 75133 0 5
// GirlNewVeh := CreateVehicle ;
2204: LD_ADDR_EXP 60
2208: PUSH
2209: CALL_OW 45
2213: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2214: LD_EXP 60
2218: PPUSH
2219: LD_INT 4
2221: PPUSH
2222: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2226: LD_EXP 60
2230: PPUSH
2231: LD_INT 82
2233: PPUSH
2234: LD_INT 96
2236: PPUSH
2237: LD_INT 0
2239: PPUSH
2240: CALL_OW 48
// if JMMGirl = 1 then
2244: LD_EXP 7
2248: PUSH
2249: LD_INT 1
2251: EQUAL
2252: IFFALSE 2287
// begin Joan := PrepareUnit ( Joan , true , 14_ ) ;
2254: LD_ADDR_EXP 41
2258: PUSH
2259: LD_STRING Joan
2261: PPUSH
2262: LD_INT 1
2264: PPUSH
2265: LD_STRING 14_
2267: PPUSH
2268: CALL 70272 0 3
2272: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2273: LD_EXP 41
2277: PPUSH
2278: LD_EXP 60
2282: PPUSH
2283: CALL_OW 52
// end ; if JMMGirl = 2 then
2287: LD_EXP 7
2291: PUSH
2292: LD_INT 2
2294: EQUAL
2295: IFFALSE 2330
// begin Lisa := PrepareUnit ( Lisa , true , 14_ ) ;
2297: LD_ADDR_EXP 43
2301: PUSH
2302: LD_STRING Lisa
2304: PPUSH
2305: LD_INT 1
2307: PPUSH
2308: LD_STRING 14_
2310: PPUSH
2311: CALL 70272 0 3
2315: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2316: LD_EXP 43
2320: PPUSH
2321: LD_EXP 60
2325: PPUSH
2326: CALL_OW 52
// end ; if JMMGirl = 3 then
2330: LD_EXP 7
2334: PUSH
2335: LD_INT 3
2337: EQUAL
2338: IFFALSE 2373
// begin Connie := PrepareUnit ( Connie , true , 14_ ) ;
2340: LD_ADDR_EXP 55
2344: PUSH
2345: LD_STRING Connie
2347: PPUSH
2348: LD_INT 1
2350: PPUSH
2351: LD_STRING 14_
2353: PPUSH
2354: CALL 70272 0 3
2358: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2359: LD_EXP 55
2363: PPUSH
2364: LD_EXP 60
2368: PPUSH
2369: CALL_OW 52
// end ; end ; end ;
2373: LD_VAR 0 1
2377: RET
// export function PrepareStevensSquad ; var tmp ; begin
2378: LD_INT 0
2380: PPUSH
2381: PPUSH
// uc_side := 1 ;
2382: LD_ADDR_OWVAR 20
2386: PUSH
2387: LD_INT 1
2389: ST_TO_ADDR
// uc_nation := 1 ;
2390: LD_ADDR_OWVAR 21
2394: PUSH
2395: LD_INT 1
2397: ST_TO_ADDR
// tmp := [ ] ;
2398: LD_ADDR_VAR 0 2
2402: PUSH
2403: EMPTY
2404: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2405: LD_ADDR_EXP 42
2409: PUSH
2410: LD_STRING Stevens
2412: PPUSH
2413: LD_EXP 1
2417: NOT
2418: PPUSH
2419: LD_STRING 13f_
2421: PPUSH
2422: CALL 70272 0 3
2426: ST_TO_ADDR
// if not Stevens then
2427: LD_EXP 42
2431: NOT
2432: IFFALSE 2546
// begin hc_name = Baker Smith ;
2434: LD_ADDR_OWVAR 26
2438: PUSH
2439: LD_STRING Baker Smith
2441: ST_TO_ADDR
// hc_gallery = us ;
2442: LD_ADDR_OWVAR 33
2446: PUSH
2447: LD_STRING us
2449: ST_TO_ADDR
// hc_face_number := 29 ;
2450: LD_ADDR_OWVAR 34
2454: PUSH
2455: LD_INT 29
2457: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2458: LD_INT 1
2460: PPUSH
2461: LD_INT 10
2463: PPUSH
2464: CALL_OW 384
// hc_basic_skills := [ 2 , 2 , 0 , 2 ] ;
2468: LD_ADDR_OWVAR 30
2472: PUSH
2473: LD_INT 2
2475: PUSH
2476: LD_INT 2
2478: PUSH
2479: LD_INT 0
2481: PUSH
2482: LD_INT 2
2484: PUSH
2485: EMPTY
2486: LIST
2487: LIST
2488: LIST
2489: LIST
2490: ST_TO_ADDR
// hc_skills := [ 4 , 5 , 2 , 10 ] ;
2491: LD_ADDR_OWVAR 31
2495: PUSH
2496: LD_INT 4
2498: PUSH
2499: LD_INT 5
2501: PUSH
2502: LD_INT 2
2504: PUSH
2505: LD_INT 10
2507: PUSH
2508: EMPTY
2509: LIST
2510: LIST
2511: LIST
2512: LIST
2513: ST_TO_ADDR
// Baker := CreateHuman ;
2514: LD_ADDR_EXP 56
2518: PUSH
2519: CALL_OW 44
2523: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2524: LD_ADDR_VAR 0 2
2528: PUSH
2529: LD_VAR 0 2
2533: PUSH
2534: LD_EXP 56
2538: ADD
2539: ST_TO_ADDR
// InitHc ;
2540: CALL_OW 19
// end else
2544: GO 2562
// tmp := tmp ^ Stevens ;
2546: LD_ADDR_VAR 0 2
2550: PUSH
2551: LD_VAR 0 2
2555: PUSH
2556: LD_EXP 42
2560: ADD
2561: ST_TO_ADDR
// if not Lisa then
2562: LD_EXP 43
2566: NOT
2567: IFFALSE 2613
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2569: LD_ADDR_EXP 43
2573: PUSH
2574: LD_STRING Lisa
2576: PPUSH
2577: LD_EXP 1
2581: NOT
2582: PPUSH
2583: LD_STRING 13f_
2585: PPUSH
2586: CALL 70272 0 3
2590: ST_TO_ADDR
// if Lisa then
2591: LD_EXP 43
2595: IFFALSE 2613
// tmp := tmp ^ Lisa ;
2597: LD_ADDR_VAR 0 2
2601: PUSH
2602: LD_VAR 0 2
2606: PUSH
2607: LD_EXP 43
2611: ADD
2612: ST_TO_ADDR
// end ; if not Donaldson then
2613: LD_EXP 44
2617: NOT
2618: IFFALSE 2664
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2620: LD_ADDR_EXP 44
2624: PUSH
2625: LD_STRING Donaldson
2627: PPUSH
2628: LD_EXP 1
2632: NOT
2633: PPUSH
2634: LD_STRING 13f_
2636: PPUSH
2637: CALL 70272 0 3
2641: ST_TO_ADDR
// if Donaldson then
2642: LD_EXP 44
2646: IFFALSE 2664
// tmp := tmp ^ Donaldson ;
2648: LD_ADDR_VAR 0 2
2652: PUSH
2653: LD_VAR 0 2
2657: PUSH
2658: LD_EXP 44
2662: ADD
2663: ST_TO_ADDR
// end ; if not Bobby then
2664: LD_EXP 45
2668: NOT
2669: IFFALSE 2715
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2671: LD_ADDR_EXP 45
2675: PUSH
2676: LD_STRING Bobby
2678: PPUSH
2679: LD_EXP 1
2683: NOT
2684: PPUSH
2685: LD_STRING 13f_
2687: PPUSH
2688: CALL 70272 0 3
2692: ST_TO_ADDR
// if Bobby then
2693: LD_EXP 45
2697: IFFALSE 2715
// tmp := tmp ^ Bobby ;
2699: LD_ADDR_VAR 0 2
2703: PUSH
2704: LD_VAR 0 2
2708: PUSH
2709: LD_EXP 45
2713: ADD
2714: ST_TO_ADDR
// end ; if not Cyrus then
2715: LD_EXP 46
2719: NOT
2720: IFFALSE 2766
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2722: LD_ADDR_EXP 46
2726: PUSH
2727: LD_STRING Cyrus
2729: PPUSH
2730: LD_EXP 1
2734: NOT
2735: PPUSH
2736: LD_STRING 13f_
2738: PPUSH
2739: CALL 70272 0 3
2743: ST_TO_ADDR
// if Cyrus then
2744: LD_EXP 46
2748: IFFALSE 2766
// tmp := tmp ^ Cyrus ;
2750: LD_ADDR_VAR 0 2
2754: PUSH
2755: LD_VAR 0 2
2759: PUSH
2760: LD_EXP 46
2764: ADD
2765: ST_TO_ADDR
// end ; if not Brown then
2766: LD_EXP 48
2770: NOT
2771: IFFALSE 2817
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2773: LD_ADDR_EXP 48
2777: PUSH
2778: LD_STRING Brown
2780: PPUSH
2781: LD_EXP 1
2785: NOT
2786: PPUSH
2787: LD_STRING 13f_
2789: PPUSH
2790: CALL 70272 0 3
2794: ST_TO_ADDR
// if Brown then
2795: LD_EXP 48
2799: IFFALSE 2817
// tmp := tmp ^ Brown ;
2801: LD_ADDR_VAR 0 2
2805: PUSH
2806: LD_VAR 0 2
2810: PUSH
2811: LD_EXP 48
2815: ADD
2816: ST_TO_ADDR
// end ; if not Gladstone then
2817: LD_EXP 49
2821: NOT
2822: IFFALSE 2868
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2824: LD_ADDR_EXP 49
2828: PUSH
2829: LD_STRING Gladstone
2831: PPUSH
2832: LD_EXP 1
2836: NOT
2837: PPUSH
2838: LD_STRING 13f_
2840: PPUSH
2841: CALL 70272 0 3
2845: ST_TO_ADDR
// if Gladstone then
2846: LD_EXP 49
2850: IFFALSE 2868
// tmp := tmp ^ Gladstone ;
2852: LD_ADDR_VAR 0 2
2856: PUSH
2857: LD_VAR 0 2
2861: PUSH
2862: LD_EXP 49
2866: ADD
2867: ST_TO_ADDR
// end ; if not Houten then
2868: LD_EXP 50
2872: NOT
2873: IFFALSE 2919
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2875: LD_ADDR_EXP 50
2879: PUSH
2880: LD_STRING Houten
2882: PPUSH
2883: LD_EXP 1
2887: NOT
2888: PPUSH
2889: LD_STRING 13f_
2891: PPUSH
2892: CALL 70272 0 3
2896: ST_TO_ADDR
// if Houten then
2897: LD_EXP 50
2901: IFFALSE 2919
// tmp := tmp ^ Houten ;
2903: LD_ADDR_VAR 0 2
2907: PUSH
2908: LD_VAR 0 2
2912: PUSH
2913: LD_EXP 50
2917: ADD
2918: ST_TO_ADDR
// end ; if not Cornel then
2919: LD_EXP 51
2923: NOT
2924: IFFALSE 2970
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2926: LD_ADDR_EXP 51
2930: PUSH
2931: LD_STRING Cornell
2933: PPUSH
2934: LD_EXP 1
2938: NOT
2939: PPUSH
2940: LD_STRING 13f_
2942: PPUSH
2943: CALL 70272 0 3
2947: ST_TO_ADDR
// if Cornel then
2948: LD_EXP 51
2952: IFFALSE 2970
// tmp := tmp ^ Cornel ;
2954: LD_ADDR_VAR 0 2
2958: PUSH
2959: LD_VAR 0 2
2963: PUSH
2964: LD_EXP 51
2968: ADD
2969: ST_TO_ADDR
// end ; if not Gary then
2970: LD_EXP 52
2974: NOT
2975: IFFALSE 3021
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2977: LD_ADDR_EXP 52
2981: PUSH
2982: LD_STRING Gary
2984: PPUSH
2985: LD_EXP 1
2989: NOT
2990: PPUSH
2991: LD_STRING 13f_
2993: PPUSH
2994: CALL 70272 0 3
2998: ST_TO_ADDR
// if Gary then
2999: LD_EXP 52
3003: IFFALSE 3021
// tmp := tmp ^ Gary ;
3005: LD_ADDR_VAR 0 2
3009: PUSH
3010: LD_VAR 0 2
3014: PUSH
3015: LD_EXP 52
3019: ADD
3020: ST_TO_ADDR
// end ; if not Frank then
3021: LD_EXP 53
3025: NOT
3026: IFFALSE 3072
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
3028: LD_ADDR_EXP 53
3032: PUSH
3033: LD_STRING Frank
3035: PPUSH
3036: LD_EXP 1
3040: NOT
3041: PPUSH
3042: LD_STRING 13f_
3044: PPUSH
3045: CALL 70272 0 3
3049: ST_TO_ADDR
// if Frank then
3050: LD_EXP 53
3054: IFFALSE 3072
// tmp := tmp ^ Frank ;
3056: LD_ADDR_VAR 0 2
3060: PUSH
3061: LD_VAR 0 2
3065: PUSH
3066: LD_EXP 53
3070: ADD
3071: ST_TO_ADDR
// end ; if not Kikuchi then
3072: LD_EXP 54
3076: NOT
3077: IFFALSE 3123
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
3079: LD_ADDR_EXP 54
3083: PUSH
3084: LD_STRING Kikuchi
3086: PPUSH
3087: LD_EXP 1
3091: NOT
3092: PPUSH
3093: LD_STRING 13f_
3095: PPUSH
3096: CALL 70272 0 3
3100: ST_TO_ADDR
// if Kikuchi then
3101: LD_EXP 54
3105: IFFALSE 3123
// tmp := tmp ^ Kikuchi ;
3107: LD_ADDR_VAR 0 2
3111: PUSH
3112: LD_VAR 0 2
3116: PUSH
3117: LD_EXP 54
3121: ADD
3122: ST_TO_ADDR
// end ; if not DeltaDoctor then
3123: LD_EXP 58
3127: NOT
3128: IFFALSE 3174
// begin DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13f_ ) ;
3130: LD_ADDR_EXP 58
3134: PUSH
3135: LD_STRING DeltaDoctor
3137: PPUSH
3138: LD_EXP 1
3142: NOT
3143: PPUSH
3144: LD_STRING 13f_
3146: PPUSH
3147: CALL 70272 0 3
3151: ST_TO_ADDR
// if Bobby then
3152: LD_EXP 45
3156: IFFALSE 3174
// tmp := tmp ^ DeltaDoctor ;
3158: LD_ADDR_VAR 0 2
3162: PUSH
3163: LD_VAR 0 2
3167: PUSH
3168: LD_EXP 58
3172: ADD
3173: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3174: LD_ADDR_VAR 0 2
3178: PUSH
3179: LD_VAR 0 2
3183: PUSH
3184: LD_STRING 13_other_survivors
3186: PPUSH
3187: CALL_OW 31
3191: UNION
3192: ST_TO_ADDR
// result := tmp diff 0 ;
3193: LD_ADDR_VAR 0 1
3197: PUSH
3198: LD_VAR 0 2
3202: PUSH
3203: LD_INT 0
3205: DIFF
3206: ST_TO_ADDR
// end ; end_of_file
3207: LD_VAR 0 1
3211: RET
// export Powell ; export vip , extraSquad ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3212: LD_INT 0
3214: PPUSH
3215: PPUSH
3216: PPUSH
3217: PPUSH
3218: PPUSH
3219: PPUSH
3220: PPUSH
3221: PPUSH
3222: PPUSH
3223: PPUSH
// uc_side := 4 ;
3224: LD_ADDR_OWVAR 20
3228: PUSH
3229: LD_INT 4
3231: ST_TO_ADDR
// uc_nation := 1 ;
3232: LD_ADDR_OWVAR 21
3236: PUSH
3237: LD_INT 1
3239: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3240: LD_INT 387
3242: PPUSH
3243: CALL_OW 274
3247: PPUSH
3248: LD_INT 1
3250: PPUSH
3251: LD_INT 3500
3253: PUSH
3254: LD_INT 3000
3256: PUSH
3257: LD_INT 2500
3259: PUSH
3260: LD_INT 2000
3262: PUSH
3263: EMPTY
3264: LIST
3265: LIST
3266: LIST
3267: LIST
3268: PUSH
3269: LD_OWVAR 67
3273: ARRAY
3274: PPUSH
3275: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3279: LD_INT 387
3281: PPUSH
3282: CALL_OW 274
3286: PPUSH
3287: LD_INT 2
3289: PPUSH
3290: LD_INT 400
3292: PPUSH
3293: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3297: LD_INT 387
3299: PPUSH
3300: CALL_OW 274
3304: PPUSH
3305: LD_INT 3
3307: PPUSH
3308: LD_INT 10
3310: PPUSH
3311: CALL_OW 277
// SetBName ( am_depot , sigma ) ;
3315: LD_INT 387
3317: PPUSH
3318: LD_STRING sigma
3320: PPUSH
3321: CALL_OW 500
// Powell := NewCharacter ( Powell ) ;
3325: LD_ADDR_EXP 61
3329: PUSH
3330: LD_STRING Powell
3332: PPUSH
3333: CALL_OW 25
3337: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3338: LD_EXP 61
3342: PPUSH
3343: LD_INT 57
3345: PPUSH
3346: LD_INT 94
3348: PPUSH
3349: LD_INT 0
3351: PPUSH
3352: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3356: LD_EXP 61
3360: PPUSH
3361: LD_INT 58
3363: PPUSH
3364: LD_INT 94
3366: PPUSH
3367: CALL_OW 118
// vip := [ ] ;
3371: LD_ADDR_EXP 62
3375: PUSH
3376: EMPTY
3377: ST_TO_ADDR
// extraSquad := [ ] ;
3378: LD_ADDR_EXP 63
3382: PUSH
3383: EMPTY
3384: ST_TO_ADDR
// tmp := [ ] ;
3385: LD_ADDR_VAR 0 5
3389: PUSH
3390: EMPTY
3391: ST_TO_ADDR
// if JMMGirl <> 2 then
3392: LD_EXP 7
3396: PUSH
3397: LD_INT 2
3399: NONEQUAL
3400: IFFALSE 3424
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3402: LD_ADDR_EXP 43
3406: PUSH
3407: LD_STRING Lisa
3409: PPUSH
3410: LD_EXP 1
3414: NOT
3415: PPUSH
3416: LD_STRING 13s_
3418: PPUSH
3419: CALL 70272 0 3
3423: ST_TO_ADDR
// if Lisa then
3424: LD_EXP 43
3428: IFFALSE 3446
// tmp := tmp ^ Lisa ;
3430: LD_ADDR_VAR 0 5
3434: PUSH
3435: LD_VAR 0 5
3439: PUSH
3440: LD_EXP 43
3444: ADD
3445: ST_TO_ADDR
// if JMMGirl < 3 then
3446: LD_EXP 7
3450: PUSH
3451: LD_INT 3
3453: LESS
3454: IFFALSE 3485
// begin Connie := NewCharacter ( Coonie ) ;
3456: LD_ADDR_EXP 55
3460: PUSH
3461: LD_STRING Coonie
3463: PPUSH
3464: CALL_OW 25
3468: ST_TO_ADDR
// tmp := tmp ^ Connie ;
3469: LD_ADDR_VAR 0 5
3473: PUSH
3474: LD_VAR 0 5
3478: PUSH
3479: LD_EXP 55
3483: ADD
3484: ST_TO_ADDR
// end ; Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3485: LD_ADDR_EXP 44
3489: PUSH
3490: LD_STRING Donaldson
3492: PPUSH
3493: LD_EXP 1
3497: NOT
3498: PPUSH
3499: LD_STRING 13s_
3501: PPUSH
3502: CALL 70272 0 3
3506: ST_TO_ADDR
// if Donaldson then
3507: LD_EXP 44
3511: IFFALSE 3529
// tmp := tmp ^ Donaldson ;
3513: LD_ADDR_VAR 0 5
3517: PUSH
3518: LD_VAR 0 5
3522: PUSH
3523: LD_EXP 44
3527: ADD
3528: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3529: LD_ADDR_EXP 45
3533: PUSH
3534: LD_STRING Bobby
3536: PPUSH
3537: LD_EXP 1
3541: NOT
3542: PPUSH
3543: LD_STRING 13s_
3545: PPUSH
3546: CALL 70272 0 3
3550: ST_TO_ADDR
// if Bobby then
3551: LD_EXP 45
3555: IFFALSE 3573
// tmp := tmp ^ Bobby ;
3557: LD_ADDR_VAR 0 5
3561: PUSH
3562: LD_VAR 0 5
3566: PUSH
3567: LD_EXP 45
3571: ADD
3572: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3573: LD_ADDR_EXP 46
3577: PUSH
3578: LD_STRING Cyrus
3580: PPUSH
3581: LD_EXP 1
3585: NOT
3586: PPUSH
3587: LD_STRING 13s_
3589: PPUSH
3590: CALL 70272 0 3
3594: ST_TO_ADDR
// if Cyrus then
3595: LD_EXP 46
3599: IFFALSE 3617
// tmp := tmp ^ Cyrus ;
3601: LD_ADDR_VAR 0 5
3605: PUSH
3606: LD_VAR 0 5
3610: PUSH
3611: LD_EXP 46
3615: ADD
3616: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3617: LD_ADDR_EXP 47
3621: PUSH
3622: LD_STRING Denis
3624: PPUSH
3625: LD_EXP 1
3629: NOT
3630: PPUSH
3631: LD_STRING 13s_
3633: PPUSH
3634: CALL 70272 0 3
3638: ST_TO_ADDR
// if not Denis then
3639: LD_EXP 47
3643: NOT
3644: IFFALSE 3668
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3646: LD_ADDR_EXP 47
3650: PUSH
3651: LD_STRING Denis
3653: PPUSH
3654: LD_EXP 1
3658: NOT
3659: PPUSH
3660: LD_STRING 13f_
3662: PPUSH
3663: CALL 70272 0 3
3667: ST_TO_ADDR
// if Denis then
3668: LD_EXP 47
3672: IFFALSE 3690
// tmp := tmp ^ Denis ;
3674: LD_ADDR_VAR 0 5
3678: PUSH
3679: LD_VAR 0 5
3683: PUSH
3684: LD_EXP 47
3688: ADD
3689: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3690: LD_ADDR_EXP 48
3694: PUSH
3695: LD_STRING Brown
3697: PPUSH
3698: LD_EXP 1
3702: NOT
3703: PPUSH
3704: LD_STRING 13s_
3706: PPUSH
3707: CALL 70272 0 3
3711: ST_TO_ADDR
// if Brown then
3712: LD_EXP 48
3716: IFFALSE 3734
// tmp := tmp ^ Brown ;
3718: LD_ADDR_VAR 0 5
3722: PUSH
3723: LD_VAR 0 5
3727: PUSH
3728: LD_EXP 48
3732: ADD
3733: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3734: LD_ADDR_EXP 49
3738: PUSH
3739: LD_STRING Gladstone
3741: PPUSH
3742: LD_EXP 1
3746: NOT
3747: PPUSH
3748: LD_STRING 13s_
3750: PPUSH
3751: CALL 70272 0 3
3755: ST_TO_ADDR
// if Gladstone then
3756: LD_EXP 49
3760: IFFALSE 3778
// tmp := tmp ^ Gladstone ;
3762: LD_ADDR_VAR 0 5
3766: PUSH
3767: LD_VAR 0 5
3771: PUSH
3772: LD_EXP 49
3776: ADD
3777: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3778: LD_ADDR_EXP 50
3782: PUSH
3783: LD_STRING Houten
3785: PPUSH
3786: LD_EXP 1
3790: NOT
3791: PPUSH
3792: LD_STRING 13s_
3794: PPUSH
3795: CALL 70272 0 3
3799: ST_TO_ADDR
// if Houten then
3800: LD_EXP 50
3804: IFFALSE 3822
// tmp := tmp ^ Houten ;
3806: LD_ADDR_VAR 0 5
3810: PUSH
3811: LD_VAR 0 5
3815: PUSH
3816: LD_EXP 50
3820: ADD
3821: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3822: LD_ADDR_EXP 51
3826: PUSH
3827: LD_STRING Cornel
3829: PPUSH
3830: LD_EXP 1
3834: NOT
3835: PPUSH
3836: LD_STRING 13s_
3838: PPUSH
3839: CALL 70272 0 3
3843: ST_TO_ADDR
// if Cornel then
3844: LD_EXP 51
3848: IFFALSE 3866
// tmp := tmp ^ Cornel ;
3850: LD_ADDR_VAR 0 5
3854: PUSH
3855: LD_VAR 0 5
3859: PUSH
3860: LD_EXP 51
3864: ADD
3865: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3866: LD_ADDR_EXP 52
3870: PUSH
3871: LD_STRING Gary
3873: PPUSH
3874: LD_EXP 1
3878: NOT
3879: PPUSH
3880: LD_STRING 13s_
3882: PPUSH
3883: CALL 70272 0 3
3887: ST_TO_ADDR
// if Gary then
3888: LD_EXP 52
3892: IFFALSE 3910
// tmp := tmp ^ Gary ;
3894: LD_ADDR_VAR 0 5
3898: PUSH
3899: LD_VAR 0 5
3903: PUSH
3904: LD_EXP 52
3908: ADD
3909: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3910: LD_ADDR_EXP 53
3914: PUSH
3915: LD_STRING Frank
3917: PPUSH
3918: LD_EXP 1
3922: NOT
3923: PPUSH
3924: LD_STRING 13s_
3926: PPUSH
3927: CALL 70272 0 3
3931: ST_TO_ADDR
// if Frank then
3932: LD_EXP 53
3936: IFFALSE 3954
// tmp := tmp ^ Frank ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_VAR 0 5
3947: PUSH
3948: LD_EXP 53
3952: ADD
3953: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3954: LD_ADDR_EXP 54
3958: PUSH
3959: LD_STRING Kikuchi
3961: PPUSH
3962: LD_EXP 1
3966: NOT
3967: PPUSH
3968: LD_STRING 13s_
3970: PPUSH
3971: CALL 70272 0 3
3975: ST_TO_ADDR
// if Kikuchi then
3976: LD_EXP 54
3980: IFFALSE 3998
// tmp := tmp ^ Kikuchi ;
3982: LD_ADDR_VAR 0 5
3986: PUSH
3987: LD_VAR 0 5
3991: PUSH
3992: LD_EXP 54
3996: ADD
3997: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13s_ ) ;
3998: LD_ADDR_EXP 58
4002: PUSH
4003: LD_STRING DeltaDoctor
4005: PPUSH
4006: LD_EXP 1
4010: NOT
4011: PPUSH
4012: LD_STRING 13s_
4014: PPUSH
4015: CALL 70272 0 3
4019: ST_TO_ADDR
// if DeltaDoctor then
4020: LD_EXP 58
4024: IFFALSE 4042
// tmp := tmp ^ DeltaDoctor ;
4026: LD_ADDR_VAR 0 5
4030: PUSH
4031: LD_VAR 0 5
4035: PUSH
4036: LD_EXP 58
4040: ADD
4041: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 10c_ ) ;
4042: LD_ADDR_EXP 57
4046: PUSH
4047: LD_STRING Mike
4049: PPUSH
4050: LD_EXP 1
4054: NOT
4055: PPUSH
4056: LD_STRING 10c_
4058: PPUSH
4059: CALL 70272 0 3
4063: ST_TO_ADDR
// if Mike then
4064: LD_EXP 57
4068: IFFALSE 4091
// PlaceUnitXYR ( Mike , 61 , 89 , 8 , false ) ;
4070: LD_EXP 57
4074: PPUSH
4075: LD_INT 61
4077: PPUSH
4078: LD_INT 89
4080: PPUSH
4081: LD_INT 8
4083: PPUSH
4084: LD_INT 0
4086: PPUSH
4087: CALL_OW 50
// vip := tmp ;
4091: LD_ADDR_EXP 62
4095: PUSH
4096: LD_VAR 0 5
4100: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
4101: LD_ADDR_VAR 0 5
4105: PUSH
4106: LD_VAR 0 5
4110: PUSH
4111: LD_STRING 13s_others
4113: PPUSH
4114: CALL_OW 31
4118: UNION
4119: ST_TO_ADDR
// if tmp < 18 then
4120: LD_VAR 0 5
4124: PUSH
4125: LD_INT 18
4127: LESS
4128: IFFALSE 4233
// begin InitHC_All ( ) ;
4130: CALL_OW 584
// for i = 1 to 18 - tmp do
4134: LD_ADDR_VAR 0 2
4138: PUSH
4139: DOUBLE
4140: LD_INT 1
4142: DEC
4143: ST_TO_ADDR
4144: LD_INT 18
4146: PUSH
4147: LD_VAR 0 5
4151: MINUS
4152: PUSH
4153: FOR_TO
4154: IFFALSE 4231
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
4156: LD_INT 1
4158: PPUSH
4159: LD_VAR 0 2
4163: PUSH
4164: LD_INT 4
4166: MOD
4167: PUSH
4168: LD_INT 1
4170: PLUS
4171: PPUSH
4172: LD_INT 4
4174: PPUSH
4175: CALL_OW 380
// un := CreateHuman ;
4179: LD_ADDR_VAR 0 10
4183: PUSH
4184: CALL_OW 44
4188: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
4189: LD_ADDR_VAR 0 5
4193: PUSH
4194: LD_VAR 0 5
4198: PPUSH
4199: LD_VAR 0 10
4203: PPUSH
4204: CALL 108004 0 2
4208: ST_TO_ADDR
// extraSquad := Join ( extraSquad , un ) ;
4209: LD_ADDR_EXP 63
4213: PUSH
4214: LD_EXP 63
4218: PPUSH
4219: LD_VAR 0 10
4223: PPUSH
4224: CALL 108004 0 2
4228: ST_TO_ADDR
// end ;
4229: GO 4153
4231: POP
4232: POP
// end ; depot := HexInfo ( 53 , 94 ) ;
4233: LD_ADDR_VAR 0 6
4237: PUSH
4238: LD_INT 53
4240: PPUSH
4241: LD_INT 94
4243: PPUSH
4244: CALL_OW 428
4248: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
4249: LD_ADDR_VAR 0 7
4253: PUSH
4254: LD_INT 56
4256: PPUSH
4257: LD_INT 101
4259: PPUSH
4260: CALL_OW 428
4264: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
4265: LD_ADDR_VAR 0 8
4269: PUSH
4270: LD_INT 67
4272: PPUSH
4273: LD_INT 101
4275: PPUSH
4276: CALL_OW 428
4280: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
4281: LD_ADDR_VAR 0 9
4285: PUSH
4286: LD_INT 54
4288: PPUSH
4289: LD_INT 85
4291: PPUSH
4292: CALL_OW 428
4296: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
4297: LD_ADDR_VAR 0 3
4301: PUSH
4302: LD_VAR 0 8
4306: PUSH
4307: LD_VAR 0 6
4311: PUSH
4312: LD_VAR 0 9
4316: PUSH
4317: LD_VAR 0 7
4321: PUSH
4322: EMPTY
4323: LIST
4324: LIST
4325: LIST
4326: LIST
4327: ST_TO_ADDR
// for i in tmp do
4328: LD_ADDR_VAR 0 2
4332: PUSH
4333: LD_VAR 0 5
4337: PUSH
4338: FOR_IN
4339: IFFALSE 4534
// begin case GetBType ( b [ 1 ] ) of b_armoury :
4341: LD_VAR 0 3
4345: PUSH
4346: LD_INT 1
4348: ARRAY
4349: PPUSH
4350: CALL_OW 266
4354: PUSH
4355: LD_INT 4
4357: DOUBLE
4358: EQUAL
4359: IFTRUE 4363
4361: GO 4378
4363: POP
// SetClass ( i , class_soldier ) ; b_depot :
4364: LD_VAR 0 2
4368: PPUSH
4369: LD_INT 1
4371: PPUSH
4372: CALL_OW 336
4376: GO 4448
4378: LD_INT 0
4380: DOUBLE
4381: EQUAL
4382: IFTRUE 4386
4384: GO 4401
4386: POP
// SetClass ( i , class_engineer ) ; b_workshop :
4387: LD_VAR 0 2
4391: PPUSH
4392: LD_INT 2
4394: PPUSH
4395: CALL_OW 336
4399: GO 4448
4401: LD_INT 2
4403: DOUBLE
4404: EQUAL
4405: IFTRUE 4409
4407: GO 4424
4409: POP
// SetClass ( i , class_mechanic ) ; b_lab :
4410: LD_VAR 0 2
4414: PPUSH
4415: LD_INT 3
4417: PPUSH
4418: CALL_OW 336
4422: GO 4448
4424: LD_INT 6
4426: DOUBLE
4427: EQUAL
4428: IFTRUE 4432
4430: GO 4447
4432: POP
// SetClass ( i , class_scientistic ) ; end ;
4433: LD_VAR 0 2
4437: PPUSH
4438: LD_INT 4
4440: PPUSH
4441: CALL_OW 336
4445: GO 4448
4447: POP
// if UnitsInside ( b [ 1 ] ) = 6 then
4448: LD_VAR 0 3
4452: PUSH
4453: LD_INT 1
4455: ARRAY
4456: PPUSH
4457: CALL_OW 313
4461: PUSH
4462: LD_INT 6
4464: EQUAL
4465: IFFALSE 4485
// b := Delete ( b , 1 ) ;
4467: LD_ADDR_VAR 0 3
4471: PUSH
4472: LD_VAR 0 3
4476: PPUSH
4477: LD_INT 1
4479: PPUSH
4480: CALL_OW 3
4484: ST_TO_ADDR
// if b then
4485: LD_VAR 0 3
4489: IFFALSE 4511
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4491: LD_VAR 0 2
4495: PPUSH
4496: LD_VAR 0 3
4500: PUSH
4501: LD_INT 1
4503: ARRAY
4504: PPUSH
4505: CALL_OW 52
4509: GO 4532
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4511: LD_VAR 0 2
4515: PPUSH
4516: LD_INT 61
4518: PPUSH
4519: LD_INT 89
4521: PPUSH
4522: LD_INT 8
4524: PPUSH
4525: LD_INT 0
4527: PPUSH
4528: CALL_OW 50
// end ;
4532: GO 4338
4534: POP
4535: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4536: LD_INT 2
4538: PPUSH
4539: LD_INT 1
4541: PPUSH
4542: LD_INT 1
4544: PPUSH
4545: LD_INT 12
4547: PPUSH
4548: LD_INT 100
4550: PPUSH
4551: CALL 75133 0 5
// veh := CreateVehicle ;
4555: LD_ADDR_VAR 0 4
4559: PUSH
4560: CALL_OW 45
4564: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4565: LD_VAR 0 4
4569: PPUSH
4570: LD_INT 4
4572: PPUSH
4573: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4577: LD_VAR 0 4
4581: PPUSH
4582: LD_INT 49
4584: PPUSH
4585: LD_INT 88
4587: PPUSH
4588: LD_INT 0
4590: PPUSH
4591: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4595: LD_VAR 0 4
4599: PPUSH
4600: LD_INT 1
4602: PPUSH
4603: LD_INT 100
4605: PPUSH
4606: CALL_OW 290
// uc_side := 0 ;
4610: LD_ADDR_OWVAR 20
4614: PUSH
4615: LD_INT 0
4617: ST_TO_ADDR
// uc_nation := 0 ;
4618: LD_ADDR_OWVAR 21
4622: PUSH
4623: LD_INT 0
4625: ST_TO_ADDR
// for i := 1 to 3 do
4626: LD_ADDR_VAR 0 2
4630: PUSH
4631: DOUBLE
4632: LD_INT 1
4634: DEC
4635: ST_TO_ADDR
4636: LD_INT 3
4638: PUSH
4639: FOR_TO
4640: IFFALSE 4671
// begin InitHc ;
4642: CALL_OW 19
// hc_class := class_apeman ;
4646: LD_ADDR_OWVAR 28
4650: PUSH
4651: LD_INT 12
4653: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4654: CALL_OW 44
4658: PPUSH
4659: LD_INT 13
4661: PPUSH
4662: LD_INT 0
4664: PPUSH
4665: CALL_OW 49
// end ;
4669: GO 4639
4671: POP
4672: POP
// end ; end_of_file
4673: LD_VAR 0 1
4677: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4678: LD_INT 0
4680: PPUSH
4681: PPUSH
4682: PPUSH
4683: PPUSH
4684: PPUSH
// side := 8 ;
4685: LD_ADDR_VAR 0 3
4689: PUSH
4690: LD_INT 8
4692: ST_TO_ADDR
// uc_side := side ;
4693: LD_ADDR_OWVAR 20
4697: PUSH
4698: LD_VAR 0 3
4702: ST_TO_ADDR
// uc_nation := 2 ;
4703: LD_ADDR_OWVAR 21
4707: PUSH
4708: LD_INT 2
4710: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4711: LD_ADDR_VAR 0 2
4715: PUSH
4716: LD_INT 22
4718: PUSH
4719: LD_VAR 0 3
4723: PUSH
4724: EMPTY
4725: LIST
4726: LIST
4727: PUSH
4728: LD_INT 21
4730: PUSH
4731: LD_INT 3
4733: PUSH
4734: EMPTY
4735: LIST
4736: LIST
4737: PUSH
4738: EMPTY
4739: LIST
4740: LIST
4741: PPUSH
4742: CALL_OW 69
4746: PUSH
4747: FOR_IN
4748: IFFALSE 4764
// SetBLevel ( i , 10 ) ;
4750: LD_VAR 0 2
4754: PPUSH
4755: LD_INT 10
4757: PPUSH
4758: CALL_OW 241
4762: GO 4747
4764: POP
4765: POP
// if KurtStatus then
4766: LD_EXP 3
4770: IFFALSE 4793
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4772: LD_ADDR_EXP 64
4776: PUSH
4777: LD_STRING Kurt
4779: PPUSH
4780: LD_INT 0
4782: PPUSH
4783: LD_STRING 
4785: PPUSH
4786: CALL 70272 0 3
4790: ST_TO_ADDR
4791: GO 4815
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4793: LD_ADDR_EXP 64
4797: PUSH
4798: LD_STRING AltKurt
4800: PPUSH
4801: LD_EXP 1
4805: NOT
4806: PPUSH
4807: LD_STRING 
4809: PPUSH
4810: CALL 70272 0 3
4814: ST_TO_ADDR
// if not Kurt then
4815: LD_EXP 64
4819: NOT
4820: IFFALSE 4846
// begin InitHc ;
4822: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4826: LD_INT 1
4828: PPUSH
4829: LD_INT 10
4831: PPUSH
4832: CALL_OW 381
// Kurt := CreateHuman ;
4836: LD_ADDR_EXP 64
4840: PUSH
4841: CALL_OW 44
4845: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4846: LD_EXP 64
4850: PPUSH
4851: LD_INT 324
4853: PPUSH
4854: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4858: LD_ADDR_EXP 65
4862: PUSH
4863: LD_STRING Kozlov
4865: PPUSH
4866: LD_INT 0
4868: PPUSH
4869: LD_STRING 
4871: PPUSH
4872: CALL 70272 0 3
4876: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4877: LD_EXP 65
4881: PPUSH
4882: LD_INT 22
4884: PUSH
4885: LD_INT 8
4887: PUSH
4888: EMPTY
4889: LIST
4890: LIST
4891: PUSH
4892: LD_INT 23
4894: PUSH
4895: LD_INT 3
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: PUSH
4902: LD_INT 30
4904: PUSH
4905: LD_INT 8
4907: PUSH
4908: EMPTY
4909: LIST
4910: LIST
4911: PUSH
4912: EMPTY
4913: LIST
4914: LIST
4915: LIST
4916: PPUSH
4917: CALL_OW 69
4921: PUSH
4922: LD_INT 1
4924: ARRAY
4925: PPUSH
4926: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4930: LD_EXP 65
4934: PPUSH
4935: LD_INT 3
4937: PPUSH
4938: LD_INT 10
4940: PPUSH
4941: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4945: LD_EXP 65
4949: PPUSH
4950: LD_INT 4
4952: PPUSH
4953: LD_INT 10
4955: PPUSH
4956: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4960: LD_ADDR_VAR 0 5
4964: PUSH
4965: LD_INT 22
4967: PUSH
4968: LD_VAR 0 3
4972: PUSH
4973: EMPTY
4974: LIST
4975: LIST
4976: PUSH
4977: LD_INT 30
4979: PUSH
4980: LD_INT 32
4982: PUSH
4983: EMPTY
4984: LIST
4985: LIST
4986: PUSH
4987: LD_INT 58
4989: PUSH
4990: EMPTY
4991: LIST
4992: PUSH
4993: EMPTY
4994: LIST
4995: LIST
4996: LIST
4997: PPUSH
4998: CALL_OW 69
5002: ST_TO_ADDR
// for i = 1 to 10 do
5003: LD_ADDR_VAR 0 2
5007: PUSH
5008: DOUBLE
5009: LD_INT 1
5011: DEC
5012: ST_TO_ADDR
5013: LD_INT 10
5015: PUSH
5016: FOR_TO
5017: IFFALSE 5089
// begin uc_nation := nation_nature ;
5019: LD_ADDR_OWVAR 21
5023: PUSH
5024: LD_INT 0
5026: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
5027: LD_ADDR_OWVAR 28
5031: PUSH
5032: LD_INT 15
5034: ST_TO_ADDR
// hc_gallery :=  ;
5035: LD_ADDR_OWVAR 33
5039: PUSH
5040: LD_STRING 
5042: ST_TO_ADDR
// hc_name :=  ;
5043: LD_ADDR_OWVAR 26
5047: PUSH
5048: LD_STRING 
5050: ST_TO_ADDR
// un := CreateHuman ;
5051: LD_ADDR_VAR 0 4
5055: PUSH
5056: CALL_OW 44
5060: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
5061: LD_VAR 0 4
5065: PPUSH
5066: LD_VAR 0 5
5070: PUSH
5071: LD_VAR 0 5
5075: PUSH
5076: LD_VAR 0 2
5080: MINUS
5081: ARRAY
5082: PPUSH
5083: CALL_OW 52
// end ;
5087: GO 5016
5089: POP
5090: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
5091: LD_ADDR_VAR 0 5
5095: PUSH
5096: LD_STRING 12_kurt_squad
5098: PPUSH
5099: CALL_OW 31
5103: ST_TO_ADDR
// if tmp then
5104: LD_VAR 0 5
5108: IFFALSE 5142
// for i in tmp do
5110: LD_ADDR_VAR 0 2
5114: PUSH
5115: LD_VAR 0 5
5119: PUSH
5120: FOR_IN
5121: IFFALSE 5140
// PlaceUnitArea ( i , legionBaseArea , false ) ;
5123: LD_VAR 0 2
5127: PPUSH
5128: LD_INT 5
5130: PPUSH
5131: LD_INT 0
5133: PPUSH
5134: CALL_OW 49
5138: GO 5120
5140: POP
5141: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
5142: LD_INT 324
5144: PPUSH
5145: LD_INT 5
5147: PPUSH
5148: LD_STRING 
5150: PPUSH
5151: LD_INT 8
5153: PUSH
5154: LD_INT 9
5156: PUSH
5157: LD_INT 10
5159: PUSH
5160: LD_INT 10
5162: PUSH
5163: EMPTY
5164: LIST
5165: LIST
5166: LIST
5167: LIST
5168: PUSH
5169: LD_OWVAR 67
5173: ARRAY
5174: PPUSH
5175: LD_INT 3000
5177: PUSH
5178: LD_INT 500
5180: PUSH
5181: LD_INT 150
5183: PUSH
5184: EMPTY
5185: LIST
5186: LIST
5187: LIST
5188: PPUSH
5189: LD_INT 16
5191: PUSH
5192: LD_INT 6
5194: PUSH
5195: LD_INT 6
5197: PUSH
5198: LD_INT 8
5200: PUSH
5201: EMPTY
5202: LIST
5203: LIST
5204: LIST
5205: LIST
5206: PPUSH
5207: CALL 78954 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
5211: LD_ADDR_EXP 102
5215: PUSH
5216: LD_EXP 102
5220: PPUSH
5221: LD_INT 3
5223: PPUSH
5224: LD_INT 22
5226: PUSH
5227: LD_VAR 0 3
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: PUSH
5236: LD_INT 23
5238: PUSH
5239: LD_INT 2
5241: PUSH
5242: EMPTY
5243: LIST
5244: LIST
5245: PUSH
5246: LD_INT 3
5248: PUSH
5249: LD_INT 21
5251: PUSH
5252: LD_INT 2
5254: PUSH
5255: EMPTY
5256: LIST
5257: LIST
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: PUSH
5263: EMPTY
5264: LIST
5265: LIST
5266: LIST
5267: PPUSH
5268: CALL_OW 69
5272: PUSH
5273: LD_EXP 64
5277: DIFF
5278: PPUSH
5279: CALL_OW 1
5283: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
5284: LD_INT 1
5286: PPUSH
5287: LD_INT 7
5289: PPUSH
5290: CALL_OW 383
// hc_name := Ali Hadrach ;
5294: LD_ADDR_OWVAR 26
5298: PUSH
5299: LD_STRING Ali Hadrach
5301: ST_TO_ADDR
// hc_gallery := us ;
5302: LD_ADDR_OWVAR 33
5306: PUSH
5307: LD_STRING us
5309: ST_TO_ADDR
// hc_face_number := 31 ;
5310: LD_ADDR_OWVAR 34
5314: PUSH
5315: LD_INT 31
5317: ST_TO_ADDR
// Friend := CreateHuman ;
5318: LD_ADDR_EXP 66
5322: PUSH
5323: CALL_OW 44
5327: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
5328: LD_INT 14
5330: PPUSH
5331: LD_INT 3
5333: PPUSH
5334: LD_INT 1
5336: PPUSH
5337: LD_INT 29
5339: PPUSH
5340: LD_INT 100
5342: PPUSH
5343: CALL 75133 0 5
// powellBomb := CreateVehicle ;
5347: LD_ADDR_EXP 67
5351: PUSH
5352: CALL_OW 45
5356: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
5357: LD_EXP 67
5361: PPUSH
5362: LD_INT 90
5364: PPUSH
5365: LD_INT 51
5367: PPUSH
5368: LD_INT 0
5370: PPUSH
5371: CALL_OW 48
// end ;
5375: LD_VAR 0 1
5379: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
5380: LD_INT 0
5382: PPUSH
5383: PPUSH
5384: PPUSH
// if IsLive ( kozlov_fac ) then
5385: LD_INT 332
5387: PPUSH
5388: CALL_OW 300
5392: IFFALSE 5396
// exit ;
5394: GO 5963
// ComExitBuilding ( Kozlov ) ;
5396: LD_EXP 65
5400: PPUSH
5401: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
5405: LD_EXP 65
5409: PPUSH
5410: CALL_OW 257
5414: PUSH
5415: LD_INT 2
5417: NONEQUAL
5418: IFFALSE 5453
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
5420: LD_EXP 65
5424: PPUSH
5425: LD_INT 324
5427: PPUSH
5428: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
5432: LD_EXP 65
5436: PPUSH
5437: LD_INT 2
5439: PPUSH
5440: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
5444: LD_EXP 65
5448: PPUSH
5449: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
5453: LD_EXP 65
5457: PPUSH
5458: LD_INT 2
5460: PPUSH
5461: LD_INT 93
5463: PPUSH
5464: LD_INT 32
5466: PPUSH
5467: LD_INT 3
5469: PPUSH
5470: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5474: LD_INT 35
5476: PPUSH
5477: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5481: LD_INT 22
5483: PUSH
5484: LD_INT 8
5486: PUSH
5487: EMPTY
5488: LIST
5489: LIST
5490: PUSH
5491: LD_INT 30
5493: PUSH
5494: LD_INT 3
5496: PUSH
5497: EMPTY
5498: LIST
5499: LIST
5500: PUSH
5501: LD_INT 23
5503: PUSH
5504: LD_INT 3
5506: PUSH
5507: EMPTY
5508: LIST
5509: LIST
5510: PUSH
5511: LD_INT 57
5513: PUSH
5514: EMPTY
5515: LIST
5516: PUSH
5517: EMPTY
5518: LIST
5519: LIST
5520: LIST
5521: LIST
5522: PPUSH
5523: CALL_OW 69
5527: IFFALSE 5474
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5529: LD_ADDR_VAR 0 2
5533: PUSH
5534: LD_INT 22
5536: PUSH
5537: LD_INT 8
5539: PUSH
5540: EMPTY
5541: LIST
5542: LIST
5543: PUSH
5544: LD_INT 30
5546: PUSH
5547: LD_INT 3
5549: PUSH
5550: EMPTY
5551: LIST
5552: LIST
5553: PUSH
5554: LD_INT 23
5556: PUSH
5557: LD_INT 3
5559: PUSH
5560: EMPTY
5561: LIST
5562: LIST
5563: PUSH
5564: LD_INT 57
5566: PUSH
5567: EMPTY
5568: LIST
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: LIST
5574: LIST
5575: PPUSH
5576: CALL_OW 69
5580: PUSH
5581: LD_INT 1
5583: ARRAY
5584: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5585: LD_INT 22
5587: PUSH
5588: LD_INT 8
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: PUSH
5595: LD_INT 23
5597: PUSH
5598: LD_INT 3
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: PUSH
5605: LD_INT 30
5607: PUSH
5608: LD_INT 21
5610: PUSH
5611: EMPTY
5612: LIST
5613: LIST
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: LIST
5619: PPUSH
5620: CALL_OW 69
5624: NOT
5625: IFFALSE 5703
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5627: LD_EXP 65
5631: PPUSH
5632: LD_INT 21
5634: PPUSH
5635: LD_INT 97
5637: PPUSH
5638: LD_INT 36
5640: PPUSH
5641: LD_INT 5
5643: PPUSH
5644: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5648: LD_INT 35
5650: PPUSH
5651: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5655: LD_INT 22
5657: PUSH
5658: LD_INT 8
5660: PUSH
5661: EMPTY
5662: LIST
5663: LIST
5664: PUSH
5665: LD_INT 23
5667: PUSH
5668: LD_INT 3
5670: PUSH
5671: EMPTY
5672: LIST
5673: LIST
5674: PUSH
5675: LD_INT 30
5677: PUSH
5678: LD_INT 21
5680: PUSH
5681: EMPTY
5682: LIST
5683: LIST
5684: PUSH
5685: LD_INT 57
5687: PUSH
5688: EMPTY
5689: LIST
5690: PUSH
5691: EMPTY
5692: LIST
5693: LIST
5694: LIST
5695: LIST
5696: PPUSH
5697: CALL_OW 69
5701: IFFALSE 5648
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5703: LD_INT 22
5705: PUSH
5706: LD_INT 8
5708: PUSH
5709: EMPTY
5710: LIST
5711: LIST
5712: PUSH
5713: LD_INT 23
5715: PUSH
5716: LD_INT 3
5718: PUSH
5719: EMPTY
5720: LIST
5721: LIST
5722: PUSH
5723: LD_INT 30
5725: PUSH
5726: LD_INT 18
5728: PUSH
5729: EMPTY
5730: LIST
5731: LIST
5732: PUSH
5733: EMPTY
5734: LIST
5735: LIST
5736: LIST
5737: PPUSH
5738: CALL_OW 69
5742: NOT
5743: IFFALSE 5821
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5745: LD_EXP 65
5749: PPUSH
5750: LD_INT 18
5752: PPUSH
5753: LD_INT 89
5755: PPUSH
5756: LD_INT 32
5758: PPUSH
5759: LD_INT 1
5761: PPUSH
5762: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5766: LD_INT 35
5768: PPUSH
5769: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5773: LD_INT 22
5775: PUSH
5776: LD_INT 8
5778: PUSH
5779: EMPTY
5780: LIST
5781: LIST
5782: PUSH
5783: LD_INT 23
5785: PUSH
5786: LD_INT 3
5788: PUSH
5789: EMPTY
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 30
5795: PUSH
5796: LD_INT 18
5798: PUSH
5799: EMPTY
5800: LIST
5801: LIST
5802: PUSH
5803: LD_INT 57
5805: PUSH
5806: EMPTY
5807: LIST
5808: PUSH
5809: EMPTY
5810: LIST
5811: LIST
5812: LIST
5813: LIST
5814: PPUSH
5815: CALL_OW 69
5819: IFFALSE 5766
// end ; lab := kozlov_lab ;
5821: LD_ADDR_VAR 0 3
5825: PUSH
5826: LD_INT 336
5828: ST_TO_ADDR
// if not lab then
5829: LD_VAR 0 3
5833: NOT
5834: IFFALSE 5838
// exit ;
5836: GO 5963
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5838: LD_EXP 65
5842: PPUSH
5843: LD_VAR 0 3
5847: PUSH
5848: LD_INT 1
5850: ARRAY
5851: PPUSH
5852: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5856: LD_EXP 65
5860: PPUSH
5861: LD_INT 4
5863: PPUSH
5864: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5868: LD_VAR 0 3
5872: PUSH
5873: LD_INT 1
5875: ARRAY
5876: PPUSH
5877: LD_INT 25
5879: PPUSH
5880: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5884: LD_INT 35
5886: PPUSH
5887: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5891: LD_INT 25
5893: PPUSH
5894: LD_INT 8
5896: PPUSH
5897: CALL_OW 321
5901: PUSH
5902: LD_INT 2
5904: EQUAL
5905: IFFALSE 5884
// ComExitBuilding ( Kozlov ) ;
5907: LD_EXP 65
5911: PPUSH
5912: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5916: LD_EXP 65
5920: PPUSH
5921: LD_VAR 0 2
5925: PPUSH
5926: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5930: LD_EXP 65
5934: PPUSH
5935: LD_INT 3
5937: PPUSH
5938: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5942: LD_VAR 0 2
5946: PPUSH
5947: LD_INT 23
5949: PPUSH
5950: LD_INT 3
5952: PPUSH
5953: LD_INT 1
5955: PPUSH
5956: LD_INT 48
5958: PPUSH
5959: CALL_OW 125
// end ;
5963: LD_VAR 0 1
5967: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5968: LD_EXP 22
5972: NOT
5973: PUSH
5974: LD_EXP 15
5978: PUSH
5979: LD_INT 6
5981: GREATEREQUAL
5982: AND
5983: IFFALSE 6064
5985: GO 5987
5987: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5988: LD_INT 3
5990: PPUSH
5991: LD_INT 3
5993: PPUSH
5994: CALL 63983 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5998: LD_INT 3
6000: PPUSH
6001: LD_INT 14
6003: PUSH
6004: LD_INT 1
6006: PUSH
6007: LD_INT 1
6009: PUSH
6010: LD_INT 28
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: PUSH
6019: LD_INT 14
6021: PUSH
6022: LD_INT 1
6024: PUSH
6025: LD_INT 1
6027: PUSH
6028: LD_INT 28
6030: PUSH
6031: EMPTY
6032: LIST
6033: LIST
6034: LIST
6035: LIST
6036: PUSH
6037: LD_INT 14
6039: PUSH
6040: LD_INT 1
6042: PUSH
6043: LD_INT 1
6045: PUSH
6046: LD_INT 28
6048: PUSH
6049: EMPTY
6050: LIST
6051: LIST
6052: LIST
6053: LIST
6054: PUSH
6055: EMPTY
6056: LIST
6057: LIST
6058: LIST
6059: PPUSH
6060: CALL 63846 0 2
// end ;
6064: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target , p ;
6065: LD_EXP 22
6069: NOT
6070: PUSH
6071: LD_EXP 15
6075: PUSH
6076: LD_INT 6
6078: GREATEREQUAL
6079: AND
6080: PUSH
6081: LD_INT 3
6083: PPUSH
6084: LD_INT 1
6086: PPUSH
6087: CALL 65264 0 2
6091: NOT
6092: AND
6093: IFFALSE 7046
6095: GO 6097
6097: DISABLE
6098: LD_INT 0
6100: PPUSH
6101: PPUSH
6102: PPUSH
6103: PPUSH
// begin enable ;
6104: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
6105: LD_INT 22
6107: PUSH
6108: LD_INT 8
6110: PUSH
6111: EMPTY
6112: LIST
6113: LIST
6114: PUSH
6115: LD_INT 23
6117: PUSH
6118: LD_INT 2
6120: PUSH
6121: EMPTY
6122: LIST
6123: LIST
6124: PUSH
6125: LD_INT 30
6127: PUSH
6128: LD_INT 3
6130: PUSH
6131: EMPTY
6132: LIST
6133: LIST
6134: PUSH
6135: EMPTY
6136: LIST
6137: LIST
6138: LIST
6139: PPUSH
6140: CALL_OW 69
6144: NOT
6145: IFFALSE 6149
// exit ;
6147: GO 7046
// if Prob ( 40 ) then
6149: LD_INT 40
6151: PPUSH
6152: CALL_OW 13
6156: IFFALSE 6283
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6158: LD_INT 3
6160: PPUSH
6161: LD_INT 14
6163: PUSH
6164: LD_INT 1
6166: PUSH
6167: LD_INT 2
6169: PUSH
6170: LD_INT 28
6172: PUSH
6173: EMPTY
6174: LIST
6175: LIST
6176: LIST
6177: LIST
6178: PUSH
6179: LD_INT 14
6181: PUSH
6182: LD_INT 1
6184: PUSH
6185: LD_INT 2
6187: PUSH
6188: LD_INT 28
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: LIST
6195: LIST
6196: PUSH
6197: LD_INT 14
6199: PUSH
6200: LD_INT 1
6202: PUSH
6203: LD_INT 2
6205: PUSH
6206: LD_INT 28
6208: PUSH
6209: EMPTY
6210: LIST
6211: LIST
6212: LIST
6213: LIST
6214: PUSH
6215: LD_INT 14
6217: PUSH
6218: LD_INT 1
6220: PUSH
6221: LD_INT 2
6223: PUSH
6224: LD_INT 28
6226: PUSH
6227: EMPTY
6228: LIST
6229: LIST
6230: LIST
6231: LIST
6232: PUSH
6233: LD_INT 14
6235: PUSH
6236: LD_INT 1
6238: PUSH
6239: LD_INT 2
6241: PUSH
6242: LD_INT 28
6244: PUSH
6245: EMPTY
6246: LIST
6247: LIST
6248: LIST
6249: LIST
6250: PUSH
6251: LD_INT 14
6253: PUSH
6254: LD_INT 1
6256: PUSH
6257: LD_INT 2
6259: PUSH
6260: LD_INT 26
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: LIST
6267: LIST
6268: PUSH
6269: EMPTY
6270: LIST
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: LIST
6276: PPUSH
6277: CALL 63846 0 2
// end else
6281: GO 6490
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6283: LD_INT 3
6285: PPUSH
6286: LD_INT 14
6288: PUSH
6289: LD_INT 1
6291: PUSH
6292: LD_INT 2
6294: PUSH
6295: LD_INT 27
6297: PUSH
6298: LD_INT 26
6300: PUSH
6301: LD_INT 26
6303: PUSH
6304: LD_INT 28
6306: PUSH
6307: EMPTY
6308: LIST
6309: LIST
6310: LIST
6311: LIST
6312: PUSH
6313: LD_OWVAR 67
6317: ARRAY
6318: PUSH
6319: EMPTY
6320: LIST
6321: LIST
6322: LIST
6323: LIST
6324: PUSH
6325: LD_INT 14
6327: PUSH
6328: LD_INT 1
6330: PUSH
6331: LD_INT 2
6333: PUSH
6334: LD_INT 27
6336: PUSH
6337: LD_INT 26
6339: PUSH
6340: LD_INT 26
6342: PUSH
6343: LD_INT 26
6345: PUSH
6346: EMPTY
6347: LIST
6348: LIST
6349: LIST
6350: LIST
6351: PUSH
6352: LD_OWVAR 67
6356: ARRAY
6357: PUSH
6358: EMPTY
6359: LIST
6360: LIST
6361: LIST
6362: LIST
6363: PUSH
6364: LD_INT 14
6366: PUSH
6367: LD_INT 1
6369: PUSH
6370: LD_INT 2
6372: PUSH
6373: LD_INT 26
6375: PUSH
6376: LD_INT 26
6378: PUSH
6379: LD_INT 29
6381: PUSH
6382: LD_INT 29
6384: PUSH
6385: EMPTY
6386: LIST
6387: LIST
6388: LIST
6389: LIST
6390: PUSH
6391: LD_OWVAR 67
6395: ARRAY
6396: PUSH
6397: EMPTY
6398: LIST
6399: LIST
6400: LIST
6401: LIST
6402: PUSH
6403: LD_INT 13
6405: PUSH
6406: LD_INT 1
6408: PUSH
6409: LD_INT 2
6411: PUSH
6412: LD_INT 26
6414: PUSH
6415: LD_INT 29
6417: PUSH
6418: LD_INT 29
6420: PUSH
6421: LD_INT 29
6423: PUSH
6424: EMPTY
6425: LIST
6426: LIST
6427: LIST
6428: LIST
6429: PUSH
6430: LD_OWVAR 67
6434: ARRAY
6435: PUSH
6436: EMPTY
6437: LIST
6438: LIST
6439: LIST
6440: LIST
6441: PUSH
6442: LD_INT 13
6444: PUSH
6445: LD_INT 1
6447: PUSH
6448: LD_INT 2
6450: PUSH
6451: LD_INT 29
6453: PUSH
6454: EMPTY
6455: LIST
6456: LIST
6457: LIST
6458: LIST
6459: PUSH
6460: LD_INT 14
6462: PUSH
6463: LD_INT 1
6465: PUSH
6466: LD_INT 2
6468: PUSH
6469: LD_INT 26
6471: PUSH
6472: EMPTY
6473: LIST
6474: LIST
6475: LIST
6476: LIST
6477: PUSH
6478: EMPTY
6479: LIST
6480: LIST
6481: LIST
6482: LIST
6483: LIST
6484: LIST
6485: PPUSH
6486: CALL 63846 0 2
// end ; wait ( 2 2$00 ) ;
6490: LD_INT 4200
6492: PPUSH
6493: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] , [ f_not , [ f_weapon , ar_crane ] ] ] ) diff mc_defender [ 3 ] ;
6497: LD_ADDR_VAR 0 2
6501: PUSH
6502: LD_INT 22
6504: PUSH
6505: LD_INT 8
6507: PUSH
6508: EMPTY
6509: LIST
6510: LIST
6511: PUSH
6512: LD_INT 21
6514: PUSH
6515: LD_INT 2
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: PUSH
6522: LD_INT 3
6524: PUSH
6525: LD_INT 34
6527: PUSH
6528: LD_INT 31
6530: PUSH
6531: EMPTY
6532: LIST
6533: LIST
6534: PUSH
6535: EMPTY
6536: LIST
6537: LIST
6538: PUSH
6539: LD_INT 3
6541: PUSH
6542: LD_INT 34
6544: PUSH
6545: LD_INT 32
6547: PUSH
6548: EMPTY
6549: LIST
6550: LIST
6551: PUSH
6552: EMPTY
6553: LIST
6554: LIST
6555: PUSH
6556: LD_INT 3
6558: PUSH
6559: LD_INT 34
6561: PUSH
6562: LD_INT 88
6564: PUSH
6565: EMPTY
6566: LIST
6567: LIST
6568: PUSH
6569: EMPTY
6570: LIST
6571: LIST
6572: PUSH
6573: EMPTY
6574: LIST
6575: LIST
6576: LIST
6577: LIST
6578: LIST
6579: PPUSH
6580: CALL_OW 69
6584: PUSH
6585: LD_EXP 124
6589: PUSH
6590: LD_INT 3
6592: ARRAY
6593: DIFF
6594: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6595: LD_ADDR_EXP 121
6599: PUSH
6600: LD_EXP 121
6604: PPUSH
6605: LD_INT 3
6607: PPUSH
6608: LD_EXP 121
6612: PUSH
6613: LD_INT 3
6615: ARRAY
6616: PUSH
6617: LD_VAR 0 2
6621: DIFF
6622: PPUSH
6623: CALL_OW 1
6627: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6628: LD_ADDR_VAR 0 3
6632: PUSH
6633: LD_INT 0
6635: PPUSH
6636: LD_INT 2
6638: PPUSH
6639: CALL_OW 12
6643: ST_TO_ADDR
// if target then
6644: LD_VAR 0 3
6648: IFFALSE 6806
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6650: LD_ADDR_VAR 0 2
6654: PUSH
6655: LD_VAR 0 2
6659: PPUSH
6660: LD_INT 50
6662: PUSH
6663: EMPTY
6664: LIST
6665: PPUSH
6666: CALL_OW 72
6670: ST_TO_ADDR
// if not tmp then
6671: LD_VAR 0 2
6675: NOT
6676: IFFALSE 6680
// break ;
6678: GO 6804
// for i in tmp do
6680: LD_ADDR_VAR 0 1
6684: PUSH
6685: LD_VAR 0 2
6689: PUSH
6690: FOR_IN
6691: IFFALSE 6731
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6693: LD_VAR 0 1
6697: PPUSH
6698: LD_INT 89
6700: PPUSH
6701: LD_INT 71
6703: PPUSH
6704: CALL_OW 297
6708: PUSH
6709: LD_INT 9
6711: GREATER
6712: IFFALSE 6729
// ComMoveXY ( i , 89 , 71 ) ;
6714: LD_VAR 0 1
6718: PPUSH
6719: LD_INT 89
6721: PPUSH
6722: LD_INT 71
6724: PPUSH
6725: CALL_OW 111
6729: GO 6690
6731: POP
6732: POP
// wait ( 0 0$1 ) ;
6733: LD_INT 35
6735: PPUSH
6736: CALL_OW 67
// p := Inc ( p ) ;
6740: LD_ADDR_VAR 0 4
6744: PUSH
6745: LD_VAR 0 4
6749: PPUSH
6750: CALL 109365 0 1
6754: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6755: LD_VAR 0 2
6759: PPUSH
6760: LD_INT 92
6762: PUSH
6763: LD_INT 89
6765: PUSH
6766: LD_INT 71
6768: PUSH
6769: LD_INT 9
6771: PUSH
6772: EMPTY
6773: LIST
6774: LIST
6775: LIST
6776: LIST
6777: PPUSH
6778: CALL_OW 72
6782: PUSH
6783: LD_VAR 0 2
6787: PUSH
6788: LD_INT 1
6790: MINUS
6791: GREATEREQUAL
6792: PUSH
6793: LD_VAR 0 4
6797: PUSH
6798: LD_INT 30
6800: GREATER
6801: OR
6802: IFFALSE 6650
// end else
6804: GO 6960
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6806: LD_ADDR_VAR 0 2
6810: PUSH
6811: LD_VAR 0 2
6815: PPUSH
6816: LD_INT 50
6818: PUSH
6819: EMPTY
6820: LIST
6821: PPUSH
6822: CALL_OW 72
6826: ST_TO_ADDR
// if not tmp then
6827: LD_VAR 0 2
6831: NOT
6832: IFFALSE 6836
// break ;
6834: GO 6960
// for i in tmp do
6836: LD_ADDR_VAR 0 1
6840: PUSH
6841: LD_VAR 0 2
6845: PUSH
6846: FOR_IN
6847: IFFALSE 6887
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6849: LD_VAR 0 1
6853: PPUSH
6854: LD_INT 125
6856: PPUSH
6857: LD_INT 129
6859: PPUSH
6860: CALL_OW 297
6864: PUSH
6865: LD_INT 9
6867: GREATER
6868: IFFALSE 6885
// ComMoveXY ( i , 125 , 129 ) ;
6870: LD_VAR 0 1
6874: PPUSH
6875: LD_INT 125
6877: PPUSH
6878: LD_INT 129
6880: PPUSH
6881: CALL_OW 111
6885: GO 6846
6887: POP
6888: POP
// wait ( 0 0$1 ) ;
6889: LD_INT 35
6891: PPUSH
6892: CALL_OW 67
// p := Inc ( p ) ;
6896: LD_ADDR_VAR 0 4
6900: PUSH
6901: LD_VAR 0 4
6905: PPUSH
6906: CALL 109365 0 1
6910: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6911: LD_VAR 0 2
6915: PPUSH
6916: LD_INT 92
6918: PUSH
6919: LD_INT 125
6921: PUSH
6922: LD_INT 129
6924: PUSH
6925: LD_INT 9
6927: PUSH
6928: EMPTY
6929: LIST
6930: LIST
6931: LIST
6932: LIST
6933: PPUSH
6934: CALL_OW 72
6938: PUSH
6939: LD_VAR 0 2
6943: PUSH
6944: LD_INT 1
6946: MINUS
6947: GREATEREQUAL
6948: PUSH
6949: LD_VAR 0 4
6953: PUSH
6954: LD_INT 30
6956: GREATER
6957: OR
6958: IFFALSE 6806
// end ; repeat wait ( 0 0$1 ) ;
6960: LD_INT 35
6962: PPUSH
6963: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6967: LD_ADDR_VAR 0 2
6971: PUSH
6972: LD_VAR 0 2
6976: PPUSH
6977: LD_INT 50
6979: PUSH
6980: EMPTY
6981: LIST
6982: PPUSH
6983: CALL_OW 72
6987: ST_TO_ADDR
// for i in tmp do
6988: LD_ADDR_VAR 0 1
6992: PUSH
6993: LD_VAR 0 2
6997: PUSH
6998: FOR_IN
6999: IFFALSE 7037
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7001: LD_VAR 0 1
7005: PPUSH
7006: LD_INT 81
7008: PUSH
7009: LD_INT 8
7011: PUSH
7012: EMPTY
7013: LIST
7014: LIST
7015: PPUSH
7016: CALL_OW 69
7020: PPUSH
7021: LD_VAR 0 1
7025: PPUSH
7026: CALL_OW 74
7030: PPUSH
7031: CALL_OW 115
7035: GO 6998
7037: POP
7038: POP
// until not tmp ;
7039: LD_VAR 0 2
7043: NOT
7044: IFFALSE 6960
// end ;
7046: PPOPN 4
7048: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
7049: LD_EXP 22
7053: NOT
7054: PUSH
7055: LD_EXP 15
7059: PUSH
7060: LD_INT 6
7062: GREATEREQUAL
7063: AND
7064: PUSH
7065: LD_OWVAR 67
7069: PUSH
7070: LD_INT 1
7072: GREATER
7073: AND
7074: IFFALSE 7607
7076: GO 7078
7078: DISABLE
7079: LD_INT 0
7081: PPUSH
7082: PPUSH
7083: PPUSH
// begin enable ;
7084: ENABLE
// tmp := [ ] ;
7085: LD_ADDR_VAR 0 3
7089: PUSH
7090: EMPTY
7091: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
7092: LD_ADDR_VAR 0 1
7096: PUSH
7097: DOUBLE
7098: LD_INT 1
7100: DEC
7101: ST_TO_ADDR
7102: LD_INT 4
7104: PUSH
7105: LD_INT 6
7107: PUSH
7108: LD_INT 7
7110: PUSH
7111: LD_INT 8
7113: PUSH
7114: EMPTY
7115: LIST
7116: LIST
7117: LIST
7118: LIST
7119: PUSH
7120: LD_OWVAR 67
7124: ARRAY
7125: PUSH
7126: FOR_TO
7127: IFFALSE 7287
// begin uc_side := 8 ;
7129: LD_ADDR_OWVAR 20
7133: PUSH
7134: LD_INT 8
7136: ST_TO_ADDR
// uc_nation := 2 ;
7137: LD_ADDR_OWVAR 21
7141: PUSH
7142: LD_INT 2
7144: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
7145: LD_INT 13
7147: PUSH
7148: LD_INT 14
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: PUSH
7155: LD_INT 1
7157: PPUSH
7158: LD_INT 2
7160: PPUSH
7161: CALL_OW 12
7165: ARRAY
7166: PPUSH
7167: LD_INT 1
7169: PPUSH
7170: LD_INT 5
7172: PPUSH
7173: LD_INT 27
7175: PUSH
7176: LD_INT 28
7178: PUSH
7179: LD_INT 26
7181: PUSH
7182: LD_INT 25
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: LIST
7189: LIST
7190: PUSH
7191: LD_INT 1
7193: PPUSH
7194: LD_INT 4
7196: PPUSH
7197: CALL_OW 12
7201: ARRAY
7202: PPUSH
7203: LD_INT 88
7205: PPUSH
7206: CALL 75133 0 5
// un := CreateVehicle ;
7210: LD_ADDR_VAR 0 2
7214: PUSH
7215: CALL_OW 45
7219: ST_TO_ADDR
// tmp := tmp ^ un ;
7220: LD_ADDR_VAR 0 3
7224: PUSH
7225: LD_VAR 0 3
7229: PUSH
7230: LD_VAR 0 2
7234: ADD
7235: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7236: LD_VAR 0 2
7240: PPUSH
7241: LD_INT 3
7243: PPUSH
7244: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7248: LD_VAR 0 2
7252: PPUSH
7253: LD_INT 30
7255: PPUSH
7256: LD_INT 0
7258: PPUSH
7259: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7263: LD_VAR 0 2
7267: PPUSH
7268: LD_INT 16
7270: PPUSH
7271: LD_INT 11
7273: PPUSH
7274: CALL_OW 111
// wait ( 0 0$2 ) ;
7278: LD_INT 70
7280: PPUSH
7281: CALL_OW 67
// end ;
7285: GO 7126
7287: POP
7288: POP
// for i = 1 to Difficulty do
7289: LD_ADDR_VAR 0 1
7293: PUSH
7294: DOUBLE
7295: LD_INT 1
7297: DEC
7298: ST_TO_ADDR
7299: LD_OWVAR 67
7303: PUSH
7304: FOR_TO
7305: IFFALSE 7434
// begin uc_side := 8 ;
7307: LD_ADDR_OWVAR 20
7311: PUSH
7312: LD_INT 8
7314: ST_TO_ADDR
// uc_nation := 2 ;
7315: LD_ADDR_OWVAR 21
7319: PUSH
7320: LD_INT 2
7322: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
7323: LD_INT 0
7325: PPUSH
7326: LD_INT 8
7328: PPUSH
7329: LD_INT 8
7331: PUSH
7332: LD_INT 8
7334: PUSH
7335: LD_INT 9
7337: PUSH
7338: LD_INT 10
7340: PUSH
7341: EMPTY
7342: LIST
7343: LIST
7344: LIST
7345: LIST
7346: PUSH
7347: LD_OWVAR 67
7351: ARRAY
7352: PPUSH
7353: CALL_OW 380
// un := CreateHuman ;
7357: LD_ADDR_VAR 0 2
7361: PUSH
7362: CALL_OW 44
7366: ST_TO_ADDR
// tmp := tmp ^ un ;
7367: LD_ADDR_VAR 0 3
7371: PUSH
7372: LD_VAR 0 3
7376: PUSH
7377: LD_VAR 0 2
7381: ADD
7382: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7383: LD_VAR 0 2
7387: PPUSH
7388: LD_INT 3
7390: PPUSH
7391: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7395: LD_VAR 0 2
7399: PPUSH
7400: LD_INT 30
7402: PPUSH
7403: LD_INT 0
7405: PPUSH
7406: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7410: LD_VAR 0 2
7414: PPUSH
7415: LD_INT 16
7417: PPUSH
7418: LD_INT 11
7420: PPUSH
7421: CALL_OW 111
// wait ( 0 0$2 ) ;
7425: LD_INT 70
7427: PPUSH
7428: CALL_OW 67
// end ;
7432: GO 7304
7434: POP
7435: POP
// repeat wait ( 0 0$1 ) ;
7436: LD_INT 35
7438: PPUSH
7439: CALL_OW 67
// if legionDestroyed then
7443: LD_EXP 22
7447: IFFALSE 7451
// exit ;
7449: GO 7607
// for i in tmp do
7451: LD_ADDR_VAR 0 1
7455: PUSH
7456: LD_VAR 0 3
7460: PUSH
7461: FOR_IN
7462: IFFALSE 7598
// begin if GetLives ( i ) > 250 then
7464: LD_VAR 0 1
7468: PPUSH
7469: CALL_OW 256
7473: PUSH
7474: LD_INT 250
7476: GREATER
7477: IFFALSE 7569
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
7479: LD_INT 81
7481: PUSH
7482: LD_INT 8
7484: PUSH
7485: EMPTY
7486: LIST
7487: LIST
7488: PUSH
7489: LD_INT 91
7491: PUSH
7492: LD_VAR 0 1
7496: PUSH
7497: LD_INT 10
7499: PUSH
7500: EMPTY
7501: LIST
7502: LIST
7503: LIST
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PPUSH
7509: CALL_OW 69
7513: NOT
7514: IFFALSE 7533
// ComAgressiveMove ( i , 67 , 110 ) else
7516: LD_VAR 0 1
7520: PPUSH
7521: LD_INT 67
7523: PPUSH
7524: LD_INT 110
7526: PPUSH
7527: CALL_OW 114
7531: GO 7567
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7533: LD_VAR 0 1
7537: PPUSH
7538: LD_INT 81
7540: PUSH
7541: LD_INT 8
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: PPUSH
7548: CALL_OW 69
7552: PPUSH
7553: LD_VAR 0 1
7557: PPUSH
7558: CALL_OW 74
7562: PPUSH
7563: CALL_OW 115
// end else
7567: GO 7596
// if IsDead ( i ) then
7569: LD_VAR 0 1
7573: PPUSH
7574: CALL_OW 301
7578: IFFALSE 7596
// tmp := tmp diff i ;
7580: LD_ADDR_VAR 0 3
7584: PUSH
7585: LD_VAR 0 3
7589: PUSH
7590: LD_VAR 0 1
7594: DIFF
7595: ST_TO_ADDR
// end ;
7596: GO 7461
7598: POP
7599: POP
// until not tmp ;
7600: LD_VAR 0 3
7604: NOT
7605: IFFALSE 7436
// end ; end_of_file
7607: PPOPN 3
7609: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
7610: LD_INT 0
7612: PPUSH
7613: PPUSH
7614: PPUSH
7615: PPUSH
7616: PPUSH
7617: PPUSH
7618: PPUSH
7619: PPUSH
7620: PPUSH
7621: PPUSH
// side := 3 ;
7622: LD_ADDR_VAR 0 6
7626: PUSH
7627: LD_INT 3
7629: ST_TO_ADDR
// uc_side := side ;
7630: LD_ADDR_OWVAR 20
7634: PUSH
7635: LD_VAR 0 6
7639: ST_TO_ADDR
// uc_nation := 3 ;
7640: LD_ADDR_OWVAR 21
7644: PUSH
7645: LD_INT 3
7647: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7648: LD_ADDR_VAR 0 2
7652: PUSH
7653: LD_INT 22
7655: PUSH
7656: LD_VAR 0 6
7660: PUSH
7661: EMPTY
7662: LIST
7663: LIST
7664: PUSH
7665: LD_INT 21
7667: PUSH
7668: LD_INT 3
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: PUSH
7675: EMPTY
7676: LIST
7677: LIST
7678: PPUSH
7679: CALL_OW 69
7683: PUSH
7684: FOR_IN
7685: IFFALSE 7701
// SetBLevel ( i , 10 ) ;
7687: LD_VAR 0 2
7691: PPUSH
7692: LD_INT 10
7694: PPUSH
7695: CALL_OW 241
7699: GO 7684
7701: POP
7702: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7703: LD_ADDR_VAR 0 10
7707: PUSH
7708: LD_INT 22
7710: PUSH
7711: LD_VAR 0 6
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: PUSH
7720: LD_INT 30
7722: PUSH
7723: LD_INT 34
7725: PUSH
7726: EMPTY
7727: LIST
7728: LIST
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: PPUSH
7734: CALL_OW 69
7738: ST_TO_ADDR
// if teleport then
7739: LD_VAR 0 10
7743: IFFALSE 7764
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7745: LD_VAR 0 10
7749: PUSH
7750: LD_INT 1
7752: ARRAY
7753: PPUSH
7754: LD_INT 123
7756: PPUSH
7757: LD_INT 122
7759: PPUSH
7760: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7764: LD_ADDR_EXP 68
7768: PUSH
7769: LD_STRING Platonov
7771: PPUSH
7772: CALL_OW 25
7776: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7777: LD_ADDR_EXP 69
7781: PUSH
7782: LD_STRING Kovalyuk
7784: PPUSH
7785: CALL_OW 25
7789: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7790: LD_ADDR_EXP 71
7794: PUSH
7795: LD_STRING Yakotich
7797: PPUSH
7798: LD_EXP 1
7802: NOT
7803: PPUSH
7804: LD_STRING 09_
7806: PPUSH
7807: CALL 70272 0 3
7811: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7812: LD_ADDR_EXP 70
7816: PUSH
7817: LD_STRING Bystrov
7819: PPUSH
7820: CALL_OW 25
7824: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7825: LD_ADDR_EXP 72
7829: PUSH
7830: LD_STRING Gleb
7832: PPUSH
7833: CALL_OW 25
7837: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7838: LD_STRING 03_Cornel
7840: PPUSH
7841: CALL_OW 28
7845: IFFALSE 7893
// begin Bierezov := NewCharacter ( Mikhail ) ;
7847: LD_ADDR_EXP 73
7851: PUSH
7852: LD_STRING Mikhail
7854: PPUSH
7855: CALL_OW 25
7859: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7860: LD_EXP 73
7864: PPUSH
7865: LD_INT 197
7867: PPUSH
7868: LD_INT 111
7870: PPUSH
7871: LD_INT 9
7873: PPUSH
7874: LD_INT 0
7876: PPUSH
7877: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7881: LD_EXP 73
7885: PPUSH
7886: LD_INT 3
7888: PPUSH
7889: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7893: LD_EXP 68
7897: PPUSH
7898: LD_INT 126
7900: PPUSH
7901: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7905: LD_EXP 69
7909: PPUSH
7910: LD_INT 134
7912: PPUSH
7913: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7917: LD_EXP 71
7921: PPUSH
7922: LD_INT 197
7924: PPUSH
7925: LD_INT 111
7927: PPUSH
7928: LD_INT 9
7930: PPUSH
7931: LD_INT 0
7933: PPUSH
7934: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7938: LD_EXP 70
7942: PPUSH
7943: LD_INT 197
7945: PPUSH
7946: LD_INT 111
7948: PPUSH
7949: LD_INT 9
7951: PPUSH
7952: LD_INT 0
7954: PPUSH
7955: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7959: LD_EXP 72
7963: PPUSH
7964: LD_INT 197
7966: PPUSH
7967: LD_INT 111
7969: PPUSH
7970: LD_INT 9
7972: PPUSH
7973: LD_INT 0
7975: PPUSH
7976: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 12 , 6 ] ) ;
7980: LD_ADDR_VAR 0 5
7984: PUSH
7985: LD_INT 126
7987: PPUSH
7988: LD_INT 4
7990: PPUSH
7991: LD_STRING zhukov
7993: PPUSH
7994: LD_INT 9
7996: PUSH
7997: LD_INT 10
7999: PUSH
8000: LD_INT 10
8002: PUSH
8003: LD_INT 10
8005: PUSH
8006: EMPTY
8007: LIST
8008: LIST
8009: LIST
8010: LIST
8011: PUSH
8012: LD_OWVAR 67
8016: ARRAY
8017: PPUSH
8018: LD_INT 90000
8020: PUSH
8021: LD_INT 1000
8023: PUSH
8024: LD_INT 300
8026: PUSH
8027: EMPTY
8028: LIST
8029: LIST
8030: LIST
8031: PPUSH
8032: LD_INT 18
8034: PUSH
8035: LD_INT 8
8037: PUSH
8038: LD_INT 12
8040: PUSH
8041: LD_INT 6
8043: PUSH
8044: EMPTY
8045: LIST
8046: LIST
8047: LIST
8048: LIST
8049: PPUSH
8050: CALL 78954 0 6
8054: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Bystrov , Gleb , Bierezov ] ) ;
8055: LD_ADDR_EXP 102
8059: PUSH
8060: LD_EXP 102
8064: PPUSH
8065: LD_INT 2
8067: PPUSH
8068: LD_VAR 0 5
8072: PUSH
8073: LD_EXP 71
8077: PUSH
8078: LD_EXP 70
8082: PUSH
8083: LD_EXP 72
8087: PUSH
8088: LD_EXP 73
8092: PUSH
8093: EMPTY
8094: LIST
8095: LIST
8096: LIST
8097: LIST
8098: UNION
8099: PPUSH
8100: CALL_OW 1
8104: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8105: LD_ADDR_VAR 0 4
8109: PUSH
8110: LD_INT 267
8112: PPUSH
8113: CALL_OW 274
8117: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8118: LD_VAR 0 4
8122: PPUSH
8123: LD_INT 1
8125: PPUSH
8126: LD_INT 5000
8128: PPUSH
8129: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8133: LD_VAR 0 4
8137: PPUSH
8138: LD_INT 2
8140: PPUSH
8141: LD_INT 200
8143: PPUSH
8144: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8148: LD_VAR 0 4
8152: PPUSH
8153: LD_INT 3
8155: PPUSH
8156: LD_INT 200
8158: PPUSH
8159: CALL_OW 277
// for i := 1 to 6 do
8163: LD_ADDR_VAR 0 2
8167: PUSH
8168: DOUBLE
8169: LD_INT 1
8171: DEC
8172: ST_TO_ADDR
8173: LD_INT 6
8175: PUSH
8176: FOR_TO
8177: IFFALSE 8260
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
8179: LD_INT 0
8181: PPUSH
8182: LD_INT 8
8184: PUSH
8185: LD_INT 9
8187: PUSH
8188: LD_INT 10
8190: PUSH
8191: LD_INT 10
8193: PUSH
8194: EMPTY
8195: LIST
8196: LIST
8197: LIST
8198: LIST
8199: PUSH
8200: LD_OWVAR 67
8204: ARRAY
8205: PPUSH
8206: CALL_OW 381
// un := CreateHuman ;
8210: LD_ADDR_VAR 0 8
8214: PUSH
8215: CALL_OW 44
8219: ST_TO_ADDR
// if i mod 2 = 0 then
8220: LD_VAR 0 2
8224: PUSH
8225: LD_INT 2
8227: MOD
8228: PUSH
8229: LD_INT 0
8231: EQUAL
8232: IFFALSE 8246
// SetClass ( un , class_bazooker ) ;
8234: LD_VAR 0 8
8238: PPUSH
8239: LD_INT 9
8241: PPUSH
8242: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
8246: LD_VAR 0 8
8250: PPUSH
8251: LD_INT 460
8253: PPUSH
8254: CALL_OW 52
// end ;
8258: GO 8176
8260: POP
8261: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
8262: LD_INT 21
8264: PPUSH
8265: LD_INT 3
8267: PPUSH
8268: LD_INT 3
8270: PPUSH
8271: LD_INT 52
8273: PPUSH
8274: LD_INT 100
8276: PPUSH
8277: CALL 75133 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
8281: CALL_OW 45
8285: PPUSH
8286: LD_INT 259
8288: PPUSH
8289: LD_INT 145
8291: PPUSH
8292: LD_INT 3
8294: PPUSH
8295: LD_INT 0
8297: PPUSH
8298: CALL 110144 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
8302: CALL_OW 45
8306: PPUSH
8307: LD_INT 245
8309: PPUSH
8310: LD_INT 139
8312: PPUSH
8313: LD_INT 3
8315: PPUSH
8316: LD_INT 0
8318: PPUSH
8319: CALL 110144 0 5
// behemoths := [ ] ;
8323: LD_ADDR_EXP 76
8327: PUSH
8328: EMPTY
8329: ST_TO_ADDR
// behemothBuilders := [ ] ;
8330: LD_ADDR_EXP 77
8334: PUSH
8335: EMPTY
8336: ST_TO_ADDR
// if Kovalyuk then
8337: LD_EXP 69
8341: IFFALSE 8363
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
8343: LD_ADDR_EXP 77
8347: PUSH
8348: LD_EXP 77
8352: PPUSH
8353: LD_EXP 69
8357: PPUSH
8358: CALL 108004 0 2
8362: ST_TO_ADDR
// end ;
8363: LD_VAR 0 1
8367: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8368: LD_INT 0
8370: PPUSH
8371: PPUSH
8372: PPUSH
8373: PPUSH
8374: PPUSH
// xy := [ [ 221 , 154 ] , [ 223 , 149 ] , [ 228 , 147 ] , [ 232 , 155 ] ] ;
8375: LD_ADDR_VAR 0 4
8379: PUSH
8380: LD_INT 221
8382: PUSH
8383: LD_INT 154
8385: PUSH
8386: EMPTY
8387: LIST
8388: LIST
8389: PUSH
8390: LD_INT 223
8392: PUSH
8393: LD_INT 149
8395: PUSH
8396: EMPTY
8397: LIST
8398: LIST
8399: PUSH
8400: LD_INT 228
8402: PUSH
8403: LD_INT 147
8405: PUSH
8406: EMPTY
8407: LIST
8408: LIST
8409: PUSH
8410: LD_INT 232
8412: PUSH
8413: LD_INT 155
8415: PUSH
8416: EMPTY
8417: LIST
8418: LIST
8419: PUSH
8420: EMPTY
8421: LIST
8422: LIST
8423: LIST
8424: LIST
8425: ST_TO_ADDR
// if not behemothBuilders then
8426: LD_EXP 77
8430: NOT
8431: IFFALSE 8435
// exit ;
8433: GO 8566
// j := 1 ;
8435: LD_ADDR_VAR 0 3
8439: PUSH
8440: LD_INT 1
8442: ST_TO_ADDR
// for i in behemothBuilders do
8443: LD_ADDR_VAR 0 2
8447: PUSH
8448: LD_EXP 77
8452: PUSH
8453: FOR_IN
8454: IFFALSE 8564
// begin if GetClass ( i ) <> class_mechanic then
8456: LD_VAR 0 2
8460: PPUSH
8461: CALL_OW 257
8465: PUSH
8466: LD_INT 3
8468: NONEQUAL
8469: IFFALSE 8483
// SetClass ( i , class_mechanic ) ;
8471: LD_VAR 0 2
8475: PPUSH
8476: LD_INT 3
8478: PPUSH
8479: CALL_OW 336
// if IsInUnit ( i ) then
8483: LD_VAR 0 2
8487: PPUSH
8488: CALL_OW 310
8492: IFFALSE 8503
// ComExitBuilding ( i ) ;
8494: LD_VAR 0 2
8498: PPUSH
8499: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8503: LD_VAR 0 2
8507: PPUSH
8508: LD_INT 37
8510: PPUSH
8511: LD_VAR 0 4
8515: PUSH
8516: LD_VAR 0 3
8520: ARRAY
8521: PUSH
8522: LD_INT 1
8524: ARRAY
8525: PPUSH
8526: LD_VAR 0 4
8530: PUSH
8531: LD_VAR 0 3
8535: ARRAY
8536: PUSH
8537: LD_INT 2
8539: ARRAY
8540: PPUSH
8541: LD_INT 0
8543: PPUSH
8544: CALL_OW 230
// j := j + 1 ;
8548: LD_ADDR_VAR 0 3
8552: PUSH
8553: LD_VAR 0 3
8557: PUSH
8558: LD_INT 1
8560: PLUS
8561: ST_TO_ADDR
// end ;
8562: GO 8453
8564: POP
8565: POP
// end ;
8566: LD_VAR 0 1
8570: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
8571: LD_INT 24
8573: PPUSH
8574: LD_INT 30
8576: PUSH
8577: LD_INT 37
8579: PUSH
8580: EMPTY
8581: LIST
8582: LIST
8583: PPUSH
8584: CALL_OW 70
8588: IFFALSE 8601
8590: GO 8592
8592: DISABLE
// behemothUnderConstruct := true ;
8593: LD_ADDR_EXP 26
8597: PUSH
8598: LD_INT 1
8600: ST_TO_ADDR
8601: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8602: LD_INT 3
8604: PPUSH
8605: CALL 108065 0 1
8609: PUSH
8610: LD_INT 22
8612: PUSH
8613: LD_INT 3
8615: PUSH
8616: EMPTY
8617: LIST
8618: LIST
8619: PUSH
8620: LD_INT 30
8622: PUSH
8623: LD_INT 37
8625: PUSH
8626: EMPTY
8627: LIST
8628: LIST
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: PPUSH
8634: CALL_OW 69
8638: NOT
8639: AND
8640: IFFALSE 8826
8642: GO 8644
8644: DISABLE
8645: LD_INT 0
8647: PPUSH
8648: PPUSH
// begin enable ;
8649: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8650: LD_ADDR_VAR 0 2
8654: PUSH
8655: LD_INT 3
8657: PPUSH
8658: CALL 108065 0 1
8662: ST_TO_ADDR
// for i in tmp do
8663: LD_ADDR_VAR 0 1
8667: PUSH
8668: LD_VAR 0 2
8672: PUSH
8673: FOR_IN
8674: IFFALSE 8824
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8676: LD_VAR 0 1
8680: PPUSH
8681: LD_INT 9
8683: PPUSH
8684: CALL_OW 308
8688: PUSH
8689: LD_VAR 0 1
8693: PPUSH
8694: CALL_OW 110
8698: PUSH
8699: LD_INT 2
8701: EQUAL
8702: NOT
8703: AND
8704: IFFALSE 8718
// SetTag ( i , 2 ) ;
8706: LD_VAR 0 1
8710: PPUSH
8711: LD_INT 2
8713: PPUSH
8714: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8718: LD_INT 81
8720: PUSH
8721: LD_INT 3
8723: PUSH
8724: EMPTY
8725: LIST
8726: LIST
8727: PUSH
8728: LD_INT 91
8730: PUSH
8731: LD_VAR 0 1
8735: PUSH
8736: LD_INT 12
8738: PUSH
8739: EMPTY
8740: LIST
8741: LIST
8742: LIST
8743: PUSH
8744: EMPTY
8745: LIST
8746: LIST
8747: PPUSH
8748: CALL_OW 69
8752: NOT
8753: PUSH
8754: LD_VAR 0 1
8758: PPUSH
8759: CALL_OW 110
8763: PUSH
8764: LD_INT 2
8766: EQUAL
8767: NOT
8768: AND
8769: IFFALSE 8788
// ComAgressiveMove ( i , 64 , 93 ) else
8771: LD_VAR 0 1
8775: PPUSH
8776: LD_INT 64
8778: PPUSH
8779: LD_INT 93
8781: PPUSH
8782: CALL_OW 114
8786: GO 8822
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8788: LD_VAR 0 1
8792: PPUSH
8793: LD_INT 81
8795: PUSH
8796: LD_INT 3
8798: PUSH
8799: EMPTY
8800: LIST
8801: LIST
8802: PPUSH
8803: CALL_OW 69
8807: PPUSH
8808: LD_VAR 0 1
8812: PPUSH
8813: CALL_OW 74
8817: PPUSH
8818: CALL_OW 115
// end ;
8822: GO 8673
8824: POP
8825: POP
// end ;
8826: PPOPN 2
8828: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8829: LD_INT 0
8831: PPUSH
8832: PPUSH
8833: PPUSH
// result := [ ] ;
8834: LD_ADDR_VAR 0 2
8838: PUSH
8839: EMPTY
8840: ST_TO_ADDR
// uc_side := 6 ;
8841: LD_ADDR_OWVAR 20
8845: PUSH
8846: LD_INT 6
8848: ST_TO_ADDR
// uc_nation := 3 ;
8849: LD_ADDR_OWVAR 21
8853: PUSH
8854: LD_INT 3
8856: ST_TO_ADDR
// case strength of 1 :
8857: LD_VAR 0 1
8861: PUSH
8862: LD_INT 1
8864: DOUBLE
8865: EQUAL
8866: IFTRUE 8870
8868: GO 9012
8870: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8871: LD_ADDR_VAR 0 3
8875: PUSH
8876: DOUBLE
8877: LD_INT 1
8879: DEC
8880: ST_TO_ADDR
8881: LD_INT 4
8883: PUSH
8884: LD_INT 5
8886: PUSH
8887: LD_INT 6
8889: PUSH
8890: LD_INT 7
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: LIST
8897: LIST
8898: PUSH
8899: LD_OWVAR 67
8903: ARRAY
8904: PUSH
8905: FOR_TO
8906: IFFALSE 9008
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8908: LD_INT 22
8910: PUSH
8911: LD_INT 24
8913: PUSH
8914: EMPTY
8915: LIST
8916: LIST
8917: PUSH
8918: LD_VAR 0 3
8922: PUSH
8923: LD_INT 2
8925: MOD
8926: PUSH
8927: LD_INT 1
8929: PLUS
8930: ARRAY
8931: PPUSH
8932: LD_INT 1
8934: PUSH
8935: LD_INT 3
8937: PUSH
8938: EMPTY
8939: LIST
8940: LIST
8941: PUSH
8942: LD_INT 1
8944: PPUSH
8945: LD_INT 2
8947: PPUSH
8948: CALL_OW 12
8952: ARRAY
8953: PPUSH
8954: LD_INT 3
8956: PPUSH
8957: LD_INT 43
8959: PUSH
8960: LD_INT 44
8962: PUSH
8963: LD_INT 45
8965: PUSH
8966: EMPTY
8967: LIST
8968: LIST
8969: LIST
8970: PUSH
8971: LD_INT 1
8973: PPUSH
8974: LD_INT 3
8976: PPUSH
8977: CALL_OW 12
8981: ARRAY
8982: PPUSH
8983: LD_INT 80
8985: PPUSH
8986: CALL 75133 0 5
// result := result union CreateVehicle ;
8990: LD_ADDR_VAR 0 2
8994: PUSH
8995: LD_VAR 0 2
8999: PUSH
9000: CALL_OW 45
9004: UNION
9005: ST_TO_ADDR
// end ;
9006: GO 8905
9008: POP
9009: POP
// end ; 2 :
9010: GO 10007
9012: LD_INT 2
9014: DOUBLE
9015: EQUAL
9016: IFTRUE 9020
9018: GO 9188
9020: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
9021: LD_ADDR_VAR 0 3
9025: PUSH
9026: DOUBLE
9027: LD_INT 1
9029: DEC
9030: ST_TO_ADDR
9031: LD_INT 5
9033: PUSH
9034: LD_INT 6
9036: PUSH
9037: LD_INT 7
9039: PUSH
9040: LD_INT 8
9042: PUSH
9043: EMPTY
9044: LIST
9045: LIST
9046: LIST
9047: LIST
9048: PUSH
9049: LD_OWVAR 67
9053: ARRAY
9054: PUSH
9055: FOR_TO
9056: IFFALSE 9184
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
9058: LD_INT 22
9060: PUSH
9061: LD_INT 24
9063: PUSH
9064: LD_INT 24
9066: PUSH
9067: EMPTY
9068: LIST
9069: LIST
9070: LIST
9071: PUSH
9072: LD_VAR 0 3
9076: PUSH
9077: LD_INT 3
9079: MOD
9080: PUSH
9081: LD_INT 1
9083: PLUS
9084: ARRAY
9085: PPUSH
9086: LD_INT 1
9088: PUSH
9089: LD_INT 3
9091: PUSH
9092: EMPTY
9093: LIST
9094: LIST
9095: PUSH
9096: LD_INT 1
9098: PPUSH
9099: LD_INT 2
9101: PPUSH
9102: CALL_OW 12
9106: ARRAY
9107: PPUSH
9108: LD_INT 3
9110: PPUSH
9111: LD_INT 43
9113: PUSH
9114: LD_INT 44
9116: PUSH
9117: LD_INT 45
9119: PUSH
9120: LD_INT 44
9122: PUSH
9123: LD_INT 46
9125: PUSH
9126: LD_INT 46
9128: PUSH
9129: LD_INT 49
9131: PUSH
9132: LD_INT 49
9134: PUSH
9135: EMPTY
9136: LIST
9137: LIST
9138: LIST
9139: LIST
9140: LIST
9141: LIST
9142: LIST
9143: LIST
9144: PUSH
9145: LD_VAR 0 3
9149: PUSH
9150: LD_INT 8
9152: MOD
9153: PUSH
9154: LD_INT 1
9156: PLUS
9157: ARRAY
9158: PPUSH
9159: LD_INT 80
9161: PPUSH
9162: CALL 75133 0 5
// result := result union CreateVehicle ;
9166: LD_ADDR_VAR 0 2
9170: PUSH
9171: LD_VAR 0 2
9175: PUSH
9176: CALL_OW 45
9180: UNION
9181: ST_TO_ADDR
// end ;
9182: GO 9055
9184: POP
9185: POP
// end ; 3 :
9186: GO 10007
9188: LD_INT 3
9190: DOUBLE
9191: EQUAL
9192: IFTRUE 9196
9194: GO 9368
9196: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
9197: LD_ADDR_VAR 0 3
9201: PUSH
9202: DOUBLE
9203: LD_INT 1
9205: DEC
9206: ST_TO_ADDR
9207: LD_INT 6
9209: PUSH
9210: LD_INT 7
9212: PUSH
9213: LD_INT 8
9215: PUSH
9216: LD_INT 9
9218: PUSH
9219: EMPTY
9220: LIST
9221: LIST
9222: LIST
9223: LIST
9224: PUSH
9225: LD_OWVAR 67
9229: ARRAY
9230: PUSH
9231: FOR_TO
9232: IFFALSE 9364
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9234: LD_INT 22
9236: PUSH
9237: LD_INT 24
9239: PUSH
9240: LD_INT 24
9242: PUSH
9243: EMPTY
9244: LIST
9245: LIST
9246: LIST
9247: PUSH
9248: LD_VAR 0 3
9252: PUSH
9253: LD_INT 3
9255: MOD
9256: PUSH
9257: LD_INT 1
9259: PLUS
9260: ARRAY
9261: PPUSH
9262: LD_INT 1
9264: PUSH
9265: LD_INT 3
9267: PUSH
9268: EMPTY
9269: LIST
9270: LIST
9271: PUSH
9272: LD_INT 1
9274: PPUSH
9275: LD_INT 2
9277: PPUSH
9278: CALL_OW 12
9282: ARRAY
9283: PPUSH
9284: LD_INT 3
9286: PPUSH
9287: LD_INT 43
9289: PUSH
9290: LD_INT 47
9292: PUSH
9293: LD_INT 45
9295: PUSH
9296: LD_INT 45
9298: PUSH
9299: LD_INT 46
9301: PUSH
9302: LD_INT 46
9304: PUSH
9305: LD_INT 49
9307: PUSH
9308: LD_INT 49
9310: PUSH
9311: LD_INT 49
9313: PUSH
9314: EMPTY
9315: LIST
9316: LIST
9317: LIST
9318: LIST
9319: LIST
9320: LIST
9321: LIST
9322: LIST
9323: LIST
9324: PUSH
9325: LD_VAR 0 3
9329: PUSH
9330: LD_INT 9
9332: MOD
9333: PUSH
9334: LD_INT 1
9336: PLUS
9337: ARRAY
9338: PPUSH
9339: LD_INT 80
9341: PPUSH
9342: CALL 75133 0 5
// result := result union CreateVehicle ;
9346: LD_ADDR_VAR 0 2
9350: PUSH
9351: LD_VAR 0 2
9355: PUSH
9356: CALL_OW 45
9360: UNION
9361: ST_TO_ADDR
// end ;
9362: GO 9231
9364: POP
9365: POP
// end ; 4 :
9366: GO 10007
9368: LD_INT 4
9370: DOUBLE
9371: EQUAL
9372: IFTRUE 9376
9374: GO 10006
9376: POP
// begin uc_nation := 3 ;
9377: LD_ADDR_OWVAR 21
9381: PUSH
9382: LD_INT 3
9384: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
9385: LD_ADDR_VAR 0 3
9389: PUSH
9390: DOUBLE
9391: LD_INT 1
9393: DEC
9394: ST_TO_ADDR
9395: LD_INT 6
9397: PUSH
9398: LD_INT 8
9400: PUSH
9401: LD_INT 9
9403: PUSH
9404: LD_INT 10
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: LIST
9411: LIST
9412: PUSH
9413: LD_OWVAR 67
9417: ARRAY
9418: PUSH
9419: FOR_TO
9420: IFFALSE 9552
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9422: LD_INT 22
9424: PUSH
9425: LD_INT 24
9427: PUSH
9428: LD_INT 24
9430: PUSH
9431: EMPTY
9432: LIST
9433: LIST
9434: LIST
9435: PUSH
9436: LD_VAR 0 3
9440: PUSH
9441: LD_INT 3
9443: MOD
9444: PUSH
9445: LD_INT 1
9447: PLUS
9448: ARRAY
9449: PPUSH
9450: LD_INT 1
9452: PUSH
9453: LD_INT 3
9455: PUSH
9456: EMPTY
9457: LIST
9458: LIST
9459: PUSH
9460: LD_INT 1
9462: PPUSH
9463: LD_INT 2
9465: PPUSH
9466: CALL_OW 12
9470: ARRAY
9471: PPUSH
9472: LD_INT 3
9474: PPUSH
9475: LD_INT 45
9477: PUSH
9478: LD_INT 47
9480: PUSH
9481: LD_INT 47
9483: PUSH
9484: LD_INT 45
9486: PUSH
9487: LD_INT 46
9489: PUSH
9490: LD_INT 46
9492: PUSH
9493: LD_INT 49
9495: PUSH
9496: LD_INT 49
9498: PUSH
9499: LD_INT 49
9501: PUSH
9502: EMPTY
9503: LIST
9504: LIST
9505: LIST
9506: LIST
9507: LIST
9508: LIST
9509: LIST
9510: LIST
9511: LIST
9512: PUSH
9513: LD_VAR 0 3
9517: PUSH
9518: LD_INT 9
9520: MOD
9521: PUSH
9522: LD_INT 1
9524: PLUS
9525: ARRAY
9526: PPUSH
9527: LD_INT 80
9529: PPUSH
9530: CALL 75133 0 5
// result := result union CreateVehicle ;
9534: LD_ADDR_VAR 0 2
9538: PUSH
9539: LD_VAR 0 2
9543: PUSH
9544: CALL_OW 45
9548: UNION
9549: ST_TO_ADDR
// end ;
9550: GO 9419
9552: POP
9553: POP
// if not KappaStatus then
9554: LD_EXP 2
9558: NOT
9559: IFFALSE 9794
// begin uc_nation := 1 ;
9561: LD_ADDR_OWVAR 21
9565: PUSH
9566: LD_INT 1
9568: ST_TO_ADDR
// for i = 1 to 3 do
9569: LD_ADDR_VAR 0 3
9573: PUSH
9574: DOUBLE
9575: LD_INT 1
9577: DEC
9578: ST_TO_ADDR
9579: LD_INT 3
9581: PUSH
9582: FOR_TO
9583: IFFALSE 9719
// begin j := rand ( 0 , 1 ) ;
9585: LD_ADDR_VAR 0 4
9589: PUSH
9590: LD_INT 0
9592: PPUSH
9593: LD_INT 1
9595: PPUSH
9596: CALL_OW 12
9600: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9601: LD_INT 3
9603: PUSH
9604: LD_INT 5
9606: PUSH
9607: LD_INT 5
9609: PUSH
9610: LD_INT 4
9612: PUSH
9613: EMPTY
9614: LIST
9615: LIST
9616: LIST
9617: LIST
9618: PUSH
9619: LD_VAR 0 4
9623: PUSH
9624: LD_INT 1
9626: PPUSH
9627: LD_INT 3
9629: PPUSH
9630: CALL_OW 12
9634: PLUS
9635: ARRAY
9636: PPUSH
9637: LD_INT 1
9639: PUSH
9640: LD_INT 3
9642: PUSH
9643: EMPTY
9644: LIST
9645: LIST
9646: PUSH
9647: LD_INT 1
9649: PPUSH
9650: LD_INT 2
9652: PPUSH
9653: CALL_OW 12
9657: ARRAY
9658: PPUSH
9659: LD_INT 3
9661: PPUSH
9662: LD_INT 9
9664: PUSH
9665: LD_INT 7
9667: PUSH
9668: LD_INT 6
9670: PUSH
9671: EMPTY
9672: LIST
9673: LIST
9674: LIST
9675: PUSH
9676: LD_VAR 0 4
9680: PUSH
9681: LD_INT 1
9683: PPUSH
9684: LD_INT 2
9686: PPUSH
9687: CALL_OW 12
9691: PLUS
9692: ARRAY
9693: PPUSH
9694: LD_INT 85
9696: PPUSH
9697: CALL 75133 0 5
// result := result union CreateVehicle ;
9701: LD_ADDR_VAR 0 2
9705: PUSH
9706: LD_VAR 0 2
9710: PUSH
9711: CALL_OW 45
9715: UNION
9716: ST_TO_ADDR
// end ;
9717: GO 9582
9719: POP
9720: POP
// if vsevolodFirstAttack then
9721: LD_EXP 24
9725: IFFALSE 9792
// begin vsevolodFirstAttack := false ;
9727: LD_ADDR_EXP 24
9731: PUSH
9732: LD_INT 0
9734: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9735: LD_INT 5
9737: PPUSH
9738: LD_INT 3
9740: PPUSH
9741: LD_INT 1
9743: PPUSH
9744: LD_INT 6
9746: PPUSH
9747: LD_INT 100
9749: PPUSH
9750: CALL 75133 0 5
// sewiVeh := CreateVehicle ;
9754: LD_ADDR_EXP 75
9758: PUSH
9759: CALL_OW 45
9763: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9764: LD_EXP 75
9768: PPUSH
9769: LD_INT 1
9771: PPUSH
9772: CALL_OW 242
// result := result union sewiVeh ;
9776: LD_ADDR_VAR 0 2
9780: PUSH
9781: LD_VAR 0 2
9785: PUSH
9786: LD_EXP 75
9790: UNION
9791: ST_TO_ADDR
// end ; end else
9792: GO 10004
// if vsevolodFirstAttack then
9794: LD_EXP 24
9798: IFFALSE 10004
// begin vsevolodFirstAttack := false ;
9800: LD_ADDR_EXP 24
9804: PUSH
9805: LD_INT 0
9807: ST_TO_ADDR
// uc_nation := 3 ;
9808: LD_ADDR_OWVAR 21
9812: PUSH
9813: LD_INT 3
9815: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9816: LD_ADDR_VAR 0 3
9820: PUSH
9821: DOUBLE
9822: LD_INT 1
9824: DEC
9825: ST_TO_ADDR
9826: LD_INT 2
9828: PUSH
9829: LD_OWVAR 67
9833: PLUS
9834: PUSH
9835: FOR_TO
9836: IFFALSE 9944
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9838: LD_INT 22
9840: PUSH
9841: LD_INT 24
9843: PUSH
9844: LD_INT 24
9846: PUSH
9847: EMPTY
9848: LIST
9849: LIST
9850: LIST
9851: PUSH
9852: LD_VAR 0 3
9856: PUSH
9857: LD_INT 3
9859: MOD
9860: PUSH
9861: LD_INT 1
9863: PLUS
9864: ARRAY
9865: PPUSH
9866: LD_INT 1
9868: PUSH
9869: LD_INT 3
9871: PUSH
9872: EMPTY
9873: LIST
9874: LIST
9875: PUSH
9876: LD_INT 1
9878: PPUSH
9879: LD_INT 2
9881: PPUSH
9882: CALL_OW 12
9886: ARRAY
9887: PPUSH
9888: LD_INT 1
9890: PPUSH
9891: LD_INT 45
9893: PUSH
9894: LD_INT 47
9896: PUSH
9897: LD_INT 47
9899: PUSH
9900: EMPTY
9901: LIST
9902: LIST
9903: LIST
9904: PUSH
9905: LD_VAR 0 3
9909: PUSH
9910: LD_INT 3
9912: MOD
9913: PUSH
9914: LD_INT 1
9916: PLUS
9917: ARRAY
9918: PPUSH
9919: LD_INT 80
9921: PPUSH
9922: CALL 75133 0 5
// result := result union CreateVehicle ;
9926: LD_ADDR_VAR 0 2
9930: PUSH
9931: LD_VAR 0 2
9935: PUSH
9936: CALL_OW 45
9940: UNION
9941: ST_TO_ADDR
// end ;
9942: GO 9835
9944: POP
9945: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9946: LD_INT 24
9948: PPUSH
9949: LD_INT 3
9951: PPUSH
9952: LD_INT 1
9954: PPUSH
9955: LD_INT 47
9957: PPUSH
9958: LD_INT 100
9960: PPUSH
9961: CALL 75133 0 5
// sewiVeh := CreateVehicle ;
9965: LD_ADDR_EXP 75
9969: PUSH
9970: CALL_OW 45
9974: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9975: LD_EXP 75
9979: PPUSH
9980: LD_INT 6
9982: NEG
9983: PPUSH
9984: CALL_OW 242
// result := result union sewiVeh ;
9988: LD_ADDR_VAR 0 2
9992: PUSH
9993: LD_VAR 0 2
9997: PUSH
9998: LD_EXP 75
10002: UNION
10003: ST_TO_ADDR
// end ; end ; end ;
10004: GO 10007
10006: POP
// end ;
10007: LD_VAR 0 2
10011: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
10012: LD_EXP 16
10016: IFFALSE 10773
10018: GO 10020
10020: DISABLE
10021: LD_INT 0
10023: PPUSH
10024: PPUSH
10025: PPUSH
10026: PPUSH
10027: PPUSH
10028: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
10029: LD_ADDR_VAR 0 4
10033: PUSH
10034: LD_INT 11
10036: PUSH
10037: LD_INT 12
10039: PUSH
10040: EMPTY
10041: LIST
10042: LIST
10043: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
10044: LD_ADDR_VAR 0 3
10048: PUSH
10049: LD_INT 11550
10051: PUSH
10052: LD_INT 10150
10054: PUSH
10055: LD_INT 9800
10057: PUSH
10058: LD_INT 9450
10060: PUSH
10061: EMPTY
10062: LIST
10063: LIST
10064: LIST
10065: LIST
10066: PUSH
10067: LD_OWVAR 67
10071: ARRAY
10072: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
10073: LD_ADDR_VAR 0 6
10077: PUSH
10078: LD_INT 70
10080: PUSH
10081: LD_INT 118
10083: PUSH
10084: EMPTY
10085: LIST
10086: LIST
10087: PUSH
10088: LD_INT 78
10090: PUSH
10091: LD_INT 31
10093: PUSH
10094: EMPTY
10095: LIST
10096: LIST
10097: PUSH
10098: EMPTY
10099: LIST
10100: LIST
10101: ST_TO_ADDR
// repeat if missionStage = 2 then
10102: LD_EXP 15
10106: PUSH
10107: LD_INT 2
10109: EQUAL
10110: IFFALSE 10121
// wait ( 1 1$30 ) else
10112: LD_INT 3150
10114: PPUSH
10115: CALL_OW 67
10119: GO 10130
// wait ( time ) ;
10121: LD_VAR 0 3
10125: PPUSH
10126: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
10130: LD_EXP 15
10134: PUSH
10135: LD_INT 6
10137: EQUAL
10138: PUSH
10139: LD_OWVAR 67
10143: PUSH
10144: LD_INT 2
10146: GREATER
10147: OR
10148: IFFALSE 10176
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
10150: LD_INT 51
10152: PPUSH
10153: LD_INT 6
10155: PPUSH
10156: LD_INT 2
10158: PPUSH
10159: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
10163: LD_INT 57
10165: PPUSH
10166: LD_INT 6
10168: PPUSH
10169: LD_INT 2
10171: PPUSH
10172: CALL_OW 322
// end ; if missionStage = 8 then
10176: LD_EXP 15
10180: PUSH
10181: LD_INT 8
10183: EQUAL
10184: IFFALSE 10212
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
10186: LD_INT 52
10188: PPUSH
10189: LD_INT 6
10191: PPUSH
10192: LD_INT 2
10194: PPUSH
10195: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
10199: LD_INT 58
10201: PPUSH
10202: LD_INT 6
10204: PPUSH
10205: LD_INT 2
10207: PPUSH
10208: CALL_OW 322
// end ; if Difficulty = 4 or missionStage = 10 then
10212: LD_OWVAR 67
10216: PUSH
10217: LD_INT 4
10219: EQUAL
10220: PUSH
10221: LD_EXP 15
10225: PUSH
10226: LD_INT 10
10228: EQUAL
10229: OR
10230: IFFALSE 10258
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
10232: LD_INT 53
10234: PPUSH
10235: LD_INT 6
10237: PPUSH
10238: LD_INT 2
10240: PPUSH
10241: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
10245: LD_INT 59
10247: PPUSH
10248: LD_INT 6
10250: PPUSH
10251: LD_INT 2
10253: PPUSH
10254: CALL_OW 322
// end ; if activeAttacks then
10258: LD_EXP 16
10262: IFFALSE 10767
// begin if missionStage = 2 then
10264: LD_EXP 15
10268: PUSH
10269: LD_INT 2
10271: EQUAL
10272: IFFALSE 10282
// strength := 1 ;
10274: LD_ADDR_VAR 0 5
10278: PUSH
10279: LD_INT 1
10281: ST_TO_ADDR
// if missionStage > 2 then
10282: LD_EXP 15
10286: PUSH
10287: LD_INT 2
10289: GREATER
10290: IFFALSE 10300
// strength := 2 ;
10292: LD_ADDR_VAR 0 5
10296: PUSH
10297: LD_INT 2
10299: ST_TO_ADDR
// if missionStage > 6 then
10300: LD_EXP 15
10304: PUSH
10305: LD_INT 6
10307: GREATER
10308: IFFALSE 10318
// strength := 3 ;
10310: LD_ADDR_VAR 0 5
10314: PUSH
10315: LD_INT 3
10317: ST_TO_ADDR
// if missionStage > 10 then
10318: LD_EXP 15
10322: PUSH
10323: LD_INT 10
10325: GREATER
10326: IFFALSE 10336
// strength := 4 ;
10328: LD_ADDR_VAR 0 5
10332: PUSH
10333: LD_INT 4
10335: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
10336: LD_ADDR_VAR 0 2
10340: PUSH
10341: LD_VAR 0 5
10345: PPUSH
10346: CALL 8829 0 1
10350: ST_TO_ADDR
// for i in tmp do
10351: LD_ADDR_VAR 0 1
10355: PUSH
10356: LD_VAR 0 2
10360: PUSH
10361: FOR_IN
10362: IFFALSE 10636
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
10364: LD_VAR 0 1
10368: PPUSH
10369: LD_VAR 0 4
10373: PUSH
10374: LD_INT 1
10376: PPUSH
10377: LD_INT 2
10379: PPUSH
10380: CALL_OW 12
10384: ARRAY
10385: PPUSH
10386: LD_INT 0
10388: PPUSH
10389: CALL_OW 49
// if i = sewiVeh then
10393: LD_VAR 0 1
10397: PUSH
10398: LD_EXP 75
10402: EQUAL
10403: IFFALSE 10456
// begin uc_side := 6 ;
10405: LD_ADDR_OWVAR 20
10409: PUSH
10410: LD_INT 6
10412: ST_TO_ADDR
// uc_nation := nation_russian ;
10413: LD_ADDR_OWVAR 21
10417: PUSH
10418: LD_INT 3
10420: ST_TO_ADDR
// Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
10421: LD_ADDR_EXP 74
10425: PUSH
10426: LD_STRING Vsevolod
10428: PPUSH
10429: LD_INT 0
10431: PPUSH
10432: LD_STRING 
10434: PPUSH
10435: CALL 70272 0 3
10439: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
10440: LD_EXP 74
10444: PPUSH
10445: LD_VAR 0 1
10449: PPUSH
10450: CALL_OW 52
// end else
10454: GO 10537
// if GetControl ( i ) = control_manual then
10456: LD_VAR 0 1
10460: PPUSH
10461: CALL_OW 263
10465: PUSH
10466: LD_INT 1
10468: EQUAL
10469: IFFALSE 10537
// begin uc_side := 6 ;
10471: LD_ADDR_OWVAR 20
10475: PUSH
10476: LD_INT 6
10478: ST_TO_ADDR
// uc_nation := 3 ;
10479: LD_ADDR_OWVAR 21
10483: PUSH
10484: LD_INT 3
10486: ST_TO_ADDR
// hc_gallery :=  ;
10487: LD_ADDR_OWVAR 33
10491: PUSH
10492: LD_STRING 
10494: ST_TO_ADDR
// hc_name :=  ;
10495: LD_ADDR_OWVAR 26
10499: PUSH
10500: LD_STRING 
10502: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
10503: LD_INT 0
10505: PPUSH
10506: LD_INT 3
10508: PPUSH
10509: LD_INT 10
10511: PPUSH
10512: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
10516: CALL_OW 44
10520: PPUSH
10521: LD_VAR 0 1
10525: PPUSH
10526: CALL_OW 52
// wait ( 0 0$0.3 ) ;
10530: LD_INT 10
10532: PPUSH
10533: CALL_OW 67
// end ; case rand ( 1 , 3 ) of 1 :
10537: LD_INT 1
10539: PPUSH
10540: LD_INT 3
10542: PPUSH
10543: CALL_OW 12
10547: PUSH
10548: LD_INT 1
10550: DOUBLE
10551: EQUAL
10552: IFTRUE 10556
10554: GO 10574
10556: POP
// ComMoveXY ( i , 111 , 197 ) ; 2 :
10557: LD_VAR 0 1
10561: PPUSH
10562: LD_INT 111
10564: PPUSH
10565: LD_INT 197
10567: PPUSH
10568: CALL_OW 111
10572: GO 10627
10574: LD_INT 2
10576: DOUBLE
10577: EQUAL
10578: IFTRUE 10582
10580: GO 10600
10582: POP
// ComMoveXY ( i , 91 , 165 ) ; 3 :
10583: LD_VAR 0 1
10587: PPUSH
10588: LD_INT 91
10590: PPUSH
10591: LD_INT 165
10593: PPUSH
10594: CALL_OW 111
10598: GO 10627
10600: LD_INT 3
10602: DOUBLE
10603: EQUAL
10604: IFTRUE 10608
10606: GO 10626
10608: POP
// ComMoveXY ( i , 137 , 157 ) ; end ;
10609: LD_VAR 0 1
10613: PPUSH
10614: LD_INT 137
10616: PPUSH
10617: LD_INT 157
10619: PPUSH
10620: CALL_OW 111
10624: GO 10627
10626: POP
// wait ( 0 0$2 ) ;
10627: LD_INT 70
10629: PPUSH
10630: CALL_OW 67
// end ;
10634: GO 10361
10636: POP
10637: POP
// repeat wait ( 0 0$1 ) ;
10638: LD_INT 35
10640: PPUSH
10641: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
10645: LD_ADDR_VAR 0 1
10649: PUSH
10650: LD_VAR 0 2
10654: PPUSH
10655: LD_INT 50
10657: PUSH
10658: EMPTY
10659: LIST
10660: PPUSH
10661: CALL_OW 72
10665: PUSH
10666: FOR_IN
10667: IFFALSE 10726
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10669: LD_VAR 0 1
10673: PPUSH
10674: LD_INT 108
10676: PUSH
10677: LD_INT 153
10679: PUSH
10680: EMPTY
10681: LIST
10682: LIST
10683: PUSH
10684: LD_INT 105
10686: PUSH
10687: LD_INT 149
10689: PUSH
10690: EMPTY
10691: LIST
10692: LIST
10693: PUSH
10694: LD_INT 85
10696: PUSH
10697: LD_INT 131
10699: PUSH
10700: EMPTY
10701: LIST
10702: LIST
10703: PUSH
10704: LD_INT 64
10706: PUSH
10707: LD_INT 105
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: LIST
10718: LIST
10719: PPUSH
10720: CALL 110608 0 2
10724: GO 10666
10726: POP
10727: POP
// until not UnitFilter ( tmp , [ [ f_not , [ f_weapon , ru_time_lapser ] ] , [ f_ok ] ] ) ;
10728: LD_VAR 0 2
10732: PPUSH
10733: LD_INT 3
10735: PUSH
10736: LD_INT 34
10738: PUSH
10739: LD_INT 49
10741: PUSH
10742: EMPTY
10743: LIST
10744: LIST
10745: PUSH
10746: EMPTY
10747: LIST
10748: LIST
10749: PUSH
10750: LD_INT 50
10752: PUSH
10753: EMPTY
10754: LIST
10755: PUSH
10756: EMPTY
10757: LIST
10758: LIST
10759: PPUSH
10760: CALL_OW 72
10764: NOT
10765: IFFALSE 10638
// end ; until russianDestroyed ;
10767: LD_EXP 21
10771: IFFALSE 10102
// end ;
10773: PPOPN 6
10775: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 do var i , tmp , target , teleport , p ;
10776: LD_EXP 21
10780: NOT
10781: PUSH
10782: LD_EXP 15
10786: PUSH
10787: LD_INT 6
10789: GREATEREQUAL
10790: AND
10791: IFFALSE 11828
10793: GO 10795
10795: DISABLE
10796: LD_INT 0
10798: PPUSH
10799: PPUSH
10800: PPUSH
10801: PPUSH
10802: PPUSH
// begin enable ;
10803: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10804: LD_INT 22
10806: PUSH
10807: LD_INT 3
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PUSH
10814: LD_INT 30
10816: PUSH
10817: LD_INT 3
10819: PUSH
10820: EMPTY
10821: LIST
10822: LIST
10823: PUSH
10824: EMPTY
10825: LIST
10826: LIST
10827: PPUSH
10828: CALL_OW 69
10832: NOT
10833: IFFALSE 10837
// exit ;
10835: GO 11828
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10837: LD_ADDR_VAR 0 4
10841: PUSH
10842: LD_INT 22
10844: PUSH
10845: LD_INT 3
10847: PUSH
10848: EMPTY
10849: LIST
10850: LIST
10851: PUSH
10852: LD_INT 30
10854: PUSH
10855: LD_INT 34
10857: PUSH
10858: EMPTY
10859: LIST
10860: LIST
10861: PUSH
10862: EMPTY
10863: LIST
10864: LIST
10865: PPUSH
10866: CALL_OW 69
10870: ST_TO_ADDR
// if Prob ( 40 ) then
10871: LD_INT 40
10873: PPUSH
10874: CALL_OW 13
10878: IFFALSE 11024
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10880: LD_INT 2
10882: PPUSH
10883: LD_INT 22
10885: PUSH
10886: LD_INT 3
10888: PUSH
10889: LD_INT 3
10891: PUSH
10892: LD_INT 49
10894: PUSH
10895: EMPTY
10896: LIST
10897: LIST
10898: LIST
10899: LIST
10900: PUSH
10901: LD_INT 22
10903: PUSH
10904: LD_INT 3
10906: PUSH
10907: LD_INT 3
10909: PUSH
10910: LD_INT 49
10912: PUSH
10913: EMPTY
10914: LIST
10915: LIST
10916: LIST
10917: LIST
10918: PUSH
10919: LD_INT 22
10921: PUSH
10922: LD_INT 3
10924: PUSH
10925: LD_INT 3
10927: PUSH
10928: LD_INT 49
10930: PUSH
10931: EMPTY
10932: LIST
10933: LIST
10934: LIST
10935: LIST
10936: PUSH
10937: LD_INT 24
10939: PUSH
10940: LD_INT 3
10942: PUSH
10943: LD_INT 3
10945: PUSH
10946: LD_INT 46
10948: PUSH
10949: EMPTY
10950: LIST
10951: LIST
10952: LIST
10953: LIST
10954: PUSH
10955: LD_INT 24
10957: PUSH
10958: LD_INT 3
10960: PUSH
10961: LD_INT 3
10963: PUSH
10964: LD_INT 46
10966: PUSH
10967: EMPTY
10968: LIST
10969: LIST
10970: LIST
10971: LIST
10972: PUSH
10973: LD_INT 24
10975: PUSH
10976: LD_INT 3
10978: PUSH
10979: LD_INT 3
10981: PUSH
10982: LD_INT 46
10984: PUSH
10985: EMPTY
10986: LIST
10987: LIST
10988: LIST
10989: LIST
10990: PUSH
10991: LD_INT 24
10993: PUSH
10994: LD_INT 3
10996: PUSH
10997: LD_INT 3
10999: PUSH
11000: LD_INT 46
11002: PUSH
11003: EMPTY
11004: LIST
11005: LIST
11006: LIST
11007: LIST
11008: PUSH
11009: EMPTY
11010: LIST
11011: LIST
11012: LIST
11013: LIST
11014: LIST
11015: LIST
11016: LIST
11017: PPUSH
11018: CALL 63846 0 2
// end else
11022: GO 11166
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
11024: LD_INT 2
11026: PPUSH
11027: LD_INT 24
11029: PUSH
11030: LD_INT 3
11032: PUSH
11033: LD_INT 3
11035: PUSH
11036: LD_INT 47
11038: PUSH
11039: EMPTY
11040: LIST
11041: LIST
11042: LIST
11043: LIST
11044: PUSH
11045: LD_INT 24
11047: PUSH
11048: LD_INT 3
11050: PUSH
11051: LD_INT 3
11053: PUSH
11054: LD_INT 47
11056: PUSH
11057: EMPTY
11058: LIST
11059: LIST
11060: LIST
11061: LIST
11062: PUSH
11063: LD_INT 24
11065: PUSH
11066: LD_INT 3
11068: PUSH
11069: LD_INT 3
11071: PUSH
11072: LD_INT 47
11074: PUSH
11075: EMPTY
11076: LIST
11077: LIST
11078: LIST
11079: LIST
11080: PUSH
11081: LD_INT 24
11083: PUSH
11084: LD_INT 3
11086: PUSH
11087: LD_INT 3
11089: PUSH
11090: LD_INT 46
11092: PUSH
11093: EMPTY
11094: LIST
11095: LIST
11096: LIST
11097: LIST
11098: PUSH
11099: LD_INT 24
11101: PUSH
11102: LD_INT 3
11104: PUSH
11105: LD_INT 3
11107: PUSH
11108: LD_INT 46
11110: PUSH
11111: EMPTY
11112: LIST
11113: LIST
11114: LIST
11115: LIST
11116: PUSH
11117: LD_INT 24
11119: PUSH
11120: LD_INT 3
11122: PUSH
11123: LD_INT 3
11125: PUSH
11126: LD_INT 46
11128: PUSH
11129: EMPTY
11130: LIST
11131: LIST
11132: LIST
11133: LIST
11134: PUSH
11135: LD_INT 24
11137: PUSH
11138: LD_INT 3
11140: PUSH
11141: LD_INT 3
11143: PUSH
11144: LD_INT 46
11146: PUSH
11147: EMPTY
11148: LIST
11149: LIST
11150: LIST
11151: LIST
11152: PUSH
11153: EMPTY
11154: LIST
11155: LIST
11156: LIST
11157: LIST
11158: LIST
11159: LIST
11160: LIST
11161: PPUSH
11162: CALL 63846 0 2
// end ; wait ( 2 2$00 ) ;
11166: LD_INT 4200
11168: PPUSH
11169: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_siberium_rocket ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 2 ] ;
11173: LD_ADDR_VAR 0 2
11177: PUSH
11178: LD_INT 22
11180: PUSH
11181: LD_INT 3
11183: PUSH
11184: EMPTY
11185: LIST
11186: LIST
11187: PUSH
11188: LD_INT 23
11190: PUSH
11191: LD_INT 3
11193: PUSH
11194: EMPTY
11195: LIST
11196: LIST
11197: PUSH
11198: LD_INT 21
11200: PUSH
11201: LD_INT 2
11203: PUSH
11204: EMPTY
11205: LIST
11206: LIST
11207: PUSH
11208: LD_INT 3
11210: PUSH
11211: LD_INT 34
11213: PUSH
11214: LD_INT 48
11216: PUSH
11217: EMPTY
11218: LIST
11219: LIST
11220: PUSH
11221: EMPTY
11222: LIST
11223: LIST
11224: PUSH
11225: LD_INT 3
11227: PUSH
11228: LD_INT 34
11230: PUSH
11231: LD_INT 51
11233: PUSH
11234: EMPTY
11235: LIST
11236: LIST
11237: PUSH
11238: EMPTY
11239: LIST
11240: LIST
11241: PUSH
11242: LD_INT 3
11244: PUSH
11245: LD_INT 34
11247: PUSH
11248: LD_INT 52
11250: PUSH
11251: EMPTY
11252: LIST
11253: LIST
11254: PUSH
11255: EMPTY
11256: LIST
11257: LIST
11258: PUSH
11259: EMPTY
11260: LIST
11261: LIST
11262: LIST
11263: LIST
11264: LIST
11265: LIST
11266: PPUSH
11267: CALL_OW 69
11271: PUSH
11272: LD_EXP 124
11276: PUSH
11277: LD_INT 2
11279: ARRAY
11280: DIFF
11281: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
11282: LD_ADDR_EXP 121
11286: PUSH
11287: LD_EXP 121
11291: PPUSH
11292: LD_INT 2
11294: PPUSH
11295: LD_EXP 121
11299: PUSH
11300: LD_INT 2
11302: ARRAY
11303: PUSH
11304: LD_VAR 0 2
11308: DIFF
11309: PPUSH
11310: CALL_OW 1
11314: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
11315: LD_ADDR_VAR 0 3
11319: PUSH
11320: LD_INT 0
11322: PPUSH
11323: LD_INT 1
11325: PPUSH
11326: CALL_OW 12
11330: ST_TO_ADDR
// p := 0 ;
11331: LD_ADDR_VAR 0 5
11335: PUSH
11336: LD_INT 0
11338: ST_TO_ADDR
// if target then
11339: LD_VAR 0 3
11343: IFFALSE 11492
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11345: LD_ADDR_VAR 0 2
11349: PUSH
11350: LD_VAR 0 2
11354: PPUSH
11355: LD_INT 50
11357: PUSH
11358: EMPTY
11359: LIST
11360: PPUSH
11361: CALL_OW 72
11365: ST_TO_ADDR
// for i in tmp do
11366: LD_ADDR_VAR 0 1
11370: PUSH
11371: LD_VAR 0 2
11375: PUSH
11376: FOR_IN
11377: IFFALSE 11417
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
11379: LD_VAR 0 1
11383: PPUSH
11384: LD_INT 139
11386: PPUSH
11387: LD_INT 89
11389: PPUSH
11390: CALL_OW 297
11394: PUSH
11395: LD_INT 9
11397: GREATER
11398: IFFALSE 11415
// ComMoveXY ( i , 139 , 89 ) ;
11400: LD_VAR 0 1
11404: PPUSH
11405: LD_INT 139
11407: PPUSH
11408: LD_INT 89
11410: PPUSH
11411: CALL_OW 111
11415: GO 11376
11417: POP
11418: POP
// wait ( 0 0$1 ) ;
11419: LD_INT 35
11421: PPUSH
11422: CALL_OW 67
// p := Inc ( p ) ;
11426: LD_ADDR_VAR 0 5
11430: PUSH
11431: LD_VAR 0 5
11435: PPUSH
11436: CALL 109365 0 1
11440: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11441: LD_VAR 0 2
11445: PPUSH
11446: LD_INT 92
11448: PUSH
11449: LD_INT 139
11451: PUSH
11452: LD_INT 89
11454: PUSH
11455: LD_INT 9
11457: PUSH
11458: EMPTY
11459: LIST
11460: LIST
11461: LIST
11462: LIST
11463: PPUSH
11464: CALL_OW 72
11468: PUSH
11469: LD_VAR 0 2
11473: PUSH
11474: LD_INT 1
11476: MINUS
11477: GREATEREQUAL
11478: PUSH
11479: LD_VAR 0 5
11483: PUSH
11484: LD_INT 60
11486: GREATER
11487: OR
11488: IFFALSE 11345
// end else
11490: GO 11655
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11492: LD_VAR 0 2
11496: PPUSH
11497: LD_VAR 0 4
11501: PUSH
11502: LD_INT 1
11504: ARRAY
11505: PPUSH
11506: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11510: LD_ADDR_VAR 0 2
11514: PUSH
11515: LD_VAR 0 2
11519: PPUSH
11520: LD_INT 50
11522: PUSH
11523: EMPTY
11524: LIST
11525: PPUSH
11526: CALL_OW 72
11530: ST_TO_ADDR
// for i in tmp do
11531: LD_ADDR_VAR 0 1
11535: PUSH
11536: LD_VAR 0 2
11540: PUSH
11541: FOR_IN
11542: IFFALSE 11582
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11544: LD_VAR 0 1
11548: PPUSH
11549: LD_INT 124
11551: PPUSH
11552: LD_INT 139
11554: PPUSH
11555: CALL_OW 297
11559: PUSH
11560: LD_INT 9
11562: GREATER
11563: IFFALSE 11580
// ComMoveXY ( i , 124 , 139 ) ;
11565: LD_VAR 0 1
11569: PPUSH
11570: LD_INT 124
11572: PPUSH
11573: LD_INT 139
11575: PPUSH
11576: CALL_OW 111
11580: GO 11541
11582: POP
11583: POP
// wait ( 0 0$1 ) ;
11584: LD_INT 35
11586: PPUSH
11587: CALL_OW 67
// p := Inc ( p ) ;
11591: LD_ADDR_VAR 0 5
11595: PUSH
11596: LD_VAR 0 5
11600: PPUSH
11601: CALL 109365 0 1
11605: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11606: LD_VAR 0 2
11610: PPUSH
11611: LD_INT 92
11613: PUSH
11614: LD_INT 124
11616: PUSH
11617: LD_INT 139
11619: PUSH
11620: LD_INT 9
11622: PUSH
11623: EMPTY
11624: LIST
11625: LIST
11626: LIST
11627: LIST
11628: PPUSH
11629: CALL_OW 72
11633: PUSH
11634: LD_VAR 0 2
11638: PUSH
11639: LD_INT 1
11641: MINUS
11642: GREATEREQUAL
11643: PUSH
11644: LD_VAR 0 5
11648: PUSH
11649: LD_INT 60
11651: GREATER
11652: OR
11653: IFFALSE 11510
// end ; repeat wait ( 0 0$1 ) ;
11655: LD_INT 35
11657: PPUSH
11658: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11662: LD_ADDR_VAR 0 2
11666: PUSH
11667: LD_VAR 0 2
11671: PPUSH
11672: LD_INT 50
11674: PUSH
11675: EMPTY
11676: LIST
11677: PPUSH
11678: CALL_OW 72
11682: ST_TO_ADDR
// for i in tmp do
11683: LD_ADDR_VAR 0 1
11687: PUSH
11688: LD_VAR 0 2
11692: PUSH
11693: FOR_IN
11694: IFFALSE 11819
// begin if GetWeapon ( i ) = ru_time_lapser then
11696: LD_VAR 0 1
11700: PPUSH
11701: CALL_OW 264
11705: PUSH
11706: LD_INT 49
11708: EQUAL
11709: IFFALSE 11765
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11711: LD_VAR 0 1
11715: PPUSH
11716: LD_INT 2
11718: PUSH
11719: LD_INT 22
11721: PUSH
11722: LD_INT 1
11724: PUSH
11725: EMPTY
11726: LIST
11727: LIST
11728: PUSH
11729: LD_INT 22
11731: PUSH
11732: LD_INT 8
11734: PUSH
11735: EMPTY
11736: LIST
11737: LIST
11738: PUSH
11739: EMPTY
11740: LIST
11741: LIST
11742: LIST
11743: PPUSH
11744: CALL_OW 69
11748: PPUSH
11749: LD_VAR 0 1
11753: PPUSH
11754: CALL_OW 74
11758: PPUSH
11759: CALL_OW 112
11763: GO 11817
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11765: LD_VAR 0 1
11769: PPUSH
11770: LD_INT 2
11772: PUSH
11773: LD_INT 22
11775: PUSH
11776: LD_INT 1
11778: PUSH
11779: EMPTY
11780: LIST
11781: LIST
11782: PUSH
11783: LD_INT 22
11785: PUSH
11786: LD_INT 8
11788: PUSH
11789: EMPTY
11790: LIST
11791: LIST
11792: PUSH
11793: EMPTY
11794: LIST
11795: LIST
11796: LIST
11797: PPUSH
11798: CALL_OW 69
11802: PPUSH
11803: LD_VAR 0 1
11807: PPUSH
11808: CALL_OW 74
11812: PPUSH
11813: CALL_OW 115
// end ;
11817: GO 11693
11819: POP
11820: POP
// until not tmp ;
11821: LD_VAR 0 2
11825: NOT
11826: IFFALSE 11655
// end ;
11828: PPOPN 5
11830: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 7 and Difficulty > 1 do var i , veh , un ;
11831: LD_EXP 15
11835: PUSH
11836: LD_INT 7
11838: GREATEREQUAL
11839: PUSH
11840: LD_OWVAR 67
11844: PUSH
11845: LD_INT 1
11847: GREATER
11848: AND
11849: IFFALSE 12141
11851: GO 11853
11853: DISABLE
11854: LD_INT 0
11856: PPUSH
11857: PPUSH
11858: PPUSH
// begin ruMobile := [ ] ;
11859: LD_ADDR_EXP 78
11863: PUSH
11864: EMPTY
11865: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 ] [ Difficulty - 1 ] do
11866: LD_ADDR_VAR 0 1
11870: PUSH
11871: DOUBLE
11872: LD_INT 1
11874: DEC
11875: ST_TO_ADDR
11876: LD_INT 4
11878: PUSH
11879: LD_INT 5
11881: PUSH
11882: LD_INT 6
11884: PUSH
11885: EMPTY
11886: LIST
11887: LIST
11888: LIST
11889: PUSH
11890: LD_OWVAR 67
11894: PUSH
11895: LD_INT 1
11897: MINUS
11898: ARRAY
11899: PUSH
11900: FOR_TO
11901: IFFALSE 12139
// begin uc_side := 3 ;
11903: LD_ADDR_OWVAR 20
11907: PUSH
11908: LD_INT 3
11910: ST_TO_ADDR
// uc_nation := 1 ;
11911: LD_ADDR_OWVAR 21
11915: PUSH
11916: LD_INT 1
11918: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_laser , us_rocket_launcher ] [ i mod 2 + 1 ] , 100 ) ;
11919: LD_INT 5
11921: PPUSH
11922: LD_INT 3
11924: PPUSH
11925: LD_INT 1
11927: PPUSH
11928: LD_INT 9
11930: PUSH
11931: LD_INT 7
11933: PUSH
11934: EMPTY
11935: LIST
11936: LIST
11937: PUSH
11938: LD_VAR 0 1
11942: PUSH
11943: LD_INT 2
11945: MOD
11946: PUSH
11947: LD_INT 1
11949: PLUS
11950: ARRAY
11951: PPUSH
11952: LD_INT 100
11954: PPUSH
11955: CALL 75133 0 5
// veh := CreateVehicle ;
11959: LD_ADDR_VAR 0 2
11963: PUSH
11964: CALL_OW 45
11968: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11969: LD_VAR 0 2
11973: PPUSH
11974: LD_INT 3
11976: PPUSH
11977: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11981: LD_VAR 0 2
11985: PPUSH
11986: LD_INT 29
11988: PPUSH
11989: LD_INT 0
11991: PPUSH
11992: CALL_OW 49
// uc_nation := 3 ;
11996: LD_ADDR_OWVAR 21
12000: PUSH
12001: LD_INT 3
12003: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
12004: LD_INT 0
12006: PPUSH
12007: LD_INT 10
12009: PPUSH
12010: CALL_OW 383
// un := CreateHuman ;
12014: LD_ADDR_VAR 0 3
12018: PUSH
12019: CALL_OW 44
12023: ST_TO_ADDR
// SetTag ( un , 105 ) ;
12024: LD_VAR 0 3
12028: PPUSH
12029: LD_INT 105
12031: PPUSH
12032: CALL_OW 109
// if GetSkill ( un , skill_mechanical ) < [ 8 , 9 , 10 ] [ Difficulty ] then
12036: LD_VAR 0 3
12040: PPUSH
12041: LD_INT 3
12043: PPUSH
12044: CALL_OW 259
12048: PUSH
12049: LD_INT 8
12051: PUSH
12052: LD_INT 9
12054: PUSH
12055: LD_INT 10
12057: PUSH
12058: EMPTY
12059: LIST
12060: LIST
12061: LIST
12062: PUSH
12063: LD_OWVAR 67
12067: ARRAY
12068: LESS
12069: IFFALSE 12103
// SetSkill ( un , skill_mechanical , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
12071: LD_VAR 0 3
12075: PPUSH
12076: LD_INT 3
12078: PPUSH
12079: LD_INT 8
12081: PUSH
12082: LD_INT 9
12084: PUSH
12085: LD_INT 10
12087: PUSH
12088: EMPTY
12089: LIST
12090: LIST
12091: LIST
12092: PUSH
12093: LD_OWVAR 67
12097: ARRAY
12098: PPUSH
12099: CALL_OW 237
// PlaceHumanInUnit ( un , veh ) ;
12103: LD_VAR 0 3
12107: PPUSH
12108: LD_VAR 0 2
12112: PPUSH
12113: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
12117: LD_ADDR_EXP 78
12121: PUSH
12122: LD_EXP 78
12126: PPUSH
12127: LD_VAR 0 2
12131: PPUSH
12132: CALL 108004 0 2
12136: ST_TO_ADDR
// end ;
12137: GO 11900
12139: POP
12140: POP
// end ;
12141: PPOPN 3
12143: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
12144: LD_EXP 78
12148: IFFALSE 12657
12150: GO 12152
12152: DISABLE
12153: LD_INT 0
12155: PPUSH
12156: PPUSH
12157: PPUSH
// begin enable ;
12158: ENABLE
// if not ruMobile then
12159: LD_EXP 78
12163: NOT
12164: IFFALSE 12169
// begin disable ;
12166: DISABLE
// exit ;
12167: GO 12657
// end ; for i in ruMobile do
12169: LD_ADDR_VAR 0 1
12173: PUSH
12174: LD_EXP 78
12178: PUSH
12179: FOR_IN
12180: IFFALSE 12655
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
12182: LD_VAR 0 1
12186: PPUSH
12187: CALL_OW 302
12191: NOT
12192: PUSH
12193: LD_VAR 0 1
12197: PPUSH
12198: CALL_OW 255
12202: PUSH
12203: LD_INT 3
12205: NONEQUAL
12206: OR
12207: IFFALSE 12227
// begin ruMobile := ruMobile diff i ;
12209: LD_ADDR_EXP 78
12213: PUSH
12214: LD_EXP 78
12218: PUSH
12219: LD_VAR 0 1
12223: DIFF
12224: ST_TO_ADDR
// continue ;
12225: GO 12179
// end ; if GetTag ( i ) = 300 then
12227: LD_VAR 0 1
12231: PPUSH
12232: CALL_OW 110
12236: PUSH
12237: LD_INT 300
12239: EQUAL
12240: IFFALSE 12290
// begin ComMoveXY ( i , 160 , 81 ) ;
12242: LD_VAR 0 1
12246: PPUSH
12247: LD_INT 160
12249: PPUSH
12250: LD_INT 81
12252: PPUSH
12253: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
12257: LD_VAR 0 1
12261: PPUSH
12262: LD_INT 160
12264: PPUSH
12265: LD_INT 81
12267: PPUSH
12268: CALL_OW 297
12272: PUSH
12273: LD_INT 8
12275: LESS
12276: IFFALSE 12290
// SetTag ( i , 301 ) ;
12278: LD_VAR 0 1
12282: PPUSH
12283: LD_INT 301
12285: PPUSH
12286: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
12290: LD_VAR 0 1
12294: PPUSH
12295: CALL_OW 110
12299: PUSH
12300: LD_INT 301
12302: EQUAL
12303: IFFALSE 12346
// begin if not IsInArea ( i , ruMobileParkingArea ) then
12305: LD_VAR 0 1
12309: PPUSH
12310: LD_INT 33
12312: PPUSH
12313: CALL_OW 308
12317: NOT
12318: IFFALSE 12334
// ComMoveToArea ( i , ruMobileParkingArea ) else
12320: LD_VAR 0 1
12324: PPUSH
12325: LD_INT 33
12327: PPUSH
12328: CALL_OW 113
12332: GO 12346
// SetTag ( i , 302 ) ;
12334: LD_VAR 0 1
12338: PPUSH
12339: LD_INT 302
12341: PPUSH
12342: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
12346: LD_VAR 0 1
12350: PPUSH
12351: CALL_OW 110
12355: PUSH
12356: LD_INT 302
12358: EQUAL
12359: IFFALSE 12489
// begin if GetLives ( i ) < 1000 then
12361: LD_VAR 0 1
12365: PPUSH
12366: CALL_OW 256
12370: PUSH
12371: LD_INT 1000
12373: LESS
12374: IFFALSE 12466
// begin if not IsDrivenBy ( i ) then
12376: LD_VAR 0 1
12380: PPUSH
12381: CALL_OW 311
12385: NOT
12386: IFFALSE 12390
// continue ;
12388: GO 12179
// mech := IsDrivenBy ( i ) ;
12390: LD_ADDR_VAR 0 2
12394: PUSH
12395: LD_VAR 0 1
12399: PPUSH
12400: CALL_OW 311
12404: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
12405: LD_VAR 0 2
12409: PPUSH
12410: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
12414: LD_VAR 0 2
12418: PPUSH
12419: LD_VAR 0 1
12423: PPUSH
12424: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
12428: LD_INT 35
12430: PPUSH
12431: CALL_OW 67
// until GetLives ( i ) = 1000 ;
12435: LD_VAR 0 1
12439: PPUSH
12440: CALL_OW 256
12444: PUSH
12445: LD_INT 1000
12447: EQUAL
12448: IFFALSE 12428
// ComEnterUnit ( mech , i ) ;
12450: LD_VAR 0 2
12454: PPUSH
12455: LD_VAR 0 1
12459: PPUSH
12460: CALL_OW 120
// end else
12464: GO 12489
// if IsDrivenBy ( i ) then
12466: LD_VAR 0 1
12470: PPUSH
12471: CALL_OW 311
12475: IFFALSE 12489
// SetTag ( i , 0 ) ;
12477: LD_VAR 0 1
12481: PPUSH
12482: LD_INT 0
12484: PPUSH
12485: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
12489: LD_VAR 0 1
12493: PPUSH
12494: CALL_OW 110
12498: PUSH
12499: LD_INT 300
12501: LESS
12502: IFFALSE 12653
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
12504: LD_ADDR_VAR 0 3
12508: PUSH
12509: LD_INT 4
12511: PPUSH
12512: LD_INT 81
12514: PUSH
12515: LD_INT 3
12517: PUSH
12518: EMPTY
12519: LIST
12520: LIST
12521: PPUSH
12522: CALL_OW 70
12526: ST_TO_ADDR
// if GetLives ( i ) < 650 then
12527: LD_VAR 0 1
12531: PPUSH
12532: CALL_OW 256
12536: PUSH
12537: LD_INT 650
12539: LESS
12540: IFFALSE 12565
// begin ComStop ( i ) ;
12542: LD_VAR 0 1
12546: PPUSH
12547: CALL_OW 141
// SetTag ( i , 300 ) ;
12551: LD_VAR 0 1
12555: PPUSH
12556: LD_INT 300
12558: PPUSH
12559: CALL_OW 109
// continue ;
12563: GO 12179
// end ; if enemy then
12565: LD_VAR 0 3
12569: IFFALSE 12609
// begin if not HasTask ( i ) then
12571: LD_VAR 0 1
12575: PPUSH
12576: CALL_OW 314
12580: NOT
12581: IFFALSE 12607
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
12583: LD_VAR 0 1
12587: PPUSH
12588: LD_VAR 0 3
12592: PPUSH
12593: LD_VAR 0 1
12597: PPUSH
12598: CALL_OW 74
12602: PPUSH
12603: CALL_OW 115
// end else
12607: GO 12653
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
12609: LD_VAR 0 1
12613: PPUSH
12614: LD_INT 158
12616: PUSH
12617: LD_INT 61
12619: PUSH
12620: EMPTY
12621: LIST
12622: LIST
12623: PUSH
12624: LD_INT 98
12626: PUSH
12627: LD_INT 100
12629: PUSH
12630: EMPTY
12631: LIST
12632: LIST
12633: PUSH
12634: LD_INT 78
12636: PUSH
12637: LD_INT 93
12639: PUSH
12640: EMPTY
12641: LIST
12642: LIST
12643: PUSH
12644: EMPTY
12645: LIST
12646: LIST
12647: LIST
12648: PPUSH
12649: CALL 110608 0 2
// end ; end ;
12653: GO 12179
12655: POP
12656: POP
// end ; end_of_file
12657: PPOPN 3
12659: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport , b ; begin
12660: LD_INT 0
12662: PPUSH
12663: PPUSH
12664: PPUSH
12665: PPUSH
12666: PPUSH
12667: PPUSH
12668: PPUSH
// if Difficulty = 1 then
12669: LD_OWVAR 67
12673: PUSH
12674: LD_INT 1
12676: EQUAL
12677: IFFALSE 12715
// for i in FilterAllUnits ( [ f_inarea , delBuildingsArea ] ) do
12679: LD_ADDR_VAR 0 2
12683: PUSH
12684: LD_INT 95
12686: PUSH
12687: LD_INT 34
12689: PUSH
12690: EMPTY
12691: LIST
12692: LIST
12693: PPUSH
12694: CALL_OW 69
12698: PUSH
12699: FOR_IN
12700: IFFALSE 12713
// RemoveUnit ( i ) ;
12702: LD_VAR 0 2
12706: PPUSH
12707: CALL_OW 64
12711: GO 12699
12713: POP
12714: POP
// SetInvulnrability ( alien , true ) ;
12715: LD_INT 1
12717: PPUSH
12718: LD_INT 1
12720: PPUSH
12721: CALL_OW 607
// side := 7 ;
12725: LD_ADDR_VAR 0 5
12729: PUSH
12730: LD_INT 7
12732: ST_TO_ADDR
// uc_side := side ;
12733: LD_ADDR_OWVAR 20
12737: PUSH
12738: LD_VAR 0 5
12742: ST_TO_ADDR
// uc_nation := 1 ;
12743: LD_ADDR_OWVAR 21
12747: PUSH
12748: LD_INT 1
12750: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
12751: LD_ADDR_VAR 0 2
12755: PUSH
12756: LD_INT 22
12758: PUSH
12759: LD_VAR 0 5
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: PUSH
12768: LD_INT 21
12770: PUSH
12771: LD_INT 3
12773: PUSH
12774: EMPTY
12775: LIST
12776: LIST
12777: PUSH
12778: EMPTY
12779: LIST
12780: LIST
12781: PPUSH
12782: CALL_OW 69
12786: PUSH
12787: FOR_IN
12788: IFFALSE 12804
// SetBLevel ( i , 10 ) ;
12790: LD_VAR 0 2
12794: PPUSH
12795: LD_INT 10
12797: PPUSH
12798: CALL_OW 241
12802: GO 12787
12804: POP
12805: POP
// base := GetBase ( al_depot ) ;
12806: LD_ADDR_VAR 0 4
12810: PUSH
12811: LD_INT 2
12813: PPUSH
12814: CALL_OW 274
12818: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
12819: LD_ADDR_VAR 0 6
12823: PUSH
12824: LD_INT 22
12826: PUSH
12827: LD_VAR 0 5
12831: PUSH
12832: EMPTY
12833: LIST
12834: LIST
12835: PUSH
12836: LD_INT 30
12838: PUSH
12839: LD_INT 34
12841: PUSH
12842: EMPTY
12843: LIST
12844: LIST
12845: PUSH
12846: EMPTY
12847: LIST
12848: LIST
12849: PPUSH
12850: CALL_OW 69
12854: ST_TO_ADDR
// if teleport then
12855: LD_VAR 0 6
12859: IFFALSE 12880
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
12861: LD_VAR 0 6
12865: PUSH
12866: LD_INT 1
12868: ARRAY
12869: PPUSH
12870: LD_INT 262
12872: PPUSH
12873: LD_INT 119
12875: PPUSH
12876: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
12880: LD_VAR 0 4
12884: PPUSH
12885: LD_INT 1
12887: PPUSH
12888: LD_INT 19500
12890: PPUSH
12891: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
12895: LD_VAR 0 4
12899: PPUSH
12900: LD_INT 2
12902: PPUSH
12903: LD_INT 200
12905: PPUSH
12906: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
12910: LD_VAR 0 4
12914: PPUSH
12915: LD_INT 3
12917: PPUSH
12918: LD_INT 650
12920: PPUSH
12921: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12925: LD_ADDR_EXP 79
12929: PUSH
12930: LD_STRING Roth
12932: PPUSH
12933: CALL_OW 25
12937: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12938: LD_ADDR_EXP 80
12942: PUSH
12943: LD_STRING Simms
12945: PPUSH
12946: LD_EXP 1
12950: NOT
12951: PPUSH
12952: LD_STRING 10c_
12954: PPUSH
12955: CALL 70272 0 3
12959: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
12960: LD_EXP 80
12964: PPUSH
12965: LD_INT 4
12967: PPUSH
12968: CALL_OW 336
// if not Simms then
12972: LD_EXP 80
12976: NOT
12977: IFFALSE 13007
// begin uc_nation := 1 ;
12979: LD_ADDR_OWVAR 21
12983: PUSH
12984: LD_INT 1
12986: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12987: LD_INT 2
12989: PPUSH
12990: LD_INT 10
12992: PPUSH
12993: CALL_OW 384
// Simms := CreateHuman ;
12997: LD_ADDR_EXP 80
13001: PUSH
13002: CALL_OW 44
13006: ST_TO_ADDR
// end ; uc_nation := 3 ;
13007: LD_ADDR_OWVAR 21
13011: PUSH
13012: LD_INT 3
13014: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
13015: LD_ADDR_EXP 81
13019: PUSH
13020: LD_STRING Kirilenkova
13022: PPUSH
13023: CALL_OW 25
13027: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
13028: LD_ADDR_EXP 95
13032: PUSH
13033: LD_STRING Oblukov
13035: PPUSH
13036: CALL_OW 25
13040: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
13041: LD_ADDR_EXP 82
13045: PUSH
13046: LD_STRING Dolgov
13048: PPUSH
13049: CALL_OW 25
13053: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
13054: LD_ADDR_EXP 83
13058: PUSH
13059: LD_STRING Petrosyan
13061: PPUSH
13062: CALL_OW 25
13066: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
13067: LD_ADDR_EXP 94
13071: PUSH
13072: LD_STRING Scholtze
13074: PPUSH
13075: CALL_OW 25
13079: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
13080: LD_ADDR_EXP 93
13084: PUSH
13085: LD_STRING Kapitsova
13087: PPUSH
13088: CALL_OW 25
13092: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
13093: LD_ADDR_EXP 84
13097: PUSH
13098: LD_STRING Petrovova
13100: PPUSH
13101: CALL_OW 25
13105: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
13106: LD_ADDR_EXP 85
13110: PUSH
13111: LD_STRING Kuzmov
13113: PPUSH
13114: CALL_OW 25
13118: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
13119: LD_ADDR_EXP 92
13123: PUSH
13124: LD_STRING Karamazov
13126: PPUSH
13127: CALL_OW 25
13131: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
13132: LD_STRING 13_Lipshchin_1
13134: PPUSH
13135: LD_INT 0
13137: PPUSH
13138: CALL_OW 30
13142: IFFALSE 13157
// Lipshchin := NewCharacter ( Lipshchin ) ;
13144: LD_ADDR_EXP 86
13148: PUSH
13149: LD_STRING Lipshchin
13151: PPUSH
13152: CALL_OW 25
13156: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
13157: LD_STRING 13_Titov_1
13159: PPUSH
13160: LD_INT 0
13162: PPUSH
13163: CALL_OW 30
13167: IFFALSE 13182
// Titov := NewCharacter ( Titov ) ;
13169: LD_ADDR_EXP 88
13173: PUSH
13174: LD_STRING Titov
13176: PPUSH
13177: CALL_OW 25
13181: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
13182: LD_STRING 13_Gnyevko_1
13184: PPUSH
13185: LD_INT 0
13187: PPUSH
13188: CALL_OW 30
13192: IFFALSE 13207
// Gnyevko := NewCharacter ( Gnyevko ) ;
13194: LD_ADDR_EXP 87
13198: PUSH
13199: LD_STRING Gnyevko
13201: PPUSH
13202: CALL_OW 25
13206: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
13207: LD_STRING 13_Xavier_1
13209: PPUSH
13210: LD_INT 0
13212: PPUSH
13213: CALL_OW 30
13217: IFFALSE 13232
// Xavier := NewCharacter ( Xavier2 ) ;
13219: LD_ADDR_EXP 89
13223: PUSH
13224: LD_STRING Xavier2
13226: PPUSH
13227: CALL_OW 25
13231: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
13232: LD_STRING 13_Belkov_1
13234: PPUSH
13235: LD_INT 0
13237: PPUSH
13238: CALL_OW 30
13242: IFFALSE 13257
// Belkov := NewCharacter ( Belkov ) ;
13244: LD_ADDR_EXP 90
13248: PUSH
13249: LD_STRING Belkov
13251: PPUSH
13252: CALL_OW 25
13256: ST_TO_ADDR
// if not BurlakStatus then
13257: LD_EXP 9
13261: NOT
13262: IFFALSE 13277
// Burlak = NewCharacter ( Burlak ) ;
13264: LD_ADDR_EXP 91
13268: PUSH
13269: LD_STRING Burlak
13271: PPUSH
13272: CALL_OW 25
13276: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
13277: LD_ADDR_VAR 0 3
13281: PUSH
13282: LD_EXP 79
13286: PUSH
13287: LD_EXP 81
13291: PUSH
13292: LD_EXP 95
13296: PUSH
13297: LD_EXP 82
13301: PUSH
13302: LD_EXP 83
13306: PUSH
13307: LD_EXP 94
13311: PUSH
13312: LD_EXP 93
13316: PUSH
13317: LD_EXP 84
13321: PUSH
13322: LD_EXP 85
13326: PUSH
13327: LD_EXP 92
13331: PUSH
13332: EMPTY
13333: LIST
13334: LIST
13335: LIST
13336: LIST
13337: LIST
13338: LIST
13339: LIST
13340: LIST
13341: LIST
13342: LIST
13343: ST_TO_ADDR
// if Simms then
13344: LD_EXP 80
13348: IFFALSE 13366
// tmp := tmp ^ Simms ;
13350: LD_ADDR_VAR 0 3
13354: PUSH
13355: LD_VAR 0 3
13359: PUSH
13360: LD_EXP 80
13364: ADD
13365: ST_TO_ADDR
// if Titov then
13366: LD_EXP 88
13370: IFFALSE 13388
// tmp := tmp ^ Titov ;
13372: LD_ADDR_VAR 0 3
13376: PUSH
13377: LD_VAR 0 3
13381: PUSH
13382: LD_EXP 88
13386: ADD
13387: ST_TO_ADDR
// if Lipshchin then
13388: LD_EXP 86
13392: IFFALSE 13410
// tmp := tmp ^ Lipshchin ;
13394: LD_ADDR_VAR 0 3
13398: PUSH
13399: LD_VAR 0 3
13403: PUSH
13404: LD_EXP 86
13408: ADD
13409: ST_TO_ADDR
// if Gnyevko then
13410: LD_EXP 87
13414: IFFALSE 13432
// tmp := tmp ^ Gnyevko ;
13416: LD_ADDR_VAR 0 3
13420: PUSH
13421: LD_VAR 0 3
13425: PUSH
13426: LD_EXP 87
13430: ADD
13431: ST_TO_ADDR
// if Xavier then
13432: LD_EXP 89
13436: IFFALSE 13454
// tmp := tmp ^ Xavier ;
13438: LD_ADDR_VAR 0 3
13442: PUSH
13443: LD_VAR 0 3
13447: PUSH
13448: LD_EXP 89
13452: ADD
13453: ST_TO_ADDR
// if Belkov then
13454: LD_EXP 90
13458: IFFALSE 13476
// tmp := tmp ^ Belkov ;
13460: LD_ADDR_VAR 0 3
13464: PUSH
13465: LD_VAR 0 3
13469: PUSH
13470: LD_EXP 90
13474: ADD
13475: ST_TO_ADDR
// if Burlak then
13476: LD_EXP 91
13480: IFFALSE 13498
// tmp := tmp ^ Burlak ;
13482: LD_ADDR_VAR 0 3
13486: PUSH
13487: LD_VAR 0 3
13491: PUSH
13492: LD_EXP 91
13496: ADD
13497: ST_TO_ADDR
// for i = 1 to 11 do
13498: LD_ADDR_VAR 0 2
13502: PUSH
13503: DOUBLE
13504: LD_INT 1
13506: DEC
13507: ST_TO_ADDR
13508: LD_INT 11
13510: PUSH
13511: FOR_TO
13512: IFFALSE 13580
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
13514: LD_ADDR_OWVAR 21
13518: PUSH
13519: LD_INT 1
13521: PUSH
13522: LD_INT 3
13524: PUSH
13525: EMPTY
13526: LIST
13527: LIST
13528: PUSH
13529: LD_INT 1
13531: PPUSH
13532: LD_INT 2
13534: PPUSH
13535: CALL_OW 12
13539: ARRAY
13540: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 10 ) ;
13541: LD_INT 0
13543: PPUSH
13544: LD_INT 1
13546: PPUSH
13547: LD_INT 4
13549: PPUSH
13550: CALL_OW 12
13554: PPUSH
13555: LD_INT 10
13557: PPUSH
13558: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
13562: LD_ADDR_VAR 0 3
13566: PUSH
13567: LD_VAR 0 3
13571: PUSH
13572: CALL_OW 44
13576: ADD
13577: ST_TO_ADDR
// end ;
13578: GO 13511
13580: POP
13581: POP
// for i in tmp do
13582: LD_ADDR_VAR 0 2
13586: PUSH
13587: LD_VAR 0 3
13591: PUSH
13592: FOR_IN
13593: IFFALSE 13618
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
13595: LD_VAR 0 2
13599: PPUSH
13600: LD_INT 260
13602: PPUSH
13603: LD_INT 235
13605: PPUSH
13606: LD_INT 8
13608: PPUSH
13609: LD_INT 0
13611: PPUSH
13612: CALL_OW 50
13616: GO 13592
13618: POP
13619: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
13620: LD_ADDR_EXP 102
13624: PUSH
13625: LD_EXP 102
13629: PPUSH
13630: LD_INT 1
13632: PPUSH
13633: LD_INT 22
13635: PUSH
13636: LD_VAR 0 5
13640: PUSH
13641: EMPTY
13642: LIST
13643: LIST
13644: PUSH
13645: LD_INT 3
13647: PUSH
13648: LD_INT 21
13650: PUSH
13651: LD_INT 2
13653: PUSH
13654: EMPTY
13655: LIST
13656: LIST
13657: PUSH
13658: EMPTY
13659: LIST
13660: LIST
13661: PUSH
13662: EMPTY
13663: LIST
13664: LIST
13665: PPUSH
13666: CALL_OW 69
13670: PUSH
13671: LD_EXP 79
13675: PUSH
13676: LD_EXP 80
13680: PUSH
13681: EMPTY
13682: LIST
13683: LIST
13684: DIFF
13685: PPUSH
13686: CALL_OW 1
13690: ST_TO_ADDR
// uc_side := 0 ;
13691: LD_ADDR_OWVAR 20
13695: PUSH
13696: LD_INT 0
13698: ST_TO_ADDR
// uc_nation := 0 ;
13699: LD_ADDR_OWVAR 21
13703: PUSH
13704: LD_INT 0
13706: ST_TO_ADDR
// for i = 1 to 5 do
13707: LD_ADDR_VAR 0 2
13711: PUSH
13712: DOUBLE
13713: LD_INT 1
13715: DEC
13716: ST_TO_ADDR
13717: LD_INT 5
13719: PUSH
13720: FOR_TO
13721: IFFALSE 13758
// begin InitHc ;
13723: CALL_OW 19
// hc_class := class_apeman ;
13727: LD_ADDR_OWVAR 28
13731: PUSH
13732: LD_INT 12
13734: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
13735: CALL_OW 44
13739: PPUSH
13740: LD_INT 299
13742: PPUSH
13743: LD_INT 229
13745: PPUSH
13746: LD_INT 10
13748: PPUSH
13749: LD_INT 0
13751: PPUSH
13752: CALL_OW 50
// end ;
13756: GO 13720
13758: POP
13759: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
13760: LD_EXP 79
13764: PPUSH
13765: LD_INT 259
13767: PPUSH
13768: LD_INT 235
13770: PPUSH
13771: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
13775: LD_EXP 79
13779: PPUSH
13780: LD_INT 262
13782: PPUSH
13783: LD_INT 235
13785: PPUSH
13786: CALL_OW 178
// if Simms then
13790: LD_EXP 80
13794: IFFALSE 13825
// begin ComMoveXY ( Simms , 262 , 235 ) ;
13796: LD_EXP 80
13800: PPUSH
13801: LD_INT 262
13803: PPUSH
13804: LD_INT 235
13806: PPUSH
13807: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
13811: LD_EXP 80
13815: PPUSH
13816: LD_EXP 79
13820: PPUSH
13821: CALL_OW 179
// end ; uc_side := 7 ;
13825: LD_ADDR_OWVAR 20
13829: PUSH
13830: LD_INT 7
13832: ST_TO_ADDR
// uc_nation := 1 ;
13833: LD_ADDR_OWVAR 21
13837: PUSH
13838: LD_INT 1
13840: ST_TO_ADDR
// bc_type := b_control_tower ;
13841: LD_ADDR_OWVAR 42
13845: PUSH
13846: LD_INT 36
13848: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 268 , 251 , 4 ) ;
13849: LD_ADDR_VAR 0 7
13853: PUSH
13854: LD_INT 268
13856: PPUSH
13857: LD_INT 251
13859: PPUSH
13860: LD_INT 4
13862: PPUSH
13863: CALL_OW 47
13867: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
13868: LD_INT 0
13870: PPUSH
13871: LD_INT 10
13873: PPUSH
13874: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , b ) ;
13878: CALL_OW 44
13882: PPUSH
13883: LD_VAR 0 7
13887: PPUSH
13888: CALL_OW 52
// end ;
13892: LD_VAR 0 1
13896: RET
// every 9 9$00 trigger allianceActive and not allianceDestroyed and FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_lab_full ] ] ) do var i , tmp , target ;
13897: LD_EXP 31
13901: PUSH
13902: LD_EXP 23
13906: NOT
13907: AND
13908: PUSH
13909: LD_INT 22
13911: PUSH
13912: LD_INT 7
13914: PUSH
13915: EMPTY
13916: LIST
13917: LIST
13918: PUSH
13919: LD_INT 30
13921: PUSH
13922: LD_INT 8
13924: PUSH
13925: EMPTY
13926: LIST
13927: LIST
13928: PUSH
13929: EMPTY
13930: LIST
13931: LIST
13932: PPUSH
13933: CALL_OW 69
13937: AND
13938: IFFALSE 14166
13940: GO 13942
13942: DISABLE
13943: LD_INT 0
13945: PPUSH
13946: PPUSH
13947: PPUSH
// begin enable ;
13948: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
13949: LD_ADDR_VAR 0 2
13953: PUSH
13954: LD_INT 81
13956: PUSH
13957: LD_INT 7
13959: PUSH
13960: EMPTY
13961: LIST
13962: LIST
13963: PUSH
13964: LD_INT 2
13966: PUSH
13967: LD_INT 32
13969: PUSH
13970: LD_INT 3
13972: PUSH
13973: EMPTY
13974: LIST
13975: LIST
13976: PUSH
13977: LD_INT 30
13979: PUSH
13980: LD_INT 30
13982: PUSH
13983: EMPTY
13984: LIST
13985: LIST
13986: PUSH
13987: LD_INT 30
13989: PUSH
13990: LD_INT 28
13992: PUSH
13993: EMPTY
13994: LIST
13995: LIST
13996: PUSH
13997: LD_INT 34
13999: PUSH
14000: LD_INT 49
14002: PUSH
14003: EMPTY
14004: LIST
14005: LIST
14006: PUSH
14007: LD_INT 34
14009: PUSH
14010: LD_INT 10
14012: PUSH
14013: EMPTY
14014: LIST
14015: LIST
14016: PUSH
14017: LD_INT 34
14019: PUSH
14020: LD_INT 8
14022: PUSH
14023: EMPTY
14024: LIST
14025: LIST
14026: PUSH
14027: EMPTY
14028: LIST
14029: LIST
14030: LIST
14031: LIST
14032: LIST
14033: LIST
14034: LIST
14035: PUSH
14036: EMPTY
14037: LIST
14038: LIST
14039: PPUSH
14040: CALL_OW 69
14044: ST_TO_ADDR
// if not tmp then
14045: LD_VAR 0 2
14049: NOT
14050: IFFALSE 14054
// exit ;
14052: GO 14166
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
14054: LD_VAR 0 2
14058: PPUSH
14059: LD_INT 34
14061: PUSH
14062: LD_INT 8
14064: PUSH
14065: EMPTY
14066: LIST
14067: LIST
14068: PPUSH
14069: CALL_OW 72
14073: IFFALSE 14106
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
14075: LD_ADDR_VAR 0 3
14079: PUSH
14080: LD_VAR 0 2
14084: PPUSH
14085: LD_INT 34
14087: PUSH
14088: LD_INT 8
14090: PUSH
14091: EMPTY
14092: LIST
14093: LIST
14094: PPUSH
14095: CALL_OW 72
14099: PUSH
14100: LD_INT 1
14102: ARRAY
14103: ST_TO_ADDR
14104: GO 14130
// target := tmp [ rand ( 1 , tmp ) ] ;
14106: LD_ADDR_VAR 0 3
14110: PUSH
14111: LD_VAR 0 2
14115: PUSH
14116: LD_INT 1
14118: PPUSH
14119: LD_VAR 0 2
14123: PPUSH
14124: CALL_OW 12
14128: ARRAY
14129: ST_TO_ADDR
// if GetSide ( target ) = 1 then
14130: LD_VAR 0 3
14134: PPUSH
14135: CALL_OW 255
14139: PUSH
14140: LD_INT 1
14142: EQUAL
14143: IFFALSE 14154
// CenterNowOnUnits ( target ) ;
14145: LD_VAR 0 3
14149: PPUSH
14150: CALL_OW 87
// SetLives ( target , 0 ) ;
14154: LD_VAR 0 3
14158: PPUSH
14159: LD_INT 0
14161: PPUSH
14162: CALL_OW 234
// end ;
14166: PPOPN 3
14168: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
14169: LD_EXP 23
14173: NOT
14174: PUSH
14175: LD_EXP 31
14179: AND
14180: IFFALSE 14696
14182: GO 14184
14184: DISABLE
14185: LD_INT 0
14187: PPUSH
14188: PPUSH
14189: PPUSH
// begin uc_side := 7 ;
14190: LD_ADDR_OWVAR 20
14194: PUSH
14195: LD_INT 7
14197: ST_TO_ADDR
// uc_nation := 1 ;
14198: LD_ADDR_OWVAR 21
14202: PUSH
14203: LD_INT 1
14205: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] , [ 94 , 114 ] ] ) ;
14206: LD_ADDR_VAR 0 3
14210: PUSH
14211: LD_INT 125
14213: PUSH
14214: LD_INT 163
14216: PUSH
14217: EMPTY
14218: LIST
14219: LIST
14220: PUSH
14221: LD_INT 185
14223: PUSH
14224: LD_INT 168
14226: PUSH
14227: EMPTY
14228: LIST
14229: LIST
14230: PUSH
14231: LD_INT 111
14233: PUSH
14234: LD_INT 97
14236: PUSH
14237: EMPTY
14238: LIST
14239: LIST
14240: PUSH
14241: LD_INT 94
14243: PUSH
14244: LD_INT 114
14246: PUSH
14247: EMPTY
14248: LIST
14249: LIST
14250: PUSH
14251: EMPTY
14252: LIST
14253: LIST
14254: LIST
14255: LIST
14256: PPUSH
14257: CALL 108109 0 1
14261: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
14262: LD_ADDR_EXP 96
14266: PUSH
14267: EMPTY
14268: ST_TO_ADDR
// for i = 1 to Difficulty do
14269: LD_ADDR_VAR 0 1
14273: PUSH
14274: DOUBLE
14275: LD_INT 1
14277: DEC
14278: ST_TO_ADDR
14279: LD_OWVAR 67
14283: PUSH
14284: FOR_TO
14285: IFFALSE 14443
// begin InitHc ;
14287: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
14291: LD_INT 0
14293: PPUSH
14294: LD_INT 8
14296: PPUSH
14297: CALL_OW 381
// un := CreateHuman ;
14301: LD_ADDR_VAR 0 2
14305: PUSH
14306: CALL_OW 44
14310: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
14311: LD_VAR 0 2
14315: PPUSH
14316: LD_INT 258
14318: PPUSH
14319: LD_INT 267
14321: PPUSH
14322: LD_INT 4
14324: PPUSH
14325: LD_INT 0
14327: PPUSH
14328: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
14332: LD_ADDR_EXP 96
14336: PUSH
14337: LD_EXP 96
14341: PUSH
14342: LD_VAR 0 2
14346: UNION
14347: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
14348: LD_VAR 0 2
14352: PPUSH
14353: LD_VAR 0 3
14357: PUSH
14358: LD_VAR 0 1
14362: ARRAY
14363: PUSH
14364: LD_INT 1
14366: ARRAY
14367: PPUSH
14368: LD_VAR 0 3
14372: PUSH
14373: LD_VAR 0 1
14377: ARRAY
14378: PUSH
14379: LD_INT 2
14381: ARRAY
14382: PPUSH
14383: LD_INT 4
14385: PPUSH
14386: LD_INT 1
14388: PPUSH
14389: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
14393: LD_VAR 0 2
14397: PPUSH
14398: LD_VAR 0 3
14402: PUSH
14403: LD_VAR 0 1
14407: ARRAY
14408: PUSH
14409: LD_INT 1
14411: ARRAY
14412: PPUSH
14413: LD_VAR 0 3
14417: PUSH
14418: LD_VAR 0 1
14422: ARRAY
14423: PUSH
14424: LD_INT 2
14426: ARRAY
14427: PPUSH
14428: CALL_OW 171
// AddComInvisible ( un ) ;
14432: LD_VAR 0 2
14436: PPUSH
14437: CALL_OW 212
// end ;
14441: GO 14284
14443: POP
14444: POP
// repeat wait ( 0 0$45 ) ;
14445: LD_INT 1575
14447: PPUSH
14448: CALL_OW 67
// for i in allianceSpecialForce do
14452: LD_ADDR_VAR 0 1
14456: PUSH
14457: LD_EXP 96
14461: PUSH
14462: FOR_IN
14463: IFFALSE 14681
// begin if IsInvisible ( i ) then
14465: LD_VAR 0 1
14469: PPUSH
14470: CALL_OW 571
14474: IFFALSE 14650
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , 25 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
14476: LD_ADDR_VAR 0 3
14480: PUSH
14481: LD_INT 22
14483: PUSH
14484: LD_INT 1
14486: PUSH
14487: EMPTY
14488: LIST
14489: LIST
14490: PUSH
14491: LD_INT 50
14493: PUSH
14494: EMPTY
14495: LIST
14496: PUSH
14497: LD_INT 56
14499: PUSH
14500: EMPTY
14501: LIST
14502: PUSH
14503: LD_INT 91
14505: PUSH
14506: LD_VAR 0 1
14510: PUSH
14511: LD_INT 25
14513: PUSH
14514: EMPTY
14515: LIST
14516: LIST
14517: LIST
14518: PUSH
14519: LD_INT 2
14521: PUSH
14522: LD_INT 25
14524: PUSH
14525: LD_INT 1
14527: PUSH
14528: EMPTY
14529: LIST
14530: LIST
14531: PUSH
14532: LD_INT 25
14534: PUSH
14535: LD_INT 2
14537: PUSH
14538: EMPTY
14539: LIST
14540: LIST
14541: PUSH
14542: LD_INT 25
14544: PUSH
14545: LD_INT 3
14547: PUSH
14548: EMPTY
14549: LIST
14550: LIST
14551: PUSH
14552: LD_INT 25
14554: PUSH
14555: LD_INT 4
14557: PUSH
14558: EMPTY
14559: LIST
14560: LIST
14561: PUSH
14562: LD_INT 25
14564: PUSH
14565: LD_INT 5
14567: PUSH
14568: EMPTY
14569: LIST
14570: LIST
14571: PUSH
14572: LD_INT 25
14574: PUSH
14575: LD_INT 8
14577: PUSH
14578: EMPTY
14579: LIST
14580: LIST
14581: PUSH
14582: EMPTY
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: LIST
14589: LIST
14590: PUSH
14591: EMPTY
14592: LIST
14593: LIST
14594: LIST
14595: LIST
14596: LIST
14597: PPUSH
14598: CALL_OW 69
14602: ST_TO_ADDR
// if not tmp then
14603: LD_VAR 0 3
14607: NOT
14608: IFFALSE 14612
// continue ;
14610: GO 14462
// if Prob ( 30 * Difficulty ) then
14612: LD_INT 30
14614: PUSH
14615: LD_OWVAR 67
14619: MUL
14620: PPUSH
14621: CALL_OW 13
14625: IFFALSE 14650
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
14627: LD_VAR 0 3
14631: PUSH
14632: LD_INT 1
14634: PPUSH
14635: LD_VAR 0 3
14639: PPUSH
14640: CALL_OW 12
14644: ARRAY
14645: PPUSH
14646: CALL 35362 0 1
// end ; if IsDead ( i ) then
14650: LD_VAR 0 1
14654: PPUSH
14655: CALL_OW 301
14659: IFFALSE 14679
// begin allianceSpecialForce := allianceSpecialForce diff i ;
14661: LD_ADDR_EXP 96
14665: PUSH
14666: LD_EXP 96
14670: PUSH
14671: LD_VAR 0 1
14675: DIFF
14676: ST_TO_ADDR
// continue ;
14677: GO 14462
// end ; end ;
14679: GO 14462
14681: POP
14682: POP
// until allianceDestroyed or not allianceSpecialForce ;
14683: LD_EXP 23
14687: PUSH
14688: LD_EXP 96
14692: NOT
14693: OR
14694: IFFALSE 14445
// end ;
14696: PPOPN 3
14698: END
// every 0 0$30 trigger allianceActive and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_bweapon , us_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ] ) do var i , un , tmp , e ;
14699: LD_EXP 31
14703: PUSH
14704: LD_INT 22
14706: PUSH
14707: LD_INT 1
14709: PUSH
14710: EMPTY
14711: LIST
14712: LIST
14713: PUSH
14714: LD_INT 2
14716: PUSH
14717: LD_INT 35
14719: PUSH
14720: LD_INT 8
14722: PUSH
14723: EMPTY
14724: LIST
14725: LIST
14726: PUSH
14727: LD_INT 34
14729: PUSH
14730: LD_INT 8
14732: PUSH
14733: EMPTY
14734: LIST
14735: LIST
14736: PUSH
14737: EMPTY
14738: LIST
14739: LIST
14740: LIST
14741: PUSH
14742: EMPTY
14743: LIST
14744: LIST
14745: PPUSH
14746: CALL_OW 69
14750: AND
14751: IFFALSE 15151
14753: GO 14755
14755: DISABLE
14756: LD_INT 0
14758: PPUSH
14759: PPUSH
14760: PPUSH
14761: PPUSH
// begin for i := 1 to [ 6 , 8 , 10 , 12 ] [ Difficulty ] do
14762: LD_ADDR_VAR 0 1
14766: PUSH
14767: DOUBLE
14768: LD_INT 1
14770: DEC
14771: ST_TO_ADDR
14772: LD_INT 6
14774: PUSH
14775: LD_INT 8
14777: PUSH
14778: LD_INT 10
14780: PUSH
14781: LD_INT 12
14783: PUSH
14784: EMPTY
14785: LIST
14786: LIST
14787: LIST
14788: LIST
14789: PUSH
14790: LD_OWVAR 67
14794: ARRAY
14795: PUSH
14796: FOR_TO
14797: IFFALSE 14989
// begin uc_side := 7 ;
14799: LD_ADDR_OWVAR 20
14803: PUSH
14804: LD_INT 7
14806: ST_TO_ADDR
// uc_nation := 1 ;
14807: LD_ADDR_OWVAR 21
14811: PUSH
14812: LD_INT 1
14814: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , [ control_remote , control_computer ] [ rand ( 1 , 2 ) ] , [ us_heavy_gun , us_laser ] [ rand ( 1 , 2 ) ] , 100 ) ;
14815: LD_INT 5
14817: PPUSH
14818: LD_INT 3
14820: PPUSH
14821: LD_INT 2
14823: PUSH
14824: LD_INT 3
14826: PUSH
14827: EMPTY
14828: LIST
14829: LIST
14830: PUSH
14831: LD_INT 1
14833: PPUSH
14834: LD_INT 2
14836: PPUSH
14837: CALL_OW 12
14841: ARRAY
14842: PPUSH
14843: LD_INT 6
14845: PUSH
14846: LD_INT 9
14848: PUSH
14849: EMPTY
14850: LIST
14851: LIST
14852: PUSH
14853: LD_INT 1
14855: PPUSH
14856: LD_INT 2
14858: PPUSH
14859: CALL_OW 12
14863: ARRAY
14864: PPUSH
14865: LD_INT 100
14867: PPUSH
14868: CALL 75133 0 5
// un := CreateVehicle ;
14872: LD_ADDR_VAR 0 2
14876: PUSH
14877: CALL_OW 45
14881: ST_TO_ADDR
// SetDir ( un , 4 ) ;
14882: LD_VAR 0 2
14886: PPUSH
14887: LD_INT 4
14889: PPUSH
14890: CALL_OW 233
// PlaceUnitXYR ( un , 307 , 219 , 6 , false ) ;
14894: LD_VAR 0 2
14898: PPUSH
14899: LD_INT 307
14901: PPUSH
14902: LD_INT 219
14904: PPUSH
14905: LD_INT 6
14907: PPUSH
14908: LD_INT 0
14910: PPUSH
14911: CALL_OW 50
// if GetControl ( un ) = control_remote then
14915: LD_VAR 0 2
14919: PPUSH
14920: CALL_OW 263
14924: PUSH
14925: LD_INT 2
14927: EQUAL
14928: IFFALSE 14939
// Connect ( un ) ;
14930: LD_VAR 0 2
14934: PPUSH
14935: CALL 78601 0 1
// TeleportUnit ( un , 124 , 92 , 12 , true ) ;
14939: LD_VAR 0 2
14943: PPUSH
14944: LD_INT 124
14946: PPUSH
14947: LD_INT 92
14949: PPUSH
14950: LD_INT 12
14952: PPUSH
14953: LD_INT 1
14955: PPUSH
14956: CALL_OW 483
// tmp := Join ( tmp , un ) ;
14960: LD_ADDR_VAR 0 3
14964: PUSH
14965: LD_VAR 0 3
14969: PPUSH
14970: LD_VAR 0 2
14974: PPUSH
14975: CALL 108004 0 2
14979: ST_TO_ADDR
// wait ( 0 0$0.3 ) ;
14980: LD_INT 10
14982: PPUSH
14983: CALL_OW 67
// end ;
14987: GO 14796
14989: POP
14990: POP
// repeat wait ( 0 0$2 ) ;
14991: LD_INT 70
14993: PPUSH
14994: CALL_OW 67
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) ;
14998: LD_ADDR_VAR 0 4
15002: PUSH
15003: LD_INT 22
15005: PUSH
15006: LD_INT 1
15008: PUSH
15009: EMPTY
15010: LIST
15011: LIST
15012: PUSH
15013: LD_INT 34
15015: PUSH
15016: LD_INT 8
15018: PUSH
15019: EMPTY
15020: LIST
15021: LIST
15022: PUSH
15023: EMPTY
15024: LIST
15025: LIST
15026: PPUSH
15027: CALL_OW 69
15031: ST_TO_ADDR
// if not e then
15032: LD_VAR 0 4
15036: NOT
15037: IFFALSE 15073
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
15039: LD_ADDR_VAR 0 4
15043: PUSH
15044: LD_INT 22
15046: PUSH
15047: LD_INT 1
15049: PUSH
15050: EMPTY
15051: LIST
15052: LIST
15053: PUSH
15054: LD_INT 21
15056: PUSH
15057: LD_INT 2
15059: PUSH
15060: EMPTY
15061: LIST
15062: LIST
15063: PUSH
15064: EMPTY
15065: LIST
15066: LIST
15067: PPUSH
15068: CALL_OW 69
15072: ST_TO_ADDR
// for i in tmp do
15073: LD_ADDR_VAR 0 1
15077: PUSH
15078: LD_VAR 0 3
15082: PUSH
15083: FOR_IN
15084: IFFALSE 15142
// if not IsOK ( i ) then
15086: LD_VAR 0 1
15090: PPUSH
15091: CALL_OW 302
15095: NOT
15096: IFFALSE 15116
// tmp := tmp diff i else
15098: LD_ADDR_VAR 0 3
15102: PUSH
15103: LD_VAR 0 3
15107: PUSH
15108: LD_VAR 0 1
15112: DIFF
15113: ST_TO_ADDR
15114: GO 15140
// ComAttackUnit ( i , NearestUnitToUnit ( e , i ) ) ;
15116: LD_VAR 0 1
15120: PPUSH
15121: LD_VAR 0 4
15125: PPUSH
15126: LD_VAR 0 1
15130: PPUSH
15131: CALL_OW 74
15135: PPUSH
15136: CALL_OW 115
15140: GO 15083
15142: POP
15143: POP
// until not tmp ;
15144: LD_VAR 0 3
15148: NOT
15149: IFFALSE 14991
// end ;
15151: PPOPN 4
15153: END
// every 8 8$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport , p ;
15154: LD_EXP 23
15158: NOT
15159: PUSH
15160: LD_EXP 31
15164: AND
15165: IFFALSE 16239
15167: GO 15169
15169: DISABLE
15170: LD_INT 0
15172: PPUSH
15173: PPUSH
15174: PPUSH
15175: PPUSH
15176: PPUSH
// begin enable ;
15177: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
15178: LD_INT 22
15180: PUSH
15181: LD_INT 7
15183: PUSH
15184: EMPTY
15185: LIST
15186: LIST
15187: PUSH
15188: LD_INT 30
15190: PUSH
15191: LD_INT 3
15193: PUSH
15194: EMPTY
15195: LIST
15196: LIST
15197: PUSH
15198: EMPTY
15199: LIST
15200: LIST
15201: PPUSH
15202: CALL_OW 69
15206: NOT
15207: IFFALSE 15211
// exit ;
15209: GO 16239
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
15211: LD_ADDR_VAR 0 4
15215: PUSH
15216: LD_INT 22
15218: PUSH
15219: LD_INT 7
15221: PUSH
15222: EMPTY
15223: LIST
15224: LIST
15225: PUSH
15226: LD_INT 30
15228: PUSH
15229: LD_INT 34
15231: PUSH
15232: EMPTY
15233: LIST
15234: LIST
15235: PUSH
15236: EMPTY
15237: LIST
15238: LIST
15239: PPUSH
15240: CALL_OW 69
15244: ST_TO_ADDR
// if Prob ( 40 ) then
15245: LD_INT 40
15247: PPUSH
15248: CALL_OW 13
15252: IFFALSE 15398
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
15254: LD_INT 1
15256: PPUSH
15257: LD_INT 5
15259: PUSH
15260: LD_INT 3
15262: PUSH
15263: LD_INT 2
15265: PUSH
15266: LD_INT 6
15268: PUSH
15269: EMPTY
15270: LIST
15271: LIST
15272: LIST
15273: LIST
15274: PUSH
15275: LD_INT 5
15277: PUSH
15278: LD_INT 3
15280: PUSH
15281: LD_INT 2
15283: PUSH
15284: LD_INT 6
15286: PUSH
15287: EMPTY
15288: LIST
15289: LIST
15290: LIST
15291: LIST
15292: PUSH
15293: LD_INT 5
15295: PUSH
15296: LD_INT 3
15298: PUSH
15299: LD_INT 2
15301: PUSH
15302: LD_INT 6
15304: PUSH
15305: EMPTY
15306: LIST
15307: LIST
15308: LIST
15309: LIST
15310: PUSH
15311: LD_INT 5
15313: PUSH
15314: LD_INT 3
15316: PUSH
15317: LD_INT 2
15319: PUSH
15320: LD_INT 9
15322: PUSH
15323: EMPTY
15324: LIST
15325: LIST
15326: LIST
15327: LIST
15328: PUSH
15329: LD_INT 24
15331: PUSH
15332: LD_INT 3
15334: PUSH
15335: LD_INT 3
15337: PUSH
15338: LD_INT 45
15340: PUSH
15341: EMPTY
15342: LIST
15343: LIST
15344: LIST
15345: LIST
15346: PUSH
15347: LD_INT 24
15349: PUSH
15350: LD_INT 3
15352: PUSH
15353: LD_INT 3
15355: PUSH
15356: LD_INT 47
15358: PUSH
15359: EMPTY
15360: LIST
15361: LIST
15362: LIST
15363: LIST
15364: PUSH
15365: LD_INT 24
15367: PUSH
15368: LD_INT 3
15370: PUSH
15371: LD_INT 3
15373: PUSH
15374: LD_INT 45
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: LIST
15381: LIST
15382: PUSH
15383: EMPTY
15384: LIST
15385: LIST
15386: LIST
15387: LIST
15388: LIST
15389: LIST
15390: LIST
15391: PPUSH
15392: CALL 63846 0 2
// end else
15396: GO 15540
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
15398: LD_INT 1
15400: PPUSH
15401: LD_INT 24
15403: PUSH
15404: LD_INT 3
15406: PUSH
15407: LD_INT 3
15409: PUSH
15410: LD_INT 47
15412: PUSH
15413: EMPTY
15414: LIST
15415: LIST
15416: LIST
15417: LIST
15418: PUSH
15419: LD_INT 24
15421: PUSH
15422: LD_INT 3
15424: PUSH
15425: LD_INT 3
15427: PUSH
15428: LD_INT 47
15430: PUSH
15431: EMPTY
15432: LIST
15433: LIST
15434: LIST
15435: LIST
15436: PUSH
15437: LD_INT 5
15439: PUSH
15440: LD_INT 3
15442: PUSH
15443: LD_INT 2
15445: PUSH
15446: LD_INT 9
15448: PUSH
15449: EMPTY
15450: LIST
15451: LIST
15452: LIST
15453: LIST
15454: PUSH
15455: LD_INT 5
15457: PUSH
15458: LD_INT 3
15460: PUSH
15461: LD_INT 2
15463: PUSH
15464: LD_INT 9
15466: PUSH
15467: EMPTY
15468: LIST
15469: LIST
15470: LIST
15471: LIST
15472: PUSH
15473: LD_INT 5
15475: PUSH
15476: LD_INT 3
15478: PUSH
15479: LD_INT 2
15481: PUSH
15482: LD_INT 9
15484: PUSH
15485: EMPTY
15486: LIST
15487: LIST
15488: LIST
15489: LIST
15490: PUSH
15491: LD_INT 24
15493: PUSH
15494: LD_INT 1
15496: PUSH
15497: LD_INT 3
15499: PUSH
15500: LD_INT 45
15502: PUSH
15503: EMPTY
15504: LIST
15505: LIST
15506: LIST
15507: LIST
15508: PUSH
15509: LD_INT 24
15511: PUSH
15512: LD_INT 1
15514: PUSH
15515: LD_INT 3
15517: PUSH
15518: LD_INT 45
15520: PUSH
15521: EMPTY
15522: LIST
15523: LIST
15524: LIST
15525: LIST
15526: PUSH
15527: EMPTY
15528: LIST
15529: LIST
15530: LIST
15531: LIST
15532: LIST
15533: LIST
15534: LIST
15535: PPUSH
15536: CALL 63846 0 2
// end ; wait ( 2 2$00 ) ;
15540: LD_INT 4200
15542: PPUSH
15543: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_crane ] ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 1 ] ;
15547: LD_ADDR_VAR 0 2
15551: PUSH
15552: LD_INT 22
15554: PUSH
15555: LD_INT 7
15557: PUSH
15558: EMPTY
15559: LIST
15560: LIST
15561: PUSH
15562: LD_INT 21
15564: PUSH
15565: LD_INT 2
15567: PUSH
15568: EMPTY
15569: LIST
15570: LIST
15571: PUSH
15572: LD_INT 3
15574: PUSH
15575: LD_INT 34
15577: PUSH
15578: LD_INT 13
15580: PUSH
15581: EMPTY
15582: LIST
15583: LIST
15584: PUSH
15585: EMPTY
15586: LIST
15587: LIST
15588: PUSH
15589: LD_INT 3
15591: PUSH
15592: LD_INT 34
15594: PUSH
15595: LD_INT 12
15597: PUSH
15598: EMPTY
15599: LIST
15600: LIST
15601: PUSH
15602: EMPTY
15603: LIST
15604: LIST
15605: PUSH
15606: LD_INT 3
15608: PUSH
15609: LD_INT 34
15611: PUSH
15612: LD_INT 51
15614: PUSH
15615: EMPTY
15616: LIST
15617: LIST
15618: PUSH
15619: EMPTY
15620: LIST
15621: LIST
15622: PUSH
15623: LD_INT 3
15625: PUSH
15626: LD_INT 34
15628: PUSH
15629: LD_INT 52
15631: PUSH
15632: EMPTY
15633: LIST
15634: LIST
15635: PUSH
15636: EMPTY
15637: LIST
15638: LIST
15639: PUSH
15640: EMPTY
15641: LIST
15642: LIST
15643: LIST
15644: LIST
15645: LIST
15646: LIST
15647: PPUSH
15648: CALL_OW 69
15652: PUSH
15653: LD_EXP 124
15657: PUSH
15658: LD_INT 1
15660: ARRAY
15661: DIFF
15662: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
15663: LD_ADDR_EXP 121
15667: PUSH
15668: LD_EXP 121
15672: PPUSH
15673: LD_INT 1
15675: PPUSH
15676: LD_EXP 121
15680: PUSH
15681: LD_INT 1
15683: ARRAY
15684: PUSH
15685: LD_VAR 0 2
15689: DIFF
15690: PPUSH
15691: CALL_OW 1
15695: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
15696: LD_ADDR_VAR 0 3
15700: PUSH
15701: LD_INT 0
15703: PPUSH
15704: LD_INT 1
15706: PPUSH
15707: CALL_OW 12
15711: ST_TO_ADDR
// p := 0 ;
15712: LD_ADDR_VAR 0 5
15716: PUSH
15717: LD_INT 0
15719: ST_TO_ADDR
// if target then
15720: LD_VAR 0 3
15724: IFFALSE 15915
// begin for i in tmp do
15726: LD_ADDR_VAR 0 1
15730: PUSH
15731: LD_VAR 0 2
15735: PUSH
15736: FOR_IN
15737: IFFALSE 15762
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
15739: LD_VAR 0 1
15743: PPUSH
15744: LD_INT 179
15746: PPUSH
15747: LD_INT 209
15749: PPUSH
15750: LD_INT 8
15752: PPUSH
15753: LD_INT 1
15755: PPUSH
15756: CALL_OW 483
15760: GO 15736
15762: POP
15763: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15764: LD_ADDR_VAR 0 2
15768: PUSH
15769: LD_VAR 0 2
15773: PPUSH
15774: LD_INT 24
15776: PUSH
15777: LD_INT 250
15779: PUSH
15780: EMPTY
15781: LIST
15782: LIST
15783: PPUSH
15784: CALL_OW 72
15788: ST_TO_ADDR
// for i in tmp do
15789: LD_ADDR_VAR 0 1
15793: PUSH
15794: LD_VAR 0 2
15798: PUSH
15799: FOR_IN
15800: IFFALSE 15840
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
15802: LD_VAR 0 1
15806: PPUSH
15807: LD_INT 179
15809: PPUSH
15810: LD_INT 209
15812: PPUSH
15813: CALL_OW 297
15817: PUSH
15818: LD_INT 9
15820: GREATER
15821: IFFALSE 15838
// ComMoveXY ( i , 179 , 209 ) ;
15823: LD_VAR 0 1
15827: PPUSH
15828: LD_INT 179
15830: PPUSH
15831: LD_INT 209
15833: PPUSH
15834: CALL_OW 111
15838: GO 15799
15840: POP
15841: POP
// wait ( 0 0$1 ) ;
15842: LD_INT 35
15844: PPUSH
15845: CALL_OW 67
// p := Inc ( p ) ;
15849: LD_ADDR_VAR 0 5
15853: PUSH
15854: LD_VAR 0 5
15858: PPUSH
15859: CALL 109365 0 1
15863: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
15864: LD_VAR 0 2
15868: PPUSH
15869: LD_INT 92
15871: PUSH
15872: LD_INT 179
15874: PUSH
15875: LD_INT 209
15877: PUSH
15878: LD_INT 9
15880: PUSH
15881: EMPTY
15882: LIST
15883: LIST
15884: LIST
15885: LIST
15886: PPUSH
15887: CALL_OW 72
15891: PUSH
15892: LD_VAR 0 2
15896: PUSH
15897: LD_INT 1
15899: MINUS
15900: GREATEREQUAL
15901: PUSH
15902: LD_VAR 0 5
15906: PUSH
15907: LD_INT 30
15909: GREATER
15910: OR
15911: IFFALSE 15764
// end else
15913: GO 16102
// begin for i in tmp do
15915: LD_ADDR_VAR 0 1
15919: PUSH
15920: LD_VAR 0 2
15924: PUSH
15925: FOR_IN
15926: IFFALSE 15951
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
15928: LD_VAR 0 1
15932: PPUSH
15933: LD_INT 285
15935: PPUSH
15936: LD_INT 163
15938: PPUSH
15939: LD_INT 8
15941: PPUSH
15942: LD_INT 1
15944: PPUSH
15945: CALL_OW 483
15949: GO 15925
15951: POP
15952: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15953: LD_ADDR_VAR 0 2
15957: PUSH
15958: LD_VAR 0 2
15962: PPUSH
15963: LD_INT 24
15965: PUSH
15966: LD_INT 250
15968: PUSH
15969: EMPTY
15970: LIST
15971: LIST
15972: PPUSH
15973: CALL_OW 72
15977: ST_TO_ADDR
// for i in tmp do
15978: LD_ADDR_VAR 0 1
15982: PUSH
15983: LD_VAR 0 2
15987: PUSH
15988: FOR_IN
15989: IFFALSE 16029
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
15991: LD_VAR 0 1
15995: PPUSH
15996: LD_INT 285
15998: PPUSH
15999: LD_INT 163
16001: PPUSH
16002: CALL_OW 297
16006: PUSH
16007: LD_INT 9
16009: GREATER
16010: IFFALSE 16027
// ComMoveXY ( i , 285 , 163 ) ;
16012: LD_VAR 0 1
16016: PPUSH
16017: LD_INT 285
16019: PPUSH
16020: LD_INT 163
16022: PPUSH
16023: CALL_OW 111
16027: GO 15988
16029: POP
16030: POP
// wait ( 0 0$1 ) ;
16031: LD_INT 35
16033: PPUSH
16034: CALL_OW 67
// p := Inc ( p ) ;
16038: LD_ADDR_VAR 0 5
16042: PUSH
16043: LD_VAR 0 5
16047: PPUSH
16048: CALL 109365 0 1
16052: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
16053: LD_VAR 0 2
16057: PPUSH
16058: LD_INT 92
16060: PUSH
16061: LD_INT 285
16063: PUSH
16064: LD_INT 163
16066: PUSH
16067: LD_INT 9
16069: PUSH
16070: EMPTY
16071: LIST
16072: LIST
16073: LIST
16074: LIST
16075: PPUSH
16076: CALL_OW 72
16080: PUSH
16081: LD_VAR 0 2
16085: PUSH
16086: LD_INT 1
16088: MINUS
16089: GREATEREQUAL
16090: PUSH
16091: LD_VAR 0 5
16095: PUSH
16096: LD_INT 30
16098: GREATER
16099: OR
16100: IFFALSE 15953
// end ; repeat wait ( 0 0$1 ) ;
16102: LD_INT 35
16104: PPUSH
16105: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
16109: LD_ADDR_VAR 0 2
16113: PUSH
16114: LD_VAR 0 2
16118: PPUSH
16119: LD_INT 50
16121: PUSH
16122: EMPTY
16123: LIST
16124: PPUSH
16125: CALL_OW 72
16129: ST_TO_ADDR
// for i in tmp do
16130: LD_ADDR_VAR 0 1
16134: PUSH
16135: LD_VAR 0 2
16139: PUSH
16140: FOR_IN
16141: IFFALSE 16230
// if GetWeapon ( i ) = ru_time_lapser then
16143: LD_VAR 0 1
16147: PPUSH
16148: CALL_OW 264
16152: PUSH
16153: LD_INT 49
16155: EQUAL
16156: IFFALSE 16194
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
16158: LD_VAR 0 1
16162: PPUSH
16163: LD_INT 81
16165: PUSH
16166: LD_INT 7
16168: PUSH
16169: EMPTY
16170: LIST
16171: LIST
16172: PPUSH
16173: CALL_OW 69
16177: PPUSH
16178: LD_VAR 0 1
16182: PPUSH
16183: CALL_OW 74
16187: PPUSH
16188: CALL_OW 112
16192: GO 16228
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
16194: LD_VAR 0 1
16198: PPUSH
16199: LD_INT 81
16201: PUSH
16202: LD_INT 7
16204: PUSH
16205: EMPTY
16206: LIST
16207: LIST
16208: PPUSH
16209: CALL_OW 69
16213: PPUSH
16214: LD_VAR 0 1
16218: PPUSH
16219: CALL_OW 74
16223: PPUSH
16224: CALL_OW 115
16228: GO 16140
16230: POP
16231: POP
// until not tmp ;
16232: LD_VAR 0 2
16236: NOT
16237: IFFALSE 16102
// end ;
16239: PPOPN 5
16241: END
// every 1 1$30 trigger allianceActive and IsOk ( Roth ) and Difficulty > 2 do
16242: LD_EXP 31
16246: PUSH
16247: LD_EXP 79
16251: PPUSH
16252: CALL_OW 302
16256: AND
16257: PUSH
16258: LD_OWVAR 67
16262: PUSH
16263: LD_INT 2
16265: GREATER
16266: AND
16267: IFFALSE 16367
16269: GO 16271
16271: DISABLE
// begin enable ;
16272: ENABLE
// if GetDistUnitXY ( Roth , 245 , 234 ) > 6 then
16273: LD_EXP 79
16277: PPUSH
16278: LD_INT 245
16280: PPUSH
16281: LD_INT 234
16283: PPUSH
16284: CALL_OW 297
16288: PUSH
16289: LD_INT 6
16291: GREATER
16292: IFFALSE 16311
// ComMoveXY ( Roth , 245 , 234 ) else
16294: LD_EXP 79
16298: PPUSH
16299: LD_INT 245
16301: PPUSH
16302: LD_INT 234
16304: PPUSH
16305: CALL_OW 111
16309: GO 16367
// ComMoveHex ( Roth , [ [ 259 , 235 ] , [ 252 , 209 ] , [ 275 , 235 ] ] [ rand ( 1 , 3 ) ] ) ;
16311: LD_EXP 79
16315: PPUSH
16316: LD_INT 259
16318: PUSH
16319: LD_INT 235
16321: PUSH
16322: EMPTY
16323: LIST
16324: LIST
16325: PUSH
16326: LD_INT 252
16328: PUSH
16329: LD_INT 209
16331: PUSH
16332: EMPTY
16333: LIST
16334: LIST
16335: PUSH
16336: LD_INT 275
16338: PUSH
16339: LD_INT 235
16341: PUSH
16342: EMPTY
16343: LIST
16344: LIST
16345: PUSH
16346: EMPTY
16347: LIST
16348: LIST
16349: LIST
16350: PUSH
16351: LD_INT 1
16353: PPUSH
16354: LD_INT 3
16356: PPUSH
16357: CALL_OW 12
16361: ARRAY
16362: PPUSH
16363: CALL 112156 0 2
// end ; end_of_file
16367: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
16368: LD_INT 0
16370: PPUSH
16371: PPUSH
16372: PPUSH
16373: PPUSH
// missionStage := 13 ;
16374: LD_ADDR_EXP 15
16378: PUSH
16379: LD_INT 13
16381: ST_TO_ADDR
// uc_side := 2 ;
16382: LD_ADDR_OWVAR 20
16386: PUSH
16387: LD_INT 2
16389: ST_TO_ADDR
// uc_nation := 2 ;
16390: LD_ADDR_OWVAR 21
16394: PUSH
16395: LD_INT 2
16397: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
16398: LD_ADDR_EXP 97
16402: PUSH
16403: LD_STRING Omar
16405: PPUSH
16406: CALL_OW 25
16410: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
16411: LD_EXP 97
16415: PPUSH
16416: LD_INT 4
16418: PPUSH
16419: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
16423: LD_EXP 97
16427: PPUSH
16428: LD_INT 242
16430: PPUSH
16431: LD_INT 75
16433: PPUSH
16434: LD_INT 0
16436: PPUSH
16437: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
16441: LD_ADDR_EXP 98
16445: PUSH
16446: LD_STRING Heike
16448: PPUSH
16449: CALL_OW 25
16453: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
16454: LD_INT 14
16456: PPUSH
16457: LD_INT 3
16459: PPUSH
16460: LD_INT 1
16462: PPUSH
16463: LD_INT 27
16465: PPUSH
16466: LD_INT 100
16468: PPUSH
16469: CALL 75133 0 5
// veh := CreateVehicle ;
16473: LD_ADDR_VAR 0 3
16477: PUSH
16478: CALL_OW 45
16482: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
16483: LD_VAR 0 3
16487: PPUSH
16488: LD_INT 2
16490: NEG
16491: PPUSH
16492: CALL_OW 242
// SetDir ( veh , 4 ) ;
16496: LD_VAR 0 3
16500: PPUSH
16501: LD_INT 4
16503: PPUSH
16504: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
16508: LD_VAR 0 3
16512: PPUSH
16513: LD_INT 241
16515: PPUSH
16516: LD_INT 72
16518: PPUSH
16519: LD_INT 0
16521: PPUSH
16522: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
16526: LD_EXP 98
16530: PPUSH
16531: LD_VAR 0 3
16535: PPUSH
16536: CALL_OW 52
// if KhatamStatus then
16540: LD_EXP 8
16544: IFFALSE 16607
// begin Khatam := NewCharacter ( Khatam ) ;
16546: LD_ADDR_EXP 99
16550: PUSH
16551: LD_STRING Khatam
16553: PPUSH
16554: CALL_OW 25
16558: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
16559: LD_EXP 99
16563: PPUSH
16564: LD_INT 245
16566: PPUSH
16567: LD_INT 78
16569: PPUSH
16570: LD_INT 3
16572: PPUSH
16573: LD_INT 0
16575: PPUSH
16576: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
16580: LD_EXP 99
16584: PPUSH
16585: LD_INT 4
16587: PPUSH
16588: LD_INT 10
16590: PPUSH
16591: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
16595: LD_EXP 99
16599: PPUSH
16600: LD_INT 4
16602: PPUSH
16603: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
16607: LD_ADDR_VAR 0 2
16611: PUSH
16612: DOUBLE
16613: LD_INT 1
16615: DEC
16616: ST_TO_ADDR
16617: LD_INT 2
16619: PUSH
16620: LD_INT 2
16622: PUSH
16623: LD_INT 3
16625: PUSH
16626: LD_INT 3
16628: PUSH
16629: EMPTY
16630: LIST
16631: LIST
16632: LIST
16633: LIST
16634: PUSH
16635: LD_OWVAR 67
16639: ARRAY
16640: PUSH
16641: FOR_TO
16642: IFFALSE 16708
// begin PrepareScientist ( false , 6 + Difficulty ) ;
16644: LD_INT 0
16646: PPUSH
16647: LD_INT 6
16649: PUSH
16650: LD_OWVAR 67
16654: PLUS
16655: PPUSH
16656: CALL_OW 384
// un := CreateHuman ;
16660: LD_ADDR_VAR 0 4
16664: PUSH
16665: CALL_OW 44
16669: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
16670: LD_VAR 0 4
16674: PPUSH
16675: LD_INT 28
16677: PUSH
16678: LD_INT 29
16680: PUSH
16681: EMPTY
16682: LIST
16683: LIST
16684: PUSH
16685: LD_VAR 0 2
16689: PUSH
16690: LD_INT 2
16692: MOD
16693: PUSH
16694: LD_INT 1
16696: PLUS
16697: ARRAY
16698: PPUSH
16699: LD_INT 0
16701: PPUSH
16702: CALL_OW 49
// end ;
16706: GO 16641
16708: POP
16709: POP
// for i = 1 to 6 do
16710: LD_ADDR_VAR 0 2
16714: PUSH
16715: DOUBLE
16716: LD_INT 1
16718: DEC
16719: ST_TO_ADDR
16720: LD_INT 6
16722: PUSH
16723: FOR_TO
16724: IFFALSE 16769
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
16726: LD_INT 0
16728: PPUSH
16729: LD_INT 6
16731: PUSH
16732: LD_OWVAR 67
16736: PLUS
16737: PPUSH
16738: CALL_OW 381
// un := CreateHuman ;
16742: LD_ADDR_VAR 0 4
16746: PUSH
16747: CALL_OW 44
16751: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16752: LD_VAR 0 4
16756: PPUSH
16757: LD_INT 32
16759: PPUSH
16760: LD_INT 0
16762: PPUSH
16763: CALL_OW 49
// end ;
16767: GO 16723
16769: POP
16770: POP
// for i = 1 to 3 do
16771: LD_ADDR_VAR 0 2
16775: PUSH
16776: DOUBLE
16777: LD_INT 1
16779: DEC
16780: ST_TO_ADDR
16781: LD_INT 3
16783: PUSH
16784: FOR_TO
16785: IFFALSE 16833
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
16787: LD_INT 0
16789: PPUSH
16790: LD_INT 8
16792: PPUSH
16793: LD_INT 6
16795: PUSH
16796: LD_OWVAR 67
16800: PLUS
16801: PPUSH
16802: CALL_OW 380
// un := CreateHuman ;
16806: LD_ADDR_VAR 0 4
16810: PUSH
16811: CALL_OW 44
16815: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16816: LD_VAR 0 4
16820: PPUSH
16821: LD_INT 32
16823: PPUSH
16824: LD_INT 0
16826: PPUSH
16827: CALL_OW 49
// end ;
16831: GO 16784
16833: POP
16834: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
16835: LD_ADDR_VAR 0 2
16839: PUSH
16840: DOUBLE
16841: LD_INT 1
16843: DEC
16844: ST_TO_ADDR
16845: LD_INT 2
16847: PUSH
16848: LD_INT 3
16850: PUSH
16851: LD_INT 4
16853: PUSH
16854: LD_INT 4
16856: PUSH
16857: EMPTY
16858: LIST
16859: LIST
16860: LIST
16861: LIST
16862: PUSH
16863: LD_OWVAR 67
16867: ARRAY
16868: PUSH
16869: FOR_TO
16870: IFFALSE 16960
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
16872: LD_INT 14
16874: PPUSH
16875: LD_INT 2
16877: PPUSH
16878: LD_INT 1
16880: PPUSH
16881: LD_INT 28
16883: PPUSH
16884: LD_INT 80
16886: PPUSH
16887: CALL 75133 0 5
// veh := CreateVehicle ;
16891: LD_ADDR_VAR 0 3
16895: PUSH
16896: CALL_OW 45
16900: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
16901: LD_VAR 0 3
16905: PPUSH
16906: LD_INT 3
16908: PPUSH
16909: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
16913: LD_VAR 0 3
16917: PPUSH
16918: LD_INT 29
16920: PPUSH
16921: LD_INT 0
16923: PPUSH
16924: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16928: LD_INT 0
16930: PPUSH
16931: LD_INT 6
16933: PUSH
16934: LD_OWVAR 67
16938: PLUS
16939: PPUSH
16940: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
16944: CALL_OW 44
16948: PPUSH
16949: LD_VAR 0 3
16953: PPUSH
16954: CALL_OW 52
// end ;
16958: GO 16869
16960: POP
16961: POP
// for i = 1 to 5 + Difficulty do
16962: LD_ADDR_VAR 0 2
16966: PUSH
16967: DOUBLE
16968: LD_INT 1
16970: DEC
16971: ST_TO_ADDR
16972: LD_INT 5
16974: PUSH
16975: LD_OWVAR 67
16979: PLUS
16980: PUSH
16981: FOR_TO
16982: IFFALSE 17109
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
16984: LD_INT 14
16986: PPUSH
16987: LD_INT 1
16989: PPUSH
16990: LD_INT 3
16992: PPUSH
16993: CALL_OW 12
16997: PPUSH
16998: LD_INT 1
17000: PPUSH
17001: LD_INT 28
17003: PUSH
17004: LD_INT 26
17006: PUSH
17007: LD_INT 27
17009: PUSH
17010: LD_INT 25
17012: PUSH
17013: EMPTY
17014: LIST
17015: LIST
17016: LIST
17017: LIST
17018: PUSH
17019: LD_VAR 0 2
17023: PUSH
17024: LD_INT 4
17026: MOD
17027: PUSH
17028: LD_INT 1
17030: PLUS
17031: ARRAY
17032: PPUSH
17033: LD_INT 80
17035: PPUSH
17036: CALL 75133 0 5
// veh := CreateVehicle ;
17040: LD_ADDR_VAR 0 3
17044: PUSH
17045: CALL_OW 45
17049: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
17050: LD_VAR 0 3
17054: PPUSH
17055: LD_INT 4
17057: PPUSH
17058: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
17062: LD_VAR 0 3
17066: PPUSH
17067: LD_INT 28
17069: PPUSH
17070: LD_INT 0
17072: PPUSH
17073: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
17077: LD_INT 0
17079: PPUSH
17080: LD_INT 6
17082: PUSH
17083: LD_OWVAR 67
17087: PLUS
17088: PPUSH
17089: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
17093: CALL_OW 44
17097: PPUSH
17098: LD_VAR 0 3
17102: PPUSH
17103: CALL_OW 52
// end ;
17107: GO 16981
17109: POP
17110: POP
// for i = 1 to Difficulty do
17111: LD_ADDR_VAR 0 2
17115: PUSH
17116: DOUBLE
17117: LD_INT 1
17119: DEC
17120: ST_TO_ADDR
17121: LD_OWVAR 67
17125: PUSH
17126: FOR_TO
17127: IFFALSE 17187
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
17129: LD_INT 14
17131: PPUSH
17132: LD_INT 3
17134: PPUSH
17135: LD_INT 5
17137: PPUSH
17138: LD_INT 29
17140: PPUSH
17141: LD_INT 80
17143: PPUSH
17144: CALL 75133 0 5
// veh := CreateVehicle ;
17148: LD_ADDR_VAR 0 3
17152: PUSH
17153: CALL_OW 45
17157: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
17158: LD_VAR 0 3
17162: PPUSH
17163: LD_INT 4
17165: PPUSH
17166: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
17170: LD_VAR 0 3
17174: PPUSH
17175: LD_INT 28
17177: PPUSH
17178: LD_INT 0
17180: PPUSH
17181: CALL_OW 49
// end ;
17185: GO 17126
17187: POP
17188: POP
// end ;
17189: LD_VAR 0 1
17193: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
17194: LD_INT 22
17196: PUSH
17197: LD_INT 2
17199: PUSH
17200: EMPTY
17201: LIST
17202: LIST
17203: PPUSH
17204: CALL_OW 69
17208: IFFALSE 17587
17210: GO 17212
17212: DISABLE
17213: LD_INT 0
17215: PPUSH
17216: PPUSH
17217: PPUSH
17218: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
17219: LD_ADDR_VAR 0 3
17223: PUSH
17224: LD_INT 22
17226: PUSH
17227: LD_INT 2
17229: PUSH
17230: EMPTY
17231: LIST
17232: LIST
17233: PUSH
17234: LD_INT 25
17236: PUSH
17237: LD_INT 4
17239: PUSH
17240: EMPTY
17241: LIST
17242: LIST
17243: PUSH
17244: EMPTY
17245: LIST
17246: LIST
17247: PPUSH
17248: CALL_OW 69
17252: PUSH
17253: LD_EXP 99
17257: DIFF
17258: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
17259: LD_ADDR_VAR 0 2
17263: PUSH
17264: LD_INT 22
17266: PUSH
17267: LD_INT 2
17269: PUSH
17270: EMPTY
17271: LIST
17272: LIST
17273: PPUSH
17274: CALL_OW 69
17278: PUSH
17279: LD_EXP 99
17283: PUSH
17284: LD_VAR 0 3
17288: UNION
17289: DIFF
17290: ST_TO_ADDR
// if Khatam then
17291: LD_EXP 99
17295: IFFALSE 17312
// ComMoveXY ( Khatam , 211 , 92 ) ;
17297: LD_EXP 99
17301: PPUSH
17302: LD_INT 211
17304: PPUSH
17305: LD_INT 92
17307: PPUSH
17308: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
17312: LD_INT 197
17314: PPUSH
17315: LD_INT 80
17317: PPUSH
17318: LD_INT 2
17320: PPUSH
17321: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
17325: LD_INT 213
17327: PPUSH
17328: LD_INT 90
17330: PPUSH
17331: LD_INT 2
17333: PPUSH
17334: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
17338: LD_INT 215
17340: PPUSH
17341: LD_INT 129
17343: PPUSH
17344: LD_INT 2
17346: PPUSH
17347: CALL_OW 441
// if sci then
17351: LD_VAR 0 3
17355: IFFALSE 17376
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
17357: LD_VAR 0 3
17361: PUSH
17362: LD_INT 1
17364: ARRAY
17365: PPUSH
17366: LD_INT 197
17368: PPUSH
17369: LD_INT 80
17371: PPUSH
17372: CALL_OW 158
// if sci > 1 then
17376: LD_VAR 0 3
17380: PUSH
17381: LD_INT 1
17383: GREATER
17384: IFFALSE 17405
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
17386: LD_VAR 0 3
17390: PUSH
17391: LD_INT 2
17393: ARRAY
17394: PPUSH
17395: LD_INT 213
17397: PPUSH
17398: LD_INT 90
17400: PPUSH
17401: CALL_OW 158
// if sci > 2 then
17405: LD_VAR 0 3
17409: PUSH
17410: LD_INT 2
17412: GREATER
17413: IFFALSE 17434
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
17415: LD_VAR 0 3
17419: PUSH
17420: LD_INT 3
17422: ARRAY
17423: PPUSH
17424: LD_INT 215
17426: PPUSH
17427: LD_INT 129
17429: PPUSH
17430: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
17434: LD_VAR 0 2
17438: PPUSH
17439: LD_INT 195
17441: PPUSH
17442: LD_INT 102
17444: PPUSH
17445: CALL_OW 114
// wait ( 0 0$5 ) ;
17449: LD_INT 175
17451: PPUSH
17452: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
17456: LD_INT 70
17458: PPUSH
17459: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
17463: LD_ADDR_VAR 0 4
17467: PUSH
17468: LD_INT 92
17470: PUSH
17471: LD_INT 195
17473: PUSH
17474: LD_INT 102
17476: PUSH
17477: LD_INT 36
17479: PUSH
17480: EMPTY
17481: LIST
17482: LIST
17483: LIST
17484: LIST
17485: PUSH
17486: LD_INT 22
17488: PUSH
17489: LD_INT 1
17491: PUSH
17492: EMPTY
17493: LIST
17494: LIST
17495: PUSH
17496: EMPTY
17497: LIST
17498: LIST
17499: PPUSH
17500: CALL_OW 69
17504: ST_TO_ADDR
// for i in tmp do
17505: LD_ADDR_VAR 0 1
17509: PUSH
17510: LD_VAR 0 2
17514: PUSH
17515: FOR_IN
17516: IFFALSE 17567
// if enemy then
17518: LD_VAR 0 4
17522: IFFALSE 17550
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
17524: LD_VAR 0 1
17528: PPUSH
17529: LD_VAR 0 4
17533: PPUSH
17534: LD_VAR 0 1
17538: PPUSH
17539: CALL_OW 74
17543: PPUSH
17544: CALL_OW 115
17548: GO 17565
// ComAgressiveMove ( i , 195 , 102 ) ;
17550: LD_VAR 0 1
17554: PPUSH
17555: LD_INT 195
17557: PPUSH
17558: LD_INT 102
17560: PPUSH
17561: CALL_OW 114
17565: GO 17515
17567: POP
17568: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
17569: LD_VAR 0 2
17573: PPUSH
17574: LD_INT 50
17576: PUSH
17577: EMPTY
17578: LIST
17579: PPUSH
17580: CALL_OW 72
17584: NOT
17585: IFFALSE 17456
// end ; end_of_file
17587: PPOPN 4
17589: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
17590: LD_INT 0
17592: PPUSH
17593: PPUSH
17594: PPUSH
17595: PPUSH
17596: PPUSH
17597: PPUSH
17598: PPUSH
17599: PPUSH
17600: PPUSH
// Video ( true ) ;
17601: LD_INT 1
17603: PPUSH
17604: CALL 107976 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
17608: LD_ADDR_VAR 0 5
17612: PUSH
17613: LD_INT 7
17615: PPUSH
17616: LD_INT 0
17618: PPUSH
17619: CALL_OW 517
17623: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
17624: LD_ADDR_VAR 0 2
17628: PUSH
17629: DOUBLE
17630: LD_INT 1
17632: DEC
17633: ST_TO_ADDR
17634: LD_VAR 0 5
17638: PUSH
17639: LD_INT 1
17641: ARRAY
17642: PUSH
17643: FOR_TO
17644: IFFALSE 17689
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
17646: LD_VAR 0 5
17650: PUSH
17651: LD_INT 1
17653: ARRAY
17654: PUSH
17655: LD_VAR 0 2
17659: ARRAY
17660: PPUSH
17661: LD_VAR 0 5
17665: PUSH
17666: LD_INT 2
17668: ARRAY
17669: PUSH
17670: LD_VAR 0 2
17674: ARRAY
17675: PPUSH
17676: LD_INT 1
17678: PPUSH
17679: LD_INT 15
17681: NEG
17682: PPUSH
17683: CALL 107890 0 4
17687: GO 17643
17689: POP
17690: POP
// CenterNowOnUnits ( Powell ) ;
17691: LD_EXP 61
17695: PPUSH
17696: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
17700: LD_ADDR_VAR 0 5
17704: PUSH
17705: LD_EXP 59
17709: PUSH
17710: EMPTY
17711: LIST
17712: ST_TO_ADDR
// if GirlNewVeh then
17713: LD_EXP 60
17717: IFFALSE 17735
// tmp := tmp ^ GirlNewVeh ;
17719: LD_ADDR_VAR 0 5
17723: PUSH
17724: LD_VAR 0 5
17728: PUSH
17729: LD_EXP 60
17733: ADD
17734: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
17735: LD_VAR 0 5
17739: PPUSH
17740: LD_INT 60
17742: PPUSH
17743: LD_INT 109
17745: PPUSH
17746: CALL_OW 111
// if KappaStatus then
17750: LD_EXP 2
17754: IFFALSE 17806
// begin Say ( JMM , D1nT-JMM-1 ) ;
17756: LD_EXP 40
17760: PPUSH
17761: LD_STRING D1nT-JMM-1
17763: PPUSH
17764: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17768: LD_EXP 61
17772: PPUSH
17773: LD_STRING D1T-Pow-1
17775: PPUSH
17776: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
17780: LD_EXP 40
17784: PPUSH
17785: LD_STRING D1T-JMM-2
17787: PPUSH
17788: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
17792: LD_EXP 61
17796: PPUSH
17797: LD_STRING D1T-Pow-2
17799: PPUSH
17800: CALL_OW 88
// end else
17804: GO 18012
// if JMMGirlStatus then
17806: LD_EXP 6
17810: IFFALSE 17955
// begin Say ( JMM , D1T-JMM-1 ) ;
17812: LD_EXP 40
17816: PPUSH
17817: LD_STRING D1T-JMM-1
17819: PPUSH
17820: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17824: LD_EXP 61
17828: PPUSH
17829: LD_STRING D1T-Pow-1
17831: PPUSH
17832: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
17836: LD_EXP 40
17840: PPUSH
17841: LD_STRING D1T-JMM-3
17843: PPUSH
17844: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
17848: LD_EXP 61
17852: PPUSH
17853: LD_STRING D1T-Pow-3
17855: PPUSH
17856: CALL_OW 88
// if JMMGirl then
17860: LD_EXP 7
17864: IFFALSE 17953
// begin case JMMGirl of 1 :
17866: LD_EXP 7
17870: PUSH
17871: LD_INT 1
17873: DOUBLE
17874: EQUAL
17875: IFTRUE 17879
17877: GO 17894
17879: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
17880: LD_EXP 41
17884: PPUSH
17885: LD_STRING D1T-Joan-3
17887: PPUSH
17888: CALL_OW 88
17892: GO 17941
17894: LD_INT 2
17896: DOUBLE
17897: EQUAL
17898: IFTRUE 17902
17900: GO 17917
17902: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
17903: LD_EXP 43
17907: PPUSH
17908: LD_STRING D1T-Lisa-3
17910: PPUSH
17911: CALL_OW 88
17915: GO 17941
17917: LD_INT 3
17919: DOUBLE
17920: EQUAL
17921: IFTRUE 17925
17923: GO 17940
17925: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
17926: LD_EXP 55
17930: PPUSH
17931: LD_STRING D1T-Con-3
17933: PPUSH
17934: CALL_OW 88
17938: GO 17941
17940: POP
// Say ( Powell , D1T-Pow-4 ) ;
17941: LD_EXP 61
17945: PPUSH
17946: LD_STRING D1T-Pow-4
17948: PPUSH
17949: CALL_OW 88
// end ; end else
17953: GO 18012
// if not FastEnd then
17955: LD_EXP 11
17959: NOT
17960: IFFALSE 17988
// begin Say ( JMM , D1T-JMM-4 ) ;
17962: LD_EXP 40
17966: PPUSH
17967: LD_STRING D1T-JMM-4
17969: PPUSH
17970: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
17974: LD_EXP 61
17978: PPUSH
17979: LD_STRING D1T-Pow-5
17981: PPUSH
17982: CALL_OW 88
// end else
17986: GO 18012
// begin Say ( JMM , D1nT-JMM-1 ) ;
17988: LD_EXP 40
17992: PPUSH
17993: LD_STRING D1nT-JMM-1
17995: PPUSH
17996: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
18000: LD_EXP 61
18004: PPUSH
18005: LD_STRING D1nT-Pow-1
18007: PPUSH
18008: CALL_OW 88
// end ; repeat wait ( 3 ) ;
18012: LD_INT 3
18014: PPUSH
18015: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
18019: LD_EXP 59
18023: PPUSH
18024: CALL_OW 314
18028: NOT
18029: IFFALSE 18012
// ComExitVehicle ( JMM ) ;
18031: LD_EXP 40
18035: PPUSH
18036: CALL_OW 121
// repeat wait ( 3 ) ;
18040: LD_INT 3
18042: PPUSH
18043: CALL_OW 67
// until not IsInUnit ( JMM ) ;
18047: LD_EXP 40
18051: PPUSH
18052: CALL_OW 310
18056: NOT
18057: IFFALSE 18040
// ComMoveXY ( JMM , 60 , 94 ) ;
18059: LD_EXP 40
18063: PPUSH
18064: LD_INT 60
18066: PPUSH
18067: LD_INT 94
18069: PPUSH
18070: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
18074: LD_EXP 40
18078: PPUSH
18079: LD_EXP 61
18083: PPUSH
18084: CALL_OW 179
// if Joan then
18088: LD_EXP 41
18092: IFFALSE 18146
// begin ComExitVehicle ( Joan ) ;
18094: LD_EXP 41
18098: PPUSH
18099: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
18103: LD_EXP 41
18107: PPUSH
18108: LD_INT 35
18110: PPUSH
18111: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
18115: LD_EXP 41
18119: PPUSH
18120: LD_INT 65
18122: PPUSH
18123: LD_INT 104
18125: PPUSH
18126: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
18130: LD_EXP 41
18134: PPUSH
18135: LD_EXP 40
18139: PPUSH
18140: CALL_OW 179
// end else
18144: GO 18280
// if Lisa and JMMGirl = 2 then
18146: LD_EXP 43
18150: PUSH
18151: LD_EXP 7
18155: PUSH
18156: LD_INT 2
18158: EQUAL
18159: AND
18160: IFFALSE 18214
// begin ComExitVehicle ( Lisa ) ;
18162: LD_EXP 43
18166: PPUSH
18167: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
18171: LD_EXP 43
18175: PPUSH
18176: LD_INT 35
18178: PPUSH
18179: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
18183: LD_EXP 43
18187: PPUSH
18188: LD_INT 65
18190: PPUSH
18191: LD_INT 104
18193: PPUSH
18194: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
18198: LD_EXP 43
18202: PPUSH
18203: LD_EXP 40
18207: PPUSH
18208: CALL_OW 179
// end else
18212: GO 18280
// if Connie and JMMGirl = 3 then
18214: LD_EXP 55
18218: PUSH
18219: LD_EXP 7
18223: PUSH
18224: LD_INT 3
18226: EQUAL
18227: AND
18228: IFFALSE 18280
// begin ComExitVehicle ( Connie ) ;
18230: LD_EXP 55
18234: PPUSH
18235: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
18239: LD_EXP 55
18243: PPUSH
18244: LD_INT 35
18246: PPUSH
18247: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
18251: LD_EXP 55
18255: PPUSH
18256: LD_INT 65
18258: PPUSH
18259: LD_INT 104
18261: PPUSH
18262: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
18266: LD_EXP 55
18270: PPUSH
18271: LD_EXP 40
18275: PPUSH
18276: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
18280: LD_INT 35
18282: PPUSH
18283: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
18287: LD_EXP 40
18291: PPUSH
18292: LD_EXP 61
18296: PPUSH
18297: CALL_OW 296
18301: PUSH
18302: LD_INT 8
18304: LESS
18305: IFFALSE 18280
// wait ( 0 0$0.5 ) ;
18307: LD_INT 18
18309: PPUSH
18310: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
18314: LD_EXP 40
18318: PPUSH
18319: LD_STRING D1-JMM-1
18321: PPUSH
18322: CALL_OW 88
// async ;
18326: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
18327: LD_EXP 61
18331: PPUSH
18332: LD_STRING D1-Pow-1
18334: PPUSH
18335: CALL_OW 88
// if not dialogue_skipped then
18339: LD_OWVAR 59
18343: NOT
18344: IFFALSE 18353
// wait ( 0 0$2 ) ;
18346: LD_INT 70
18348: PPUSH
18349: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
18353: LD_INT 170
18355: PPUSH
18356: LD_INT 99
18358: PPUSH
18359: LD_INT 1
18361: PPUSH
18362: LD_INT 6
18364: NEG
18365: PPUSH
18366: CALL 107890 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
18370: LD_INT 174
18372: PPUSH
18373: LD_INT 115
18375: PPUSH
18376: LD_INT 1
18378: PPUSH
18379: LD_INT 6
18381: NEG
18382: PPUSH
18383: CALL 107890 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
18387: LD_INT 169
18389: PPUSH
18390: LD_INT 71
18392: PPUSH
18393: LD_INT 1
18395: PPUSH
18396: LD_INT 6
18398: NEG
18399: PPUSH
18400: CALL 107890 0 4
// if not dialogue_skipped then
18404: LD_OWVAR 59
18408: NOT
18409: IFFALSE 18428
// begin CenterOnXY ( 170 , 99 ) ;
18411: LD_INT 170
18413: PPUSH
18414: LD_INT 99
18416: PPUSH
18417: CALL_OW 84
// wait ( 0 0$2.3 ) ;
18421: LD_INT 80
18423: PPUSH
18424: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
18428: LD_INT 75
18430: PPUSH
18431: LD_INT 53
18433: PPUSH
18434: LD_INT 1
18436: PPUSH
18437: LD_INT 9
18439: NEG
18440: PPUSH
18441: CALL 107890 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
18445: LD_INT 54
18447: PPUSH
18448: LD_INT 42
18450: PPUSH
18451: LD_INT 1
18453: PPUSH
18454: LD_INT 9
18456: NEG
18457: PPUSH
18458: CALL 107890 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
18462: LD_INT 62
18464: PPUSH
18465: LD_INT 51
18467: PPUSH
18468: LD_INT 1
18470: PPUSH
18471: LD_INT 9
18473: NEG
18474: PPUSH
18475: CALL 107890 0 4
// if not dialogue_skipped then
18479: LD_OWVAR 59
18483: NOT
18484: IFFALSE 18503
// begin CenterOnXY ( 75 , 53 ) ;
18486: LD_INT 75
18488: PPUSH
18489: LD_INT 53
18491: PPUSH
18492: CALL_OW 84
// wait ( 0 0$4 ) ;
18496: LD_INT 140
18498: PPUSH
18499: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
18503: LD_EXP 61
18507: PPUSH
18508: CALL_OW 87
// if not dialogue_skipped then
18512: LD_OWVAR 59
18516: NOT
18517: IFFALSE 18526
// wait ( 0 0$2 ) ;
18519: LD_INT 70
18521: PPUSH
18522: CALL_OW 67
// sync ;
18526: SYNC
// Say ( JMM , D1-JMM-2 ) ;
18527: LD_EXP 40
18531: PPUSH
18532: LD_STRING D1-JMM-2
18534: PPUSH
18535: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
18539: LD_EXP 61
18543: PPUSH
18544: LD_STRING D1-Pow-2
18546: PPUSH
18547: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
18551: LD_EXP 40
18555: PPUSH
18556: LD_STRING D1-JMM-3
18558: PPUSH
18559: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
18563: LD_EXP 61
18567: PPUSH
18568: LD_STRING D1-Pow-3
18570: PPUSH
18571: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
18575: LD_EXP 40
18579: PPUSH
18580: LD_STRING D1-JMM-4
18582: PPUSH
18583: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
18587: LD_EXP 61
18591: PPUSH
18592: LD_STRING D1-Pow-4
18594: PPUSH
18595: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
18599: LD_EXP 40
18603: PPUSH
18604: LD_STRING D1-JMM-5
18606: PPUSH
18607: CALL_OW 88
// async ;
18611: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
18612: LD_EXP 61
18616: PPUSH
18617: LD_STRING D1-Pow-5
18619: PPUSH
18620: CALL_OW 88
// if not dialogue_skipped then
18624: LD_OWVAR 59
18628: NOT
18629: IFFALSE 18638
// wait ( 0 0$3.6 ) ;
18631: LD_INT 126
18633: PPUSH
18634: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
18638: LD_INT 134
18640: PPUSH
18641: LD_INT 210
18643: PPUSH
18644: LD_INT 1
18646: PPUSH
18647: LD_INT 11
18649: NEG
18650: PPUSH
18651: CALL 107890 0 4
// if not dialogue_skipped then
18655: LD_OWVAR 59
18659: NOT
18660: IFFALSE 18679
// begin CenterOnXY ( 134 , 210 ) ;
18662: LD_INT 134
18664: PPUSH
18665: LD_INT 210
18667: PPUSH
18668: CALL_OW 84
// wait ( 0 0$2 ) ;
18672: LD_INT 70
18674: PPUSH
18675: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
18679: LD_INT 101
18681: PPUSH
18682: LD_INT 159
18684: PPUSH
18685: LD_INT 1
18687: PPUSH
18688: LD_INT 10
18690: NEG
18691: PPUSH
18692: CALL 107890 0 4
// if not dialogue_skipped then
18696: LD_OWVAR 59
18700: NOT
18701: IFFALSE 18720
// begin CenterOnXY ( 101 , 159 ) ;
18703: LD_INT 101
18705: PPUSH
18706: LD_INT 159
18708: PPUSH
18709: CALL_OW 84
// wait ( 0 0$2 ) ;
18713: LD_INT 70
18715: PPUSH
18716: CALL_OW 67
// end ; sync ;
18720: SYNC
// CenterNowOnUnits ( Powell ) ;
18721: LD_EXP 61
18725: PPUSH
18726: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
18730: LD_ADDR_VAR 0 6
18734: PUSH
18735: LD_INT 1
18737: PUSH
18738: LD_INT 2
18740: PUSH
18741: LD_INT 3
18743: PUSH
18744: LD_INT 4
18746: PUSH
18747: LD_INT 5
18749: PUSH
18750: LD_INT 6
18752: PUSH
18753: EMPTY
18754: LIST
18755: LIST
18756: LIST
18757: LIST
18758: LIST
18759: LIST
18760: ST_TO_ADDR
// if not dialogue_skipped then
18761: LD_OWVAR 59
18765: NOT
18766: IFFALSE 18935
// begin game_speed := 4 ;
18768: LD_ADDR_OWVAR 65
18772: PUSH
18773: LD_INT 4
18775: ST_TO_ADDR
// wait ( 0 0$6 ) ;
18776: LD_INT 210
18778: PPUSH
18779: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
18783: LD_ADDR_VAR 0 7
18787: PUSH
18788: LD_STRING Q1
18790: PPUSH
18791: LD_VAR 0 6
18795: PPUSH
18796: CALL_OW 98
18800: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
18801: LD_ADDR_VAR 0 7
18805: PUSH
18806: LD_STRING Q1
18808: PPUSH
18809: LD_VAR 0 6
18813: PPUSH
18814: CALL_OW 98
18818: ST_TO_ADDR
// options := options diff dec ;
18819: LD_ADDR_VAR 0 6
18823: PUSH
18824: LD_VAR 0 6
18828: PUSH
18829: LD_VAR 0 7
18833: DIFF
18834: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
18835: LD_VAR 0 7
18839: PPUSH
18840: LD_VAR 0 6
18844: PPUSH
18845: CALL 20499 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
18849: LD_VAR 0 7
18853: PUSH
18854: LD_INT 5
18856: PUSH
18857: LD_INT 6
18859: PUSH
18860: EMPTY
18861: LIST
18862: LIST
18863: IN
18864: PUSH
18865: LD_VAR 0 6
18869: PUSH
18870: LD_INT 2
18872: EQUAL
18873: OR
18874: IFFALSE 18801
// if not ( dec in [ 5 , 6 ] ) then
18876: LD_VAR 0 7
18880: PUSH
18881: LD_INT 5
18883: PUSH
18884: LD_INT 6
18886: PUSH
18887: EMPTY
18888: LIST
18889: LIST
18890: IN
18891: NOT
18892: IFFALSE 18935
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
18894: LD_ADDR_VAR 0 7
18898: PUSH
18899: LD_STRING Q1a
18901: PPUSH
18902: LD_INT 1
18904: PUSH
18905: LD_INT 2
18907: PUSH
18908: EMPTY
18909: LIST
18910: LIST
18911: PPUSH
18912: CALL_OW 98
18916: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
18917: LD_VAR 0 7
18921: PUSH
18922: LD_INT 4
18924: PLUS
18925: PPUSH
18926: LD_VAR 0 6
18930: PPUSH
18931: CALL 20499 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
18935: LD_INT 81
18937: PPUSH
18938: LD_INT 127
18940: PPUSH
18941: CALL_OW 84
// amount := 8 ;
18945: LD_ADDR_VAR 0 8
18949: PUSH
18950: LD_INT 8
18952: ST_TO_ADDR
// macmilan_squad := [ ] ;
18953: LD_ADDR_VAR 0 9
18957: PUSH
18958: EMPTY
18959: ST_TO_ADDR
// if vip < amount then
18960: LD_EXP 62
18964: PUSH
18965: LD_VAR 0 8
18969: LESS
18970: IFFALSE 19014
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
18972: LD_ADDR_VAR 0 5
18976: PUSH
18977: LD_EXP 62
18981: PUSH
18982: LD_INT 22
18984: PUSH
18985: LD_INT 4
18987: PUSH
18988: EMPTY
18989: LIST
18990: LIST
18991: PUSH
18992: LD_INT 21
18994: PUSH
18995: LD_INT 1
18997: PUSH
18998: EMPTY
18999: LIST
19000: LIST
19001: PUSH
19002: EMPTY
19003: LIST
19004: LIST
19005: PPUSH
19006: CALL_OW 69
19010: UNION
19011: ST_TO_ADDR
19012: GO 19024
// tmp := vip ;
19014: LD_ADDR_VAR 0 5
19018: PUSH
19019: LD_EXP 62
19023: ST_TO_ADDR
// tmp := tmp diff Powell ;
19024: LD_ADDR_VAR 0 5
19028: PUSH
19029: LD_VAR 0 5
19033: PUSH
19034: LD_EXP 61
19038: DIFF
19039: ST_TO_ADDR
// if tmp < amount then
19040: LD_VAR 0 5
19044: PUSH
19045: LD_VAR 0 8
19049: LESS
19050: IFFALSE 19062
// amount := tmp ;
19052: LD_ADDR_VAR 0 8
19056: PUSH
19057: LD_VAR 0 5
19061: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
19062: LD_VAR 0 5
19066: PUSH
19067: LD_INT 1
19069: ARRAY
19070: PPUSH
19071: CALL_OW 257
19075: PUSH
19076: LD_INT 2
19078: NONEQUAL
19079: IFFALSE 19177
// begin if IsInUnit ( tmp [ 1 ] ) then
19081: LD_VAR 0 5
19085: PUSH
19086: LD_INT 1
19088: ARRAY
19089: PPUSH
19090: CALL_OW 310
19094: IFFALSE 19109
// ComExitBuilding ( tmp [ 1 ] ) ;
19096: LD_VAR 0 5
19100: PUSH
19101: LD_INT 1
19103: ARRAY
19104: PPUSH
19105: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
19109: LD_INT 387
19111: PPUSH
19112: CALL_OW 313
19116: PUSH
19117: LD_INT 6
19119: EQUAL
19120: IFFALSE 19145
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
19122: LD_INT 387
19124: PPUSH
19125: CALL_OW 313
19129: PUSH
19130: LD_INT 1
19132: ARRAY
19133: PPUSH
19134: CALL_OW 122
// wait ( 3 ) ;
19138: LD_INT 3
19140: PPUSH
19141: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
19145: LD_VAR 0 5
19149: PUSH
19150: LD_INT 1
19152: ARRAY
19153: PPUSH
19154: LD_INT 387
19156: PPUSH
19157: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
19161: LD_VAR 0 5
19165: PUSH
19166: LD_INT 1
19168: ARRAY
19169: PPUSH
19170: LD_INT 2
19172: PPUSH
19173: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
19177: LD_EXP 40
19181: PPUSH
19182: LD_INT 82
19184: PPUSH
19185: LD_INT 129
19187: PPUSH
19188: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
19192: LD_EXP 40
19196: PPUSH
19197: LD_EXP 61
19201: PPUSH
19202: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
19206: LD_INT 22
19208: PUSH
19209: LD_INT 1
19211: PUSH
19212: EMPTY
19213: LIST
19214: LIST
19215: PPUSH
19216: CALL_OW 69
19220: PUSH
19221: LD_EXP 40
19225: DIFF
19226: PPUSH
19227: LD_INT 84
19229: PPUSH
19230: LD_INT 128
19232: PPUSH
19233: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
19237: LD_INT 22
19239: PUSH
19240: LD_INT 1
19242: PUSH
19243: EMPTY
19244: LIST
19245: LIST
19246: PPUSH
19247: CALL_OW 69
19251: PUSH
19252: LD_EXP 40
19256: DIFF
19257: PPUSH
19258: LD_EXP 40
19262: PPUSH
19263: CALL_OW 179
// for i = 1 to amount do
19267: LD_ADDR_VAR 0 2
19271: PUSH
19272: DOUBLE
19273: LD_INT 1
19275: DEC
19276: ST_TO_ADDR
19277: LD_VAR 0 8
19281: PUSH
19282: FOR_TO
19283: IFFALSE 19451
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
19285: LD_ADDR_VAR 0 9
19289: PUSH
19290: LD_VAR 0 9
19294: PUSH
19295: LD_VAR 0 5
19299: PUSH
19300: LD_VAR 0 2
19304: ARRAY
19305: ADD
19306: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
19307: LD_VAR 0 5
19311: PUSH
19312: LD_VAR 0 2
19316: ARRAY
19317: PPUSH
19318: CALL_OW 310
19322: IFFALSE 19339
// AddComExitBuilding ( tmp [ i ] ) ;
19324: LD_VAR 0 5
19328: PUSH
19329: LD_VAR 0 2
19333: ARRAY
19334: PPUSH
19335: CALL_OW 182
// if i = 2 and JMMNewVeh then
19339: LD_VAR 0 2
19343: PUSH
19344: LD_INT 2
19346: EQUAL
19347: PUSH
19348: LD_EXP 59
19352: AND
19353: IFFALSE 19411
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
19355: LD_VAR 0 5
19359: PUSH
19360: LD_VAR 0 2
19364: ARRAY
19365: PPUSH
19366: LD_EXP 59
19370: PPUSH
19371: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
19375: LD_VAR 0 5
19379: PUSH
19380: LD_VAR 0 2
19384: ARRAY
19385: PPUSH
19386: LD_INT 86
19388: PPUSH
19389: LD_INT 133
19391: PPUSH
19392: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
19396: LD_VAR 0 5
19400: PUSH
19401: LD_VAR 0 2
19405: ARRAY
19406: PPUSH
19407: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
19411: LD_VAR 0 5
19415: PUSH
19416: LD_VAR 0 2
19420: ARRAY
19421: PPUSH
19422: LD_INT 8
19424: PPUSH
19425: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
19429: LD_VAR 0 5
19433: PUSH
19434: LD_VAR 0 2
19438: ARRAY
19439: PPUSH
19440: LD_EXP 40
19444: PPUSH
19445: CALL_OW 179
// end ;
19449: GO 19282
19451: POP
19452: POP
// if GirlNewVeh then
19453: LD_EXP 60
19457: IFFALSE 19471
// SetSide ( GirlNewVeh , 4 ) ;
19459: LD_EXP 60
19463: PPUSH
19464: LD_INT 4
19466: PPUSH
19467: CALL_OW 235
// if Mike then
19471: LD_EXP 57
19475: IFFALSE 19512
// begin macmilan_squad := Join ( macmilan_squad , Mike ) ;
19477: LD_ADDR_VAR 0 9
19481: PUSH
19482: LD_VAR 0 9
19486: PPUSH
19487: LD_EXP 57
19491: PPUSH
19492: CALL 108004 0 2
19496: ST_TO_ADDR
// ComMoveXY ( Mike , 86 , 133 ) ;
19497: LD_EXP 57
19501: PPUSH
19502: LD_INT 86
19504: PPUSH
19505: LD_INT 133
19507: PPUSH
19508: CALL_OW 111
// end ; repeat wait ( 0 0$1 ) ;
19512: LD_INT 35
19514: PPUSH
19515: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
19519: LD_VAR 0 9
19523: PPUSH
19524: LD_INT 95
19526: PUSH
19527: LD_INT 9
19529: PUSH
19530: EMPTY
19531: LIST
19532: LIST
19533: PPUSH
19534: CALL_OW 72
19538: PUSH
19539: LD_INT 0
19541: EQUAL
19542: PUSH
19543: LD_EXP 40
19547: PPUSH
19548: LD_INT 9
19550: PPUSH
19551: CALL_OW 308
19555: NOT
19556: AND
19557: IFFALSE 19512
// wait ( 0 0$2 ) ;
19559: LD_INT 70
19561: PPUSH
19562: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
19566: LD_VAR 0 9
19570: PPUSH
19571: LD_INT 1
19573: PPUSH
19574: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
19578: LD_INT 21
19580: PUSH
19581: LD_INT 2
19583: PUSH
19584: EMPTY
19585: LIST
19586: LIST
19587: PUSH
19588: LD_INT 92
19590: PUSH
19591: LD_INT 83
19593: PUSH
19594: LD_INT 130
19596: PUSH
19597: LD_INT 10
19599: PUSH
19600: EMPTY
19601: LIST
19602: LIST
19603: LIST
19604: LIST
19605: PUSH
19606: EMPTY
19607: LIST
19608: LIST
19609: PPUSH
19610: CALL_OW 69
19614: PPUSH
19615: LD_INT 1
19617: PPUSH
19618: CALL_OW 235
// tick := 0 ;
19622: LD_ADDR_OWVAR 1
19626: PUSH
19627: LD_INT 0
19629: ST_TO_ADDR
// Video ( false ) ;
19630: LD_INT 0
19632: PPUSH
19633: CALL 107976 0 1
// ChangeMissionObjectives ( M1 ) ;
19637: LD_STRING M1
19639: PPUSH
19640: CALL_OW 337
// SaveForQuickRestart ;
19644: CALL_OW 22
// missionStart := true ;
19648: LD_ADDR_EXP 13
19652: PUSH
19653: LD_INT 1
19655: ST_TO_ADDR
// missionStage := 2 ;
19656: LD_ADDR_EXP 15
19660: PUSH
19661: LD_INT 2
19663: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19664: LD_INT 35
19666: PPUSH
19667: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
19671: LD_ADDR_VAR 0 5
19675: PUSH
19676: LD_INT 22
19678: PUSH
19679: LD_INT 4
19681: PUSH
19682: EMPTY
19683: LIST
19684: LIST
19685: PUSH
19686: LD_INT 21
19688: PUSH
19689: LD_INT 1
19691: PUSH
19692: EMPTY
19693: LIST
19694: LIST
19695: PUSH
19696: EMPTY
19697: LIST
19698: LIST
19699: PPUSH
19700: CALL_OW 69
19704: PUSH
19705: LD_EXP 61
19709: DIFF
19710: ST_TO_ADDR
// if not tmp then
19711: LD_VAR 0 5
19715: NOT
19716: IFFALSE 19731
// tmp := [ Powell ] ;
19718: LD_ADDR_VAR 0 5
19722: PUSH
19723: LD_EXP 61
19727: PUSH
19728: EMPTY
19729: LIST
19730: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
19731: LD_ADDR_VAR 0 4
19735: PUSH
19736: LD_INT 22
19738: PUSH
19739: LD_INT 4
19741: PUSH
19742: EMPTY
19743: LIST
19744: LIST
19745: PUSH
19746: LD_INT 34
19748: PUSH
19749: LD_INT 12
19751: PUSH
19752: EMPTY
19753: LIST
19754: LIST
19755: PUSH
19756: EMPTY
19757: LIST
19758: LIST
19759: PPUSH
19760: CALL_OW 69
19764: PUSH
19765: LD_INT 1
19767: ARRAY
19768: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
19769: LD_VAR 0 5
19773: PUSH
19774: LD_INT 1
19776: ARRAY
19777: PPUSH
19778: CALL_OW 310
19782: IFFALSE 19797
// ComExitBuilding ( tmp [ 1 ] ) ;
19784: LD_VAR 0 5
19788: PUSH
19789: LD_INT 1
19791: ARRAY
19792: PPUSH
19793: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
19797: LD_VAR 0 5
19801: PUSH
19802: LD_INT 1
19804: ARRAY
19805: PPUSH
19806: LD_VAR 0 4
19810: PPUSH
19811: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
19815: LD_VAR 0 5
19819: PUSH
19820: LD_INT 1
19822: ARRAY
19823: PPUSH
19824: LD_INT 80
19826: PPUSH
19827: LD_INT 136
19829: PPUSH
19830: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
19834: LD_VAR 0 5
19838: PUSH
19839: LD_INT 1
19841: ARRAY
19842: PPUSH
19843: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
19847: LD_VAR 0 5
19851: PUSH
19852: LD_INT 1
19854: ARRAY
19855: PPUSH
19856: LD_INT 59
19858: PPUSH
19859: LD_INT 112
19861: PPUSH
19862: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
19866: LD_VAR 0 5
19870: PUSH
19871: LD_INT 1
19873: ARRAY
19874: PPUSH
19875: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
19879: LD_EXP 41
19883: PUSH
19884: LD_EXP 41
19888: PPUSH
19889: CALL_OW 255
19893: PUSH
19894: LD_INT 1
19896: EQUAL
19897: AND
19898: IFFALSE 19924
// begin Say ( Joan , D3W-Joan-1 ) ;
19900: LD_EXP 41
19904: PPUSH
19905: LD_STRING D3W-Joan-1
19907: PPUSH
19908: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19912: LD_EXP 40
19916: PPUSH
19917: LD_STRING D3W-JMM-1
19919: PPUSH
19920: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
19924: LD_EXP 43
19928: PUSH
19929: LD_EXP 43
19933: PPUSH
19934: CALL_OW 255
19938: PUSH
19939: LD_INT 1
19941: EQUAL
19942: AND
19943: PUSH
19944: LD_EXP 43
19948: PUSH
19949: LD_EXP 62
19953: IN
19954: NOT
19955: AND
19956: IFFALSE 19982
// begin Say ( Lisa , D3W-Lisa-1 ) ;
19958: LD_EXP 43
19962: PPUSH
19963: LD_STRING D3W-Lisa-1
19965: PPUSH
19966: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19970: LD_EXP 40
19974: PPUSH
19975: LD_STRING D3W-JMM-1
19977: PPUSH
19978: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
19982: LD_EXP 55
19986: PUSH
19987: LD_EXP 55
19991: PPUSH
19992: CALL_OW 255
19996: PUSH
19997: LD_INT 1
19999: EQUAL
20000: AND
20001: IFFALSE 20027
// begin Say ( Connie , D3W-Con-1 ) ;
20003: LD_EXP 55
20007: PPUSH
20008: LD_STRING D3W-Con-1
20010: PPUSH
20011: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
20015: LD_EXP 40
20019: PPUSH
20020: LD_STRING D3W-JMM-1
20022: PPUSH
20023: CALL_OW 88
// end ; wait ( 0 0$0.5 ) ;
20027: LD_INT 18
20029: PPUSH
20030: CALL_OW 67
// if Lisa in vip and GetSide ( Lisa ) = 1 then
20034: LD_EXP 43
20038: PUSH
20039: LD_EXP 62
20043: IN
20044: PUSH
20045: LD_EXP 43
20049: PPUSH
20050: CALL_OW 255
20054: PUSH
20055: LD_INT 1
20057: EQUAL
20058: AND
20059: IFFALSE 20075
// Say ( Lisa , D3nW-Lisa-1 ) else
20061: LD_EXP 43
20065: PPUSH
20066: LD_STRING D3nW-Lisa-1
20068: PPUSH
20069: CALL_OW 88
20073: GO 20319
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
20075: LD_EXP 46
20079: PUSH
20080: LD_EXP 62
20084: IN
20085: PUSH
20086: LD_EXP 46
20090: PPUSH
20091: CALL_OW 255
20095: PUSH
20096: LD_INT 1
20098: EQUAL
20099: AND
20100: IFFALSE 20116
// Say ( Cyrus , D3nW-Cyrus-1 ) else
20102: LD_EXP 46
20106: PPUSH
20107: LD_STRING D3nW-Cyrus-1
20109: PPUSH
20110: CALL_OW 88
20114: GO 20319
// if Bobby in vip and GetSide ( Bobby ) = 1 then
20116: LD_EXP 45
20120: PUSH
20121: LD_EXP 62
20125: IN
20126: PUSH
20127: LD_EXP 45
20131: PPUSH
20132: CALL_OW 255
20136: PUSH
20137: LD_INT 1
20139: EQUAL
20140: AND
20141: IFFALSE 20157
// Say ( Bobby , D3nW-Bobby-1 ) else
20143: LD_EXP 45
20147: PPUSH
20148: LD_STRING D3nW-Bobby-1
20150: PPUSH
20151: CALL_OW 88
20155: GO 20319
// if Gary in vip and GetSide ( Gary ) = 1 then
20157: LD_EXP 52
20161: PUSH
20162: LD_EXP 62
20166: IN
20167: PUSH
20168: LD_EXP 52
20172: PPUSH
20173: CALL_OW 255
20177: PUSH
20178: LD_INT 1
20180: EQUAL
20181: AND
20182: IFFALSE 20198
// Say ( Gary , D3nW-Gary-1 ) else
20184: LD_EXP 52
20188: PPUSH
20189: LD_STRING D3nW-Gary-1
20191: PPUSH
20192: CALL_OW 88
20196: GO 20319
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
20198: LD_EXP 44
20202: PUSH
20203: LD_EXP 62
20207: IN
20208: PUSH
20209: LD_EXP 44
20213: PPUSH
20214: CALL_OW 255
20218: PUSH
20219: LD_INT 1
20221: EQUAL
20222: AND
20223: IFFALSE 20239
// Say ( Donaldson , D3nW-Don-1 ) else
20225: LD_EXP 44
20229: PPUSH
20230: LD_STRING D3nW-Don-1
20232: PPUSH
20233: CALL_OW 88
20237: GO 20319
// if Cornel in vip and GetSide ( Cornel ) = 1 then
20239: LD_EXP 51
20243: PUSH
20244: LD_EXP 62
20248: IN
20249: PUSH
20250: LD_EXP 51
20254: PPUSH
20255: CALL_OW 255
20259: PUSH
20260: LD_INT 1
20262: EQUAL
20263: AND
20264: IFFALSE 20280
// Say ( Cornel , D3nW-Corn-1 ) else
20266: LD_EXP 51
20270: PPUSH
20271: LD_STRING D3nW-Corn-1
20273: PPUSH
20274: CALL_OW 88
20278: GO 20319
// if Frank in vip and GetSide ( Frank ) = 1 then
20280: LD_EXP 53
20284: PUSH
20285: LD_EXP 62
20289: IN
20290: PUSH
20291: LD_EXP 53
20295: PPUSH
20296: CALL_OW 255
20300: PUSH
20301: LD_INT 1
20303: EQUAL
20304: AND
20305: IFFALSE 20319
// Say ( Frank , D3nW-Frank-1 ) ;
20307: LD_EXP 53
20311: PPUSH
20312: LD_STRING D3nW-Frank-1
20314: PPUSH
20315: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
20319: LD_EXP 62
20323: PPUSH
20324: LD_INT 22
20326: PUSH
20327: LD_INT 1
20329: PUSH
20330: EMPTY
20331: LIST
20332: LIST
20333: PPUSH
20334: CALL_OW 72
20338: IFFALSE 20364
// begin Say ( JMM , D3nW-JMM-1 ) ;
20340: LD_EXP 40
20344: PPUSH
20345: LD_STRING D3nW-JMM-1
20347: PPUSH
20348: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
20352: LD_EXP 40
20356: PPUSH
20357: LD_STRING D3nW-JMM-1a
20359: PPUSH
20360: CALL_OW 88
// end ; t := 0 0$00 ;
20364: LD_ADDR_VAR 0 3
20368: PUSH
20369: LD_INT 0
20371: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20372: LD_INT 35
20374: PPUSH
20375: CALL_OW 67
// t := t + 0 0$1 ;
20379: LD_ADDR_VAR 0 3
20383: PUSH
20384: LD_VAR 0 3
20388: PUSH
20389: LD_INT 35
20391: PLUS
20392: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
20393: LD_INT 59
20395: PPUSH
20396: LD_INT 112
20398: PPUSH
20399: CALL_OW 428
20403: PUSH
20404: LD_VAR 0 3
20408: PUSH
20409: LD_INT 2100
20411: GREATER
20412: OR
20413: IFFALSE 20372
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
20415: LD_ADDR_EXP 102
20419: PUSH
20420: LD_EXP 102
20424: PPUSH
20425: LD_INT 4
20427: PPUSH
20428: LD_INT 22
20430: PUSH
20431: LD_INT 4
20433: PUSH
20434: EMPTY
20435: LIST
20436: LIST
20437: PUSH
20438: LD_INT 23
20440: PUSH
20441: LD_INT 1
20443: PUSH
20444: EMPTY
20445: LIST
20446: LIST
20447: PUSH
20448: LD_INT 3
20450: PUSH
20451: LD_INT 21
20453: PUSH
20454: LD_INT 2
20456: PUSH
20457: EMPTY
20458: LIST
20459: LIST
20460: PUSH
20461: EMPTY
20462: LIST
20463: LIST
20464: PUSH
20465: EMPTY
20466: LIST
20467: LIST
20468: LIST
20469: PPUSH
20470: CALL_OW 69
20474: PUSH
20475: LD_EXP 61
20479: DIFF
20480: PPUSH
20481: CALL_OW 1
20485: ST_TO_ADDR
// activeAttacks := true ;
20486: LD_ADDR_EXP 16
20490: PUSH
20491: LD_INT 1
20493: ST_TO_ADDR
// end ;
20494: LD_VAR 0 1
20498: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
20499: LD_INT 0
20501: PPUSH
// case question of 1 :
20502: LD_VAR 0 1
20506: PUSH
20507: LD_INT 1
20509: DOUBLE
20510: EQUAL
20511: IFTRUE 20515
20513: GO 20566
20515: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
20516: LD_EXP 40
20520: PPUSH
20521: LD_STRING D2Mot-JMM-1
20523: PPUSH
20524: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
20528: LD_EXP 61
20532: PPUSH
20533: LD_STRING D2Mot-Pow-1
20535: PPUSH
20536: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
20540: LD_EXP 40
20544: PPUSH
20545: LD_STRING D2Mot-JMM-2
20547: PPUSH
20548: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
20552: LD_EXP 61
20556: PPUSH
20557: LD_STRING D2Mot-Pow-2
20559: PPUSH
20560: CALL_OW 88
// end ; 2 :
20564: GO 20917
20566: LD_INT 2
20568: DOUBLE
20569: EQUAL
20570: IFTRUE 20574
20572: GO 20650
20574: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
20575: LD_EXP 40
20579: PPUSH
20580: LD_STRING D2Rus-JMM-1
20582: PPUSH
20583: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
20587: LD_EXP 61
20591: PPUSH
20592: LD_STRING D2Rus-Pow-1
20594: PPUSH
20595: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
20599: LD_EXP 40
20603: PPUSH
20604: LD_STRING D2Rus-JMM-2
20606: PPUSH
20607: CALL_OW 88
// if not ( 3 in list_of_q ) then
20611: LD_INT 3
20613: PUSH
20614: LD_VAR 0 2
20618: IN
20619: NOT
20620: IFFALSE 20636
// Say ( Powell , D2Rus-Pow-2 ) else
20622: LD_EXP 61
20626: PPUSH
20627: LD_STRING D2Rus-Pow-2
20629: PPUSH
20630: CALL_OW 88
20634: GO 20648
// Say ( Powell , D2Rus-Pow-2a ) ;
20636: LD_EXP 61
20640: PPUSH
20641: LD_STRING D2Rus-Pow-2a
20643: PPUSH
20644: CALL_OW 88
// end ; 3 :
20648: GO 20917
20650: LD_INT 3
20652: DOUBLE
20653: EQUAL
20654: IFTRUE 20658
20656: GO 20743
20658: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
20659: LD_EXP 40
20663: PPUSH
20664: LD_STRING D2Leg-JMM-1
20666: PPUSH
20667: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
20671: LD_EXP 61
20675: PPUSH
20676: LD_STRING D2Leg-Pow-1
20678: PPUSH
20679: CALL_OW 88
// if 2 in list_of_q then
20683: LD_INT 2
20685: PUSH
20686: LD_VAR 0 2
20690: IN
20691: IFFALSE 20717
// begin Say ( JMM , D2Leg-JMM-2 ) ;
20693: LD_EXP 40
20697: PPUSH
20698: LD_STRING D2Leg-JMM-2
20700: PPUSH
20701: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
20705: LD_EXP 61
20709: PPUSH
20710: LD_STRING D2Leg-Pow-2
20712: PPUSH
20713: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
20717: LD_EXP 40
20721: PPUSH
20722: LD_STRING D2Leg-JMM-3
20724: PPUSH
20725: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
20729: LD_EXP 61
20733: PPUSH
20734: LD_STRING D2Leg-Pow-3
20736: PPUSH
20737: CALL_OW 88
// end ; 4 :
20741: GO 20917
20743: LD_INT 4
20745: DOUBLE
20746: EQUAL
20747: IFTRUE 20751
20749: GO 20826
20751: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
20752: LD_EXP 40
20756: PPUSH
20757: LD_STRING D2Ar-JMM-1
20759: PPUSH
20760: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
20764: LD_EXP 61
20768: PPUSH
20769: LD_STRING D2Ar-Pow-1
20771: PPUSH
20772: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
20776: LD_EXP 40
20780: PPUSH
20781: LD_STRING D2Ar-JMM-2
20783: PPUSH
20784: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
20788: LD_EXP 61
20792: PPUSH
20793: LD_STRING D2Ar-Pow-2
20795: PPUSH
20796: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
20800: LD_EXP 40
20804: PPUSH
20805: LD_STRING D2Ar-JMM-3
20807: PPUSH
20808: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
20812: LD_EXP 61
20816: PPUSH
20817: LD_STRING D2Ar-Pow-3
20819: PPUSH
20820: CALL_OW 88
// end ; 5 :
20824: GO 20917
20826: LD_INT 5
20828: DOUBLE
20829: EQUAL
20830: IFTRUE 20834
20832: GO 20849
20834: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
20835: LD_EXP 40
20839: PPUSH
20840: LD_STRING D2Conf-JMM-1
20842: PPUSH
20843: CALL_OW 88
20847: GO 20917
20849: LD_INT 6
20851: DOUBLE
20852: EQUAL
20853: IFTRUE 20857
20855: GO 20916
20857: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
20858: LD_EXP 40
20862: PPUSH
20863: LD_STRING D2Com-JMM-1
20865: PPUSH
20866: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
20870: LD_EXP 61
20874: PPUSH
20875: LD_STRING D2Com-Pow-1
20877: PPUSH
20878: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
20882: LD_EXP 40
20886: PPUSH
20887: LD_STRING D2Com-JMM-2
20889: PPUSH
20890: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
20894: LD_EXP 61
20898: PPUSH
20899: LD_STRING D2Com-Pow-2
20901: PPUSH
20902: CALL_OW 88
// powellAngerQuery := true ;
20906: LD_ADDR_EXP 36
20910: PUSH
20911: LD_INT 1
20913: ST_TO_ADDR
// end ; end ;
20914: GO 20917
20916: POP
// end ;
20917: LD_VAR 0 3
20921: RET
// every 0 0$5 trigger missionStart do var tmp ;
20922: LD_EXP 13
20926: IFFALSE 21251
20928: GO 20930
20930: DISABLE
20931: LD_INT 0
20933: PPUSH
// begin repeat wait ( 0 0$1 ) ;
20934: LD_INT 35
20936: PPUSH
20937: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
20941: LD_INT 14
20943: PPUSH
20944: LD_INT 22
20946: PUSH
20947: LD_INT 1
20949: PUSH
20950: EMPTY
20951: LIST
20952: LIST
20953: PUSH
20954: LD_INT 3
20956: PUSH
20957: LD_INT 21
20959: PUSH
20960: LD_INT 3
20962: PUSH
20963: EMPTY
20964: LIST
20965: LIST
20966: PUSH
20967: EMPTY
20968: LIST
20969: LIST
20970: PUSH
20971: EMPTY
20972: LIST
20973: LIST
20974: PPUSH
20975: CALL_OW 70
20979: PUSH
20980: LD_EXP 15
20984: PUSH
20985: LD_INT 2
20987: PUSH
20988: LD_INT 3
20990: PUSH
20991: LD_INT 4
20993: PUSH
20994: LD_INT 5
20996: PUSH
20997: EMPTY
20998: LIST
20999: LIST
21000: LIST
21001: LIST
21002: IN
21003: AND
21004: IFFALSE 21241
// begin powellAnger := powellAnger + 1 ;
21006: LD_ADDR_EXP 17
21010: PUSH
21011: LD_EXP 17
21015: PUSH
21016: LD_INT 1
21018: PLUS
21019: ST_TO_ADDR
// Video ( true ) ;
21020: LD_INT 1
21022: PPUSH
21023: CALL 107976 0 1
// CenterNowOnUnits ( tmp ) ;
21027: LD_VAR 0 1
21031: PPUSH
21032: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
21036: LD_INT 14
21038: PPUSH
21039: LD_INT 22
21041: PUSH
21042: LD_INT 1
21044: PUSH
21045: EMPTY
21046: LIST
21047: LIST
21048: PPUSH
21049: CALL_OW 70
21053: PPUSH
21054: LD_INT 86
21056: PPUSH
21057: LD_INT 133
21059: PPUSH
21060: CALL_OW 111
// async ;
21064: ASYNC
// case powellAnger of 1 :
21065: LD_EXP 17
21069: PUSH
21070: LD_INT 1
21072: DOUBLE
21073: EQUAL
21074: IFTRUE 21078
21076: GO 21093
21078: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
21079: LD_EXP 61
21083: PPUSH
21084: LD_STRING DBack1-Pow-1
21086: PPUSH
21087: CALL_OW 88
21091: GO 21140
21093: LD_INT 2
21095: DOUBLE
21096: EQUAL
21097: IFTRUE 21101
21099: GO 21116
21101: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
21102: LD_EXP 61
21106: PPUSH
21107: LD_STRING DBack2-Pow-1
21109: PPUSH
21110: CALL_OW 88
21114: GO 21140
21116: LD_INT 3
21118: DOUBLE
21119: EQUAL
21120: IFTRUE 21124
21122: GO 21139
21124: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
21125: LD_EXP 61
21129: PPUSH
21130: LD_STRING DBack3-Pow-1
21132: PPUSH
21133: CALL_OW 88
21137: GO 21140
21139: POP
// sync ;
21140: SYNC
// repeat wait ( 0 0$1 ) ;
21141: LD_INT 35
21143: PPUSH
21144: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
21148: LD_INT 14
21150: PPUSH
21151: LD_INT 22
21153: PUSH
21154: LD_INT 1
21156: PUSH
21157: EMPTY
21158: LIST
21159: LIST
21160: PPUSH
21161: CALL_OW 70
21165: PPUSH
21166: LD_INT 86
21168: PPUSH
21169: LD_INT 133
21171: PPUSH
21172: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21176: LD_INT 14
21178: PPUSH
21179: LD_INT 22
21181: PUSH
21182: LD_INT 1
21184: PUSH
21185: EMPTY
21186: LIST
21187: LIST
21188: PUSH
21189: LD_INT 3
21191: PUSH
21192: LD_INT 21
21194: PUSH
21195: LD_INT 3
21197: PUSH
21198: EMPTY
21199: LIST
21200: LIST
21201: PUSH
21202: EMPTY
21203: LIST
21204: LIST
21205: PUSH
21206: EMPTY
21207: LIST
21208: LIST
21209: PPUSH
21210: CALL_OW 70
21214: NOT
21215: IFFALSE 21141
// if powellAnger >= 3 then
21217: LD_EXP 17
21221: PUSH
21222: LD_INT 3
21224: GREATEREQUAL
21225: IFFALSE 21234
// YouLost ( Dismissed ) ;
21227: LD_STRING Dismissed
21229: PPUSH
21230: CALL_OW 104
// Video ( false ) ;
21234: LD_INT 0
21236: PPUSH
21237: CALL 107976 0 1
// end ; until missionStage > 5 ;
21241: LD_EXP 15
21245: PUSH
21246: LD_INT 5
21248: GREATER
21249: IFFALSE 20934
// end ;
21251: PPOPN 1
21253: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t , p ;
21254: LD_EXP 13
21258: PUSH
21259: LD_INT 22
21261: PUSH
21262: LD_INT 4
21264: PUSH
21265: EMPTY
21266: LIST
21267: LIST
21268: PUSH
21269: LD_INT 21
21271: PUSH
21272: LD_INT 2
21274: PUSH
21275: EMPTY
21276: LIST
21277: LIST
21278: PUSH
21279: EMPTY
21280: LIST
21281: LIST
21282: PPUSH
21283: CALL_OW 69
21287: PUSH
21288: LD_INT 4
21290: GREATEREQUAL
21291: AND
21292: PUSH
21293: LD_EXP 15
21297: PUSH
21298: LD_INT 2
21300: EQUAL
21301: AND
21302: IFFALSE 23926
21304: GO 21306
21306: DISABLE
21307: LD_INT 0
21309: PPUSH
21310: PPUSH
21311: PPUSH
21312: PPUSH
21313: PPUSH
21314: PPUSH
21315: PPUSH
21316: PPUSH
21317: PPUSH
21318: PPUSH
21319: PPUSH
// begin missionStage := 3 ;
21320: LD_ADDR_EXP 15
21324: PUSH
21325: LD_INT 3
21327: ST_TO_ADDR
// retreat := false ;
21328: LD_ADDR_VAR 0 4
21332: PUSH
21333: LD_INT 0
21335: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
21336: LD_ADDR_VAR 0 5
21340: PUSH
21341: LD_INT 22
21343: PUSH
21344: LD_INT 4
21346: PUSH
21347: EMPTY
21348: LIST
21349: LIST
21350: PUSH
21351: LD_INT 30
21353: PUSH
21354: LD_INT 4
21356: PUSH
21357: EMPTY
21358: LIST
21359: LIST
21360: PUSH
21361: EMPTY
21362: LIST
21363: LIST
21364: PPUSH
21365: CALL_OW 69
21369: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21370: LD_ADDR_VAR 0 6
21374: PUSH
21375: LD_INT 22
21377: PUSH
21378: LD_INT 4
21380: PUSH
21381: EMPTY
21382: LIST
21383: LIST
21384: PUSH
21385: LD_INT 30
21387: PUSH
21388: LD_INT 5
21390: PUSH
21391: EMPTY
21392: LIST
21393: LIST
21394: PUSH
21395: EMPTY
21396: LIST
21397: LIST
21398: PPUSH
21399: CALL_OW 69
21403: ST_TO_ADDR
// if not bar then
21404: LD_VAR 0 6
21408: NOT
21409: IFFALSE 21462
// begin repeat wait ( 0 0$1 ) ;
21411: LD_INT 35
21413: PPUSH
21414: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
21418: LD_INT 22
21420: PUSH
21421: LD_INT 4
21423: PUSH
21424: EMPTY
21425: LIST
21426: LIST
21427: PUSH
21428: LD_INT 3
21430: PUSH
21431: LD_INT 57
21433: PUSH
21434: EMPTY
21435: LIST
21436: PUSH
21437: EMPTY
21438: LIST
21439: LIST
21440: PUSH
21441: LD_INT 30
21443: PUSH
21444: LD_INT 5
21446: PUSH
21447: EMPTY
21448: LIST
21449: LIST
21450: PUSH
21451: EMPTY
21452: LIST
21453: LIST
21454: LIST
21455: PPUSH
21456: CALL_OW 69
21460: IFFALSE 21411
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21462: LD_ADDR_VAR 0 6
21466: PUSH
21467: LD_INT 22
21469: PUSH
21470: LD_INT 4
21472: PUSH
21473: EMPTY
21474: LIST
21475: LIST
21476: PUSH
21477: LD_INT 30
21479: PUSH
21480: LD_INT 5
21482: PUSH
21483: EMPTY
21484: LIST
21485: LIST
21486: PUSH
21487: EMPTY
21488: LIST
21489: LIST
21490: PPUSH
21491: CALL_OW 69
21495: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21496: LD_INT 35
21498: PPUSH
21499: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
21503: LD_EXP 121
21507: PUSH
21508: LD_INT 4
21510: ARRAY
21511: PUSH
21512: LD_INT 4
21514: GREATEREQUAL
21515: IFFALSE 21496
// tmp := [ ] ;
21517: LD_ADDR_VAR 0 2
21521: PUSH
21522: EMPTY
21523: ST_TO_ADDR
// tmp2 := [ ] ;
21524: LD_ADDR_VAR 0 3
21528: PUSH
21529: EMPTY
21530: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell union vip ) do
21531: LD_ADDR_VAR 0 1
21535: PUSH
21536: LD_INT 22
21538: PUSH
21539: LD_INT 4
21541: PUSH
21542: EMPTY
21543: LIST
21544: LIST
21545: PUSH
21546: LD_INT 2
21548: PUSH
21549: LD_INT 25
21551: PUSH
21552: LD_INT 1
21554: PUSH
21555: EMPTY
21556: LIST
21557: LIST
21558: PUSH
21559: LD_INT 25
21561: PUSH
21562: LD_INT 2
21564: PUSH
21565: EMPTY
21566: LIST
21567: LIST
21568: PUSH
21569: LD_INT 25
21571: PUSH
21572: LD_INT 3
21574: PUSH
21575: EMPTY
21576: LIST
21577: LIST
21578: PUSH
21579: LD_INT 25
21581: PUSH
21582: LD_INT 4
21584: PUSH
21585: EMPTY
21586: LIST
21587: LIST
21588: PUSH
21589: LD_INT 25
21591: PUSH
21592: LD_INT 5
21594: PUSH
21595: EMPTY
21596: LIST
21597: LIST
21598: PUSH
21599: EMPTY
21600: LIST
21601: LIST
21602: LIST
21603: LIST
21604: LIST
21605: LIST
21606: PUSH
21607: EMPTY
21608: LIST
21609: LIST
21610: PPUSH
21611: CALL_OW 69
21615: PUSH
21616: LD_EXP 61
21620: PUSH
21621: LD_EXP 62
21625: UNION
21626: DIFF
21627: PUSH
21628: FOR_IN
21629: IFFALSE 21691
// if not i in extraSquad then
21631: LD_VAR 0 1
21635: PUSH
21636: LD_EXP 63
21640: IN
21641: NOT
21642: IFFALSE 21666
// tmp := Join ( tmp , i ) else
21644: LD_ADDR_VAR 0 2
21648: PUSH
21649: LD_VAR 0 2
21653: PPUSH
21654: LD_VAR 0 1
21658: PPUSH
21659: CALL 108004 0 2
21663: ST_TO_ADDR
21664: GO 21689
// tmp := Insert ( tmp , 1 , i ) ;
21666: LD_ADDR_VAR 0 2
21670: PUSH
21671: LD_VAR 0 2
21675: PPUSH
21676: LD_INT 1
21678: PPUSH
21679: LD_VAR 0 1
21683: PPUSH
21684: CALL_OW 2
21688: ST_TO_ADDR
21689: GO 21628
21691: POP
21692: POP
// tmp := tmp diff 0 ;
21693: LD_ADDR_VAR 0 2
21697: PUSH
21698: LD_VAR 0 2
21702: PUSH
21703: LD_INT 0
21705: DIFF
21706: ST_TO_ADDR
// p := 0 ;
21707: LD_ADDR_VAR 0 11
21711: PUSH
21712: LD_INT 0
21714: ST_TO_ADDR
// for i in UnitFilter ( tmp , [ f_sex , sex_male ] ) do
21715: LD_ADDR_VAR 0 1
21719: PUSH
21720: LD_VAR 0 2
21724: PPUSH
21725: LD_INT 26
21727: PUSH
21728: LD_INT 1
21730: PUSH
21731: EMPTY
21732: LIST
21733: LIST
21734: PPUSH
21735: CALL_OW 72
21739: PUSH
21740: FOR_IN
21741: IFFALSE 21792
// begin p := Inc ( p ) ;
21743: LD_ADDR_VAR 0 11
21747: PUSH
21748: LD_VAR 0 11
21752: PPUSH
21753: CALL 109365 0 1
21757: ST_TO_ADDR
// tmp2 := Join ( tmp2 , i ) ;
21758: LD_ADDR_VAR 0 3
21762: PUSH
21763: LD_VAR 0 3
21767: PPUSH
21768: LD_VAR 0 1
21772: PPUSH
21773: CALL 108004 0 2
21777: ST_TO_ADDR
// if p = 4 then
21778: LD_VAR 0 11
21782: PUSH
21783: LD_INT 4
21785: EQUAL
21786: IFFALSE 21790
// break ;
21788: GO 21792
// end ;
21790: GO 21740
21792: POP
21793: POP
// tmp := tmp diff tmp2 ;
21794: LD_ADDR_VAR 0 2
21798: PUSH
21799: LD_VAR 0 2
21803: PUSH
21804: LD_VAR 0 3
21808: DIFF
21809: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
21810: LD_ADDR_VAR 0 2
21814: PUSH
21815: LD_VAR 0 2
21819: PPUSH
21820: LD_INT 3
21822: PPUSH
21823: CALL 106508 0 2
21827: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
21828: LD_ADDR_VAR 0 3
21832: PUSH
21833: LD_VAR 0 3
21837: PPUSH
21838: LD_INT 3
21840: PPUSH
21841: CALL 106508 0 2
21845: ST_TO_ADDR
// for i := 1 to 4 do
21846: LD_ADDR_VAR 0 1
21850: PUSH
21851: DOUBLE
21852: LD_INT 1
21854: DEC
21855: ST_TO_ADDR
21856: LD_INT 4
21858: PUSH
21859: FOR_TO
21860: IFFALSE 22026
// begin if tmp2 then
21862: LD_VAR 0 3
21866: IFFALSE 21947
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
21868: LD_ADDR_EXP 18
21872: PUSH
21873: LD_EXP 18
21877: PPUSH
21878: LD_INT 1
21880: PPUSH
21881: LD_EXP 18
21885: PUSH
21886: LD_INT 1
21888: ARRAY
21889: PUSH
21890: LD_VAR 0 3
21894: PUSH
21895: LD_VAR 0 3
21899: ARRAY
21900: ADD
21901: PPUSH
21902: CALL_OW 1
21906: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
21907: LD_VAR 0 3
21911: PUSH
21912: LD_VAR 0 3
21916: ARRAY
21917: PPUSH
21918: LD_INT 1
21920: PPUSH
21921: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
21925: LD_ADDR_VAR 0 3
21929: PUSH
21930: LD_VAR 0 3
21934: PPUSH
21935: LD_VAR 0 3
21939: PPUSH
21940: CALL_OW 3
21944: ST_TO_ADDR
// end else
21945: GO 22024
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
21947: LD_ADDR_EXP 18
21951: PUSH
21952: LD_EXP 18
21956: PPUSH
21957: LD_INT 1
21959: PPUSH
21960: LD_EXP 18
21964: PUSH
21965: LD_INT 1
21967: ARRAY
21968: PUSH
21969: LD_VAR 0 2
21973: PUSH
21974: LD_VAR 0 2
21978: ARRAY
21979: ADD
21980: PPUSH
21981: CALL_OW 1
21985: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
21986: LD_VAR 0 2
21990: PUSH
21991: LD_VAR 0 2
21995: ARRAY
21996: PPUSH
21997: LD_INT 1
21999: PPUSH
22000: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
22004: LD_ADDR_VAR 0 2
22008: PUSH
22009: LD_VAR 0 2
22013: PPUSH
22014: LD_VAR 0 2
22018: PPUSH
22019: CALL_OW 3
22023: ST_TO_ADDR
// end ; end ;
22024: GO 21859
22026: POP
22027: POP
// if tmp2 then
22028: LD_VAR 0 3
22032: IFFALSE 22050
// tmp := tmp union tmp2 ;
22034: LD_ADDR_VAR 0 2
22038: PUSH
22039: LD_VAR 0 2
22043: PUSH
22044: LD_VAR 0 3
22048: UNION
22049: ST_TO_ADDR
// for i := 0 to 3 do
22050: LD_ADDR_VAR 0 1
22054: PUSH
22055: DOUBLE
22056: LD_INT 0
22058: DEC
22059: ST_TO_ADDR
22060: LD_INT 3
22062: PUSH
22063: FOR_TO
22064: IFFALSE 22227
// begin if not tmp [ tmp - i ] then
22066: LD_VAR 0 2
22070: PUSH
22071: LD_VAR 0 2
22075: PUSH
22076: LD_VAR 0 1
22080: MINUS
22081: ARRAY
22082: NOT
22083: IFFALSE 22180
// begin uc_side := 4 ;
22085: LD_ADDR_OWVAR 20
22089: PUSH
22090: LD_INT 4
22092: ST_TO_ADDR
// uc_nation := 1 ;
22093: LD_ADDR_OWVAR 21
22097: PUSH
22098: LD_INT 1
22100: ST_TO_ADDR
// InitHc ;
22101: CALL_OW 19
// PrepareSoldier ( sex_male , 3 ) ;
22105: LD_INT 1
22107: PPUSH
22108: LD_INT 3
22110: PPUSH
22111: CALL_OW 381
// un := CreateHuman ;
22115: LD_ADDR_VAR 0 8
22119: PUSH
22120: CALL_OW 44
22124: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( 39 , 61 ) ) ;
22125: LD_VAR 0 8
22129: PPUSH
22130: LD_INT 39
22132: PPUSH
22133: LD_INT 61
22135: PPUSH
22136: CALL_OW 428
22140: PPUSH
22141: CALL_OW 52
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ un ) ;
22145: LD_ADDR_EXP 18
22149: PUSH
22150: LD_EXP 18
22154: PPUSH
22155: LD_INT 2
22157: PPUSH
22158: LD_EXP 18
22162: PUSH
22163: LD_INT 2
22165: ARRAY
22166: PUSH
22167: LD_VAR 0 8
22171: ADD
22172: PPUSH
22173: CALL_OW 1
22177: ST_TO_ADDR
// end else
22178: GO 22225
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
22180: LD_ADDR_EXP 18
22184: PUSH
22185: LD_EXP 18
22189: PPUSH
22190: LD_INT 2
22192: PPUSH
22193: LD_EXP 18
22197: PUSH
22198: LD_INT 2
22200: ARRAY
22201: PUSH
22202: LD_VAR 0 2
22206: PUSH
22207: LD_VAR 0 2
22211: PUSH
22212: LD_VAR 0 1
22216: MINUS
22217: ARRAY
22218: ADD
22219: PPUSH
22220: CALL_OW 1
22224: ST_TO_ADDR
// end ;
22225: GO 22063
22227: POP
22228: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
22229: LD_ADDR_EXP 102
22233: PUSH
22234: LD_EXP 102
22238: PPUSH
22239: LD_INT 4
22241: PPUSH
22242: LD_EXP 102
22246: PUSH
22247: LD_INT 4
22249: ARRAY
22250: PUSH
22251: LD_EXP 18
22255: PUSH
22256: LD_INT 1
22258: ARRAY
22259: DIFF
22260: PPUSH
22261: CALL_OW 1
22265: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
22266: LD_VAR 0 5
22270: PUSH
22271: LD_INT 1
22273: ARRAY
22274: PPUSH
22275: CALL_OW 313
22279: IFFALSE 22334
// begin for i in UnitsInside ( arm [ 1 ] ) do
22281: LD_ADDR_VAR 0 1
22285: PUSH
22286: LD_VAR 0 5
22290: PUSH
22291: LD_INT 1
22293: ARRAY
22294: PPUSH
22295: CALL_OW 313
22299: PUSH
22300: FOR_IN
22301: IFFALSE 22332
// begin ComExitBuilding ( i ) ;
22303: LD_VAR 0 1
22307: PPUSH
22308: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
22312: LD_VAR 0 1
22316: PPUSH
22317: LD_VAR 0 6
22321: PUSH
22322: LD_INT 1
22324: ARRAY
22325: PPUSH
22326: CALL_OW 180
// end ;
22330: GO 22300
22332: POP
22333: POP
// end ; wait ( 0 0$5 ) ;
22334: LD_INT 175
22336: PPUSH
22337: CALL_OW 67
// repeat wait ( 0 0$1 ) until not UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) ;
22341: LD_INT 35
22343: PPUSH
22344: CALL_OW 67
22348: LD_EXP 18
22352: PUSH
22353: LD_INT 1
22355: ARRAY
22356: PPUSH
22357: LD_INT 55
22359: PUSH
22360: EMPTY
22361: LIST
22362: PPUSH
22363: CALL_OW 72
22367: NOT
22368: IFFALSE 22341
// for i in powellSquadAttack [ 1 ] do
22370: LD_ADDR_VAR 0 1
22374: PUSH
22375: LD_EXP 18
22379: PUSH
22380: LD_INT 1
22382: ARRAY
22383: PUSH
22384: FOR_IN
22385: IFFALSE 22492
// begin if IsInUnit ( i ) then
22387: LD_VAR 0 1
22391: PPUSH
22392: CALL_OW 310
22396: IFFALSE 22407
// ComExitBuilding ( i ) ;
22398: LD_VAR 0 1
22402: PPUSH
22403: CALL_OW 122
// if GetClass ( i ) <> 1 then
22407: LD_VAR 0 1
22411: PPUSH
22412: CALL_OW 257
22416: PUSH
22417: LD_INT 1
22419: NONEQUAL
22420: IFFALSE 22461
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
22422: LD_VAR 0 1
22426: PPUSH
22427: LD_VAR 0 5
22431: PUSH
22432: LD_INT 1
22434: ARRAY
22435: PPUSH
22436: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
22440: LD_VAR 0 1
22444: PPUSH
22445: LD_INT 1
22447: PPUSH
22448: CALL_OW 183
// AddComExitBuilding ( i ) ;
22452: LD_VAR 0 1
22456: PPUSH
22457: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
22461: LD_VAR 0 1
22465: PPUSH
22466: LD_INT 60
22468: PPUSH
22469: LD_INT 94
22471: PPUSH
22472: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
22476: LD_VAR 0 1
22480: PPUSH
22481: LD_EXP 61
22485: PPUSH
22486: CALL_OW 179
// end ;
22490: GO 22384
22492: POP
22493: POP
// wait ( 0 0$45 ) ;
22494: LD_INT 1575
22496: PPUSH
22497: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
22501: LD_EXP 61
22505: PPUSH
22506: LD_STRING D4-Pow-1
22508: PPUSH
22509: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
22513: LD_ADDR_VAR 0 2
22517: PUSH
22518: LD_EXP 18
22522: PUSH
22523: LD_INT 1
22525: ARRAY
22526: PPUSH
22527: LD_INT 26
22529: PUSH
22530: LD_INT 1
22532: PUSH
22533: EMPTY
22534: LIST
22535: LIST
22536: PPUSH
22537: CALL_OW 72
22541: ST_TO_ADDR
// if tmp then
22542: LD_VAR 0 2
22546: IFFALSE 22564
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
22548: LD_VAR 0 2
22552: PUSH
22553: LD_INT 1
22555: ARRAY
22556: PPUSH
22557: LD_STRING D4-Sol1-1
22559: PPUSH
22560: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
22564: LD_EXP 61
22568: PPUSH
22569: LD_STRING D4-Pow-2
22571: PPUSH
22572: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
22576: LD_ADDR_VAR 0 1
22580: PUSH
22581: DOUBLE
22582: LD_INT 1
22584: DEC
22585: ST_TO_ADDR
22586: LD_EXP 18
22590: PUSH
22591: LD_INT 1
22593: ARRAY
22594: PUSH
22595: FOR_TO
22596: IFFALSE 22689
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
22598: LD_EXP 18
22602: PUSH
22603: LD_INT 1
22605: ARRAY
22606: PUSH
22607: LD_VAR 0 1
22611: ARRAY
22612: PPUSH
22613: LD_EXP 121
22617: PUSH
22618: LD_INT 4
22620: ARRAY
22621: PUSH
22622: LD_INT 1
22624: ARRAY
22625: PPUSH
22626: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
22630: LD_ADDR_EXP 121
22634: PUSH
22635: LD_EXP 121
22639: PPUSH
22640: LD_INT 4
22642: PPUSH
22643: LD_EXP 121
22647: PUSH
22648: LD_INT 4
22650: ARRAY
22651: PPUSH
22652: LD_INT 1
22654: PPUSH
22655: CALL_OW 3
22659: PPUSH
22660: CALL_OW 1
22664: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
22665: LD_INT 8
22667: PPUSH
22668: LD_EXP 18
22672: PUSH
22673: LD_INT 1
22675: ARRAY
22676: PUSH
22677: LD_VAR 0 1
22681: ARRAY
22682: PPUSH
22683: CALL_OW 471
// end ;
22687: GO 22595
22689: POP
22690: POP
// repeat wait ( 0 0$1 ) ;
22691: LD_INT 35
22693: PPUSH
22694: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
22698: LD_EXP 18
22702: PUSH
22703: LD_INT 1
22705: ARRAY
22706: PPUSH
22707: LD_INT 55
22709: PUSH
22710: EMPTY
22711: LIST
22712: PPUSH
22713: CALL_OW 72
22717: PUSH
22718: LD_INT 4
22720: GREATEREQUAL
22721: IFFALSE 22691
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
22723: LD_EXP 18
22727: PUSH
22728: LD_INT 1
22730: ARRAY
22731: PPUSH
22732: LD_INT 69
22734: PPUSH
22735: LD_INT 94
22737: PPUSH
22738: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
22742: LD_EXP 18
22746: PUSH
22747: LD_INT 1
22749: ARRAY
22750: PPUSH
22751: LD_INT 82
22753: PPUSH
22754: LD_INT 83
22756: PPUSH
22757: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
22761: LD_EXP 18
22765: PUSH
22766: LD_INT 1
22768: ARRAY
22769: PPUSH
22770: LD_INT 77
22772: PPUSH
22773: LD_INT 69
22775: PPUSH
22776: CALL_OW 174
// wait ( 0 0$30 ) ;
22780: LD_INT 1050
22782: PPUSH
22783: CALL_OW 67
// repeat wait ( 3 ) ;
22787: LD_INT 3
22789: PPUSH
22790: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
22794: LD_ADDR_VAR 0 1
22798: PUSH
22799: LD_EXP 18
22803: PUSH
22804: LD_INT 1
22806: ARRAY
22807: PUSH
22808: FOR_IN
22809: IFFALSE 22945
// begin if GetLives ( i ) < 990 then
22811: LD_VAR 0 1
22815: PPUSH
22816: CALL_OW 256
22820: PUSH
22821: LD_INT 990
22823: LESS
22824: IFFALSE 22838
// SetLives ( i , 1000 ) ;
22826: LD_VAR 0 1
22830: PPUSH
22831: LD_INT 1000
22833: PPUSH
22834: CALL_OW 234
// if not IsInUnit ( i ) then
22838: LD_VAR 0 1
22842: PPUSH
22843: CALL_OW 310
22847: NOT
22848: IFFALSE 22943
// begin if not HasTask ( i ) then
22850: LD_VAR 0 1
22854: PPUSH
22855: CALL_OW 314
22859: NOT
22860: IFFALSE 22877
// ComMoveXY ( i , 64 , 93 ) ;
22862: LD_VAR 0 1
22866: PPUSH
22867: LD_INT 64
22869: PPUSH
22870: LD_INT 93
22872: PPUSH
22873: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
22877: LD_VAR 0 4
22881: NOT
22882: PUSH
22883: LD_VAR 0 1
22887: PPUSH
22888: CALL_OW 258
22892: PUSH
22893: LD_INT 1
22895: EQUAL
22896: AND
22897: IFFALSE 22943
// begin retreat := true ;
22899: LD_ADDR_VAR 0 4
22903: PUSH
22904: LD_INT 1
22906: ST_TO_ADDR
// SetTag ( i , 2 ) ;
22907: LD_VAR 0 1
22911: PPUSH
22912: LD_INT 2
22914: PPUSH
22915: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
22919: LD_VAR 0 1
22923: PPUSH
22924: LD_STRING D4a-Sol1-1
22926: PPUSH
22927: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
22931: LD_EXP 61
22935: PPUSH
22936: LD_STRING D4a-Pow-1
22938: PPUSH
22939: CALL_OW 88
// end ; end ; end ;
22943: GO 22808
22945: POP
22946: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_inarea , powellBase ] ) >= 4 ;
22947: LD_EXP 18
22951: PUSH
22952: LD_INT 1
22954: ARRAY
22955: PPUSH
22956: LD_INT 95
22958: PUSH
22959: LD_INT 9
22961: PUSH
22962: EMPTY
22963: LIST
22964: LIST
22965: PPUSH
22966: CALL_OW 72
22970: PUSH
22971: LD_INT 4
22973: GREATEREQUAL
22974: IFFALSE 22787
// for i in powellSquadAttack [ 1 ] do
22976: LD_ADDR_VAR 0 1
22980: PUSH
22981: LD_EXP 18
22985: PUSH
22986: LD_INT 1
22988: ARRAY
22989: PUSH
22990: FOR_IN
22991: IFFALSE 23127
// begin if GetTag ( i ) = 2 then
22993: LD_VAR 0 1
22997: PPUSH
22998: CALL_OW 110
23002: PUSH
23003: LD_INT 2
23005: EQUAL
23006: IFFALSE 23068
// begin ComMoveXY ( i , 60 , 94 ) ;
23008: LD_VAR 0 1
23012: PPUSH
23013: LD_INT 60
23015: PPUSH
23016: LD_INT 94
23018: PPUSH
23019: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
23023: LD_VAR 0 1
23027: PPUSH
23028: LD_EXP 61
23032: PPUSH
23033: CALL_OW 179
// wait ( 0 0$3 ) ;
23037: LD_INT 105
23039: PPUSH
23040: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
23044: LD_VAR 0 1
23048: PPUSH
23049: LD_STRING D4a-Sol1-2
23051: PPUSH
23052: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
23056: LD_EXP 61
23060: PPUSH
23061: LD_STRING D4a-Pow-2
23063: PPUSH
23064: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
23068: LD_VAR 0 1
23072: PPUSH
23073: LD_INT 0
23075: PPUSH
23076: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
23080: LD_ADDR_EXP 102
23084: PUSH
23085: LD_EXP 102
23089: PPUSH
23090: LD_INT 4
23092: PPUSH
23093: LD_EXP 102
23097: PUSH
23098: LD_INT 4
23100: ARRAY
23101: PUSH
23102: LD_VAR 0 1
23106: UNION
23107: PPUSH
23108: CALL_OW 1
23112: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
23113: LD_INT 8
23115: PPUSH
23116: LD_VAR 0 1
23120: PPUSH
23121: CALL_OW 472
// end ;
23125: GO 22990
23127: POP
23128: POP
// wait ( 1 1$00 ) ;
23129: LD_INT 2100
23131: PPUSH
23132: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
23136: LD_ADDR_VAR 0 9
23140: PUSH
23141: LD_INT 22
23143: PUSH
23144: LD_INT 4
23146: PUSH
23147: EMPTY
23148: LIST
23149: LIST
23150: PUSH
23151: LD_INT 30
23153: PUSH
23154: LD_INT 32
23156: PUSH
23157: EMPTY
23158: LIST
23159: LIST
23160: PUSH
23161: LD_INT 58
23163: PUSH
23164: EMPTY
23165: LIST
23166: PUSH
23167: EMPTY
23168: LIST
23169: LIST
23170: LIST
23171: PPUSH
23172: CALL_OW 69
23176: ST_TO_ADDR
// if tmp then
23177: LD_VAR 0 2
23181: IFFALSE 23421
// begin for i := 1 to tmp do
23183: LD_ADDR_VAR 0 1
23187: PUSH
23188: DOUBLE
23189: LD_INT 1
23191: DEC
23192: ST_TO_ADDR
23193: LD_VAR 0 2
23197: PUSH
23198: FOR_TO
23199: IFFALSE 23412
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
23201: LD_ADDR_EXP 102
23205: PUSH
23206: LD_EXP 102
23210: PPUSH
23211: LD_INT 4
23213: PPUSH
23214: LD_EXP 102
23218: PUSH
23219: LD_INT 4
23221: ARRAY
23222: PUSH
23223: LD_VAR 0 2
23227: PUSH
23228: LD_VAR 0 1
23232: ARRAY
23233: DIFF
23234: PPUSH
23235: CALL_OW 1
23239: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
23240: LD_ADDR_VAR 0 10
23244: PUSH
23245: LD_VAR 0 2
23249: PUSH
23250: LD_VAR 0 1
23254: ARRAY
23255: PPUSH
23256: CALL_OW 310
23260: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
23261: LD_VAR 0 10
23265: PUSH
23266: LD_VAR 0 10
23270: PPUSH
23271: CALL_OW 266
23275: PUSH
23276: LD_INT 32
23278: EQUAL
23279: AND
23280: IFFALSE 23284
// continue ;
23282: GO 23198
// if t then
23284: LD_VAR 0 10
23288: IFFALSE 23305
// ComExitBuilding ( tmp [ i ] ) ;
23290: LD_VAR 0 2
23294: PUSH
23295: LD_VAR 0 1
23299: ARRAY
23300: PPUSH
23301: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
23305: LD_VAR 0 2
23309: PUSH
23310: LD_VAR 0 1
23314: ARRAY
23315: PPUSH
23316: LD_VAR 0 5
23320: PUSH
23321: LD_INT 1
23323: ARRAY
23324: PPUSH
23325: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
23329: LD_VAR 0 2
23333: PUSH
23334: LD_VAR 0 1
23338: ARRAY
23339: PPUSH
23340: LD_INT 1
23342: PPUSH
23343: CALL_OW 183
// if emptyTowers then
23347: LD_VAR 0 9
23351: IFFALSE 23410
// begin AddComExitBuilding ( tmp [ i ] ) ;
23353: LD_VAR 0 2
23357: PUSH
23358: LD_VAR 0 1
23362: ARRAY
23363: PPUSH
23364: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
23368: LD_VAR 0 2
23372: PUSH
23373: LD_VAR 0 1
23377: ARRAY
23378: PPUSH
23379: LD_VAR 0 9
23383: PUSH
23384: LD_INT 1
23386: ARRAY
23387: PPUSH
23388: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
23392: LD_ADDR_VAR 0 9
23396: PUSH
23397: LD_VAR 0 9
23401: PPUSH
23402: LD_INT 1
23404: PPUSH
23405: CALL_OW 3
23409: ST_TO_ADDR
// end ; end ;
23410: GO 23198
23412: POP
23413: POP
// wait ( 0 0$30 ) ;
23414: LD_INT 1050
23416: PPUSH
23417: CALL_OW 67
// end ; uc_side := 6 ;
23421: LD_ADDR_OWVAR 20
23425: PUSH
23426: LD_INT 6
23428: ST_TO_ADDR
// uc_nation := 3 ;
23429: LD_ADDR_OWVAR 21
23433: PUSH
23434: LD_INT 3
23436: ST_TO_ADDR
// ru := [ ] ;
23437: LD_ADDR_VAR 0 7
23441: PUSH
23442: EMPTY
23443: ST_TO_ADDR
// for i = 1 to 5 do
23444: LD_ADDR_VAR 0 1
23448: PUSH
23449: DOUBLE
23450: LD_INT 1
23452: DEC
23453: ST_TO_ADDR
23454: LD_INT 5
23456: PUSH
23457: FOR_TO
23458: IFFALSE 23578
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
23460: LD_INT 22
23462: PUSH
23463: LD_INT 23
23465: PUSH
23466: EMPTY
23467: LIST
23468: LIST
23469: PUSH
23470: LD_INT 1
23472: PPUSH
23473: LD_INT 2
23475: PPUSH
23476: CALL_OW 12
23480: ARRAY
23481: PPUSH
23482: LD_INT 1
23484: PPUSH
23485: LD_INT 3
23487: PPUSH
23488: LD_INT 43
23490: PUSH
23491: LD_INT 44
23493: PUSH
23494: EMPTY
23495: LIST
23496: LIST
23497: PUSH
23498: LD_INT 1
23500: PPUSH
23501: LD_INT 2
23503: PPUSH
23504: CALL_OW 12
23508: ARRAY
23509: PPUSH
23510: LD_INT 89
23512: PPUSH
23513: CALL 75133 0 5
// un := CreateVehicle ;
23517: LD_ADDR_VAR 0 8
23521: PUSH
23522: CALL_OW 45
23526: ST_TO_ADDR
// SetDir ( un , 4 ) ;
23527: LD_VAR 0 8
23531: PPUSH
23532: LD_INT 4
23534: PPUSH
23535: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
23539: LD_VAR 0 8
23543: PPUSH
23544: LD_INT 136
23546: PPUSH
23547: LD_INT 90
23549: PPUSH
23550: LD_INT 8
23552: PPUSH
23553: LD_INT 0
23555: PPUSH
23556: CALL_OW 50
// ru := ru ^ un ;
23560: LD_ADDR_VAR 0 7
23564: PUSH
23565: LD_VAR 0 7
23569: PUSH
23570: LD_VAR 0 8
23574: ADD
23575: ST_TO_ADDR
// end ;
23576: GO 23457
23578: POP
23579: POP
// if ru then
23580: LD_VAR 0 7
23584: IFFALSE 23601
// ComAgressiveMove ( ru , 57 , 94 ) ;
23586: LD_VAR 0 7
23590: PPUSH
23591: LD_INT 57
23593: PPUSH
23594: LD_INT 94
23596: PPUSH
23597: CALL_OW 114
// wait ( 3 3$00 ) ;
23601: LD_INT 6300
23603: PPUSH
23604: CALL_OW 67
// p := UnitsInside ( HexInfo ( 54 , 85 ) ) ;
23608: LD_ADDR_VAR 0 11
23612: PUSH
23613: LD_INT 54
23615: PPUSH
23616: LD_INT 85
23618: PPUSH
23619: CALL_OW 428
23623: PPUSH
23624: CALL_OW 313
23628: ST_TO_ADDR
// t := 0 ;
23629: LD_ADDR_VAR 0 10
23633: PUSH
23634: LD_INT 0
23636: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_empty ] ] , [ f_btype , b_bunker ] ] ) do
23637: LD_ADDR_VAR 0 1
23641: PUSH
23642: LD_INT 22
23644: PUSH
23645: LD_INT 4
23647: PUSH
23648: EMPTY
23649: LIST
23650: LIST
23651: PUSH
23652: LD_INT 3
23654: PUSH
23655: LD_INT 58
23657: PUSH
23658: EMPTY
23659: LIST
23660: PUSH
23661: EMPTY
23662: LIST
23663: LIST
23664: PUSH
23665: LD_INT 30
23667: PUSH
23668: LD_INT 32
23670: PUSH
23671: EMPTY
23672: LIST
23673: LIST
23674: PUSH
23675: EMPTY
23676: LIST
23677: LIST
23678: LIST
23679: PPUSH
23680: CALL_OW 69
23684: PUSH
23685: FOR_IN
23686: IFFALSE 23812
// begin if p + t > 5 then
23688: LD_VAR 0 11
23692: PUSH
23693: LD_VAR 0 10
23697: PLUS
23698: PUSH
23699: LD_INT 5
23701: GREATER
23702: IFFALSE 23706
// break ;
23704: GO 23812
// un := UnitsInside ( i ) ;
23706: LD_ADDR_VAR 0 8
23710: PUSH
23711: LD_VAR 0 1
23715: PPUSH
23716: CALL_OW 313
23720: ST_TO_ADDR
// ComExitBuilding ( un ) ;
23721: LD_VAR 0 8
23725: PPUSH
23726: CALL_OW 122
// AddComEnterUnit ( un , HexInfo ( 54 , 85 ) ) ;
23730: LD_VAR 0 8
23734: PPUSH
23735: LD_INT 54
23737: PPUSH
23738: LD_INT 85
23740: PPUSH
23741: CALL_OW 428
23745: PPUSH
23746: CALL_OW 180
// AddComChangeProfession ( un , class_mechanic ) ;
23750: LD_VAR 0 8
23754: PPUSH
23755: LD_INT 3
23757: PPUSH
23758: CALL_OW 183
// t := Inc ( t ) ;
23762: LD_ADDR_VAR 0 10
23766: PUSH
23767: LD_VAR 0 10
23771: PPUSH
23772: CALL 109365 0 1
23776: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] ^ un ) ;
23777: LD_ADDR_EXP 102
23781: PUSH
23782: LD_EXP 102
23786: PPUSH
23787: LD_INT 4
23789: PPUSH
23790: LD_EXP 102
23794: PUSH
23795: LD_INT 4
23797: ARRAY
23798: PUSH
23799: LD_VAR 0 8
23803: ADD
23804: PPUSH
23805: CALL_OW 1
23809: ST_TO_ADDR
// end ;
23810: GO 23685
23812: POP
23813: POP
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
23814: LD_INT 4
23816: PPUSH
23817: LD_INT 3
23819: PUSH
23820: LD_INT 1
23822: PUSH
23823: LD_INT 1
23825: PUSH
23826: LD_INT 5
23828: PUSH
23829: EMPTY
23830: LIST
23831: LIST
23832: LIST
23833: LIST
23834: PUSH
23835: LD_INT 4
23837: PUSH
23838: LD_INT 1
23840: PUSH
23841: LD_INT 1
23843: PUSH
23844: LD_INT 6
23846: PUSH
23847: EMPTY
23848: LIST
23849: LIST
23850: LIST
23851: LIST
23852: PUSH
23853: LD_INT 4
23855: PUSH
23856: LD_INT 1
23858: PUSH
23859: LD_INT 1
23861: PUSH
23862: LD_INT 7
23864: PUSH
23865: EMPTY
23866: LIST
23867: LIST
23868: LIST
23869: LIST
23870: PUSH
23871: LD_INT 3
23873: PUSH
23874: LD_INT 1
23876: PUSH
23877: LD_INT 1
23879: PUSH
23880: LD_INT 7
23882: PUSH
23883: EMPTY
23884: LIST
23885: LIST
23886: LIST
23887: LIST
23888: PUSH
23889: LD_INT 3
23891: PUSH
23892: LD_INT 1
23894: PUSH
23895: LD_INT 1
23897: PUSH
23898: LD_INT 5
23900: PUSH
23901: EMPTY
23902: LIST
23903: LIST
23904: LIST
23905: LIST
23906: PUSH
23907: EMPTY
23908: LIST
23909: LIST
23910: LIST
23911: LIST
23912: LIST
23913: PPUSH
23914: CALL 63798 0 2
// missionStage := 4 ;
23918: LD_ADDR_EXP 15
23922: PUSH
23923: LD_INT 4
23925: ST_TO_ADDR
// end ;
23926: PPOPN 11
23928: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , t , _xy , dist , fac , arm , speaker , emp_towers , veh ;
23929: LD_EXP 15
23933: PUSH
23934: LD_INT 4
23936: EQUAL
23937: PUSH
23938: LD_INT 22
23940: PUSH
23941: LD_INT 4
23943: PUSH
23944: EMPTY
23945: LIST
23946: LIST
23947: PUSH
23948: LD_INT 21
23950: PUSH
23951: LD_INT 2
23953: PUSH
23954: EMPTY
23955: LIST
23956: LIST
23957: PUSH
23958: EMPTY
23959: LIST
23960: LIST
23961: PPUSH
23962: CALL_OW 69
23966: PUSH
23967: LD_INT 5
23969: GREATEREQUAL
23970: AND
23971: IFFALSE 28335
23973: GO 23975
23975: DISABLE
23976: LD_INT 0
23978: PPUSH
23979: PPUSH
23980: PPUSH
23981: PPUSH
23982: PPUSH
23983: PPUSH
23984: PPUSH
23985: PPUSH
23986: PPUSH
23987: PPUSH
23988: PPUSH
23989: PPUSH
23990: PPUSH
23991: PPUSH
// begin wait ( 0 0$10 ) ;
23992: LD_INT 350
23994: PPUSH
23995: CALL_OW 67
// missionStage := 5 ;
23999: LD_ADDR_EXP 15
24003: PUSH
24004: LD_INT 5
24006: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
24007: LD_ADDR_VAR 0 11
24011: PUSH
24012: LD_INT 22
24014: PUSH
24015: LD_INT 4
24017: PUSH
24018: EMPTY
24019: LIST
24020: LIST
24021: PUSH
24022: LD_INT 2
24024: PUSH
24025: LD_INT 30
24027: PUSH
24028: LD_INT 4
24030: PUSH
24031: EMPTY
24032: LIST
24033: LIST
24034: PUSH
24035: LD_INT 30
24037: PUSH
24038: LD_INT 5
24040: PUSH
24041: EMPTY
24042: LIST
24043: LIST
24044: PUSH
24045: EMPTY
24046: LIST
24047: LIST
24048: LIST
24049: PUSH
24050: EMPTY
24051: LIST
24052: LIST
24053: PPUSH
24054: CALL_OW 69
24058: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
24059: LD_ADDR_VAR 0 6
24063: PUSH
24064: LD_INT 22
24066: PUSH
24067: LD_INT 4
24069: PUSH
24070: EMPTY
24071: LIST
24072: LIST
24073: PUSH
24074: LD_INT 21
24076: PUSH
24077: LD_INT 1
24079: PUSH
24080: EMPTY
24081: LIST
24082: LIST
24083: PUSH
24084: LD_INT 3
24086: PUSH
24087: LD_INT 25
24089: PUSH
24090: LD_INT 16
24092: PUSH
24093: EMPTY
24094: LIST
24095: LIST
24096: PUSH
24097: EMPTY
24098: LIST
24099: LIST
24100: PUSH
24101: LD_INT 3
24103: PUSH
24104: LD_INT 25
24106: PUSH
24107: LD_INT 12
24109: PUSH
24110: EMPTY
24111: LIST
24112: LIST
24113: PUSH
24114: EMPTY
24115: LIST
24116: LIST
24117: PUSH
24118: EMPTY
24119: LIST
24120: LIST
24121: LIST
24122: LIST
24123: PPUSH
24124: CALL_OW 69
24128: PUSH
24129: LD_EXP 61
24133: DIFF
24134: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
24135: LD_ADDR_VAR 0 10
24139: PUSH
24140: LD_INT 22
24142: PUSH
24143: LD_INT 4
24145: PUSH
24146: EMPTY
24147: LIST
24148: LIST
24149: PUSH
24150: LD_INT 30
24152: PUSH
24153: LD_INT 3
24155: PUSH
24156: EMPTY
24157: LIST
24158: LIST
24159: PUSH
24160: EMPTY
24161: LIST
24162: LIST
24163: PPUSH
24164: CALL_OW 69
24168: PUSH
24169: LD_INT 1
24171: ARRAY
24172: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
24173: LD_INT 350
24175: PPUSH
24176: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
24180: LD_EXP 121
24184: PUSH
24185: LD_INT 4
24187: ARRAY
24188: PUSH
24189: LD_INT 5
24191: LESS
24192: PUSH
24193: LD_VAR 0 10
24197: PPUSH
24198: CALL_OW 461
24202: PUSH
24203: LD_INT 2
24205: EQUAL
24206: AND
24207: IFFALSE 24237
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
24209: LD_INT 4
24211: PPUSH
24212: LD_INT 3
24214: PUSH
24215: LD_INT 1
24217: PUSH
24218: LD_INT 1
24220: PUSH
24221: LD_INT 5
24223: PUSH
24224: EMPTY
24225: LIST
24226: LIST
24227: LIST
24228: LIST
24229: PUSH
24230: EMPTY
24231: LIST
24232: PPUSH
24233: CALL 63846 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
24237: LD_EXP 121
24241: PUSH
24242: LD_INT 4
24244: ARRAY
24245: PUSH
24246: LD_INT 5
24248: GREATEREQUAL
24249: PUSH
24250: LD_EXP 121
24254: PUSH
24255: LD_INT 4
24257: ARRAY
24258: PPUSH
24259: LD_INT 58
24261: PUSH
24262: EMPTY
24263: LIST
24264: PPUSH
24265: CALL_OW 72
24269: PUSH
24270: LD_INT 5
24272: GREATEREQUAL
24273: AND
24274: IFFALSE 24173
// powellAllowRetreat := false ;
24276: LD_ADDR_EXP 19
24280: PUSH
24281: LD_INT 0
24283: ST_TO_ADDR
// activeAttacks := false ;
24284: LD_ADDR_EXP 16
24288: PUSH
24289: LD_INT 0
24291: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
24292: LD_INT 35
24294: PPUSH
24295: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
24299: LD_INT 22
24301: PUSH
24302: LD_INT 6
24304: PUSH
24305: EMPTY
24306: LIST
24307: LIST
24308: PPUSH
24309: CALL_OW 69
24313: PUSH
24314: LD_INT 0
24316: EQUAL
24317: IFFALSE 24292
// tmp := mc_vehicles [ 4 ] ;
24319: LD_ADDR_VAR 0 3
24323: PUSH
24324: LD_EXP 121
24328: PUSH
24329: LD_INT 4
24331: ARRAY
24332: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
24333: LD_ADDR_VAR 0 1
24337: PUSH
24338: DOUBLE
24339: LD_INT 1
24341: DEC
24342: ST_TO_ADDR
24343: LD_EXP 18
24347: PUSH
24348: FOR_TO
24349: IFFALSE 24671
// begin for j in powellSquadAttack [ i ] do
24351: LD_ADDR_VAR 0 2
24355: PUSH
24356: LD_EXP 18
24360: PUSH
24361: LD_VAR 0 1
24365: ARRAY
24366: PUSH
24367: FOR_IN
24368: IFFALSE 24667
// begin if j in mc_bases [ 4 ] then
24370: LD_VAR 0 2
24374: PUSH
24375: LD_EXP 102
24379: PUSH
24380: LD_INT 4
24382: ARRAY
24383: IN
24384: IFFALSE 24419
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff j ) ;
24386: LD_ADDR_EXP 102
24390: PUSH
24391: LD_EXP 102
24395: PPUSH
24396: LD_INT 4
24398: PPUSH
24399: LD_EXP 102
24403: PUSH
24404: LD_INT 4
24406: ARRAY
24407: PUSH
24408: LD_VAR 0 2
24412: DIFF
24413: PPUSH
24414: CALL_OW 1
24418: ST_TO_ADDR
// forces := forces diff j ;
24419: LD_ADDR_VAR 0 6
24423: PUSH
24424: LD_VAR 0 6
24428: PUSH
24429: LD_VAR 0 2
24433: DIFF
24434: ST_TO_ADDR
// SetTag ( j , 1 ) ;
24435: LD_VAR 0 2
24439: PPUSH
24440: LD_INT 1
24442: PPUSH
24443: CALL_OW 109
// wait ( 0 0$2 ) ;
24447: LD_INT 70
24449: PPUSH
24450: CALL_OW 67
// if IsInUnit ( j ) then
24454: LD_VAR 0 2
24458: PPUSH
24459: CALL_OW 310
24463: IFFALSE 24474
// ComExitBuilding ( j ) ;
24465: LD_VAR 0 2
24469: PPUSH
24470: CALL_OW 122
// if GetClass ( j ) <> 1 and not HasTask ( j ) then
24474: LD_VAR 0 2
24478: PPUSH
24479: CALL_OW 257
24483: PUSH
24484: LD_INT 1
24486: NONEQUAL
24487: PUSH
24488: LD_VAR 0 2
24492: PPUSH
24493: CALL_OW 314
24497: NOT
24498: AND
24499: IFFALSE 24579
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
24501: LD_VAR 0 11
24505: PUSH
24506: LD_INT 1
24508: ARRAY
24509: PPUSH
24510: CALL_OW 313
24514: PUSH
24515: LD_INT 5
24517: GREATEREQUAL
24518: IFFALSE 24540
// ComEnterUnit ( j , arm [ 2 ] ) else
24520: LD_VAR 0 2
24524: PPUSH
24525: LD_VAR 0 11
24529: PUSH
24530: LD_INT 2
24532: ARRAY
24533: PPUSH
24534: CALL_OW 120
24538: GO 24558
// ComEnterUnit ( j , arm [ 1 ] ) ;
24540: LD_VAR 0 2
24544: PPUSH
24545: LD_VAR 0 11
24549: PUSH
24550: LD_INT 1
24552: ARRAY
24553: PPUSH
24554: CALL_OW 120
// AddComChangeProfession ( j , 1 ) ;
24558: LD_VAR 0 2
24562: PPUSH
24563: LD_INT 1
24565: PPUSH
24566: CALL_OW 183
// AddComExitBuilding ( j ) ;
24570: LD_VAR 0 2
24574: PPUSH
24575: CALL_OW 182
// end ; if i = 2 then
24579: LD_VAR 0 1
24583: PUSH
24584: LD_INT 2
24586: EQUAL
24587: IFFALSE 24604
// AddComMoveXY ( j , 61 , 93 ) ;
24589: LD_VAR 0 2
24593: PPUSH
24594: LD_INT 61
24596: PPUSH
24597: LD_INT 93
24599: PPUSH
24600: CALL_OW 171
// if i = 1 then
24604: LD_VAR 0 1
24608: PUSH
24609: LD_INT 1
24611: EQUAL
24612: IFFALSE 24665
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
24614: LD_VAR 0 2
24618: PPUSH
24619: LD_VAR 0 3
24623: PUSH
24624: LD_INT 1
24626: ARRAY
24627: PPUSH
24628: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
24632: LD_ADDR_VAR 0 3
24636: PUSH
24637: LD_VAR 0 3
24641: PPUSH
24642: LD_INT 1
24644: PPUSH
24645: CALL_OW 3
24649: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
24650: LD_VAR 0 2
24654: PPUSH
24655: LD_INT 69
24657: PPUSH
24658: LD_INT 94
24660: PPUSH
24661: CALL_OW 171
// end ; end ;
24665: GO 24367
24667: POP
24668: POP
// end ;
24669: GO 24348
24671: POP
24672: POP
// wait ( 0 0$30 ) ;
24673: LD_INT 1050
24675: PPUSH
24676: CALL_OW 67
// MC_Kill ( 4 ) ;
24680: LD_INT 4
24682: PPUSH
24683: CALL 39821 0 1
// tmp := UnitsInside ( fac ) ;
24687: LD_ADDR_VAR 0 3
24691: PUSH
24692: LD_VAR 0 10
24696: PPUSH
24697: CALL_OW 313
24701: ST_TO_ADDR
// if tmp then
24702: LD_VAR 0 3
24706: IFFALSE 24827
// for i in tmp do
24708: LD_ADDR_VAR 0 1
24712: PUSH
24713: LD_VAR 0 3
24717: PUSH
24718: FOR_IN
24719: IFFALSE 24825
// begin ComExitBuilding ( i ) ;
24721: LD_VAR 0 1
24725: PPUSH
24726: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
24730: LD_VAR 0 11
24734: PUSH
24735: LD_INT 2
24737: ARRAY
24738: PPUSH
24739: CALL_OW 313
24743: PUSH
24744: LD_INT 6
24746: LESS
24747: IFFALSE 24769
// AddComEnterUnit ( i , arm [ 2 ] ) else
24749: LD_VAR 0 1
24753: PPUSH
24754: LD_VAR 0 11
24758: PUSH
24759: LD_INT 2
24761: ARRAY
24762: PPUSH
24763: CALL_OW 180
24767: GO 24823
// if UnitsInside ( arm [ 1 ] ) < 6 then
24769: LD_VAR 0 11
24773: PUSH
24774: LD_INT 1
24776: ARRAY
24777: PPUSH
24778: CALL_OW 313
24782: PUSH
24783: LD_INT 6
24785: LESS
24786: IFFALSE 24808
// AddComEnterUnit ( i , arm [ 1 ] ) else
24788: LD_VAR 0 1
24792: PPUSH
24793: LD_VAR 0 11
24797: PUSH
24798: LD_INT 1
24800: ARRAY
24801: PPUSH
24802: CALL_OW 180
24806: GO 24823
// AddComMoveXY ( i , 37 , 68 ) ;
24808: LD_VAR 0 1
24812: PPUSH
24813: LD_INT 37
24815: PPUSH
24816: LD_INT 68
24818: PPUSH
24819: CALL_OW 171
// end ;
24823: GO 24718
24825: POP
24826: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
24827: LD_ADDR_VAR 0 12
24831: PUSH
24832: LD_VAR 0 6
24836: PPUSH
24837: LD_INT 26
24839: PUSH
24840: LD_INT 1
24842: PUSH
24843: EMPTY
24844: LIST
24845: LIST
24846: PPUSH
24847: CALL_OW 72
24851: PUSH
24852: LD_EXP 62
24856: DIFF
24857: ST_TO_ADDR
// if not speaker then
24858: LD_VAR 0 12
24862: NOT
24863: IFFALSE 24890
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
24865: LD_ADDR_VAR 0 12
24869: PUSH
24870: LD_VAR 0 6
24874: PPUSH
24875: LD_INT 26
24877: PUSH
24878: LD_INT 1
24880: PUSH
24881: EMPTY
24882: LIST
24883: LIST
24884: PPUSH
24885: CALL_OW 72
24889: ST_TO_ADDR
// if speaker then
24890: LD_VAR 0 12
24894: IFFALSE 24910
// speaker := speaker [ 1 ] ;
24896: LD_ADDR_VAR 0 12
24900: PUSH
24901: LD_VAR 0 12
24905: PUSH
24906: LD_INT 1
24908: ARRAY
24909: ST_TO_ADDR
// Video ( true ) ;
24910: LD_INT 1
24912: PPUSH
24913: CALL 107976 0 1
// CenterNowOnUnits ( Powell ) ;
24917: LD_EXP 61
24921: PPUSH
24922: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
24926: LD_ADDR_VAR 0 3
24930: PUSH
24931: LD_VAR 0 6
24935: PPUSH
24936: LD_INT 3
24938: PUSH
24939: LD_INT 25
24941: PUSH
24942: LD_INT 1
24944: PUSH
24945: EMPTY
24946: LIST
24947: LIST
24948: PUSH
24949: EMPTY
24950: LIST
24951: LIST
24952: PPUSH
24953: CALL_OW 72
24957: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
24958: LD_ADDR_VAR 0 13
24962: PUSH
24963: LD_INT 22
24965: PUSH
24966: LD_INT 4
24968: PUSH
24969: EMPTY
24970: LIST
24971: LIST
24972: PUSH
24973: LD_INT 30
24975: PUSH
24976: LD_INT 32
24978: PUSH
24979: EMPTY
24980: LIST
24981: LIST
24982: PUSH
24983: LD_INT 58
24985: PUSH
24986: EMPTY
24987: LIST
24988: PUSH
24989: EMPTY
24990: LIST
24991: LIST
24992: LIST
24993: PPUSH
24994: CALL_OW 69
24998: ST_TO_ADDR
// t := Count ( tmp ) ;
24999: LD_ADDR_VAR 0 7
25003: PUSH
25004: LD_VAR 0 3
25008: PPUSH
25009: CALL 72395 0 1
25013: ST_TO_ADDR
// if t > 4 then
25014: LD_VAR 0 7
25018: PUSH
25019: LD_INT 4
25021: GREATER
25022: IFFALSE 25032
// t := 4 ;
25024: LD_ADDR_VAR 0 7
25028: PUSH
25029: LD_INT 4
25031: ST_TO_ADDR
// for i := 1 to t do
25032: LD_ADDR_VAR 0 1
25036: PUSH
25037: DOUBLE
25038: LD_INT 1
25040: DEC
25041: ST_TO_ADDR
25042: LD_VAR 0 7
25046: PUSH
25047: FOR_TO
25048: IFFALSE 25194
// begin if IsInUnit ( tmp [ i ] ) then
25050: LD_VAR 0 3
25054: PUSH
25055: LD_VAR 0 1
25059: ARRAY
25060: PPUSH
25061: CALL_OW 310
25065: IFFALSE 25082
// ComExitBuilding ( tmp [ i ] ) ;
25067: LD_VAR 0 3
25071: PUSH
25072: LD_VAR 0 1
25076: ARRAY
25077: PPUSH
25078: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
25082: LD_VAR 0 3
25086: PUSH
25087: LD_VAR 0 1
25091: ARRAY
25092: PPUSH
25093: LD_VAR 0 11
25097: PUSH
25098: LD_INT 1
25100: ARRAY
25101: PPUSH
25102: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
25106: LD_VAR 0 3
25110: PUSH
25111: LD_VAR 0 1
25115: ARRAY
25116: PPUSH
25117: LD_INT 1
25119: PPUSH
25120: CALL_OW 183
// if Count ( emp_towers ) then
25124: LD_VAR 0 13
25128: PPUSH
25129: CALL 72395 0 1
25133: IFFALSE 25192
// begin AddComExitBuilding ( tmp [ i ] ) ;
25135: LD_VAR 0 3
25139: PUSH
25140: LD_VAR 0 1
25144: ARRAY
25145: PPUSH
25146: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
25150: LD_VAR 0 3
25154: PUSH
25155: LD_VAR 0 1
25159: ARRAY
25160: PPUSH
25161: LD_VAR 0 13
25165: PUSH
25166: LD_INT 1
25168: ARRAY
25169: PPUSH
25170: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
25174: LD_ADDR_VAR 0 13
25178: PUSH
25179: LD_VAR 0 13
25183: PPUSH
25184: LD_INT 1
25186: PPUSH
25187: CALL_OW 3
25191: ST_TO_ADDR
// end ; end ;
25192: GO 25047
25194: POP
25195: POP
// wait ( 0 0$5 ) ;
25196: LD_INT 175
25198: PPUSH
25199: CALL_OW 67
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
25203: LD_VAR 0 3
25207: PPUSH
25208: LD_INT 3
25210: PUSH
25211: LD_INT 54
25213: PUSH
25214: EMPTY
25215: LIST
25216: PUSH
25217: EMPTY
25218: LIST
25219: LIST
25220: PPUSH
25221: CALL_OW 72
25225: IFFALSE 25245
// ComEnterUnit ( tmp , arm [ 1 ] ) ;
25227: LD_VAR 0 3
25231: PPUSH
25232: LD_VAR 0 11
25236: PUSH
25237: LD_INT 1
25239: ARRAY
25240: PPUSH
25241: CALL_OW 120
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
25245: LD_ADDR_VAR 0 3
25249: PUSH
25250: LD_EXP 18
25254: PUSH
25255: LD_INT 1
25257: ARRAY
25258: PUSH
25259: LD_EXP 18
25263: PUSH
25264: LD_INT 2
25266: ARRAY
25267: ADD
25268: PPUSH
25269: LD_INT 26
25271: PUSH
25272: LD_INT 1
25274: PUSH
25275: EMPTY
25276: LIST
25277: LIST
25278: PPUSH
25279: CALL_OW 72
25283: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
25284: LD_ADDR_VAR 0 1
25288: PUSH
25289: LD_EXP 18
25293: PUSH
25294: LD_INT 2
25296: ARRAY
25297: PUSH
25298: FOR_IN
25299: IFFALSE 25317
// ComTurnUnit ( i , Powell ) ;
25301: LD_VAR 0 1
25305: PPUSH
25306: LD_EXP 61
25310: PPUSH
25311: CALL_OW 119
25315: GO 25298
25317: POP
25318: POP
// Say ( Powell , D5-Pow-1 ) ;
25319: LD_EXP 61
25323: PPUSH
25324: LD_STRING D5-Pow-1
25326: PPUSH
25327: CALL_OW 88
// if tmp then
25331: LD_VAR 0 3
25335: IFFALSE 25353
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
25337: LD_VAR 0 3
25341: PUSH
25342: LD_INT 1
25344: ARRAY
25345: PPUSH
25346: LD_STRING D5-Sol2-1
25348: PPUSH
25349: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
25353: LD_EXP 61
25357: PPUSH
25358: LD_STRING D5-Pow-2
25360: PPUSH
25361: CALL_OW 88
// if tmp > 1 then
25365: LD_VAR 0 3
25369: PUSH
25370: LD_INT 1
25372: GREATER
25373: IFFALSE 25391
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
25375: LD_VAR 0 3
25379: PUSH
25380: LD_INT 2
25382: ARRAY
25383: PPUSH
25384: LD_STRING D5-Sol2-2
25386: PPUSH
25387: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
25391: LD_EXP 61
25395: PPUSH
25396: LD_STRING D5-Pow-3
25398: PPUSH
25399: CALL_OW 88
// wait ( 0 0$1 ) ;
25403: LD_INT 35
25405: PPUSH
25406: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
25410: LD_ADDR_VAR 0 3
25414: PUSH
25415: LD_EXP 18
25419: PUSH
25420: LD_INT 1
25422: ARRAY
25423: PUSH
25424: LD_EXP 18
25428: PUSH
25429: LD_INT 2
25431: ARRAY
25432: UNION
25433: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
25434: LD_VAR 0 3
25438: PPUSH
25439: LD_INT 80
25441: PPUSH
25442: LD_INT 67
25444: PPUSH
25445: CALL_OW 114
// wait ( 0 0$2 ) ;
25449: LD_INT 70
25451: PPUSH
25452: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
25456: LD_INT 79
25458: PPUSH
25459: LD_INT 72
25461: PPUSH
25462: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
25466: LD_INT 70
25468: PPUSH
25469: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
25473: LD_VAR 0 3
25477: PPUSH
25478: LD_INT 3
25480: PUSH
25481: LD_INT 24
25483: PUSH
25484: LD_INT 1000
25486: PUSH
25487: EMPTY
25488: LIST
25489: LIST
25490: PUSH
25491: EMPTY
25492: LIST
25493: LIST
25494: PPUSH
25495: CALL_OW 72
25499: IFFALSE 25466
// Say ( Powell , D5a-Pow-1 ) ;
25501: LD_EXP 61
25505: PPUSH
25506: LD_STRING D5a-Pow-1
25508: PPUSH
25509: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
25513: LD_EXP 61
25517: PPUSH
25518: LD_STRING D5a-Pow-1a
25520: PPUSH
25521: CALL_OW 88
// wait ( 0 0$0.7 ) ;
25525: LD_INT 24
25527: PPUSH
25528: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
25532: LD_EXP 61
25536: PPUSH
25537: LD_STRING D5a-Pow-1b
25539: PPUSH
25540: CALL_OW 88
// wait ( 0 0$0.3 ) ;
25544: LD_INT 10
25546: PPUSH
25547: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
25551: LD_EXP 61
25555: PPUSH
25556: LD_STRING D5a-Pow-1c
25558: PPUSH
25559: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
25563: LD_VAR 0 3
25567: PPUSH
25568: LD_INT 68
25570: PPUSH
25571: LD_INT 63
25573: PPUSH
25574: CALL_OW 111
// wait ( 0 0$0.5 ) ;
25578: LD_INT 18
25580: PPUSH
25581: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
25585: LD_EXP 61
25589: PPUSH
25590: LD_STRING D5a-Pow-1d
25592: PPUSH
25593: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
25597: LD_INT 35
25599: PPUSH
25600: CALL_OW 67
// if not HasTask ( tmp ) then
25604: LD_VAR 0 3
25608: PPUSH
25609: CALL_OW 314
25613: NOT
25614: IFFALSE 25631
// ComAgressiveMove ( tmp , 68 , 63 ) ;
25616: LD_VAR 0 3
25620: PPUSH
25621: LD_INT 68
25623: PPUSH
25624: LD_INT 63
25626: PPUSH
25627: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
25631: LD_VAR 0 3
25635: PPUSH
25636: LD_INT 24
25638: PUSH
25639: LD_INT 1
25641: PUSH
25642: EMPTY
25643: LIST
25644: LIST
25645: PPUSH
25646: CALL_OW 72
25650: NOT
25651: IFFALSE 25597
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
25653: LD_ADDR_VAR 0 3
25657: PUSH
25658: LD_INT 22
25660: PUSH
25661: LD_INT 4
25663: PUSH
25664: EMPTY
25665: LIST
25666: LIST
25667: PUSH
25668: LD_INT 92
25670: PUSH
25671: LD_INT 60
25673: PUSH
25674: LD_INT 93
25676: PUSH
25677: LD_INT 10
25679: PUSH
25680: EMPTY
25681: LIST
25682: LIST
25683: LIST
25684: LIST
25685: PUSH
25686: LD_INT 3
25688: PUSH
25689: LD_INT 54
25691: PUSH
25692: EMPTY
25693: LIST
25694: PUSH
25695: EMPTY
25696: LIST
25697: LIST
25698: PUSH
25699: EMPTY
25700: LIST
25701: LIST
25702: LIST
25703: PPUSH
25704: CALL_OW 69
25708: PUSH
25709: LD_EXP 61
25713: DIFF
25714: ST_TO_ADDR
// if tmp then
25715: LD_VAR 0 3
25719: IFFALSE 25753
// for i in tmp do
25721: LD_ADDR_VAR 0 1
25725: PUSH
25726: LD_VAR 0 3
25730: PUSH
25731: FOR_IN
25732: IFFALSE 25751
// ComMoveXY ( i , 36 , 67 ) ;
25734: LD_VAR 0 1
25738: PPUSH
25739: LD_INT 36
25741: PPUSH
25742: LD_INT 67
25744: PPUSH
25745: CALL_OW 111
25749: GO 25731
25751: POP
25752: POP
// wait ( 0 0$3 ) ;
25753: LD_INT 105
25755: PPUSH
25756: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
25760: LD_VAR 0 12
25764: PPUSH
25765: LD_STRING D6-Sol3-1
25767: PPUSH
25768: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
25772: LD_EXP 61
25776: PPUSH
25777: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
25781: LD_EXP 61
25785: PPUSH
25786: LD_STRING D6-Pow-1
25788: PPUSH
25789: CALL_OW 88
// tmp := [ ] ;
25793: LD_ADDR_VAR 0 3
25797: PUSH
25798: EMPTY
25799: ST_TO_ADDR
// for i = 1 to 2 do
25800: LD_ADDR_VAR 0 1
25804: PUSH
25805: DOUBLE
25806: LD_INT 1
25808: DEC
25809: ST_TO_ADDR
25810: LD_INT 2
25812: PUSH
25813: FOR_TO
25814: IFFALSE 25928
// begin uc_side := 8 ;
25816: LD_ADDR_OWVAR 20
25820: PUSH
25821: LD_INT 8
25823: ST_TO_ADDR
// uc_nation := 2 ;
25824: LD_ADDR_OWVAR 21
25828: PUSH
25829: LD_INT 2
25831: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
25832: LD_INT 14
25834: PPUSH
25835: LD_INT 3
25837: PPUSH
25838: LD_INT 2
25840: PPUSH
25841: LD_INT 29
25843: PPUSH
25844: LD_INT 100
25846: PPUSH
25847: CALL 75133 0 5
// veh := CreateVehicle ;
25851: LD_ADDR_VAR 0 14
25855: PUSH
25856: CALL_OW 45
25860: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
25861: LD_VAR 0 14
25865: PPUSH
25866: LD_INT 4
25868: PPUSH
25869: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
25873: LD_VAR 0 14
25877: PPUSH
25878: LD_INT 99
25880: PPUSH
25881: LD_INT 83
25883: PPUSH
25884: LD_INT 3
25886: PPUSH
25887: LD_INT 0
25889: PPUSH
25890: CALL_OW 50
// wait ( 3 ) ;
25894: LD_INT 3
25896: PPUSH
25897: CALL_OW 67
// Connect ( veh ) ;
25901: LD_VAR 0 14
25905: PPUSH
25906: CALL 78601 0 1
// tmp := tmp ^ veh ;
25910: LD_ADDR_VAR 0 3
25914: PUSH
25915: LD_VAR 0 3
25919: PUSH
25920: LD_VAR 0 14
25924: ADD
25925: ST_TO_ADDR
// end ;
25926: GO 25813
25928: POP
25929: POP
// wait ( 0 0$1 ) ;
25930: LD_INT 35
25932: PPUSH
25933: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
25937: LD_INT 99
25939: PPUSH
25940: LD_INT 83
25942: PPUSH
25943: LD_INT 1
25945: PPUSH
25946: LD_INT 10
25948: PPUSH
25949: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
25953: LD_INT 99
25955: PPUSH
25956: LD_INT 83
25958: PPUSH
25959: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
25963: LD_VAR 0 12
25967: PPUSH
25968: LD_STRING D6-Sol3-2
25970: PPUSH
25971: CALL_OW 88
// async ;
25975: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
25976: LD_EXP 61
25980: PPUSH
25981: LD_STRING D6-Pow-2
25983: PPUSH
25984: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
25988: LD_VAR 0 3
25992: PUSH
25993: LD_INT 1
25995: ARRAY
25996: PPUSH
25997: LD_VAR 0 10
26001: PPUSH
26002: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
26006: LD_VAR 0 3
26010: PUSH
26011: LD_INT 2
26013: ARRAY
26014: PPUSH
26015: LD_INT 22
26017: PUSH
26018: LD_INT 4
26020: PUSH
26021: EMPTY
26022: LIST
26023: LIST
26024: PUSH
26025: LD_INT 21
26027: PUSH
26028: LD_INT 3
26030: PUSH
26031: EMPTY
26032: LIST
26033: LIST
26034: PUSH
26035: EMPTY
26036: LIST
26037: LIST
26038: PPUSH
26039: CALL_OW 69
26043: PPUSH
26044: LD_VAR 0 3
26048: PUSH
26049: LD_INT 2
26051: ARRAY
26052: PPUSH
26053: CALL_OW 74
26057: PPUSH
26058: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
26062: LD_EXP 61
26066: PPUSH
26067: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
26071: LD_INT 99
26073: PPUSH
26074: LD_INT 83
26076: PPUSH
26077: LD_INT 1
26079: PPUSH
26080: CALL_OW 331
// repeat wait ( 4 ) ;
26084: LD_INT 4
26086: PPUSH
26087: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
26091: LD_VAR 0 3
26095: PUSH
26096: LD_INT 1
26098: ARRAY
26099: PPUSH
26100: CALL_OW 256
26104: PUSH
26105: LD_INT 1000
26107: LESS
26108: IFFALSE 26126
// SetLives ( tmp [ 1 ] , 1000 ) ;
26110: LD_VAR 0 3
26114: PUSH
26115: LD_INT 1
26117: ARRAY
26118: PPUSH
26119: LD_INT 1000
26121: PPUSH
26122: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
26126: LD_INT 22
26128: PUSH
26129: LD_INT 4
26131: PUSH
26132: EMPTY
26133: LIST
26134: LIST
26135: PUSH
26136: LD_INT 30
26138: PUSH
26139: LD_INT 3
26141: PUSH
26142: EMPTY
26143: LIST
26144: LIST
26145: PUSH
26146: EMPTY
26147: LIST
26148: LIST
26149: PPUSH
26150: CALL_OW 69
26154: PUSH
26155: LD_INT 0
26157: EQUAL
26158: IFFALSE 26084
// skirmish := false ;
26160: LD_ADDR_EXP 100
26164: PUSH
26165: LD_INT 0
26167: ST_TO_ADDR
// sync ;
26168: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
26169: LD_EXP 61
26173: PPUSH
26174: LD_STRING D6a-Pow-1
26176: PPUSH
26177: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
26181: LD_VAR 0 12
26185: PPUSH
26186: LD_STRING D6a-Sol3-1
26188: PPUSH
26189: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
26193: LD_EXP 61
26197: PPUSH
26198: LD_STRING D6a-Pow-2
26200: PPUSH
26201: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
26205: LD_VAR 0 12
26209: PPUSH
26210: LD_STRING D6a-Sol3-2
26212: PPUSH
26213: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
26217: LD_EXP 61
26221: PPUSH
26222: LD_STRING D6a-Pow-3
26224: PPUSH
26225: CALL_OW 88
// powellCenterCameraMode := true ;
26229: LD_ADDR_EXP 20
26233: PUSH
26234: LD_INT 1
26236: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
26237: LD_ADDR_VAR 0 1
26241: PUSH
26242: LD_INT 22
26244: PUSH
26245: LD_INT 8
26247: PUSH
26248: EMPTY
26249: LIST
26250: LIST
26251: PUSH
26252: LD_INT 25
26254: PUSH
26255: LD_INT 2
26257: PUSH
26258: EMPTY
26259: LIST
26260: LIST
26261: PUSH
26262: EMPTY
26263: LIST
26264: LIST
26265: PPUSH
26266: CALL_OW 69
26270: PUSH
26271: FOR_IN
26272: IFFALSE 26327
// begin SetTag ( i , 1 ) ;
26274: LD_VAR 0 1
26278: PPUSH
26279: LD_INT 1
26281: PPUSH
26282: CALL_OW 109
// ComExitBuilding ( i ) ;
26286: LD_VAR 0 1
26290: PPUSH
26291: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
26295: LD_VAR 0 1
26299: PPUSH
26300: LD_INT 35
26302: PPUSH
26303: LD_INT 6
26305: PPUSH
26306: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
26310: LD_VAR 0 1
26314: PPUSH
26315: LD_INT 53
26317: PPUSH
26318: LD_INT 4
26320: PPUSH
26321: CALL_OW 171
// end ;
26325: GO 26271
26327: POP
26328: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
26329: LD_ADDR_VAR 0 3
26333: PUSH
26334: LD_INT 22
26336: PUSH
26337: LD_INT 4
26339: PUSH
26340: EMPTY
26341: LIST
26342: LIST
26343: PUSH
26344: LD_INT 21
26346: PUSH
26347: LD_INT 2
26349: PUSH
26350: EMPTY
26351: LIST
26352: LIST
26353: PUSH
26354: LD_INT 3
26356: PUSH
26357: LD_INT 34
26359: PUSH
26360: LD_INT 12
26362: PUSH
26363: EMPTY
26364: LIST
26365: LIST
26366: PUSH
26367: EMPTY
26368: LIST
26369: LIST
26370: PUSH
26371: EMPTY
26372: LIST
26373: LIST
26374: LIST
26375: PPUSH
26376: CALL_OW 69
26380: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
26381: LD_EXP 61
26385: PPUSH
26386: LD_VAR 0 3
26390: PPUSH
26391: LD_EXP 61
26395: PPUSH
26396: CALL_OW 74
26400: PPUSH
26401: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
26405: LD_EXP 61
26409: PPUSH
26410: LD_INT 100
26412: PPUSH
26413: LD_INT 88
26415: PPUSH
26416: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
26420: LD_EXP 61
26424: PPUSH
26425: LD_INT 100
26427: PPUSH
26428: LD_INT 75
26430: PPUSH
26431: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
26435: LD_EXP 61
26439: PPUSH
26440: LD_INT 88
26442: PPUSH
26443: LD_INT 53
26445: PPUSH
26446: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
26450: LD_INT 8
26452: PPUSH
26453: LD_EXP 61
26457: PPUSH
26458: CALL_OW 471
// repeat wait ( 3 ) ;
26462: LD_INT 3
26464: PPUSH
26465: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
26469: LD_INT 22
26471: PUSH
26472: LD_INT 4
26474: PUSH
26475: EMPTY
26476: LIST
26477: LIST
26478: PUSH
26479: LD_INT 92
26481: PUSH
26482: LD_INT 100
26484: PUSH
26485: LD_INT 75
26487: PUSH
26488: LD_INT 6
26490: PUSH
26491: EMPTY
26492: LIST
26493: LIST
26494: LIST
26495: LIST
26496: PUSH
26497: EMPTY
26498: LIST
26499: LIST
26500: PPUSH
26501: CALL_OW 69
26505: IFFALSE 26462
// async ;
26507: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
26508: LD_EXP 61
26512: PPUSH
26513: LD_STRING D6b-Pow-1
26515: PPUSH
26516: CALL_OW 88
// repeat wait ( 3 ) ;
26520: LD_INT 3
26522: PPUSH
26523: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
26527: LD_EXP 61
26531: PPUSH
26532: CALL_OW 310
26536: PPUSH
26537: CALL_OW 256
26541: PUSH
26542: LD_INT 1000
26544: LESS
26545: IFFALSE 26564
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
26547: LD_EXP 61
26551: PPUSH
26552: CALL_OW 310
26556: PPUSH
26557: LD_INT 1000
26559: PPUSH
26560: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
26564: LD_EXP 61
26568: PPUSH
26569: CALL_OW 256
26573: PUSH
26574: LD_INT 1000
26576: LESS
26577: IFFALSE 26591
// SetLives ( Powell , 1000 ) ;
26579: LD_EXP 61
26583: PPUSH
26584: LD_INT 1000
26586: PPUSH
26587: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
26591: LD_EXP 61
26595: PPUSH
26596: LD_EXP 67
26600: PPUSH
26601: CALL_OW 296
26605: PUSH
26606: LD_INT 5
26608: LESS
26609: PUSH
26610: LD_EXP 61
26614: PPUSH
26615: CALL_OW 310
26619: PPUSH
26620: LD_EXP 67
26624: PPUSH
26625: CALL_OW 296
26629: PUSH
26630: LD_INT 5
26632: LESS
26633: OR
26634: IFFALSE 26653
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
26636: LD_EXP 61
26640: PPUSH
26641: CALL_OW 310
26645: PPUSH
26646: LD_INT 100
26648: PPUSH
26649: CALL_OW 234
// until not IsInUnit ( Powell ) ;
26653: LD_EXP 61
26657: PPUSH
26658: CALL_OW 310
26662: NOT
26663: IFFALSE 26520
// DoNotAttack ( 8 , powellBomb ) ;
26665: LD_INT 8
26667: PPUSH
26668: LD_EXP 67
26672: PPUSH
26673: CALL_OW 471
// game_speed := 4 ;
26677: LD_ADDR_OWVAR 65
26681: PUSH
26682: LD_INT 4
26684: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
26685: LD_EXP 61
26689: PPUSH
26690: LD_STRING D6b-Pow-1a
26692: PPUSH
26693: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
26697: LD_EXP 61
26701: PPUSH
26702: LD_EXP 67
26706: PPUSH
26707: CALL_OW 180
// sync ;
26711: SYNC
// repeat wait ( 0 0$1 ) ;
26712: LD_INT 35
26714: PPUSH
26715: CALL_OW 67
// until IsInUnit ( Powell ) ;
26719: LD_EXP 61
26723: PPUSH
26724: CALL_OW 310
26728: IFFALSE 26712
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
26730: LD_INT 8
26732: PPUSH
26733: LD_EXP 61
26737: PPUSH
26738: CALL_OW 310
26742: PPUSH
26743: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
26747: LD_EXP 61
26751: PPUSH
26752: LD_INT 91
26754: PPUSH
26755: LD_INT 44
26757: PPUSH
26758: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26762: LD_EXP 61
26766: PPUSH
26767: LD_INT 96
26769: PPUSH
26770: LD_INT 44
26772: PPUSH
26773: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26777: LD_EXP 61
26781: PPUSH
26782: LD_INT 96
26784: PPUSH
26785: LD_INT 41
26787: PPUSH
26788: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
26792: LD_EXP 61
26796: PPUSH
26797: LD_INT 92
26799: PPUSH
26800: LD_INT 39
26802: PPUSH
26803: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
26807: LD_EXP 61
26811: PPUSH
26812: LD_INT 88
26814: PPUSH
26815: LD_INT 41
26817: PPUSH
26818: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
26822: LD_EXP 61
26826: PPUSH
26827: LD_INT 91
26829: PPUSH
26830: LD_INT 44
26832: PPUSH
26833: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26837: LD_EXP 61
26841: PPUSH
26842: LD_INT 96
26844: PPUSH
26845: LD_INT 44
26847: PPUSH
26848: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26852: LD_EXP 61
26856: PPUSH
26857: LD_INT 96
26859: PPUSH
26860: LD_INT 41
26862: PPUSH
26863: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
26867: LD_EXP 61
26871: PPUSH
26872: LD_INT 92
26874: PPUSH
26875: LD_INT 39
26877: PPUSH
26878: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
26882: LD_EXP 61
26886: PPUSH
26887: LD_INT 88
26889: PPUSH
26890: LD_INT 41
26892: PPUSH
26893: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
26897: LD_EXP 61
26901: PPUSH
26902: LD_INT 91
26904: PPUSH
26905: LD_INT 44
26907: PPUSH
26908: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
26912: LD_EXP 61
26916: PPUSH
26917: LD_INT 93
26919: PPUSH
26920: LD_INT 39
26922: PPUSH
26923: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
26927: LD_EXP 61
26931: PPUSH
26932: LD_INT 93
26934: PPUSH
26935: LD_INT 36
26937: PPUSH
26938: CALL_OW 171
// wait ( 0 0$3.5 ) ;
26942: LD_INT 122
26944: PPUSH
26945: CALL_OW 67
// game_speed := 4 ;
26949: LD_ADDR_OWVAR 65
26953: PUSH
26954: LD_INT 4
26956: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
26957: LD_EXP 61
26961: PPUSH
26962: LD_STRING D6b-Pow-1b
26964: PPUSH
26965: CALL_OW 88
// tmp := [ ] ;
26969: LD_ADDR_VAR 0 3
26973: PUSH
26974: EMPTY
26975: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
26976: LD_ADDR_VAR 0 5
26980: PUSH
26981: LD_INT 78
26983: PUSH
26984: LD_INT 47
26986: PUSH
26987: EMPTY
26988: LIST
26989: LIST
26990: PUSH
26991: LD_INT 106
26993: PUSH
26994: LD_INT 53
26996: PUSH
26997: EMPTY
26998: LIST
26999: LIST
27000: PUSH
27001: EMPTY
27002: LIST
27003: LIST
27004: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
27005: LD_ADDR_VAR 0 1
27009: PUSH
27010: LD_INT 22
27012: PUSH
27013: LD_INT 8
27015: PUSH
27016: EMPTY
27017: LIST
27018: LIST
27019: PUSH
27020: LD_INT 21
27022: PUSH
27023: LD_INT 3
27025: PUSH
27026: EMPTY
27027: LIST
27028: LIST
27029: PUSH
27030: LD_INT 92
27032: PUSH
27033: LD_INT 90
27035: PUSH
27036: LD_INT 52
27038: PUSH
27039: LD_INT 12
27041: PUSH
27042: EMPTY
27043: LIST
27044: LIST
27045: LIST
27046: LIST
27047: PUSH
27048: EMPTY
27049: LIST
27050: LIST
27051: LIST
27052: PPUSH
27053: CALL_OW 69
27057: PUSH
27058: FOR_IN
27059: IFFALSE 27084
// tmp := tmp ^ UnitsInside ( i ) ;
27061: LD_ADDR_VAR 0 3
27065: PUSH
27066: LD_VAR 0 3
27070: PUSH
27071: LD_VAR 0 1
27075: PPUSH
27076: CALL_OW 313
27080: ADD
27081: ST_TO_ADDR
27082: GO 27058
27084: POP
27085: POP
// for i in tmp do
27086: LD_ADDR_VAR 0 1
27090: PUSH
27091: LD_VAR 0 3
27095: PUSH
27096: FOR_IN
27097: IFFALSE 27259
// begin dist := 9999 ;
27099: LD_ADDR_VAR 0 9
27103: PUSH
27104: LD_INT 9999
27106: ST_TO_ADDR
// _xy := [ ] ;
27107: LD_ADDR_VAR 0 8
27111: PUSH
27112: EMPTY
27113: ST_TO_ADDR
// SetTag ( i , 1 ) ;
27114: LD_VAR 0 1
27118: PPUSH
27119: LD_INT 1
27121: PPUSH
27122: CALL_OW 109
// ComExitBuilding ( i ) ;
27126: LD_VAR 0 1
27130: PPUSH
27131: CALL_OW 122
// for j in xy do
27135: LD_ADDR_VAR 0 2
27139: PUSH
27140: LD_VAR 0 5
27144: PUSH
27145: FOR_IN
27146: IFFALSE 27228
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
27148: LD_VAR 0 1
27152: PPUSH
27153: LD_VAR 0 2
27157: PUSH
27158: LD_INT 1
27160: ARRAY
27161: PPUSH
27162: LD_VAR 0 2
27166: PUSH
27167: LD_INT 2
27169: ARRAY
27170: PPUSH
27171: CALL_OW 297
27175: PUSH
27176: LD_VAR 0 9
27180: LESS
27181: IFFALSE 27226
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
27183: LD_ADDR_VAR 0 9
27187: PUSH
27188: LD_VAR 0 1
27192: PPUSH
27193: LD_VAR 0 2
27197: PUSH
27198: LD_INT 1
27200: ARRAY
27201: PPUSH
27202: LD_VAR 0 2
27206: PUSH
27207: LD_INT 2
27209: ARRAY
27210: PPUSH
27211: CALL_OW 297
27215: ST_TO_ADDR
// _xy := j ;
27216: LD_ADDR_VAR 0 8
27220: PUSH
27221: LD_VAR 0 2
27225: ST_TO_ADDR
// end ;
27226: GO 27145
27228: POP
27229: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
27230: LD_VAR 0 1
27234: PPUSH
27235: LD_VAR 0 8
27239: PUSH
27240: LD_INT 1
27242: ARRAY
27243: PPUSH
27244: LD_VAR 0 8
27248: PUSH
27249: LD_INT 2
27251: ARRAY
27252: PPUSH
27253: CALL_OW 171
// end ;
27257: GO 27096
27259: POP
27260: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
27261: LD_ADDR_VAR 0 4
27265: PUSH
27266: LD_VAR 0 3
27270: PPUSH
27271: LD_INT 26
27273: PUSH
27274: LD_INT 1
27276: PUSH
27277: EMPTY
27278: LIST
27279: LIST
27280: PUSH
27281: LD_INT 25
27283: PUSH
27284: LD_INT 1
27286: PUSH
27287: EMPTY
27288: LIST
27289: LIST
27290: PUSH
27291: EMPTY
27292: LIST
27293: LIST
27294: PPUSH
27295: CALL_OW 72
27299: ST_TO_ADDR
// if tmp2 < 2 then
27300: LD_VAR 0 4
27304: PUSH
27305: LD_INT 2
27307: LESS
27308: IFFALSE 27377
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
27310: LD_ADDR_VAR 0 4
27314: PUSH
27315: LD_INT 22
27317: PUSH
27318: LD_INT 8
27320: PUSH
27321: EMPTY
27322: LIST
27323: LIST
27324: PUSH
27325: LD_INT 26
27327: PUSH
27328: LD_INT 1
27330: PUSH
27331: EMPTY
27332: LIST
27333: LIST
27334: PUSH
27335: LD_INT 3
27337: PUSH
27338: LD_INT 25
27340: PUSH
27341: LD_INT 15
27343: PUSH
27344: EMPTY
27345: LIST
27346: LIST
27347: PUSH
27348: EMPTY
27349: LIST
27350: LIST
27351: PUSH
27352: EMPTY
27353: LIST
27354: LIST
27355: LIST
27356: PPUSH
27357: CALL_OW 69
27361: PUSH
27362: LD_EXP 64
27366: PUSH
27367: LD_EXP 65
27371: PUSH
27372: EMPTY
27373: LIST
27374: LIST
27375: DIFF
27376: ST_TO_ADDR
// if tmp2 then
27377: LD_VAR 0 4
27381: IFFALSE 27399
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
27383: LD_VAR 0 4
27387: PUSH
27388: LD_INT 1
27390: ARRAY
27391: PPUSH
27392: LD_STRING D6b-ArSol1-1
27394: PPUSH
27395: CALL_OW 88
// async ;
27399: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
27400: LD_EXP 61
27404: PPUSH
27405: LD_STRING D6b-Pow-2
27407: PPUSH
27408: CALL_OW 88
// wait ( 0 0$0.5 ) ;
27412: LD_INT 18
27414: PPUSH
27415: CALL_OW 67
// if tmp2 > 1 then
27419: LD_VAR 0 4
27423: PUSH
27424: LD_INT 1
27426: GREATER
27427: IFFALSE 27445
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
27429: LD_VAR 0 4
27433: PUSH
27434: LD_INT 2
27436: ARRAY
27437: PPUSH
27438: LD_STRING D6b-ArSol2-1
27440: PPUSH
27441: CALL_OW 88
// sync ;
27445: SYNC
// repeat wait ( 5 ) ;
27446: LD_INT 5
27448: PPUSH
27449: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
27453: LD_INT 93
27455: PPUSH
27456: LD_INT 36
27458: PPUSH
27459: CALL_OW 428
27463: PPUSH
27464: CALL_OW 255
27468: PUSH
27469: LD_INT 4
27471: EQUAL
27472: IFFALSE 27446
// DialogueOn ;
27474: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
27478: LD_INT 10
27480: PPUSH
27481: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
27485: LD_EXP 61
27489: PPUSH
27490: LD_STRING D6b-Pow-2a
27492: PPUSH
27493: CALL_OW 88
// DialogueOff ;
27497: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
27501: LD_EXP 61
27505: PPUSH
27506: CALL_OW 310
27510: PPUSH
27511: LD_INT 332
27513: PPUSH
27514: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
27518: LD_INT 93
27520: PPUSH
27521: LD_INT 35
27523: PPUSH
27524: LD_INT 1
27526: PPUSH
27527: LD_INT 6
27529: NEG
27530: PPUSH
27531: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
27535: LD_INT 35
27537: PPUSH
27538: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
27542: LD_INT 332
27544: PPUSH
27545: CALL_OW 256
27549: PUSH
27550: LD_INT 1000
27552: LESS
27553: PUSH
27554: LD_INT 332
27556: PPUSH
27557: CALL_OW 300
27561: AND
27562: IFFALSE 27574
// SetLives ( kozlov_fac , 0 ) ;
27564: LD_INT 332
27566: PPUSH
27567: LD_INT 0
27569: PPUSH
27570: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
27574: LD_INT 332
27576: PPUSH
27577: CALL_OW 301
27581: PUSH
27582: LD_EXP 61
27586: PPUSH
27587: CALL_OW 301
27591: OR
27592: IFFALSE 27535
// game_speed := 4 ;
27594: LD_ADDR_OWVAR 65
27598: PUSH
27599: LD_INT 4
27601: ST_TO_ADDR
// powellCenterCameraMode := false ;
27602: LD_ADDR_EXP 20
27606: PUSH
27607: LD_INT 0
27609: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
27610: LD_ADDR_VAR 0 1
27614: PUSH
27615: LD_VAR 0 3
27619: PUSH
27620: LD_INT 22
27622: PUSH
27623: LD_INT 8
27625: PUSH
27626: EMPTY
27627: LIST
27628: LIST
27629: PUSH
27630: LD_INT 25
27632: PUSH
27633: LD_INT 2
27635: PUSH
27636: EMPTY
27637: LIST
27638: LIST
27639: PUSH
27640: EMPTY
27641: LIST
27642: LIST
27643: PPUSH
27644: CALL_OW 69
27648: UNION
27649: PUSH
27650: FOR_IN
27651: IFFALSE 27667
// SetTag ( i , 0 ) ;
27653: LD_VAR 0 1
27657: PPUSH
27658: LD_INT 0
27660: PPUSH
27661: CALL_OW 109
27665: GO 27650
27667: POP
27668: POP
// wait ( 0 0$3 ) ;
27669: LD_INT 105
27671: PPUSH
27672: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
27676: LD_INT 93
27678: PPUSH
27679: LD_INT 35
27681: PPUSH
27682: LD_INT 1
27684: PPUSH
27685: CALL_OW 331
// DialogueOn ;
27689: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
27693: LD_VAR 0 12
27697: PPUSH
27698: LD_STRING D6c-Sol3-1
27700: PPUSH
27701: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
27705: LD_INT 10
27707: PPUSH
27708: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
27712: LD_EXP 40
27716: PPUSH
27717: LD_STRING D6c-JMM-1
27719: PPUSH
27720: CALL_OW 88
// if Cyrus then
27724: LD_EXP 46
27728: IFFALSE 27742
// Say ( Cyrus , D6c-Cyrus-1 ) ;
27730: LD_EXP 46
27734: PPUSH
27735: LD_STRING D6c-Cyrus-1
27737: PPUSH
27738: CALL_OW 88
// if Bobby then
27742: LD_EXP 45
27746: IFFALSE 27760
// Say ( Bobby , D6c-Bobby-1 ) ;
27748: LD_EXP 45
27752: PPUSH
27753: LD_STRING D6c-Bobby-1
27755: PPUSH
27756: CALL_OW 88
// if Cornel then
27760: LD_EXP 51
27764: IFFALSE 27778
// Say ( Cornel , D6c-Corn-1 ) ;
27766: LD_EXP 51
27770: PPUSH
27771: LD_STRING D6c-Corn-1
27773: PPUSH
27774: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
27778: LD_ADDR_VAR 0 4
27782: PUSH
27783: LD_INT 2
27785: PUSH
27786: LD_INT 22
27788: PUSH
27789: LD_INT 1
27791: PUSH
27792: EMPTY
27793: LIST
27794: LIST
27795: PUSH
27796: LD_INT 22
27798: PUSH
27799: LD_INT 4
27801: PUSH
27802: EMPTY
27803: LIST
27804: LIST
27805: PUSH
27806: EMPTY
27807: LIST
27808: LIST
27809: LIST
27810: PUSH
27811: LD_INT 26
27813: PUSH
27814: LD_INT 1
27816: PUSH
27817: EMPTY
27818: LIST
27819: LIST
27820: PUSH
27821: LD_INT 23
27823: PUSH
27824: LD_INT 1
27826: PUSH
27827: EMPTY
27828: LIST
27829: LIST
27830: PUSH
27831: EMPTY
27832: LIST
27833: LIST
27834: LIST
27835: PPUSH
27836: CALL_OW 69
27840: PUSH
27841: LD_VAR 0 12
27845: PUSH
27846: LD_EXP 40
27850: UNION
27851: PUSH
27852: LD_EXP 62
27856: UNION
27857: DIFF
27858: ST_TO_ADDR
// if tmp2 then
27859: LD_VAR 0 4
27863: IFFALSE 27881
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
27865: LD_VAR 0 4
27869: PUSH
27870: LD_INT 1
27872: ARRAY
27873: PPUSH
27874: LD_STRING D6c-Sol1-1
27876: PPUSH
27877: CALL_OW 88
// if Lisa then
27881: LD_EXP 43
27885: IFFALSE 27899
// Say ( Lisa , D6c-Lisa-1 ) ;
27887: LD_EXP 43
27891: PPUSH
27892: LD_STRING D6c-Lisa-1
27894: PPUSH
27895: CALL_OW 88
// if Gary then
27899: LD_EXP 52
27903: IFFALSE 27917
// Say ( Gary , D6c-Gary-1 ) ;
27905: LD_EXP 52
27909: PPUSH
27910: LD_STRING D6c-Gary-1
27912: PPUSH
27913: CALL_OW 88
// if Donaldson then
27917: LD_EXP 44
27921: IFFALSE 27935
// Say ( Donaldson , D6c-Don-1 ) ;
27923: LD_EXP 44
27927: PPUSH
27928: LD_STRING D6c-Don-1
27930: PPUSH
27931: CALL_OW 88
// if tmp2 > 1 then
27935: LD_VAR 0 4
27939: PUSH
27940: LD_INT 1
27942: GREATER
27943: IFFALSE 27961
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
27945: LD_VAR 0 4
27949: PUSH
27950: LD_INT 2
27952: ARRAY
27953: PPUSH
27954: LD_STRING D6c-Sol2-1
27956: PPUSH
27957: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
27961: LD_VAR 0 12
27965: PPUSH
27966: LD_STRING D6c-Sol3-2
27968: PPUSH
27969: CALL_OW 88
// if IsInUnit ( JMM ) then
27973: LD_EXP 40
27977: PPUSH
27978: CALL_OW 310
27982: IFFALSE 28000
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
27984: LD_EXP 40
27988: PPUSH
27989: CALL_OW 310
27993: PPUSH
27994: CALL_OW 87
27998: GO 28009
// CenterNowOnUnits ( JMM ) ;
28000: LD_EXP 40
28004: PPUSH
28005: CALL_OW 87
// dwait ( 0 0$2 ) ;
28009: LD_INT 70
28011: PPUSH
28012: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
28016: LD_EXP 40
28020: PPUSH
28021: LD_STRING D6c-JMM-2
28023: PPUSH
28024: CALL_OW 88
// DialogueOff ;
28028: CALL_OW 7
// Video ( false ) ;
28032: LD_INT 0
28034: PPUSH
28035: CALL 107976 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
28039: LD_INT 22
28041: PUSH
28042: LD_INT 4
28044: PUSH
28045: EMPTY
28046: LIST
28047: LIST
28048: PPUSH
28049: CALL_OW 69
28053: PPUSH
28054: LD_INT 1
28056: PPUSH
28057: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
28061: LD_INT 4
28063: PPUSH
28064: LD_INT 4
28066: PPUSH
28067: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
28071: LD_ADDR_VAR 0 1
28075: PUSH
28076: LD_INT 4
28078: PPUSH
28079: LD_INT 1
28081: PPUSH
28082: LD_INT 2
28084: PPUSH
28085: CALL 70356 0 3
28089: PUSH
28090: FOR_IN
28091: IFFALSE 28128
// if GetTech ( i , 1 ) <> state_researched then
28093: LD_VAR 0 1
28097: PPUSH
28098: LD_INT 1
28100: PPUSH
28101: CALL_OW 321
28105: PUSH
28106: LD_INT 2
28108: NONEQUAL
28109: IFFALSE 28126
// SetTech ( i , 1 , state_researched ) ;
28111: LD_VAR 0 1
28115: PPUSH
28116: LD_INT 1
28118: PPUSH
28119: LD_INT 2
28121: PPUSH
28122: CALL_OW 322
28126: GO 28090
28128: POP
28129: POP
// missionStage := 6 ;
28130: LD_ADDR_EXP 15
28134: PUSH
28135: LD_INT 6
28137: ST_TO_ADDR
// activeAttacks := true ;
28138: LD_ADDR_EXP 16
28142: PUSH
28143: LD_INT 1
28145: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
28146: LD_STRING M2
28148: PPUSH
28149: CALL_OW 337
// SaveForQuickRestart ;
28153: CALL_OW 22
// wait ( 0 0$40 ) ;
28157: LD_INT 1400
28159: PPUSH
28160: CALL_OW 67
// DialogueOn ;
28164: CALL_OW 6
// SayRadioNoFaceNoName ( Friend , D7-Friend-1 ) ;
28168: LD_EXP 66
28172: PPUSH
28173: LD_STRING D7-Friend-1
28175: PPUSH
28176: CALL 112073 0 2
// Say ( JMM , D7-JMM-1 ) ;
28180: LD_EXP 40
28184: PPUSH
28185: LD_STRING D7-JMM-1
28187: PPUSH
28188: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-2 ) ;
28192: LD_EXP 66
28196: PPUSH
28197: LD_STRING D7-Friend-2
28199: PPUSH
28200: CALL 112073 0 2
// Say ( JMM , D7-JMM-2 ) ;
28204: LD_EXP 40
28208: PPUSH
28209: LD_STRING D7-JMM-2
28211: PPUSH
28212: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-3 ) ;
28216: LD_EXP 66
28220: PPUSH
28221: LD_STRING D7-Friend-3
28223: PPUSH
28224: CALL 112073 0 2
// Say ( JMM , D7-JMM-3 ) ;
28228: LD_EXP 40
28232: PPUSH
28233: LD_STRING D7-JMM-3
28235: PPUSH
28236: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-4 ) ;
28240: LD_EXP 66
28244: PPUSH
28245: LD_STRING D7-Friend-4
28247: PPUSH
28248: CALL 112073 0 2
// Say ( JMM , D7-JMM-4 ) ;
28252: LD_EXP 40
28256: PPUSH
28257: LD_STRING D7-JMM-4
28259: PPUSH
28260: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-5 ) ;
28264: LD_EXP 66
28268: PPUSH
28269: LD_STRING D7-Friend-5
28271: PPUSH
28272: CALL 112073 0 2
// Say ( JMM , D7-JMM-5 ) ;
28276: LD_EXP 40
28280: PPUSH
28281: LD_STRING D7-JMM-5
28283: PPUSH
28284: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-6 ) ;
28288: LD_EXP 66
28292: PPUSH
28293: LD_STRING D7-Friend-6
28295: PPUSH
28296: CALL 112073 0 2
// Say ( JMM , D7-JMM-6 ) ;
28300: LD_EXP 40
28304: PPUSH
28305: LD_STRING D7-JMM-6
28307: PPUSH
28308: CALL_OW 88
// DialogueOff ;
28312: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
28316: LD_STRING Mlegion
28318: PPUSH
28319: CALL_OW 337
// skirmish := true ;
28323: LD_ADDR_EXP 100
28327: PUSH
28328: LD_INT 1
28330: ST_TO_ADDR
// RebuildKozlovFactory ;
28331: CALL 5380 0 0
// end ;
28335: PPOPN 14
28337: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
28338: LD_EXP 20
28342: PUSH
28343: LD_EXP 61
28347: PPUSH
28348: CALL_OW 300
28352: AND
28353: IFFALSE 28395
28355: GO 28357
28357: DISABLE
// begin enable ;
28358: ENABLE
// if IsInUnit ( Powell ) then
28359: LD_EXP 61
28363: PPUSH
28364: CALL_OW 310
28368: IFFALSE 28386
// CenterOnUnits ( IsInUnit ( Powell ) ) else
28370: LD_EXP 61
28374: PPUSH
28375: CALL_OW 310
28379: PPUSH
28380: CALL_OW 85
28384: GO 28395
// CenterOnUnits ( Powell ) ;
28386: LD_EXP 61
28390: PPUSH
28391: CALL_OW 85
// end ;
28395: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
28396: LD_INT 22
28398: PUSH
28399: LD_INT 8
28401: PUSH
28402: EMPTY
28403: LIST
28404: LIST
28405: PUSH
28406: LD_INT 34
28408: PUSH
28409: LD_INT 48
28411: PUSH
28412: EMPTY
28413: LIST
28414: LIST
28415: PUSH
28416: EMPTY
28417: LIST
28418: LIST
28419: PPUSH
28420: CALL_OW 69
28424: IFFALSE 28698
28426: GO 28428
28428: DISABLE
28429: LD_INT 0
28431: PPUSH
28432: PPUSH
// begin if missionStage < 9 then
28433: LD_EXP 15
28437: PUSH
28438: LD_INT 9
28440: LESS
28441: IFFALSE 28451
// missionStage := 9 ;
28443: LD_ADDR_EXP 15
28447: PUSH
28448: LD_INT 9
28450: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28451: LD_ADDR_VAR 0 1
28455: PUSH
28456: LD_INT 22
28458: PUSH
28459: LD_INT 8
28461: PUSH
28462: EMPTY
28463: LIST
28464: LIST
28465: PUSH
28466: LD_INT 34
28468: PUSH
28469: LD_INT 48
28471: PUSH
28472: EMPTY
28473: LIST
28474: LIST
28475: PUSH
28476: EMPTY
28477: LIST
28478: LIST
28479: PPUSH
28480: CALL_OW 69
28484: PUSH
28485: LD_INT 1
28487: ARRAY
28488: ST_TO_ADDR
// wait ( 0 0$05 ) ;
28489: LD_INT 175
28491: PPUSH
28492: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
28496: LD_EXP 12
28500: PUSH
28501: LD_EXP 3
28505: PUSH
28506: LD_INT 0
28508: PUSH
28509: LD_INT 2
28511: PUSH
28512: EMPTY
28513: LIST
28514: LIST
28515: IN
28516: OR
28517: IFFALSE 28540
// target := [ 68 , 108 , 1 ] else
28519: LD_ADDR_VAR 0 2
28523: PUSH
28524: LD_INT 68
28526: PUSH
28527: LD_INT 108
28529: PUSH
28530: LD_INT 1
28532: PUSH
28533: EMPTY
28534: LIST
28535: LIST
28536: LIST
28537: ST_TO_ADDR
28538: GO 28559
// target := [ 181 , 88 , 2 ] ;
28540: LD_ADDR_VAR 0 2
28544: PUSH
28545: LD_INT 181
28547: PUSH
28548: LD_INT 88
28550: PUSH
28551: LD_INT 2
28553: PUSH
28554: EMPTY
28555: LIST
28556: LIST
28557: LIST
28558: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
28559: LD_VAR 0 1
28563: PPUSH
28564: LD_VAR 0 2
28568: PUSH
28569: LD_INT 1
28571: ARRAY
28572: PPUSH
28573: LD_VAR 0 2
28577: PUSH
28578: LD_INT 2
28580: ARRAY
28581: PPUSH
28582: CALL_OW 176
// if target [ 3 ] = 1 then
28586: LD_VAR 0 2
28590: PUSH
28591: LD_INT 3
28593: ARRAY
28594: PUSH
28595: LD_INT 1
28597: EQUAL
28598: IFFALSE 28614
// SayRadio ( Kurt , D12-Kurt-1 ) else
28600: LD_EXP 64
28604: PPUSH
28605: LD_STRING D12-Kurt-1
28607: PPUSH
28608: CALL_OW 94
28612: GO 28638
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
28614: LD_EXP 64
28618: PPUSH
28619: LD_STRING D12a-Kurt-1
28621: PPUSH
28622: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
28626: LD_EXP 79
28630: PPUSH
28631: LD_STRING D12a-Roth-1
28633: PPUSH
28634: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
28638: LD_INT 350
28640: PPUSH
28641: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
28645: LD_VAR 0 1
28649: PPUSH
28650: LD_INT 22
28652: PUSH
28653: LD_INT 8
28655: PUSH
28656: EMPTY
28657: LIST
28658: LIST
28659: PUSH
28660: LD_INT 23
28662: PUSH
28663: LD_INT 2
28665: PUSH
28666: EMPTY
28667: LIST
28668: LIST
28669: PUSH
28670: LD_INT 30
28672: PUSH
28673: LD_INT 3
28675: PUSH
28676: EMPTY
28677: LIST
28678: LIST
28679: PUSH
28680: EMPTY
28681: LIST
28682: LIST
28683: LIST
28684: PPUSH
28685: CALL_OW 69
28689: PUSH
28690: LD_INT 1
28692: ARRAY
28693: PPUSH
28694: CALL_OW 228
// end ;
28698: PPOPN 2
28700: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
28701: LD_EXP 64
28705: PPUSH
28706: CALL_OW 256
28710: PUSH
28711: LD_INT 999
28713: LESS
28714: PUSH
28715: LD_INT 22
28717: PUSH
28718: LD_INT 8
28720: PUSH
28721: EMPTY
28722: LIST
28723: LIST
28724: PUSH
28725: LD_INT 21
28727: PUSH
28728: LD_INT 1
28730: PUSH
28731: EMPTY
28732: LIST
28733: LIST
28734: PUSH
28735: LD_INT 23
28737: PUSH
28738: LD_INT 2
28740: PUSH
28741: EMPTY
28742: LIST
28743: LIST
28744: PUSH
28745: EMPTY
28746: LIST
28747: LIST
28748: LIST
28749: PPUSH
28750: CALL_OW 69
28754: PUSH
28755: LD_INT 9
28757: PUSH
28758: LD_INT 8
28760: PUSH
28761: LD_INT 7
28763: PUSH
28764: LD_INT 6
28766: PUSH
28767: EMPTY
28768: LIST
28769: LIST
28770: LIST
28771: LIST
28772: PUSH
28773: LD_OWVAR 67
28777: ARRAY
28778: LESSEQUAL
28779: OR
28780: PUSH
28781: LD_INT 22
28783: PUSH
28784: LD_INT 8
28786: PUSH
28787: EMPTY
28788: LIST
28789: LIST
28790: PUSH
28791: LD_INT 34
28793: PUSH
28794: LD_INT 48
28796: PUSH
28797: EMPTY
28798: LIST
28799: LIST
28800: PUSH
28801: EMPTY
28802: LIST
28803: LIST
28804: PPUSH
28805: CALL_OW 69
28809: NOT
28810: AND
28811: PUSH
28812: LD_EXP 64
28816: PPUSH
28817: CALL_OW 302
28821: AND
28822: PUSH
28823: LD_INT 5
28825: PPUSH
28826: LD_INT 22
28828: PUSH
28829: LD_INT 1
28831: PUSH
28832: EMPTY
28833: LIST
28834: LIST
28835: PPUSH
28836: CALL_OW 70
28840: AND
28841: IFFALSE 29603
28843: GO 28845
28845: DISABLE
28846: LD_INT 0
28848: PPUSH
28849: PPUSH
28850: PPUSH
// begin legionDestroyed := true ;
28851: LD_ADDR_EXP 22
28855: PUSH
28856: LD_INT 1
28858: ST_TO_ADDR
// DialogueOn ;
28859: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
28863: LD_EXP 40
28867: PPUSH
28868: LD_STRING D13-JMM-1
28870: PPUSH
28871: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
28875: LD_EXP 64
28879: PPUSH
28880: LD_STRING D13-Kurt-1
28882: PPUSH
28883: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
28887: LD_EXP 40
28891: PPUSH
28892: LD_STRING D13-JMM-2
28894: PPUSH
28895: CALL_OW 88
// if FakeInfo then
28899: LD_EXP 12
28903: IFFALSE 28923
// begin Say ( Kurt , D13-Kurt-2 ) ;
28905: LD_EXP 64
28909: PPUSH
28910: LD_STRING D13-Kurt-2
28912: PPUSH
28913: CALL_OW 88
// DialogueOff ;
28917: CALL_OW 7
// exit ;
28921: GO 29603
// end ; if not KurtStatus then
28923: LD_EXP 3
28927: NOT
28928: IFFALSE 28944
// Say ( Kurt , D13-Kurt-2b ) else
28930: LD_EXP 64
28934: PPUSH
28935: LD_STRING D13-Kurt-2b
28937: PPUSH
28938: CALL_OW 88
28942: GO 28956
// Say ( Kurt , D13-Kurt-2a ) ;
28944: LD_EXP 64
28948: PPUSH
28949: LD_STRING D13-Kurt-2a
28951: PPUSH
28952: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
28956: LD_EXP 40
28960: PPUSH
28961: LD_STRING D13-JMM-3
28963: PPUSH
28964: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
28968: LD_EXP 64
28972: PPUSH
28973: LD_STRING D13-Kurt-3
28975: PPUSH
28976: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
28980: LD_EXP 40
28984: PPUSH
28985: LD_STRING D13-JMM-4
28987: PPUSH
28988: CALL_OW 88
// DialogueOff ;
28992: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
28996: LD_STRING MlegionOut
28998: PPUSH
28999: CALL_OW 337
// MC_Kill ( 3 ) ;
29003: LD_INT 3
29005: PPUSH
29006: CALL 39821 0 1
// KillUnit ( Kozlov ) ;
29010: LD_EXP 65
29014: PPUSH
29015: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
29019: LD_ADDR_VAR 0 1
29023: PUSH
29024: LD_INT 22
29026: PUSH
29027: LD_INT 8
29029: PUSH
29030: EMPTY
29031: LIST
29032: LIST
29033: PUSH
29034: LD_INT 23
29036: PUSH
29037: LD_INT 3
29039: PUSH
29040: EMPTY
29041: LIST
29042: LIST
29043: PUSH
29044: LD_INT 3
29046: PUSH
29047: LD_INT 21
29049: PUSH
29050: LD_INT 33
29052: PUSH
29053: EMPTY
29054: LIST
29055: LIST
29056: PUSH
29057: EMPTY
29058: LIST
29059: LIST
29060: PUSH
29061: EMPTY
29062: LIST
29063: LIST
29064: LIST
29065: PPUSH
29066: CALL_OW 69
29070: PUSH
29071: FOR_IN
29072: IFFALSE 29085
// KillUnit ( i ) ;
29074: LD_VAR 0 1
29078: PPUSH
29079: CALL_OW 66
29083: GO 29071
29085: POP
29086: POP
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
29087: LD_ADDR_VAR 0 1
29091: PUSH
29092: LD_INT 22
29094: PUSH
29095: LD_INT 8
29097: PUSH
29098: EMPTY
29099: LIST
29100: LIST
29101: PUSH
29102: LD_INT 21
29104: PUSH
29105: LD_INT 2
29107: PUSH
29108: EMPTY
29109: LIST
29110: LIST
29111: PUSH
29112: EMPTY
29113: LIST
29114: LIST
29115: PPUSH
29116: CALL_OW 69
29120: PUSH
29121: FOR_IN
29122: IFFALSE 29135
// KillUnit ( i ) ;
29124: LD_VAR 0 1
29128: PPUSH
29129: CALL_OW 66
29133: GO 29121
29135: POP
29136: POP
// wait ( 0 0$0.6 ) ;
29137: LD_INT 21
29139: PPUSH
29140: CALL_OW 67
// ChangeSideFog ( 8 , 1 ) ;
29144: LD_INT 8
29146: PPUSH
29147: LD_INT 1
29149: PPUSH
29150: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
29154: LD_ADDR_VAR 0 2
29158: PUSH
29159: LD_INT 22
29161: PUSH
29162: LD_INT 8
29164: PUSH
29165: EMPTY
29166: LIST
29167: LIST
29168: PUSH
29169: LD_INT 21
29171: PUSH
29172: LD_INT 1
29174: PUSH
29175: EMPTY
29176: LIST
29177: LIST
29178: PUSH
29179: EMPTY
29180: LIST
29181: LIST
29182: PPUSH
29183: CALL_OW 69
29187: PUSH
29188: LD_EXP 65
29192: PUSH
29193: LD_EXP 64
29197: PUSH
29198: EMPTY
29199: LIST
29200: LIST
29201: DIFF
29202: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
29203: LD_VAR 0 2
29207: PUSH
29208: LD_INT 6
29210: PUSH
29211: LD_INT 5
29213: PUSH
29214: LD_INT 4
29216: PUSH
29217: LD_INT 3
29219: PUSH
29220: EMPTY
29221: LIST
29222: LIST
29223: LIST
29224: LIST
29225: PUSH
29226: LD_OWVAR 67
29230: ARRAY
29231: GREATEREQUAL
29232: IFFALSE 29384
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
29234: LD_ADDR_VAR 0 3
29238: PUSH
29239: LD_INT 6
29241: PUSH
29242: LD_INT 5
29244: PUSH
29245: LD_INT 4
29247: PUSH
29248: LD_INT 3
29250: PUSH
29251: EMPTY
29252: LIST
29253: LIST
29254: LIST
29255: LIST
29256: PUSH
29257: LD_OWVAR 67
29261: ARRAY
29262: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
29263: LD_ADDR_VAR 0 1
29267: PUSH
29268: DOUBLE
29269: LD_VAR 0 2
29273: PUSH
29274: LD_VAR 0 3
29278: PUSH
29279: LD_INT 1
29281: PLUS
29282: MINUS
29283: INC
29284: ST_TO_ADDR
29285: LD_INT 1
29287: PUSH
29288: FOR_DOWNTO
29289: IFFALSE 29380
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
29291: LD_ADDR_EXP 38
29295: PUSH
29296: LD_EXP 38
29300: PUSH
29301: LD_VAR 0 2
29305: PUSH
29306: LD_VAR 0 1
29310: ARRAY
29311: ADD
29312: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
29313: LD_VAR 0 2
29317: PUSH
29318: LD_VAR 0 1
29322: ARRAY
29323: PPUSH
29324: CALL_OW 310
29328: IFFALSE 29345
// ComExit ( tmp [ i ] ) ;
29330: LD_VAR 0 2
29334: PUSH
29335: LD_VAR 0 1
29339: ARRAY
29340: PPUSH
29341: CALL 108402 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
29345: LD_VAR 0 2
29349: PUSH
29350: LD_VAR 0 1
29354: ARRAY
29355: PPUSH
29356: LD_INT 34
29358: PUSH
29359: LD_INT 0
29361: PPUSH
29362: LD_INT 6
29364: PPUSH
29365: CALL_OW 12
29369: PLUS
29370: PPUSH
29371: LD_INT 1
29373: PPUSH
29374: CALL_OW 171
// end ;
29378: GO 29288
29380: POP
29381: POP
// end else
29382: GO 29394
// x := tmp ;
29384: LD_ADDR_VAR 0 3
29388: PUSH
29389: LD_VAR 0 2
29393: ST_TO_ADDR
// for i := tmp downto tmp - x do
29394: LD_ADDR_VAR 0 1
29398: PUSH
29399: DOUBLE
29400: LD_VAR 0 2
29404: INC
29405: ST_TO_ADDR
29406: LD_VAR 0 2
29410: PUSH
29411: LD_VAR 0 3
29415: MINUS
29416: PUSH
29417: FOR_DOWNTO
29418: IFFALSE 29490
// begin if IsInUnit ( tmp [ i ] ) then
29420: LD_VAR 0 2
29424: PUSH
29425: LD_VAR 0 1
29429: ARRAY
29430: PPUSH
29431: CALL_OW 310
29435: IFFALSE 29452
// ComExit ( tmp [ i ] ) ;
29437: LD_VAR 0 2
29441: PUSH
29442: LD_VAR 0 1
29446: ARRAY
29447: PPUSH
29448: CALL 108402 0 1
// SetSide ( tmp [ i ] , 1 ) ;
29452: LD_VAR 0 2
29456: PUSH
29457: LD_VAR 0 1
29461: ARRAY
29462: PPUSH
29463: LD_INT 1
29465: PPUSH
29466: CALL_OW 235
// SetLives ( tmp [ i ] , 1000 ) ;
29470: LD_VAR 0 2
29474: PUSH
29475: LD_VAR 0 1
29479: ARRAY
29480: PPUSH
29481: LD_INT 1000
29483: PPUSH
29484: CALL_OW 234
// end ;
29488: GO 29417
29490: POP
29491: POP
// SetSide ( Kurt , 1 ) ;
29492: LD_EXP 64
29496: PPUSH
29497: LD_INT 1
29499: PPUSH
29500: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
29504: LD_INT 22
29506: PUSH
29507: LD_INT 8
29509: PUSH
29510: EMPTY
29511: LIST
29512: LIST
29513: PUSH
29514: LD_INT 21
29516: PUSH
29517: LD_INT 3
29519: PUSH
29520: EMPTY
29521: LIST
29522: LIST
29523: PUSH
29524: EMPTY
29525: LIST
29526: LIST
29527: PPUSH
29528: CALL_OW 69
29532: PPUSH
29533: LD_INT 1
29535: PPUSH
29536: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
29540: LD_INT 8
29542: PPUSH
29543: LD_INT 1
29545: PPUSH
29546: LD_INT 1
29548: PPUSH
29549: LD_INT 1
29551: PPUSH
29552: CALL_OW 80
// wait ( 1 1$20 ) ;
29556: LD_INT 2800
29558: PPUSH
29559: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
29563: LD_EXP 66
29567: PPUSH
29568: LD_INT 37
29570: PPUSH
29571: LD_INT 1
29573: PPUSH
29574: LD_INT 0
29576: PPUSH
29577: CALL_OW 48
// wait ( 0 0$1 ) ;
29581: LD_INT 35
29583: PPUSH
29584: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
29588: LD_EXP 66
29592: PPUSH
29593: LD_INT 60
29595: PPUSH
29596: LD_INT 95
29598: PPUSH
29599: CALL_OW 111
// end ;
29603: PPOPN 3
29605: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
29606: LD_EXP 22
29610: NOT
29611: PUSH
29612: LD_INT 22
29614: PUSH
29615: LD_INT 8
29617: PUSH
29618: EMPTY
29619: LIST
29620: LIST
29621: PUSH
29622: LD_INT 21
29624: PUSH
29625: LD_INT 1
29627: PUSH
29628: EMPTY
29629: LIST
29630: LIST
29631: PUSH
29632: EMPTY
29633: LIST
29634: LIST
29635: PPUSH
29636: CALL_OW 69
29640: PUSH
29641: LD_INT 0
29643: EQUAL
29644: AND
29645: IFFALSE 29665
29647: GO 29649
29649: DISABLE
// begin legionDestroyed := true ;
29650: LD_ADDR_EXP 22
29654: PUSH
29655: LD_INT 1
29657: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
29658: LD_STRING MlegionOut
29660: PPUSH
29661: CALL_OW 337
// end ;
29665: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
29666: LD_EXP 38
29670: IFFALSE 29745
29672: GO 29674
29674: DISABLE
29675: LD_INT 0
29677: PPUSH
// begin enable ;
29678: ENABLE
// for i in legionEscapeUnits do
29679: LD_ADDR_VAR 0 1
29683: PUSH
29684: LD_EXP 38
29688: PUSH
29689: FOR_IN
29690: IFFALSE 29743
// begin if IsInArea ( i , legionEscapeArea ) then
29692: LD_VAR 0 1
29696: PPUSH
29697: LD_INT 31
29699: PPUSH
29700: CALL_OW 308
29704: IFFALSE 29717
// RemoveUnit ( i ) else
29706: LD_VAR 0 1
29710: PPUSH
29711: CALL_OW 64
29715: GO 29741
// if not HasTask ( i ) then
29717: LD_VAR 0 1
29721: PPUSH
29722: CALL_OW 314
29726: NOT
29727: IFFALSE 29741
// ComMoveToArea ( i , legionEscapeArea ) ;
29729: LD_VAR 0 1
29733: PPUSH
29734: LD_INT 31
29736: PPUSH
29737: CALL_OW 113
// end ;
29741: GO 29689
29743: POP
29744: POP
// end ;
29745: PPOPN 1
29747: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
29748: LD_INT 1
29750: PPUSH
29751: LD_EXP 66
29755: PPUSH
29756: CALL_OW 292
29760: IFFALSE 30058
29762: GO 29764
29764: DISABLE
29765: LD_INT 0
29767: PPUSH
// begin wait ( 0 0$2 ) ;
29768: LD_INT 70
29770: PPUSH
29771: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
29775: LD_EXP 66
29779: PPUSH
29780: CALL_OW 87
// DialogueOn ;
29784: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
29788: LD_EXP 40
29792: PPUSH
29793: LD_STRING D14-JMM-1
29795: PPUSH
29796: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
29800: LD_EXP 66
29804: PPUSH
29805: LD_STRING D14-Friend-1
29807: PPUSH
29808: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
29812: LD_EXP 40
29816: PPUSH
29817: LD_STRING D14-JMM-2
29819: PPUSH
29820: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
29824: LD_EXP 66
29828: PPUSH
29829: LD_STRING D14-Friend-2
29831: PPUSH
29832: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
29836: LD_EXP 40
29840: PPUSH
29841: LD_STRING D14-JMM-3
29843: PPUSH
29844: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
29848: LD_EXP 66
29852: PPUSH
29853: LD_STRING D14-Friend-3
29855: PPUSH
29856: CALL_OW 88
// DialogueOff ;
29860: CALL_OW 7
// dec := Query ( Q14 ) ;
29864: LD_ADDR_VAR 0 1
29868: PUSH
29869: LD_STRING Q14
29871: PPUSH
29872: CALL_OW 97
29876: ST_TO_ADDR
// if dec = 1 then
29877: LD_VAR 0 1
29881: PUSH
29882: LD_INT 1
29884: EQUAL
29885: IFFALSE 29919
// begin DialogueOn ;
29887: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
29891: LD_EXP 40
29895: PPUSH
29896: LD_STRING D14a-JMM-1
29898: PPUSH
29899: CALL_OW 88
// DialogueOff ;
29903: CALL_OW 7
// SetSide ( Friend , 1 ) ;
29907: LD_EXP 66
29911: PPUSH
29912: LD_INT 1
29914: PPUSH
29915: CALL_OW 235
// end ; if dec = 2 then
29919: LD_VAR 0 1
29923: PUSH
29924: LD_INT 2
29926: EQUAL
29927: IFFALSE 29980
// begin DialogueOn ;
29929: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
29933: LD_EXP 40
29937: PPUSH
29938: LD_STRING D14b-JMM-1
29940: PPUSH
29941: CALL_OW 88
// DialogueOff ;
29945: CALL_OW 7
// wait ( 0 0$1 ) ;
29949: LD_INT 35
29951: PPUSH
29952: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
29956: LD_EXP 66
29960: PPUSH
29961: LD_INT 9
29963: PPUSH
29964: LD_INT 2
29966: PPUSH
29967: CALL_OW 111
// AddComHold ( Friend ) ;
29971: LD_EXP 66
29975: PPUSH
29976: CALL_OW 200
// end ; if dec = 3 then
29980: LD_VAR 0 1
29984: PUSH
29985: LD_INT 3
29987: EQUAL
29988: IFFALSE 30058
// begin DialogueOn ;
29990: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
29994: LD_EXP 40
29998: PPUSH
29999: LD_STRING D14c-JMM-1
30001: PPUSH
30002: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
30006: LD_EXP 66
30010: PPUSH
30011: LD_STRING D14c-Friend-1
30013: PPUSH
30014: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
30018: LD_EXP 40
30022: PPUSH
30023: LD_STRING D14c-JMM-2
30025: PPUSH
30026: CALL_OW 88
// DialogueOff ;
30030: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
30034: LD_EXP 66
30038: PPUSH
30039: LD_INT 9
30041: PPUSH
30042: LD_INT 2
30044: PPUSH
30045: CALL_OW 111
// AddComHold ( Friend ) ;
30049: LD_EXP 66
30053: PPUSH
30054: CALL_OW 200
// end ; end ;
30058: PPOPN 1
30060: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
30061: LD_INT 9
30063: PPUSH
30064: LD_INT 2
30066: PPUSH
30067: CALL_OW 428
30071: PUSH
30072: LD_EXP 66
30076: EQUAL
30077: PUSH
30078: LD_EXP 66
30082: PPUSH
30083: CALL_OW 255
30087: PUSH
30088: LD_INT 8
30090: EQUAL
30091: AND
30092: IFFALSE 30106
30094: GO 30096
30096: DISABLE
// RemoveUnit ( Friend ) ;
30097: LD_EXP 66
30101: PPUSH
30102: CALL_OW 64
30106: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
30107: LD_EXP 14
30111: PUSH
30112: LD_INT 31500
30114: GREATEREQUAL
30115: PUSH
30116: LD_EXP 7
30120: AND
30121: PUSH
30122: LD_EXP 2
30126: AND
30127: IFFALSE 30573
30129: GO 30131
30131: DISABLE
30132: LD_INT 0
30134: PPUSH
30135: PPUSH
30136: PPUSH
// begin missionStage := 7 ;
30137: LD_ADDR_EXP 15
30141: PUSH
30142: LD_INT 7
30144: ST_TO_ADDR
// for i := 1 to 5 do
30145: LD_ADDR_VAR 0 1
30149: PUSH
30150: DOUBLE
30151: LD_INT 1
30153: DEC
30154: ST_TO_ADDR
30155: LD_INT 5
30157: PUSH
30158: FOR_TO
30159: IFFALSE 30271
// begin uc_side = 1 ;
30161: LD_ADDR_OWVAR 20
30165: PUSH
30166: LD_INT 1
30168: ST_TO_ADDR
// uc_nation = 1 ;
30169: LD_ADDR_OWVAR 21
30173: PUSH
30174: LD_INT 1
30176: ST_TO_ADDR
// vc_engine = engine_siberite ;
30177: LD_ADDR_OWVAR 39
30181: PUSH
30182: LD_INT 3
30184: ST_TO_ADDR
// vc_control = control_computer ;
30185: LD_ADDR_OWVAR 38
30189: PUSH
30190: LD_INT 3
30192: ST_TO_ADDR
// vc_chassis = us_medium_tracked ;
30193: LD_ADDR_OWVAR 37
30197: PUSH
30198: LD_INT 3
30200: ST_TO_ADDR
// vc_weapon = [ us_double_gun , us_laser , us_rocket_launcher ] [ Rand ( 1 , 3 ) ] ;
30201: LD_ADDR_OWVAR 40
30205: PUSH
30206: LD_INT 5
30208: PUSH
30209: LD_INT 9
30211: PUSH
30212: LD_INT 7
30214: PUSH
30215: EMPTY
30216: LIST
30217: LIST
30218: LIST
30219: PUSH
30220: LD_INT 1
30222: PPUSH
30223: LD_INT 3
30225: PPUSH
30226: CALL_OW 12
30230: ARRAY
30231: ST_TO_ADDR
// veh = CreateVehicle ;
30232: LD_ADDR_VAR 0 2
30236: PUSH
30237: CALL_OW 45
30241: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
30242: LD_VAR 0 2
30246: PPUSH
30247: LD_INT 1
30249: PPUSH
30250: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
30254: LD_VAR 0 2
30258: PPUSH
30259: LD_INT 19
30261: PPUSH
30262: LD_INT 0
30264: PPUSH
30265: CALL_OW 49
// end ;
30269: GO 30158
30271: POP
30272: POP
// uc_side = 1 ;
30273: LD_ADDR_OWVAR 20
30277: PUSH
30278: LD_INT 1
30280: ST_TO_ADDR
// uc_nation = 1 ;
30281: LD_ADDR_OWVAR 21
30285: PUSH
30286: LD_INT 1
30288: ST_TO_ADDR
// vc_engine = 3 ;
30289: LD_ADDR_OWVAR 39
30293: PUSH
30294: LD_INT 3
30296: ST_TO_ADDR
// vc_control = 1 ;
30297: LD_ADDR_OWVAR 38
30301: PUSH
30302: LD_INT 1
30304: ST_TO_ADDR
// vc_chassis = 3 ;
30305: LD_ADDR_OWVAR 37
30309: PUSH
30310: LD_INT 3
30312: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
30313: LD_ADDR_OWVAR 40
30317: PUSH
30318: LD_INT 5
30320: PUSH
30321: LD_INT 9
30323: PUSH
30324: LD_INT 7
30326: PUSH
30327: EMPTY
30328: LIST
30329: LIST
30330: LIST
30331: PUSH
30332: LD_INT 1
30334: PPUSH
30335: LD_INT 3
30337: PPUSH
30338: CALL_OW 12
30342: ARRAY
30343: ST_TO_ADDR
// vehG = CreateVehicle ;
30344: LD_ADDR_VAR 0 3
30348: PUSH
30349: CALL_OW 45
30353: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
30354: LD_VAR 0 3
30358: PPUSH
30359: LD_INT 1
30361: PPUSH
30362: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
30366: LD_VAR 0 3
30370: PPUSH
30371: LD_INT 19
30373: PPUSH
30374: LD_INT 0
30376: PPUSH
30377: CALL_OW 49
// if JMMGirl = 1 then
30381: LD_EXP 7
30385: PUSH
30386: LD_INT 1
30388: EQUAL
30389: IFFALSE 30445
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
30391: LD_ADDR_EXP 41
30395: PUSH
30396: LD_STRING Joan
30398: PPUSH
30399: LD_INT 1
30401: PPUSH
30402: LD_STRING 14_
30404: PPUSH
30405: CALL 70272 0 3
30409: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
30410: LD_EXP 41
30414: PPUSH
30415: LD_VAR 0 3
30419: PPUSH
30420: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30424: LD_VAR 0 3
30428: PPUSH
30429: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
30433: LD_EXP 41
30437: PPUSH
30438: LD_STRING D10BW-Joan-1
30440: PPUSH
30441: CALL_OW 94
// end ; if JMMGirl = 2 then
30445: LD_EXP 7
30449: PUSH
30450: LD_INT 2
30452: EQUAL
30453: IFFALSE 30509
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
30455: LD_ADDR_EXP 43
30459: PUSH
30460: LD_STRING Lisa
30462: PPUSH
30463: LD_INT 1
30465: PPUSH
30466: LD_STRING 14_
30468: PPUSH
30469: CALL 70272 0 3
30473: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
30474: LD_EXP 43
30478: PPUSH
30479: LD_VAR 0 3
30483: PPUSH
30484: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30488: LD_VAR 0 3
30492: PPUSH
30493: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
30497: LD_EXP 43
30501: PPUSH
30502: LD_STRING D10BW-Lisa-1
30504: PPUSH
30505: CALL_OW 94
// end ; if JMMGirl = 3 then
30509: LD_EXP 7
30513: PUSH
30514: LD_INT 3
30516: EQUAL
30517: IFFALSE 30573
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
30519: LD_ADDR_EXP 55
30523: PUSH
30524: LD_STRING Connie
30526: PPUSH
30527: LD_INT 1
30529: PPUSH
30530: LD_STRING 14_
30532: PPUSH
30533: CALL 70272 0 3
30537: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
30538: LD_EXP 55
30542: PPUSH
30543: LD_VAR 0 3
30547: PPUSH
30548: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30552: LD_VAR 0 3
30556: PPUSH
30557: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
30561: LD_EXP 55
30565: PPUSH
30566: LD_STRING D10BW-Con-1
30568: PPUSH
30569: CALL_OW 94
// end ; end ;
30573: PPOPN 3
30575: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
30576: LD_EXP 14
30580: PUSH
30581: LD_INT 94500
30583: GREATEREQUAL
30584: IFFALSE 30996
30586: GO 30588
30588: DISABLE
30589: LD_INT 0
30591: PPUSH
30592: PPUSH
30593: PPUSH
// begin tmp := PrepareStevensSquad ;
30594: LD_ADDR_VAR 0 3
30598: PUSH
30599: CALL 2378 0 0
30603: ST_TO_ADDR
// if not tmp then
30604: LD_VAR 0 3
30608: NOT
30609: IFFALSE 30613
// exit ;
30611: GO 30996
// uc_side := 1 ;
30613: LD_ADDR_OWVAR 20
30617: PUSH
30618: LD_INT 1
30620: ST_TO_ADDR
// uc_nation := 1 ;
30621: LD_ADDR_OWVAR 21
30625: PUSH
30626: LD_INT 1
30628: ST_TO_ADDR
// for i in tmp do
30629: LD_ADDR_VAR 0 1
30633: PUSH
30634: LD_VAR 0 3
30638: PUSH
30639: FOR_IN
30640: IFFALSE 30737
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
30642: LD_INT 3
30644: PPUSH
30645: LD_INT 3
30647: PPUSH
30648: LD_INT 1
30650: PPUSH
30651: LD_INT 5
30653: PUSH
30654: LD_INT 9
30656: PUSH
30657: LD_INT 7
30659: PUSH
30660: EMPTY
30661: LIST
30662: LIST
30663: LIST
30664: PUSH
30665: LD_INT 1
30667: PPUSH
30668: LD_INT 3
30670: PPUSH
30671: CALL_OW 12
30675: ARRAY
30676: PPUSH
30677: LD_INT 40
30679: PPUSH
30680: CALL 75133 0 5
// veh := CreateVehicle ;
30684: LD_ADDR_VAR 0 2
30688: PUSH
30689: CALL_OW 45
30693: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
30694: LD_VAR 0 2
30698: PPUSH
30699: LD_INT 1
30701: PPUSH
30702: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
30706: LD_VAR 0 2
30710: PPUSH
30711: LD_INT 19
30713: PPUSH
30714: LD_INT 0
30716: PPUSH
30717: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
30721: LD_VAR 0 1
30725: PPUSH
30726: LD_VAR 0 2
30730: PPUSH
30731: CALL_OW 52
// end ;
30735: GO 30639
30737: POP
30738: POP
// missionStage := 8 ;
30739: LD_ADDR_EXP 15
30743: PUSH
30744: LD_INT 8
30746: ST_TO_ADDR
// DialogueOn ;
30747: CALL_OW 6
// if Stevens then
30751: LD_EXP 42
30755: IFFALSE 30869
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
30757: LD_EXP 42
30761: PPUSH
30762: CALL_OW 310
30766: PPUSH
30767: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
30771: LD_EXP 42
30775: PPUSH
30776: LD_STRING D8-Huck-1
30778: PPUSH
30779: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
30783: LD_EXP 40
30787: PPUSH
30788: LD_STRING D8-JMM-1
30790: PPUSH
30791: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
30795: LD_EXP 42
30799: PPUSH
30800: LD_STRING D8-Huck-2
30802: PPUSH
30803: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
30807: LD_EXP 40
30811: PPUSH
30812: LD_STRING D8-JMM-2
30814: PPUSH
30815: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
30819: LD_EXP 42
30823: PPUSH
30824: LD_STRING D8-Huck-3
30826: PPUSH
30827: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
30831: LD_EXP 40
30835: PPUSH
30836: LD_STRING D8-JMM-3
30838: PPUSH
30839: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
30843: LD_EXP 42
30847: PPUSH
30848: LD_STRING D8-Huck-4
30850: PPUSH
30851: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
30855: LD_EXP 40
30859: PPUSH
30860: LD_STRING D8-JMM-4
30862: PPUSH
30863: CALL_OW 88
// end else
30867: GO 30979
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
30869: LD_EXP 56
30873: PPUSH
30874: CALL_OW 310
30878: PPUSH
30879: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
30883: LD_EXP 56
30887: PPUSH
30888: LD_STRING D8-Huck-1
30890: PPUSH
30891: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
30895: LD_EXP 40
30899: PPUSH
30900: LD_STRING D8-JMM-1a
30902: PPUSH
30903: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
30907: LD_EXP 56
30911: PPUSH
30912: LD_STRING D8-Huck-2
30914: PPUSH
30915: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
30919: LD_EXP 40
30923: PPUSH
30924: LD_STRING D8-JMM-2
30926: PPUSH
30927: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
30931: LD_EXP 56
30935: PPUSH
30936: LD_STRING D8-Huck-3
30938: PPUSH
30939: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
30943: LD_EXP 40
30947: PPUSH
30948: LD_STRING D8-JMM-3
30950: PPUSH
30951: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
30955: LD_EXP 56
30959: PPUSH
30960: LD_STRING D8-Huck-4
30962: PPUSH
30963: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
30967: LD_EXP 40
30971: PPUSH
30972: LD_STRING D8-JMM-4
30974: PPUSH
30975: CALL_OW 88
// end ; DialogueOff ;
30979: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
30983: LD_INT 25
30985: PPUSH
30986: LD_INT 1
30988: PPUSH
30989: LD_INT 1
30991: PPUSH
30992: CALL_OW 322
// end ;
30996: PPOPN 3
30998: END
// every 0 0$1 trigger IsOk ( sewiVeh ) and See ( 1 , sewiVeh ) do
30999: LD_EXP 75
31003: PPUSH
31004: CALL_OW 302
31008: PUSH
31009: LD_INT 1
31011: PPUSH
31012: LD_EXP 75
31016: PPUSH
31017: CALL_OW 292
31021: AND
31022: IFFALSE 31273
31024: GO 31026
31026: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
31027: LD_EXP 75
31031: PPUSH
31032: CALL_OW 87
// DialogueOn ;
31036: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
31040: LD_EXP 40
31044: PPUSH
31045: LD_STRING D10nB-JMM-1
31047: PPUSH
31048: CALL_OW 88
// if BurlakStatus = 1 then
31052: LD_EXP 9
31056: PUSH
31057: LD_INT 1
31059: EQUAL
31060: IFFALSE 31074
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
31062: LD_EXP 74
31066: PPUSH
31067: LD_STRING D10nB-Vse-1a
31069: PPUSH
31070: CALL_OW 94
// end ; if BurlakStatus = 0 then
31074: LD_EXP 9
31078: PUSH
31079: LD_INT 0
31081: EQUAL
31082: IFFALSE 31096
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
31084: LD_EXP 74
31088: PPUSH
31089: LD_STRING D10nB-Vse-1
31091: PPUSH
31092: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
31096: LD_EXP 40
31100: PPUSH
31101: LD_STRING D10nB-JMM-2
31103: PPUSH
31104: CALL_OW 88
// if KappaStatus then
31108: LD_EXP 2
31112: IFFALSE 31126
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
31114: LD_EXP 74
31118: PPUSH
31119: LD_STRING D10nB-Vse-5a
31121: PPUSH
31122: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
31126: LD_EXP 2
31130: NOT
31131: PUSH
31132: LD_EXP 6
31136: PUSH
31137: LD_INT 0
31139: EQUAL
31140: AND
31141: IFFALSE 31269
// begin if JMMGirl = 1 then
31143: LD_EXP 7
31147: PUSH
31148: LD_INT 1
31150: EQUAL
31151: IFFALSE 31201
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
31153: LD_EXP 74
31157: PPUSH
31158: LD_STRING D10nB-Vse-2
31160: PPUSH
31161: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
31165: LD_EXP 40
31169: PPUSH
31170: LD_STRING D10nB-JMM-3
31172: PPUSH
31173: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
31177: LD_EXP 74
31181: PPUSH
31182: LD_STRING D10nB-Vse-3
31184: PPUSH
31185: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
31189: LD_EXP 40
31193: PPUSH
31194: LD_STRING D10nB-JMM-4
31196: PPUSH
31197: CALL_OW 88
// end ; if JMMGirl = 2 then
31201: LD_EXP 7
31205: PUSH
31206: LD_INT 2
31208: EQUAL
31209: IFFALSE 31235
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
31211: LD_EXP 74
31215: PPUSH
31216: LD_STRING D10nB-Vse-4
31218: PPUSH
31219: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
31223: LD_EXP 40
31227: PPUSH
31228: LD_STRING D10nB-JMM-5
31230: PPUSH
31231: CALL_OW 88
// end ; if JMMGirl = 3 then
31235: LD_EXP 7
31239: PUSH
31240: LD_INT 3
31242: EQUAL
31243: IFFALSE 31269
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
31245: LD_EXP 74
31249: PPUSH
31250: LD_STRING D10nB-Vse-5
31252: PPUSH
31253: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
31257: LD_EXP 40
31261: PPUSH
31262: LD_STRING D10nB-JMM-6
31264: PPUSH
31265: CALL_OW 88
// end ; end ; DialogueOff ;
31269: CALL_OW 7
// end ;
31273: END
// every 0 0$1 trigger missionTime >= 55 55$00 and IsOk ( Kovalyuk ) and IsOk ( ru_depot2 ) do var i , j , tmp ;
31274: LD_EXP 14
31278: PUSH
31279: LD_INT 115500
31281: GREATEREQUAL
31282: PUSH
31283: LD_EXP 69
31287: PPUSH
31288: CALL_OW 302
31292: AND
31293: PUSH
31294: LD_INT 267
31296: PPUSH
31297: CALL_OW 302
31301: AND
31302: IFFALSE 31816
31304: GO 31306
31306: DISABLE
31307: LD_INT 0
31309: PPUSH
31310: PPUSH
31311: PPUSH
// begin missionStage := 10 ;
31312: LD_ADDR_EXP 15
31316: PUSH
31317: LD_INT 10
31319: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
31320: LD_ADDR_VAR 0 3
31324: PUSH
31325: LD_INT 22
31327: PUSH
31328: LD_INT 1
31330: PUSH
31331: EMPTY
31332: LIST
31333: LIST
31334: PUSH
31335: LD_INT 23
31337: PUSH
31338: LD_INT 1
31340: PUSH
31341: EMPTY
31342: LIST
31343: LIST
31344: PUSH
31345: LD_INT 26
31347: PUSH
31348: LD_INT 1
31350: PUSH
31351: EMPTY
31352: LIST
31353: LIST
31354: PUSH
31355: LD_INT 3
31357: PUSH
31358: LD_INT 25
31360: PUSH
31361: LD_INT 12
31363: PUSH
31364: EMPTY
31365: LIST
31366: LIST
31367: PUSH
31368: EMPTY
31369: LIST
31370: LIST
31371: PUSH
31372: LD_INT 3
31374: PUSH
31375: LD_INT 25
31377: PUSH
31378: LD_INT 16
31380: PUSH
31381: EMPTY
31382: LIST
31383: LIST
31384: PUSH
31385: EMPTY
31386: LIST
31387: LIST
31388: PUSH
31389: EMPTY
31390: LIST
31391: LIST
31392: LIST
31393: LIST
31394: LIST
31395: PPUSH
31396: CALL_OW 69
31400: PUSH
31401: LD_EXP 40
31405: PUSH
31406: LD_EXP 64
31410: PUSH
31411: LD_EXP 42
31415: PUSH
31416: LD_EXP 56
31420: PUSH
31421: LD_EXP 43
31425: PUSH
31426: LD_EXP 44
31430: PUSH
31431: LD_EXP 45
31435: PUSH
31436: LD_EXP 46
31440: PUSH
31441: LD_EXP 47
31445: PUSH
31446: LD_EXP 48
31450: PUSH
31451: LD_EXP 49
31455: PUSH
31456: LD_EXP 50
31460: PUSH
31461: LD_EXP 51
31465: PUSH
31466: LD_EXP 52
31470: PUSH
31471: LD_EXP 53
31475: PUSH
31476: LD_EXP 54
31480: PUSH
31481: EMPTY
31482: LIST
31483: LIST
31484: LIST
31485: LIST
31486: LIST
31487: LIST
31488: LIST
31489: LIST
31490: LIST
31491: LIST
31492: LIST
31493: LIST
31494: LIST
31495: LIST
31496: LIST
31497: LIST
31498: DIFF
31499: ST_TO_ADDR
// if not tmp and Brown then
31500: LD_VAR 0 3
31504: NOT
31505: PUSH
31506: LD_EXP 48
31510: AND
31511: IFFALSE 31526
// tmp := [ Brown ] ;
31513: LD_ADDR_VAR 0 3
31517: PUSH
31518: LD_EXP 48
31522: PUSH
31523: EMPTY
31524: LIST
31525: ST_TO_ADDR
// DialogueOn ;
31526: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
31530: LD_VAR 0 3
31534: PUSH
31535: LD_INT 1
31537: ARRAY
31538: PPUSH
31539: LD_STRING D11-Sol1-1
31541: PPUSH
31542: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
31546: LD_EXP 68
31550: PPUSH
31551: LD_STRING D11-Pla-1
31553: PPUSH
31554: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
31558: LD_EXP 69
31562: PPUSH
31563: LD_STRING D11-Kov-1
31565: PPUSH
31566: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
31570: LD_EXP 68
31574: PPUSH
31575: LD_STRING D11-Pla-2
31577: PPUSH
31578: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
31582: LD_VAR 0 3
31586: PUSH
31587: LD_INT 1
31589: ARRAY
31590: PPUSH
31591: LD_STRING D11-Sol1-2
31593: PPUSH
31594: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
31598: LD_EXP 40
31602: PPUSH
31603: LD_STRING D11-JMM-2
31605: PPUSH
31606: CALL_OW 88
// DialogueOff ;
31610: CALL_OW 7
// allowBehemothConstruct := true ;
31614: LD_ADDR_EXP 25
31618: PUSH
31619: LD_INT 1
31621: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
31622: LD_STRING M4
31624: PPUSH
31625: CALL_OW 337
// j := 3 ;
31629: LD_ADDR_VAR 0 2
31633: PUSH
31634: LD_INT 3
31636: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_not , [ f_tag , 105 ] ] , [ f_class , 3 ] ] ) diff Kovalyuk ;
31637: LD_ADDR_VAR 0 3
31641: PUSH
31642: LD_INT 22
31644: PUSH
31645: LD_INT 3
31647: PUSH
31648: EMPTY
31649: LIST
31650: LIST
31651: PUSH
31652: LD_INT 50
31654: PUSH
31655: EMPTY
31656: LIST
31657: PUSH
31658: LD_INT 3
31660: PUSH
31661: LD_INT 120
31663: PUSH
31664: LD_INT 105
31666: PUSH
31667: EMPTY
31668: LIST
31669: LIST
31670: PUSH
31671: EMPTY
31672: LIST
31673: LIST
31674: PUSH
31675: LD_INT 25
31677: PUSH
31678: LD_INT 3
31680: PUSH
31681: EMPTY
31682: LIST
31683: LIST
31684: PUSH
31685: EMPTY
31686: LIST
31687: LIST
31688: LIST
31689: LIST
31690: PPUSH
31691: CALL_OW 69
31695: PUSH
31696: LD_EXP 69
31700: DIFF
31701: ST_TO_ADDR
// for i in tmp do
31702: LD_ADDR_VAR 0 1
31706: PUSH
31707: LD_VAR 0 3
31711: PUSH
31712: FOR_IN
31713: IFFALSE 31763
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
31715: LD_ADDR_EXP 77
31719: PUSH
31720: LD_EXP 77
31724: PPUSH
31725: LD_VAR 0 1
31729: PPUSH
31730: CALL 108004 0 2
31734: ST_TO_ADDR
// j := j - 1 ;
31735: LD_ADDR_VAR 0 2
31739: PUSH
31740: LD_VAR 0 2
31744: PUSH
31745: LD_INT 1
31747: MINUS
31748: ST_TO_ADDR
// if j = 0 then
31749: LD_VAR 0 2
31753: PUSH
31754: LD_INT 0
31756: EQUAL
31757: IFFALSE 31761
// break ;
31759: GO 31763
// end ;
31761: GO 31712
31763: POP
31764: POP
// BuildBehemoths ;
31765: CALL 8368 0 0
// repeat wait ( 15 15$00 ) ;
31769: LD_INT 31500
31771: PPUSH
31772: CALL_OW 67
// if behemothDestroyedBeforeFinish then
31776: LD_EXP 27
31780: IFFALSE 31784
// break ;
31782: GO 31816
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
31784: LD_INT 267
31786: PPUSH
31787: CALL_OW 274
31791: PPUSH
31792: LD_INT 1
31794: PPUSH
31795: CALL_OW 275
31799: PUSH
31800: LD_INT 1000
31802: GREATEREQUAL
31803: IFFALSE 31809
// BuildBehemoths ;
31805: CALL 8368 0 0
// until not behemothBuilders ;
31809: LD_EXP 77
31813: NOT
31814: IFFALSE 31769
// end ;
31816: PPOPN 3
31818: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
31819: LD_EXP 77
31823: NOT
31824: PUSH
31825: LD_EXP 28
31829: NOT
31830: AND
31831: PUSH
31832: LD_EXP 25
31836: AND
31837: IFFALSE 31857
31839: GO 31841
31841: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
31842: LD_STRING M4a
31844: PPUSH
31845: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
31849: LD_ADDR_EXP 27
31853: PUSH
31854: LD_INT 1
31856: ST_TO_ADDR
// end ;
31857: END
// every 0 0$1 trigger behemothDone do
31858: LD_EXP 28
31862: IFFALSE 31874
31864: GO 31866
31866: DISABLE
// ChangeMissionObjectives ( M4b ) ;
31867: LD_STRING M4b
31869: PPUSH
31870: CALL_OW 337
31874: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
31875: LD_EXP 29
31879: NOT
31880: IFFALSE 32076
31882: GO 31884
31884: DISABLE
31885: LD_INT 0
31887: PPUSH
31888: PPUSH
// begin enable ;
31889: ENABLE
// tmp := GetBehemoths ( 3 ) ;
31890: LD_ADDR_VAR 0 1
31894: PUSH
31895: LD_INT 3
31897: PPUSH
31898: CALL 108065 0 1
31902: ST_TO_ADDR
// if not tmp and not behemothDone then
31903: LD_VAR 0 1
31907: NOT
31908: PUSH
31909: LD_EXP 28
31913: NOT
31914: AND
31915: IFFALSE 31951
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
31917: LD_ADDR_VAR 0 1
31921: PUSH
31922: LD_INT 22
31924: PUSH
31925: LD_INT 3
31927: PUSH
31928: EMPTY
31929: LIST
31930: LIST
31931: PUSH
31932: LD_INT 30
31934: PUSH
31935: LD_INT 37
31937: PUSH
31938: EMPTY
31939: LIST
31940: LIST
31941: PUSH
31942: EMPTY
31943: LIST
31944: LIST
31945: PPUSH
31946: CALL_OW 69
31950: ST_TO_ADDR
// if not tmp then
31951: LD_VAR 0 1
31955: NOT
31956: IFFALSE 31960
// exit ;
31958: GO 32076
// for i in tmp do
31960: LD_ADDR_VAR 0 2
31964: PUSH
31965: LD_VAR 0 1
31969: PUSH
31970: FOR_IN
31971: IFFALSE 32074
// if See ( 1 , i ) then
31973: LD_INT 1
31975: PPUSH
31976: LD_VAR 0 2
31980: PPUSH
31981: CALL_OW 292
31985: IFFALSE 32072
// begin if GetType ( i ) = unit_building then
31987: LD_VAR 0 2
31991: PPUSH
31992: CALL_OW 247
31996: PUSH
31997: LD_INT 3
31999: EQUAL
32000: IFFALSE 32038
// begin disable ;
32002: DISABLE
// CenterNowOnUnits ( i ) ;
32003: LD_VAR 0 2
32007: PPUSH
32008: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
32012: LD_EXP 40
32016: PPUSH
32017: LD_STRING D17a-JMM-1
32019: PPUSH
32020: CALL_OW 88
// seeBehemoth := true ;
32024: LD_ADDR_EXP 29
32028: PUSH
32029: LD_INT 1
32031: ST_TO_ADDR
// exit ;
32032: POP
32033: POP
32034: GO 32076
// end else
32036: GO 32072
// begin disable ;
32038: DISABLE
// CenterNowOnUnits ( i ) ;
32039: LD_VAR 0 2
32043: PPUSH
32044: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
32048: LD_EXP 40
32052: PPUSH
32053: LD_STRING D17b-JMM-1
32055: PPUSH
32056: CALL_OW 88
// seeBehemoth := true ;
32060: LD_ADDR_EXP 29
32064: PUSH
32065: LD_INT 1
32067: ST_TO_ADDR
// exit ;
32068: POP
32069: POP
32070: GO 32076
// end ; end ;
32072: GO 31970
32074: POP
32075: POP
// end ;
32076: PPOPN 2
32078: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
32079: LD_EXP 14
32083: PUSH
32084: LD_INT 123200
32086: GREATEREQUAL
32087: IFFALSE 33287
32089: GO 32091
32091: DISABLE
32092: LD_INT 0
32094: PPUSH
32095: PPUSH
32096: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
32097: LD_INT 2
32099: PPUSH
32100: LD_INT 23
32102: PUSH
32103: LD_INT 3
32105: PUSH
32106: LD_INT 3
32108: PUSH
32109: LD_INT 48
32111: PUSH
32112: EMPTY
32113: LIST
32114: LIST
32115: LIST
32116: LIST
32117: PUSH
32118: EMPTY
32119: LIST
32120: PPUSH
32121: CALL 63846 0 2
// repeat wait ( 0 0$1 ) ;
32125: LD_INT 35
32127: PPUSH
32128: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
32132: LD_INT 22
32134: PUSH
32135: LD_INT 3
32137: PUSH
32138: EMPTY
32139: LIST
32140: LIST
32141: PUSH
32142: LD_INT 34
32144: PUSH
32145: LD_INT 48
32147: PUSH
32148: EMPTY
32149: LIST
32150: LIST
32151: PUSH
32152: EMPTY
32153: LIST
32154: LIST
32155: PPUSH
32156: CALL_OW 69
32160: IFFALSE 32125
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
32162: LD_ADDR_VAR 0 1
32166: PUSH
32167: LD_INT 22
32169: PUSH
32170: LD_INT 3
32172: PUSH
32173: EMPTY
32174: LIST
32175: LIST
32176: PUSH
32177: LD_INT 34
32179: PUSH
32180: LD_INT 48
32182: PUSH
32183: EMPTY
32184: LIST
32185: LIST
32186: PUSH
32187: EMPTY
32188: LIST
32189: LIST
32190: PPUSH
32191: CALL_OW 69
32195: PUSH
32196: LD_INT 1
32198: ARRAY
32199: ST_TO_ADDR
// missionStage := 12 ;
32200: LD_ADDR_EXP 15
32204: PUSH
32205: LD_INT 12
32207: ST_TO_ADDR
// platonovHasBomb := true ;
32208: LD_ADDR_EXP 30
32212: PUSH
32213: LD_INT 1
32215: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
32216: LD_VAR 0 1
32220: PPUSH
32221: LD_INT 181
32223: PPUSH
32224: LD_INT 86
32226: PPUSH
32227: CALL_OW 171
// AddComHold ( bomb ) ;
32231: LD_VAR 0 1
32235: PPUSH
32236: CALL_OW 200
// wait ( 0 0$10 ) ;
32240: LD_INT 350
32242: PPUSH
32243: CALL_OW 67
// DialogueOn ;
32247: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
32251: LD_EXP 68
32255: PPUSH
32256: LD_STRING D15-Pla-1
32258: PPUSH
32259: CALL_OW 94
// dec := Query ( Q15a ) ;
32263: LD_ADDR_VAR 0 2
32267: PUSH
32268: LD_STRING Q15a
32270: PPUSH
32271: CALL_OW 97
32275: ST_TO_ADDR
// if dec = 1 then
32276: LD_VAR 0 2
32280: PUSH
32281: LD_INT 1
32283: EQUAL
32284: IFFALSE 32307
// begin Say ( JMM , D15a-JMM-1 ) ;
32286: LD_EXP 40
32290: PPUSH
32291: LD_STRING D15a-JMM-1
32293: PPUSH
32294: CALL_OW 88
// YouLost ( Surrender ) ;
32298: LD_STRING Surrender
32300: PPUSH
32301: CALL_OW 104
// exit ;
32305: GO 33287
// end ; if dec = 2 then
32307: LD_VAR 0 2
32311: PUSH
32312: LD_INT 2
32314: EQUAL
32315: IFFALSE 32384
// begin Say ( JMM , D15b-JMM-1 ) ;
32317: LD_EXP 40
32321: PPUSH
32322: LD_STRING D15b-JMM-1
32324: PPUSH
32325: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
32329: LD_EXP 68
32333: PPUSH
32334: LD_STRING D15b-Pla-1
32336: PPUSH
32337: CALL_OW 94
// DialogueOff ;
32341: CALL_OW 7
// wait ( 3 3$00 ) ;
32345: LD_INT 6300
32347: PPUSH
32348: CALL_OW 67
// DialogueOn ;
32352: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
32356: LD_EXP 40
32360: PPUSH
32361: LD_STRING D15d-JMM-1a
32363: PPUSH
32364: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
32368: LD_EXP 68
32372: PPUSH
32373: LD_STRING D15d-Pla-1
32375: PPUSH
32376: CALL_OW 94
// DialogueOff ;
32380: CALL_OW 7
// end ; if dec = 3 then
32384: LD_VAR 0 2
32388: PUSH
32389: LD_INT 3
32391: EQUAL
32392: IFFALSE 32446
// begin Say ( JMM , D15c-JMM-1 ) ;
32394: LD_EXP 40
32398: PPUSH
32399: LD_STRING D15c-JMM-1
32401: PPUSH
32402: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
32406: LD_EXP 68
32410: PPUSH
32411: LD_STRING D15c-Pla-1
32413: PPUSH
32414: CALL_OW 94
// DialogueOff ;
32418: CALL_OW 7
// wait ( 0 0$15 ) ;
32422: LD_INT 525
32424: PPUSH
32425: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
32429: LD_VAR 0 1
32433: PPUSH
32434: LD_INT 60
32436: PPUSH
32437: LD_INT 95
32439: PPUSH
32440: CALL_OW 116
// exit ;
32444: GO 33287
// end ; if dec = 4 then
32446: LD_VAR 0 2
32450: PUSH
32451: LD_INT 4
32453: EQUAL
32454: IFFALSE 32484
// begin Say ( JMM , D15d-JMM-1 ) ;
32456: LD_EXP 40
32460: PPUSH
32461: LD_STRING D15d-JMM-1
32463: PPUSH
32464: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
32468: LD_EXP 68
32472: PPUSH
32473: LD_STRING D15d-Pla-1
32475: PPUSH
32476: CALL_OW 94
// DialogueOff ;
32480: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32484: LD_EXP 66
32488: PPUSH
32489: CALL_OW 302
32493: PUSH
32494: LD_EXP 66
32498: PPUSH
32499: CALL_OW 255
32503: PUSH
32504: LD_INT 1
32506: EQUAL
32507: AND
32508: PUSH
32509: LD_INT 22
32511: PUSH
32512: LD_INT 1
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PUSH
32519: LD_INT 34
32521: PUSH
32522: LD_INT 8
32524: PUSH
32525: EMPTY
32526: LIST
32527: LIST
32528: PUSH
32529: EMPTY
32530: LIST
32531: LIST
32532: PPUSH
32533: CALL_OW 69
32537: NOT
32538: AND
32539: IFFALSE 33188
// begin SetSide ( Friend , 8 ) ;
32541: LD_EXP 66
32545: PPUSH
32546: LD_INT 8
32548: PPUSH
32549: CALL_OW 235
// if IsInUnit ( Friend ) then
32553: LD_EXP 66
32557: PPUSH
32558: CALL_OW 310
32562: IFFALSE 32573
// ComExitBuilding ( Friend ) ;
32564: LD_EXP 66
32568: PPUSH
32569: CALL_OW 122
// if IsDriver ( Friend ) then
32573: LD_EXP 66
32577: PPUSH
32578: CALL 105608 0 1
32582: IFFALSE 32593
// ComExitVehicle ( Friend ) ;
32584: LD_EXP 66
32588: PPUSH
32589: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
32593: LD_EXP 66
32597: PPUSH
32598: LD_INT 9
32600: PPUSH
32601: LD_INT 2
32603: PPUSH
32604: CALL_OW 171
// wait ( 0 0$05 ) ;
32608: LD_INT 175
32610: PPUSH
32611: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
32615: LD_EXP 66
32619: PPUSH
32620: CALL_OW 87
// DialogueOn ;
32624: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
32628: LD_EXP 40
32632: PPUSH
32633: LD_STRING D16-JMM-1
32635: PPUSH
32636: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
32640: LD_EXP 66
32644: PPUSH
32645: LD_STRING D16-Friend-1
32647: PPUSH
32648: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
32652: LD_EXP 40
32656: PPUSH
32657: LD_STRING D16-JMM-2
32659: PPUSH
32660: CALL_OW 88
// DialogueOff ;
32664: CALL_OW 7
// SetSide ( Friend , 1 ) ;
32668: LD_EXP 66
32672: PPUSH
32673: LD_INT 1
32675: PPUSH
32676: CALL_OW 235
// ComHold ( Friend ) ;
32680: LD_EXP 66
32684: PPUSH
32685: CALL_OW 140
// wait ( 0 0$20 ) ;
32689: LD_INT 700
32691: PPUSH
32692: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
32696: LD_EXP 66
32700: PPUSH
32701: LD_INT 9
32703: PPUSH
32704: LD_INT 2
32706: PPUSH
32707: CALL_OW 297
32711: PUSH
32712: LD_INT 30
32714: LESS
32715: IFFALSE 32784
// begin SetSide ( Friend , 8 ) ;
32717: LD_EXP 66
32721: PPUSH
32722: LD_INT 8
32724: PPUSH
32725: CALL_OW 235
// if IsInUnit ( Friend ) then
32729: LD_EXP 66
32733: PPUSH
32734: CALL_OW 310
32738: IFFALSE 32749
// ComExitBuilding ( Friend ) ;
32740: LD_EXP 66
32744: PPUSH
32745: CALL_OW 122
// if IsDriver ( Friend ) then
32749: LD_EXP 66
32753: PPUSH
32754: CALL 105608 0 1
32758: IFFALSE 32769
// ComExitVehicle ( Friend ) ;
32760: LD_EXP 66
32764: PPUSH
32765: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
32769: LD_EXP 66
32773: PPUSH
32774: LD_INT 9
32776: PPUSH
32777: LD_INT 2
32779: PPUSH
32780: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
32784: LD_INT 1050
32786: PPUSH
32787: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32791: LD_INT 22
32793: PUSH
32794: LD_INT 1
32796: PUSH
32797: EMPTY
32798: LIST
32799: LIST
32800: PUSH
32801: LD_INT 34
32803: PUSH
32804: LD_INT 8
32806: PUSH
32807: EMPTY
32808: LIST
32809: LIST
32810: PUSH
32811: EMPTY
32812: LIST
32813: LIST
32814: PPUSH
32815: CALL_OW 69
32819: NOT
32820: IFFALSE 33166
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
32822: LD_ADDR_VAR 0 3
32826: PUSH
32827: LD_INT 22
32829: PUSH
32830: LD_INT 1
32832: PUSH
32833: EMPTY
32834: LIST
32835: LIST
32836: PUSH
32837: LD_INT 26
32839: PUSH
32840: LD_INT 1
32842: PUSH
32843: EMPTY
32844: LIST
32845: LIST
32846: PUSH
32847: LD_INT 3
32849: PUSH
32850: LD_INT 25
32852: PUSH
32853: LD_INT 12
32855: PUSH
32856: EMPTY
32857: LIST
32858: LIST
32859: PUSH
32860: LD_INT 25
32862: PUSH
32863: LD_INT 16
32865: PUSH
32866: EMPTY
32867: LIST
32868: LIST
32869: PUSH
32870: EMPTY
32871: LIST
32872: LIST
32873: LIST
32874: PUSH
32875: EMPTY
32876: LIST
32877: LIST
32878: LIST
32879: PPUSH
32880: CALL_OW 69
32884: PUSH
32885: LD_EXP 40
32889: PUSH
32890: LD_EXP 42
32894: PUSH
32895: LD_EXP 56
32899: PUSH
32900: LD_EXP 43
32904: PUSH
32905: LD_EXP 44
32909: PUSH
32910: LD_EXP 45
32914: PUSH
32915: LD_EXP 46
32919: PUSH
32920: LD_EXP 47
32924: PUSH
32925: LD_EXP 48
32929: PUSH
32930: LD_EXP 49
32934: PUSH
32935: LD_EXP 50
32939: PUSH
32940: LD_EXP 51
32944: PUSH
32945: LD_EXP 52
32949: PUSH
32950: LD_EXP 53
32954: PUSH
32955: LD_EXP 54
32959: PUSH
32960: EMPTY
32961: LIST
32962: LIST
32963: LIST
32964: LIST
32965: LIST
32966: LIST
32967: LIST
32968: LIST
32969: LIST
32970: LIST
32971: LIST
32972: LIST
32973: LIST
32974: LIST
32975: LIST
32976: DIFF
32977: ST_TO_ADDR
// DialogueOn ;
32978: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
32982: LD_EXP 68
32986: PPUSH
32987: LD_STRING D16a-Pla-1
32989: PPUSH
32990: CALL_OW 94
// if Stevens then
32994: LD_EXP 42
32998: IFFALSE 33014
// Say ( Stevens , D16a-Huck-1 ) else
33000: LD_EXP 42
33004: PPUSH
33005: LD_STRING D16a-Huck-1
33007: PPUSH
33008: CALL_OW 88
33012: GO 33056
// if Baker then
33014: LD_EXP 56
33018: IFFALSE 33034
// Say ( Baker , D16a-Huck-1 ) else
33020: LD_EXP 56
33024: PPUSH
33025: LD_STRING D16a-Huck-1
33027: PPUSH
33028: CALL_OW 88
33032: GO 33056
// if tmp then
33034: LD_VAR 0 3
33038: IFFALSE 33056
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
33040: LD_VAR 0 3
33044: PUSH
33045: LD_INT 1
33047: ARRAY
33048: PPUSH
33049: LD_STRING D16a-Sol1-1
33051: PPUSH
33052: CALL_OW 88
// if GetSide ( Friend ) = 8 then
33056: LD_EXP 66
33060: PPUSH
33061: CALL_OW 255
33065: PUSH
33066: LD_INT 8
33068: EQUAL
33069: IFFALSE 33085
// Say ( JMM , D16a-JMM-1 ) else
33071: LD_EXP 40
33075: PPUSH
33076: LD_STRING D16a-JMM-1
33078: PPUSH
33079: CALL_OW 88
33083: GO 33145
// begin Say ( JMM , D16a-JMM-1a ) ;
33085: LD_EXP 40
33089: PPUSH
33090: LD_STRING D16a-JMM-1a
33092: PPUSH
33093: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
33097: LD_EXP 66
33101: PPUSH
33102: LD_STRING D16a-Friend-1
33104: PPUSH
33105: CALL_OW 88
// ComExitBuilding ( Friend ) ;
33109: LD_EXP 66
33113: PPUSH
33114: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
33118: LD_EXP 66
33122: PPUSH
33123: LD_INT 191
33125: PPUSH
33126: LD_INT 103
33128: PPUSH
33129: CALL_OW 171
// SetSide ( Friend , 3 ) ;
33133: LD_EXP 66
33137: PPUSH
33138: LD_INT 3
33140: PPUSH
33141: CALL_OW 235
// end ; DialogueOff ;
33145: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
33149: LD_VAR 0 1
33153: PPUSH
33154: LD_INT 60
33156: PPUSH
33157: LD_INT 95
33159: PPUSH
33160: CALL_OW 116
// end else
33164: GO 33186
// begin DialogueOn ;
33166: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
33170: LD_EXP 68
33174: PPUSH
33175: LD_STRING D16c-Pla-1
33177: PPUSH
33178: CALL_OW 94
// DialogueOff ;
33182: CALL_OW 7
// end ; end else
33186: GO 33287
// begin wait ( 3 3$00 ) ;
33188: LD_INT 6300
33190: PPUSH
33191: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33195: LD_INT 22
33197: PUSH
33198: LD_INT 1
33200: PUSH
33201: EMPTY
33202: LIST
33203: LIST
33204: PUSH
33205: LD_INT 34
33207: PUSH
33208: LD_INT 8
33210: PUSH
33211: EMPTY
33212: LIST
33213: LIST
33214: PUSH
33215: EMPTY
33216: LIST
33217: LIST
33218: PPUSH
33219: CALL_OW 69
33223: NOT
33224: IFFALSE 33267
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
33226: LD_EXP 68
33230: PPUSH
33231: LD_STRING D16b-Pla-1
33233: PPUSH
33234: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
33238: LD_EXP 40
33242: PPUSH
33243: LD_STRING D16b-JMM-1
33245: PPUSH
33246: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
33250: LD_VAR 0 1
33254: PPUSH
33255: LD_INT 60
33257: PPUSH
33258: LD_INT 95
33260: PPUSH
33261: CALL_OW 116
// end else
33265: GO 33287
// begin DialogueOn ;
33267: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
33271: LD_EXP 68
33275: PPUSH
33276: LD_STRING D16c-Pla-1
33278: PPUSH
33279: CALL_OW 94
// DialogueOff ;
33283: CALL_OW 7
// end ; end ; end ;
33287: PPOPN 3
33289: END
// every 0 0$10 trigger ( GetTech ( tech_SibFiss , 1 ) = state_researched or missionTime >= 60 60$00 ) and not allianceDestroyed and IsOk ( Roth ) do var dec ;
33290: LD_INT 25
33292: PPUSH
33293: LD_INT 1
33295: PPUSH
33296: CALL_OW 321
33300: PUSH
33301: LD_INT 2
33303: EQUAL
33304: PUSH
33305: LD_EXP 14
33309: PUSH
33310: LD_INT 126000
33312: GREATEREQUAL
33313: OR
33314: PUSH
33315: LD_EXP 23
33319: NOT
33320: AND
33321: PUSH
33322: LD_EXP 79
33326: PPUSH
33327: CALL_OW 302
33331: AND
33332: IFFALSE 33690
33334: GO 33336
33336: DISABLE
33337: LD_INT 0
33339: PPUSH
// begin missionStage := 11 ;
33340: LD_ADDR_EXP 15
33344: PUSH
33345: LD_INT 11
33347: ST_TO_ADDR
// DialogueOn ;
33348: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
33352: LD_EXP 79
33356: PPUSH
33357: LD_STRING D9-Roth-1
33359: PPUSH
33360: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
33364: LD_EXP 40
33368: PPUSH
33369: LD_STRING D9-JMM-1
33371: PPUSH
33372: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
33376: LD_EXP 79
33380: PPUSH
33381: LD_STRING D9-Roth-2
33383: PPUSH
33384: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
33388: LD_EXP 79
33392: PPUSH
33393: LD_STRING D9-Roth-2a
33395: PPUSH
33396: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
33400: LD_EXP 68
33404: PPUSH
33405: LD_STRING D9-Pla-2
33407: PPUSH
33408: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
33412: LD_EXP 79
33416: PPUSH
33417: LD_STRING D9-Roth-3
33419: PPUSH
33420: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
33424: LD_EXP 68
33428: PPUSH
33429: LD_STRING D9-Pla-3
33431: PPUSH
33432: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
33436: LD_EXP 79
33440: PPUSH
33441: LD_STRING D9-Roth-4
33443: PPUSH
33444: CALL_OW 94
// dec := Query ( Q9 ) ;
33448: LD_ADDR_VAR 0 1
33452: PUSH
33453: LD_STRING Q9
33455: PPUSH
33456: CALL_OW 97
33460: ST_TO_ADDR
// if dec = 1 then
33461: LD_VAR 0 1
33465: PUSH
33466: LD_INT 1
33468: EQUAL
33469: IFFALSE 33483
// SayRadio ( Roth , D9a-Roth-1 ) ;
33471: LD_EXP 79
33475: PPUSH
33476: LD_STRING D9a-Roth-1
33478: PPUSH
33479: CALL_OW 94
// if dec = 2 then
33483: LD_VAR 0 1
33487: PUSH
33488: LD_INT 2
33490: EQUAL
33491: IFFALSE 33517
// begin Say ( JMM , D9b-JMM-1 ) ;
33493: LD_EXP 40
33497: PPUSH
33498: LD_STRING D9b-JMM-1
33500: PPUSH
33501: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
33505: LD_EXP 79
33509: PPUSH
33510: LD_STRING D9b-Roth-1
33512: PPUSH
33513: CALL_OW 94
// end ; if dec = 3 then
33517: LD_VAR 0 1
33521: PUSH
33522: LD_INT 3
33524: EQUAL
33525: IFFALSE 33587
// begin Say ( JMM , D9c-JMM-1 ) ;
33527: LD_EXP 40
33531: PPUSH
33532: LD_STRING D9c-JMM-1
33534: PPUSH
33535: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
33539: LD_EXP 79
33543: PPUSH
33544: LD_STRING D9c-Roth-1
33546: PPUSH
33547: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
33551: LD_EXP 40
33555: PPUSH
33556: LD_STRING D9c-JMM-2
33558: PPUSH
33559: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
33563: LD_EXP 79
33567: PPUSH
33568: LD_STRING D9c-Roth-2
33570: PPUSH
33571: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
33575: LD_EXP 40
33579: PPUSH
33580: LD_STRING D9c-JMM-3
33582: PPUSH
33583: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
33587: LD_EXP 79
33591: PPUSH
33592: LD_STRING D9c-Roth-3
33594: PPUSH
33595: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
33599: LD_EXP 79
33603: PPUSH
33604: LD_STRING D9cont-Roth-1
33606: PPUSH
33607: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
33611: LD_EXP 40
33615: PPUSH
33616: LD_STRING D9cont-JMM-1
33618: PPUSH
33619: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
33623: LD_EXP 79
33627: PPUSH
33628: LD_STRING D9cont-Roth-2
33630: PPUSH
33631: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
33635: LD_EXP 40
33639: PPUSH
33640: LD_STRING D9cont-JMM-2
33642: PPUSH
33643: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
33647: LD_EXP 79
33651: PPUSH
33652: LD_STRING D9cont-Roth-3
33654: PPUSH
33655: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
33659: LD_EXP 40
33663: PPUSH
33664: LD_STRING D9cont-JMM-3
33666: PPUSH
33667: CALL_OW 88
// DialogueOff ;
33671: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
33675: LD_STRING M3
33677: PPUSH
33678: CALL_OW 337
// allianceActive := true ;
33682: LD_ADDR_EXP 31
33686: PUSH
33687: LD_INT 1
33689: ST_TO_ADDR
// end ;
33690: PPOPN 1
33692: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
33693: LD_INT 1
33695: PPUSH
33696: LD_INT 126
33698: PPUSH
33699: CALL_OW 292
33703: PUSH
33704: LD_EXP 68
33708: PPUSH
33709: CALL_OW 310
33713: AND
33714: IFFALSE 33867
33716: GO 33718
33718: DISABLE
33719: LD_INT 0
33721: PPUSH
// begin ComExitBuilding ( Platonov ) ;
33722: LD_EXP 68
33726: PPUSH
33727: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
33731: LD_ADDR_VAR 0 1
33735: PUSH
33736: LD_INT 4
33738: PPUSH
33739: LD_INT 22
33741: PUSH
33742: LD_INT 1
33744: PUSH
33745: EMPTY
33746: LIST
33747: LIST
33748: PPUSH
33749: CALL_OW 70
33753: PPUSH
33754: LD_EXP 68
33758: PPUSH
33759: CALL_OW 74
33763: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
33764: LD_EXP 68
33768: PPUSH
33769: LD_VAR 0 1
33773: PUSH
33774: LD_INT 1
33776: ARRAY
33777: PPUSH
33778: CALL_OW 175
// SayRadio ( Platonov , D18-Pla-1 ) ;
33782: LD_EXP 68
33786: PPUSH
33787: LD_STRING D18-Pla-1
33789: PPUSH
33790: CALL_OW 94
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
33794: LD_INT 22
33796: PUSH
33797: LD_INT 3
33799: PUSH
33800: EMPTY
33801: LIST
33802: LIST
33803: PUSH
33804: LD_INT 34
33806: PUSH
33807: LD_INT 48
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: PPUSH
33818: CALL_OW 69
33822: IFFALSE 33867
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 111 , 97 ) ;
33824: LD_INT 22
33826: PUSH
33827: LD_INT 3
33829: PUSH
33830: EMPTY
33831: LIST
33832: LIST
33833: PUSH
33834: LD_INT 34
33836: PUSH
33837: LD_INT 48
33839: PUSH
33840: EMPTY
33841: LIST
33842: LIST
33843: PUSH
33844: EMPTY
33845: LIST
33846: LIST
33847: PPUSH
33848: CALL_OW 69
33852: PUSH
33853: LD_INT 1
33855: ARRAY
33856: PPUSH
33857: LD_INT 111
33859: PPUSH
33860: LD_INT 97
33862: PPUSH
33863: CALL_OW 116
// end ;
33867: PPOPN 1
33869: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 14 , 13 , 12 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
33870: LD_EXP 68
33874: PPUSH
33875: CALL_OW 301
33879: PUSH
33880: LD_EXP 71
33884: PPUSH
33885: CALL_OW 301
33889: AND
33890: PUSH
33891: LD_INT 22
33893: PUSH
33894: LD_INT 3
33896: PUSH
33897: EMPTY
33898: LIST
33899: LIST
33900: PUSH
33901: LD_INT 21
33903: PUSH
33904: LD_INT 1
33906: PUSH
33907: EMPTY
33908: LIST
33909: LIST
33910: PUSH
33911: LD_INT 50
33913: PUSH
33914: EMPTY
33915: LIST
33916: PUSH
33917: EMPTY
33918: LIST
33919: LIST
33920: LIST
33921: PPUSH
33922: CALL_OW 69
33926: PUSH
33927: LD_INT 14
33929: PUSH
33930: LD_INT 13
33932: PUSH
33933: LD_INT 12
33935: PUSH
33936: LD_INT 10
33938: PUSH
33939: EMPTY
33940: LIST
33941: LIST
33942: LIST
33943: LIST
33944: PUSH
33945: LD_OWVAR 67
33949: ARRAY
33950: LESS
33951: AND
33952: IFFALSE 34751
33954: GO 33956
33956: DISABLE
33957: LD_INT 0
33959: PPUSH
33960: PPUSH
33961: PPUSH
33962: PPUSH
// begin MC_Kill ( 2 ) ;
33963: LD_INT 2
33965: PPUSH
33966: CALL 39821 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
33970: LD_INT 1
33972: PPUSH
33973: LD_INT 3
33975: PPUSH
33976: LD_INT 1
33978: PPUSH
33979: LD_INT 1
33981: PPUSH
33982: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
33986: LD_ADDR_VAR 0 2
33990: PUSH
33991: LD_INT 22
33993: PUSH
33994: LD_INT 3
33996: PUSH
33997: EMPTY
33998: LIST
33999: LIST
34000: PUSH
34001: LD_INT 21
34003: PUSH
34004: LD_INT 1
34006: PUSH
34007: EMPTY
34008: LIST
34009: LIST
34010: PUSH
34011: LD_INT 50
34013: PUSH
34014: EMPTY
34015: LIST
34016: PUSH
34017: LD_INT 26
34019: PUSH
34020: LD_INT 1
34022: PUSH
34023: EMPTY
34024: LIST
34025: LIST
34026: PUSH
34027: EMPTY
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: PPUSH
34033: CALL_OW 69
34037: ST_TO_ADDR
// if not tmp then
34038: LD_VAR 0 2
34042: NOT
34043: IFFALSE 34099
// begin uc_side = 3 ;
34045: LD_ADDR_OWVAR 20
34049: PUSH
34050: LD_INT 3
34052: ST_TO_ADDR
// uc_nation = 3 ;
34053: LD_ADDR_OWVAR 21
34057: PUSH
34058: LD_INT 3
34060: ST_TO_ADDR
// hc_name =  ;
34061: LD_ADDR_OWVAR 26
34065: PUSH
34066: LD_STRING 
34068: ST_TO_ADDR
// hc_gallery =  ;
34069: LD_ADDR_OWVAR 33
34073: PUSH
34074: LD_STRING 
34076: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
34077: LD_INT 1
34079: PPUSH
34080: LD_INT 10
34082: PPUSH
34083: CALL_OW 381
// tmp = CreateHuman ;
34087: LD_ADDR_VAR 0 2
34091: PUSH
34092: CALL_OW 44
34096: ST_TO_ADDR
// end else
34097: GO 34113
// tmp := tmp [ 1 ] ;
34099: LD_ADDR_VAR 0 2
34103: PUSH
34104: LD_VAR 0 2
34108: PUSH
34109: LD_INT 1
34111: ARRAY
34112: ST_TO_ADDR
// DialogueOn ;
34113: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
34117: LD_VAR 0 2
34121: PPUSH
34122: LD_STRING DSurrenderRussians-RSol1-1a
34124: PPUSH
34125: CALL_OW 94
// DialogueOff ;
34129: CALL_OW 7
// russianDestroyed := true ;
34133: LD_ADDR_EXP 21
34137: PUSH
34138: LD_INT 1
34140: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
34141: LD_ADDR_VAR 0 1
34145: PUSH
34146: LD_INT 22
34148: PUSH
34149: LD_INT 6
34151: PUSH
34152: EMPTY
34153: LIST
34154: LIST
34155: PPUSH
34156: CALL_OW 69
34160: PUSH
34161: FOR_IN
34162: IFFALSE 34175
// KillUnit ( i ) ;
34164: LD_VAR 0 1
34168: PPUSH
34169: CALL_OW 66
34173: GO 34161
34175: POP
34176: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
34177: LD_INT 22
34179: PUSH
34180: LD_INT 3
34182: PUSH
34183: EMPTY
34184: LIST
34185: LIST
34186: PUSH
34187: LD_INT 21
34189: PUSH
34190: LD_INT 1
34192: PUSH
34193: EMPTY
34194: LIST
34195: LIST
34196: PUSH
34197: EMPTY
34198: LIST
34199: LIST
34200: PPUSH
34201: CALL_OW 69
34205: PPUSH
34206: CALL_OW 122
// wait ( 0 0$1 ) ;
34210: LD_INT 35
34212: PPUSH
34213: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
34217: LD_INT 22
34219: PUSH
34220: LD_INT 3
34222: PUSH
34223: EMPTY
34224: LIST
34225: LIST
34226: PUSH
34227: LD_INT 21
34229: PUSH
34230: LD_INT 1
34232: PUSH
34233: EMPTY
34234: LIST
34235: LIST
34236: PUSH
34237: EMPTY
34238: LIST
34239: LIST
34240: PPUSH
34241: CALL_OW 69
34245: PPUSH
34246: LD_INT 25
34248: PPUSH
34249: CALL_OW 173
// wait ( 0 0$35 ) ;
34253: LD_INT 1225
34255: PPUSH
34256: CALL_OW 67
// PrepareOmarInvasion ;
34260: CALL 16368 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
34264: LD_ADDR_VAR 0 2
34268: PUSH
34269: LD_EXP 97
34273: PPUSH
34274: CALL_OW 250
34278: PUSH
34279: LD_EXP 97
34283: PPUSH
34284: CALL_OW 251
34288: PUSH
34289: EMPTY
34290: LIST
34291: LIST
34292: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
34293: LD_VAR 0 2
34297: PUSH
34298: LD_INT 1
34300: ARRAY
34301: PPUSH
34302: LD_VAR 0 2
34306: PUSH
34307: LD_INT 2
34309: ARRAY
34310: PPUSH
34311: LD_INT 1
34313: PPUSH
34314: LD_INT 8
34316: NEG
34317: PPUSH
34318: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
34322: LD_EXP 97
34326: PPUSH
34327: CALL_OW 87
// DialogueOn ;
34331: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
34335: LD_EXP 40
34339: PPUSH
34340: LD_STRING D19-JMM-1
34342: PPUSH
34343: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Kurt , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
34347: LD_ADDR_VAR 0 3
34351: PUSH
34352: LD_INT 22
34354: PUSH
34355: LD_INT 1
34357: PUSH
34358: EMPTY
34359: LIST
34360: LIST
34361: PUSH
34362: LD_INT 26
34364: PUSH
34365: LD_INT 1
34367: PUSH
34368: EMPTY
34369: LIST
34370: LIST
34371: PUSH
34372: LD_INT 2
34374: PUSH
34375: LD_INT 25
34377: PUSH
34378: LD_INT 1
34380: PUSH
34381: EMPTY
34382: LIST
34383: LIST
34384: PUSH
34385: LD_INT 25
34387: PUSH
34388: LD_INT 2
34390: PUSH
34391: EMPTY
34392: LIST
34393: LIST
34394: PUSH
34395: LD_INT 25
34397: PUSH
34398: LD_INT 3
34400: PUSH
34401: EMPTY
34402: LIST
34403: LIST
34404: PUSH
34405: LD_INT 25
34407: PUSH
34408: LD_INT 4
34410: PUSH
34411: EMPTY
34412: LIST
34413: LIST
34414: PUSH
34415: LD_INT 25
34417: PUSH
34418: LD_INT 5
34420: PUSH
34421: EMPTY
34422: LIST
34423: LIST
34424: PUSH
34425: LD_INT 25
34427: PUSH
34428: LD_INT 8
34430: PUSH
34431: EMPTY
34432: LIST
34433: LIST
34434: PUSH
34435: EMPTY
34436: LIST
34437: LIST
34438: LIST
34439: LIST
34440: LIST
34441: LIST
34442: LIST
34443: PUSH
34444: EMPTY
34445: LIST
34446: LIST
34447: LIST
34448: PPUSH
34449: CALL_OW 69
34453: PUSH
34454: LD_EXP 40
34458: PUSH
34459: LD_EXP 41
34463: PUSH
34464: LD_EXP 64
34468: PUSH
34469: LD_EXP 42
34473: PUSH
34474: LD_EXP 43
34478: PUSH
34479: LD_EXP 44
34483: PUSH
34484: LD_EXP 45
34488: PUSH
34489: LD_EXP 46
34493: PUSH
34494: LD_EXP 47
34498: PUSH
34499: LD_EXP 48
34503: PUSH
34504: LD_EXP 49
34508: PUSH
34509: LD_EXP 50
34513: PUSH
34514: LD_EXP 51
34518: PUSH
34519: LD_EXP 52
34523: PUSH
34524: LD_EXP 53
34528: PUSH
34529: LD_EXP 54
34533: PUSH
34534: LD_EXP 55
34538: PUSH
34539: LD_EXP 56
34543: PUSH
34544: EMPTY
34545: LIST
34546: LIST
34547: LIST
34548: LIST
34549: LIST
34550: LIST
34551: LIST
34552: LIST
34553: LIST
34554: LIST
34555: LIST
34556: LIST
34557: LIST
34558: LIST
34559: LIST
34560: LIST
34561: LIST
34562: LIST
34563: DIFF
34564: ST_TO_ADDR
// if tmp2 then
34565: LD_VAR 0 3
34569: IFFALSE 34587
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
34571: LD_VAR 0 3
34575: PUSH
34576: LD_INT 1
34578: ARRAY
34579: PPUSH
34580: LD_STRING D19-Sol1-1
34582: PPUSH
34583: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
34587: LD_EXP 40
34591: PPUSH
34592: LD_STRING D19-JMM-2
34594: PPUSH
34595: CALL_OW 88
// DialogueOff ;
34599: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
34603: LD_VAR 0 2
34607: PUSH
34608: LD_INT 1
34610: ARRAY
34611: PPUSH
34612: LD_VAR 0 2
34616: PUSH
34617: LD_INT 2
34619: ARRAY
34620: PPUSH
34621: LD_INT 1
34623: PPUSH
34624: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
34628: LD_STRING M5
34630: PPUSH
34631: CALL_OW 337
// omarOnMotherLode := false ;
34635: LD_ADDR_VAR 0 4
34639: PUSH
34640: LD_INT 0
34642: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
34643: LD_INT 35
34645: PPUSH
34646: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
34650: LD_EXP 97
34654: PPUSH
34655: LD_INT 215
34657: PPUSH
34658: LD_INT 100
34660: PPUSH
34661: CALL_OW 297
34665: PUSH
34666: LD_INT 10
34668: LESS
34669: PUSH
34670: LD_VAR 0 4
34674: NOT
34675: AND
34676: IFFALSE 34710
// begin omarOnMotherLode := true ;
34678: LD_ADDR_VAR 0 4
34682: PUSH
34683: LD_INT 1
34685: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
34686: LD_EXP 40
34690: PPUSH
34691: LD_STRING D19b-JMM-1
34693: PPUSH
34694: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
34698: LD_EXP 97
34702: PPUSH
34703: LD_STRING DOmarContam-Omar-1
34705: PPUSH
34706: CALL_OW 88
// end ; until IsDead ( Omar ) ;
34710: LD_EXP 97
34714: PPUSH
34715: CALL_OW 301
34719: IFFALSE 34643
// Say ( JMM , D19a-JMM-1 ) ;
34721: LD_EXP 40
34725: PPUSH
34726: LD_STRING D19a-JMM-1
34728: PPUSH
34729: CALL_OW 88
// if Heike then
34733: LD_EXP 98
34737: IFFALSE 34751
// Say ( Heike , D19a-Hke-1 ) ;
34739: LD_EXP 98
34743: PPUSH
34744: LD_STRING D19a-Hke-1
34746: PPUSH
34747: CALL_OW 88
// end ;
34751: PPOPN 4
34753: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
34754: LD_INT 22
34756: PUSH
34757: LD_INT 3
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PUSH
34764: LD_INT 21
34766: PUSH
34767: LD_INT 1
34769: PUSH
34770: EMPTY
34771: LIST
34772: LIST
34773: PUSH
34774: EMPTY
34775: LIST
34776: LIST
34777: PPUSH
34778: CALL_OW 69
34782: PUSH
34783: LD_EXP 21
34787: AND
34788: IFFALSE 34856
34790: GO 34792
34792: DISABLE
34793: LD_INT 0
34795: PPUSH
34796: PPUSH
// begin enable ;
34797: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
34798: LD_ADDR_VAR 0 2
34802: PUSH
34803: LD_INT 25
34805: PPUSH
34806: LD_INT 22
34808: PUSH
34809: LD_INT 3
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PPUSH
34816: CALL_OW 70
34820: ST_TO_ADDR
// if not tmp then
34821: LD_VAR 0 2
34825: NOT
34826: IFFALSE 34830
// exit ;
34828: GO 34856
// for i in tmp do
34830: LD_ADDR_VAR 0 1
34834: PUSH
34835: LD_VAR 0 2
34839: PUSH
34840: FOR_IN
34841: IFFALSE 34854
// RemoveUnit ( i ) ;
34843: LD_VAR 0 1
34847: PPUSH
34848: CALL_OW 64
34852: GO 34840
34854: POP
34855: POP
// end ;
34856: PPOPN 2
34858: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
34859: LD_INT 22
34861: PUSH
34862: LD_INT 7
34864: PUSH
34865: EMPTY
34866: LIST
34867: LIST
34868: PUSH
34869: LD_INT 21
34871: PUSH
34872: LD_INT 1
34874: PUSH
34875: EMPTY
34876: LIST
34877: LIST
34878: PUSH
34879: EMPTY
34880: LIST
34881: LIST
34882: PPUSH
34883: CALL_OW 69
34887: PUSH
34888: LD_INT 6
34890: LESS
34891: IFFALSE 35359
34893: GO 34895
34895: DISABLE
34896: LD_INT 0
34898: PPUSH
34899: PPUSH
// begin MC_Kill ( 1 ) ;
34900: LD_INT 1
34902: PPUSH
34903: CALL 39821 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
34907: LD_INT 7
34909: PPUSH
34910: LD_INT 1
34912: PPUSH
34913: LD_INT 1
34915: PPUSH
34916: LD_INT 1
34918: PPUSH
34919: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
34923: LD_ADDR_VAR 0 1
34927: PUSH
34928: LD_INT 22
34930: PUSH
34931: LD_INT 7
34933: PUSH
34934: EMPTY
34935: LIST
34936: LIST
34937: PUSH
34938: LD_INT 26
34940: PUSH
34941: LD_INT 1
34943: PUSH
34944: EMPTY
34945: LIST
34946: LIST
34947: PUSH
34948: EMPTY
34949: LIST
34950: LIST
34951: PPUSH
34952: CALL_OW 69
34956: PUSH
34957: LD_EXP 79
34961: DIFF
34962: ST_TO_ADDR
// if tmp then
34963: LD_VAR 0 1
34967: IFFALSE 34985
// tmp := tmp [ 1 ] else
34969: LD_ADDR_VAR 0 1
34973: PUSH
34974: LD_VAR 0 1
34978: PUSH
34979: LD_INT 1
34981: ARRAY
34982: ST_TO_ADDR
34983: GO 35021
// begin uc_side := 7 ;
34985: LD_ADDR_OWVAR 20
34989: PUSH
34990: LD_INT 7
34992: ST_TO_ADDR
// uc_nation := 1 ;
34993: LD_ADDR_OWVAR 21
34997: PUSH
34998: LD_INT 1
35000: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
35001: LD_INT 1
35003: PPUSH
35004: LD_INT 8
35006: PPUSH
35007: CALL_OW 384
// tmp := CreateHuman ;
35011: LD_ADDR_VAR 0 1
35015: PUSH
35016: CALL_OW 44
35020: ST_TO_ADDR
// end ; DialogueOn ;
35021: CALL_OW 6
// if IsOK ( Roth ) then
35025: LD_EXP 79
35029: PPUSH
35030: CALL_OW 302
35034: IFFALSE 35048
// Say ( JMM , DAb-JMM-1 ) ;
35036: LD_EXP 40
35040: PPUSH
35041: LD_STRING DAb-JMM-1
35043: PPUSH
35044: CALL_OW 88
// if IsOK ( Roth ) then
35048: LD_EXP 79
35052: PPUSH
35053: CALL_OW 302
35057: IFFALSE 35081
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
35059: LD_EXP 79
35063: PPUSH
35064: LD_STRING DSurrenderAlliance-Roth-1
35066: PPUSH
35067: CALL_OW 88
// RothCaptured := true ;
35071: LD_ADDR_EXP 33
35075: PUSH
35076: LD_INT 1
35078: ST_TO_ADDR
// end else
35079: GO 35093
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
35081: LD_VAR 0 1
35085: PPUSH
35086: LD_STRING DSurrenderAlliance-Sci1-1
35088: PPUSH
35089: CALL_OW 88
// DialogueOff ;
35093: CALL_OW 7
// allianceDestroyed := true ;
35097: LD_ADDR_EXP 23
35101: PUSH
35102: LD_INT 1
35104: ST_TO_ADDR
// if capturedUnit = 0 then
35105: LD_EXP 34
35109: PUSH
35110: LD_INT 0
35112: EQUAL
35113: IFFALSE 35122
// SetAchievement ( ACH_ALLIANCE ) ;
35115: LD_STRING ACH_ALLIANCE
35117: PPUSH
35118: CALL_OW 543
// if trueAmericans then
35122: LD_EXP 35
35126: IFFALSE 35202
// begin if trueAmericans = 1 then
35128: LD_EXP 35
35132: PUSH
35133: LD_INT 1
35135: EQUAL
35136: IFFALSE 35152
// Say ( JMM , DAb-JMM-1a ) else
35138: LD_EXP 40
35142: PPUSH
35143: LD_STRING DAb-JMM-1a
35145: PPUSH
35146: CALL_OW 88
35150: GO 35164
// Say ( JMM , DAb-JMM-1b ) ;
35152: LD_EXP 40
35156: PPUSH
35157: LD_STRING DAb-JMM-1b
35159: PPUSH
35160: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
35164: LD_EXP 35
35168: PPUSH
35169: CALL_OW 87
// for i in trueAmericans do
35173: LD_ADDR_VAR 0 2
35177: PUSH
35178: LD_EXP 35
35182: PUSH
35183: FOR_IN
35184: IFFALSE 35200
// SetSide ( i , 1 ) ;
35186: LD_VAR 0 2
35190: PPUSH
35191: LD_INT 1
35193: PPUSH
35194: CALL_OW 235
35198: GO 35183
35200: POP
35201: POP
// end ; repeat wait ( 0 0$1 ) ;
35202: LD_INT 35
35204: PPUSH
35205: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
35209: LD_ADDR_VAR 0 2
35213: PUSH
35214: LD_INT 22
35216: PUSH
35217: LD_INT 7
35219: PUSH
35220: EMPTY
35221: LIST
35222: LIST
35223: PUSH
35224: LD_INT 21
35226: PUSH
35227: LD_INT 1
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: PUSH
35234: EMPTY
35235: LIST
35236: LIST
35237: PPUSH
35238: CALL_OW 69
35242: PUSH
35243: FOR_IN
35244: IFFALSE 35326
// begin if IsInUnit ( i ) then
35246: LD_VAR 0 2
35250: PPUSH
35251: CALL_OW 310
35255: IFFALSE 35266
// ComExitBuilding ( i ) ;
35257: LD_VAR 0 2
35261: PPUSH
35262: CALL_OW 122
// if IsDriver ( i ) then
35266: LD_VAR 0 2
35270: PPUSH
35271: CALL 105608 0 1
35275: IFFALSE 35286
// ComExitVehicle ( i ) ;
35277: LD_VAR 0 2
35281: PPUSH
35282: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
35286: LD_VAR 0 2
35290: PPUSH
35291: LD_INT 26
35293: PPUSH
35294: CALL_OW 308
35298: NOT
35299: IFFALSE 35315
// AddComMoveToArea ( i , allianceEscapeArea ) else
35301: LD_VAR 0 2
35305: PPUSH
35306: LD_INT 26
35308: PPUSH
35309: CALL_OW 173
35313: GO 35324
// RemoveUnit ( i ) ;
35315: LD_VAR 0 2
35319: PPUSH
35320: CALL_OW 64
// end ;
35324: GO 35243
35326: POP
35327: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
35328: LD_INT 22
35330: PUSH
35331: LD_INT 7
35333: PUSH
35334: EMPTY
35335: LIST
35336: LIST
35337: PUSH
35338: LD_INT 21
35340: PUSH
35341: LD_INT 1
35343: PUSH
35344: EMPTY
35345: LIST
35346: LIST
35347: PUSH
35348: EMPTY
35349: LIST
35350: LIST
35351: PPUSH
35352: CALL_OW 69
35356: NOT
35357: IFFALSE 35202
// end ;
35359: PPOPN 2
35361: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
35362: LD_INT 0
35364: PPUSH
35365: PPUSH
// if not unit then
35366: LD_VAR 0 1
35370: NOT
35371: IFFALSE 35375
// exit ;
35373: GO 36889
// DoNotAttack ( 7 , unit ) ;
35375: LD_INT 7
35377: PPUSH
35378: LD_VAR 0 1
35382: PPUSH
35383: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
35387: LD_VAR 0 1
35391: PPUSH
35392: LD_INT 260
35394: PPUSH
35395: LD_INT 235
35397: PPUSH
35398: LD_INT 3
35400: PPUSH
35401: LD_INT 1
35403: PPUSH
35404: CALL_OW 483
// SetSide ( unit , 4 ) ;
35408: LD_VAR 0 1
35412: PPUSH
35413: LD_INT 4
35415: PPUSH
35416: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
35420: LD_ADDR_EXP 34
35424: PUSH
35425: LD_EXP 34
35429: PUSH
35430: LD_INT 1
35432: PLUS
35433: ST_TO_ADDR
// wait ( 0 0$2 ) ;
35434: LD_INT 70
35436: PPUSH
35437: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
35441: LD_INT 260
35443: PPUSH
35444: LD_INT 235
35446: PPUSH
35447: LD_INT 1
35449: PPUSH
35450: LD_INT 8
35452: NEG
35453: PPUSH
35454: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
35458: LD_VAR 0 1
35462: PPUSH
35463: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
35467: LD_VAR 0 1
35471: PPUSH
35472: LD_EXP 79
35476: PPUSH
35477: CALL_OW 119
// DialogueOn ;
35481: CALL_OW 6
// case unit of JMM :
35485: LD_VAR 0 1
35489: PUSH
35490: LD_EXP 40
35494: DOUBLE
35495: EQUAL
35496: IFTRUE 35500
35498: GO 35515
35500: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
35501: LD_EXP 40
35505: PPUSH
35506: LD_STRING DA1-JMM-1
35508: PPUSH
35509: CALL_OW 91
35513: GO 35957
35515: LD_EXP 41
35519: DOUBLE
35520: EQUAL
35521: IFTRUE 35525
35523: GO 35540
35525: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
35526: LD_EXP 41
35530: PPUSH
35531: LD_STRING DA1-Joan-1
35533: PPUSH
35534: CALL_OW 91
35538: GO 35957
35540: LD_EXP 43
35544: DOUBLE
35545: EQUAL
35546: IFTRUE 35550
35548: GO 35565
35550: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
35551: LD_EXP 43
35555: PPUSH
35556: LD_STRING DA1-Lisa-1
35558: PPUSH
35559: CALL_OW 91
35563: GO 35957
35565: LD_EXP 44
35569: DOUBLE
35570: EQUAL
35571: IFTRUE 35575
35573: GO 35590
35575: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
35576: LD_EXP 44
35580: PPUSH
35581: LD_STRING DA1-Don-1
35583: PPUSH
35584: CALL_OW 91
35588: GO 35957
35590: LD_EXP 51
35594: DOUBLE
35595: EQUAL
35596: IFTRUE 35600
35598: GO 35615
35600: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
35601: LD_EXP 51
35605: PPUSH
35606: LD_STRING DA1-Corn-1
35608: PPUSH
35609: CALL_OW 91
35613: GO 35957
35615: LD_EXP 47
35619: DOUBLE
35620: EQUAL
35621: IFTRUE 35625
35623: GO 35640
35625: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
35626: LD_EXP 47
35630: PPUSH
35631: LD_STRING DA1-Den-1
35633: PPUSH
35634: CALL_OW 91
35638: GO 35957
35640: LD_EXP 45
35644: DOUBLE
35645: EQUAL
35646: IFTRUE 35650
35648: GO 35665
35650: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
35651: LD_EXP 45
35655: PPUSH
35656: LD_STRING DA1-Bobby-1
35658: PPUSH
35659: CALL_OW 91
35663: GO 35957
35665: LD_EXP 49
35669: DOUBLE
35670: EQUAL
35671: IFTRUE 35675
35673: GO 35690
35675: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
35676: LD_EXP 49
35680: PPUSH
35681: LD_STRING DA1-Glad-1
35683: PPUSH
35684: CALL_OW 91
35688: GO 35957
35690: LD_EXP 46
35694: DOUBLE
35695: EQUAL
35696: IFTRUE 35700
35698: GO 35715
35700: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
35701: LD_EXP 46
35705: PPUSH
35706: LD_STRING DA1-Cyrus-1
35708: PPUSH
35709: CALL_OW 91
35713: GO 35957
35715: LD_EXP 42
35719: DOUBLE
35720: EQUAL
35721: IFTRUE 35725
35723: GO 35740
35725: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
35726: LD_EXP 42
35730: PPUSH
35731: LD_STRING DA1-Huck-1
35733: PPUSH
35734: CALL_OW 91
35738: GO 35957
35740: LD_EXP 56
35744: DOUBLE
35745: EQUAL
35746: IFTRUE 35750
35748: GO 35765
35750: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
35751: LD_EXP 56
35755: PPUSH
35756: LD_STRING DA1-Huck-1
35758: PPUSH
35759: CALL_OW 91
35763: GO 35957
35765: LD_EXP 48
35769: DOUBLE
35770: EQUAL
35771: IFTRUE 35775
35773: GO 35790
35775: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
35776: LD_EXP 48
35780: PPUSH
35781: LD_STRING DA1-Brown-1
35783: PPUSH
35784: CALL_OW 91
35788: GO 35957
35790: LD_EXP 52
35794: DOUBLE
35795: EQUAL
35796: IFTRUE 35800
35798: GO 35815
35800: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
35801: LD_EXP 52
35805: PPUSH
35806: LD_STRING DA1-Gary-1
35808: PPUSH
35809: CALL_OW 91
35813: GO 35957
35815: LD_EXP 55
35819: DOUBLE
35820: EQUAL
35821: IFTRUE 35825
35823: GO 35840
35825: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
35826: LD_EXP 55
35830: PPUSH
35831: LD_STRING DA1-Con-1
35833: PPUSH
35834: CALL_OW 91
35838: GO 35957
35840: LD_EXP 64
35844: DOUBLE
35845: EQUAL
35846: IFTRUE 35850
35848: GO 35865
35850: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
35851: LD_EXP 64
35855: PPUSH
35856: LD_STRING DA1-Kurt-1
35858: PPUSH
35859: CALL_OW 91
35863: GO 35957
35865: LD_EXP 54
35869: DOUBLE
35870: EQUAL
35871: IFTRUE 35875
35873: GO 35890
35875: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
35876: LD_EXP 54
35880: PPUSH
35881: LD_STRING DA1-Yam-1
35883: PPUSH
35884: CALL_OW 91
35888: GO 35957
35890: LD_EXP 53
35894: DOUBLE
35895: EQUAL
35896: IFTRUE 35900
35898: GO 35915
35900: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
35901: LD_EXP 53
35905: PPUSH
35906: LD_STRING DA1-Frank-1
35908: PPUSH
35909: CALL_OW 91
35913: GO 35957
35915: POP
// begin if GetSex ( unit ) = sex_male then
35916: LD_VAR 0 1
35920: PPUSH
35921: CALL_OW 258
35925: PUSH
35926: LD_INT 1
35928: EQUAL
35929: IFFALSE 35945
// ForceSay ( unit , DA1-Sol1-1 ) else
35931: LD_VAR 0 1
35935: PPUSH
35936: LD_STRING DA1-Sol1-1
35938: PPUSH
35939: CALL_OW 91
35943: GO 35957
// ForceSay ( unit , DA1-FSol1-1 ) ;
35945: LD_VAR 0 1
35949: PPUSH
35950: LD_STRING DA1-FSol1-1
35952: PPUSH
35953: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
35957: LD_EXP 79
35961: PPUSH
35962: LD_STRING DA-Roth-1
35964: PPUSH
35965: CALL_OW 88
// if capturedUnit = 1 then
35969: LD_EXP 34
35973: PUSH
35974: LD_INT 1
35976: EQUAL
35977: IFFALSE 36005
// begin Say ( Simms , DA-Sim-1 ) ;
35979: LD_EXP 80
35983: PPUSH
35984: LD_STRING DA-Sim-1
35986: PPUSH
35987: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
35991: LD_EXP 79
35995: PPUSH
35996: LD_STRING DA-Roth-2
35998: PPUSH
35999: CALL_OW 88
// end else
36003: GO 36017
// Say ( Simms , DA-Sim-2 ) ;
36005: LD_EXP 80
36009: PPUSH
36010: LD_STRING DA-Sim-2
36012: PPUSH
36013: CALL_OW 88
// case unit of JMM :
36017: LD_VAR 0 1
36021: PUSH
36022: LD_EXP 40
36026: DOUBLE
36027: EQUAL
36028: IFTRUE 36032
36030: GO 36047
36032: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
36033: LD_EXP 40
36037: PPUSH
36038: LD_STRING DA1-JMM-1a
36040: PPUSH
36041: CALL_OW 91
36045: GO 36564
36047: LD_EXP 41
36051: DOUBLE
36052: EQUAL
36053: IFTRUE 36057
36055: GO 36072
36057: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
36058: LD_EXP 41
36062: PPUSH
36063: LD_STRING DA1-Joan-1a
36065: PPUSH
36066: CALL_OW 91
36070: GO 36564
36072: LD_EXP 43
36076: DOUBLE
36077: EQUAL
36078: IFTRUE 36082
36080: GO 36097
36082: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
36083: LD_EXP 43
36087: PPUSH
36088: LD_STRING DA1-Lisa-1a
36090: PPUSH
36091: CALL_OW 91
36095: GO 36564
36097: LD_EXP 44
36101: DOUBLE
36102: EQUAL
36103: IFTRUE 36107
36105: GO 36122
36107: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
36108: LD_EXP 44
36112: PPUSH
36113: LD_STRING DA1-Don-1a
36115: PPUSH
36116: CALL_OW 91
36120: GO 36564
36122: LD_EXP 51
36126: DOUBLE
36127: EQUAL
36128: IFTRUE 36132
36130: GO 36147
36132: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
36133: LD_EXP 51
36137: PPUSH
36138: LD_STRING DA1-Corn-1a
36140: PPUSH
36141: CALL_OW 91
36145: GO 36564
36147: LD_EXP 47
36151: DOUBLE
36152: EQUAL
36153: IFTRUE 36157
36155: GO 36172
36157: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
36158: LD_EXP 47
36162: PPUSH
36163: LD_STRING DA1-Den-1a
36165: PPUSH
36166: CALL_OW 91
36170: GO 36564
36172: LD_EXP 45
36176: DOUBLE
36177: EQUAL
36178: IFTRUE 36182
36180: GO 36197
36182: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
36183: LD_EXP 45
36187: PPUSH
36188: LD_STRING DA1-Bobby-1a
36190: PPUSH
36191: CALL_OW 91
36195: GO 36564
36197: LD_EXP 49
36201: DOUBLE
36202: EQUAL
36203: IFTRUE 36207
36205: GO 36222
36207: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
36208: LD_EXP 49
36212: PPUSH
36213: LD_STRING DA1-Glad-1a
36215: PPUSH
36216: CALL_OW 91
36220: GO 36564
36222: LD_EXP 46
36226: DOUBLE
36227: EQUAL
36228: IFTRUE 36232
36230: GO 36247
36232: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
36233: LD_EXP 46
36237: PPUSH
36238: LD_STRING DA1-Cyrus-1a
36240: PPUSH
36241: CALL_OW 91
36245: GO 36564
36247: LD_EXP 42
36251: DOUBLE
36252: EQUAL
36253: IFTRUE 36257
36255: GO 36272
36257: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
36258: LD_EXP 42
36262: PPUSH
36263: LD_STRING DA1-Huck-1a
36265: PPUSH
36266: CALL_OW 91
36270: GO 36564
36272: LD_EXP 56
36276: DOUBLE
36277: EQUAL
36278: IFTRUE 36282
36280: GO 36297
36282: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
36283: LD_EXP 56
36287: PPUSH
36288: LD_STRING DA1-Huck-1a
36290: PPUSH
36291: CALL_OW 91
36295: GO 36564
36297: LD_EXP 48
36301: DOUBLE
36302: EQUAL
36303: IFTRUE 36307
36305: GO 36322
36307: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
36308: LD_EXP 48
36312: PPUSH
36313: LD_STRING DA1-Brown-1a
36315: PPUSH
36316: CALL_OW 91
36320: GO 36564
36322: LD_EXP 52
36326: DOUBLE
36327: EQUAL
36328: IFTRUE 36332
36330: GO 36347
36332: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
36333: LD_EXP 52
36337: PPUSH
36338: LD_STRING DA1-Gary-1a
36340: PPUSH
36341: CALL_OW 91
36345: GO 36564
36347: LD_EXP 55
36351: DOUBLE
36352: EQUAL
36353: IFTRUE 36357
36355: GO 36382
36357: POP
// if JMMGirl = 3 then
36358: LD_EXP 7
36362: PUSH
36363: LD_INT 3
36365: EQUAL
36366: IFFALSE 36380
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
36368: LD_EXP 55
36372: PPUSH
36373: LD_STRING DA1-Con-1a
36375: PPUSH
36376: CALL_OW 91
36380: GO 36564
36382: LD_EXP 64
36386: DOUBLE
36387: EQUAL
36388: IFTRUE 36392
36390: GO 36407
36392: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
36393: LD_EXP 64
36397: PPUSH
36398: LD_STRING DA1-Kurt-1a
36400: PPUSH
36401: CALL_OW 91
36405: GO 36564
36407: LD_EXP 54
36411: DOUBLE
36412: EQUAL
36413: IFTRUE 36417
36415: GO 36432
36417: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
36418: LD_EXP 54
36422: PPUSH
36423: LD_STRING DA1-Yam-1a
36425: PPUSH
36426: CALL_OW 91
36430: GO 36564
36432: LD_EXP 53
36436: DOUBLE
36437: EQUAL
36438: IFTRUE 36442
36440: GO 36457
36442: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
36443: LD_EXP 53
36447: PPUSH
36448: LD_STRING DA1-Frank-1a
36450: PPUSH
36451: CALL_OW 91
36455: GO 36564
36457: POP
// begin join := rand ( 0 , 1 ) ;
36458: LD_ADDR_VAR 0 3
36462: PUSH
36463: LD_INT 0
36465: PPUSH
36466: LD_INT 1
36468: PPUSH
36469: CALL_OW 12
36473: ST_TO_ADDR
// if join then
36474: LD_VAR 0 3
36478: IFFALSE 36523
// begin if GetSex ( unit ) = sex_male then
36480: LD_VAR 0 1
36484: PPUSH
36485: CALL_OW 258
36489: PUSH
36490: LD_INT 1
36492: EQUAL
36493: IFFALSE 36509
// ForceSay ( unit , DA1-Sol1-1b ) else
36495: LD_VAR 0 1
36499: PPUSH
36500: LD_STRING DA1-Sol1-1b
36502: PPUSH
36503: CALL_OW 91
36507: GO 36521
// ForceSay ( unit , DA1-FSol1-1b ) ;
36509: LD_VAR 0 1
36513: PPUSH
36514: LD_STRING DA1-FSol1-1b
36516: PPUSH
36517: CALL_OW 91
// end else
36521: GO 36564
// begin if GetSex ( unit ) = sex_male then
36523: LD_VAR 0 1
36527: PPUSH
36528: CALL_OW 258
36532: PUSH
36533: LD_INT 1
36535: EQUAL
36536: IFFALSE 36552
// ForceSay ( unit , DA1-Sol1-1a ) else
36538: LD_VAR 0 1
36542: PPUSH
36543: LD_STRING DA1-Sol1-1a
36545: PPUSH
36546: CALL_OW 91
36550: GO 36564
// ForceSay ( unit , DA1-FSol1-1a ) ;
36552: LD_VAR 0 1
36556: PPUSH
36557: LD_STRING DA1-FSol1-1a
36559: PPUSH
36560: CALL_OW 91
// end ; end ; end ; if unit = JMM then
36564: LD_VAR 0 1
36568: PUSH
36569: LD_EXP 40
36573: EQUAL
36574: IFFALSE 36585
// begin YouLost ( JMMCaptured ) ;
36576: LD_STRING JMMCaptured
36578: PPUSH
36579: CALL_OW 104
// exit ;
36583: GO 36889
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi , DeltaDoctor ] or join then
36585: LD_VAR 0 1
36589: PUSH
36590: LD_EXP 44
36594: PUSH
36595: LD_EXP 47
36599: PUSH
36600: LD_EXP 45
36604: PUSH
36605: LD_EXP 42
36609: PUSH
36610: LD_EXP 56
36614: PUSH
36615: LD_EXP 48
36619: PUSH
36620: LD_EXP 54
36624: PUSH
36625: LD_EXP 58
36629: PUSH
36630: EMPTY
36631: LIST
36632: LIST
36633: LIST
36634: LIST
36635: LIST
36636: LIST
36637: LIST
36638: LIST
36639: IN
36640: PUSH
36641: LD_VAR 0 3
36645: OR
36646: IFFALSE 36745
// begin Say ( Roth , DA-Roth-3 ) ;
36648: LD_EXP 79
36652: PPUSH
36653: LD_STRING DA-Roth-3
36655: PPUSH
36656: CALL_OW 88
// SetSide ( unit , 7 ) ;
36660: LD_VAR 0 1
36664: PPUSH
36665: LD_INT 7
36667: PPUSH
36668: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
36672: LD_ADDR_EXP 102
36676: PUSH
36677: LD_EXP 102
36681: PPUSH
36682: LD_INT 1
36684: PPUSH
36685: LD_EXP 102
36689: PUSH
36690: LD_INT 1
36692: ARRAY
36693: PUSH
36694: LD_VAR 0 1
36698: ADD
36699: PPUSH
36700: CALL_OW 1
36704: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
36705: LD_INT 260
36707: PPUSH
36708: LD_INT 235
36710: PPUSH
36711: LD_INT 1
36713: PPUSH
36714: CALL_OW 331
// SetLives ( unit , 1000 ) ;
36718: LD_VAR 0 1
36722: PPUSH
36723: LD_INT 1000
36725: PPUSH
36726: CALL_OW 234
// DialogueOff ;
36730: CALL_OW 7
// ComFree ( unit ) ;
36734: LD_VAR 0 1
36738: PPUSH
36739: CALL_OW 139
// end else
36743: GO 36826
// begin Say ( Roth , DA-Roth-3a ) ;
36745: LD_EXP 79
36749: PPUSH
36750: LD_STRING DA-Roth-3a
36752: PPUSH
36753: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
36757: LD_ADDR_EXP 35
36761: PUSH
36762: LD_EXP 35
36766: PUSH
36767: LD_VAR 0 1
36771: ADD
36772: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
36773: LD_INT 260
36775: PPUSH
36776: LD_INT 235
36778: PPUSH
36779: LD_INT 1
36781: PPUSH
36782: CALL_OW 331
// SetLives ( unit , 1000 ) ;
36786: LD_VAR 0 1
36790: PPUSH
36791: LD_INT 1000
36793: PPUSH
36794: CALL_OW 234
// DialogueOff ;
36798: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
36802: LD_VAR 0 1
36806: PPUSH
36807: LD_INT 272
36809: PPUSH
36810: LD_INT 254
36812: PPUSH
36813: CALL_OW 111
// AddComHold ( unit ) ;
36817: LD_VAR 0 1
36821: PPUSH
36822: CALL_OW 200
// end ; if capturedUnit = 1 then
36826: LD_EXP 34
36830: PUSH
36831: LD_INT 1
36833: EQUAL
36834: IFFALSE 36889
// begin DialogueOn ;
36836: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
36840: LD_EXP 40
36844: PPUSH
36845: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
36849: LD_EXP 40
36853: PPUSH
36854: LD_STRING DAa-JMM-1
36856: PPUSH
36857: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
36861: LD_EXP 40
36865: PPUSH
36866: LD_STRING DAa-JMM-1a
36868: PPUSH
36869: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
36873: LD_EXP 40
36877: PPUSH
36878: LD_STRING DAa-JMM-1b
36880: PPUSH
36881: CALL_OW 88
// DialogueOff ;
36885: CALL_OW 7
// end ; end ;
36889: LD_VAR 0 2
36893: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
36894: LD_EXP 15
36898: PUSH
36899: LD_INT 13
36901: GREATEREQUAL
36902: PUSH
36903: LD_INT 22
36905: PUSH
36906: LD_INT 2
36908: PUSH
36909: EMPTY
36910: LIST
36911: LIST
36912: PUSH
36913: LD_INT 21
36915: PUSH
36916: LD_INT 1
36918: PUSH
36919: EMPTY
36920: LIST
36921: LIST
36922: PUSH
36923: EMPTY
36924: LIST
36925: LIST
36926: PPUSH
36927: CALL_OW 69
36931: PUSH
36932: LD_INT 0
36934: EQUAL
36935: AND
36936: PUSH
36937: LD_INT 22
36939: PUSH
36940: LD_INT 2
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: PUSH
36947: LD_INT 33
36949: PUSH
36950: LD_INT 5
36952: PUSH
36953: EMPTY
36954: LIST
36955: LIST
36956: PUSH
36957: LD_INT 21
36959: PUSH
36960: LD_INT 2
36962: PUSH
36963: EMPTY
36964: LIST
36965: LIST
36966: PUSH
36967: LD_INT 50
36969: PUSH
36970: EMPTY
36971: LIST
36972: PUSH
36973: EMPTY
36974: LIST
36975: LIST
36976: LIST
36977: LIST
36978: PPUSH
36979: CALL_OW 69
36983: PUSH
36984: LD_INT 0
36986: EQUAL
36987: AND
36988: PUSH
36989: LD_EXP 21
36993: AND
36994: PUSH
36995: LD_EXP 22
36999: AND
37000: PUSH
37001: LD_EXP 23
37005: AND
37006: IFFALSE 37775
37008: GO 37010
37010: DISABLE
37011: LD_INT 0
37013: PPUSH
37014: PPUSH
37015: PPUSH
// begin wait ( 0 0$05 ) ;
37016: LD_INT 175
37018: PPUSH
37019: CALL_OW 67
// if Count ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 2 then
37023: LD_INT 22
37025: PUSH
37026: LD_INT 1
37028: PUSH
37029: EMPTY
37030: LIST
37031: LIST
37032: PUSH
37033: LD_INT 21
37035: PUSH
37036: LD_INT 1
37038: PUSH
37039: EMPTY
37040: LIST
37041: LIST
37042: PUSH
37043: LD_INT 23
37045: PUSH
37046: LD_INT 1
37048: PUSH
37049: EMPTY
37050: LIST
37051: LIST
37052: PUSH
37053: LD_INT 50
37055: PUSH
37056: EMPTY
37057: LIST
37058: PUSH
37059: EMPTY
37060: LIST
37061: LIST
37062: LIST
37063: LIST
37064: PPUSH
37065: CALL_OW 69
37069: PPUSH
37070: CALL 72395 0 1
37074: PUSH
37075: LD_INT 2
37077: LESS
37078: IFFALSE 37089
// begin YouLost ( LostVictory ) ;
37080: LD_STRING LostVictory
37082: PPUSH
37083: CALL_OW 104
// exit ;
37087: GO 37775
// end ; m1 := false ;
37089: LD_ADDR_VAR 0 1
37093: PUSH
37094: LD_INT 0
37096: ST_TO_ADDR
// m2 := false ;
37097: LD_ADDR_VAR 0 2
37101: PUSH
37102: LD_INT 0
37104: ST_TO_ADDR
// m3 := false ;
37105: LD_ADDR_VAR 0 3
37109: PUSH
37110: LD_INT 0
37112: ST_TO_ADDR
// if not bombExploded then
37113: LD_EXP 37
37117: NOT
37118: IFFALSE 37127
// SetAchievement ( ACH_SIBROCKET ) ;
37120: LD_STRING ACH_SIBROCKET
37122: PPUSH
37123: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
37127: LD_EXP 66
37131: PPUSH
37132: CALL_OW 255
37136: PUSH
37137: LD_INT 1
37139: EQUAL
37140: PUSH
37141: LD_EXP 66
37145: PPUSH
37146: CALL_OW 302
37150: AND
37151: IFFALSE 37167
// begin wait ( 3 ) ;
37153: LD_INT 3
37155: PPUSH
37156: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
37160: LD_STRING ACH_OPO
37162: PPUSH
37163: CALL_OW 543
// end ; if tick <= 120 120$00 then
37167: LD_OWVAR 1
37171: PUSH
37172: LD_INT 252000
37174: LESSEQUAL
37175: IFFALSE 37191
// begin wait ( 3 ) ;
37177: LD_INT 3
37179: PPUSH
37180: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
37184: LD_STRING ACH_ASPEED_15
37186: PPUSH
37187: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
37191: LD_EXP 40
37195: PPUSH
37196: CALL_OW 87
// music_class := 5 ;
37200: LD_ADDR_OWVAR 72
37204: PUSH
37205: LD_INT 5
37207: ST_TO_ADDR
// music_nat := 5 ;
37208: LD_ADDR_OWVAR 71
37212: PUSH
37213: LD_INT 5
37215: ST_TO_ADDR
// DialogueOn ;
37216: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
37220: LD_EXP 40
37224: PPUSH
37225: LD_STRING D20-JMM-1
37227: PPUSH
37228: CALL_OW 88
// if IsOK ( Joan ) then
37232: LD_EXP 41
37236: PPUSH
37237: CALL_OW 302
37241: IFFALSE 37255
// Say ( Joan , D20-Joan-1 ) ;
37243: LD_EXP 41
37247: PPUSH
37248: LD_STRING D20-Joan-1
37250: PPUSH
37251: CALL_OW 88
// if IsOk ( Lisa ) then
37255: LD_EXP 43
37259: PPUSH
37260: CALL_OW 302
37264: IFFALSE 37278
// Say ( Lisa , D20-Lisa-1 ) ;
37266: LD_EXP 43
37270: PPUSH
37271: LD_STRING D20-Lisa-1
37273: PPUSH
37274: CALL_OW 88
// if IsOk ( Donaldson ) then
37278: LD_EXP 44
37282: PPUSH
37283: CALL_OW 302
37287: IFFALSE 37301
// Say ( Donaldson , D20-Don-1 ) ;
37289: LD_EXP 44
37293: PPUSH
37294: LD_STRING D20-Don-1
37296: PPUSH
37297: CALL_OW 88
// if IsOK ( Cornel ) then
37301: LD_EXP 51
37305: PPUSH
37306: CALL_OW 302
37310: IFFALSE 37324
// Say ( Cornel , D20-Corn-1 ) ;
37312: LD_EXP 51
37316: PPUSH
37317: LD_STRING D20-Corn-1
37319: PPUSH
37320: CALL_OW 88
// if IsOk ( Denis ) then
37324: LD_EXP 47
37328: PPUSH
37329: CALL_OW 302
37333: IFFALSE 37347
// Say ( Denis , D20-Den-1 ) ;
37335: LD_EXP 47
37339: PPUSH
37340: LD_STRING D20-Den-1
37342: PPUSH
37343: CALL_OW 88
// if IsOk ( Bobby ) then
37347: LD_EXP 45
37351: PPUSH
37352: CALL_OW 302
37356: IFFALSE 37370
// Say ( Bobby , D20-Bobby-1 ) ;
37358: LD_EXP 45
37362: PPUSH
37363: LD_STRING D20-Bobby-1
37365: PPUSH
37366: CALL_OW 88
// if IsOk ( Gladstone ) then
37370: LD_EXP 49
37374: PPUSH
37375: CALL_OW 302
37379: IFFALSE 37393
// Say ( Gladstone , D20-Glad-1 ) ;
37381: LD_EXP 49
37385: PPUSH
37386: LD_STRING D20-Glad-1
37388: PPUSH
37389: CALL_OW 88
// if IsOk ( Cyrus ) then
37393: LD_EXP 46
37397: PPUSH
37398: CALL_OW 302
37402: IFFALSE 37416
// Say ( Cyrus , D20-Cyrus-1 ) ;
37404: LD_EXP 46
37408: PPUSH
37409: LD_STRING D20-Cyrus-1
37411: PPUSH
37412: CALL_OW 88
// if IsOk ( Stevens ) then
37416: LD_EXP 42
37420: PPUSH
37421: CALL_OW 302
37425: IFFALSE 37439
// Say ( Stevens , D20-Huck-1 ) ;
37427: LD_EXP 42
37431: PPUSH
37432: LD_STRING D20-Huck-1
37434: PPUSH
37435: CALL_OW 88
// if IsOk ( Brown ) then
37439: LD_EXP 48
37443: PPUSH
37444: CALL_OW 302
37448: IFFALSE 37462
// Say ( Brown , D20-Brown-1 ) ;
37450: LD_EXP 48
37454: PPUSH
37455: LD_STRING D20-Brown-1
37457: PPUSH
37458: CALL_OW 88
// if IsOk ( Gary ) then
37462: LD_EXP 52
37466: PPUSH
37467: CALL_OW 302
37471: IFFALSE 37485
// Say ( Gary , D20-Gary-1 ) ;
37473: LD_EXP 52
37477: PPUSH
37478: LD_STRING D20-Gary-1
37480: PPUSH
37481: CALL_OW 88
// if IsOk ( Connie ) then
37485: LD_EXP 55
37489: PPUSH
37490: CALL_OW 302
37494: IFFALSE 37508
// Say ( Connie , D20-Con-1 ) ;
37496: LD_EXP 55
37500: PPUSH
37501: LD_STRING D20-Con-1
37503: PPUSH
37504: CALL_OW 88
// if IsOk ( Kurt ) then
37508: LD_EXP 64
37512: PPUSH
37513: CALL_OW 302
37517: IFFALSE 37531
// Say ( Kurt , D20-Kurt-1 ) ;
37519: LD_EXP 64
37523: PPUSH
37524: LD_STRING D20-Kurt-1
37526: PPUSH
37527: CALL_OW 88
// if IsOk ( Kikuchi ) then
37531: LD_EXP 54
37535: PPUSH
37536: CALL_OW 302
37540: IFFALSE 37554
// Say ( Kikuchi , D20-Yam-1 ) ;
37542: LD_EXP 54
37546: PPUSH
37547: LD_STRING D20-Yam-1
37549: PPUSH
37550: CALL_OW 88
// if IsOk ( Frank ) then
37554: LD_EXP 53
37558: PPUSH
37559: CALL_OW 302
37563: IFFALSE 37577
// Say ( Frank , D20-Frank-1 ) ;
37565: LD_EXP 53
37569: PPUSH
37570: LD_STRING D20-Frank-1
37572: PPUSH
37573: CALL_OW 88
// DialogueOff ;
37577: CALL_OW 7
// if RothCaptured then
37581: LD_EXP 33
37585: IFFALSE 37607
// begin m1 := true ;
37587: LD_ADDR_VAR 0 1
37591: PUSH
37592: LD_INT 1
37594: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
37595: LD_STRING Roth
37597: PPUSH
37598: LD_INT 1
37600: PPUSH
37601: CALL_OW 101
// end else
37605: GO 37618
// AddMedal ( Roth , - 1 ) ;
37607: LD_STRING Roth
37609: PPUSH
37610: LD_INT 1
37612: NEG
37613: PPUSH
37614: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish or not behemothDone then
37618: LD_EXP 25
37622: NOT
37623: PUSH
37624: LD_EXP 27
37628: OR
37629: PUSH
37630: LD_EXP 28
37634: NOT
37635: OR
37636: IFFALSE 37658
// begin m2 := true ;
37638: LD_ADDR_VAR 0 2
37642: PUSH
37643: LD_INT 1
37645: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
37646: LD_STRING Project
37648: PPUSH
37649: LD_INT 1
37651: PPUSH
37652: CALL_OW 101
// end else
37656: GO 37669
// AddMedal ( Project , - 1 ) ;
37658: LD_STRING Project
37660: PPUSH
37661: LD_INT 1
37663: NEG
37664: PPUSH
37665: CALL_OW 101
// if lostCounter = 0 then
37669: LD_EXP 32
37673: PUSH
37674: LD_INT 0
37676: EQUAL
37677: IFFALSE 37699
// begin m3 := true ;
37679: LD_ADDR_VAR 0 3
37683: PUSH
37684: LD_INT 1
37686: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
37687: LD_STRING NoLosses
37689: PPUSH
37690: LD_INT 1
37692: PPUSH
37693: CALL_OW 101
// end else
37697: GO 37710
// AddMedal ( NoLosses , - 1 ) ;
37699: LD_STRING NoLosses
37701: PPUSH
37702: LD_INT 1
37704: NEG
37705: PPUSH
37706: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
37710: LD_VAR 0 1
37714: PUSH
37715: LD_VAR 0 2
37719: AND
37720: PUSH
37721: LD_VAR 0 3
37725: AND
37726: PUSH
37727: LD_OWVAR 67
37731: PUSH
37732: LD_INT 3
37734: GREATEREQUAL
37735: AND
37736: IFFALSE 37748
// SetAchievementEX ( ACH_AMER , 15 ) ;
37738: LD_STRING ACH_AMER
37740: PPUSH
37741: LD_INT 15
37743: PPUSH
37744: CALL_OW 564
// GiveMedals ( MAIN ) ;
37748: LD_STRING MAIN
37750: PPUSH
37751: CALL_OW 102
// music_class := 4 ;
37755: LD_ADDR_OWVAR 72
37759: PUSH
37760: LD_INT 4
37762: ST_TO_ADDR
// music_nat := 1 ;
37763: LD_ADDR_OWVAR 71
37767: PUSH
37768: LD_INT 1
37770: ST_TO_ADDR
// YouWin ;
37771: CALL_OW 103
// end ; end_of_file
37775: PPOPN 3
37777: END
// export function CustomEvent ( event ) ; begin
37778: LD_INT 0
37780: PPUSH
// end ;
37781: LD_VAR 0 2
37785: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
37786: LD_VAR 0 1
37790: PUSH
37791: LD_INT 1
37793: EQUAL
37794: PUSH
37795: LD_VAR 0 2
37799: PUSH
37800: LD_INT 4
37802: EQUAL
37803: AND
37804: PUSH
37805: LD_EXP 61
37809: PPUSH
37810: CALL_OW 300
37814: AND
37815: IFFALSE 37831
// begin wait ( 0 0$2 ) ;
37817: LD_INT 70
37819: PPUSH
37820: CALL_OW 67
// YouLost ( Dismissed ) ;
37824: LD_STRING Dismissed
37826: PPUSH
37827: CALL_OW 104
// end ; end ;
37831: PPOPN 2
37833: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
37834: LD_VAR 0 2
37838: PPUSH
37839: LD_VAR 0 3
37843: PPUSH
37844: LD_INT 18
37846: PPUSH
37847: CALL_OW 309
37851: IFFALSE 37860
// YouLost ( Motherlode3 ) ;
37853: LD_STRING Motherlode3
37855: PPUSH
37856: CALL_OW 104
// end ;
37860: PPOPN 3
37862: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
37863: LD_EXP 27
37867: NOT
37868: IFFALSE 37878
// behemothDone := true ;
37870: LD_ADDR_EXP 28
37874: PUSH
37875: LD_INT 1
37877: ST_TO_ADDR
// end ;
37878: PPOPN 1
37880: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
37881: LD_VAR 0 1
37885: PPUSH
37886: CALL_OW 255
37890: PUSH
37891: LD_INT 1
37893: EQUAL
37894: IFFALSE 37904
// bombExploded := true ;
37896: LD_ADDR_EXP 37
37900: PUSH
37901: LD_INT 1
37903: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
37904: LD_VAR 0 1
37908: PPUSH
37909: CALL_OW 255
37913: PUSH
37914: LD_INT 3
37916: EQUAL
37917: IFFALSE 37947
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
37919: LD_INT 2
37921: PPUSH
37922: LD_INT 23
37924: PUSH
37925: LD_INT 3
37927: PUSH
37928: LD_INT 3
37930: PUSH
37931: LD_INT 48
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: LIST
37938: LIST
37939: PUSH
37940: EMPTY
37941: LIST
37942: PPUSH
37943: CALL 63846 0 2
// if GetSide ( unit ) = 1 and GetSide ( Friend ) = 1 and IsOk ( Friend ) and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
37947: LD_VAR 0 1
37951: PPUSH
37952: CALL_OW 255
37956: PUSH
37957: LD_INT 1
37959: EQUAL
37960: PUSH
37961: LD_EXP 66
37965: PPUSH
37966: CALL_OW 255
37970: PUSH
37971: LD_INT 1
37973: EQUAL
37974: AND
37975: PUSH
37976: LD_EXP 66
37980: PPUSH
37981: CALL_OW 302
37985: AND
37986: PUSH
37987: LD_EXP 30
37991: AND
37992: PUSH
37993: LD_INT 22
37995: PUSH
37996: LD_INT 3
37998: PUSH
37999: EMPTY
38000: LIST
38001: LIST
38002: PUSH
38003: LD_INT 34
38005: PUSH
38006: LD_INT 48
38008: PUSH
38009: EMPTY
38010: LIST
38011: LIST
38012: PUSH
38013: EMPTY
38014: LIST
38015: LIST
38016: PPUSH
38017: CALL_OW 69
38021: AND
38022: PUSH
38023: LD_INT 22
38025: PUSH
38026: LD_INT 1
38028: PUSH
38029: EMPTY
38030: LIST
38031: LIST
38032: PUSH
38033: LD_INT 34
38035: PUSH
38036: LD_INT 8
38038: PUSH
38039: EMPTY
38040: LIST
38041: LIST
38042: PUSH
38043: EMPTY
38044: LIST
38045: LIST
38046: PPUSH
38047: CALL_OW 69
38051: NOT
38052: AND
38053: IFFALSE 38105
// begin wait ( 0 0$5 ) ;
38055: LD_INT 175
38057: PPUSH
38058: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
38062: LD_INT 22
38064: PUSH
38065: LD_INT 3
38067: PUSH
38068: EMPTY
38069: LIST
38070: LIST
38071: PUSH
38072: LD_INT 34
38074: PUSH
38075: LD_INT 48
38077: PUSH
38078: EMPTY
38079: LIST
38080: LIST
38081: PUSH
38082: EMPTY
38083: LIST
38084: LIST
38085: PPUSH
38086: CALL_OW 69
38090: PUSH
38091: LD_INT 1
38093: ARRAY
38094: PPUSH
38095: LD_INT 60
38097: PPUSH
38098: LD_INT 95
38100: PPUSH
38101: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
38105: LD_VAR 0 2
38109: PPUSH
38110: LD_VAR 0 3
38114: PPUSH
38115: LD_INT 18
38117: PPUSH
38118: CALL_OW 309
38122: PUSH
38123: LD_VAR 0 2
38127: PPUSH
38128: LD_VAR 0 3
38132: PPUSH
38133: LD_INT 18
38135: PPUSH
38136: CALL 111817 0 3
38140: OR
38141: IFFALSE 38188
// begin if GetSide ( unit ) = 1 then
38143: LD_VAR 0 1
38147: PPUSH
38148: CALL_OW 255
38152: PUSH
38153: LD_INT 1
38155: EQUAL
38156: IFFALSE 38174
// begin wait ( 0 0$6 ) ;
38158: LD_INT 210
38160: PPUSH
38161: CALL_OW 67
// YouLost ( Motherlode2 ) ;
38165: LD_STRING Motherlode2
38167: PPUSH
38168: CALL_OW 104
// end else
38172: GO 38188
// begin wait ( 0 0$6 ) ;
38174: LD_INT 210
38176: PPUSH
38177: CALL_OW 67
// YouLost ( Motherlode1 ) ;
38181: LD_STRING Motherlode1
38183: PPUSH
38184: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
38188: LD_VAR 0 1
38192: PPUSH
38193: CALL_OW 255
38197: PUSH
38198: LD_INT 3
38200: EQUAL
38201: IFFALSE 38222
// begin wait ( 0 0$5 ) ;
38203: LD_INT 175
38205: PPUSH
38206: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
38210: LD_EXP 68
38214: PPUSH
38215: LD_STRING D18-Pla-1
38217: PPUSH
38218: CALL_OW 94
// end ; end ;
38222: PPOPN 3
38224: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
38225: LD_VAR 0 1
38229: PPUSH
38230: CALL 129035 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
38234: LD_VAR 0 1
38238: PUSH
38239: LD_INT 22
38241: PUSH
38242: LD_INT 1
38244: PUSH
38245: EMPTY
38246: LIST
38247: LIST
38248: PUSH
38249: LD_INT 21
38251: PUSH
38252: LD_INT 1
38254: PUSH
38255: EMPTY
38256: LIST
38257: LIST
38258: PUSH
38259: LD_INT 23
38261: PUSH
38262: LD_INT 1
38264: PUSH
38265: EMPTY
38266: LIST
38267: LIST
38268: PUSH
38269: EMPTY
38270: LIST
38271: LIST
38272: LIST
38273: PPUSH
38274: CALL_OW 69
38278: IN
38279: IFFALSE 38295
// lostCounter := lostCounter + 1 ;
38281: LD_ADDR_EXP 32
38285: PUSH
38286: LD_EXP 32
38290: PUSH
38291: LD_INT 1
38293: PLUS
38294: ST_TO_ADDR
// if un in behemothBuilders then
38295: LD_VAR 0 1
38299: PUSH
38300: LD_EXP 77
38304: IN
38305: IFFALSE 38325
// begin behemothBuilders := behemothBuilders diff un ;
38307: LD_ADDR_EXP 77
38311: PUSH
38312: LD_EXP 77
38316: PUSH
38317: LD_VAR 0 1
38321: DIFF
38322: ST_TO_ADDR
// exit ;
38323: GO 38355
// end ; if un = JMM then
38325: LD_VAR 0 1
38329: PUSH
38330: LD_EXP 40
38334: EQUAL
38335: IFFALSE 38346
// begin YouLost ( JMM ) ;
38337: LD_STRING JMM
38339: PPUSH
38340: CALL_OW 104
// exit ;
38344: GO 38355
// end ; MCE_UnitDestroyed ( un ) ;
38346: LD_VAR 0 1
38350: PPUSH
38351: CALL 67288 0 1
// end ;
38355: PPOPN 1
38357: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
38358: LD_VAR 0 1
38362: PPUSH
38363: LD_VAR 0 2
38367: PPUSH
38368: CALL 69620 0 2
// end ;
38372: PPOPN 2
38374: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
38375: LD_VAR 0 1
38379: PPUSH
38380: CALL 68688 0 1
// end ;
38384: PPOPN 1
38386: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
38387: LD_VAR 0 1
38391: PUSH
38392: LD_INT 22
38394: PUSH
38395: LD_INT 8
38397: PUSH
38398: EMPTY
38399: LIST
38400: LIST
38401: PUSH
38402: LD_INT 30
38404: PUSH
38405: LD_INT 2
38407: PUSH
38408: EMPTY
38409: LIST
38410: LIST
38411: PUSH
38412: LD_INT 23
38414: PUSH
38415: LD_INT 3
38417: PUSH
38418: EMPTY
38419: LIST
38420: LIST
38421: PUSH
38422: EMPTY
38423: LIST
38424: LIST
38425: LIST
38426: PPUSH
38427: CALL_OW 69
38431: IN
38432: IFFALSE 38459
// begin ComUpgrade ( building ) ;
38434: LD_VAR 0 1
38438: PPUSH
38439: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
38443: LD_EXP 65
38447: PPUSH
38448: LD_VAR 0 1
38452: PPUSH
38453: CALL 78493 0 2
// exit ;
38457: GO 38468
// end ; MCE_BuildingComplete ( building ) ;
38459: LD_VAR 0 1
38463: PPUSH
38464: CALL 68929 0 1
// end ;
38468: PPOPN 1
38470: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
38471: LD_VAR 0 1
38475: PPUSH
38476: LD_VAR 0 2
38480: PPUSH
38481: CALL 66984 0 2
// end ;
38485: PPOPN 2
38487: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
38488: LD_VAR 0 1
38492: PPUSH
38493: LD_VAR 0 2
38497: PPUSH
38498: LD_VAR 0 3
38502: PPUSH
38503: LD_VAR 0 4
38507: PPUSH
38508: LD_VAR 0 5
38512: PPUSH
38513: CALL 66604 0 5
// end ;
38517: PPOPN 5
38519: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
38520: LD_VAR 0 1
38524: PPUSH
38525: CALL_OW 255
38529: PUSH
38530: LD_INT 1
38532: EQUAL
38533: IFFALSE 38550
// amConstructCounter := Inc ( amConstructCounter ) ;
38535: LD_ADDR_EXP 39
38539: PUSH
38540: LD_EXP 39
38544: PPUSH
38545: CALL 109365 0 1
38549: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
38550: LD_VAR 0 1
38554: PPUSH
38555: LD_VAR 0 2
38559: PPUSH
38560: CALL 129093 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
38564: LD_VAR 0 1
38568: PPUSH
38569: LD_VAR 0 2
38573: PPUSH
38574: CALL 66157 0 2
// end ;
38578: PPOPN 2
38580: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
38581: LD_VAR 0 1
38585: PPUSH
38586: LD_VAR 0 2
38590: PPUSH
38591: LD_VAR 0 3
38595: PPUSH
38596: LD_VAR 0 4
38600: PPUSH
38601: CALL 65995 0 4
// end ;
38605: PPOPN 4
38607: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
38608: LD_VAR 0 1
38612: PPUSH
38613: LD_VAR 0 2
38617: PPUSH
38618: LD_VAR 0 3
38622: PPUSH
38623: CALL 65770 0 3
// end ;
38627: PPOPN 3
38629: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
38630: LD_VAR 0 1
38634: PPUSH
38635: LD_VAR 0 2
38639: PPUSH
38640: CALL 65655 0 2
// end ;
38644: PPOPN 2
38646: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
38647: LD_VAR 0 1
38651: PPUSH
38652: LD_VAR 0 2
38656: PPUSH
38657: CALL 69915 0 2
// end ;
38661: PPOPN 2
38663: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
38664: LD_VAR 0 1
38668: PUSH
38669: LD_INT 460
38671: EQUAL
38672: IFFALSE 38694
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
38674: LD_VAR 0 2
38678: PPUSH
38679: LD_INT 227
38681: PPUSH
38682: LD_INT 136
38684: PPUSH
38685: CALL_OW 428
38689: PPUSH
38690: CALL_OW 120
// end ;
38694: PPOPN 2
38696: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
38697: LD_VAR 0 1
38701: PPUSH
38702: CALL_OW 255
38706: PUSH
38707: LD_INT 4
38709: EQUAL
38710: PUSH
38711: LD_VAR 0 1
38715: PUSH
38716: LD_EXP 18
38720: PUSH
38721: LD_INT 1
38723: ARRAY
38724: IN
38725: AND
38726: PUSH
38727: LD_EXP 19
38731: AND
38732: IFFALSE 38751
// begin ComMoveXY ( driver , 61 , 93 ) ;
38734: LD_VAR 0 1
38738: PPUSH
38739: LD_INT 61
38741: PPUSH
38742: LD_INT 93
38744: PPUSH
38745: CALL_OW 111
// exit ;
38749: GO 38820
// end ; if GetSide ( driver ) = 3 and GetTag ( driver ) = 105 then
38751: LD_VAR 0 1
38755: PPUSH
38756: CALL_OW 255
38760: PUSH
38761: LD_INT 3
38763: EQUAL
38764: PUSH
38765: LD_VAR 0 1
38769: PPUSH
38770: CALL_OW 110
38774: PUSH
38775: LD_INT 105
38777: EQUAL
38778: AND
38779: IFFALSE 38796
// begin ComMoveXY ( driver , 187 , 92 ) ;
38781: LD_VAR 0 1
38785: PPUSH
38786: LD_INT 187
38788: PPUSH
38789: LD_INT 92
38791: PPUSH
38792: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
38796: LD_VAR 0 1
38800: PPUSH
38801: LD_VAR 0 2
38805: PPUSH
38806: LD_VAR 0 3
38810: PPUSH
38811: LD_VAR 0 4
38815: PPUSH
38816: CALL 70131 0 4
// end ;
38820: PPOPN 4
38822: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
38823: LD_VAR 0 1
38827: PPUSH
38828: LD_VAR 0 2
38832: PPUSH
38833: CALL 65464 0 2
// end ;
38837: PPOPN 2
38839: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
38840: LD_VAR 0 1
38844: PPUSH
38845: CALL 129077 0 1
// end ; end_of_file
38849: PPOPN 1
38851: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
38852: LD_EXP 15
38856: PUSH
38857: LD_INT 2
38859: EQUAL
38860: IFFALSE 39377
38862: GO 38864
38864: DISABLE
38865: LD_INT 0
38867: PPUSH
38868: PPUSH
// begin time := 0 0$35 ;
38869: LD_ADDR_VAR 0 2
38873: PUSH
38874: LD_INT 1225
38876: ST_TO_ADDR
// repeat wait ( time ) ;
38877: LD_VAR 0 2
38881: PPUSH
38882: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
38886: LD_INT 1
38888: PPUSH
38889: LD_INT 5
38891: PPUSH
38892: CALL_OW 12
38896: PPUSH
38897: LD_INT 106
38899: PPUSH
38900: LD_INT 150
38902: PPUSH
38903: LD_INT 19
38905: PPUSH
38906: LD_INT 1
38908: PPUSH
38909: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
38913: LD_INT 455
38915: PPUSH
38916: LD_INT 770
38918: PPUSH
38919: CALL_OW 12
38923: PPUSH
38924: CALL_OW 67
// if Prob ( 50 ) then
38928: LD_INT 50
38930: PPUSH
38931: CALL_OW 13
38935: IFFALSE 38964
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
38937: LD_INT 1
38939: PPUSH
38940: LD_INT 5
38942: PPUSH
38943: CALL_OW 12
38947: PPUSH
38948: LD_INT 62
38950: PPUSH
38951: LD_INT 108
38953: PPUSH
38954: LD_INT 10
38956: PPUSH
38957: LD_INT 1
38959: PPUSH
38960: CALL_OW 56
// until missionStage > 4 ;
38964: LD_EXP 15
38968: PUSH
38969: LD_INT 4
38971: GREATER
38972: IFFALSE 38877
// repeat wait ( 0 0$1 ) ;
38974: LD_INT 35
38976: PPUSH
38977: CALL_OW 67
// until missionStage = 6 ;
38981: LD_EXP 15
38985: PUSH
38986: LD_INT 6
38988: EQUAL
38989: IFFALSE 38974
// time := 0 0$20 ;
38991: LD_ADDR_VAR 0 2
38995: PUSH
38996: LD_INT 700
38998: ST_TO_ADDR
// repeat wait ( time ) ;
38999: LD_VAR 0 2
39003: PPUSH
39004: CALL_OW 67
// if Prob ( 90 ) then
39008: LD_INT 90
39010: PPUSH
39011: CALL_OW 13
39015: IFFALSE 39058
// begin time := time + 0 0$2 ;
39017: LD_ADDR_VAR 0 2
39021: PUSH
39022: LD_VAR 0 2
39026: PUSH
39027: LD_INT 70
39029: PLUS
39030: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
39031: LD_INT 1
39033: PPUSH
39034: LD_INT 5
39036: PPUSH
39037: CALL_OW 12
39041: PPUSH
39042: LD_INT 106
39044: PPUSH
39045: LD_INT 89
39047: PPUSH
39048: LD_INT 45
39050: PPUSH
39051: LD_INT 1
39053: PPUSH
39054: CALL_OW 56
// end ; if Prob ( 45 ) then
39058: LD_INT 45
39060: PPUSH
39061: CALL_OW 13
39065: IFFALSE 39121
// begin for i := 1 to 4 do
39067: LD_ADDR_VAR 0 1
39071: PUSH
39072: DOUBLE
39073: LD_INT 1
39075: DEC
39076: ST_TO_ADDR
39077: LD_INT 4
39079: PUSH
39080: FOR_TO
39081: IFFALSE 39119
// begin wait ( 0 0$5 ) ;
39083: LD_INT 175
39085: PPUSH
39086: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
39090: LD_INT 1
39092: PPUSH
39093: LD_INT 5
39095: PPUSH
39096: CALL_OW 12
39100: PPUSH
39101: LD_INT 113
39103: PPUSH
39104: LD_INT 117
39106: PPUSH
39107: LD_INT 25
39109: PPUSH
39110: LD_INT 1
39112: PPUSH
39113: CALL_OW 56
// end ;
39117: GO 39080
39119: POP
39120: POP
// end ; if Prob ( 40 ) then
39121: LD_INT 40
39123: PPUSH
39124: CALL_OW 13
39128: IFFALSE 39174
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
39130: LD_INT 385
39132: PPUSH
39133: LD_INT 945
39135: PPUSH
39136: CALL_OW 12
39140: PPUSH
39141: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
39145: LD_INT 1
39147: PPUSH
39148: LD_INT 5
39150: PPUSH
39151: CALL_OW 12
39155: PPUSH
39156: LD_INT 21
39158: PPUSH
39159: LD_INT 26
39161: PPUSH
39162: LD_INT 12
39164: PPUSH
39165: LD_INT 1
39167: PPUSH
39168: CALL_OW 56
// end else
39172: GO 39210
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
39174: LD_INT 700
39176: PPUSH
39177: LD_INT 1225
39179: PPUSH
39180: CALL_OW 12
39184: PPUSH
39185: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
39189: LD_INT 1
39191: PPUSH
39192: LD_INT 5
39194: PPUSH
39195: CALL_OW 12
39199: PPUSH
39200: LD_INT 16
39202: PPUSH
39203: LD_INT 1
39205: PPUSH
39206: CALL_OW 55
// end ; if Prob ( 50 ) then
39210: LD_INT 50
39212: PPUSH
39213: CALL_OW 13
39217: IFFALSE 39263
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
39219: LD_INT 700
39221: PPUSH
39222: LD_INT 1050
39224: PPUSH
39225: CALL_OW 12
39229: PPUSH
39230: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
39234: LD_INT 1
39236: PPUSH
39237: LD_INT 5
39239: PPUSH
39240: CALL_OW 12
39244: PPUSH
39245: LD_INT 168
39247: PPUSH
39248: LD_INT 168
39250: PPUSH
39251: LD_INT 16
39253: PPUSH
39254: LD_INT 1
39256: PPUSH
39257: CALL_OW 56
// end else
39261: GO 39299
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
39263: LD_INT 350
39265: PPUSH
39266: LD_INT 525
39268: PPUSH
39269: CALL_OW 12
39273: PPUSH
39274: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
39278: LD_INT 1
39280: PPUSH
39281: LD_INT 5
39283: PPUSH
39284: CALL_OW 12
39288: PPUSH
39289: LD_INT 15
39291: PPUSH
39292: LD_INT 1
39294: PPUSH
39295: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
39299: LD_INT 175
39301: PPUSH
39302: LD_INT 315
39304: PPUSH
39305: CALL_OW 12
39309: PPUSH
39310: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
39314: LD_INT 1
39316: PPUSH
39317: LD_INT 5
39319: PPUSH
39320: CALL_OW 12
39324: PPUSH
39325: LD_INT 103
39327: PPUSH
39328: LD_INT 140
39330: PPUSH
39331: LD_INT 20
39333: PPUSH
39334: LD_INT 1
39336: PPUSH
39337: CALL_OW 56
// time := time + 0 0$2 ;
39341: LD_ADDR_VAR 0 2
39345: PUSH
39346: LD_VAR 0 2
39350: PUSH
39351: LD_INT 70
39353: PLUS
39354: ST_TO_ADDR
// if time > 1 1$20 then
39355: LD_VAR 0 2
39359: PUSH
39360: LD_INT 2800
39362: GREATER
39363: IFFALSE 39373
// time := 0 0$30 ;
39365: LD_ADDR_VAR 0 2
39369: PUSH
39370: LD_INT 1050
39372: ST_TO_ADDR
// until false ;
39373: LD_INT 0
39375: IFFALSE 38999
// end ; end_of_file
39377: PPOPN 2
39379: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
39380: LD_EXP 13
39384: PUSH
39385: LD_EXP 15
39389: PUSH
39390: LD_INT 6
39392: GREATEREQUAL
39393: AND
39394: IFFALSE 39431
39396: GO 39398
39398: DISABLE
// begin enable ;
39399: ENABLE
// missionTime := missionTime + 0 0$1 ;
39400: LD_ADDR_EXP 14
39404: PUSH
39405: LD_EXP 14
39409: PUSH
39410: LD_INT 35
39412: PLUS
39413: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
39414: LD_ADDR_OWVAR 47
39418: PUSH
39419: LD_STRING #Am15-1
39421: PUSH
39422: LD_EXP 14
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: ST_TO_ADDR
// end ; end_of_file
39431: END
// export function InitNature ; begin
39432: LD_INT 0
39434: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
39435: LD_INT 3
39437: PPUSH
39438: LD_INT 3
39440: PPUSH
39441: LD_INT 2
39443: PPUSH
39444: LD_INT 1
39446: PPUSH
39447: LD_INT 1
39449: PPUSH
39450: LD_INT 0
39452: PPUSH
39453: LD_INT 0
39455: PPUSH
39456: LD_INT 20
39458: PPUSH
39459: LD_INT 0
39461: PPUSH
39462: CALL 104681 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
39466: LD_INT 2
39468: PPUSH
39469: LD_INT 1
39471: PPUSH
39472: LD_INT 1
39474: PPUSH
39475: LD_INT 1
39477: PPUSH
39478: LD_INT 1
39480: PPUSH
39481: LD_INT 0
39483: PPUSH
39484: LD_INT 0
39486: PPUSH
39487: LD_INT 21
39489: PPUSH
39490: LD_INT 0
39492: PPUSH
39493: CALL 104681 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
39497: LD_INT 4
39499: PPUSH
39500: LD_INT 1
39502: PPUSH
39503: LD_INT 2
39505: PPUSH
39506: LD_INT 4
39508: PPUSH
39509: LD_INT 2
39511: PPUSH
39512: LD_INT 1
39514: PPUSH
39515: LD_INT 0
39517: PPUSH
39518: LD_INT 22
39520: PPUSH
39521: LD_INT 0
39523: PPUSH
39524: CALL 104681 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
39528: LD_INT 0
39530: PPUSH
39531: LD_INT 0
39533: PPUSH
39534: LD_INT 0
39536: PPUSH
39537: LD_INT 0
39539: PPUSH
39540: LD_INT 0
39542: PPUSH
39543: LD_INT 0
39545: PPUSH
39546: LD_INT 9
39548: PPUSH
39549: LD_INT 0
39551: PPUSH
39552: LD_INT 23
39554: PPUSH
39555: CALL 104681 0 9
// end ; end_of_file
39559: LD_VAR 0 1
39563: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
39564: LD_INT 0
39566: PPUSH
39567: PPUSH
// skirmish := false ;
39568: LD_ADDR_EXP 100
39572: PUSH
39573: LD_INT 0
39575: ST_TO_ADDR
// debug_mc := false ;
39576: LD_ADDR_EXP 101
39580: PUSH
39581: LD_INT 0
39583: ST_TO_ADDR
// mc_bases := [ ] ;
39584: LD_ADDR_EXP 102
39588: PUSH
39589: EMPTY
39590: ST_TO_ADDR
// mc_sides := [ ] ;
39591: LD_ADDR_EXP 128
39595: PUSH
39596: EMPTY
39597: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
39598: LD_ADDR_EXP 103
39602: PUSH
39603: EMPTY
39604: ST_TO_ADDR
// mc_building_repairs := [ ] ;
39605: LD_ADDR_EXP 104
39609: PUSH
39610: EMPTY
39611: ST_TO_ADDR
// mc_need_heal := [ ] ;
39612: LD_ADDR_EXP 105
39616: PUSH
39617: EMPTY
39618: ST_TO_ADDR
// mc_healers := [ ] ;
39619: LD_ADDR_EXP 106
39623: PUSH
39624: EMPTY
39625: ST_TO_ADDR
// mc_build_list := [ ] ;
39626: LD_ADDR_EXP 107
39630: PUSH
39631: EMPTY
39632: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
39633: LD_ADDR_EXP 134
39637: PUSH
39638: EMPTY
39639: ST_TO_ADDR
// mc_builders := [ ] ;
39640: LD_ADDR_EXP 108
39644: PUSH
39645: EMPTY
39646: ST_TO_ADDR
// mc_construct_list := [ ] ;
39647: LD_ADDR_EXP 109
39651: PUSH
39652: EMPTY
39653: ST_TO_ADDR
// mc_turret_list := [ ] ;
39654: LD_ADDR_EXP 110
39658: PUSH
39659: EMPTY
39660: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
39661: LD_ADDR_EXP 111
39665: PUSH
39666: EMPTY
39667: ST_TO_ADDR
// mc_miners := [ ] ;
39668: LD_ADDR_EXP 116
39672: PUSH
39673: EMPTY
39674: ST_TO_ADDR
// mc_mines := [ ] ;
39675: LD_ADDR_EXP 115
39679: PUSH
39680: EMPTY
39681: ST_TO_ADDR
// mc_minefields := [ ] ;
39682: LD_ADDR_EXP 117
39686: PUSH
39687: EMPTY
39688: ST_TO_ADDR
// mc_crates := [ ] ;
39689: LD_ADDR_EXP 118
39693: PUSH
39694: EMPTY
39695: ST_TO_ADDR
// mc_crates_collector := [ ] ;
39696: LD_ADDR_EXP 119
39700: PUSH
39701: EMPTY
39702: ST_TO_ADDR
// mc_crates_area := [ ] ;
39703: LD_ADDR_EXP 120
39707: PUSH
39708: EMPTY
39709: ST_TO_ADDR
// mc_vehicles := [ ] ;
39710: LD_ADDR_EXP 121
39714: PUSH
39715: EMPTY
39716: ST_TO_ADDR
// mc_attack := [ ] ;
39717: LD_ADDR_EXP 122
39721: PUSH
39722: EMPTY
39723: ST_TO_ADDR
// mc_produce := [ ] ;
39724: LD_ADDR_EXP 123
39728: PUSH
39729: EMPTY
39730: ST_TO_ADDR
// mc_defender := [ ] ;
39731: LD_ADDR_EXP 124
39735: PUSH
39736: EMPTY
39737: ST_TO_ADDR
// mc_parking := [ ] ;
39738: LD_ADDR_EXP 126
39742: PUSH
39743: EMPTY
39744: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
39745: LD_ADDR_EXP 112
39749: PUSH
39750: EMPTY
39751: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
39752: LD_ADDR_EXP 114
39756: PUSH
39757: EMPTY
39758: ST_TO_ADDR
// mc_scan := [ ] ;
39759: LD_ADDR_EXP 125
39763: PUSH
39764: EMPTY
39765: ST_TO_ADDR
// mc_scan_area := [ ] ;
39766: LD_ADDR_EXP 127
39770: PUSH
39771: EMPTY
39772: ST_TO_ADDR
// mc_tech := [ ] ;
39773: LD_ADDR_EXP 129
39777: PUSH
39778: EMPTY
39779: ST_TO_ADDR
// mc_class := [ ] ;
39780: LD_ADDR_EXP 143
39784: PUSH
39785: EMPTY
39786: ST_TO_ADDR
// mc_class_case_use := [ ] ;
39787: LD_ADDR_EXP 144
39791: PUSH
39792: EMPTY
39793: ST_TO_ADDR
// mc_is_defending := [ ] ;
39794: LD_ADDR_EXP 145
39798: PUSH
39799: EMPTY
39800: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
39801: LD_ADDR_EXP 136
39805: PUSH
39806: EMPTY
39807: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
39808: LD_ADDR_EXP 146
39812: PUSH
39813: LD_INT 0
39815: ST_TO_ADDR
// end ;
39816: LD_VAR 0 1
39820: RET
// export function MC_Kill ( base ) ; begin
39821: LD_INT 0
39823: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
39824: LD_ADDR_EXP 102
39828: PUSH
39829: LD_EXP 102
39833: PPUSH
39834: LD_VAR 0 1
39838: PPUSH
39839: EMPTY
39840: PPUSH
39841: CALL_OW 1
39845: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
39846: LD_ADDR_EXP 103
39850: PUSH
39851: LD_EXP 103
39855: PPUSH
39856: LD_VAR 0 1
39860: PPUSH
39861: EMPTY
39862: PPUSH
39863: CALL_OW 1
39867: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
39868: LD_ADDR_EXP 104
39872: PUSH
39873: LD_EXP 104
39877: PPUSH
39878: LD_VAR 0 1
39882: PPUSH
39883: EMPTY
39884: PPUSH
39885: CALL_OW 1
39889: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
39890: LD_ADDR_EXP 105
39894: PUSH
39895: LD_EXP 105
39899: PPUSH
39900: LD_VAR 0 1
39904: PPUSH
39905: EMPTY
39906: PPUSH
39907: CALL_OW 1
39911: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
39912: LD_ADDR_EXP 106
39916: PUSH
39917: LD_EXP 106
39921: PPUSH
39922: LD_VAR 0 1
39926: PPUSH
39927: EMPTY
39928: PPUSH
39929: CALL_OW 1
39933: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
39934: LD_ADDR_EXP 107
39938: PUSH
39939: LD_EXP 107
39943: PPUSH
39944: LD_VAR 0 1
39948: PPUSH
39949: EMPTY
39950: PPUSH
39951: CALL_OW 1
39955: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
39956: LD_ADDR_EXP 108
39960: PUSH
39961: LD_EXP 108
39965: PPUSH
39966: LD_VAR 0 1
39970: PPUSH
39971: EMPTY
39972: PPUSH
39973: CALL_OW 1
39977: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
39978: LD_ADDR_EXP 109
39982: PUSH
39983: LD_EXP 109
39987: PPUSH
39988: LD_VAR 0 1
39992: PPUSH
39993: EMPTY
39994: PPUSH
39995: CALL_OW 1
39999: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
40000: LD_ADDR_EXP 110
40004: PUSH
40005: LD_EXP 110
40009: PPUSH
40010: LD_VAR 0 1
40014: PPUSH
40015: EMPTY
40016: PPUSH
40017: CALL_OW 1
40021: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
40022: LD_ADDR_EXP 111
40026: PUSH
40027: LD_EXP 111
40031: PPUSH
40032: LD_VAR 0 1
40036: PPUSH
40037: EMPTY
40038: PPUSH
40039: CALL_OW 1
40043: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
40044: LD_ADDR_EXP 112
40048: PUSH
40049: LD_EXP 112
40053: PPUSH
40054: LD_VAR 0 1
40058: PPUSH
40059: EMPTY
40060: PPUSH
40061: CALL_OW 1
40065: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
40066: LD_ADDR_EXP 113
40070: PUSH
40071: LD_EXP 113
40075: PPUSH
40076: LD_VAR 0 1
40080: PPUSH
40081: LD_INT 0
40083: PPUSH
40084: CALL_OW 1
40088: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
40089: LD_ADDR_EXP 114
40093: PUSH
40094: LD_EXP 114
40098: PPUSH
40099: LD_VAR 0 1
40103: PPUSH
40104: EMPTY
40105: PPUSH
40106: CALL_OW 1
40110: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
40111: LD_ADDR_EXP 115
40115: PUSH
40116: LD_EXP 115
40120: PPUSH
40121: LD_VAR 0 1
40125: PPUSH
40126: EMPTY
40127: PPUSH
40128: CALL_OW 1
40132: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
40133: LD_ADDR_EXP 116
40137: PUSH
40138: LD_EXP 116
40142: PPUSH
40143: LD_VAR 0 1
40147: PPUSH
40148: EMPTY
40149: PPUSH
40150: CALL_OW 1
40154: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
40155: LD_ADDR_EXP 117
40159: PUSH
40160: LD_EXP 117
40164: PPUSH
40165: LD_VAR 0 1
40169: PPUSH
40170: EMPTY
40171: PPUSH
40172: CALL_OW 1
40176: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
40177: LD_ADDR_EXP 118
40181: PUSH
40182: LD_EXP 118
40186: PPUSH
40187: LD_VAR 0 1
40191: PPUSH
40192: EMPTY
40193: PPUSH
40194: CALL_OW 1
40198: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
40199: LD_ADDR_EXP 119
40203: PUSH
40204: LD_EXP 119
40208: PPUSH
40209: LD_VAR 0 1
40213: PPUSH
40214: EMPTY
40215: PPUSH
40216: CALL_OW 1
40220: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
40221: LD_ADDR_EXP 120
40225: PUSH
40226: LD_EXP 120
40230: PPUSH
40231: LD_VAR 0 1
40235: PPUSH
40236: EMPTY
40237: PPUSH
40238: CALL_OW 1
40242: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
40243: LD_ADDR_EXP 121
40247: PUSH
40248: LD_EXP 121
40252: PPUSH
40253: LD_VAR 0 1
40257: PPUSH
40258: EMPTY
40259: PPUSH
40260: CALL_OW 1
40264: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
40265: LD_ADDR_EXP 122
40269: PUSH
40270: LD_EXP 122
40274: PPUSH
40275: LD_VAR 0 1
40279: PPUSH
40280: EMPTY
40281: PPUSH
40282: CALL_OW 1
40286: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
40287: LD_ADDR_EXP 123
40291: PUSH
40292: LD_EXP 123
40296: PPUSH
40297: LD_VAR 0 1
40301: PPUSH
40302: EMPTY
40303: PPUSH
40304: CALL_OW 1
40308: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
40309: LD_ADDR_EXP 124
40313: PUSH
40314: LD_EXP 124
40318: PPUSH
40319: LD_VAR 0 1
40323: PPUSH
40324: EMPTY
40325: PPUSH
40326: CALL_OW 1
40330: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
40331: LD_ADDR_EXP 125
40335: PUSH
40336: LD_EXP 125
40340: PPUSH
40341: LD_VAR 0 1
40345: PPUSH
40346: EMPTY
40347: PPUSH
40348: CALL_OW 1
40352: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
40353: LD_ADDR_EXP 126
40357: PUSH
40358: LD_EXP 126
40362: PPUSH
40363: LD_VAR 0 1
40367: PPUSH
40368: EMPTY
40369: PPUSH
40370: CALL_OW 1
40374: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
40375: LD_ADDR_EXP 127
40379: PUSH
40380: LD_EXP 127
40384: PPUSH
40385: LD_VAR 0 1
40389: PPUSH
40390: EMPTY
40391: PPUSH
40392: CALL_OW 1
40396: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
40397: LD_ADDR_EXP 129
40401: PUSH
40402: LD_EXP 129
40406: PPUSH
40407: LD_VAR 0 1
40411: PPUSH
40412: EMPTY
40413: PPUSH
40414: CALL_OW 1
40418: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
40419: LD_ADDR_EXP 131
40423: PUSH
40424: LD_EXP 131
40428: PPUSH
40429: LD_VAR 0 1
40433: PPUSH
40434: EMPTY
40435: PPUSH
40436: CALL_OW 1
40440: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
40441: LD_ADDR_EXP 132
40445: PUSH
40446: LD_EXP 132
40450: PPUSH
40451: LD_VAR 0 1
40455: PPUSH
40456: EMPTY
40457: PPUSH
40458: CALL_OW 1
40462: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
40463: LD_ADDR_EXP 133
40467: PUSH
40468: LD_EXP 133
40472: PPUSH
40473: LD_VAR 0 1
40477: PPUSH
40478: EMPTY
40479: PPUSH
40480: CALL_OW 1
40484: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
40485: LD_ADDR_EXP 134
40489: PUSH
40490: LD_EXP 134
40494: PPUSH
40495: LD_VAR 0 1
40499: PPUSH
40500: EMPTY
40501: PPUSH
40502: CALL_OW 1
40506: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
40507: LD_ADDR_EXP 135
40511: PUSH
40512: LD_EXP 135
40516: PPUSH
40517: LD_VAR 0 1
40521: PPUSH
40522: EMPTY
40523: PPUSH
40524: CALL_OW 1
40528: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
40529: LD_ADDR_EXP 136
40533: PUSH
40534: LD_EXP 136
40538: PPUSH
40539: LD_VAR 0 1
40543: PPUSH
40544: EMPTY
40545: PPUSH
40546: CALL_OW 1
40550: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
40551: LD_ADDR_EXP 137
40555: PUSH
40556: LD_EXP 137
40560: PPUSH
40561: LD_VAR 0 1
40565: PPUSH
40566: EMPTY
40567: PPUSH
40568: CALL_OW 1
40572: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
40573: LD_ADDR_EXP 138
40577: PUSH
40578: LD_EXP 138
40582: PPUSH
40583: LD_VAR 0 1
40587: PPUSH
40588: EMPTY
40589: PPUSH
40590: CALL_OW 1
40594: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
40595: LD_ADDR_EXP 139
40599: PUSH
40600: LD_EXP 139
40604: PPUSH
40605: LD_VAR 0 1
40609: PPUSH
40610: EMPTY
40611: PPUSH
40612: CALL_OW 1
40616: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
40617: LD_ADDR_EXP 140
40621: PUSH
40622: LD_EXP 140
40626: PPUSH
40627: LD_VAR 0 1
40631: PPUSH
40632: EMPTY
40633: PPUSH
40634: CALL_OW 1
40638: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
40639: LD_ADDR_EXP 141
40643: PUSH
40644: LD_EXP 141
40648: PPUSH
40649: LD_VAR 0 1
40653: PPUSH
40654: EMPTY
40655: PPUSH
40656: CALL_OW 1
40660: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
40661: LD_ADDR_EXP 142
40665: PUSH
40666: LD_EXP 142
40670: PPUSH
40671: LD_VAR 0 1
40675: PPUSH
40676: EMPTY
40677: PPUSH
40678: CALL_OW 1
40682: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
40683: LD_ADDR_EXP 143
40687: PUSH
40688: LD_EXP 143
40692: PPUSH
40693: LD_VAR 0 1
40697: PPUSH
40698: EMPTY
40699: PPUSH
40700: CALL_OW 1
40704: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
40705: LD_ADDR_EXP 144
40709: PUSH
40710: LD_EXP 144
40714: PPUSH
40715: LD_VAR 0 1
40719: PPUSH
40720: LD_INT 0
40722: PPUSH
40723: CALL_OW 1
40727: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
40728: LD_ADDR_EXP 145
40732: PUSH
40733: LD_EXP 145
40737: PPUSH
40738: LD_VAR 0 1
40742: PPUSH
40743: LD_INT 0
40745: PPUSH
40746: CALL_OW 1
40750: ST_TO_ADDR
// end ;
40751: LD_VAR 0 2
40755: RET
// export function MC_Add ( side , units ) ; var base ; begin
40756: LD_INT 0
40758: PPUSH
40759: PPUSH
// base := mc_bases + 1 ;
40760: LD_ADDR_VAR 0 4
40764: PUSH
40765: LD_EXP 102
40769: PUSH
40770: LD_INT 1
40772: PLUS
40773: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
40774: LD_ADDR_EXP 128
40778: PUSH
40779: LD_EXP 128
40783: PPUSH
40784: LD_VAR 0 4
40788: PPUSH
40789: LD_VAR 0 1
40793: PPUSH
40794: CALL_OW 1
40798: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
40799: LD_ADDR_EXP 102
40803: PUSH
40804: LD_EXP 102
40808: PPUSH
40809: LD_VAR 0 4
40813: PPUSH
40814: LD_VAR 0 2
40818: PPUSH
40819: CALL_OW 1
40823: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
40824: LD_ADDR_EXP 103
40828: PUSH
40829: LD_EXP 103
40833: PPUSH
40834: LD_VAR 0 4
40838: PPUSH
40839: EMPTY
40840: PPUSH
40841: CALL_OW 1
40845: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
40846: LD_ADDR_EXP 104
40850: PUSH
40851: LD_EXP 104
40855: PPUSH
40856: LD_VAR 0 4
40860: PPUSH
40861: EMPTY
40862: PPUSH
40863: CALL_OW 1
40867: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
40868: LD_ADDR_EXP 105
40872: PUSH
40873: LD_EXP 105
40877: PPUSH
40878: LD_VAR 0 4
40882: PPUSH
40883: EMPTY
40884: PPUSH
40885: CALL_OW 1
40889: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
40890: LD_ADDR_EXP 106
40894: PUSH
40895: LD_EXP 106
40899: PPUSH
40900: LD_VAR 0 4
40904: PPUSH
40905: EMPTY
40906: PPUSH
40907: CALL_OW 1
40911: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
40912: LD_ADDR_EXP 107
40916: PUSH
40917: LD_EXP 107
40921: PPUSH
40922: LD_VAR 0 4
40926: PPUSH
40927: EMPTY
40928: PPUSH
40929: CALL_OW 1
40933: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
40934: LD_ADDR_EXP 108
40938: PUSH
40939: LD_EXP 108
40943: PPUSH
40944: LD_VAR 0 4
40948: PPUSH
40949: EMPTY
40950: PPUSH
40951: CALL_OW 1
40955: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
40956: LD_ADDR_EXP 109
40960: PUSH
40961: LD_EXP 109
40965: PPUSH
40966: LD_VAR 0 4
40970: PPUSH
40971: EMPTY
40972: PPUSH
40973: CALL_OW 1
40977: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
40978: LD_ADDR_EXP 110
40982: PUSH
40983: LD_EXP 110
40987: PPUSH
40988: LD_VAR 0 4
40992: PPUSH
40993: EMPTY
40994: PPUSH
40995: CALL_OW 1
40999: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
41000: LD_ADDR_EXP 111
41004: PUSH
41005: LD_EXP 111
41009: PPUSH
41010: LD_VAR 0 4
41014: PPUSH
41015: EMPTY
41016: PPUSH
41017: CALL_OW 1
41021: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
41022: LD_ADDR_EXP 112
41026: PUSH
41027: LD_EXP 112
41031: PPUSH
41032: LD_VAR 0 4
41036: PPUSH
41037: EMPTY
41038: PPUSH
41039: CALL_OW 1
41043: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
41044: LD_ADDR_EXP 113
41048: PUSH
41049: LD_EXP 113
41053: PPUSH
41054: LD_VAR 0 4
41058: PPUSH
41059: LD_INT 0
41061: PPUSH
41062: CALL_OW 1
41066: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
41067: LD_ADDR_EXP 114
41071: PUSH
41072: LD_EXP 114
41076: PPUSH
41077: LD_VAR 0 4
41081: PPUSH
41082: EMPTY
41083: PPUSH
41084: CALL_OW 1
41088: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
41089: LD_ADDR_EXP 115
41093: PUSH
41094: LD_EXP 115
41098: PPUSH
41099: LD_VAR 0 4
41103: PPUSH
41104: EMPTY
41105: PPUSH
41106: CALL_OW 1
41110: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
41111: LD_ADDR_EXP 116
41115: PUSH
41116: LD_EXP 116
41120: PPUSH
41121: LD_VAR 0 4
41125: PPUSH
41126: EMPTY
41127: PPUSH
41128: CALL_OW 1
41132: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
41133: LD_ADDR_EXP 117
41137: PUSH
41138: LD_EXP 117
41142: PPUSH
41143: LD_VAR 0 4
41147: PPUSH
41148: EMPTY
41149: PPUSH
41150: CALL_OW 1
41154: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
41155: LD_ADDR_EXP 118
41159: PUSH
41160: LD_EXP 118
41164: PPUSH
41165: LD_VAR 0 4
41169: PPUSH
41170: EMPTY
41171: PPUSH
41172: CALL_OW 1
41176: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
41177: LD_ADDR_EXP 119
41181: PUSH
41182: LD_EXP 119
41186: PPUSH
41187: LD_VAR 0 4
41191: PPUSH
41192: EMPTY
41193: PPUSH
41194: CALL_OW 1
41198: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
41199: LD_ADDR_EXP 120
41203: PUSH
41204: LD_EXP 120
41208: PPUSH
41209: LD_VAR 0 4
41213: PPUSH
41214: EMPTY
41215: PPUSH
41216: CALL_OW 1
41220: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
41221: LD_ADDR_EXP 121
41225: PUSH
41226: LD_EXP 121
41230: PPUSH
41231: LD_VAR 0 4
41235: PPUSH
41236: EMPTY
41237: PPUSH
41238: CALL_OW 1
41242: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
41243: LD_ADDR_EXP 122
41247: PUSH
41248: LD_EXP 122
41252: PPUSH
41253: LD_VAR 0 4
41257: PPUSH
41258: EMPTY
41259: PPUSH
41260: CALL_OW 1
41264: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
41265: LD_ADDR_EXP 123
41269: PUSH
41270: LD_EXP 123
41274: PPUSH
41275: LD_VAR 0 4
41279: PPUSH
41280: EMPTY
41281: PPUSH
41282: CALL_OW 1
41286: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
41287: LD_ADDR_EXP 124
41291: PUSH
41292: LD_EXP 124
41296: PPUSH
41297: LD_VAR 0 4
41301: PPUSH
41302: EMPTY
41303: PPUSH
41304: CALL_OW 1
41308: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
41309: LD_ADDR_EXP 125
41313: PUSH
41314: LD_EXP 125
41318: PPUSH
41319: LD_VAR 0 4
41323: PPUSH
41324: EMPTY
41325: PPUSH
41326: CALL_OW 1
41330: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
41331: LD_ADDR_EXP 126
41335: PUSH
41336: LD_EXP 126
41340: PPUSH
41341: LD_VAR 0 4
41345: PPUSH
41346: EMPTY
41347: PPUSH
41348: CALL_OW 1
41352: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
41353: LD_ADDR_EXP 127
41357: PUSH
41358: LD_EXP 127
41362: PPUSH
41363: LD_VAR 0 4
41367: PPUSH
41368: EMPTY
41369: PPUSH
41370: CALL_OW 1
41374: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
41375: LD_ADDR_EXP 129
41379: PUSH
41380: LD_EXP 129
41384: PPUSH
41385: LD_VAR 0 4
41389: PPUSH
41390: EMPTY
41391: PPUSH
41392: CALL_OW 1
41396: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
41397: LD_ADDR_EXP 131
41401: PUSH
41402: LD_EXP 131
41406: PPUSH
41407: LD_VAR 0 4
41411: PPUSH
41412: EMPTY
41413: PPUSH
41414: CALL_OW 1
41418: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
41419: LD_ADDR_EXP 132
41423: PUSH
41424: LD_EXP 132
41428: PPUSH
41429: LD_VAR 0 4
41433: PPUSH
41434: EMPTY
41435: PPUSH
41436: CALL_OW 1
41440: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
41441: LD_ADDR_EXP 133
41445: PUSH
41446: LD_EXP 133
41450: PPUSH
41451: LD_VAR 0 4
41455: PPUSH
41456: EMPTY
41457: PPUSH
41458: CALL_OW 1
41462: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
41463: LD_ADDR_EXP 134
41467: PUSH
41468: LD_EXP 134
41472: PPUSH
41473: LD_VAR 0 4
41477: PPUSH
41478: EMPTY
41479: PPUSH
41480: CALL_OW 1
41484: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
41485: LD_ADDR_EXP 135
41489: PUSH
41490: LD_EXP 135
41494: PPUSH
41495: LD_VAR 0 4
41499: PPUSH
41500: EMPTY
41501: PPUSH
41502: CALL_OW 1
41506: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
41507: LD_ADDR_EXP 136
41511: PUSH
41512: LD_EXP 136
41516: PPUSH
41517: LD_VAR 0 4
41521: PPUSH
41522: EMPTY
41523: PPUSH
41524: CALL_OW 1
41528: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
41529: LD_ADDR_EXP 137
41533: PUSH
41534: LD_EXP 137
41538: PPUSH
41539: LD_VAR 0 4
41543: PPUSH
41544: EMPTY
41545: PPUSH
41546: CALL_OW 1
41550: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
41551: LD_ADDR_EXP 138
41555: PUSH
41556: LD_EXP 138
41560: PPUSH
41561: LD_VAR 0 4
41565: PPUSH
41566: EMPTY
41567: PPUSH
41568: CALL_OW 1
41572: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
41573: LD_ADDR_EXP 139
41577: PUSH
41578: LD_EXP 139
41582: PPUSH
41583: LD_VAR 0 4
41587: PPUSH
41588: EMPTY
41589: PPUSH
41590: CALL_OW 1
41594: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
41595: LD_ADDR_EXP 140
41599: PUSH
41600: LD_EXP 140
41604: PPUSH
41605: LD_VAR 0 4
41609: PPUSH
41610: EMPTY
41611: PPUSH
41612: CALL_OW 1
41616: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
41617: LD_ADDR_EXP 141
41621: PUSH
41622: LD_EXP 141
41626: PPUSH
41627: LD_VAR 0 4
41631: PPUSH
41632: EMPTY
41633: PPUSH
41634: CALL_OW 1
41638: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
41639: LD_ADDR_EXP 142
41643: PUSH
41644: LD_EXP 142
41648: PPUSH
41649: LD_VAR 0 4
41653: PPUSH
41654: EMPTY
41655: PPUSH
41656: CALL_OW 1
41660: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
41661: LD_ADDR_EXP 143
41665: PUSH
41666: LD_EXP 143
41670: PPUSH
41671: LD_VAR 0 4
41675: PPUSH
41676: EMPTY
41677: PPUSH
41678: CALL_OW 1
41682: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
41683: LD_ADDR_EXP 144
41687: PUSH
41688: LD_EXP 144
41692: PPUSH
41693: LD_VAR 0 4
41697: PPUSH
41698: LD_INT 0
41700: PPUSH
41701: CALL_OW 1
41705: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
41706: LD_ADDR_EXP 145
41710: PUSH
41711: LD_EXP 145
41715: PPUSH
41716: LD_VAR 0 4
41720: PPUSH
41721: LD_INT 0
41723: PPUSH
41724: CALL_OW 1
41728: ST_TO_ADDR
// result := base ;
41729: LD_ADDR_VAR 0 3
41733: PUSH
41734: LD_VAR 0 4
41738: ST_TO_ADDR
// end ;
41739: LD_VAR 0 3
41743: RET
// export function MC_Start ( ) ; var i ; begin
41744: LD_INT 0
41746: PPUSH
41747: PPUSH
// for i = 1 to mc_bases do
41748: LD_ADDR_VAR 0 2
41752: PUSH
41753: DOUBLE
41754: LD_INT 1
41756: DEC
41757: ST_TO_ADDR
41758: LD_EXP 102
41762: PUSH
41763: FOR_TO
41764: IFFALSE 42864
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
41766: LD_ADDR_EXP 102
41770: PUSH
41771: LD_EXP 102
41775: PPUSH
41776: LD_VAR 0 2
41780: PPUSH
41781: LD_EXP 102
41785: PUSH
41786: LD_VAR 0 2
41790: ARRAY
41791: PUSH
41792: LD_INT 0
41794: DIFF
41795: PPUSH
41796: CALL_OW 1
41800: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
41801: LD_ADDR_EXP 103
41805: PUSH
41806: LD_EXP 103
41810: PPUSH
41811: LD_VAR 0 2
41815: PPUSH
41816: EMPTY
41817: PPUSH
41818: CALL_OW 1
41822: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
41823: LD_ADDR_EXP 104
41827: PUSH
41828: LD_EXP 104
41832: PPUSH
41833: LD_VAR 0 2
41837: PPUSH
41838: EMPTY
41839: PPUSH
41840: CALL_OW 1
41844: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
41845: LD_ADDR_EXP 105
41849: PUSH
41850: LD_EXP 105
41854: PPUSH
41855: LD_VAR 0 2
41859: PPUSH
41860: EMPTY
41861: PPUSH
41862: CALL_OW 1
41866: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
41867: LD_ADDR_EXP 106
41871: PUSH
41872: LD_EXP 106
41876: PPUSH
41877: LD_VAR 0 2
41881: PPUSH
41882: EMPTY
41883: PUSH
41884: EMPTY
41885: PUSH
41886: EMPTY
41887: LIST
41888: LIST
41889: PPUSH
41890: CALL_OW 1
41894: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
41895: LD_ADDR_EXP 107
41899: PUSH
41900: LD_EXP 107
41904: PPUSH
41905: LD_VAR 0 2
41909: PPUSH
41910: EMPTY
41911: PPUSH
41912: CALL_OW 1
41916: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
41917: LD_ADDR_EXP 134
41921: PUSH
41922: LD_EXP 134
41926: PPUSH
41927: LD_VAR 0 2
41931: PPUSH
41932: EMPTY
41933: PPUSH
41934: CALL_OW 1
41938: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
41939: LD_ADDR_EXP 108
41943: PUSH
41944: LD_EXP 108
41948: PPUSH
41949: LD_VAR 0 2
41953: PPUSH
41954: EMPTY
41955: PPUSH
41956: CALL_OW 1
41960: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
41961: LD_ADDR_EXP 109
41965: PUSH
41966: LD_EXP 109
41970: PPUSH
41971: LD_VAR 0 2
41975: PPUSH
41976: EMPTY
41977: PPUSH
41978: CALL_OW 1
41982: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
41983: LD_ADDR_EXP 110
41987: PUSH
41988: LD_EXP 110
41992: PPUSH
41993: LD_VAR 0 2
41997: PPUSH
41998: LD_EXP 102
42002: PUSH
42003: LD_VAR 0 2
42007: ARRAY
42008: PPUSH
42009: LD_INT 2
42011: PUSH
42012: LD_INT 30
42014: PUSH
42015: LD_INT 32
42017: PUSH
42018: EMPTY
42019: LIST
42020: LIST
42021: PUSH
42022: LD_INT 30
42024: PUSH
42025: LD_INT 33
42027: PUSH
42028: EMPTY
42029: LIST
42030: LIST
42031: PUSH
42032: EMPTY
42033: LIST
42034: LIST
42035: LIST
42036: PPUSH
42037: CALL_OW 72
42041: PPUSH
42042: CALL_OW 1
42046: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
42047: LD_ADDR_EXP 111
42051: PUSH
42052: LD_EXP 111
42056: PPUSH
42057: LD_VAR 0 2
42061: PPUSH
42062: LD_EXP 102
42066: PUSH
42067: LD_VAR 0 2
42071: ARRAY
42072: PPUSH
42073: LD_INT 2
42075: PUSH
42076: LD_INT 30
42078: PUSH
42079: LD_INT 32
42081: PUSH
42082: EMPTY
42083: LIST
42084: LIST
42085: PUSH
42086: LD_INT 30
42088: PUSH
42089: LD_INT 31
42091: PUSH
42092: EMPTY
42093: LIST
42094: LIST
42095: PUSH
42096: EMPTY
42097: LIST
42098: LIST
42099: LIST
42100: PUSH
42101: LD_INT 58
42103: PUSH
42104: EMPTY
42105: LIST
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PPUSH
42111: CALL_OW 72
42115: PPUSH
42116: CALL_OW 1
42120: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
42121: LD_ADDR_EXP 112
42125: PUSH
42126: LD_EXP 112
42130: PPUSH
42131: LD_VAR 0 2
42135: PPUSH
42136: EMPTY
42137: PPUSH
42138: CALL_OW 1
42142: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
42143: LD_ADDR_EXP 116
42147: PUSH
42148: LD_EXP 116
42152: PPUSH
42153: LD_VAR 0 2
42157: PPUSH
42158: EMPTY
42159: PPUSH
42160: CALL_OW 1
42164: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
42165: LD_ADDR_EXP 115
42169: PUSH
42170: LD_EXP 115
42174: PPUSH
42175: LD_VAR 0 2
42179: PPUSH
42180: EMPTY
42181: PPUSH
42182: CALL_OW 1
42186: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
42187: LD_ADDR_EXP 117
42191: PUSH
42192: LD_EXP 117
42196: PPUSH
42197: LD_VAR 0 2
42201: PPUSH
42202: EMPTY
42203: PPUSH
42204: CALL_OW 1
42208: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
42209: LD_ADDR_EXP 118
42213: PUSH
42214: LD_EXP 118
42218: PPUSH
42219: LD_VAR 0 2
42223: PPUSH
42224: EMPTY
42225: PPUSH
42226: CALL_OW 1
42230: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
42231: LD_ADDR_EXP 119
42235: PUSH
42236: LD_EXP 119
42240: PPUSH
42241: LD_VAR 0 2
42245: PPUSH
42246: EMPTY
42247: PPUSH
42248: CALL_OW 1
42252: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
42253: LD_ADDR_EXP 120
42257: PUSH
42258: LD_EXP 120
42262: PPUSH
42263: LD_VAR 0 2
42267: PPUSH
42268: EMPTY
42269: PPUSH
42270: CALL_OW 1
42274: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
42275: LD_ADDR_EXP 121
42279: PUSH
42280: LD_EXP 121
42284: PPUSH
42285: LD_VAR 0 2
42289: PPUSH
42290: EMPTY
42291: PPUSH
42292: CALL_OW 1
42296: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
42297: LD_ADDR_EXP 122
42301: PUSH
42302: LD_EXP 122
42306: PPUSH
42307: LD_VAR 0 2
42311: PPUSH
42312: EMPTY
42313: PPUSH
42314: CALL_OW 1
42318: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
42319: LD_ADDR_EXP 123
42323: PUSH
42324: LD_EXP 123
42328: PPUSH
42329: LD_VAR 0 2
42333: PPUSH
42334: EMPTY
42335: PPUSH
42336: CALL_OW 1
42340: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
42341: LD_ADDR_EXP 124
42345: PUSH
42346: LD_EXP 124
42350: PPUSH
42351: LD_VAR 0 2
42355: PPUSH
42356: EMPTY
42357: PPUSH
42358: CALL_OW 1
42362: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
42363: LD_ADDR_EXP 113
42367: PUSH
42368: LD_EXP 113
42372: PPUSH
42373: LD_VAR 0 2
42377: PPUSH
42378: LD_INT 0
42380: PPUSH
42381: CALL_OW 1
42385: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
42386: LD_ADDR_EXP 126
42390: PUSH
42391: LD_EXP 126
42395: PPUSH
42396: LD_VAR 0 2
42400: PPUSH
42401: LD_INT 0
42403: PPUSH
42404: CALL_OW 1
42408: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
42409: LD_ADDR_EXP 114
42413: PUSH
42414: LD_EXP 114
42418: PPUSH
42419: LD_VAR 0 2
42423: PPUSH
42424: EMPTY
42425: PPUSH
42426: CALL_OW 1
42430: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
42431: LD_ADDR_EXP 125
42435: PUSH
42436: LD_EXP 125
42440: PPUSH
42441: LD_VAR 0 2
42445: PPUSH
42446: LD_INT 0
42448: PPUSH
42449: CALL_OW 1
42453: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
42454: LD_ADDR_EXP 127
42458: PUSH
42459: LD_EXP 127
42463: PPUSH
42464: LD_VAR 0 2
42468: PPUSH
42469: EMPTY
42470: PPUSH
42471: CALL_OW 1
42475: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
42476: LD_ADDR_EXP 130
42480: PUSH
42481: LD_EXP 130
42485: PPUSH
42486: LD_VAR 0 2
42490: PPUSH
42491: LD_INT 0
42493: PPUSH
42494: CALL_OW 1
42498: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
42499: LD_ADDR_EXP 131
42503: PUSH
42504: LD_EXP 131
42508: PPUSH
42509: LD_VAR 0 2
42513: PPUSH
42514: EMPTY
42515: PPUSH
42516: CALL_OW 1
42520: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
42521: LD_ADDR_EXP 132
42525: PUSH
42526: LD_EXP 132
42530: PPUSH
42531: LD_VAR 0 2
42535: PPUSH
42536: EMPTY
42537: PPUSH
42538: CALL_OW 1
42542: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
42543: LD_ADDR_EXP 133
42547: PUSH
42548: LD_EXP 133
42552: PPUSH
42553: LD_VAR 0 2
42557: PPUSH
42558: EMPTY
42559: PPUSH
42560: CALL_OW 1
42564: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
42565: LD_ADDR_EXP 135
42569: PUSH
42570: LD_EXP 135
42574: PPUSH
42575: LD_VAR 0 2
42579: PPUSH
42580: LD_EXP 102
42584: PUSH
42585: LD_VAR 0 2
42589: ARRAY
42590: PPUSH
42591: LD_INT 2
42593: PUSH
42594: LD_INT 30
42596: PUSH
42597: LD_INT 6
42599: PUSH
42600: EMPTY
42601: LIST
42602: LIST
42603: PUSH
42604: LD_INT 30
42606: PUSH
42607: LD_INT 7
42609: PUSH
42610: EMPTY
42611: LIST
42612: LIST
42613: PUSH
42614: LD_INT 30
42616: PUSH
42617: LD_INT 8
42619: PUSH
42620: EMPTY
42621: LIST
42622: LIST
42623: PUSH
42624: EMPTY
42625: LIST
42626: LIST
42627: LIST
42628: LIST
42629: PPUSH
42630: CALL_OW 72
42634: PPUSH
42635: CALL_OW 1
42639: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
42640: LD_ADDR_EXP 136
42644: PUSH
42645: LD_EXP 136
42649: PPUSH
42650: LD_VAR 0 2
42654: PPUSH
42655: EMPTY
42656: PPUSH
42657: CALL_OW 1
42661: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
42662: LD_ADDR_EXP 137
42666: PUSH
42667: LD_EXP 137
42671: PPUSH
42672: LD_VAR 0 2
42676: PPUSH
42677: EMPTY
42678: PPUSH
42679: CALL_OW 1
42683: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
42684: LD_ADDR_EXP 138
42688: PUSH
42689: LD_EXP 138
42693: PPUSH
42694: LD_VAR 0 2
42698: PPUSH
42699: EMPTY
42700: PPUSH
42701: CALL_OW 1
42705: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
42706: LD_ADDR_EXP 139
42710: PUSH
42711: LD_EXP 139
42715: PPUSH
42716: LD_VAR 0 2
42720: PPUSH
42721: EMPTY
42722: PPUSH
42723: CALL_OW 1
42727: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42728: LD_ADDR_EXP 140
42732: PUSH
42733: LD_EXP 140
42737: PPUSH
42738: LD_VAR 0 2
42742: PPUSH
42743: EMPTY
42744: PPUSH
42745: CALL_OW 1
42749: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
42750: LD_ADDR_EXP 141
42754: PUSH
42755: LD_EXP 141
42759: PPUSH
42760: LD_VAR 0 2
42764: PPUSH
42765: EMPTY
42766: PPUSH
42767: CALL_OW 1
42771: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
42772: LD_ADDR_EXP 142
42776: PUSH
42777: LD_EXP 142
42781: PPUSH
42782: LD_VAR 0 2
42786: PPUSH
42787: EMPTY
42788: PPUSH
42789: CALL_OW 1
42793: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
42794: LD_ADDR_EXP 143
42798: PUSH
42799: LD_EXP 143
42803: PPUSH
42804: LD_VAR 0 2
42808: PPUSH
42809: EMPTY
42810: PPUSH
42811: CALL_OW 1
42815: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
42816: LD_ADDR_EXP 144
42820: PUSH
42821: LD_EXP 144
42825: PPUSH
42826: LD_VAR 0 2
42830: PPUSH
42831: LD_INT 0
42833: PPUSH
42834: CALL_OW 1
42838: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
42839: LD_ADDR_EXP 145
42843: PUSH
42844: LD_EXP 145
42848: PPUSH
42849: LD_VAR 0 2
42853: PPUSH
42854: LD_INT 0
42856: PPUSH
42857: CALL_OW 1
42861: ST_TO_ADDR
// end ;
42862: GO 41763
42864: POP
42865: POP
// MC_InitSides ( ) ;
42866: CALL 43152 0 0
// MC_InitResearch ( ) ;
42870: CALL 42891 0 0
// CustomInitMacro ( ) ;
42874: CALL 475 0 0
// skirmish := true ;
42878: LD_ADDR_EXP 100
42882: PUSH
42883: LD_INT 1
42885: ST_TO_ADDR
// end ;
42886: LD_VAR 0 1
42890: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
42891: LD_INT 0
42893: PPUSH
42894: PPUSH
42895: PPUSH
42896: PPUSH
42897: PPUSH
42898: PPUSH
// if not mc_bases then
42899: LD_EXP 102
42903: NOT
42904: IFFALSE 42908
// exit ;
42906: GO 43147
// for i = 1 to 8 do
42908: LD_ADDR_VAR 0 2
42912: PUSH
42913: DOUBLE
42914: LD_INT 1
42916: DEC
42917: ST_TO_ADDR
42918: LD_INT 8
42920: PUSH
42921: FOR_TO
42922: IFFALSE 42948
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
42924: LD_ADDR_EXP 129
42928: PUSH
42929: LD_EXP 129
42933: PPUSH
42934: LD_VAR 0 2
42938: PPUSH
42939: EMPTY
42940: PPUSH
42941: CALL_OW 1
42945: ST_TO_ADDR
42946: GO 42921
42948: POP
42949: POP
// tmp := [ ] ;
42950: LD_ADDR_VAR 0 5
42954: PUSH
42955: EMPTY
42956: ST_TO_ADDR
// for i = 1 to mc_sides do
42957: LD_ADDR_VAR 0 2
42961: PUSH
42962: DOUBLE
42963: LD_INT 1
42965: DEC
42966: ST_TO_ADDR
42967: LD_EXP 128
42971: PUSH
42972: FOR_TO
42973: IFFALSE 43031
// if not mc_sides [ i ] in tmp then
42975: LD_EXP 128
42979: PUSH
42980: LD_VAR 0 2
42984: ARRAY
42985: PUSH
42986: LD_VAR 0 5
42990: IN
42991: NOT
42992: IFFALSE 43029
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
42994: LD_ADDR_VAR 0 5
42998: PUSH
42999: LD_VAR 0 5
43003: PPUSH
43004: LD_VAR 0 5
43008: PUSH
43009: LD_INT 1
43011: PLUS
43012: PPUSH
43013: LD_EXP 128
43017: PUSH
43018: LD_VAR 0 2
43022: ARRAY
43023: PPUSH
43024: CALL_OW 2
43028: ST_TO_ADDR
43029: GO 42972
43031: POP
43032: POP
// if not tmp then
43033: LD_VAR 0 5
43037: NOT
43038: IFFALSE 43042
// exit ;
43040: GO 43147
// for j in tmp do
43042: LD_ADDR_VAR 0 3
43046: PUSH
43047: LD_VAR 0 5
43051: PUSH
43052: FOR_IN
43053: IFFALSE 43145
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
43055: LD_ADDR_VAR 0 6
43059: PUSH
43060: LD_INT 22
43062: PUSH
43063: LD_VAR 0 3
43067: PUSH
43068: EMPTY
43069: LIST
43070: LIST
43071: PPUSH
43072: CALL_OW 69
43076: ST_TO_ADDR
// if not un then
43077: LD_VAR 0 6
43081: NOT
43082: IFFALSE 43086
// continue ;
43084: GO 43052
// nation := GetNation ( un [ 1 ] ) ;
43086: LD_ADDR_VAR 0 4
43090: PUSH
43091: LD_VAR 0 6
43095: PUSH
43096: LD_INT 1
43098: ARRAY
43099: PPUSH
43100: CALL_OW 248
43104: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
43105: LD_ADDR_EXP 129
43109: PUSH
43110: LD_EXP 129
43114: PPUSH
43115: LD_VAR 0 3
43119: PPUSH
43120: LD_VAR 0 3
43124: PPUSH
43125: LD_VAR 0 4
43129: PPUSH
43130: LD_INT 1
43132: PPUSH
43133: CALL 70356 0 3
43137: PPUSH
43138: CALL_OW 1
43142: ST_TO_ADDR
// end ;
43143: GO 43052
43145: POP
43146: POP
// end ;
43147: LD_VAR 0 1
43151: RET
// export function MC_InitSides ( ) ; var i ; begin
43152: LD_INT 0
43154: PPUSH
43155: PPUSH
// if not mc_bases then
43156: LD_EXP 102
43160: NOT
43161: IFFALSE 43165
// exit ;
43163: GO 43239
// for i = 1 to mc_bases do
43165: LD_ADDR_VAR 0 2
43169: PUSH
43170: DOUBLE
43171: LD_INT 1
43173: DEC
43174: ST_TO_ADDR
43175: LD_EXP 102
43179: PUSH
43180: FOR_TO
43181: IFFALSE 43237
// if mc_bases [ i ] then
43183: LD_EXP 102
43187: PUSH
43188: LD_VAR 0 2
43192: ARRAY
43193: IFFALSE 43235
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
43195: LD_ADDR_EXP 128
43199: PUSH
43200: LD_EXP 128
43204: PPUSH
43205: LD_VAR 0 2
43209: PPUSH
43210: LD_EXP 102
43214: PUSH
43215: LD_VAR 0 2
43219: ARRAY
43220: PUSH
43221: LD_INT 1
43223: ARRAY
43224: PPUSH
43225: CALL_OW 255
43229: PPUSH
43230: CALL_OW 1
43234: ST_TO_ADDR
43235: GO 43180
43237: POP
43238: POP
// end ;
43239: LD_VAR 0 1
43243: RET
// every 0 0$03 trigger skirmish do
43244: LD_EXP 100
43248: IFFALSE 43402
43250: GO 43252
43252: DISABLE
// begin enable ;
43253: ENABLE
// MC_CheckBuildings ( ) ;
43254: CALL 47914 0 0
// MC_CheckPeopleLife ( ) ;
43258: CALL 48075 0 0
// RaiseSailEvent ( 100 ) ;
43262: LD_INT 100
43264: PPUSH
43265: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
43269: LD_INT 103
43271: PPUSH
43272: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
43276: LD_INT 104
43278: PPUSH
43279: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
43283: LD_INT 105
43285: PPUSH
43286: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
43290: LD_INT 106
43292: PPUSH
43293: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
43297: LD_INT 107
43299: PPUSH
43300: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
43304: LD_INT 108
43306: PPUSH
43307: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
43311: LD_INT 109
43313: PPUSH
43314: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
43318: LD_INT 110
43320: PPUSH
43321: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
43325: LD_INT 111
43327: PPUSH
43328: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
43332: LD_INT 112
43334: PPUSH
43335: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
43339: LD_INT 113
43341: PPUSH
43342: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
43346: LD_INT 120
43348: PPUSH
43349: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
43353: LD_INT 121
43355: PPUSH
43356: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
43360: LD_INT 122
43362: PPUSH
43363: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
43367: LD_INT 123
43369: PPUSH
43370: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
43374: LD_INT 124
43376: PPUSH
43377: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
43381: LD_INT 125
43383: PPUSH
43384: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
43388: LD_INT 126
43390: PPUSH
43391: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
43395: LD_INT 200
43397: PPUSH
43398: CALL_OW 427
// end ;
43402: END
// on SailEvent ( event ) do begin if event < 100 then
43403: LD_VAR 0 1
43407: PUSH
43408: LD_INT 100
43410: LESS
43411: IFFALSE 43422
// CustomEvent ( event ) ;
43413: LD_VAR 0 1
43417: PPUSH
43418: CALL 37778 0 1
// if event = 100 then
43422: LD_VAR 0 1
43426: PUSH
43427: LD_INT 100
43429: EQUAL
43430: IFFALSE 43436
// MC_ClassManager ( ) ;
43432: CALL 43828 0 0
// if event = 101 then
43436: LD_VAR 0 1
43440: PUSH
43441: LD_INT 101
43443: EQUAL
43444: IFFALSE 43450
// MC_RepairBuildings ( ) ;
43446: CALL 48660 0 0
// if event = 102 then
43450: LD_VAR 0 1
43454: PUSH
43455: LD_INT 102
43457: EQUAL
43458: IFFALSE 43464
// MC_Heal ( ) ;
43460: CALL 49595 0 0
// if event = 103 then
43464: LD_VAR 0 1
43468: PUSH
43469: LD_INT 103
43471: EQUAL
43472: IFFALSE 43478
// MC_Build ( ) ;
43474: CALL 50017 0 0
// if event = 104 then
43478: LD_VAR 0 1
43482: PUSH
43483: LD_INT 104
43485: EQUAL
43486: IFFALSE 43492
// MC_TurretWeapon ( ) ;
43488: CALL 51651 0 0
// if event = 105 then
43492: LD_VAR 0 1
43496: PUSH
43497: LD_INT 105
43499: EQUAL
43500: IFFALSE 43506
// MC_BuildUpgrade ( ) ;
43502: CALL 51202 0 0
// if event = 106 then
43506: LD_VAR 0 1
43510: PUSH
43511: LD_INT 106
43513: EQUAL
43514: IFFALSE 43520
// MC_PlantMines ( ) ;
43516: CALL 52081 0 0
// if event = 107 then
43520: LD_VAR 0 1
43524: PUSH
43525: LD_INT 107
43527: EQUAL
43528: IFFALSE 43534
// MC_CollectCrates ( ) ;
43530: CALL 52879 0 0
// if event = 108 then
43534: LD_VAR 0 1
43538: PUSH
43539: LD_INT 108
43541: EQUAL
43542: IFFALSE 43548
// MC_LinkRemoteControl ( ) ;
43544: CALL 54729 0 0
// if event = 109 then
43548: LD_VAR 0 1
43552: PUSH
43553: LD_INT 109
43555: EQUAL
43556: IFFALSE 43562
// MC_ProduceVehicle ( ) ;
43558: CALL 54910 0 0
// if event = 110 then
43562: LD_VAR 0 1
43566: PUSH
43567: LD_INT 110
43569: EQUAL
43570: IFFALSE 43576
// MC_SendAttack ( ) ;
43572: CALL 55376 0 0
// if event = 111 then
43576: LD_VAR 0 1
43580: PUSH
43581: LD_INT 111
43583: EQUAL
43584: IFFALSE 43590
// MC_Defend ( ) ;
43586: CALL 55484 0 0
// if event = 112 then
43590: LD_VAR 0 1
43594: PUSH
43595: LD_INT 112
43597: EQUAL
43598: IFFALSE 43604
// MC_Research ( ) ;
43600: CALL 56364 0 0
// if event = 113 then
43604: LD_VAR 0 1
43608: PUSH
43609: LD_INT 113
43611: EQUAL
43612: IFFALSE 43618
// MC_MinesTrigger ( ) ;
43614: CALL 57478 0 0
// if event = 120 then
43618: LD_VAR 0 1
43622: PUSH
43623: LD_INT 120
43625: EQUAL
43626: IFFALSE 43632
// MC_RepairVehicle ( ) ;
43628: CALL 57577 0 0
// if event = 121 then
43632: LD_VAR 0 1
43636: PUSH
43637: LD_INT 121
43639: EQUAL
43640: IFFALSE 43646
// MC_TameApe ( ) ;
43642: CALL 58346 0 0
// if event = 122 then
43646: LD_VAR 0 1
43650: PUSH
43651: LD_INT 122
43653: EQUAL
43654: IFFALSE 43660
// MC_ChangeApeClass ( ) ;
43656: CALL 59175 0 0
// if event = 123 then
43660: LD_VAR 0 1
43664: PUSH
43665: LD_INT 123
43667: EQUAL
43668: IFFALSE 43674
// MC_Bazooka ( ) ;
43670: CALL 59825 0 0
// if event = 124 then
43674: LD_VAR 0 1
43678: PUSH
43679: LD_INT 124
43681: EQUAL
43682: IFFALSE 43688
// MC_TeleportExit ( ) ;
43684: CALL 60023 0 0
// if event = 125 then
43688: LD_VAR 0 1
43692: PUSH
43693: LD_INT 125
43695: EQUAL
43696: IFFALSE 43702
// MC_Deposits ( ) ;
43698: CALL 60670 0 0
// if event = 126 then
43702: LD_VAR 0 1
43706: PUSH
43707: LD_INT 126
43709: EQUAL
43710: IFFALSE 43716
// MC_RemoteDriver ( ) ;
43712: CALL 61295 0 0
// if event = 200 then
43716: LD_VAR 0 1
43720: PUSH
43721: LD_INT 200
43723: EQUAL
43724: IFFALSE 43730
// MC_Idle ( ) ;
43726: CALL 63202 0 0
// end ;
43730: PPOPN 1
43732: END
// export function MC_Reset ( base , tag ) ; var i ; begin
43733: LD_INT 0
43735: PPUSH
43736: PPUSH
// if not mc_bases [ base ] or not tag then
43737: LD_EXP 102
43741: PUSH
43742: LD_VAR 0 1
43746: ARRAY
43747: NOT
43748: PUSH
43749: LD_VAR 0 2
43753: NOT
43754: OR
43755: IFFALSE 43759
// exit ;
43757: GO 43823
// for i in mc_bases [ base ] union mc_ape [ base ] do
43759: LD_ADDR_VAR 0 4
43763: PUSH
43764: LD_EXP 102
43768: PUSH
43769: LD_VAR 0 1
43773: ARRAY
43774: PUSH
43775: LD_EXP 131
43779: PUSH
43780: LD_VAR 0 1
43784: ARRAY
43785: UNION
43786: PUSH
43787: FOR_IN
43788: IFFALSE 43821
// if GetTag ( i ) = tag then
43790: LD_VAR 0 4
43794: PPUSH
43795: CALL_OW 110
43799: PUSH
43800: LD_VAR 0 2
43804: EQUAL
43805: IFFALSE 43819
// SetTag ( i , 0 ) ;
43807: LD_VAR 0 4
43811: PPUSH
43812: LD_INT 0
43814: PPUSH
43815: CALL_OW 109
43819: GO 43787
43821: POP
43822: POP
// end ;
43823: LD_VAR 0 3
43827: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
43828: LD_INT 0
43830: PPUSH
43831: PPUSH
43832: PPUSH
43833: PPUSH
43834: PPUSH
43835: PPUSH
43836: PPUSH
43837: PPUSH
// if not mc_bases then
43838: LD_EXP 102
43842: NOT
43843: IFFALSE 43847
// exit ;
43845: GO 44296
// for i = 1 to mc_bases do
43847: LD_ADDR_VAR 0 2
43851: PUSH
43852: DOUBLE
43853: LD_INT 1
43855: DEC
43856: ST_TO_ADDR
43857: LD_EXP 102
43861: PUSH
43862: FOR_TO
43863: IFFALSE 44294
// begin tmp := MC_ClassCheckReq ( i ) ;
43865: LD_ADDR_VAR 0 4
43869: PUSH
43870: LD_VAR 0 2
43874: PPUSH
43875: CALL 44301 0 1
43879: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
43880: LD_ADDR_EXP 143
43884: PUSH
43885: LD_EXP 143
43889: PPUSH
43890: LD_VAR 0 2
43894: PPUSH
43895: LD_VAR 0 4
43899: PPUSH
43900: CALL_OW 1
43904: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
43905: LD_ADDR_VAR 0 6
43909: PUSH
43910: LD_EXP 102
43914: PUSH
43915: LD_VAR 0 2
43919: ARRAY
43920: PPUSH
43921: LD_INT 2
43923: PUSH
43924: LD_INT 30
43926: PUSH
43927: LD_INT 4
43929: PUSH
43930: EMPTY
43931: LIST
43932: LIST
43933: PUSH
43934: LD_INT 30
43936: PUSH
43937: LD_INT 5
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: PUSH
43944: EMPTY
43945: LIST
43946: LIST
43947: LIST
43948: PPUSH
43949: CALL_OW 72
43953: PUSH
43954: LD_EXP 102
43958: PUSH
43959: LD_VAR 0 2
43963: ARRAY
43964: PPUSH
43965: LD_INT 2
43967: PUSH
43968: LD_INT 30
43970: PUSH
43971: LD_INT 0
43973: PUSH
43974: EMPTY
43975: LIST
43976: LIST
43977: PUSH
43978: LD_INT 30
43980: PUSH
43981: LD_INT 1
43983: PUSH
43984: EMPTY
43985: LIST
43986: LIST
43987: PUSH
43988: EMPTY
43989: LIST
43990: LIST
43991: LIST
43992: PPUSH
43993: CALL_OW 72
43997: PUSH
43998: LD_EXP 102
44002: PUSH
44003: LD_VAR 0 2
44007: ARRAY
44008: PPUSH
44009: LD_INT 30
44011: PUSH
44012: LD_INT 3
44014: PUSH
44015: EMPTY
44016: LIST
44017: LIST
44018: PPUSH
44019: CALL_OW 72
44023: PUSH
44024: LD_EXP 102
44028: PUSH
44029: LD_VAR 0 2
44033: ARRAY
44034: PPUSH
44035: LD_INT 2
44037: PUSH
44038: LD_INT 30
44040: PUSH
44041: LD_INT 6
44043: PUSH
44044: EMPTY
44045: LIST
44046: LIST
44047: PUSH
44048: LD_INT 30
44050: PUSH
44051: LD_INT 7
44053: PUSH
44054: EMPTY
44055: LIST
44056: LIST
44057: PUSH
44058: LD_INT 30
44060: PUSH
44061: LD_INT 8
44063: PUSH
44064: EMPTY
44065: LIST
44066: LIST
44067: PUSH
44068: EMPTY
44069: LIST
44070: LIST
44071: LIST
44072: LIST
44073: PPUSH
44074: CALL_OW 72
44078: PUSH
44079: EMPTY
44080: LIST
44081: LIST
44082: LIST
44083: LIST
44084: ST_TO_ADDR
// for j := 1 to 4 do
44085: LD_ADDR_VAR 0 3
44089: PUSH
44090: DOUBLE
44091: LD_INT 1
44093: DEC
44094: ST_TO_ADDR
44095: LD_INT 4
44097: PUSH
44098: FOR_TO
44099: IFFALSE 44290
// begin if not tmp [ j ] then
44101: LD_VAR 0 4
44105: PUSH
44106: LD_VAR 0 3
44110: ARRAY
44111: NOT
44112: IFFALSE 44116
// continue ;
44114: GO 44098
// for p in tmp [ j ] do
44116: LD_ADDR_VAR 0 5
44120: PUSH
44121: LD_VAR 0 4
44125: PUSH
44126: LD_VAR 0 3
44130: ARRAY
44131: PUSH
44132: FOR_IN
44133: IFFALSE 44286
// begin if not b [ j ] then
44135: LD_VAR 0 6
44139: PUSH
44140: LD_VAR 0 3
44144: ARRAY
44145: NOT
44146: IFFALSE 44150
// break ;
44148: GO 44286
// e := 0 ;
44150: LD_ADDR_VAR 0 7
44154: PUSH
44155: LD_INT 0
44157: ST_TO_ADDR
// for k in b [ j ] do
44158: LD_ADDR_VAR 0 8
44162: PUSH
44163: LD_VAR 0 6
44167: PUSH
44168: LD_VAR 0 3
44172: ARRAY
44173: PUSH
44174: FOR_IN
44175: IFFALSE 44202
// if IsNotFull ( k ) then
44177: LD_VAR 0 8
44181: PPUSH
44182: CALL 72477 0 1
44186: IFFALSE 44200
// begin e := k ;
44188: LD_ADDR_VAR 0 7
44192: PUSH
44193: LD_VAR 0 8
44197: ST_TO_ADDR
// break ;
44198: GO 44202
// end ;
44200: GO 44174
44202: POP
44203: POP
// if e and not UnitGoingToBuilding ( p , e ) then
44204: LD_VAR 0 7
44208: PUSH
44209: LD_VAR 0 5
44213: PPUSH
44214: LD_VAR 0 7
44218: PPUSH
44219: CALL 106636 0 2
44223: NOT
44224: AND
44225: IFFALSE 44284
// begin if IsInUnit ( p ) then
44227: LD_VAR 0 5
44231: PPUSH
44232: CALL_OW 310
44236: IFFALSE 44247
// ComExitBuilding ( p ) ;
44238: LD_VAR 0 5
44242: PPUSH
44243: CALL_OW 122
// ComEnterUnit ( p , e ) ;
44247: LD_VAR 0 5
44251: PPUSH
44252: LD_VAR 0 7
44256: PPUSH
44257: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
44261: LD_VAR 0 5
44265: PPUSH
44266: LD_VAR 0 3
44270: PPUSH
44271: CALL_OW 183
// AddComExitBuilding ( p ) ;
44275: LD_VAR 0 5
44279: PPUSH
44280: CALL_OW 182
// end ; end ;
44284: GO 44132
44286: POP
44287: POP
// end ;
44288: GO 44098
44290: POP
44291: POP
// end ;
44292: GO 43862
44294: POP
44295: POP
// end ;
44296: LD_VAR 0 1
44300: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
44301: LD_INT 0
44303: PPUSH
44304: PPUSH
44305: PPUSH
44306: PPUSH
44307: PPUSH
44308: PPUSH
44309: PPUSH
44310: PPUSH
44311: PPUSH
44312: PPUSH
44313: PPUSH
44314: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
44315: LD_ADDR_VAR 0 2
44319: PUSH
44320: LD_INT 0
44322: PUSH
44323: LD_INT 0
44325: PUSH
44326: LD_INT 0
44328: PUSH
44329: LD_INT 0
44331: PUSH
44332: EMPTY
44333: LIST
44334: LIST
44335: LIST
44336: LIST
44337: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
44338: LD_VAR 0 1
44342: NOT
44343: PUSH
44344: LD_EXP 102
44348: PUSH
44349: LD_VAR 0 1
44353: ARRAY
44354: NOT
44355: OR
44356: PUSH
44357: LD_EXP 102
44361: PUSH
44362: LD_VAR 0 1
44366: ARRAY
44367: PPUSH
44368: LD_INT 2
44370: PUSH
44371: LD_INT 30
44373: PUSH
44374: LD_INT 0
44376: PUSH
44377: EMPTY
44378: LIST
44379: LIST
44380: PUSH
44381: LD_INT 30
44383: PUSH
44384: LD_INT 1
44386: PUSH
44387: EMPTY
44388: LIST
44389: LIST
44390: PUSH
44391: EMPTY
44392: LIST
44393: LIST
44394: LIST
44395: PPUSH
44396: CALL_OW 72
44400: NOT
44401: OR
44402: IFFALSE 44406
// exit ;
44404: GO 47909
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
44406: LD_ADDR_VAR 0 4
44410: PUSH
44411: LD_EXP 102
44415: PUSH
44416: LD_VAR 0 1
44420: ARRAY
44421: PPUSH
44422: LD_INT 2
44424: PUSH
44425: LD_INT 25
44427: PUSH
44428: LD_INT 1
44430: PUSH
44431: EMPTY
44432: LIST
44433: LIST
44434: PUSH
44435: LD_INT 25
44437: PUSH
44438: LD_INT 2
44440: PUSH
44441: EMPTY
44442: LIST
44443: LIST
44444: PUSH
44445: LD_INT 25
44447: PUSH
44448: LD_INT 3
44450: PUSH
44451: EMPTY
44452: LIST
44453: LIST
44454: PUSH
44455: LD_INT 25
44457: PUSH
44458: LD_INT 4
44460: PUSH
44461: EMPTY
44462: LIST
44463: LIST
44464: PUSH
44465: LD_INT 25
44467: PUSH
44468: LD_INT 5
44470: PUSH
44471: EMPTY
44472: LIST
44473: LIST
44474: PUSH
44475: LD_INT 25
44477: PUSH
44478: LD_INT 8
44480: PUSH
44481: EMPTY
44482: LIST
44483: LIST
44484: PUSH
44485: LD_INT 25
44487: PUSH
44488: LD_INT 9
44490: PUSH
44491: EMPTY
44492: LIST
44493: LIST
44494: PUSH
44495: EMPTY
44496: LIST
44497: LIST
44498: LIST
44499: LIST
44500: LIST
44501: LIST
44502: LIST
44503: LIST
44504: PPUSH
44505: CALL_OW 72
44509: ST_TO_ADDR
// if not tmp then
44510: LD_VAR 0 4
44514: NOT
44515: IFFALSE 44519
// exit ;
44517: GO 47909
// for i in tmp do
44519: LD_ADDR_VAR 0 3
44523: PUSH
44524: LD_VAR 0 4
44528: PUSH
44529: FOR_IN
44530: IFFALSE 44561
// if GetTag ( i ) then
44532: LD_VAR 0 3
44536: PPUSH
44537: CALL_OW 110
44541: IFFALSE 44559
// tmp := tmp diff i ;
44543: LD_ADDR_VAR 0 4
44547: PUSH
44548: LD_VAR 0 4
44552: PUSH
44553: LD_VAR 0 3
44557: DIFF
44558: ST_TO_ADDR
44559: GO 44529
44561: POP
44562: POP
// if not tmp then
44563: LD_VAR 0 4
44567: NOT
44568: IFFALSE 44572
// exit ;
44570: GO 47909
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
44572: LD_ADDR_VAR 0 5
44576: PUSH
44577: LD_EXP 102
44581: PUSH
44582: LD_VAR 0 1
44586: ARRAY
44587: PPUSH
44588: LD_INT 2
44590: PUSH
44591: LD_INT 25
44593: PUSH
44594: LD_INT 1
44596: PUSH
44597: EMPTY
44598: LIST
44599: LIST
44600: PUSH
44601: LD_INT 25
44603: PUSH
44604: LD_INT 5
44606: PUSH
44607: EMPTY
44608: LIST
44609: LIST
44610: PUSH
44611: LD_INT 25
44613: PUSH
44614: LD_INT 8
44616: PUSH
44617: EMPTY
44618: LIST
44619: LIST
44620: PUSH
44621: LD_INT 25
44623: PUSH
44624: LD_INT 9
44626: PUSH
44627: EMPTY
44628: LIST
44629: LIST
44630: PUSH
44631: EMPTY
44632: LIST
44633: LIST
44634: LIST
44635: LIST
44636: LIST
44637: PPUSH
44638: CALL_OW 72
44642: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
44643: LD_ADDR_VAR 0 6
44647: PUSH
44648: LD_EXP 102
44652: PUSH
44653: LD_VAR 0 1
44657: ARRAY
44658: PPUSH
44659: LD_INT 25
44661: PUSH
44662: LD_INT 2
44664: PUSH
44665: EMPTY
44666: LIST
44667: LIST
44668: PPUSH
44669: CALL_OW 72
44673: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
44674: LD_ADDR_VAR 0 7
44678: PUSH
44679: LD_EXP 102
44683: PUSH
44684: LD_VAR 0 1
44688: ARRAY
44689: PPUSH
44690: LD_INT 25
44692: PUSH
44693: LD_INT 3
44695: PUSH
44696: EMPTY
44697: LIST
44698: LIST
44699: PPUSH
44700: CALL_OW 72
44704: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
44705: LD_ADDR_VAR 0 8
44709: PUSH
44710: LD_EXP 102
44714: PUSH
44715: LD_VAR 0 1
44719: ARRAY
44720: PPUSH
44721: LD_INT 25
44723: PUSH
44724: LD_INT 4
44726: PUSH
44727: EMPTY
44728: LIST
44729: LIST
44730: PUSH
44731: LD_INT 24
44733: PUSH
44734: LD_INT 251
44736: PUSH
44737: EMPTY
44738: LIST
44739: LIST
44740: PUSH
44741: EMPTY
44742: LIST
44743: LIST
44744: PPUSH
44745: CALL_OW 72
44749: ST_TO_ADDR
// if mc_is_defending [ base ] then
44750: LD_EXP 145
44754: PUSH
44755: LD_VAR 0 1
44759: ARRAY
44760: IFFALSE 45221
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
44762: LD_ADDR_EXP 144
44766: PUSH
44767: LD_EXP 144
44771: PPUSH
44772: LD_VAR 0 1
44776: PPUSH
44777: LD_INT 4
44779: PPUSH
44780: CALL_OW 1
44784: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
44785: LD_ADDR_VAR 0 12
44789: PUSH
44790: LD_EXP 102
44794: PUSH
44795: LD_VAR 0 1
44799: ARRAY
44800: PPUSH
44801: LD_INT 2
44803: PUSH
44804: LD_INT 30
44806: PUSH
44807: LD_INT 4
44809: PUSH
44810: EMPTY
44811: LIST
44812: LIST
44813: PUSH
44814: LD_INT 30
44816: PUSH
44817: LD_INT 5
44819: PUSH
44820: EMPTY
44821: LIST
44822: LIST
44823: PUSH
44824: EMPTY
44825: LIST
44826: LIST
44827: LIST
44828: PPUSH
44829: CALL_OW 72
44833: ST_TO_ADDR
// if not b then
44834: LD_VAR 0 12
44838: NOT
44839: IFFALSE 44843
// exit ;
44841: GO 47909
// p := [ ] ;
44843: LD_ADDR_VAR 0 11
44847: PUSH
44848: EMPTY
44849: ST_TO_ADDR
// if sci >= 2 then
44850: LD_VAR 0 8
44854: PUSH
44855: LD_INT 2
44857: GREATEREQUAL
44858: IFFALSE 44889
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
44860: LD_ADDR_VAR 0 8
44864: PUSH
44865: LD_VAR 0 8
44869: PUSH
44870: LD_INT 1
44872: ARRAY
44873: PUSH
44874: LD_VAR 0 8
44878: PUSH
44879: LD_INT 2
44881: ARRAY
44882: PUSH
44883: EMPTY
44884: LIST
44885: LIST
44886: ST_TO_ADDR
44887: GO 44950
// if sci = 1 then
44889: LD_VAR 0 8
44893: PUSH
44894: LD_INT 1
44896: EQUAL
44897: IFFALSE 44918
// sci := [ sci [ 1 ] ] else
44899: LD_ADDR_VAR 0 8
44903: PUSH
44904: LD_VAR 0 8
44908: PUSH
44909: LD_INT 1
44911: ARRAY
44912: PUSH
44913: EMPTY
44914: LIST
44915: ST_TO_ADDR
44916: GO 44950
// if sci = 0 then
44918: LD_VAR 0 8
44922: PUSH
44923: LD_INT 0
44925: EQUAL
44926: IFFALSE 44950
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
44928: LD_ADDR_VAR 0 11
44932: PUSH
44933: LD_VAR 0 4
44937: PPUSH
44938: LD_INT 4
44940: PPUSH
44941: CALL 106508 0 2
44945: PUSH
44946: LD_INT 1
44948: ARRAY
44949: ST_TO_ADDR
// if eng > 4 then
44950: LD_VAR 0 6
44954: PUSH
44955: LD_INT 4
44957: GREATER
44958: IFFALSE 45004
// for i = eng downto 4 do
44960: LD_ADDR_VAR 0 3
44964: PUSH
44965: DOUBLE
44966: LD_VAR 0 6
44970: INC
44971: ST_TO_ADDR
44972: LD_INT 4
44974: PUSH
44975: FOR_DOWNTO
44976: IFFALSE 45002
// eng := eng diff eng [ i ] ;
44978: LD_ADDR_VAR 0 6
44982: PUSH
44983: LD_VAR 0 6
44987: PUSH
44988: LD_VAR 0 6
44992: PUSH
44993: LD_VAR 0 3
44997: ARRAY
44998: DIFF
44999: ST_TO_ADDR
45000: GO 44975
45002: POP
45003: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
45004: LD_ADDR_VAR 0 4
45008: PUSH
45009: LD_VAR 0 4
45013: PUSH
45014: LD_VAR 0 5
45018: PUSH
45019: LD_VAR 0 6
45023: UNION
45024: PUSH
45025: LD_VAR 0 7
45029: UNION
45030: PUSH
45031: LD_VAR 0 8
45035: UNION
45036: DIFF
45037: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
45038: LD_ADDR_VAR 0 13
45042: PUSH
45043: LD_EXP 102
45047: PUSH
45048: LD_VAR 0 1
45052: ARRAY
45053: PPUSH
45054: LD_INT 2
45056: PUSH
45057: LD_INT 30
45059: PUSH
45060: LD_INT 32
45062: PUSH
45063: EMPTY
45064: LIST
45065: LIST
45066: PUSH
45067: LD_INT 30
45069: PUSH
45070: LD_INT 31
45072: PUSH
45073: EMPTY
45074: LIST
45075: LIST
45076: PUSH
45077: EMPTY
45078: LIST
45079: LIST
45080: LIST
45081: PPUSH
45082: CALL_OW 72
45086: PUSH
45087: LD_EXP 102
45091: PUSH
45092: LD_VAR 0 1
45096: ARRAY
45097: PPUSH
45098: LD_INT 2
45100: PUSH
45101: LD_INT 30
45103: PUSH
45104: LD_INT 4
45106: PUSH
45107: EMPTY
45108: LIST
45109: LIST
45110: PUSH
45111: LD_INT 30
45113: PUSH
45114: LD_INT 5
45116: PUSH
45117: EMPTY
45118: LIST
45119: LIST
45120: PUSH
45121: EMPTY
45122: LIST
45123: LIST
45124: LIST
45125: PPUSH
45126: CALL_OW 72
45130: PUSH
45131: LD_INT 6
45133: MUL
45134: PLUS
45135: ST_TO_ADDR
// if bcount < tmp then
45136: LD_VAR 0 13
45140: PUSH
45141: LD_VAR 0 4
45145: LESS
45146: IFFALSE 45192
// for i = tmp downto bcount do
45148: LD_ADDR_VAR 0 3
45152: PUSH
45153: DOUBLE
45154: LD_VAR 0 4
45158: INC
45159: ST_TO_ADDR
45160: LD_VAR 0 13
45164: PUSH
45165: FOR_DOWNTO
45166: IFFALSE 45190
// tmp := Delete ( tmp , tmp ) ;
45168: LD_ADDR_VAR 0 4
45172: PUSH
45173: LD_VAR 0 4
45177: PPUSH
45178: LD_VAR 0 4
45182: PPUSH
45183: CALL_OW 3
45187: ST_TO_ADDR
45188: GO 45165
45190: POP
45191: POP
// result := [ tmp , 0 , 0 , p ] ;
45192: LD_ADDR_VAR 0 2
45196: PUSH
45197: LD_VAR 0 4
45201: PUSH
45202: LD_INT 0
45204: PUSH
45205: LD_INT 0
45207: PUSH
45208: LD_VAR 0 11
45212: PUSH
45213: EMPTY
45214: LIST
45215: LIST
45216: LIST
45217: LIST
45218: ST_TO_ADDR
// exit ;
45219: GO 47909
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
45221: LD_EXP 102
45225: PUSH
45226: LD_VAR 0 1
45230: ARRAY
45231: PPUSH
45232: LD_INT 2
45234: PUSH
45235: LD_INT 30
45237: PUSH
45238: LD_INT 6
45240: PUSH
45241: EMPTY
45242: LIST
45243: LIST
45244: PUSH
45245: LD_INT 30
45247: PUSH
45248: LD_INT 7
45250: PUSH
45251: EMPTY
45252: LIST
45253: LIST
45254: PUSH
45255: LD_INT 30
45257: PUSH
45258: LD_INT 8
45260: PUSH
45261: EMPTY
45262: LIST
45263: LIST
45264: PUSH
45265: EMPTY
45266: LIST
45267: LIST
45268: LIST
45269: LIST
45270: PPUSH
45271: CALL_OW 72
45275: NOT
45276: PUSH
45277: LD_EXP 102
45281: PUSH
45282: LD_VAR 0 1
45286: ARRAY
45287: PPUSH
45288: LD_INT 30
45290: PUSH
45291: LD_INT 3
45293: PUSH
45294: EMPTY
45295: LIST
45296: LIST
45297: PPUSH
45298: CALL_OW 72
45302: NOT
45303: AND
45304: IFFALSE 45376
// begin if eng = tmp then
45306: LD_VAR 0 6
45310: PUSH
45311: LD_VAR 0 4
45315: EQUAL
45316: IFFALSE 45320
// exit ;
45318: GO 47909
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
45320: LD_ADDR_EXP 144
45324: PUSH
45325: LD_EXP 144
45329: PPUSH
45330: LD_VAR 0 1
45334: PPUSH
45335: LD_INT 1
45337: PPUSH
45338: CALL_OW 1
45342: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
45343: LD_ADDR_VAR 0 2
45347: PUSH
45348: LD_INT 0
45350: PUSH
45351: LD_VAR 0 4
45355: PUSH
45356: LD_VAR 0 6
45360: DIFF
45361: PUSH
45362: LD_INT 0
45364: PUSH
45365: LD_INT 0
45367: PUSH
45368: EMPTY
45369: LIST
45370: LIST
45371: LIST
45372: LIST
45373: ST_TO_ADDR
// exit ;
45374: GO 47909
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
45376: LD_EXP 129
45380: PUSH
45381: LD_EXP 128
45385: PUSH
45386: LD_VAR 0 1
45390: ARRAY
45391: ARRAY
45392: PUSH
45393: LD_EXP 102
45397: PUSH
45398: LD_VAR 0 1
45402: ARRAY
45403: PPUSH
45404: LD_INT 2
45406: PUSH
45407: LD_INT 30
45409: PUSH
45410: LD_INT 6
45412: PUSH
45413: EMPTY
45414: LIST
45415: LIST
45416: PUSH
45417: LD_INT 30
45419: PUSH
45420: LD_INT 7
45422: PUSH
45423: EMPTY
45424: LIST
45425: LIST
45426: PUSH
45427: LD_INT 30
45429: PUSH
45430: LD_INT 8
45432: PUSH
45433: EMPTY
45434: LIST
45435: LIST
45436: PUSH
45437: EMPTY
45438: LIST
45439: LIST
45440: LIST
45441: LIST
45442: PPUSH
45443: CALL_OW 72
45447: AND
45448: PUSH
45449: LD_EXP 102
45453: PUSH
45454: LD_VAR 0 1
45458: ARRAY
45459: PPUSH
45460: LD_INT 30
45462: PUSH
45463: LD_INT 3
45465: PUSH
45466: EMPTY
45467: LIST
45468: LIST
45469: PPUSH
45470: CALL_OW 72
45474: NOT
45475: AND
45476: IFFALSE 45690
// begin if sci >= 6 then
45478: LD_VAR 0 8
45482: PUSH
45483: LD_INT 6
45485: GREATEREQUAL
45486: IFFALSE 45490
// exit ;
45488: GO 47909
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
45490: LD_ADDR_EXP 144
45494: PUSH
45495: LD_EXP 144
45499: PPUSH
45500: LD_VAR 0 1
45504: PPUSH
45505: LD_INT 2
45507: PPUSH
45508: CALL_OW 1
45512: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
45513: LD_ADDR_VAR 0 9
45517: PUSH
45518: LD_VAR 0 4
45522: PUSH
45523: LD_VAR 0 8
45527: DIFF
45528: PPUSH
45529: LD_INT 4
45531: PPUSH
45532: CALL 106508 0 2
45536: ST_TO_ADDR
// p := [ ] ;
45537: LD_ADDR_VAR 0 11
45541: PUSH
45542: EMPTY
45543: ST_TO_ADDR
// if sci < 6 and sort > 6 then
45544: LD_VAR 0 8
45548: PUSH
45549: LD_INT 6
45551: LESS
45552: PUSH
45553: LD_VAR 0 9
45557: PUSH
45558: LD_INT 6
45560: GREATER
45561: AND
45562: IFFALSE 45643
// begin for i = 1 to 6 - sci do
45564: LD_ADDR_VAR 0 3
45568: PUSH
45569: DOUBLE
45570: LD_INT 1
45572: DEC
45573: ST_TO_ADDR
45574: LD_INT 6
45576: PUSH
45577: LD_VAR 0 8
45581: MINUS
45582: PUSH
45583: FOR_TO
45584: IFFALSE 45639
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
45586: LD_ADDR_VAR 0 11
45590: PUSH
45591: LD_VAR 0 11
45595: PPUSH
45596: LD_VAR 0 11
45600: PUSH
45601: LD_INT 1
45603: PLUS
45604: PPUSH
45605: LD_VAR 0 9
45609: PUSH
45610: LD_INT 1
45612: ARRAY
45613: PPUSH
45614: CALL_OW 2
45618: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
45619: LD_ADDR_VAR 0 9
45623: PUSH
45624: LD_VAR 0 9
45628: PPUSH
45629: LD_INT 1
45631: PPUSH
45632: CALL_OW 3
45636: ST_TO_ADDR
// end ;
45637: GO 45583
45639: POP
45640: POP
// end else
45641: GO 45663
// if sort then
45643: LD_VAR 0 9
45647: IFFALSE 45663
// p := sort [ 1 ] ;
45649: LD_ADDR_VAR 0 11
45653: PUSH
45654: LD_VAR 0 9
45658: PUSH
45659: LD_INT 1
45661: ARRAY
45662: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
45663: LD_ADDR_VAR 0 2
45667: PUSH
45668: LD_INT 0
45670: PUSH
45671: LD_INT 0
45673: PUSH
45674: LD_INT 0
45676: PUSH
45677: LD_VAR 0 11
45681: PUSH
45682: EMPTY
45683: LIST
45684: LIST
45685: LIST
45686: LIST
45687: ST_TO_ADDR
// exit ;
45688: GO 47909
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
45690: LD_EXP 129
45694: PUSH
45695: LD_EXP 128
45699: PUSH
45700: LD_VAR 0 1
45704: ARRAY
45705: ARRAY
45706: PUSH
45707: LD_EXP 102
45711: PUSH
45712: LD_VAR 0 1
45716: ARRAY
45717: PPUSH
45718: LD_INT 2
45720: PUSH
45721: LD_INT 30
45723: PUSH
45724: LD_INT 6
45726: PUSH
45727: EMPTY
45728: LIST
45729: LIST
45730: PUSH
45731: LD_INT 30
45733: PUSH
45734: LD_INT 7
45736: PUSH
45737: EMPTY
45738: LIST
45739: LIST
45740: PUSH
45741: LD_INT 30
45743: PUSH
45744: LD_INT 8
45746: PUSH
45747: EMPTY
45748: LIST
45749: LIST
45750: PUSH
45751: EMPTY
45752: LIST
45753: LIST
45754: LIST
45755: LIST
45756: PPUSH
45757: CALL_OW 72
45761: AND
45762: PUSH
45763: LD_EXP 102
45767: PUSH
45768: LD_VAR 0 1
45772: ARRAY
45773: PPUSH
45774: LD_INT 30
45776: PUSH
45777: LD_INT 3
45779: PUSH
45780: EMPTY
45781: LIST
45782: LIST
45783: PPUSH
45784: CALL_OW 72
45788: AND
45789: IFFALSE 46523
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
45791: LD_ADDR_EXP 144
45795: PUSH
45796: LD_EXP 144
45800: PPUSH
45801: LD_VAR 0 1
45805: PPUSH
45806: LD_INT 3
45808: PPUSH
45809: CALL_OW 1
45813: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
45814: LD_ADDR_VAR 0 2
45818: PUSH
45819: LD_INT 0
45821: PUSH
45822: LD_INT 0
45824: PUSH
45825: LD_INT 0
45827: PUSH
45828: LD_INT 0
45830: PUSH
45831: EMPTY
45832: LIST
45833: LIST
45834: LIST
45835: LIST
45836: ST_TO_ADDR
// if not eng then
45837: LD_VAR 0 6
45841: NOT
45842: IFFALSE 45905
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
45844: LD_ADDR_VAR 0 11
45848: PUSH
45849: LD_VAR 0 4
45853: PPUSH
45854: LD_INT 2
45856: PPUSH
45857: CALL 106508 0 2
45861: PUSH
45862: LD_INT 1
45864: ARRAY
45865: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
45866: LD_ADDR_VAR 0 2
45870: PUSH
45871: LD_VAR 0 2
45875: PPUSH
45876: LD_INT 2
45878: PPUSH
45879: LD_VAR 0 11
45883: PPUSH
45884: CALL_OW 1
45888: ST_TO_ADDR
// tmp := tmp diff p ;
45889: LD_ADDR_VAR 0 4
45893: PUSH
45894: LD_VAR 0 4
45898: PUSH
45899: LD_VAR 0 11
45903: DIFF
45904: ST_TO_ADDR
// end ; if tmp and sci < 6 then
45905: LD_VAR 0 4
45909: PUSH
45910: LD_VAR 0 8
45914: PUSH
45915: LD_INT 6
45917: LESS
45918: AND
45919: IFFALSE 46107
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
45921: LD_ADDR_VAR 0 9
45925: PUSH
45926: LD_VAR 0 4
45930: PUSH
45931: LD_VAR 0 8
45935: PUSH
45936: LD_VAR 0 7
45940: UNION
45941: DIFF
45942: PPUSH
45943: LD_INT 4
45945: PPUSH
45946: CALL 106508 0 2
45950: ST_TO_ADDR
// p := [ ] ;
45951: LD_ADDR_VAR 0 11
45955: PUSH
45956: EMPTY
45957: ST_TO_ADDR
// if sort then
45958: LD_VAR 0 9
45962: IFFALSE 46078
// for i = 1 to 6 - sci do
45964: LD_ADDR_VAR 0 3
45968: PUSH
45969: DOUBLE
45970: LD_INT 1
45972: DEC
45973: ST_TO_ADDR
45974: LD_INT 6
45976: PUSH
45977: LD_VAR 0 8
45981: MINUS
45982: PUSH
45983: FOR_TO
45984: IFFALSE 46076
// begin if i = sort then
45986: LD_VAR 0 3
45990: PUSH
45991: LD_VAR 0 9
45995: EQUAL
45996: IFFALSE 46000
// break ;
45998: GO 46076
// if GetClass ( i ) = 4 then
46000: LD_VAR 0 3
46004: PPUSH
46005: CALL_OW 257
46009: PUSH
46010: LD_INT 4
46012: EQUAL
46013: IFFALSE 46017
// continue ;
46015: GO 45983
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46017: LD_ADDR_VAR 0 11
46021: PUSH
46022: LD_VAR 0 11
46026: PPUSH
46027: LD_VAR 0 11
46031: PUSH
46032: LD_INT 1
46034: PLUS
46035: PPUSH
46036: LD_VAR 0 9
46040: PUSH
46041: LD_VAR 0 3
46045: ARRAY
46046: PPUSH
46047: CALL_OW 2
46051: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46052: LD_ADDR_VAR 0 4
46056: PUSH
46057: LD_VAR 0 4
46061: PUSH
46062: LD_VAR 0 9
46066: PUSH
46067: LD_VAR 0 3
46071: ARRAY
46072: DIFF
46073: ST_TO_ADDR
// end ;
46074: GO 45983
46076: POP
46077: POP
// if p then
46078: LD_VAR 0 11
46082: IFFALSE 46107
// result := Replace ( result , 4 , p ) ;
46084: LD_ADDR_VAR 0 2
46088: PUSH
46089: LD_VAR 0 2
46093: PPUSH
46094: LD_INT 4
46096: PPUSH
46097: LD_VAR 0 11
46101: PPUSH
46102: CALL_OW 1
46106: ST_TO_ADDR
// end ; if tmp and mech < 6 then
46107: LD_VAR 0 4
46111: PUSH
46112: LD_VAR 0 7
46116: PUSH
46117: LD_INT 6
46119: LESS
46120: AND
46121: IFFALSE 46309
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
46123: LD_ADDR_VAR 0 9
46127: PUSH
46128: LD_VAR 0 4
46132: PUSH
46133: LD_VAR 0 8
46137: PUSH
46138: LD_VAR 0 7
46142: UNION
46143: DIFF
46144: PPUSH
46145: LD_INT 3
46147: PPUSH
46148: CALL 106508 0 2
46152: ST_TO_ADDR
// p := [ ] ;
46153: LD_ADDR_VAR 0 11
46157: PUSH
46158: EMPTY
46159: ST_TO_ADDR
// if sort then
46160: LD_VAR 0 9
46164: IFFALSE 46280
// for i = 1 to 6 - mech do
46166: LD_ADDR_VAR 0 3
46170: PUSH
46171: DOUBLE
46172: LD_INT 1
46174: DEC
46175: ST_TO_ADDR
46176: LD_INT 6
46178: PUSH
46179: LD_VAR 0 7
46183: MINUS
46184: PUSH
46185: FOR_TO
46186: IFFALSE 46278
// begin if i = sort then
46188: LD_VAR 0 3
46192: PUSH
46193: LD_VAR 0 9
46197: EQUAL
46198: IFFALSE 46202
// break ;
46200: GO 46278
// if GetClass ( i ) = 3 then
46202: LD_VAR 0 3
46206: PPUSH
46207: CALL_OW 257
46211: PUSH
46212: LD_INT 3
46214: EQUAL
46215: IFFALSE 46219
// continue ;
46217: GO 46185
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46219: LD_ADDR_VAR 0 11
46223: PUSH
46224: LD_VAR 0 11
46228: PPUSH
46229: LD_VAR 0 11
46233: PUSH
46234: LD_INT 1
46236: PLUS
46237: PPUSH
46238: LD_VAR 0 9
46242: PUSH
46243: LD_VAR 0 3
46247: ARRAY
46248: PPUSH
46249: CALL_OW 2
46253: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46254: LD_ADDR_VAR 0 4
46258: PUSH
46259: LD_VAR 0 4
46263: PUSH
46264: LD_VAR 0 9
46268: PUSH
46269: LD_VAR 0 3
46273: ARRAY
46274: DIFF
46275: ST_TO_ADDR
// end ;
46276: GO 46185
46278: POP
46279: POP
// if p then
46280: LD_VAR 0 11
46284: IFFALSE 46309
// result := Replace ( result , 3 , p ) ;
46286: LD_ADDR_VAR 0 2
46290: PUSH
46291: LD_VAR 0 2
46295: PPUSH
46296: LD_INT 3
46298: PPUSH
46299: LD_VAR 0 11
46303: PPUSH
46304: CALL_OW 1
46308: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
46309: LD_VAR 0 4
46313: PUSH
46314: LD_INT 6
46316: GREATER
46317: PUSH
46318: LD_VAR 0 6
46322: PUSH
46323: LD_INT 6
46325: LESS
46326: AND
46327: IFFALSE 46521
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
46329: LD_ADDR_VAR 0 9
46333: PUSH
46334: LD_VAR 0 4
46338: PUSH
46339: LD_VAR 0 8
46343: PUSH
46344: LD_VAR 0 7
46348: UNION
46349: PUSH
46350: LD_VAR 0 6
46354: UNION
46355: DIFF
46356: PPUSH
46357: LD_INT 2
46359: PPUSH
46360: CALL 106508 0 2
46364: ST_TO_ADDR
// p := [ ] ;
46365: LD_ADDR_VAR 0 11
46369: PUSH
46370: EMPTY
46371: ST_TO_ADDR
// if sort then
46372: LD_VAR 0 9
46376: IFFALSE 46492
// for i = 1 to 6 - eng do
46378: LD_ADDR_VAR 0 3
46382: PUSH
46383: DOUBLE
46384: LD_INT 1
46386: DEC
46387: ST_TO_ADDR
46388: LD_INT 6
46390: PUSH
46391: LD_VAR 0 6
46395: MINUS
46396: PUSH
46397: FOR_TO
46398: IFFALSE 46490
// begin if i = sort then
46400: LD_VAR 0 3
46404: PUSH
46405: LD_VAR 0 9
46409: EQUAL
46410: IFFALSE 46414
// break ;
46412: GO 46490
// if GetClass ( i ) = 2 then
46414: LD_VAR 0 3
46418: PPUSH
46419: CALL_OW 257
46423: PUSH
46424: LD_INT 2
46426: EQUAL
46427: IFFALSE 46431
// continue ;
46429: GO 46397
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46431: LD_ADDR_VAR 0 11
46435: PUSH
46436: LD_VAR 0 11
46440: PPUSH
46441: LD_VAR 0 11
46445: PUSH
46446: LD_INT 1
46448: PLUS
46449: PPUSH
46450: LD_VAR 0 9
46454: PUSH
46455: LD_VAR 0 3
46459: ARRAY
46460: PPUSH
46461: CALL_OW 2
46465: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46466: LD_ADDR_VAR 0 4
46470: PUSH
46471: LD_VAR 0 4
46475: PUSH
46476: LD_VAR 0 9
46480: PUSH
46481: LD_VAR 0 3
46485: ARRAY
46486: DIFF
46487: ST_TO_ADDR
// end ;
46488: GO 46397
46490: POP
46491: POP
// if p then
46492: LD_VAR 0 11
46496: IFFALSE 46521
// result := Replace ( result , 2 , p ) ;
46498: LD_ADDR_VAR 0 2
46502: PUSH
46503: LD_VAR 0 2
46507: PPUSH
46508: LD_INT 2
46510: PPUSH
46511: LD_VAR 0 11
46515: PPUSH
46516: CALL_OW 1
46520: ST_TO_ADDR
// end ; exit ;
46521: GO 47909
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
46523: LD_EXP 129
46527: PUSH
46528: LD_EXP 128
46532: PUSH
46533: LD_VAR 0 1
46537: ARRAY
46538: ARRAY
46539: NOT
46540: PUSH
46541: LD_EXP 102
46545: PUSH
46546: LD_VAR 0 1
46550: ARRAY
46551: PPUSH
46552: LD_INT 30
46554: PUSH
46555: LD_INT 3
46557: PUSH
46558: EMPTY
46559: LIST
46560: LIST
46561: PPUSH
46562: CALL_OW 72
46566: AND
46567: PUSH
46568: LD_EXP 107
46572: PUSH
46573: LD_VAR 0 1
46577: ARRAY
46578: AND
46579: IFFALSE 47187
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
46581: LD_ADDR_EXP 144
46585: PUSH
46586: LD_EXP 144
46590: PPUSH
46591: LD_VAR 0 1
46595: PPUSH
46596: LD_INT 5
46598: PPUSH
46599: CALL_OW 1
46603: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
46604: LD_ADDR_VAR 0 2
46608: PUSH
46609: LD_INT 0
46611: PUSH
46612: LD_INT 0
46614: PUSH
46615: LD_INT 0
46617: PUSH
46618: LD_INT 0
46620: PUSH
46621: EMPTY
46622: LIST
46623: LIST
46624: LIST
46625: LIST
46626: ST_TO_ADDR
// if sci > 1 then
46627: LD_VAR 0 8
46631: PUSH
46632: LD_INT 1
46634: GREATER
46635: IFFALSE 46663
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
46637: LD_ADDR_VAR 0 4
46641: PUSH
46642: LD_VAR 0 4
46646: PUSH
46647: LD_VAR 0 8
46651: PUSH
46652: LD_VAR 0 8
46656: PUSH
46657: LD_INT 1
46659: ARRAY
46660: DIFF
46661: DIFF
46662: ST_TO_ADDR
// if tmp and not sci then
46663: LD_VAR 0 4
46667: PUSH
46668: LD_VAR 0 8
46672: NOT
46673: AND
46674: IFFALSE 46743
// begin sort := SortBySkill ( tmp , 4 ) ;
46676: LD_ADDR_VAR 0 9
46680: PUSH
46681: LD_VAR 0 4
46685: PPUSH
46686: LD_INT 4
46688: PPUSH
46689: CALL 106508 0 2
46693: ST_TO_ADDR
// if sort then
46694: LD_VAR 0 9
46698: IFFALSE 46714
// p := sort [ 1 ] ;
46700: LD_ADDR_VAR 0 11
46704: PUSH
46705: LD_VAR 0 9
46709: PUSH
46710: LD_INT 1
46712: ARRAY
46713: ST_TO_ADDR
// if p then
46714: LD_VAR 0 11
46718: IFFALSE 46743
// result := Replace ( result , 4 , p ) ;
46720: LD_ADDR_VAR 0 2
46724: PUSH
46725: LD_VAR 0 2
46729: PPUSH
46730: LD_INT 4
46732: PPUSH
46733: LD_VAR 0 11
46737: PPUSH
46738: CALL_OW 1
46742: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
46743: LD_ADDR_VAR 0 4
46747: PUSH
46748: LD_VAR 0 4
46752: PUSH
46753: LD_VAR 0 7
46757: DIFF
46758: ST_TO_ADDR
// if tmp and mech < 6 then
46759: LD_VAR 0 4
46763: PUSH
46764: LD_VAR 0 7
46768: PUSH
46769: LD_INT 6
46771: LESS
46772: AND
46773: IFFALSE 46961
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
46775: LD_ADDR_VAR 0 9
46779: PUSH
46780: LD_VAR 0 4
46784: PUSH
46785: LD_VAR 0 8
46789: PUSH
46790: LD_VAR 0 7
46794: UNION
46795: DIFF
46796: PPUSH
46797: LD_INT 3
46799: PPUSH
46800: CALL 106508 0 2
46804: ST_TO_ADDR
// p := [ ] ;
46805: LD_ADDR_VAR 0 11
46809: PUSH
46810: EMPTY
46811: ST_TO_ADDR
// if sort then
46812: LD_VAR 0 9
46816: IFFALSE 46932
// for i = 1 to 6 - mech do
46818: LD_ADDR_VAR 0 3
46822: PUSH
46823: DOUBLE
46824: LD_INT 1
46826: DEC
46827: ST_TO_ADDR
46828: LD_INT 6
46830: PUSH
46831: LD_VAR 0 7
46835: MINUS
46836: PUSH
46837: FOR_TO
46838: IFFALSE 46930
// begin if i = sort then
46840: LD_VAR 0 3
46844: PUSH
46845: LD_VAR 0 9
46849: EQUAL
46850: IFFALSE 46854
// break ;
46852: GO 46930
// if GetClass ( i ) = 3 then
46854: LD_VAR 0 3
46858: PPUSH
46859: CALL_OW 257
46863: PUSH
46864: LD_INT 3
46866: EQUAL
46867: IFFALSE 46871
// continue ;
46869: GO 46837
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46871: LD_ADDR_VAR 0 11
46875: PUSH
46876: LD_VAR 0 11
46880: PPUSH
46881: LD_VAR 0 11
46885: PUSH
46886: LD_INT 1
46888: PLUS
46889: PPUSH
46890: LD_VAR 0 9
46894: PUSH
46895: LD_VAR 0 3
46899: ARRAY
46900: PPUSH
46901: CALL_OW 2
46905: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46906: LD_ADDR_VAR 0 4
46910: PUSH
46911: LD_VAR 0 4
46915: PUSH
46916: LD_VAR 0 9
46920: PUSH
46921: LD_VAR 0 3
46925: ARRAY
46926: DIFF
46927: ST_TO_ADDR
// end ;
46928: GO 46837
46930: POP
46931: POP
// if p then
46932: LD_VAR 0 11
46936: IFFALSE 46961
// result := Replace ( result , 3 , p ) ;
46938: LD_ADDR_VAR 0 2
46942: PUSH
46943: LD_VAR 0 2
46947: PPUSH
46948: LD_INT 3
46950: PPUSH
46951: LD_VAR 0 11
46955: PPUSH
46956: CALL_OW 1
46960: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
46961: LD_ADDR_VAR 0 4
46965: PUSH
46966: LD_VAR 0 4
46970: PUSH
46971: LD_VAR 0 6
46975: DIFF
46976: ST_TO_ADDR
// if tmp and eng < 6 then
46977: LD_VAR 0 4
46981: PUSH
46982: LD_VAR 0 6
46986: PUSH
46987: LD_INT 6
46989: LESS
46990: AND
46991: IFFALSE 47185
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
46993: LD_ADDR_VAR 0 9
46997: PUSH
46998: LD_VAR 0 4
47002: PUSH
47003: LD_VAR 0 8
47007: PUSH
47008: LD_VAR 0 7
47012: UNION
47013: PUSH
47014: LD_VAR 0 6
47018: UNION
47019: DIFF
47020: PPUSH
47021: LD_INT 2
47023: PPUSH
47024: CALL 106508 0 2
47028: ST_TO_ADDR
// p := [ ] ;
47029: LD_ADDR_VAR 0 11
47033: PUSH
47034: EMPTY
47035: ST_TO_ADDR
// if sort then
47036: LD_VAR 0 9
47040: IFFALSE 47156
// for i = 1 to 6 - eng do
47042: LD_ADDR_VAR 0 3
47046: PUSH
47047: DOUBLE
47048: LD_INT 1
47050: DEC
47051: ST_TO_ADDR
47052: LD_INT 6
47054: PUSH
47055: LD_VAR 0 6
47059: MINUS
47060: PUSH
47061: FOR_TO
47062: IFFALSE 47154
// begin if i = sort then
47064: LD_VAR 0 3
47068: PUSH
47069: LD_VAR 0 9
47073: EQUAL
47074: IFFALSE 47078
// break ;
47076: GO 47154
// if GetClass ( i ) = 2 then
47078: LD_VAR 0 3
47082: PPUSH
47083: CALL_OW 257
47087: PUSH
47088: LD_INT 2
47090: EQUAL
47091: IFFALSE 47095
// continue ;
47093: GO 47061
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47095: LD_ADDR_VAR 0 11
47099: PUSH
47100: LD_VAR 0 11
47104: PPUSH
47105: LD_VAR 0 11
47109: PUSH
47110: LD_INT 1
47112: PLUS
47113: PPUSH
47114: LD_VAR 0 9
47118: PUSH
47119: LD_VAR 0 3
47123: ARRAY
47124: PPUSH
47125: CALL_OW 2
47129: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47130: LD_ADDR_VAR 0 4
47134: PUSH
47135: LD_VAR 0 4
47139: PUSH
47140: LD_VAR 0 9
47144: PUSH
47145: LD_VAR 0 3
47149: ARRAY
47150: DIFF
47151: ST_TO_ADDR
// end ;
47152: GO 47061
47154: POP
47155: POP
// if p then
47156: LD_VAR 0 11
47160: IFFALSE 47185
// result := Replace ( result , 2 , p ) ;
47162: LD_ADDR_VAR 0 2
47166: PUSH
47167: LD_VAR 0 2
47171: PPUSH
47172: LD_INT 2
47174: PPUSH
47175: LD_VAR 0 11
47179: PPUSH
47180: CALL_OW 1
47184: ST_TO_ADDR
// end ; exit ;
47185: GO 47909
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
47187: LD_EXP 129
47191: PUSH
47192: LD_EXP 128
47196: PUSH
47197: LD_VAR 0 1
47201: ARRAY
47202: ARRAY
47203: NOT
47204: PUSH
47205: LD_EXP 102
47209: PUSH
47210: LD_VAR 0 1
47214: ARRAY
47215: PPUSH
47216: LD_INT 30
47218: PUSH
47219: LD_INT 3
47221: PUSH
47222: EMPTY
47223: LIST
47224: LIST
47225: PPUSH
47226: CALL_OW 72
47230: AND
47231: PUSH
47232: LD_EXP 107
47236: PUSH
47237: LD_VAR 0 1
47241: ARRAY
47242: NOT
47243: AND
47244: IFFALSE 47909
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
47246: LD_ADDR_EXP 144
47250: PUSH
47251: LD_EXP 144
47255: PPUSH
47256: LD_VAR 0 1
47260: PPUSH
47261: LD_INT 6
47263: PPUSH
47264: CALL_OW 1
47268: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
47269: LD_ADDR_VAR 0 2
47273: PUSH
47274: LD_INT 0
47276: PUSH
47277: LD_INT 0
47279: PUSH
47280: LD_INT 0
47282: PUSH
47283: LD_INT 0
47285: PUSH
47286: EMPTY
47287: LIST
47288: LIST
47289: LIST
47290: LIST
47291: ST_TO_ADDR
// if sci >= 1 then
47292: LD_VAR 0 8
47296: PUSH
47297: LD_INT 1
47299: GREATEREQUAL
47300: IFFALSE 47322
// tmp := tmp diff sci [ 1 ] ;
47302: LD_ADDR_VAR 0 4
47306: PUSH
47307: LD_VAR 0 4
47311: PUSH
47312: LD_VAR 0 8
47316: PUSH
47317: LD_INT 1
47319: ARRAY
47320: DIFF
47321: ST_TO_ADDR
// if tmp and not sci then
47322: LD_VAR 0 4
47326: PUSH
47327: LD_VAR 0 8
47331: NOT
47332: AND
47333: IFFALSE 47402
// begin sort := SortBySkill ( tmp , 4 ) ;
47335: LD_ADDR_VAR 0 9
47339: PUSH
47340: LD_VAR 0 4
47344: PPUSH
47345: LD_INT 4
47347: PPUSH
47348: CALL 106508 0 2
47352: ST_TO_ADDR
// if sort then
47353: LD_VAR 0 9
47357: IFFALSE 47373
// p := sort [ 1 ] ;
47359: LD_ADDR_VAR 0 11
47363: PUSH
47364: LD_VAR 0 9
47368: PUSH
47369: LD_INT 1
47371: ARRAY
47372: ST_TO_ADDR
// if p then
47373: LD_VAR 0 11
47377: IFFALSE 47402
// result := Replace ( result , 4 , p ) ;
47379: LD_ADDR_VAR 0 2
47383: PUSH
47384: LD_VAR 0 2
47388: PPUSH
47389: LD_INT 4
47391: PPUSH
47392: LD_VAR 0 11
47396: PPUSH
47397: CALL_OW 1
47401: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
47402: LD_ADDR_VAR 0 4
47406: PUSH
47407: LD_VAR 0 4
47411: PUSH
47412: LD_VAR 0 7
47416: DIFF
47417: ST_TO_ADDR
// if tmp and mech < 6 then
47418: LD_VAR 0 4
47422: PUSH
47423: LD_VAR 0 7
47427: PUSH
47428: LD_INT 6
47430: LESS
47431: AND
47432: IFFALSE 47614
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
47434: LD_ADDR_VAR 0 9
47438: PUSH
47439: LD_VAR 0 4
47443: PUSH
47444: LD_VAR 0 7
47448: DIFF
47449: PPUSH
47450: LD_INT 3
47452: PPUSH
47453: CALL 106508 0 2
47457: ST_TO_ADDR
// p := [ ] ;
47458: LD_ADDR_VAR 0 11
47462: PUSH
47463: EMPTY
47464: ST_TO_ADDR
// if sort then
47465: LD_VAR 0 9
47469: IFFALSE 47585
// for i = 1 to 6 - mech do
47471: LD_ADDR_VAR 0 3
47475: PUSH
47476: DOUBLE
47477: LD_INT 1
47479: DEC
47480: ST_TO_ADDR
47481: LD_INT 6
47483: PUSH
47484: LD_VAR 0 7
47488: MINUS
47489: PUSH
47490: FOR_TO
47491: IFFALSE 47583
// begin if i = sort then
47493: LD_VAR 0 3
47497: PUSH
47498: LD_VAR 0 9
47502: EQUAL
47503: IFFALSE 47507
// break ;
47505: GO 47583
// if GetClass ( i ) = 3 then
47507: LD_VAR 0 3
47511: PPUSH
47512: CALL_OW 257
47516: PUSH
47517: LD_INT 3
47519: EQUAL
47520: IFFALSE 47524
// continue ;
47522: GO 47490
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47524: LD_ADDR_VAR 0 11
47528: PUSH
47529: LD_VAR 0 11
47533: PPUSH
47534: LD_VAR 0 11
47538: PUSH
47539: LD_INT 1
47541: PLUS
47542: PPUSH
47543: LD_VAR 0 9
47547: PUSH
47548: LD_VAR 0 3
47552: ARRAY
47553: PPUSH
47554: CALL_OW 2
47558: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47559: LD_ADDR_VAR 0 4
47563: PUSH
47564: LD_VAR 0 4
47568: PUSH
47569: LD_VAR 0 9
47573: PUSH
47574: LD_VAR 0 3
47578: ARRAY
47579: DIFF
47580: ST_TO_ADDR
// end ;
47581: GO 47490
47583: POP
47584: POP
// if p then
47585: LD_VAR 0 11
47589: IFFALSE 47614
// result := Replace ( result , 3 , p ) ;
47591: LD_ADDR_VAR 0 2
47595: PUSH
47596: LD_VAR 0 2
47600: PPUSH
47601: LD_INT 3
47603: PPUSH
47604: LD_VAR 0 11
47608: PPUSH
47609: CALL_OW 1
47613: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
47614: LD_ADDR_VAR 0 4
47618: PUSH
47619: LD_VAR 0 4
47623: PUSH
47624: LD_VAR 0 6
47628: DIFF
47629: ST_TO_ADDR
// if tmp and eng < 4 then
47630: LD_VAR 0 4
47634: PUSH
47635: LD_VAR 0 6
47639: PUSH
47640: LD_INT 4
47642: LESS
47643: AND
47644: IFFALSE 47834
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
47646: LD_ADDR_VAR 0 9
47650: PUSH
47651: LD_VAR 0 4
47655: PUSH
47656: LD_VAR 0 7
47660: PUSH
47661: LD_VAR 0 6
47665: UNION
47666: DIFF
47667: PPUSH
47668: LD_INT 2
47670: PPUSH
47671: CALL 106508 0 2
47675: ST_TO_ADDR
// p := [ ] ;
47676: LD_ADDR_VAR 0 11
47680: PUSH
47681: EMPTY
47682: ST_TO_ADDR
// if sort then
47683: LD_VAR 0 9
47687: IFFALSE 47803
// for i = 1 to 4 - eng do
47689: LD_ADDR_VAR 0 3
47693: PUSH
47694: DOUBLE
47695: LD_INT 1
47697: DEC
47698: ST_TO_ADDR
47699: LD_INT 4
47701: PUSH
47702: LD_VAR 0 6
47706: MINUS
47707: PUSH
47708: FOR_TO
47709: IFFALSE 47801
// begin if i = sort then
47711: LD_VAR 0 3
47715: PUSH
47716: LD_VAR 0 9
47720: EQUAL
47721: IFFALSE 47725
// break ;
47723: GO 47801
// if GetClass ( i ) = 2 then
47725: LD_VAR 0 3
47729: PPUSH
47730: CALL_OW 257
47734: PUSH
47735: LD_INT 2
47737: EQUAL
47738: IFFALSE 47742
// continue ;
47740: GO 47708
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47742: LD_ADDR_VAR 0 11
47746: PUSH
47747: LD_VAR 0 11
47751: PPUSH
47752: LD_VAR 0 11
47756: PUSH
47757: LD_INT 1
47759: PLUS
47760: PPUSH
47761: LD_VAR 0 9
47765: PUSH
47766: LD_VAR 0 3
47770: ARRAY
47771: PPUSH
47772: CALL_OW 2
47776: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47777: LD_ADDR_VAR 0 4
47781: PUSH
47782: LD_VAR 0 4
47786: PUSH
47787: LD_VAR 0 9
47791: PUSH
47792: LD_VAR 0 3
47796: ARRAY
47797: DIFF
47798: ST_TO_ADDR
// end ;
47799: GO 47708
47801: POP
47802: POP
// if p then
47803: LD_VAR 0 11
47807: IFFALSE 47832
// result := Replace ( result , 2 , p ) ;
47809: LD_ADDR_VAR 0 2
47813: PUSH
47814: LD_VAR 0 2
47818: PPUSH
47819: LD_INT 2
47821: PPUSH
47822: LD_VAR 0 11
47826: PPUSH
47827: CALL_OW 1
47831: ST_TO_ADDR
// end else
47832: GO 47878
// for i = eng downto 5 do
47834: LD_ADDR_VAR 0 3
47838: PUSH
47839: DOUBLE
47840: LD_VAR 0 6
47844: INC
47845: ST_TO_ADDR
47846: LD_INT 5
47848: PUSH
47849: FOR_DOWNTO
47850: IFFALSE 47876
// tmp := tmp union eng [ i ] ;
47852: LD_ADDR_VAR 0 4
47856: PUSH
47857: LD_VAR 0 4
47861: PUSH
47862: LD_VAR 0 6
47866: PUSH
47867: LD_VAR 0 3
47871: ARRAY
47872: UNION
47873: ST_TO_ADDR
47874: GO 47849
47876: POP
47877: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
47878: LD_ADDR_VAR 0 2
47882: PUSH
47883: LD_VAR 0 2
47887: PPUSH
47888: LD_INT 1
47890: PPUSH
47891: LD_VAR 0 4
47895: PUSH
47896: LD_VAR 0 5
47900: DIFF
47901: PPUSH
47902: CALL_OW 1
47906: ST_TO_ADDR
// exit ;
47907: GO 47909
// end ; end ;
47909: LD_VAR 0 2
47913: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
47914: LD_INT 0
47916: PPUSH
47917: PPUSH
47918: PPUSH
// if not mc_bases then
47919: LD_EXP 102
47923: NOT
47924: IFFALSE 47928
// exit ;
47926: GO 48070
// for i = 1 to mc_bases do
47928: LD_ADDR_VAR 0 2
47932: PUSH
47933: DOUBLE
47934: LD_INT 1
47936: DEC
47937: ST_TO_ADDR
47938: LD_EXP 102
47942: PUSH
47943: FOR_TO
47944: IFFALSE 48061
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
47946: LD_ADDR_VAR 0 3
47950: PUSH
47951: LD_EXP 102
47955: PUSH
47956: LD_VAR 0 2
47960: ARRAY
47961: PPUSH
47962: LD_INT 21
47964: PUSH
47965: LD_INT 3
47967: PUSH
47968: EMPTY
47969: LIST
47970: LIST
47971: PUSH
47972: LD_INT 3
47974: PUSH
47975: LD_INT 2
47977: PUSH
47978: LD_INT 30
47980: PUSH
47981: LD_INT 29
47983: PUSH
47984: EMPTY
47985: LIST
47986: LIST
47987: PUSH
47988: LD_INT 30
47990: PUSH
47991: LD_INT 30
47993: PUSH
47994: EMPTY
47995: LIST
47996: LIST
47997: PUSH
47998: EMPTY
47999: LIST
48000: LIST
48001: LIST
48002: PUSH
48003: EMPTY
48004: LIST
48005: LIST
48006: PUSH
48007: LD_INT 3
48009: PUSH
48010: LD_INT 24
48012: PUSH
48013: LD_INT 1000
48015: PUSH
48016: EMPTY
48017: LIST
48018: LIST
48019: PUSH
48020: EMPTY
48021: LIST
48022: LIST
48023: PUSH
48024: EMPTY
48025: LIST
48026: LIST
48027: LIST
48028: PPUSH
48029: CALL_OW 72
48033: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
48034: LD_ADDR_EXP 103
48038: PUSH
48039: LD_EXP 103
48043: PPUSH
48044: LD_VAR 0 2
48048: PPUSH
48049: LD_VAR 0 3
48053: PPUSH
48054: CALL_OW 1
48058: ST_TO_ADDR
// end ;
48059: GO 47943
48061: POP
48062: POP
// RaiseSailEvent ( 101 ) ;
48063: LD_INT 101
48065: PPUSH
48066: CALL_OW 427
// end ;
48070: LD_VAR 0 1
48074: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
48075: LD_INT 0
48077: PPUSH
48078: PPUSH
48079: PPUSH
48080: PPUSH
48081: PPUSH
48082: PPUSH
48083: PPUSH
// if not mc_bases then
48084: LD_EXP 102
48088: NOT
48089: IFFALSE 48093
// exit ;
48091: GO 48655
// for i = 1 to mc_bases do
48093: LD_ADDR_VAR 0 2
48097: PUSH
48098: DOUBLE
48099: LD_INT 1
48101: DEC
48102: ST_TO_ADDR
48103: LD_EXP 102
48107: PUSH
48108: FOR_TO
48109: IFFALSE 48646
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
48111: LD_ADDR_VAR 0 5
48115: PUSH
48116: LD_EXP 102
48120: PUSH
48121: LD_VAR 0 2
48125: ARRAY
48126: PUSH
48127: LD_EXP 131
48131: PUSH
48132: LD_VAR 0 2
48136: ARRAY
48137: UNION
48138: PPUSH
48139: LD_INT 21
48141: PUSH
48142: LD_INT 1
48144: PUSH
48145: EMPTY
48146: LIST
48147: LIST
48148: PUSH
48149: LD_INT 1
48151: PUSH
48152: LD_INT 3
48154: PUSH
48155: LD_INT 54
48157: PUSH
48158: EMPTY
48159: LIST
48160: PUSH
48161: EMPTY
48162: LIST
48163: LIST
48164: PUSH
48165: LD_INT 3
48167: PUSH
48168: LD_INT 24
48170: PUSH
48171: LD_INT 1000
48173: PUSH
48174: EMPTY
48175: LIST
48176: LIST
48177: PUSH
48178: EMPTY
48179: LIST
48180: LIST
48181: PUSH
48182: EMPTY
48183: LIST
48184: LIST
48185: LIST
48186: PUSH
48187: EMPTY
48188: LIST
48189: LIST
48190: PPUSH
48191: CALL_OW 72
48195: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
48196: LD_ADDR_VAR 0 6
48200: PUSH
48201: LD_EXP 102
48205: PUSH
48206: LD_VAR 0 2
48210: ARRAY
48211: PPUSH
48212: LD_INT 21
48214: PUSH
48215: LD_INT 1
48217: PUSH
48218: EMPTY
48219: LIST
48220: LIST
48221: PUSH
48222: LD_INT 1
48224: PUSH
48225: LD_INT 3
48227: PUSH
48228: LD_INT 54
48230: PUSH
48231: EMPTY
48232: LIST
48233: PUSH
48234: EMPTY
48235: LIST
48236: LIST
48237: PUSH
48238: LD_INT 3
48240: PUSH
48241: LD_INT 24
48243: PUSH
48244: LD_INT 250
48246: PUSH
48247: EMPTY
48248: LIST
48249: LIST
48250: PUSH
48251: EMPTY
48252: LIST
48253: LIST
48254: PUSH
48255: EMPTY
48256: LIST
48257: LIST
48258: LIST
48259: PUSH
48260: EMPTY
48261: LIST
48262: LIST
48263: PPUSH
48264: CALL_OW 72
48268: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
48269: LD_ADDR_VAR 0 7
48273: PUSH
48274: LD_VAR 0 5
48278: PUSH
48279: LD_VAR 0 6
48283: DIFF
48284: ST_TO_ADDR
// if not need_heal_1 then
48285: LD_VAR 0 6
48289: NOT
48290: IFFALSE 48323
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
48292: LD_ADDR_EXP 105
48296: PUSH
48297: LD_EXP 105
48301: PPUSH
48302: LD_VAR 0 2
48306: PUSH
48307: LD_INT 1
48309: PUSH
48310: EMPTY
48311: LIST
48312: LIST
48313: PPUSH
48314: EMPTY
48315: PPUSH
48316: CALL 75255 0 3
48320: ST_TO_ADDR
48321: GO 48393
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
48323: LD_ADDR_EXP 105
48327: PUSH
48328: LD_EXP 105
48332: PPUSH
48333: LD_VAR 0 2
48337: PUSH
48338: LD_INT 1
48340: PUSH
48341: EMPTY
48342: LIST
48343: LIST
48344: PPUSH
48345: LD_EXP 105
48349: PUSH
48350: LD_VAR 0 2
48354: ARRAY
48355: PUSH
48356: LD_INT 1
48358: ARRAY
48359: PPUSH
48360: LD_INT 3
48362: PUSH
48363: LD_INT 24
48365: PUSH
48366: LD_INT 1000
48368: PUSH
48369: EMPTY
48370: LIST
48371: LIST
48372: PUSH
48373: EMPTY
48374: LIST
48375: LIST
48376: PPUSH
48377: CALL_OW 72
48381: PUSH
48382: LD_VAR 0 6
48386: UNION
48387: PPUSH
48388: CALL 75255 0 3
48392: ST_TO_ADDR
// if not need_heal_2 then
48393: LD_VAR 0 7
48397: NOT
48398: IFFALSE 48431
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
48400: LD_ADDR_EXP 105
48404: PUSH
48405: LD_EXP 105
48409: PPUSH
48410: LD_VAR 0 2
48414: PUSH
48415: LD_INT 2
48417: PUSH
48418: EMPTY
48419: LIST
48420: LIST
48421: PPUSH
48422: EMPTY
48423: PPUSH
48424: CALL 75255 0 3
48428: ST_TO_ADDR
48429: GO 48463
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
48431: LD_ADDR_EXP 105
48435: PUSH
48436: LD_EXP 105
48440: PPUSH
48441: LD_VAR 0 2
48445: PUSH
48446: LD_INT 2
48448: PUSH
48449: EMPTY
48450: LIST
48451: LIST
48452: PPUSH
48453: LD_VAR 0 7
48457: PPUSH
48458: CALL 75255 0 3
48462: ST_TO_ADDR
// if need_heal_2 then
48463: LD_VAR 0 7
48467: IFFALSE 48628
// for j in need_heal_2 do
48469: LD_ADDR_VAR 0 3
48473: PUSH
48474: LD_VAR 0 7
48478: PUSH
48479: FOR_IN
48480: IFFALSE 48626
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48482: LD_ADDR_VAR 0 5
48486: PUSH
48487: LD_EXP 102
48491: PUSH
48492: LD_VAR 0 2
48496: ARRAY
48497: PPUSH
48498: LD_INT 2
48500: PUSH
48501: LD_INT 30
48503: PUSH
48504: LD_INT 6
48506: PUSH
48507: EMPTY
48508: LIST
48509: LIST
48510: PUSH
48511: LD_INT 30
48513: PUSH
48514: LD_INT 7
48516: PUSH
48517: EMPTY
48518: LIST
48519: LIST
48520: PUSH
48521: LD_INT 30
48523: PUSH
48524: LD_INT 8
48526: PUSH
48527: EMPTY
48528: LIST
48529: LIST
48530: PUSH
48531: LD_INT 30
48533: PUSH
48534: LD_INT 0
48536: PUSH
48537: EMPTY
48538: LIST
48539: LIST
48540: PUSH
48541: LD_INT 30
48543: PUSH
48544: LD_INT 1
48546: PUSH
48547: EMPTY
48548: LIST
48549: LIST
48550: PUSH
48551: EMPTY
48552: LIST
48553: LIST
48554: LIST
48555: LIST
48556: LIST
48557: LIST
48558: PPUSH
48559: CALL_OW 72
48563: ST_TO_ADDR
// if tmp then
48564: LD_VAR 0 5
48568: IFFALSE 48624
// begin k := NearestUnitToUnit ( tmp , j ) ;
48570: LD_ADDR_VAR 0 4
48574: PUSH
48575: LD_VAR 0 5
48579: PPUSH
48580: LD_VAR 0 3
48584: PPUSH
48585: CALL_OW 74
48589: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
48590: LD_VAR 0 3
48594: PPUSH
48595: LD_VAR 0 4
48599: PPUSH
48600: CALL_OW 296
48604: PUSH
48605: LD_INT 5
48607: GREATER
48608: IFFALSE 48624
// ComMoveToNearbyEntrance ( j , k ) ;
48610: LD_VAR 0 3
48614: PPUSH
48615: LD_VAR 0 4
48619: PPUSH
48620: CALL 108881 0 2
// end ; end ;
48624: GO 48479
48626: POP
48627: POP
// if not need_heal_1 and not need_heal_2 then
48628: LD_VAR 0 6
48632: NOT
48633: PUSH
48634: LD_VAR 0 7
48638: NOT
48639: AND
48640: IFFALSE 48644
// continue ;
48642: GO 48108
// end ;
48644: GO 48108
48646: POP
48647: POP
// RaiseSailEvent ( 102 ) ;
48648: LD_INT 102
48650: PPUSH
48651: CALL_OW 427
// end ;
48655: LD_VAR 0 1
48659: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
48660: LD_INT 0
48662: PPUSH
48663: PPUSH
48664: PPUSH
48665: PPUSH
48666: PPUSH
48667: PPUSH
48668: PPUSH
48669: PPUSH
// if not mc_bases then
48670: LD_EXP 102
48674: NOT
48675: IFFALSE 48679
// exit ;
48677: GO 49590
// for i = 1 to mc_bases do
48679: LD_ADDR_VAR 0 2
48683: PUSH
48684: DOUBLE
48685: LD_INT 1
48687: DEC
48688: ST_TO_ADDR
48689: LD_EXP 102
48693: PUSH
48694: FOR_TO
48695: IFFALSE 49588
// begin if not mc_building_need_repair [ i ] then
48697: LD_EXP 103
48701: PUSH
48702: LD_VAR 0 2
48706: ARRAY
48707: NOT
48708: IFFALSE 48893
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
48710: LD_ADDR_VAR 0 6
48714: PUSH
48715: LD_EXP 121
48719: PUSH
48720: LD_VAR 0 2
48724: ARRAY
48725: PPUSH
48726: LD_INT 3
48728: PUSH
48729: LD_INT 24
48731: PUSH
48732: LD_INT 1000
48734: PUSH
48735: EMPTY
48736: LIST
48737: LIST
48738: PUSH
48739: EMPTY
48740: LIST
48741: LIST
48742: PUSH
48743: LD_INT 2
48745: PUSH
48746: LD_INT 34
48748: PUSH
48749: LD_INT 13
48751: PUSH
48752: EMPTY
48753: LIST
48754: LIST
48755: PUSH
48756: LD_INT 34
48758: PUSH
48759: LD_INT 52
48761: PUSH
48762: EMPTY
48763: LIST
48764: LIST
48765: PUSH
48766: LD_INT 34
48768: PUSH
48769: LD_INT 88
48771: PUSH
48772: EMPTY
48773: LIST
48774: LIST
48775: PUSH
48776: EMPTY
48777: LIST
48778: LIST
48779: LIST
48780: LIST
48781: PUSH
48782: EMPTY
48783: LIST
48784: LIST
48785: PPUSH
48786: CALL_OW 72
48790: ST_TO_ADDR
// if cranes then
48791: LD_VAR 0 6
48795: IFFALSE 48857
// for j in cranes do
48797: LD_ADDR_VAR 0 3
48801: PUSH
48802: LD_VAR 0 6
48806: PUSH
48807: FOR_IN
48808: IFFALSE 48855
// if not IsInArea ( j , mc_parking [ i ] ) then
48810: LD_VAR 0 3
48814: PPUSH
48815: LD_EXP 126
48819: PUSH
48820: LD_VAR 0 2
48824: ARRAY
48825: PPUSH
48826: CALL_OW 308
48830: NOT
48831: IFFALSE 48853
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48833: LD_VAR 0 3
48837: PPUSH
48838: LD_EXP 126
48842: PUSH
48843: LD_VAR 0 2
48847: ARRAY
48848: PPUSH
48849: CALL_OW 113
48853: GO 48807
48855: POP
48856: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
48857: LD_ADDR_EXP 104
48861: PUSH
48862: LD_EXP 104
48866: PPUSH
48867: LD_VAR 0 2
48871: PPUSH
48872: EMPTY
48873: PPUSH
48874: CALL_OW 1
48878: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
48879: LD_VAR 0 2
48883: PPUSH
48884: LD_INT 101
48886: PPUSH
48887: CALL 43733 0 2
// continue ;
48891: GO 48694
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
48893: LD_ADDR_EXP 108
48897: PUSH
48898: LD_EXP 108
48902: PPUSH
48903: LD_VAR 0 2
48907: PPUSH
48908: EMPTY
48909: PPUSH
48910: CALL_OW 1
48914: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
48915: LD_VAR 0 2
48919: PPUSH
48920: LD_INT 103
48922: PPUSH
48923: CALL 43733 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
48927: LD_ADDR_VAR 0 5
48931: PUSH
48932: LD_EXP 102
48936: PUSH
48937: LD_VAR 0 2
48941: ARRAY
48942: PUSH
48943: LD_EXP 131
48947: PUSH
48948: LD_VAR 0 2
48952: ARRAY
48953: UNION
48954: PPUSH
48955: LD_INT 2
48957: PUSH
48958: LD_INT 25
48960: PUSH
48961: LD_INT 2
48963: PUSH
48964: EMPTY
48965: LIST
48966: LIST
48967: PUSH
48968: LD_INT 25
48970: PUSH
48971: LD_INT 16
48973: PUSH
48974: EMPTY
48975: LIST
48976: LIST
48977: PUSH
48978: EMPTY
48979: LIST
48980: LIST
48981: LIST
48982: PUSH
48983: EMPTY
48984: LIST
48985: PPUSH
48986: CALL_OW 72
48990: ST_TO_ADDR
// if mc_need_heal [ i ] then
48991: LD_EXP 105
48995: PUSH
48996: LD_VAR 0 2
49000: ARRAY
49001: IFFALSE 49045
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
49003: LD_ADDR_VAR 0 5
49007: PUSH
49008: LD_VAR 0 5
49012: PUSH
49013: LD_EXP 105
49017: PUSH
49018: LD_VAR 0 2
49022: ARRAY
49023: PUSH
49024: LD_INT 1
49026: ARRAY
49027: PUSH
49028: LD_EXP 105
49032: PUSH
49033: LD_VAR 0 2
49037: ARRAY
49038: PUSH
49039: LD_INT 2
49041: ARRAY
49042: UNION
49043: DIFF
49044: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
49045: LD_ADDR_VAR 0 6
49049: PUSH
49050: LD_EXP 121
49054: PUSH
49055: LD_VAR 0 2
49059: ARRAY
49060: PPUSH
49061: LD_INT 2
49063: PUSH
49064: LD_INT 34
49066: PUSH
49067: LD_INT 13
49069: PUSH
49070: EMPTY
49071: LIST
49072: LIST
49073: PUSH
49074: LD_INT 34
49076: PUSH
49077: LD_INT 52
49079: PUSH
49080: EMPTY
49081: LIST
49082: LIST
49083: PUSH
49084: LD_INT 34
49086: PUSH
49087: LD_INT 88
49089: PUSH
49090: EMPTY
49091: LIST
49092: LIST
49093: PUSH
49094: EMPTY
49095: LIST
49096: LIST
49097: LIST
49098: LIST
49099: PPUSH
49100: CALL_OW 72
49104: ST_TO_ADDR
// if cranes then
49105: LD_VAR 0 6
49109: IFFALSE 49277
// begin for j in cranes do
49111: LD_ADDR_VAR 0 3
49115: PUSH
49116: LD_VAR 0 6
49120: PUSH
49121: FOR_IN
49122: IFFALSE 49275
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
49124: LD_VAR 0 3
49128: PPUSH
49129: CALL_OW 256
49133: PUSH
49134: LD_INT 1000
49136: EQUAL
49137: PUSH
49138: LD_VAR 0 3
49142: PPUSH
49143: CALL_OW 314
49147: NOT
49148: AND
49149: IFFALSE 49215
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
49151: LD_ADDR_VAR 0 8
49155: PUSH
49156: LD_EXP 103
49160: PUSH
49161: LD_VAR 0 2
49165: ARRAY
49166: PPUSH
49167: LD_VAR 0 3
49171: PPUSH
49172: CALL_OW 74
49176: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
49177: LD_VAR 0 8
49181: PPUSH
49182: LD_INT 16
49184: PPUSH
49185: CALL 78220 0 2
49189: PUSH
49190: LD_INT 4
49192: ARRAY
49193: PUSH
49194: LD_INT 10
49196: LESS
49197: IFFALSE 49213
// ComRepairBuilding ( j , to_repair ) ;
49199: LD_VAR 0 3
49203: PPUSH
49204: LD_VAR 0 8
49208: PPUSH
49209: CALL_OW 130
// end else
49213: GO 49273
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
49215: LD_VAR 0 3
49219: PPUSH
49220: CALL_OW 256
49224: PUSH
49225: LD_INT 500
49227: LESS
49228: PUSH
49229: LD_VAR 0 3
49233: PPUSH
49234: LD_EXP 126
49238: PUSH
49239: LD_VAR 0 2
49243: ARRAY
49244: PPUSH
49245: CALL_OW 308
49249: NOT
49250: AND
49251: IFFALSE 49273
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49253: LD_VAR 0 3
49257: PPUSH
49258: LD_EXP 126
49262: PUSH
49263: LD_VAR 0 2
49267: ARRAY
49268: PPUSH
49269: CALL_OW 113
// end ;
49273: GO 49121
49275: POP
49276: POP
// end ; if tmp > 3 then
49277: LD_VAR 0 5
49281: PUSH
49282: LD_INT 3
49284: GREATER
49285: IFFALSE 49305
// tmp := ShrinkArray ( tmp , 4 ) ;
49287: LD_ADDR_VAR 0 5
49291: PUSH
49292: LD_VAR 0 5
49296: PPUSH
49297: LD_INT 4
49299: PPUSH
49300: CALL 108319 0 2
49304: ST_TO_ADDR
// if not tmp then
49305: LD_VAR 0 5
49309: NOT
49310: IFFALSE 49314
// continue ;
49312: GO 48694
// for j in tmp do
49314: LD_ADDR_VAR 0 3
49318: PUSH
49319: LD_VAR 0 5
49323: PUSH
49324: FOR_IN
49325: IFFALSE 49584
// begin if IsInUnit ( j ) then
49327: LD_VAR 0 3
49331: PPUSH
49332: CALL_OW 310
49336: IFFALSE 49347
// ComExitBuilding ( j ) ;
49338: LD_VAR 0 3
49342: PPUSH
49343: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
49347: LD_VAR 0 3
49351: PUSH
49352: LD_EXP 104
49356: PUSH
49357: LD_VAR 0 2
49361: ARRAY
49362: IN
49363: NOT
49364: IFFALSE 49422
// begin SetTag ( j , 101 ) ;
49366: LD_VAR 0 3
49370: PPUSH
49371: LD_INT 101
49373: PPUSH
49374: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
49378: LD_ADDR_EXP 104
49382: PUSH
49383: LD_EXP 104
49387: PPUSH
49388: LD_VAR 0 2
49392: PUSH
49393: LD_EXP 104
49397: PUSH
49398: LD_VAR 0 2
49402: ARRAY
49403: PUSH
49404: LD_INT 1
49406: PLUS
49407: PUSH
49408: EMPTY
49409: LIST
49410: LIST
49411: PPUSH
49412: LD_VAR 0 3
49416: PPUSH
49417: CALL 75255 0 3
49421: ST_TO_ADDR
// end ; wait ( 1 ) ;
49422: LD_INT 1
49424: PPUSH
49425: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
49429: LD_ADDR_VAR 0 7
49433: PUSH
49434: LD_EXP 103
49438: PUSH
49439: LD_VAR 0 2
49443: ARRAY
49444: ST_TO_ADDR
// if mc_scan [ i ] then
49445: LD_EXP 125
49449: PUSH
49450: LD_VAR 0 2
49454: ARRAY
49455: IFFALSE 49517
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
49457: LD_ADDR_VAR 0 7
49461: PUSH
49462: LD_EXP 103
49466: PUSH
49467: LD_VAR 0 2
49471: ARRAY
49472: PPUSH
49473: LD_INT 3
49475: PUSH
49476: LD_INT 30
49478: PUSH
49479: LD_INT 32
49481: PUSH
49482: EMPTY
49483: LIST
49484: LIST
49485: PUSH
49486: LD_INT 30
49488: PUSH
49489: LD_INT 33
49491: PUSH
49492: EMPTY
49493: LIST
49494: LIST
49495: PUSH
49496: LD_INT 30
49498: PUSH
49499: LD_INT 31
49501: PUSH
49502: EMPTY
49503: LIST
49504: LIST
49505: PUSH
49506: EMPTY
49507: LIST
49508: LIST
49509: LIST
49510: LIST
49511: PPUSH
49512: CALL_OW 72
49516: ST_TO_ADDR
// if not to_repair_tmp then
49517: LD_VAR 0 7
49521: NOT
49522: IFFALSE 49526
// continue ;
49524: GO 49324
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
49526: LD_ADDR_VAR 0 8
49530: PUSH
49531: LD_VAR 0 7
49535: PPUSH
49536: LD_VAR 0 3
49540: PPUSH
49541: CALL_OW 74
49545: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
49546: LD_VAR 0 8
49550: PPUSH
49551: LD_INT 16
49553: PPUSH
49554: CALL 78220 0 2
49558: PUSH
49559: LD_INT 4
49561: ARRAY
49562: PUSH
49563: LD_INT 14
49565: LESS
49566: IFFALSE 49582
// ComRepairBuilding ( j , to_repair ) ;
49568: LD_VAR 0 3
49572: PPUSH
49573: LD_VAR 0 8
49577: PPUSH
49578: CALL_OW 130
// end ;
49582: GO 49324
49584: POP
49585: POP
// end ;
49586: GO 48694
49588: POP
49589: POP
// end ;
49590: LD_VAR 0 1
49594: RET
// export function MC_Heal ; var i , j , tmp ; begin
49595: LD_INT 0
49597: PPUSH
49598: PPUSH
49599: PPUSH
49600: PPUSH
// if not mc_bases then
49601: LD_EXP 102
49605: NOT
49606: IFFALSE 49610
// exit ;
49608: GO 50012
// for i = 1 to mc_bases do
49610: LD_ADDR_VAR 0 2
49614: PUSH
49615: DOUBLE
49616: LD_INT 1
49618: DEC
49619: ST_TO_ADDR
49620: LD_EXP 102
49624: PUSH
49625: FOR_TO
49626: IFFALSE 50010
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
49628: LD_EXP 105
49632: PUSH
49633: LD_VAR 0 2
49637: ARRAY
49638: PUSH
49639: LD_INT 1
49641: ARRAY
49642: NOT
49643: PUSH
49644: LD_EXP 105
49648: PUSH
49649: LD_VAR 0 2
49653: ARRAY
49654: PUSH
49655: LD_INT 2
49657: ARRAY
49658: NOT
49659: AND
49660: IFFALSE 49698
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
49662: LD_ADDR_EXP 106
49666: PUSH
49667: LD_EXP 106
49671: PPUSH
49672: LD_VAR 0 2
49676: PPUSH
49677: EMPTY
49678: PPUSH
49679: CALL_OW 1
49683: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
49684: LD_VAR 0 2
49688: PPUSH
49689: LD_INT 102
49691: PPUSH
49692: CALL 43733 0 2
// continue ;
49696: GO 49625
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
49698: LD_ADDR_VAR 0 4
49702: PUSH
49703: LD_EXP 102
49707: PUSH
49708: LD_VAR 0 2
49712: ARRAY
49713: PPUSH
49714: LD_INT 25
49716: PUSH
49717: LD_INT 4
49719: PUSH
49720: EMPTY
49721: LIST
49722: LIST
49723: PPUSH
49724: CALL_OW 72
49728: ST_TO_ADDR
// if not tmp then
49729: LD_VAR 0 4
49733: NOT
49734: IFFALSE 49738
// continue ;
49736: GO 49625
// if mc_taming [ i ] then
49738: LD_EXP 133
49742: PUSH
49743: LD_VAR 0 2
49747: ARRAY
49748: IFFALSE 49772
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
49750: LD_ADDR_EXP 133
49754: PUSH
49755: LD_EXP 133
49759: PPUSH
49760: LD_VAR 0 2
49764: PPUSH
49765: EMPTY
49766: PPUSH
49767: CALL_OW 1
49771: ST_TO_ADDR
// for j in tmp do
49772: LD_ADDR_VAR 0 3
49776: PUSH
49777: LD_VAR 0 4
49781: PUSH
49782: FOR_IN
49783: IFFALSE 50006
// begin if IsInUnit ( j ) then
49785: LD_VAR 0 3
49789: PPUSH
49790: CALL_OW 310
49794: IFFALSE 49805
// ComExitBuilding ( j ) ;
49796: LD_VAR 0 3
49800: PPUSH
49801: CALL_OW 122
// if not j in mc_healers [ i ] then
49805: LD_VAR 0 3
49809: PUSH
49810: LD_EXP 106
49814: PUSH
49815: LD_VAR 0 2
49819: ARRAY
49820: IN
49821: NOT
49822: IFFALSE 49868
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
49824: LD_ADDR_EXP 106
49828: PUSH
49829: LD_EXP 106
49833: PPUSH
49834: LD_VAR 0 2
49838: PUSH
49839: LD_EXP 106
49843: PUSH
49844: LD_VAR 0 2
49848: ARRAY
49849: PUSH
49850: LD_INT 1
49852: PLUS
49853: PUSH
49854: EMPTY
49855: LIST
49856: LIST
49857: PPUSH
49858: LD_VAR 0 3
49862: PPUSH
49863: CALL 75255 0 3
49867: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
49868: LD_VAR 0 3
49872: PPUSH
49873: CALL_OW 110
49877: PUSH
49878: LD_INT 102
49880: NONEQUAL
49881: IFFALSE 49895
// SetTag ( j , 102 ) ;
49883: LD_VAR 0 3
49887: PPUSH
49888: LD_INT 102
49890: PPUSH
49891: CALL_OW 109
// Wait ( 3 ) ;
49895: LD_INT 3
49897: PPUSH
49898: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
49902: LD_EXP 105
49906: PUSH
49907: LD_VAR 0 2
49911: ARRAY
49912: PUSH
49913: LD_INT 1
49915: ARRAY
49916: IFFALSE 49948
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
49918: LD_VAR 0 3
49922: PPUSH
49923: LD_EXP 105
49927: PUSH
49928: LD_VAR 0 2
49932: ARRAY
49933: PUSH
49934: LD_INT 1
49936: ARRAY
49937: PUSH
49938: LD_INT 1
49940: ARRAY
49941: PPUSH
49942: CALL_OW 128
49946: GO 50004
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
49948: LD_VAR 0 3
49952: PPUSH
49953: CALL_OW 314
49957: NOT
49958: PUSH
49959: LD_EXP 105
49963: PUSH
49964: LD_VAR 0 2
49968: ARRAY
49969: PUSH
49970: LD_INT 2
49972: ARRAY
49973: AND
49974: IFFALSE 50004
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
49976: LD_VAR 0 3
49980: PPUSH
49981: LD_EXP 105
49985: PUSH
49986: LD_VAR 0 2
49990: ARRAY
49991: PUSH
49992: LD_INT 2
49994: ARRAY
49995: PUSH
49996: LD_INT 1
49998: ARRAY
49999: PPUSH
50000: CALL_OW 128
// end ;
50004: GO 49782
50006: POP
50007: POP
// end ;
50008: GO 49625
50010: POP
50011: POP
// end ;
50012: LD_VAR 0 1
50016: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
50017: LD_INT 0
50019: PPUSH
50020: PPUSH
50021: PPUSH
50022: PPUSH
50023: PPUSH
50024: PPUSH
// if not mc_bases then
50025: LD_EXP 102
50029: NOT
50030: IFFALSE 50034
// exit ;
50032: GO 51197
// for i = 1 to mc_bases do
50034: LD_ADDR_VAR 0 2
50038: PUSH
50039: DOUBLE
50040: LD_INT 1
50042: DEC
50043: ST_TO_ADDR
50044: LD_EXP 102
50048: PUSH
50049: FOR_TO
50050: IFFALSE 51195
// begin if mc_scan [ i ] then
50052: LD_EXP 125
50056: PUSH
50057: LD_VAR 0 2
50061: ARRAY
50062: IFFALSE 50066
// continue ;
50064: GO 50049
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
50066: LD_EXP 107
50070: PUSH
50071: LD_VAR 0 2
50075: ARRAY
50076: NOT
50077: PUSH
50078: LD_EXP 109
50082: PUSH
50083: LD_VAR 0 2
50087: ARRAY
50088: NOT
50089: AND
50090: PUSH
50091: LD_EXP 108
50095: PUSH
50096: LD_VAR 0 2
50100: ARRAY
50101: AND
50102: IFFALSE 50140
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
50104: LD_ADDR_EXP 108
50108: PUSH
50109: LD_EXP 108
50113: PPUSH
50114: LD_VAR 0 2
50118: PPUSH
50119: EMPTY
50120: PPUSH
50121: CALL_OW 1
50125: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
50126: LD_VAR 0 2
50130: PPUSH
50131: LD_INT 103
50133: PPUSH
50134: CALL 43733 0 2
// continue ;
50138: GO 50049
// end ; if mc_construct_list [ i ] then
50140: LD_EXP 109
50144: PUSH
50145: LD_VAR 0 2
50149: ARRAY
50150: IFFALSE 50370
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
50152: LD_ADDR_VAR 0 5
50156: PUSH
50157: LD_EXP 102
50161: PUSH
50162: LD_VAR 0 2
50166: ARRAY
50167: PPUSH
50168: LD_INT 25
50170: PUSH
50171: LD_INT 2
50173: PUSH
50174: EMPTY
50175: LIST
50176: LIST
50177: PPUSH
50178: CALL_OW 72
50182: PUSH
50183: LD_EXP 104
50187: PUSH
50188: LD_VAR 0 2
50192: ARRAY
50193: DIFF
50194: ST_TO_ADDR
// if not tmp then
50195: LD_VAR 0 5
50199: NOT
50200: IFFALSE 50204
// continue ;
50202: GO 50049
// for j in tmp do
50204: LD_ADDR_VAR 0 3
50208: PUSH
50209: LD_VAR 0 5
50213: PUSH
50214: FOR_IN
50215: IFFALSE 50366
// begin if not mc_builders [ i ] then
50217: LD_EXP 108
50221: PUSH
50222: LD_VAR 0 2
50226: ARRAY
50227: NOT
50228: IFFALSE 50286
// begin SetTag ( j , 103 ) ;
50230: LD_VAR 0 3
50234: PPUSH
50235: LD_INT 103
50237: PPUSH
50238: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
50242: LD_ADDR_EXP 108
50246: PUSH
50247: LD_EXP 108
50251: PPUSH
50252: LD_VAR 0 2
50256: PUSH
50257: LD_EXP 108
50261: PUSH
50262: LD_VAR 0 2
50266: ARRAY
50267: PUSH
50268: LD_INT 1
50270: PLUS
50271: PUSH
50272: EMPTY
50273: LIST
50274: LIST
50275: PPUSH
50276: LD_VAR 0 3
50280: PPUSH
50281: CALL 75255 0 3
50285: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
50286: LD_VAR 0 3
50290: PPUSH
50291: CALL_OW 310
50295: IFFALSE 50306
// ComExitBuilding ( j ) ;
50297: LD_VAR 0 3
50301: PPUSH
50302: CALL_OW 122
// wait ( 3 ) ;
50306: LD_INT 3
50308: PPUSH
50309: CALL_OW 67
// if not mc_construct_list [ i ] then
50313: LD_EXP 109
50317: PUSH
50318: LD_VAR 0 2
50322: ARRAY
50323: NOT
50324: IFFALSE 50328
// break ;
50326: GO 50366
// if not HasTask ( j ) then
50328: LD_VAR 0 3
50332: PPUSH
50333: CALL_OW 314
50337: NOT
50338: IFFALSE 50364
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
50340: LD_VAR 0 3
50344: PPUSH
50345: LD_EXP 109
50349: PUSH
50350: LD_VAR 0 2
50354: ARRAY
50355: PUSH
50356: LD_INT 1
50358: ARRAY
50359: PPUSH
50360: CALL 78493 0 2
// end ;
50364: GO 50214
50366: POP
50367: POP
// end else
50368: GO 51193
// if mc_build_list [ i ] then
50370: LD_EXP 107
50374: PUSH
50375: LD_VAR 0 2
50379: ARRAY
50380: IFFALSE 51193
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
50382: LD_EXP 107
50386: PUSH
50387: LD_VAR 0 2
50391: ARRAY
50392: PUSH
50393: LD_INT 1
50395: ARRAY
50396: PUSH
50397: LD_INT 1
50399: ARRAY
50400: PPUSH
50401: CALL 78317 0 1
50405: PUSH
50406: LD_EXP 102
50410: PUSH
50411: LD_VAR 0 2
50415: ARRAY
50416: PPUSH
50417: LD_INT 2
50419: PUSH
50420: LD_INT 30
50422: PUSH
50423: LD_INT 2
50425: PUSH
50426: EMPTY
50427: LIST
50428: LIST
50429: PUSH
50430: LD_INT 30
50432: PUSH
50433: LD_INT 3
50435: PUSH
50436: EMPTY
50437: LIST
50438: LIST
50439: PUSH
50440: EMPTY
50441: LIST
50442: LIST
50443: LIST
50444: PPUSH
50445: CALL_OW 72
50449: NOT
50450: AND
50451: IFFALSE 50556
// begin for j = 1 to mc_build_list [ i ] do
50453: LD_ADDR_VAR 0 3
50457: PUSH
50458: DOUBLE
50459: LD_INT 1
50461: DEC
50462: ST_TO_ADDR
50463: LD_EXP 107
50467: PUSH
50468: LD_VAR 0 2
50472: ARRAY
50473: PUSH
50474: FOR_TO
50475: IFFALSE 50554
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
50477: LD_EXP 107
50481: PUSH
50482: LD_VAR 0 2
50486: ARRAY
50487: PUSH
50488: LD_VAR 0 3
50492: ARRAY
50493: PUSH
50494: LD_INT 1
50496: ARRAY
50497: PUSH
50498: LD_INT 2
50500: EQUAL
50501: IFFALSE 50552
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
50503: LD_ADDR_EXP 107
50507: PUSH
50508: LD_EXP 107
50512: PPUSH
50513: LD_VAR 0 2
50517: PPUSH
50518: LD_EXP 107
50522: PUSH
50523: LD_VAR 0 2
50527: ARRAY
50528: PPUSH
50529: LD_VAR 0 3
50533: PPUSH
50534: LD_INT 1
50536: PPUSH
50537: LD_INT 0
50539: PPUSH
50540: CALL 74673 0 4
50544: PPUSH
50545: CALL_OW 1
50549: ST_TO_ADDR
// break ;
50550: GO 50554
// end ;
50552: GO 50474
50554: POP
50555: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50556: LD_ADDR_VAR 0 6
50560: PUSH
50561: LD_EXP 102
50565: PUSH
50566: LD_VAR 0 2
50570: ARRAY
50571: PPUSH
50572: LD_INT 2
50574: PUSH
50575: LD_INT 30
50577: PUSH
50578: LD_INT 0
50580: PUSH
50581: EMPTY
50582: LIST
50583: LIST
50584: PUSH
50585: LD_INT 30
50587: PUSH
50588: LD_INT 1
50590: PUSH
50591: EMPTY
50592: LIST
50593: LIST
50594: PUSH
50595: EMPTY
50596: LIST
50597: LIST
50598: LIST
50599: PPUSH
50600: CALL_OW 72
50604: ST_TO_ADDR
// for k := 1 to depot do
50605: LD_ADDR_VAR 0 4
50609: PUSH
50610: DOUBLE
50611: LD_INT 1
50613: DEC
50614: ST_TO_ADDR
50615: LD_VAR 0 6
50619: PUSH
50620: FOR_TO
50621: IFFALSE 51191
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
50623: LD_EXP 107
50627: PUSH
50628: LD_VAR 0 2
50632: ARRAY
50633: PUSH
50634: LD_INT 1
50636: ARRAY
50637: PUSH
50638: LD_INT 1
50640: ARRAY
50641: PUSH
50642: LD_INT 0
50644: EQUAL
50645: PUSH
50646: LD_VAR 0 6
50650: PUSH
50651: LD_VAR 0 4
50655: ARRAY
50656: PPUSH
50657: LD_EXP 107
50661: PUSH
50662: LD_VAR 0 2
50666: ARRAY
50667: PUSH
50668: LD_INT 1
50670: ARRAY
50671: PUSH
50672: LD_INT 1
50674: ARRAY
50675: PPUSH
50676: LD_EXP 107
50680: PUSH
50681: LD_VAR 0 2
50685: ARRAY
50686: PUSH
50687: LD_INT 1
50689: ARRAY
50690: PUSH
50691: LD_INT 2
50693: ARRAY
50694: PPUSH
50695: LD_EXP 107
50699: PUSH
50700: LD_VAR 0 2
50704: ARRAY
50705: PUSH
50706: LD_INT 1
50708: ARRAY
50709: PUSH
50710: LD_INT 3
50712: ARRAY
50713: PPUSH
50714: LD_EXP 107
50718: PUSH
50719: LD_VAR 0 2
50723: ARRAY
50724: PUSH
50725: LD_INT 1
50727: ARRAY
50728: PUSH
50729: LD_INT 4
50731: ARRAY
50732: PPUSH
50733: CALL 83729 0 5
50737: OR
50738: IFFALSE 51019
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
50740: LD_ADDR_VAR 0 5
50744: PUSH
50745: LD_EXP 102
50749: PUSH
50750: LD_VAR 0 2
50754: ARRAY
50755: PPUSH
50756: LD_INT 25
50758: PUSH
50759: LD_INT 2
50761: PUSH
50762: EMPTY
50763: LIST
50764: LIST
50765: PPUSH
50766: CALL_OW 72
50770: PUSH
50771: LD_EXP 104
50775: PUSH
50776: LD_VAR 0 2
50780: ARRAY
50781: DIFF
50782: ST_TO_ADDR
// if not tmp then
50783: LD_VAR 0 5
50787: NOT
50788: IFFALSE 50792
// continue ;
50790: GO 50620
// for j in tmp do
50792: LD_ADDR_VAR 0 3
50796: PUSH
50797: LD_VAR 0 5
50801: PUSH
50802: FOR_IN
50803: IFFALSE 51015
// begin if not mc_builders [ i ] then
50805: LD_EXP 108
50809: PUSH
50810: LD_VAR 0 2
50814: ARRAY
50815: NOT
50816: IFFALSE 50874
// begin SetTag ( j , 103 ) ;
50818: LD_VAR 0 3
50822: PPUSH
50823: LD_INT 103
50825: PPUSH
50826: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
50830: LD_ADDR_EXP 108
50834: PUSH
50835: LD_EXP 108
50839: PPUSH
50840: LD_VAR 0 2
50844: PUSH
50845: LD_EXP 108
50849: PUSH
50850: LD_VAR 0 2
50854: ARRAY
50855: PUSH
50856: LD_INT 1
50858: PLUS
50859: PUSH
50860: EMPTY
50861: LIST
50862: LIST
50863: PPUSH
50864: LD_VAR 0 3
50868: PPUSH
50869: CALL 75255 0 3
50873: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
50874: LD_VAR 0 3
50878: PPUSH
50879: CALL_OW 310
50883: IFFALSE 50894
// ComExitBuilding ( j ) ;
50885: LD_VAR 0 3
50889: PPUSH
50890: CALL_OW 122
// wait ( 3 ) ;
50894: LD_INT 3
50896: PPUSH
50897: CALL_OW 67
// if not mc_build_list [ i ] then
50901: LD_EXP 107
50905: PUSH
50906: LD_VAR 0 2
50910: ARRAY
50911: NOT
50912: IFFALSE 50916
// break ;
50914: GO 51015
// if not HasTask ( j ) then
50916: LD_VAR 0 3
50920: PPUSH
50921: CALL_OW 314
50925: NOT
50926: IFFALSE 51013
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
50928: LD_VAR 0 3
50932: PPUSH
50933: LD_EXP 107
50937: PUSH
50938: LD_VAR 0 2
50942: ARRAY
50943: PUSH
50944: LD_INT 1
50946: ARRAY
50947: PUSH
50948: LD_INT 1
50950: ARRAY
50951: PPUSH
50952: LD_EXP 107
50956: PUSH
50957: LD_VAR 0 2
50961: ARRAY
50962: PUSH
50963: LD_INT 1
50965: ARRAY
50966: PUSH
50967: LD_INT 2
50969: ARRAY
50970: PPUSH
50971: LD_EXP 107
50975: PUSH
50976: LD_VAR 0 2
50980: ARRAY
50981: PUSH
50982: LD_INT 1
50984: ARRAY
50985: PUSH
50986: LD_INT 3
50988: ARRAY
50989: PPUSH
50990: LD_EXP 107
50994: PUSH
50995: LD_VAR 0 2
50999: ARRAY
51000: PUSH
51001: LD_INT 1
51003: ARRAY
51004: PUSH
51005: LD_INT 4
51007: ARRAY
51008: PPUSH
51009: CALL_OW 145
// end ;
51013: GO 50802
51015: POP
51016: POP
// end else
51017: GO 51189
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
51019: LD_EXP 102
51023: PUSH
51024: LD_VAR 0 2
51028: ARRAY
51029: PPUSH
51030: LD_EXP 107
51034: PUSH
51035: LD_VAR 0 2
51039: ARRAY
51040: PUSH
51041: LD_INT 1
51043: ARRAY
51044: PUSH
51045: LD_INT 1
51047: ARRAY
51048: PPUSH
51049: LD_EXP 107
51053: PUSH
51054: LD_VAR 0 2
51058: ARRAY
51059: PUSH
51060: LD_INT 1
51062: ARRAY
51063: PUSH
51064: LD_INT 2
51066: ARRAY
51067: PPUSH
51068: LD_EXP 107
51072: PUSH
51073: LD_VAR 0 2
51077: ARRAY
51078: PUSH
51079: LD_INT 1
51081: ARRAY
51082: PUSH
51083: LD_INT 3
51085: ARRAY
51086: PPUSH
51087: LD_EXP 107
51091: PUSH
51092: LD_VAR 0 2
51096: ARRAY
51097: PUSH
51098: LD_INT 1
51100: ARRAY
51101: PUSH
51102: LD_INT 4
51104: ARRAY
51105: PPUSH
51106: LD_EXP 102
51110: PUSH
51111: LD_VAR 0 2
51115: ARRAY
51116: PPUSH
51117: LD_INT 21
51119: PUSH
51120: LD_INT 3
51122: PUSH
51123: EMPTY
51124: LIST
51125: LIST
51126: PPUSH
51127: CALL_OW 72
51131: PPUSH
51132: EMPTY
51133: PPUSH
51134: CALL 82483 0 7
51138: NOT
51139: IFFALSE 51189
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
51141: LD_ADDR_EXP 107
51145: PUSH
51146: LD_EXP 107
51150: PPUSH
51151: LD_VAR 0 2
51155: PPUSH
51156: LD_EXP 107
51160: PUSH
51161: LD_VAR 0 2
51165: ARRAY
51166: PPUSH
51167: LD_INT 1
51169: PPUSH
51170: LD_INT 1
51172: NEG
51173: PPUSH
51174: LD_INT 0
51176: PPUSH
51177: CALL 74673 0 4
51181: PPUSH
51182: CALL_OW 1
51186: ST_TO_ADDR
// continue ;
51187: GO 50620
// end ; end ;
51189: GO 50620
51191: POP
51192: POP
// end ; end ;
51193: GO 50049
51195: POP
51196: POP
// end ;
51197: LD_VAR 0 1
51201: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
51202: LD_INT 0
51204: PPUSH
51205: PPUSH
51206: PPUSH
51207: PPUSH
51208: PPUSH
51209: PPUSH
// if not mc_bases then
51210: LD_EXP 102
51214: NOT
51215: IFFALSE 51219
// exit ;
51217: GO 51646
// for i = 1 to mc_bases do
51219: LD_ADDR_VAR 0 2
51223: PUSH
51224: DOUBLE
51225: LD_INT 1
51227: DEC
51228: ST_TO_ADDR
51229: LD_EXP 102
51233: PUSH
51234: FOR_TO
51235: IFFALSE 51644
// begin tmp := mc_build_upgrade [ i ] ;
51237: LD_ADDR_VAR 0 4
51241: PUSH
51242: LD_EXP 134
51246: PUSH
51247: LD_VAR 0 2
51251: ARRAY
51252: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
51253: LD_ADDR_VAR 0 6
51257: PUSH
51258: LD_EXP 135
51262: PUSH
51263: LD_VAR 0 2
51267: ARRAY
51268: PPUSH
51269: LD_INT 2
51271: PUSH
51272: LD_INT 30
51274: PUSH
51275: LD_INT 6
51277: PUSH
51278: EMPTY
51279: LIST
51280: LIST
51281: PUSH
51282: LD_INT 30
51284: PUSH
51285: LD_INT 7
51287: PUSH
51288: EMPTY
51289: LIST
51290: LIST
51291: PUSH
51292: EMPTY
51293: LIST
51294: LIST
51295: LIST
51296: PPUSH
51297: CALL_OW 72
51301: ST_TO_ADDR
// if not tmp and not lab then
51302: LD_VAR 0 4
51306: NOT
51307: PUSH
51308: LD_VAR 0 6
51312: NOT
51313: AND
51314: IFFALSE 51318
// continue ;
51316: GO 51234
// if tmp then
51318: LD_VAR 0 4
51322: IFFALSE 51442
// for j in tmp do
51324: LD_ADDR_VAR 0 3
51328: PUSH
51329: LD_VAR 0 4
51333: PUSH
51334: FOR_IN
51335: IFFALSE 51440
// begin if UpgradeCost ( j ) then
51337: LD_VAR 0 3
51341: PPUSH
51342: CALL 82143 0 1
51346: IFFALSE 51438
// begin ComUpgrade ( j ) ;
51348: LD_VAR 0 3
51352: PPUSH
51353: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
51357: LD_ADDR_EXP 134
51361: PUSH
51362: LD_EXP 134
51366: PPUSH
51367: LD_VAR 0 2
51371: PPUSH
51372: LD_EXP 134
51376: PUSH
51377: LD_VAR 0 2
51381: ARRAY
51382: PUSH
51383: LD_VAR 0 3
51387: DIFF
51388: PPUSH
51389: CALL_OW 1
51393: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
51394: LD_ADDR_EXP 109
51398: PUSH
51399: LD_EXP 109
51403: PPUSH
51404: LD_VAR 0 2
51408: PUSH
51409: LD_EXP 109
51413: PUSH
51414: LD_VAR 0 2
51418: ARRAY
51419: PUSH
51420: LD_INT 1
51422: PLUS
51423: PUSH
51424: EMPTY
51425: LIST
51426: LIST
51427: PPUSH
51428: LD_VAR 0 3
51432: PPUSH
51433: CALL 75255 0 3
51437: ST_TO_ADDR
// end ; end ;
51438: GO 51334
51440: POP
51441: POP
// if not lab or not mc_lab_upgrade [ i ] then
51442: LD_VAR 0 6
51446: NOT
51447: PUSH
51448: LD_EXP 136
51452: PUSH
51453: LD_VAR 0 2
51457: ARRAY
51458: NOT
51459: OR
51460: IFFALSE 51464
// continue ;
51462: GO 51234
// for j in lab do
51464: LD_ADDR_VAR 0 3
51468: PUSH
51469: LD_VAR 0 6
51473: PUSH
51474: FOR_IN
51475: IFFALSE 51640
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
51477: LD_VAR 0 3
51481: PPUSH
51482: CALL_OW 266
51486: PUSH
51487: LD_INT 6
51489: PUSH
51490: LD_INT 7
51492: PUSH
51493: EMPTY
51494: LIST
51495: LIST
51496: IN
51497: PUSH
51498: LD_VAR 0 3
51502: PPUSH
51503: CALL_OW 461
51507: PUSH
51508: LD_INT 1
51510: NONEQUAL
51511: AND
51512: IFFALSE 51638
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
51514: LD_VAR 0 3
51518: PPUSH
51519: LD_EXP 136
51523: PUSH
51524: LD_VAR 0 2
51528: ARRAY
51529: PUSH
51530: LD_INT 1
51532: ARRAY
51533: PPUSH
51534: CALL 82348 0 2
51538: IFFALSE 51638
// begin ComCancel ( j ) ;
51540: LD_VAR 0 3
51544: PPUSH
51545: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
51549: LD_VAR 0 3
51553: PPUSH
51554: LD_EXP 136
51558: PUSH
51559: LD_VAR 0 2
51563: ARRAY
51564: PUSH
51565: LD_INT 1
51567: ARRAY
51568: PPUSH
51569: CALL_OW 207
// if not j in mc_construct_list [ i ] then
51573: LD_VAR 0 3
51577: PUSH
51578: LD_EXP 109
51582: PUSH
51583: LD_VAR 0 2
51587: ARRAY
51588: IN
51589: NOT
51590: IFFALSE 51636
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
51592: LD_ADDR_EXP 109
51596: PUSH
51597: LD_EXP 109
51601: PPUSH
51602: LD_VAR 0 2
51606: PUSH
51607: LD_EXP 109
51611: PUSH
51612: LD_VAR 0 2
51616: ARRAY
51617: PUSH
51618: LD_INT 1
51620: PLUS
51621: PUSH
51622: EMPTY
51623: LIST
51624: LIST
51625: PPUSH
51626: LD_VAR 0 3
51630: PPUSH
51631: CALL 75255 0 3
51635: ST_TO_ADDR
// break ;
51636: GO 51640
// end ; end ; end ;
51638: GO 51474
51640: POP
51641: POP
// end ;
51642: GO 51234
51644: POP
51645: POP
// end ;
51646: LD_VAR 0 1
51650: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
51651: LD_INT 0
51653: PPUSH
51654: PPUSH
51655: PPUSH
51656: PPUSH
51657: PPUSH
51658: PPUSH
51659: PPUSH
51660: PPUSH
51661: PPUSH
// if not mc_bases then
51662: LD_EXP 102
51666: NOT
51667: IFFALSE 51671
// exit ;
51669: GO 52076
// for i = 1 to mc_bases do
51671: LD_ADDR_VAR 0 2
51675: PUSH
51676: DOUBLE
51677: LD_INT 1
51679: DEC
51680: ST_TO_ADDR
51681: LD_EXP 102
51685: PUSH
51686: FOR_TO
51687: IFFALSE 52074
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
51689: LD_EXP 110
51693: PUSH
51694: LD_VAR 0 2
51698: ARRAY
51699: NOT
51700: PUSH
51701: LD_EXP 102
51705: PUSH
51706: LD_VAR 0 2
51710: ARRAY
51711: PPUSH
51712: LD_INT 30
51714: PUSH
51715: LD_INT 3
51717: PUSH
51718: EMPTY
51719: LIST
51720: LIST
51721: PPUSH
51722: CALL_OW 72
51726: NOT
51727: OR
51728: IFFALSE 51732
// continue ;
51730: GO 51686
// busy := false ;
51732: LD_ADDR_VAR 0 8
51736: PUSH
51737: LD_INT 0
51739: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51740: LD_ADDR_VAR 0 4
51744: PUSH
51745: LD_EXP 102
51749: PUSH
51750: LD_VAR 0 2
51754: ARRAY
51755: PPUSH
51756: LD_INT 30
51758: PUSH
51759: LD_INT 3
51761: PUSH
51762: EMPTY
51763: LIST
51764: LIST
51765: PPUSH
51766: CALL_OW 72
51770: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
51771: LD_ADDR_VAR 0 6
51775: PUSH
51776: LD_EXP 110
51780: PUSH
51781: LD_VAR 0 2
51785: ARRAY
51786: PPUSH
51787: LD_INT 2
51789: PUSH
51790: LD_INT 30
51792: PUSH
51793: LD_INT 32
51795: PUSH
51796: EMPTY
51797: LIST
51798: LIST
51799: PUSH
51800: LD_INT 30
51802: PUSH
51803: LD_INT 33
51805: PUSH
51806: EMPTY
51807: LIST
51808: LIST
51809: PUSH
51810: EMPTY
51811: LIST
51812: LIST
51813: LIST
51814: PPUSH
51815: CALL_OW 72
51819: ST_TO_ADDR
// if not t then
51820: LD_VAR 0 6
51824: NOT
51825: IFFALSE 51829
// continue ;
51827: GO 51686
// for j in tmp do
51829: LD_ADDR_VAR 0 3
51833: PUSH
51834: LD_VAR 0 4
51838: PUSH
51839: FOR_IN
51840: IFFALSE 51870
// if not BuildingStatus ( j ) = bs_idle then
51842: LD_VAR 0 3
51846: PPUSH
51847: CALL_OW 461
51851: PUSH
51852: LD_INT 2
51854: EQUAL
51855: NOT
51856: IFFALSE 51868
// begin busy := true ;
51858: LD_ADDR_VAR 0 8
51862: PUSH
51863: LD_INT 1
51865: ST_TO_ADDR
// break ;
51866: GO 51870
// end ;
51868: GO 51839
51870: POP
51871: POP
// if busy then
51872: LD_VAR 0 8
51876: IFFALSE 51880
// continue ;
51878: GO 51686
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
51880: LD_ADDR_VAR 0 7
51884: PUSH
51885: LD_VAR 0 6
51889: PPUSH
51890: LD_INT 35
51892: PUSH
51893: LD_INT 0
51895: PUSH
51896: EMPTY
51897: LIST
51898: LIST
51899: PPUSH
51900: CALL_OW 72
51904: ST_TO_ADDR
// if tw then
51905: LD_VAR 0 7
51909: IFFALSE 51986
// begin tw := tw [ 1 ] ;
51911: LD_ADDR_VAR 0 7
51915: PUSH
51916: LD_VAR 0 7
51920: PUSH
51921: LD_INT 1
51923: ARRAY
51924: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
51925: LD_ADDR_VAR 0 9
51929: PUSH
51930: LD_VAR 0 7
51934: PPUSH
51935: LD_EXP 127
51939: PUSH
51940: LD_VAR 0 2
51944: ARRAY
51945: PPUSH
51946: CALL 80640 0 2
51950: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
51951: LD_EXP 141
51955: PUSH
51956: LD_VAR 0 2
51960: ARRAY
51961: IFFALSE 51984
// if not weapon in mc_allowed_tower_weapons [ i ] then
51963: LD_VAR 0 9
51967: PUSH
51968: LD_EXP 141
51972: PUSH
51973: LD_VAR 0 2
51977: ARRAY
51978: IN
51979: NOT
51980: IFFALSE 51984
// continue ;
51982: GO 51686
// end else
51984: GO 52049
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
51986: LD_ADDR_VAR 0 5
51990: PUSH
51991: LD_EXP 110
51995: PUSH
51996: LD_VAR 0 2
52000: ARRAY
52001: PPUSH
52002: LD_VAR 0 4
52006: PPUSH
52007: CALL 107552 0 2
52011: ST_TO_ADDR
// if not tmp2 then
52012: LD_VAR 0 5
52016: NOT
52017: IFFALSE 52021
// continue ;
52019: GO 51686
// tw := tmp2 [ 1 ] ;
52021: LD_ADDR_VAR 0 7
52025: PUSH
52026: LD_VAR 0 5
52030: PUSH
52031: LD_INT 1
52033: ARRAY
52034: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
52035: LD_ADDR_VAR 0 9
52039: PUSH
52040: LD_VAR 0 5
52044: PUSH
52045: LD_INT 2
52047: ARRAY
52048: ST_TO_ADDR
// end ; if not weapon then
52049: LD_VAR 0 9
52053: NOT
52054: IFFALSE 52058
// continue ;
52056: GO 51686
// ComPlaceWeapon ( tw , weapon ) ;
52058: LD_VAR 0 7
52062: PPUSH
52063: LD_VAR 0 9
52067: PPUSH
52068: CALL_OW 148
// end ;
52072: GO 51686
52074: POP
52075: POP
// end ;
52076: LD_VAR 0 1
52080: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
52081: LD_INT 0
52083: PPUSH
52084: PPUSH
52085: PPUSH
52086: PPUSH
52087: PPUSH
52088: PPUSH
52089: PPUSH
// if not mc_bases then
52090: LD_EXP 102
52094: NOT
52095: IFFALSE 52099
// exit ;
52097: GO 52874
// for i = 1 to mc_bases do
52099: LD_ADDR_VAR 0 2
52103: PUSH
52104: DOUBLE
52105: LD_INT 1
52107: DEC
52108: ST_TO_ADDR
52109: LD_EXP 102
52113: PUSH
52114: FOR_TO
52115: IFFALSE 52872
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
52117: LD_EXP 115
52121: PUSH
52122: LD_VAR 0 2
52126: ARRAY
52127: NOT
52128: PUSH
52129: LD_EXP 115
52133: PUSH
52134: LD_VAR 0 2
52138: ARRAY
52139: PUSH
52140: LD_EXP 116
52144: PUSH
52145: LD_VAR 0 2
52149: ARRAY
52150: EQUAL
52151: OR
52152: PUSH
52153: LD_EXP 125
52157: PUSH
52158: LD_VAR 0 2
52162: ARRAY
52163: OR
52164: IFFALSE 52168
// continue ;
52166: GO 52114
// if mc_miners [ i ] then
52168: LD_EXP 116
52172: PUSH
52173: LD_VAR 0 2
52177: ARRAY
52178: IFFALSE 52559
// begin for j = mc_miners [ i ] downto 1 do
52180: LD_ADDR_VAR 0 3
52184: PUSH
52185: DOUBLE
52186: LD_EXP 116
52190: PUSH
52191: LD_VAR 0 2
52195: ARRAY
52196: INC
52197: ST_TO_ADDR
52198: LD_INT 1
52200: PUSH
52201: FOR_DOWNTO
52202: IFFALSE 52557
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
52204: LD_EXP 116
52208: PUSH
52209: LD_VAR 0 2
52213: ARRAY
52214: PUSH
52215: LD_VAR 0 3
52219: ARRAY
52220: PPUSH
52221: CALL_OW 301
52225: PUSH
52226: LD_EXP 116
52230: PUSH
52231: LD_VAR 0 2
52235: ARRAY
52236: PUSH
52237: LD_VAR 0 3
52241: ARRAY
52242: PPUSH
52243: CALL_OW 257
52247: PUSH
52248: LD_INT 1
52250: NONEQUAL
52251: OR
52252: IFFALSE 52315
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
52254: LD_ADDR_VAR 0 5
52258: PUSH
52259: LD_EXP 116
52263: PUSH
52264: LD_VAR 0 2
52268: ARRAY
52269: PUSH
52270: LD_EXP 116
52274: PUSH
52275: LD_VAR 0 2
52279: ARRAY
52280: PUSH
52281: LD_VAR 0 3
52285: ARRAY
52286: DIFF
52287: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
52288: LD_ADDR_EXP 116
52292: PUSH
52293: LD_EXP 116
52297: PPUSH
52298: LD_VAR 0 2
52302: PPUSH
52303: LD_VAR 0 5
52307: PPUSH
52308: CALL_OW 1
52312: ST_TO_ADDR
// continue ;
52313: GO 52201
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
52315: LD_EXP 116
52319: PUSH
52320: LD_VAR 0 2
52324: ARRAY
52325: PUSH
52326: LD_VAR 0 3
52330: ARRAY
52331: PPUSH
52332: CALL_OW 257
52336: PUSH
52337: LD_INT 1
52339: EQUAL
52340: PUSH
52341: LD_EXP 116
52345: PUSH
52346: LD_VAR 0 2
52350: ARRAY
52351: PUSH
52352: LD_VAR 0 3
52356: ARRAY
52357: PPUSH
52358: CALL_OW 459
52362: NOT
52363: AND
52364: PUSH
52365: LD_EXP 116
52369: PUSH
52370: LD_VAR 0 2
52374: ARRAY
52375: PUSH
52376: LD_VAR 0 3
52380: ARRAY
52381: PPUSH
52382: CALL_OW 314
52386: NOT
52387: AND
52388: IFFALSE 52555
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
52390: LD_EXP 116
52394: PUSH
52395: LD_VAR 0 2
52399: ARRAY
52400: PUSH
52401: LD_VAR 0 3
52405: ARRAY
52406: PPUSH
52407: CALL_OW 310
52411: IFFALSE 52434
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
52413: LD_EXP 116
52417: PUSH
52418: LD_VAR 0 2
52422: ARRAY
52423: PUSH
52424: LD_VAR 0 3
52428: ARRAY
52429: PPUSH
52430: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
52434: LD_EXP 116
52438: PUSH
52439: LD_VAR 0 2
52443: ARRAY
52444: PUSH
52445: LD_VAR 0 3
52449: ARRAY
52450: PPUSH
52451: CALL_OW 314
52455: NOT
52456: IFFALSE 52555
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
52458: LD_ADDR_VAR 0 7
52462: PUSH
52463: LD_VAR 0 3
52467: PUSH
52468: LD_EXP 115
52472: PUSH
52473: LD_VAR 0 2
52477: ARRAY
52478: PPUSH
52479: CALL 72395 0 1
52483: MOD
52484: PUSH
52485: LD_INT 1
52487: PLUS
52488: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
52489: LD_EXP 116
52493: PUSH
52494: LD_VAR 0 2
52498: ARRAY
52499: PUSH
52500: LD_VAR 0 3
52504: ARRAY
52505: PPUSH
52506: LD_EXP 115
52510: PUSH
52511: LD_VAR 0 2
52515: ARRAY
52516: PUSH
52517: LD_VAR 0 7
52521: ARRAY
52522: PUSH
52523: LD_INT 1
52525: ARRAY
52526: PPUSH
52527: LD_EXP 115
52531: PUSH
52532: LD_VAR 0 2
52536: ARRAY
52537: PUSH
52538: LD_VAR 0 7
52542: ARRAY
52543: PUSH
52544: LD_INT 2
52546: ARRAY
52547: PPUSH
52548: LD_INT 0
52550: PPUSH
52551: CALL_OW 193
// end ; end ; end ;
52555: GO 52201
52557: POP
52558: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
52559: LD_ADDR_VAR 0 5
52563: PUSH
52564: LD_EXP 102
52568: PUSH
52569: LD_VAR 0 2
52573: ARRAY
52574: PPUSH
52575: LD_INT 2
52577: PUSH
52578: LD_INT 30
52580: PUSH
52581: LD_INT 4
52583: PUSH
52584: EMPTY
52585: LIST
52586: LIST
52587: PUSH
52588: LD_INT 30
52590: PUSH
52591: LD_INT 5
52593: PUSH
52594: EMPTY
52595: LIST
52596: LIST
52597: PUSH
52598: LD_INT 30
52600: PUSH
52601: LD_INT 32
52603: PUSH
52604: EMPTY
52605: LIST
52606: LIST
52607: PUSH
52608: EMPTY
52609: LIST
52610: LIST
52611: LIST
52612: LIST
52613: PPUSH
52614: CALL_OW 72
52618: ST_TO_ADDR
// if not tmp then
52619: LD_VAR 0 5
52623: NOT
52624: IFFALSE 52628
// continue ;
52626: GO 52114
// list := [ ] ;
52628: LD_ADDR_VAR 0 6
52632: PUSH
52633: EMPTY
52634: ST_TO_ADDR
// for j in tmp do
52635: LD_ADDR_VAR 0 3
52639: PUSH
52640: LD_VAR 0 5
52644: PUSH
52645: FOR_IN
52646: IFFALSE 52715
// begin for k in UnitsInside ( j ) do
52648: LD_ADDR_VAR 0 4
52652: PUSH
52653: LD_VAR 0 3
52657: PPUSH
52658: CALL_OW 313
52662: PUSH
52663: FOR_IN
52664: IFFALSE 52711
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
52666: LD_VAR 0 4
52670: PPUSH
52671: CALL_OW 257
52675: PUSH
52676: LD_INT 1
52678: EQUAL
52679: PUSH
52680: LD_VAR 0 4
52684: PPUSH
52685: CALL_OW 459
52689: NOT
52690: AND
52691: IFFALSE 52709
// list := list ^ k ;
52693: LD_ADDR_VAR 0 6
52697: PUSH
52698: LD_VAR 0 6
52702: PUSH
52703: LD_VAR 0 4
52707: ADD
52708: ST_TO_ADDR
52709: GO 52663
52711: POP
52712: POP
// end ;
52713: GO 52645
52715: POP
52716: POP
// list := list diff mc_miners [ i ] ;
52717: LD_ADDR_VAR 0 6
52721: PUSH
52722: LD_VAR 0 6
52726: PUSH
52727: LD_EXP 116
52731: PUSH
52732: LD_VAR 0 2
52736: ARRAY
52737: DIFF
52738: ST_TO_ADDR
// if not list then
52739: LD_VAR 0 6
52743: NOT
52744: IFFALSE 52748
// continue ;
52746: GO 52114
// k := mc_mines [ i ] - mc_miners [ i ] ;
52748: LD_ADDR_VAR 0 4
52752: PUSH
52753: LD_EXP 115
52757: PUSH
52758: LD_VAR 0 2
52762: ARRAY
52763: PUSH
52764: LD_EXP 116
52768: PUSH
52769: LD_VAR 0 2
52773: ARRAY
52774: MINUS
52775: ST_TO_ADDR
// if k > list then
52776: LD_VAR 0 4
52780: PUSH
52781: LD_VAR 0 6
52785: GREATER
52786: IFFALSE 52798
// k := list ;
52788: LD_ADDR_VAR 0 4
52792: PUSH
52793: LD_VAR 0 6
52797: ST_TO_ADDR
// for j = 1 to k do
52798: LD_ADDR_VAR 0 3
52802: PUSH
52803: DOUBLE
52804: LD_INT 1
52806: DEC
52807: ST_TO_ADDR
52808: LD_VAR 0 4
52812: PUSH
52813: FOR_TO
52814: IFFALSE 52868
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
52816: LD_ADDR_EXP 116
52820: PUSH
52821: LD_EXP 116
52825: PPUSH
52826: LD_VAR 0 2
52830: PUSH
52831: LD_EXP 116
52835: PUSH
52836: LD_VAR 0 2
52840: ARRAY
52841: PUSH
52842: LD_INT 1
52844: PLUS
52845: PUSH
52846: EMPTY
52847: LIST
52848: LIST
52849: PPUSH
52850: LD_VAR 0 6
52854: PUSH
52855: LD_VAR 0 3
52859: ARRAY
52860: PPUSH
52861: CALL 75255 0 3
52865: ST_TO_ADDR
52866: GO 52813
52868: POP
52869: POP
// end ;
52870: GO 52114
52872: POP
52873: POP
// end ;
52874: LD_VAR 0 1
52878: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
52879: LD_INT 0
52881: PPUSH
52882: PPUSH
52883: PPUSH
52884: PPUSH
52885: PPUSH
52886: PPUSH
52887: PPUSH
52888: PPUSH
52889: PPUSH
52890: PPUSH
52891: PPUSH
// if not mc_bases then
52892: LD_EXP 102
52896: NOT
52897: IFFALSE 52901
// exit ;
52899: GO 54724
// for i = 1 to mc_bases do
52901: LD_ADDR_VAR 0 2
52905: PUSH
52906: DOUBLE
52907: LD_INT 1
52909: DEC
52910: ST_TO_ADDR
52911: LD_EXP 102
52915: PUSH
52916: FOR_TO
52917: IFFALSE 54722
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
52919: LD_EXP 102
52923: PUSH
52924: LD_VAR 0 2
52928: ARRAY
52929: NOT
52930: PUSH
52931: LD_EXP 109
52935: PUSH
52936: LD_VAR 0 2
52940: ARRAY
52941: OR
52942: IFFALSE 52946
// continue ;
52944: GO 52916
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
52946: LD_EXP 118
52950: PUSH
52951: LD_VAR 0 2
52955: ARRAY
52956: NOT
52957: PUSH
52958: LD_EXP 119
52962: PUSH
52963: LD_VAR 0 2
52967: ARRAY
52968: AND
52969: IFFALSE 53007
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
52971: LD_ADDR_EXP 119
52975: PUSH
52976: LD_EXP 119
52980: PPUSH
52981: LD_VAR 0 2
52985: PPUSH
52986: EMPTY
52987: PPUSH
52988: CALL_OW 1
52992: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
52993: LD_VAR 0 2
52997: PPUSH
52998: LD_INT 107
53000: PPUSH
53001: CALL 43733 0 2
// continue ;
53005: GO 52916
// end ; target := [ ] ;
53007: LD_ADDR_VAR 0 7
53011: PUSH
53012: EMPTY
53013: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
53014: LD_ADDR_VAR 0 6
53018: PUSH
53019: LD_EXP 102
53023: PUSH
53024: LD_VAR 0 2
53028: ARRAY
53029: PUSH
53030: LD_INT 1
53032: ARRAY
53033: PPUSH
53034: CALL_OW 255
53038: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53039: LD_ADDR_VAR 0 9
53043: PUSH
53044: LD_EXP 102
53048: PUSH
53049: LD_VAR 0 2
53053: ARRAY
53054: PPUSH
53055: LD_INT 2
53057: PUSH
53058: LD_INT 30
53060: PUSH
53061: LD_INT 0
53063: PUSH
53064: EMPTY
53065: LIST
53066: LIST
53067: PUSH
53068: LD_INT 30
53070: PUSH
53071: LD_INT 1
53073: PUSH
53074: EMPTY
53075: LIST
53076: LIST
53077: PUSH
53078: EMPTY
53079: LIST
53080: LIST
53081: LIST
53082: PPUSH
53083: CALL_OW 72
53087: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
53088: LD_ADDR_VAR 0 3
53092: PUSH
53093: DOUBLE
53094: LD_EXP 118
53098: PUSH
53099: LD_VAR 0 2
53103: ARRAY
53104: INC
53105: ST_TO_ADDR
53106: LD_INT 1
53108: PUSH
53109: FOR_DOWNTO
53110: IFFALSE 53355
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
53112: LD_EXP 118
53116: PUSH
53117: LD_VAR 0 2
53121: ARRAY
53122: PUSH
53123: LD_VAR 0 3
53127: ARRAY
53128: PUSH
53129: LD_INT 2
53131: ARRAY
53132: PPUSH
53133: LD_EXP 118
53137: PUSH
53138: LD_VAR 0 2
53142: ARRAY
53143: PUSH
53144: LD_VAR 0 3
53148: ARRAY
53149: PUSH
53150: LD_INT 3
53152: ARRAY
53153: PPUSH
53154: CALL_OW 488
53158: PUSH
53159: LD_EXP 118
53163: PUSH
53164: LD_VAR 0 2
53168: ARRAY
53169: PUSH
53170: LD_VAR 0 3
53174: ARRAY
53175: PUSH
53176: LD_INT 2
53178: ARRAY
53179: PPUSH
53180: LD_EXP 118
53184: PUSH
53185: LD_VAR 0 2
53189: ARRAY
53190: PUSH
53191: LD_VAR 0 3
53195: ARRAY
53196: PUSH
53197: LD_INT 3
53199: ARRAY
53200: PPUSH
53201: CALL_OW 284
53205: PUSH
53206: LD_INT 0
53208: EQUAL
53209: AND
53210: IFFALSE 53265
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
53212: LD_ADDR_VAR 0 5
53216: PUSH
53217: LD_EXP 118
53221: PUSH
53222: LD_VAR 0 2
53226: ARRAY
53227: PPUSH
53228: LD_VAR 0 3
53232: PPUSH
53233: CALL_OW 3
53237: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
53238: LD_ADDR_EXP 118
53242: PUSH
53243: LD_EXP 118
53247: PPUSH
53248: LD_VAR 0 2
53252: PPUSH
53253: LD_VAR 0 5
53257: PPUSH
53258: CALL_OW 1
53262: ST_TO_ADDR
// continue ;
53263: GO 53109
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
53265: LD_VAR 0 6
53269: PPUSH
53270: LD_EXP 118
53274: PUSH
53275: LD_VAR 0 2
53279: ARRAY
53280: PUSH
53281: LD_VAR 0 3
53285: ARRAY
53286: PUSH
53287: LD_INT 2
53289: ARRAY
53290: PPUSH
53291: LD_EXP 118
53295: PUSH
53296: LD_VAR 0 2
53300: ARRAY
53301: PUSH
53302: LD_VAR 0 3
53306: ARRAY
53307: PUSH
53308: LD_INT 3
53310: ARRAY
53311: PPUSH
53312: LD_INT 30
53314: PPUSH
53315: CALL 76519 0 4
53319: PUSH
53320: LD_INT 4
53322: ARRAY
53323: PUSH
53324: LD_INT 0
53326: EQUAL
53327: IFFALSE 53353
// begin target := mc_crates [ i ] [ j ] ;
53329: LD_ADDR_VAR 0 7
53333: PUSH
53334: LD_EXP 118
53338: PUSH
53339: LD_VAR 0 2
53343: ARRAY
53344: PUSH
53345: LD_VAR 0 3
53349: ARRAY
53350: ST_TO_ADDR
// break ;
53351: GO 53355
// end ; end ;
53353: GO 53109
53355: POP
53356: POP
// if not target then
53357: LD_VAR 0 7
53361: NOT
53362: IFFALSE 53366
// continue ;
53364: GO 52916
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
53366: LD_ADDR_VAR 0 8
53370: PUSH
53371: LD_EXP 121
53375: PUSH
53376: LD_VAR 0 2
53380: ARRAY
53381: PPUSH
53382: LD_INT 2
53384: PUSH
53385: LD_INT 3
53387: PUSH
53388: LD_INT 58
53390: PUSH
53391: EMPTY
53392: LIST
53393: PUSH
53394: EMPTY
53395: LIST
53396: LIST
53397: PUSH
53398: LD_INT 61
53400: PUSH
53401: EMPTY
53402: LIST
53403: PUSH
53404: LD_INT 33
53406: PUSH
53407: LD_INT 5
53409: PUSH
53410: EMPTY
53411: LIST
53412: LIST
53413: PUSH
53414: LD_INT 33
53416: PUSH
53417: LD_INT 3
53419: PUSH
53420: EMPTY
53421: LIST
53422: LIST
53423: PUSH
53424: EMPTY
53425: LIST
53426: LIST
53427: LIST
53428: LIST
53429: LIST
53430: PUSH
53431: LD_INT 2
53433: PUSH
53434: LD_INT 34
53436: PUSH
53437: LD_INT 32
53439: PUSH
53440: EMPTY
53441: LIST
53442: LIST
53443: PUSH
53444: LD_INT 34
53446: PUSH
53447: LD_INT 51
53449: PUSH
53450: EMPTY
53451: LIST
53452: LIST
53453: PUSH
53454: LD_INT 34
53456: PUSH
53457: LD_INT 12
53459: PUSH
53460: EMPTY
53461: LIST
53462: LIST
53463: PUSH
53464: EMPTY
53465: LIST
53466: LIST
53467: LIST
53468: LIST
53469: PUSH
53470: EMPTY
53471: LIST
53472: LIST
53473: PPUSH
53474: CALL_OW 72
53478: ST_TO_ADDR
// if not cargo then
53479: LD_VAR 0 8
53483: NOT
53484: IFFALSE 54190
// begin if mc_crates_collector [ i ] < 5 then
53486: LD_EXP 119
53490: PUSH
53491: LD_VAR 0 2
53495: ARRAY
53496: PUSH
53497: LD_INT 5
53499: LESS
53500: IFFALSE 53866
// begin if mc_ape [ i ] then
53502: LD_EXP 131
53506: PUSH
53507: LD_VAR 0 2
53511: ARRAY
53512: IFFALSE 53559
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
53514: LD_ADDR_VAR 0 5
53518: PUSH
53519: LD_EXP 131
53523: PUSH
53524: LD_VAR 0 2
53528: ARRAY
53529: PPUSH
53530: LD_INT 25
53532: PUSH
53533: LD_INT 16
53535: PUSH
53536: EMPTY
53537: LIST
53538: LIST
53539: PUSH
53540: LD_INT 24
53542: PUSH
53543: LD_INT 750
53545: PUSH
53546: EMPTY
53547: LIST
53548: LIST
53549: PUSH
53550: EMPTY
53551: LIST
53552: LIST
53553: PPUSH
53554: CALL_OW 72
53558: ST_TO_ADDR
// if not tmp then
53559: LD_VAR 0 5
53563: NOT
53564: IFFALSE 53611
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
53566: LD_ADDR_VAR 0 5
53570: PUSH
53571: LD_EXP 102
53575: PUSH
53576: LD_VAR 0 2
53580: ARRAY
53581: PPUSH
53582: LD_INT 25
53584: PUSH
53585: LD_INT 2
53587: PUSH
53588: EMPTY
53589: LIST
53590: LIST
53591: PUSH
53592: LD_INT 24
53594: PUSH
53595: LD_INT 750
53597: PUSH
53598: EMPTY
53599: LIST
53600: LIST
53601: PUSH
53602: EMPTY
53603: LIST
53604: LIST
53605: PPUSH
53606: CALL_OW 72
53610: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
53611: LD_EXP 131
53615: PUSH
53616: LD_VAR 0 2
53620: ARRAY
53621: PUSH
53622: LD_EXP 102
53626: PUSH
53627: LD_VAR 0 2
53631: ARRAY
53632: PPUSH
53633: LD_INT 25
53635: PUSH
53636: LD_INT 2
53638: PUSH
53639: EMPTY
53640: LIST
53641: LIST
53642: PUSH
53643: LD_INT 24
53645: PUSH
53646: LD_INT 750
53648: PUSH
53649: EMPTY
53650: LIST
53651: LIST
53652: PUSH
53653: EMPTY
53654: LIST
53655: LIST
53656: PPUSH
53657: CALL_OW 72
53661: AND
53662: PUSH
53663: LD_VAR 0 5
53667: PUSH
53668: LD_INT 5
53670: LESS
53671: AND
53672: IFFALSE 53754
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
53674: LD_ADDR_VAR 0 3
53678: PUSH
53679: LD_EXP 102
53683: PUSH
53684: LD_VAR 0 2
53688: ARRAY
53689: PPUSH
53690: LD_INT 25
53692: PUSH
53693: LD_INT 2
53695: PUSH
53696: EMPTY
53697: LIST
53698: LIST
53699: PUSH
53700: LD_INT 24
53702: PUSH
53703: LD_INT 750
53705: PUSH
53706: EMPTY
53707: LIST
53708: LIST
53709: PUSH
53710: EMPTY
53711: LIST
53712: LIST
53713: PPUSH
53714: CALL_OW 72
53718: PUSH
53719: FOR_IN
53720: IFFALSE 53752
// begin tmp := tmp union j ;
53722: LD_ADDR_VAR 0 5
53726: PUSH
53727: LD_VAR 0 5
53731: PUSH
53732: LD_VAR 0 3
53736: UNION
53737: ST_TO_ADDR
// if tmp >= 5 then
53738: LD_VAR 0 5
53742: PUSH
53743: LD_INT 5
53745: GREATEREQUAL
53746: IFFALSE 53750
// break ;
53748: GO 53752
// end ;
53750: GO 53719
53752: POP
53753: POP
// end ; if not tmp then
53754: LD_VAR 0 5
53758: NOT
53759: IFFALSE 53763
// continue ;
53761: GO 52916
// for j in tmp do
53763: LD_ADDR_VAR 0 3
53767: PUSH
53768: LD_VAR 0 5
53772: PUSH
53773: FOR_IN
53774: IFFALSE 53864
// if not GetTag ( j ) then
53776: LD_VAR 0 3
53780: PPUSH
53781: CALL_OW 110
53785: NOT
53786: IFFALSE 53862
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
53788: LD_ADDR_EXP 119
53792: PUSH
53793: LD_EXP 119
53797: PPUSH
53798: LD_VAR 0 2
53802: PUSH
53803: LD_EXP 119
53807: PUSH
53808: LD_VAR 0 2
53812: ARRAY
53813: PUSH
53814: LD_INT 1
53816: PLUS
53817: PUSH
53818: EMPTY
53819: LIST
53820: LIST
53821: PPUSH
53822: LD_VAR 0 3
53826: PPUSH
53827: CALL 75255 0 3
53831: ST_TO_ADDR
// SetTag ( j , 107 ) ;
53832: LD_VAR 0 3
53836: PPUSH
53837: LD_INT 107
53839: PPUSH
53840: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
53844: LD_EXP 119
53848: PUSH
53849: LD_VAR 0 2
53853: ARRAY
53854: PUSH
53855: LD_INT 5
53857: GREATEREQUAL
53858: IFFALSE 53862
// break ;
53860: GO 53864
// end ;
53862: GO 53773
53864: POP
53865: POP
// end ; if mc_crates_collector [ i ] and target then
53866: LD_EXP 119
53870: PUSH
53871: LD_VAR 0 2
53875: ARRAY
53876: PUSH
53877: LD_VAR 0 7
53881: AND
53882: IFFALSE 54188
// begin if mc_crates_collector [ i ] < target [ 1 ] then
53884: LD_EXP 119
53888: PUSH
53889: LD_VAR 0 2
53893: ARRAY
53894: PUSH
53895: LD_VAR 0 7
53899: PUSH
53900: LD_INT 1
53902: ARRAY
53903: LESS
53904: IFFALSE 53924
// tmp := mc_crates_collector [ i ] else
53906: LD_ADDR_VAR 0 5
53910: PUSH
53911: LD_EXP 119
53915: PUSH
53916: LD_VAR 0 2
53920: ARRAY
53921: ST_TO_ADDR
53922: GO 53938
// tmp := target [ 1 ] ;
53924: LD_ADDR_VAR 0 5
53928: PUSH
53929: LD_VAR 0 7
53933: PUSH
53934: LD_INT 1
53936: ARRAY
53937: ST_TO_ADDR
// k := 0 ;
53938: LD_ADDR_VAR 0 4
53942: PUSH
53943: LD_INT 0
53945: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
53946: LD_ADDR_VAR 0 3
53950: PUSH
53951: LD_EXP 119
53955: PUSH
53956: LD_VAR 0 2
53960: ARRAY
53961: PUSH
53962: FOR_IN
53963: IFFALSE 54186
// begin k := k + 1 ;
53965: LD_ADDR_VAR 0 4
53969: PUSH
53970: LD_VAR 0 4
53974: PUSH
53975: LD_INT 1
53977: PLUS
53978: ST_TO_ADDR
// if k > tmp then
53979: LD_VAR 0 4
53983: PUSH
53984: LD_VAR 0 5
53988: GREATER
53989: IFFALSE 53993
// break ;
53991: GO 54186
// if not GetClass ( j ) in [ 2 , 16 ] then
53993: LD_VAR 0 3
53997: PPUSH
53998: CALL_OW 257
54002: PUSH
54003: LD_INT 2
54005: PUSH
54006: LD_INT 16
54008: PUSH
54009: EMPTY
54010: LIST
54011: LIST
54012: IN
54013: NOT
54014: IFFALSE 54067
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
54016: LD_ADDR_EXP 119
54020: PUSH
54021: LD_EXP 119
54025: PPUSH
54026: LD_VAR 0 2
54030: PPUSH
54031: LD_EXP 119
54035: PUSH
54036: LD_VAR 0 2
54040: ARRAY
54041: PUSH
54042: LD_VAR 0 3
54046: DIFF
54047: PPUSH
54048: CALL_OW 1
54052: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54053: LD_VAR 0 3
54057: PPUSH
54058: LD_INT 0
54060: PPUSH
54061: CALL_OW 109
// continue ;
54065: GO 53962
// end ; if IsInUnit ( j ) then
54067: LD_VAR 0 3
54071: PPUSH
54072: CALL_OW 310
54076: IFFALSE 54087
// ComExitBuilding ( j ) ;
54078: LD_VAR 0 3
54082: PPUSH
54083: CALL_OW 122
// wait ( 3 ) ;
54087: LD_INT 3
54089: PPUSH
54090: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
54094: LD_VAR 0 3
54098: PPUSH
54099: CALL_OW 314
54103: PUSH
54104: LD_VAR 0 6
54108: PPUSH
54109: LD_VAR 0 7
54113: PUSH
54114: LD_INT 2
54116: ARRAY
54117: PPUSH
54118: LD_VAR 0 7
54122: PUSH
54123: LD_INT 3
54125: ARRAY
54126: PPUSH
54127: LD_INT 30
54129: PPUSH
54130: CALL 76519 0 4
54134: PUSH
54135: LD_INT 4
54137: ARRAY
54138: AND
54139: IFFALSE 54157
// ComStandNearbyBuilding ( j , depot ) else
54141: LD_VAR 0 3
54145: PPUSH
54146: LD_VAR 0 9
54150: PPUSH
54151: CALL 71857 0 2
54155: GO 54184
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
54157: LD_VAR 0 3
54161: PPUSH
54162: LD_VAR 0 7
54166: PUSH
54167: LD_INT 2
54169: ARRAY
54170: PPUSH
54171: LD_VAR 0 7
54175: PUSH
54176: LD_INT 3
54178: ARRAY
54179: PPUSH
54180: CALL_OW 117
// end ;
54184: GO 53962
54186: POP
54187: POP
// end ; end else
54188: GO 54720
// begin for j in cargo do
54190: LD_ADDR_VAR 0 3
54194: PUSH
54195: LD_VAR 0 8
54199: PUSH
54200: FOR_IN
54201: IFFALSE 54718
// begin if GetTag ( j ) <> 0 then
54203: LD_VAR 0 3
54207: PPUSH
54208: CALL_OW 110
54212: PUSH
54213: LD_INT 0
54215: NONEQUAL
54216: IFFALSE 54220
// continue ;
54218: GO 54200
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
54220: LD_VAR 0 3
54224: PPUSH
54225: CALL_OW 256
54229: PUSH
54230: LD_INT 1000
54232: LESS
54233: PUSH
54234: LD_VAR 0 3
54238: PPUSH
54239: LD_EXP 126
54243: PUSH
54244: LD_VAR 0 2
54248: ARRAY
54249: PPUSH
54250: CALL_OW 308
54254: NOT
54255: AND
54256: IFFALSE 54278
// ComMoveToArea ( j , mc_parking [ i ] ) ;
54258: LD_VAR 0 3
54262: PPUSH
54263: LD_EXP 126
54267: PUSH
54268: LD_VAR 0 2
54272: ARRAY
54273: PPUSH
54274: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
54278: LD_VAR 0 3
54282: PPUSH
54283: CALL_OW 256
54287: PUSH
54288: LD_INT 1000
54290: LESS
54291: PUSH
54292: LD_VAR 0 3
54296: PPUSH
54297: LD_EXP 126
54301: PUSH
54302: LD_VAR 0 2
54306: ARRAY
54307: PPUSH
54308: CALL_OW 308
54312: AND
54313: IFFALSE 54317
// continue ;
54315: GO 54200
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
54317: LD_VAR 0 3
54321: PPUSH
54322: CALL_OW 262
54326: PUSH
54327: LD_INT 2
54329: EQUAL
54330: PUSH
54331: LD_VAR 0 3
54335: PPUSH
54336: CALL_OW 261
54340: PUSH
54341: LD_INT 15
54343: LESS
54344: AND
54345: IFFALSE 54349
// continue ;
54347: GO 54200
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
54349: LD_VAR 0 3
54353: PPUSH
54354: CALL_OW 262
54358: PUSH
54359: LD_INT 1
54361: EQUAL
54362: PUSH
54363: LD_VAR 0 3
54367: PPUSH
54368: CALL_OW 261
54372: PUSH
54373: LD_INT 10
54375: LESS
54376: AND
54377: IFFALSE 54657
// begin if not depot then
54379: LD_VAR 0 9
54383: NOT
54384: IFFALSE 54388
// continue ;
54386: GO 54200
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
54388: LD_VAR 0 3
54392: PPUSH
54393: LD_VAR 0 9
54397: PPUSH
54398: LD_VAR 0 3
54402: PPUSH
54403: CALL_OW 74
54407: PPUSH
54408: CALL_OW 296
54412: PUSH
54413: LD_INT 6
54415: LESS
54416: IFFALSE 54432
// SetFuel ( j , 100 ) else
54418: LD_VAR 0 3
54422: PPUSH
54423: LD_INT 100
54425: PPUSH
54426: CALL_OW 240
54430: GO 54657
// if GetFuel ( j ) = 0 then
54432: LD_VAR 0 3
54436: PPUSH
54437: CALL_OW 261
54441: PUSH
54442: LD_INT 0
54444: EQUAL
54445: IFFALSE 54657
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
54447: LD_ADDR_EXP 121
54451: PUSH
54452: LD_EXP 121
54456: PPUSH
54457: LD_VAR 0 2
54461: PPUSH
54462: LD_EXP 121
54466: PUSH
54467: LD_VAR 0 2
54471: ARRAY
54472: PUSH
54473: LD_VAR 0 3
54477: DIFF
54478: PPUSH
54479: CALL_OW 1
54483: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
54484: LD_VAR 0 3
54488: PPUSH
54489: CALL_OW 263
54493: PUSH
54494: LD_INT 1
54496: EQUAL
54497: IFFALSE 54513
// ComExitVehicle ( IsInUnit ( j ) ) ;
54499: LD_VAR 0 3
54503: PPUSH
54504: CALL_OW 310
54508: PPUSH
54509: CALL_OW 121
// if GetControl ( j ) = control_remote then
54513: LD_VAR 0 3
54517: PPUSH
54518: CALL_OW 263
54522: PUSH
54523: LD_INT 2
54525: EQUAL
54526: IFFALSE 54537
// ComUnlink ( j ) ;
54528: LD_VAR 0 3
54532: PPUSH
54533: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
54537: LD_ADDR_VAR 0 10
54541: PUSH
54542: LD_VAR 0 2
54546: PPUSH
54547: LD_INT 3
54549: PPUSH
54550: CALL 64301 0 2
54554: ST_TO_ADDR
// if fac then
54555: LD_VAR 0 10
54559: IFFALSE 54655
// begin for k in fac do
54561: LD_ADDR_VAR 0 4
54565: PUSH
54566: LD_VAR 0 10
54570: PUSH
54571: FOR_IN
54572: IFFALSE 54653
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
54574: LD_ADDR_VAR 0 11
54578: PUSH
54579: LD_VAR 0 10
54583: PPUSH
54584: LD_VAR 0 3
54588: PPUSH
54589: CALL_OW 265
54593: PPUSH
54594: LD_VAR 0 3
54598: PPUSH
54599: CALL_OW 262
54603: PPUSH
54604: LD_VAR 0 3
54608: PPUSH
54609: CALL_OW 263
54613: PPUSH
54614: LD_VAR 0 3
54618: PPUSH
54619: CALL_OW 264
54623: PPUSH
54624: CALL 72753 0 5
54628: ST_TO_ADDR
// if components then
54629: LD_VAR 0 11
54633: IFFALSE 54651
// begin MC_InsertProduceList ( i , components ) ;
54635: LD_VAR 0 2
54639: PPUSH
54640: LD_VAR 0 11
54644: PPUSH
54645: CALL 63846 0 2
// break ;
54649: GO 54653
// end ; end ;
54651: GO 54571
54653: POP
54654: POP
// end ; continue ;
54655: GO 54200
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
54657: LD_VAR 0 3
54661: PPUSH
54662: LD_INT 1
54664: PPUSH
54665: CALL_OW 289
54669: PUSH
54670: LD_INT 100
54672: LESS
54673: PUSH
54674: LD_VAR 0 3
54678: PPUSH
54679: CALL_OW 314
54683: NOT
54684: AND
54685: IFFALSE 54714
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
54687: LD_VAR 0 3
54691: PPUSH
54692: LD_VAR 0 7
54696: PUSH
54697: LD_INT 2
54699: ARRAY
54700: PPUSH
54701: LD_VAR 0 7
54705: PUSH
54706: LD_INT 3
54708: ARRAY
54709: PPUSH
54710: CALL_OW 117
// break ;
54714: GO 54718
// end ;
54716: GO 54200
54718: POP
54719: POP
// end ; end ;
54720: GO 52916
54722: POP
54723: POP
// end ;
54724: LD_VAR 0 1
54728: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
54729: LD_INT 0
54731: PPUSH
54732: PPUSH
54733: PPUSH
54734: PPUSH
// if not mc_bases then
54735: LD_EXP 102
54739: NOT
54740: IFFALSE 54744
// exit ;
54742: GO 54905
// for i = 1 to mc_bases do
54744: LD_ADDR_VAR 0 2
54748: PUSH
54749: DOUBLE
54750: LD_INT 1
54752: DEC
54753: ST_TO_ADDR
54754: LD_EXP 102
54758: PUSH
54759: FOR_TO
54760: IFFALSE 54903
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
54762: LD_ADDR_VAR 0 4
54766: PUSH
54767: LD_EXP 121
54771: PUSH
54772: LD_VAR 0 2
54776: ARRAY
54777: PUSH
54778: LD_EXP 124
54782: PUSH
54783: LD_VAR 0 2
54787: ARRAY
54788: UNION
54789: PPUSH
54790: LD_INT 33
54792: PUSH
54793: LD_INT 2
54795: PUSH
54796: EMPTY
54797: LIST
54798: LIST
54799: PPUSH
54800: CALL_OW 72
54804: ST_TO_ADDR
// if tmp then
54805: LD_VAR 0 4
54809: IFFALSE 54901
// for j in tmp do
54811: LD_ADDR_VAR 0 3
54815: PUSH
54816: LD_VAR 0 4
54820: PUSH
54821: FOR_IN
54822: IFFALSE 54899
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
54824: LD_VAR 0 3
54828: PPUSH
54829: CALL_OW 312
54833: NOT
54834: PUSH
54835: LD_VAR 0 3
54839: PPUSH
54840: CALL_OW 256
54844: PUSH
54845: LD_INT 250
54847: GREATEREQUAL
54848: AND
54849: IFFALSE 54862
// Connect ( j ) else
54851: LD_VAR 0 3
54855: PPUSH
54856: CALL 78601 0 1
54860: GO 54897
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
54862: LD_VAR 0 3
54866: PPUSH
54867: CALL_OW 256
54871: PUSH
54872: LD_INT 250
54874: LESS
54875: PUSH
54876: LD_VAR 0 3
54880: PPUSH
54881: CALL_OW 312
54885: AND
54886: IFFALSE 54897
// ComUnlink ( j ) ;
54888: LD_VAR 0 3
54892: PPUSH
54893: CALL_OW 136
54897: GO 54821
54899: POP
54900: POP
// end ;
54901: GO 54759
54903: POP
54904: POP
// end ;
54905: LD_VAR 0 1
54909: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
54910: LD_INT 0
54912: PPUSH
54913: PPUSH
54914: PPUSH
54915: PPUSH
54916: PPUSH
// if not mc_bases then
54917: LD_EXP 102
54921: NOT
54922: IFFALSE 54926
// exit ;
54924: GO 55371
// for i = 1 to mc_bases do
54926: LD_ADDR_VAR 0 2
54930: PUSH
54931: DOUBLE
54932: LD_INT 1
54934: DEC
54935: ST_TO_ADDR
54936: LD_EXP 102
54940: PUSH
54941: FOR_TO
54942: IFFALSE 55369
// begin if not mc_produce [ i ] then
54944: LD_EXP 123
54948: PUSH
54949: LD_VAR 0 2
54953: ARRAY
54954: NOT
54955: IFFALSE 54959
// continue ;
54957: GO 54941
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54959: LD_ADDR_VAR 0 5
54963: PUSH
54964: LD_EXP 102
54968: PUSH
54969: LD_VAR 0 2
54973: ARRAY
54974: PPUSH
54975: LD_INT 30
54977: PUSH
54978: LD_INT 3
54980: PUSH
54981: EMPTY
54982: LIST
54983: LIST
54984: PPUSH
54985: CALL_OW 72
54989: ST_TO_ADDR
// if not fac then
54990: LD_VAR 0 5
54994: NOT
54995: IFFALSE 54999
// continue ;
54997: GO 54941
// for j in fac do
54999: LD_ADDR_VAR 0 3
55003: PUSH
55004: LD_VAR 0 5
55008: PUSH
55009: FOR_IN
55010: IFFALSE 55365
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
55012: LD_VAR 0 3
55016: PPUSH
55017: CALL_OW 461
55021: PUSH
55022: LD_INT 2
55024: NONEQUAL
55025: PUSH
55026: LD_VAR 0 3
55030: PPUSH
55031: LD_INT 15
55033: PPUSH
55034: CALL 78220 0 2
55038: PUSH
55039: LD_INT 4
55041: ARRAY
55042: OR
55043: IFFALSE 55047
// continue ;
55045: GO 55009
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
55047: LD_VAR 0 3
55051: PPUSH
55052: LD_EXP 123
55056: PUSH
55057: LD_VAR 0 2
55061: ARRAY
55062: PUSH
55063: LD_INT 1
55065: ARRAY
55066: PUSH
55067: LD_INT 1
55069: ARRAY
55070: PPUSH
55071: LD_EXP 123
55075: PUSH
55076: LD_VAR 0 2
55080: ARRAY
55081: PUSH
55082: LD_INT 1
55084: ARRAY
55085: PUSH
55086: LD_INT 2
55088: ARRAY
55089: PPUSH
55090: LD_EXP 123
55094: PUSH
55095: LD_VAR 0 2
55099: ARRAY
55100: PUSH
55101: LD_INT 1
55103: ARRAY
55104: PUSH
55105: LD_INT 3
55107: ARRAY
55108: PPUSH
55109: LD_EXP 123
55113: PUSH
55114: LD_VAR 0 2
55118: ARRAY
55119: PUSH
55120: LD_INT 1
55122: ARRAY
55123: PUSH
55124: LD_INT 4
55126: ARRAY
55127: PPUSH
55128: CALL_OW 448
55132: PUSH
55133: LD_VAR 0 3
55137: PPUSH
55138: LD_EXP 123
55142: PUSH
55143: LD_VAR 0 2
55147: ARRAY
55148: PUSH
55149: LD_INT 1
55151: ARRAY
55152: PUSH
55153: LD_INT 1
55155: ARRAY
55156: PUSH
55157: LD_EXP 123
55161: PUSH
55162: LD_VAR 0 2
55166: ARRAY
55167: PUSH
55168: LD_INT 1
55170: ARRAY
55171: PUSH
55172: LD_INT 2
55174: ARRAY
55175: PUSH
55176: LD_EXP 123
55180: PUSH
55181: LD_VAR 0 2
55185: ARRAY
55186: PUSH
55187: LD_INT 1
55189: ARRAY
55190: PUSH
55191: LD_INT 3
55193: ARRAY
55194: PUSH
55195: LD_EXP 123
55199: PUSH
55200: LD_VAR 0 2
55204: ARRAY
55205: PUSH
55206: LD_INT 1
55208: ARRAY
55209: PUSH
55210: LD_INT 4
55212: ARRAY
55213: PUSH
55214: EMPTY
55215: LIST
55216: LIST
55217: LIST
55218: LIST
55219: PPUSH
55220: CALL 81996 0 2
55224: AND
55225: IFFALSE 55363
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
55227: LD_VAR 0 3
55231: PPUSH
55232: LD_EXP 123
55236: PUSH
55237: LD_VAR 0 2
55241: ARRAY
55242: PUSH
55243: LD_INT 1
55245: ARRAY
55246: PUSH
55247: LD_INT 1
55249: ARRAY
55250: PPUSH
55251: LD_EXP 123
55255: PUSH
55256: LD_VAR 0 2
55260: ARRAY
55261: PUSH
55262: LD_INT 1
55264: ARRAY
55265: PUSH
55266: LD_INT 2
55268: ARRAY
55269: PPUSH
55270: LD_EXP 123
55274: PUSH
55275: LD_VAR 0 2
55279: ARRAY
55280: PUSH
55281: LD_INT 1
55283: ARRAY
55284: PUSH
55285: LD_INT 3
55287: ARRAY
55288: PPUSH
55289: LD_EXP 123
55293: PUSH
55294: LD_VAR 0 2
55298: ARRAY
55299: PUSH
55300: LD_INT 1
55302: ARRAY
55303: PUSH
55304: LD_INT 4
55306: ARRAY
55307: PPUSH
55308: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
55312: LD_ADDR_VAR 0 4
55316: PUSH
55317: LD_EXP 123
55321: PUSH
55322: LD_VAR 0 2
55326: ARRAY
55327: PPUSH
55328: LD_INT 1
55330: PPUSH
55331: CALL_OW 3
55335: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
55336: LD_ADDR_EXP 123
55340: PUSH
55341: LD_EXP 123
55345: PPUSH
55346: LD_VAR 0 2
55350: PPUSH
55351: LD_VAR 0 4
55355: PPUSH
55356: CALL_OW 1
55360: ST_TO_ADDR
// break ;
55361: GO 55365
// end ; end ;
55363: GO 55009
55365: POP
55366: POP
// end ;
55367: GO 54941
55369: POP
55370: POP
// end ;
55371: LD_VAR 0 1
55375: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
55376: LD_INT 0
55378: PPUSH
55379: PPUSH
55380: PPUSH
// if not mc_bases then
55381: LD_EXP 102
55385: NOT
55386: IFFALSE 55390
// exit ;
55388: GO 55479
// for i = 1 to mc_bases do
55390: LD_ADDR_VAR 0 2
55394: PUSH
55395: DOUBLE
55396: LD_INT 1
55398: DEC
55399: ST_TO_ADDR
55400: LD_EXP 102
55404: PUSH
55405: FOR_TO
55406: IFFALSE 55477
// begin if mc_attack [ i ] then
55408: LD_EXP 122
55412: PUSH
55413: LD_VAR 0 2
55417: ARRAY
55418: IFFALSE 55475
// begin tmp := mc_attack [ i ] [ 1 ] ;
55420: LD_ADDR_VAR 0 3
55424: PUSH
55425: LD_EXP 122
55429: PUSH
55430: LD_VAR 0 2
55434: ARRAY
55435: PUSH
55436: LD_INT 1
55438: ARRAY
55439: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
55440: LD_ADDR_EXP 122
55444: PUSH
55445: LD_EXP 122
55449: PPUSH
55450: LD_VAR 0 2
55454: PPUSH
55455: EMPTY
55456: PPUSH
55457: CALL_OW 1
55461: ST_TO_ADDR
// Attack ( tmp ) ;
55462: LD_VAR 0 3
55466: PPUSH
55467: CALL 134319 0 1
// exit ;
55471: POP
55472: POP
55473: GO 55479
// end ; end ;
55475: GO 55405
55477: POP
55478: POP
// end ;
55479: LD_VAR 0 1
55483: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
55484: LD_INT 0
55486: PPUSH
55487: PPUSH
55488: PPUSH
55489: PPUSH
55490: PPUSH
55491: PPUSH
55492: PPUSH
// if not mc_bases then
55493: LD_EXP 102
55497: NOT
55498: IFFALSE 55502
// exit ;
55500: GO 56359
// for i = 1 to mc_bases do
55502: LD_ADDR_VAR 0 2
55506: PUSH
55507: DOUBLE
55508: LD_INT 1
55510: DEC
55511: ST_TO_ADDR
55512: LD_EXP 102
55516: PUSH
55517: FOR_TO
55518: IFFALSE 56357
// begin if not mc_bases [ i ] then
55520: LD_EXP 102
55524: PUSH
55525: LD_VAR 0 2
55529: ARRAY
55530: NOT
55531: IFFALSE 55535
// continue ;
55533: GO 55517
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
55535: LD_ADDR_VAR 0 7
55539: PUSH
55540: LD_EXP 102
55544: PUSH
55545: LD_VAR 0 2
55549: ARRAY
55550: PUSH
55551: LD_INT 1
55553: ARRAY
55554: PPUSH
55555: CALL 72079 0 1
55559: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
55560: LD_ADDR_EXP 125
55564: PUSH
55565: LD_EXP 125
55569: PPUSH
55570: LD_VAR 0 2
55574: PPUSH
55575: LD_EXP 102
55579: PUSH
55580: LD_VAR 0 2
55584: ARRAY
55585: PUSH
55586: LD_INT 1
55588: ARRAY
55589: PPUSH
55590: CALL_OW 255
55594: PPUSH
55595: LD_EXP 127
55599: PUSH
55600: LD_VAR 0 2
55604: ARRAY
55605: PPUSH
55606: CALL 72044 0 2
55610: PPUSH
55611: CALL_OW 1
55615: ST_TO_ADDR
// if not mc_scan [ i ] then
55616: LD_EXP 125
55620: PUSH
55621: LD_VAR 0 2
55625: ARRAY
55626: NOT
55627: IFFALSE 55805
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
55629: LD_ADDR_EXP 145
55633: PUSH
55634: LD_EXP 145
55638: PPUSH
55639: LD_VAR 0 2
55643: PPUSH
55644: LD_INT 0
55646: PPUSH
55647: CALL_OW 1
55651: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55652: LD_ADDR_VAR 0 4
55656: PUSH
55657: LD_EXP 102
55661: PUSH
55662: LD_VAR 0 2
55666: ARRAY
55667: PPUSH
55668: LD_INT 2
55670: PUSH
55671: LD_INT 25
55673: PUSH
55674: LD_INT 5
55676: PUSH
55677: EMPTY
55678: LIST
55679: LIST
55680: PUSH
55681: LD_INT 25
55683: PUSH
55684: LD_INT 8
55686: PUSH
55687: EMPTY
55688: LIST
55689: LIST
55690: PUSH
55691: LD_INT 25
55693: PUSH
55694: LD_INT 9
55696: PUSH
55697: EMPTY
55698: LIST
55699: LIST
55700: PUSH
55701: EMPTY
55702: LIST
55703: LIST
55704: LIST
55705: LIST
55706: PPUSH
55707: CALL_OW 72
55711: ST_TO_ADDR
// if not tmp then
55712: LD_VAR 0 4
55716: NOT
55717: IFFALSE 55721
// continue ;
55719: GO 55517
// for j in tmp do
55721: LD_ADDR_VAR 0 3
55725: PUSH
55726: LD_VAR 0 4
55730: PUSH
55731: FOR_IN
55732: IFFALSE 55803
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
55734: LD_VAR 0 3
55738: PPUSH
55739: CALL_OW 310
55743: PPUSH
55744: CALL_OW 266
55748: PUSH
55749: LD_INT 5
55751: EQUAL
55752: PUSH
55753: LD_VAR 0 3
55757: PPUSH
55758: CALL_OW 257
55762: PUSH
55763: LD_INT 1
55765: EQUAL
55766: AND
55767: PUSH
55768: LD_VAR 0 3
55772: PPUSH
55773: CALL_OW 459
55777: NOT
55778: AND
55779: PUSH
55780: LD_VAR 0 7
55784: AND
55785: IFFALSE 55801
// ComChangeProfession ( j , class ) ;
55787: LD_VAR 0 3
55791: PPUSH
55792: LD_VAR 0 7
55796: PPUSH
55797: CALL_OW 123
55801: GO 55731
55803: POP
55804: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
55805: LD_EXP 125
55809: PUSH
55810: LD_VAR 0 2
55814: ARRAY
55815: PUSH
55816: LD_EXP 145
55820: PUSH
55821: LD_VAR 0 2
55825: ARRAY
55826: NOT
55827: AND
55828: PUSH
55829: LD_EXP 124
55833: PUSH
55834: LD_VAR 0 2
55838: ARRAY
55839: NOT
55840: AND
55841: PUSH
55842: LD_EXP 102
55846: PUSH
55847: LD_VAR 0 2
55851: ARRAY
55852: PPUSH
55853: LD_INT 50
55855: PUSH
55856: EMPTY
55857: LIST
55858: PUSH
55859: LD_INT 2
55861: PUSH
55862: LD_INT 30
55864: PUSH
55865: LD_INT 32
55867: PUSH
55868: EMPTY
55869: LIST
55870: LIST
55871: PUSH
55872: LD_INT 30
55874: PUSH
55875: LD_INT 33
55877: PUSH
55878: EMPTY
55879: LIST
55880: LIST
55881: PUSH
55882: LD_INT 30
55884: PUSH
55885: LD_INT 4
55887: PUSH
55888: EMPTY
55889: LIST
55890: LIST
55891: PUSH
55892: LD_INT 30
55894: PUSH
55895: LD_INT 5
55897: PUSH
55898: EMPTY
55899: LIST
55900: LIST
55901: PUSH
55902: EMPTY
55903: LIST
55904: LIST
55905: LIST
55906: LIST
55907: LIST
55908: PUSH
55909: EMPTY
55910: LIST
55911: LIST
55912: PPUSH
55913: CALL_OW 72
55917: PUSH
55918: LD_INT 4
55920: LESS
55921: PUSH
55922: LD_EXP 102
55926: PUSH
55927: LD_VAR 0 2
55931: ARRAY
55932: PPUSH
55933: LD_INT 3
55935: PUSH
55936: LD_INT 24
55938: PUSH
55939: LD_INT 1000
55941: PUSH
55942: EMPTY
55943: LIST
55944: LIST
55945: PUSH
55946: EMPTY
55947: LIST
55948: LIST
55949: PUSH
55950: LD_INT 2
55952: PUSH
55953: LD_INT 30
55955: PUSH
55956: LD_INT 0
55958: PUSH
55959: EMPTY
55960: LIST
55961: LIST
55962: PUSH
55963: LD_INT 30
55965: PUSH
55966: LD_INT 1
55968: PUSH
55969: EMPTY
55970: LIST
55971: LIST
55972: PUSH
55973: EMPTY
55974: LIST
55975: LIST
55976: LIST
55977: PUSH
55978: EMPTY
55979: LIST
55980: LIST
55981: PPUSH
55982: CALL_OW 72
55986: OR
55987: AND
55988: IFFALSE 56239
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
55990: LD_ADDR_EXP 145
55994: PUSH
55995: LD_EXP 145
55999: PPUSH
56000: LD_VAR 0 2
56004: PPUSH
56005: LD_INT 1
56007: PPUSH
56008: CALL_OW 1
56012: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56013: LD_ADDR_VAR 0 4
56017: PUSH
56018: LD_EXP 102
56022: PUSH
56023: LD_VAR 0 2
56027: ARRAY
56028: PPUSH
56029: LD_INT 2
56031: PUSH
56032: LD_INT 25
56034: PUSH
56035: LD_INT 1
56037: PUSH
56038: EMPTY
56039: LIST
56040: LIST
56041: PUSH
56042: LD_INT 25
56044: PUSH
56045: LD_INT 5
56047: PUSH
56048: EMPTY
56049: LIST
56050: LIST
56051: PUSH
56052: LD_INT 25
56054: PUSH
56055: LD_INT 8
56057: PUSH
56058: EMPTY
56059: LIST
56060: LIST
56061: PUSH
56062: LD_INT 25
56064: PUSH
56065: LD_INT 9
56067: PUSH
56068: EMPTY
56069: LIST
56070: LIST
56071: PUSH
56072: EMPTY
56073: LIST
56074: LIST
56075: LIST
56076: LIST
56077: LIST
56078: PPUSH
56079: CALL_OW 72
56083: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
56084: LD_ADDR_VAR 0 4
56088: PUSH
56089: LD_VAR 0 4
56093: PUSH
56094: LD_VAR 0 4
56098: PPUSH
56099: LD_INT 18
56101: PPUSH
56102: CALL 105573 0 2
56106: DIFF
56107: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
56108: LD_VAR 0 4
56112: NOT
56113: PUSH
56114: LD_EXP 102
56118: PUSH
56119: LD_VAR 0 2
56123: ARRAY
56124: PPUSH
56125: LD_INT 2
56127: PUSH
56128: LD_INT 30
56130: PUSH
56131: LD_INT 4
56133: PUSH
56134: EMPTY
56135: LIST
56136: LIST
56137: PUSH
56138: LD_INT 30
56140: PUSH
56141: LD_INT 5
56143: PUSH
56144: EMPTY
56145: LIST
56146: LIST
56147: PUSH
56148: EMPTY
56149: LIST
56150: LIST
56151: LIST
56152: PPUSH
56153: CALL_OW 72
56157: NOT
56158: AND
56159: IFFALSE 56221
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
56161: LD_ADDR_VAR 0 4
56165: PUSH
56166: LD_EXP 102
56170: PUSH
56171: LD_VAR 0 2
56175: ARRAY
56176: PPUSH
56177: LD_INT 2
56179: PUSH
56180: LD_INT 25
56182: PUSH
56183: LD_INT 2
56185: PUSH
56186: EMPTY
56187: LIST
56188: LIST
56189: PUSH
56190: LD_INT 25
56192: PUSH
56193: LD_INT 3
56195: PUSH
56196: EMPTY
56197: LIST
56198: LIST
56199: PUSH
56200: LD_INT 25
56202: PUSH
56203: LD_INT 4
56205: PUSH
56206: EMPTY
56207: LIST
56208: LIST
56209: PUSH
56210: EMPTY
56211: LIST
56212: LIST
56213: LIST
56214: LIST
56215: PPUSH
56216: CALL_OW 72
56220: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
56221: LD_VAR 0 2
56225: PPUSH
56226: LD_VAR 0 4
56230: PPUSH
56231: CALL 139028 0 2
// exit ;
56235: POP
56236: POP
56237: GO 56359
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
56239: LD_EXP 125
56243: PUSH
56244: LD_VAR 0 2
56248: ARRAY
56249: PUSH
56250: LD_EXP 145
56254: PUSH
56255: LD_VAR 0 2
56259: ARRAY
56260: NOT
56261: AND
56262: PUSH
56263: LD_EXP 124
56267: PUSH
56268: LD_VAR 0 2
56272: ARRAY
56273: AND
56274: IFFALSE 56355
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
56276: LD_ADDR_EXP 145
56280: PUSH
56281: LD_EXP 145
56285: PPUSH
56286: LD_VAR 0 2
56290: PPUSH
56291: LD_INT 1
56293: PPUSH
56294: CALL_OW 1
56298: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
56299: LD_ADDR_VAR 0 4
56303: PUSH
56304: LD_EXP 124
56308: PUSH
56309: LD_VAR 0 2
56313: ARRAY
56314: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
56315: LD_ADDR_EXP 124
56319: PUSH
56320: LD_EXP 124
56324: PPUSH
56325: LD_VAR 0 2
56329: PPUSH
56330: EMPTY
56331: PPUSH
56332: CALL_OW 1
56336: ST_TO_ADDR
// Defend ( i , tmp ) ;
56337: LD_VAR 0 2
56341: PPUSH
56342: LD_VAR 0 4
56346: PPUSH
56347: CALL 139624 0 2
// exit ;
56351: POP
56352: POP
56353: GO 56359
// end ; end ;
56355: GO 55517
56357: POP
56358: POP
// end ;
56359: LD_VAR 0 1
56363: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
56364: LD_INT 0
56366: PPUSH
56367: PPUSH
56368: PPUSH
56369: PPUSH
56370: PPUSH
56371: PPUSH
56372: PPUSH
56373: PPUSH
56374: PPUSH
56375: PPUSH
56376: PPUSH
// if not mc_bases then
56377: LD_EXP 102
56381: NOT
56382: IFFALSE 56386
// exit ;
56384: GO 57473
// for i = 1 to mc_bases do
56386: LD_ADDR_VAR 0 2
56390: PUSH
56391: DOUBLE
56392: LD_INT 1
56394: DEC
56395: ST_TO_ADDR
56396: LD_EXP 102
56400: PUSH
56401: FOR_TO
56402: IFFALSE 57471
// begin tmp := mc_lab [ i ] ;
56404: LD_ADDR_VAR 0 6
56408: PUSH
56409: LD_EXP 135
56413: PUSH
56414: LD_VAR 0 2
56418: ARRAY
56419: ST_TO_ADDR
// if not tmp then
56420: LD_VAR 0 6
56424: NOT
56425: IFFALSE 56429
// continue ;
56427: GO 56401
// idle_lab := 0 ;
56429: LD_ADDR_VAR 0 11
56433: PUSH
56434: LD_INT 0
56436: ST_TO_ADDR
// for j in tmp do
56437: LD_ADDR_VAR 0 3
56441: PUSH
56442: LD_VAR 0 6
56446: PUSH
56447: FOR_IN
56448: IFFALSE 57467
// begin researching := false ;
56450: LD_ADDR_VAR 0 10
56454: PUSH
56455: LD_INT 0
56457: ST_TO_ADDR
// side := GetSide ( j ) ;
56458: LD_ADDR_VAR 0 4
56462: PUSH
56463: LD_VAR 0 3
56467: PPUSH
56468: CALL_OW 255
56472: ST_TO_ADDR
// if not mc_tech [ side ] then
56473: LD_EXP 129
56477: PUSH
56478: LD_VAR 0 4
56482: ARRAY
56483: NOT
56484: IFFALSE 56488
// continue ;
56486: GO 56447
// if BuildingStatus ( j ) = bs_idle then
56488: LD_VAR 0 3
56492: PPUSH
56493: CALL_OW 461
56497: PUSH
56498: LD_INT 2
56500: EQUAL
56501: IFFALSE 56689
// begin if idle_lab and UnitsInside ( j ) < 6 then
56503: LD_VAR 0 11
56507: PUSH
56508: LD_VAR 0 3
56512: PPUSH
56513: CALL_OW 313
56517: PUSH
56518: LD_INT 6
56520: LESS
56521: AND
56522: IFFALSE 56593
// begin tmp2 := UnitsInside ( idle_lab ) ;
56524: LD_ADDR_VAR 0 9
56528: PUSH
56529: LD_VAR 0 11
56533: PPUSH
56534: CALL_OW 313
56538: ST_TO_ADDR
// if tmp2 then
56539: LD_VAR 0 9
56543: IFFALSE 56585
// for x in tmp2 do
56545: LD_ADDR_VAR 0 7
56549: PUSH
56550: LD_VAR 0 9
56554: PUSH
56555: FOR_IN
56556: IFFALSE 56583
// begin ComExitBuilding ( x ) ;
56558: LD_VAR 0 7
56562: PPUSH
56563: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
56567: LD_VAR 0 7
56571: PPUSH
56572: LD_VAR 0 3
56576: PPUSH
56577: CALL_OW 180
// end ;
56581: GO 56555
56583: POP
56584: POP
// idle_lab := 0 ;
56585: LD_ADDR_VAR 0 11
56589: PUSH
56590: LD_INT 0
56592: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
56593: LD_ADDR_VAR 0 5
56597: PUSH
56598: LD_EXP 129
56602: PUSH
56603: LD_VAR 0 4
56607: ARRAY
56608: PUSH
56609: FOR_IN
56610: IFFALSE 56670
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
56612: LD_VAR 0 3
56616: PPUSH
56617: LD_VAR 0 5
56621: PPUSH
56622: CALL_OW 430
56626: PUSH
56627: LD_VAR 0 4
56631: PPUSH
56632: LD_VAR 0 5
56636: PPUSH
56637: CALL 71149 0 2
56641: AND
56642: IFFALSE 56668
// begin researching := true ;
56644: LD_ADDR_VAR 0 10
56648: PUSH
56649: LD_INT 1
56651: ST_TO_ADDR
// ComResearch ( j , t ) ;
56652: LD_VAR 0 3
56656: PPUSH
56657: LD_VAR 0 5
56661: PPUSH
56662: CALL_OW 124
// break ;
56666: GO 56670
// end ;
56668: GO 56609
56670: POP
56671: POP
// if not researching then
56672: LD_VAR 0 10
56676: NOT
56677: IFFALSE 56689
// idle_lab := j ;
56679: LD_ADDR_VAR 0 11
56683: PUSH
56684: LD_VAR 0 3
56688: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
56689: LD_VAR 0 3
56693: PPUSH
56694: CALL_OW 461
56698: PUSH
56699: LD_INT 10
56701: EQUAL
56702: IFFALSE 57290
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
56704: LD_EXP 131
56708: PUSH
56709: LD_VAR 0 2
56713: ARRAY
56714: NOT
56715: PUSH
56716: LD_EXP 132
56720: PUSH
56721: LD_VAR 0 2
56725: ARRAY
56726: NOT
56727: AND
56728: PUSH
56729: LD_EXP 129
56733: PUSH
56734: LD_VAR 0 4
56738: ARRAY
56739: PUSH
56740: LD_INT 1
56742: GREATER
56743: AND
56744: IFFALSE 56875
// begin ComCancel ( j ) ;
56746: LD_VAR 0 3
56750: PPUSH
56751: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
56755: LD_ADDR_EXP 129
56759: PUSH
56760: LD_EXP 129
56764: PPUSH
56765: LD_VAR 0 4
56769: PPUSH
56770: LD_EXP 129
56774: PUSH
56775: LD_VAR 0 4
56779: ARRAY
56780: PPUSH
56781: LD_EXP 129
56785: PUSH
56786: LD_VAR 0 4
56790: ARRAY
56791: PUSH
56792: LD_INT 1
56794: MINUS
56795: PPUSH
56796: LD_EXP 129
56800: PUSH
56801: LD_VAR 0 4
56805: ARRAY
56806: PPUSH
56807: LD_INT 0
56809: PPUSH
56810: CALL 74673 0 4
56814: PPUSH
56815: CALL_OW 1
56819: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
56820: LD_ADDR_EXP 129
56824: PUSH
56825: LD_EXP 129
56829: PPUSH
56830: LD_VAR 0 4
56834: PPUSH
56835: LD_EXP 129
56839: PUSH
56840: LD_VAR 0 4
56844: ARRAY
56845: PPUSH
56846: LD_EXP 129
56850: PUSH
56851: LD_VAR 0 4
56855: ARRAY
56856: PPUSH
56857: LD_INT 1
56859: PPUSH
56860: LD_INT 0
56862: PPUSH
56863: CALL 74673 0 4
56867: PPUSH
56868: CALL_OW 1
56872: ST_TO_ADDR
// continue ;
56873: GO 56447
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
56875: LD_EXP 131
56879: PUSH
56880: LD_VAR 0 2
56884: ARRAY
56885: PUSH
56886: LD_EXP 132
56890: PUSH
56891: LD_VAR 0 2
56895: ARRAY
56896: NOT
56897: AND
56898: IFFALSE 57025
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
56900: LD_ADDR_EXP 132
56904: PUSH
56905: LD_EXP 132
56909: PPUSH
56910: LD_VAR 0 2
56914: PUSH
56915: LD_EXP 132
56919: PUSH
56920: LD_VAR 0 2
56924: ARRAY
56925: PUSH
56926: LD_INT 1
56928: PLUS
56929: PUSH
56930: EMPTY
56931: LIST
56932: LIST
56933: PPUSH
56934: LD_EXP 131
56938: PUSH
56939: LD_VAR 0 2
56943: ARRAY
56944: PUSH
56945: LD_INT 1
56947: ARRAY
56948: PPUSH
56949: CALL 75255 0 3
56953: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
56954: LD_EXP 131
56958: PUSH
56959: LD_VAR 0 2
56963: ARRAY
56964: PUSH
56965: LD_INT 1
56967: ARRAY
56968: PPUSH
56969: LD_INT 112
56971: PPUSH
56972: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
56976: LD_ADDR_VAR 0 9
56980: PUSH
56981: LD_EXP 131
56985: PUSH
56986: LD_VAR 0 2
56990: ARRAY
56991: PPUSH
56992: LD_INT 1
56994: PPUSH
56995: CALL_OW 3
56999: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
57000: LD_ADDR_EXP 131
57004: PUSH
57005: LD_EXP 131
57009: PPUSH
57010: LD_VAR 0 2
57014: PPUSH
57015: LD_VAR 0 9
57019: PPUSH
57020: CALL_OW 1
57024: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
57025: LD_EXP 131
57029: PUSH
57030: LD_VAR 0 2
57034: ARRAY
57035: PUSH
57036: LD_EXP 132
57040: PUSH
57041: LD_VAR 0 2
57045: ARRAY
57046: AND
57047: PUSH
57048: LD_EXP 132
57052: PUSH
57053: LD_VAR 0 2
57057: ARRAY
57058: PUSH
57059: LD_INT 1
57061: ARRAY
57062: PPUSH
57063: CALL_OW 310
57067: NOT
57068: AND
57069: PUSH
57070: LD_VAR 0 3
57074: PPUSH
57075: CALL_OW 313
57079: PUSH
57080: LD_INT 6
57082: EQUAL
57083: AND
57084: IFFALSE 57140
// begin tmp2 := UnitsInside ( j ) ;
57086: LD_ADDR_VAR 0 9
57090: PUSH
57091: LD_VAR 0 3
57095: PPUSH
57096: CALL_OW 313
57100: ST_TO_ADDR
// if tmp2 = 6 then
57101: LD_VAR 0 9
57105: PUSH
57106: LD_INT 6
57108: EQUAL
57109: IFFALSE 57140
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
57111: LD_VAR 0 9
57115: PUSH
57116: LD_INT 1
57118: ARRAY
57119: PPUSH
57120: LD_INT 112
57122: PPUSH
57123: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
57127: LD_VAR 0 9
57131: PUSH
57132: LD_INT 1
57134: ARRAY
57135: PPUSH
57136: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
57140: LD_EXP 132
57144: PUSH
57145: LD_VAR 0 2
57149: ARRAY
57150: PUSH
57151: LD_EXP 132
57155: PUSH
57156: LD_VAR 0 2
57160: ARRAY
57161: PUSH
57162: LD_INT 1
57164: ARRAY
57165: PPUSH
57166: CALL_OW 314
57170: NOT
57171: AND
57172: PUSH
57173: LD_EXP 132
57177: PUSH
57178: LD_VAR 0 2
57182: ARRAY
57183: PUSH
57184: LD_INT 1
57186: ARRAY
57187: PPUSH
57188: CALL_OW 310
57192: NOT
57193: AND
57194: IFFALSE 57220
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
57196: LD_EXP 132
57200: PUSH
57201: LD_VAR 0 2
57205: ARRAY
57206: PUSH
57207: LD_INT 1
57209: ARRAY
57210: PPUSH
57211: LD_VAR 0 3
57215: PPUSH
57216: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
57220: LD_EXP 132
57224: PUSH
57225: LD_VAR 0 2
57229: ARRAY
57230: PUSH
57231: LD_INT 1
57233: ARRAY
57234: PPUSH
57235: CALL_OW 310
57239: PUSH
57240: LD_EXP 132
57244: PUSH
57245: LD_VAR 0 2
57249: ARRAY
57250: PUSH
57251: LD_INT 1
57253: ARRAY
57254: PPUSH
57255: CALL_OW 310
57259: PPUSH
57260: CALL_OW 461
57264: PUSH
57265: LD_INT 3
57267: NONEQUAL
57268: AND
57269: IFFALSE 57290
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
57271: LD_EXP 132
57275: PUSH
57276: LD_VAR 0 2
57280: ARRAY
57281: PUSH
57282: LD_INT 1
57284: ARRAY
57285: PPUSH
57286: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
57290: LD_VAR 0 3
57294: PPUSH
57295: CALL_OW 461
57299: PUSH
57300: LD_INT 6
57302: EQUAL
57303: PUSH
57304: LD_VAR 0 6
57308: PUSH
57309: LD_INT 1
57311: GREATER
57312: AND
57313: IFFALSE 57465
// begin sci := [ ] ;
57315: LD_ADDR_VAR 0 8
57319: PUSH
57320: EMPTY
57321: ST_TO_ADDR
// for x in ( tmp diff j ) do
57322: LD_ADDR_VAR 0 7
57326: PUSH
57327: LD_VAR 0 6
57331: PUSH
57332: LD_VAR 0 3
57336: DIFF
57337: PUSH
57338: FOR_IN
57339: IFFALSE 57391
// begin if sci = 6 then
57341: LD_VAR 0 8
57345: PUSH
57346: LD_INT 6
57348: EQUAL
57349: IFFALSE 57353
// break ;
57351: GO 57391
// if BuildingStatus ( x ) = bs_idle then
57353: LD_VAR 0 7
57357: PPUSH
57358: CALL_OW 461
57362: PUSH
57363: LD_INT 2
57365: EQUAL
57366: IFFALSE 57389
// sci := sci ^ UnitsInside ( x ) ;
57368: LD_ADDR_VAR 0 8
57372: PUSH
57373: LD_VAR 0 8
57377: PUSH
57378: LD_VAR 0 7
57382: PPUSH
57383: CALL_OW 313
57387: ADD
57388: ST_TO_ADDR
// end ;
57389: GO 57338
57391: POP
57392: POP
// if not sci then
57393: LD_VAR 0 8
57397: NOT
57398: IFFALSE 57402
// continue ;
57400: GO 56447
// for x in sci do
57402: LD_ADDR_VAR 0 7
57406: PUSH
57407: LD_VAR 0 8
57411: PUSH
57412: FOR_IN
57413: IFFALSE 57463
// if IsInUnit ( x ) and not HasTask ( x ) then
57415: LD_VAR 0 7
57419: PPUSH
57420: CALL_OW 310
57424: PUSH
57425: LD_VAR 0 7
57429: PPUSH
57430: CALL_OW 314
57434: NOT
57435: AND
57436: IFFALSE 57461
// begin ComExitBuilding ( x ) ;
57438: LD_VAR 0 7
57442: PPUSH
57443: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
57447: LD_VAR 0 7
57451: PPUSH
57452: LD_VAR 0 3
57456: PPUSH
57457: CALL_OW 180
// end ;
57461: GO 57412
57463: POP
57464: POP
// end ; end ;
57465: GO 56447
57467: POP
57468: POP
// end ;
57469: GO 56401
57471: POP
57472: POP
// end ;
57473: LD_VAR 0 1
57477: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
57478: LD_INT 0
57480: PPUSH
57481: PPUSH
// if not mc_bases then
57482: LD_EXP 102
57486: NOT
57487: IFFALSE 57491
// exit ;
57489: GO 57572
// for i = 1 to mc_bases do
57491: LD_ADDR_VAR 0 2
57495: PUSH
57496: DOUBLE
57497: LD_INT 1
57499: DEC
57500: ST_TO_ADDR
57501: LD_EXP 102
57505: PUSH
57506: FOR_TO
57507: IFFALSE 57570
// if mc_mines [ i ] and mc_miners [ i ] then
57509: LD_EXP 115
57513: PUSH
57514: LD_VAR 0 2
57518: ARRAY
57519: PUSH
57520: LD_EXP 116
57524: PUSH
57525: LD_VAR 0 2
57529: ARRAY
57530: AND
57531: IFFALSE 57568
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
57533: LD_EXP 116
57537: PUSH
57538: LD_VAR 0 2
57542: ARRAY
57543: PUSH
57544: LD_INT 1
57546: ARRAY
57547: PPUSH
57548: CALL_OW 255
57552: PPUSH
57553: LD_EXP 115
57557: PUSH
57558: LD_VAR 0 2
57562: ARRAY
57563: PPUSH
57564: CALL 72232 0 2
57568: GO 57506
57570: POP
57571: POP
// end ;
57572: LD_VAR 0 1
57576: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
57577: LD_INT 0
57579: PPUSH
57580: PPUSH
57581: PPUSH
57582: PPUSH
57583: PPUSH
57584: PPUSH
57585: PPUSH
57586: PPUSH
// if not mc_bases or not mc_parking then
57587: LD_EXP 102
57591: NOT
57592: PUSH
57593: LD_EXP 126
57597: NOT
57598: OR
57599: IFFALSE 57603
// exit ;
57601: GO 58341
// for i = 1 to mc_bases do
57603: LD_ADDR_VAR 0 2
57607: PUSH
57608: DOUBLE
57609: LD_INT 1
57611: DEC
57612: ST_TO_ADDR
57613: LD_EXP 102
57617: PUSH
57618: FOR_TO
57619: IFFALSE 58339
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
57621: LD_EXP 102
57625: PUSH
57626: LD_VAR 0 2
57630: ARRAY
57631: NOT
57632: PUSH
57633: LD_EXP 126
57637: PUSH
57638: LD_VAR 0 2
57642: ARRAY
57643: NOT
57644: OR
57645: IFFALSE 57649
// continue ;
57647: GO 57618
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
57649: LD_ADDR_VAR 0 5
57653: PUSH
57654: LD_EXP 102
57658: PUSH
57659: LD_VAR 0 2
57663: ARRAY
57664: PUSH
57665: LD_INT 1
57667: ARRAY
57668: PPUSH
57669: CALL_OW 255
57673: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
57674: LD_ADDR_VAR 0 6
57678: PUSH
57679: LD_EXP 102
57683: PUSH
57684: LD_VAR 0 2
57688: ARRAY
57689: PPUSH
57690: LD_INT 30
57692: PUSH
57693: LD_INT 3
57695: PUSH
57696: EMPTY
57697: LIST
57698: LIST
57699: PPUSH
57700: CALL_OW 72
57704: ST_TO_ADDR
// if not fac then
57705: LD_VAR 0 6
57709: NOT
57710: IFFALSE 57761
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57712: LD_ADDR_VAR 0 6
57716: PUSH
57717: LD_EXP 102
57721: PUSH
57722: LD_VAR 0 2
57726: ARRAY
57727: PPUSH
57728: LD_INT 2
57730: PUSH
57731: LD_INT 30
57733: PUSH
57734: LD_INT 0
57736: PUSH
57737: EMPTY
57738: LIST
57739: LIST
57740: PUSH
57741: LD_INT 30
57743: PUSH
57744: LD_INT 1
57746: PUSH
57747: EMPTY
57748: LIST
57749: LIST
57750: PUSH
57751: EMPTY
57752: LIST
57753: LIST
57754: LIST
57755: PPUSH
57756: CALL_OW 72
57760: ST_TO_ADDR
// if not fac then
57761: LD_VAR 0 6
57765: NOT
57766: IFFALSE 57770
// continue ;
57768: GO 57618
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
57770: LD_ADDR_VAR 0 7
57774: PUSH
57775: LD_EXP 126
57779: PUSH
57780: LD_VAR 0 2
57784: ARRAY
57785: PPUSH
57786: LD_INT 22
57788: PUSH
57789: LD_VAR 0 5
57793: PUSH
57794: EMPTY
57795: LIST
57796: LIST
57797: PUSH
57798: LD_INT 21
57800: PUSH
57801: LD_INT 2
57803: PUSH
57804: EMPTY
57805: LIST
57806: LIST
57807: PUSH
57808: LD_INT 3
57810: PUSH
57811: LD_INT 60
57813: PUSH
57814: EMPTY
57815: LIST
57816: PUSH
57817: EMPTY
57818: LIST
57819: LIST
57820: PUSH
57821: LD_INT 3
57823: PUSH
57824: LD_INT 24
57826: PUSH
57827: LD_INT 1000
57829: PUSH
57830: EMPTY
57831: LIST
57832: LIST
57833: PUSH
57834: EMPTY
57835: LIST
57836: LIST
57837: PUSH
57838: EMPTY
57839: LIST
57840: LIST
57841: LIST
57842: LIST
57843: PPUSH
57844: CALL_OW 70
57848: ST_TO_ADDR
// for j in fac do
57849: LD_ADDR_VAR 0 3
57853: PUSH
57854: LD_VAR 0 6
57858: PUSH
57859: FOR_IN
57860: IFFALSE 57955
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
57862: LD_ADDR_VAR 0 7
57866: PUSH
57867: LD_VAR 0 7
57871: PUSH
57872: LD_INT 22
57874: PUSH
57875: LD_VAR 0 5
57879: PUSH
57880: EMPTY
57881: LIST
57882: LIST
57883: PUSH
57884: LD_INT 91
57886: PUSH
57887: LD_VAR 0 3
57891: PUSH
57892: LD_INT 15
57894: PUSH
57895: EMPTY
57896: LIST
57897: LIST
57898: LIST
57899: PUSH
57900: LD_INT 21
57902: PUSH
57903: LD_INT 2
57905: PUSH
57906: EMPTY
57907: LIST
57908: LIST
57909: PUSH
57910: LD_INT 3
57912: PUSH
57913: LD_INT 60
57915: PUSH
57916: EMPTY
57917: LIST
57918: PUSH
57919: EMPTY
57920: LIST
57921: LIST
57922: PUSH
57923: LD_INT 3
57925: PUSH
57926: LD_INT 24
57928: PUSH
57929: LD_INT 1000
57931: PUSH
57932: EMPTY
57933: LIST
57934: LIST
57935: PUSH
57936: EMPTY
57937: LIST
57938: LIST
57939: PUSH
57940: EMPTY
57941: LIST
57942: LIST
57943: LIST
57944: LIST
57945: LIST
57946: PPUSH
57947: CALL_OW 69
57951: UNION
57952: ST_TO_ADDR
57953: GO 57859
57955: POP
57956: POP
// if not vehs then
57957: LD_VAR 0 7
57961: NOT
57962: IFFALSE 57988
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57964: LD_ADDR_EXP 114
57968: PUSH
57969: LD_EXP 114
57973: PPUSH
57974: LD_VAR 0 2
57978: PPUSH
57979: EMPTY
57980: PPUSH
57981: CALL_OW 1
57985: ST_TO_ADDR
// continue ;
57986: GO 57618
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
57988: LD_ADDR_VAR 0 8
57992: PUSH
57993: LD_EXP 102
57997: PUSH
57998: LD_VAR 0 2
58002: ARRAY
58003: PPUSH
58004: LD_INT 30
58006: PUSH
58007: LD_INT 3
58009: PUSH
58010: EMPTY
58011: LIST
58012: LIST
58013: PPUSH
58014: CALL_OW 72
58018: ST_TO_ADDR
// if tmp then
58019: LD_VAR 0 8
58023: IFFALSE 58126
// begin for j in tmp do
58025: LD_ADDR_VAR 0 3
58029: PUSH
58030: LD_VAR 0 8
58034: PUSH
58035: FOR_IN
58036: IFFALSE 58124
// for k in UnitsInside ( j ) do
58038: LD_ADDR_VAR 0 4
58042: PUSH
58043: LD_VAR 0 3
58047: PPUSH
58048: CALL_OW 313
58052: PUSH
58053: FOR_IN
58054: IFFALSE 58120
// if k then
58056: LD_VAR 0 4
58060: IFFALSE 58118
// if not k in mc_repair_vehicle [ i ] then
58062: LD_VAR 0 4
58066: PUSH
58067: LD_EXP 114
58071: PUSH
58072: LD_VAR 0 2
58076: ARRAY
58077: IN
58078: NOT
58079: IFFALSE 58118
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
58081: LD_ADDR_EXP 114
58085: PUSH
58086: LD_EXP 114
58090: PPUSH
58091: LD_VAR 0 2
58095: PPUSH
58096: LD_EXP 114
58100: PUSH
58101: LD_VAR 0 2
58105: ARRAY
58106: PUSH
58107: LD_VAR 0 4
58111: UNION
58112: PPUSH
58113: CALL_OW 1
58117: ST_TO_ADDR
58118: GO 58053
58120: POP
58121: POP
58122: GO 58035
58124: POP
58125: POP
// end ; if not mc_repair_vehicle [ i ] then
58126: LD_EXP 114
58130: PUSH
58131: LD_VAR 0 2
58135: ARRAY
58136: NOT
58137: IFFALSE 58141
// continue ;
58139: GO 57618
// for j in mc_repair_vehicle [ i ] do
58141: LD_ADDR_VAR 0 3
58145: PUSH
58146: LD_EXP 114
58150: PUSH
58151: LD_VAR 0 2
58155: ARRAY
58156: PUSH
58157: FOR_IN
58158: IFFALSE 58335
// begin if GetClass ( j ) <> 3 then
58160: LD_VAR 0 3
58164: PPUSH
58165: CALL_OW 257
58169: PUSH
58170: LD_INT 3
58172: NONEQUAL
58173: IFFALSE 58214
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
58175: LD_ADDR_EXP 114
58179: PUSH
58180: LD_EXP 114
58184: PPUSH
58185: LD_VAR 0 2
58189: PPUSH
58190: LD_EXP 114
58194: PUSH
58195: LD_VAR 0 2
58199: ARRAY
58200: PUSH
58201: LD_VAR 0 3
58205: DIFF
58206: PPUSH
58207: CALL_OW 1
58211: ST_TO_ADDR
// continue ;
58212: GO 58157
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
58214: LD_VAR 0 3
58218: PPUSH
58219: CALL_OW 311
58223: NOT
58224: PUSH
58225: LD_VAR 0 3
58229: PUSH
58230: LD_EXP 105
58234: PUSH
58235: LD_VAR 0 2
58239: ARRAY
58240: PUSH
58241: LD_INT 1
58243: ARRAY
58244: IN
58245: NOT
58246: AND
58247: PUSH
58248: LD_VAR 0 3
58252: PUSH
58253: LD_EXP 105
58257: PUSH
58258: LD_VAR 0 2
58262: ARRAY
58263: PUSH
58264: LD_INT 2
58266: ARRAY
58267: IN
58268: NOT
58269: AND
58270: IFFALSE 58333
// begin if IsInUnit ( j ) then
58272: LD_VAR 0 3
58276: PPUSH
58277: CALL_OW 310
58281: IFFALSE 58294
// ComExitBuilding ( j ) else
58283: LD_VAR 0 3
58287: PPUSH
58288: CALL_OW 122
58292: GO 58333
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
58294: LD_VAR 0 3
58298: PPUSH
58299: LD_VAR 0 7
58303: PUSH
58304: LD_INT 1
58306: ARRAY
58307: PPUSH
58308: CALL 110069 0 2
58312: NOT
58313: IFFALSE 58333
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
58315: LD_VAR 0 3
58319: PPUSH
58320: LD_VAR 0 7
58324: PUSH
58325: LD_INT 1
58327: ARRAY
58328: PPUSH
58329: CALL_OW 129
// end ; end ;
58333: GO 58157
58335: POP
58336: POP
// end ;
58337: GO 57618
58339: POP
58340: POP
// end ;
58341: LD_VAR 0 1
58345: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
58346: LD_INT 0
58348: PPUSH
58349: PPUSH
58350: PPUSH
58351: PPUSH
58352: PPUSH
58353: PPUSH
58354: PPUSH
58355: PPUSH
58356: PPUSH
58357: PPUSH
58358: PPUSH
// if not mc_bases then
58359: LD_EXP 102
58363: NOT
58364: IFFALSE 58368
// exit ;
58366: GO 59170
// for i = 1 to mc_bases do
58368: LD_ADDR_VAR 0 2
58372: PUSH
58373: DOUBLE
58374: LD_INT 1
58376: DEC
58377: ST_TO_ADDR
58378: LD_EXP 102
58382: PUSH
58383: FOR_TO
58384: IFFALSE 59168
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
58386: LD_EXP 130
58390: PUSH
58391: LD_VAR 0 2
58395: ARRAY
58396: NOT
58397: PUSH
58398: LD_EXP 105
58402: PUSH
58403: LD_VAR 0 2
58407: ARRAY
58408: PUSH
58409: LD_INT 1
58411: ARRAY
58412: OR
58413: PUSH
58414: LD_EXP 105
58418: PUSH
58419: LD_VAR 0 2
58423: ARRAY
58424: PUSH
58425: LD_INT 2
58427: ARRAY
58428: OR
58429: PUSH
58430: LD_EXP 128
58434: PUSH
58435: LD_VAR 0 2
58439: ARRAY
58440: PPUSH
58441: LD_INT 1
58443: PPUSH
58444: CALL_OW 325
58448: NOT
58449: OR
58450: PUSH
58451: LD_EXP 125
58455: PUSH
58456: LD_VAR 0 2
58460: ARRAY
58461: OR
58462: IFFALSE 58466
// continue ;
58464: GO 58383
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
58466: LD_ADDR_VAR 0 8
58470: PUSH
58471: LD_EXP 102
58475: PUSH
58476: LD_VAR 0 2
58480: ARRAY
58481: PPUSH
58482: LD_INT 25
58484: PUSH
58485: LD_INT 4
58487: PUSH
58488: EMPTY
58489: LIST
58490: LIST
58491: PUSH
58492: LD_INT 50
58494: PUSH
58495: EMPTY
58496: LIST
58497: PUSH
58498: LD_INT 3
58500: PUSH
58501: LD_INT 60
58503: PUSH
58504: EMPTY
58505: LIST
58506: PUSH
58507: EMPTY
58508: LIST
58509: LIST
58510: PUSH
58511: EMPTY
58512: LIST
58513: LIST
58514: LIST
58515: PPUSH
58516: CALL_OW 72
58520: PUSH
58521: LD_EXP 106
58525: PUSH
58526: LD_VAR 0 2
58530: ARRAY
58531: DIFF
58532: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58533: LD_ADDR_VAR 0 9
58537: PUSH
58538: LD_EXP 102
58542: PUSH
58543: LD_VAR 0 2
58547: ARRAY
58548: PPUSH
58549: LD_INT 2
58551: PUSH
58552: LD_INT 30
58554: PUSH
58555: LD_INT 0
58557: PUSH
58558: EMPTY
58559: LIST
58560: LIST
58561: PUSH
58562: LD_INT 30
58564: PUSH
58565: LD_INT 1
58567: PUSH
58568: EMPTY
58569: LIST
58570: LIST
58571: PUSH
58572: EMPTY
58573: LIST
58574: LIST
58575: LIST
58576: PPUSH
58577: CALL_OW 72
58581: ST_TO_ADDR
// if not tmp or not dep then
58582: LD_VAR 0 8
58586: NOT
58587: PUSH
58588: LD_VAR 0 9
58592: NOT
58593: OR
58594: IFFALSE 58598
// continue ;
58596: GO 58383
// side := GetSide ( tmp [ 1 ] ) ;
58598: LD_ADDR_VAR 0 11
58602: PUSH
58603: LD_VAR 0 8
58607: PUSH
58608: LD_INT 1
58610: ARRAY
58611: PPUSH
58612: CALL_OW 255
58616: ST_TO_ADDR
// dep := dep [ 1 ] ;
58617: LD_ADDR_VAR 0 9
58621: PUSH
58622: LD_VAR 0 9
58626: PUSH
58627: LD_INT 1
58629: ARRAY
58630: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
58631: LD_ADDR_VAR 0 7
58635: PUSH
58636: LD_EXP 130
58640: PUSH
58641: LD_VAR 0 2
58645: ARRAY
58646: PPUSH
58647: LD_INT 22
58649: PUSH
58650: LD_INT 0
58652: PUSH
58653: EMPTY
58654: LIST
58655: LIST
58656: PUSH
58657: LD_INT 25
58659: PUSH
58660: LD_INT 12
58662: PUSH
58663: EMPTY
58664: LIST
58665: LIST
58666: PUSH
58667: EMPTY
58668: LIST
58669: LIST
58670: PPUSH
58671: CALL_OW 70
58675: PUSH
58676: LD_INT 22
58678: PUSH
58679: LD_INT 0
58681: PUSH
58682: EMPTY
58683: LIST
58684: LIST
58685: PUSH
58686: LD_INT 25
58688: PUSH
58689: LD_INT 12
58691: PUSH
58692: EMPTY
58693: LIST
58694: LIST
58695: PUSH
58696: LD_INT 91
58698: PUSH
58699: LD_VAR 0 9
58703: PUSH
58704: LD_INT 20
58706: PUSH
58707: EMPTY
58708: LIST
58709: LIST
58710: LIST
58711: PUSH
58712: EMPTY
58713: LIST
58714: LIST
58715: LIST
58716: PPUSH
58717: CALL_OW 69
58721: UNION
58722: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
58723: LD_ADDR_VAR 0 10
58727: PUSH
58728: LD_EXP 130
58732: PUSH
58733: LD_VAR 0 2
58737: ARRAY
58738: PPUSH
58739: LD_INT 81
58741: PUSH
58742: LD_VAR 0 11
58746: PUSH
58747: EMPTY
58748: LIST
58749: LIST
58750: PPUSH
58751: CALL_OW 70
58755: ST_TO_ADDR
// if not apes or danger_at_area then
58756: LD_VAR 0 7
58760: NOT
58761: PUSH
58762: LD_VAR 0 10
58766: OR
58767: IFFALSE 58817
// begin if mc_taming [ i ] then
58769: LD_EXP 133
58773: PUSH
58774: LD_VAR 0 2
58778: ARRAY
58779: IFFALSE 58815
// begin MC_Reset ( i , 121 ) ;
58781: LD_VAR 0 2
58785: PPUSH
58786: LD_INT 121
58788: PPUSH
58789: CALL 43733 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
58793: LD_ADDR_EXP 133
58797: PUSH
58798: LD_EXP 133
58802: PPUSH
58803: LD_VAR 0 2
58807: PPUSH
58808: EMPTY
58809: PPUSH
58810: CALL_OW 1
58814: ST_TO_ADDR
// end ; continue ;
58815: GO 58383
// end ; for j in tmp do
58817: LD_ADDR_VAR 0 3
58821: PUSH
58822: LD_VAR 0 8
58826: PUSH
58827: FOR_IN
58828: IFFALSE 59164
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
58830: LD_VAR 0 3
58834: PUSH
58835: LD_EXP 133
58839: PUSH
58840: LD_VAR 0 2
58844: ARRAY
58845: IN
58846: NOT
58847: PUSH
58848: LD_EXP 133
58852: PUSH
58853: LD_VAR 0 2
58857: ARRAY
58858: PUSH
58859: LD_INT 3
58861: LESS
58862: AND
58863: IFFALSE 58921
// begin SetTag ( j , 121 ) ;
58865: LD_VAR 0 3
58869: PPUSH
58870: LD_INT 121
58872: PPUSH
58873: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
58877: LD_ADDR_EXP 133
58881: PUSH
58882: LD_EXP 133
58886: PPUSH
58887: LD_VAR 0 2
58891: PUSH
58892: LD_EXP 133
58896: PUSH
58897: LD_VAR 0 2
58901: ARRAY
58902: PUSH
58903: LD_INT 1
58905: PLUS
58906: PUSH
58907: EMPTY
58908: LIST
58909: LIST
58910: PPUSH
58911: LD_VAR 0 3
58915: PPUSH
58916: CALL 75255 0 3
58920: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
58921: LD_VAR 0 3
58925: PUSH
58926: LD_EXP 133
58930: PUSH
58931: LD_VAR 0 2
58935: ARRAY
58936: IN
58937: IFFALSE 59162
// begin if GetClass ( j ) <> 4 then
58939: LD_VAR 0 3
58943: PPUSH
58944: CALL_OW 257
58948: PUSH
58949: LD_INT 4
58951: NONEQUAL
58952: IFFALSE 59005
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
58954: LD_ADDR_EXP 133
58958: PUSH
58959: LD_EXP 133
58963: PPUSH
58964: LD_VAR 0 2
58968: PPUSH
58969: LD_EXP 133
58973: PUSH
58974: LD_VAR 0 2
58978: ARRAY
58979: PUSH
58980: LD_VAR 0 3
58984: DIFF
58985: PPUSH
58986: CALL_OW 1
58990: ST_TO_ADDR
// SetTag ( j , 0 ) ;
58991: LD_VAR 0 3
58995: PPUSH
58996: LD_INT 0
58998: PPUSH
58999: CALL_OW 109
// continue ;
59003: GO 58827
// end ; if IsInUnit ( j ) then
59005: LD_VAR 0 3
59009: PPUSH
59010: CALL_OW 310
59014: IFFALSE 59025
// ComExitBuilding ( j ) ;
59016: LD_VAR 0 3
59020: PPUSH
59021: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
59025: LD_ADDR_VAR 0 6
59029: PUSH
59030: LD_VAR 0 7
59034: PPUSH
59035: LD_VAR 0 3
59039: PPUSH
59040: CALL_OW 74
59044: ST_TO_ADDR
// if not ape then
59045: LD_VAR 0 6
59049: NOT
59050: IFFALSE 59054
// break ;
59052: GO 59164
// x := GetX ( ape ) ;
59054: LD_ADDR_VAR 0 4
59058: PUSH
59059: LD_VAR 0 6
59063: PPUSH
59064: CALL_OW 250
59068: ST_TO_ADDR
// y := GetY ( ape ) ;
59069: LD_ADDR_VAR 0 5
59073: PUSH
59074: LD_VAR 0 6
59078: PPUSH
59079: CALL_OW 251
59083: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
59084: LD_VAR 0 4
59088: PPUSH
59089: LD_VAR 0 5
59093: PPUSH
59094: CALL_OW 488
59098: NOT
59099: PUSH
59100: LD_VAR 0 11
59104: PPUSH
59105: LD_VAR 0 4
59109: PPUSH
59110: LD_VAR 0 5
59114: PPUSH
59115: LD_INT 20
59117: PPUSH
59118: CALL 76519 0 4
59122: PUSH
59123: LD_INT 4
59125: ARRAY
59126: OR
59127: IFFALSE 59131
// break ;
59129: GO 59164
// if not HasTask ( j ) then
59131: LD_VAR 0 3
59135: PPUSH
59136: CALL_OW 314
59140: NOT
59141: IFFALSE 59162
// ComTameXY ( j , x , y ) ;
59143: LD_VAR 0 3
59147: PPUSH
59148: LD_VAR 0 4
59152: PPUSH
59153: LD_VAR 0 5
59157: PPUSH
59158: CALL_OW 131
// end ; end ;
59162: GO 58827
59164: POP
59165: POP
// end ;
59166: GO 58383
59168: POP
59169: POP
// end ;
59170: LD_VAR 0 1
59174: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
59175: LD_INT 0
59177: PPUSH
59178: PPUSH
59179: PPUSH
59180: PPUSH
59181: PPUSH
59182: PPUSH
59183: PPUSH
59184: PPUSH
// if not mc_bases then
59185: LD_EXP 102
59189: NOT
59190: IFFALSE 59194
// exit ;
59192: GO 59820
// for i = 1 to mc_bases do
59194: LD_ADDR_VAR 0 2
59198: PUSH
59199: DOUBLE
59200: LD_INT 1
59202: DEC
59203: ST_TO_ADDR
59204: LD_EXP 102
59208: PUSH
59209: FOR_TO
59210: IFFALSE 59818
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
59212: LD_EXP 131
59216: PUSH
59217: LD_VAR 0 2
59221: ARRAY
59222: NOT
59223: PUSH
59224: LD_EXP 131
59228: PUSH
59229: LD_VAR 0 2
59233: ARRAY
59234: PPUSH
59235: LD_INT 25
59237: PUSH
59238: LD_INT 12
59240: PUSH
59241: EMPTY
59242: LIST
59243: LIST
59244: PPUSH
59245: CALL_OW 72
59249: NOT
59250: OR
59251: IFFALSE 59255
// continue ;
59253: GO 59209
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
59255: LD_ADDR_VAR 0 5
59259: PUSH
59260: LD_EXP 131
59264: PUSH
59265: LD_VAR 0 2
59269: ARRAY
59270: PUSH
59271: LD_INT 1
59273: ARRAY
59274: PPUSH
59275: CALL_OW 255
59279: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
59280: LD_VAR 0 5
59284: PPUSH
59285: LD_INT 2
59287: PPUSH
59288: CALL_OW 325
59292: IFFALSE 59545
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
59294: LD_ADDR_VAR 0 4
59298: PUSH
59299: LD_EXP 131
59303: PUSH
59304: LD_VAR 0 2
59308: ARRAY
59309: PPUSH
59310: LD_INT 25
59312: PUSH
59313: LD_INT 16
59315: PUSH
59316: EMPTY
59317: LIST
59318: LIST
59319: PPUSH
59320: CALL_OW 72
59324: ST_TO_ADDR
// if tmp < 6 then
59325: LD_VAR 0 4
59329: PUSH
59330: LD_INT 6
59332: LESS
59333: IFFALSE 59545
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59335: LD_ADDR_VAR 0 6
59339: PUSH
59340: LD_EXP 102
59344: PUSH
59345: LD_VAR 0 2
59349: ARRAY
59350: PPUSH
59351: LD_INT 2
59353: PUSH
59354: LD_INT 30
59356: PUSH
59357: LD_INT 0
59359: PUSH
59360: EMPTY
59361: LIST
59362: LIST
59363: PUSH
59364: LD_INT 30
59366: PUSH
59367: LD_INT 1
59369: PUSH
59370: EMPTY
59371: LIST
59372: LIST
59373: PUSH
59374: EMPTY
59375: LIST
59376: LIST
59377: LIST
59378: PPUSH
59379: CALL_OW 72
59383: ST_TO_ADDR
// if depot then
59384: LD_VAR 0 6
59388: IFFALSE 59545
// begin selected := 0 ;
59390: LD_ADDR_VAR 0 7
59394: PUSH
59395: LD_INT 0
59397: ST_TO_ADDR
// for j in depot do
59398: LD_ADDR_VAR 0 3
59402: PUSH
59403: LD_VAR 0 6
59407: PUSH
59408: FOR_IN
59409: IFFALSE 59440
// begin if UnitsInside ( j ) < 6 then
59411: LD_VAR 0 3
59415: PPUSH
59416: CALL_OW 313
59420: PUSH
59421: LD_INT 6
59423: LESS
59424: IFFALSE 59438
// begin selected := j ;
59426: LD_ADDR_VAR 0 7
59430: PUSH
59431: LD_VAR 0 3
59435: ST_TO_ADDR
// break ;
59436: GO 59440
// end ; end ;
59438: GO 59408
59440: POP
59441: POP
// if selected then
59442: LD_VAR 0 7
59446: IFFALSE 59545
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
59448: LD_ADDR_VAR 0 3
59452: PUSH
59453: LD_EXP 131
59457: PUSH
59458: LD_VAR 0 2
59462: ARRAY
59463: PPUSH
59464: LD_INT 25
59466: PUSH
59467: LD_INT 12
59469: PUSH
59470: EMPTY
59471: LIST
59472: LIST
59473: PPUSH
59474: CALL_OW 72
59478: PUSH
59479: FOR_IN
59480: IFFALSE 59543
// if not HasTask ( j ) then
59482: LD_VAR 0 3
59486: PPUSH
59487: CALL_OW 314
59491: NOT
59492: IFFALSE 59541
// begin if not IsInUnit ( j ) then
59494: LD_VAR 0 3
59498: PPUSH
59499: CALL_OW 310
59503: NOT
59504: IFFALSE 59520
// ComEnterUnit ( j , selected ) ;
59506: LD_VAR 0 3
59510: PPUSH
59511: LD_VAR 0 7
59515: PPUSH
59516: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
59520: LD_VAR 0 3
59524: PPUSH
59525: LD_INT 16
59527: PPUSH
59528: CALL_OW 183
// AddComExitBuilding ( j ) ;
59532: LD_VAR 0 3
59536: PPUSH
59537: CALL_OW 182
// end ;
59541: GO 59479
59543: POP
59544: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
59545: LD_VAR 0 5
59549: PPUSH
59550: LD_INT 11
59552: PPUSH
59553: CALL_OW 325
59557: IFFALSE 59816
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
59559: LD_ADDR_VAR 0 4
59563: PUSH
59564: LD_EXP 131
59568: PUSH
59569: LD_VAR 0 2
59573: ARRAY
59574: PPUSH
59575: LD_INT 25
59577: PUSH
59578: LD_INT 16
59580: PUSH
59581: EMPTY
59582: LIST
59583: LIST
59584: PPUSH
59585: CALL_OW 72
59589: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
59590: LD_VAR 0 4
59594: PUSH
59595: LD_INT 6
59597: GREATEREQUAL
59598: PUSH
59599: LD_VAR 0 5
59603: PPUSH
59604: LD_INT 2
59606: PPUSH
59607: CALL_OW 325
59611: NOT
59612: OR
59613: IFFALSE 59816
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
59615: LD_ADDR_VAR 0 8
59619: PUSH
59620: LD_EXP 102
59624: PUSH
59625: LD_VAR 0 2
59629: ARRAY
59630: PPUSH
59631: LD_INT 2
59633: PUSH
59634: LD_INT 30
59636: PUSH
59637: LD_INT 4
59639: PUSH
59640: EMPTY
59641: LIST
59642: LIST
59643: PUSH
59644: LD_INT 30
59646: PUSH
59647: LD_INT 5
59649: PUSH
59650: EMPTY
59651: LIST
59652: LIST
59653: PUSH
59654: EMPTY
59655: LIST
59656: LIST
59657: LIST
59658: PPUSH
59659: CALL_OW 72
59663: ST_TO_ADDR
// if barracks then
59664: LD_VAR 0 8
59668: IFFALSE 59816
// begin selected := 0 ;
59670: LD_ADDR_VAR 0 7
59674: PUSH
59675: LD_INT 0
59677: ST_TO_ADDR
// for j in barracks do
59678: LD_ADDR_VAR 0 3
59682: PUSH
59683: LD_VAR 0 8
59687: PUSH
59688: FOR_IN
59689: IFFALSE 59720
// begin if UnitsInside ( j ) < 6 then
59691: LD_VAR 0 3
59695: PPUSH
59696: CALL_OW 313
59700: PUSH
59701: LD_INT 6
59703: LESS
59704: IFFALSE 59718
// begin selected := j ;
59706: LD_ADDR_VAR 0 7
59710: PUSH
59711: LD_VAR 0 3
59715: ST_TO_ADDR
// break ;
59716: GO 59720
// end ; end ;
59718: GO 59688
59720: POP
59721: POP
// if selected then
59722: LD_VAR 0 7
59726: IFFALSE 59816
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
59728: LD_ADDR_VAR 0 3
59732: PUSH
59733: LD_EXP 131
59737: PUSH
59738: LD_VAR 0 2
59742: ARRAY
59743: PPUSH
59744: LD_INT 25
59746: PUSH
59747: LD_INT 12
59749: PUSH
59750: EMPTY
59751: LIST
59752: LIST
59753: PPUSH
59754: CALL_OW 72
59758: PUSH
59759: FOR_IN
59760: IFFALSE 59814
// if not IsInUnit ( j ) and not HasTask ( j ) then
59762: LD_VAR 0 3
59766: PPUSH
59767: CALL_OW 310
59771: NOT
59772: PUSH
59773: LD_VAR 0 3
59777: PPUSH
59778: CALL_OW 314
59782: NOT
59783: AND
59784: IFFALSE 59812
// begin ComEnterUnit ( j , selected ) ;
59786: LD_VAR 0 3
59790: PPUSH
59791: LD_VAR 0 7
59795: PPUSH
59796: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
59800: LD_VAR 0 3
59804: PPUSH
59805: LD_INT 15
59807: PPUSH
59808: CALL_OW 183
// end ;
59812: GO 59759
59814: POP
59815: POP
// end ; end ; end ; end ; end ;
59816: GO 59209
59818: POP
59819: POP
// end ;
59820: LD_VAR 0 1
59824: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
59825: LD_INT 0
59827: PPUSH
59828: PPUSH
59829: PPUSH
59830: PPUSH
// if not mc_bases then
59831: LD_EXP 102
59835: NOT
59836: IFFALSE 59840
// exit ;
59838: GO 60018
// for i = 1 to mc_bases do
59840: LD_ADDR_VAR 0 2
59844: PUSH
59845: DOUBLE
59846: LD_INT 1
59848: DEC
59849: ST_TO_ADDR
59850: LD_EXP 102
59854: PUSH
59855: FOR_TO
59856: IFFALSE 60016
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
59858: LD_ADDR_VAR 0 4
59862: PUSH
59863: LD_EXP 102
59867: PUSH
59868: LD_VAR 0 2
59872: ARRAY
59873: PPUSH
59874: LD_INT 25
59876: PUSH
59877: LD_INT 9
59879: PUSH
59880: EMPTY
59881: LIST
59882: LIST
59883: PPUSH
59884: CALL_OW 72
59888: ST_TO_ADDR
// if not tmp then
59889: LD_VAR 0 4
59893: NOT
59894: IFFALSE 59898
// continue ;
59896: GO 59855
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
59898: LD_EXP 128
59902: PUSH
59903: LD_VAR 0 2
59907: ARRAY
59908: PPUSH
59909: LD_INT 29
59911: PPUSH
59912: CALL_OW 325
59916: NOT
59917: PUSH
59918: LD_EXP 128
59922: PUSH
59923: LD_VAR 0 2
59927: ARRAY
59928: PPUSH
59929: LD_INT 28
59931: PPUSH
59932: CALL_OW 325
59936: NOT
59937: AND
59938: IFFALSE 59942
// continue ;
59940: GO 59855
// for j in tmp do
59942: LD_ADDR_VAR 0 3
59946: PUSH
59947: LD_VAR 0 4
59951: PUSH
59952: FOR_IN
59953: IFFALSE 60012
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
59955: LD_VAR 0 3
59959: PUSH
59960: LD_EXP 105
59964: PUSH
59965: LD_VAR 0 2
59969: ARRAY
59970: PUSH
59971: LD_INT 1
59973: ARRAY
59974: IN
59975: NOT
59976: PUSH
59977: LD_VAR 0 3
59981: PUSH
59982: LD_EXP 105
59986: PUSH
59987: LD_VAR 0 2
59991: ARRAY
59992: PUSH
59993: LD_INT 2
59995: ARRAY
59996: IN
59997: NOT
59998: AND
59999: IFFALSE 60010
// ComSpaceTimeShoot ( j ) ;
60001: LD_VAR 0 3
60005: PPUSH
60006: CALL 71240 0 1
60010: GO 59952
60012: POP
60013: POP
// end ;
60014: GO 59855
60016: POP
60017: POP
// end ;
60018: LD_VAR 0 1
60022: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
60023: LD_INT 0
60025: PPUSH
60026: PPUSH
60027: PPUSH
60028: PPUSH
60029: PPUSH
60030: PPUSH
60031: PPUSH
60032: PPUSH
60033: PPUSH
// if not mc_bases then
60034: LD_EXP 102
60038: NOT
60039: IFFALSE 60043
// exit ;
60041: GO 60665
// for i = 1 to mc_bases do
60043: LD_ADDR_VAR 0 2
60047: PUSH
60048: DOUBLE
60049: LD_INT 1
60051: DEC
60052: ST_TO_ADDR
60053: LD_EXP 102
60057: PUSH
60058: FOR_TO
60059: IFFALSE 60663
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
60061: LD_EXP 137
60065: PUSH
60066: LD_VAR 0 2
60070: ARRAY
60071: NOT
60072: PUSH
60073: LD_INT 38
60075: PPUSH
60076: LD_EXP 128
60080: PUSH
60081: LD_VAR 0 2
60085: ARRAY
60086: PPUSH
60087: CALL_OW 321
60091: PUSH
60092: LD_INT 2
60094: NONEQUAL
60095: OR
60096: IFFALSE 60100
// continue ;
60098: GO 60058
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
60100: LD_ADDR_VAR 0 8
60104: PUSH
60105: LD_EXP 102
60109: PUSH
60110: LD_VAR 0 2
60114: ARRAY
60115: PPUSH
60116: LD_INT 30
60118: PUSH
60119: LD_INT 34
60121: PUSH
60122: EMPTY
60123: LIST
60124: LIST
60125: PPUSH
60126: CALL_OW 72
60130: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
60131: LD_ADDR_VAR 0 9
60135: PUSH
60136: LD_EXP 102
60140: PUSH
60141: LD_VAR 0 2
60145: ARRAY
60146: PPUSH
60147: LD_INT 25
60149: PUSH
60150: LD_INT 4
60152: PUSH
60153: EMPTY
60154: LIST
60155: LIST
60156: PPUSH
60157: CALL_OW 72
60161: PPUSH
60162: LD_INT 0
60164: PPUSH
60165: CALL 105573 0 2
60169: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
60170: LD_VAR 0 9
60174: NOT
60175: PUSH
60176: LD_VAR 0 8
60180: NOT
60181: OR
60182: PUSH
60183: LD_EXP 102
60187: PUSH
60188: LD_VAR 0 2
60192: ARRAY
60193: PPUSH
60194: LD_INT 124
60196: PPUSH
60197: CALL 105573 0 2
60201: OR
60202: IFFALSE 60206
// continue ;
60204: GO 60058
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
60206: LD_EXP 138
60210: PUSH
60211: LD_VAR 0 2
60215: ARRAY
60216: PUSH
60217: LD_EXP 137
60221: PUSH
60222: LD_VAR 0 2
60226: ARRAY
60227: LESS
60228: PUSH
60229: LD_EXP 138
60233: PUSH
60234: LD_VAR 0 2
60238: ARRAY
60239: PUSH
60240: LD_VAR 0 8
60244: LESS
60245: AND
60246: IFFALSE 60661
// begin tmp := sci [ 1 ] ;
60248: LD_ADDR_VAR 0 7
60252: PUSH
60253: LD_VAR 0 9
60257: PUSH
60258: LD_INT 1
60260: ARRAY
60261: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
60262: LD_VAR 0 7
60266: PPUSH
60267: LD_INT 124
60269: PPUSH
60270: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
60274: LD_ADDR_VAR 0 3
60278: PUSH
60279: DOUBLE
60280: LD_EXP 137
60284: PUSH
60285: LD_VAR 0 2
60289: ARRAY
60290: INC
60291: ST_TO_ADDR
60292: LD_EXP 137
60296: PUSH
60297: LD_VAR 0 2
60301: ARRAY
60302: PUSH
60303: FOR_DOWNTO
60304: IFFALSE 60647
// begin if IsInUnit ( tmp ) then
60306: LD_VAR 0 7
60310: PPUSH
60311: CALL_OW 310
60315: IFFALSE 60326
// ComExitBuilding ( tmp ) ;
60317: LD_VAR 0 7
60321: PPUSH
60322: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
60326: LD_INT 35
60328: PPUSH
60329: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
60333: LD_VAR 0 7
60337: PPUSH
60338: CALL_OW 310
60342: NOT
60343: PUSH
60344: LD_VAR 0 7
60348: PPUSH
60349: CALL_OW 314
60353: NOT
60354: AND
60355: IFFALSE 60326
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
60357: LD_ADDR_VAR 0 6
60361: PUSH
60362: LD_VAR 0 7
60366: PPUSH
60367: CALL_OW 250
60371: PUSH
60372: LD_VAR 0 7
60376: PPUSH
60377: CALL_OW 251
60381: PUSH
60382: EMPTY
60383: LIST
60384: LIST
60385: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
60386: LD_INT 35
60388: PPUSH
60389: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
60393: LD_ADDR_VAR 0 4
60397: PUSH
60398: LD_EXP 137
60402: PUSH
60403: LD_VAR 0 2
60407: ARRAY
60408: PUSH
60409: LD_VAR 0 3
60413: ARRAY
60414: PUSH
60415: LD_INT 1
60417: ARRAY
60418: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
60419: LD_ADDR_VAR 0 5
60423: PUSH
60424: LD_EXP 137
60428: PUSH
60429: LD_VAR 0 2
60433: ARRAY
60434: PUSH
60435: LD_VAR 0 3
60439: ARRAY
60440: PUSH
60441: LD_INT 2
60443: ARRAY
60444: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
60445: LD_VAR 0 7
60449: PPUSH
60450: LD_INT 10
60452: PPUSH
60453: CALL 78220 0 2
60457: PUSH
60458: LD_INT 4
60460: ARRAY
60461: IFFALSE 60499
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
60463: LD_VAR 0 7
60467: PPUSH
60468: LD_VAR 0 6
60472: PUSH
60473: LD_INT 1
60475: ARRAY
60476: PPUSH
60477: LD_VAR 0 6
60481: PUSH
60482: LD_INT 2
60484: ARRAY
60485: PPUSH
60486: CALL_OW 111
// wait ( 0 0$10 ) ;
60490: LD_INT 350
60492: PPUSH
60493: CALL_OW 67
// end else
60497: GO 60525
// begin ComMoveXY ( tmp , x , y ) ;
60499: LD_VAR 0 7
60503: PPUSH
60504: LD_VAR 0 4
60508: PPUSH
60509: LD_VAR 0 5
60513: PPUSH
60514: CALL_OW 111
// wait ( 0 0$3 ) ;
60518: LD_INT 105
60520: PPUSH
60521: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
60525: LD_VAR 0 7
60529: PPUSH
60530: LD_VAR 0 4
60534: PPUSH
60535: LD_VAR 0 5
60539: PPUSH
60540: CALL_OW 307
60544: IFFALSE 60386
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
60546: LD_VAR 0 7
60550: PPUSH
60551: LD_VAR 0 4
60555: PPUSH
60556: LD_VAR 0 5
60560: PPUSH
60561: LD_VAR 0 8
60565: PUSH
60566: LD_VAR 0 3
60570: ARRAY
60571: PPUSH
60572: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
60576: LD_INT 35
60578: PPUSH
60579: CALL_OW 67
// until not HasTask ( tmp ) ;
60583: LD_VAR 0 7
60587: PPUSH
60588: CALL_OW 314
60592: NOT
60593: IFFALSE 60576
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
60595: LD_ADDR_EXP 138
60599: PUSH
60600: LD_EXP 138
60604: PPUSH
60605: LD_VAR 0 2
60609: PUSH
60610: LD_EXP 138
60614: PUSH
60615: LD_VAR 0 2
60619: ARRAY
60620: PUSH
60621: LD_INT 1
60623: PLUS
60624: PUSH
60625: EMPTY
60626: LIST
60627: LIST
60628: PPUSH
60629: LD_VAR 0 8
60633: PUSH
60634: LD_VAR 0 3
60638: ARRAY
60639: PPUSH
60640: CALL 75255 0 3
60644: ST_TO_ADDR
// end ;
60645: GO 60303
60647: POP
60648: POP
// MC_Reset ( i , 124 ) ;
60649: LD_VAR 0 2
60653: PPUSH
60654: LD_INT 124
60656: PPUSH
60657: CALL 43733 0 2
// end ; end ;
60661: GO 60058
60663: POP
60664: POP
// end ;
60665: LD_VAR 0 1
60669: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
60670: LD_INT 0
60672: PPUSH
60673: PPUSH
60674: PPUSH
// if not mc_bases then
60675: LD_EXP 102
60679: NOT
60680: IFFALSE 60684
// exit ;
60682: GO 61290
// for i = 1 to mc_bases do
60684: LD_ADDR_VAR 0 2
60688: PUSH
60689: DOUBLE
60690: LD_INT 1
60692: DEC
60693: ST_TO_ADDR
60694: LD_EXP 102
60698: PUSH
60699: FOR_TO
60700: IFFALSE 61288
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
60702: LD_ADDR_VAR 0 3
60706: PUSH
60707: LD_EXP 102
60711: PUSH
60712: LD_VAR 0 2
60716: ARRAY
60717: PPUSH
60718: LD_INT 25
60720: PUSH
60721: LD_INT 4
60723: PUSH
60724: EMPTY
60725: LIST
60726: LIST
60727: PPUSH
60728: CALL_OW 72
60732: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
60733: LD_VAR 0 3
60737: NOT
60738: PUSH
60739: LD_EXP 139
60743: PUSH
60744: LD_VAR 0 2
60748: ARRAY
60749: NOT
60750: OR
60751: PUSH
60752: LD_EXP 102
60756: PUSH
60757: LD_VAR 0 2
60761: ARRAY
60762: PPUSH
60763: LD_INT 2
60765: PUSH
60766: LD_INT 30
60768: PUSH
60769: LD_INT 0
60771: PUSH
60772: EMPTY
60773: LIST
60774: LIST
60775: PUSH
60776: LD_INT 30
60778: PUSH
60779: LD_INT 1
60781: PUSH
60782: EMPTY
60783: LIST
60784: LIST
60785: PUSH
60786: EMPTY
60787: LIST
60788: LIST
60789: LIST
60790: PPUSH
60791: CALL_OW 72
60795: NOT
60796: OR
60797: IFFALSE 60847
// begin if mc_deposits_finder [ i ] then
60799: LD_EXP 140
60803: PUSH
60804: LD_VAR 0 2
60808: ARRAY
60809: IFFALSE 60845
// begin MC_Reset ( i , 125 ) ;
60811: LD_VAR 0 2
60815: PPUSH
60816: LD_INT 125
60818: PPUSH
60819: CALL 43733 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60823: LD_ADDR_EXP 140
60827: PUSH
60828: LD_EXP 140
60832: PPUSH
60833: LD_VAR 0 2
60837: PPUSH
60838: EMPTY
60839: PPUSH
60840: CALL_OW 1
60844: ST_TO_ADDR
// end ; continue ;
60845: GO 60699
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
60847: LD_EXP 139
60851: PUSH
60852: LD_VAR 0 2
60856: ARRAY
60857: PUSH
60858: LD_INT 1
60860: ARRAY
60861: PUSH
60862: LD_INT 3
60864: ARRAY
60865: PUSH
60866: LD_INT 1
60868: EQUAL
60869: PUSH
60870: LD_INT 20
60872: PPUSH
60873: LD_EXP 128
60877: PUSH
60878: LD_VAR 0 2
60882: ARRAY
60883: PPUSH
60884: CALL_OW 321
60888: PUSH
60889: LD_INT 2
60891: NONEQUAL
60892: AND
60893: IFFALSE 60943
// begin if mc_deposits_finder [ i ] then
60895: LD_EXP 140
60899: PUSH
60900: LD_VAR 0 2
60904: ARRAY
60905: IFFALSE 60941
// begin MC_Reset ( i , 125 ) ;
60907: LD_VAR 0 2
60911: PPUSH
60912: LD_INT 125
60914: PPUSH
60915: CALL 43733 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60919: LD_ADDR_EXP 140
60923: PUSH
60924: LD_EXP 140
60928: PPUSH
60929: LD_VAR 0 2
60933: PPUSH
60934: EMPTY
60935: PPUSH
60936: CALL_OW 1
60940: ST_TO_ADDR
// end ; continue ;
60941: GO 60699
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
60943: LD_EXP 139
60947: PUSH
60948: LD_VAR 0 2
60952: ARRAY
60953: PUSH
60954: LD_INT 1
60956: ARRAY
60957: PUSH
60958: LD_INT 1
60960: ARRAY
60961: PPUSH
60962: LD_EXP 139
60966: PUSH
60967: LD_VAR 0 2
60971: ARRAY
60972: PUSH
60973: LD_INT 1
60975: ARRAY
60976: PUSH
60977: LD_INT 2
60979: ARRAY
60980: PPUSH
60981: LD_EXP 128
60985: PUSH
60986: LD_VAR 0 2
60990: ARRAY
60991: PPUSH
60992: CALL_OW 440
60996: IFFALSE 61039
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
60998: LD_ADDR_EXP 139
61002: PUSH
61003: LD_EXP 139
61007: PPUSH
61008: LD_VAR 0 2
61012: PPUSH
61013: LD_EXP 139
61017: PUSH
61018: LD_VAR 0 2
61022: ARRAY
61023: PPUSH
61024: LD_INT 1
61026: PPUSH
61027: CALL_OW 3
61031: PPUSH
61032: CALL_OW 1
61036: ST_TO_ADDR
61037: GO 61286
// begin if not mc_deposits_finder [ i ] then
61039: LD_EXP 140
61043: PUSH
61044: LD_VAR 0 2
61048: ARRAY
61049: NOT
61050: IFFALSE 61102
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
61052: LD_ADDR_EXP 140
61056: PUSH
61057: LD_EXP 140
61061: PPUSH
61062: LD_VAR 0 2
61066: PPUSH
61067: LD_VAR 0 3
61071: PUSH
61072: LD_INT 1
61074: ARRAY
61075: PUSH
61076: EMPTY
61077: LIST
61078: PPUSH
61079: CALL_OW 1
61083: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
61084: LD_VAR 0 3
61088: PUSH
61089: LD_INT 1
61091: ARRAY
61092: PPUSH
61093: LD_INT 125
61095: PPUSH
61096: CALL_OW 109
// end else
61100: GO 61286
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
61102: LD_EXP 140
61106: PUSH
61107: LD_VAR 0 2
61111: ARRAY
61112: PUSH
61113: LD_INT 1
61115: ARRAY
61116: PPUSH
61117: CALL_OW 310
61121: IFFALSE 61144
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
61123: LD_EXP 140
61127: PUSH
61128: LD_VAR 0 2
61132: ARRAY
61133: PUSH
61134: LD_INT 1
61136: ARRAY
61137: PPUSH
61138: CALL_OW 122
61142: GO 61286
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
61144: LD_EXP 140
61148: PUSH
61149: LD_VAR 0 2
61153: ARRAY
61154: PUSH
61155: LD_INT 1
61157: ARRAY
61158: PPUSH
61159: CALL_OW 314
61163: NOT
61164: PUSH
61165: LD_EXP 140
61169: PUSH
61170: LD_VAR 0 2
61174: ARRAY
61175: PUSH
61176: LD_INT 1
61178: ARRAY
61179: PPUSH
61180: LD_EXP 139
61184: PUSH
61185: LD_VAR 0 2
61189: ARRAY
61190: PUSH
61191: LD_INT 1
61193: ARRAY
61194: PUSH
61195: LD_INT 1
61197: ARRAY
61198: PPUSH
61199: LD_EXP 139
61203: PUSH
61204: LD_VAR 0 2
61208: ARRAY
61209: PUSH
61210: LD_INT 1
61212: ARRAY
61213: PUSH
61214: LD_INT 2
61216: ARRAY
61217: PPUSH
61218: CALL_OW 297
61222: PUSH
61223: LD_INT 6
61225: GREATER
61226: AND
61227: IFFALSE 61286
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
61229: LD_EXP 140
61233: PUSH
61234: LD_VAR 0 2
61238: ARRAY
61239: PUSH
61240: LD_INT 1
61242: ARRAY
61243: PPUSH
61244: LD_EXP 139
61248: PUSH
61249: LD_VAR 0 2
61253: ARRAY
61254: PUSH
61255: LD_INT 1
61257: ARRAY
61258: PUSH
61259: LD_INT 1
61261: ARRAY
61262: PPUSH
61263: LD_EXP 139
61267: PUSH
61268: LD_VAR 0 2
61272: ARRAY
61273: PUSH
61274: LD_INT 1
61276: ARRAY
61277: PUSH
61278: LD_INT 2
61280: ARRAY
61281: PPUSH
61282: CALL_OW 111
// end ; end ; end ;
61286: GO 60699
61288: POP
61289: POP
// end ;
61290: LD_VAR 0 1
61294: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
61295: LD_INT 0
61297: PPUSH
61298: PPUSH
61299: PPUSH
61300: PPUSH
61301: PPUSH
61302: PPUSH
61303: PPUSH
61304: PPUSH
61305: PPUSH
61306: PPUSH
61307: PPUSH
// if not mc_bases then
61308: LD_EXP 102
61312: NOT
61313: IFFALSE 61317
// exit ;
61315: GO 62257
// for i = 1 to mc_bases do
61317: LD_ADDR_VAR 0 2
61321: PUSH
61322: DOUBLE
61323: LD_INT 1
61325: DEC
61326: ST_TO_ADDR
61327: LD_EXP 102
61331: PUSH
61332: FOR_TO
61333: IFFALSE 62255
// begin if not mc_bases [ i ] or mc_scan [ i ] then
61335: LD_EXP 102
61339: PUSH
61340: LD_VAR 0 2
61344: ARRAY
61345: NOT
61346: PUSH
61347: LD_EXP 125
61351: PUSH
61352: LD_VAR 0 2
61356: ARRAY
61357: OR
61358: IFFALSE 61362
// continue ;
61360: GO 61332
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
61362: LD_ADDR_VAR 0 7
61366: PUSH
61367: LD_EXP 102
61371: PUSH
61372: LD_VAR 0 2
61376: ARRAY
61377: PUSH
61378: LD_INT 1
61380: ARRAY
61381: PPUSH
61382: CALL_OW 248
61386: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
61387: LD_VAR 0 7
61391: PUSH
61392: LD_INT 3
61394: EQUAL
61395: PUSH
61396: LD_EXP 121
61400: PUSH
61401: LD_VAR 0 2
61405: ARRAY
61406: PUSH
61407: LD_EXP 124
61411: PUSH
61412: LD_VAR 0 2
61416: ARRAY
61417: UNION
61418: PPUSH
61419: LD_INT 33
61421: PUSH
61422: LD_INT 2
61424: PUSH
61425: EMPTY
61426: LIST
61427: LIST
61428: PPUSH
61429: CALL_OW 72
61433: NOT
61434: OR
61435: IFFALSE 61439
// continue ;
61437: GO 61332
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
61439: LD_ADDR_VAR 0 9
61443: PUSH
61444: LD_EXP 102
61448: PUSH
61449: LD_VAR 0 2
61453: ARRAY
61454: PPUSH
61455: LD_INT 30
61457: PUSH
61458: LD_INT 36
61460: PUSH
61461: EMPTY
61462: LIST
61463: LIST
61464: PPUSH
61465: CALL_OW 72
61469: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
61470: LD_ADDR_VAR 0 10
61474: PUSH
61475: LD_EXP 121
61479: PUSH
61480: LD_VAR 0 2
61484: ARRAY
61485: PPUSH
61486: LD_INT 34
61488: PUSH
61489: LD_INT 31
61491: PUSH
61492: EMPTY
61493: LIST
61494: LIST
61495: PPUSH
61496: CALL_OW 72
61500: ST_TO_ADDR
// if not cts and not mcts then
61501: LD_VAR 0 9
61505: NOT
61506: PUSH
61507: LD_VAR 0 10
61511: NOT
61512: AND
61513: IFFALSE 61517
// continue ;
61515: GO 61332
// x := cts ;
61517: LD_ADDR_VAR 0 11
61521: PUSH
61522: LD_VAR 0 9
61526: ST_TO_ADDR
// if not x then
61527: LD_VAR 0 11
61531: NOT
61532: IFFALSE 61544
// x := mcts ;
61534: LD_ADDR_VAR 0 11
61538: PUSH
61539: LD_VAR 0 10
61543: ST_TO_ADDR
// if not x then
61544: LD_VAR 0 11
61548: NOT
61549: IFFALSE 61553
// continue ;
61551: GO 61332
// if mc_remote_driver [ i ] then
61553: LD_EXP 142
61557: PUSH
61558: LD_VAR 0 2
61562: ARRAY
61563: IFFALSE 61950
// for j in mc_remote_driver [ i ] do
61565: LD_ADDR_VAR 0 3
61569: PUSH
61570: LD_EXP 142
61574: PUSH
61575: LD_VAR 0 2
61579: ARRAY
61580: PUSH
61581: FOR_IN
61582: IFFALSE 61948
// begin if GetClass ( j ) <> 3 then
61584: LD_VAR 0 3
61588: PPUSH
61589: CALL_OW 257
61593: PUSH
61594: LD_INT 3
61596: NONEQUAL
61597: IFFALSE 61650
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
61599: LD_ADDR_EXP 142
61603: PUSH
61604: LD_EXP 142
61608: PPUSH
61609: LD_VAR 0 2
61613: PPUSH
61614: LD_EXP 142
61618: PUSH
61619: LD_VAR 0 2
61623: ARRAY
61624: PUSH
61625: LD_VAR 0 3
61629: DIFF
61630: PPUSH
61631: CALL_OW 1
61635: ST_TO_ADDR
// SetTag ( j , 0 ) ;
61636: LD_VAR 0 3
61640: PPUSH
61641: LD_INT 0
61643: PPUSH
61644: CALL_OW 109
// continue ;
61648: GO 61581
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
61650: LD_EXP 121
61654: PUSH
61655: LD_VAR 0 2
61659: ARRAY
61660: PPUSH
61661: LD_INT 34
61663: PUSH
61664: LD_INT 31
61666: PUSH
61667: EMPTY
61668: LIST
61669: LIST
61670: PUSH
61671: LD_INT 58
61673: PUSH
61674: EMPTY
61675: LIST
61676: PUSH
61677: EMPTY
61678: LIST
61679: LIST
61680: PPUSH
61681: CALL_OW 72
61685: PUSH
61686: LD_VAR 0 3
61690: PPUSH
61691: CALL 105608 0 1
61695: NOT
61696: AND
61697: IFFALSE 61768
// begin if IsInUnit ( j ) then
61699: LD_VAR 0 3
61703: PPUSH
61704: CALL_OW 310
61708: IFFALSE 61719
// ComExitBuilding ( j ) ;
61710: LD_VAR 0 3
61714: PPUSH
61715: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
61719: LD_VAR 0 3
61723: PPUSH
61724: LD_EXP 121
61728: PUSH
61729: LD_VAR 0 2
61733: ARRAY
61734: PPUSH
61735: LD_INT 34
61737: PUSH
61738: LD_INT 31
61740: PUSH
61741: EMPTY
61742: LIST
61743: LIST
61744: PUSH
61745: LD_INT 58
61747: PUSH
61748: EMPTY
61749: LIST
61750: PUSH
61751: EMPTY
61752: LIST
61753: LIST
61754: PPUSH
61755: CALL_OW 72
61759: PUSH
61760: LD_INT 1
61762: ARRAY
61763: PPUSH
61764: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
61768: LD_VAR 0 3
61772: PPUSH
61773: CALL_OW 310
61777: NOT
61778: PUSH
61779: LD_VAR 0 3
61783: PPUSH
61784: CALL_OW 310
61788: PPUSH
61789: CALL_OW 266
61793: PUSH
61794: LD_INT 36
61796: NONEQUAL
61797: PUSH
61798: LD_VAR 0 3
61802: PPUSH
61803: CALL 105608 0 1
61807: NOT
61808: AND
61809: OR
61810: IFFALSE 61946
// begin if IsInUnit ( j ) then
61812: LD_VAR 0 3
61816: PPUSH
61817: CALL_OW 310
61821: IFFALSE 61832
// ComExitBuilding ( j ) ;
61823: LD_VAR 0 3
61827: PPUSH
61828: CALL_OW 122
// ct := 0 ;
61832: LD_ADDR_VAR 0 8
61836: PUSH
61837: LD_INT 0
61839: ST_TO_ADDR
// for k in x do
61840: LD_ADDR_VAR 0 4
61844: PUSH
61845: LD_VAR 0 11
61849: PUSH
61850: FOR_IN
61851: IFFALSE 61924
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
61853: LD_VAR 0 4
61857: PPUSH
61858: CALL_OW 264
61862: PUSH
61863: LD_INT 31
61865: EQUAL
61866: PUSH
61867: LD_VAR 0 4
61871: PPUSH
61872: CALL_OW 311
61876: NOT
61877: AND
61878: PUSH
61879: LD_VAR 0 4
61883: PPUSH
61884: CALL_OW 266
61888: PUSH
61889: LD_INT 36
61891: EQUAL
61892: PUSH
61893: LD_VAR 0 4
61897: PPUSH
61898: CALL_OW 313
61902: PUSH
61903: LD_INT 3
61905: LESS
61906: AND
61907: OR
61908: IFFALSE 61922
// begin ct := k ;
61910: LD_ADDR_VAR 0 8
61914: PUSH
61915: LD_VAR 0 4
61919: ST_TO_ADDR
// break ;
61920: GO 61924
// end ;
61922: GO 61850
61924: POP
61925: POP
// if ct then
61926: LD_VAR 0 8
61930: IFFALSE 61946
// ComEnterUnit ( j , ct ) ;
61932: LD_VAR 0 3
61936: PPUSH
61937: LD_VAR 0 8
61941: PPUSH
61942: CALL_OW 120
// end ; end ;
61946: GO 61581
61948: POP
61949: POP
// places := 0 ;
61950: LD_ADDR_VAR 0 5
61954: PUSH
61955: LD_INT 0
61957: ST_TO_ADDR
// for j = 1 to x do
61958: LD_ADDR_VAR 0 3
61962: PUSH
61963: DOUBLE
61964: LD_INT 1
61966: DEC
61967: ST_TO_ADDR
61968: LD_VAR 0 11
61972: PUSH
61973: FOR_TO
61974: IFFALSE 62050
// if GetWeapon ( x [ j ] ) = ar_control_tower then
61976: LD_VAR 0 11
61980: PUSH
61981: LD_VAR 0 3
61985: ARRAY
61986: PPUSH
61987: CALL_OW 264
61991: PUSH
61992: LD_INT 31
61994: EQUAL
61995: IFFALSE 62013
// places := places + 1 else
61997: LD_ADDR_VAR 0 5
62001: PUSH
62002: LD_VAR 0 5
62006: PUSH
62007: LD_INT 1
62009: PLUS
62010: ST_TO_ADDR
62011: GO 62048
// if GetBType ( x [ j ] ) = b_control_tower then
62013: LD_VAR 0 11
62017: PUSH
62018: LD_VAR 0 3
62022: ARRAY
62023: PPUSH
62024: CALL_OW 266
62028: PUSH
62029: LD_INT 36
62031: EQUAL
62032: IFFALSE 62048
// places := places + 3 ;
62034: LD_ADDR_VAR 0 5
62038: PUSH
62039: LD_VAR 0 5
62043: PUSH
62044: LD_INT 3
62046: PLUS
62047: ST_TO_ADDR
62048: GO 61973
62050: POP
62051: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
62052: LD_VAR 0 5
62056: PUSH
62057: LD_INT 0
62059: EQUAL
62060: PUSH
62061: LD_VAR 0 5
62065: PUSH
62066: LD_EXP 142
62070: PUSH
62071: LD_VAR 0 2
62075: ARRAY
62076: LESSEQUAL
62077: OR
62078: IFFALSE 62082
// continue ;
62080: GO 61332
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
62082: LD_ADDR_VAR 0 6
62086: PUSH
62087: LD_EXP 102
62091: PUSH
62092: LD_VAR 0 2
62096: ARRAY
62097: PPUSH
62098: LD_INT 25
62100: PUSH
62101: LD_INT 3
62103: PUSH
62104: EMPTY
62105: LIST
62106: LIST
62107: PPUSH
62108: CALL_OW 72
62112: PUSH
62113: LD_EXP 142
62117: PUSH
62118: LD_VAR 0 2
62122: ARRAY
62123: DIFF
62124: PPUSH
62125: LD_INT 3
62127: PPUSH
62128: CALL 106508 0 2
62132: ST_TO_ADDR
// for j in tmp do
62133: LD_ADDR_VAR 0 3
62137: PUSH
62138: LD_VAR 0 6
62142: PUSH
62143: FOR_IN
62144: IFFALSE 62179
// if GetTag ( j ) > 0 then
62146: LD_VAR 0 3
62150: PPUSH
62151: CALL_OW 110
62155: PUSH
62156: LD_INT 0
62158: GREATER
62159: IFFALSE 62177
// tmp := tmp diff j ;
62161: LD_ADDR_VAR 0 6
62165: PUSH
62166: LD_VAR 0 6
62170: PUSH
62171: LD_VAR 0 3
62175: DIFF
62176: ST_TO_ADDR
62177: GO 62143
62179: POP
62180: POP
// if not tmp then
62181: LD_VAR 0 6
62185: NOT
62186: IFFALSE 62190
// continue ;
62188: GO 61332
// if places then
62190: LD_VAR 0 5
62194: IFFALSE 62253
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
62196: LD_ADDR_EXP 142
62200: PUSH
62201: LD_EXP 142
62205: PPUSH
62206: LD_VAR 0 2
62210: PPUSH
62211: LD_EXP 142
62215: PUSH
62216: LD_VAR 0 2
62220: ARRAY
62221: PUSH
62222: LD_VAR 0 6
62226: PUSH
62227: LD_INT 1
62229: ARRAY
62230: UNION
62231: PPUSH
62232: CALL_OW 1
62236: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
62237: LD_VAR 0 6
62241: PUSH
62242: LD_INT 1
62244: ARRAY
62245: PPUSH
62246: LD_INT 126
62248: PPUSH
62249: CALL_OW 109
// end ; end ;
62253: GO 61332
62255: POP
62256: POP
// end ;
62257: LD_VAR 0 1
62261: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
62262: LD_INT 0
62264: PPUSH
62265: PPUSH
62266: PPUSH
62267: PPUSH
62268: PPUSH
62269: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
62270: LD_VAR 0 1
62274: NOT
62275: PUSH
62276: LD_VAR 0 2
62280: NOT
62281: OR
62282: PUSH
62283: LD_VAR 0 3
62287: NOT
62288: OR
62289: PUSH
62290: LD_VAR 0 4
62294: PUSH
62295: LD_INT 1
62297: PUSH
62298: LD_INT 2
62300: PUSH
62301: LD_INT 3
62303: PUSH
62304: LD_INT 4
62306: PUSH
62307: LD_INT 5
62309: PUSH
62310: LD_INT 8
62312: PUSH
62313: LD_INT 9
62315: PUSH
62316: LD_INT 15
62318: PUSH
62319: LD_INT 16
62321: PUSH
62322: EMPTY
62323: LIST
62324: LIST
62325: LIST
62326: LIST
62327: LIST
62328: LIST
62329: LIST
62330: LIST
62331: LIST
62332: IN
62333: NOT
62334: OR
62335: IFFALSE 62339
// exit ;
62337: GO 63197
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
62339: LD_ADDR_VAR 0 2
62343: PUSH
62344: LD_VAR 0 2
62348: PPUSH
62349: LD_INT 21
62351: PUSH
62352: LD_INT 3
62354: PUSH
62355: EMPTY
62356: LIST
62357: LIST
62358: PUSH
62359: LD_INT 24
62361: PUSH
62362: LD_INT 250
62364: PUSH
62365: EMPTY
62366: LIST
62367: LIST
62368: PUSH
62369: EMPTY
62370: LIST
62371: LIST
62372: PPUSH
62373: CALL_OW 72
62377: ST_TO_ADDR
// case class of 1 , 15 :
62378: LD_VAR 0 4
62382: PUSH
62383: LD_INT 1
62385: DOUBLE
62386: EQUAL
62387: IFTRUE 62397
62389: LD_INT 15
62391: DOUBLE
62392: EQUAL
62393: IFTRUE 62397
62395: GO 62482
62397: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
62398: LD_ADDR_VAR 0 8
62402: PUSH
62403: LD_VAR 0 2
62407: PPUSH
62408: LD_INT 2
62410: PUSH
62411: LD_INT 30
62413: PUSH
62414: LD_INT 32
62416: PUSH
62417: EMPTY
62418: LIST
62419: LIST
62420: PUSH
62421: LD_INT 30
62423: PUSH
62424: LD_INT 31
62426: PUSH
62427: EMPTY
62428: LIST
62429: LIST
62430: PUSH
62431: EMPTY
62432: LIST
62433: LIST
62434: LIST
62435: PPUSH
62436: CALL_OW 72
62440: PUSH
62441: LD_VAR 0 2
62445: PPUSH
62446: LD_INT 2
62448: PUSH
62449: LD_INT 30
62451: PUSH
62452: LD_INT 4
62454: PUSH
62455: EMPTY
62456: LIST
62457: LIST
62458: PUSH
62459: LD_INT 30
62461: PUSH
62462: LD_INT 5
62464: PUSH
62465: EMPTY
62466: LIST
62467: LIST
62468: PUSH
62469: EMPTY
62470: LIST
62471: LIST
62472: LIST
62473: PPUSH
62474: CALL_OW 72
62478: ADD
62479: ST_TO_ADDR
62480: GO 62728
62482: LD_INT 2
62484: DOUBLE
62485: EQUAL
62486: IFTRUE 62496
62488: LD_INT 16
62490: DOUBLE
62491: EQUAL
62492: IFTRUE 62496
62494: GO 62542
62496: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
62497: LD_ADDR_VAR 0 8
62501: PUSH
62502: LD_VAR 0 2
62506: PPUSH
62507: LD_INT 2
62509: PUSH
62510: LD_INT 30
62512: PUSH
62513: LD_INT 0
62515: PUSH
62516: EMPTY
62517: LIST
62518: LIST
62519: PUSH
62520: LD_INT 30
62522: PUSH
62523: LD_INT 1
62525: PUSH
62526: EMPTY
62527: LIST
62528: LIST
62529: PUSH
62530: EMPTY
62531: LIST
62532: LIST
62533: LIST
62534: PPUSH
62535: CALL_OW 72
62539: ST_TO_ADDR
62540: GO 62728
62542: LD_INT 3
62544: DOUBLE
62545: EQUAL
62546: IFTRUE 62550
62548: GO 62596
62550: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
62551: LD_ADDR_VAR 0 8
62555: PUSH
62556: LD_VAR 0 2
62560: PPUSH
62561: LD_INT 2
62563: PUSH
62564: LD_INT 30
62566: PUSH
62567: LD_INT 2
62569: PUSH
62570: EMPTY
62571: LIST
62572: LIST
62573: PUSH
62574: LD_INT 30
62576: PUSH
62577: LD_INT 3
62579: PUSH
62580: EMPTY
62581: LIST
62582: LIST
62583: PUSH
62584: EMPTY
62585: LIST
62586: LIST
62587: LIST
62588: PPUSH
62589: CALL_OW 72
62593: ST_TO_ADDR
62594: GO 62728
62596: LD_INT 4
62598: DOUBLE
62599: EQUAL
62600: IFTRUE 62604
62602: GO 62661
62604: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
62605: LD_ADDR_VAR 0 8
62609: PUSH
62610: LD_VAR 0 2
62614: PPUSH
62615: LD_INT 2
62617: PUSH
62618: LD_INT 30
62620: PUSH
62621: LD_INT 6
62623: PUSH
62624: EMPTY
62625: LIST
62626: LIST
62627: PUSH
62628: LD_INT 30
62630: PUSH
62631: LD_INT 7
62633: PUSH
62634: EMPTY
62635: LIST
62636: LIST
62637: PUSH
62638: LD_INT 30
62640: PUSH
62641: LD_INT 8
62643: PUSH
62644: EMPTY
62645: LIST
62646: LIST
62647: PUSH
62648: EMPTY
62649: LIST
62650: LIST
62651: LIST
62652: LIST
62653: PPUSH
62654: CALL_OW 72
62658: ST_TO_ADDR
62659: GO 62728
62661: LD_INT 5
62663: DOUBLE
62664: EQUAL
62665: IFTRUE 62681
62667: LD_INT 8
62669: DOUBLE
62670: EQUAL
62671: IFTRUE 62681
62673: LD_INT 9
62675: DOUBLE
62676: EQUAL
62677: IFTRUE 62681
62679: GO 62727
62681: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
62682: LD_ADDR_VAR 0 8
62686: PUSH
62687: LD_VAR 0 2
62691: PPUSH
62692: LD_INT 2
62694: PUSH
62695: LD_INT 30
62697: PUSH
62698: LD_INT 4
62700: PUSH
62701: EMPTY
62702: LIST
62703: LIST
62704: PUSH
62705: LD_INT 30
62707: PUSH
62708: LD_INT 5
62710: PUSH
62711: EMPTY
62712: LIST
62713: LIST
62714: PUSH
62715: EMPTY
62716: LIST
62717: LIST
62718: LIST
62719: PPUSH
62720: CALL_OW 72
62724: ST_TO_ADDR
62725: GO 62728
62727: POP
// if not tmp then
62728: LD_VAR 0 8
62732: NOT
62733: IFFALSE 62737
// exit ;
62735: GO 63197
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
62737: LD_VAR 0 4
62741: PUSH
62742: LD_INT 1
62744: PUSH
62745: LD_INT 15
62747: PUSH
62748: EMPTY
62749: LIST
62750: LIST
62751: IN
62752: PUSH
62753: LD_EXP 111
62757: PUSH
62758: LD_VAR 0 1
62762: ARRAY
62763: AND
62764: IFFALSE 62920
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
62766: LD_ADDR_VAR 0 9
62770: PUSH
62771: LD_EXP 111
62775: PUSH
62776: LD_VAR 0 1
62780: ARRAY
62781: PUSH
62782: LD_INT 1
62784: ARRAY
62785: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
62786: LD_VAR 0 9
62790: PUSH
62791: LD_EXP 112
62795: PUSH
62796: LD_VAR 0 1
62800: ARRAY
62801: IN
62802: NOT
62803: IFFALSE 62918
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
62805: LD_ADDR_EXP 112
62809: PUSH
62810: LD_EXP 112
62814: PPUSH
62815: LD_VAR 0 1
62819: PUSH
62820: LD_EXP 112
62824: PUSH
62825: LD_VAR 0 1
62829: ARRAY
62830: PUSH
62831: LD_INT 1
62833: PLUS
62834: PUSH
62835: EMPTY
62836: LIST
62837: LIST
62838: PPUSH
62839: LD_VAR 0 9
62843: PPUSH
62844: CALL 75255 0 3
62848: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
62849: LD_ADDR_EXP 111
62853: PUSH
62854: LD_EXP 111
62858: PPUSH
62859: LD_VAR 0 1
62863: PPUSH
62864: LD_EXP 111
62868: PUSH
62869: LD_VAR 0 1
62873: ARRAY
62874: PUSH
62875: LD_VAR 0 9
62879: DIFF
62880: PPUSH
62881: CALL_OW 1
62885: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
62886: LD_VAR 0 3
62890: PPUSH
62891: LD_EXP 112
62895: PUSH
62896: LD_VAR 0 1
62900: ARRAY
62901: PUSH
62902: LD_EXP 112
62906: PUSH
62907: LD_VAR 0 1
62911: ARRAY
62912: ARRAY
62913: PPUSH
62914: CALL_OW 120
// end ; exit ;
62918: GO 63197
// end ; if tmp > 1 then
62920: LD_VAR 0 8
62924: PUSH
62925: LD_INT 1
62927: GREATER
62928: IFFALSE 63032
// for i = 2 to tmp do
62930: LD_ADDR_VAR 0 6
62934: PUSH
62935: DOUBLE
62936: LD_INT 2
62938: DEC
62939: ST_TO_ADDR
62940: LD_VAR 0 8
62944: PUSH
62945: FOR_TO
62946: IFFALSE 63030
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
62948: LD_VAR 0 8
62952: PUSH
62953: LD_VAR 0 6
62957: ARRAY
62958: PPUSH
62959: CALL_OW 461
62963: PUSH
62964: LD_INT 6
62966: EQUAL
62967: IFFALSE 63028
// begin x := tmp [ i ] ;
62969: LD_ADDR_VAR 0 9
62973: PUSH
62974: LD_VAR 0 8
62978: PUSH
62979: LD_VAR 0 6
62983: ARRAY
62984: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
62985: LD_ADDR_VAR 0 8
62989: PUSH
62990: LD_VAR 0 8
62994: PPUSH
62995: LD_VAR 0 6
62999: PPUSH
63000: CALL_OW 3
63004: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
63005: LD_ADDR_VAR 0 8
63009: PUSH
63010: LD_VAR 0 8
63014: PPUSH
63015: LD_INT 1
63017: PPUSH
63018: LD_VAR 0 9
63022: PPUSH
63023: CALL_OW 2
63027: ST_TO_ADDR
// end ;
63028: GO 62945
63030: POP
63031: POP
// for i in tmp do
63032: LD_ADDR_VAR 0 6
63036: PUSH
63037: LD_VAR 0 8
63041: PUSH
63042: FOR_IN
63043: IFFALSE 63070
// begin if IsNotFull ( i ) then
63045: LD_VAR 0 6
63049: PPUSH
63050: CALL 72477 0 1
63054: IFFALSE 63068
// begin j := i ;
63056: LD_ADDR_VAR 0 7
63060: PUSH
63061: LD_VAR 0 6
63065: ST_TO_ADDR
// break ;
63066: GO 63070
// end ; end ;
63068: GO 63042
63070: POP
63071: POP
// if j then
63072: LD_VAR 0 7
63076: IFFALSE 63094
// ComEnterUnit ( unit , j ) else
63078: LD_VAR 0 3
63082: PPUSH
63083: LD_VAR 0 7
63087: PPUSH
63088: CALL_OW 120
63092: GO 63197
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63094: LD_ADDR_VAR 0 10
63098: PUSH
63099: LD_VAR 0 2
63103: PPUSH
63104: LD_INT 2
63106: PUSH
63107: LD_INT 30
63109: PUSH
63110: LD_INT 0
63112: PUSH
63113: EMPTY
63114: LIST
63115: LIST
63116: PUSH
63117: LD_INT 30
63119: PUSH
63120: LD_INT 1
63122: PUSH
63123: EMPTY
63124: LIST
63125: LIST
63126: PUSH
63127: EMPTY
63128: LIST
63129: LIST
63130: LIST
63131: PPUSH
63132: CALL_OW 72
63136: ST_TO_ADDR
// if depot then
63137: LD_VAR 0 10
63141: IFFALSE 63197
// begin depot := NearestUnitToUnit ( depot , unit ) ;
63143: LD_ADDR_VAR 0 10
63147: PUSH
63148: LD_VAR 0 10
63152: PPUSH
63153: LD_VAR 0 3
63157: PPUSH
63158: CALL_OW 74
63162: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
63163: LD_VAR 0 3
63167: PPUSH
63168: LD_VAR 0 10
63172: PPUSH
63173: CALL_OW 296
63177: PUSH
63178: LD_INT 10
63180: GREATER
63181: IFFALSE 63197
// ComStandNearbyBuilding ( unit , depot ) ;
63183: LD_VAR 0 3
63187: PPUSH
63188: LD_VAR 0 10
63192: PPUSH
63193: CALL 71857 0 2
// end ; end ; end ;
63197: LD_VAR 0 5
63201: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
63202: LD_INT 0
63204: PPUSH
63205: PPUSH
63206: PPUSH
63207: PPUSH
// if not mc_bases then
63208: LD_EXP 102
63212: NOT
63213: IFFALSE 63217
// exit ;
63215: GO 63456
// for i = 1 to mc_bases do
63217: LD_ADDR_VAR 0 2
63221: PUSH
63222: DOUBLE
63223: LD_INT 1
63225: DEC
63226: ST_TO_ADDR
63227: LD_EXP 102
63231: PUSH
63232: FOR_TO
63233: IFFALSE 63454
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
63235: LD_ADDR_VAR 0 4
63239: PUSH
63240: LD_EXP 102
63244: PUSH
63245: LD_VAR 0 2
63249: ARRAY
63250: PPUSH
63251: LD_INT 21
63253: PUSH
63254: LD_INT 1
63256: PUSH
63257: EMPTY
63258: LIST
63259: LIST
63260: PPUSH
63261: CALL_OW 72
63265: PUSH
63266: LD_EXP 131
63270: PUSH
63271: LD_VAR 0 2
63275: ARRAY
63276: UNION
63277: ST_TO_ADDR
// if not tmp then
63278: LD_VAR 0 4
63282: NOT
63283: IFFALSE 63287
// continue ;
63285: GO 63232
// for j in tmp do
63287: LD_ADDR_VAR 0 3
63291: PUSH
63292: LD_VAR 0 4
63296: PUSH
63297: FOR_IN
63298: IFFALSE 63450
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
63300: LD_VAR 0 3
63304: PPUSH
63305: CALL_OW 110
63309: NOT
63310: PUSH
63311: LD_VAR 0 3
63315: PPUSH
63316: CALL_OW 314
63320: NOT
63321: AND
63322: PUSH
63323: LD_VAR 0 3
63327: PPUSH
63328: CALL_OW 311
63332: NOT
63333: AND
63334: PUSH
63335: LD_VAR 0 3
63339: PPUSH
63340: CALL_OW 310
63344: NOT
63345: AND
63346: PUSH
63347: LD_VAR 0 3
63351: PUSH
63352: LD_EXP 105
63356: PUSH
63357: LD_VAR 0 2
63361: ARRAY
63362: PUSH
63363: LD_INT 1
63365: ARRAY
63366: IN
63367: NOT
63368: AND
63369: PUSH
63370: LD_VAR 0 3
63374: PUSH
63375: LD_EXP 105
63379: PUSH
63380: LD_VAR 0 2
63384: ARRAY
63385: PUSH
63386: LD_INT 2
63388: ARRAY
63389: IN
63390: NOT
63391: AND
63392: PUSH
63393: LD_VAR 0 3
63397: PUSH
63398: LD_EXP 114
63402: PUSH
63403: LD_VAR 0 2
63407: ARRAY
63408: IN
63409: NOT
63410: AND
63411: IFFALSE 63448
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
63413: LD_VAR 0 2
63417: PPUSH
63418: LD_EXP 102
63422: PUSH
63423: LD_VAR 0 2
63427: ARRAY
63428: PPUSH
63429: LD_VAR 0 3
63433: PPUSH
63434: LD_VAR 0 3
63438: PPUSH
63439: CALL_OW 257
63443: PPUSH
63444: CALL 62262 0 4
// end ;
63448: GO 63297
63450: POP
63451: POP
// end ;
63452: GO 63232
63454: POP
63455: POP
// end ;
63456: LD_VAR 0 1
63460: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
63461: LD_INT 0
63463: PPUSH
63464: PPUSH
63465: PPUSH
63466: PPUSH
63467: PPUSH
63468: PPUSH
// if not mc_bases [ base ] then
63469: LD_EXP 102
63473: PUSH
63474: LD_VAR 0 1
63478: ARRAY
63479: NOT
63480: IFFALSE 63484
// exit ;
63482: GO 63685
// tmp := [ ] ;
63484: LD_ADDR_VAR 0 6
63488: PUSH
63489: EMPTY
63490: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
63491: LD_ADDR_VAR 0 7
63495: PUSH
63496: LD_VAR 0 3
63500: PPUSH
63501: LD_INT 0
63503: PPUSH
63504: CALL_OW 517
63508: ST_TO_ADDR
// if not list then
63509: LD_VAR 0 7
63513: NOT
63514: IFFALSE 63518
// exit ;
63516: GO 63685
// c := Count ( list [ 1 ] ) ;
63518: LD_ADDR_VAR 0 9
63522: PUSH
63523: LD_VAR 0 7
63527: PUSH
63528: LD_INT 1
63530: ARRAY
63531: PPUSH
63532: CALL 72395 0 1
63536: ST_TO_ADDR
// if amount > c then
63537: LD_VAR 0 2
63541: PUSH
63542: LD_VAR 0 9
63546: GREATER
63547: IFFALSE 63559
// amount := c ;
63549: LD_ADDR_VAR 0 2
63553: PUSH
63554: LD_VAR 0 9
63558: ST_TO_ADDR
// for i := 1 to amount do
63559: LD_ADDR_VAR 0 5
63563: PUSH
63564: DOUBLE
63565: LD_INT 1
63567: DEC
63568: ST_TO_ADDR
63569: LD_VAR 0 2
63573: PUSH
63574: FOR_TO
63575: IFFALSE 63633
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
63577: LD_ADDR_VAR 0 6
63581: PUSH
63582: LD_VAR 0 6
63586: PPUSH
63587: LD_VAR 0 5
63591: PPUSH
63592: LD_VAR 0 7
63596: PUSH
63597: LD_INT 1
63599: ARRAY
63600: PUSH
63601: LD_VAR 0 5
63605: ARRAY
63606: PUSH
63607: LD_VAR 0 7
63611: PUSH
63612: LD_INT 2
63614: ARRAY
63615: PUSH
63616: LD_VAR 0 5
63620: ARRAY
63621: PUSH
63622: EMPTY
63623: LIST
63624: LIST
63625: PPUSH
63626: CALL_OW 1
63630: ST_TO_ADDR
63631: GO 63574
63633: POP
63634: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
63635: LD_ADDR_EXP 115
63639: PUSH
63640: LD_EXP 115
63644: PPUSH
63645: LD_VAR 0 1
63649: PPUSH
63650: LD_VAR 0 6
63654: PPUSH
63655: CALL_OW 1
63659: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
63660: LD_ADDR_EXP 117
63664: PUSH
63665: LD_EXP 117
63669: PPUSH
63670: LD_VAR 0 1
63674: PPUSH
63675: LD_VAR 0 3
63679: PPUSH
63680: CALL_OW 1
63684: ST_TO_ADDR
// end ;
63685: LD_VAR 0 4
63689: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
63690: LD_INT 0
63692: PPUSH
// if not mc_bases [ base ] then
63693: LD_EXP 102
63697: PUSH
63698: LD_VAR 0 1
63702: ARRAY
63703: NOT
63704: IFFALSE 63708
// exit ;
63706: GO 63733
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
63708: LD_ADDR_EXP 107
63712: PUSH
63713: LD_EXP 107
63717: PPUSH
63718: LD_VAR 0 1
63722: PPUSH
63723: LD_VAR 0 2
63727: PPUSH
63728: CALL_OW 1
63732: ST_TO_ADDR
// end ;
63733: LD_VAR 0 3
63737: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
63738: LD_INT 0
63740: PPUSH
// if not mc_bases [ base ] then
63741: LD_EXP 102
63745: PUSH
63746: LD_VAR 0 1
63750: ARRAY
63751: NOT
63752: IFFALSE 63756
// exit ;
63754: GO 63793
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
63756: LD_ADDR_EXP 107
63760: PUSH
63761: LD_EXP 107
63765: PPUSH
63766: LD_VAR 0 1
63770: PPUSH
63771: LD_EXP 107
63775: PUSH
63776: LD_VAR 0 1
63780: ARRAY
63781: PUSH
63782: LD_VAR 0 2
63786: UNION
63787: PPUSH
63788: CALL_OW 1
63792: ST_TO_ADDR
// end ;
63793: LD_VAR 0 3
63797: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
63798: LD_INT 0
63800: PPUSH
// if not mc_bases [ base ] then
63801: LD_EXP 102
63805: PUSH
63806: LD_VAR 0 1
63810: ARRAY
63811: NOT
63812: IFFALSE 63816
// exit ;
63814: GO 63841
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
63816: LD_ADDR_EXP 123
63820: PUSH
63821: LD_EXP 123
63825: PPUSH
63826: LD_VAR 0 1
63830: PPUSH
63831: LD_VAR 0 2
63835: PPUSH
63836: CALL_OW 1
63840: ST_TO_ADDR
// end ;
63841: LD_VAR 0 3
63845: RET
// export function MC_InsertProduceList ( base , components ) ; begin
63846: LD_INT 0
63848: PPUSH
// if not mc_bases [ base ] then
63849: LD_EXP 102
63853: PUSH
63854: LD_VAR 0 1
63858: ARRAY
63859: NOT
63860: IFFALSE 63864
// exit ;
63862: GO 63901
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
63864: LD_ADDR_EXP 123
63868: PUSH
63869: LD_EXP 123
63873: PPUSH
63874: LD_VAR 0 1
63878: PPUSH
63879: LD_EXP 123
63883: PUSH
63884: LD_VAR 0 1
63888: ARRAY
63889: PUSH
63890: LD_VAR 0 2
63894: ADD
63895: PPUSH
63896: CALL_OW 1
63900: ST_TO_ADDR
// end ;
63901: LD_VAR 0 3
63905: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
63906: LD_INT 0
63908: PPUSH
// if not mc_bases [ base ] then
63909: LD_EXP 102
63913: PUSH
63914: LD_VAR 0 1
63918: ARRAY
63919: NOT
63920: IFFALSE 63924
// exit ;
63922: GO 63978
// mc_defender := Replace ( mc_defender , base , deflist ) ;
63924: LD_ADDR_EXP 124
63928: PUSH
63929: LD_EXP 124
63933: PPUSH
63934: LD_VAR 0 1
63938: PPUSH
63939: LD_VAR 0 2
63943: PPUSH
63944: CALL_OW 1
63948: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
63949: LD_ADDR_EXP 113
63953: PUSH
63954: LD_EXP 113
63958: PPUSH
63959: LD_VAR 0 1
63963: PPUSH
63964: LD_VAR 0 2
63968: PUSH
63969: LD_INT 0
63971: PLUS
63972: PPUSH
63973: CALL_OW 1
63977: ST_TO_ADDR
// end ;
63978: LD_VAR 0 3
63982: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
63983: LD_INT 0
63985: PPUSH
// if not mc_bases [ base ] then
63986: LD_EXP 102
63990: PUSH
63991: LD_VAR 0 1
63995: ARRAY
63996: NOT
63997: IFFALSE 64001
// exit ;
63999: GO 64026
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
64001: LD_ADDR_EXP 113
64005: PUSH
64006: LD_EXP 113
64010: PPUSH
64011: LD_VAR 0 1
64015: PPUSH
64016: LD_VAR 0 2
64020: PPUSH
64021: CALL_OW 1
64025: ST_TO_ADDR
// end ;
64026: LD_VAR 0 3
64030: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
64031: LD_INT 0
64033: PPUSH
64034: PPUSH
64035: PPUSH
64036: PPUSH
// if not mc_bases [ base ] then
64037: LD_EXP 102
64041: PUSH
64042: LD_VAR 0 1
64046: ARRAY
64047: NOT
64048: IFFALSE 64052
// exit ;
64050: GO 64117
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
64052: LD_ADDR_EXP 122
64056: PUSH
64057: LD_EXP 122
64061: PPUSH
64062: LD_VAR 0 1
64066: PUSH
64067: LD_EXP 122
64071: PUSH
64072: LD_VAR 0 1
64076: ARRAY
64077: PUSH
64078: LD_INT 1
64080: PLUS
64081: PUSH
64082: EMPTY
64083: LIST
64084: LIST
64085: PPUSH
64086: LD_VAR 0 1
64090: PUSH
64091: LD_VAR 0 2
64095: PUSH
64096: LD_VAR 0 3
64100: PUSH
64101: LD_VAR 0 4
64105: PUSH
64106: EMPTY
64107: LIST
64108: LIST
64109: LIST
64110: LIST
64111: PPUSH
64112: CALL 75255 0 3
64116: ST_TO_ADDR
// end ;
64117: LD_VAR 0 5
64121: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
64122: LD_INT 0
64124: PPUSH
// if not mc_bases [ base ] then
64125: LD_EXP 102
64129: PUSH
64130: LD_VAR 0 1
64134: ARRAY
64135: NOT
64136: IFFALSE 64140
// exit ;
64138: GO 64165
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
64140: LD_ADDR_EXP 139
64144: PUSH
64145: LD_EXP 139
64149: PPUSH
64150: LD_VAR 0 1
64154: PPUSH
64155: LD_VAR 0 2
64159: PPUSH
64160: CALL_OW 1
64164: ST_TO_ADDR
// end ;
64165: LD_VAR 0 3
64169: RET
// export function MC_GetMinesField ( base ) ; begin
64170: LD_INT 0
64172: PPUSH
// result := mc_mines [ base ] ;
64173: LD_ADDR_VAR 0 2
64177: PUSH
64178: LD_EXP 115
64182: PUSH
64183: LD_VAR 0 1
64187: ARRAY
64188: ST_TO_ADDR
// end ;
64189: LD_VAR 0 2
64193: RET
// export function MC_GetProduceList ( base ) ; begin
64194: LD_INT 0
64196: PPUSH
// result := mc_produce [ base ] ;
64197: LD_ADDR_VAR 0 2
64201: PUSH
64202: LD_EXP 123
64206: PUSH
64207: LD_VAR 0 1
64211: ARRAY
64212: ST_TO_ADDR
// end ;
64213: LD_VAR 0 2
64217: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
64218: LD_INT 0
64220: PPUSH
64221: PPUSH
// if not mc_bases then
64222: LD_EXP 102
64226: NOT
64227: IFFALSE 64231
// exit ;
64229: GO 64296
// if mc_bases [ base ] then
64231: LD_EXP 102
64235: PUSH
64236: LD_VAR 0 1
64240: ARRAY
64241: IFFALSE 64296
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
64243: LD_ADDR_VAR 0 3
64247: PUSH
64248: LD_EXP 102
64252: PUSH
64253: LD_VAR 0 1
64257: ARRAY
64258: PPUSH
64259: LD_INT 30
64261: PUSH
64262: LD_VAR 0 2
64266: PUSH
64267: EMPTY
64268: LIST
64269: LIST
64270: PPUSH
64271: CALL_OW 72
64275: ST_TO_ADDR
// if result then
64276: LD_VAR 0 3
64280: IFFALSE 64296
// result := result [ 1 ] ;
64282: LD_ADDR_VAR 0 3
64286: PUSH
64287: LD_VAR 0 3
64291: PUSH
64292: LD_INT 1
64294: ARRAY
64295: ST_TO_ADDR
// end ; end ;
64296: LD_VAR 0 3
64300: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
64301: LD_INT 0
64303: PPUSH
64304: PPUSH
// if not mc_bases then
64305: LD_EXP 102
64309: NOT
64310: IFFALSE 64314
// exit ;
64312: GO 64359
// if mc_bases [ base ] then
64314: LD_EXP 102
64318: PUSH
64319: LD_VAR 0 1
64323: ARRAY
64324: IFFALSE 64359
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
64326: LD_ADDR_VAR 0 3
64330: PUSH
64331: LD_EXP 102
64335: PUSH
64336: LD_VAR 0 1
64340: ARRAY
64341: PPUSH
64342: LD_INT 30
64344: PUSH
64345: LD_VAR 0 2
64349: PUSH
64350: EMPTY
64351: LIST
64352: LIST
64353: PPUSH
64354: CALL_OW 72
64358: ST_TO_ADDR
// end ;
64359: LD_VAR 0 3
64363: RET
// export function MC_SetTame ( base , area ) ; begin
64364: LD_INT 0
64366: PPUSH
// if not mc_bases or not base then
64367: LD_EXP 102
64371: NOT
64372: PUSH
64373: LD_VAR 0 1
64377: NOT
64378: OR
64379: IFFALSE 64383
// exit ;
64381: GO 64408
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
64383: LD_ADDR_EXP 130
64387: PUSH
64388: LD_EXP 130
64392: PPUSH
64393: LD_VAR 0 1
64397: PPUSH
64398: LD_VAR 0 2
64402: PPUSH
64403: CALL_OW 1
64407: ST_TO_ADDR
// end ;
64408: LD_VAR 0 3
64412: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
64413: LD_INT 0
64415: PPUSH
64416: PPUSH
// if not mc_bases or not base then
64417: LD_EXP 102
64421: NOT
64422: PUSH
64423: LD_VAR 0 1
64427: NOT
64428: OR
64429: IFFALSE 64433
// exit ;
64431: GO 64535
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
64433: LD_ADDR_VAR 0 4
64437: PUSH
64438: LD_EXP 102
64442: PUSH
64443: LD_VAR 0 1
64447: ARRAY
64448: PPUSH
64449: LD_INT 30
64451: PUSH
64452: LD_VAR 0 2
64456: PUSH
64457: EMPTY
64458: LIST
64459: LIST
64460: PPUSH
64461: CALL_OW 72
64465: ST_TO_ADDR
// if not tmp then
64466: LD_VAR 0 4
64470: NOT
64471: IFFALSE 64475
// exit ;
64473: GO 64535
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
64475: LD_ADDR_EXP 134
64479: PUSH
64480: LD_EXP 134
64484: PPUSH
64485: LD_VAR 0 1
64489: PPUSH
64490: LD_EXP 134
64494: PUSH
64495: LD_VAR 0 1
64499: ARRAY
64500: PPUSH
64501: LD_EXP 134
64505: PUSH
64506: LD_VAR 0 1
64510: ARRAY
64511: PUSH
64512: LD_INT 1
64514: PLUS
64515: PPUSH
64516: LD_VAR 0 4
64520: PUSH
64521: LD_INT 1
64523: ARRAY
64524: PPUSH
64525: CALL_OW 2
64529: PPUSH
64530: CALL_OW 1
64534: ST_TO_ADDR
// end ;
64535: LD_VAR 0 3
64539: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
64540: LD_INT 0
64542: PPUSH
64543: PPUSH
// if not mc_bases or not base or not kinds then
64544: LD_EXP 102
64548: NOT
64549: PUSH
64550: LD_VAR 0 1
64554: NOT
64555: OR
64556: PUSH
64557: LD_VAR 0 2
64561: NOT
64562: OR
64563: IFFALSE 64567
// exit ;
64565: GO 64628
// for i in kinds do
64567: LD_ADDR_VAR 0 4
64571: PUSH
64572: LD_VAR 0 2
64576: PUSH
64577: FOR_IN
64578: IFFALSE 64626
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
64580: LD_ADDR_EXP 136
64584: PUSH
64585: LD_EXP 136
64589: PPUSH
64590: LD_VAR 0 1
64594: PUSH
64595: LD_EXP 136
64599: PUSH
64600: LD_VAR 0 1
64604: ARRAY
64605: PUSH
64606: LD_INT 1
64608: PLUS
64609: PUSH
64610: EMPTY
64611: LIST
64612: LIST
64613: PPUSH
64614: LD_VAR 0 4
64618: PPUSH
64619: CALL 75255 0 3
64623: ST_TO_ADDR
64624: GO 64577
64626: POP
64627: POP
// end ;
64628: LD_VAR 0 3
64632: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
64633: LD_INT 0
64635: PPUSH
// if not mc_bases or not base or not areas then
64636: LD_EXP 102
64640: NOT
64641: PUSH
64642: LD_VAR 0 1
64646: NOT
64647: OR
64648: PUSH
64649: LD_VAR 0 2
64653: NOT
64654: OR
64655: IFFALSE 64659
// exit ;
64657: GO 64684
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
64659: LD_ADDR_EXP 120
64663: PUSH
64664: LD_EXP 120
64668: PPUSH
64669: LD_VAR 0 1
64673: PPUSH
64674: LD_VAR 0 2
64678: PPUSH
64679: CALL_OW 1
64683: ST_TO_ADDR
// end ;
64684: LD_VAR 0 3
64688: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
64689: LD_INT 0
64691: PPUSH
// if not mc_bases or not base or not teleports_exit then
64692: LD_EXP 102
64696: NOT
64697: PUSH
64698: LD_VAR 0 1
64702: NOT
64703: OR
64704: PUSH
64705: LD_VAR 0 2
64709: NOT
64710: OR
64711: IFFALSE 64715
// exit ;
64713: GO 64740
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
64715: LD_ADDR_EXP 137
64719: PUSH
64720: LD_EXP 137
64724: PPUSH
64725: LD_VAR 0 1
64729: PPUSH
64730: LD_VAR 0 2
64734: PPUSH
64735: CALL_OW 1
64739: ST_TO_ADDR
// end ;
64740: LD_VAR 0 3
64744: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
64745: LD_INT 0
64747: PPUSH
64748: PPUSH
64749: PPUSH
// if not mc_bases or not base or not ext_list then
64750: LD_EXP 102
64754: NOT
64755: PUSH
64756: LD_VAR 0 1
64760: NOT
64761: OR
64762: PUSH
64763: LD_VAR 0 5
64767: NOT
64768: OR
64769: IFFALSE 64773
// exit ;
64771: GO 64946
// tmp := GetFacExtXYD ( x , y , d ) ;
64773: LD_ADDR_VAR 0 8
64777: PUSH
64778: LD_VAR 0 2
64782: PPUSH
64783: LD_VAR 0 3
64787: PPUSH
64788: LD_VAR 0 4
64792: PPUSH
64793: CALL 105638 0 3
64797: ST_TO_ADDR
// if not tmp then
64798: LD_VAR 0 8
64802: NOT
64803: IFFALSE 64807
// exit ;
64805: GO 64946
// for i in tmp do
64807: LD_ADDR_VAR 0 7
64811: PUSH
64812: LD_VAR 0 8
64816: PUSH
64817: FOR_IN
64818: IFFALSE 64944
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
64820: LD_ADDR_EXP 107
64824: PUSH
64825: LD_EXP 107
64829: PPUSH
64830: LD_VAR 0 1
64834: PPUSH
64835: LD_EXP 107
64839: PUSH
64840: LD_VAR 0 1
64844: ARRAY
64845: PPUSH
64846: LD_EXP 107
64850: PUSH
64851: LD_VAR 0 1
64855: ARRAY
64856: PUSH
64857: LD_INT 1
64859: PLUS
64860: PPUSH
64861: LD_VAR 0 5
64865: PUSH
64866: LD_INT 1
64868: ARRAY
64869: PUSH
64870: LD_VAR 0 7
64874: PUSH
64875: LD_INT 1
64877: ARRAY
64878: PUSH
64879: LD_VAR 0 7
64883: PUSH
64884: LD_INT 2
64886: ARRAY
64887: PUSH
64888: LD_VAR 0 7
64892: PUSH
64893: LD_INT 3
64895: ARRAY
64896: PUSH
64897: EMPTY
64898: LIST
64899: LIST
64900: LIST
64901: LIST
64902: PPUSH
64903: CALL_OW 2
64907: PPUSH
64908: CALL_OW 1
64912: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
64913: LD_ADDR_VAR 0 5
64917: PUSH
64918: LD_VAR 0 5
64922: PPUSH
64923: LD_INT 1
64925: PPUSH
64926: CALL_OW 3
64930: ST_TO_ADDR
// if not ext_list then
64931: LD_VAR 0 5
64935: NOT
64936: IFFALSE 64942
// exit ;
64938: POP
64939: POP
64940: GO 64946
// end ;
64942: GO 64817
64944: POP
64945: POP
// end ;
64946: LD_VAR 0 6
64950: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
64951: LD_INT 0
64953: PPUSH
// if not mc_bases or not base or not weapon_list then
64954: LD_EXP 102
64958: NOT
64959: PUSH
64960: LD_VAR 0 1
64964: NOT
64965: OR
64966: PUSH
64967: LD_VAR 0 2
64971: NOT
64972: OR
64973: IFFALSE 64977
// exit ;
64975: GO 65002
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
64977: LD_ADDR_EXP 141
64981: PUSH
64982: LD_EXP 141
64986: PPUSH
64987: LD_VAR 0 1
64991: PPUSH
64992: LD_VAR 0 2
64996: PPUSH
64997: CALL_OW 1
65001: ST_TO_ADDR
// end ;
65002: LD_VAR 0 3
65006: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
65007: LD_INT 0
65009: PPUSH
// if not mc_bases or not base or not tech_list then
65010: LD_EXP 102
65014: NOT
65015: PUSH
65016: LD_VAR 0 1
65020: NOT
65021: OR
65022: PUSH
65023: LD_VAR 0 2
65027: NOT
65028: OR
65029: IFFALSE 65033
// exit ;
65031: GO 65058
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
65033: LD_ADDR_EXP 129
65037: PUSH
65038: LD_EXP 129
65042: PPUSH
65043: LD_VAR 0 1
65047: PPUSH
65048: LD_VAR 0 2
65052: PPUSH
65053: CALL_OW 1
65057: ST_TO_ADDR
// end ;
65058: LD_VAR 0 3
65062: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
65063: LD_INT 0
65065: PPUSH
// if not mc_bases or not parking_area or not base then
65066: LD_EXP 102
65070: NOT
65071: PUSH
65072: LD_VAR 0 2
65076: NOT
65077: OR
65078: PUSH
65079: LD_VAR 0 1
65083: NOT
65084: OR
65085: IFFALSE 65089
// exit ;
65087: GO 65114
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
65089: LD_ADDR_EXP 126
65093: PUSH
65094: LD_EXP 126
65098: PPUSH
65099: LD_VAR 0 1
65103: PPUSH
65104: LD_VAR 0 2
65108: PPUSH
65109: CALL_OW 1
65113: ST_TO_ADDR
// end ;
65114: LD_VAR 0 3
65118: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
65119: LD_INT 0
65121: PPUSH
// if not mc_bases or not base or not scan_area then
65122: LD_EXP 102
65126: NOT
65127: PUSH
65128: LD_VAR 0 1
65132: NOT
65133: OR
65134: PUSH
65135: LD_VAR 0 2
65139: NOT
65140: OR
65141: IFFALSE 65145
// exit ;
65143: GO 65170
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
65145: LD_ADDR_EXP 127
65149: PUSH
65150: LD_EXP 127
65154: PPUSH
65155: LD_VAR 0 1
65159: PPUSH
65160: LD_VAR 0 2
65164: PPUSH
65165: CALL_OW 1
65169: ST_TO_ADDR
// end ;
65170: LD_VAR 0 3
65174: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
65175: LD_INT 0
65177: PPUSH
65178: PPUSH
// if not mc_bases or not base then
65179: LD_EXP 102
65183: NOT
65184: PUSH
65185: LD_VAR 0 1
65189: NOT
65190: OR
65191: IFFALSE 65195
// exit ;
65193: GO 65259
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
65195: LD_ADDR_VAR 0 3
65199: PUSH
65200: LD_INT 1
65202: PUSH
65203: LD_INT 2
65205: PUSH
65206: LD_INT 3
65208: PUSH
65209: LD_INT 4
65211: PUSH
65212: LD_INT 11
65214: PUSH
65215: EMPTY
65216: LIST
65217: LIST
65218: LIST
65219: LIST
65220: LIST
65221: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
65222: LD_ADDR_EXP 129
65226: PUSH
65227: LD_EXP 129
65231: PPUSH
65232: LD_VAR 0 1
65236: PPUSH
65237: LD_EXP 129
65241: PUSH
65242: LD_VAR 0 1
65246: ARRAY
65247: PUSH
65248: LD_VAR 0 3
65252: DIFF
65253: PPUSH
65254: CALL_OW 1
65258: ST_TO_ADDR
// end ;
65259: LD_VAR 0 2
65263: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
65264: LD_INT 0
65266: PPUSH
// result := mc_vehicles [ base ] ;
65267: LD_ADDR_VAR 0 3
65271: PUSH
65272: LD_EXP 121
65276: PUSH
65277: LD_VAR 0 1
65281: ARRAY
65282: ST_TO_ADDR
// if onlyCombat then
65283: LD_VAR 0 2
65287: IFFALSE 65459
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
65289: LD_ADDR_VAR 0 3
65293: PUSH
65294: LD_VAR 0 3
65298: PUSH
65299: LD_VAR 0 3
65303: PPUSH
65304: LD_INT 2
65306: PUSH
65307: LD_INT 34
65309: PUSH
65310: LD_INT 12
65312: PUSH
65313: EMPTY
65314: LIST
65315: LIST
65316: PUSH
65317: LD_INT 34
65319: PUSH
65320: LD_INT 51
65322: PUSH
65323: EMPTY
65324: LIST
65325: LIST
65326: PUSH
65327: LD_INT 34
65329: PUSH
65330: LD_INT 89
65332: PUSH
65333: EMPTY
65334: LIST
65335: LIST
65336: PUSH
65337: LD_INT 34
65339: PUSH
65340: LD_INT 32
65342: PUSH
65343: EMPTY
65344: LIST
65345: LIST
65346: PUSH
65347: LD_INT 34
65349: PUSH
65350: LD_INT 13
65352: PUSH
65353: EMPTY
65354: LIST
65355: LIST
65356: PUSH
65357: LD_INT 34
65359: PUSH
65360: LD_INT 52
65362: PUSH
65363: EMPTY
65364: LIST
65365: LIST
65366: PUSH
65367: LD_INT 34
65369: PUSH
65370: LD_INT 88
65372: PUSH
65373: EMPTY
65374: LIST
65375: LIST
65376: PUSH
65377: LD_INT 34
65379: PUSH
65380: LD_INT 14
65382: PUSH
65383: EMPTY
65384: LIST
65385: LIST
65386: PUSH
65387: LD_INT 34
65389: PUSH
65390: LD_INT 53
65392: PUSH
65393: EMPTY
65394: LIST
65395: LIST
65396: PUSH
65397: LD_INT 34
65399: PUSH
65400: LD_INT 98
65402: PUSH
65403: EMPTY
65404: LIST
65405: LIST
65406: PUSH
65407: LD_INT 34
65409: PUSH
65410: LD_INT 31
65412: PUSH
65413: EMPTY
65414: LIST
65415: LIST
65416: PUSH
65417: LD_INT 34
65419: PUSH
65420: LD_INT 48
65422: PUSH
65423: EMPTY
65424: LIST
65425: LIST
65426: PUSH
65427: LD_INT 34
65429: PUSH
65430: LD_INT 8
65432: PUSH
65433: EMPTY
65434: LIST
65435: LIST
65436: PUSH
65437: EMPTY
65438: LIST
65439: LIST
65440: LIST
65441: LIST
65442: LIST
65443: LIST
65444: LIST
65445: LIST
65446: LIST
65447: LIST
65448: LIST
65449: LIST
65450: LIST
65451: LIST
65452: PPUSH
65453: CALL_OW 72
65457: DIFF
65458: ST_TO_ADDR
// end ; end_of_file
65459: LD_VAR 0 3
65463: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
65464: LD_INT 0
65466: PPUSH
65467: PPUSH
65468: PPUSH
// if not mc_bases or not skirmish then
65469: LD_EXP 102
65473: NOT
65474: PUSH
65475: LD_EXP 100
65479: NOT
65480: OR
65481: IFFALSE 65485
// exit ;
65483: GO 65650
// for i = 1 to mc_bases do
65485: LD_ADDR_VAR 0 4
65489: PUSH
65490: DOUBLE
65491: LD_INT 1
65493: DEC
65494: ST_TO_ADDR
65495: LD_EXP 102
65499: PUSH
65500: FOR_TO
65501: IFFALSE 65648
// begin if sci in mc_bases [ i ] then
65503: LD_VAR 0 2
65507: PUSH
65508: LD_EXP 102
65512: PUSH
65513: LD_VAR 0 4
65517: ARRAY
65518: IN
65519: IFFALSE 65646
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
65521: LD_ADDR_EXP 131
65525: PUSH
65526: LD_EXP 131
65530: PPUSH
65531: LD_VAR 0 4
65535: PUSH
65536: LD_EXP 131
65540: PUSH
65541: LD_VAR 0 4
65545: ARRAY
65546: PUSH
65547: LD_INT 1
65549: PLUS
65550: PUSH
65551: EMPTY
65552: LIST
65553: LIST
65554: PPUSH
65555: LD_VAR 0 1
65559: PPUSH
65560: CALL 75255 0 3
65564: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
65565: LD_ADDR_VAR 0 5
65569: PUSH
65570: LD_EXP 102
65574: PUSH
65575: LD_VAR 0 4
65579: ARRAY
65580: PPUSH
65581: LD_INT 2
65583: PUSH
65584: LD_INT 30
65586: PUSH
65587: LD_INT 0
65589: PUSH
65590: EMPTY
65591: LIST
65592: LIST
65593: PUSH
65594: LD_INT 30
65596: PUSH
65597: LD_INT 1
65599: PUSH
65600: EMPTY
65601: LIST
65602: LIST
65603: PUSH
65604: EMPTY
65605: LIST
65606: LIST
65607: LIST
65608: PPUSH
65609: CALL_OW 72
65613: PPUSH
65614: LD_VAR 0 1
65618: PPUSH
65619: CALL_OW 74
65623: ST_TO_ADDR
// if tmp then
65624: LD_VAR 0 5
65628: IFFALSE 65644
// ComStandNearbyBuilding ( ape , tmp ) ;
65630: LD_VAR 0 1
65634: PPUSH
65635: LD_VAR 0 5
65639: PPUSH
65640: CALL 71857 0 2
// break ;
65644: GO 65648
// end ; end ;
65646: GO 65500
65648: POP
65649: POP
// end ;
65650: LD_VAR 0 3
65654: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
65655: LD_INT 0
65657: PPUSH
65658: PPUSH
65659: PPUSH
// if not mc_bases or not skirmish then
65660: LD_EXP 102
65664: NOT
65665: PUSH
65666: LD_EXP 100
65670: NOT
65671: OR
65672: IFFALSE 65676
// exit ;
65674: GO 65765
// for i = 1 to mc_bases do
65676: LD_ADDR_VAR 0 4
65680: PUSH
65681: DOUBLE
65682: LD_INT 1
65684: DEC
65685: ST_TO_ADDR
65686: LD_EXP 102
65690: PUSH
65691: FOR_TO
65692: IFFALSE 65763
// begin if building in mc_busy_turret_list [ i ] then
65694: LD_VAR 0 1
65698: PUSH
65699: LD_EXP 112
65703: PUSH
65704: LD_VAR 0 4
65708: ARRAY
65709: IN
65710: IFFALSE 65761
// begin tmp := mc_busy_turret_list [ i ] diff building ;
65712: LD_ADDR_VAR 0 5
65716: PUSH
65717: LD_EXP 112
65721: PUSH
65722: LD_VAR 0 4
65726: ARRAY
65727: PUSH
65728: LD_VAR 0 1
65732: DIFF
65733: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
65734: LD_ADDR_EXP 112
65738: PUSH
65739: LD_EXP 112
65743: PPUSH
65744: LD_VAR 0 4
65748: PPUSH
65749: LD_VAR 0 5
65753: PPUSH
65754: CALL_OW 1
65758: ST_TO_ADDR
// break ;
65759: GO 65763
// end ; end ;
65761: GO 65691
65763: POP
65764: POP
// end ;
65765: LD_VAR 0 3
65769: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
65770: LD_INT 0
65772: PPUSH
65773: PPUSH
65774: PPUSH
// if not mc_bases or not skirmish then
65775: LD_EXP 102
65779: NOT
65780: PUSH
65781: LD_EXP 100
65785: NOT
65786: OR
65787: IFFALSE 65791
// exit ;
65789: GO 65990
// for i = 1 to mc_bases do
65791: LD_ADDR_VAR 0 5
65795: PUSH
65796: DOUBLE
65797: LD_INT 1
65799: DEC
65800: ST_TO_ADDR
65801: LD_EXP 102
65805: PUSH
65806: FOR_TO
65807: IFFALSE 65988
// if building in mc_bases [ i ] then
65809: LD_VAR 0 1
65813: PUSH
65814: LD_EXP 102
65818: PUSH
65819: LD_VAR 0 5
65823: ARRAY
65824: IN
65825: IFFALSE 65986
// begin tmp := mc_bases [ i ] diff building ;
65827: LD_ADDR_VAR 0 6
65831: PUSH
65832: LD_EXP 102
65836: PUSH
65837: LD_VAR 0 5
65841: ARRAY
65842: PUSH
65843: LD_VAR 0 1
65847: DIFF
65848: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
65849: LD_ADDR_EXP 102
65853: PUSH
65854: LD_EXP 102
65858: PPUSH
65859: LD_VAR 0 5
65863: PPUSH
65864: LD_VAR 0 6
65868: PPUSH
65869: CALL_OW 1
65873: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
65874: LD_VAR 0 1
65878: PUSH
65879: LD_EXP 110
65883: PUSH
65884: LD_VAR 0 5
65888: ARRAY
65889: IN
65890: IFFALSE 65929
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
65892: LD_ADDR_EXP 110
65896: PUSH
65897: LD_EXP 110
65901: PPUSH
65902: LD_VAR 0 5
65906: PPUSH
65907: LD_EXP 110
65911: PUSH
65912: LD_VAR 0 5
65916: ARRAY
65917: PUSH
65918: LD_VAR 0 1
65922: DIFF
65923: PPUSH
65924: CALL_OW 1
65928: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
65929: LD_VAR 0 1
65933: PUSH
65934: LD_EXP 111
65938: PUSH
65939: LD_VAR 0 5
65943: ARRAY
65944: IN
65945: IFFALSE 65984
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
65947: LD_ADDR_EXP 111
65951: PUSH
65952: LD_EXP 111
65956: PPUSH
65957: LD_VAR 0 5
65961: PPUSH
65962: LD_EXP 111
65966: PUSH
65967: LD_VAR 0 5
65971: ARRAY
65972: PUSH
65973: LD_VAR 0 1
65977: DIFF
65978: PPUSH
65979: CALL_OW 1
65983: ST_TO_ADDR
// break ;
65984: GO 65988
// end ;
65986: GO 65806
65988: POP
65989: POP
// end ;
65990: LD_VAR 0 4
65994: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
65995: LD_INT 0
65997: PPUSH
65998: PPUSH
65999: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
66000: LD_EXP 102
66004: NOT
66005: PUSH
66006: LD_EXP 100
66010: NOT
66011: OR
66012: PUSH
66013: LD_VAR 0 3
66017: PUSH
66018: LD_EXP 128
66022: IN
66023: NOT
66024: OR
66025: IFFALSE 66029
// exit ;
66027: GO 66152
// for i = 1 to mc_vehicles do
66029: LD_ADDR_VAR 0 6
66033: PUSH
66034: DOUBLE
66035: LD_INT 1
66037: DEC
66038: ST_TO_ADDR
66039: LD_EXP 121
66043: PUSH
66044: FOR_TO
66045: IFFALSE 66150
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
66047: LD_VAR 0 2
66051: PUSH
66052: LD_EXP 121
66056: PUSH
66057: LD_VAR 0 6
66061: ARRAY
66062: IN
66063: PUSH
66064: LD_VAR 0 1
66068: PUSH
66069: LD_EXP 121
66073: PUSH
66074: LD_VAR 0 6
66078: ARRAY
66079: IN
66080: OR
66081: IFFALSE 66148
// begin tmp := mc_vehicles [ i ] diff old ;
66083: LD_ADDR_VAR 0 7
66087: PUSH
66088: LD_EXP 121
66092: PUSH
66093: LD_VAR 0 6
66097: ARRAY
66098: PUSH
66099: LD_VAR 0 2
66103: DIFF
66104: ST_TO_ADDR
// tmp := tmp diff new ;
66105: LD_ADDR_VAR 0 7
66109: PUSH
66110: LD_VAR 0 7
66114: PUSH
66115: LD_VAR 0 1
66119: DIFF
66120: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
66121: LD_ADDR_EXP 121
66125: PUSH
66126: LD_EXP 121
66130: PPUSH
66131: LD_VAR 0 6
66135: PPUSH
66136: LD_VAR 0 7
66140: PPUSH
66141: CALL_OW 1
66145: ST_TO_ADDR
// break ;
66146: GO 66150
// end ;
66148: GO 66044
66150: POP
66151: POP
// end ;
66152: LD_VAR 0 5
66156: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
66157: LD_INT 0
66159: PPUSH
66160: PPUSH
66161: PPUSH
66162: PPUSH
// if not mc_bases or not skirmish then
66163: LD_EXP 102
66167: NOT
66168: PUSH
66169: LD_EXP 100
66173: NOT
66174: OR
66175: IFFALSE 66179
// exit ;
66177: GO 66599
// repeat wait ( 0 0$1 ) ;
66179: LD_INT 35
66181: PPUSH
66182: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
66186: LD_EXP 146
66190: NOT
66191: IFFALSE 66179
// mc_block_vehicle_constructed_thread := true ;
66193: LD_ADDR_EXP 146
66197: PUSH
66198: LD_INT 1
66200: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
66201: LD_ADDR_VAR 0 5
66205: PUSH
66206: LD_VAR 0 1
66210: PPUSH
66211: CALL_OW 255
66215: ST_TO_ADDR
// for i = 1 to mc_bases do
66216: LD_ADDR_VAR 0 4
66220: PUSH
66221: DOUBLE
66222: LD_INT 1
66224: DEC
66225: ST_TO_ADDR
66226: LD_EXP 102
66230: PUSH
66231: FOR_TO
66232: IFFALSE 66589
// begin if factory in mc_bases [ i ] then
66234: LD_VAR 0 2
66238: PUSH
66239: LD_EXP 102
66243: PUSH
66244: LD_VAR 0 4
66248: ARRAY
66249: IN
66250: IFFALSE 66587
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
66252: LD_EXP 124
66256: PUSH
66257: LD_VAR 0 4
66261: ARRAY
66262: PUSH
66263: LD_EXP 113
66267: PUSH
66268: LD_VAR 0 4
66272: ARRAY
66273: LESS
66274: PUSH
66275: LD_VAR 0 1
66279: PPUSH
66280: CALL_OW 264
66284: PUSH
66285: LD_INT 31
66287: PUSH
66288: LD_INT 32
66290: PUSH
66291: LD_INT 51
66293: PUSH
66294: LD_INT 89
66296: PUSH
66297: LD_INT 12
66299: PUSH
66300: LD_INT 30
66302: PUSH
66303: LD_INT 98
66305: PUSH
66306: LD_INT 11
66308: PUSH
66309: LD_INT 53
66311: PUSH
66312: LD_INT 14
66314: PUSH
66315: LD_INT 91
66317: PUSH
66318: LD_INT 29
66320: PUSH
66321: LD_INT 99
66323: PUSH
66324: LD_INT 13
66326: PUSH
66327: LD_INT 52
66329: PUSH
66330: LD_INT 88
66332: PUSH
66333: LD_INT 48
66335: PUSH
66336: LD_INT 8
66338: PUSH
66339: EMPTY
66340: LIST
66341: LIST
66342: LIST
66343: LIST
66344: LIST
66345: LIST
66346: LIST
66347: LIST
66348: LIST
66349: LIST
66350: LIST
66351: LIST
66352: LIST
66353: LIST
66354: LIST
66355: LIST
66356: LIST
66357: LIST
66358: IN
66359: NOT
66360: AND
66361: IFFALSE 66409
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
66363: LD_ADDR_EXP 124
66367: PUSH
66368: LD_EXP 124
66372: PPUSH
66373: LD_VAR 0 4
66377: PUSH
66378: LD_EXP 124
66382: PUSH
66383: LD_VAR 0 4
66387: ARRAY
66388: PUSH
66389: LD_INT 1
66391: PLUS
66392: PUSH
66393: EMPTY
66394: LIST
66395: LIST
66396: PPUSH
66397: LD_VAR 0 1
66401: PPUSH
66402: CALL 75255 0 3
66406: ST_TO_ADDR
66407: GO 66453
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
66409: LD_ADDR_EXP 121
66413: PUSH
66414: LD_EXP 121
66418: PPUSH
66419: LD_VAR 0 4
66423: PUSH
66424: LD_EXP 121
66428: PUSH
66429: LD_VAR 0 4
66433: ARRAY
66434: PUSH
66435: LD_INT 1
66437: PLUS
66438: PUSH
66439: EMPTY
66440: LIST
66441: LIST
66442: PPUSH
66443: LD_VAR 0 1
66447: PPUSH
66448: CALL 75255 0 3
66452: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
66453: LD_ADDR_EXP 146
66457: PUSH
66458: LD_INT 0
66460: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
66461: LD_VAR 0 1
66465: PPUSH
66466: CALL_OW 263
66470: PUSH
66471: LD_INT 2
66473: EQUAL
66474: IFFALSE 66503
// begin repeat wait ( 0 0$3 ) ;
66476: LD_INT 105
66478: PPUSH
66479: CALL_OW 67
// Connect ( vehicle ) ;
66483: LD_VAR 0 1
66487: PPUSH
66488: CALL 78601 0 1
// until IsControledBy ( vehicle ) ;
66492: LD_VAR 0 1
66496: PPUSH
66497: CALL_OW 312
66501: IFFALSE 66476
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
66503: LD_VAR 0 1
66507: PPUSH
66508: LD_EXP 126
66512: PUSH
66513: LD_VAR 0 4
66517: ARRAY
66518: PPUSH
66519: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
66523: LD_VAR 0 1
66527: PPUSH
66528: CALL_OW 263
66532: PUSH
66533: LD_INT 1
66535: NONEQUAL
66536: IFFALSE 66540
// break ;
66538: GO 66589
// repeat wait ( 0 0$1 ) ;
66540: LD_INT 35
66542: PPUSH
66543: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
66547: LD_VAR 0 1
66551: PPUSH
66552: LD_EXP 126
66556: PUSH
66557: LD_VAR 0 4
66561: ARRAY
66562: PPUSH
66563: CALL_OW 308
66567: IFFALSE 66540
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
66569: LD_VAR 0 1
66573: PPUSH
66574: CALL_OW 311
66578: PPUSH
66579: CALL_OW 121
// exit ;
66583: POP
66584: POP
66585: GO 66599
// end ; end ;
66587: GO 66231
66589: POP
66590: POP
// mc_block_vehicle_constructed_thread := false ;
66591: LD_ADDR_EXP 146
66595: PUSH
66596: LD_INT 0
66598: ST_TO_ADDR
// end ;
66599: LD_VAR 0 3
66603: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
66604: LD_INT 0
66606: PPUSH
66607: PPUSH
66608: PPUSH
66609: PPUSH
// if not mc_bases or not skirmish then
66610: LD_EXP 102
66614: NOT
66615: PUSH
66616: LD_EXP 100
66620: NOT
66621: OR
66622: IFFALSE 66626
// exit ;
66624: GO 66979
// repeat wait ( 0 0$1 ) ;
66626: LD_INT 35
66628: PPUSH
66629: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
66633: LD_VAR 0 2
66637: PPUSH
66638: LD_VAR 0 3
66642: PPUSH
66643: CALL_OW 284
66647: IFFALSE 66626
// if GetResourceTypeXY ( x , y ) = mat_artefact then
66649: LD_VAR 0 2
66653: PPUSH
66654: LD_VAR 0 3
66658: PPUSH
66659: CALL_OW 283
66663: PUSH
66664: LD_INT 4
66666: EQUAL
66667: IFFALSE 66671
// exit ;
66669: GO 66979
// for i = 1 to mc_bases do
66671: LD_ADDR_VAR 0 7
66675: PUSH
66676: DOUBLE
66677: LD_INT 1
66679: DEC
66680: ST_TO_ADDR
66681: LD_EXP 102
66685: PUSH
66686: FOR_TO
66687: IFFALSE 66977
// begin if mc_crates_area [ i ] then
66689: LD_EXP 120
66693: PUSH
66694: LD_VAR 0 7
66698: ARRAY
66699: IFFALSE 66810
// for j in mc_crates_area [ i ] do
66701: LD_ADDR_VAR 0 8
66705: PUSH
66706: LD_EXP 120
66710: PUSH
66711: LD_VAR 0 7
66715: ARRAY
66716: PUSH
66717: FOR_IN
66718: IFFALSE 66808
// if InArea ( x , y , j ) then
66720: LD_VAR 0 2
66724: PPUSH
66725: LD_VAR 0 3
66729: PPUSH
66730: LD_VAR 0 8
66734: PPUSH
66735: CALL_OW 309
66739: IFFALSE 66806
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
66741: LD_ADDR_EXP 118
66745: PUSH
66746: LD_EXP 118
66750: PPUSH
66751: LD_VAR 0 7
66755: PUSH
66756: LD_EXP 118
66760: PUSH
66761: LD_VAR 0 7
66765: ARRAY
66766: PUSH
66767: LD_INT 1
66769: PLUS
66770: PUSH
66771: EMPTY
66772: LIST
66773: LIST
66774: PPUSH
66775: LD_VAR 0 4
66779: PUSH
66780: LD_VAR 0 2
66784: PUSH
66785: LD_VAR 0 3
66789: PUSH
66790: EMPTY
66791: LIST
66792: LIST
66793: LIST
66794: PPUSH
66795: CALL 75255 0 3
66799: ST_TO_ADDR
// exit ;
66800: POP
66801: POP
66802: POP
66803: POP
66804: GO 66979
// end ;
66806: GO 66717
66808: POP
66809: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66810: LD_ADDR_VAR 0 9
66814: PUSH
66815: LD_EXP 102
66819: PUSH
66820: LD_VAR 0 7
66824: ARRAY
66825: PPUSH
66826: LD_INT 2
66828: PUSH
66829: LD_INT 30
66831: PUSH
66832: LD_INT 0
66834: PUSH
66835: EMPTY
66836: LIST
66837: LIST
66838: PUSH
66839: LD_INT 30
66841: PUSH
66842: LD_INT 1
66844: PUSH
66845: EMPTY
66846: LIST
66847: LIST
66848: PUSH
66849: EMPTY
66850: LIST
66851: LIST
66852: LIST
66853: PPUSH
66854: CALL_OW 72
66858: ST_TO_ADDR
// if not depot then
66859: LD_VAR 0 9
66863: NOT
66864: IFFALSE 66868
// continue ;
66866: GO 66686
// for j in depot do
66868: LD_ADDR_VAR 0 8
66872: PUSH
66873: LD_VAR 0 9
66877: PUSH
66878: FOR_IN
66879: IFFALSE 66973
// if GetDistUnitXY ( j , x , y ) < 30 then
66881: LD_VAR 0 8
66885: PPUSH
66886: LD_VAR 0 2
66890: PPUSH
66891: LD_VAR 0 3
66895: PPUSH
66896: CALL_OW 297
66900: PUSH
66901: LD_INT 30
66903: LESS
66904: IFFALSE 66971
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
66906: LD_ADDR_EXP 118
66910: PUSH
66911: LD_EXP 118
66915: PPUSH
66916: LD_VAR 0 7
66920: PUSH
66921: LD_EXP 118
66925: PUSH
66926: LD_VAR 0 7
66930: ARRAY
66931: PUSH
66932: LD_INT 1
66934: PLUS
66935: PUSH
66936: EMPTY
66937: LIST
66938: LIST
66939: PPUSH
66940: LD_VAR 0 4
66944: PUSH
66945: LD_VAR 0 2
66949: PUSH
66950: LD_VAR 0 3
66954: PUSH
66955: EMPTY
66956: LIST
66957: LIST
66958: LIST
66959: PPUSH
66960: CALL 75255 0 3
66964: ST_TO_ADDR
// exit ;
66965: POP
66966: POP
66967: POP
66968: POP
66969: GO 66979
// end ;
66971: GO 66878
66973: POP
66974: POP
// end ;
66975: GO 66686
66977: POP
66978: POP
// end ;
66979: LD_VAR 0 6
66983: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
66984: LD_INT 0
66986: PPUSH
66987: PPUSH
66988: PPUSH
66989: PPUSH
// if not mc_bases or not skirmish then
66990: LD_EXP 102
66994: NOT
66995: PUSH
66996: LD_EXP 100
67000: NOT
67001: OR
67002: IFFALSE 67006
// exit ;
67004: GO 67283
// side := GetSide ( lab ) ;
67006: LD_ADDR_VAR 0 4
67010: PUSH
67011: LD_VAR 0 2
67015: PPUSH
67016: CALL_OW 255
67020: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
67021: LD_VAR 0 4
67025: PUSH
67026: LD_EXP 128
67030: IN
67031: NOT
67032: PUSH
67033: LD_EXP 129
67037: NOT
67038: OR
67039: PUSH
67040: LD_EXP 102
67044: NOT
67045: OR
67046: IFFALSE 67050
// exit ;
67048: GO 67283
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
67050: LD_ADDR_EXP 129
67054: PUSH
67055: LD_EXP 129
67059: PPUSH
67060: LD_VAR 0 4
67064: PPUSH
67065: LD_EXP 129
67069: PUSH
67070: LD_VAR 0 4
67074: ARRAY
67075: PUSH
67076: LD_VAR 0 1
67080: DIFF
67081: PPUSH
67082: CALL_OW 1
67086: ST_TO_ADDR
// for i = 1 to mc_bases do
67087: LD_ADDR_VAR 0 5
67091: PUSH
67092: DOUBLE
67093: LD_INT 1
67095: DEC
67096: ST_TO_ADDR
67097: LD_EXP 102
67101: PUSH
67102: FOR_TO
67103: IFFALSE 67281
// begin if lab in mc_bases [ i ] then
67105: LD_VAR 0 2
67109: PUSH
67110: LD_EXP 102
67114: PUSH
67115: LD_VAR 0 5
67119: ARRAY
67120: IN
67121: IFFALSE 67279
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
67123: LD_VAR 0 1
67127: PUSH
67128: LD_INT 11
67130: PUSH
67131: LD_INT 4
67133: PUSH
67134: LD_INT 3
67136: PUSH
67137: LD_INT 2
67139: PUSH
67140: EMPTY
67141: LIST
67142: LIST
67143: LIST
67144: LIST
67145: IN
67146: PUSH
67147: LD_EXP 132
67151: PUSH
67152: LD_VAR 0 5
67156: ARRAY
67157: AND
67158: IFFALSE 67279
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
67160: LD_ADDR_VAR 0 6
67164: PUSH
67165: LD_EXP 132
67169: PUSH
67170: LD_VAR 0 5
67174: ARRAY
67175: PUSH
67176: LD_INT 1
67178: ARRAY
67179: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
67180: LD_ADDR_EXP 132
67184: PUSH
67185: LD_EXP 132
67189: PPUSH
67190: LD_VAR 0 5
67194: PPUSH
67195: EMPTY
67196: PPUSH
67197: CALL_OW 1
67201: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
67202: LD_VAR 0 6
67206: PPUSH
67207: LD_INT 0
67209: PPUSH
67210: CALL_OW 109
// ComExitBuilding ( tmp ) ;
67214: LD_VAR 0 6
67218: PPUSH
67219: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
67223: LD_ADDR_EXP 131
67227: PUSH
67228: LD_EXP 131
67232: PPUSH
67233: LD_VAR 0 5
67237: PPUSH
67238: LD_EXP 131
67242: PUSH
67243: LD_VAR 0 5
67247: ARRAY
67248: PPUSH
67249: LD_INT 1
67251: PPUSH
67252: LD_VAR 0 6
67256: PPUSH
67257: CALL_OW 2
67261: PPUSH
67262: CALL_OW 1
67266: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
67267: LD_VAR 0 5
67271: PPUSH
67272: LD_INT 112
67274: PPUSH
67275: CALL 43733 0 2
// end ; end ; end ;
67279: GO 67102
67281: POP
67282: POP
// end ;
67283: LD_VAR 0 3
67287: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
67288: LD_INT 0
67290: PPUSH
67291: PPUSH
67292: PPUSH
67293: PPUSH
67294: PPUSH
67295: PPUSH
67296: PPUSH
67297: PPUSH
// if not mc_bases or not skirmish then
67298: LD_EXP 102
67302: NOT
67303: PUSH
67304: LD_EXP 100
67308: NOT
67309: OR
67310: IFFALSE 67314
// exit ;
67312: GO 68683
// for i = 1 to mc_bases do
67314: LD_ADDR_VAR 0 3
67318: PUSH
67319: DOUBLE
67320: LD_INT 1
67322: DEC
67323: ST_TO_ADDR
67324: LD_EXP 102
67328: PUSH
67329: FOR_TO
67330: IFFALSE 68681
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
67332: LD_VAR 0 1
67336: PUSH
67337: LD_EXP 102
67341: PUSH
67342: LD_VAR 0 3
67346: ARRAY
67347: IN
67348: PUSH
67349: LD_VAR 0 1
67353: PUSH
67354: LD_EXP 109
67358: PUSH
67359: LD_VAR 0 3
67363: ARRAY
67364: IN
67365: OR
67366: PUSH
67367: LD_VAR 0 1
67371: PUSH
67372: LD_EXP 124
67376: PUSH
67377: LD_VAR 0 3
67381: ARRAY
67382: IN
67383: OR
67384: PUSH
67385: LD_VAR 0 1
67389: PUSH
67390: LD_EXP 121
67394: PUSH
67395: LD_VAR 0 3
67399: ARRAY
67400: IN
67401: OR
67402: PUSH
67403: LD_VAR 0 1
67407: PUSH
67408: LD_EXP 131
67412: PUSH
67413: LD_VAR 0 3
67417: ARRAY
67418: IN
67419: OR
67420: PUSH
67421: LD_VAR 0 1
67425: PUSH
67426: LD_EXP 132
67430: PUSH
67431: LD_VAR 0 3
67435: ARRAY
67436: IN
67437: OR
67438: IFFALSE 68679
// begin if un in mc_ape [ i ] then
67440: LD_VAR 0 1
67444: PUSH
67445: LD_EXP 131
67449: PUSH
67450: LD_VAR 0 3
67454: ARRAY
67455: IN
67456: IFFALSE 67495
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
67458: LD_ADDR_EXP 131
67462: PUSH
67463: LD_EXP 131
67467: PPUSH
67468: LD_VAR 0 3
67472: PPUSH
67473: LD_EXP 131
67477: PUSH
67478: LD_VAR 0 3
67482: ARRAY
67483: PUSH
67484: LD_VAR 0 1
67488: DIFF
67489: PPUSH
67490: CALL_OW 1
67494: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
67495: LD_VAR 0 1
67499: PUSH
67500: LD_EXP 132
67504: PUSH
67505: LD_VAR 0 3
67509: ARRAY
67510: IN
67511: IFFALSE 67535
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
67513: LD_ADDR_EXP 132
67517: PUSH
67518: LD_EXP 132
67522: PPUSH
67523: LD_VAR 0 3
67527: PPUSH
67528: EMPTY
67529: PPUSH
67530: CALL_OW 1
67534: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
67535: LD_VAR 0 1
67539: PPUSH
67540: CALL_OW 247
67544: PUSH
67545: LD_INT 2
67547: EQUAL
67548: PUSH
67549: LD_VAR 0 1
67553: PPUSH
67554: CALL_OW 110
67558: PUSH
67559: LD_INT 20
67561: EQUAL
67562: PUSH
67563: LD_VAR 0 1
67567: PUSH
67568: LD_EXP 124
67572: PUSH
67573: LD_VAR 0 3
67577: ARRAY
67578: IN
67579: OR
67580: PUSH
67581: LD_VAR 0 1
67585: PPUSH
67586: CALL_OW 264
67590: PUSH
67591: LD_INT 12
67593: PUSH
67594: LD_INT 51
67596: PUSH
67597: LD_INT 89
67599: PUSH
67600: LD_INT 32
67602: PUSH
67603: LD_INT 13
67605: PUSH
67606: LD_INT 52
67608: PUSH
67609: LD_INT 31
67611: PUSH
67612: EMPTY
67613: LIST
67614: LIST
67615: LIST
67616: LIST
67617: LIST
67618: LIST
67619: LIST
67620: IN
67621: OR
67622: AND
67623: IFFALSE 67931
// begin if un in mc_defender [ i ] then
67625: LD_VAR 0 1
67629: PUSH
67630: LD_EXP 124
67634: PUSH
67635: LD_VAR 0 3
67639: ARRAY
67640: IN
67641: IFFALSE 67680
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
67643: LD_ADDR_EXP 124
67647: PUSH
67648: LD_EXP 124
67652: PPUSH
67653: LD_VAR 0 3
67657: PPUSH
67658: LD_EXP 124
67662: PUSH
67663: LD_VAR 0 3
67667: ARRAY
67668: PUSH
67669: LD_VAR 0 1
67673: DIFF
67674: PPUSH
67675: CALL_OW 1
67679: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
67680: LD_ADDR_VAR 0 8
67684: PUSH
67685: LD_VAR 0 3
67689: PPUSH
67690: LD_INT 3
67692: PPUSH
67693: CALL 64301 0 2
67697: ST_TO_ADDR
// if fac then
67698: LD_VAR 0 8
67702: IFFALSE 67931
// begin for j in fac do
67704: LD_ADDR_VAR 0 4
67708: PUSH
67709: LD_VAR 0 8
67713: PUSH
67714: FOR_IN
67715: IFFALSE 67929
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
67717: LD_ADDR_VAR 0 9
67721: PUSH
67722: LD_VAR 0 8
67726: PPUSH
67727: LD_VAR 0 1
67731: PPUSH
67732: CALL_OW 265
67736: PPUSH
67737: LD_VAR 0 1
67741: PPUSH
67742: CALL_OW 262
67746: PPUSH
67747: LD_VAR 0 1
67751: PPUSH
67752: CALL_OW 263
67756: PPUSH
67757: LD_VAR 0 1
67761: PPUSH
67762: CALL_OW 264
67766: PPUSH
67767: CALL 72753 0 5
67771: ST_TO_ADDR
// if components then
67772: LD_VAR 0 9
67776: IFFALSE 67927
// begin if GetWeapon ( un ) = ar_control_tower then
67778: LD_VAR 0 1
67782: PPUSH
67783: CALL_OW 264
67787: PUSH
67788: LD_INT 31
67790: EQUAL
67791: IFFALSE 67908
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
67793: LD_VAR 0 1
67797: PPUSH
67798: CALL_OW 311
67802: PPUSH
67803: LD_INT 0
67805: PPUSH
67806: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
67810: LD_ADDR_EXP 142
67814: PUSH
67815: LD_EXP 142
67819: PPUSH
67820: LD_VAR 0 3
67824: PPUSH
67825: LD_EXP 142
67829: PUSH
67830: LD_VAR 0 3
67834: ARRAY
67835: PUSH
67836: LD_VAR 0 1
67840: PPUSH
67841: CALL_OW 311
67845: DIFF
67846: PPUSH
67847: CALL_OW 1
67851: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
67852: LD_ADDR_VAR 0 7
67856: PUSH
67857: LD_EXP 123
67861: PUSH
67862: LD_VAR 0 3
67866: ARRAY
67867: PPUSH
67868: LD_INT 1
67870: PPUSH
67871: LD_VAR 0 9
67875: PPUSH
67876: CALL_OW 2
67880: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
67881: LD_ADDR_EXP 123
67885: PUSH
67886: LD_EXP 123
67890: PPUSH
67891: LD_VAR 0 3
67895: PPUSH
67896: LD_VAR 0 7
67900: PPUSH
67901: CALL_OW 1
67905: ST_TO_ADDR
// end else
67906: GO 67925
// MC_InsertProduceList ( i , [ components ] ) ;
67908: LD_VAR 0 3
67912: PPUSH
67913: LD_VAR 0 9
67917: PUSH
67918: EMPTY
67919: LIST
67920: PPUSH
67921: CALL 63846 0 2
// break ;
67925: GO 67929
// end ; end ;
67927: GO 67714
67929: POP
67930: POP
// end ; end ; if GetType ( un ) = unit_building then
67931: LD_VAR 0 1
67935: PPUSH
67936: CALL_OW 247
67940: PUSH
67941: LD_INT 3
67943: EQUAL
67944: IFFALSE 68347
// begin btype := GetBType ( un ) ;
67946: LD_ADDR_VAR 0 5
67950: PUSH
67951: LD_VAR 0 1
67955: PPUSH
67956: CALL_OW 266
67960: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
67961: LD_VAR 0 5
67965: PUSH
67966: LD_INT 29
67968: PUSH
67969: LD_INT 30
67971: PUSH
67972: EMPTY
67973: LIST
67974: LIST
67975: IN
67976: IFFALSE 68049
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
67978: LD_VAR 0 1
67982: PPUSH
67983: CALL_OW 250
67987: PPUSH
67988: LD_VAR 0 1
67992: PPUSH
67993: CALL_OW 251
67997: PPUSH
67998: LD_VAR 0 1
68002: PPUSH
68003: CALL_OW 255
68007: PPUSH
68008: CALL_OW 440
68012: NOT
68013: IFFALSE 68049
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
68015: LD_VAR 0 1
68019: PPUSH
68020: CALL_OW 250
68024: PPUSH
68025: LD_VAR 0 1
68029: PPUSH
68030: CALL_OW 251
68034: PPUSH
68035: LD_VAR 0 1
68039: PPUSH
68040: CALL_OW 255
68044: PPUSH
68045: CALL_OW 441
// end ; if btype = b_warehouse then
68049: LD_VAR 0 5
68053: PUSH
68054: LD_INT 1
68056: EQUAL
68057: IFFALSE 68075
// begin btype := b_depot ;
68059: LD_ADDR_VAR 0 5
68063: PUSH
68064: LD_INT 0
68066: ST_TO_ADDR
// pos := 1 ;
68067: LD_ADDR_VAR 0 6
68071: PUSH
68072: LD_INT 1
68074: ST_TO_ADDR
// end ; if btype = b_factory then
68075: LD_VAR 0 5
68079: PUSH
68080: LD_INT 3
68082: EQUAL
68083: IFFALSE 68101
// begin btype := b_workshop ;
68085: LD_ADDR_VAR 0 5
68089: PUSH
68090: LD_INT 2
68092: ST_TO_ADDR
// pos := 1 ;
68093: LD_ADDR_VAR 0 6
68097: PUSH
68098: LD_INT 1
68100: ST_TO_ADDR
// end ; if btype = b_barracks then
68101: LD_VAR 0 5
68105: PUSH
68106: LD_INT 5
68108: EQUAL
68109: IFFALSE 68119
// btype := b_armoury ;
68111: LD_ADDR_VAR 0 5
68115: PUSH
68116: LD_INT 4
68118: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
68119: LD_VAR 0 5
68123: PUSH
68124: LD_INT 7
68126: PUSH
68127: LD_INT 8
68129: PUSH
68130: EMPTY
68131: LIST
68132: LIST
68133: IN
68134: IFFALSE 68144
// btype := b_lab ;
68136: LD_ADDR_VAR 0 5
68140: PUSH
68141: LD_INT 6
68143: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
68144: LD_ADDR_EXP 107
68148: PUSH
68149: LD_EXP 107
68153: PPUSH
68154: LD_VAR 0 3
68158: PUSH
68159: LD_EXP 107
68163: PUSH
68164: LD_VAR 0 3
68168: ARRAY
68169: PUSH
68170: LD_INT 1
68172: PLUS
68173: PUSH
68174: EMPTY
68175: LIST
68176: LIST
68177: PPUSH
68178: LD_VAR 0 5
68182: PUSH
68183: LD_VAR 0 1
68187: PPUSH
68188: CALL_OW 250
68192: PUSH
68193: LD_VAR 0 1
68197: PPUSH
68198: CALL_OW 251
68202: PUSH
68203: LD_VAR 0 1
68207: PPUSH
68208: CALL_OW 254
68212: PUSH
68213: EMPTY
68214: LIST
68215: LIST
68216: LIST
68217: LIST
68218: PPUSH
68219: CALL 75255 0 3
68223: ST_TO_ADDR
// if pos = 1 then
68224: LD_VAR 0 6
68228: PUSH
68229: LD_INT 1
68231: EQUAL
68232: IFFALSE 68347
// begin tmp := mc_build_list [ i ] ;
68234: LD_ADDR_VAR 0 7
68238: PUSH
68239: LD_EXP 107
68243: PUSH
68244: LD_VAR 0 3
68248: ARRAY
68249: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
68250: LD_VAR 0 7
68254: PPUSH
68255: LD_INT 2
68257: PUSH
68258: LD_INT 30
68260: PUSH
68261: LD_INT 0
68263: PUSH
68264: EMPTY
68265: LIST
68266: LIST
68267: PUSH
68268: LD_INT 30
68270: PUSH
68271: LD_INT 1
68273: PUSH
68274: EMPTY
68275: LIST
68276: LIST
68277: PUSH
68278: EMPTY
68279: LIST
68280: LIST
68281: LIST
68282: PPUSH
68283: CALL_OW 72
68287: IFFALSE 68297
// pos := 2 ;
68289: LD_ADDR_VAR 0 6
68293: PUSH
68294: LD_INT 2
68296: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
68297: LD_ADDR_VAR 0 7
68301: PUSH
68302: LD_VAR 0 7
68306: PPUSH
68307: LD_VAR 0 6
68311: PPUSH
68312: LD_VAR 0 7
68316: PPUSH
68317: CALL 75581 0 3
68321: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
68322: LD_ADDR_EXP 107
68326: PUSH
68327: LD_EXP 107
68331: PPUSH
68332: LD_VAR 0 3
68336: PPUSH
68337: LD_VAR 0 7
68341: PPUSH
68342: CALL_OW 1
68346: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
68347: LD_VAR 0 1
68351: PUSH
68352: LD_EXP 102
68356: PUSH
68357: LD_VAR 0 3
68361: ARRAY
68362: IN
68363: IFFALSE 68402
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
68365: LD_ADDR_EXP 102
68369: PUSH
68370: LD_EXP 102
68374: PPUSH
68375: LD_VAR 0 3
68379: PPUSH
68380: LD_EXP 102
68384: PUSH
68385: LD_VAR 0 3
68389: ARRAY
68390: PUSH
68391: LD_VAR 0 1
68395: DIFF
68396: PPUSH
68397: CALL_OW 1
68401: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
68402: LD_VAR 0 1
68406: PUSH
68407: LD_EXP 109
68411: PUSH
68412: LD_VAR 0 3
68416: ARRAY
68417: IN
68418: IFFALSE 68457
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
68420: LD_ADDR_EXP 109
68424: PUSH
68425: LD_EXP 109
68429: PPUSH
68430: LD_VAR 0 3
68434: PPUSH
68435: LD_EXP 109
68439: PUSH
68440: LD_VAR 0 3
68444: ARRAY
68445: PUSH
68446: LD_VAR 0 1
68450: DIFF
68451: PPUSH
68452: CALL_OW 1
68456: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
68457: LD_VAR 0 1
68461: PUSH
68462: LD_EXP 121
68466: PUSH
68467: LD_VAR 0 3
68471: ARRAY
68472: IN
68473: IFFALSE 68512
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
68475: LD_ADDR_EXP 121
68479: PUSH
68480: LD_EXP 121
68484: PPUSH
68485: LD_VAR 0 3
68489: PPUSH
68490: LD_EXP 121
68494: PUSH
68495: LD_VAR 0 3
68499: ARRAY
68500: PUSH
68501: LD_VAR 0 1
68505: DIFF
68506: PPUSH
68507: CALL_OW 1
68511: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
68512: LD_VAR 0 1
68516: PUSH
68517: LD_EXP 124
68521: PUSH
68522: LD_VAR 0 3
68526: ARRAY
68527: IN
68528: IFFALSE 68567
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
68530: LD_ADDR_EXP 124
68534: PUSH
68535: LD_EXP 124
68539: PPUSH
68540: LD_VAR 0 3
68544: PPUSH
68545: LD_EXP 124
68549: PUSH
68550: LD_VAR 0 3
68554: ARRAY
68555: PUSH
68556: LD_VAR 0 1
68560: DIFF
68561: PPUSH
68562: CALL_OW 1
68566: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
68567: LD_VAR 0 1
68571: PUSH
68572: LD_EXP 111
68576: PUSH
68577: LD_VAR 0 3
68581: ARRAY
68582: IN
68583: IFFALSE 68622
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
68585: LD_ADDR_EXP 111
68589: PUSH
68590: LD_EXP 111
68594: PPUSH
68595: LD_VAR 0 3
68599: PPUSH
68600: LD_EXP 111
68604: PUSH
68605: LD_VAR 0 3
68609: ARRAY
68610: PUSH
68611: LD_VAR 0 1
68615: DIFF
68616: PPUSH
68617: CALL_OW 1
68621: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
68622: LD_VAR 0 1
68626: PUSH
68627: LD_EXP 110
68631: PUSH
68632: LD_VAR 0 3
68636: ARRAY
68637: IN
68638: IFFALSE 68677
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
68640: LD_ADDR_EXP 110
68644: PUSH
68645: LD_EXP 110
68649: PPUSH
68650: LD_VAR 0 3
68654: PPUSH
68655: LD_EXP 110
68659: PUSH
68660: LD_VAR 0 3
68664: ARRAY
68665: PUSH
68666: LD_VAR 0 1
68670: DIFF
68671: PPUSH
68672: CALL_OW 1
68676: ST_TO_ADDR
// end ; break ;
68677: GO 68681
// end ;
68679: GO 67329
68681: POP
68682: POP
// end ;
68683: LD_VAR 0 2
68687: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
68688: LD_INT 0
68690: PPUSH
68691: PPUSH
68692: PPUSH
// if not mc_bases or not skirmish then
68693: LD_EXP 102
68697: NOT
68698: PUSH
68699: LD_EXP 100
68703: NOT
68704: OR
68705: IFFALSE 68709
// exit ;
68707: GO 68924
// for i = 1 to mc_bases do
68709: LD_ADDR_VAR 0 3
68713: PUSH
68714: DOUBLE
68715: LD_INT 1
68717: DEC
68718: ST_TO_ADDR
68719: LD_EXP 102
68723: PUSH
68724: FOR_TO
68725: IFFALSE 68922
// begin if building in mc_construct_list [ i ] then
68727: LD_VAR 0 1
68731: PUSH
68732: LD_EXP 109
68736: PUSH
68737: LD_VAR 0 3
68741: ARRAY
68742: IN
68743: IFFALSE 68920
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
68745: LD_ADDR_EXP 109
68749: PUSH
68750: LD_EXP 109
68754: PPUSH
68755: LD_VAR 0 3
68759: PPUSH
68760: LD_EXP 109
68764: PUSH
68765: LD_VAR 0 3
68769: ARRAY
68770: PUSH
68771: LD_VAR 0 1
68775: DIFF
68776: PPUSH
68777: CALL_OW 1
68781: ST_TO_ADDR
// if building in mc_lab [ i ] then
68782: LD_VAR 0 1
68786: PUSH
68787: LD_EXP 135
68791: PUSH
68792: LD_VAR 0 3
68796: ARRAY
68797: IN
68798: IFFALSE 68853
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
68800: LD_ADDR_EXP 136
68804: PUSH
68805: LD_EXP 136
68809: PPUSH
68810: LD_VAR 0 3
68814: PPUSH
68815: LD_EXP 136
68819: PUSH
68820: LD_VAR 0 3
68824: ARRAY
68825: PPUSH
68826: LD_INT 1
68828: PPUSH
68829: LD_EXP 136
68833: PUSH
68834: LD_VAR 0 3
68838: ARRAY
68839: PPUSH
68840: LD_INT 0
68842: PPUSH
68843: CALL 74673 0 4
68847: PPUSH
68848: CALL_OW 1
68852: ST_TO_ADDR
// if not building in mc_bases [ i ] then
68853: LD_VAR 0 1
68857: PUSH
68858: LD_EXP 102
68862: PUSH
68863: LD_VAR 0 3
68867: ARRAY
68868: IN
68869: NOT
68870: IFFALSE 68916
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
68872: LD_ADDR_EXP 102
68876: PUSH
68877: LD_EXP 102
68881: PPUSH
68882: LD_VAR 0 3
68886: PUSH
68887: LD_EXP 102
68891: PUSH
68892: LD_VAR 0 3
68896: ARRAY
68897: PUSH
68898: LD_INT 1
68900: PLUS
68901: PUSH
68902: EMPTY
68903: LIST
68904: LIST
68905: PPUSH
68906: LD_VAR 0 1
68910: PPUSH
68911: CALL 75255 0 3
68915: ST_TO_ADDR
// exit ;
68916: POP
68917: POP
68918: GO 68924
// end ; end ;
68920: GO 68724
68922: POP
68923: POP
// end ;
68924: LD_VAR 0 2
68928: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
68929: LD_INT 0
68931: PPUSH
68932: PPUSH
68933: PPUSH
68934: PPUSH
68935: PPUSH
68936: PPUSH
68937: PPUSH
// if not mc_bases or not skirmish then
68938: LD_EXP 102
68942: NOT
68943: PUSH
68944: LD_EXP 100
68948: NOT
68949: OR
68950: IFFALSE 68954
// exit ;
68952: GO 69615
// for i = 1 to mc_bases do
68954: LD_ADDR_VAR 0 3
68958: PUSH
68959: DOUBLE
68960: LD_INT 1
68962: DEC
68963: ST_TO_ADDR
68964: LD_EXP 102
68968: PUSH
68969: FOR_TO
68970: IFFALSE 69613
// begin if building in mc_construct_list [ i ] then
68972: LD_VAR 0 1
68976: PUSH
68977: LD_EXP 109
68981: PUSH
68982: LD_VAR 0 3
68986: ARRAY
68987: IN
68988: IFFALSE 69611
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
68990: LD_ADDR_EXP 109
68994: PUSH
68995: LD_EXP 109
68999: PPUSH
69000: LD_VAR 0 3
69004: PPUSH
69005: LD_EXP 109
69009: PUSH
69010: LD_VAR 0 3
69014: ARRAY
69015: PUSH
69016: LD_VAR 0 1
69020: DIFF
69021: PPUSH
69022: CALL_OW 1
69026: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
69027: LD_ADDR_EXP 102
69031: PUSH
69032: LD_EXP 102
69036: PPUSH
69037: LD_VAR 0 3
69041: PUSH
69042: LD_EXP 102
69046: PUSH
69047: LD_VAR 0 3
69051: ARRAY
69052: PUSH
69053: LD_INT 1
69055: PLUS
69056: PUSH
69057: EMPTY
69058: LIST
69059: LIST
69060: PPUSH
69061: LD_VAR 0 1
69065: PPUSH
69066: CALL 75255 0 3
69070: ST_TO_ADDR
// btype := GetBType ( building ) ;
69071: LD_ADDR_VAR 0 5
69075: PUSH
69076: LD_VAR 0 1
69080: PPUSH
69081: CALL_OW 266
69085: ST_TO_ADDR
// side := GetSide ( building ) ;
69086: LD_ADDR_VAR 0 8
69090: PUSH
69091: LD_VAR 0 1
69095: PPUSH
69096: CALL_OW 255
69100: ST_TO_ADDR
// if btype = b_lab then
69101: LD_VAR 0 5
69105: PUSH
69106: LD_INT 6
69108: EQUAL
69109: IFFALSE 69159
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
69111: LD_ADDR_EXP 135
69115: PUSH
69116: LD_EXP 135
69120: PPUSH
69121: LD_VAR 0 3
69125: PUSH
69126: LD_EXP 135
69130: PUSH
69131: LD_VAR 0 3
69135: ARRAY
69136: PUSH
69137: LD_INT 1
69139: PLUS
69140: PUSH
69141: EMPTY
69142: LIST
69143: LIST
69144: PPUSH
69145: LD_VAR 0 1
69149: PPUSH
69150: CALL 75255 0 3
69154: ST_TO_ADDR
// exit ;
69155: POP
69156: POP
69157: GO 69615
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
69159: LD_VAR 0 5
69163: PUSH
69164: LD_INT 0
69166: PUSH
69167: LD_INT 2
69169: PUSH
69170: LD_INT 4
69172: PUSH
69173: EMPTY
69174: LIST
69175: LIST
69176: LIST
69177: IN
69178: IFFALSE 69302
// begin if btype = b_armoury then
69180: LD_VAR 0 5
69184: PUSH
69185: LD_INT 4
69187: EQUAL
69188: IFFALSE 69198
// btype := b_barracks ;
69190: LD_ADDR_VAR 0 5
69194: PUSH
69195: LD_INT 5
69197: ST_TO_ADDR
// if btype = b_depot then
69198: LD_VAR 0 5
69202: PUSH
69203: LD_INT 0
69205: EQUAL
69206: IFFALSE 69216
// btype := b_warehouse ;
69208: LD_ADDR_VAR 0 5
69212: PUSH
69213: LD_INT 1
69215: ST_TO_ADDR
// if btype = b_workshop then
69216: LD_VAR 0 5
69220: PUSH
69221: LD_INT 2
69223: EQUAL
69224: IFFALSE 69234
// btype := b_factory ;
69226: LD_ADDR_VAR 0 5
69230: PUSH
69231: LD_INT 3
69233: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
69234: LD_VAR 0 5
69238: PPUSH
69239: LD_VAR 0 8
69243: PPUSH
69244: CALL_OW 323
69248: PUSH
69249: LD_INT 1
69251: EQUAL
69252: IFFALSE 69298
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
69254: LD_ADDR_EXP 134
69258: PUSH
69259: LD_EXP 134
69263: PPUSH
69264: LD_VAR 0 3
69268: PUSH
69269: LD_EXP 134
69273: PUSH
69274: LD_VAR 0 3
69278: ARRAY
69279: PUSH
69280: LD_INT 1
69282: PLUS
69283: PUSH
69284: EMPTY
69285: LIST
69286: LIST
69287: PPUSH
69288: LD_VAR 0 1
69292: PPUSH
69293: CALL 75255 0 3
69297: ST_TO_ADDR
// exit ;
69298: POP
69299: POP
69300: GO 69615
// end ; if btype in [ b_bunker , b_turret ] then
69302: LD_VAR 0 5
69306: PUSH
69307: LD_INT 32
69309: PUSH
69310: LD_INT 33
69312: PUSH
69313: EMPTY
69314: LIST
69315: LIST
69316: IN
69317: IFFALSE 69607
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
69319: LD_ADDR_EXP 110
69323: PUSH
69324: LD_EXP 110
69328: PPUSH
69329: LD_VAR 0 3
69333: PUSH
69334: LD_EXP 110
69338: PUSH
69339: LD_VAR 0 3
69343: ARRAY
69344: PUSH
69345: LD_INT 1
69347: PLUS
69348: PUSH
69349: EMPTY
69350: LIST
69351: LIST
69352: PPUSH
69353: LD_VAR 0 1
69357: PPUSH
69358: CALL 75255 0 3
69362: ST_TO_ADDR
// if btype = b_bunker then
69363: LD_VAR 0 5
69367: PUSH
69368: LD_INT 32
69370: EQUAL
69371: IFFALSE 69607
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
69373: LD_ADDR_EXP 111
69377: PUSH
69378: LD_EXP 111
69382: PPUSH
69383: LD_VAR 0 3
69387: PUSH
69388: LD_EXP 111
69392: PUSH
69393: LD_VAR 0 3
69397: ARRAY
69398: PUSH
69399: LD_INT 1
69401: PLUS
69402: PUSH
69403: EMPTY
69404: LIST
69405: LIST
69406: PPUSH
69407: LD_VAR 0 1
69411: PPUSH
69412: CALL 75255 0 3
69416: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
69417: LD_ADDR_VAR 0 6
69421: PUSH
69422: LD_EXP 102
69426: PUSH
69427: LD_VAR 0 3
69431: ARRAY
69432: PPUSH
69433: LD_INT 25
69435: PUSH
69436: LD_INT 1
69438: PUSH
69439: EMPTY
69440: LIST
69441: LIST
69442: PUSH
69443: LD_INT 3
69445: PUSH
69446: LD_INT 54
69448: PUSH
69449: EMPTY
69450: LIST
69451: PUSH
69452: EMPTY
69453: LIST
69454: LIST
69455: PUSH
69456: EMPTY
69457: LIST
69458: LIST
69459: PPUSH
69460: CALL_OW 72
69464: ST_TO_ADDR
// if tmp then
69465: LD_VAR 0 6
69469: IFFALSE 69475
// exit ;
69471: POP
69472: POP
69473: GO 69615
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
69475: LD_ADDR_VAR 0 6
69479: PUSH
69480: LD_EXP 102
69484: PUSH
69485: LD_VAR 0 3
69489: ARRAY
69490: PPUSH
69491: LD_INT 2
69493: PUSH
69494: LD_INT 30
69496: PUSH
69497: LD_INT 4
69499: PUSH
69500: EMPTY
69501: LIST
69502: LIST
69503: PUSH
69504: LD_INT 30
69506: PUSH
69507: LD_INT 5
69509: PUSH
69510: EMPTY
69511: LIST
69512: LIST
69513: PUSH
69514: EMPTY
69515: LIST
69516: LIST
69517: LIST
69518: PPUSH
69519: CALL_OW 72
69523: ST_TO_ADDR
// if not tmp then
69524: LD_VAR 0 6
69528: NOT
69529: IFFALSE 69535
// exit ;
69531: POP
69532: POP
69533: GO 69615
// for j in tmp do
69535: LD_ADDR_VAR 0 4
69539: PUSH
69540: LD_VAR 0 6
69544: PUSH
69545: FOR_IN
69546: IFFALSE 69605
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
69548: LD_ADDR_VAR 0 7
69552: PUSH
69553: LD_VAR 0 4
69557: PPUSH
69558: CALL_OW 313
69562: PPUSH
69563: LD_INT 25
69565: PUSH
69566: LD_INT 1
69568: PUSH
69569: EMPTY
69570: LIST
69571: LIST
69572: PPUSH
69573: CALL_OW 72
69577: ST_TO_ADDR
// if units then
69578: LD_VAR 0 7
69582: IFFALSE 69603
// begin ComExitBuilding ( units [ 1 ] ) ;
69584: LD_VAR 0 7
69588: PUSH
69589: LD_INT 1
69591: ARRAY
69592: PPUSH
69593: CALL_OW 122
// exit ;
69597: POP
69598: POP
69599: POP
69600: POP
69601: GO 69615
// end ; end ;
69603: GO 69545
69605: POP
69606: POP
// end ; end ; exit ;
69607: POP
69608: POP
69609: GO 69615
// end ; end ;
69611: GO 68969
69613: POP
69614: POP
// end ;
69615: LD_VAR 0 2
69619: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
69620: LD_INT 0
69622: PPUSH
69623: PPUSH
69624: PPUSH
69625: PPUSH
69626: PPUSH
69627: PPUSH
69628: PPUSH
// if not mc_bases or not skirmish then
69629: LD_EXP 102
69633: NOT
69634: PUSH
69635: LD_EXP 100
69639: NOT
69640: OR
69641: IFFALSE 69645
// exit ;
69643: GO 69910
// btype := GetBType ( building ) ;
69645: LD_ADDR_VAR 0 6
69649: PUSH
69650: LD_VAR 0 1
69654: PPUSH
69655: CALL_OW 266
69659: ST_TO_ADDR
// x := GetX ( building ) ;
69660: LD_ADDR_VAR 0 7
69664: PUSH
69665: LD_VAR 0 1
69669: PPUSH
69670: CALL_OW 250
69674: ST_TO_ADDR
// y := GetY ( building ) ;
69675: LD_ADDR_VAR 0 8
69679: PUSH
69680: LD_VAR 0 1
69684: PPUSH
69685: CALL_OW 251
69689: ST_TO_ADDR
// d := GetDir ( building ) ;
69690: LD_ADDR_VAR 0 9
69694: PUSH
69695: LD_VAR 0 1
69699: PPUSH
69700: CALL_OW 254
69704: ST_TO_ADDR
// for i = 1 to mc_bases do
69705: LD_ADDR_VAR 0 4
69709: PUSH
69710: DOUBLE
69711: LD_INT 1
69713: DEC
69714: ST_TO_ADDR
69715: LD_EXP 102
69719: PUSH
69720: FOR_TO
69721: IFFALSE 69908
// begin if not mc_build_list [ i ] then
69723: LD_EXP 107
69727: PUSH
69728: LD_VAR 0 4
69732: ARRAY
69733: NOT
69734: IFFALSE 69738
// continue ;
69736: GO 69720
// for j := 1 to mc_build_list [ i ] do
69738: LD_ADDR_VAR 0 5
69742: PUSH
69743: DOUBLE
69744: LD_INT 1
69746: DEC
69747: ST_TO_ADDR
69748: LD_EXP 107
69752: PUSH
69753: LD_VAR 0 4
69757: ARRAY
69758: PUSH
69759: FOR_TO
69760: IFFALSE 69904
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
69762: LD_VAR 0 6
69766: PUSH
69767: LD_VAR 0 7
69771: PUSH
69772: LD_VAR 0 8
69776: PUSH
69777: LD_VAR 0 9
69781: PUSH
69782: EMPTY
69783: LIST
69784: LIST
69785: LIST
69786: LIST
69787: PPUSH
69788: LD_EXP 107
69792: PUSH
69793: LD_VAR 0 4
69797: ARRAY
69798: PUSH
69799: LD_VAR 0 5
69803: ARRAY
69804: PPUSH
69805: CALL 81812 0 2
69809: IFFALSE 69902
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
69811: LD_ADDR_EXP 107
69815: PUSH
69816: LD_EXP 107
69820: PPUSH
69821: LD_VAR 0 4
69825: PPUSH
69826: LD_EXP 107
69830: PUSH
69831: LD_VAR 0 4
69835: ARRAY
69836: PPUSH
69837: LD_VAR 0 5
69841: PPUSH
69842: CALL_OW 3
69846: PPUSH
69847: CALL_OW 1
69851: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
69852: LD_ADDR_EXP 109
69856: PUSH
69857: LD_EXP 109
69861: PPUSH
69862: LD_VAR 0 4
69866: PUSH
69867: LD_EXP 109
69871: PUSH
69872: LD_VAR 0 4
69876: ARRAY
69877: PUSH
69878: LD_INT 1
69880: PLUS
69881: PUSH
69882: EMPTY
69883: LIST
69884: LIST
69885: PPUSH
69886: LD_VAR 0 1
69890: PPUSH
69891: CALL 75255 0 3
69895: ST_TO_ADDR
// exit ;
69896: POP
69897: POP
69898: POP
69899: POP
69900: GO 69910
// end ;
69902: GO 69759
69904: POP
69905: POP
// end ;
69906: GO 69720
69908: POP
69909: POP
// end ;
69910: LD_VAR 0 3
69914: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
69915: LD_INT 0
69917: PPUSH
69918: PPUSH
69919: PPUSH
// if not mc_bases or not skirmish then
69920: LD_EXP 102
69924: NOT
69925: PUSH
69926: LD_EXP 100
69930: NOT
69931: OR
69932: IFFALSE 69936
// exit ;
69934: GO 70126
// for i = 1 to mc_bases do
69936: LD_ADDR_VAR 0 4
69940: PUSH
69941: DOUBLE
69942: LD_INT 1
69944: DEC
69945: ST_TO_ADDR
69946: LD_EXP 102
69950: PUSH
69951: FOR_TO
69952: IFFALSE 70039
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
69954: LD_VAR 0 1
69958: PUSH
69959: LD_EXP 110
69963: PUSH
69964: LD_VAR 0 4
69968: ARRAY
69969: IN
69970: PUSH
69971: LD_VAR 0 1
69975: PUSH
69976: LD_EXP 111
69980: PUSH
69981: LD_VAR 0 4
69985: ARRAY
69986: IN
69987: NOT
69988: AND
69989: IFFALSE 70037
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
69991: LD_ADDR_EXP 111
69995: PUSH
69996: LD_EXP 111
70000: PPUSH
70001: LD_VAR 0 4
70005: PUSH
70006: LD_EXP 111
70010: PUSH
70011: LD_VAR 0 4
70015: ARRAY
70016: PUSH
70017: LD_INT 1
70019: PLUS
70020: PUSH
70021: EMPTY
70022: LIST
70023: LIST
70024: PPUSH
70025: LD_VAR 0 1
70029: PPUSH
70030: CALL 75255 0 3
70034: ST_TO_ADDR
// break ;
70035: GO 70039
// end ; end ;
70037: GO 69951
70039: POP
70040: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
70041: LD_VAR 0 1
70045: PPUSH
70046: CALL_OW 257
70050: PUSH
70051: LD_EXP 128
70055: IN
70056: PUSH
70057: LD_VAR 0 1
70061: PPUSH
70062: CALL_OW 266
70066: PUSH
70067: LD_INT 5
70069: EQUAL
70070: AND
70071: PUSH
70072: LD_VAR 0 2
70076: PPUSH
70077: CALL_OW 110
70081: PUSH
70082: LD_INT 18
70084: NONEQUAL
70085: AND
70086: IFFALSE 70126
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
70088: LD_VAR 0 2
70092: PPUSH
70093: CALL_OW 257
70097: PUSH
70098: LD_INT 5
70100: PUSH
70101: LD_INT 8
70103: PUSH
70104: LD_INT 9
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: LIST
70111: IN
70112: IFFALSE 70126
// SetClass ( unit , 1 ) ;
70114: LD_VAR 0 2
70118: PPUSH
70119: LD_INT 1
70121: PPUSH
70122: CALL_OW 336
// end ;
70126: LD_VAR 0 3
70130: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
70131: LD_INT 0
70133: PPUSH
70134: PPUSH
// if not mc_bases or not skirmish then
70135: LD_EXP 102
70139: NOT
70140: PUSH
70141: LD_EXP 100
70145: NOT
70146: OR
70147: IFFALSE 70151
// exit ;
70149: GO 70267
// if GetLives ( abandoned_vehicle ) > 250 then
70151: LD_VAR 0 2
70155: PPUSH
70156: CALL_OW 256
70160: PUSH
70161: LD_INT 250
70163: GREATER
70164: IFFALSE 70168
// exit ;
70166: GO 70267
// for i = 1 to mc_bases do
70168: LD_ADDR_VAR 0 6
70172: PUSH
70173: DOUBLE
70174: LD_INT 1
70176: DEC
70177: ST_TO_ADDR
70178: LD_EXP 102
70182: PUSH
70183: FOR_TO
70184: IFFALSE 70265
// begin if driver in mc_bases [ i ] then
70186: LD_VAR 0 1
70190: PUSH
70191: LD_EXP 102
70195: PUSH
70196: LD_VAR 0 6
70200: ARRAY
70201: IN
70202: IFFALSE 70263
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
70204: LD_VAR 0 1
70208: PPUSH
70209: LD_EXP 102
70213: PUSH
70214: LD_VAR 0 6
70218: ARRAY
70219: PPUSH
70220: LD_INT 2
70222: PUSH
70223: LD_INT 30
70225: PUSH
70226: LD_INT 0
70228: PUSH
70229: EMPTY
70230: LIST
70231: LIST
70232: PUSH
70233: LD_INT 30
70235: PUSH
70236: LD_INT 1
70238: PUSH
70239: EMPTY
70240: LIST
70241: LIST
70242: PUSH
70243: EMPTY
70244: LIST
70245: LIST
70246: LIST
70247: PPUSH
70248: CALL_OW 72
70252: PUSH
70253: LD_INT 1
70255: ARRAY
70256: PPUSH
70257: CALL 108881 0 2
// break ;
70261: GO 70265
// end ; end ;
70263: GO 70183
70265: POP
70266: POP
// end ; end_of_file
70267: LD_VAR 0 5
70271: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
70272: LD_INT 0
70274: PPUSH
70275: PPUSH
// if exist_mode then
70276: LD_VAR 0 2
70280: IFFALSE 70326
// begin unit := CreateCharacter ( prefix & ident ) ;
70282: LD_ADDR_VAR 0 5
70286: PUSH
70287: LD_VAR 0 3
70291: PUSH
70292: LD_VAR 0 1
70296: STR
70297: PPUSH
70298: CALL_OW 34
70302: ST_TO_ADDR
// if unit then
70303: LD_VAR 0 5
70307: IFFALSE 70324
// DeleteCharacters ( prefix & ident ) ;
70309: LD_VAR 0 3
70313: PUSH
70314: LD_VAR 0 1
70318: STR
70319: PPUSH
70320: CALL_OW 40
// end else
70324: GO 70341
// unit := NewCharacter ( ident ) ;
70326: LD_ADDR_VAR 0 5
70330: PUSH
70331: LD_VAR 0 1
70335: PPUSH
70336: CALL_OW 25
70340: ST_TO_ADDR
// result := unit ;
70341: LD_ADDR_VAR 0 4
70345: PUSH
70346: LD_VAR 0 5
70350: ST_TO_ADDR
// end ;
70351: LD_VAR 0 4
70355: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
70356: LD_INT 0
70358: PPUSH
70359: PPUSH
// if not side or not nation then
70360: LD_VAR 0 1
70364: NOT
70365: PUSH
70366: LD_VAR 0 2
70370: NOT
70371: OR
70372: IFFALSE 70376
// exit ;
70374: GO 71144
// case nation of nation_american :
70376: LD_VAR 0 2
70380: PUSH
70381: LD_INT 1
70383: DOUBLE
70384: EQUAL
70385: IFTRUE 70389
70387: GO 70603
70389: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
70390: LD_ADDR_VAR 0 4
70394: PUSH
70395: LD_INT 35
70397: PUSH
70398: LD_INT 45
70400: PUSH
70401: LD_INT 46
70403: PUSH
70404: LD_INT 47
70406: PUSH
70407: LD_INT 82
70409: PUSH
70410: LD_INT 83
70412: PUSH
70413: LD_INT 84
70415: PUSH
70416: LD_INT 85
70418: PUSH
70419: LD_INT 86
70421: PUSH
70422: LD_INT 1
70424: PUSH
70425: LD_INT 2
70427: PUSH
70428: LD_INT 6
70430: PUSH
70431: LD_INT 15
70433: PUSH
70434: LD_INT 16
70436: PUSH
70437: LD_INT 7
70439: PUSH
70440: LD_INT 12
70442: PUSH
70443: LD_INT 13
70445: PUSH
70446: LD_INT 10
70448: PUSH
70449: LD_INT 14
70451: PUSH
70452: LD_INT 20
70454: PUSH
70455: LD_INT 21
70457: PUSH
70458: LD_INT 22
70460: PUSH
70461: LD_INT 25
70463: PUSH
70464: LD_INT 32
70466: PUSH
70467: LD_INT 27
70469: PUSH
70470: LD_INT 36
70472: PUSH
70473: LD_INT 69
70475: PUSH
70476: LD_INT 39
70478: PUSH
70479: LD_INT 34
70481: PUSH
70482: LD_INT 40
70484: PUSH
70485: LD_INT 48
70487: PUSH
70488: LD_INT 49
70490: PUSH
70491: LD_INT 50
70493: PUSH
70494: LD_INT 51
70496: PUSH
70497: LD_INT 52
70499: PUSH
70500: LD_INT 53
70502: PUSH
70503: LD_INT 54
70505: PUSH
70506: LD_INT 55
70508: PUSH
70509: LD_INT 56
70511: PUSH
70512: LD_INT 57
70514: PUSH
70515: LD_INT 58
70517: PUSH
70518: LD_INT 59
70520: PUSH
70521: LD_INT 60
70523: PUSH
70524: LD_INT 61
70526: PUSH
70527: LD_INT 62
70529: PUSH
70530: LD_INT 80
70532: PUSH
70533: LD_INT 82
70535: PUSH
70536: LD_INT 83
70538: PUSH
70539: LD_INT 84
70541: PUSH
70542: LD_INT 85
70544: PUSH
70545: LD_INT 86
70547: PUSH
70548: EMPTY
70549: LIST
70550: LIST
70551: LIST
70552: LIST
70553: LIST
70554: LIST
70555: LIST
70556: LIST
70557: LIST
70558: LIST
70559: LIST
70560: LIST
70561: LIST
70562: LIST
70563: LIST
70564: LIST
70565: LIST
70566: LIST
70567: LIST
70568: LIST
70569: LIST
70570: LIST
70571: LIST
70572: LIST
70573: LIST
70574: LIST
70575: LIST
70576: LIST
70577: LIST
70578: LIST
70579: LIST
70580: LIST
70581: LIST
70582: LIST
70583: LIST
70584: LIST
70585: LIST
70586: LIST
70587: LIST
70588: LIST
70589: LIST
70590: LIST
70591: LIST
70592: LIST
70593: LIST
70594: LIST
70595: LIST
70596: LIST
70597: LIST
70598: LIST
70599: LIST
70600: ST_TO_ADDR
70601: GO 71068
70603: LD_INT 2
70605: DOUBLE
70606: EQUAL
70607: IFTRUE 70611
70609: GO 70837
70611: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
70612: LD_ADDR_VAR 0 4
70616: PUSH
70617: LD_INT 35
70619: PUSH
70620: LD_INT 45
70622: PUSH
70623: LD_INT 46
70625: PUSH
70626: LD_INT 47
70628: PUSH
70629: LD_INT 82
70631: PUSH
70632: LD_INT 83
70634: PUSH
70635: LD_INT 84
70637: PUSH
70638: LD_INT 85
70640: PUSH
70641: LD_INT 87
70643: PUSH
70644: LD_INT 70
70646: PUSH
70647: LD_INT 1
70649: PUSH
70650: LD_INT 11
70652: PUSH
70653: LD_INT 3
70655: PUSH
70656: LD_INT 4
70658: PUSH
70659: LD_INT 5
70661: PUSH
70662: LD_INT 6
70664: PUSH
70665: LD_INT 15
70667: PUSH
70668: LD_INT 18
70670: PUSH
70671: LD_INT 7
70673: PUSH
70674: LD_INT 17
70676: PUSH
70677: LD_INT 8
70679: PUSH
70680: LD_INT 20
70682: PUSH
70683: LD_INT 21
70685: PUSH
70686: LD_INT 22
70688: PUSH
70689: LD_INT 72
70691: PUSH
70692: LD_INT 26
70694: PUSH
70695: LD_INT 69
70697: PUSH
70698: LD_INT 39
70700: PUSH
70701: LD_INT 40
70703: PUSH
70704: LD_INT 41
70706: PUSH
70707: LD_INT 42
70709: PUSH
70710: LD_INT 43
70712: PUSH
70713: LD_INT 48
70715: PUSH
70716: LD_INT 49
70718: PUSH
70719: LD_INT 50
70721: PUSH
70722: LD_INT 51
70724: PUSH
70725: LD_INT 52
70727: PUSH
70728: LD_INT 53
70730: PUSH
70731: LD_INT 54
70733: PUSH
70734: LD_INT 55
70736: PUSH
70737: LD_INT 56
70739: PUSH
70740: LD_INT 60
70742: PUSH
70743: LD_INT 61
70745: PUSH
70746: LD_INT 62
70748: PUSH
70749: LD_INT 66
70751: PUSH
70752: LD_INT 67
70754: PUSH
70755: LD_INT 68
70757: PUSH
70758: LD_INT 81
70760: PUSH
70761: LD_INT 82
70763: PUSH
70764: LD_INT 83
70766: PUSH
70767: LD_INT 84
70769: PUSH
70770: LD_INT 85
70772: PUSH
70773: LD_INT 87
70775: PUSH
70776: LD_INT 88
70778: PUSH
70779: EMPTY
70780: LIST
70781: LIST
70782: LIST
70783: LIST
70784: LIST
70785: LIST
70786: LIST
70787: LIST
70788: LIST
70789: LIST
70790: LIST
70791: LIST
70792: LIST
70793: LIST
70794: LIST
70795: LIST
70796: LIST
70797: LIST
70798: LIST
70799: LIST
70800: LIST
70801: LIST
70802: LIST
70803: LIST
70804: LIST
70805: LIST
70806: LIST
70807: LIST
70808: LIST
70809: LIST
70810: LIST
70811: LIST
70812: LIST
70813: LIST
70814: LIST
70815: LIST
70816: LIST
70817: LIST
70818: LIST
70819: LIST
70820: LIST
70821: LIST
70822: LIST
70823: LIST
70824: LIST
70825: LIST
70826: LIST
70827: LIST
70828: LIST
70829: LIST
70830: LIST
70831: LIST
70832: LIST
70833: LIST
70834: ST_TO_ADDR
70835: GO 71068
70837: LD_INT 3
70839: DOUBLE
70840: EQUAL
70841: IFTRUE 70845
70843: GO 71067
70845: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
70846: LD_ADDR_VAR 0 4
70850: PUSH
70851: LD_INT 46
70853: PUSH
70854: LD_INT 47
70856: PUSH
70857: LD_INT 1
70859: PUSH
70860: LD_INT 2
70862: PUSH
70863: LD_INT 82
70865: PUSH
70866: LD_INT 83
70868: PUSH
70869: LD_INT 84
70871: PUSH
70872: LD_INT 85
70874: PUSH
70875: LD_INT 86
70877: PUSH
70878: LD_INT 11
70880: PUSH
70881: LD_INT 9
70883: PUSH
70884: LD_INT 20
70886: PUSH
70887: LD_INT 19
70889: PUSH
70890: LD_INT 21
70892: PUSH
70893: LD_INT 24
70895: PUSH
70896: LD_INT 22
70898: PUSH
70899: LD_INT 25
70901: PUSH
70902: LD_INT 28
70904: PUSH
70905: LD_INT 29
70907: PUSH
70908: LD_INT 30
70910: PUSH
70911: LD_INT 31
70913: PUSH
70914: LD_INT 37
70916: PUSH
70917: LD_INT 38
70919: PUSH
70920: LD_INT 32
70922: PUSH
70923: LD_INT 27
70925: PUSH
70926: LD_INT 33
70928: PUSH
70929: LD_INT 69
70931: PUSH
70932: LD_INT 39
70934: PUSH
70935: LD_INT 34
70937: PUSH
70938: LD_INT 40
70940: PUSH
70941: LD_INT 71
70943: PUSH
70944: LD_INT 23
70946: PUSH
70947: LD_INT 44
70949: PUSH
70950: LD_INT 48
70952: PUSH
70953: LD_INT 49
70955: PUSH
70956: LD_INT 50
70958: PUSH
70959: LD_INT 51
70961: PUSH
70962: LD_INT 52
70964: PUSH
70965: LD_INT 53
70967: PUSH
70968: LD_INT 54
70970: PUSH
70971: LD_INT 55
70973: PUSH
70974: LD_INT 56
70976: PUSH
70977: LD_INT 57
70979: PUSH
70980: LD_INT 58
70982: PUSH
70983: LD_INT 59
70985: PUSH
70986: LD_INT 63
70988: PUSH
70989: LD_INT 64
70991: PUSH
70992: LD_INT 65
70994: PUSH
70995: LD_INT 82
70997: PUSH
70998: LD_INT 83
71000: PUSH
71001: LD_INT 84
71003: PUSH
71004: LD_INT 85
71006: PUSH
71007: LD_INT 86
71009: PUSH
71010: EMPTY
71011: LIST
71012: LIST
71013: LIST
71014: LIST
71015: LIST
71016: LIST
71017: LIST
71018: LIST
71019: LIST
71020: LIST
71021: LIST
71022: LIST
71023: LIST
71024: LIST
71025: LIST
71026: LIST
71027: LIST
71028: LIST
71029: LIST
71030: LIST
71031: LIST
71032: LIST
71033: LIST
71034: LIST
71035: LIST
71036: LIST
71037: LIST
71038: LIST
71039: LIST
71040: LIST
71041: LIST
71042: LIST
71043: LIST
71044: LIST
71045: LIST
71046: LIST
71047: LIST
71048: LIST
71049: LIST
71050: LIST
71051: LIST
71052: LIST
71053: LIST
71054: LIST
71055: LIST
71056: LIST
71057: LIST
71058: LIST
71059: LIST
71060: LIST
71061: LIST
71062: LIST
71063: LIST
71064: ST_TO_ADDR
71065: GO 71068
71067: POP
// if state > - 1 and state < 3 then
71068: LD_VAR 0 3
71072: PUSH
71073: LD_INT 1
71075: NEG
71076: GREATER
71077: PUSH
71078: LD_VAR 0 3
71082: PUSH
71083: LD_INT 3
71085: LESS
71086: AND
71087: IFFALSE 71144
// for i in result do
71089: LD_ADDR_VAR 0 5
71093: PUSH
71094: LD_VAR 0 4
71098: PUSH
71099: FOR_IN
71100: IFFALSE 71142
// if GetTech ( i , side ) <> state then
71102: LD_VAR 0 5
71106: PPUSH
71107: LD_VAR 0 1
71111: PPUSH
71112: CALL_OW 321
71116: PUSH
71117: LD_VAR 0 3
71121: NONEQUAL
71122: IFFALSE 71140
// result := result diff i ;
71124: LD_ADDR_VAR 0 4
71128: PUSH
71129: LD_VAR 0 4
71133: PUSH
71134: LD_VAR 0 5
71138: DIFF
71139: ST_TO_ADDR
71140: GO 71099
71142: POP
71143: POP
// end ;
71144: LD_VAR 0 4
71148: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
71149: LD_INT 0
71151: PPUSH
71152: PPUSH
71153: PPUSH
// result := true ;
71154: LD_ADDR_VAR 0 3
71158: PUSH
71159: LD_INT 1
71161: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
71162: LD_ADDR_VAR 0 5
71166: PUSH
71167: LD_VAR 0 2
71171: PPUSH
71172: CALL_OW 480
71176: ST_TO_ADDR
// if not tmp then
71177: LD_VAR 0 5
71181: NOT
71182: IFFALSE 71186
// exit ;
71184: GO 71235
// for i in tmp do
71186: LD_ADDR_VAR 0 4
71190: PUSH
71191: LD_VAR 0 5
71195: PUSH
71196: FOR_IN
71197: IFFALSE 71233
// if GetTech ( i , side ) <> state_researched then
71199: LD_VAR 0 4
71203: PPUSH
71204: LD_VAR 0 1
71208: PPUSH
71209: CALL_OW 321
71213: PUSH
71214: LD_INT 2
71216: NONEQUAL
71217: IFFALSE 71231
// begin result := false ;
71219: LD_ADDR_VAR 0 3
71223: PUSH
71224: LD_INT 0
71226: ST_TO_ADDR
// exit ;
71227: POP
71228: POP
71229: GO 71235
// end ;
71231: GO 71196
71233: POP
71234: POP
// end ;
71235: LD_VAR 0 3
71239: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
71240: LD_INT 0
71242: PPUSH
71243: PPUSH
71244: PPUSH
71245: PPUSH
71246: PPUSH
71247: PPUSH
71248: PPUSH
71249: PPUSH
71250: PPUSH
71251: PPUSH
71252: PPUSH
71253: PPUSH
71254: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
71255: LD_VAR 0 1
71259: NOT
71260: PUSH
71261: LD_VAR 0 1
71265: PPUSH
71266: CALL_OW 257
71270: PUSH
71271: LD_INT 9
71273: NONEQUAL
71274: OR
71275: IFFALSE 71279
// exit ;
71277: GO 71852
// side := GetSide ( unit ) ;
71279: LD_ADDR_VAR 0 9
71283: PUSH
71284: LD_VAR 0 1
71288: PPUSH
71289: CALL_OW 255
71293: ST_TO_ADDR
// tech_space := tech_spacanom ;
71294: LD_ADDR_VAR 0 12
71298: PUSH
71299: LD_INT 29
71301: ST_TO_ADDR
// tech_time := tech_taurad ;
71302: LD_ADDR_VAR 0 13
71306: PUSH
71307: LD_INT 28
71309: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
71310: LD_ADDR_VAR 0 11
71314: PUSH
71315: LD_VAR 0 1
71319: PPUSH
71320: CALL_OW 310
71324: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
71325: LD_VAR 0 11
71329: PPUSH
71330: CALL_OW 247
71334: PUSH
71335: LD_INT 2
71337: EQUAL
71338: IFFALSE 71342
// exit ;
71340: GO 71852
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71342: LD_ADDR_VAR 0 8
71346: PUSH
71347: LD_INT 81
71349: PUSH
71350: LD_VAR 0 9
71354: PUSH
71355: EMPTY
71356: LIST
71357: LIST
71358: PUSH
71359: LD_INT 3
71361: PUSH
71362: LD_INT 21
71364: PUSH
71365: LD_INT 3
71367: PUSH
71368: EMPTY
71369: LIST
71370: LIST
71371: PUSH
71372: EMPTY
71373: LIST
71374: LIST
71375: PUSH
71376: EMPTY
71377: LIST
71378: LIST
71379: PPUSH
71380: CALL_OW 69
71384: ST_TO_ADDR
// if not tmp then
71385: LD_VAR 0 8
71389: NOT
71390: IFFALSE 71394
// exit ;
71392: GO 71852
// if in_unit then
71394: LD_VAR 0 11
71398: IFFALSE 71422
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
71400: LD_ADDR_VAR 0 10
71404: PUSH
71405: LD_VAR 0 8
71409: PPUSH
71410: LD_VAR 0 11
71414: PPUSH
71415: CALL_OW 74
71419: ST_TO_ADDR
71420: GO 71442
// enemy := NearestUnitToUnit ( tmp , unit ) ;
71422: LD_ADDR_VAR 0 10
71426: PUSH
71427: LD_VAR 0 8
71431: PPUSH
71432: LD_VAR 0 1
71436: PPUSH
71437: CALL_OW 74
71441: ST_TO_ADDR
// if not enemy then
71442: LD_VAR 0 10
71446: NOT
71447: IFFALSE 71451
// exit ;
71449: GO 71852
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
71451: LD_VAR 0 11
71455: PUSH
71456: LD_VAR 0 11
71460: PPUSH
71461: LD_VAR 0 10
71465: PPUSH
71466: CALL_OW 296
71470: PUSH
71471: LD_INT 13
71473: GREATER
71474: AND
71475: PUSH
71476: LD_VAR 0 1
71480: PPUSH
71481: LD_VAR 0 10
71485: PPUSH
71486: CALL_OW 296
71490: PUSH
71491: LD_INT 12
71493: GREATER
71494: OR
71495: IFFALSE 71499
// exit ;
71497: GO 71852
// missile := [ 1 ] ;
71499: LD_ADDR_VAR 0 14
71503: PUSH
71504: LD_INT 1
71506: PUSH
71507: EMPTY
71508: LIST
71509: ST_TO_ADDR
// if Researched ( side , tech_space ) then
71510: LD_VAR 0 9
71514: PPUSH
71515: LD_VAR 0 12
71519: PPUSH
71520: CALL_OW 325
71524: IFFALSE 71553
// missile := Replace ( missile , missile + 1 , 2 ) ;
71526: LD_ADDR_VAR 0 14
71530: PUSH
71531: LD_VAR 0 14
71535: PPUSH
71536: LD_VAR 0 14
71540: PUSH
71541: LD_INT 1
71543: PLUS
71544: PPUSH
71545: LD_INT 2
71547: PPUSH
71548: CALL_OW 1
71552: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
71553: LD_VAR 0 9
71557: PPUSH
71558: LD_VAR 0 13
71562: PPUSH
71563: CALL_OW 325
71567: PUSH
71568: LD_VAR 0 10
71572: PPUSH
71573: CALL_OW 255
71577: PPUSH
71578: LD_VAR 0 13
71582: PPUSH
71583: CALL_OW 325
71587: NOT
71588: AND
71589: IFFALSE 71618
// missile := Replace ( missile , missile + 1 , 3 ) ;
71591: LD_ADDR_VAR 0 14
71595: PUSH
71596: LD_VAR 0 14
71600: PPUSH
71601: LD_VAR 0 14
71605: PUSH
71606: LD_INT 1
71608: PLUS
71609: PPUSH
71610: LD_INT 3
71612: PPUSH
71613: CALL_OW 1
71617: ST_TO_ADDR
// if missile < 2 then
71618: LD_VAR 0 14
71622: PUSH
71623: LD_INT 2
71625: LESS
71626: IFFALSE 71630
// exit ;
71628: GO 71852
// x := GetX ( enemy ) ;
71630: LD_ADDR_VAR 0 4
71634: PUSH
71635: LD_VAR 0 10
71639: PPUSH
71640: CALL_OW 250
71644: ST_TO_ADDR
// y := GetY ( enemy ) ;
71645: LD_ADDR_VAR 0 5
71649: PUSH
71650: LD_VAR 0 10
71654: PPUSH
71655: CALL_OW 251
71659: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
71660: LD_ADDR_VAR 0 6
71664: PUSH
71665: LD_VAR 0 4
71669: PUSH
71670: LD_INT 1
71672: NEG
71673: PPUSH
71674: LD_INT 1
71676: PPUSH
71677: CALL_OW 12
71681: PLUS
71682: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
71683: LD_ADDR_VAR 0 7
71687: PUSH
71688: LD_VAR 0 5
71692: PUSH
71693: LD_INT 1
71695: NEG
71696: PPUSH
71697: LD_INT 1
71699: PPUSH
71700: CALL_OW 12
71704: PLUS
71705: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
71706: LD_VAR 0 6
71710: PPUSH
71711: LD_VAR 0 7
71715: PPUSH
71716: CALL_OW 488
71720: NOT
71721: IFFALSE 71743
// begin _x := x ;
71723: LD_ADDR_VAR 0 6
71727: PUSH
71728: LD_VAR 0 4
71732: ST_TO_ADDR
// _y := y ;
71733: LD_ADDR_VAR 0 7
71737: PUSH
71738: LD_VAR 0 5
71742: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
71743: LD_ADDR_VAR 0 3
71747: PUSH
71748: LD_INT 1
71750: PPUSH
71751: LD_VAR 0 14
71755: PPUSH
71756: CALL_OW 12
71760: ST_TO_ADDR
// case i of 1 :
71761: LD_VAR 0 3
71765: PUSH
71766: LD_INT 1
71768: DOUBLE
71769: EQUAL
71770: IFTRUE 71774
71772: GO 71791
71774: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
71775: LD_VAR 0 1
71779: PPUSH
71780: LD_VAR 0 10
71784: PPUSH
71785: CALL_OW 115
71789: GO 71852
71791: LD_INT 2
71793: DOUBLE
71794: EQUAL
71795: IFTRUE 71799
71797: GO 71821
71799: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
71800: LD_VAR 0 1
71804: PPUSH
71805: LD_VAR 0 6
71809: PPUSH
71810: LD_VAR 0 7
71814: PPUSH
71815: CALL_OW 153
71819: GO 71852
71821: LD_INT 3
71823: DOUBLE
71824: EQUAL
71825: IFTRUE 71829
71827: GO 71851
71829: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
71830: LD_VAR 0 1
71834: PPUSH
71835: LD_VAR 0 6
71839: PPUSH
71840: LD_VAR 0 7
71844: PPUSH
71845: CALL_OW 154
71849: GO 71852
71851: POP
// end ;
71852: LD_VAR 0 2
71856: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
71857: LD_INT 0
71859: PPUSH
71860: PPUSH
71861: PPUSH
71862: PPUSH
71863: PPUSH
71864: PPUSH
// if not unit or not building then
71865: LD_VAR 0 1
71869: NOT
71870: PUSH
71871: LD_VAR 0 2
71875: NOT
71876: OR
71877: IFFALSE 71881
// exit ;
71879: GO 72039
// x := GetX ( building ) ;
71881: LD_ADDR_VAR 0 5
71885: PUSH
71886: LD_VAR 0 2
71890: PPUSH
71891: CALL_OW 250
71895: ST_TO_ADDR
// y := GetY ( building ) ;
71896: LD_ADDR_VAR 0 6
71900: PUSH
71901: LD_VAR 0 2
71905: PPUSH
71906: CALL_OW 251
71910: ST_TO_ADDR
// for i = 0 to 5 do
71911: LD_ADDR_VAR 0 4
71915: PUSH
71916: DOUBLE
71917: LD_INT 0
71919: DEC
71920: ST_TO_ADDR
71921: LD_INT 5
71923: PUSH
71924: FOR_TO
71925: IFFALSE 72037
// begin _x := ShiftX ( x , i , 3 ) ;
71927: LD_ADDR_VAR 0 7
71931: PUSH
71932: LD_VAR 0 5
71936: PPUSH
71937: LD_VAR 0 4
71941: PPUSH
71942: LD_INT 3
71944: PPUSH
71945: CALL_OW 272
71949: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
71950: LD_ADDR_VAR 0 8
71954: PUSH
71955: LD_VAR 0 6
71959: PPUSH
71960: LD_VAR 0 4
71964: PPUSH
71965: LD_INT 3
71967: PPUSH
71968: CALL_OW 273
71972: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
71973: LD_VAR 0 7
71977: PPUSH
71978: LD_VAR 0 8
71982: PPUSH
71983: CALL_OW 488
71987: NOT
71988: IFFALSE 71992
// continue ;
71990: GO 71924
// if HexInfo ( _x , _y ) = 0 then
71992: LD_VAR 0 7
71996: PPUSH
71997: LD_VAR 0 8
72001: PPUSH
72002: CALL_OW 428
72006: PUSH
72007: LD_INT 0
72009: EQUAL
72010: IFFALSE 72035
// begin ComMoveXY ( unit , _x , _y ) ;
72012: LD_VAR 0 1
72016: PPUSH
72017: LD_VAR 0 7
72021: PPUSH
72022: LD_VAR 0 8
72026: PPUSH
72027: CALL_OW 111
// exit ;
72031: POP
72032: POP
72033: GO 72039
// end ; end ;
72035: GO 71924
72037: POP
72038: POP
// end ;
72039: LD_VAR 0 3
72043: RET
// export function ScanBase ( side , base_area ) ; begin
72044: LD_INT 0
72046: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
72047: LD_ADDR_VAR 0 3
72051: PUSH
72052: LD_VAR 0 2
72056: PPUSH
72057: LD_INT 81
72059: PUSH
72060: LD_VAR 0 1
72064: PUSH
72065: EMPTY
72066: LIST
72067: LIST
72068: PPUSH
72069: CALL_OW 70
72073: ST_TO_ADDR
// end ;
72074: LD_VAR 0 3
72078: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
72079: LD_INT 0
72081: PPUSH
72082: PPUSH
72083: PPUSH
72084: PPUSH
// result := false ;
72085: LD_ADDR_VAR 0 2
72089: PUSH
72090: LD_INT 0
72092: ST_TO_ADDR
// side := GetSide ( unit ) ;
72093: LD_ADDR_VAR 0 3
72097: PUSH
72098: LD_VAR 0 1
72102: PPUSH
72103: CALL_OW 255
72107: ST_TO_ADDR
// nat := GetNation ( unit ) ;
72108: LD_ADDR_VAR 0 4
72112: PUSH
72113: LD_VAR 0 1
72117: PPUSH
72118: CALL_OW 248
72122: ST_TO_ADDR
// case nat of 1 :
72123: LD_VAR 0 4
72127: PUSH
72128: LD_INT 1
72130: DOUBLE
72131: EQUAL
72132: IFTRUE 72136
72134: GO 72147
72136: POP
// tech := tech_lassight ; 2 :
72137: LD_ADDR_VAR 0 5
72141: PUSH
72142: LD_INT 12
72144: ST_TO_ADDR
72145: GO 72186
72147: LD_INT 2
72149: DOUBLE
72150: EQUAL
72151: IFTRUE 72155
72153: GO 72166
72155: POP
// tech := tech_mortar ; 3 :
72156: LD_ADDR_VAR 0 5
72160: PUSH
72161: LD_INT 41
72163: ST_TO_ADDR
72164: GO 72186
72166: LD_INT 3
72168: DOUBLE
72169: EQUAL
72170: IFTRUE 72174
72172: GO 72185
72174: POP
// tech := tech_bazooka ; end ;
72175: LD_ADDR_VAR 0 5
72179: PUSH
72180: LD_INT 44
72182: ST_TO_ADDR
72183: GO 72186
72185: POP
// if Researched ( side , tech ) then
72186: LD_VAR 0 3
72190: PPUSH
72191: LD_VAR 0 5
72195: PPUSH
72196: CALL_OW 325
72200: IFFALSE 72227
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
72202: LD_ADDR_VAR 0 2
72206: PUSH
72207: LD_INT 5
72209: PUSH
72210: LD_INT 8
72212: PUSH
72213: LD_INT 9
72215: PUSH
72216: EMPTY
72217: LIST
72218: LIST
72219: LIST
72220: PUSH
72221: LD_VAR 0 4
72225: ARRAY
72226: ST_TO_ADDR
// end ;
72227: LD_VAR 0 2
72231: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
72232: LD_INT 0
72234: PPUSH
72235: PPUSH
72236: PPUSH
// if not mines then
72237: LD_VAR 0 2
72241: NOT
72242: IFFALSE 72246
// exit ;
72244: GO 72390
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72246: LD_ADDR_VAR 0 5
72250: PUSH
72251: LD_INT 81
72253: PUSH
72254: LD_VAR 0 1
72258: PUSH
72259: EMPTY
72260: LIST
72261: LIST
72262: PUSH
72263: LD_INT 3
72265: PUSH
72266: LD_INT 21
72268: PUSH
72269: LD_INT 3
72271: PUSH
72272: EMPTY
72273: LIST
72274: LIST
72275: PUSH
72276: EMPTY
72277: LIST
72278: LIST
72279: PUSH
72280: EMPTY
72281: LIST
72282: LIST
72283: PPUSH
72284: CALL_OW 69
72288: ST_TO_ADDR
// for i in mines do
72289: LD_ADDR_VAR 0 4
72293: PUSH
72294: LD_VAR 0 2
72298: PUSH
72299: FOR_IN
72300: IFFALSE 72388
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
72302: LD_VAR 0 4
72306: PUSH
72307: LD_INT 1
72309: ARRAY
72310: PPUSH
72311: LD_VAR 0 4
72315: PUSH
72316: LD_INT 2
72318: ARRAY
72319: PPUSH
72320: CALL_OW 458
72324: NOT
72325: IFFALSE 72329
// continue ;
72327: GO 72299
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
72329: LD_VAR 0 4
72333: PUSH
72334: LD_INT 1
72336: ARRAY
72337: PPUSH
72338: LD_VAR 0 4
72342: PUSH
72343: LD_INT 2
72345: ARRAY
72346: PPUSH
72347: CALL_OW 428
72351: PUSH
72352: LD_VAR 0 5
72356: IN
72357: IFFALSE 72386
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
72359: LD_VAR 0 4
72363: PUSH
72364: LD_INT 1
72366: ARRAY
72367: PPUSH
72368: LD_VAR 0 4
72372: PUSH
72373: LD_INT 2
72375: ARRAY
72376: PPUSH
72377: LD_VAR 0 1
72381: PPUSH
72382: CALL_OW 456
// end ;
72386: GO 72299
72388: POP
72389: POP
// end ;
72390: LD_VAR 0 3
72394: RET
// export function Count ( array ) ; begin
72395: LD_INT 0
72397: PPUSH
// result := array + 0 ;
72398: LD_ADDR_VAR 0 2
72402: PUSH
72403: LD_VAR 0 1
72407: PUSH
72408: LD_INT 0
72410: PLUS
72411: ST_TO_ADDR
// end ;
72412: LD_VAR 0 2
72416: RET
// export function IsEmpty ( building ) ; begin
72417: LD_INT 0
72419: PPUSH
// if not building then
72420: LD_VAR 0 1
72424: NOT
72425: IFFALSE 72429
// exit ;
72427: GO 72472
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
72429: LD_ADDR_VAR 0 2
72433: PUSH
72434: LD_VAR 0 1
72438: PUSH
72439: LD_INT 22
72441: PUSH
72442: LD_VAR 0 1
72446: PPUSH
72447: CALL_OW 255
72451: PUSH
72452: EMPTY
72453: LIST
72454: LIST
72455: PUSH
72456: LD_INT 58
72458: PUSH
72459: EMPTY
72460: LIST
72461: PUSH
72462: EMPTY
72463: LIST
72464: LIST
72465: PPUSH
72466: CALL_OW 69
72470: IN
72471: ST_TO_ADDR
// end ;
72472: LD_VAR 0 2
72476: RET
// export function IsNotFull ( building ) ; var places ; begin
72477: LD_INT 0
72479: PPUSH
72480: PPUSH
// if not building then
72481: LD_VAR 0 1
72485: NOT
72486: IFFALSE 72490
// exit ;
72488: GO 72518
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
72490: LD_ADDR_VAR 0 2
72494: PUSH
72495: LD_VAR 0 1
72499: PPUSH
72500: LD_INT 3
72502: PUSH
72503: LD_INT 62
72505: PUSH
72506: EMPTY
72507: LIST
72508: PUSH
72509: EMPTY
72510: LIST
72511: LIST
72512: PPUSH
72513: CALL_OW 72
72517: ST_TO_ADDR
// end ;
72518: LD_VAR 0 2
72522: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
72523: LD_INT 0
72525: PPUSH
72526: PPUSH
72527: PPUSH
72528: PPUSH
// tmp := [ ] ;
72529: LD_ADDR_VAR 0 3
72533: PUSH
72534: EMPTY
72535: ST_TO_ADDR
// list := [ ] ;
72536: LD_ADDR_VAR 0 5
72540: PUSH
72541: EMPTY
72542: ST_TO_ADDR
// for i = 16 to 25 do
72543: LD_ADDR_VAR 0 4
72547: PUSH
72548: DOUBLE
72549: LD_INT 16
72551: DEC
72552: ST_TO_ADDR
72553: LD_INT 25
72555: PUSH
72556: FOR_TO
72557: IFFALSE 72630
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
72559: LD_ADDR_VAR 0 3
72563: PUSH
72564: LD_VAR 0 3
72568: PUSH
72569: LD_INT 22
72571: PUSH
72572: LD_VAR 0 1
72576: PPUSH
72577: CALL_OW 255
72581: PUSH
72582: EMPTY
72583: LIST
72584: LIST
72585: PUSH
72586: LD_INT 91
72588: PUSH
72589: LD_VAR 0 1
72593: PUSH
72594: LD_INT 6
72596: PUSH
72597: EMPTY
72598: LIST
72599: LIST
72600: LIST
72601: PUSH
72602: LD_INT 30
72604: PUSH
72605: LD_VAR 0 4
72609: PUSH
72610: EMPTY
72611: LIST
72612: LIST
72613: PUSH
72614: EMPTY
72615: LIST
72616: LIST
72617: LIST
72618: PUSH
72619: EMPTY
72620: LIST
72621: PPUSH
72622: CALL_OW 69
72626: ADD
72627: ST_TO_ADDR
72628: GO 72556
72630: POP
72631: POP
// for i = 1 to tmp do
72632: LD_ADDR_VAR 0 4
72636: PUSH
72637: DOUBLE
72638: LD_INT 1
72640: DEC
72641: ST_TO_ADDR
72642: LD_VAR 0 3
72646: PUSH
72647: FOR_TO
72648: IFFALSE 72736
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
72650: LD_ADDR_VAR 0 5
72654: PUSH
72655: LD_VAR 0 5
72659: PUSH
72660: LD_VAR 0 3
72664: PUSH
72665: LD_VAR 0 4
72669: ARRAY
72670: PPUSH
72671: CALL_OW 266
72675: PUSH
72676: LD_VAR 0 3
72680: PUSH
72681: LD_VAR 0 4
72685: ARRAY
72686: PPUSH
72687: CALL_OW 250
72691: PUSH
72692: LD_VAR 0 3
72696: PUSH
72697: LD_VAR 0 4
72701: ARRAY
72702: PPUSH
72703: CALL_OW 251
72707: PUSH
72708: LD_VAR 0 3
72712: PUSH
72713: LD_VAR 0 4
72717: ARRAY
72718: PPUSH
72719: CALL_OW 254
72723: PUSH
72724: EMPTY
72725: LIST
72726: LIST
72727: LIST
72728: LIST
72729: PUSH
72730: EMPTY
72731: LIST
72732: ADD
72733: ST_TO_ADDR
72734: GO 72647
72736: POP
72737: POP
// result := list ;
72738: LD_ADDR_VAR 0 2
72742: PUSH
72743: LD_VAR 0 5
72747: ST_TO_ADDR
// end ;
72748: LD_VAR 0 2
72752: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
72753: LD_INT 0
72755: PPUSH
72756: PPUSH
72757: PPUSH
72758: PPUSH
72759: PPUSH
72760: PPUSH
72761: PPUSH
// if not factory then
72762: LD_VAR 0 1
72766: NOT
72767: IFFALSE 72771
// exit ;
72769: GO 73364
// if control = control_apeman then
72771: LD_VAR 0 4
72775: PUSH
72776: LD_INT 5
72778: EQUAL
72779: IFFALSE 72888
// begin tmp := UnitsInside ( factory ) ;
72781: LD_ADDR_VAR 0 8
72785: PUSH
72786: LD_VAR 0 1
72790: PPUSH
72791: CALL_OW 313
72795: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
72796: LD_VAR 0 8
72800: PPUSH
72801: LD_INT 25
72803: PUSH
72804: LD_INT 12
72806: PUSH
72807: EMPTY
72808: LIST
72809: LIST
72810: PPUSH
72811: CALL_OW 72
72815: NOT
72816: IFFALSE 72826
// control := control_manual ;
72818: LD_ADDR_VAR 0 4
72822: PUSH
72823: LD_INT 1
72825: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
72826: LD_ADDR_VAR 0 8
72830: PUSH
72831: LD_VAR 0 1
72835: PPUSH
72836: CALL 72523 0 1
72840: ST_TO_ADDR
// if tmp then
72841: LD_VAR 0 8
72845: IFFALSE 72888
// begin for i in tmp do
72847: LD_ADDR_VAR 0 7
72851: PUSH
72852: LD_VAR 0 8
72856: PUSH
72857: FOR_IN
72858: IFFALSE 72886
// if i [ 1 ] = b_ext_radio then
72860: LD_VAR 0 7
72864: PUSH
72865: LD_INT 1
72867: ARRAY
72868: PUSH
72869: LD_INT 22
72871: EQUAL
72872: IFFALSE 72884
// begin control := control_remote ;
72874: LD_ADDR_VAR 0 4
72878: PUSH
72879: LD_INT 2
72881: ST_TO_ADDR
// break ;
72882: GO 72886
// end ;
72884: GO 72857
72886: POP
72887: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
72888: LD_VAR 0 1
72892: PPUSH
72893: LD_VAR 0 2
72897: PPUSH
72898: LD_VAR 0 3
72902: PPUSH
72903: LD_VAR 0 4
72907: PPUSH
72908: LD_VAR 0 5
72912: PPUSH
72913: CALL_OW 448
72917: IFFALSE 72952
// begin result := [ chassis , engine , control , weapon ] ;
72919: LD_ADDR_VAR 0 6
72923: PUSH
72924: LD_VAR 0 2
72928: PUSH
72929: LD_VAR 0 3
72933: PUSH
72934: LD_VAR 0 4
72938: PUSH
72939: LD_VAR 0 5
72943: PUSH
72944: EMPTY
72945: LIST
72946: LIST
72947: LIST
72948: LIST
72949: ST_TO_ADDR
// exit ;
72950: GO 73364
// end ; _chassis := AvailableChassisList ( factory ) ;
72952: LD_ADDR_VAR 0 9
72956: PUSH
72957: LD_VAR 0 1
72961: PPUSH
72962: CALL_OW 475
72966: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
72967: LD_ADDR_VAR 0 11
72971: PUSH
72972: LD_VAR 0 1
72976: PPUSH
72977: CALL_OW 476
72981: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
72982: LD_ADDR_VAR 0 12
72986: PUSH
72987: LD_VAR 0 1
72991: PPUSH
72992: CALL_OW 477
72996: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
72997: LD_ADDR_VAR 0 10
73001: PUSH
73002: LD_VAR 0 1
73006: PPUSH
73007: CALL_OW 478
73011: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
73012: LD_VAR 0 9
73016: NOT
73017: PUSH
73018: LD_VAR 0 11
73022: NOT
73023: OR
73024: PUSH
73025: LD_VAR 0 12
73029: NOT
73030: OR
73031: PUSH
73032: LD_VAR 0 10
73036: NOT
73037: OR
73038: IFFALSE 73073
// begin result := [ chassis , engine , control , weapon ] ;
73040: LD_ADDR_VAR 0 6
73044: PUSH
73045: LD_VAR 0 2
73049: PUSH
73050: LD_VAR 0 3
73054: PUSH
73055: LD_VAR 0 4
73059: PUSH
73060: LD_VAR 0 5
73064: PUSH
73065: EMPTY
73066: LIST
73067: LIST
73068: LIST
73069: LIST
73070: ST_TO_ADDR
// exit ;
73071: GO 73364
// end ; if not chassis in _chassis then
73073: LD_VAR 0 2
73077: PUSH
73078: LD_VAR 0 9
73082: IN
73083: NOT
73084: IFFALSE 73110
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
73086: LD_ADDR_VAR 0 2
73090: PUSH
73091: LD_VAR 0 9
73095: PUSH
73096: LD_INT 1
73098: PPUSH
73099: LD_VAR 0 9
73103: PPUSH
73104: CALL_OW 12
73108: ARRAY
73109: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
73110: LD_VAR 0 2
73114: PPUSH
73115: LD_VAR 0 3
73119: PPUSH
73120: CALL 73369 0 2
73124: NOT
73125: IFFALSE 73184
// repeat engine := _engine [ 1 ] ;
73127: LD_ADDR_VAR 0 3
73131: PUSH
73132: LD_VAR 0 11
73136: PUSH
73137: LD_INT 1
73139: ARRAY
73140: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
73141: LD_ADDR_VAR 0 11
73145: PUSH
73146: LD_VAR 0 11
73150: PPUSH
73151: LD_INT 1
73153: PPUSH
73154: CALL_OW 3
73158: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
73159: LD_VAR 0 2
73163: PPUSH
73164: LD_VAR 0 3
73168: PPUSH
73169: CALL 73369 0 2
73173: PUSH
73174: LD_VAR 0 11
73178: PUSH
73179: EMPTY
73180: EQUAL
73181: OR
73182: IFFALSE 73127
// if not control in _control then
73184: LD_VAR 0 4
73188: PUSH
73189: LD_VAR 0 12
73193: IN
73194: NOT
73195: IFFALSE 73221
// control := _control [ rand ( 1 , _control ) ] ;
73197: LD_ADDR_VAR 0 4
73201: PUSH
73202: LD_VAR 0 12
73206: PUSH
73207: LD_INT 1
73209: PPUSH
73210: LD_VAR 0 12
73214: PPUSH
73215: CALL_OW 12
73219: ARRAY
73220: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
73221: LD_VAR 0 2
73225: PPUSH
73226: LD_VAR 0 5
73230: PPUSH
73231: CALL 73589 0 2
73235: NOT
73236: IFFALSE 73295
// repeat weapon := _weapon [ 1 ] ;
73238: LD_ADDR_VAR 0 5
73242: PUSH
73243: LD_VAR 0 10
73247: PUSH
73248: LD_INT 1
73250: ARRAY
73251: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
73252: LD_ADDR_VAR 0 10
73256: PUSH
73257: LD_VAR 0 10
73261: PPUSH
73262: LD_INT 1
73264: PPUSH
73265: CALL_OW 3
73269: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
73270: LD_VAR 0 2
73274: PPUSH
73275: LD_VAR 0 5
73279: PPUSH
73280: CALL 73589 0 2
73284: PUSH
73285: LD_VAR 0 10
73289: PUSH
73290: EMPTY
73291: EQUAL
73292: OR
73293: IFFALSE 73238
// result := [ ] ;
73295: LD_ADDR_VAR 0 6
73299: PUSH
73300: EMPTY
73301: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
73302: LD_VAR 0 1
73306: PPUSH
73307: LD_VAR 0 2
73311: PPUSH
73312: LD_VAR 0 3
73316: PPUSH
73317: LD_VAR 0 4
73321: PPUSH
73322: LD_VAR 0 5
73326: PPUSH
73327: CALL_OW 448
73331: IFFALSE 73364
// result := [ chassis , engine , control , weapon ] ;
73333: LD_ADDR_VAR 0 6
73337: PUSH
73338: LD_VAR 0 2
73342: PUSH
73343: LD_VAR 0 3
73347: PUSH
73348: LD_VAR 0 4
73352: PUSH
73353: LD_VAR 0 5
73357: PUSH
73358: EMPTY
73359: LIST
73360: LIST
73361: LIST
73362: LIST
73363: ST_TO_ADDR
// end ;
73364: LD_VAR 0 6
73368: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
73369: LD_INT 0
73371: PPUSH
// if not chassis or not engine then
73372: LD_VAR 0 1
73376: NOT
73377: PUSH
73378: LD_VAR 0 2
73382: NOT
73383: OR
73384: IFFALSE 73388
// exit ;
73386: GO 73584
// case engine of engine_solar :
73388: LD_VAR 0 2
73392: PUSH
73393: LD_INT 2
73395: DOUBLE
73396: EQUAL
73397: IFTRUE 73401
73399: GO 73439
73401: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
73402: LD_ADDR_VAR 0 3
73406: PUSH
73407: LD_INT 11
73409: PUSH
73410: LD_INT 12
73412: PUSH
73413: LD_INT 13
73415: PUSH
73416: LD_INT 14
73418: PUSH
73419: LD_INT 1
73421: PUSH
73422: LD_INT 2
73424: PUSH
73425: LD_INT 3
73427: PUSH
73428: EMPTY
73429: LIST
73430: LIST
73431: LIST
73432: LIST
73433: LIST
73434: LIST
73435: LIST
73436: ST_TO_ADDR
73437: GO 73568
73439: LD_INT 1
73441: DOUBLE
73442: EQUAL
73443: IFTRUE 73447
73445: GO 73509
73447: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
73448: LD_ADDR_VAR 0 3
73452: PUSH
73453: LD_INT 11
73455: PUSH
73456: LD_INT 12
73458: PUSH
73459: LD_INT 13
73461: PUSH
73462: LD_INT 14
73464: PUSH
73465: LD_INT 1
73467: PUSH
73468: LD_INT 2
73470: PUSH
73471: LD_INT 3
73473: PUSH
73474: LD_INT 4
73476: PUSH
73477: LD_INT 5
73479: PUSH
73480: LD_INT 21
73482: PUSH
73483: LD_INT 23
73485: PUSH
73486: LD_INT 22
73488: PUSH
73489: LD_INT 24
73491: PUSH
73492: EMPTY
73493: LIST
73494: LIST
73495: LIST
73496: LIST
73497: LIST
73498: LIST
73499: LIST
73500: LIST
73501: LIST
73502: LIST
73503: LIST
73504: LIST
73505: LIST
73506: ST_TO_ADDR
73507: GO 73568
73509: LD_INT 3
73511: DOUBLE
73512: EQUAL
73513: IFTRUE 73517
73515: GO 73567
73517: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
73518: LD_ADDR_VAR 0 3
73522: PUSH
73523: LD_INT 13
73525: PUSH
73526: LD_INT 14
73528: PUSH
73529: LD_INT 2
73531: PUSH
73532: LD_INT 3
73534: PUSH
73535: LD_INT 4
73537: PUSH
73538: LD_INT 5
73540: PUSH
73541: LD_INT 21
73543: PUSH
73544: LD_INT 22
73546: PUSH
73547: LD_INT 23
73549: PUSH
73550: LD_INT 24
73552: PUSH
73553: EMPTY
73554: LIST
73555: LIST
73556: LIST
73557: LIST
73558: LIST
73559: LIST
73560: LIST
73561: LIST
73562: LIST
73563: LIST
73564: ST_TO_ADDR
73565: GO 73568
73567: POP
// result := ( chassis in result ) ;
73568: LD_ADDR_VAR 0 3
73572: PUSH
73573: LD_VAR 0 1
73577: PUSH
73578: LD_VAR 0 3
73582: IN
73583: ST_TO_ADDR
// end ;
73584: LD_VAR 0 3
73588: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
73589: LD_INT 0
73591: PPUSH
// if not chassis or not weapon then
73592: LD_VAR 0 1
73596: NOT
73597: PUSH
73598: LD_VAR 0 2
73602: NOT
73603: OR
73604: IFFALSE 73608
// exit ;
73606: GO 74668
// case weapon of us_machine_gun :
73608: LD_VAR 0 2
73612: PUSH
73613: LD_INT 2
73615: DOUBLE
73616: EQUAL
73617: IFTRUE 73621
73619: GO 73651
73621: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
73622: LD_ADDR_VAR 0 3
73626: PUSH
73627: LD_INT 1
73629: PUSH
73630: LD_INT 2
73632: PUSH
73633: LD_INT 3
73635: PUSH
73636: LD_INT 4
73638: PUSH
73639: LD_INT 5
73641: PUSH
73642: EMPTY
73643: LIST
73644: LIST
73645: LIST
73646: LIST
73647: LIST
73648: ST_TO_ADDR
73649: GO 74652
73651: LD_INT 3
73653: DOUBLE
73654: EQUAL
73655: IFTRUE 73659
73657: GO 73689
73659: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
73660: LD_ADDR_VAR 0 3
73664: PUSH
73665: LD_INT 1
73667: PUSH
73668: LD_INT 2
73670: PUSH
73671: LD_INT 3
73673: PUSH
73674: LD_INT 4
73676: PUSH
73677: LD_INT 5
73679: PUSH
73680: EMPTY
73681: LIST
73682: LIST
73683: LIST
73684: LIST
73685: LIST
73686: ST_TO_ADDR
73687: GO 74652
73689: LD_INT 11
73691: DOUBLE
73692: EQUAL
73693: IFTRUE 73697
73695: GO 73727
73697: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
73698: LD_ADDR_VAR 0 3
73702: PUSH
73703: LD_INT 1
73705: PUSH
73706: LD_INT 2
73708: PUSH
73709: LD_INT 3
73711: PUSH
73712: LD_INT 4
73714: PUSH
73715: LD_INT 5
73717: PUSH
73718: EMPTY
73719: LIST
73720: LIST
73721: LIST
73722: LIST
73723: LIST
73724: ST_TO_ADDR
73725: GO 74652
73727: LD_INT 4
73729: DOUBLE
73730: EQUAL
73731: IFTRUE 73735
73733: GO 73761
73735: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
73736: LD_ADDR_VAR 0 3
73740: PUSH
73741: LD_INT 2
73743: PUSH
73744: LD_INT 3
73746: PUSH
73747: LD_INT 4
73749: PUSH
73750: LD_INT 5
73752: PUSH
73753: EMPTY
73754: LIST
73755: LIST
73756: LIST
73757: LIST
73758: ST_TO_ADDR
73759: GO 74652
73761: LD_INT 5
73763: DOUBLE
73764: EQUAL
73765: IFTRUE 73769
73767: GO 73795
73769: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
73770: LD_ADDR_VAR 0 3
73774: PUSH
73775: LD_INT 2
73777: PUSH
73778: LD_INT 3
73780: PUSH
73781: LD_INT 4
73783: PUSH
73784: LD_INT 5
73786: PUSH
73787: EMPTY
73788: LIST
73789: LIST
73790: LIST
73791: LIST
73792: ST_TO_ADDR
73793: GO 74652
73795: LD_INT 9
73797: DOUBLE
73798: EQUAL
73799: IFTRUE 73803
73801: GO 73829
73803: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
73804: LD_ADDR_VAR 0 3
73808: PUSH
73809: LD_INT 2
73811: PUSH
73812: LD_INT 3
73814: PUSH
73815: LD_INT 4
73817: PUSH
73818: LD_INT 5
73820: PUSH
73821: EMPTY
73822: LIST
73823: LIST
73824: LIST
73825: LIST
73826: ST_TO_ADDR
73827: GO 74652
73829: LD_INT 7
73831: DOUBLE
73832: EQUAL
73833: IFTRUE 73837
73835: GO 73863
73837: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
73838: LD_ADDR_VAR 0 3
73842: PUSH
73843: LD_INT 2
73845: PUSH
73846: LD_INT 3
73848: PUSH
73849: LD_INT 4
73851: PUSH
73852: LD_INT 5
73854: PUSH
73855: EMPTY
73856: LIST
73857: LIST
73858: LIST
73859: LIST
73860: ST_TO_ADDR
73861: GO 74652
73863: LD_INT 12
73865: DOUBLE
73866: EQUAL
73867: IFTRUE 73871
73869: GO 73897
73871: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
73872: LD_ADDR_VAR 0 3
73876: PUSH
73877: LD_INT 2
73879: PUSH
73880: LD_INT 3
73882: PUSH
73883: LD_INT 4
73885: PUSH
73886: LD_INT 5
73888: PUSH
73889: EMPTY
73890: LIST
73891: LIST
73892: LIST
73893: LIST
73894: ST_TO_ADDR
73895: GO 74652
73897: LD_INT 13
73899: DOUBLE
73900: EQUAL
73901: IFTRUE 73905
73903: GO 73931
73905: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
73906: LD_ADDR_VAR 0 3
73910: PUSH
73911: LD_INT 2
73913: PUSH
73914: LD_INT 3
73916: PUSH
73917: LD_INT 4
73919: PUSH
73920: LD_INT 5
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: LIST
73927: LIST
73928: ST_TO_ADDR
73929: GO 74652
73931: LD_INT 14
73933: DOUBLE
73934: EQUAL
73935: IFTRUE 73939
73937: GO 73957
73939: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
73940: LD_ADDR_VAR 0 3
73944: PUSH
73945: LD_INT 4
73947: PUSH
73948: LD_INT 5
73950: PUSH
73951: EMPTY
73952: LIST
73953: LIST
73954: ST_TO_ADDR
73955: GO 74652
73957: LD_INT 6
73959: DOUBLE
73960: EQUAL
73961: IFTRUE 73965
73963: GO 73983
73965: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
73966: LD_ADDR_VAR 0 3
73970: PUSH
73971: LD_INT 4
73973: PUSH
73974: LD_INT 5
73976: PUSH
73977: EMPTY
73978: LIST
73979: LIST
73980: ST_TO_ADDR
73981: GO 74652
73983: LD_INT 10
73985: DOUBLE
73986: EQUAL
73987: IFTRUE 73991
73989: GO 74009
73991: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
73992: LD_ADDR_VAR 0 3
73996: PUSH
73997: LD_INT 4
73999: PUSH
74000: LD_INT 5
74002: PUSH
74003: EMPTY
74004: LIST
74005: LIST
74006: ST_TO_ADDR
74007: GO 74652
74009: LD_INT 22
74011: DOUBLE
74012: EQUAL
74013: IFTRUE 74017
74015: GO 74043
74017: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
74018: LD_ADDR_VAR 0 3
74022: PUSH
74023: LD_INT 11
74025: PUSH
74026: LD_INT 12
74028: PUSH
74029: LD_INT 13
74031: PUSH
74032: LD_INT 14
74034: PUSH
74035: EMPTY
74036: LIST
74037: LIST
74038: LIST
74039: LIST
74040: ST_TO_ADDR
74041: GO 74652
74043: LD_INT 23
74045: DOUBLE
74046: EQUAL
74047: IFTRUE 74051
74049: GO 74077
74051: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
74052: LD_ADDR_VAR 0 3
74056: PUSH
74057: LD_INT 11
74059: PUSH
74060: LD_INT 12
74062: PUSH
74063: LD_INT 13
74065: PUSH
74066: LD_INT 14
74068: PUSH
74069: EMPTY
74070: LIST
74071: LIST
74072: LIST
74073: LIST
74074: ST_TO_ADDR
74075: GO 74652
74077: LD_INT 24
74079: DOUBLE
74080: EQUAL
74081: IFTRUE 74085
74083: GO 74111
74085: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
74086: LD_ADDR_VAR 0 3
74090: PUSH
74091: LD_INT 11
74093: PUSH
74094: LD_INT 12
74096: PUSH
74097: LD_INT 13
74099: PUSH
74100: LD_INT 14
74102: PUSH
74103: EMPTY
74104: LIST
74105: LIST
74106: LIST
74107: LIST
74108: ST_TO_ADDR
74109: GO 74652
74111: LD_INT 30
74113: DOUBLE
74114: EQUAL
74115: IFTRUE 74119
74117: GO 74145
74119: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
74120: LD_ADDR_VAR 0 3
74124: PUSH
74125: LD_INT 11
74127: PUSH
74128: LD_INT 12
74130: PUSH
74131: LD_INT 13
74133: PUSH
74134: LD_INT 14
74136: PUSH
74137: EMPTY
74138: LIST
74139: LIST
74140: LIST
74141: LIST
74142: ST_TO_ADDR
74143: GO 74652
74145: LD_INT 25
74147: DOUBLE
74148: EQUAL
74149: IFTRUE 74153
74151: GO 74171
74153: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
74154: LD_ADDR_VAR 0 3
74158: PUSH
74159: LD_INT 13
74161: PUSH
74162: LD_INT 14
74164: PUSH
74165: EMPTY
74166: LIST
74167: LIST
74168: ST_TO_ADDR
74169: GO 74652
74171: LD_INT 27
74173: DOUBLE
74174: EQUAL
74175: IFTRUE 74179
74177: GO 74197
74179: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
74180: LD_ADDR_VAR 0 3
74184: PUSH
74185: LD_INT 13
74187: PUSH
74188: LD_INT 14
74190: PUSH
74191: EMPTY
74192: LIST
74193: LIST
74194: ST_TO_ADDR
74195: GO 74652
74197: LD_INT 92
74199: DOUBLE
74200: EQUAL
74201: IFTRUE 74205
74203: GO 74231
74205: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
74206: LD_ADDR_VAR 0 3
74210: PUSH
74211: LD_INT 11
74213: PUSH
74214: LD_INT 12
74216: PUSH
74217: LD_INT 13
74219: PUSH
74220: LD_INT 14
74222: PUSH
74223: EMPTY
74224: LIST
74225: LIST
74226: LIST
74227: LIST
74228: ST_TO_ADDR
74229: GO 74652
74231: LD_INT 28
74233: DOUBLE
74234: EQUAL
74235: IFTRUE 74239
74237: GO 74257
74239: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
74240: LD_ADDR_VAR 0 3
74244: PUSH
74245: LD_INT 13
74247: PUSH
74248: LD_INT 14
74250: PUSH
74251: EMPTY
74252: LIST
74253: LIST
74254: ST_TO_ADDR
74255: GO 74652
74257: LD_INT 29
74259: DOUBLE
74260: EQUAL
74261: IFTRUE 74265
74263: GO 74283
74265: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
74266: LD_ADDR_VAR 0 3
74270: PUSH
74271: LD_INT 13
74273: PUSH
74274: LD_INT 14
74276: PUSH
74277: EMPTY
74278: LIST
74279: LIST
74280: ST_TO_ADDR
74281: GO 74652
74283: LD_INT 31
74285: DOUBLE
74286: EQUAL
74287: IFTRUE 74291
74289: GO 74309
74291: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
74292: LD_ADDR_VAR 0 3
74296: PUSH
74297: LD_INT 13
74299: PUSH
74300: LD_INT 14
74302: PUSH
74303: EMPTY
74304: LIST
74305: LIST
74306: ST_TO_ADDR
74307: GO 74652
74309: LD_INT 26
74311: DOUBLE
74312: EQUAL
74313: IFTRUE 74317
74315: GO 74335
74317: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
74318: LD_ADDR_VAR 0 3
74322: PUSH
74323: LD_INT 13
74325: PUSH
74326: LD_INT 14
74328: PUSH
74329: EMPTY
74330: LIST
74331: LIST
74332: ST_TO_ADDR
74333: GO 74652
74335: LD_INT 42
74337: DOUBLE
74338: EQUAL
74339: IFTRUE 74343
74341: GO 74369
74343: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
74344: LD_ADDR_VAR 0 3
74348: PUSH
74349: LD_INT 21
74351: PUSH
74352: LD_INT 22
74354: PUSH
74355: LD_INT 23
74357: PUSH
74358: LD_INT 24
74360: PUSH
74361: EMPTY
74362: LIST
74363: LIST
74364: LIST
74365: LIST
74366: ST_TO_ADDR
74367: GO 74652
74369: LD_INT 43
74371: DOUBLE
74372: EQUAL
74373: IFTRUE 74377
74375: GO 74403
74377: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
74378: LD_ADDR_VAR 0 3
74382: PUSH
74383: LD_INT 21
74385: PUSH
74386: LD_INT 22
74388: PUSH
74389: LD_INT 23
74391: PUSH
74392: LD_INT 24
74394: PUSH
74395: EMPTY
74396: LIST
74397: LIST
74398: LIST
74399: LIST
74400: ST_TO_ADDR
74401: GO 74652
74403: LD_INT 44
74405: DOUBLE
74406: EQUAL
74407: IFTRUE 74411
74409: GO 74437
74411: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
74412: LD_ADDR_VAR 0 3
74416: PUSH
74417: LD_INT 21
74419: PUSH
74420: LD_INT 22
74422: PUSH
74423: LD_INT 23
74425: PUSH
74426: LD_INT 24
74428: PUSH
74429: EMPTY
74430: LIST
74431: LIST
74432: LIST
74433: LIST
74434: ST_TO_ADDR
74435: GO 74652
74437: LD_INT 45
74439: DOUBLE
74440: EQUAL
74441: IFTRUE 74445
74443: GO 74471
74445: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
74446: LD_ADDR_VAR 0 3
74450: PUSH
74451: LD_INT 21
74453: PUSH
74454: LD_INT 22
74456: PUSH
74457: LD_INT 23
74459: PUSH
74460: LD_INT 24
74462: PUSH
74463: EMPTY
74464: LIST
74465: LIST
74466: LIST
74467: LIST
74468: ST_TO_ADDR
74469: GO 74652
74471: LD_INT 49
74473: DOUBLE
74474: EQUAL
74475: IFTRUE 74479
74477: GO 74505
74479: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
74480: LD_ADDR_VAR 0 3
74484: PUSH
74485: LD_INT 21
74487: PUSH
74488: LD_INT 22
74490: PUSH
74491: LD_INT 23
74493: PUSH
74494: LD_INT 24
74496: PUSH
74497: EMPTY
74498: LIST
74499: LIST
74500: LIST
74501: LIST
74502: ST_TO_ADDR
74503: GO 74652
74505: LD_INT 51
74507: DOUBLE
74508: EQUAL
74509: IFTRUE 74513
74511: GO 74539
74513: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
74514: LD_ADDR_VAR 0 3
74518: PUSH
74519: LD_INT 21
74521: PUSH
74522: LD_INT 22
74524: PUSH
74525: LD_INT 23
74527: PUSH
74528: LD_INT 24
74530: PUSH
74531: EMPTY
74532: LIST
74533: LIST
74534: LIST
74535: LIST
74536: ST_TO_ADDR
74537: GO 74652
74539: LD_INT 52
74541: DOUBLE
74542: EQUAL
74543: IFTRUE 74547
74545: GO 74573
74547: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
74548: LD_ADDR_VAR 0 3
74552: PUSH
74553: LD_INT 21
74555: PUSH
74556: LD_INT 22
74558: PUSH
74559: LD_INT 23
74561: PUSH
74562: LD_INT 24
74564: PUSH
74565: EMPTY
74566: LIST
74567: LIST
74568: LIST
74569: LIST
74570: ST_TO_ADDR
74571: GO 74652
74573: LD_INT 53
74575: DOUBLE
74576: EQUAL
74577: IFTRUE 74581
74579: GO 74599
74581: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
74582: LD_ADDR_VAR 0 3
74586: PUSH
74587: LD_INT 23
74589: PUSH
74590: LD_INT 24
74592: PUSH
74593: EMPTY
74594: LIST
74595: LIST
74596: ST_TO_ADDR
74597: GO 74652
74599: LD_INT 46
74601: DOUBLE
74602: EQUAL
74603: IFTRUE 74607
74605: GO 74625
74607: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
74608: LD_ADDR_VAR 0 3
74612: PUSH
74613: LD_INT 23
74615: PUSH
74616: LD_INT 24
74618: PUSH
74619: EMPTY
74620: LIST
74621: LIST
74622: ST_TO_ADDR
74623: GO 74652
74625: LD_INT 47
74627: DOUBLE
74628: EQUAL
74629: IFTRUE 74633
74631: GO 74651
74633: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
74634: LD_ADDR_VAR 0 3
74638: PUSH
74639: LD_INT 23
74641: PUSH
74642: LD_INT 24
74644: PUSH
74645: EMPTY
74646: LIST
74647: LIST
74648: ST_TO_ADDR
74649: GO 74652
74651: POP
// result := ( chassis in result ) ;
74652: LD_ADDR_VAR 0 3
74656: PUSH
74657: LD_VAR 0 1
74661: PUSH
74662: LD_VAR 0 3
74666: IN
74667: ST_TO_ADDR
// end ;
74668: LD_VAR 0 3
74672: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
74673: LD_INT 0
74675: PPUSH
74676: PPUSH
74677: PPUSH
74678: PPUSH
74679: PPUSH
74680: PPUSH
74681: PPUSH
// result := array ;
74682: LD_ADDR_VAR 0 5
74686: PUSH
74687: LD_VAR 0 1
74691: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
74692: LD_VAR 0 1
74696: NOT
74697: PUSH
74698: LD_VAR 0 2
74702: NOT
74703: OR
74704: PUSH
74705: LD_VAR 0 3
74709: NOT
74710: OR
74711: PUSH
74712: LD_VAR 0 2
74716: PUSH
74717: LD_VAR 0 1
74721: GREATER
74722: OR
74723: PUSH
74724: LD_VAR 0 3
74728: PUSH
74729: LD_VAR 0 1
74733: GREATER
74734: OR
74735: IFFALSE 74739
// exit ;
74737: GO 75035
// if direction then
74739: LD_VAR 0 4
74743: IFFALSE 74807
// begin d := 1 ;
74745: LD_ADDR_VAR 0 9
74749: PUSH
74750: LD_INT 1
74752: ST_TO_ADDR
// if i_from > i_to then
74753: LD_VAR 0 2
74757: PUSH
74758: LD_VAR 0 3
74762: GREATER
74763: IFFALSE 74789
// length := ( array - i_from ) + i_to else
74765: LD_ADDR_VAR 0 11
74769: PUSH
74770: LD_VAR 0 1
74774: PUSH
74775: LD_VAR 0 2
74779: MINUS
74780: PUSH
74781: LD_VAR 0 3
74785: PLUS
74786: ST_TO_ADDR
74787: GO 74805
// length := i_to - i_from ;
74789: LD_ADDR_VAR 0 11
74793: PUSH
74794: LD_VAR 0 3
74798: PUSH
74799: LD_VAR 0 2
74803: MINUS
74804: ST_TO_ADDR
// end else
74805: GO 74868
// begin d := - 1 ;
74807: LD_ADDR_VAR 0 9
74811: PUSH
74812: LD_INT 1
74814: NEG
74815: ST_TO_ADDR
// if i_from > i_to then
74816: LD_VAR 0 2
74820: PUSH
74821: LD_VAR 0 3
74825: GREATER
74826: IFFALSE 74846
// length := i_from - i_to else
74828: LD_ADDR_VAR 0 11
74832: PUSH
74833: LD_VAR 0 2
74837: PUSH
74838: LD_VAR 0 3
74842: MINUS
74843: ST_TO_ADDR
74844: GO 74868
// length := ( array - i_to ) + i_from ;
74846: LD_ADDR_VAR 0 11
74850: PUSH
74851: LD_VAR 0 1
74855: PUSH
74856: LD_VAR 0 3
74860: MINUS
74861: PUSH
74862: LD_VAR 0 2
74866: PLUS
74867: ST_TO_ADDR
// end ; if not length then
74868: LD_VAR 0 11
74872: NOT
74873: IFFALSE 74877
// exit ;
74875: GO 75035
// tmp := array ;
74877: LD_ADDR_VAR 0 10
74881: PUSH
74882: LD_VAR 0 1
74886: ST_TO_ADDR
// for i = 1 to length do
74887: LD_ADDR_VAR 0 6
74891: PUSH
74892: DOUBLE
74893: LD_INT 1
74895: DEC
74896: ST_TO_ADDR
74897: LD_VAR 0 11
74901: PUSH
74902: FOR_TO
74903: IFFALSE 75023
// begin for j = 1 to array do
74905: LD_ADDR_VAR 0 7
74909: PUSH
74910: DOUBLE
74911: LD_INT 1
74913: DEC
74914: ST_TO_ADDR
74915: LD_VAR 0 1
74919: PUSH
74920: FOR_TO
74921: IFFALSE 75009
// begin k := j + d ;
74923: LD_ADDR_VAR 0 8
74927: PUSH
74928: LD_VAR 0 7
74932: PUSH
74933: LD_VAR 0 9
74937: PLUS
74938: ST_TO_ADDR
// if k > array then
74939: LD_VAR 0 8
74943: PUSH
74944: LD_VAR 0 1
74948: GREATER
74949: IFFALSE 74959
// k := 1 ;
74951: LD_ADDR_VAR 0 8
74955: PUSH
74956: LD_INT 1
74958: ST_TO_ADDR
// if not k then
74959: LD_VAR 0 8
74963: NOT
74964: IFFALSE 74976
// k := array ;
74966: LD_ADDR_VAR 0 8
74970: PUSH
74971: LD_VAR 0 1
74975: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
74976: LD_ADDR_VAR 0 10
74980: PUSH
74981: LD_VAR 0 10
74985: PPUSH
74986: LD_VAR 0 8
74990: PPUSH
74991: LD_VAR 0 1
74995: PUSH
74996: LD_VAR 0 7
75000: ARRAY
75001: PPUSH
75002: CALL_OW 1
75006: ST_TO_ADDR
// end ;
75007: GO 74920
75009: POP
75010: POP
// array := tmp ;
75011: LD_ADDR_VAR 0 1
75015: PUSH
75016: LD_VAR 0 10
75020: ST_TO_ADDR
// end ;
75021: GO 74902
75023: POP
75024: POP
// result := array ;
75025: LD_ADDR_VAR 0 5
75029: PUSH
75030: LD_VAR 0 1
75034: ST_TO_ADDR
// end ;
75035: LD_VAR 0 5
75039: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
75040: LD_INT 0
75042: PPUSH
75043: PPUSH
// result := 0 ;
75044: LD_ADDR_VAR 0 3
75048: PUSH
75049: LD_INT 0
75051: ST_TO_ADDR
// if not array or not value in array then
75052: LD_VAR 0 1
75056: NOT
75057: PUSH
75058: LD_VAR 0 2
75062: PUSH
75063: LD_VAR 0 1
75067: IN
75068: NOT
75069: OR
75070: IFFALSE 75074
// exit ;
75072: GO 75128
// for i = 1 to array do
75074: LD_ADDR_VAR 0 4
75078: PUSH
75079: DOUBLE
75080: LD_INT 1
75082: DEC
75083: ST_TO_ADDR
75084: LD_VAR 0 1
75088: PUSH
75089: FOR_TO
75090: IFFALSE 75126
// if value = array [ i ] then
75092: LD_VAR 0 2
75096: PUSH
75097: LD_VAR 0 1
75101: PUSH
75102: LD_VAR 0 4
75106: ARRAY
75107: EQUAL
75108: IFFALSE 75124
// begin result := i ;
75110: LD_ADDR_VAR 0 3
75114: PUSH
75115: LD_VAR 0 4
75119: ST_TO_ADDR
// exit ;
75120: POP
75121: POP
75122: GO 75128
// end ;
75124: GO 75089
75126: POP
75127: POP
// end ;
75128: LD_VAR 0 3
75132: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
75133: LD_INT 0
75135: PPUSH
// vc_chassis := chassis ;
75136: LD_ADDR_OWVAR 37
75140: PUSH
75141: LD_VAR 0 1
75145: ST_TO_ADDR
// vc_engine := engine ;
75146: LD_ADDR_OWVAR 39
75150: PUSH
75151: LD_VAR 0 2
75155: ST_TO_ADDR
// vc_control := control ;
75156: LD_ADDR_OWVAR 38
75160: PUSH
75161: LD_VAR 0 3
75165: ST_TO_ADDR
// vc_weapon := weapon ;
75166: LD_ADDR_OWVAR 40
75170: PUSH
75171: LD_VAR 0 4
75175: ST_TO_ADDR
// vc_fuel_battery := fuel ;
75176: LD_ADDR_OWVAR 41
75180: PUSH
75181: LD_VAR 0 5
75185: ST_TO_ADDR
// end ;
75186: LD_VAR 0 6
75190: RET
// export function WantPlant ( unit ) ; var task ; begin
75191: LD_INT 0
75193: PPUSH
75194: PPUSH
// result := false ;
75195: LD_ADDR_VAR 0 2
75199: PUSH
75200: LD_INT 0
75202: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
75203: LD_ADDR_VAR 0 3
75207: PUSH
75208: LD_VAR 0 1
75212: PPUSH
75213: CALL_OW 437
75217: ST_TO_ADDR
// if task then
75218: LD_VAR 0 3
75222: IFFALSE 75250
// if task [ 1 ] [ 1 ] = p then
75224: LD_VAR 0 3
75228: PUSH
75229: LD_INT 1
75231: ARRAY
75232: PUSH
75233: LD_INT 1
75235: ARRAY
75236: PUSH
75237: LD_STRING p
75239: EQUAL
75240: IFFALSE 75250
// result := true ;
75242: LD_ADDR_VAR 0 2
75246: PUSH
75247: LD_INT 1
75249: ST_TO_ADDR
// end ;
75250: LD_VAR 0 2
75254: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
75255: LD_INT 0
75257: PPUSH
75258: PPUSH
75259: PPUSH
75260: PPUSH
// if pos < 1 then
75261: LD_VAR 0 2
75265: PUSH
75266: LD_INT 1
75268: LESS
75269: IFFALSE 75273
// exit ;
75271: GO 75576
// if pos = 1 then
75273: LD_VAR 0 2
75277: PUSH
75278: LD_INT 1
75280: EQUAL
75281: IFFALSE 75314
// result := Replace ( arr , pos [ 1 ] , value ) else
75283: LD_ADDR_VAR 0 4
75287: PUSH
75288: LD_VAR 0 1
75292: PPUSH
75293: LD_VAR 0 2
75297: PUSH
75298: LD_INT 1
75300: ARRAY
75301: PPUSH
75302: LD_VAR 0 3
75306: PPUSH
75307: CALL_OW 1
75311: ST_TO_ADDR
75312: GO 75576
// begin tmp := arr ;
75314: LD_ADDR_VAR 0 6
75318: PUSH
75319: LD_VAR 0 1
75323: ST_TO_ADDR
// s_arr := [ tmp ] ;
75324: LD_ADDR_VAR 0 7
75328: PUSH
75329: LD_VAR 0 6
75333: PUSH
75334: EMPTY
75335: LIST
75336: ST_TO_ADDR
// for i = 1 to pos - 1 do
75337: LD_ADDR_VAR 0 5
75341: PUSH
75342: DOUBLE
75343: LD_INT 1
75345: DEC
75346: ST_TO_ADDR
75347: LD_VAR 0 2
75351: PUSH
75352: LD_INT 1
75354: MINUS
75355: PUSH
75356: FOR_TO
75357: IFFALSE 75402
// begin tmp := tmp [ pos [ i ] ] ;
75359: LD_ADDR_VAR 0 6
75363: PUSH
75364: LD_VAR 0 6
75368: PUSH
75369: LD_VAR 0 2
75373: PUSH
75374: LD_VAR 0 5
75378: ARRAY
75379: ARRAY
75380: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
75381: LD_ADDR_VAR 0 7
75385: PUSH
75386: LD_VAR 0 7
75390: PUSH
75391: LD_VAR 0 6
75395: PUSH
75396: EMPTY
75397: LIST
75398: ADD
75399: ST_TO_ADDR
// end ;
75400: GO 75356
75402: POP
75403: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
75404: LD_ADDR_VAR 0 6
75408: PUSH
75409: LD_VAR 0 6
75413: PPUSH
75414: LD_VAR 0 2
75418: PUSH
75419: LD_VAR 0 2
75423: ARRAY
75424: PPUSH
75425: LD_VAR 0 3
75429: PPUSH
75430: CALL_OW 1
75434: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
75435: LD_ADDR_VAR 0 7
75439: PUSH
75440: LD_VAR 0 7
75444: PPUSH
75445: LD_VAR 0 7
75449: PPUSH
75450: LD_VAR 0 6
75454: PPUSH
75455: CALL_OW 1
75459: ST_TO_ADDR
// for i = s_arr downto 2 do
75460: LD_ADDR_VAR 0 5
75464: PUSH
75465: DOUBLE
75466: LD_VAR 0 7
75470: INC
75471: ST_TO_ADDR
75472: LD_INT 2
75474: PUSH
75475: FOR_DOWNTO
75476: IFFALSE 75560
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
75478: LD_ADDR_VAR 0 6
75482: PUSH
75483: LD_VAR 0 7
75487: PUSH
75488: LD_VAR 0 5
75492: PUSH
75493: LD_INT 1
75495: MINUS
75496: ARRAY
75497: PPUSH
75498: LD_VAR 0 2
75502: PUSH
75503: LD_VAR 0 5
75507: PUSH
75508: LD_INT 1
75510: MINUS
75511: ARRAY
75512: PPUSH
75513: LD_VAR 0 7
75517: PUSH
75518: LD_VAR 0 5
75522: ARRAY
75523: PPUSH
75524: CALL_OW 1
75528: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
75529: LD_ADDR_VAR 0 7
75533: PUSH
75534: LD_VAR 0 7
75538: PPUSH
75539: LD_VAR 0 5
75543: PUSH
75544: LD_INT 1
75546: MINUS
75547: PPUSH
75548: LD_VAR 0 6
75552: PPUSH
75553: CALL_OW 1
75557: ST_TO_ADDR
// end ;
75558: GO 75475
75560: POP
75561: POP
// result := s_arr [ 1 ] ;
75562: LD_ADDR_VAR 0 4
75566: PUSH
75567: LD_VAR 0 7
75571: PUSH
75572: LD_INT 1
75574: ARRAY
75575: ST_TO_ADDR
// end ; end ;
75576: LD_VAR 0 4
75580: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
75581: LD_INT 0
75583: PPUSH
75584: PPUSH
// if not list then
75585: LD_VAR 0 1
75589: NOT
75590: IFFALSE 75594
// exit ;
75592: GO 75685
// i := list [ pos1 ] ;
75594: LD_ADDR_VAR 0 5
75598: PUSH
75599: LD_VAR 0 1
75603: PUSH
75604: LD_VAR 0 2
75608: ARRAY
75609: ST_TO_ADDR
// if not i then
75610: LD_VAR 0 5
75614: NOT
75615: IFFALSE 75619
// exit ;
75617: GO 75685
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
75619: LD_ADDR_VAR 0 1
75623: PUSH
75624: LD_VAR 0 1
75628: PPUSH
75629: LD_VAR 0 2
75633: PPUSH
75634: LD_VAR 0 1
75638: PUSH
75639: LD_VAR 0 3
75643: ARRAY
75644: PPUSH
75645: CALL_OW 1
75649: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
75650: LD_ADDR_VAR 0 1
75654: PUSH
75655: LD_VAR 0 1
75659: PPUSH
75660: LD_VAR 0 3
75664: PPUSH
75665: LD_VAR 0 5
75669: PPUSH
75670: CALL_OW 1
75674: ST_TO_ADDR
// result := list ;
75675: LD_ADDR_VAR 0 4
75679: PUSH
75680: LD_VAR 0 1
75684: ST_TO_ADDR
// end ;
75685: LD_VAR 0 4
75689: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
75690: LD_INT 0
75692: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
75693: LD_ADDR_VAR 0 5
75697: PUSH
75698: LD_VAR 0 1
75702: PPUSH
75703: CALL_OW 250
75707: PPUSH
75708: LD_VAR 0 1
75712: PPUSH
75713: CALL_OW 251
75717: PPUSH
75718: LD_VAR 0 2
75722: PPUSH
75723: LD_VAR 0 3
75727: PPUSH
75728: LD_VAR 0 4
75732: PPUSH
75733: CALL 76111 0 5
75737: ST_TO_ADDR
// end ;
75738: LD_VAR 0 5
75742: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
75743: LD_INT 0
75745: PPUSH
75746: PPUSH
75747: PPUSH
75748: PPUSH
// if not list or not unit then
75749: LD_VAR 0 2
75753: NOT
75754: PUSH
75755: LD_VAR 0 1
75759: NOT
75760: OR
75761: IFFALSE 75765
// exit ;
75763: GO 76106
// result := [ ] ;
75765: LD_ADDR_VAR 0 5
75769: PUSH
75770: EMPTY
75771: ST_TO_ADDR
// for i in list do
75772: LD_ADDR_VAR 0 6
75776: PUSH
75777: LD_VAR 0 2
75781: PUSH
75782: FOR_IN
75783: IFFALSE 76001
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
75785: LD_ADDR_VAR 0 8
75789: PUSH
75790: LD_VAR 0 1
75794: PPUSH
75795: LD_VAR 0 6
75799: PUSH
75800: LD_INT 1
75802: ARRAY
75803: PPUSH
75804: LD_VAR 0 6
75808: PUSH
75809: LD_INT 2
75811: ARRAY
75812: PPUSH
75813: CALL_OW 297
75817: ST_TO_ADDR
// if not Count ( result ) then
75818: LD_VAR 0 5
75822: PPUSH
75823: CALL 72395 0 1
75827: NOT
75828: IFFALSE 75861
// begin result := Join ( result , [ i , tmp ] ) ;
75830: LD_ADDR_VAR 0 5
75834: PUSH
75835: LD_VAR 0 5
75839: PPUSH
75840: LD_VAR 0 6
75844: PUSH
75845: LD_VAR 0 8
75849: PUSH
75850: EMPTY
75851: LIST
75852: LIST
75853: PPUSH
75854: CALL 108004 0 2
75858: ST_TO_ADDR
// continue ;
75859: GO 75782
// end ; if result [ result ] [ 2 ] <= tmp then
75861: LD_VAR 0 5
75865: PUSH
75866: LD_VAR 0 5
75870: ARRAY
75871: PUSH
75872: LD_INT 2
75874: ARRAY
75875: PUSH
75876: LD_VAR 0 8
75880: LESSEQUAL
75881: IFFALSE 75914
// result := Join ( result , [ i , tmp ] ) else
75883: LD_ADDR_VAR 0 5
75887: PUSH
75888: LD_VAR 0 5
75892: PPUSH
75893: LD_VAR 0 6
75897: PUSH
75898: LD_VAR 0 8
75902: PUSH
75903: EMPTY
75904: LIST
75905: LIST
75906: PPUSH
75907: CALL 108004 0 2
75911: ST_TO_ADDR
75912: GO 75999
// begin for j := 1 to Count ( result ) do
75914: LD_ADDR_VAR 0 7
75918: PUSH
75919: DOUBLE
75920: LD_INT 1
75922: DEC
75923: ST_TO_ADDR
75924: LD_VAR 0 5
75928: PPUSH
75929: CALL 72395 0 1
75933: PUSH
75934: FOR_TO
75935: IFFALSE 75997
// begin if tmp < result [ j ] [ 2 ] then
75937: LD_VAR 0 8
75941: PUSH
75942: LD_VAR 0 5
75946: PUSH
75947: LD_VAR 0 7
75951: ARRAY
75952: PUSH
75953: LD_INT 2
75955: ARRAY
75956: LESS
75957: IFFALSE 75995
// begin result := Insert ( result , j , [ i , tmp ] ) ;
75959: LD_ADDR_VAR 0 5
75963: PUSH
75964: LD_VAR 0 5
75968: PPUSH
75969: LD_VAR 0 7
75973: PPUSH
75974: LD_VAR 0 6
75978: PUSH
75979: LD_VAR 0 8
75983: PUSH
75984: EMPTY
75985: LIST
75986: LIST
75987: PPUSH
75988: CALL_OW 2
75992: ST_TO_ADDR
// break ;
75993: GO 75997
// end ; end ;
75995: GO 75934
75997: POP
75998: POP
// end ; end ;
75999: GO 75782
76001: POP
76002: POP
// if result and not asc then
76003: LD_VAR 0 5
76007: PUSH
76008: LD_VAR 0 3
76012: NOT
76013: AND
76014: IFFALSE 76031
// result := ReverseArray ( result ) ;
76016: LD_ADDR_VAR 0 5
76020: PUSH
76021: LD_VAR 0 5
76025: PPUSH
76026: CALL 103271 0 1
76030: ST_TO_ADDR
// tmp := [ ] ;
76031: LD_ADDR_VAR 0 8
76035: PUSH
76036: EMPTY
76037: ST_TO_ADDR
// if mode then
76038: LD_VAR 0 4
76042: IFFALSE 76106
// begin for i := 1 to result do
76044: LD_ADDR_VAR 0 6
76048: PUSH
76049: DOUBLE
76050: LD_INT 1
76052: DEC
76053: ST_TO_ADDR
76054: LD_VAR 0 5
76058: PUSH
76059: FOR_TO
76060: IFFALSE 76094
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
76062: LD_ADDR_VAR 0 8
76066: PUSH
76067: LD_VAR 0 8
76071: PPUSH
76072: LD_VAR 0 5
76076: PUSH
76077: LD_VAR 0 6
76081: ARRAY
76082: PUSH
76083: LD_INT 1
76085: ARRAY
76086: PPUSH
76087: CALL 108004 0 2
76091: ST_TO_ADDR
76092: GO 76059
76094: POP
76095: POP
// result := tmp ;
76096: LD_ADDR_VAR 0 5
76100: PUSH
76101: LD_VAR 0 8
76105: ST_TO_ADDR
// end ; end ;
76106: LD_VAR 0 5
76110: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
76111: LD_INT 0
76113: PPUSH
76114: PPUSH
76115: PPUSH
76116: PPUSH
// if not list then
76117: LD_VAR 0 3
76121: NOT
76122: IFFALSE 76126
// exit ;
76124: GO 76514
// result := [ ] ;
76126: LD_ADDR_VAR 0 6
76130: PUSH
76131: EMPTY
76132: ST_TO_ADDR
// for i in list do
76133: LD_ADDR_VAR 0 7
76137: PUSH
76138: LD_VAR 0 3
76142: PUSH
76143: FOR_IN
76144: IFFALSE 76346
// begin tmp := GetDistUnitXY ( i , x , y ) ;
76146: LD_ADDR_VAR 0 9
76150: PUSH
76151: LD_VAR 0 7
76155: PPUSH
76156: LD_VAR 0 1
76160: PPUSH
76161: LD_VAR 0 2
76165: PPUSH
76166: CALL_OW 297
76170: ST_TO_ADDR
// if not result then
76171: LD_VAR 0 6
76175: NOT
76176: IFFALSE 76202
// result := [ [ i , tmp ] ] else
76178: LD_ADDR_VAR 0 6
76182: PUSH
76183: LD_VAR 0 7
76187: PUSH
76188: LD_VAR 0 9
76192: PUSH
76193: EMPTY
76194: LIST
76195: LIST
76196: PUSH
76197: EMPTY
76198: LIST
76199: ST_TO_ADDR
76200: GO 76344
// begin if result [ result ] [ 2 ] <= tmp then
76202: LD_VAR 0 6
76206: PUSH
76207: LD_VAR 0 6
76211: ARRAY
76212: PUSH
76213: LD_INT 2
76215: ARRAY
76216: PUSH
76217: LD_VAR 0 9
76221: LESSEQUAL
76222: IFFALSE 76264
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
76224: LD_ADDR_VAR 0 6
76228: PUSH
76229: LD_VAR 0 6
76233: PPUSH
76234: LD_VAR 0 6
76238: PUSH
76239: LD_INT 1
76241: PLUS
76242: PPUSH
76243: LD_VAR 0 7
76247: PUSH
76248: LD_VAR 0 9
76252: PUSH
76253: EMPTY
76254: LIST
76255: LIST
76256: PPUSH
76257: CALL_OW 2
76261: ST_TO_ADDR
76262: GO 76344
// for j := 1 to result do
76264: LD_ADDR_VAR 0 8
76268: PUSH
76269: DOUBLE
76270: LD_INT 1
76272: DEC
76273: ST_TO_ADDR
76274: LD_VAR 0 6
76278: PUSH
76279: FOR_TO
76280: IFFALSE 76342
// begin if tmp < result [ j ] [ 2 ] then
76282: LD_VAR 0 9
76286: PUSH
76287: LD_VAR 0 6
76291: PUSH
76292: LD_VAR 0 8
76296: ARRAY
76297: PUSH
76298: LD_INT 2
76300: ARRAY
76301: LESS
76302: IFFALSE 76340
// begin result := Insert ( result , j , [ i , tmp ] ) ;
76304: LD_ADDR_VAR 0 6
76308: PUSH
76309: LD_VAR 0 6
76313: PPUSH
76314: LD_VAR 0 8
76318: PPUSH
76319: LD_VAR 0 7
76323: PUSH
76324: LD_VAR 0 9
76328: PUSH
76329: EMPTY
76330: LIST
76331: LIST
76332: PPUSH
76333: CALL_OW 2
76337: ST_TO_ADDR
// break ;
76338: GO 76342
// end ; end ;
76340: GO 76279
76342: POP
76343: POP
// end ; end ;
76344: GO 76143
76346: POP
76347: POP
// if result and not asc then
76348: LD_VAR 0 6
76352: PUSH
76353: LD_VAR 0 4
76357: NOT
76358: AND
76359: IFFALSE 76434
// begin tmp := result ;
76361: LD_ADDR_VAR 0 9
76365: PUSH
76366: LD_VAR 0 6
76370: ST_TO_ADDR
// for i = tmp downto 1 do
76371: LD_ADDR_VAR 0 7
76375: PUSH
76376: DOUBLE
76377: LD_VAR 0 9
76381: INC
76382: ST_TO_ADDR
76383: LD_INT 1
76385: PUSH
76386: FOR_DOWNTO
76387: IFFALSE 76432
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
76389: LD_ADDR_VAR 0 6
76393: PUSH
76394: LD_VAR 0 6
76398: PPUSH
76399: LD_VAR 0 9
76403: PUSH
76404: LD_VAR 0 7
76408: MINUS
76409: PUSH
76410: LD_INT 1
76412: PLUS
76413: PPUSH
76414: LD_VAR 0 9
76418: PUSH
76419: LD_VAR 0 7
76423: ARRAY
76424: PPUSH
76425: CALL_OW 1
76429: ST_TO_ADDR
76430: GO 76386
76432: POP
76433: POP
// end ; tmp := [ ] ;
76434: LD_ADDR_VAR 0 9
76438: PUSH
76439: EMPTY
76440: ST_TO_ADDR
// if mode then
76441: LD_VAR 0 5
76445: IFFALSE 76514
// begin for i = 1 to result do
76447: LD_ADDR_VAR 0 7
76451: PUSH
76452: DOUBLE
76453: LD_INT 1
76455: DEC
76456: ST_TO_ADDR
76457: LD_VAR 0 6
76461: PUSH
76462: FOR_TO
76463: IFFALSE 76502
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
76465: LD_ADDR_VAR 0 9
76469: PUSH
76470: LD_VAR 0 9
76474: PPUSH
76475: LD_VAR 0 7
76479: PPUSH
76480: LD_VAR 0 6
76484: PUSH
76485: LD_VAR 0 7
76489: ARRAY
76490: PUSH
76491: LD_INT 1
76493: ARRAY
76494: PPUSH
76495: CALL_OW 1
76499: ST_TO_ADDR
76500: GO 76462
76502: POP
76503: POP
// result := tmp ;
76504: LD_ADDR_VAR 0 6
76508: PUSH
76509: LD_VAR 0 9
76513: ST_TO_ADDR
// end ; end ;
76514: LD_VAR 0 6
76518: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
76519: LD_INT 0
76521: PPUSH
76522: PPUSH
76523: PPUSH
76524: PPUSH
76525: PPUSH
76526: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
76527: LD_ADDR_VAR 0 5
76531: PUSH
76532: LD_INT 0
76534: PUSH
76535: LD_INT 0
76537: PUSH
76538: LD_INT 0
76540: PUSH
76541: EMPTY
76542: PUSH
76543: EMPTY
76544: LIST
76545: LIST
76546: LIST
76547: LIST
76548: ST_TO_ADDR
// if not x or not y then
76549: LD_VAR 0 2
76553: NOT
76554: PUSH
76555: LD_VAR 0 3
76559: NOT
76560: OR
76561: IFFALSE 76565
// exit ;
76563: GO 78215
// if not range then
76565: LD_VAR 0 4
76569: NOT
76570: IFFALSE 76580
// range := 10 ;
76572: LD_ADDR_VAR 0 4
76576: PUSH
76577: LD_INT 10
76579: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
76580: LD_ADDR_VAR 0 8
76584: PUSH
76585: LD_INT 81
76587: PUSH
76588: LD_VAR 0 1
76592: PUSH
76593: EMPTY
76594: LIST
76595: LIST
76596: PUSH
76597: LD_INT 92
76599: PUSH
76600: LD_VAR 0 2
76604: PUSH
76605: LD_VAR 0 3
76609: PUSH
76610: LD_VAR 0 4
76614: PUSH
76615: EMPTY
76616: LIST
76617: LIST
76618: LIST
76619: LIST
76620: PUSH
76621: LD_INT 3
76623: PUSH
76624: LD_INT 21
76626: PUSH
76627: LD_INT 3
76629: PUSH
76630: EMPTY
76631: LIST
76632: LIST
76633: PUSH
76634: EMPTY
76635: LIST
76636: LIST
76637: PUSH
76638: EMPTY
76639: LIST
76640: LIST
76641: LIST
76642: PPUSH
76643: CALL_OW 69
76647: ST_TO_ADDR
// if not tmp then
76648: LD_VAR 0 8
76652: NOT
76653: IFFALSE 76657
// exit ;
76655: GO 78215
// for i in tmp do
76657: LD_ADDR_VAR 0 6
76661: PUSH
76662: LD_VAR 0 8
76666: PUSH
76667: FOR_IN
76668: IFFALSE 78190
// begin points := [ 0 , 0 , 0 ] ;
76670: LD_ADDR_VAR 0 9
76674: PUSH
76675: LD_INT 0
76677: PUSH
76678: LD_INT 0
76680: PUSH
76681: LD_INT 0
76683: PUSH
76684: EMPTY
76685: LIST
76686: LIST
76687: LIST
76688: ST_TO_ADDR
// bpoints := 1 ;
76689: LD_ADDR_VAR 0 10
76693: PUSH
76694: LD_INT 1
76696: ST_TO_ADDR
// case GetType ( i ) of unit_human :
76697: LD_VAR 0 6
76701: PPUSH
76702: CALL_OW 247
76706: PUSH
76707: LD_INT 1
76709: DOUBLE
76710: EQUAL
76711: IFTRUE 76715
76713: GO 77293
76715: POP
// begin if GetClass ( i ) = 1 then
76716: LD_VAR 0 6
76720: PPUSH
76721: CALL_OW 257
76725: PUSH
76726: LD_INT 1
76728: EQUAL
76729: IFFALSE 76750
// points := [ 10 , 5 , 3 ] ;
76731: LD_ADDR_VAR 0 9
76735: PUSH
76736: LD_INT 10
76738: PUSH
76739: LD_INT 5
76741: PUSH
76742: LD_INT 3
76744: PUSH
76745: EMPTY
76746: LIST
76747: LIST
76748: LIST
76749: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
76750: LD_VAR 0 6
76754: PPUSH
76755: CALL_OW 257
76759: PUSH
76760: LD_INT 2
76762: PUSH
76763: LD_INT 3
76765: PUSH
76766: LD_INT 4
76768: PUSH
76769: EMPTY
76770: LIST
76771: LIST
76772: LIST
76773: IN
76774: IFFALSE 76795
// points := [ 3 , 2 , 1 ] ;
76776: LD_ADDR_VAR 0 9
76780: PUSH
76781: LD_INT 3
76783: PUSH
76784: LD_INT 2
76786: PUSH
76787: LD_INT 1
76789: PUSH
76790: EMPTY
76791: LIST
76792: LIST
76793: LIST
76794: ST_TO_ADDR
// if GetClass ( i ) = 5 then
76795: LD_VAR 0 6
76799: PPUSH
76800: CALL_OW 257
76804: PUSH
76805: LD_INT 5
76807: EQUAL
76808: IFFALSE 76829
// points := [ 130 , 5 , 2 ] ;
76810: LD_ADDR_VAR 0 9
76814: PUSH
76815: LD_INT 130
76817: PUSH
76818: LD_INT 5
76820: PUSH
76821: LD_INT 2
76823: PUSH
76824: EMPTY
76825: LIST
76826: LIST
76827: LIST
76828: ST_TO_ADDR
// if GetClass ( i ) = 8 then
76829: LD_VAR 0 6
76833: PPUSH
76834: CALL_OW 257
76838: PUSH
76839: LD_INT 8
76841: EQUAL
76842: IFFALSE 76863
// points := [ 35 , 35 , 30 ] ;
76844: LD_ADDR_VAR 0 9
76848: PUSH
76849: LD_INT 35
76851: PUSH
76852: LD_INT 35
76854: PUSH
76855: LD_INT 30
76857: PUSH
76858: EMPTY
76859: LIST
76860: LIST
76861: LIST
76862: ST_TO_ADDR
// if GetClass ( i ) = 9 then
76863: LD_VAR 0 6
76867: PPUSH
76868: CALL_OW 257
76872: PUSH
76873: LD_INT 9
76875: EQUAL
76876: IFFALSE 76897
// points := [ 20 , 55 , 40 ] ;
76878: LD_ADDR_VAR 0 9
76882: PUSH
76883: LD_INT 20
76885: PUSH
76886: LD_INT 55
76888: PUSH
76889: LD_INT 40
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: LIST
76896: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
76897: LD_VAR 0 6
76901: PPUSH
76902: CALL_OW 257
76906: PUSH
76907: LD_INT 12
76909: PUSH
76910: LD_INT 16
76912: PUSH
76913: EMPTY
76914: LIST
76915: LIST
76916: IN
76917: IFFALSE 76938
// points := [ 5 , 3 , 2 ] ;
76919: LD_ADDR_VAR 0 9
76923: PUSH
76924: LD_INT 5
76926: PUSH
76927: LD_INT 3
76929: PUSH
76930: LD_INT 2
76932: PUSH
76933: EMPTY
76934: LIST
76935: LIST
76936: LIST
76937: ST_TO_ADDR
// if GetClass ( i ) = 17 then
76938: LD_VAR 0 6
76942: PPUSH
76943: CALL_OW 257
76947: PUSH
76948: LD_INT 17
76950: EQUAL
76951: IFFALSE 76972
// points := [ 100 , 50 , 75 ] ;
76953: LD_ADDR_VAR 0 9
76957: PUSH
76958: LD_INT 100
76960: PUSH
76961: LD_INT 50
76963: PUSH
76964: LD_INT 75
76966: PUSH
76967: EMPTY
76968: LIST
76969: LIST
76970: LIST
76971: ST_TO_ADDR
// if GetClass ( i ) = 15 then
76972: LD_VAR 0 6
76976: PPUSH
76977: CALL_OW 257
76981: PUSH
76982: LD_INT 15
76984: EQUAL
76985: IFFALSE 77006
// points := [ 10 , 5 , 3 ] ;
76987: LD_ADDR_VAR 0 9
76991: PUSH
76992: LD_INT 10
76994: PUSH
76995: LD_INT 5
76997: PUSH
76998: LD_INT 3
77000: PUSH
77001: EMPTY
77002: LIST
77003: LIST
77004: LIST
77005: ST_TO_ADDR
// if GetClass ( i ) = 14 then
77006: LD_VAR 0 6
77010: PPUSH
77011: CALL_OW 257
77015: PUSH
77016: LD_INT 14
77018: EQUAL
77019: IFFALSE 77040
// points := [ 10 , 0 , 0 ] ;
77021: LD_ADDR_VAR 0 9
77025: PUSH
77026: LD_INT 10
77028: PUSH
77029: LD_INT 0
77031: PUSH
77032: LD_INT 0
77034: PUSH
77035: EMPTY
77036: LIST
77037: LIST
77038: LIST
77039: ST_TO_ADDR
// if GetClass ( i ) = 11 then
77040: LD_VAR 0 6
77044: PPUSH
77045: CALL_OW 257
77049: PUSH
77050: LD_INT 11
77052: EQUAL
77053: IFFALSE 77074
// points := [ 30 , 10 , 5 ] ;
77055: LD_ADDR_VAR 0 9
77059: PUSH
77060: LD_INT 30
77062: PUSH
77063: LD_INT 10
77065: PUSH
77066: LD_INT 5
77068: PUSH
77069: EMPTY
77070: LIST
77071: LIST
77072: LIST
77073: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
77074: LD_VAR 0 1
77078: PPUSH
77079: LD_INT 5
77081: PPUSH
77082: CALL_OW 321
77086: PUSH
77087: LD_INT 2
77089: EQUAL
77090: IFFALSE 77107
// bpoints := bpoints * 1.8 ;
77092: LD_ADDR_VAR 0 10
77096: PUSH
77097: LD_VAR 0 10
77101: PUSH
77102: LD_REAL  1.80000000000000E+0000
77105: MUL
77106: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
77107: LD_VAR 0 6
77111: PPUSH
77112: CALL_OW 257
77116: PUSH
77117: LD_INT 1
77119: PUSH
77120: LD_INT 2
77122: PUSH
77123: LD_INT 3
77125: PUSH
77126: LD_INT 4
77128: PUSH
77129: EMPTY
77130: LIST
77131: LIST
77132: LIST
77133: LIST
77134: IN
77135: PUSH
77136: LD_VAR 0 1
77140: PPUSH
77141: LD_INT 51
77143: PPUSH
77144: CALL_OW 321
77148: PUSH
77149: LD_INT 2
77151: EQUAL
77152: AND
77153: IFFALSE 77170
// bpoints := bpoints * 1.2 ;
77155: LD_ADDR_VAR 0 10
77159: PUSH
77160: LD_VAR 0 10
77164: PUSH
77165: LD_REAL  1.20000000000000E+0000
77168: MUL
77169: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
77170: LD_VAR 0 6
77174: PPUSH
77175: CALL_OW 257
77179: PUSH
77180: LD_INT 5
77182: PUSH
77183: LD_INT 7
77185: PUSH
77186: LD_INT 9
77188: PUSH
77189: EMPTY
77190: LIST
77191: LIST
77192: LIST
77193: IN
77194: PUSH
77195: LD_VAR 0 1
77199: PPUSH
77200: LD_INT 52
77202: PPUSH
77203: CALL_OW 321
77207: PUSH
77208: LD_INT 2
77210: EQUAL
77211: AND
77212: IFFALSE 77229
// bpoints := bpoints * 1.5 ;
77214: LD_ADDR_VAR 0 10
77218: PUSH
77219: LD_VAR 0 10
77223: PUSH
77224: LD_REAL  1.50000000000000E+0000
77227: MUL
77228: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
77229: LD_VAR 0 1
77233: PPUSH
77234: LD_INT 66
77236: PPUSH
77237: CALL_OW 321
77241: PUSH
77242: LD_INT 2
77244: EQUAL
77245: IFFALSE 77262
// bpoints := bpoints * 1.1 ;
77247: LD_ADDR_VAR 0 10
77251: PUSH
77252: LD_VAR 0 10
77256: PUSH
77257: LD_REAL  1.10000000000000E+0000
77260: MUL
77261: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
77262: LD_ADDR_VAR 0 10
77266: PUSH
77267: LD_VAR 0 10
77271: PUSH
77272: LD_VAR 0 6
77276: PPUSH
77277: LD_INT 1
77279: PPUSH
77280: CALL_OW 259
77284: PUSH
77285: LD_REAL  1.15000000000000E+0000
77288: MUL
77289: MUL
77290: ST_TO_ADDR
// end ; unit_vehicle :
77291: GO 78119
77293: LD_INT 2
77295: DOUBLE
77296: EQUAL
77297: IFTRUE 77301
77299: GO 78107
77301: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
77302: LD_VAR 0 6
77306: PPUSH
77307: CALL_OW 264
77311: PUSH
77312: LD_INT 2
77314: PUSH
77315: LD_INT 42
77317: PUSH
77318: LD_INT 24
77320: PUSH
77321: EMPTY
77322: LIST
77323: LIST
77324: LIST
77325: IN
77326: IFFALSE 77347
// points := [ 25 , 5 , 3 ] ;
77328: LD_ADDR_VAR 0 9
77332: PUSH
77333: LD_INT 25
77335: PUSH
77336: LD_INT 5
77338: PUSH
77339: LD_INT 3
77341: PUSH
77342: EMPTY
77343: LIST
77344: LIST
77345: LIST
77346: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
77347: LD_VAR 0 6
77351: PPUSH
77352: CALL_OW 264
77356: PUSH
77357: LD_INT 4
77359: PUSH
77360: LD_INT 43
77362: PUSH
77363: LD_INT 25
77365: PUSH
77366: EMPTY
77367: LIST
77368: LIST
77369: LIST
77370: IN
77371: IFFALSE 77392
// points := [ 40 , 15 , 5 ] ;
77373: LD_ADDR_VAR 0 9
77377: PUSH
77378: LD_INT 40
77380: PUSH
77381: LD_INT 15
77383: PUSH
77384: LD_INT 5
77386: PUSH
77387: EMPTY
77388: LIST
77389: LIST
77390: LIST
77391: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
77392: LD_VAR 0 6
77396: PPUSH
77397: CALL_OW 264
77401: PUSH
77402: LD_INT 3
77404: PUSH
77405: LD_INT 23
77407: PUSH
77408: EMPTY
77409: LIST
77410: LIST
77411: IN
77412: IFFALSE 77433
// points := [ 7 , 25 , 8 ] ;
77414: LD_ADDR_VAR 0 9
77418: PUSH
77419: LD_INT 7
77421: PUSH
77422: LD_INT 25
77424: PUSH
77425: LD_INT 8
77427: PUSH
77428: EMPTY
77429: LIST
77430: LIST
77431: LIST
77432: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
77433: LD_VAR 0 6
77437: PPUSH
77438: CALL_OW 264
77442: PUSH
77443: LD_INT 5
77445: PUSH
77446: LD_INT 27
77448: PUSH
77449: LD_INT 44
77451: PUSH
77452: EMPTY
77453: LIST
77454: LIST
77455: LIST
77456: IN
77457: IFFALSE 77478
// points := [ 14 , 50 , 16 ] ;
77459: LD_ADDR_VAR 0 9
77463: PUSH
77464: LD_INT 14
77466: PUSH
77467: LD_INT 50
77469: PUSH
77470: LD_INT 16
77472: PUSH
77473: EMPTY
77474: LIST
77475: LIST
77476: LIST
77477: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
77478: LD_VAR 0 6
77482: PPUSH
77483: CALL_OW 264
77487: PUSH
77488: LD_INT 6
77490: PUSH
77491: LD_INT 46
77493: PUSH
77494: EMPTY
77495: LIST
77496: LIST
77497: IN
77498: IFFALSE 77519
// points := [ 32 , 120 , 70 ] ;
77500: LD_ADDR_VAR 0 9
77504: PUSH
77505: LD_INT 32
77507: PUSH
77508: LD_INT 120
77510: PUSH
77511: LD_INT 70
77513: PUSH
77514: EMPTY
77515: LIST
77516: LIST
77517: LIST
77518: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
77519: LD_VAR 0 6
77523: PPUSH
77524: CALL_OW 264
77528: PUSH
77529: LD_INT 7
77531: PUSH
77532: LD_INT 28
77534: PUSH
77535: LD_INT 45
77537: PUSH
77538: LD_INT 92
77540: PUSH
77541: EMPTY
77542: LIST
77543: LIST
77544: LIST
77545: LIST
77546: IN
77547: IFFALSE 77568
// points := [ 35 , 20 , 45 ] ;
77549: LD_ADDR_VAR 0 9
77553: PUSH
77554: LD_INT 35
77556: PUSH
77557: LD_INT 20
77559: PUSH
77560: LD_INT 45
77562: PUSH
77563: EMPTY
77564: LIST
77565: LIST
77566: LIST
77567: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
77568: LD_VAR 0 6
77572: PPUSH
77573: CALL_OW 264
77577: PUSH
77578: LD_INT 47
77580: PUSH
77581: EMPTY
77582: LIST
77583: IN
77584: IFFALSE 77605
// points := [ 67 , 45 , 75 ] ;
77586: LD_ADDR_VAR 0 9
77590: PUSH
77591: LD_INT 67
77593: PUSH
77594: LD_INT 45
77596: PUSH
77597: LD_INT 75
77599: PUSH
77600: EMPTY
77601: LIST
77602: LIST
77603: LIST
77604: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
77605: LD_VAR 0 6
77609: PPUSH
77610: CALL_OW 264
77614: PUSH
77615: LD_INT 26
77617: PUSH
77618: EMPTY
77619: LIST
77620: IN
77621: IFFALSE 77642
// points := [ 120 , 30 , 80 ] ;
77623: LD_ADDR_VAR 0 9
77627: PUSH
77628: LD_INT 120
77630: PUSH
77631: LD_INT 30
77633: PUSH
77634: LD_INT 80
77636: PUSH
77637: EMPTY
77638: LIST
77639: LIST
77640: LIST
77641: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
77642: LD_VAR 0 6
77646: PPUSH
77647: CALL_OW 264
77651: PUSH
77652: LD_INT 22
77654: PUSH
77655: EMPTY
77656: LIST
77657: IN
77658: IFFALSE 77679
// points := [ 40 , 1 , 1 ] ;
77660: LD_ADDR_VAR 0 9
77664: PUSH
77665: LD_INT 40
77667: PUSH
77668: LD_INT 1
77670: PUSH
77671: LD_INT 1
77673: PUSH
77674: EMPTY
77675: LIST
77676: LIST
77677: LIST
77678: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
77679: LD_VAR 0 6
77683: PPUSH
77684: CALL_OW 264
77688: PUSH
77689: LD_INT 29
77691: PUSH
77692: EMPTY
77693: LIST
77694: IN
77695: IFFALSE 77716
// points := [ 70 , 200 , 400 ] ;
77697: LD_ADDR_VAR 0 9
77701: PUSH
77702: LD_INT 70
77704: PUSH
77705: LD_INT 200
77707: PUSH
77708: LD_INT 400
77710: PUSH
77711: EMPTY
77712: LIST
77713: LIST
77714: LIST
77715: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
77716: LD_VAR 0 6
77720: PPUSH
77721: CALL_OW 264
77725: PUSH
77726: LD_INT 14
77728: PUSH
77729: LD_INT 53
77731: PUSH
77732: EMPTY
77733: LIST
77734: LIST
77735: IN
77736: IFFALSE 77757
// points := [ 40 , 10 , 20 ] ;
77738: LD_ADDR_VAR 0 9
77742: PUSH
77743: LD_INT 40
77745: PUSH
77746: LD_INT 10
77748: PUSH
77749: LD_INT 20
77751: PUSH
77752: EMPTY
77753: LIST
77754: LIST
77755: LIST
77756: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
77757: LD_VAR 0 6
77761: PPUSH
77762: CALL_OW 264
77766: PUSH
77767: LD_INT 9
77769: PUSH
77770: EMPTY
77771: LIST
77772: IN
77773: IFFALSE 77794
// points := [ 5 , 70 , 20 ] ;
77775: LD_ADDR_VAR 0 9
77779: PUSH
77780: LD_INT 5
77782: PUSH
77783: LD_INT 70
77785: PUSH
77786: LD_INT 20
77788: PUSH
77789: EMPTY
77790: LIST
77791: LIST
77792: LIST
77793: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
77794: LD_VAR 0 6
77798: PPUSH
77799: CALL_OW 264
77803: PUSH
77804: LD_INT 10
77806: PUSH
77807: EMPTY
77808: LIST
77809: IN
77810: IFFALSE 77831
// points := [ 35 , 110 , 70 ] ;
77812: LD_ADDR_VAR 0 9
77816: PUSH
77817: LD_INT 35
77819: PUSH
77820: LD_INT 110
77822: PUSH
77823: LD_INT 70
77825: PUSH
77826: EMPTY
77827: LIST
77828: LIST
77829: LIST
77830: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
77831: LD_VAR 0 6
77835: PPUSH
77836: CALL_OW 265
77840: PUSH
77841: LD_INT 25
77843: EQUAL
77844: IFFALSE 77865
// points := [ 80 , 65 , 100 ] ;
77846: LD_ADDR_VAR 0 9
77850: PUSH
77851: LD_INT 80
77853: PUSH
77854: LD_INT 65
77856: PUSH
77857: LD_INT 100
77859: PUSH
77860: EMPTY
77861: LIST
77862: LIST
77863: LIST
77864: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
77865: LD_VAR 0 6
77869: PPUSH
77870: CALL_OW 263
77874: PUSH
77875: LD_INT 1
77877: EQUAL
77878: IFFALSE 77913
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
77880: LD_ADDR_VAR 0 10
77884: PUSH
77885: LD_VAR 0 10
77889: PUSH
77890: LD_VAR 0 6
77894: PPUSH
77895: CALL_OW 311
77899: PPUSH
77900: LD_INT 3
77902: PPUSH
77903: CALL_OW 259
77907: PUSH
77908: LD_INT 4
77910: MUL
77911: MUL
77912: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
77913: LD_VAR 0 6
77917: PPUSH
77918: CALL_OW 263
77922: PUSH
77923: LD_INT 2
77925: EQUAL
77926: IFFALSE 77977
// begin j := IsControledBy ( i ) ;
77928: LD_ADDR_VAR 0 7
77932: PUSH
77933: LD_VAR 0 6
77937: PPUSH
77938: CALL_OW 312
77942: ST_TO_ADDR
// if j then
77943: LD_VAR 0 7
77947: IFFALSE 77977
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
77949: LD_ADDR_VAR 0 10
77953: PUSH
77954: LD_VAR 0 10
77958: PUSH
77959: LD_VAR 0 7
77963: PPUSH
77964: LD_INT 3
77966: PPUSH
77967: CALL_OW 259
77971: PUSH
77972: LD_INT 3
77974: MUL
77975: MUL
77976: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
77977: LD_VAR 0 6
77981: PPUSH
77982: CALL_OW 264
77986: PUSH
77987: LD_INT 5
77989: PUSH
77990: LD_INT 6
77992: PUSH
77993: LD_INT 46
77995: PUSH
77996: LD_INT 44
77998: PUSH
77999: LD_INT 47
78001: PUSH
78002: LD_INT 45
78004: PUSH
78005: LD_INT 28
78007: PUSH
78008: LD_INT 7
78010: PUSH
78011: LD_INT 27
78013: PUSH
78014: LD_INT 29
78016: PUSH
78017: EMPTY
78018: LIST
78019: LIST
78020: LIST
78021: LIST
78022: LIST
78023: LIST
78024: LIST
78025: LIST
78026: LIST
78027: LIST
78028: IN
78029: PUSH
78030: LD_VAR 0 1
78034: PPUSH
78035: LD_INT 52
78037: PPUSH
78038: CALL_OW 321
78042: PUSH
78043: LD_INT 2
78045: EQUAL
78046: AND
78047: IFFALSE 78064
// bpoints := bpoints * 1.2 ;
78049: LD_ADDR_VAR 0 10
78053: PUSH
78054: LD_VAR 0 10
78058: PUSH
78059: LD_REAL  1.20000000000000E+0000
78062: MUL
78063: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
78064: LD_VAR 0 6
78068: PPUSH
78069: CALL_OW 264
78073: PUSH
78074: LD_INT 6
78076: PUSH
78077: LD_INT 46
78079: PUSH
78080: LD_INT 47
78082: PUSH
78083: EMPTY
78084: LIST
78085: LIST
78086: LIST
78087: IN
78088: IFFALSE 78105
// bpoints := bpoints * 1.2 ;
78090: LD_ADDR_VAR 0 10
78094: PUSH
78095: LD_VAR 0 10
78099: PUSH
78100: LD_REAL  1.20000000000000E+0000
78103: MUL
78104: ST_TO_ADDR
// end ; unit_building :
78105: GO 78119
78107: LD_INT 3
78109: DOUBLE
78110: EQUAL
78111: IFTRUE 78115
78113: GO 78118
78115: POP
// ; end ;
78116: GO 78119
78118: POP
// for j = 1 to 3 do
78119: LD_ADDR_VAR 0 7
78123: PUSH
78124: DOUBLE
78125: LD_INT 1
78127: DEC
78128: ST_TO_ADDR
78129: LD_INT 3
78131: PUSH
78132: FOR_TO
78133: IFFALSE 78186
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
78135: LD_ADDR_VAR 0 5
78139: PUSH
78140: LD_VAR 0 5
78144: PPUSH
78145: LD_VAR 0 7
78149: PPUSH
78150: LD_VAR 0 5
78154: PUSH
78155: LD_VAR 0 7
78159: ARRAY
78160: PUSH
78161: LD_VAR 0 9
78165: PUSH
78166: LD_VAR 0 7
78170: ARRAY
78171: PUSH
78172: LD_VAR 0 10
78176: MUL
78177: PLUS
78178: PPUSH
78179: CALL_OW 1
78183: ST_TO_ADDR
78184: GO 78132
78186: POP
78187: POP
// end ;
78188: GO 76667
78190: POP
78191: POP
// result := Replace ( result , 4 , tmp ) ;
78192: LD_ADDR_VAR 0 5
78196: PUSH
78197: LD_VAR 0 5
78201: PPUSH
78202: LD_INT 4
78204: PPUSH
78205: LD_VAR 0 8
78209: PPUSH
78210: CALL_OW 1
78214: ST_TO_ADDR
// end ;
78215: LD_VAR 0 5
78219: RET
// export function DangerAtRange ( unit , range ) ; begin
78220: LD_INT 0
78222: PPUSH
// if not unit then
78223: LD_VAR 0 1
78227: NOT
78228: IFFALSE 78232
// exit ;
78230: GO 78277
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
78232: LD_ADDR_VAR 0 3
78236: PUSH
78237: LD_VAR 0 1
78241: PPUSH
78242: CALL_OW 255
78246: PPUSH
78247: LD_VAR 0 1
78251: PPUSH
78252: CALL_OW 250
78256: PPUSH
78257: LD_VAR 0 1
78261: PPUSH
78262: CALL_OW 251
78266: PPUSH
78267: LD_VAR 0 2
78271: PPUSH
78272: CALL 76519 0 4
78276: ST_TO_ADDR
// end ;
78277: LD_VAR 0 3
78281: RET
// export function DangerInArea ( side , area ) ; begin
78282: LD_INT 0
78284: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
78285: LD_ADDR_VAR 0 3
78289: PUSH
78290: LD_VAR 0 2
78294: PPUSH
78295: LD_INT 81
78297: PUSH
78298: LD_VAR 0 1
78302: PUSH
78303: EMPTY
78304: LIST
78305: LIST
78306: PPUSH
78307: CALL_OW 70
78311: ST_TO_ADDR
// end ;
78312: LD_VAR 0 3
78316: RET
// export function IsExtension ( b ) ; begin
78317: LD_INT 0
78319: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
78320: LD_ADDR_VAR 0 2
78324: PUSH
78325: LD_VAR 0 1
78329: PUSH
78330: LD_INT 23
78332: PUSH
78333: LD_INT 20
78335: PUSH
78336: LD_INT 22
78338: PUSH
78339: LD_INT 17
78341: PUSH
78342: LD_INT 24
78344: PUSH
78345: LD_INT 21
78347: PUSH
78348: LD_INT 19
78350: PUSH
78351: LD_INT 16
78353: PUSH
78354: LD_INT 25
78356: PUSH
78357: LD_INT 18
78359: PUSH
78360: EMPTY
78361: LIST
78362: LIST
78363: LIST
78364: LIST
78365: LIST
78366: LIST
78367: LIST
78368: LIST
78369: LIST
78370: LIST
78371: IN
78372: ST_TO_ADDR
// end ;
78373: LD_VAR 0 2
78377: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
78378: LD_INT 0
78380: PPUSH
78381: PPUSH
78382: PPUSH
// result := [ ] ;
78383: LD_ADDR_VAR 0 4
78387: PUSH
78388: EMPTY
78389: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
78390: LD_ADDR_VAR 0 5
78394: PUSH
78395: LD_VAR 0 2
78399: PPUSH
78400: LD_INT 21
78402: PUSH
78403: LD_INT 3
78405: PUSH
78406: EMPTY
78407: LIST
78408: LIST
78409: PPUSH
78410: CALL_OW 70
78414: ST_TO_ADDR
// if not tmp then
78415: LD_VAR 0 5
78419: NOT
78420: IFFALSE 78424
// exit ;
78422: GO 78488
// if checkLink then
78424: LD_VAR 0 3
78428: IFFALSE 78478
// begin for i in tmp do
78430: LD_ADDR_VAR 0 6
78434: PUSH
78435: LD_VAR 0 5
78439: PUSH
78440: FOR_IN
78441: IFFALSE 78476
// if GetBase ( i ) <> base then
78443: LD_VAR 0 6
78447: PPUSH
78448: CALL_OW 274
78452: PUSH
78453: LD_VAR 0 1
78457: NONEQUAL
78458: IFFALSE 78474
// ComLinkToBase ( base , i ) ;
78460: LD_VAR 0 1
78464: PPUSH
78465: LD_VAR 0 6
78469: PPUSH
78470: CALL_OW 169
78474: GO 78440
78476: POP
78477: POP
// end ; result := tmp ;
78478: LD_ADDR_VAR 0 4
78482: PUSH
78483: LD_VAR 0 5
78487: ST_TO_ADDR
// end ;
78488: LD_VAR 0 4
78492: RET
// export function ComComplete ( units , b ) ; var i ; begin
78493: LD_INT 0
78495: PPUSH
78496: PPUSH
// if not units then
78497: LD_VAR 0 1
78501: NOT
78502: IFFALSE 78506
// exit ;
78504: GO 78596
// for i in units do
78506: LD_ADDR_VAR 0 4
78510: PUSH
78511: LD_VAR 0 1
78515: PUSH
78516: FOR_IN
78517: IFFALSE 78594
// if BuildingStatus ( b ) = bs_build then
78519: LD_VAR 0 2
78523: PPUSH
78524: CALL_OW 461
78528: PUSH
78529: LD_INT 1
78531: EQUAL
78532: IFFALSE 78592
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
78534: LD_VAR 0 4
78538: PPUSH
78539: LD_STRING h
78541: PUSH
78542: LD_VAR 0 2
78546: PPUSH
78547: CALL_OW 250
78551: PUSH
78552: LD_VAR 0 2
78556: PPUSH
78557: CALL_OW 251
78561: PUSH
78562: LD_VAR 0 2
78566: PUSH
78567: LD_INT 0
78569: PUSH
78570: LD_INT 0
78572: PUSH
78573: LD_INT 0
78575: PUSH
78576: EMPTY
78577: LIST
78578: LIST
78579: LIST
78580: LIST
78581: LIST
78582: LIST
78583: LIST
78584: PUSH
78585: EMPTY
78586: LIST
78587: PPUSH
78588: CALL_OW 446
78592: GO 78516
78594: POP
78595: POP
// end ;
78596: LD_VAR 0 3
78600: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
78601: LD_INT 0
78603: PPUSH
78604: PPUSH
78605: PPUSH
78606: PPUSH
78607: PPUSH
78608: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
78609: LD_VAR 0 1
78613: NOT
78614: PUSH
78615: LD_VAR 0 1
78619: PPUSH
78620: CALL_OW 263
78624: PUSH
78625: LD_INT 2
78627: NONEQUAL
78628: OR
78629: IFFALSE 78633
// exit ;
78631: GO 78949
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
78633: LD_ADDR_VAR 0 6
78637: PUSH
78638: LD_INT 22
78640: PUSH
78641: LD_VAR 0 1
78645: PPUSH
78646: CALL_OW 255
78650: PUSH
78651: EMPTY
78652: LIST
78653: LIST
78654: PUSH
78655: LD_INT 2
78657: PUSH
78658: LD_INT 30
78660: PUSH
78661: LD_INT 36
78663: PUSH
78664: EMPTY
78665: LIST
78666: LIST
78667: PUSH
78668: LD_INT 34
78670: PUSH
78671: LD_INT 31
78673: PUSH
78674: EMPTY
78675: LIST
78676: LIST
78677: PUSH
78678: EMPTY
78679: LIST
78680: LIST
78681: LIST
78682: PUSH
78683: EMPTY
78684: LIST
78685: LIST
78686: PPUSH
78687: CALL_OW 69
78691: ST_TO_ADDR
// if not tmp then
78692: LD_VAR 0 6
78696: NOT
78697: IFFALSE 78701
// exit ;
78699: GO 78949
// result := [ ] ;
78701: LD_ADDR_VAR 0 2
78705: PUSH
78706: EMPTY
78707: ST_TO_ADDR
// for i in tmp do
78708: LD_ADDR_VAR 0 3
78712: PUSH
78713: LD_VAR 0 6
78717: PUSH
78718: FOR_IN
78719: IFFALSE 78790
// begin t := UnitsInside ( i ) ;
78721: LD_ADDR_VAR 0 4
78725: PUSH
78726: LD_VAR 0 3
78730: PPUSH
78731: CALL_OW 313
78735: ST_TO_ADDR
// if t then
78736: LD_VAR 0 4
78740: IFFALSE 78788
// for j in t do
78742: LD_ADDR_VAR 0 7
78746: PUSH
78747: LD_VAR 0 4
78751: PUSH
78752: FOR_IN
78753: IFFALSE 78786
// result := Replace ( result , result + 1 , j ) ;
78755: LD_ADDR_VAR 0 2
78759: PUSH
78760: LD_VAR 0 2
78764: PPUSH
78765: LD_VAR 0 2
78769: PUSH
78770: LD_INT 1
78772: PLUS
78773: PPUSH
78774: LD_VAR 0 7
78778: PPUSH
78779: CALL_OW 1
78783: ST_TO_ADDR
78784: GO 78752
78786: POP
78787: POP
// end ;
78788: GO 78718
78790: POP
78791: POP
// if not result then
78792: LD_VAR 0 2
78796: NOT
78797: IFFALSE 78801
// exit ;
78799: GO 78949
// mech := result [ 1 ] ;
78801: LD_ADDR_VAR 0 5
78805: PUSH
78806: LD_VAR 0 2
78810: PUSH
78811: LD_INT 1
78813: ARRAY
78814: ST_TO_ADDR
// if result > 1 then
78815: LD_VAR 0 2
78819: PUSH
78820: LD_INT 1
78822: GREATER
78823: IFFALSE 78935
// begin for i = 2 to result do
78825: LD_ADDR_VAR 0 3
78829: PUSH
78830: DOUBLE
78831: LD_INT 2
78833: DEC
78834: ST_TO_ADDR
78835: LD_VAR 0 2
78839: PUSH
78840: FOR_TO
78841: IFFALSE 78933
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
78843: LD_ADDR_VAR 0 4
78847: PUSH
78848: LD_VAR 0 2
78852: PUSH
78853: LD_VAR 0 3
78857: ARRAY
78858: PPUSH
78859: LD_INT 3
78861: PPUSH
78862: CALL_OW 259
78866: PUSH
78867: LD_VAR 0 2
78871: PUSH
78872: LD_VAR 0 3
78876: ARRAY
78877: PPUSH
78878: CALL_OW 432
78882: MINUS
78883: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
78884: LD_VAR 0 4
78888: PUSH
78889: LD_VAR 0 5
78893: PPUSH
78894: LD_INT 3
78896: PPUSH
78897: CALL_OW 259
78901: PUSH
78902: LD_VAR 0 5
78906: PPUSH
78907: CALL_OW 432
78911: MINUS
78912: GREATEREQUAL
78913: IFFALSE 78931
// mech := result [ i ] ;
78915: LD_ADDR_VAR 0 5
78919: PUSH
78920: LD_VAR 0 2
78924: PUSH
78925: LD_VAR 0 3
78929: ARRAY
78930: ST_TO_ADDR
// end ;
78931: GO 78840
78933: POP
78934: POP
// end ; ComLinkTo ( vehicle , mech ) ;
78935: LD_VAR 0 1
78939: PPUSH
78940: LD_VAR 0 5
78944: PPUSH
78945: CALL_OW 135
// end ;
78949: LD_VAR 0 2
78953: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
78954: LD_INT 0
78956: PPUSH
78957: PPUSH
78958: PPUSH
78959: PPUSH
78960: PPUSH
78961: PPUSH
78962: PPUSH
78963: PPUSH
78964: PPUSH
78965: PPUSH
78966: PPUSH
78967: PPUSH
78968: PPUSH
// result := [ ] ;
78969: LD_ADDR_VAR 0 7
78973: PUSH
78974: EMPTY
78975: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
78976: LD_VAR 0 1
78980: PPUSH
78981: CALL_OW 266
78985: PUSH
78986: LD_INT 0
78988: PUSH
78989: LD_INT 1
78991: PUSH
78992: EMPTY
78993: LIST
78994: LIST
78995: IN
78996: NOT
78997: IFFALSE 79001
// exit ;
78999: GO 80635
// if name then
79001: LD_VAR 0 3
79005: IFFALSE 79021
// SetBName ( base_dep , name ) ;
79007: LD_VAR 0 1
79011: PPUSH
79012: LD_VAR 0 3
79016: PPUSH
79017: CALL_OW 500
// base := GetBase ( base_dep ) ;
79021: LD_ADDR_VAR 0 15
79025: PUSH
79026: LD_VAR 0 1
79030: PPUSH
79031: CALL_OW 274
79035: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
79036: LD_ADDR_VAR 0 16
79040: PUSH
79041: LD_VAR 0 1
79045: PPUSH
79046: CALL_OW 255
79050: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
79051: LD_ADDR_VAR 0 17
79055: PUSH
79056: LD_VAR 0 1
79060: PPUSH
79061: CALL_OW 248
79065: ST_TO_ADDR
// if sources then
79066: LD_VAR 0 5
79070: IFFALSE 79117
// for i = 1 to 3 do
79072: LD_ADDR_VAR 0 8
79076: PUSH
79077: DOUBLE
79078: LD_INT 1
79080: DEC
79081: ST_TO_ADDR
79082: LD_INT 3
79084: PUSH
79085: FOR_TO
79086: IFFALSE 79115
// AddResourceType ( base , i , sources [ i ] ) ;
79088: LD_VAR 0 15
79092: PPUSH
79093: LD_VAR 0 8
79097: PPUSH
79098: LD_VAR 0 5
79102: PUSH
79103: LD_VAR 0 8
79107: ARRAY
79108: PPUSH
79109: CALL_OW 276
79113: GO 79085
79115: POP
79116: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
79117: LD_ADDR_VAR 0 18
79121: PUSH
79122: LD_VAR 0 15
79126: PPUSH
79127: LD_VAR 0 2
79131: PPUSH
79132: LD_INT 1
79134: PPUSH
79135: CALL 78378 0 3
79139: ST_TO_ADDR
// InitHc ;
79140: CALL_OW 19
// InitUc ;
79144: CALL_OW 18
// uc_side := side ;
79148: LD_ADDR_OWVAR 20
79152: PUSH
79153: LD_VAR 0 16
79157: ST_TO_ADDR
// uc_nation := nation ;
79158: LD_ADDR_OWVAR 21
79162: PUSH
79163: LD_VAR 0 17
79167: ST_TO_ADDR
// if buildings then
79168: LD_VAR 0 18
79172: IFFALSE 80494
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
79174: LD_ADDR_VAR 0 19
79178: PUSH
79179: LD_VAR 0 18
79183: PPUSH
79184: LD_INT 2
79186: PUSH
79187: LD_INT 30
79189: PUSH
79190: LD_INT 29
79192: PUSH
79193: EMPTY
79194: LIST
79195: LIST
79196: PUSH
79197: LD_INT 30
79199: PUSH
79200: LD_INT 30
79202: PUSH
79203: EMPTY
79204: LIST
79205: LIST
79206: PUSH
79207: EMPTY
79208: LIST
79209: LIST
79210: LIST
79211: PPUSH
79212: CALL_OW 72
79216: ST_TO_ADDR
// if tmp then
79217: LD_VAR 0 19
79221: IFFALSE 79269
// for i in tmp do
79223: LD_ADDR_VAR 0 8
79227: PUSH
79228: LD_VAR 0 19
79232: PUSH
79233: FOR_IN
79234: IFFALSE 79267
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
79236: LD_VAR 0 8
79240: PPUSH
79241: CALL_OW 250
79245: PPUSH
79246: LD_VAR 0 8
79250: PPUSH
79251: CALL_OW 251
79255: PPUSH
79256: LD_VAR 0 16
79260: PPUSH
79261: CALL_OW 441
79265: GO 79233
79267: POP
79268: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
79269: LD_VAR 0 18
79273: PPUSH
79274: LD_INT 2
79276: PUSH
79277: LD_INT 30
79279: PUSH
79280: LD_INT 32
79282: PUSH
79283: EMPTY
79284: LIST
79285: LIST
79286: PUSH
79287: LD_INT 30
79289: PUSH
79290: LD_INT 33
79292: PUSH
79293: EMPTY
79294: LIST
79295: LIST
79296: PUSH
79297: EMPTY
79298: LIST
79299: LIST
79300: LIST
79301: PPUSH
79302: CALL_OW 72
79306: IFFALSE 79394
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
79308: LD_ADDR_VAR 0 8
79312: PUSH
79313: LD_VAR 0 18
79317: PPUSH
79318: LD_INT 2
79320: PUSH
79321: LD_INT 30
79323: PUSH
79324: LD_INT 32
79326: PUSH
79327: EMPTY
79328: LIST
79329: LIST
79330: PUSH
79331: LD_INT 30
79333: PUSH
79334: LD_INT 33
79336: PUSH
79337: EMPTY
79338: LIST
79339: LIST
79340: PUSH
79341: EMPTY
79342: LIST
79343: LIST
79344: LIST
79345: PPUSH
79346: CALL_OW 72
79350: PUSH
79351: FOR_IN
79352: IFFALSE 79392
// begin if not GetBWeapon ( i ) then
79354: LD_VAR 0 8
79358: PPUSH
79359: CALL_OW 269
79363: NOT
79364: IFFALSE 79390
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
79366: LD_VAR 0 8
79370: PPUSH
79371: LD_VAR 0 8
79375: PPUSH
79376: LD_VAR 0 2
79380: PPUSH
79381: CALL 80640 0 2
79385: PPUSH
79386: CALL_OW 431
// end ;
79390: GO 79351
79392: POP
79393: POP
// end ; for i = 1 to personel do
79394: LD_ADDR_VAR 0 8
79398: PUSH
79399: DOUBLE
79400: LD_INT 1
79402: DEC
79403: ST_TO_ADDR
79404: LD_VAR 0 6
79408: PUSH
79409: FOR_TO
79410: IFFALSE 80474
// begin if i > 4 then
79412: LD_VAR 0 8
79416: PUSH
79417: LD_INT 4
79419: GREATER
79420: IFFALSE 79424
// break ;
79422: GO 80474
// case i of 1 :
79424: LD_VAR 0 8
79428: PUSH
79429: LD_INT 1
79431: DOUBLE
79432: EQUAL
79433: IFTRUE 79437
79435: GO 79517
79437: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
79438: LD_ADDR_VAR 0 12
79442: PUSH
79443: LD_VAR 0 18
79447: PPUSH
79448: LD_INT 22
79450: PUSH
79451: LD_VAR 0 16
79455: PUSH
79456: EMPTY
79457: LIST
79458: LIST
79459: PUSH
79460: LD_INT 58
79462: PUSH
79463: EMPTY
79464: LIST
79465: PUSH
79466: LD_INT 2
79468: PUSH
79469: LD_INT 30
79471: PUSH
79472: LD_INT 32
79474: PUSH
79475: EMPTY
79476: LIST
79477: LIST
79478: PUSH
79479: LD_INT 30
79481: PUSH
79482: LD_INT 4
79484: PUSH
79485: EMPTY
79486: LIST
79487: LIST
79488: PUSH
79489: LD_INT 30
79491: PUSH
79492: LD_INT 5
79494: PUSH
79495: EMPTY
79496: LIST
79497: LIST
79498: PUSH
79499: EMPTY
79500: LIST
79501: LIST
79502: LIST
79503: LIST
79504: PUSH
79505: EMPTY
79506: LIST
79507: LIST
79508: LIST
79509: PPUSH
79510: CALL_OW 72
79514: ST_TO_ADDR
79515: GO 79739
79517: LD_INT 2
79519: DOUBLE
79520: EQUAL
79521: IFTRUE 79525
79523: GO 79587
79525: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
79526: LD_ADDR_VAR 0 12
79530: PUSH
79531: LD_VAR 0 18
79535: PPUSH
79536: LD_INT 22
79538: PUSH
79539: LD_VAR 0 16
79543: PUSH
79544: EMPTY
79545: LIST
79546: LIST
79547: PUSH
79548: LD_INT 2
79550: PUSH
79551: LD_INT 30
79553: PUSH
79554: LD_INT 0
79556: PUSH
79557: EMPTY
79558: LIST
79559: LIST
79560: PUSH
79561: LD_INT 30
79563: PUSH
79564: LD_INT 1
79566: PUSH
79567: EMPTY
79568: LIST
79569: LIST
79570: PUSH
79571: EMPTY
79572: LIST
79573: LIST
79574: LIST
79575: PUSH
79576: EMPTY
79577: LIST
79578: LIST
79579: PPUSH
79580: CALL_OW 72
79584: ST_TO_ADDR
79585: GO 79739
79587: LD_INT 3
79589: DOUBLE
79590: EQUAL
79591: IFTRUE 79595
79593: GO 79657
79595: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
79596: LD_ADDR_VAR 0 12
79600: PUSH
79601: LD_VAR 0 18
79605: PPUSH
79606: LD_INT 22
79608: PUSH
79609: LD_VAR 0 16
79613: PUSH
79614: EMPTY
79615: LIST
79616: LIST
79617: PUSH
79618: LD_INT 2
79620: PUSH
79621: LD_INT 30
79623: PUSH
79624: LD_INT 2
79626: PUSH
79627: EMPTY
79628: LIST
79629: LIST
79630: PUSH
79631: LD_INT 30
79633: PUSH
79634: LD_INT 3
79636: PUSH
79637: EMPTY
79638: LIST
79639: LIST
79640: PUSH
79641: EMPTY
79642: LIST
79643: LIST
79644: LIST
79645: PUSH
79646: EMPTY
79647: LIST
79648: LIST
79649: PPUSH
79650: CALL_OW 72
79654: ST_TO_ADDR
79655: GO 79739
79657: LD_INT 4
79659: DOUBLE
79660: EQUAL
79661: IFTRUE 79665
79663: GO 79738
79665: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
79666: LD_ADDR_VAR 0 12
79670: PUSH
79671: LD_VAR 0 18
79675: PPUSH
79676: LD_INT 22
79678: PUSH
79679: LD_VAR 0 16
79683: PUSH
79684: EMPTY
79685: LIST
79686: LIST
79687: PUSH
79688: LD_INT 2
79690: PUSH
79691: LD_INT 30
79693: PUSH
79694: LD_INT 6
79696: PUSH
79697: EMPTY
79698: LIST
79699: LIST
79700: PUSH
79701: LD_INT 30
79703: PUSH
79704: LD_INT 7
79706: PUSH
79707: EMPTY
79708: LIST
79709: LIST
79710: PUSH
79711: LD_INT 30
79713: PUSH
79714: LD_INT 8
79716: PUSH
79717: EMPTY
79718: LIST
79719: LIST
79720: PUSH
79721: EMPTY
79722: LIST
79723: LIST
79724: LIST
79725: LIST
79726: PUSH
79727: EMPTY
79728: LIST
79729: LIST
79730: PPUSH
79731: CALL_OW 72
79735: ST_TO_ADDR
79736: GO 79739
79738: POP
// if i = 1 then
79739: LD_VAR 0 8
79743: PUSH
79744: LD_INT 1
79746: EQUAL
79747: IFFALSE 79858
// begin tmp := [ ] ;
79749: LD_ADDR_VAR 0 19
79753: PUSH
79754: EMPTY
79755: ST_TO_ADDR
// for j in f do
79756: LD_ADDR_VAR 0 9
79760: PUSH
79761: LD_VAR 0 12
79765: PUSH
79766: FOR_IN
79767: IFFALSE 79840
// if GetBType ( j ) = b_bunker then
79769: LD_VAR 0 9
79773: PPUSH
79774: CALL_OW 266
79778: PUSH
79779: LD_INT 32
79781: EQUAL
79782: IFFALSE 79809
// tmp := Insert ( tmp , 1 , j ) else
79784: LD_ADDR_VAR 0 19
79788: PUSH
79789: LD_VAR 0 19
79793: PPUSH
79794: LD_INT 1
79796: PPUSH
79797: LD_VAR 0 9
79801: PPUSH
79802: CALL_OW 2
79806: ST_TO_ADDR
79807: GO 79838
// tmp := Insert ( tmp , tmp + 1 , j ) ;
79809: LD_ADDR_VAR 0 19
79813: PUSH
79814: LD_VAR 0 19
79818: PPUSH
79819: LD_VAR 0 19
79823: PUSH
79824: LD_INT 1
79826: PLUS
79827: PPUSH
79828: LD_VAR 0 9
79832: PPUSH
79833: CALL_OW 2
79837: ST_TO_ADDR
79838: GO 79766
79840: POP
79841: POP
// if tmp then
79842: LD_VAR 0 19
79846: IFFALSE 79858
// f := tmp ;
79848: LD_ADDR_VAR 0 12
79852: PUSH
79853: LD_VAR 0 19
79857: ST_TO_ADDR
// end ; x := personel [ i ] ;
79858: LD_ADDR_VAR 0 13
79862: PUSH
79863: LD_VAR 0 6
79867: PUSH
79868: LD_VAR 0 8
79872: ARRAY
79873: ST_TO_ADDR
// if x = - 1 then
79874: LD_VAR 0 13
79878: PUSH
79879: LD_INT 1
79881: NEG
79882: EQUAL
79883: IFFALSE 80092
// begin for j in f do
79885: LD_ADDR_VAR 0 9
79889: PUSH
79890: LD_VAR 0 12
79894: PUSH
79895: FOR_IN
79896: IFFALSE 80088
// repeat InitHc ;
79898: CALL_OW 19
// if GetBType ( j ) = b_barracks then
79902: LD_VAR 0 9
79906: PPUSH
79907: CALL_OW 266
79911: PUSH
79912: LD_INT 5
79914: EQUAL
79915: IFFALSE 79985
// begin if UnitsInside ( j ) < 3 then
79917: LD_VAR 0 9
79921: PPUSH
79922: CALL_OW 313
79926: PUSH
79927: LD_INT 3
79929: LESS
79930: IFFALSE 79966
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
79932: LD_INT 0
79934: PPUSH
79935: LD_INT 5
79937: PUSH
79938: LD_INT 8
79940: PUSH
79941: LD_INT 9
79943: PUSH
79944: EMPTY
79945: LIST
79946: LIST
79947: LIST
79948: PUSH
79949: LD_VAR 0 17
79953: ARRAY
79954: PPUSH
79955: LD_VAR 0 4
79959: PPUSH
79960: CALL_OW 380
79964: GO 79983
// PrepareHuman ( false , i , skill ) ;
79966: LD_INT 0
79968: PPUSH
79969: LD_VAR 0 8
79973: PPUSH
79974: LD_VAR 0 4
79978: PPUSH
79979: CALL_OW 380
// end else
79983: GO 80002
// PrepareHuman ( false , i , skill ) ;
79985: LD_INT 0
79987: PPUSH
79988: LD_VAR 0 8
79992: PPUSH
79993: LD_VAR 0 4
79997: PPUSH
79998: CALL_OW 380
// un := CreateHuman ;
80002: LD_ADDR_VAR 0 14
80006: PUSH
80007: CALL_OW 44
80011: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
80012: LD_ADDR_VAR 0 7
80016: PUSH
80017: LD_VAR 0 7
80021: PPUSH
80022: LD_INT 1
80024: PPUSH
80025: LD_VAR 0 14
80029: PPUSH
80030: CALL_OW 2
80034: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
80035: LD_VAR 0 14
80039: PPUSH
80040: LD_VAR 0 9
80044: PPUSH
80045: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
80049: LD_VAR 0 9
80053: PPUSH
80054: CALL_OW 313
80058: PUSH
80059: LD_INT 6
80061: EQUAL
80062: PUSH
80063: LD_VAR 0 9
80067: PPUSH
80068: CALL_OW 266
80072: PUSH
80073: LD_INT 32
80075: PUSH
80076: LD_INT 31
80078: PUSH
80079: EMPTY
80080: LIST
80081: LIST
80082: IN
80083: OR
80084: IFFALSE 79898
80086: GO 79895
80088: POP
80089: POP
// end else
80090: GO 80472
// for j = 1 to x do
80092: LD_ADDR_VAR 0 9
80096: PUSH
80097: DOUBLE
80098: LD_INT 1
80100: DEC
80101: ST_TO_ADDR
80102: LD_VAR 0 13
80106: PUSH
80107: FOR_TO
80108: IFFALSE 80470
// begin InitHc ;
80110: CALL_OW 19
// if not f then
80114: LD_VAR 0 12
80118: NOT
80119: IFFALSE 80208
// begin PrepareHuman ( false , i , skill ) ;
80121: LD_INT 0
80123: PPUSH
80124: LD_VAR 0 8
80128: PPUSH
80129: LD_VAR 0 4
80133: PPUSH
80134: CALL_OW 380
// un := CreateHuman ;
80138: LD_ADDR_VAR 0 14
80142: PUSH
80143: CALL_OW 44
80147: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
80148: LD_ADDR_VAR 0 7
80152: PUSH
80153: LD_VAR 0 7
80157: PPUSH
80158: LD_INT 1
80160: PPUSH
80161: LD_VAR 0 14
80165: PPUSH
80166: CALL_OW 2
80170: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
80171: LD_VAR 0 14
80175: PPUSH
80176: LD_VAR 0 1
80180: PPUSH
80181: CALL_OW 250
80185: PPUSH
80186: LD_VAR 0 1
80190: PPUSH
80191: CALL_OW 251
80195: PPUSH
80196: LD_INT 10
80198: PPUSH
80199: LD_INT 0
80201: PPUSH
80202: CALL_OW 50
// continue ;
80206: GO 80107
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
80208: LD_VAR 0 12
80212: PUSH
80213: LD_INT 1
80215: ARRAY
80216: PPUSH
80217: CALL_OW 313
80221: PUSH
80222: LD_VAR 0 12
80226: PUSH
80227: LD_INT 1
80229: ARRAY
80230: PPUSH
80231: CALL_OW 266
80235: PUSH
80236: LD_INT 32
80238: PUSH
80239: LD_INT 31
80241: PUSH
80242: EMPTY
80243: LIST
80244: LIST
80245: IN
80246: AND
80247: PUSH
80248: LD_VAR 0 12
80252: PUSH
80253: LD_INT 1
80255: ARRAY
80256: PPUSH
80257: CALL_OW 313
80261: PUSH
80262: LD_INT 6
80264: EQUAL
80265: OR
80266: IFFALSE 80286
// f := Delete ( f , 1 ) ;
80268: LD_ADDR_VAR 0 12
80272: PUSH
80273: LD_VAR 0 12
80277: PPUSH
80278: LD_INT 1
80280: PPUSH
80281: CALL_OW 3
80285: ST_TO_ADDR
// if not f then
80286: LD_VAR 0 12
80290: NOT
80291: IFFALSE 80309
// begin x := x + 2 ;
80293: LD_ADDR_VAR 0 13
80297: PUSH
80298: LD_VAR 0 13
80302: PUSH
80303: LD_INT 2
80305: PLUS
80306: ST_TO_ADDR
// continue ;
80307: GO 80107
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
80309: LD_VAR 0 12
80313: PUSH
80314: LD_INT 1
80316: ARRAY
80317: PPUSH
80318: CALL_OW 266
80322: PUSH
80323: LD_INT 5
80325: EQUAL
80326: IFFALSE 80400
// begin if UnitsInside ( f [ 1 ] ) < 3 then
80328: LD_VAR 0 12
80332: PUSH
80333: LD_INT 1
80335: ARRAY
80336: PPUSH
80337: CALL_OW 313
80341: PUSH
80342: LD_INT 3
80344: LESS
80345: IFFALSE 80381
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
80347: LD_INT 0
80349: PPUSH
80350: LD_INT 5
80352: PUSH
80353: LD_INT 8
80355: PUSH
80356: LD_INT 9
80358: PUSH
80359: EMPTY
80360: LIST
80361: LIST
80362: LIST
80363: PUSH
80364: LD_VAR 0 17
80368: ARRAY
80369: PPUSH
80370: LD_VAR 0 4
80374: PPUSH
80375: CALL_OW 380
80379: GO 80398
// PrepareHuman ( false , i , skill ) ;
80381: LD_INT 0
80383: PPUSH
80384: LD_VAR 0 8
80388: PPUSH
80389: LD_VAR 0 4
80393: PPUSH
80394: CALL_OW 380
// end else
80398: GO 80417
// PrepareHuman ( false , i , skill ) ;
80400: LD_INT 0
80402: PPUSH
80403: LD_VAR 0 8
80407: PPUSH
80408: LD_VAR 0 4
80412: PPUSH
80413: CALL_OW 380
// un := CreateHuman ;
80417: LD_ADDR_VAR 0 14
80421: PUSH
80422: CALL_OW 44
80426: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
80427: LD_ADDR_VAR 0 7
80431: PUSH
80432: LD_VAR 0 7
80436: PPUSH
80437: LD_INT 1
80439: PPUSH
80440: LD_VAR 0 14
80444: PPUSH
80445: CALL_OW 2
80449: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
80450: LD_VAR 0 14
80454: PPUSH
80455: LD_VAR 0 12
80459: PUSH
80460: LD_INT 1
80462: ARRAY
80463: PPUSH
80464: CALL_OW 52
// end ;
80468: GO 80107
80470: POP
80471: POP
// end ;
80472: GO 79409
80474: POP
80475: POP
// result := result ^ buildings ;
80476: LD_ADDR_VAR 0 7
80480: PUSH
80481: LD_VAR 0 7
80485: PUSH
80486: LD_VAR 0 18
80490: ADD
80491: ST_TO_ADDR
// end else
80492: GO 80635
// begin for i = 1 to personel do
80494: LD_ADDR_VAR 0 8
80498: PUSH
80499: DOUBLE
80500: LD_INT 1
80502: DEC
80503: ST_TO_ADDR
80504: LD_VAR 0 6
80508: PUSH
80509: FOR_TO
80510: IFFALSE 80633
// begin if i > 4 then
80512: LD_VAR 0 8
80516: PUSH
80517: LD_INT 4
80519: GREATER
80520: IFFALSE 80524
// break ;
80522: GO 80633
// x := personel [ i ] ;
80524: LD_ADDR_VAR 0 13
80528: PUSH
80529: LD_VAR 0 6
80533: PUSH
80534: LD_VAR 0 8
80538: ARRAY
80539: ST_TO_ADDR
// if x = - 1 then
80540: LD_VAR 0 13
80544: PUSH
80545: LD_INT 1
80547: NEG
80548: EQUAL
80549: IFFALSE 80553
// continue ;
80551: GO 80509
// PrepareHuman ( false , i , skill ) ;
80553: LD_INT 0
80555: PPUSH
80556: LD_VAR 0 8
80560: PPUSH
80561: LD_VAR 0 4
80565: PPUSH
80566: CALL_OW 380
// un := CreateHuman ;
80570: LD_ADDR_VAR 0 14
80574: PUSH
80575: CALL_OW 44
80579: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
80580: LD_VAR 0 14
80584: PPUSH
80585: LD_VAR 0 1
80589: PPUSH
80590: CALL_OW 250
80594: PPUSH
80595: LD_VAR 0 1
80599: PPUSH
80600: CALL_OW 251
80604: PPUSH
80605: LD_INT 10
80607: PPUSH
80608: LD_INT 0
80610: PPUSH
80611: CALL_OW 50
// result := result ^ un ;
80615: LD_ADDR_VAR 0 7
80619: PUSH
80620: LD_VAR 0 7
80624: PUSH
80625: LD_VAR 0 14
80629: ADD
80630: ST_TO_ADDR
// end ;
80631: GO 80509
80633: POP
80634: POP
// end ; end ;
80635: LD_VAR 0 7
80639: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
80640: LD_INT 0
80642: PPUSH
80643: PPUSH
80644: PPUSH
80645: PPUSH
80646: PPUSH
80647: PPUSH
80648: PPUSH
80649: PPUSH
80650: PPUSH
80651: PPUSH
80652: PPUSH
80653: PPUSH
80654: PPUSH
80655: PPUSH
80656: PPUSH
80657: PPUSH
// result := false ;
80658: LD_ADDR_VAR 0 3
80662: PUSH
80663: LD_INT 0
80665: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
80666: LD_VAR 0 1
80670: NOT
80671: PUSH
80672: LD_VAR 0 1
80676: PPUSH
80677: CALL_OW 266
80681: PUSH
80682: LD_INT 32
80684: PUSH
80685: LD_INT 33
80687: PUSH
80688: EMPTY
80689: LIST
80690: LIST
80691: IN
80692: NOT
80693: OR
80694: IFFALSE 80698
// exit ;
80696: GO 81807
// nat := GetNation ( tower ) ;
80698: LD_ADDR_VAR 0 12
80702: PUSH
80703: LD_VAR 0 1
80707: PPUSH
80708: CALL_OW 248
80712: ST_TO_ADDR
// side := GetSide ( tower ) ;
80713: LD_ADDR_VAR 0 16
80717: PUSH
80718: LD_VAR 0 1
80722: PPUSH
80723: CALL_OW 255
80727: ST_TO_ADDR
// x := GetX ( tower ) ;
80728: LD_ADDR_VAR 0 10
80732: PUSH
80733: LD_VAR 0 1
80737: PPUSH
80738: CALL_OW 250
80742: ST_TO_ADDR
// y := GetY ( tower ) ;
80743: LD_ADDR_VAR 0 11
80747: PUSH
80748: LD_VAR 0 1
80752: PPUSH
80753: CALL_OW 251
80757: ST_TO_ADDR
// if not x or not y then
80758: LD_VAR 0 10
80762: NOT
80763: PUSH
80764: LD_VAR 0 11
80768: NOT
80769: OR
80770: IFFALSE 80774
// exit ;
80772: GO 81807
// weapon := 0 ;
80774: LD_ADDR_VAR 0 18
80778: PUSH
80779: LD_INT 0
80781: ST_TO_ADDR
// fac_list := [ ] ;
80782: LD_ADDR_VAR 0 17
80786: PUSH
80787: EMPTY
80788: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
80789: LD_ADDR_VAR 0 6
80793: PUSH
80794: LD_VAR 0 1
80798: PPUSH
80799: CALL_OW 274
80803: PPUSH
80804: LD_VAR 0 2
80808: PPUSH
80809: LD_INT 0
80811: PPUSH
80812: CALL 78378 0 3
80816: PPUSH
80817: LD_INT 30
80819: PUSH
80820: LD_INT 3
80822: PUSH
80823: EMPTY
80824: LIST
80825: LIST
80826: PPUSH
80827: CALL_OW 72
80831: ST_TO_ADDR
// if not factories then
80832: LD_VAR 0 6
80836: NOT
80837: IFFALSE 80841
// exit ;
80839: GO 81807
// for i in factories do
80841: LD_ADDR_VAR 0 8
80845: PUSH
80846: LD_VAR 0 6
80850: PUSH
80851: FOR_IN
80852: IFFALSE 80877
// fac_list := fac_list union AvailableWeaponList ( i ) ;
80854: LD_ADDR_VAR 0 17
80858: PUSH
80859: LD_VAR 0 17
80863: PUSH
80864: LD_VAR 0 8
80868: PPUSH
80869: CALL_OW 478
80873: UNION
80874: ST_TO_ADDR
80875: GO 80851
80877: POP
80878: POP
// if not fac_list then
80879: LD_VAR 0 17
80883: NOT
80884: IFFALSE 80888
// exit ;
80886: GO 81807
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
80888: LD_ADDR_VAR 0 5
80892: PUSH
80893: LD_INT 4
80895: PUSH
80896: LD_INT 5
80898: PUSH
80899: LD_INT 9
80901: PUSH
80902: LD_INT 10
80904: PUSH
80905: LD_INT 6
80907: PUSH
80908: LD_INT 7
80910: PUSH
80911: LD_INT 11
80913: PUSH
80914: EMPTY
80915: LIST
80916: LIST
80917: LIST
80918: LIST
80919: LIST
80920: LIST
80921: LIST
80922: PUSH
80923: LD_INT 27
80925: PUSH
80926: LD_INT 28
80928: PUSH
80929: LD_INT 26
80931: PUSH
80932: LD_INT 30
80934: PUSH
80935: EMPTY
80936: LIST
80937: LIST
80938: LIST
80939: LIST
80940: PUSH
80941: LD_INT 43
80943: PUSH
80944: LD_INT 44
80946: PUSH
80947: LD_INT 46
80949: PUSH
80950: LD_INT 45
80952: PUSH
80953: LD_INT 47
80955: PUSH
80956: LD_INT 49
80958: PUSH
80959: EMPTY
80960: LIST
80961: LIST
80962: LIST
80963: LIST
80964: LIST
80965: LIST
80966: PUSH
80967: EMPTY
80968: LIST
80969: LIST
80970: LIST
80971: PUSH
80972: LD_VAR 0 12
80976: ARRAY
80977: ST_TO_ADDR
// list := list isect fac_list ;
80978: LD_ADDR_VAR 0 5
80982: PUSH
80983: LD_VAR 0 5
80987: PUSH
80988: LD_VAR 0 17
80992: ISECT
80993: ST_TO_ADDR
// if not list then
80994: LD_VAR 0 5
80998: NOT
80999: IFFALSE 81003
// exit ;
81001: GO 81807
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
81003: LD_VAR 0 12
81007: PUSH
81008: LD_INT 3
81010: EQUAL
81011: PUSH
81012: LD_INT 49
81014: PUSH
81015: LD_VAR 0 5
81019: IN
81020: AND
81021: PUSH
81022: LD_INT 31
81024: PPUSH
81025: LD_VAR 0 16
81029: PPUSH
81030: CALL_OW 321
81034: PUSH
81035: LD_INT 2
81037: EQUAL
81038: AND
81039: IFFALSE 81099
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
81041: LD_INT 22
81043: PUSH
81044: LD_VAR 0 16
81048: PUSH
81049: EMPTY
81050: LIST
81051: LIST
81052: PUSH
81053: LD_INT 35
81055: PUSH
81056: LD_INT 49
81058: PUSH
81059: EMPTY
81060: LIST
81061: LIST
81062: PUSH
81063: LD_INT 91
81065: PUSH
81066: LD_VAR 0 1
81070: PUSH
81071: LD_INT 10
81073: PUSH
81074: EMPTY
81075: LIST
81076: LIST
81077: LIST
81078: PUSH
81079: EMPTY
81080: LIST
81081: LIST
81082: LIST
81083: PPUSH
81084: CALL_OW 69
81088: NOT
81089: IFFALSE 81099
// weapon := ru_time_lapser ;
81091: LD_ADDR_VAR 0 18
81095: PUSH
81096: LD_INT 49
81098: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
81099: LD_VAR 0 12
81103: PUSH
81104: LD_INT 1
81106: PUSH
81107: LD_INT 2
81109: PUSH
81110: EMPTY
81111: LIST
81112: LIST
81113: IN
81114: PUSH
81115: LD_INT 11
81117: PUSH
81118: LD_VAR 0 5
81122: IN
81123: PUSH
81124: LD_INT 30
81126: PUSH
81127: LD_VAR 0 5
81131: IN
81132: OR
81133: AND
81134: PUSH
81135: LD_INT 6
81137: PPUSH
81138: LD_VAR 0 16
81142: PPUSH
81143: CALL_OW 321
81147: PUSH
81148: LD_INT 2
81150: EQUAL
81151: AND
81152: IFFALSE 81317
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
81154: LD_INT 22
81156: PUSH
81157: LD_VAR 0 16
81161: PUSH
81162: EMPTY
81163: LIST
81164: LIST
81165: PUSH
81166: LD_INT 2
81168: PUSH
81169: LD_INT 35
81171: PUSH
81172: LD_INT 11
81174: PUSH
81175: EMPTY
81176: LIST
81177: LIST
81178: PUSH
81179: LD_INT 35
81181: PUSH
81182: LD_INT 30
81184: PUSH
81185: EMPTY
81186: LIST
81187: LIST
81188: PUSH
81189: EMPTY
81190: LIST
81191: LIST
81192: LIST
81193: PUSH
81194: LD_INT 91
81196: PUSH
81197: LD_VAR 0 1
81201: PUSH
81202: LD_INT 18
81204: PUSH
81205: EMPTY
81206: LIST
81207: LIST
81208: LIST
81209: PUSH
81210: EMPTY
81211: LIST
81212: LIST
81213: LIST
81214: PPUSH
81215: CALL_OW 69
81219: NOT
81220: PUSH
81221: LD_INT 22
81223: PUSH
81224: LD_VAR 0 16
81228: PUSH
81229: EMPTY
81230: LIST
81231: LIST
81232: PUSH
81233: LD_INT 2
81235: PUSH
81236: LD_INT 30
81238: PUSH
81239: LD_INT 32
81241: PUSH
81242: EMPTY
81243: LIST
81244: LIST
81245: PUSH
81246: LD_INT 30
81248: PUSH
81249: LD_INT 33
81251: PUSH
81252: EMPTY
81253: LIST
81254: LIST
81255: PUSH
81256: EMPTY
81257: LIST
81258: LIST
81259: LIST
81260: PUSH
81261: LD_INT 91
81263: PUSH
81264: LD_VAR 0 1
81268: PUSH
81269: LD_INT 12
81271: PUSH
81272: EMPTY
81273: LIST
81274: LIST
81275: LIST
81276: PUSH
81277: EMPTY
81278: LIST
81279: LIST
81280: LIST
81281: PUSH
81282: EMPTY
81283: LIST
81284: PPUSH
81285: CALL_OW 69
81289: PUSH
81290: LD_INT 2
81292: GREATER
81293: AND
81294: IFFALSE 81317
// weapon := [ us_radar , ar_radar ] [ nat ] ;
81296: LD_ADDR_VAR 0 18
81300: PUSH
81301: LD_INT 11
81303: PUSH
81304: LD_INT 30
81306: PUSH
81307: EMPTY
81308: LIST
81309: LIST
81310: PUSH
81311: LD_VAR 0 12
81315: ARRAY
81316: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
81317: LD_VAR 0 18
81321: NOT
81322: PUSH
81323: LD_INT 40
81325: PPUSH
81326: LD_VAR 0 16
81330: PPUSH
81331: CALL_OW 321
81335: PUSH
81336: LD_INT 2
81338: EQUAL
81339: AND
81340: PUSH
81341: LD_INT 7
81343: PUSH
81344: LD_VAR 0 5
81348: IN
81349: PUSH
81350: LD_INT 28
81352: PUSH
81353: LD_VAR 0 5
81357: IN
81358: OR
81359: PUSH
81360: LD_INT 45
81362: PUSH
81363: LD_VAR 0 5
81367: IN
81368: OR
81369: AND
81370: IFFALSE 81624
// begin hex := GetHexInfo ( x , y ) ;
81372: LD_ADDR_VAR 0 4
81376: PUSH
81377: LD_VAR 0 10
81381: PPUSH
81382: LD_VAR 0 11
81386: PPUSH
81387: CALL_OW 546
81391: ST_TO_ADDR
// if hex [ 1 ] then
81392: LD_VAR 0 4
81396: PUSH
81397: LD_INT 1
81399: ARRAY
81400: IFFALSE 81404
// exit ;
81402: GO 81807
// height := hex [ 2 ] ;
81404: LD_ADDR_VAR 0 15
81408: PUSH
81409: LD_VAR 0 4
81413: PUSH
81414: LD_INT 2
81416: ARRAY
81417: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
81418: LD_ADDR_VAR 0 14
81422: PUSH
81423: LD_INT 0
81425: PUSH
81426: LD_INT 2
81428: PUSH
81429: LD_INT 3
81431: PUSH
81432: LD_INT 5
81434: PUSH
81435: EMPTY
81436: LIST
81437: LIST
81438: LIST
81439: LIST
81440: ST_TO_ADDR
// for i in tmp do
81441: LD_ADDR_VAR 0 8
81445: PUSH
81446: LD_VAR 0 14
81450: PUSH
81451: FOR_IN
81452: IFFALSE 81622
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
81454: LD_ADDR_VAR 0 9
81458: PUSH
81459: LD_VAR 0 10
81463: PPUSH
81464: LD_VAR 0 8
81468: PPUSH
81469: LD_INT 5
81471: PPUSH
81472: CALL_OW 272
81476: PUSH
81477: LD_VAR 0 11
81481: PPUSH
81482: LD_VAR 0 8
81486: PPUSH
81487: LD_INT 5
81489: PPUSH
81490: CALL_OW 273
81494: PUSH
81495: EMPTY
81496: LIST
81497: LIST
81498: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
81499: LD_VAR 0 9
81503: PUSH
81504: LD_INT 1
81506: ARRAY
81507: PPUSH
81508: LD_VAR 0 9
81512: PUSH
81513: LD_INT 2
81515: ARRAY
81516: PPUSH
81517: CALL_OW 488
81521: IFFALSE 81620
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
81523: LD_ADDR_VAR 0 4
81527: PUSH
81528: LD_VAR 0 9
81532: PUSH
81533: LD_INT 1
81535: ARRAY
81536: PPUSH
81537: LD_VAR 0 9
81541: PUSH
81542: LD_INT 2
81544: ARRAY
81545: PPUSH
81546: CALL_OW 546
81550: ST_TO_ADDR
// if hex [ 1 ] then
81551: LD_VAR 0 4
81555: PUSH
81556: LD_INT 1
81558: ARRAY
81559: IFFALSE 81563
// continue ;
81561: GO 81451
// h := hex [ 2 ] ;
81563: LD_ADDR_VAR 0 13
81567: PUSH
81568: LD_VAR 0 4
81572: PUSH
81573: LD_INT 2
81575: ARRAY
81576: ST_TO_ADDR
// if h + 7 < height then
81577: LD_VAR 0 13
81581: PUSH
81582: LD_INT 7
81584: PLUS
81585: PUSH
81586: LD_VAR 0 15
81590: LESS
81591: IFFALSE 81620
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
81593: LD_ADDR_VAR 0 18
81597: PUSH
81598: LD_INT 7
81600: PUSH
81601: LD_INT 28
81603: PUSH
81604: LD_INT 45
81606: PUSH
81607: EMPTY
81608: LIST
81609: LIST
81610: LIST
81611: PUSH
81612: LD_VAR 0 12
81616: ARRAY
81617: ST_TO_ADDR
// break ;
81618: GO 81622
// end ; end ; end ;
81620: GO 81451
81622: POP
81623: POP
// end ; if not weapon then
81624: LD_VAR 0 18
81628: NOT
81629: IFFALSE 81689
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
81631: LD_ADDR_VAR 0 5
81635: PUSH
81636: LD_VAR 0 5
81640: PUSH
81641: LD_INT 11
81643: PUSH
81644: LD_INT 30
81646: PUSH
81647: LD_INT 49
81649: PUSH
81650: EMPTY
81651: LIST
81652: LIST
81653: LIST
81654: DIFF
81655: ST_TO_ADDR
// if not list then
81656: LD_VAR 0 5
81660: NOT
81661: IFFALSE 81665
// exit ;
81663: GO 81807
// weapon := list [ rand ( 1 , list ) ] ;
81665: LD_ADDR_VAR 0 18
81669: PUSH
81670: LD_VAR 0 5
81674: PUSH
81675: LD_INT 1
81677: PPUSH
81678: LD_VAR 0 5
81682: PPUSH
81683: CALL_OW 12
81687: ARRAY
81688: ST_TO_ADDR
// end ; if weapon then
81689: LD_VAR 0 18
81693: IFFALSE 81807
// begin tmp := CostOfWeapon ( weapon ) ;
81695: LD_ADDR_VAR 0 14
81699: PUSH
81700: LD_VAR 0 18
81704: PPUSH
81705: CALL_OW 451
81709: ST_TO_ADDR
// j := GetBase ( tower ) ;
81710: LD_ADDR_VAR 0 9
81714: PUSH
81715: LD_VAR 0 1
81719: PPUSH
81720: CALL_OW 274
81724: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
81725: LD_VAR 0 9
81729: PPUSH
81730: LD_INT 1
81732: PPUSH
81733: CALL_OW 275
81737: PUSH
81738: LD_VAR 0 14
81742: PUSH
81743: LD_INT 1
81745: ARRAY
81746: GREATEREQUAL
81747: PUSH
81748: LD_VAR 0 9
81752: PPUSH
81753: LD_INT 2
81755: PPUSH
81756: CALL_OW 275
81760: PUSH
81761: LD_VAR 0 14
81765: PUSH
81766: LD_INT 2
81768: ARRAY
81769: GREATEREQUAL
81770: AND
81771: PUSH
81772: LD_VAR 0 9
81776: PPUSH
81777: LD_INT 3
81779: PPUSH
81780: CALL_OW 275
81784: PUSH
81785: LD_VAR 0 14
81789: PUSH
81790: LD_INT 3
81792: ARRAY
81793: GREATEREQUAL
81794: AND
81795: IFFALSE 81807
// result := weapon ;
81797: LD_ADDR_VAR 0 3
81801: PUSH
81802: LD_VAR 0 18
81806: ST_TO_ADDR
// end ; end ;
81807: LD_VAR 0 3
81811: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
81812: LD_INT 0
81814: PPUSH
81815: PPUSH
// result := true ;
81816: LD_ADDR_VAR 0 3
81820: PUSH
81821: LD_INT 1
81823: ST_TO_ADDR
// if array1 = array2 then
81824: LD_VAR 0 1
81828: PUSH
81829: LD_VAR 0 2
81833: EQUAL
81834: IFFALSE 81894
// begin for i = 1 to array1 do
81836: LD_ADDR_VAR 0 4
81840: PUSH
81841: DOUBLE
81842: LD_INT 1
81844: DEC
81845: ST_TO_ADDR
81846: LD_VAR 0 1
81850: PUSH
81851: FOR_TO
81852: IFFALSE 81890
// if array1 [ i ] <> array2 [ i ] then
81854: LD_VAR 0 1
81858: PUSH
81859: LD_VAR 0 4
81863: ARRAY
81864: PUSH
81865: LD_VAR 0 2
81869: PUSH
81870: LD_VAR 0 4
81874: ARRAY
81875: NONEQUAL
81876: IFFALSE 81888
// begin result := false ;
81878: LD_ADDR_VAR 0 3
81882: PUSH
81883: LD_INT 0
81885: ST_TO_ADDR
// break ;
81886: GO 81890
// end ;
81888: GO 81851
81890: POP
81891: POP
// end else
81892: GO 81902
// result := false ;
81894: LD_ADDR_VAR 0 3
81898: PUSH
81899: LD_INT 0
81901: ST_TO_ADDR
// end ;
81902: LD_VAR 0 3
81906: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
81907: LD_INT 0
81909: PPUSH
81910: PPUSH
// if not array1 or not array2 then
81911: LD_VAR 0 1
81915: NOT
81916: PUSH
81917: LD_VAR 0 2
81921: NOT
81922: OR
81923: IFFALSE 81927
// exit ;
81925: GO 81991
// result := true ;
81927: LD_ADDR_VAR 0 3
81931: PUSH
81932: LD_INT 1
81934: ST_TO_ADDR
// for i = 1 to array1 do
81935: LD_ADDR_VAR 0 4
81939: PUSH
81940: DOUBLE
81941: LD_INT 1
81943: DEC
81944: ST_TO_ADDR
81945: LD_VAR 0 1
81949: PUSH
81950: FOR_TO
81951: IFFALSE 81989
// if array1 [ i ] <> array2 [ i ] then
81953: LD_VAR 0 1
81957: PUSH
81958: LD_VAR 0 4
81962: ARRAY
81963: PUSH
81964: LD_VAR 0 2
81968: PUSH
81969: LD_VAR 0 4
81973: ARRAY
81974: NONEQUAL
81975: IFFALSE 81987
// begin result := false ;
81977: LD_ADDR_VAR 0 3
81981: PUSH
81982: LD_INT 0
81984: ST_TO_ADDR
// break ;
81985: GO 81989
// end ;
81987: GO 81950
81989: POP
81990: POP
// end ;
81991: LD_VAR 0 3
81995: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
81996: LD_INT 0
81998: PPUSH
81999: PPUSH
82000: PPUSH
// pom := GetBase ( fac ) ;
82001: LD_ADDR_VAR 0 5
82005: PUSH
82006: LD_VAR 0 1
82010: PPUSH
82011: CALL_OW 274
82015: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
82016: LD_ADDR_VAR 0 4
82020: PUSH
82021: LD_VAR 0 2
82025: PUSH
82026: LD_INT 1
82028: ARRAY
82029: PPUSH
82030: LD_VAR 0 2
82034: PUSH
82035: LD_INT 2
82037: ARRAY
82038: PPUSH
82039: LD_VAR 0 2
82043: PUSH
82044: LD_INT 3
82046: ARRAY
82047: PPUSH
82048: LD_VAR 0 2
82052: PUSH
82053: LD_INT 4
82055: ARRAY
82056: PPUSH
82057: CALL_OW 449
82061: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
82062: LD_ADDR_VAR 0 3
82066: PUSH
82067: LD_VAR 0 5
82071: PPUSH
82072: LD_INT 1
82074: PPUSH
82075: CALL_OW 275
82079: PUSH
82080: LD_VAR 0 4
82084: PUSH
82085: LD_INT 1
82087: ARRAY
82088: GREATEREQUAL
82089: PUSH
82090: LD_VAR 0 5
82094: PPUSH
82095: LD_INT 2
82097: PPUSH
82098: CALL_OW 275
82102: PUSH
82103: LD_VAR 0 4
82107: PUSH
82108: LD_INT 2
82110: ARRAY
82111: GREATEREQUAL
82112: AND
82113: PUSH
82114: LD_VAR 0 5
82118: PPUSH
82119: LD_INT 3
82121: PPUSH
82122: CALL_OW 275
82126: PUSH
82127: LD_VAR 0 4
82131: PUSH
82132: LD_INT 3
82134: ARRAY
82135: GREATEREQUAL
82136: AND
82137: ST_TO_ADDR
// end ;
82138: LD_VAR 0 3
82142: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
82143: LD_INT 0
82145: PPUSH
82146: PPUSH
82147: PPUSH
82148: PPUSH
// pom := GetBase ( building ) ;
82149: LD_ADDR_VAR 0 3
82153: PUSH
82154: LD_VAR 0 1
82158: PPUSH
82159: CALL_OW 274
82163: ST_TO_ADDR
// if not pom then
82164: LD_VAR 0 3
82168: NOT
82169: IFFALSE 82173
// exit ;
82171: GO 82343
// btype := GetBType ( building ) ;
82173: LD_ADDR_VAR 0 5
82177: PUSH
82178: LD_VAR 0 1
82182: PPUSH
82183: CALL_OW 266
82187: ST_TO_ADDR
// if btype = b_armoury then
82188: LD_VAR 0 5
82192: PUSH
82193: LD_INT 4
82195: EQUAL
82196: IFFALSE 82206
// btype := b_barracks ;
82198: LD_ADDR_VAR 0 5
82202: PUSH
82203: LD_INT 5
82205: ST_TO_ADDR
// if btype = b_depot then
82206: LD_VAR 0 5
82210: PUSH
82211: LD_INT 0
82213: EQUAL
82214: IFFALSE 82224
// btype := b_warehouse ;
82216: LD_ADDR_VAR 0 5
82220: PUSH
82221: LD_INT 1
82223: ST_TO_ADDR
// if btype = b_workshop then
82224: LD_VAR 0 5
82228: PUSH
82229: LD_INT 2
82231: EQUAL
82232: IFFALSE 82242
// btype := b_factory ;
82234: LD_ADDR_VAR 0 5
82238: PUSH
82239: LD_INT 3
82241: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
82242: LD_ADDR_VAR 0 4
82246: PUSH
82247: LD_VAR 0 5
82251: PPUSH
82252: LD_VAR 0 1
82256: PPUSH
82257: CALL_OW 248
82261: PPUSH
82262: CALL_OW 450
82266: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
82267: LD_ADDR_VAR 0 2
82271: PUSH
82272: LD_VAR 0 3
82276: PPUSH
82277: LD_INT 1
82279: PPUSH
82280: CALL_OW 275
82284: PUSH
82285: LD_VAR 0 4
82289: PUSH
82290: LD_INT 1
82292: ARRAY
82293: GREATEREQUAL
82294: PUSH
82295: LD_VAR 0 3
82299: PPUSH
82300: LD_INT 2
82302: PPUSH
82303: CALL_OW 275
82307: PUSH
82308: LD_VAR 0 4
82312: PUSH
82313: LD_INT 2
82315: ARRAY
82316: GREATEREQUAL
82317: AND
82318: PUSH
82319: LD_VAR 0 3
82323: PPUSH
82324: LD_INT 3
82326: PPUSH
82327: CALL_OW 275
82331: PUSH
82332: LD_VAR 0 4
82336: PUSH
82337: LD_INT 3
82339: ARRAY
82340: GREATEREQUAL
82341: AND
82342: ST_TO_ADDR
// end ;
82343: LD_VAR 0 2
82347: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
82348: LD_INT 0
82350: PPUSH
82351: PPUSH
82352: PPUSH
// pom := GetBase ( building ) ;
82353: LD_ADDR_VAR 0 4
82357: PUSH
82358: LD_VAR 0 1
82362: PPUSH
82363: CALL_OW 274
82367: ST_TO_ADDR
// if not pom then
82368: LD_VAR 0 4
82372: NOT
82373: IFFALSE 82377
// exit ;
82375: GO 82478
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
82377: LD_ADDR_VAR 0 5
82381: PUSH
82382: LD_VAR 0 2
82386: PPUSH
82387: LD_VAR 0 1
82391: PPUSH
82392: CALL_OW 248
82396: PPUSH
82397: CALL_OW 450
82401: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
82402: LD_ADDR_VAR 0 3
82406: PUSH
82407: LD_VAR 0 4
82411: PPUSH
82412: LD_INT 1
82414: PPUSH
82415: CALL_OW 275
82419: PUSH
82420: LD_VAR 0 5
82424: PUSH
82425: LD_INT 1
82427: ARRAY
82428: GREATEREQUAL
82429: PUSH
82430: LD_VAR 0 4
82434: PPUSH
82435: LD_INT 2
82437: PPUSH
82438: CALL_OW 275
82442: PUSH
82443: LD_VAR 0 5
82447: PUSH
82448: LD_INT 2
82450: ARRAY
82451: GREATEREQUAL
82452: AND
82453: PUSH
82454: LD_VAR 0 4
82458: PPUSH
82459: LD_INT 3
82461: PPUSH
82462: CALL_OW 275
82466: PUSH
82467: LD_VAR 0 5
82471: PUSH
82472: LD_INT 3
82474: ARRAY
82475: GREATEREQUAL
82476: AND
82477: ST_TO_ADDR
// end ;
82478: LD_VAR 0 3
82482: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
82483: LD_INT 0
82485: PPUSH
82486: PPUSH
82487: PPUSH
82488: PPUSH
82489: PPUSH
82490: PPUSH
82491: PPUSH
82492: PPUSH
82493: PPUSH
82494: PPUSH
82495: PPUSH
// result := false ;
82496: LD_ADDR_VAR 0 8
82500: PUSH
82501: LD_INT 0
82503: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
82504: LD_VAR 0 5
82508: NOT
82509: PUSH
82510: LD_VAR 0 1
82514: NOT
82515: OR
82516: PUSH
82517: LD_VAR 0 2
82521: NOT
82522: OR
82523: PUSH
82524: LD_VAR 0 3
82528: NOT
82529: OR
82530: IFFALSE 82534
// exit ;
82532: GO 83348
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
82534: LD_ADDR_VAR 0 14
82538: PUSH
82539: LD_VAR 0 1
82543: PPUSH
82544: LD_VAR 0 2
82548: PPUSH
82549: LD_VAR 0 3
82553: PPUSH
82554: LD_VAR 0 4
82558: PPUSH
82559: LD_VAR 0 5
82563: PUSH
82564: LD_INT 1
82566: ARRAY
82567: PPUSH
82568: CALL_OW 248
82572: PPUSH
82573: LD_INT 0
82575: PPUSH
82576: CALL 84601 0 6
82580: ST_TO_ADDR
// if not hexes then
82581: LD_VAR 0 14
82585: NOT
82586: IFFALSE 82590
// exit ;
82588: GO 83348
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
82590: LD_ADDR_VAR 0 17
82594: PUSH
82595: LD_VAR 0 5
82599: PPUSH
82600: LD_INT 22
82602: PUSH
82603: LD_VAR 0 13
82607: PPUSH
82608: CALL_OW 255
82612: PUSH
82613: EMPTY
82614: LIST
82615: LIST
82616: PUSH
82617: LD_INT 2
82619: PUSH
82620: LD_INT 30
82622: PUSH
82623: LD_INT 0
82625: PUSH
82626: EMPTY
82627: LIST
82628: LIST
82629: PUSH
82630: LD_INT 30
82632: PUSH
82633: LD_INT 1
82635: PUSH
82636: EMPTY
82637: LIST
82638: LIST
82639: PUSH
82640: EMPTY
82641: LIST
82642: LIST
82643: LIST
82644: PUSH
82645: EMPTY
82646: LIST
82647: LIST
82648: PPUSH
82649: CALL_OW 72
82653: ST_TO_ADDR
// for i = 1 to hexes do
82654: LD_ADDR_VAR 0 9
82658: PUSH
82659: DOUBLE
82660: LD_INT 1
82662: DEC
82663: ST_TO_ADDR
82664: LD_VAR 0 14
82668: PUSH
82669: FOR_TO
82670: IFFALSE 83346
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
82672: LD_ADDR_VAR 0 13
82676: PUSH
82677: LD_VAR 0 14
82681: PUSH
82682: LD_VAR 0 9
82686: ARRAY
82687: PUSH
82688: LD_INT 1
82690: ARRAY
82691: PPUSH
82692: LD_VAR 0 14
82696: PUSH
82697: LD_VAR 0 9
82701: ARRAY
82702: PUSH
82703: LD_INT 2
82705: ARRAY
82706: PPUSH
82707: CALL_OW 428
82711: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
82712: LD_VAR 0 14
82716: PUSH
82717: LD_VAR 0 9
82721: ARRAY
82722: PUSH
82723: LD_INT 1
82725: ARRAY
82726: PPUSH
82727: LD_VAR 0 14
82731: PUSH
82732: LD_VAR 0 9
82736: ARRAY
82737: PUSH
82738: LD_INT 2
82740: ARRAY
82741: PPUSH
82742: CALL_OW 351
82746: PUSH
82747: LD_VAR 0 14
82751: PUSH
82752: LD_VAR 0 9
82756: ARRAY
82757: PUSH
82758: LD_INT 1
82760: ARRAY
82761: PPUSH
82762: LD_VAR 0 14
82766: PUSH
82767: LD_VAR 0 9
82771: ARRAY
82772: PUSH
82773: LD_INT 2
82775: ARRAY
82776: PPUSH
82777: CALL_OW 488
82781: NOT
82782: OR
82783: PUSH
82784: LD_VAR 0 13
82788: PPUSH
82789: CALL_OW 247
82793: PUSH
82794: LD_INT 3
82796: EQUAL
82797: OR
82798: IFFALSE 82804
// exit ;
82800: POP
82801: POP
82802: GO 83348
// if not tmp then
82804: LD_VAR 0 13
82808: NOT
82809: IFFALSE 82813
// continue ;
82811: GO 82669
// result := true ;
82813: LD_ADDR_VAR 0 8
82817: PUSH
82818: LD_INT 1
82820: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
82821: LD_VAR 0 6
82825: PUSH
82826: LD_VAR 0 13
82830: PPUSH
82831: CALL_OW 247
82835: PUSH
82836: LD_INT 2
82838: EQUAL
82839: AND
82840: PUSH
82841: LD_VAR 0 13
82845: PPUSH
82846: CALL_OW 263
82850: PUSH
82851: LD_INT 1
82853: EQUAL
82854: AND
82855: IFFALSE 83019
// begin if IsDrivenBy ( tmp ) then
82857: LD_VAR 0 13
82861: PPUSH
82862: CALL_OW 311
82866: IFFALSE 82870
// continue ;
82868: GO 82669
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
82870: LD_VAR 0 6
82874: PPUSH
82875: LD_INT 3
82877: PUSH
82878: LD_INT 60
82880: PUSH
82881: EMPTY
82882: LIST
82883: PUSH
82884: EMPTY
82885: LIST
82886: LIST
82887: PUSH
82888: LD_INT 3
82890: PUSH
82891: LD_INT 55
82893: PUSH
82894: EMPTY
82895: LIST
82896: PUSH
82897: EMPTY
82898: LIST
82899: LIST
82900: PUSH
82901: EMPTY
82902: LIST
82903: LIST
82904: PPUSH
82905: CALL_OW 72
82909: IFFALSE 83017
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
82911: LD_ADDR_VAR 0 18
82915: PUSH
82916: LD_VAR 0 6
82920: PPUSH
82921: LD_INT 3
82923: PUSH
82924: LD_INT 60
82926: PUSH
82927: EMPTY
82928: LIST
82929: PUSH
82930: EMPTY
82931: LIST
82932: LIST
82933: PUSH
82934: LD_INT 3
82936: PUSH
82937: LD_INT 55
82939: PUSH
82940: EMPTY
82941: LIST
82942: PUSH
82943: EMPTY
82944: LIST
82945: LIST
82946: PUSH
82947: EMPTY
82948: LIST
82949: LIST
82950: PPUSH
82951: CALL_OW 72
82955: PUSH
82956: LD_INT 1
82958: ARRAY
82959: ST_TO_ADDR
// if IsInUnit ( driver ) then
82960: LD_VAR 0 18
82964: PPUSH
82965: CALL_OW 310
82969: IFFALSE 82980
// ComExit ( driver ) ;
82971: LD_VAR 0 18
82975: PPUSH
82976: CALL 108402 0 1
// AddComEnterUnit ( driver , tmp ) ;
82980: LD_VAR 0 18
82984: PPUSH
82985: LD_VAR 0 13
82989: PPUSH
82990: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
82994: LD_VAR 0 18
82998: PPUSH
82999: LD_VAR 0 7
83003: PPUSH
83004: CALL_OW 173
// AddComExitVehicle ( driver ) ;
83008: LD_VAR 0 18
83012: PPUSH
83013: CALL_OW 181
// end ; continue ;
83017: GO 82669
// end ; if not cleaners or not tmp in cleaners then
83019: LD_VAR 0 6
83023: NOT
83024: PUSH
83025: LD_VAR 0 13
83029: PUSH
83030: LD_VAR 0 6
83034: IN
83035: NOT
83036: OR
83037: IFFALSE 83344
// begin if dep then
83039: LD_VAR 0 17
83043: IFFALSE 83179
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
83045: LD_ADDR_VAR 0 16
83049: PUSH
83050: LD_VAR 0 17
83054: PUSH
83055: LD_INT 1
83057: ARRAY
83058: PPUSH
83059: CALL_OW 250
83063: PPUSH
83064: LD_VAR 0 17
83068: PUSH
83069: LD_INT 1
83071: ARRAY
83072: PPUSH
83073: CALL_OW 254
83077: PPUSH
83078: LD_INT 5
83080: PPUSH
83081: CALL_OW 272
83085: PUSH
83086: LD_VAR 0 17
83090: PUSH
83091: LD_INT 1
83093: ARRAY
83094: PPUSH
83095: CALL_OW 251
83099: PPUSH
83100: LD_VAR 0 17
83104: PUSH
83105: LD_INT 1
83107: ARRAY
83108: PPUSH
83109: CALL_OW 254
83113: PPUSH
83114: LD_INT 5
83116: PPUSH
83117: CALL_OW 273
83121: PUSH
83122: EMPTY
83123: LIST
83124: LIST
83125: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
83126: LD_VAR 0 16
83130: PUSH
83131: LD_INT 1
83133: ARRAY
83134: PPUSH
83135: LD_VAR 0 16
83139: PUSH
83140: LD_INT 2
83142: ARRAY
83143: PPUSH
83144: CALL_OW 488
83148: IFFALSE 83179
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
83150: LD_VAR 0 13
83154: PPUSH
83155: LD_VAR 0 16
83159: PUSH
83160: LD_INT 1
83162: ARRAY
83163: PPUSH
83164: LD_VAR 0 16
83168: PUSH
83169: LD_INT 2
83171: ARRAY
83172: PPUSH
83173: CALL_OW 111
// continue ;
83177: GO 82669
// end ; end ; r := GetDir ( tmp ) ;
83179: LD_ADDR_VAR 0 15
83183: PUSH
83184: LD_VAR 0 13
83188: PPUSH
83189: CALL_OW 254
83193: ST_TO_ADDR
// if r = 5 then
83194: LD_VAR 0 15
83198: PUSH
83199: LD_INT 5
83201: EQUAL
83202: IFFALSE 83212
// r := 0 ;
83204: LD_ADDR_VAR 0 15
83208: PUSH
83209: LD_INT 0
83211: ST_TO_ADDR
// for j = r to 5 do
83212: LD_ADDR_VAR 0 10
83216: PUSH
83217: DOUBLE
83218: LD_VAR 0 15
83222: DEC
83223: ST_TO_ADDR
83224: LD_INT 5
83226: PUSH
83227: FOR_TO
83228: IFFALSE 83342
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
83230: LD_ADDR_VAR 0 11
83234: PUSH
83235: LD_VAR 0 13
83239: PPUSH
83240: CALL_OW 250
83244: PPUSH
83245: LD_VAR 0 10
83249: PPUSH
83250: LD_INT 2
83252: PPUSH
83253: CALL_OW 272
83257: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
83258: LD_ADDR_VAR 0 12
83262: PUSH
83263: LD_VAR 0 13
83267: PPUSH
83268: CALL_OW 251
83272: PPUSH
83273: LD_VAR 0 10
83277: PPUSH
83278: LD_INT 2
83280: PPUSH
83281: CALL_OW 273
83285: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
83286: LD_VAR 0 11
83290: PPUSH
83291: LD_VAR 0 12
83295: PPUSH
83296: CALL_OW 488
83300: PUSH
83301: LD_VAR 0 11
83305: PPUSH
83306: LD_VAR 0 12
83310: PPUSH
83311: CALL_OW 428
83315: NOT
83316: AND
83317: IFFALSE 83340
// begin ComMoveXY ( tmp , _x , _y ) ;
83319: LD_VAR 0 13
83323: PPUSH
83324: LD_VAR 0 11
83328: PPUSH
83329: LD_VAR 0 12
83333: PPUSH
83334: CALL_OW 111
// break ;
83338: GO 83342
// end ; end ;
83340: GO 83227
83342: POP
83343: POP
// end ; end ;
83344: GO 82669
83346: POP
83347: POP
// end ;
83348: LD_VAR 0 8
83352: RET
// export function BuildingTechInvented ( side , btype ) ; begin
83353: LD_INT 0
83355: PPUSH
// result := true ;
83356: LD_ADDR_VAR 0 3
83360: PUSH
83361: LD_INT 1
83363: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
83364: LD_VAR 0 2
83368: PUSH
83369: LD_INT 24
83371: DOUBLE
83372: EQUAL
83373: IFTRUE 83383
83375: LD_INT 33
83377: DOUBLE
83378: EQUAL
83379: IFTRUE 83383
83381: GO 83408
83383: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
83384: LD_ADDR_VAR 0 3
83388: PUSH
83389: LD_INT 32
83391: PPUSH
83392: LD_VAR 0 1
83396: PPUSH
83397: CALL_OW 321
83401: PUSH
83402: LD_INT 2
83404: EQUAL
83405: ST_TO_ADDR
83406: GO 83724
83408: LD_INT 20
83410: DOUBLE
83411: EQUAL
83412: IFTRUE 83416
83414: GO 83441
83416: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
83417: LD_ADDR_VAR 0 3
83421: PUSH
83422: LD_INT 6
83424: PPUSH
83425: LD_VAR 0 1
83429: PPUSH
83430: CALL_OW 321
83434: PUSH
83435: LD_INT 2
83437: EQUAL
83438: ST_TO_ADDR
83439: GO 83724
83441: LD_INT 22
83443: DOUBLE
83444: EQUAL
83445: IFTRUE 83455
83447: LD_INT 36
83449: DOUBLE
83450: EQUAL
83451: IFTRUE 83455
83453: GO 83480
83455: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
83456: LD_ADDR_VAR 0 3
83460: PUSH
83461: LD_INT 15
83463: PPUSH
83464: LD_VAR 0 1
83468: PPUSH
83469: CALL_OW 321
83473: PUSH
83474: LD_INT 2
83476: EQUAL
83477: ST_TO_ADDR
83478: GO 83724
83480: LD_INT 30
83482: DOUBLE
83483: EQUAL
83484: IFTRUE 83488
83486: GO 83513
83488: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
83489: LD_ADDR_VAR 0 3
83493: PUSH
83494: LD_INT 20
83496: PPUSH
83497: LD_VAR 0 1
83501: PPUSH
83502: CALL_OW 321
83506: PUSH
83507: LD_INT 2
83509: EQUAL
83510: ST_TO_ADDR
83511: GO 83724
83513: LD_INT 28
83515: DOUBLE
83516: EQUAL
83517: IFTRUE 83527
83519: LD_INT 21
83521: DOUBLE
83522: EQUAL
83523: IFTRUE 83527
83525: GO 83552
83527: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
83528: LD_ADDR_VAR 0 3
83532: PUSH
83533: LD_INT 21
83535: PPUSH
83536: LD_VAR 0 1
83540: PPUSH
83541: CALL_OW 321
83545: PUSH
83546: LD_INT 2
83548: EQUAL
83549: ST_TO_ADDR
83550: GO 83724
83552: LD_INT 16
83554: DOUBLE
83555: EQUAL
83556: IFTRUE 83560
83558: GO 83585
83560: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
83561: LD_ADDR_VAR 0 3
83565: PUSH
83566: LD_INT 84
83568: PPUSH
83569: LD_VAR 0 1
83573: PPUSH
83574: CALL_OW 321
83578: PUSH
83579: LD_INT 2
83581: EQUAL
83582: ST_TO_ADDR
83583: GO 83724
83585: LD_INT 19
83587: DOUBLE
83588: EQUAL
83589: IFTRUE 83599
83591: LD_INT 23
83593: DOUBLE
83594: EQUAL
83595: IFTRUE 83599
83597: GO 83624
83599: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
83600: LD_ADDR_VAR 0 3
83604: PUSH
83605: LD_INT 83
83607: PPUSH
83608: LD_VAR 0 1
83612: PPUSH
83613: CALL_OW 321
83617: PUSH
83618: LD_INT 2
83620: EQUAL
83621: ST_TO_ADDR
83622: GO 83724
83624: LD_INT 17
83626: DOUBLE
83627: EQUAL
83628: IFTRUE 83632
83630: GO 83657
83632: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
83633: LD_ADDR_VAR 0 3
83637: PUSH
83638: LD_INT 39
83640: PPUSH
83641: LD_VAR 0 1
83645: PPUSH
83646: CALL_OW 321
83650: PUSH
83651: LD_INT 2
83653: EQUAL
83654: ST_TO_ADDR
83655: GO 83724
83657: LD_INT 18
83659: DOUBLE
83660: EQUAL
83661: IFTRUE 83665
83663: GO 83690
83665: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
83666: LD_ADDR_VAR 0 3
83670: PUSH
83671: LD_INT 40
83673: PPUSH
83674: LD_VAR 0 1
83678: PPUSH
83679: CALL_OW 321
83683: PUSH
83684: LD_INT 2
83686: EQUAL
83687: ST_TO_ADDR
83688: GO 83724
83690: LD_INT 27
83692: DOUBLE
83693: EQUAL
83694: IFTRUE 83698
83696: GO 83723
83698: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
83699: LD_ADDR_VAR 0 3
83703: PUSH
83704: LD_INT 35
83706: PPUSH
83707: LD_VAR 0 1
83711: PPUSH
83712: CALL_OW 321
83716: PUSH
83717: LD_INT 2
83719: EQUAL
83720: ST_TO_ADDR
83721: GO 83724
83723: POP
// end ;
83724: LD_VAR 0 3
83728: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
83729: LD_INT 0
83731: PPUSH
83732: PPUSH
83733: PPUSH
83734: PPUSH
83735: PPUSH
83736: PPUSH
83737: PPUSH
83738: PPUSH
83739: PPUSH
83740: PPUSH
83741: PPUSH
// result := false ;
83742: LD_ADDR_VAR 0 6
83746: PUSH
83747: LD_INT 0
83749: ST_TO_ADDR
// if btype = b_depot then
83750: LD_VAR 0 2
83754: PUSH
83755: LD_INT 0
83757: EQUAL
83758: IFFALSE 83770
// begin result := true ;
83760: LD_ADDR_VAR 0 6
83764: PUSH
83765: LD_INT 1
83767: ST_TO_ADDR
// exit ;
83768: GO 84596
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
83770: LD_VAR 0 1
83774: NOT
83775: PUSH
83776: LD_VAR 0 1
83780: PPUSH
83781: CALL_OW 266
83785: PUSH
83786: LD_INT 0
83788: PUSH
83789: LD_INT 1
83791: PUSH
83792: EMPTY
83793: LIST
83794: LIST
83795: IN
83796: NOT
83797: OR
83798: PUSH
83799: LD_VAR 0 2
83803: NOT
83804: OR
83805: PUSH
83806: LD_VAR 0 5
83810: PUSH
83811: LD_INT 0
83813: PUSH
83814: LD_INT 1
83816: PUSH
83817: LD_INT 2
83819: PUSH
83820: LD_INT 3
83822: PUSH
83823: LD_INT 4
83825: PUSH
83826: LD_INT 5
83828: PUSH
83829: EMPTY
83830: LIST
83831: LIST
83832: LIST
83833: LIST
83834: LIST
83835: LIST
83836: IN
83837: NOT
83838: OR
83839: PUSH
83840: LD_VAR 0 3
83844: PPUSH
83845: LD_VAR 0 4
83849: PPUSH
83850: CALL_OW 488
83854: NOT
83855: OR
83856: IFFALSE 83860
// exit ;
83858: GO 84596
// side := GetSide ( depot ) ;
83860: LD_ADDR_VAR 0 9
83864: PUSH
83865: LD_VAR 0 1
83869: PPUSH
83870: CALL_OW 255
83874: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
83875: LD_VAR 0 9
83879: PPUSH
83880: LD_VAR 0 2
83884: PPUSH
83885: CALL 83353 0 2
83889: NOT
83890: IFFALSE 83894
// exit ;
83892: GO 84596
// pom := GetBase ( depot ) ;
83894: LD_ADDR_VAR 0 10
83898: PUSH
83899: LD_VAR 0 1
83903: PPUSH
83904: CALL_OW 274
83908: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
83909: LD_ADDR_VAR 0 11
83913: PUSH
83914: LD_VAR 0 2
83918: PPUSH
83919: LD_VAR 0 1
83923: PPUSH
83924: CALL_OW 248
83928: PPUSH
83929: CALL_OW 450
83933: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
83934: LD_VAR 0 10
83938: PPUSH
83939: LD_INT 1
83941: PPUSH
83942: CALL_OW 275
83946: PUSH
83947: LD_VAR 0 11
83951: PUSH
83952: LD_INT 1
83954: ARRAY
83955: GREATEREQUAL
83956: PUSH
83957: LD_VAR 0 10
83961: PPUSH
83962: LD_INT 2
83964: PPUSH
83965: CALL_OW 275
83969: PUSH
83970: LD_VAR 0 11
83974: PUSH
83975: LD_INT 2
83977: ARRAY
83978: GREATEREQUAL
83979: AND
83980: PUSH
83981: LD_VAR 0 10
83985: PPUSH
83986: LD_INT 3
83988: PPUSH
83989: CALL_OW 275
83993: PUSH
83994: LD_VAR 0 11
83998: PUSH
83999: LD_INT 3
84001: ARRAY
84002: GREATEREQUAL
84003: AND
84004: NOT
84005: IFFALSE 84009
// exit ;
84007: GO 84596
// if GetBType ( depot ) = b_depot then
84009: LD_VAR 0 1
84013: PPUSH
84014: CALL_OW 266
84018: PUSH
84019: LD_INT 0
84021: EQUAL
84022: IFFALSE 84034
// dist := 28 else
84024: LD_ADDR_VAR 0 14
84028: PUSH
84029: LD_INT 28
84031: ST_TO_ADDR
84032: GO 84042
// dist := 36 ;
84034: LD_ADDR_VAR 0 14
84038: PUSH
84039: LD_INT 36
84041: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
84042: LD_VAR 0 1
84046: PPUSH
84047: LD_VAR 0 3
84051: PPUSH
84052: LD_VAR 0 4
84056: PPUSH
84057: CALL_OW 297
84061: PUSH
84062: LD_VAR 0 14
84066: GREATER
84067: IFFALSE 84071
// exit ;
84069: GO 84596
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
84071: LD_ADDR_VAR 0 12
84075: PUSH
84076: LD_VAR 0 2
84080: PPUSH
84081: LD_VAR 0 3
84085: PPUSH
84086: LD_VAR 0 4
84090: PPUSH
84091: LD_VAR 0 5
84095: PPUSH
84096: LD_VAR 0 1
84100: PPUSH
84101: CALL_OW 248
84105: PPUSH
84106: LD_INT 0
84108: PPUSH
84109: CALL 84601 0 6
84113: ST_TO_ADDR
// if not hexes then
84114: LD_VAR 0 12
84118: NOT
84119: IFFALSE 84123
// exit ;
84121: GO 84596
// hex := GetHexInfo ( x , y ) ;
84123: LD_ADDR_VAR 0 15
84127: PUSH
84128: LD_VAR 0 3
84132: PPUSH
84133: LD_VAR 0 4
84137: PPUSH
84138: CALL_OW 546
84142: ST_TO_ADDR
// if hex [ 1 ] then
84143: LD_VAR 0 15
84147: PUSH
84148: LD_INT 1
84150: ARRAY
84151: IFFALSE 84155
// exit ;
84153: GO 84596
// height := hex [ 2 ] ;
84155: LD_ADDR_VAR 0 13
84159: PUSH
84160: LD_VAR 0 15
84164: PUSH
84165: LD_INT 2
84167: ARRAY
84168: ST_TO_ADDR
// for i = 1 to hexes do
84169: LD_ADDR_VAR 0 7
84173: PUSH
84174: DOUBLE
84175: LD_INT 1
84177: DEC
84178: ST_TO_ADDR
84179: LD_VAR 0 12
84183: PUSH
84184: FOR_TO
84185: IFFALSE 84515
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
84187: LD_VAR 0 12
84191: PUSH
84192: LD_VAR 0 7
84196: ARRAY
84197: PUSH
84198: LD_INT 1
84200: ARRAY
84201: PPUSH
84202: LD_VAR 0 12
84206: PUSH
84207: LD_VAR 0 7
84211: ARRAY
84212: PUSH
84213: LD_INT 2
84215: ARRAY
84216: PPUSH
84217: CALL_OW 488
84221: NOT
84222: PUSH
84223: LD_VAR 0 12
84227: PUSH
84228: LD_VAR 0 7
84232: ARRAY
84233: PUSH
84234: LD_INT 1
84236: ARRAY
84237: PPUSH
84238: LD_VAR 0 12
84242: PUSH
84243: LD_VAR 0 7
84247: ARRAY
84248: PUSH
84249: LD_INT 2
84251: ARRAY
84252: PPUSH
84253: CALL_OW 428
84257: PUSH
84258: LD_INT 0
84260: GREATER
84261: OR
84262: PUSH
84263: LD_VAR 0 12
84267: PUSH
84268: LD_VAR 0 7
84272: ARRAY
84273: PUSH
84274: LD_INT 1
84276: ARRAY
84277: PPUSH
84278: LD_VAR 0 12
84282: PUSH
84283: LD_VAR 0 7
84287: ARRAY
84288: PUSH
84289: LD_INT 2
84291: ARRAY
84292: PPUSH
84293: CALL_OW 351
84297: OR
84298: IFFALSE 84304
// exit ;
84300: POP
84301: POP
84302: GO 84596
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84304: LD_ADDR_VAR 0 8
84308: PUSH
84309: LD_VAR 0 12
84313: PUSH
84314: LD_VAR 0 7
84318: ARRAY
84319: PUSH
84320: LD_INT 1
84322: ARRAY
84323: PPUSH
84324: LD_VAR 0 12
84328: PUSH
84329: LD_VAR 0 7
84333: ARRAY
84334: PUSH
84335: LD_INT 2
84337: ARRAY
84338: PPUSH
84339: CALL_OW 546
84343: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
84344: LD_VAR 0 8
84348: PUSH
84349: LD_INT 1
84351: ARRAY
84352: PUSH
84353: LD_VAR 0 8
84357: PUSH
84358: LD_INT 2
84360: ARRAY
84361: PUSH
84362: LD_VAR 0 13
84366: PUSH
84367: LD_INT 2
84369: PLUS
84370: GREATER
84371: OR
84372: PUSH
84373: LD_VAR 0 8
84377: PUSH
84378: LD_INT 2
84380: ARRAY
84381: PUSH
84382: LD_VAR 0 13
84386: PUSH
84387: LD_INT 2
84389: MINUS
84390: LESS
84391: OR
84392: PUSH
84393: LD_VAR 0 8
84397: PUSH
84398: LD_INT 3
84400: ARRAY
84401: PUSH
84402: LD_INT 0
84404: PUSH
84405: LD_INT 8
84407: PUSH
84408: LD_INT 9
84410: PUSH
84411: LD_INT 10
84413: PUSH
84414: LD_INT 11
84416: PUSH
84417: LD_INT 12
84419: PUSH
84420: LD_INT 13
84422: PUSH
84423: LD_INT 16
84425: PUSH
84426: LD_INT 17
84428: PUSH
84429: LD_INT 18
84431: PUSH
84432: LD_INT 19
84434: PUSH
84435: LD_INT 20
84437: PUSH
84438: LD_INT 21
84440: PUSH
84441: EMPTY
84442: LIST
84443: LIST
84444: LIST
84445: LIST
84446: LIST
84447: LIST
84448: LIST
84449: LIST
84450: LIST
84451: LIST
84452: LIST
84453: LIST
84454: LIST
84455: IN
84456: NOT
84457: OR
84458: PUSH
84459: LD_VAR 0 8
84463: PUSH
84464: LD_INT 5
84466: ARRAY
84467: NOT
84468: OR
84469: PUSH
84470: LD_VAR 0 8
84474: PUSH
84475: LD_INT 6
84477: ARRAY
84478: PUSH
84479: LD_INT 1
84481: PUSH
84482: LD_INT 2
84484: PUSH
84485: LD_INT 7
84487: PUSH
84488: LD_INT 9
84490: PUSH
84491: LD_INT 10
84493: PUSH
84494: LD_INT 11
84496: PUSH
84497: EMPTY
84498: LIST
84499: LIST
84500: LIST
84501: LIST
84502: LIST
84503: LIST
84504: IN
84505: NOT
84506: OR
84507: IFFALSE 84513
// exit ;
84509: POP
84510: POP
84511: GO 84596
// end ;
84513: GO 84184
84515: POP
84516: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
84517: LD_VAR 0 9
84521: PPUSH
84522: LD_VAR 0 3
84526: PPUSH
84527: LD_VAR 0 4
84531: PPUSH
84532: LD_INT 20
84534: PPUSH
84535: CALL 76519 0 4
84539: PUSH
84540: LD_INT 4
84542: ARRAY
84543: IFFALSE 84547
// exit ;
84545: GO 84596
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
84547: LD_VAR 0 2
84551: PUSH
84552: LD_INT 29
84554: PUSH
84555: LD_INT 30
84557: PUSH
84558: EMPTY
84559: LIST
84560: LIST
84561: IN
84562: PUSH
84563: LD_VAR 0 3
84567: PPUSH
84568: LD_VAR 0 4
84572: PPUSH
84573: LD_VAR 0 9
84577: PPUSH
84578: CALL_OW 440
84582: NOT
84583: AND
84584: IFFALSE 84588
// exit ;
84586: GO 84596
// result := true ;
84588: LD_ADDR_VAR 0 6
84592: PUSH
84593: LD_INT 1
84595: ST_TO_ADDR
// end ;
84596: LD_VAR 0 6
84600: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
84601: LD_INT 0
84603: PPUSH
84604: PPUSH
84605: PPUSH
84606: PPUSH
84607: PPUSH
84608: PPUSH
84609: PPUSH
84610: PPUSH
84611: PPUSH
84612: PPUSH
84613: PPUSH
84614: PPUSH
84615: PPUSH
84616: PPUSH
84617: PPUSH
84618: PPUSH
84619: PPUSH
84620: PPUSH
84621: PPUSH
84622: PPUSH
84623: PPUSH
84624: PPUSH
84625: PPUSH
84626: PPUSH
84627: PPUSH
84628: PPUSH
84629: PPUSH
84630: PPUSH
84631: PPUSH
84632: PPUSH
84633: PPUSH
84634: PPUSH
84635: PPUSH
84636: PPUSH
84637: PPUSH
84638: PPUSH
84639: PPUSH
84640: PPUSH
84641: PPUSH
84642: PPUSH
84643: PPUSH
84644: PPUSH
84645: PPUSH
84646: PPUSH
84647: PPUSH
84648: PPUSH
84649: PPUSH
84650: PPUSH
84651: PPUSH
84652: PPUSH
84653: PPUSH
84654: PPUSH
84655: PPUSH
84656: PPUSH
84657: PPUSH
84658: PPUSH
84659: PPUSH
84660: PPUSH
// result = [ ] ;
84661: LD_ADDR_VAR 0 7
84665: PUSH
84666: EMPTY
84667: ST_TO_ADDR
// temp_list = [ ] ;
84668: LD_ADDR_VAR 0 9
84672: PUSH
84673: EMPTY
84674: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
84675: LD_VAR 0 4
84679: PUSH
84680: LD_INT 0
84682: PUSH
84683: LD_INT 1
84685: PUSH
84686: LD_INT 2
84688: PUSH
84689: LD_INT 3
84691: PUSH
84692: LD_INT 4
84694: PUSH
84695: LD_INT 5
84697: PUSH
84698: EMPTY
84699: LIST
84700: LIST
84701: LIST
84702: LIST
84703: LIST
84704: LIST
84705: IN
84706: NOT
84707: PUSH
84708: LD_VAR 0 1
84712: PUSH
84713: LD_INT 0
84715: PUSH
84716: LD_INT 1
84718: PUSH
84719: EMPTY
84720: LIST
84721: LIST
84722: IN
84723: PUSH
84724: LD_VAR 0 5
84728: PUSH
84729: LD_INT 1
84731: PUSH
84732: LD_INT 2
84734: PUSH
84735: LD_INT 3
84737: PUSH
84738: EMPTY
84739: LIST
84740: LIST
84741: LIST
84742: IN
84743: NOT
84744: AND
84745: OR
84746: IFFALSE 84750
// exit ;
84748: GO 103141
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
84750: LD_VAR 0 1
84754: PUSH
84755: LD_INT 6
84757: PUSH
84758: LD_INT 7
84760: PUSH
84761: LD_INT 8
84763: PUSH
84764: LD_INT 13
84766: PUSH
84767: LD_INT 12
84769: PUSH
84770: LD_INT 15
84772: PUSH
84773: LD_INT 11
84775: PUSH
84776: LD_INT 14
84778: PUSH
84779: LD_INT 10
84781: PUSH
84782: EMPTY
84783: LIST
84784: LIST
84785: LIST
84786: LIST
84787: LIST
84788: LIST
84789: LIST
84790: LIST
84791: LIST
84792: IN
84793: IFFALSE 84803
// btype = b_lab ;
84795: LD_ADDR_VAR 0 1
84799: PUSH
84800: LD_INT 6
84802: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
84803: LD_VAR 0 6
84807: PUSH
84808: LD_INT 0
84810: PUSH
84811: LD_INT 1
84813: PUSH
84814: LD_INT 2
84816: PUSH
84817: EMPTY
84818: LIST
84819: LIST
84820: LIST
84821: IN
84822: NOT
84823: PUSH
84824: LD_VAR 0 1
84828: PUSH
84829: LD_INT 0
84831: PUSH
84832: LD_INT 1
84834: PUSH
84835: LD_INT 2
84837: PUSH
84838: LD_INT 3
84840: PUSH
84841: LD_INT 6
84843: PUSH
84844: LD_INT 36
84846: PUSH
84847: LD_INT 4
84849: PUSH
84850: LD_INT 5
84852: PUSH
84853: LD_INT 31
84855: PUSH
84856: LD_INT 32
84858: PUSH
84859: LD_INT 33
84861: PUSH
84862: EMPTY
84863: LIST
84864: LIST
84865: LIST
84866: LIST
84867: LIST
84868: LIST
84869: LIST
84870: LIST
84871: LIST
84872: LIST
84873: LIST
84874: IN
84875: NOT
84876: PUSH
84877: LD_VAR 0 6
84881: PUSH
84882: LD_INT 1
84884: EQUAL
84885: AND
84886: OR
84887: PUSH
84888: LD_VAR 0 1
84892: PUSH
84893: LD_INT 2
84895: PUSH
84896: LD_INT 3
84898: PUSH
84899: EMPTY
84900: LIST
84901: LIST
84902: IN
84903: NOT
84904: PUSH
84905: LD_VAR 0 6
84909: PUSH
84910: LD_INT 2
84912: EQUAL
84913: AND
84914: OR
84915: IFFALSE 84925
// mode = 0 ;
84917: LD_ADDR_VAR 0 6
84921: PUSH
84922: LD_INT 0
84924: ST_TO_ADDR
// case mode of 0 :
84925: LD_VAR 0 6
84929: PUSH
84930: LD_INT 0
84932: DOUBLE
84933: EQUAL
84934: IFTRUE 84938
84936: GO 96391
84938: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
84939: LD_ADDR_VAR 0 11
84943: PUSH
84944: LD_INT 0
84946: PUSH
84947: LD_INT 0
84949: PUSH
84950: EMPTY
84951: LIST
84952: LIST
84953: PUSH
84954: LD_INT 0
84956: PUSH
84957: LD_INT 1
84959: NEG
84960: PUSH
84961: EMPTY
84962: LIST
84963: LIST
84964: PUSH
84965: LD_INT 1
84967: PUSH
84968: LD_INT 0
84970: PUSH
84971: EMPTY
84972: LIST
84973: LIST
84974: PUSH
84975: LD_INT 1
84977: PUSH
84978: LD_INT 1
84980: PUSH
84981: EMPTY
84982: LIST
84983: LIST
84984: PUSH
84985: LD_INT 0
84987: PUSH
84988: LD_INT 1
84990: PUSH
84991: EMPTY
84992: LIST
84993: LIST
84994: PUSH
84995: LD_INT 1
84997: NEG
84998: PUSH
84999: LD_INT 0
85001: PUSH
85002: EMPTY
85003: LIST
85004: LIST
85005: PUSH
85006: LD_INT 1
85008: NEG
85009: PUSH
85010: LD_INT 1
85012: NEG
85013: PUSH
85014: EMPTY
85015: LIST
85016: LIST
85017: PUSH
85018: LD_INT 1
85020: NEG
85021: PUSH
85022: LD_INT 2
85024: NEG
85025: PUSH
85026: EMPTY
85027: LIST
85028: LIST
85029: PUSH
85030: LD_INT 0
85032: PUSH
85033: LD_INT 2
85035: NEG
85036: PUSH
85037: EMPTY
85038: LIST
85039: LIST
85040: PUSH
85041: LD_INT 1
85043: PUSH
85044: LD_INT 1
85046: NEG
85047: PUSH
85048: EMPTY
85049: LIST
85050: LIST
85051: PUSH
85052: LD_INT 1
85054: PUSH
85055: LD_INT 2
85057: PUSH
85058: EMPTY
85059: LIST
85060: LIST
85061: PUSH
85062: LD_INT 0
85064: PUSH
85065: LD_INT 2
85067: PUSH
85068: EMPTY
85069: LIST
85070: LIST
85071: PUSH
85072: LD_INT 1
85074: NEG
85075: PUSH
85076: LD_INT 1
85078: PUSH
85079: EMPTY
85080: LIST
85081: LIST
85082: PUSH
85083: LD_INT 1
85085: PUSH
85086: LD_INT 3
85088: PUSH
85089: EMPTY
85090: LIST
85091: LIST
85092: PUSH
85093: LD_INT 0
85095: PUSH
85096: LD_INT 3
85098: PUSH
85099: EMPTY
85100: LIST
85101: LIST
85102: PUSH
85103: LD_INT 1
85105: NEG
85106: PUSH
85107: LD_INT 2
85109: PUSH
85110: EMPTY
85111: LIST
85112: LIST
85113: PUSH
85114: EMPTY
85115: LIST
85116: LIST
85117: LIST
85118: LIST
85119: LIST
85120: LIST
85121: LIST
85122: LIST
85123: LIST
85124: LIST
85125: LIST
85126: LIST
85127: LIST
85128: LIST
85129: LIST
85130: LIST
85131: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85132: LD_ADDR_VAR 0 12
85136: PUSH
85137: LD_INT 0
85139: PUSH
85140: LD_INT 0
85142: PUSH
85143: EMPTY
85144: LIST
85145: LIST
85146: PUSH
85147: LD_INT 0
85149: PUSH
85150: LD_INT 1
85152: NEG
85153: PUSH
85154: EMPTY
85155: LIST
85156: LIST
85157: PUSH
85158: LD_INT 1
85160: PUSH
85161: LD_INT 0
85163: PUSH
85164: EMPTY
85165: LIST
85166: LIST
85167: PUSH
85168: LD_INT 1
85170: PUSH
85171: LD_INT 1
85173: PUSH
85174: EMPTY
85175: LIST
85176: LIST
85177: PUSH
85178: LD_INT 0
85180: PUSH
85181: LD_INT 1
85183: PUSH
85184: EMPTY
85185: LIST
85186: LIST
85187: PUSH
85188: LD_INT 1
85190: NEG
85191: PUSH
85192: LD_INT 0
85194: PUSH
85195: EMPTY
85196: LIST
85197: LIST
85198: PUSH
85199: LD_INT 1
85201: NEG
85202: PUSH
85203: LD_INT 1
85205: NEG
85206: PUSH
85207: EMPTY
85208: LIST
85209: LIST
85210: PUSH
85211: LD_INT 1
85213: PUSH
85214: LD_INT 1
85216: NEG
85217: PUSH
85218: EMPTY
85219: LIST
85220: LIST
85221: PUSH
85222: LD_INT 2
85224: PUSH
85225: LD_INT 0
85227: PUSH
85228: EMPTY
85229: LIST
85230: LIST
85231: PUSH
85232: LD_INT 2
85234: PUSH
85235: LD_INT 1
85237: PUSH
85238: EMPTY
85239: LIST
85240: LIST
85241: PUSH
85242: LD_INT 1
85244: NEG
85245: PUSH
85246: LD_INT 1
85248: PUSH
85249: EMPTY
85250: LIST
85251: LIST
85252: PUSH
85253: LD_INT 2
85255: NEG
85256: PUSH
85257: LD_INT 0
85259: PUSH
85260: EMPTY
85261: LIST
85262: LIST
85263: PUSH
85264: LD_INT 2
85266: NEG
85267: PUSH
85268: LD_INT 1
85270: NEG
85271: PUSH
85272: EMPTY
85273: LIST
85274: LIST
85275: PUSH
85276: LD_INT 2
85278: NEG
85279: PUSH
85280: LD_INT 1
85282: PUSH
85283: EMPTY
85284: LIST
85285: LIST
85286: PUSH
85287: LD_INT 3
85289: NEG
85290: PUSH
85291: LD_INT 0
85293: PUSH
85294: EMPTY
85295: LIST
85296: LIST
85297: PUSH
85298: LD_INT 3
85300: NEG
85301: PUSH
85302: LD_INT 1
85304: NEG
85305: PUSH
85306: EMPTY
85307: LIST
85308: LIST
85309: PUSH
85310: EMPTY
85311: LIST
85312: LIST
85313: LIST
85314: LIST
85315: LIST
85316: LIST
85317: LIST
85318: LIST
85319: LIST
85320: LIST
85321: LIST
85322: LIST
85323: LIST
85324: LIST
85325: LIST
85326: LIST
85327: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85328: LD_ADDR_VAR 0 13
85332: PUSH
85333: LD_INT 0
85335: PUSH
85336: LD_INT 0
85338: PUSH
85339: EMPTY
85340: LIST
85341: LIST
85342: PUSH
85343: LD_INT 0
85345: PUSH
85346: LD_INT 1
85348: NEG
85349: PUSH
85350: EMPTY
85351: LIST
85352: LIST
85353: PUSH
85354: LD_INT 1
85356: PUSH
85357: LD_INT 0
85359: PUSH
85360: EMPTY
85361: LIST
85362: LIST
85363: PUSH
85364: LD_INT 1
85366: PUSH
85367: LD_INT 1
85369: PUSH
85370: EMPTY
85371: LIST
85372: LIST
85373: PUSH
85374: LD_INT 0
85376: PUSH
85377: LD_INT 1
85379: PUSH
85380: EMPTY
85381: LIST
85382: LIST
85383: PUSH
85384: LD_INT 1
85386: NEG
85387: PUSH
85388: LD_INT 0
85390: PUSH
85391: EMPTY
85392: LIST
85393: LIST
85394: PUSH
85395: LD_INT 1
85397: NEG
85398: PUSH
85399: LD_INT 1
85401: NEG
85402: PUSH
85403: EMPTY
85404: LIST
85405: LIST
85406: PUSH
85407: LD_INT 1
85409: NEG
85410: PUSH
85411: LD_INT 2
85413: NEG
85414: PUSH
85415: EMPTY
85416: LIST
85417: LIST
85418: PUSH
85419: LD_INT 2
85421: PUSH
85422: LD_INT 1
85424: PUSH
85425: EMPTY
85426: LIST
85427: LIST
85428: PUSH
85429: LD_INT 2
85431: PUSH
85432: LD_INT 2
85434: PUSH
85435: EMPTY
85436: LIST
85437: LIST
85438: PUSH
85439: LD_INT 1
85441: PUSH
85442: LD_INT 2
85444: PUSH
85445: EMPTY
85446: LIST
85447: LIST
85448: PUSH
85449: LD_INT 2
85451: NEG
85452: PUSH
85453: LD_INT 1
85455: NEG
85456: PUSH
85457: EMPTY
85458: LIST
85459: LIST
85460: PUSH
85461: LD_INT 2
85463: NEG
85464: PUSH
85465: LD_INT 2
85467: NEG
85468: PUSH
85469: EMPTY
85470: LIST
85471: LIST
85472: PUSH
85473: LD_INT 2
85475: NEG
85476: PUSH
85477: LD_INT 3
85479: NEG
85480: PUSH
85481: EMPTY
85482: LIST
85483: LIST
85484: PUSH
85485: LD_INT 3
85487: NEG
85488: PUSH
85489: LD_INT 2
85491: NEG
85492: PUSH
85493: EMPTY
85494: LIST
85495: LIST
85496: PUSH
85497: LD_INT 3
85499: NEG
85500: PUSH
85501: LD_INT 3
85503: NEG
85504: PUSH
85505: EMPTY
85506: LIST
85507: LIST
85508: PUSH
85509: EMPTY
85510: LIST
85511: LIST
85512: LIST
85513: LIST
85514: LIST
85515: LIST
85516: LIST
85517: LIST
85518: LIST
85519: LIST
85520: LIST
85521: LIST
85522: LIST
85523: LIST
85524: LIST
85525: LIST
85526: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
85527: LD_ADDR_VAR 0 14
85531: PUSH
85532: LD_INT 0
85534: PUSH
85535: LD_INT 0
85537: PUSH
85538: EMPTY
85539: LIST
85540: LIST
85541: PUSH
85542: LD_INT 0
85544: PUSH
85545: LD_INT 1
85547: NEG
85548: PUSH
85549: EMPTY
85550: LIST
85551: LIST
85552: PUSH
85553: LD_INT 1
85555: PUSH
85556: LD_INT 0
85558: PUSH
85559: EMPTY
85560: LIST
85561: LIST
85562: PUSH
85563: LD_INT 1
85565: PUSH
85566: LD_INT 1
85568: PUSH
85569: EMPTY
85570: LIST
85571: LIST
85572: PUSH
85573: LD_INT 0
85575: PUSH
85576: LD_INT 1
85578: PUSH
85579: EMPTY
85580: LIST
85581: LIST
85582: PUSH
85583: LD_INT 1
85585: NEG
85586: PUSH
85587: LD_INT 0
85589: PUSH
85590: EMPTY
85591: LIST
85592: LIST
85593: PUSH
85594: LD_INT 1
85596: NEG
85597: PUSH
85598: LD_INT 1
85600: NEG
85601: PUSH
85602: EMPTY
85603: LIST
85604: LIST
85605: PUSH
85606: LD_INT 1
85608: NEG
85609: PUSH
85610: LD_INT 2
85612: NEG
85613: PUSH
85614: EMPTY
85615: LIST
85616: LIST
85617: PUSH
85618: LD_INT 0
85620: PUSH
85621: LD_INT 2
85623: NEG
85624: PUSH
85625: EMPTY
85626: LIST
85627: LIST
85628: PUSH
85629: LD_INT 1
85631: PUSH
85632: LD_INT 1
85634: NEG
85635: PUSH
85636: EMPTY
85637: LIST
85638: LIST
85639: PUSH
85640: LD_INT 1
85642: PUSH
85643: LD_INT 2
85645: PUSH
85646: EMPTY
85647: LIST
85648: LIST
85649: PUSH
85650: LD_INT 0
85652: PUSH
85653: LD_INT 2
85655: PUSH
85656: EMPTY
85657: LIST
85658: LIST
85659: PUSH
85660: LD_INT 1
85662: NEG
85663: PUSH
85664: LD_INT 1
85666: PUSH
85667: EMPTY
85668: LIST
85669: LIST
85670: PUSH
85671: LD_INT 1
85673: NEG
85674: PUSH
85675: LD_INT 3
85677: NEG
85678: PUSH
85679: EMPTY
85680: LIST
85681: LIST
85682: PUSH
85683: LD_INT 0
85685: PUSH
85686: LD_INT 3
85688: NEG
85689: PUSH
85690: EMPTY
85691: LIST
85692: LIST
85693: PUSH
85694: LD_INT 1
85696: PUSH
85697: LD_INT 2
85699: NEG
85700: PUSH
85701: EMPTY
85702: LIST
85703: LIST
85704: PUSH
85705: EMPTY
85706: LIST
85707: LIST
85708: LIST
85709: LIST
85710: LIST
85711: LIST
85712: LIST
85713: LIST
85714: LIST
85715: LIST
85716: LIST
85717: LIST
85718: LIST
85719: LIST
85720: LIST
85721: LIST
85722: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
85723: LD_ADDR_VAR 0 15
85727: PUSH
85728: LD_INT 0
85730: PUSH
85731: LD_INT 0
85733: PUSH
85734: EMPTY
85735: LIST
85736: LIST
85737: PUSH
85738: LD_INT 0
85740: PUSH
85741: LD_INT 1
85743: NEG
85744: PUSH
85745: EMPTY
85746: LIST
85747: LIST
85748: PUSH
85749: LD_INT 1
85751: PUSH
85752: LD_INT 0
85754: PUSH
85755: EMPTY
85756: LIST
85757: LIST
85758: PUSH
85759: LD_INT 1
85761: PUSH
85762: LD_INT 1
85764: PUSH
85765: EMPTY
85766: LIST
85767: LIST
85768: PUSH
85769: LD_INT 0
85771: PUSH
85772: LD_INT 1
85774: PUSH
85775: EMPTY
85776: LIST
85777: LIST
85778: PUSH
85779: LD_INT 1
85781: NEG
85782: PUSH
85783: LD_INT 0
85785: PUSH
85786: EMPTY
85787: LIST
85788: LIST
85789: PUSH
85790: LD_INT 1
85792: NEG
85793: PUSH
85794: LD_INT 1
85796: NEG
85797: PUSH
85798: EMPTY
85799: LIST
85800: LIST
85801: PUSH
85802: LD_INT 1
85804: PUSH
85805: LD_INT 1
85807: NEG
85808: PUSH
85809: EMPTY
85810: LIST
85811: LIST
85812: PUSH
85813: LD_INT 2
85815: PUSH
85816: LD_INT 0
85818: PUSH
85819: EMPTY
85820: LIST
85821: LIST
85822: PUSH
85823: LD_INT 2
85825: PUSH
85826: LD_INT 1
85828: PUSH
85829: EMPTY
85830: LIST
85831: LIST
85832: PUSH
85833: LD_INT 1
85835: NEG
85836: PUSH
85837: LD_INT 1
85839: PUSH
85840: EMPTY
85841: LIST
85842: LIST
85843: PUSH
85844: LD_INT 2
85846: NEG
85847: PUSH
85848: LD_INT 0
85850: PUSH
85851: EMPTY
85852: LIST
85853: LIST
85854: PUSH
85855: LD_INT 2
85857: NEG
85858: PUSH
85859: LD_INT 1
85861: NEG
85862: PUSH
85863: EMPTY
85864: LIST
85865: LIST
85866: PUSH
85867: LD_INT 2
85869: PUSH
85870: LD_INT 1
85872: NEG
85873: PUSH
85874: EMPTY
85875: LIST
85876: LIST
85877: PUSH
85878: LD_INT 3
85880: PUSH
85881: LD_INT 0
85883: PUSH
85884: EMPTY
85885: LIST
85886: LIST
85887: PUSH
85888: LD_INT 3
85890: PUSH
85891: LD_INT 1
85893: PUSH
85894: EMPTY
85895: LIST
85896: LIST
85897: PUSH
85898: EMPTY
85899: LIST
85900: LIST
85901: LIST
85902: LIST
85903: LIST
85904: LIST
85905: LIST
85906: LIST
85907: LIST
85908: LIST
85909: LIST
85910: LIST
85911: LIST
85912: LIST
85913: LIST
85914: LIST
85915: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
85916: LD_ADDR_VAR 0 16
85920: PUSH
85921: LD_INT 0
85923: PUSH
85924: LD_INT 0
85926: PUSH
85927: EMPTY
85928: LIST
85929: LIST
85930: PUSH
85931: LD_INT 0
85933: PUSH
85934: LD_INT 1
85936: NEG
85937: PUSH
85938: EMPTY
85939: LIST
85940: LIST
85941: PUSH
85942: LD_INT 1
85944: PUSH
85945: LD_INT 0
85947: PUSH
85948: EMPTY
85949: LIST
85950: LIST
85951: PUSH
85952: LD_INT 1
85954: PUSH
85955: LD_INT 1
85957: PUSH
85958: EMPTY
85959: LIST
85960: LIST
85961: PUSH
85962: LD_INT 0
85964: PUSH
85965: LD_INT 1
85967: PUSH
85968: EMPTY
85969: LIST
85970: LIST
85971: PUSH
85972: LD_INT 1
85974: NEG
85975: PUSH
85976: LD_INT 0
85978: PUSH
85979: EMPTY
85980: LIST
85981: LIST
85982: PUSH
85983: LD_INT 1
85985: NEG
85986: PUSH
85987: LD_INT 1
85989: NEG
85990: PUSH
85991: EMPTY
85992: LIST
85993: LIST
85994: PUSH
85995: LD_INT 1
85997: NEG
85998: PUSH
85999: LD_INT 2
86001: NEG
86002: PUSH
86003: EMPTY
86004: LIST
86005: LIST
86006: PUSH
86007: LD_INT 2
86009: PUSH
86010: LD_INT 1
86012: PUSH
86013: EMPTY
86014: LIST
86015: LIST
86016: PUSH
86017: LD_INT 2
86019: PUSH
86020: LD_INT 2
86022: PUSH
86023: EMPTY
86024: LIST
86025: LIST
86026: PUSH
86027: LD_INT 1
86029: PUSH
86030: LD_INT 2
86032: PUSH
86033: EMPTY
86034: LIST
86035: LIST
86036: PUSH
86037: LD_INT 2
86039: NEG
86040: PUSH
86041: LD_INT 1
86043: NEG
86044: PUSH
86045: EMPTY
86046: LIST
86047: LIST
86048: PUSH
86049: LD_INT 2
86051: NEG
86052: PUSH
86053: LD_INT 2
86055: NEG
86056: PUSH
86057: EMPTY
86058: LIST
86059: LIST
86060: PUSH
86061: LD_INT 3
86063: PUSH
86064: LD_INT 2
86066: PUSH
86067: EMPTY
86068: LIST
86069: LIST
86070: PUSH
86071: LD_INT 3
86073: PUSH
86074: LD_INT 3
86076: PUSH
86077: EMPTY
86078: LIST
86079: LIST
86080: PUSH
86081: LD_INT 2
86083: PUSH
86084: LD_INT 3
86086: PUSH
86087: EMPTY
86088: LIST
86089: LIST
86090: PUSH
86091: EMPTY
86092: LIST
86093: LIST
86094: LIST
86095: LIST
86096: LIST
86097: LIST
86098: LIST
86099: LIST
86100: LIST
86101: LIST
86102: LIST
86103: LIST
86104: LIST
86105: LIST
86106: LIST
86107: LIST
86108: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86109: LD_ADDR_VAR 0 17
86113: PUSH
86114: LD_INT 0
86116: PUSH
86117: LD_INT 0
86119: PUSH
86120: EMPTY
86121: LIST
86122: LIST
86123: PUSH
86124: LD_INT 0
86126: PUSH
86127: LD_INT 1
86129: NEG
86130: PUSH
86131: EMPTY
86132: LIST
86133: LIST
86134: PUSH
86135: LD_INT 1
86137: PUSH
86138: LD_INT 0
86140: PUSH
86141: EMPTY
86142: LIST
86143: LIST
86144: PUSH
86145: LD_INT 1
86147: PUSH
86148: LD_INT 1
86150: PUSH
86151: EMPTY
86152: LIST
86153: LIST
86154: PUSH
86155: LD_INT 0
86157: PUSH
86158: LD_INT 1
86160: PUSH
86161: EMPTY
86162: LIST
86163: LIST
86164: PUSH
86165: LD_INT 1
86167: NEG
86168: PUSH
86169: LD_INT 0
86171: PUSH
86172: EMPTY
86173: LIST
86174: LIST
86175: PUSH
86176: LD_INT 1
86178: NEG
86179: PUSH
86180: LD_INT 1
86182: NEG
86183: PUSH
86184: EMPTY
86185: LIST
86186: LIST
86187: PUSH
86188: LD_INT 1
86190: NEG
86191: PUSH
86192: LD_INT 2
86194: NEG
86195: PUSH
86196: EMPTY
86197: LIST
86198: LIST
86199: PUSH
86200: LD_INT 0
86202: PUSH
86203: LD_INT 2
86205: NEG
86206: PUSH
86207: EMPTY
86208: LIST
86209: LIST
86210: PUSH
86211: LD_INT 1
86213: PUSH
86214: LD_INT 1
86216: NEG
86217: PUSH
86218: EMPTY
86219: LIST
86220: LIST
86221: PUSH
86222: LD_INT 2
86224: PUSH
86225: LD_INT 0
86227: PUSH
86228: EMPTY
86229: LIST
86230: LIST
86231: PUSH
86232: LD_INT 2
86234: PUSH
86235: LD_INT 1
86237: PUSH
86238: EMPTY
86239: LIST
86240: LIST
86241: PUSH
86242: LD_INT 2
86244: PUSH
86245: LD_INT 2
86247: PUSH
86248: EMPTY
86249: LIST
86250: LIST
86251: PUSH
86252: LD_INT 1
86254: PUSH
86255: LD_INT 2
86257: PUSH
86258: EMPTY
86259: LIST
86260: LIST
86261: PUSH
86262: LD_INT 0
86264: PUSH
86265: LD_INT 2
86267: PUSH
86268: EMPTY
86269: LIST
86270: LIST
86271: PUSH
86272: LD_INT 1
86274: NEG
86275: PUSH
86276: LD_INT 1
86278: PUSH
86279: EMPTY
86280: LIST
86281: LIST
86282: PUSH
86283: LD_INT 2
86285: NEG
86286: PUSH
86287: LD_INT 0
86289: PUSH
86290: EMPTY
86291: LIST
86292: LIST
86293: PUSH
86294: LD_INT 2
86296: NEG
86297: PUSH
86298: LD_INT 1
86300: NEG
86301: PUSH
86302: EMPTY
86303: LIST
86304: LIST
86305: PUSH
86306: LD_INT 2
86308: NEG
86309: PUSH
86310: LD_INT 2
86312: NEG
86313: PUSH
86314: EMPTY
86315: LIST
86316: LIST
86317: PUSH
86318: EMPTY
86319: LIST
86320: LIST
86321: LIST
86322: LIST
86323: LIST
86324: LIST
86325: LIST
86326: LIST
86327: LIST
86328: LIST
86329: LIST
86330: LIST
86331: LIST
86332: LIST
86333: LIST
86334: LIST
86335: LIST
86336: LIST
86337: LIST
86338: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86339: LD_ADDR_VAR 0 18
86343: PUSH
86344: LD_INT 0
86346: PUSH
86347: LD_INT 0
86349: PUSH
86350: EMPTY
86351: LIST
86352: LIST
86353: PUSH
86354: LD_INT 0
86356: PUSH
86357: LD_INT 1
86359: NEG
86360: PUSH
86361: EMPTY
86362: LIST
86363: LIST
86364: PUSH
86365: LD_INT 1
86367: PUSH
86368: LD_INT 0
86370: PUSH
86371: EMPTY
86372: LIST
86373: LIST
86374: PUSH
86375: LD_INT 1
86377: PUSH
86378: LD_INT 1
86380: PUSH
86381: EMPTY
86382: LIST
86383: LIST
86384: PUSH
86385: LD_INT 0
86387: PUSH
86388: LD_INT 1
86390: PUSH
86391: EMPTY
86392: LIST
86393: LIST
86394: PUSH
86395: LD_INT 1
86397: NEG
86398: PUSH
86399: LD_INT 0
86401: PUSH
86402: EMPTY
86403: LIST
86404: LIST
86405: PUSH
86406: LD_INT 1
86408: NEG
86409: PUSH
86410: LD_INT 1
86412: NEG
86413: PUSH
86414: EMPTY
86415: LIST
86416: LIST
86417: PUSH
86418: LD_INT 1
86420: NEG
86421: PUSH
86422: LD_INT 2
86424: NEG
86425: PUSH
86426: EMPTY
86427: LIST
86428: LIST
86429: PUSH
86430: LD_INT 0
86432: PUSH
86433: LD_INT 2
86435: NEG
86436: PUSH
86437: EMPTY
86438: LIST
86439: LIST
86440: PUSH
86441: LD_INT 1
86443: PUSH
86444: LD_INT 1
86446: NEG
86447: PUSH
86448: EMPTY
86449: LIST
86450: LIST
86451: PUSH
86452: LD_INT 2
86454: PUSH
86455: LD_INT 0
86457: PUSH
86458: EMPTY
86459: LIST
86460: LIST
86461: PUSH
86462: LD_INT 2
86464: PUSH
86465: LD_INT 1
86467: PUSH
86468: EMPTY
86469: LIST
86470: LIST
86471: PUSH
86472: LD_INT 2
86474: PUSH
86475: LD_INT 2
86477: PUSH
86478: EMPTY
86479: LIST
86480: LIST
86481: PUSH
86482: LD_INT 1
86484: PUSH
86485: LD_INT 2
86487: PUSH
86488: EMPTY
86489: LIST
86490: LIST
86491: PUSH
86492: LD_INT 0
86494: PUSH
86495: LD_INT 2
86497: PUSH
86498: EMPTY
86499: LIST
86500: LIST
86501: PUSH
86502: LD_INT 1
86504: NEG
86505: PUSH
86506: LD_INT 1
86508: PUSH
86509: EMPTY
86510: LIST
86511: LIST
86512: PUSH
86513: LD_INT 2
86515: NEG
86516: PUSH
86517: LD_INT 0
86519: PUSH
86520: EMPTY
86521: LIST
86522: LIST
86523: PUSH
86524: LD_INT 2
86526: NEG
86527: PUSH
86528: LD_INT 1
86530: NEG
86531: PUSH
86532: EMPTY
86533: LIST
86534: LIST
86535: PUSH
86536: LD_INT 2
86538: NEG
86539: PUSH
86540: LD_INT 2
86542: NEG
86543: PUSH
86544: EMPTY
86545: LIST
86546: LIST
86547: PUSH
86548: EMPTY
86549: LIST
86550: LIST
86551: LIST
86552: LIST
86553: LIST
86554: LIST
86555: LIST
86556: LIST
86557: LIST
86558: LIST
86559: LIST
86560: LIST
86561: LIST
86562: LIST
86563: LIST
86564: LIST
86565: LIST
86566: LIST
86567: LIST
86568: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86569: LD_ADDR_VAR 0 19
86573: PUSH
86574: LD_INT 0
86576: PUSH
86577: LD_INT 0
86579: PUSH
86580: EMPTY
86581: LIST
86582: LIST
86583: PUSH
86584: LD_INT 0
86586: PUSH
86587: LD_INT 1
86589: NEG
86590: PUSH
86591: EMPTY
86592: LIST
86593: LIST
86594: PUSH
86595: LD_INT 1
86597: PUSH
86598: LD_INT 0
86600: PUSH
86601: EMPTY
86602: LIST
86603: LIST
86604: PUSH
86605: LD_INT 1
86607: PUSH
86608: LD_INT 1
86610: PUSH
86611: EMPTY
86612: LIST
86613: LIST
86614: PUSH
86615: LD_INT 0
86617: PUSH
86618: LD_INT 1
86620: PUSH
86621: EMPTY
86622: LIST
86623: LIST
86624: PUSH
86625: LD_INT 1
86627: NEG
86628: PUSH
86629: LD_INT 0
86631: PUSH
86632: EMPTY
86633: LIST
86634: LIST
86635: PUSH
86636: LD_INT 1
86638: NEG
86639: PUSH
86640: LD_INT 1
86642: NEG
86643: PUSH
86644: EMPTY
86645: LIST
86646: LIST
86647: PUSH
86648: LD_INT 1
86650: NEG
86651: PUSH
86652: LD_INT 2
86654: NEG
86655: PUSH
86656: EMPTY
86657: LIST
86658: LIST
86659: PUSH
86660: LD_INT 0
86662: PUSH
86663: LD_INT 2
86665: NEG
86666: PUSH
86667: EMPTY
86668: LIST
86669: LIST
86670: PUSH
86671: LD_INT 1
86673: PUSH
86674: LD_INT 1
86676: NEG
86677: PUSH
86678: EMPTY
86679: LIST
86680: LIST
86681: PUSH
86682: LD_INT 2
86684: PUSH
86685: LD_INT 0
86687: PUSH
86688: EMPTY
86689: LIST
86690: LIST
86691: PUSH
86692: LD_INT 2
86694: PUSH
86695: LD_INT 1
86697: PUSH
86698: EMPTY
86699: LIST
86700: LIST
86701: PUSH
86702: LD_INT 2
86704: PUSH
86705: LD_INT 2
86707: PUSH
86708: EMPTY
86709: LIST
86710: LIST
86711: PUSH
86712: LD_INT 1
86714: PUSH
86715: LD_INT 2
86717: PUSH
86718: EMPTY
86719: LIST
86720: LIST
86721: PUSH
86722: LD_INT 0
86724: PUSH
86725: LD_INT 2
86727: PUSH
86728: EMPTY
86729: LIST
86730: LIST
86731: PUSH
86732: LD_INT 1
86734: NEG
86735: PUSH
86736: LD_INT 1
86738: PUSH
86739: EMPTY
86740: LIST
86741: LIST
86742: PUSH
86743: LD_INT 2
86745: NEG
86746: PUSH
86747: LD_INT 0
86749: PUSH
86750: EMPTY
86751: LIST
86752: LIST
86753: PUSH
86754: LD_INT 2
86756: NEG
86757: PUSH
86758: LD_INT 1
86760: NEG
86761: PUSH
86762: EMPTY
86763: LIST
86764: LIST
86765: PUSH
86766: LD_INT 2
86768: NEG
86769: PUSH
86770: LD_INT 2
86772: NEG
86773: PUSH
86774: EMPTY
86775: LIST
86776: LIST
86777: PUSH
86778: EMPTY
86779: LIST
86780: LIST
86781: LIST
86782: LIST
86783: LIST
86784: LIST
86785: LIST
86786: LIST
86787: LIST
86788: LIST
86789: LIST
86790: LIST
86791: LIST
86792: LIST
86793: LIST
86794: LIST
86795: LIST
86796: LIST
86797: LIST
86798: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86799: LD_ADDR_VAR 0 20
86803: PUSH
86804: LD_INT 0
86806: PUSH
86807: LD_INT 0
86809: PUSH
86810: EMPTY
86811: LIST
86812: LIST
86813: PUSH
86814: LD_INT 0
86816: PUSH
86817: LD_INT 1
86819: NEG
86820: PUSH
86821: EMPTY
86822: LIST
86823: LIST
86824: PUSH
86825: LD_INT 1
86827: PUSH
86828: LD_INT 0
86830: PUSH
86831: EMPTY
86832: LIST
86833: LIST
86834: PUSH
86835: LD_INT 1
86837: PUSH
86838: LD_INT 1
86840: PUSH
86841: EMPTY
86842: LIST
86843: LIST
86844: PUSH
86845: LD_INT 0
86847: PUSH
86848: LD_INT 1
86850: PUSH
86851: EMPTY
86852: LIST
86853: LIST
86854: PUSH
86855: LD_INT 1
86857: NEG
86858: PUSH
86859: LD_INT 0
86861: PUSH
86862: EMPTY
86863: LIST
86864: LIST
86865: PUSH
86866: LD_INT 1
86868: NEG
86869: PUSH
86870: LD_INT 1
86872: NEG
86873: PUSH
86874: EMPTY
86875: LIST
86876: LIST
86877: PUSH
86878: LD_INT 1
86880: NEG
86881: PUSH
86882: LD_INT 2
86884: NEG
86885: PUSH
86886: EMPTY
86887: LIST
86888: LIST
86889: PUSH
86890: LD_INT 0
86892: PUSH
86893: LD_INT 2
86895: NEG
86896: PUSH
86897: EMPTY
86898: LIST
86899: LIST
86900: PUSH
86901: LD_INT 1
86903: PUSH
86904: LD_INT 1
86906: NEG
86907: PUSH
86908: EMPTY
86909: LIST
86910: LIST
86911: PUSH
86912: LD_INT 2
86914: PUSH
86915: LD_INT 0
86917: PUSH
86918: EMPTY
86919: LIST
86920: LIST
86921: PUSH
86922: LD_INT 2
86924: PUSH
86925: LD_INT 1
86927: PUSH
86928: EMPTY
86929: LIST
86930: LIST
86931: PUSH
86932: LD_INT 2
86934: PUSH
86935: LD_INT 2
86937: PUSH
86938: EMPTY
86939: LIST
86940: LIST
86941: PUSH
86942: LD_INT 1
86944: PUSH
86945: LD_INT 2
86947: PUSH
86948: EMPTY
86949: LIST
86950: LIST
86951: PUSH
86952: LD_INT 0
86954: PUSH
86955: LD_INT 2
86957: PUSH
86958: EMPTY
86959: LIST
86960: LIST
86961: PUSH
86962: LD_INT 1
86964: NEG
86965: PUSH
86966: LD_INT 1
86968: PUSH
86969: EMPTY
86970: LIST
86971: LIST
86972: PUSH
86973: LD_INT 2
86975: NEG
86976: PUSH
86977: LD_INT 0
86979: PUSH
86980: EMPTY
86981: LIST
86982: LIST
86983: PUSH
86984: LD_INT 2
86986: NEG
86987: PUSH
86988: LD_INT 1
86990: NEG
86991: PUSH
86992: EMPTY
86993: LIST
86994: LIST
86995: PUSH
86996: LD_INT 2
86998: NEG
86999: PUSH
87000: LD_INT 2
87002: NEG
87003: PUSH
87004: EMPTY
87005: LIST
87006: LIST
87007: PUSH
87008: EMPTY
87009: LIST
87010: LIST
87011: LIST
87012: LIST
87013: LIST
87014: LIST
87015: LIST
87016: LIST
87017: LIST
87018: LIST
87019: LIST
87020: LIST
87021: LIST
87022: LIST
87023: LIST
87024: LIST
87025: LIST
87026: LIST
87027: LIST
87028: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87029: LD_ADDR_VAR 0 21
87033: PUSH
87034: LD_INT 0
87036: PUSH
87037: LD_INT 0
87039: PUSH
87040: EMPTY
87041: LIST
87042: LIST
87043: PUSH
87044: LD_INT 0
87046: PUSH
87047: LD_INT 1
87049: NEG
87050: PUSH
87051: EMPTY
87052: LIST
87053: LIST
87054: PUSH
87055: LD_INT 1
87057: PUSH
87058: LD_INT 0
87060: PUSH
87061: EMPTY
87062: LIST
87063: LIST
87064: PUSH
87065: LD_INT 1
87067: PUSH
87068: LD_INT 1
87070: PUSH
87071: EMPTY
87072: LIST
87073: LIST
87074: PUSH
87075: LD_INT 0
87077: PUSH
87078: LD_INT 1
87080: PUSH
87081: EMPTY
87082: LIST
87083: LIST
87084: PUSH
87085: LD_INT 1
87087: NEG
87088: PUSH
87089: LD_INT 0
87091: PUSH
87092: EMPTY
87093: LIST
87094: LIST
87095: PUSH
87096: LD_INT 1
87098: NEG
87099: PUSH
87100: LD_INT 1
87102: NEG
87103: PUSH
87104: EMPTY
87105: LIST
87106: LIST
87107: PUSH
87108: LD_INT 1
87110: NEG
87111: PUSH
87112: LD_INT 2
87114: NEG
87115: PUSH
87116: EMPTY
87117: LIST
87118: LIST
87119: PUSH
87120: LD_INT 0
87122: PUSH
87123: LD_INT 2
87125: NEG
87126: PUSH
87127: EMPTY
87128: LIST
87129: LIST
87130: PUSH
87131: LD_INT 1
87133: PUSH
87134: LD_INT 1
87136: NEG
87137: PUSH
87138: EMPTY
87139: LIST
87140: LIST
87141: PUSH
87142: LD_INT 2
87144: PUSH
87145: LD_INT 0
87147: PUSH
87148: EMPTY
87149: LIST
87150: LIST
87151: PUSH
87152: LD_INT 2
87154: PUSH
87155: LD_INT 1
87157: PUSH
87158: EMPTY
87159: LIST
87160: LIST
87161: PUSH
87162: LD_INT 2
87164: PUSH
87165: LD_INT 2
87167: PUSH
87168: EMPTY
87169: LIST
87170: LIST
87171: PUSH
87172: LD_INT 1
87174: PUSH
87175: LD_INT 2
87177: PUSH
87178: EMPTY
87179: LIST
87180: LIST
87181: PUSH
87182: LD_INT 0
87184: PUSH
87185: LD_INT 2
87187: PUSH
87188: EMPTY
87189: LIST
87190: LIST
87191: PUSH
87192: LD_INT 1
87194: NEG
87195: PUSH
87196: LD_INT 1
87198: PUSH
87199: EMPTY
87200: LIST
87201: LIST
87202: PUSH
87203: LD_INT 2
87205: NEG
87206: PUSH
87207: LD_INT 0
87209: PUSH
87210: EMPTY
87211: LIST
87212: LIST
87213: PUSH
87214: LD_INT 2
87216: NEG
87217: PUSH
87218: LD_INT 1
87220: NEG
87221: PUSH
87222: EMPTY
87223: LIST
87224: LIST
87225: PUSH
87226: LD_INT 2
87228: NEG
87229: PUSH
87230: LD_INT 2
87232: NEG
87233: PUSH
87234: EMPTY
87235: LIST
87236: LIST
87237: PUSH
87238: EMPTY
87239: LIST
87240: LIST
87241: LIST
87242: LIST
87243: LIST
87244: LIST
87245: LIST
87246: LIST
87247: LIST
87248: LIST
87249: LIST
87250: LIST
87251: LIST
87252: LIST
87253: LIST
87254: LIST
87255: LIST
87256: LIST
87257: LIST
87258: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87259: LD_ADDR_VAR 0 22
87263: PUSH
87264: LD_INT 0
87266: PUSH
87267: LD_INT 0
87269: PUSH
87270: EMPTY
87271: LIST
87272: LIST
87273: PUSH
87274: LD_INT 0
87276: PUSH
87277: LD_INT 1
87279: NEG
87280: PUSH
87281: EMPTY
87282: LIST
87283: LIST
87284: PUSH
87285: LD_INT 1
87287: PUSH
87288: LD_INT 0
87290: PUSH
87291: EMPTY
87292: LIST
87293: LIST
87294: PUSH
87295: LD_INT 1
87297: PUSH
87298: LD_INT 1
87300: PUSH
87301: EMPTY
87302: LIST
87303: LIST
87304: PUSH
87305: LD_INT 0
87307: PUSH
87308: LD_INT 1
87310: PUSH
87311: EMPTY
87312: LIST
87313: LIST
87314: PUSH
87315: LD_INT 1
87317: NEG
87318: PUSH
87319: LD_INT 0
87321: PUSH
87322: EMPTY
87323: LIST
87324: LIST
87325: PUSH
87326: LD_INT 1
87328: NEG
87329: PUSH
87330: LD_INT 1
87332: NEG
87333: PUSH
87334: EMPTY
87335: LIST
87336: LIST
87337: PUSH
87338: LD_INT 1
87340: NEG
87341: PUSH
87342: LD_INT 2
87344: NEG
87345: PUSH
87346: EMPTY
87347: LIST
87348: LIST
87349: PUSH
87350: LD_INT 0
87352: PUSH
87353: LD_INT 2
87355: NEG
87356: PUSH
87357: EMPTY
87358: LIST
87359: LIST
87360: PUSH
87361: LD_INT 1
87363: PUSH
87364: LD_INT 1
87366: NEG
87367: PUSH
87368: EMPTY
87369: LIST
87370: LIST
87371: PUSH
87372: LD_INT 2
87374: PUSH
87375: LD_INT 0
87377: PUSH
87378: EMPTY
87379: LIST
87380: LIST
87381: PUSH
87382: LD_INT 2
87384: PUSH
87385: LD_INT 1
87387: PUSH
87388: EMPTY
87389: LIST
87390: LIST
87391: PUSH
87392: LD_INT 2
87394: PUSH
87395: LD_INT 2
87397: PUSH
87398: EMPTY
87399: LIST
87400: LIST
87401: PUSH
87402: LD_INT 1
87404: PUSH
87405: LD_INT 2
87407: PUSH
87408: EMPTY
87409: LIST
87410: LIST
87411: PUSH
87412: LD_INT 0
87414: PUSH
87415: LD_INT 2
87417: PUSH
87418: EMPTY
87419: LIST
87420: LIST
87421: PUSH
87422: LD_INT 1
87424: NEG
87425: PUSH
87426: LD_INT 1
87428: PUSH
87429: EMPTY
87430: LIST
87431: LIST
87432: PUSH
87433: LD_INT 2
87435: NEG
87436: PUSH
87437: LD_INT 0
87439: PUSH
87440: EMPTY
87441: LIST
87442: LIST
87443: PUSH
87444: LD_INT 2
87446: NEG
87447: PUSH
87448: LD_INT 1
87450: NEG
87451: PUSH
87452: EMPTY
87453: LIST
87454: LIST
87455: PUSH
87456: LD_INT 2
87458: NEG
87459: PUSH
87460: LD_INT 2
87462: NEG
87463: PUSH
87464: EMPTY
87465: LIST
87466: LIST
87467: PUSH
87468: EMPTY
87469: LIST
87470: LIST
87471: LIST
87472: LIST
87473: LIST
87474: LIST
87475: LIST
87476: LIST
87477: LIST
87478: LIST
87479: LIST
87480: LIST
87481: LIST
87482: LIST
87483: LIST
87484: LIST
87485: LIST
87486: LIST
87487: LIST
87488: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
87489: LD_ADDR_VAR 0 23
87493: PUSH
87494: LD_INT 0
87496: PUSH
87497: LD_INT 0
87499: PUSH
87500: EMPTY
87501: LIST
87502: LIST
87503: PUSH
87504: LD_INT 0
87506: PUSH
87507: LD_INT 1
87509: NEG
87510: PUSH
87511: EMPTY
87512: LIST
87513: LIST
87514: PUSH
87515: LD_INT 1
87517: PUSH
87518: LD_INT 0
87520: PUSH
87521: EMPTY
87522: LIST
87523: LIST
87524: PUSH
87525: LD_INT 1
87527: PUSH
87528: LD_INT 1
87530: PUSH
87531: EMPTY
87532: LIST
87533: LIST
87534: PUSH
87535: LD_INT 0
87537: PUSH
87538: LD_INT 1
87540: PUSH
87541: EMPTY
87542: LIST
87543: LIST
87544: PUSH
87545: LD_INT 1
87547: NEG
87548: PUSH
87549: LD_INT 0
87551: PUSH
87552: EMPTY
87553: LIST
87554: LIST
87555: PUSH
87556: LD_INT 1
87558: NEG
87559: PUSH
87560: LD_INT 1
87562: NEG
87563: PUSH
87564: EMPTY
87565: LIST
87566: LIST
87567: PUSH
87568: LD_INT 1
87570: NEG
87571: PUSH
87572: LD_INT 2
87574: NEG
87575: PUSH
87576: EMPTY
87577: LIST
87578: LIST
87579: PUSH
87580: LD_INT 0
87582: PUSH
87583: LD_INT 2
87585: NEG
87586: PUSH
87587: EMPTY
87588: LIST
87589: LIST
87590: PUSH
87591: LD_INT 1
87593: PUSH
87594: LD_INT 1
87596: NEG
87597: PUSH
87598: EMPTY
87599: LIST
87600: LIST
87601: PUSH
87602: LD_INT 2
87604: PUSH
87605: LD_INT 0
87607: PUSH
87608: EMPTY
87609: LIST
87610: LIST
87611: PUSH
87612: LD_INT 2
87614: PUSH
87615: LD_INT 1
87617: PUSH
87618: EMPTY
87619: LIST
87620: LIST
87621: PUSH
87622: LD_INT 2
87624: PUSH
87625: LD_INT 2
87627: PUSH
87628: EMPTY
87629: LIST
87630: LIST
87631: PUSH
87632: LD_INT 1
87634: PUSH
87635: LD_INT 2
87637: PUSH
87638: EMPTY
87639: LIST
87640: LIST
87641: PUSH
87642: LD_INT 0
87644: PUSH
87645: LD_INT 2
87647: PUSH
87648: EMPTY
87649: LIST
87650: LIST
87651: PUSH
87652: LD_INT 1
87654: NEG
87655: PUSH
87656: LD_INT 1
87658: PUSH
87659: EMPTY
87660: LIST
87661: LIST
87662: PUSH
87663: LD_INT 2
87665: NEG
87666: PUSH
87667: LD_INT 0
87669: PUSH
87670: EMPTY
87671: LIST
87672: LIST
87673: PUSH
87674: LD_INT 2
87676: NEG
87677: PUSH
87678: LD_INT 1
87680: NEG
87681: PUSH
87682: EMPTY
87683: LIST
87684: LIST
87685: PUSH
87686: LD_INT 2
87688: NEG
87689: PUSH
87690: LD_INT 2
87692: NEG
87693: PUSH
87694: EMPTY
87695: LIST
87696: LIST
87697: PUSH
87698: LD_INT 2
87700: NEG
87701: PUSH
87702: LD_INT 3
87704: NEG
87705: PUSH
87706: EMPTY
87707: LIST
87708: LIST
87709: PUSH
87710: LD_INT 1
87712: NEG
87713: PUSH
87714: LD_INT 3
87716: NEG
87717: PUSH
87718: EMPTY
87719: LIST
87720: LIST
87721: PUSH
87722: LD_INT 1
87724: PUSH
87725: LD_INT 2
87727: NEG
87728: PUSH
87729: EMPTY
87730: LIST
87731: LIST
87732: PUSH
87733: LD_INT 2
87735: PUSH
87736: LD_INT 1
87738: NEG
87739: PUSH
87740: EMPTY
87741: LIST
87742: LIST
87743: PUSH
87744: EMPTY
87745: LIST
87746: LIST
87747: LIST
87748: LIST
87749: LIST
87750: LIST
87751: LIST
87752: LIST
87753: LIST
87754: LIST
87755: LIST
87756: LIST
87757: LIST
87758: LIST
87759: LIST
87760: LIST
87761: LIST
87762: LIST
87763: LIST
87764: LIST
87765: LIST
87766: LIST
87767: LIST
87768: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
87769: LD_ADDR_VAR 0 24
87773: PUSH
87774: LD_INT 0
87776: PUSH
87777: LD_INT 0
87779: PUSH
87780: EMPTY
87781: LIST
87782: LIST
87783: PUSH
87784: LD_INT 0
87786: PUSH
87787: LD_INT 1
87789: NEG
87790: PUSH
87791: EMPTY
87792: LIST
87793: LIST
87794: PUSH
87795: LD_INT 1
87797: PUSH
87798: LD_INT 0
87800: PUSH
87801: EMPTY
87802: LIST
87803: LIST
87804: PUSH
87805: LD_INT 1
87807: PUSH
87808: LD_INT 1
87810: PUSH
87811: EMPTY
87812: LIST
87813: LIST
87814: PUSH
87815: LD_INT 0
87817: PUSH
87818: LD_INT 1
87820: PUSH
87821: EMPTY
87822: LIST
87823: LIST
87824: PUSH
87825: LD_INT 1
87827: NEG
87828: PUSH
87829: LD_INT 0
87831: PUSH
87832: EMPTY
87833: LIST
87834: LIST
87835: PUSH
87836: LD_INT 1
87838: NEG
87839: PUSH
87840: LD_INT 1
87842: NEG
87843: PUSH
87844: EMPTY
87845: LIST
87846: LIST
87847: PUSH
87848: LD_INT 1
87850: NEG
87851: PUSH
87852: LD_INT 2
87854: NEG
87855: PUSH
87856: EMPTY
87857: LIST
87858: LIST
87859: PUSH
87860: LD_INT 0
87862: PUSH
87863: LD_INT 2
87865: NEG
87866: PUSH
87867: EMPTY
87868: LIST
87869: LIST
87870: PUSH
87871: LD_INT 1
87873: PUSH
87874: LD_INT 1
87876: NEG
87877: PUSH
87878: EMPTY
87879: LIST
87880: LIST
87881: PUSH
87882: LD_INT 2
87884: PUSH
87885: LD_INT 0
87887: PUSH
87888: EMPTY
87889: LIST
87890: LIST
87891: PUSH
87892: LD_INT 2
87894: PUSH
87895: LD_INT 1
87897: PUSH
87898: EMPTY
87899: LIST
87900: LIST
87901: PUSH
87902: LD_INT 2
87904: PUSH
87905: LD_INT 2
87907: PUSH
87908: EMPTY
87909: LIST
87910: LIST
87911: PUSH
87912: LD_INT 1
87914: PUSH
87915: LD_INT 2
87917: PUSH
87918: EMPTY
87919: LIST
87920: LIST
87921: PUSH
87922: LD_INT 0
87924: PUSH
87925: LD_INT 2
87927: PUSH
87928: EMPTY
87929: LIST
87930: LIST
87931: PUSH
87932: LD_INT 1
87934: NEG
87935: PUSH
87936: LD_INT 1
87938: PUSH
87939: EMPTY
87940: LIST
87941: LIST
87942: PUSH
87943: LD_INT 2
87945: NEG
87946: PUSH
87947: LD_INT 0
87949: PUSH
87950: EMPTY
87951: LIST
87952: LIST
87953: PUSH
87954: LD_INT 2
87956: NEG
87957: PUSH
87958: LD_INT 1
87960: NEG
87961: PUSH
87962: EMPTY
87963: LIST
87964: LIST
87965: PUSH
87966: LD_INT 2
87968: NEG
87969: PUSH
87970: LD_INT 2
87972: NEG
87973: PUSH
87974: EMPTY
87975: LIST
87976: LIST
87977: PUSH
87978: LD_INT 1
87980: PUSH
87981: LD_INT 2
87983: NEG
87984: PUSH
87985: EMPTY
87986: LIST
87987: LIST
87988: PUSH
87989: LD_INT 2
87991: PUSH
87992: LD_INT 1
87994: NEG
87995: PUSH
87996: EMPTY
87997: LIST
87998: LIST
87999: PUSH
88000: LD_INT 3
88002: PUSH
88003: LD_INT 1
88005: PUSH
88006: EMPTY
88007: LIST
88008: LIST
88009: PUSH
88010: LD_INT 3
88012: PUSH
88013: LD_INT 2
88015: PUSH
88016: EMPTY
88017: LIST
88018: LIST
88019: PUSH
88020: EMPTY
88021: LIST
88022: LIST
88023: LIST
88024: LIST
88025: LIST
88026: LIST
88027: LIST
88028: LIST
88029: LIST
88030: LIST
88031: LIST
88032: LIST
88033: LIST
88034: LIST
88035: LIST
88036: LIST
88037: LIST
88038: LIST
88039: LIST
88040: LIST
88041: LIST
88042: LIST
88043: LIST
88044: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
88045: LD_ADDR_VAR 0 25
88049: PUSH
88050: LD_INT 0
88052: PUSH
88053: LD_INT 0
88055: PUSH
88056: EMPTY
88057: LIST
88058: LIST
88059: PUSH
88060: LD_INT 0
88062: PUSH
88063: LD_INT 1
88065: NEG
88066: PUSH
88067: EMPTY
88068: LIST
88069: LIST
88070: PUSH
88071: LD_INT 1
88073: PUSH
88074: LD_INT 0
88076: PUSH
88077: EMPTY
88078: LIST
88079: LIST
88080: PUSH
88081: LD_INT 1
88083: PUSH
88084: LD_INT 1
88086: PUSH
88087: EMPTY
88088: LIST
88089: LIST
88090: PUSH
88091: LD_INT 0
88093: PUSH
88094: LD_INT 1
88096: PUSH
88097: EMPTY
88098: LIST
88099: LIST
88100: PUSH
88101: LD_INT 1
88103: NEG
88104: PUSH
88105: LD_INT 0
88107: PUSH
88108: EMPTY
88109: LIST
88110: LIST
88111: PUSH
88112: LD_INT 1
88114: NEG
88115: PUSH
88116: LD_INT 1
88118: NEG
88119: PUSH
88120: EMPTY
88121: LIST
88122: LIST
88123: PUSH
88124: LD_INT 1
88126: NEG
88127: PUSH
88128: LD_INT 2
88130: NEG
88131: PUSH
88132: EMPTY
88133: LIST
88134: LIST
88135: PUSH
88136: LD_INT 0
88138: PUSH
88139: LD_INT 2
88141: NEG
88142: PUSH
88143: EMPTY
88144: LIST
88145: LIST
88146: PUSH
88147: LD_INT 1
88149: PUSH
88150: LD_INT 1
88152: NEG
88153: PUSH
88154: EMPTY
88155: LIST
88156: LIST
88157: PUSH
88158: LD_INT 2
88160: PUSH
88161: LD_INT 0
88163: PUSH
88164: EMPTY
88165: LIST
88166: LIST
88167: PUSH
88168: LD_INT 2
88170: PUSH
88171: LD_INT 1
88173: PUSH
88174: EMPTY
88175: LIST
88176: LIST
88177: PUSH
88178: LD_INT 2
88180: PUSH
88181: LD_INT 2
88183: PUSH
88184: EMPTY
88185: LIST
88186: LIST
88187: PUSH
88188: LD_INT 1
88190: PUSH
88191: LD_INT 2
88193: PUSH
88194: EMPTY
88195: LIST
88196: LIST
88197: PUSH
88198: LD_INT 0
88200: PUSH
88201: LD_INT 2
88203: PUSH
88204: EMPTY
88205: LIST
88206: LIST
88207: PUSH
88208: LD_INT 1
88210: NEG
88211: PUSH
88212: LD_INT 1
88214: PUSH
88215: EMPTY
88216: LIST
88217: LIST
88218: PUSH
88219: LD_INT 2
88221: NEG
88222: PUSH
88223: LD_INT 0
88225: PUSH
88226: EMPTY
88227: LIST
88228: LIST
88229: PUSH
88230: LD_INT 2
88232: NEG
88233: PUSH
88234: LD_INT 1
88236: NEG
88237: PUSH
88238: EMPTY
88239: LIST
88240: LIST
88241: PUSH
88242: LD_INT 2
88244: NEG
88245: PUSH
88246: LD_INT 2
88248: NEG
88249: PUSH
88250: EMPTY
88251: LIST
88252: LIST
88253: PUSH
88254: LD_INT 3
88256: PUSH
88257: LD_INT 1
88259: PUSH
88260: EMPTY
88261: LIST
88262: LIST
88263: PUSH
88264: LD_INT 3
88266: PUSH
88267: LD_INT 2
88269: PUSH
88270: EMPTY
88271: LIST
88272: LIST
88273: PUSH
88274: LD_INT 2
88276: PUSH
88277: LD_INT 3
88279: PUSH
88280: EMPTY
88281: LIST
88282: LIST
88283: PUSH
88284: LD_INT 1
88286: PUSH
88287: LD_INT 3
88289: PUSH
88290: EMPTY
88291: LIST
88292: LIST
88293: PUSH
88294: EMPTY
88295: LIST
88296: LIST
88297: LIST
88298: LIST
88299: LIST
88300: LIST
88301: LIST
88302: LIST
88303: LIST
88304: LIST
88305: LIST
88306: LIST
88307: LIST
88308: LIST
88309: LIST
88310: LIST
88311: LIST
88312: LIST
88313: LIST
88314: LIST
88315: LIST
88316: LIST
88317: LIST
88318: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
88319: LD_ADDR_VAR 0 26
88323: PUSH
88324: LD_INT 0
88326: PUSH
88327: LD_INT 0
88329: PUSH
88330: EMPTY
88331: LIST
88332: LIST
88333: PUSH
88334: LD_INT 0
88336: PUSH
88337: LD_INT 1
88339: NEG
88340: PUSH
88341: EMPTY
88342: LIST
88343: LIST
88344: PUSH
88345: LD_INT 1
88347: PUSH
88348: LD_INT 0
88350: PUSH
88351: EMPTY
88352: LIST
88353: LIST
88354: PUSH
88355: LD_INT 1
88357: PUSH
88358: LD_INT 1
88360: PUSH
88361: EMPTY
88362: LIST
88363: LIST
88364: PUSH
88365: LD_INT 0
88367: PUSH
88368: LD_INT 1
88370: PUSH
88371: EMPTY
88372: LIST
88373: LIST
88374: PUSH
88375: LD_INT 1
88377: NEG
88378: PUSH
88379: LD_INT 0
88381: PUSH
88382: EMPTY
88383: LIST
88384: LIST
88385: PUSH
88386: LD_INT 1
88388: NEG
88389: PUSH
88390: LD_INT 1
88392: NEG
88393: PUSH
88394: EMPTY
88395: LIST
88396: LIST
88397: PUSH
88398: LD_INT 1
88400: NEG
88401: PUSH
88402: LD_INT 2
88404: NEG
88405: PUSH
88406: EMPTY
88407: LIST
88408: LIST
88409: PUSH
88410: LD_INT 0
88412: PUSH
88413: LD_INT 2
88415: NEG
88416: PUSH
88417: EMPTY
88418: LIST
88419: LIST
88420: PUSH
88421: LD_INT 1
88423: PUSH
88424: LD_INT 1
88426: NEG
88427: PUSH
88428: EMPTY
88429: LIST
88430: LIST
88431: PUSH
88432: LD_INT 2
88434: PUSH
88435: LD_INT 0
88437: PUSH
88438: EMPTY
88439: LIST
88440: LIST
88441: PUSH
88442: LD_INT 2
88444: PUSH
88445: LD_INT 1
88447: PUSH
88448: EMPTY
88449: LIST
88450: LIST
88451: PUSH
88452: LD_INT 2
88454: PUSH
88455: LD_INT 2
88457: PUSH
88458: EMPTY
88459: LIST
88460: LIST
88461: PUSH
88462: LD_INT 1
88464: PUSH
88465: LD_INT 2
88467: PUSH
88468: EMPTY
88469: LIST
88470: LIST
88471: PUSH
88472: LD_INT 0
88474: PUSH
88475: LD_INT 2
88477: PUSH
88478: EMPTY
88479: LIST
88480: LIST
88481: PUSH
88482: LD_INT 1
88484: NEG
88485: PUSH
88486: LD_INT 1
88488: PUSH
88489: EMPTY
88490: LIST
88491: LIST
88492: PUSH
88493: LD_INT 2
88495: NEG
88496: PUSH
88497: LD_INT 0
88499: PUSH
88500: EMPTY
88501: LIST
88502: LIST
88503: PUSH
88504: LD_INT 2
88506: NEG
88507: PUSH
88508: LD_INT 1
88510: NEG
88511: PUSH
88512: EMPTY
88513: LIST
88514: LIST
88515: PUSH
88516: LD_INT 2
88518: NEG
88519: PUSH
88520: LD_INT 2
88522: NEG
88523: PUSH
88524: EMPTY
88525: LIST
88526: LIST
88527: PUSH
88528: LD_INT 2
88530: PUSH
88531: LD_INT 3
88533: PUSH
88534: EMPTY
88535: LIST
88536: LIST
88537: PUSH
88538: LD_INT 1
88540: PUSH
88541: LD_INT 3
88543: PUSH
88544: EMPTY
88545: LIST
88546: LIST
88547: PUSH
88548: LD_INT 1
88550: NEG
88551: PUSH
88552: LD_INT 2
88554: PUSH
88555: EMPTY
88556: LIST
88557: LIST
88558: PUSH
88559: LD_INT 2
88561: NEG
88562: PUSH
88563: LD_INT 1
88565: PUSH
88566: EMPTY
88567: LIST
88568: LIST
88569: PUSH
88570: EMPTY
88571: LIST
88572: LIST
88573: LIST
88574: LIST
88575: LIST
88576: LIST
88577: LIST
88578: LIST
88579: LIST
88580: LIST
88581: LIST
88582: LIST
88583: LIST
88584: LIST
88585: LIST
88586: LIST
88587: LIST
88588: LIST
88589: LIST
88590: LIST
88591: LIST
88592: LIST
88593: LIST
88594: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
88595: LD_ADDR_VAR 0 27
88599: PUSH
88600: LD_INT 0
88602: PUSH
88603: LD_INT 0
88605: PUSH
88606: EMPTY
88607: LIST
88608: LIST
88609: PUSH
88610: LD_INT 0
88612: PUSH
88613: LD_INT 1
88615: NEG
88616: PUSH
88617: EMPTY
88618: LIST
88619: LIST
88620: PUSH
88621: LD_INT 1
88623: PUSH
88624: LD_INT 0
88626: PUSH
88627: EMPTY
88628: LIST
88629: LIST
88630: PUSH
88631: LD_INT 1
88633: PUSH
88634: LD_INT 1
88636: PUSH
88637: EMPTY
88638: LIST
88639: LIST
88640: PUSH
88641: LD_INT 0
88643: PUSH
88644: LD_INT 1
88646: PUSH
88647: EMPTY
88648: LIST
88649: LIST
88650: PUSH
88651: LD_INT 1
88653: NEG
88654: PUSH
88655: LD_INT 0
88657: PUSH
88658: EMPTY
88659: LIST
88660: LIST
88661: PUSH
88662: LD_INT 1
88664: NEG
88665: PUSH
88666: LD_INT 1
88668: NEG
88669: PUSH
88670: EMPTY
88671: LIST
88672: LIST
88673: PUSH
88674: LD_INT 1
88676: NEG
88677: PUSH
88678: LD_INT 2
88680: NEG
88681: PUSH
88682: EMPTY
88683: LIST
88684: LIST
88685: PUSH
88686: LD_INT 0
88688: PUSH
88689: LD_INT 2
88691: NEG
88692: PUSH
88693: EMPTY
88694: LIST
88695: LIST
88696: PUSH
88697: LD_INT 1
88699: PUSH
88700: LD_INT 1
88702: NEG
88703: PUSH
88704: EMPTY
88705: LIST
88706: LIST
88707: PUSH
88708: LD_INT 2
88710: PUSH
88711: LD_INT 0
88713: PUSH
88714: EMPTY
88715: LIST
88716: LIST
88717: PUSH
88718: LD_INT 2
88720: PUSH
88721: LD_INT 1
88723: PUSH
88724: EMPTY
88725: LIST
88726: LIST
88727: PUSH
88728: LD_INT 2
88730: PUSH
88731: LD_INT 2
88733: PUSH
88734: EMPTY
88735: LIST
88736: LIST
88737: PUSH
88738: LD_INT 1
88740: PUSH
88741: LD_INT 2
88743: PUSH
88744: EMPTY
88745: LIST
88746: LIST
88747: PUSH
88748: LD_INT 0
88750: PUSH
88751: LD_INT 2
88753: PUSH
88754: EMPTY
88755: LIST
88756: LIST
88757: PUSH
88758: LD_INT 1
88760: NEG
88761: PUSH
88762: LD_INT 1
88764: PUSH
88765: EMPTY
88766: LIST
88767: LIST
88768: PUSH
88769: LD_INT 2
88771: NEG
88772: PUSH
88773: LD_INT 0
88775: PUSH
88776: EMPTY
88777: LIST
88778: LIST
88779: PUSH
88780: LD_INT 2
88782: NEG
88783: PUSH
88784: LD_INT 1
88786: NEG
88787: PUSH
88788: EMPTY
88789: LIST
88790: LIST
88791: PUSH
88792: LD_INT 2
88794: NEG
88795: PUSH
88796: LD_INT 2
88798: NEG
88799: PUSH
88800: EMPTY
88801: LIST
88802: LIST
88803: PUSH
88804: LD_INT 1
88806: NEG
88807: PUSH
88808: LD_INT 2
88810: PUSH
88811: EMPTY
88812: LIST
88813: LIST
88814: PUSH
88815: LD_INT 2
88817: NEG
88818: PUSH
88819: LD_INT 1
88821: PUSH
88822: EMPTY
88823: LIST
88824: LIST
88825: PUSH
88826: LD_INT 3
88828: NEG
88829: PUSH
88830: LD_INT 1
88832: NEG
88833: PUSH
88834: EMPTY
88835: LIST
88836: LIST
88837: PUSH
88838: LD_INT 3
88840: NEG
88841: PUSH
88842: LD_INT 2
88844: NEG
88845: PUSH
88846: EMPTY
88847: LIST
88848: LIST
88849: PUSH
88850: EMPTY
88851: LIST
88852: LIST
88853: LIST
88854: LIST
88855: LIST
88856: LIST
88857: LIST
88858: LIST
88859: LIST
88860: LIST
88861: LIST
88862: LIST
88863: LIST
88864: LIST
88865: LIST
88866: LIST
88867: LIST
88868: LIST
88869: LIST
88870: LIST
88871: LIST
88872: LIST
88873: LIST
88874: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
88875: LD_ADDR_VAR 0 28
88879: PUSH
88880: LD_INT 0
88882: PUSH
88883: LD_INT 0
88885: PUSH
88886: EMPTY
88887: LIST
88888: LIST
88889: PUSH
88890: LD_INT 0
88892: PUSH
88893: LD_INT 1
88895: NEG
88896: PUSH
88897: EMPTY
88898: LIST
88899: LIST
88900: PUSH
88901: LD_INT 1
88903: PUSH
88904: LD_INT 0
88906: PUSH
88907: EMPTY
88908: LIST
88909: LIST
88910: PUSH
88911: LD_INT 1
88913: PUSH
88914: LD_INT 1
88916: PUSH
88917: EMPTY
88918: LIST
88919: LIST
88920: PUSH
88921: LD_INT 0
88923: PUSH
88924: LD_INT 1
88926: PUSH
88927: EMPTY
88928: LIST
88929: LIST
88930: PUSH
88931: LD_INT 1
88933: NEG
88934: PUSH
88935: LD_INT 0
88937: PUSH
88938: EMPTY
88939: LIST
88940: LIST
88941: PUSH
88942: LD_INT 1
88944: NEG
88945: PUSH
88946: LD_INT 1
88948: NEG
88949: PUSH
88950: EMPTY
88951: LIST
88952: LIST
88953: PUSH
88954: LD_INT 1
88956: NEG
88957: PUSH
88958: LD_INT 2
88960: NEG
88961: PUSH
88962: EMPTY
88963: LIST
88964: LIST
88965: PUSH
88966: LD_INT 0
88968: PUSH
88969: LD_INT 2
88971: NEG
88972: PUSH
88973: EMPTY
88974: LIST
88975: LIST
88976: PUSH
88977: LD_INT 1
88979: PUSH
88980: LD_INT 1
88982: NEG
88983: PUSH
88984: EMPTY
88985: LIST
88986: LIST
88987: PUSH
88988: LD_INT 2
88990: PUSH
88991: LD_INT 0
88993: PUSH
88994: EMPTY
88995: LIST
88996: LIST
88997: PUSH
88998: LD_INT 2
89000: PUSH
89001: LD_INT 1
89003: PUSH
89004: EMPTY
89005: LIST
89006: LIST
89007: PUSH
89008: LD_INT 2
89010: PUSH
89011: LD_INT 2
89013: PUSH
89014: EMPTY
89015: LIST
89016: LIST
89017: PUSH
89018: LD_INT 1
89020: PUSH
89021: LD_INT 2
89023: PUSH
89024: EMPTY
89025: LIST
89026: LIST
89027: PUSH
89028: LD_INT 0
89030: PUSH
89031: LD_INT 2
89033: PUSH
89034: EMPTY
89035: LIST
89036: LIST
89037: PUSH
89038: LD_INT 1
89040: NEG
89041: PUSH
89042: LD_INT 1
89044: PUSH
89045: EMPTY
89046: LIST
89047: LIST
89048: PUSH
89049: LD_INT 2
89051: NEG
89052: PUSH
89053: LD_INT 0
89055: PUSH
89056: EMPTY
89057: LIST
89058: LIST
89059: PUSH
89060: LD_INT 2
89062: NEG
89063: PUSH
89064: LD_INT 1
89066: NEG
89067: PUSH
89068: EMPTY
89069: LIST
89070: LIST
89071: PUSH
89072: LD_INT 2
89074: NEG
89075: PUSH
89076: LD_INT 2
89078: NEG
89079: PUSH
89080: EMPTY
89081: LIST
89082: LIST
89083: PUSH
89084: LD_INT 2
89086: NEG
89087: PUSH
89088: LD_INT 3
89090: NEG
89091: PUSH
89092: EMPTY
89093: LIST
89094: LIST
89095: PUSH
89096: LD_INT 1
89098: NEG
89099: PUSH
89100: LD_INT 3
89102: NEG
89103: PUSH
89104: EMPTY
89105: LIST
89106: LIST
89107: PUSH
89108: LD_INT 3
89110: NEG
89111: PUSH
89112: LD_INT 1
89114: NEG
89115: PUSH
89116: EMPTY
89117: LIST
89118: LIST
89119: PUSH
89120: LD_INT 3
89122: NEG
89123: PUSH
89124: LD_INT 2
89126: NEG
89127: PUSH
89128: EMPTY
89129: LIST
89130: LIST
89131: PUSH
89132: EMPTY
89133: LIST
89134: LIST
89135: LIST
89136: LIST
89137: LIST
89138: LIST
89139: LIST
89140: LIST
89141: LIST
89142: LIST
89143: LIST
89144: LIST
89145: LIST
89146: LIST
89147: LIST
89148: LIST
89149: LIST
89150: LIST
89151: LIST
89152: LIST
89153: LIST
89154: LIST
89155: LIST
89156: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
89157: LD_ADDR_VAR 0 29
89161: PUSH
89162: LD_INT 0
89164: PUSH
89165: LD_INT 0
89167: PUSH
89168: EMPTY
89169: LIST
89170: LIST
89171: PUSH
89172: LD_INT 0
89174: PUSH
89175: LD_INT 1
89177: NEG
89178: PUSH
89179: EMPTY
89180: LIST
89181: LIST
89182: PUSH
89183: LD_INT 1
89185: PUSH
89186: LD_INT 0
89188: PUSH
89189: EMPTY
89190: LIST
89191: LIST
89192: PUSH
89193: LD_INT 1
89195: PUSH
89196: LD_INT 1
89198: PUSH
89199: EMPTY
89200: LIST
89201: LIST
89202: PUSH
89203: LD_INT 0
89205: PUSH
89206: LD_INT 1
89208: PUSH
89209: EMPTY
89210: LIST
89211: LIST
89212: PUSH
89213: LD_INT 1
89215: NEG
89216: PUSH
89217: LD_INT 0
89219: PUSH
89220: EMPTY
89221: LIST
89222: LIST
89223: PUSH
89224: LD_INT 1
89226: NEG
89227: PUSH
89228: LD_INT 1
89230: NEG
89231: PUSH
89232: EMPTY
89233: LIST
89234: LIST
89235: PUSH
89236: LD_INT 1
89238: NEG
89239: PUSH
89240: LD_INT 2
89242: NEG
89243: PUSH
89244: EMPTY
89245: LIST
89246: LIST
89247: PUSH
89248: LD_INT 0
89250: PUSH
89251: LD_INT 2
89253: NEG
89254: PUSH
89255: EMPTY
89256: LIST
89257: LIST
89258: PUSH
89259: LD_INT 1
89261: PUSH
89262: LD_INT 1
89264: NEG
89265: PUSH
89266: EMPTY
89267: LIST
89268: LIST
89269: PUSH
89270: LD_INT 2
89272: PUSH
89273: LD_INT 0
89275: PUSH
89276: EMPTY
89277: LIST
89278: LIST
89279: PUSH
89280: LD_INT 2
89282: PUSH
89283: LD_INT 1
89285: PUSH
89286: EMPTY
89287: LIST
89288: LIST
89289: PUSH
89290: LD_INT 1
89292: PUSH
89293: LD_INT 2
89295: PUSH
89296: EMPTY
89297: LIST
89298: LIST
89299: PUSH
89300: LD_INT 0
89302: PUSH
89303: LD_INT 2
89305: PUSH
89306: EMPTY
89307: LIST
89308: LIST
89309: PUSH
89310: LD_INT 1
89312: NEG
89313: PUSH
89314: LD_INT 1
89316: PUSH
89317: EMPTY
89318: LIST
89319: LIST
89320: PUSH
89321: LD_INT 2
89323: NEG
89324: PUSH
89325: LD_INT 1
89327: NEG
89328: PUSH
89329: EMPTY
89330: LIST
89331: LIST
89332: PUSH
89333: LD_INT 2
89335: NEG
89336: PUSH
89337: LD_INT 2
89339: NEG
89340: PUSH
89341: EMPTY
89342: LIST
89343: LIST
89344: PUSH
89345: LD_INT 2
89347: NEG
89348: PUSH
89349: LD_INT 3
89351: NEG
89352: PUSH
89353: EMPTY
89354: LIST
89355: LIST
89356: PUSH
89357: LD_INT 2
89359: PUSH
89360: LD_INT 1
89362: NEG
89363: PUSH
89364: EMPTY
89365: LIST
89366: LIST
89367: PUSH
89368: LD_INT 3
89370: PUSH
89371: LD_INT 1
89373: PUSH
89374: EMPTY
89375: LIST
89376: LIST
89377: PUSH
89378: LD_INT 1
89380: PUSH
89381: LD_INT 3
89383: PUSH
89384: EMPTY
89385: LIST
89386: LIST
89387: PUSH
89388: LD_INT 1
89390: NEG
89391: PUSH
89392: LD_INT 2
89394: PUSH
89395: EMPTY
89396: LIST
89397: LIST
89398: PUSH
89399: LD_INT 3
89401: NEG
89402: PUSH
89403: LD_INT 2
89405: NEG
89406: PUSH
89407: EMPTY
89408: LIST
89409: LIST
89410: PUSH
89411: EMPTY
89412: LIST
89413: LIST
89414: LIST
89415: LIST
89416: LIST
89417: LIST
89418: LIST
89419: LIST
89420: LIST
89421: LIST
89422: LIST
89423: LIST
89424: LIST
89425: LIST
89426: LIST
89427: LIST
89428: LIST
89429: LIST
89430: LIST
89431: LIST
89432: LIST
89433: LIST
89434: LIST
89435: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
89436: LD_ADDR_VAR 0 30
89440: PUSH
89441: LD_INT 0
89443: PUSH
89444: LD_INT 0
89446: PUSH
89447: EMPTY
89448: LIST
89449: LIST
89450: PUSH
89451: LD_INT 0
89453: PUSH
89454: LD_INT 1
89456: NEG
89457: PUSH
89458: EMPTY
89459: LIST
89460: LIST
89461: PUSH
89462: LD_INT 1
89464: PUSH
89465: LD_INT 0
89467: PUSH
89468: EMPTY
89469: LIST
89470: LIST
89471: PUSH
89472: LD_INT 1
89474: PUSH
89475: LD_INT 1
89477: PUSH
89478: EMPTY
89479: LIST
89480: LIST
89481: PUSH
89482: LD_INT 0
89484: PUSH
89485: LD_INT 1
89487: PUSH
89488: EMPTY
89489: LIST
89490: LIST
89491: PUSH
89492: LD_INT 1
89494: NEG
89495: PUSH
89496: LD_INT 0
89498: PUSH
89499: EMPTY
89500: LIST
89501: LIST
89502: PUSH
89503: LD_INT 1
89505: NEG
89506: PUSH
89507: LD_INT 1
89509: NEG
89510: PUSH
89511: EMPTY
89512: LIST
89513: LIST
89514: PUSH
89515: LD_INT 1
89517: NEG
89518: PUSH
89519: LD_INT 2
89521: NEG
89522: PUSH
89523: EMPTY
89524: LIST
89525: LIST
89526: PUSH
89527: LD_INT 0
89529: PUSH
89530: LD_INT 2
89532: NEG
89533: PUSH
89534: EMPTY
89535: LIST
89536: LIST
89537: PUSH
89538: LD_INT 1
89540: PUSH
89541: LD_INT 1
89543: NEG
89544: PUSH
89545: EMPTY
89546: LIST
89547: LIST
89548: PUSH
89549: LD_INT 2
89551: PUSH
89552: LD_INT 0
89554: PUSH
89555: EMPTY
89556: LIST
89557: LIST
89558: PUSH
89559: LD_INT 2
89561: PUSH
89562: LD_INT 1
89564: PUSH
89565: EMPTY
89566: LIST
89567: LIST
89568: PUSH
89569: LD_INT 2
89571: PUSH
89572: LD_INT 2
89574: PUSH
89575: EMPTY
89576: LIST
89577: LIST
89578: PUSH
89579: LD_INT 1
89581: PUSH
89582: LD_INT 2
89584: PUSH
89585: EMPTY
89586: LIST
89587: LIST
89588: PUSH
89589: LD_INT 1
89591: NEG
89592: PUSH
89593: LD_INT 1
89595: PUSH
89596: EMPTY
89597: LIST
89598: LIST
89599: PUSH
89600: LD_INT 2
89602: NEG
89603: PUSH
89604: LD_INT 0
89606: PUSH
89607: EMPTY
89608: LIST
89609: LIST
89610: PUSH
89611: LD_INT 2
89613: NEG
89614: PUSH
89615: LD_INT 1
89617: NEG
89618: PUSH
89619: EMPTY
89620: LIST
89621: LIST
89622: PUSH
89623: LD_INT 1
89625: NEG
89626: PUSH
89627: LD_INT 3
89629: NEG
89630: PUSH
89631: EMPTY
89632: LIST
89633: LIST
89634: PUSH
89635: LD_INT 1
89637: PUSH
89638: LD_INT 2
89640: NEG
89641: PUSH
89642: EMPTY
89643: LIST
89644: LIST
89645: PUSH
89646: LD_INT 3
89648: PUSH
89649: LD_INT 2
89651: PUSH
89652: EMPTY
89653: LIST
89654: LIST
89655: PUSH
89656: LD_INT 2
89658: PUSH
89659: LD_INT 3
89661: PUSH
89662: EMPTY
89663: LIST
89664: LIST
89665: PUSH
89666: LD_INT 2
89668: NEG
89669: PUSH
89670: LD_INT 1
89672: PUSH
89673: EMPTY
89674: LIST
89675: LIST
89676: PUSH
89677: LD_INT 3
89679: NEG
89680: PUSH
89681: LD_INT 1
89683: NEG
89684: PUSH
89685: EMPTY
89686: LIST
89687: LIST
89688: PUSH
89689: EMPTY
89690: LIST
89691: LIST
89692: LIST
89693: LIST
89694: LIST
89695: LIST
89696: LIST
89697: LIST
89698: LIST
89699: LIST
89700: LIST
89701: LIST
89702: LIST
89703: LIST
89704: LIST
89705: LIST
89706: LIST
89707: LIST
89708: LIST
89709: LIST
89710: LIST
89711: LIST
89712: LIST
89713: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
89714: LD_ADDR_VAR 0 31
89718: PUSH
89719: LD_INT 0
89721: PUSH
89722: LD_INT 0
89724: PUSH
89725: EMPTY
89726: LIST
89727: LIST
89728: PUSH
89729: LD_INT 0
89731: PUSH
89732: LD_INT 1
89734: NEG
89735: PUSH
89736: EMPTY
89737: LIST
89738: LIST
89739: PUSH
89740: LD_INT 1
89742: PUSH
89743: LD_INT 0
89745: PUSH
89746: EMPTY
89747: LIST
89748: LIST
89749: PUSH
89750: LD_INT 1
89752: PUSH
89753: LD_INT 1
89755: PUSH
89756: EMPTY
89757: LIST
89758: LIST
89759: PUSH
89760: LD_INT 0
89762: PUSH
89763: LD_INT 1
89765: PUSH
89766: EMPTY
89767: LIST
89768: LIST
89769: PUSH
89770: LD_INT 1
89772: NEG
89773: PUSH
89774: LD_INT 0
89776: PUSH
89777: EMPTY
89778: LIST
89779: LIST
89780: PUSH
89781: LD_INT 1
89783: NEG
89784: PUSH
89785: LD_INT 1
89787: NEG
89788: PUSH
89789: EMPTY
89790: LIST
89791: LIST
89792: PUSH
89793: LD_INT 1
89795: NEG
89796: PUSH
89797: LD_INT 2
89799: NEG
89800: PUSH
89801: EMPTY
89802: LIST
89803: LIST
89804: PUSH
89805: LD_INT 1
89807: PUSH
89808: LD_INT 1
89810: NEG
89811: PUSH
89812: EMPTY
89813: LIST
89814: LIST
89815: PUSH
89816: LD_INT 2
89818: PUSH
89819: LD_INT 0
89821: PUSH
89822: EMPTY
89823: LIST
89824: LIST
89825: PUSH
89826: LD_INT 2
89828: PUSH
89829: LD_INT 1
89831: PUSH
89832: EMPTY
89833: LIST
89834: LIST
89835: PUSH
89836: LD_INT 2
89838: PUSH
89839: LD_INT 2
89841: PUSH
89842: EMPTY
89843: LIST
89844: LIST
89845: PUSH
89846: LD_INT 1
89848: PUSH
89849: LD_INT 2
89851: PUSH
89852: EMPTY
89853: LIST
89854: LIST
89855: PUSH
89856: LD_INT 0
89858: PUSH
89859: LD_INT 2
89861: PUSH
89862: EMPTY
89863: LIST
89864: LIST
89865: PUSH
89866: LD_INT 1
89868: NEG
89869: PUSH
89870: LD_INT 1
89872: PUSH
89873: EMPTY
89874: LIST
89875: LIST
89876: PUSH
89877: LD_INT 2
89879: NEG
89880: PUSH
89881: LD_INT 1
89883: NEG
89884: PUSH
89885: EMPTY
89886: LIST
89887: LIST
89888: PUSH
89889: LD_INT 2
89891: NEG
89892: PUSH
89893: LD_INT 2
89895: NEG
89896: PUSH
89897: EMPTY
89898: LIST
89899: LIST
89900: PUSH
89901: LD_INT 2
89903: NEG
89904: PUSH
89905: LD_INT 3
89907: NEG
89908: PUSH
89909: EMPTY
89910: LIST
89911: LIST
89912: PUSH
89913: LD_INT 2
89915: PUSH
89916: LD_INT 1
89918: NEG
89919: PUSH
89920: EMPTY
89921: LIST
89922: LIST
89923: PUSH
89924: LD_INT 3
89926: PUSH
89927: LD_INT 1
89929: PUSH
89930: EMPTY
89931: LIST
89932: LIST
89933: PUSH
89934: LD_INT 1
89936: PUSH
89937: LD_INT 3
89939: PUSH
89940: EMPTY
89941: LIST
89942: LIST
89943: PUSH
89944: LD_INT 1
89946: NEG
89947: PUSH
89948: LD_INT 2
89950: PUSH
89951: EMPTY
89952: LIST
89953: LIST
89954: PUSH
89955: LD_INT 3
89957: NEG
89958: PUSH
89959: LD_INT 2
89961: NEG
89962: PUSH
89963: EMPTY
89964: LIST
89965: LIST
89966: PUSH
89967: EMPTY
89968: LIST
89969: LIST
89970: LIST
89971: LIST
89972: LIST
89973: LIST
89974: LIST
89975: LIST
89976: LIST
89977: LIST
89978: LIST
89979: LIST
89980: LIST
89981: LIST
89982: LIST
89983: LIST
89984: LIST
89985: LIST
89986: LIST
89987: LIST
89988: LIST
89989: LIST
89990: LIST
89991: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
89992: LD_ADDR_VAR 0 32
89996: PUSH
89997: LD_INT 0
89999: PUSH
90000: LD_INT 0
90002: PUSH
90003: EMPTY
90004: LIST
90005: LIST
90006: PUSH
90007: LD_INT 0
90009: PUSH
90010: LD_INT 1
90012: NEG
90013: PUSH
90014: EMPTY
90015: LIST
90016: LIST
90017: PUSH
90018: LD_INT 1
90020: PUSH
90021: LD_INT 0
90023: PUSH
90024: EMPTY
90025: LIST
90026: LIST
90027: PUSH
90028: LD_INT 1
90030: PUSH
90031: LD_INT 1
90033: PUSH
90034: EMPTY
90035: LIST
90036: LIST
90037: PUSH
90038: LD_INT 0
90040: PUSH
90041: LD_INT 1
90043: PUSH
90044: EMPTY
90045: LIST
90046: LIST
90047: PUSH
90048: LD_INT 1
90050: NEG
90051: PUSH
90052: LD_INT 0
90054: PUSH
90055: EMPTY
90056: LIST
90057: LIST
90058: PUSH
90059: LD_INT 1
90061: NEG
90062: PUSH
90063: LD_INT 1
90065: NEG
90066: PUSH
90067: EMPTY
90068: LIST
90069: LIST
90070: PUSH
90071: LD_INT 1
90073: NEG
90074: PUSH
90075: LD_INT 2
90077: NEG
90078: PUSH
90079: EMPTY
90080: LIST
90081: LIST
90082: PUSH
90083: LD_INT 0
90085: PUSH
90086: LD_INT 2
90088: NEG
90089: PUSH
90090: EMPTY
90091: LIST
90092: LIST
90093: PUSH
90094: LD_INT 1
90096: PUSH
90097: LD_INT 1
90099: NEG
90100: PUSH
90101: EMPTY
90102: LIST
90103: LIST
90104: PUSH
90105: LD_INT 2
90107: PUSH
90108: LD_INT 1
90110: PUSH
90111: EMPTY
90112: LIST
90113: LIST
90114: PUSH
90115: LD_INT 2
90117: PUSH
90118: LD_INT 2
90120: PUSH
90121: EMPTY
90122: LIST
90123: LIST
90124: PUSH
90125: LD_INT 1
90127: PUSH
90128: LD_INT 2
90130: PUSH
90131: EMPTY
90132: LIST
90133: LIST
90134: PUSH
90135: LD_INT 0
90137: PUSH
90138: LD_INT 2
90140: PUSH
90141: EMPTY
90142: LIST
90143: LIST
90144: PUSH
90145: LD_INT 1
90147: NEG
90148: PUSH
90149: LD_INT 1
90151: PUSH
90152: EMPTY
90153: LIST
90154: LIST
90155: PUSH
90156: LD_INT 2
90158: NEG
90159: PUSH
90160: LD_INT 0
90162: PUSH
90163: EMPTY
90164: LIST
90165: LIST
90166: PUSH
90167: LD_INT 2
90169: NEG
90170: PUSH
90171: LD_INT 1
90173: NEG
90174: PUSH
90175: EMPTY
90176: LIST
90177: LIST
90178: PUSH
90179: LD_INT 1
90181: NEG
90182: PUSH
90183: LD_INT 3
90185: NEG
90186: PUSH
90187: EMPTY
90188: LIST
90189: LIST
90190: PUSH
90191: LD_INT 1
90193: PUSH
90194: LD_INT 2
90196: NEG
90197: PUSH
90198: EMPTY
90199: LIST
90200: LIST
90201: PUSH
90202: LD_INT 3
90204: PUSH
90205: LD_INT 2
90207: PUSH
90208: EMPTY
90209: LIST
90210: LIST
90211: PUSH
90212: LD_INT 2
90214: PUSH
90215: LD_INT 3
90217: PUSH
90218: EMPTY
90219: LIST
90220: LIST
90221: PUSH
90222: LD_INT 2
90224: NEG
90225: PUSH
90226: LD_INT 1
90228: PUSH
90229: EMPTY
90230: LIST
90231: LIST
90232: PUSH
90233: LD_INT 3
90235: NEG
90236: PUSH
90237: LD_INT 1
90239: NEG
90240: PUSH
90241: EMPTY
90242: LIST
90243: LIST
90244: PUSH
90245: EMPTY
90246: LIST
90247: LIST
90248: LIST
90249: LIST
90250: LIST
90251: LIST
90252: LIST
90253: LIST
90254: LIST
90255: LIST
90256: LIST
90257: LIST
90258: LIST
90259: LIST
90260: LIST
90261: LIST
90262: LIST
90263: LIST
90264: LIST
90265: LIST
90266: LIST
90267: LIST
90268: LIST
90269: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
90270: LD_ADDR_VAR 0 33
90274: PUSH
90275: LD_INT 0
90277: PUSH
90278: LD_INT 0
90280: PUSH
90281: EMPTY
90282: LIST
90283: LIST
90284: PUSH
90285: LD_INT 0
90287: PUSH
90288: LD_INT 1
90290: NEG
90291: PUSH
90292: EMPTY
90293: LIST
90294: LIST
90295: PUSH
90296: LD_INT 1
90298: PUSH
90299: LD_INT 0
90301: PUSH
90302: EMPTY
90303: LIST
90304: LIST
90305: PUSH
90306: LD_INT 1
90308: PUSH
90309: LD_INT 1
90311: PUSH
90312: EMPTY
90313: LIST
90314: LIST
90315: PUSH
90316: LD_INT 0
90318: PUSH
90319: LD_INT 1
90321: PUSH
90322: EMPTY
90323: LIST
90324: LIST
90325: PUSH
90326: LD_INT 1
90328: NEG
90329: PUSH
90330: LD_INT 0
90332: PUSH
90333: EMPTY
90334: LIST
90335: LIST
90336: PUSH
90337: LD_INT 1
90339: NEG
90340: PUSH
90341: LD_INT 1
90343: NEG
90344: PUSH
90345: EMPTY
90346: LIST
90347: LIST
90348: PUSH
90349: LD_INT 1
90351: NEG
90352: PUSH
90353: LD_INT 2
90355: NEG
90356: PUSH
90357: EMPTY
90358: LIST
90359: LIST
90360: PUSH
90361: LD_INT 1
90363: PUSH
90364: LD_INT 1
90366: NEG
90367: PUSH
90368: EMPTY
90369: LIST
90370: LIST
90371: PUSH
90372: LD_INT 2
90374: PUSH
90375: LD_INT 0
90377: PUSH
90378: EMPTY
90379: LIST
90380: LIST
90381: PUSH
90382: LD_INT 2
90384: PUSH
90385: LD_INT 1
90387: PUSH
90388: EMPTY
90389: LIST
90390: LIST
90391: PUSH
90392: LD_INT 1
90394: PUSH
90395: LD_INT 2
90397: PUSH
90398: EMPTY
90399: LIST
90400: LIST
90401: PUSH
90402: LD_INT 0
90404: PUSH
90405: LD_INT 2
90407: PUSH
90408: EMPTY
90409: LIST
90410: LIST
90411: PUSH
90412: LD_INT 1
90414: NEG
90415: PUSH
90416: LD_INT 1
90418: PUSH
90419: EMPTY
90420: LIST
90421: LIST
90422: PUSH
90423: LD_INT 2
90425: NEG
90426: PUSH
90427: LD_INT 0
90429: PUSH
90430: EMPTY
90431: LIST
90432: LIST
90433: PUSH
90434: LD_INT 2
90436: NEG
90437: PUSH
90438: LD_INT 1
90440: NEG
90441: PUSH
90442: EMPTY
90443: LIST
90444: LIST
90445: PUSH
90446: LD_INT 2
90448: NEG
90449: PUSH
90450: LD_INT 2
90452: NEG
90453: PUSH
90454: EMPTY
90455: LIST
90456: LIST
90457: PUSH
90458: LD_INT 2
90460: NEG
90461: PUSH
90462: LD_INT 3
90464: NEG
90465: PUSH
90466: EMPTY
90467: LIST
90468: LIST
90469: PUSH
90470: LD_INT 2
90472: PUSH
90473: LD_INT 1
90475: NEG
90476: PUSH
90477: EMPTY
90478: LIST
90479: LIST
90480: PUSH
90481: LD_INT 3
90483: PUSH
90484: LD_INT 1
90486: PUSH
90487: EMPTY
90488: LIST
90489: LIST
90490: PUSH
90491: LD_INT 1
90493: PUSH
90494: LD_INT 3
90496: PUSH
90497: EMPTY
90498: LIST
90499: LIST
90500: PUSH
90501: LD_INT 1
90503: NEG
90504: PUSH
90505: LD_INT 2
90507: PUSH
90508: EMPTY
90509: LIST
90510: LIST
90511: PUSH
90512: LD_INT 3
90514: NEG
90515: PUSH
90516: LD_INT 2
90518: NEG
90519: PUSH
90520: EMPTY
90521: LIST
90522: LIST
90523: PUSH
90524: EMPTY
90525: LIST
90526: LIST
90527: LIST
90528: LIST
90529: LIST
90530: LIST
90531: LIST
90532: LIST
90533: LIST
90534: LIST
90535: LIST
90536: LIST
90537: LIST
90538: LIST
90539: LIST
90540: LIST
90541: LIST
90542: LIST
90543: LIST
90544: LIST
90545: LIST
90546: LIST
90547: LIST
90548: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
90549: LD_ADDR_VAR 0 34
90553: PUSH
90554: LD_INT 0
90556: PUSH
90557: LD_INT 0
90559: PUSH
90560: EMPTY
90561: LIST
90562: LIST
90563: PUSH
90564: LD_INT 0
90566: PUSH
90567: LD_INT 1
90569: NEG
90570: PUSH
90571: EMPTY
90572: LIST
90573: LIST
90574: PUSH
90575: LD_INT 1
90577: PUSH
90578: LD_INT 0
90580: PUSH
90581: EMPTY
90582: LIST
90583: LIST
90584: PUSH
90585: LD_INT 1
90587: PUSH
90588: LD_INT 1
90590: PUSH
90591: EMPTY
90592: LIST
90593: LIST
90594: PUSH
90595: LD_INT 0
90597: PUSH
90598: LD_INT 1
90600: PUSH
90601: EMPTY
90602: LIST
90603: LIST
90604: PUSH
90605: LD_INT 1
90607: NEG
90608: PUSH
90609: LD_INT 0
90611: PUSH
90612: EMPTY
90613: LIST
90614: LIST
90615: PUSH
90616: LD_INT 1
90618: NEG
90619: PUSH
90620: LD_INT 1
90622: NEG
90623: PUSH
90624: EMPTY
90625: LIST
90626: LIST
90627: PUSH
90628: LD_INT 1
90630: NEG
90631: PUSH
90632: LD_INT 2
90634: NEG
90635: PUSH
90636: EMPTY
90637: LIST
90638: LIST
90639: PUSH
90640: LD_INT 0
90642: PUSH
90643: LD_INT 2
90645: NEG
90646: PUSH
90647: EMPTY
90648: LIST
90649: LIST
90650: PUSH
90651: LD_INT 1
90653: PUSH
90654: LD_INT 1
90656: NEG
90657: PUSH
90658: EMPTY
90659: LIST
90660: LIST
90661: PUSH
90662: LD_INT 2
90664: PUSH
90665: LD_INT 1
90667: PUSH
90668: EMPTY
90669: LIST
90670: LIST
90671: PUSH
90672: LD_INT 2
90674: PUSH
90675: LD_INT 2
90677: PUSH
90678: EMPTY
90679: LIST
90680: LIST
90681: PUSH
90682: LD_INT 1
90684: PUSH
90685: LD_INT 2
90687: PUSH
90688: EMPTY
90689: LIST
90690: LIST
90691: PUSH
90692: LD_INT 1
90694: NEG
90695: PUSH
90696: LD_INT 1
90698: PUSH
90699: EMPTY
90700: LIST
90701: LIST
90702: PUSH
90703: LD_INT 2
90705: NEG
90706: PUSH
90707: LD_INT 0
90709: PUSH
90710: EMPTY
90711: LIST
90712: LIST
90713: PUSH
90714: LD_INT 2
90716: NEG
90717: PUSH
90718: LD_INT 1
90720: NEG
90721: PUSH
90722: EMPTY
90723: LIST
90724: LIST
90725: PUSH
90726: LD_INT 2
90728: NEG
90729: PUSH
90730: LD_INT 2
90732: NEG
90733: PUSH
90734: EMPTY
90735: LIST
90736: LIST
90737: PUSH
90738: LD_INT 1
90740: NEG
90741: PUSH
90742: LD_INT 3
90744: NEG
90745: PUSH
90746: EMPTY
90747: LIST
90748: LIST
90749: PUSH
90750: LD_INT 1
90752: PUSH
90753: LD_INT 2
90755: NEG
90756: PUSH
90757: EMPTY
90758: LIST
90759: LIST
90760: PUSH
90761: LD_INT 3
90763: PUSH
90764: LD_INT 2
90766: PUSH
90767: EMPTY
90768: LIST
90769: LIST
90770: PUSH
90771: LD_INT 2
90773: PUSH
90774: LD_INT 3
90776: PUSH
90777: EMPTY
90778: LIST
90779: LIST
90780: PUSH
90781: LD_INT 2
90783: NEG
90784: PUSH
90785: LD_INT 1
90787: PUSH
90788: EMPTY
90789: LIST
90790: LIST
90791: PUSH
90792: LD_INT 3
90794: NEG
90795: PUSH
90796: LD_INT 1
90798: NEG
90799: PUSH
90800: EMPTY
90801: LIST
90802: LIST
90803: PUSH
90804: EMPTY
90805: LIST
90806: LIST
90807: LIST
90808: LIST
90809: LIST
90810: LIST
90811: LIST
90812: LIST
90813: LIST
90814: LIST
90815: LIST
90816: LIST
90817: LIST
90818: LIST
90819: LIST
90820: LIST
90821: LIST
90822: LIST
90823: LIST
90824: LIST
90825: LIST
90826: LIST
90827: LIST
90828: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
90829: LD_ADDR_VAR 0 35
90833: PUSH
90834: LD_INT 0
90836: PUSH
90837: LD_INT 0
90839: PUSH
90840: EMPTY
90841: LIST
90842: LIST
90843: PUSH
90844: LD_INT 0
90846: PUSH
90847: LD_INT 1
90849: NEG
90850: PUSH
90851: EMPTY
90852: LIST
90853: LIST
90854: PUSH
90855: LD_INT 1
90857: PUSH
90858: LD_INT 0
90860: PUSH
90861: EMPTY
90862: LIST
90863: LIST
90864: PUSH
90865: LD_INT 1
90867: PUSH
90868: LD_INT 1
90870: PUSH
90871: EMPTY
90872: LIST
90873: LIST
90874: PUSH
90875: LD_INT 0
90877: PUSH
90878: LD_INT 1
90880: PUSH
90881: EMPTY
90882: LIST
90883: LIST
90884: PUSH
90885: LD_INT 1
90887: NEG
90888: PUSH
90889: LD_INT 0
90891: PUSH
90892: EMPTY
90893: LIST
90894: LIST
90895: PUSH
90896: LD_INT 1
90898: NEG
90899: PUSH
90900: LD_INT 1
90902: NEG
90903: PUSH
90904: EMPTY
90905: LIST
90906: LIST
90907: PUSH
90908: LD_INT 2
90910: PUSH
90911: LD_INT 1
90913: PUSH
90914: EMPTY
90915: LIST
90916: LIST
90917: PUSH
90918: LD_INT 2
90920: NEG
90921: PUSH
90922: LD_INT 1
90924: NEG
90925: PUSH
90926: EMPTY
90927: LIST
90928: LIST
90929: PUSH
90930: EMPTY
90931: LIST
90932: LIST
90933: LIST
90934: LIST
90935: LIST
90936: LIST
90937: LIST
90938: LIST
90939: LIST
90940: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
90941: LD_ADDR_VAR 0 36
90945: PUSH
90946: LD_INT 0
90948: PUSH
90949: LD_INT 0
90951: PUSH
90952: EMPTY
90953: LIST
90954: LIST
90955: PUSH
90956: LD_INT 0
90958: PUSH
90959: LD_INT 1
90961: NEG
90962: PUSH
90963: EMPTY
90964: LIST
90965: LIST
90966: PUSH
90967: LD_INT 1
90969: PUSH
90970: LD_INT 0
90972: PUSH
90973: EMPTY
90974: LIST
90975: LIST
90976: PUSH
90977: LD_INT 1
90979: PUSH
90980: LD_INT 1
90982: PUSH
90983: EMPTY
90984: LIST
90985: LIST
90986: PUSH
90987: LD_INT 0
90989: PUSH
90990: LD_INT 1
90992: PUSH
90993: EMPTY
90994: LIST
90995: LIST
90996: PUSH
90997: LD_INT 1
90999: NEG
91000: PUSH
91001: LD_INT 0
91003: PUSH
91004: EMPTY
91005: LIST
91006: LIST
91007: PUSH
91008: LD_INT 1
91010: NEG
91011: PUSH
91012: LD_INT 1
91014: NEG
91015: PUSH
91016: EMPTY
91017: LIST
91018: LIST
91019: PUSH
91020: LD_INT 1
91022: NEG
91023: PUSH
91024: LD_INT 2
91026: NEG
91027: PUSH
91028: EMPTY
91029: LIST
91030: LIST
91031: PUSH
91032: LD_INT 1
91034: PUSH
91035: LD_INT 2
91037: PUSH
91038: EMPTY
91039: LIST
91040: LIST
91041: PUSH
91042: EMPTY
91043: LIST
91044: LIST
91045: LIST
91046: LIST
91047: LIST
91048: LIST
91049: LIST
91050: LIST
91051: LIST
91052: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
91053: LD_ADDR_VAR 0 37
91057: PUSH
91058: LD_INT 0
91060: PUSH
91061: LD_INT 0
91063: PUSH
91064: EMPTY
91065: LIST
91066: LIST
91067: PUSH
91068: LD_INT 0
91070: PUSH
91071: LD_INT 1
91073: NEG
91074: PUSH
91075: EMPTY
91076: LIST
91077: LIST
91078: PUSH
91079: LD_INT 1
91081: PUSH
91082: LD_INT 0
91084: PUSH
91085: EMPTY
91086: LIST
91087: LIST
91088: PUSH
91089: LD_INT 1
91091: PUSH
91092: LD_INT 1
91094: PUSH
91095: EMPTY
91096: LIST
91097: LIST
91098: PUSH
91099: LD_INT 0
91101: PUSH
91102: LD_INT 1
91104: PUSH
91105: EMPTY
91106: LIST
91107: LIST
91108: PUSH
91109: LD_INT 1
91111: NEG
91112: PUSH
91113: LD_INT 0
91115: PUSH
91116: EMPTY
91117: LIST
91118: LIST
91119: PUSH
91120: LD_INT 1
91122: NEG
91123: PUSH
91124: LD_INT 1
91126: NEG
91127: PUSH
91128: EMPTY
91129: LIST
91130: LIST
91131: PUSH
91132: LD_INT 1
91134: PUSH
91135: LD_INT 1
91137: NEG
91138: PUSH
91139: EMPTY
91140: LIST
91141: LIST
91142: PUSH
91143: LD_INT 1
91145: NEG
91146: PUSH
91147: LD_INT 1
91149: PUSH
91150: EMPTY
91151: LIST
91152: LIST
91153: PUSH
91154: EMPTY
91155: LIST
91156: LIST
91157: LIST
91158: LIST
91159: LIST
91160: LIST
91161: LIST
91162: LIST
91163: LIST
91164: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
91165: LD_ADDR_VAR 0 38
91169: PUSH
91170: LD_INT 0
91172: PUSH
91173: LD_INT 0
91175: PUSH
91176: EMPTY
91177: LIST
91178: LIST
91179: PUSH
91180: LD_INT 0
91182: PUSH
91183: LD_INT 1
91185: NEG
91186: PUSH
91187: EMPTY
91188: LIST
91189: LIST
91190: PUSH
91191: LD_INT 1
91193: PUSH
91194: LD_INT 0
91196: PUSH
91197: EMPTY
91198: LIST
91199: LIST
91200: PUSH
91201: LD_INT 1
91203: PUSH
91204: LD_INT 1
91206: PUSH
91207: EMPTY
91208: LIST
91209: LIST
91210: PUSH
91211: LD_INT 0
91213: PUSH
91214: LD_INT 1
91216: PUSH
91217: EMPTY
91218: LIST
91219: LIST
91220: PUSH
91221: LD_INT 1
91223: NEG
91224: PUSH
91225: LD_INT 0
91227: PUSH
91228: EMPTY
91229: LIST
91230: LIST
91231: PUSH
91232: LD_INT 1
91234: NEG
91235: PUSH
91236: LD_INT 1
91238: NEG
91239: PUSH
91240: EMPTY
91241: LIST
91242: LIST
91243: PUSH
91244: LD_INT 2
91246: PUSH
91247: LD_INT 1
91249: PUSH
91250: EMPTY
91251: LIST
91252: LIST
91253: PUSH
91254: LD_INT 2
91256: NEG
91257: PUSH
91258: LD_INT 1
91260: NEG
91261: PUSH
91262: EMPTY
91263: LIST
91264: LIST
91265: PUSH
91266: EMPTY
91267: LIST
91268: LIST
91269: LIST
91270: LIST
91271: LIST
91272: LIST
91273: LIST
91274: LIST
91275: LIST
91276: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
91277: LD_ADDR_VAR 0 39
91281: PUSH
91282: LD_INT 0
91284: PUSH
91285: LD_INT 0
91287: PUSH
91288: EMPTY
91289: LIST
91290: LIST
91291: PUSH
91292: LD_INT 0
91294: PUSH
91295: LD_INT 1
91297: NEG
91298: PUSH
91299: EMPTY
91300: LIST
91301: LIST
91302: PUSH
91303: LD_INT 1
91305: PUSH
91306: LD_INT 0
91308: PUSH
91309: EMPTY
91310: LIST
91311: LIST
91312: PUSH
91313: LD_INT 1
91315: PUSH
91316: LD_INT 1
91318: PUSH
91319: EMPTY
91320: LIST
91321: LIST
91322: PUSH
91323: LD_INT 0
91325: PUSH
91326: LD_INT 1
91328: PUSH
91329: EMPTY
91330: LIST
91331: LIST
91332: PUSH
91333: LD_INT 1
91335: NEG
91336: PUSH
91337: LD_INT 0
91339: PUSH
91340: EMPTY
91341: LIST
91342: LIST
91343: PUSH
91344: LD_INT 1
91346: NEG
91347: PUSH
91348: LD_INT 1
91350: NEG
91351: PUSH
91352: EMPTY
91353: LIST
91354: LIST
91355: PUSH
91356: LD_INT 1
91358: NEG
91359: PUSH
91360: LD_INT 2
91362: NEG
91363: PUSH
91364: EMPTY
91365: LIST
91366: LIST
91367: PUSH
91368: LD_INT 1
91370: PUSH
91371: LD_INT 2
91373: PUSH
91374: EMPTY
91375: LIST
91376: LIST
91377: PUSH
91378: EMPTY
91379: LIST
91380: LIST
91381: LIST
91382: LIST
91383: LIST
91384: LIST
91385: LIST
91386: LIST
91387: LIST
91388: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
91389: LD_ADDR_VAR 0 40
91393: PUSH
91394: LD_INT 0
91396: PUSH
91397: LD_INT 0
91399: PUSH
91400: EMPTY
91401: LIST
91402: LIST
91403: PUSH
91404: LD_INT 0
91406: PUSH
91407: LD_INT 1
91409: NEG
91410: PUSH
91411: EMPTY
91412: LIST
91413: LIST
91414: PUSH
91415: LD_INT 1
91417: PUSH
91418: LD_INT 0
91420: PUSH
91421: EMPTY
91422: LIST
91423: LIST
91424: PUSH
91425: LD_INT 1
91427: PUSH
91428: LD_INT 1
91430: PUSH
91431: EMPTY
91432: LIST
91433: LIST
91434: PUSH
91435: LD_INT 0
91437: PUSH
91438: LD_INT 1
91440: PUSH
91441: EMPTY
91442: LIST
91443: LIST
91444: PUSH
91445: LD_INT 1
91447: NEG
91448: PUSH
91449: LD_INT 0
91451: PUSH
91452: EMPTY
91453: LIST
91454: LIST
91455: PUSH
91456: LD_INT 1
91458: NEG
91459: PUSH
91460: LD_INT 1
91462: NEG
91463: PUSH
91464: EMPTY
91465: LIST
91466: LIST
91467: PUSH
91468: LD_INT 1
91470: PUSH
91471: LD_INT 1
91473: NEG
91474: PUSH
91475: EMPTY
91476: LIST
91477: LIST
91478: PUSH
91479: LD_INT 1
91481: NEG
91482: PUSH
91483: LD_INT 1
91485: PUSH
91486: EMPTY
91487: LIST
91488: LIST
91489: PUSH
91490: EMPTY
91491: LIST
91492: LIST
91493: LIST
91494: LIST
91495: LIST
91496: LIST
91497: LIST
91498: LIST
91499: LIST
91500: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91501: LD_ADDR_VAR 0 41
91505: PUSH
91506: LD_INT 0
91508: PUSH
91509: LD_INT 0
91511: PUSH
91512: EMPTY
91513: LIST
91514: LIST
91515: PUSH
91516: LD_INT 0
91518: PUSH
91519: LD_INT 1
91521: NEG
91522: PUSH
91523: EMPTY
91524: LIST
91525: LIST
91526: PUSH
91527: LD_INT 1
91529: PUSH
91530: LD_INT 0
91532: PUSH
91533: EMPTY
91534: LIST
91535: LIST
91536: PUSH
91537: LD_INT 1
91539: PUSH
91540: LD_INT 1
91542: PUSH
91543: EMPTY
91544: LIST
91545: LIST
91546: PUSH
91547: LD_INT 0
91549: PUSH
91550: LD_INT 1
91552: PUSH
91553: EMPTY
91554: LIST
91555: LIST
91556: PUSH
91557: LD_INT 1
91559: NEG
91560: PUSH
91561: LD_INT 0
91563: PUSH
91564: EMPTY
91565: LIST
91566: LIST
91567: PUSH
91568: LD_INT 1
91570: NEG
91571: PUSH
91572: LD_INT 1
91574: NEG
91575: PUSH
91576: EMPTY
91577: LIST
91578: LIST
91579: PUSH
91580: LD_INT 1
91582: NEG
91583: PUSH
91584: LD_INT 2
91586: NEG
91587: PUSH
91588: EMPTY
91589: LIST
91590: LIST
91591: PUSH
91592: LD_INT 1
91594: PUSH
91595: LD_INT 1
91597: NEG
91598: PUSH
91599: EMPTY
91600: LIST
91601: LIST
91602: PUSH
91603: LD_INT 2
91605: PUSH
91606: LD_INT 0
91608: PUSH
91609: EMPTY
91610: LIST
91611: LIST
91612: PUSH
91613: LD_INT 2
91615: PUSH
91616: LD_INT 1
91618: PUSH
91619: EMPTY
91620: LIST
91621: LIST
91622: PUSH
91623: LD_INT 2
91625: PUSH
91626: LD_INT 2
91628: PUSH
91629: EMPTY
91630: LIST
91631: LIST
91632: PUSH
91633: LD_INT 1
91635: PUSH
91636: LD_INT 2
91638: PUSH
91639: EMPTY
91640: LIST
91641: LIST
91642: PUSH
91643: LD_INT 1
91645: NEG
91646: PUSH
91647: LD_INT 1
91649: PUSH
91650: EMPTY
91651: LIST
91652: LIST
91653: PUSH
91654: LD_INT 2
91656: NEG
91657: PUSH
91658: LD_INT 0
91660: PUSH
91661: EMPTY
91662: LIST
91663: LIST
91664: PUSH
91665: LD_INT 2
91667: NEG
91668: PUSH
91669: LD_INT 1
91671: NEG
91672: PUSH
91673: EMPTY
91674: LIST
91675: LIST
91676: PUSH
91677: LD_INT 2
91679: NEG
91680: PUSH
91681: LD_INT 2
91683: NEG
91684: PUSH
91685: EMPTY
91686: LIST
91687: LIST
91688: PUSH
91689: LD_INT 2
91691: NEG
91692: PUSH
91693: LD_INT 3
91695: NEG
91696: PUSH
91697: EMPTY
91698: LIST
91699: LIST
91700: PUSH
91701: LD_INT 2
91703: PUSH
91704: LD_INT 1
91706: NEG
91707: PUSH
91708: EMPTY
91709: LIST
91710: LIST
91711: PUSH
91712: LD_INT 3
91714: PUSH
91715: LD_INT 0
91717: PUSH
91718: EMPTY
91719: LIST
91720: LIST
91721: PUSH
91722: LD_INT 3
91724: PUSH
91725: LD_INT 1
91727: PUSH
91728: EMPTY
91729: LIST
91730: LIST
91731: PUSH
91732: LD_INT 3
91734: PUSH
91735: LD_INT 2
91737: PUSH
91738: EMPTY
91739: LIST
91740: LIST
91741: PUSH
91742: LD_INT 3
91744: PUSH
91745: LD_INT 3
91747: PUSH
91748: EMPTY
91749: LIST
91750: LIST
91751: PUSH
91752: LD_INT 2
91754: PUSH
91755: LD_INT 3
91757: PUSH
91758: EMPTY
91759: LIST
91760: LIST
91761: PUSH
91762: LD_INT 2
91764: NEG
91765: PUSH
91766: LD_INT 1
91768: PUSH
91769: EMPTY
91770: LIST
91771: LIST
91772: PUSH
91773: LD_INT 3
91775: NEG
91776: PUSH
91777: LD_INT 0
91779: PUSH
91780: EMPTY
91781: LIST
91782: LIST
91783: PUSH
91784: LD_INT 3
91786: NEG
91787: PUSH
91788: LD_INT 1
91790: NEG
91791: PUSH
91792: EMPTY
91793: LIST
91794: LIST
91795: PUSH
91796: LD_INT 3
91798: NEG
91799: PUSH
91800: LD_INT 2
91802: NEG
91803: PUSH
91804: EMPTY
91805: LIST
91806: LIST
91807: PUSH
91808: LD_INT 3
91810: NEG
91811: PUSH
91812: LD_INT 3
91814: NEG
91815: PUSH
91816: EMPTY
91817: LIST
91818: LIST
91819: PUSH
91820: EMPTY
91821: LIST
91822: LIST
91823: LIST
91824: LIST
91825: LIST
91826: LIST
91827: LIST
91828: LIST
91829: LIST
91830: LIST
91831: LIST
91832: LIST
91833: LIST
91834: LIST
91835: LIST
91836: LIST
91837: LIST
91838: LIST
91839: LIST
91840: LIST
91841: LIST
91842: LIST
91843: LIST
91844: LIST
91845: LIST
91846: LIST
91847: LIST
91848: LIST
91849: LIST
91850: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91851: LD_ADDR_VAR 0 42
91855: PUSH
91856: LD_INT 0
91858: PUSH
91859: LD_INT 0
91861: PUSH
91862: EMPTY
91863: LIST
91864: LIST
91865: PUSH
91866: LD_INT 0
91868: PUSH
91869: LD_INT 1
91871: NEG
91872: PUSH
91873: EMPTY
91874: LIST
91875: LIST
91876: PUSH
91877: LD_INT 1
91879: PUSH
91880: LD_INT 0
91882: PUSH
91883: EMPTY
91884: LIST
91885: LIST
91886: PUSH
91887: LD_INT 1
91889: PUSH
91890: LD_INT 1
91892: PUSH
91893: EMPTY
91894: LIST
91895: LIST
91896: PUSH
91897: LD_INT 0
91899: PUSH
91900: LD_INT 1
91902: PUSH
91903: EMPTY
91904: LIST
91905: LIST
91906: PUSH
91907: LD_INT 1
91909: NEG
91910: PUSH
91911: LD_INT 0
91913: PUSH
91914: EMPTY
91915: LIST
91916: LIST
91917: PUSH
91918: LD_INT 1
91920: NEG
91921: PUSH
91922: LD_INT 1
91924: NEG
91925: PUSH
91926: EMPTY
91927: LIST
91928: LIST
91929: PUSH
91930: LD_INT 1
91932: NEG
91933: PUSH
91934: LD_INT 2
91936: NEG
91937: PUSH
91938: EMPTY
91939: LIST
91940: LIST
91941: PUSH
91942: LD_INT 0
91944: PUSH
91945: LD_INT 2
91947: NEG
91948: PUSH
91949: EMPTY
91950: LIST
91951: LIST
91952: PUSH
91953: LD_INT 1
91955: PUSH
91956: LD_INT 1
91958: NEG
91959: PUSH
91960: EMPTY
91961: LIST
91962: LIST
91963: PUSH
91964: LD_INT 2
91966: PUSH
91967: LD_INT 1
91969: PUSH
91970: EMPTY
91971: LIST
91972: LIST
91973: PUSH
91974: LD_INT 2
91976: PUSH
91977: LD_INT 2
91979: PUSH
91980: EMPTY
91981: LIST
91982: LIST
91983: PUSH
91984: LD_INT 1
91986: PUSH
91987: LD_INT 2
91989: PUSH
91990: EMPTY
91991: LIST
91992: LIST
91993: PUSH
91994: LD_INT 0
91996: PUSH
91997: LD_INT 2
91999: PUSH
92000: EMPTY
92001: LIST
92002: LIST
92003: PUSH
92004: LD_INT 1
92006: NEG
92007: PUSH
92008: LD_INT 1
92010: PUSH
92011: EMPTY
92012: LIST
92013: LIST
92014: PUSH
92015: LD_INT 2
92017: NEG
92018: PUSH
92019: LD_INT 1
92021: NEG
92022: PUSH
92023: EMPTY
92024: LIST
92025: LIST
92026: PUSH
92027: LD_INT 2
92029: NEG
92030: PUSH
92031: LD_INT 2
92033: NEG
92034: PUSH
92035: EMPTY
92036: LIST
92037: LIST
92038: PUSH
92039: LD_INT 2
92041: NEG
92042: PUSH
92043: LD_INT 3
92045: NEG
92046: PUSH
92047: EMPTY
92048: LIST
92049: LIST
92050: PUSH
92051: LD_INT 1
92053: NEG
92054: PUSH
92055: LD_INT 3
92057: NEG
92058: PUSH
92059: EMPTY
92060: LIST
92061: LIST
92062: PUSH
92063: LD_INT 0
92065: PUSH
92066: LD_INT 3
92068: NEG
92069: PUSH
92070: EMPTY
92071: LIST
92072: LIST
92073: PUSH
92074: LD_INT 1
92076: PUSH
92077: LD_INT 2
92079: NEG
92080: PUSH
92081: EMPTY
92082: LIST
92083: LIST
92084: PUSH
92085: LD_INT 3
92087: PUSH
92088: LD_INT 2
92090: PUSH
92091: EMPTY
92092: LIST
92093: LIST
92094: PUSH
92095: LD_INT 3
92097: PUSH
92098: LD_INT 3
92100: PUSH
92101: EMPTY
92102: LIST
92103: LIST
92104: PUSH
92105: LD_INT 2
92107: PUSH
92108: LD_INT 3
92110: PUSH
92111: EMPTY
92112: LIST
92113: LIST
92114: PUSH
92115: LD_INT 1
92117: PUSH
92118: LD_INT 3
92120: PUSH
92121: EMPTY
92122: LIST
92123: LIST
92124: PUSH
92125: LD_INT 0
92127: PUSH
92128: LD_INT 3
92130: PUSH
92131: EMPTY
92132: LIST
92133: LIST
92134: PUSH
92135: LD_INT 1
92137: NEG
92138: PUSH
92139: LD_INT 2
92141: PUSH
92142: EMPTY
92143: LIST
92144: LIST
92145: PUSH
92146: LD_INT 3
92148: NEG
92149: PUSH
92150: LD_INT 2
92152: NEG
92153: PUSH
92154: EMPTY
92155: LIST
92156: LIST
92157: PUSH
92158: LD_INT 3
92160: NEG
92161: PUSH
92162: LD_INT 3
92164: NEG
92165: PUSH
92166: EMPTY
92167: LIST
92168: LIST
92169: PUSH
92170: EMPTY
92171: LIST
92172: LIST
92173: LIST
92174: LIST
92175: LIST
92176: LIST
92177: LIST
92178: LIST
92179: LIST
92180: LIST
92181: LIST
92182: LIST
92183: LIST
92184: LIST
92185: LIST
92186: LIST
92187: LIST
92188: LIST
92189: LIST
92190: LIST
92191: LIST
92192: LIST
92193: LIST
92194: LIST
92195: LIST
92196: LIST
92197: LIST
92198: LIST
92199: LIST
92200: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92201: LD_ADDR_VAR 0 43
92205: PUSH
92206: LD_INT 0
92208: PUSH
92209: LD_INT 0
92211: PUSH
92212: EMPTY
92213: LIST
92214: LIST
92215: PUSH
92216: LD_INT 0
92218: PUSH
92219: LD_INT 1
92221: NEG
92222: PUSH
92223: EMPTY
92224: LIST
92225: LIST
92226: PUSH
92227: LD_INT 1
92229: PUSH
92230: LD_INT 0
92232: PUSH
92233: EMPTY
92234: LIST
92235: LIST
92236: PUSH
92237: LD_INT 1
92239: PUSH
92240: LD_INT 1
92242: PUSH
92243: EMPTY
92244: LIST
92245: LIST
92246: PUSH
92247: LD_INT 0
92249: PUSH
92250: LD_INT 1
92252: PUSH
92253: EMPTY
92254: LIST
92255: LIST
92256: PUSH
92257: LD_INT 1
92259: NEG
92260: PUSH
92261: LD_INT 0
92263: PUSH
92264: EMPTY
92265: LIST
92266: LIST
92267: PUSH
92268: LD_INT 1
92270: NEG
92271: PUSH
92272: LD_INT 1
92274: NEG
92275: PUSH
92276: EMPTY
92277: LIST
92278: LIST
92279: PUSH
92280: LD_INT 1
92282: NEG
92283: PUSH
92284: LD_INT 2
92286: NEG
92287: PUSH
92288: EMPTY
92289: LIST
92290: LIST
92291: PUSH
92292: LD_INT 0
92294: PUSH
92295: LD_INT 2
92297: NEG
92298: PUSH
92299: EMPTY
92300: LIST
92301: LIST
92302: PUSH
92303: LD_INT 1
92305: PUSH
92306: LD_INT 1
92308: NEG
92309: PUSH
92310: EMPTY
92311: LIST
92312: LIST
92313: PUSH
92314: LD_INT 2
92316: PUSH
92317: LD_INT 0
92319: PUSH
92320: EMPTY
92321: LIST
92322: LIST
92323: PUSH
92324: LD_INT 2
92326: PUSH
92327: LD_INT 1
92329: PUSH
92330: EMPTY
92331: LIST
92332: LIST
92333: PUSH
92334: LD_INT 1
92336: PUSH
92337: LD_INT 2
92339: PUSH
92340: EMPTY
92341: LIST
92342: LIST
92343: PUSH
92344: LD_INT 0
92346: PUSH
92347: LD_INT 2
92349: PUSH
92350: EMPTY
92351: LIST
92352: LIST
92353: PUSH
92354: LD_INT 1
92356: NEG
92357: PUSH
92358: LD_INT 1
92360: PUSH
92361: EMPTY
92362: LIST
92363: LIST
92364: PUSH
92365: LD_INT 2
92367: NEG
92368: PUSH
92369: LD_INT 0
92371: PUSH
92372: EMPTY
92373: LIST
92374: LIST
92375: PUSH
92376: LD_INT 2
92378: NEG
92379: PUSH
92380: LD_INT 1
92382: NEG
92383: PUSH
92384: EMPTY
92385: LIST
92386: LIST
92387: PUSH
92388: LD_INT 1
92390: NEG
92391: PUSH
92392: LD_INT 3
92394: NEG
92395: PUSH
92396: EMPTY
92397: LIST
92398: LIST
92399: PUSH
92400: LD_INT 0
92402: PUSH
92403: LD_INT 3
92405: NEG
92406: PUSH
92407: EMPTY
92408: LIST
92409: LIST
92410: PUSH
92411: LD_INT 1
92413: PUSH
92414: LD_INT 2
92416: NEG
92417: PUSH
92418: EMPTY
92419: LIST
92420: LIST
92421: PUSH
92422: LD_INT 2
92424: PUSH
92425: LD_INT 1
92427: NEG
92428: PUSH
92429: EMPTY
92430: LIST
92431: LIST
92432: PUSH
92433: LD_INT 3
92435: PUSH
92436: LD_INT 0
92438: PUSH
92439: EMPTY
92440: LIST
92441: LIST
92442: PUSH
92443: LD_INT 3
92445: PUSH
92446: LD_INT 1
92448: PUSH
92449: EMPTY
92450: LIST
92451: LIST
92452: PUSH
92453: LD_INT 1
92455: PUSH
92456: LD_INT 3
92458: PUSH
92459: EMPTY
92460: LIST
92461: LIST
92462: PUSH
92463: LD_INT 0
92465: PUSH
92466: LD_INT 3
92468: PUSH
92469: EMPTY
92470: LIST
92471: LIST
92472: PUSH
92473: LD_INT 1
92475: NEG
92476: PUSH
92477: LD_INT 2
92479: PUSH
92480: EMPTY
92481: LIST
92482: LIST
92483: PUSH
92484: LD_INT 2
92486: NEG
92487: PUSH
92488: LD_INT 1
92490: PUSH
92491: EMPTY
92492: LIST
92493: LIST
92494: PUSH
92495: LD_INT 3
92497: NEG
92498: PUSH
92499: LD_INT 0
92501: PUSH
92502: EMPTY
92503: LIST
92504: LIST
92505: PUSH
92506: LD_INT 3
92508: NEG
92509: PUSH
92510: LD_INT 1
92512: NEG
92513: PUSH
92514: EMPTY
92515: LIST
92516: LIST
92517: PUSH
92518: EMPTY
92519: LIST
92520: LIST
92521: LIST
92522: LIST
92523: LIST
92524: LIST
92525: LIST
92526: LIST
92527: LIST
92528: LIST
92529: LIST
92530: LIST
92531: LIST
92532: LIST
92533: LIST
92534: LIST
92535: LIST
92536: LIST
92537: LIST
92538: LIST
92539: LIST
92540: LIST
92541: LIST
92542: LIST
92543: LIST
92544: LIST
92545: LIST
92546: LIST
92547: LIST
92548: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92549: LD_ADDR_VAR 0 44
92553: PUSH
92554: LD_INT 0
92556: PUSH
92557: LD_INT 0
92559: PUSH
92560: EMPTY
92561: LIST
92562: LIST
92563: PUSH
92564: LD_INT 0
92566: PUSH
92567: LD_INT 1
92569: NEG
92570: PUSH
92571: EMPTY
92572: LIST
92573: LIST
92574: PUSH
92575: LD_INT 1
92577: PUSH
92578: LD_INT 0
92580: PUSH
92581: EMPTY
92582: LIST
92583: LIST
92584: PUSH
92585: LD_INT 1
92587: PUSH
92588: LD_INT 1
92590: PUSH
92591: EMPTY
92592: LIST
92593: LIST
92594: PUSH
92595: LD_INT 0
92597: PUSH
92598: LD_INT 1
92600: PUSH
92601: EMPTY
92602: LIST
92603: LIST
92604: PUSH
92605: LD_INT 1
92607: NEG
92608: PUSH
92609: LD_INT 0
92611: PUSH
92612: EMPTY
92613: LIST
92614: LIST
92615: PUSH
92616: LD_INT 1
92618: NEG
92619: PUSH
92620: LD_INT 1
92622: NEG
92623: PUSH
92624: EMPTY
92625: LIST
92626: LIST
92627: PUSH
92628: LD_INT 1
92630: NEG
92631: PUSH
92632: LD_INT 2
92634: NEG
92635: PUSH
92636: EMPTY
92637: LIST
92638: LIST
92639: PUSH
92640: LD_INT 1
92642: PUSH
92643: LD_INT 1
92645: NEG
92646: PUSH
92647: EMPTY
92648: LIST
92649: LIST
92650: PUSH
92651: LD_INT 2
92653: PUSH
92654: LD_INT 0
92656: PUSH
92657: EMPTY
92658: LIST
92659: LIST
92660: PUSH
92661: LD_INT 2
92663: PUSH
92664: LD_INT 1
92666: PUSH
92667: EMPTY
92668: LIST
92669: LIST
92670: PUSH
92671: LD_INT 2
92673: PUSH
92674: LD_INT 2
92676: PUSH
92677: EMPTY
92678: LIST
92679: LIST
92680: PUSH
92681: LD_INT 1
92683: PUSH
92684: LD_INT 2
92686: PUSH
92687: EMPTY
92688: LIST
92689: LIST
92690: PUSH
92691: LD_INT 1
92693: NEG
92694: PUSH
92695: LD_INT 1
92697: PUSH
92698: EMPTY
92699: LIST
92700: LIST
92701: PUSH
92702: LD_INT 2
92704: NEG
92705: PUSH
92706: LD_INT 0
92708: PUSH
92709: EMPTY
92710: LIST
92711: LIST
92712: PUSH
92713: LD_INT 2
92715: NEG
92716: PUSH
92717: LD_INT 1
92719: NEG
92720: PUSH
92721: EMPTY
92722: LIST
92723: LIST
92724: PUSH
92725: LD_INT 2
92727: NEG
92728: PUSH
92729: LD_INT 2
92731: NEG
92732: PUSH
92733: EMPTY
92734: LIST
92735: LIST
92736: PUSH
92737: LD_INT 2
92739: NEG
92740: PUSH
92741: LD_INT 3
92743: NEG
92744: PUSH
92745: EMPTY
92746: LIST
92747: LIST
92748: PUSH
92749: LD_INT 2
92751: PUSH
92752: LD_INT 1
92754: NEG
92755: PUSH
92756: EMPTY
92757: LIST
92758: LIST
92759: PUSH
92760: LD_INT 3
92762: PUSH
92763: LD_INT 0
92765: PUSH
92766: EMPTY
92767: LIST
92768: LIST
92769: PUSH
92770: LD_INT 3
92772: PUSH
92773: LD_INT 1
92775: PUSH
92776: EMPTY
92777: LIST
92778: LIST
92779: PUSH
92780: LD_INT 3
92782: PUSH
92783: LD_INT 2
92785: PUSH
92786: EMPTY
92787: LIST
92788: LIST
92789: PUSH
92790: LD_INT 3
92792: PUSH
92793: LD_INT 3
92795: PUSH
92796: EMPTY
92797: LIST
92798: LIST
92799: PUSH
92800: LD_INT 2
92802: PUSH
92803: LD_INT 3
92805: PUSH
92806: EMPTY
92807: LIST
92808: LIST
92809: PUSH
92810: LD_INT 2
92812: NEG
92813: PUSH
92814: LD_INT 1
92816: PUSH
92817: EMPTY
92818: LIST
92819: LIST
92820: PUSH
92821: LD_INT 3
92823: NEG
92824: PUSH
92825: LD_INT 0
92827: PUSH
92828: EMPTY
92829: LIST
92830: LIST
92831: PUSH
92832: LD_INT 3
92834: NEG
92835: PUSH
92836: LD_INT 1
92838: NEG
92839: PUSH
92840: EMPTY
92841: LIST
92842: LIST
92843: PUSH
92844: LD_INT 3
92846: NEG
92847: PUSH
92848: LD_INT 2
92850: NEG
92851: PUSH
92852: EMPTY
92853: LIST
92854: LIST
92855: PUSH
92856: LD_INT 3
92858: NEG
92859: PUSH
92860: LD_INT 3
92862: NEG
92863: PUSH
92864: EMPTY
92865: LIST
92866: LIST
92867: PUSH
92868: EMPTY
92869: LIST
92870: LIST
92871: LIST
92872: LIST
92873: LIST
92874: LIST
92875: LIST
92876: LIST
92877: LIST
92878: LIST
92879: LIST
92880: LIST
92881: LIST
92882: LIST
92883: LIST
92884: LIST
92885: LIST
92886: LIST
92887: LIST
92888: LIST
92889: LIST
92890: LIST
92891: LIST
92892: LIST
92893: LIST
92894: LIST
92895: LIST
92896: LIST
92897: LIST
92898: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92899: LD_ADDR_VAR 0 45
92903: PUSH
92904: LD_INT 0
92906: PUSH
92907: LD_INT 0
92909: PUSH
92910: EMPTY
92911: LIST
92912: LIST
92913: PUSH
92914: LD_INT 0
92916: PUSH
92917: LD_INT 1
92919: NEG
92920: PUSH
92921: EMPTY
92922: LIST
92923: LIST
92924: PUSH
92925: LD_INT 1
92927: PUSH
92928: LD_INT 0
92930: PUSH
92931: EMPTY
92932: LIST
92933: LIST
92934: PUSH
92935: LD_INT 1
92937: PUSH
92938: LD_INT 1
92940: PUSH
92941: EMPTY
92942: LIST
92943: LIST
92944: PUSH
92945: LD_INT 0
92947: PUSH
92948: LD_INT 1
92950: PUSH
92951: EMPTY
92952: LIST
92953: LIST
92954: PUSH
92955: LD_INT 1
92957: NEG
92958: PUSH
92959: LD_INT 0
92961: PUSH
92962: EMPTY
92963: LIST
92964: LIST
92965: PUSH
92966: LD_INT 1
92968: NEG
92969: PUSH
92970: LD_INT 1
92972: NEG
92973: PUSH
92974: EMPTY
92975: LIST
92976: LIST
92977: PUSH
92978: LD_INT 1
92980: NEG
92981: PUSH
92982: LD_INT 2
92984: NEG
92985: PUSH
92986: EMPTY
92987: LIST
92988: LIST
92989: PUSH
92990: LD_INT 0
92992: PUSH
92993: LD_INT 2
92995: NEG
92996: PUSH
92997: EMPTY
92998: LIST
92999: LIST
93000: PUSH
93001: LD_INT 1
93003: PUSH
93004: LD_INT 1
93006: NEG
93007: PUSH
93008: EMPTY
93009: LIST
93010: LIST
93011: PUSH
93012: LD_INT 2
93014: PUSH
93015: LD_INT 1
93017: PUSH
93018: EMPTY
93019: LIST
93020: LIST
93021: PUSH
93022: LD_INT 2
93024: PUSH
93025: LD_INT 2
93027: PUSH
93028: EMPTY
93029: LIST
93030: LIST
93031: PUSH
93032: LD_INT 1
93034: PUSH
93035: LD_INT 2
93037: PUSH
93038: EMPTY
93039: LIST
93040: LIST
93041: PUSH
93042: LD_INT 0
93044: PUSH
93045: LD_INT 2
93047: PUSH
93048: EMPTY
93049: LIST
93050: LIST
93051: PUSH
93052: LD_INT 1
93054: NEG
93055: PUSH
93056: LD_INT 1
93058: PUSH
93059: EMPTY
93060: LIST
93061: LIST
93062: PUSH
93063: LD_INT 2
93065: NEG
93066: PUSH
93067: LD_INT 1
93069: NEG
93070: PUSH
93071: EMPTY
93072: LIST
93073: LIST
93074: PUSH
93075: LD_INT 2
93077: NEG
93078: PUSH
93079: LD_INT 2
93081: NEG
93082: PUSH
93083: EMPTY
93084: LIST
93085: LIST
93086: PUSH
93087: LD_INT 2
93089: NEG
93090: PUSH
93091: LD_INT 3
93093: NEG
93094: PUSH
93095: EMPTY
93096: LIST
93097: LIST
93098: PUSH
93099: LD_INT 1
93101: NEG
93102: PUSH
93103: LD_INT 3
93105: NEG
93106: PUSH
93107: EMPTY
93108: LIST
93109: LIST
93110: PUSH
93111: LD_INT 0
93113: PUSH
93114: LD_INT 3
93116: NEG
93117: PUSH
93118: EMPTY
93119: LIST
93120: LIST
93121: PUSH
93122: LD_INT 1
93124: PUSH
93125: LD_INT 2
93127: NEG
93128: PUSH
93129: EMPTY
93130: LIST
93131: LIST
93132: PUSH
93133: LD_INT 3
93135: PUSH
93136: LD_INT 2
93138: PUSH
93139: EMPTY
93140: LIST
93141: LIST
93142: PUSH
93143: LD_INT 3
93145: PUSH
93146: LD_INT 3
93148: PUSH
93149: EMPTY
93150: LIST
93151: LIST
93152: PUSH
93153: LD_INT 2
93155: PUSH
93156: LD_INT 3
93158: PUSH
93159: EMPTY
93160: LIST
93161: LIST
93162: PUSH
93163: LD_INT 1
93165: PUSH
93166: LD_INT 3
93168: PUSH
93169: EMPTY
93170: LIST
93171: LIST
93172: PUSH
93173: LD_INT 0
93175: PUSH
93176: LD_INT 3
93178: PUSH
93179: EMPTY
93180: LIST
93181: LIST
93182: PUSH
93183: LD_INT 1
93185: NEG
93186: PUSH
93187: LD_INT 2
93189: PUSH
93190: EMPTY
93191: LIST
93192: LIST
93193: PUSH
93194: LD_INT 3
93196: NEG
93197: PUSH
93198: LD_INT 2
93200: NEG
93201: PUSH
93202: EMPTY
93203: LIST
93204: LIST
93205: PUSH
93206: LD_INT 3
93208: NEG
93209: PUSH
93210: LD_INT 3
93212: NEG
93213: PUSH
93214: EMPTY
93215: LIST
93216: LIST
93217: PUSH
93218: EMPTY
93219: LIST
93220: LIST
93221: LIST
93222: LIST
93223: LIST
93224: LIST
93225: LIST
93226: LIST
93227: LIST
93228: LIST
93229: LIST
93230: LIST
93231: LIST
93232: LIST
93233: LIST
93234: LIST
93235: LIST
93236: LIST
93237: LIST
93238: LIST
93239: LIST
93240: LIST
93241: LIST
93242: LIST
93243: LIST
93244: LIST
93245: LIST
93246: LIST
93247: LIST
93248: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93249: LD_ADDR_VAR 0 46
93253: PUSH
93254: LD_INT 0
93256: PUSH
93257: LD_INT 0
93259: PUSH
93260: EMPTY
93261: LIST
93262: LIST
93263: PUSH
93264: LD_INT 0
93266: PUSH
93267: LD_INT 1
93269: NEG
93270: PUSH
93271: EMPTY
93272: LIST
93273: LIST
93274: PUSH
93275: LD_INT 1
93277: PUSH
93278: LD_INT 0
93280: PUSH
93281: EMPTY
93282: LIST
93283: LIST
93284: PUSH
93285: LD_INT 1
93287: PUSH
93288: LD_INT 1
93290: PUSH
93291: EMPTY
93292: LIST
93293: LIST
93294: PUSH
93295: LD_INT 0
93297: PUSH
93298: LD_INT 1
93300: PUSH
93301: EMPTY
93302: LIST
93303: LIST
93304: PUSH
93305: LD_INT 1
93307: NEG
93308: PUSH
93309: LD_INT 0
93311: PUSH
93312: EMPTY
93313: LIST
93314: LIST
93315: PUSH
93316: LD_INT 1
93318: NEG
93319: PUSH
93320: LD_INT 1
93322: NEG
93323: PUSH
93324: EMPTY
93325: LIST
93326: LIST
93327: PUSH
93328: LD_INT 1
93330: NEG
93331: PUSH
93332: LD_INT 2
93334: NEG
93335: PUSH
93336: EMPTY
93337: LIST
93338: LIST
93339: PUSH
93340: LD_INT 0
93342: PUSH
93343: LD_INT 2
93345: NEG
93346: PUSH
93347: EMPTY
93348: LIST
93349: LIST
93350: PUSH
93351: LD_INT 1
93353: PUSH
93354: LD_INT 1
93356: NEG
93357: PUSH
93358: EMPTY
93359: LIST
93360: LIST
93361: PUSH
93362: LD_INT 2
93364: PUSH
93365: LD_INT 0
93367: PUSH
93368: EMPTY
93369: LIST
93370: LIST
93371: PUSH
93372: LD_INT 2
93374: PUSH
93375: LD_INT 1
93377: PUSH
93378: EMPTY
93379: LIST
93380: LIST
93381: PUSH
93382: LD_INT 1
93384: PUSH
93385: LD_INT 2
93387: PUSH
93388: EMPTY
93389: LIST
93390: LIST
93391: PUSH
93392: LD_INT 0
93394: PUSH
93395: LD_INT 2
93397: PUSH
93398: EMPTY
93399: LIST
93400: LIST
93401: PUSH
93402: LD_INT 1
93404: NEG
93405: PUSH
93406: LD_INT 1
93408: PUSH
93409: EMPTY
93410: LIST
93411: LIST
93412: PUSH
93413: LD_INT 2
93415: NEG
93416: PUSH
93417: LD_INT 0
93419: PUSH
93420: EMPTY
93421: LIST
93422: LIST
93423: PUSH
93424: LD_INT 2
93426: NEG
93427: PUSH
93428: LD_INT 1
93430: NEG
93431: PUSH
93432: EMPTY
93433: LIST
93434: LIST
93435: PUSH
93436: LD_INT 1
93438: NEG
93439: PUSH
93440: LD_INT 3
93442: NEG
93443: PUSH
93444: EMPTY
93445: LIST
93446: LIST
93447: PUSH
93448: LD_INT 0
93450: PUSH
93451: LD_INT 3
93453: NEG
93454: PUSH
93455: EMPTY
93456: LIST
93457: LIST
93458: PUSH
93459: LD_INT 1
93461: PUSH
93462: LD_INT 2
93464: NEG
93465: PUSH
93466: EMPTY
93467: LIST
93468: LIST
93469: PUSH
93470: LD_INT 2
93472: PUSH
93473: LD_INT 1
93475: NEG
93476: PUSH
93477: EMPTY
93478: LIST
93479: LIST
93480: PUSH
93481: LD_INT 3
93483: PUSH
93484: LD_INT 0
93486: PUSH
93487: EMPTY
93488: LIST
93489: LIST
93490: PUSH
93491: LD_INT 3
93493: PUSH
93494: LD_INT 1
93496: PUSH
93497: EMPTY
93498: LIST
93499: LIST
93500: PUSH
93501: LD_INT 1
93503: PUSH
93504: LD_INT 3
93506: PUSH
93507: EMPTY
93508: LIST
93509: LIST
93510: PUSH
93511: LD_INT 0
93513: PUSH
93514: LD_INT 3
93516: PUSH
93517: EMPTY
93518: LIST
93519: LIST
93520: PUSH
93521: LD_INT 1
93523: NEG
93524: PUSH
93525: LD_INT 2
93527: PUSH
93528: EMPTY
93529: LIST
93530: LIST
93531: PUSH
93532: LD_INT 2
93534: NEG
93535: PUSH
93536: LD_INT 1
93538: PUSH
93539: EMPTY
93540: LIST
93541: LIST
93542: PUSH
93543: LD_INT 3
93545: NEG
93546: PUSH
93547: LD_INT 0
93549: PUSH
93550: EMPTY
93551: LIST
93552: LIST
93553: PUSH
93554: LD_INT 3
93556: NEG
93557: PUSH
93558: LD_INT 1
93560: NEG
93561: PUSH
93562: EMPTY
93563: LIST
93564: LIST
93565: PUSH
93566: EMPTY
93567: LIST
93568: LIST
93569: LIST
93570: LIST
93571: LIST
93572: LIST
93573: LIST
93574: LIST
93575: LIST
93576: LIST
93577: LIST
93578: LIST
93579: LIST
93580: LIST
93581: LIST
93582: LIST
93583: LIST
93584: LIST
93585: LIST
93586: LIST
93587: LIST
93588: LIST
93589: LIST
93590: LIST
93591: LIST
93592: LIST
93593: LIST
93594: LIST
93595: LIST
93596: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93597: LD_ADDR_VAR 0 47
93601: PUSH
93602: LD_INT 0
93604: PUSH
93605: LD_INT 0
93607: PUSH
93608: EMPTY
93609: LIST
93610: LIST
93611: PUSH
93612: LD_INT 0
93614: PUSH
93615: LD_INT 1
93617: NEG
93618: PUSH
93619: EMPTY
93620: LIST
93621: LIST
93622: PUSH
93623: LD_INT 1
93625: PUSH
93626: LD_INT 0
93628: PUSH
93629: EMPTY
93630: LIST
93631: LIST
93632: PUSH
93633: LD_INT 1
93635: PUSH
93636: LD_INT 1
93638: PUSH
93639: EMPTY
93640: LIST
93641: LIST
93642: PUSH
93643: LD_INT 0
93645: PUSH
93646: LD_INT 1
93648: PUSH
93649: EMPTY
93650: LIST
93651: LIST
93652: PUSH
93653: LD_INT 1
93655: NEG
93656: PUSH
93657: LD_INT 0
93659: PUSH
93660: EMPTY
93661: LIST
93662: LIST
93663: PUSH
93664: LD_INT 1
93666: NEG
93667: PUSH
93668: LD_INT 1
93670: NEG
93671: PUSH
93672: EMPTY
93673: LIST
93674: LIST
93675: PUSH
93676: LD_INT 1
93678: NEG
93679: PUSH
93680: LD_INT 2
93682: NEG
93683: PUSH
93684: EMPTY
93685: LIST
93686: LIST
93687: PUSH
93688: LD_INT 0
93690: PUSH
93691: LD_INT 2
93693: NEG
93694: PUSH
93695: EMPTY
93696: LIST
93697: LIST
93698: PUSH
93699: LD_INT 1
93701: PUSH
93702: LD_INT 1
93704: NEG
93705: PUSH
93706: EMPTY
93707: LIST
93708: LIST
93709: PUSH
93710: LD_INT 2
93712: NEG
93713: PUSH
93714: LD_INT 1
93716: NEG
93717: PUSH
93718: EMPTY
93719: LIST
93720: LIST
93721: PUSH
93722: LD_INT 2
93724: NEG
93725: PUSH
93726: LD_INT 2
93728: NEG
93729: PUSH
93730: EMPTY
93731: LIST
93732: LIST
93733: PUSH
93734: EMPTY
93735: LIST
93736: LIST
93737: LIST
93738: LIST
93739: LIST
93740: LIST
93741: LIST
93742: LIST
93743: LIST
93744: LIST
93745: LIST
93746: LIST
93747: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
93748: LD_ADDR_VAR 0 48
93752: PUSH
93753: LD_INT 0
93755: PUSH
93756: LD_INT 0
93758: PUSH
93759: EMPTY
93760: LIST
93761: LIST
93762: PUSH
93763: LD_INT 0
93765: PUSH
93766: LD_INT 1
93768: NEG
93769: PUSH
93770: EMPTY
93771: LIST
93772: LIST
93773: PUSH
93774: LD_INT 1
93776: PUSH
93777: LD_INT 0
93779: PUSH
93780: EMPTY
93781: LIST
93782: LIST
93783: PUSH
93784: LD_INT 1
93786: PUSH
93787: LD_INT 1
93789: PUSH
93790: EMPTY
93791: LIST
93792: LIST
93793: PUSH
93794: LD_INT 0
93796: PUSH
93797: LD_INT 1
93799: PUSH
93800: EMPTY
93801: LIST
93802: LIST
93803: PUSH
93804: LD_INT 1
93806: NEG
93807: PUSH
93808: LD_INT 0
93810: PUSH
93811: EMPTY
93812: LIST
93813: LIST
93814: PUSH
93815: LD_INT 1
93817: NEG
93818: PUSH
93819: LD_INT 1
93821: NEG
93822: PUSH
93823: EMPTY
93824: LIST
93825: LIST
93826: PUSH
93827: LD_INT 1
93829: NEG
93830: PUSH
93831: LD_INT 2
93833: NEG
93834: PUSH
93835: EMPTY
93836: LIST
93837: LIST
93838: PUSH
93839: LD_INT 0
93841: PUSH
93842: LD_INT 2
93844: NEG
93845: PUSH
93846: EMPTY
93847: LIST
93848: LIST
93849: PUSH
93850: LD_INT 1
93852: PUSH
93853: LD_INT 1
93855: NEG
93856: PUSH
93857: EMPTY
93858: LIST
93859: LIST
93860: PUSH
93861: LD_INT 2
93863: PUSH
93864: LD_INT 0
93866: PUSH
93867: EMPTY
93868: LIST
93869: LIST
93870: PUSH
93871: LD_INT 2
93873: PUSH
93874: LD_INT 1
93876: PUSH
93877: EMPTY
93878: LIST
93879: LIST
93880: PUSH
93881: EMPTY
93882: LIST
93883: LIST
93884: LIST
93885: LIST
93886: LIST
93887: LIST
93888: LIST
93889: LIST
93890: LIST
93891: LIST
93892: LIST
93893: LIST
93894: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
93895: LD_ADDR_VAR 0 49
93899: PUSH
93900: LD_INT 0
93902: PUSH
93903: LD_INT 0
93905: PUSH
93906: EMPTY
93907: LIST
93908: LIST
93909: PUSH
93910: LD_INT 0
93912: PUSH
93913: LD_INT 1
93915: NEG
93916: PUSH
93917: EMPTY
93918: LIST
93919: LIST
93920: PUSH
93921: LD_INT 1
93923: PUSH
93924: LD_INT 0
93926: PUSH
93927: EMPTY
93928: LIST
93929: LIST
93930: PUSH
93931: LD_INT 1
93933: PUSH
93934: LD_INT 1
93936: PUSH
93937: EMPTY
93938: LIST
93939: LIST
93940: PUSH
93941: LD_INT 0
93943: PUSH
93944: LD_INT 1
93946: PUSH
93947: EMPTY
93948: LIST
93949: LIST
93950: PUSH
93951: LD_INT 1
93953: NEG
93954: PUSH
93955: LD_INT 0
93957: PUSH
93958: EMPTY
93959: LIST
93960: LIST
93961: PUSH
93962: LD_INT 1
93964: NEG
93965: PUSH
93966: LD_INT 1
93968: NEG
93969: PUSH
93970: EMPTY
93971: LIST
93972: LIST
93973: PUSH
93974: LD_INT 1
93976: PUSH
93977: LD_INT 1
93979: NEG
93980: PUSH
93981: EMPTY
93982: LIST
93983: LIST
93984: PUSH
93985: LD_INT 2
93987: PUSH
93988: LD_INT 0
93990: PUSH
93991: EMPTY
93992: LIST
93993: LIST
93994: PUSH
93995: LD_INT 2
93997: PUSH
93998: LD_INT 1
94000: PUSH
94001: EMPTY
94002: LIST
94003: LIST
94004: PUSH
94005: LD_INT 2
94007: PUSH
94008: LD_INT 2
94010: PUSH
94011: EMPTY
94012: LIST
94013: LIST
94014: PUSH
94015: LD_INT 1
94017: PUSH
94018: LD_INT 2
94020: PUSH
94021: EMPTY
94022: LIST
94023: LIST
94024: PUSH
94025: EMPTY
94026: LIST
94027: LIST
94028: LIST
94029: LIST
94030: LIST
94031: LIST
94032: LIST
94033: LIST
94034: LIST
94035: LIST
94036: LIST
94037: LIST
94038: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94039: LD_ADDR_VAR 0 50
94043: PUSH
94044: LD_INT 0
94046: PUSH
94047: LD_INT 0
94049: PUSH
94050: EMPTY
94051: LIST
94052: LIST
94053: PUSH
94054: LD_INT 0
94056: PUSH
94057: LD_INT 1
94059: NEG
94060: PUSH
94061: EMPTY
94062: LIST
94063: LIST
94064: PUSH
94065: LD_INT 1
94067: PUSH
94068: LD_INT 0
94070: PUSH
94071: EMPTY
94072: LIST
94073: LIST
94074: PUSH
94075: LD_INT 1
94077: PUSH
94078: LD_INT 1
94080: PUSH
94081: EMPTY
94082: LIST
94083: LIST
94084: PUSH
94085: LD_INT 0
94087: PUSH
94088: LD_INT 1
94090: PUSH
94091: EMPTY
94092: LIST
94093: LIST
94094: PUSH
94095: LD_INT 1
94097: NEG
94098: PUSH
94099: LD_INT 0
94101: PUSH
94102: EMPTY
94103: LIST
94104: LIST
94105: PUSH
94106: LD_INT 1
94108: NEG
94109: PUSH
94110: LD_INT 1
94112: NEG
94113: PUSH
94114: EMPTY
94115: LIST
94116: LIST
94117: PUSH
94118: LD_INT 2
94120: PUSH
94121: LD_INT 1
94123: PUSH
94124: EMPTY
94125: LIST
94126: LIST
94127: PUSH
94128: LD_INT 2
94130: PUSH
94131: LD_INT 2
94133: PUSH
94134: EMPTY
94135: LIST
94136: LIST
94137: PUSH
94138: LD_INT 1
94140: PUSH
94141: LD_INT 2
94143: PUSH
94144: EMPTY
94145: LIST
94146: LIST
94147: PUSH
94148: LD_INT 0
94150: PUSH
94151: LD_INT 2
94153: PUSH
94154: EMPTY
94155: LIST
94156: LIST
94157: PUSH
94158: LD_INT 1
94160: NEG
94161: PUSH
94162: LD_INT 1
94164: PUSH
94165: EMPTY
94166: LIST
94167: LIST
94168: PUSH
94169: EMPTY
94170: LIST
94171: LIST
94172: LIST
94173: LIST
94174: LIST
94175: LIST
94176: LIST
94177: LIST
94178: LIST
94179: LIST
94180: LIST
94181: LIST
94182: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94183: LD_ADDR_VAR 0 51
94187: PUSH
94188: LD_INT 0
94190: PUSH
94191: LD_INT 0
94193: PUSH
94194: EMPTY
94195: LIST
94196: LIST
94197: PUSH
94198: LD_INT 0
94200: PUSH
94201: LD_INT 1
94203: NEG
94204: PUSH
94205: EMPTY
94206: LIST
94207: LIST
94208: PUSH
94209: LD_INT 1
94211: PUSH
94212: LD_INT 0
94214: PUSH
94215: EMPTY
94216: LIST
94217: LIST
94218: PUSH
94219: LD_INT 1
94221: PUSH
94222: LD_INT 1
94224: PUSH
94225: EMPTY
94226: LIST
94227: LIST
94228: PUSH
94229: LD_INT 0
94231: PUSH
94232: LD_INT 1
94234: PUSH
94235: EMPTY
94236: LIST
94237: LIST
94238: PUSH
94239: LD_INT 1
94241: NEG
94242: PUSH
94243: LD_INT 0
94245: PUSH
94246: EMPTY
94247: LIST
94248: LIST
94249: PUSH
94250: LD_INT 1
94252: NEG
94253: PUSH
94254: LD_INT 1
94256: NEG
94257: PUSH
94258: EMPTY
94259: LIST
94260: LIST
94261: PUSH
94262: LD_INT 1
94264: PUSH
94265: LD_INT 2
94267: PUSH
94268: EMPTY
94269: LIST
94270: LIST
94271: PUSH
94272: LD_INT 0
94274: PUSH
94275: LD_INT 2
94277: PUSH
94278: EMPTY
94279: LIST
94280: LIST
94281: PUSH
94282: LD_INT 1
94284: NEG
94285: PUSH
94286: LD_INT 1
94288: PUSH
94289: EMPTY
94290: LIST
94291: LIST
94292: PUSH
94293: LD_INT 2
94295: NEG
94296: PUSH
94297: LD_INT 0
94299: PUSH
94300: EMPTY
94301: LIST
94302: LIST
94303: PUSH
94304: LD_INT 2
94306: NEG
94307: PUSH
94308: LD_INT 1
94310: NEG
94311: PUSH
94312: EMPTY
94313: LIST
94314: LIST
94315: PUSH
94316: EMPTY
94317: LIST
94318: LIST
94319: LIST
94320: LIST
94321: LIST
94322: LIST
94323: LIST
94324: LIST
94325: LIST
94326: LIST
94327: LIST
94328: LIST
94329: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94330: LD_ADDR_VAR 0 52
94334: PUSH
94335: LD_INT 0
94337: PUSH
94338: LD_INT 0
94340: PUSH
94341: EMPTY
94342: LIST
94343: LIST
94344: PUSH
94345: LD_INT 0
94347: PUSH
94348: LD_INT 1
94350: NEG
94351: PUSH
94352: EMPTY
94353: LIST
94354: LIST
94355: PUSH
94356: LD_INT 1
94358: PUSH
94359: LD_INT 0
94361: PUSH
94362: EMPTY
94363: LIST
94364: LIST
94365: PUSH
94366: LD_INT 1
94368: PUSH
94369: LD_INT 1
94371: PUSH
94372: EMPTY
94373: LIST
94374: LIST
94375: PUSH
94376: LD_INT 0
94378: PUSH
94379: LD_INT 1
94381: PUSH
94382: EMPTY
94383: LIST
94384: LIST
94385: PUSH
94386: LD_INT 1
94388: NEG
94389: PUSH
94390: LD_INT 0
94392: PUSH
94393: EMPTY
94394: LIST
94395: LIST
94396: PUSH
94397: LD_INT 1
94399: NEG
94400: PUSH
94401: LD_INT 1
94403: NEG
94404: PUSH
94405: EMPTY
94406: LIST
94407: LIST
94408: PUSH
94409: LD_INT 1
94411: NEG
94412: PUSH
94413: LD_INT 2
94415: NEG
94416: PUSH
94417: EMPTY
94418: LIST
94419: LIST
94420: PUSH
94421: LD_INT 1
94423: NEG
94424: PUSH
94425: LD_INT 1
94427: PUSH
94428: EMPTY
94429: LIST
94430: LIST
94431: PUSH
94432: LD_INT 2
94434: NEG
94435: PUSH
94436: LD_INT 0
94438: PUSH
94439: EMPTY
94440: LIST
94441: LIST
94442: PUSH
94443: LD_INT 2
94445: NEG
94446: PUSH
94447: LD_INT 1
94449: NEG
94450: PUSH
94451: EMPTY
94452: LIST
94453: LIST
94454: PUSH
94455: LD_INT 2
94457: NEG
94458: PUSH
94459: LD_INT 2
94461: NEG
94462: PUSH
94463: EMPTY
94464: LIST
94465: LIST
94466: PUSH
94467: EMPTY
94468: LIST
94469: LIST
94470: LIST
94471: LIST
94472: LIST
94473: LIST
94474: LIST
94475: LIST
94476: LIST
94477: LIST
94478: LIST
94479: LIST
94480: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94481: LD_ADDR_VAR 0 53
94485: PUSH
94486: LD_INT 0
94488: PUSH
94489: LD_INT 0
94491: PUSH
94492: EMPTY
94493: LIST
94494: LIST
94495: PUSH
94496: LD_INT 0
94498: PUSH
94499: LD_INT 1
94501: NEG
94502: PUSH
94503: EMPTY
94504: LIST
94505: LIST
94506: PUSH
94507: LD_INT 1
94509: PUSH
94510: LD_INT 0
94512: PUSH
94513: EMPTY
94514: LIST
94515: LIST
94516: PUSH
94517: LD_INT 1
94519: PUSH
94520: LD_INT 1
94522: PUSH
94523: EMPTY
94524: LIST
94525: LIST
94526: PUSH
94527: LD_INT 0
94529: PUSH
94530: LD_INT 1
94532: PUSH
94533: EMPTY
94534: LIST
94535: LIST
94536: PUSH
94537: LD_INT 1
94539: NEG
94540: PUSH
94541: LD_INT 0
94543: PUSH
94544: EMPTY
94545: LIST
94546: LIST
94547: PUSH
94548: LD_INT 1
94550: NEG
94551: PUSH
94552: LD_INT 1
94554: NEG
94555: PUSH
94556: EMPTY
94557: LIST
94558: LIST
94559: PUSH
94560: LD_INT 1
94562: NEG
94563: PUSH
94564: LD_INT 2
94566: NEG
94567: PUSH
94568: EMPTY
94569: LIST
94570: LIST
94571: PUSH
94572: LD_INT 0
94574: PUSH
94575: LD_INT 2
94577: NEG
94578: PUSH
94579: EMPTY
94580: LIST
94581: LIST
94582: PUSH
94583: LD_INT 1
94585: PUSH
94586: LD_INT 1
94588: NEG
94589: PUSH
94590: EMPTY
94591: LIST
94592: LIST
94593: PUSH
94594: LD_INT 2
94596: PUSH
94597: LD_INT 0
94599: PUSH
94600: EMPTY
94601: LIST
94602: LIST
94603: PUSH
94604: LD_INT 2
94606: PUSH
94607: LD_INT 1
94609: PUSH
94610: EMPTY
94611: LIST
94612: LIST
94613: PUSH
94614: LD_INT 2
94616: PUSH
94617: LD_INT 2
94619: PUSH
94620: EMPTY
94621: LIST
94622: LIST
94623: PUSH
94624: LD_INT 1
94626: PUSH
94627: LD_INT 2
94629: PUSH
94630: EMPTY
94631: LIST
94632: LIST
94633: PUSH
94634: LD_INT 0
94636: PUSH
94637: LD_INT 2
94639: PUSH
94640: EMPTY
94641: LIST
94642: LIST
94643: PUSH
94644: LD_INT 1
94646: NEG
94647: PUSH
94648: LD_INT 1
94650: PUSH
94651: EMPTY
94652: LIST
94653: LIST
94654: PUSH
94655: LD_INT 2
94657: NEG
94658: PUSH
94659: LD_INT 0
94661: PUSH
94662: EMPTY
94663: LIST
94664: LIST
94665: PUSH
94666: LD_INT 2
94668: NEG
94669: PUSH
94670: LD_INT 1
94672: NEG
94673: PUSH
94674: EMPTY
94675: LIST
94676: LIST
94677: PUSH
94678: LD_INT 2
94680: NEG
94681: PUSH
94682: LD_INT 2
94684: NEG
94685: PUSH
94686: EMPTY
94687: LIST
94688: LIST
94689: PUSH
94690: EMPTY
94691: LIST
94692: LIST
94693: LIST
94694: LIST
94695: LIST
94696: LIST
94697: LIST
94698: LIST
94699: LIST
94700: LIST
94701: LIST
94702: LIST
94703: LIST
94704: LIST
94705: LIST
94706: LIST
94707: LIST
94708: LIST
94709: LIST
94710: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94711: LD_ADDR_VAR 0 54
94715: PUSH
94716: LD_INT 0
94718: PUSH
94719: LD_INT 0
94721: PUSH
94722: EMPTY
94723: LIST
94724: LIST
94725: PUSH
94726: LD_INT 0
94728: PUSH
94729: LD_INT 1
94731: NEG
94732: PUSH
94733: EMPTY
94734: LIST
94735: LIST
94736: PUSH
94737: LD_INT 1
94739: PUSH
94740: LD_INT 0
94742: PUSH
94743: EMPTY
94744: LIST
94745: LIST
94746: PUSH
94747: LD_INT 1
94749: PUSH
94750: LD_INT 1
94752: PUSH
94753: EMPTY
94754: LIST
94755: LIST
94756: PUSH
94757: LD_INT 0
94759: PUSH
94760: LD_INT 1
94762: PUSH
94763: EMPTY
94764: LIST
94765: LIST
94766: PUSH
94767: LD_INT 1
94769: NEG
94770: PUSH
94771: LD_INT 0
94773: PUSH
94774: EMPTY
94775: LIST
94776: LIST
94777: PUSH
94778: LD_INT 1
94780: NEG
94781: PUSH
94782: LD_INT 1
94784: NEG
94785: PUSH
94786: EMPTY
94787: LIST
94788: LIST
94789: PUSH
94790: LD_INT 1
94792: NEG
94793: PUSH
94794: LD_INT 2
94796: NEG
94797: PUSH
94798: EMPTY
94799: LIST
94800: LIST
94801: PUSH
94802: LD_INT 0
94804: PUSH
94805: LD_INT 2
94807: NEG
94808: PUSH
94809: EMPTY
94810: LIST
94811: LIST
94812: PUSH
94813: LD_INT 1
94815: PUSH
94816: LD_INT 1
94818: NEG
94819: PUSH
94820: EMPTY
94821: LIST
94822: LIST
94823: PUSH
94824: LD_INT 2
94826: PUSH
94827: LD_INT 0
94829: PUSH
94830: EMPTY
94831: LIST
94832: LIST
94833: PUSH
94834: LD_INT 2
94836: PUSH
94837: LD_INT 1
94839: PUSH
94840: EMPTY
94841: LIST
94842: LIST
94843: PUSH
94844: LD_INT 2
94846: PUSH
94847: LD_INT 2
94849: PUSH
94850: EMPTY
94851: LIST
94852: LIST
94853: PUSH
94854: LD_INT 1
94856: PUSH
94857: LD_INT 2
94859: PUSH
94860: EMPTY
94861: LIST
94862: LIST
94863: PUSH
94864: LD_INT 0
94866: PUSH
94867: LD_INT 2
94869: PUSH
94870: EMPTY
94871: LIST
94872: LIST
94873: PUSH
94874: LD_INT 1
94876: NEG
94877: PUSH
94878: LD_INT 1
94880: PUSH
94881: EMPTY
94882: LIST
94883: LIST
94884: PUSH
94885: LD_INT 2
94887: NEG
94888: PUSH
94889: LD_INT 0
94891: PUSH
94892: EMPTY
94893: LIST
94894: LIST
94895: PUSH
94896: LD_INT 2
94898: NEG
94899: PUSH
94900: LD_INT 1
94902: NEG
94903: PUSH
94904: EMPTY
94905: LIST
94906: LIST
94907: PUSH
94908: LD_INT 2
94910: NEG
94911: PUSH
94912: LD_INT 2
94914: NEG
94915: PUSH
94916: EMPTY
94917: LIST
94918: LIST
94919: PUSH
94920: EMPTY
94921: LIST
94922: LIST
94923: LIST
94924: LIST
94925: LIST
94926: LIST
94927: LIST
94928: LIST
94929: LIST
94930: LIST
94931: LIST
94932: LIST
94933: LIST
94934: LIST
94935: LIST
94936: LIST
94937: LIST
94938: LIST
94939: LIST
94940: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94941: LD_ADDR_VAR 0 55
94945: PUSH
94946: LD_INT 0
94948: PUSH
94949: LD_INT 0
94951: PUSH
94952: EMPTY
94953: LIST
94954: LIST
94955: PUSH
94956: LD_INT 0
94958: PUSH
94959: LD_INT 1
94961: NEG
94962: PUSH
94963: EMPTY
94964: LIST
94965: LIST
94966: PUSH
94967: LD_INT 1
94969: PUSH
94970: LD_INT 0
94972: PUSH
94973: EMPTY
94974: LIST
94975: LIST
94976: PUSH
94977: LD_INT 1
94979: PUSH
94980: LD_INT 1
94982: PUSH
94983: EMPTY
94984: LIST
94985: LIST
94986: PUSH
94987: LD_INT 0
94989: PUSH
94990: LD_INT 1
94992: PUSH
94993: EMPTY
94994: LIST
94995: LIST
94996: PUSH
94997: LD_INT 1
94999: NEG
95000: PUSH
95001: LD_INT 0
95003: PUSH
95004: EMPTY
95005: LIST
95006: LIST
95007: PUSH
95008: LD_INT 1
95010: NEG
95011: PUSH
95012: LD_INT 1
95014: NEG
95015: PUSH
95016: EMPTY
95017: LIST
95018: LIST
95019: PUSH
95020: LD_INT 1
95022: NEG
95023: PUSH
95024: LD_INT 2
95026: NEG
95027: PUSH
95028: EMPTY
95029: LIST
95030: LIST
95031: PUSH
95032: LD_INT 0
95034: PUSH
95035: LD_INT 2
95037: NEG
95038: PUSH
95039: EMPTY
95040: LIST
95041: LIST
95042: PUSH
95043: LD_INT 1
95045: PUSH
95046: LD_INT 1
95048: NEG
95049: PUSH
95050: EMPTY
95051: LIST
95052: LIST
95053: PUSH
95054: LD_INT 2
95056: PUSH
95057: LD_INT 0
95059: PUSH
95060: EMPTY
95061: LIST
95062: LIST
95063: PUSH
95064: LD_INT 2
95066: PUSH
95067: LD_INT 1
95069: PUSH
95070: EMPTY
95071: LIST
95072: LIST
95073: PUSH
95074: LD_INT 2
95076: PUSH
95077: LD_INT 2
95079: PUSH
95080: EMPTY
95081: LIST
95082: LIST
95083: PUSH
95084: LD_INT 1
95086: PUSH
95087: LD_INT 2
95089: PUSH
95090: EMPTY
95091: LIST
95092: LIST
95093: PUSH
95094: LD_INT 0
95096: PUSH
95097: LD_INT 2
95099: PUSH
95100: EMPTY
95101: LIST
95102: LIST
95103: PUSH
95104: LD_INT 1
95106: NEG
95107: PUSH
95108: LD_INT 1
95110: PUSH
95111: EMPTY
95112: LIST
95113: LIST
95114: PUSH
95115: LD_INT 2
95117: NEG
95118: PUSH
95119: LD_INT 0
95121: PUSH
95122: EMPTY
95123: LIST
95124: LIST
95125: PUSH
95126: LD_INT 2
95128: NEG
95129: PUSH
95130: LD_INT 1
95132: NEG
95133: PUSH
95134: EMPTY
95135: LIST
95136: LIST
95137: PUSH
95138: LD_INT 2
95140: NEG
95141: PUSH
95142: LD_INT 2
95144: NEG
95145: PUSH
95146: EMPTY
95147: LIST
95148: LIST
95149: PUSH
95150: EMPTY
95151: LIST
95152: LIST
95153: LIST
95154: LIST
95155: LIST
95156: LIST
95157: LIST
95158: LIST
95159: LIST
95160: LIST
95161: LIST
95162: LIST
95163: LIST
95164: LIST
95165: LIST
95166: LIST
95167: LIST
95168: LIST
95169: LIST
95170: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95171: LD_ADDR_VAR 0 56
95175: PUSH
95176: LD_INT 0
95178: PUSH
95179: LD_INT 0
95181: PUSH
95182: EMPTY
95183: LIST
95184: LIST
95185: PUSH
95186: LD_INT 0
95188: PUSH
95189: LD_INT 1
95191: NEG
95192: PUSH
95193: EMPTY
95194: LIST
95195: LIST
95196: PUSH
95197: LD_INT 1
95199: PUSH
95200: LD_INT 0
95202: PUSH
95203: EMPTY
95204: LIST
95205: LIST
95206: PUSH
95207: LD_INT 1
95209: PUSH
95210: LD_INT 1
95212: PUSH
95213: EMPTY
95214: LIST
95215: LIST
95216: PUSH
95217: LD_INT 0
95219: PUSH
95220: LD_INT 1
95222: PUSH
95223: EMPTY
95224: LIST
95225: LIST
95226: PUSH
95227: LD_INT 1
95229: NEG
95230: PUSH
95231: LD_INT 0
95233: PUSH
95234: EMPTY
95235: LIST
95236: LIST
95237: PUSH
95238: LD_INT 1
95240: NEG
95241: PUSH
95242: LD_INT 1
95244: NEG
95245: PUSH
95246: EMPTY
95247: LIST
95248: LIST
95249: PUSH
95250: LD_INT 1
95252: NEG
95253: PUSH
95254: LD_INT 2
95256: NEG
95257: PUSH
95258: EMPTY
95259: LIST
95260: LIST
95261: PUSH
95262: LD_INT 0
95264: PUSH
95265: LD_INT 2
95267: NEG
95268: PUSH
95269: EMPTY
95270: LIST
95271: LIST
95272: PUSH
95273: LD_INT 1
95275: PUSH
95276: LD_INT 1
95278: NEG
95279: PUSH
95280: EMPTY
95281: LIST
95282: LIST
95283: PUSH
95284: LD_INT 2
95286: PUSH
95287: LD_INT 0
95289: PUSH
95290: EMPTY
95291: LIST
95292: LIST
95293: PUSH
95294: LD_INT 2
95296: PUSH
95297: LD_INT 1
95299: PUSH
95300: EMPTY
95301: LIST
95302: LIST
95303: PUSH
95304: LD_INT 2
95306: PUSH
95307: LD_INT 2
95309: PUSH
95310: EMPTY
95311: LIST
95312: LIST
95313: PUSH
95314: LD_INT 1
95316: PUSH
95317: LD_INT 2
95319: PUSH
95320: EMPTY
95321: LIST
95322: LIST
95323: PUSH
95324: LD_INT 0
95326: PUSH
95327: LD_INT 2
95329: PUSH
95330: EMPTY
95331: LIST
95332: LIST
95333: PUSH
95334: LD_INT 1
95336: NEG
95337: PUSH
95338: LD_INT 1
95340: PUSH
95341: EMPTY
95342: LIST
95343: LIST
95344: PUSH
95345: LD_INT 2
95347: NEG
95348: PUSH
95349: LD_INT 0
95351: PUSH
95352: EMPTY
95353: LIST
95354: LIST
95355: PUSH
95356: LD_INT 2
95358: NEG
95359: PUSH
95360: LD_INT 1
95362: NEG
95363: PUSH
95364: EMPTY
95365: LIST
95366: LIST
95367: PUSH
95368: LD_INT 2
95370: NEG
95371: PUSH
95372: LD_INT 2
95374: NEG
95375: PUSH
95376: EMPTY
95377: LIST
95378: LIST
95379: PUSH
95380: EMPTY
95381: LIST
95382: LIST
95383: LIST
95384: LIST
95385: LIST
95386: LIST
95387: LIST
95388: LIST
95389: LIST
95390: LIST
95391: LIST
95392: LIST
95393: LIST
95394: LIST
95395: LIST
95396: LIST
95397: LIST
95398: LIST
95399: LIST
95400: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95401: LD_ADDR_VAR 0 57
95405: PUSH
95406: LD_INT 0
95408: PUSH
95409: LD_INT 0
95411: PUSH
95412: EMPTY
95413: LIST
95414: LIST
95415: PUSH
95416: LD_INT 0
95418: PUSH
95419: LD_INT 1
95421: NEG
95422: PUSH
95423: EMPTY
95424: LIST
95425: LIST
95426: PUSH
95427: LD_INT 1
95429: PUSH
95430: LD_INT 0
95432: PUSH
95433: EMPTY
95434: LIST
95435: LIST
95436: PUSH
95437: LD_INT 1
95439: PUSH
95440: LD_INT 1
95442: PUSH
95443: EMPTY
95444: LIST
95445: LIST
95446: PUSH
95447: LD_INT 0
95449: PUSH
95450: LD_INT 1
95452: PUSH
95453: EMPTY
95454: LIST
95455: LIST
95456: PUSH
95457: LD_INT 1
95459: NEG
95460: PUSH
95461: LD_INT 0
95463: PUSH
95464: EMPTY
95465: LIST
95466: LIST
95467: PUSH
95468: LD_INT 1
95470: NEG
95471: PUSH
95472: LD_INT 1
95474: NEG
95475: PUSH
95476: EMPTY
95477: LIST
95478: LIST
95479: PUSH
95480: LD_INT 1
95482: NEG
95483: PUSH
95484: LD_INT 2
95486: NEG
95487: PUSH
95488: EMPTY
95489: LIST
95490: LIST
95491: PUSH
95492: LD_INT 0
95494: PUSH
95495: LD_INT 2
95497: NEG
95498: PUSH
95499: EMPTY
95500: LIST
95501: LIST
95502: PUSH
95503: LD_INT 1
95505: PUSH
95506: LD_INT 1
95508: NEG
95509: PUSH
95510: EMPTY
95511: LIST
95512: LIST
95513: PUSH
95514: LD_INT 2
95516: PUSH
95517: LD_INT 0
95519: PUSH
95520: EMPTY
95521: LIST
95522: LIST
95523: PUSH
95524: LD_INT 2
95526: PUSH
95527: LD_INT 1
95529: PUSH
95530: EMPTY
95531: LIST
95532: LIST
95533: PUSH
95534: LD_INT 2
95536: PUSH
95537: LD_INT 2
95539: PUSH
95540: EMPTY
95541: LIST
95542: LIST
95543: PUSH
95544: LD_INT 1
95546: PUSH
95547: LD_INT 2
95549: PUSH
95550: EMPTY
95551: LIST
95552: LIST
95553: PUSH
95554: LD_INT 0
95556: PUSH
95557: LD_INT 2
95559: PUSH
95560: EMPTY
95561: LIST
95562: LIST
95563: PUSH
95564: LD_INT 1
95566: NEG
95567: PUSH
95568: LD_INT 1
95570: PUSH
95571: EMPTY
95572: LIST
95573: LIST
95574: PUSH
95575: LD_INT 2
95577: NEG
95578: PUSH
95579: LD_INT 0
95581: PUSH
95582: EMPTY
95583: LIST
95584: LIST
95585: PUSH
95586: LD_INT 2
95588: NEG
95589: PUSH
95590: LD_INT 1
95592: NEG
95593: PUSH
95594: EMPTY
95595: LIST
95596: LIST
95597: PUSH
95598: LD_INT 2
95600: NEG
95601: PUSH
95602: LD_INT 2
95604: NEG
95605: PUSH
95606: EMPTY
95607: LIST
95608: LIST
95609: PUSH
95610: EMPTY
95611: LIST
95612: LIST
95613: LIST
95614: LIST
95615: LIST
95616: LIST
95617: LIST
95618: LIST
95619: LIST
95620: LIST
95621: LIST
95622: LIST
95623: LIST
95624: LIST
95625: LIST
95626: LIST
95627: LIST
95628: LIST
95629: LIST
95630: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95631: LD_ADDR_VAR 0 58
95635: PUSH
95636: LD_INT 0
95638: PUSH
95639: LD_INT 0
95641: PUSH
95642: EMPTY
95643: LIST
95644: LIST
95645: PUSH
95646: LD_INT 0
95648: PUSH
95649: LD_INT 1
95651: NEG
95652: PUSH
95653: EMPTY
95654: LIST
95655: LIST
95656: PUSH
95657: LD_INT 1
95659: PUSH
95660: LD_INT 0
95662: PUSH
95663: EMPTY
95664: LIST
95665: LIST
95666: PUSH
95667: LD_INT 1
95669: PUSH
95670: LD_INT 1
95672: PUSH
95673: EMPTY
95674: LIST
95675: LIST
95676: PUSH
95677: LD_INT 0
95679: PUSH
95680: LD_INT 1
95682: PUSH
95683: EMPTY
95684: LIST
95685: LIST
95686: PUSH
95687: LD_INT 1
95689: NEG
95690: PUSH
95691: LD_INT 0
95693: PUSH
95694: EMPTY
95695: LIST
95696: LIST
95697: PUSH
95698: LD_INT 1
95700: NEG
95701: PUSH
95702: LD_INT 1
95704: NEG
95705: PUSH
95706: EMPTY
95707: LIST
95708: LIST
95709: PUSH
95710: LD_INT 1
95712: NEG
95713: PUSH
95714: LD_INT 2
95716: NEG
95717: PUSH
95718: EMPTY
95719: LIST
95720: LIST
95721: PUSH
95722: LD_INT 0
95724: PUSH
95725: LD_INT 2
95727: NEG
95728: PUSH
95729: EMPTY
95730: LIST
95731: LIST
95732: PUSH
95733: LD_INT 1
95735: PUSH
95736: LD_INT 1
95738: NEG
95739: PUSH
95740: EMPTY
95741: LIST
95742: LIST
95743: PUSH
95744: LD_INT 2
95746: PUSH
95747: LD_INT 0
95749: PUSH
95750: EMPTY
95751: LIST
95752: LIST
95753: PUSH
95754: LD_INT 2
95756: PUSH
95757: LD_INT 1
95759: PUSH
95760: EMPTY
95761: LIST
95762: LIST
95763: PUSH
95764: LD_INT 2
95766: PUSH
95767: LD_INT 2
95769: PUSH
95770: EMPTY
95771: LIST
95772: LIST
95773: PUSH
95774: LD_INT 1
95776: PUSH
95777: LD_INT 2
95779: PUSH
95780: EMPTY
95781: LIST
95782: LIST
95783: PUSH
95784: LD_INT 0
95786: PUSH
95787: LD_INT 2
95789: PUSH
95790: EMPTY
95791: LIST
95792: LIST
95793: PUSH
95794: LD_INT 1
95796: NEG
95797: PUSH
95798: LD_INT 1
95800: PUSH
95801: EMPTY
95802: LIST
95803: LIST
95804: PUSH
95805: LD_INT 2
95807: NEG
95808: PUSH
95809: LD_INT 0
95811: PUSH
95812: EMPTY
95813: LIST
95814: LIST
95815: PUSH
95816: LD_INT 2
95818: NEG
95819: PUSH
95820: LD_INT 1
95822: NEG
95823: PUSH
95824: EMPTY
95825: LIST
95826: LIST
95827: PUSH
95828: LD_INT 2
95830: NEG
95831: PUSH
95832: LD_INT 2
95834: NEG
95835: PUSH
95836: EMPTY
95837: LIST
95838: LIST
95839: PUSH
95840: EMPTY
95841: LIST
95842: LIST
95843: LIST
95844: LIST
95845: LIST
95846: LIST
95847: LIST
95848: LIST
95849: LIST
95850: LIST
95851: LIST
95852: LIST
95853: LIST
95854: LIST
95855: LIST
95856: LIST
95857: LIST
95858: LIST
95859: LIST
95860: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95861: LD_ADDR_VAR 0 59
95865: PUSH
95866: LD_INT 0
95868: PUSH
95869: LD_INT 0
95871: PUSH
95872: EMPTY
95873: LIST
95874: LIST
95875: PUSH
95876: LD_INT 0
95878: PUSH
95879: LD_INT 1
95881: NEG
95882: PUSH
95883: EMPTY
95884: LIST
95885: LIST
95886: PUSH
95887: LD_INT 1
95889: PUSH
95890: LD_INT 0
95892: PUSH
95893: EMPTY
95894: LIST
95895: LIST
95896: PUSH
95897: LD_INT 1
95899: PUSH
95900: LD_INT 1
95902: PUSH
95903: EMPTY
95904: LIST
95905: LIST
95906: PUSH
95907: LD_INT 0
95909: PUSH
95910: LD_INT 1
95912: PUSH
95913: EMPTY
95914: LIST
95915: LIST
95916: PUSH
95917: LD_INT 1
95919: NEG
95920: PUSH
95921: LD_INT 0
95923: PUSH
95924: EMPTY
95925: LIST
95926: LIST
95927: PUSH
95928: LD_INT 1
95930: NEG
95931: PUSH
95932: LD_INT 1
95934: NEG
95935: PUSH
95936: EMPTY
95937: LIST
95938: LIST
95939: PUSH
95940: EMPTY
95941: LIST
95942: LIST
95943: LIST
95944: LIST
95945: LIST
95946: LIST
95947: LIST
95948: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95949: LD_ADDR_VAR 0 60
95953: PUSH
95954: LD_INT 0
95956: PUSH
95957: LD_INT 0
95959: PUSH
95960: EMPTY
95961: LIST
95962: LIST
95963: PUSH
95964: LD_INT 0
95966: PUSH
95967: LD_INT 1
95969: NEG
95970: PUSH
95971: EMPTY
95972: LIST
95973: LIST
95974: PUSH
95975: LD_INT 1
95977: PUSH
95978: LD_INT 0
95980: PUSH
95981: EMPTY
95982: LIST
95983: LIST
95984: PUSH
95985: LD_INT 1
95987: PUSH
95988: LD_INT 1
95990: PUSH
95991: EMPTY
95992: LIST
95993: LIST
95994: PUSH
95995: LD_INT 0
95997: PUSH
95998: LD_INT 1
96000: PUSH
96001: EMPTY
96002: LIST
96003: LIST
96004: PUSH
96005: LD_INT 1
96007: NEG
96008: PUSH
96009: LD_INT 0
96011: PUSH
96012: EMPTY
96013: LIST
96014: LIST
96015: PUSH
96016: LD_INT 1
96018: NEG
96019: PUSH
96020: LD_INT 1
96022: NEG
96023: PUSH
96024: EMPTY
96025: LIST
96026: LIST
96027: PUSH
96028: EMPTY
96029: LIST
96030: LIST
96031: LIST
96032: LIST
96033: LIST
96034: LIST
96035: LIST
96036: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96037: LD_ADDR_VAR 0 61
96041: PUSH
96042: LD_INT 0
96044: PUSH
96045: LD_INT 0
96047: PUSH
96048: EMPTY
96049: LIST
96050: LIST
96051: PUSH
96052: LD_INT 0
96054: PUSH
96055: LD_INT 1
96057: NEG
96058: PUSH
96059: EMPTY
96060: LIST
96061: LIST
96062: PUSH
96063: LD_INT 1
96065: PUSH
96066: LD_INT 0
96068: PUSH
96069: EMPTY
96070: LIST
96071: LIST
96072: PUSH
96073: LD_INT 1
96075: PUSH
96076: LD_INT 1
96078: PUSH
96079: EMPTY
96080: LIST
96081: LIST
96082: PUSH
96083: LD_INT 0
96085: PUSH
96086: LD_INT 1
96088: PUSH
96089: EMPTY
96090: LIST
96091: LIST
96092: PUSH
96093: LD_INT 1
96095: NEG
96096: PUSH
96097: LD_INT 0
96099: PUSH
96100: EMPTY
96101: LIST
96102: LIST
96103: PUSH
96104: LD_INT 1
96106: NEG
96107: PUSH
96108: LD_INT 1
96110: NEG
96111: PUSH
96112: EMPTY
96113: LIST
96114: LIST
96115: PUSH
96116: EMPTY
96117: LIST
96118: LIST
96119: LIST
96120: LIST
96121: LIST
96122: LIST
96123: LIST
96124: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96125: LD_ADDR_VAR 0 62
96129: PUSH
96130: LD_INT 0
96132: PUSH
96133: LD_INT 0
96135: PUSH
96136: EMPTY
96137: LIST
96138: LIST
96139: PUSH
96140: LD_INT 0
96142: PUSH
96143: LD_INT 1
96145: NEG
96146: PUSH
96147: EMPTY
96148: LIST
96149: LIST
96150: PUSH
96151: LD_INT 1
96153: PUSH
96154: LD_INT 0
96156: PUSH
96157: EMPTY
96158: LIST
96159: LIST
96160: PUSH
96161: LD_INT 1
96163: PUSH
96164: LD_INT 1
96166: PUSH
96167: EMPTY
96168: LIST
96169: LIST
96170: PUSH
96171: LD_INT 0
96173: PUSH
96174: LD_INT 1
96176: PUSH
96177: EMPTY
96178: LIST
96179: LIST
96180: PUSH
96181: LD_INT 1
96183: NEG
96184: PUSH
96185: LD_INT 0
96187: PUSH
96188: EMPTY
96189: LIST
96190: LIST
96191: PUSH
96192: LD_INT 1
96194: NEG
96195: PUSH
96196: LD_INT 1
96198: NEG
96199: PUSH
96200: EMPTY
96201: LIST
96202: LIST
96203: PUSH
96204: EMPTY
96205: LIST
96206: LIST
96207: LIST
96208: LIST
96209: LIST
96210: LIST
96211: LIST
96212: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96213: LD_ADDR_VAR 0 63
96217: PUSH
96218: LD_INT 0
96220: PUSH
96221: LD_INT 0
96223: PUSH
96224: EMPTY
96225: LIST
96226: LIST
96227: PUSH
96228: LD_INT 0
96230: PUSH
96231: LD_INT 1
96233: NEG
96234: PUSH
96235: EMPTY
96236: LIST
96237: LIST
96238: PUSH
96239: LD_INT 1
96241: PUSH
96242: LD_INT 0
96244: PUSH
96245: EMPTY
96246: LIST
96247: LIST
96248: PUSH
96249: LD_INT 1
96251: PUSH
96252: LD_INT 1
96254: PUSH
96255: EMPTY
96256: LIST
96257: LIST
96258: PUSH
96259: LD_INT 0
96261: PUSH
96262: LD_INT 1
96264: PUSH
96265: EMPTY
96266: LIST
96267: LIST
96268: PUSH
96269: LD_INT 1
96271: NEG
96272: PUSH
96273: LD_INT 0
96275: PUSH
96276: EMPTY
96277: LIST
96278: LIST
96279: PUSH
96280: LD_INT 1
96282: NEG
96283: PUSH
96284: LD_INT 1
96286: NEG
96287: PUSH
96288: EMPTY
96289: LIST
96290: LIST
96291: PUSH
96292: EMPTY
96293: LIST
96294: LIST
96295: LIST
96296: LIST
96297: LIST
96298: LIST
96299: LIST
96300: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96301: LD_ADDR_VAR 0 64
96305: PUSH
96306: LD_INT 0
96308: PUSH
96309: LD_INT 0
96311: PUSH
96312: EMPTY
96313: LIST
96314: LIST
96315: PUSH
96316: LD_INT 0
96318: PUSH
96319: LD_INT 1
96321: NEG
96322: PUSH
96323: EMPTY
96324: LIST
96325: LIST
96326: PUSH
96327: LD_INT 1
96329: PUSH
96330: LD_INT 0
96332: PUSH
96333: EMPTY
96334: LIST
96335: LIST
96336: PUSH
96337: LD_INT 1
96339: PUSH
96340: LD_INT 1
96342: PUSH
96343: EMPTY
96344: LIST
96345: LIST
96346: PUSH
96347: LD_INT 0
96349: PUSH
96350: LD_INT 1
96352: PUSH
96353: EMPTY
96354: LIST
96355: LIST
96356: PUSH
96357: LD_INT 1
96359: NEG
96360: PUSH
96361: LD_INT 0
96363: PUSH
96364: EMPTY
96365: LIST
96366: LIST
96367: PUSH
96368: LD_INT 1
96370: NEG
96371: PUSH
96372: LD_INT 1
96374: NEG
96375: PUSH
96376: EMPTY
96377: LIST
96378: LIST
96379: PUSH
96380: EMPTY
96381: LIST
96382: LIST
96383: LIST
96384: LIST
96385: LIST
96386: LIST
96387: LIST
96388: ST_TO_ADDR
// end ; 1 :
96389: GO 102286
96391: LD_INT 1
96393: DOUBLE
96394: EQUAL
96395: IFTRUE 96399
96397: GO 99022
96399: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
96400: LD_ADDR_VAR 0 11
96404: PUSH
96405: LD_INT 1
96407: NEG
96408: PUSH
96409: LD_INT 3
96411: NEG
96412: PUSH
96413: EMPTY
96414: LIST
96415: LIST
96416: PUSH
96417: LD_INT 0
96419: PUSH
96420: LD_INT 3
96422: NEG
96423: PUSH
96424: EMPTY
96425: LIST
96426: LIST
96427: PUSH
96428: LD_INT 1
96430: PUSH
96431: LD_INT 2
96433: NEG
96434: PUSH
96435: EMPTY
96436: LIST
96437: LIST
96438: PUSH
96439: EMPTY
96440: LIST
96441: LIST
96442: LIST
96443: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
96444: LD_ADDR_VAR 0 12
96448: PUSH
96449: LD_INT 2
96451: PUSH
96452: LD_INT 1
96454: NEG
96455: PUSH
96456: EMPTY
96457: LIST
96458: LIST
96459: PUSH
96460: LD_INT 3
96462: PUSH
96463: LD_INT 0
96465: PUSH
96466: EMPTY
96467: LIST
96468: LIST
96469: PUSH
96470: LD_INT 3
96472: PUSH
96473: LD_INT 1
96475: PUSH
96476: EMPTY
96477: LIST
96478: LIST
96479: PUSH
96480: EMPTY
96481: LIST
96482: LIST
96483: LIST
96484: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
96485: LD_ADDR_VAR 0 13
96489: PUSH
96490: LD_INT 3
96492: PUSH
96493: LD_INT 2
96495: PUSH
96496: EMPTY
96497: LIST
96498: LIST
96499: PUSH
96500: LD_INT 3
96502: PUSH
96503: LD_INT 3
96505: PUSH
96506: EMPTY
96507: LIST
96508: LIST
96509: PUSH
96510: LD_INT 2
96512: PUSH
96513: LD_INT 3
96515: PUSH
96516: EMPTY
96517: LIST
96518: LIST
96519: PUSH
96520: EMPTY
96521: LIST
96522: LIST
96523: LIST
96524: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
96525: LD_ADDR_VAR 0 14
96529: PUSH
96530: LD_INT 1
96532: PUSH
96533: LD_INT 3
96535: PUSH
96536: EMPTY
96537: LIST
96538: LIST
96539: PUSH
96540: LD_INT 0
96542: PUSH
96543: LD_INT 3
96545: PUSH
96546: EMPTY
96547: LIST
96548: LIST
96549: PUSH
96550: LD_INT 1
96552: NEG
96553: PUSH
96554: LD_INT 2
96556: PUSH
96557: EMPTY
96558: LIST
96559: LIST
96560: PUSH
96561: EMPTY
96562: LIST
96563: LIST
96564: LIST
96565: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
96566: LD_ADDR_VAR 0 15
96570: PUSH
96571: LD_INT 2
96573: NEG
96574: PUSH
96575: LD_INT 1
96577: PUSH
96578: EMPTY
96579: LIST
96580: LIST
96581: PUSH
96582: LD_INT 3
96584: NEG
96585: PUSH
96586: LD_INT 0
96588: PUSH
96589: EMPTY
96590: LIST
96591: LIST
96592: PUSH
96593: LD_INT 3
96595: NEG
96596: PUSH
96597: LD_INT 1
96599: NEG
96600: PUSH
96601: EMPTY
96602: LIST
96603: LIST
96604: PUSH
96605: EMPTY
96606: LIST
96607: LIST
96608: LIST
96609: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
96610: LD_ADDR_VAR 0 16
96614: PUSH
96615: LD_INT 2
96617: NEG
96618: PUSH
96619: LD_INT 3
96621: NEG
96622: PUSH
96623: EMPTY
96624: LIST
96625: LIST
96626: PUSH
96627: LD_INT 3
96629: NEG
96630: PUSH
96631: LD_INT 2
96633: NEG
96634: PUSH
96635: EMPTY
96636: LIST
96637: LIST
96638: PUSH
96639: LD_INT 3
96641: NEG
96642: PUSH
96643: LD_INT 3
96645: NEG
96646: PUSH
96647: EMPTY
96648: LIST
96649: LIST
96650: PUSH
96651: EMPTY
96652: LIST
96653: LIST
96654: LIST
96655: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
96656: LD_ADDR_VAR 0 17
96660: PUSH
96661: LD_INT 1
96663: NEG
96664: PUSH
96665: LD_INT 3
96667: NEG
96668: PUSH
96669: EMPTY
96670: LIST
96671: LIST
96672: PUSH
96673: LD_INT 0
96675: PUSH
96676: LD_INT 3
96678: NEG
96679: PUSH
96680: EMPTY
96681: LIST
96682: LIST
96683: PUSH
96684: LD_INT 1
96686: PUSH
96687: LD_INT 2
96689: NEG
96690: PUSH
96691: EMPTY
96692: LIST
96693: LIST
96694: PUSH
96695: EMPTY
96696: LIST
96697: LIST
96698: LIST
96699: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
96700: LD_ADDR_VAR 0 18
96704: PUSH
96705: LD_INT 2
96707: PUSH
96708: LD_INT 1
96710: NEG
96711: PUSH
96712: EMPTY
96713: LIST
96714: LIST
96715: PUSH
96716: LD_INT 3
96718: PUSH
96719: LD_INT 0
96721: PUSH
96722: EMPTY
96723: LIST
96724: LIST
96725: PUSH
96726: LD_INT 3
96728: PUSH
96729: LD_INT 1
96731: PUSH
96732: EMPTY
96733: LIST
96734: LIST
96735: PUSH
96736: EMPTY
96737: LIST
96738: LIST
96739: LIST
96740: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
96741: LD_ADDR_VAR 0 19
96745: PUSH
96746: LD_INT 3
96748: PUSH
96749: LD_INT 2
96751: PUSH
96752: EMPTY
96753: LIST
96754: LIST
96755: PUSH
96756: LD_INT 3
96758: PUSH
96759: LD_INT 3
96761: PUSH
96762: EMPTY
96763: LIST
96764: LIST
96765: PUSH
96766: LD_INT 2
96768: PUSH
96769: LD_INT 3
96771: PUSH
96772: EMPTY
96773: LIST
96774: LIST
96775: PUSH
96776: EMPTY
96777: LIST
96778: LIST
96779: LIST
96780: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
96781: LD_ADDR_VAR 0 20
96785: PUSH
96786: LD_INT 1
96788: PUSH
96789: LD_INT 3
96791: PUSH
96792: EMPTY
96793: LIST
96794: LIST
96795: PUSH
96796: LD_INT 0
96798: PUSH
96799: LD_INT 3
96801: PUSH
96802: EMPTY
96803: LIST
96804: LIST
96805: PUSH
96806: LD_INT 1
96808: NEG
96809: PUSH
96810: LD_INT 2
96812: PUSH
96813: EMPTY
96814: LIST
96815: LIST
96816: PUSH
96817: EMPTY
96818: LIST
96819: LIST
96820: LIST
96821: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
96822: LD_ADDR_VAR 0 21
96826: PUSH
96827: LD_INT 2
96829: NEG
96830: PUSH
96831: LD_INT 1
96833: PUSH
96834: EMPTY
96835: LIST
96836: LIST
96837: PUSH
96838: LD_INT 3
96840: NEG
96841: PUSH
96842: LD_INT 0
96844: PUSH
96845: EMPTY
96846: LIST
96847: LIST
96848: PUSH
96849: LD_INT 3
96851: NEG
96852: PUSH
96853: LD_INT 1
96855: NEG
96856: PUSH
96857: EMPTY
96858: LIST
96859: LIST
96860: PUSH
96861: EMPTY
96862: LIST
96863: LIST
96864: LIST
96865: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
96866: LD_ADDR_VAR 0 22
96870: PUSH
96871: LD_INT 2
96873: NEG
96874: PUSH
96875: LD_INT 3
96877: NEG
96878: PUSH
96879: EMPTY
96880: LIST
96881: LIST
96882: PUSH
96883: LD_INT 3
96885: NEG
96886: PUSH
96887: LD_INT 2
96889: NEG
96890: PUSH
96891: EMPTY
96892: LIST
96893: LIST
96894: PUSH
96895: LD_INT 3
96897: NEG
96898: PUSH
96899: LD_INT 3
96901: NEG
96902: PUSH
96903: EMPTY
96904: LIST
96905: LIST
96906: PUSH
96907: EMPTY
96908: LIST
96909: LIST
96910: LIST
96911: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
96912: LD_ADDR_VAR 0 23
96916: PUSH
96917: LD_INT 0
96919: PUSH
96920: LD_INT 3
96922: NEG
96923: PUSH
96924: EMPTY
96925: LIST
96926: LIST
96927: PUSH
96928: LD_INT 1
96930: NEG
96931: PUSH
96932: LD_INT 4
96934: NEG
96935: PUSH
96936: EMPTY
96937: LIST
96938: LIST
96939: PUSH
96940: LD_INT 1
96942: PUSH
96943: LD_INT 3
96945: NEG
96946: PUSH
96947: EMPTY
96948: LIST
96949: LIST
96950: PUSH
96951: EMPTY
96952: LIST
96953: LIST
96954: LIST
96955: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
96956: LD_ADDR_VAR 0 24
96960: PUSH
96961: LD_INT 3
96963: PUSH
96964: LD_INT 0
96966: PUSH
96967: EMPTY
96968: LIST
96969: LIST
96970: PUSH
96971: LD_INT 3
96973: PUSH
96974: LD_INT 1
96976: NEG
96977: PUSH
96978: EMPTY
96979: LIST
96980: LIST
96981: PUSH
96982: LD_INT 4
96984: PUSH
96985: LD_INT 1
96987: PUSH
96988: EMPTY
96989: LIST
96990: LIST
96991: PUSH
96992: EMPTY
96993: LIST
96994: LIST
96995: LIST
96996: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
96997: LD_ADDR_VAR 0 25
97001: PUSH
97002: LD_INT 3
97004: PUSH
97005: LD_INT 3
97007: PUSH
97008: EMPTY
97009: LIST
97010: LIST
97011: PUSH
97012: LD_INT 4
97014: PUSH
97015: LD_INT 3
97017: PUSH
97018: EMPTY
97019: LIST
97020: LIST
97021: PUSH
97022: LD_INT 3
97024: PUSH
97025: LD_INT 4
97027: PUSH
97028: EMPTY
97029: LIST
97030: LIST
97031: PUSH
97032: EMPTY
97033: LIST
97034: LIST
97035: LIST
97036: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
97037: LD_ADDR_VAR 0 26
97041: PUSH
97042: LD_INT 0
97044: PUSH
97045: LD_INT 3
97047: PUSH
97048: EMPTY
97049: LIST
97050: LIST
97051: PUSH
97052: LD_INT 1
97054: PUSH
97055: LD_INT 4
97057: PUSH
97058: EMPTY
97059: LIST
97060: LIST
97061: PUSH
97062: LD_INT 1
97064: NEG
97065: PUSH
97066: LD_INT 3
97068: PUSH
97069: EMPTY
97070: LIST
97071: LIST
97072: PUSH
97073: EMPTY
97074: LIST
97075: LIST
97076: LIST
97077: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
97078: LD_ADDR_VAR 0 27
97082: PUSH
97083: LD_INT 3
97085: NEG
97086: PUSH
97087: LD_INT 0
97089: PUSH
97090: EMPTY
97091: LIST
97092: LIST
97093: PUSH
97094: LD_INT 3
97096: NEG
97097: PUSH
97098: LD_INT 1
97100: PUSH
97101: EMPTY
97102: LIST
97103: LIST
97104: PUSH
97105: LD_INT 4
97107: NEG
97108: PUSH
97109: LD_INT 1
97111: NEG
97112: PUSH
97113: EMPTY
97114: LIST
97115: LIST
97116: PUSH
97117: EMPTY
97118: LIST
97119: LIST
97120: LIST
97121: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
97122: LD_ADDR_VAR 0 28
97126: PUSH
97127: LD_INT 3
97129: NEG
97130: PUSH
97131: LD_INT 3
97133: NEG
97134: PUSH
97135: EMPTY
97136: LIST
97137: LIST
97138: PUSH
97139: LD_INT 3
97141: NEG
97142: PUSH
97143: LD_INT 4
97145: NEG
97146: PUSH
97147: EMPTY
97148: LIST
97149: LIST
97150: PUSH
97151: LD_INT 4
97153: NEG
97154: PUSH
97155: LD_INT 3
97157: NEG
97158: PUSH
97159: EMPTY
97160: LIST
97161: LIST
97162: PUSH
97163: EMPTY
97164: LIST
97165: LIST
97166: LIST
97167: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
97168: LD_ADDR_VAR 0 29
97172: PUSH
97173: LD_INT 1
97175: NEG
97176: PUSH
97177: LD_INT 3
97179: NEG
97180: PUSH
97181: EMPTY
97182: LIST
97183: LIST
97184: PUSH
97185: LD_INT 0
97187: PUSH
97188: LD_INT 3
97190: NEG
97191: PUSH
97192: EMPTY
97193: LIST
97194: LIST
97195: PUSH
97196: LD_INT 1
97198: PUSH
97199: LD_INT 2
97201: NEG
97202: PUSH
97203: EMPTY
97204: LIST
97205: LIST
97206: PUSH
97207: LD_INT 1
97209: NEG
97210: PUSH
97211: LD_INT 4
97213: NEG
97214: PUSH
97215: EMPTY
97216: LIST
97217: LIST
97218: PUSH
97219: LD_INT 0
97221: PUSH
97222: LD_INT 4
97224: NEG
97225: PUSH
97226: EMPTY
97227: LIST
97228: LIST
97229: PUSH
97230: LD_INT 1
97232: PUSH
97233: LD_INT 3
97235: NEG
97236: PUSH
97237: EMPTY
97238: LIST
97239: LIST
97240: PUSH
97241: LD_INT 1
97243: NEG
97244: PUSH
97245: LD_INT 5
97247: NEG
97248: PUSH
97249: EMPTY
97250: LIST
97251: LIST
97252: PUSH
97253: LD_INT 0
97255: PUSH
97256: LD_INT 5
97258: NEG
97259: PUSH
97260: EMPTY
97261: LIST
97262: LIST
97263: PUSH
97264: LD_INT 1
97266: PUSH
97267: LD_INT 4
97269: NEG
97270: PUSH
97271: EMPTY
97272: LIST
97273: LIST
97274: PUSH
97275: LD_INT 1
97277: NEG
97278: PUSH
97279: LD_INT 6
97281: NEG
97282: PUSH
97283: EMPTY
97284: LIST
97285: LIST
97286: PUSH
97287: LD_INT 0
97289: PUSH
97290: LD_INT 6
97292: NEG
97293: PUSH
97294: EMPTY
97295: LIST
97296: LIST
97297: PUSH
97298: LD_INT 1
97300: PUSH
97301: LD_INT 5
97303: NEG
97304: PUSH
97305: EMPTY
97306: LIST
97307: LIST
97308: PUSH
97309: EMPTY
97310: LIST
97311: LIST
97312: LIST
97313: LIST
97314: LIST
97315: LIST
97316: LIST
97317: LIST
97318: LIST
97319: LIST
97320: LIST
97321: LIST
97322: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
97323: LD_ADDR_VAR 0 30
97327: PUSH
97328: LD_INT 2
97330: PUSH
97331: LD_INT 1
97333: NEG
97334: PUSH
97335: EMPTY
97336: LIST
97337: LIST
97338: PUSH
97339: LD_INT 3
97341: PUSH
97342: LD_INT 0
97344: PUSH
97345: EMPTY
97346: LIST
97347: LIST
97348: PUSH
97349: LD_INT 3
97351: PUSH
97352: LD_INT 1
97354: PUSH
97355: EMPTY
97356: LIST
97357: LIST
97358: PUSH
97359: LD_INT 3
97361: PUSH
97362: LD_INT 1
97364: NEG
97365: PUSH
97366: EMPTY
97367: LIST
97368: LIST
97369: PUSH
97370: LD_INT 4
97372: PUSH
97373: LD_INT 0
97375: PUSH
97376: EMPTY
97377: LIST
97378: LIST
97379: PUSH
97380: LD_INT 4
97382: PUSH
97383: LD_INT 1
97385: PUSH
97386: EMPTY
97387: LIST
97388: LIST
97389: PUSH
97390: LD_INT 4
97392: PUSH
97393: LD_INT 1
97395: NEG
97396: PUSH
97397: EMPTY
97398: LIST
97399: LIST
97400: PUSH
97401: LD_INT 5
97403: PUSH
97404: LD_INT 0
97406: PUSH
97407: EMPTY
97408: LIST
97409: LIST
97410: PUSH
97411: LD_INT 5
97413: PUSH
97414: LD_INT 1
97416: PUSH
97417: EMPTY
97418: LIST
97419: LIST
97420: PUSH
97421: LD_INT 5
97423: PUSH
97424: LD_INT 1
97426: NEG
97427: PUSH
97428: EMPTY
97429: LIST
97430: LIST
97431: PUSH
97432: LD_INT 6
97434: PUSH
97435: LD_INT 0
97437: PUSH
97438: EMPTY
97439: LIST
97440: LIST
97441: PUSH
97442: LD_INT 6
97444: PUSH
97445: LD_INT 1
97447: PUSH
97448: EMPTY
97449: LIST
97450: LIST
97451: PUSH
97452: EMPTY
97453: LIST
97454: LIST
97455: LIST
97456: LIST
97457: LIST
97458: LIST
97459: LIST
97460: LIST
97461: LIST
97462: LIST
97463: LIST
97464: LIST
97465: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
97466: LD_ADDR_VAR 0 31
97470: PUSH
97471: LD_INT 3
97473: PUSH
97474: LD_INT 2
97476: PUSH
97477: EMPTY
97478: LIST
97479: LIST
97480: PUSH
97481: LD_INT 3
97483: PUSH
97484: LD_INT 3
97486: PUSH
97487: EMPTY
97488: LIST
97489: LIST
97490: PUSH
97491: LD_INT 2
97493: PUSH
97494: LD_INT 3
97496: PUSH
97497: EMPTY
97498: LIST
97499: LIST
97500: PUSH
97501: LD_INT 4
97503: PUSH
97504: LD_INT 3
97506: PUSH
97507: EMPTY
97508: LIST
97509: LIST
97510: PUSH
97511: LD_INT 4
97513: PUSH
97514: LD_INT 4
97516: PUSH
97517: EMPTY
97518: LIST
97519: LIST
97520: PUSH
97521: LD_INT 3
97523: PUSH
97524: LD_INT 4
97526: PUSH
97527: EMPTY
97528: LIST
97529: LIST
97530: PUSH
97531: LD_INT 5
97533: PUSH
97534: LD_INT 4
97536: PUSH
97537: EMPTY
97538: LIST
97539: LIST
97540: PUSH
97541: LD_INT 5
97543: PUSH
97544: LD_INT 5
97546: PUSH
97547: EMPTY
97548: LIST
97549: LIST
97550: PUSH
97551: LD_INT 4
97553: PUSH
97554: LD_INT 5
97556: PUSH
97557: EMPTY
97558: LIST
97559: LIST
97560: PUSH
97561: LD_INT 6
97563: PUSH
97564: LD_INT 5
97566: PUSH
97567: EMPTY
97568: LIST
97569: LIST
97570: PUSH
97571: LD_INT 6
97573: PUSH
97574: LD_INT 6
97576: PUSH
97577: EMPTY
97578: LIST
97579: LIST
97580: PUSH
97581: LD_INT 5
97583: PUSH
97584: LD_INT 6
97586: PUSH
97587: EMPTY
97588: LIST
97589: LIST
97590: PUSH
97591: EMPTY
97592: LIST
97593: LIST
97594: LIST
97595: LIST
97596: LIST
97597: LIST
97598: LIST
97599: LIST
97600: LIST
97601: LIST
97602: LIST
97603: LIST
97604: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
97605: LD_ADDR_VAR 0 32
97609: PUSH
97610: LD_INT 1
97612: PUSH
97613: LD_INT 3
97615: PUSH
97616: EMPTY
97617: LIST
97618: LIST
97619: PUSH
97620: LD_INT 0
97622: PUSH
97623: LD_INT 3
97625: PUSH
97626: EMPTY
97627: LIST
97628: LIST
97629: PUSH
97630: LD_INT 1
97632: NEG
97633: PUSH
97634: LD_INT 2
97636: PUSH
97637: EMPTY
97638: LIST
97639: LIST
97640: PUSH
97641: LD_INT 1
97643: PUSH
97644: LD_INT 4
97646: PUSH
97647: EMPTY
97648: LIST
97649: LIST
97650: PUSH
97651: LD_INT 0
97653: PUSH
97654: LD_INT 4
97656: PUSH
97657: EMPTY
97658: LIST
97659: LIST
97660: PUSH
97661: LD_INT 1
97663: NEG
97664: PUSH
97665: LD_INT 3
97667: PUSH
97668: EMPTY
97669: LIST
97670: LIST
97671: PUSH
97672: LD_INT 1
97674: PUSH
97675: LD_INT 5
97677: PUSH
97678: EMPTY
97679: LIST
97680: LIST
97681: PUSH
97682: LD_INT 0
97684: PUSH
97685: LD_INT 5
97687: PUSH
97688: EMPTY
97689: LIST
97690: LIST
97691: PUSH
97692: LD_INT 1
97694: NEG
97695: PUSH
97696: LD_INT 4
97698: PUSH
97699: EMPTY
97700: LIST
97701: LIST
97702: PUSH
97703: LD_INT 1
97705: PUSH
97706: LD_INT 6
97708: PUSH
97709: EMPTY
97710: LIST
97711: LIST
97712: PUSH
97713: LD_INT 0
97715: PUSH
97716: LD_INT 6
97718: PUSH
97719: EMPTY
97720: LIST
97721: LIST
97722: PUSH
97723: LD_INT 1
97725: NEG
97726: PUSH
97727: LD_INT 5
97729: PUSH
97730: EMPTY
97731: LIST
97732: LIST
97733: PUSH
97734: EMPTY
97735: LIST
97736: LIST
97737: LIST
97738: LIST
97739: LIST
97740: LIST
97741: LIST
97742: LIST
97743: LIST
97744: LIST
97745: LIST
97746: LIST
97747: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
97748: LD_ADDR_VAR 0 33
97752: PUSH
97753: LD_INT 2
97755: NEG
97756: PUSH
97757: LD_INT 1
97759: PUSH
97760: EMPTY
97761: LIST
97762: LIST
97763: PUSH
97764: LD_INT 3
97766: NEG
97767: PUSH
97768: LD_INT 0
97770: PUSH
97771: EMPTY
97772: LIST
97773: LIST
97774: PUSH
97775: LD_INT 3
97777: NEG
97778: PUSH
97779: LD_INT 1
97781: NEG
97782: PUSH
97783: EMPTY
97784: LIST
97785: LIST
97786: PUSH
97787: LD_INT 3
97789: NEG
97790: PUSH
97791: LD_INT 1
97793: PUSH
97794: EMPTY
97795: LIST
97796: LIST
97797: PUSH
97798: LD_INT 4
97800: NEG
97801: PUSH
97802: LD_INT 0
97804: PUSH
97805: EMPTY
97806: LIST
97807: LIST
97808: PUSH
97809: LD_INT 4
97811: NEG
97812: PUSH
97813: LD_INT 1
97815: NEG
97816: PUSH
97817: EMPTY
97818: LIST
97819: LIST
97820: PUSH
97821: LD_INT 4
97823: NEG
97824: PUSH
97825: LD_INT 1
97827: PUSH
97828: EMPTY
97829: LIST
97830: LIST
97831: PUSH
97832: LD_INT 5
97834: NEG
97835: PUSH
97836: LD_INT 0
97838: PUSH
97839: EMPTY
97840: LIST
97841: LIST
97842: PUSH
97843: LD_INT 5
97845: NEG
97846: PUSH
97847: LD_INT 1
97849: NEG
97850: PUSH
97851: EMPTY
97852: LIST
97853: LIST
97854: PUSH
97855: LD_INT 5
97857: NEG
97858: PUSH
97859: LD_INT 1
97861: PUSH
97862: EMPTY
97863: LIST
97864: LIST
97865: PUSH
97866: LD_INT 6
97868: NEG
97869: PUSH
97870: LD_INT 0
97872: PUSH
97873: EMPTY
97874: LIST
97875: LIST
97876: PUSH
97877: LD_INT 6
97879: NEG
97880: PUSH
97881: LD_INT 1
97883: NEG
97884: PUSH
97885: EMPTY
97886: LIST
97887: LIST
97888: PUSH
97889: EMPTY
97890: LIST
97891: LIST
97892: LIST
97893: LIST
97894: LIST
97895: LIST
97896: LIST
97897: LIST
97898: LIST
97899: LIST
97900: LIST
97901: LIST
97902: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
97903: LD_ADDR_VAR 0 34
97907: PUSH
97908: LD_INT 2
97910: NEG
97911: PUSH
97912: LD_INT 3
97914: NEG
97915: PUSH
97916: EMPTY
97917: LIST
97918: LIST
97919: PUSH
97920: LD_INT 3
97922: NEG
97923: PUSH
97924: LD_INT 2
97926: NEG
97927: PUSH
97928: EMPTY
97929: LIST
97930: LIST
97931: PUSH
97932: LD_INT 3
97934: NEG
97935: PUSH
97936: LD_INT 3
97938: NEG
97939: PUSH
97940: EMPTY
97941: LIST
97942: LIST
97943: PUSH
97944: LD_INT 3
97946: NEG
97947: PUSH
97948: LD_INT 4
97950: NEG
97951: PUSH
97952: EMPTY
97953: LIST
97954: LIST
97955: PUSH
97956: LD_INT 4
97958: NEG
97959: PUSH
97960: LD_INT 3
97962: NEG
97963: PUSH
97964: EMPTY
97965: LIST
97966: LIST
97967: PUSH
97968: LD_INT 4
97970: NEG
97971: PUSH
97972: LD_INT 4
97974: NEG
97975: PUSH
97976: EMPTY
97977: LIST
97978: LIST
97979: PUSH
97980: LD_INT 4
97982: NEG
97983: PUSH
97984: LD_INT 5
97986: NEG
97987: PUSH
97988: EMPTY
97989: LIST
97990: LIST
97991: PUSH
97992: LD_INT 5
97994: NEG
97995: PUSH
97996: LD_INT 4
97998: NEG
97999: PUSH
98000: EMPTY
98001: LIST
98002: LIST
98003: PUSH
98004: LD_INT 5
98006: NEG
98007: PUSH
98008: LD_INT 5
98010: NEG
98011: PUSH
98012: EMPTY
98013: LIST
98014: LIST
98015: PUSH
98016: LD_INT 5
98018: NEG
98019: PUSH
98020: LD_INT 6
98022: NEG
98023: PUSH
98024: EMPTY
98025: LIST
98026: LIST
98027: PUSH
98028: LD_INT 6
98030: NEG
98031: PUSH
98032: LD_INT 5
98034: NEG
98035: PUSH
98036: EMPTY
98037: LIST
98038: LIST
98039: PUSH
98040: LD_INT 6
98042: NEG
98043: PUSH
98044: LD_INT 6
98046: NEG
98047: PUSH
98048: EMPTY
98049: LIST
98050: LIST
98051: PUSH
98052: EMPTY
98053: LIST
98054: LIST
98055: LIST
98056: LIST
98057: LIST
98058: LIST
98059: LIST
98060: LIST
98061: LIST
98062: LIST
98063: LIST
98064: LIST
98065: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
98066: LD_ADDR_VAR 0 41
98070: PUSH
98071: LD_INT 0
98073: PUSH
98074: LD_INT 2
98076: NEG
98077: PUSH
98078: EMPTY
98079: LIST
98080: LIST
98081: PUSH
98082: LD_INT 1
98084: NEG
98085: PUSH
98086: LD_INT 3
98088: NEG
98089: PUSH
98090: EMPTY
98091: LIST
98092: LIST
98093: PUSH
98094: LD_INT 1
98096: PUSH
98097: LD_INT 2
98099: NEG
98100: PUSH
98101: EMPTY
98102: LIST
98103: LIST
98104: PUSH
98105: EMPTY
98106: LIST
98107: LIST
98108: LIST
98109: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
98110: LD_ADDR_VAR 0 42
98114: PUSH
98115: LD_INT 2
98117: PUSH
98118: LD_INT 0
98120: PUSH
98121: EMPTY
98122: LIST
98123: LIST
98124: PUSH
98125: LD_INT 2
98127: PUSH
98128: LD_INT 1
98130: NEG
98131: PUSH
98132: EMPTY
98133: LIST
98134: LIST
98135: PUSH
98136: LD_INT 3
98138: PUSH
98139: LD_INT 1
98141: PUSH
98142: EMPTY
98143: LIST
98144: LIST
98145: PUSH
98146: EMPTY
98147: LIST
98148: LIST
98149: LIST
98150: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
98151: LD_ADDR_VAR 0 43
98155: PUSH
98156: LD_INT 2
98158: PUSH
98159: LD_INT 2
98161: PUSH
98162: EMPTY
98163: LIST
98164: LIST
98165: PUSH
98166: LD_INT 3
98168: PUSH
98169: LD_INT 2
98171: PUSH
98172: EMPTY
98173: LIST
98174: LIST
98175: PUSH
98176: LD_INT 2
98178: PUSH
98179: LD_INT 3
98181: PUSH
98182: EMPTY
98183: LIST
98184: LIST
98185: PUSH
98186: EMPTY
98187: LIST
98188: LIST
98189: LIST
98190: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
98191: LD_ADDR_VAR 0 44
98195: PUSH
98196: LD_INT 0
98198: PUSH
98199: LD_INT 2
98201: PUSH
98202: EMPTY
98203: LIST
98204: LIST
98205: PUSH
98206: LD_INT 1
98208: PUSH
98209: LD_INT 3
98211: PUSH
98212: EMPTY
98213: LIST
98214: LIST
98215: PUSH
98216: LD_INT 1
98218: NEG
98219: PUSH
98220: LD_INT 2
98222: PUSH
98223: EMPTY
98224: LIST
98225: LIST
98226: PUSH
98227: EMPTY
98228: LIST
98229: LIST
98230: LIST
98231: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
98232: LD_ADDR_VAR 0 45
98236: PUSH
98237: LD_INT 2
98239: NEG
98240: PUSH
98241: LD_INT 0
98243: PUSH
98244: EMPTY
98245: LIST
98246: LIST
98247: PUSH
98248: LD_INT 2
98250: NEG
98251: PUSH
98252: LD_INT 1
98254: PUSH
98255: EMPTY
98256: LIST
98257: LIST
98258: PUSH
98259: LD_INT 3
98261: NEG
98262: PUSH
98263: LD_INT 1
98265: NEG
98266: PUSH
98267: EMPTY
98268: LIST
98269: LIST
98270: PUSH
98271: EMPTY
98272: LIST
98273: LIST
98274: LIST
98275: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
98276: LD_ADDR_VAR 0 46
98280: PUSH
98281: LD_INT 2
98283: NEG
98284: PUSH
98285: LD_INT 2
98287: NEG
98288: PUSH
98289: EMPTY
98290: LIST
98291: LIST
98292: PUSH
98293: LD_INT 2
98295: NEG
98296: PUSH
98297: LD_INT 3
98299: NEG
98300: PUSH
98301: EMPTY
98302: LIST
98303: LIST
98304: PUSH
98305: LD_INT 3
98307: NEG
98308: PUSH
98309: LD_INT 2
98311: NEG
98312: PUSH
98313: EMPTY
98314: LIST
98315: LIST
98316: PUSH
98317: EMPTY
98318: LIST
98319: LIST
98320: LIST
98321: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
98322: LD_ADDR_VAR 0 47
98326: PUSH
98327: LD_INT 2
98329: NEG
98330: PUSH
98331: LD_INT 3
98333: NEG
98334: PUSH
98335: EMPTY
98336: LIST
98337: LIST
98338: PUSH
98339: LD_INT 1
98341: NEG
98342: PUSH
98343: LD_INT 3
98345: NEG
98346: PUSH
98347: EMPTY
98348: LIST
98349: LIST
98350: PUSH
98351: EMPTY
98352: LIST
98353: LIST
98354: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
98355: LD_ADDR_VAR 0 48
98359: PUSH
98360: LD_INT 1
98362: PUSH
98363: LD_INT 2
98365: NEG
98366: PUSH
98367: EMPTY
98368: LIST
98369: LIST
98370: PUSH
98371: LD_INT 2
98373: PUSH
98374: LD_INT 1
98376: NEG
98377: PUSH
98378: EMPTY
98379: LIST
98380: LIST
98381: PUSH
98382: EMPTY
98383: LIST
98384: LIST
98385: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
98386: LD_ADDR_VAR 0 49
98390: PUSH
98391: LD_INT 3
98393: PUSH
98394: LD_INT 1
98396: PUSH
98397: EMPTY
98398: LIST
98399: LIST
98400: PUSH
98401: LD_INT 3
98403: PUSH
98404: LD_INT 2
98406: PUSH
98407: EMPTY
98408: LIST
98409: LIST
98410: PUSH
98411: EMPTY
98412: LIST
98413: LIST
98414: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
98415: LD_ADDR_VAR 0 50
98419: PUSH
98420: LD_INT 2
98422: PUSH
98423: LD_INT 3
98425: PUSH
98426: EMPTY
98427: LIST
98428: LIST
98429: PUSH
98430: LD_INT 1
98432: PUSH
98433: LD_INT 3
98435: PUSH
98436: EMPTY
98437: LIST
98438: LIST
98439: PUSH
98440: EMPTY
98441: LIST
98442: LIST
98443: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
98444: LD_ADDR_VAR 0 51
98448: PUSH
98449: LD_INT 1
98451: NEG
98452: PUSH
98453: LD_INT 2
98455: PUSH
98456: EMPTY
98457: LIST
98458: LIST
98459: PUSH
98460: LD_INT 2
98462: NEG
98463: PUSH
98464: LD_INT 1
98466: PUSH
98467: EMPTY
98468: LIST
98469: LIST
98470: PUSH
98471: EMPTY
98472: LIST
98473: LIST
98474: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
98475: LD_ADDR_VAR 0 52
98479: PUSH
98480: LD_INT 3
98482: NEG
98483: PUSH
98484: LD_INT 1
98486: NEG
98487: PUSH
98488: EMPTY
98489: LIST
98490: LIST
98491: PUSH
98492: LD_INT 3
98494: NEG
98495: PUSH
98496: LD_INT 2
98498: NEG
98499: PUSH
98500: EMPTY
98501: LIST
98502: LIST
98503: PUSH
98504: EMPTY
98505: LIST
98506: LIST
98507: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
98508: LD_ADDR_VAR 0 53
98512: PUSH
98513: LD_INT 1
98515: NEG
98516: PUSH
98517: LD_INT 3
98519: NEG
98520: PUSH
98521: EMPTY
98522: LIST
98523: LIST
98524: PUSH
98525: LD_INT 0
98527: PUSH
98528: LD_INT 3
98530: NEG
98531: PUSH
98532: EMPTY
98533: LIST
98534: LIST
98535: PUSH
98536: LD_INT 1
98538: PUSH
98539: LD_INT 2
98541: NEG
98542: PUSH
98543: EMPTY
98544: LIST
98545: LIST
98546: PUSH
98547: EMPTY
98548: LIST
98549: LIST
98550: LIST
98551: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
98552: LD_ADDR_VAR 0 54
98556: PUSH
98557: LD_INT 2
98559: PUSH
98560: LD_INT 1
98562: NEG
98563: PUSH
98564: EMPTY
98565: LIST
98566: LIST
98567: PUSH
98568: LD_INT 3
98570: PUSH
98571: LD_INT 0
98573: PUSH
98574: EMPTY
98575: LIST
98576: LIST
98577: PUSH
98578: LD_INT 3
98580: PUSH
98581: LD_INT 1
98583: PUSH
98584: EMPTY
98585: LIST
98586: LIST
98587: PUSH
98588: EMPTY
98589: LIST
98590: LIST
98591: LIST
98592: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
98593: LD_ADDR_VAR 0 55
98597: PUSH
98598: LD_INT 3
98600: PUSH
98601: LD_INT 2
98603: PUSH
98604: EMPTY
98605: LIST
98606: LIST
98607: PUSH
98608: LD_INT 3
98610: PUSH
98611: LD_INT 3
98613: PUSH
98614: EMPTY
98615: LIST
98616: LIST
98617: PUSH
98618: LD_INT 2
98620: PUSH
98621: LD_INT 3
98623: PUSH
98624: EMPTY
98625: LIST
98626: LIST
98627: PUSH
98628: EMPTY
98629: LIST
98630: LIST
98631: LIST
98632: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
98633: LD_ADDR_VAR 0 56
98637: PUSH
98638: LD_INT 1
98640: PUSH
98641: LD_INT 3
98643: PUSH
98644: EMPTY
98645: LIST
98646: LIST
98647: PUSH
98648: LD_INT 0
98650: PUSH
98651: LD_INT 3
98653: PUSH
98654: EMPTY
98655: LIST
98656: LIST
98657: PUSH
98658: LD_INT 1
98660: NEG
98661: PUSH
98662: LD_INT 2
98664: PUSH
98665: EMPTY
98666: LIST
98667: LIST
98668: PUSH
98669: EMPTY
98670: LIST
98671: LIST
98672: LIST
98673: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
98674: LD_ADDR_VAR 0 57
98678: PUSH
98679: LD_INT 2
98681: NEG
98682: PUSH
98683: LD_INT 1
98685: PUSH
98686: EMPTY
98687: LIST
98688: LIST
98689: PUSH
98690: LD_INT 3
98692: NEG
98693: PUSH
98694: LD_INT 0
98696: PUSH
98697: EMPTY
98698: LIST
98699: LIST
98700: PUSH
98701: LD_INT 3
98703: NEG
98704: PUSH
98705: LD_INT 1
98707: NEG
98708: PUSH
98709: EMPTY
98710: LIST
98711: LIST
98712: PUSH
98713: EMPTY
98714: LIST
98715: LIST
98716: LIST
98717: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
98718: LD_ADDR_VAR 0 58
98722: PUSH
98723: LD_INT 2
98725: NEG
98726: PUSH
98727: LD_INT 3
98729: NEG
98730: PUSH
98731: EMPTY
98732: LIST
98733: LIST
98734: PUSH
98735: LD_INT 3
98737: NEG
98738: PUSH
98739: LD_INT 2
98741: NEG
98742: PUSH
98743: EMPTY
98744: LIST
98745: LIST
98746: PUSH
98747: LD_INT 3
98749: NEG
98750: PUSH
98751: LD_INT 3
98753: NEG
98754: PUSH
98755: EMPTY
98756: LIST
98757: LIST
98758: PUSH
98759: EMPTY
98760: LIST
98761: LIST
98762: LIST
98763: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
98764: LD_ADDR_VAR 0 59
98768: PUSH
98769: LD_INT 1
98771: NEG
98772: PUSH
98773: LD_INT 2
98775: NEG
98776: PUSH
98777: EMPTY
98778: LIST
98779: LIST
98780: PUSH
98781: LD_INT 0
98783: PUSH
98784: LD_INT 2
98786: NEG
98787: PUSH
98788: EMPTY
98789: LIST
98790: LIST
98791: PUSH
98792: LD_INT 1
98794: PUSH
98795: LD_INT 1
98797: NEG
98798: PUSH
98799: EMPTY
98800: LIST
98801: LIST
98802: PUSH
98803: EMPTY
98804: LIST
98805: LIST
98806: LIST
98807: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
98808: LD_ADDR_VAR 0 60
98812: PUSH
98813: LD_INT 1
98815: PUSH
98816: LD_INT 1
98818: NEG
98819: PUSH
98820: EMPTY
98821: LIST
98822: LIST
98823: PUSH
98824: LD_INT 2
98826: PUSH
98827: LD_INT 0
98829: PUSH
98830: EMPTY
98831: LIST
98832: LIST
98833: PUSH
98834: LD_INT 2
98836: PUSH
98837: LD_INT 1
98839: PUSH
98840: EMPTY
98841: LIST
98842: LIST
98843: PUSH
98844: EMPTY
98845: LIST
98846: LIST
98847: LIST
98848: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
98849: LD_ADDR_VAR 0 61
98853: PUSH
98854: LD_INT 2
98856: PUSH
98857: LD_INT 1
98859: PUSH
98860: EMPTY
98861: LIST
98862: LIST
98863: PUSH
98864: LD_INT 2
98866: PUSH
98867: LD_INT 2
98869: PUSH
98870: EMPTY
98871: LIST
98872: LIST
98873: PUSH
98874: LD_INT 1
98876: PUSH
98877: LD_INT 2
98879: PUSH
98880: EMPTY
98881: LIST
98882: LIST
98883: PUSH
98884: EMPTY
98885: LIST
98886: LIST
98887: LIST
98888: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
98889: LD_ADDR_VAR 0 62
98893: PUSH
98894: LD_INT 1
98896: PUSH
98897: LD_INT 2
98899: PUSH
98900: EMPTY
98901: LIST
98902: LIST
98903: PUSH
98904: LD_INT 0
98906: PUSH
98907: LD_INT 2
98909: PUSH
98910: EMPTY
98911: LIST
98912: LIST
98913: PUSH
98914: LD_INT 1
98916: NEG
98917: PUSH
98918: LD_INT 1
98920: PUSH
98921: EMPTY
98922: LIST
98923: LIST
98924: PUSH
98925: EMPTY
98926: LIST
98927: LIST
98928: LIST
98929: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
98930: LD_ADDR_VAR 0 63
98934: PUSH
98935: LD_INT 1
98937: NEG
98938: PUSH
98939: LD_INT 1
98941: PUSH
98942: EMPTY
98943: LIST
98944: LIST
98945: PUSH
98946: LD_INT 2
98948: NEG
98949: PUSH
98950: LD_INT 0
98952: PUSH
98953: EMPTY
98954: LIST
98955: LIST
98956: PUSH
98957: LD_INT 2
98959: NEG
98960: PUSH
98961: LD_INT 1
98963: NEG
98964: PUSH
98965: EMPTY
98966: LIST
98967: LIST
98968: PUSH
98969: EMPTY
98970: LIST
98971: LIST
98972: LIST
98973: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
98974: LD_ADDR_VAR 0 64
98978: PUSH
98979: LD_INT 1
98981: NEG
98982: PUSH
98983: LD_INT 2
98985: NEG
98986: PUSH
98987: EMPTY
98988: LIST
98989: LIST
98990: PUSH
98991: LD_INT 2
98993: NEG
98994: PUSH
98995: LD_INT 1
98997: NEG
98998: PUSH
98999: EMPTY
99000: LIST
99001: LIST
99002: PUSH
99003: LD_INT 2
99005: NEG
99006: PUSH
99007: LD_INT 2
99009: NEG
99010: PUSH
99011: EMPTY
99012: LIST
99013: LIST
99014: PUSH
99015: EMPTY
99016: LIST
99017: LIST
99018: LIST
99019: ST_TO_ADDR
// end ; 2 :
99020: GO 102286
99022: LD_INT 2
99024: DOUBLE
99025: EQUAL
99026: IFTRUE 99030
99028: GO 102285
99030: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
99031: LD_ADDR_VAR 0 29
99035: PUSH
99036: LD_INT 4
99038: PUSH
99039: LD_INT 0
99041: PUSH
99042: EMPTY
99043: LIST
99044: LIST
99045: PUSH
99046: LD_INT 4
99048: PUSH
99049: LD_INT 1
99051: NEG
99052: PUSH
99053: EMPTY
99054: LIST
99055: LIST
99056: PUSH
99057: LD_INT 5
99059: PUSH
99060: LD_INT 0
99062: PUSH
99063: EMPTY
99064: LIST
99065: LIST
99066: PUSH
99067: LD_INT 5
99069: PUSH
99070: LD_INT 1
99072: PUSH
99073: EMPTY
99074: LIST
99075: LIST
99076: PUSH
99077: LD_INT 4
99079: PUSH
99080: LD_INT 1
99082: PUSH
99083: EMPTY
99084: LIST
99085: LIST
99086: PUSH
99087: LD_INT 3
99089: PUSH
99090: LD_INT 0
99092: PUSH
99093: EMPTY
99094: LIST
99095: LIST
99096: PUSH
99097: LD_INT 3
99099: PUSH
99100: LD_INT 1
99102: NEG
99103: PUSH
99104: EMPTY
99105: LIST
99106: LIST
99107: PUSH
99108: LD_INT 3
99110: PUSH
99111: LD_INT 2
99113: NEG
99114: PUSH
99115: EMPTY
99116: LIST
99117: LIST
99118: PUSH
99119: LD_INT 5
99121: PUSH
99122: LD_INT 2
99124: PUSH
99125: EMPTY
99126: LIST
99127: LIST
99128: PUSH
99129: LD_INT 3
99131: PUSH
99132: LD_INT 3
99134: PUSH
99135: EMPTY
99136: LIST
99137: LIST
99138: PUSH
99139: LD_INT 3
99141: PUSH
99142: LD_INT 2
99144: PUSH
99145: EMPTY
99146: LIST
99147: LIST
99148: PUSH
99149: LD_INT 4
99151: PUSH
99152: LD_INT 3
99154: PUSH
99155: EMPTY
99156: LIST
99157: LIST
99158: PUSH
99159: LD_INT 4
99161: PUSH
99162: LD_INT 4
99164: PUSH
99165: EMPTY
99166: LIST
99167: LIST
99168: PUSH
99169: LD_INT 3
99171: PUSH
99172: LD_INT 4
99174: PUSH
99175: EMPTY
99176: LIST
99177: LIST
99178: PUSH
99179: LD_INT 2
99181: PUSH
99182: LD_INT 3
99184: PUSH
99185: EMPTY
99186: LIST
99187: LIST
99188: PUSH
99189: LD_INT 2
99191: PUSH
99192: LD_INT 2
99194: PUSH
99195: EMPTY
99196: LIST
99197: LIST
99198: PUSH
99199: LD_INT 4
99201: PUSH
99202: LD_INT 2
99204: PUSH
99205: EMPTY
99206: LIST
99207: LIST
99208: PUSH
99209: LD_INT 2
99211: PUSH
99212: LD_INT 4
99214: PUSH
99215: EMPTY
99216: LIST
99217: LIST
99218: PUSH
99219: LD_INT 0
99221: PUSH
99222: LD_INT 4
99224: PUSH
99225: EMPTY
99226: LIST
99227: LIST
99228: PUSH
99229: LD_INT 0
99231: PUSH
99232: LD_INT 3
99234: PUSH
99235: EMPTY
99236: LIST
99237: LIST
99238: PUSH
99239: LD_INT 1
99241: PUSH
99242: LD_INT 4
99244: PUSH
99245: EMPTY
99246: LIST
99247: LIST
99248: PUSH
99249: LD_INT 1
99251: PUSH
99252: LD_INT 5
99254: PUSH
99255: EMPTY
99256: LIST
99257: LIST
99258: PUSH
99259: LD_INT 0
99261: PUSH
99262: LD_INT 5
99264: PUSH
99265: EMPTY
99266: LIST
99267: LIST
99268: PUSH
99269: LD_INT 1
99271: NEG
99272: PUSH
99273: LD_INT 4
99275: PUSH
99276: EMPTY
99277: LIST
99278: LIST
99279: PUSH
99280: LD_INT 1
99282: NEG
99283: PUSH
99284: LD_INT 3
99286: PUSH
99287: EMPTY
99288: LIST
99289: LIST
99290: PUSH
99291: LD_INT 2
99293: PUSH
99294: LD_INT 5
99296: PUSH
99297: EMPTY
99298: LIST
99299: LIST
99300: PUSH
99301: LD_INT 2
99303: NEG
99304: PUSH
99305: LD_INT 3
99307: PUSH
99308: EMPTY
99309: LIST
99310: LIST
99311: PUSH
99312: LD_INT 3
99314: NEG
99315: PUSH
99316: LD_INT 0
99318: PUSH
99319: EMPTY
99320: LIST
99321: LIST
99322: PUSH
99323: LD_INT 3
99325: NEG
99326: PUSH
99327: LD_INT 1
99329: NEG
99330: PUSH
99331: EMPTY
99332: LIST
99333: LIST
99334: PUSH
99335: LD_INT 2
99337: NEG
99338: PUSH
99339: LD_INT 0
99341: PUSH
99342: EMPTY
99343: LIST
99344: LIST
99345: PUSH
99346: LD_INT 2
99348: NEG
99349: PUSH
99350: LD_INT 1
99352: PUSH
99353: EMPTY
99354: LIST
99355: LIST
99356: PUSH
99357: LD_INT 3
99359: NEG
99360: PUSH
99361: LD_INT 1
99363: PUSH
99364: EMPTY
99365: LIST
99366: LIST
99367: PUSH
99368: LD_INT 4
99370: NEG
99371: PUSH
99372: LD_INT 0
99374: PUSH
99375: EMPTY
99376: LIST
99377: LIST
99378: PUSH
99379: LD_INT 4
99381: NEG
99382: PUSH
99383: LD_INT 1
99385: NEG
99386: PUSH
99387: EMPTY
99388: LIST
99389: LIST
99390: PUSH
99391: LD_INT 4
99393: NEG
99394: PUSH
99395: LD_INT 2
99397: NEG
99398: PUSH
99399: EMPTY
99400: LIST
99401: LIST
99402: PUSH
99403: LD_INT 2
99405: NEG
99406: PUSH
99407: LD_INT 2
99409: PUSH
99410: EMPTY
99411: LIST
99412: LIST
99413: PUSH
99414: LD_INT 4
99416: NEG
99417: PUSH
99418: LD_INT 4
99420: NEG
99421: PUSH
99422: EMPTY
99423: LIST
99424: LIST
99425: PUSH
99426: LD_INT 4
99428: NEG
99429: PUSH
99430: LD_INT 5
99432: NEG
99433: PUSH
99434: EMPTY
99435: LIST
99436: LIST
99437: PUSH
99438: LD_INT 3
99440: NEG
99441: PUSH
99442: LD_INT 4
99444: NEG
99445: PUSH
99446: EMPTY
99447: LIST
99448: LIST
99449: PUSH
99450: LD_INT 3
99452: NEG
99453: PUSH
99454: LD_INT 3
99456: NEG
99457: PUSH
99458: EMPTY
99459: LIST
99460: LIST
99461: PUSH
99462: LD_INT 4
99464: NEG
99465: PUSH
99466: LD_INT 3
99468: NEG
99469: PUSH
99470: EMPTY
99471: LIST
99472: LIST
99473: PUSH
99474: LD_INT 5
99476: NEG
99477: PUSH
99478: LD_INT 4
99480: NEG
99481: PUSH
99482: EMPTY
99483: LIST
99484: LIST
99485: PUSH
99486: LD_INT 5
99488: NEG
99489: PUSH
99490: LD_INT 5
99492: NEG
99493: PUSH
99494: EMPTY
99495: LIST
99496: LIST
99497: PUSH
99498: LD_INT 3
99500: NEG
99501: PUSH
99502: LD_INT 5
99504: NEG
99505: PUSH
99506: EMPTY
99507: LIST
99508: LIST
99509: PUSH
99510: LD_INT 5
99512: NEG
99513: PUSH
99514: LD_INT 3
99516: NEG
99517: PUSH
99518: EMPTY
99519: LIST
99520: LIST
99521: PUSH
99522: EMPTY
99523: LIST
99524: LIST
99525: LIST
99526: LIST
99527: LIST
99528: LIST
99529: LIST
99530: LIST
99531: LIST
99532: LIST
99533: LIST
99534: LIST
99535: LIST
99536: LIST
99537: LIST
99538: LIST
99539: LIST
99540: LIST
99541: LIST
99542: LIST
99543: LIST
99544: LIST
99545: LIST
99546: LIST
99547: LIST
99548: LIST
99549: LIST
99550: LIST
99551: LIST
99552: LIST
99553: LIST
99554: LIST
99555: LIST
99556: LIST
99557: LIST
99558: LIST
99559: LIST
99560: LIST
99561: LIST
99562: LIST
99563: LIST
99564: LIST
99565: LIST
99566: LIST
99567: LIST
99568: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
99569: LD_ADDR_VAR 0 30
99573: PUSH
99574: LD_INT 4
99576: PUSH
99577: LD_INT 4
99579: PUSH
99580: EMPTY
99581: LIST
99582: LIST
99583: PUSH
99584: LD_INT 4
99586: PUSH
99587: LD_INT 3
99589: PUSH
99590: EMPTY
99591: LIST
99592: LIST
99593: PUSH
99594: LD_INT 5
99596: PUSH
99597: LD_INT 4
99599: PUSH
99600: EMPTY
99601: LIST
99602: LIST
99603: PUSH
99604: LD_INT 5
99606: PUSH
99607: LD_INT 5
99609: PUSH
99610: EMPTY
99611: LIST
99612: LIST
99613: PUSH
99614: LD_INT 4
99616: PUSH
99617: LD_INT 5
99619: PUSH
99620: EMPTY
99621: LIST
99622: LIST
99623: PUSH
99624: LD_INT 3
99626: PUSH
99627: LD_INT 4
99629: PUSH
99630: EMPTY
99631: LIST
99632: LIST
99633: PUSH
99634: LD_INT 3
99636: PUSH
99637: LD_INT 3
99639: PUSH
99640: EMPTY
99641: LIST
99642: LIST
99643: PUSH
99644: LD_INT 5
99646: PUSH
99647: LD_INT 3
99649: PUSH
99650: EMPTY
99651: LIST
99652: LIST
99653: PUSH
99654: LD_INT 3
99656: PUSH
99657: LD_INT 5
99659: PUSH
99660: EMPTY
99661: LIST
99662: LIST
99663: PUSH
99664: LD_INT 0
99666: PUSH
99667: LD_INT 3
99669: PUSH
99670: EMPTY
99671: LIST
99672: LIST
99673: PUSH
99674: LD_INT 0
99676: PUSH
99677: LD_INT 2
99679: PUSH
99680: EMPTY
99681: LIST
99682: LIST
99683: PUSH
99684: LD_INT 1
99686: PUSH
99687: LD_INT 3
99689: PUSH
99690: EMPTY
99691: LIST
99692: LIST
99693: PUSH
99694: LD_INT 1
99696: PUSH
99697: LD_INT 4
99699: PUSH
99700: EMPTY
99701: LIST
99702: LIST
99703: PUSH
99704: LD_INT 0
99706: PUSH
99707: LD_INT 4
99709: PUSH
99710: EMPTY
99711: LIST
99712: LIST
99713: PUSH
99714: LD_INT 1
99716: NEG
99717: PUSH
99718: LD_INT 3
99720: PUSH
99721: EMPTY
99722: LIST
99723: LIST
99724: PUSH
99725: LD_INT 1
99727: NEG
99728: PUSH
99729: LD_INT 2
99731: PUSH
99732: EMPTY
99733: LIST
99734: LIST
99735: PUSH
99736: LD_INT 2
99738: PUSH
99739: LD_INT 4
99741: PUSH
99742: EMPTY
99743: LIST
99744: LIST
99745: PUSH
99746: LD_INT 2
99748: NEG
99749: PUSH
99750: LD_INT 2
99752: PUSH
99753: EMPTY
99754: LIST
99755: LIST
99756: PUSH
99757: LD_INT 4
99759: NEG
99760: PUSH
99761: LD_INT 0
99763: PUSH
99764: EMPTY
99765: LIST
99766: LIST
99767: PUSH
99768: LD_INT 4
99770: NEG
99771: PUSH
99772: LD_INT 1
99774: NEG
99775: PUSH
99776: EMPTY
99777: LIST
99778: LIST
99779: PUSH
99780: LD_INT 3
99782: NEG
99783: PUSH
99784: LD_INT 0
99786: PUSH
99787: EMPTY
99788: LIST
99789: LIST
99790: PUSH
99791: LD_INT 3
99793: NEG
99794: PUSH
99795: LD_INT 1
99797: PUSH
99798: EMPTY
99799: LIST
99800: LIST
99801: PUSH
99802: LD_INT 4
99804: NEG
99805: PUSH
99806: LD_INT 1
99808: PUSH
99809: EMPTY
99810: LIST
99811: LIST
99812: PUSH
99813: LD_INT 5
99815: NEG
99816: PUSH
99817: LD_INT 0
99819: PUSH
99820: EMPTY
99821: LIST
99822: LIST
99823: PUSH
99824: LD_INT 5
99826: NEG
99827: PUSH
99828: LD_INT 1
99830: NEG
99831: PUSH
99832: EMPTY
99833: LIST
99834: LIST
99835: PUSH
99836: LD_INT 5
99838: NEG
99839: PUSH
99840: LD_INT 2
99842: NEG
99843: PUSH
99844: EMPTY
99845: LIST
99846: LIST
99847: PUSH
99848: LD_INT 3
99850: NEG
99851: PUSH
99852: LD_INT 2
99854: PUSH
99855: EMPTY
99856: LIST
99857: LIST
99858: PUSH
99859: LD_INT 3
99861: NEG
99862: PUSH
99863: LD_INT 3
99865: NEG
99866: PUSH
99867: EMPTY
99868: LIST
99869: LIST
99870: PUSH
99871: LD_INT 3
99873: NEG
99874: PUSH
99875: LD_INT 4
99877: NEG
99878: PUSH
99879: EMPTY
99880: LIST
99881: LIST
99882: PUSH
99883: LD_INT 2
99885: NEG
99886: PUSH
99887: LD_INT 3
99889: NEG
99890: PUSH
99891: EMPTY
99892: LIST
99893: LIST
99894: PUSH
99895: LD_INT 2
99897: NEG
99898: PUSH
99899: LD_INT 2
99901: NEG
99902: PUSH
99903: EMPTY
99904: LIST
99905: LIST
99906: PUSH
99907: LD_INT 3
99909: NEG
99910: PUSH
99911: LD_INT 2
99913: NEG
99914: PUSH
99915: EMPTY
99916: LIST
99917: LIST
99918: PUSH
99919: LD_INT 4
99921: NEG
99922: PUSH
99923: LD_INT 3
99925: NEG
99926: PUSH
99927: EMPTY
99928: LIST
99929: LIST
99930: PUSH
99931: LD_INT 4
99933: NEG
99934: PUSH
99935: LD_INT 4
99937: NEG
99938: PUSH
99939: EMPTY
99940: LIST
99941: LIST
99942: PUSH
99943: LD_INT 2
99945: NEG
99946: PUSH
99947: LD_INT 4
99949: NEG
99950: PUSH
99951: EMPTY
99952: LIST
99953: LIST
99954: PUSH
99955: LD_INT 4
99957: NEG
99958: PUSH
99959: LD_INT 2
99961: NEG
99962: PUSH
99963: EMPTY
99964: LIST
99965: LIST
99966: PUSH
99967: LD_INT 0
99969: PUSH
99970: LD_INT 4
99972: NEG
99973: PUSH
99974: EMPTY
99975: LIST
99976: LIST
99977: PUSH
99978: LD_INT 0
99980: PUSH
99981: LD_INT 5
99983: NEG
99984: PUSH
99985: EMPTY
99986: LIST
99987: LIST
99988: PUSH
99989: LD_INT 1
99991: PUSH
99992: LD_INT 4
99994: NEG
99995: PUSH
99996: EMPTY
99997: LIST
99998: LIST
99999: PUSH
100000: LD_INT 1
100002: PUSH
100003: LD_INT 3
100005: NEG
100006: PUSH
100007: EMPTY
100008: LIST
100009: LIST
100010: PUSH
100011: LD_INT 0
100013: PUSH
100014: LD_INT 3
100016: NEG
100017: PUSH
100018: EMPTY
100019: LIST
100020: LIST
100021: PUSH
100022: LD_INT 1
100024: NEG
100025: PUSH
100026: LD_INT 4
100028: NEG
100029: PUSH
100030: EMPTY
100031: LIST
100032: LIST
100033: PUSH
100034: LD_INT 1
100036: NEG
100037: PUSH
100038: LD_INT 5
100040: NEG
100041: PUSH
100042: EMPTY
100043: LIST
100044: LIST
100045: PUSH
100046: LD_INT 2
100048: PUSH
100049: LD_INT 3
100051: NEG
100052: PUSH
100053: EMPTY
100054: LIST
100055: LIST
100056: PUSH
100057: LD_INT 2
100059: NEG
100060: PUSH
100061: LD_INT 5
100063: NEG
100064: PUSH
100065: EMPTY
100066: LIST
100067: LIST
100068: PUSH
100069: EMPTY
100070: LIST
100071: LIST
100072: LIST
100073: LIST
100074: LIST
100075: LIST
100076: LIST
100077: LIST
100078: LIST
100079: LIST
100080: LIST
100081: LIST
100082: LIST
100083: LIST
100084: LIST
100085: LIST
100086: LIST
100087: LIST
100088: LIST
100089: LIST
100090: LIST
100091: LIST
100092: LIST
100093: LIST
100094: LIST
100095: LIST
100096: LIST
100097: LIST
100098: LIST
100099: LIST
100100: LIST
100101: LIST
100102: LIST
100103: LIST
100104: LIST
100105: LIST
100106: LIST
100107: LIST
100108: LIST
100109: LIST
100110: LIST
100111: LIST
100112: LIST
100113: LIST
100114: LIST
100115: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
100116: LD_ADDR_VAR 0 31
100120: PUSH
100121: LD_INT 0
100123: PUSH
100124: LD_INT 4
100126: PUSH
100127: EMPTY
100128: LIST
100129: LIST
100130: PUSH
100131: LD_INT 0
100133: PUSH
100134: LD_INT 3
100136: PUSH
100137: EMPTY
100138: LIST
100139: LIST
100140: PUSH
100141: LD_INT 1
100143: PUSH
100144: LD_INT 4
100146: PUSH
100147: EMPTY
100148: LIST
100149: LIST
100150: PUSH
100151: LD_INT 1
100153: PUSH
100154: LD_INT 5
100156: PUSH
100157: EMPTY
100158: LIST
100159: LIST
100160: PUSH
100161: LD_INT 0
100163: PUSH
100164: LD_INT 5
100166: PUSH
100167: EMPTY
100168: LIST
100169: LIST
100170: PUSH
100171: LD_INT 1
100173: NEG
100174: PUSH
100175: LD_INT 4
100177: PUSH
100178: EMPTY
100179: LIST
100180: LIST
100181: PUSH
100182: LD_INT 1
100184: NEG
100185: PUSH
100186: LD_INT 3
100188: PUSH
100189: EMPTY
100190: LIST
100191: LIST
100192: PUSH
100193: LD_INT 2
100195: PUSH
100196: LD_INT 5
100198: PUSH
100199: EMPTY
100200: LIST
100201: LIST
100202: PUSH
100203: LD_INT 2
100205: NEG
100206: PUSH
100207: LD_INT 3
100209: PUSH
100210: EMPTY
100211: LIST
100212: LIST
100213: PUSH
100214: LD_INT 3
100216: NEG
100217: PUSH
100218: LD_INT 0
100220: PUSH
100221: EMPTY
100222: LIST
100223: LIST
100224: PUSH
100225: LD_INT 3
100227: NEG
100228: PUSH
100229: LD_INT 1
100231: NEG
100232: PUSH
100233: EMPTY
100234: LIST
100235: LIST
100236: PUSH
100237: LD_INT 2
100239: NEG
100240: PUSH
100241: LD_INT 0
100243: PUSH
100244: EMPTY
100245: LIST
100246: LIST
100247: PUSH
100248: LD_INT 2
100250: NEG
100251: PUSH
100252: LD_INT 1
100254: PUSH
100255: EMPTY
100256: LIST
100257: LIST
100258: PUSH
100259: LD_INT 3
100261: NEG
100262: PUSH
100263: LD_INT 1
100265: PUSH
100266: EMPTY
100267: LIST
100268: LIST
100269: PUSH
100270: LD_INT 4
100272: NEG
100273: PUSH
100274: LD_INT 0
100276: PUSH
100277: EMPTY
100278: LIST
100279: LIST
100280: PUSH
100281: LD_INT 4
100283: NEG
100284: PUSH
100285: LD_INT 1
100287: NEG
100288: PUSH
100289: EMPTY
100290: LIST
100291: LIST
100292: PUSH
100293: LD_INT 4
100295: NEG
100296: PUSH
100297: LD_INT 2
100299: NEG
100300: PUSH
100301: EMPTY
100302: LIST
100303: LIST
100304: PUSH
100305: LD_INT 2
100307: NEG
100308: PUSH
100309: LD_INT 2
100311: PUSH
100312: EMPTY
100313: LIST
100314: LIST
100315: PUSH
100316: LD_INT 4
100318: NEG
100319: PUSH
100320: LD_INT 4
100322: NEG
100323: PUSH
100324: EMPTY
100325: LIST
100326: LIST
100327: PUSH
100328: LD_INT 4
100330: NEG
100331: PUSH
100332: LD_INT 5
100334: NEG
100335: PUSH
100336: EMPTY
100337: LIST
100338: LIST
100339: PUSH
100340: LD_INT 3
100342: NEG
100343: PUSH
100344: LD_INT 4
100346: NEG
100347: PUSH
100348: EMPTY
100349: LIST
100350: LIST
100351: PUSH
100352: LD_INT 3
100354: NEG
100355: PUSH
100356: LD_INT 3
100358: NEG
100359: PUSH
100360: EMPTY
100361: LIST
100362: LIST
100363: PUSH
100364: LD_INT 4
100366: NEG
100367: PUSH
100368: LD_INT 3
100370: NEG
100371: PUSH
100372: EMPTY
100373: LIST
100374: LIST
100375: PUSH
100376: LD_INT 5
100378: NEG
100379: PUSH
100380: LD_INT 4
100382: NEG
100383: PUSH
100384: EMPTY
100385: LIST
100386: LIST
100387: PUSH
100388: LD_INT 5
100390: NEG
100391: PUSH
100392: LD_INT 5
100394: NEG
100395: PUSH
100396: EMPTY
100397: LIST
100398: LIST
100399: PUSH
100400: LD_INT 3
100402: NEG
100403: PUSH
100404: LD_INT 5
100406: NEG
100407: PUSH
100408: EMPTY
100409: LIST
100410: LIST
100411: PUSH
100412: LD_INT 5
100414: NEG
100415: PUSH
100416: LD_INT 3
100418: NEG
100419: PUSH
100420: EMPTY
100421: LIST
100422: LIST
100423: PUSH
100424: LD_INT 0
100426: PUSH
100427: LD_INT 3
100429: NEG
100430: PUSH
100431: EMPTY
100432: LIST
100433: LIST
100434: PUSH
100435: LD_INT 0
100437: PUSH
100438: LD_INT 4
100440: NEG
100441: PUSH
100442: EMPTY
100443: LIST
100444: LIST
100445: PUSH
100446: LD_INT 1
100448: PUSH
100449: LD_INT 3
100451: NEG
100452: PUSH
100453: EMPTY
100454: LIST
100455: LIST
100456: PUSH
100457: LD_INT 1
100459: PUSH
100460: LD_INT 2
100462: NEG
100463: PUSH
100464: EMPTY
100465: LIST
100466: LIST
100467: PUSH
100468: LD_INT 0
100470: PUSH
100471: LD_INT 2
100473: NEG
100474: PUSH
100475: EMPTY
100476: LIST
100477: LIST
100478: PUSH
100479: LD_INT 1
100481: NEG
100482: PUSH
100483: LD_INT 3
100485: NEG
100486: PUSH
100487: EMPTY
100488: LIST
100489: LIST
100490: PUSH
100491: LD_INT 1
100493: NEG
100494: PUSH
100495: LD_INT 4
100497: NEG
100498: PUSH
100499: EMPTY
100500: LIST
100501: LIST
100502: PUSH
100503: LD_INT 2
100505: PUSH
100506: LD_INT 2
100508: NEG
100509: PUSH
100510: EMPTY
100511: LIST
100512: LIST
100513: PUSH
100514: LD_INT 2
100516: NEG
100517: PUSH
100518: LD_INT 4
100520: NEG
100521: PUSH
100522: EMPTY
100523: LIST
100524: LIST
100525: PUSH
100526: LD_INT 4
100528: PUSH
100529: LD_INT 0
100531: PUSH
100532: EMPTY
100533: LIST
100534: LIST
100535: PUSH
100536: LD_INT 4
100538: PUSH
100539: LD_INT 1
100541: NEG
100542: PUSH
100543: EMPTY
100544: LIST
100545: LIST
100546: PUSH
100547: LD_INT 5
100549: PUSH
100550: LD_INT 0
100552: PUSH
100553: EMPTY
100554: LIST
100555: LIST
100556: PUSH
100557: LD_INT 5
100559: PUSH
100560: LD_INT 1
100562: PUSH
100563: EMPTY
100564: LIST
100565: LIST
100566: PUSH
100567: LD_INT 4
100569: PUSH
100570: LD_INT 1
100572: PUSH
100573: EMPTY
100574: LIST
100575: LIST
100576: PUSH
100577: LD_INT 3
100579: PUSH
100580: LD_INT 0
100582: PUSH
100583: EMPTY
100584: LIST
100585: LIST
100586: PUSH
100587: LD_INT 3
100589: PUSH
100590: LD_INT 1
100592: NEG
100593: PUSH
100594: EMPTY
100595: LIST
100596: LIST
100597: PUSH
100598: LD_INT 3
100600: PUSH
100601: LD_INT 2
100603: NEG
100604: PUSH
100605: EMPTY
100606: LIST
100607: LIST
100608: PUSH
100609: LD_INT 5
100611: PUSH
100612: LD_INT 2
100614: PUSH
100615: EMPTY
100616: LIST
100617: LIST
100618: PUSH
100619: EMPTY
100620: LIST
100621: LIST
100622: LIST
100623: LIST
100624: LIST
100625: LIST
100626: LIST
100627: LIST
100628: LIST
100629: LIST
100630: LIST
100631: LIST
100632: LIST
100633: LIST
100634: LIST
100635: LIST
100636: LIST
100637: LIST
100638: LIST
100639: LIST
100640: LIST
100641: LIST
100642: LIST
100643: LIST
100644: LIST
100645: LIST
100646: LIST
100647: LIST
100648: LIST
100649: LIST
100650: LIST
100651: LIST
100652: LIST
100653: LIST
100654: LIST
100655: LIST
100656: LIST
100657: LIST
100658: LIST
100659: LIST
100660: LIST
100661: LIST
100662: LIST
100663: LIST
100664: LIST
100665: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
100666: LD_ADDR_VAR 0 32
100670: PUSH
100671: LD_INT 4
100673: NEG
100674: PUSH
100675: LD_INT 0
100677: PUSH
100678: EMPTY
100679: LIST
100680: LIST
100681: PUSH
100682: LD_INT 4
100684: NEG
100685: PUSH
100686: LD_INT 1
100688: NEG
100689: PUSH
100690: EMPTY
100691: LIST
100692: LIST
100693: PUSH
100694: LD_INT 3
100696: NEG
100697: PUSH
100698: LD_INT 0
100700: PUSH
100701: EMPTY
100702: LIST
100703: LIST
100704: PUSH
100705: LD_INT 3
100707: NEG
100708: PUSH
100709: LD_INT 1
100711: PUSH
100712: EMPTY
100713: LIST
100714: LIST
100715: PUSH
100716: LD_INT 4
100718: NEG
100719: PUSH
100720: LD_INT 1
100722: PUSH
100723: EMPTY
100724: LIST
100725: LIST
100726: PUSH
100727: LD_INT 5
100729: NEG
100730: PUSH
100731: LD_INT 0
100733: PUSH
100734: EMPTY
100735: LIST
100736: LIST
100737: PUSH
100738: LD_INT 5
100740: NEG
100741: PUSH
100742: LD_INT 1
100744: NEG
100745: PUSH
100746: EMPTY
100747: LIST
100748: LIST
100749: PUSH
100750: LD_INT 5
100752: NEG
100753: PUSH
100754: LD_INT 2
100756: NEG
100757: PUSH
100758: EMPTY
100759: LIST
100760: LIST
100761: PUSH
100762: LD_INT 3
100764: NEG
100765: PUSH
100766: LD_INT 2
100768: PUSH
100769: EMPTY
100770: LIST
100771: LIST
100772: PUSH
100773: LD_INT 3
100775: NEG
100776: PUSH
100777: LD_INT 3
100779: NEG
100780: PUSH
100781: EMPTY
100782: LIST
100783: LIST
100784: PUSH
100785: LD_INT 3
100787: NEG
100788: PUSH
100789: LD_INT 4
100791: NEG
100792: PUSH
100793: EMPTY
100794: LIST
100795: LIST
100796: PUSH
100797: LD_INT 2
100799: NEG
100800: PUSH
100801: LD_INT 3
100803: NEG
100804: PUSH
100805: EMPTY
100806: LIST
100807: LIST
100808: PUSH
100809: LD_INT 2
100811: NEG
100812: PUSH
100813: LD_INT 2
100815: NEG
100816: PUSH
100817: EMPTY
100818: LIST
100819: LIST
100820: PUSH
100821: LD_INT 3
100823: NEG
100824: PUSH
100825: LD_INT 2
100827: NEG
100828: PUSH
100829: EMPTY
100830: LIST
100831: LIST
100832: PUSH
100833: LD_INT 4
100835: NEG
100836: PUSH
100837: LD_INT 3
100839: NEG
100840: PUSH
100841: EMPTY
100842: LIST
100843: LIST
100844: PUSH
100845: LD_INT 4
100847: NEG
100848: PUSH
100849: LD_INT 4
100851: NEG
100852: PUSH
100853: EMPTY
100854: LIST
100855: LIST
100856: PUSH
100857: LD_INT 2
100859: NEG
100860: PUSH
100861: LD_INT 4
100863: NEG
100864: PUSH
100865: EMPTY
100866: LIST
100867: LIST
100868: PUSH
100869: LD_INT 4
100871: NEG
100872: PUSH
100873: LD_INT 2
100875: NEG
100876: PUSH
100877: EMPTY
100878: LIST
100879: LIST
100880: PUSH
100881: LD_INT 0
100883: PUSH
100884: LD_INT 4
100886: NEG
100887: PUSH
100888: EMPTY
100889: LIST
100890: LIST
100891: PUSH
100892: LD_INT 0
100894: PUSH
100895: LD_INT 5
100897: NEG
100898: PUSH
100899: EMPTY
100900: LIST
100901: LIST
100902: PUSH
100903: LD_INT 1
100905: PUSH
100906: LD_INT 4
100908: NEG
100909: PUSH
100910: EMPTY
100911: LIST
100912: LIST
100913: PUSH
100914: LD_INT 1
100916: PUSH
100917: LD_INT 3
100919: NEG
100920: PUSH
100921: EMPTY
100922: LIST
100923: LIST
100924: PUSH
100925: LD_INT 0
100927: PUSH
100928: LD_INT 3
100930: NEG
100931: PUSH
100932: EMPTY
100933: LIST
100934: LIST
100935: PUSH
100936: LD_INT 1
100938: NEG
100939: PUSH
100940: LD_INT 4
100942: NEG
100943: PUSH
100944: EMPTY
100945: LIST
100946: LIST
100947: PUSH
100948: LD_INT 1
100950: NEG
100951: PUSH
100952: LD_INT 5
100954: NEG
100955: PUSH
100956: EMPTY
100957: LIST
100958: LIST
100959: PUSH
100960: LD_INT 2
100962: PUSH
100963: LD_INT 3
100965: NEG
100966: PUSH
100967: EMPTY
100968: LIST
100969: LIST
100970: PUSH
100971: LD_INT 2
100973: NEG
100974: PUSH
100975: LD_INT 5
100977: NEG
100978: PUSH
100979: EMPTY
100980: LIST
100981: LIST
100982: PUSH
100983: LD_INT 3
100985: PUSH
100986: LD_INT 0
100988: PUSH
100989: EMPTY
100990: LIST
100991: LIST
100992: PUSH
100993: LD_INT 3
100995: PUSH
100996: LD_INT 1
100998: NEG
100999: PUSH
101000: EMPTY
101001: LIST
101002: LIST
101003: PUSH
101004: LD_INT 4
101006: PUSH
101007: LD_INT 0
101009: PUSH
101010: EMPTY
101011: LIST
101012: LIST
101013: PUSH
101014: LD_INT 4
101016: PUSH
101017: LD_INT 1
101019: PUSH
101020: EMPTY
101021: LIST
101022: LIST
101023: PUSH
101024: LD_INT 3
101026: PUSH
101027: LD_INT 1
101029: PUSH
101030: EMPTY
101031: LIST
101032: LIST
101033: PUSH
101034: LD_INT 2
101036: PUSH
101037: LD_INT 0
101039: PUSH
101040: EMPTY
101041: LIST
101042: LIST
101043: PUSH
101044: LD_INT 2
101046: PUSH
101047: LD_INT 1
101049: NEG
101050: PUSH
101051: EMPTY
101052: LIST
101053: LIST
101054: PUSH
101055: LD_INT 2
101057: PUSH
101058: LD_INT 2
101060: NEG
101061: PUSH
101062: EMPTY
101063: LIST
101064: LIST
101065: PUSH
101066: LD_INT 4
101068: PUSH
101069: LD_INT 2
101071: PUSH
101072: EMPTY
101073: LIST
101074: LIST
101075: PUSH
101076: LD_INT 4
101078: PUSH
101079: LD_INT 4
101081: PUSH
101082: EMPTY
101083: LIST
101084: LIST
101085: PUSH
101086: LD_INT 4
101088: PUSH
101089: LD_INT 3
101091: PUSH
101092: EMPTY
101093: LIST
101094: LIST
101095: PUSH
101096: LD_INT 5
101098: PUSH
101099: LD_INT 4
101101: PUSH
101102: EMPTY
101103: LIST
101104: LIST
101105: PUSH
101106: LD_INT 5
101108: PUSH
101109: LD_INT 5
101111: PUSH
101112: EMPTY
101113: LIST
101114: LIST
101115: PUSH
101116: LD_INT 4
101118: PUSH
101119: LD_INT 5
101121: PUSH
101122: EMPTY
101123: LIST
101124: LIST
101125: PUSH
101126: LD_INT 3
101128: PUSH
101129: LD_INT 4
101131: PUSH
101132: EMPTY
101133: LIST
101134: LIST
101135: PUSH
101136: LD_INT 3
101138: PUSH
101139: LD_INT 3
101141: PUSH
101142: EMPTY
101143: LIST
101144: LIST
101145: PUSH
101146: LD_INT 5
101148: PUSH
101149: LD_INT 3
101151: PUSH
101152: EMPTY
101153: LIST
101154: LIST
101155: PUSH
101156: LD_INT 3
101158: PUSH
101159: LD_INT 5
101161: PUSH
101162: EMPTY
101163: LIST
101164: LIST
101165: PUSH
101166: EMPTY
101167: LIST
101168: LIST
101169: LIST
101170: LIST
101171: LIST
101172: LIST
101173: LIST
101174: LIST
101175: LIST
101176: LIST
101177: LIST
101178: LIST
101179: LIST
101180: LIST
101181: LIST
101182: LIST
101183: LIST
101184: LIST
101185: LIST
101186: LIST
101187: LIST
101188: LIST
101189: LIST
101190: LIST
101191: LIST
101192: LIST
101193: LIST
101194: LIST
101195: LIST
101196: LIST
101197: LIST
101198: LIST
101199: LIST
101200: LIST
101201: LIST
101202: LIST
101203: LIST
101204: LIST
101205: LIST
101206: LIST
101207: LIST
101208: LIST
101209: LIST
101210: LIST
101211: LIST
101212: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
101213: LD_ADDR_VAR 0 33
101217: PUSH
101218: LD_INT 4
101220: NEG
101221: PUSH
101222: LD_INT 4
101224: NEG
101225: PUSH
101226: EMPTY
101227: LIST
101228: LIST
101229: PUSH
101230: LD_INT 4
101232: NEG
101233: PUSH
101234: LD_INT 5
101236: NEG
101237: PUSH
101238: EMPTY
101239: LIST
101240: LIST
101241: PUSH
101242: LD_INT 3
101244: NEG
101245: PUSH
101246: LD_INT 4
101248: NEG
101249: PUSH
101250: EMPTY
101251: LIST
101252: LIST
101253: PUSH
101254: LD_INT 3
101256: NEG
101257: PUSH
101258: LD_INT 3
101260: NEG
101261: PUSH
101262: EMPTY
101263: LIST
101264: LIST
101265: PUSH
101266: LD_INT 4
101268: NEG
101269: PUSH
101270: LD_INT 3
101272: NEG
101273: PUSH
101274: EMPTY
101275: LIST
101276: LIST
101277: PUSH
101278: LD_INT 5
101280: NEG
101281: PUSH
101282: LD_INT 4
101284: NEG
101285: PUSH
101286: EMPTY
101287: LIST
101288: LIST
101289: PUSH
101290: LD_INT 5
101292: NEG
101293: PUSH
101294: LD_INT 5
101296: NEG
101297: PUSH
101298: EMPTY
101299: LIST
101300: LIST
101301: PUSH
101302: LD_INT 3
101304: NEG
101305: PUSH
101306: LD_INT 5
101308: NEG
101309: PUSH
101310: EMPTY
101311: LIST
101312: LIST
101313: PUSH
101314: LD_INT 5
101316: NEG
101317: PUSH
101318: LD_INT 3
101320: NEG
101321: PUSH
101322: EMPTY
101323: LIST
101324: LIST
101325: PUSH
101326: LD_INT 0
101328: PUSH
101329: LD_INT 3
101331: NEG
101332: PUSH
101333: EMPTY
101334: LIST
101335: LIST
101336: PUSH
101337: LD_INT 0
101339: PUSH
101340: LD_INT 4
101342: NEG
101343: PUSH
101344: EMPTY
101345: LIST
101346: LIST
101347: PUSH
101348: LD_INT 1
101350: PUSH
101351: LD_INT 3
101353: NEG
101354: PUSH
101355: EMPTY
101356: LIST
101357: LIST
101358: PUSH
101359: LD_INT 1
101361: PUSH
101362: LD_INT 2
101364: NEG
101365: PUSH
101366: EMPTY
101367: LIST
101368: LIST
101369: PUSH
101370: LD_INT 0
101372: PUSH
101373: LD_INT 2
101375: NEG
101376: PUSH
101377: EMPTY
101378: LIST
101379: LIST
101380: PUSH
101381: LD_INT 1
101383: NEG
101384: PUSH
101385: LD_INT 3
101387: NEG
101388: PUSH
101389: EMPTY
101390: LIST
101391: LIST
101392: PUSH
101393: LD_INT 1
101395: NEG
101396: PUSH
101397: LD_INT 4
101399: NEG
101400: PUSH
101401: EMPTY
101402: LIST
101403: LIST
101404: PUSH
101405: LD_INT 2
101407: PUSH
101408: LD_INT 2
101410: NEG
101411: PUSH
101412: EMPTY
101413: LIST
101414: LIST
101415: PUSH
101416: LD_INT 2
101418: NEG
101419: PUSH
101420: LD_INT 4
101422: NEG
101423: PUSH
101424: EMPTY
101425: LIST
101426: LIST
101427: PUSH
101428: LD_INT 4
101430: PUSH
101431: LD_INT 0
101433: PUSH
101434: EMPTY
101435: LIST
101436: LIST
101437: PUSH
101438: LD_INT 4
101440: PUSH
101441: LD_INT 1
101443: NEG
101444: PUSH
101445: EMPTY
101446: LIST
101447: LIST
101448: PUSH
101449: LD_INT 5
101451: PUSH
101452: LD_INT 0
101454: PUSH
101455: EMPTY
101456: LIST
101457: LIST
101458: PUSH
101459: LD_INT 5
101461: PUSH
101462: LD_INT 1
101464: PUSH
101465: EMPTY
101466: LIST
101467: LIST
101468: PUSH
101469: LD_INT 4
101471: PUSH
101472: LD_INT 1
101474: PUSH
101475: EMPTY
101476: LIST
101477: LIST
101478: PUSH
101479: LD_INT 3
101481: PUSH
101482: LD_INT 0
101484: PUSH
101485: EMPTY
101486: LIST
101487: LIST
101488: PUSH
101489: LD_INT 3
101491: PUSH
101492: LD_INT 1
101494: NEG
101495: PUSH
101496: EMPTY
101497: LIST
101498: LIST
101499: PUSH
101500: LD_INT 3
101502: PUSH
101503: LD_INT 2
101505: NEG
101506: PUSH
101507: EMPTY
101508: LIST
101509: LIST
101510: PUSH
101511: LD_INT 5
101513: PUSH
101514: LD_INT 2
101516: PUSH
101517: EMPTY
101518: LIST
101519: LIST
101520: PUSH
101521: LD_INT 3
101523: PUSH
101524: LD_INT 3
101526: PUSH
101527: EMPTY
101528: LIST
101529: LIST
101530: PUSH
101531: LD_INT 3
101533: PUSH
101534: LD_INT 2
101536: PUSH
101537: EMPTY
101538: LIST
101539: LIST
101540: PUSH
101541: LD_INT 4
101543: PUSH
101544: LD_INT 3
101546: PUSH
101547: EMPTY
101548: LIST
101549: LIST
101550: PUSH
101551: LD_INT 4
101553: PUSH
101554: LD_INT 4
101556: PUSH
101557: EMPTY
101558: LIST
101559: LIST
101560: PUSH
101561: LD_INT 3
101563: PUSH
101564: LD_INT 4
101566: PUSH
101567: EMPTY
101568: LIST
101569: LIST
101570: PUSH
101571: LD_INT 2
101573: PUSH
101574: LD_INT 3
101576: PUSH
101577: EMPTY
101578: LIST
101579: LIST
101580: PUSH
101581: LD_INT 2
101583: PUSH
101584: LD_INT 2
101586: PUSH
101587: EMPTY
101588: LIST
101589: LIST
101590: PUSH
101591: LD_INT 4
101593: PUSH
101594: LD_INT 2
101596: PUSH
101597: EMPTY
101598: LIST
101599: LIST
101600: PUSH
101601: LD_INT 2
101603: PUSH
101604: LD_INT 4
101606: PUSH
101607: EMPTY
101608: LIST
101609: LIST
101610: PUSH
101611: LD_INT 0
101613: PUSH
101614: LD_INT 4
101616: PUSH
101617: EMPTY
101618: LIST
101619: LIST
101620: PUSH
101621: LD_INT 0
101623: PUSH
101624: LD_INT 3
101626: PUSH
101627: EMPTY
101628: LIST
101629: LIST
101630: PUSH
101631: LD_INT 1
101633: PUSH
101634: LD_INT 4
101636: PUSH
101637: EMPTY
101638: LIST
101639: LIST
101640: PUSH
101641: LD_INT 1
101643: PUSH
101644: LD_INT 5
101646: PUSH
101647: EMPTY
101648: LIST
101649: LIST
101650: PUSH
101651: LD_INT 0
101653: PUSH
101654: LD_INT 5
101656: PUSH
101657: EMPTY
101658: LIST
101659: LIST
101660: PUSH
101661: LD_INT 1
101663: NEG
101664: PUSH
101665: LD_INT 4
101667: PUSH
101668: EMPTY
101669: LIST
101670: LIST
101671: PUSH
101672: LD_INT 1
101674: NEG
101675: PUSH
101676: LD_INT 3
101678: PUSH
101679: EMPTY
101680: LIST
101681: LIST
101682: PUSH
101683: LD_INT 2
101685: PUSH
101686: LD_INT 5
101688: PUSH
101689: EMPTY
101690: LIST
101691: LIST
101692: PUSH
101693: LD_INT 2
101695: NEG
101696: PUSH
101697: LD_INT 3
101699: PUSH
101700: EMPTY
101701: LIST
101702: LIST
101703: PUSH
101704: EMPTY
101705: LIST
101706: LIST
101707: LIST
101708: LIST
101709: LIST
101710: LIST
101711: LIST
101712: LIST
101713: LIST
101714: LIST
101715: LIST
101716: LIST
101717: LIST
101718: LIST
101719: LIST
101720: LIST
101721: LIST
101722: LIST
101723: LIST
101724: LIST
101725: LIST
101726: LIST
101727: LIST
101728: LIST
101729: LIST
101730: LIST
101731: LIST
101732: LIST
101733: LIST
101734: LIST
101735: LIST
101736: LIST
101737: LIST
101738: LIST
101739: LIST
101740: LIST
101741: LIST
101742: LIST
101743: LIST
101744: LIST
101745: LIST
101746: LIST
101747: LIST
101748: LIST
101749: LIST
101750: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
101751: LD_ADDR_VAR 0 34
101755: PUSH
101756: LD_INT 0
101758: PUSH
101759: LD_INT 4
101761: NEG
101762: PUSH
101763: EMPTY
101764: LIST
101765: LIST
101766: PUSH
101767: LD_INT 0
101769: PUSH
101770: LD_INT 5
101772: NEG
101773: PUSH
101774: EMPTY
101775: LIST
101776: LIST
101777: PUSH
101778: LD_INT 1
101780: PUSH
101781: LD_INT 4
101783: NEG
101784: PUSH
101785: EMPTY
101786: LIST
101787: LIST
101788: PUSH
101789: LD_INT 1
101791: PUSH
101792: LD_INT 3
101794: NEG
101795: PUSH
101796: EMPTY
101797: LIST
101798: LIST
101799: PUSH
101800: LD_INT 0
101802: PUSH
101803: LD_INT 3
101805: NEG
101806: PUSH
101807: EMPTY
101808: LIST
101809: LIST
101810: PUSH
101811: LD_INT 1
101813: NEG
101814: PUSH
101815: LD_INT 4
101817: NEG
101818: PUSH
101819: EMPTY
101820: LIST
101821: LIST
101822: PUSH
101823: LD_INT 1
101825: NEG
101826: PUSH
101827: LD_INT 5
101829: NEG
101830: PUSH
101831: EMPTY
101832: LIST
101833: LIST
101834: PUSH
101835: LD_INT 2
101837: PUSH
101838: LD_INT 3
101840: NEG
101841: PUSH
101842: EMPTY
101843: LIST
101844: LIST
101845: PUSH
101846: LD_INT 2
101848: NEG
101849: PUSH
101850: LD_INT 5
101852: NEG
101853: PUSH
101854: EMPTY
101855: LIST
101856: LIST
101857: PUSH
101858: LD_INT 3
101860: PUSH
101861: LD_INT 0
101863: PUSH
101864: EMPTY
101865: LIST
101866: LIST
101867: PUSH
101868: LD_INT 3
101870: PUSH
101871: LD_INT 1
101873: NEG
101874: PUSH
101875: EMPTY
101876: LIST
101877: LIST
101878: PUSH
101879: LD_INT 4
101881: PUSH
101882: LD_INT 0
101884: PUSH
101885: EMPTY
101886: LIST
101887: LIST
101888: PUSH
101889: LD_INT 4
101891: PUSH
101892: LD_INT 1
101894: PUSH
101895: EMPTY
101896: LIST
101897: LIST
101898: PUSH
101899: LD_INT 3
101901: PUSH
101902: LD_INT 1
101904: PUSH
101905: EMPTY
101906: LIST
101907: LIST
101908: PUSH
101909: LD_INT 2
101911: PUSH
101912: LD_INT 0
101914: PUSH
101915: EMPTY
101916: LIST
101917: LIST
101918: PUSH
101919: LD_INT 2
101921: PUSH
101922: LD_INT 1
101924: NEG
101925: PUSH
101926: EMPTY
101927: LIST
101928: LIST
101929: PUSH
101930: LD_INT 2
101932: PUSH
101933: LD_INT 2
101935: NEG
101936: PUSH
101937: EMPTY
101938: LIST
101939: LIST
101940: PUSH
101941: LD_INT 4
101943: PUSH
101944: LD_INT 2
101946: PUSH
101947: EMPTY
101948: LIST
101949: LIST
101950: PUSH
101951: LD_INT 4
101953: PUSH
101954: LD_INT 4
101956: PUSH
101957: EMPTY
101958: LIST
101959: LIST
101960: PUSH
101961: LD_INT 4
101963: PUSH
101964: LD_INT 3
101966: PUSH
101967: EMPTY
101968: LIST
101969: LIST
101970: PUSH
101971: LD_INT 5
101973: PUSH
101974: LD_INT 4
101976: PUSH
101977: EMPTY
101978: LIST
101979: LIST
101980: PUSH
101981: LD_INT 5
101983: PUSH
101984: LD_INT 5
101986: PUSH
101987: EMPTY
101988: LIST
101989: LIST
101990: PUSH
101991: LD_INT 4
101993: PUSH
101994: LD_INT 5
101996: PUSH
101997: EMPTY
101998: LIST
101999: LIST
102000: PUSH
102001: LD_INT 3
102003: PUSH
102004: LD_INT 4
102006: PUSH
102007: EMPTY
102008: LIST
102009: LIST
102010: PUSH
102011: LD_INT 3
102013: PUSH
102014: LD_INT 3
102016: PUSH
102017: EMPTY
102018: LIST
102019: LIST
102020: PUSH
102021: LD_INT 5
102023: PUSH
102024: LD_INT 3
102026: PUSH
102027: EMPTY
102028: LIST
102029: LIST
102030: PUSH
102031: LD_INT 3
102033: PUSH
102034: LD_INT 5
102036: PUSH
102037: EMPTY
102038: LIST
102039: LIST
102040: PUSH
102041: LD_INT 0
102043: PUSH
102044: LD_INT 3
102046: PUSH
102047: EMPTY
102048: LIST
102049: LIST
102050: PUSH
102051: LD_INT 0
102053: PUSH
102054: LD_INT 2
102056: PUSH
102057: EMPTY
102058: LIST
102059: LIST
102060: PUSH
102061: LD_INT 1
102063: PUSH
102064: LD_INT 3
102066: PUSH
102067: EMPTY
102068: LIST
102069: LIST
102070: PUSH
102071: LD_INT 1
102073: PUSH
102074: LD_INT 4
102076: PUSH
102077: EMPTY
102078: LIST
102079: LIST
102080: PUSH
102081: LD_INT 0
102083: PUSH
102084: LD_INT 4
102086: PUSH
102087: EMPTY
102088: LIST
102089: LIST
102090: PUSH
102091: LD_INT 1
102093: NEG
102094: PUSH
102095: LD_INT 3
102097: PUSH
102098: EMPTY
102099: LIST
102100: LIST
102101: PUSH
102102: LD_INT 1
102104: NEG
102105: PUSH
102106: LD_INT 2
102108: PUSH
102109: EMPTY
102110: LIST
102111: LIST
102112: PUSH
102113: LD_INT 2
102115: PUSH
102116: LD_INT 4
102118: PUSH
102119: EMPTY
102120: LIST
102121: LIST
102122: PUSH
102123: LD_INT 2
102125: NEG
102126: PUSH
102127: LD_INT 2
102129: PUSH
102130: EMPTY
102131: LIST
102132: LIST
102133: PUSH
102134: LD_INT 4
102136: NEG
102137: PUSH
102138: LD_INT 0
102140: PUSH
102141: EMPTY
102142: LIST
102143: LIST
102144: PUSH
102145: LD_INT 4
102147: NEG
102148: PUSH
102149: LD_INT 1
102151: NEG
102152: PUSH
102153: EMPTY
102154: LIST
102155: LIST
102156: PUSH
102157: LD_INT 3
102159: NEG
102160: PUSH
102161: LD_INT 0
102163: PUSH
102164: EMPTY
102165: LIST
102166: LIST
102167: PUSH
102168: LD_INT 3
102170: NEG
102171: PUSH
102172: LD_INT 1
102174: PUSH
102175: EMPTY
102176: LIST
102177: LIST
102178: PUSH
102179: LD_INT 4
102181: NEG
102182: PUSH
102183: LD_INT 1
102185: PUSH
102186: EMPTY
102187: LIST
102188: LIST
102189: PUSH
102190: LD_INT 5
102192: NEG
102193: PUSH
102194: LD_INT 0
102196: PUSH
102197: EMPTY
102198: LIST
102199: LIST
102200: PUSH
102201: LD_INT 5
102203: NEG
102204: PUSH
102205: LD_INT 1
102207: NEG
102208: PUSH
102209: EMPTY
102210: LIST
102211: LIST
102212: PUSH
102213: LD_INT 5
102215: NEG
102216: PUSH
102217: LD_INT 2
102219: NEG
102220: PUSH
102221: EMPTY
102222: LIST
102223: LIST
102224: PUSH
102225: LD_INT 3
102227: NEG
102228: PUSH
102229: LD_INT 2
102231: PUSH
102232: EMPTY
102233: LIST
102234: LIST
102235: PUSH
102236: EMPTY
102237: LIST
102238: LIST
102239: LIST
102240: LIST
102241: LIST
102242: LIST
102243: LIST
102244: LIST
102245: LIST
102246: LIST
102247: LIST
102248: LIST
102249: LIST
102250: LIST
102251: LIST
102252: LIST
102253: LIST
102254: LIST
102255: LIST
102256: LIST
102257: LIST
102258: LIST
102259: LIST
102260: LIST
102261: LIST
102262: LIST
102263: LIST
102264: LIST
102265: LIST
102266: LIST
102267: LIST
102268: LIST
102269: LIST
102270: LIST
102271: LIST
102272: LIST
102273: LIST
102274: LIST
102275: LIST
102276: LIST
102277: LIST
102278: LIST
102279: LIST
102280: LIST
102281: LIST
102282: ST_TO_ADDR
// end ; end ;
102283: GO 102286
102285: POP
// case btype of b_depot , b_warehouse :
102286: LD_VAR 0 1
102290: PUSH
102291: LD_INT 0
102293: DOUBLE
102294: EQUAL
102295: IFTRUE 102305
102297: LD_INT 1
102299: DOUBLE
102300: EQUAL
102301: IFTRUE 102305
102303: GO 102506
102305: POP
// case nation of nation_american :
102306: LD_VAR 0 5
102310: PUSH
102311: LD_INT 1
102313: DOUBLE
102314: EQUAL
102315: IFTRUE 102319
102317: GO 102375
102319: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
102320: LD_ADDR_VAR 0 9
102324: PUSH
102325: LD_VAR 0 11
102329: PUSH
102330: LD_VAR 0 12
102334: PUSH
102335: LD_VAR 0 13
102339: PUSH
102340: LD_VAR 0 14
102344: PUSH
102345: LD_VAR 0 15
102349: PUSH
102350: LD_VAR 0 16
102354: PUSH
102355: EMPTY
102356: LIST
102357: LIST
102358: LIST
102359: LIST
102360: LIST
102361: LIST
102362: PUSH
102363: LD_VAR 0 4
102367: PUSH
102368: LD_INT 1
102370: PLUS
102371: ARRAY
102372: ST_TO_ADDR
102373: GO 102504
102375: LD_INT 2
102377: DOUBLE
102378: EQUAL
102379: IFTRUE 102383
102381: GO 102439
102383: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
102384: LD_ADDR_VAR 0 9
102388: PUSH
102389: LD_VAR 0 17
102393: PUSH
102394: LD_VAR 0 18
102398: PUSH
102399: LD_VAR 0 19
102403: PUSH
102404: LD_VAR 0 20
102408: PUSH
102409: LD_VAR 0 21
102413: PUSH
102414: LD_VAR 0 22
102418: PUSH
102419: EMPTY
102420: LIST
102421: LIST
102422: LIST
102423: LIST
102424: LIST
102425: LIST
102426: PUSH
102427: LD_VAR 0 4
102431: PUSH
102432: LD_INT 1
102434: PLUS
102435: ARRAY
102436: ST_TO_ADDR
102437: GO 102504
102439: LD_INT 3
102441: DOUBLE
102442: EQUAL
102443: IFTRUE 102447
102445: GO 102503
102447: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
102448: LD_ADDR_VAR 0 9
102452: PUSH
102453: LD_VAR 0 23
102457: PUSH
102458: LD_VAR 0 24
102462: PUSH
102463: LD_VAR 0 25
102467: PUSH
102468: LD_VAR 0 26
102472: PUSH
102473: LD_VAR 0 27
102477: PUSH
102478: LD_VAR 0 28
102482: PUSH
102483: EMPTY
102484: LIST
102485: LIST
102486: LIST
102487: LIST
102488: LIST
102489: LIST
102490: PUSH
102491: LD_VAR 0 4
102495: PUSH
102496: LD_INT 1
102498: PLUS
102499: ARRAY
102500: ST_TO_ADDR
102501: GO 102504
102503: POP
102504: GO 103059
102506: LD_INT 2
102508: DOUBLE
102509: EQUAL
102510: IFTRUE 102520
102512: LD_INT 3
102514: DOUBLE
102515: EQUAL
102516: IFTRUE 102520
102518: GO 102576
102520: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
102521: LD_ADDR_VAR 0 9
102525: PUSH
102526: LD_VAR 0 29
102530: PUSH
102531: LD_VAR 0 30
102535: PUSH
102536: LD_VAR 0 31
102540: PUSH
102541: LD_VAR 0 32
102545: PUSH
102546: LD_VAR 0 33
102550: PUSH
102551: LD_VAR 0 34
102555: PUSH
102556: EMPTY
102557: LIST
102558: LIST
102559: LIST
102560: LIST
102561: LIST
102562: LIST
102563: PUSH
102564: LD_VAR 0 4
102568: PUSH
102569: LD_INT 1
102571: PLUS
102572: ARRAY
102573: ST_TO_ADDR
102574: GO 103059
102576: LD_INT 16
102578: DOUBLE
102579: EQUAL
102580: IFTRUE 102638
102582: LD_INT 17
102584: DOUBLE
102585: EQUAL
102586: IFTRUE 102638
102588: LD_INT 18
102590: DOUBLE
102591: EQUAL
102592: IFTRUE 102638
102594: LD_INT 19
102596: DOUBLE
102597: EQUAL
102598: IFTRUE 102638
102600: LD_INT 22
102602: DOUBLE
102603: EQUAL
102604: IFTRUE 102638
102606: LD_INT 20
102608: DOUBLE
102609: EQUAL
102610: IFTRUE 102638
102612: LD_INT 21
102614: DOUBLE
102615: EQUAL
102616: IFTRUE 102638
102618: LD_INT 23
102620: DOUBLE
102621: EQUAL
102622: IFTRUE 102638
102624: LD_INT 24
102626: DOUBLE
102627: EQUAL
102628: IFTRUE 102638
102630: LD_INT 25
102632: DOUBLE
102633: EQUAL
102634: IFTRUE 102638
102636: GO 102694
102638: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
102639: LD_ADDR_VAR 0 9
102643: PUSH
102644: LD_VAR 0 35
102648: PUSH
102649: LD_VAR 0 36
102653: PUSH
102654: LD_VAR 0 37
102658: PUSH
102659: LD_VAR 0 38
102663: PUSH
102664: LD_VAR 0 39
102668: PUSH
102669: LD_VAR 0 40
102673: PUSH
102674: EMPTY
102675: LIST
102676: LIST
102677: LIST
102678: LIST
102679: LIST
102680: LIST
102681: PUSH
102682: LD_VAR 0 4
102686: PUSH
102687: LD_INT 1
102689: PLUS
102690: ARRAY
102691: ST_TO_ADDR
102692: GO 103059
102694: LD_INT 6
102696: DOUBLE
102697: EQUAL
102698: IFTRUE 102750
102700: LD_INT 7
102702: DOUBLE
102703: EQUAL
102704: IFTRUE 102750
102706: LD_INT 8
102708: DOUBLE
102709: EQUAL
102710: IFTRUE 102750
102712: LD_INT 13
102714: DOUBLE
102715: EQUAL
102716: IFTRUE 102750
102718: LD_INT 12
102720: DOUBLE
102721: EQUAL
102722: IFTRUE 102750
102724: LD_INT 15
102726: DOUBLE
102727: EQUAL
102728: IFTRUE 102750
102730: LD_INT 11
102732: DOUBLE
102733: EQUAL
102734: IFTRUE 102750
102736: LD_INT 14
102738: DOUBLE
102739: EQUAL
102740: IFTRUE 102750
102742: LD_INT 10
102744: DOUBLE
102745: EQUAL
102746: IFTRUE 102750
102748: GO 102806
102750: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
102751: LD_ADDR_VAR 0 9
102755: PUSH
102756: LD_VAR 0 41
102760: PUSH
102761: LD_VAR 0 42
102765: PUSH
102766: LD_VAR 0 43
102770: PUSH
102771: LD_VAR 0 44
102775: PUSH
102776: LD_VAR 0 45
102780: PUSH
102781: LD_VAR 0 46
102785: PUSH
102786: EMPTY
102787: LIST
102788: LIST
102789: LIST
102790: LIST
102791: LIST
102792: LIST
102793: PUSH
102794: LD_VAR 0 4
102798: PUSH
102799: LD_INT 1
102801: PLUS
102802: ARRAY
102803: ST_TO_ADDR
102804: GO 103059
102806: LD_INT 36
102808: DOUBLE
102809: EQUAL
102810: IFTRUE 102814
102812: GO 102870
102814: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
102815: LD_ADDR_VAR 0 9
102819: PUSH
102820: LD_VAR 0 47
102824: PUSH
102825: LD_VAR 0 48
102829: PUSH
102830: LD_VAR 0 49
102834: PUSH
102835: LD_VAR 0 50
102839: PUSH
102840: LD_VAR 0 51
102844: PUSH
102845: LD_VAR 0 52
102849: PUSH
102850: EMPTY
102851: LIST
102852: LIST
102853: LIST
102854: LIST
102855: LIST
102856: LIST
102857: PUSH
102858: LD_VAR 0 4
102862: PUSH
102863: LD_INT 1
102865: PLUS
102866: ARRAY
102867: ST_TO_ADDR
102868: GO 103059
102870: LD_INT 4
102872: DOUBLE
102873: EQUAL
102874: IFTRUE 102896
102876: LD_INT 5
102878: DOUBLE
102879: EQUAL
102880: IFTRUE 102896
102882: LD_INT 34
102884: DOUBLE
102885: EQUAL
102886: IFTRUE 102896
102888: LD_INT 37
102890: DOUBLE
102891: EQUAL
102892: IFTRUE 102896
102894: GO 102952
102896: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
102897: LD_ADDR_VAR 0 9
102901: PUSH
102902: LD_VAR 0 53
102906: PUSH
102907: LD_VAR 0 54
102911: PUSH
102912: LD_VAR 0 55
102916: PUSH
102917: LD_VAR 0 56
102921: PUSH
102922: LD_VAR 0 57
102926: PUSH
102927: LD_VAR 0 58
102931: PUSH
102932: EMPTY
102933: LIST
102934: LIST
102935: LIST
102936: LIST
102937: LIST
102938: LIST
102939: PUSH
102940: LD_VAR 0 4
102944: PUSH
102945: LD_INT 1
102947: PLUS
102948: ARRAY
102949: ST_TO_ADDR
102950: GO 103059
102952: LD_INT 31
102954: DOUBLE
102955: EQUAL
102956: IFTRUE 103002
102958: LD_INT 32
102960: DOUBLE
102961: EQUAL
102962: IFTRUE 103002
102964: LD_INT 33
102966: DOUBLE
102967: EQUAL
102968: IFTRUE 103002
102970: LD_INT 27
102972: DOUBLE
102973: EQUAL
102974: IFTRUE 103002
102976: LD_INT 26
102978: DOUBLE
102979: EQUAL
102980: IFTRUE 103002
102982: LD_INT 28
102984: DOUBLE
102985: EQUAL
102986: IFTRUE 103002
102988: LD_INT 29
102990: DOUBLE
102991: EQUAL
102992: IFTRUE 103002
102994: LD_INT 30
102996: DOUBLE
102997: EQUAL
102998: IFTRUE 103002
103000: GO 103058
103002: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
103003: LD_ADDR_VAR 0 9
103007: PUSH
103008: LD_VAR 0 59
103012: PUSH
103013: LD_VAR 0 60
103017: PUSH
103018: LD_VAR 0 61
103022: PUSH
103023: LD_VAR 0 62
103027: PUSH
103028: LD_VAR 0 63
103032: PUSH
103033: LD_VAR 0 64
103037: PUSH
103038: EMPTY
103039: LIST
103040: LIST
103041: LIST
103042: LIST
103043: LIST
103044: LIST
103045: PUSH
103046: LD_VAR 0 4
103050: PUSH
103051: LD_INT 1
103053: PLUS
103054: ARRAY
103055: ST_TO_ADDR
103056: GO 103059
103058: POP
// temp_list2 = [ ] ;
103059: LD_ADDR_VAR 0 10
103063: PUSH
103064: EMPTY
103065: ST_TO_ADDR
// for i in temp_list do
103066: LD_ADDR_VAR 0 8
103070: PUSH
103071: LD_VAR 0 9
103075: PUSH
103076: FOR_IN
103077: IFFALSE 103129
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
103079: LD_ADDR_VAR 0 10
103083: PUSH
103084: LD_VAR 0 10
103088: PUSH
103089: LD_VAR 0 8
103093: PUSH
103094: LD_INT 1
103096: ARRAY
103097: PUSH
103098: LD_VAR 0 2
103102: PLUS
103103: PUSH
103104: LD_VAR 0 8
103108: PUSH
103109: LD_INT 2
103111: ARRAY
103112: PUSH
103113: LD_VAR 0 3
103117: PLUS
103118: PUSH
103119: EMPTY
103120: LIST
103121: LIST
103122: PUSH
103123: EMPTY
103124: LIST
103125: ADD
103126: ST_TO_ADDR
103127: GO 103076
103129: POP
103130: POP
// result = temp_list2 ;
103131: LD_ADDR_VAR 0 7
103135: PUSH
103136: LD_VAR 0 10
103140: ST_TO_ADDR
// end ;
103141: LD_VAR 0 7
103145: RET
// export function EnemyInRange ( unit , dist ) ; begin
103146: LD_INT 0
103148: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
103149: LD_ADDR_VAR 0 3
103153: PUSH
103154: LD_VAR 0 1
103158: PPUSH
103159: CALL_OW 255
103163: PPUSH
103164: LD_VAR 0 1
103168: PPUSH
103169: CALL_OW 250
103173: PPUSH
103174: LD_VAR 0 1
103178: PPUSH
103179: CALL_OW 251
103183: PPUSH
103184: LD_VAR 0 2
103188: PPUSH
103189: CALL 76519 0 4
103193: PUSH
103194: LD_INT 4
103196: ARRAY
103197: ST_TO_ADDR
// end ;
103198: LD_VAR 0 3
103202: RET
// export function PlayerSeeMe ( unit ) ; begin
103203: LD_INT 0
103205: PPUSH
// result := See ( your_side , unit ) ;
103206: LD_ADDR_VAR 0 2
103210: PUSH
103211: LD_OWVAR 2
103215: PPUSH
103216: LD_VAR 0 1
103220: PPUSH
103221: CALL_OW 292
103225: ST_TO_ADDR
// end ;
103226: LD_VAR 0 2
103230: RET
// export function ReverseDir ( unit ) ; begin
103231: LD_INT 0
103233: PPUSH
// if not unit then
103234: LD_VAR 0 1
103238: NOT
103239: IFFALSE 103243
// exit ;
103241: GO 103266
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
103243: LD_ADDR_VAR 0 2
103247: PUSH
103248: LD_VAR 0 1
103252: PPUSH
103253: CALL_OW 254
103257: PUSH
103258: LD_INT 3
103260: PLUS
103261: PUSH
103262: LD_INT 6
103264: MOD
103265: ST_TO_ADDR
// end ;
103266: LD_VAR 0 2
103270: RET
// export function ReverseArray ( array ) ; var i ; begin
103271: LD_INT 0
103273: PPUSH
103274: PPUSH
// if not array then
103275: LD_VAR 0 1
103279: NOT
103280: IFFALSE 103284
// exit ;
103282: GO 103339
// result := [ ] ;
103284: LD_ADDR_VAR 0 2
103288: PUSH
103289: EMPTY
103290: ST_TO_ADDR
// for i := array downto 1 do
103291: LD_ADDR_VAR 0 3
103295: PUSH
103296: DOUBLE
103297: LD_VAR 0 1
103301: INC
103302: ST_TO_ADDR
103303: LD_INT 1
103305: PUSH
103306: FOR_DOWNTO
103307: IFFALSE 103337
// result := Join ( result , array [ i ] ) ;
103309: LD_ADDR_VAR 0 2
103313: PUSH
103314: LD_VAR 0 2
103318: PPUSH
103319: LD_VAR 0 1
103323: PUSH
103324: LD_VAR 0 3
103328: ARRAY
103329: PPUSH
103330: CALL 108004 0 2
103334: ST_TO_ADDR
103335: GO 103306
103337: POP
103338: POP
// end ;
103339: LD_VAR 0 2
103343: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
103344: LD_INT 0
103346: PPUSH
103347: PPUSH
103348: PPUSH
103349: PPUSH
103350: PPUSH
103351: PPUSH
// if not unit or not hexes then
103352: LD_VAR 0 1
103356: NOT
103357: PUSH
103358: LD_VAR 0 2
103362: NOT
103363: OR
103364: IFFALSE 103368
// exit ;
103366: GO 103491
// dist := 9999 ;
103368: LD_ADDR_VAR 0 5
103372: PUSH
103373: LD_INT 9999
103375: ST_TO_ADDR
// for i = 1 to hexes do
103376: LD_ADDR_VAR 0 4
103380: PUSH
103381: DOUBLE
103382: LD_INT 1
103384: DEC
103385: ST_TO_ADDR
103386: LD_VAR 0 2
103390: PUSH
103391: FOR_TO
103392: IFFALSE 103479
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
103394: LD_ADDR_VAR 0 6
103398: PUSH
103399: LD_VAR 0 1
103403: PPUSH
103404: LD_VAR 0 2
103408: PUSH
103409: LD_VAR 0 4
103413: ARRAY
103414: PUSH
103415: LD_INT 1
103417: ARRAY
103418: PPUSH
103419: LD_VAR 0 2
103423: PUSH
103424: LD_VAR 0 4
103428: ARRAY
103429: PUSH
103430: LD_INT 2
103432: ARRAY
103433: PPUSH
103434: CALL_OW 297
103438: ST_TO_ADDR
// if tdist < dist then
103439: LD_VAR 0 6
103443: PUSH
103444: LD_VAR 0 5
103448: LESS
103449: IFFALSE 103477
// begin hex := hexes [ i ] ;
103451: LD_ADDR_VAR 0 8
103455: PUSH
103456: LD_VAR 0 2
103460: PUSH
103461: LD_VAR 0 4
103465: ARRAY
103466: ST_TO_ADDR
// dist := tdist ;
103467: LD_ADDR_VAR 0 5
103471: PUSH
103472: LD_VAR 0 6
103476: ST_TO_ADDR
// end ; end ;
103477: GO 103391
103479: POP
103480: POP
// result := hex ;
103481: LD_ADDR_VAR 0 3
103485: PUSH
103486: LD_VAR 0 8
103490: ST_TO_ADDR
// end ;
103491: LD_VAR 0 3
103495: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
103496: LD_INT 0
103498: PPUSH
103499: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
103500: LD_VAR 0 1
103504: NOT
103505: PUSH
103506: LD_VAR 0 1
103510: PUSH
103511: LD_INT 21
103513: PUSH
103514: LD_INT 2
103516: PUSH
103517: EMPTY
103518: LIST
103519: LIST
103520: PUSH
103521: LD_INT 23
103523: PUSH
103524: LD_INT 2
103526: PUSH
103527: EMPTY
103528: LIST
103529: LIST
103530: PUSH
103531: EMPTY
103532: LIST
103533: LIST
103534: PPUSH
103535: CALL_OW 69
103539: IN
103540: NOT
103541: OR
103542: IFFALSE 103546
// exit ;
103544: GO 103593
// for i = 1 to 3 do
103546: LD_ADDR_VAR 0 3
103550: PUSH
103551: DOUBLE
103552: LD_INT 1
103554: DEC
103555: ST_TO_ADDR
103556: LD_INT 3
103558: PUSH
103559: FOR_TO
103560: IFFALSE 103591
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
103562: LD_VAR 0 1
103566: PPUSH
103567: CALL_OW 250
103571: PPUSH
103572: LD_VAR 0 1
103576: PPUSH
103577: CALL_OW 251
103581: PPUSH
103582: LD_INT 1
103584: PPUSH
103585: CALL_OW 453
103589: GO 103559
103591: POP
103592: POP
// end ;
103593: LD_VAR 0 2
103597: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
103598: LD_INT 0
103600: PPUSH
103601: PPUSH
103602: PPUSH
103603: PPUSH
103604: PPUSH
103605: PPUSH
// if not unit or not enemy_unit then
103606: LD_VAR 0 1
103610: NOT
103611: PUSH
103612: LD_VAR 0 2
103616: NOT
103617: OR
103618: IFFALSE 103622
// exit ;
103620: GO 104089
// if GetLives ( i ) < 250 then
103622: LD_VAR 0 4
103626: PPUSH
103627: CALL_OW 256
103631: PUSH
103632: LD_INT 250
103634: LESS
103635: IFFALSE 103648
// begin ComAutodestruct ( i ) ;
103637: LD_VAR 0 4
103641: PPUSH
103642: CALL 103496 0 1
// exit ;
103646: GO 104089
// end ; x := GetX ( enemy_unit ) ;
103648: LD_ADDR_VAR 0 7
103652: PUSH
103653: LD_VAR 0 2
103657: PPUSH
103658: CALL_OW 250
103662: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
103663: LD_ADDR_VAR 0 8
103667: PUSH
103668: LD_VAR 0 2
103672: PPUSH
103673: CALL_OW 251
103677: ST_TO_ADDR
// if not x or not y then
103678: LD_VAR 0 7
103682: NOT
103683: PUSH
103684: LD_VAR 0 8
103688: NOT
103689: OR
103690: IFFALSE 103694
// exit ;
103692: GO 104089
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
103694: LD_ADDR_VAR 0 6
103698: PUSH
103699: LD_VAR 0 7
103703: PPUSH
103704: LD_INT 0
103706: PPUSH
103707: LD_INT 4
103709: PPUSH
103710: CALL_OW 272
103714: PUSH
103715: LD_VAR 0 8
103719: PPUSH
103720: LD_INT 0
103722: PPUSH
103723: LD_INT 4
103725: PPUSH
103726: CALL_OW 273
103730: PUSH
103731: EMPTY
103732: LIST
103733: LIST
103734: PUSH
103735: LD_VAR 0 7
103739: PPUSH
103740: LD_INT 1
103742: PPUSH
103743: LD_INT 4
103745: PPUSH
103746: CALL_OW 272
103750: PUSH
103751: LD_VAR 0 8
103755: PPUSH
103756: LD_INT 1
103758: PPUSH
103759: LD_INT 4
103761: PPUSH
103762: CALL_OW 273
103766: PUSH
103767: EMPTY
103768: LIST
103769: LIST
103770: PUSH
103771: LD_VAR 0 7
103775: PPUSH
103776: LD_INT 2
103778: PPUSH
103779: LD_INT 4
103781: PPUSH
103782: CALL_OW 272
103786: PUSH
103787: LD_VAR 0 8
103791: PPUSH
103792: LD_INT 2
103794: PPUSH
103795: LD_INT 4
103797: PPUSH
103798: CALL_OW 273
103802: PUSH
103803: EMPTY
103804: LIST
103805: LIST
103806: PUSH
103807: LD_VAR 0 7
103811: PPUSH
103812: LD_INT 3
103814: PPUSH
103815: LD_INT 4
103817: PPUSH
103818: CALL_OW 272
103822: PUSH
103823: LD_VAR 0 8
103827: PPUSH
103828: LD_INT 3
103830: PPUSH
103831: LD_INT 4
103833: PPUSH
103834: CALL_OW 273
103838: PUSH
103839: EMPTY
103840: LIST
103841: LIST
103842: PUSH
103843: LD_VAR 0 7
103847: PPUSH
103848: LD_INT 4
103850: PPUSH
103851: LD_INT 4
103853: PPUSH
103854: CALL_OW 272
103858: PUSH
103859: LD_VAR 0 8
103863: PPUSH
103864: LD_INT 4
103866: PPUSH
103867: LD_INT 4
103869: PPUSH
103870: CALL_OW 273
103874: PUSH
103875: EMPTY
103876: LIST
103877: LIST
103878: PUSH
103879: LD_VAR 0 7
103883: PPUSH
103884: LD_INT 5
103886: PPUSH
103887: LD_INT 4
103889: PPUSH
103890: CALL_OW 272
103894: PUSH
103895: LD_VAR 0 8
103899: PPUSH
103900: LD_INT 5
103902: PPUSH
103903: LD_INT 4
103905: PPUSH
103906: CALL_OW 273
103910: PUSH
103911: EMPTY
103912: LIST
103913: LIST
103914: PUSH
103915: EMPTY
103916: LIST
103917: LIST
103918: LIST
103919: LIST
103920: LIST
103921: LIST
103922: ST_TO_ADDR
// for i = tmp downto 1 do
103923: LD_ADDR_VAR 0 4
103927: PUSH
103928: DOUBLE
103929: LD_VAR 0 6
103933: INC
103934: ST_TO_ADDR
103935: LD_INT 1
103937: PUSH
103938: FOR_DOWNTO
103939: IFFALSE 104040
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
103941: LD_VAR 0 6
103945: PUSH
103946: LD_VAR 0 4
103950: ARRAY
103951: PUSH
103952: LD_INT 1
103954: ARRAY
103955: PPUSH
103956: LD_VAR 0 6
103960: PUSH
103961: LD_VAR 0 4
103965: ARRAY
103966: PUSH
103967: LD_INT 2
103969: ARRAY
103970: PPUSH
103971: CALL_OW 488
103975: NOT
103976: PUSH
103977: LD_VAR 0 6
103981: PUSH
103982: LD_VAR 0 4
103986: ARRAY
103987: PUSH
103988: LD_INT 1
103990: ARRAY
103991: PPUSH
103992: LD_VAR 0 6
103996: PUSH
103997: LD_VAR 0 4
104001: ARRAY
104002: PUSH
104003: LD_INT 2
104005: ARRAY
104006: PPUSH
104007: CALL_OW 428
104011: PUSH
104012: LD_INT 0
104014: NONEQUAL
104015: OR
104016: IFFALSE 104038
// tmp := Delete ( tmp , i ) ;
104018: LD_ADDR_VAR 0 6
104022: PUSH
104023: LD_VAR 0 6
104027: PPUSH
104028: LD_VAR 0 4
104032: PPUSH
104033: CALL_OW 3
104037: ST_TO_ADDR
104038: GO 103938
104040: POP
104041: POP
// j := GetClosestHex ( unit , tmp ) ;
104042: LD_ADDR_VAR 0 5
104046: PUSH
104047: LD_VAR 0 1
104051: PPUSH
104052: LD_VAR 0 6
104056: PPUSH
104057: CALL 103344 0 2
104061: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
104062: LD_VAR 0 1
104066: PPUSH
104067: LD_VAR 0 5
104071: PUSH
104072: LD_INT 1
104074: ARRAY
104075: PPUSH
104076: LD_VAR 0 5
104080: PUSH
104081: LD_INT 2
104083: ARRAY
104084: PPUSH
104085: CALL_OW 111
// end ;
104089: LD_VAR 0 3
104093: RET
// export function PrepareApemanSoldier ( ) ; begin
104094: LD_INT 0
104096: PPUSH
// uc_nation := 0 ;
104097: LD_ADDR_OWVAR 21
104101: PUSH
104102: LD_INT 0
104104: ST_TO_ADDR
// hc_sex := sex_male ;
104105: LD_ADDR_OWVAR 27
104109: PUSH
104110: LD_INT 1
104112: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
104113: LD_ADDR_OWVAR 28
104117: PUSH
104118: LD_INT 15
104120: ST_TO_ADDR
// hc_gallery :=  ;
104121: LD_ADDR_OWVAR 33
104125: PUSH
104126: LD_STRING 
104128: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
104129: LD_ADDR_OWVAR 31
104133: PUSH
104134: LD_INT 0
104136: PPUSH
104137: LD_INT 3
104139: PPUSH
104140: CALL_OW 12
104144: PUSH
104145: LD_INT 0
104147: PPUSH
104148: LD_INT 3
104150: PPUSH
104151: CALL_OW 12
104155: PUSH
104156: LD_INT 0
104158: PUSH
104159: LD_INT 0
104161: PUSH
104162: EMPTY
104163: LIST
104164: LIST
104165: LIST
104166: LIST
104167: ST_TO_ADDR
// end ;
104168: LD_VAR 0 1
104172: RET
// export function PrepareApemanEngineer ( ) ; begin
104173: LD_INT 0
104175: PPUSH
// uc_nation := 0 ;
104176: LD_ADDR_OWVAR 21
104180: PUSH
104181: LD_INT 0
104183: ST_TO_ADDR
// hc_sex := sex_male ;
104184: LD_ADDR_OWVAR 27
104188: PUSH
104189: LD_INT 1
104191: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
104192: LD_ADDR_OWVAR 28
104196: PUSH
104197: LD_INT 16
104199: ST_TO_ADDR
// hc_gallery :=  ;
104200: LD_ADDR_OWVAR 33
104204: PUSH
104205: LD_STRING 
104207: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
104208: LD_ADDR_OWVAR 31
104212: PUSH
104213: LD_INT 0
104215: PPUSH
104216: LD_INT 3
104218: PPUSH
104219: CALL_OW 12
104223: PUSH
104224: LD_INT 0
104226: PPUSH
104227: LD_INT 3
104229: PPUSH
104230: CALL_OW 12
104234: PUSH
104235: LD_INT 0
104237: PUSH
104238: LD_INT 0
104240: PUSH
104241: EMPTY
104242: LIST
104243: LIST
104244: LIST
104245: LIST
104246: ST_TO_ADDR
// end ;
104247: LD_VAR 0 1
104251: RET
// export function PrepareApeman ( agressivity ) ; begin
104252: LD_INT 0
104254: PPUSH
// uc_side := 0 ;
104255: LD_ADDR_OWVAR 20
104259: PUSH
104260: LD_INT 0
104262: ST_TO_ADDR
// uc_nation := 0 ;
104263: LD_ADDR_OWVAR 21
104267: PUSH
104268: LD_INT 0
104270: ST_TO_ADDR
// hc_sex := sex_male ;
104271: LD_ADDR_OWVAR 27
104275: PUSH
104276: LD_INT 1
104278: ST_TO_ADDR
// hc_class := class_apeman ;
104279: LD_ADDR_OWVAR 28
104283: PUSH
104284: LD_INT 12
104286: ST_TO_ADDR
// hc_gallery :=  ;
104287: LD_ADDR_OWVAR 33
104291: PUSH
104292: LD_STRING 
104294: ST_TO_ADDR
// if agressivity = 0 then
104295: LD_VAR 0 1
104299: PUSH
104300: LD_INT 0
104302: EQUAL
104303: IFFALSE 104315
// hc_agressivity := 0 else
104305: LD_ADDR_OWVAR 35
104309: PUSH
104310: LD_INT 0
104312: ST_TO_ADDR
104313: GO 104336
// hc_agressivity := rand ( - agressivity , agressivity ) ;
104315: LD_ADDR_OWVAR 35
104319: PUSH
104320: LD_VAR 0 1
104324: NEG
104325: PPUSH
104326: LD_VAR 0 1
104330: PPUSH
104331: CALL_OW 12
104335: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
104336: LD_ADDR_OWVAR 31
104340: PUSH
104341: LD_INT 0
104343: PPUSH
104344: LD_INT 3
104346: PPUSH
104347: CALL_OW 12
104351: PUSH
104352: LD_INT 0
104354: PPUSH
104355: LD_INT 3
104357: PPUSH
104358: CALL_OW 12
104362: PUSH
104363: LD_INT 0
104365: PUSH
104366: LD_INT 0
104368: PUSH
104369: EMPTY
104370: LIST
104371: LIST
104372: LIST
104373: LIST
104374: ST_TO_ADDR
// end ;
104375: LD_VAR 0 2
104379: RET
// export function PrepareTiger ( agressivity ) ; begin
104380: LD_INT 0
104382: PPUSH
// uc_side := 0 ;
104383: LD_ADDR_OWVAR 20
104387: PUSH
104388: LD_INT 0
104390: ST_TO_ADDR
// uc_nation := 0 ;
104391: LD_ADDR_OWVAR 21
104395: PUSH
104396: LD_INT 0
104398: ST_TO_ADDR
// hc_class := class_tiger ;
104399: LD_ADDR_OWVAR 28
104403: PUSH
104404: LD_INT 14
104406: ST_TO_ADDR
// hc_gallery :=  ;
104407: LD_ADDR_OWVAR 33
104411: PUSH
104412: LD_STRING 
104414: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
104415: LD_ADDR_OWVAR 35
104419: PUSH
104420: LD_VAR 0 1
104424: NEG
104425: PPUSH
104426: LD_VAR 0 1
104430: PPUSH
104431: CALL_OW 12
104435: ST_TO_ADDR
// end ;
104436: LD_VAR 0 2
104440: RET
// export function PrepareEnchidna ( ) ; begin
104441: LD_INT 0
104443: PPUSH
// uc_side := 0 ;
104444: LD_ADDR_OWVAR 20
104448: PUSH
104449: LD_INT 0
104451: ST_TO_ADDR
// uc_nation := 0 ;
104452: LD_ADDR_OWVAR 21
104456: PUSH
104457: LD_INT 0
104459: ST_TO_ADDR
// hc_class := class_baggie ;
104460: LD_ADDR_OWVAR 28
104464: PUSH
104465: LD_INT 13
104467: ST_TO_ADDR
// hc_gallery :=  ;
104468: LD_ADDR_OWVAR 33
104472: PUSH
104473: LD_STRING 
104475: ST_TO_ADDR
// end ;
104476: LD_VAR 0 1
104480: RET
// export function PrepareFrog ( ) ; begin
104481: LD_INT 0
104483: PPUSH
// uc_side := 0 ;
104484: LD_ADDR_OWVAR 20
104488: PUSH
104489: LD_INT 0
104491: ST_TO_ADDR
// uc_nation := 0 ;
104492: LD_ADDR_OWVAR 21
104496: PUSH
104497: LD_INT 0
104499: ST_TO_ADDR
// hc_class := class_frog ;
104500: LD_ADDR_OWVAR 28
104504: PUSH
104505: LD_INT 19
104507: ST_TO_ADDR
// hc_gallery :=  ;
104508: LD_ADDR_OWVAR 33
104512: PUSH
104513: LD_STRING 
104515: ST_TO_ADDR
// end ;
104516: LD_VAR 0 1
104520: RET
// export function PrepareFish ( ) ; begin
104521: LD_INT 0
104523: PPUSH
// uc_side := 0 ;
104524: LD_ADDR_OWVAR 20
104528: PUSH
104529: LD_INT 0
104531: ST_TO_ADDR
// uc_nation := 0 ;
104532: LD_ADDR_OWVAR 21
104536: PUSH
104537: LD_INT 0
104539: ST_TO_ADDR
// hc_class := class_fish ;
104540: LD_ADDR_OWVAR 28
104544: PUSH
104545: LD_INT 20
104547: ST_TO_ADDR
// hc_gallery :=  ;
104548: LD_ADDR_OWVAR 33
104552: PUSH
104553: LD_STRING 
104555: ST_TO_ADDR
// end ;
104556: LD_VAR 0 1
104560: RET
// export function PrepareBird ( ) ; begin
104561: LD_INT 0
104563: PPUSH
// uc_side := 0 ;
104564: LD_ADDR_OWVAR 20
104568: PUSH
104569: LD_INT 0
104571: ST_TO_ADDR
// uc_nation := 0 ;
104572: LD_ADDR_OWVAR 21
104576: PUSH
104577: LD_INT 0
104579: ST_TO_ADDR
// hc_class := class_phororhacos ;
104580: LD_ADDR_OWVAR 28
104584: PUSH
104585: LD_INT 18
104587: ST_TO_ADDR
// hc_gallery :=  ;
104588: LD_ADDR_OWVAR 33
104592: PUSH
104593: LD_STRING 
104595: ST_TO_ADDR
// end ;
104596: LD_VAR 0 1
104600: RET
// export function PrepareHorse ( ) ; begin
104601: LD_INT 0
104603: PPUSH
// uc_side := 0 ;
104604: LD_ADDR_OWVAR 20
104608: PUSH
104609: LD_INT 0
104611: ST_TO_ADDR
// uc_nation := 0 ;
104612: LD_ADDR_OWVAR 21
104616: PUSH
104617: LD_INT 0
104619: ST_TO_ADDR
// hc_class := class_horse ;
104620: LD_ADDR_OWVAR 28
104624: PUSH
104625: LD_INT 21
104627: ST_TO_ADDR
// hc_gallery :=  ;
104628: LD_ADDR_OWVAR 33
104632: PUSH
104633: LD_STRING 
104635: ST_TO_ADDR
// end ;
104636: LD_VAR 0 1
104640: RET
// export function PrepareMastodont ( ) ; begin
104641: LD_INT 0
104643: PPUSH
// uc_side := 0 ;
104644: LD_ADDR_OWVAR 20
104648: PUSH
104649: LD_INT 0
104651: ST_TO_ADDR
// uc_nation := 0 ;
104652: LD_ADDR_OWVAR 21
104656: PUSH
104657: LD_INT 0
104659: ST_TO_ADDR
// vc_chassis := class_mastodont ;
104660: LD_ADDR_OWVAR 37
104664: PUSH
104665: LD_INT 31
104667: ST_TO_ADDR
// vc_control := control_rider ;
104668: LD_ADDR_OWVAR 38
104672: PUSH
104673: LD_INT 4
104675: ST_TO_ADDR
// end ;
104676: LD_VAR 0 1
104680: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
104681: LD_INT 0
104683: PPUSH
104684: PPUSH
104685: PPUSH
// uc_side = 0 ;
104686: LD_ADDR_OWVAR 20
104690: PUSH
104691: LD_INT 0
104693: ST_TO_ADDR
// uc_nation = 0 ;
104694: LD_ADDR_OWVAR 21
104698: PUSH
104699: LD_INT 0
104701: ST_TO_ADDR
// InitHc_All ( ) ;
104702: CALL_OW 584
// InitVc ;
104706: CALL_OW 20
// if mastodonts then
104710: LD_VAR 0 6
104714: IFFALSE 104781
// for i = 1 to mastodonts do
104716: LD_ADDR_VAR 0 11
104720: PUSH
104721: DOUBLE
104722: LD_INT 1
104724: DEC
104725: ST_TO_ADDR
104726: LD_VAR 0 6
104730: PUSH
104731: FOR_TO
104732: IFFALSE 104779
// begin vc_chassis := 31 ;
104734: LD_ADDR_OWVAR 37
104738: PUSH
104739: LD_INT 31
104741: ST_TO_ADDR
// vc_control := control_rider ;
104742: LD_ADDR_OWVAR 38
104746: PUSH
104747: LD_INT 4
104749: ST_TO_ADDR
// animal := CreateVehicle ;
104750: LD_ADDR_VAR 0 12
104754: PUSH
104755: CALL_OW 45
104759: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104760: LD_VAR 0 12
104764: PPUSH
104765: LD_VAR 0 8
104769: PPUSH
104770: LD_INT 0
104772: PPUSH
104773: CALL 106909 0 3
// end ;
104777: GO 104731
104779: POP
104780: POP
// if horses then
104781: LD_VAR 0 5
104785: IFFALSE 104852
// for i = 1 to horses do
104787: LD_ADDR_VAR 0 11
104791: PUSH
104792: DOUBLE
104793: LD_INT 1
104795: DEC
104796: ST_TO_ADDR
104797: LD_VAR 0 5
104801: PUSH
104802: FOR_TO
104803: IFFALSE 104850
// begin hc_class := 21 ;
104805: LD_ADDR_OWVAR 28
104809: PUSH
104810: LD_INT 21
104812: ST_TO_ADDR
// hc_gallery :=  ;
104813: LD_ADDR_OWVAR 33
104817: PUSH
104818: LD_STRING 
104820: ST_TO_ADDR
// animal := CreateHuman ;
104821: LD_ADDR_VAR 0 12
104825: PUSH
104826: CALL_OW 44
104830: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104831: LD_VAR 0 12
104835: PPUSH
104836: LD_VAR 0 8
104840: PPUSH
104841: LD_INT 0
104843: PPUSH
104844: CALL 106909 0 3
// end ;
104848: GO 104802
104850: POP
104851: POP
// if birds then
104852: LD_VAR 0 1
104856: IFFALSE 104923
// for i = 1 to birds do
104858: LD_ADDR_VAR 0 11
104862: PUSH
104863: DOUBLE
104864: LD_INT 1
104866: DEC
104867: ST_TO_ADDR
104868: LD_VAR 0 1
104872: PUSH
104873: FOR_TO
104874: IFFALSE 104921
// begin hc_class := 18 ;
104876: LD_ADDR_OWVAR 28
104880: PUSH
104881: LD_INT 18
104883: ST_TO_ADDR
// hc_gallery =  ;
104884: LD_ADDR_OWVAR 33
104888: PUSH
104889: LD_STRING 
104891: ST_TO_ADDR
// animal := CreateHuman ;
104892: LD_ADDR_VAR 0 12
104896: PUSH
104897: CALL_OW 44
104901: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104902: LD_VAR 0 12
104906: PPUSH
104907: LD_VAR 0 8
104911: PPUSH
104912: LD_INT 0
104914: PPUSH
104915: CALL 106909 0 3
// end ;
104919: GO 104873
104921: POP
104922: POP
// if tigers then
104923: LD_VAR 0 2
104927: IFFALSE 105011
// for i = 1 to tigers do
104929: LD_ADDR_VAR 0 11
104933: PUSH
104934: DOUBLE
104935: LD_INT 1
104937: DEC
104938: ST_TO_ADDR
104939: LD_VAR 0 2
104943: PUSH
104944: FOR_TO
104945: IFFALSE 105009
// begin hc_class = class_tiger ;
104947: LD_ADDR_OWVAR 28
104951: PUSH
104952: LD_INT 14
104954: ST_TO_ADDR
// hc_gallery =  ;
104955: LD_ADDR_OWVAR 33
104959: PUSH
104960: LD_STRING 
104962: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
104963: LD_ADDR_OWVAR 35
104967: PUSH
104968: LD_INT 7
104970: NEG
104971: PPUSH
104972: LD_INT 7
104974: PPUSH
104975: CALL_OW 12
104979: ST_TO_ADDR
// animal := CreateHuman ;
104980: LD_ADDR_VAR 0 12
104984: PUSH
104985: CALL_OW 44
104989: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104990: LD_VAR 0 12
104994: PPUSH
104995: LD_VAR 0 8
104999: PPUSH
105000: LD_INT 0
105002: PPUSH
105003: CALL 106909 0 3
// end ;
105007: GO 104944
105009: POP
105010: POP
// if apemans then
105011: LD_VAR 0 3
105015: IFFALSE 105138
// for i = 1 to apemans do
105017: LD_ADDR_VAR 0 11
105021: PUSH
105022: DOUBLE
105023: LD_INT 1
105025: DEC
105026: ST_TO_ADDR
105027: LD_VAR 0 3
105031: PUSH
105032: FOR_TO
105033: IFFALSE 105136
// begin hc_class = class_apeman ;
105035: LD_ADDR_OWVAR 28
105039: PUSH
105040: LD_INT 12
105042: ST_TO_ADDR
// hc_gallery =  ;
105043: LD_ADDR_OWVAR 33
105047: PUSH
105048: LD_STRING 
105050: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
105051: LD_ADDR_OWVAR 35
105055: PUSH
105056: LD_INT 2
105058: NEG
105059: PPUSH
105060: LD_INT 2
105062: PPUSH
105063: CALL_OW 12
105067: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
105068: LD_ADDR_OWVAR 31
105072: PUSH
105073: LD_INT 1
105075: PPUSH
105076: LD_INT 3
105078: PPUSH
105079: CALL_OW 12
105083: PUSH
105084: LD_INT 1
105086: PPUSH
105087: LD_INT 3
105089: PPUSH
105090: CALL_OW 12
105094: PUSH
105095: LD_INT 0
105097: PUSH
105098: LD_INT 0
105100: PUSH
105101: EMPTY
105102: LIST
105103: LIST
105104: LIST
105105: LIST
105106: ST_TO_ADDR
// animal := CreateHuman ;
105107: LD_ADDR_VAR 0 12
105111: PUSH
105112: CALL_OW 44
105116: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
105117: LD_VAR 0 12
105121: PPUSH
105122: LD_VAR 0 8
105126: PPUSH
105127: LD_INT 0
105129: PPUSH
105130: CALL 106909 0 3
// end ;
105134: GO 105032
105136: POP
105137: POP
// if enchidnas then
105138: LD_VAR 0 4
105142: IFFALSE 105209
// for i = 1 to enchidnas do
105144: LD_ADDR_VAR 0 11
105148: PUSH
105149: DOUBLE
105150: LD_INT 1
105152: DEC
105153: ST_TO_ADDR
105154: LD_VAR 0 4
105158: PUSH
105159: FOR_TO
105160: IFFALSE 105207
// begin hc_class = 13 ;
105162: LD_ADDR_OWVAR 28
105166: PUSH
105167: LD_INT 13
105169: ST_TO_ADDR
// hc_gallery =  ;
105170: LD_ADDR_OWVAR 33
105174: PUSH
105175: LD_STRING 
105177: ST_TO_ADDR
// animal := CreateHuman ;
105178: LD_ADDR_VAR 0 12
105182: PUSH
105183: CALL_OW 44
105187: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
105188: LD_VAR 0 12
105192: PPUSH
105193: LD_VAR 0 8
105197: PPUSH
105198: LD_INT 0
105200: PPUSH
105201: CALL 106909 0 3
// end ;
105205: GO 105159
105207: POP
105208: POP
// if fishes then
105209: LD_VAR 0 7
105213: IFFALSE 105280
// for i = 1 to fishes do
105215: LD_ADDR_VAR 0 11
105219: PUSH
105220: DOUBLE
105221: LD_INT 1
105223: DEC
105224: ST_TO_ADDR
105225: LD_VAR 0 7
105229: PUSH
105230: FOR_TO
105231: IFFALSE 105278
// begin hc_class = 20 ;
105233: LD_ADDR_OWVAR 28
105237: PUSH
105238: LD_INT 20
105240: ST_TO_ADDR
// hc_gallery =  ;
105241: LD_ADDR_OWVAR 33
105245: PUSH
105246: LD_STRING 
105248: ST_TO_ADDR
// animal := CreateHuman ;
105249: LD_ADDR_VAR 0 12
105253: PUSH
105254: CALL_OW 44
105258: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
105259: LD_VAR 0 12
105263: PPUSH
105264: LD_VAR 0 9
105268: PPUSH
105269: LD_INT 0
105271: PPUSH
105272: CALL 106909 0 3
// end ;
105276: GO 105230
105278: POP
105279: POP
// end ;
105280: LD_VAR 0 10
105284: RET
// export function WantHeal ( sci , unit ) ; begin
105285: LD_INT 0
105287: PPUSH
// if GetTaskList ( sci ) > 0 then
105288: LD_VAR 0 1
105292: PPUSH
105293: CALL_OW 437
105297: PUSH
105298: LD_INT 0
105300: GREATER
105301: IFFALSE 105371
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
105303: LD_VAR 0 1
105307: PPUSH
105308: CALL_OW 437
105312: PUSH
105313: LD_INT 1
105315: ARRAY
105316: PUSH
105317: LD_INT 1
105319: ARRAY
105320: PUSH
105321: LD_STRING l
105323: EQUAL
105324: PUSH
105325: LD_VAR 0 1
105329: PPUSH
105330: CALL_OW 437
105334: PUSH
105335: LD_INT 1
105337: ARRAY
105338: PUSH
105339: LD_INT 4
105341: ARRAY
105342: PUSH
105343: LD_VAR 0 2
105347: EQUAL
105348: AND
105349: IFFALSE 105361
// result := true else
105351: LD_ADDR_VAR 0 3
105355: PUSH
105356: LD_INT 1
105358: ST_TO_ADDR
105359: GO 105369
// result := false ;
105361: LD_ADDR_VAR 0 3
105365: PUSH
105366: LD_INT 0
105368: ST_TO_ADDR
// end else
105369: GO 105379
// result := false ;
105371: LD_ADDR_VAR 0 3
105375: PUSH
105376: LD_INT 0
105378: ST_TO_ADDR
// end ;
105379: LD_VAR 0 3
105383: RET
// export function HealTarget ( sci ) ; begin
105384: LD_INT 0
105386: PPUSH
// if not sci then
105387: LD_VAR 0 1
105391: NOT
105392: IFFALSE 105396
// exit ;
105394: GO 105461
// result := 0 ;
105396: LD_ADDR_VAR 0 2
105400: PUSH
105401: LD_INT 0
105403: ST_TO_ADDR
// if GetTaskList ( sci ) then
105404: LD_VAR 0 1
105408: PPUSH
105409: CALL_OW 437
105413: IFFALSE 105461
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
105415: LD_VAR 0 1
105419: PPUSH
105420: CALL_OW 437
105424: PUSH
105425: LD_INT 1
105427: ARRAY
105428: PUSH
105429: LD_INT 1
105431: ARRAY
105432: PUSH
105433: LD_STRING l
105435: EQUAL
105436: IFFALSE 105461
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
105438: LD_ADDR_VAR 0 2
105442: PUSH
105443: LD_VAR 0 1
105447: PPUSH
105448: CALL_OW 437
105452: PUSH
105453: LD_INT 1
105455: ARRAY
105456: PUSH
105457: LD_INT 4
105459: ARRAY
105460: ST_TO_ADDR
// end ;
105461: LD_VAR 0 2
105465: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
105466: LD_INT 0
105468: PPUSH
105469: PPUSH
105470: PPUSH
105471: PPUSH
// if not base_units then
105472: LD_VAR 0 1
105476: NOT
105477: IFFALSE 105481
// exit ;
105479: GO 105568
// result := false ;
105481: LD_ADDR_VAR 0 2
105485: PUSH
105486: LD_INT 0
105488: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
105489: LD_ADDR_VAR 0 5
105493: PUSH
105494: LD_VAR 0 1
105498: PPUSH
105499: LD_INT 21
105501: PUSH
105502: LD_INT 3
105504: PUSH
105505: EMPTY
105506: LIST
105507: LIST
105508: PPUSH
105509: CALL_OW 72
105513: ST_TO_ADDR
// if not tmp then
105514: LD_VAR 0 5
105518: NOT
105519: IFFALSE 105523
// exit ;
105521: GO 105568
// for i in tmp do
105523: LD_ADDR_VAR 0 3
105527: PUSH
105528: LD_VAR 0 5
105532: PUSH
105533: FOR_IN
105534: IFFALSE 105566
// begin result := EnemyInRange ( i , 22 ) ;
105536: LD_ADDR_VAR 0 2
105540: PUSH
105541: LD_VAR 0 3
105545: PPUSH
105546: LD_INT 22
105548: PPUSH
105549: CALL 103146 0 2
105553: ST_TO_ADDR
// if result then
105554: LD_VAR 0 2
105558: IFFALSE 105564
// exit ;
105560: POP
105561: POP
105562: GO 105568
// end ;
105564: GO 105533
105566: POP
105567: POP
// end ;
105568: LD_VAR 0 2
105572: RET
// export function FilterByTag ( units , tag ) ; begin
105573: LD_INT 0
105575: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
105576: LD_ADDR_VAR 0 3
105580: PUSH
105581: LD_VAR 0 1
105585: PPUSH
105586: LD_INT 120
105588: PUSH
105589: LD_VAR 0 2
105593: PUSH
105594: EMPTY
105595: LIST
105596: LIST
105597: PPUSH
105598: CALL_OW 72
105602: ST_TO_ADDR
// end ;
105603: LD_VAR 0 3
105607: RET
// export function IsDriver ( un ) ; begin
105608: LD_INT 0
105610: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
105611: LD_ADDR_VAR 0 2
105615: PUSH
105616: LD_VAR 0 1
105620: PUSH
105621: LD_INT 55
105623: PUSH
105624: EMPTY
105625: LIST
105626: PPUSH
105627: CALL_OW 69
105631: IN
105632: ST_TO_ADDR
// end ;
105633: LD_VAR 0 2
105637: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
105638: LD_INT 0
105640: PPUSH
105641: PPUSH
// list := [ ] ;
105642: LD_ADDR_VAR 0 5
105646: PUSH
105647: EMPTY
105648: ST_TO_ADDR
// case d of 0 :
105649: LD_VAR 0 3
105653: PUSH
105654: LD_INT 0
105656: DOUBLE
105657: EQUAL
105658: IFTRUE 105662
105660: GO 105795
105662: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
105663: LD_ADDR_VAR 0 5
105667: PUSH
105668: LD_VAR 0 1
105672: PUSH
105673: LD_INT 4
105675: MINUS
105676: PUSH
105677: LD_VAR 0 2
105681: PUSH
105682: LD_INT 4
105684: MINUS
105685: PUSH
105686: LD_INT 2
105688: PUSH
105689: EMPTY
105690: LIST
105691: LIST
105692: LIST
105693: PUSH
105694: LD_VAR 0 1
105698: PUSH
105699: LD_INT 3
105701: MINUS
105702: PUSH
105703: LD_VAR 0 2
105707: PUSH
105708: LD_INT 1
105710: PUSH
105711: EMPTY
105712: LIST
105713: LIST
105714: LIST
105715: PUSH
105716: LD_VAR 0 1
105720: PUSH
105721: LD_INT 4
105723: PLUS
105724: PUSH
105725: LD_VAR 0 2
105729: PUSH
105730: LD_INT 4
105732: PUSH
105733: EMPTY
105734: LIST
105735: LIST
105736: LIST
105737: PUSH
105738: LD_VAR 0 1
105742: PUSH
105743: LD_INT 3
105745: PLUS
105746: PUSH
105747: LD_VAR 0 2
105751: PUSH
105752: LD_INT 3
105754: PLUS
105755: PUSH
105756: LD_INT 5
105758: PUSH
105759: EMPTY
105760: LIST
105761: LIST
105762: LIST
105763: PUSH
105764: LD_VAR 0 1
105768: PUSH
105769: LD_VAR 0 2
105773: PUSH
105774: LD_INT 4
105776: PLUS
105777: PUSH
105778: LD_INT 0
105780: PUSH
105781: EMPTY
105782: LIST
105783: LIST
105784: LIST
105785: PUSH
105786: EMPTY
105787: LIST
105788: LIST
105789: LIST
105790: LIST
105791: LIST
105792: ST_TO_ADDR
// end ; 1 :
105793: GO 106493
105795: LD_INT 1
105797: DOUBLE
105798: EQUAL
105799: IFTRUE 105803
105801: GO 105936
105803: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
105804: LD_ADDR_VAR 0 5
105808: PUSH
105809: LD_VAR 0 1
105813: PUSH
105814: LD_VAR 0 2
105818: PUSH
105819: LD_INT 4
105821: MINUS
105822: PUSH
105823: LD_INT 3
105825: PUSH
105826: EMPTY
105827: LIST
105828: LIST
105829: LIST
105830: PUSH
105831: LD_VAR 0 1
105835: PUSH
105836: LD_INT 3
105838: MINUS
105839: PUSH
105840: LD_VAR 0 2
105844: PUSH
105845: LD_INT 3
105847: MINUS
105848: PUSH
105849: LD_INT 2
105851: PUSH
105852: EMPTY
105853: LIST
105854: LIST
105855: LIST
105856: PUSH
105857: LD_VAR 0 1
105861: PUSH
105862: LD_INT 4
105864: MINUS
105865: PUSH
105866: LD_VAR 0 2
105870: PUSH
105871: LD_INT 1
105873: PUSH
105874: EMPTY
105875: LIST
105876: LIST
105877: LIST
105878: PUSH
105879: LD_VAR 0 1
105883: PUSH
105884: LD_VAR 0 2
105888: PUSH
105889: LD_INT 3
105891: PLUS
105892: PUSH
105893: LD_INT 0
105895: PUSH
105896: EMPTY
105897: LIST
105898: LIST
105899: LIST
105900: PUSH
105901: LD_VAR 0 1
105905: PUSH
105906: LD_INT 4
105908: PLUS
105909: PUSH
105910: LD_VAR 0 2
105914: PUSH
105915: LD_INT 4
105917: PLUS
105918: PUSH
105919: LD_INT 5
105921: PUSH
105922: EMPTY
105923: LIST
105924: LIST
105925: LIST
105926: PUSH
105927: EMPTY
105928: LIST
105929: LIST
105930: LIST
105931: LIST
105932: LIST
105933: ST_TO_ADDR
// end ; 2 :
105934: GO 106493
105936: LD_INT 2
105938: DOUBLE
105939: EQUAL
105940: IFTRUE 105944
105942: GO 106073
105944: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
105945: LD_ADDR_VAR 0 5
105949: PUSH
105950: LD_VAR 0 1
105954: PUSH
105955: LD_VAR 0 2
105959: PUSH
105960: LD_INT 3
105962: MINUS
105963: PUSH
105964: LD_INT 3
105966: PUSH
105967: EMPTY
105968: LIST
105969: LIST
105970: LIST
105971: PUSH
105972: LD_VAR 0 1
105976: PUSH
105977: LD_INT 4
105979: PLUS
105980: PUSH
105981: LD_VAR 0 2
105985: PUSH
105986: LD_INT 4
105988: PUSH
105989: EMPTY
105990: LIST
105991: LIST
105992: LIST
105993: PUSH
105994: LD_VAR 0 1
105998: PUSH
105999: LD_VAR 0 2
106003: PUSH
106004: LD_INT 4
106006: PLUS
106007: PUSH
106008: LD_INT 0
106010: PUSH
106011: EMPTY
106012: LIST
106013: LIST
106014: LIST
106015: PUSH
106016: LD_VAR 0 1
106020: PUSH
106021: LD_INT 3
106023: MINUS
106024: PUSH
106025: LD_VAR 0 2
106029: PUSH
106030: LD_INT 1
106032: PUSH
106033: EMPTY
106034: LIST
106035: LIST
106036: LIST
106037: PUSH
106038: LD_VAR 0 1
106042: PUSH
106043: LD_INT 4
106045: MINUS
106046: PUSH
106047: LD_VAR 0 2
106051: PUSH
106052: LD_INT 4
106054: MINUS
106055: PUSH
106056: LD_INT 2
106058: PUSH
106059: EMPTY
106060: LIST
106061: LIST
106062: LIST
106063: PUSH
106064: EMPTY
106065: LIST
106066: LIST
106067: LIST
106068: LIST
106069: LIST
106070: ST_TO_ADDR
// end ; 3 :
106071: GO 106493
106073: LD_INT 3
106075: DOUBLE
106076: EQUAL
106077: IFTRUE 106081
106079: GO 106214
106081: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
106082: LD_ADDR_VAR 0 5
106086: PUSH
106087: LD_VAR 0 1
106091: PUSH
106092: LD_INT 3
106094: PLUS
106095: PUSH
106096: LD_VAR 0 2
106100: PUSH
106101: LD_INT 4
106103: PUSH
106104: EMPTY
106105: LIST
106106: LIST
106107: LIST
106108: PUSH
106109: LD_VAR 0 1
106113: PUSH
106114: LD_INT 4
106116: PLUS
106117: PUSH
106118: LD_VAR 0 2
106122: PUSH
106123: LD_INT 4
106125: PLUS
106126: PUSH
106127: LD_INT 5
106129: PUSH
106130: EMPTY
106131: LIST
106132: LIST
106133: LIST
106134: PUSH
106135: LD_VAR 0 1
106139: PUSH
106140: LD_INT 4
106142: MINUS
106143: PUSH
106144: LD_VAR 0 2
106148: PUSH
106149: LD_INT 1
106151: PUSH
106152: EMPTY
106153: LIST
106154: LIST
106155: LIST
106156: PUSH
106157: LD_VAR 0 1
106161: PUSH
106162: LD_VAR 0 2
106166: PUSH
106167: LD_INT 4
106169: MINUS
106170: PUSH
106171: LD_INT 3
106173: PUSH
106174: EMPTY
106175: LIST
106176: LIST
106177: LIST
106178: PUSH
106179: LD_VAR 0 1
106183: PUSH
106184: LD_INT 3
106186: MINUS
106187: PUSH
106188: LD_VAR 0 2
106192: PUSH
106193: LD_INT 3
106195: MINUS
106196: PUSH
106197: LD_INT 2
106199: PUSH
106200: EMPTY
106201: LIST
106202: LIST
106203: LIST
106204: PUSH
106205: EMPTY
106206: LIST
106207: LIST
106208: LIST
106209: LIST
106210: LIST
106211: ST_TO_ADDR
// end ; 4 :
106212: GO 106493
106214: LD_INT 4
106216: DOUBLE
106217: EQUAL
106218: IFTRUE 106222
106220: GO 106355
106222: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
106223: LD_ADDR_VAR 0 5
106227: PUSH
106228: LD_VAR 0 1
106232: PUSH
106233: LD_VAR 0 2
106237: PUSH
106238: LD_INT 4
106240: PLUS
106241: PUSH
106242: LD_INT 0
106244: PUSH
106245: EMPTY
106246: LIST
106247: LIST
106248: LIST
106249: PUSH
106250: LD_VAR 0 1
106254: PUSH
106255: LD_INT 3
106257: PLUS
106258: PUSH
106259: LD_VAR 0 2
106263: PUSH
106264: LD_INT 3
106266: PLUS
106267: PUSH
106268: LD_INT 5
106270: PUSH
106271: EMPTY
106272: LIST
106273: LIST
106274: LIST
106275: PUSH
106276: LD_VAR 0 1
106280: PUSH
106281: LD_INT 4
106283: PLUS
106284: PUSH
106285: LD_VAR 0 2
106289: PUSH
106290: LD_INT 4
106292: PUSH
106293: EMPTY
106294: LIST
106295: LIST
106296: LIST
106297: PUSH
106298: LD_VAR 0 1
106302: PUSH
106303: LD_VAR 0 2
106307: PUSH
106308: LD_INT 3
106310: MINUS
106311: PUSH
106312: LD_INT 3
106314: PUSH
106315: EMPTY
106316: LIST
106317: LIST
106318: LIST
106319: PUSH
106320: LD_VAR 0 1
106324: PUSH
106325: LD_INT 4
106327: MINUS
106328: PUSH
106329: LD_VAR 0 2
106333: PUSH
106334: LD_INT 4
106336: MINUS
106337: PUSH
106338: LD_INT 2
106340: PUSH
106341: EMPTY
106342: LIST
106343: LIST
106344: LIST
106345: PUSH
106346: EMPTY
106347: LIST
106348: LIST
106349: LIST
106350: LIST
106351: LIST
106352: ST_TO_ADDR
// end ; 5 :
106353: GO 106493
106355: LD_INT 5
106357: DOUBLE
106358: EQUAL
106359: IFTRUE 106363
106361: GO 106492
106363: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
106364: LD_ADDR_VAR 0 5
106368: PUSH
106369: LD_VAR 0 1
106373: PUSH
106374: LD_INT 4
106376: MINUS
106377: PUSH
106378: LD_VAR 0 2
106382: PUSH
106383: LD_INT 1
106385: PUSH
106386: EMPTY
106387: LIST
106388: LIST
106389: LIST
106390: PUSH
106391: LD_VAR 0 1
106395: PUSH
106396: LD_VAR 0 2
106400: PUSH
106401: LD_INT 4
106403: MINUS
106404: PUSH
106405: LD_INT 3
106407: PUSH
106408: EMPTY
106409: LIST
106410: LIST
106411: LIST
106412: PUSH
106413: LD_VAR 0 1
106417: PUSH
106418: LD_INT 4
106420: PLUS
106421: PUSH
106422: LD_VAR 0 2
106426: PUSH
106427: LD_INT 4
106429: PLUS
106430: PUSH
106431: LD_INT 5
106433: PUSH
106434: EMPTY
106435: LIST
106436: LIST
106437: LIST
106438: PUSH
106439: LD_VAR 0 1
106443: PUSH
106444: LD_INT 3
106446: PLUS
106447: PUSH
106448: LD_VAR 0 2
106452: PUSH
106453: LD_INT 4
106455: PUSH
106456: EMPTY
106457: LIST
106458: LIST
106459: LIST
106460: PUSH
106461: LD_VAR 0 1
106465: PUSH
106466: LD_VAR 0 2
106470: PUSH
106471: LD_INT 3
106473: PLUS
106474: PUSH
106475: LD_INT 0
106477: PUSH
106478: EMPTY
106479: LIST
106480: LIST
106481: LIST
106482: PUSH
106483: EMPTY
106484: LIST
106485: LIST
106486: LIST
106487: LIST
106488: LIST
106489: ST_TO_ADDR
// end ; end ;
106490: GO 106493
106492: POP
// result := list ;
106493: LD_ADDR_VAR 0 4
106497: PUSH
106498: LD_VAR 0 5
106502: ST_TO_ADDR
// end ;
106503: LD_VAR 0 4
106507: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
106508: LD_INT 0
106510: PPUSH
106511: PPUSH
106512: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
106513: LD_VAR 0 1
106517: NOT
106518: PUSH
106519: LD_VAR 0 2
106523: PUSH
106524: LD_INT 1
106526: PUSH
106527: LD_INT 2
106529: PUSH
106530: LD_INT 3
106532: PUSH
106533: LD_INT 4
106535: PUSH
106536: EMPTY
106537: LIST
106538: LIST
106539: LIST
106540: LIST
106541: IN
106542: NOT
106543: OR
106544: IFFALSE 106548
// exit ;
106546: GO 106631
// tmp := [ ] ;
106548: LD_ADDR_VAR 0 5
106552: PUSH
106553: EMPTY
106554: ST_TO_ADDR
// for i in units do
106555: LD_ADDR_VAR 0 4
106559: PUSH
106560: LD_VAR 0 1
106564: PUSH
106565: FOR_IN
106566: IFFALSE 106600
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
106568: LD_ADDR_VAR 0 5
106572: PUSH
106573: LD_VAR 0 5
106577: PPUSH
106578: LD_VAR 0 4
106582: PPUSH
106583: LD_VAR 0 2
106587: PPUSH
106588: CALL_OW 259
106592: PPUSH
106593: CALL 108004 0 2
106597: ST_TO_ADDR
106598: GO 106565
106600: POP
106601: POP
// if not tmp then
106602: LD_VAR 0 5
106606: NOT
106607: IFFALSE 106611
// exit ;
106609: GO 106631
// result := SortListByListDesc ( units , tmp ) ;
106611: LD_ADDR_VAR 0 3
106615: PUSH
106616: LD_VAR 0 1
106620: PPUSH
106621: LD_VAR 0 5
106625: PPUSH
106626: CALL_OW 77
106630: ST_TO_ADDR
// end ;
106631: LD_VAR 0 3
106635: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
106636: LD_INT 0
106638: PPUSH
106639: PPUSH
106640: PPUSH
// result := false ;
106641: LD_ADDR_VAR 0 3
106645: PUSH
106646: LD_INT 0
106648: ST_TO_ADDR
// if not building then
106649: LD_VAR 0 2
106653: NOT
106654: IFFALSE 106658
// exit ;
106656: GO 106796
// x := GetX ( building ) ;
106658: LD_ADDR_VAR 0 4
106662: PUSH
106663: LD_VAR 0 2
106667: PPUSH
106668: CALL_OW 250
106672: ST_TO_ADDR
// y := GetY ( building ) ;
106673: LD_ADDR_VAR 0 5
106677: PUSH
106678: LD_VAR 0 2
106682: PPUSH
106683: CALL_OW 251
106687: ST_TO_ADDR
// if not x or not y then
106688: LD_VAR 0 4
106692: NOT
106693: PUSH
106694: LD_VAR 0 5
106698: NOT
106699: OR
106700: IFFALSE 106704
// exit ;
106702: GO 106796
// if GetTaskList ( unit ) then
106704: LD_VAR 0 1
106708: PPUSH
106709: CALL_OW 437
106713: IFFALSE 106796
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106715: LD_STRING e
106717: PUSH
106718: LD_VAR 0 1
106722: PPUSH
106723: CALL_OW 437
106727: PUSH
106728: LD_INT 1
106730: ARRAY
106731: PUSH
106732: LD_INT 1
106734: ARRAY
106735: EQUAL
106736: PUSH
106737: LD_VAR 0 4
106741: PUSH
106742: LD_VAR 0 1
106746: PPUSH
106747: CALL_OW 437
106751: PUSH
106752: LD_INT 1
106754: ARRAY
106755: PUSH
106756: LD_INT 2
106758: ARRAY
106759: EQUAL
106760: AND
106761: PUSH
106762: LD_VAR 0 5
106766: PUSH
106767: LD_VAR 0 1
106771: PPUSH
106772: CALL_OW 437
106776: PUSH
106777: LD_INT 1
106779: ARRAY
106780: PUSH
106781: LD_INT 3
106783: ARRAY
106784: EQUAL
106785: AND
106786: IFFALSE 106796
// result := true end ;
106788: LD_ADDR_VAR 0 3
106792: PUSH
106793: LD_INT 1
106795: ST_TO_ADDR
// end ;
106796: LD_VAR 0 3
106800: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
106801: LD_INT 0
106803: PPUSH
// result := false ;
106804: LD_ADDR_VAR 0 4
106808: PUSH
106809: LD_INT 0
106811: ST_TO_ADDR
// if GetTaskList ( unit ) then
106812: LD_VAR 0 1
106816: PPUSH
106817: CALL_OW 437
106821: IFFALSE 106904
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106823: LD_STRING M
106825: PUSH
106826: LD_VAR 0 1
106830: PPUSH
106831: CALL_OW 437
106835: PUSH
106836: LD_INT 1
106838: ARRAY
106839: PUSH
106840: LD_INT 1
106842: ARRAY
106843: EQUAL
106844: PUSH
106845: LD_VAR 0 2
106849: PUSH
106850: LD_VAR 0 1
106854: PPUSH
106855: CALL_OW 437
106859: PUSH
106860: LD_INT 1
106862: ARRAY
106863: PUSH
106864: LD_INT 2
106866: ARRAY
106867: EQUAL
106868: AND
106869: PUSH
106870: LD_VAR 0 3
106874: PUSH
106875: LD_VAR 0 1
106879: PPUSH
106880: CALL_OW 437
106884: PUSH
106885: LD_INT 1
106887: ARRAY
106888: PUSH
106889: LD_INT 3
106891: ARRAY
106892: EQUAL
106893: AND
106894: IFFALSE 106904
// result := true ;
106896: LD_ADDR_VAR 0 4
106900: PUSH
106901: LD_INT 1
106903: ST_TO_ADDR
// end ; end ;
106904: LD_VAR 0 4
106908: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
106909: LD_INT 0
106911: PPUSH
106912: PPUSH
106913: PPUSH
106914: PPUSH
// if not unit or not area then
106915: LD_VAR 0 1
106919: NOT
106920: PUSH
106921: LD_VAR 0 2
106925: NOT
106926: OR
106927: IFFALSE 106931
// exit ;
106929: GO 107107
// tmp := AreaToList ( area , i ) ;
106931: LD_ADDR_VAR 0 6
106935: PUSH
106936: LD_VAR 0 2
106940: PPUSH
106941: LD_VAR 0 5
106945: PPUSH
106946: CALL_OW 517
106950: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
106951: LD_ADDR_VAR 0 5
106955: PUSH
106956: DOUBLE
106957: LD_INT 1
106959: DEC
106960: ST_TO_ADDR
106961: LD_VAR 0 6
106965: PUSH
106966: LD_INT 1
106968: ARRAY
106969: PUSH
106970: FOR_TO
106971: IFFALSE 107105
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
106973: LD_ADDR_VAR 0 7
106977: PUSH
106978: LD_VAR 0 6
106982: PUSH
106983: LD_INT 1
106985: ARRAY
106986: PUSH
106987: LD_VAR 0 5
106991: ARRAY
106992: PUSH
106993: LD_VAR 0 6
106997: PUSH
106998: LD_INT 2
107000: ARRAY
107001: PUSH
107002: LD_VAR 0 5
107006: ARRAY
107007: PUSH
107008: EMPTY
107009: LIST
107010: LIST
107011: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
107012: LD_INT 92
107014: PUSH
107015: LD_VAR 0 7
107019: PUSH
107020: LD_INT 1
107022: ARRAY
107023: PUSH
107024: LD_VAR 0 7
107028: PUSH
107029: LD_INT 2
107031: ARRAY
107032: PUSH
107033: LD_INT 2
107035: PUSH
107036: EMPTY
107037: LIST
107038: LIST
107039: LIST
107040: LIST
107041: PPUSH
107042: CALL_OW 69
107046: PUSH
107047: LD_INT 0
107049: EQUAL
107050: IFFALSE 107103
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
107052: LD_VAR 0 1
107056: PPUSH
107057: LD_VAR 0 7
107061: PUSH
107062: LD_INT 1
107064: ARRAY
107065: PPUSH
107066: LD_VAR 0 7
107070: PUSH
107071: LD_INT 2
107073: ARRAY
107074: PPUSH
107075: LD_VAR 0 3
107079: PPUSH
107080: CALL_OW 48
// result := IsPlaced ( unit ) ;
107084: LD_ADDR_VAR 0 4
107088: PUSH
107089: LD_VAR 0 1
107093: PPUSH
107094: CALL_OW 305
107098: ST_TO_ADDR
// exit ;
107099: POP
107100: POP
107101: GO 107107
// end ; end ;
107103: GO 106970
107105: POP
107106: POP
// end ;
107107: LD_VAR 0 4
107111: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
107112: LD_INT 0
107114: PPUSH
107115: PPUSH
107116: PPUSH
// if not side or side > 8 then
107117: LD_VAR 0 1
107121: NOT
107122: PUSH
107123: LD_VAR 0 1
107127: PUSH
107128: LD_INT 8
107130: GREATER
107131: OR
107132: IFFALSE 107136
// exit ;
107134: GO 107323
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
107136: LD_ADDR_VAR 0 4
107140: PUSH
107141: LD_INT 22
107143: PUSH
107144: LD_VAR 0 1
107148: PUSH
107149: EMPTY
107150: LIST
107151: LIST
107152: PUSH
107153: LD_INT 21
107155: PUSH
107156: LD_INT 3
107158: PUSH
107159: EMPTY
107160: LIST
107161: LIST
107162: PUSH
107163: EMPTY
107164: LIST
107165: LIST
107166: PPUSH
107167: CALL_OW 69
107171: ST_TO_ADDR
// if not tmp then
107172: LD_VAR 0 4
107176: NOT
107177: IFFALSE 107181
// exit ;
107179: GO 107323
// enable_addtolog := true ;
107181: LD_ADDR_OWVAR 81
107185: PUSH
107186: LD_INT 1
107188: ST_TO_ADDR
// AddToLog ( [ ) ;
107189: LD_STRING [
107191: PPUSH
107192: CALL_OW 561
// for i in tmp do
107196: LD_ADDR_VAR 0 3
107200: PUSH
107201: LD_VAR 0 4
107205: PUSH
107206: FOR_IN
107207: IFFALSE 107314
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
107209: LD_STRING [
107211: PUSH
107212: LD_VAR 0 3
107216: PPUSH
107217: CALL_OW 266
107221: STR
107222: PUSH
107223: LD_STRING , 
107225: STR
107226: PUSH
107227: LD_VAR 0 3
107231: PPUSH
107232: CALL_OW 250
107236: STR
107237: PUSH
107238: LD_STRING , 
107240: STR
107241: PUSH
107242: LD_VAR 0 3
107246: PPUSH
107247: CALL_OW 251
107251: STR
107252: PUSH
107253: LD_STRING , 
107255: STR
107256: PUSH
107257: LD_VAR 0 3
107261: PPUSH
107262: CALL_OW 254
107266: STR
107267: PUSH
107268: LD_STRING , 
107270: STR
107271: PUSH
107272: LD_VAR 0 3
107276: PPUSH
107277: LD_INT 1
107279: PPUSH
107280: CALL_OW 268
107284: STR
107285: PUSH
107286: LD_STRING , 
107288: STR
107289: PUSH
107290: LD_VAR 0 3
107294: PPUSH
107295: LD_INT 2
107297: PPUSH
107298: CALL_OW 268
107302: STR
107303: PUSH
107304: LD_STRING ],
107306: STR
107307: PPUSH
107308: CALL_OW 561
// end ;
107312: GO 107206
107314: POP
107315: POP
// AddToLog ( ]; ) ;
107316: LD_STRING ];
107318: PPUSH
107319: CALL_OW 561
// end ;
107323: LD_VAR 0 2
107327: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
107328: LD_INT 0
107330: PPUSH
107331: PPUSH
107332: PPUSH
107333: PPUSH
107334: PPUSH
// if not area or not rate or not max then
107335: LD_VAR 0 1
107339: NOT
107340: PUSH
107341: LD_VAR 0 2
107345: NOT
107346: OR
107347: PUSH
107348: LD_VAR 0 4
107352: NOT
107353: OR
107354: IFFALSE 107358
// exit ;
107356: GO 107547
// while 1 do
107358: LD_INT 1
107360: IFFALSE 107547
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
107362: LD_ADDR_VAR 0 9
107366: PUSH
107367: LD_VAR 0 1
107371: PPUSH
107372: LD_INT 1
107374: PPUSH
107375: CALL_OW 287
107379: PUSH
107380: LD_INT 10
107382: MUL
107383: ST_TO_ADDR
// r := rate / 10 ;
107384: LD_ADDR_VAR 0 7
107388: PUSH
107389: LD_VAR 0 2
107393: PUSH
107394: LD_INT 10
107396: DIVREAL
107397: ST_TO_ADDR
// time := 1 1$00 ;
107398: LD_ADDR_VAR 0 8
107402: PUSH
107403: LD_INT 2100
107405: ST_TO_ADDR
// if amount < min then
107406: LD_VAR 0 9
107410: PUSH
107411: LD_VAR 0 3
107415: LESS
107416: IFFALSE 107434
// r := r * 2 else
107418: LD_ADDR_VAR 0 7
107422: PUSH
107423: LD_VAR 0 7
107427: PUSH
107428: LD_INT 2
107430: MUL
107431: ST_TO_ADDR
107432: GO 107460
// if amount > max then
107434: LD_VAR 0 9
107438: PUSH
107439: LD_VAR 0 4
107443: GREATER
107444: IFFALSE 107460
// r := r / 2 ;
107446: LD_ADDR_VAR 0 7
107450: PUSH
107451: LD_VAR 0 7
107455: PUSH
107456: LD_INT 2
107458: DIVREAL
107459: ST_TO_ADDR
// time := time / r ;
107460: LD_ADDR_VAR 0 8
107464: PUSH
107465: LD_VAR 0 8
107469: PUSH
107470: LD_VAR 0 7
107474: DIVREAL
107475: ST_TO_ADDR
// if time < 0 then
107476: LD_VAR 0 8
107480: PUSH
107481: LD_INT 0
107483: LESS
107484: IFFALSE 107501
// time := time * - 1 ;
107486: LD_ADDR_VAR 0 8
107490: PUSH
107491: LD_VAR 0 8
107495: PUSH
107496: LD_INT 1
107498: NEG
107499: MUL
107500: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
107501: LD_VAR 0 8
107505: PUSH
107506: LD_INT 35
107508: PPUSH
107509: LD_INT 875
107511: PPUSH
107512: CALL_OW 12
107516: PLUS
107517: PPUSH
107518: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
107522: LD_INT 1
107524: PPUSH
107525: LD_INT 5
107527: PPUSH
107528: CALL_OW 12
107532: PPUSH
107533: LD_VAR 0 1
107537: PPUSH
107538: LD_INT 1
107540: PPUSH
107541: CALL_OW 55
// end ;
107545: GO 107358
// end ;
107547: LD_VAR 0 5
107551: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
107552: LD_INT 0
107554: PPUSH
107555: PPUSH
107556: PPUSH
107557: PPUSH
107558: PPUSH
107559: PPUSH
107560: PPUSH
107561: PPUSH
// if not turrets or not factories then
107562: LD_VAR 0 1
107566: NOT
107567: PUSH
107568: LD_VAR 0 2
107572: NOT
107573: OR
107574: IFFALSE 107578
// exit ;
107576: GO 107885
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
107578: LD_ADDR_VAR 0 10
107582: PUSH
107583: LD_INT 5
107585: PUSH
107586: LD_INT 6
107588: PUSH
107589: EMPTY
107590: LIST
107591: LIST
107592: PUSH
107593: LD_INT 2
107595: PUSH
107596: LD_INT 4
107598: PUSH
107599: EMPTY
107600: LIST
107601: LIST
107602: PUSH
107603: LD_INT 3
107605: PUSH
107606: LD_INT 5
107608: PUSH
107609: EMPTY
107610: LIST
107611: LIST
107612: PUSH
107613: EMPTY
107614: LIST
107615: LIST
107616: LIST
107617: PUSH
107618: LD_INT 24
107620: PUSH
107621: LD_INT 25
107623: PUSH
107624: EMPTY
107625: LIST
107626: LIST
107627: PUSH
107628: LD_INT 23
107630: PUSH
107631: LD_INT 27
107633: PUSH
107634: EMPTY
107635: LIST
107636: LIST
107637: PUSH
107638: EMPTY
107639: LIST
107640: LIST
107641: PUSH
107642: LD_INT 42
107644: PUSH
107645: LD_INT 43
107647: PUSH
107648: EMPTY
107649: LIST
107650: LIST
107651: PUSH
107652: LD_INT 44
107654: PUSH
107655: LD_INT 46
107657: PUSH
107658: EMPTY
107659: LIST
107660: LIST
107661: PUSH
107662: LD_INT 45
107664: PUSH
107665: LD_INT 47
107667: PUSH
107668: EMPTY
107669: LIST
107670: LIST
107671: PUSH
107672: EMPTY
107673: LIST
107674: LIST
107675: LIST
107676: PUSH
107677: EMPTY
107678: LIST
107679: LIST
107680: LIST
107681: ST_TO_ADDR
// result := [ ] ;
107682: LD_ADDR_VAR 0 3
107686: PUSH
107687: EMPTY
107688: ST_TO_ADDR
// for i in turrets do
107689: LD_ADDR_VAR 0 4
107693: PUSH
107694: LD_VAR 0 1
107698: PUSH
107699: FOR_IN
107700: IFFALSE 107883
// begin nat := GetNation ( i ) ;
107702: LD_ADDR_VAR 0 7
107706: PUSH
107707: LD_VAR 0 4
107711: PPUSH
107712: CALL_OW 248
107716: ST_TO_ADDR
// weapon := 0 ;
107717: LD_ADDR_VAR 0 8
107721: PUSH
107722: LD_INT 0
107724: ST_TO_ADDR
// if not nat then
107725: LD_VAR 0 7
107729: NOT
107730: IFFALSE 107734
// continue ;
107732: GO 107699
// for j in list [ nat ] do
107734: LD_ADDR_VAR 0 5
107738: PUSH
107739: LD_VAR 0 10
107743: PUSH
107744: LD_VAR 0 7
107748: ARRAY
107749: PUSH
107750: FOR_IN
107751: IFFALSE 107792
// if GetBWeapon ( i ) = j [ 1 ] then
107753: LD_VAR 0 4
107757: PPUSH
107758: CALL_OW 269
107762: PUSH
107763: LD_VAR 0 5
107767: PUSH
107768: LD_INT 1
107770: ARRAY
107771: EQUAL
107772: IFFALSE 107790
// begin weapon := j [ 2 ] ;
107774: LD_ADDR_VAR 0 8
107778: PUSH
107779: LD_VAR 0 5
107783: PUSH
107784: LD_INT 2
107786: ARRAY
107787: ST_TO_ADDR
// break ;
107788: GO 107792
// end ;
107790: GO 107750
107792: POP
107793: POP
// if not weapon then
107794: LD_VAR 0 8
107798: NOT
107799: IFFALSE 107803
// continue ;
107801: GO 107699
// for k in factories do
107803: LD_ADDR_VAR 0 6
107807: PUSH
107808: LD_VAR 0 2
107812: PUSH
107813: FOR_IN
107814: IFFALSE 107879
// begin weapons := AvailableWeaponList ( k ) ;
107816: LD_ADDR_VAR 0 9
107820: PUSH
107821: LD_VAR 0 6
107825: PPUSH
107826: CALL_OW 478
107830: ST_TO_ADDR
// if not weapons then
107831: LD_VAR 0 9
107835: NOT
107836: IFFALSE 107840
// continue ;
107838: GO 107813
// if weapon in weapons then
107840: LD_VAR 0 8
107844: PUSH
107845: LD_VAR 0 9
107849: IN
107850: IFFALSE 107877
// begin result := [ i , weapon ] ;
107852: LD_ADDR_VAR 0 3
107856: PUSH
107857: LD_VAR 0 4
107861: PUSH
107862: LD_VAR 0 8
107866: PUSH
107867: EMPTY
107868: LIST
107869: LIST
107870: ST_TO_ADDR
// exit ;
107871: POP
107872: POP
107873: POP
107874: POP
107875: GO 107885
// end ; end ;
107877: GO 107813
107879: POP
107880: POP
// end ;
107881: GO 107699
107883: POP
107884: POP
// end ;
107885: LD_VAR 0 3
107889: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
107890: LD_INT 0
107892: PPUSH
// if not side or side > 8 then
107893: LD_VAR 0 3
107897: NOT
107898: PUSH
107899: LD_VAR 0 3
107903: PUSH
107904: LD_INT 8
107906: GREATER
107907: OR
107908: IFFALSE 107912
// exit ;
107910: GO 107971
// if not range then
107912: LD_VAR 0 4
107916: NOT
107917: IFFALSE 107928
// range := - 12 ;
107919: LD_ADDR_VAR 0 4
107923: PUSH
107924: LD_INT 12
107926: NEG
107927: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
107928: LD_VAR 0 1
107932: PPUSH
107933: LD_VAR 0 2
107937: PPUSH
107938: LD_VAR 0 3
107942: PPUSH
107943: LD_VAR 0 4
107947: PPUSH
107948: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
107952: LD_VAR 0 1
107956: PPUSH
107957: LD_VAR 0 2
107961: PPUSH
107962: LD_VAR 0 3
107966: PPUSH
107967: CALL_OW 331
// end ;
107971: LD_VAR 0 5
107975: RET
// export function Video ( mode ) ; begin
107976: LD_INT 0
107978: PPUSH
// ingame_video = mode ;
107979: LD_ADDR_OWVAR 52
107983: PUSH
107984: LD_VAR 0 1
107988: ST_TO_ADDR
// interface_hidden = mode ;
107989: LD_ADDR_OWVAR 54
107993: PUSH
107994: LD_VAR 0 1
107998: ST_TO_ADDR
// end ;
107999: LD_VAR 0 2
108003: RET
// export function Join ( array , element ) ; begin
108004: LD_INT 0
108006: PPUSH
// result := Replace ( array , array + 1 , element ) ;
108007: LD_ADDR_VAR 0 3
108011: PUSH
108012: LD_VAR 0 1
108016: PPUSH
108017: LD_VAR 0 1
108021: PUSH
108022: LD_INT 1
108024: PLUS
108025: PPUSH
108026: LD_VAR 0 2
108030: PPUSH
108031: CALL_OW 1
108035: ST_TO_ADDR
// end ;
108036: LD_VAR 0 3
108040: RET
// export function JoinUnion ( array , element ) ; begin
108041: LD_INT 0
108043: PPUSH
// result := array union element ;
108044: LD_ADDR_VAR 0 3
108048: PUSH
108049: LD_VAR 0 1
108053: PUSH
108054: LD_VAR 0 2
108058: UNION
108059: ST_TO_ADDR
// end ;
108060: LD_VAR 0 3
108064: RET
// export function GetBehemoths ( side ) ; begin
108065: LD_INT 0
108067: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
108068: LD_ADDR_VAR 0 2
108072: PUSH
108073: LD_INT 22
108075: PUSH
108076: LD_VAR 0 1
108080: PUSH
108081: EMPTY
108082: LIST
108083: LIST
108084: PUSH
108085: LD_INT 31
108087: PUSH
108088: LD_INT 25
108090: PUSH
108091: EMPTY
108092: LIST
108093: LIST
108094: PUSH
108095: EMPTY
108096: LIST
108097: LIST
108098: PPUSH
108099: CALL_OW 69
108103: ST_TO_ADDR
// end ;
108104: LD_VAR 0 2
108108: RET
// export function Shuffle ( array ) ; var i , index ; begin
108109: LD_INT 0
108111: PPUSH
108112: PPUSH
108113: PPUSH
// result := [ ] ;
108114: LD_ADDR_VAR 0 2
108118: PUSH
108119: EMPTY
108120: ST_TO_ADDR
// if not array then
108121: LD_VAR 0 1
108125: NOT
108126: IFFALSE 108130
// exit ;
108128: GO 108229
// Randomize ;
108130: CALL_OW 10
// for i = array downto 1 do
108134: LD_ADDR_VAR 0 3
108138: PUSH
108139: DOUBLE
108140: LD_VAR 0 1
108144: INC
108145: ST_TO_ADDR
108146: LD_INT 1
108148: PUSH
108149: FOR_DOWNTO
108150: IFFALSE 108227
// begin index := rand ( 1 , array ) ;
108152: LD_ADDR_VAR 0 4
108156: PUSH
108157: LD_INT 1
108159: PPUSH
108160: LD_VAR 0 1
108164: PPUSH
108165: CALL_OW 12
108169: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
108170: LD_ADDR_VAR 0 2
108174: PUSH
108175: LD_VAR 0 2
108179: PPUSH
108180: LD_VAR 0 2
108184: PUSH
108185: LD_INT 1
108187: PLUS
108188: PPUSH
108189: LD_VAR 0 1
108193: PUSH
108194: LD_VAR 0 4
108198: ARRAY
108199: PPUSH
108200: CALL_OW 2
108204: ST_TO_ADDR
// array := Delete ( array , index ) ;
108205: LD_ADDR_VAR 0 1
108209: PUSH
108210: LD_VAR 0 1
108214: PPUSH
108215: LD_VAR 0 4
108219: PPUSH
108220: CALL_OW 3
108224: ST_TO_ADDR
// end ;
108225: GO 108149
108227: POP
108228: POP
// end ;
108229: LD_VAR 0 2
108233: RET
// export function GetBaseMaterials ( base ) ; begin
108234: LD_INT 0
108236: PPUSH
// result := [ 0 , 0 , 0 ] ;
108237: LD_ADDR_VAR 0 2
108241: PUSH
108242: LD_INT 0
108244: PUSH
108245: LD_INT 0
108247: PUSH
108248: LD_INT 0
108250: PUSH
108251: EMPTY
108252: LIST
108253: LIST
108254: LIST
108255: ST_TO_ADDR
// if not base then
108256: LD_VAR 0 1
108260: NOT
108261: IFFALSE 108265
// exit ;
108263: GO 108314
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
108265: LD_ADDR_VAR 0 2
108269: PUSH
108270: LD_VAR 0 1
108274: PPUSH
108275: LD_INT 1
108277: PPUSH
108278: CALL_OW 275
108282: PUSH
108283: LD_VAR 0 1
108287: PPUSH
108288: LD_INT 2
108290: PPUSH
108291: CALL_OW 275
108295: PUSH
108296: LD_VAR 0 1
108300: PPUSH
108301: LD_INT 3
108303: PPUSH
108304: CALL_OW 275
108308: PUSH
108309: EMPTY
108310: LIST
108311: LIST
108312: LIST
108313: ST_TO_ADDR
// end ;
108314: LD_VAR 0 2
108318: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
108319: LD_INT 0
108321: PPUSH
108322: PPUSH
// result := array ;
108323: LD_ADDR_VAR 0 3
108327: PUSH
108328: LD_VAR 0 1
108332: ST_TO_ADDR
// if size >= result then
108333: LD_VAR 0 2
108337: PUSH
108338: LD_VAR 0 3
108342: GREATEREQUAL
108343: IFFALSE 108347
// exit ;
108345: GO 108397
// if size then
108347: LD_VAR 0 2
108351: IFFALSE 108397
// for i := array downto size do
108353: LD_ADDR_VAR 0 4
108357: PUSH
108358: DOUBLE
108359: LD_VAR 0 1
108363: INC
108364: ST_TO_ADDR
108365: LD_VAR 0 2
108369: PUSH
108370: FOR_DOWNTO
108371: IFFALSE 108395
// result := Delete ( result , result ) ;
108373: LD_ADDR_VAR 0 3
108377: PUSH
108378: LD_VAR 0 3
108382: PPUSH
108383: LD_VAR 0 3
108387: PPUSH
108388: CALL_OW 3
108392: ST_TO_ADDR
108393: GO 108370
108395: POP
108396: POP
// end ;
108397: LD_VAR 0 3
108401: RET
// export function ComExit ( unit ) ; var tmp ; begin
108402: LD_INT 0
108404: PPUSH
108405: PPUSH
// if not IsInUnit ( unit ) then
108406: LD_VAR 0 1
108410: PPUSH
108411: CALL_OW 310
108415: NOT
108416: IFFALSE 108420
// exit ;
108418: GO 108480
// tmp := IsInUnit ( unit ) ;
108420: LD_ADDR_VAR 0 3
108424: PUSH
108425: LD_VAR 0 1
108429: PPUSH
108430: CALL_OW 310
108434: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
108435: LD_VAR 0 3
108439: PPUSH
108440: CALL_OW 247
108444: PUSH
108445: LD_INT 2
108447: EQUAL
108448: IFFALSE 108461
// ComExitVehicle ( unit ) else
108450: LD_VAR 0 1
108454: PPUSH
108455: CALL_OW 121
108459: GO 108470
// ComExitBuilding ( unit ) ;
108461: LD_VAR 0 1
108465: PPUSH
108466: CALL_OW 122
// result := tmp ;
108470: LD_ADDR_VAR 0 2
108474: PUSH
108475: LD_VAR 0 3
108479: ST_TO_ADDR
// end ;
108480: LD_VAR 0 2
108484: RET
// export function ComExitAll ( units ) ; var i ; begin
108485: LD_INT 0
108487: PPUSH
108488: PPUSH
// if not units then
108489: LD_VAR 0 1
108493: NOT
108494: IFFALSE 108498
// exit ;
108496: GO 108524
// for i in units do
108498: LD_ADDR_VAR 0 3
108502: PUSH
108503: LD_VAR 0 1
108507: PUSH
108508: FOR_IN
108509: IFFALSE 108522
// ComExit ( i ) ;
108511: LD_VAR 0 3
108515: PPUSH
108516: CALL 108402 0 1
108520: GO 108508
108522: POP
108523: POP
// end ;
108524: LD_VAR 0 2
108528: RET
// export function ResetHc ; begin
108529: LD_INT 0
108531: PPUSH
// InitHc ;
108532: CALL_OW 19
// hc_importance := 0 ;
108536: LD_ADDR_OWVAR 32
108540: PUSH
108541: LD_INT 0
108543: ST_TO_ADDR
// end ;
108544: LD_VAR 0 1
108548: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
108549: LD_INT 0
108551: PPUSH
108552: PPUSH
108553: PPUSH
// _x := ( x1 + x2 ) div 2 ;
108554: LD_ADDR_VAR 0 6
108558: PUSH
108559: LD_VAR 0 1
108563: PUSH
108564: LD_VAR 0 3
108568: PLUS
108569: PUSH
108570: LD_INT 2
108572: DIV
108573: ST_TO_ADDR
// if _x < 0 then
108574: LD_VAR 0 6
108578: PUSH
108579: LD_INT 0
108581: LESS
108582: IFFALSE 108599
// _x := _x * - 1 ;
108584: LD_ADDR_VAR 0 6
108588: PUSH
108589: LD_VAR 0 6
108593: PUSH
108594: LD_INT 1
108596: NEG
108597: MUL
108598: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
108599: LD_ADDR_VAR 0 7
108603: PUSH
108604: LD_VAR 0 2
108608: PUSH
108609: LD_VAR 0 4
108613: PLUS
108614: PUSH
108615: LD_INT 2
108617: DIV
108618: ST_TO_ADDR
// if _y < 0 then
108619: LD_VAR 0 7
108623: PUSH
108624: LD_INT 0
108626: LESS
108627: IFFALSE 108644
// _y := _y * - 1 ;
108629: LD_ADDR_VAR 0 7
108633: PUSH
108634: LD_VAR 0 7
108638: PUSH
108639: LD_INT 1
108641: NEG
108642: MUL
108643: ST_TO_ADDR
// result := [ _x , _y ] ;
108644: LD_ADDR_VAR 0 5
108648: PUSH
108649: LD_VAR 0 6
108653: PUSH
108654: LD_VAR 0 7
108658: PUSH
108659: EMPTY
108660: LIST
108661: LIST
108662: ST_TO_ADDR
// end ;
108663: LD_VAR 0 5
108667: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
108668: LD_INT 0
108670: PPUSH
108671: PPUSH
108672: PPUSH
108673: PPUSH
// task := GetTaskList ( unit ) ;
108674: LD_ADDR_VAR 0 7
108678: PUSH
108679: LD_VAR 0 1
108683: PPUSH
108684: CALL_OW 437
108688: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
108689: LD_VAR 0 7
108693: NOT
108694: PUSH
108695: LD_VAR 0 1
108699: PPUSH
108700: LD_VAR 0 2
108704: PPUSH
108705: CALL_OW 308
108709: NOT
108710: AND
108711: IFFALSE 108715
// exit ;
108713: GO 108833
// if IsInArea ( unit , area ) then
108715: LD_VAR 0 1
108719: PPUSH
108720: LD_VAR 0 2
108724: PPUSH
108725: CALL_OW 308
108729: IFFALSE 108747
// begin ComMoveToArea ( unit , goAway ) ;
108731: LD_VAR 0 1
108735: PPUSH
108736: LD_VAR 0 3
108740: PPUSH
108741: CALL_OW 113
// exit ;
108745: GO 108833
// end ; if task [ 1 ] [ 1 ] <> M then
108747: LD_VAR 0 7
108751: PUSH
108752: LD_INT 1
108754: ARRAY
108755: PUSH
108756: LD_INT 1
108758: ARRAY
108759: PUSH
108760: LD_STRING M
108762: NONEQUAL
108763: IFFALSE 108767
// exit ;
108765: GO 108833
// x := task [ 1 ] [ 2 ] ;
108767: LD_ADDR_VAR 0 5
108771: PUSH
108772: LD_VAR 0 7
108776: PUSH
108777: LD_INT 1
108779: ARRAY
108780: PUSH
108781: LD_INT 2
108783: ARRAY
108784: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
108785: LD_ADDR_VAR 0 6
108789: PUSH
108790: LD_VAR 0 7
108794: PUSH
108795: LD_INT 1
108797: ARRAY
108798: PUSH
108799: LD_INT 3
108801: ARRAY
108802: ST_TO_ADDR
// if InArea ( x , y , area ) then
108803: LD_VAR 0 5
108807: PPUSH
108808: LD_VAR 0 6
108812: PPUSH
108813: LD_VAR 0 2
108817: PPUSH
108818: CALL_OW 309
108822: IFFALSE 108833
// ComStop ( unit ) ;
108824: LD_VAR 0 1
108828: PPUSH
108829: CALL_OW 141
// end ;
108833: LD_VAR 0 4
108837: RET
// export function Abs ( value ) ; begin
108838: LD_INT 0
108840: PPUSH
// result := value ;
108841: LD_ADDR_VAR 0 2
108845: PUSH
108846: LD_VAR 0 1
108850: ST_TO_ADDR
// if value < 0 then
108851: LD_VAR 0 1
108855: PUSH
108856: LD_INT 0
108858: LESS
108859: IFFALSE 108876
// result := value * - 1 ;
108861: LD_ADDR_VAR 0 2
108865: PUSH
108866: LD_VAR 0 1
108870: PUSH
108871: LD_INT 1
108873: NEG
108874: MUL
108875: ST_TO_ADDR
// end ;
108876: LD_VAR 0 2
108880: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
108881: LD_INT 0
108883: PPUSH
108884: PPUSH
108885: PPUSH
108886: PPUSH
108887: PPUSH
108888: PPUSH
108889: PPUSH
108890: PPUSH
// if not unit or not building then
108891: LD_VAR 0 1
108895: NOT
108896: PUSH
108897: LD_VAR 0 2
108901: NOT
108902: OR
108903: IFFALSE 108907
// exit ;
108905: GO 109133
// x := GetX ( building ) ;
108907: LD_ADDR_VAR 0 4
108911: PUSH
108912: LD_VAR 0 2
108916: PPUSH
108917: CALL_OW 250
108921: ST_TO_ADDR
// y := GetY ( building ) ;
108922: LD_ADDR_VAR 0 6
108926: PUSH
108927: LD_VAR 0 2
108931: PPUSH
108932: CALL_OW 251
108936: ST_TO_ADDR
// d := GetDir ( building ) ;
108937: LD_ADDR_VAR 0 8
108941: PUSH
108942: LD_VAR 0 2
108946: PPUSH
108947: CALL_OW 254
108951: ST_TO_ADDR
// r := 4 ;
108952: LD_ADDR_VAR 0 9
108956: PUSH
108957: LD_INT 4
108959: ST_TO_ADDR
// for i := 1 to 5 do
108960: LD_ADDR_VAR 0 10
108964: PUSH
108965: DOUBLE
108966: LD_INT 1
108968: DEC
108969: ST_TO_ADDR
108970: LD_INT 5
108972: PUSH
108973: FOR_TO
108974: IFFALSE 109131
// begin _x := ShiftX ( x , d , r + i ) ;
108976: LD_ADDR_VAR 0 5
108980: PUSH
108981: LD_VAR 0 4
108985: PPUSH
108986: LD_VAR 0 8
108990: PPUSH
108991: LD_VAR 0 9
108995: PUSH
108996: LD_VAR 0 10
109000: PLUS
109001: PPUSH
109002: CALL_OW 272
109006: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
109007: LD_ADDR_VAR 0 7
109011: PUSH
109012: LD_VAR 0 6
109016: PPUSH
109017: LD_VAR 0 8
109021: PPUSH
109022: LD_VAR 0 9
109026: PUSH
109027: LD_VAR 0 10
109031: PLUS
109032: PPUSH
109033: CALL_OW 273
109037: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
109038: LD_VAR 0 5
109042: PPUSH
109043: LD_VAR 0 7
109047: PPUSH
109048: CALL_OW 488
109052: PUSH
109053: LD_VAR 0 5
109057: PPUSH
109058: LD_VAR 0 7
109062: PPUSH
109063: CALL_OW 428
109067: PPUSH
109068: CALL_OW 247
109072: PUSH
109073: LD_INT 3
109075: PUSH
109076: LD_INT 2
109078: PUSH
109079: EMPTY
109080: LIST
109081: LIST
109082: IN
109083: NOT
109084: AND
109085: IFFALSE 109129
// begin ComMoveXY ( unit , _x , _y ) ;
109087: LD_VAR 0 1
109091: PPUSH
109092: LD_VAR 0 5
109096: PPUSH
109097: LD_VAR 0 7
109101: PPUSH
109102: CALL_OW 111
// result := [ _x , _y ] ;
109106: LD_ADDR_VAR 0 3
109110: PUSH
109111: LD_VAR 0 5
109115: PUSH
109116: LD_VAR 0 7
109120: PUSH
109121: EMPTY
109122: LIST
109123: LIST
109124: ST_TO_ADDR
// exit ;
109125: POP
109126: POP
109127: GO 109133
// end ; end ;
109129: GO 108973
109131: POP
109132: POP
// end ;
109133: LD_VAR 0 3
109137: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
109138: LD_INT 0
109140: PPUSH
109141: PPUSH
109142: PPUSH
// result := 0 ;
109143: LD_ADDR_VAR 0 3
109147: PUSH
109148: LD_INT 0
109150: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
109151: LD_VAR 0 1
109155: PUSH
109156: LD_INT 0
109158: LESS
109159: PUSH
109160: LD_VAR 0 1
109164: PUSH
109165: LD_INT 8
109167: GREATER
109168: OR
109169: PUSH
109170: LD_VAR 0 2
109174: PUSH
109175: LD_INT 0
109177: LESS
109178: OR
109179: PUSH
109180: LD_VAR 0 2
109184: PUSH
109185: LD_INT 8
109187: GREATER
109188: OR
109189: IFFALSE 109193
// exit ;
109191: GO 109268
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
109193: LD_ADDR_VAR 0 4
109197: PUSH
109198: LD_INT 22
109200: PUSH
109201: LD_VAR 0 2
109205: PUSH
109206: EMPTY
109207: LIST
109208: LIST
109209: PPUSH
109210: CALL_OW 69
109214: PUSH
109215: FOR_IN
109216: IFFALSE 109266
// begin un := UnitShoot ( i ) ;
109218: LD_ADDR_VAR 0 5
109222: PUSH
109223: LD_VAR 0 4
109227: PPUSH
109228: CALL_OW 504
109232: ST_TO_ADDR
// if GetSide ( un ) = side1 then
109233: LD_VAR 0 5
109237: PPUSH
109238: CALL_OW 255
109242: PUSH
109243: LD_VAR 0 1
109247: EQUAL
109248: IFFALSE 109264
// begin result := un ;
109250: LD_ADDR_VAR 0 3
109254: PUSH
109255: LD_VAR 0 5
109259: ST_TO_ADDR
// exit ;
109260: POP
109261: POP
109262: GO 109268
// end ; end ;
109264: GO 109215
109266: POP
109267: POP
// end ;
109268: LD_VAR 0 3
109272: RET
// export function GetCargoBay ( units ) ; begin
109273: LD_INT 0
109275: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
109276: LD_ADDR_VAR 0 2
109280: PUSH
109281: LD_VAR 0 1
109285: PPUSH
109286: LD_INT 2
109288: PUSH
109289: LD_INT 34
109291: PUSH
109292: LD_INT 12
109294: PUSH
109295: EMPTY
109296: LIST
109297: LIST
109298: PUSH
109299: LD_INT 34
109301: PUSH
109302: LD_INT 51
109304: PUSH
109305: EMPTY
109306: LIST
109307: LIST
109308: PUSH
109309: LD_INT 34
109311: PUSH
109312: LD_INT 32
109314: PUSH
109315: EMPTY
109316: LIST
109317: LIST
109318: PUSH
109319: LD_INT 34
109321: PUSH
109322: LD_INT 89
109324: PUSH
109325: EMPTY
109326: LIST
109327: LIST
109328: PUSH
109329: EMPTY
109330: LIST
109331: LIST
109332: LIST
109333: LIST
109334: LIST
109335: PPUSH
109336: CALL_OW 72
109340: ST_TO_ADDR
// end ;
109341: LD_VAR 0 2
109345: RET
// export function Negate ( value ) ; begin
109346: LD_INT 0
109348: PPUSH
// result := not value ;
109349: LD_ADDR_VAR 0 2
109353: PUSH
109354: LD_VAR 0 1
109358: NOT
109359: ST_TO_ADDR
// end ;
109360: LD_VAR 0 2
109364: RET
// export function Inc ( value ) ; begin
109365: LD_INT 0
109367: PPUSH
// result := value + 1 ;
109368: LD_ADDR_VAR 0 2
109372: PUSH
109373: LD_VAR 0 1
109377: PUSH
109378: LD_INT 1
109380: PLUS
109381: ST_TO_ADDR
// end ;
109382: LD_VAR 0 2
109386: RET
// export function Dec ( value ) ; begin
109387: LD_INT 0
109389: PPUSH
// result := value - 1 ;
109390: LD_ADDR_VAR 0 2
109394: PUSH
109395: LD_VAR 0 1
109399: PUSH
109400: LD_INT 1
109402: MINUS
109403: ST_TO_ADDR
// end ;
109404: LD_VAR 0 2
109408: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
109409: LD_INT 0
109411: PPUSH
109412: PPUSH
109413: PPUSH
109414: PPUSH
109415: PPUSH
109416: PPUSH
109417: PPUSH
109418: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
109419: LD_VAR 0 1
109423: PPUSH
109424: LD_VAR 0 2
109428: PPUSH
109429: CALL_OW 488
109433: NOT
109434: PUSH
109435: LD_VAR 0 3
109439: PPUSH
109440: LD_VAR 0 4
109444: PPUSH
109445: CALL_OW 488
109449: NOT
109450: OR
109451: IFFALSE 109464
// begin result := - 1 ;
109453: LD_ADDR_VAR 0 5
109457: PUSH
109458: LD_INT 1
109460: NEG
109461: ST_TO_ADDR
// exit ;
109462: GO 109699
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
109464: LD_ADDR_VAR 0 12
109468: PUSH
109469: LD_VAR 0 1
109473: PPUSH
109474: LD_VAR 0 2
109478: PPUSH
109479: LD_VAR 0 3
109483: PPUSH
109484: LD_VAR 0 4
109488: PPUSH
109489: CALL 108549 0 4
109493: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
109494: LD_ADDR_VAR 0 11
109498: PUSH
109499: LD_VAR 0 1
109503: PPUSH
109504: LD_VAR 0 2
109508: PPUSH
109509: LD_VAR 0 12
109513: PUSH
109514: LD_INT 1
109516: ARRAY
109517: PPUSH
109518: LD_VAR 0 12
109522: PUSH
109523: LD_INT 2
109525: ARRAY
109526: PPUSH
109527: CALL_OW 298
109531: ST_TO_ADDR
// distance := 9999 ;
109532: LD_ADDR_VAR 0 10
109536: PUSH
109537: LD_INT 9999
109539: ST_TO_ADDR
// for i := 0 to 5 do
109540: LD_ADDR_VAR 0 6
109544: PUSH
109545: DOUBLE
109546: LD_INT 0
109548: DEC
109549: ST_TO_ADDR
109550: LD_INT 5
109552: PUSH
109553: FOR_TO
109554: IFFALSE 109697
// begin _x := ShiftX ( x1 , i , centerDist ) ;
109556: LD_ADDR_VAR 0 7
109560: PUSH
109561: LD_VAR 0 1
109565: PPUSH
109566: LD_VAR 0 6
109570: PPUSH
109571: LD_VAR 0 11
109575: PPUSH
109576: CALL_OW 272
109580: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
109581: LD_ADDR_VAR 0 8
109585: PUSH
109586: LD_VAR 0 2
109590: PPUSH
109591: LD_VAR 0 6
109595: PPUSH
109596: LD_VAR 0 11
109600: PPUSH
109601: CALL_OW 273
109605: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
109606: LD_VAR 0 7
109610: PPUSH
109611: LD_VAR 0 8
109615: PPUSH
109616: CALL_OW 488
109620: NOT
109621: IFFALSE 109625
// continue ;
109623: GO 109553
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
109625: LD_ADDR_VAR 0 9
109629: PUSH
109630: LD_VAR 0 12
109634: PUSH
109635: LD_INT 1
109637: ARRAY
109638: PPUSH
109639: LD_VAR 0 12
109643: PUSH
109644: LD_INT 2
109646: ARRAY
109647: PPUSH
109648: LD_VAR 0 7
109652: PPUSH
109653: LD_VAR 0 8
109657: PPUSH
109658: CALL_OW 298
109662: ST_TO_ADDR
// if tmp < distance then
109663: LD_VAR 0 9
109667: PUSH
109668: LD_VAR 0 10
109672: LESS
109673: IFFALSE 109695
// begin result := i ;
109675: LD_ADDR_VAR 0 5
109679: PUSH
109680: LD_VAR 0 6
109684: ST_TO_ADDR
// distance := tmp ;
109685: LD_ADDR_VAR 0 10
109689: PUSH
109690: LD_VAR 0 9
109694: ST_TO_ADDR
// end ; end ;
109695: GO 109553
109697: POP
109698: POP
// end ;
109699: LD_VAR 0 5
109703: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
109704: LD_INT 0
109706: PPUSH
109707: PPUSH
// if not driver or not IsInUnit ( driver ) then
109708: LD_VAR 0 1
109712: NOT
109713: PUSH
109714: LD_VAR 0 1
109718: PPUSH
109719: CALL_OW 310
109723: NOT
109724: OR
109725: IFFALSE 109729
// exit ;
109727: GO 109819
// vehicle := IsInUnit ( driver ) ;
109729: LD_ADDR_VAR 0 3
109733: PUSH
109734: LD_VAR 0 1
109738: PPUSH
109739: CALL_OW 310
109743: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
109744: LD_VAR 0 1
109748: PPUSH
109749: LD_STRING \
109751: PUSH
109752: LD_INT 0
109754: PUSH
109755: LD_INT 0
109757: PUSH
109758: LD_INT 0
109760: PUSH
109761: LD_INT 0
109763: PUSH
109764: LD_INT 0
109766: PUSH
109767: LD_INT 0
109769: PUSH
109770: EMPTY
109771: LIST
109772: LIST
109773: LIST
109774: LIST
109775: LIST
109776: LIST
109777: LIST
109778: PUSH
109779: LD_STRING E
109781: PUSH
109782: LD_INT 0
109784: PUSH
109785: LD_INT 0
109787: PUSH
109788: LD_VAR 0 3
109792: PUSH
109793: LD_INT 0
109795: PUSH
109796: LD_INT 0
109798: PUSH
109799: LD_INT 0
109801: PUSH
109802: EMPTY
109803: LIST
109804: LIST
109805: LIST
109806: LIST
109807: LIST
109808: LIST
109809: LIST
109810: PUSH
109811: EMPTY
109812: LIST
109813: LIST
109814: PPUSH
109815: CALL_OW 446
// end ;
109819: LD_VAR 0 2
109823: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
109824: LD_INT 0
109826: PPUSH
109827: PPUSH
// if not driver or not IsInUnit ( driver ) then
109828: LD_VAR 0 1
109832: NOT
109833: PUSH
109834: LD_VAR 0 1
109838: PPUSH
109839: CALL_OW 310
109843: NOT
109844: OR
109845: IFFALSE 109849
// exit ;
109847: GO 109939
// vehicle := IsInUnit ( driver ) ;
109849: LD_ADDR_VAR 0 3
109853: PUSH
109854: LD_VAR 0 1
109858: PPUSH
109859: CALL_OW 310
109863: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
109864: LD_VAR 0 1
109868: PPUSH
109869: LD_STRING \
109871: PUSH
109872: LD_INT 0
109874: PUSH
109875: LD_INT 0
109877: PUSH
109878: LD_INT 0
109880: PUSH
109881: LD_INT 0
109883: PUSH
109884: LD_INT 0
109886: PUSH
109887: LD_INT 0
109889: PUSH
109890: EMPTY
109891: LIST
109892: LIST
109893: LIST
109894: LIST
109895: LIST
109896: LIST
109897: LIST
109898: PUSH
109899: LD_STRING E
109901: PUSH
109902: LD_INT 0
109904: PUSH
109905: LD_INT 0
109907: PUSH
109908: LD_VAR 0 3
109912: PUSH
109913: LD_INT 0
109915: PUSH
109916: LD_INT 0
109918: PUSH
109919: LD_INT 0
109921: PUSH
109922: EMPTY
109923: LIST
109924: LIST
109925: LIST
109926: LIST
109927: LIST
109928: LIST
109929: LIST
109930: PUSH
109931: EMPTY
109932: LIST
109933: LIST
109934: PPUSH
109935: CALL_OW 447
// end ;
109939: LD_VAR 0 2
109943: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
109944: LD_INT 0
109946: PPUSH
109947: PPUSH
109948: PPUSH
// tmp := [ ] ;
109949: LD_ADDR_VAR 0 5
109953: PUSH
109954: EMPTY
109955: ST_TO_ADDR
// for i in units do
109956: LD_ADDR_VAR 0 4
109960: PUSH
109961: LD_VAR 0 1
109965: PUSH
109966: FOR_IN
109967: IFFALSE 110005
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
109969: LD_ADDR_VAR 0 5
109973: PUSH
109974: LD_VAR 0 5
109978: PPUSH
109979: LD_VAR 0 5
109983: PUSH
109984: LD_INT 1
109986: PLUS
109987: PPUSH
109988: LD_VAR 0 4
109992: PPUSH
109993: CALL_OW 256
109997: PPUSH
109998: CALL_OW 2
110002: ST_TO_ADDR
110003: GO 109966
110005: POP
110006: POP
// if not tmp then
110007: LD_VAR 0 5
110011: NOT
110012: IFFALSE 110016
// exit ;
110014: GO 110064
// if asc then
110016: LD_VAR 0 2
110020: IFFALSE 110044
// result := SortListByListAsc ( units , tmp ) else
110022: LD_ADDR_VAR 0 3
110026: PUSH
110027: LD_VAR 0 1
110031: PPUSH
110032: LD_VAR 0 5
110036: PPUSH
110037: CALL_OW 76
110041: ST_TO_ADDR
110042: GO 110064
// result := SortListByListDesc ( units , tmp ) ;
110044: LD_ADDR_VAR 0 3
110048: PUSH
110049: LD_VAR 0 1
110053: PPUSH
110054: LD_VAR 0 5
110058: PPUSH
110059: CALL_OW 77
110063: ST_TO_ADDR
// end ;
110064: LD_VAR 0 3
110068: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
110069: LD_INT 0
110071: PPUSH
110072: PPUSH
// task := GetTaskList ( mech ) ;
110073: LD_ADDR_VAR 0 4
110077: PUSH
110078: LD_VAR 0 1
110082: PPUSH
110083: CALL_OW 437
110087: ST_TO_ADDR
// if not task then
110088: LD_VAR 0 4
110092: NOT
110093: IFFALSE 110097
// exit ;
110095: GO 110139
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
110097: LD_ADDR_VAR 0 3
110101: PUSH
110102: LD_VAR 0 4
110106: PUSH
110107: LD_INT 1
110109: ARRAY
110110: PUSH
110111: LD_INT 1
110113: ARRAY
110114: PUSH
110115: LD_STRING r
110117: EQUAL
110118: PUSH
110119: LD_VAR 0 4
110123: PUSH
110124: LD_INT 1
110126: ARRAY
110127: PUSH
110128: LD_INT 4
110130: ARRAY
110131: PUSH
110132: LD_VAR 0 2
110136: EQUAL
110137: AND
110138: ST_TO_ADDR
// end ;
110139: LD_VAR 0 3
110143: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
110144: LD_INT 0
110146: PPUSH
// SetDir ( unit , d ) ;
110147: LD_VAR 0 1
110151: PPUSH
110152: LD_VAR 0 4
110156: PPUSH
110157: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
110161: LD_VAR 0 1
110165: PPUSH
110166: LD_VAR 0 2
110170: PPUSH
110171: LD_VAR 0 3
110175: PPUSH
110176: LD_VAR 0 5
110180: PPUSH
110181: CALL_OW 48
// end ;
110185: LD_VAR 0 6
110189: RET
// export function ToNaturalNumber ( number ) ; begin
110190: LD_INT 0
110192: PPUSH
// result := number div 1 ;
110193: LD_ADDR_VAR 0 2
110197: PUSH
110198: LD_VAR 0 1
110202: PUSH
110203: LD_INT 1
110205: DIV
110206: ST_TO_ADDR
// if number < 0 then
110207: LD_VAR 0 1
110211: PUSH
110212: LD_INT 0
110214: LESS
110215: IFFALSE 110225
// result := 0 ;
110217: LD_ADDR_VAR 0 2
110221: PUSH
110222: LD_INT 0
110224: ST_TO_ADDR
// end ;
110225: LD_VAR 0 2
110229: RET
// export function SortByClass ( units , class ) ; var un ; begin
110230: LD_INT 0
110232: PPUSH
110233: PPUSH
// if not units or not class then
110234: LD_VAR 0 1
110238: NOT
110239: PUSH
110240: LD_VAR 0 2
110244: NOT
110245: OR
110246: IFFALSE 110250
// exit ;
110248: GO 110345
// result := [ ] ;
110250: LD_ADDR_VAR 0 3
110254: PUSH
110255: EMPTY
110256: ST_TO_ADDR
// for un in units do
110257: LD_ADDR_VAR 0 4
110261: PUSH
110262: LD_VAR 0 1
110266: PUSH
110267: FOR_IN
110268: IFFALSE 110343
// if GetClass ( un ) = class then
110270: LD_VAR 0 4
110274: PPUSH
110275: CALL_OW 257
110279: PUSH
110280: LD_VAR 0 2
110284: EQUAL
110285: IFFALSE 110312
// result := Insert ( result , 1 , un ) else
110287: LD_ADDR_VAR 0 3
110291: PUSH
110292: LD_VAR 0 3
110296: PPUSH
110297: LD_INT 1
110299: PPUSH
110300: LD_VAR 0 4
110304: PPUSH
110305: CALL_OW 2
110309: ST_TO_ADDR
110310: GO 110341
// result := Replace ( result , result + 1 , un ) ;
110312: LD_ADDR_VAR 0 3
110316: PUSH
110317: LD_VAR 0 3
110321: PPUSH
110322: LD_VAR 0 3
110326: PUSH
110327: LD_INT 1
110329: PLUS
110330: PPUSH
110331: LD_VAR 0 4
110335: PPUSH
110336: CALL_OW 1
110340: ST_TO_ADDR
110341: GO 110267
110343: POP
110344: POP
// end ;
110345: LD_VAR 0 3
110349: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
110350: LD_INT 0
110352: PPUSH
110353: PPUSH
110354: PPUSH
110355: PPUSH
110356: PPUSH
110357: PPUSH
110358: PPUSH
// result := [ ] ;
110359: LD_ADDR_VAR 0 4
110363: PUSH
110364: EMPTY
110365: ST_TO_ADDR
// if x - r < 0 then
110366: LD_VAR 0 1
110370: PUSH
110371: LD_VAR 0 3
110375: MINUS
110376: PUSH
110377: LD_INT 0
110379: LESS
110380: IFFALSE 110392
// min_x := 0 else
110382: LD_ADDR_VAR 0 8
110386: PUSH
110387: LD_INT 0
110389: ST_TO_ADDR
110390: GO 110408
// min_x := x - r ;
110392: LD_ADDR_VAR 0 8
110396: PUSH
110397: LD_VAR 0 1
110401: PUSH
110402: LD_VAR 0 3
110406: MINUS
110407: ST_TO_ADDR
// if y - r < 0 then
110408: LD_VAR 0 2
110412: PUSH
110413: LD_VAR 0 3
110417: MINUS
110418: PUSH
110419: LD_INT 0
110421: LESS
110422: IFFALSE 110434
// min_y := 0 else
110424: LD_ADDR_VAR 0 7
110428: PUSH
110429: LD_INT 0
110431: ST_TO_ADDR
110432: GO 110450
// min_y := y - r ;
110434: LD_ADDR_VAR 0 7
110438: PUSH
110439: LD_VAR 0 2
110443: PUSH
110444: LD_VAR 0 3
110448: MINUS
110449: ST_TO_ADDR
// max_x := x + r ;
110450: LD_ADDR_VAR 0 9
110454: PUSH
110455: LD_VAR 0 1
110459: PUSH
110460: LD_VAR 0 3
110464: PLUS
110465: ST_TO_ADDR
// max_y := y + r ;
110466: LD_ADDR_VAR 0 10
110470: PUSH
110471: LD_VAR 0 2
110475: PUSH
110476: LD_VAR 0 3
110480: PLUS
110481: ST_TO_ADDR
// for _x = min_x to max_x do
110482: LD_ADDR_VAR 0 5
110486: PUSH
110487: DOUBLE
110488: LD_VAR 0 8
110492: DEC
110493: ST_TO_ADDR
110494: LD_VAR 0 9
110498: PUSH
110499: FOR_TO
110500: IFFALSE 110601
// for _y = min_y to max_y do
110502: LD_ADDR_VAR 0 6
110506: PUSH
110507: DOUBLE
110508: LD_VAR 0 7
110512: DEC
110513: ST_TO_ADDR
110514: LD_VAR 0 10
110518: PUSH
110519: FOR_TO
110520: IFFALSE 110597
// begin if not ValidHex ( _x , _y ) then
110522: LD_VAR 0 5
110526: PPUSH
110527: LD_VAR 0 6
110531: PPUSH
110532: CALL_OW 488
110536: NOT
110537: IFFALSE 110541
// continue ;
110539: GO 110519
// if GetResourceTypeXY ( _x , _y ) then
110541: LD_VAR 0 5
110545: PPUSH
110546: LD_VAR 0 6
110550: PPUSH
110551: CALL_OW 283
110555: IFFALSE 110595
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
110557: LD_ADDR_VAR 0 4
110561: PUSH
110562: LD_VAR 0 4
110566: PPUSH
110567: LD_VAR 0 4
110571: PUSH
110572: LD_INT 1
110574: PLUS
110575: PPUSH
110576: LD_VAR 0 5
110580: PUSH
110581: LD_VAR 0 6
110585: PUSH
110586: EMPTY
110587: LIST
110588: LIST
110589: PPUSH
110590: CALL_OW 1
110594: ST_TO_ADDR
// end ;
110595: GO 110519
110597: POP
110598: POP
110599: GO 110499
110601: POP
110602: POP
// end ;
110603: LD_VAR 0 4
110607: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
110608: LD_INT 0
110610: PPUSH
110611: PPUSH
110612: PPUSH
110613: PPUSH
110614: PPUSH
110615: PPUSH
110616: PPUSH
110617: PPUSH
// if not units then
110618: LD_VAR 0 1
110622: NOT
110623: IFFALSE 110627
// exit ;
110625: GO 111155
// result := UnitFilter ( units , [ f_ok ] ) ;
110627: LD_ADDR_VAR 0 3
110631: PUSH
110632: LD_VAR 0 1
110636: PPUSH
110637: LD_INT 50
110639: PUSH
110640: EMPTY
110641: LIST
110642: PPUSH
110643: CALL_OW 72
110647: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
110648: LD_ADDR_VAR 0 8
110652: PUSH
110653: LD_VAR 0 1
110657: PUSH
110658: LD_INT 1
110660: ARRAY
110661: PPUSH
110662: CALL_OW 255
110666: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
110667: LD_ADDR_VAR 0 10
110671: PUSH
110672: LD_INT 29
110674: PUSH
110675: LD_INT 91
110677: PUSH
110678: LD_INT 49
110680: PUSH
110681: EMPTY
110682: LIST
110683: LIST
110684: LIST
110685: ST_TO_ADDR
// if not result then
110686: LD_VAR 0 3
110690: NOT
110691: IFFALSE 110695
// exit ;
110693: GO 111155
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
110695: LD_ADDR_VAR 0 5
110699: PUSH
110700: LD_INT 81
110702: PUSH
110703: LD_VAR 0 8
110707: PUSH
110708: EMPTY
110709: LIST
110710: LIST
110711: PPUSH
110712: CALL_OW 69
110716: ST_TO_ADDR
// for i in result do
110717: LD_ADDR_VAR 0 4
110721: PUSH
110722: LD_VAR 0 3
110726: PUSH
110727: FOR_IN
110728: IFFALSE 111153
// begin tag := GetTag ( i ) + 1 ;
110730: LD_ADDR_VAR 0 9
110734: PUSH
110735: LD_VAR 0 4
110739: PPUSH
110740: CALL_OW 110
110744: PUSH
110745: LD_INT 1
110747: PLUS
110748: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
110749: LD_ADDR_VAR 0 7
110753: PUSH
110754: LD_VAR 0 4
110758: PPUSH
110759: CALL_OW 250
110763: PPUSH
110764: LD_VAR 0 4
110768: PPUSH
110769: CALL_OW 251
110773: PPUSH
110774: LD_INT 4
110776: PPUSH
110777: CALL 110350 0 3
110781: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
110782: LD_VAR 0 4
110786: PPUSH
110787: CALL_OW 247
110791: PUSH
110792: LD_INT 2
110794: EQUAL
110795: PUSH
110796: LD_VAR 0 7
110800: PUSH
110801: LD_INT 2
110803: GREATER
110804: AND
110805: PUSH
110806: LD_VAR 0 4
110810: PPUSH
110811: CALL_OW 264
110815: PUSH
110816: LD_VAR 0 10
110820: IN
110821: NOT
110822: AND
110823: IFFALSE 110862
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
110825: LD_VAR 0 4
110829: PPUSH
110830: LD_VAR 0 7
110834: PUSH
110835: LD_INT 1
110837: ARRAY
110838: PUSH
110839: LD_INT 1
110841: ARRAY
110842: PPUSH
110843: LD_VAR 0 7
110847: PUSH
110848: LD_INT 1
110850: ARRAY
110851: PUSH
110852: LD_INT 2
110854: ARRAY
110855: PPUSH
110856: CALL_OW 116
110860: GO 111151
// if path > tag then
110862: LD_VAR 0 2
110866: PUSH
110867: LD_VAR 0 9
110871: GREATER
110872: IFFALSE 111080
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
110874: LD_ADDR_VAR 0 6
110878: PUSH
110879: LD_VAR 0 5
110883: PPUSH
110884: LD_INT 91
110886: PUSH
110887: LD_VAR 0 4
110891: PUSH
110892: LD_INT 8
110894: PUSH
110895: EMPTY
110896: LIST
110897: LIST
110898: LIST
110899: PPUSH
110900: CALL_OW 72
110904: ST_TO_ADDR
// if nearEnemy then
110905: LD_VAR 0 6
110909: IFFALSE 110978
// begin if GetWeapon ( i ) = ru_time_lapser then
110911: LD_VAR 0 4
110915: PPUSH
110916: CALL_OW 264
110920: PUSH
110921: LD_INT 49
110923: EQUAL
110924: IFFALSE 110952
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
110926: LD_VAR 0 4
110930: PPUSH
110931: LD_VAR 0 6
110935: PPUSH
110936: LD_VAR 0 4
110940: PPUSH
110941: CALL_OW 74
110945: PPUSH
110946: CALL_OW 112
110950: GO 110976
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
110952: LD_VAR 0 4
110956: PPUSH
110957: LD_VAR 0 6
110961: PPUSH
110962: LD_VAR 0 4
110966: PPUSH
110967: CALL_OW 74
110971: PPUSH
110972: CALL 112226 0 2
// end else
110976: GO 111078
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
110978: LD_VAR 0 4
110982: PPUSH
110983: LD_VAR 0 2
110987: PUSH
110988: LD_VAR 0 9
110992: ARRAY
110993: PUSH
110994: LD_INT 1
110996: ARRAY
110997: PPUSH
110998: LD_VAR 0 2
111002: PUSH
111003: LD_VAR 0 9
111007: ARRAY
111008: PUSH
111009: LD_INT 2
111011: ARRAY
111012: PPUSH
111013: CALL_OW 297
111017: PUSH
111018: LD_INT 6
111020: GREATER
111021: IFFALSE 111064
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
111023: LD_VAR 0 4
111027: PPUSH
111028: LD_VAR 0 2
111032: PUSH
111033: LD_VAR 0 9
111037: ARRAY
111038: PUSH
111039: LD_INT 1
111041: ARRAY
111042: PPUSH
111043: LD_VAR 0 2
111047: PUSH
111048: LD_VAR 0 9
111052: ARRAY
111053: PUSH
111054: LD_INT 2
111056: ARRAY
111057: PPUSH
111058: CALL_OW 114
111062: GO 111078
// SetTag ( i , tag ) ;
111064: LD_VAR 0 4
111068: PPUSH
111069: LD_VAR 0 9
111073: PPUSH
111074: CALL_OW 109
// end else
111078: GO 111151
// if enemy then
111080: LD_VAR 0 5
111084: IFFALSE 111151
// begin if GetWeapon ( i ) = ru_time_lapser then
111086: LD_VAR 0 4
111090: PPUSH
111091: CALL_OW 264
111095: PUSH
111096: LD_INT 49
111098: EQUAL
111099: IFFALSE 111127
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
111101: LD_VAR 0 4
111105: PPUSH
111106: LD_VAR 0 5
111110: PPUSH
111111: LD_VAR 0 4
111115: PPUSH
111116: CALL_OW 74
111120: PPUSH
111121: CALL_OW 112
111125: GO 111151
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
111127: LD_VAR 0 4
111131: PPUSH
111132: LD_VAR 0 5
111136: PPUSH
111137: LD_VAR 0 4
111141: PPUSH
111142: CALL_OW 74
111146: PPUSH
111147: CALL 112226 0 2
// end ; end ;
111151: GO 110727
111153: POP
111154: POP
// end ;
111155: LD_VAR 0 3
111159: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
111160: LD_INT 0
111162: PPUSH
111163: PPUSH
111164: PPUSH
// if not unit or IsInUnit ( unit ) then
111165: LD_VAR 0 1
111169: NOT
111170: PUSH
111171: LD_VAR 0 1
111175: PPUSH
111176: CALL_OW 310
111180: OR
111181: IFFALSE 111185
// exit ;
111183: GO 111276
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
111185: LD_ADDR_VAR 0 4
111189: PUSH
111190: LD_VAR 0 1
111194: PPUSH
111195: CALL_OW 250
111199: PPUSH
111200: LD_VAR 0 2
111204: PPUSH
111205: LD_INT 1
111207: PPUSH
111208: CALL_OW 272
111212: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
111213: LD_ADDR_VAR 0 5
111217: PUSH
111218: LD_VAR 0 1
111222: PPUSH
111223: CALL_OW 251
111227: PPUSH
111228: LD_VAR 0 2
111232: PPUSH
111233: LD_INT 1
111235: PPUSH
111236: CALL_OW 273
111240: ST_TO_ADDR
// if ValidHex ( x , y ) then
111241: LD_VAR 0 4
111245: PPUSH
111246: LD_VAR 0 5
111250: PPUSH
111251: CALL_OW 488
111255: IFFALSE 111276
// ComTurnXY ( unit , x , y ) ;
111257: LD_VAR 0 1
111261: PPUSH
111262: LD_VAR 0 4
111266: PPUSH
111267: LD_VAR 0 5
111271: PPUSH
111272: CALL_OW 118
// end ;
111276: LD_VAR 0 3
111280: RET
// export function SeeUnits ( side , units ) ; var i ; begin
111281: LD_INT 0
111283: PPUSH
111284: PPUSH
// result := false ;
111285: LD_ADDR_VAR 0 3
111289: PUSH
111290: LD_INT 0
111292: ST_TO_ADDR
// if not units then
111293: LD_VAR 0 2
111297: NOT
111298: IFFALSE 111302
// exit ;
111300: GO 111347
// for i in units do
111302: LD_ADDR_VAR 0 4
111306: PUSH
111307: LD_VAR 0 2
111311: PUSH
111312: FOR_IN
111313: IFFALSE 111345
// if See ( side , i ) then
111315: LD_VAR 0 1
111319: PPUSH
111320: LD_VAR 0 4
111324: PPUSH
111325: CALL_OW 292
111329: IFFALSE 111343
// begin result := true ;
111331: LD_ADDR_VAR 0 3
111335: PUSH
111336: LD_INT 1
111338: ST_TO_ADDR
// exit ;
111339: POP
111340: POP
111341: GO 111347
// end ;
111343: GO 111312
111345: POP
111346: POP
// end ;
111347: LD_VAR 0 3
111351: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
111352: LD_INT 0
111354: PPUSH
111355: PPUSH
111356: PPUSH
111357: PPUSH
// if not unit or not points then
111358: LD_VAR 0 1
111362: NOT
111363: PUSH
111364: LD_VAR 0 2
111368: NOT
111369: OR
111370: IFFALSE 111374
// exit ;
111372: GO 111464
// dist := 99999 ;
111374: LD_ADDR_VAR 0 5
111378: PUSH
111379: LD_INT 99999
111381: ST_TO_ADDR
// for i in points do
111382: LD_ADDR_VAR 0 4
111386: PUSH
111387: LD_VAR 0 2
111391: PUSH
111392: FOR_IN
111393: IFFALSE 111462
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
111395: LD_ADDR_VAR 0 6
111399: PUSH
111400: LD_VAR 0 1
111404: PPUSH
111405: LD_VAR 0 4
111409: PUSH
111410: LD_INT 1
111412: ARRAY
111413: PPUSH
111414: LD_VAR 0 4
111418: PUSH
111419: LD_INT 2
111421: ARRAY
111422: PPUSH
111423: CALL_OW 297
111427: ST_TO_ADDR
// if tmpDist < dist then
111428: LD_VAR 0 6
111432: PUSH
111433: LD_VAR 0 5
111437: LESS
111438: IFFALSE 111460
// begin result := i ;
111440: LD_ADDR_VAR 0 3
111444: PUSH
111445: LD_VAR 0 4
111449: ST_TO_ADDR
// dist := tmpDist ;
111450: LD_ADDR_VAR 0 5
111454: PUSH
111455: LD_VAR 0 6
111459: ST_TO_ADDR
// end ; end ;
111460: GO 111392
111462: POP
111463: POP
// end ;
111464: LD_VAR 0 3
111468: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
111469: LD_INT 0
111471: PPUSH
// uc_side := side ;
111472: LD_ADDR_OWVAR 20
111476: PUSH
111477: LD_VAR 0 1
111481: ST_TO_ADDR
// uc_nation := 3 ;
111482: LD_ADDR_OWVAR 21
111486: PUSH
111487: LD_INT 3
111489: ST_TO_ADDR
// vc_chassis := 25 ;
111490: LD_ADDR_OWVAR 37
111494: PUSH
111495: LD_INT 25
111497: ST_TO_ADDR
// vc_engine := engine_siberite ;
111498: LD_ADDR_OWVAR 39
111502: PUSH
111503: LD_INT 3
111505: ST_TO_ADDR
// vc_control := control_computer ;
111506: LD_ADDR_OWVAR 38
111510: PUSH
111511: LD_INT 3
111513: ST_TO_ADDR
// vc_weapon := 59 ;
111514: LD_ADDR_OWVAR 40
111518: PUSH
111519: LD_INT 59
111521: ST_TO_ADDR
// result := CreateVehicle ;
111522: LD_ADDR_VAR 0 5
111526: PUSH
111527: CALL_OW 45
111531: ST_TO_ADDR
// SetDir ( result , d ) ;
111532: LD_VAR 0 5
111536: PPUSH
111537: LD_VAR 0 4
111541: PPUSH
111542: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
111546: LD_VAR 0 5
111550: PPUSH
111551: LD_VAR 0 2
111555: PPUSH
111556: LD_VAR 0 3
111560: PPUSH
111561: LD_INT 0
111563: PPUSH
111564: CALL_OW 48
// end ;
111568: LD_VAR 0 5
111572: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
111573: LD_INT 0
111575: PPUSH
111576: PPUSH
111577: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
111578: LD_ADDR_VAR 0 2
111582: PUSH
111583: LD_INT 0
111585: PUSH
111586: LD_INT 0
111588: PUSH
111589: LD_INT 0
111591: PUSH
111592: LD_INT 0
111594: PUSH
111595: EMPTY
111596: LIST
111597: LIST
111598: LIST
111599: LIST
111600: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
111601: LD_VAR 0 1
111605: NOT
111606: PUSH
111607: LD_VAR 0 1
111611: PPUSH
111612: CALL_OW 264
111616: PUSH
111617: LD_INT 12
111619: PUSH
111620: LD_INT 51
111622: PUSH
111623: LD_INT 32
111625: PUSH
111626: LD_INT 89
111628: PUSH
111629: EMPTY
111630: LIST
111631: LIST
111632: LIST
111633: LIST
111634: IN
111635: NOT
111636: OR
111637: IFFALSE 111641
// exit ;
111639: GO 111739
// for i := 1 to 3 do
111641: LD_ADDR_VAR 0 3
111645: PUSH
111646: DOUBLE
111647: LD_INT 1
111649: DEC
111650: ST_TO_ADDR
111651: LD_INT 3
111653: PUSH
111654: FOR_TO
111655: IFFALSE 111737
// begin tmp := GetCargo ( cargo , i ) ;
111657: LD_ADDR_VAR 0 4
111661: PUSH
111662: LD_VAR 0 1
111666: PPUSH
111667: LD_VAR 0 3
111671: PPUSH
111672: CALL_OW 289
111676: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
111677: LD_ADDR_VAR 0 2
111681: PUSH
111682: LD_VAR 0 2
111686: PPUSH
111687: LD_VAR 0 3
111691: PPUSH
111692: LD_VAR 0 4
111696: PPUSH
111697: CALL_OW 1
111701: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
111702: LD_ADDR_VAR 0 2
111706: PUSH
111707: LD_VAR 0 2
111711: PPUSH
111712: LD_INT 4
111714: PPUSH
111715: LD_VAR 0 2
111719: PUSH
111720: LD_INT 4
111722: ARRAY
111723: PUSH
111724: LD_VAR 0 4
111728: PLUS
111729: PPUSH
111730: CALL_OW 1
111734: ST_TO_ADDR
// end ;
111735: GO 111654
111737: POP
111738: POP
// end ;
111739: LD_VAR 0 2
111743: RET
// export function Length ( array ) ; begin
111744: LD_INT 0
111746: PPUSH
// result := array + 0 ;
111747: LD_ADDR_VAR 0 2
111751: PUSH
111752: LD_VAR 0 1
111756: PUSH
111757: LD_INT 0
111759: PLUS
111760: ST_TO_ADDR
// end ;
111761: LD_VAR 0 2
111765: RET
// export function PrepareArray ( array ) ; begin
111766: LD_INT 0
111768: PPUSH
// result := array diff 0 ;
111769: LD_ADDR_VAR 0 2
111773: PUSH
111774: LD_VAR 0 1
111778: PUSH
111779: LD_INT 0
111781: DIFF
111782: ST_TO_ADDR
// if not result [ 1 ] then
111783: LD_VAR 0 2
111787: PUSH
111788: LD_INT 1
111790: ARRAY
111791: NOT
111792: IFFALSE 111812
// result := Delete ( result , 1 ) ;
111794: LD_ADDR_VAR 0 2
111798: PUSH
111799: LD_VAR 0 2
111803: PPUSH
111804: LD_INT 1
111806: PPUSH
111807: CALL_OW 3
111811: ST_TO_ADDR
// end ;
111812: LD_VAR 0 2
111816: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
111817: LD_INT 0
111819: PPUSH
111820: PPUSH
111821: PPUSH
111822: PPUSH
// sibRocketRange := 25 ;
111823: LD_ADDR_VAR 0 6
111827: PUSH
111828: LD_INT 25
111830: ST_TO_ADDR
// result := false ;
111831: LD_ADDR_VAR 0 4
111835: PUSH
111836: LD_INT 0
111838: ST_TO_ADDR
// for i := 0 to 5 do
111839: LD_ADDR_VAR 0 5
111843: PUSH
111844: DOUBLE
111845: LD_INT 0
111847: DEC
111848: ST_TO_ADDR
111849: LD_INT 5
111851: PUSH
111852: FOR_TO
111853: IFFALSE 111920
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
111855: LD_VAR 0 1
111859: PPUSH
111860: LD_VAR 0 5
111864: PPUSH
111865: LD_VAR 0 6
111869: PPUSH
111870: CALL_OW 272
111874: PPUSH
111875: LD_VAR 0 2
111879: PPUSH
111880: LD_VAR 0 5
111884: PPUSH
111885: LD_VAR 0 6
111889: PPUSH
111890: CALL_OW 273
111894: PPUSH
111895: LD_VAR 0 3
111899: PPUSH
111900: CALL_OW 309
111904: IFFALSE 111918
// begin result := true ;
111906: LD_ADDR_VAR 0 4
111910: PUSH
111911: LD_INT 1
111913: ST_TO_ADDR
// exit ;
111914: POP
111915: POP
111916: GO 111922
// end ;
111918: GO 111852
111920: POP
111921: POP
// end ;
111922: LD_VAR 0 4
111926: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
111927: LD_INT 0
111929: PPUSH
111930: PPUSH
111931: PPUSH
// if btype = b_depot then
111932: LD_VAR 0 2
111936: PUSH
111937: LD_INT 0
111939: EQUAL
111940: IFFALSE 111952
// begin result := true ;
111942: LD_ADDR_VAR 0 3
111946: PUSH
111947: LD_INT 1
111949: ST_TO_ADDR
// exit ;
111950: GO 112068
// end ; pom := GetBase ( depot ) ;
111952: LD_ADDR_VAR 0 4
111956: PUSH
111957: LD_VAR 0 1
111961: PPUSH
111962: CALL_OW 274
111966: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
111967: LD_ADDR_VAR 0 5
111971: PUSH
111972: LD_VAR 0 2
111976: PPUSH
111977: LD_VAR 0 1
111981: PPUSH
111982: CALL_OW 248
111986: PPUSH
111987: CALL_OW 450
111991: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
111992: LD_ADDR_VAR 0 3
111996: PUSH
111997: LD_VAR 0 4
112001: PPUSH
112002: LD_INT 1
112004: PPUSH
112005: CALL_OW 275
112009: PUSH
112010: LD_VAR 0 5
112014: PUSH
112015: LD_INT 1
112017: ARRAY
112018: GREATEREQUAL
112019: PUSH
112020: LD_VAR 0 4
112024: PPUSH
112025: LD_INT 2
112027: PPUSH
112028: CALL_OW 275
112032: PUSH
112033: LD_VAR 0 5
112037: PUSH
112038: LD_INT 2
112040: ARRAY
112041: GREATEREQUAL
112042: AND
112043: PUSH
112044: LD_VAR 0 4
112048: PPUSH
112049: LD_INT 3
112051: PPUSH
112052: CALL_OW 275
112056: PUSH
112057: LD_VAR 0 5
112061: PUSH
112062: LD_INT 3
112064: ARRAY
112065: GREATEREQUAL
112066: AND
112067: ST_TO_ADDR
// end ;
112068: LD_VAR 0 3
112072: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
112073: LD_INT 0
112075: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
112076: LD_VAR 0 1
112080: PPUSH
112081: LD_VAR 0 2
112085: PPUSH
112086: LD_INT 0
112088: PPUSH
112089: LD_INT 0
112091: PPUSH
112092: LD_INT 1
112094: PPUSH
112095: LD_INT 0
112097: PPUSH
112098: CALL_OW 587
// end ;
112102: LD_VAR 0 3
112106: RET
// export function CenterOnNow ( unit ) ; begin
112107: LD_INT 0
112109: PPUSH
// result := IsInUnit ( unit ) ;
112110: LD_ADDR_VAR 0 2
112114: PUSH
112115: LD_VAR 0 1
112119: PPUSH
112120: CALL_OW 310
112124: ST_TO_ADDR
// if not result then
112125: LD_VAR 0 2
112129: NOT
112130: IFFALSE 112142
// result := unit ;
112132: LD_ADDR_VAR 0 2
112136: PUSH
112137: LD_VAR 0 1
112141: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
112142: LD_VAR 0 1
112146: PPUSH
112147: CALL_OW 87
// end ;
112151: LD_VAR 0 2
112155: RET
// export function ComMoveHex ( unit , hex ) ; begin
112156: LD_INT 0
112158: PPUSH
// if not hex then
112159: LD_VAR 0 2
112163: NOT
112164: IFFALSE 112168
// exit ;
112166: GO 112221
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
112168: LD_VAR 0 2
112172: PUSH
112173: LD_INT 1
112175: ARRAY
112176: PPUSH
112177: LD_VAR 0 2
112181: PUSH
112182: LD_INT 2
112184: ARRAY
112185: PPUSH
112186: CALL_OW 428
112190: IFFALSE 112194
// exit ;
112192: GO 112221
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
112194: LD_VAR 0 1
112198: PPUSH
112199: LD_VAR 0 2
112203: PUSH
112204: LD_INT 1
112206: ARRAY
112207: PPUSH
112208: LD_VAR 0 2
112212: PUSH
112213: LD_INT 2
112215: ARRAY
112216: PPUSH
112217: CALL_OW 111
// end ;
112221: LD_VAR 0 3
112225: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
112226: LD_INT 0
112228: PPUSH
112229: PPUSH
112230: PPUSH
// if not unit or not enemy then
112231: LD_VAR 0 1
112235: NOT
112236: PUSH
112237: LD_VAR 0 2
112241: NOT
112242: OR
112243: IFFALSE 112247
// exit ;
112245: GO 112371
// x := GetX ( enemy ) ;
112247: LD_ADDR_VAR 0 4
112251: PUSH
112252: LD_VAR 0 2
112256: PPUSH
112257: CALL_OW 250
112261: ST_TO_ADDR
// y := GetY ( enemy ) ;
112262: LD_ADDR_VAR 0 5
112266: PUSH
112267: LD_VAR 0 2
112271: PPUSH
112272: CALL_OW 251
112276: ST_TO_ADDR
// if ValidHex ( x , y ) then
112277: LD_VAR 0 4
112281: PPUSH
112282: LD_VAR 0 5
112286: PPUSH
112287: CALL_OW 488
112291: IFFALSE 112371
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
112293: LD_VAR 0 2
112297: PPUSH
112298: CALL_OW 247
112302: PUSH
112303: LD_INT 3
112305: PUSH
112306: LD_INT 2
112308: PUSH
112309: EMPTY
112310: LIST
112311: LIST
112312: IN
112313: PUSH
112314: LD_VAR 0 1
112318: PPUSH
112319: CALL_OW 255
112323: PPUSH
112324: LD_VAR 0 2
112328: PPUSH
112329: CALL_OW 292
112333: OR
112334: IFFALSE 112352
// ComAttackUnit ( unit , enemy ) else
112336: LD_VAR 0 1
112340: PPUSH
112341: LD_VAR 0 2
112345: PPUSH
112346: CALL_OW 115
112350: GO 112371
// ComAgressiveMove ( unit , x , y ) ;
112352: LD_VAR 0 1
112356: PPUSH
112357: LD_VAR 0 4
112361: PPUSH
112362: LD_VAR 0 5
112366: PPUSH
112367: CALL_OW 114
// end ;
112371: LD_VAR 0 3
112375: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
112376: LD_INT 0
112378: PPUSH
112379: PPUSH
112380: PPUSH
// list := AreaToList ( area , 0 ) ;
112381: LD_ADDR_VAR 0 5
112385: PUSH
112386: LD_VAR 0 1
112390: PPUSH
112391: LD_INT 0
112393: PPUSH
112394: CALL_OW 517
112398: ST_TO_ADDR
// if not list then
112399: LD_VAR 0 5
112403: NOT
112404: IFFALSE 112408
// exit ;
112406: GO 112538
// if all then
112408: LD_VAR 0 2
112412: IFFALSE 112500
// begin for i := 1 to list [ 1 ] do
112414: LD_ADDR_VAR 0 4
112418: PUSH
112419: DOUBLE
112420: LD_INT 1
112422: DEC
112423: ST_TO_ADDR
112424: LD_VAR 0 5
112428: PUSH
112429: LD_INT 1
112431: ARRAY
112432: PUSH
112433: FOR_TO
112434: IFFALSE 112496
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
112436: LD_ADDR_VAR 0 3
112440: PUSH
112441: LD_VAR 0 3
112445: PPUSH
112446: LD_VAR 0 3
112450: PUSH
112451: LD_INT 1
112453: PLUS
112454: PPUSH
112455: LD_VAR 0 5
112459: PUSH
112460: LD_INT 1
112462: ARRAY
112463: PUSH
112464: LD_VAR 0 4
112468: ARRAY
112469: PUSH
112470: LD_VAR 0 5
112474: PUSH
112475: LD_INT 2
112477: ARRAY
112478: PUSH
112479: LD_VAR 0 4
112483: ARRAY
112484: PUSH
112485: EMPTY
112486: LIST
112487: LIST
112488: PPUSH
112489: CALL_OW 1
112493: ST_TO_ADDR
112494: GO 112433
112496: POP
112497: POP
// exit ;
112498: GO 112538
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
112500: LD_ADDR_VAR 0 3
112504: PUSH
112505: LD_VAR 0 5
112509: PUSH
112510: LD_INT 1
112512: ARRAY
112513: PUSH
112514: LD_INT 1
112516: ARRAY
112517: PUSH
112518: LD_VAR 0 5
112522: PUSH
112523: LD_INT 2
112525: ARRAY
112526: PUSH
112527: LD_INT 1
112529: ARRAY
112530: PUSH
112531: EMPTY
112532: LIST
112533: LIST
112534: PUSH
112535: EMPTY
112536: LIST
112537: ST_TO_ADDR
// end ;
112538: LD_VAR 0 3
112542: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
112543: LD_INT 0
112545: PPUSH
112546: PPUSH
// list := AreaToList ( area , 0 ) ;
112547: LD_ADDR_VAR 0 4
112551: PUSH
112552: LD_VAR 0 1
112556: PPUSH
112557: LD_INT 0
112559: PPUSH
112560: CALL_OW 517
112564: ST_TO_ADDR
// if not list then
112565: LD_VAR 0 4
112569: NOT
112570: IFFALSE 112574
// exit ;
112572: GO 112615
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
112574: LD_ADDR_VAR 0 3
112578: PUSH
112579: LD_VAR 0 4
112583: PUSH
112584: LD_INT 1
112586: ARRAY
112587: PUSH
112588: LD_INT 1
112590: ARRAY
112591: PUSH
112592: LD_VAR 0 4
112596: PUSH
112597: LD_INT 2
112599: ARRAY
112600: PUSH
112601: LD_INT 1
112603: ARRAY
112604: PUSH
112605: LD_VAR 0 2
112609: PUSH
112610: EMPTY
112611: LIST
112612: LIST
112613: LIST
112614: ST_TO_ADDR
// end ;
112615: LD_VAR 0 3
112619: RET
// export function First ( array ) ; begin
112620: LD_INT 0
112622: PPUSH
// if not array then
112623: LD_VAR 0 1
112627: NOT
112628: IFFALSE 112632
// exit ;
112630: GO 112646
// result := array [ 1 ] ;
112632: LD_ADDR_VAR 0 2
112636: PUSH
112637: LD_VAR 0 1
112641: PUSH
112642: LD_INT 1
112644: ARRAY
112645: ST_TO_ADDR
// end ;
112646: LD_VAR 0 2
112650: RET
// export function Last ( array ) ; begin
112651: LD_INT 0
112653: PPUSH
// if not array then
112654: LD_VAR 0 1
112658: NOT
112659: IFFALSE 112663
// exit ;
112661: GO 112679
// result := array [ array ] ;
112663: LD_ADDR_VAR 0 2
112667: PUSH
112668: LD_VAR 0 1
112672: PUSH
112673: LD_VAR 0 1
112677: ARRAY
112678: ST_TO_ADDR
// end ;
112679: LD_VAR 0 2
112683: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
112684: LD_INT 0
112686: PPUSH
112687: PPUSH
// result := [ ] ;
112688: LD_ADDR_VAR 0 5
112692: PUSH
112693: EMPTY
112694: ST_TO_ADDR
// if not array then
112695: LD_VAR 0 1
112699: NOT
112700: IFFALSE 112704
// exit ;
112702: GO 112816
// for i := 1 to array do
112704: LD_ADDR_VAR 0 6
112708: PUSH
112709: DOUBLE
112710: LD_INT 1
112712: DEC
112713: ST_TO_ADDR
112714: LD_VAR 0 1
112718: PUSH
112719: FOR_TO
112720: IFFALSE 112814
// if array [ i ] [ index ] = value then
112722: LD_VAR 0 1
112726: PUSH
112727: LD_VAR 0 6
112731: ARRAY
112732: PUSH
112733: LD_VAR 0 2
112737: ARRAY
112738: PUSH
112739: LD_VAR 0 3
112743: EQUAL
112744: IFFALSE 112812
// begin if indexColumn then
112746: LD_VAR 0 4
112750: IFFALSE 112786
// result := Join ( result , array [ i ] [ indexColumn ] ) else
112752: LD_ADDR_VAR 0 5
112756: PUSH
112757: LD_VAR 0 5
112761: PPUSH
112762: LD_VAR 0 1
112766: PUSH
112767: LD_VAR 0 6
112771: ARRAY
112772: PUSH
112773: LD_VAR 0 4
112777: ARRAY
112778: PPUSH
112779: CALL 108004 0 2
112783: ST_TO_ADDR
112784: GO 112812
// result := Join ( result , array [ i ] ) ;
112786: LD_ADDR_VAR 0 5
112790: PUSH
112791: LD_VAR 0 5
112795: PPUSH
112796: LD_VAR 0 1
112800: PUSH
112801: LD_VAR 0 6
112805: ARRAY
112806: PPUSH
112807: CALL 108004 0 2
112811: ST_TO_ADDR
// end ;
112812: GO 112719
112814: POP
112815: POP
// end ;
112816: LD_VAR 0 5
112820: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
112821: LD_INT 0
112823: PPUSH
// if not vehicles or not parkingPoint then
112824: LD_VAR 0 1
112828: NOT
112829: PUSH
112830: LD_VAR 0 2
112834: NOT
112835: OR
112836: IFFALSE 112840
// exit ;
112838: GO 112938
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
112840: LD_ADDR_VAR 0 1
112844: PUSH
112845: LD_VAR 0 1
112849: PPUSH
112850: LD_INT 50
112852: PUSH
112853: EMPTY
112854: LIST
112855: PUSH
112856: LD_INT 3
112858: PUSH
112859: LD_INT 92
112861: PUSH
112862: LD_VAR 0 2
112866: PUSH
112867: LD_INT 1
112869: ARRAY
112870: PUSH
112871: LD_VAR 0 2
112875: PUSH
112876: LD_INT 2
112878: ARRAY
112879: PUSH
112880: LD_INT 8
112882: PUSH
112883: EMPTY
112884: LIST
112885: LIST
112886: LIST
112887: LIST
112888: PUSH
112889: EMPTY
112890: LIST
112891: LIST
112892: PUSH
112893: EMPTY
112894: LIST
112895: LIST
112896: PPUSH
112897: CALL_OW 72
112901: ST_TO_ADDR
// if not vehicles then
112902: LD_VAR 0 1
112906: NOT
112907: IFFALSE 112911
// exit ;
112909: GO 112938
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
112911: LD_VAR 0 1
112915: PPUSH
112916: LD_VAR 0 2
112920: PUSH
112921: LD_INT 1
112923: ARRAY
112924: PPUSH
112925: LD_VAR 0 2
112929: PUSH
112930: LD_INT 2
112932: ARRAY
112933: PPUSH
112934: CALL_OW 111
// end ;
112938: LD_VAR 0 3
112942: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
112943: LD_INT 0
112945: PPUSH
112946: PPUSH
112947: PPUSH
// if not side or not area then
112948: LD_VAR 0 1
112952: NOT
112953: PUSH
112954: LD_VAR 0 2
112958: NOT
112959: OR
112960: IFFALSE 112964
// exit ;
112962: GO 113083
// tmp := AreaToList ( area , 0 ) ;
112964: LD_ADDR_VAR 0 5
112968: PUSH
112969: LD_VAR 0 2
112973: PPUSH
112974: LD_INT 0
112976: PPUSH
112977: CALL_OW 517
112981: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
112982: LD_ADDR_VAR 0 4
112986: PUSH
112987: DOUBLE
112988: LD_INT 1
112990: DEC
112991: ST_TO_ADDR
112992: LD_VAR 0 5
112996: PUSH
112997: LD_INT 1
112999: ARRAY
113000: PUSH
113001: FOR_TO
113002: IFFALSE 113081
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
113004: LD_VAR 0 5
113008: PUSH
113009: LD_INT 1
113011: ARRAY
113012: PUSH
113013: LD_VAR 0 4
113017: ARRAY
113018: PPUSH
113019: LD_VAR 0 5
113023: PUSH
113024: LD_INT 2
113026: ARRAY
113027: PUSH
113028: LD_VAR 0 4
113032: ARRAY
113033: PPUSH
113034: CALL_OW 351
113038: IFFALSE 113079
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
113040: LD_VAR 0 5
113044: PUSH
113045: LD_INT 1
113047: ARRAY
113048: PUSH
113049: LD_VAR 0 4
113053: ARRAY
113054: PPUSH
113055: LD_VAR 0 5
113059: PUSH
113060: LD_INT 2
113062: ARRAY
113063: PUSH
113064: LD_VAR 0 4
113068: ARRAY
113069: PPUSH
113070: LD_VAR 0 1
113074: PPUSH
113075: CALL_OW 244
// end ;
113079: GO 113001
113081: POP
113082: POP
// end ; end_of_file end_of_file
113083: LD_VAR 0 3
113087: RET
// export globalGameSaveCounter ; every 0 0$1 do
113088: GO 113090
113090: DISABLE
// begin enable ;
113091: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
113092: LD_STRING updateTimer(
113094: PUSH
113095: LD_OWVAR 1
113099: STR
113100: PUSH
113101: LD_STRING );
113103: STR
113104: PPUSH
113105: CALL_OW 559
// end ;
113109: END
// every 0 0$1 do
113110: GO 113112
113112: DISABLE
// begin globalGameSaveCounter := 0 ;
113113: LD_ADDR_EXP 147
113117: PUSH
113118: LD_INT 0
113120: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
113121: LD_STRING setGameSaveCounter(0)
113123: PPUSH
113124: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
113128: LD_STRING initStreamRollete();
113130: PPUSH
113131: CALL_OW 559
// InitStreamMode ;
113135: CALL 114478 0 0
// DefineStreamItems ( false ) ;
113139: LD_INT 0
113141: PPUSH
113142: CALL 114942 0 1
// end ;
113146: END
// export function SOS_MapStart ( ) ; begin
113147: LD_INT 0
113149: PPUSH
// if streamModeActive then
113150: LD_EXP 148
113154: IFFALSE 113163
// DefineStreamItems ( true ) ;
113156: LD_INT 1
113158: PPUSH
113159: CALL 114942 0 1
// UpdateLuaVariables ( ) ;
113163: CALL 113180 0 0
// UpdateFactoryWaypoints ( ) ;
113167: CALL 127944 0 0
// UpdateWarehouseGatheringPoints ( ) ;
113171: CALL 128196 0 0
// end ;
113175: LD_VAR 0 1
113179: RET
// function UpdateLuaVariables ( ) ; begin
113180: LD_INT 0
113182: PPUSH
// if globalGameSaveCounter then
113183: LD_EXP 147
113187: IFFALSE 113221
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
113189: LD_ADDR_EXP 147
113193: PUSH
113194: LD_EXP 147
113198: PPUSH
113199: CALL 109365 0 1
113203: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
113204: LD_STRING setGameSaveCounter(
113206: PUSH
113207: LD_EXP 147
113211: STR
113212: PUSH
113213: LD_STRING )
113215: STR
113216: PPUSH
113217: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
113221: LD_STRING setGameDifficulty(
113223: PUSH
113224: LD_OWVAR 67
113228: STR
113229: PUSH
113230: LD_STRING )
113232: STR
113233: PPUSH
113234: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
113238: LD_STRING displayDifficulty(
113240: PUSH
113241: LD_OWVAR 67
113245: STR
113246: PUSH
113247: LD_STRING )
113249: STR
113250: PPUSH
113251: CALL_OW 559
// end ;
113255: LD_VAR 0 1
113259: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
113260: LD_INT 0
113262: PPUSH
// if p2 = stream_mode then
113263: LD_VAR 0 2
113267: PUSH
113268: LD_INT 100
113270: EQUAL
113271: IFFALSE 114274
// begin if not StreamModeActive then
113273: LD_EXP 148
113277: NOT
113278: IFFALSE 113288
// StreamModeActive := true ;
113280: LD_ADDR_EXP 148
113284: PUSH
113285: LD_INT 1
113287: ST_TO_ADDR
// if p3 = 0 then
113288: LD_VAR 0 3
113292: PUSH
113293: LD_INT 0
113295: EQUAL
113296: IFFALSE 113302
// InitStreamMode ;
113298: CALL 114478 0 0
// if p3 = 1 then
113302: LD_VAR 0 3
113306: PUSH
113307: LD_INT 1
113309: EQUAL
113310: IFFALSE 113320
// sRocket := true ;
113312: LD_ADDR_EXP 153
113316: PUSH
113317: LD_INT 1
113319: ST_TO_ADDR
// if p3 = 2 then
113320: LD_VAR 0 3
113324: PUSH
113325: LD_INT 2
113327: EQUAL
113328: IFFALSE 113338
// sSpeed := true ;
113330: LD_ADDR_EXP 152
113334: PUSH
113335: LD_INT 1
113337: ST_TO_ADDR
// if p3 = 3 then
113338: LD_VAR 0 3
113342: PUSH
113343: LD_INT 3
113345: EQUAL
113346: IFFALSE 113356
// sEngine := true ;
113348: LD_ADDR_EXP 154
113352: PUSH
113353: LD_INT 1
113355: ST_TO_ADDR
// if p3 = 4 then
113356: LD_VAR 0 3
113360: PUSH
113361: LD_INT 4
113363: EQUAL
113364: IFFALSE 113374
// sSpec := true ;
113366: LD_ADDR_EXP 151
113370: PUSH
113371: LD_INT 1
113373: ST_TO_ADDR
// if p3 = 5 then
113374: LD_VAR 0 3
113378: PUSH
113379: LD_INT 5
113381: EQUAL
113382: IFFALSE 113392
// sLevel := true ;
113384: LD_ADDR_EXP 155
113388: PUSH
113389: LD_INT 1
113391: ST_TO_ADDR
// if p3 = 6 then
113392: LD_VAR 0 3
113396: PUSH
113397: LD_INT 6
113399: EQUAL
113400: IFFALSE 113410
// sArmoury := true ;
113402: LD_ADDR_EXP 156
113406: PUSH
113407: LD_INT 1
113409: ST_TO_ADDR
// if p3 = 7 then
113410: LD_VAR 0 3
113414: PUSH
113415: LD_INT 7
113417: EQUAL
113418: IFFALSE 113428
// sRadar := true ;
113420: LD_ADDR_EXP 157
113424: PUSH
113425: LD_INT 1
113427: ST_TO_ADDR
// if p3 = 8 then
113428: LD_VAR 0 3
113432: PUSH
113433: LD_INT 8
113435: EQUAL
113436: IFFALSE 113446
// sBunker := true ;
113438: LD_ADDR_EXP 158
113442: PUSH
113443: LD_INT 1
113445: ST_TO_ADDR
// if p3 = 9 then
113446: LD_VAR 0 3
113450: PUSH
113451: LD_INT 9
113453: EQUAL
113454: IFFALSE 113464
// sHack := true ;
113456: LD_ADDR_EXP 159
113460: PUSH
113461: LD_INT 1
113463: ST_TO_ADDR
// if p3 = 10 then
113464: LD_VAR 0 3
113468: PUSH
113469: LD_INT 10
113471: EQUAL
113472: IFFALSE 113482
// sFire := true ;
113474: LD_ADDR_EXP 160
113478: PUSH
113479: LD_INT 1
113481: ST_TO_ADDR
// if p3 = 11 then
113482: LD_VAR 0 3
113486: PUSH
113487: LD_INT 11
113489: EQUAL
113490: IFFALSE 113500
// sRefresh := true ;
113492: LD_ADDR_EXP 161
113496: PUSH
113497: LD_INT 1
113499: ST_TO_ADDR
// if p3 = 12 then
113500: LD_VAR 0 3
113504: PUSH
113505: LD_INT 12
113507: EQUAL
113508: IFFALSE 113518
// sExp := true ;
113510: LD_ADDR_EXP 162
113514: PUSH
113515: LD_INT 1
113517: ST_TO_ADDR
// if p3 = 13 then
113518: LD_VAR 0 3
113522: PUSH
113523: LD_INT 13
113525: EQUAL
113526: IFFALSE 113536
// sDepot := true ;
113528: LD_ADDR_EXP 163
113532: PUSH
113533: LD_INT 1
113535: ST_TO_ADDR
// if p3 = 14 then
113536: LD_VAR 0 3
113540: PUSH
113541: LD_INT 14
113543: EQUAL
113544: IFFALSE 113554
// sFlag := true ;
113546: LD_ADDR_EXP 164
113550: PUSH
113551: LD_INT 1
113553: ST_TO_ADDR
// if p3 = 15 then
113554: LD_VAR 0 3
113558: PUSH
113559: LD_INT 15
113561: EQUAL
113562: IFFALSE 113572
// sKamikadze := true ;
113564: LD_ADDR_EXP 172
113568: PUSH
113569: LD_INT 1
113571: ST_TO_ADDR
// if p3 = 16 then
113572: LD_VAR 0 3
113576: PUSH
113577: LD_INT 16
113579: EQUAL
113580: IFFALSE 113590
// sTroll := true ;
113582: LD_ADDR_EXP 173
113586: PUSH
113587: LD_INT 1
113589: ST_TO_ADDR
// if p3 = 17 then
113590: LD_VAR 0 3
113594: PUSH
113595: LD_INT 17
113597: EQUAL
113598: IFFALSE 113608
// sSlow := true ;
113600: LD_ADDR_EXP 174
113604: PUSH
113605: LD_INT 1
113607: ST_TO_ADDR
// if p3 = 18 then
113608: LD_VAR 0 3
113612: PUSH
113613: LD_INT 18
113615: EQUAL
113616: IFFALSE 113626
// sLack := true ;
113618: LD_ADDR_EXP 175
113622: PUSH
113623: LD_INT 1
113625: ST_TO_ADDR
// if p3 = 19 then
113626: LD_VAR 0 3
113630: PUSH
113631: LD_INT 19
113633: EQUAL
113634: IFFALSE 113644
// sTank := true ;
113636: LD_ADDR_EXP 177
113640: PUSH
113641: LD_INT 1
113643: ST_TO_ADDR
// if p3 = 20 then
113644: LD_VAR 0 3
113648: PUSH
113649: LD_INT 20
113651: EQUAL
113652: IFFALSE 113662
// sRemote := true ;
113654: LD_ADDR_EXP 178
113658: PUSH
113659: LD_INT 1
113661: ST_TO_ADDR
// if p3 = 21 then
113662: LD_VAR 0 3
113666: PUSH
113667: LD_INT 21
113669: EQUAL
113670: IFFALSE 113680
// sPowell := true ;
113672: LD_ADDR_EXP 179
113676: PUSH
113677: LD_INT 1
113679: ST_TO_ADDR
// if p3 = 22 then
113680: LD_VAR 0 3
113684: PUSH
113685: LD_INT 22
113687: EQUAL
113688: IFFALSE 113698
// sTeleport := true ;
113690: LD_ADDR_EXP 182
113694: PUSH
113695: LD_INT 1
113697: ST_TO_ADDR
// if p3 = 23 then
113698: LD_VAR 0 3
113702: PUSH
113703: LD_INT 23
113705: EQUAL
113706: IFFALSE 113716
// sOilTower := true ;
113708: LD_ADDR_EXP 184
113712: PUSH
113713: LD_INT 1
113715: ST_TO_ADDR
// if p3 = 24 then
113716: LD_VAR 0 3
113720: PUSH
113721: LD_INT 24
113723: EQUAL
113724: IFFALSE 113734
// sShovel := true ;
113726: LD_ADDR_EXP 185
113730: PUSH
113731: LD_INT 1
113733: ST_TO_ADDR
// if p3 = 25 then
113734: LD_VAR 0 3
113738: PUSH
113739: LD_INT 25
113741: EQUAL
113742: IFFALSE 113752
// sSheik := true ;
113744: LD_ADDR_EXP 186
113748: PUSH
113749: LD_INT 1
113751: ST_TO_ADDR
// if p3 = 26 then
113752: LD_VAR 0 3
113756: PUSH
113757: LD_INT 26
113759: EQUAL
113760: IFFALSE 113770
// sEarthquake := true ;
113762: LD_ADDR_EXP 188
113766: PUSH
113767: LD_INT 1
113769: ST_TO_ADDR
// if p3 = 27 then
113770: LD_VAR 0 3
113774: PUSH
113775: LD_INT 27
113777: EQUAL
113778: IFFALSE 113788
// sAI := true ;
113780: LD_ADDR_EXP 189
113784: PUSH
113785: LD_INT 1
113787: ST_TO_ADDR
// if p3 = 28 then
113788: LD_VAR 0 3
113792: PUSH
113793: LD_INT 28
113795: EQUAL
113796: IFFALSE 113806
// sCargo := true ;
113798: LD_ADDR_EXP 192
113802: PUSH
113803: LD_INT 1
113805: ST_TO_ADDR
// if p3 = 29 then
113806: LD_VAR 0 3
113810: PUSH
113811: LD_INT 29
113813: EQUAL
113814: IFFALSE 113824
// sDLaser := true ;
113816: LD_ADDR_EXP 193
113820: PUSH
113821: LD_INT 1
113823: ST_TO_ADDR
// if p3 = 30 then
113824: LD_VAR 0 3
113828: PUSH
113829: LD_INT 30
113831: EQUAL
113832: IFFALSE 113842
// sExchange := true ;
113834: LD_ADDR_EXP 194
113838: PUSH
113839: LD_INT 1
113841: ST_TO_ADDR
// if p3 = 31 then
113842: LD_VAR 0 3
113846: PUSH
113847: LD_INT 31
113849: EQUAL
113850: IFFALSE 113860
// sFac := true ;
113852: LD_ADDR_EXP 195
113856: PUSH
113857: LD_INT 1
113859: ST_TO_ADDR
// if p3 = 32 then
113860: LD_VAR 0 3
113864: PUSH
113865: LD_INT 32
113867: EQUAL
113868: IFFALSE 113878
// sPower := true ;
113870: LD_ADDR_EXP 196
113874: PUSH
113875: LD_INT 1
113877: ST_TO_ADDR
// if p3 = 33 then
113878: LD_VAR 0 3
113882: PUSH
113883: LD_INT 33
113885: EQUAL
113886: IFFALSE 113896
// sRandom := true ;
113888: LD_ADDR_EXP 197
113892: PUSH
113893: LD_INT 1
113895: ST_TO_ADDR
// if p3 = 34 then
113896: LD_VAR 0 3
113900: PUSH
113901: LD_INT 34
113903: EQUAL
113904: IFFALSE 113914
// sShield := true ;
113906: LD_ADDR_EXP 198
113910: PUSH
113911: LD_INT 1
113913: ST_TO_ADDR
// if p3 = 35 then
113914: LD_VAR 0 3
113918: PUSH
113919: LD_INT 35
113921: EQUAL
113922: IFFALSE 113932
// sTime := true ;
113924: LD_ADDR_EXP 199
113928: PUSH
113929: LD_INT 1
113931: ST_TO_ADDR
// if p3 = 36 then
113932: LD_VAR 0 3
113936: PUSH
113937: LD_INT 36
113939: EQUAL
113940: IFFALSE 113950
// sTools := true ;
113942: LD_ADDR_EXP 200
113946: PUSH
113947: LD_INT 1
113949: ST_TO_ADDR
// if p3 = 101 then
113950: LD_VAR 0 3
113954: PUSH
113955: LD_INT 101
113957: EQUAL
113958: IFFALSE 113968
// sSold := true ;
113960: LD_ADDR_EXP 165
113964: PUSH
113965: LD_INT 1
113967: ST_TO_ADDR
// if p3 = 102 then
113968: LD_VAR 0 3
113972: PUSH
113973: LD_INT 102
113975: EQUAL
113976: IFFALSE 113986
// sDiff := true ;
113978: LD_ADDR_EXP 166
113982: PUSH
113983: LD_INT 1
113985: ST_TO_ADDR
// if p3 = 103 then
113986: LD_VAR 0 3
113990: PUSH
113991: LD_INT 103
113993: EQUAL
113994: IFFALSE 114004
// sFog := true ;
113996: LD_ADDR_EXP 169
114000: PUSH
114001: LD_INT 1
114003: ST_TO_ADDR
// if p3 = 104 then
114004: LD_VAR 0 3
114008: PUSH
114009: LD_INT 104
114011: EQUAL
114012: IFFALSE 114022
// sReset := true ;
114014: LD_ADDR_EXP 170
114018: PUSH
114019: LD_INT 1
114021: ST_TO_ADDR
// if p3 = 105 then
114022: LD_VAR 0 3
114026: PUSH
114027: LD_INT 105
114029: EQUAL
114030: IFFALSE 114040
// sSun := true ;
114032: LD_ADDR_EXP 171
114036: PUSH
114037: LD_INT 1
114039: ST_TO_ADDR
// if p3 = 106 then
114040: LD_VAR 0 3
114044: PUSH
114045: LD_INT 106
114047: EQUAL
114048: IFFALSE 114058
// sTiger := true ;
114050: LD_ADDR_EXP 167
114054: PUSH
114055: LD_INT 1
114057: ST_TO_ADDR
// if p3 = 107 then
114058: LD_VAR 0 3
114062: PUSH
114063: LD_INT 107
114065: EQUAL
114066: IFFALSE 114076
// sBomb := true ;
114068: LD_ADDR_EXP 168
114072: PUSH
114073: LD_INT 1
114075: ST_TO_ADDR
// if p3 = 108 then
114076: LD_VAR 0 3
114080: PUSH
114081: LD_INT 108
114083: EQUAL
114084: IFFALSE 114094
// sWound := true ;
114086: LD_ADDR_EXP 176
114090: PUSH
114091: LD_INT 1
114093: ST_TO_ADDR
// if p3 = 109 then
114094: LD_VAR 0 3
114098: PUSH
114099: LD_INT 109
114101: EQUAL
114102: IFFALSE 114112
// sBetray := true ;
114104: LD_ADDR_EXP 180
114108: PUSH
114109: LD_INT 1
114111: ST_TO_ADDR
// if p3 = 110 then
114112: LD_VAR 0 3
114116: PUSH
114117: LD_INT 110
114119: EQUAL
114120: IFFALSE 114130
// sContamin := true ;
114122: LD_ADDR_EXP 181
114126: PUSH
114127: LD_INT 1
114129: ST_TO_ADDR
// if p3 = 111 then
114130: LD_VAR 0 3
114134: PUSH
114135: LD_INT 111
114137: EQUAL
114138: IFFALSE 114148
// sOil := true ;
114140: LD_ADDR_EXP 183
114144: PUSH
114145: LD_INT 1
114147: ST_TO_ADDR
// if p3 = 112 then
114148: LD_VAR 0 3
114152: PUSH
114153: LD_INT 112
114155: EQUAL
114156: IFFALSE 114166
// sStu := true ;
114158: LD_ADDR_EXP 187
114162: PUSH
114163: LD_INT 1
114165: ST_TO_ADDR
// if p3 = 113 then
114166: LD_VAR 0 3
114170: PUSH
114171: LD_INT 113
114173: EQUAL
114174: IFFALSE 114184
// sBazooka := true ;
114176: LD_ADDR_EXP 190
114180: PUSH
114181: LD_INT 1
114183: ST_TO_ADDR
// if p3 = 114 then
114184: LD_VAR 0 3
114188: PUSH
114189: LD_INT 114
114191: EQUAL
114192: IFFALSE 114202
// sMortar := true ;
114194: LD_ADDR_EXP 191
114198: PUSH
114199: LD_INT 1
114201: ST_TO_ADDR
// if p3 = 115 then
114202: LD_VAR 0 3
114206: PUSH
114207: LD_INT 115
114209: EQUAL
114210: IFFALSE 114220
// sRanger := true ;
114212: LD_ADDR_EXP 201
114216: PUSH
114217: LD_INT 1
114219: ST_TO_ADDR
// if p3 = 116 then
114220: LD_VAR 0 3
114224: PUSH
114225: LD_INT 116
114227: EQUAL
114228: IFFALSE 114238
// sComputer := true ;
114230: LD_ADDR_EXP 202
114234: PUSH
114235: LD_INT 1
114237: ST_TO_ADDR
// if p3 = 117 then
114238: LD_VAR 0 3
114242: PUSH
114243: LD_INT 117
114245: EQUAL
114246: IFFALSE 114256
// s30 := true ;
114248: LD_ADDR_EXP 203
114252: PUSH
114253: LD_INT 1
114255: ST_TO_ADDR
// if p3 = 118 then
114256: LD_VAR 0 3
114260: PUSH
114261: LD_INT 118
114263: EQUAL
114264: IFFALSE 114274
// s60 := true ;
114266: LD_ADDR_EXP 204
114270: PUSH
114271: LD_INT 1
114273: ST_TO_ADDR
// end ; if p2 = hack_mode then
114274: LD_VAR 0 2
114278: PUSH
114279: LD_INT 101
114281: EQUAL
114282: IFFALSE 114410
// begin case p3 of 1 :
114284: LD_VAR 0 3
114288: PUSH
114289: LD_INT 1
114291: DOUBLE
114292: EQUAL
114293: IFTRUE 114297
114295: GO 114304
114297: POP
// hHackUnlimitedResources ; 2 :
114298: CALL 126557 0 0
114302: GO 114410
114304: LD_INT 2
114306: DOUBLE
114307: EQUAL
114308: IFTRUE 114312
114310: GO 114319
114312: POP
// hHackSetLevel10 ; 3 :
114313: CALL 126690 0 0
114317: GO 114410
114319: LD_INT 3
114321: DOUBLE
114322: EQUAL
114323: IFTRUE 114327
114325: GO 114334
114327: POP
// hHackSetLevel10YourUnits ; 4 :
114328: CALL 126775 0 0
114332: GO 114410
114334: LD_INT 4
114336: DOUBLE
114337: EQUAL
114338: IFTRUE 114342
114340: GO 114349
114342: POP
// hHackInvincible ; 5 :
114343: CALL 127223 0 0
114347: GO 114410
114349: LD_INT 5
114351: DOUBLE
114352: EQUAL
114353: IFTRUE 114357
114355: GO 114364
114357: POP
// hHackInvisible ; 6 :
114358: CALL 127334 0 0
114362: GO 114410
114364: LD_INT 6
114366: DOUBLE
114367: EQUAL
114368: IFTRUE 114372
114370: GO 114379
114372: POP
// hHackChangeYourSide ; 7 :
114373: CALL 127391 0 0
114377: GO 114410
114379: LD_INT 7
114381: DOUBLE
114382: EQUAL
114383: IFTRUE 114387
114385: GO 114394
114387: POP
// hHackChangeUnitSide ; 8 :
114388: CALL 127433 0 0
114392: GO 114410
114394: LD_INT 8
114396: DOUBLE
114397: EQUAL
114398: IFTRUE 114402
114400: GO 114409
114402: POP
// hHackFog ; end ;
114403: CALL 127534 0 0
114407: GO 114410
114409: POP
// end ; if p2 = game_save_mode then
114410: LD_VAR 0 2
114414: PUSH
114415: LD_INT 102
114417: EQUAL
114418: IFFALSE 114473
// begin if p3 = 1 then
114420: LD_VAR 0 3
114424: PUSH
114425: LD_INT 1
114427: EQUAL
114428: IFFALSE 114440
// globalGameSaveCounter := p4 ;
114430: LD_ADDR_EXP 147
114434: PUSH
114435: LD_VAR 0 4
114439: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
114440: LD_VAR 0 3
114444: PUSH
114445: LD_INT 2
114447: EQUAL
114448: PUSH
114449: LD_EXP 147
114453: AND
114454: IFFALSE 114473
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
114456: LD_STRING setGameSaveCounter(
114458: PUSH
114459: LD_EXP 147
114463: STR
114464: PUSH
114465: LD_STRING )
114467: STR
114468: PPUSH
114469: CALL_OW 559
// end ; end ;
114473: LD_VAR 0 7
114477: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
114478: LD_INT 0
114480: PPUSH
// streamModeActive := false ;
114481: LD_ADDR_EXP 148
114485: PUSH
114486: LD_INT 0
114488: ST_TO_ADDR
// normalCounter := 36 ;
114489: LD_ADDR_EXP 149
114493: PUSH
114494: LD_INT 36
114496: ST_TO_ADDR
// hardcoreCounter := 18 ;
114497: LD_ADDR_EXP 150
114501: PUSH
114502: LD_INT 18
114504: ST_TO_ADDR
// sRocket := false ;
114505: LD_ADDR_EXP 153
114509: PUSH
114510: LD_INT 0
114512: ST_TO_ADDR
// sSpeed := false ;
114513: LD_ADDR_EXP 152
114517: PUSH
114518: LD_INT 0
114520: ST_TO_ADDR
// sEngine := false ;
114521: LD_ADDR_EXP 154
114525: PUSH
114526: LD_INT 0
114528: ST_TO_ADDR
// sSpec := false ;
114529: LD_ADDR_EXP 151
114533: PUSH
114534: LD_INT 0
114536: ST_TO_ADDR
// sLevel := false ;
114537: LD_ADDR_EXP 155
114541: PUSH
114542: LD_INT 0
114544: ST_TO_ADDR
// sArmoury := false ;
114545: LD_ADDR_EXP 156
114549: PUSH
114550: LD_INT 0
114552: ST_TO_ADDR
// sRadar := false ;
114553: LD_ADDR_EXP 157
114557: PUSH
114558: LD_INT 0
114560: ST_TO_ADDR
// sBunker := false ;
114561: LD_ADDR_EXP 158
114565: PUSH
114566: LD_INT 0
114568: ST_TO_ADDR
// sHack := false ;
114569: LD_ADDR_EXP 159
114573: PUSH
114574: LD_INT 0
114576: ST_TO_ADDR
// sFire := false ;
114577: LD_ADDR_EXP 160
114581: PUSH
114582: LD_INT 0
114584: ST_TO_ADDR
// sRefresh := false ;
114585: LD_ADDR_EXP 161
114589: PUSH
114590: LD_INT 0
114592: ST_TO_ADDR
// sExp := false ;
114593: LD_ADDR_EXP 162
114597: PUSH
114598: LD_INT 0
114600: ST_TO_ADDR
// sDepot := false ;
114601: LD_ADDR_EXP 163
114605: PUSH
114606: LD_INT 0
114608: ST_TO_ADDR
// sFlag := false ;
114609: LD_ADDR_EXP 164
114613: PUSH
114614: LD_INT 0
114616: ST_TO_ADDR
// sKamikadze := false ;
114617: LD_ADDR_EXP 172
114621: PUSH
114622: LD_INT 0
114624: ST_TO_ADDR
// sTroll := false ;
114625: LD_ADDR_EXP 173
114629: PUSH
114630: LD_INT 0
114632: ST_TO_ADDR
// sSlow := false ;
114633: LD_ADDR_EXP 174
114637: PUSH
114638: LD_INT 0
114640: ST_TO_ADDR
// sLack := false ;
114641: LD_ADDR_EXP 175
114645: PUSH
114646: LD_INT 0
114648: ST_TO_ADDR
// sTank := false ;
114649: LD_ADDR_EXP 177
114653: PUSH
114654: LD_INT 0
114656: ST_TO_ADDR
// sRemote := false ;
114657: LD_ADDR_EXP 178
114661: PUSH
114662: LD_INT 0
114664: ST_TO_ADDR
// sPowell := false ;
114665: LD_ADDR_EXP 179
114669: PUSH
114670: LD_INT 0
114672: ST_TO_ADDR
// sTeleport := false ;
114673: LD_ADDR_EXP 182
114677: PUSH
114678: LD_INT 0
114680: ST_TO_ADDR
// sOilTower := false ;
114681: LD_ADDR_EXP 184
114685: PUSH
114686: LD_INT 0
114688: ST_TO_ADDR
// sShovel := false ;
114689: LD_ADDR_EXP 185
114693: PUSH
114694: LD_INT 0
114696: ST_TO_ADDR
// sSheik := false ;
114697: LD_ADDR_EXP 186
114701: PUSH
114702: LD_INT 0
114704: ST_TO_ADDR
// sEarthquake := false ;
114705: LD_ADDR_EXP 188
114709: PUSH
114710: LD_INT 0
114712: ST_TO_ADDR
// sAI := false ;
114713: LD_ADDR_EXP 189
114717: PUSH
114718: LD_INT 0
114720: ST_TO_ADDR
// sCargo := false ;
114721: LD_ADDR_EXP 192
114725: PUSH
114726: LD_INT 0
114728: ST_TO_ADDR
// sDLaser := false ;
114729: LD_ADDR_EXP 193
114733: PUSH
114734: LD_INT 0
114736: ST_TO_ADDR
// sExchange := false ;
114737: LD_ADDR_EXP 194
114741: PUSH
114742: LD_INT 0
114744: ST_TO_ADDR
// sFac := false ;
114745: LD_ADDR_EXP 195
114749: PUSH
114750: LD_INT 0
114752: ST_TO_ADDR
// sPower := false ;
114753: LD_ADDR_EXP 196
114757: PUSH
114758: LD_INT 0
114760: ST_TO_ADDR
// sRandom := false ;
114761: LD_ADDR_EXP 197
114765: PUSH
114766: LD_INT 0
114768: ST_TO_ADDR
// sShield := false ;
114769: LD_ADDR_EXP 198
114773: PUSH
114774: LD_INT 0
114776: ST_TO_ADDR
// sTime := false ;
114777: LD_ADDR_EXP 199
114781: PUSH
114782: LD_INT 0
114784: ST_TO_ADDR
// sTools := false ;
114785: LD_ADDR_EXP 200
114789: PUSH
114790: LD_INT 0
114792: ST_TO_ADDR
// sSold := false ;
114793: LD_ADDR_EXP 165
114797: PUSH
114798: LD_INT 0
114800: ST_TO_ADDR
// sDiff := false ;
114801: LD_ADDR_EXP 166
114805: PUSH
114806: LD_INT 0
114808: ST_TO_ADDR
// sFog := false ;
114809: LD_ADDR_EXP 169
114813: PUSH
114814: LD_INT 0
114816: ST_TO_ADDR
// sReset := false ;
114817: LD_ADDR_EXP 170
114821: PUSH
114822: LD_INT 0
114824: ST_TO_ADDR
// sSun := false ;
114825: LD_ADDR_EXP 171
114829: PUSH
114830: LD_INT 0
114832: ST_TO_ADDR
// sTiger := false ;
114833: LD_ADDR_EXP 167
114837: PUSH
114838: LD_INT 0
114840: ST_TO_ADDR
// sBomb := false ;
114841: LD_ADDR_EXP 168
114845: PUSH
114846: LD_INT 0
114848: ST_TO_ADDR
// sWound := false ;
114849: LD_ADDR_EXP 176
114853: PUSH
114854: LD_INT 0
114856: ST_TO_ADDR
// sBetray := false ;
114857: LD_ADDR_EXP 180
114861: PUSH
114862: LD_INT 0
114864: ST_TO_ADDR
// sContamin := false ;
114865: LD_ADDR_EXP 181
114869: PUSH
114870: LD_INT 0
114872: ST_TO_ADDR
// sOil := false ;
114873: LD_ADDR_EXP 183
114877: PUSH
114878: LD_INT 0
114880: ST_TO_ADDR
// sStu := false ;
114881: LD_ADDR_EXP 187
114885: PUSH
114886: LD_INT 0
114888: ST_TO_ADDR
// sBazooka := false ;
114889: LD_ADDR_EXP 190
114893: PUSH
114894: LD_INT 0
114896: ST_TO_ADDR
// sMortar := false ;
114897: LD_ADDR_EXP 191
114901: PUSH
114902: LD_INT 0
114904: ST_TO_ADDR
// sRanger := false ;
114905: LD_ADDR_EXP 201
114909: PUSH
114910: LD_INT 0
114912: ST_TO_ADDR
// sComputer := false ;
114913: LD_ADDR_EXP 202
114917: PUSH
114918: LD_INT 0
114920: ST_TO_ADDR
// s30 := false ;
114921: LD_ADDR_EXP 203
114925: PUSH
114926: LD_INT 0
114928: ST_TO_ADDR
// s60 := false ;
114929: LD_ADDR_EXP 204
114933: PUSH
114934: LD_INT 0
114936: ST_TO_ADDR
// end ;
114937: LD_VAR 0 1
114941: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
114942: LD_INT 0
114944: PPUSH
114945: PPUSH
114946: PPUSH
114947: PPUSH
114948: PPUSH
114949: PPUSH
114950: PPUSH
// result := [ ] ;
114951: LD_ADDR_VAR 0 2
114955: PUSH
114956: EMPTY
114957: ST_TO_ADDR
// if campaign_id = 1 then
114958: LD_OWVAR 69
114962: PUSH
114963: LD_INT 1
114965: EQUAL
114966: IFFALSE 118132
// begin case mission_number of 1 :
114968: LD_OWVAR 70
114972: PUSH
114973: LD_INT 1
114975: DOUBLE
114976: EQUAL
114977: IFTRUE 114981
114979: GO 115057
114981: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
114982: LD_ADDR_VAR 0 2
114986: PUSH
114987: LD_INT 2
114989: PUSH
114990: LD_INT 4
114992: PUSH
114993: LD_INT 11
114995: PUSH
114996: LD_INT 12
114998: PUSH
114999: LD_INT 15
115001: PUSH
115002: LD_INT 16
115004: PUSH
115005: LD_INT 22
115007: PUSH
115008: LD_INT 23
115010: PUSH
115011: LD_INT 26
115013: PUSH
115014: EMPTY
115015: LIST
115016: LIST
115017: LIST
115018: LIST
115019: LIST
115020: LIST
115021: LIST
115022: LIST
115023: LIST
115024: PUSH
115025: LD_INT 101
115027: PUSH
115028: LD_INT 102
115030: PUSH
115031: LD_INT 106
115033: PUSH
115034: LD_INT 116
115036: PUSH
115037: LD_INT 117
115039: PUSH
115040: LD_INT 118
115042: PUSH
115043: EMPTY
115044: LIST
115045: LIST
115046: LIST
115047: LIST
115048: LIST
115049: LIST
115050: PUSH
115051: EMPTY
115052: LIST
115053: LIST
115054: ST_TO_ADDR
115055: GO 118130
115057: LD_INT 2
115059: DOUBLE
115060: EQUAL
115061: IFTRUE 115065
115063: GO 115149
115065: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
115066: LD_ADDR_VAR 0 2
115070: PUSH
115071: LD_INT 2
115073: PUSH
115074: LD_INT 4
115076: PUSH
115077: LD_INT 11
115079: PUSH
115080: LD_INT 12
115082: PUSH
115083: LD_INT 15
115085: PUSH
115086: LD_INT 16
115088: PUSH
115089: LD_INT 22
115091: PUSH
115092: LD_INT 23
115094: PUSH
115095: LD_INT 26
115097: PUSH
115098: EMPTY
115099: LIST
115100: LIST
115101: LIST
115102: LIST
115103: LIST
115104: LIST
115105: LIST
115106: LIST
115107: LIST
115108: PUSH
115109: LD_INT 101
115111: PUSH
115112: LD_INT 102
115114: PUSH
115115: LD_INT 105
115117: PUSH
115118: LD_INT 106
115120: PUSH
115121: LD_INT 108
115123: PUSH
115124: LD_INT 116
115126: PUSH
115127: LD_INT 117
115129: PUSH
115130: LD_INT 118
115132: PUSH
115133: EMPTY
115134: LIST
115135: LIST
115136: LIST
115137: LIST
115138: LIST
115139: LIST
115140: LIST
115141: LIST
115142: PUSH
115143: EMPTY
115144: LIST
115145: LIST
115146: ST_TO_ADDR
115147: GO 118130
115149: LD_INT 3
115151: DOUBLE
115152: EQUAL
115153: IFTRUE 115157
115155: GO 115245
115157: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
115158: LD_ADDR_VAR 0 2
115162: PUSH
115163: LD_INT 2
115165: PUSH
115166: LD_INT 4
115168: PUSH
115169: LD_INT 5
115171: PUSH
115172: LD_INT 11
115174: PUSH
115175: LD_INT 12
115177: PUSH
115178: LD_INT 15
115180: PUSH
115181: LD_INT 16
115183: PUSH
115184: LD_INT 22
115186: PUSH
115187: LD_INT 26
115189: PUSH
115190: LD_INT 36
115192: PUSH
115193: EMPTY
115194: LIST
115195: LIST
115196: LIST
115197: LIST
115198: LIST
115199: LIST
115200: LIST
115201: LIST
115202: LIST
115203: LIST
115204: PUSH
115205: LD_INT 101
115207: PUSH
115208: LD_INT 102
115210: PUSH
115211: LD_INT 105
115213: PUSH
115214: LD_INT 106
115216: PUSH
115217: LD_INT 108
115219: PUSH
115220: LD_INT 116
115222: PUSH
115223: LD_INT 117
115225: PUSH
115226: LD_INT 118
115228: PUSH
115229: EMPTY
115230: LIST
115231: LIST
115232: LIST
115233: LIST
115234: LIST
115235: LIST
115236: LIST
115237: LIST
115238: PUSH
115239: EMPTY
115240: LIST
115241: LIST
115242: ST_TO_ADDR
115243: GO 118130
115245: LD_INT 4
115247: DOUBLE
115248: EQUAL
115249: IFTRUE 115253
115251: GO 115349
115253: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
115254: LD_ADDR_VAR 0 2
115258: PUSH
115259: LD_INT 2
115261: PUSH
115262: LD_INT 4
115264: PUSH
115265: LD_INT 5
115267: PUSH
115268: LD_INT 8
115270: PUSH
115271: LD_INT 11
115273: PUSH
115274: LD_INT 12
115276: PUSH
115277: LD_INT 15
115279: PUSH
115280: LD_INT 16
115282: PUSH
115283: LD_INT 22
115285: PUSH
115286: LD_INT 23
115288: PUSH
115289: LD_INT 26
115291: PUSH
115292: LD_INT 36
115294: PUSH
115295: EMPTY
115296: LIST
115297: LIST
115298: LIST
115299: LIST
115300: LIST
115301: LIST
115302: LIST
115303: LIST
115304: LIST
115305: LIST
115306: LIST
115307: LIST
115308: PUSH
115309: LD_INT 101
115311: PUSH
115312: LD_INT 102
115314: PUSH
115315: LD_INT 105
115317: PUSH
115318: LD_INT 106
115320: PUSH
115321: LD_INT 108
115323: PUSH
115324: LD_INT 116
115326: PUSH
115327: LD_INT 117
115329: PUSH
115330: LD_INT 118
115332: PUSH
115333: EMPTY
115334: LIST
115335: LIST
115336: LIST
115337: LIST
115338: LIST
115339: LIST
115340: LIST
115341: LIST
115342: PUSH
115343: EMPTY
115344: LIST
115345: LIST
115346: ST_TO_ADDR
115347: GO 118130
115349: LD_INT 5
115351: DOUBLE
115352: EQUAL
115353: IFTRUE 115357
115355: GO 115469
115357: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
115358: LD_ADDR_VAR 0 2
115362: PUSH
115363: LD_INT 2
115365: PUSH
115366: LD_INT 4
115368: PUSH
115369: LD_INT 5
115371: PUSH
115372: LD_INT 6
115374: PUSH
115375: LD_INT 8
115377: PUSH
115378: LD_INT 11
115380: PUSH
115381: LD_INT 12
115383: PUSH
115384: LD_INT 15
115386: PUSH
115387: LD_INT 16
115389: PUSH
115390: LD_INT 22
115392: PUSH
115393: LD_INT 23
115395: PUSH
115396: LD_INT 25
115398: PUSH
115399: LD_INT 26
115401: PUSH
115402: LD_INT 36
115404: PUSH
115405: EMPTY
115406: LIST
115407: LIST
115408: LIST
115409: LIST
115410: LIST
115411: LIST
115412: LIST
115413: LIST
115414: LIST
115415: LIST
115416: LIST
115417: LIST
115418: LIST
115419: LIST
115420: PUSH
115421: LD_INT 101
115423: PUSH
115424: LD_INT 102
115426: PUSH
115427: LD_INT 105
115429: PUSH
115430: LD_INT 106
115432: PUSH
115433: LD_INT 108
115435: PUSH
115436: LD_INT 109
115438: PUSH
115439: LD_INT 112
115441: PUSH
115442: LD_INT 116
115444: PUSH
115445: LD_INT 117
115447: PUSH
115448: LD_INT 118
115450: PUSH
115451: EMPTY
115452: LIST
115453: LIST
115454: LIST
115455: LIST
115456: LIST
115457: LIST
115458: LIST
115459: LIST
115460: LIST
115461: LIST
115462: PUSH
115463: EMPTY
115464: LIST
115465: LIST
115466: ST_TO_ADDR
115467: GO 118130
115469: LD_INT 6
115471: DOUBLE
115472: EQUAL
115473: IFTRUE 115477
115475: GO 115609
115477: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
115478: LD_ADDR_VAR 0 2
115482: PUSH
115483: LD_INT 2
115485: PUSH
115486: LD_INT 4
115488: PUSH
115489: LD_INT 5
115491: PUSH
115492: LD_INT 6
115494: PUSH
115495: LD_INT 8
115497: PUSH
115498: LD_INT 11
115500: PUSH
115501: LD_INT 12
115503: PUSH
115504: LD_INT 15
115506: PUSH
115507: LD_INT 16
115509: PUSH
115510: LD_INT 20
115512: PUSH
115513: LD_INT 21
115515: PUSH
115516: LD_INT 22
115518: PUSH
115519: LD_INT 23
115521: PUSH
115522: LD_INT 25
115524: PUSH
115525: LD_INT 26
115527: PUSH
115528: LD_INT 30
115530: PUSH
115531: LD_INT 31
115533: PUSH
115534: LD_INT 32
115536: PUSH
115537: LD_INT 36
115539: PUSH
115540: EMPTY
115541: LIST
115542: LIST
115543: LIST
115544: LIST
115545: LIST
115546: LIST
115547: LIST
115548: LIST
115549: LIST
115550: LIST
115551: LIST
115552: LIST
115553: LIST
115554: LIST
115555: LIST
115556: LIST
115557: LIST
115558: LIST
115559: LIST
115560: PUSH
115561: LD_INT 101
115563: PUSH
115564: LD_INT 102
115566: PUSH
115567: LD_INT 105
115569: PUSH
115570: LD_INT 106
115572: PUSH
115573: LD_INT 108
115575: PUSH
115576: LD_INT 109
115578: PUSH
115579: LD_INT 112
115581: PUSH
115582: LD_INT 116
115584: PUSH
115585: LD_INT 117
115587: PUSH
115588: LD_INT 118
115590: PUSH
115591: EMPTY
115592: LIST
115593: LIST
115594: LIST
115595: LIST
115596: LIST
115597: LIST
115598: LIST
115599: LIST
115600: LIST
115601: LIST
115602: PUSH
115603: EMPTY
115604: LIST
115605: LIST
115606: ST_TO_ADDR
115607: GO 118130
115609: LD_INT 7
115611: DOUBLE
115612: EQUAL
115613: IFTRUE 115617
115615: GO 115729
115617: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
115618: LD_ADDR_VAR 0 2
115622: PUSH
115623: LD_INT 2
115625: PUSH
115626: LD_INT 4
115628: PUSH
115629: LD_INT 5
115631: PUSH
115632: LD_INT 7
115634: PUSH
115635: LD_INT 11
115637: PUSH
115638: LD_INT 12
115640: PUSH
115641: LD_INT 15
115643: PUSH
115644: LD_INT 16
115646: PUSH
115647: LD_INT 20
115649: PUSH
115650: LD_INT 21
115652: PUSH
115653: LD_INT 22
115655: PUSH
115656: LD_INT 23
115658: PUSH
115659: LD_INT 25
115661: PUSH
115662: LD_INT 26
115664: PUSH
115665: EMPTY
115666: LIST
115667: LIST
115668: LIST
115669: LIST
115670: LIST
115671: LIST
115672: LIST
115673: LIST
115674: LIST
115675: LIST
115676: LIST
115677: LIST
115678: LIST
115679: LIST
115680: PUSH
115681: LD_INT 101
115683: PUSH
115684: LD_INT 102
115686: PUSH
115687: LD_INT 103
115689: PUSH
115690: LD_INT 105
115692: PUSH
115693: LD_INT 106
115695: PUSH
115696: LD_INT 108
115698: PUSH
115699: LD_INT 112
115701: PUSH
115702: LD_INT 116
115704: PUSH
115705: LD_INT 117
115707: PUSH
115708: LD_INT 118
115710: PUSH
115711: EMPTY
115712: LIST
115713: LIST
115714: LIST
115715: LIST
115716: LIST
115717: LIST
115718: LIST
115719: LIST
115720: LIST
115721: LIST
115722: PUSH
115723: EMPTY
115724: LIST
115725: LIST
115726: ST_TO_ADDR
115727: GO 118130
115729: LD_INT 8
115731: DOUBLE
115732: EQUAL
115733: IFTRUE 115737
115735: GO 115877
115737: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
115738: LD_ADDR_VAR 0 2
115742: PUSH
115743: LD_INT 2
115745: PUSH
115746: LD_INT 4
115748: PUSH
115749: LD_INT 5
115751: PUSH
115752: LD_INT 6
115754: PUSH
115755: LD_INT 7
115757: PUSH
115758: LD_INT 8
115760: PUSH
115761: LD_INT 11
115763: PUSH
115764: LD_INT 12
115766: PUSH
115767: LD_INT 15
115769: PUSH
115770: LD_INT 16
115772: PUSH
115773: LD_INT 20
115775: PUSH
115776: LD_INT 21
115778: PUSH
115779: LD_INT 22
115781: PUSH
115782: LD_INT 23
115784: PUSH
115785: LD_INT 25
115787: PUSH
115788: LD_INT 26
115790: PUSH
115791: LD_INT 30
115793: PUSH
115794: LD_INT 31
115796: PUSH
115797: LD_INT 32
115799: PUSH
115800: LD_INT 36
115802: PUSH
115803: EMPTY
115804: LIST
115805: LIST
115806: LIST
115807: LIST
115808: LIST
115809: LIST
115810: LIST
115811: LIST
115812: LIST
115813: LIST
115814: LIST
115815: LIST
115816: LIST
115817: LIST
115818: LIST
115819: LIST
115820: LIST
115821: LIST
115822: LIST
115823: LIST
115824: PUSH
115825: LD_INT 101
115827: PUSH
115828: LD_INT 102
115830: PUSH
115831: LD_INT 103
115833: PUSH
115834: LD_INT 105
115836: PUSH
115837: LD_INT 106
115839: PUSH
115840: LD_INT 108
115842: PUSH
115843: LD_INT 109
115845: PUSH
115846: LD_INT 112
115848: PUSH
115849: LD_INT 116
115851: PUSH
115852: LD_INT 117
115854: PUSH
115855: LD_INT 118
115857: PUSH
115858: EMPTY
115859: LIST
115860: LIST
115861: LIST
115862: LIST
115863: LIST
115864: LIST
115865: LIST
115866: LIST
115867: LIST
115868: LIST
115869: LIST
115870: PUSH
115871: EMPTY
115872: LIST
115873: LIST
115874: ST_TO_ADDR
115875: GO 118130
115877: LD_INT 9
115879: DOUBLE
115880: EQUAL
115881: IFTRUE 115885
115883: GO 116033
115885: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
115886: LD_ADDR_VAR 0 2
115890: PUSH
115891: LD_INT 2
115893: PUSH
115894: LD_INT 4
115896: PUSH
115897: LD_INT 5
115899: PUSH
115900: LD_INT 6
115902: PUSH
115903: LD_INT 7
115905: PUSH
115906: LD_INT 8
115908: PUSH
115909: LD_INT 11
115911: PUSH
115912: LD_INT 12
115914: PUSH
115915: LD_INT 15
115917: PUSH
115918: LD_INT 16
115920: PUSH
115921: LD_INT 20
115923: PUSH
115924: LD_INT 21
115926: PUSH
115927: LD_INT 22
115929: PUSH
115930: LD_INT 23
115932: PUSH
115933: LD_INT 25
115935: PUSH
115936: LD_INT 26
115938: PUSH
115939: LD_INT 28
115941: PUSH
115942: LD_INT 30
115944: PUSH
115945: LD_INT 31
115947: PUSH
115948: LD_INT 32
115950: PUSH
115951: LD_INT 36
115953: PUSH
115954: EMPTY
115955: LIST
115956: LIST
115957: LIST
115958: LIST
115959: LIST
115960: LIST
115961: LIST
115962: LIST
115963: LIST
115964: LIST
115965: LIST
115966: LIST
115967: LIST
115968: LIST
115969: LIST
115970: LIST
115971: LIST
115972: LIST
115973: LIST
115974: LIST
115975: LIST
115976: PUSH
115977: LD_INT 101
115979: PUSH
115980: LD_INT 102
115982: PUSH
115983: LD_INT 103
115985: PUSH
115986: LD_INT 105
115988: PUSH
115989: LD_INT 106
115991: PUSH
115992: LD_INT 108
115994: PUSH
115995: LD_INT 109
115997: PUSH
115998: LD_INT 112
116000: PUSH
116001: LD_INT 114
116003: PUSH
116004: LD_INT 116
116006: PUSH
116007: LD_INT 117
116009: PUSH
116010: LD_INT 118
116012: PUSH
116013: EMPTY
116014: LIST
116015: LIST
116016: LIST
116017: LIST
116018: LIST
116019: LIST
116020: LIST
116021: LIST
116022: LIST
116023: LIST
116024: LIST
116025: LIST
116026: PUSH
116027: EMPTY
116028: LIST
116029: LIST
116030: ST_TO_ADDR
116031: GO 118130
116033: LD_INT 10
116035: DOUBLE
116036: EQUAL
116037: IFTRUE 116041
116039: GO 116237
116041: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
116042: LD_ADDR_VAR 0 2
116046: PUSH
116047: LD_INT 2
116049: PUSH
116050: LD_INT 4
116052: PUSH
116053: LD_INT 5
116055: PUSH
116056: LD_INT 6
116058: PUSH
116059: LD_INT 7
116061: PUSH
116062: LD_INT 8
116064: PUSH
116065: LD_INT 9
116067: PUSH
116068: LD_INT 10
116070: PUSH
116071: LD_INT 11
116073: PUSH
116074: LD_INT 12
116076: PUSH
116077: LD_INT 13
116079: PUSH
116080: LD_INT 14
116082: PUSH
116083: LD_INT 15
116085: PUSH
116086: LD_INT 16
116088: PUSH
116089: LD_INT 17
116091: PUSH
116092: LD_INT 18
116094: PUSH
116095: LD_INT 19
116097: PUSH
116098: LD_INT 20
116100: PUSH
116101: LD_INT 21
116103: PUSH
116104: LD_INT 22
116106: PUSH
116107: LD_INT 23
116109: PUSH
116110: LD_INT 24
116112: PUSH
116113: LD_INT 25
116115: PUSH
116116: LD_INT 26
116118: PUSH
116119: LD_INT 28
116121: PUSH
116122: LD_INT 30
116124: PUSH
116125: LD_INT 31
116127: PUSH
116128: LD_INT 32
116130: PUSH
116131: LD_INT 36
116133: PUSH
116134: EMPTY
116135: LIST
116136: LIST
116137: LIST
116138: LIST
116139: LIST
116140: LIST
116141: LIST
116142: LIST
116143: LIST
116144: LIST
116145: LIST
116146: LIST
116147: LIST
116148: LIST
116149: LIST
116150: LIST
116151: LIST
116152: LIST
116153: LIST
116154: LIST
116155: LIST
116156: LIST
116157: LIST
116158: LIST
116159: LIST
116160: LIST
116161: LIST
116162: LIST
116163: LIST
116164: PUSH
116165: LD_INT 101
116167: PUSH
116168: LD_INT 102
116170: PUSH
116171: LD_INT 103
116173: PUSH
116174: LD_INT 104
116176: PUSH
116177: LD_INT 105
116179: PUSH
116180: LD_INT 106
116182: PUSH
116183: LD_INT 107
116185: PUSH
116186: LD_INT 108
116188: PUSH
116189: LD_INT 109
116191: PUSH
116192: LD_INT 110
116194: PUSH
116195: LD_INT 111
116197: PUSH
116198: LD_INT 112
116200: PUSH
116201: LD_INT 114
116203: PUSH
116204: LD_INT 116
116206: PUSH
116207: LD_INT 117
116209: PUSH
116210: LD_INT 118
116212: PUSH
116213: EMPTY
116214: LIST
116215: LIST
116216: LIST
116217: LIST
116218: LIST
116219: LIST
116220: LIST
116221: LIST
116222: LIST
116223: LIST
116224: LIST
116225: LIST
116226: LIST
116227: LIST
116228: LIST
116229: LIST
116230: PUSH
116231: EMPTY
116232: LIST
116233: LIST
116234: ST_TO_ADDR
116235: GO 118130
116237: LD_INT 11
116239: DOUBLE
116240: EQUAL
116241: IFTRUE 116245
116243: GO 116449
116245: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
116246: LD_ADDR_VAR 0 2
116250: PUSH
116251: LD_INT 2
116253: PUSH
116254: LD_INT 3
116256: PUSH
116257: LD_INT 4
116259: PUSH
116260: LD_INT 5
116262: PUSH
116263: LD_INT 6
116265: PUSH
116266: LD_INT 7
116268: PUSH
116269: LD_INT 8
116271: PUSH
116272: LD_INT 9
116274: PUSH
116275: LD_INT 10
116277: PUSH
116278: LD_INT 11
116280: PUSH
116281: LD_INT 12
116283: PUSH
116284: LD_INT 13
116286: PUSH
116287: LD_INT 14
116289: PUSH
116290: LD_INT 15
116292: PUSH
116293: LD_INT 16
116295: PUSH
116296: LD_INT 17
116298: PUSH
116299: LD_INT 18
116301: PUSH
116302: LD_INT 19
116304: PUSH
116305: LD_INT 20
116307: PUSH
116308: LD_INT 21
116310: PUSH
116311: LD_INT 22
116313: PUSH
116314: LD_INT 23
116316: PUSH
116317: LD_INT 24
116319: PUSH
116320: LD_INT 25
116322: PUSH
116323: LD_INT 26
116325: PUSH
116326: LD_INT 28
116328: PUSH
116329: LD_INT 30
116331: PUSH
116332: LD_INT 31
116334: PUSH
116335: LD_INT 32
116337: PUSH
116338: LD_INT 34
116340: PUSH
116341: LD_INT 36
116343: PUSH
116344: EMPTY
116345: LIST
116346: LIST
116347: LIST
116348: LIST
116349: LIST
116350: LIST
116351: LIST
116352: LIST
116353: LIST
116354: LIST
116355: LIST
116356: LIST
116357: LIST
116358: LIST
116359: LIST
116360: LIST
116361: LIST
116362: LIST
116363: LIST
116364: LIST
116365: LIST
116366: LIST
116367: LIST
116368: LIST
116369: LIST
116370: LIST
116371: LIST
116372: LIST
116373: LIST
116374: LIST
116375: LIST
116376: PUSH
116377: LD_INT 101
116379: PUSH
116380: LD_INT 102
116382: PUSH
116383: LD_INT 103
116385: PUSH
116386: LD_INT 104
116388: PUSH
116389: LD_INT 105
116391: PUSH
116392: LD_INT 106
116394: PUSH
116395: LD_INT 107
116397: PUSH
116398: LD_INT 108
116400: PUSH
116401: LD_INT 109
116403: PUSH
116404: LD_INT 110
116406: PUSH
116407: LD_INT 111
116409: PUSH
116410: LD_INT 112
116412: PUSH
116413: LD_INT 114
116415: PUSH
116416: LD_INT 116
116418: PUSH
116419: LD_INT 117
116421: PUSH
116422: LD_INT 118
116424: PUSH
116425: EMPTY
116426: LIST
116427: LIST
116428: LIST
116429: LIST
116430: LIST
116431: LIST
116432: LIST
116433: LIST
116434: LIST
116435: LIST
116436: LIST
116437: LIST
116438: LIST
116439: LIST
116440: LIST
116441: LIST
116442: PUSH
116443: EMPTY
116444: LIST
116445: LIST
116446: ST_TO_ADDR
116447: GO 118130
116449: LD_INT 12
116451: DOUBLE
116452: EQUAL
116453: IFTRUE 116457
116455: GO 116677
116457: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
116458: LD_ADDR_VAR 0 2
116462: PUSH
116463: LD_INT 1
116465: PUSH
116466: LD_INT 2
116468: PUSH
116469: LD_INT 3
116471: PUSH
116472: LD_INT 4
116474: PUSH
116475: LD_INT 5
116477: PUSH
116478: LD_INT 6
116480: PUSH
116481: LD_INT 7
116483: PUSH
116484: LD_INT 8
116486: PUSH
116487: LD_INT 9
116489: PUSH
116490: LD_INT 10
116492: PUSH
116493: LD_INT 11
116495: PUSH
116496: LD_INT 12
116498: PUSH
116499: LD_INT 13
116501: PUSH
116502: LD_INT 14
116504: PUSH
116505: LD_INT 15
116507: PUSH
116508: LD_INT 16
116510: PUSH
116511: LD_INT 17
116513: PUSH
116514: LD_INT 18
116516: PUSH
116517: LD_INT 19
116519: PUSH
116520: LD_INT 20
116522: PUSH
116523: LD_INT 21
116525: PUSH
116526: LD_INT 22
116528: PUSH
116529: LD_INT 23
116531: PUSH
116532: LD_INT 24
116534: PUSH
116535: LD_INT 25
116537: PUSH
116538: LD_INT 26
116540: PUSH
116541: LD_INT 27
116543: PUSH
116544: LD_INT 28
116546: PUSH
116547: LD_INT 30
116549: PUSH
116550: LD_INT 31
116552: PUSH
116553: LD_INT 32
116555: PUSH
116556: LD_INT 33
116558: PUSH
116559: LD_INT 34
116561: PUSH
116562: LD_INT 36
116564: PUSH
116565: EMPTY
116566: LIST
116567: LIST
116568: LIST
116569: LIST
116570: LIST
116571: LIST
116572: LIST
116573: LIST
116574: LIST
116575: LIST
116576: LIST
116577: LIST
116578: LIST
116579: LIST
116580: LIST
116581: LIST
116582: LIST
116583: LIST
116584: LIST
116585: LIST
116586: LIST
116587: LIST
116588: LIST
116589: LIST
116590: LIST
116591: LIST
116592: LIST
116593: LIST
116594: LIST
116595: LIST
116596: LIST
116597: LIST
116598: LIST
116599: LIST
116600: PUSH
116601: LD_INT 101
116603: PUSH
116604: LD_INT 102
116606: PUSH
116607: LD_INT 103
116609: PUSH
116610: LD_INT 104
116612: PUSH
116613: LD_INT 105
116615: PUSH
116616: LD_INT 106
116618: PUSH
116619: LD_INT 107
116621: PUSH
116622: LD_INT 108
116624: PUSH
116625: LD_INT 109
116627: PUSH
116628: LD_INT 110
116630: PUSH
116631: LD_INT 111
116633: PUSH
116634: LD_INT 112
116636: PUSH
116637: LD_INT 113
116639: PUSH
116640: LD_INT 114
116642: PUSH
116643: LD_INT 116
116645: PUSH
116646: LD_INT 117
116648: PUSH
116649: LD_INT 118
116651: PUSH
116652: EMPTY
116653: LIST
116654: LIST
116655: LIST
116656: LIST
116657: LIST
116658: LIST
116659: LIST
116660: LIST
116661: LIST
116662: LIST
116663: LIST
116664: LIST
116665: LIST
116666: LIST
116667: LIST
116668: LIST
116669: LIST
116670: PUSH
116671: EMPTY
116672: LIST
116673: LIST
116674: ST_TO_ADDR
116675: GO 118130
116677: LD_INT 13
116679: DOUBLE
116680: EQUAL
116681: IFTRUE 116685
116683: GO 116893
116685: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
116686: LD_ADDR_VAR 0 2
116690: PUSH
116691: LD_INT 1
116693: PUSH
116694: LD_INT 2
116696: PUSH
116697: LD_INT 3
116699: PUSH
116700: LD_INT 4
116702: PUSH
116703: LD_INT 5
116705: PUSH
116706: LD_INT 8
116708: PUSH
116709: LD_INT 9
116711: PUSH
116712: LD_INT 10
116714: PUSH
116715: LD_INT 11
116717: PUSH
116718: LD_INT 12
116720: PUSH
116721: LD_INT 14
116723: PUSH
116724: LD_INT 15
116726: PUSH
116727: LD_INT 16
116729: PUSH
116730: LD_INT 17
116732: PUSH
116733: LD_INT 18
116735: PUSH
116736: LD_INT 19
116738: PUSH
116739: LD_INT 20
116741: PUSH
116742: LD_INT 21
116744: PUSH
116745: LD_INT 22
116747: PUSH
116748: LD_INT 23
116750: PUSH
116751: LD_INT 24
116753: PUSH
116754: LD_INT 25
116756: PUSH
116757: LD_INT 26
116759: PUSH
116760: LD_INT 27
116762: PUSH
116763: LD_INT 28
116765: PUSH
116766: LD_INT 30
116768: PUSH
116769: LD_INT 31
116771: PUSH
116772: LD_INT 32
116774: PUSH
116775: LD_INT 33
116777: PUSH
116778: LD_INT 34
116780: PUSH
116781: LD_INT 36
116783: PUSH
116784: EMPTY
116785: LIST
116786: LIST
116787: LIST
116788: LIST
116789: LIST
116790: LIST
116791: LIST
116792: LIST
116793: LIST
116794: LIST
116795: LIST
116796: LIST
116797: LIST
116798: LIST
116799: LIST
116800: LIST
116801: LIST
116802: LIST
116803: LIST
116804: LIST
116805: LIST
116806: LIST
116807: LIST
116808: LIST
116809: LIST
116810: LIST
116811: LIST
116812: LIST
116813: LIST
116814: LIST
116815: LIST
116816: PUSH
116817: LD_INT 101
116819: PUSH
116820: LD_INT 102
116822: PUSH
116823: LD_INT 103
116825: PUSH
116826: LD_INT 104
116828: PUSH
116829: LD_INT 105
116831: PUSH
116832: LD_INT 106
116834: PUSH
116835: LD_INT 107
116837: PUSH
116838: LD_INT 108
116840: PUSH
116841: LD_INT 109
116843: PUSH
116844: LD_INT 110
116846: PUSH
116847: LD_INT 111
116849: PUSH
116850: LD_INT 112
116852: PUSH
116853: LD_INT 113
116855: PUSH
116856: LD_INT 114
116858: PUSH
116859: LD_INT 116
116861: PUSH
116862: LD_INT 117
116864: PUSH
116865: LD_INT 118
116867: PUSH
116868: EMPTY
116869: LIST
116870: LIST
116871: LIST
116872: LIST
116873: LIST
116874: LIST
116875: LIST
116876: LIST
116877: LIST
116878: LIST
116879: LIST
116880: LIST
116881: LIST
116882: LIST
116883: LIST
116884: LIST
116885: LIST
116886: PUSH
116887: EMPTY
116888: LIST
116889: LIST
116890: ST_TO_ADDR
116891: GO 118130
116893: LD_INT 14
116895: DOUBLE
116896: EQUAL
116897: IFTRUE 116901
116899: GO 117125
116901: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
116902: LD_ADDR_VAR 0 2
116906: PUSH
116907: LD_INT 1
116909: PUSH
116910: LD_INT 2
116912: PUSH
116913: LD_INT 3
116915: PUSH
116916: LD_INT 4
116918: PUSH
116919: LD_INT 5
116921: PUSH
116922: LD_INT 6
116924: PUSH
116925: LD_INT 7
116927: PUSH
116928: LD_INT 8
116930: PUSH
116931: LD_INT 9
116933: PUSH
116934: LD_INT 10
116936: PUSH
116937: LD_INT 11
116939: PUSH
116940: LD_INT 12
116942: PUSH
116943: LD_INT 13
116945: PUSH
116946: LD_INT 14
116948: PUSH
116949: LD_INT 15
116951: PUSH
116952: LD_INT 16
116954: PUSH
116955: LD_INT 17
116957: PUSH
116958: LD_INT 18
116960: PUSH
116961: LD_INT 19
116963: PUSH
116964: LD_INT 20
116966: PUSH
116967: LD_INT 21
116969: PUSH
116970: LD_INT 22
116972: PUSH
116973: LD_INT 23
116975: PUSH
116976: LD_INT 24
116978: PUSH
116979: LD_INT 25
116981: PUSH
116982: LD_INT 26
116984: PUSH
116985: LD_INT 27
116987: PUSH
116988: LD_INT 28
116990: PUSH
116991: LD_INT 29
116993: PUSH
116994: LD_INT 30
116996: PUSH
116997: LD_INT 31
116999: PUSH
117000: LD_INT 32
117002: PUSH
117003: LD_INT 33
117005: PUSH
117006: LD_INT 34
117008: PUSH
117009: LD_INT 36
117011: PUSH
117012: EMPTY
117013: LIST
117014: LIST
117015: LIST
117016: LIST
117017: LIST
117018: LIST
117019: LIST
117020: LIST
117021: LIST
117022: LIST
117023: LIST
117024: LIST
117025: LIST
117026: LIST
117027: LIST
117028: LIST
117029: LIST
117030: LIST
117031: LIST
117032: LIST
117033: LIST
117034: LIST
117035: LIST
117036: LIST
117037: LIST
117038: LIST
117039: LIST
117040: LIST
117041: LIST
117042: LIST
117043: LIST
117044: LIST
117045: LIST
117046: LIST
117047: LIST
117048: PUSH
117049: LD_INT 101
117051: PUSH
117052: LD_INT 102
117054: PUSH
117055: LD_INT 103
117057: PUSH
117058: LD_INT 104
117060: PUSH
117061: LD_INT 105
117063: PUSH
117064: LD_INT 106
117066: PUSH
117067: LD_INT 107
117069: PUSH
117070: LD_INT 108
117072: PUSH
117073: LD_INT 109
117075: PUSH
117076: LD_INT 110
117078: PUSH
117079: LD_INT 111
117081: PUSH
117082: LD_INT 112
117084: PUSH
117085: LD_INT 113
117087: PUSH
117088: LD_INT 114
117090: PUSH
117091: LD_INT 116
117093: PUSH
117094: LD_INT 117
117096: PUSH
117097: LD_INT 118
117099: PUSH
117100: EMPTY
117101: LIST
117102: LIST
117103: LIST
117104: LIST
117105: LIST
117106: LIST
117107: LIST
117108: LIST
117109: LIST
117110: LIST
117111: LIST
117112: LIST
117113: LIST
117114: LIST
117115: LIST
117116: LIST
117117: LIST
117118: PUSH
117119: EMPTY
117120: LIST
117121: LIST
117122: ST_TO_ADDR
117123: GO 118130
117125: LD_INT 15
117127: DOUBLE
117128: EQUAL
117129: IFTRUE 117133
117131: GO 117357
117133: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
117134: LD_ADDR_VAR 0 2
117138: PUSH
117139: LD_INT 1
117141: PUSH
117142: LD_INT 2
117144: PUSH
117145: LD_INT 3
117147: PUSH
117148: LD_INT 4
117150: PUSH
117151: LD_INT 5
117153: PUSH
117154: LD_INT 6
117156: PUSH
117157: LD_INT 7
117159: PUSH
117160: LD_INT 8
117162: PUSH
117163: LD_INT 9
117165: PUSH
117166: LD_INT 10
117168: PUSH
117169: LD_INT 11
117171: PUSH
117172: LD_INT 12
117174: PUSH
117175: LD_INT 13
117177: PUSH
117178: LD_INT 14
117180: PUSH
117181: LD_INT 15
117183: PUSH
117184: LD_INT 16
117186: PUSH
117187: LD_INT 17
117189: PUSH
117190: LD_INT 18
117192: PUSH
117193: LD_INT 19
117195: PUSH
117196: LD_INT 20
117198: PUSH
117199: LD_INT 21
117201: PUSH
117202: LD_INT 22
117204: PUSH
117205: LD_INT 23
117207: PUSH
117208: LD_INT 24
117210: PUSH
117211: LD_INT 25
117213: PUSH
117214: LD_INT 26
117216: PUSH
117217: LD_INT 27
117219: PUSH
117220: LD_INT 28
117222: PUSH
117223: LD_INT 29
117225: PUSH
117226: LD_INT 30
117228: PUSH
117229: LD_INT 31
117231: PUSH
117232: LD_INT 32
117234: PUSH
117235: LD_INT 33
117237: PUSH
117238: LD_INT 34
117240: PUSH
117241: LD_INT 36
117243: PUSH
117244: EMPTY
117245: LIST
117246: LIST
117247: LIST
117248: LIST
117249: LIST
117250: LIST
117251: LIST
117252: LIST
117253: LIST
117254: LIST
117255: LIST
117256: LIST
117257: LIST
117258: LIST
117259: LIST
117260: LIST
117261: LIST
117262: LIST
117263: LIST
117264: LIST
117265: LIST
117266: LIST
117267: LIST
117268: LIST
117269: LIST
117270: LIST
117271: LIST
117272: LIST
117273: LIST
117274: LIST
117275: LIST
117276: LIST
117277: LIST
117278: LIST
117279: LIST
117280: PUSH
117281: LD_INT 101
117283: PUSH
117284: LD_INT 102
117286: PUSH
117287: LD_INT 103
117289: PUSH
117290: LD_INT 104
117292: PUSH
117293: LD_INT 105
117295: PUSH
117296: LD_INT 106
117298: PUSH
117299: LD_INT 107
117301: PUSH
117302: LD_INT 108
117304: PUSH
117305: LD_INT 109
117307: PUSH
117308: LD_INT 110
117310: PUSH
117311: LD_INT 111
117313: PUSH
117314: LD_INT 112
117316: PUSH
117317: LD_INT 113
117319: PUSH
117320: LD_INT 114
117322: PUSH
117323: LD_INT 116
117325: PUSH
117326: LD_INT 117
117328: PUSH
117329: LD_INT 118
117331: PUSH
117332: EMPTY
117333: LIST
117334: LIST
117335: LIST
117336: LIST
117337: LIST
117338: LIST
117339: LIST
117340: LIST
117341: LIST
117342: LIST
117343: LIST
117344: LIST
117345: LIST
117346: LIST
117347: LIST
117348: LIST
117349: LIST
117350: PUSH
117351: EMPTY
117352: LIST
117353: LIST
117354: ST_TO_ADDR
117355: GO 118130
117357: LD_INT 16
117359: DOUBLE
117360: EQUAL
117361: IFTRUE 117365
117363: GO 117501
117365: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
117366: LD_ADDR_VAR 0 2
117370: PUSH
117371: LD_INT 2
117373: PUSH
117374: LD_INT 4
117376: PUSH
117377: LD_INT 5
117379: PUSH
117380: LD_INT 7
117382: PUSH
117383: LD_INT 11
117385: PUSH
117386: LD_INT 12
117388: PUSH
117389: LD_INT 15
117391: PUSH
117392: LD_INT 16
117394: PUSH
117395: LD_INT 20
117397: PUSH
117398: LD_INT 21
117400: PUSH
117401: LD_INT 22
117403: PUSH
117404: LD_INT 23
117406: PUSH
117407: LD_INT 25
117409: PUSH
117410: LD_INT 26
117412: PUSH
117413: LD_INT 30
117415: PUSH
117416: LD_INT 31
117418: PUSH
117419: LD_INT 32
117421: PUSH
117422: LD_INT 33
117424: PUSH
117425: LD_INT 34
117427: PUSH
117428: EMPTY
117429: LIST
117430: LIST
117431: LIST
117432: LIST
117433: LIST
117434: LIST
117435: LIST
117436: LIST
117437: LIST
117438: LIST
117439: LIST
117440: LIST
117441: LIST
117442: LIST
117443: LIST
117444: LIST
117445: LIST
117446: LIST
117447: LIST
117448: PUSH
117449: LD_INT 101
117451: PUSH
117452: LD_INT 102
117454: PUSH
117455: LD_INT 103
117457: PUSH
117458: LD_INT 106
117460: PUSH
117461: LD_INT 108
117463: PUSH
117464: LD_INT 112
117466: PUSH
117467: LD_INT 113
117469: PUSH
117470: LD_INT 114
117472: PUSH
117473: LD_INT 116
117475: PUSH
117476: LD_INT 117
117478: PUSH
117479: LD_INT 118
117481: PUSH
117482: EMPTY
117483: LIST
117484: LIST
117485: LIST
117486: LIST
117487: LIST
117488: LIST
117489: LIST
117490: LIST
117491: LIST
117492: LIST
117493: LIST
117494: PUSH
117495: EMPTY
117496: LIST
117497: LIST
117498: ST_TO_ADDR
117499: GO 118130
117501: LD_INT 17
117503: DOUBLE
117504: EQUAL
117505: IFTRUE 117509
117507: GO 117733
117509: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
117510: LD_ADDR_VAR 0 2
117514: PUSH
117515: LD_INT 1
117517: PUSH
117518: LD_INT 2
117520: PUSH
117521: LD_INT 3
117523: PUSH
117524: LD_INT 4
117526: PUSH
117527: LD_INT 5
117529: PUSH
117530: LD_INT 6
117532: PUSH
117533: LD_INT 7
117535: PUSH
117536: LD_INT 8
117538: PUSH
117539: LD_INT 9
117541: PUSH
117542: LD_INT 10
117544: PUSH
117545: LD_INT 11
117547: PUSH
117548: LD_INT 12
117550: PUSH
117551: LD_INT 13
117553: PUSH
117554: LD_INT 14
117556: PUSH
117557: LD_INT 15
117559: PUSH
117560: LD_INT 16
117562: PUSH
117563: LD_INT 17
117565: PUSH
117566: LD_INT 18
117568: PUSH
117569: LD_INT 19
117571: PUSH
117572: LD_INT 20
117574: PUSH
117575: LD_INT 21
117577: PUSH
117578: LD_INT 22
117580: PUSH
117581: LD_INT 23
117583: PUSH
117584: LD_INT 24
117586: PUSH
117587: LD_INT 25
117589: PUSH
117590: LD_INT 26
117592: PUSH
117593: LD_INT 27
117595: PUSH
117596: LD_INT 28
117598: PUSH
117599: LD_INT 29
117601: PUSH
117602: LD_INT 30
117604: PUSH
117605: LD_INT 31
117607: PUSH
117608: LD_INT 32
117610: PUSH
117611: LD_INT 33
117613: PUSH
117614: LD_INT 34
117616: PUSH
117617: LD_INT 36
117619: PUSH
117620: EMPTY
117621: LIST
117622: LIST
117623: LIST
117624: LIST
117625: LIST
117626: LIST
117627: LIST
117628: LIST
117629: LIST
117630: LIST
117631: LIST
117632: LIST
117633: LIST
117634: LIST
117635: LIST
117636: LIST
117637: LIST
117638: LIST
117639: LIST
117640: LIST
117641: LIST
117642: LIST
117643: LIST
117644: LIST
117645: LIST
117646: LIST
117647: LIST
117648: LIST
117649: LIST
117650: LIST
117651: LIST
117652: LIST
117653: LIST
117654: LIST
117655: LIST
117656: PUSH
117657: LD_INT 101
117659: PUSH
117660: LD_INT 102
117662: PUSH
117663: LD_INT 103
117665: PUSH
117666: LD_INT 104
117668: PUSH
117669: LD_INT 105
117671: PUSH
117672: LD_INT 106
117674: PUSH
117675: LD_INT 107
117677: PUSH
117678: LD_INT 108
117680: PUSH
117681: LD_INT 109
117683: PUSH
117684: LD_INT 110
117686: PUSH
117687: LD_INT 111
117689: PUSH
117690: LD_INT 112
117692: PUSH
117693: LD_INT 113
117695: PUSH
117696: LD_INT 114
117698: PUSH
117699: LD_INT 116
117701: PUSH
117702: LD_INT 117
117704: PUSH
117705: LD_INT 118
117707: PUSH
117708: EMPTY
117709: LIST
117710: LIST
117711: LIST
117712: LIST
117713: LIST
117714: LIST
117715: LIST
117716: LIST
117717: LIST
117718: LIST
117719: LIST
117720: LIST
117721: LIST
117722: LIST
117723: LIST
117724: LIST
117725: LIST
117726: PUSH
117727: EMPTY
117728: LIST
117729: LIST
117730: ST_TO_ADDR
117731: GO 118130
117733: LD_INT 18
117735: DOUBLE
117736: EQUAL
117737: IFTRUE 117741
117739: GO 117889
117741: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
117742: LD_ADDR_VAR 0 2
117746: PUSH
117747: LD_INT 2
117749: PUSH
117750: LD_INT 4
117752: PUSH
117753: LD_INT 5
117755: PUSH
117756: LD_INT 7
117758: PUSH
117759: LD_INT 11
117761: PUSH
117762: LD_INT 12
117764: PUSH
117765: LD_INT 15
117767: PUSH
117768: LD_INT 16
117770: PUSH
117771: LD_INT 20
117773: PUSH
117774: LD_INT 21
117776: PUSH
117777: LD_INT 22
117779: PUSH
117780: LD_INT 23
117782: PUSH
117783: LD_INT 25
117785: PUSH
117786: LD_INT 26
117788: PUSH
117789: LD_INT 30
117791: PUSH
117792: LD_INT 31
117794: PUSH
117795: LD_INT 32
117797: PUSH
117798: LD_INT 33
117800: PUSH
117801: LD_INT 34
117803: PUSH
117804: LD_INT 35
117806: PUSH
117807: LD_INT 36
117809: PUSH
117810: EMPTY
117811: LIST
117812: LIST
117813: LIST
117814: LIST
117815: LIST
117816: LIST
117817: LIST
117818: LIST
117819: LIST
117820: LIST
117821: LIST
117822: LIST
117823: LIST
117824: LIST
117825: LIST
117826: LIST
117827: LIST
117828: LIST
117829: LIST
117830: LIST
117831: LIST
117832: PUSH
117833: LD_INT 101
117835: PUSH
117836: LD_INT 102
117838: PUSH
117839: LD_INT 103
117841: PUSH
117842: LD_INT 106
117844: PUSH
117845: LD_INT 108
117847: PUSH
117848: LD_INT 112
117850: PUSH
117851: LD_INT 113
117853: PUSH
117854: LD_INT 114
117856: PUSH
117857: LD_INT 115
117859: PUSH
117860: LD_INT 116
117862: PUSH
117863: LD_INT 117
117865: PUSH
117866: LD_INT 118
117868: PUSH
117869: EMPTY
117870: LIST
117871: LIST
117872: LIST
117873: LIST
117874: LIST
117875: LIST
117876: LIST
117877: LIST
117878: LIST
117879: LIST
117880: LIST
117881: LIST
117882: PUSH
117883: EMPTY
117884: LIST
117885: LIST
117886: ST_TO_ADDR
117887: GO 118130
117889: LD_INT 19
117891: DOUBLE
117892: EQUAL
117893: IFTRUE 117897
117895: GO 118129
117897: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
117898: LD_ADDR_VAR 0 2
117902: PUSH
117903: LD_INT 1
117905: PUSH
117906: LD_INT 2
117908: PUSH
117909: LD_INT 3
117911: PUSH
117912: LD_INT 4
117914: PUSH
117915: LD_INT 5
117917: PUSH
117918: LD_INT 6
117920: PUSH
117921: LD_INT 7
117923: PUSH
117924: LD_INT 8
117926: PUSH
117927: LD_INT 9
117929: PUSH
117930: LD_INT 10
117932: PUSH
117933: LD_INT 11
117935: PUSH
117936: LD_INT 12
117938: PUSH
117939: LD_INT 13
117941: PUSH
117942: LD_INT 14
117944: PUSH
117945: LD_INT 15
117947: PUSH
117948: LD_INT 16
117950: PUSH
117951: LD_INT 17
117953: PUSH
117954: LD_INT 18
117956: PUSH
117957: LD_INT 19
117959: PUSH
117960: LD_INT 20
117962: PUSH
117963: LD_INT 21
117965: PUSH
117966: LD_INT 22
117968: PUSH
117969: LD_INT 23
117971: PUSH
117972: LD_INT 24
117974: PUSH
117975: LD_INT 25
117977: PUSH
117978: LD_INT 26
117980: PUSH
117981: LD_INT 27
117983: PUSH
117984: LD_INT 28
117986: PUSH
117987: LD_INT 29
117989: PUSH
117990: LD_INT 30
117992: PUSH
117993: LD_INT 31
117995: PUSH
117996: LD_INT 32
117998: PUSH
117999: LD_INT 33
118001: PUSH
118002: LD_INT 34
118004: PUSH
118005: LD_INT 35
118007: PUSH
118008: LD_INT 36
118010: PUSH
118011: EMPTY
118012: LIST
118013: LIST
118014: LIST
118015: LIST
118016: LIST
118017: LIST
118018: LIST
118019: LIST
118020: LIST
118021: LIST
118022: LIST
118023: LIST
118024: LIST
118025: LIST
118026: LIST
118027: LIST
118028: LIST
118029: LIST
118030: LIST
118031: LIST
118032: LIST
118033: LIST
118034: LIST
118035: LIST
118036: LIST
118037: LIST
118038: LIST
118039: LIST
118040: LIST
118041: LIST
118042: LIST
118043: LIST
118044: LIST
118045: LIST
118046: LIST
118047: LIST
118048: PUSH
118049: LD_INT 101
118051: PUSH
118052: LD_INT 102
118054: PUSH
118055: LD_INT 103
118057: PUSH
118058: LD_INT 104
118060: PUSH
118061: LD_INT 105
118063: PUSH
118064: LD_INT 106
118066: PUSH
118067: LD_INT 107
118069: PUSH
118070: LD_INT 108
118072: PUSH
118073: LD_INT 109
118075: PUSH
118076: LD_INT 110
118078: PUSH
118079: LD_INT 111
118081: PUSH
118082: LD_INT 112
118084: PUSH
118085: LD_INT 113
118087: PUSH
118088: LD_INT 114
118090: PUSH
118091: LD_INT 115
118093: PUSH
118094: LD_INT 116
118096: PUSH
118097: LD_INT 117
118099: PUSH
118100: LD_INT 118
118102: PUSH
118103: EMPTY
118104: LIST
118105: LIST
118106: LIST
118107: LIST
118108: LIST
118109: LIST
118110: LIST
118111: LIST
118112: LIST
118113: LIST
118114: LIST
118115: LIST
118116: LIST
118117: LIST
118118: LIST
118119: LIST
118120: LIST
118121: LIST
118122: PUSH
118123: EMPTY
118124: LIST
118125: LIST
118126: ST_TO_ADDR
118127: GO 118130
118129: POP
// end else
118130: GO 118361
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
118132: LD_ADDR_VAR 0 2
118136: PUSH
118137: LD_INT 1
118139: PUSH
118140: LD_INT 2
118142: PUSH
118143: LD_INT 3
118145: PUSH
118146: LD_INT 4
118148: PUSH
118149: LD_INT 5
118151: PUSH
118152: LD_INT 6
118154: PUSH
118155: LD_INT 7
118157: PUSH
118158: LD_INT 8
118160: PUSH
118161: LD_INT 9
118163: PUSH
118164: LD_INT 10
118166: PUSH
118167: LD_INT 11
118169: PUSH
118170: LD_INT 12
118172: PUSH
118173: LD_INT 13
118175: PUSH
118176: LD_INT 14
118178: PUSH
118179: LD_INT 15
118181: PUSH
118182: LD_INT 16
118184: PUSH
118185: LD_INT 17
118187: PUSH
118188: LD_INT 18
118190: PUSH
118191: LD_INT 19
118193: PUSH
118194: LD_INT 20
118196: PUSH
118197: LD_INT 21
118199: PUSH
118200: LD_INT 22
118202: PUSH
118203: LD_INT 23
118205: PUSH
118206: LD_INT 24
118208: PUSH
118209: LD_INT 25
118211: PUSH
118212: LD_INT 26
118214: PUSH
118215: LD_INT 27
118217: PUSH
118218: LD_INT 28
118220: PUSH
118221: LD_INT 29
118223: PUSH
118224: LD_INT 30
118226: PUSH
118227: LD_INT 31
118229: PUSH
118230: LD_INT 32
118232: PUSH
118233: LD_INT 33
118235: PUSH
118236: LD_INT 34
118238: PUSH
118239: LD_INT 35
118241: PUSH
118242: LD_INT 36
118244: PUSH
118245: EMPTY
118246: LIST
118247: LIST
118248: LIST
118249: LIST
118250: LIST
118251: LIST
118252: LIST
118253: LIST
118254: LIST
118255: LIST
118256: LIST
118257: LIST
118258: LIST
118259: LIST
118260: LIST
118261: LIST
118262: LIST
118263: LIST
118264: LIST
118265: LIST
118266: LIST
118267: LIST
118268: LIST
118269: LIST
118270: LIST
118271: LIST
118272: LIST
118273: LIST
118274: LIST
118275: LIST
118276: LIST
118277: LIST
118278: LIST
118279: LIST
118280: LIST
118281: LIST
118282: PUSH
118283: LD_INT 101
118285: PUSH
118286: LD_INT 102
118288: PUSH
118289: LD_INT 103
118291: PUSH
118292: LD_INT 104
118294: PUSH
118295: LD_INT 105
118297: PUSH
118298: LD_INT 106
118300: PUSH
118301: LD_INT 107
118303: PUSH
118304: LD_INT 108
118306: PUSH
118307: LD_INT 109
118309: PUSH
118310: LD_INT 110
118312: PUSH
118313: LD_INT 111
118315: PUSH
118316: LD_INT 112
118318: PUSH
118319: LD_INT 113
118321: PUSH
118322: LD_INT 114
118324: PUSH
118325: LD_INT 115
118327: PUSH
118328: LD_INT 116
118330: PUSH
118331: LD_INT 117
118333: PUSH
118334: LD_INT 118
118336: PUSH
118337: EMPTY
118338: LIST
118339: LIST
118340: LIST
118341: LIST
118342: LIST
118343: LIST
118344: LIST
118345: LIST
118346: LIST
118347: LIST
118348: LIST
118349: LIST
118350: LIST
118351: LIST
118352: LIST
118353: LIST
118354: LIST
118355: LIST
118356: PUSH
118357: EMPTY
118358: LIST
118359: LIST
118360: ST_TO_ADDR
// if result then
118361: LD_VAR 0 2
118365: IFFALSE 119151
// begin normal :=  ;
118367: LD_ADDR_VAR 0 5
118371: PUSH
118372: LD_STRING 
118374: ST_TO_ADDR
// hardcore :=  ;
118375: LD_ADDR_VAR 0 6
118379: PUSH
118380: LD_STRING 
118382: ST_TO_ADDR
// active :=  ;
118383: LD_ADDR_VAR 0 7
118387: PUSH
118388: LD_STRING 
118390: ST_TO_ADDR
// for i = 1 to normalCounter do
118391: LD_ADDR_VAR 0 8
118395: PUSH
118396: DOUBLE
118397: LD_INT 1
118399: DEC
118400: ST_TO_ADDR
118401: LD_EXP 149
118405: PUSH
118406: FOR_TO
118407: IFFALSE 118508
// begin tmp := 0 ;
118409: LD_ADDR_VAR 0 3
118413: PUSH
118414: LD_STRING 0
118416: ST_TO_ADDR
// if result [ 1 ] then
118417: LD_VAR 0 2
118421: PUSH
118422: LD_INT 1
118424: ARRAY
118425: IFFALSE 118490
// if result [ 1 ] [ 1 ] = i then
118427: LD_VAR 0 2
118431: PUSH
118432: LD_INT 1
118434: ARRAY
118435: PUSH
118436: LD_INT 1
118438: ARRAY
118439: PUSH
118440: LD_VAR 0 8
118444: EQUAL
118445: IFFALSE 118490
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
118447: LD_ADDR_VAR 0 2
118451: PUSH
118452: LD_VAR 0 2
118456: PPUSH
118457: LD_INT 1
118459: PPUSH
118460: LD_VAR 0 2
118464: PUSH
118465: LD_INT 1
118467: ARRAY
118468: PPUSH
118469: LD_INT 1
118471: PPUSH
118472: CALL_OW 3
118476: PPUSH
118477: CALL_OW 1
118481: ST_TO_ADDR
// tmp := 1 ;
118482: LD_ADDR_VAR 0 3
118486: PUSH
118487: LD_STRING 1
118489: ST_TO_ADDR
// end ; normal := normal & tmp ;
118490: LD_ADDR_VAR 0 5
118494: PUSH
118495: LD_VAR 0 5
118499: PUSH
118500: LD_VAR 0 3
118504: STR
118505: ST_TO_ADDR
// end ;
118506: GO 118406
118508: POP
118509: POP
// for i = 1 to hardcoreCounter do
118510: LD_ADDR_VAR 0 8
118514: PUSH
118515: DOUBLE
118516: LD_INT 1
118518: DEC
118519: ST_TO_ADDR
118520: LD_EXP 150
118524: PUSH
118525: FOR_TO
118526: IFFALSE 118631
// begin tmp := 0 ;
118528: LD_ADDR_VAR 0 3
118532: PUSH
118533: LD_STRING 0
118535: ST_TO_ADDR
// if result [ 2 ] then
118536: LD_VAR 0 2
118540: PUSH
118541: LD_INT 2
118543: ARRAY
118544: IFFALSE 118613
// if result [ 2 ] [ 1 ] = 100 + i then
118546: LD_VAR 0 2
118550: PUSH
118551: LD_INT 2
118553: ARRAY
118554: PUSH
118555: LD_INT 1
118557: ARRAY
118558: PUSH
118559: LD_INT 100
118561: PUSH
118562: LD_VAR 0 8
118566: PLUS
118567: EQUAL
118568: IFFALSE 118613
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
118570: LD_ADDR_VAR 0 2
118574: PUSH
118575: LD_VAR 0 2
118579: PPUSH
118580: LD_INT 2
118582: PPUSH
118583: LD_VAR 0 2
118587: PUSH
118588: LD_INT 2
118590: ARRAY
118591: PPUSH
118592: LD_INT 1
118594: PPUSH
118595: CALL_OW 3
118599: PPUSH
118600: CALL_OW 1
118604: ST_TO_ADDR
// tmp := 1 ;
118605: LD_ADDR_VAR 0 3
118609: PUSH
118610: LD_STRING 1
118612: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
118613: LD_ADDR_VAR 0 6
118617: PUSH
118618: LD_VAR 0 6
118622: PUSH
118623: LD_VAR 0 3
118627: STR
118628: ST_TO_ADDR
// end ;
118629: GO 118525
118631: POP
118632: POP
// if isGameLoad then
118633: LD_VAR 0 1
118637: IFFALSE 119112
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
118639: LD_ADDR_VAR 0 4
118643: PUSH
118644: LD_EXP 153
118648: PUSH
118649: LD_EXP 152
118653: PUSH
118654: LD_EXP 154
118658: PUSH
118659: LD_EXP 151
118663: PUSH
118664: LD_EXP 155
118668: PUSH
118669: LD_EXP 156
118673: PUSH
118674: LD_EXP 157
118678: PUSH
118679: LD_EXP 158
118683: PUSH
118684: LD_EXP 159
118688: PUSH
118689: LD_EXP 160
118693: PUSH
118694: LD_EXP 161
118698: PUSH
118699: LD_EXP 162
118703: PUSH
118704: LD_EXP 163
118708: PUSH
118709: LD_EXP 164
118713: PUSH
118714: LD_EXP 172
118718: PUSH
118719: LD_EXP 173
118723: PUSH
118724: LD_EXP 174
118728: PUSH
118729: LD_EXP 175
118733: PUSH
118734: LD_EXP 177
118738: PUSH
118739: LD_EXP 178
118743: PUSH
118744: LD_EXP 179
118748: PUSH
118749: LD_EXP 182
118753: PUSH
118754: LD_EXP 184
118758: PUSH
118759: LD_EXP 185
118763: PUSH
118764: LD_EXP 186
118768: PUSH
118769: LD_EXP 188
118773: PUSH
118774: LD_EXP 189
118778: PUSH
118779: LD_EXP 192
118783: PUSH
118784: LD_EXP 193
118788: PUSH
118789: LD_EXP 194
118793: PUSH
118794: LD_EXP 195
118798: PUSH
118799: LD_EXP 196
118803: PUSH
118804: LD_EXP 197
118808: PUSH
118809: LD_EXP 198
118813: PUSH
118814: LD_EXP 199
118818: PUSH
118819: LD_EXP 200
118823: PUSH
118824: LD_EXP 165
118828: PUSH
118829: LD_EXP 166
118833: PUSH
118834: LD_EXP 169
118838: PUSH
118839: LD_EXP 170
118843: PUSH
118844: LD_EXP 171
118848: PUSH
118849: LD_EXP 167
118853: PUSH
118854: LD_EXP 168
118858: PUSH
118859: LD_EXP 176
118863: PUSH
118864: LD_EXP 180
118868: PUSH
118869: LD_EXP 181
118873: PUSH
118874: LD_EXP 183
118878: PUSH
118879: LD_EXP 187
118883: PUSH
118884: LD_EXP 190
118888: PUSH
118889: LD_EXP 191
118893: PUSH
118894: LD_EXP 201
118898: PUSH
118899: LD_EXP 202
118903: PUSH
118904: LD_EXP 203
118908: PUSH
118909: LD_EXP 204
118913: PUSH
118914: EMPTY
118915: LIST
118916: LIST
118917: LIST
118918: LIST
118919: LIST
118920: LIST
118921: LIST
118922: LIST
118923: LIST
118924: LIST
118925: LIST
118926: LIST
118927: LIST
118928: LIST
118929: LIST
118930: LIST
118931: LIST
118932: LIST
118933: LIST
118934: LIST
118935: LIST
118936: LIST
118937: LIST
118938: LIST
118939: LIST
118940: LIST
118941: LIST
118942: LIST
118943: LIST
118944: LIST
118945: LIST
118946: LIST
118947: LIST
118948: LIST
118949: LIST
118950: LIST
118951: LIST
118952: LIST
118953: LIST
118954: LIST
118955: LIST
118956: LIST
118957: LIST
118958: LIST
118959: LIST
118960: LIST
118961: LIST
118962: LIST
118963: LIST
118964: LIST
118965: LIST
118966: LIST
118967: LIST
118968: LIST
118969: ST_TO_ADDR
// tmp :=  ;
118970: LD_ADDR_VAR 0 3
118974: PUSH
118975: LD_STRING 
118977: ST_TO_ADDR
// for i = 1 to normalCounter do
118978: LD_ADDR_VAR 0 8
118982: PUSH
118983: DOUBLE
118984: LD_INT 1
118986: DEC
118987: ST_TO_ADDR
118988: LD_EXP 149
118992: PUSH
118993: FOR_TO
118994: IFFALSE 119030
// begin if flags [ i ] then
118996: LD_VAR 0 4
119000: PUSH
119001: LD_VAR 0 8
119005: ARRAY
119006: IFFALSE 119028
// tmp := tmp & i & ; ;
119008: LD_ADDR_VAR 0 3
119012: PUSH
119013: LD_VAR 0 3
119017: PUSH
119018: LD_VAR 0 8
119022: STR
119023: PUSH
119024: LD_STRING ;
119026: STR
119027: ST_TO_ADDR
// end ;
119028: GO 118993
119030: POP
119031: POP
// for i = 1 to hardcoreCounter do
119032: LD_ADDR_VAR 0 8
119036: PUSH
119037: DOUBLE
119038: LD_INT 1
119040: DEC
119041: ST_TO_ADDR
119042: LD_EXP 150
119046: PUSH
119047: FOR_TO
119048: IFFALSE 119094
// begin if flags [ normalCounter + i ] then
119050: LD_VAR 0 4
119054: PUSH
119055: LD_EXP 149
119059: PUSH
119060: LD_VAR 0 8
119064: PLUS
119065: ARRAY
119066: IFFALSE 119092
// tmp := tmp & ( 100 + i ) & ; ;
119068: LD_ADDR_VAR 0 3
119072: PUSH
119073: LD_VAR 0 3
119077: PUSH
119078: LD_INT 100
119080: PUSH
119081: LD_VAR 0 8
119085: PLUS
119086: STR
119087: PUSH
119088: LD_STRING ;
119090: STR
119091: ST_TO_ADDR
// end ;
119092: GO 119047
119094: POP
119095: POP
// if tmp then
119096: LD_VAR 0 3
119100: IFFALSE 119112
// active := tmp ;
119102: LD_ADDR_VAR 0 7
119106: PUSH
119107: LD_VAR 0 3
119111: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
119112: LD_STRING getStreamItemsFromMission("
119114: PUSH
119115: LD_VAR 0 5
119119: STR
119120: PUSH
119121: LD_STRING ","
119123: STR
119124: PUSH
119125: LD_VAR 0 6
119129: STR
119130: PUSH
119131: LD_STRING ","
119133: STR
119134: PUSH
119135: LD_VAR 0 7
119139: STR
119140: PUSH
119141: LD_STRING ")
119143: STR
119144: PPUSH
119145: CALL_OW 559
// end else
119149: GO 119158
// ToLua ( getStreamItemsFromMission("","","") ) ;
119151: LD_STRING getStreamItemsFromMission("","","")
119153: PPUSH
119154: CALL_OW 559
// end ;
119158: LD_VAR 0 2
119162: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
119163: LD_EXP 148
119167: PUSH
119168: LD_EXP 153
119172: AND
119173: IFFALSE 119297
119175: GO 119177
119177: DISABLE
119178: LD_INT 0
119180: PPUSH
119181: PPUSH
// begin enable ;
119182: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
119183: LD_ADDR_VAR 0 2
119187: PUSH
119188: LD_INT 22
119190: PUSH
119191: LD_OWVAR 2
119195: PUSH
119196: EMPTY
119197: LIST
119198: LIST
119199: PUSH
119200: LD_INT 2
119202: PUSH
119203: LD_INT 34
119205: PUSH
119206: LD_INT 7
119208: PUSH
119209: EMPTY
119210: LIST
119211: LIST
119212: PUSH
119213: LD_INT 34
119215: PUSH
119216: LD_INT 45
119218: PUSH
119219: EMPTY
119220: LIST
119221: LIST
119222: PUSH
119223: LD_INT 34
119225: PUSH
119226: LD_INT 28
119228: PUSH
119229: EMPTY
119230: LIST
119231: LIST
119232: PUSH
119233: LD_INT 34
119235: PUSH
119236: LD_INT 47
119238: PUSH
119239: EMPTY
119240: LIST
119241: LIST
119242: PUSH
119243: EMPTY
119244: LIST
119245: LIST
119246: LIST
119247: LIST
119248: LIST
119249: PUSH
119250: EMPTY
119251: LIST
119252: LIST
119253: PPUSH
119254: CALL_OW 69
119258: ST_TO_ADDR
// if not tmp then
119259: LD_VAR 0 2
119263: NOT
119264: IFFALSE 119268
// exit ;
119266: GO 119297
// for i in tmp do
119268: LD_ADDR_VAR 0 1
119272: PUSH
119273: LD_VAR 0 2
119277: PUSH
119278: FOR_IN
119279: IFFALSE 119295
// begin SetLives ( i , 0 ) ;
119281: LD_VAR 0 1
119285: PPUSH
119286: LD_INT 0
119288: PPUSH
119289: CALL_OW 234
// end ;
119293: GO 119278
119295: POP
119296: POP
// end ;
119297: PPOPN 2
119299: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
119300: LD_EXP 148
119304: PUSH
119305: LD_EXP 154
119309: AND
119310: IFFALSE 119394
119312: GO 119314
119314: DISABLE
119315: LD_INT 0
119317: PPUSH
119318: PPUSH
// begin enable ;
119319: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
119320: LD_ADDR_VAR 0 2
119324: PUSH
119325: LD_INT 22
119327: PUSH
119328: LD_OWVAR 2
119332: PUSH
119333: EMPTY
119334: LIST
119335: LIST
119336: PUSH
119337: LD_INT 32
119339: PUSH
119340: LD_INT 3
119342: PUSH
119343: EMPTY
119344: LIST
119345: LIST
119346: PUSH
119347: EMPTY
119348: LIST
119349: LIST
119350: PPUSH
119351: CALL_OW 69
119355: ST_TO_ADDR
// if not tmp then
119356: LD_VAR 0 2
119360: NOT
119361: IFFALSE 119365
// exit ;
119363: GO 119394
// for i in tmp do
119365: LD_ADDR_VAR 0 1
119369: PUSH
119370: LD_VAR 0 2
119374: PUSH
119375: FOR_IN
119376: IFFALSE 119392
// begin SetLives ( i , 0 ) ;
119378: LD_VAR 0 1
119382: PPUSH
119383: LD_INT 0
119385: PPUSH
119386: CALL_OW 234
// end ;
119390: GO 119375
119392: POP
119393: POP
// end ;
119394: PPOPN 2
119396: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
119397: LD_EXP 148
119401: PUSH
119402: LD_EXP 151
119406: AND
119407: IFFALSE 119500
119409: GO 119411
119411: DISABLE
119412: LD_INT 0
119414: PPUSH
// begin enable ;
119415: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
119416: LD_ADDR_VAR 0 1
119420: PUSH
119421: LD_INT 22
119423: PUSH
119424: LD_OWVAR 2
119428: PUSH
119429: EMPTY
119430: LIST
119431: LIST
119432: PUSH
119433: LD_INT 2
119435: PUSH
119436: LD_INT 25
119438: PUSH
119439: LD_INT 5
119441: PUSH
119442: EMPTY
119443: LIST
119444: LIST
119445: PUSH
119446: LD_INT 25
119448: PUSH
119449: LD_INT 9
119451: PUSH
119452: EMPTY
119453: LIST
119454: LIST
119455: PUSH
119456: LD_INT 25
119458: PUSH
119459: LD_INT 8
119461: PUSH
119462: EMPTY
119463: LIST
119464: LIST
119465: PUSH
119466: EMPTY
119467: LIST
119468: LIST
119469: LIST
119470: LIST
119471: PUSH
119472: EMPTY
119473: LIST
119474: LIST
119475: PPUSH
119476: CALL_OW 69
119480: PUSH
119481: FOR_IN
119482: IFFALSE 119498
// begin SetClass ( i , 1 ) ;
119484: LD_VAR 0 1
119488: PPUSH
119489: LD_INT 1
119491: PPUSH
119492: CALL_OW 336
// end ;
119496: GO 119481
119498: POP
119499: POP
// end ;
119500: PPOPN 1
119502: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
119503: LD_EXP 148
119507: PUSH
119508: LD_EXP 152
119512: AND
119513: PUSH
119514: LD_OWVAR 65
119518: PUSH
119519: LD_INT 7
119521: LESS
119522: AND
119523: IFFALSE 119537
119525: GO 119527
119527: DISABLE
// begin enable ;
119528: ENABLE
// game_speed := 7 ;
119529: LD_ADDR_OWVAR 65
119533: PUSH
119534: LD_INT 7
119536: ST_TO_ADDR
// end ;
119537: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
119538: LD_EXP 148
119542: PUSH
119543: LD_EXP 155
119547: AND
119548: IFFALSE 119750
119550: GO 119552
119552: DISABLE
119553: LD_INT 0
119555: PPUSH
119556: PPUSH
119557: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
119558: LD_ADDR_VAR 0 3
119562: PUSH
119563: LD_INT 81
119565: PUSH
119566: LD_OWVAR 2
119570: PUSH
119571: EMPTY
119572: LIST
119573: LIST
119574: PUSH
119575: LD_INT 21
119577: PUSH
119578: LD_INT 1
119580: PUSH
119581: EMPTY
119582: LIST
119583: LIST
119584: PUSH
119585: EMPTY
119586: LIST
119587: LIST
119588: PPUSH
119589: CALL_OW 69
119593: ST_TO_ADDR
// if not tmp then
119594: LD_VAR 0 3
119598: NOT
119599: IFFALSE 119603
// exit ;
119601: GO 119750
// if tmp > 5 then
119603: LD_VAR 0 3
119607: PUSH
119608: LD_INT 5
119610: GREATER
119611: IFFALSE 119623
// k := 5 else
119613: LD_ADDR_VAR 0 2
119617: PUSH
119618: LD_INT 5
119620: ST_TO_ADDR
119621: GO 119633
// k := tmp ;
119623: LD_ADDR_VAR 0 2
119627: PUSH
119628: LD_VAR 0 3
119632: ST_TO_ADDR
// for i := 1 to k do
119633: LD_ADDR_VAR 0 1
119637: PUSH
119638: DOUBLE
119639: LD_INT 1
119641: DEC
119642: ST_TO_ADDR
119643: LD_VAR 0 2
119647: PUSH
119648: FOR_TO
119649: IFFALSE 119748
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
119651: LD_VAR 0 3
119655: PUSH
119656: LD_VAR 0 1
119660: ARRAY
119661: PPUSH
119662: LD_VAR 0 1
119666: PUSH
119667: LD_INT 4
119669: MOD
119670: PUSH
119671: LD_INT 1
119673: PLUS
119674: PPUSH
119675: CALL_OW 259
119679: PUSH
119680: LD_INT 10
119682: LESS
119683: IFFALSE 119746
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
119685: LD_VAR 0 3
119689: PUSH
119690: LD_VAR 0 1
119694: ARRAY
119695: PPUSH
119696: LD_VAR 0 1
119700: PUSH
119701: LD_INT 4
119703: MOD
119704: PUSH
119705: LD_INT 1
119707: PLUS
119708: PPUSH
119709: LD_VAR 0 3
119713: PUSH
119714: LD_VAR 0 1
119718: ARRAY
119719: PPUSH
119720: LD_VAR 0 1
119724: PUSH
119725: LD_INT 4
119727: MOD
119728: PUSH
119729: LD_INT 1
119731: PLUS
119732: PPUSH
119733: CALL_OW 259
119737: PUSH
119738: LD_INT 1
119740: PLUS
119741: PPUSH
119742: CALL_OW 237
119746: GO 119648
119748: POP
119749: POP
// end ;
119750: PPOPN 3
119752: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
119753: LD_EXP 148
119757: PUSH
119758: LD_EXP 156
119762: AND
119763: IFFALSE 119783
119765: GO 119767
119767: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
119768: LD_INT 4
119770: PPUSH
119771: LD_OWVAR 2
119775: PPUSH
119776: LD_INT 0
119778: PPUSH
119779: CALL_OW 324
119783: END
// every 0 0$1 trigger StreamModeActive and sShovel do
119784: LD_EXP 148
119788: PUSH
119789: LD_EXP 185
119793: AND
119794: IFFALSE 119814
119796: GO 119798
119798: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
119799: LD_INT 19
119801: PPUSH
119802: LD_OWVAR 2
119806: PPUSH
119807: LD_INT 0
119809: PPUSH
119810: CALL_OW 324
119814: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
119815: LD_EXP 148
119819: PUSH
119820: LD_EXP 157
119824: AND
119825: IFFALSE 119927
119827: GO 119829
119829: DISABLE
119830: LD_INT 0
119832: PPUSH
119833: PPUSH
// begin enable ;
119834: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
119835: LD_ADDR_VAR 0 2
119839: PUSH
119840: LD_INT 22
119842: PUSH
119843: LD_OWVAR 2
119847: PUSH
119848: EMPTY
119849: LIST
119850: LIST
119851: PUSH
119852: LD_INT 2
119854: PUSH
119855: LD_INT 34
119857: PUSH
119858: LD_INT 11
119860: PUSH
119861: EMPTY
119862: LIST
119863: LIST
119864: PUSH
119865: LD_INT 34
119867: PUSH
119868: LD_INT 30
119870: PUSH
119871: EMPTY
119872: LIST
119873: LIST
119874: PUSH
119875: EMPTY
119876: LIST
119877: LIST
119878: LIST
119879: PUSH
119880: EMPTY
119881: LIST
119882: LIST
119883: PPUSH
119884: CALL_OW 69
119888: ST_TO_ADDR
// if not tmp then
119889: LD_VAR 0 2
119893: NOT
119894: IFFALSE 119898
// exit ;
119896: GO 119927
// for i in tmp do
119898: LD_ADDR_VAR 0 1
119902: PUSH
119903: LD_VAR 0 2
119907: PUSH
119908: FOR_IN
119909: IFFALSE 119925
// begin SetLives ( i , 0 ) ;
119911: LD_VAR 0 1
119915: PPUSH
119916: LD_INT 0
119918: PPUSH
119919: CALL_OW 234
// end ;
119923: GO 119908
119925: POP
119926: POP
// end ;
119927: PPOPN 2
119929: END
// every 0 0$1 trigger StreamModeActive and sBunker do
119930: LD_EXP 148
119934: PUSH
119935: LD_EXP 158
119939: AND
119940: IFFALSE 119960
119942: GO 119944
119944: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
119945: LD_INT 32
119947: PPUSH
119948: LD_OWVAR 2
119952: PPUSH
119953: LD_INT 0
119955: PPUSH
119956: CALL_OW 324
119960: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
119961: LD_EXP 148
119965: PUSH
119966: LD_EXP 159
119970: AND
119971: IFFALSE 120152
119973: GO 119975
119975: DISABLE
119976: LD_INT 0
119978: PPUSH
119979: PPUSH
119980: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
119981: LD_ADDR_VAR 0 2
119985: PUSH
119986: LD_INT 22
119988: PUSH
119989: LD_OWVAR 2
119993: PUSH
119994: EMPTY
119995: LIST
119996: LIST
119997: PUSH
119998: LD_INT 33
120000: PUSH
120001: LD_INT 3
120003: PUSH
120004: EMPTY
120005: LIST
120006: LIST
120007: PUSH
120008: EMPTY
120009: LIST
120010: LIST
120011: PPUSH
120012: CALL_OW 69
120016: ST_TO_ADDR
// if not tmp then
120017: LD_VAR 0 2
120021: NOT
120022: IFFALSE 120026
// exit ;
120024: GO 120152
// side := 0 ;
120026: LD_ADDR_VAR 0 3
120030: PUSH
120031: LD_INT 0
120033: ST_TO_ADDR
// for i := 1 to 8 do
120034: LD_ADDR_VAR 0 1
120038: PUSH
120039: DOUBLE
120040: LD_INT 1
120042: DEC
120043: ST_TO_ADDR
120044: LD_INT 8
120046: PUSH
120047: FOR_TO
120048: IFFALSE 120096
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
120050: LD_OWVAR 2
120054: PUSH
120055: LD_VAR 0 1
120059: NONEQUAL
120060: PUSH
120061: LD_OWVAR 2
120065: PPUSH
120066: LD_VAR 0 1
120070: PPUSH
120071: CALL_OW 81
120075: PUSH
120076: LD_INT 2
120078: EQUAL
120079: AND
120080: IFFALSE 120094
// begin side := i ;
120082: LD_ADDR_VAR 0 3
120086: PUSH
120087: LD_VAR 0 1
120091: ST_TO_ADDR
// break ;
120092: GO 120096
// end ;
120094: GO 120047
120096: POP
120097: POP
// if not side then
120098: LD_VAR 0 3
120102: NOT
120103: IFFALSE 120107
// exit ;
120105: GO 120152
// for i := 1 to tmp do
120107: LD_ADDR_VAR 0 1
120111: PUSH
120112: DOUBLE
120113: LD_INT 1
120115: DEC
120116: ST_TO_ADDR
120117: LD_VAR 0 2
120121: PUSH
120122: FOR_TO
120123: IFFALSE 120150
// if Prob ( 60 ) then
120125: LD_INT 60
120127: PPUSH
120128: CALL_OW 13
120132: IFFALSE 120148
// SetSide ( i , side ) ;
120134: LD_VAR 0 1
120138: PPUSH
120139: LD_VAR 0 3
120143: PPUSH
120144: CALL_OW 235
120148: GO 120122
120150: POP
120151: POP
// end ;
120152: PPOPN 3
120154: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
120155: LD_EXP 148
120159: PUSH
120160: LD_EXP 161
120164: AND
120165: IFFALSE 120284
120167: GO 120169
120169: DISABLE
120170: LD_INT 0
120172: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
120173: LD_ADDR_VAR 0 1
120177: PUSH
120178: LD_INT 22
120180: PUSH
120181: LD_OWVAR 2
120185: PUSH
120186: EMPTY
120187: LIST
120188: LIST
120189: PUSH
120190: LD_INT 21
120192: PUSH
120193: LD_INT 1
120195: PUSH
120196: EMPTY
120197: LIST
120198: LIST
120199: PUSH
120200: LD_INT 3
120202: PUSH
120203: LD_INT 23
120205: PUSH
120206: LD_INT 0
120208: PUSH
120209: EMPTY
120210: LIST
120211: LIST
120212: PUSH
120213: EMPTY
120214: LIST
120215: LIST
120216: PUSH
120217: EMPTY
120218: LIST
120219: LIST
120220: LIST
120221: PPUSH
120222: CALL_OW 69
120226: PUSH
120227: FOR_IN
120228: IFFALSE 120282
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
120230: LD_VAR 0 1
120234: PPUSH
120235: CALL_OW 257
120239: PUSH
120240: LD_INT 1
120242: PUSH
120243: LD_INT 2
120245: PUSH
120246: LD_INT 3
120248: PUSH
120249: LD_INT 4
120251: PUSH
120252: EMPTY
120253: LIST
120254: LIST
120255: LIST
120256: LIST
120257: IN
120258: IFFALSE 120280
// SetClass ( un , rand ( 1 , 4 ) ) ;
120260: LD_VAR 0 1
120264: PPUSH
120265: LD_INT 1
120267: PPUSH
120268: LD_INT 4
120270: PPUSH
120271: CALL_OW 12
120275: PPUSH
120276: CALL_OW 336
120280: GO 120227
120282: POP
120283: POP
// end ;
120284: PPOPN 1
120286: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
120287: LD_EXP 148
120291: PUSH
120292: LD_EXP 160
120296: AND
120297: IFFALSE 120376
120299: GO 120301
120301: DISABLE
120302: LD_INT 0
120304: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
120305: LD_ADDR_VAR 0 1
120309: PUSH
120310: LD_INT 22
120312: PUSH
120313: LD_OWVAR 2
120317: PUSH
120318: EMPTY
120319: LIST
120320: LIST
120321: PUSH
120322: LD_INT 21
120324: PUSH
120325: LD_INT 3
120327: PUSH
120328: EMPTY
120329: LIST
120330: LIST
120331: PUSH
120332: EMPTY
120333: LIST
120334: LIST
120335: PPUSH
120336: CALL_OW 69
120340: ST_TO_ADDR
// if not tmp then
120341: LD_VAR 0 1
120345: NOT
120346: IFFALSE 120350
// exit ;
120348: GO 120376
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
120350: LD_VAR 0 1
120354: PUSH
120355: LD_INT 1
120357: PPUSH
120358: LD_VAR 0 1
120362: PPUSH
120363: CALL_OW 12
120367: ARRAY
120368: PPUSH
120369: LD_INT 100
120371: PPUSH
120372: CALL_OW 234
// end ;
120376: PPOPN 1
120378: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
120379: LD_EXP 148
120383: PUSH
120384: LD_EXP 162
120388: AND
120389: IFFALSE 120487
120391: GO 120393
120393: DISABLE
120394: LD_INT 0
120396: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
120397: LD_ADDR_VAR 0 1
120401: PUSH
120402: LD_INT 22
120404: PUSH
120405: LD_OWVAR 2
120409: PUSH
120410: EMPTY
120411: LIST
120412: LIST
120413: PUSH
120414: LD_INT 21
120416: PUSH
120417: LD_INT 1
120419: PUSH
120420: EMPTY
120421: LIST
120422: LIST
120423: PUSH
120424: EMPTY
120425: LIST
120426: LIST
120427: PPUSH
120428: CALL_OW 69
120432: ST_TO_ADDR
// if not tmp then
120433: LD_VAR 0 1
120437: NOT
120438: IFFALSE 120442
// exit ;
120440: GO 120487
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
120442: LD_VAR 0 1
120446: PUSH
120447: LD_INT 1
120449: PPUSH
120450: LD_VAR 0 1
120454: PPUSH
120455: CALL_OW 12
120459: ARRAY
120460: PPUSH
120461: LD_INT 1
120463: PPUSH
120464: LD_INT 4
120466: PPUSH
120467: CALL_OW 12
120471: PPUSH
120472: LD_INT 3000
120474: PPUSH
120475: LD_INT 9000
120477: PPUSH
120478: CALL_OW 12
120482: PPUSH
120483: CALL_OW 492
// end ;
120487: PPOPN 1
120489: END
// every 0 0$1 trigger StreamModeActive and sDepot do
120490: LD_EXP 148
120494: PUSH
120495: LD_EXP 163
120499: AND
120500: IFFALSE 120520
120502: GO 120504
120504: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
120505: LD_INT 1
120507: PPUSH
120508: LD_OWVAR 2
120512: PPUSH
120513: LD_INT 0
120515: PPUSH
120516: CALL_OW 324
120520: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
120521: LD_EXP 148
120525: PUSH
120526: LD_EXP 164
120530: AND
120531: IFFALSE 120614
120533: GO 120535
120535: DISABLE
120536: LD_INT 0
120538: PPUSH
120539: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
120540: LD_ADDR_VAR 0 2
120544: PUSH
120545: LD_INT 22
120547: PUSH
120548: LD_OWVAR 2
120552: PUSH
120553: EMPTY
120554: LIST
120555: LIST
120556: PUSH
120557: LD_INT 21
120559: PUSH
120560: LD_INT 3
120562: PUSH
120563: EMPTY
120564: LIST
120565: LIST
120566: PUSH
120567: EMPTY
120568: LIST
120569: LIST
120570: PPUSH
120571: CALL_OW 69
120575: ST_TO_ADDR
// if not tmp then
120576: LD_VAR 0 2
120580: NOT
120581: IFFALSE 120585
// exit ;
120583: GO 120614
// for i in tmp do
120585: LD_ADDR_VAR 0 1
120589: PUSH
120590: LD_VAR 0 2
120594: PUSH
120595: FOR_IN
120596: IFFALSE 120612
// SetBLevel ( i , 10 ) ;
120598: LD_VAR 0 1
120602: PPUSH
120603: LD_INT 10
120605: PPUSH
120606: CALL_OW 241
120610: GO 120595
120612: POP
120613: POP
// end ;
120614: PPOPN 2
120616: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
120617: LD_EXP 148
120621: PUSH
120622: LD_EXP 165
120626: AND
120627: IFFALSE 120738
120629: GO 120631
120631: DISABLE
120632: LD_INT 0
120634: PPUSH
120635: PPUSH
120636: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
120637: LD_ADDR_VAR 0 3
120641: PUSH
120642: LD_INT 22
120644: PUSH
120645: LD_OWVAR 2
120649: PUSH
120650: EMPTY
120651: LIST
120652: LIST
120653: PUSH
120654: LD_INT 25
120656: PUSH
120657: LD_INT 1
120659: PUSH
120660: EMPTY
120661: LIST
120662: LIST
120663: PUSH
120664: EMPTY
120665: LIST
120666: LIST
120667: PPUSH
120668: CALL_OW 69
120672: ST_TO_ADDR
// if not tmp then
120673: LD_VAR 0 3
120677: NOT
120678: IFFALSE 120682
// exit ;
120680: GO 120738
// un := tmp [ rand ( 1 , tmp ) ] ;
120682: LD_ADDR_VAR 0 2
120686: PUSH
120687: LD_VAR 0 3
120691: PUSH
120692: LD_INT 1
120694: PPUSH
120695: LD_VAR 0 3
120699: PPUSH
120700: CALL_OW 12
120704: ARRAY
120705: ST_TO_ADDR
// if Crawls ( un ) then
120706: LD_VAR 0 2
120710: PPUSH
120711: CALL_OW 318
120715: IFFALSE 120726
// ComWalk ( un ) ;
120717: LD_VAR 0 2
120721: PPUSH
120722: CALL_OW 138
// SetClass ( un , class_sniper ) ;
120726: LD_VAR 0 2
120730: PPUSH
120731: LD_INT 5
120733: PPUSH
120734: CALL_OW 336
// end ;
120738: PPOPN 3
120740: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
120741: LD_EXP 148
120745: PUSH
120746: LD_EXP 166
120750: AND
120751: PUSH
120752: LD_OWVAR 67
120756: PUSH
120757: LD_INT 4
120759: LESS
120760: AND
120761: IFFALSE 120780
120763: GO 120765
120765: DISABLE
// begin Difficulty := Difficulty + 1 ;
120766: LD_ADDR_OWVAR 67
120770: PUSH
120771: LD_OWVAR 67
120775: PUSH
120776: LD_INT 1
120778: PLUS
120779: ST_TO_ADDR
// end ;
120780: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
120781: LD_EXP 148
120785: PUSH
120786: LD_EXP 167
120790: AND
120791: IFFALSE 120894
120793: GO 120795
120795: DISABLE
120796: LD_INT 0
120798: PPUSH
// begin for i := 1 to 5 do
120799: LD_ADDR_VAR 0 1
120803: PUSH
120804: DOUBLE
120805: LD_INT 1
120807: DEC
120808: ST_TO_ADDR
120809: LD_INT 5
120811: PUSH
120812: FOR_TO
120813: IFFALSE 120892
// begin uc_nation := nation_nature ;
120815: LD_ADDR_OWVAR 21
120819: PUSH
120820: LD_INT 0
120822: ST_TO_ADDR
// uc_side := 0 ;
120823: LD_ADDR_OWVAR 20
120827: PUSH
120828: LD_INT 0
120830: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
120831: LD_ADDR_OWVAR 29
120835: PUSH
120836: LD_INT 12
120838: PUSH
120839: LD_INT 12
120841: PUSH
120842: EMPTY
120843: LIST
120844: LIST
120845: ST_TO_ADDR
// hc_agressivity := 20 ;
120846: LD_ADDR_OWVAR 35
120850: PUSH
120851: LD_INT 20
120853: ST_TO_ADDR
// hc_class := class_tiger ;
120854: LD_ADDR_OWVAR 28
120858: PUSH
120859: LD_INT 14
120861: ST_TO_ADDR
// hc_gallery :=  ;
120862: LD_ADDR_OWVAR 33
120866: PUSH
120867: LD_STRING 
120869: ST_TO_ADDR
// hc_name :=  ;
120870: LD_ADDR_OWVAR 26
120874: PUSH
120875: LD_STRING 
120877: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
120878: CALL_OW 44
120882: PPUSH
120883: LD_INT 0
120885: PPUSH
120886: CALL_OW 51
// end ;
120890: GO 120812
120892: POP
120893: POP
// end ;
120894: PPOPN 1
120896: END
// every 0 0$1 trigger StreamModeActive and sBomb do
120897: LD_EXP 148
120901: PUSH
120902: LD_EXP 168
120906: AND
120907: IFFALSE 120916
120909: GO 120911
120911: DISABLE
// StreamSibBomb ;
120912: CALL 120917 0 0
120916: END
// export function StreamSibBomb ; var i , x , y ; begin
120917: LD_INT 0
120919: PPUSH
120920: PPUSH
120921: PPUSH
120922: PPUSH
// result := false ;
120923: LD_ADDR_VAR 0 1
120927: PUSH
120928: LD_INT 0
120930: ST_TO_ADDR
// for i := 1 to 16 do
120931: LD_ADDR_VAR 0 2
120935: PUSH
120936: DOUBLE
120937: LD_INT 1
120939: DEC
120940: ST_TO_ADDR
120941: LD_INT 16
120943: PUSH
120944: FOR_TO
120945: IFFALSE 121144
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
120947: LD_ADDR_VAR 0 3
120951: PUSH
120952: LD_INT 10
120954: PUSH
120955: LD_INT 20
120957: PUSH
120958: LD_INT 30
120960: PUSH
120961: LD_INT 40
120963: PUSH
120964: LD_INT 50
120966: PUSH
120967: LD_INT 60
120969: PUSH
120970: LD_INT 70
120972: PUSH
120973: LD_INT 80
120975: PUSH
120976: LD_INT 90
120978: PUSH
120979: LD_INT 100
120981: PUSH
120982: LD_INT 110
120984: PUSH
120985: LD_INT 120
120987: PUSH
120988: LD_INT 130
120990: PUSH
120991: LD_INT 140
120993: PUSH
120994: LD_INT 150
120996: PUSH
120997: EMPTY
120998: LIST
120999: LIST
121000: LIST
121001: LIST
121002: LIST
121003: LIST
121004: LIST
121005: LIST
121006: LIST
121007: LIST
121008: LIST
121009: LIST
121010: LIST
121011: LIST
121012: LIST
121013: PUSH
121014: LD_INT 1
121016: PPUSH
121017: LD_INT 15
121019: PPUSH
121020: CALL_OW 12
121024: ARRAY
121025: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
121026: LD_ADDR_VAR 0 4
121030: PUSH
121031: LD_INT 10
121033: PUSH
121034: LD_INT 20
121036: PUSH
121037: LD_INT 30
121039: PUSH
121040: LD_INT 40
121042: PUSH
121043: LD_INT 50
121045: PUSH
121046: LD_INT 60
121048: PUSH
121049: LD_INT 70
121051: PUSH
121052: LD_INT 80
121054: PUSH
121055: LD_INT 90
121057: PUSH
121058: LD_INT 100
121060: PUSH
121061: LD_INT 110
121063: PUSH
121064: LD_INT 120
121066: PUSH
121067: LD_INT 130
121069: PUSH
121070: LD_INT 140
121072: PUSH
121073: LD_INT 150
121075: PUSH
121076: EMPTY
121077: LIST
121078: LIST
121079: LIST
121080: LIST
121081: LIST
121082: LIST
121083: LIST
121084: LIST
121085: LIST
121086: LIST
121087: LIST
121088: LIST
121089: LIST
121090: LIST
121091: LIST
121092: PUSH
121093: LD_INT 1
121095: PPUSH
121096: LD_INT 15
121098: PPUSH
121099: CALL_OW 12
121103: ARRAY
121104: ST_TO_ADDR
// if ValidHex ( x , y ) then
121105: LD_VAR 0 3
121109: PPUSH
121110: LD_VAR 0 4
121114: PPUSH
121115: CALL_OW 488
121119: IFFALSE 121142
// begin result := [ x , y ] ;
121121: LD_ADDR_VAR 0 1
121125: PUSH
121126: LD_VAR 0 3
121130: PUSH
121131: LD_VAR 0 4
121135: PUSH
121136: EMPTY
121137: LIST
121138: LIST
121139: ST_TO_ADDR
// break ;
121140: GO 121144
// end ; end ;
121142: GO 120944
121144: POP
121145: POP
// if result then
121146: LD_VAR 0 1
121150: IFFALSE 121210
// begin ToLua ( playSibBomb() ) ;
121152: LD_STRING playSibBomb()
121154: PPUSH
121155: CALL_OW 559
// wait ( 0 0$14 ) ;
121159: LD_INT 490
121161: PPUSH
121162: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
121166: LD_VAR 0 1
121170: PUSH
121171: LD_INT 1
121173: ARRAY
121174: PPUSH
121175: LD_VAR 0 1
121179: PUSH
121180: LD_INT 2
121182: ARRAY
121183: PPUSH
121184: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
121188: LD_VAR 0 1
121192: PUSH
121193: LD_INT 1
121195: ARRAY
121196: PPUSH
121197: LD_VAR 0 1
121201: PUSH
121202: LD_INT 2
121204: ARRAY
121205: PPUSH
121206: CALL_OW 429
// end ; end ;
121210: LD_VAR 0 1
121214: RET
// every 0 0$1 trigger StreamModeActive and sReset do
121215: LD_EXP 148
121219: PUSH
121220: LD_EXP 170
121224: AND
121225: IFFALSE 121237
121227: GO 121229
121229: DISABLE
// YouLost (  ) ;
121230: LD_STRING 
121232: PPUSH
121233: CALL_OW 104
121237: END
// every 0 0$1 trigger StreamModeActive and sFog do
121238: LD_EXP 148
121242: PUSH
121243: LD_EXP 169
121247: AND
121248: IFFALSE 121262
121250: GO 121252
121252: DISABLE
// FogOff ( your_side ) ;
121253: LD_OWVAR 2
121257: PPUSH
121258: CALL_OW 344
121262: END
// every 0 0$1 trigger StreamModeActive and sSun do
121263: LD_EXP 148
121267: PUSH
121268: LD_EXP 171
121272: AND
121273: IFFALSE 121301
121275: GO 121277
121277: DISABLE
// begin solar_recharge_percent := 0 ;
121278: LD_ADDR_OWVAR 79
121282: PUSH
121283: LD_INT 0
121285: ST_TO_ADDR
// wait ( 5 5$00 ) ;
121286: LD_INT 10500
121288: PPUSH
121289: CALL_OW 67
// solar_recharge_percent := 100 ;
121293: LD_ADDR_OWVAR 79
121297: PUSH
121298: LD_INT 100
121300: ST_TO_ADDR
// end ;
121301: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
121302: LD_EXP 148
121306: PUSH
121307: LD_EXP 172
121311: AND
121312: IFFALSE 121551
121314: GO 121316
121316: DISABLE
121317: LD_INT 0
121319: PPUSH
121320: PPUSH
121321: PPUSH
// begin tmp := [ ] ;
121322: LD_ADDR_VAR 0 3
121326: PUSH
121327: EMPTY
121328: ST_TO_ADDR
// for i := 1 to 6 do
121329: LD_ADDR_VAR 0 1
121333: PUSH
121334: DOUBLE
121335: LD_INT 1
121337: DEC
121338: ST_TO_ADDR
121339: LD_INT 6
121341: PUSH
121342: FOR_TO
121343: IFFALSE 121448
// begin uc_nation := nation_nature ;
121345: LD_ADDR_OWVAR 21
121349: PUSH
121350: LD_INT 0
121352: ST_TO_ADDR
// uc_side := 0 ;
121353: LD_ADDR_OWVAR 20
121357: PUSH
121358: LD_INT 0
121360: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
121361: LD_ADDR_OWVAR 29
121365: PUSH
121366: LD_INT 12
121368: PUSH
121369: LD_INT 12
121371: PUSH
121372: EMPTY
121373: LIST
121374: LIST
121375: ST_TO_ADDR
// hc_agressivity := 20 ;
121376: LD_ADDR_OWVAR 35
121380: PUSH
121381: LD_INT 20
121383: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
121384: LD_ADDR_OWVAR 28
121388: PUSH
121389: LD_INT 17
121391: ST_TO_ADDR
// hc_gallery :=  ;
121392: LD_ADDR_OWVAR 33
121396: PUSH
121397: LD_STRING 
121399: ST_TO_ADDR
// hc_name :=  ;
121400: LD_ADDR_OWVAR 26
121404: PUSH
121405: LD_STRING 
121407: ST_TO_ADDR
// un := CreateHuman ;
121408: LD_ADDR_VAR 0 2
121412: PUSH
121413: CALL_OW 44
121417: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
121418: LD_VAR 0 2
121422: PPUSH
121423: LD_INT 1
121425: PPUSH
121426: CALL_OW 51
// tmp := tmp ^ un ;
121430: LD_ADDR_VAR 0 3
121434: PUSH
121435: LD_VAR 0 3
121439: PUSH
121440: LD_VAR 0 2
121444: ADD
121445: ST_TO_ADDR
// end ;
121446: GO 121342
121448: POP
121449: POP
// repeat wait ( 0 0$1 ) ;
121450: LD_INT 35
121452: PPUSH
121453: CALL_OW 67
// for un in tmp do
121457: LD_ADDR_VAR 0 2
121461: PUSH
121462: LD_VAR 0 3
121466: PUSH
121467: FOR_IN
121468: IFFALSE 121542
// begin if IsDead ( un ) then
121470: LD_VAR 0 2
121474: PPUSH
121475: CALL_OW 301
121479: IFFALSE 121499
// begin tmp := tmp diff un ;
121481: LD_ADDR_VAR 0 3
121485: PUSH
121486: LD_VAR 0 3
121490: PUSH
121491: LD_VAR 0 2
121495: DIFF
121496: ST_TO_ADDR
// continue ;
121497: GO 121467
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
121499: LD_VAR 0 2
121503: PPUSH
121504: LD_INT 3
121506: PUSH
121507: LD_INT 22
121509: PUSH
121510: LD_INT 0
121512: PUSH
121513: EMPTY
121514: LIST
121515: LIST
121516: PUSH
121517: EMPTY
121518: LIST
121519: LIST
121520: PPUSH
121521: CALL_OW 69
121525: PPUSH
121526: LD_VAR 0 2
121530: PPUSH
121531: CALL_OW 74
121535: PPUSH
121536: CALL_OW 115
// end ;
121540: GO 121467
121542: POP
121543: POP
// until not tmp ;
121544: LD_VAR 0 3
121548: NOT
121549: IFFALSE 121450
// end ;
121551: PPOPN 3
121553: END
// every 0 0$1 trigger StreamModeActive and sTroll do
121554: LD_EXP 148
121558: PUSH
121559: LD_EXP 173
121563: AND
121564: IFFALSE 121618
121566: GO 121568
121568: DISABLE
// begin ToLua ( displayTroll(); ) ;
121569: LD_STRING displayTroll();
121571: PPUSH
121572: CALL_OW 559
// wait ( 3 3$00 ) ;
121576: LD_INT 6300
121578: PPUSH
121579: CALL_OW 67
// ToLua ( hideTroll(); ) ;
121583: LD_STRING hideTroll();
121585: PPUSH
121586: CALL_OW 559
// wait ( 1 1$00 ) ;
121590: LD_INT 2100
121592: PPUSH
121593: CALL_OW 67
// ToLua ( displayTroll(); ) ;
121597: LD_STRING displayTroll();
121599: PPUSH
121600: CALL_OW 559
// wait ( 1 1$00 ) ;
121604: LD_INT 2100
121606: PPUSH
121607: CALL_OW 67
// ToLua ( hideTroll(); ) ;
121611: LD_STRING hideTroll();
121613: PPUSH
121614: CALL_OW 559
// end ;
121618: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
121619: LD_EXP 148
121623: PUSH
121624: LD_EXP 174
121628: AND
121629: IFFALSE 121692
121631: GO 121633
121633: DISABLE
121634: LD_INT 0
121636: PPUSH
// begin p := 0 ;
121637: LD_ADDR_VAR 0 1
121641: PUSH
121642: LD_INT 0
121644: ST_TO_ADDR
// repeat game_speed := 1 ;
121645: LD_ADDR_OWVAR 65
121649: PUSH
121650: LD_INT 1
121652: ST_TO_ADDR
// wait ( 0 0$1 ) ;
121653: LD_INT 35
121655: PPUSH
121656: CALL_OW 67
// p := p + 1 ;
121660: LD_ADDR_VAR 0 1
121664: PUSH
121665: LD_VAR 0 1
121669: PUSH
121670: LD_INT 1
121672: PLUS
121673: ST_TO_ADDR
// until p >= 60 ;
121674: LD_VAR 0 1
121678: PUSH
121679: LD_INT 60
121681: GREATEREQUAL
121682: IFFALSE 121645
// game_speed := 4 ;
121684: LD_ADDR_OWVAR 65
121688: PUSH
121689: LD_INT 4
121691: ST_TO_ADDR
// end ;
121692: PPOPN 1
121694: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
121695: LD_EXP 148
121699: PUSH
121700: LD_EXP 175
121704: AND
121705: IFFALSE 121851
121707: GO 121709
121709: DISABLE
121710: LD_INT 0
121712: PPUSH
121713: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
121714: LD_ADDR_VAR 0 1
121718: PUSH
121719: LD_INT 22
121721: PUSH
121722: LD_OWVAR 2
121726: PUSH
121727: EMPTY
121728: LIST
121729: LIST
121730: PUSH
121731: LD_INT 2
121733: PUSH
121734: LD_INT 30
121736: PUSH
121737: LD_INT 0
121739: PUSH
121740: EMPTY
121741: LIST
121742: LIST
121743: PUSH
121744: LD_INT 30
121746: PUSH
121747: LD_INT 1
121749: PUSH
121750: EMPTY
121751: LIST
121752: LIST
121753: PUSH
121754: EMPTY
121755: LIST
121756: LIST
121757: LIST
121758: PUSH
121759: EMPTY
121760: LIST
121761: LIST
121762: PPUSH
121763: CALL_OW 69
121767: ST_TO_ADDR
// if not depot then
121768: LD_VAR 0 1
121772: NOT
121773: IFFALSE 121777
// exit ;
121775: GO 121851
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
121777: LD_ADDR_VAR 0 2
121781: PUSH
121782: LD_VAR 0 1
121786: PUSH
121787: LD_INT 1
121789: PPUSH
121790: LD_VAR 0 1
121794: PPUSH
121795: CALL_OW 12
121799: ARRAY
121800: PPUSH
121801: CALL_OW 274
121805: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
121806: LD_VAR 0 2
121810: PPUSH
121811: LD_INT 1
121813: PPUSH
121814: LD_INT 0
121816: PPUSH
121817: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
121821: LD_VAR 0 2
121825: PPUSH
121826: LD_INT 2
121828: PPUSH
121829: LD_INT 0
121831: PPUSH
121832: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
121836: LD_VAR 0 2
121840: PPUSH
121841: LD_INT 3
121843: PPUSH
121844: LD_INT 0
121846: PPUSH
121847: CALL_OW 277
// end ;
121851: PPOPN 2
121853: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
121854: LD_EXP 148
121858: PUSH
121859: LD_EXP 176
121863: AND
121864: IFFALSE 121961
121866: GO 121868
121868: DISABLE
121869: LD_INT 0
121871: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
121872: LD_ADDR_VAR 0 1
121876: PUSH
121877: LD_INT 22
121879: PUSH
121880: LD_OWVAR 2
121884: PUSH
121885: EMPTY
121886: LIST
121887: LIST
121888: PUSH
121889: LD_INT 21
121891: PUSH
121892: LD_INT 1
121894: PUSH
121895: EMPTY
121896: LIST
121897: LIST
121898: PUSH
121899: LD_INT 3
121901: PUSH
121902: LD_INT 23
121904: PUSH
121905: LD_INT 0
121907: PUSH
121908: EMPTY
121909: LIST
121910: LIST
121911: PUSH
121912: EMPTY
121913: LIST
121914: LIST
121915: PUSH
121916: EMPTY
121917: LIST
121918: LIST
121919: LIST
121920: PPUSH
121921: CALL_OW 69
121925: ST_TO_ADDR
// if not tmp then
121926: LD_VAR 0 1
121930: NOT
121931: IFFALSE 121935
// exit ;
121933: GO 121961
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
121935: LD_VAR 0 1
121939: PUSH
121940: LD_INT 1
121942: PPUSH
121943: LD_VAR 0 1
121947: PPUSH
121948: CALL_OW 12
121952: ARRAY
121953: PPUSH
121954: LD_INT 200
121956: PPUSH
121957: CALL_OW 234
// end ;
121961: PPOPN 1
121963: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
121964: LD_EXP 148
121968: PUSH
121969: LD_EXP 177
121973: AND
121974: IFFALSE 122053
121976: GO 121978
121978: DISABLE
121979: LD_INT 0
121981: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
121982: LD_ADDR_VAR 0 1
121986: PUSH
121987: LD_INT 22
121989: PUSH
121990: LD_OWVAR 2
121994: PUSH
121995: EMPTY
121996: LIST
121997: LIST
121998: PUSH
121999: LD_INT 21
122001: PUSH
122002: LD_INT 2
122004: PUSH
122005: EMPTY
122006: LIST
122007: LIST
122008: PUSH
122009: EMPTY
122010: LIST
122011: LIST
122012: PPUSH
122013: CALL_OW 69
122017: ST_TO_ADDR
// if not tmp then
122018: LD_VAR 0 1
122022: NOT
122023: IFFALSE 122027
// exit ;
122025: GO 122053
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
122027: LD_VAR 0 1
122031: PUSH
122032: LD_INT 1
122034: PPUSH
122035: LD_VAR 0 1
122039: PPUSH
122040: CALL_OW 12
122044: ARRAY
122045: PPUSH
122046: LD_INT 60
122048: PPUSH
122049: CALL_OW 234
// end ;
122053: PPOPN 1
122055: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
122056: LD_EXP 148
122060: PUSH
122061: LD_EXP 178
122065: AND
122066: IFFALSE 122165
122068: GO 122070
122070: DISABLE
122071: LD_INT 0
122073: PPUSH
122074: PPUSH
// begin enable ;
122075: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
122076: LD_ADDR_VAR 0 1
122080: PUSH
122081: LD_INT 22
122083: PUSH
122084: LD_OWVAR 2
122088: PUSH
122089: EMPTY
122090: LIST
122091: LIST
122092: PUSH
122093: LD_INT 61
122095: PUSH
122096: EMPTY
122097: LIST
122098: PUSH
122099: LD_INT 33
122101: PUSH
122102: LD_INT 2
122104: PUSH
122105: EMPTY
122106: LIST
122107: LIST
122108: PUSH
122109: EMPTY
122110: LIST
122111: LIST
122112: LIST
122113: PPUSH
122114: CALL_OW 69
122118: ST_TO_ADDR
// if not tmp then
122119: LD_VAR 0 1
122123: NOT
122124: IFFALSE 122128
// exit ;
122126: GO 122165
// for i in tmp do
122128: LD_ADDR_VAR 0 2
122132: PUSH
122133: LD_VAR 0 1
122137: PUSH
122138: FOR_IN
122139: IFFALSE 122163
// if IsControledBy ( i ) then
122141: LD_VAR 0 2
122145: PPUSH
122146: CALL_OW 312
122150: IFFALSE 122161
// ComUnlink ( i ) ;
122152: LD_VAR 0 2
122156: PPUSH
122157: CALL_OW 136
122161: GO 122138
122163: POP
122164: POP
// end ;
122165: PPOPN 2
122167: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
122168: LD_EXP 148
122172: PUSH
122173: LD_EXP 179
122177: AND
122178: IFFALSE 122318
122180: GO 122182
122182: DISABLE
122183: LD_INT 0
122185: PPUSH
122186: PPUSH
// begin ToLua ( displayPowell(); ) ;
122187: LD_STRING displayPowell();
122189: PPUSH
122190: CALL_OW 559
// uc_side := 0 ;
122194: LD_ADDR_OWVAR 20
122198: PUSH
122199: LD_INT 0
122201: ST_TO_ADDR
// uc_nation := 2 ;
122202: LD_ADDR_OWVAR 21
122206: PUSH
122207: LD_INT 2
122209: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
122210: LD_ADDR_OWVAR 37
122214: PUSH
122215: LD_INT 14
122217: ST_TO_ADDR
// vc_engine := engine_siberite ;
122218: LD_ADDR_OWVAR 39
122222: PUSH
122223: LD_INT 3
122225: ST_TO_ADDR
// vc_control := control_apeman ;
122226: LD_ADDR_OWVAR 38
122230: PUSH
122231: LD_INT 5
122233: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
122234: LD_ADDR_OWVAR 40
122238: PUSH
122239: LD_INT 29
122241: ST_TO_ADDR
// un := CreateVehicle ;
122242: LD_ADDR_VAR 0 2
122246: PUSH
122247: CALL_OW 45
122251: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
122252: LD_VAR 0 2
122256: PPUSH
122257: LD_INT 1
122259: PPUSH
122260: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
122264: LD_INT 35
122266: PPUSH
122267: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
122271: LD_VAR 0 2
122275: PPUSH
122276: LD_INT 22
122278: PUSH
122279: LD_OWVAR 2
122283: PUSH
122284: EMPTY
122285: LIST
122286: LIST
122287: PPUSH
122288: CALL_OW 69
122292: PPUSH
122293: LD_VAR 0 2
122297: PPUSH
122298: CALL_OW 74
122302: PPUSH
122303: CALL_OW 115
// until IsDead ( un ) ;
122307: LD_VAR 0 2
122311: PPUSH
122312: CALL_OW 301
122316: IFFALSE 122264
// end ;
122318: PPOPN 2
122320: END
// every 0 0$1 trigger StreamModeActive and sStu do
122321: LD_EXP 148
122325: PUSH
122326: LD_EXP 187
122330: AND
122331: IFFALSE 122347
122333: GO 122335
122335: DISABLE
// begin ToLua ( displayStucuk(); ) ;
122336: LD_STRING displayStucuk();
122338: PPUSH
122339: CALL_OW 559
// ResetFog ;
122343: CALL_OW 335
// end ;
122347: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
122348: LD_EXP 148
122352: PUSH
122353: LD_EXP 180
122357: AND
122358: IFFALSE 122499
122360: GO 122362
122362: DISABLE
122363: LD_INT 0
122365: PPUSH
122366: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
122367: LD_ADDR_VAR 0 2
122371: PUSH
122372: LD_INT 22
122374: PUSH
122375: LD_OWVAR 2
122379: PUSH
122380: EMPTY
122381: LIST
122382: LIST
122383: PUSH
122384: LD_INT 21
122386: PUSH
122387: LD_INT 1
122389: PUSH
122390: EMPTY
122391: LIST
122392: LIST
122393: PUSH
122394: EMPTY
122395: LIST
122396: LIST
122397: PPUSH
122398: CALL_OW 69
122402: ST_TO_ADDR
// if not tmp then
122403: LD_VAR 0 2
122407: NOT
122408: IFFALSE 122412
// exit ;
122410: GO 122499
// un := tmp [ rand ( 1 , tmp ) ] ;
122412: LD_ADDR_VAR 0 1
122416: PUSH
122417: LD_VAR 0 2
122421: PUSH
122422: LD_INT 1
122424: PPUSH
122425: LD_VAR 0 2
122429: PPUSH
122430: CALL_OW 12
122434: ARRAY
122435: ST_TO_ADDR
// SetSide ( un , 0 ) ;
122436: LD_VAR 0 1
122440: PPUSH
122441: LD_INT 0
122443: PPUSH
122444: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
122448: LD_VAR 0 1
122452: PPUSH
122453: LD_OWVAR 3
122457: PUSH
122458: LD_VAR 0 1
122462: DIFF
122463: PPUSH
122464: LD_VAR 0 1
122468: PPUSH
122469: CALL_OW 74
122473: PPUSH
122474: CALL_OW 115
// wait ( 0 0$20 ) ;
122478: LD_INT 700
122480: PPUSH
122481: CALL_OW 67
// SetSide ( un , your_side ) ;
122485: LD_VAR 0 1
122489: PPUSH
122490: LD_OWVAR 2
122494: PPUSH
122495: CALL_OW 235
// end ;
122499: PPOPN 2
122501: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
122502: LD_EXP 148
122506: PUSH
122507: LD_EXP 181
122511: AND
122512: IFFALSE 122618
122514: GO 122516
122516: DISABLE
122517: LD_INT 0
122519: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
122520: LD_ADDR_VAR 0 1
122524: PUSH
122525: LD_INT 22
122527: PUSH
122528: LD_OWVAR 2
122532: PUSH
122533: EMPTY
122534: LIST
122535: LIST
122536: PUSH
122537: LD_INT 2
122539: PUSH
122540: LD_INT 30
122542: PUSH
122543: LD_INT 0
122545: PUSH
122546: EMPTY
122547: LIST
122548: LIST
122549: PUSH
122550: LD_INT 30
122552: PUSH
122553: LD_INT 1
122555: PUSH
122556: EMPTY
122557: LIST
122558: LIST
122559: PUSH
122560: EMPTY
122561: LIST
122562: LIST
122563: LIST
122564: PUSH
122565: EMPTY
122566: LIST
122567: LIST
122568: PPUSH
122569: CALL_OW 69
122573: ST_TO_ADDR
// if not depot then
122574: LD_VAR 0 1
122578: NOT
122579: IFFALSE 122583
// exit ;
122581: GO 122618
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
122583: LD_VAR 0 1
122587: PUSH
122588: LD_INT 1
122590: ARRAY
122591: PPUSH
122592: CALL_OW 250
122596: PPUSH
122597: LD_VAR 0 1
122601: PUSH
122602: LD_INT 1
122604: ARRAY
122605: PPUSH
122606: CALL_OW 251
122610: PPUSH
122611: LD_INT 70
122613: PPUSH
122614: CALL_OW 495
// end ;
122618: PPOPN 1
122620: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
122621: LD_EXP 148
122625: PUSH
122626: LD_EXP 182
122630: AND
122631: IFFALSE 122842
122633: GO 122635
122635: DISABLE
122636: LD_INT 0
122638: PPUSH
122639: PPUSH
122640: PPUSH
122641: PPUSH
122642: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
122643: LD_ADDR_VAR 0 5
122647: PUSH
122648: LD_INT 22
122650: PUSH
122651: LD_OWVAR 2
122655: PUSH
122656: EMPTY
122657: LIST
122658: LIST
122659: PUSH
122660: LD_INT 21
122662: PUSH
122663: LD_INT 1
122665: PUSH
122666: EMPTY
122667: LIST
122668: LIST
122669: PUSH
122670: EMPTY
122671: LIST
122672: LIST
122673: PPUSH
122674: CALL_OW 69
122678: ST_TO_ADDR
// if not tmp then
122679: LD_VAR 0 5
122683: NOT
122684: IFFALSE 122688
// exit ;
122686: GO 122842
// for i in tmp do
122688: LD_ADDR_VAR 0 1
122692: PUSH
122693: LD_VAR 0 5
122697: PUSH
122698: FOR_IN
122699: IFFALSE 122840
// begin d := rand ( 0 , 5 ) ;
122701: LD_ADDR_VAR 0 4
122705: PUSH
122706: LD_INT 0
122708: PPUSH
122709: LD_INT 5
122711: PPUSH
122712: CALL_OW 12
122716: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
122717: LD_ADDR_VAR 0 2
122721: PUSH
122722: LD_VAR 0 1
122726: PPUSH
122727: CALL_OW 250
122731: PPUSH
122732: LD_VAR 0 4
122736: PPUSH
122737: LD_INT 3
122739: PPUSH
122740: LD_INT 12
122742: PPUSH
122743: CALL_OW 12
122747: PPUSH
122748: CALL_OW 272
122752: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
122753: LD_ADDR_VAR 0 3
122757: PUSH
122758: LD_VAR 0 1
122762: PPUSH
122763: CALL_OW 251
122767: PPUSH
122768: LD_VAR 0 4
122772: PPUSH
122773: LD_INT 3
122775: PPUSH
122776: LD_INT 12
122778: PPUSH
122779: CALL_OW 12
122783: PPUSH
122784: CALL_OW 273
122788: ST_TO_ADDR
// if ValidHex ( x , y ) then
122789: LD_VAR 0 2
122793: PPUSH
122794: LD_VAR 0 3
122798: PPUSH
122799: CALL_OW 488
122803: IFFALSE 122838
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
122805: LD_VAR 0 1
122809: PPUSH
122810: LD_VAR 0 2
122814: PPUSH
122815: LD_VAR 0 3
122819: PPUSH
122820: LD_INT 3
122822: PPUSH
122823: LD_INT 6
122825: PPUSH
122826: CALL_OW 12
122830: PPUSH
122831: LD_INT 1
122833: PPUSH
122834: CALL_OW 483
// end ;
122838: GO 122698
122840: POP
122841: POP
// end ;
122842: PPOPN 5
122844: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
122845: LD_EXP 148
122849: PUSH
122850: LD_EXP 183
122854: AND
122855: IFFALSE 122949
122857: GO 122859
122859: DISABLE
122860: LD_INT 0
122862: PPUSH
122863: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
122864: LD_ADDR_VAR 0 2
122868: PUSH
122869: LD_INT 22
122871: PUSH
122872: LD_OWVAR 2
122876: PUSH
122877: EMPTY
122878: LIST
122879: LIST
122880: PUSH
122881: LD_INT 32
122883: PUSH
122884: LD_INT 1
122886: PUSH
122887: EMPTY
122888: LIST
122889: LIST
122890: PUSH
122891: LD_INT 21
122893: PUSH
122894: LD_INT 2
122896: PUSH
122897: EMPTY
122898: LIST
122899: LIST
122900: PUSH
122901: EMPTY
122902: LIST
122903: LIST
122904: LIST
122905: PPUSH
122906: CALL_OW 69
122910: ST_TO_ADDR
// if not tmp then
122911: LD_VAR 0 2
122915: NOT
122916: IFFALSE 122920
// exit ;
122918: GO 122949
// for i in tmp do
122920: LD_ADDR_VAR 0 1
122924: PUSH
122925: LD_VAR 0 2
122929: PUSH
122930: FOR_IN
122931: IFFALSE 122947
// SetFuel ( i , 0 ) ;
122933: LD_VAR 0 1
122937: PPUSH
122938: LD_INT 0
122940: PPUSH
122941: CALL_OW 240
122945: GO 122930
122947: POP
122948: POP
// end ;
122949: PPOPN 2
122951: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
122952: LD_EXP 148
122956: PUSH
122957: LD_EXP 184
122961: AND
122962: IFFALSE 123028
122964: GO 122966
122966: DISABLE
122967: LD_INT 0
122969: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
122970: LD_ADDR_VAR 0 1
122974: PUSH
122975: LD_INT 22
122977: PUSH
122978: LD_OWVAR 2
122982: PUSH
122983: EMPTY
122984: LIST
122985: LIST
122986: PUSH
122987: LD_INT 30
122989: PUSH
122990: LD_INT 29
122992: PUSH
122993: EMPTY
122994: LIST
122995: LIST
122996: PUSH
122997: EMPTY
122998: LIST
122999: LIST
123000: PPUSH
123001: CALL_OW 69
123005: ST_TO_ADDR
// if not tmp then
123006: LD_VAR 0 1
123010: NOT
123011: IFFALSE 123015
// exit ;
123013: GO 123028
// DestroyUnit ( tmp [ 1 ] ) ;
123015: LD_VAR 0 1
123019: PUSH
123020: LD_INT 1
123022: ARRAY
123023: PPUSH
123024: CALL_OW 65
// end ;
123028: PPOPN 1
123030: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
123031: LD_EXP 148
123035: PUSH
123036: LD_EXP 186
123040: AND
123041: IFFALSE 123170
123043: GO 123045
123045: DISABLE
123046: LD_INT 0
123048: PPUSH
// begin uc_side := 0 ;
123049: LD_ADDR_OWVAR 20
123053: PUSH
123054: LD_INT 0
123056: ST_TO_ADDR
// uc_nation := nation_arabian ;
123057: LD_ADDR_OWVAR 21
123061: PUSH
123062: LD_INT 2
123064: ST_TO_ADDR
// hc_gallery :=  ;
123065: LD_ADDR_OWVAR 33
123069: PUSH
123070: LD_STRING 
123072: ST_TO_ADDR
// hc_name :=  ;
123073: LD_ADDR_OWVAR 26
123077: PUSH
123078: LD_STRING 
123080: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
123081: LD_INT 1
123083: PPUSH
123084: LD_INT 11
123086: PPUSH
123087: LD_INT 10
123089: PPUSH
123090: CALL_OW 380
// un := CreateHuman ;
123094: LD_ADDR_VAR 0 1
123098: PUSH
123099: CALL_OW 44
123103: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
123104: LD_VAR 0 1
123108: PPUSH
123109: LD_INT 1
123111: PPUSH
123112: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
123116: LD_INT 35
123118: PPUSH
123119: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
123123: LD_VAR 0 1
123127: PPUSH
123128: LD_INT 22
123130: PUSH
123131: LD_OWVAR 2
123135: PUSH
123136: EMPTY
123137: LIST
123138: LIST
123139: PPUSH
123140: CALL_OW 69
123144: PPUSH
123145: LD_VAR 0 1
123149: PPUSH
123150: CALL_OW 74
123154: PPUSH
123155: CALL_OW 115
// until IsDead ( un ) ;
123159: LD_VAR 0 1
123163: PPUSH
123164: CALL_OW 301
123168: IFFALSE 123116
// end ;
123170: PPOPN 1
123172: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
123173: LD_EXP 148
123177: PUSH
123178: LD_EXP 188
123182: AND
123183: IFFALSE 123195
123185: GO 123187
123187: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
123188: LD_STRING earthquake(getX(game), 0, 32)
123190: PPUSH
123191: CALL_OW 559
123195: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
123196: LD_EXP 148
123200: PUSH
123201: LD_EXP 189
123205: AND
123206: IFFALSE 123297
123208: GO 123210
123210: DISABLE
123211: LD_INT 0
123213: PPUSH
// begin enable ;
123214: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
123215: LD_ADDR_VAR 0 1
123219: PUSH
123220: LD_INT 22
123222: PUSH
123223: LD_OWVAR 2
123227: PUSH
123228: EMPTY
123229: LIST
123230: LIST
123231: PUSH
123232: LD_INT 21
123234: PUSH
123235: LD_INT 2
123237: PUSH
123238: EMPTY
123239: LIST
123240: LIST
123241: PUSH
123242: LD_INT 33
123244: PUSH
123245: LD_INT 3
123247: PUSH
123248: EMPTY
123249: LIST
123250: LIST
123251: PUSH
123252: EMPTY
123253: LIST
123254: LIST
123255: LIST
123256: PPUSH
123257: CALL_OW 69
123261: ST_TO_ADDR
// if not tmp then
123262: LD_VAR 0 1
123266: NOT
123267: IFFALSE 123271
// exit ;
123269: GO 123297
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
123271: LD_VAR 0 1
123275: PUSH
123276: LD_INT 1
123278: PPUSH
123279: LD_VAR 0 1
123283: PPUSH
123284: CALL_OW 12
123288: ARRAY
123289: PPUSH
123290: LD_INT 1
123292: PPUSH
123293: CALL_OW 234
// end ;
123297: PPOPN 1
123299: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
123300: LD_EXP 148
123304: PUSH
123305: LD_EXP 190
123309: AND
123310: IFFALSE 123451
123312: GO 123314
123314: DISABLE
123315: LD_INT 0
123317: PPUSH
123318: PPUSH
123319: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
123320: LD_ADDR_VAR 0 3
123324: PUSH
123325: LD_INT 22
123327: PUSH
123328: LD_OWVAR 2
123332: PUSH
123333: EMPTY
123334: LIST
123335: LIST
123336: PUSH
123337: LD_INT 25
123339: PUSH
123340: LD_INT 1
123342: PUSH
123343: EMPTY
123344: LIST
123345: LIST
123346: PUSH
123347: EMPTY
123348: LIST
123349: LIST
123350: PPUSH
123351: CALL_OW 69
123355: ST_TO_ADDR
// if not tmp then
123356: LD_VAR 0 3
123360: NOT
123361: IFFALSE 123365
// exit ;
123363: GO 123451
// un := tmp [ rand ( 1 , tmp ) ] ;
123365: LD_ADDR_VAR 0 2
123369: PUSH
123370: LD_VAR 0 3
123374: PUSH
123375: LD_INT 1
123377: PPUSH
123378: LD_VAR 0 3
123382: PPUSH
123383: CALL_OW 12
123387: ARRAY
123388: ST_TO_ADDR
// if Crawls ( un ) then
123389: LD_VAR 0 2
123393: PPUSH
123394: CALL_OW 318
123398: IFFALSE 123409
// ComWalk ( un ) ;
123400: LD_VAR 0 2
123404: PPUSH
123405: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
123409: LD_VAR 0 2
123413: PPUSH
123414: LD_INT 9
123416: PPUSH
123417: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
123421: LD_INT 28
123423: PPUSH
123424: LD_OWVAR 2
123428: PPUSH
123429: LD_INT 2
123431: PPUSH
123432: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
123436: LD_INT 29
123438: PPUSH
123439: LD_OWVAR 2
123443: PPUSH
123444: LD_INT 2
123446: PPUSH
123447: CALL_OW 322
// end ;
123451: PPOPN 3
123453: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
123454: LD_EXP 148
123458: PUSH
123459: LD_EXP 191
123463: AND
123464: IFFALSE 123575
123466: GO 123468
123468: DISABLE
123469: LD_INT 0
123471: PPUSH
123472: PPUSH
123473: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
123474: LD_ADDR_VAR 0 3
123478: PUSH
123479: LD_INT 22
123481: PUSH
123482: LD_OWVAR 2
123486: PUSH
123487: EMPTY
123488: LIST
123489: LIST
123490: PUSH
123491: LD_INT 25
123493: PUSH
123494: LD_INT 1
123496: PUSH
123497: EMPTY
123498: LIST
123499: LIST
123500: PUSH
123501: EMPTY
123502: LIST
123503: LIST
123504: PPUSH
123505: CALL_OW 69
123509: ST_TO_ADDR
// if not tmp then
123510: LD_VAR 0 3
123514: NOT
123515: IFFALSE 123519
// exit ;
123517: GO 123575
// un := tmp [ rand ( 1 , tmp ) ] ;
123519: LD_ADDR_VAR 0 2
123523: PUSH
123524: LD_VAR 0 3
123528: PUSH
123529: LD_INT 1
123531: PPUSH
123532: LD_VAR 0 3
123536: PPUSH
123537: CALL_OW 12
123541: ARRAY
123542: ST_TO_ADDR
// if Crawls ( un ) then
123543: LD_VAR 0 2
123547: PPUSH
123548: CALL_OW 318
123552: IFFALSE 123563
// ComWalk ( un ) ;
123554: LD_VAR 0 2
123558: PPUSH
123559: CALL_OW 138
// SetClass ( un , class_mortar ) ;
123563: LD_VAR 0 2
123567: PPUSH
123568: LD_INT 8
123570: PPUSH
123571: CALL_OW 336
// end ;
123575: PPOPN 3
123577: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
123578: LD_EXP 148
123582: PUSH
123583: LD_EXP 192
123587: AND
123588: IFFALSE 123732
123590: GO 123592
123592: DISABLE
123593: LD_INT 0
123595: PPUSH
123596: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
123597: LD_ADDR_VAR 0 2
123601: PUSH
123602: LD_INT 22
123604: PUSH
123605: LD_OWVAR 2
123609: PUSH
123610: EMPTY
123611: LIST
123612: LIST
123613: PUSH
123614: LD_INT 21
123616: PUSH
123617: LD_INT 2
123619: PUSH
123620: EMPTY
123621: LIST
123622: LIST
123623: PUSH
123624: LD_INT 2
123626: PUSH
123627: LD_INT 34
123629: PUSH
123630: LD_INT 12
123632: PUSH
123633: EMPTY
123634: LIST
123635: LIST
123636: PUSH
123637: LD_INT 34
123639: PUSH
123640: LD_INT 51
123642: PUSH
123643: EMPTY
123644: LIST
123645: LIST
123646: PUSH
123647: LD_INT 34
123649: PUSH
123650: LD_INT 32
123652: PUSH
123653: EMPTY
123654: LIST
123655: LIST
123656: PUSH
123657: EMPTY
123658: LIST
123659: LIST
123660: LIST
123661: LIST
123662: PUSH
123663: EMPTY
123664: LIST
123665: LIST
123666: LIST
123667: PPUSH
123668: CALL_OW 69
123672: ST_TO_ADDR
// if not tmp then
123673: LD_VAR 0 2
123677: NOT
123678: IFFALSE 123682
// exit ;
123680: GO 123732
// for i in tmp do
123682: LD_ADDR_VAR 0 1
123686: PUSH
123687: LD_VAR 0 2
123691: PUSH
123692: FOR_IN
123693: IFFALSE 123730
// if GetCargo ( i , mat_artifact ) = 0 then
123695: LD_VAR 0 1
123699: PPUSH
123700: LD_INT 4
123702: PPUSH
123703: CALL_OW 289
123707: PUSH
123708: LD_INT 0
123710: EQUAL
123711: IFFALSE 123728
// SetCargo ( i , mat_siberit , 100 ) ;
123713: LD_VAR 0 1
123717: PPUSH
123718: LD_INT 3
123720: PPUSH
123721: LD_INT 100
123723: PPUSH
123724: CALL_OW 290
123728: GO 123692
123730: POP
123731: POP
// end ;
123732: PPOPN 2
123734: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
123735: LD_EXP 148
123739: PUSH
123740: LD_EXP 193
123744: AND
123745: IFFALSE 123928
123747: GO 123749
123749: DISABLE
123750: LD_INT 0
123752: PPUSH
123753: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
123754: LD_ADDR_VAR 0 2
123758: PUSH
123759: LD_INT 22
123761: PUSH
123762: LD_OWVAR 2
123766: PUSH
123767: EMPTY
123768: LIST
123769: LIST
123770: PPUSH
123771: CALL_OW 69
123775: ST_TO_ADDR
// if not tmp then
123776: LD_VAR 0 2
123780: NOT
123781: IFFALSE 123785
// exit ;
123783: GO 123928
// for i := 1 to 2 do
123785: LD_ADDR_VAR 0 1
123789: PUSH
123790: DOUBLE
123791: LD_INT 1
123793: DEC
123794: ST_TO_ADDR
123795: LD_INT 2
123797: PUSH
123798: FOR_TO
123799: IFFALSE 123926
// begin uc_side := your_side ;
123801: LD_ADDR_OWVAR 20
123805: PUSH
123806: LD_OWVAR 2
123810: ST_TO_ADDR
// uc_nation := nation_american ;
123811: LD_ADDR_OWVAR 21
123815: PUSH
123816: LD_INT 1
123818: ST_TO_ADDR
// vc_chassis := us_morphling ;
123819: LD_ADDR_OWVAR 37
123823: PUSH
123824: LD_INT 5
123826: ST_TO_ADDR
// vc_engine := engine_siberite ;
123827: LD_ADDR_OWVAR 39
123831: PUSH
123832: LD_INT 3
123834: ST_TO_ADDR
// vc_control := control_computer ;
123835: LD_ADDR_OWVAR 38
123839: PUSH
123840: LD_INT 3
123842: ST_TO_ADDR
// vc_weapon := us_double_laser ;
123843: LD_ADDR_OWVAR 40
123847: PUSH
123848: LD_INT 10
123850: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
123851: LD_VAR 0 2
123855: PUSH
123856: LD_INT 1
123858: ARRAY
123859: PPUSH
123860: CALL_OW 310
123864: NOT
123865: IFFALSE 123912
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
123867: CALL_OW 45
123871: PPUSH
123872: LD_VAR 0 2
123876: PUSH
123877: LD_INT 1
123879: ARRAY
123880: PPUSH
123881: CALL_OW 250
123885: PPUSH
123886: LD_VAR 0 2
123890: PUSH
123891: LD_INT 1
123893: ARRAY
123894: PPUSH
123895: CALL_OW 251
123899: PPUSH
123900: LD_INT 12
123902: PPUSH
123903: LD_INT 1
123905: PPUSH
123906: CALL_OW 50
123910: GO 123924
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
123912: CALL_OW 45
123916: PPUSH
123917: LD_INT 1
123919: PPUSH
123920: CALL_OW 51
// end ;
123924: GO 123798
123926: POP
123927: POP
// end ;
123928: PPOPN 2
123930: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
123931: LD_EXP 148
123935: PUSH
123936: LD_EXP 194
123940: AND
123941: IFFALSE 124163
123943: GO 123945
123945: DISABLE
123946: LD_INT 0
123948: PPUSH
123949: PPUSH
123950: PPUSH
123951: PPUSH
123952: PPUSH
123953: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
123954: LD_ADDR_VAR 0 6
123958: PUSH
123959: LD_INT 22
123961: PUSH
123962: LD_OWVAR 2
123966: PUSH
123967: EMPTY
123968: LIST
123969: LIST
123970: PUSH
123971: LD_INT 21
123973: PUSH
123974: LD_INT 1
123976: PUSH
123977: EMPTY
123978: LIST
123979: LIST
123980: PUSH
123981: LD_INT 3
123983: PUSH
123984: LD_INT 23
123986: PUSH
123987: LD_INT 0
123989: PUSH
123990: EMPTY
123991: LIST
123992: LIST
123993: PUSH
123994: EMPTY
123995: LIST
123996: LIST
123997: PUSH
123998: EMPTY
123999: LIST
124000: LIST
124001: LIST
124002: PPUSH
124003: CALL_OW 69
124007: ST_TO_ADDR
// if not tmp then
124008: LD_VAR 0 6
124012: NOT
124013: IFFALSE 124017
// exit ;
124015: GO 124163
// s1 := rand ( 1 , 4 ) ;
124017: LD_ADDR_VAR 0 2
124021: PUSH
124022: LD_INT 1
124024: PPUSH
124025: LD_INT 4
124027: PPUSH
124028: CALL_OW 12
124032: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
124033: LD_ADDR_VAR 0 4
124037: PUSH
124038: LD_VAR 0 6
124042: PUSH
124043: LD_INT 1
124045: ARRAY
124046: PPUSH
124047: LD_VAR 0 2
124051: PPUSH
124052: CALL_OW 259
124056: ST_TO_ADDR
// if s1 = 1 then
124057: LD_VAR 0 2
124061: PUSH
124062: LD_INT 1
124064: EQUAL
124065: IFFALSE 124085
// s2 := rand ( 2 , 4 ) else
124067: LD_ADDR_VAR 0 3
124071: PUSH
124072: LD_INT 2
124074: PPUSH
124075: LD_INT 4
124077: PPUSH
124078: CALL_OW 12
124082: ST_TO_ADDR
124083: GO 124093
// s2 := 1 ;
124085: LD_ADDR_VAR 0 3
124089: PUSH
124090: LD_INT 1
124092: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
124093: LD_ADDR_VAR 0 5
124097: PUSH
124098: LD_VAR 0 6
124102: PUSH
124103: LD_INT 1
124105: ARRAY
124106: PPUSH
124107: LD_VAR 0 3
124111: PPUSH
124112: CALL_OW 259
124116: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
124117: LD_VAR 0 6
124121: PUSH
124122: LD_INT 1
124124: ARRAY
124125: PPUSH
124126: LD_VAR 0 2
124130: PPUSH
124131: LD_VAR 0 5
124135: PPUSH
124136: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
124140: LD_VAR 0 6
124144: PUSH
124145: LD_INT 1
124147: ARRAY
124148: PPUSH
124149: LD_VAR 0 3
124153: PPUSH
124154: LD_VAR 0 4
124158: PPUSH
124159: CALL_OW 237
// end ;
124163: PPOPN 6
124165: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
124166: LD_EXP 148
124170: PUSH
124171: LD_EXP 195
124175: AND
124176: IFFALSE 124255
124178: GO 124180
124180: DISABLE
124181: LD_INT 0
124183: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
124184: LD_ADDR_VAR 0 1
124188: PUSH
124189: LD_INT 22
124191: PUSH
124192: LD_OWVAR 2
124196: PUSH
124197: EMPTY
124198: LIST
124199: LIST
124200: PUSH
124201: LD_INT 30
124203: PUSH
124204: LD_INT 3
124206: PUSH
124207: EMPTY
124208: LIST
124209: LIST
124210: PUSH
124211: EMPTY
124212: LIST
124213: LIST
124214: PPUSH
124215: CALL_OW 69
124219: ST_TO_ADDR
// if not tmp then
124220: LD_VAR 0 1
124224: NOT
124225: IFFALSE 124229
// exit ;
124227: GO 124255
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
124229: LD_VAR 0 1
124233: PUSH
124234: LD_INT 1
124236: PPUSH
124237: LD_VAR 0 1
124241: PPUSH
124242: CALL_OW 12
124246: ARRAY
124247: PPUSH
124248: LD_INT 1
124250: PPUSH
124251: CALL_OW 234
// end ;
124255: PPOPN 1
124257: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
124258: LD_EXP 148
124262: PUSH
124263: LD_EXP 196
124267: AND
124268: IFFALSE 124380
124270: GO 124272
124272: DISABLE
124273: LD_INT 0
124275: PPUSH
124276: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
124277: LD_ADDR_VAR 0 2
124281: PUSH
124282: LD_INT 22
124284: PUSH
124285: LD_OWVAR 2
124289: PUSH
124290: EMPTY
124291: LIST
124292: LIST
124293: PUSH
124294: LD_INT 2
124296: PUSH
124297: LD_INT 30
124299: PUSH
124300: LD_INT 27
124302: PUSH
124303: EMPTY
124304: LIST
124305: LIST
124306: PUSH
124307: LD_INT 30
124309: PUSH
124310: LD_INT 26
124312: PUSH
124313: EMPTY
124314: LIST
124315: LIST
124316: PUSH
124317: LD_INT 30
124319: PUSH
124320: LD_INT 28
124322: PUSH
124323: EMPTY
124324: LIST
124325: LIST
124326: PUSH
124327: EMPTY
124328: LIST
124329: LIST
124330: LIST
124331: LIST
124332: PUSH
124333: EMPTY
124334: LIST
124335: LIST
124336: PPUSH
124337: CALL_OW 69
124341: ST_TO_ADDR
// if not tmp then
124342: LD_VAR 0 2
124346: NOT
124347: IFFALSE 124351
// exit ;
124349: GO 124380
// for i in tmp do
124351: LD_ADDR_VAR 0 1
124355: PUSH
124356: LD_VAR 0 2
124360: PUSH
124361: FOR_IN
124362: IFFALSE 124378
// SetLives ( i , 1 ) ;
124364: LD_VAR 0 1
124368: PPUSH
124369: LD_INT 1
124371: PPUSH
124372: CALL_OW 234
124376: GO 124361
124378: POP
124379: POP
// end ;
124380: PPOPN 2
124382: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
124383: LD_EXP 148
124387: PUSH
124388: LD_EXP 197
124392: AND
124393: IFFALSE 124680
124395: GO 124397
124397: DISABLE
124398: LD_INT 0
124400: PPUSH
124401: PPUSH
124402: PPUSH
// begin i := rand ( 1 , 7 ) ;
124403: LD_ADDR_VAR 0 1
124407: PUSH
124408: LD_INT 1
124410: PPUSH
124411: LD_INT 7
124413: PPUSH
124414: CALL_OW 12
124418: ST_TO_ADDR
// case i of 1 :
124419: LD_VAR 0 1
124423: PUSH
124424: LD_INT 1
124426: DOUBLE
124427: EQUAL
124428: IFTRUE 124432
124430: GO 124442
124432: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
124433: LD_STRING earthquake(getX(game), 0, 32)
124435: PPUSH
124436: CALL_OW 559
124440: GO 124680
124442: LD_INT 2
124444: DOUBLE
124445: EQUAL
124446: IFTRUE 124450
124448: GO 124464
124450: POP
// begin ToLua ( displayStucuk(); ) ;
124451: LD_STRING displayStucuk();
124453: PPUSH
124454: CALL_OW 559
// ResetFog ;
124458: CALL_OW 335
// end ; 3 :
124462: GO 124680
124464: LD_INT 3
124466: DOUBLE
124467: EQUAL
124468: IFTRUE 124472
124470: GO 124576
124472: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
124473: LD_ADDR_VAR 0 2
124477: PUSH
124478: LD_INT 22
124480: PUSH
124481: LD_OWVAR 2
124485: PUSH
124486: EMPTY
124487: LIST
124488: LIST
124489: PUSH
124490: LD_INT 25
124492: PUSH
124493: LD_INT 1
124495: PUSH
124496: EMPTY
124497: LIST
124498: LIST
124499: PUSH
124500: EMPTY
124501: LIST
124502: LIST
124503: PPUSH
124504: CALL_OW 69
124508: ST_TO_ADDR
// if not tmp then
124509: LD_VAR 0 2
124513: NOT
124514: IFFALSE 124518
// exit ;
124516: GO 124680
// un := tmp [ rand ( 1 , tmp ) ] ;
124518: LD_ADDR_VAR 0 3
124522: PUSH
124523: LD_VAR 0 2
124527: PUSH
124528: LD_INT 1
124530: PPUSH
124531: LD_VAR 0 2
124535: PPUSH
124536: CALL_OW 12
124540: ARRAY
124541: ST_TO_ADDR
// if Crawls ( un ) then
124542: LD_VAR 0 3
124546: PPUSH
124547: CALL_OW 318
124551: IFFALSE 124562
// ComWalk ( un ) ;
124553: LD_VAR 0 3
124557: PPUSH
124558: CALL_OW 138
// SetClass ( un , class_mortar ) ;
124562: LD_VAR 0 3
124566: PPUSH
124567: LD_INT 8
124569: PPUSH
124570: CALL_OW 336
// end ; 4 :
124574: GO 124680
124576: LD_INT 4
124578: DOUBLE
124579: EQUAL
124580: IFTRUE 124584
124582: GO 124658
124584: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
124585: LD_ADDR_VAR 0 2
124589: PUSH
124590: LD_INT 22
124592: PUSH
124593: LD_OWVAR 2
124597: PUSH
124598: EMPTY
124599: LIST
124600: LIST
124601: PUSH
124602: LD_INT 30
124604: PUSH
124605: LD_INT 29
124607: PUSH
124608: EMPTY
124609: LIST
124610: LIST
124611: PUSH
124612: EMPTY
124613: LIST
124614: LIST
124615: PPUSH
124616: CALL_OW 69
124620: ST_TO_ADDR
// if not tmp then
124621: LD_VAR 0 2
124625: NOT
124626: IFFALSE 124630
// exit ;
124628: GO 124680
// CenterNowOnUnits ( tmp [ 1 ] ) ;
124630: LD_VAR 0 2
124634: PUSH
124635: LD_INT 1
124637: ARRAY
124638: PPUSH
124639: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
124643: LD_VAR 0 2
124647: PUSH
124648: LD_INT 1
124650: ARRAY
124651: PPUSH
124652: CALL_OW 65
// end ; 5 .. 7 :
124656: GO 124680
124658: LD_INT 5
124660: DOUBLE
124661: GREATEREQUAL
124662: IFFALSE 124670
124664: LD_INT 7
124666: DOUBLE
124667: LESSEQUAL
124668: IFTRUE 124672
124670: GO 124679
124672: POP
// StreamSibBomb ; end ;
124673: CALL 120917 0 0
124677: GO 124680
124679: POP
// end ;
124680: PPOPN 3
124682: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
124683: LD_EXP 148
124687: PUSH
124688: LD_EXP 198
124692: AND
124693: IFFALSE 124849
124695: GO 124697
124697: DISABLE
124698: LD_INT 0
124700: PPUSH
124701: PPUSH
124702: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
124703: LD_ADDR_VAR 0 2
124707: PUSH
124708: LD_INT 81
124710: PUSH
124711: LD_OWVAR 2
124715: PUSH
124716: EMPTY
124717: LIST
124718: LIST
124719: PUSH
124720: LD_INT 2
124722: PUSH
124723: LD_INT 21
124725: PUSH
124726: LD_INT 1
124728: PUSH
124729: EMPTY
124730: LIST
124731: LIST
124732: PUSH
124733: LD_INT 21
124735: PUSH
124736: LD_INT 2
124738: PUSH
124739: EMPTY
124740: LIST
124741: LIST
124742: PUSH
124743: EMPTY
124744: LIST
124745: LIST
124746: LIST
124747: PUSH
124748: EMPTY
124749: LIST
124750: LIST
124751: PPUSH
124752: CALL_OW 69
124756: ST_TO_ADDR
// if not tmp then
124757: LD_VAR 0 2
124761: NOT
124762: IFFALSE 124766
// exit ;
124764: GO 124849
// p := 0 ;
124766: LD_ADDR_VAR 0 3
124770: PUSH
124771: LD_INT 0
124773: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
124774: LD_INT 35
124776: PPUSH
124777: CALL_OW 67
// p := p + 1 ;
124781: LD_ADDR_VAR 0 3
124785: PUSH
124786: LD_VAR 0 3
124790: PUSH
124791: LD_INT 1
124793: PLUS
124794: ST_TO_ADDR
// for i in tmp do
124795: LD_ADDR_VAR 0 1
124799: PUSH
124800: LD_VAR 0 2
124804: PUSH
124805: FOR_IN
124806: IFFALSE 124837
// if GetLives ( i ) < 1000 then
124808: LD_VAR 0 1
124812: PPUSH
124813: CALL_OW 256
124817: PUSH
124818: LD_INT 1000
124820: LESS
124821: IFFALSE 124835
// SetLives ( i , 1000 ) ;
124823: LD_VAR 0 1
124827: PPUSH
124828: LD_INT 1000
124830: PPUSH
124831: CALL_OW 234
124835: GO 124805
124837: POP
124838: POP
// until p > 20 ;
124839: LD_VAR 0 3
124843: PUSH
124844: LD_INT 20
124846: GREATER
124847: IFFALSE 124774
// end ;
124849: PPOPN 3
124851: END
// every 0 0$1 trigger StreamModeActive and sTime do
124852: LD_EXP 148
124856: PUSH
124857: LD_EXP 199
124861: AND
124862: IFFALSE 124897
124864: GO 124866
124866: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
124867: LD_INT 28
124869: PPUSH
124870: LD_OWVAR 2
124874: PPUSH
124875: LD_INT 2
124877: PPUSH
124878: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
124882: LD_INT 30
124884: PPUSH
124885: LD_OWVAR 2
124889: PPUSH
124890: LD_INT 2
124892: PPUSH
124893: CALL_OW 322
// end ;
124897: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
124898: LD_EXP 148
124902: PUSH
124903: LD_EXP 200
124907: AND
124908: IFFALSE 125029
124910: GO 124912
124912: DISABLE
124913: LD_INT 0
124915: PPUSH
124916: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
124917: LD_ADDR_VAR 0 2
124921: PUSH
124922: LD_INT 22
124924: PUSH
124925: LD_OWVAR 2
124929: PUSH
124930: EMPTY
124931: LIST
124932: LIST
124933: PUSH
124934: LD_INT 21
124936: PUSH
124937: LD_INT 1
124939: PUSH
124940: EMPTY
124941: LIST
124942: LIST
124943: PUSH
124944: LD_INT 3
124946: PUSH
124947: LD_INT 23
124949: PUSH
124950: LD_INT 0
124952: PUSH
124953: EMPTY
124954: LIST
124955: LIST
124956: PUSH
124957: EMPTY
124958: LIST
124959: LIST
124960: PUSH
124961: EMPTY
124962: LIST
124963: LIST
124964: LIST
124965: PPUSH
124966: CALL_OW 69
124970: ST_TO_ADDR
// if not tmp then
124971: LD_VAR 0 2
124975: NOT
124976: IFFALSE 124980
// exit ;
124978: GO 125029
// for i in tmp do
124980: LD_ADDR_VAR 0 1
124984: PUSH
124985: LD_VAR 0 2
124989: PUSH
124990: FOR_IN
124991: IFFALSE 125027
// begin if Crawls ( i ) then
124993: LD_VAR 0 1
124997: PPUSH
124998: CALL_OW 318
125002: IFFALSE 125013
// ComWalk ( i ) ;
125004: LD_VAR 0 1
125008: PPUSH
125009: CALL_OW 138
// SetClass ( i , 2 ) ;
125013: LD_VAR 0 1
125017: PPUSH
125018: LD_INT 2
125020: PPUSH
125021: CALL_OW 336
// end ;
125025: GO 124990
125027: POP
125028: POP
// end ;
125029: PPOPN 2
125031: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
125032: LD_EXP 148
125036: PUSH
125037: LD_EXP 201
125041: AND
125042: IFFALSE 125330
125044: GO 125046
125046: DISABLE
125047: LD_INT 0
125049: PPUSH
125050: PPUSH
125051: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
125052: LD_OWVAR 2
125056: PPUSH
125057: LD_INT 9
125059: PPUSH
125060: LD_INT 1
125062: PPUSH
125063: LD_INT 1
125065: PPUSH
125066: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
125070: LD_INT 9
125072: PPUSH
125073: LD_OWVAR 2
125077: PPUSH
125078: CALL_OW 343
// uc_side := 9 ;
125082: LD_ADDR_OWVAR 20
125086: PUSH
125087: LD_INT 9
125089: ST_TO_ADDR
// uc_nation := 2 ;
125090: LD_ADDR_OWVAR 21
125094: PUSH
125095: LD_INT 2
125097: ST_TO_ADDR
// hc_name := Dark Warrior ;
125098: LD_ADDR_OWVAR 26
125102: PUSH
125103: LD_STRING Dark Warrior
125105: ST_TO_ADDR
// hc_gallery :=  ;
125106: LD_ADDR_OWVAR 33
125110: PUSH
125111: LD_STRING 
125113: ST_TO_ADDR
// hc_noskilllimit := true ;
125114: LD_ADDR_OWVAR 76
125118: PUSH
125119: LD_INT 1
125121: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
125122: LD_ADDR_OWVAR 31
125126: PUSH
125127: LD_INT 30
125129: PUSH
125130: LD_INT 30
125132: PUSH
125133: LD_INT 30
125135: PUSH
125136: LD_INT 30
125138: PUSH
125139: EMPTY
125140: LIST
125141: LIST
125142: LIST
125143: LIST
125144: ST_TO_ADDR
// un := CreateHuman ;
125145: LD_ADDR_VAR 0 3
125149: PUSH
125150: CALL_OW 44
125154: ST_TO_ADDR
// hc_noskilllimit := false ;
125155: LD_ADDR_OWVAR 76
125159: PUSH
125160: LD_INT 0
125162: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
125163: LD_VAR 0 3
125167: PPUSH
125168: LD_INT 1
125170: PPUSH
125171: CALL_OW 51
// ToLua ( playRanger() ) ;
125175: LD_STRING playRanger()
125177: PPUSH
125178: CALL_OW 559
// p := 0 ;
125182: LD_ADDR_VAR 0 2
125186: PUSH
125187: LD_INT 0
125189: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
125190: LD_INT 35
125192: PPUSH
125193: CALL_OW 67
// p := p + 1 ;
125197: LD_ADDR_VAR 0 2
125201: PUSH
125202: LD_VAR 0 2
125206: PUSH
125207: LD_INT 1
125209: PLUS
125210: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
125211: LD_VAR 0 3
125215: PPUSH
125216: CALL_OW 256
125220: PUSH
125221: LD_INT 1000
125223: LESS
125224: IFFALSE 125238
// SetLives ( un , 1000 ) ;
125226: LD_VAR 0 3
125230: PPUSH
125231: LD_INT 1000
125233: PPUSH
125234: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
125238: LD_VAR 0 3
125242: PPUSH
125243: LD_INT 81
125245: PUSH
125246: LD_OWVAR 2
125250: PUSH
125251: EMPTY
125252: LIST
125253: LIST
125254: PUSH
125255: LD_INT 91
125257: PUSH
125258: LD_VAR 0 3
125262: PUSH
125263: LD_INT 30
125265: PUSH
125266: EMPTY
125267: LIST
125268: LIST
125269: LIST
125270: PUSH
125271: EMPTY
125272: LIST
125273: LIST
125274: PPUSH
125275: CALL_OW 69
125279: PPUSH
125280: LD_VAR 0 3
125284: PPUSH
125285: CALL_OW 74
125289: PPUSH
125290: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
125294: LD_VAR 0 2
125298: PUSH
125299: LD_INT 80
125301: GREATER
125302: PUSH
125303: LD_VAR 0 3
125307: PPUSH
125308: CALL_OW 301
125312: OR
125313: IFFALSE 125190
// if un then
125315: LD_VAR 0 3
125319: IFFALSE 125330
// RemoveUnit ( un ) ;
125321: LD_VAR 0 3
125325: PPUSH
125326: CALL_OW 64
// end ;
125330: PPOPN 3
125332: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
125333: LD_EXP 202
125337: IFFALSE 125453
125339: GO 125341
125341: DISABLE
125342: LD_INT 0
125344: PPUSH
125345: PPUSH
125346: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
125347: LD_ADDR_VAR 0 2
125351: PUSH
125352: LD_INT 81
125354: PUSH
125355: LD_OWVAR 2
125359: PUSH
125360: EMPTY
125361: LIST
125362: LIST
125363: PUSH
125364: LD_INT 21
125366: PUSH
125367: LD_INT 1
125369: PUSH
125370: EMPTY
125371: LIST
125372: LIST
125373: PUSH
125374: EMPTY
125375: LIST
125376: LIST
125377: PPUSH
125378: CALL_OW 69
125382: ST_TO_ADDR
// ToLua ( playComputer() ) ;
125383: LD_STRING playComputer()
125385: PPUSH
125386: CALL_OW 559
// if not tmp then
125390: LD_VAR 0 2
125394: NOT
125395: IFFALSE 125399
// exit ;
125397: GO 125453
// for i in tmp do
125399: LD_ADDR_VAR 0 1
125403: PUSH
125404: LD_VAR 0 2
125408: PUSH
125409: FOR_IN
125410: IFFALSE 125451
// for j := 1 to 4 do
125412: LD_ADDR_VAR 0 3
125416: PUSH
125417: DOUBLE
125418: LD_INT 1
125420: DEC
125421: ST_TO_ADDR
125422: LD_INT 4
125424: PUSH
125425: FOR_TO
125426: IFFALSE 125447
// SetSkill ( i , j , 10 ) ;
125428: LD_VAR 0 1
125432: PPUSH
125433: LD_VAR 0 3
125437: PPUSH
125438: LD_INT 10
125440: PPUSH
125441: CALL_OW 237
125445: GO 125425
125447: POP
125448: POP
125449: GO 125409
125451: POP
125452: POP
// end ;
125453: PPOPN 3
125455: END
// every 0 0$1 trigger s30 do var i , tmp ;
125456: LD_EXP 203
125460: IFFALSE 125529
125462: GO 125464
125464: DISABLE
125465: LD_INT 0
125467: PPUSH
125468: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
125469: LD_ADDR_VAR 0 2
125473: PUSH
125474: LD_INT 22
125476: PUSH
125477: LD_OWVAR 2
125481: PUSH
125482: EMPTY
125483: LIST
125484: LIST
125485: PPUSH
125486: CALL_OW 69
125490: ST_TO_ADDR
// if not tmp then
125491: LD_VAR 0 2
125495: NOT
125496: IFFALSE 125500
// exit ;
125498: GO 125529
// for i in tmp do
125500: LD_ADDR_VAR 0 1
125504: PUSH
125505: LD_VAR 0 2
125509: PUSH
125510: FOR_IN
125511: IFFALSE 125527
// SetLives ( i , 300 ) ;
125513: LD_VAR 0 1
125517: PPUSH
125518: LD_INT 300
125520: PPUSH
125521: CALL_OW 234
125525: GO 125510
125527: POP
125528: POP
// end ;
125529: PPOPN 2
125531: END
// every 0 0$1 trigger s60 do var i , tmp ;
125532: LD_EXP 204
125536: IFFALSE 125605
125538: GO 125540
125540: DISABLE
125541: LD_INT 0
125543: PPUSH
125544: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
125545: LD_ADDR_VAR 0 2
125549: PUSH
125550: LD_INT 22
125552: PUSH
125553: LD_OWVAR 2
125557: PUSH
125558: EMPTY
125559: LIST
125560: LIST
125561: PPUSH
125562: CALL_OW 69
125566: ST_TO_ADDR
// if not tmp then
125567: LD_VAR 0 2
125571: NOT
125572: IFFALSE 125576
// exit ;
125574: GO 125605
// for i in tmp do
125576: LD_ADDR_VAR 0 1
125580: PUSH
125581: LD_VAR 0 2
125585: PUSH
125586: FOR_IN
125587: IFFALSE 125603
// SetLives ( i , 600 ) ;
125589: LD_VAR 0 1
125593: PPUSH
125594: LD_INT 600
125596: PPUSH
125597: CALL_OW 234
125601: GO 125586
125603: POP
125604: POP
// end ;
125605: PPOPN 2
125607: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
125608: LD_INT 0
125610: PPUSH
// case cmd of 301 :
125611: LD_VAR 0 1
125615: PUSH
125616: LD_INT 301
125618: DOUBLE
125619: EQUAL
125620: IFTRUE 125624
125622: GO 125656
125624: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
125625: LD_VAR 0 6
125629: PPUSH
125630: LD_VAR 0 7
125634: PPUSH
125635: LD_VAR 0 8
125639: PPUSH
125640: LD_VAR 0 4
125644: PPUSH
125645: LD_VAR 0 5
125649: PPUSH
125650: CALL 126865 0 5
125654: GO 125777
125656: LD_INT 302
125658: DOUBLE
125659: EQUAL
125660: IFTRUE 125664
125662: GO 125701
125664: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
125665: LD_VAR 0 6
125669: PPUSH
125670: LD_VAR 0 7
125674: PPUSH
125675: LD_VAR 0 8
125679: PPUSH
125680: LD_VAR 0 9
125684: PPUSH
125685: LD_VAR 0 4
125689: PPUSH
125690: LD_VAR 0 5
125694: PPUSH
125695: CALL 126956 0 6
125699: GO 125777
125701: LD_INT 303
125703: DOUBLE
125704: EQUAL
125705: IFTRUE 125709
125707: GO 125746
125709: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
125710: LD_VAR 0 6
125714: PPUSH
125715: LD_VAR 0 7
125719: PPUSH
125720: LD_VAR 0 8
125724: PPUSH
125725: LD_VAR 0 9
125729: PPUSH
125730: LD_VAR 0 4
125734: PPUSH
125735: LD_VAR 0 5
125739: PPUSH
125740: CALL 125782 0 6
125744: GO 125777
125746: LD_INT 304
125748: DOUBLE
125749: EQUAL
125750: IFTRUE 125754
125752: GO 125776
125754: POP
// hHackTeleport ( unit , x , y ) ; end ;
125755: LD_VAR 0 2
125759: PPUSH
125760: LD_VAR 0 4
125764: PPUSH
125765: LD_VAR 0 5
125769: PPUSH
125770: CALL 127549 0 3
125774: GO 125777
125776: POP
// end ;
125777: LD_VAR 0 12
125781: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
125782: LD_INT 0
125784: PPUSH
125785: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
125786: LD_VAR 0 1
125790: PUSH
125791: LD_INT 1
125793: LESS
125794: PUSH
125795: LD_VAR 0 1
125799: PUSH
125800: LD_INT 3
125802: GREATER
125803: OR
125804: PUSH
125805: LD_VAR 0 5
125809: PPUSH
125810: LD_VAR 0 6
125814: PPUSH
125815: CALL_OW 428
125819: OR
125820: IFFALSE 125824
// exit ;
125822: GO 126552
// uc_side := your_side ;
125824: LD_ADDR_OWVAR 20
125828: PUSH
125829: LD_OWVAR 2
125833: ST_TO_ADDR
// uc_nation := nation ;
125834: LD_ADDR_OWVAR 21
125838: PUSH
125839: LD_VAR 0 1
125843: ST_TO_ADDR
// bc_level = 1 ;
125844: LD_ADDR_OWVAR 43
125848: PUSH
125849: LD_INT 1
125851: ST_TO_ADDR
// case btype of 1 :
125852: LD_VAR 0 2
125856: PUSH
125857: LD_INT 1
125859: DOUBLE
125860: EQUAL
125861: IFTRUE 125865
125863: GO 125876
125865: POP
// bc_type := b_depot ; 2 :
125866: LD_ADDR_OWVAR 42
125870: PUSH
125871: LD_INT 0
125873: ST_TO_ADDR
125874: GO 126496
125876: LD_INT 2
125878: DOUBLE
125879: EQUAL
125880: IFTRUE 125884
125882: GO 125895
125884: POP
// bc_type := b_warehouse ; 3 :
125885: LD_ADDR_OWVAR 42
125889: PUSH
125890: LD_INT 1
125892: ST_TO_ADDR
125893: GO 126496
125895: LD_INT 3
125897: DOUBLE
125898: EQUAL
125899: IFTRUE 125903
125901: GO 125914
125903: POP
// bc_type := b_lab ; 4 .. 9 :
125904: LD_ADDR_OWVAR 42
125908: PUSH
125909: LD_INT 6
125911: ST_TO_ADDR
125912: GO 126496
125914: LD_INT 4
125916: DOUBLE
125917: GREATEREQUAL
125918: IFFALSE 125926
125920: LD_INT 9
125922: DOUBLE
125923: LESSEQUAL
125924: IFTRUE 125928
125926: GO 125988
125928: POP
// begin bc_type := b_lab_half ;
125929: LD_ADDR_OWVAR 42
125933: PUSH
125934: LD_INT 7
125936: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
125937: LD_ADDR_OWVAR 44
125941: PUSH
125942: LD_INT 10
125944: PUSH
125945: LD_INT 11
125947: PUSH
125948: LD_INT 12
125950: PUSH
125951: LD_INT 15
125953: PUSH
125954: LD_INT 14
125956: PUSH
125957: LD_INT 13
125959: PUSH
125960: EMPTY
125961: LIST
125962: LIST
125963: LIST
125964: LIST
125965: LIST
125966: LIST
125967: PUSH
125968: LD_VAR 0 2
125972: PUSH
125973: LD_INT 3
125975: MINUS
125976: ARRAY
125977: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
125978: LD_ADDR_OWVAR 45
125982: PUSH
125983: LD_INT 9
125985: ST_TO_ADDR
// end ; 10 .. 13 :
125986: GO 126496
125988: LD_INT 10
125990: DOUBLE
125991: GREATEREQUAL
125992: IFFALSE 126000
125994: LD_INT 13
125996: DOUBLE
125997: LESSEQUAL
125998: IFTRUE 126002
126000: GO 126079
126002: POP
// begin bc_type := b_lab_full ;
126003: LD_ADDR_OWVAR 42
126007: PUSH
126008: LD_INT 8
126010: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
126011: LD_ADDR_OWVAR 44
126015: PUSH
126016: LD_INT 10
126018: PUSH
126019: LD_INT 12
126021: PUSH
126022: LD_INT 14
126024: PUSH
126025: LD_INT 13
126027: PUSH
126028: EMPTY
126029: LIST
126030: LIST
126031: LIST
126032: LIST
126033: PUSH
126034: LD_VAR 0 2
126038: PUSH
126039: LD_INT 9
126041: MINUS
126042: ARRAY
126043: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
126044: LD_ADDR_OWVAR 45
126048: PUSH
126049: LD_INT 11
126051: PUSH
126052: LD_INT 15
126054: PUSH
126055: LD_INT 12
126057: PUSH
126058: LD_INT 15
126060: PUSH
126061: EMPTY
126062: LIST
126063: LIST
126064: LIST
126065: LIST
126066: PUSH
126067: LD_VAR 0 2
126071: PUSH
126072: LD_INT 9
126074: MINUS
126075: ARRAY
126076: ST_TO_ADDR
// end ; 14 :
126077: GO 126496
126079: LD_INT 14
126081: DOUBLE
126082: EQUAL
126083: IFTRUE 126087
126085: GO 126098
126087: POP
// bc_type := b_workshop ; 15 :
126088: LD_ADDR_OWVAR 42
126092: PUSH
126093: LD_INT 2
126095: ST_TO_ADDR
126096: GO 126496
126098: LD_INT 15
126100: DOUBLE
126101: EQUAL
126102: IFTRUE 126106
126104: GO 126117
126106: POP
// bc_type := b_factory ; 16 :
126107: LD_ADDR_OWVAR 42
126111: PUSH
126112: LD_INT 3
126114: ST_TO_ADDR
126115: GO 126496
126117: LD_INT 16
126119: DOUBLE
126120: EQUAL
126121: IFTRUE 126125
126123: GO 126136
126125: POP
// bc_type := b_ext_gun ; 17 :
126126: LD_ADDR_OWVAR 42
126130: PUSH
126131: LD_INT 17
126133: ST_TO_ADDR
126134: GO 126496
126136: LD_INT 17
126138: DOUBLE
126139: EQUAL
126140: IFTRUE 126144
126142: GO 126172
126144: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
126145: LD_ADDR_OWVAR 42
126149: PUSH
126150: LD_INT 19
126152: PUSH
126153: LD_INT 23
126155: PUSH
126156: LD_INT 19
126158: PUSH
126159: EMPTY
126160: LIST
126161: LIST
126162: LIST
126163: PUSH
126164: LD_VAR 0 1
126168: ARRAY
126169: ST_TO_ADDR
126170: GO 126496
126172: LD_INT 18
126174: DOUBLE
126175: EQUAL
126176: IFTRUE 126180
126178: GO 126191
126180: POP
// bc_type := b_ext_radar ; 19 :
126181: LD_ADDR_OWVAR 42
126185: PUSH
126186: LD_INT 20
126188: ST_TO_ADDR
126189: GO 126496
126191: LD_INT 19
126193: DOUBLE
126194: EQUAL
126195: IFTRUE 126199
126197: GO 126210
126199: POP
// bc_type := b_ext_radio ; 20 :
126200: LD_ADDR_OWVAR 42
126204: PUSH
126205: LD_INT 22
126207: ST_TO_ADDR
126208: GO 126496
126210: LD_INT 20
126212: DOUBLE
126213: EQUAL
126214: IFTRUE 126218
126216: GO 126229
126218: POP
// bc_type := b_ext_siberium ; 21 :
126219: LD_ADDR_OWVAR 42
126223: PUSH
126224: LD_INT 21
126226: ST_TO_ADDR
126227: GO 126496
126229: LD_INT 21
126231: DOUBLE
126232: EQUAL
126233: IFTRUE 126237
126235: GO 126248
126237: POP
// bc_type := b_ext_computer ; 22 :
126238: LD_ADDR_OWVAR 42
126242: PUSH
126243: LD_INT 24
126245: ST_TO_ADDR
126246: GO 126496
126248: LD_INT 22
126250: DOUBLE
126251: EQUAL
126252: IFTRUE 126256
126254: GO 126267
126256: POP
// bc_type := b_ext_track ; 23 :
126257: LD_ADDR_OWVAR 42
126261: PUSH
126262: LD_INT 16
126264: ST_TO_ADDR
126265: GO 126496
126267: LD_INT 23
126269: DOUBLE
126270: EQUAL
126271: IFTRUE 126275
126273: GO 126286
126275: POP
// bc_type := b_ext_laser ; 24 :
126276: LD_ADDR_OWVAR 42
126280: PUSH
126281: LD_INT 25
126283: ST_TO_ADDR
126284: GO 126496
126286: LD_INT 24
126288: DOUBLE
126289: EQUAL
126290: IFTRUE 126294
126292: GO 126305
126294: POP
// bc_type := b_control_tower ; 25 :
126295: LD_ADDR_OWVAR 42
126299: PUSH
126300: LD_INT 36
126302: ST_TO_ADDR
126303: GO 126496
126305: LD_INT 25
126307: DOUBLE
126308: EQUAL
126309: IFTRUE 126313
126311: GO 126324
126313: POP
// bc_type := b_breastwork ; 26 :
126314: LD_ADDR_OWVAR 42
126318: PUSH
126319: LD_INT 31
126321: ST_TO_ADDR
126322: GO 126496
126324: LD_INT 26
126326: DOUBLE
126327: EQUAL
126328: IFTRUE 126332
126330: GO 126343
126332: POP
// bc_type := b_bunker ; 27 :
126333: LD_ADDR_OWVAR 42
126337: PUSH
126338: LD_INT 32
126340: ST_TO_ADDR
126341: GO 126496
126343: LD_INT 27
126345: DOUBLE
126346: EQUAL
126347: IFTRUE 126351
126349: GO 126362
126351: POP
// bc_type := b_turret ; 28 :
126352: LD_ADDR_OWVAR 42
126356: PUSH
126357: LD_INT 33
126359: ST_TO_ADDR
126360: GO 126496
126362: LD_INT 28
126364: DOUBLE
126365: EQUAL
126366: IFTRUE 126370
126368: GO 126381
126370: POP
// bc_type := b_armoury ; 29 :
126371: LD_ADDR_OWVAR 42
126375: PUSH
126376: LD_INT 4
126378: ST_TO_ADDR
126379: GO 126496
126381: LD_INT 29
126383: DOUBLE
126384: EQUAL
126385: IFTRUE 126389
126387: GO 126400
126389: POP
// bc_type := b_barracks ; 30 :
126390: LD_ADDR_OWVAR 42
126394: PUSH
126395: LD_INT 5
126397: ST_TO_ADDR
126398: GO 126496
126400: LD_INT 30
126402: DOUBLE
126403: EQUAL
126404: IFTRUE 126408
126406: GO 126419
126408: POP
// bc_type := b_solar_power ; 31 :
126409: LD_ADDR_OWVAR 42
126413: PUSH
126414: LD_INT 27
126416: ST_TO_ADDR
126417: GO 126496
126419: LD_INT 31
126421: DOUBLE
126422: EQUAL
126423: IFTRUE 126427
126425: GO 126438
126427: POP
// bc_type := b_oil_power ; 32 :
126428: LD_ADDR_OWVAR 42
126432: PUSH
126433: LD_INT 26
126435: ST_TO_ADDR
126436: GO 126496
126438: LD_INT 32
126440: DOUBLE
126441: EQUAL
126442: IFTRUE 126446
126444: GO 126457
126446: POP
// bc_type := b_siberite_power ; 33 :
126447: LD_ADDR_OWVAR 42
126451: PUSH
126452: LD_INT 28
126454: ST_TO_ADDR
126455: GO 126496
126457: LD_INT 33
126459: DOUBLE
126460: EQUAL
126461: IFTRUE 126465
126463: GO 126476
126465: POP
// bc_type := b_oil_mine ; 34 :
126466: LD_ADDR_OWVAR 42
126470: PUSH
126471: LD_INT 29
126473: ST_TO_ADDR
126474: GO 126496
126476: LD_INT 34
126478: DOUBLE
126479: EQUAL
126480: IFTRUE 126484
126482: GO 126495
126484: POP
// bc_type := b_siberite_mine ; end ;
126485: LD_ADDR_OWVAR 42
126489: PUSH
126490: LD_INT 30
126492: ST_TO_ADDR
126493: GO 126496
126495: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
126496: LD_ADDR_VAR 0 8
126500: PUSH
126501: LD_VAR 0 5
126505: PPUSH
126506: LD_VAR 0 6
126510: PPUSH
126511: LD_VAR 0 3
126515: PPUSH
126516: CALL_OW 47
126520: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
126521: LD_OWVAR 42
126525: PUSH
126526: LD_INT 32
126528: PUSH
126529: LD_INT 33
126531: PUSH
126532: EMPTY
126533: LIST
126534: LIST
126535: IN
126536: IFFALSE 126552
// PlaceWeaponTurret ( b , weapon ) ;
126538: LD_VAR 0 8
126542: PPUSH
126543: LD_VAR 0 4
126547: PPUSH
126548: CALL_OW 431
// end ;
126552: LD_VAR 0 7
126556: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
126557: LD_INT 0
126559: PPUSH
126560: PPUSH
126561: PPUSH
126562: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
126563: LD_ADDR_VAR 0 4
126567: PUSH
126568: LD_INT 22
126570: PUSH
126571: LD_OWVAR 2
126575: PUSH
126576: EMPTY
126577: LIST
126578: LIST
126579: PUSH
126580: LD_INT 2
126582: PUSH
126583: LD_INT 30
126585: PUSH
126586: LD_INT 0
126588: PUSH
126589: EMPTY
126590: LIST
126591: LIST
126592: PUSH
126593: LD_INT 30
126595: PUSH
126596: LD_INT 1
126598: PUSH
126599: EMPTY
126600: LIST
126601: LIST
126602: PUSH
126603: EMPTY
126604: LIST
126605: LIST
126606: LIST
126607: PUSH
126608: EMPTY
126609: LIST
126610: LIST
126611: PPUSH
126612: CALL_OW 69
126616: ST_TO_ADDR
// if not tmp then
126617: LD_VAR 0 4
126621: NOT
126622: IFFALSE 126626
// exit ;
126624: GO 126685
// for i in tmp do
126626: LD_ADDR_VAR 0 2
126630: PUSH
126631: LD_VAR 0 4
126635: PUSH
126636: FOR_IN
126637: IFFALSE 126683
// for j = 1 to 3 do
126639: LD_ADDR_VAR 0 3
126643: PUSH
126644: DOUBLE
126645: LD_INT 1
126647: DEC
126648: ST_TO_ADDR
126649: LD_INT 3
126651: PUSH
126652: FOR_TO
126653: IFFALSE 126679
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
126655: LD_VAR 0 2
126659: PPUSH
126660: CALL_OW 274
126664: PPUSH
126665: LD_VAR 0 3
126669: PPUSH
126670: LD_INT 99999
126672: PPUSH
126673: CALL_OW 277
126677: GO 126652
126679: POP
126680: POP
126681: GO 126636
126683: POP
126684: POP
// end ;
126685: LD_VAR 0 1
126689: RET
// export function hHackSetLevel10 ; var i , j ; begin
126690: LD_INT 0
126692: PPUSH
126693: PPUSH
126694: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
126695: LD_ADDR_VAR 0 2
126699: PUSH
126700: LD_INT 21
126702: PUSH
126703: LD_INT 1
126705: PUSH
126706: EMPTY
126707: LIST
126708: LIST
126709: PPUSH
126710: CALL_OW 69
126714: PUSH
126715: FOR_IN
126716: IFFALSE 126768
// if IsSelected ( i ) then
126718: LD_VAR 0 2
126722: PPUSH
126723: CALL_OW 306
126727: IFFALSE 126766
// begin for j := 1 to 4 do
126729: LD_ADDR_VAR 0 3
126733: PUSH
126734: DOUBLE
126735: LD_INT 1
126737: DEC
126738: ST_TO_ADDR
126739: LD_INT 4
126741: PUSH
126742: FOR_TO
126743: IFFALSE 126764
// SetSkill ( i , j , 10 ) ;
126745: LD_VAR 0 2
126749: PPUSH
126750: LD_VAR 0 3
126754: PPUSH
126755: LD_INT 10
126757: PPUSH
126758: CALL_OW 237
126762: GO 126742
126764: POP
126765: POP
// end ;
126766: GO 126715
126768: POP
126769: POP
// end ;
126770: LD_VAR 0 1
126774: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
126775: LD_INT 0
126777: PPUSH
126778: PPUSH
126779: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
126780: LD_ADDR_VAR 0 2
126784: PUSH
126785: LD_INT 22
126787: PUSH
126788: LD_OWVAR 2
126792: PUSH
126793: EMPTY
126794: LIST
126795: LIST
126796: PUSH
126797: LD_INT 21
126799: PUSH
126800: LD_INT 1
126802: PUSH
126803: EMPTY
126804: LIST
126805: LIST
126806: PUSH
126807: EMPTY
126808: LIST
126809: LIST
126810: PPUSH
126811: CALL_OW 69
126815: PUSH
126816: FOR_IN
126817: IFFALSE 126858
// begin for j := 1 to 4 do
126819: LD_ADDR_VAR 0 3
126823: PUSH
126824: DOUBLE
126825: LD_INT 1
126827: DEC
126828: ST_TO_ADDR
126829: LD_INT 4
126831: PUSH
126832: FOR_TO
126833: IFFALSE 126854
// SetSkill ( i , j , 10 ) ;
126835: LD_VAR 0 2
126839: PPUSH
126840: LD_VAR 0 3
126844: PPUSH
126845: LD_INT 10
126847: PPUSH
126848: CALL_OW 237
126852: GO 126832
126854: POP
126855: POP
// end ;
126856: GO 126816
126858: POP
126859: POP
// end ;
126860: LD_VAR 0 1
126864: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
126865: LD_INT 0
126867: PPUSH
// uc_side := your_side ;
126868: LD_ADDR_OWVAR 20
126872: PUSH
126873: LD_OWVAR 2
126877: ST_TO_ADDR
// uc_nation := nation ;
126878: LD_ADDR_OWVAR 21
126882: PUSH
126883: LD_VAR 0 1
126887: ST_TO_ADDR
// InitHc ;
126888: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
126892: LD_INT 0
126894: PPUSH
126895: LD_VAR 0 2
126899: PPUSH
126900: LD_VAR 0 3
126904: PPUSH
126905: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
126909: LD_VAR 0 4
126913: PPUSH
126914: LD_VAR 0 5
126918: PPUSH
126919: CALL_OW 428
126923: PUSH
126924: LD_INT 0
126926: EQUAL
126927: IFFALSE 126951
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
126929: CALL_OW 44
126933: PPUSH
126934: LD_VAR 0 4
126938: PPUSH
126939: LD_VAR 0 5
126943: PPUSH
126944: LD_INT 1
126946: PPUSH
126947: CALL_OW 48
// end ;
126951: LD_VAR 0 6
126955: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
126956: LD_INT 0
126958: PPUSH
126959: PPUSH
// uc_side := your_side ;
126960: LD_ADDR_OWVAR 20
126964: PUSH
126965: LD_OWVAR 2
126969: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
126970: LD_VAR 0 1
126974: PUSH
126975: LD_INT 1
126977: PUSH
126978: LD_INT 2
126980: PUSH
126981: LD_INT 3
126983: PUSH
126984: LD_INT 4
126986: PUSH
126987: LD_INT 5
126989: PUSH
126990: EMPTY
126991: LIST
126992: LIST
126993: LIST
126994: LIST
126995: LIST
126996: IN
126997: IFFALSE 127009
// uc_nation := nation_american else
126999: LD_ADDR_OWVAR 21
127003: PUSH
127004: LD_INT 1
127006: ST_TO_ADDR
127007: GO 127052
// if chassis in [ 11 , 12 , 13 , 14 ] then
127009: LD_VAR 0 1
127013: PUSH
127014: LD_INT 11
127016: PUSH
127017: LD_INT 12
127019: PUSH
127020: LD_INT 13
127022: PUSH
127023: LD_INT 14
127025: PUSH
127026: EMPTY
127027: LIST
127028: LIST
127029: LIST
127030: LIST
127031: IN
127032: IFFALSE 127044
// uc_nation := nation_arabian else
127034: LD_ADDR_OWVAR 21
127038: PUSH
127039: LD_INT 2
127041: ST_TO_ADDR
127042: GO 127052
// uc_nation := nation_russian ;
127044: LD_ADDR_OWVAR 21
127048: PUSH
127049: LD_INT 3
127051: ST_TO_ADDR
// vc_chassis := chassis ;
127052: LD_ADDR_OWVAR 37
127056: PUSH
127057: LD_VAR 0 1
127061: ST_TO_ADDR
// vc_engine := engine ;
127062: LD_ADDR_OWVAR 39
127066: PUSH
127067: LD_VAR 0 2
127071: ST_TO_ADDR
// vc_control := control ;
127072: LD_ADDR_OWVAR 38
127076: PUSH
127077: LD_VAR 0 3
127081: ST_TO_ADDR
// vc_weapon := weapon ;
127082: LD_ADDR_OWVAR 40
127086: PUSH
127087: LD_VAR 0 4
127091: ST_TO_ADDR
// un := CreateVehicle ;
127092: LD_ADDR_VAR 0 8
127096: PUSH
127097: CALL_OW 45
127101: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
127102: LD_VAR 0 8
127106: PPUSH
127107: LD_INT 0
127109: PPUSH
127110: LD_INT 5
127112: PPUSH
127113: CALL_OW 12
127117: PPUSH
127118: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
127122: LD_VAR 0 8
127126: PPUSH
127127: LD_VAR 0 5
127131: PPUSH
127132: LD_VAR 0 6
127136: PPUSH
127137: LD_INT 1
127139: PPUSH
127140: CALL_OW 48
// end ;
127144: LD_VAR 0 7
127148: RET
// export hInvincible ; every 1 do
127149: GO 127151
127151: DISABLE
// hInvincible := [ ] ;
127152: LD_ADDR_EXP 205
127156: PUSH
127157: EMPTY
127158: ST_TO_ADDR
127159: END
// every 10 do var i ;
127160: GO 127162
127162: DISABLE
127163: LD_INT 0
127165: PPUSH
// begin enable ;
127166: ENABLE
// if not hInvincible then
127167: LD_EXP 205
127171: NOT
127172: IFFALSE 127176
// exit ;
127174: GO 127220
// for i in hInvincible do
127176: LD_ADDR_VAR 0 1
127180: PUSH
127181: LD_EXP 205
127185: PUSH
127186: FOR_IN
127187: IFFALSE 127218
// if GetLives ( i ) < 1000 then
127189: LD_VAR 0 1
127193: PPUSH
127194: CALL_OW 256
127198: PUSH
127199: LD_INT 1000
127201: LESS
127202: IFFALSE 127216
// SetLives ( i , 1000 ) ;
127204: LD_VAR 0 1
127208: PPUSH
127209: LD_INT 1000
127211: PPUSH
127212: CALL_OW 234
127216: GO 127186
127218: POP
127219: POP
// end ;
127220: PPOPN 1
127222: END
// export function hHackInvincible ; var i ; begin
127223: LD_INT 0
127225: PPUSH
127226: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
127227: LD_ADDR_VAR 0 2
127231: PUSH
127232: LD_INT 2
127234: PUSH
127235: LD_INT 21
127237: PUSH
127238: LD_INT 1
127240: PUSH
127241: EMPTY
127242: LIST
127243: LIST
127244: PUSH
127245: LD_INT 21
127247: PUSH
127248: LD_INT 2
127250: PUSH
127251: EMPTY
127252: LIST
127253: LIST
127254: PUSH
127255: EMPTY
127256: LIST
127257: LIST
127258: LIST
127259: PPUSH
127260: CALL_OW 69
127264: PUSH
127265: FOR_IN
127266: IFFALSE 127327
// if IsSelected ( i ) then
127268: LD_VAR 0 2
127272: PPUSH
127273: CALL_OW 306
127277: IFFALSE 127325
// begin if i in hInvincible then
127279: LD_VAR 0 2
127283: PUSH
127284: LD_EXP 205
127288: IN
127289: IFFALSE 127309
// hInvincible := hInvincible diff i else
127291: LD_ADDR_EXP 205
127295: PUSH
127296: LD_EXP 205
127300: PUSH
127301: LD_VAR 0 2
127305: DIFF
127306: ST_TO_ADDR
127307: GO 127325
// hInvincible := hInvincible union i ;
127309: LD_ADDR_EXP 205
127313: PUSH
127314: LD_EXP 205
127318: PUSH
127319: LD_VAR 0 2
127323: UNION
127324: ST_TO_ADDR
// end ;
127325: GO 127265
127327: POP
127328: POP
// end ;
127329: LD_VAR 0 1
127333: RET
// export function hHackInvisible ; var i , j ; begin
127334: LD_INT 0
127336: PPUSH
127337: PPUSH
127338: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
127339: LD_ADDR_VAR 0 2
127343: PUSH
127344: LD_INT 21
127346: PUSH
127347: LD_INT 1
127349: PUSH
127350: EMPTY
127351: LIST
127352: LIST
127353: PPUSH
127354: CALL_OW 69
127358: PUSH
127359: FOR_IN
127360: IFFALSE 127384
// if IsSelected ( i ) then
127362: LD_VAR 0 2
127366: PPUSH
127367: CALL_OW 306
127371: IFFALSE 127382
// ComForceInvisible ( i ) ;
127373: LD_VAR 0 2
127377: PPUSH
127378: CALL_OW 496
127382: GO 127359
127384: POP
127385: POP
// end ;
127386: LD_VAR 0 1
127390: RET
// export function hHackChangeYourSide ; begin
127391: LD_INT 0
127393: PPUSH
// if your_side = 8 then
127394: LD_OWVAR 2
127398: PUSH
127399: LD_INT 8
127401: EQUAL
127402: IFFALSE 127414
// your_side := 0 else
127404: LD_ADDR_OWVAR 2
127408: PUSH
127409: LD_INT 0
127411: ST_TO_ADDR
127412: GO 127428
// your_side := your_side + 1 ;
127414: LD_ADDR_OWVAR 2
127418: PUSH
127419: LD_OWVAR 2
127423: PUSH
127424: LD_INT 1
127426: PLUS
127427: ST_TO_ADDR
// end ;
127428: LD_VAR 0 1
127432: RET
// export function hHackChangeUnitSide ; var i , j ; begin
127433: LD_INT 0
127435: PPUSH
127436: PPUSH
127437: PPUSH
// for i in all_units do
127438: LD_ADDR_VAR 0 2
127442: PUSH
127443: LD_OWVAR 3
127447: PUSH
127448: FOR_IN
127449: IFFALSE 127527
// if IsSelected ( i ) then
127451: LD_VAR 0 2
127455: PPUSH
127456: CALL_OW 306
127460: IFFALSE 127525
// begin j := GetSide ( i ) ;
127462: LD_ADDR_VAR 0 3
127466: PUSH
127467: LD_VAR 0 2
127471: PPUSH
127472: CALL_OW 255
127476: ST_TO_ADDR
// if j = 8 then
127477: LD_VAR 0 3
127481: PUSH
127482: LD_INT 8
127484: EQUAL
127485: IFFALSE 127497
// j := 0 else
127487: LD_ADDR_VAR 0 3
127491: PUSH
127492: LD_INT 0
127494: ST_TO_ADDR
127495: GO 127511
// j := j + 1 ;
127497: LD_ADDR_VAR 0 3
127501: PUSH
127502: LD_VAR 0 3
127506: PUSH
127507: LD_INT 1
127509: PLUS
127510: ST_TO_ADDR
// SetSide ( i , j ) ;
127511: LD_VAR 0 2
127515: PPUSH
127516: LD_VAR 0 3
127520: PPUSH
127521: CALL_OW 235
// end ;
127525: GO 127448
127527: POP
127528: POP
// end ;
127529: LD_VAR 0 1
127533: RET
// export function hHackFog ; begin
127534: LD_INT 0
127536: PPUSH
// FogOff ( true ) ;
127537: LD_INT 1
127539: PPUSH
127540: CALL_OW 344
// end ;
127544: LD_VAR 0 1
127548: RET
// export function hHackTeleport ( unit , x , y ) ; begin
127549: LD_INT 0
127551: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
127552: LD_VAR 0 1
127556: PPUSH
127557: LD_VAR 0 2
127561: PPUSH
127562: LD_VAR 0 3
127566: PPUSH
127567: LD_INT 1
127569: PPUSH
127570: LD_INT 1
127572: PPUSH
127573: CALL_OW 483
// CenterOnXY ( x , y ) ;
127577: LD_VAR 0 2
127581: PPUSH
127582: LD_VAR 0 3
127586: PPUSH
127587: CALL_OW 84
// end ;
127591: LD_VAR 0 4
127595: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
127596: LD_INT 0
127598: PPUSH
127599: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
127600: LD_VAR 0 1
127604: NOT
127605: PUSH
127606: LD_VAR 0 2
127610: PPUSH
127611: LD_VAR 0 3
127615: PPUSH
127616: CALL_OW 488
127620: NOT
127621: OR
127622: PUSH
127623: LD_VAR 0 1
127627: PPUSH
127628: CALL_OW 266
127632: PUSH
127633: LD_INT 3
127635: NONEQUAL
127636: PUSH
127637: LD_VAR 0 1
127641: PPUSH
127642: CALL_OW 247
127646: PUSH
127647: LD_INT 1
127649: EQUAL
127650: NOT
127651: AND
127652: OR
127653: IFFALSE 127657
// exit ;
127655: GO 127939
// if GetType ( factory ) = unit_human then
127657: LD_VAR 0 1
127661: PPUSH
127662: CALL_OW 247
127666: PUSH
127667: LD_INT 1
127669: EQUAL
127670: IFFALSE 127687
// factory := IsInUnit ( factory ) ;
127672: LD_ADDR_VAR 0 1
127676: PUSH
127677: LD_VAR 0 1
127681: PPUSH
127682: CALL_OW 310
127686: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
127687: LD_VAR 0 1
127691: PPUSH
127692: CALL_OW 266
127696: PUSH
127697: LD_INT 3
127699: NONEQUAL
127700: IFFALSE 127704
// exit ;
127702: GO 127939
// for i := 1 to Count ( factoryWaypoints ) do
127704: LD_ADDR_VAR 0 5
127708: PUSH
127709: DOUBLE
127710: LD_INT 1
127712: DEC
127713: ST_TO_ADDR
127714: LD_EXP 206
127718: PPUSH
127719: CALL 72395 0 1
127723: PUSH
127724: FOR_TO
127725: IFFALSE 127887
// begin if HexInfo ( x , y ) = factoryWaypoints [ i ] [ 2 ] then
127727: LD_VAR 0 2
127731: PPUSH
127732: LD_VAR 0 3
127736: PPUSH
127737: CALL_OW 428
127741: PUSH
127742: LD_EXP 206
127746: PUSH
127747: LD_VAR 0 5
127751: ARRAY
127752: PUSH
127753: LD_INT 2
127755: ARRAY
127756: EQUAL
127757: IFFALSE 127789
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
127759: LD_ADDR_EXP 206
127763: PUSH
127764: LD_EXP 206
127768: PPUSH
127769: LD_VAR 0 5
127773: PPUSH
127774: CALL_OW 3
127778: ST_TO_ADDR
// UpdateFactoryWaypoints ;
127779: CALL 127944 0 0
// exit ;
127783: POP
127784: POP
127785: GO 127939
// end else
127787: GO 127885
// if factory = factoryWaypoints [ i ] [ 2 ] then
127789: LD_VAR 0 1
127793: PUSH
127794: LD_EXP 206
127798: PUSH
127799: LD_VAR 0 5
127803: ARRAY
127804: PUSH
127805: LD_INT 2
127807: ARRAY
127808: EQUAL
127809: IFFALSE 127885
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
127811: LD_ADDR_EXP 206
127815: PUSH
127816: LD_EXP 206
127820: PPUSH
127821: LD_VAR 0 5
127825: PPUSH
127826: CALL_OW 3
127830: ST_TO_ADDR
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
127831: LD_ADDR_EXP 206
127835: PUSH
127836: LD_EXP 206
127840: PPUSH
127841: LD_VAR 0 1
127845: PPUSH
127846: CALL_OW 255
127850: PUSH
127851: LD_VAR 0 1
127855: PUSH
127856: LD_VAR 0 2
127860: PUSH
127861: LD_VAR 0 3
127865: PUSH
127866: EMPTY
127867: LIST
127868: LIST
127869: LIST
127870: LIST
127871: PPUSH
127872: CALL 108004 0 2
127876: ST_TO_ADDR
// UpdateFactoryWaypoints ;
127877: CALL 127944 0 0
// exit ;
127881: POP
127882: POP
127883: GO 127939
// end ; end ;
127885: GO 127724
127887: POP
127888: POP
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
127889: LD_ADDR_EXP 206
127893: PUSH
127894: LD_EXP 206
127898: PPUSH
127899: LD_VAR 0 1
127903: PPUSH
127904: CALL_OW 255
127908: PUSH
127909: LD_VAR 0 1
127913: PUSH
127914: LD_VAR 0 2
127918: PUSH
127919: LD_VAR 0 3
127923: PUSH
127924: EMPTY
127925: LIST
127926: LIST
127927: LIST
127928: LIST
127929: PPUSH
127930: CALL 108004 0 2
127934: ST_TO_ADDR
// UpdateFactoryWaypoints ;
127935: CALL 127944 0 0
// end ;
127939: LD_VAR 0 4
127943: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
127944: LD_INT 0
127946: PPUSH
127947: PPUSH
127948: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
127949: LD_STRING resetFactoryWaypoint();
127951: PPUSH
127952: CALL_OW 559
// if factoryWaypoints then
127956: LD_EXP 206
127960: IFFALSE 128081
// begin list := factoryWaypoints ;
127962: LD_ADDR_VAR 0 3
127966: PUSH
127967: LD_EXP 206
127971: ST_TO_ADDR
// for i := 1 to list do
127972: LD_ADDR_VAR 0 2
127976: PUSH
127977: DOUBLE
127978: LD_INT 1
127980: DEC
127981: ST_TO_ADDR
127982: LD_VAR 0 3
127986: PUSH
127987: FOR_TO
127988: IFFALSE 128079
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
127990: LD_STRING setFactoryWaypointXY(
127992: PUSH
127993: LD_VAR 0 3
127997: PUSH
127998: LD_VAR 0 2
128002: ARRAY
128003: PUSH
128004: LD_INT 1
128006: ARRAY
128007: STR
128008: PUSH
128009: LD_STRING ,
128011: STR
128012: PUSH
128013: LD_VAR 0 3
128017: PUSH
128018: LD_VAR 0 2
128022: ARRAY
128023: PUSH
128024: LD_INT 2
128026: ARRAY
128027: STR
128028: PUSH
128029: LD_STRING ,
128031: STR
128032: PUSH
128033: LD_VAR 0 3
128037: PUSH
128038: LD_VAR 0 2
128042: ARRAY
128043: PUSH
128044: LD_INT 3
128046: ARRAY
128047: STR
128048: PUSH
128049: LD_STRING ,
128051: STR
128052: PUSH
128053: LD_VAR 0 3
128057: PUSH
128058: LD_VAR 0 2
128062: ARRAY
128063: PUSH
128064: LD_INT 4
128066: ARRAY
128067: STR
128068: PUSH
128069: LD_STRING )
128071: STR
128072: PPUSH
128073: CALL_OW 559
128077: GO 127987
128079: POP
128080: POP
// end ; end ;
128081: LD_VAR 0 1
128085: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
128086: LD_INT 0
128088: PPUSH
// if HexInfo ( x , y ) = warehouse then
128089: LD_VAR 0 2
128093: PPUSH
128094: LD_VAR 0 3
128098: PPUSH
128099: CALL_OW 428
128103: PUSH
128104: LD_VAR 0 1
128108: EQUAL
128109: IFFALSE 128136
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
128111: LD_ADDR_EXP 207
128115: PUSH
128116: LD_EXP 207
128120: PPUSH
128121: LD_VAR 0 1
128125: PPUSH
128126: LD_INT 0
128128: PPUSH
128129: CALL_OW 1
128133: ST_TO_ADDR
128134: GO 128187
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
128136: LD_ADDR_EXP 207
128140: PUSH
128141: LD_EXP 207
128145: PPUSH
128146: LD_VAR 0 1
128150: PPUSH
128151: LD_VAR 0 1
128155: PPUSH
128156: CALL_OW 255
128160: PUSH
128161: LD_VAR 0 1
128165: PUSH
128166: LD_VAR 0 2
128170: PUSH
128171: LD_VAR 0 3
128175: PUSH
128176: EMPTY
128177: LIST
128178: LIST
128179: LIST
128180: LIST
128181: PPUSH
128182: CALL_OW 1
128186: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
128187: CALL 128196 0 0
// end ;
128191: LD_VAR 0 4
128195: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
128196: LD_INT 0
128198: PPUSH
128199: PPUSH
128200: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
128201: LD_STRING resetWarehouseGatheringPoints();
128203: PPUSH
128204: CALL_OW 559
// if warehouseGatheringPoints then
128208: LD_EXP 207
128212: IFFALSE 128338
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
128214: LD_ADDR_VAR 0 3
128218: PUSH
128219: LD_EXP 207
128223: PPUSH
128224: CALL 111766 0 1
128228: ST_TO_ADDR
// for i := 1 to list do
128229: LD_ADDR_VAR 0 2
128233: PUSH
128234: DOUBLE
128235: LD_INT 1
128237: DEC
128238: ST_TO_ADDR
128239: LD_VAR 0 3
128243: PUSH
128244: FOR_TO
128245: IFFALSE 128336
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
128247: LD_STRING setWarehouseGatheringPointXY(
128249: PUSH
128250: LD_VAR 0 3
128254: PUSH
128255: LD_VAR 0 2
128259: ARRAY
128260: PUSH
128261: LD_INT 1
128263: ARRAY
128264: STR
128265: PUSH
128266: LD_STRING ,
128268: STR
128269: PUSH
128270: LD_VAR 0 3
128274: PUSH
128275: LD_VAR 0 2
128279: ARRAY
128280: PUSH
128281: LD_INT 2
128283: ARRAY
128284: STR
128285: PUSH
128286: LD_STRING ,
128288: STR
128289: PUSH
128290: LD_VAR 0 3
128294: PUSH
128295: LD_VAR 0 2
128299: ARRAY
128300: PUSH
128301: LD_INT 3
128303: ARRAY
128304: STR
128305: PUSH
128306: LD_STRING ,
128308: STR
128309: PUSH
128310: LD_VAR 0 3
128314: PUSH
128315: LD_VAR 0 2
128319: ARRAY
128320: PUSH
128321: LD_INT 4
128323: ARRAY
128324: STR
128325: PUSH
128326: LD_STRING )
128328: STR
128329: PPUSH
128330: CALL_OW 559
128334: GO 128244
128336: POP
128337: POP
// end ; end ;
128338: LD_VAR 0 1
128342: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
128343: LD_EXP 207
128347: IFFALSE 129032
128349: GO 128351
128351: DISABLE
128352: LD_INT 0
128354: PPUSH
128355: PPUSH
128356: PPUSH
128357: PPUSH
128358: PPUSH
128359: PPUSH
128360: PPUSH
128361: PPUSH
128362: PPUSH
// begin enable ;
128363: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
128364: LD_ADDR_VAR 0 3
128368: PUSH
128369: LD_EXP 207
128373: PPUSH
128374: CALL 111766 0 1
128378: ST_TO_ADDR
// if not list then
128379: LD_VAR 0 3
128383: NOT
128384: IFFALSE 128388
// exit ;
128386: GO 129032
// for i := 1 to list do
128388: LD_ADDR_VAR 0 1
128392: PUSH
128393: DOUBLE
128394: LD_INT 1
128396: DEC
128397: ST_TO_ADDR
128398: LD_VAR 0 3
128402: PUSH
128403: FOR_TO
128404: IFFALSE 129030
// begin depot := list [ i ] [ 2 ] ;
128406: LD_ADDR_VAR 0 8
128410: PUSH
128411: LD_VAR 0 3
128415: PUSH
128416: LD_VAR 0 1
128420: ARRAY
128421: PUSH
128422: LD_INT 2
128424: ARRAY
128425: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
128426: LD_ADDR_VAR 0 5
128430: PUSH
128431: LD_VAR 0 3
128435: PUSH
128436: LD_VAR 0 1
128440: ARRAY
128441: PUSH
128442: LD_INT 1
128444: ARRAY
128445: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
128446: LD_VAR 0 8
128450: PPUSH
128451: CALL_OW 301
128455: PUSH
128456: LD_VAR 0 5
128460: PUSH
128461: LD_VAR 0 8
128465: PPUSH
128466: CALL_OW 255
128470: NONEQUAL
128471: OR
128472: IFFALSE 128501
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
128474: LD_ADDR_EXP 207
128478: PUSH
128479: LD_EXP 207
128483: PPUSH
128484: LD_VAR 0 8
128488: PPUSH
128489: LD_INT 0
128491: PPUSH
128492: CALL_OW 1
128496: ST_TO_ADDR
// exit ;
128497: POP
128498: POP
128499: GO 129032
// end ; x := list [ i ] [ 3 ] ;
128501: LD_ADDR_VAR 0 6
128505: PUSH
128506: LD_VAR 0 3
128510: PUSH
128511: LD_VAR 0 1
128515: ARRAY
128516: PUSH
128517: LD_INT 3
128519: ARRAY
128520: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
128521: LD_ADDR_VAR 0 7
128525: PUSH
128526: LD_VAR 0 3
128530: PUSH
128531: LD_VAR 0 1
128535: ARRAY
128536: PUSH
128537: LD_INT 4
128539: ARRAY
128540: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
128541: LD_ADDR_VAR 0 9
128545: PUSH
128546: LD_VAR 0 6
128550: PPUSH
128551: LD_VAR 0 7
128555: PPUSH
128556: LD_INT 16
128558: PPUSH
128559: CALL 110350 0 3
128563: ST_TO_ADDR
// if not cratesNearbyPoint then
128564: LD_VAR 0 9
128568: NOT
128569: IFFALSE 128575
// exit ;
128571: POP
128572: POP
128573: GO 129032
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
128575: LD_ADDR_VAR 0 4
128579: PUSH
128580: LD_INT 22
128582: PUSH
128583: LD_VAR 0 5
128587: PUSH
128588: EMPTY
128589: LIST
128590: LIST
128591: PUSH
128592: LD_INT 3
128594: PUSH
128595: LD_INT 60
128597: PUSH
128598: EMPTY
128599: LIST
128600: PUSH
128601: EMPTY
128602: LIST
128603: LIST
128604: PUSH
128605: LD_INT 91
128607: PUSH
128608: LD_VAR 0 8
128612: PUSH
128613: LD_INT 6
128615: PUSH
128616: EMPTY
128617: LIST
128618: LIST
128619: LIST
128620: PUSH
128621: LD_INT 2
128623: PUSH
128624: LD_INT 25
128626: PUSH
128627: LD_INT 2
128629: PUSH
128630: EMPTY
128631: LIST
128632: LIST
128633: PUSH
128634: LD_INT 25
128636: PUSH
128637: LD_INT 16
128639: PUSH
128640: EMPTY
128641: LIST
128642: LIST
128643: PUSH
128644: EMPTY
128645: LIST
128646: LIST
128647: LIST
128648: PUSH
128649: EMPTY
128650: LIST
128651: LIST
128652: LIST
128653: LIST
128654: PPUSH
128655: CALL_OW 69
128659: PUSH
128660: LD_VAR 0 8
128664: PPUSH
128665: CALL_OW 313
128669: PPUSH
128670: LD_INT 3
128672: PUSH
128673: LD_INT 60
128675: PUSH
128676: EMPTY
128677: LIST
128678: PUSH
128679: EMPTY
128680: LIST
128681: LIST
128682: PUSH
128683: LD_INT 2
128685: PUSH
128686: LD_INT 25
128688: PUSH
128689: LD_INT 2
128691: PUSH
128692: EMPTY
128693: LIST
128694: LIST
128695: PUSH
128696: LD_INT 25
128698: PUSH
128699: LD_INT 16
128701: PUSH
128702: EMPTY
128703: LIST
128704: LIST
128705: PUSH
128706: EMPTY
128707: LIST
128708: LIST
128709: LIST
128710: PUSH
128711: EMPTY
128712: LIST
128713: LIST
128714: PPUSH
128715: CALL_OW 72
128719: UNION
128720: ST_TO_ADDR
// if tmp then
128721: LD_VAR 0 4
128725: IFFALSE 128805
// begin tmp := ShrinkArray ( tmp , 3 ) ;
128727: LD_ADDR_VAR 0 4
128731: PUSH
128732: LD_VAR 0 4
128736: PPUSH
128737: LD_INT 3
128739: PPUSH
128740: CALL 108319 0 2
128744: ST_TO_ADDR
// for j in tmp do
128745: LD_ADDR_VAR 0 2
128749: PUSH
128750: LD_VAR 0 4
128754: PUSH
128755: FOR_IN
128756: IFFALSE 128799
// begin if IsInUnit ( j ) then
128758: LD_VAR 0 2
128762: PPUSH
128763: CALL_OW 310
128767: IFFALSE 128778
// ComExit ( j ) ;
128769: LD_VAR 0 2
128773: PPUSH
128774: CALL 108402 0 1
// AddComCollect ( j , x , y ) ;
128778: LD_VAR 0 2
128782: PPUSH
128783: LD_VAR 0 6
128787: PPUSH
128788: LD_VAR 0 7
128792: PPUSH
128793: CALL_OW 177
// end ;
128797: GO 128755
128799: POP
128800: POP
// exit ;
128801: POP
128802: POP
128803: GO 129032
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
128805: LD_ADDR_VAR 0 4
128809: PUSH
128810: LD_INT 22
128812: PUSH
128813: LD_VAR 0 5
128817: PUSH
128818: EMPTY
128819: LIST
128820: LIST
128821: PUSH
128822: LD_INT 91
128824: PUSH
128825: LD_VAR 0 8
128829: PUSH
128830: LD_INT 8
128832: PUSH
128833: EMPTY
128834: LIST
128835: LIST
128836: LIST
128837: PUSH
128838: LD_INT 2
128840: PUSH
128841: LD_INT 34
128843: PUSH
128844: LD_INT 12
128846: PUSH
128847: EMPTY
128848: LIST
128849: LIST
128850: PUSH
128851: LD_INT 34
128853: PUSH
128854: LD_INT 51
128856: PUSH
128857: EMPTY
128858: LIST
128859: LIST
128860: PUSH
128861: LD_INT 34
128863: PUSH
128864: LD_INT 32
128866: PUSH
128867: EMPTY
128868: LIST
128869: LIST
128870: PUSH
128871: LD_INT 34
128873: PUSH
128874: LD_INT 89
128876: PUSH
128877: EMPTY
128878: LIST
128879: LIST
128880: PUSH
128881: EMPTY
128882: LIST
128883: LIST
128884: LIST
128885: LIST
128886: LIST
128887: PUSH
128888: EMPTY
128889: LIST
128890: LIST
128891: LIST
128892: PPUSH
128893: CALL_OW 69
128897: ST_TO_ADDR
// if tmp then
128898: LD_VAR 0 4
128902: IFFALSE 129028
// begin for j in tmp do
128904: LD_ADDR_VAR 0 2
128908: PUSH
128909: LD_VAR 0 4
128913: PUSH
128914: FOR_IN
128915: IFFALSE 129026
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
128917: LD_VAR 0 2
128921: PPUSH
128922: CALL_OW 262
128926: PUSH
128927: LD_INT 3
128929: EQUAL
128930: PUSH
128931: LD_VAR 0 2
128935: PPUSH
128936: CALL_OW 261
128940: PUSH
128941: LD_INT 20
128943: GREATER
128944: OR
128945: PUSH
128946: LD_VAR 0 2
128950: PPUSH
128951: CALL_OW 314
128955: NOT
128956: AND
128957: PUSH
128958: LD_VAR 0 2
128962: PPUSH
128963: CALL_OW 263
128967: PUSH
128968: LD_INT 1
128970: NONEQUAL
128971: PUSH
128972: LD_VAR 0 2
128976: PPUSH
128977: CALL_OW 311
128981: OR
128982: AND
128983: IFFALSE 129024
// begin ComCollect ( j , x , y ) ;
128985: LD_VAR 0 2
128989: PPUSH
128990: LD_VAR 0 6
128994: PPUSH
128995: LD_VAR 0 7
128999: PPUSH
129000: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
129004: LD_VAR 0 2
129008: PPUSH
129009: LD_VAR 0 8
129013: PPUSH
129014: CALL_OW 172
// exit ;
129018: POP
129019: POP
129020: POP
129021: POP
129022: GO 129032
// end ;
129024: GO 128914
129026: POP
129027: POP
// end ; end ;
129028: GO 128403
129030: POP
129031: POP
// end ; end_of_file
129032: PPOPN 9
129034: END
// export function SOS_UnitDestroyed ( un ) ; begin
129035: LD_INT 0
129037: PPUSH
// ComRadiation ( un ) ;
129038: LD_VAR 0 1
129042: PPUSH
129043: CALL 130024 0 1
// end ;
129047: LD_VAR 0 2
129051: RET
// export function SOS_UnitKamikazed ( un ) ; begin
129052: LD_INT 0
129054: PPUSH
// ComRadiation ( un ) ;
129055: LD_VAR 0 1
129059: PPUSH
129060: CALL 130024 0 1
// end ;
129064: LD_VAR 0 2
129068: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
129069: LD_INT 0
129071: PPUSH
// end ;
129072: LD_VAR 0 4
129076: RET
// export function SOS_Command ( cmd ) ; begin
129077: LD_INT 0
129079: PPUSH
// end ;
129080: LD_VAR 0 2
129084: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
129085: LD_INT 0
129087: PPUSH
// end ;
129088: LD_VAR 0 6
129092: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var i , tag , driver , hex ; begin
129093: LD_INT 0
129095: PPUSH
129096: PPUSH
129097: PPUSH
129098: PPUSH
129099: PPUSH
// if not vehicle or not factory then
129100: LD_VAR 0 1
129104: NOT
129105: PUSH
129106: LD_VAR 0 2
129110: NOT
129111: OR
129112: IFFALSE 129116
// exit ;
129114: GO 129615
// if not factoryWaypoints then
129116: LD_EXP 206
129120: NOT
129121: IFFALSE 129125
// exit ;
129123: GO 129615
// for i := 1 to Count ( factoryWaypoints ) do
129125: LD_ADDR_VAR 0 4
129129: PUSH
129130: DOUBLE
129131: LD_INT 1
129133: DEC
129134: ST_TO_ADDR
129135: LD_EXP 206
129139: PPUSH
129140: CALL 72395 0 1
129144: PUSH
129145: FOR_TO
129146: IFFALSE 129613
// if factoryWaypoints [ i ] [ 2 ] = factory then
129148: LD_EXP 206
129152: PUSH
129153: LD_VAR 0 4
129157: ARRAY
129158: PUSH
129159: LD_INT 2
129161: ARRAY
129162: PUSH
129163: LD_VAR 0 2
129167: EQUAL
129168: IFFALSE 129611
// begin if GetControl ( vehicle ) = control_manual then
129170: LD_VAR 0 1
129174: PPUSH
129175: CALL_OW 263
129179: PUSH
129180: LD_INT 1
129182: EQUAL
129183: IFFALSE 129494
// begin driver := IsDrivenBy ( vehicle ) ;
129185: LD_ADDR_VAR 0 6
129189: PUSH
129190: LD_VAR 0 1
129194: PPUSH
129195: CALL_OW 311
129199: ST_TO_ADDR
// tag := GetTag ( driver ) ;
129200: LD_ADDR_VAR 0 5
129204: PUSH
129205: LD_VAR 0 6
129209: PPUSH
129210: CALL_OW 110
129214: ST_TO_ADDR
// if tag = tDriver or GetTag ( vehicle ) = tDriver then
129215: LD_VAR 0 5
129219: PUSH
129220: LD_INT 501
129222: EQUAL
129223: PUSH
129224: LD_VAR 0 1
129228: PPUSH
129229: CALL_OW 110
129233: PUSH
129234: LD_INT 501
129236: EQUAL
129237: OR
129238: IFFALSE 129244
// exit ;
129240: POP
129241: POP
129242: GO 129615
// if not HasTask ( driver ) then
129244: LD_VAR 0 6
129248: PPUSH
129249: CALL_OW 314
129253: NOT
129254: IFFALSE 129492
// begin SetTag ( driver , tDriver ) ;
129256: LD_VAR 0 6
129260: PPUSH
129261: LD_INT 501
129263: PPUSH
129264: CALL_OW 109
// SetTag ( vehicle , tDriver ) ;
129268: LD_VAR 0 1
129272: PPUSH
129273: LD_INT 501
129275: PPUSH
129276: CALL_OW 109
// hex := HexInfo ( factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
129280: LD_ADDR_VAR 0 7
129284: PUSH
129285: LD_EXP 206
129289: PUSH
129290: LD_VAR 0 4
129294: ARRAY
129295: PUSH
129296: LD_INT 3
129298: ARRAY
129299: PPUSH
129300: LD_EXP 206
129304: PUSH
129305: LD_VAR 0 4
129309: ARRAY
129310: PUSH
129311: LD_INT 4
129313: ARRAY
129314: PPUSH
129315: CALL_OW 428
129319: ST_TO_ADDR
// if hex then
129320: LD_VAR 0 7
129324: IFFALSE 129342
// ComMoveUnit ( driver , hex ) else
129326: LD_VAR 0 6
129330: PPUSH
129331: LD_VAR 0 7
129335: PPUSH
129336: CALL_OW 112
129340: GO 129381
// ComMoveXY ( driver , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
129342: LD_VAR 0 6
129346: PPUSH
129347: LD_EXP 206
129351: PUSH
129352: LD_VAR 0 4
129356: ARRAY
129357: PUSH
129358: LD_INT 3
129360: ARRAY
129361: PPUSH
129362: LD_EXP 206
129366: PUSH
129367: LD_VAR 0 4
129371: ARRAY
129372: PUSH
129373: LD_INT 4
129375: ARRAY
129376: PPUSH
129377: CALL_OW 111
// AddComExitVehicle ( driver ) ;
129381: LD_VAR 0 6
129385: PPUSH
129386: CALL_OW 181
// if Multiplayer then
129390: LD_OWVAR 4
129394: IFFALSE 129443
// begin repeat wait ( 10 ) ;
129396: LD_INT 10
129398: PPUSH
129399: CALL_OW 67
// until not IsInUnit ( driver ) ;
129403: LD_VAR 0 6
129407: PPUSH
129408: CALL_OW 310
129412: NOT
129413: IFFALSE 129396
// if not HasTask ( driver ) then
129415: LD_VAR 0 6
129419: PPUSH
129420: CALL_OW 314
129424: NOT
129425: IFFALSE 129441
// ComEnterUnit ( driver , factory ) ;
129427: LD_VAR 0 6
129431: PPUSH
129432: LD_VAR 0 2
129436: PPUSH
129437: CALL_OW 120
// end else
129441: GO 129457
// AddComEnterUnit ( driver , factory ) ;
129443: LD_VAR 0 6
129447: PPUSH
129448: LD_VAR 0 2
129452: PPUSH
129453: CALL_OW 180
// wait ( 0 0$1 ) ;
129457: LD_INT 35
129459: PPUSH
129460: CALL_OW 67
// SetTag ( driver , tag ) ;
129464: LD_VAR 0 6
129468: PPUSH
129469: LD_VAR 0 5
129473: PPUSH
129474: CALL_OW 109
// SetTag ( vehicle , 0 ) ;
129478: LD_VAR 0 1
129482: PPUSH
129483: LD_INT 0
129485: PPUSH
129486: CALL_OW 109
// break ;
129490: GO 129613
// end ; end else
129492: GO 129611
// if GetControl ( vehicle ) = control_remote then
129494: LD_VAR 0 1
129498: PPUSH
129499: CALL_OW 263
129503: PUSH
129504: LD_INT 2
129506: EQUAL
129507: IFFALSE 129570
// begin wait ( 0 0$2 ) ;
129509: LD_INT 70
129511: PPUSH
129512: CALL_OW 67
// if Connect ( vehicle ) then
129516: LD_VAR 0 1
129520: PPUSH
129521: CALL 78601 0 1
129525: IFFALSE 129566
// AddComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
129527: LD_VAR 0 1
129531: PPUSH
129532: LD_EXP 206
129536: PUSH
129537: LD_VAR 0 4
129541: ARRAY
129542: PUSH
129543: LD_INT 3
129545: ARRAY
129546: PPUSH
129547: LD_EXP 206
129551: PUSH
129552: LD_VAR 0 4
129556: ARRAY
129557: PUSH
129558: LD_INT 4
129560: ARRAY
129561: PPUSH
129562: CALL_OW 171
// break ;
129566: GO 129613
// end else
129568: GO 129611
// begin AddComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
129570: LD_VAR 0 1
129574: PPUSH
129575: LD_EXP 206
129579: PUSH
129580: LD_VAR 0 4
129584: ARRAY
129585: PUSH
129586: LD_INT 3
129588: ARRAY
129589: PPUSH
129590: LD_EXP 206
129594: PUSH
129595: LD_VAR 0 4
129599: ARRAY
129600: PUSH
129601: LD_INT 4
129603: ARRAY
129604: PPUSH
129605: CALL_OW 171
// break ;
129609: GO 129613
// end ; end ;
129611: GO 129145
129613: POP
129614: POP
// end ;
129615: LD_VAR 0 3
129619: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
129620: LD_INT 0
129622: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
129623: LD_VAR 0 1
129627: PUSH
129628: LD_INT 250
129630: EQUAL
129631: PUSH
129632: LD_VAR 0 2
129636: PPUSH
129637: CALL_OW 264
129641: PUSH
129642: LD_INT 81
129644: EQUAL
129645: AND
129646: IFFALSE 129667
// MinerPlaceMine ( unit , x , y ) ;
129648: LD_VAR 0 2
129652: PPUSH
129653: LD_VAR 0 4
129657: PPUSH
129658: LD_VAR 0 5
129662: PPUSH
129663: CALL 132759 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
129667: LD_VAR 0 1
129671: PUSH
129672: LD_INT 251
129674: EQUAL
129675: PUSH
129676: LD_VAR 0 2
129680: PPUSH
129681: CALL_OW 264
129685: PUSH
129686: LD_INT 81
129688: EQUAL
129689: AND
129690: IFFALSE 129711
// MinerDetonateMine ( unit , x , y ) ;
129692: LD_VAR 0 2
129696: PPUSH
129697: LD_VAR 0 4
129701: PPUSH
129702: LD_VAR 0 5
129706: PPUSH
129707: CALL 133034 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
129711: LD_VAR 0 1
129715: PUSH
129716: LD_INT 252
129718: EQUAL
129719: PUSH
129720: LD_VAR 0 2
129724: PPUSH
129725: CALL_OW 264
129729: PUSH
129730: LD_INT 81
129732: EQUAL
129733: AND
129734: IFFALSE 129755
// MinerCreateMinefield ( unit , x , y ) ;
129736: LD_VAR 0 2
129740: PPUSH
129741: LD_VAR 0 4
129745: PPUSH
129746: LD_VAR 0 5
129750: PPUSH
129751: CALL 133451 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
129755: LD_VAR 0 1
129759: PUSH
129760: LD_INT 253
129762: EQUAL
129763: PUSH
129764: LD_VAR 0 2
129768: PPUSH
129769: CALL_OW 257
129773: PUSH
129774: LD_INT 5
129776: EQUAL
129777: AND
129778: IFFALSE 129799
// ComBinocular ( unit , x , y ) ;
129780: LD_VAR 0 2
129784: PPUSH
129785: LD_VAR 0 4
129789: PPUSH
129790: LD_VAR 0 5
129794: PPUSH
129795: CALL 133820 0 3
// if selectedUnit then
129799: LD_VAR 0 3
129803: IFFALSE 129859
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
129805: LD_VAR 0 1
129809: PUSH
129810: LD_INT 254
129812: EQUAL
129813: PUSH
129814: LD_VAR 0 2
129818: PPUSH
129819: CALL_OW 264
129823: PUSH
129824: LD_INT 99
129826: EQUAL
129827: AND
129828: PUSH
129829: LD_VAR 0 3
129833: PPUSH
129834: CALL_OW 263
129838: PUSH
129839: LD_INT 3
129841: EQUAL
129842: AND
129843: IFFALSE 129859
// HackDestroyVehicle ( unit , selectedUnit ) ;
129845: LD_VAR 0 2
129849: PPUSH
129850: LD_VAR 0 3
129854: PPUSH
129855: CALL 132123 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
129859: LD_VAR 0 1
129863: PUSH
129864: LD_INT 255
129866: EQUAL
129867: PUSH
129868: LD_VAR 0 2
129872: PPUSH
129873: CALL_OW 264
129877: PUSH
129878: LD_INT 14
129880: PUSH
129881: LD_INT 53
129883: PUSH
129884: EMPTY
129885: LIST
129886: LIST
129887: IN
129888: AND
129889: PUSH
129890: LD_VAR 0 4
129894: PPUSH
129895: LD_VAR 0 5
129899: PPUSH
129900: CALL_OW 488
129904: AND
129905: IFFALSE 129929
// CutTreeXYR ( unit , x , y , 12 ) ;
129907: LD_VAR 0 2
129911: PPUSH
129912: LD_VAR 0 4
129916: PPUSH
129917: LD_VAR 0 5
129921: PPUSH
129922: LD_INT 12
129924: PPUSH
129925: CALL 130120 0 4
// if cmd = 256 then
129929: LD_VAR 0 1
129933: PUSH
129934: LD_INT 256
129936: EQUAL
129937: IFFALSE 129958
// SetFactoryWaypoint ( unit , x , y ) ;
129939: LD_VAR 0 2
129943: PPUSH
129944: LD_VAR 0 4
129948: PPUSH
129949: LD_VAR 0 5
129953: PPUSH
129954: CALL 127596 0 3
// if cmd = 257 then
129958: LD_VAR 0 1
129962: PUSH
129963: LD_INT 257
129965: EQUAL
129966: IFFALSE 129987
// SetWarehouseGatheringPoint ( unit , x , y ) ;
129968: LD_VAR 0 2
129972: PPUSH
129973: LD_VAR 0 4
129977: PPUSH
129978: LD_VAR 0 5
129982: PPUSH
129983: CALL 128086 0 3
// if cmd = 258 then
129987: LD_VAR 0 1
129991: PUSH
129992: LD_INT 258
129994: EQUAL
129995: IFFALSE 130019
// BurnTreeXYR ( unit , x , y , 8 ) ;
129997: LD_VAR 0 2
130001: PPUSH
130002: LD_VAR 0 4
130006: PPUSH
130007: LD_VAR 0 5
130011: PPUSH
130012: LD_INT 8
130014: PPUSH
130015: CALL 130514 0 4
// end ;
130019: LD_VAR 0 6
130023: RET
// export function ComRadiation ( un ) ; var eff ; begin
130024: LD_INT 0
130026: PPUSH
130027: PPUSH
// if GetWeapon ( un ) <> ar_bio_bomb then
130028: LD_VAR 0 1
130032: PPUSH
130033: CALL_OW 264
130037: PUSH
130038: LD_INT 91
130040: NONEQUAL
130041: IFFALSE 130045
// exit ;
130043: GO 130115
// if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
130045: LD_INT 68
130047: PPUSH
130048: LD_VAR 0 1
130052: PPUSH
130053: CALL_OW 255
130057: PPUSH
130058: CALL_OW 321
130062: PUSH
130063: LD_INT 2
130065: EQUAL
130066: IFFALSE 130078
// eff := 70 else
130068: LD_ADDR_VAR 0 3
130072: PUSH
130073: LD_INT 70
130075: ST_TO_ADDR
130076: GO 130086
// eff := 30 ;
130078: LD_ADDR_VAR 0 3
130082: PUSH
130083: LD_INT 30
130085: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
130086: LD_VAR 0 1
130090: PPUSH
130091: CALL_OW 250
130095: PPUSH
130096: LD_VAR 0 1
130100: PPUSH
130101: CALL_OW 251
130105: PPUSH
130106: LD_VAR 0 3
130110: PPUSH
130111: CALL_OW 495
// end ;
130115: LD_VAR 0 2
130119: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
130120: LD_INT 0
130122: PPUSH
130123: PPUSH
130124: PPUSH
130125: PPUSH
130126: PPUSH
130127: PPUSH
130128: PPUSH
130129: PPUSH
130130: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
130131: LD_VAR 0 1
130135: PPUSH
130136: CALL_OW 302
130140: NOT
130141: PUSH
130142: LD_VAR 0 2
130146: PPUSH
130147: LD_VAR 0 3
130151: PPUSH
130152: CALL_OW 488
130156: NOT
130157: OR
130158: PUSH
130159: LD_VAR 0 4
130163: NOT
130164: OR
130165: IFFALSE 130169
// exit ;
130167: GO 130509
// list := [ ] ;
130169: LD_ADDR_VAR 0 13
130173: PUSH
130174: EMPTY
130175: ST_TO_ADDR
// if x - r < 0 then
130176: LD_VAR 0 2
130180: PUSH
130181: LD_VAR 0 4
130185: MINUS
130186: PUSH
130187: LD_INT 0
130189: LESS
130190: IFFALSE 130202
// min_x := 0 else
130192: LD_ADDR_VAR 0 7
130196: PUSH
130197: LD_INT 0
130199: ST_TO_ADDR
130200: GO 130218
// min_x := x - r ;
130202: LD_ADDR_VAR 0 7
130206: PUSH
130207: LD_VAR 0 2
130211: PUSH
130212: LD_VAR 0 4
130216: MINUS
130217: ST_TO_ADDR
// if y - r < 0 then
130218: LD_VAR 0 3
130222: PUSH
130223: LD_VAR 0 4
130227: MINUS
130228: PUSH
130229: LD_INT 0
130231: LESS
130232: IFFALSE 130244
// min_y := 0 else
130234: LD_ADDR_VAR 0 8
130238: PUSH
130239: LD_INT 0
130241: ST_TO_ADDR
130242: GO 130260
// min_y := y - r ;
130244: LD_ADDR_VAR 0 8
130248: PUSH
130249: LD_VAR 0 3
130253: PUSH
130254: LD_VAR 0 4
130258: MINUS
130259: ST_TO_ADDR
// max_x := x + r ;
130260: LD_ADDR_VAR 0 9
130264: PUSH
130265: LD_VAR 0 2
130269: PUSH
130270: LD_VAR 0 4
130274: PLUS
130275: ST_TO_ADDR
// max_y := y + r ;
130276: LD_ADDR_VAR 0 10
130280: PUSH
130281: LD_VAR 0 3
130285: PUSH
130286: LD_VAR 0 4
130290: PLUS
130291: ST_TO_ADDR
// for _x = min_x to max_x do
130292: LD_ADDR_VAR 0 11
130296: PUSH
130297: DOUBLE
130298: LD_VAR 0 7
130302: DEC
130303: ST_TO_ADDR
130304: LD_VAR 0 9
130308: PUSH
130309: FOR_TO
130310: IFFALSE 130427
// for _y = min_y to max_y do
130312: LD_ADDR_VAR 0 12
130316: PUSH
130317: DOUBLE
130318: LD_VAR 0 8
130322: DEC
130323: ST_TO_ADDR
130324: LD_VAR 0 10
130328: PUSH
130329: FOR_TO
130330: IFFALSE 130423
// begin if not ValidHex ( _x , _y ) then
130332: LD_VAR 0 11
130336: PPUSH
130337: LD_VAR 0 12
130341: PPUSH
130342: CALL_OW 488
130346: NOT
130347: IFFALSE 130351
// continue ;
130349: GO 130329
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
130351: LD_VAR 0 11
130355: PPUSH
130356: LD_VAR 0 12
130360: PPUSH
130361: CALL_OW 351
130365: PUSH
130366: LD_VAR 0 11
130370: PPUSH
130371: LD_VAR 0 12
130375: PPUSH
130376: CALL_OW 554
130380: AND
130381: IFFALSE 130421
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
130383: LD_ADDR_VAR 0 13
130387: PUSH
130388: LD_VAR 0 13
130392: PPUSH
130393: LD_VAR 0 13
130397: PUSH
130398: LD_INT 1
130400: PLUS
130401: PPUSH
130402: LD_VAR 0 11
130406: PUSH
130407: LD_VAR 0 12
130411: PUSH
130412: EMPTY
130413: LIST
130414: LIST
130415: PPUSH
130416: CALL_OW 2
130420: ST_TO_ADDR
// end ;
130421: GO 130329
130423: POP
130424: POP
130425: GO 130309
130427: POP
130428: POP
// if not list then
130429: LD_VAR 0 13
130433: NOT
130434: IFFALSE 130438
// exit ;
130436: GO 130509
// for i in list do
130438: LD_ADDR_VAR 0 6
130442: PUSH
130443: LD_VAR 0 13
130447: PUSH
130448: FOR_IN
130449: IFFALSE 130507
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
130451: LD_VAR 0 1
130455: PPUSH
130456: LD_STRING M
130458: PUSH
130459: LD_VAR 0 6
130463: PUSH
130464: LD_INT 1
130466: ARRAY
130467: PUSH
130468: LD_VAR 0 6
130472: PUSH
130473: LD_INT 2
130475: ARRAY
130476: PUSH
130477: LD_INT 0
130479: PUSH
130480: LD_INT 0
130482: PUSH
130483: LD_INT 0
130485: PUSH
130486: LD_INT 0
130488: PUSH
130489: EMPTY
130490: LIST
130491: LIST
130492: LIST
130493: LIST
130494: LIST
130495: LIST
130496: LIST
130497: PUSH
130498: EMPTY
130499: LIST
130500: PPUSH
130501: CALL_OW 447
130505: GO 130448
130507: POP
130508: POP
// end ;
130509: LD_VAR 0 5
130513: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
130514: LD_INT 0
130516: PPUSH
130517: PPUSH
130518: PPUSH
130519: PPUSH
130520: PPUSH
130521: PPUSH
130522: PPUSH
130523: PPUSH
130524: PPUSH
130525: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
130526: LD_VAR 0 1
130530: PPUSH
130531: CALL_OW 302
130535: NOT
130536: PUSH
130537: LD_VAR 0 2
130541: PPUSH
130542: LD_VAR 0 3
130546: PPUSH
130547: CALL_OW 488
130551: NOT
130552: OR
130553: PUSH
130554: LD_VAR 0 4
130558: NOT
130559: OR
130560: IFFALSE 130564
// exit ;
130562: GO 131077
// list := [ ] ;
130564: LD_ADDR_VAR 0 13
130568: PUSH
130569: EMPTY
130570: ST_TO_ADDR
// if x - r < 0 then
130571: LD_VAR 0 2
130575: PUSH
130576: LD_VAR 0 4
130580: MINUS
130581: PUSH
130582: LD_INT 0
130584: LESS
130585: IFFALSE 130597
// min_x := 0 else
130587: LD_ADDR_VAR 0 7
130591: PUSH
130592: LD_INT 0
130594: ST_TO_ADDR
130595: GO 130613
// min_x := x - r ;
130597: LD_ADDR_VAR 0 7
130601: PUSH
130602: LD_VAR 0 2
130606: PUSH
130607: LD_VAR 0 4
130611: MINUS
130612: ST_TO_ADDR
// if y - r < 0 then
130613: LD_VAR 0 3
130617: PUSH
130618: LD_VAR 0 4
130622: MINUS
130623: PUSH
130624: LD_INT 0
130626: LESS
130627: IFFALSE 130639
// min_y := 0 else
130629: LD_ADDR_VAR 0 8
130633: PUSH
130634: LD_INT 0
130636: ST_TO_ADDR
130637: GO 130655
// min_y := y - r ;
130639: LD_ADDR_VAR 0 8
130643: PUSH
130644: LD_VAR 0 3
130648: PUSH
130649: LD_VAR 0 4
130653: MINUS
130654: ST_TO_ADDR
// max_x := x + r ;
130655: LD_ADDR_VAR 0 9
130659: PUSH
130660: LD_VAR 0 2
130664: PUSH
130665: LD_VAR 0 4
130669: PLUS
130670: ST_TO_ADDR
// max_y := y + r ;
130671: LD_ADDR_VAR 0 10
130675: PUSH
130676: LD_VAR 0 3
130680: PUSH
130681: LD_VAR 0 4
130685: PLUS
130686: ST_TO_ADDR
// for _x = min_x to max_x do
130687: LD_ADDR_VAR 0 11
130691: PUSH
130692: DOUBLE
130693: LD_VAR 0 7
130697: DEC
130698: ST_TO_ADDR
130699: LD_VAR 0 9
130703: PUSH
130704: FOR_TO
130705: IFFALSE 130822
// for _y = min_y to max_y do
130707: LD_ADDR_VAR 0 12
130711: PUSH
130712: DOUBLE
130713: LD_VAR 0 8
130717: DEC
130718: ST_TO_ADDR
130719: LD_VAR 0 10
130723: PUSH
130724: FOR_TO
130725: IFFALSE 130818
// begin if not ValidHex ( _x , _y ) then
130727: LD_VAR 0 11
130731: PPUSH
130732: LD_VAR 0 12
130736: PPUSH
130737: CALL_OW 488
130741: NOT
130742: IFFALSE 130746
// continue ;
130744: GO 130724
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
130746: LD_VAR 0 11
130750: PPUSH
130751: LD_VAR 0 12
130755: PPUSH
130756: CALL_OW 351
130760: PUSH
130761: LD_VAR 0 11
130765: PPUSH
130766: LD_VAR 0 12
130770: PPUSH
130771: CALL_OW 554
130775: AND
130776: IFFALSE 130816
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
130778: LD_ADDR_VAR 0 13
130782: PUSH
130783: LD_VAR 0 13
130787: PPUSH
130788: LD_VAR 0 13
130792: PUSH
130793: LD_INT 1
130795: PLUS
130796: PPUSH
130797: LD_VAR 0 11
130801: PUSH
130802: LD_VAR 0 12
130806: PUSH
130807: EMPTY
130808: LIST
130809: LIST
130810: PPUSH
130811: CALL_OW 2
130815: ST_TO_ADDR
// end ;
130816: GO 130724
130818: POP
130819: POP
130820: GO 130704
130822: POP
130823: POP
// if not list then
130824: LD_VAR 0 13
130828: NOT
130829: IFFALSE 130833
// exit ;
130831: GO 131077
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
130833: LD_ADDR_VAR 0 13
130837: PUSH
130838: LD_VAR 0 1
130842: PPUSH
130843: LD_VAR 0 13
130847: PPUSH
130848: LD_INT 1
130850: PPUSH
130851: LD_INT 1
130853: PPUSH
130854: CALL 75743 0 4
130858: ST_TO_ADDR
// ComStop ( flame ) ;
130859: LD_VAR 0 1
130863: PPUSH
130864: CALL_OW 141
// for i in list do
130868: LD_ADDR_VAR 0 6
130872: PUSH
130873: LD_VAR 0 13
130877: PUSH
130878: FOR_IN
130879: IFFALSE 130910
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
130881: LD_VAR 0 1
130885: PPUSH
130886: LD_VAR 0 6
130890: PUSH
130891: LD_INT 1
130893: ARRAY
130894: PPUSH
130895: LD_VAR 0 6
130899: PUSH
130900: LD_INT 2
130902: ARRAY
130903: PPUSH
130904: CALL_OW 176
130908: GO 130878
130910: POP
130911: POP
// repeat wait ( 0 0$1 ) ;
130912: LD_INT 35
130914: PPUSH
130915: CALL_OW 67
// task := GetTaskList ( flame ) ;
130919: LD_ADDR_VAR 0 14
130923: PUSH
130924: LD_VAR 0 1
130928: PPUSH
130929: CALL_OW 437
130933: ST_TO_ADDR
// if not task then
130934: LD_VAR 0 14
130938: NOT
130939: IFFALSE 130943
// exit ;
130941: GO 131077
// if task [ 1 ] [ 1 ] <> | then
130943: LD_VAR 0 14
130947: PUSH
130948: LD_INT 1
130950: ARRAY
130951: PUSH
130952: LD_INT 1
130954: ARRAY
130955: PUSH
130956: LD_STRING |
130958: NONEQUAL
130959: IFFALSE 130963
// exit ;
130961: GO 131077
// _x := task [ 1 ] [ 2 ] ;
130963: LD_ADDR_VAR 0 11
130967: PUSH
130968: LD_VAR 0 14
130972: PUSH
130973: LD_INT 1
130975: ARRAY
130976: PUSH
130977: LD_INT 2
130979: ARRAY
130980: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
130981: LD_ADDR_VAR 0 12
130985: PUSH
130986: LD_VAR 0 14
130990: PUSH
130991: LD_INT 1
130993: ARRAY
130994: PUSH
130995: LD_INT 3
130997: ARRAY
130998: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
130999: LD_VAR 0 11
131003: PPUSH
131004: LD_VAR 0 12
131008: PPUSH
131009: CALL_OW 351
131013: NOT
131014: PUSH
131015: LD_VAR 0 11
131019: PPUSH
131020: LD_VAR 0 12
131024: PPUSH
131025: CALL_OW 554
131029: NOT
131030: OR
131031: IFFALSE 131065
// begin task := Delete ( task , 1 ) ;
131033: LD_ADDR_VAR 0 14
131037: PUSH
131038: LD_VAR 0 14
131042: PPUSH
131043: LD_INT 1
131045: PPUSH
131046: CALL_OW 3
131050: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
131051: LD_VAR 0 1
131055: PPUSH
131056: LD_VAR 0 14
131060: PPUSH
131061: CALL_OW 446
// end ; until not HasTask ( flame ) ;
131065: LD_VAR 0 1
131069: PPUSH
131070: CALL_OW 314
131074: NOT
131075: IFFALSE 130912
// end ;
131077: LD_VAR 0 5
131081: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
131082: LD_EXP 209
131086: NOT
131087: IFFALSE 131137
131089: GO 131091
131091: DISABLE
// begin initHack := true ;
131092: LD_ADDR_EXP 209
131096: PUSH
131097: LD_INT 1
131099: ST_TO_ADDR
// hackTanks := [ ] ;
131100: LD_ADDR_EXP 210
131104: PUSH
131105: EMPTY
131106: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
131107: LD_ADDR_EXP 211
131111: PUSH
131112: EMPTY
131113: ST_TO_ADDR
// hackLimit := 3 ;
131114: LD_ADDR_EXP 212
131118: PUSH
131119: LD_INT 3
131121: ST_TO_ADDR
// hackDist := 12 ;
131122: LD_ADDR_EXP 213
131126: PUSH
131127: LD_INT 12
131129: ST_TO_ADDR
// hackCounter := [ ] ;
131130: LD_ADDR_EXP 214
131134: PUSH
131135: EMPTY
131136: ST_TO_ADDR
// end ;
131137: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
131138: LD_EXP 209
131142: PUSH
131143: LD_INT 34
131145: PUSH
131146: LD_INT 99
131148: PUSH
131149: EMPTY
131150: LIST
131151: LIST
131152: PPUSH
131153: CALL_OW 69
131157: AND
131158: IFFALSE 131411
131160: GO 131162
131162: DISABLE
131163: LD_INT 0
131165: PPUSH
131166: PPUSH
// begin enable ;
131167: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
131168: LD_ADDR_VAR 0 1
131172: PUSH
131173: LD_INT 34
131175: PUSH
131176: LD_INT 99
131178: PUSH
131179: EMPTY
131180: LIST
131181: LIST
131182: PPUSH
131183: CALL_OW 69
131187: PUSH
131188: FOR_IN
131189: IFFALSE 131409
// begin if not i in hackTanks then
131191: LD_VAR 0 1
131195: PUSH
131196: LD_EXP 210
131200: IN
131201: NOT
131202: IFFALSE 131285
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
131204: LD_ADDR_EXP 210
131208: PUSH
131209: LD_EXP 210
131213: PPUSH
131214: LD_EXP 210
131218: PUSH
131219: LD_INT 1
131221: PLUS
131222: PPUSH
131223: LD_VAR 0 1
131227: PPUSH
131228: CALL_OW 1
131232: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
131233: LD_ADDR_EXP 211
131237: PUSH
131238: LD_EXP 211
131242: PPUSH
131243: LD_EXP 211
131247: PUSH
131248: LD_INT 1
131250: PLUS
131251: PPUSH
131252: EMPTY
131253: PPUSH
131254: CALL_OW 1
131258: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
131259: LD_ADDR_EXP 214
131263: PUSH
131264: LD_EXP 214
131268: PPUSH
131269: LD_EXP 214
131273: PUSH
131274: LD_INT 1
131276: PLUS
131277: PPUSH
131278: EMPTY
131279: PPUSH
131280: CALL_OW 1
131284: ST_TO_ADDR
// end ; if not IsOk ( i ) then
131285: LD_VAR 0 1
131289: PPUSH
131290: CALL_OW 302
131294: NOT
131295: IFFALSE 131308
// begin HackUnlinkAll ( i ) ;
131297: LD_VAR 0 1
131301: PPUSH
131302: CALL 131414 0 1
// continue ;
131306: GO 131188
// end ; HackCheckCapturedStatus ( i ) ;
131308: LD_VAR 0 1
131312: PPUSH
131313: CALL 131857 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
131317: LD_ADDR_VAR 0 2
131321: PUSH
131322: LD_INT 81
131324: PUSH
131325: LD_VAR 0 1
131329: PPUSH
131330: CALL_OW 255
131334: PUSH
131335: EMPTY
131336: LIST
131337: LIST
131338: PUSH
131339: LD_INT 33
131341: PUSH
131342: LD_INT 3
131344: PUSH
131345: EMPTY
131346: LIST
131347: LIST
131348: PUSH
131349: LD_INT 91
131351: PUSH
131352: LD_VAR 0 1
131356: PUSH
131357: LD_EXP 213
131361: PUSH
131362: EMPTY
131363: LIST
131364: LIST
131365: LIST
131366: PUSH
131367: LD_INT 50
131369: PUSH
131370: EMPTY
131371: LIST
131372: PUSH
131373: EMPTY
131374: LIST
131375: LIST
131376: LIST
131377: LIST
131378: PPUSH
131379: CALL_OW 69
131383: ST_TO_ADDR
// if not tmp then
131384: LD_VAR 0 2
131388: NOT
131389: IFFALSE 131393
// continue ;
131391: GO 131188
// HackLink ( i , tmp ) ;
131393: LD_VAR 0 1
131397: PPUSH
131398: LD_VAR 0 2
131402: PPUSH
131403: CALL 131550 0 2
// end ;
131407: GO 131188
131409: POP
131410: POP
// end ;
131411: PPOPN 2
131413: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
131414: LD_INT 0
131416: PPUSH
131417: PPUSH
131418: PPUSH
// if not hack in hackTanks then
131419: LD_VAR 0 1
131423: PUSH
131424: LD_EXP 210
131428: IN
131429: NOT
131430: IFFALSE 131434
// exit ;
131432: GO 131545
// index := GetElementIndex ( hackTanks , hack ) ;
131434: LD_ADDR_VAR 0 4
131438: PUSH
131439: LD_EXP 210
131443: PPUSH
131444: LD_VAR 0 1
131448: PPUSH
131449: CALL 75040 0 2
131453: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
131454: LD_EXP 211
131458: PUSH
131459: LD_VAR 0 4
131463: ARRAY
131464: IFFALSE 131545
// begin for i in hackTanksCaptured [ index ] do
131466: LD_ADDR_VAR 0 3
131470: PUSH
131471: LD_EXP 211
131475: PUSH
131476: LD_VAR 0 4
131480: ARRAY
131481: PUSH
131482: FOR_IN
131483: IFFALSE 131509
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
131485: LD_VAR 0 3
131489: PUSH
131490: LD_INT 1
131492: ARRAY
131493: PPUSH
131494: LD_VAR 0 3
131498: PUSH
131499: LD_INT 2
131501: ARRAY
131502: PPUSH
131503: CALL_OW 235
131507: GO 131482
131509: POP
131510: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
131511: LD_ADDR_EXP 211
131515: PUSH
131516: LD_EXP 211
131520: PPUSH
131521: LD_VAR 0 4
131525: PPUSH
131526: EMPTY
131527: PPUSH
131528: CALL_OW 1
131532: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
131533: LD_VAR 0 1
131537: PPUSH
131538: LD_INT 0
131540: PPUSH
131541: CALL_OW 505
// end ; end ;
131545: LD_VAR 0 2
131549: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
131550: LD_INT 0
131552: PPUSH
131553: PPUSH
131554: PPUSH
// if not hack in hackTanks or not vehicles then
131555: LD_VAR 0 1
131559: PUSH
131560: LD_EXP 210
131564: IN
131565: NOT
131566: PUSH
131567: LD_VAR 0 2
131571: NOT
131572: OR
131573: IFFALSE 131577
// exit ;
131575: GO 131852
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
131577: LD_ADDR_VAR 0 2
131581: PUSH
131582: LD_VAR 0 1
131586: PPUSH
131587: LD_VAR 0 2
131591: PPUSH
131592: LD_INT 1
131594: PPUSH
131595: LD_INT 1
131597: PPUSH
131598: CALL 75690 0 4
131602: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
131603: LD_ADDR_VAR 0 5
131607: PUSH
131608: LD_EXP 210
131612: PPUSH
131613: LD_VAR 0 1
131617: PPUSH
131618: CALL 75040 0 2
131622: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
131623: LD_EXP 211
131627: PUSH
131628: LD_VAR 0 5
131632: ARRAY
131633: PUSH
131634: LD_EXP 212
131638: LESS
131639: IFFALSE 131828
// begin for i := 1 to vehicles do
131641: LD_ADDR_VAR 0 4
131645: PUSH
131646: DOUBLE
131647: LD_INT 1
131649: DEC
131650: ST_TO_ADDR
131651: LD_VAR 0 2
131655: PUSH
131656: FOR_TO
131657: IFFALSE 131826
// begin if hackTanksCaptured [ index ] = hackLimit then
131659: LD_EXP 211
131663: PUSH
131664: LD_VAR 0 5
131668: ARRAY
131669: PUSH
131670: LD_EXP 212
131674: EQUAL
131675: IFFALSE 131679
// break ;
131677: GO 131826
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
131679: LD_ADDR_EXP 214
131683: PUSH
131684: LD_EXP 214
131688: PPUSH
131689: LD_VAR 0 5
131693: PPUSH
131694: LD_EXP 214
131698: PUSH
131699: LD_VAR 0 5
131703: ARRAY
131704: PUSH
131705: LD_INT 1
131707: PLUS
131708: PPUSH
131709: CALL_OW 1
131713: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
131714: LD_ADDR_EXP 211
131718: PUSH
131719: LD_EXP 211
131723: PPUSH
131724: LD_VAR 0 5
131728: PUSH
131729: LD_EXP 211
131733: PUSH
131734: LD_VAR 0 5
131738: ARRAY
131739: PUSH
131740: LD_INT 1
131742: PLUS
131743: PUSH
131744: EMPTY
131745: LIST
131746: LIST
131747: PPUSH
131748: LD_VAR 0 2
131752: PUSH
131753: LD_VAR 0 4
131757: ARRAY
131758: PUSH
131759: LD_VAR 0 2
131763: PUSH
131764: LD_VAR 0 4
131768: ARRAY
131769: PPUSH
131770: CALL_OW 255
131774: PUSH
131775: EMPTY
131776: LIST
131777: LIST
131778: PPUSH
131779: CALL 75255 0 3
131783: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
131784: LD_VAR 0 2
131788: PUSH
131789: LD_VAR 0 4
131793: ARRAY
131794: PPUSH
131795: LD_VAR 0 1
131799: PPUSH
131800: CALL_OW 255
131804: PPUSH
131805: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
131809: LD_VAR 0 2
131813: PUSH
131814: LD_VAR 0 4
131818: ARRAY
131819: PPUSH
131820: CALL_OW 141
// end ;
131824: GO 131656
131826: POP
131827: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
131828: LD_VAR 0 1
131832: PPUSH
131833: LD_EXP 211
131837: PUSH
131838: LD_VAR 0 5
131842: ARRAY
131843: PUSH
131844: LD_INT 0
131846: PLUS
131847: PPUSH
131848: CALL_OW 505
// end ;
131852: LD_VAR 0 3
131856: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
131857: LD_INT 0
131859: PPUSH
131860: PPUSH
131861: PPUSH
131862: PPUSH
// if not hack in hackTanks then
131863: LD_VAR 0 1
131867: PUSH
131868: LD_EXP 210
131872: IN
131873: NOT
131874: IFFALSE 131878
// exit ;
131876: GO 132118
// index := GetElementIndex ( hackTanks , hack ) ;
131878: LD_ADDR_VAR 0 4
131882: PUSH
131883: LD_EXP 210
131887: PPUSH
131888: LD_VAR 0 1
131892: PPUSH
131893: CALL 75040 0 2
131897: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
131898: LD_ADDR_VAR 0 3
131902: PUSH
131903: DOUBLE
131904: LD_EXP 211
131908: PUSH
131909: LD_VAR 0 4
131913: ARRAY
131914: INC
131915: ST_TO_ADDR
131916: LD_INT 1
131918: PUSH
131919: FOR_DOWNTO
131920: IFFALSE 132092
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
131922: LD_ADDR_VAR 0 5
131926: PUSH
131927: LD_EXP 211
131931: PUSH
131932: LD_VAR 0 4
131936: ARRAY
131937: PUSH
131938: LD_VAR 0 3
131942: ARRAY
131943: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
131944: LD_VAR 0 5
131948: PUSH
131949: LD_INT 1
131951: ARRAY
131952: PPUSH
131953: CALL_OW 302
131957: NOT
131958: PUSH
131959: LD_VAR 0 5
131963: PUSH
131964: LD_INT 1
131966: ARRAY
131967: PPUSH
131968: CALL_OW 255
131972: PUSH
131973: LD_VAR 0 1
131977: PPUSH
131978: CALL_OW 255
131982: NONEQUAL
131983: OR
131984: IFFALSE 132090
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
131986: LD_VAR 0 5
131990: PUSH
131991: LD_INT 1
131993: ARRAY
131994: PPUSH
131995: CALL_OW 305
131999: PUSH
132000: LD_VAR 0 5
132004: PUSH
132005: LD_INT 1
132007: ARRAY
132008: PPUSH
132009: CALL_OW 255
132013: PUSH
132014: LD_VAR 0 1
132018: PPUSH
132019: CALL_OW 255
132023: EQUAL
132024: AND
132025: IFFALSE 132049
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
132027: LD_VAR 0 5
132031: PUSH
132032: LD_INT 1
132034: ARRAY
132035: PPUSH
132036: LD_VAR 0 5
132040: PUSH
132041: LD_INT 2
132043: ARRAY
132044: PPUSH
132045: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
132049: LD_ADDR_EXP 211
132053: PUSH
132054: LD_EXP 211
132058: PPUSH
132059: LD_VAR 0 4
132063: PPUSH
132064: LD_EXP 211
132068: PUSH
132069: LD_VAR 0 4
132073: ARRAY
132074: PPUSH
132075: LD_VAR 0 3
132079: PPUSH
132080: CALL_OW 3
132084: PPUSH
132085: CALL_OW 1
132089: ST_TO_ADDR
// end ; end ;
132090: GO 131919
132092: POP
132093: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
132094: LD_VAR 0 1
132098: PPUSH
132099: LD_EXP 211
132103: PUSH
132104: LD_VAR 0 4
132108: ARRAY
132109: PUSH
132110: LD_INT 0
132112: PLUS
132113: PPUSH
132114: CALL_OW 505
// end ;
132118: LD_VAR 0 2
132122: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
132123: LD_INT 0
132125: PPUSH
132126: PPUSH
132127: PPUSH
132128: PPUSH
// if not hack in hackTanks then
132129: LD_VAR 0 1
132133: PUSH
132134: LD_EXP 210
132138: IN
132139: NOT
132140: IFFALSE 132144
// exit ;
132142: GO 132229
// index := GetElementIndex ( hackTanks , hack ) ;
132144: LD_ADDR_VAR 0 5
132148: PUSH
132149: LD_EXP 210
132153: PPUSH
132154: LD_VAR 0 1
132158: PPUSH
132159: CALL 75040 0 2
132163: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
132164: LD_ADDR_VAR 0 4
132168: PUSH
132169: DOUBLE
132170: LD_INT 1
132172: DEC
132173: ST_TO_ADDR
132174: LD_EXP 211
132178: PUSH
132179: LD_VAR 0 5
132183: ARRAY
132184: PUSH
132185: FOR_TO
132186: IFFALSE 132227
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
132188: LD_EXP 211
132192: PUSH
132193: LD_VAR 0 5
132197: ARRAY
132198: PUSH
132199: LD_VAR 0 4
132203: ARRAY
132204: PUSH
132205: LD_INT 1
132207: ARRAY
132208: PUSH
132209: LD_VAR 0 2
132213: EQUAL
132214: IFFALSE 132225
// KillUnit ( vehicle ) ;
132216: LD_VAR 0 2
132220: PPUSH
132221: CALL_OW 66
132225: GO 132185
132227: POP
132228: POP
// end ;
132229: LD_VAR 0 3
132233: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
132234: LD_EXP 215
132238: NOT
132239: IFFALSE 132274
132241: GO 132243
132243: DISABLE
// begin initMiner := true ;
132244: LD_ADDR_EXP 215
132248: PUSH
132249: LD_INT 1
132251: ST_TO_ADDR
// minersList := [ ] ;
132252: LD_ADDR_EXP 216
132256: PUSH
132257: EMPTY
132258: ST_TO_ADDR
// minerMinesList := [ ] ;
132259: LD_ADDR_EXP 217
132263: PUSH
132264: EMPTY
132265: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
132266: LD_ADDR_EXP 218
132270: PUSH
132271: LD_INT 5
132273: ST_TO_ADDR
// end ;
132274: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
132275: LD_EXP 215
132279: PUSH
132280: LD_INT 34
132282: PUSH
132283: LD_INT 81
132285: PUSH
132286: EMPTY
132287: LIST
132288: LIST
132289: PPUSH
132290: CALL_OW 69
132294: AND
132295: IFFALSE 132756
132297: GO 132299
132299: DISABLE
132300: LD_INT 0
132302: PPUSH
132303: PPUSH
132304: PPUSH
132305: PPUSH
// begin enable ;
132306: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
132307: LD_ADDR_VAR 0 1
132311: PUSH
132312: LD_INT 34
132314: PUSH
132315: LD_INT 81
132317: PUSH
132318: EMPTY
132319: LIST
132320: LIST
132321: PPUSH
132322: CALL_OW 69
132326: PUSH
132327: FOR_IN
132328: IFFALSE 132400
// begin if not i in minersList then
132330: LD_VAR 0 1
132334: PUSH
132335: LD_EXP 216
132339: IN
132340: NOT
132341: IFFALSE 132398
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
132343: LD_ADDR_EXP 216
132347: PUSH
132348: LD_EXP 216
132352: PPUSH
132353: LD_EXP 216
132357: PUSH
132358: LD_INT 1
132360: PLUS
132361: PPUSH
132362: LD_VAR 0 1
132366: PPUSH
132367: CALL_OW 1
132371: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
132372: LD_ADDR_EXP 217
132376: PUSH
132377: LD_EXP 217
132381: PPUSH
132382: LD_EXP 217
132386: PUSH
132387: LD_INT 1
132389: PLUS
132390: PPUSH
132391: EMPTY
132392: PPUSH
132393: CALL_OW 1
132397: ST_TO_ADDR
// end end ;
132398: GO 132327
132400: POP
132401: POP
// for i := minerMinesList downto 1 do
132402: LD_ADDR_VAR 0 1
132406: PUSH
132407: DOUBLE
132408: LD_EXP 217
132412: INC
132413: ST_TO_ADDR
132414: LD_INT 1
132416: PUSH
132417: FOR_DOWNTO
132418: IFFALSE 132754
// begin if IsLive ( minersList [ i ] ) then
132420: LD_EXP 216
132424: PUSH
132425: LD_VAR 0 1
132429: ARRAY
132430: PPUSH
132431: CALL_OW 300
132435: IFFALSE 132463
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
132437: LD_EXP 216
132441: PUSH
132442: LD_VAR 0 1
132446: ARRAY
132447: PPUSH
132448: LD_EXP 217
132452: PUSH
132453: LD_VAR 0 1
132457: ARRAY
132458: PPUSH
132459: CALL_OW 505
// if not minerMinesList [ i ] then
132463: LD_EXP 217
132467: PUSH
132468: LD_VAR 0 1
132472: ARRAY
132473: NOT
132474: IFFALSE 132478
// continue ;
132476: GO 132417
// for j := minerMinesList [ i ] downto 1 do
132478: LD_ADDR_VAR 0 2
132482: PUSH
132483: DOUBLE
132484: LD_EXP 217
132488: PUSH
132489: LD_VAR 0 1
132493: ARRAY
132494: INC
132495: ST_TO_ADDR
132496: LD_INT 1
132498: PUSH
132499: FOR_DOWNTO
132500: IFFALSE 132750
// begin side := GetSide ( minersList [ i ] ) ;
132502: LD_ADDR_VAR 0 3
132506: PUSH
132507: LD_EXP 216
132511: PUSH
132512: LD_VAR 0 1
132516: ARRAY
132517: PPUSH
132518: CALL_OW 255
132522: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
132523: LD_ADDR_VAR 0 4
132527: PUSH
132528: LD_EXP 217
132532: PUSH
132533: LD_VAR 0 1
132537: ARRAY
132538: PUSH
132539: LD_VAR 0 2
132543: ARRAY
132544: PUSH
132545: LD_INT 1
132547: ARRAY
132548: PPUSH
132549: LD_EXP 217
132553: PUSH
132554: LD_VAR 0 1
132558: ARRAY
132559: PUSH
132560: LD_VAR 0 2
132564: ARRAY
132565: PUSH
132566: LD_INT 2
132568: ARRAY
132569: PPUSH
132570: CALL_OW 428
132574: ST_TO_ADDR
// if not tmp then
132575: LD_VAR 0 4
132579: NOT
132580: IFFALSE 132584
// continue ;
132582: GO 132499
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
132584: LD_VAR 0 4
132588: PUSH
132589: LD_INT 81
132591: PUSH
132592: LD_VAR 0 3
132596: PUSH
132597: EMPTY
132598: LIST
132599: LIST
132600: PPUSH
132601: CALL_OW 69
132605: IN
132606: PUSH
132607: LD_EXP 217
132611: PUSH
132612: LD_VAR 0 1
132616: ARRAY
132617: PUSH
132618: LD_VAR 0 2
132622: ARRAY
132623: PUSH
132624: LD_INT 1
132626: ARRAY
132627: PPUSH
132628: LD_EXP 217
132632: PUSH
132633: LD_VAR 0 1
132637: ARRAY
132638: PUSH
132639: LD_VAR 0 2
132643: ARRAY
132644: PUSH
132645: LD_INT 2
132647: ARRAY
132648: PPUSH
132649: CALL_OW 458
132653: AND
132654: IFFALSE 132748
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
132656: LD_EXP 217
132660: PUSH
132661: LD_VAR 0 1
132665: ARRAY
132666: PUSH
132667: LD_VAR 0 2
132671: ARRAY
132672: PUSH
132673: LD_INT 1
132675: ARRAY
132676: PPUSH
132677: LD_EXP 217
132681: PUSH
132682: LD_VAR 0 1
132686: ARRAY
132687: PUSH
132688: LD_VAR 0 2
132692: ARRAY
132693: PUSH
132694: LD_INT 2
132696: ARRAY
132697: PPUSH
132698: LD_VAR 0 3
132702: PPUSH
132703: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
132707: LD_ADDR_EXP 217
132711: PUSH
132712: LD_EXP 217
132716: PPUSH
132717: LD_VAR 0 1
132721: PPUSH
132722: LD_EXP 217
132726: PUSH
132727: LD_VAR 0 1
132731: ARRAY
132732: PPUSH
132733: LD_VAR 0 2
132737: PPUSH
132738: CALL_OW 3
132742: PPUSH
132743: CALL_OW 1
132747: ST_TO_ADDR
// end ; end ;
132748: GO 132499
132750: POP
132751: POP
// end ;
132752: GO 132417
132754: POP
132755: POP
// end ;
132756: PPOPN 4
132758: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
132759: LD_INT 0
132761: PPUSH
132762: PPUSH
// result := false ;
132763: LD_ADDR_VAR 0 4
132767: PUSH
132768: LD_INT 0
132770: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
132771: LD_VAR 0 1
132775: PPUSH
132776: CALL_OW 264
132780: PUSH
132781: LD_INT 81
132783: EQUAL
132784: NOT
132785: IFFALSE 132789
// exit ;
132787: GO 133029
// index := GetElementIndex ( minersList , unit ) ;
132789: LD_ADDR_VAR 0 5
132793: PUSH
132794: LD_EXP 216
132798: PPUSH
132799: LD_VAR 0 1
132803: PPUSH
132804: CALL 75040 0 2
132808: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
132809: LD_EXP 217
132813: PUSH
132814: LD_VAR 0 5
132818: ARRAY
132819: PUSH
132820: LD_EXP 218
132824: GREATEREQUAL
132825: IFFALSE 132829
// exit ;
132827: GO 133029
// ComMoveXY ( unit , x , y ) ;
132829: LD_VAR 0 1
132833: PPUSH
132834: LD_VAR 0 2
132838: PPUSH
132839: LD_VAR 0 3
132843: PPUSH
132844: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
132848: LD_INT 35
132850: PPUSH
132851: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
132855: LD_VAR 0 1
132859: PPUSH
132860: LD_VAR 0 2
132864: PPUSH
132865: LD_VAR 0 3
132869: PPUSH
132870: CALL 106801 0 3
132874: NOT
132875: PUSH
132876: LD_VAR 0 1
132880: PPUSH
132881: CALL_OW 314
132885: AND
132886: IFFALSE 132890
// exit ;
132888: GO 133029
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
132890: LD_VAR 0 2
132894: PPUSH
132895: LD_VAR 0 3
132899: PPUSH
132900: CALL_OW 428
132904: PUSH
132905: LD_VAR 0 1
132909: EQUAL
132910: PUSH
132911: LD_VAR 0 1
132915: PPUSH
132916: CALL_OW 314
132920: NOT
132921: AND
132922: IFFALSE 132848
// PlaySoundXY ( x , y , PlantMine ) ;
132924: LD_VAR 0 2
132928: PPUSH
132929: LD_VAR 0 3
132933: PPUSH
132934: LD_STRING PlantMine
132936: PPUSH
132937: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
132941: LD_VAR 0 2
132945: PPUSH
132946: LD_VAR 0 3
132950: PPUSH
132951: LD_VAR 0 1
132955: PPUSH
132956: CALL_OW 255
132960: PPUSH
132961: LD_INT 0
132963: PPUSH
132964: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
132968: LD_ADDR_EXP 217
132972: PUSH
132973: LD_EXP 217
132977: PPUSH
132978: LD_VAR 0 5
132982: PUSH
132983: LD_EXP 217
132987: PUSH
132988: LD_VAR 0 5
132992: ARRAY
132993: PUSH
132994: LD_INT 1
132996: PLUS
132997: PUSH
132998: EMPTY
132999: LIST
133000: LIST
133001: PPUSH
133002: LD_VAR 0 2
133006: PUSH
133007: LD_VAR 0 3
133011: PUSH
133012: EMPTY
133013: LIST
133014: LIST
133015: PPUSH
133016: CALL 75255 0 3
133020: ST_TO_ADDR
// result := true ;
133021: LD_ADDR_VAR 0 4
133025: PUSH
133026: LD_INT 1
133028: ST_TO_ADDR
// end ;
133029: LD_VAR 0 4
133033: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
133034: LD_INT 0
133036: PPUSH
133037: PPUSH
133038: PPUSH
// if not unit in minersList then
133039: LD_VAR 0 1
133043: PUSH
133044: LD_EXP 216
133048: IN
133049: NOT
133050: IFFALSE 133054
// exit ;
133052: GO 133446
// index := GetElementIndex ( minersList , unit ) ;
133054: LD_ADDR_VAR 0 6
133058: PUSH
133059: LD_EXP 216
133063: PPUSH
133064: LD_VAR 0 1
133068: PPUSH
133069: CALL 75040 0 2
133073: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
133074: LD_ADDR_VAR 0 5
133078: PUSH
133079: DOUBLE
133080: LD_EXP 217
133084: PUSH
133085: LD_VAR 0 6
133089: ARRAY
133090: INC
133091: ST_TO_ADDR
133092: LD_INT 1
133094: PUSH
133095: FOR_DOWNTO
133096: IFFALSE 133257
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
133098: LD_EXP 217
133102: PUSH
133103: LD_VAR 0 6
133107: ARRAY
133108: PUSH
133109: LD_VAR 0 5
133113: ARRAY
133114: PUSH
133115: LD_INT 1
133117: ARRAY
133118: PUSH
133119: LD_VAR 0 2
133123: EQUAL
133124: PUSH
133125: LD_EXP 217
133129: PUSH
133130: LD_VAR 0 6
133134: ARRAY
133135: PUSH
133136: LD_VAR 0 5
133140: ARRAY
133141: PUSH
133142: LD_INT 2
133144: ARRAY
133145: PUSH
133146: LD_VAR 0 3
133150: EQUAL
133151: AND
133152: IFFALSE 133255
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
133154: LD_EXP 217
133158: PUSH
133159: LD_VAR 0 6
133163: ARRAY
133164: PUSH
133165: LD_VAR 0 5
133169: ARRAY
133170: PUSH
133171: LD_INT 1
133173: ARRAY
133174: PPUSH
133175: LD_EXP 217
133179: PUSH
133180: LD_VAR 0 6
133184: ARRAY
133185: PUSH
133186: LD_VAR 0 5
133190: ARRAY
133191: PUSH
133192: LD_INT 2
133194: ARRAY
133195: PPUSH
133196: LD_VAR 0 1
133200: PPUSH
133201: CALL_OW 255
133205: PPUSH
133206: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
133210: LD_ADDR_EXP 217
133214: PUSH
133215: LD_EXP 217
133219: PPUSH
133220: LD_VAR 0 6
133224: PPUSH
133225: LD_EXP 217
133229: PUSH
133230: LD_VAR 0 6
133234: ARRAY
133235: PPUSH
133236: LD_VAR 0 5
133240: PPUSH
133241: CALL_OW 3
133245: PPUSH
133246: CALL_OW 1
133250: ST_TO_ADDR
// exit ;
133251: POP
133252: POP
133253: GO 133446
// end ; end ;
133255: GO 133095
133257: POP
133258: POP
// for i := minerMinesList [ index ] downto 1 do
133259: LD_ADDR_VAR 0 5
133263: PUSH
133264: DOUBLE
133265: LD_EXP 217
133269: PUSH
133270: LD_VAR 0 6
133274: ARRAY
133275: INC
133276: ST_TO_ADDR
133277: LD_INT 1
133279: PUSH
133280: FOR_DOWNTO
133281: IFFALSE 133444
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
133283: LD_EXP 217
133287: PUSH
133288: LD_VAR 0 6
133292: ARRAY
133293: PUSH
133294: LD_VAR 0 5
133298: ARRAY
133299: PUSH
133300: LD_INT 1
133302: ARRAY
133303: PPUSH
133304: LD_EXP 217
133308: PUSH
133309: LD_VAR 0 6
133313: ARRAY
133314: PUSH
133315: LD_VAR 0 5
133319: ARRAY
133320: PUSH
133321: LD_INT 2
133323: ARRAY
133324: PPUSH
133325: LD_VAR 0 2
133329: PPUSH
133330: LD_VAR 0 3
133334: PPUSH
133335: CALL_OW 298
133339: PUSH
133340: LD_INT 6
133342: LESS
133343: IFFALSE 133442
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
133345: LD_EXP 217
133349: PUSH
133350: LD_VAR 0 6
133354: ARRAY
133355: PUSH
133356: LD_VAR 0 5
133360: ARRAY
133361: PUSH
133362: LD_INT 1
133364: ARRAY
133365: PPUSH
133366: LD_EXP 217
133370: PUSH
133371: LD_VAR 0 6
133375: ARRAY
133376: PUSH
133377: LD_VAR 0 5
133381: ARRAY
133382: PUSH
133383: LD_INT 2
133385: ARRAY
133386: PPUSH
133387: LD_VAR 0 1
133391: PPUSH
133392: CALL_OW 255
133396: PPUSH
133397: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
133401: LD_ADDR_EXP 217
133405: PUSH
133406: LD_EXP 217
133410: PPUSH
133411: LD_VAR 0 6
133415: PPUSH
133416: LD_EXP 217
133420: PUSH
133421: LD_VAR 0 6
133425: ARRAY
133426: PPUSH
133427: LD_VAR 0 5
133431: PPUSH
133432: CALL_OW 3
133436: PPUSH
133437: CALL_OW 1
133441: ST_TO_ADDR
// end ; end ;
133442: GO 133280
133444: POP
133445: POP
// end ;
133446: LD_VAR 0 4
133450: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
133451: LD_INT 0
133453: PPUSH
133454: PPUSH
133455: PPUSH
133456: PPUSH
133457: PPUSH
133458: PPUSH
133459: PPUSH
133460: PPUSH
133461: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
133462: LD_VAR 0 1
133466: PPUSH
133467: CALL_OW 264
133471: PUSH
133472: LD_INT 81
133474: EQUAL
133475: NOT
133476: PUSH
133477: LD_VAR 0 1
133481: PUSH
133482: LD_EXP 216
133486: IN
133487: NOT
133488: OR
133489: IFFALSE 133493
// exit ;
133491: GO 133815
// index := GetElementIndex ( minersList , unit ) ;
133493: LD_ADDR_VAR 0 6
133497: PUSH
133498: LD_EXP 216
133502: PPUSH
133503: LD_VAR 0 1
133507: PPUSH
133508: CALL 75040 0 2
133512: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
133513: LD_ADDR_VAR 0 8
133517: PUSH
133518: LD_EXP 218
133522: PUSH
133523: LD_EXP 217
133527: PUSH
133528: LD_VAR 0 6
133532: ARRAY
133533: MINUS
133534: ST_TO_ADDR
// if not minesFreeAmount then
133535: LD_VAR 0 8
133539: NOT
133540: IFFALSE 133544
// exit ;
133542: GO 133815
// tmp := [ ] ;
133544: LD_ADDR_VAR 0 7
133548: PUSH
133549: EMPTY
133550: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
133551: LD_ADDR_VAR 0 5
133555: PUSH
133556: DOUBLE
133557: LD_INT 1
133559: DEC
133560: ST_TO_ADDR
133561: LD_VAR 0 8
133565: PUSH
133566: FOR_TO
133567: IFFALSE 133762
// begin _d := rand ( 0 , 5 ) ;
133569: LD_ADDR_VAR 0 11
133573: PUSH
133574: LD_INT 0
133576: PPUSH
133577: LD_INT 5
133579: PPUSH
133580: CALL_OW 12
133584: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
133585: LD_ADDR_VAR 0 12
133589: PUSH
133590: LD_INT 2
133592: PPUSH
133593: LD_INT 6
133595: PPUSH
133596: CALL_OW 12
133600: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
133601: LD_ADDR_VAR 0 9
133605: PUSH
133606: LD_VAR 0 2
133610: PPUSH
133611: LD_VAR 0 11
133615: PPUSH
133616: LD_VAR 0 12
133620: PPUSH
133621: CALL_OW 272
133625: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
133626: LD_ADDR_VAR 0 10
133630: PUSH
133631: LD_VAR 0 3
133635: PPUSH
133636: LD_VAR 0 11
133640: PPUSH
133641: LD_VAR 0 12
133645: PPUSH
133646: CALL_OW 273
133650: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
133651: LD_VAR 0 9
133655: PPUSH
133656: LD_VAR 0 10
133660: PPUSH
133661: CALL_OW 488
133665: PUSH
133666: LD_VAR 0 9
133670: PUSH
133671: LD_VAR 0 10
133675: PUSH
133676: EMPTY
133677: LIST
133678: LIST
133679: PUSH
133680: LD_VAR 0 7
133684: IN
133685: NOT
133686: AND
133687: PUSH
133688: LD_VAR 0 9
133692: PPUSH
133693: LD_VAR 0 10
133697: PPUSH
133698: CALL_OW 458
133702: NOT
133703: AND
133704: IFFALSE 133746
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
133706: LD_ADDR_VAR 0 7
133710: PUSH
133711: LD_VAR 0 7
133715: PPUSH
133716: LD_VAR 0 7
133720: PUSH
133721: LD_INT 1
133723: PLUS
133724: PPUSH
133725: LD_VAR 0 9
133729: PUSH
133730: LD_VAR 0 10
133734: PUSH
133735: EMPTY
133736: LIST
133737: LIST
133738: PPUSH
133739: CALL_OW 1
133743: ST_TO_ADDR
133744: GO 133760
// i := i - 1 ;
133746: LD_ADDR_VAR 0 5
133750: PUSH
133751: LD_VAR 0 5
133755: PUSH
133756: LD_INT 1
133758: MINUS
133759: ST_TO_ADDR
// end ;
133760: GO 133566
133762: POP
133763: POP
// for i in tmp do
133764: LD_ADDR_VAR 0 5
133768: PUSH
133769: LD_VAR 0 7
133773: PUSH
133774: FOR_IN
133775: IFFALSE 133813
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
133777: LD_VAR 0 1
133781: PPUSH
133782: LD_VAR 0 5
133786: PUSH
133787: LD_INT 1
133789: ARRAY
133790: PPUSH
133791: LD_VAR 0 5
133795: PUSH
133796: LD_INT 2
133798: ARRAY
133799: PPUSH
133800: CALL 132759 0 3
133804: NOT
133805: IFFALSE 133811
// exit ;
133807: POP
133808: POP
133809: GO 133815
133811: GO 133774
133813: POP
133814: POP
// end ;
133815: LD_VAR 0 4
133819: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , dir , viewRange , _x , _y , _d , p ; begin
133820: LD_INT 0
133822: PPUSH
133823: PPUSH
133824: PPUSH
133825: PPUSH
133826: PPUSH
133827: PPUSH
133828: PPUSH
133829: PPUSH
133830: PPUSH
// if GetClass ( unit ) <> class_sniper then
133831: LD_VAR 0 1
133835: PPUSH
133836: CALL_OW 257
133840: PUSH
133841: LD_INT 5
133843: NONEQUAL
133844: IFFALSE 133848
// exit ;
133846: GO 134314
// dist := 8 ;
133848: LD_ADDR_VAR 0 5
133852: PUSH
133853: LD_INT 8
133855: ST_TO_ADDR
// viewRange := 12 ;
133856: LD_ADDR_VAR 0 8
133860: PUSH
133861: LD_INT 12
133863: ST_TO_ADDR
// side := GetSide ( unit ) ;
133864: LD_ADDR_VAR 0 6
133868: PUSH
133869: LD_VAR 0 1
133873: PPUSH
133874: CALL_OW 255
133878: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
133879: LD_INT 61
133881: PPUSH
133882: LD_VAR 0 6
133886: PPUSH
133887: CALL_OW 321
133891: PUSH
133892: LD_INT 2
133894: EQUAL
133895: IFFALSE 133905
// viewRange := 16 ;
133897: LD_ADDR_VAR 0 8
133901: PUSH
133902: LD_INT 16
133904: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
133905: LD_VAR 0 1
133909: PPUSH
133910: LD_VAR 0 2
133914: PPUSH
133915: LD_VAR 0 3
133919: PPUSH
133920: CALL_OW 297
133924: PUSH
133925: LD_VAR 0 5
133929: GREATER
133930: IFFALSE 134009
// begin ComMoveXY ( unit , x , y ) ;
133932: LD_VAR 0 1
133936: PPUSH
133937: LD_VAR 0 2
133941: PPUSH
133942: LD_VAR 0 3
133946: PPUSH
133947: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
133951: LD_INT 35
133953: PPUSH
133954: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
133958: LD_VAR 0 1
133962: PPUSH
133963: LD_VAR 0 2
133967: PPUSH
133968: LD_VAR 0 3
133972: PPUSH
133973: CALL 106801 0 3
133977: NOT
133978: IFFALSE 133982
// exit ;
133980: GO 134314
// until GetDistUnitXY ( unit , x , y ) < dist ;
133982: LD_VAR 0 1
133986: PPUSH
133987: LD_VAR 0 2
133991: PPUSH
133992: LD_VAR 0 3
133996: PPUSH
133997: CALL_OW 297
134001: PUSH
134002: LD_VAR 0 5
134006: LESS
134007: IFFALSE 133951
// end ; ComTurnXY ( unit , x , y ) ;
134009: LD_VAR 0 1
134013: PPUSH
134014: LD_VAR 0 2
134018: PPUSH
134019: LD_VAR 0 3
134023: PPUSH
134024: CALL_OW 118
// repeat if Multiplayer then
134028: LD_OWVAR 4
134032: IFFALSE 134043
// wait ( 35 ) else
134034: LD_INT 35
134036: PPUSH
134037: CALL_OW 67
134041: GO 134050
// wait ( 5 ) ;
134043: LD_INT 5
134045: PPUSH
134046: CALL_OW 67
// _d := GetDir ( unit ) ;
134050: LD_ADDR_VAR 0 11
134054: PUSH
134055: LD_VAR 0 1
134059: PPUSH
134060: CALL_OW 254
134064: ST_TO_ADDR
// dir := GetDirFromHex ( GetX ( unit ) , GetY ( unit ) , x , y ) ;
134065: LD_ADDR_VAR 0 7
134069: PUSH
134070: LD_VAR 0 1
134074: PPUSH
134075: CALL_OW 250
134079: PPUSH
134080: LD_VAR 0 1
134084: PPUSH
134085: CALL_OW 251
134089: PPUSH
134090: LD_VAR 0 2
134094: PPUSH
134095: LD_VAR 0 3
134099: PPUSH
134100: CALL 109409 0 4
134104: ST_TO_ADDR
// until dir = _d ;
134105: LD_VAR 0 7
134109: PUSH
134110: LD_VAR 0 11
134114: EQUAL
134115: IFFALSE 134028
// _x := ShiftX ( GetX ( unit ) , dir , dist ) ;
134117: LD_ADDR_VAR 0 9
134121: PUSH
134122: LD_VAR 0 1
134126: PPUSH
134127: CALL_OW 250
134131: PPUSH
134132: LD_VAR 0 7
134136: PPUSH
134137: LD_VAR 0 5
134141: PPUSH
134142: CALL_OW 272
134146: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , dir , dist ) ;
134147: LD_ADDR_VAR 0 10
134151: PUSH
134152: LD_VAR 0 1
134156: PPUSH
134157: CALL_OW 251
134161: PPUSH
134162: LD_VAR 0 7
134166: PPUSH
134167: LD_VAR 0 5
134171: PPUSH
134172: CALL_OW 273
134176: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
134177: LD_VAR 0 9
134181: PPUSH
134182: LD_VAR 0 10
134186: PPUSH
134187: CALL_OW 488
134191: NOT
134192: IFFALSE 134196
// exit ;
134194: GO 134314
// ComAnimCustom ( unit , 1 ) ;
134196: LD_VAR 0 1
134200: PPUSH
134201: LD_INT 1
134203: PPUSH
134204: CALL_OW 592
// p := 0 ;
134208: LD_ADDR_VAR 0 12
134212: PUSH
134213: LD_INT 0
134215: ST_TO_ADDR
// PlaceSeeing ( _x , _y , side , viewRange ) ;
134216: LD_VAR 0 9
134220: PPUSH
134221: LD_VAR 0 10
134225: PPUSH
134226: LD_VAR 0 6
134230: PPUSH
134231: LD_VAR 0 8
134235: PPUSH
134236: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
134240: LD_INT 35
134242: PPUSH
134243: CALL_OW 67
// p := Inc ( p ) ;
134247: LD_ADDR_VAR 0 12
134251: PUSH
134252: LD_VAR 0 12
134256: PPUSH
134257: CALL 109365 0 1
134261: ST_TO_ADDR
// until p = 3 or not IsOk ( unit ) or IsDead ( unit ) ;
134262: LD_VAR 0 12
134266: PUSH
134267: LD_INT 3
134269: EQUAL
134270: PUSH
134271: LD_VAR 0 1
134275: PPUSH
134276: CALL_OW 302
134280: NOT
134281: OR
134282: PUSH
134283: LD_VAR 0 1
134287: PPUSH
134288: CALL_OW 301
134292: OR
134293: IFFALSE 134240
// RemoveSeeing ( _x , _y , side ) ;
134295: LD_VAR 0 9
134299: PPUSH
134300: LD_VAR 0 10
134304: PPUSH
134305: LD_VAR 0 6
134309: PPUSH
134310: CALL_OW 331
// end ; end_of_file
134314: LD_VAR 0 4
134318: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
134319: LD_INT 0
134321: PPUSH
134322: PPUSH
134323: PPUSH
134324: PPUSH
134325: PPUSH
134326: PPUSH
134327: PPUSH
134328: PPUSH
134329: PPUSH
134330: PPUSH
134331: PPUSH
134332: PPUSH
134333: PPUSH
134334: PPUSH
134335: PPUSH
134336: PPUSH
134337: PPUSH
134338: PPUSH
134339: PPUSH
134340: PPUSH
134341: PPUSH
134342: PPUSH
134343: PPUSH
134344: PPUSH
134345: PPUSH
134346: PPUSH
134347: PPUSH
134348: PPUSH
134349: PPUSH
134350: PPUSH
134351: PPUSH
134352: PPUSH
134353: PPUSH
134354: PPUSH
// if not list then
134355: LD_VAR 0 1
134359: NOT
134360: IFFALSE 134364
// exit ;
134362: GO 139023
// base := list [ 1 ] ;
134364: LD_ADDR_VAR 0 3
134368: PUSH
134369: LD_VAR 0 1
134373: PUSH
134374: LD_INT 1
134376: ARRAY
134377: ST_TO_ADDR
// group := list [ 2 ] ;
134378: LD_ADDR_VAR 0 4
134382: PUSH
134383: LD_VAR 0 1
134387: PUSH
134388: LD_INT 2
134390: ARRAY
134391: ST_TO_ADDR
// path := list [ 3 ] ;
134392: LD_ADDR_VAR 0 5
134396: PUSH
134397: LD_VAR 0 1
134401: PUSH
134402: LD_INT 3
134404: ARRAY
134405: ST_TO_ADDR
// flags := list [ 4 ] ;
134406: LD_ADDR_VAR 0 6
134410: PUSH
134411: LD_VAR 0 1
134415: PUSH
134416: LD_INT 4
134418: ARRAY
134419: ST_TO_ADDR
// mined := [ ] ;
134420: LD_ADDR_VAR 0 27
134424: PUSH
134425: EMPTY
134426: ST_TO_ADDR
// bombed := [ ] ;
134427: LD_ADDR_VAR 0 28
134431: PUSH
134432: EMPTY
134433: ST_TO_ADDR
// healers := [ ] ;
134434: LD_ADDR_VAR 0 31
134438: PUSH
134439: EMPTY
134440: ST_TO_ADDR
// to_heal := [ ] ;
134441: LD_ADDR_VAR 0 30
134445: PUSH
134446: EMPTY
134447: ST_TO_ADDR
// repairs := [ ] ;
134448: LD_ADDR_VAR 0 33
134452: PUSH
134453: EMPTY
134454: ST_TO_ADDR
// to_repair := [ ] ;
134455: LD_ADDR_VAR 0 32
134459: PUSH
134460: EMPTY
134461: ST_TO_ADDR
// if not group or not path then
134462: LD_VAR 0 4
134466: NOT
134467: PUSH
134468: LD_VAR 0 5
134472: NOT
134473: OR
134474: IFFALSE 134478
// exit ;
134476: GO 139023
// side := GetSide ( group [ 1 ] ) ;
134478: LD_ADDR_VAR 0 35
134482: PUSH
134483: LD_VAR 0 4
134487: PUSH
134488: LD_INT 1
134490: ARRAY
134491: PPUSH
134492: CALL_OW 255
134496: ST_TO_ADDR
// if flags then
134497: LD_VAR 0 6
134501: IFFALSE 134645
// begin f_ignore_area := flags [ 1 ] ;
134503: LD_ADDR_VAR 0 17
134507: PUSH
134508: LD_VAR 0 6
134512: PUSH
134513: LD_INT 1
134515: ARRAY
134516: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
134517: LD_ADDR_VAR 0 18
134521: PUSH
134522: LD_VAR 0 6
134526: PUSH
134527: LD_INT 2
134529: ARRAY
134530: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
134531: LD_ADDR_VAR 0 19
134535: PUSH
134536: LD_VAR 0 6
134540: PUSH
134541: LD_INT 3
134543: ARRAY
134544: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
134545: LD_ADDR_VAR 0 20
134549: PUSH
134550: LD_VAR 0 6
134554: PUSH
134555: LD_INT 4
134557: ARRAY
134558: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
134559: LD_ADDR_VAR 0 21
134563: PUSH
134564: LD_VAR 0 6
134568: PUSH
134569: LD_INT 5
134571: ARRAY
134572: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
134573: LD_ADDR_VAR 0 22
134577: PUSH
134578: LD_VAR 0 6
134582: PUSH
134583: LD_INT 6
134585: ARRAY
134586: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
134587: LD_ADDR_VAR 0 23
134591: PUSH
134592: LD_VAR 0 6
134596: PUSH
134597: LD_INT 7
134599: ARRAY
134600: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
134601: LD_ADDR_VAR 0 24
134605: PUSH
134606: LD_VAR 0 6
134610: PUSH
134611: LD_INT 8
134613: ARRAY
134614: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
134615: LD_ADDR_VAR 0 25
134619: PUSH
134620: LD_VAR 0 6
134624: PUSH
134625: LD_INT 9
134627: ARRAY
134628: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
134629: LD_ADDR_VAR 0 26
134633: PUSH
134634: LD_VAR 0 6
134638: PUSH
134639: LD_INT 10
134641: ARRAY
134642: ST_TO_ADDR
// end else
134643: GO 134725
// begin f_ignore_area := false ;
134645: LD_ADDR_VAR 0 17
134649: PUSH
134650: LD_INT 0
134652: ST_TO_ADDR
// f_capture := false ;
134653: LD_ADDR_VAR 0 18
134657: PUSH
134658: LD_INT 0
134660: ST_TO_ADDR
// f_ignore_civ := false ;
134661: LD_ADDR_VAR 0 19
134665: PUSH
134666: LD_INT 0
134668: ST_TO_ADDR
// f_murder := false ;
134669: LD_ADDR_VAR 0 20
134673: PUSH
134674: LD_INT 0
134676: ST_TO_ADDR
// f_mines := false ;
134677: LD_ADDR_VAR 0 21
134681: PUSH
134682: LD_INT 0
134684: ST_TO_ADDR
// f_repair := false ;
134685: LD_ADDR_VAR 0 22
134689: PUSH
134690: LD_INT 0
134692: ST_TO_ADDR
// f_heal := false ;
134693: LD_ADDR_VAR 0 23
134697: PUSH
134698: LD_INT 0
134700: ST_TO_ADDR
// f_spacetime := false ;
134701: LD_ADDR_VAR 0 24
134705: PUSH
134706: LD_INT 0
134708: ST_TO_ADDR
// f_attack_depot := false ;
134709: LD_ADDR_VAR 0 25
134713: PUSH
134714: LD_INT 0
134716: ST_TO_ADDR
// f_crawl := false ;
134717: LD_ADDR_VAR 0 26
134721: PUSH
134722: LD_INT 0
134724: ST_TO_ADDR
// end ; if f_heal then
134725: LD_VAR 0 23
134729: IFFALSE 134756
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
134731: LD_ADDR_VAR 0 31
134735: PUSH
134736: LD_VAR 0 4
134740: PPUSH
134741: LD_INT 25
134743: PUSH
134744: LD_INT 4
134746: PUSH
134747: EMPTY
134748: LIST
134749: LIST
134750: PPUSH
134751: CALL_OW 72
134755: ST_TO_ADDR
// if f_repair then
134756: LD_VAR 0 22
134760: IFFALSE 134787
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
134762: LD_ADDR_VAR 0 33
134766: PUSH
134767: LD_VAR 0 4
134771: PPUSH
134772: LD_INT 25
134774: PUSH
134775: LD_INT 3
134777: PUSH
134778: EMPTY
134779: LIST
134780: LIST
134781: PPUSH
134782: CALL_OW 72
134786: ST_TO_ADDR
// units_path := [ ] ;
134787: LD_ADDR_VAR 0 16
134791: PUSH
134792: EMPTY
134793: ST_TO_ADDR
// for i = 1 to group do
134794: LD_ADDR_VAR 0 7
134798: PUSH
134799: DOUBLE
134800: LD_INT 1
134802: DEC
134803: ST_TO_ADDR
134804: LD_VAR 0 4
134808: PUSH
134809: FOR_TO
134810: IFFALSE 134839
// units_path := Replace ( units_path , i , path ) ;
134812: LD_ADDR_VAR 0 16
134816: PUSH
134817: LD_VAR 0 16
134821: PPUSH
134822: LD_VAR 0 7
134826: PPUSH
134827: LD_VAR 0 5
134831: PPUSH
134832: CALL_OW 1
134836: ST_TO_ADDR
134837: GO 134809
134839: POP
134840: POP
// repeat for i = group downto 1 do
134841: LD_ADDR_VAR 0 7
134845: PUSH
134846: DOUBLE
134847: LD_VAR 0 4
134851: INC
134852: ST_TO_ADDR
134853: LD_INT 1
134855: PUSH
134856: FOR_DOWNTO
134857: IFFALSE 138979
// begin wait ( 5 ) ;
134859: LD_INT 5
134861: PPUSH
134862: CALL_OW 67
// tmp := [ ] ;
134866: LD_ADDR_VAR 0 14
134870: PUSH
134871: EMPTY
134872: ST_TO_ADDR
// attacking := false ;
134873: LD_ADDR_VAR 0 29
134877: PUSH
134878: LD_INT 0
134880: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
134881: LD_VAR 0 4
134885: PUSH
134886: LD_VAR 0 7
134890: ARRAY
134891: PPUSH
134892: CALL_OW 301
134896: PUSH
134897: LD_VAR 0 4
134901: PUSH
134902: LD_VAR 0 7
134906: ARRAY
134907: NOT
134908: OR
134909: IFFALSE 135018
// begin if GetType ( group [ i ] ) = unit_human then
134911: LD_VAR 0 4
134915: PUSH
134916: LD_VAR 0 7
134920: ARRAY
134921: PPUSH
134922: CALL_OW 247
134926: PUSH
134927: LD_INT 1
134929: EQUAL
134930: IFFALSE 134976
// begin to_heal := to_heal diff group [ i ] ;
134932: LD_ADDR_VAR 0 30
134936: PUSH
134937: LD_VAR 0 30
134941: PUSH
134942: LD_VAR 0 4
134946: PUSH
134947: LD_VAR 0 7
134951: ARRAY
134952: DIFF
134953: ST_TO_ADDR
// healers := healers diff group [ i ] ;
134954: LD_ADDR_VAR 0 31
134958: PUSH
134959: LD_VAR 0 31
134963: PUSH
134964: LD_VAR 0 4
134968: PUSH
134969: LD_VAR 0 7
134973: ARRAY
134974: DIFF
134975: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
134976: LD_ADDR_VAR 0 4
134980: PUSH
134981: LD_VAR 0 4
134985: PPUSH
134986: LD_VAR 0 7
134990: PPUSH
134991: CALL_OW 3
134995: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
134996: LD_ADDR_VAR 0 16
135000: PUSH
135001: LD_VAR 0 16
135005: PPUSH
135006: LD_VAR 0 7
135010: PPUSH
135011: CALL_OW 3
135015: ST_TO_ADDR
// continue ;
135016: GO 134856
// end ; if f_repair then
135018: LD_VAR 0 22
135022: IFFALSE 135511
// begin if GetType ( group [ i ] ) = unit_vehicle then
135024: LD_VAR 0 4
135028: PUSH
135029: LD_VAR 0 7
135033: ARRAY
135034: PPUSH
135035: CALL_OW 247
135039: PUSH
135040: LD_INT 2
135042: EQUAL
135043: IFFALSE 135233
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
135045: LD_VAR 0 4
135049: PUSH
135050: LD_VAR 0 7
135054: ARRAY
135055: PPUSH
135056: CALL_OW 256
135060: PUSH
135061: LD_INT 700
135063: LESS
135064: PUSH
135065: LD_VAR 0 4
135069: PUSH
135070: LD_VAR 0 7
135074: ARRAY
135075: PUSH
135076: LD_VAR 0 32
135080: IN
135081: NOT
135082: AND
135083: IFFALSE 135107
// to_repair := to_repair union group [ i ] ;
135085: LD_ADDR_VAR 0 32
135089: PUSH
135090: LD_VAR 0 32
135094: PUSH
135095: LD_VAR 0 4
135099: PUSH
135100: LD_VAR 0 7
135104: ARRAY
135105: UNION
135106: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
135107: LD_VAR 0 4
135111: PUSH
135112: LD_VAR 0 7
135116: ARRAY
135117: PPUSH
135118: CALL_OW 256
135122: PUSH
135123: LD_INT 1000
135125: EQUAL
135126: PUSH
135127: LD_VAR 0 4
135131: PUSH
135132: LD_VAR 0 7
135136: ARRAY
135137: PUSH
135138: LD_VAR 0 32
135142: IN
135143: AND
135144: IFFALSE 135168
// to_repair := to_repair diff group [ i ] ;
135146: LD_ADDR_VAR 0 32
135150: PUSH
135151: LD_VAR 0 32
135155: PUSH
135156: LD_VAR 0 4
135160: PUSH
135161: LD_VAR 0 7
135165: ARRAY
135166: DIFF
135167: ST_TO_ADDR
// if group [ i ] in to_repair then
135168: LD_VAR 0 4
135172: PUSH
135173: LD_VAR 0 7
135177: ARRAY
135178: PUSH
135179: LD_VAR 0 32
135183: IN
135184: IFFALSE 135231
// begin if not IsInArea ( group [ i ] , f_repair ) then
135186: LD_VAR 0 4
135190: PUSH
135191: LD_VAR 0 7
135195: ARRAY
135196: PPUSH
135197: LD_VAR 0 22
135201: PPUSH
135202: CALL_OW 308
135206: NOT
135207: IFFALSE 135229
// ComMoveToArea ( group [ i ] , f_repair ) ;
135209: LD_VAR 0 4
135213: PUSH
135214: LD_VAR 0 7
135218: ARRAY
135219: PPUSH
135220: LD_VAR 0 22
135224: PPUSH
135225: CALL_OW 113
// continue ;
135229: GO 134856
// end ; end else
135231: GO 135511
// if group [ i ] in repairs then
135233: LD_VAR 0 4
135237: PUSH
135238: LD_VAR 0 7
135242: ARRAY
135243: PUSH
135244: LD_VAR 0 33
135248: IN
135249: IFFALSE 135511
// begin if IsInUnit ( group [ i ] ) then
135251: LD_VAR 0 4
135255: PUSH
135256: LD_VAR 0 7
135260: ARRAY
135261: PPUSH
135262: CALL_OW 310
135266: IFFALSE 135334
// begin z := IsInUnit ( group [ i ] ) ;
135268: LD_ADDR_VAR 0 13
135272: PUSH
135273: LD_VAR 0 4
135277: PUSH
135278: LD_VAR 0 7
135282: ARRAY
135283: PPUSH
135284: CALL_OW 310
135288: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
135289: LD_VAR 0 13
135293: PUSH
135294: LD_VAR 0 32
135298: IN
135299: PUSH
135300: LD_VAR 0 13
135304: PPUSH
135305: LD_VAR 0 22
135309: PPUSH
135310: CALL_OW 308
135314: AND
135315: IFFALSE 135332
// ComExitVehicle ( group [ i ] ) ;
135317: LD_VAR 0 4
135321: PUSH
135322: LD_VAR 0 7
135326: ARRAY
135327: PPUSH
135328: CALL_OW 121
// end else
135332: GO 135511
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
135334: LD_ADDR_VAR 0 13
135338: PUSH
135339: LD_VAR 0 4
135343: PPUSH
135344: LD_INT 95
135346: PUSH
135347: LD_VAR 0 22
135351: PUSH
135352: EMPTY
135353: LIST
135354: LIST
135355: PUSH
135356: LD_INT 58
135358: PUSH
135359: EMPTY
135360: LIST
135361: PUSH
135362: EMPTY
135363: LIST
135364: LIST
135365: PPUSH
135366: CALL_OW 72
135370: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
135371: LD_VAR 0 4
135375: PUSH
135376: LD_VAR 0 7
135380: ARRAY
135381: PPUSH
135382: CALL_OW 314
135386: NOT
135387: IFFALSE 135509
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
135389: LD_ADDR_VAR 0 10
135393: PUSH
135394: LD_VAR 0 13
135398: PPUSH
135399: LD_VAR 0 4
135403: PUSH
135404: LD_VAR 0 7
135408: ARRAY
135409: PPUSH
135410: CALL_OW 74
135414: ST_TO_ADDR
// if not x then
135415: LD_VAR 0 10
135419: NOT
135420: IFFALSE 135424
// continue ;
135422: GO 134856
// if GetLives ( x ) < 1000 then
135424: LD_VAR 0 10
135428: PPUSH
135429: CALL_OW 256
135433: PUSH
135434: LD_INT 1000
135436: LESS
135437: IFFALSE 135461
// ComRepairVehicle ( group [ i ] , x ) else
135439: LD_VAR 0 4
135443: PUSH
135444: LD_VAR 0 7
135448: ARRAY
135449: PPUSH
135450: LD_VAR 0 10
135454: PPUSH
135455: CALL_OW 129
135459: GO 135509
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
135461: LD_VAR 0 23
135465: PUSH
135466: LD_VAR 0 4
135470: PUSH
135471: LD_VAR 0 7
135475: ARRAY
135476: PPUSH
135477: CALL_OW 256
135481: PUSH
135482: LD_INT 1000
135484: LESS
135485: AND
135486: NOT
135487: IFFALSE 135509
// ComEnterUnit ( group [ i ] , x ) ;
135489: LD_VAR 0 4
135493: PUSH
135494: LD_VAR 0 7
135498: ARRAY
135499: PPUSH
135500: LD_VAR 0 10
135504: PPUSH
135505: CALL_OW 120
// end ; continue ;
135509: GO 134856
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
135511: LD_VAR 0 23
135515: PUSH
135516: LD_VAR 0 4
135520: PUSH
135521: LD_VAR 0 7
135525: ARRAY
135526: PPUSH
135527: CALL_OW 247
135531: PUSH
135532: LD_INT 1
135534: EQUAL
135535: AND
135536: IFFALSE 136014
// begin if group [ i ] in healers then
135538: LD_VAR 0 4
135542: PUSH
135543: LD_VAR 0 7
135547: ARRAY
135548: PUSH
135549: LD_VAR 0 31
135553: IN
135554: IFFALSE 135827
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
135556: LD_VAR 0 4
135560: PUSH
135561: LD_VAR 0 7
135565: ARRAY
135566: PPUSH
135567: LD_VAR 0 23
135571: PPUSH
135572: CALL_OW 308
135576: NOT
135577: PUSH
135578: LD_VAR 0 4
135582: PUSH
135583: LD_VAR 0 7
135587: ARRAY
135588: PPUSH
135589: CALL_OW 314
135593: NOT
135594: AND
135595: IFFALSE 135619
// ComMoveToArea ( group [ i ] , f_heal ) else
135597: LD_VAR 0 4
135601: PUSH
135602: LD_VAR 0 7
135606: ARRAY
135607: PPUSH
135608: LD_VAR 0 23
135612: PPUSH
135613: CALL_OW 113
135617: GO 135825
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
135619: LD_VAR 0 4
135623: PUSH
135624: LD_VAR 0 7
135628: ARRAY
135629: PPUSH
135630: CALL 105384 0 1
135634: PPUSH
135635: CALL_OW 256
135639: PUSH
135640: LD_INT 1000
135642: EQUAL
135643: IFFALSE 135662
// ComStop ( group [ i ] ) else
135645: LD_VAR 0 4
135649: PUSH
135650: LD_VAR 0 7
135654: ARRAY
135655: PPUSH
135656: CALL_OW 141
135660: GO 135825
// if not HasTask ( group [ i ] ) and to_heal then
135662: LD_VAR 0 4
135666: PUSH
135667: LD_VAR 0 7
135671: ARRAY
135672: PPUSH
135673: CALL_OW 314
135677: NOT
135678: PUSH
135679: LD_VAR 0 30
135683: AND
135684: IFFALSE 135825
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
135686: LD_ADDR_VAR 0 13
135690: PUSH
135691: LD_VAR 0 30
135695: PPUSH
135696: LD_INT 3
135698: PUSH
135699: LD_INT 54
135701: PUSH
135702: EMPTY
135703: LIST
135704: PUSH
135705: EMPTY
135706: LIST
135707: LIST
135708: PPUSH
135709: CALL_OW 72
135713: PPUSH
135714: LD_VAR 0 4
135718: PUSH
135719: LD_VAR 0 7
135723: ARRAY
135724: PPUSH
135725: CALL_OW 74
135729: ST_TO_ADDR
// if z then
135730: LD_VAR 0 13
135734: IFFALSE 135825
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
135736: LD_INT 91
135738: PUSH
135739: LD_VAR 0 13
135743: PUSH
135744: LD_INT 10
135746: PUSH
135747: EMPTY
135748: LIST
135749: LIST
135750: LIST
135751: PUSH
135752: LD_INT 81
135754: PUSH
135755: LD_VAR 0 13
135759: PPUSH
135760: CALL_OW 255
135764: PUSH
135765: EMPTY
135766: LIST
135767: LIST
135768: PUSH
135769: EMPTY
135770: LIST
135771: LIST
135772: PPUSH
135773: CALL_OW 69
135777: PUSH
135778: LD_INT 0
135780: EQUAL
135781: IFFALSE 135805
// ComHeal ( group [ i ] , z ) else
135783: LD_VAR 0 4
135787: PUSH
135788: LD_VAR 0 7
135792: ARRAY
135793: PPUSH
135794: LD_VAR 0 13
135798: PPUSH
135799: CALL_OW 128
135803: GO 135825
// ComMoveToArea ( group [ i ] , f_heal ) ;
135805: LD_VAR 0 4
135809: PUSH
135810: LD_VAR 0 7
135814: ARRAY
135815: PPUSH
135816: LD_VAR 0 23
135820: PPUSH
135821: CALL_OW 113
// end ; continue ;
135825: GO 134856
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
135827: LD_VAR 0 4
135831: PUSH
135832: LD_VAR 0 7
135836: ARRAY
135837: PPUSH
135838: CALL_OW 256
135842: PUSH
135843: LD_INT 700
135845: LESS
135846: PUSH
135847: LD_VAR 0 4
135851: PUSH
135852: LD_VAR 0 7
135856: ARRAY
135857: PUSH
135858: LD_VAR 0 30
135862: IN
135863: NOT
135864: AND
135865: IFFALSE 135889
// to_heal := to_heal union group [ i ] ;
135867: LD_ADDR_VAR 0 30
135871: PUSH
135872: LD_VAR 0 30
135876: PUSH
135877: LD_VAR 0 4
135881: PUSH
135882: LD_VAR 0 7
135886: ARRAY
135887: UNION
135888: ST_TO_ADDR
// if group [ i ] in to_heal then
135889: LD_VAR 0 4
135893: PUSH
135894: LD_VAR 0 7
135898: ARRAY
135899: PUSH
135900: LD_VAR 0 30
135904: IN
135905: IFFALSE 136014
// begin if GetLives ( group [ i ] ) = 1000 then
135907: LD_VAR 0 4
135911: PUSH
135912: LD_VAR 0 7
135916: ARRAY
135917: PPUSH
135918: CALL_OW 256
135922: PUSH
135923: LD_INT 1000
135925: EQUAL
135926: IFFALSE 135952
// to_heal := to_heal diff group [ i ] else
135928: LD_ADDR_VAR 0 30
135932: PUSH
135933: LD_VAR 0 30
135937: PUSH
135938: LD_VAR 0 4
135942: PUSH
135943: LD_VAR 0 7
135947: ARRAY
135948: DIFF
135949: ST_TO_ADDR
135950: GO 136014
// begin if not IsInArea ( group [ i ] , to_heal ) then
135952: LD_VAR 0 4
135956: PUSH
135957: LD_VAR 0 7
135961: ARRAY
135962: PPUSH
135963: LD_VAR 0 30
135967: PPUSH
135968: CALL_OW 308
135972: NOT
135973: IFFALSE 135997
// ComMoveToArea ( group [ i ] , f_heal ) else
135975: LD_VAR 0 4
135979: PUSH
135980: LD_VAR 0 7
135984: ARRAY
135985: PPUSH
135986: LD_VAR 0 23
135990: PPUSH
135991: CALL_OW 113
135995: GO 136012
// ComHold ( group [ i ] ) ;
135997: LD_VAR 0 4
136001: PUSH
136002: LD_VAR 0 7
136006: ARRAY
136007: PPUSH
136008: CALL_OW 140
// continue ;
136012: GO 134856
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
136014: LD_VAR 0 4
136018: PUSH
136019: LD_VAR 0 7
136023: ARRAY
136024: PPUSH
136025: LD_INT 10
136027: PPUSH
136028: CALL 103146 0 2
136032: NOT
136033: PUSH
136034: LD_VAR 0 16
136038: PUSH
136039: LD_VAR 0 7
136043: ARRAY
136044: PUSH
136045: EMPTY
136046: EQUAL
136047: NOT
136048: AND
136049: IFFALSE 136315
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
136051: LD_VAR 0 4
136055: PUSH
136056: LD_VAR 0 7
136060: ARRAY
136061: PPUSH
136062: CALL_OW 262
136066: PUSH
136067: LD_INT 1
136069: PUSH
136070: LD_INT 2
136072: PUSH
136073: EMPTY
136074: LIST
136075: LIST
136076: IN
136077: IFFALSE 136118
// if GetFuel ( group [ i ] ) < 10 then
136079: LD_VAR 0 4
136083: PUSH
136084: LD_VAR 0 7
136088: ARRAY
136089: PPUSH
136090: CALL_OW 261
136094: PUSH
136095: LD_INT 10
136097: LESS
136098: IFFALSE 136118
// SetFuel ( group [ i ] , 12 ) ;
136100: LD_VAR 0 4
136104: PUSH
136105: LD_VAR 0 7
136109: ARRAY
136110: PPUSH
136111: LD_INT 12
136113: PPUSH
136114: CALL_OW 240
// if units_path [ i ] then
136118: LD_VAR 0 16
136122: PUSH
136123: LD_VAR 0 7
136127: ARRAY
136128: IFFALSE 136313
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
136130: LD_VAR 0 4
136134: PUSH
136135: LD_VAR 0 7
136139: ARRAY
136140: PPUSH
136141: LD_VAR 0 16
136145: PUSH
136146: LD_VAR 0 7
136150: ARRAY
136151: PUSH
136152: LD_INT 1
136154: ARRAY
136155: PUSH
136156: LD_INT 1
136158: ARRAY
136159: PPUSH
136160: LD_VAR 0 16
136164: PUSH
136165: LD_VAR 0 7
136169: ARRAY
136170: PUSH
136171: LD_INT 1
136173: ARRAY
136174: PUSH
136175: LD_INT 2
136177: ARRAY
136178: PPUSH
136179: CALL_OW 297
136183: PUSH
136184: LD_INT 6
136186: GREATER
136187: IFFALSE 136262
// begin if not HasTask ( group [ i ] ) then
136189: LD_VAR 0 4
136193: PUSH
136194: LD_VAR 0 7
136198: ARRAY
136199: PPUSH
136200: CALL_OW 314
136204: NOT
136205: IFFALSE 136260
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
136207: LD_VAR 0 4
136211: PUSH
136212: LD_VAR 0 7
136216: ARRAY
136217: PPUSH
136218: LD_VAR 0 16
136222: PUSH
136223: LD_VAR 0 7
136227: ARRAY
136228: PUSH
136229: LD_INT 1
136231: ARRAY
136232: PUSH
136233: LD_INT 1
136235: ARRAY
136236: PPUSH
136237: LD_VAR 0 16
136241: PUSH
136242: LD_VAR 0 7
136246: ARRAY
136247: PUSH
136248: LD_INT 1
136250: ARRAY
136251: PUSH
136252: LD_INT 2
136254: ARRAY
136255: PPUSH
136256: CALL_OW 114
// end else
136260: GO 136313
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
136262: LD_ADDR_VAR 0 15
136266: PUSH
136267: LD_VAR 0 16
136271: PUSH
136272: LD_VAR 0 7
136276: ARRAY
136277: PPUSH
136278: LD_INT 1
136280: PPUSH
136281: CALL_OW 3
136285: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
136286: LD_ADDR_VAR 0 16
136290: PUSH
136291: LD_VAR 0 16
136295: PPUSH
136296: LD_VAR 0 7
136300: PPUSH
136301: LD_VAR 0 15
136305: PPUSH
136306: CALL_OW 1
136310: ST_TO_ADDR
// continue ;
136311: GO 134856
// end ; end ; end else
136313: GO 138977
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
136315: LD_ADDR_VAR 0 14
136319: PUSH
136320: LD_INT 81
136322: PUSH
136323: LD_VAR 0 4
136327: PUSH
136328: LD_VAR 0 7
136332: ARRAY
136333: PPUSH
136334: CALL_OW 255
136338: PUSH
136339: EMPTY
136340: LIST
136341: LIST
136342: PPUSH
136343: CALL_OW 69
136347: ST_TO_ADDR
// if not tmp then
136348: LD_VAR 0 14
136352: NOT
136353: IFFALSE 136357
// continue ;
136355: GO 134856
// if f_ignore_area then
136357: LD_VAR 0 17
136361: IFFALSE 136449
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
136363: LD_ADDR_VAR 0 15
136367: PUSH
136368: LD_VAR 0 14
136372: PPUSH
136373: LD_INT 3
136375: PUSH
136376: LD_INT 92
136378: PUSH
136379: LD_VAR 0 17
136383: PUSH
136384: LD_INT 1
136386: ARRAY
136387: PUSH
136388: LD_VAR 0 17
136392: PUSH
136393: LD_INT 2
136395: ARRAY
136396: PUSH
136397: LD_VAR 0 17
136401: PUSH
136402: LD_INT 3
136404: ARRAY
136405: PUSH
136406: EMPTY
136407: LIST
136408: LIST
136409: LIST
136410: LIST
136411: PUSH
136412: EMPTY
136413: LIST
136414: LIST
136415: PPUSH
136416: CALL_OW 72
136420: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
136421: LD_VAR 0 14
136425: PUSH
136426: LD_VAR 0 15
136430: DIFF
136431: IFFALSE 136449
// tmp := tmp diff tmp2 ;
136433: LD_ADDR_VAR 0 14
136437: PUSH
136438: LD_VAR 0 14
136442: PUSH
136443: LD_VAR 0 15
136447: DIFF
136448: ST_TO_ADDR
// end ; if not f_murder then
136449: LD_VAR 0 20
136453: NOT
136454: IFFALSE 136512
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
136456: LD_ADDR_VAR 0 15
136460: PUSH
136461: LD_VAR 0 14
136465: PPUSH
136466: LD_INT 3
136468: PUSH
136469: LD_INT 50
136471: PUSH
136472: EMPTY
136473: LIST
136474: PUSH
136475: EMPTY
136476: LIST
136477: LIST
136478: PPUSH
136479: CALL_OW 72
136483: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
136484: LD_VAR 0 14
136488: PUSH
136489: LD_VAR 0 15
136493: DIFF
136494: IFFALSE 136512
// tmp := tmp diff tmp2 ;
136496: LD_ADDR_VAR 0 14
136500: PUSH
136501: LD_VAR 0 14
136505: PUSH
136506: LD_VAR 0 15
136510: DIFF
136511: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
136512: LD_ADDR_VAR 0 14
136516: PUSH
136517: LD_VAR 0 4
136521: PUSH
136522: LD_VAR 0 7
136526: ARRAY
136527: PPUSH
136528: LD_VAR 0 14
136532: PPUSH
136533: LD_INT 1
136535: PPUSH
136536: LD_INT 1
136538: PPUSH
136539: CALL 75690 0 4
136543: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
136544: LD_VAR 0 4
136548: PUSH
136549: LD_VAR 0 7
136553: ARRAY
136554: PPUSH
136555: CALL_OW 257
136559: PUSH
136560: LD_INT 1
136562: EQUAL
136563: IFFALSE 137011
// begin if WantPlant ( group [ i ] ) then
136565: LD_VAR 0 4
136569: PUSH
136570: LD_VAR 0 7
136574: ARRAY
136575: PPUSH
136576: CALL 75191 0 1
136580: IFFALSE 136584
// continue ;
136582: GO 134856
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
136584: LD_VAR 0 18
136588: PUSH
136589: LD_VAR 0 4
136593: PUSH
136594: LD_VAR 0 7
136598: ARRAY
136599: PPUSH
136600: CALL_OW 310
136604: NOT
136605: AND
136606: PUSH
136607: LD_VAR 0 14
136611: PUSH
136612: LD_INT 1
136614: ARRAY
136615: PUSH
136616: LD_VAR 0 14
136620: PPUSH
136621: LD_INT 21
136623: PUSH
136624: LD_INT 2
136626: PUSH
136627: EMPTY
136628: LIST
136629: LIST
136630: PUSH
136631: LD_INT 58
136633: PUSH
136634: EMPTY
136635: LIST
136636: PUSH
136637: EMPTY
136638: LIST
136639: LIST
136640: PPUSH
136641: CALL_OW 72
136645: IN
136646: AND
136647: IFFALSE 136683
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
136649: LD_VAR 0 4
136653: PUSH
136654: LD_VAR 0 7
136658: ARRAY
136659: PPUSH
136660: LD_VAR 0 14
136664: PUSH
136665: LD_INT 1
136667: ARRAY
136668: PPUSH
136669: CALL_OW 120
// attacking := true ;
136673: LD_ADDR_VAR 0 29
136677: PUSH
136678: LD_INT 1
136680: ST_TO_ADDR
// continue ;
136681: GO 134856
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
136683: LD_VAR 0 26
136687: PUSH
136688: LD_VAR 0 4
136692: PUSH
136693: LD_VAR 0 7
136697: ARRAY
136698: PPUSH
136699: CALL_OW 257
136703: PUSH
136704: LD_INT 1
136706: EQUAL
136707: AND
136708: PUSH
136709: LD_VAR 0 4
136713: PUSH
136714: LD_VAR 0 7
136718: ARRAY
136719: PPUSH
136720: CALL_OW 256
136724: PUSH
136725: LD_INT 800
136727: LESS
136728: AND
136729: PUSH
136730: LD_VAR 0 4
136734: PUSH
136735: LD_VAR 0 7
136739: ARRAY
136740: PPUSH
136741: CALL_OW 318
136745: NOT
136746: AND
136747: IFFALSE 136764
// ComCrawl ( group [ i ] ) ;
136749: LD_VAR 0 4
136753: PUSH
136754: LD_VAR 0 7
136758: ARRAY
136759: PPUSH
136760: CALL_OW 137
// if f_mines then
136764: LD_VAR 0 21
136768: IFFALSE 137011
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
136770: LD_VAR 0 14
136774: PUSH
136775: LD_INT 1
136777: ARRAY
136778: PPUSH
136779: CALL_OW 247
136783: PUSH
136784: LD_INT 3
136786: EQUAL
136787: PUSH
136788: LD_VAR 0 14
136792: PUSH
136793: LD_INT 1
136795: ARRAY
136796: PUSH
136797: LD_VAR 0 27
136801: IN
136802: NOT
136803: AND
136804: IFFALSE 137011
// begin x := GetX ( tmp [ 1 ] ) ;
136806: LD_ADDR_VAR 0 10
136810: PUSH
136811: LD_VAR 0 14
136815: PUSH
136816: LD_INT 1
136818: ARRAY
136819: PPUSH
136820: CALL_OW 250
136824: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
136825: LD_ADDR_VAR 0 11
136829: PUSH
136830: LD_VAR 0 14
136834: PUSH
136835: LD_INT 1
136837: ARRAY
136838: PPUSH
136839: CALL_OW 251
136843: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
136844: LD_ADDR_VAR 0 12
136848: PUSH
136849: LD_VAR 0 4
136853: PUSH
136854: LD_VAR 0 7
136858: ARRAY
136859: PPUSH
136860: CALL 103231 0 1
136864: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
136865: LD_VAR 0 4
136869: PUSH
136870: LD_VAR 0 7
136874: ARRAY
136875: PPUSH
136876: LD_VAR 0 10
136880: PPUSH
136881: LD_VAR 0 11
136885: PPUSH
136886: LD_VAR 0 14
136890: PUSH
136891: LD_INT 1
136893: ARRAY
136894: PPUSH
136895: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
136899: LD_VAR 0 4
136903: PUSH
136904: LD_VAR 0 7
136908: ARRAY
136909: PPUSH
136910: LD_VAR 0 10
136914: PPUSH
136915: LD_VAR 0 12
136919: PPUSH
136920: LD_INT 7
136922: PPUSH
136923: CALL_OW 272
136927: PPUSH
136928: LD_VAR 0 11
136932: PPUSH
136933: LD_VAR 0 12
136937: PPUSH
136938: LD_INT 7
136940: PPUSH
136941: CALL_OW 273
136945: PPUSH
136946: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
136950: LD_VAR 0 4
136954: PUSH
136955: LD_VAR 0 7
136959: ARRAY
136960: PPUSH
136961: LD_INT 71
136963: PPUSH
136964: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
136968: LD_ADDR_VAR 0 27
136972: PUSH
136973: LD_VAR 0 27
136977: PPUSH
136978: LD_VAR 0 27
136982: PUSH
136983: LD_INT 1
136985: PLUS
136986: PPUSH
136987: LD_VAR 0 14
136991: PUSH
136992: LD_INT 1
136994: ARRAY
136995: PPUSH
136996: CALL_OW 1
137000: ST_TO_ADDR
// attacking := true ;
137001: LD_ADDR_VAR 0 29
137005: PUSH
137006: LD_INT 1
137008: ST_TO_ADDR
// continue ;
137009: GO 134856
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
137011: LD_VAR 0 4
137015: PUSH
137016: LD_VAR 0 7
137020: ARRAY
137021: PPUSH
137022: CALL_OW 257
137026: PUSH
137027: LD_INT 17
137029: EQUAL
137030: PUSH
137031: LD_VAR 0 4
137035: PUSH
137036: LD_VAR 0 7
137040: ARRAY
137041: PPUSH
137042: CALL_OW 110
137046: PUSH
137047: LD_INT 71
137049: EQUAL
137050: NOT
137051: AND
137052: IFFALSE 137198
// begin attacking := false ;
137054: LD_ADDR_VAR 0 29
137058: PUSH
137059: LD_INT 0
137061: ST_TO_ADDR
// k := 5 ;
137062: LD_ADDR_VAR 0 9
137066: PUSH
137067: LD_INT 5
137069: ST_TO_ADDR
// if tmp < k then
137070: LD_VAR 0 14
137074: PUSH
137075: LD_VAR 0 9
137079: LESS
137080: IFFALSE 137092
// k := tmp ;
137082: LD_ADDR_VAR 0 9
137086: PUSH
137087: LD_VAR 0 14
137091: ST_TO_ADDR
// for j = 1 to k do
137092: LD_ADDR_VAR 0 8
137096: PUSH
137097: DOUBLE
137098: LD_INT 1
137100: DEC
137101: ST_TO_ADDR
137102: LD_VAR 0 9
137106: PUSH
137107: FOR_TO
137108: IFFALSE 137196
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
137110: LD_VAR 0 14
137114: PUSH
137115: LD_VAR 0 8
137119: ARRAY
137120: PUSH
137121: LD_VAR 0 14
137125: PPUSH
137126: LD_INT 58
137128: PUSH
137129: EMPTY
137130: LIST
137131: PPUSH
137132: CALL_OW 72
137136: IN
137137: NOT
137138: IFFALSE 137194
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
137140: LD_VAR 0 4
137144: PUSH
137145: LD_VAR 0 7
137149: ARRAY
137150: PPUSH
137151: LD_VAR 0 14
137155: PUSH
137156: LD_VAR 0 8
137160: ARRAY
137161: PPUSH
137162: CALL_OW 115
// attacking := true ;
137166: LD_ADDR_VAR 0 29
137170: PUSH
137171: LD_INT 1
137173: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
137174: LD_VAR 0 4
137178: PUSH
137179: LD_VAR 0 7
137183: ARRAY
137184: PPUSH
137185: LD_INT 71
137187: PPUSH
137188: CALL_OW 109
// continue ;
137192: GO 137107
// end ; end ;
137194: GO 137107
137196: POP
137197: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
137198: LD_VAR 0 4
137202: PUSH
137203: LD_VAR 0 7
137207: ARRAY
137208: PPUSH
137209: CALL_OW 257
137213: PUSH
137214: LD_INT 8
137216: EQUAL
137217: PUSH
137218: LD_VAR 0 4
137222: PUSH
137223: LD_VAR 0 7
137227: ARRAY
137228: PPUSH
137229: CALL_OW 264
137233: PUSH
137234: LD_INT 28
137236: PUSH
137237: LD_INT 45
137239: PUSH
137240: LD_INT 7
137242: PUSH
137243: LD_INT 47
137245: PUSH
137246: EMPTY
137247: LIST
137248: LIST
137249: LIST
137250: LIST
137251: IN
137252: OR
137253: IFFALSE 137509
// begin attacking := false ;
137255: LD_ADDR_VAR 0 29
137259: PUSH
137260: LD_INT 0
137262: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
137263: LD_VAR 0 14
137267: PUSH
137268: LD_INT 1
137270: ARRAY
137271: PPUSH
137272: CALL_OW 266
137276: PUSH
137277: LD_INT 32
137279: PUSH
137280: LD_INT 31
137282: PUSH
137283: LD_INT 33
137285: PUSH
137286: LD_INT 4
137288: PUSH
137289: LD_INT 5
137291: PUSH
137292: EMPTY
137293: LIST
137294: LIST
137295: LIST
137296: LIST
137297: LIST
137298: IN
137299: IFFALSE 137485
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
137301: LD_ADDR_VAR 0 9
137305: PUSH
137306: LD_VAR 0 14
137310: PUSH
137311: LD_INT 1
137313: ARRAY
137314: PPUSH
137315: CALL_OW 266
137319: PPUSH
137320: LD_VAR 0 14
137324: PUSH
137325: LD_INT 1
137327: ARRAY
137328: PPUSH
137329: CALL_OW 250
137333: PPUSH
137334: LD_VAR 0 14
137338: PUSH
137339: LD_INT 1
137341: ARRAY
137342: PPUSH
137343: CALL_OW 251
137347: PPUSH
137348: LD_VAR 0 14
137352: PUSH
137353: LD_INT 1
137355: ARRAY
137356: PPUSH
137357: CALL_OW 254
137361: PPUSH
137362: LD_VAR 0 14
137366: PUSH
137367: LD_INT 1
137369: ARRAY
137370: PPUSH
137371: CALL_OW 248
137375: PPUSH
137376: LD_INT 0
137378: PPUSH
137379: CALL 84601 0 6
137383: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
137384: LD_ADDR_VAR 0 8
137388: PUSH
137389: LD_VAR 0 4
137393: PUSH
137394: LD_VAR 0 7
137398: ARRAY
137399: PPUSH
137400: LD_VAR 0 9
137404: PPUSH
137405: CALL 103344 0 2
137409: ST_TO_ADDR
// if j then
137410: LD_VAR 0 8
137414: IFFALSE 137483
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
137416: LD_VAR 0 8
137420: PUSH
137421: LD_INT 1
137423: ARRAY
137424: PPUSH
137425: LD_VAR 0 8
137429: PUSH
137430: LD_INT 2
137432: ARRAY
137433: PPUSH
137434: CALL_OW 488
137438: IFFALSE 137483
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
137440: LD_VAR 0 4
137444: PUSH
137445: LD_VAR 0 7
137449: ARRAY
137450: PPUSH
137451: LD_VAR 0 8
137455: PUSH
137456: LD_INT 1
137458: ARRAY
137459: PPUSH
137460: LD_VAR 0 8
137464: PUSH
137465: LD_INT 2
137467: ARRAY
137468: PPUSH
137469: CALL_OW 116
// attacking := true ;
137473: LD_ADDR_VAR 0 29
137477: PUSH
137478: LD_INT 1
137480: ST_TO_ADDR
// continue ;
137481: GO 134856
// end ; end else
137483: GO 137509
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
137485: LD_VAR 0 4
137489: PUSH
137490: LD_VAR 0 7
137494: ARRAY
137495: PPUSH
137496: LD_VAR 0 14
137500: PUSH
137501: LD_INT 1
137503: ARRAY
137504: PPUSH
137505: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
137509: LD_VAR 0 4
137513: PUSH
137514: LD_VAR 0 7
137518: ARRAY
137519: PPUSH
137520: CALL_OW 265
137524: PUSH
137525: LD_INT 11
137527: EQUAL
137528: IFFALSE 137806
// begin k := 10 ;
137530: LD_ADDR_VAR 0 9
137534: PUSH
137535: LD_INT 10
137537: ST_TO_ADDR
// x := 0 ;
137538: LD_ADDR_VAR 0 10
137542: PUSH
137543: LD_INT 0
137545: ST_TO_ADDR
// if tmp < k then
137546: LD_VAR 0 14
137550: PUSH
137551: LD_VAR 0 9
137555: LESS
137556: IFFALSE 137568
// k := tmp ;
137558: LD_ADDR_VAR 0 9
137562: PUSH
137563: LD_VAR 0 14
137567: ST_TO_ADDR
// for j = k downto 1 do
137568: LD_ADDR_VAR 0 8
137572: PUSH
137573: DOUBLE
137574: LD_VAR 0 9
137578: INC
137579: ST_TO_ADDR
137580: LD_INT 1
137582: PUSH
137583: FOR_DOWNTO
137584: IFFALSE 137659
// begin if GetType ( tmp [ j ] ) = unit_human then
137586: LD_VAR 0 14
137590: PUSH
137591: LD_VAR 0 8
137595: ARRAY
137596: PPUSH
137597: CALL_OW 247
137601: PUSH
137602: LD_INT 1
137604: EQUAL
137605: IFFALSE 137657
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
137607: LD_VAR 0 4
137611: PUSH
137612: LD_VAR 0 7
137616: ARRAY
137617: PPUSH
137618: LD_VAR 0 14
137622: PUSH
137623: LD_VAR 0 8
137627: ARRAY
137628: PPUSH
137629: CALL 103598 0 2
// x := tmp [ j ] ;
137633: LD_ADDR_VAR 0 10
137637: PUSH
137638: LD_VAR 0 14
137642: PUSH
137643: LD_VAR 0 8
137647: ARRAY
137648: ST_TO_ADDR
// attacking := true ;
137649: LD_ADDR_VAR 0 29
137653: PUSH
137654: LD_INT 1
137656: ST_TO_ADDR
// end ; end ;
137657: GO 137583
137659: POP
137660: POP
// if not x then
137661: LD_VAR 0 10
137665: NOT
137666: IFFALSE 137806
// begin attacking := true ;
137668: LD_ADDR_VAR 0 29
137672: PUSH
137673: LD_INT 1
137675: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
137676: LD_VAR 0 4
137680: PUSH
137681: LD_VAR 0 7
137685: ARRAY
137686: PPUSH
137687: CALL_OW 250
137691: PPUSH
137692: LD_VAR 0 4
137696: PUSH
137697: LD_VAR 0 7
137701: ARRAY
137702: PPUSH
137703: CALL_OW 251
137707: PPUSH
137708: CALL_OW 546
137712: PUSH
137713: LD_INT 2
137715: ARRAY
137716: PUSH
137717: LD_VAR 0 14
137721: PUSH
137722: LD_INT 1
137724: ARRAY
137725: PPUSH
137726: CALL_OW 250
137730: PPUSH
137731: LD_VAR 0 14
137735: PUSH
137736: LD_INT 1
137738: ARRAY
137739: PPUSH
137740: CALL_OW 251
137744: PPUSH
137745: CALL_OW 546
137749: PUSH
137750: LD_INT 2
137752: ARRAY
137753: EQUAL
137754: IFFALSE 137782
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
137756: LD_VAR 0 4
137760: PUSH
137761: LD_VAR 0 7
137765: ARRAY
137766: PPUSH
137767: LD_VAR 0 14
137771: PUSH
137772: LD_INT 1
137774: ARRAY
137775: PPUSH
137776: CALL 103598 0 2
137780: GO 137806
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
137782: LD_VAR 0 4
137786: PUSH
137787: LD_VAR 0 7
137791: ARRAY
137792: PPUSH
137793: LD_VAR 0 14
137797: PUSH
137798: LD_INT 1
137800: ARRAY
137801: PPUSH
137802: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
137806: LD_VAR 0 4
137810: PUSH
137811: LD_VAR 0 7
137815: ARRAY
137816: PPUSH
137817: CALL_OW 264
137821: PUSH
137822: LD_INT 29
137824: EQUAL
137825: IFFALSE 138191
// begin if WantsToAttack ( group [ i ] ) in bombed then
137827: LD_VAR 0 4
137831: PUSH
137832: LD_VAR 0 7
137836: ARRAY
137837: PPUSH
137838: CALL_OW 319
137842: PUSH
137843: LD_VAR 0 28
137847: IN
137848: IFFALSE 137852
// continue ;
137850: GO 134856
// k := 8 ;
137852: LD_ADDR_VAR 0 9
137856: PUSH
137857: LD_INT 8
137859: ST_TO_ADDR
// x := 0 ;
137860: LD_ADDR_VAR 0 10
137864: PUSH
137865: LD_INT 0
137867: ST_TO_ADDR
// if tmp < k then
137868: LD_VAR 0 14
137872: PUSH
137873: LD_VAR 0 9
137877: LESS
137878: IFFALSE 137890
// k := tmp ;
137880: LD_ADDR_VAR 0 9
137884: PUSH
137885: LD_VAR 0 14
137889: ST_TO_ADDR
// for j = 1 to k do
137890: LD_ADDR_VAR 0 8
137894: PUSH
137895: DOUBLE
137896: LD_INT 1
137898: DEC
137899: ST_TO_ADDR
137900: LD_VAR 0 9
137904: PUSH
137905: FOR_TO
137906: IFFALSE 138038
// begin if GetType ( tmp [ j ] ) = unit_building then
137908: LD_VAR 0 14
137912: PUSH
137913: LD_VAR 0 8
137917: ARRAY
137918: PPUSH
137919: CALL_OW 247
137923: PUSH
137924: LD_INT 3
137926: EQUAL
137927: IFFALSE 138036
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
137929: LD_VAR 0 14
137933: PUSH
137934: LD_VAR 0 8
137938: ARRAY
137939: PUSH
137940: LD_VAR 0 28
137944: IN
137945: NOT
137946: PUSH
137947: LD_VAR 0 14
137951: PUSH
137952: LD_VAR 0 8
137956: ARRAY
137957: PPUSH
137958: CALL_OW 313
137962: AND
137963: IFFALSE 138036
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
137965: LD_VAR 0 4
137969: PUSH
137970: LD_VAR 0 7
137974: ARRAY
137975: PPUSH
137976: LD_VAR 0 14
137980: PUSH
137981: LD_VAR 0 8
137985: ARRAY
137986: PPUSH
137987: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
137991: LD_ADDR_VAR 0 28
137995: PUSH
137996: LD_VAR 0 28
138000: PPUSH
138001: LD_VAR 0 28
138005: PUSH
138006: LD_INT 1
138008: PLUS
138009: PPUSH
138010: LD_VAR 0 14
138014: PUSH
138015: LD_VAR 0 8
138019: ARRAY
138020: PPUSH
138021: CALL_OW 1
138025: ST_TO_ADDR
// attacking := true ;
138026: LD_ADDR_VAR 0 29
138030: PUSH
138031: LD_INT 1
138033: ST_TO_ADDR
// break ;
138034: GO 138038
// end ; end ;
138036: GO 137905
138038: POP
138039: POP
// if not attacking and f_attack_depot then
138040: LD_VAR 0 29
138044: NOT
138045: PUSH
138046: LD_VAR 0 25
138050: AND
138051: IFFALSE 138146
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
138053: LD_ADDR_VAR 0 13
138057: PUSH
138058: LD_VAR 0 14
138062: PPUSH
138063: LD_INT 2
138065: PUSH
138066: LD_INT 30
138068: PUSH
138069: LD_INT 0
138071: PUSH
138072: EMPTY
138073: LIST
138074: LIST
138075: PUSH
138076: LD_INT 30
138078: PUSH
138079: LD_INT 1
138081: PUSH
138082: EMPTY
138083: LIST
138084: LIST
138085: PUSH
138086: EMPTY
138087: LIST
138088: LIST
138089: LIST
138090: PPUSH
138091: CALL_OW 72
138095: ST_TO_ADDR
// if z then
138096: LD_VAR 0 13
138100: IFFALSE 138146
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
138102: LD_VAR 0 4
138106: PUSH
138107: LD_VAR 0 7
138111: ARRAY
138112: PPUSH
138113: LD_VAR 0 13
138117: PPUSH
138118: LD_VAR 0 4
138122: PUSH
138123: LD_VAR 0 7
138127: ARRAY
138128: PPUSH
138129: CALL_OW 74
138133: PPUSH
138134: CALL_OW 115
// attacking := true ;
138138: LD_ADDR_VAR 0 29
138142: PUSH
138143: LD_INT 1
138145: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
138146: LD_VAR 0 4
138150: PUSH
138151: LD_VAR 0 7
138155: ARRAY
138156: PPUSH
138157: CALL_OW 256
138161: PUSH
138162: LD_INT 500
138164: LESS
138165: IFFALSE 138191
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
138167: LD_VAR 0 4
138171: PUSH
138172: LD_VAR 0 7
138176: ARRAY
138177: PPUSH
138178: LD_VAR 0 14
138182: PUSH
138183: LD_INT 1
138185: ARRAY
138186: PPUSH
138187: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
138191: LD_VAR 0 4
138195: PUSH
138196: LD_VAR 0 7
138200: ARRAY
138201: PPUSH
138202: CALL_OW 264
138206: PUSH
138207: LD_INT 49
138209: EQUAL
138210: IFFALSE 138331
// begin if not HasTask ( group [ i ] ) then
138212: LD_VAR 0 4
138216: PUSH
138217: LD_VAR 0 7
138221: ARRAY
138222: PPUSH
138223: CALL_OW 314
138227: NOT
138228: IFFALSE 138331
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
138230: LD_ADDR_VAR 0 9
138234: PUSH
138235: LD_INT 81
138237: PUSH
138238: LD_VAR 0 4
138242: PUSH
138243: LD_VAR 0 7
138247: ARRAY
138248: PPUSH
138249: CALL_OW 255
138253: PUSH
138254: EMPTY
138255: LIST
138256: LIST
138257: PPUSH
138258: CALL_OW 69
138262: PPUSH
138263: LD_VAR 0 4
138267: PUSH
138268: LD_VAR 0 7
138272: ARRAY
138273: PPUSH
138274: CALL_OW 74
138278: ST_TO_ADDR
// if k then
138279: LD_VAR 0 9
138283: IFFALSE 138331
// if GetDistUnits ( group [ i ] , k ) > 10 then
138285: LD_VAR 0 4
138289: PUSH
138290: LD_VAR 0 7
138294: ARRAY
138295: PPUSH
138296: LD_VAR 0 9
138300: PPUSH
138301: CALL_OW 296
138305: PUSH
138306: LD_INT 10
138308: GREATER
138309: IFFALSE 138331
// ComMoveUnit ( group [ i ] , k ) ;
138311: LD_VAR 0 4
138315: PUSH
138316: LD_VAR 0 7
138320: ARRAY
138321: PPUSH
138322: LD_VAR 0 9
138326: PPUSH
138327: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
138331: LD_VAR 0 4
138335: PUSH
138336: LD_VAR 0 7
138340: ARRAY
138341: PPUSH
138342: CALL_OW 256
138346: PUSH
138347: LD_INT 250
138349: LESS
138350: PUSH
138351: LD_VAR 0 4
138355: PUSH
138356: LD_VAR 0 7
138360: ARRAY
138361: PUSH
138362: LD_INT 21
138364: PUSH
138365: LD_INT 2
138367: PUSH
138368: EMPTY
138369: LIST
138370: LIST
138371: PUSH
138372: LD_INT 23
138374: PUSH
138375: LD_INT 2
138377: PUSH
138378: EMPTY
138379: LIST
138380: LIST
138381: PUSH
138382: EMPTY
138383: LIST
138384: LIST
138385: PPUSH
138386: CALL_OW 69
138390: IN
138391: AND
138392: IFFALSE 138517
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
138394: LD_ADDR_VAR 0 9
138398: PUSH
138399: LD_OWVAR 3
138403: PUSH
138404: LD_VAR 0 4
138408: PUSH
138409: LD_VAR 0 7
138413: ARRAY
138414: DIFF
138415: PPUSH
138416: LD_VAR 0 4
138420: PUSH
138421: LD_VAR 0 7
138425: ARRAY
138426: PPUSH
138427: CALL_OW 74
138431: ST_TO_ADDR
// if not k then
138432: LD_VAR 0 9
138436: NOT
138437: IFFALSE 138441
// continue ;
138439: GO 134856
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
138441: LD_VAR 0 9
138445: PUSH
138446: LD_INT 81
138448: PUSH
138449: LD_VAR 0 4
138453: PUSH
138454: LD_VAR 0 7
138458: ARRAY
138459: PPUSH
138460: CALL_OW 255
138464: PUSH
138465: EMPTY
138466: LIST
138467: LIST
138468: PPUSH
138469: CALL_OW 69
138473: IN
138474: PUSH
138475: LD_VAR 0 9
138479: PPUSH
138480: LD_VAR 0 4
138484: PUSH
138485: LD_VAR 0 7
138489: ARRAY
138490: PPUSH
138491: CALL_OW 296
138495: PUSH
138496: LD_INT 5
138498: LESS
138499: AND
138500: IFFALSE 138517
// ComAutodestruct ( group [ i ] ) ;
138502: LD_VAR 0 4
138506: PUSH
138507: LD_VAR 0 7
138511: ARRAY
138512: PPUSH
138513: CALL 103496 0 1
// end ; if f_attack_depot then
138517: LD_VAR 0 25
138521: IFFALSE 138633
// begin k := 6 ;
138523: LD_ADDR_VAR 0 9
138527: PUSH
138528: LD_INT 6
138530: ST_TO_ADDR
// if tmp < k then
138531: LD_VAR 0 14
138535: PUSH
138536: LD_VAR 0 9
138540: LESS
138541: IFFALSE 138553
// k := tmp ;
138543: LD_ADDR_VAR 0 9
138547: PUSH
138548: LD_VAR 0 14
138552: ST_TO_ADDR
// for j = 1 to k do
138553: LD_ADDR_VAR 0 8
138557: PUSH
138558: DOUBLE
138559: LD_INT 1
138561: DEC
138562: ST_TO_ADDR
138563: LD_VAR 0 9
138567: PUSH
138568: FOR_TO
138569: IFFALSE 138631
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
138571: LD_VAR 0 8
138575: PPUSH
138576: CALL_OW 266
138580: PUSH
138581: LD_INT 0
138583: PUSH
138584: LD_INT 1
138586: PUSH
138587: EMPTY
138588: LIST
138589: LIST
138590: IN
138591: IFFALSE 138629
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
138593: LD_VAR 0 4
138597: PUSH
138598: LD_VAR 0 7
138602: ARRAY
138603: PPUSH
138604: LD_VAR 0 14
138608: PUSH
138609: LD_VAR 0 8
138613: ARRAY
138614: PPUSH
138615: CALL_OW 115
// attacking := true ;
138619: LD_ADDR_VAR 0 29
138623: PUSH
138624: LD_INT 1
138626: ST_TO_ADDR
// break ;
138627: GO 138631
// end ;
138629: GO 138568
138631: POP
138632: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
138633: LD_VAR 0 4
138637: PUSH
138638: LD_VAR 0 7
138642: ARRAY
138643: PPUSH
138644: CALL_OW 302
138648: PUSH
138649: LD_VAR 0 29
138653: NOT
138654: AND
138655: IFFALSE 138977
// begin if GetTag ( group [ i ] ) = 71 then
138657: LD_VAR 0 4
138661: PUSH
138662: LD_VAR 0 7
138666: ARRAY
138667: PPUSH
138668: CALL_OW 110
138672: PUSH
138673: LD_INT 71
138675: EQUAL
138676: IFFALSE 138717
// begin if HasTask ( group [ i ] ) then
138678: LD_VAR 0 4
138682: PUSH
138683: LD_VAR 0 7
138687: ARRAY
138688: PPUSH
138689: CALL_OW 314
138693: IFFALSE 138699
// continue else
138695: GO 134856
138697: GO 138717
// SetTag ( group [ i ] , 0 ) ;
138699: LD_VAR 0 4
138703: PUSH
138704: LD_VAR 0 7
138708: ARRAY
138709: PPUSH
138710: LD_INT 0
138712: PPUSH
138713: CALL_OW 109
// end ; k := 8 ;
138717: LD_ADDR_VAR 0 9
138721: PUSH
138722: LD_INT 8
138724: ST_TO_ADDR
// x := 0 ;
138725: LD_ADDR_VAR 0 10
138729: PUSH
138730: LD_INT 0
138732: ST_TO_ADDR
// if tmp < k then
138733: LD_VAR 0 14
138737: PUSH
138738: LD_VAR 0 9
138742: LESS
138743: IFFALSE 138755
// k := tmp ;
138745: LD_ADDR_VAR 0 9
138749: PUSH
138750: LD_VAR 0 14
138754: ST_TO_ADDR
// for j = 1 to k do
138755: LD_ADDR_VAR 0 8
138759: PUSH
138760: DOUBLE
138761: LD_INT 1
138763: DEC
138764: ST_TO_ADDR
138765: LD_VAR 0 9
138769: PUSH
138770: FOR_TO
138771: IFFALSE 138869
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
138773: LD_VAR 0 14
138777: PUSH
138778: LD_VAR 0 8
138782: ARRAY
138783: PPUSH
138784: CALL_OW 247
138788: PUSH
138789: LD_INT 1
138791: EQUAL
138792: PUSH
138793: LD_VAR 0 14
138797: PUSH
138798: LD_VAR 0 8
138802: ARRAY
138803: PPUSH
138804: CALL_OW 256
138808: PUSH
138809: LD_INT 250
138811: LESS
138812: PUSH
138813: LD_VAR 0 20
138817: AND
138818: PUSH
138819: LD_VAR 0 20
138823: NOT
138824: PUSH
138825: LD_VAR 0 14
138829: PUSH
138830: LD_VAR 0 8
138834: ARRAY
138835: PPUSH
138836: CALL_OW 256
138840: PUSH
138841: LD_INT 250
138843: GREATEREQUAL
138844: AND
138845: OR
138846: AND
138847: IFFALSE 138867
// begin x := tmp [ j ] ;
138849: LD_ADDR_VAR 0 10
138853: PUSH
138854: LD_VAR 0 14
138858: PUSH
138859: LD_VAR 0 8
138863: ARRAY
138864: ST_TO_ADDR
// break ;
138865: GO 138869
// end ;
138867: GO 138770
138869: POP
138870: POP
// if x then
138871: LD_VAR 0 10
138875: IFFALSE 138899
// ComAttackUnit ( group [ i ] , x ) else
138877: LD_VAR 0 4
138881: PUSH
138882: LD_VAR 0 7
138886: ARRAY
138887: PPUSH
138888: LD_VAR 0 10
138892: PPUSH
138893: CALL_OW 115
138897: GO 138923
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
138899: LD_VAR 0 4
138903: PUSH
138904: LD_VAR 0 7
138908: ARRAY
138909: PPUSH
138910: LD_VAR 0 14
138914: PUSH
138915: LD_INT 1
138917: ARRAY
138918: PPUSH
138919: CALL_OW 115
// if not HasTask ( group [ i ] ) then
138923: LD_VAR 0 4
138927: PUSH
138928: LD_VAR 0 7
138932: ARRAY
138933: PPUSH
138934: CALL_OW 314
138938: NOT
138939: IFFALSE 138977
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
138941: LD_VAR 0 4
138945: PUSH
138946: LD_VAR 0 7
138950: ARRAY
138951: PPUSH
138952: LD_VAR 0 14
138956: PPUSH
138957: LD_VAR 0 4
138961: PUSH
138962: LD_VAR 0 7
138966: ARRAY
138967: PPUSH
138968: CALL_OW 74
138972: PPUSH
138973: CALL_OW 115
// end ; end ; end ;
138977: GO 134856
138979: POP
138980: POP
// wait ( 0 0$2 ) ;
138981: LD_INT 70
138983: PPUSH
138984: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
138988: LD_VAR 0 4
138992: NOT
138993: PUSH
138994: LD_VAR 0 4
138998: PUSH
138999: EMPTY
139000: EQUAL
139001: OR
139002: PUSH
139003: LD_INT 81
139005: PUSH
139006: LD_VAR 0 35
139010: PUSH
139011: EMPTY
139012: LIST
139013: LIST
139014: PPUSH
139015: CALL_OW 69
139019: NOT
139020: OR
139021: IFFALSE 134841
// end ;
139023: LD_VAR 0 2
139027: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
139028: LD_INT 0
139030: PPUSH
139031: PPUSH
139032: PPUSH
139033: PPUSH
139034: PPUSH
139035: PPUSH
// if not base or not mc_bases [ base ] or not solds then
139036: LD_VAR 0 1
139040: NOT
139041: PUSH
139042: LD_EXP 102
139046: PUSH
139047: LD_VAR 0 1
139051: ARRAY
139052: NOT
139053: OR
139054: PUSH
139055: LD_VAR 0 2
139059: NOT
139060: OR
139061: IFFALSE 139065
// exit ;
139063: GO 139619
// side := mc_sides [ base ] ;
139065: LD_ADDR_VAR 0 6
139069: PUSH
139070: LD_EXP 128
139074: PUSH
139075: LD_VAR 0 1
139079: ARRAY
139080: ST_TO_ADDR
// if not side then
139081: LD_VAR 0 6
139085: NOT
139086: IFFALSE 139090
// exit ;
139088: GO 139619
// for i in solds do
139090: LD_ADDR_VAR 0 7
139094: PUSH
139095: LD_VAR 0 2
139099: PUSH
139100: FOR_IN
139101: IFFALSE 139162
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
139103: LD_VAR 0 7
139107: PPUSH
139108: CALL_OW 310
139112: PPUSH
139113: CALL_OW 266
139117: PUSH
139118: LD_INT 32
139120: PUSH
139121: LD_INT 31
139123: PUSH
139124: EMPTY
139125: LIST
139126: LIST
139127: IN
139128: IFFALSE 139148
// solds := solds diff i else
139130: LD_ADDR_VAR 0 2
139134: PUSH
139135: LD_VAR 0 2
139139: PUSH
139140: LD_VAR 0 7
139144: DIFF
139145: ST_TO_ADDR
139146: GO 139160
// SetTag ( i , 18 ) ;
139148: LD_VAR 0 7
139152: PPUSH
139153: LD_INT 18
139155: PPUSH
139156: CALL_OW 109
139160: GO 139100
139162: POP
139163: POP
// if not solds then
139164: LD_VAR 0 2
139168: NOT
139169: IFFALSE 139173
// exit ;
139171: GO 139619
// repeat wait ( 0 0$2 ) ;
139173: LD_INT 70
139175: PPUSH
139176: CALL_OW 67
// enemy := mc_scan [ base ] ;
139180: LD_ADDR_VAR 0 4
139184: PUSH
139185: LD_EXP 125
139189: PUSH
139190: LD_VAR 0 1
139194: ARRAY
139195: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
139196: LD_EXP 102
139200: PUSH
139201: LD_VAR 0 1
139205: ARRAY
139206: NOT
139207: PUSH
139208: LD_EXP 102
139212: PUSH
139213: LD_VAR 0 1
139217: ARRAY
139218: PUSH
139219: EMPTY
139220: EQUAL
139221: OR
139222: IFFALSE 139259
// begin for i in solds do
139224: LD_ADDR_VAR 0 7
139228: PUSH
139229: LD_VAR 0 2
139233: PUSH
139234: FOR_IN
139235: IFFALSE 139248
// ComStop ( i ) ;
139237: LD_VAR 0 7
139241: PPUSH
139242: CALL_OW 141
139246: GO 139234
139248: POP
139249: POP
// solds := [ ] ;
139250: LD_ADDR_VAR 0 2
139254: PUSH
139255: EMPTY
139256: ST_TO_ADDR
// exit ;
139257: GO 139619
// end ; for i in solds do
139259: LD_ADDR_VAR 0 7
139263: PUSH
139264: LD_VAR 0 2
139268: PUSH
139269: FOR_IN
139270: IFFALSE 139591
// begin if IsInUnit ( i ) then
139272: LD_VAR 0 7
139276: PPUSH
139277: CALL_OW 310
139281: IFFALSE 139292
// ComExitBuilding ( i ) ;
139283: LD_VAR 0 7
139287: PPUSH
139288: CALL_OW 122
// if GetLives ( i ) > 500 then
139292: LD_VAR 0 7
139296: PPUSH
139297: CALL_OW 256
139301: PUSH
139302: LD_INT 500
139304: GREATER
139305: IFFALSE 139358
// begin e := NearestUnitToUnit ( enemy , i ) ;
139307: LD_ADDR_VAR 0 5
139311: PUSH
139312: LD_VAR 0 4
139316: PPUSH
139317: LD_VAR 0 7
139321: PPUSH
139322: CALL_OW 74
139326: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
139327: LD_VAR 0 7
139331: PPUSH
139332: LD_VAR 0 5
139336: PPUSH
139337: CALL_OW 250
139341: PPUSH
139342: LD_VAR 0 5
139346: PPUSH
139347: CALL_OW 251
139351: PPUSH
139352: CALL_OW 114
// end else
139356: GO 139589
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
139358: LD_VAR 0 7
139362: PPUSH
139363: LD_EXP 102
139367: PUSH
139368: LD_VAR 0 1
139372: ARRAY
139373: PPUSH
139374: LD_INT 2
139376: PUSH
139377: LD_INT 30
139379: PUSH
139380: LD_INT 0
139382: PUSH
139383: EMPTY
139384: LIST
139385: LIST
139386: PUSH
139387: LD_INT 30
139389: PUSH
139390: LD_INT 1
139392: PUSH
139393: EMPTY
139394: LIST
139395: LIST
139396: PUSH
139397: LD_INT 30
139399: PUSH
139400: LD_INT 6
139402: PUSH
139403: EMPTY
139404: LIST
139405: LIST
139406: PUSH
139407: EMPTY
139408: LIST
139409: LIST
139410: LIST
139411: LIST
139412: PPUSH
139413: CALL_OW 72
139417: PPUSH
139418: LD_VAR 0 7
139422: PPUSH
139423: CALL_OW 74
139427: PPUSH
139428: CALL_OW 296
139432: PUSH
139433: LD_INT 10
139435: GREATER
139436: IFFALSE 139589
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
139438: LD_ADDR_VAR 0 8
139442: PUSH
139443: LD_EXP 102
139447: PUSH
139448: LD_VAR 0 1
139452: ARRAY
139453: PPUSH
139454: LD_INT 2
139456: PUSH
139457: LD_INT 30
139459: PUSH
139460: LD_INT 0
139462: PUSH
139463: EMPTY
139464: LIST
139465: LIST
139466: PUSH
139467: LD_INT 30
139469: PUSH
139470: LD_INT 1
139472: PUSH
139473: EMPTY
139474: LIST
139475: LIST
139476: PUSH
139477: LD_INT 30
139479: PUSH
139480: LD_INT 6
139482: PUSH
139483: EMPTY
139484: LIST
139485: LIST
139486: PUSH
139487: EMPTY
139488: LIST
139489: LIST
139490: LIST
139491: LIST
139492: PPUSH
139493: CALL_OW 72
139497: PPUSH
139498: LD_VAR 0 7
139502: PPUSH
139503: CALL_OW 74
139507: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
139508: LD_VAR 0 7
139512: PPUSH
139513: LD_VAR 0 8
139517: PPUSH
139518: CALL_OW 250
139522: PPUSH
139523: LD_INT 3
139525: PPUSH
139526: LD_INT 5
139528: PPUSH
139529: CALL_OW 272
139533: PPUSH
139534: LD_VAR 0 8
139538: PPUSH
139539: CALL_OW 251
139543: PPUSH
139544: LD_INT 3
139546: PPUSH
139547: LD_INT 5
139549: PPUSH
139550: CALL_OW 273
139554: PPUSH
139555: CALL_OW 111
// SetTag ( i , 0 ) ;
139559: LD_VAR 0 7
139563: PPUSH
139564: LD_INT 0
139566: PPUSH
139567: CALL_OW 109
// solds := solds diff i ;
139571: LD_ADDR_VAR 0 2
139575: PUSH
139576: LD_VAR 0 2
139580: PUSH
139581: LD_VAR 0 7
139585: DIFF
139586: ST_TO_ADDR
// continue ;
139587: GO 139269
// end ; end ;
139589: GO 139269
139591: POP
139592: POP
// until not solds or not enemy ;
139593: LD_VAR 0 2
139597: NOT
139598: PUSH
139599: LD_VAR 0 4
139603: NOT
139604: OR
139605: IFFALSE 139173
// MC_Reset ( base , 18 ) ;
139607: LD_VAR 0 1
139611: PPUSH
139612: LD_INT 18
139614: PPUSH
139615: CALL 43733 0 2
// end ;
139619: LD_VAR 0 3
139623: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
139624: LD_INT 0
139626: PPUSH
139627: PPUSH
139628: PPUSH
139629: PPUSH
139630: PPUSH
139631: PPUSH
139632: PPUSH
139633: PPUSH
139634: PPUSH
139635: PPUSH
139636: PPUSH
139637: PPUSH
139638: PPUSH
139639: PPUSH
139640: PPUSH
139641: PPUSH
139642: PPUSH
139643: PPUSH
139644: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
139645: LD_ADDR_VAR 0 12
139649: PUSH
139650: LD_EXP 102
139654: PUSH
139655: LD_VAR 0 1
139659: ARRAY
139660: PPUSH
139661: LD_INT 25
139663: PUSH
139664: LD_INT 3
139666: PUSH
139667: EMPTY
139668: LIST
139669: LIST
139670: PPUSH
139671: CALL_OW 72
139675: ST_TO_ADDR
// if mc_remote_driver [ base ] then
139676: LD_EXP 142
139680: PUSH
139681: LD_VAR 0 1
139685: ARRAY
139686: IFFALSE 139710
// mechs := mechs diff mc_remote_driver [ base ] ;
139688: LD_ADDR_VAR 0 12
139692: PUSH
139693: LD_VAR 0 12
139697: PUSH
139698: LD_EXP 142
139702: PUSH
139703: LD_VAR 0 1
139707: ARRAY
139708: DIFF
139709: ST_TO_ADDR
// for i in mechs do
139710: LD_ADDR_VAR 0 4
139714: PUSH
139715: LD_VAR 0 12
139719: PUSH
139720: FOR_IN
139721: IFFALSE 139756
// if GetTag ( i ) > 0 then
139723: LD_VAR 0 4
139727: PPUSH
139728: CALL_OW 110
139732: PUSH
139733: LD_INT 0
139735: GREATER
139736: IFFALSE 139754
// mechs := mechs diff i ;
139738: LD_ADDR_VAR 0 12
139742: PUSH
139743: LD_VAR 0 12
139747: PUSH
139748: LD_VAR 0 4
139752: DIFF
139753: ST_TO_ADDR
139754: GO 139720
139756: POP
139757: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
139758: LD_ADDR_VAR 0 8
139762: PUSH
139763: LD_EXP 102
139767: PUSH
139768: LD_VAR 0 1
139772: ARRAY
139773: PPUSH
139774: LD_INT 2
139776: PUSH
139777: LD_INT 25
139779: PUSH
139780: LD_INT 1
139782: PUSH
139783: EMPTY
139784: LIST
139785: LIST
139786: PUSH
139787: LD_INT 25
139789: PUSH
139790: LD_INT 5
139792: PUSH
139793: EMPTY
139794: LIST
139795: LIST
139796: PUSH
139797: LD_INT 25
139799: PUSH
139800: LD_INT 8
139802: PUSH
139803: EMPTY
139804: LIST
139805: LIST
139806: PUSH
139807: LD_INT 25
139809: PUSH
139810: LD_INT 9
139812: PUSH
139813: EMPTY
139814: LIST
139815: LIST
139816: PUSH
139817: EMPTY
139818: LIST
139819: LIST
139820: LIST
139821: LIST
139822: LIST
139823: PPUSH
139824: CALL_OW 72
139828: ST_TO_ADDR
// if not defenders and not solds then
139829: LD_VAR 0 2
139833: NOT
139834: PUSH
139835: LD_VAR 0 8
139839: NOT
139840: AND
139841: IFFALSE 139845
// exit ;
139843: GO 141615
// depot_under_attack := false ;
139845: LD_ADDR_VAR 0 16
139849: PUSH
139850: LD_INT 0
139852: ST_TO_ADDR
// sold_defenders := [ ] ;
139853: LD_ADDR_VAR 0 17
139857: PUSH
139858: EMPTY
139859: ST_TO_ADDR
// if mechs then
139860: LD_VAR 0 12
139864: IFFALSE 140017
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
139866: LD_ADDR_VAR 0 4
139870: PUSH
139871: LD_VAR 0 2
139875: PPUSH
139876: LD_INT 21
139878: PUSH
139879: LD_INT 2
139881: PUSH
139882: EMPTY
139883: LIST
139884: LIST
139885: PPUSH
139886: CALL_OW 72
139890: PUSH
139891: FOR_IN
139892: IFFALSE 140015
// begin if GetTag ( i ) <> 20 then
139894: LD_VAR 0 4
139898: PPUSH
139899: CALL_OW 110
139903: PUSH
139904: LD_INT 20
139906: NONEQUAL
139907: IFFALSE 139921
// SetTag ( i , 20 ) ;
139909: LD_VAR 0 4
139913: PPUSH
139914: LD_INT 20
139916: PPUSH
139917: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
139921: LD_VAR 0 4
139925: PPUSH
139926: CALL_OW 263
139930: PUSH
139931: LD_INT 1
139933: EQUAL
139934: PUSH
139935: LD_VAR 0 4
139939: PPUSH
139940: CALL_OW 311
139944: NOT
139945: AND
139946: IFFALSE 140013
// begin un := mechs [ 1 ] ;
139948: LD_ADDR_VAR 0 10
139952: PUSH
139953: LD_VAR 0 12
139957: PUSH
139958: LD_INT 1
139960: ARRAY
139961: ST_TO_ADDR
// ComExit ( un ) ;
139962: LD_VAR 0 10
139966: PPUSH
139967: CALL 108402 0 1
// AddComEnterUnit ( un , i ) ;
139971: LD_VAR 0 10
139975: PPUSH
139976: LD_VAR 0 4
139980: PPUSH
139981: CALL_OW 180
// SetTag ( un , 19 ) ;
139985: LD_VAR 0 10
139989: PPUSH
139990: LD_INT 19
139992: PPUSH
139993: CALL_OW 109
// mechs := mechs diff un ;
139997: LD_ADDR_VAR 0 12
140001: PUSH
140002: LD_VAR 0 12
140006: PUSH
140007: LD_VAR 0 10
140011: DIFF
140012: ST_TO_ADDR
// end ; end ;
140013: GO 139891
140015: POP
140016: POP
// if solds then
140017: LD_VAR 0 8
140021: IFFALSE 140080
// for i in solds do
140023: LD_ADDR_VAR 0 4
140027: PUSH
140028: LD_VAR 0 8
140032: PUSH
140033: FOR_IN
140034: IFFALSE 140078
// if not GetTag ( i ) then
140036: LD_VAR 0 4
140040: PPUSH
140041: CALL_OW 110
140045: NOT
140046: IFFALSE 140076
// begin defenders := defenders union i ;
140048: LD_ADDR_VAR 0 2
140052: PUSH
140053: LD_VAR 0 2
140057: PUSH
140058: LD_VAR 0 4
140062: UNION
140063: ST_TO_ADDR
// SetTag ( i , 18 ) ;
140064: LD_VAR 0 4
140068: PPUSH
140069: LD_INT 18
140071: PPUSH
140072: CALL_OW 109
// end ;
140076: GO 140033
140078: POP
140079: POP
// repeat wait ( 0 0$2 ) ;
140080: LD_INT 70
140082: PPUSH
140083: CALL_OW 67
// enemy := mc_scan [ base ] ;
140087: LD_ADDR_VAR 0 21
140091: PUSH
140092: LD_EXP 125
140096: PUSH
140097: LD_VAR 0 1
140101: ARRAY
140102: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
140103: LD_EXP 102
140107: PUSH
140108: LD_VAR 0 1
140112: ARRAY
140113: NOT
140114: PUSH
140115: LD_EXP 102
140119: PUSH
140120: LD_VAR 0 1
140124: ARRAY
140125: PUSH
140126: EMPTY
140127: EQUAL
140128: OR
140129: IFFALSE 140166
// begin for i in defenders do
140131: LD_ADDR_VAR 0 4
140135: PUSH
140136: LD_VAR 0 2
140140: PUSH
140141: FOR_IN
140142: IFFALSE 140155
// ComStop ( i ) ;
140144: LD_VAR 0 4
140148: PPUSH
140149: CALL_OW 141
140153: GO 140141
140155: POP
140156: POP
// defenders := [ ] ;
140157: LD_ADDR_VAR 0 2
140161: PUSH
140162: EMPTY
140163: ST_TO_ADDR
// exit ;
140164: GO 141615
// end ; for i in defenders do
140166: LD_ADDR_VAR 0 4
140170: PUSH
140171: LD_VAR 0 2
140175: PUSH
140176: FOR_IN
140177: IFFALSE 141075
// begin e := NearestUnitToUnit ( enemy , i ) ;
140179: LD_ADDR_VAR 0 13
140183: PUSH
140184: LD_VAR 0 21
140188: PPUSH
140189: LD_VAR 0 4
140193: PPUSH
140194: CALL_OW 74
140198: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
140199: LD_ADDR_VAR 0 7
140203: PUSH
140204: LD_EXP 102
140208: PUSH
140209: LD_VAR 0 1
140213: ARRAY
140214: PPUSH
140215: LD_INT 2
140217: PUSH
140218: LD_INT 30
140220: PUSH
140221: LD_INT 0
140223: PUSH
140224: EMPTY
140225: LIST
140226: LIST
140227: PUSH
140228: LD_INT 30
140230: PUSH
140231: LD_INT 1
140233: PUSH
140234: EMPTY
140235: LIST
140236: LIST
140237: PUSH
140238: EMPTY
140239: LIST
140240: LIST
140241: LIST
140242: PPUSH
140243: CALL_OW 72
140247: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
140248: LD_ADDR_VAR 0 16
140252: PUSH
140253: LD_VAR 0 7
140257: NOT
140258: PUSH
140259: LD_VAR 0 7
140263: PPUSH
140264: LD_INT 3
140266: PUSH
140267: LD_INT 24
140269: PUSH
140270: LD_INT 600
140272: PUSH
140273: EMPTY
140274: LIST
140275: LIST
140276: PUSH
140277: EMPTY
140278: LIST
140279: LIST
140280: PPUSH
140281: CALL_OW 72
140285: OR
140286: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
140287: LD_VAR 0 4
140291: PPUSH
140292: CALL_OW 247
140296: PUSH
140297: LD_INT 2
140299: DOUBLE
140300: EQUAL
140301: IFTRUE 140305
140303: GO 140701
140305: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
140306: LD_VAR 0 4
140310: PPUSH
140311: CALL_OW 256
140315: PUSH
140316: LD_INT 1000
140318: EQUAL
140319: PUSH
140320: LD_VAR 0 4
140324: PPUSH
140325: LD_VAR 0 13
140329: PPUSH
140330: CALL_OW 296
140334: PUSH
140335: LD_INT 40
140337: LESS
140338: PUSH
140339: LD_VAR 0 13
140343: PPUSH
140344: LD_EXP 127
140348: PUSH
140349: LD_VAR 0 1
140353: ARRAY
140354: PPUSH
140355: CALL_OW 308
140359: OR
140360: AND
140361: IFFALSE 140483
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
140363: LD_VAR 0 4
140367: PPUSH
140368: CALL_OW 262
140372: PUSH
140373: LD_INT 1
140375: EQUAL
140376: PUSH
140377: LD_VAR 0 4
140381: PPUSH
140382: CALL_OW 261
140386: PUSH
140387: LD_INT 30
140389: LESS
140390: AND
140391: PUSH
140392: LD_VAR 0 7
140396: AND
140397: IFFALSE 140467
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
140399: LD_VAR 0 4
140403: PPUSH
140404: LD_VAR 0 7
140408: PPUSH
140409: LD_VAR 0 4
140413: PPUSH
140414: CALL_OW 74
140418: PPUSH
140419: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
140423: LD_VAR 0 4
140427: PPUSH
140428: LD_VAR 0 7
140432: PPUSH
140433: LD_VAR 0 4
140437: PPUSH
140438: CALL_OW 74
140442: PPUSH
140443: CALL_OW 296
140447: PUSH
140448: LD_INT 6
140450: LESS
140451: IFFALSE 140465
// SetFuel ( i , 100 ) ;
140453: LD_VAR 0 4
140457: PPUSH
140458: LD_INT 100
140460: PPUSH
140461: CALL_OW 240
// end else
140465: GO 140481
// ComAttackUnit ( i , e ) ;
140467: LD_VAR 0 4
140471: PPUSH
140472: LD_VAR 0 13
140476: PPUSH
140477: CALL_OW 115
// end else
140481: GO 140584
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
140483: LD_VAR 0 13
140487: PPUSH
140488: LD_EXP 127
140492: PUSH
140493: LD_VAR 0 1
140497: ARRAY
140498: PPUSH
140499: CALL_OW 308
140503: NOT
140504: PUSH
140505: LD_VAR 0 4
140509: PPUSH
140510: LD_VAR 0 13
140514: PPUSH
140515: CALL_OW 296
140519: PUSH
140520: LD_INT 40
140522: GREATEREQUAL
140523: AND
140524: PUSH
140525: LD_VAR 0 4
140529: PPUSH
140530: CALL_OW 256
140534: PUSH
140535: LD_INT 650
140537: LESSEQUAL
140538: OR
140539: PUSH
140540: LD_VAR 0 4
140544: PPUSH
140545: LD_EXP 126
140549: PUSH
140550: LD_VAR 0 1
140554: ARRAY
140555: PPUSH
140556: CALL_OW 308
140560: NOT
140561: AND
140562: IFFALSE 140584
// ComMoveToArea ( i , mc_parking [ base ] ) ;
140564: LD_VAR 0 4
140568: PPUSH
140569: LD_EXP 126
140573: PUSH
140574: LD_VAR 0 1
140578: ARRAY
140579: PPUSH
140580: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
140584: LD_VAR 0 4
140588: PPUSH
140589: CALL_OW 256
140593: PUSH
140594: LD_INT 1000
140596: LESS
140597: PUSH
140598: LD_VAR 0 4
140602: PPUSH
140603: CALL_OW 263
140607: PUSH
140608: LD_INT 1
140610: EQUAL
140611: AND
140612: PUSH
140613: LD_VAR 0 4
140617: PPUSH
140618: CALL_OW 311
140622: AND
140623: PUSH
140624: LD_VAR 0 4
140628: PPUSH
140629: LD_EXP 126
140633: PUSH
140634: LD_VAR 0 1
140638: ARRAY
140639: PPUSH
140640: CALL_OW 308
140644: AND
140645: IFFALSE 140699
// begin mech := IsDrivenBy ( i ) ;
140647: LD_ADDR_VAR 0 9
140651: PUSH
140652: LD_VAR 0 4
140656: PPUSH
140657: CALL_OW 311
140661: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
140662: LD_VAR 0 9
140666: PPUSH
140667: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
140671: LD_VAR 0 9
140675: PPUSH
140676: LD_VAR 0 4
140680: PPUSH
140681: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
140685: LD_VAR 0 9
140689: PPUSH
140690: LD_VAR 0 4
140694: PPUSH
140695: CALL_OW 180
// end ; end ; unit_human :
140699: GO 141046
140701: LD_INT 1
140703: DOUBLE
140704: EQUAL
140705: IFTRUE 140709
140707: GO 141045
140709: POP
// begin b := IsInUnit ( i ) ;
140710: LD_ADDR_VAR 0 18
140714: PUSH
140715: LD_VAR 0 4
140719: PPUSH
140720: CALL_OW 310
140724: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
140725: LD_ADDR_VAR 0 19
140729: PUSH
140730: LD_VAR 0 18
140734: NOT
140735: PUSH
140736: LD_VAR 0 18
140740: PPUSH
140741: CALL_OW 266
140745: PUSH
140746: LD_INT 32
140748: PUSH
140749: LD_INT 31
140751: PUSH
140752: EMPTY
140753: LIST
140754: LIST
140755: IN
140756: OR
140757: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
140758: LD_VAR 0 18
140762: PPUSH
140763: CALL_OW 266
140767: PUSH
140768: LD_INT 5
140770: EQUAL
140771: PUSH
140772: LD_VAR 0 4
140776: PPUSH
140777: CALL_OW 257
140781: PUSH
140782: LD_INT 1
140784: PUSH
140785: LD_INT 2
140787: PUSH
140788: LD_INT 3
140790: PUSH
140791: LD_INT 4
140793: PUSH
140794: EMPTY
140795: LIST
140796: LIST
140797: LIST
140798: LIST
140799: IN
140800: AND
140801: IFFALSE 140838
// begin class := AllowSpecClass ( i ) ;
140803: LD_ADDR_VAR 0 20
140807: PUSH
140808: LD_VAR 0 4
140812: PPUSH
140813: CALL 72079 0 1
140817: ST_TO_ADDR
// if class then
140818: LD_VAR 0 20
140822: IFFALSE 140838
// ComChangeProfession ( i , class ) ;
140824: LD_VAR 0 4
140828: PPUSH
140829: LD_VAR 0 20
140833: PPUSH
140834: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
140838: LD_VAR 0 16
140842: PUSH
140843: LD_VAR 0 2
140847: PPUSH
140848: LD_INT 21
140850: PUSH
140851: LD_INT 2
140853: PUSH
140854: EMPTY
140855: LIST
140856: LIST
140857: PPUSH
140858: CALL_OW 72
140862: PUSH
140863: LD_INT 1
140865: LESSEQUAL
140866: OR
140867: PUSH
140868: LD_VAR 0 19
140872: AND
140873: PUSH
140874: LD_VAR 0 4
140878: PUSH
140879: LD_VAR 0 17
140883: IN
140884: NOT
140885: AND
140886: IFFALSE 140979
// begin if b then
140888: LD_VAR 0 18
140892: IFFALSE 140941
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
140894: LD_VAR 0 18
140898: PPUSH
140899: LD_VAR 0 21
140903: PPUSH
140904: LD_VAR 0 18
140908: PPUSH
140909: CALL_OW 74
140913: PPUSH
140914: CALL_OW 296
140918: PUSH
140919: LD_INT 10
140921: LESS
140922: PUSH
140923: LD_VAR 0 18
140927: PPUSH
140928: CALL_OW 461
140932: PUSH
140933: LD_INT 7
140935: NONEQUAL
140936: AND
140937: IFFALSE 140941
// continue ;
140939: GO 140176
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
140941: LD_ADDR_VAR 0 17
140945: PUSH
140946: LD_VAR 0 17
140950: PPUSH
140951: LD_VAR 0 17
140955: PUSH
140956: LD_INT 1
140958: PLUS
140959: PPUSH
140960: LD_VAR 0 4
140964: PPUSH
140965: CALL_OW 1
140969: ST_TO_ADDR
// ComExitBuilding ( i ) ;
140970: LD_VAR 0 4
140974: PPUSH
140975: CALL_OW 122
// end ; if sold_defenders then
140979: LD_VAR 0 17
140983: IFFALSE 141043
// if i in sold_defenders then
140985: LD_VAR 0 4
140989: PUSH
140990: LD_VAR 0 17
140994: IN
140995: IFFALSE 141043
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
140997: LD_VAR 0 4
141001: PPUSH
141002: CALL_OW 314
141006: NOT
141007: PUSH
141008: LD_VAR 0 4
141012: PPUSH
141013: LD_VAR 0 13
141017: PPUSH
141018: CALL_OW 296
141022: PUSH
141023: LD_INT 30
141025: LESS
141026: AND
141027: IFFALSE 141043
// ComAttackUnit ( i , e ) ;
141029: LD_VAR 0 4
141033: PPUSH
141034: LD_VAR 0 13
141038: PPUSH
141039: CALL_OW 115
// end ; end ; end ;
141043: GO 141046
141045: POP
// if IsDead ( i ) then
141046: LD_VAR 0 4
141050: PPUSH
141051: CALL_OW 301
141055: IFFALSE 141073
// defenders := defenders diff i ;
141057: LD_ADDR_VAR 0 2
141061: PUSH
141062: LD_VAR 0 2
141066: PUSH
141067: LD_VAR 0 4
141071: DIFF
141072: ST_TO_ADDR
// end ;
141073: GO 140176
141075: POP
141076: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
141077: LD_VAR 0 21
141081: NOT
141082: PUSH
141083: LD_VAR 0 2
141087: NOT
141088: OR
141089: PUSH
141090: LD_EXP 102
141094: PUSH
141095: LD_VAR 0 1
141099: ARRAY
141100: NOT
141101: OR
141102: IFFALSE 140080
// MC_Reset ( base , 18 ) ;
141104: LD_VAR 0 1
141108: PPUSH
141109: LD_INT 18
141111: PPUSH
141112: CALL 43733 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
141116: LD_ADDR_VAR 0 2
141120: PUSH
141121: LD_VAR 0 2
141125: PUSH
141126: LD_VAR 0 2
141130: PPUSH
141131: LD_INT 2
141133: PUSH
141134: LD_INT 25
141136: PUSH
141137: LD_INT 1
141139: PUSH
141140: EMPTY
141141: LIST
141142: LIST
141143: PUSH
141144: LD_INT 25
141146: PUSH
141147: LD_INT 5
141149: PUSH
141150: EMPTY
141151: LIST
141152: LIST
141153: PUSH
141154: LD_INT 25
141156: PUSH
141157: LD_INT 8
141159: PUSH
141160: EMPTY
141161: LIST
141162: LIST
141163: PUSH
141164: LD_INT 25
141166: PUSH
141167: LD_INT 9
141169: PUSH
141170: EMPTY
141171: LIST
141172: LIST
141173: PUSH
141174: EMPTY
141175: LIST
141176: LIST
141177: LIST
141178: LIST
141179: LIST
141180: PPUSH
141181: CALL_OW 72
141185: DIFF
141186: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
141187: LD_VAR 0 21
141191: NOT
141192: PUSH
141193: LD_VAR 0 2
141197: PPUSH
141198: LD_INT 21
141200: PUSH
141201: LD_INT 2
141203: PUSH
141204: EMPTY
141205: LIST
141206: LIST
141207: PPUSH
141208: CALL_OW 72
141212: AND
141213: IFFALSE 141551
// begin tmp := FilterByTag ( defenders , 19 ) ;
141215: LD_ADDR_VAR 0 11
141219: PUSH
141220: LD_VAR 0 2
141224: PPUSH
141225: LD_INT 19
141227: PPUSH
141228: CALL 105573 0 2
141232: ST_TO_ADDR
// if tmp then
141233: LD_VAR 0 11
141237: IFFALSE 141307
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
141239: LD_ADDR_VAR 0 11
141243: PUSH
141244: LD_VAR 0 11
141248: PPUSH
141249: LD_INT 25
141251: PUSH
141252: LD_INT 3
141254: PUSH
141255: EMPTY
141256: LIST
141257: LIST
141258: PPUSH
141259: CALL_OW 72
141263: ST_TO_ADDR
// if tmp then
141264: LD_VAR 0 11
141268: IFFALSE 141307
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
141270: LD_ADDR_EXP 114
141274: PUSH
141275: LD_EXP 114
141279: PPUSH
141280: LD_VAR 0 1
141284: PPUSH
141285: LD_EXP 114
141289: PUSH
141290: LD_VAR 0 1
141294: ARRAY
141295: PUSH
141296: LD_VAR 0 11
141300: UNION
141301: PPUSH
141302: CALL_OW 1
141306: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
141307: LD_VAR 0 1
141311: PPUSH
141312: LD_INT 19
141314: PPUSH
141315: CALL 43733 0 2
// repeat wait ( 0 0$1 ) ;
141319: LD_INT 35
141321: PPUSH
141322: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
141326: LD_EXP 102
141330: PUSH
141331: LD_VAR 0 1
141335: ARRAY
141336: NOT
141337: PUSH
141338: LD_EXP 102
141342: PUSH
141343: LD_VAR 0 1
141347: ARRAY
141348: PUSH
141349: EMPTY
141350: EQUAL
141351: OR
141352: IFFALSE 141389
// begin for i in defenders do
141354: LD_ADDR_VAR 0 4
141358: PUSH
141359: LD_VAR 0 2
141363: PUSH
141364: FOR_IN
141365: IFFALSE 141378
// ComStop ( i ) ;
141367: LD_VAR 0 4
141371: PPUSH
141372: CALL_OW 141
141376: GO 141364
141378: POP
141379: POP
// defenders := [ ] ;
141380: LD_ADDR_VAR 0 2
141384: PUSH
141385: EMPTY
141386: ST_TO_ADDR
// exit ;
141387: GO 141615
// end ; for i in defenders do
141389: LD_ADDR_VAR 0 4
141393: PUSH
141394: LD_VAR 0 2
141398: PUSH
141399: FOR_IN
141400: IFFALSE 141489
// begin if not IsInArea ( i , mc_parking [ base ] ) then
141402: LD_VAR 0 4
141406: PPUSH
141407: LD_EXP 126
141411: PUSH
141412: LD_VAR 0 1
141416: ARRAY
141417: PPUSH
141418: CALL_OW 308
141422: NOT
141423: IFFALSE 141447
// ComMoveToArea ( i , mc_parking [ base ] ) else
141425: LD_VAR 0 4
141429: PPUSH
141430: LD_EXP 126
141434: PUSH
141435: LD_VAR 0 1
141439: ARRAY
141440: PPUSH
141441: CALL_OW 113
141445: GO 141487
// if GetControl ( i ) = control_manual then
141447: LD_VAR 0 4
141451: PPUSH
141452: CALL_OW 263
141456: PUSH
141457: LD_INT 1
141459: EQUAL
141460: IFFALSE 141487
// if IsDrivenBy ( i ) then
141462: LD_VAR 0 4
141466: PPUSH
141467: CALL_OW 311
141471: IFFALSE 141487
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
141473: LD_VAR 0 4
141477: PPUSH
141478: CALL_OW 311
141482: PPUSH
141483: CALL_OW 121
// end ;
141487: GO 141399
141489: POP
141490: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
141491: LD_VAR 0 2
141495: PPUSH
141496: LD_INT 95
141498: PUSH
141499: LD_EXP 126
141503: PUSH
141504: LD_VAR 0 1
141508: ARRAY
141509: PUSH
141510: EMPTY
141511: LIST
141512: LIST
141513: PPUSH
141514: CALL_OW 72
141518: PUSH
141519: LD_VAR 0 2
141523: EQUAL
141524: PUSH
141525: LD_EXP 125
141529: PUSH
141530: LD_VAR 0 1
141534: ARRAY
141535: OR
141536: PUSH
141537: LD_EXP 102
141541: PUSH
141542: LD_VAR 0 1
141546: ARRAY
141547: NOT
141548: OR
141549: IFFALSE 141319
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
141551: LD_ADDR_EXP 124
141555: PUSH
141556: LD_EXP 124
141560: PPUSH
141561: LD_VAR 0 1
141565: PPUSH
141566: LD_VAR 0 2
141570: PPUSH
141571: LD_INT 21
141573: PUSH
141574: LD_INT 2
141576: PUSH
141577: EMPTY
141578: LIST
141579: LIST
141580: PPUSH
141581: CALL_OW 72
141585: PPUSH
141586: CALL_OW 1
141590: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
141591: LD_VAR 0 1
141595: PPUSH
141596: LD_INT 19
141598: PPUSH
141599: CALL 43733 0 2
// MC_Reset ( base , 20 ) ;
141603: LD_VAR 0 1
141607: PPUSH
141608: LD_INT 20
141610: PPUSH
141611: CALL 43733 0 2
// end ; end_of_file
141615: LD_VAR 0 3
141619: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
141620: LD_VAR 0 1
141624: PUSH
141625: LD_INT 200
141627: DOUBLE
141628: GREATEREQUAL
141629: IFFALSE 141637
141631: LD_INT 299
141633: DOUBLE
141634: LESSEQUAL
141635: IFTRUE 141639
141637: GO 141671
141639: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
141640: LD_VAR 0 1
141644: PPUSH
141645: LD_VAR 0 2
141649: PPUSH
141650: LD_VAR 0 3
141654: PPUSH
141655: LD_VAR 0 4
141659: PPUSH
141660: LD_VAR 0 5
141664: PPUSH
141665: CALL 129620 0 5
141669: GO 141748
141671: LD_INT 300
141673: DOUBLE
141674: GREATEREQUAL
141675: IFFALSE 141683
141677: LD_INT 399
141679: DOUBLE
141680: LESSEQUAL
141681: IFTRUE 141685
141683: GO 141747
141685: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
141686: LD_VAR 0 1
141690: PPUSH
141691: LD_VAR 0 2
141695: PPUSH
141696: LD_VAR 0 3
141700: PPUSH
141701: LD_VAR 0 4
141705: PPUSH
141706: LD_VAR 0 5
141710: PPUSH
141711: LD_VAR 0 6
141715: PPUSH
141716: LD_VAR 0 7
141720: PPUSH
141721: LD_VAR 0 8
141725: PPUSH
141726: LD_VAR 0 9
141730: PPUSH
141731: LD_VAR 0 10
141735: PPUSH
141736: LD_VAR 0 11
141740: PPUSH
141741: CALL 125608 0 11
141745: GO 141748
141747: POP
// end ;
141748: PPOPN 11
141750: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
141751: LD_VAR 0 1
141755: PPUSH
141756: LD_VAR 0 2
141760: PPUSH
141761: LD_VAR 0 3
141765: PPUSH
141766: LD_VAR 0 4
141770: PPUSH
141771: LD_VAR 0 5
141775: PPUSH
141776: CALL 129085 0 5
// end ; end_of_file
141780: PPOPN 5
141782: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
141783: LD_VAR 0 1
141787: PPUSH
141788: LD_VAR 0 2
141792: PPUSH
141793: LD_VAR 0 3
141797: PPUSH
141798: LD_VAR 0 4
141802: PPUSH
141803: LD_VAR 0 5
141807: PPUSH
141808: LD_VAR 0 6
141812: PPUSH
141813: CALL 113260 0 6
// end ;
141817: PPOPN 6
141819: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
141820: LD_INT 0
141822: PPUSH
// begin if not units then
141823: LD_VAR 0 1
141827: NOT
141828: IFFALSE 141832
// exit ;
141830: GO 141832
// end ;
141832: PPOPN 7
141834: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
141835: CALL 113147 0 0
// end ;
141839: PPOPN 1
141841: END
