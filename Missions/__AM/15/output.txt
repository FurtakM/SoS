// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 39588 0 0
// InitNature ;
  19: CALL 39456 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 12660 0 0
// PrepareRussian ;
  40: CALL 7610 0 0
// PrepareLegion ;
  44: CALL 4678 0 0
// PreparePowell ;
  48: CALL 3212 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 17590 0 0
// MC_Start ( ) ;
  60: CALL 41768 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 126
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 127
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 64564 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 64657 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 64007 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 3
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 3
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 63822 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 64564 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 64657 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 63822 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 64007 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 64437 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 63485 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 64564 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 64657 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 131
 971: PUSH
 972: LD_EXP 131
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 63822 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 64564 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 64657 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 63714 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 64975 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 64146 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 64437 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 64437 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 64769 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 63822 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 64388 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker , Mike , DeltaDoctor ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 70296 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1942
// PrepareVehicle ( [ us_morphling , us_morphling , us_medium_tracked , us_medium_tracked ] [ Difficulty ] , engine_siberite , control_manual , [ us_laser , us_laser , us_double_gun , us_double_gun ] [ Difficulty ] , 100 ) else
1879: LD_INT 5
1881: PUSH
1882: LD_INT 5
1884: PUSH
1885: LD_INT 3
1887: PUSH
1888: LD_INT 3
1890: PUSH
1891: EMPTY
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: PUSH
1897: LD_OWVAR 67
1901: ARRAY
1902: PPUSH
1903: LD_INT 3
1905: PPUSH
1906: LD_INT 1
1908: PPUSH
1909: LD_INT 9
1911: PUSH
1912: LD_INT 9
1914: PUSH
1915: LD_INT 5
1917: PUSH
1918: LD_INT 5
1920: PUSH
1921: EMPTY
1922: LIST
1923: LIST
1924: LIST
1925: LIST
1926: PUSH
1927: LD_OWVAR 67
1931: ARRAY
1932: PPUSH
1933: LD_INT 100
1935: PPUSH
1936: CALL 75220 0 5
1940: GO 2001
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1942: LD_EXP 4
1946: PUSH
1947: LD_INT 1
1949: ARRAY
1950: PUSH
1951: LD_INT 1
1953: ARRAY
1954: PPUSH
1955: LD_EXP 4
1959: PUSH
1960: LD_INT 2
1962: ARRAY
1963: PUSH
1964: LD_INT 1
1966: ARRAY
1967: PPUSH
1968: LD_EXP 4
1972: PUSH
1973: LD_INT 3
1975: ARRAY
1976: PUSH
1977: LD_INT 1
1979: ARRAY
1980: PPUSH
1981: LD_EXP 4
1985: PUSH
1986: LD_INT 4
1988: ARRAY
1989: PUSH
1990: LD_INT 1
1992: ARRAY
1993: PPUSH
1994: LD_INT 30
1996: PPUSH
1997: CALL 75220 0 5
// JMMNewVeh := CreateVehicle ;
2001: LD_ADDR_EXP 59
2005: PUSH
2006: CALL_OW 45
2010: ST_TO_ADDR
// if not JMMNewVeh then
2011: LD_EXP 59
2015: NOT
2016: IFFALSE 2047
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
2018: LD_INT 5
2020: PPUSH
2021: LD_INT 3
2023: PPUSH
2024: LD_INT 1
2026: PPUSH
2027: LD_INT 9
2029: PPUSH
2030: LD_INT 100
2032: PPUSH
2033: CALL 75220 0 5
// JMMNewVeh := CreateVehicle ;
2037: LD_ADDR_EXP 59
2041: PUSH
2042: CALL_OW 45
2046: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2047: LD_EXP 59
2051: PPUSH
2052: LD_INT 4
2054: PPUSH
2055: CALL_OW 233
// SetMark ( JMMNewVeh , - 1 ) ;
2059: LD_EXP 59
2063: PPUSH
2064: LD_INT 1
2066: NEG
2067: PPUSH
2068: CALL_OW 242
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2072: LD_EXP 59
2076: PPUSH
2077: LD_INT 79
2079: PPUSH
2080: LD_INT 91
2082: PPUSH
2083: LD_INT 0
2085: PPUSH
2086: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2090: LD_EXP 40
2094: PPUSH
2095: LD_EXP 59
2099: PPUSH
2100: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2104: LD_EXP 6
2108: PUSH
2109: LD_EXP 2
2113: NOT
2114: AND
2115: IFFALSE 2373
// begin if not JMMGirlVeh then
2117: LD_EXP 5
2121: NOT
2122: IFFALSE 2145
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2124: LD_INT 3
2126: PPUSH
2127: LD_INT 3
2129: PPUSH
2130: LD_INT 1
2132: PPUSH
2133: LD_INT 9
2135: PPUSH
2136: LD_INT 100
2138: PPUSH
2139: CALL 75220 0 5
2143: GO 2204
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2145: LD_EXP 5
2149: PUSH
2150: LD_INT 1
2152: ARRAY
2153: PUSH
2154: LD_INT 1
2156: ARRAY
2157: PPUSH
2158: LD_EXP 5
2162: PUSH
2163: LD_INT 2
2165: ARRAY
2166: PUSH
2167: LD_INT 1
2169: ARRAY
2170: PPUSH
2171: LD_EXP 5
2175: PUSH
2176: LD_INT 3
2178: ARRAY
2179: PUSH
2180: LD_INT 1
2182: ARRAY
2183: PPUSH
2184: LD_EXP 5
2188: PUSH
2189: LD_INT 4
2191: ARRAY
2192: PUSH
2193: LD_INT 1
2195: ARRAY
2196: PPUSH
2197: LD_INT 30
2199: PPUSH
2200: CALL 75220 0 5
// GirlNewVeh := CreateVehicle ;
2204: LD_ADDR_EXP 60
2208: PUSH
2209: CALL_OW 45
2213: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2214: LD_EXP 60
2218: PPUSH
2219: LD_INT 4
2221: PPUSH
2222: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2226: LD_EXP 60
2230: PPUSH
2231: LD_INT 82
2233: PPUSH
2234: LD_INT 96
2236: PPUSH
2237: LD_INT 0
2239: PPUSH
2240: CALL_OW 48
// if JMMGirl = 1 then
2244: LD_EXP 7
2248: PUSH
2249: LD_INT 1
2251: EQUAL
2252: IFFALSE 2287
// begin Joan := PrepareUnit ( Joan , true , 14_ ) ;
2254: LD_ADDR_EXP 41
2258: PUSH
2259: LD_STRING Joan
2261: PPUSH
2262: LD_INT 1
2264: PPUSH
2265: LD_STRING 14_
2267: PPUSH
2268: CALL 70296 0 3
2272: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2273: LD_EXP 41
2277: PPUSH
2278: LD_EXP 60
2282: PPUSH
2283: CALL_OW 52
// end ; if JMMGirl = 2 then
2287: LD_EXP 7
2291: PUSH
2292: LD_INT 2
2294: EQUAL
2295: IFFALSE 2330
// begin Lisa := PrepareUnit ( Lisa , true , 14_ ) ;
2297: LD_ADDR_EXP 43
2301: PUSH
2302: LD_STRING Lisa
2304: PPUSH
2305: LD_INT 1
2307: PPUSH
2308: LD_STRING 14_
2310: PPUSH
2311: CALL 70296 0 3
2315: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2316: LD_EXP 43
2320: PPUSH
2321: LD_EXP 60
2325: PPUSH
2326: CALL_OW 52
// end ; if JMMGirl = 3 then
2330: LD_EXP 7
2334: PUSH
2335: LD_INT 3
2337: EQUAL
2338: IFFALSE 2373
// begin Connie := PrepareUnit ( Connie , true , 14_ ) ;
2340: LD_ADDR_EXP 55
2344: PUSH
2345: LD_STRING Connie
2347: PPUSH
2348: LD_INT 1
2350: PPUSH
2351: LD_STRING 14_
2353: PPUSH
2354: CALL 70296 0 3
2358: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2359: LD_EXP 55
2363: PPUSH
2364: LD_EXP 60
2368: PPUSH
2369: CALL_OW 52
// end ; end ; end ;
2373: LD_VAR 0 1
2377: RET
// export function PrepareStevensSquad ; var tmp ; begin
2378: LD_INT 0
2380: PPUSH
2381: PPUSH
// uc_side := 1 ;
2382: LD_ADDR_OWVAR 20
2386: PUSH
2387: LD_INT 1
2389: ST_TO_ADDR
// uc_nation := 1 ;
2390: LD_ADDR_OWVAR 21
2394: PUSH
2395: LD_INT 1
2397: ST_TO_ADDR
// tmp := [ ] ;
2398: LD_ADDR_VAR 0 2
2402: PUSH
2403: EMPTY
2404: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2405: LD_ADDR_EXP 42
2409: PUSH
2410: LD_STRING Stevens
2412: PPUSH
2413: LD_EXP 1
2417: NOT
2418: PPUSH
2419: LD_STRING 13f_
2421: PPUSH
2422: CALL 70296 0 3
2426: ST_TO_ADDR
// if not Stevens then
2427: LD_EXP 42
2431: NOT
2432: IFFALSE 2546
// begin hc_name = Baker Smith ;
2434: LD_ADDR_OWVAR 26
2438: PUSH
2439: LD_STRING Baker Smith
2441: ST_TO_ADDR
// hc_gallery = us ;
2442: LD_ADDR_OWVAR 33
2446: PUSH
2447: LD_STRING us
2449: ST_TO_ADDR
// hc_face_number := 29 ;
2450: LD_ADDR_OWVAR 34
2454: PUSH
2455: LD_INT 29
2457: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2458: LD_INT 1
2460: PPUSH
2461: LD_INT 10
2463: PPUSH
2464: CALL_OW 384
// hc_basic_skills := [ 2 , 2 , 0 , 2 ] ;
2468: LD_ADDR_OWVAR 30
2472: PUSH
2473: LD_INT 2
2475: PUSH
2476: LD_INT 2
2478: PUSH
2479: LD_INT 0
2481: PUSH
2482: LD_INT 2
2484: PUSH
2485: EMPTY
2486: LIST
2487: LIST
2488: LIST
2489: LIST
2490: ST_TO_ADDR
// hc_skills := [ 4 , 5 , 2 , 10 ] ;
2491: LD_ADDR_OWVAR 31
2495: PUSH
2496: LD_INT 4
2498: PUSH
2499: LD_INT 5
2501: PUSH
2502: LD_INT 2
2504: PUSH
2505: LD_INT 10
2507: PUSH
2508: EMPTY
2509: LIST
2510: LIST
2511: LIST
2512: LIST
2513: ST_TO_ADDR
// Baker := CreateHuman ;
2514: LD_ADDR_EXP 56
2518: PUSH
2519: CALL_OW 44
2523: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2524: LD_ADDR_VAR 0 2
2528: PUSH
2529: LD_VAR 0 2
2533: PUSH
2534: LD_EXP 56
2538: ADD
2539: ST_TO_ADDR
// InitHc ;
2540: CALL_OW 19
// end else
2544: GO 2562
// tmp := tmp ^ Stevens ;
2546: LD_ADDR_VAR 0 2
2550: PUSH
2551: LD_VAR 0 2
2555: PUSH
2556: LD_EXP 42
2560: ADD
2561: ST_TO_ADDR
// if not Lisa then
2562: LD_EXP 43
2566: NOT
2567: IFFALSE 2613
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2569: LD_ADDR_EXP 43
2573: PUSH
2574: LD_STRING Lisa
2576: PPUSH
2577: LD_EXP 1
2581: NOT
2582: PPUSH
2583: LD_STRING 13f_
2585: PPUSH
2586: CALL 70296 0 3
2590: ST_TO_ADDR
// if Lisa then
2591: LD_EXP 43
2595: IFFALSE 2613
// tmp := tmp ^ Lisa ;
2597: LD_ADDR_VAR 0 2
2601: PUSH
2602: LD_VAR 0 2
2606: PUSH
2607: LD_EXP 43
2611: ADD
2612: ST_TO_ADDR
// end ; if not Donaldson then
2613: LD_EXP 44
2617: NOT
2618: IFFALSE 2664
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2620: LD_ADDR_EXP 44
2624: PUSH
2625: LD_STRING Donaldson
2627: PPUSH
2628: LD_EXP 1
2632: NOT
2633: PPUSH
2634: LD_STRING 13f_
2636: PPUSH
2637: CALL 70296 0 3
2641: ST_TO_ADDR
// if Donaldson then
2642: LD_EXP 44
2646: IFFALSE 2664
// tmp := tmp ^ Donaldson ;
2648: LD_ADDR_VAR 0 2
2652: PUSH
2653: LD_VAR 0 2
2657: PUSH
2658: LD_EXP 44
2662: ADD
2663: ST_TO_ADDR
// end ; if not Bobby then
2664: LD_EXP 45
2668: NOT
2669: IFFALSE 2715
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2671: LD_ADDR_EXP 45
2675: PUSH
2676: LD_STRING Bobby
2678: PPUSH
2679: LD_EXP 1
2683: NOT
2684: PPUSH
2685: LD_STRING 13f_
2687: PPUSH
2688: CALL 70296 0 3
2692: ST_TO_ADDR
// if Bobby then
2693: LD_EXP 45
2697: IFFALSE 2715
// tmp := tmp ^ Bobby ;
2699: LD_ADDR_VAR 0 2
2703: PUSH
2704: LD_VAR 0 2
2708: PUSH
2709: LD_EXP 45
2713: ADD
2714: ST_TO_ADDR
// end ; if not Cyrus then
2715: LD_EXP 46
2719: NOT
2720: IFFALSE 2766
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2722: LD_ADDR_EXP 46
2726: PUSH
2727: LD_STRING Cyrus
2729: PPUSH
2730: LD_EXP 1
2734: NOT
2735: PPUSH
2736: LD_STRING 13f_
2738: PPUSH
2739: CALL 70296 0 3
2743: ST_TO_ADDR
// if Cyrus then
2744: LD_EXP 46
2748: IFFALSE 2766
// tmp := tmp ^ Cyrus ;
2750: LD_ADDR_VAR 0 2
2754: PUSH
2755: LD_VAR 0 2
2759: PUSH
2760: LD_EXP 46
2764: ADD
2765: ST_TO_ADDR
// end ; if not Brown then
2766: LD_EXP 48
2770: NOT
2771: IFFALSE 2817
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2773: LD_ADDR_EXP 48
2777: PUSH
2778: LD_STRING Brown
2780: PPUSH
2781: LD_EXP 1
2785: NOT
2786: PPUSH
2787: LD_STRING 13f_
2789: PPUSH
2790: CALL 70296 0 3
2794: ST_TO_ADDR
// if Brown then
2795: LD_EXP 48
2799: IFFALSE 2817
// tmp := tmp ^ Brown ;
2801: LD_ADDR_VAR 0 2
2805: PUSH
2806: LD_VAR 0 2
2810: PUSH
2811: LD_EXP 48
2815: ADD
2816: ST_TO_ADDR
// end ; if not Gladstone then
2817: LD_EXP 49
2821: NOT
2822: IFFALSE 2868
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2824: LD_ADDR_EXP 49
2828: PUSH
2829: LD_STRING Gladstone
2831: PPUSH
2832: LD_EXP 1
2836: NOT
2837: PPUSH
2838: LD_STRING 13f_
2840: PPUSH
2841: CALL 70296 0 3
2845: ST_TO_ADDR
// if Gladstone then
2846: LD_EXP 49
2850: IFFALSE 2868
// tmp := tmp ^ Gladstone ;
2852: LD_ADDR_VAR 0 2
2856: PUSH
2857: LD_VAR 0 2
2861: PUSH
2862: LD_EXP 49
2866: ADD
2867: ST_TO_ADDR
// end ; if not Houten then
2868: LD_EXP 50
2872: NOT
2873: IFFALSE 2919
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2875: LD_ADDR_EXP 50
2879: PUSH
2880: LD_STRING Houten
2882: PPUSH
2883: LD_EXP 1
2887: NOT
2888: PPUSH
2889: LD_STRING 13f_
2891: PPUSH
2892: CALL 70296 0 3
2896: ST_TO_ADDR
// if Houten then
2897: LD_EXP 50
2901: IFFALSE 2919
// tmp := tmp ^ Houten ;
2903: LD_ADDR_VAR 0 2
2907: PUSH
2908: LD_VAR 0 2
2912: PUSH
2913: LD_EXP 50
2917: ADD
2918: ST_TO_ADDR
// end ; if not Cornel then
2919: LD_EXP 51
2923: NOT
2924: IFFALSE 2970
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2926: LD_ADDR_EXP 51
2930: PUSH
2931: LD_STRING Cornell
2933: PPUSH
2934: LD_EXP 1
2938: NOT
2939: PPUSH
2940: LD_STRING 13f_
2942: PPUSH
2943: CALL 70296 0 3
2947: ST_TO_ADDR
// if Cornel then
2948: LD_EXP 51
2952: IFFALSE 2970
// tmp := tmp ^ Cornel ;
2954: LD_ADDR_VAR 0 2
2958: PUSH
2959: LD_VAR 0 2
2963: PUSH
2964: LD_EXP 51
2968: ADD
2969: ST_TO_ADDR
// end ; if not Gary then
2970: LD_EXP 52
2974: NOT
2975: IFFALSE 3021
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2977: LD_ADDR_EXP 52
2981: PUSH
2982: LD_STRING Gary
2984: PPUSH
2985: LD_EXP 1
2989: NOT
2990: PPUSH
2991: LD_STRING 13f_
2993: PPUSH
2994: CALL 70296 0 3
2998: ST_TO_ADDR
// if Gary then
2999: LD_EXP 52
3003: IFFALSE 3021
// tmp := tmp ^ Gary ;
3005: LD_ADDR_VAR 0 2
3009: PUSH
3010: LD_VAR 0 2
3014: PUSH
3015: LD_EXP 52
3019: ADD
3020: ST_TO_ADDR
// end ; if not Frank then
3021: LD_EXP 53
3025: NOT
3026: IFFALSE 3072
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
3028: LD_ADDR_EXP 53
3032: PUSH
3033: LD_STRING Frank
3035: PPUSH
3036: LD_EXP 1
3040: NOT
3041: PPUSH
3042: LD_STRING 13f_
3044: PPUSH
3045: CALL 70296 0 3
3049: ST_TO_ADDR
// if Frank then
3050: LD_EXP 53
3054: IFFALSE 3072
// tmp := tmp ^ Frank ;
3056: LD_ADDR_VAR 0 2
3060: PUSH
3061: LD_VAR 0 2
3065: PUSH
3066: LD_EXP 53
3070: ADD
3071: ST_TO_ADDR
// end ; if not Kikuchi then
3072: LD_EXP 54
3076: NOT
3077: IFFALSE 3123
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
3079: LD_ADDR_EXP 54
3083: PUSH
3084: LD_STRING Kikuchi
3086: PPUSH
3087: LD_EXP 1
3091: NOT
3092: PPUSH
3093: LD_STRING 13f_
3095: PPUSH
3096: CALL 70296 0 3
3100: ST_TO_ADDR
// if Kikuchi then
3101: LD_EXP 54
3105: IFFALSE 3123
// tmp := tmp ^ Kikuchi ;
3107: LD_ADDR_VAR 0 2
3111: PUSH
3112: LD_VAR 0 2
3116: PUSH
3117: LD_EXP 54
3121: ADD
3122: ST_TO_ADDR
// end ; if not DeltaDoctor then
3123: LD_EXP 58
3127: NOT
3128: IFFALSE 3174
// begin DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13f_ ) ;
3130: LD_ADDR_EXP 58
3134: PUSH
3135: LD_STRING DeltaDoctor
3137: PPUSH
3138: LD_EXP 1
3142: NOT
3143: PPUSH
3144: LD_STRING 13f_
3146: PPUSH
3147: CALL 70296 0 3
3151: ST_TO_ADDR
// if Bobby then
3152: LD_EXP 45
3156: IFFALSE 3174
// tmp := tmp ^ DeltaDoctor ;
3158: LD_ADDR_VAR 0 2
3162: PUSH
3163: LD_VAR 0 2
3167: PUSH
3168: LD_EXP 58
3172: ADD
3173: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3174: LD_ADDR_VAR 0 2
3178: PUSH
3179: LD_VAR 0 2
3183: PUSH
3184: LD_STRING 13_other_survivors
3186: PPUSH
3187: CALL_OW 31
3191: UNION
3192: ST_TO_ADDR
// result := tmp diff 0 ;
3193: LD_ADDR_VAR 0 1
3197: PUSH
3198: LD_VAR 0 2
3202: PUSH
3203: LD_INT 0
3205: DIFF
3206: ST_TO_ADDR
// end ; end_of_file
3207: LD_VAR 0 1
3211: RET
// export Powell ; export vip , extraSquad ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3212: LD_INT 0
3214: PPUSH
3215: PPUSH
3216: PPUSH
3217: PPUSH
3218: PPUSH
3219: PPUSH
3220: PPUSH
3221: PPUSH
3222: PPUSH
3223: PPUSH
// uc_side := 4 ;
3224: LD_ADDR_OWVAR 20
3228: PUSH
3229: LD_INT 4
3231: ST_TO_ADDR
// uc_nation := 1 ;
3232: LD_ADDR_OWVAR 21
3236: PUSH
3237: LD_INT 1
3239: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3240: LD_INT 387
3242: PPUSH
3243: CALL_OW 274
3247: PPUSH
3248: LD_INT 1
3250: PPUSH
3251: LD_INT 3500
3253: PUSH
3254: LD_INT 3000
3256: PUSH
3257: LD_INT 2500
3259: PUSH
3260: LD_INT 2000
3262: PUSH
3263: EMPTY
3264: LIST
3265: LIST
3266: LIST
3267: LIST
3268: PUSH
3269: LD_OWVAR 67
3273: ARRAY
3274: PPUSH
3275: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3279: LD_INT 387
3281: PPUSH
3282: CALL_OW 274
3286: PPUSH
3287: LD_INT 2
3289: PPUSH
3290: LD_INT 400
3292: PPUSH
3293: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3297: LD_INT 387
3299: PPUSH
3300: CALL_OW 274
3304: PPUSH
3305: LD_INT 3
3307: PPUSH
3308: LD_INT 10
3310: PPUSH
3311: CALL_OW 277
// SetBName ( am_depot , sigma ) ;
3315: LD_INT 387
3317: PPUSH
3318: LD_STRING sigma
3320: PPUSH
3321: CALL_OW 500
// Powell := NewCharacter ( Powell ) ;
3325: LD_ADDR_EXP 61
3329: PUSH
3330: LD_STRING Powell
3332: PPUSH
3333: CALL_OW 25
3337: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3338: LD_EXP 61
3342: PPUSH
3343: LD_INT 57
3345: PPUSH
3346: LD_INT 94
3348: PPUSH
3349: LD_INT 0
3351: PPUSH
3352: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3356: LD_EXP 61
3360: PPUSH
3361: LD_INT 58
3363: PPUSH
3364: LD_INT 94
3366: PPUSH
3367: CALL_OW 118
// vip := [ ] ;
3371: LD_ADDR_EXP 62
3375: PUSH
3376: EMPTY
3377: ST_TO_ADDR
// extraSquad := [ ] ;
3378: LD_ADDR_EXP 63
3382: PUSH
3383: EMPTY
3384: ST_TO_ADDR
// tmp := [ ] ;
3385: LD_ADDR_VAR 0 5
3389: PUSH
3390: EMPTY
3391: ST_TO_ADDR
// if JMMGirl <> 2 then
3392: LD_EXP 7
3396: PUSH
3397: LD_INT 2
3399: NONEQUAL
3400: IFFALSE 3424
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3402: LD_ADDR_EXP 43
3406: PUSH
3407: LD_STRING Lisa
3409: PPUSH
3410: LD_EXP 1
3414: NOT
3415: PPUSH
3416: LD_STRING 13s_
3418: PPUSH
3419: CALL 70296 0 3
3423: ST_TO_ADDR
// if Lisa then
3424: LD_EXP 43
3428: IFFALSE 3446
// tmp := tmp ^ Lisa ;
3430: LD_ADDR_VAR 0 5
3434: PUSH
3435: LD_VAR 0 5
3439: PUSH
3440: LD_EXP 43
3444: ADD
3445: ST_TO_ADDR
// if JMMGirl < 3 then
3446: LD_EXP 7
3450: PUSH
3451: LD_INT 3
3453: LESS
3454: IFFALSE 3485
// begin Connie := NewCharacter ( Coonie ) ;
3456: LD_ADDR_EXP 55
3460: PUSH
3461: LD_STRING Coonie
3463: PPUSH
3464: CALL_OW 25
3468: ST_TO_ADDR
// tmp := tmp ^ Connie ;
3469: LD_ADDR_VAR 0 5
3473: PUSH
3474: LD_VAR 0 5
3478: PUSH
3479: LD_EXP 55
3483: ADD
3484: ST_TO_ADDR
// end ; Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3485: LD_ADDR_EXP 44
3489: PUSH
3490: LD_STRING Donaldson
3492: PPUSH
3493: LD_EXP 1
3497: NOT
3498: PPUSH
3499: LD_STRING 13s_
3501: PPUSH
3502: CALL 70296 0 3
3506: ST_TO_ADDR
// if Donaldson then
3507: LD_EXP 44
3511: IFFALSE 3529
// tmp := tmp ^ Donaldson ;
3513: LD_ADDR_VAR 0 5
3517: PUSH
3518: LD_VAR 0 5
3522: PUSH
3523: LD_EXP 44
3527: ADD
3528: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3529: LD_ADDR_EXP 45
3533: PUSH
3534: LD_STRING Bobby
3536: PPUSH
3537: LD_EXP 1
3541: NOT
3542: PPUSH
3543: LD_STRING 13s_
3545: PPUSH
3546: CALL 70296 0 3
3550: ST_TO_ADDR
// if Bobby then
3551: LD_EXP 45
3555: IFFALSE 3573
// tmp := tmp ^ Bobby ;
3557: LD_ADDR_VAR 0 5
3561: PUSH
3562: LD_VAR 0 5
3566: PUSH
3567: LD_EXP 45
3571: ADD
3572: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3573: LD_ADDR_EXP 46
3577: PUSH
3578: LD_STRING Cyrus
3580: PPUSH
3581: LD_EXP 1
3585: NOT
3586: PPUSH
3587: LD_STRING 13s_
3589: PPUSH
3590: CALL 70296 0 3
3594: ST_TO_ADDR
// if Cyrus then
3595: LD_EXP 46
3599: IFFALSE 3617
// tmp := tmp ^ Cyrus ;
3601: LD_ADDR_VAR 0 5
3605: PUSH
3606: LD_VAR 0 5
3610: PUSH
3611: LD_EXP 46
3615: ADD
3616: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3617: LD_ADDR_EXP 47
3621: PUSH
3622: LD_STRING Denis
3624: PPUSH
3625: LD_EXP 1
3629: NOT
3630: PPUSH
3631: LD_STRING 13s_
3633: PPUSH
3634: CALL 70296 0 3
3638: ST_TO_ADDR
// if not Denis then
3639: LD_EXP 47
3643: NOT
3644: IFFALSE 3668
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3646: LD_ADDR_EXP 47
3650: PUSH
3651: LD_STRING Denis
3653: PPUSH
3654: LD_EXP 1
3658: NOT
3659: PPUSH
3660: LD_STRING 13f_
3662: PPUSH
3663: CALL 70296 0 3
3667: ST_TO_ADDR
// if Denis then
3668: LD_EXP 47
3672: IFFALSE 3690
// tmp := tmp ^ Denis ;
3674: LD_ADDR_VAR 0 5
3678: PUSH
3679: LD_VAR 0 5
3683: PUSH
3684: LD_EXP 47
3688: ADD
3689: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3690: LD_ADDR_EXP 48
3694: PUSH
3695: LD_STRING Brown
3697: PPUSH
3698: LD_EXP 1
3702: NOT
3703: PPUSH
3704: LD_STRING 13s_
3706: PPUSH
3707: CALL 70296 0 3
3711: ST_TO_ADDR
// if Brown then
3712: LD_EXP 48
3716: IFFALSE 3734
// tmp := tmp ^ Brown ;
3718: LD_ADDR_VAR 0 5
3722: PUSH
3723: LD_VAR 0 5
3727: PUSH
3728: LD_EXP 48
3732: ADD
3733: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3734: LD_ADDR_EXP 49
3738: PUSH
3739: LD_STRING Gladstone
3741: PPUSH
3742: LD_EXP 1
3746: NOT
3747: PPUSH
3748: LD_STRING 13s_
3750: PPUSH
3751: CALL 70296 0 3
3755: ST_TO_ADDR
// if Gladstone then
3756: LD_EXP 49
3760: IFFALSE 3778
// tmp := tmp ^ Gladstone ;
3762: LD_ADDR_VAR 0 5
3766: PUSH
3767: LD_VAR 0 5
3771: PUSH
3772: LD_EXP 49
3776: ADD
3777: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3778: LD_ADDR_EXP 50
3782: PUSH
3783: LD_STRING Houten
3785: PPUSH
3786: LD_EXP 1
3790: NOT
3791: PPUSH
3792: LD_STRING 13s_
3794: PPUSH
3795: CALL 70296 0 3
3799: ST_TO_ADDR
// if Houten then
3800: LD_EXP 50
3804: IFFALSE 3822
// tmp := tmp ^ Houten ;
3806: LD_ADDR_VAR 0 5
3810: PUSH
3811: LD_VAR 0 5
3815: PUSH
3816: LD_EXP 50
3820: ADD
3821: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3822: LD_ADDR_EXP 51
3826: PUSH
3827: LD_STRING Cornel
3829: PPUSH
3830: LD_EXP 1
3834: NOT
3835: PPUSH
3836: LD_STRING 13s_
3838: PPUSH
3839: CALL 70296 0 3
3843: ST_TO_ADDR
// if Cornel then
3844: LD_EXP 51
3848: IFFALSE 3866
// tmp := tmp ^ Cornel ;
3850: LD_ADDR_VAR 0 5
3854: PUSH
3855: LD_VAR 0 5
3859: PUSH
3860: LD_EXP 51
3864: ADD
3865: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3866: LD_ADDR_EXP 52
3870: PUSH
3871: LD_STRING Gary
3873: PPUSH
3874: LD_EXP 1
3878: NOT
3879: PPUSH
3880: LD_STRING 13s_
3882: PPUSH
3883: CALL 70296 0 3
3887: ST_TO_ADDR
// if Gary then
3888: LD_EXP 52
3892: IFFALSE 3910
// tmp := tmp ^ Gary ;
3894: LD_ADDR_VAR 0 5
3898: PUSH
3899: LD_VAR 0 5
3903: PUSH
3904: LD_EXP 52
3908: ADD
3909: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3910: LD_ADDR_EXP 53
3914: PUSH
3915: LD_STRING Frank
3917: PPUSH
3918: LD_EXP 1
3922: NOT
3923: PPUSH
3924: LD_STRING 13s_
3926: PPUSH
3927: CALL 70296 0 3
3931: ST_TO_ADDR
// if Frank then
3932: LD_EXP 53
3936: IFFALSE 3954
// tmp := tmp ^ Frank ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_VAR 0 5
3947: PUSH
3948: LD_EXP 53
3952: ADD
3953: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3954: LD_ADDR_EXP 54
3958: PUSH
3959: LD_STRING Kikuchi
3961: PPUSH
3962: LD_EXP 1
3966: NOT
3967: PPUSH
3968: LD_STRING 13s_
3970: PPUSH
3971: CALL 70296 0 3
3975: ST_TO_ADDR
// if Kikuchi then
3976: LD_EXP 54
3980: IFFALSE 3998
// tmp := tmp ^ Kikuchi ;
3982: LD_ADDR_VAR 0 5
3986: PUSH
3987: LD_VAR 0 5
3991: PUSH
3992: LD_EXP 54
3996: ADD
3997: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13s_ ) ;
3998: LD_ADDR_EXP 58
4002: PUSH
4003: LD_STRING DeltaDoctor
4005: PPUSH
4006: LD_EXP 1
4010: NOT
4011: PPUSH
4012: LD_STRING 13s_
4014: PPUSH
4015: CALL 70296 0 3
4019: ST_TO_ADDR
// if DeltaDoctor then
4020: LD_EXP 58
4024: IFFALSE 4042
// tmp := tmp ^ DeltaDoctor ;
4026: LD_ADDR_VAR 0 5
4030: PUSH
4031: LD_VAR 0 5
4035: PUSH
4036: LD_EXP 58
4040: ADD
4041: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 10c_ ) ;
4042: LD_ADDR_EXP 57
4046: PUSH
4047: LD_STRING Mike
4049: PPUSH
4050: LD_EXP 1
4054: NOT
4055: PPUSH
4056: LD_STRING 10c_
4058: PPUSH
4059: CALL 70296 0 3
4063: ST_TO_ADDR
// if Mike then
4064: LD_EXP 57
4068: IFFALSE 4091
// PlaceUnitXYR ( Mike , 61 , 89 , 8 , false ) ;
4070: LD_EXP 57
4074: PPUSH
4075: LD_INT 61
4077: PPUSH
4078: LD_INT 89
4080: PPUSH
4081: LD_INT 8
4083: PPUSH
4084: LD_INT 0
4086: PPUSH
4087: CALL_OW 50
// vip := tmp ;
4091: LD_ADDR_EXP 62
4095: PUSH
4096: LD_VAR 0 5
4100: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
4101: LD_ADDR_VAR 0 5
4105: PUSH
4106: LD_VAR 0 5
4110: PUSH
4111: LD_STRING 13s_others
4113: PPUSH
4114: CALL_OW 31
4118: UNION
4119: ST_TO_ADDR
// if tmp < 18 then
4120: LD_VAR 0 5
4124: PUSH
4125: LD_INT 18
4127: LESS
4128: IFFALSE 4233
// begin InitHC_All ( ) ;
4130: CALL_OW 584
// for i = 1 to 18 - tmp do
4134: LD_ADDR_VAR 0 2
4138: PUSH
4139: DOUBLE
4140: LD_INT 1
4142: DEC
4143: ST_TO_ADDR
4144: LD_INT 18
4146: PUSH
4147: LD_VAR 0 5
4151: MINUS
4152: PUSH
4153: FOR_TO
4154: IFFALSE 4231
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
4156: LD_INT 1
4158: PPUSH
4159: LD_VAR 0 2
4163: PUSH
4164: LD_INT 4
4166: MOD
4167: PUSH
4168: LD_INT 1
4170: PLUS
4171: PPUSH
4172: LD_INT 4
4174: PPUSH
4175: CALL_OW 380
// un := CreateHuman ;
4179: LD_ADDR_VAR 0 10
4183: PUSH
4184: CALL_OW 44
4188: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
4189: LD_ADDR_VAR 0 5
4193: PUSH
4194: LD_VAR 0 5
4198: PPUSH
4199: LD_VAR 0 10
4203: PPUSH
4204: CALL 108091 0 2
4208: ST_TO_ADDR
// extraSquad := Join ( extraSquad , un ) ;
4209: LD_ADDR_EXP 63
4213: PUSH
4214: LD_EXP 63
4218: PPUSH
4219: LD_VAR 0 10
4223: PPUSH
4224: CALL 108091 0 2
4228: ST_TO_ADDR
// end ;
4229: GO 4153
4231: POP
4232: POP
// end ; depot := HexInfo ( 53 , 94 ) ;
4233: LD_ADDR_VAR 0 6
4237: PUSH
4238: LD_INT 53
4240: PPUSH
4241: LD_INT 94
4243: PPUSH
4244: CALL_OW 428
4248: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
4249: LD_ADDR_VAR 0 7
4253: PUSH
4254: LD_INT 56
4256: PPUSH
4257: LD_INT 101
4259: PPUSH
4260: CALL_OW 428
4264: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
4265: LD_ADDR_VAR 0 8
4269: PUSH
4270: LD_INT 67
4272: PPUSH
4273: LD_INT 101
4275: PPUSH
4276: CALL_OW 428
4280: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
4281: LD_ADDR_VAR 0 9
4285: PUSH
4286: LD_INT 54
4288: PPUSH
4289: LD_INT 85
4291: PPUSH
4292: CALL_OW 428
4296: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
4297: LD_ADDR_VAR 0 3
4301: PUSH
4302: LD_VAR 0 8
4306: PUSH
4307: LD_VAR 0 6
4311: PUSH
4312: LD_VAR 0 9
4316: PUSH
4317: LD_VAR 0 7
4321: PUSH
4322: EMPTY
4323: LIST
4324: LIST
4325: LIST
4326: LIST
4327: ST_TO_ADDR
// for i in tmp do
4328: LD_ADDR_VAR 0 2
4332: PUSH
4333: LD_VAR 0 5
4337: PUSH
4338: FOR_IN
4339: IFFALSE 4534
// begin case GetBType ( b [ 1 ] ) of b_armoury :
4341: LD_VAR 0 3
4345: PUSH
4346: LD_INT 1
4348: ARRAY
4349: PPUSH
4350: CALL_OW 266
4354: PUSH
4355: LD_INT 4
4357: DOUBLE
4358: EQUAL
4359: IFTRUE 4363
4361: GO 4378
4363: POP
// SetClass ( i , class_soldier ) ; b_depot :
4364: LD_VAR 0 2
4368: PPUSH
4369: LD_INT 1
4371: PPUSH
4372: CALL_OW 336
4376: GO 4448
4378: LD_INT 0
4380: DOUBLE
4381: EQUAL
4382: IFTRUE 4386
4384: GO 4401
4386: POP
// SetClass ( i , class_engineer ) ; b_workshop :
4387: LD_VAR 0 2
4391: PPUSH
4392: LD_INT 2
4394: PPUSH
4395: CALL_OW 336
4399: GO 4448
4401: LD_INT 2
4403: DOUBLE
4404: EQUAL
4405: IFTRUE 4409
4407: GO 4424
4409: POP
// SetClass ( i , class_mechanic ) ; b_lab :
4410: LD_VAR 0 2
4414: PPUSH
4415: LD_INT 3
4417: PPUSH
4418: CALL_OW 336
4422: GO 4448
4424: LD_INT 6
4426: DOUBLE
4427: EQUAL
4428: IFTRUE 4432
4430: GO 4447
4432: POP
// SetClass ( i , class_scientistic ) ; end ;
4433: LD_VAR 0 2
4437: PPUSH
4438: LD_INT 4
4440: PPUSH
4441: CALL_OW 336
4445: GO 4448
4447: POP
// if UnitsInside ( b [ 1 ] ) = 6 then
4448: LD_VAR 0 3
4452: PUSH
4453: LD_INT 1
4455: ARRAY
4456: PPUSH
4457: CALL_OW 313
4461: PUSH
4462: LD_INT 6
4464: EQUAL
4465: IFFALSE 4485
// b := Delete ( b , 1 ) ;
4467: LD_ADDR_VAR 0 3
4471: PUSH
4472: LD_VAR 0 3
4476: PPUSH
4477: LD_INT 1
4479: PPUSH
4480: CALL_OW 3
4484: ST_TO_ADDR
// if b then
4485: LD_VAR 0 3
4489: IFFALSE 4511
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4491: LD_VAR 0 2
4495: PPUSH
4496: LD_VAR 0 3
4500: PUSH
4501: LD_INT 1
4503: ARRAY
4504: PPUSH
4505: CALL_OW 52
4509: GO 4532
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4511: LD_VAR 0 2
4515: PPUSH
4516: LD_INT 61
4518: PPUSH
4519: LD_INT 89
4521: PPUSH
4522: LD_INT 8
4524: PPUSH
4525: LD_INT 0
4527: PPUSH
4528: CALL_OW 50
// end ;
4532: GO 4338
4534: POP
4535: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4536: LD_INT 2
4538: PPUSH
4539: LD_INT 1
4541: PPUSH
4542: LD_INT 1
4544: PPUSH
4545: LD_INT 12
4547: PPUSH
4548: LD_INT 100
4550: PPUSH
4551: CALL 75220 0 5
// veh := CreateVehicle ;
4555: LD_ADDR_VAR 0 4
4559: PUSH
4560: CALL_OW 45
4564: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4565: LD_VAR 0 4
4569: PPUSH
4570: LD_INT 4
4572: PPUSH
4573: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4577: LD_VAR 0 4
4581: PPUSH
4582: LD_INT 49
4584: PPUSH
4585: LD_INT 88
4587: PPUSH
4588: LD_INT 0
4590: PPUSH
4591: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4595: LD_VAR 0 4
4599: PPUSH
4600: LD_INT 1
4602: PPUSH
4603: LD_INT 100
4605: PPUSH
4606: CALL_OW 290
// uc_side := 0 ;
4610: LD_ADDR_OWVAR 20
4614: PUSH
4615: LD_INT 0
4617: ST_TO_ADDR
// uc_nation := 0 ;
4618: LD_ADDR_OWVAR 21
4622: PUSH
4623: LD_INT 0
4625: ST_TO_ADDR
// for i := 1 to 3 do
4626: LD_ADDR_VAR 0 2
4630: PUSH
4631: DOUBLE
4632: LD_INT 1
4634: DEC
4635: ST_TO_ADDR
4636: LD_INT 3
4638: PUSH
4639: FOR_TO
4640: IFFALSE 4671
// begin InitHc ;
4642: CALL_OW 19
// hc_class := class_apeman ;
4646: LD_ADDR_OWVAR 28
4650: PUSH
4651: LD_INT 12
4653: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4654: CALL_OW 44
4658: PPUSH
4659: LD_INT 13
4661: PPUSH
4662: LD_INT 0
4664: PPUSH
4665: CALL_OW 49
// end ;
4669: GO 4639
4671: POP
4672: POP
// end ; end_of_file
4673: LD_VAR 0 1
4677: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4678: LD_INT 0
4680: PPUSH
4681: PPUSH
4682: PPUSH
4683: PPUSH
4684: PPUSH
// side := 8 ;
4685: LD_ADDR_VAR 0 3
4689: PUSH
4690: LD_INT 8
4692: ST_TO_ADDR
// uc_side := side ;
4693: LD_ADDR_OWVAR 20
4697: PUSH
4698: LD_VAR 0 3
4702: ST_TO_ADDR
// uc_nation := 2 ;
4703: LD_ADDR_OWVAR 21
4707: PUSH
4708: LD_INT 2
4710: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4711: LD_ADDR_VAR 0 2
4715: PUSH
4716: LD_INT 22
4718: PUSH
4719: LD_VAR 0 3
4723: PUSH
4724: EMPTY
4725: LIST
4726: LIST
4727: PUSH
4728: LD_INT 21
4730: PUSH
4731: LD_INT 3
4733: PUSH
4734: EMPTY
4735: LIST
4736: LIST
4737: PUSH
4738: EMPTY
4739: LIST
4740: LIST
4741: PPUSH
4742: CALL_OW 69
4746: PUSH
4747: FOR_IN
4748: IFFALSE 4764
// SetBLevel ( i , 10 ) ;
4750: LD_VAR 0 2
4754: PPUSH
4755: LD_INT 10
4757: PPUSH
4758: CALL_OW 241
4762: GO 4747
4764: POP
4765: POP
// if KurtStatus then
4766: LD_EXP 3
4770: IFFALSE 4793
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4772: LD_ADDR_EXP 64
4776: PUSH
4777: LD_STRING Kurt
4779: PPUSH
4780: LD_INT 0
4782: PPUSH
4783: LD_STRING 
4785: PPUSH
4786: CALL 70296 0 3
4790: ST_TO_ADDR
4791: GO 4815
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4793: LD_ADDR_EXP 64
4797: PUSH
4798: LD_STRING AltKurt
4800: PPUSH
4801: LD_EXP 1
4805: NOT
4806: PPUSH
4807: LD_STRING 
4809: PPUSH
4810: CALL 70296 0 3
4814: ST_TO_ADDR
// if not Kurt then
4815: LD_EXP 64
4819: NOT
4820: IFFALSE 4846
// begin InitHc ;
4822: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4826: LD_INT 1
4828: PPUSH
4829: LD_INT 10
4831: PPUSH
4832: CALL_OW 381
// Kurt := CreateHuman ;
4836: LD_ADDR_EXP 64
4840: PUSH
4841: CALL_OW 44
4845: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4846: LD_EXP 64
4850: PPUSH
4851: LD_INT 324
4853: PPUSH
4854: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4858: LD_ADDR_EXP 65
4862: PUSH
4863: LD_STRING Kozlov
4865: PPUSH
4866: LD_INT 0
4868: PPUSH
4869: LD_STRING 
4871: PPUSH
4872: CALL 70296 0 3
4876: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4877: LD_EXP 65
4881: PPUSH
4882: LD_INT 22
4884: PUSH
4885: LD_INT 8
4887: PUSH
4888: EMPTY
4889: LIST
4890: LIST
4891: PUSH
4892: LD_INT 23
4894: PUSH
4895: LD_INT 3
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: PUSH
4902: LD_INT 30
4904: PUSH
4905: LD_INT 8
4907: PUSH
4908: EMPTY
4909: LIST
4910: LIST
4911: PUSH
4912: EMPTY
4913: LIST
4914: LIST
4915: LIST
4916: PPUSH
4917: CALL_OW 69
4921: PUSH
4922: LD_INT 1
4924: ARRAY
4925: PPUSH
4926: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4930: LD_EXP 65
4934: PPUSH
4935: LD_INT 3
4937: PPUSH
4938: LD_INT 10
4940: PPUSH
4941: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4945: LD_EXP 65
4949: PPUSH
4950: LD_INT 4
4952: PPUSH
4953: LD_INT 10
4955: PPUSH
4956: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4960: LD_ADDR_VAR 0 5
4964: PUSH
4965: LD_INT 22
4967: PUSH
4968: LD_VAR 0 3
4972: PUSH
4973: EMPTY
4974: LIST
4975: LIST
4976: PUSH
4977: LD_INT 30
4979: PUSH
4980: LD_INT 32
4982: PUSH
4983: EMPTY
4984: LIST
4985: LIST
4986: PUSH
4987: LD_INT 58
4989: PUSH
4990: EMPTY
4991: LIST
4992: PUSH
4993: EMPTY
4994: LIST
4995: LIST
4996: LIST
4997: PPUSH
4998: CALL_OW 69
5002: ST_TO_ADDR
// for i = 1 to 10 do
5003: LD_ADDR_VAR 0 2
5007: PUSH
5008: DOUBLE
5009: LD_INT 1
5011: DEC
5012: ST_TO_ADDR
5013: LD_INT 10
5015: PUSH
5016: FOR_TO
5017: IFFALSE 5089
// begin uc_nation := nation_nature ;
5019: LD_ADDR_OWVAR 21
5023: PUSH
5024: LD_INT 0
5026: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
5027: LD_ADDR_OWVAR 28
5031: PUSH
5032: LD_INT 15
5034: ST_TO_ADDR
// hc_gallery :=  ;
5035: LD_ADDR_OWVAR 33
5039: PUSH
5040: LD_STRING 
5042: ST_TO_ADDR
// hc_name :=  ;
5043: LD_ADDR_OWVAR 26
5047: PUSH
5048: LD_STRING 
5050: ST_TO_ADDR
// un := CreateHuman ;
5051: LD_ADDR_VAR 0 4
5055: PUSH
5056: CALL_OW 44
5060: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
5061: LD_VAR 0 4
5065: PPUSH
5066: LD_VAR 0 5
5070: PUSH
5071: LD_VAR 0 5
5075: PUSH
5076: LD_VAR 0 2
5080: MINUS
5081: ARRAY
5082: PPUSH
5083: CALL_OW 52
// end ;
5087: GO 5016
5089: POP
5090: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
5091: LD_ADDR_VAR 0 5
5095: PUSH
5096: LD_STRING 12_kurt_squad
5098: PPUSH
5099: CALL_OW 31
5103: ST_TO_ADDR
// if tmp then
5104: LD_VAR 0 5
5108: IFFALSE 5142
// for i in tmp do
5110: LD_ADDR_VAR 0 2
5114: PUSH
5115: LD_VAR 0 5
5119: PUSH
5120: FOR_IN
5121: IFFALSE 5140
// PlaceUnitArea ( i , legionBaseArea , false ) ;
5123: LD_VAR 0 2
5127: PPUSH
5128: LD_INT 5
5130: PPUSH
5131: LD_INT 0
5133: PPUSH
5134: CALL_OW 49
5138: GO 5120
5140: POP
5141: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
5142: LD_INT 324
5144: PPUSH
5145: LD_INT 5
5147: PPUSH
5148: LD_STRING 
5150: PPUSH
5151: LD_INT 8
5153: PUSH
5154: LD_INT 9
5156: PUSH
5157: LD_INT 10
5159: PUSH
5160: LD_INT 10
5162: PUSH
5163: EMPTY
5164: LIST
5165: LIST
5166: LIST
5167: LIST
5168: PUSH
5169: LD_OWVAR 67
5173: ARRAY
5174: PPUSH
5175: LD_INT 3000
5177: PUSH
5178: LD_INT 500
5180: PUSH
5181: LD_INT 150
5183: PUSH
5184: EMPTY
5185: LIST
5186: LIST
5187: LIST
5188: PPUSH
5189: LD_INT 16
5191: PUSH
5192: LD_INT 6
5194: PUSH
5195: LD_INT 6
5197: PUSH
5198: LD_INT 8
5200: PUSH
5201: EMPTY
5202: LIST
5203: LIST
5204: LIST
5205: LIST
5206: PPUSH
5207: CALL 79041 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
5211: LD_ADDR_EXP 102
5215: PUSH
5216: LD_EXP 102
5220: PPUSH
5221: LD_INT 3
5223: PPUSH
5224: LD_INT 22
5226: PUSH
5227: LD_VAR 0 3
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: PUSH
5236: LD_INT 23
5238: PUSH
5239: LD_INT 2
5241: PUSH
5242: EMPTY
5243: LIST
5244: LIST
5245: PUSH
5246: LD_INT 3
5248: PUSH
5249: LD_INT 21
5251: PUSH
5252: LD_INT 2
5254: PUSH
5255: EMPTY
5256: LIST
5257: LIST
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: PUSH
5263: EMPTY
5264: LIST
5265: LIST
5266: LIST
5267: PPUSH
5268: CALL_OW 69
5272: PUSH
5273: LD_EXP 64
5277: DIFF
5278: PPUSH
5279: CALL_OW 1
5283: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
5284: LD_INT 1
5286: PPUSH
5287: LD_INT 7
5289: PPUSH
5290: CALL_OW 383
// hc_name := Ali Hadrach ;
5294: LD_ADDR_OWVAR 26
5298: PUSH
5299: LD_STRING Ali Hadrach
5301: ST_TO_ADDR
// hc_gallery := us ;
5302: LD_ADDR_OWVAR 33
5306: PUSH
5307: LD_STRING us
5309: ST_TO_ADDR
// hc_face_number := 31 ;
5310: LD_ADDR_OWVAR 34
5314: PUSH
5315: LD_INT 31
5317: ST_TO_ADDR
// Friend := CreateHuman ;
5318: LD_ADDR_EXP 66
5322: PUSH
5323: CALL_OW 44
5327: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
5328: LD_INT 14
5330: PPUSH
5331: LD_INT 3
5333: PPUSH
5334: LD_INT 1
5336: PPUSH
5337: LD_INT 29
5339: PPUSH
5340: LD_INT 100
5342: PPUSH
5343: CALL 75220 0 5
// powellBomb := CreateVehicle ;
5347: LD_ADDR_EXP 67
5351: PUSH
5352: CALL_OW 45
5356: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
5357: LD_EXP 67
5361: PPUSH
5362: LD_INT 90
5364: PPUSH
5365: LD_INT 51
5367: PPUSH
5368: LD_INT 0
5370: PPUSH
5371: CALL_OW 48
// end ;
5375: LD_VAR 0 1
5379: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
5380: LD_INT 0
5382: PPUSH
5383: PPUSH
5384: PPUSH
// if IsLive ( kozlov_fac ) then
5385: LD_INT 332
5387: PPUSH
5388: CALL_OW 300
5392: IFFALSE 5396
// exit ;
5394: GO 5963
// ComExitBuilding ( Kozlov ) ;
5396: LD_EXP 65
5400: PPUSH
5401: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
5405: LD_EXP 65
5409: PPUSH
5410: CALL_OW 257
5414: PUSH
5415: LD_INT 2
5417: NONEQUAL
5418: IFFALSE 5453
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
5420: LD_EXP 65
5424: PPUSH
5425: LD_INT 324
5427: PPUSH
5428: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
5432: LD_EXP 65
5436: PPUSH
5437: LD_INT 2
5439: PPUSH
5440: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
5444: LD_EXP 65
5448: PPUSH
5449: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
5453: LD_EXP 65
5457: PPUSH
5458: LD_INT 2
5460: PPUSH
5461: LD_INT 93
5463: PPUSH
5464: LD_INT 32
5466: PPUSH
5467: LD_INT 3
5469: PPUSH
5470: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5474: LD_INT 35
5476: PPUSH
5477: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5481: LD_INT 22
5483: PUSH
5484: LD_INT 8
5486: PUSH
5487: EMPTY
5488: LIST
5489: LIST
5490: PUSH
5491: LD_INT 30
5493: PUSH
5494: LD_INT 3
5496: PUSH
5497: EMPTY
5498: LIST
5499: LIST
5500: PUSH
5501: LD_INT 23
5503: PUSH
5504: LD_INT 3
5506: PUSH
5507: EMPTY
5508: LIST
5509: LIST
5510: PUSH
5511: LD_INT 57
5513: PUSH
5514: EMPTY
5515: LIST
5516: PUSH
5517: EMPTY
5518: LIST
5519: LIST
5520: LIST
5521: LIST
5522: PPUSH
5523: CALL_OW 69
5527: IFFALSE 5474
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5529: LD_ADDR_VAR 0 2
5533: PUSH
5534: LD_INT 22
5536: PUSH
5537: LD_INT 8
5539: PUSH
5540: EMPTY
5541: LIST
5542: LIST
5543: PUSH
5544: LD_INT 30
5546: PUSH
5547: LD_INT 3
5549: PUSH
5550: EMPTY
5551: LIST
5552: LIST
5553: PUSH
5554: LD_INT 23
5556: PUSH
5557: LD_INT 3
5559: PUSH
5560: EMPTY
5561: LIST
5562: LIST
5563: PUSH
5564: LD_INT 57
5566: PUSH
5567: EMPTY
5568: LIST
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: LIST
5574: LIST
5575: PPUSH
5576: CALL_OW 69
5580: PUSH
5581: LD_INT 1
5583: ARRAY
5584: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5585: LD_INT 22
5587: PUSH
5588: LD_INT 8
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: PUSH
5595: LD_INT 23
5597: PUSH
5598: LD_INT 3
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: PUSH
5605: LD_INT 30
5607: PUSH
5608: LD_INT 21
5610: PUSH
5611: EMPTY
5612: LIST
5613: LIST
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: LIST
5619: PPUSH
5620: CALL_OW 69
5624: NOT
5625: IFFALSE 5703
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5627: LD_EXP 65
5631: PPUSH
5632: LD_INT 21
5634: PPUSH
5635: LD_INT 97
5637: PPUSH
5638: LD_INT 36
5640: PPUSH
5641: LD_INT 5
5643: PPUSH
5644: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5648: LD_INT 35
5650: PPUSH
5651: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5655: LD_INT 22
5657: PUSH
5658: LD_INT 8
5660: PUSH
5661: EMPTY
5662: LIST
5663: LIST
5664: PUSH
5665: LD_INT 23
5667: PUSH
5668: LD_INT 3
5670: PUSH
5671: EMPTY
5672: LIST
5673: LIST
5674: PUSH
5675: LD_INT 30
5677: PUSH
5678: LD_INT 21
5680: PUSH
5681: EMPTY
5682: LIST
5683: LIST
5684: PUSH
5685: LD_INT 57
5687: PUSH
5688: EMPTY
5689: LIST
5690: PUSH
5691: EMPTY
5692: LIST
5693: LIST
5694: LIST
5695: LIST
5696: PPUSH
5697: CALL_OW 69
5701: IFFALSE 5648
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5703: LD_INT 22
5705: PUSH
5706: LD_INT 8
5708: PUSH
5709: EMPTY
5710: LIST
5711: LIST
5712: PUSH
5713: LD_INT 23
5715: PUSH
5716: LD_INT 3
5718: PUSH
5719: EMPTY
5720: LIST
5721: LIST
5722: PUSH
5723: LD_INT 30
5725: PUSH
5726: LD_INT 18
5728: PUSH
5729: EMPTY
5730: LIST
5731: LIST
5732: PUSH
5733: EMPTY
5734: LIST
5735: LIST
5736: LIST
5737: PPUSH
5738: CALL_OW 69
5742: NOT
5743: IFFALSE 5821
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5745: LD_EXP 65
5749: PPUSH
5750: LD_INT 18
5752: PPUSH
5753: LD_INT 89
5755: PPUSH
5756: LD_INT 32
5758: PPUSH
5759: LD_INT 1
5761: PPUSH
5762: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5766: LD_INT 35
5768: PPUSH
5769: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5773: LD_INT 22
5775: PUSH
5776: LD_INT 8
5778: PUSH
5779: EMPTY
5780: LIST
5781: LIST
5782: PUSH
5783: LD_INT 23
5785: PUSH
5786: LD_INT 3
5788: PUSH
5789: EMPTY
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 30
5795: PUSH
5796: LD_INT 18
5798: PUSH
5799: EMPTY
5800: LIST
5801: LIST
5802: PUSH
5803: LD_INT 57
5805: PUSH
5806: EMPTY
5807: LIST
5808: PUSH
5809: EMPTY
5810: LIST
5811: LIST
5812: LIST
5813: LIST
5814: PPUSH
5815: CALL_OW 69
5819: IFFALSE 5766
// end ; lab := kozlov_lab ;
5821: LD_ADDR_VAR 0 3
5825: PUSH
5826: LD_INT 336
5828: ST_TO_ADDR
// if not lab then
5829: LD_VAR 0 3
5833: NOT
5834: IFFALSE 5838
// exit ;
5836: GO 5963
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5838: LD_EXP 65
5842: PPUSH
5843: LD_VAR 0 3
5847: PUSH
5848: LD_INT 1
5850: ARRAY
5851: PPUSH
5852: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5856: LD_EXP 65
5860: PPUSH
5861: LD_INT 4
5863: PPUSH
5864: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5868: LD_VAR 0 3
5872: PUSH
5873: LD_INT 1
5875: ARRAY
5876: PPUSH
5877: LD_INT 25
5879: PPUSH
5880: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5884: LD_INT 35
5886: PPUSH
5887: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5891: LD_INT 25
5893: PPUSH
5894: LD_INT 8
5896: PPUSH
5897: CALL_OW 321
5901: PUSH
5902: LD_INT 2
5904: EQUAL
5905: IFFALSE 5884
// ComExitBuilding ( Kozlov ) ;
5907: LD_EXP 65
5911: PPUSH
5912: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5916: LD_EXP 65
5920: PPUSH
5921: LD_VAR 0 2
5925: PPUSH
5926: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5930: LD_EXP 65
5934: PPUSH
5935: LD_INT 3
5937: PPUSH
5938: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5942: LD_VAR 0 2
5946: PPUSH
5947: LD_INT 23
5949: PPUSH
5950: LD_INT 3
5952: PPUSH
5953: LD_INT 1
5955: PPUSH
5956: LD_INT 48
5958: PPUSH
5959: CALL_OW 125
// end ;
5963: LD_VAR 0 1
5967: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5968: LD_EXP 22
5972: NOT
5973: PUSH
5974: LD_EXP 15
5978: PUSH
5979: LD_INT 6
5981: GREATEREQUAL
5982: AND
5983: IFFALSE 6064
5985: GO 5987
5987: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5988: LD_INT 3
5990: PPUSH
5991: LD_INT 3
5993: PPUSH
5994: CALL 64007 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5998: LD_INT 3
6000: PPUSH
6001: LD_INT 14
6003: PUSH
6004: LD_INT 1
6006: PUSH
6007: LD_INT 1
6009: PUSH
6010: LD_INT 28
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: PUSH
6019: LD_INT 14
6021: PUSH
6022: LD_INT 1
6024: PUSH
6025: LD_INT 1
6027: PUSH
6028: LD_INT 28
6030: PUSH
6031: EMPTY
6032: LIST
6033: LIST
6034: LIST
6035: LIST
6036: PUSH
6037: LD_INT 14
6039: PUSH
6040: LD_INT 1
6042: PUSH
6043: LD_INT 1
6045: PUSH
6046: LD_INT 28
6048: PUSH
6049: EMPTY
6050: LIST
6051: LIST
6052: LIST
6053: LIST
6054: PUSH
6055: EMPTY
6056: LIST
6057: LIST
6058: LIST
6059: PPUSH
6060: CALL 63870 0 2
// end ;
6064: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target , p ;
6065: LD_EXP 22
6069: NOT
6070: PUSH
6071: LD_EXP 15
6075: PUSH
6076: LD_INT 6
6078: GREATEREQUAL
6079: AND
6080: PUSH
6081: LD_INT 3
6083: PPUSH
6084: LD_INT 1
6086: PPUSH
6087: CALL 65288 0 2
6091: NOT
6092: AND
6093: IFFALSE 7046
6095: GO 6097
6097: DISABLE
6098: LD_INT 0
6100: PPUSH
6101: PPUSH
6102: PPUSH
6103: PPUSH
// begin enable ;
6104: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
6105: LD_INT 22
6107: PUSH
6108: LD_INT 8
6110: PUSH
6111: EMPTY
6112: LIST
6113: LIST
6114: PUSH
6115: LD_INT 23
6117: PUSH
6118: LD_INT 2
6120: PUSH
6121: EMPTY
6122: LIST
6123: LIST
6124: PUSH
6125: LD_INT 30
6127: PUSH
6128: LD_INT 3
6130: PUSH
6131: EMPTY
6132: LIST
6133: LIST
6134: PUSH
6135: EMPTY
6136: LIST
6137: LIST
6138: LIST
6139: PPUSH
6140: CALL_OW 69
6144: NOT
6145: IFFALSE 6149
// exit ;
6147: GO 7046
// if Prob ( 40 ) then
6149: LD_INT 40
6151: PPUSH
6152: CALL_OW 13
6156: IFFALSE 6283
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6158: LD_INT 3
6160: PPUSH
6161: LD_INT 14
6163: PUSH
6164: LD_INT 1
6166: PUSH
6167: LD_INT 2
6169: PUSH
6170: LD_INT 28
6172: PUSH
6173: EMPTY
6174: LIST
6175: LIST
6176: LIST
6177: LIST
6178: PUSH
6179: LD_INT 14
6181: PUSH
6182: LD_INT 1
6184: PUSH
6185: LD_INT 2
6187: PUSH
6188: LD_INT 28
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: LIST
6195: LIST
6196: PUSH
6197: LD_INT 14
6199: PUSH
6200: LD_INT 1
6202: PUSH
6203: LD_INT 2
6205: PUSH
6206: LD_INT 28
6208: PUSH
6209: EMPTY
6210: LIST
6211: LIST
6212: LIST
6213: LIST
6214: PUSH
6215: LD_INT 14
6217: PUSH
6218: LD_INT 1
6220: PUSH
6221: LD_INT 2
6223: PUSH
6224: LD_INT 28
6226: PUSH
6227: EMPTY
6228: LIST
6229: LIST
6230: LIST
6231: LIST
6232: PUSH
6233: LD_INT 14
6235: PUSH
6236: LD_INT 1
6238: PUSH
6239: LD_INT 2
6241: PUSH
6242: LD_INT 28
6244: PUSH
6245: EMPTY
6246: LIST
6247: LIST
6248: LIST
6249: LIST
6250: PUSH
6251: LD_INT 14
6253: PUSH
6254: LD_INT 1
6256: PUSH
6257: LD_INT 2
6259: PUSH
6260: LD_INT 26
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: LIST
6267: LIST
6268: PUSH
6269: EMPTY
6270: LIST
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: LIST
6276: PPUSH
6277: CALL 63870 0 2
// end else
6281: GO 6490
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6283: LD_INT 3
6285: PPUSH
6286: LD_INT 14
6288: PUSH
6289: LD_INT 1
6291: PUSH
6292: LD_INT 2
6294: PUSH
6295: LD_INT 27
6297: PUSH
6298: LD_INT 26
6300: PUSH
6301: LD_INT 26
6303: PUSH
6304: LD_INT 28
6306: PUSH
6307: EMPTY
6308: LIST
6309: LIST
6310: LIST
6311: LIST
6312: PUSH
6313: LD_OWVAR 67
6317: ARRAY
6318: PUSH
6319: EMPTY
6320: LIST
6321: LIST
6322: LIST
6323: LIST
6324: PUSH
6325: LD_INT 14
6327: PUSH
6328: LD_INT 1
6330: PUSH
6331: LD_INT 2
6333: PUSH
6334: LD_INT 27
6336: PUSH
6337: LD_INT 26
6339: PUSH
6340: LD_INT 26
6342: PUSH
6343: LD_INT 26
6345: PUSH
6346: EMPTY
6347: LIST
6348: LIST
6349: LIST
6350: LIST
6351: PUSH
6352: LD_OWVAR 67
6356: ARRAY
6357: PUSH
6358: EMPTY
6359: LIST
6360: LIST
6361: LIST
6362: LIST
6363: PUSH
6364: LD_INT 14
6366: PUSH
6367: LD_INT 1
6369: PUSH
6370: LD_INT 2
6372: PUSH
6373: LD_INT 26
6375: PUSH
6376: LD_INT 26
6378: PUSH
6379: LD_INT 29
6381: PUSH
6382: LD_INT 29
6384: PUSH
6385: EMPTY
6386: LIST
6387: LIST
6388: LIST
6389: LIST
6390: PUSH
6391: LD_OWVAR 67
6395: ARRAY
6396: PUSH
6397: EMPTY
6398: LIST
6399: LIST
6400: LIST
6401: LIST
6402: PUSH
6403: LD_INT 13
6405: PUSH
6406: LD_INT 1
6408: PUSH
6409: LD_INT 2
6411: PUSH
6412: LD_INT 26
6414: PUSH
6415: LD_INT 29
6417: PUSH
6418: LD_INT 29
6420: PUSH
6421: LD_INT 29
6423: PUSH
6424: EMPTY
6425: LIST
6426: LIST
6427: LIST
6428: LIST
6429: PUSH
6430: LD_OWVAR 67
6434: ARRAY
6435: PUSH
6436: EMPTY
6437: LIST
6438: LIST
6439: LIST
6440: LIST
6441: PUSH
6442: LD_INT 13
6444: PUSH
6445: LD_INT 1
6447: PUSH
6448: LD_INT 2
6450: PUSH
6451: LD_INT 29
6453: PUSH
6454: EMPTY
6455: LIST
6456: LIST
6457: LIST
6458: LIST
6459: PUSH
6460: LD_INT 14
6462: PUSH
6463: LD_INT 1
6465: PUSH
6466: LD_INT 2
6468: PUSH
6469: LD_INT 26
6471: PUSH
6472: EMPTY
6473: LIST
6474: LIST
6475: LIST
6476: LIST
6477: PUSH
6478: EMPTY
6479: LIST
6480: LIST
6481: LIST
6482: LIST
6483: LIST
6484: LIST
6485: PPUSH
6486: CALL 63870 0 2
// end ; wait ( 2 2$00 ) ;
6490: LD_INT 4200
6492: PPUSH
6493: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] , [ f_not , [ f_weapon , ar_crane ] ] ] ) diff mc_defender [ 3 ] ;
6497: LD_ADDR_VAR 0 2
6501: PUSH
6502: LD_INT 22
6504: PUSH
6505: LD_INT 8
6507: PUSH
6508: EMPTY
6509: LIST
6510: LIST
6511: PUSH
6512: LD_INT 21
6514: PUSH
6515: LD_INT 2
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: PUSH
6522: LD_INT 3
6524: PUSH
6525: LD_INT 34
6527: PUSH
6528: LD_INT 31
6530: PUSH
6531: EMPTY
6532: LIST
6533: LIST
6534: PUSH
6535: EMPTY
6536: LIST
6537: LIST
6538: PUSH
6539: LD_INT 3
6541: PUSH
6542: LD_INT 34
6544: PUSH
6545: LD_INT 32
6547: PUSH
6548: EMPTY
6549: LIST
6550: LIST
6551: PUSH
6552: EMPTY
6553: LIST
6554: LIST
6555: PUSH
6556: LD_INT 3
6558: PUSH
6559: LD_INT 34
6561: PUSH
6562: LD_INT 88
6564: PUSH
6565: EMPTY
6566: LIST
6567: LIST
6568: PUSH
6569: EMPTY
6570: LIST
6571: LIST
6572: PUSH
6573: EMPTY
6574: LIST
6575: LIST
6576: LIST
6577: LIST
6578: LIST
6579: PPUSH
6580: CALL_OW 69
6584: PUSH
6585: LD_EXP 124
6589: PUSH
6590: LD_INT 3
6592: ARRAY
6593: DIFF
6594: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6595: LD_ADDR_EXP 121
6599: PUSH
6600: LD_EXP 121
6604: PPUSH
6605: LD_INT 3
6607: PPUSH
6608: LD_EXP 121
6612: PUSH
6613: LD_INT 3
6615: ARRAY
6616: PUSH
6617: LD_VAR 0 2
6621: DIFF
6622: PPUSH
6623: CALL_OW 1
6627: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6628: LD_ADDR_VAR 0 3
6632: PUSH
6633: LD_INT 0
6635: PPUSH
6636: LD_INT 2
6638: PPUSH
6639: CALL_OW 12
6643: ST_TO_ADDR
// if target then
6644: LD_VAR 0 3
6648: IFFALSE 6806
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6650: LD_ADDR_VAR 0 2
6654: PUSH
6655: LD_VAR 0 2
6659: PPUSH
6660: LD_INT 50
6662: PUSH
6663: EMPTY
6664: LIST
6665: PPUSH
6666: CALL_OW 72
6670: ST_TO_ADDR
// if not tmp then
6671: LD_VAR 0 2
6675: NOT
6676: IFFALSE 6680
// break ;
6678: GO 6804
// for i in tmp do
6680: LD_ADDR_VAR 0 1
6684: PUSH
6685: LD_VAR 0 2
6689: PUSH
6690: FOR_IN
6691: IFFALSE 6731
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6693: LD_VAR 0 1
6697: PPUSH
6698: LD_INT 89
6700: PPUSH
6701: LD_INT 71
6703: PPUSH
6704: CALL_OW 297
6708: PUSH
6709: LD_INT 9
6711: GREATER
6712: IFFALSE 6729
// ComMoveXY ( i , 89 , 71 ) ;
6714: LD_VAR 0 1
6718: PPUSH
6719: LD_INT 89
6721: PPUSH
6722: LD_INT 71
6724: PPUSH
6725: CALL_OW 111
6729: GO 6690
6731: POP
6732: POP
// wait ( 0 0$1 ) ;
6733: LD_INT 35
6735: PPUSH
6736: CALL_OW 67
// p := Inc ( p ) ;
6740: LD_ADDR_VAR 0 4
6744: PUSH
6745: LD_VAR 0 4
6749: PPUSH
6750: CALL 109452 0 1
6754: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6755: LD_VAR 0 2
6759: PPUSH
6760: LD_INT 92
6762: PUSH
6763: LD_INT 89
6765: PUSH
6766: LD_INT 71
6768: PUSH
6769: LD_INT 9
6771: PUSH
6772: EMPTY
6773: LIST
6774: LIST
6775: LIST
6776: LIST
6777: PPUSH
6778: CALL_OW 72
6782: PUSH
6783: LD_VAR 0 2
6787: PUSH
6788: LD_INT 1
6790: MINUS
6791: GREATEREQUAL
6792: PUSH
6793: LD_VAR 0 4
6797: PUSH
6798: LD_INT 30
6800: GREATER
6801: OR
6802: IFFALSE 6650
// end else
6804: GO 6960
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6806: LD_ADDR_VAR 0 2
6810: PUSH
6811: LD_VAR 0 2
6815: PPUSH
6816: LD_INT 50
6818: PUSH
6819: EMPTY
6820: LIST
6821: PPUSH
6822: CALL_OW 72
6826: ST_TO_ADDR
// if not tmp then
6827: LD_VAR 0 2
6831: NOT
6832: IFFALSE 6836
// break ;
6834: GO 6960
// for i in tmp do
6836: LD_ADDR_VAR 0 1
6840: PUSH
6841: LD_VAR 0 2
6845: PUSH
6846: FOR_IN
6847: IFFALSE 6887
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6849: LD_VAR 0 1
6853: PPUSH
6854: LD_INT 125
6856: PPUSH
6857: LD_INT 129
6859: PPUSH
6860: CALL_OW 297
6864: PUSH
6865: LD_INT 9
6867: GREATER
6868: IFFALSE 6885
// ComMoveXY ( i , 125 , 129 ) ;
6870: LD_VAR 0 1
6874: PPUSH
6875: LD_INT 125
6877: PPUSH
6878: LD_INT 129
6880: PPUSH
6881: CALL_OW 111
6885: GO 6846
6887: POP
6888: POP
// wait ( 0 0$1 ) ;
6889: LD_INT 35
6891: PPUSH
6892: CALL_OW 67
// p := Inc ( p ) ;
6896: LD_ADDR_VAR 0 4
6900: PUSH
6901: LD_VAR 0 4
6905: PPUSH
6906: CALL 109452 0 1
6910: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6911: LD_VAR 0 2
6915: PPUSH
6916: LD_INT 92
6918: PUSH
6919: LD_INT 125
6921: PUSH
6922: LD_INT 129
6924: PUSH
6925: LD_INT 9
6927: PUSH
6928: EMPTY
6929: LIST
6930: LIST
6931: LIST
6932: LIST
6933: PPUSH
6934: CALL_OW 72
6938: PUSH
6939: LD_VAR 0 2
6943: PUSH
6944: LD_INT 1
6946: MINUS
6947: GREATEREQUAL
6948: PUSH
6949: LD_VAR 0 4
6953: PUSH
6954: LD_INT 30
6956: GREATER
6957: OR
6958: IFFALSE 6806
// end ; repeat wait ( 0 0$1 ) ;
6960: LD_INT 35
6962: PPUSH
6963: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6967: LD_ADDR_VAR 0 2
6971: PUSH
6972: LD_VAR 0 2
6976: PPUSH
6977: LD_INT 50
6979: PUSH
6980: EMPTY
6981: LIST
6982: PPUSH
6983: CALL_OW 72
6987: ST_TO_ADDR
// for i in tmp do
6988: LD_ADDR_VAR 0 1
6992: PUSH
6993: LD_VAR 0 2
6997: PUSH
6998: FOR_IN
6999: IFFALSE 7037
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7001: LD_VAR 0 1
7005: PPUSH
7006: LD_INT 81
7008: PUSH
7009: LD_INT 8
7011: PUSH
7012: EMPTY
7013: LIST
7014: LIST
7015: PPUSH
7016: CALL_OW 69
7020: PPUSH
7021: LD_VAR 0 1
7025: PPUSH
7026: CALL_OW 74
7030: PPUSH
7031: CALL_OW 115
7035: GO 6998
7037: POP
7038: POP
// until not tmp ;
7039: LD_VAR 0 2
7043: NOT
7044: IFFALSE 6960
// end ;
7046: PPOPN 4
7048: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
7049: LD_EXP 22
7053: NOT
7054: PUSH
7055: LD_EXP 15
7059: PUSH
7060: LD_INT 6
7062: GREATEREQUAL
7063: AND
7064: PUSH
7065: LD_OWVAR 67
7069: PUSH
7070: LD_INT 1
7072: GREATER
7073: AND
7074: IFFALSE 7607
7076: GO 7078
7078: DISABLE
7079: LD_INT 0
7081: PPUSH
7082: PPUSH
7083: PPUSH
// begin enable ;
7084: ENABLE
// tmp := [ ] ;
7085: LD_ADDR_VAR 0 3
7089: PUSH
7090: EMPTY
7091: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
7092: LD_ADDR_VAR 0 1
7096: PUSH
7097: DOUBLE
7098: LD_INT 1
7100: DEC
7101: ST_TO_ADDR
7102: LD_INT 4
7104: PUSH
7105: LD_INT 6
7107: PUSH
7108: LD_INT 7
7110: PUSH
7111: LD_INT 8
7113: PUSH
7114: EMPTY
7115: LIST
7116: LIST
7117: LIST
7118: LIST
7119: PUSH
7120: LD_OWVAR 67
7124: ARRAY
7125: PUSH
7126: FOR_TO
7127: IFFALSE 7287
// begin uc_side := 8 ;
7129: LD_ADDR_OWVAR 20
7133: PUSH
7134: LD_INT 8
7136: ST_TO_ADDR
// uc_nation := 2 ;
7137: LD_ADDR_OWVAR 21
7141: PUSH
7142: LD_INT 2
7144: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
7145: LD_INT 13
7147: PUSH
7148: LD_INT 14
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: PUSH
7155: LD_INT 1
7157: PPUSH
7158: LD_INT 2
7160: PPUSH
7161: CALL_OW 12
7165: ARRAY
7166: PPUSH
7167: LD_INT 1
7169: PPUSH
7170: LD_INT 5
7172: PPUSH
7173: LD_INT 27
7175: PUSH
7176: LD_INT 28
7178: PUSH
7179: LD_INT 26
7181: PUSH
7182: LD_INT 25
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: LIST
7189: LIST
7190: PUSH
7191: LD_INT 1
7193: PPUSH
7194: LD_INT 4
7196: PPUSH
7197: CALL_OW 12
7201: ARRAY
7202: PPUSH
7203: LD_INT 88
7205: PPUSH
7206: CALL 75220 0 5
// un := CreateVehicle ;
7210: LD_ADDR_VAR 0 2
7214: PUSH
7215: CALL_OW 45
7219: ST_TO_ADDR
// tmp := tmp ^ un ;
7220: LD_ADDR_VAR 0 3
7224: PUSH
7225: LD_VAR 0 3
7229: PUSH
7230: LD_VAR 0 2
7234: ADD
7235: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7236: LD_VAR 0 2
7240: PPUSH
7241: LD_INT 3
7243: PPUSH
7244: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7248: LD_VAR 0 2
7252: PPUSH
7253: LD_INT 30
7255: PPUSH
7256: LD_INT 0
7258: PPUSH
7259: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7263: LD_VAR 0 2
7267: PPUSH
7268: LD_INT 16
7270: PPUSH
7271: LD_INT 11
7273: PPUSH
7274: CALL_OW 111
// wait ( 0 0$2 ) ;
7278: LD_INT 70
7280: PPUSH
7281: CALL_OW 67
// end ;
7285: GO 7126
7287: POP
7288: POP
// for i = 1 to Difficulty do
7289: LD_ADDR_VAR 0 1
7293: PUSH
7294: DOUBLE
7295: LD_INT 1
7297: DEC
7298: ST_TO_ADDR
7299: LD_OWVAR 67
7303: PUSH
7304: FOR_TO
7305: IFFALSE 7434
// begin uc_side := 8 ;
7307: LD_ADDR_OWVAR 20
7311: PUSH
7312: LD_INT 8
7314: ST_TO_ADDR
// uc_nation := 2 ;
7315: LD_ADDR_OWVAR 21
7319: PUSH
7320: LD_INT 2
7322: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
7323: LD_INT 0
7325: PPUSH
7326: LD_INT 8
7328: PPUSH
7329: LD_INT 8
7331: PUSH
7332: LD_INT 8
7334: PUSH
7335: LD_INT 9
7337: PUSH
7338: LD_INT 10
7340: PUSH
7341: EMPTY
7342: LIST
7343: LIST
7344: LIST
7345: LIST
7346: PUSH
7347: LD_OWVAR 67
7351: ARRAY
7352: PPUSH
7353: CALL_OW 380
// un := CreateHuman ;
7357: LD_ADDR_VAR 0 2
7361: PUSH
7362: CALL_OW 44
7366: ST_TO_ADDR
// tmp := tmp ^ un ;
7367: LD_ADDR_VAR 0 3
7371: PUSH
7372: LD_VAR 0 3
7376: PUSH
7377: LD_VAR 0 2
7381: ADD
7382: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7383: LD_VAR 0 2
7387: PPUSH
7388: LD_INT 3
7390: PPUSH
7391: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7395: LD_VAR 0 2
7399: PPUSH
7400: LD_INT 30
7402: PPUSH
7403: LD_INT 0
7405: PPUSH
7406: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7410: LD_VAR 0 2
7414: PPUSH
7415: LD_INT 16
7417: PPUSH
7418: LD_INT 11
7420: PPUSH
7421: CALL_OW 111
// wait ( 0 0$2 ) ;
7425: LD_INT 70
7427: PPUSH
7428: CALL_OW 67
// end ;
7432: GO 7304
7434: POP
7435: POP
// repeat wait ( 0 0$1 ) ;
7436: LD_INT 35
7438: PPUSH
7439: CALL_OW 67
// if legionDestroyed then
7443: LD_EXP 22
7447: IFFALSE 7451
// exit ;
7449: GO 7607
// for i in tmp do
7451: LD_ADDR_VAR 0 1
7455: PUSH
7456: LD_VAR 0 3
7460: PUSH
7461: FOR_IN
7462: IFFALSE 7598
// begin if GetLives ( i ) > 250 then
7464: LD_VAR 0 1
7468: PPUSH
7469: CALL_OW 256
7473: PUSH
7474: LD_INT 250
7476: GREATER
7477: IFFALSE 7569
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
7479: LD_INT 81
7481: PUSH
7482: LD_INT 8
7484: PUSH
7485: EMPTY
7486: LIST
7487: LIST
7488: PUSH
7489: LD_INT 91
7491: PUSH
7492: LD_VAR 0 1
7496: PUSH
7497: LD_INT 10
7499: PUSH
7500: EMPTY
7501: LIST
7502: LIST
7503: LIST
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PPUSH
7509: CALL_OW 69
7513: NOT
7514: IFFALSE 7533
// ComAgressiveMove ( i , 67 , 110 ) else
7516: LD_VAR 0 1
7520: PPUSH
7521: LD_INT 67
7523: PPUSH
7524: LD_INT 110
7526: PPUSH
7527: CALL_OW 114
7531: GO 7567
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7533: LD_VAR 0 1
7537: PPUSH
7538: LD_INT 81
7540: PUSH
7541: LD_INT 8
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: PPUSH
7548: CALL_OW 69
7552: PPUSH
7553: LD_VAR 0 1
7557: PPUSH
7558: CALL_OW 74
7562: PPUSH
7563: CALL_OW 115
// end else
7567: GO 7596
// if IsDead ( i ) then
7569: LD_VAR 0 1
7573: PPUSH
7574: CALL_OW 301
7578: IFFALSE 7596
// tmp := tmp diff i ;
7580: LD_ADDR_VAR 0 3
7584: PUSH
7585: LD_VAR 0 3
7589: PUSH
7590: LD_VAR 0 1
7594: DIFF
7595: ST_TO_ADDR
// end ;
7596: GO 7461
7598: POP
7599: POP
// until not tmp ;
7600: LD_VAR 0 3
7604: NOT
7605: IFFALSE 7436
// end ; end_of_file
7607: PPOPN 3
7609: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
7610: LD_INT 0
7612: PPUSH
7613: PPUSH
7614: PPUSH
7615: PPUSH
7616: PPUSH
7617: PPUSH
7618: PPUSH
7619: PPUSH
7620: PPUSH
7621: PPUSH
// side := 3 ;
7622: LD_ADDR_VAR 0 6
7626: PUSH
7627: LD_INT 3
7629: ST_TO_ADDR
// uc_side := side ;
7630: LD_ADDR_OWVAR 20
7634: PUSH
7635: LD_VAR 0 6
7639: ST_TO_ADDR
// uc_nation := 3 ;
7640: LD_ADDR_OWVAR 21
7644: PUSH
7645: LD_INT 3
7647: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7648: LD_ADDR_VAR 0 2
7652: PUSH
7653: LD_INT 22
7655: PUSH
7656: LD_VAR 0 6
7660: PUSH
7661: EMPTY
7662: LIST
7663: LIST
7664: PUSH
7665: LD_INT 21
7667: PUSH
7668: LD_INT 3
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: PUSH
7675: EMPTY
7676: LIST
7677: LIST
7678: PPUSH
7679: CALL_OW 69
7683: PUSH
7684: FOR_IN
7685: IFFALSE 7701
// SetBLevel ( i , 10 ) ;
7687: LD_VAR 0 2
7691: PPUSH
7692: LD_INT 10
7694: PPUSH
7695: CALL_OW 241
7699: GO 7684
7701: POP
7702: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7703: LD_ADDR_VAR 0 10
7707: PUSH
7708: LD_INT 22
7710: PUSH
7711: LD_VAR 0 6
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: PUSH
7720: LD_INT 30
7722: PUSH
7723: LD_INT 34
7725: PUSH
7726: EMPTY
7727: LIST
7728: LIST
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: PPUSH
7734: CALL_OW 69
7738: ST_TO_ADDR
// if teleport then
7739: LD_VAR 0 10
7743: IFFALSE 7764
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7745: LD_VAR 0 10
7749: PUSH
7750: LD_INT 1
7752: ARRAY
7753: PPUSH
7754: LD_INT 123
7756: PPUSH
7757: LD_INT 122
7759: PPUSH
7760: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7764: LD_ADDR_EXP 68
7768: PUSH
7769: LD_STRING Platonov
7771: PPUSH
7772: CALL_OW 25
7776: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7777: LD_ADDR_EXP 69
7781: PUSH
7782: LD_STRING Kovalyuk
7784: PPUSH
7785: CALL_OW 25
7789: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7790: LD_ADDR_EXP 71
7794: PUSH
7795: LD_STRING Yakotich
7797: PPUSH
7798: LD_EXP 1
7802: NOT
7803: PPUSH
7804: LD_STRING 09_
7806: PPUSH
7807: CALL 70296 0 3
7811: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7812: LD_ADDR_EXP 70
7816: PUSH
7817: LD_STRING Bystrov
7819: PPUSH
7820: CALL_OW 25
7824: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7825: LD_ADDR_EXP 72
7829: PUSH
7830: LD_STRING Gleb
7832: PPUSH
7833: CALL_OW 25
7837: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7838: LD_STRING 03_Cornel
7840: PPUSH
7841: CALL_OW 28
7845: IFFALSE 7893
// begin Bierezov := NewCharacter ( Mikhail ) ;
7847: LD_ADDR_EXP 73
7851: PUSH
7852: LD_STRING Mikhail
7854: PPUSH
7855: CALL_OW 25
7859: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7860: LD_EXP 73
7864: PPUSH
7865: LD_INT 197
7867: PPUSH
7868: LD_INT 111
7870: PPUSH
7871: LD_INT 9
7873: PPUSH
7874: LD_INT 0
7876: PPUSH
7877: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7881: LD_EXP 73
7885: PPUSH
7886: LD_INT 3
7888: PPUSH
7889: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7893: LD_EXP 68
7897: PPUSH
7898: LD_INT 126
7900: PPUSH
7901: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7905: LD_EXP 69
7909: PPUSH
7910: LD_INT 134
7912: PPUSH
7913: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7917: LD_EXP 71
7921: PPUSH
7922: LD_INT 197
7924: PPUSH
7925: LD_INT 111
7927: PPUSH
7928: LD_INT 9
7930: PPUSH
7931: LD_INT 0
7933: PPUSH
7934: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7938: LD_EXP 70
7942: PPUSH
7943: LD_INT 197
7945: PPUSH
7946: LD_INT 111
7948: PPUSH
7949: LD_INT 9
7951: PPUSH
7952: LD_INT 0
7954: PPUSH
7955: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7959: LD_EXP 72
7963: PPUSH
7964: LD_INT 197
7966: PPUSH
7967: LD_INT 111
7969: PPUSH
7970: LD_INT 9
7972: PPUSH
7973: LD_INT 0
7975: PPUSH
7976: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 12 , 6 ] ) ;
7980: LD_ADDR_VAR 0 5
7984: PUSH
7985: LD_INT 126
7987: PPUSH
7988: LD_INT 4
7990: PPUSH
7991: LD_STRING zhukov
7993: PPUSH
7994: LD_INT 9
7996: PUSH
7997: LD_INT 10
7999: PUSH
8000: LD_INT 10
8002: PUSH
8003: LD_INT 10
8005: PUSH
8006: EMPTY
8007: LIST
8008: LIST
8009: LIST
8010: LIST
8011: PUSH
8012: LD_OWVAR 67
8016: ARRAY
8017: PPUSH
8018: LD_INT 90000
8020: PUSH
8021: LD_INT 1000
8023: PUSH
8024: LD_INT 300
8026: PUSH
8027: EMPTY
8028: LIST
8029: LIST
8030: LIST
8031: PPUSH
8032: LD_INT 18
8034: PUSH
8035: LD_INT 8
8037: PUSH
8038: LD_INT 12
8040: PUSH
8041: LD_INT 6
8043: PUSH
8044: EMPTY
8045: LIST
8046: LIST
8047: LIST
8048: LIST
8049: PPUSH
8050: CALL 79041 0 6
8054: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Bystrov , Gleb , Bierezov ] ) ;
8055: LD_ADDR_EXP 102
8059: PUSH
8060: LD_EXP 102
8064: PPUSH
8065: LD_INT 2
8067: PPUSH
8068: LD_VAR 0 5
8072: PUSH
8073: LD_EXP 71
8077: PUSH
8078: LD_EXP 70
8082: PUSH
8083: LD_EXP 72
8087: PUSH
8088: LD_EXP 73
8092: PUSH
8093: EMPTY
8094: LIST
8095: LIST
8096: LIST
8097: LIST
8098: UNION
8099: PPUSH
8100: CALL_OW 1
8104: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8105: LD_ADDR_VAR 0 4
8109: PUSH
8110: LD_INT 267
8112: PPUSH
8113: CALL_OW 274
8117: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8118: LD_VAR 0 4
8122: PPUSH
8123: LD_INT 1
8125: PPUSH
8126: LD_INT 5000
8128: PPUSH
8129: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8133: LD_VAR 0 4
8137: PPUSH
8138: LD_INT 2
8140: PPUSH
8141: LD_INT 200
8143: PPUSH
8144: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8148: LD_VAR 0 4
8152: PPUSH
8153: LD_INT 3
8155: PPUSH
8156: LD_INT 200
8158: PPUSH
8159: CALL_OW 277
// for i := 1 to 6 do
8163: LD_ADDR_VAR 0 2
8167: PUSH
8168: DOUBLE
8169: LD_INT 1
8171: DEC
8172: ST_TO_ADDR
8173: LD_INT 6
8175: PUSH
8176: FOR_TO
8177: IFFALSE 8260
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
8179: LD_INT 0
8181: PPUSH
8182: LD_INT 8
8184: PUSH
8185: LD_INT 9
8187: PUSH
8188: LD_INT 10
8190: PUSH
8191: LD_INT 10
8193: PUSH
8194: EMPTY
8195: LIST
8196: LIST
8197: LIST
8198: LIST
8199: PUSH
8200: LD_OWVAR 67
8204: ARRAY
8205: PPUSH
8206: CALL_OW 381
// un := CreateHuman ;
8210: LD_ADDR_VAR 0 8
8214: PUSH
8215: CALL_OW 44
8219: ST_TO_ADDR
// if i mod 2 = 0 then
8220: LD_VAR 0 2
8224: PUSH
8225: LD_INT 2
8227: MOD
8228: PUSH
8229: LD_INT 0
8231: EQUAL
8232: IFFALSE 8246
// SetClass ( un , class_bazooker ) ;
8234: LD_VAR 0 8
8238: PPUSH
8239: LD_INT 9
8241: PPUSH
8242: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
8246: LD_VAR 0 8
8250: PPUSH
8251: LD_INT 460
8253: PPUSH
8254: CALL_OW 52
// end ;
8258: GO 8176
8260: POP
8261: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
8262: LD_INT 21
8264: PPUSH
8265: LD_INT 3
8267: PPUSH
8268: LD_INT 3
8270: PPUSH
8271: LD_INT 52
8273: PPUSH
8274: LD_INT 100
8276: PPUSH
8277: CALL 75220 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
8281: CALL_OW 45
8285: PPUSH
8286: LD_INT 259
8288: PPUSH
8289: LD_INT 145
8291: PPUSH
8292: LD_INT 3
8294: PPUSH
8295: LD_INT 0
8297: PPUSH
8298: CALL 110231 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
8302: CALL_OW 45
8306: PPUSH
8307: LD_INT 245
8309: PPUSH
8310: LD_INT 139
8312: PPUSH
8313: LD_INT 3
8315: PPUSH
8316: LD_INT 0
8318: PPUSH
8319: CALL 110231 0 5
// behemoths := [ ] ;
8323: LD_ADDR_EXP 76
8327: PUSH
8328: EMPTY
8329: ST_TO_ADDR
// behemothBuilders := [ ] ;
8330: LD_ADDR_EXP 77
8334: PUSH
8335: EMPTY
8336: ST_TO_ADDR
// if Kovalyuk then
8337: LD_EXP 69
8341: IFFALSE 8363
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
8343: LD_ADDR_EXP 77
8347: PUSH
8348: LD_EXP 77
8352: PPUSH
8353: LD_EXP 69
8357: PPUSH
8358: CALL 108091 0 2
8362: ST_TO_ADDR
// end ;
8363: LD_VAR 0 1
8367: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8368: LD_INT 0
8370: PPUSH
8371: PPUSH
8372: PPUSH
8373: PPUSH
8374: PPUSH
// xy := [ [ 221 , 154 ] , [ 223 , 149 ] , [ 228 , 147 ] , [ 232 , 155 ] ] ;
8375: LD_ADDR_VAR 0 4
8379: PUSH
8380: LD_INT 221
8382: PUSH
8383: LD_INT 154
8385: PUSH
8386: EMPTY
8387: LIST
8388: LIST
8389: PUSH
8390: LD_INT 223
8392: PUSH
8393: LD_INT 149
8395: PUSH
8396: EMPTY
8397: LIST
8398: LIST
8399: PUSH
8400: LD_INT 228
8402: PUSH
8403: LD_INT 147
8405: PUSH
8406: EMPTY
8407: LIST
8408: LIST
8409: PUSH
8410: LD_INT 232
8412: PUSH
8413: LD_INT 155
8415: PUSH
8416: EMPTY
8417: LIST
8418: LIST
8419: PUSH
8420: EMPTY
8421: LIST
8422: LIST
8423: LIST
8424: LIST
8425: ST_TO_ADDR
// if not behemothBuilders then
8426: LD_EXP 77
8430: NOT
8431: IFFALSE 8435
// exit ;
8433: GO 8566
// j := 1 ;
8435: LD_ADDR_VAR 0 3
8439: PUSH
8440: LD_INT 1
8442: ST_TO_ADDR
// for i in behemothBuilders do
8443: LD_ADDR_VAR 0 2
8447: PUSH
8448: LD_EXP 77
8452: PUSH
8453: FOR_IN
8454: IFFALSE 8564
// begin if GetClass ( i ) <> class_mechanic then
8456: LD_VAR 0 2
8460: PPUSH
8461: CALL_OW 257
8465: PUSH
8466: LD_INT 3
8468: NONEQUAL
8469: IFFALSE 8483
// SetClass ( i , class_mechanic ) ;
8471: LD_VAR 0 2
8475: PPUSH
8476: LD_INT 3
8478: PPUSH
8479: CALL_OW 336
// if IsInUnit ( i ) then
8483: LD_VAR 0 2
8487: PPUSH
8488: CALL_OW 310
8492: IFFALSE 8503
// ComExitBuilding ( i ) ;
8494: LD_VAR 0 2
8498: PPUSH
8499: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8503: LD_VAR 0 2
8507: PPUSH
8508: LD_INT 37
8510: PPUSH
8511: LD_VAR 0 4
8515: PUSH
8516: LD_VAR 0 3
8520: ARRAY
8521: PUSH
8522: LD_INT 1
8524: ARRAY
8525: PPUSH
8526: LD_VAR 0 4
8530: PUSH
8531: LD_VAR 0 3
8535: ARRAY
8536: PUSH
8537: LD_INT 2
8539: ARRAY
8540: PPUSH
8541: LD_INT 0
8543: PPUSH
8544: CALL_OW 230
// j := j + 1 ;
8548: LD_ADDR_VAR 0 3
8552: PUSH
8553: LD_VAR 0 3
8557: PUSH
8558: LD_INT 1
8560: PLUS
8561: ST_TO_ADDR
// end ;
8562: GO 8453
8564: POP
8565: POP
// end ;
8566: LD_VAR 0 1
8570: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
8571: LD_INT 24
8573: PPUSH
8574: LD_INT 30
8576: PUSH
8577: LD_INT 37
8579: PUSH
8580: EMPTY
8581: LIST
8582: LIST
8583: PPUSH
8584: CALL_OW 70
8588: IFFALSE 8601
8590: GO 8592
8592: DISABLE
// behemothUnderConstruct := true ;
8593: LD_ADDR_EXP 26
8597: PUSH
8598: LD_INT 1
8600: ST_TO_ADDR
8601: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8602: LD_INT 3
8604: PPUSH
8605: CALL 108152 0 1
8609: PUSH
8610: LD_INT 22
8612: PUSH
8613: LD_INT 3
8615: PUSH
8616: EMPTY
8617: LIST
8618: LIST
8619: PUSH
8620: LD_INT 30
8622: PUSH
8623: LD_INT 37
8625: PUSH
8626: EMPTY
8627: LIST
8628: LIST
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: PPUSH
8634: CALL_OW 69
8638: NOT
8639: AND
8640: IFFALSE 8826
8642: GO 8644
8644: DISABLE
8645: LD_INT 0
8647: PPUSH
8648: PPUSH
// begin enable ;
8649: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8650: LD_ADDR_VAR 0 2
8654: PUSH
8655: LD_INT 3
8657: PPUSH
8658: CALL 108152 0 1
8662: ST_TO_ADDR
// for i in tmp do
8663: LD_ADDR_VAR 0 1
8667: PUSH
8668: LD_VAR 0 2
8672: PUSH
8673: FOR_IN
8674: IFFALSE 8824
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8676: LD_VAR 0 1
8680: PPUSH
8681: LD_INT 9
8683: PPUSH
8684: CALL_OW 308
8688: PUSH
8689: LD_VAR 0 1
8693: PPUSH
8694: CALL_OW 110
8698: PUSH
8699: LD_INT 2
8701: EQUAL
8702: NOT
8703: AND
8704: IFFALSE 8718
// SetTag ( i , 2 ) ;
8706: LD_VAR 0 1
8710: PPUSH
8711: LD_INT 2
8713: PPUSH
8714: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8718: LD_INT 81
8720: PUSH
8721: LD_INT 3
8723: PUSH
8724: EMPTY
8725: LIST
8726: LIST
8727: PUSH
8728: LD_INT 91
8730: PUSH
8731: LD_VAR 0 1
8735: PUSH
8736: LD_INT 12
8738: PUSH
8739: EMPTY
8740: LIST
8741: LIST
8742: LIST
8743: PUSH
8744: EMPTY
8745: LIST
8746: LIST
8747: PPUSH
8748: CALL_OW 69
8752: NOT
8753: PUSH
8754: LD_VAR 0 1
8758: PPUSH
8759: CALL_OW 110
8763: PUSH
8764: LD_INT 2
8766: EQUAL
8767: NOT
8768: AND
8769: IFFALSE 8788
// ComAgressiveMove ( i , 64 , 93 ) else
8771: LD_VAR 0 1
8775: PPUSH
8776: LD_INT 64
8778: PPUSH
8779: LD_INT 93
8781: PPUSH
8782: CALL_OW 114
8786: GO 8822
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8788: LD_VAR 0 1
8792: PPUSH
8793: LD_INT 81
8795: PUSH
8796: LD_INT 3
8798: PUSH
8799: EMPTY
8800: LIST
8801: LIST
8802: PPUSH
8803: CALL_OW 69
8807: PPUSH
8808: LD_VAR 0 1
8812: PPUSH
8813: CALL_OW 74
8817: PPUSH
8818: CALL_OW 115
// end ;
8822: GO 8673
8824: POP
8825: POP
// end ;
8826: PPOPN 2
8828: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8829: LD_INT 0
8831: PPUSH
8832: PPUSH
8833: PPUSH
// result := [ ] ;
8834: LD_ADDR_VAR 0 2
8838: PUSH
8839: EMPTY
8840: ST_TO_ADDR
// uc_side := 6 ;
8841: LD_ADDR_OWVAR 20
8845: PUSH
8846: LD_INT 6
8848: ST_TO_ADDR
// uc_nation := 3 ;
8849: LD_ADDR_OWVAR 21
8853: PUSH
8854: LD_INT 3
8856: ST_TO_ADDR
// case strength of 1 :
8857: LD_VAR 0 1
8861: PUSH
8862: LD_INT 1
8864: DOUBLE
8865: EQUAL
8866: IFTRUE 8870
8868: GO 9012
8870: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8871: LD_ADDR_VAR 0 3
8875: PUSH
8876: DOUBLE
8877: LD_INT 1
8879: DEC
8880: ST_TO_ADDR
8881: LD_INT 4
8883: PUSH
8884: LD_INT 5
8886: PUSH
8887: LD_INT 6
8889: PUSH
8890: LD_INT 7
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: LIST
8897: LIST
8898: PUSH
8899: LD_OWVAR 67
8903: ARRAY
8904: PUSH
8905: FOR_TO
8906: IFFALSE 9008
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8908: LD_INT 22
8910: PUSH
8911: LD_INT 24
8913: PUSH
8914: EMPTY
8915: LIST
8916: LIST
8917: PUSH
8918: LD_VAR 0 3
8922: PUSH
8923: LD_INT 2
8925: MOD
8926: PUSH
8927: LD_INT 1
8929: PLUS
8930: ARRAY
8931: PPUSH
8932: LD_INT 1
8934: PUSH
8935: LD_INT 3
8937: PUSH
8938: EMPTY
8939: LIST
8940: LIST
8941: PUSH
8942: LD_INT 1
8944: PPUSH
8945: LD_INT 2
8947: PPUSH
8948: CALL_OW 12
8952: ARRAY
8953: PPUSH
8954: LD_INT 3
8956: PPUSH
8957: LD_INT 43
8959: PUSH
8960: LD_INT 44
8962: PUSH
8963: LD_INT 45
8965: PUSH
8966: EMPTY
8967: LIST
8968: LIST
8969: LIST
8970: PUSH
8971: LD_INT 1
8973: PPUSH
8974: LD_INT 3
8976: PPUSH
8977: CALL_OW 12
8981: ARRAY
8982: PPUSH
8983: LD_INT 80
8985: PPUSH
8986: CALL 75220 0 5
// result := result union CreateVehicle ;
8990: LD_ADDR_VAR 0 2
8994: PUSH
8995: LD_VAR 0 2
8999: PUSH
9000: CALL_OW 45
9004: UNION
9005: ST_TO_ADDR
// end ;
9006: GO 8905
9008: POP
9009: POP
// end ; 2 :
9010: GO 10007
9012: LD_INT 2
9014: DOUBLE
9015: EQUAL
9016: IFTRUE 9020
9018: GO 9188
9020: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
9021: LD_ADDR_VAR 0 3
9025: PUSH
9026: DOUBLE
9027: LD_INT 1
9029: DEC
9030: ST_TO_ADDR
9031: LD_INT 5
9033: PUSH
9034: LD_INT 6
9036: PUSH
9037: LD_INT 7
9039: PUSH
9040: LD_INT 8
9042: PUSH
9043: EMPTY
9044: LIST
9045: LIST
9046: LIST
9047: LIST
9048: PUSH
9049: LD_OWVAR 67
9053: ARRAY
9054: PUSH
9055: FOR_TO
9056: IFFALSE 9184
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
9058: LD_INT 22
9060: PUSH
9061: LD_INT 24
9063: PUSH
9064: LD_INT 24
9066: PUSH
9067: EMPTY
9068: LIST
9069: LIST
9070: LIST
9071: PUSH
9072: LD_VAR 0 3
9076: PUSH
9077: LD_INT 3
9079: MOD
9080: PUSH
9081: LD_INT 1
9083: PLUS
9084: ARRAY
9085: PPUSH
9086: LD_INT 1
9088: PUSH
9089: LD_INT 3
9091: PUSH
9092: EMPTY
9093: LIST
9094: LIST
9095: PUSH
9096: LD_INT 1
9098: PPUSH
9099: LD_INT 2
9101: PPUSH
9102: CALL_OW 12
9106: ARRAY
9107: PPUSH
9108: LD_INT 3
9110: PPUSH
9111: LD_INT 43
9113: PUSH
9114: LD_INT 44
9116: PUSH
9117: LD_INT 45
9119: PUSH
9120: LD_INT 44
9122: PUSH
9123: LD_INT 46
9125: PUSH
9126: LD_INT 46
9128: PUSH
9129: LD_INT 49
9131: PUSH
9132: LD_INT 49
9134: PUSH
9135: EMPTY
9136: LIST
9137: LIST
9138: LIST
9139: LIST
9140: LIST
9141: LIST
9142: LIST
9143: LIST
9144: PUSH
9145: LD_VAR 0 3
9149: PUSH
9150: LD_INT 8
9152: MOD
9153: PUSH
9154: LD_INT 1
9156: PLUS
9157: ARRAY
9158: PPUSH
9159: LD_INT 80
9161: PPUSH
9162: CALL 75220 0 5
// result := result union CreateVehicle ;
9166: LD_ADDR_VAR 0 2
9170: PUSH
9171: LD_VAR 0 2
9175: PUSH
9176: CALL_OW 45
9180: UNION
9181: ST_TO_ADDR
// end ;
9182: GO 9055
9184: POP
9185: POP
// end ; 3 :
9186: GO 10007
9188: LD_INT 3
9190: DOUBLE
9191: EQUAL
9192: IFTRUE 9196
9194: GO 9368
9196: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
9197: LD_ADDR_VAR 0 3
9201: PUSH
9202: DOUBLE
9203: LD_INT 1
9205: DEC
9206: ST_TO_ADDR
9207: LD_INT 6
9209: PUSH
9210: LD_INT 7
9212: PUSH
9213: LD_INT 8
9215: PUSH
9216: LD_INT 9
9218: PUSH
9219: EMPTY
9220: LIST
9221: LIST
9222: LIST
9223: LIST
9224: PUSH
9225: LD_OWVAR 67
9229: ARRAY
9230: PUSH
9231: FOR_TO
9232: IFFALSE 9364
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9234: LD_INT 22
9236: PUSH
9237: LD_INT 24
9239: PUSH
9240: LD_INT 24
9242: PUSH
9243: EMPTY
9244: LIST
9245: LIST
9246: LIST
9247: PUSH
9248: LD_VAR 0 3
9252: PUSH
9253: LD_INT 3
9255: MOD
9256: PUSH
9257: LD_INT 1
9259: PLUS
9260: ARRAY
9261: PPUSH
9262: LD_INT 1
9264: PUSH
9265: LD_INT 3
9267: PUSH
9268: EMPTY
9269: LIST
9270: LIST
9271: PUSH
9272: LD_INT 1
9274: PPUSH
9275: LD_INT 2
9277: PPUSH
9278: CALL_OW 12
9282: ARRAY
9283: PPUSH
9284: LD_INT 3
9286: PPUSH
9287: LD_INT 43
9289: PUSH
9290: LD_INT 47
9292: PUSH
9293: LD_INT 45
9295: PUSH
9296: LD_INT 45
9298: PUSH
9299: LD_INT 46
9301: PUSH
9302: LD_INT 46
9304: PUSH
9305: LD_INT 49
9307: PUSH
9308: LD_INT 49
9310: PUSH
9311: LD_INT 49
9313: PUSH
9314: EMPTY
9315: LIST
9316: LIST
9317: LIST
9318: LIST
9319: LIST
9320: LIST
9321: LIST
9322: LIST
9323: LIST
9324: PUSH
9325: LD_VAR 0 3
9329: PUSH
9330: LD_INT 9
9332: MOD
9333: PUSH
9334: LD_INT 1
9336: PLUS
9337: ARRAY
9338: PPUSH
9339: LD_INT 80
9341: PPUSH
9342: CALL 75220 0 5
// result := result union CreateVehicle ;
9346: LD_ADDR_VAR 0 2
9350: PUSH
9351: LD_VAR 0 2
9355: PUSH
9356: CALL_OW 45
9360: UNION
9361: ST_TO_ADDR
// end ;
9362: GO 9231
9364: POP
9365: POP
// end ; 4 :
9366: GO 10007
9368: LD_INT 4
9370: DOUBLE
9371: EQUAL
9372: IFTRUE 9376
9374: GO 10006
9376: POP
// begin uc_nation := 3 ;
9377: LD_ADDR_OWVAR 21
9381: PUSH
9382: LD_INT 3
9384: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
9385: LD_ADDR_VAR 0 3
9389: PUSH
9390: DOUBLE
9391: LD_INT 1
9393: DEC
9394: ST_TO_ADDR
9395: LD_INT 6
9397: PUSH
9398: LD_INT 8
9400: PUSH
9401: LD_INT 9
9403: PUSH
9404: LD_INT 10
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: LIST
9411: LIST
9412: PUSH
9413: LD_OWVAR 67
9417: ARRAY
9418: PUSH
9419: FOR_TO
9420: IFFALSE 9552
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9422: LD_INT 22
9424: PUSH
9425: LD_INT 24
9427: PUSH
9428: LD_INT 24
9430: PUSH
9431: EMPTY
9432: LIST
9433: LIST
9434: LIST
9435: PUSH
9436: LD_VAR 0 3
9440: PUSH
9441: LD_INT 3
9443: MOD
9444: PUSH
9445: LD_INT 1
9447: PLUS
9448: ARRAY
9449: PPUSH
9450: LD_INT 1
9452: PUSH
9453: LD_INT 3
9455: PUSH
9456: EMPTY
9457: LIST
9458: LIST
9459: PUSH
9460: LD_INT 1
9462: PPUSH
9463: LD_INT 2
9465: PPUSH
9466: CALL_OW 12
9470: ARRAY
9471: PPUSH
9472: LD_INT 3
9474: PPUSH
9475: LD_INT 45
9477: PUSH
9478: LD_INT 47
9480: PUSH
9481: LD_INT 47
9483: PUSH
9484: LD_INT 45
9486: PUSH
9487: LD_INT 46
9489: PUSH
9490: LD_INT 46
9492: PUSH
9493: LD_INT 49
9495: PUSH
9496: LD_INT 49
9498: PUSH
9499: LD_INT 49
9501: PUSH
9502: EMPTY
9503: LIST
9504: LIST
9505: LIST
9506: LIST
9507: LIST
9508: LIST
9509: LIST
9510: LIST
9511: LIST
9512: PUSH
9513: LD_VAR 0 3
9517: PUSH
9518: LD_INT 9
9520: MOD
9521: PUSH
9522: LD_INT 1
9524: PLUS
9525: ARRAY
9526: PPUSH
9527: LD_INT 80
9529: PPUSH
9530: CALL 75220 0 5
// result := result union CreateVehicle ;
9534: LD_ADDR_VAR 0 2
9538: PUSH
9539: LD_VAR 0 2
9543: PUSH
9544: CALL_OW 45
9548: UNION
9549: ST_TO_ADDR
// end ;
9550: GO 9419
9552: POP
9553: POP
// if not KappaStatus then
9554: LD_EXP 2
9558: NOT
9559: IFFALSE 9794
// begin uc_nation := 1 ;
9561: LD_ADDR_OWVAR 21
9565: PUSH
9566: LD_INT 1
9568: ST_TO_ADDR
// for i = 1 to 3 do
9569: LD_ADDR_VAR 0 3
9573: PUSH
9574: DOUBLE
9575: LD_INT 1
9577: DEC
9578: ST_TO_ADDR
9579: LD_INT 3
9581: PUSH
9582: FOR_TO
9583: IFFALSE 9719
// begin j := rand ( 0 , 1 ) ;
9585: LD_ADDR_VAR 0 4
9589: PUSH
9590: LD_INT 0
9592: PPUSH
9593: LD_INT 1
9595: PPUSH
9596: CALL_OW 12
9600: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9601: LD_INT 3
9603: PUSH
9604: LD_INT 5
9606: PUSH
9607: LD_INT 5
9609: PUSH
9610: LD_INT 4
9612: PUSH
9613: EMPTY
9614: LIST
9615: LIST
9616: LIST
9617: LIST
9618: PUSH
9619: LD_VAR 0 4
9623: PUSH
9624: LD_INT 1
9626: PPUSH
9627: LD_INT 3
9629: PPUSH
9630: CALL_OW 12
9634: PLUS
9635: ARRAY
9636: PPUSH
9637: LD_INT 1
9639: PUSH
9640: LD_INT 3
9642: PUSH
9643: EMPTY
9644: LIST
9645: LIST
9646: PUSH
9647: LD_INT 1
9649: PPUSH
9650: LD_INT 2
9652: PPUSH
9653: CALL_OW 12
9657: ARRAY
9658: PPUSH
9659: LD_INT 3
9661: PPUSH
9662: LD_INT 9
9664: PUSH
9665: LD_INT 7
9667: PUSH
9668: LD_INT 6
9670: PUSH
9671: EMPTY
9672: LIST
9673: LIST
9674: LIST
9675: PUSH
9676: LD_VAR 0 4
9680: PUSH
9681: LD_INT 1
9683: PPUSH
9684: LD_INT 2
9686: PPUSH
9687: CALL_OW 12
9691: PLUS
9692: ARRAY
9693: PPUSH
9694: LD_INT 85
9696: PPUSH
9697: CALL 75220 0 5
// result := result union CreateVehicle ;
9701: LD_ADDR_VAR 0 2
9705: PUSH
9706: LD_VAR 0 2
9710: PUSH
9711: CALL_OW 45
9715: UNION
9716: ST_TO_ADDR
// end ;
9717: GO 9582
9719: POP
9720: POP
// if vsevolodFirstAttack then
9721: LD_EXP 24
9725: IFFALSE 9792
// begin vsevolodFirstAttack := false ;
9727: LD_ADDR_EXP 24
9731: PUSH
9732: LD_INT 0
9734: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9735: LD_INT 5
9737: PPUSH
9738: LD_INT 3
9740: PPUSH
9741: LD_INT 1
9743: PPUSH
9744: LD_INT 6
9746: PPUSH
9747: LD_INT 100
9749: PPUSH
9750: CALL 75220 0 5
// sewiVeh := CreateVehicle ;
9754: LD_ADDR_EXP 75
9758: PUSH
9759: CALL_OW 45
9763: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9764: LD_EXP 75
9768: PPUSH
9769: LD_INT 1
9771: PPUSH
9772: CALL_OW 242
// result := result union sewiVeh ;
9776: LD_ADDR_VAR 0 2
9780: PUSH
9781: LD_VAR 0 2
9785: PUSH
9786: LD_EXP 75
9790: UNION
9791: ST_TO_ADDR
// end ; end else
9792: GO 10004
// if vsevolodFirstAttack then
9794: LD_EXP 24
9798: IFFALSE 10004
// begin vsevolodFirstAttack := false ;
9800: LD_ADDR_EXP 24
9804: PUSH
9805: LD_INT 0
9807: ST_TO_ADDR
// uc_nation := 3 ;
9808: LD_ADDR_OWVAR 21
9812: PUSH
9813: LD_INT 3
9815: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9816: LD_ADDR_VAR 0 3
9820: PUSH
9821: DOUBLE
9822: LD_INT 1
9824: DEC
9825: ST_TO_ADDR
9826: LD_INT 2
9828: PUSH
9829: LD_OWVAR 67
9833: PLUS
9834: PUSH
9835: FOR_TO
9836: IFFALSE 9944
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9838: LD_INT 22
9840: PUSH
9841: LD_INT 24
9843: PUSH
9844: LD_INT 24
9846: PUSH
9847: EMPTY
9848: LIST
9849: LIST
9850: LIST
9851: PUSH
9852: LD_VAR 0 3
9856: PUSH
9857: LD_INT 3
9859: MOD
9860: PUSH
9861: LD_INT 1
9863: PLUS
9864: ARRAY
9865: PPUSH
9866: LD_INT 1
9868: PUSH
9869: LD_INT 3
9871: PUSH
9872: EMPTY
9873: LIST
9874: LIST
9875: PUSH
9876: LD_INT 1
9878: PPUSH
9879: LD_INT 2
9881: PPUSH
9882: CALL_OW 12
9886: ARRAY
9887: PPUSH
9888: LD_INT 1
9890: PPUSH
9891: LD_INT 45
9893: PUSH
9894: LD_INT 47
9896: PUSH
9897: LD_INT 47
9899: PUSH
9900: EMPTY
9901: LIST
9902: LIST
9903: LIST
9904: PUSH
9905: LD_VAR 0 3
9909: PUSH
9910: LD_INT 3
9912: MOD
9913: PUSH
9914: LD_INT 1
9916: PLUS
9917: ARRAY
9918: PPUSH
9919: LD_INT 80
9921: PPUSH
9922: CALL 75220 0 5
// result := result union CreateVehicle ;
9926: LD_ADDR_VAR 0 2
9930: PUSH
9931: LD_VAR 0 2
9935: PUSH
9936: CALL_OW 45
9940: UNION
9941: ST_TO_ADDR
// end ;
9942: GO 9835
9944: POP
9945: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9946: LD_INT 24
9948: PPUSH
9949: LD_INT 3
9951: PPUSH
9952: LD_INT 1
9954: PPUSH
9955: LD_INT 47
9957: PPUSH
9958: LD_INT 100
9960: PPUSH
9961: CALL 75220 0 5
// sewiVeh := CreateVehicle ;
9965: LD_ADDR_EXP 75
9969: PUSH
9970: CALL_OW 45
9974: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9975: LD_EXP 75
9979: PPUSH
9980: LD_INT 6
9982: NEG
9983: PPUSH
9984: CALL_OW 242
// result := result union sewiVeh ;
9988: LD_ADDR_VAR 0 2
9992: PUSH
9993: LD_VAR 0 2
9997: PUSH
9998: LD_EXP 75
10002: UNION
10003: ST_TO_ADDR
// end ; end ; end ;
10004: GO 10007
10006: POP
// end ;
10007: LD_VAR 0 2
10011: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
10012: LD_EXP 16
10016: IFFALSE 10773
10018: GO 10020
10020: DISABLE
10021: LD_INT 0
10023: PPUSH
10024: PPUSH
10025: PPUSH
10026: PPUSH
10027: PPUSH
10028: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
10029: LD_ADDR_VAR 0 4
10033: PUSH
10034: LD_INT 11
10036: PUSH
10037: LD_INT 12
10039: PUSH
10040: EMPTY
10041: LIST
10042: LIST
10043: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
10044: LD_ADDR_VAR 0 3
10048: PUSH
10049: LD_INT 11550
10051: PUSH
10052: LD_INT 10150
10054: PUSH
10055: LD_INT 9800
10057: PUSH
10058: LD_INT 9450
10060: PUSH
10061: EMPTY
10062: LIST
10063: LIST
10064: LIST
10065: LIST
10066: PUSH
10067: LD_OWVAR 67
10071: ARRAY
10072: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
10073: LD_ADDR_VAR 0 6
10077: PUSH
10078: LD_INT 70
10080: PUSH
10081: LD_INT 118
10083: PUSH
10084: EMPTY
10085: LIST
10086: LIST
10087: PUSH
10088: LD_INT 78
10090: PUSH
10091: LD_INT 31
10093: PUSH
10094: EMPTY
10095: LIST
10096: LIST
10097: PUSH
10098: EMPTY
10099: LIST
10100: LIST
10101: ST_TO_ADDR
// repeat if missionStage = 2 then
10102: LD_EXP 15
10106: PUSH
10107: LD_INT 2
10109: EQUAL
10110: IFFALSE 10121
// wait ( 1 1$30 ) else
10112: LD_INT 3150
10114: PPUSH
10115: CALL_OW 67
10119: GO 10130
// wait ( time ) ;
10121: LD_VAR 0 3
10125: PPUSH
10126: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
10130: LD_EXP 15
10134: PUSH
10135: LD_INT 6
10137: EQUAL
10138: PUSH
10139: LD_OWVAR 67
10143: PUSH
10144: LD_INT 2
10146: GREATER
10147: OR
10148: IFFALSE 10176
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
10150: LD_INT 51
10152: PPUSH
10153: LD_INT 6
10155: PPUSH
10156: LD_INT 2
10158: PPUSH
10159: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
10163: LD_INT 57
10165: PPUSH
10166: LD_INT 6
10168: PPUSH
10169: LD_INT 2
10171: PPUSH
10172: CALL_OW 322
// end ; if missionStage = 8 then
10176: LD_EXP 15
10180: PUSH
10181: LD_INT 8
10183: EQUAL
10184: IFFALSE 10212
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
10186: LD_INT 52
10188: PPUSH
10189: LD_INT 6
10191: PPUSH
10192: LD_INT 2
10194: PPUSH
10195: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
10199: LD_INT 58
10201: PPUSH
10202: LD_INT 6
10204: PPUSH
10205: LD_INT 2
10207: PPUSH
10208: CALL_OW 322
// end ; if Difficulty = 4 or missionStage = 10 then
10212: LD_OWVAR 67
10216: PUSH
10217: LD_INT 4
10219: EQUAL
10220: PUSH
10221: LD_EXP 15
10225: PUSH
10226: LD_INT 10
10228: EQUAL
10229: OR
10230: IFFALSE 10258
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
10232: LD_INT 53
10234: PPUSH
10235: LD_INT 6
10237: PPUSH
10238: LD_INT 2
10240: PPUSH
10241: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
10245: LD_INT 59
10247: PPUSH
10248: LD_INT 6
10250: PPUSH
10251: LD_INT 2
10253: PPUSH
10254: CALL_OW 322
// end ; if activeAttacks then
10258: LD_EXP 16
10262: IFFALSE 10767
// begin if missionStage = 2 then
10264: LD_EXP 15
10268: PUSH
10269: LD_INT 2
10271: EQUAL
10272: IFFALSE 10282
// strength := 1 ;
10274: LD_ADDR_VAR 0 5
10278: PUSH
10279: LD_INT 1
10281: ST_TO_ADDR
// if missionStage > 2 then
10282: LD_EXP 15
10286: PUSH
10287: LD_INT 2
10289: GREATER
10290: IFFALSE 10300
// strength := 2 ;
10292: LD_ADDR_VAR 0 5
10296: PUSH
10297: LD_INT 2
10299: ST_TO_ADDR
// if missionStage > 6 then
10300: LD_EXP 15
10304: PUSH
10305: LD_INT 6
10307: GREATER
10308: IFFALSE 10318
// strength := 3 ;
10310: LD_ADDR_VAR 0 5
10314: PUSH
10315: LD_INT 3
10317: ST_TO_ADDR
// if missionStage > 10 then
10318: LD_EXP 15
10322: PUSH
10323: LD_INT 10
10325: GREATER
10326: IFFALSE 10336
// strength := 4 ;
10328: LD_ADDR_VAR 0 5
10332: PUSH
10333: LD_INT 4
10335: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
10336: LD_ADDR_VAR 0 2
10340: PUSH
10341: LD_VAR 0 5
10345: PPUSH
10346: CALL 8829 0 1
10350: ST_TO_ADDR
// for i in tmp do
10351: LD_ADDR_VAR 0 1
10355: PUSH
10356: LD_VAR 0 2
10360: PUSH
10361: FOR_IN
10362: IFFALSE 10636
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
10364: LD_VAR 0 1
10368: PPUSH
10369: LD_VAR 0 4
10373: PUSH
10374: LD_INT 1
10376: PPUSH
10377: LD_INT 2
10379: PPUSH
10380: CALL_OW 12
10384: ARRAY
10385: PPUSH
10386: LD_INT 0
10388: PPUSH
10389: CALL_OW 49
// if i = sewiVeh then
10393: LD_VAR 0 1
10397: PUSH
10398: LD_EXP 75
10402: EQUAL
10403: IFFALSE 10456
// begin uc_side := 6 ;
10405: LD_ADDR_OWVAR 20
10409: PUSH
10410: LD_INT 6
10412: ST_TO_ADDR
// uc_nation := nation_russian ;
10413: LD_ADDR_OWVAR 21
10417: PUSH
10418: LD_INT 3
10420: ST_TO_ADDR
// Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
10421: LD_ADDR_EXP 74
10425: PUSH
10426: LD_STRING Vsevolod
10428: PPUSH
10429: LD_INT 0
10431: PPUSH
10432: LD_STRING 
10434: PPUSH
10435: CALL 70296 0 3
10439: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
10440: LD_EXP 74
10444: PPUSH
10445: LD_VAR 0 1
10449: PPUSH
10450: CALL_OW 52
// end else
10454: GO 10537
// if GetControl ( i ) = control_manual then
10456: LD_VAR 0 1
10460: PPUSH
10461: CALL_OW 263
10465: PUSH
10466: LD_INT 1
10468: EQUAL
10469: IFFALSE 10537
// begin uc_side := 6 ;
10471: LD_ADDR_OWVAR 20
10475: PUSH
10476: LD_INT 6
10478: ST_TO_ADDR
// uc_nation := 3 ;
10479: LD_ADDR_OWVAR 21
10483: PUSH
10484: LD_INT 3
10486: ST_TO_ADDR
// hc_gallery :=  ;
10487: LD_ADDR_OWVAR 33
10491: PUSH
10492: LD_STRING 
10494: ST_TO_ADDR
// hc_name :=  ;
10495: LD_ADDR_OWVAR 26
10499: PUSH
10500: LD_STRING 
10502: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
10503: LD_INT 0
10505: PPUSH
10506: LD_INT 3
10508: PPUSH
10509: LD_INT 10
10511: PPUSH
10512: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
10516: CALL_OW 44
10520: PPUSH
10521: LD_VAR 0 1
10525: PPUSH
10526: CALL_OW 52
// wait ( 0 0$0.3 ) ;
10530: LD_INT 10
10532: PPUSH
10533: CALL_OW 67
// end ; case rand ( 1 , 3 ) of 1 :
10537: LD_INT 1
10539: PPUSH
10540: LD_INT 3
10542: PPUSH
10543: CALL_OW 12
10547: PUSH
10548: LD_INT 1
10550: DOUBLE
10551: EQUAL
10552: IFTRUE 10556
10554: GO 10574
10556: POP
// ComMoveXY ( i , 111 , 197 ) ; 2 :
10557: LD_VAR 0 1
10561: PPUSH
10562: LD_INT 111
10564: PPUSH
10565: LD_INT 197
10567: PPUSH
10568: CALL_OW 111
10572: GO 10627
10574: LD_INT 2
10576: DOUBLE
10577: EQUAL
10578: IFTRUE 10582
10580: GO 10600
10582: POP
// ComMoveXY ( i , 91 , 165 ) ; 3 :
10583: LD_VAR 0 1
10587: PPUSH
10588: LD_INT 91
10590: PPUSH
10591: LD_INT 165
10593: PPUSH
10594: CALL_OW 111
10598: GO 10627
10600: LD_INT 3
10602: DOUBLE
10603: EQUAL
10604: IFTRUE 10608
10606: GO 10626
10608: POP
// ComMoveXY ( i , 137 , 157 ) ; end ;
10609: LD_VAR 0 1
10613: PPUSH
10614: LD_INT 137
10616: PPUSH
10617: LD_INT 157
10619: PPUSH
10620: CALL_OW 111
10624: GO 10627
10626: POP
// wait ( 0 0$2 ) ;
10627: LD_INT 70
10629: PPUSH
10630: CALL_OW 67
// end ;
10634: GO 10361
10636: POP
10637: POP
// repeat wait ( 0 0$1 ) ;
10638: LD_INT 35
10640: PPUSH
10641: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
10645: LD_ADDR_VAR 0 1
10649: PUSH
10650: LD_VAR 0 2
10654: PPUSH
10655: LD_INT 50
10657: PUSH
10658: EMPTY
10659: LIST
10660: PPUSH
10661: CALL_OW 72
10665: PUSH
10666: FOR_IN
10667: IFFALSE 10726
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10669: LD_VAR 0 1
10673: PPUSH
10674: LD_INT 108
10676: PUSH
10677: LD_INT 153
10679: PUSH
10680: EMPTY
10681: LIST
10682: LIST
10683: PUSH
10684: LD_INT 105
10686: PUSH
10687: LD_INT 149
10689: PUSH
10690: EMPTY
10691: LIST
10692: LIST
10693: PUSH
10694: LD_INT 85
10696: PUSH
10697: LD_INT 131
10699: PUSH
10700: EMPTY
10701: LIST
10702: LIST
10703: PUSH
10704: LD_INT 64
10706: PUSH
10707: LD_INT 105
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: LIST
10718: LIST
10719: PPUSH
10720: CALL 110701 0 2
10724: GO 10666
10726: POP
10727: POP
// until not UnitFilter ( tmp , [ [ f_not , [ f_weapon , ru_time_lapser ] ] , [ f_ok ] ] ) ;
10728: LD_VAR 0 2
10732: PPUSH
10733: LD_INT 3
10735: PUSH
10736: LD_INT 34
10738: PUSH
10739: LD_INT 49
10741: PUSH
10742: EMPTY
10743: LIST
10744: LIST
10745: PUSH
10746: EMPTY
10747: LIST
10748: LIST
10749: PUSH
10750: LD_INT 50
10752: PUSH
10753: EMPTY
10754: LIST
10755: PUSH
10756: EMPTY
10757: LIST
10758: LIST
10759: PPUSH
10760: CALL_OW 72
10764: NOT
10765: IFFALSE 10638
// end ; until russianDestroyed ;
10767: LD_EXP 21
10771: IFFALSE 10102
// end ;
10773: PPOPN 6
10775: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 do var i , tmp , target , teleport , p ;
10776: LD_EXP 21
10780: NOT
10781: PUSH
10782: LD_EXP 15
10786: PUSH
10787: LD_INT 6
10789: GREATEREQUAL
10790: AND
10791: IFFALSE 11828
10793: GO 10795
10795: DISABLE
10796: LD_INT 0
10798: PPUSH
10799: PPUSH
10800: PPUSH
10801: PPUSH
10802: PPUSH
// begin enable ;
10803: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10804: LD_INT 22
10806: PUSH
10807: LD_INT 3
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PUSH
10814: LD_INT 30
10816: PUSH
10817: LD_INT 3
10819: PUSH
10820: EMPTY
10821: LIST
10822: LIST
10823: PUSH
10824: EMPTY
10825: LIST
10826: LIST
10827: PPUSH
10828: CALL_OW 69
10832: NOT
10833: IFFALSE 10837
// exit ;
10835: GO 11828
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10837: LD_ADDR_VAR 0 4
10841: PUSH
10842: LD_INT 22
10844: PUSH
10845: LD_INT 3
10847: PUSH
10848: EMPTY
10849: LIST
10850: LIST
10851: PUSH
10852: LD_INT 30
10854: PUSH
10855: LD_INT 34
10857: PUSH
10858: EMPTY
10859: LIST
10860: LIST
10861: PUSH
10862: EMPTY
10863: LIST
10864: LIST
10865: PPUSH
10866: CALL_OW 69
10870: ST_TO_ADDR
// if Prob ( 40 ) then
10871: LD_INT 40
10873: PPUSH
10874: CALL_OW 13
10878: IFFALSE 11024
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10880: LD_INT 2
10882: PPUSH
10883: LD_INT 22
10885: PUSH
10886: LD_INT 3
10888: PUSH
10889: LD_INT 3
10891: PUSH
10892: LD_INT 49
10894: PUSH
10895: EMPTY
10896: LIST
10897: LIST
10898: LIST
10899: LIST
10900: PUSH
10901: LD_INT 22
10903: PUSH
10904: LD_INT 3
10906: PUSH
10907: LD_INT 3
10909: PUSH
10910: LD_INT 49
10912: PUSH
10913: EMPTY
10914: LIST
10915: LIST
10916: LIST
10917: LIST
10918: PUSH
10919: LD_INT 22
10921: PUSH
10922: LD_INT 3
10924: PUSH
10925: LD_INT 3
10927: PUSH
10928: LD_INT 49
10930: PUSH
10931: EMPTY
10932: LIST
10933: LIST
10934: LIST
10935: LIST
10936: PUSH
10937: LD_INT 24
10939: PUSH
10940: LD_INT 3
10942: PUSH
10943: LD_INT 3
10945: PUSH
10946: LD_INT 46
10948: PUSH
10949: EMPTY
10950: LIST
10951: LIST
10952: LIST
10953: LIST
10954: PUSH
10955: LD_INT 24
10957: PUSH
10958: LD_INT 3
10960: PUSH
10961: LD_INT 3
10963: PUSH
10964: LD_INT 46
10966: PUSH
10967: EMPTY
10968: LIST
10969: LIST
10970: LIST
10971: LIST
10972: PUSH
10973: LD_INT 24
10975: PUSH
10976: LD_INT 3
10978: PUSH
10979: LD_INT 3
10981: PUSH
10982: LD_INT 46
10984: PUSH
10985: EMPTY
10986: LIST
10987: LIST
10988: LIST
10989: LIST
10990: PUSH
10991: LD_INT 24
10993: PUSH
10994: LD_INT 3
10996: PUSH
10997: LD_INT 3
10999: PUSH
11000: LD_INT 46
11002: PUSH
11003: EMPTY
11004: LIST
11005: LIST
11006: LIST
11007: LIST
11008: PUSH
11009: EMPTY
11010: LIST
11011: LIST
11012: LIST
11013: LIST
11014: LIST
11015: LIST
11016: LIST
11017: PPUSH
11018: CALL 63870 0 2
// end else
11022: GO 11166
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
11024: LD_INT 2
11026: PPUSH
11027: LD_INT 24
11029: PUSH
11030: LD_INT 3
11032: PUSH
11033: LD_INT 3
11035: PUSH
11036: LD_INT 47
11038: PUSH
11039: EMPTY
11040: LIST
11041: LIST
11042: LIST
11043: LIST
11044: PUSH
11045: LD_INT 24
11047: PUSH
11048: LD_INT 3
11050: PUSH
11051: LD_INT 3
11053: PUSH
11054: LD_INT 47
11056: PUSH
11057: EMPTY
11058: LIST
11059: LIST
11060: LIST
11061: LIST
11062: PUSH
11063: LD_INT 24
11065: PUSH
11066: LD_INT 3
11068: PUSH
11069: LD_INT 3
11071: PUSH
11072: LD_INT 47
11074: PUSH
11075: EMPTY
11076: LIST
11077: LIST
11078: LIST
11079: LIST
11080: PUSH
11081: LD_INT 24
11083: PUSH
11084: LD_INT 3
11086: PUSH
11087: LD_INT 3
11089: PUSH
11090: LD_INT 46
11092: PUSH
11093: EMPTY
11094: LIST
11095: LIST
11096: LIST
11097: LIST
11098: PUSH
11099: LD_INT 24
11101: PUSH
11102: LD_INT 3
11104: PUSH
11105: LD_INT 3
11107: PUSH
11108: LD_INT 46
11110: PUSH
11111: EMPTY
11112: LIST
11113: LIST
11114: LIST
11115: LIST
11116: PUSH
11117: LD_INT 24
11119: PUSH
11120: LD_INT 3
11122: PUSH
11123: LD_INT 3
11125: PUSH
11126: LD_INT 46
11128: PUSH
11129: EMPTY
11130: LIST
11131: LIST
11132: LIST
11133: LIST
11134: PUSH
11135: LD_INT 24
11137: PUSH
11138: LD_INT 3
11140: PUSH
11141: LD_INT 3
11143: PUSH
11144: LD_INT 46
11146: PUSH
11147: EMPTY
11148: LIST
11149: LIST
11150: LIST
11151: LIST
11152: PUSH
11153: EMPTY
11154: LIST
11155: LIST
11156: LIST
11157: LIST
11158: LIST
11159: LIST
11160: LIST
11161: PPUSH
11162: CALL 63870 0 2
// end ; wait ( 2 2$00 ) ;
11166: LD_INT 4200
11168: PPUSH
11169: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_siberium_rocket ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 2 ] ;
11173: LD_ADDR_VAR 0 2
11177: PUSH
11178: LD_INT 22
11180: PUSH
11181: LD_INT 3
11183: PUSH
11184: EMPTY
11185: LIST
11186: LIST
11187: PUSH
11188: LD_INT 23
11190: PUSH
11191: LD_INT 3
11193: PUSH
11194: EMPTY
11195: LIST
11196: LIST
11197: PUSH
11198: LD_INT 21
11200: PUSH
11201: LD_INT 2
11203: PUSH
11204: EMPTY
11205: LIST
11206: LIST
11207: PUSH
11208: LD_INT 3
11210: PUSH
11211: LD_INT 34
11213: PUSH
11214: LD_INT 48
11216: PUSH
11217: EMPTY
11218: LIST
11219: LIST
11220: PUSH
11221: EMPTY
11222: LIST
11223: LIST
11224: PUSH
11225: LD_INT 3
11227: PUSH
11228: LD_INT 34
11230: PUSH
11231: LD_INT 51
11233: PUSH
11234: EMPTY
11235: LIST
11236: LIST
11237: PUSH
11238: EMPTY
11239: LIST
11240: LIST
11241: PUSH
11242: LD_INT 3
11244: PUSH
11245: LD_INT 34
11247: PUSH
11248: LD_INT 52
11250: PUSH
11251: EMPTY
11252: LIST
11253: LIST
11254: PUSH
11255: EMPTY
11256: LIST
11257: LIST
11258: PUSH
11259: EMPTY
11260: LIST
11261: LIST
11262: LIST
11263: LIST
11264: LIST
11265: LIST
11266: PPUSH
11267: CALL_OW 69
11271: PUSH
11272: LD_EXP 124
11276: PUSH
11277: LD_INT 2
11279: ARRAY
11280: DIFF
11281: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
11282: LD_ADDR_EXP 121
11286: PUSH
11287: LD_EXP 121
11291: PPUSH
11292: LD_INT 2
11294: PPUSH
11295: LD_EXP 121
11299: PUSH
11300: LD_INT 2
11302: ARRAY
11303: PUSH
11304: LD_VAR 0 2
11308: DIFF
11309: PPUSH
11310: CALL_OW 1
11314: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
11315: LD_ADDR_VAR 0 3
11319: PUSH
11320: LD_INT 0
11322: PPUSH
11323: LD_INT 1
11325: PPUSH
11326: CALL_OW 12
11330: ST_TO_ADDR
// p := 0 ;
11331: LD_ADDR_VAR 0 5
11335: PUSH
11336: LD_INT 0
11338: ST_TO_ADDR
// if target then
11339: LD_VAR 0 3
11343: IFFALSE 11492
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11345: LD_ADDR_VAR 0 2
11349: PUSH
11350: LD_VAR 0 2
11354: PPUSH
11355: LD_INT 50
11357: PUSH
11358: EMPTY
11359: LIST
11360: PPUSH
11361: CALL_OW 72
11365: ST_TO_ADDR
// for i in tmp do
11366: LD_ADDR_VAR 0 1
11370: PUSH
11371: LD_VAR 0 2
11375: PUSH
11376: FOR_IN
11377: IFFALSE 11417
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
11379: LD_VAR 0 1
11383: PPUSH
11384: LD_INT 139
11386: PPUSH
11387: LD_INT 89
11389: PPUSH
11390: CALL_OW 297
11394: PUSH
11395: LD_INT 9
11397: GREATER
11398: IFFALSE 11415
// ComMoveXY ( i , 139 , 89 ) ;
11400: LD_VAR 0 1
11404: PPUSH
11405: LD_INT 139
11407: PPUSH
11408: LD_INT 89
11410: PPUSH
11411: CALL_OW 111
11415: GO 11376
11417: POP
11418: POP
// wait ( 0 0$1 ) ;
11419: LD_INT 35
11421: PPUSH
11422: CALL_OW 67
// p := Inc ( p ) ;
11426: LD_ADDR_VAR 0 5
11430: PUSH
11431: LD_VAR 0 5
11435: PPUSH
11436: CALL 109452 0 1
11440: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11441: LD_VAR 0 2
11445: PPUSH
11446: LD_INT 92
11448: PUSH
11449: LD_INT 139
11451: PUSH
11452: LD_INT 89
11454: PUSH
11455: LD_INT 9
11457: PUSH
11458: EMPTY
11459: LIST
11460: LIST
11461: LIST
11462: LIST
11463: PPUSH
11464: CALL_OW 72
11468: PUSH
11469: LD_VAR 0 2
11473: PUSH
11474: LD_INT 1
11476: MINUS
11477: GREATEREQUAL
11478: PUSH
11479: LD_VAR 0 5
11483: PUSH
11484: LD_INT 60
11486: GREATER
11487: OR
11488: IFFALSE 11345
// end else
11490: GO 11655
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11492: LD_VAR 0 2
11496: PPUSH
11497: LD_VAR 0 4
11501: PUSH
11502: LD_INT 1
11504: ARRAY
11505: PPUSH
11506: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11510: LD_ADDR_VAR 0 2
11514: PUSH
11515: LD_VAR 0 2
11519: PPUSH
11520: LD_INT 50
11522: PUSH
11523: EMPTY
11524: LIST
11525: PPUSH
11526: CALL_OW 72
11530: ST_TO_ADDR
// for i in tmp do
11531: LD_ADDR_VAR 0 1
11535: PUSH
11536: LD_VAR 0 2
11540: PUSH
11541: FOR_IN
11542: IFFALSE 11582
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11544: LD_VAR 0 1
11548: PPUSH
11549: LD_INT 124
11551: PPUSH
11552: LD_INT 139
11554: PPUSH
11555: CALL_OW 297
11559: PUSH
11560: LD_INT 9
11562: GREATER
11563: IFFALSE 11580
// ComMoveXY ( i , 124 , 139 ) ;
11565: LD_VAR 0 1
11569: PPUSH
11570: LD_INT 124
11572: PPUSH
11573: LD_INT 139
11575: PPUSH
11576: CALL_OW 111
11580: GO 11541
11582: POP
11583: POP
// wait ( 0 0$1 ) ;
11584: LD_INT 35
11586: PPUSH
11587: CALL_OW 67
// p := Inc ( p ) ;
11591: LD_ADDR_VAR 0 5
11595: PUSH
11596: LD_VAR 0 5
11600: PPUSH
11601: CALL 109452 0 1
11605: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11606: LD_VAR 0 2
11610: PPUSH
11611: LD_INT 92
11613: PUSH
11614: LD_INT 124
11616: PUSH
11617: LD_INT 139
11619: PUSH
11620: LD_INT 9
11622: PUSH
11623: EMPTY
11624: LIST
11625: LIST
11626: LIST
11627: LIST
11628: PPUSH
11629: CALL_OW 72
11633: PUSH
11634: LD_VAR 0 2
11638: PUSH
11639: LD_INT 1
11641: MINUS
11642: GREATEREQUAL
11643: PUSH
11644: LD_VAR 0 5
11648: PUSH
11649: LD_INT 60
11651: GREATER
11652: OR
11653: IFFALSE 11510
// end ; repeat wait ( 0 0$1 ) ;
11655: LD_INT 35
11657: PPUSH
11658: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11662: LD_ADDR_VAR 0 2
11666: PUSH
11667: LD_VAR 0 2
11671: PPUSH
11672: LD_INT 50
11674: PUSH
11675: EMPTY
11676: LIST
11677: PPUSH
11678: CALL_OW 72
11682: ST_TO_ADDR
// for i in tmp do
11683: LD_ADDR_VAR 0 1
11687: PUSH
11688: LD_VAR 0 2
11692: PUSH
11693: FOR_IN
11694: IFFALSE 11819
// begin if GetWeapon ( i ) = ru_time_lapser then
11696: LD_VAR 0 1
11700: PPUSH
11701: CALL_OW 264
11705: PUSH
11706: LD_INT 49
11708: EQUAL
11709: IFFALSE 11765
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11711: LD_VAR 0 1
11715: PPUSH
11716: LD_INT 2
11718: PUSH
11719: LD_INT 22
11721: PUSH
11722: LD_INT 1
11724: PUSH
11725: EMPTY
11726: LIST
11727: LIST
11728: PUSH
11729: LD_INT 22
11731: PUSH
11732: LD_INT 8
11734: PUSH
11735: EMPTY
11736: LIST
11737: LIST
11738: PUSH
11739: EMPTY
11740: LIST
11741: LIST
11742: LIST
11743: PPUSH
11744: CALL_OW 69
11748: PPUSH
11749: LD_VAR 0 1
11753: PPUSH
11754: CALL_OW 74
11758: PPUSH
11759: CALL_OW 112
11763: GO 11817
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11765: LD_VAR 0 1
11769: PPUSH
11770: LD_INT 2
11772: PUSH
11773: LD_INT 22
11775: PUSH
11776: LD_INT 1
11778: PUSH
11779: EMPTY
11780: LIST
11781: LIST
11782: PUSH
11783: LD_INT 22
11785: PUSH
11786: LD_INT 8
11788: PUSH
11789: EMPTY
11790: LIST
11791: LIST
11792: PUSH
11793: EMPTY
11794: LIST
11795: LIST
11796: LIST
11797: PPUSH
11798: CALL_OW 69
11802: PPUSH
11803: LD_VAR 0 1
11807: PPUSH
11808: CALL_OW 74
11812: PPUSH
11813: CALL_OW 115
// end ;
11817: GO 11693
11819: POP
11820: POP
// until not tmp ;
11821: LD_VAR 0 2
11825: NOT
11826: IFFALSE 11655
// end ;
11828: PPOPN 5
11830: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 7 and Difficulty > 1 do var i , veh , un ;
11831: LD_EXP 15
11835: PUSH
11836: LD_INT 7
11838: GREATEREQUAL
11839: PUSH
11840: LD_OWVAR 67
11844: PUSH
11845: LD_INT 1
11847: GREATER
11848: AND
11849: IFFALSE 12141
11851: GO 11853
11853: DISABLE
11854: LD_INT 0
11856: PPUSH
11857: PPUSH
11858: PPUSH
// begin ruMobile := [ ] ;
11859: LD_ADDR_EXP 78
11863: PUSH
11864: EMPTY
11865: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 ] [ Difficulty - 1 ] do
11866: LD_ADDR_VAR 0 1
11870: PUSH
11871: DOUBLE
11872: LD_INT 1
11874: DEC
11875: ST_TO_ADDR
11876: LD_INT 4
11878: PUSH
11879: LD_INT 5
11881: PUSH
11882: LD_INT 6
11884: PUSH
11885: EMPTY
11886: LIST
11887: LIST
11888: LIST
11889: PUSH
11890: LD_OWVAR 67
11894: PUSH
11895: LD_INT 1
11897: MINUS
11898: ARRAY
11899: PUSH
11900: FOR_TO
11901: IFFALSE 12139
// begin uc_side := 3 ;
11903: LD_ADDR_OWVAR 20
11907: PUSH
11908: LD_INT 3
11910: ST_TO_ADDR
// uc_nation := 1 ;
11911: LD_ADDR_OWVAR 21
11915: PUSH
11916: LD_INT 1
11918: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_laser , us_rocket_launcher ] [ i mod 2 + 1 ] , 100 ) ;
11919: LD_INT 5
11921: PPUSH
11922: LD_INT 3
11924: PPUSH
11925: LD_INT 1
11927: PPUSH
11928: LD_INT 9
11930: PUSH
11931: LD_INT 7
11933: PUSH
11934: EMPTY
11935: LIST
11936: LIST
11937: PUSH
11938: LD_VAR 0 1
11942: PUSH
11943: LD_INT 2
11945: MOD
11946: PUSH
11947: LD_INT 1
11949: PLUS
11950: ARRAY
11951: PPUSH
11952: LD_INT 100
11954: PPUSH
11955: CALL 75220 0 5
// veh := CreateVehicle ;
11959: LD_ADDR_VAR 0 2
11963: PUSH
11964: CALL_OW 45
11968: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11969: LD_VAR 0 2
11973: PPUSH
11974: LD_INT 3
11976: PPUSH
11977: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11981: LD_VAR 0 2
11985: PPUSH
11986: LD_INT 29
11988: PPUSH
11989: LD_INT 0
11991: PPUSH
11992: CALL_OW 49
// uc_nation := 3 ;
11996: LD_ADDR_OWVAR 21
12000: PUSH
12001: LD_INT 3
12003: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
12004: LD_INT 0
12006: PPUSH
12007: LD_INT 10
12009: PPUSH
12010: CALL_OW 383
// un := CreateHuman ;
12014: LD_ADDR_VAR 0 3
12018: PUSH
12019: CALL_OW 44
12023: ST_TO_ADDR
// SetTag ( un , 105 ) ;
12024: LD_VAR 0 3
12028: PPUSH
12029: LD_INT 105
12031: PPUSH
12032: CALL_OW 109
// if GetSkill ( un , skill_mechanical ) < [ 8 , 9 , 10 ] [ Difficulty ] then
12036: LD_VAR 0 3
12040: PPUSH
12041: LD_INT 3
12043: PPUSH
12044: CALL_OW 259
12048: PUSH
12049: LD_INT 8
12051: PUSH
12052: LD_INT 9
12054: PUSH
12055: LD_INT 10
12057: PUSH
12058: EMPTY
12059: LIST
12060: LIST
12061: LIST
12062: PUSH
12063: LD_OWVAR 67
12067: ARRAY
12068: LESS
12069: IFFALSE 12103
// SetSkill ( un , skill_mechanical , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
12071: LD_VAR 0 3
12075: PPUSH
12076: LD_INT 3
12078: PPUSH
12079: LD_INT 8
12081: PUSH
12082: LD_INT 9
12084: PUSH
12085: LD_INT 10
12087: PUSH
12088: EMPTY
12089: LIST
12090: LIST
12091: LIST
12092: PUSH
12093: LD_OWVAR 67
12097: ARRAY
12098: PPUSH
12099: CALL_OW 237
// PlaceHumanInUnit ( un , veh ) ;
12103: LD_VAR 0 3
12107: PPUSH
12108: LD_VAR 0 2
12112: PPUSH
12113: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
12117: LD_ADDR_EXP 78
12121: PUSH
12122: LD_EXP 78
12126: PPUSH
12127: LD_VAR 0 2
12131: PPUSH
12132: CALL 108091 0 2
12136: ST_TO_ADDR
// end ;
12137: GO 11900
12139: POP
12140: POP
// end ;
12141: PPOPN 3
12143: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
12144: LD_EXP 78
12148: IFFALSE 12657
12150: GO 12152
12152: DISABLE
12153: LD_INT 0
12155: PPUSH
12156: PPUSH
12157: PPUSH
// begin enable ;
12158: ENABLE
// if not ruMobile then
12159: LD_EXP 78
12163: NOT
12164: IFFALSE 12169
// begin disable ;
12166: DISABLE
// exit ;
12167: GO 12657
// end ; for i in ruMobile do
12169: LD_ADDR_VAR 0 1
12173: PUSH
12174: LD_EXP 78
12178: PUSH
12179: FOR_IN
12180: IFFALSE 12655
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
12182: LD_VAR 0 1
12186: PPUSH
12187: CALL_OW 302
12191: NOT
12192: PUSH
12193: LD_VAR 0 1
12197: PPUSH
12198: CALL_OW 255
12202: PUSH
12203: LD_INT 3
12205: NONEQUAL
12206: OR
12207: IFFALSE 12227
// begin ruMobile := ruMobile diff i ;
12209: LD_ADDR_EXP 78
12213: PUSH
12214: LD_EXP 78
12218: PUSH
12219: LD_VAR 0 1
12223: DIFF
12224: ST_TO_ADDR
// continue ;
12225: GO 12179
// end ; if GetTag ( i ) = 300 then
12227: LD_VAR 0 1
12231: PPUSH
12232: CALL_OW 110
12236: PUSH
12237: LD_INT 300
12239: EQUAL
12240: IFFALSE 12290
// begin ComMoveXY ( i , 160 , 81 ) ;
12242: LD_VAR 0 1
12246: PPUSH
12247: LD_INT 160
12249: PPUSH
12250: LD_INT 81
12252: PPUSH
12253: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
12257: LD_VAR 0 1
12261: PPUSH
12262: LD_INT 160
12264: PPUSH
12265: LD_INT 81
12267: PPUSH
12268: CALL_OW 297
12272: PUSH
12273: LD_INT 8
12275: LESS
12276: IFFALSE 12290
// SetTag ( i , 301 ) ;
12278: LD_VAR 0 1
12282: PPUSH
12283: LD_INT 301
12285: PPUSH
12286: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
12290: LD_VAR 0 1
12294: PPUSH
12295: CALL_OW 110
12299: PUSH
12300: LD_INT 301
12302: EQUAL
12303: IFFALSE 12346
// begin if not IsInArea ( i , ruMobileParkingArea ) then
12305: LD_VAR 0 1
12309: PPUSH
12310: LD_INT 33
12312: PPUSH
12313: CALL_OW 308
12317: NOT
12318: IFFALSE 12334
// ComMoveToArea ( i , ruMobileParkingArea ) else
12320: LD_VAR 0 1
12324: PPUSH
12325: LD_INT 33
12327: PPUSH
12328: CALL_OW 113
12332: GO 12346
// SetTag ( i , 302 ) ;
12334: LD_VAR 0 1
12338: PPUSH
12339: LD_INT 302
12341: PPUSH
12342: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
12346: LD_VAR 0 1
12350: PPUSH
12351: CALL_OW 110
12355: PUSH
12356: LD_INT 302
12358: EQUAL
12359: IFFALSE 12489
// begin if GetLives ( i ) < 1000 then
12361: LD_VAR 0 1
12365: PPUSH
12366: CALL_OW 256
12370: PUSH
12371: LD_INT 1000
12373: LESS
12374: IFFALSE 12466
// begin if not IsDrivenBy ( i ) then
12376: LD_VAR 0 1
12380: PPUSH
12381: CALL_OW 311
12385: NOT
12386: IFFALSE 12390
// continue ;
12388: GO 12179
// mech := IsDrivenBy ( i ) ;
12390: LD_ADDR_VAR 0 2
12394: PUSH
12395: LD_VAR 0 1
12399: PPUSH
12400: CALL_OW 311
12404: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
12405: LD_VAR 0 2
12409: PPUSH
12410: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
12414: LD_VAR 0 2
12418: PPUSH
12419: LD_VAR 0 1
12423: PPUSH
12424: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
12428: LD_INT 35
12430: PPUSH
12431: CALL_OW 67
// until GetLives ( i ) = 1000 ;
12435: LD_VAR 0 1
12439: PPUSH
12440: CALL_OW 256
12444: PUSH
12445: LD_INT 1000
12447: EQUAL
12448: IFFALSE 12428
// ComEnterUnit ( mech , i ) ;
12450: LD_VAR 0 2
12454: PPUSH
12455: LD_VAR 0 1
12459: PPUSH
12460: CALL_OW 120
// end else
12464: GO 12489
// if IsDrivenBy ( i ) then
12466: LD_VAR 0 1
12470: PPUSH
12471: CALL_OW 311
12475: IFFALSE 12489
// SetTag ( i , 0 ) ;
12477: LD_VAR 0 1
12481: PPUSH
12482: LD_INT 0
12484: PPUSH
12485: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
12489: LD_VAR 0 1
12493: PPUSH
12494: CALL_OW 110
12498: PUSH
12499: LD_INT 300
12501: LESS
12502: IFFALSE 12653
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
12504: LD_ADDR_VAR 0 3
12508: PUSH
12509: LD_INT 4
12511: PPUSH
12512: LD_INT 81
12514: PUSH
12515: LD_INT 3
12517: PUSH
12518: EMPTY
12519: LIST
12520: LIST
12521: PPUSH
12522: CALL_OW 70
12526: ST_TO_ADDR
// if GetLives ( i ) < 650 then
12527: LD_VAR 0 1
12531: PPUSH
12532: CALL_OW 256
12536: PUSH
12537: LD_INT 650
12539: LESS
12540: IFFALSE 12565
// begin ComStop ( i ) ;
12542: LD_VAR 0 1
12546: PPUSH
12547: CALL_OW 141
// SetTag ( i , 300 ) ;
12551: LD_VAR 0 1
12555: PPUSH
12556: LD_INT 300
12558: PPUSH
12559: CALL_OW 109
// continue ;
12563: GO 12179
// end ; if enemy then
12565: LD_VAR 0 3
12569: IFFALSE 12609
// begin if not HasTask ( i ) then
12571: LD_VAR 0 1
12575: PPUSH
12576: CALL_OW 314
12580: NOT
12581: IFFALSE 12607
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
12583: LD_VAR 0 1
12587: PPUSH
12588: LD_VAR 0 3
12592: PPUSH
12593: LD_VAR 0 1
12597: PPUSH
12598: CALL_OW 74
12602: PPUSH
12603: CALL_OW 115
// end else
12607: GO 12653
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
12609: LD_VAR 0 1
12613: PPUSH
12614: LD_INT 158
12616: PUSH
12617: LD_INT 61
12619: PUSH
12620: EMPTY
12621: LIST
12622: LIST
12623: PUSH
12624: LD_INT 98
12626: PUSH
12627: LD_INT 100
12629: PUSH
12630: EMPTY
12631: LIST
12632: LIST
12633: PUSH
12634: LD_INT 78
12636: PUSH
12637: LD_INT 93
12639: PUSH
12640: EMPTY
12641: LIST
12642: LIST
12643: PUSH
12644: EMPTY
12645: LIST
12646: LIST
12647: LIST
12648: PPUSH
12649: CALL 110701 0 2
// end ; end ;
12653: GO 12179
12655: POP
12656: POP
// end ; end_of_file
12657: PPOPN 3
12659: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport , b ; begin
12660: LD_INT 0
12662: PPUSH
12663: PPUSH
12664: PPUSH
12665: PPUSH
12666: PPUSH
12667: PPUSH
12668: PPUSH
// if Difficulty = 1 then
12669: LD_OWVAR 67
12673: PUSH
12674: LD_INT 1
12676: EQUAL
12677: IFFALSE 12715
// for i in FilterAllUnits ( [ f_inarea , delBuildingsArea ] ) do
12679: LD_ADDR_VAR 0 2
12683: PUSH
12684: LD_INT 95
12686: PUSH
12687: LD_INT 34
12689: PUSH
12690: EMPTY
12691: LIST
12692: LIST
12693: PPUSH
12694: CALL_OW 69
12698: PUSH
12699: FOR_IN
12700: IFFALSE 12713
// RemoveUnit ( i ) ;
12702: LD_VAR 0 2
12706: PPUSH
12707: CALL_OW 64
12711: GO 12699
12713: POP
12714: POP
// SetInvulnrability ( alien , true ) ;
12715: LD_INT 1
12717: PPUSH
12718: LD_INT 1
12720: PPUSH
12721: CALL_OW 607
// side := 7 ;
12725: LD_ADDR_VAR 0 5
12729: PUSH
12730: LD_INT 7
12732: ST_TO_ADDR
// uc_side := side ;
12733: LD_ADDR_OWVAR 20
12737: PUSH
12738: LD_VAR 0 5
12742: ST_TO_ADDR
// uc_nation := 1 ;
12743: LD_ADDR_OWVAR 21
12747: PUSH
12748: LD_INT 1
12750: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
12751: LD_ADDR_VAR 0 2
12755: PUSH
12756: LD_INT 22
12758: PUSH
12759: LD_VAR 0 5
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: PUSH
12768: LD_INT 21
12770: PUSH
12771: LD_INT 3
12773: PUSH
12774: EMPTY
12775: LIST
12776: LIST
12777: PUSH
12778: EMPTY
12779: LIST
12780: LIST
12781: PPUSH
12782: CALL_OW 69
12786: PUSH
12787: FOR_IN
12788: IFFALSE 12804
// SetBLevel ( i , 10 ) ;
12790: LD_VAR 0 2
12794: PPUSH
12795: LD_INT 10
12797: PPUSH
12798: CALL_OW 241
12802: GO 12787
12804: POP
12805: POP
// base := GetBase ( al_depot ) ;
12806: LD_ADDR_VAR 0 4
12810: PUSH
12811: LD_INT 2
12813: PPUSH
12814: CALL_OW 274
12818: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
12819: LD_ADDR_VAR 0 6
12823: PUSH
12824: LD_INT 22
12826: PUSH
12827: LD_VAR 0 5
12831: PUSH
12832: EMPTY
12833: LIST
12834: LIST
12835: PUSH
12836: LD_INT 30
12838: PUSH
12839: LD_INT 34
12841: PUSH
12842: EMPTY
12843: LIST
12844: LIST
12845: PUSH
12846: EMPTY
12847: LIST
12848: LIST
12849: PPUSH
12850: CALL_OW 69
12854: ST_TO_ADDR
// if teleport then
12855: LD_VAR 0 6
12859: IFFALSE 12880
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
12861: LD_VAR 0 6
12865: PUSH
12866: LD_INT 1
12868: ARRAY
12869: PPUSH
12870: LD_INT 262
12872: PPUSH
12873: LD_INT 119
12875: PPUSH
12876: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
12880: LD_VAR 0 4
12884: PPUSH
12885: LD_INT 1
12887: PPUSH
12888: LD_INT 19500
12890: PPUSH
12891: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
12895: LD_VAR 0 4
12899: PPUSH
12900: LD_INT 2
12902: PPUSH
12903: LD_INT 200
12905: PPUSH
12906: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
12910: LD_VAR 0 4
12914: PPUSH
12915: LD_INT 3
12917: PPUSH
12918: LD_INT 650
12920: PPUSH
12921: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12925: LD_ADDR_EXP 79
12929: PUSH
12930: LD_STRING Roth
12932: PPUSH
12933: CALL_OW 25
12937: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12938: LD_ADDR_EXP 80
12942: PUSH
12943: LD_STRING Simms
12945: PPUSH
12946: LD_EXP 1
12950: NOT
12951: PPUSH
12952: LD_STRING 10c_
12954: PPUSH
12955: CALL 70296 0 3
12959: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
12960: LD_EXP 80
12964: PPUSH
12965: LD_INT 4
12967: PPUSH
12968: CALL_OW 336
// if not Simms then
12972: LD_EXP 80
12976: NOT
12977: IFFALSE 13007
// begin uc_nation := 1 ;
12979: LD_ADDR_OWVAR 21
12983: PUSH
12984: LD_INT 1
12986: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12987: LD_INT 2
12989: PPUSH
12990: LD_INT 10
12992: PPUSH
12993: CALL_OW 384
// Simms := CreateHuman ;
12997: LD_ADDR_EXP 80
13001: PUSH
13002: CALL_OW 44
13006: ST_TO_ADDR
// end ; uc_nation := 3 ;
13007: LD_ADDR_OWVAR 21
13011: PUSH
13012: LD_INT 3
13014: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
13015: LD_ADDR_EXP 81
13019: PUSH
13020: LD_STRING Kirilenkova
13022: PPUSH
13023: CALL_OW 25
13027: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
13028: LD_ADDR_EXP 95
13032: PUSH
13033: LD_STRING Oblukov
13035: PPUSH
13036: CALL_OW 25
13040: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
13041: LD_ADDR_EXP 82
13045: PUSH
13046: LD_STRING Dolgov
13048: PPUSH
13049: CALL_OW 25
13053: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
13054: LD_ADDR_EXP 83
13058: PUSH
13059: LD_STRING Petrosyan
13061: PPUSH
13062: CALL_OW 25
13066: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
13067: LD_ADDR_EXP 94
13071: PUSH
13072: LD_STRING Scholtze
13074: PPUSH
13075: CALL_OW 25
13079: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
13080: LD_ADDR_EXP 93
13084: PUSH
13085: LD_STRING Kapitsova
13087: PPUSH
13088: CALL_OW 25
13092: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
13093: LD_ADDR_EXP 84
13097: PUSH
13098: LD_STRING Petrovova
13100: PPUSH
13101: CALL_OW 25
13105: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
13106: LD_ADDR_EXP 85
13110: PUSH
13111: LD_STRING Kuzmov
13113: PPUSH
13114: CALL_OW 25
13118: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
13119: LD_ADDR_EXP 92
13123: PUSH
13124: LD_STRING Karamazov
13126: PPUSH
13127: CALL_OW 25
13131: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
13132: LD_STRING 13_Lipshchin_1
13134: PPUSH
13135: LD_INT 0
13137: PPUSH
13138: CALL_OW 30
13142: IFFALSE 13157
// Lipshchin := NewCharacter ( Lipshchin ) ;
13144: LD_ADDR_EXP 86
13148: PUSH
13149: LD_STRING Lipshchin
13151: PPUSH
13152: CALL_OW 25
13156: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
13157: LD_STRING 13_Titov_1
13159: PPUSH
13160: LD_INT 0
13162: PPUSH
13163: CALL_OW 30
13167: IFFALSE 13182
// Titov := NewCharacter ( Titov ) ;
13169: LD_ADDR_EXP 88
13173: PUSH
13174: LD_STRING Titov
13176: PPUSH
13177: CALL_OW 25
13181: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
13182: LD_STRING 13_Gnyevko_1
13184: PPUSH
13185: LD_INT 0
13187: PPUSH
13188: CALL_OW 30
13192: IFFALSE 13207
// Gnyevko := NewCharacter ( Gnyevko ) ;
13194: LD_ADDR_EXP 87
13198: PUSH
13199: LD_STRING Gnyevko
13201: PPUSH
13202: CALL_OW 25
13206: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
13207: LD_STRING 13_Xavier_1
13209: PPUSH
13210: LD_INT 0
13212: PPUSH
13213: CALL_OW 30
13217: IFFALSE 13232
// Xavier := NewCharacter ( Xavier2 ) ;
13219: LD_ADDR_EXP 89
13223: PUSH
13224: LD_STRING Xavier2
13226: PPUSH
13227: CALL_OW 25
13231: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
13232: LD_STRING 13_Belkov_1
13234: PPUSH
13235: LD_INT 0
13237: PPUSH
13238: CALL_OW 30
13242: IFFALSE 13257
// Belkov := NewCharacter ( Belkov ) ;
13244: LD_ADDR_EXP 90
13248: PUSH
13249: LD_STRING Belkov
13251: PPUSH
13252: CALL_OW 25
13256: ST_TO_ADDR
// if not BurlakStatus then
13257: LD_EXP 9
13261: NOT
13262: IFFALSE 13277
// Burlak = NewCharacter ( Burlak ) ;
13264: LD_ADDR_EXP 91
13268: PUSH
13269: LD_STRING Burlak
13271: PPUSH
13272: CALL_OW 25
13276: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
13277: LD_ADDR_VAR 0 3
13281: PUSH
13282: LD_EXP 79
13286: PUSH
13287: LD_EXP 81
13291: PUSH
13292: LD_EXP 95
13296: PUSH
13297: LD_EXP 82
13301: PUSH
13302: LD_EXP 83
13306: PUSH
13307: LD_EXP 94
13311: PUSH
13312: LD_EXP 93
13316: PUSH
13317: LD_EXP 84
13321: PUSH
13322: LD_EXP 85
13326: PUSH
13327: LD_EXP 92
13331: PUSH
13332: EMPTY
13333: LIST
13334: LIST
13335: LIST
13336: LIST
13337: LIST
13338: LIST
13339: LIST
13340: LIST
13341: LIST
13342: LIST
13343: ST_TO_ADDR
// if Simms then
13344: LD_EXP 80
13348: IFFALSE 13366
// tmp := tmp ^ Simms ;
13350: LD_ADDR_VAR 0 3
13354: PUSH
13355: LD_VAR 0 3
13359: PUSH
13360: LD_EXP 80
13364: ADD
13365: ST_TO_ADDR
// if Titov then
13366: LD_EXP 88
13370: IFFALSE 13388
// tmp := tmp ^ Titov ;
13372: LD_ADDR_VAR 0 3
13376: PUSH
13377: LD_VAR 0 3
13381: PUSH
13382: LD_EXP 88
13386: ADD
13387: ST_TO_ADDR
// if Lipshchin then
13388: LD_EXP 86
13392: IFFALSE 13410
// tmp := tmp ^ Lipshchin ;
13394: LD_ADDR_VAR 0 3
13398: PUSH
13399: LD_VAR 0 3
13403: PUSH
13404: LD_EXP 86
13408: ADD
13409: ST_TO_ADDR
// if Gnyevko then
13410: LD_EXP 87
13414: IFFALSE 13432
// tmp := tmp ^ Gnyevko ;
13416: LD_ADDR_VAR 0 3
13420: PUSH
13421: LD_VAR 0 3
13425: PUSH
13426: LD_EXP 87
13430: ADD
13431: ST_TO_ADDR
// if Xavier then
13432: LD_EXP 89
13436: IFFALSE 13454
// tmp := tmp ^ Xavier ;
13438: LD_ADDR_VAR 0 3
13442: PUSH
13443: LD_VAR 0 3
13447: PUSH
13448: LD_EXP 89
13452: ADD
13453: ST_TO_ADDR
// if Belkov then
13454: LD_EXP 90
13458: IFFALSE 13476
// tmp := tmp ^ Belkov ;
13460: LD_ADDR_VAR 0 3
13464: PUSH
13465: LD_VAR 0 3
13469: PUSH
13470: LD_EXP 90
13474: ADD
13475: ST_TO_ADDR
// if Burlak then
13476: LD_EXP 91
13480: IFFALSE 13498
// tmp := tmp ^ Burlak ;
13482: LD_ADDR_VAR 0 3
13486: PUSH
13487: LD_VAR 0 3
13491: PUSH
13492: LD_EXP 91
13496: ADD
13497: ST_TO_ADDR
// for i = 1 to 11 do
13498: LD_ADDR_VAR 0 2
13502: PUSH
13503: DOUBLE
13504: LD_INT 1
13506: DEC
13507: ST_TO_ADDR
13508: LD_INT 11
13510: PUSH
13511: FOR_TO
13512: IFFALSE 13580
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
13514: LD_ADDR_OWVAR 21
13518: PUSH
13519: LD_INT 1
13521: PUSH
13522: LD_INT 3
13524: PUSH
13525: EMPTY
13526: LIST
13527: LIST
13528: PUSH
13529: LD_INT 1
13531: PPUSH
13532: LD_INT 2
13534: PPUSH
13535: CALL_OW 12
13539: ARRAY
13540: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 10 ) ;
13541: LD_INT 0
13543: PPUSH
13544: LD_INT 1
13546: PPUSH
13547: LD_INT 4
13549: PPUSH
13550: CALL_OW 12
13554: PPUSH
13555: LD_INT 10
13557: PPUSH
13558: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
13562: LD_ADDR_VAR 0 3
13566: PUSH
13567: LD_VAR 0 3
13571: PUSH
13572: CALL_OW 44
13576: ADD
13577: ST_TO_ADDR
// end ;
13578: GO 13511
13580: POP
13581: POP
// for i in tmp do
13582: LD_ADDR_VAR 0 2
13586: PUSH
13587: LD_VAR 0 3
13591: PUSH
13592: FOR_IN
13593: IFFALSE 13618
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
13595: LD_VAR 0 2
13599: PPUSH
13600: LD_INT 260
13602: PPUSH
13603: LD_INT 235
13605: PPUSH
13606: LD_INT 8
13608: PPUSH
13609: LD_INT 0
13611: PPUSH
13612: CALL_OW 50
13616: GO 13592
13618: POP
13619: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
13620: LD_ADDR_EXP 102
13624: PUSH
13625: LD_EXP 102
13629: PPUSH
13630: LD_INT 1
13632: PPUSH
13633: LD_INT 22
13635: PUSH
13636: LD_VAR 0 5
13640: PUSH
13641: EMPTY
13642: LIST
13643: LIST
13644: PUSH
13645: LD_INT 3
13647: PUSH
13648: LD_INT 21
13650: PUSH
13651: LD_INT 2
13653: PUSH
13654: EMPTY
13655: LIST
13656: LIST
13657: PUSH
13658: EMPTY
13659: LIST
13660: LIST
13661: PUSH
13662: EMPTY
13663: LIST
13664: LIST
13665: PPUSH
13666: CALL_OW 69
13670: PUSH
13671: LD_EXP 79
13675: PUSH
13676: LD_EXP 80
13680: PUSH
13681: EMPTY
13682: LIST
13683: LIST
13684: DIFF
13685: PPUSH
13686: CALL_OW 1
13690: ST_TO_ADDR
// uc_side := 0 ;
13691: LD_ADDR_OWVAR 20
13695: PUSH
13696: LD_INT 0
13698: ST_TO_ADDR
// uc_nation := 0 ;
13699: LD_ADDR_OWVAR 21
13703: PUSH
13704: LD_INT 0
13706: ST_TO_ADDR
// for i = 1 to 5 do
13707: LD_ADDR_VAR 0 2
13711: PUSH
13712: DOUBLE
13713: LD_INT 1
13715: DEC
13716: ST_TO_ADDR
13717: LD_INT 5
13719: PUSH
13720: FOR_TO
13721: IFFALSE 13758
// begin InitHc ;
13723: CALL_OW 19
// hc_class := class_apeman ;
13727: LD_ADDR_OWVAR 28
13731: PUSH
13732: LD_INT 12
13734: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
13735: CALL_OW 44
13739: PPUSH
13740: LD_INT 299
13742: PPUSH
13743: LD_INT 229
13745: PPUSH
13746: LD_INT 10
13748: PPUSH
13749: LD_INT 0
13751: PPUSH
13752: CALL_OW 50
// end ;
13756: GO 13720
13758: POP
13759: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
13760: LD_EXP 79
13764: PPUSH
13765: LD_INT 259
13767: PPUSH
13768: LD_INT 235
13770: PPUSH
13771: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
13775: LD_EXP 79
13779: PPUSH
13780: LD_INT 262
13782: PPUSH
13783: LD_INT 235
13785: PPUSH
13786: CALL_OW 178
// if Simms then
13790: LD_EXP 80
13794: IFFALSE 13825
// begin ComMoveXY ( Simms , 262 , 235 ) ;
13796: LD_EXP 80
13800: PPUSH
13801: LD_INT 262
13803: PPUSH
13804: LD_INT 235
13806: PPUSH
13807: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
13811: LD_EXP 80
13815: PPUSH
13816: LD_EXP 79
13820: PPUSH
13821: CALL_OW 179
// end ; uc_side := 7 ;
13825: LD_ADDR_OWVAR 20
13829: PUSH
13830: LD_INT 7
13832: ST_TO_ADDR
// uc_nation := 1 ;
13833: LD_ADDR_OWVAR 21
13837: PUSH
13838: LD_INT 1
13840: ST_TO_ADDR
// bc_type := b_control_tower ;
13841: LD_ADDR_OWVAR 42
13845: PUSH
13846: LD_INT 36
13848: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 268 , 251 , 4 ) ;
13849: LD_ADDR_VAR 0 7
13853: PUSH
13854: LD_INT 268
13856: PPUSH
13857: LD_INT 251
13859: PPUSH
13860: LD_INT 4
13862: PPUSH
13863: CALL_OW 47
13867: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
13868: LD_INT 0
13870: PPUSH
13871: LD_INT 10
13873: PPUSH
13874: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , b ) ;
13878: CALL_OW 44
13882: PPUSH
13883: LD_VAR 0 7
13887: PPUSH
13888: CALL_OW 52
// end ;
13892: LD_VAR 0 1
13896: RET
// every 9 9$00 trigger allianceActive and not allianceDestroyed and FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_lab_full ] ] ) do var i , tmp , target ;
13897: LD_EXP 31
13901: PUSH
13902: LD_EXP 23
13906: NOT
13907: AND
13908: PUSH
13909: LD_INT 22
13911: PUSH
13912: LD_INT 7
13914: PUSH
13915: EMPTY
13916: LIST
13917: LIST
13918: PUSH
13919: LD_INT 30
13921: PUSH
13922: LD_INT 8
13924: PUSH
13925: EMPTY
13926: LIST
13927: LIST
13928: PUSH
13929: EMPTY
13930: LIST
13931: LIST
13932: PPUSH
13933: CALL_OW 69
13937: AND
13938: IFFALSE 14166
13940: GO 13942
13942: DISABLE
13943: LD_INT 0
13945: PPUSH
13946: PPUSH
13947: PPUSH
// begin enable ;
13948: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
13949: LD_ADDR_VAR 0 2
13953: PUSH
13954: LD_INT 81
13956: PUSH
13957: LD_INT 7
13959: PUSH
13960: EMPTY
13961: LIST
13962: LIST
13963: PUSH
13964: LD_INT 2
13966: PUSH
13967: LD_INT 32
13969: PUSH
13970: LD_INT 3
13972: PUSH
13973: EMPTY
13974: LIST
13975: LIST
13976: PUSH
13977: LD_INT 30
13979: PUSH
13980: LD_INT 30
13982: PUSH
13983: EMPTY
13984: LIST
13985: LIST
13986: PUSH
13987: LD_INT 30
13989: PUSH
13990: LD_INT 28
13992: PUSH
13993: EMPTY
13994: LIST
13995: LIST
13996: PUSH
13997: LD_INT 34
13999: PUSH
14000: LD_INT 49
14002: PUSH
14003: EMPTY
14004: LIST
14005: LIST
14006: PUSH
14007: LD_INT 34
14009: PUSH
14010: LD_INT 10
14012: PUSH
14013: EMPTY
14014: LIST
14015: LIST
14016: PUSH
14017: LD_INT 34
14019: PUSH
14020: LD_INT 8
14022: PUSH
14023: EMPTY
14024: LIST
14025: LIST
14026: PUSH
14027: EMPTY
14028: LIST
14029: LIST
14030: LIST
14031: LIST
14032: LIST
14033: LIST
14034: LIST
14035: PUSH
14036: EMPTY
14037: LIST
14038: LIST
14039: PPUSH
14040: CALL_OW 69
14044: ST_TO_ADDR
// if not tmp then
14045: LD_VAR 0 2
14049: NOT
14050: IFFALSE 14054
// exit ;
14052: GO 14166
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
14054: LD_VAR 0 2
14058: PPUSH
14059: LD_INT 34
14061: PUSH
14062: LD_INT 8
14064: PUSH
14065: EMPTY
14066: LIST
14067: LIST
14068: PPUSH
14069: CALL_OW 72
14073: IFFALSE 14106
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
14075: LD_ADDR_VAR 0 3
14079: PUSH
14080: LD_VAR 0 2
14084: PPUSH
14085: LD_INT 34
14087: PUSH
14088: LD_INT 8
14090: PUSH
14091: EMPTY
14092: LIST
14093: LIST
14094: PPUSH
14095: CALL_OW 72
14099: PUSH
14100: LD_INT 1
14102: ARRAY
14103: ST_TO_ADDR
14104: GO 14130
// target := tmp [ rand ( 1 , tmp ) ] ;
14106: LD_ADDR_VAR 0 3
14110: PUSH
14111: LD_VAR 0 2
14115: PUSH
14116: LD_INT 1
14118: PPUSH
14119: LD_VAR 0 2
14123: PPUSH
14124: CALL_OW 12
14128: ARRAY
14129: ST_TO_ADDR
// if GetSide ( target ) = 1 then
14130: LD_VAR 0 3
14134: PPUSH
14135: CALL_OW 255
14139: PUSH
14140: LD_INT 1
14142: EQUAL
14143: IFFALSE 14154
// CenterNowOnUnits ( target ) ;
14145: LD_VAR 0 3
14149: PPUSH
14150: CALL_OW 87
// SetLives ( target , 0 ) ;
14154: LD_VAR 0 3
14158: PPUSH
14159: LD_INT 0
14161: PPUSH
14162: CALL_OW 234
// end ;
14166: PPOPN 3
14168: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
14169: LD_EXP 23
14173: NOT
14174: PUSH
14175: LD_EXP 31
14179: AND
14180: IFFALSE 14696
14182: GO 14184
14184: DISABLE
14185: LD_INT 0
14187: PPUSH
14188: PPUSH
14189: PPUSH
// begin uc_side := 7 ;
14190: LD_ADDR_OWVAR 20
14194: PUSH
14195: LD_INT 7
14197: ST_TO_ADDR
// uc_nation := 1 ;
14198: LD_ADDR_OWVAR 21
14202: PUSH
14203: LD_INT 1
14205: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] , [ 94 , 114 ] ] ) ;
14206: LD_ADDR_VAR 0 3
14210: PUSH
14211: LD_INT 125
14213: PUSH
14214: LD_INT 163
14216: PUSH
14217: EMPTY
14218: LIST
14219: LIST
14220: PUSH
14221: LD_INT 185
14223: PUSH
14224: LD_INT 168
14226: PUSH
14227: EMPTY
14228: LIST
14229: LIST
14230: PUSH
14231: LD_INT 111
14233: PUSH
14234: LD_INT 97
14236: PUSH
14237: EMPTY
14238: LIST
14239: LIST
14240: PUSH
14241: LD_INT 94
14243: PUSH
14244: LD_INT 114
14246: PUSH
14247: EMPTY
14248: LIST
14249: LIST
14250: PUSH
14251: EMPTY
14252: LIST
14253: LIST
14254: LIST
14255: LIST
14256: PPUSH
14257: CALL 108196 0 1
14261: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
14262: LD_ADDR_EXP 96
14266: PUSH
14267: EMPTY
14268: ST_TO_ADDR
// for i = 1 to Difficulty do
14269: LD_ADDR_VAR 0 1
14273: PUSH
14274: DOUBLE
14275: LD_INT 1
14277: DEC
14278: ST_TO_ADDR
14279: LD_OWVAR 67
14283: PUSH
14284: FOR_TO
14285: IFFALSE 14443
// begin InitHc ;
14287: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
14291: LD_INT 0
14293: PPUSH
14294: LD_INT 8
14296: PPUSH
14297: CALL_OW 381
// un := CreateHuman ;
14301: LD_ADDR_VAR 0 2
14305: PUSH
14306: CALL_OW 44
14310: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
14311: LD_VAR 0 2
14315: PPUSH
14316: LD_INT 258
14318: PPUSH
14319: LD_INT 267
14321: PPUSH
14322: LD_INT 4
14324: PPUSH
14325: LD_INT 0
14327: PPUSH
14328: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
14332: LD_ADDR_EXP 96
14336: PUSH
14337: LD_EXP 96
14341: PUSH
14342: LD_VAR 0 2
14346: UNION
14347: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
14348: LD_VAR 0 2
14352: PPUSH
14353: LD_VAR 0 3
14357: PUSH
14358: LD_VAR 0 1
14362: ARRAY
14363: PUSH
14364: LD_INT 1
14366: ARRAY
14367: PPUSH
14368: LD_VAR 0 3
14372: PUSH
14373: LD_VAR 0 1
14377: ARRAY
14378: PUSH
14379: LD_INT 2
14381: ARRAY
14382: PPUSH
14383: LD_INT 4
14385: PPUSH
14386: LD_INT 1
14388: PPUSH
14389: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
14393: LD_VAR 0 2
14397: PPUSH
14398: LD_VAR 0 3
14402: PUSH
14403: LD_VAR 0 1
14407: ARRAY
14408: PUSH
14409: LD_INT 1
14411: ARRAY
14412: PPUSH
14413: LD_VAR 0 3
14417: PUSH
14418: LD_VAR 0 1
14422: ARRAY
14423: PUSH
14424: LD_INT 2
14426: ARRAY
14427: PPUSH
14428: CALL_OW 171
// AddComInvisible ( un ) ;
14432: LD_VAR 0 2
14436: PPUSH
14437: CALL_OW 212
// end ;
14441: GO 14284
14443: POP
14444: POP
// repeat wait ( 0 0$45 ) ;
14445: LD_INT 1575
14447: PPUSH
14448: CALL_OW 67
// for i in allianceSpecialForce do
14452: LD_ADDR_VAR 0 1
14456: PUSH
14457: LD_EXP 96
14461: PUSH
14462: FOR_IN
14463: IFFALSE 14681
// begin if IsInvisible ( i ) then
14465: LD_VAR 0 1
14469: PPUSH
14470: CALL_OW 571
14474: IFFALSE 14650
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , 25 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
14476: LD_ADDR_VAR 0 3
14480: PUSH
14481: LD_INT 22
14483: PUSH
14484: LD_INT 1
14486: PUSH
14487: EMPTY
14488: LIST
14489: LIST
14490: PUSH
14491: LD_INT 50
14493: PUSH
14494: EMPTY
14495: LIST
14496: PUSH
14497: LD_INT 56
14499: PUSH
14500: EMPTY
14501: LIST
14502: PUSH
14503: LD_INT 91
14505: PUSH
14506: LD_VAR 0 1
14510: PUSH
14511: LD_INT 25
14513: PUSH
14514: EMPTY
14515: LIST
14516: LIST
14517: LIST
14518: PUSH
14519: LD_INT 2
14521: PUSH
14522: LD_INT 25
14524: PUSH
14525: LD_INT 1
14527: PUSH
14528: EMPTY
14529: LIST
14530: LIST
14531: PUSH
14532: LD_INT 25
14534: PUSH
14535: LD_INT 2
14537: PUSH
14538: EMPTY
14539: LIST
14540: LIST
14541: PUSH
14542: LD_INT 25
14544: PUSH
14545: LD_INT 3
14547: PUSH
14548: EMPTY
14549: LIST
14550: LIST
14551: PUSH
14552: LD_INT 25
14554: PUSH
14555: LD_INT 4
14557: PUSH
14558: EMPTY
14559: LIST
14560: LIST
14561: PUSH
14562: LD_INT 25
14564: PUSH
14565: LD_INT 5
14567: PUSH
14568: EMPTY
14569: LIST
14570: LIST
14571: PUSH
14572: LD_INT 25
14574: PUSH
14575: LD_INT 8
14577: PUSH
14578: EMPTY
14579: LIST
14580: LIST
14581: PUSH
14582: EMPTY
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: LIST
14589: LIST
14590: PUSH
14591: EMPTY
14592: LIST
14593: LIST
14594: LIST
14595: LIST
14596: LIST
14597: PPUSH
14598: CALL_OW 69
14602: ST_TO_ADDR
// if not tmp then
14603: LD_VAR 0 3
14607: NOT
14608: IFFALSE 14612
// continue ;
14610: GO 14462
// if Prob ( 30 * Difficulty ) then
14612: LD_INT 30
14614: PUSH
14615: LD_OWVAR 67
14619: MUL
14620: PPUSH
14621: CALL_OW 13
14625: IFFALSE 14650
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
14627: LD_VAR 0 3
14631: PUSH
14632: LD_INT 1
14634: PPUSH
14635: LD_VAR 0 3
14639: PPUSH
14640: CALL_OW 12
14644: ARRAY
14645: PPUSH
14646: CALL 35386 0 1
// end ; if IsDead ( i ) then
14650: LD_VAR 0 1
14654: PPUSH
14655: CALL_OW 301
14659: IFFALSE 14679
// begin allianceSpecialForce := allianceSpecialForce diff i ;
14661: LD_ADDR_EXP 96
14665: PUSH
14666: LD_EXP 96
14670: PUSH
14671: LD_VAR 0 1
14675: DIFF
14676: ST_TO_ADDR
// continue ;
14677: GO 14462
// end ; end ;
14679: GO 14462
14681: POP
14682: POP
// until allianceDestroyed or not allianceSpecialForce ;
14683: LD_EXP 23
14687: PUSH
14688: LD_EXP 96
14692: NOT
14693: OR
14694: IFFALSE 14445
// end ;
14696: PPOPN 3
14698: END
// every 0 0$30 trigger allianceActive and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_bweapon , us_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ] ) do var i , un , tmp , e ;
14699: LD_EXP 31
14703: PUSH
14704: LD_INT 22
14706: PUSH
14707: LD_INT 1
14709: PUSH
14710: EMPTY
14711: LIST
14712: LIST
14713: PUSH
14714: LD_INT 2
14716: PUSH
14717: LD_INT 35
14719: PUSH
14720: LD_INT 8
14722: PUSH
14723: EMPTY
14724: LIST
14725: LIST
14726: PUSH
14727: LD_INT 34
14729: PUSH
14730: LD_INT 8
14732: PUSH
14733: EMPTY
14734: LIST
14735: LIST
14736: PUSH
14737: EMPTY
14738: LIST
14739: LIST
14740: LIST
14741: PUSH
14742: EMPTY
14743: LIST
14744: LIST
14745: PPUSH
14746: CALL_OW 69
14750: AND
14751: IFFALSE 15151
14753: GO 14755
14755: DISABLE
14756: LD_INT 0
14758: PPUSH
14759: PPUSH
14760: PPUSH
14761: PPUSH
// begin for i := 1 to [ 6 , 8 , 10 , 12 ] [ Difficulty ] do
14762: LD_ADDR_VAR 0 1
14766: PUSH
14767: DOUBLE
14768: LD_INT 1
14770: DEC
14771: ST_TO_ADDR
14772: LD_INT 6
14774: PUSH
14775: LD_INT 8
14777: PUSH
14778: LD_INT 10
14780: PUSH
14781: LD_INT 12
14783: PUSH
14784: EMPTY
14785: LIST
14786: LIST
14787: LIST
14788: LIST
14789: PUSH
14790: LD_OWVAR 67
14794: ARRAY
14795: PUSH
14796: FOR_TO
14797: IFFALSE 14989
// begin uc_side := 7 ;
14799: LD_ADDR_OWVAR 20
14803: PUSH
14804: LD_INT 7
14806: ST_TO_ADDR
// uc_nation := 1 ;
14807: LD_ADDR_OWVAR 21
14811: PUSH
14812: LD_INT 1
14814: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , [ control_remote , control_computer ] [ rand ( 1 , 2 ) ] , [ us_heavy_gun , us_laser ] [ rand ( 1 , 2 ) ] , 100 ) ;
14815: LD_INT 5
14817: PPUSH
14818: LD_INT 3
14820: PPUSH
14821: LD_INT 2
14823: PUSH
14824: LD_INT 3
14826: PUSH
14827: EMPTY
14828: LIST
14829: LIST
14830: PUSH
14831: LD_INT 1
14833: PPUSH
14834: LD_INT 2
14836: PPUSH
14837: CALL_OW 12
14841: ARRAY
14842: PPUSH
14843: LD_INT 6
14845: PUSH
14846: LD_INT 9
14848: PUSH
14849: EMPTY
14850: LIST
14851: LIST
14852: PUSH
14853: LD_INT 1
14855: PPUSH
14856: LD_INT 2
14858: PPUSH
14859: CALL_OW 12
14863: ARRAY
14864: PPUSH
14865: LD_INT 100
14867: PPUSH
14868: CALL 75220 0 5
// un := CreateVehicle ;
14872: LD_ADDR_VAR 0 2
14876: PUSH
14877: CALL_OW 45
14881: ST_TO_ADDR
// SetDir ( un , 4 ) ;
14882: LD_VAR 0 2
14886: PPUSH
14887: LD_INT 4
14889: PPUSH
14890: CALL_OW 233
// PlaceUnitXYR ( un , 307 , 219 , 6 , false ) ;
14894: LD_VAR 0 2
14898: PPUSH
14899: LD_INT 307
14901: PPUSH
14902: LD_INT 219
14904: PPUSH
14905: LD_INT 6
14907: PPUSH
14908: LD_INT 0
14910: PPUSH
14911: CALL_OW 50
// if GetControl ( un ) = control_remote then
14915: LD_VAR 0 2
14919: PPUSH
14920: CALL_OW 263
14924: PUSH
14925: LD_INT 2
14927: EQUAL
14928: IFFALSE 14939
// Connect ( un ) ;
14930: LD_VAR 0 2
14934: PPUSH
14935: CALL 78688 0 1
// TeleportUnit ( un , 124 , 92 , 12 , true ) ;
14939: LD_VAR 0 2
14943: PPUSH
14944: LD_INT 124
14946: PPUSH
14947: LD_INT 92
14949: PPUSH
14950: LD_INT 12
14952: PPUSH
14953: LD_INT 1
14955: PPUSH
14956: CALL_OW 483
// tmp := Join ( tmp , un ) ;
14960: LD_ADDR_VAR 0 3
14964: PUSH
14965: LD_VAR 0 3
14969: PPUSH
14970: LD_VAR 0 2
14974: PPUSH
14975: CALL 108091 0 2
14979: ST_TO_ADDR
// wait ( 0 0$0.3 ) ;
14980: LD_INT 10
14982: PPUSH
14983: CALL_OW 67
// end ;
14987: GO 14796
14989: POP
14990: POP
// repeat wait ( 0 0$2 ) ;
14991: LD_INT 70
14993: PPUSH
14994: CALL_OW 67
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) ;
14998: LD_ADDR_VAR 0 4
15002: PUSH
15003: LD_INT 22
15005: PUSH
15006: LD_INT 1
15008: PUSH
15009: EMPTY
15010: LIST
15011: LIST
15012: PUSH
15013: LD_INT 34
15015: PUSH
15016: LD_INT 8
15018: PUSH
15019: EMPTY
15020: LIST
15021: LIST
15022: PUSH
15023: EMPTY
15024: LIST
15025: LIST
15026: PPUSH
15027: CALL_OW 69
15031: ST_TO_ADDR
// if not e then
15032: LD_VAR 0 4
15036: NOT
15037: IFFALSE 15073
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
15039: LD_ADDR_VAR 0 4
15043: PUSH
15044: LD_INT 22
15046: PUSH
15047: LD_INT 1
15049: PUSH
15050: EMPTY
15051: LIST
15052: LIST
15053: PUSH
15054: LD_INT 21
15056: PUSH
15057: LD_INT 2
15059: PUSH
15060: EMPTY
15061: LIST
15062: LIST
15063: PUSH
15064: EMPTY
15065: LIST
15066: LIST
15067: PPUSH
15068: CALL_OW 69
15072: ST_TO_ADDR
// for i in tmp do
15073: LD_ADDR_VAR 0 1
15077: PUSH
15078: LD_VAR 0 3
15082: PUSH
15083: FOR_IN
15084: IFFALSE 15142
// if not IsOK ( i ) then
15086: LD_VAR 0 1
15090: PPUSH
15091: CALL_OW 302
15095: NOT
15096: IFFALSE 15116
// tmp := tmp diff i else
15098: LD_ADDR_VAR 0 3
15102: PUSH
15103: LD_VAR 0 3
15107: PUSH
15108: LD_VAR 0 1
15112: DIFF
15113: ST_TO_ADDR
15114: GO 15140
// ComAttackUnit ( i , NearestUnitToUnit ( e , i ) ) ;
15116: LD_VAR 0 1
15120: PPUSH
15121: LD_VAR 0 4
15125: PPUSH
15126: LD_VAR 0 1
15130: PPUSH
15131: CALL_OW 74
15135: PPUSH
15136: CALL_OW 115
15140: GO 15083
15142: POP
15143: POP
// until not tmp ;
15144: LD_VAR 0 3
15148: NOT
15149: IFFALSE 14991
// end ;
15151: PPOPN 4
15153: END
// every 8 8$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport , p ;
15154: LD_EXP 23
15158: NOT
15159: PUSH
15160: LD_EXP 31
15164: AND
15165: IFFALSE 16239
15167: GO 15169
15169: DISABLE
15170: LD_INT 0
15172: PPUSH
15173: PPUSH
15174: PPUSH
15175: PPUSH
15176: PPUSH
// begin enable ;
15177: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
15178: LD_INT 22
15180: PUSH
15181: LD_INT 7
15183: PUSH
15184: EMPTY
15185: LIST
15186: LIST
15187: PUSH
15188: LD_INT 30
15190: PUSH
15191: LD_INT 3
15193: PUSH
15194: EMPTY
15195: LIST
15196: LIST
15197: PUSH
15198: EMPTY
15199: LIST
15200: LIST
15201: PPUSH
15202: CALL_OW 69
15206: NOT
15207: IFFALSE 15211
// exit ;
15209: GO 16239
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
15211: LD_ADDR_VAR 0 4
15215: PUSH
15216: LD_INT 22
15218: PUSH
15219: LD_INT 7
15221: PUSH
15222: EMPTY
15223: LIST
15224: LIST
15225: PUSH
15226: LD_INT 30
15228: PUSH
15229: LD_INT 34
15231: PUSH
15232: EMPTY
15233: LIST
15234: LIST
15235: PUSH
15236: EMPTY
15237: LIST
15238: LIST
15239: PPUSH
15240: CALL_OW 69
15244: ST_TO_ADDR
// if Prob ( 40 ) then
15245: LD_INT 40
15247: PPUSH
15248: CALL_OW 13
15252: IFFALSE 15398
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
15254: LD_INT 1
15256: PPUSH
15257: LD_INT 5
15259: PUSH
15260: LD_INT 3
15262: PUSH
15263: LD_INT 2
15265: PUSH
15266: LD_INT 6
15268: PUSH
15269: EMPTY
15270: LIST
15271: LIST
15272: LIST
15273: LIST
15274: PUSH
15275: LD_INT 5
15277: PUSH
15278: LD_INT 3
15280: PUSH
15281: LD_INT 2
15283: PUSH
15284: LD_INT 6
15286: PUSH
15287: EMPTY
15288: LIST
15289: LIST
15290: LIST
15291: LIST
15292: PUSH
15293: LD_INT 5
15295: PUSH
15296: LD_INT 3
15298: PUSH
15299: LD_INT 2
15301: PUSH
15302: LD_INT 6
15304: PUSH
15305: EMPTY
15306: LIST
15307: LIST
15308: LIST
15309: LIST
15310: PUSH
15311: LD_INT 5
15313: PUSH
15314: LD_INT 3
15316: PUSH
15317: LD_INT 2
15319: PUSH
15320: LD_INT 9
15322: PUSH
15323: EMPTY
15324: LIST
15325: LIST
15326: LIST
15327: LIST
15328: PUSH
15329: LD_INT 24
15331: PUSH
15332: LD_INT 3
15334: PUSH
15335: LD_INT 3
15337: PUSH
15338: LD_INT 45
15340: PUSH
15341: EMPTY
15342: LIST
15343: LIST
15344: LIST
15345: LIST
15346: PUSH
15347: LD_INT 24
15349: PUSH
15350: LD_INT 3
15352: PUSH
15353: LD_INT 3
15355: PUSH
15356: LD_INT 47
15358: PUSH
15359: EMPTY
15360: LIST
15361: LIST
15362: LIST
15363: LIST
15364: PUSH
15365: LD_INT 24
15367: PUSH
15368: LD_INT 3
15370: PUSH
15371: LD_INT 3
15373: PUSH
15374: LD_INT 45
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: LIST
15381: LIST
15382: PUSH
15383: EMPTY
15384: LIST
15385: LIST
15386: LIST
15387: LIST
15388: LIST
15389: LIST
15390: LIST
15391: PPUSH
15392: CALL 63870 0 2
// end else
15396: GO 15540
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
15398: LD_INT 1
15400: PPUSH
15401: LD_INT 24
15403: PUSH
15404: LD_INT 3
15406: PUSH
15407: LD_INT 3
15409: PUSH
15410: LD_INT 47
15412: PUSH
15413: EMPTY
15414: LIST
15415: LIST
15416: LIST
15417: LIST
15418: PUSH
15419: LD_INT 24
15421: PUSH
15422: LD_INT 3
15424: PUSH
15425: LD_INT 3
15427: PUSH
15428: LD_INT 47
15430: PUSH
15431: EMPTY
15432: LIST
15433: LIST
15434: LIST
15435: LIST
15436: PUSH
15437: LD_INT 5
15439: PUSH
15440: LD_INT 3
15442: PUSH
15443: LD_INT 2
15445: PUSH
15446: LD_INT 9
15448: PUSH
15449: EMPTY
15450: LIST
15451: LIST
15452: LIST
15453: LIST
15454: PUSH
15455: LD_INT 5
15457: PUSH
15458: LD_INT 3
15460: PUSH
15461: LD_INT 2
15463: PUSH
15464: LD_INT 9
15466: PUSH
15467: EMPTY
15468: LIST
15469: LIST
15470: LIST
15471: LIST
15472: PUSH
15473: LD_INT 5
15475: PUSH
15476: LD_INT 3
15478: PUSH
15479: LD_INT 2
15481: PUSH
15482: LD_INT 9
15484: PUSH
15485: EMPTY
15486: LIST
15487: LIST
15488: LIST
15489: LIST
15490: PUSH
15491: LD_INT 24
15493: PUSH
15494: LD_INT 1
15496: PUSH
15497: LD_INT 3
15499: PUSH
15500: LD_INT 45
15502: PUSH
15503: EMPTY
15504: LIST
15505: LIST
15506: LIST
15507: LIST
15508: PUSH
15509: LD_INT 24
15511: PUSH
15512: LD_INT 1
15514: PUSH
15515: LD_INT 3
15517: PUSH
15518: LD_INT 45
15520: PUSH
15521: EMPTY
15522: LIST
15523: LIST
15524: LIST
15525: LIST
15526: PUSH
15527: EMPTY
15528: LIST
15529: LIST
15530: LIST
15531: LIST
15532: LIST
15533: LIST
15534: LIST
15535: PPUSH
15536: CALL 63870 0 2
// end ; wait ( 2 2$00 ) ;
15540: LD_INT 4200
15542: PPUSH
15543: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_crane ] ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 1 ] ;
15547: LD_ADDR_VAR 0 2
15551: PUSH
15552: LD_INT 22
15554: PUSH
15555: LD_INT 7
15557: PUSH
15558: EMPTY
15559: LIST
15560: LIST
15561: PUSH
15562: LD_INT 21
15564: PUSH
15565: LD_INT 2
15567: PUSH
15568: EMPTY
15569: LIST
15570: LIST
15571: PUSH
15572: LD_INT 3
15574: PUSH
15575: LD_INT 34
15577: PUSH
15578: LD_INT 13
15580: PUSH
15581: EMPTY
15582: LIST
15583: LIST
15584: PUSH
15585: EMPTY
15586: LIST
15587: LIST
15588: PUSH
15589: LD_INT 3
15591: PUSH
15592: LD_INT 34
15594: PUSH
15595: LD_INT 12
15597: PUSH
15598: EMPTY
15599: LIST
15600: LIST
15601: PUSH
15602: EMPTY
15603: LIST
15604: LIST
15605: PUSH
15606: LD_INT 3
15608: PUSH
15609: LD_INT 34
15611: PUSH
15612: LD_INT 51
15614: PUSH
15615: EMPTY
15616: LIST
15617: LIST
15618: PUSH
15619: EMPTY
15620: LIST
15621: LIST
15622: PUSH
15623: LD_INT 3
15625: PUSH
15626: LD_INT 34
15628: PUSH
15629: LD_INT 52
15631: PUSH
15632: EMPTY
15633: LIST
15634: LIST
15635: PUSH
15636: EMPTY
15637: LIST
15638: LIST
15639: PUSH
15640: EMPTY
15641: LIST
15642: LIST
15643: LIST
15644: LIST
15645: LIST
15646: LIST
15647: PPUSH
15648: CALL_OW 69
15652: PUSH
15653: LD_EXP 124
15657: PUSH
15658: LD_INT 1
15660: ARRAY
15661: DIFF
15662: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
15663: LD_ADDR_EXP 121
15667: PUSH
15668: LD_EXP 121
15672: PPUSH
15673: LD_INT 1
15675: PPUSH
15676: LD_EXP 121
15680: PUSH
15681: LD_INT 1
15683: ARRAY
15684: PUSH
15685: LD_VAR 0 2
15689: DIFF
15690: PPUSH
15691: CALL_OW 1
15695: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
15696: LD_ADDR_VAR 0 3
15700: PUSH
15701: LD_INT 0
15703: PPUSH
15704: LD_INT 1
15706: PPUSH
15707: CALL_OW 12
15711: ST_TO_ADDR
// p := 0 ;
15712: LD_ADDR_VAR 0 5
15716: PUSH
15717: LD_INT 0
15719: ST_TO_ADDR
// if target then
15720: LD_VAR 0 3
15724: IFFALSE 15915
// begin for i in tmp do
15726: LD_ADDR_VAR 0 1
15730: PUSH
15731: LD_VAR 0 2
15735: PUSH
15736: FOR_IN
15737: IFFALSE 15762
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
15739: LD_VAR 0 1
15743: PPUSH
15744: LD_INT 179
15746: PPUSH
15747: LD_INT 209
15749: PPUSH
15750: LD_INT 8
15752: PPUSH
15753: LD_INT 1
15755: PPUSH
15756: CALL_OW 483
15760: GO 15736
15762: POP
15763: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15764: LD_ADDR_VAR 0 2
15768: PUSH
15769: LD_VAR 0 2
15773: PPUSH
15774: LD_INT 24
15776: PUSH
15777: LD_INT 250
15779: PUSH
15780: EMPTY
15781: LIST
15782: LIST
15783: PPUSH
15784: CALL_OW 72
15788: ST_TO_ADDR
// for i in tmp do
15789: LD_ADDR_VAR 0 1
15793: PUSH
15794: LD_VAR 0 2
15798: PUSH
15799: FOR_IN
15800: IFFALSE 15840
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
15802: LD_VAR 0 1
15806: PPUSH
15807: LD_INT 179
15809: PPUSH
15810: LD_INT 209
15812: PPUSH
15813: CALL_OW 297
15817: PUSH
15818: LD_INT 9
15820: GREATER
15821: IFFALSE 15838
// ComMoveXY ( i , 179 , 209 ) ;
15823: LD_VAR 0 1
15827: PPUSH
15828: LD_INT 179
15830: PPUSH
15831: LD_INT 209
15833: PPUSH
15834: CALL_OW 111
15838: GO 15799
15840: POP
15841: POP
// wait ( 0 0$1 ) ;
15842: LD_INT 35
15844: PPUSH
15845: CALL_OW 67
// p := Inc ( p ) ;
15849: LD_ADDR_VAR 0 5
15853: PUSH
15854: LD_VAR 0 5
15858: PPUSH
15859: CALL 109452 0 1
15863: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
15864: LD_VAR 0 2
15868: PPUSH
15869: LD_INT 92
15871: PUSH
15872: LD_INT 179
15874: PUSH
15875: LD_INT 209
15877: PUSH
15878: LD_INT 9
15880: PUSH
15881: EMPTY
15882: LIST
15883: LIST
15884: LIST
15885: LIST
15886: PPUSH
15887: CALL_OW 72
15891: PUSH
15892: LD_VAR 0 2
15896: PUSH
15897: LD_INT 1
15899: MINUS
15900: GREATEREQUAL
15901: PUSH
15902: LD_VAR 0 5
15906: PUSH
15907: LD_INT 30
15909: GREATER
15910: OR
15911: IFFALSE 15764
// end else
15913: GO 16102
// begin for i in tmp do
15915: LD_ADDR_VAR 0 1
15919: PUSH
15920: LD_VAR 0 2
15924: PUSH
15925: FOR_IN
15926: IFFALSE 15951
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
15928: LD_VAR 0 1
15932: PPUSH
15933: LD_INT 285
15935: PPUSH
15936: LD_INT 163
15938: PPUSH
15939: LD_INT 8
15941: PPUSH
15942: LD_INT 1
15944: PPUSH
15945: CALL_OW 483
15949: GO 15925
15951: POP
15952: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15953: LD_ADDR_VAR 0 2
15957: PUSH
15958: LD_VAR 0 2
15962: PPUSH
15963: LD_INT 24
15965: PUSH
15966: LD_INT 250
15968: PUSH
15969: EMPTY
15970: LIST
15971: LIST
15972: PPUSH
15973: CALL_OW 72
15977: ST_TO_ADDR
// for i in tmp do
15978: LD_ADDR_VAR 0 1
15982: PUSH
15983: LD_VAR 0 2
15987: PUSH
15988: FOR_IN
15989: IFFALSE 16029
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
15991: LD_VAR 0 1
15995: PPUSH
15996: LD_INT 285
15998: PPUSH
15999: LD_INT 163
16001: PPUSH
16002: CALL_OW 297
16006: PUSH
16007: LD_INT 9
16009: GREATER
16010: IFFALSE 16027
// ComMoveXY ( i , 285 , 163 ) ;
16012: LD_VAR 0 1
16016: PPUSH
16017: LD_INT 285
16019: PPUSH
16020: LD_INT 163
16022: PPUSH
16023: CALL_OW 111
16027: GO 15988
16029: POP
16030: POP
// wait ( 0 0$1 ) ;
16031: LD_INT 35
16033: PPUSH
16034: CALL_OW 67
// p := Inc ( p ) ;
16038: LD_ADDR_VAR 0 5
16042: PUSH
16043: LD_VAR 0 5
16047: PPUSH
16048: CALL 109452 0 1
16052: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
16053: LD_VAR 0 2
16057: PPUSH
16058: LD_INT 92
16060: PUSH
16061: LD_INT 285
16063: PUSH
16064: LD_INT 163
16066: PUSH
16067: LD_INT 9
16069: PUSH
16070: EMPTY
16071: LIST
16072: LIST
16073: LIST
16074: LIST
16075: PPUSH
16076: CALL_OW 72
16080: PUSH
16081: LD_VAR 0 2
16085: PUSH
16086: LD_INT 1
16088: MINUS
16089: GREATEREQUAL
16090: PUSH
16091: LD_VAR 0 5
16095: PUSH
16096: LD_INT 30
16098: GREATER
16099: OR
16100: IFFALSE 15953
// end ; repeat wait ( 0 0$1 ) ;
16102: LD_INT 35
16104: PPUSH
16105: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
16109: LD_ADDR_VAR 0 2
16113: PUSH
16114: LD_VAR 0 2
16118: PPUSH
16119: LD_INT 50
16121: PUSH
16122: EMPTY
16123: LIST
16124: PPUSH
16125: CALL_OW 72
16129: ST_TO_ADDR
// for i in tmp do
16130: LD_ADDR_VAR 0 1
16134: PUSH
16135: LD_VAR 0 2
16139: PUSH
16140: FOR_IN
16141: IFFALSE 16230
// if GetWeapon ( i ) = ru_time_lapser then
16143: LD_VAR 0 1
16147: PPUSH
16148: CALL_OW 264
16152: PUSH
16153: LD_INT 49
16155: EQUAL
16156: IFFALSE 16194
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
16158: LD_VAR 0 1
16162: PPUSH
16163: LD_INT 81
16165: PUSH
16166: LD_INT 7
16168: PUSH
16169: EMPTY
16170: LIST
16171: LIST
16172: PPUSH
16173: CALL_OW 69
16177: PPUSH
16178: LD_VAR 0 1
16182: PPUSH
16183: CALL_OW 74
16187: PPUSH
16188: CALL_OW 112
16192: GO 16228
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
16194: LD_VAR 0 1
16198: PPUSH
16199: LD_INT 81
16201: PUSH
16202: LD_INT 7
16204: PUSH
16205: EMPTY
16206: LIST
16207: LIST
16208: PPUSH
16209: CALL_OW 69
16213: PPUSH
16214: LD_VAR 0 1
16218: PPUSH
16219: CALL_OW 74
16223: PPUSH
16224: CALL_OW 115
16228: GO 16140
16230: POP
16231: POP
// until not tmp ;
16232: LD_VAR 0 2
16236: NOT
16237: IFFALSE 16102
// end ;
16239: PPOPN 5
16241: END
// every 1 1$30 trigger allianceActive and IsOk ( Roth ) and Difficulty > 2 do
16242: LD_EXP 31
16246: PUSH
16247: LD_EXP 79
16251: PPUSH
16252: CALL_OW 302
16256: AND
16257: PUSH
16258: LD_OWVAR 67
16262: PUSH
16263: LD_INT 2
16265: GREATER
16266: AND
16267: IFFALSE 16367
16269: GO 16271
16271: DISABLE
// begin enable ;
16272: ENABLE
// if GetDistUnitXY ( Roth , 245 , 234 ) > 6 then
16273: LD_EXP 79
16277: PPUSH
16278: LD_INT 245
16280: PPUSH
16281: LD_INT 234
16283: PPUSH
16284: CALL_OW 297
16288: PUSH
16289: LD_INT 6
16291: GREATER
16292: IFFALSE 16311
// ComMoveXY ( Roth , 245 , 234 ) else
16294: LD_EXP 79
16298: PPUSH
16299: LD_INT 245
16301: PPUSH
16302: LD_INT 234
16304: PPUSH
16305: CALL_OW 111
16309: GO 16367
// ComMoveHex ( Roth , [ [ 259 , 235 ] , [ 252 , 209 ] , [ 275 , 235 ] ] [ rand ( 1 , 3 ) ] ) ;
16311: LD_EXP 79
16315: PPUSH
16316: LD_INT 259
16318: PUSH
16319: LD_INT 235
16321: PUSH
16322: EMPTY
16323: LIST
16324: LIST
16325: PUSH
16326: LD_INT 252
16328: PUSH
16329: LD_INT 209
16331: PUSH
16332: EMPTY
16333: LIST
16334: LIST
16335: PUSH
16336: LD_INT 275
16338: PUSH
16339: LD_INT 235
16341: PUSH
16342: EMPTY
16343: LIST
16344: LIST
16345: PUSH
16346: EMPTY
16347: LIST
16348: LIST
16349: LIST
16350: PUSH
16351: LD_INT 1
16353: PPUSH
16354: LD_INT 3
16356: PPUSH
16357: CALL_OW 12
16361: ARRAY
16362: PPUSH
16363: CALL 112249 0 2
// end ; end_of_file
16367: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
16368: LD_INT 0
16370: PPUSH
16371: PPUSH
16372: PPUSH
16373: PPUSH
// missionStage := 13 ;
16374: LD_ADDR_EXP 15
16378: PUSH
16379: LD_INT 13
16381: ST_TO_ADDR
// uc_side := 2 ;
16382: LD_ADDR_OWVAR 20
16386: PUSH
16387: LD_INT 2
16389: ST_TO_ADDR
// uc_nation := 2 ;
16390: LD_ADDR_OWVAR 21
16394: PUSH
16395: LD_INT 2
16397: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
16398: LD_ADDR_EXP 97
16402: PUSH
16403: LD_STRING Omar
16405: PPUSH
16406: CALL_OW 25
16410: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
16411: LD_EXP 97
16415: PPUSH
16416: LD_INT 4
16418: PPUSH
16419: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
16423: LD_EXP 97
16427: PPUSH
16428: LD_INT 242
16430: PPUSH
16431: LD_INT 75
16433: PPUSH
16434: LD_INT 0
16436: PPUSH
16437: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
16441: LD_ADDR_EXP 98
16445: PUSH
16446: LD_STRING Heike
16448: PPUSH
16449: CALL_OW 25
16453: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
16454: LD_INT 14
16456: PPUSH
16457: LD_INT 3
16459: PPUSH
16460: LD_INT 1
16462: PPUSH
16463: LD_INT 27
16465: PPUSH
16466: LD_INT 100
16468: PPUSH
16469: CALL 75220 0 5
// veh := CreateVehicle ;
16473: LD_ADDR_VAR 0 3
16477: PUSH
16478: CALL_OW 45
16482: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
16483: LD_VAR 0 3
16487: PPUSH
16488: LD_INT 2
16490: NEG
16491: PPUSH
16492: CALL_OW 242
// SetDir ( veh , 4 ) ;
16496: LD_VAR 0 3
16500: PPUSH
16501: LD_INT 4
16503: PPUSH
16504: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
16508: LD_VAR 0 3
16512: PPUSH
16513: LD_INT 241
16515: PPUSH
16516: LD_INT 72
16518: PPUSH
16519: LD_INT 0
16521: PPUSH
16522: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
16526: LD_EXP 98
16530: PPUSH
16531: LD_VAR 0 3
16535: PPUSH
16536: CALL_OW 52
// if KhatamStatus then
16540: LD_EXP 8
16544: IFFALSE 16607
// begin Khatam := NewCharacter ( Khatam ) ;
16546: LD_ADDR_EXP 99
16550: PUSH
16551: LD_STRING Khatam
16553: PPUSH
16554: CALL_OW 25
16558: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
16559: LD_EXP 99
16563: PPUSH
16564: LD_INT 245
16566: PPUSH
16567: LD_INT 78
16569: PPUSH
16570: LD_INT 3
16572: PPUSH
16573: LD_INT 0
16575: PPUSH
16576: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
16580: LD_EXP 99
16584: PPUSH
16585: LD_INT 4
16587: PPUSH
16588: LD_INT 10
16590: PPUSH
16591: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
16595: LD_EXP 99
16599: PPUSH
16600: LD_INT 4
16602: PPUSH
16603: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
16607: LD_ADDR_VAR 0 2
16611: PUSH
16612: DOUBLE
16613: LD_INT 1
16615: DEC
16616: ST_TO_ADDR
16617: LD_INT 2
16619: PUSH
16620: LD_INT 2
16622: PUSH
16623: LD_INT 3
16625: PUSH
16626: LD_INT 3
16628: PUSH
16629: EMPTY
16630: LIST
16631: LIST
16632: LIST
16633: LIST
16634: PUSH
16635: LD_OWVAR 67
16639: ARRAY
16640: PUSH
16641: FOR_TO
16642: IFFALSE 16708
// begin PrepareScientist ( false , 6 + Difficulty ) ;
16644: LD_INT 0
16646: PPUSH
16647: LD_INT 6
16649: PUSH
16650: LD_OWVAR 67
16654: PLUS
16655: PPUSH
16656: CALL_OW 384
// un := CreateHuman ;
16660: LD_ADDR_VAR 0 4
16664: PUSH
16665: CALL_OW 44
16669: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
16670: LD_VAR 0 4
16674: PPUSH
16675: LD_INT 28
16677: PUSH
16678: LD_INT 29
16680: PUSH
16681: EMPTY
16682: LIST
16683: LIST
16684: PUSH
16685: LD_VAR 0 2
16689: PUSH
16690: LD_INT 2
16692: MOD
16693: PUSH
16694: LD_INT 1
16696: PLUS
16697: ARRAY
16698: PPUSH
16699: LD_INT 0
16701: PPUSH
16702: CALL_OW 49
// end ;
16706: GO 16641
16708: POP
16709: POP
// for i = 1 to 6 do
16710: LD_ADDR_VAR 0 2
16714: PUSH
16715: DOUBLE
16716: LD_INT 1
16718: DEC
16719: ST_TO_ADDR
16720: LD_INT 6
16722: PUSH
16723: FOR_TO
16724: IFFALSE 16769
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
16726: LD_INT 0
16728: PPUSH
16729: LD_INT 6
16731: PUSH
16732: LD_OWVAR 67
16736: PLUS
16737: PPUSH
16738: CALL_OW 381
// un := CreateHuman ;
16742: LD_ADDR_VAR 0 4
16746: PUSH
16747: CALL_OW 44
16751: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16752: LD_VAR 0 4
16756: PPUSH
16757: LD_INT 32
16759: PPUSH
16760: LD_INT 0
16762: PPUSH
16763: CALL_OW 49
// end ;
16767: GO 16723
16769: POP
16770: POP
// for i = 1 to 3 do
16771: LD_ADDR_VAR 0 2
16775: PUSH
16776: DOUBLE
16777: LD_INT 1
16779: DEC
16780: ST_TO_ADDR
16781: LD_INT 3
16783: PUSH
16784: FOR_TO
16785: IFFALSE 16833
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
16787: LD_INT 0
16789: PPUSH
16790: LD_INT 8
16792: PPUSH
16793: LD_INT 6
16795: PUSH
16796: LD_OWVAR 67
16800: PLUS
16801: PPUSH
16802: CALL_OW 380
// un := CreateHuman ;
16806: LD_ADDR_VAR 0 4
16810: PUSH
16811: CALL_OW 44
16815: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16816: LD_VAR 0 4
16820: PPUSH
16821: LD_INT 32
16823: PPUSH
16824: LD_INT 0
16826: PPUSH
16827: CALL_OW 49
// end ;
16831: GO 16784
16833: POP
16834: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
16835: LD_ADDR_VAR 0 2
16839: PUSH
16840: DOUBLE
16841: LD_INT 1
16843: DEC
16844: ST_TO_ADDR
16845: LD_INT 2
16847: PUSH
16848: LD_INT 3
16850: PUSH
16851: LD_INT 4
16853: PUSH
16854: LD_INT 4
16856: PUSH
16857: EMPTY
16858: LIST
16859: LIST
16860: LIST
16861: LIST
16862: PUSH
16863: LD_OWVAR 67
16867: ARRAY
16868: PUSH
16869: FOR_TO
16870: IFFALSE 16960
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
16872: LD_INT 14
16874: PPUSH
16875: LD_INT 2
16877: PPUSH
16878: LD_INT 1
16880: PPUSH
16881: LD_INT 28
16883: PPUSH
16884: LD_INT 80
16886: PPUSH
16887: CALL 75220 0 5
// veh := CreateVehicle ;
16891: LD_ADDR_VAR 0 3
16895: PUSH
16896: CALL_OW 45
16900: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
16901: LD_VAR 0 3
16905: PPUSH
16906: LD_INT 3
16908: PPUSH
16909: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
16913: LD_VAR 0 3
16917: PPUSH
16918: LD_INT 29
16920: PPUSH
16921: LD_INT 0
16923: PPUSH
16924: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16928: LD_INT 0
16930: PPUSH
16931: LD_INT 6
16933: PUSH
16934: LD_OWVAR 67
16938: PLUS
16939: PPUSH
16940: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
16944: CALL_OW 44
16948: PPUSH
16949: LD_VAR 0 3
16953: PPUSH
16954: CALL_OW 52
// end ;
16958: GO 16869
16960: POP
16961: POP
// for i = 1 to 5 + Difficulty do
16962: LD_ADDR_VAR 0 2
16966: PUSH
16967: DOUBLE
16968: LD_INT 1
16970: DEC
16971: ST_TO_ADDR
16972: LD_INT 5
16974: PUSH
16975: LD_OWVAR 67
16979: PLUS
16980: PUSH
16981: FOR_TO
16982: IFFALSE 17109
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
16984: LD_INT 14
16986: PPUSH
16987: LD_INT 1
16989: PPUSH
16990: LD_INT 3
16992: PPUSH
16993: CALL_OW 12
16997: PPUSH
16998: LD_INT 1
17000: PPUSH
17001: LD_INT 28
17003: PUSH
17004: LD_INT 26
17006: PUSH
17007: LD_INT 27
17009: PUSH
17010: LD_INT 25
17012: PUSH
17013: EMPTY
17014: LIST
17015: LIST
17016: LIST
17017: LIST
17018: PUSH
17019: LD_VAR 0 2
17023: PUSH
17024: LD_INT 4
17026: MOD
17027: PUSH
17028: LD_INT 1
17030: PLUS
17031: ARRAY
17032: PPUSH
17033: LD_INT 80
17035: PPUSH
17036: CALL 75220 0 5
// veh := CreateVehicle ;
17040: LD_ADDR_VAR 0 3
17044: PUSH
17045: CALL_OW 45
17049: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
17050: LD_VAR 0 3
17054: PPUSH
17055: LD_INT 4
17057: PPUSH
17058: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
17062: LD_VAR 0 3
17066: PPUSH
17067: LD_INT 28
17069: PPUSH
17070: LD_INT 0
17072: PPUSH
17073: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
17077: LD_INT 0
17079: PPUSH
17080: LD_INT 6
17082: PUSH
17083: LD_OWVAR 67
17087: PLUS
17088: PPUSH
17089: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
17093: CALL_OW 44
17097: PPUSH
17098: LD_VAR 0 3
17102: PPUSH
17103: CALL_OW 52
// end ;
17107: GO 16981
17109: POP
17110: POP
// for i = 1 to Difficulty do
17111: LD_ADDR_VAR 0 2
17115: PUSH
17116: DOUBLE
17117: LD_INT 1
17119: DEC
17120: ST_TO_ADDR
17121: LD_OWVAR 67
17125: PUSH
17126: FOR_TO
17127: IFFALSE 17187
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
17129: LD_INT 14
17131: PPUSH
17132: LD_INT 3
17134: PPUSH
17135: LD_INT 5
17137: PPUSH
17138: LD_INT 29
17140: PPUSH
17141: LD_INT 80
17143: PPUSH
17144: CALL 75220 0 5
// veh := CreateVehicle ;
17148: LD_ADDR_VAR 0 3
17152: PUSH
17153: CALL_OW 45
17157: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
17158: LD_VAR 0 3
17162: PPUSH
17163: LD_INT 4
17165: PPUSH
17166: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
17170: LD_VAR 0 3
17174: PPUSH
17175: LD_INT 28
17177: PPUSH
17178: LD_INT 0
17180: PPUSH
17181: CALL_OW 49
// end ;
17185: GO 17126
17187: POP
17188: POP
// end ;
17189: LD_VAR 0 1
17193: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
17194: LD_INT 22
17196: PUSH
17197: LD_INT 2
17199: PUSH
17200: EMPTY
17201: LIST
17202: LIST
17203: PPUSH
17204: CALL_OW 69
17208: IFFALSE 17587
17210: GO 17212
17212: DISABLE
17213: LD_INT 0
17215: PPUSH
17216: PPUSH
17217: PPUSH
17218: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
17219: LD_ADDR_VAR 0 3
17223: PUSH
17224: LD_INT 22
17226: PUSH
17227: LD_INT 2
17229: PUSH
17230: EMPTY
17231: LIST
17232: LIST
17233: PUSH
17234: LD_INT 25
17236: PUSH
17237: LD_INT 4
17239: PUSH
17240: EMPTY
17241: LIST
17242: LIST
17243: PUSH
17244: EMPTY
17245: LIST
17246: LIST
17247: PPUSH
17248: CALL_OW 69
17252: PUSH
17253: LD_EXP 99
17257: DIFF
17258: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
17259: LD_ADDR_VAR 0 2
17263: PUSH
17264: LD_INT 22
17266: PUSH
17267: LD_INT 2
17269: PUSH
17270: EMPTY
17271: LIST
17272: LIST
17273: PPUSH
17274: CALL_OW 69
17278: PUSH
17279: LD_EXP 99
17283: PUSH
17284: LD_VAR 0 3
17288: UNION
17289: DIFF
17290: ST_TO_ADDR
// if Khatam then
17291: LD_EXP 99
17295: IFFALSE 17312
// ComMoveXY ( Khatam , 211 , 92 ) ;
17297: LD_EXP 99
17301: PPUSH
17302: LD_INT 211
17304: PPUSH
17305: LD_INT 92
17307: PPUSH
17308: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
17312: LD_INT 197
17314: PPUSH
17315: LD_INT 80
17317: PPUSH
17318: LD_INT 2
17320: PPUSH
17321: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
17325: LD_INT 213
17327: PPUSH
17328: LD_INT 90
17330: PPUSH
17331: LD_INT 2
17333: PPUSH
17334: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
17338: LD_INT 215
17340: PPUSH
17341: LD_INT 129
17343: PPUSH
17344: LD_INT 2
17346: PPUSH
17347: CALL_OW 441
// if sci then
17351: LD_VAR 0 3
17355: IFFALSE 17376
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
17357: LD_VAR 0 3
17361: PUSH
17362: LD_INT 1
17364: ARRAY
17365: PPUSH
17366: LD_INT 197
17368: PPUSH
17369: LD_INT 80
17371: PPUSH
17372: CALL_OW 158
// if sci > 1 then
17376: LD_VAR 0 3
17380: PUSH
17381: LD_INT 1
17383: GREATER
17384: IFFALSE 17405
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
17386: LD_VAR 0 3
17390: PUSH
17391: LD_INT 2
17393: ARRAY
17394: PPUSH
17395: LD_INT 213
17397: PPUSH
17398: LD_INT 90
17400: PPUSH
17401: CALL_OW 158
// if sci > 2 then
17405: LD_VAR 0 3
17409: PUSH
17410: LD_INT 2
17412: GREATER
17413: IFFALSE 17434
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
17415: LD_VAR 0 3
17419: PUSH
17420: LD_INT 3
17422: ARRAY
17423: PPUSH
17424: LD_INT 215
17426: PPUSH
17427: LD_INT 129
17429: PPUSH
17430: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
17434: LD_VAR 0 2
17438: PPUSH
17439: LD_INT 195
17441: PPUSH
17442: LD_INT 102
17444: PPUSH
17445: CALL_OW 114
// wait ( 0 0$5 ) ;
17449: LD_INT 175
17451: PPUSH
17452: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
17456: LD_INT 70
17458: PPUSH
17459: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
17463: LD_ADDR_VAR 0 4
17467: PUSH
17468: LD_INT 92
17470: PUSH
17471: LD_INT 195
17473: PUSH
17474: LD_INT 102
17476: PUSH
17477: LD_INT 36
17479: PUSH
17480: EMPTY
17481: LIST
17482: LIST
17483: LIST
17484: LIST
17485: PUSH
17486: LD_INT 22
17488: PUSH
17489: LD_INT 1
17491: PUSH
17492: EMPTY
17493: LIST
17494: LIST
17495: PUSH
17496: EMPTY
17497: LIST
17498: LIST
17499: PPUSH
17500: CALL_OW 69
17504: ST_TO_ADDR
// for i in tmp do
17505: LD_ADDR_VAR 0 1
17509: PUSH
17510: LD_VAR 0 2
17514: PUSH
17515: FOR_IN
17516: IFFALSE 17567
// if enemy then
17518: LD_VAR 0 4
17522: IFFALSE 17550
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
17524: LD_VAR 0 1
17528: PPUSH
17529: LD_VAR 0 4
17533: PPUSH
17534: LD_VAR 0 1
17538: PPUSH
17539: CALL_OW 74
17543: PPUSH
17544: CALL_OW 115
17548: GO 17565
// ComAgressiveMove ( i , 195 , 102 ) ;
17550: LD_VAR 0 1
17554: PPUSH
17555: LD_INT 195
17557: PPUSH
17558: LD_INT 102
17560: PPUSH
17561: CALL_OW 114
17565: GO 17515
17567: POP
17568: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
17569: LD_VAR 0 2
17573: PPUSH
17574: LD_INT 50
17576: PUSH
17577: EMPTY
17578: LIST
17579: PPUSH
17580: CALL_OW 72
17584: NOT
17585: IFFALSE 17456
// end ; end_of_file
17587: PPOPN 4
17589: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
17590: LD_INT 0
17592: PPUSH
17593: PPUSH
17594: PPUSH
17595: PPUSH
17596: PPUSH
17597: PPUSH
17598: PPUSH
17599: PPUSH
17600: PPUSH
// Video ( true ) ;
17601: LD_INT 1
17603: PPUSH
17604: CALL 108063 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
17608: LD_ADDR_VAR 0 5
17612: PUSH
17613: LD_INT 7
17615: PPUSH
17616: LD_INT 0
17618: PPUSH
17619: CALL_OW 517
17623: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
17624: LD_ADDR_VAR 0 2
17628: PUSH
17629: DOUBLE
17630: LD_INT 1
17632: DEC
17633: ST_TO_ADDR
17634: LD_VAR 0 5
17638: PUSH
17639: LD_INT 1
17641: ARRAY
17642: PUSH
17643: FOR_TO
17644: IFFALSE 17689
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
17646: LD_VAR 0 5
17650: PUSH
17651: LD_INT 1
17653: ARRAY
17654: PUSH
17655: LD_VAR 0 2
17659: ARRAY
17660: PPUSH
17661: LD_VAR 0 5
17665: PUSH
17666: LD_INT 2
17668: ARRAY
17669: PUSH
17670: LD_VAR 0 2
17674: ARRAY
17675: PPUSH
17676: LD_INT 1
17678: PPUSH
17679: LD_INT 15
17681: NEG
17682: PPUSH
17683: CALL 107977 0 4
17687: GO 17643
17689: POP
17690: POP
// CenterNowOnUnits ( Powell ) ;
17691: LD_EXP 61
17695: PPUSH
17696: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
17700: LD_ADDR_VAR 0 5
17704: PUSH
17705: LD_EXP 59
17709: PUSH
17710: EMPTY
17711: LIST
17712: ST_TO_ADDR
// if GirlNewVeh then
17713: LD_EXP 60
17717: IFFALSE 17735
// tmp := tmp ^ GirlNewVeh ;
17719: LD_ADDR_VAR 0 5
17723: PUSH
17724: LD_VAR 0 5
17728: PUSH
17729: LD_EXP 60
17733: ADD
17734: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
17735: LD_VAR 0 5
17739: PPUSH
17740: LD_INT 60
17742: PPUSH
17743: LD_INT 109
17745: PPUSH
17746: CALL_OW 111
// if KappaStatus then
17750: LD_EXP 2
17754: IFFALSE 17806
// begin Say ( JMM , D1nT-JMM-1 ) ;
17756: LD_EXP 40
17760: PPUSH
17761: LD_STRING D1nT-JMM-1
17763: PPUSH
17764: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17768: LD_EXP 61
17772: PPUSH
17773: LD_STRING D1T-Pow-1
17775: PPUSH
17776: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
17780: LD_EXP 40
17784: PPUSH
17785: LD_STRING D1T-JMM-2
17787: PPUSH
17788: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
17792: LD_EXP 61
17796: PPUSH
17797: LD_STRING D1T-Pow-2
17799: PPUSH
17800: CALL_OW 88
// end else
17804: GO 18012
// if JMMGirlStatus then
17806: LD_EXP 6
17810: IFFALSE 17955
// begin Say ( JMM , D1T-JMM-1 ) ;
17812: LD_EXP 40
17816: PPUSH
17817: LD_STRING D1T-JMM-1
17819: PPUSH
17820: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17824: LD_EXP 61
17828: PPUSH
17829: LD_STRING D1T-Pow-1
17831: PPUSH
17832: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
17836: LD_EXP 40
17840: PPUSH
17841: LD_STRING D1T-JMM-3
17843: PPUSH
17844: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
17848: LD_EXP 61
17852: PPUSH
17853: LD_STRING D1T-Pow-3
17855: PPUSH
17856: CALL_OW 88
// if JMMGirl then
17860: LD_EXP 7
17864: IFFALSE 17953
// begin case JMMGirl of 1 :
17866: LD_EXP 7
17870: PUSH
17871: LD_INT 1
17873: DOUBLE
17874: EQUAL
17875: IFTRUE 17879
17877: GO 17894
17879: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
17880: LD_EXP 41
17884: PPUSH
17885: LD_STRING D1T-Joan-3
17887: PPUSH
17888: CALL_OW 88
17892: GO 17941
17894: LD_INT 2
17896: DOUBLE
17897: EQUAL
17898: IFTRUE 17902
17900: GO 17917
17902: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
17903: LD_EXP 43
17907: PPUSH
17908: LD_STRING D1T-Lisa-3
17910: PPUSH
17911: CALL_OW 88
17915: GO 17941
17917: LD_INT 3
17919: DOUBLE
17920: EQUAL
17921: IFTRUE 17925
17923: GO 17940
17925: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
17926: LD_EXP 55
17930: PPUSH
17931: LD_STRING D1T-Con-3
17933: PPUSH
17934: CALL_OW 88
17938: GO 17941
17940: POP
// Say ( Powell , D1T-Pow-4 ) ;
17941: LD_EXP 61
17945: PPUSH
17946: LD_STRING D1T-Pow-4
17948: PPUSH
17949: CALL_OW 88
// end ; end else
17953: GO 18012
// if not FastEnd then
17955: LD_EXP 11
17959: NOT
17960: IFFALSE 17988
// begin Say ( JMM , D1T-JMM-4 ) ;
17962: LD_EXP 40
17966: PPUSH
17967: LD_STRING D1T-JMM-4
17969: PPUSH
17970: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
17974: LD_EXP 61
17978: PPUSH
17979: LD_STRING D1T-Pow-5
17981: PPUSH
17982: CALL_OW 88
// end else
17986: GO 18012
// begin Say ( JMM , D1nT-JMM-1 ) ;
17988: LD_EXP 40
17992: PPUSH
17993: LD_STRING D1nT-JMM-1
17995: PPUSH
17996: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
18000: LD_EXP 61
18004: PPUSH
18005: LD_STRING D1nT-Pow-1
18007: PPUSH
18008: CALL_OW 88
// end ; repeat wait ( 3 ) ;
18012: LD_INT 3
18014: PPUSH
18015: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
18019: LD_EXP 59
18023: PPUSH
18024: CALL_OW 314
18028: NOT
18029: IFFALSE 18012
// ComExitVehicle ( JMM ) ;
18031: LD_EXP 40
18035: PPUSH
18036: CALL_OW 121
// repeat wait ( 3 ) ;
18040: LD_INT 3
18042: PPUSH
18043: CALL_OW 67
// until not IsInUnit ( JMM ) ;
18047: LD_EXP 40
18051: PPUSH
18052: CALL_OW 310
18056: NOT
18057: IFFALSE 18040
// ComMoveXY ( JMM , 60 , 94 ) ;
18059: LD_EXP 40
18063: PPUSH
18064: LD_INT 60
18066: PPUSH
18067: LD_INT 94
18069: PPUSH
18070: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
18074: LD_EXP 40
18078: PPUSH
18079: LD_EXP 61
18083: PPUSH
18084: CALL_OW 179
// if Joan then
18088: LD_EXP 41
18092: IFFALSE 18146
// begin ComExitVehicle ( Joan ) ;
18094: LD_EXP 41
18098: PPUSH
18099: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
18103: LD_EXP 41
18107: PPUSH
18108: LD_INT 35
18110: PPUSH
18111: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
18115: LD_EXP 41
18119: PPUSH
18120: LD_INT 65
18122: PPUSH
18123: LD_INT 104
18125: PPUSH
18126: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
18130: LD_EXP 41
18134: PPUSH
18135: LD_EXP 40
18139: PPUSH
18140: CALL_OW 179
// end else
18144: GO 18280
// if Lisa and JMMGirl = 2 then
18146: LD_EXP 43
18150: PUSH
18151: LD_EXP 7
18155: PUSH
18156: LD_INT 2
18158: EQUAL
18159: AND
18160: IFFALSE 18214
// begin ComExitVehicle ( Lisa ) ;
18162: LD_EXP 43
18166: PPUSH
18167: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
18171: LD_EXP 43
18175: PPUSH
18176: LD_INT 35
18178: PPUSH
18179: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
18183: LD_EXP 43
18187: PPUSH
18188: LD_INT 65
18190: PPUSH
18191: LD_INT 104
18193: PPUSH
18194: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
18198: LD_EXP 43
18202: PPUSH
18203: LD_EXP 40
18207: PPUSH
18208: CALL_OW 179
// end else
18212: GO 18280
// if Connie and JMMGirl = 3 then
18214: LD_EXP 55
18218: PUSH
18219: LD_EXP 7
18223: PUSH
18224: LD_INT 3
18226: EQUAL
18227: AND
18228: IFFALSE 18280
// begin ComExitVehicle ( Connie ) ;
18230: LD_EXP 55
18234: PPUSH
18235: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
18239: LD_EXP 55
18243: PPUSH
18244: LD_INT 35
18246: PPUSH
18247: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
18251: LD_EXP 55
18255: PPUSH
18256: LD_INT 65
18258: PPUSH
18259: LD_INT 104
18261: PPUSH
18262: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
18266: LD_EXP 55
18270: PPUSH
18271: LD_EXP 40
18275: PPUSH
18276: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
18280: LD_INT 35
18282: PPUSH
18283: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
18287: LD_EXP 40
18291: PPUSH
18292: LD_EXP 61
18296: PPUSH
18297: CALL_OW 296
18301: PUSH
18302: LD_INT 8
18304: LESS
18305: IFFALSE 18280
// wait ( 0 0$0.5 ) ;
18307: LD_INT 18
18309: PPUSH
18310: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
18314: LD_EXP 40
18318: PPUSH
18319: LD_STRING D1-JMM-1
18321: PPUSH
18322: CALL_OW 88
// async ;
18326: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
18327: LD_EXP 61
18331: PPUSH
18332: LD_STRING D1-Pow-1
18334: PPUSH
18335: CALL_OW 88
// if not dialogue_skipped then
18339: LD_OWVAR 59
18343: NOT
18344: IFFALSE 18353
// wait ( 0 0$2 ) ;
18346: LD_INT 70
18348: PPUSH
18349: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
18353: LD_INT 170
18355: PPUSH
18356: LD_INT 99
18358: PPUSH
18359: LD_INT 1
18361: PPUSH
18362: LD_INT 6
18364: NEG
18365: PPUSH
18366: CALL 107977 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
18370: LD_INT 174
18372: PPUSH
18373: LD_INT 115
18375: PPUSH
18376: LD_INT 1
18378: PPUSH
18379: LD_INT 6
18381: NEG
18382: PPUSH
18383: CALL 107977 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
18387: LD_INT 169
18389: PPUSH
18390: LD_INT 71
18392: PPUSH
18393: LD_INT 1
18395: PPUSH
18396: LD_INT 6
18398: NEG
18399: PPUSH
18400: CALL 107977 0 4
// if not dialogue_skipped then
18404: LD_OWVAR 59
18408: NOT
18409: IFFALSE 18428
// begin CenterOnXY ( 170 , 99 ) ;
18411: LD_INT 170
18413: PPUSH
18414: LD_INT 99
18416: PPUSH
18417: CALL_OW 84
// wait ( 0 0$2.3 ) ;
18421: LD_INT 80
18423: PPUSH
18424: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
18428: LD_INT 75
18430: PPUSH
18431: LD_INT 53
18433: PPUSH
18434: LD_INT 1
18436: PPUSH
18437: LD_INT 9
18439: NEG
18440: PPUSH
18441: CALL 107977 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
18445: LD_INT 54
18447: PPUSH
18448: LD_INT 42
18450: PPUSH
18451: LD_INT 1
18453: PPUSH
18454: LD_INT 9
18456: NEG
18457: PPUSH
18458: CALL 107977 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
18462: LD_INT 62
18464: PPUSH
18465: LD_INT 51
18467: PPUSH
18468: LD_INT 1
18470: PPUSH
18471: LD_INT 9
18473: NEG
18474: PPUSH
18475: CALL 107977 0 4
// if not dialogue_skipped then
18479: LD_OWVAR 59
18483: NOT
18484: IFFALSE 18503
// begin CenterOnXY ( 75 , 53 ) ;
18486: LD_INT 75
18488: PPUSH
18489: LD_INT 53
18491: PPUSH
18492: CALL_OW 84
// wait ( 0 0$4 ) ;
18496: LD_INT 140
18498: PPUSH
18499: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
18503: LD_EXP 61
18507: PPUSH
18508: CALL_OW 87
// if not dialogue_skipped then
18512: LD_OWVAR 59
18516: NOT
18517: IFFALSE 18526
// wait ( 0 0$2 ) ;
18519: LD_INT 70
18521: PPUSH
18522: CALL_OW 67
// sync ;
18526: SYNC
// Say ( JMM , D1-JMM-2 ) ;
18527: LD_EXP 40
18531: PPUSH
18532: LD_STRING D1-JMM-2
18534: PPUSH
18535: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
18539: LD_EXP 61
18543: PPUSH
18544: LD_STRING D1-Pow-2
18546: PPUSH
18547: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
18551: LD_EXP 40
18555: PPUSH
18556: LD_STRING D1-JMM-3
18558: PPUSH
18559: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
18563: LD_EXP 61
18567: PPUSH
18568: LD_STRING D1-Pow-3
18570: PPUSH
18571: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
18575: LD_EXP 40
18579: PPUSH
18580: LD_STRING D1-JMM-4
18582: PPUSH
18583: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
18587: LD_EXP 61
18591: PPUSH
18592: LD_STRING D1-Pow-4
18594: PPUSH
18595: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
18599: LD_EXP 40
18603: PPUSH
18604: LD_STRING D1-JMM-5
18606: PPUSH
18607: CALL_OW 88
// async ;
18611: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
18612: LD_EXP 61
18616: PPUSH
18617: LD_STRING D1-Pow-5
18619: PPUSH
18620: CALL_OW 88
// if not dialogue_skipped then
18624: LD_OWVAR 59
18628: NOT
18629: IFFALSE 18638
// wait ( 0 0$3.6 ) ;
18631: LD_INT 126
18633: PPUSH
18634: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
18638: LD_INT 134
18640: PPUSH
18641: LD_INT 210
18643: PPUSH
18644: LD_INT 1
18646: PPUSH
18647: LD_INT 11
18649: NEG
18650: PPUSH
18651: CALL 107977 0 4
// if not dialogue_skipped then
18655: LD_OWVAR 59
18659: NOT
18660: IFFALSE 18679
// begin CenterOnXY ( 134 , 210 ) ;
18662: LD_INT 134
18664: PPUSH
18665: LD_INT 210
18667: PPUSH
18668: CALL_OW 84
// wait ( 0 0$2 ) ;
18672: LD_INT 70
18674: PPUSH
18675: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
18679: LD_INT 101
18681: PPUSH
18682: LD_INT 159
18684: PPUSH
18685: LD_INT 1
18687: PPUSH
18688: LD_INT 10
18690: NEG
18691: PPUSH
18692: CALL 107977 0 4
// if not dialogue_skipped then
18696: LD_OWVAR 59
18700: NOT
18701: IFFALSE 18720
// begin CenterOnXY ( 101 , 159 ) ;
18703: LD_INT 101
18705: PPUSH
18706: LD_INT 159
18708: PPUSH
18709: CALL_OW 84
// wait ( 0 0$2 ) ;
18713: LD_INT 70
18715: PPUSH
18716: CALL_OW 67
// end ; sync ;
18720: SYNC
// CenterNowOnUnits ( Powell ) ;
18721: LD_EXP 61
18725: PPUSH
18726: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
18730: LD_ADDR_VAR 0 6
18734: PUSH
18735: LD_INT 1
18737: PUSH
18738: LD_INT 2
18740: PUSH
18741: LD_INT 3
18743: PUSH
18744: LD_INT 4
18746: PUSH
18747: LD_INT 5
18749: PUSH
18750: LD_INT 6
18752: PUSH
18753: EMPTY
18754: LIST
18755: LIST
18756: LIST
18757: LIST
18758: LIST
18759: LIST
18760: ST_TO_ADDR
// if not dialogue_skipped then
18761: LD_OWVAR 59
18765: NOT
18766: IFFALSE 18935
// begin game_speed := 4 ;
18768: LD_ADDR_OWVAR 65
18772: PUSH
18773: LD_INT 4
18775: ST_TO_ADDR
// wait ( 0 0$6 ) ;
18776: LD_INT 210
18778: PPUSH
18779: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
18783: LD_ADDR_VAR 0 7
18787: PUSH
18788: LD_STRING Q1
18790: PPUSH
18791: LD_VAR 0 6
18795: PPUSH
18796: CALL_OW 98
18800: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
18801: LD_ADDR_VAR 0 7
18805: PUSH
18806: LD_STRING Q1
18808: PPUSH
18809: LD_VAR 0 6
18813: PPUSH
18814: CALL_OW 98
18818: ST_TO_ADDR
// options := options diff dec ;
18819: LD_ADDR_VAR 0 6
18823: PUSH
18824: LD_VAR 0 6
18828: PUSH
18829: LD_VAR 0 7
18833: DIFF
18834: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
18835: LD_VAR 0 7
18839: PPUSH
18840: LD_VAR 0 6
18844: PPUSH
18845: CALL 20529 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
18849: LD_VAR 0 7
18853: PUSH
18854: LD_INT 5
18856: PUSH
18857: LD_INT 6
18859: PUSH
18860: EMPTY
18861: LIST
18862: LIST
18863: IN
18864: PUSH
18865: LD_VAR 0 6
18869: PUSH
18870: LD_INT 2
18872: EQUAL
18873: OR
18874: IFFALSE 18801
// if not ( dec in [ 5 , 6 ] ) then
18876: LD_VAR 0 7
18880: PUSH
18881: LD_INT 5
18883: PUSH
18884: LD_INT 6
18886: PUSH
18887: EMPTY
18888: LIST
18889: LIST
18890: IN
18891: NOT
18892: IFFALSE 18935
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
18894: LD_ADDR_VAR 0 7
18898: PUSH
18899: LD_STRING Q1a
18901: PPUSH
18902: LD_INT 1
18904: PUSH
18905: LD_INT 2
18907: PUSH
18908: EMPTY
18909: LIST
18910: LIST
18911: PPUSH
18912: CALL_OW 98
18916: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
18917: LD_VAR 0 7
18921: PUSH
18922: LD_INT 4
18924: PLUS
18925: PPUSH
18926: LD_VAR 0 6
18930: PPUSH
18931: CALL 20529 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
18935: LD_INT 81
18937: PPUSH
18938: LD_INT 127
18940: PPUSH
18941: CALL_OW 84
// amount := 8 ;
18945: LD_ADDR_VAR 0 8
18949: PUSH
18950: LD_INT 8
18952: ST_TO_ADDR
// macmilan_squad := [ ] ;
18953: LD_ADDR_VAR 0 9
18957: PUSH
18958: EMPTY
18959: ST_TO_ADDR
// if vip < amount then
18960: LD_EXP 62
18964: PUSH
18965: LD_VAR 0 8
18969: LESS
18970: IFFALSE 19014
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
18972: LD_ADDR_VAR 0 5
18976: PUSH
18977: LD_EXP 62
18981: PUSH
18982: LD_INT 22
18984: PUSH
18985: LD_INT 4
18987: PUSH
18988: EMPTY
18989: LIST
18990: LIST
18991: PUSH
18992: LD_INT 21
18994: PUSH
18995: LD_INT 1
18997: PUSH
18998: EMPTY
18999: LIST
19000: LIST
19001: PUSH
19002: EMPTY
19003: LIST
19004: LIST
19005: PPUSH
19006: CALL_OW 69
19010: UNION
19011: ST_TO_ADDR
19012: GO 19024
// tmp := vip ;
19014: LD_ADDR_VAR 0 5
19018: PUSH
19019: LD_EXP 62
19023: ST_TO_ADDR
// tmp := tmp diff Powell ;
19024: LD_ADDR_VAR 0 5
19028: PUSH
19029: LD_VAR 0 5
19033: PUSH
19034: LD_EXP 61
19038: DIFF
19039: ST_TO_ADDR
// if tmp < amount then
19040: LD_VAR 0 5
19044: PUSH
19045: LD_VAR 0 8
19049: LESS
19050: IFFALSE 19062
// amount := tmp ;
19052: LD_ADDR_VAR 0 8
19056: PUSH
19057: LD_VAR 0 5
19061: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
19062: LD_VAR 0 5
19066: PUSH
19067: LD_INT 1
19069: ARRAY
19070: PPUSH
19071: CALL_OW 257
19075: PUSH
19076: LD_INT 2
19078: NONEQUAL
19079: IFFALSE 19177
// begin if IsInUnit ( tmp [ 1 ] ) then
19081: LD_VAR 0 5
19085: PUSH
19086: LD_INT 1
19088: ARRAY
19089: PPUSH
19090: CALL_OW 310
19094: IFFALSE 19109
// ComExitBuilding ( tmp [ 1 ] ) ;
19096: LD_VAR 0 5
19100: PUSH
19101: LD_INT 1
19103: ARRAY
19104: PPUSH
19105: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
19109: LD_INT 387
19111: PPUSH
19112: CALL_OW 313
19116: PUSH
19117: LD_INT 6
19119: EQUAL
19120: IFFALSE 19145
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
19122: LD_INT 387
19124: PPUSH
19125: CALL_OW 313
19129: PUSH
19130: LD_INT 1
19132: ARRAY
19133: PPUSH
19134: CALL_OW 122
// wait ( 3 ) ;
19138: LD_INT 3
19140: PPUSH
19141: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
19145: LD_VAR 0 5
19149: PUSH
19150: LD_INT 1
19152: ARRAY
19153: PPUSH
19154: LD_INT 387
19156: PPUSH
19157: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
19161: LD_VAR 0 5
19165: PUSH
19166: LD_INT 1
19168: ARRAY
19169: PPUSH
19170: LD_INT 2
19172: PPUSH
19173: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
19177: LD_EXP 40
19181: PPUSH
19182: LD_INT 82
19184: PPUSH
19185: LD_INT 129
19187: PPUSH
19188: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
19192: LD_EXP 40
19196: PPUSH
19197: LD_EXP 61
19201: PPUSH
19202: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
19206: LD_INT 22
19208: PUSH
19209: LD_INT 1
19211: PUSH
19212: EMPTY
19213: LIST
19214: LIST
19215: PPUSH
19216: CALL_OW 69
19220: PUSH
19221: LD_EXP 40
19225: DIFF
19226: PPUSH
19227: LD_INT 84
19229: PPUSH
19230: LD_INT 128
19232: PPUSH
19233: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
19237: LD_INT 22
19239: PUSH
19240: LD_INT 1
19242: PUSH
19243: EMPTY
19244: LIST
19245: LIST
19246: PPUSH
19247: CALL_OW 69
19251: PUSH
19252: LD_EXP 40
19256: DIFF
19257: PPUSH
19258: LD_EXP 40
19262: PPUSH
19263: CALL_OW 179
// for i = 1 to amount do
19267: LD_ADDR_VAR 0 2
19271: PUSH
19272: DOUBLE
19273: LD_INT 1
19275: DEC
19276: ST_TO_ADDR
19277: LD_VAR 0 8
19281: PUSH
19282: FOR_TO
19283: IFFALSE 19451
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
19285: LD_ADDR_VAR 0 9
19289: PUSH
19290: LD_VAR 0 9
19294: PUSH
19295: LD_VAR 0 5
19299: PUSH
19300: LD_VAR 0 2
19304: ARRAY
19305: ADD
19306: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
19307: LD_VAR 0 5
19311: PUSH
19312: LD_VAR 0 2
19316: ARRAY
19317: PPUSH
19318: CALL_OW 310
19322: IFFALSE 19339
// AddComExitBuilding ( tmp [ i ] ) ;
19324: LD_VAR 0 5
19328: PUSH
19329: LD_VAR 0 2
19333: ARRAY
19334: PPUSH
19335: CALL_OW 182
// if i = 2 and JMMNewVeh then
19339: LD_VAR 0 2
19343: PUSH
19344: LD_INT 2
19346: EQUAL
19347: PUSH
19348: LD_EXP 59
19352: AND
19353: IFFALSE 19411
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
19355: LD_VAR 0 5
19359: PUSH
19360: LD_VAR 0 2
19364: ARRAY
19365: PPUSH
19366: LD_EXP 59
19370: PPUSH
19371: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
19375: LD_VAR 0 5
19379: PUSH
19380: LD_VAR 0 2
19384: ARRAY
19385: PPUSH
19386: LD_INT 86
19388: PPUSH
19389: LD_INT 133
19391: PPUSH
19392: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
19396: LD_VAR 0 5
19400: PUSH
19401: LD_VAR 0 2
19405: ARRAY
19406: PPUSH
19407: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
19411: LD_VAR 0 5
19415: PUSH
19416: LD_VAR 0 2
19420: ARRAY
19421: PPUSH
19422: LD_INT 8
19424: PPUSH
19425: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
19429: LD_VAR 0 5
19433: PUSH
19434: LD_VAR 0 2
19438: ARRAY
19439: PPUSH
19440: LD_EXP 40
19444: PPUSH
19445: CALL_OW 179
// end ;
19449: GO 19282
19451: POP
19452: POP
// if GirlNewVeh then
19453: LD_EXP 60
19457: IFFALSE 19471
// SetSide ( GirlNewVeh , 4 ) ;
19459: LD_EXP 60
19463: PPUSH
19464: LD_INT 4
19466: PPUSH
19467: CALL_OW 235
// if Mike then
19471: LD_EXP 57
19475: IFFALSE 19512
// begin macmilan_squad := Join ( macmilan_squad , Mike ) ;
19477: LD_ADDR_VAR 0 9
19481: PUSH
19482: LD_VAR 0 9
19486: PPUSH
19487: LD_EXP 57
19491: PPUSH
19492: CALL 108091 0 2
19496: ST_TO_ADDR
// ComMoveXY ( Mike , 86 , 133 ) ;
19497: LD_EXP 57
19501: PPUSH
19502: LD_INT 86
19504: PPUSH
19505: LD_INT 133
19507: PPUSH
19508: CALL_OW 111
// end ; repeat wait ( 0 0$1 ) ;
19512: LD_INT 35
19514: PPUSH
19515: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
19519: LD_VAR 0 9
19523: PPUSH
19524: LD_INT 95
19526: PUSH
19527: LD_INT 9
19529: PUSH
19530: EMPTY
19531: LIST
19532: LIST
19533: PPUSH
19534: CALL_OW 72
19538: PUSH
19539: LD_INT 0
19541: EQUAL
19542: PUSH
19543: LD_EXP 40
19547: PPUSH
19548: LD_INT 9
19550: PPUSH
19551: CALL_OW 308
19555: NOT
19556: AND
19557: IFFALSE 19512
// wait ( 0 0$2 ) ;
19559: LD_INT 70
19561: PPUSH
19562: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
19566: LD_VAR 0 9
19570: PPUSH
19571: LD_INT 1
19573: PPUSH
19574: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
19578: LD_INT 21
19580: PUSH
19581: LD_INT 2
19583: PUSH
19584: EMPTY
19585: LIST
19586: LIST
19587: PUSH
19588: LD_INT 92
19590: PUSH
19591: LD_INT 83
19593: PUSH
19594: LD_INT 130
19596: PUSH
19597: LD_INT 10
19599: PUSH
19600: EMPTY
19601: LIST
19602: LIST
19603: LIST
19604: LIST
19605: PUSH
19606: EMPTY
19607: LIST
19608: LIST
19609: PPUSH
19610: CALL_OW 69
19614: PPUSH
19615: LD_INT 1
19617: PPUSH
19618: CALL_OW 235
// tick := 0 ;
19622: LD_ADDR_OWVAR 1
19626: PUSH
19627: LD_INT 0
19629: ST_TO_ADDR
// Video ( false ) ;
19630: LD_INT 0
19632: PPUSH
19633: CALL 108063 0 1
// ChangeMissionObjectives ( M1 ) ;
19637: LD_STRING M1
19639: PPUSH
19640: CALL_OW 337
// SaveForQuickRestart ;
19644: CALL_OW 22
// missionStart := true ;
19648: LD_ADDR_EXP 13
19652: PUSH
19653: LD_INT 1
19655: ST_TO_ADDR
// missionStage := 2 ;
19656: LD_ADDR_EXP 15
19660: PUSH
19661: LD_INT 2
19663: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19664: LD_INT 35
19666: PPUSH
19667: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
19671: LD_ADDR_VAR 0 5
19675: PUSH
19676: LD_INT 22
19678: PUSH
19679: LD_INT 4
19681: PUSH
19682: EMPTY
19683: LIST
19684: LIST
19685: PUSH
19686: LD_INT 21
19688: PUSH
19689: LD_INT 1
19691: PUSH
19692: EMPTY
19693: LIST
19694: LIST
19695: PUSH
19696: EMPTY
19697: LIST
19698: LIST
19699: PPUSH
19700: CALL_OW 69
19704: PUSH
19705: LD_EXP 61
19709: DIFF
19710: ST_TO_ADDR
// if not tmp then
19711: LD_VAR 0 5
19715: NOT
19716: IFFALSE 19731
// tmp := [ Powell ] ;
19718: LD_ADDR_VAR 0 5
19722: PUSH
19723: LD_EXP 61
19727: PUSH
19728: EMPTY
19729: LIST
19730: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
19731: LD_ADDR_VAR 0 4
19735: PUSH
19736: LD_INT 22
19738: PUSH
19739: LD_INT 4
19741: PUSH
19742: EMPTY
19743: LIST
19744: LIST
19745: PUSH
19746: LD_INT 34
19748: PUSH
19749: LD_INT 12
19751: PUSH
19752: EMPTY
19753: LIST
19754: LIST
19755: PUSH
19756: EMPTY
19757: LIST
19758: LIST
19759: PPUSH
19760: CALL_OW 69
19764: PUSH
19765: LD_INT 1
19767: ARRAY
19768: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
19769: LD_VAR 0 5
19773: PUSH
19774: LD_INT 1
19776: ARRAY
19777: PPUSH
19778: CALL_OW 310
19782: IFFALSE 19797
// ComExitBuilding ( tmp [ 1 ] ) ;
19784: LD_VAR 0 5
19788: PUSH
19789: LD_INT 1
19791: ARRAY
19792: PPUSH
19793: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
19797: LD_VAR 0 5
19801: PUSH
19802: LD_INT 1
19804: ARRAY
19805: PPUSH
19806: LD_VAR 0 4
19810: PPUSH
19811: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
19815: LD_VAR 0 5
19819: PUSH
19820: LD_INT 1
19822: ARRAY
19823: PPUSH
19824: LD_INT 80
19826: PPUSH
19827: LD_INT 136
19829: PPUSH
19830: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
19834: LD_VAR 0 5
19838: PUSH
19839: LD_INT 1
19841: ARRAY
19842: PPUSH
19843: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
19847: LD_VAR 0 5
19851: PUSH
19852: LD_INT 1
19854: ARRAY
19855: PPUSH
19856: LD_INT 59
19858: PPUSH
19859: LD_INT 112
19861: PPUSH
19862: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
19866: LD_VAR 0 5
19870: PUSH
19871: LD_INT 1
19873: ARRAY
19874: PPUSH
19875: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 and JMMGirl = 1 then
19879: LD_EXP 41
19883: PUSH
19884: LD_EXP 41
19888: PPUSH
19889: CALL_OW 255
19893: PUSH
19894: LD_INT 1
19896: EQUAL
19897: AND
19898: PUSH
19899: LD_EXP 7
19903: PUSH
19904: LD_INT 1
19906: EQUAL
19907: AND
19908: IFFALSE 19934
// begin Say ( Joan , D3W-Joan-1 ) ;
19910: LD_EXP 41
19914: PPUSH
19915: LD_STRING D3W-Joan-1
19917: PPUSH
19918: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19922: LD_EXP 40
19926: PPUSH
19927: LD_STRING D3W-JMM-1
19929: PPUSH
19930: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip and JMMGirl = 2 then
19934: LD_EXP 43
19938: PUSH
19939: LD_EXP 43
19943: PPUSH
19944: CALL_OW 255
19948: PUSH
19949: LD_INT 1
19951: EQUAL
19952: AND
19953: PUSH
19954: LD_EXP 43
19958: PUSH
19959: LD_EXP 62
19963: IN
19964: NOT
19965: AND
19966: PUSH
19967: LD_EXP 7
19971: PUSH
19972: LD_INT 2
19974: EQUAL
19975: AND
19976: IFFALSE 20002
// begin Say ( Lisa , D3W-Lisa-1 ) ;
19978: LD_EXP 43
19982: PPUSH
19983: LD_STRING D3W-Lisa-1
19985: PPUSH
19986: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19990: LD_EXP 40
19994: PPUSH
19995: LD_STRING D3W-JMM-1
19997: PPUSH
19998: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 and JMMGirl = 3 then
20002: LD_EXP 55
20006: PUSH
20007: LD_EXP 55
20011: PPUSH
20012: CALL_OW 255
20016: PUSH
20017: LD_INT 1
20019: EQUAL
20020: AND
20021: PUSH
20022: LD_EXP 7
20026: PUSH
20027: LD_INT 3
20029: EQUAL
20030: AND
20031: IFFALSE 20057
// begin Say ( Connie , D3W-Con-1 ) ;
20033: LD_EXP 55
20037: PPUSH
20038: LD_STRING D3W-Con-1
20040: PPUSH
20041: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
20045: LD_EXP 40
20049: PPUSH
20050: LD_STRING D3W-JMM-1
20052: PPUSH
20053: CALL_OW 88
// end ; wait ( 0 0$0.5 ) ;
20057: LD_INT 18
20059: PPUSH
20060: CALL_OW 67
// if Lisa in vip and GetSide ( Lisa ) = 1 then
20064: LD_EXP 43
20068: PUSH
20069: LD_EXP 62
20073: IN
20074: PUSH
20075: LD_EXP 43
20079: PPUSH
20080: CALL_OW 255
20084: PUSH
20085: LD_INT 1
20087: EQUAL
20088: AND
20089: IFFALSE 20105
// Say ( Lisa , D3nW-Lisa-1 ) else
20091: LD_EXP 43
20095: PPUSH
20096: LD_STRING D3nW-Lisa-1
20098: PPUSH
20099: CALL_OW 88
20103: GO 20349
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
20105: LD_EXP 46
20109: PUSH
20110: LD_EXP 62
20114: IN
20115: PUSH
20116: LD_EXP 46
20120: PPUSH
20121: CALL_OW 255
20125: PUSH
20126: LD_INT 1
20128: EQUAL
20129: AND
20130: IFFALSE 20146
// Say ( Cyrus , D3nW-Cyrus-1 ) else
20132: LD_EXP 46
20136: PPUSH
20137: LD_STRING D3nW-Cyrus-1
20139: PPUSH
20140: CALL_OW 88
20144: GO 20349
// if Bobby in vip and GetSide ( Bobby ) = 1 then
20146: LD_EXP 45
20150: PUSH
20151: LD_EXP 62
20155: IN
20156: PUSH
20157: LD_EXP 45
20161: PPUSH
20162: CALL_OW 255
20166: PUSH
20167: LD_INT 1
20169: EQUAL
20170: AND
20171: IFFALSE 20187
// Say ( Bobby , D3nW-Bobby-1 ) else
20173: LD_EXP 45
20177: PPUSH
20178: LD_STRING D3nW-Bobby-1
20180: PPUSH
20181: CALL_OW 88
20185: GO 20349
// if Gary in vip and GetSide ( Gary ) = 1 then
20187: LD_EXP 52
20191: PUSH
20192: LD_EXP 62
20196: IN
20197: PUSH
20198: LD_EXP 52
20202: PPUSH
20203: CALL_OW 255
20207: PUSH
20208: LD_INT 1
20210: EQUAL
20211: AND
20212: IFFALSE 20228
// Say ( Gary , D3nW-Gary-1 ) else
20214: LD_EXP 52
20218: PPUSH
20219: LD_STRING D3nW-Gary-1
20221: PPUSH
20222: CALL_OW 88
20226: GO 20349
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
20228: LD_EXP 44
20232: PUSH
20233: LD_EXP 62
20237: IN
20238: PUSH
20239: LD_EXP 44
20243: PPUSH
20244: CALL_OW 255
20248: PUSH
20249: LD_INT 1
20251: EQUAL
20252: AND
20253: IFFALSE 20269
// Say ( Donaldson , D3nW-Don-1 ) else
20255: LD_EXP 44
20259: PPUSH
20260: LD_STRING D3nW-Don-1
20262: PPUSH
20263: CALL_OW 88
20267: GO 20349
// if Cornel in vip and GetSide ( Cornel ) = 1 then
20269: LD_EXP 51
20273: PUSH
20274: LD_EXP 62
20278: IN
20279: PUSH
20280: LD_EXP 51
20284: PPUSH
20285: CALL_OW 255
20289: PUSH
20290: LD_INT 1
20292: EQUAL
20293: AND
20294: IFFALSE 20310
// Say ( Cornel , D3nW-Corn-1 ) else
20296: LD_EXP 51
20300: PPUSH
20301: LD_STRING D3nW-Corn-1
20303: PPUSH
20304: CALL_OW 88
20308: GO 20349
// if Frank in vip and GetSide ( Frank ) = 1 then
20310: LD_EXP 53
20314: PUSH
20315: LD_EXP 62
20319: IN
20320: PUSH
20321: LD_EXP 53
20325: PPUSH
20326: CALL_OW 255
20330: PUSH
20331: LD_INT 1
20333: EQUAL
20334: AND
20335: IFFALSE 20349
// Say ( Frank , D3nW-Frank-1 ) ;
20337: LD_EXP 53
20341: PPUSH
20342: LD_STRING D3nW-Frank-1
20344: PPUSH
20345: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
20349: LD_EXP 62
20353: PPUSH
20354: LD_INT 22
20356: PUSH
20357: LD_INT 1
20359: PUSH
20360: EMPTY
20361: LIST
20362: LIST
20363: PPUSH
20364: CALL_OW 72
20368: IFFALSE 20394
// begin Say ( JMM , D3nW-JMM-1 ) ;
20370: LD_EXP 40
20374: PPUSH
20375: LD_STRING D3nW-JMM-1
20377: PPUSH
20378: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
20382: LD_EXP 40
20386: PPUSH
20387: LD_STRING D3nW-JMM-1a
20389: PPUSH
20390: CALL_OW 88
// end ; t := 0 0$00 ;
20394: LD_ADDR_VAR 0 3
20398: PUSH
20399: LD_INT 0
20401: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20402: LD_INT 35
20404: PPUSH
20405: CALL_OW 67
// t := t + 0 0$1 ;
20409: LD_ADDR_VAR 0 3
20413: PUSH
20414: LD_VAR 0 3
20418: PUSH
20419: LD_INT 35
20421: PLUS
20422: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
20423: LD_INT 59
20425: PPUSH
20426: LD_INT 112
20428: PPUSH
20429: CALL_OW 428
20433: PUSH
20434: LD_VAR 0 3
20438: PUSH
20439: LD_INT 2100
20441: GREATER
20442: OR
20443: IFFALSE 20402
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
20445: LD_ADDR_EXP 102
20449: PUSH
20450: LD_EXP 102
20454: PPUSH
20455: LD_INT 4
20457: PPUSH
20458: LD_INT 22
20460: PUSH
20461: LD_INT 4
20463: PUSH
20464: EMPTY
20465: LIST
20466: LIST
20467: PUSH
20468: LD_INT 23
20470: PUSH
20471: LD_INT 1
20473: PUSH
20474: EMPTY
20475: LIST
20476: LIST
20477: PUSH
20478: LD_INT 3
20480: PUSH
20481: LD_INT 21
20483: PUSH
20484: LD_INT 2
20486: PUSH
20487: EMPTY
20488: LIST
20489: LIST
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: PUSH
20495: EMPTY
20496: LIST
20497: LIST
20498: LIST
20499: PPUSH
20500: CALL_OW 69
20504: PUSH
20505: LD_EXP 61
20509: DIFF
20510: PPUSH
20511: CALL_OW 1
20515: ST_TO_ADDR
// activeAttacks := true ;
20516: LD_ADDR_EXP 16
20520: PUSH
20521: LD_INT 1
20523: ST_TO_ADDR
// end ;
20524: LD_VAR 0 1
20528: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
20529: LD_INT 0
20531: PPUSH
// case question of 1 :
20532: LD_VAR 0 1
20536: PUSH
20537: LD_INT 1
20539: DOUBLE
20540: EQUAL
20541: IFTRUE 20545
20543: GO 20596
20545: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
20546: LD_EXP 40
20550: PPUSH
20551: LD_STRING D2Mot-JMM-1
20553: PPUSH
20554: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
20558: LD_EXP 61
20562: PPUSH
20563: LD_STRING D2Mot-Pow-1
20565: PPUSH
20566: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
20570: LD_EXP 40
20574: PPUSH
20575: LD_STRING D2Mot-JMM-2
20577: PPUSH
20578: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
20582: LD_EXP 61
20586: PPUSH
20587: LD_STRING D2Mot-Pow-2
20589: PPUSH
20590: CALL_OW 88
// end ; 2 :
20594: GO 20947
20596: LD_INT 2
20598: DOUBLE
20599: EQUAL
20600: IFTRUE 20604
20602: GO 20680
20604: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
20605: LD_EXP 40
20609: PPUSH
20610: LD_STRING D2Rus-JMM-1
20612: PPUSH
20613: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
20617: LD_EXP 61
20621: PPUSH
20622: LD_STRING D2Rus-Pow-1
20624: PPUSH
20625: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
20629: LD_EXP 40
20633: PPUSH
20634: LD_STRING D2Rus-JMM-2
20636: PPUSH
20637: CALL_OW 88
// if not ( 3 in list_of_q ) then
20641: LD_INT 3
20643: PUSH
20644: LD_VAR 0 2
20648: IN
20649: NOT
20650: IFFALSE 20666
// Say ( Powell , D2Rus-Pow-2 ) else
20652: LD_EXP 61
20656: PPUSH
20657: LD_STRING D2Rus-Pow-2
20659: PPUSH
20660: CALL_OW 88
20664: GO 20678
// Say ( Powell , D2Rus-Pow-2a ) ;
20666: LD_EXP 61
20670: PPUSH
20671: LD_STRING D2Rus-Pow-2a
20673: PPUSH
20674: CALL_OW 88
// end ; 3 :
20678: GO 20947
20680: LD_INT 3
20682: DOUBLE
20683: EQUAL
20684: IFTRUE 20688
20686: GO 20773
20688: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
20689: LD_EXP 40
20693: PPUSH
20694: LD_STRING D2Leg-JMM-1
20696: PPUSH
20697: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
20701: LD_EXP 61
20705: PPUSH
20706: LD_STRING D2Leg-Pow-1
20708: PPUSH
20709: CALL_OW 88
// if 2 in list_of_q then
20713: LD_INT 2
20715: PUSH
20716: LD_VAR 0 2
20720: IN
20721: IFFALSE 20747
// begin Say ( JMM , D2Leg-JMM-2 ) ;
20723: LD_EXP 40
20727: PPUSH
20728: LD_STRING D2Leg-JMM-2
20730: PPUSH
20731: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
20735: LD_EXP 61
20739: PPUSH
20740: LD_STRING D2Leg-Pow-2
20742: PPUSH
20743: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
20747: LD_EXP 40
20751: PPUSH
20752: LD_STRING D2Leg-JMM-3
20754: PPUSH
20755: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
20759: LD_EXP 61
20763: PPUSH
20764: LD_STRING D2Leg-Pow-3
20766: PPUSH
20767: CALL_OW 88
// end ; 4 :
20771: GO 20947
20773: LD_INT 4
20775: DOUBLE
20776: EQUAL
20777: IFTRUE 20781
20779: GO 20856
20781: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
20782: LD_EXP 40
20786: PPUSH
20787: LD_STRING D2Ar-JMM-1
20789: PPUSH
20790: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
20794: LD_EXP 61
20798: PPUSH
20799: LD_STRING D2Ar-Pow-1
20801: PPUSH
20802: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
20806: LD_EXP 40
20810: PPUSH
20811: LD_STRING D2Ar-JMM-2
20813: PPUSH
20814: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
20818: LD_EXP 61
20822: PPUSH
20823: LD_STRING D2Ar-Pow-2
20825: PPUSH
20826: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
20830: LD_EXP 40
20834: PPUSH
20835: LD_STRING D2Ar-JMM-3
20837: PPUSH
20838: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
20842: LD_EXP 61
20846: PPUSH
20847: LD_STRING D2Ar-Pow-3
20849: PPUSH
20850: CALL_OW 88
// end ; 5 :
20854: GO 20947
20856: LD_INT 5
20858: DOUBLE
20859: EQUAL
20860: IFTRUE 20864
20862: GO 20879
20864: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
20865: LD_EXP 40
20869: PPUSH
20870: LD_STRING D2Conf-JMM-1
20872: PPUSH
20873: CALL_OW 88
20877: GO 20947
20879: LD_INT 6
20881: DOUBLE
20882: EQUAL
20883: IFTRUE 20887
20885: GO 20946
20887: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
20888: LD_EXP 40
20892: PPUSH
20893: LD_STRING D2Com-JMM-1
20895: PPUSH
20896: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
20900: LD_EXP 61
20904: PPUSH
20905: LD_STRING D2Com-Pow-1
20907: PPUSH
20908: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
20912: LD_EXP 40
20916: PPUSH
20917: LD_STRING D2Com-JMM-2
20919: PPUSH
20920: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
20924: LD_EXP 61
20928: PPUSH
20929: LD_STRING D2Com-Pow-2
20931: PPUSH
20932: CALL_OW 88
// powellAngerQuery := true ;
20936: LD_ADDR_EXP 36
20940: PUSH
20941: LD_INT 1
20943: ST_TO_ADDR
// end ; end ;
20944: GO 20947
20946: POP
// end ;
20947: LD_VAR 0 3
20951: RET
// every 0 0$5 trigger missionStart do var tmp ;
20952: LD_EXP 13
20956: IFFALSE 21281
20958: GO 20960
20960: DISABLE
20961: LD_INT 0
20963: PPUSH
// begin repeat wait ( 0 0$1 ) ;
20964: LD_INT 35
20966: PPUSH
20967: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
20971: LD_INT 14
20973: PPUSH
20974: LD_INT 22
20976: PUSH
20977: LD_INT 1
20979: PUSH
20980: EMPTY
20981: LIST
20982: LIST
20983: PUSH
20984: LD_INT 3
20986: PUSH
20987: LD_INT 21
20989: PUSH
20990: LD_INT 3
20992: PUSH
20993: EMPTY
20994: LIST
20995: LIST
20996: PUSH
20997: EMPTY
20998: LIST
20999: LIST
21000: PUSH
21001: EMPTY
21002: LIST
21003: LIST
21004: PPUSH
21005: CALL_OW 70
21009: PUSH
21010: LD_EXP 15
21014: PUSH
21015: LD_INT 2
21017: PUSH
21018: LD_INT 3
21020: PUSH
21021: LD_INT 4
21023: PUSH
21024: LD_INT 5
21026: PUSH
21027: EMPTY
21028: LIST
21029: LIST
21030: LIST
21031: LIST
21032: IN
21033: AND
21034: IFFALSE 21271
// begin powellAnger := powellAnger + 1 ;
21036: LD_ADDR_EXP 17
21040: PUSH
21041: LD_EXP 17
21045: PUSH
21046: LD_INT 1
21048: PLUS
21049: ST_TO_ADDR
// Video ( true ) ;
21050: LD_INT 1
21052: PPUSH
21053: CALL 108063 0 1
// CenterNowOnUnits ( tmp ) ;
21057: LD_VAR 0 1
21061: PPUSH
21062: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
21066: LD_INT 14
21068: PPUSH
21069: LD_INT 22
21071: PUSH
21072: LD_INT 1
21074: PUSH
21075: EMPTY
21076: LIST
21077: LIST
21078: PPUSH
21079: CALL_OW 70
21083: PPUSH
21084: LD_INT 86
21086: PPUSH
21087: LD_INT 133
21089: PPUSH
21090: CALL_OW 111
// async ;
21094: ASYNC
// case powellAnger of 1 :
21095: LD_EXP 17
21099: PUSH
21100: LD_INT 1
21102: DOUBLE
21103: EQUAL
21104: IFTRUE 21108
21106: GO 21123
21108: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
21109: LD_EXP 61
21113: PPUSH
21114: LD_STRING DBack1-Pow-1
21116: PPUSH
21117: CALL_OW 88
21121: GO 21170
21123: LD_INT 2
21125: DOUBLE
21126: EQUAL
21127: IFTRUE 21131
21129: GO 21146
21131: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
21132: LD_EXP 61
21136: PPUSH
21137: LD_STRING DBack2-Pow-1
21139: PPUSH
21140: CALL_OW 88
21144: GO 21170
21146: LD_INT 3
21148: DOUBLE
21149: EQUAL
21150: IFTRUE 21154
21152: GO 21169
21154: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
21155: LD_EXP 61
21159: PPUSH
21160: LD_STRING DBack3-Pow-1
21162: PPUSH
21163: CALL_OW 88
21167: GO 21170
21169: POP
// sync ;
21170: SYNC
// repeat wait ( 0 0$1 ) ;
21171: LD_INT 35
21173: PPUSH
21174: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
21178: LD_INT 14
21180: PPUSH
21181: LD_INT 22
21183: PUSH
21184: LD_INT 1
21186: PUSH
21187: EMPTY
21188: LIST
21189: LIST
21190: PPUSH
21191: CALL_OW 70
21195: PPUSH
21196: LD_INT 86
21198: PPUSH
21199: LD_INT 133
21201: PPUSH
21202: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21206: LD_INT 14
21208: PPUSH
21209: LD_INT 22
21211: PUSH
21212: LD_INT 1
21214: PUSH
21215: EMPTY
21216: LIST
21217: LIST
21218: PUSH
21219: LD_INT 3
21221: PUSH
21222: LD_INT 21
21224: PUSH
21225: LD_INT 3
21227: PUSH
21228: EMPTY
21229: LIST
21230: LIST
21231: PUSH
21232: EMPTY
21233: LIST
21234: LIST
21235: PUSH
21236: EMPTY
21237: LIST
21238: LIST
21239: PPUSH
21240: CALL_OW 70
21244: NOT
21245: IFFALSE 21171
// if powellAnger >= 3 then
21247: LD_EXP 17
21251: PUSH
21252: LD_INT 3
21254: GREATEREQUAL
21255: IFFALSE 21264
// YouLost ( Dismissed ) ;
21257: LD_STRING Dismissed
21259: PPUSH
21260: CALL_OW 104
// Video ( false ) ;
21264: LD_INT 0
21266: PPUSH
21267: CALL 108063 0 1
// end ; until missionStage > 5 ;
21271: LD_EXP 15
21275: PUSH
21276: LD_INT 5
21278: GREATER
21279: IFFALSE 20964
// end ;
21281: PPOPN 1
21283: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t , p ;
21284: LD_EXP 13
21288: PUSH
21289: LD_INT 22
21291: PUSH
21292: LD_INT 4
21294: PUSH
21295: EMPTY
21296: LIST
21297: LIST
21298: PUSH
21299: LD_INT 21
21301: PUSH
21302: LD_INT 2
21304: PUSH
21305: EMPTY
21306: LIST
21307: LIST
21308: PUSH
21309: EMPTY
21310: LIST
21311: LIST
21312: PPUSH
21313: CALL_OW 69
21317: PUSH
21318: LD_INT 4
21320: GREATEREQUAL
21321: AND
21322: PUSH
21323: LD_EXP 15
21327: PUSH
21328: LD_INT 2
21330: EQUAL
21331: AND
21332: IFFALSE 23956
21334: GO 21336
21336: DISABLE
21337: LD_INT 0
21339: PPUSH
21340: PPUSH
21341: PPUSH
21342: PPUSH
21343: PPUSH
21344: PPUSH
21345: PPUSH
21346: PPUSH
21347: PPUSH
21348: PPUSH
21349: PPUSH
// begin missionStage := 3 ;
21350: LD_ADDR_EXP 15
21354: PUSH
21355: LD_INT 3
21357: ST_TO_ADDR
// retreat := false ;
21358: LD_ADDR_VAR 0 4
21362: PUSH
21363: LD_INT 0
21365: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
21366: LD_ADDR_VAR 0 5
21370: PUSH
21371: LD_INT 22
21373: PUSH
21374: LD_INT 4
21376: PUSH
21377: EMPTY
21378: LIST
21379: LIST
21380: PUSH
21381: LD_INT 30
21383: PUSH
21384: LD_INT 4
21386: PUSH
21387: EMPTY
21388: LIST
21389: LIST
21390: PUSH
21391: EMPTY
21392: LIST
21393: LIST
21394: PPUSH
21395: CALL_OW 69
21399: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21400: LD_ADDR_VAR 0 6
21404: PUSH
21405: LD_INT 22
21407: PUSH
21408: LD_INT 4
21410: PUSH
21411: EMPTY
21412: LIST
21413: LIST
21414: PUSH
21415: LD_INT 30
21417: PUSH
21418: LD_INT 5
21420: PUSH
21421: EMPTY
21422: LIST
21423: LIST
21424: PUSH
21425: EMPTY
21426: LIST
21427: LIST
21428: PPUSH
21429: CALL_OW 69
21433: ST_TO_ADDR
// if not bar then
21434: LD_VAR 0 6
21438: NOT
21439: IFFALSE 21492
// begin repeat wait ( 0 0$1 ) ;
21441: LD_INT 35
21443: PPUSH
21444: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
21448: LD_INT 22
21450: PUSH
21451: LD_INT 4
21453: PUSH
21454: EMPTY
21455: LIST
21456: LIST
21457: PUSH
21458: LD_INT 3
21460: PUSH
21461: LD_INT 57
21463: PUSH
21464: EMPTY
21465: LIST
21466: PUSH
21467: EMPTY
21468: LIST
21469: LIST
21470: PUSH
21471: LD_INT 30
21473: PUSH
21474: LD_INT 5
21476: PUSH
21477: EMPTY
21478: LIST
21479: LIST
21480: PUSH
21481: EMPTY
21482: LIST
21483: LIST
21484: LIST
21485: PPUSH
21486: CALL_OW 69
21490: IFFALSE 21441
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21492: LD_ADDR_VAR 0 6
21496: PUSH
21497: LD_INT 22
21499: PUSH
21500: LD_INT 4
21502: PUSH
21503: EMPTY
21504: LIST
21505: LIST
21506: PUSH
21507: LD_INT 30
21509: PUSH
21510: LD_INT 5
21512: PUSH
21513: EMPTY
21514: LIST
21515: LIST
21516: PUSH
21517: EMPTY
21518: LIST
21519: LIST
21520: PPUSH
21521: CALL_OW 69
21525: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21526: LD_INT 35
21528: PPUSH
21529: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
21533: LD_EXP 121
21537: PUSH
21538: LD_INT 4
21540: ARRAY
21541: PUSH
21542: LD_INT 4
21544: GREATEREQUAL
21545: IFFALSE 21526
// tmp := [ ] ;
21547: LD_ADDR_VAR 0 2
21551: PUSH
21552: EMPTY
21553: ST_TO_ADDR
// tmp2 := [ ] ;
21554: LD_ADDR_VAR 0 3
21558: PUSH
21559: EMPTY
21560: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell union vip ) do
21561: LD_ADDR_VAR 0 1
21565: PUSH
21566: LD_INT 22
21568: PUSH
21569: LD_INT 4
21571: PUSH
21572: EMPTY
21573: LIST
21574: LIST
21575: PUSH
21576: LD_INT 2
21578: PUSH
21579: LD_INT 25
21581: PUSH
21582: LD_INT 1
21584: PUSH
21585: EMPTY
21586: LIST
21587: LIST
21588: PUSH
21589: LD_INT 25
21591: PUSH
21592: LD_INT 2
21594: PUSH
21595: EMPTY
21596: LIST
21597: LIST
21598: PUSH
21599: LD_INT 25
21601: PUSH
21602: LD_INT 3
21604: PUSH
21605: EMPTY
21606: LIST
21607: LIST
21608: PUSH
21609: LD_INT 25
21611: PUSH
21612: LD_INT 4
21614: PUSH
21615: EMPTY
21616: LIST
21617: LIST
21618: PUSH
21619: LD_INT 25
21621: PUSH
21622: LD_INT 5
21624: PUSH
21625: EMPTY
21626: LIST
21627: LIST
21628: PUSH
21629: EMPTY
21630: LIST
21631: LIST
21632: LIST
21633: LIST
21634: LIST
21635: LIST
21636: PUSH
21637: EMPTY
21638: LIST
21639: LIST
21640: PPUSH
21641: CALL_OW 69
21645: PUSH
21646: LD_EXP 61
21650: PUSH
21651: LD_EXP 62
21655: UNION
21656: DIFF
21657: PUSH
21658: FOR_IN
21659: IFFALSE 21721
// if not i in extraSquad then
21661: LD_VAR 0 1
21665: PUSH
21666: LD_EXP 63
21670: IN
21671: NOT
21672: IFFALSE 21696
// tmp := Join ( tmp , i ) else
21674: LD_ADDR_VAR 0 2
21678: PUSH
21679: LD_VAR 0 2
21683: PPUSH
21684: LD_VAR 0 1
21688: PPUSH
21689: CALL 108091 0 2
21693: ST_TO_ADDR
21694: GO 21719
// tmp := Insert ( tmp , 1 , i ) ;
21696: LD_ADDR_VAR 0 2
21700: PUSH
21701: LD_VAR 0 2
21705: PPUSH
21706: LD_INT 1
21708: PPUSH
21709: LD_VAR 0 1
21713: PPUSH
21714: CALL_OW 2
21718: ST_TO_ADDR
21719: GO 21658
21721: POP
21722: POP
// tmp := tmp diff 0 ;
21723: LD_ADDR_VAR 0 2
21727: PUSH
21728: LD_VAR 0 2
21732: PUSH
21733: LD_INT 0
21735: DIFF
21736: ST_TO_ADDR
// p := 0 ;
21737: LD_ADDR_VAR 0 11
21741: PUSH
21742: LD_INT 0
21744: ST_TO_ADDR
// for i in UnitFilter ( tmp , [ f_sex , sex_male ] ) do
21745: LD_ADDR_VAR 0 1
21749: PUSH
21750: LD_VAR 0 2
21754: PPUSH
21755: LD_INT 26
21757: PUSH
21758: LD_INT 1
21760: PUSH
21761: EMPTY
21762: LIST
21763: LIST
21764: PPUSH
21765: CALL_OW 72
21769: PUSH
21770: FOR_IN
21771: IFFALSE 21822
// begin p := Inc ( p ) ;
21773: LD_ADDR_VAR 0 11
21777: PUSH
21778: LD_VAR 0 11
21782: PPUSH
21783: CALL 109452 0 1
21787: ST_TO_ADDR
// tmp2 := Join ( tmp2 , i ) ;
21788: LD_ADDR_VAR 0 3
21792: PUSH
21793: LD_VAR 0 3
21797: PPUSH
21798: LD_VAR 0 1
21802: PPUSH
21803: CALL 108091 0 2
21807: ST_TO_ADDR
// if p = 4 then
21808: LD_VAR 0 11
21812: PUSH
21813: LD_INT 4
21815: EQUAL
21816: IFFALSE 21820
// break ;
21818: GO 21822
// end ;
21820: GO 21770
21822: POP
21823: POP
// tmp := tmp diff tmp2 ;
21824: LD_ADDR_VAR 0 2
21828: PUSH
21829: LD_VAR 0 2
21833: PUSH
21834: LD_VAR 0 3
21838: DIFF
21839: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
21840: LD_ADDR_VAR 0 2
21844: PUSH
21845: LD_VAR 0 2
21849: PPUSH
21850: LD_INT 3
21852: PPUSH
21853: CALL 106595 0 2
21857: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
21858: LD_ADDR_VAR 0 3
21862: PUSH
21863: LD_VAR 0 3
21867: PPUSH
21868: LD_INT 3
21870: PPUSH
21871: CALL 106595 0 2
21875: ST_TO_ADDR
// for i := 1 to 4 do
21876: LD_ADDR_VAR 0 1
21880: PUSH
21881: DOUBLE
21882: LD_INT 1
21884: DEC
21885: ST_TO_ADDR
21886: LD_INT 4
21888: PUSH
21889: FOR_TO
21890: IFFALSE 22056
// begin if tmp2 then
21892: LD_VAR 0 3
21896: IFFALSE 21977
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
21898: LD_ADDR_EXP 18
21902: PUSH
21903: LD_EXP 18
21907: PPUSH
21908: LD_INT 1
21910: PPUSH
21911: LD_EXP 18
21915: PUSH
21916: LD_INT 1
21918: ARRAY
21919: PUSH
21920: LD_VAR 0 3
21924: PUSH
21925: LD_VAR 0 3
21929: ARRAY
21930: ADD
21931: PPUSH
21932: CALL_OW 1
21936: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
21937: LD_VAR 0 3
21941: PUSH
21942: LD_VAR 0 3
21946: ARRAY
21947: PPUSH
21948: LD_INT 1
21950: PPUSH
21951: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
21955: LD_ADDR_VAR 0 3
21959: PUSH
21960: LD_VAR 0 3
21964: PPUSH
21965: LD_VAR 0 3
21969: PPUSH
21970: CALL_OW 3
21974: ST_TO_ADDR
// end else
21975: GO 22054
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
21977: LD_ADDR_EXP 18
21981: PUSH
21982: LD_EXP 18
21986: PPUSH
21987: LD_INT 1
21989: PPUSH
21990: LD_EXP 18
21994: PUSH
21995: LD_INT 1
21997: ARRAY
21998: PUSH
21999: LD_VAR 0 2
22003: PUSH
22004: LD_VAR 0 2
22008: ARRAY
22009: ADD
22010: PPUSH
22011: CALL_OW 1
22015: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
22016: LD_VAR 0 2
22020: PUSH
22021: LD_VAR 0 2
22025: ARRAY
22026: PPUSH
22027: LD_INT 1
22029: PPUSH
22030: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
22034: LD_ADDR_VAR 0 2
22038: PUSH
22039: LD_VAR 0 2
22043: PPUSH
22044: LD_VAR 0 2
22048: PPUSH
22049: CALL_OW 3
22053: ST_TO_ADDR
// end ; end ;
22054: GO 21889
22056: POP
22057: POP
// if tmp2 then
22058: LD_VAR 0 3
22062: IFFALSE 22080
// tmp := tmp union tmp2 ;
22064: LD_ADDR_VAR 0 2
22068: PUSH
22069: LD_VAR 0 2
22073: PUSH
22074: LD_VAR 0 3
22078: UNION
22079: ST_TO_ADDR
// for i := 0 to 3 do
22080: LD_ADDR_VAR 0 1
22084: PUSH
22085: DOUBLE
22086: LD_INT 0
22088: DEC
22089: ST_TO_ADDR
22090: LD_INT 3
22092: PUSH
22093: FOR_TO
22094: IFFALSE 22257
// begin if not tmp [ tmp - i ] then
22096: LD_VAR 0 2
22100: PUSH
22101: LD_VAR 0 2
22105: PUSH
22106: LD_VAR 0 1
22110: MINUS
22111: ARRAY
22112: NOT
22113: IFFALSE 22210
// begin uc_side := 4 ;
22115: LD_ADDR_OWVAR 20
22119: PUSH
22120: LD_INT 4
22122: ST_TO_ADDR
// uc_nation := 1 ;
22123: LD_ADDR_OWVAR 21
22127: PUSH
22128: LD_INT 1
22130: ST_TO_ADDR
// InitHc ;
22131: CALL_OW 19
// PrepareSoldier ( sex_male , 3 ) ;
22135: LD_INT 1
22137: PPUSH
22138: LD_INT 3
22140: PPUSH
22141: CALL_OW 381
// un := CreateHuman ;
22145: LD_ADDR_VAR 0 8
22149: PUSH
22150: CALL_OW 44
22154: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( 39 , 61 ) ) ;
22155: LD_VAR 0 8
22159: PPUSH
22160: LD_INT 39
22162: PPUSH
22163: LD_INT 61
22165: PPUSH
22166: CALL_OW 428
22170: PPUSH
22171: CALL_OW 52
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ un ) ;
22175: LD_ADDR_EXP 18
22179: PUSH
22180: LD_EXP 18
22184: PPUSH
22185: LD_INT 2
22187: PPUSH
22188: LD_EXP 18
22192: PUSH
22193: LD_INT 2
22195: ARRAY
22196: PUSH
22197: LD_VAR 0 8
22201: ADD
22202: PPUSH
22203: CALL_OW 1
22207: ST_TO_ADDR
// end else
22208: GO 22255
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
22210: LD_ADDR_EXP 18
22214: PUSH
22215: LD_EXP 18
22219: PPUSH
22220: LD_INT 2
22222: PPUSH
22223: LD_EXP 18
22227: PUSH
22228: LD_INT 2
22230: ARRAY
22231: PUSH
22232: LD_VAR 0 2
22236: PUSH
22237: LD_VAR 0 2
22241: PUSH
22242: LD_VAR 0 1
22246: MINUS
22247: ARRAY
22248: ADD
22249: PPUSH
22250: CALL_OW 1
22254: ST_TO_ADDR
// end ;
22255: GO 22093
22257: POP
22258: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
22259: LD_ADDR_EXP 102
22263: PUSH
22264: LD_EXP 102
22268: PPUSH
22269: LD_INT 4
22271: PPUSH
22272: LD_EXP 102
22276: PUSH
22277: LD_INT 4
22279: ARRAY
22280: PUSH
22281: LD_EXP 18
22285: PUSH
22286: LD_INT 1
22288: ARRAY
22289: DIFF
22290: PPUSH
22291: CALL_OW 1
22295: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
22296: LD_VAR 0 5
22300: PUSH
22301: LD_INT 1
22303: ARRAY
22304: PPUSH
22305: CALL_OW 313
22309: IFFALSE 22364
// begin for i in UnitsInside ( arm [ 1 ] ) do
22311: LD_ADDR_VAR 0 1
22315: PUSH
22316: LD_VAR 0 5
22320: PUSH
22321: LD_INT 1
22323: ARRAY
22324: PPUSH
22325: CALL_OW 313
22329: PUSH
22330: FOR_IN
22331: IFFALSE 22362
// begin ComExitBuilding ( i ) ;
22333: LD_VAR 0 1
22337: PPUSH
22338: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
22342: LD_VAR 0 1
22346: PPUSH
22347: LD_VAR 0 6
22351: PUSH
22352: LD_INT 1
22354: ARRAY
22355: PPUSH
22356: CALL_OW 180
// end ;
22360: GO 22330
22362: POP
22363: POP
// end ; wait ( 0 0$5 ) ;
22364: LD_INT 175
22366: PPUSH
22367: CALL_OW 67
// repeat wait ( 0 0$1 ) until not UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) ;
22371: LD_INT 35
22373: PPUSH
22374: CALL_OW 67
22378: LD_EXP 18
22382: PUSH
22383: LD_INT 1
22385: ARRAY
22386: PPUSH
22387: LD_INT 55
22389: PUSH
22390: EMPTY
22391: LIST
22392: PPUSH
22393: CALL_OW 72
22397: NOT
22398: IFFALSE 22371
// for i in powellSquadAttack [ 1 ] do
22400: LD_ADDR_VAR 0 1
22404: PUSH
22405: LD_EXP 18
22409: PUSH
22410: LD_INT 1
22412: ARRAY
22413: PUSH
22414: FOR_IN
22415: IFFALSE 22522
// begin if IsInUnit ( i ) then
22417: LD_VAR 0 1
22421: PPUSH
22422: CALL_OW 310
22426: IFFALSE 22437
// ComExitBuilding ( i ) ;
22428: LD_VAR 0 1
22432: PPUSH
22433: CALL_OW 122
// if GetClass ( i ) <> 1 then
22437: LD_VAR 0 1
22441: PPUSH
22442: CALL_OW 257
22446: PUSH
22447: LD_INT 1
22449: NONEQUAL
22450: IFFALSE 22491
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
22452: LD_VAR 0 1
22456: PPUSH
22457: LD_VAR 0 5
22461: PUSH
22462: LD_INT 1
22464: ARRAY
22465: PPUSH
22466: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
22470: LD_VAR 0 1
22474: PPUSH
22475: LD_INT 1
22477: PPUSH
22478: CALL_OW 183
// AddComExitBuilding ( i ) ;
22482: LD_VAR 0 1
22486: PPUSH
22487: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
22491: LD_VAR 0 1
22495: PPUSH
22496: LD_INT 60
22498: PPUSH
22499: LD_INT 94
22501: PPUSH
22502: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
22506: LD_VAR 0 1
22510: PPUSH
22511: LD_EXP 61
22515: PPUSH
22516: CALL_OW 179
// end ;
22520: GO 22414
22522: POP
22523: POP
// wait ( 0 0$45 ) ;
22524: LD_INT 1575
22526: PPUSH
22527: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
22531: LD_EXP 61
22535: PPUSH
22536: LD_STRING D4-Pow-1
22538: PPUSH
22539: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
22543: LD_ADDR_VAR 0 2
22547: PUSH
22548: LD_EXP 18
22552: PUSH
22553: LD_INT 1
22555: ARRAY
22556: PPUSH
22557: LD_INT 26
22559: PUSH
22560: LD_INT 1
22562: PUSH
22563: EMPTY
22564: LIST
22565: LIST
22566: PPUSH
22567: CALL_OW 72
22571: ST_TO_ADDR
// if tmp then
22572: LD_VAR 0 2
22576: IFFALSE 22594
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
22578: LD_VAR 0 2
22582: PUSH
22583: LD_INT 1
22585: ARRAY
22586: PPUSH
22587: LD_STRING D4-Sol1-1
22589: PPUSH
22590: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
22594: LD_EXP 61
22598: PPUSH
22599: LD_STRING D4-Pow-2
22601: PPUSH
22602: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
22606: LD_ADDR_VAR 0 1
22610: PUSH
22611: DOUBLE
22612: LD_INT 1
22614: DEC
22615: ST_TO_ADDR
22616: LD_EXP 18
22620: PUSH
22621: LD_INT 1
22623: ARRAY
22624: PUSH
22625: FOR_TO
22626: IFFALSE 22719
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
22628: LD_EXP 18
22632: PUSH
22633: LD_INT 1
22635: ARRAY
22636: PUSH
22637: LD_VAR 0 1
22641: ARRAY
22642: PPUSH
22643: LD_EXP 121
22647: PUSH
22648: LD_INT 4
22650: ARRAY
22651: PUSH
22652: LD_INT 1
22654: ARRAY
22655: PPUSH
22656: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
22660: LD_ADDR_EXP 121
22664: PUSH
22665: LD_EXP 121
22669: PPUSH
22670: LD_INT 4
22672: PPUSH
22673: LD_EXP 121
22677: PUSH
22678: LD_INT 4
22680: ARRAY
22681: PPUSH
22682: LD_INT 1
22684: PPUSH
22685: CALL_OW 3
22689: PPUSH
22690: CALL_OW 1
22694: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
22695: LD_INT 8
22697: PPUSH
22698: LD_EXP 18
22702: PUSH
22703: LD_INT 1
22705: ARRAY
22706: PUSH
22707: LD_VAR 0 1
22711: ARRAY
22712: PPUSH
22713: CALL_OW 471
// end ;
22717: GO 22625
22719: POP
22720: POP
// repeat wait ( 0 0$1 ) ;
22721: LD_INT 35
22723: PPUSH
22724: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
22728: LD_EXP 18
22732: PUSH
22733: LD_INT 1
22735: ARRAY
22736: PPUSH
22737: LD_INT 55
22739: PUSH
22740: EMPTY
22741: LIST
22742: PPUSH
22743: CALL_OW 72
22747: PUSH
22748: LD_INT 4
22750: GREATEREQUAL
22751: IFFALSE 22721
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
22753: LD_EXP 18
22757: PUSH
22758: LD_INT 1
22760: ARRAY
22761: PPUSH
22762: LD_INT 69
22764: PPUSH
22765: LD_INT 94
22767: PPUSH
22768: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
22772: LD_EXP 18
22776: PUSH
22777: LD_INT 1
22779: ARRAY
22780: PPUSH
22781: LD_INT 82
22783: PPUSH
22784: LD_INT 83
22786: PPUSH
22787: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
22791: LD_EXP 18
22795: PUSH
22796: LD_INT 1
22798: ARRAY
22799: PPUSH
22800: LD_INT 77
22802: PPUSH
22803: LD_INT 69
22805: PPUSH
22806: CALL_OW 174
// wait ( 0 0$30 ) ;
22810: LD_INT 1050
22812: PPUSH
22813: CALL_OW 67
// repeat wait ( 3 ) ;
22817: LD_INT 3
22819: PPUSH
22820: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
22824: LD_ADDR_VAR 0 1
22828: PUSH
22829: LD_EXP 18
22833: PUSH
22834: LD_INT 1
22836: ARRAY
22837: PUSH
22838: FOR_IN
22839: IFFALSE 22975
// begin if GetLives ( i ) < 990 then
22841: LD_VAR 0 1
22845: PPUSH
22846: CALL_OW 256
22850: PUSH
22851: LD_INT 990
22853: LESS
22854: IFFALSE 22868
// SetLives ( i , 1000 ) ;
22856: LD_VAR 0 1
22860: PPUSH
22861: LD_INT 1000
22863: PPUSH
22864: CALL_OW 234
// if not IsInUnit ( i ) then
22868: LD_VAR 0 1
22872: PPUSH
22873: CALL_OW 310
22877: NOT
22878: IFFALSE 22973
// begin if not HasTask ( i ) then
22880: LD_VAR 0 1
22884: PPUSH
22885: CALL_OW 314
22889: NOT
22890: IFFALSE 22907
// ComMoveXY ( i , 64 , 93 ) ;
22892: LD_VAR 0 1
22896: PPUSH
22897: LD_INT 64
22899: PPUSH
22900: LD_INT 93
22902: PPUSH
22903: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
22907: LD_VAR 0 4
22911: NOT
22912: PUSH
22913: LD_VAR 0 1
22917: PPUSH
22918: CALL_OW 258
22922: PUSH
22923: LD_INT 1
22925: EQUAL
22926: AND
22927: IFFALSE 22973
// begin retreat := true ;
22929: LD_ADDR_VAR 0 4
22933: PUSH
22934: LD_INT 1
22936: ST_TO_ADDR
// SetTag ( i , 2 ) ;
22937: LD_VAR 0 1
22941: PPUSH
22942: LD_INT 2
22944: PPUSH
22945: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
22949: LD_VAR 0 1
22953: PPUSH
22954: LD_STRING D4a-Sol1-1
22956: PPUSH
22957: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
22961: LD_EXP 61
22965: PPUSH
22966: LD_STRING D4a-Pow-1
22968: PPUSH
22969: CALL_OW 88
// end ; end ; end ;
22973: GO 22838
22975: POP
22976: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_inarea , powellBase ] ) >= 4 ;
22977: LD_EXP 18
22981: PUSH
22982: LD_INT 1
22984: ARRAY
22985: PPUSH
22986: LD_INT 95
22988: PUSH
22989: LD_INT 9
22991: PUSH
22992: EMPTY
22993: LIST
22994: LIST
22995: PPUSH
22996: CALL_OW 72
23000: PUSH
23001: LD_INT 4
23003: GREATEREQUAL
23004: IFFALSE 22817
// for i in powellSquadAttack [ 1 ] do
23006: LD_ADDR_VAR 0 1
23010: PUSH
23011: LD_EXP 18
23015: PUSH
23016: LD_INT 1
23018: ARRAY
23019: PUSH
23020: FOR_IN
23021: IFFALSE 23157
// begin if GetTag ( i ) = 2 then
23023: LD_VAR 0 1
23027: PPUSH
23028: CALL_OW 110
23032: PUSH
23033: LD_INT 2
23035: EQUAL
23036: IFFALSE 23098
// begin ComMoveXY ( i , 60 , 94 ) ;
23038: LD_VAR 0 1
23042: PPUSH
23043: LD_INT 60
23045: PPUSH
23046: LD_INT 94
23048: PPUSH
23049: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
23053: LD_VAR 0 1
23057: PPUSH
23058: LD_EXP 61
23062: PPUSH
23063: CALL_OW 179
// wait ( 0 0$3 ) ;
23067: LD_INT 105
23069: PPUSH
23070: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
23074: LD_VAR 0 1
23078: PPUSH
23079: LD_STRING D4a-Sol1-2
23081: PPUSH
23082: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
23086: LD_EXP 61
23090: PPUSH
23091: LD_STRING D4a-Pow-2
23093: PPUSH
23094: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
23098: LD_VAR 0 1
23102: PPUSH
23103: LD_INT 0
23105: PPUSH
23106: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
23110: LD_ADDR_EXP 102
23114: PUSH
23115: LD_EXP 102
23119: PPUSH
23120: LD_INT 4
23122: PPUSH
23123: LD_EXP 102
23127: PUSH
23128: LD_INT 4
23130: ARRAY
23131: PUSH
23132: LD_VAR 0 1
23136: UNION
23137: PPUSH
23138: CALL_OW 1
23142: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
23143: LD_INT 8
23145: PPUSH
23146: LD_VAR 0 1
23150: PPUSH
23151: CALL_OW 472
// end ;
23155: GO 23020
23157: POP
23158: POP
// wait ( 1 1$00 ) ;
23159: LD_INT 2100
23161: PPUSH
23162: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
23166: LD_ADDR_VAR 0 9
23170: PUSH
23171: LD_INT 22
23173: PUSH
23174: LD_INT 4
23176: PUSH
23177: EMPTY
23178: LIST
23179: LIST
23180: PUSH
23181: LD_INT 30
23183: PUSH
23184: LD_INT 32
23186: PUSH
23187: EMPTY
23188: LIST
23189: LIST
23190: PUSH
23191: LD_INT 58
23193: PUSH
23194: EMPTY
23195: LIST
23196: PUSH
23197: EMPTY
23198: LIST
23199: LIST
23200: LIST
23201: PPUSH
23202: CALL_OW 69
23206: ST_TO_ADDR
// if tmp then
23207: LD_VAR 0 2
23211: IFFALSE 23451
// begin for i := 1 to tmp do
23213: LD_ADDR_VAR 0 1
23217: PUSH
23218: DOUBLE
23219: LD_INT 1
23221: DEC
23222: ST_TO_ADDR
23223: LD_VAR 0 2
23227: PUSH
23228: FOR_TO
23229: IFFALSE 23442
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
23231: LD_ADDR_EXP 102
23235: PUSH
23236: LD_EXP 102
23240: PPUSH
23241: LD_INT 4
23243: PPUSH
23244: LD_EXP 102
23248: PUSH
23249: LD_INT 4
23251: ARRAY
23252: PUSH
23253: LD_VAR 0 2
23257: PUSH
23258: LD_VAR 0 1
23262: ARRAY
23263: DIFF
23264: PPUSH
23265: CALL_OW 1
23269: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
23270: LD_ADDR_VAR 0 10
23274: PUSH
23275: LD_VAR 0 2
23279: PUSH
23280: LD_VAR 0 1
23284: ARRAY
23285: PPUSH
23286: CALL_OW 310
23290: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
23291: LD_VAR 0 10
23295: PUSH
23296: LD_VAR 0 10
23300: PPUSH
23301: CALL_OW 266
23305: PUSH
23306: LD_INT 32
23308: EQUAL
23309: AND
23310: IFFALSE 23314
// continue ;
23312: GO 23228
// if t then
23314: LD_VAR 0 10
23318: IFFALSE 23335
// ComExitBuilding ( tmp [ i ] ) ;
23320: LD_VAR 0 2
23324: PUSH
23325: LD_VAR 0 1
23329: ARRAY
23330: PPUSH
23331: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
23335: LD_VAR 0 2
23339: PUSH
23340: LD_VAR 0 1
23344: ARRAY
23345: PPUSH
23346: LD_VAR 0 5
23350: PUSH
23351: LD_INT 1
23353: ARRAY
23354: PPUSH
23355: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
23359: LD_VAR 0 2
23363: PUSH
23364: LD_VAR 0 1
23368: ARRAY
23369: PPUSH
23370: LD_INT 1
23372: PPUSH
23373: CALL_OW 183
// if emptyTowers then
23377: LD_VAR 0 9
23381: IFFALSE 23440
// begin AddComExitBuilding ( tmp [ i ] ) ;
23383: LD_VAR 0 2
23387: PUSH
23388: LD_VAR 0 1
23392: ARRAY
23393: PPUSH
23394: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
23398: LD_VAR 0 2
23402: PUSH
23403: LD_VAR 0 1
23407: ARRAY
23408: PPUSH
23409: LD_VAR 0 9
23413: PUSH
23414: LD_INT 1
23416: ARRAY
23417: PPUSH
23418: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
23422: LD_ADDR_VAR 0 9
23426: PUSH
23427: LD_VAR 0 9
23431: PPUSH
23432: LD_INT 1
23434: PPUSH
23435: CALL_OW 3
23439: ST_TO_ADDR
// end ; end ;
23440: GO 23228
23442: POP
23443: POP
// wait ( 0 0$30 ) ;
23444: LD_INT 1050
23446: PPUSH
23447: CALL_OW 67
// end ; uc_side := 6 ;
23451: LD_ADDR_OWVAR 20
23455: PUSH
23456: LD_INT 6
23458: ST_TO_ADDR
// uc_nation := 3 ;
23459: LD_ADDR_OWVAR 21
23463: PUSH
23464: LD_INT 3
23466: ST_TO_ADDR
// ru := [ ] ;
23467: LD_ADDR_VAR 0 7
23471: PUSH
23472: EMPTY
23473: ST_TO_ADDR
// for i = 1 to 5 do
23474: LD_ADDR_VAR 0 1
23478: PUSH
23479: DOUBLE
23480: LD_INT 1
23482: DEC
23483: ST_TO_ADDR
23484: LD_INT 5
23486: PUSH
23487: FOR_TO
23488: IFFALSE 23608
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
23490: LD_INT 22
23492: PUSH
23493: LD_INT 23
23495: PUSH
23496: EMPTY
23497: LIST
23498: LIST
23499: PUSH
23500: LD_INT 1
23502: PPUSH
23503: LD_INT 2
23505: PPUSH
23506: CALL_OW 12
23510: ARRAY
23511: PPUSH
23512: LD_INT 1
23514: PPUSH
23515: LD_INT 3
23517: PPUSH
23518: LD_INT 43
23520: PUSH
23521: LD_INT 44
23523: PUSH
23524: EMPTY
23525: LIST
23526: LIST
23527: PUSH
23528: LD_INT 1
23530: PPUSH
23531: LD_INT 2
23533: PPUSH
23534: CALL_OW 12
23538: ARRAY
23539: PPUSH
23540: LD_INT 89
23542: PPUSH
23543: CALL 75220 0 5
// un := CreateVehicle ;
23547: LD_ADDR_VAR 0 8
23551: PUSH
23552: CALL_OW 45
23556: ST_TO_ADDR
// SetDir ( un , 4 ) ;
23557: LD_VAR 0 8
23561: PPUSH
23562: LD_INT 4
23564: PPUSH
23565: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
23569: LD_VAR 0 8
23573: PPUSH
23574: LD_INT 136
23576: PPUSH
23577: LD_INT 90
23579: PPUSH
23580: LD_INT 8
23582: PPUSH
23583: LD_INT 0
23585: PPUSH
23586: CALL_OW 50
// ru := ru ^ un ;
23590: LD_ADDR_VAR 0 7
23594: PUSH
23595: LD_VAR 0 7
23599: PUSH
23600: LD_VAR 0 8
23604: ADD
23605: ST_TO_ADDR
// end ;
23606: GO 23487
23608: POP
23609: POP
// if ru then
23610: LD_VAR 0 7
23614: IFFALSE 23631
// ComAgressiveMove ( ru , 57 , 94 ) ;
23616: LD_VAR 0 7
23620: PPUSH
23621: LD_INT 57
23623: PPUSH
23624: LD_INT 94
23626: PPUSH
23627: CALL_OW 114
// wait ( 3 3$00 ) ;
23631: LD_INT 6300
23633: PPUSH
23634: CALL_OW 67
// p := UnitsInside ( HexInfo ( 54 , 85 ) ) ;
23638: LD_ADDR_VAR 0 11
23642: PUSH
23643: LD_INT 54
23645: PPUSH
23646: LD_INT 85
23648: PPUSH
23649: CALL_OW 428
23653: PPUSH
23654: CALL_OW 313
23658: ST_TO_ADDR
// t := 0 ;
23659: LD_ADDR_VAR 0 10
23663: PUSH
23664: LD_INT 0
23666: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_empty ] ] , [ f_btype , b_bunker ] ] ) do
23667: LD_ADDR_VAR 0 1
23671: PUSH
23672: LD_INT 22
23674: PUSH
23675: LD_INT 4
23677: PUSH
23678: EMPTY
23679: LIST
23680: LIST
23681: PUSH
23682: LD_INT 3
23684: PUSH
23685: LD_INT 58
23687: PUSH
23688: EMPTY
23689: LIST
23690: PUSH
23691: EMPTY
23692: LIST
23693: LIST
23694: PUSH
23695: LD_INT 30
23697: PUSH
23698: LD_INT 32
23700: PUSH
23701: EMPTY
23702: LIST
23703: LIST
23704: PUSH
23705: EMPTY
23706: LIST
23707: LIST
23708: LIST
23709: PPUSH
23710: CALL_OW 69
23714: PUSH
23715: FOR_IN
23716: IFFALSE 23842
// begin if p + t > 5 then
23718: LD_VAR 0 11
23722: PUSH
23723: LD_VAR 0 10
23727: PLUS
23728: PUSH
23729: LD_INT 5
23731: GREATER
23732: IFFALSE 23736
// break ;
23734: GO 23842
// un := UnitsInside ( i ) ;
23736: LD_ADDR_VAR 0 8
23740: PUSH
23741: LD_VAR 0 1
23745: PPUSH
23746: CALL_OW 313
23750: ST_TO_ADDR
// ComExitBuilding ( un ) ;
23751: LD_VAR 0 8
23755: PPUSH
23756: CALL_OW 122
// AddComEnterUnit ( un , HexInfo ( 54 , 85 ) ) ;
23760: LD_VAR 0 8
23764: PPUSH
23765: LD_INT 54
23767: PPUSH
23768: LD_INT 85
23770: PPUSH
23771: CALL_OW 428
23775: PPUSH
23776: CALL_OW 180
// AddComChangeProfession ( un , class_mechanic ) ;
23780: LD_VAR 0 8
23784: PPUSH
23785: LD_INT 3
23787: PPUSH
23788: CALL_OW 183
// t := Inc ( t ) ;
23792: LD_ADDR_VAR 0 10
23796: PUSH
23797: LD_VAR 0 10
23801: PPUSH
23802: CALL 109452 0 1
23806: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] ^ un ) ;
23807: LD_ADDR_EXP 102
23811: PUSH
23812: LD_EXP 102
23816: PPUSH
23817: LD_INT 4
23819: PPUSH
23820: LD_EXP 102
23824: PUSH
23825: LD_INT 4
23827: ARRAY
23828: PUSH
23829: LD_VAR 0 8
23833: ADD
23834: PPUSH
23835: CALL_OW 1
23839: ST_TO_ADDR
// end ;
23840: GO 23715
23842: POP
23843: POP
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
23844: LD_INT 4
23846: PPUSH
23847: LD_INT 3
23849: PUSH
23850: LD_INT 1
23852: PUSH
23853: LD_INT 1
23855: PUSH
23856: LD_INT 5
23858: PUSH
23859: EMPTY
23860: LIST
23861: LIST
23862: LIST
23863: LIST
23864: PUSH
23865: LD_INT 4
23867: PUSH
23868: LD_INT 1
23870: PUSH
23871: LD_INT 1
23873: PUSH
23874: LD_INT 6
23876: PUSH
23877: EMPTY
23878: LIST
23879: LIST
23880: LIST
23881: LIST
23882: PUSH
23883: LD_INT 4
23885: PUSH
23886: LD_INT 1
23888: PUSH
23889: LD_INT 1
23891: PUSH
23892: LD_INT 7
23894: PUSH
23895: EMPTY
23896: LIST
23897: LIST
23898: LIST
23899: LIST
23900: PUSH
23901: LD_INT 3
23903: PUSH
23904: LD_INT 1
23906: PUSH
23907: LD_INT 1
23909: PUSH
23910: LD_INT 7
23912: PUSH
23913: EMPTY
23914: LIST
23915: LIST
23916: LIST
23917: LIST
23918: PUSH
23919: LD_INT 3
23921: PUSH
23922: LD_INT 1
23924: PUSH
23925: LD_INT 1
23927: PUSH
23928: LD_INT 5
23930: PUSH
23931: EMPTY
23932: LIST
23933: LIST
23934: LIST
23935: LIST
23936: PUSH
23937: EMPTY
23938: LIST
23939: LIST
23940: LIST
23941: LIST
23942: LIST
23943: PPUSH
23944: CALL 63822 0 2
// missionStage := 4 ;
23948: LD_ADDR_EXP 15
23952: PUSH
23953: LD_INT 4
23955: ST_TO_ADDR
// end ;
23956: PPOPN 11
23958: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , t , _xy , dist , fac , arm , speaker , emp_towers , veh ;
23959: LD_EXP 15
23963: PUSH
23964: LD_INT 4
23966: EQUAL
23967: PUSH
23968: LD_INT 22
23970: PUSH
23971: LD_INT 4
23973: PUSH
23974: EMPTY
23975: LIST
23976: LIST
23977: PUSH
23978: LD_INT 21
23980: PUSH
23981: LD_INT 2
23983: PUSH
23984: EMPTY
23985: LIST
23986: LIST
23987: PUSH
23988: EMPTY
23989: LIST
23990: LIST
23991: PPUSH
23992: CALL_OW 69
23996: PUSH
23997: LD_INT 5
23999: GREATEREQUAL
24000: AND
24001: IFFALSE 28365
24003: GO 24005
24005: DISABLE
24006: LD_INT 0
24008: PPUSH
24009: PPUSH
24010: PPUSH
24011: PPUSH
24012: PPUSH
24013: PPUSH
24014: PPUSH
24015: PPUSH
24016: PPUSH
24017: PPUSH
24018: PPUSH
24019: PPUSH
24020: PPUSH
24021: PPUSH
// begin wait ( 0 0$10 ) ;
24022: LD_INT 350
24024: PPUSH
24025: CALL_OW 67
// missionStage := 5 ;
24029: LD_ADDR_EXP 15
24033: PUSH
24034: LD_INT 5
24036: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
24037: LD_ADDR_VAR 0 11
24041: PUSH
24042: LD_INT 22
24044: PUSH
24045: LD_INT 4
24047: PUSH
24048: EMPTY
24049: LIST
24050: LIST
24051: PUSH
24052: LD_INT 2
24054: PUSH
24055: LD_INT 30
24057: PUSH
24058: LD_INT 4
24060: PUSH
24061: EMPTY
24062: LIST
24063: LIST
24064: PUSH
24065: LD_INT 30
24067: PUSH
24068: LD_INT 5
24070: PUSH
24071: EMPTY
24072: LIST
24073: LIST
24074: PUSH
24075: EMPTY
24076: LIST
24077: LIST
24078: LIST
24079: PUSH
24080: EMPTY
24081: LIST
24082: LIST
24083: PPUSH
24084: CALL_OW 69
24088: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
24089: LD_ADDR_VAR 0 6
24093: PUSH
24094: LD_INT 22
24096: PUSH
24097: LD_INT 4
24099: PUSH
24100: EMPTY
24101: LIST
24102: LIST
24103: PUSH
24104: LD_INT 21
24106: PUSH
24107: LD_INT 1
24109: PUSH
24110: EMPTY
24111: LIST
24112: LIST
24113: PUSH
24114: LD_INT 3
24116: PUSH
24117: LD_INT 25
24119: PUSH
24120: LD_INT 16
24122: PUSH
24123: EMPTY
24124: LIST
24125: LIST
24126: PUSH
24127: EMPTY
24128: LIST
24129: LIST
24130: PUSH
24131: LD_INT 3
24133: PUSH
24134: LD_INT 25
24136: PUSH
24137: LD_INT 12
24139: PUSH
24140: EMPTY
24141: LIST
24142: LIST
24143: PUSH
24144: EMPTY
24145: LIST
24146: LIST
24147: PUSH
24148: EMPTY
24149: LIST
24150: LIST
24151: LIST
24152: LIST
24153: PPUSH
24154: CALL_OW 69
24158: PUSH
24159: LD_EXP 61
24163: DIFF
24164: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
24165: LD_ADDR_VAR 0 10
24169: PUSH
24170: LD_INT 22
24172: PUSH
24173: LD_INT 4
24175: PUSH
24176: EMPTY
24177: LIST
24178: LIST
24179: PUSH
24180: LD_INT 30
24182: PUSH
24183: LD_INT 3
24185: PUSH
24186: EMPTY
24187: LIST
24188: LIST
24189: PUSH
24190: EMPTY
24191: LIST
24192: LIST
24193: PPUSH
24194: CALL_OW 69
24198: PUSH
24199: LD_INT 1
24201: ARRAY
24202: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
24203: LD_INT 350
24205: PPUSH
24206: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
24210: LD_EXP 121
24214: PUSH
24215: LD_INT 4
24217: ARRAY
24218: PUSH
24219: LD_INT 5
24221: LESS
24222: PUSH
24223: LD_VAR 0 10
24227: PPUSH
24228: CALL_OW 461
24232: PUSH
24233: LD_INT 2
24235: EQUAL
24236: AND
24237: IFFALSE 24267
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
24239: LD_INT 4
24241: PPUSH
24242: LD_INT 3
24244: PUSH
24245: LD_INT 1
24247: PUSH
24248: LD_INT 1
24250: PUSH
24251: LD_INT 5
24253: PUSH
24254: EMPTY
24255: LIST
24256: LIST
24257: LIST
24258: LIST
24259: PUSH
24260: EMPTY
24261: LIST
24262: PPUSH
24263: CALL 63870 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
24267: LD_EXP 121
24271: PUSH
24272: LD_INT 4
24274: ARRAY
24275: PUSH
24276: LD_INT 5
24278: GREATEREQUAL
24279: PUSH
24280: LD_EXP 121
24284: PUSH
24285: LD_INT 4
24287: ARRAY
24288: PPUSH
24289: LD_INT 58
24291: PUSH
24292: EMPTY
24293: LIST
24294: PPUSH
24295: CALL_OW 72
24299: PUSH
24300: LD_INT 5
24302: GREATEREQUAL
24303: AND
24304: IFFALSE 24203
// powellAllowRetreat := false ;
24306: LD_ADDR_EXP 19
24310: PUSH
24311: LD_INT 0
24313: ST_TO_ADDR
// activeAttacks := false ;
24314: LD_ADDR_EXP 16
24318: PUSH
24319: LD_INT 0
24321: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
24322: LD_INT 35
24324: PPUSH
24325: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
24329: LD_INT 22
24331: PUSH
24332: LD_INT 6
24334: PUSH
24335: EMPTY
24336: LIST
24337: LIST
24338: PPUSH
24339: CALL_OW 69
24343: PUSH
24344: LD_INT 0
24346: EQUAL
24347: IFFALSE 24322
// tmp := mc_vehicles [ 4 ] ;
24349: LD_ADDR_VAR 0 3
24353: PUSH
24354: LD_EXP 121
24358: PUSH
24359: LD_INT 4
24361: ARRAY
24362: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
24363: LD_ADDR_VAR 0 1
24367: PUSH
24368: DOUBLE
24369: LD_INT 1
24371: DEC
24372: ST_TO_ADDR
24373: LD_EXP 18
24377: PUSH
24378: FOR_TO
24379: IFFALSE 24701
// begin for j in powellSquadAttack [ i ] do
24381: LD_ADDR_VAR 0 2
24385: PUSH
24386: LD_EXP 18
24390: PUSH
24391: LD_VAR 0 1
24395: ARRAY
24396: PUSH
24397: FOR_IN
24398: IFFALSE 24697
// begin if j in mc_bases [ 4 ] then
24400: LD_VAR 0 2
24404: PUSH
24405: LD_EXP 102
24409: PUSH
24410: LD_INT 4
24412: ARRAY
24413: IN
24414: IFFALSE 24449
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff j ) ;
24416: LD_ADDR_EXP 102
24420: PUSH
24421: LD_EXP 102
24425: PPUSH
24426: LD_INT 4
24428: PPUSH
24429: LD_EXP 102
24433: PUSH
24434: LD_INT 4
24436: ARRAY
24437: PUSH
24438: LD_VAR 0 2
24442: DIFF
24443: PPUSH
24444: CALL_OW 1
24448: ST_TO_ADDR
// forces := forces diff j ;
24449: LD_ADDR_VAR 0 6
24453: PUSH
24454: LD_VAR 0 6
24458: PUSH
24459: LD_VAR 0 2
24463: DIFF
24464: ST_TO_ADDR
// SetTag ( j , 1 ) ;
24465: LD_VAR 0 2
24469: PPUSH
24470: LD_INT 1
24472: PPUSH
24473: CALL_OW 109
// wait ( 0 0$2 ) ;
24477: LD_INT 70
24479: PPUSH
24480: CALL_OW 67
// if IsInUnit ( j ) then
24484: LD_VAR 0 2
24488: PPUSH
24489: CALL_OW 310
24493: IFFALSE 24504
// ComExitBuilding ( j ) ;
24495: LD_VAR 0 2
24499: PPUSH
24500: CALL_OW 122
// if GetClass ( j ) <> 1 and not HasTask ( j ) then
24504: LD_VAR 0 2
24508: PPUSH
24509: CALL_OW 257
24513: PUSH
24514: LD_INT 1
24516: NONEQUAL
24517: PUSH
24518: LD_VAR 0 2
24522: PPUSH
24523: CALL_OW 314
24527: NOT
24528: AND
24529: IFFALSE 24609
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
24531: LD_VAR 0 11
24535: PUSH
24536: LD_INT 1
24538: ARRAY
24539: PPUSH
24540: CALL_OW 313
24544: PUSH
24545: LD_INT 5
24547: GREATEREQUAL
24548: IFFALSE 24570
// ComEnterUnit ( j , arm [ 2 ] ) else
24550: LD_VAR 0 2
24554: PPUSH
24555: LD_VAR 0 11
24559: PUSH
24560: LD_INT 2
24562: ARRAY
24563: PPUSH
24564: CALL_OW 120
24568: GO 24588
// ComEnterUnit ( j , arm [ 1 ] ) ;
24570: LD_VAR 0 2
24574: PPUSH
24575: LD_VAR 0 11
24579: PUSH
24580: LD_INT 1
24582: ARRAY
24583: PPUSH
24584: CALL_OW 120
// AddComChangeProfession ( j , 1 ) ;
24588: LD_VAR 0 2
24592: PPUSH
24593: LD_INT 1
24595: PPUSH
24596: CALL_OW 183
// AddComExitBuilding ( j ) ;
24600: LD_VAR 0 2
24604: PPUSH
24605: CALL_OW 182
// end ; if i = 2 then
24609: LD_VAR 0 1
24613: PUSH
24614: LD_INT 2
24616: EQUAL
24617: IFFALSE 24634
// AddComMoveXY ( j , 61 , 93 ) ;
24619: LD_VAR 0 2
24623: PPUSH
24624: LD_INT 61
24626: PPUSH
24627: LD_INT 93
24629: PPUSH
24630: CALL_OW 171
// if i = 1 then
24634: LD_VAR 0 1
24638: PUSH
24639: LD_INT 1
24641: EQUAL
24642: IFFALSE 24695
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
24644: LD_VAR 0 2
24648: PPUSH
24649: LD_VAR 0 3
24653: PUSH
24654: LD_INT 1
24656: ARRAY
24657: PPUSH
24658: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
24662: LD_ADDR_VAR 0 3
24666: PUSH
24667: LD_VAR 0 3
24671: PPUSH
24672: LD_INT 1
24674: PPUSH
24675: CALL_OW 3
24679: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
24680: LD_VAR 0 2
24684: PPUSH
24685: LD_INT 69
24687: PPUSH
24688: LD_INT 94
24690: PPUSH
24691: CALL_OW 171
// end ; end ;
24695: GO 24397
24697: POP
24698: POP
// end ;
24699: GO 24378
24701: POP
24702: POP
// wait ( 0 0$30 ) ;
24703: LD_INT 1050
24705: PPUSH
24706: CALL_OW 67
// MC_Kill ( 4 ) ;
24710: LD_INT 4
24712: PPUSH
24713: CALL 39845 0 1
// tmp := UnitsInside ( fac ) ;
24717: LD_ADDR_VAR 0 3
24721: PUSH
24722: LD_VAR 0 10
24726: PPUSH
24727: CALL_OW 313
24731: ST_TO_ADDR
// if tmp then
24732: LD_VAR 0 3
24736: IFFALSE 24857
// for i in tmp do
24738: LD_ADDR_VAR 0 1
24742: PUSH
24743: LD_VAR 0 3
24747: PUSH
24748: FOR_IN
24749: IFFALSE 24855
// begin ComExitBuilding ( i ) ;
24751: LD_VAR 0 1
24755: PPUSH
24756: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
24760: LD_VAR 0 11
24764: PUSH
24765: LD_INT 2
24767: ARRAY
24768: PPUSH
24769: CALL_OW 313
24773: PUSH
24774: LD_INT 6
24776: LESS
24777: IFFALSE 24799
// AddComEnterUnit ( i , arm [ 2 ] ) else
24779: LD_VAR 0 1
24783: PPUSH
24784: LD_VAR 0 11
24788: PUSH
24789: LD_INT 2
24791: ARRAY
24792: PPUSH
24793: CALL_OW 180
24797: GO 24853
// if UnitsInside ( arm [ 1 ] ) < 6 then
24799: LD_VAR 0 11
24803: PUSH
24804: LD_INT 1
24806: ARRAY
24807: PPUSH
24808: CALL_OW 313
24812: PUSH
24813: LD_INT 6
24815: LESS
24816: IFFALSE 24838
// AddComEnterUnit ( i , arm [ 1 ] ) else
24818: LD_VAR 0 1
24822: PPUSH
24823: LD_VAR 0 11
24827: PUSH
24828: LD_INT 1
24830: ARRAY
24831: PPUSH
24832: CALL_OW 180
24836: GO 24853
// AddComMoveXY ( i , 37 , 68 ) ;
24838: LD_VAR 0 1
24842: PPUSH
24843: LD_INT 37
24845: PPUSH
24846: LD_INT 68
24848: PPUSH
24849: CALL_OW 171
// end ;
24853: GO 24748
24855: POP
24856: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
24857: LD_ADDR_VAR 0 12
24861: PUSH
24862: LD_VAR 0 6
24866: PPUSH
24867: LD_INT 26
24869: PUSH
24870: LD_INT 1
24872: PUSH
24873: EMPTY
24874: LIST
24875: LIST
24876: PPUSH
24877: CALL_OW 72
24881: PUSH
24882: LD_EXP 62
24886: DIFF
24887: ST_TO_ADDR
// if not speaker then
24888: LD_VAR 0 12
24892: NOT
24893: IFFALSE 24920
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
24895: LD_ADDR_VAR 0 12
24899: PUSH
24900: LD_VAR 0 6
24904: PPUSH
24905: LD_INT 26
24907: PUSH
24908: LD_INT 1
24910: PUSH
24911: EMPTY
24912: LIST
24913: LIST
24914: PPUSH
24915: CALL_OW 72
24919: ST_TO_ADDR
// if speaker then
24920: LD_VAR 0 12
24924: IFFALSE 24940
// speaker := speaker [ 1 ] ;
24926: LD_ADDR_VAR 0 12
24930: PUSH
24931: LD_VAR 0 12
24935: PUSH
24936: LD_INT 1
24938: ARRAY
24939: ST_TO_ADDR
// Video ( true ) ;
24940: LD_INT 1
24942: PPUSH
24943: CALL 108063 0 1
// CenterNowOnUnits ( Powell ) ;
24947: LD_EXP 61
24951: PPUSH
24952: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
24956: LD_ADDR_VAR 0 3
24960: PUSH
24961: LD_VAR 0 6
24965: PPUSH
24966: LD_INT 3
24968: PUSH
24969: LD_INT 25
24971: PUSH
24972: LD_INT 1
24974: PUSH
24975: EMPTY
24976: LIST
24977: LIST
24978: PUSH
24979: EMPTY
24980: LIST
24981: LIST
24982: PPUSH
24983: CALL_OW 72
24987: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
24988: LD_ADDR_VAR 0 13
24992: PUSH
24993: LD_INT 22
24995: PUSH
24996: LD_INT 4
24998: PUSH
24999: EMPTY
25000: LIST
25001: LIST
25002: PUSH
25003: LD_INT 30
25005: PUSH
25006: LD_INT 32
25008: PUSH
25009: EMPTY
25010: LIST
25011: LIST
25012: PUSH
25013: LD_INT 58
25015: PUSH
25016: EMPTY
25017: LIST
25018: PUSH
25019: EMPTY
25020: LIST
25021: LIST
25022: LIST
25023: PPUSH
25024: CALL_OW 69
25028: ST_TO_ADDR
// t := Count ( tmp ) ;
25029: LD_ADDR_VAR 0 7
25033: PUSH
25034: LD_VAR 0 3
25038: PPUSH
25039: CALL 72482 0 1
25043: ST_TO_ADDR
// if t > 4 then
25044: LD_VAR 0 7
25048: PUSH
25049: LD_INT 4
25051: GREATER
25052: IFFALSE 25062
// t := 4 ;
25054: LD_ADDR_VAR 0 7
25058: PUSH
25059: LD_INT 4
25061: ST_TO_ADDR
// for i := 1 to t do
25062: LD_ADDR_VAR 0 1
25066: PUSH
25067: DOUBLE
25068: LD_INT 1
25070: DEC
25071: ST_TO_ADDR
25072: LD_VAR 0 7
25076: PUSH
25077: FOR_TO
25078: IFFALSE 25224
// begin if IsInUnit ( tmp [ i ] ) then
25080: LD_VAR 0 3
25084: PUSH
25085: LD_VAR 0 1
25089: ARRAY
25090: PPUSH
25091: CALL_OW 310
25095: IFFALSE 25112
// ComExitBuilding ( tmp [ i ] ) ;
25097: LD_VAR 0 3
25101: PUSH
25102: LD_VAR 0 1
25106: ARRAY
25107: PPUSH
25108: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
25112: LD_VAR 0 3
25116: PUSH
25117: LD_VAR 0 1
25121: ARRAY
25122: PPUSH
25123: LD_VAR 0 11
25127: PUSH
25128: LD_INT 1
25130: ARRAY
25131: PPUSH
25132: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
25136: LD_VAR 0 3
25140: PUSH
25141: LD_VAR 0 1
25145: ARRAY
25146: PPUSH
25147: LD_INT 1
25149: PPUSH
25150: CALL_OW 183
// if Count ( emp_towers ) then
25154: LD_VAR 0 13
25158: PPUSH
25159: CALL 72482 0 1
25163: IFFALSE 25222
// begin AddComExitBuilding ( tmp [ i ] ) ;
25165: LD_VAR 0 3
25169: PUSH
25170: LD_VAR 0 1
25174: ARRAY
25175: PPUSH
25176: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
25180: LD_VAR 0 3
25184: PUSH
25185: LD_VAR 0 1
25189: ARRAY
25190: PPUSH
25191: LD_VAR 0 13
25195: PUSH
25196: LD_INT 1
25198: ARRAY
25199: PPUSH
25200: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
25204: LD_ADDR_VAR 0 13
25208: PUSH
25209: LD_VAR 0 13
25213: PPUSH
25214: LD_INT 1
25216: PPUSH
25217: CALL_OW 3
25221: ST_TO_ADDR
// end ; end ;
25222: GO 25077
25224: POP
25225: POP
// wait ( 0 0$5 ) ;
25226: LD_INT 175
25228: PPUSH
25229: CALL_OW 67
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
25233: LD_VAR 0 3
25237: PPUSH
25238: LD_INT 3
25240: PUSH
25241: LD_INT 54
25243: PUSH
25244: EMPTY
25245: LIST
25246: PUSH
25247: EMPTY
25248: LIST
25249: LIST
25250: PPUSH
25251: CALL_OW 72
25255: IFFALSE 25275
// ComEnterUnit ( tmp , arm [ 1 ] ) ;
25257: LD_VAR 0 3
25261: PPUSH
25262: LD_VAR 0 11
25266: PUSH
25267: LD_INT 1
25269: ARRAY
25270: PPUSH
25271: CALL_OW 120
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
25275: LD_ADDR_VAR 0 3
25279: PUSH
25280: LD_EXP 18
25284: PUSH
25285: LD_INT 1
25287: ARRAY
25288: PUSH
25289: LD_EXP 18
25293: PUSH
25294: LD_INT 2
25296: ARRAY
25297: ADD
25298: PPUSH
25299: LD_INT 26
25301: PUSH
25302: LD_INT 1
25304: PUSH
25305: EMPTY
25306: LIST
25307: LIST
25308: PPUSH
25309: CALL_OW 72
25313: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
25314: LD_ADDR_VAR 0 1
25318: PUSH
25319: LD_EXP 18
25323: PUSH
25324: LD_INT 2
25326: ARRAY
25327: PUSH
25328: FOR_IN
25329: IFFALSE 25347
// ComTurnUnit ( i , Powell ) ;
25331: LD_VAR 0 1
25335: PPUSH
25336: LD_EXP 61
25340: PPUSH
25341: CALL_OW 119
25345: GO 25328
25347: POP
25348: POP
// Say ( Powell , D5-Pow-1 ) ;
25349: LD_EXP 61
25353: PPUSH
25354: LD_STRING D5-Pow-1
25356: PPUSH
25357: CALL_OW 88
// if tmp then
25361: LD_VAR 0 3
25365: IFFALSE 25383
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
25367: LD_VAR 0 3
25371: PUSH
25372: LD_INT 1
25374: ARRAY
25375: PPUSH
25376: LD_STRING D5-Sol2-1
25378: PPUSH
25379: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
25383: LD_EXP 61
25387: PPUSH
25388: LD_STRING D5-Pow-2
25390: PPUSH
25391: CALL_OW 88
// if tmp > 1 then
25395: LD_VAR 0 3
25399: PUSH
25400: LD_INT 1
25402: GREATER
25403: IFFALSE 25421
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
25405: LD_VAR 0 3
25409: PUSH
25410: LD_INT 2
25412: ARRAY
25413: PPUSH
25414: LD_STRING D5-Sol2-2
25416: PPUSH
25417: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
25421: LD_EXP 61
25425: PPUSH
25426: LD_STRING D5-Pow-3
25428: PPUSH
25429: CALL_OW 88
// wait ( 0 0$1 ) ;
25433: LD_INT 35
25435: PPUSH
25436: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
25440: LD_ADDR_VAR 0 3
25444: PUSH
25445: LD_EXP 18
25449: PUSH
25450: LD_INT 1
25452: ARRAY
25453: PUSH
25454: LD_EXP 18
25458: PUSH
25459: LD_INT 2
25461: ARRAY
25462: UNION
25463: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
25464: LD_VAR 0 3
25468: PPUSH
25469: LD_INT 80
25471: PPUSH
25472: LD_INT 67
25474: PPUSH
25475: CALL_OW 114
// wait ( 0 0$2 ) ;
25479: LD_INT 70
25481: PPUSH
25482: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
25486: LD_INT 79
25488: PPUSH
25489: LD_INT 72
25491: PPUSH
25492: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
25496: LD_INT 70
25498: PPUSH
25499: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
25503: LD_VAR 0 3
25507: PPUSH
25508: LD_INT 3
25510: PUSH
25511: LD_INT 24
25513: PUSH
25514: LD_INT 1000
25516: PUSH
25517: EMPTY
25518: LIST
25519: LIST
25520: PUSH
25521: EMPTY
25522: LIST
25523: LIST
25524: PPUSH
25525: CALL_OW 72
25529: IFFALSE 25496
// Say ( Powell , D5a-Pow-1 ) ;
25531: LD_EXP 61
25535: PPUSH
25536: LD_STRING D5a-Pow-1
25538: PPUSH
25539: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
25543: LD_EXP 61
25547: PPUSH
25548: LD_STRING D5a-Pow-1a
25550: PPUSH
25551: CALL_OW 88
// wait ( 0 0$0.7 ) ;
25555: LD_INT 24
25557: PPUSH
25558: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
25562: LD_EXP 61
25566: PPUSH
25567: LD_STRING D5a-Pow-1b
25569: PPUSH
25570: CALL_OW 88
// wait ( 0 0$0.3 ) ;
25574: LD_INT 10
25576: PPUSH
25577: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
25581: LD_EXP 61
25585: PPUSH
25586: LD_STRING D5a-Pow-1c
25588: PPUSH
25589: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
25593: LD_VAR 0 3
25597: PPUSH
25598: LD_INT 68
25600: PPUSH
25601: LD_INT 63
25603: PPUSH
25604: CALL_OW 111
// wait ( 0 0$0.5 ) ;
25608: LD_INT 18
25610: PPUSH
25611: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
25615: LD_EXP 61
25619: PPUSH
25620: LD_STRING D5a-Pow-1d
25622: PPUSH
25623: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
25627: LD_INT 35
25629: PPUSH
25630: CALL_OW 67
// if not HasTask ( tmp ) then
25634: LD_VAR 0 3
25638: PPUSH
25639: CALL_OW 314
25643: NOT
25644: IFFALSE 25661
// ComAgressiveMove ( tmp , 68 , 63 ) ;
25646: LD_VAR 0 3
25650: PPUSH
25651: LD_INT 68
25653: PPUSH
25654: LD_INT 63
25656: PPUSH
25657: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
25661: LD_VAR 0 3
25665: PPUSH
25666: LD_INT 24
25668: PUSH
25669: LD_INT 1
25671: PUSH
25672: EMPTY
25673: LIST
25674: LIST
25675: PPUSH
25676: CALL_OW 72
25680: NOT
25681: IFFALSE 25627
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
25683: LD_ADDR_VAR 0 3
25687: PUSH
25688: LD_INT 22
25690: PUSH
25691: LD_INT 4
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: PUSH
25698: LD_INT 92
25700: PUSH
25701: LD_INT 60
25703: PUSH
25704: LD_INT 93
25706: PUSH
25707: LD_INT 10
25709: PUSH
25710: EMPTY
25711: LIST
25712: LIST
25713: LIST
25714: LIST
25715: PUSH
25716: LD_INT 3
25718: PUSH
25719: LD_INT 54
25721: PUSH
25722: EMPTY
25723: LIST
25724: PUSH
25725: EMPTY
25726: LIST
25727: LIST
25728: PUSH
25729: EMPTY
25730: LIST
25731: LIST
25732: LIST
25733: PPUSH
25734: CALL_OW 69
25738: PUSH
25739: LD_EXP 61
25743: DIFF
25744: ST_TO_ADDR
// if tmp then
25745: LD_VAR 0 3
25749: IFFALSE 25783
// for i in tmp do
25751: LD_ADDR_VAR 0 1
25755: PUSH
25756: LD_VAR 0 3
25760: PUSH
25761: FOR_IN
25762: IFFALSE 25781
// ComMoveXY ( i , 36 , 67 ) ;
25764: LD_VAR 0 1
25768: PPUSH
25769: LD_INT 36
25771: PPUSH
25772: LD_INT 67
25774: PPUSH
25775: CALL_OW 111
25779: GO 25761
25781: POP
25782: POP
// wait ( 0 0$3 ) ;
25783: LD_INT 105
25785: PPUSH
25786: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
25790: LD_VAR 0 12
25794: PPUSH
25795: LD_STRING D6-Sol3-1
25797: PPUSH
25798: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
25802: LD_EXP 61
25806: PPUSH
25807: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
25811: LD_EXP 61
25815: PPUSH
25816: LD_STRING D6-Pow-1
25818: PPUSH
25819: CALL_OW 88
// tmp := [ ] ;
25823: LD_ADDR_VAR 0 3
25827: PUSH
25828: EMPTY
25829: ST_TO_ADDR
// for i = 1 to 2 do
25830: LD_ADDR_VAR 0 1
25834: PUSH
25835: DOUBLE
25836: LD_INT 1
25838: DEC
25839: ST_TO_ADDR
25840: LD_INT 2
25842: PUSH
25843: FOR_TO
25844: IFFALSE 25958
// begin uc_side := 8 ;
25846: LD_ADDR_OWVAR 20
25850: PUSH
25851: LD_INT 8
25853: ST_TO_ADDR
// uc_nation := 2 ;
25854: LD_ADDR_OWVAR 21
25858: PUSH
25859: LD_INT 2
25861: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
25862: LD_INT 14
25864: PPUSH
25865: LD_INT 3
25867: PPUSH
25868: LD_INT 2
25870: PPUSH
25871: LD_INT 29
25873: PPUSH
25874: LD_INT 100
25876: PPUSH
25877: CALL 75220 0 5
// veh := CreateVehicle ;
25881: LD_ADDR_VAR 0 14
25885: PUSH
25886: CALL_OW 45
25890: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
25891: LD_VAR 0 14
25895: PPUSH
25896: LD_INT 4
25898: PPUSH
25899: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
25903: LD_VAR 0 14
25907: PPUSH
25908: LD_INT 99
25910: PPUSH
25911: LD_INT 83
25913: PPUSH
25914: LD_INT 3
25916: PPUSH
25917: LD_INT 0
25919: PPUSH
25920: CALL_OW 50
// wait ( 3 ) ;
25924: LD_INT 3
25926: PPUSH
25927: CALL_OW 67
// Connect ( veh ) ;
25931: LD_VAR 0 14
25935: PPUSH
25936: CALL 78688 0 1
// tmp := tmp ^ veh ;
25940: LD_ADDR_VAR 0 3
25944: PUSH
25945: LD_VAR 0 3
25949: PUSH
25950: LD_VAR 0 14
25954: ADD
25955: ST_TO_ADDR
// end ;
25956: GO 25843
25958: POP
25959: POP
// wait ( 0 0$1 ) ;
25960: LD_INT 35
25962: PPUSH
25963: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
25967: LD_INT 99
25969: PPUSH
25970: LD_INT 83
25972: PPUSH
25973: LD_INT 1
25975: PPUSH
25976: LD_INT 10
25978: PPUSH
25979: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
25983: LD_INT 99
25985: PPUSH
25986: LD_INT 83
25988: PPUSH
25989: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
25993: LD_VAR 0 12
25997: PPUSH
25998: LD_STRING D6-Sol3-2
26000: PPUSH
26001: CALL_OW 88
// async ;
26005: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
26006: LD_EXP 61
26010: PPUSH
26011: LD_STRING D6-Pow-2
26013: PPUSH
26014: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
26018: LD_VAR 0 3
26022: PUSH
26023: LD_INT 1
26025: ARRAY
26026: PPUSH
26027: LD_VAR 0 10
26031: PPUSH
26032: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
26036: LD_VAR 0 3
26040: PUSH
26041: LD_INT 2
26043: ARRAY
26044: PPUSH
26045: LD_INT 22
26047: PUSH
26048: LD_INT 4
26050: PUSH
26051: EMPTY
26052: LIST
26053: LIST
26054: PUSH
26055: LD_INT 21
26057: PUSH
26058: LD_INT 3
26060: PUSH
26061: EMPTY
26062: LIST
26063: LIST
26064: PUSH
26065: EMPTY
26066: LIST
26067: LIST
26068: PPUSH
26069: CALL_OW 69
26073: PPUSH
26074: LD_VAR 0 3
26078: PUSH
26079: LD_INT 2
26081: ARRAY
26082: PPUSH
26083: CALL_OW 74
26087: PPUSH
26088: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
26092: LD_EXP 61
26096: PPUSH
26097: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
26101: LD_INT 99
26103: PPUSH
26104: LD_INT 83
26106: PPUSH
26107: LD_INT 1
26109: PPUSH
26110: CALL_OW 331
// repeat wait ( 4 ) ;
26114: LD_INT 4
26116: PPUSH
26117: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
26121: LD_VAR 0 3
26125: PUSH
26126: LD_INT 1
26128: ARRAY
26129: PPUSH
26130: CALL_OW 256
26134: PUSH
26135: LD_INT 1000
26137: LESS
26138: IFFALSE 26156
// SetLives ( tmp [ 1 ] , 1000 ) ;
26140: LD_VAR 0 3
26144: PUSH
26145: LD_INT 1
26147: ARRAY
26148: PPUSH
26149: LD_INT 1000
26151: PPUSH
26152: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
26156: LD_INT 22
26158: PUSH
26159: LD_INT 4
26161: PUSH
26162: EMPTY
26163: LIST
26164: LIST
26165: PUSH
26166: LD_INT 30
26168: PUSH
26169: LD_INT 3
26171: PUSH
26172: EMPTY
26173: LIST
26174: LIST
26175: PUSH
26176: EMPTY
26177: LIST
26178: LIST
26179: PPUSH
26180: CALL_OW 69
26184: PUSH
26185: LD_INT 0
26187: EQUAL
26188: IFFALSE 26114
// skirmish := false ;
26190: LD_ADDR_EXP 100
26194: PUSH
26195: LD_INT 0
26197: ST_TO_ADDR
// sync ;
26198: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
26199: LD_EXP 61
26203: PPUSH
26204: LD_STRING D6a-Pow-1
26206: PPUSH
26207: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
26211: LD_VAR 0 12
26215: PPUSH
26216: LD_STRING D6a-Sol3-1
26218: PPUSH
26219: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
26223: LD_EXP 61
26227: PPUSH
26228: LD_STRING D6a-Pow-2
26230: PPUSH
26231: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
26235: LD_VAR 0 12
26239: PPUSH
26240: LD_STRING D6a-Sol3-2
26242: PPUSH
26243: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
26247: LD_EXP 61
26251: PPUSH
26252: LD_STRING D6a-Pow-3
26254: PPUSH
26255: CALL_OW 88
// powellCenterCameraMode := true ;
26259: LD_ADDR_EXP 20
26263: PUSH
26264: LD_INT 1
26266: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
26267: LD_ADDR_VAR 0 1
26271: PUSH
26272: LD_INT 22
26274: PUSH
26275: LD_INT 8
26277: PUSH
26278: EMPTY
26279: LIST
26280: LIST
26281: PUSH
26282: LD_INT 25
26284: PUSH
26285: LD_INT 2
26287: PUSH
26288: EMPTY
26289: LIST
26290: LIST
26291: PUSH
26292: EMPTY
26293: LIST
26294: LIST
26295: PPUSH
26296: CALL_OW 69
26300: PUSH
26301: FOR_IN
26302: IFFALSE 26357
// begin SetTag ( i , 1 ) ;
26304: LD_VAR 0 1
26308: PPUSH
26309: LD_INT 1
26311: PPUSH
26312: CALL_OW 109
// ComExitBuilding ( i ) ;
26316: LD_VAR 0 1
26320: PPUSH
26321: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
26325: LD_VAR 0 1
26329: PPUSH
26330: LD_INT 35
26332: PPUSH
26333: LD_INT 6
26335: PPUSH
26336: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
26340: LD_VAR 0 1
26344: PPUSH
26345: LD_INT 53
26347: PPUSH
26348: LD_INT 4
26350: PPUSH
26351: CALL_OW 171
// end ;
26355: GO 26301
26357: POP
26358: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
26359: LD_ADDR_VAR 0 3
26363: PUSH
26364: LD_INT 22
26366: PUSH
26367: LD_INT 4
26369: PUSH
26370: EMPTY
26371: LIST
26372: LIST
26373: PUSH
26374: LD_INT 21
26376: PUSH
26377: LD_INT 2
26379: PUSH
26380: EMPTY
26381: LIST
26382: LIST
26383: PUSH
26384: LD_INT 3
26386: PUSH
26387: LD_INT 34
26389: PUSH
26390: LD_INT 12
26392: PUSH
26393: EMPTY
26394: LIST
26395: LIST
26396: PUSH
26397: EMPTY
26398: LIST
26399: LIST
26400: PUSH
26401: EMPTY
26402: LIST
26403: LIST
26404: LIST
26405: PPUSH
26406: CALL_OW 69
26410: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
26411: LD_EXP 61
26415: PPUSH
26416: LD_VAR 0 3
26420: PPUSH
26421: LD_EXP 61
26425: PPUSH
26426: CALL_OW 74
26430: PPUSH
26431: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
26435: LD_EXP 61
26439: PPUSH
26440: LD_INT 100
26442: PPUSH
26443: LD_INT 88
26445: PPUSH
26446: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
26450: LD_EXP 61
26454: PPUSH
26455: LD_INT 100
26457: PPUSH
26458: LD_INT 75
26460: PPUSH
26461: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
26465: LD_EXP 61
26469: PPUSH
26470: LD_INT 88
26472: PPUSH
26473: LD_INT 53
26475: PPUSH
26476: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
26480: LD_INT 8
26482: PPUSH
26483: LD_EXP 61
26487: PPUSH
26488: CALL_OW 471
// repeat wait ( 3 ) ;
26492: LD_INT 3
26494: PPUSH
26495: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
26499: LD_INT 22
26501: PUSH
26502: LD_INT 4
26504: PUSH
26505: EMPTY
26506: LIST
26507: LIST
26508: PUSH
26509: LD_INT 92
26511: PUSH
26512: LD_INT 100
26514: PUSH
26515: LD_INT 75
26517: PUSH
26518: LD_INT 6
26520: PUSH
26521: EMPTY
26522: LIST
26523: LIST
26524: LIST
26525: LIST
26526: PUSH
26527: EMPTY
26528: LIST
26529: LIST
26530: PPUSH
26531: CALL_OW 69
26535: IFFALSE 26492
// async ;
26537: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
26538: LD_EXP 61
26542: PPUSH
26543: LD_STRING D6b-Pow-1
26545: PPUSH
26546: CALL_OW 88
// repeat wait ( 3 ) ;
26550: LD_INT 3
26552: PPUSH
26553: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
26557: LD_EXP 61
26561: PPUSH
26562: CALL_OW 310
26566: PPUSH
26567: CALL_OW 256
26571: PUSH
26572: LD_INT 1000
26574: LESS
26575: IFFALSE 26594
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
26577: LD_EXP 61
26581: PPUSH
26582: CALL_OW 310
26586: PPUSH
26587: LD_INT 1000
26589: PPUSH
26590: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
26594: LD_EXP 61
26598: PPUSH
26599: CALL_OW 256
26603: PUSH
26604: LD_INT 1000
26606: LESS
26607: IFFALSE 26621
// SetLives ( Powell , 1000 ) ;
26609: LD_EXP 61
26613: PPUSH
26614: LD_INT 1000
26616: PPUSH
26617: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
26621: LD_EXP 61
26625: PPUSH
26626: LD_EXP 67
26630: PPUSH
26631: CALL_OW 296
26635: PUSH
26636: LD_INT 5
26638: LESS
26639: PUSH
26640: LD_EXP 61
26644: PPUSH
26645: CALL_OW 310
26649: PPUSH
26650: LD_EXP 67
26654: PPUSH
26655: CALL_OW 296
26659: PUSH
26660: LD_INT 5
26662: LESS
26663: OR
26664: IFFALSE 26683
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
26666: LD_EXP 61
26670: PPUSH
26671: CALL_OW 310
26675: PPUSH
26676: LD_INT 100
26678: PPUSH
26679: CALL_OW 234
// until not IsInUnit ( Powell ) ;
26683: LD_EXP 61
26687: PPUSH
26688: CALL_OW 310
26692: NOT
26693: IFFALSE 26550
// DoNotAttack ( 8 , powellBomb ) ;
26695: LD_INT 8
26697: PPUSH
26698: LD_EXP 67
26702: PPUSH
26703: CALL_OW 471
// game_speed := 4 ;
26707: LD_ADDR_OWVAR 65
26711: PUSH
26712: LD_INT 4
26714: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
26715: LD_EXP 61
26719: PPUSH
26720: LD_STRING D6b-Pow-1a
26722: PPUSH
26723: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
26727: LD_EXP 61
26731: PPUSH
26732: LD_EXP 67
26736: PPUSH
26737: CALL_OW 180
// sync ;
26741: SYNC
// repeat wait ( 0 0$1 ) ;
26742: LD_INT 35
26744: PPUSH
26745: CALL_OW 67
// until IsInUnit ( Powell ) ;
26749: LD_EXP 61
26753: PPUSH
26754: CALL_OW 310
26758: IFFALSE 26742
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
26760: LD_INT 8
26762: PPUSH
26763: LD_EXP 61
26767: PPUSH
26768: CALL_OW 310
26772: PPUSH
26773: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
26777: LD_EXP 61
26781: PPUSH
26782: LD_INT 91
26784: PPUSH
26785: LD_INT 44
26787: PPUSH
26788: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26792: LD_EXP 61
26796: PPUSH
26797: LD_INT 96
26799: PPUSH
26800: LD_INT 44
26802: PPUSH
26803: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26807: LD_EXP 61
26811: PPUSH
26812: LD_INT 96
26814: PPUSH
26815: LD_INT 41
26817: PPUSH
26818: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
26822: LD_EXP 61
26826: PPUSH
26827: LD_INT 92
26829: PPUSH
26830: LD_INT 39
26832: PPUSH
26833: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
26837: LD_EXP 61
26841: PPUSH
26842: LD_INT 88
26844: PPUSH
26845: LD_INT 41
26847: PPUSH
26848: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
26852: LD_EXP 61
26856: PPUSH
26857: LD_INT 91
26859: PPUSH
26860: LD_INT 44
26862: PPUSH
26863: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26867: LD_EXP 61
26871: PPUSH
26872: LD_INT 96
26874: PPUSH
26875: LD_INT 44
26877: PPUSH
26878: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26882: LD_EXP 61
26886: PPUSH
26887: LD_INT 96
26889: PPUSH
26890: LD_INT 41
26892: PPUSH
26893: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
26897: LD_EXP 61
26901: PPUSH
26902: LD_INT 92
26904: PPUSH
26905: LD_INT 39
26907: PPUSH
26908: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
26912: LD_EXP 61
26916: PPUSH
26917: LD_INT 88
26919: PPUSH
26920: LD_INT 41
26922: PPUSH
26923: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
26927: LD_EXP 61
26931: PPUSH
26932: LD_INT 91
26934: PPUSH
26935: LD_INT 44
26937: PPUSH
26938: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
26942: LD_EXP 61
26946: PPUSH
26947: LD_INT 93
26949: PPUSH
26950: LD_INT 39
26952: PPUSH
26953: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
26957: LD_EXP 61
26961: PPUSH
26962: LD_INT 93
26964: PPUSH
26965: LD_INT 36
26967: PPUSH
26968: CALL_OW 171
// wait ( 0 0$3.5 ) ;
26972: LD_INT 122
26974: PPUSH
26975: CALL_OW 67
// game_speed := 4 ;
26979: LD_ADDR_OWVAR 65
26983: PUSH
26984: LD_INT 4
26986: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
26987: LD_EXP 61
26991: PPUSH
26992: LD_STRING D6b-Pow-1b
26994: PPUSH
26995: CALL_OW 88
// tmp := [ ] ;
26999: LD_ADDR_VAR 0 3
27003: PUSH
27004: EMPTY
27005: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
27006: LD_ADDR_VAR 0 5
27010: PUSH
27011: LD_INT 78
27013: PUSH
27014: LD_INT 47
27016: PUSH
27017: EMPTY
27018: LIST
27019: LIST
27020: PUSH
27021: LD_INT 106
27023: PUSH
27024: LD_INT 53
27026: PUSH
27027: EMPTY
27028: LIST
27029: LIST
27030: PUSH
27031: EMPTY
27032: LIST
27033: LIST
27034: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
27035: LD_ADDR_VAR 0 1
27039: PUSH
27040: LD_INT 22
27042: PUSH
27043: LD_INT 8
27045: PUSH
27046: EMPTY
27047: LIST
27048: LIST
27049: PUSH
27050: LD_INT 21
27052: PUSH
27053: LD_INT 3
27055: PUSH
27056: EMPTY
27057: LIST
27058: LIST
27059: PUSH
27060: LD_INT 92
27062: PUSH
27063: LD_INT 90
27065: PUSH
27066: LD_INT 52
27068: PUSH
27069: LD_INT 12
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: LIST
27076: LIST
27077: PUSH
27078: EMPTY
27079: LIST
27080: LIST
27081: LIST
27082: PPUSH
27083: CALL_OW 69
27087: PUSH
27088: FOR_IN
27089: IFFALSE 27114
// tmp := tmp ^ UnitsInside ( i ) ;
27091: LD_ADDR_VAR 0 3
27095: PUSH
27096: LD_VAR 0 3
27100: PUSH
27101: LD_VAR 0 1
27105: PPUSH
27106: CALL_OW 313
27110: ADD
27111: ST_TO_ADDR
27112: GO 27088
27114: POP
27115: POP
// for i in tmp do
27116: LD_ADDR_VAR 0 1
27120: PUSH
27121: LD_VAR 0 3
27125: PUSH
27126: FOR_IN
27127: IFFALSE 27289
// begin dist := 9999 ;
27129: LD_ADDR_VAR 0 9
27133: PUSH
27134: LD_INT 9999
27136: ST_TO_ADDR
// _xy := [ ] ;
27137: LD_ADDR_VAR 0 8
27141: PUSH
27142: EMPTY
27143: ST_TO_ADDR
// SetTag ( i , 1 ) ;
27144: LD_VAR 0 1
27148: PPUSH
27149: LD_INT 1
27151: PPUSH
27152: CALL_OW 109
// ComExitBuilding ( i ) ;
27156: LD_VAR 0 1
27160: PPUSH
27161: CALL_OW 122
// for j in xy do
27165: LD_ADDR_VAR 0 2
27169: PUSH
27170: LD_VAR 0 5
27174: PUSH
27175: FOR_IN
27176: IFFALSE 27258
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
27178: LD_VAR 0 1
27182: PPUSH
27183: LD_VAR 0 2
27187: PUSH
27188: LD_INT 1
27190: ARRAY
27191: PPUSH
27192: LD_VAR 0 2
27196: PUSH
27197: LD_INT 2
27199: ARRAY
27200: PPUSH
27201: CALL_OW 297
27205: PUSH
27206: LD_VAR 0 9
27210: LESS
27211: IFFALSE 27256
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
27213: LD_ADDR_VAR 0 9
27217: PUSH
27218: LD_VAR 0 1
27222: PPUSH
27223: LD_VAR 0 2
27227: PUSH
27228: LD_INT 1
27230: ARRAY
27231: PPUSH
27232: LD_VAR 0 2
27236: PUSH
27237: LD_INT 2
27239: ARRAY
27240: PPUSH
27241: CALL_OW 297
27245: ST_TO_ADDR
// _xy := j ;
27246: LD_ADDR_VAR 0 8
27250: PUSH
27251: LD_VAR 0 2
27255: ST_TO_ADDR
// end ;
27256: GO 27175
27258: POP
27259: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
27260: LD_VAR 0 1
27264: PPUSH
27265: LD_VAR 0 8
27269: PUSH
27270: LD_INT 1
27272: ARRAY
27273: PPUSH
27274: LD_VAR 0 8
27278: PUSH
27279: LD_INT 2
27281: ARRAY
27282: PPUSH
27283: CALL_OW 171
// end ;
27287: GO 27126
27289: POP
27290: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
27291: LD_ADDR_VAR 0 4
27295: PUSH
27296: LD_VAR 0 3
27300: PPUSH
27301: LD_INT 26
27303: PUSH
27304: LD_INT 1
27306: PUSH
27307: EMPTY
27308: LIST
27309: LIST
27310: PUSH
27311: LD_INT 25
27313: PUSH
27314: LD_INT 1
27316: PUSH
27317: EMPTY
27318: LIST
27319: LIST
27320: PUSH
27321: EMPTY
27322: LIST
27323: LIST
27324: PPUSH
27325: CALL_OW 72
27329: ST_TO_ADDR
// if tmp2 < 2 then
27330: LD_VAR 0 4
27334: PUSH
27335: LD_INT 2
27337: LESS
27338: IFFALSE 27407
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
27340: LD_ADDR_VAR 0 4
27344: PUSH
27345: LD_INT 22
27347: PUSH
27348: LD_INT 8
27350: PUSH
27351: EMPTY
27352: LIST
27353: LIST
27354: PUSH
27355: LD_INT 26
27357: PUSH
27358: LD_INT 1
27360: PUSH
27361: EMPTY
27362: LIST
27363: LIST
27364: PUSH
27365: LD_INT 3
27367: PUSH
27368: LD_INT 25
27370: PUSH
27371: LD_INT 15
27373: PUSH
27374: EMPTY
27375: LIST
27376: LIST
27377: PUSH
27378: EMPTY
27379: LIST
27380: LIST
27381: PUSH
27382: EMPTY
27383: LIST
27384: LIST
27385: LIST
27386: PPUSH
27387: CALL_OW 69
27391: PUSH
27392: LD_EXP 64
27396: PUSH
27397: LD_EXP 65
27401: PUSH
27402: EMPTY
27403: LIST
27404: LIST
27405: DIFF
27406: ST_TO_ADDR
// if tmp2 then
27407: LD_VAR 0 4
27411: IFFALSE 27429
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
27413: LD_VAR 0 4
27417: PUSH
27418: LD_INT 1
27420: ARRAY
27421: PPUSH
27422: LD_STRING D6b-ArSol1-1
27424: PPUSH
27425: CALL_OW 88
// async ;
27429: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
27430: LD_EXP 61
27434: PPUSH
27435: LD_STRING D6b-Pow-2
27437: PPUSH
27438: CALL_OW 88
// wait ( 0 0$0.5 ) ;
27442: LD_INT 18
27444: PPUSH
27445: CALL_OW 67
// if tmp2 > 1 then
27449: LD_VAR 0 4
27453: PUSH
27454: LD_INT 1
27456: GREATER
27457: IFFALSE 27475
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
27459: LD_VAR 0 4
27463: PUSH
27464: LD_INT 2
27466: ARRAY
27467: PPUSH
27468: LD_STRING D6b-ArSol2-1
27470: PPUSH
27471: CALL_OW 88
// sync ;
27475: SYNC
// repeat wait ( 5 ) ;
27476: LD_INT 5
27478: PPUSH
27479: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
27483: LD_INT 93
27485: PPUSH
27486: LD_INT 36
27488: PPUSH
27489: CALL_OW 428
27493: PPUSH
27494: CALL_OW 255
27498: PUSH
27499: LD_INT 4
27501: EQUAL
27502: IFFALSE 27476
// DialogueOn ;
27504: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
27508: LD_INT 10
27510: PPUSH
27511: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
27515: LD_EXP 61
27519: PPUSH
27520: LD_STRING D6b-Pow-2a
27522: PPUSH
27523: CALL_OW 88
// DialogueOff ;
27527: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
27531: LD_EXP 61
27535: PPUSH
27536: CALL_OW 310
27540: PPUSH
27541: LD_INT 332
27543: PPUSH
27544: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
27548: LD_INT 93
27550: PPUSH
27551: LD_INT 35
27553: PPUSH
27554: LD_INT 1
27556: PPUSH
27557: LD_INT 6
27559: NEG
27560: PPUSH
27561: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
27565: LD_INT 35
27567: PPUSH
27568: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
27572: LD_INT 332
27574: PPUSH
27575: CALL_OW 256
27579: PUSH
27580: LD_INT 1000
27582: LESS
27583: PUSH
27584: LD_INT 332
27586: PPUSH
27587: CALL_OW 300
27591: AND
27592: IFFALSE 27604
// SetLives ( kozlov_fac , 0 ) ;
27594: LD_INT 332
27596: PPUSH
27597: LD_INT 0
27599: PPUSH
27600: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
27604: LD_INT 332
27606: PPUSH
27607: CALL_OW 301
27611: PUSH
27612: LD_EXP 61
27616: PPUSH
27617: CALL_OW 301
27621: OR
27622: IFFALSE 27565
// game_speed := 4 ;
27624: LD_ADDR_OWVAR 65
27628: PUSH
27629: LD_INT 4
27631: ST_TO_ADDR
// powellCenterCameraMode := false ;
27632: LD_ADDR_EXP 20
27636: PUSH
27637: LD_INT 0
27639: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
27640: LD_ADDR_VAR 0 1
27644: PUSH
27645: LD_VAR 0 3
27649: PUSH
27650: LD_INT 22
27652: PUSH
27653: LD_INT 8
27655: PUSH
27656: EMPTY
27657: LIST
27658: LIST
27659: PUSH
27660: LD_INT 25
27662: PUSH
27663: LD_INT 2
27665: PUSH
27666: EMPTY
27667: LIST
27668: LIST
27669: PUSH
27670: EMPTY
27671: LIST
27672: LIST
27673: PPUSH
27674: CALL_OW 69
27678: UNION
27679: PUSH
27680: FOR_IN
27681: IFFALSE 27697
// SetTag ( i , 0 ) ;
27683: LD_VAR 0 1
27687: PPUSH
27688: LD_INT 0
27690: PPUSH
27691: CALL_OW 109
27695: GO 27680
27697: POP
27698: POP
// wait ( 0 0$3 ) ;
27699: LD_INT 105
27701: PPUSH
27702: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
27706: LD_INT 93
27708: PPUSH
27709: LD_INT 35
27711: PPUSH
27712: LD_INT 1
27714: PPUSH
27715: CALL_OW 331
// DialogueOn ;
27719: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
27723: LD_VAR 0 12
27727: PPUSH
27728: LD_STRING D6c-Sol3-1
27730: PPUSH
27731: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
27735: LD_INT 10
27737: PPUSH
27738: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
27742: LD_EXP 40
27746: PPUSH
27747: LD_STRING D6c-JMM-1
27749: PPUSH
27750: CALL_OW 88
// if Cyrus then
27754: LD_EXP 46
27758: IFFALSE 27772
// Say ( Cyrus , D6c-Cyrus-1 ) ;
27760: LD_EXP 46
27764: PPUSH
27765: LD_STRING D6c-Cyrus-1
27767: PPUSH
27768: CALL_OW 88
// if Bobby then
27772: LD_EXP 45
27776: IFFALSE 27790
// Say ( Bobby , D6c-Bobby-1 ) ;
27778: LD_EXP 45
27782: PPUSH
27783: LD_STRING D6c-Bobby-1
27785: PPUSH
27786: CALL_OW 88
// if Cornel then
27790: LD_EXP 51
27794: IFFALSE 27808
// Say ( Cornel , D6c-Corn-1 ) ;
27796: LD_EXP 51
27800: PPUSH
27801: LD_STRING D6c-Corn-1
27803: PPUSH
27804: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
27808: LD_ADDR_VAR 0 4
27812: PUSH
27813: LD_INT 2
27815: PUSH
27816: LD_INT 22
27818: PUSH
27819: LD_INT 1
27821: PUSH
27822: EMPTY
27823: LIST
27824: LIST
27825: PUSH
27826: LD_INT 22
27828: PUSH
27829: LD_INT 4
27831: PUSH
27832: EMPTY
27833: LIST
27834: LIST
27835: PUSH
27836: EMPTY
27837: LIST
27838: LIST
27839: LIST
27840: PUSH
27841: LD_INT 26
27843: PUSH
27844: LD_INT 1
27846: PUSH
27847: EMPTY
27848: LIST
27849: LIST
27850: PUSH
27851: LD_INT 23
27853: PUSH
27854: LD_INT 1
27856: PUSH
27857: EMPTY
27858: LIST
27859: LIST
27860: PUSH
27861: EMPTY
27862: LIST
27863: LIST
27864: LIST
27865: PPUSH
27866: CALL_OW 69
27870: PUSH
27871: LD_VAR 0 12
27875: PUSH
27876: LD_EXP 40
27880: UNION
27881: PUSH
27882: LD_EXP 62
27886: UNION
27887: DIFF
27888: ST_TO_ADDR
// if tmp2 then
27889: LD_VAR 0 4
27893: IFFALSE 27911
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
27895: LD_VAR 0 4
27899: PUSH
27900: LD_INT 1
27902: ARRAY
27903: PPUSH
27904: LD_STRING D6c-Sol1-1
27906: PPUSH
27907: CALL_OW 88
// if Lisa then
27911: LD_EXP 43
27915: IFFALSE 27929
// Say ( Lisa , D6c-Lisa-1 ) ;
27917: LD_EXP 43
27921: PPUSH
27922: LD_STRING D6c-Lisa-1
27924: PPUSH
27925: CALL_OW 88
// if Gary then
27929: LD_EXP 52
27933: IFFALSE 27947
// Say ( Gary , D6c-Gary-1 ) ;
27935: LD_EXP 52
27939: PPUSH
27940: LD_STRING D6c-Gary-1
27942: PPUSH
27943: CALL_OW 88
// if Donaldson then
27947: LD_EXP 44
27951: IFFALSE 27965
// Say ( Donaldson , D6c-Don-1 ) ;
27953: LD_EXP 44
27957: PPUSH
27958: LD_STRING D6c-Don-1
27960: PPUSH
27961: CALL_OW 88
// if tmp2 > 1 then
27965: LD_VAR 0 4
27969: PUSH
27970: LD_INT 1
27972: GREATER
27973: IFFALSE 27991
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
27975: LD_VAR 0 4
27979: PUSH
27980: LD_INT 2
27982: ARRAY
27983: PPUSH
27984: LD_STRING D6c-Sol2-1
27986: PPUSH
27987: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
27991: LD_VAR 0 12
27995: PPUSH
27996: LD_STRING D6c-Sol3-2
27998: PPUSH
27999: CALL_OW 88
// if IsInUnit ( JMM ) then
28003: LD_EXP 40
28007: PPUSH
28008: CALL_OW 310
28012: IFFALSE 28030
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
28014: LD_EXP 40
28018: PPUSH
28019: CALL_OW 310
28023: PPUSH
28024: CALL_OW 87
28028: GO 28039
// CenterNowOnUnits ( JMM ) ;
28030: LD_EXP 40
28034: PPUSH
28035: CALL_OW 87
// dwait ( 0 0$2 ) ;
28039: LD_INT 70
28041: PPUSH
28042: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
28046: LD_EXP 40
28050: PPUSH
28051: LD_STRING D6c-JMM-2
28053: PPUSH
28054: CALL_OW 88
// DialogueOff ;
28058: CALL_OW 7
// Video ( false ) ;
28062: LD_INT 0
28064: PPUSH
28065: CALL 108063 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
28069: LD_INT 22
28071: PUSH
28072: LD_INT 4
28074: PUSH
28075: EMPTY
28076: LIST
28077: LIST
28078: PPUSH
28079: CALL_OW 69
28083: PPUSH
28084: LD_INT 1
28086: PPUSH
28087: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
28091: LD_INT 4
28093: PPUSH
28094: LD_INT 4
28096: PPUSH
28097: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
28101: LD_ADDR_VAR 0 1
28105: PUSH
28106: LD_INT 4
28108: PPUSH
28109: LD_INT 1
28111: PPUSH
28112: LD_INT 2
28114: PPUSH
28115: CALL 70443 0 3
28119: PUSH
28120: FOR_IN
28121: IFFALSE 28158
// if GetTech ( i , 1 ) <> state_researched then
28123: LD_VAR 0 1
28127: PPUSH
28128: LD_INT 1
28130: PPUSH
28131: CALL_OW 321
28135: PUSH
28136: LD_INT 2
28138: NONEQUAL
28139: IFFALSE 28156
// SetTech ( i , 1 , state_researched ) ;
28141: LD_VAR 0 1
28145: PPUSH
28146: LD_INT 1
28148: PPUSH
28149: LD_INT 2
28151: PPUSH
28152: CALL_OW 322
28156: GO 28120
28158: POP
28159: POP
// missionStage := 6 ;
28160: LD_ADDR_EXP 15
28164: PUSH
28165: LD_INT 6
28167: ST_TO_ADDR
// activeAttacks := true ;
28168: LD_ADDR_EXP 16
28172: PUSH
28173: LD_INT 1
28175: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
28176: LD_STRING M2
28178: PPUSH
28179: CALL_OW 337
// SaveForQuickRestart ;
28183: CALL_OW 22
// wait ( 0 0$40 ) ;
28187: LD_INT 1400
28189: PPUSH
28190: CALL_OW 67
// DialogueOn ;
28194: CALL_OW 6
// SayRadioNoFaceNoName ( Friend , D7-Friend-1 ) ;
28198: LD_EXP 66
28202: PPUSH
28203: LD_STRING D7-Friend-1
28205: PPUSH
28206: CALL 112166 0 2
// Say ( JMM , D7-JMM-1 ) ;
28210: LD_EXP 40
28214: PPUSH
28215: LD_STRING D7-JMM-1
28217: PPUSH
28218: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-2 ) ;
28222: LD_EXP 66
28226: PPUSH
28227: LD_STRING D7-Friend-2
28229: PPUSH
28230: CALL 112166 0 2
// Say ( JMM , D7-JMM-2 ) ;
28234: LD_EXP 40
28238: PPUSH
28239: LD_STRING D7-JMM-2
28241: PPUSH
28242: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-3 ) ;
28246: LD_EXP 66
28250: PPUSH
28251: LD_STRING D7-Friend-3
28253: PPUSH
28254: CALL 112166 0 2
// Say ( JMM , D7-JMM-3 ) ;
28258: LD_EXP 40
28262: PPUSH
28263: LD_STRING D7-JMM-3
28265: PPUSH
28266: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-4 ) ;
28270: LD_EXP 66
28274: PPUSH
28275: LD_STRING D7-Friend-4
28277: PPUSH
28278: CALL 112166 0 2
// Say ( JMM , D7-JMM-4 ) ;
28282: LD_EXP 40
28286: PPUSH
28287: LD_STRING D7-JMM-4
28289: PPUSH
28290: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-5 ) ;
28294: LD_EXP 66
28298: PPUSH
28299: LD_STRING D7-Friend-5
28301: PPUSH
28302: CALL 112166 0 2
// Say ( JMM , D7-JMM-5 ) ;
28306: LD_EXP 40
28310: PPUSH
28311: LD_STRING D7-JMM-5
28313: PPUSH
28314: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-6 ) ;
28318: LD_EXP 66
28322: PPUSH
28323: LD_STRING D7-Friend-6
28325: PPUSH
28326: CALL 112166 0 2
// Say ( JMM , D7-JMM-6 ) ;
28330: LD_EXP 40
28334: PPUSH
28335: LD_STRING D7-JMM-6
28337: PPUSH
28338: CALL_OW 88
// DialogueOff ;
28342: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
28346: LD_STRING Mlegion
28348: PPUSH
28349: CALL_OW 337
// skirmish := true ;
28353: LD_ADDR_EXP 100
28357: PUSH
28358: LD_INT 1
28360: ST_TO_ADDR
// RebuildKozlovFactory ;
28361: CALL 5380 0 0
// end ;
28365: PPOPN 14
28367: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
28368: LD_EXP 20
28372: PUSH
28373: LD_EXP 61
28377: PPUSH
28378: CALL_OW 300
28382: AND
28383: IFFALSE 28425
28385: GO 28387
28387: DISABLE
// begin enable ;
28388: ENABLE
// if IsInUnit ( Powell ) then
28389: LD_EXP 61
28393: PPUSH
28394: CALL_OW 310
28398: IFFALSE 28416
// CenterOnUnits ( IsInUnit ( Powell ) ) else
28400: LD_EXP 61
28404: PPUSH
28405: CALL_OW 310
28409: PPUSH
28410: CALL_OW 85
28414: GO 28425
// CenterOnUnits ( Powell ) ;
28416: LD_EXP 61
28420: PPUSH
28421: CALL_OW 85
// end ;
28425: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
28426: LD_INT 22
28428: PUSH
28429: LD_INT 8
28431: PUSH
28432: EMPTY
28433: LIST
28434: LIST
28435: PUSH
28436: LD_INT 34
28438: PUSH
28439: LD_INT 48
28441: PUSH
28442: EMPTY
28443: LIST
28444: LIST
28445: PUSH
28446: EMPTY
28447: LIST
28448: LIST
28449: PPUSH
28450: CALL_OW 69
28454: IFFALSE 28728
28456: GO 28458
28458: DISABLE
28459: LD_INT 0
28461: PPUSH
28462: PPUSH
// begin if missionStage < 9 then
28463: LD_EXP 15
28467: PUSH
28468: LD_INT 9
28470: LESS
28471: IFFALSE 28481
// missionStage := 9 ;
28473: LD_ADDR_EXP 15
28477: PUSH
28478: LD_INT 9
28480: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28481: LD_ADDR_VAR 0 1
28485: PUSH
28486: LD_INT 22
28488: PUSH
28489: LD_INT 8
28491: PUSH
28492: EMPTY
28493: LIST
28494: LIST
28495: PUSH
28496: LD_INT 34
28498: PUSH
28499: LD_INT 48
28501: PUSH
28502: EMPTY
28503: LIST
28504: LIST
28505: PUSH
28506: EMPTY
28507: LIST
28508: LIST
28509: PPUSH
28510: CALL_OW 69
28514: PUSH
28515: LD_INT 1
28517: ARRAY
28518: ST_TO_ADDR
// wait ( 0 0$05 ) ;
28519: LD_INT 175
28521: PPUSH
28522: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
28526: LD_EXP 12
28530: PUSH
28531: LD_EXP 3
28535: PUSH
28536: LD_INT 0
28538: PUSH
28539: LD_INT 2
28541: PUSH
28542: EMPTY
28543: LIST
28544: LIST
28545: IN
28546: OR
28547: IFFALSE 28570
// target := [ 68 , 108 , 1 ] else
28549: LD_ADDR_VAR 0 2
28553: PUSH
28554: LD_INT 68
28556: PUSH
28557: LD_INT 108
28559: PUSH
28560: LD_INT 1
28562: PUSH
28563: EMPTY
28564: LIST
28565: LIST
28566: LIST
28567: ST_TO_ADDR
28568: GO 28589
// target := [ 181 , 88 , 2 ] ;
28570: LD_ADDR_VAR 0 2
28574: PUSH
28575: LD_INT 181
28577: PUSH
28578: LD_INT 88
28580: PUSH
28581: LD_INT 2
28583: PUSH
28584: EMPTY
28585: LIST
28586: LIST
28587: LIST
28588: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
28589: LD_VAR 0 1
28593: PPUSH
28594: LD_VAR 0 2
28598: PUSH
28599: LD_INT 1
28601: ARRAY
28602: PPUSH
28603: LD_VAR 0 2
28607: PUSH
28608: LD_INT 2
28610: ARRAY
28611: PPUSH
28612: CALL_OW 176
// if target [ 3 ] = 1 then
28616: LD_VAR 0 2
28620: PUSH
28621: LD_INT 3
28623: ARRAY
28624: PUSH
28625: LD_INT 1
28627: EQUAL
28628: IFFALSE 28644
// SayRadio ( Kurt , D12-Kurt-1 ) else
28630: LD_EXP 64
28634: PPUSH
28635: LD_STRING D12-Kurt-1
28637: PPUSH
28638: CALL_OW 94
28642: GO 28668
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
28644: LD_EXP 64
28648: PPUSH
28649: LD_STRING D12a-Kurt-1
28651: PPUSH
28652: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
28656: LD_EXP 79
28660: PPUSH
28661: LD_STRING D12a-Roth-1
28663: PPUSH
28664: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
28668: LD_INT 350
28670: PPUSH
28671: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
28675: LD_VAR 0 1
28679: PPUSH
28680: LD_INT 22
28682: PUSH
28683: LD_INT 8
28685: PUSH
28686: EMPTY
28687: LIST
28688: LIST
28689: PUSH
28690: LD_INT 23
28692: PUSH
28693: LD_INT 2
28695: PUSH
28696: EMPTY
28697: LIST
28698: LIST
28699: PUSH
28700: LD_INT 30
28702: PUSH
28703: LD_INT 3
28705: PUSH
28706: EMPTY
28707: LIST
28708: LIST
28709: PUSH
28710: EMPTY
28711: LIST
28712: LIST
28713: LIST
28714: PPUSH
28715: CALL_OW 69
28719: PUSH
28720: LD_INT 1
28722: ARRAY
28723: PPUSH
28724: CALL_OW 228
// end ;
28728: PPOPN 2
28730: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
28731: LD_EXP 64
28735: PPUSH
28736: CALL_OW 256
28740: PUSH
28741: LD_INT 999
28743: LESS
28744: PUSH
28745: LD_INT 22
28747: PUSH
28748: LD_INT 8
28750: PUSH
28751: EMPTY
28752: LIST
28753: LIST
28754: PUSH
28755: LD_INT 21
28757: PUSH
28758: LD_INT 1
28760: PUSH
28761: EMPTY
28762: LIST
28763: LIST
28764: PUSH
28765: LD_INT 23
28767: PUSH
28768: LD_INT 2
28770: PUSH
28771: EMPTY
28772: LIST
28773: LIST
28774: PUSH
28775: EMPTY
28776: LIST
28777: LIST
28778: LIST
28779: PPUSH
28780: CALL_OW 69
28784: PUSH
28785: LD_INT 9
28787: PUSH
28788: LD_INT 8
28790: PUSH
28791: LD_INT 7
28793: PUSH
28794: LD_INT 6
28796: PUSH
28797: EMPTY
28798: LIST
28799: LIST
28800: LIST
28801: LIST
28802: PUSH
28803: LD_OWVAR 67
28807: ARRAY
28808: LESSEQUAL
28809: OR
28810: PUSH
28811: LD_INT 22
28813: PUSH
28814: LD_INT 8
28816: PUSH
28817: EMPTY
28818: LIST
28819: LIST
28820: PUSH
28821: LD_INT 34
28823: PUSH
28824: LD_INT 48
28826: PUSH
28827: EMPTY
28828: LIST
28829: LIST
28830: PUSH
28831: EMPTY
28832: LIST
28833: LIST
28834: PPUSH
28835: CALL_OW 69
28839: NOT
28840: AND
28841: PUSH
28842: LD_EXP 64
28846: PPUSH
28847: CALL_OW 302
28851: AND
28852: PUSH
28853: LD_INT 5
28855: PPUSH
28856: LD_INT 22
28858: PUSH
28859: LD_INT 1
28861: PUSH
28862: EMPTY
28863: LIST
28864: LIST
28865: PPUSH
28866: CALL_OW 70
28870: AND
28871: IFFALSE 29633
28873: GO 28875
28875: DISABLE
28876: LD_INT 0
28878: PPUSH
28879: PPUSH
28880: PPUSH
// begin legionDestroyed := true ;
28881: LD_ADDR_EXP 22
28885: PUSH
28886: LD_INT 1
28888: ST_TO_ADDR
// DialogueOn ;
28889: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
28893: LD_EXP 40
28897: PPUSH
28898: LD_STRING D13-JMM-1
28900: PPUSH
28901: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
28905: LD_EXP 64
28909: PPUSH
28910: LD_STRING D13-Kurt-1
28912: PPUSH
28913: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
28917: LD_EXP 40
28921: PPUSH
28922: LD_STRING D13-JMM-2
28924: PPUSH
28925: CALL_OW 88
// if FakeInfo then
28929: LD_EXP 12
28933: IFFALSE 28953
// begin Say ( Kurt , D13-Kurt-2 ) ;
28935: LD_EXP 64
28939: PPUSH
28940: LD_STRING D13-Kurt-2
28942: PPUSH
28943: CALL_OW 88
// DialogueOff ;
28947: CALL_OW 7
// exit ;
28951: GO 29633
// end ; if not KurtStatus then
28953: LD_EXP 3
28957: NOT
28958: IFFALSE 28974
// Say ( Kurt , D13-Kurt-2b ) else
28960: LD_EXP 64
28964: PPUSH
28965: LD_STRING D13-Kurt-2b
28967: PPUSH
28968: CALL_OW 88
28972: GO 28986
// Say ( Kurt , D13-Kurt-2a ) ;
28974: LD_EXP 64
28978: PPUSH
28979: LD_STRING D13-Kurt-2a
28981: PPUSH
28982: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
28986: LD_EXP 40
28990: PPUSH
28991: LD_STRING D13-JMM-3
28993: PPUSH
28994: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
28998: LD_EXP 64
29002: PPUSH
29003: LD_STRING D13-Kurt-3
29005: PPUSH
29006: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
29010: LD_EXP 40
29014: PPUSH
29015: LD_STRING D13-JMM-4
29017: PPUSH
29018: CALL_OW 88
// DialogueOff ;
29022: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
29026: LD_STRING MlegionOut
29028: PPUSH
29029: CALL_OW 337
// MC_Kill ( 3 ) ;
29033: LD_INT 3
29035: PPUSH
29036: CALL 39845 0 1
// KillUnit ( Kozlov ) ;
29040: LD_EXP 65
29044: PPUSH
29045: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
29049: LD_ADDR_VAR 0 1
29053: PUSH
29054: LD_INT 22
29056: PUSH
29057: LD_INT 8
29059: PUSH
29060: EMPTY
29061: LIST
29062: LIST
29063: PUSH
29064: LD_INT 23
29066: PUSH
29067: LD_INT 3
29069: PUSH
29070: EMPTY
29071: LIST
29072: LIST
29073: PUSH
29074: LD_INT 3
29076: PUSH
29077: LD_INT 21
29079: PUSH
29080: LD_INT 33
29082: PUSH
29083: EMPTY
29084: LIST
29085: LIST
29086: PUSH
29087: EMPTY
29088: LIST
29089: LIST
29090: PUSH
29091: EMPTY
29092: LIST
29093: LIST
29094: LIST
29095: PPUSH
29096: CALL_OW 69
29100: PUSH
29101: FOR_IN
29102: IFFALSE 29115
// KillUnit ( i ) ;
29104: LD_VAR 0 1
29108: PPUSH
29109: CALL_OW 66
29113: GO 29101
29115: POP
29116: POP
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
29117: LD_ADDR_VAR 0 1
29121: PUSH
29122: LD_INT 22
29124: PUSH
29125: LD_INT 8
29127: PUSH
29128: EMPTY
29129: LIST
29130: LIST
29131: PUSH
29132: LD_INT 21
29134: PUSH
29135: LD_INT 2
29137: PUSH
29138: EMPTY
29139: LIST
29140: LIST
29141: PUSH
29142: EMPTY
29143: LIST
29144: LIST
29145: PPUSH
29146: CALL_OW 69
29150: PUSH
29151: FOR_IN
29152: IFFALSE 29165
// KillUnit ( i ) ;
29154: LD_VAR 0 1
29158: PPUSH
29159: CALL_OW 66
29163: GO 29151
29165: POP
29166: POP
// wait ( 0 0$0.6 ) ;
29167: LD_INT 21
29169: PPUSH
29170: CALL_OW 67
// ChangeSideFog ( 8 , 1 ) ;
29174: LD_INT 8
29176: PPUSH
29177: LD_INT 1
29179: PPUSH
29180: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
29184: LD_ADDR_VAR 0 2
29188: PUSH
29189: LD_INT 22
29191: PUSH
29192: LD_INT 8
29194: PUSH
29195: EMPTY
29196: LIST
29197: LIST
29198: PUSH
29199: LD_INT 21
29201: PUSH
29202: LD_INT 1
29204: PUSH
29205: EMPTY
29206: LIST
29207: LIST
29208: PUSH
29209: EMPTY
29210: LIST
29211: LIST
29212: PPUSH
29213: CALL_OW 69
29217: PUSH
29218: LD_EXP 65
29222: PUSH
29223: LD_EXP 64
29227: PUSH
29228: EMPTY
29229: LIST
29230: LIST
29231: DIFF
29232: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
29233: LD_VAR 0 2
29237: PUSH
29238: LD_INT 6
29240: PUSH
29241: LD_INT 5
29243: PUSH
29244: LD_INT 4
29246: PUSH
29247: LD_INT 3
29249: PUSH
29250: EMPTY
29251: LIST
29252: LIST
29253: LIST
29254: LIST
29255: PUSH
29256: LD_OWVAR 67
29260: ARRAY
29261: GREATEREQUAL
29262: IFFALSE 29414
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
29264: LD_ADDR_VAR 0 3
29268: PUSH
29269: LD_INT 6
29271: PUSH
29272: LD_INT 5
29274: PUSH
29275: LD_INT 4
29277: PUSH
29278: LD_INT 3
29280: PUSH
29281: EMPTY
29282: LIST
29283: LIST
29284: LIST
29285: LIST
29286: PUSH
29287: LD_OWVAR 67
29291: ARRAY
29292: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
29293: LD_ADDR_VAR 0 1
29297: PUSH
29298: DOUBLE
29299: LD_VAR 0 2
29303: PUSH
29304: LD_VAR 0 3
29308: PUSH
29309: LD_INT 1
29311: PLUS
29312: MINUS
29313: INC
29314: ST_TO_ADDR
29315: LD_INT 1
29317: PUSH
29318: FOR_DOWNTO
29319: IFFALSE 29410
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
29321: LD_ADDR_EXP 38
29325: PUSH
29326: LD_EXP 38
29330: PUSH
29331: LD_VAR 0 2
29335: PUSH
29336: LD_VAR 0 1
29340: ARRAY
29341: ADD
29342: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
29343: LD_VAR 0 2
29347: PUSH
29348: LD_VAR 0 1
29352: ARRAY
29353: PPUSH
29354: CALL_OW 310
29358: IFFALSE 29375
// ComExit ( tmp [ i ] ) ;
29360: LD_VAR 0 2
29364: PUSH
29365: LD_VAR 0 1
29369: ARRAY
29370: PPUSH
29371: CALL 108489 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
29375: LD_VAR 0 2
29379: PUSH
29380: LD_VAR 0 1
29384: ARRAY
29385: PPUSH
29386: LD_INT 34
29388: PUSH
29389: LD_INT 0
29391: PPUSH
29392: LD_INT 6
29394: PPUSH
29395: CALL_OW 12
29399: PLUS
29400: PPUSH
29401: LD_INT 1
29403: PPUSH
29404: CALL_OW 171
// end ;
29408: GO 29318
29410: POP
29411: POP
// end else
29412: GO 29424
// x := tmp ;
29414: LD_ADDR_VAR 0 3
29418: PUSH
29419: LD_VAR 0 2
29423: ST_TO_ADDR
// for i := tmp downto tmp - x do
29424: LD_ADDR_VAR 0 1
29428: PUSH
29429: DOUBLE
29430: LD_VAR 0 2
29434: INC
29435: ST_TO_ADDR
29436: LD_VAR 0 2
29440: PUSH
29441: LD_VAR 0 3
29445: MINUS
29446: PUSH
29447: FOR_DOWNTO
29448: IFFALSE 29520
// begin if IsInUnit ( tmp [ i ] ) then
29450: LD_VAR 0 2
29454: PUSH
29455: LD_VAR 0 1
29459: ARRAY
29460: PPUSH
29461: CALL_OW 310
29465: IFFALSE 29482
// ComExit ( tmp [ i ] ) ;
29467: LD_VAR 0 2
29471: PUSH
29472: LD_VAR 0 1
29476: ARRAY
29477: PPUSH
29478: CALL 108489 0 1
// SetSide ( tmp [ i ] , 1 ) ;
29482: LD_VAR 0 2
29486: PUSH
29487: LD_VAR 0 1
29491: ARRAY
29492: PPUSH
29493: LD_INT 1
29495: PPUSH
29496: CALL_OW 235
// SetLives ( tmp [ i ] , 1000 ) ;
29500: LD_VAR 0 2
29504: PUSH
29505: LD_VAR 0 1
29509: ARRAY
29510: PPUSH
29511: LD_INT 1000
29513: PPUSH
29514: CALL_OW 234
// end ;
29518: GO 29447
29520: POP
29521: POP
// SetSide ( Kurt , 1 ) ;
29522: LD_EXP 64
29526: PPUSH
29527: LD_INT 1
29529: PPUSH
29530: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
29534: LD_INT 22
29536: PUSH
29537: LD_INT 8
29539: PUSH
29540: EMPTY
29541: LIST
29542: LIST
29543: PUSH
29544: LD_INT 21
29546: PUSH
29547: LD_INT 3
29549: PUSH
29550: EMPTY
29551: LIST
29552: LIST
29553: PUSH
29554: EMPTY
29555: LIST
29556: LIST
29557: PPUSH
29558: CALL_OW 69
29562: PPUSH
29563: LD_INT 1
29565: PPUSH
29566: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
29570: LD_INT 8
29572: PPUSH
29573: LD_INT 1
29575: PPUSH
29576: LD_INT 1
29578: PPUSH
29579: LD_INT 1
29581: PPUSH
29582: CALL_OW 80
// wait ( 1 1$20 ) ;
29586: LD_INT 2800
29588: PPUSH
29589: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
29593: LD_EXP 66
29597: PPUSH
29598: LD_INT 37
29600: PPUSH
29601: LD_INT 1
29603: PPUSH
29604: LD_INT 0
29606: PPUSH
29607: CALL_OW 48
// wait ( 0 0$1 ) ;
29611: LD_INT 35
29613: PPUSH
29614: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
29618: LD_EXP 66
29622: PPUSH
29623: LD_INT 60
29625: PPUSH
29626: LD_INT 95
29628: PPUSH
29629: CALL_OW 111
// end ;
29633: PPOPN 3
29635: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
29636: LD_EXP 22
29640: NOT
29641: PUSH
29642: LD_INT 22
29644: PUSH
29645: LD_INT 8
29647: PUSH
29648: EMPTY
29649: LIST
29650: LIST
29651: PUSH
29652: LD_INT 21
29654: PUSH
29655: LD_INT 1
29657: PUSH
29658: EMPTY
29659: LIST
29660: LIST
29661: PUSH
29662: EMPTY
29663: LIST
29664: LIST
29665: PPUSH
29666: CALL_OW 69
29670: PUSH
29671: LD_INT 0
29673: EQUAL
29674: AND
29675: IFFALSE 29695
29677: GO 29679
29679: DISABLE
// begin legionDestroyed := true ;
29680: LD_ADDR_EXP 22
29684: PUSH
29685: LD_INT 1
29687: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
29688: LD_STRING MlegionOut
29690: PPUSH
29691: CALL_OW 337
// end ;
29695: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
29696: LD_EXP 38
29700: IFFALSE 29775
29702: GO 29704
29704: DISABLE
29705: LD_INT 0
29707: PPUSH
// begin enable ;
29708: ENABLE
// for i in legionEscapeUnits do
29709: LD_ADDR_VAR 0 1
29713: PUSH
29714: LD_EXP 38
29718: PUSH
29719: FOR_IN
29720: IFFALSE 29773
// begin if IsInArea ( i , legionEscapeArea ) then
29722: LD_VAR 0 1
29726: PPUSH
29727: LD_INT 31
29729: PPUSH
29730: CALL_OW 308
29734: IFFALSE 29747
// RemoveUnit ( i ) else
29736: LD_VAR 0 1
29740: PPUSH
29741: CALL_OW 64
29745: GO 29771
// if not HasTask ( i ) then
29747: LD_VAR 0 1
29751: PPUSH
29752: CALL_OW 314
29756: NOT
29757: IFFALSE 29771
// ComMoveToArea ( i , legionEscapeArea ) ;
29759: LD_VAR 0 1
29763: PPUSH
29764: LD_INT 31
29766: PPUSH
29767: CALL_OW 113
// end ;
29771: GO 29719
29773: POP
29774: POP
// end ;
29775: PPOPN 1
29777: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
29778: LD_INT 1
29780: PPUSH
29781: LD_EXP 66
29785: PPUSH
29786: CALL_OW 292
29790: IFFALSE 30088
29792: GO 29794
29794: DISABLE
29795: LD_INT 0
29797: PPUSH
// begin wait ( 0 0$2 ) ;
29798: LD_INT 70
29800: PPUSH
29801: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
29805: LD_EXP 66
29809: PPUSH
29810: CALL_OW 87
// DialogueOn ;
29814: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
29818: LD_EXP 40
29822: PPUSH
29823: LD_STRING D14-JMM-1
29825: PPUSH
29826: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
29830: LD_EXP 66
29834: PPUSH
29835: LD_STRING D14-Friend-1
29837: PPUSH
29838: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
29842: LD_EXP 40
29846: PPUSH
29847: LD_STRING D14-JMM-2
29849: PPUSH
29850: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
29854: LD_EXP 66
29858: PPUSH
29859: LD_STRING D14-Friend-2
29861: PPUSH
29862: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
29866: LD_EXP 40
29870: PPUSH
29871: LD_STRING D14-JMM-3
29873: PPUSH
29874: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
29878: LD_EXP 66
29882: PPUSH
29883: LD_STRING D14-Friend-3
29885: PPUSH
29886: CALL_OW 88
// DialogueOff ;
29890: CALL_OW 7
// dec := Query ( Q14 ) ;
29894: LD_ADDR_VAR 0 1
29898: PUSH
29899: LD_STRING Q14
29901: PPUSH
29902: CALL_OW 97
29906: ST_TO_ADDR
// if dec = 1 then
29907: LD_VAR 0 1
29911: PUSH
29912: LD_INT 1
29914: EQUAL
29915: IFFALSE 29949
// begin DialogueOn ;
29917: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
29921: LD_EXP 40
29925: PPUSH
29926: LD_STRING D14a-JMM-1
29928: PPUSH
29929: CALL_OW 88
// DialogueOff ;
29933: CALL_OW 7
// SetSide ( Friend , 1 ) ;
29937: LD_EXP 66
29941: PPUSH
29942: LD_INT 1
29944: PPUSH
29945: CALL_OW 235
// end ; if dec = 2 then
29949: LD_VAR 0 1
29953: PUSH
29954: LD_INT 2
29956: EQUAL
29957: IFFALSE 30010
// begin DialogueOn ;
29959: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
29963: LD_EXP 40
29967: PPUSH
29968: LD_STRING D14b-JMM-1
29970: PPUSH
29971: CALL_OW 88
// DialogueOff ;
29975: CALL_OW 7
// wait ( 0 0$1 ) ;
29979: LD_INT 35
29981: PPUSH
29982: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
29986: LD_EXP 66
29990: PPUSH
29991: LD_INT 9
29993: PPUSH
29994: LD_INT 2
29996: PPUSH
29997: CALL_OW 111
// AddComHold ( Friend ) ;
30001: LD_EXP 66
30005: PPUSH
30006: CALL_OW 200
// end ; if dec = 3 then
30010: LD_VAR 0 1
30014: PUSH
30015: LD_INT 3
30017: EQUAL
30018: IFFALSE 30088
// begin DialogueOn ;
30020: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
30024: LD_EXP 40
30028: PPUSH
30029: LD_STRING D14c-JMM-1
30031: PPUSH
30032: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
30036: LD_EXP 66
30040: PPUSH
30041: LD_STRING D14c-Friend-1
30043: PPUSH
30044: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
30048: LD_EXP 40
30052: PPUSH
30053: LD_STRING D14c-JMM-2
30055: PPUSH
30056: CALL_OW 88
// DialogueOff ;
30060: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
30064: LD_EXP 66
30068: PPUSH
30069: LD_INT 9
30071: PPUSH
30072: LD_INT 2
30074: PPUSH
30075: CALL_OW 111
// AddComHold ( Friend ) ;
30079: LD_EXP 66
30083: PPUSH
30084: CALL_OW 200
// end ; end ;
30088: PPOPN 1
30090: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
30091: LD_INT 9
30093: PPUSH
30094: LD_INT 2
30096: PPUSH
30097: CALL_OW 428
30101: PUSH
30102: LD_EXP 66
30106: EQUAL
30107: PUSH
30108: LD_EXP 66
30112: PPUSH
30113: CALL_OW 255
30117: PUSH
30118: LD_INT 8
30120: EQUAL
30121: AND
30122: IFFALSE 30136
30124: GO 30126
30126: DISABLE
// RemoveUnit ( Friend ) ;
30127: LD_EXP 66
30131: PPUSH
30132: CALL_OW 64
30136: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
30137: LD_EXP 14
30141: PUSH
30142: LD_INT 31500
30144: GREATEREQUAL
30145: PUSH
30146: LD_EXP 7
30150: AND
30151: PUSH
30152: LD_EXP 2
30156: AND
30157: IFFALSE 30603
30159: GO 30161
30161: DISABLE
30162: LD_INT 0
30164: PPUSH
30165: PPUSH
30166: PPUSH
// begin missionStage := 7 ;
30167: LD_ADDR_EXP 15
30171: PUSH
30172: LD_INT 7
30174: ST_TO_ADDR
// for i := 1 to 5 do
30175: LD_ADDR_VAR 0 1
30179: PUSH
30180: DOUBLE
30181: LD_INT 1
30183: DEC
30184: ST_TO_ADDR
30185: LD_INT 5
30187: PUSH
30188: FOR_TO
30189: IFFALSE 30301
// begin uc_side = 1 ;
30191: LD_ADDR_OWVAR 20
30195: PUSH
30196: LD_INT 1
30198: ST_TO_ADDR
// uc_nation = 1 ;
30199: LD_ADDR_OWVAR 21
30203: PUSH
30204: LD_INT 1
30206: ST_TO_ADDR
// vc_engine = engine_siberite ;
30207: LD_ADDR_OWVAR 39
30211: PUSH
30212: LD_INT 3
30214: ST_TO_ADDR
// vc_control = control_computer ;
30215: LD_ADDR_OWVAR 38
30219: PUSH
30220: LD_INT 3
30222: ST_TO_ADDR
// vc_chassis = us_medium_tracked ;
30223: LD_ADDR_OWVAR 37
30227: PUSH
30228: LD_INT 3
30230: ST_TO_ADDR
// vc_weapon = [ us_double_gun , us_laser , us_rocket_launcher ] [ Rand ( 1 , 3 ) ] ;
30231: LD_ADDR_OWVAR 40
30235: PUSH
30236: LD_INT 5
30238: PUSH
30239: LD_INT 9
30241: PUSH
30242: LD_INT 7
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: LIST
30249: PUSH
30250: LD_INT 1
30252: PPUSH
30253: LD_INT 3
30255: PPUSH
30256: CALL_OW 12
30260: ARRAY
30261: ST_TO_ADDR
// veh = CreateVehicle ;
30262: LD_ADDR_VAR 0 2
30266: PUSH
30267: CALL_OW 45
30271: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
30272: LD_VAR 0 2
30276: PPUSH
30277: LD_INT 1
30279: PPUSH
30280: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
30284: LD_VAR 0 2
30288: PPUSH
30289: LD_INT 19
30291: PPUSH
30292: LD_INT 0
30294: PPUSH
30295: CALL_OW 49
// end ;
30299: GO 30188
30301: POP
30302: POP
// uc_side = 1 ;
30303: LD_ADDR_OWVAR 20
30307: PUSH
30308: LD_INT 1
30310: ST_TO_ADDR
// uc_nation = 1 ;
30311: LD_ADDR_OWVAR 21
30315: PUSH
30316: LD_INT 1
30318: ST_TO_ADDR
// vc_engine = 3 ;
30319: LD_ADDR_OWVAR 39
30323: PUSH
30324: LD_INT 3
30326: ST_TO_ADDR
// vc_control = 1 ;
30327: LD_ADDR_OWVAR 38
30331: PUSH
30332: LD_INT 1
30334: ST_TO_ADDR
// vc_chassis = 3 ;
30335: LD_ADDR_OWVAR 37
30339: PUSH
30340: LD_INT 3
30342: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
30343: LD_ADDR_OWVAR 40
30347: PUSH
30348: LD_INT 5
30350: PUSH
30351: LD_INT 9
30353: PUSH
30354: LD_INT 7
30356: PUSH
30357: EMPTY
30358: LIST
30359: LIST
30360: LIST
30361: PUSH
30362: LD_INT 1
30364: PPUSH
30365: LD_INT 3
30367: PPUSH
30368: CALL_OW 12
30372: ARRAY
30373: ST_TO_ADDR
// vehG = CreateVehicle ;
30374: LD_ADDR_VAR 0 3
30378: PUSH
30379: CALL_OW 45
30383: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
30384: LD_VAR 0 3
30388: PPUSH
30389: LD_INT 1
30391: PPUSH
30392: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
30396: LD_VAR 0 3
30400: PPUSH
30401: LD_INT 19
30403: PPUSH
30404: LD_INT 0
30406: PPUSH
30407: CALL_OW 49
// if JMMGirl = 1 then
30411: LD_EXP 7
30415: PUSH
30416: LD_INT 1
30418: EQUAL
30419: IFFALSE 30475
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
30421: LD_ADDR_EXP 41
30425: PUSH
30426: LD_STRING Joan
30428: PPUSH
30429: LD_INT 1
30431: PPUSH
30432: LD_STRING 14_
30434: PPUSH
30435: CALL 70296 0 3
30439: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
30440: LD_EXP 41
30444: PPUSH
30445: LD_VAR 0 3
30449: PPUSH
30450: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30454: LD_VAR 0 3
30458: PPUSH
30459: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
30463: LD_EXP 41
30467: PPUSH
30468: LD_STRING D10BW-Joan-1
30470: PPUSH
30471: CALL_OW 94
// end ; if JMMGirl = 2 then
30475: LD_EXP 7
30479: PUSH
30480: LD_INT 2
30482: EQUAL
30483: IFFALSE 30539
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
30485: LD_ADDR_EXP 43
30489: PUSH
30490: LD_STRING Lisa
30492: PPUSH
30493: LD_INT 1
30495: PPUSH
30496: LD_STRING 14_
30498: PPUSH
30499: CALL 70296 0 3
30503: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
30504: LD_EXP 43
30508: PPUSH
30509: LD_VAR 0 3
30513: PPUSH
30514: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30518: LD_VAR 0 3
30522: PPUSH
30523: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
30527: LD_EXP 43
30531: PPUSH
30532: LD_STRING D10BW-Lisa-1
30534: PPUSH
30535: CALL_OW 94
// end ; if JMMGirl = 3 then
30539: LD_EXP 7
30543: PUSH
30544: LD_INT 3
30546: EQUAL
30547: IFFALSE 30603
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
30549: LD_ADDR_EXP 55
30553: PUSH
30554: LD_STRING Connie
30556: PPUSH
30557: LD_INT 1
30559: PPUSH
30560: LD_STRING 14_
30562: PPUSH
30563: CALL 70296 0 3
30567: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
30568: LD_EXP 55
30572: PPUSH
30573: LD_VAR 0 3
30577: PPUSH
30578: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30582: LD_VAR 0 3
30586: PPUSH
30587: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
30591: LD_EXP 55
30595: PPUSH
30596: LD_STRING D10BW-Con-1
30598: PPUSH
30599: CALL_OW 94
// end ; end ;
30603: PPOPN 3
30605: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
30606: LD_EXP 14
30610: PUSH
30611: LD_INT 94500
30613: GREATEREQUAL
30614: IFFALSE 31026
30616: GO 30618
30618: DISABLE
30619: LD_INT 0
30621: PPUSH
30622: PPUSH
30623: PPUSH
// begin tmp := PrepareStevensSquad ;
30624: LD_ADDR_VAR 0 3
30628: PUSH
30629: CALL 2378 0 0
30633: ST_TO_ADDR
// if not tmp then
30634: LD_VAR 0 3
30638: NOT
30639: IFFALSE 30643
// exit ;
30641: GO 31026
// uc_side := 1 ;
30643: LD_ADDR_OWVAR 20
30647: PUSH
30648: LD_INT 1
30650: ST_TO_ADDR
// uc_nation := 1 ;
30651: LD_ADDR_OWVAR 21
30655: PUSH
30656: LD_INT 1
30658: ST_TO_ADDR
// for i in tmp do
30659: LD_ADDR_VAR 0 1
30663: PUSH
30664: LD_VAR 0 3
30668: PUSH
30669: FOR_IN
30670: IFFALSE 30767
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
30672: LD_INT 3
30674: PPUSH
30675: LD_INT 3
30677: PPUSH
30678: LD_INT 1
30680: PPUSH
30681: LD_INT 5
30683: PUSH
30684: LD_INT 9
30686: PUSH
30687: LD_INT 7
30689: PUSH
30690: EMPTY
30691: LIST
30692: LIST
30693: LIST
30694: PUSH
30695: LD_INT 1
30697: PPUSH
30698: LD_INT 3
30700: PPUSH
30701: CALL_OW 12
30705: ARRAY
30706: PPUSH
30707: LD_INT 40
30709: PPUSH
30710: CALL 75220 0 5
// veh := CreateVehicle ;
30714: LD_ADDR_VAR 0 2
30718: PUSH
30719: CALL_OW 45
30723: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
30724: LD_VAR 0 2
30728: PPUSH
30729: LD_INT 1
30731: PPUSH
30732: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
30736: LD_VAR 0 2
30740: PPUSH
30741: LD_INT 19
30743: PPUSH
30744: LD_INT 0
30746: PPUSH
30747: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
30751: LD_VAR 0 1
30755: PPUSH
30756: LD_VAR 0 2
30760: PPUSH
30761: CALL_OW 52
// end ;
30765: GO 30669
30767: POP
30768: POP
// missionStage := 8 ;
30769: LD_ADDR_EXP 15
30773: PUSH
30774: LD_INT 8
30776: ST_TO_ADDR
// DialogueOn ;
30777: CALL_OW 6
// if Stevens then
30781: LD_EXP 42
30785: IFFALSE 30899
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
30787: LD_EXP 42
30791: PPUSH
30792: CALL_OW 310
30796: PPUSH
30797: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
30801: LD_EXP 42
30805: PPUSH
30806: LD_STRING D8-Huck-1
30808: PPUSH
30809: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
30813: LD_EXP 40
30817: PPUSH
30818: LD_STRING D8-JMM-1
30820: PPUSH
30821: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
30825: LD_EXP 42
30829: PPUSH
30830: LD_STRING D8-Huck-2
30832: PPUSH
30833: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
30837: LD_EXP 40
30841: PPUSH
30842: LD_STRING D8-JMM-2
30844: PPUSH
30845: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
30849: LD_EXP 42
30853: PPUSH
30854: LD_STRING D8-Huck-3
30856: PPUSH
30857: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
30861: LD_EXP 40
30865: PPUSH
30866: LD_STRING D8-JMM-3
30868: PPUSH
30869: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
30873: LD_EXP 42
30877: PPUSH
30878: LD_STRING D8-Huck-4
30880: PPUSH
30881: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
30885: LD_EXP 40
30889: PPUSH
30890: LD_STRING D8-JMM-4
30892: PPUSH
30893: CALL_OW 88
// end else
30897: GO 31009
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
30899: LD_EXP 56
30903: PPUSH
30904: CALL_OW 310
30908: PPUSH
30909: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
30913: LD_EXP 56
30917: PPUSH
30918: LD_STRING D8-Huck-1
30920: PPUSH
30921: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
30925: LD_EXP 40
30929: PPUSH
30930: LD_STRING D8-JMM-1a
30932: PPUSH
30933: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
30937: LD_EXP 56
30941: PPUSH
30942: LD_STRING D8-Huck-2
30944: PPUSH
30945: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
30949: LD_EXP 40
30953: PPUSH
30954: LD_STRING D8-JMM-2
30956: PPUSH
30957: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
30961: LD_EXP 56
30965: PPUSH
30966: LD_STRING D8-Huck-3
30968: PPUSH
30969: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
30973: LD_EXP 40
30977: PPUSH
30978: LD_STRING D8-JMM-3
30980: PPUSH
30981: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
30985: LD_EXP 56
30989: PPUSH
30990: LD_STRING D8-Huck-4
30992: PPUSH
30993: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
30997: LD_EXP 40
31001: PPUSH
31002: LD_STRING D8-JMM-4
31004: PPUSH
31005: CALL_OW 88
// end ; DialogueOff ;
31009: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
31013: LD_INT 25
31015: PPUSH
31016: LD_INT 1
31018: PPUSH
31019: LD_INT 1
31021: PPUSH
31022: CALL_OW 322
// end ;
31026: PPOPN 3
31028: END
// every 0 0$1 trigger IsOk ( sewiVeh ) and See ( 1 , sewiVeh ) do
31029: LD_EXP 75
31033: PPUSH
31034: CALL_OW 302
31038: PUSH
31039: LD_INT 1
31041: PPUSH
31042: LD_EXP 75
31046: PPUSH
31047: CALL_OW 292
31051: AND
31052: IFFALSE 31290
31054: GO 31056
31056: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
31057: LD_EXP 75
31061: PPUSH
31062: CALL_OW 87
// DialogueOn ;
31066: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
31070: LD_EXP 40
31074: PPUSH
31075: LD_STRING D10nB-JMM-1
31077: PPUSH
31078: CALL_OW 88
// if BurlakStatus = 1 then
31082: LD_EXP 9
31086: PUSH
31087: LD_INT 1
31089: EQUAL
31090: IFFALSE 31106
// SayRadio ( Vsevolod , D10nB-Vse-1a ) else
31092: LD_EXP 74
31096: PPUSH
31097: LD_STRING D10nB-Vse-1a
31099: PPUSH
31100: CALL_OW 94
31104: GO 31118
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
31106: LD_EXP 74
31110: PPUSH
31111: LD_STRING D10nB-Vse-1
31113: PPUSH
31114: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
31118: LD_EXP 40
31122: PPUSH
31123: LD_STRING D10nB-JMM-2
31125: PPUSH
31126: CALL_OW 88
// if KappaStatus then
31130: LD_EXP 2
31134: IFFALSE 31150
// SayRadio ( Vsevolod , D10nB-Vse-5a ) else
31136: LD_EXP 74
31140: PPUSH
31141: LD_STRING D10nB-Vse-5a
31143: PPUSH
31144: CALL_OW 94
31148: GO 31286
// if JMMGirlStatus = 0 then
31150: LD_EXP 6
31154: PUSH
31155: LD_INT 0
31157: EQUAL
31158: IFFALSE 31286
// begin if JMMGirl = 1 then
31160: LD_EXP 7
31164: PUSH
31165: LD_INT 1
31167: EQUAL
31168: IFFALSE 31218
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
31170: LD_EXP 74
31174: PPUSH
31175: LD_STRING D10nB-Vse-2
31177: PPUSH
31178: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
31182: LD_EXP 40
31186: PPUSH
31187: LD_STRING D10nB-JMM-3
31189: PPUSH
31190: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
31194: LD_EXP 74
31198: PPUSH
31199: LD_STRING D10nB-Vse-3
31201: PPUSH
31202: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
31206: LD_EXP 40
31210: PPUSH
31211: LD_STRING D10nB-JMM-4
31213: PPUSH
31214: CALL_OW 88
// end ; if JMMGirl = 2 then
31218: LD_EXP 7
31222: PUSH
31223: LD_INT 2
31225: EQUAL
31226: IFFALSE 31252
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
31228: LD_EXP 74
31232: PPUSH
31233: LD_STRING D10nB-Vse-4
31235: PPUSH
31236: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
31240: LD_EXP 40
31244: PPUSH
31245: LD_STRING D10nB-JMM-5
31247: PPUSH
31248: CALL_OW 88
// end ; if JMMGirl = 3 then
31252: LD_EXP 7
31256: PUSH
31257: LD_INT 3
31259: EQUAL
31260: IFFALSE 31286
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
31262: LD_EXP 74
31266: PPUSH
31267: LD_STRING D10nB-Vse-5
31269: PPUSH
31270: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
31274: LD_EXP 40
31278: PPUSH
31279: LD_STRING D10nB-JMM-6
31281: PPUSH
31282: CALL_OW 88
// end ; end ; DialogueOff ;
31286: CALL_OW 7
// end ;
31290: END
// every 0 0$1 trigger missionTime >= 55 55$00 and IsOk ( Kovalyuk ) and IsOk ( ru_depot2 ) do var i , j , tmp ;
31291: LD_EXP 14
31295: PUSH
31296: LD_INT 115500
31298: GREATEREQUAL
31299: PUSH
31300: LD_EXP 69
31304: PPUSH
31305: CALL_OW 302
31309: AND
31310: PUSH
31311: LD_INT 267
31313: PPUSH
31314: CALL_OW 302
31318: AND
31319: IFFALSE 31833
31321: GO 31323
31323: DISABLE
31324: LD_INT 0
31326: PPUSH
31327: PPUSH
31328: PPUSH
// begin missionStage := 10 ;
31329: LD_ADDR_EXP 15
31333: PUSH
31334: LD_INT 10
31336: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
31337: LD_ADDR_VAR 0 3
31341: PUSH
31342: LD_INT 22
31344: PUSH
31345: LD_INT 1
31347: PUSH
31348: EMPTY
31349: LIST
31350: LIST
31351: PUSH
31352: LD_INT 23
31354: PUSH
31355: LD_INT 1
31357: PUSH
31358: EMPTY
31359: LIST
31360: LIST
31361: PUSH
31362: LD_INT 26
31364: PUSH
31365: LD_INT 1
31367: PUSH
31368: EMPTY
31369: LIST
31370: LIST
31371: PUSH
31372: LD_INT 3
31374: PUSH
31375: LD_INT 25
31377: PUSH
31378: LD_INT 12
31380: PUSH
31381: EMPTY
31382: LIST
31383: LIST
31384: PUSH
31385: EMPTY
31386: LIST
31387: LIST
31388: PUSH
31389: LD_INT 3
31391: PUSH
31392: LD_INT 25
31394: PUSH
31395: LD_INT 16
31397: PUSH
31398: EMPTY
31399: LIST
31400: LIST
31401: PUSH
31402: EMPTY
31403: LIST
31404: LIST
31405: PUSH
31406: EMPTY
31407: LIST
31408: LIST
31409: LIST
31410: LIST
31411: LIST
31412: PPUSH
31413: CALL_OW 69
31417: PUSH
31418: LD_EXP 40
31422: PUSH
31423: LD_EXP 64
31427: PUSH
31428: LD_EXP 42
31432: PUSH
31433: LD_EXP 56
31437: PUSH
31438: LD_EXP 43
31442: PUSH
31443: LD_EXP 44
31447: PUSH
31448: LD_EXP 45
31452: PUSH
31453: LD_EXP 46
31457: PUSH
31458: LD_EXP 47
31462: PUSH
31463: LD_EXP 48
31467: PUSH
31468: LD_EXP 49
31472: PUSH
31473: LD_EXP 50
31477: PUSH
31478: LD_EXP 51
31482: PUSH
31483: LD_EXP 52
31487: PUSH
31488: LD_EXP 53
31492: PUSH
31493: LD_EXP 54
31497: PUSH
31498: EMPTY
31499: LIST
31500: LIST
31501: LIST
31502: LIST
31503: LIST
31504: LIST
31505: LIST
31506: LIST
31507: LIST
31508: LIST
31509: LIST
31510: LIST
31511: LIST
31512: LIST
31513: LIST
31514: LIST
31515: DIFF
31516: ST_TO_ADDR
// if not tmp and Brown then
31517: LD_VAR 0 3
31521: NOT
31522: PUSH
31523: LD_EXP 48
31527: AND
31528: IFFALSE 31543
// tmp := [ Brown ] ;
31530: LD_ADDR_VAR 0 3
31534: PUSH
31535: LD_EXP 48
31539: PUSH
31540: EMPTY
31541: LIST
31542: ST_TO_ADDR
// DialogueOn ;
31543: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
31547: LD_VAR 0 3
31551: PUSH
31552: LD_INT 1
31554: ARRAY
31555: PPUSH
31556: LD_STRING D11-Sol1-1
31558: PPUSH
31559: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
31563: LD_EXP 68
31567: PPUSH
31568: LD_STRING D11-Pla-1
31570: PPUSH
31571: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
31575: LD_EXP 69
31579: PPUSH
31580: LD_STRING D11-Kov-1
31582: PPUSH
31583: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
31587: LD_EXP 68
31591: PPUSH
31592: LD_STRING D11-Pla-2
31594: PPUSH
31595: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
31599: LD_VAR 0 3
31603: PUSH
31604: LD_INT 1
31606: ARRAY
31607: PPUSH
31608: LD_STRING D11-Sol1-2
31610: PPUSH
31611: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
31615: LD_EXP 40
31619: PPUSH
31620: LD_STRING D11-JMM-2
31622: PPUSH
31623: CALL_OW 88
// DialogueOff ;
31627: CALL_OW 7
// allowBehemothConstruct := true ;
31631: LD_ADDR_EXP 25
31635: PUSH
31636: LD_INT 1
31638: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
31639: LD_STRING M4
31641: PPUSH
31642: CALL_OW 337
// j := 3 ;
31646: LD_ADDR_VAR 0 2
31650: PUSH
31651: LD_INT 3
31653: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_not , [ f_tag , 105 ] ] , [ f_class , 3 ] ] ) diff Kovalyuk ;
31654: LD_ADDR_VAR 0 3
31658: PUSH
31659: LD_INT 22
31661: PUSH
31662: LD_INT 3
31664: PUSH
31665: EMPTY
31666: LIST
31667: LIST
31668: PUSH
31669: LD_INT 50
31671: PUSH
31672: EMPTY
31673: LIST
31674: PUSH
31675: LD_INT 3
31677: PUSH
31678: LD_INT 120
31680: PUSH
31681: LD_INT 105
31683: PUSH
31684: EMPTY
31685: LIST
31686: LIST
31687: PUSH
31688: EMPTY
31689: LIST
31690: LIST
31691: PUSH
31692: LD_INT 25
31694: PUSH
31695: LD_INT 3
31697: PUSH
31698: EMPTY
31699: LIST
31700: LIST
31701: PUSH
31702: EMPTY
31703: LIST
31704: LIST
31705: LIST
31706: LIST
31707: PPUSH
31708: CALL_OW 69
31712: PUSH
31713: LD_EXP 69
31717: DIFF
31718: ST_TO_ADDR
// for i in tmp do
31719: LD_ADDR_VAR 0 1
31723: PUSH
31724: LD_VAR 0 3
31728: PUSH
31729: FOR_IN
31730: IFFALSE 31780
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
31732: LD_ADDR_EXP 77
31736: PUSH
31737: LD_EXP 77
31741: PPUSH
31742: LD_VAR 0 1
31746: PPUSH
31747: CALL 108091 0 2
31751: ST_TO_ADDR
// j := j - 1 ;
31752: LD_ADDR_VAR 0 2
31756: PUSH
31757: LD_VAR 0 2
31761: PUSH
31762: LD_INT 1
31764: MINUS
31765: ST_TO_ADDR
// if j = 0 then
31766: LD_VAR 0 2
31770: PUSH
31771: LD_INT 0
31773: EQUAL
31774: IFFALSE 31778
// break ;
31776: GO 31780
// end ;
31778: GO 31729
31780: POP
31781: POP
// BuildBehemoths ;
31782: CALL 8368 0 0
// repeat wait ( 15 15$00 ) ;
31786: LD_INT 31500
31788: PPUSH
31789: CALL_OW 67
// if behemothDestroyedBeforeFinish then
31793: LD_EXP 27
31797: IFFALSE 31801
// break ;
31799: GO 31833
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
31801: LD_INT 267
31803: PPUSH
31804: CALL_OW 274
31808: PPUSH
31809: LD_INT 1
31811: PPUSH
31812: CALL_OW 275
31816: PUSH
31817: LD_INT 1000
31819: GREATEREQUAL
31820: IFFALSE 31826
// BuildBehemoths ;
31822: CALL 8368 0 0
// until not behemothBuilders ;
31826: LD_EXP 77
31830: NOT
31831: IFFALSE 31786
// end ;
31833: PPOPN 3
31835: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
31836: LD_EXP 77
31840: NOT
31841: PUSH
31842: LD_EXP 28
31846: NOT
31847: AND
31848: PUSH
31849: LD_EXP 25
31853: AND
31854: IFFALSE 31874
31856: GO 31858
31858: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
31859: LD_STRING M4a
31861: PPUSH
31862: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
31866: LD_ADDR_EXP 27
31870: PUSH
31871: LD_INT 1
31873: ST_TO_ADDR
// end ;
31874: END
// every 0 0$1 trigger behemothDone do
31875: LD_EXP 28
31879: IFFALSE 31891
31881: GO 31883
31883: DISABLE
// ChangeMissionObjectives ( M4b ) ;
31884: LD_STRING M4b
31886: PPUSH
31887: CALL_OW 337
31891: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
31892: LD_EXP 29
31896: NOT
31897: IFFALSE 32093
31899: GO 31901
31901: DISABLE
31902: LD_INT 0
31904: PPUSH
31905: PPUSH
// begin enable ;
31906: ENABLE
// tmp := GetBehemoths ( 3 ) ;
31907: LD_ADDR_VAR 0 1
31911: PUSH
31912: LD_INT 3
31914: PPUSH
31915: CALL 108152 0 1
31919: ST_TO_ADDR
// if not tmp and not behemothDone then
31920: LD_VAR 0 1
31924: NOT
31925: PUSH
31926: LD_EXP 28
31930: NOT
31931: AND
31932: IFFALSE 31968
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
31934: LD_ADDR_VAR 0 1
31938: PUSH
31939: LD_INT 22
31941: PUSH
31942: LD_INT 3
31944: PUSH
31945: EMPTY
31946: LIST
31947: LIST
31948: PUSH
31949: LD_INT 30
31951: PUSH
31952: LD_INT 37
31954: PUSH
31955: EMPTY
31956: LIST
31957: LIST
31958: PUSH
31959: EMPTY
31960: LIST
31961: LIST
31962: PPUSH
31963: CALL_OW 69
31967: ST_TO_ADDR
// if not tmp then
31968: LD_VAR 0 1
31972: NOT
31973: IFFALSE 31977
// exit ;
31975: GO 32093
// for i in tmp do
31977: LD_ADDR_VAR 0 2
31981: PUSH
31982: LD_VAR 0 1
31986: PUSH
31987: FOR_IN
31988: IFFALSE 32091
// if See ( 1 , i ) then
31990: LD_INT 1
31992: PPUSH
31993: LD_VAR 0 2
31997: PPUSH
31998: CALL_OW 292
32002: IFFALSE 32089
// begin if GetType ( i ) = unit_building then
32004: LD_VAR 0 2
32008: PPUSH
32009: CALL_OW 247
32013: PUSH
32014: LD_INT 3
32016: EQUAL
32017: IFFALSE 32055
// begin disable ;
32019: DISABLE
// CenterNowOnUnits ( i ) ;
32020: LD_VAR 0 2
32024: PPUSH
32025: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
32029: LD_EXP 40
32033: PPUSH
32034: LD_STRING D17a-JMM-1
32036: PPUSH
32037: CALL_OW 88
// seeBehemoth := true ;
32041: LD_ADDR_EXP 29
32045: PUSH
32046: LD_INT 1
32048: ST_TO_ADDR
// exit ;
32049: POP
32050: POP
32051: GO 32093
// end else
32053: GO 32089
// begin disable ;
32055: DISABLE
// CenterNowOnUnits ( i ) ;
32056: LD_VAR 0 2
32060: PPUSH
32061: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
32065: LD_EXP 40
32069: PPUSH
32070: LD_STRING D17b-JMM-1
32072: PPUSH
32073: CALL_OW 88
// seeBehemoth := true ;
32077: LD_ADDR_EXP 29
32081: PUSH
32082: LD_INT 1
32084: ST_TO_ADDR
// exit ;
32085: POP
32086: POP
32087: GO 32093
// end ; end ;
32089: GO 31987
32091: POP
32092: POP
// end ;
32093: PPOPN 2
32095: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
32096: LD_EXP 14
32100: PUSH
32101: LD_INT 123200
32103: GREATEREQUAL
32104: IFFALSE 33311
32106: GO 32108
32108: DISABLE
32109: LD_INT 0
32111: PPUSH
32112: PPUSH
32113: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
32114: LD_INT 2
32116: PPUSH
32117: LD_INT 23
32119: PUSH
32120: LD_INT 3
32122: PUSH
32123: LD_INT 3
32125: PUSH
32126: LD_INT 48
32128: PUSH
32129: EMPTY
32130: LIST
32131: LIST
32132: LIST
32133: LIST
32134: PUSH
32135: EMPTY
32136: LIST
32137: PPUSH
32138: CALL 63870 0 2
// repeat wait ( 0 0$1 ) ;
32142: LD_INT 35
32144: PPUSH
32145: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
32149: LD_INT 22
32151: PUSH
32152: LD_INT 3
32154: PUSH
32155: EMPTY
32156: LIST
32157: LIST
32158: PUSH
32159: LD_INT 34
32161: PUSH
32162: LD_INT 48
32164: PUSH
32165: EMPTY
32166: LIST
32167: LIST
32168: PUSH
32169: EMPTY
32170: LIST
32171: LIST
32172: PPUSH
32173: CALL_OW 69
32177: IFFALSE 32142
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
32179: LD_ADDR_VAR 0 1
32183: PUSH
32184: LD_INT 22
32186: PUSH
32187: LD_INT 3
32189: PUSH
32190: EMPTY
32191: LIST
32192: LIST
32193: PUSH
32194: LD_INT 34
32196: PUSH
32197: LD_INT 48
32199: PUSH
32200: EMPTY
32201: LIST
32202: LIST
32203: PUSH
32204: EMPTY
32205: LIST
32206: LIST
32207: PPUSH
32208: CALL_OW 69
32212: PUSH
32213: LD_INT 1
32215: ARRAY
32216: ST_TO_ADDR
// missionStage := 12 ;
32217: LD_ADDR_EXP 15
32221: PUSH
32222: LD_INT 12
32224: ST_TO_ADDR
// platonovHasBomb := true ;
32225: LD_ADDR_EXP 30
32229: PUSH
32230: LD_INT 1
32232: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
32233: LD_VAR 0 1
32237: PPUSH
32238: LD_INT 181
32240: PPUSH
32241: LD_INT 86
32243: PPUSH
32244: CALL_OW 171
// AddComHold ( bomb ) ;
32248: LD_VAR 0 1
32252: PPUSH
32253: CALL_OW 200
// wait ( 0 0$10 ) ;
32257: LD_INT 350
32259: PPUSH
32260: CALL_OW 67
// DialogueOn ;
32264: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
32268: LD_EXP 68
32272: PPUSH
32273: LD_STRING D15-Pla-1
32275: PPUSH
32276: CALL_OW 94
// dec := Query ( Q15a ) ;
32280: LD_ADDR_VAR 0 2
32284: PUSH
32285: LD_STRING Q15a
32287: PPUSH
32288: CALL_OW 97
32292: ST_TO_ADDR
// if dec = 1 then
32293: LD_VAR 0 2
32297: PUSH
32298: LD_INT 1
32300: EQUAL
32301: IFFALSE 32324
// begin Say ( JMM , D15a-JMM-1 ) ;
32303: LD_EXP 40
32307: PPUSH
32308: LD_STRING D15a-JMM-1
32310: PPUSH
32311: CALL_OW 88
// YouLost ( Surrender ) ;
32315: LD_STRING Surrender
32317: PPUSH
32318: CALL_OW 104
// exit ;
32322: GO 33311
// end ; if dec = 2 then
32324: LD_VAR 0 2
32328: PUSH
32329: LD_INT 2
32331: EQUAL
32332: IFFALSE 32401
// begin Say ( JMM , D15b-JMM-1 ) ;
32334: LD_EXP 40
32338: PPUSH
32339: LD_STRING D15b-JMM-1
32341: PPUSH
32342: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
32346: LD_EXP 68
32350: PPUSH
32351: LD_STRING D15b-Pla-1
32353: PPUSH
32354: CALL_OW 94
// DialogueOff ;
32358: CALL_OW 7
// wait ( 3 3$00 ) ;
32362: LD_INT 6300
32364: PPUSH
32365: CALL_OW 67
// DialogueOn ;
32369: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
32373: LD_EXP 40
32377: PPUSH
32378: LD_STRING D15d-JMM-1a
32380: PPUSH
32381: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
32385: LD_EXP 68
32389: PPUSH
32390: LD_STRING D15d-Pla-1
32392: PPUSH
32393: CALL_OW 94
// DialogueOff ;
32397: CALL_OW 7
// end ; if dec = 3 then
32401: LD_VAR 0 2
32405: PUSH
32406: LD_INT 3
32408: EQUAL
32409: IFFALSE 32463
// begin Say ( JMM , D15c-JMM-1 ) ;
32411: LD_EXP 40
32415: PPUSH
32416: LD_STRING D15c-JMM-1
32418: PPUSH
32419: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
32423: LD_EXP 68
32427: PPUSH
32428: LD_STRING D15c-Pla-1
32430: PPUSH
32431: CALL_OW 94
// DialogueOff ;
32435: CALL_OW 7
// wait ( 0 0$15 ) ;
32439: LD_INT 525
32441: PPUSH
32442: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
32446: LD_VAR 0 1
32450: PPUSH
32451: LD_INT 60
32453: PPUSH
32454: LD_INT 95
32456: PPUSH
32457: CALL_OW 116
// exit ;
32461: GO 33311
// end ; if dec = 4 then
32463: LD_VAR 0 2
32467: PUSH
32468: LD_INT 4
32470: EQUAL
32471: IFFALSE 32501
// begin Say ( JMM , D15d-JMM-1 ) ;
32473: LD_EXP 40
32477: PPUSH
32478: LD_STRING D15d-JMM-1
32480: PPUSH
32481: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
32485: LD_EXP 68
32489: PPUSH
32490: LD_STRING D15d-Pla-1
32492: PPUSH
32493: CALL_OW 94
// DialogueOff ;
32497: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32501: LD_EXP 66
32505: PPUSH
32506: CALL_OW 302
32510: PUSH
32511: LD_EXP 66
32515: PPUSH
32516: CALL_OW 255
32520: PUSH
32521: LD_INT 1
32523: EQUAL
32524: AND
32525: PUSH
32526: LD_INT 22
32528: PUSH
32529: LD_INT 1
32531: PUSH
32532: EMPTY
32533: LIST
32534: LIST
32535: PUSH
32536: LD_INT 34
32538: PUSH
32539: LD_INT 8
32541: PUSH
32542: EMPTY
32543: LIST
32544: LIST
32545: PUSH
32546: EMPTY
32547: LIST
32548: LIST
32549: PPUSH
32550: CALL_OW 69
32554: NOT
32555: AND
32556: IFFALSE 33205
// begin SetSide ( Friend , 8 ) ;
32558: LD_EXP 66
32562: PPUSH
32563: LD_INT 8
32565: PPUSH
32566: CALL_OW 235
// if IsInUnit ( Friend ) then
32570: LD_EXP 66
32574: PPUSH
32575: CALL_OW 310
32579: IFFALSE 32590
// ComExitBuilding ( Friend ) ;
32581: LD_EXP 66
32585: PPUSH
32586: CALL_OW 122
// if IsDriver ( Friend ) then
32590: LD_EXP 66
32594: PPUSH
32595: CALL 105695 0 1
32599: IFFALSE 32610
// ComExitVehicle ( Friend ) ;
32601: LD_EXP 66
32605: PPUSH
32606: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
32610: LD_EXP 66
32614: PPUSH
32615: LD_INT 9
32617: PPUSH
32618: LD_INT 2
32620: PPUSH
32621: CALL_OW 171
// wait ( 0 0$05 ) ;
32625: LD_INT 175
32627: PPUSH
32628: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
32632: LD_EXP 66
32636: PPUSH
32637: CALL_OW 87
// DialogueOn ;
32641: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
32645: LD_EXP 40
32649: PPUSH
32650: LD_STRING D16-JMM-1
32652: PPUSH
32653: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
32657: LD_EXP 66
32661: PPUSH
32662: LD_STRING D16-Friend-1
32664: PPUSH
32665: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
32669: LD_EXP 40
32673: PPUSH
32674: LD_STRING D16-JMM-2
32676: PPUSH
32677: CALL_OW 88
// DialogueOff ;
32681: CALL_OW 7
// SetSide ( Friend , 1 ) ;
32685: LD_EXP 66
32689: PPUSH
32690: LD_INT 1
32692: PPUSH
32693: CALL_OW 235
// ComHold ( Friend ) ;
32697: LD_EXP 66
32701: PPUSH
32702: CALL_OW 140
// wait ( 0 0$20 ) ;
32706: LD_INT 700
32708: PPUSH
32709: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
32713: LD_EXP 66
32717: PPUSH
32718: LD_INT 9
32720: PPUSH
32721: LD_INT 2
32723: PPUSH
32724: CALL_OW 297
32728: PUSH
32729: LD_INT 30
32731: LESS
32732: IFFALSE 32801
// begin SetSide ( Friend , 8 ) ;
32734: LD_EXP 66
32738: PPUSH
32739: LD_INT 8
32741: PPUSH
32742: CALL_OW 235
// if IsInUnit ( Friend ) then
32746: LD_EXP 66
32750: PPUSH
32751: CALL_OW 310
32755: IFFALSE 32766
// ComExitBuilding ( Friend ) ;
32757: LD_EXP 66
32761: PPUSH
32762: CALL_OW 122
// if IsDriver ( Friend ) then
32766: LD_EXP 66
32770: PPUSH
32771: CALL 105695 0 1
32775: IFFALSE 32786
// ComExitVehicle ( Friend ) ;
32777: LD_EXP 66
32781: PPUSH
32782: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
32786: LD_EXP 66
32790: PPUSH
32791: LD_INT 9
32793: PPUSH
32794: LD_INT 2
32796: PPUSH
32797: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
32801: LD_INT 1050
32803: PPUSH
32804: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32808: LD_INT 22
32810: PUSH
32811: LD_INT 1
32813: PUSH
32814: EMPTY
32815: LIST
32816: LIST
32817: PUSH
32818: LD_INT 34
32820: PUSH
32821: LD_INT 8
32823: PUSH
32824: EMPTY
32825: LIST
32826: LIST
32827: PUSH
32828: EMPTY
32829: LIST
32830: LIST
32831: PPUSH
32832: CALL_OW 69
32836: NOT
32837: IFFALSE 33183
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
32839: LD_ADDR_VAR 0 3
32843: PUSH
32844: LD_INT 22
32846: PUSH
32847: LD_INT 1
32849: PUSH
32850: EMPTY
32851: LIST
32852: LIST
32853: PUSH
32854: LD_INT 26
32856: PUSH
32857: LD_INT 1
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: LD_INT 3
32866: PUSH
32867: LD_INT 25
32869: PUSH
32870: LD_INT 12
32872: PUSH
32873: EMPTY
32874: LIST
32875: LIST
32876: PUSH
32877: LD_INT 25
32879: PUSH
32880: LD_INT 16
32882: PUSH
32883: EMPTY
32884: LIST
32885: LIST
32886: PUSH
32887: EMPTY
32888: LIST
32889: LIST
32890: LIST
32891: PUSH
32892: EMPTY
32893: LIST
32894: LIST
32895: LIST
32896: PPUSH
32897: CALL_OW 69
32901: PUSH
32902: LD_EXP 40
32906: PUSH
32907: LD_EXP 42
32911: PUSH
32912: LD_EXP 56
32916: PUSH
32917: LD_EXP 43
32921: PUSH
32922: LD_EXP 44
32926: PUSH
32927: LD_EXP 45
32931: PUSH
32932: LD_EXP 46
32936: PUSH
32937: LD_EXP 47
32941: PUSH
32942: LD_EXP 48
32946: PUSH
32947: LD_EXP 49
32951: PUSH
32952: LD_EXP 50
32956: PUSH
32957: LD_EXP 51
32961: PUSH
32962: LD_EXP 52
32966: PUSH
32967: LD_EXP 53
32971: PUSH
32972: LD_EXP 54
32976: PUSH
32977: EMPTY
32978: LIST
32979: LIST
32980: LIST
32981: LIST
32982: LIST
32983: LIST
32984: LIST
32985: LIST
32986: LIST
32987: LIST
32988: LIST
32989: LIST
32990: LIST
32991: LIST
32992: LIST
32993: DIFF
32994: ST_TO_ADDR
// DialogueOn ;
32995: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
32999: LD_EXP 68
33003: PPUSH
33004: LD_STRING D16a-Pla-1
33006: PPUSH
33007: CALL_OW 94
// if Stevens then
33011: LD_EXP 42
33015: IFFALSE 33031
// Say ( Stevens , D16a-Huck-1 ) else
33017: LD_EXP 42
33021: PPUSH
33022: LD_STRING D16a-Huck-1
33024: PPUSH
33025: CALL_OW 88
33029: GO 33073
// if Baker then
33031: LD_EXP 56
33035: IFFALSE 33051
// Say ( Baker , D16a-Huck-1 ) else
33037: LD_EXP 56
33041: PPUSH
33042: LD_STRING D16a-Huck-1
33044: PPUSH
33045: CALL_OW 88
33049: GO 33073
// if tmp then
33051: LD_VAR 0 3
33055: IFFALSE 33073
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
33057: LD_VAR 0 3
33061: PUSH
33062: LD_INT 1
33064: ARRAY
33065: PPUSH
33066: LD_STRING D16a-Sol1-1
33068: PPUSH
33069: CALL_OW 88
// if GetSide ( Friend ) = 8 then
33073: LD_EXP 66
33077: PPUSH
33078: CALL_OW 255
33082: PUSH
33083: LD_INT 8
33085: EQUAL
33086: IFFALSE 33102
// Say ( JMM , D16a-JMM-1 ) else
33088: LD_EXP 40
33092: PPUSH
33093: LD_STRING D16a-JMM-1
33095: PPUSH
33096: CALL_OW 88
33100: GO 33162
// begin Say ( JMM , D16a-JMM-1a ) ;
33102: LD_EXP 40
33106: PPUSH
33107: LD_STRING D16a-JMM-1a
33109: PPUSH
33110: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
33114: LD_EXP 66
33118: PPUSH
33119: LD_STRING D16a-Friend-1
33121: PPUSH
33122: CALL_OW 88
// ComExitBuilding ( Friend ) ;
33126: LD_EXP 66
33130: PPUSH
33131: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
33135: LD_EXP 66
33139: PPUSH
33140: LD_INT 191
33142: PPUSH
33143: LD_INT 103
33145: PPUSH
33146: CALL_OW 171
// SetSide ( Friend , 3 ) ;
33150: LD_EXP 66
33154: PPUSH
33155: LD_INT 3
33157: PPUSH
33158: CALL_OW 235
// end ; DialogueOff ;
33162: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
33166: LD_VAR 0 1
33170: PPUSH
33171: LD_INT 60
33173: PPUSH
33174: LD_INT 95
33176: PPUSH
33177: CALL_OW 116
// end else
33181: GO 33203
// begin DialogueOn ;
33183: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
33187: LD_EXP 68
33191: PPUSH
33192: LD_STRING D16c-Pla-1
33194: PPUSH
33195: CALL_OW 94
// DialogueOff ;
33199: CALL_OW 7
// end ; end else
33203: GO 33311
// begin wait ( 3 3$00 ) ;
33205: LD_INT 6300
33207: PPUSH
33208: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) and not bombExploded then
33212: LD_INT 22
33214: PUSH
33215: LD_INT 1
33217: PUSH
33218: EMPTY
33219: LIST
33220: LIST
33221: PUSH
33222: LD_INT 34
33224: PUSH
33225: LD_INT 8
33227: PUSH
33228: EMPTY
33229: LIST
33230: LIST
33231: PUSH
33232: EMPTY
33233: LIST
33234: LIST
33235: PPUSH
33236: CALL_OW 69
33240: NOT
33241: PUSH
33242: LD_EXP 37
33246: NOT
33247: AND
33248: IFFALSE 33291
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
33250: LD_EXP 68
33254: PPUSH
33255: LD_STRING D16b-Pla-1
33257: PPUSH
33258: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
33262: LD_EXP 40
33266: PPUSH
33267: LD_STRING D16b-JMM-1
33269: PPUSH
33270: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
33274: LD_VAR 0 1
33278: PPUSH
33279: LD_INT 60
33281: PPUSH
33282: LD_INT 95
33284: PPUSH
33285: CALL_OW 116
// end else
33289: GO 33311
// begin DialogueOn ;
33291: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
33295: LD_EXP 68
33299: PPUSH
33300: LD_STRING D16c-Pla-1
33302: PPUSH
33303: CALL_OW 94
// DialogueOff ;
33307: CALL_OW 7
// end ; end ; end ;
33311: PPOPN 3
33313: END
// every 0 0$10 trigger ( GetTech ( tech_SibFiss , 1 ) = state_researched or missionTime >= 60 60$00 ) and not allianceDestroyed and IsOk ( Roth ) do var dec ;
33314: LD_INT 25
33316: PPUSH
33317: LD_INT 1
33319: PPUSH
33320: CALL_OW 321
33324: PUSH
33325: LD_INT 2
33327: EQUAL
33328: PUSH
33329: LD_EXP 14
33333: PUSH
33334: LD_INT 126000
33336: GREATEREQUAL
33337: OR
33338: PUSH
33339: LD_EXP 23
33343: NOT
33344: AND
33345: PUSH
33346: LD_EXP 79
33350: PPUSH
33351: CALL_OW 302
33355: AND
33356: IFFALSE 33714
33358: GO 33360
33360: DISABLE
33361: LD_INT 0
33363: PPUSH
// begin missionStage := 11 ;
33364: LD_ADDR_EXP 15
33368: PUSH
33369: LD_INT 11
33371: ST_TO_ADDR
// DialogueOn ;
33372: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
33376: LD_EXP 79
33380: PPUSH
33381: LD_STRING D9-Roth-1
33383: PPUSH
33384: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
33388: LD_EXP 40
33392: PPUSH
33393: LD_STRING D9-JMM-1
33395: PPUSH
33396: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
33400: LD_EXP 79
33404: PPUSH
33405: LD_STRING D9-Roth-2
33407: PPUSH
33408: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
33412: LD_EXP 79
33416: PPUSH
33417: LD_STRING D9-Roth-2a
33419: PPUSH
33420: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
33424: LD_EXP 68
33428: PPUSH
33429: LD_STRING D9-Pla-2
33431: PPUSH
33432: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
33436: LD_EXP 79
33440: PPUSH
33441: LD_STRING D9-Roth-3
33443: PPUSH
33444: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
33448: LD_EXP 68
33452: PPUSH
33453: LD_STRING D9-Pla-3
33455: PPUSH
33456: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
33460: LD_EXP 79
33464: PPUSH
33465: LD_STRING D9-Roth-4
33467: PPUSH
33468: CALL_OW 94
// dec := Query ( Q9 ) ;
33472: LD_ADDR_VAR 0 1
33476: PUSH
33477: LD_STRING Q9
33479: PPUSH
33480: CALL_OW 97
33484: ST_TO_ADDR
// if dec = 1 then
33485: LD_VAR 0 1
33489: PUSH
33490: LD_INT 1
33492: EQUAL
33493: IFFALSE 33507
// SayRadio ( Roth , D9a-Roth-1 ) ;
33495: LD_EXP 79
33499: PPUSH
33500: LD_STRING D9a-Roth-1
33502: PPUSH
33503: CALL_OW 94
// if dec = 2 then
33507: LD_VAR 0 1
33511: PUSH
33512: LD_INT 2
33514: EQUAL
33515: IFFALSE 33541
// begin Say ( JMM , D9b-JMM-1 ) ;
33517: LD_EXP 40
33521: PPUSH
33522: LD_STRING D9b-JMM-1
33524: PPUSH
33525: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
33529: LD_EXP 79
33533: PPUSH
33534: LD_STRING D9b-Roth-1
33536: PPUSH
33537: CALL_OW 94
// end ; if dec = 3 then
33541: LD_VAR 0 1
33545: PUSH
33546: LD_INT 3
33548: EQUAL
33549: IFFALSE 33611
// begin Say ( JMM , D9c-JMM-1 ) ;
33551: LD_EXP 40
33555: PPUSH
33556: LD_STRING D9c-JMM-1
33558: PPUSH
33559: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
33563: LD_EXP 79
33567: PPUSH
33568: LD_STRING D9c-Roth-1
33570: PPUSH
33571: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
33575: LD_EXP 40
33579: PPUSH
33580: LD_STRING D9c-JMM-2
33582: PPUSH
33583: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
33587: LD_EXP 79
33591: PPUSH
33592: LD_STRING D9c-Roth-2
33594: PPUSH
33595: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
33599: LD_EXP 40
33603: PPUSH
33604: LD_STRING D9c-JMM-3
33606: PPUSH
33607: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
33611: LD_EXP 79
33615: PPUSH
33616: LD_STRING D9c-Roth-3
33618: PPUSH
33619: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
33623: LD_EXP 79
33627: PPUSH
33628: LD_STRING D9cont-Roth-1
33630: PPUSH
33631: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
33635: LD_EXP 40
33639: PPUSH
33640: LD_STRING D9cont-JMM-1
33642: PPUSH
33643: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
33647: LD_EXP 79
33651: PPUSH
33652: LD_STRING D9cont-Roth-2
33654: PPUSH
33655: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
33659: LD_EXP 40
33663: PPUSH
33664: LD_STRING D9cont-JMM-2
33666: PPUSH
33667: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
33671: LD_EXP 79
33675: PPUSH
33676: LD_STRING D9cont-Roth-3
33678: PPUSH
33679: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
33683: LD_EXP 40
33687: PPUSH
33688: LD_STRING D9cont-JMM-3
33690: PPUSH
33691: CALL_OW 88
// DialogueOff ;
33695: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
33699: LD_STRING M3
33701: PPUSH
33702: CALL_OW 337
// allianceActive := true ;
33706: LD_ADDR_EXP 31
33710: PUSH
33711: LD_INT 1
33713: ST_TO_ADDR
// end ;
33714: PPOPN 1
33716: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
33717: LD_INT 1
33719: PPUSH
33720: LD_INT 126
33722: PPUSH
33723: CALL_OW 292
33727: PUSH
33728: LD_EXP 68
33732: PPUSH
33733: CALL_OW 310
33737: AND
33738: IFFALSE 33891
33740: GO 33742
33742: DISABLE
33743: LD_INT 0
33745: PPUSH
// begin ComExitBuilding ( Platonov ) ;
33746: LD_EXP 68
33750: PPUSH
33751: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
33755: LD_ADDR_VAR 0 1
33759: PUSH
33760: LD_INT 4
33762: PPUSH
33763: LD_INT 22
33765: PUSH
33766: LD_INT 1
33768: PUSH
33769: EMPTY
33770: LIST
33771: LIST
33772: PPUSH
33773: CALL_OW 70
33777: PPUSH
33778: LD_EXP 68
33782: PPUSH
33783: CALL_OW 74
33787: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
33788: LD_EXP 68
33792: PPUSH
33793: LD_VAR 0 1
33797: PUSH
33798: LD_INT 1
33800: ARRAY
33801: PPUSH
33802: CALL_OW 175
// SayRadio ( Platonov , D18-Pla-1 ) ;
33806: LD_EXP 68
33810: PPUSH
33811: LD_STRING D18-Pla-1
33813: PPUSH
33814: CALL_OW 94
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
33818: LD_INT 22
33820: PUSH
33821: LD_INT 3
33823: PUSH
33824: EMPTY
33825: LIST
33826: LIST
33827: PUSH
33828: LD_INT 34
33830: PUSH
33831: LD_INT 48
33833: PUSH
33834: EMPTY
33835: LIST
33836: LIST
33837: PUSH
33838: EMPTY
33839: LIST
33840: LIST
33841: PPUSH
33842: CALL_OW 69
33846: IFFALSE 33891
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 111 , 97 ) ;
33848: LD_INT 22
33850: PUSH
33851: LD_INT 3
33853: PUSH
33854: EMPTY
33855: LIST
33856: LIST
33857: PUSH
33858: LD_INT 34
33860: PUSH
33861: LD_INT 48
33863: PUSH
33864: EMPTY
33865: LIST
33866: LIST
33867: PUSH
33868: EMPTY
33869: LIST
33870: LIST
33871: PPUSH
33872: CALL_OW 69
33876: PUSH
33877: LD_INT 1
33879: ARRAY
33880: PPUSH
33881: LD_INT 111
33883: PPUSH
33884: LD_INT 97
33886: PPUSH
33887: CALL_OW 116
// end ;
33891: PPOPN 1
33893: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 14 , 13 , 12 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
33894: LD_EXP 68
33898: PPUSH
33899: CALL_OW 301
33903: PUSH
33904: LD_EXP 71
33908: PPUSH
33909: CALL_OW 301
33913: AND
33914: PUSH
33915: LD_INT 22
33917: PUSH
33918: LD_INT 3
33920: PUSH
33921: EMPTY
33922: LIST
33923: LIST
33924: PUSH
33925: LD_INT 21
33927: PUSH
33928: LD_INT 1
33930: PUSH
33931: EMPTY
33932: LIST
33933: LIST
33934: PUSH
33935: LD_INT 50
33937: PUSH
33938: EMPTY
33939: LIST
33940: PUSH
33941: EMPTY
33942: LIST
33943: LIST
33944: LIST
33945: PPUSH
33946: CALL_OW 69
33950: PUSH
33951: LD_INT 14
33953: PUSH
33954: LD_INT 13
33956: PUSH
33957: LD_INT 12
33959: PUSH
33960: LD_INT 10
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: LIST
33967: LIST
33968: PUSH
33969: LD_OWVAR 67
33973: ARRAY
33974: LESS
33975: AND
33976: IFFALSE 34775
33978: GO 33980
33980: DISABLE
33981: LD_INT 0
33983: PPUSH
33984: PPUSH
33985: PPUSH
33986: PPUSH
// begin MC_Kill ( 2 ) ;
33987: LD_INT 2
33989: PPUSH
33990: CALL 39845 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
33994: LD_INT 1
33996: PPUSH
33997: LD_INT 3
33999: PPUSH
34000: LD_INT 1
34002: PPUSH
34003: LD_INT 1
34005: PPUSH
34006: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
34010: LD_ADDR_VAR 0 2
34014: PUSH
34015: LD_INT 22
34017: PUSH
34018: LD_INT 3
34020: PUSH
34021: EMPTY
34022: LIST
34023: LIST
34024: PUSH
34025: LD_INT 21
34027: PUSH
34028: LD_INT 1
34030: PUSH
34031: EMPTY
34032: LIST
34033: LIST
34034: PUSH
34035: LD_INT 50
34037: PUSH
34038: EMPTY
34039: LIST
34040: PUSH
34041: LD_INT 26
34043: PUSH
34044: LD_INT 1
34046: PUSH
34047: EMPTY
34048: LIST
34049: LIST
34050: PUSH
34051: EMPTY
34052: LIST
34053: LIST
34054: LIST
34055: LIST
34056: PPUSH
34057: CALL_OW 69
34061: ST_TO_ADDR
// if not tmp then
34062: LD_VAR 0 2
34066: NOT
34067: IFFALSE 34123
// begin uc_side = 3 ;
34069: LD_ADDR_OWVAR 20
34073: PUSH
34074: LD_INT 3
34076: ST_TO_ADDR
// uc_nation = 3 ;
34077: LD_ADDR_OWVAR 21
34081: PUSH
34082: LD_INT 3
34084: ST_TO_ADDR
// hc_name =  ;
34085: LD_ADDR_OWVAR 26
34089: PUSH
34090: LD_STRING 
34092: ST_TO_ADDR
// hc_gallery =  ;
34093: LD_ADDR_OWVAR 33
34097: PUSH
34098: LD_STRING 
34100: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
34101: LD_INT 1
34103: PPUSH
34104: LD_INT 10
34106: PPUSH
34107: CALL_OW 381
// tmp = CreateHuman ;
34111: LD_ADDR_VAR 0 2
34115: PUSH
34116: CALL_OW 44
34120: ST_TO_ADDR
// end else
34121: GO 34137
// tmp := tmp [ 1 ] ;
34123: LD_ADDR_VAR 0 2
34127: PUSH
34128: LD_VAR 0 2
34132: PUSH
34133: LD_INT 1
34135: ARRAY
34136: ST_TO_ADDR
// DialogueOn ;
34137: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
34141: LD_VAR 0 2
34145: PPUSH
34146: LD_STRING DSurrenderRussians-RSol1-1a
34148: PPUSH
34149: CALL_OW 94
// DialogueOff ;
34153: CALL_OW 7
// russianDestroyed := true ;
34157: LD_ADDR_EXP 21
34161: PUSH
34162: LD_INT 1
34164: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
34165: LD_ADDR_VAR 0 1
34169: PUSH
34170: LD_INT 22
34172: PUSH
34173: LD_INT 6
34175: PUSH
34176: EMPTY
34177: LIST
34178: LIST
34179: PPUSH
34180: CALL_OW 69
34184: PUSH
34185: FOR_IN
34186: IFFALSE 34199
// KillUnit ( i ) ;
34188: LD_VAR 0 1
34192: PPUSH
34193: CALL_OW 66
34197: GO 34185
34199: POP
34200: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
34201: LD_INT 22
34203: PUSH
34204: LD_INT 3
34206: PUSH
34207: EMPTY
34208: LIST
34209: LIST
34210: PUSH
34211: LD_INT 21
34213: PUSH
34214: LD_INT 1
34216: PUSH
34217: EMPTY
34218: LIST
34219: LIST
34220: PUSH
34221: EMPTY
34222: LIST
34223: LIST
34224: PPUSH
34225: CALL_OW 69
34229: PPUSH
34230: CALL_OW 122
// wait ( 0 0$1 ) ;
34234: LD_INT 35
34236: PPUSH
34237: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
34241: LD_INT 22
34243: PUSH
34244: LD_INT 3
34246: PUSH
34247: EMPTY
34248: LIST
34249: LIST
34250: PUSH
34251: LD_INT 21
34253: PUSH
34254: LD_INT 1
34256: PUSH
34257: EMPTY
34258: LIST
34259: LIST
34260: PUSH
34261: EMPTY
34262: LIST
34263: LIST
34264: PPUSH
34265: CALL_OW 69
34269: PPUSH
34270: LD_INT 25
34272: PPUSH
34273: CALL_OW 173
// wait ( 0 0$35 ) ;
34277: LD_INT 1225
34279: PPUSH
34280: CALL_OW 67
// PrepareOmarInvasion ;
34284: CALL 16368 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
34288: LD_ADDR_VAR 0 2
34292: PUSH
34293: LD_EXP 97
34297: PPUSH
34298: CALL_OW 250
34302: PUSH
34303: LD_EXP 97
34307: PPUSH
34308: CALL_OW 251
34312: PUSH
34313: EMPTY
34314: LIST
34315: LIST
34316: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
34317: LD_VAR 0 2
34321: PUSH
34322: LD_INT 1
34324: ARRAY
34325: PPUSH
34326: LD_VAR 0 2
34330: PUSH
34331: LD_INT 2
34333: ARRAY
34334: PPUSH
34335: LD_INT 1
34337: PPUSH
34338: LD_INT 8
34340: NEG
34341: PPUSH
34342: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
34346: LD_EXP 97
34350: PPUSH
34351: CALL_OW 87
// DialogueOn ;
34355: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
34359: LD_EXP 40
34363: PPUSH
34364: LD_STRING D19-JMM-1
34366: PPUSH
34367: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Kurt , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
34371: LD_ADDR_VAR 0 3
34375: PUSH
34376: LD_INT 22
34378: PUSH
34379: LD_INT 1
34381: PUSH
34382: EMPTY
34383: LIST
34384: LIST
34385: PUSH
34386: LD_INT 26
34388: PUSH
34389: LD_INT 1
34391: PUSH
34392: EMPTY
34393: LIST
34394: LIST
34395: PUSH
34396: LD_INT 2
34398: PUSH
34399: LD_INT 25
34401: PUSH
34402: LD_INT 1
34404: PUSH
34405: EMPTY
34406: LIST
34407: LIST
34408: PUSH
34409: LD_INT 25
34411: PUSH
34412: LD_INT 2
34414: PUSH
34415: EMPTY
34416: LIST
34417: LIST
34418: PUSH
34419: LD_INT 25
34421: PUSH
34422: LD_INT 3
34424: PUSH
34425: EMPTY
34426: LIST
34427: LIST
34428: PUSH
34429: LD_INT 25
34431: PUSH
34432: LD_INT 4
34434: PUSH
34435: EMPTY
34436: LIST
34437: LIST
34438: PUSH
34439: LD_INT 25
34441: PUSH
34442: LD_INT 5
34444: PUSH
34445: EMPTY
34446: LIST
34447: LIST
34448: PUSH
34449: LD_INT 25
34451: PUSH
34452: LD_INT 8
34454: PUSH
34455: EMPTY
34456: LIST
34457: LIST
34458: PUSH
34459: EMPTY
34460: LIST
34461: LIST
34462: LIST
34463: LIST
34464: LIST
34465: LIST
34466: LIST
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: LIST
34472: PPUSH
34473: CALL_OW 69
34477: PUSH
34478: LD_EXP 40
34482: PUSH
34483: LD_EXP 41
34487: PUSH
34488: LD_EXP 64
34492: PUSH
34493: LD_EXP 42
34497: PUSH
34498: LD_EXP 43
34502: PUSH
34503: LD_EXP 44
34507: PUSH
34508: LD_EXP 45
34512: PUSH
34513: LD_EXP 46
34517: PUSH
34518: LD_EXP 47
34522: PUSH
34523: LD_EXP 48
34527: PUSH
34528: LD_EXP 49
34532: PUSH
34533: LD_EXP 50
34537: PUSH
34538: LD_EXP 51
34542: PUSH
34543: LD_EXP 52
34547: PUSH
34548: LD_EXP 53
34552: PUSH
34553: LD_EXP 54
34557: PUSH
34558: LD_EXP 55
34562: PUSH
34563: LD_EXP 56
34567: PUSH
34568: EMPTY
34569: LIST
34570: LIST
34571: LIST
34572: LIST
34573: LIST
34574: LIST
34575: LIST
34576: LIST
34577: LIST
34578: LIST
34579: LIST
34580: LIST
34581: LIST
34582: LIST
34583: LIST
34584: LIST
34585: LIST
34586: LIST
34587: DIFF
34588: ST_TO_ADDR
// if tmp2 then
34589: LD_VAR 0 3
34593: IFFALSE 34611
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
34595: LD_VAR 0 3
34599: PUSH
34600: LD_INT 1
34602: ARRAY
34603: PPUSH
34604: LD_STRING D19-Sol1-1
34606: PPUSH
34607: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
34611: LD_EXP 40
34615: PPUSH
34616: LD_STRING D19-JMM-2
34618: PPUSH
34619: CALL_OW 88
// DialogueOff ;
34623: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
34627: LD_VAR 0 2
34631: PUSH
34632: LD_INT 1
34634: ARRAY
34635: PPUSH
34636: LD_VAR 0 2
34640: PUSH
34641: LD_INT 2
34643: ARRAY
34644: PPUSH
34645: LD_INT 1
34647: PPUSH
34648: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
34652: LD_STRING M5
34654: PPUSH
34655: CALL_OW 337
// omarOnMotherLode := false ;
34659: LD_ADDR_VAR 0 4
34663: PUSH
34664: LD_INT 0
34666: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
34667: LD_INT 35
34669: PPUSH
34670: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
34674: LD_EXP 97
34678: PPUSH
34679: LD_INT 215
34681: PPUSH
34682: LD_INT 100
34684: PPUSH
34685: CALL_OW 297
34689: PUSH
34690: LD_INT 10
34692: LESS
34693: PUSH
34694: LD_VAR 0 4
34698: NOT
34699: AND
34700: IFFALSE 34734
// begin omarOnMotherLode := true ;
34702: LD_ADDR_VAR 0 4
34706: PUSH
34707: LD_INT 1
34709: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
34710: LD_EXP 40
34714: PPUSH
34715: LD_STRING D19b-JMM-1
34717: PPUSH
34718: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
34722: LD_EXP 97
34726: PPUSH
34727: LD_STRING DOmarContam-Omar-1
34729: PPUSH
34730: CALL_OW 88
// end ; until IsDead ( Omar ) ;
34734: LD_EXP 97
34738: PPUSH
34739: CALL_OW 301
34743: IFFALSE 34667
// Say ( JMM , D19a-JMM-1 ) ;
34745: LD_EXP 40
34749: PPUSH
34750: LD_STRING D19a-JMM-1
34752: PPUSH
34753: CALL_OW 88
// if Heike then
34757: LD_EXP 98
34761: IFFALSE 34775
// Say ( Heike , D19a-Hke-1 ) ;
34763: LD_EXP 98
34767: PPUSH
34768: LD_STRING D19a-Hke-1
34770: PPUSH
34771: CALL_OW 88
// end ;
34775: PPOPN 4
34777: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
34778: LD_INT 22
34780: PUSH
34781: LD_INT 3
34783: PUSH
34784: EMPTY
34785: LIST
34786: LIST
34787: PUSH
34788: LD_INT 21
34790: PUSH
34791: LD_INT 1
34793: PUSH
34794: EMPTY
34795: LIST
34796: LIST
34797: PUSH
34798: EMPTY
34799: LIST
34800: LIST
34801: PPUSH
34802: CALL_OW 69
34806: PUSH
34807: LD_EXP 21
34811: AND
34812: IFFALSE 34880
34814: GO 34816
34816: DISABLE
34817: LD_INT 0
34819: PPUSH
34820: PPUSH
// begin enable ;
34821: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
34822: LD_ADDR_VAR 0 2
34826: PUSH
34827: LD_INT 25
34829: PPUSH
34830: LD_INT 22
34832: PUSH
34833: LD_INT 3
34835: PUSH
34836: EMPTY
34837: LIST
34838: LIST
34839: PPUSH
34840: CALL_OW 70
34844: ST_TO_ADDR
// if not tmp then
34845: LD_VAR 0 2
34849: NOT
34850: IFFALSE 34854
// exit ;
34852: GO 34880
// for i in tmp do
34854: LD_ADDR_VAR 0 1
34858: PUSH
34859: LD_VAR 0 2
34863: PUSH
34864: FOR_IN
34865: IFFALSE 34878
// RemoveUnit ( i ) ;
34867: LD_VAR 0 1
34871: PPUSH
34872: CALL_OW 64
34876: GO 34864
34878: POP
34879: POP
// end ;
34880: PPOPN 2
34882: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
34883: LD_INT 22
34885: PUSH
34886: LD_INT 7
34888: PUSH
34889: EMPTY
34890: LIST
34891: LIST
34892: PUSH
34893: LD_INT 21
34895: PUSH
34896: LD_INT 1
34898: PUSH
34899: EMPTY
34900: LIST
34901: LIST
34902: PUSH
34903: EMPTY
34904: LIST
34905: LIST
34906: PPUSH
34907: CALL_OW 69
34911: PUSH
34912: LD_INT 6
34914: LESS
34915: IFFALSE 35383
34917: GO 34919
34919: DISABLE
34920: LD_INT 0
34922: PPUSH
34923: PPUSH
// begin MC_Kill ( 1 ) ;
34924: LD_INT 1
34926: PPUSH
34927: CALL 39845 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
34931: LD_INT 7
34933: PPUSH
34934: LD_INT 1
34936: PPUSH
34937: LD_INT 1
34939: PPUSH
34940: LD_INT 1
34942: PPUSH
34943: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
34947: LD_ADDR_VAR 0 1
34951: PUSH
34952: LD_INT 22
34954: PUSH
34955: LD_INT 7
34957: PUSH
34958: EMPTY
34959: LIST
34960: LIST
34961: PUSH
34962: LD_INT 26
34964: PUSH
34965: LD_INT 1
34967: PUSH
34968: EMPTY
34969: LIST
34970: LIST
34971: PUSH
34972: EMPTY
34973: LIST
34974: LIST
34975: PPUSH
34976: CALL_OW 69
34980: PUSH
34981: LD_EXP 79
34985: DIFF
34986: ST_TO_ADDR
// if tmp then
34987: LD_VAR 0 1
34991: IFFALSE 35009
// tmp := tmp [ 1 ] else
34993: LD_ADDR_VAR 0 1
34997: PUSH
34998: LD_VAR 0 1
35002: PUSH
35003: LD_INT 1
35005: ARRAY
35006: ST_TO_ADDR
35007: GO 35045
// begin uc_side := 7 ;
35009: LD_ADDR_OWVAR 20
35013: PUSH
35014: LD_INT 7
35016: ST_TO_ADDR
// uc_nation := 1 ;
35017: LD_ADDR_OWVAR 21
35021: PUSH
35022: LD_INT 1
35024: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
35025: LD_INT 1
35027: PPUSH
35028: LD_INT 8
35030: PPUSH
35031: CALL_OW 384
// tmp := CreateHuman ;
35035: LD_ADDR_VAR 0 1
35039: PUSH
35040: CALL_OW 44
35044: ST_TO_ADDR
// end ; DialogueOn ;
35045: CALL_OW 6
// if IsOK ( Roth ) then
35049: LD_EXP 79
35053: PPUSH
35054: CALL_OW 302
35058: IFFALSE 35072
// Say ( JMM , DAb-JMM-1 ) ;
35060: LD_EXP 40
35064: PPUSH
35065: LD_STRING DAb-JMM-1
35067: PPUSH
35068: CALL_OW 88
// if IsOK ( Roth ) then
35072: LD_EXP 79
35076: PPUSH
35077: CALL_OW 302
35081: IFFALSE 35105
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
35083: LD_EXP 79
35087: PPUSH
35088: LD_STRING DSurrenderAlliance-Roth-1
35090: PPUSH
35091: CALL_OW 88
// RothCaptured := true ;
35095: LD_ADDR_EXP 33
35099: PUSH
35100: LD_INT 1
35102: ST_TO_ADDR
// end else
35103: GO 35117
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
35105: LD_VAR 0 1
35109: PPUSH
35110: LD_STRING DSurrenderAlliance-Sci1-1
35112: PPUSH
35113: CALL_OW 88
// DialogueOff ;
35117: CALL_OW 7
// allianceDestroyed := true ;
35121: LD_ADDR_EXP 23
35125: PUSH
35126: LD_INT 1
35128: ST_TO_ADDR
// if capturedUnit = 0 then
35129: LD_EXP 34
35133: PUSH
35134: LD_INT 0
35136: EQUAL
35137: IFFALSE 35146
// SetAchievement ( ACH_ALLIANCE ) ;
35139: LD_STRING ACH_ALLIANCE
35141: PPUSH
35142: CALL_OW 543
// if trueAmericans then
35146: LD_EXP 35
35150: IFFALSE 35226
// begin if trueAmericans = 1 then
35152: LD_EXP 35
35156: PUSH
35157: LD_INT 1
35159: EQUAL
35160: IFFALSE 35176
// Say ( JMM , DAb-JMM-1a ) else
35162: LD_EXP 40
35166: PPUSH
35167: LD_STRING DAb-JMM-1a
35169: PPUSH
35170: CALL_OW 88
35174: GO 35188
// Say ( JMM , DAb-JMM-1b ) ;
35176: LD_EXP 40
35180: PPUSH
35181: LD_STRING DAb-JMM-1b
35183: PPUSH
35184: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
35188: LD_EXP 35
35192: PPUSH
35193: CALL_OW 87
// for i in trueAmericans do
35197: LD_ADDR_VAR 0 2
35201: PUSH
35202: LD_EXP 35
35206: PUSH
35207: FOR_IN
35208: IFFALSE 35224
// SetSide ( i , 1 ) ;
35210: LD_VAR 0 2
35214: PPUSH
35215: LD_INT 1
35217: PPUSH
35218: CALL_OW 235
35222: GO 35207
35224: POP
35225: POP
// end ; repeat wait ( 0 0$1 ) ;
35226: LD_INT 35
35228: PPUSH
35229: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
35233: LD_ADDR_VAR 0 2
35237: PUSH
35238: LD_INT 22
35240: PUSH
35241: LD_INT 7
35243: PUSH
35244: EMPTY
35245: LIST
35246: LIST
35247: PUSH
35248: LD_INT 21
35250: PUSH
35251: LD_INT 1
35253: PUSH
35254: EMPTY
35255: LIST
35256: LIST
35257: PUSH
35258: EMPTY
35259: LIST
35260: LIST
35261: PPUSH
35262: CALL_OW 69
35266: PUSH
35267: FOR_IN
35268: IFFALSE 35350
// begin if IsInUnit ( i ) then
35270: LD_VAR 0 2
35274: PPUSH
35275: CALL_OW 310
35279: IFFALSE 35290
// ComExitBuilding ( i ) ;
35281: LD_VAR 0 2
35285: PPUSH
35286: CALL_OW 122
// if IsDriver ( i ) then
35290: LD_VAR 0 2
35294: PPUSH
35295: CALL 105695 0 1
35299: IFFALSE 35310
// ComExitVehicle ( i ) ;
35301: LD_VAR 0 2
35305: PPUSH
35306: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
35310: LD_VAR 0 2
35314: PPUSH
35315: LD_INT 26
35317: PPUSH
35318: CALL_OW 308
35322: NOT
35323: IFFALSE 35339
// AddComMoveToArea ( i , allianceEscapeArea ) else
35325: LD_VAR 0 2
35329: PPUSH
35330: LD_INT 26
35332: PPUSH
35333: CALL_OW 173
35337: GO 35348
// RemoveUnit ( i ) ;
35339: LD_VAR 0 2
35343: PPUSH
35344: CALL_OW 64
// end ;
35348: GO 35267
35350: POP
35351: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
35352: LD_INT 22
35354: PUSH
35355: LD_INT 7
35357: PUSH
35358: EMPTY
35359: LIST
35360: LIST
35361: PUSH
35362: LD_INT 21
35364: PUSH
35365: LD_INT 1
35367: PUSH
35368: EMPTY
35369: LIST
35370: LIST
35371: PUSH
35372: EMPTY
35373: LIST
35374: LIST
35375: PPUSH
35376: CALL_OW 69
35380: NOT
35381: IFFALSE 35226
// end ;
35383: PPOPN 2
35385: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
35386: LD_INT 0
35388: PPUSH
35389: PPUSH
// if not unit then
35390: LD_VAR 0 1
35394: NOT
35395: IFFALSE 35399
// exit ;
35397: GO 36913
// DoNotAttack ( 7 , unit ) ;
35399: LD_INT 7
35401: PPUSH
35402: LD_VAR 0 1
35406: PPUSH
35407: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
35411: LD_VAR 0 1
35415: PPUSH
35416: LD_INT 260
35418: PPUSH
35419: LD_INT 235
35421: PPUSH
35422: LD_INT 3
35424: PPUSH
35425: LD_INT 1
35427: PPUSH
35428: CALL_OW 483
// SetSide ( unit , 4 ) ;
35432: LD_VAR 0 1
35436: PPUSH
35437: LD_INT 4
35439: PPUSH
35440: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
35444: LD_ADDR_EXP 34
35448: PUSH
35449: LD_EXP 34
35453: PUSH
35454: LD_INT 1
35456: PLUS
35457: ST_TO_ADDR
// wait ( 0 0$2 ) ;
35458: LD_INT 70
35460: PPUSH
35461: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
35465: LD_INT 260
35467: PPUSH
35468: LD_INT 235
35470: PPUSH
35471: LD_INT 1
35473: PPUSH
35474: LD_INT 8
35476: NEG
35477: PPUSH
35478: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
35482: LD_VAR 0 1
35486: PPUSH
35487: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
35491: LD_VAR 0 1
35495: PPUSH
35496: LD_EXP 79
35500: PPUSH
35501: CALL_OW 119
// DialogueOn ;
35505: CALL_OW 6
// case unit of JMM :
35509: LD_VAR 0 1
35513: PUSH
35514: LD_EXP 40
35518: DOUBLE
35519: EQUAL
35520: IFTRUE 35524
35522: GO 35539
35524: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
35525: LD_EXP 40
35529: PPUSH
35530: LD_STRING DA1-JMM-1
35532: PPUSH
35533: CALL_OW 91
35537: GO 35981
35539: LD_EXP 41
35543: DOUBLE
35544: EQUAL
35545: IFTRUE 35549
35547: GO 35564
35549: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
35550: LD_EXP 41
35554: PPUSH
35555: LD_STRING DA1-Joan-1
35557: PPUSH
35558: CALL_OW 91
35562: GO 35981
35564: LD_EXP 43
35568: DOUBLE
35569: EQUAL
35570: IFTRUE 35574
35572: GO 35589
35574: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
35575: LD_EXP 43
35579: PPUSH
35580: LD_STRING DA1-Lisa-1
35582: PPUSH
35583: CALL_OW 91
35587: GO 35981
35589: LD_EXP 44
35593: DOUBLE
35594: EQUAL
35595: IFTRUE 35599
35597: GO 35614
35599: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
35600: LD_EXP 44
35604: PPUSH
35605: LD_STRING DA1-Don-1
35607: PPUSH
35608: CALL_OW 91
35612: GO 35981
35614: LD_EXP 51
35618: DOUBLE
35619: EQUAL
35620: IFTRUE 35624
35622: GO 35639
35624: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
35625: LD_EXP 51
35629: PPUSH
35630: LD_STRING DA1-Corn-1
35632: PPUSH
35633: CALL_OW 91
35637: GO 35981
35639: LD_EXP 47
35643: DOUBLE
35644: EQUAL
35645: IFTRUE 35649
35647: GO 35664
35649: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
35650: LD_EXP 47
35654: PPUSH
35655: LD_STRING DA1-Den-1
35657: PPUSH
35658: CALL_OW 91
35662: GO 35981
35664: LD_EXP 45
35668: DOUBLE
35669: EQUAL
35670: IFTRUE 35674
35672: GO 35689
35674: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
35675: LD_EXP 45
35679: PPUSH
35680: LD_STRING DA1-Bobby-1
35682: PPUSH
35683: CALL_OW 91
35687: GO 35981
35689: LD_EXP 49
35693: DOUBLE
35694: EQUAL
35695: IFTRUE 35699
35697: GO 35714
35699: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
35700: LD_EXP 49
35704: PPUSH
35705: LD_STRING DA1-Glad-1
35707: PPUSH
35708: CALL_OW 91
35712: GO 35981
35714: LD_EXP 46
35718: DOUBLE
35719: EQUAL
35720: IFTRUE 35724
35722: GO 35739
35724: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
35725: LD_EXP 46
35729: PPUSH
35730: LD_STRING DA1-Cyrus-1
35732: PPUSH
35733: CALL_OW 91
35737: GO 35981
35739: LD_EXP 42
35743: DOUBLE
35744: EQUAL
35745: IFTRUE 35749
35747: GO 35764
35749: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
35750: LD_EXP 42
35754: PPUSH
35755: LD_STRING DA1-Huck-1
35757: PPUSH
35758: CALL_OW 91
35762: GO 35981
35764: LD_EXP 56
35768: DOUBLE
35769: EQUAL
35770: IFTRUE 35774
35772: GO 35789
35774: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
35775: LD_EXP 56
35779: PPUSH
35780: LD_STRING DA1-Huck-1
35782: PPUSH
35783: CALL_OW 91
35787: GO 35981
35789: LD_EXP 48
35793: DOUBLE
35794: EQUAL
35795: IFTRUE 35799
35797: GO 35814
35799: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
35800: LD_EXP 48
35804: PPUSH
35805: LD_STRING DA1-Brown-1
35807: PPUSH
35808: CALL_OW 91
35812: GO 35981
35814: LD_EXP 52
35818: DOUBLE
35819: EQUAL
35820: IFTRUE 35824
35822: GO 35839
35824: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
35825: LD_EXP 52
35829: PPUSH
35830: LD_STRING DA1-Gary-1
35832: PPUSH
35833: CALL_OW 91
35837: GO 35981
35839: LD_EXP 55
35843: DOUBLE
35844: EQUAL
35845: IFTRUE 35849
35847: GO 35864
35849: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
35850: LD_EXP 55
35854: PPUSH
35855: LD_STRING DA1-Con-1
35857: PPUSH
35858: CALL_OW 91
35862: GO 35981
35864: LD_EXP 64
35868: DOUBLE
35869: EQUAL
35870: IFTRUE 35874
35872: GO 35889
35874: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
35875: LD_EXP 64
35879: PPUSH
35880: LD_STRING DA1-Kurt-1
35882: PPUSH
35883: CALL_OW 91
35887: GO 35981
35889: LD_EXP 54
35893: DOUBLE
35894: EQUAL
35895: IFTRUE 35899
35897: GO 35914
35899: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
35900: LD_EXP 54
35904: PPUSH
35905: LD_STRING DA1-Yam-1
35907: PPUSH
35908: CALL_OW 91
35912: GO 35981
35914: LD_EXP 53
35918: DOUBLE
35919: EQUAL
35920: IFTRUE 35924
35922: GO 35939
35924: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
35925: LD_EXP 53
35929: PPUSH
35930: LD_STRING DA1-Frank-1
35932: PPUSH
35933: CALL_OW 91
35937: GO 35981
35939: POP
// begin if GetSex ( unit ) = sex_male then
35940: LD_VAR 0 1
35944: PPUSH
35945: CALL_OW 258
35949: PUSH
35950: LD_INT 1
35952: EQUAL
35953: IFFALSE 35969
// ForceSay ( unit , DA1-Sol1-1 ) else
35955: LD_VAR 0 1
35959: PPUSH
35960: LD_STRING DA1-Sol1-1
35962: PPUSH
35963: CALL_OW 91
35967: GO 35981
// ForceSay ( unit , DA1-FSol1-1 ) ;
35969: LD_VAR 0 1
35973: PPUSH
35974: LD_STRING DA1-FSol1-1
35976: PPUSH
35977: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
35981: LD_EXP 79
35985: PPUSH
35986: LD_STRING DA-Roth-1
35988: PPUSH
35989: CALL_OW 88
// if capturedUnit = 1 then
35993: LD_EXP 34
35997: PUSH
35998: LD_INT 1
36000: EQUAL
36001: IFFALSE 36029
// begin Say ( Simms , DA-Sim-1 ) ;
36003: LD_EXP 80
36007: PPUSH
36008: LD_STRING DA-Sim-1
36010: PPUSH
36011: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
36015: LD_EXP 79
36019: PPUSH
36020: LD_STRING DA-Roth-2
36022: PPUSH
36023: CALL_OW 88
// end else
36027: GO 36041
// Say ( Simms , DA-Sim-2 ) ;
36029: LD_EXP 80
36033: PPUSH
36034: LD_STRING DA-Sim-2
36036: PPUSH
36037: CALL_OW 88
// case unit of JMM :
36041: LD_VAR 0 1
36045: PUSH
36046: LD_EXP 40
36050: DOUBLE
36051: EQUAL
36052: IFTRUE 36056
36054: GO 36071
36056: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
36057: LD_EXP 40
36061: PPUSH
36062: LD_STRING DA1-JMM-1a
36064: PPUSH
36065: CALL_OW 91
36069: GO 36588
36071: LD_EXP 41
36075: DOUBLE
36076: EQUAL
36077: IFTRUE 36081
36079: GO 36096
36081: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
36082: LD_EXP 41
36086: PPUSH
36087: LD_STRING DA1-Joan-1a
36089: PPUSH
36090: CALL_OW 91
36094: GO 36588
36096: LD_EXP 43
36100: DOUBLE
36101: EQUAL
36102: IFTRUE 36106
36104: GO 36121
36106: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
36107: LD_EXP 43
36111: PPUSH
36112: LD_STRING DA1-Lisa-1a
36114: PPUSH
36115: CALL_OW 91
36119: GO 36588
36121: LD_EXP 44
36125: DOUBLE
36126: EQUAL
36127: IFTRUE 36131
36129: GO 36146
36131: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
36132: LD_EXP 44
36136: PPUSH
36137: LD_STRING DA1-Don-1a
36139: PPUSH
36140: CALL_OW 91
36144: GO 36588
36146: LD_EXP 51
36150: DOUBLE
36151: EQUAL
36152: IFTRUE 36156
36154: GO 36171
36156: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
36157: LD_EXP 51
36161: PPUSH
36162: LD_STRING DA1-Corn-1a
36164: PPUSH
36165: CALL_OW 91
36169: GO 36588
36171: LD_EXP 47
36175: DOUBLE
36176: EQUAL
36177: IFTRUE 36181
36179: GO 36196
36181: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
36182: LD_EXP 47
36186: PPUSH
36187: LD_STRING DA1-Den-1a
36189: PPUSH
36190: CALL_OW 91
36194: GO 36588
36196: LD_EXP 45
36200: DOUBLE
36201: EQUAL
36202: IFTRUE 36206
36204: GO 36221
36206: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
36207: LD_EXP 45
36211: PPUSH
36212: LD_STRING DA1-Bobby-1a
36214: PPUSH
36215: CALL_OW 91
36219: GO 36588
36221: LD_EXP 49
36225: DOUBLE
36226: EQUAL
36227: IFTRUE 36231
36229: GO 36246
36231: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
36232: LD_EXP 49
36236: PPUSH
36237: LD_STRING DA1-Glad-1a
36239: PPUSH
36240: CALL_OW 91
36244: GO 36588
36246: LD_EXP 46
36250: DOUBLE
36251: EQUAL
36252: IFTRUE 36256
36254: GO 36271
36256: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
36257: LD_EXP 46
36261: PPUSH
36262: LD_STRING DA1-Cyrus-1a
36264: PPUSH
36265: CALL_OW 91
36269: GO 36588
36271: LD_EXP 42
36275: DOUBLE
36276: EQUAL
36277: IFTRUE 36281
36279: GO 36296
36281: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
36282: LD_EXP 42
36286: PPUSH
36287: LD_STRING DA1-Huck-1a
36289: PPUSH
36290: CALL_OW 91
36294: GO 36588
36296: LD_EXP 56
36300: DOUBLE
36301: EQUAL
36302: IFTRUE 36306
36304: GO 36321
36306: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
36307: LD_EXP 56
36311: PPUSH
36312: LD_STRING DA1-Huck-1a
36314: PPUSH
36315: CALL_OW 91
36319: GO 36588
36321: LD_EXP 48
36325: DOUBLE
36326: EQUAL
36327: IFTRUE 36331
36329: GO 36346
36331: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
36332: LD_EXP 48
36336: PPUSH
36337: LD_STRING DA1-Brown-1a
36339: PPUSH
36340: CALL_OW 91
36344: GO 36588
36346: LD_EXP 52
36350: DOUBLE
36351: EQUAL
36352: IFTRUE 36356
36354: GO 36371
36356: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
36357: LD_EXP 52
36361: PPUSH
36362: LD_STRING DA1-Gary-1a
36364: PPUSH
36365: CALL_OW 91
36369: GO 36588
36371: LD_EXP 55
36375: DOUBLE
36376: EQUAL
36377: IFTRUE 36381
36379: GO 36406
36381: POP
// if JMMGirl = 3 then
36382: LD_EXP 7
36386: PUSH
36387: LD_INT 3
36389: EQUAL
36390: IFFALSE 36404
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
36392: LD_EXP 55
36396: PPUSH
36397: LD_STRING DA1-Con-1a
36399: PPUSH
36400: CALL_OW 91
36404: GO 36588
36406: LD_EXP 64
36410: DOUBLE
36411: EQUAL
36412: IFTRUE 36416
36414: GO 36431
36416: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
36417: LD_EXP 64
36421: PPUSH
36422: LD_STRING DA1-Kurt-1a
36424: PPUSH
36425: CALL_OW 91
36429: GO 36588
36431: LD_EXP 54
36435: DOUBLE
36436: EQUAL
36437: IFTRUE 36441
36439: GO 36456
36441: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
36442: LD_EXP 54
36446: PPUSH
36447: LD_STRING DA1-Yam-1a
36449: PPUSH
36450: CALL_OW 91
36454: GO 36588
36456: LD_EXP 53
36460: DOUBLE
36461: EQUAL
36462: IFTRUE 36466
36464: GO 36481
36466: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
36467: LD_EXP 53
36471: PPUSH
36472: LD_STRING DA1-Frank-1a
36474: PPUSH
36475: CALL_OW 91
36479: GO 36588
36481: POP
// begin join := rand ( 0 , 1 ) ;
36482: LD_ADDR_VAR 0 3
36486: PUSH
36487: LD_INT 0
36489: PPUSH
36490: LD_INT 1
36492: PPUSH
36493: CALL_OW 12
36497: ST_TO_ADDR
// if join then
36498: LD_VAR 0 3
36502: IFFALSE 36547
// begin if GetSex ( unit ) = sex_male then
36504: LD_VAR 0 1
36508: PPUSH
36509: CALL_OW 258
36513: PUSH
36514: LD_INT 1
36516: EQUAL
36517: IFFALSE 36533
// ForceSay ( unit , DA1-Sol1-1b ) else
36519: LD_VAR 0 1
36523: PPUSH
36524: LD_STRING DA1-Sol1-1b
36526: PPUSH
36527: CALL_OW 91
36531: GO 36545
// ForceSay ( unit , DA1-FSol1-1b ) ;
36533: LD_VAR 0 1
36537: PPUSH
36538: LD_STRING DA1-FSol1-1b
36540: PPUSH
36541: CALL_OW 91
// end else
36545: GO 36588
// begin if GetSex ( unit ) = sex_male then
36547: LD_VAR 0 1
36551: PPUSH
36552: CALL_OW 258
36556: PUSH
36557: LD_INT 1
36559: EQUAL
36560: IFFALSE 36576
// ForceSay ( unit , DA1-Sol1-1a ) else
36562: LD_VAR 0 1
36566: PPUSH
36567: LD_STRING DA1-Sol1-1a
36569: PPUSH
36570: CALL_OW 91
36574: GO 36588
// ForceSay ( unit , DA1-FSol1-1a ) ;
36576: LD_VAR 0 1
36580: PPUSH
36581: LD_STRING DA1-FSol1-1a
36583: PPUSH
36584: CALL_OW 91
// end ; end ; end ; if unit = JMM then
36588: LD_VAR 0 1
36592: PUSH
36593: LD_EXP 40
36597: EQUAL
36598: IFFALSE 36609
// begin YouLost ( JMMCaptured ) ;
36600: LD_STRING JMMCaptured
36602: PPUSH
36603: CALL_OW 104
// exit ;
36607: GO 36913
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi , DeltaDoctor ] or join then
36609: LD_VAR 0 1
36613: PUSH
36614: LD_EXP 44
36618: PUSH
36619: LD_EXP 47
36623: PUSH
36624: LD_EXP 45
36628: PUSH
36629: LD_EXP 42
36633: PUSH
36634: LD_EXP 56
36638: PUSH
36639: LD_EXP 48
36643: PUSH
36644: LD_EXP 54
36648: PUSH
36649: LD_EXP 58
36653: PUSH
36654: EMPTY
36655: LIST
36656: LIST
36657: LIST
36658: LIST
36659: LIST
36660: LIST
36661: LIST
36662: LIST
36663: IN
36664: PUSH
36665: LD_VAR 0 3
36669: OR
36670: IFFALSE 36769
// begin Say ( Roth , DA-Roth-3 ) ;
36672: LD_EXP 79
36676: PPUSH
36677: LD_STRING DA-Roth-3
36679: PPUSH
36680: CALL_OW 88
// SetSide ( unit , 7 ) ;
36684: LD_VAR 0 1
36688: PPUSH
36689: LD_INT 7
36691: PPUSH
36692: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
36696: LD_ADDR_EXP 102
36700: PUSH
36701: LD_EXP 102
36705: PPUSH
36706: LD_INT 1
36708: PPUSH
36709: LD_EXP 102
36713: PUSH
36714: LD_INT 1
36716: ARRAY
36717: PUSH
36718: LD_VAR 0 1
36722: ADD
36723: PPUSH
36724: CALL_OW 1
36728: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
36729: LD_INT 260
36731: PPUSH
36732: LD_INT 235
36734: PPUSH
36735: LD_INT 1
36737: PPUSH
36738: CALL_OW 331
// SetLives ( unit , 1000 ) ;
36742: LD_VAR 0 1
36746: PPUSH
36747: LD_INT 1000
36749: PPUSH
36750: CALL_OW 234
// DialogueOff ;
36754: CALL_OW 7
// ComFree ( unit ) ;
36758: LD_VAR 0 1
36762: PPUSH
36763: CALL_OW 139
// end else
36767: GO 36850
// begin Say ( Roth , DA-Roth-3a ) ;
36769: LD_EXP 79
36773: PPUSH
36774: LD_STRING DA-Roth-3a
36776: PPUSH
36777: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
36781: LD_ADDR_EXP 35
36785: PUSH
36786: LD_EXP 35
36790: PUSH
36791: LD_VAR 0 1
36795: ADD
36796: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
36797: LD_INT 260
36799: PPUSH
36800: LD_INT 235
36802: PPUSH
36803: LD_INT 1
36805: PPUSH
36806: CALL_OW 331
// SetLives ( unit , 1000 ) ;
36810: LD_VAR 0 1
36814: PPUSH
36815: LD_INT 1000
36817: PPUSH
36818: CALL_OW 234
// DialogueOff ;
36822: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
36826: LD_VAR 0 1
36830: PPUSH
36831: LD_INT 272
36833: PPUSH
36834: LD_INT 254
36836: PPUSH
36837: CALL_OW 111
// AddComHold ( unit ) ;
36841: LD_VAR 0 1
36845: PPUSH
36846: CALL_OW 200
// end ; if capturedUnit = 1 then
36850: LD_EXP 34
36854: PUSH
36855: LD_INT 1
36857: EQUAL
36858: IFFALSE 36913
// begin DialogueOn ;
36860: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
36864: LD_EXP 40
36868: PPUSH
36869: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
36873: LD_EXP 40
36877: PPUSH
36878: LD_STRING DAa-JMM-1
36880: PPUSH
36881: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
36885: LD_EXP 40
36889: PPUSH
36890: LD_STRING DAa-JMM-1a
36892: PPUSH
36893: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
36897: LD_EXP 40
36901: PPUSH
36902: LD_STRING DAa-JMM-1b
36904: PPUSH
36905: CALL_OW 88
// DialogueOff ;
36909: CALL_OW 7
// end ; end ;
36913: LD_VAR 0 2
36917: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
36918: LD_EXP 15
36922: PUSH
36923: LD_INT 13
36925: GREATEREQUAL
36926: PUSH
36927: LD_INT 22
36929: PUSH
36930: LD_INT 2
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PUSH
36937: LD_INT 21
36939: PUSH
36940: LD_INT 1
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: PUSH
36947: EMPTY
36948: LIST
36949: LIST
36950: PPUSH
36951: CALL_OW 69
36955: PUSH
36956: LD_INT 0
36958: EQUAL
36959: AND
36960: PUSH
36961: LD_INT 22
36963: PUSH
36964: LD_INT 2
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: PUSH
36971: LD_INT 33
36973: PUSH
36974: LD_INT 5
36976: PUSH
36977: EMPTY
36978: LIST
36979: LIST
36980: PUSH
36981: LD_INT 21
36983: PUSH
36984: LD_INT 2
36986: PUSH
36987: EMPTY
36988: LIST
36989: LIST
36990: PUSH
36991: LD_INT 50
36993: PUSH
36994: EMPTY
36995: LIST
36996: PUSH
36997: EMPTY
36998: LIST
36999: LIST
37000: LIST
37001: LIST
37002: PPUSH
37003: CALL_OW 69
37007: PUSH
37008: LD_INT 0
37010: EQUAL
37011: AND
37012: PUSH
37013: LD_EXP 21
37017: AND
37018: PUSH
37019: LD_EXP 22
37023: AND
37024: PUSH
37025: LD_EXP 23
37029: AND
37030: IFFALSE 37799
37032: GO 37034
37034: DISABLE
37035: LD_INT 0
37037: PPUSH
37038: PPUSH
37039: PPUSH
// begin wait ( 0 0$05 ) ;
37040: LD_INT 175
37042: PPUSH
37043: CALL_OW 67
// if Count ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 2 then
37047: LD_INT 22
37049: PUSH
37050: LD_INT 1
37052: PUSH
37053: EMPTY
37054: LIST
37055: LIST
37056: PUSH
37057: LD_INT 21
37059: PUSH
37060: LD_INT 1
37062: PUSH
37063: EMPTY
37064: LIST
37065: LIST
37066: PUSH
37067: LD_INT 23
37069: PUSH
37070: LD_INT 1
37072: PUSH
37073: EMPTY
37074: LIST
37075: LIST
37076: PUSH
37077: LD_INT 50
37079: PUSH
37080: EMPTY
37081: LIST
37082: PUSH
37083: EMPTY
37084: LIST
37085: LIST
37086: LIST
37087: LIST
37088: PPUSH
37089: CALL_OW 69
37093: PPUSH
37094: CALL 72482 0 1
37098: PUSH
37099: LD_INT 2
37101: LESS
37102: IFFALSE 37113
// begin YouLost ( LostVictory ) ;
37104: LD_STRING LostVictory
37106: PPUSH
37107: CALL_OW 104
// exit ;
37111: GO 37799
// end ; m1 := false ;
37113: LD_ADDR_VAR 0 1
37117: PUSH
37118: LD_INT 0
37120: ST_TO_ADDR
// m2 := false ;
37121: LD_ADDR_VAR 0 2
37125: PUSH
37126: LD_INT 0
37128: ST_TO_ADDR
// m3 := false ;
37129: LD_ADDR_VAR 0 3
37133: PUSH
37134: LD_INT 0
37136: ST_TO_ADDR
// if not bombExploded then
37137: LD_EXP 37
37141: NOT
37142: IFFALSE 37151
// SetAchievement ( ACH_SIBROCKET ) ;
37144: LD_STRING ACH_SIBROCKET
37146: PPUSH
37147: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
37151: LD_EXP 66
37155: PPUSH
37156: CALL_OW 255
37160: PUSH
37161: LD_INT 1
37163: EQUAL
37164: PUSH
37165: LD_EXP 66
37169: PPUSH
37170: CALL_OW 302
37174: AND
37175: IFFALSE 37191
// begin wait ( 3 ) ;
37177: LD_INT 3
37179: PPUSH
37180: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
37184: LD_STRING ACH_OPO
37186: PPUSH
37187: CALL_OW 543
// end ; if tick <= 120 120$00 then
37191: LD_OWVAR 1
37195: PUSH
37196: LD_INT 252000
37198: LESSEQUAL
37199: IFFALSE 37215
// begin wait ( 3 ) ;
37201: LD_INT 3
37203: PPUSH
37204: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
37208: LD_STRING ACH_ASPEED_15
37210: PPUSH
37211: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
37215: LD_EXP 40
37219: PPUSH
37220: CALL_OW 87
// music_class := 5 ;
37224: LD_ADDR_OWVAR 72
37228: PUSH
37229: LD_INT 5
37231: ST_TO_ADDR
// music_nat := 5 ;
37232: LD_ADDR_OWVAR 71
37236: PUSH
37237: LD_INT 5
37239: ST_TO_ADDR
// DialogueOn ;
37240: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
37244: LD_EXP 40
37248: PPUSH
37249: LD_STRING D20-JMM-1
37251: PPUSH
37252: CALL_OW 88
// if IsOK ( Joan ) then
37256: LD_EXP 41
37260: PPUSH
37261: CALL_OW 302
37265: IFFALSE 37279
// Say ( Joan , D20-Joan-1 ) ;
37267: LD_EXP 41
37271: PPUSH
37272: LD_STRING D20-Joan-1
37274: PPUSH
37275: CALL_OW 88
// if IsOk ( Lisa ) then
37279: LD_EXP 43
37283: PPUSH
37284: CALL_OW 302
37288: IFFALSE 37302
// Say ( Lisa , D20-Lisa-1 ) ;
37290: LD_EXP 43
37294: PPUSH
37295: LD_STRING D20-Lisa-1
37297: PPUSH
37298: CALL_OW 88
// if IsOk ( Donaldson ) then
37302: LD_EXP 44
37306: PPUSH
37307: CALL_OW 302
37311: IFFALSE 37325
// Say ( Donaldson , D20-Don-1 ) ;
37313: LD_EXP 44
37317: PPUSH
37318: LD_STRING D20-Don-1
37320: PPUSH
37321: CALL_OW 88
// if IsOK ( Cornel ) then
37325: LD_EXP 51
37329: PPUSH
37330: CALL_OW 302
37334: IFFALSE 37348
// Say ( Cornel , D20-Corn-1 ) ;
37336: LD_EXP 51
37340: PPUSH
37341: LD_STRING D20-Corn-1
37343: PPUSH
37344: CALL_OW 88
// if IsOk ( Denis ) then
37348: LD_EXP 47
37352: PPUSH
37353: CALL_OW 302
37357: IFFALSE 37371
// Say ( Denis , D20-Den-1 ) ;
37359: LD_EXP 47
37363: PPUSH
37364: LD_STRING D20-Den-1
37366: PPUSH
37367: CALL_OW 88
// if IsOk ( Bobby ) then
37371: LD_EXP 45
37375: PPUSH
37376: CALL_OW 302
37380: IFFALSE 37394
// Say ( Bobby , D20-Bobby-1 ) ;
37382: LD_EXP 45
37386: PPUSH
37387: LD_STRING D20-Bobby-1
37389: PPUSH
37390: CALL_OW 88
// if IsOk ( Gladstone ) then
37394: LD_EXP 49
37398: PPUSH
37399: CALL_OW 302
37403: IFFALSE 37417
// Say ( Gladstone , D20-Glad-1 ) ;
37405: LD_EXP 49
37409: PPUSH
37410: LD_STRING D20-Glad-1
37412: PPUSH
37413: CALL_OW 88
// if IsOk ( Cyrus ) then
37417: LD_EXP 46
37421: PPUSH
37422: CALL_OW 302
37426: IFFALSE 37440
// Say ( Cyrus , D20-Cyrus-1 ) ;
37428: LD_EXP 46
37432: PPUSH
37433: LD_STRING D20-Cyrus-1
37435: PPUSH
37436: CALL_OW 88
// if IsOk ( Stevens ) then
37440: LD_EXP 42
37444: PPUSH
37445: CALL_OW 302
37449: IFFALSE 37463
// Say ( Stevens , D20-Huck-1 ) ;
37451: LD_EXP 42
37455: PPUSH
37456: LD_STRING D20-Huck-1
37458: PPUSH
37459: CALL_OW 88
// if IsOk ( Brown ) then
37463: LD_EXP 48
37467: PPUSH
37468: CALL_OW 302
37472: IFFALSE 37486
// Say ( Brown , D20-Brown-1 ) ;
37474: LD_EXP 48
37478: PPUSH
37479: LD_STRING D20-Brown-1
37481: PPUSH
37482: CALL_OW 88
// if IsOk ( Gary ) then
37486: LD_EXP 52
37490: PPUSH
37491: CALL_OW 302
37495: IFFALSE 37509
// Say ( Gary , D20-Gary-1 ) ;
37497: LD_EXP 52
37501: PPUSH
37502: LD_STRING D20-Gary-1
37504: PPUSH
37505: CALL_OW 88
// if IsOk ( Connie ) then
37509: LD_EXP 55
37513: PPUSH
37514: CALL_OW 302
37518: IFFALSE 37532
// Say ( Connie , D20-Con-1 ) ;
37520: LD_EXP 55
37524: PPUSH
37525: LD_STRING D20-Con-1
37527: PPUSH
37528: CALL_OW 88
// if IsOk ( Kurt ) then
37532: LD_EXP 64
37536: PPUSH
37537: CALL_OW 302
37541: IFFALSE 37555
// Say ( Kurt , D20-Kurt-1 ) ;
37543: LD_EXP 64
37547: PPUSH
37548: LD_STRING D20-Kurt-1
37550: PPUSH
37551: CALL_OW 88
// if IsOk ( Kikuchi ) then
37555: LD_EXP 54
37559: PPUSH
37560: CALL_OW 302
37564: IFFALSE 37578
// Say ( Kikuchi , D20-Yam-1 ) ;
37566: LD_EXP 54
37570: PPUSH
37571: LD_STRING D20-Yam-1
37573: PPUSH
37574: CALL_OW 88
// if IsOk ( Frank ) then
37578: LD_EXP 53
37582: PPUSH
37583: CALL_OW 302
37587: IFFALSE 37601
// Say ( Frank , D20-Frank-1 ) ;
37589: LD_EXP 53
37593: PPUSH
37594: LD_STRING D20-Frank-1
37596: PPUSH
37597: CALL_OW 88
// DialogueOff ;
37601: CALL_OW 7
// if RothCaptured then
37605: LD_EXP 33
37609: IFFALSE 37631
// begin m1 := true ;
37611: LD_ADDR_VAR 0 1
37615: PUSH
37616: LD_INT 1
37618: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
37619: LD_STRING Roth
37621: PPUSH
37622: LD_INT 1
37624: PPUSH
37625: CALL_OW 101
// end else
37629: GO 37642
// AddMedal ( Roth , - 1 ) ;
37631: LD_STRING Roth
37633: PPUSH
37634: LD_INT 1
37636: NEG
37637: PPUSH
37638: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish or not behemothDone then
37642: LD_EXP 25
37646: NOT
37647: PUSH
37648: LD_EXP 27
37652: OR
37653: PUSH
37654: LD_EXP 28
37658: NOT
37659: OR
37660: IFFALSE 37682
// begin m2 := true ;
37662: LD_ADDR_VAR 0 2
37666: PUSH
37667: LD_INT 1
37669: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
37670: LD_STRING Project
37672: PPUSH
37673: LD_INT 1
37675: PPUSH
37676: CALL_OW 101
// end else
37680: GO 37693
// AddMedal ( Project , - 1 ) ;
37682: LD_STRING Project
37684: PPUSH
37685: LD_INT 1
37687: NEG
37688: PPUSH
37689: CALL_OW 101
// if lostCounter = 0 then
37693: LD_EXP 32
37697: PUSH
37698: LD_INT 0
37700: EQUAL
37701: IFFALSE 37723
// begin m3 := true ;
37703: LD_ADDR_VAR 0 3
37707: PUSH
37708: LD_INT 1
37710: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
37711: LD_STRING NoLosses
37713: PPUSH
37714: LD_INT 1
37716: PPUSH
37717: CALL_OW 101
// end else
37721: GO 37734
// AddMedal ( NoLosses , - 1 ) ;
37723: LD_STRING NoLosses
37725: PPUSH
37726: LD_INT 1
37728: NEG
37729: PPUSH
37730: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
37734: LD_VAR 0 1
37738: PUSH
37739: LD_VAR 0 2
37743: AND
37744: PUSH
37745: LD_VAR 0 3
37749: AND
37750: PUSH
37751: LD_OWVAR 67
37755: PUSH
37756: LD_INT 3
37758: GREATEREQUAL
37759: AND
37760: IFFALSE 37772
// SetAchievementEX ( ACH_AMER , 15 ) ;
37762: LD_STRING ACH_AMER
37764: PPUSH
37765: LD_INT 15
37767: PPUSH
37768: CALL_OW 564
// GiveMedals ( MAIN ) ;
37772: LD_STRING MAIN
37774: PPUSH
37775: CALL_OW 102
// music_class := 4 ;
37779: LD_ADDR_OWVAR 72
37783: PUSH
37784: LD_INT 4
37786: ST_TO_ADDR
// music_nat := 1 ;
37787: LD_ADDR_OWVAR 71
37791: PUSH
37792: LD_INT 1
37794: ST_TO_ADDR
// YouWin ;
37795: CALL_OW 103
// end ; end_of_file
37799: PPOPN 3
37801: END
// export function CustomEvent ( event ) ; begin
37802: LD_INT 0
37804: PPUSH
// end ;
37805: LD_VAR 0 2
37809: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
37810: LD_VAR 0 1
37814: PUSH
37815: LD_INT 1
37817: EQUAL
37818: PUSH
37819: LD_VAR 0 2
37823: PUSH
37824: LD_INT 4
37826: EQUAL
37827: AND
37828: PUSH
37829: LD_EXP 61
37833: PPUSH
37834: CALL_OW 300
37838: AND
37839: IFFALSE 37855
// begin wait ( 0 0$2 ) ;
37841: LD_INT 70
37843: PPUSH
37844: CALL_OW 67
// YouLost ( Dismissed ) ;
37848: LD_STRING Dismissed
37850: PPUSH
37851: CALL_OW 104
// end ; end ;
37855: PPOPN 2
37857: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
37858: LD_VAR 0 2
37862: PPUSH
37863: LD_VAR 0 3
37867: PPUSH
37868: LD_INT 18
37870: PPUSH
37871: CALL_OW 309
37875: IFFALSE 37884
// YouLost ( Motherlode3 ) ;
37877: LD_STRING Motherlode3
37879: PPUSH
37880: CALL_OW 104
// end ;
37884: PPOPN 3
37886: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
37887: LD_EXP 27
37891: NOT
37892: IFFALSE 37902
// behemothDone := true ;
37894: LD_ADDR_EXP 28
37898: PUSH
37899: LD_INT 1
37901: ST_TO_ADDR
// end ;
37902: PPOPN 1
37904: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
37905: LD_VAR 0 1
37909: PPUSH
37910: CALL_OW 255
37914: PUSH
37915: LD_INT 1
37917: EQUAL
37918: IFFALSE 37928
// bombExploded := true ;
37920: LD_ADDR_EXP 37
37924: PUSH
37925: LD_INT 1
37927: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
37928: LD_VAR 0 1
37932: PPUSH
37933: CALL_OW 255
37937: PUSH
37938: LD_INT 3
37940: EQUAL
37941: IFFALSE 37971
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
37943: LD_INT 2
37945: PPUSH
37946: LD_INT 23
37948: PUSH
37949: LD_INT 3
37951: PUSH
37952: LD_INT 3
37954: PUSH
37955: LD_INT 48
37957: PUSH
37958: EMPTY
37959: LIST
37960: LIST
37961: LIST
37962: LIST
37963: PUSH
37964: EMPTY
37965: LIST
37966: PPUSH
37967: CALL 63870 0 2
// if GetSide ( unit ) = 1 and GetSide ( Friend ) = 1 and IsOk ( Friend ) and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
37971: LD_VAR 0 1
37975: PPUSH
37976: CALL_OW 255
37980: PUSH
37981: LD_INT 1
37983: EQUAL
37984: PUSH
37985: LD_EXP 66
37989: PPUSH
37990: CALL_OW 255
37994: PUSH
37995: LD_INT 1
37997: EQUAL
37998: AND
37999: PUSH
38000: LD_EXP 66
38004: PPUSH
38005: CALL_OW 302
38009: AND
38010: PUSH
38011: LD_EXP 30
38015: AND
38016: PUSH
38017: LD_INT 22
38019: PUSH
38020: LD_INT 3
38022: PUSH
38023: EMPTY
38024: LIST
38025: LIST
38026: PUSH
38027: LD_INT 34
38029: PUSH
38030: LD_INT 48
38032: PUSH
38033: EMPTY
38034: LIST
38035: LIST
38036: PUSH
38037: EMPTY
38038: LIST
38039: LIST
38040: PPUSH
38041: CALL_OW 69
38045: AND
38046: PUSH
38047: LD_INT 22
38049: PUSH
38050: LD_INT 1
38052: PUSH
38053: EMPTY
38054: LIST
38055: LIST
38056: PUSH
38057: LD_INT 34
38059: PUSH
38060: LD_INT 8
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: EMPTY
38068: LIST
38069: LIST
38070: PPUSH
38071: CALL_OW 69
38075: NOT
38076: AND
38077: IFFALSE 38129
// begin wait ( 0 0$5 ) ;
38079: LD_INT 175
38081: PPUSH
38082: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
38086: LD_INT 22
38088: PUSH
38089: LD_INT 3
38091: PUSH
38092: EMPTY
38093: LIST
38094: LIST
38095: PUSH
38096: LD_INT 34
38098: PUSH
38099: LD_INT 48
38101: PUSH
38102: EMPTY
38103: LIST
38104: LIST
38105: PUSH
38106: EMPTY
38107: LIST
38108: LIST
38109: PPUSH
38110: CALL_OW 69
38114: PUSH
38115: LD_INT 1
38117: ARRAY
38118: PPUSH
38119: LD_INT 60
38121: PPUSH
38122: LD_INT 95
38124: PPUSH
38125: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
38129: LD_VAR 0 2
38133: PPUSH
38134: LD_VAR 0 3
38138: PPUSH
38139: LD_INT 18
38141: PPUSH
38142: CALL_OW 309
38146: PUSH
38147: LD_VAR 0 2
38151: PPUSH
38152: LD_VAR 0 3
38156: PPUSH
38157: LD_INT 18
38159: PPUSH
38160: CALL 111910 0 3
38164: OR
38165: IFFALSE 38212
// begin if GetSide ( unit ) = 1 then
38167: LD_VAR 0 1
38171: PPUSH
38172: CALL_OW 255
38176: PUSH
38177: LD_INT 1
38179: EQUAL
38180: IFFALSE 38198
// begin wait ( 0 0$6 ) ;
38182: LD_INT 210
38184: PPUSH
38185: CALL_OW 67
// YouLost ( Motherlode2 ) ;
38189: LD_STRING Motherlode2
38191: PPUSH
38192: CALL_OW 104
// end else
38196: GO 38212
// begin wait ( 0 0$6 ) ;
38198: LD_INT 210
38200: PPUSH
38201: CALL_OW 67
// YouLost ( Motherlode1 ) ;
38205: LD_STRING Motherlode1
38207: PPUSH
38208: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
38212: LD_VAR 0 1
38216: PPUSH
38217: CALL_OW 255
38221: PUSH
38222: LD_INT 3
38224: EQUAL
38225: IFFALSE 38246
// begin wait ( 0 0$5 ) ;
38227: LD_INT 175
38229: PPUSH
38230: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
38234: LD_EXP 68
38238: PPUSH
38239: LD_STRING D18-Pla-1
38241: PPUSH
38242: CALL_OW 94
// end ; end ;
38246: PPOPN 3
38248: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
38249: LD_VAR 0 1
38253: PPUSH
38254: CALL 129128 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
38258: LD_VAR 0 1
38262: PUSH
38263: LD_INT 22
38265: PUSH
38266: LD_INT 1
38268: PUSH
38269: EMPTY
38270: LIST
38271: LIST
38272: PUSH
38273: LD_INT 21
38275: PUSH
38276: LD_INT 1
38278: PUSH
38279: EMPTY
38280: LIST
38281: LIST
38282: PUSH
38283: LD_INT 23
38285: PUSH
38286: LD_INT 1
38288: PUSH
38289: EMPTY
38290: LIST
38291: LIST
38292: PUSH
38293: EMPTY
38294: LIST
38295: LIST
38296: LIST
38297: PPUSH
38298: CALL_OW 69
38302: IN
38303: IFFALSE 38319
// lostCounter := lostCounter + 1 ;
38305: LD_ADDR_EXP 32
38309: PUSH
38310: LD_EXP 32
38314: PUSH
38315: LD_INT 1
38317: PLUS
38318: ST_TO_ADDR
// if un in behemothBuilders then
38319: LD_VAR 0 1
38323: PUSH
38324: LD_EXP 77
38328: IN
38329: IFFALSE 38349
// begin behemothBuilders := behemothBuilders diff un ;
38331: LD_ADDR_EXP 77
38335: PUSH
38336: LD_EXP 77
38340: PUSH
38341: LD_VAR 0 1
38345: DIFF
38346: ST_TO_ADDR
// exit ;
38347: GO 38379
// end ; if un = JMM then
38349: LD_VAR 0 1
38353: PUSH
38354: LD_EXP 40
38358: EQUAL
38359: IFFALSE 38370
// begin YouLost ( JMM ) ;
38361: LD_STRING JMM
38363: PPUSH
38364: CALL_OW 104
// exit ;
38368: GO 38379
// end ; MCE_UnitDestroyed ( un ) ;
38370: LD_VAR 0 1
38374: PPUSH
38375: CALL 67312 0 1
// end ;
38379: PPOPN 1
38381: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
38382: LD_VAR 0 1
38386: PPUSH
38387: LD_VAR 0 2
38391: PPUSH
38392: CALL 69644 0 2
// end ;
38396: PPOPN 2
38398: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
38399: LD_VAR 0 1
38403: PPUSH
38404: CALL 68712 0 1
// end ;
38408: PPOPN 1
38410: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
38411: LD_VAR 0 1
38415: PUSH
38416: LD_INT 22
38418: PUSH
38419: LD_INT 8
38421: PUSH
38422: EMPTY
38423: LIST
38424: LIST
38425: PUSH
38426: LD_INT 30
38428: PUSH
38429: LD_INT 2
38431: PUSH
38432: EMPTY
38433: LIST
38434: LIST
38435: PUSH
38436: LD_INT 23
38438: PUSH
38439: LD_INT 3
38441: PUSH
38442: EMPTY
38443: LIST
38444: LIST
38445: PUSH
38446: EMPTY
38447: LIST
38448: LIST
38449: LIST
38450: PPUSH
38451: CALL_OW 69
38455: IN
38456: IFFALSE 38483
// begin ComUpgrade ( building ) ;
38458: LD_VAR 0 1
38462: PPUSH
38463: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
38467: LD_EXP 65
38471: PPUSH
38472: LD_VAR 0 1
38476: PPUSH
38477: CALL 78580 0 2
// exit ;
38481: GO 38492
// end ; MCE_BuildingComplete ( building ) ;
38483: LD_VAR 0 1
38487: PPUSH
38488: CALL 68953 0 1
// end ;
38492: PPOPN 1
38494: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
38495: LD_VAR 0 1
38499: PPUSH
38500: LD_VAR 0 2
38504: PPUSH
38505: CALL 67008 0 2
// end ;
38509: PPOPN 2
38511: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
38512: LD_VAR 0 1
38516: PPUSH
38517: LD_VAR 0 2
38521: PPUSH
38522: LD_VAR 0 3
38526: PPUSH
38527: LD_VAR 0 4
38531: PPUSH
38532: LD_VAR 0 5
38536: PPUSH
38537: CALL 66628 0 5
// end ;
38541: PPOPN 5
38543: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
38544: LD_VAR 0 1
38548: PPUSH
38549: CALL_OW 255
38553: PUSH
38554: LD_INT 1
38556: EQUAL
38557: IFFALSE 38574
// amConstructCounter := Inc ( amConstructCounter ) ;
38559: LD_ADDR_EXP 39
38563: PUSH
38564: LD_EXP 39
38568: PPUSH
38569: CALL 109452 0 1
38573: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
38574: LD_VAR 0 1
38578: PPUSH
38579: LD_VAR 0 2
38583: PPUSH
38584: CALL 129186 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
38588: LD_VAR 0 1
38592: PPUSH
38593: LD_VAR 0 2
38597: PPUSH
38598: CALL 66181 0 2
// end ;
38602: PPOPN 2
38604: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
38605: LD_VAR 0 1
38609: PPUSH
38610: LD_VAR 0 2
38614: PPUSH
38615: LD_VAR 0 3
38619: PPUSH
38620: LD_VAR 0 4
38624: PPUSH
38625: CALL 66019 0 4
// end ;
38629: PPOPN 4
38631: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
38632: LD_VAR 0 1
38636: PPUSH
38637: LD_VAR 0 2
38641: PPUSH
38642: LD_VAR 0 3
38646: PPUSH
38647: CALL 65794 0 3
// end ;
38651: PPOPN 3
38653: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
38654: LD_VAR 0 1
38658: PPUSH
38659: LD_VAR 0 2
38663: PPUSH
38664: CALL 65679 0 2
// end ;
38668: PPOPN 2
38670: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
38671: LD_VAR 0 1
38675: PPUSH
38676: LD_VAR 0 2
38680: PPUSH
38681: CALL 69939 0 2
// end ;
38685: PPOPN 2
38687: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
38688: LD_VAR 0 1
38692: PUSH
38693: LD_INT 460
38695: EQUAL
38696: IFFALSE 38718
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
38698: LD_VAR 0 2
38702: PPUSH
38703: LD_INT 227
38705: PPUSH
38706: LD_INT 136
38708: PPUSH
38709: CALL_OW 428
38713: PPUSH
38714: CALL_OW 120
// end ;
38718: PPOPN 2
38720: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
38721: LD_VAR 0 1
38725: PPUSH
38726: CALL_OW 255
38730: PUSH
38731: LD_INT 4
38733: EQUAL
38734: PUSH
38735: LD_VAR 0 1
38739: PUSH
38740: LD_EXP 18
38744: PUSH
38745: LD_INT 1
38747: ARRAY
38748: IN
38749: AND
38750: PUSH
38751: LD_EXP 19
38755: AND
38756: IFFALSE 38775
// begin ComMoveXY ( driver , 61 , 93 ) ;
38758: LD_VAR 0 1
38762: PPUSH
38763: LD_INT 61
38765: PPUSH
38766: LD_INT 93
38768: PPUSH
38769: CALL_OW 111
// exit ;
38773: GO 38844
// end ; if GetSide ( driver ) = 3 and GetTag ( driver ) = 105 then
38775: LD_VAR 0 1
38779: PPUSH
38780: CALL_OW 255
38784: PUSH
38785: LD_INT 3
38787: EQUAL
38788: PUSH
38789: LD_VAR 0 1
38793: PPUSH
38794: CALL_OW 110
38798: PUSH
38799: LD_INT 105
38801: EQUAL
38802: AND
38803: IFFALSE 38820
// begin ComMoveXY ( driver , 187 , 92 ) ;
38805: LD_VAR 0 1
38809: PPUSH
38810: LD_INT 187
38812: PPUSH
38813: LD_INT 92
38815: PPUSH
38816: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
38820: LD_VAR 0 1
38824: PPUSH
38825: LD_VAR 0 2
38829: PPUSH
38830: LD_VAR 0 3
38834: PPUSH
38835: LD_VAR 0 4
38839: PPUSH
38840: CALL 70155 0 4
// end ;
38844: PPOPN 4
38846: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
38847: LD_VAR 0 1
38851: PPUSH
38852: LD_VAR 0 2
38856: PPUSH
38857: CALL 65488 0 2
// end ;
38861: PPOPN 2
38863: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
38864: LD_VAR 0 1
38868: PPUSH
38869: CALL 129170 0 1
// end ; end_of_file
38873: PPOPN 1
38875: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
38876: LD_EXP 15
38880: PUSH
38881: LD_INT 2
38883: EQUAL
38884: IFFALSE 39401
38886: GO 38888
38888: DISABLE
38889: LD_INT 0
38891: PPUSH
38892: PPUSH
// begin time := 0 0$35 ;
38893: LD_ADDR_VAR 0 2
38897: PUSH
38898: LD_INT 1225
38900: ST_TO_ADDR
// repeat wait ( time ) ;
38901: LD_VAR 0 2
38905: PPUSH
38906: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
38910: LD_INT 1
38912: PPUSH
38913: LD_INT 5
38915: PPUSH
38916: CALL_OW 12
38920: PPUSH
38921: LD_INT 106
38923: PPUSH
38924: LD_INT 150
38926: PPUSH
38927: LD_INT 19
38929: PPUSH
38930: LD_INT 1
38932: PPUSH
38933: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
38937: LD_INT 455
38939: PPUSH
38940: LD_INT 770
38942: PPUSH
38943: CALL_OW 12
38947: PPUSH
38948: CALL_OW 67
// if Prob ( 50 ) then
38952: LD_INT 50
38954: PPUSH
38955: CALL_OW 13
38959: IFFALSE 38988
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
38961: LD_INT 1
38963: PPUSH
38964: LD_INT 5
38966: PPUSH
38967: CALL_OW 12
38971: PPUSH
38972: LD_INT 62
38974: PPUSH
38975: LD_INT 108
38977: PPUSH
38978: LD_INT 10
38980: PPUSH
38981: LD_INT 1
38983: PPUSH
38984: CALL_OW 56
// until missionStage > 4 ;
38988: LD_EXP 15
38992: PUSH
38993: LD_INT 4
38995: GREATER
38996: IFFALSE 38901
// repeat wait ( 0 0$1 ) ;
38998: LD_INT 35
39000: PPUSH
39001: CALL_OW 67
// until missionStage = 6 ;
39005: LD_EXP 15
39009: PUSH
39010: LD_INT 6
39012: EQUAL
39013: IFFALSE 38998
// time := 0 0$20 ;
39015: LD_ADDR_VAR 0 2
39019: PUSH
39020: LD_INT 700
39022: ST_TO_ADDR
// repeat wait ( time ) ;
39023: LD_VAR 0 2
39027: PPUSH
39028: CALL_OW 67
// if Prob ( 90 ) then
39032: LD_INT 90
39034: PPUSH
39035: CALL_OW 13
39039: IFFALSE 39082
// begin time := time + 0 0$2 ;
39041: LD_ADDR_VAR 0 2
39045: PUSH
39046: LD_VAR 0 2
39050: PUSH
39051: LD_INT 70
39053: PLUS
39054: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
39055: LD_INT 1
39057: PPUSH
39058: LD_INT 5
39060: PPUSH
39061: CALL_OW 12
39065: PPUSH
39066: LD_INT 106
39068: PPUSH
39069: LD_INT 89
39071: PPUSH
39072: LD_INT 45
39074: PPUSH
39075: LD_INT 1
39077: PPUSH
39078: CALL_OW 56
// end ; if Prob ( 45 ) then
39082: LD_INT 45
39084: PPUSH
39085: CALL_OW 13
39089: IFFALSE 39145
// begin for i := 1 to 4 do
39091: LD_ADDR_VAR 0 1
39095: PUSH
39096: DOUBLE
39097: LD_INT 1
39099: DEC
39100: ST_TO_ADDR
39101: LD_INT 4
39103: PUSH
39104: FOR_TO
39105: IFFALSE 39143
// begin wait ( 0 0$5 ) ;
39107: LD_INT 175
39109: PPUSH
39110: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
39114: LD_INT 1
39116: PPUSH
39117: LD_INT 5
39119: PPUSH
39120: CALL_OW 12
39124: PPUSH
39125: LD_INT 113
39127: PPUSH
39128: LD_INT 117
39130: PPUSH
39131: LD_INT 25
39133: PPUSH
39134: LD_INT 1
39136: PPUSH
39137: CALL_OW 56
// end ;
39141: GO 39104
39143: POP
39144: POP
// end ; if Prob ( 40 ) then
39145: LD_INT 40
39147: PPUSH
39148: CALL_OW 13
39152: IFFALSE 39198
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
39154: LD_INT 385
39156: PPUSH
39157: LD_INT 945
39159: PPUSH
39160: CALL_OW 12
39164: PPUSH
39165: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
39169: LD_INT 1
39171: PPUSH
39172: LD_INT 5
39174: PPUSH
39175: CALL_OW 12
39179: PPUSH
39180: LD_INT 21
39182: PPUSH
39183: LD_INT 26
39185: PPUSH
39186: LD_INT 12
39188: PPUSH
39189: LD_INT 1
39191: PPUSH
39192: CALL_OW 56
// end else
39196: GO 39234
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
39198: LD_INT 700
39200: PPUSH
39201: LD_INT 1225
39203: PPUSH
39204: CALL_OW 12
39208: PPUSH
39209: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
39213: LD_INT 1
39215: PPUSH
39216: LD_INT 5
39218: PPUSH
39219: CALL_OW 12
39223: PPUSH
39224: LD_INT 16
39226: PPUSH
39227: LD_INT 1
39229: PPUSH
39230: CALL_OW 55
// end ; if Prob ( 50 ) then
39234: LD_INT 50
39236: PPUSH
39237: CALL_OW 13
39241: IFFALSE 39287
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
39243: LD_INT 700
39245: PPUSH
39246: LD_INT 1050
39248: PPUSH
39249: CALL_OW 12
39253: PPUSH
39254: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
39258: LD_INT 1
39260: PPUSH
39261: LD_INT 5
39263: PPUSH
39264: CALL_OW 12
39268: PPUSH
39269: LD_INT 168
39271: PPUSH
39272: LD_INT 168
39274: PPUSH
39275: LD_INT 16
39277: PPUSH
39278: LD_INT 1
39280: PPUSH
39281: CALL_OW 56
// end else
39285: GO 39323
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
39287: LD_INT 350
39289: PPUSH
39290: LD_INT 525
39292: PPUSH
39293: CALL_OW 12
39297: PPUSH
39298: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
39302: LD_INT 1
39304: PPUSH
39305: LD_INT 5
39307: PPUSH
39308: CALL_OW 12
39312: PPUSH
39313: LD_INT 15
39315: PPUSH
39316: LD_INT 1
39318: PPUSH
39319: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
39323: LD_INT 175
39325: PPUSH
39326: LD_INT 315
39328: PPUSH
39329: CALL_OW 12
39333: PPUSH
39334: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
39338: LD_INT 1
39340: PPUSH
39341: LD_INT 5
39343: PPUSH
39344: CALL_OW 12
39348: PPUSH
39349: LD_INT 103
39351: PPUSH
39352: LD_INT 140
39354: PPUSH
39355: LD_INT 20
39357: PPUSH
39358: LD_INT 1
39360: PPUSH
39361: CALL_OW 56
// time := time + 0 0$2 ;
39365: LD_ADDR_VAR 0 2
39369: PUSH
39370: LD_VAR 0 2
39374: PUSH
39375: LD_INT 70
39377: PLUS
39378: ST_TO_ADDR
// if time > 1 1$20 then
39379: LD_VAR 0 2
39383: PUSH
39384: LD_INT 2800
39386: GREATER
39387: IFFALSE 39397
// time := 0 0$30 ;
39389: LD_ADDR_VAR 0 2
39393: PUSH
39394: LD_INT 1050
39396: ST_TO_ADDR
// until false ;
39397: LD_INT 0
39399: IFFALSE 39023
// end ; end_of_file
39401: PPOPN 2
39403: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
39404: LD_EXP 13
39408: PUSH
39409: LD_EXP 15
39413: PUSH
39414: LD_INT 6
39416: GREATEREQUAL
39417: AND
39418: IFFALSE 39455
39420: GO 39422
39422: DISABLE
// begin enable ;
39423: ENABLE
// missionTime := missionTime + 0 0$1 ;
39424: LD_ADDR_EXP 14
39428: PUSH
39429: LD_EXP 14
39433: PUSH
39434: LD_INT 35
39436: PLUS
39437: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
39438: LD_ADDR_OWVAR 47
39442: PUSH
39443: LD_STRING #Am15-1
39445: PUSH
39446: LD_EXP 14
39450: PUSH
39451: EMPTY
39452: LIST
39453: LIST
39454: ST_TO_ADDR
// end ; end_of_file
39455: END
// export function InitNature ; begin
39456: LD_INT 0
39458: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
39459: LD_INT 3
39461: PPUSH
39462: LD_INT 3
39464: PPUSH
39465: LD_INT 2
39467: PPUSH
39468: LD_INT 1
39470: PPUSH
39471: LD_INT 1
39473: PPUSH
39474: LD_INT 0
39476: PPUSH
39477: LD_INT 0
39479: PPUSH
39480: LD_INT 20
39482: PPUSH
39483: LD_INT 0
39485: PPUSH
39486: CALL 104768 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
39490: LD_INT 2
39492: PPUSH
39493: LD_INT 1
39495: PPUSH
39496: LD_INT 1
39498: PPUSH
39499: LD_INT 1
39501: PPUSH
39502: LD_INT 1
39504: PPUSH
39505: LD_INT 0
39507: PPUSH
39508: LD_INT 0
39510: PPUSH
39511: LD_INT 21
39513: PPUSH
39514: LD_INT 0
39516: PPUSH
39517: CALL 104768 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
39521: LD_INT 4
39523: PPUSH
39524: LD_INT 1
39526: PPUSH
39527: LD_INT 2
39529: PPUSH
39530: LD_INT 4
39532: PPUSH
39533: LD_INT 2
39535: PPUSH
39536: LD_INT 1
39538: PPUSH
39539: LD_INT 0
39541: PPUSH
39542: LD_INT 22
39544: PPUSH
39545: LD_INT 0
39547: PPUSH
39548: CALL 104768 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
39552: LD_INT 0
39554: PPUSH
39555: LD_INT 0
39557: PPUSH
39558: LD_INT 0
39560: PPUSH
39561: LD_INT 0
39563: PPUSH
39564: LD_INT 0
39566: PPUSH
39567: LD_INT 0
39569: PPUSH
39570: LD_INT 9
39572: PPUSH
39573: LD_INT 0
39575: PPUSH
39576: LD_INT 23
39578: PPUSH
39579: CALL 104768 0 9
// end ; end_of_file
39583: LD_VAR 0 1
39587: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
39588: LD_INT 0
39590: PPUSH
39591: PPUSH
// skirmish := false ;
39592: LD_ADDR_EXP 100
39596: PUSH
39597: LD_INT 0
39599: ST_TO_ADDR
// debug_mc := false ;
39600: LD_ADDR_EXP 101
39604: PUSH
39605: LD_INT 0
39607: ST_TO_ADDR
// mc_bases := [ ] ;
39608: LD_ADDR_EXP 102
39612: PUSH
39613: EMPTY
39614: ST_TO_ADDR
// mc_sides := [ ] ;
39615: LD_ADDR_EXP 128
39619: PUSH
39620: EMPTY
39621: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
39622: LD_ADDR_EXP 103
39626: PUSH
39627: EMPTY
39628: ST_TO_ADDR
// mc_building_repairs := [ ] ;
39629: LD_ADDR_EXP 104
39633: PUSH
39634: EMPTY
39635: ST_TO_ADDR
// mc_need_heal := [ ] ;
39636: LD_ADDR_EXP 105
39640: PUSH
39641: EMPTY
39642: ST_TO_ADDR
// mc_healers := [ ] ;
39643: LD_ADDR_EXP 106
39647: PUSH
39648: EMPTY
39649: ST_TO_ADDR
// mc_build_list := [ ] ;
39650: LD_ADDR_EXP 107
39654: PUSH
39655: EMPTY
39656: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
39657: LD_ADDR_EXP 134
39661: PUSH
39662: EMPTY
39663: ST_TO_ADDR
// mc_builders := [ ] ;
39664: LD_ADDR_EXP 108
39668: PUSH
39669: EMPTY
39670: ST_TO_ADDR
// mc_construct_list := [ ] ;
39671: LD_ADDR_EXP 109
39675: PUSH
39676: EMPTY
39677: ST_TO_ADDR
// mc_turret_list := [ ] ;
39678: LD_ADDR_EXP 110
39682: PUSH
39683: EMPTY
39684: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
39685: LD_ADDR_EXP 111
39689: PUSH
39690: EMPTY
39691: ST_TO_ADDR
// mc_miners := [ ] ;
39692: LD_ADDR_EXP 116
39696: PUSH
39697: EMPTY
39698: ST_TO_ADDR
// mc_mines := [ ] ;
39699: LD_ADDR_EXP 115
39703: PUSH
39704: EMPTY
39705: ST_TO_ADDR
// mc_minefields := [ ] ;
39706: LD_ADDR_EXP 117
39710: PUSH
39711: EMPTY
39712: ST_TO_ADDR
// mc_crates := [ ] ;
39713: LD_ADDR_EXP 118
39717: PUSH
39718: EMPTY
39719: ST_TO_ADDR
// mc_crates_collector := [ ] ;
39720: LD_ADDR_EXP 119
39724: PUSH
39725: EMPTY
39726: ST_TO_ADDR
// mc_crates_area := [ ] ;
39727: LD_ADDR_EXP 120
39731: PUSH
39732: EMPTY
39733: ST_TO_ADDR
// mc_vehicles := [ ] ;
39734: LD_ADDR_EXP 121
39738: PUSH
39739: EMPTY
39740: ST_TO_ADDR
// mc_attack := [ ] ;
39741: LD_ADDR_EXP 122
39745: PUSH
39746: EMPTY
39747: ST_TO_ADDR
// mc_produce := [ ] ;
39748: LD_ADDR_EXP 123
39752: PUSH
39753: EMPTY
39754: ST_TO_ADDR
// mc_defender := [ ] ;
39755: LD_ADDR_EXP 124
39759: PUSH
39760: EMPTY
39761: ST_TO_ADDR
// mc_parking := [ ] ;
39762: LD_ADDR_EXP 126
39766: PUSH
39767: EMPTY
39768: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
39769: LD_ADDR_EXP 112
39773: PUSH
39774: EMPTY
39775: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
39776: LD_ADDR_EXP 114
39780: PUSH
39781: EMPTY
39782: ST_TO_ADDR
// mc_scan := [ ] ;
39783: LD_ADDR_EXP 125
39787: PUSH
39788: EMPTY
39789: ST_TO_ADDR
// mc_scan_area := [ ] ;
39790: LD_ADDR_EXP 127
39794: PUSH
39795: EMPTY
39796: ST_TO_ADDR
// mc_tech := [ ] ;
39797: LD_ADDR_EXP 129
39801: PUSH
39802: EMPTY
39803: ST_TO_ADDR
// mc_class := [ ] ;
39804: LD_ADDR_EXP 143
39808: PUSH
39809: EMPTY
39810: ST_TO_ADDR
// mc_class_case_use := [ ] ;
39811: LD_ADDR_EXP 144
39815: PUSH
39816: EMPTY
39817: ST_TO_ADDR
// mc_is_defending := [ ] ;
39818: LD_ADDR_EXP 145
39822: PUSH
39823: EMPTY
39824: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
39825: LD_ADDR_EXP 136
39829: PUSH
39830: EMPTY
39831: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
39832: LD_ADDR_EXP 146
39836: PUSH
39837: LD_INT 0
39839: ST_TO_ADDR
// end ;
39840: LD_VAR 0 1
39844: RET
// export function MC_Kill ( base ) ; begin
39845: LD_INT 0
39847: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
39848: LD_ADDR_EXP 102
39852: PUSH
39853: LD_EXP 102
39857: PPUSH
39858: LD_VAR 0 1
39862: PPUSH
39863: EMPTY
39864: PPUSH
39865: CALL_OW 1
39869: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
39870: LD_ADDR_EXP 103
39874: PUSH
39875: LD_EXP 103
39879: PPUSH
39880: LD_VAR 0 1
39884: PPUSH
39885: EMPTY
39886: PPUSH
39887: CALL_OW 1
39891: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
39892: LD_ADDR_EXP 104
39896: PUSH
39897: LD_EXP 104
39901: PPUSH
39902: LD_VAR 0 1
39906: PPUSH
39907: EMPTY
39908: PPUSH
39909: CALL_OW 1
39913: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
39914: LD_ADDR_EXP 105
39918: PUSH
39919: LD_EXP 105
39923: PPUSH
39924: LD_VAR 0 1
39928: PPUSH
39929: EMPTY
39930: PPUSH
39931: CALL_OW 1
39935: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
39936: LD_ADDR_EXP 106
39940: PUSH
39941: LD_EXP 106
39945: PPUSH
39946: LD_VAR 0 1
39950: PPUSH
39951: EMPTY
39952: PPUSH
39953: CALL_OW 1
39957: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
39958: LD_ADDR_EXP 107
39962: PUSH
39963: LD_EXP 107
39967: PPUSH
39968: LD_VAR 0 1
39972: PPUSH
39973: EMPTY
39974: PPUSH
39975: CALL_OW 1
39979: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
39980: LD_ADDR_EXP 108
39984: PUSH
39985: LD_EXP 108
39989: PPUSH
39990: LD_VAR 0 1
39994: PPUSH
39995: EMPTY
39996: PPUSH
39997: CALL_OW 1
40001: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
40002: LD_ADDR_EXP 109
40006: PUSH
40007: LD_EXP 109
40011: PPUSH
40012: LD_VAR 0 1
40016: PPUSH
40017: EMPTY
40018: PPUSH
40019: CALL_OW 1
40023: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
40024: LD_ADDR_EXP 110
40028: PUSH
40029: LD_EXP 110
40033: PPUSH
40034: LD_VAR 0 1
40038: PPUSH
40039: EMPTY
40040: PPUSH
40041: CALL_OW 1
40045: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
40046: LD_ADDR_EXP 111
40050: PUSH
40051: LD_EXP 111
40055: PPUSH
40056: LD_VAR 0 1
40060: PPUSH
40061: EMPTY
40062: PPUSH
40063: CALL_OW 1
40067: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
40068: LD_ADDR_EXP 112
40072: PUSH
40073: LD_EXP 112
40077: PPUSH
40078: LD_VAR 0 1
40082: PPUSH
40083: EMPTY
40084: PPUSH
40085: CALL_OW 1
40089: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
40090: LD_ADDR_EXP 113
40094: PUSH
40095: LD_EXP 113
40099: PPUSH
40100: LD_VAR 0 1
40104: PPUSH
40105: LD_INT 0
40107: PPUSH
40108: CALL_OW 1
40112: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
40113: LD_ADDR_EXP 114
40117: PUSH
40118: LD_EXP 114
40122: PPUSH
40123: LD_VAR 0 1
40127: PPUSH
40128: EMPTY
40129: PPUSH
40130: CALL_OW 1
40134: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
40135: LD_ADDR_EXP 115
40139: PUSH
40140: LD_EXP 115
40144: PPUSH
40145: LD_VAR 0 1
40149: PPUSH
40150: EMPTY
40151: PPUSH
40152: CALL_OW 1
40156: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
40157: LD_ADDR_EXP 116
40161: PUSH
40162: LD_EXP 116
40166: PPUSH
40167: LD_VAR 0 1
40171: PPUSH
40172: EMPTY
40173: PPUSH
40174: CALL_OW 1
40178: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
40179: LD_ADDR_EXP 117
40183: PUSH
40184: LD_EXP 117
40188: PPUSH
40189: LD_VAR 0 1
40193: PPUSH
40194: EMPTY
40195: PPUSH
40196: CALL_OW 1
40200: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
40201: LD_ADDR_EXP 118
40205: PUSH
40206: LD_EXP 118
40210: PPUSH
40211: LD_VAR 0 1
40215: PPUSH
40216: EMPTY
40217: PPUSH
40218: CALL_OW 1
40222: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
40223: LD_ADDR_EXP 119
40227: PUSH
40228: LD_EXP 119
40232: PPUSH
40233: LD_VAR 0 1
40237: PPUSH
40238: EMPTY
40239: PPUSH
40240: CALL_OW 1
40244: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
40245: LD_ADDR_EXP 120
40249: PUSH
40250: LD_EXP 120
40254: PPUSH
40255: LD_VAR 0 1
40259: PPUSH
40260: EMPTY
40261: PPUSH
40262: CALL_OW 1
40266: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
40267: LD_ADDR_EXP 121
40271: PUSH
40272: LD_EXP 121
40276: PPUSH
40277: LD_VAR 0 1
40281: PPUSH
40282: EMPTY
40283: PPUSH
40284: CALL_OW 1
40288: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
40289: LD_ADDR_EXP 122
40293: PUSH
40294: LD_EXP 122
40298: PPUSH
40299: LD_VAR 0 1
40303: PPUSH
40304: EMPTY
40305: PPUSH
40306: CALL_OW 1
40310: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
40311: LD_ADDR_EXP 123
40315: PUSH
40316: LD_EXP 123
40320: PPUSH
40321: LD_VAR 0 1
40325: PPUSH
40326: EMPTY
40327: PPUSH
40328: CALL_OW 1
40332: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
40333: LD_ADDR_EXP 124
40337: PUSH
40338: LD_EXP 124
40342: PPUSH
40343: LD_VAR 0 1
40347: PPUSH
40348: EMPTY
40349: PPUSH
40350: CALL_OW 1
40354: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
40355: LD_ADDR_EXP 125
40359: PUSH
40360: LD_EXP 125
40364: PPUSH
40365: LD_VAR 0 1
40369: PPUSH
40370: EMPTY
40371: PPUSH
40372: CALL_OW 1
40376: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
40377: LD_ADDR_EXP 126
40381: PUSH
40382: LD_EXP 126
40386: PPUSH
40387: LD_VAR 0 1
40391: PPUSH
40392: EMPTY
40393: PPUSH
40394: CALL_OW 1
40398: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
40399: LD_ADDR_EXP 127
40403: PUSH
40404: LD_EXP 127
40408: PPUSH
40409: LD_VAR 0 1
40413: PPUSH
40414: EMPTY
40415: PPUSH
40416: CALL_OW 1
40420: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
40421: LD_ADDR_EXP 129
40425: PUSH
40426: LD_EXP 129
40430: PPUSH
40431: LD_VAR 0 1
40435: PPUSH
40436: EMPTY
40437: PPUSH
40438: CALL_OW 1
40442: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
40443: LD_ADDR_EXP 131
40447: PUSH
40448: LD_EXP 131
40452: PPUSH
40453: LD_VAR 0 1
40457: PPUSH
40458: EMPTY
40459: PPUSH
40460: CALL_OW 1
40464: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
40465: LD_ADDR_EXP 132
40469: PUSH
40470: LD_EXP 132
40474: PPUSH
40475: LD_VAR 0 1
40479: PPUSH
40480: EMPTY
40481: PPUSH
40482: CALL_OW 1
40486: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
40487: LD_ADDR_EXP 133
40491: PUSH
40492: LD_EXP 133
40496: PPUSH
40497: LD_VAR 0 1
40501: PPUSH
40502: EMPTY
40503: PPUSH
40504: CALL_OW 1
40508: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
40509: LD_ADDR_EXP 134
40513: PUSH
40514: LD_EXP 134
40518: PPUSH
40519: LD_VAR 0 1
40523: PPUSH
40524: EMPTY
40525: PPUSH
40526: CALL_OW 1
40530: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
40531: LD_ADDR_EXP 135
40535: PUSH
40536: LD_EXP 135
40540: PPUSH
40541: LD_VAR 0 1
40545: PPUSH
40546: EMPTY
40547: PPUSH
40548: CALL_OW 1
40552: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
40553: LD_ADDR_EXP 136
40557: PUSH
40558: LD_EXP 136
40562: PPUSH
40563: LD_VAR 0 1
40567: PPUSH
40568: EMPTY
40569: PPUSH
40570: CALL_OW 1
40574: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
40575: LD_ADDR_EXP 137
40579: PUSH
40580: LD_EXP 137
40584: PPUSH
40585: LD_VAR 0 1
40589: PPUSH
40590: EMPTY
40591: PPUSH
40592: CALL_OW 1
40596: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
40597: LD_ADDR_EXP 138
40601: PUSH
40602: LD_EXP 138
40606: PPUSH
40607: LD_VAR 0 1
40611: PPUSH
40612: EMPTY
40613: PPUSH
40614: CALL_OW 1
40618: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
40619: LD_ADDR_EXP 139
40623: PUSH
40624: LD_EXP 139
40628: PPUSH
40629: LD_VAR 0 1
40633: PPUSH
40634: EMPTY
40635: PPUSH
40636: CALL_OW 1
40640: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
40641: LD_ADDR_EXP 140
40645: PUSH
40646: LD_EXP 140
40650: PPUSH
40651: LD_VAR 0 1
40655: PPUSH
40656: EMPTY
40657: PPUSH
40658: CALL_OW 1
40662: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
40663: LD_ADDR_EXP 141
40667: PUSH
40668: LD_EXP 141
40672: PPUSH
40673: LD_VAR 0 1
40677: PPUSH
40678: EMPTY
40679: PPUSH
40680: CALL_OW 1
40684: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
40685: LD_ADDR_EXP 142
40689: PUSH
40690: LD_EXP 142
40694: PPUSH
40695: LD_VAR 0 1
40699: PPUSH
40700: EMPTY
40701: PPUSH
40702: CALL_OW 1
40706: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
40707: LD_ADDR_EXP 143
40711: PUSH
40712: LD_EXP 143
40716: PPUSH
40717: LD_VAR 0 1
40721: PPUSH
40722: EMPTY
40723: PPUSH
40724: CALL_OW 1
40728: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
40729: LD_ADDR_EXP 144
40733: PUSH
40734: LD_EXP 144
40738: PPUSH
40739: LD_VAR 0 1
40743: PPUSH
40744: LD_INT 0
40746: PPUSH
40747: CALL_OW 1
40751: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
40752: LD_ADDR_EXP 145
40756: PUSH
40757: LD_EXP 145
40761: PPUSH
40762: LD_VAR 0 1
40766: PPUSH
40767: LD_INT 0
40769: PPUSH
40770: CALL_OW 1
40774: ST_TO_ADDR
// end ;
40775: LD_VAR 0 2
40779: RET
// export function MC_Add ( side , units ) ; var base ; begin
40780: LD_INT 0
40782: PPUSH
40783: PPUSH
// base := mc_bases + 1 ;
40784: LD_ADDR_VAR 0 4
40788: PUSH
40789: LD_EXP 102
40793: PUSH
40794: LD_INT 1
40796: PLUS
40797: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
40798: LD_ADDR_EXP 128
40802: PUSH
40803: LD_EXP 128
40807: PPUSH
40808: LD_VAR 0 4
40812: PPUSH
40813: LD_VAR 0 1
40817: PPUSH
40818: CALL_OW 1
40822: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
40823: LD_ADDR_EXP 102
40827: PUSH
40828: LD_EXP 102
40832: PPUSH
40833: LD_VAR 0 4
40837: PPUSH
40838: LD_VAR 0 2
40842: PPUSH
40843: CALL_OW 1
40847: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
40848: LD_ADDR_EXP 103
40852: PUSH
40853: LD_EXP 103
40857: PPUSH
40858: LD_VAR 0 4
40862: PPUSH
40863: EMPTY
40864: PPUSH
40865: CALL_OW 1
40869: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
40870: LD_ADDR_EXP 104
40874: PUSH
40875: LD_EXP 104
40879: PPUSH
40880: LD_VAR 0 4
40884: PPUSH
40885: EMPTY
40886: PPUSH
40887: CALL_OW 1
40891: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
40892: LD_ADDR_EXP 105
40896: PUSH
40897: LD_EXP 105
40901: PPUSH
40902: LD_VAR 0 4
40906: PPUSH
40907: EMPTY
40908: PPUSH
40909: CALL_OW 1
40913: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
40914: LD_ADDR_EXP 106
40918: PUSH
40919: LD_EXP 106
40923: PPUSH
40924: LD_VAR 0 4
40928: PPUSH
40929: EMPTY
40930: PPUSH
40931: CALL_OW 1
40935: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
40936: LD_ADDR_EXP 107
40940: PUSH
40941: LD_EXP 107
40945: PPUSH
40946: LD_VAR 0 4
40950: PPUSH
40951: EMPTY
40952: PPUSH
40953: CALL_OW 1
40957: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
40958: LD_ADDR_EXP 108
40962: PUSH
40963: LD_EXP 108
40967: PPUSH
40968: LD_VAR 0 4
40972: PPUSH
40973: EMPTY
40974: PPUSH
40975: CALL_OW 1
40979: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
40980: LD_ADDR_EXP 109
40984: PUSH
40985: LD_EXP 109
40989: PPUSH
40990: LD_VAR 0 4
40994: PPUSH
40995: EMPTY
40996: PPUSH
40997: CALL_OW 1
41001: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
41002: LD_ADDR_EXP 110
41006: PUSH
41007: LD_EXP 110
41011: PPUSH
41012: LD_VAR 0 4
41016: PPUSH
41017: EMPTY
41018: PPUSH
41019: CALL_OW 1
41023: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
41024: LD_ADDR_EXP 111
41028: PUSH
41029: LD_EXP 111
41033: PPUSH
41034: LD_VAR 0 4
41038: PPUSH
41039: EMPTY
41040: PPUSH
41041: CALL_OW 1
41045: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
41046: LD_ADDR_EXP 112
41050: PUSH
41051: LD_EXP 112
41055: PPUSH
41056: LD_VAR 0 4
41060: PPUSH
41061: EMPTY
41062: PPUSH
41063: CALL_OW 1
41067: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
41068: LD_ADDR_EXP 113
41072: PUSH
41073: LD_EXP 113
41077: PPUSH
41078: LD_VAR 0 4
41082: PPUSH
41083: LD_INT 0
41085: PPUSH
41086: CALL_OW 1
41090: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
41091: LD_ADDR_EXP 114
41095: PUSH
41096: LD_EXP 114
41100: PPUSH
41101: LD_VAR 0 4
41105: PPUSH
41106: EMPTY
41107: PPUSH
41108: CALL_OW 1
41112: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
41113: LD_ADDR_EXP 115
41117: PUSH
41118: LD_EXP 115
41122: PPUSH
41123: LD_VAR 0 4
41127: PPUSH
41128: EMPTY
41129: PPUSH
41130: CALL_OW 1
41134: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
41135: LD_ADDR_EXP 116
41139: PUSH
41140: LD_EXP 116
41144: PPUSH
41145: LD_VAR 0 4
41149: PPUSH
41150: EMPTY
41151: PPUSH
41152: CALL_OW 1
41156: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
41157: LD_ADDR_EXP 117
41161: PUSH
41162: LD_EXP 117
41166: PPUSH
41167: LD_VAR 0 4
41171: PPUSH
41172: EMPTY
41173: PPUSH
41174: CALL_OW 1
41178: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
41179: LD_ADDR_EXP 118
41183: PUSH
41184: LD_EXP 118
41188: PPUSH
41189: LD_VAR 0 4
41193: PPUSH
41194: EMPTY
41195: PPUSH
41196: CALL_OW 1
41200: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
41201: LD_ADDR_EXP 119
41205: PUSH
41206: LD_EXP 119
41210: PPUSH
41211: LD_VAR 0 4
41215: PPUSH
41216: EMPTY
41217: PPUSH
41218: CALL_OW 1
41222: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
41223: LD_ADDR_EXP 120
41227: PUSH
41228: LD_EXP 120
41232: PPUSH
41233: LD_VAR 0 4
41237: PPUSH
41238: EMPTY
41239: PPUSH
41240: CALL_OW 1
41244: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
41245: LD_ADDR_EXP 121
41249: PUSH
41250: LD_EXP 121
41254: PPUSH
41255: LD_VAR 0 4
41259: PPUSH
41260: EMPTY
41261: PPUSH
41262: CALL_OW 1
41266: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
41267: LD_ADDR_EXP 122
41271: PUSH
41272: LD_EXP 122
41276: PPUSH
41277: LD_VAR 0 4
41281: PPUSH
41282: EMPTY
41283: PPUSH
41284: CALL_OW 1
41288: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
41289: LD_ADDR_EXP 123
41293: PUSH
41294: LD_EXP 123
41298: PPUSH
41299: LD_VAR 0 4
41303: PPUSH
41304: EMPTY
41305: PPUSH
41306: CALL_OW 1
41310: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
41311: LD_ADDR_EXP 124
41315: PUSH
41316: LD_EXP 124
41320: PPUSH
41321: LD_VAR 0 4
41325: PPUSH
41326: EMPTY
41327: PPUSH
41328: CALL_OW 1
41332: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
41333: LD_ADDR_EXP 125
41337: PUSH
41338: LD_EXP 125
41342: PPUSH
41343: LD_VAR 0 4
41347: PPUSH
41348: EMPTY
41349: PPUSH
41350: CALL_OW 1
41354: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
41355: LD_ADDR_EXP 126
41359: PUSH
41360: LD_EXP 126
41364: PPUSH
41365: LD_VAR 0 4
41369: PPUSH
41370: EMPTY
41371: PPUSH
41372: CALL_OW 1
41376: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
41377: LD_ADDR_EXP 127
41381: PUSH
41382: LD_EXP 127
41386: PPUSH
41387: LD_VAR 0 4
41391: PPUSH
41392: EMPTY
41393: PPUSH
41394: CALL_OW 1
41398: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
41399: LD_ADDR_EXP 129
41403: PUSH
41404: LD_EXP 129
41408: PPUSH
41409: LD_VAR 0 4
41413: PPUSH
41414: EMPTY
41415: PPUSH
41416: CALL_OW 1
41420: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
41421: LD_ADDR_EXP 131
41425: PUSH
41426: LD_EXP 131
41430: PPUSH
41431: LD_VAR 0 4
41435: PPUSH
41436: EMPTY
41437: PPUSH
41438: CALL_OW 1
41442: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
41443: LD_ADDR_EXP 132
41447: PUSH
41448: LD_EXP 132
41452: PPUSH
41453: LD_VAR 0 4
41457: PPUSH
41458: EMPTY
41459: PPUSH
41460: CALL_OW 1
41464: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
41465: LD_ADDR_EXP 133
41469: PUSH
41470: LD_EXP 133
41474: PPUSH
41475: LD_VAR 0 4
41479: PPUSH
41480: EMPTY
41481: PPUSH
41482: CALL_OW 1
41486: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
41487: LD_ADDR_EXP 134
41491: PUSH
41492: LD_EXP 134
41496: PPUSH
41497: LD_VAR 0 4
41501: PPUSH
41502: EMPTY
41503: PPUSH
41504: CALL_OW 1
41508: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
41509: LD_ADDR_EXP 135
41513: PUSH
41514: LD_EXP 135
41518: PPUSH
41519: LD_VAR 0 4
41523: PPUSH
41524: EMPTY
41525: PPUSH
41526: CALL_OW 1
41530: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
41531: LD_ADDR_EXP 136
41535: PUSH
41536: LD_EXP 136
41540: PPUSH
41541: LD_VAR 0 4
41545: PPUSH
41546: EMPTY
41547: PPUSH
41548: CALL_OW 1
41552: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
41553: LD_ADDR_EXP 137
41557: PUSH
41558: LD_EXP 137
41562: PPUSH
41563: LD_VAR 0 4
41567: PPUSH
41568: EMPTY
41569: PPUSH
41570: CALL_OW 1
41574: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
41575: LD_ADDR_EXP 138
41579: PUSH
41580: LD_EXP 138
41584: PPUSH
41585: LD_VAR 0 4
41589: PPUSH
41590: EMPTY
41591: PPUSH
41592: CALL_OW 1
41596: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
41597: LD_ADDR_EXP 139
41601: PUSH
41602: LD_EXP 139
41606: PPUSH
41607: LD_VAR 0 4
41611: PPUSH
41612: EMPTY
41613: PPUSH
41614: CALL_OW 1
41618: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
41619: LD_ADDR_EXP 140
41623: PUSH
41624: LD_EXP 140
41628: PPUSH
41629: LD_VAR 0 4
41633: PPUSH
41634: EMPTY
41635: PPUSH
41636: CALL_OW 1
41640: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
41641: LD_ADDR_EXP 141
41645: PUSH
41646: LD_EXP 141
41650: PPUSH
41651: LD_VAR 0 4
41655: PPUSH
41656: EMPTY
41657: PPUSH
41658: CALL_OW 1
41662: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
41663: LD_ADDR_EXP 142
41667: PUSH
41668: LD_EXP 142
41672: PPUSH
41673: LD_VAR 0 4
41677: PPUSH
41678: EMPTY
41679: PPUSH
41680: CALL_OW 1
41684: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
41685: LD_ADDR_EXP 143
41689: PUSH
41690: LD_EXP 143
41694: PPUSH
41695: LD_VAR 0 4
41699: PPUSH
41700: EMPTY
41701: PPUSH
41702: CALL_OW 1
41706: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
41707: LD_ADDR_EXP 144
41711: PUSH
41712: LD_EXP 144
41716: PPUSH
41717: LD_VAR 0 4
41721: PPUSH
41722: LD_INT 0
41724: PPUSH
41725: CALL_OW 1
41729: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
41730: LD_ADDR_EXP 145
41734: PUSH
41735: LD_EXP 145
41739: PPUSH
41740: LD_VAR 0 4
41744: PPUSH
41745: LD_INT 0
41747: PPUSH
41748: CALL_OW 1
41752: ST_TO_ADDR
// result := base ;
41753: LD_ADDR_VAR 0 3
41757: PUSH
41758: LD_VAR 0 4
41762: ST_TO_ADDR
// end ;
41763: LD_VAR 0 3
41767: RET
// export function MC_Start ( ) ; var i ; begin
41768: LD_INT 0
41770: PPUSH
41771: PPUSH
// for i = 1 to mc_bases do
41772: LD_ADDR_VAR 0 2
41776: PUSH
41777: DOUBLE
41778: LD_INT 1
41780: DEC
41781: ST_TO_ADDR
41782: LD_EXP 102
41786: PUSH
41787: FOR_TO
41788: IFFALSE 42888
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
41790: LD_ADDR_EXP 102
41794: PUSH
41795: LD_EXP 102
41799: PPUSH
41800: LD_VAR 0 2
41804: PPUSH
41805: LD_EXP 102
41809: PUSH
41810: LD_VAR 0 2
41814: ARRAY
41815: PUSH
41816: LD_INT 0
41818: DIFF
41819: PPUSH
41820: CALL_OW 1
41824: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
41825: LD_ADDR_EXP 103
41829: PUSH
41830: LD_EXP 103
41834: PPUSH
41835: LD_VAR 0 2
41839: PPUSH
41840: EMPTY
41841: PPUSH
41842: CALL_OW 1
41846: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
41847: LD_ADDR_EXP 104
41851: PUSH
41852: LD_EXP 104
41856: PPUSH
41857: LD_VAR 0 2
41861: PPUSH
41862: EMPTY
41863: PPUSH
41864: CALL_OW 1
41868: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
41869: LD_ADDR_EXP 105
41873: PUSH
41874: LD_EXP 105
41878: PPUSH
41879: LD_VAR 0 2
41883: PPUSH
41884: EMPTY
41885: PPUSH
41886: CALL_OW 1
41890: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
41891: LD_ADDR_EXP 106
41895: PUSH
41896: LD_EXP 106
41900: PPUSH
41901: LD_VAR 0 2
41905: PPUSH
41906: EMPTY
41907: PUSH
41908: EMPTY
41909: PUSH
41910: EMPTY
41911: LIST
41912: LIST
41913: PPUSH
41914: CALL_OW 1
41918: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
41919: LD_ADDR_EXP 107
41923: PUSH
41924: LD_EXP 107
41928: PPUSH
41929: LD_VAR 0 2
41933: PPUSH
41934: EMPTY
41935: PPUSH
41936: CALL_OW 1
41940: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
41941: LD_ADDR_EXP 134
41945: PUSH
41946: LD_EXP 134
41950: PPUSH
41951: LD_VAR 0 2
41955: PPUSH
41956: EMPTY
41957: PPUSH
41958: CALL_OW 1
41962: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
41963: LD_ADDR_EXP 108
41967: PUSH
41968: LD_EXP 108
41972: PPUSH
41973: LD_VAR 0 2
41977: PPUSH
41978: EMPTY
41979: PPUSH
41980: CALL_OW 1
41984: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
41985: LD_ADDR_EXP 109
41989: PUSH
41990: LD_EXP 109
41994: PPUSH
41995: LD_VAR 0 2
41999: PPUSH
42000: EMPTY
42001: PPUSH
42002: CALL_OW 1
42006: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
42007: LD_ADDR_EXP 110
42011: PUSH
42012: LD_EXP 110
42016: PPUSH
42017: LD_VAR 0 2
42021: PPUSH
42022: LD_EXP 102
42026: PUSH
42027: LD_VAR 0 2
42031: ARRAY
42032: PPUSH
42033: LD_INT 2
42035: PUSH
42036: LD_INT 30
42038: PUSH
42039: LD_INT 32
42041: PUSH
42042: EMPTY
42043: LIST
42044: LIST
42045: PUSH
42046: LD_INT 30
42048: PUSH
42049: LD_INT 33
42051: PUSH
42052: EMPTY
42053: LIST
42054: LIST
42055: PUSH
42056: EMPTY
42057: LIST
42058: LIST
42059: LIST
42060: PPUSH
42061: CALL_OW 72
42065: PPUSH
42066: CALL_OW 1
42070: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
42071: LD_ADDR_EXP 111
42075: PUSH
42076: LD_EXP 111
42080: PPUSH
42081: LD_VAR 0 2
42085: PPUSH
42086: LD_EXP 102
42090: PUSH
42091: LD_VAR 0 2
42095: ARRAY
42096: PPUSH
42097: LD_INT 2
42099: PUSH
42100: LD_INT 30
42102: PUSH
42103: LD_INT 32
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: PUSH
42110: LD_INT 30
42112: PUSH
42113: LD_INT 31
42115: PUSH
42116: EMPTY
42117: LIST
42118: LIST
42119: PUSH
42120: EMPTY
42121: LIST
42122: LIST
42123: LIST
42124: PUSH
42125: LD_INT 58
42127: PUSH
42128: EMPTY
42129: LIST
42130: PUSH
42131: EMPTY
42132: LIST
42133: LIST
42134: PPUSH
42135: CALL_OW 72
42139: PPUSH
42140: CALL_OW 1
42144: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
42145: LD_ADDR_EXP 112
42149: PUSH
42150: LD_EXP 112
42154: PPUSH
42155: LD_VAR 0 2
42159: PPUSH
42160: EMPTY
42161: PPUSH
42162: CALL_OW 1
42166: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
42167: LD_ADDR_EXP 116
42171: PUSH
42172: LD_EXP 116
42176: PPUSH
42177: LD_VAR 0 2
42181: PPUSH
42182: EMPTY
42183: PPUSH
42184: CALL_OW 1
42188: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
42189: LD_ADDR_EXP 115
42193: PUSH
42194: LD_EXP 115
42198: PPUSH
42199: LD_VAR 0 2
42203: PPUSH
42204: EMPTY
42205: PPUSH
42206: CALL_OW 1
42210: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
42211: LD_ADDR_EXP 117
42215: PUSH
42216: LD_EXP 117
42220: PPUSH
42221: LD_VAR 0 2
42225: PPUSH
42226: EMPTY
42227: PPUSH
42228: CALL_OW 1
42232: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
42233: LD_ADDR_EXP 118
42237: PUSH
42238: LD_EXP 118
42242: PPUSH
42243: LD_VAR 0 2
42247: PPUSH
42248: EMPTY
42249: PPUSH
42250: CALL_OW 1
42254: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
42255: LD_ADDR_EXP 119
42259: PUSH
42260: LD_EXP 119
42264: PPUSH
42265: LD_VAR 0 2
42269: PPUSH
42270: EMPTY
42271: PPUSH
42272: CALL_OW 1
42276: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
42277: LD_ADDR_EXP 120
42281: PUSH
42282: LD_EXP 120
42286: PPUSH
42287: LD_VAR 0 2
42291: PPUSH
42292: EMPTY
42293: PPUSH
42294: CALL_OW 1
42298: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
42299: LD_ADDR_EXP 121
42303: PUSH
42304: LD_EXP 121
42308: PPUSH
42309: LD_VAR 0 2
42313: PPUSH
42314: EMPTY
42315: PPUSH
42316: CALL_OW 1
42320: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
42321: LD_ADDR_EXP 122
42325: PUSH
42326: LD_EXP 122
42330: PPUSH
42331: LD_VAR 0 2
42335: PPUSH
42336: EMPTY
42337: PPUSH
42338: CALL_OW 1
42342: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
42343: LD_ADDR_EXP 123
42347: PUSH
42348: LD_EXP 123
42352: PPUSH
42353: LD_VAR 0 2
42357: PPUSH
42358: EMPTY
42359: PPUSH
42360: CALL_OW 1
42364: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
42365: LD_ADDR_EXP 124
42369: PUSH
42370: LD_EXP 124
42374: PPUSH
42375: LD_VAR 0 2
42379: PPUSH
42380: EMPTY
42381: PPUSH
42382: CALL_OW 1
42386: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
42387: LD_ADDR_EXP 113
42391: PUSH
42392: LD_EXP 113
42396: PPUSH
42397: LD_VAR 0 2
42401: PPUSH
42402: LD_INT 0
42404: PPUSH
42405: CALL_OW 1
42409: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
42410: LD_ADDR_EXP 126
42414: PUSH
42415: LD_EXP 126
42419: PPUSH
42420: LD_VAR 0 2
42424: PPUSH
42425: LD_INT 0
42427: PPUSH
42428: CALL_OW 1
42432: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
42433: LD_ADDR_EXP 114
42437: PUSH
42438: LD_EXP 114
42442: PPUSH
42443: LD_VAR 0 2
42447: PPUSH
42448: EMPTY
42449: PPUSH
42450: CALL_OW 1
42454: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
42455: LD_ADDR_EXP 125
42459: PUSH
42460: LD_EXP 125
42464: PPUSH
42465: LD_VAR 0 2
42469: PPUSH
42470: LD_INT 0
42472: PPUSH
42473: CALL_OW 1
42477: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
42478: LD_ADDR_EXP 127
42482: PUSH
42483: LD_EXP 127
42487: PPUSH
42488: LD_VAR 0 2
42492: PPUSH
42493: EMPTY
42494: PPUSH
42495: CALL_OW 1
42499: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
42500: LD_ADDR_EXP 130
42504: PUSH
42505: LD_EXP 130
42509: PPUSH
42510: LD_VAR 0 2
42514: PPUSH
42515: LD_INT 0
42517: PPUSH
42518: CALL_OW 1
42522: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
42523: LD_ADDR_EXP 131
42527: PUSH
42528: LD_EXP 131
42532: PPUSH
42533: LD_VAR 0 2
42537: PPUSH
42538: EMPTY
42539: PPUSH
42540: CALL_OW 1
42544: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
42545: LD_ADDR_EXP 132
42549: PUSH
42550: LD_EXP 132
42554: PPUSH
42555: LD_VAR 0 2
42559: PPUSH
42560: EMPTY
42561: PPUSH
42562: CALL_OW 1
42566: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
42567: LD_ADDR_EXP 133
42571: PUSH
42572: LD_EXP 133
42576: PPUSH
42577: LD_VAR 0 2
42581: PPUSH
42582: EMPTY
42583: PPUSH
42584: CALL_OW 1
42588: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
42589: LD_ADDR_EXP 135
42593: PUSH
42594: LD_EXP 135
42598: PPUSH
42599: LD_VAR 0 2
42603: PPUSH
42604: LD_EXP 102
42608: PUSH
42609: LD_VAR 0 2
42613: ARRAY
42614: PPUSH
42615: LD_INT 2
42617: PUSH
42618: LD_INT 30
42620: PUSH
42621: LD_INT 6
42623: PUSH
42624: EMPTY
42625: LIST
42626: LIST
42627: PUSH
42628: LD_INT 30
42630: PUSH
42631: LD_INT 7
42633: PUSH
42634: EMPTY
42635: LIST
42636: LIST
42637: PUSH
42638: LD_INT 30
42640: PUSH
42641: LD_INT 8
42643: PUSH
42644: EMPTY
42645: LIST
42646: LIST
42647: PUSH
42648: EMPTY
42649: LIST
42650: LIST
42651: LIST
42652: LIST
42653: PPUSH
42654: CALL_OW 72
42658: PPUSH
42659: CALL_OW 1
42663: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
42664: LD_ADDR_EXP 136
42668: PUSH
42669: LD_EXP 136
42673: PPUSH
42674: LD_VAR 0 2
42678: PPUSH
42679: EMPTY
42680: PPUSH
42681: CALL_OW 1
42685: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
42686: LD_ADDR_EXP 137
42690: PUSH
42691: LD_EXP 137
42695: PPUSH
42696: LD_VAR 0 2
42700: PPUSH
42701: EMPTY
42702: PPUSH
42703: CALL_OW 1
42707: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
42708: LD_ADDR_EXP 138
42712: PUSH
42713: LD_EXP 138
42717: PPUSH
42718: LD_VAR 0 2
42722: PPUSH
42723: EMPTY
42724: PPUSH
42725: CALL_OW 1
42729: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
42730: LD_ADDR_EXP 139
42734: PUSH
42735: LD_EXP 139
42739: PPUSH
42740: LD_VAR 0 2
42744: PPUSH
42745: EMPTY
42746: PPUSH
42747: CALL_OW 1
42751: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42752: LD_ADDR_EXP 140
42756: PUSH
42757: LD_EXP 140
42761: PPUSH
42762: LD_VAR 0 2
42766: PPUSH
42767: EMPTY
42768: PPUSH
42769: CALL_OW 1
42773: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
42774: LD_ADDR_EXP 141
42778: PUSH
42779: LD_EXP 141
42783: PPUSH
42784: LD_VAR 0 2
42788: PPUSH
42789: EMPTY
42790: PPUSH
42791: CALL_OW 1
42795: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
42796: LD_ADDR_EXP 142
42800: PUSH
42801: LD_EXP 142
42805: PPUSH
42806: LD_VAR 0 2
42810: PPUSH
42811: EMPTY
42812: PPUSH
42813: CALL_OW 1
42817: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
42818: LD_ADDR_EXP 143
42822: PUSH
42823: LD_EXP 143
42827: PPUSH
42828: LD_VAR 0 2
42832: PPUSH
42833: EMPTY
42834: PPUSH
42835: CALL_OW 1
42839: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
42840: LD_ADDR_EXP 144
42844: PUSH
42845: LD_EXP 144
42849: PPUSH
42850: LD_VAR 0 2
42854: PPUSH
42855: LD_INT 0
42857: PPUSH
42858: CALL_OW 1
42862: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
42863: LD_ADDR_EXP 145
42867: PUSH
42868: LD_EXP 145
42872: PPUSH
42873: LD_VAR 0 2
42877: PPUSH
42878: LD_INT 0
42880: PPUSH
42881: CALL_OW 1
42885: ST_TO_ADDR
// end ;
42886: GO 41787
42888: POP
42889: POP
// MC_InitSides ( ) ;
42890: CALL 43176 0 0
// MC_InitResearch ( ) ;
42894: CALL 42915 0 0
// CustomInitMacro ( ) ;
42898: CALL 475 0 0
// skirmish := true ;
42902: LD_ADDR_EXP 100
42906: PUSH
42907: LD_INT 1
42909: ST_TO_ADDR
// end ;
42910: LD_VAR 0 1
42914: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
42915: LD_INT 0
42917: PPUSH
42918: PPUSH
42919: PPUSH
42920: PPUSH
42921: PPUSH
42922: PPUSH
// if not mc_bases then
42923: LD_EXP 102
42927: NOT
42928: IFFALSE 42932
// exit ;
42930: GO 43171
// for i = 1 to 8 do
42932: LD_ADDR_VAR 0 2
42936: PUSH
42937: DOUBLE
42938: LD_INT 1
42940: DEC
42941: ST_TO_ADDR
42942: LD_INT 8
42944: PUSH
42945: FOR_TO
42946: IFFALSE 42972
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
42948: LD_ADDR_EXP 129
42952: PUSH
42953: LD_EXP 129
42957: PPUSH
42958: LD_VAR 0 2
42962: PPUSH
42963: EMPTY
42964: PPUSH
42965: CALL_OW 1
42969: ST_TO_ADDR
42970: GO 42945
42972: POP
42973: POP
// tmp := [ ] ;
42974: LD_ADDR_VAR 0 5
42978: PUSH
42979: EMPTY
42980: ST_TO_ADDR
// for i = 1 to mc_sides do
42981: LD_ADDR_VAR 0 2
42985: PUSH
42986: DOUBLE
42987: LD_INT 1
42989: DEC
42990: ST_TO_ADDR
42991: LD_EXP 128
42995: PUSH
42996: FOR_TO
42997: IFFALSE 43055
// if not mc_sides [ i ] in tmp then
42999: LD_EXP 128
43003: PUSH
43004: LD_VAR 0 2
43008: ARRAY
43009: PUSH
43010: LD_VAR 0 5
43014: IN
43015: NOT
43016: IFFALSE 43053
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
43018: LD_ADDR_VAR 0 5
43022: PUSH
43023: LD_VAR 0 5
43027: PPUSH
43028: LD_VAR 0 5
43032: PUSH
43033: LD_INT 1
43035: PLUS
43036: PPUSH
43037: LD_EXP 128
43041: PUSH
43042: LD_VAR 0 2
43046: ARRAY
43047: PPUSH
43048: CALL_OW 2
43052: ST_TO_ADDR
43053: GO 42996
43055: POP
43056: POP
// if not tmp then
43057: LD_VAR 0 5
43061: NOT
43062: IFFALSE 43066
// exit ;
43064: GO 43171
// for j in tmp do
43066: LD_ADDR_VAR 0 3
43070: PUSH
43071: LD_VAR 0 5
43075: PUSH
43076: FOR_IN
43077: IFFALSE 43169
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
43079: LD_ADDR_VAR 0 6
43083: PUSH
43084: LD_INT 22
43086: PUSH
43087: LD_VAR 0 3
43091: PUSH
43092: EMPTY
43093: LIST
43094: LIST
43095: PPUSH
43096: CALL_OW 69
43100: ST_TO_ADDR
// if not un then
43101: LD_VAR 0 6
43105: NOT
43106: IFFALSE 43110
// continue ;
43108: GO 43076
// nation := GetNation ( un [ 1 ] ) ;
43110: LD_ADDR_VAR 0 4
43114: PUSH
43115: LD_VAR 0 6
43119: PUSH
43120: LD_INT 1
43122: ARRAY
43123: PPUSH
43124: CALL_OW 248
43128: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
43129: LD_ADDR_EXP 129
43133: PUSH
43134: LD_EXP 129
43138: PPUSH
43139: LD_VAR 0 3
43143: PPUSH
43144: LD_VAR 0 3
43148: PPUSH
43149: LD_VAR 0 4
43153: PPUSH
43154: LD_INT 1
43156: PPUSH
43157: CALL 70443 0 3
43161: PPUSH
43162: CALL_OW 1
43166: ST_TO_ADDR
// end ;
43167: GO 43076
43169: POP
43170: POP
// end ;
43171: LD_VAR 0 1
43175: RET
// export function MC_InitSides ( ) ; var i ; begin
43176: LD_INT 0
43178: PPUSH
43179: PPUSH
// if not mc_bases then
43180: LD_EXP 102
43184: NOT
43185: IFFALSE 43189
// exit ;
43187: GO 43263
// for i = 1 to mc_bases do
43189: LD_ADDR_VAR 0 2
43193: PUSH
43194: DOUBLE
43195: LD_INT 1
43197: DEC
43198: ST_TO_ADDR
43199: LD_EXP 102
43203: PUSH
43204: FOR_TO
43205: IFFALSE 43261
// if mc_bases [ i ] then
43207: LD_EXP 102
43211: PUSH
43212: LD_VAR 0 2
43216: ARRAY
43217: IFFALSE 43259
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
43219: LD_ADDR_EXP 128
43223: PUSH
43224: LD_EXP 128
43228: PPUSH
43229: LD_VAR 0 2
43233: PPUSH
43234: LD_EXP 102
43238: PUSH
43239: LD_VAR 0 2
43243: ARRAY
43244: PUSH
43245: LD_INT 1
43247: ARRAY
43248: PPUSH
43249: CALL_OW 255
43253: PPUSH
43254: CALL_OW 1
43258: ST_TO_ADDR
43259: GO 43204
43261: POP
43262: POP
// end ;
43263: LD_VAR 0 1
43267: RET
// every 0 0$03 trigger skirmish do
43268: LD_EXP 100
43272: IFFALSE 43426
43274: GO 43276
43276: DISABLE
// begin enable ;
43277: ENABLE
// MC_CheckBuildings ( ) ;
43278: CALL 47938 0 0
// MC_CheckPeopleLife ( ) ;
43282: CALL 48099 0 0
// RaiseSailEvent ( 100 ) ;
43286: LD_INT 100
43288: PPUSH
43289: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
43293: LD_INT 103
43295: PPUSH
43296: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
43300: LD_INT 104
43302: PPUSH
43303: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
43307: LD_INT 105
43309: PPUSH
43310: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
43314: LD_INT 106
43316: PPUSH
43317: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
43321: LD_INT 107
43323: PPUSH
43324: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
43328: LD_INT 108
43330: PPUSH
43331: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
43335: LD_INT 109
43337: PPUSH
43338: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
43342: LD_INT 110
43344: PPUSH
43345: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
43349: LD_INT 111
43351: PPUSH
43352: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
43356: LD_INT 112
43358: PPUSH
43359: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
43363: LD_INT 113
43365: PPUSH
43366: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
43370: LD_INT 120
43372: PPUSH
43373: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
43377: LD_INT 121
43379: PPUSH
43380: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
43384: LD_INT 122
43386: PPUSH
43387: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
43391: LD_INT 123
43393: PPUSH
43394: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
43398: LD_INT 124
43400: PPUSH
43401: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
43405: LD_INT 125
43407: PPUSH
43408: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
43412: LD_INT 126
43414: PPUSH
43415: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
43419: LD_INT 200
43421: PPUSH
43422: CALL_OW 427
// end ;
43426: END
// on SailEvent ( event ) do begin if event < 100 then
43427: LD_VAR 0 1
43431: PUSH
43432: LD_INT 100
43434: LESS
43435: IFFALSE 43446
// CustomEvent ( event ) ;
43437: LD_VAR 0 1
43441: PPUSH
43442: CALL 37802 0 1
// if event = 100 then
43446: LD_VAR 0 1
43450: PUSH
43451: LD_INT 100
43453: EQUAL
43454: IFFALSE 43460
// MC_ClassManager ( ) ;
43456: CALL 43852 0 0
// if event = 101 then
43460: LD_VAR 0 1
43464: PUSH
43465: LD_INT 101
43467: EQUAL
43468: IFFALSE 43474
// MC_RepairBuildings ( ) ;
43470: CALL 48684 0 0
// if event = 102 then
43474: LD_VAR 0 1
43478: PUSH
43479: LD_INT 102
43481: EQUAL
43482: IFFALSE 43488
// MC_Heal ( ) ;
43484: CALL 49619 0 0
// if event = 103 then
43488: LD_VAR 0 1
43492: PUSH
43493: LD_INT 103
43495: EQUAL
43496: IFFALSE 43502
// MC_Build ( ) ;
43498: CALL 50041 0 0
// if event = 104 then
43502: LD_VAR 0 1
43506: PUSH
43507: LD_INT 104
43509: EQUAL
43510: IFFALSE 43516
// MC_TurretWeapon ( ) ;
43512: CALL 51675 0 0
// if event = 105 then
43516: LD_VAR 0 1
43520: PUSH
43521: LD_INT 105
43523: EQUAL
43524: IFFALSE 43530
// MC_BuildUpgrade ( ) ;
43526: CALL 51226 0 0
// if event = 106 then
43530: LD_VAR 0 1
43534: PUSH
43535: LD_INT 106
43537: EQUAL
43538: IFFALSE 43544
// MC_PlantMines ( ) ;
43540: CALL 52105 0 0
// if event = 107 then
43544: LD_VAR 0 1
43548: PUSH
43549: LD_INT 107
43551: EQUAL
43552: IFFALSE 43558
// MC_CollectCrates ( ) ;
43554: CALL 52903 0 0
// if event = 108 then
43558: LD_VAR 0 1
43562: PUSH
43563: LD_INT 108
43565: EQUAL
43566: IFFALSE 43572
// MC_LinkRemoteControl ( ) ;
43568: CALL 54753 0 0
// if event = 109 then
43572: LD_VAR 0 1
43576: PUSH
43577: LD_INT 109
43579: EQUAL
43580: IFFALSE 43586
// MC_ProduceVehicle ( ) ;
43582: CALL 54934 0 0
// if event = 110 then
43586: LD_VAR 0 1
43590: PUSH
43591: LD_INT 110
43593: EQUAL
43594: IFFALSE 43600
// MC_SendAttack ( ) ;
43596: CALL 55400 0 0
// if event = 111 then
43600: LD_VAR 0 1
43604: PUSH
43605: LD_INT 111
43607: EQUAL
43608: IFFALSE 43614
// MC_Defend ( ) ;
43610: CALL 55508 0 0
// if event = 112 then
43614: LD_VAR 0 1
43618: PUSH
43619: LD_INT 112
43621: EQUAL
43622: IFFALSE 43628
// MC_Research ( ) ;
43624: CALL 56388 0 0
// if event = 113 then
43628: LD_VAR 0 1
43632: PUSH
43633: LD_INT 113
43635: EQUAL
43636: IFFALSE 43642
// MC_MinesTrigger ( ) ;
43638: CALL 57502 0 0
// if event = 120 then
43642: LD_VAR 0 1
43646: PUSH
43647: LD_INT 120
43649: EQUAL
43650: IFFALSE 43656
// MC_RepairVehicle ( ) ;
43652: CALL 57601 0 0
// if event = 121 then
43656: LD_VAR 0 1
43660: PUSH
43661: LD_INT 121
43663: EQUAL
43664: IFFALSE 43670
// MC_TameApe ( ) ;
43666: CALL 58370 0 0
// if event = 122 then
43670: LD_VAR 0 1
43674: PUSH
43675: LD_INT 122
43677: EQUAL
43678: IFFALSE 43684
// MC_ChangeApeClass ( ) ;
43680: CALL 59199 0 0
// if event = 123 then
43684: LD_VAR 0 1
43688: PUSH
43689: LD_INT 123
43691: EQUAL
43692: IFFALSE 43698
// MC_Bazooka ( ) ;
43694: CALL 59849 0 0
// if event = 124 then
43698: LD_VAR 0 1
43702: PUSH
43703: LD_INT 124
43705: EQUAL
43706: IFFALSE 43712
// MC_TeleportExit ( ) ;
43708: CALL 60047 0 0
// if event = 125 then
43712: LD_VAR 0 1
43716: PUSH
43717: LD_INT 125
43719: EQUAL
43720: IFFALSE 43726
// MC_Deposits ( ) ;
43722: CALL 60694 0 0
// if event = 126 then
43726: LD_VAR 0 1
43730: PUSH
43731: LD_INT 126
43733: EQUAL
43734: IFFALSE 43740
// MC_RemoteDriver ( ) ;
43736: CALL 61319 0 0
// if event = 200 then
43740: LD_VAR 0 1
43744: PUSH
43745: LD_INT 200
43747: EQUAL
43748: IFFALSE 43754
// MC_Idle ( ) ;
43750: CALL 63226 0 0
// end ;
43754: PPOPN 1
43756: END
// export function MC_Reset ( base , tag ) ; var i ; begin
43757: LD_INT 0
43759: PPUSH
43760: PPUSH
// if not mc_bases [ base ] or not tag then
43761: LD_EXP 102
43765: PUSH
43766: LD_VAR 0 1
43770: ARRAY
43771: NOT
43772: PUSH
43773: LD_VAR 0 2
43777: NOT
43778: OR
43779: IFFALSE 43783
// exit ;
43781: GO 43847
// for i in mc_bases [ base ] union mc_ape [ base ] do
43783: LD_ADDR_VAR 0 4
43787: PUSH
43788: LD_EXP 102
43792: PUSH
43793: LD_VAR 0 1
43797: ARRAY
43798: PUSH
43799: LD_EXP 131
43803: PUSH
43804: LD_VAR 0 1
43808: ARRAY
43809: UNION
43810: PUSH
43811: FOR_IN
43812: IFFALSE 43845
// if GetTag ( i ) = tag then
43814: LD_VAR 0 4
43818: PPUSH
43819: CALL_OW 110
43823: PUSH
43824: LD_VAR 0 2
43828: EQUAL
43829: IFFALSE 43843
// SetTag ( i , 0 ) ;
43831: LD_VAR 0 4
43835: PPUSH
43836: LD_INT 0
43838: PPUSH
43839: CALL_OW 109
43843: GO 43811
43845: POP
43846: POP
// end ;
43847: LD_VAR 0 3
43851: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
43852: LD_INT 0
43854: PPUSH
43855: PPUSH
43856: PPUSH
43857: PPUSH
43858: PPUSH
43859: PPUSH
43860: PPUSH
43861: PPUSH
// if not mc_bases then
43862: LD_EXP 102
43866: NOT
43867: IFFALSE 43871
// exit ;
43869: GO 44320
// for i = 1 to mc_bases do
43871: LD_ADDR_VAR 0 2
43875: PUSH
43876: DOUBLE
43877: LD_INT 1
43879: DEC
43880: ST_TO_ADDR
43881: LD_EXP 102
43885: PUSH
43886: FOR_TO
43887: IFFALSE 44318
// begin tmp := MC_ClassCheckReq ( i ) ;
43889: LD_ADDR_VAR 0 4
43893: PUSH
43894: LD_VAR 0 2
43898: PPUSH
43899: CALL 44325 0 1
43903: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
43904: LD_ADDR_EXP 143
43908: PUSH
43909: LD_EXP 143
43913: PPUSH
43914: LD_VAR 0 2
43918: PPUSH
43919: LD_VAR 0 4
43923: PPUSH
43924: CALL_OW 1
43928: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
43929: LD_ADDR_VAR 0 6
43933: PUSH
43934: LD_EXP 102
43938: PUSH
43939: LD_VAR 0 2
43943: ARRAY
43944: PPUSH
43945: LD_INT 2
43947: PUSH
43948: LD_INT 30
43950: PUSH
43951: LD_INT 4
43953: PUSH
43954: EMPTY
43955: LIST
43956: LIST
43957: PUSH
43958: LD_INT 30
43960: PUSH
43961: LD_INT 5
43963: PUSH
43964: EMPTY
43965: LIST
43966: LIST
43967: PUSH
43968: EMPTY
43969: LIST
43970: LIST
43971: LIST
43972: PPUSH
43973: CALL_OW 72
43977: PUSH
43978: LD_EXP 102
43982: PUSH
43983: LD_VAR 0 2
43987: ARRAY
43988: PPUSH
43989: LD_INT 2
43991: PUSH
43992: LD_INT 30
43994: PUSH
43995: LD_INT 0
43997: PUSH
43998: EMPTY
43999: LIST
44000: LIST
44001: PUSH
44002: LD_INT 30
44004: PUSH
44005: LD_INT 1
44007: PUSH
44008: EMPTY
44009: LIST
44010: LIST
44011: PUSH
44012: EMPTY
44013: LIST
44014: LIST
44015: LIST
44016: PPUSH
44017: CALL_OW 72
44021: PUSH
44022: LD_EXP 102
44026: PUSH
44027: LD_VAR 0 2
44031: ARRAY
44032: PPUSH
44033: LD_INT 30
44035: PUSH
44036: LD_INT 3
44038: PUSH
44039: EMPTY
44040: LIST
44041: LIST
44042: PPUSH
44043: CALL_OW 72
44047: PUSH
44048: LD_EXP 102
44052: PUSH
44053: LD_VAR 0 2
44057: ARRAY
44058: PPUSH
44059: LD_INT 2
44061: PUSH
44062: LD_INT 30
44064: PUSH
44065: LD_INT 6
44067: PUSH
44068: EMPTY
44069: LIST
44070: LIST
44071: PUSH
44072: LD_INT 30
44074: PUSH
44075: LD_INT 7
44077: PUSH
44078: EMPTY
44079: LIST
44080: LIST
44081: PUSH
44082: LD_INT 30
44084: PUSH
44085: LD_INT 8
44087: PUSH
44088: EMPTY
44089: LIST
44090: LIST
44091: PUSH
44092: EMPTY
44093: LIST
44094: LIST
44095: LIST
44096: LIST
44097: PPUSH
44098: CALL_OW 72
44102: PUSH
44103: EMPTY
44104: LIST
44105: LIST
44106: LIST
44107: LIST
44108: ST_TO_ADDR
// for j := 1 to 4 do
44109: LD_ADDR_VAR 0 3
44113: PUSH
44114: DOUBLE
44115: LD_INT 1
44117: DEC
44118: ST_TO_ADDR
44119: LD_INT 4
44121: PUSH
44122: FOR_TO
44123: IFFALSE 44314
// begin if not tmp [ j ] then
44125: LD_VAR 0 4
44129: PUSH
44130: LD_VAR 0 3
44134: ARRAY
44135: NOT
44136: IFFALSE 44140
// continue ;
44138: GO 44122
// for p in tmp [ j ] do
44140: LD_ADDR_VAR 0 5
44144: PUSH
44145: LD_VAR 0 4
44149: PUSH
44150: LD_VAR 0 3
44154: ARRAY
44155: PUSH
44156: FOR_IN
44157: IFFALSE 44310
// begin if not b [ j ] then
44159: LD_VAR 0 6
44163: PUSH
44164: LD_VAR 0 3
44168: ARRAY
44169: NOT
44170: IFFALSE 44174
// break ;
44172: GO 44310
// e := 0 ;
44174: LD_ADDR_VAR 0 7
44178: PUSH
44179: LD_INT 0
44181: ST_TO_ADDR
// for k in b [ j ] do
44182: LD_ADDR_VAR 0 8
44186: PUSH
44187: LD_VAR 0 6
44191: PUSH
44192: LD_VAR 0 3
44196: ARRAY
44197: PUSH
44198: FOR_IN
44199: IFFALSE 44226
// if IsNotFull ( k ) then
44201: LD_VAR 0 8
44205: PPUSH
44206: CALL 72564 0 1
44210: IFFALSE 44224
// begin e := k ;
44212: LD_ADDR_VAR 0 7
44216: PUSH
44217: LD_VAR 0 8
44221: ST_TO_ADDR
// break ;
44222: GO 44226
// end ;
44224: GO 44198
44226: POP
44227: POP
// if e and not UnitGoingToBuilding ( p , e ) then
44228: LD_VAR 0 7
44232: PUSH
44233: LD_VAR 0 5
44237: PPUSH
44238: LD_VAR 0 7
44242: PPUSH
44243: CALL 106723 0 2
44247: NOT
44248: AND
44249: IFFALSE 44308
// begin if IsInUnit ( p ) then
44251: LD_VAR 0 5
44255: PPUSH
44256: CALL_OW 310
44260: IFFALSE 44271
// ComExitBuilding ( p ) ;
44262: LD_VAR 0 5
44266: PPUSH
44267: CALL_OW 122
// ComEnterUnit ( p , e ) ;
44271: LD_VAR 0 5
44275: PPUSH
44276: LD_VAR 0 7
44280: PPUSH
44281: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
44285: LD_VAR 0 5
44289: PPUSH
44290: LD_VAR 0 3
44294: PPUSH
44295: CALL_OW 183
// AddComExitBuilding ( p ) ;
44299: LD_VAR 0 5
44303: PPUSH
44304: CALL_OW 182
// end ; end ;
44308: GO 44156
44310: POP
44311: POP
// end ;
44312: GO 44122
44314: POP
44315: POP
// end ;
44316: GO 43886
44318: POP
44319: POP
// end ;
44320: LD_VAR 0 1
44324: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
44325: LD_INT 0
44327: PPUSH
44328: PPUSH
44329: PPUSH
44330: PPUSH
44331: PPUSH
44332: PPUSH
44333: PPUSH
44334: PPUSH
44335: PPUSH
44336: PPUSH
44337: PPUSH
44338: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
44339: LD_ADDR_VAR 0 2
44343: PUSH
44344: LD_INT 0
44346: PUSH
44347: LD_INT 0
44349: PUSH
44350: LD_INT 0
44352: PUSH
44353: LD_INT 0
44355: PUSH
44356: EMPTY
44357: LIST
44358: LIST
44359: LIST
44360: LIST
44361: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
44362: LD_VAR 0 1
44366: NOT
44367: PUSH
44368: LD_EXP 102
44372: PUSH
44373: LD_VAR 0 1
44377: ARRAY
44378: NOT
44379: OR
44380: PUSH
44381: LD_EXP 102
44385: PUSH
44386: LD_VAR 0 1
44390: ARRAY
44391: PPUSH
44392: LD_INT 2
44394: PUSH
44395: LD_INT 30
44397: PUSH
44398: LD_INT 0
44400: PUSH
44401: EMPTY
44402: LIST
44403: LIST
44404: PUSH
44405: LD_INT 30
44407: PUSH
44408: LD_INT 1
44410: PUSH
44411: EMPTY
44412: LIST
44413: LIST
44414: PUSH
44415: EMPTY
44416: LIST
44417: LIST
44418: LIST
44419: PPUSH
44420: CALL_OW 72
44424: NOT
44425: OR
44426: IFFALSE 44430
// exit ;
44428: GO 47933
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
44430: LD_ADDR_VAR 0 4
44434: PUSH
44435: LD_EXP 102
44439: PUSH
44440: LD_VAR 0 1
44444: ARRAY
44445: PPUSH
44446: LD_INT 2
44448: PUSH
44449: LD_INT 25
44451: PUSH
44452: LD_INT 1
44454: PUSH
44455: EMPTY
44456: LIST
44457: LIST
44458: PUSH
44459: LD_INT 25
44461: PUSH
44462: LD_INT 2
44464: PUSH
44465: EMPTY
44466: LIST
44467: LIST
44468: PUSH
44469: LD_INT 25
44471: PUSH
44472: LD_INT 3
44474: PUSH
44475: EMPTY
44476: LIST
44477: LIST
44478: PUSH
44479: LD_INT 25
44481: PUSH
44482: LD_INT 4
44484: PUSH
44485: EMPTY
44486: LIST
44487: LIST
44488: PUSH
44489: LD_INT 25
44491: PUSH
44492: LD_INT 5
44494: PUSH
44495: EMPTY
44496: LIST
44497: LIST
44498: PUSH
44499: LD_INT 25
44501: PUSH
44502: LD_INT 8
44504: PUSH
44505: EMPTY
44506: LIST
44507: LIST
44508: PUSH
44509: LD_INT 25
44511: PUSH
44512: LD_INT 9
44514: PUSH
44515: EMPTY
44516: LIST
44517: LIST
44518: PUSH
44519: EMPTY
44520: LIST
44521: LIST
44522: LIST
44523: LIST
44524: LIST
44525: LIST
44526: LIST
44527: LIST
44528: PPUSH
44529: CALL_OW 72
44533: ST_TO_ADDR
// if not tmp then
44534: LD_VAR 0 4
44538: NOT
44539: IFFALSE 44543
// exit ;
44541: GO 47933
// for i in tmp do
44543: LD_ADDR_VAR 0 3
44547: PUSH
44548: LD_VAR 0 4
44552: PUSH
44553: FOR_IN
44554: IFFALSE 44585
// if GetTag ( i ) then
44556: LD_VAR 0 3
44560: PPUSH
44561: CALL_OW 110
44565: IFFALSE 44583
// tmp := tmp diff i ;
44567: LD_ADDR_VAR 0 4
44571: PUSH
44572: LD_VAR 0 4
44576: PUSH
44577: LD_VAR 0 3
44581: DIFF
44582: ST_TO_ADDR
44583: GO 44553
44585: POP
44586: POP
// if not tmp then
44587: LD_VAR 0 4
44591: NOT
44592: IFFALSE 44596
// exit ;
44594: GO 47933
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
44596: LD_ADDR_VAR 0 5
44600: PUSH
44601: LD_EXP 102
44605: PUSH
44606: LD_VAR 0 1
44610: ARRAY
44611: PPUSH
44612: LD_INT 2
44614: PUSH
44615: LD_INT 25
44617: PUSH
44618: LD_INT 1
44620: PUSH
44621: EMPTY
44622: LIST
44623: LIST
44624: PUSH
44625: LD_INT 25
44627: PUSH
44628: LD_INT 5
44630: PUSH
44631: EMPTY
44632: LIST
44633: LIST
44634: PUSH
44635: LD_INT 25
44637: PUSH
44638: LD_INT 8
44640: PUSH
44641: EMPTY
44642: LIST
44643: LIST
44644: PUSH
44645: LD_INT 25
44647: PUSH
44648: LD_INT 9
44650: PUSH
44651: EMPTY
44652: LIST
44653: LIST
44654: PUSH
44655: EMPTY
44656: LIST
44657: LIST
44658: LIST
44659: LIST
44660: LIST
44661: PPUSH
44662: CALL_OW 72
44666: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
44667: LD_ADDR_VAR 0 6
44671: PUSH
44672: LD_EXP 102
44676: PUSH
44677: LD_VAR 0 1
44681: ARRAY
44682: PPUSH
44683: LD_INT 25
44685: PUSH
44686: LD_INT 2
44688: PUSH
44689: EMPTY
44690: LIST
44691: LIST
44692: PPUSH
44693: CALL_OW 72
44697: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
44698: LD_ADDR_VAR 0 7
44702: PUSH
44703: LD_EXP 102
44707: PUSH
44708: LD_VAR 0 1
44712: ARRAY
44713: PPUSH
44714: LD_INT 25
44716: PUSH
44717: LD_INT 3
44719: PUSH
44720: EMPTY
44721: LIST
44722: LIST
44723: PPUSH
44724: CALL_OW 72
44728: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
44729: LD_ADDR_VAR 0 8
44733: PUSH
44734: LD_EXP 102
44738: PUSH
44739: LD_VAR 0 1
44743: ARRAY
44744: PPUSH
44745: LD_INT 25
44747: PUSH
44748: LD_INT 4
44750: PUSH
44751: EMPTY
44752: LIST
44753: LIST
44754: PUSH
44755: LD_INT 24
44757: PUSH
44758: LD_INT 251
44760: PUSH
44761: EMPTY
44762: LIST
44763: LIST
44764: PUSH
44765: EMPTY
44766: LIST
44767: LIST
44768: PPUSH
44769: CALL_OW 72
44773: ST_TO_ADDR
// if mc_is_defending [ base ] then
44774: LD_EXP 145
44778: PUSH
44779: LD_VAR 0 1
44783: ARRAY
44784: IFFALSE 45245
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
44786: LD_ADDR_EXP 144
44790: PUSH
44791: LD_EXP 144
44795: PPUSH
44796: LD_VAR 0 1
44800: PPUSH
44801: LD_INT 4
44803: PPUSH
44804: CALL_OW 1
44808: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
44809: LD_ADDR_VAR 0 12
44813: PUSH
44814: LD_EXP 102
44818: PUSH
44819: LD_VAR 0 1
44823: ARRAY
44824: PPUSH
44825: LD_INT 2
44827: PUSH
44828: LD_INT 30
44830: PUSH
44831: LD_INT 4
44833: PUSH
44834: EMPTY
44835: LIST
44836: LIST
44837: PUSH
44838: LD_INT 30
44840: PUSH
44841: LD_INT 5
44843: PUSH
44844: EMPTY
44845: LIST
44846: LIST
44847: PUSH
44848: EMPTY
44849: LIST
44850: LIST
44851: LIST
44852: PPUSH
44853: CALL_OW 72
44857: ST_TO_ADDR
// if not b then
44858: LD_VAR 0 12
44862: NOT
44863: IFFALSE 44867
// exit ;
44865: GO 47933
// p := [ ] ;
44867: LD_ADDR_VAR 0 11
44871: PUSH
44872: EMPTY
44873: ST_TO_ADDR
// if sci >= 2 then
44874: LD_VAR 0 8
44878: PUSH
44879: LD_INT 2
44881: GREATEREQUAL
44882: IFFALSE 44913
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
44884: LD_ADDR_VAR 0 8
44888: PUSH
44889: LD_VAR 0 8
44893: PUSH
44894: LD_INT 1
44896: ARRAY
44897: PUSH
44898: LD_VAR 0 8
44902: PUSH
44903: LD_INT 2
44905: ARRAY
44906: PUSH
44907: EMPTY
44908: LIST
44909: LIST
44910: ST_TO_ADDR
44911: GO 44974
// if sci = 1 then
44913: LD_VAR 0 8
44917: PUSH
44918: LD_INT 1
44920: EQUAL
44921: IFFALSE 44942
// sci := [ sci [ 1 ] ] else
44923: LD_ADDR_VAR 0 8
44927: PUSH
44928: LD_VAR 0 8
44932: PUSH
44933: LD_INT 1
44935: ARRAY
44936: PUSH
44937: EMPTY
44938: LIST
44939: ST_TO_ADDR
44940: GO 44974
// if sci = 0 then
44942: LD_VAR 0 8
44946: PUSH
44947: LD_INT 0
44949: EQUAL
44950: IFFALSE 44974
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
44952: LD_ADDR_VAR 0 11
44956: PUSH
44957: LD_VAR 0 4
44961: PPUSH
44962: LD_INT 4
44964: PPUSH
44965: CALL 106595 0 2
44969: PUSH
44970: LD_INT 1
44972: ARRAY
44973: ST_TO_ADDR
// if eng > 4 then
44974: LD_VAR 0 6
44978: PUSH
44979: LD_INT 4
44981: GREATER
44982: IFFALSE 45028
// for i = eng downto 4 do
44984: LD_ADDR_VAR 0 3
44988: PUSH
44989: DOUBLE
44990: LD_VAR 0 6
44994: INC
44995: ST_TO_ADDR
44996: LD_INT 4
44998: PUSH
44999: FOR_DOWNTO
45000: IFFALSE 45026
// eng := eng diff eng [ i ] ;
45002: LD_ADDR_VAR 0 6
45006: PUSH
45007: LD_VAR 0 6
45011: PUSH
45012: LD_VAR 0 6
45016: PUSH
45017: LD_VAR 0 3
45021: ARRAY
45022: DIFF
45023: ST_TO_ADDR
45024: GO 44999
45026: POP
45027: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
45028: LD_ADDR_VAR 0 4
45032: PUSH
45033: LD_VAR 0 4
45037: PUSH
45038: LD_VAR 0 5
45042: PUSH
45043: LD_VAR 0 6
45047: UNION
45048: PUSH
45049: LD_VAR 0 7
45053: UNION
45054: PUSH
45055: LD_VAR 0 8
45059: UNION
45060: DIFF
45061: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
45062: LD_ADDR_VAR 0 13
45066: PUSH
45067: LD_EXP 102
45071: PUSH
45072: LD_VAR 0 1
45076: ARRAY
45077: PPUSH
45078: LD_INT 2
45080: PUSH
45081: LD_INT 30
45083: PUSH
45084: LD_INT 32
45086: PUSH
45087: EMPTY
45088: LIST
45089: LIST
45090: PUSH
45091: LD_INT 30
45093: PUSH
45094: LD_INT 31
45096: PUSH
45097: EMPTY
45098: LIST
45099: LIST
45100: PUSH
45101: EMPTY
45102: LIST
45103: LIST
45104: LIST
45105: PPUSH
45106: CALL_OW 72
45110: PUSH
45111: LD_EXP 102
45115: PUSH
45116: LD_VAR 0 1
45120: ARRAY
45121: PPUSH
45122: LD_INT 2
45124: PUSH
45125: LD_INT 30
45127: PUSH
45128: LD_INT 4
45130: PUSH
45131: EMPTY
45132: LIST
45133: LIST
45134: PUSH
45135: LD_INT 30
45137: PUSH
45138: LD_INT 5
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: PUSH
45145: EMPTY
45146: LIST
45147: LIST
45148: LIST
45149: PPUSH
45150: CALL_OW 72
45154: PUSH
45155: LD_INT 6
45157: MUL
45158: PLUS
45159: ST_TO_ADDR
// if bcount < tmp then
45160: LD_VAR 0 13
45164: PUSH
45165: LD_VAR 0 4
45169: LESS
45170: IFFALSE 45216
// for i = tmp downto bcount do
45172: LD_ADDR_VAR 0 3
45176: PUSH
45177: DOUBLE
45178: LD_VAR 0 4
45182: INC
45183: ST_TO_ADDR
45184: LD_VAR 0 13
45188: PUSH
45189: FOR_DOWNTO
45190: IFFALSE 45214
// tmp := Delete ( tmp , tmp ) ;
45192: LD_ADDR_VAR 0 4
45196: PUSH
45197: LD_VAR 0 4
45201: PPUSH
45202: LD_VAR 0 4
45206: PPUSH
45207: CALL_OW 3
45211: ST_TO_ADDR
45212: GO 45189
45214: POP
45215: POP
// result := [ tmp , 0 , 0 , p ] ;
45216: LD_ADDR_VAR 0 2
45220: PUSH
45221: LD_VAR 0 4
45225: PUSH
45226: LD_INT 0
45228: PUSH
45229: LD_INT 0
45231: PUSH
45232: LD_VAR 0 11
45236: PUSH
45237: EMPTY
45238: LIST
45239: LIST
45240: LIST
45241: LIST
45242: ST_TO_ADDR
// exit ;
45243: GO 47933
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
45245: LD_EXP 102
45249: PUSH
45250: LD_VAR 0 1
45254: ARRAY
45255: PPUSH
45256: LD_INT 2
45258: PUSH
45259: LD_INT 30
45261: PUSH
45262: LD_INT 6
45264: PUSH
45265: EMPTY
45266: LIST
45267: LIST
45268: PUSH
45269: LD_INT 30
45271: PUSH
45272: LD_INT 7
45274: PUSH
45275: EMPTY
45276: LIST
45277: LIST
45278: PUSH
45279: LD_INT 30
45281: PUSH
45282: LD_INT 8
45284: PUSH
45285: EMPTY
45286: LIST
45287: LIST
45288: PUSH
45289: EMPTY
45290: LIST
45291: LIST
45292: LIST
45293: LIST
45294: PPUSH
45295: CALL_OW 72
45299: NOT
45300: PUSH
45301: LD_EXP 102
45305: PUSH
45306: LD_VAR 0 1
45310: ARRAY
45311: PPUSH
45312: LD_INT 30
45314: PUSH
45315: LD_INT 3
45317: PUSH
45318: EMPTY
45319: LIST
45320: LIST
45321: PPUSH
45322: CALL_OW 72
45326: NOT
45327: AND
45328: IFFALSE 45400
// begin if eng = tmp then
45330: LD_VAR 0 6
45334: PUSH
45335: LD_VAR 0 4
45339: EQUAL
45340: IFFALSE 45344
// exit ;
45342: GO 47933
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
45344: LD_ADDR_EXP 144
45348: PUSH
45349: LD_EXP 144
45353: PPUSH
45354: LD_VAR 0 1
45358: PPUSH
45359: LD_INT 1
45361: PPUSH
45362: CALL_OW 1
45366: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
45367: LD_ADDR_VAR 0 2
45371: PUSH
45372: LD_INT 0
45374: PUSH
45375: LD_VAR 0 4
45379: PUSH
45380: LD_VAR 0 6
45384: DIFF
45385: PUSH
45386: LD_INT 0
45388: PUSH
45389: LD_INT 0
45391: PUSH
45392: EMPTY
45393: LIST
45394: LIST
45395: LIST
45396: LIST
45397: ST_TO_ADDR
// exit ;
45398: GO 47933
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
45400: LD_EXP 129
45404: PUSH
45405: LD_EXP 128
45409: PUSH
45410: LD_VAR 0 1
45414: ARRAY
45415: ARRAY
45416: PUSH
45417: LD_EXP 102
45421: PUSH
45422: LD_VAR 0 1
45426: ARRAY
45427: PPUSH
45428: LD_INT 2
45430: PUSH
45431: LD_INT 30
45433: PUSH
45434: LD_INT 6
45436: PUSH
45437: EMPTY
45438: LIST
45439: LIST
45440: PUSH
45441: LD_INT 30
45443: PUSH
45444: LD_INT 7
45446: PUSH
45447: EMPTY
45448: LIST
45449: LIST
45450: PUSH
45451: LD_INT 30
45453: PUSH
45454: LD_INT 8
45456: PUSH
45457: EMPTY
45458: LIST
45459: LIST
45460: PUSH
45461: EMPTY
45462: LIST
45463: LIST
45464: LIST
45465: LIST
45466: PPUSH
45467: CALL_OW 72
45471: AND
45472: PUSH
45473: LD_EXP 102
45477: PUSH
45478: LD_VAR 0 1
45482: ARRAY
45483: PPUSH
45484: LD_INT 30
45486: PUSH
45487: LD_INT 3
45489: PUSH
45490: EMPTY
45491: LIST
45492: LIST
45493: PPUSH
45494: CALL_OW 72
45498: NOT
45499: AND
45500: IFFALSE 45714
// begin if sci >= 6 then
45502: LD_VAR 0 8
45506: PUSH
45507: LD_INT 6
45509: GREATEREQUAL
45510: IFFALSE 45514
// exit ;
45512: GO 47933
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
45514: LD_ADDR_EXP 144
45518: PUSH
45519: LD_EXP 144
45523: PPUSH
45524: LD_VAR 0 1
45528: PPUSH
45529: LD_INT 2
45531: PPUSH
45532: CALL_OW 1
45536: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
45537: LD_ADDR_VAR 0 9
45541: PUSH
45542: LD_VAR 0 4
45546: PUSH
45547: LD_VAR 0 8
45551: DIFF
45552: PPUSH
45553: LD_INT 4
45555: PPUSH
45556: CALL 106595 0 2
45560: ST_TO_ADDR
// p := [ ] ;
45561: LD_ADDR_VAR 0 11
45565: PUSH
45566: EMPTY
45567: ST_TO_ADDR
// if sci < 6 and sort > 6 then
45568: LD_VAR 0 8
45572: PUSH
45573: LD_INT 6
45575: LESS
45576: PUSH
45577: LD_VAR 0 9
45581: PUSH
45582: LD_INT 6
45584: GREATER
45585: AND
45586: IFFALSE 45667
// begin for i = 1 to 6 - sci do
45588: LD_ADDR_VAR 0 3
45592: PUSH
45593: DOUBLE
45594: LD_INT 1
45596: DEC
45597: ST_TO_ADDR
45598: LD_INT 6
45600: PUSH
45601: LD_VAR 0 8
45605: MINUS
45606: PUSH
45607: FOR_TO
45608: IFFALSE 45663
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
45610: LD_ADDR_VAR 0 11
45614: PUSH
45615: LD_VAR 0 11
45619: PPUSH
45620: LD_VAR 0 11
45624: PUSH
45625: LD_INT 1
45627: PLUS
45628: PPUSH
45629: LD_VAR 0 9
45633: PUSH
45634: LD_INT 1
45636: ARRAY
45637: PPUSH
45638: CALL_OW 2
45642: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
45643: LD_ADDR_VAR 0 9
45647: PUSH
45648: LD_VAR 0 9
45652: PPUSH
45653: LD_INT 1
45655: PPUSH
45656: CALL_OW 3
45660: ST_TO_ADDR
// end ;
45661: GO 45607
45663: POP
45664: POP
// end else
45665: GO 45687
// if sort then
45667: LD_VAR 0 9
45671: IFFALSE 45687
// p := sort [ 1 ] ;
45673: LD_ADDR_VAR 0 11
45677: PUSH
45678: LD_VAR 0 9
45682: PUSH
45683: LD_INT 1
45685: ARRAY
45686: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
45687: LD_ADDR_VAR 0 2
45691: PUSH
45692: LD_INT 0
45694: PUSH
45695: LD_INT 0
45697: PUSH
45698: LD_INT 0
45700: PUSH
45701: LD_VAR 0 11
45705: PUSH
45706: EMPTY
45707: LIST
45708: LIST
45709: LIST
45710: LIST
45711: ST_TO_ADDR
// exit ;
45712: GO 47933
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
45714: LD_EXP 129
45718: PUSH
45719: LD_EXP 128
45723: PUSH
45724: LD_VAR 0 1
45728: ARRAY
45729: ARRAY
45730: PUSH
45731: LD_EXP 102
45735: PUSH
45736: LD_VAR 0 1
45740: ARRAY
45741: PPUSH
45742: LD_INT 2
45744: PUSH
45745: LD_INT 30
45747: PUSH
45748: LD_INT 6
45750: PUSH
45751: EMPTY
45752: LIST
45753: LIST
45754: PUSH
45755: LD_INT 30
45757: PUSH
45758: LD_INT 7
45760: PUSH
45761: EMPTY
45762: LIST
45763: LIST
45764: PUSH
45765: LD_INT 30
45767: PUSH
45768: LD_INT 8
45770: PUSH
45771: EMPTY
45772: LIST
45773: LIST
45774: PUSH
45775: EMPTY
45776: LIST
45777: LIST
45778: LIST
45779: LIST
45780: PPUSH
45781: CALL_OW 72
45785: AND
45786: PUSH
45787: LD_EXP 102
45791: PUSH
45792: LD_VAR 0 1
45796: ARRAY
45797: PPUSH
45798: LD_INT 30
45800: PUSH
45801: LD_INT 3
45803: PUSH
45804: EMPTY
45805: LIST
45806: LIST
45807: PPUSH
45808: CALL_OW 72
45812: AND
45813: IFFALSE 46547
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
45815: LD_ADDR_EXP 144
45819: PUSH
45820: LD_EXP 144
45824: PPUSH
45825: LD_VAR 0 1
45829: PPUSH
45830: LD_INT 3
45832: PPUSH
45833: CALL_OW 1
45837: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
45838: LD_ADDR_VAR 0 2
45842: PUSH
45843: LD_INT 0
45845: PUSH
45846: LD_INT 0
45848: PUSH
45849: LD_INT 0
45851: PUSH
45852: LD_INT 0
45854: PUSH
45855: EMPTY
45856: LIST
45857: LIST
45858: LIST
45859: LIST
45860: ST_TO_ADDR
// if not eng then
45861: LD_VAR 0 6
45865: NOT
45866: IFFALSE 45929
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
45868: LD_ADDR_VAR 0 11
45872: PUSH
45873: LD_VAR 0 4
45877: PPUSH
45878: LD_INT 2
45880: PPUSH
45881: CALL 106595 0 2
45885: PUSH
45886: LD_INT 1
45888: ARRAY
45889: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
45890: LD_ADDR_VAR 0 2
45894: PUSH
45895: LD_VAR 0 2
45899: PPUSH
45900: LD_INT 2
45902: PPUSH
45903: LD_VAR 0 11
45907: PPUSH
45908: CALL_OW 1
45912: ST_TO_ADDR
// tmp := tmp diff p ;
45913: LD_ADDR_VAR 0 4
45917: PUSH
45918: LD_VAR 0 4
45922: PUSH
45923: LD_VAR 0 11
45927: DIFF
45928: ST_TO_ADDR
// end ; if tmp and sci < 6 then
45929: LD_VAR 0 4
45933: PUSH
45934: LD_VAR 0 8
45938: PUSH
45939: LD_INT 6
45941: LESS
45942: AND
45943: IFFALSE 46131
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
45945: LD_ADDR_VAR 0 9
45949: PUSH
45950: LD_VAR 0 4
45954: PUSH
45955: LD_VAR 0 8
45959: PUSH
45960: LD_VAR 0 7
45964: UNION
45965: DIFF
45966: PPUSH
45967: LD_INT 4
45969: PPUSH
45970: CALL 106595 0 2
45974: ST_TO_ADDR
// p := [ ] ;
45975: LD_ADDR_VAR 0 11
45979: PUSH
45980: EMPTY
45981: ST_TO_ADDR
// if sort then
45982: LD_VAR 0 9
45986: IFFALSE 46102
// for i = 1 to 6 - sci do
45988: LD_ADDR_VAR 0 3
45992: PUSH
45993: DOUBLE
45994: LD_INT 1
45996: DEC
45997: ST_TO_ADDR
45998: LD_INT 6
46000: PUSH
46001: LD_VAR 0 8
46005: MINUS
46006: PUSH
46007: FOR_TO
46008: IFFALSE 46100
// begin if i = sort then
46010: LD_VAR 0 3
46014: PUSH
46015: LD_VAR 0 9
46019: EQUAL
46020: IFFALSE 46024
// break ;
46022: GO 46100
// if GetClass ( i ) = 4 then
46024: LD_VAR 0 3
46028: PPUSH
46029: CALL_OW 257
46033: PUSH
46034: LD_INT 4
46036: EQUAL
46037: IFFALSE 46041
// continue ;
46039: GO 46007
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46041: LD_ADDR_VAR 0 11
46045: PUSH
46046: LD_VAR 0 11
46050: PPUSH
46051: LD_VAR 0 11
46055: PUSH
46056: LD_INT 1
46058: PLUS
46059: PPUSH
46060: LD_VAR 0 9
46064: PUSH
46065: LD_VAR 0 3
46069: ARRAY
46070: PPUSH
46071: CALL_OW 2
46075: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46076: LD_ADDR_VAR 0 4
46080: PUSH
46081: LD_VAR 0 4
46085: PUSH
46086: LD_VAR 0 9
46090: PUSH
46091: LD_VAR 0 3
46095: ARRAY
46096: DIFF
46097: ST_TO_ADDR
// end ;
46098: GO 46007
46100: POP
46101: POP
// if p then
46102: LD_VAR 0 11
46106: IFFALSE 46131
// result := Replace ( result , 4 , p ) ;
46108: LD_ADDR_VAR 0 2
46112: PUSH
46113: LD_VAR 0 2
46117: PPUSH
46118: LD_INT 4
46120: PPUSH
46121: LD_VAR 0 11
46125: PPUSH
46126: CALL_OW 1
46130: ST_TO_ADDR
// end ; if tmp and mech < 6 then
46131: LD_VAR 0 4
46135: PUSH
46136: LD_VAR 0 7
46140: PUSH
46141: LD_INT 6
46143: LESS
46144: AND
46145: IFFALSE 46333
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
46147: LD_ADDR_VAR 0 9
46151: PUSH
46152: LD_VAR 0 4
46156: PUSH
46157: LD_VAR 0 8
46161: PUSH
46162: LD_VAR 0 7
46166: UNION
46167: DIFF
46168: PPUSH
46169: LD_INT 3
46171: PPUSH
46172: CALL 106595 0 2
46176: ST_TO_ADDR
// p := [ ] ;
46177: LD_ADDR_VAR 0 11
46181: PUSH
46182: EMPTY
46183: ST_TO_ADDR
// if sort then
46184: LD_VAR 0 9
46188: IFFALSE 46304
// for i = 1 to 6 - mech do
46190: LD_ADDR_VAR 0 3
46194: PUSH
46195: DOUBLE
46196: LD_INT 1
46198: DEC
46199: ST_TO_ADDR
46200: LD_INT 6
46202: PUSH
46203: LD_VAR 0 7
46207: MINUS
46208: PUSH
46209: FOR_TO
46210: IFFALSE 46302
// begin if i = sort then
46212: LD_VAR 0 3
46216: PUSH
46217: LD_VAR 0 9
46221: EQUAL
46222: IFFALSE 46226
// break ;
46224: GO 46302
// if GetClass ( i ) = 3 then
46226: LD_VAR 0 3
46230: PPUSH
46231: CALL_OW 257
46235: PUSH
46236: LD_INT 3
46238: EQUAL
46239: IFFALSE 46243
// continue ;
46241: GO 46209
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46243: LD_ADDR_VAR 0 11
46247: PUSH
46248: LD_VAR 0 11
46252: PPUSH
46253: LD_VAR 0 11
46257: PUSH
46258: LD_INT 1
46260: PLUS
46261: PPUSH
46262: LD_VAR 0 9
46266: PUSH
46267: LD_VAR 0 3
46271: ARRAY
46272: PPUSH
46273: CALL_OW 2
46277: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46278: LD_ADDR_VAR 0 4
46282: PUSH
46283: LD_VAR 0 4
46287: PUSH
46288: LD_VAR 0 9
46292: PUSH
46293: LD_VAR 0 3
46297: ARRAY
46298: DIFF
46299: ST_TO_ADDR
// end ;
46300: GO 46209
46302: POP
46303: POP
// if p then
46304: LD_VAR 0 11
46308: IFFALSE 46333
// result := Replace ( result , 3 , p ) ;
46310: LD_ADDR_VAR 0 2
46314: PUSH
46315: LD_VAR 0 2
46319: PPUSH
46320: LD_INT 3
46322: PPUSH
46323: LD_VAR 0 11
46327: PPUSH
46328: CALL_OW 1
46332: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
46333: LD_VAR 0 4
46337: PUSH
46338: LD_INT 6
46340: GREATER
46341: PUSH
46342: LD_VAR 0 6
46346: PUSH
46347: LD_INT 6
46349: LESS
46350: AND
46351: IFFALSE 46545
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
46353: LD_ADDR_VAR 0 9
46357: PUSH
46358: LD_VAR 0 4
46362: PUSH
46363: LD_VAR 0 8
46367: PUSH
46368: LD_VAR 0 7
46372: UNION
46373: PUSH
46374: LD_VAR 0 6
46378: UNION
46379: DIFF
46380: PPUSH
46381: LD_INT 2
46383: PPUSH
46384: CALL 106595 0 2
46388: ST_TO_ADDR
// p := [ ] ;
46389: LD_ADDR_VAR 0 11
46393: PUSH
46394: EMPTY
46395: ST_TO_ADDR
// if sort then
46396: LD_VAR 0 9
46400: IFFALSE 46516
// for i = 1 to 6 - eng do
46402: LD_ADDR_VAR 0 3
46406: PUSH
46407: DOUBLE
46408: LD_INT 1
46410: DEC
46411: ST_TO_ADDR
46412: LD_INT 6
46414: PUSH
46415: LD_VAR 0 6
46419: MINUS
46420: PUSH
46421: FOR_TO
46422: IFFALSE 46514
// begin if i = sort then
46424: LD_VAR 0 3
46428: PUSH
46429: LD_VAR 0 9
46433: EQUAL
46434: IFFALSE 46438
// break ;
46436: GO 46514
// if GetClass ( i ) = 2 then
46438: LD_VAR 0 3
46442: PPUSH
46443: CALL_OW 257
46447: PUSH
46448: LD_INT 2
46450: EQUAL
46451: IFFALSE 46455
// continue ;
46453: GO 46421
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46455: LD_ADDR_VAR 0 11
46459: PUSH
46460: LD_VAR 0 11
46464: PPUSH
46465: LD_VAR 0 11
46469: PUSH
46470: LD_INT 1
46472: PLUS
46473: PPUSH
46474: LD_VAR 0 9
46478: PUSH
46479: LD_VAR 0 3
46483: ARRAY
46484: PPUSH
46485: CALL_OW 2
46489: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46490: LD_ADDR_VAR 0 4
46494: PUSH
46495: LD_VAR 0 4
46499: PUSH
46500: LD_VAR 0 9
46504: PUSH
46505: LD_VAR 0 3
46509: ARRAY
46510: DIFF
46511: ST_TO_ADDR
// end ;
46512: GO 46421
46514: POP
46515: POP
// if p then
46516: LD_VAR 0 11
46520: IFFALSE 46545
// result := Replace ( result , 2 , p ) ;
46522: LD_ADDR_VAR 0 2
46526: PUSH
46527: LD_VAR 0 2
46531: PPUSH
46532: LD_INT 2
46534: PPUSH
46535: LD_VAR 0 11
46539: PPUSH
46540: CALL_OW 1
46544: ST_TO_ADDR
// end ; exit ;
46545: GO 47933
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
46547: LD_EXP 129
46551: PUSH
46552: LD_EXP 128
46556: PUSH
46557: LD_VAR 0 1
46561: ARRAY
46562: ARRAY
46563: NOT
46564: PUSH
46565: LD_EXP 102
46569: PUSH
46570: LD_VAR 0 1
46574: ARRAY
46575: PPUSH
46576: LD_INT 30
46578: PUSH
46579: LD_INT 3
46581: PUSH
46582: EMPTY
46583: LIST
46584: LIST
46585: PPUSH
46586: CALL_OW 72
46590: AND
46591: PUSH
46592: LD_EXP 107
46596: PUSH
46597: LD_VAR 0 1
46601: ARRAY
46602: AND
46603: IFFALSE 47211
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
46605: LD_ADDR_EXP 144
46609: PUSH
46610: LD_EXP 144
46614: PPUSH
46615: LD_VAR 0 1
46619: PPUSH
46620: LD_INT 5
46622: PPUSH
46623: CALL_OW 1
46627: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
46628: LD_ADDR_VAR 0 2
46632: PUSH
46633: LD_INT 0
46635: PUSH
46636: LD_INT 0
46638: PUSH
46639: LD_INT 0
46641: PUSH
46642: LD_INT 0
46644: PUSH
46645: EMPTY
46646: LIST
46647: LIST
46648: LIST
46649: LIST
46650: ST_TO_ADDR
// if sci > 1 then
46651: LD_VAR 0 8
46655: PUSH
46656: LD_INT 1
46658: GREATER
46659: IFFALSE 46687
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
46661: LD_ADDR_VAR 0 4
46665: PUSH
46666: LD_VAR 0 4
46670: PUSH
46671: LD_VAR 0 8
46675: PUSH
46676: LD_VAR 0 8
46680: PUSH
46681: LD_INT 1
46683: ARRAY
46684: DIFF
46685: DIFF
46686: ST_TO_ADDR
// if tmp and not sci then
46687: LD_VAR 0 4
46691: PUSH
46692: LD_VAR 0 8
46696: NOT
46697: AND
46698: IFFALSE 46767
// begin sort := SortBySkill ( tmp , 4 ) ;
46700: LD_ADDR_VAR 0 9
46704: PUSH
46705: LD_VAR 0 4
46709: PPUSH
46710: LD_INT 4
46712: PPUSH
46713: CALL 106595 0 2
46717: ST_TO_ADDR
// if sort then
46718: LD_VAR 0 9
46722: IFFALSE 46738
// p := sort [ 1 ] ;
46724: LD_ADDR_VAR 0 11
46728: PUSH
46729: LD_VAR 0 9
46733: PUSH
46734: LD_INT 1
46736: ARRAY
46737: ST_TO_ADDR
// if p then
46738: LD_VAR 0 11
46742: IFFALSE 46767
// result := Replace ( result , 4 , p ) ;
46744: LD_ADDR_VAR 0 2
46748: PUSH
46749: LD_VAR 0 2
46753: PPUSH
46754: LD_INT 4
46756: PPUSH
46757: LD_VAR 0 11
46761: PPUSH
46762: CALL_OW 1
46766: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
46767: LD_ADDR_VAR 0 4
46771: PUSH
46772: LD_VAR 0 4
46776: PUSH
46777: LD_VAR 0 7
46781: DIFF
46782: ST_TO_ADDR
// if tmp and mech < 6 then
46783: LD_VAR 0 4
46787: PUSH
46788: LD_VAR 0 7
46792: PUSH
46793: LD_INT 6
46795: LESS
46796: AND
46797: IFFALSE 46985
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
46799: LD_ADDR_VAR 0 9
46803: PUSH
46804: LD_VAR 0 4
46808: PUSH
46809: LD_VAR 0 8
46813: PUSH
46814: LD_VAR 0 7
46818: UNION
46819: DIFF
46820: PPUSH
46821: LD_INT 3
46823: PPUSH
46824: CALL 106595 0 2
46828: ST_TO_ADDR
// p := [ ] ;
46829: LD_ADDR_VAR 0 11
46833: PUSH
46834: EMPTY
46835: ST_TO_ADDR
// if sort then
46836: LD_VAR 0 9
46840: IFFALSE 46956
// for i = 1 to 6 - mech do
46842: LD_ADDR_VAR 0 3
46846: PUSH
46847: DOUBLE
46848: LD_INT 1
46850: DEC
46851: ST_TO_ADDR
46852: LD_INT 6
46854: PUSH
46855: LD_VAR 0 7
46859: MINUS
46860: PUSH
46861: FOR_TO
46862: IFFALSE 46954
// begin if i = sort then
46864: LD_VAR 0 3
46868: PUSH
46869: LD_VAR 0 9
46873: EQUAL
46874: IFFALSE 46878
// break ;
46876: GO 46954
// if GetClass ( i ) = 3 then
46878: LD_VAR 0 3
46882: PPUSH
46883: CALL_OW 257
46887: PUSH
46888: LD_INT 3
46890: EQUAL
46891: IFFALSE 46895
// continue ;
46893: GO 46861
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46895: LD_ADDR_VAR 0 11
46899: PUSH
46900: LD_VAR 0 11
46904: PPUSH
46905: LD_VAR 0 11
46909: PUSH
46910: LD_INT 1
46912: PLUS
46913: PPUSH
46914: LD_VAR 0 9
46918: PUSH
46919: LD_VAR 0 3
46923: ARRAY
46924: PPUSH
46925: CALL_OW 2
46929: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46930: LD_ADDR_VAR 0 4
46934: PUSH
46935: LD_VAR 0 4
46939: PUSH
46940: LD_VAR 0 9
46944: PUSH
46945: LD_VAR 0 3
46949: ARRAY
46950: DIFF
46951: ST_TO_ADDR
// end ;
46952: GO 46861
46954: POP
46955: POP
// if p then
46956: LD_VAR 0 11
46960: IFFALSE 46985
// result := Replace ( result , 3 , p ) ;
46962: LD_ADDR_VAR 0 2
46966: PUSH
46967: LD_VAR 0 2
46971: PPUSH
46972: LD_INT 3
46974: PPUSH
46975: LD_VAR 0 11
46979: PPUSH
46980: CALL_OW 1
46984: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
46985: LD_ADDR_VAR 0 4
46989: PUSH
46990: LD_VAR 0 4
46994: PUSH
46995: LD_VAR 0 6
46999: DIFF
47000: ST_TO_ADDR
// if tmp and eng < 6 then
47001: LD_VAR 0 4
47005: PUSH
47006: LD_VAR 0 6
47010: PUSH
47011: LD_INT 6
47013: LESS
47014: AND
47015: IFFALSE 47209
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
47017: LD_ADDR_VAR 0 9
47021: PUSH
47022: LD_VAR 0 4
47026: PUSH
47027: LD_VAR 0 8
47031: PUSH
47032: LD_VAR 0 7
47036: UNION
47037: PUSH
47038: LD_VAR 0 6
47042: UNION
47043: DIFF
47044: PPUSH
47045: LD_INT 2
47047: PPUSH
47048: CALL 106595 0 2
47052: ST_TO_ADDR
// p := [ ] ;
47053: LD_ADDR_VAR 0 11
47057: PUSH
47058: EMPTY
47059: ST_TO_ADDR
// if sort then
47060: LD_VAR 0 9
47064: IFFALSE 47180
// for i = 1 to 6 - eng do
47066: LD_ADDR_VAR 0 3
47070: PUSH
47071: DOUBLE
47072: LD_INT 1
47074: DEC
47075: ST_TO_ADDR
47076: LD_INT 6
47078: PUSH
47079: LD_VAR 0 6
47083: MINUS
47084: PUSH
47085: FOR_TO
47086: IFFALSE 47178
// begin if i = sort then
47088: LD_VAR 0 3
47092: PUSH
47093: LD_VAR 0 9
47097: EQUAL
47098: IFFALSE 47102
// break ;
47100: GO 47178
// if GetClass ( i ) = 2 then
47102: LD_VAR 0 3
47106: PPUSH
47107: CALL_OW 257
47111: PUSH
47112: LD_INT 2
47114: EQUAL
47115: IFFALSE 47119
// continue ;
47117: GO 47085
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47119: LD_ADDR_VAR 0 11
47123: PUSH
47124: LD_VAR 0 11
47128: PPUSH
47129: LD_VAR 0 11
47133: PUSH
47134: LD_INT 1
47136: PLUS
47137: PPUSH
47138: LD_VAR 0 9
47142: PUSH
47143: LD_VAR 0 3
47147: ARRAY
47148: PPUSH
47149: CALL_OW 2
47153: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47154: LD_ADDR_VAR 0 4
47158: PUSH
47159: LD_VAR 0 4
47163: PUSH
47164: LD_VAR 0 9
47168: PUSH
47169: LD_VAR 0 3
47173: ARRAY
47174: DIFF
47175: ST_TO_ADDR
// end ;
47176: GO 47085
47178: POP
47179: POP
// if p then
47180: LD_VAR 0 11
47184: IFFALSE 47209
// result := Replace ( result , 2 , p ) ;
47186: LD_ADDR_VAR 0 2
47190: PUSH
47191: LD_VAR 0 2
47195: PPUSH
47196: LD_INT 2
47198: PPUSH
47199: LD_VAR 0 11
47203: PPUSH
47204: CALL_OW 1
47208: ST_TO_ADDR
// end ; exit ;
47209: GO 47933
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
47211: LD_EXP 129
47215: PUSH
47216: LD_EXP 128
47220: PUSH
47221: LD_VAR 0 1
47225: ARRAY
47226: ARRAY
47227: NOT
47228: PUSH
47229: LD_EXP 102
47233: PUSH
47234: LD_VAR 0 1
47238: ARRAY
47239: PPUSH
47240: LD_INT 30
47242: PUSH
47243: LD_INT 3
47245: PUSH
47246: EMPTY
47247: LIST
47248: LIST
47249: PPUSH
47250: CALL_OW 72
47254: AND
47255: PUSH
47256: LD_EXP 107
47260: PUSH
47261: LD_VAR 0 1
47265: ARRAY
47266: NOT
47267: AND
47268: IFFALSE 47933
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
47270: LD_ADDR_EXP 144
47274: PUSH
47275: LD_EXP 144
47279: PPUSH
47280: LD_VAR 0 1
47284: PPUSH
47285: LD_INT 6
47287: PPUSH
47288: CALL_OW 1
47292: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
47293: LD_ADDR_VAR 0 2
47297: PUSH
47298: LD_INT 0
47300: PUSH
47301: LD_INT 0
47303: PUSH
47304: LD_INT 0
47306: PUSH
47307: LD_INT 0
47309: PUSH
47310: EMPTY
47311: LIST
47312: LIST
47313: LIST
47314: LIST
47315: ST_TO_ADDR
// if sci >= 1 then
47316: LD_VAR 0 8
47320: PUSH
47321: LD_INT 1
47323: GREATEREQUAL
47324: IFFALSE 47346
// tmp := tmp diff sci [ 1 ] ;
47326: LD_ADDR_VAR 0 4
47330: PUSH
47331: LD_VAR 0 4
47335: PUSH
47336: LD_VAR 0 8
47340: PUSH
47341: LD_INT 1
47343: ARRAY
47344: DIFF
47345: ST_TO_ADDR
// if tmp and not sci then
47346: LD_VAR 0 4
47350: PUSH
47351: LD_VAR 0 8
47355: NOT
47356: AND
47357: IFFALSE 47426
// begin sort := SortBySkill ( tmp , 4 ) ;
47359: LD_ADDR_VAR 0 9
47363: PUSH
47364: LD_VAR 0 4
47368: PPUSH
47369: LD_INT 4
47371: PPUSH
47372: CALL 106595 0 2
47376: ST_TO_ADDR
// if sort then
47377: LD_VAR 0 9
47381: IFFALSE 47397
// p := sort [ 1 ] ;
47383: LD_ADDR_VAR 0 11
47387: PUSH
47388: LD_VAR 0 9
47392: PUSH
47393: LD_INT 1
47395: ARRAY
47396: ST_TO_ADDR
// if p then
47397: LD_VAR 0 11
47401: IFFALSE 47426
// result := Replace ( result , 4 , p ) ;
47403: LD_ADDR_VAR 0 2
47407: PUSH
47408: LD_VAR 0 2
47412: PPUSH
47413: LD_INT 4
47415: PPUSH
47416: LD_VAR 0 11
47420: PPUSH
47421: CALL_OW 1
47425: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
47426: LD_ADDR_VAR 0 4
47430: PUSH
47431: LD_VAR 0 4
47435: PUSH
47436: LD_VAR 0 7
47440: DIFF
47441: ST_TO_ADDR
// if tmp and mech < 6 then
47442: LD_VAR 0 4
47446: PUSH
47447: LD_VAR 0 7
47451: PUSH
47452: LD_INT 6
47454: LESS
47455: AND
47456: IFFALSE 47638
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
47458: LD_ADDR_VAR 0 9
47462: PUSH
47463: LD_VAR 0 4
47467: PUSH
47468: LD_VAR 0 7
47472: DIFF
47473: PPUSH
47474: LD_INT 3
47476: PPUSH
47477: CALL 106595 0 2
47481: ST_TO_ADDR
// p := [ ] ;
47482: LD_ADDR_VAR 0 11
47486: PUSH
47487: EMPTY
47488: ST_TO_ADDR
// if sort then
47489: LD_VAR 0 9
47493: IFFALSE 47609
// for i = 1 to 6 - mech do
47495: LD_ADDR_VAR 0 3
47499: PUSH
47500: DOUBLE
47501: LD_INT 1
47503: DEC
47504: ST_TO_ADDR
47505: LD_INT 6
47507: PUSH
47508: LD_VAR 0 7
47512: MINUS
47513: PUSH
47514: FOR_TO
47515: IFFALSE 47607
// begin if i = sort then
47517: LD_VAR 0 3
47521: PUSH
47522: LD_VAR 0 9
47526: EQUAL
47527: IFFALSE 47531
// break ;
47529: GO 47607
// if GetClass ( i ) = 3 then
47531: LD_VAR 0 3
47535: PPUSH
47536: CALL_OW 257
47540: PUSH
47541: LD_INT 3
47543: EQUAL
47544: IFFALSE 47548
// continue ;
47546: GO 47514
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47548: LD_ADDR_VAR 0 11
47552: PUSH
47553: LD_VAR 0 11
47557: PPUSH
47558: LD_VAR 0 11
47562: PUSH
47563: LD_INT 1
47565: PLUS
47566: PPUSH
47567: LD_VAR 0 9
47571: PUSH
47572: LD_VAR 0 3
47576: ARRAY
47577: PPUSH
47578: CALL_OW 2
47582: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47583: LD_ADDR_VAR 0 4
47587: PUSH
47588: LD_VAR 0 4
47592: PUSH
47593: LD_VAR 0 9
47597: PUSH
47598: LD_VAR 0 3
47602: ARRAY
47603: DIFF
47604: ST_TO_ADDR
// end ;
47605: GO 47514
47607: POP
47608: POP
// if p then
47609: LD_VAR 0 11
47613: IFFALSE 47638
// result := Replace ( result , 3 , p ) ;
47615: LD_ADDR_VAR 0 2
47619: PUSH
47620: LD_VAR 0 2
47624: PPUSH
47625: LD_INT 3
47627: PPUSH
47628: LD_VAR 0 11
47632: PPUSH
47633: CALL_OW 1
47637: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
47638: LD_ADDR_VAR 0 4
47642: PUSH
47643: LD_VAR 0 4
47647: PUSH
47648: LD_VAR 0 6
47652: DIFF
47653: ST_TO_ADDR
// if tmp and eng < 4 then
47654: LD_VAR 0 4
47658: PUSH
47659: LD_VAR 0 6
47663: PUSH
47664: LD_INT 4
47666: LESS
47667: AND
47668: IFFALSE 47858
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
47670: LD_ADDR_VAR 0 9
47674: PUSH
47675: LD_VAR 0 4
47679: PUSH
47680: LD_VAR 0 7
47684: PUSH
47685: LD_VAR 0 6
47689: UNION
47690: DIFF
47691: PPUSH
47692: LD_INT 2
47694: PPUSH
47695: CALL 106595 0 2
47699: ST_TO_ADDR
// p := [ ] ;
47700: LD_ADDR_VAR 0 11
47704: PUSH
47705: EMPTY
47706: ST_TO_ADDR
// if sort then
47707: LD_VAR 0 9
47711: IFFALSE 47827
// for i = 1 to 4 - eng do
47713: LD_ADDR_VAR 0 3
47717: PUSH
47718: DOUBLE
47719: LD_INT 1
47721: DEC
47722: ST_TO_ADDR
47723: LD_INT 4
47725: PUSH
47726: LD_VAR 0 6
47730: MINUS
47731: PUSH
47732: FOR_TO
47733: IFFALSE 47825
// begin if i = sort then
47735: LD_VAR 0 3
47739: PUSH
47740: LD_VAR 0 9
47744: EQUAL
47745: IFFALSE 47749
// break ;
47747: GO 47825
// if GetClass ( i ) = 2 then
47749: LD_VAR 0 3
47753: PPUSH
47754: CALL_OW 257
47758: PUSH
47759: LD_INT 2
47761: EQUAL
47762: IFFALSE 47766
// continue ;
47764: GO 47732
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47766: LD_ADDR_VAR 0 11
47770: PUSH
47771: LD_VAR 0 11
47775: PPUSH
47776: LD_VAR 0 11
47780: PUSH
47781: LD_INT 1
47783: PLUS
47784: PPUSH
47785: LD_VAR 0 9
47789: PUSH
47790: LD_VAR 0 3
47794: ARRAY
47795: PPUSH
47796: CALL_OW 2
47800: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47801: LD_ADDR_VAR 0 4
47805: PUSH
47806: LD_VAR 0 4
47810: PUSH
47811: LD_VAR 0 9
47815: PUSH
47816: LD_VAR 0 3
47820: ARRAY
47821: DIFF
47822: ST_TO_ADDR
// end ;
47823: GO 47732
47825: POP
47826: POP
// if p then
47827: LD_VAR 0 11
47831: IFFALSE 47856
// result := Replace ( result , 2 , p ) ;
47833: LD_ADDR_VAR 0 2
47837: PUSH
47838: LD_VAR 0 2
47842: PPUSH
47843: LD_INT 2
47845: PPUSH
47846: LD_VAR 0 11
47850: PPUSH
47851: CALL_OW 1
47855: ST_TO_ADDR
// end else
47856: GO 47902
// for i = eng downto 5 do
47858: LD_ADDR_VAR 0 3
47862: PUSH
47863: DOUBLE
47864: LD_VAR 0 6
47868: INC
47869: ST_TO_ADDR
47870: LD_INT 5
47872: PUSH
47873: FOR_DOWNTO
47874: IFFALSE 47900
// tmp := tmp union eng [ i ] ;
47876: LD_ADDR_VAR 0 4
47880: PUSH
47881: LD_VAR 0 4
47885: PUSH
47886: LD_VAR 0 6
47890: PUSH
47891: LD_VAR 0 3
47895: ARRAY
47896: UNION
47897: ST_TO_ADDR
47898: GO 47873
47900: POP
47901: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
47902: LD_ADDR_VAR 0 2
47906: PUSH
47907: LD_VAR 0 2
47911: PPUSH
47912: LD_INT 1
47914: PPUSH
47915: LD_VAR 0 4
47919: PUSH
47920: LD_VAR 0 5
47924: DIFF
47925: PPUSH
47926: CALL_OW 1
47930: ST_TO_ADDR
// exit ;
47931: GO 47933
// end ; end ;
47933: LD_VAR 0 2
47937: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
47938: LD_INT 0
47940: PPUSH
47941: PPUSH
47942: PPUSH
// if not mc_bases then
47943: LD_EXP 102
47947: NOT
47948: IFFALSE 47952
// exit ;
47950: GO 48094
// for i = 1 to mc_bases do
47952: LD_ADDR_VAR 0 2
47956: PUSH
47957: DOUBLE
47958: LD_INT 1
47960: DEC
47961: ST_TO_ADDR
47962: LD_EXP 102
47966: PUSH
47967: FOR_TO
47968: IFFALSE 48085
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
47970: LD_ADDR_VAR 0 3
47974: PUSH
47975: LD_EXP 102
47979: PUSH
47980: LD_VAR 0 2
47984: ARRAY
47985: PPUSH
47986: LD_INT 21
47988: PUSH
47989: LD_INT 3
47991: PUSH
47992: EMPTY
47993: LIST
47994: LIST
47995: PUSH
47996: LD_INT 3
47998: PUSH
47999: LD_INT 2
48001: PUSH
48002: LD_INT 30
48004: PUSH
48005: LD_INT 29
48007: PUSH
48008: EMPTY
48009: LIST
48010: LIST
48011: PUSH
48012: LD_INT 30
48014: PUSH
48015: LD_INT 30
48017: PUSH
48018: EMPTY
48019: LIST
48020: LIST
48021: PUSH
48022: EMPTY
48023: LIST
48024: LIST
48025: LIST
48026: PUSH
48027: EMPTY
48028: LIST
48029: LIST
48030: PUSH
48031: LD_INT 3
48033: PUSH
48034: LD_INT 24
48036: PUSH
48037: LD_INT 1000
48039: PUSH
48040: EMPTY
48041: LIST
48042: LIST
48043: PUSH
48044: EMPTY
48045: LIST
48046: LIST
48047: PUSH
48048: EMPTY
48049: LIST
48050: LIST
48051: LIST
48052: PPUSH
48053: CALL_OW 72
48057: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
48058: LD_ADDR_EXP 103
48062: PUSH
48063: LD_EXP 103
48067: PPUSH
48068: LD_VAR 0 2
48072: PPUSH
48073: LD_VAR 0 3
48077: PPUSH
48078: CALL_OW 1
48082: ST_TO_ADDR
// end ;
48083: GO 47967
48085: POP
48086: POP
// RaiseSailEvent ( 101 ) ;
48087: LD_INT 101
48089: PPUSH
48090: CALL_OW 427
// end ;
48094: LD_VAR 0 1
48098: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
48099: LD_INT 0
48101: PPUSH
48102: PPUSH
48103: PPUSH
48104: PPUSH
48105: PPUSH
48106: PPUSH
48107: PPUSH
// if not mc_bases then
48108: LD_EXP 102
48112: NOT
48113: IFFALSE 48117
// exit ;
48115: GO 48679
// for i = 1 to mc_bases do
48117: LD_ADDR_VAR 0 2
48121: PUSH
48122: DOUBLE
48123: LD_INT 1
48125: DEC
48126: ST_TO_ADDR
48127: LD_EXP 102
48131: PUSH
48132: FOR_TO
48133: IFFALSE 48670
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
48135: LD_ADDR_VAR 0 5
48139: PUSH
48140: LD_EXP 102
48144: PUSH
48145: LD_VAR 0 2
48149: ARRAY
48150: PUSH
48151: LD_EXP 131
48155: PUSH
48156: LD_VAR 0 2
48160: ARRAY
48161: UNION
48162: PPUSH
48163: LD_INT 21
48165: PUSH
48166: LD_INT 1
48168: PUSH
48169: EMPTY
48170: LIST
48171: LIST
48172: PUSH
48173: LD_INT 1
48175: PUSH
48176: LD_INT 3
48178: PUSH
48179: LD_INT 54
48181: PUSH
48182: EMPTY
48183: LIST
48184: PUSH
48185: EMPTY
48186: LIST
48187: LIST
48188: PUSH
48189: LD_INT 3
48191: PUSH
48192: LD_INT 24
48194: PUSH
48195: LD_INT 1000
48197: PUSH
48198: EMPTY
48199: LIST
48200: LIST
48201: PUSH
48202: EMPTY
48203: LIST
48204: LIST
48205: PUSH
48206: EMPTY
48207: LIST
48208: LIST
48209: LIST
48210: PUSH
48211: EMPTY
48212: LIST
48213: LIST
48214: PPUSH
48215: CALL_OW 72
48219: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
48220: LD_ADDR_VAR 0 6
48224: PUSH
48225: LD_EXP 102
48229: PUSH
48230: LD_VAR 0 2
48234: ARRAY
48235: PPUSH
48236: LD_INT 21
48238: PUSH
48239: LD_INT 1
48241: PUSH
48242: EMPTY
48243: LIST
48244: LIST
48245: PUSH
48246: LD_INT 1
48248: PUSH
48249: LD_INT 3
48251: PUSH
48252: LD_INT 54
48254: PUSH
48255: EMPTY
48256: LIST
48257: PUSH
48258: EMPTY
48259: LIST
48260: LIST
48261: PUSH
48262: LD_INT 3
48264: PUSH
48265: LD_INT 24
48267: PUSH
48268: LD_INT 250
48270: PUSH
48271: EMPTY
48272: LIST
48273: LIST
48274: PUSH
48275: EMPTY
48276: LIST
48277: LIST
48278: PUSH
48279: EMPTY
48280: LIST
48281: LIST
48282: LIST
48283: PUSH
48284: EMPTY
48285: LIST
48286: LIST
48287: PPUSH
48288: CALL_OW 72
48292: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
48293: LD_ADDR_VAR 0 7
48297: PUSH
48298: LD_VAR 0 5
48302: PUSH
48303: LD_VAR 0 6
48307: DIFF
48308: ST_TO_ADDR
// if not need_heal_1 then
48309: LD_VAR 0 6
48313: NOT
48314: IFFALSE 48347
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
48316: LD_ADDR_EXP 105
48320: PUSH
48321: LD_EXP 105
48325: PPUSH
48326: LD_VAR 0 2
48330: PUSH
48331: LD_INT 1
48333: PUSH
48334: EMPTY
48335: LIST
48336: LIST
48337: PPUSH
48338: EMPTY
48339: PPUSH
48340: CALL 75342 0 3
48344: ST_TO_ADDR
48345: GO 48417
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
48347: LD_ADDR_EXP 105
48351: PUSH
48352: LD_EXP 105
48356: PPUSH
48357: LD_VAR 0 2
48361: PUSH
48362: LD_INT 1
48364: PUSH
48365: EMPTY
48366: LIST
48367: LIST
48368: PPUSH
48369: LD_EXP 105
48373: PUSH
48374: LD_VAR 0 2
48378: ARRAY
48379: PUSH
48380: LD_INT 1
48382: ARRAY
48383: PPUSH
48384: LD_INT 3
48386: PUSH
48387: LD_INT 24
48389: PUSH
48390: LD_INT 1000
48392: PUSH
48393: EMPTY
48394: LIST
48395: LIST
48396: PUSH
48397: EMPTY
48398: LIST
48399: LIST
48400: PPUSH
48401: CALL_OW 72
48405: PUSH
48406: LD_VAR 0 6
48410: UNION
48411: PPUSH
48412: CALL 75342 0 3
48416: ST_TO_ADDR
// if not need_heal_2 then
48417: LD_VAR 0 7
48421: NOT
48422: IFFALSE 48455
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
48424: LD_ADDR_EXP 105
48428: PUSH
48429: LD_EXP 105
48433: PPUSH
48434: LD_VAR 0 2
48438: PUSH
48439: LD_INT 2
48441: PUSH
48442: EMPTY
48443: LIST
48444: LIST
48445: PPUSH
48446: EMPTY
48447: PPUSH
48448: CALL 75342 0 3
48452: ST_TO_ADDR
48453: GO 48487
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
48455: LD_ADDR_EXP 105
48459: PUSH
48460: LD_EXP 105
48464: PPUSH
48465: LD_VAR 0 2
48469: PUSH
48470: LD_INT 2
48472: PUSH
48473: EMPTY
48474: LIST
48475: LIST
48476: PPUSH
48477: LD_VAR 0 7
48481: PPUSH
48482: CALL 75342 0 3
48486: ST_TO_ADDR
// if need_heal_2 then
48487: LD_VAR 0 7
48491: IFFALSE 48652
// for j in need_heal_2 do
48493: LD_ADDR_VAR 0 3
48497: PUSH
48498: LD_VAR 0 7
48502: PUSH
48503: FOR_IN
48504: IFFALSE 48650
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48506: LD_ADDR_VAR 0 5
48510: PUSH
48511: LD_EXP 102
48515: PUSH
48516: LD_VAR 0 2
48520: ARRAY
48521: PPUSH
48522: LD_INT 2
48524: PUSH
48525: LD_INT 30
48527: PUSH
48528: LD_INT 6
48530: PUSH
48531: EMPTY
48532: LIST
48533: LIST
48534: PUSH
48535: LD_INT 30
48537: PUSH
48538: LD_INT 7
48540: PUSH
48541: EMPTY
48542: LIST
48543: LIST
48544: PUSH
48545: LD_INT 30
48547: PUSH
48548: LD_INT 8
48550: PUSH
48551: EMPTY
48552: LIST
48553: LIST
48554: PUSH
48555: LD_INT 30
48557: PUSH
48558: LD_INT 0
48560: PUSH
48561: EMPTY
48562: LIST
48563: LIST
48564: PUSH
48565: LD_INT 30
48567: PUSH
48568: LD_INT 1
48570: PUSH
48571: EMPTY
48572: LIST
48573: LIST
48574: PUSH
48575: EMPTY
48576: LIST
48577: LIST
48578: LIST
48579: LIST
48580: LIST
48581: LIST
48582: PPUSH
48583: CALL_OW 72
48587: ST_TO_ADDR
// if tmp then
48588: LD_VAR 0 5
48592: IFFALSE 48648
// begin k := NearestUnitToUnit ( tmp , j ) ;
48594: LD_ADDR_VAR 0 4
48598: PUSH
48599: LD_VAR 0 5
48603: PPUSH
48604: LD_VAR 0 3
48608: PPUSH
48609: CALL_OW 74
48613: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
48614: LD_VAR 0 3
48618: PPUSH
48619: LD_VAR 0 4
48623: PPUSH
48624: CALL_OW 296
48628: PUSH
48629: LD_INT 5
48631: GREATER
48632: IFFALSE 48648
// ComMoveToNearbyEntrance ( j , k ) ;
48634: LD_VAR 0 3
48638: PPUSH
48639: LD_VAR 0 4
48643: PPUSH
48644: CALL 108968 0 2
// end ; end ;
48648: GO 48503
48650: POP
48651: POP
// if not need_heal_1 and not need_heal_2 then
48652: LD_VAR 0 6
48656: NOT
48657: PUSH
48658: LD_VAR 0 7
48662: NOT
48663: AND
48664: IFFALSE 48668
// continue ;
48666: GO 48132
// end ;
48668: GO 48132
48670: POP
48671: POP
// RaiseSailEvent ( 102 ) ;
48672: LD_INT 102
48674: PPUSH
48675: CALL_OW 427
// end ;
48679: LD_VAR 0 1
48683: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
48684: LD_INT 0
48686: PPUSH
48687: PPUSH
48688: PPUSH
48689: PPUSH
48690: PPUSH
48691: PPUSH
48692: PPUSH
48693: PPUSH
// if not mc_bases then
48694: LD_EXP 102
48698: NOT
48699: IFFALSE 48703
// exit ;
48701: GO 49614
// for i = 1 to mc_bases do
48703: LD_ADDR_VAR 0 2
48707: PUSH
48708: DOUBLE
48709: LD_INT 1
48711: DEC
48712: ST_TO_ADDR
48713: LD_EXP 102
48717: PUSH
48718: FOR_TO
48719: IFFALSE 49612
// begin if not mc_building_need_repair [ i ] then
48721: LD_EXP 103
48725: PUSH
48726: LD_VAR 0 2
48730: ARRAY
48731: NOT
48732: IFFALSE 48917
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
48734: LD_ADDR_VAR 0 6
48738: PUSH
48739: LD_EXP 121
48743: PUSH
48744: LD_VAR 0 2
48748: ARRAY
48749: PPUSH
48750: LD_INT 3
48752: PUSH
48753: LD_INT 24
48755: PUSH
48756: LD_INT 1000
48758: PUSH
48759: EMPTY
48760: LIST
48761: LIST
48762: PUSH
48763: EMPTY
48764: LIST
48765: LIST
48766: PUSH
48767: LD_INT 2
48769: PUSH
48770: LD_INT 34
48772: PUSH
48773: LD_INT 13
48775: PUSH
48776: EMPTY
48777: LIST
48778: LIST
48779: PUSH
48780: LD_INT 34
48782: PUSH
48783: LD_INT 52
48785: PUSH
48786: EMPTY
48787: LIST
48788: LIST
48789: PUSH
48790: LD_INT 34
48792: PUSH
48793: LD_INT 88
48795: PUSH
48796: EMPTY
48797: LIST
48798: LIST
48799: PUSH
48800: EMPTY
48801: LIST
48802: LIST
48803: LIST
48804: LIST
48805: PUSH
48806: EMPTY
48807: LIST
48808: LIST
48809: PPUSH
48810: CALL_OW 72
48814: ST_TO_ADDR
// if cranes then
48815: LD_VAR 0 6
48819: IFFALSE 48881
// for j in cranes do
48821: LD_ADDR_VAR 0 3
48825: PUSH
48826: LD_VAR 0 6
48830: PUSH
48831: FOR_IN
48832: IFFALSE 48879
// if not IsInArea ( j , mc_parking [ i ] ) then
48834: LD_VAR 0 3
48838: PPUSH
48839: LD_EXP 126
48843: PUSH
48844: LD_VAR 0 2
48848: ARRAY
48849: PPUSH
48850: CALL_OW 308
48854: NOT
48855: IFFALSE 48877
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48857: LD_VAR 0 3
48861: PPUSH
48862: LD_EXP 126
48866: PUSH
48867: LD_VAR 0 2
48871: ARRAY
48872: PPUSH
48873: CALL_OW 113
48877: GO 48831
48879: POP
48880: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
48881: LD_ADDR_EXP 104
48885: PUSH
48886: LD_EXP 104
48890: PPUSH
48891: LD_VAR 0 2
48895: PPUSH
48896: EMPTY
48897: PPUSH
48898: CALL_OW 1
48902: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
48903: LD_VAR 0 2
48907: PPUSH
48908: LD_INT 101
48910: PPUSH
48911: CALL 43757 0 2
// continue ;
48915: GO 48718
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
48917: LD_ADDR_EXP 108
48921: PUSH
48922: LD_EXP 108
48926: PPUSH
48927: LD_VAR 0 2
48931: PPUSH
48932: EMPTY
48933: PPUSH
48934: CALL_OW 1
48938: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
48939: LD_VAR 0 2
48943: PPUSH
48944: LD_INT 103
48946: PPUSH
48947: CALL 43757 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
48951: LD_ADDR_VAR 0 5
48955: PUSH
48956: LD_EXP 102
48960: PUSH
48961: LD_VAR 0 2
48965: ARRAY
48966: PUSH
48967: LD_EXP 131
48971: PUSH
48972: LD_VAR 0 2
48976: ARRAY
48977: UNION
48978: PPUSH
48979: LD_INT 2
48981: PUSH
48982: LD_INT 25
48984: PUSH
48985: LD_INT 2
48987: PUSH
48988: EMPTY
48989: LIST
48990: LIST
48991: PUSH
48992: LD_INT 25
48994: PUSH
48995: LD_INT 16
48997: PUSH
48998: EMPTY
48999: LIST
49000: LIST
49001: PUSH
49002: EMPTY
49003: LIST
49004: LIST
49005: LIST
49006: PUSH
49007: EMPTY
49008: LIST
49009: PPUSH
49010: CALL_OW 72
49014: ST_TO_ADDR
// if mc_need_heal [ i ] then
49015: LD_EXP 105
49019: PUSH
49020: LD_VAR 0 2
49024: ARRAY
49025: IFFALSE 49069
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
49027: LD_ADDR_VAR 0 5
49031: PUSH
49032: LD_VAR 0 5
49036: PUSH
49037: LD_EXP 105
49041: PUSH
49042: LD_VAR 0 2
49046: ARRAY
49047: PUSH
49048: LD_INT 1
49050: ARRAY
49051: PUSH
49052: LD_EXP 105
49056: PUSH
49057: LD_VAR 0 2
49061: ARRAY
49062: PUSH
49063: LD_INT 2
49065: ARRAY
49066: UNION
49067: DIFF
49068: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
49069: LD_ADDR_VAR 0 6
49073: PUSH
49074: LD_EXP 121
49078: PUSH
49079: LD_VAR 0 2
49083: ARRAY
49084: PPUSH
49085: LD_INT 2
49087: PUSH
49088: LD_INT 34
49090: PUSH
49091: LD_INT 13
49093: PUSH
49094: EMPTY
49095: LIST
49096: LIST
49097: PUSH
49098: LD_INT 34
49100: PUSH
49101: LD_INT 52
49103: PUSH
49104: EMPTY
49105: LIST
49106: LIST
49107: PUSH
49108: LD_INT 34
49110: PUSH
49111: LD_INT 88
49113: PUSH
49114: EMPTY
49115: LIST
49116: LIST
49117: PUSH
49118: EMPTY
49119: LIST
49120: LIST
49121: LIST
49122: LIST
49123: PPUSH
49124: CALL_OW 72
49128: ST_TO_ADDR
// if cranes then
49129: LD_VAR 0 6
49133: IFFALSE 49301
// begin for j in cranes do
49135: LD_ADDR_VAR 0 3
49139: PUSH
49140: LD_VAR 0 6
49144: PUSH
49145: FOR_IN
49146: IFFALSE 49299
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
49148: LD_VAR 0 3
49152: PPUSH
49153: CALL_OW 256
49157: PUSH
49158: LD_INT 1000
49160: EQUAL
49161: PUSH
49162: LD_VAR 0 3
49166: PPUSH
49167: CALL_OW 314
49171: NOT
49172: AND
49173: IFFALSE 49239
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
49175: LD_ADDR_VAR 0 8
49179: PUSH
49180: LD_EXP 103
49184: PUSH
49185: LD_VAR 0 2
49189: ARRAY
49190: PPUSH
49191: LD_VAR 0 3
49195: PPUSH
49196: CALL_OW 74
49200: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
49201: LD_VAR 0 8
49205: PPUSH
49206: LD_INT 16
49208: PPUSH
49209: CALL 78307 0 2
49213: PUSH
49214: LD_INT 4
49216: ARRAY
49217: PUSH
49218: LD_INT 10
49220: LESS
49221: IFFALSE 49237
// ComRepairBuilding ( j , to_repair ) ;
49223: LD_VAR 0 3
49227: PPUSH
49228: LD_VAR 0 8
49232: PPUSH
49233: CALL_OW 130
// end else
49237: GO 49297
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
49239: LD_VAR 0 3
49243: PPUSH
49244: CALL_OW 256
49248: PUSH
49249: LD_INT 500
49251: LESS
49252: PUSH
49253: LD_VAR 0 3
49257: PPUSH
49258: LD_EXP 126
49262: PUSH
49263: LD_VAR 0 2
49267: ARRAY
49268: PPUSH
49269: CALL_OW 308
49273: NOT
49274: AND
49275: IFFALSE 49297
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49277: LD_VAR 0 3
49281: PPUSH
49282: LD_EXP 126
49286: PUSH
49287: LD_VAR 0 2
49291: ARRAY
49292: PPUSH
49293: CALL_OW 113
// end ;
49297: GO 49145
49299: POP
49300: POP
// end ; if tmp > 3 then
49301: LD_VAR 0 5
49305: PUSH
49306: LD_INT 3
49308: GREATER
49309: IFFALSE 49329
// tmp := ShrinkArray ( tmp , 4 ) ;
49311: LD_ADDR_VAR 0 5
49315: PUSH
49316: LD_VAR 0 5
49320: PPUSH
49321: LD_INT 4
49323: PPUSH
49324: CALL 108406 0 2
49328: ST_TO_ADDR
// if not tmp then
49329: LD_VAR 0 5
49333: NOT
49334: IFFALSE 49338
// continue ;
49336: GO 48718
// for j in tmp do
49338: LD_ADDR_VAR 0 3
49342: PUSH
49343: LD_VAR 0 5
49347: PUSH
49348: FOR_IN
49349: IFFALSE 49608
// begin if IsInUnit ( j ) then
49351: LD_VAR 0 3
49355: PPUSH
49356: CALL_OW 310
49360: IFFALSE 49371
// ComExitBuilding ( j ) ;
49362: LD_VAR 0 3
49366: PPUSH
49367: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
49371: LD_VAR 0 3
49375: PUSH
49376: LD_EXP 104
49380: PUSH
49381: LD_VAR 0 2
49385: ARRAY
49386: IN
49387: NOT
49388: IFFALSE 49446
// begin SetTag ( j , 101 ) ;
49390: LD_VAR 0 3
49394: PPUSH
49395: LD_INT 101
49397: PPUSH
49398: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
49402: LD_ADDR_EXP 104
49406: PUSH
49407: LD_EXP 104
49411: PPUSH
49412: LD_VAR 0 2
49416: PUSH
49417: LD_EXP 104
49421: PUSH
49422: LD_VAR 0 2
49426: ARRAY
49427: PUSH
49428: LD_INT 1
49430: PLUS
49431: PUSH
49432: EMPTY
49433: LIST
49434: LIST
49435: PPUSH
49436: LD_VAR 0 3
49440: PPUSH
49441: CALL 75342 0 3
49445: ST_TO_ADDR
// end ; wait ( 1 ) ;
49446: LD_INT 1
49448: PPUSH
49449: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
49453: LD_ADDR_VAR 0 7
49457: PUSH
49458: LD_EXP 103
49462: PUSH
49463: LD_VAR 0 2
49467: ARRAY
49468: ST_TO_ADDR
// if mc_scan [ i ] then
49469: LD_EXP 125
49473: PUSH
49474: LD_VAR 0 2
49478: ARRAY
49479: IFFALSE 49541
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
49481: LD_ADDR_VAR 0 7
49485: PUSH
49486: LD_EXP 103
49490: PUSH
49491: LD_VAR 0 2
49495: ARRAY
49496: PPUSH
49497: LD_INT 3
49499: PUSH
49500: LD_INT 30
49502: PUSH
49503: LD_INT 32
49505: PUSH
49506: EMPTY
49507: LIST
49508: LIST
49509: PUSH
49510: LD_INT 30
49512: PUSH
49513: LD_INT 33
49515: PUSH
49516: EMPTY
49517: LIST
49518: LIST
49519: PUSH
49520: LD_INT 30
49522: PUSH
49523: LD_INT 31
49525: PUSH
49526: EMPTY
49527: LIST
49528: LIST
49529: PUSH
49530: EMPTY
49531: LIST
49532: LIST
49533: LIST
49534: LIST
49535: PPUSH
49536: CALL_OW 72
49540: ST_TO_ADDR
// if not to_repair_tmp then
49541: LD_VAR 0 7
49545: NOT
49546: IFFALSE 49550
// continue ;
49548: GO 49348
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
49550: LD_ADDR_VAR 0 8
49554: PUSH
49555: LD_VAR 0 7
49559: PPUSH
49560: LD_VAR 0 3
49564: PPUSH
49565: CALL_OW 74
49569: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
49570: LD_VAR 0 8
49574: PPUSH
49575: LD_INT 16
49577: PPUSH
49578: CALL 78307 0 2
49582: PUSH
49583: LD_INT 4
49585: ARRAY
49586: PUSH
49587: LD_INT 14
49589: LESS
49590: IFFALSE 49606
// ComRepairBuilding ( j , to_repair ) ;
49592: LD_VAR 0 3
49596: PPUSH
49597: LD_VAR 0 8
49601: PPUSH
49602: CALL_OW 130
// end ;
49606: GO 49348
49608: POP
49609: POP
// end ;
49610: GO 48718
49612: POP
49613: POP
// end ;
49614: LD_VAR 0 1
49618: RET
// export function MC_Heal ; var i , j , tmp ; begin
49619: LD_INT 0
49621: PPUSH
49622: PPUSH
49623: PPUSH
49624: PPUSH
// if not mc_bases then
49625: LD_EXP 102
49629: NOT
49630: IFFALSE 49634
// exit ;
49632: GO 50036
// for i = 1 to mc_bases do
49634: LD_ADDR_VAR 0 2
49638: PUSH
49639: DOUBLE
49640: LD_INT 1
49642: DEC
49643: ST_TO_ADDR
49644: LD_EXP 102
49648: PUSH
49649: FOR_TO
49650: IFFALSE 50034
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
49652: LD_EXP 105
49656: PUSH
49657: LD_VAR 0 2
49661: ARRAY
49662: PUSH
49663: LD_INT 1
49665: ARRAY
49666: NOT
49667: PUSH
49668: LD_EXP 105
49672: PUSH
49673: LD_VAR 0 2
49677: ARRAY
49678: PUSH
49679: LD_INT 2
49681: ARRAY
49682: NOT
49683: AND
49684: IFFALSE 49722
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
49686: LD_ADDR_EXP 106
49690: PUSH
49691: LD_EXP 106
49695: PPUSH
49696: LD_VAR 0 2
49700: PPUSH
49701: EMPTY
49702: PPUSH
49703: CALL_OW 1
49707: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
49708: LD_VAR 0 2
49712: PPUSH
49713: LD_INT 102
49715: PPUSH
49716: CALL 43757 0 2
// continue ;
49720: GO 49649
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
49722: LD_ADDR_VAR 0 4
49726: PUSH
49727: LD_EXP 102
49731: PUSH
49732: LD_VAR 0 2
49736: ARRAY
49737: PPUSH
49738: LD_INT 25
49740: PUSH
49741: LD_INT 4
49743: PUSH
49744: EMPTY
49745: LIST
49746: LIST
49747: PPUSH
49748: CALL_OW 72
49752: ST_TO_ADDR
// if not tmp then
49753: LD_VAR 0 4
49757: NOT
49758: IFFALSE 49762
// continue ;
49760: GO 49649
// if mc_taming [ i ] then
49762: LD_EXP 133
49766: PUSH
49767: LD_VAR 0 2
49771: ARRAY
49772: IFFALSE 49796
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
49774: LD_ADDR_EXP 133
49778: PUSH
49779: LD_EXP 133
49783: PPUSH
49784: LD_VAR 0 2
49788: PPUSH
49789: EMPTY
49790: PPUSH
49791: CALL_OW 1
49795: ST_TO_ADDR
// for j in tmp do
49796: LD_ADDR_VAR 0 3
49800: PUSH
49801: LD_VAR 0 4
49805: PUSH
49806: FOR_IN
49807: IFFALSE 50030
// begin if IsInUnit ( j ) then
49809: LD_VAR 0 3
49813: PPUSH
49814: CALL_OW 310
49818: IFFALSE 49829
// ComExitBuilding ( j ) ;
49820: LD_VAR 0 3
49824: PPUSH
49825: CALL_OW 122
// if not j in mc_healers [ i ] then
49829: LD_VAR 0 3
49833: PUSH
49834: LD_EXP 106
49838: PUSH
49839: LD_VAR 0 2
49843: ARRAY
49844: IN
49845: NOT
49846: IFFALSE 49892
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
49848: LD_ADDR_EXP 106
49852: PUSH
49853: LD_EXP 106
49857: PPUSH
49858: LD_VAR 0 2
49862: PUSH
49863: LD_EXP 106
49867: PUSH
49868: LD_VAR 0 2
49872: ARRAY
49873: PUSH
49874: LD_INT 1
49876: PLUS
49877: PUSH
49878: EMPTY
49879: LIST
49880: LIST
49881: PPUSH
49882: LD_VAR 0 3
49886: PPUSH
49887: CALL 75342 0 3
49891: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
49892: LD_VAR 0 3
49896: PPUSH
49897: CALL_OW 110
49901: PUSH
49902: LD_INT 102
49904: NONEQUAL
49905: IFFALSE 49919
// SetTag ( j , 102 ) ;
49907: LD_VAR 0 3
49911: PPUSH
49912: LD_INT 102
49914: PPUSH
49915: CALL_OW 109
// Wait ( 3 ) ;
49919: LD_INT 3
49921: PPUSH
49922: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
49926: LD_EXP 105
49930: PUSH
49931: LD_VAR 0 2
49935: ARRAY
49936: PUSH
49937: LD_INT 1
49939: ARRAY
49940: IFFALSE 49972
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
49942: LD_VAR 0 3
49946: PPUSH
49947: LD_EXP 105
49951: PUSH
49952: LD_VAR 0 2
49956: ARRAY
49957: PUSH
49958: LD_INT 1
49960: ARRAY
49961: PUSH
49962: LD_INT 1
49964: ARRAY
49965: PPUSH
49966: CALL_OW 128
49970: GO 50028
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
49972: LD_VAR 0 3
49976: PPUSH
49977: CALL_OW 314
49981: NOT
49982: PUSH
49983: LD_EXP 105
49987: PUSH
49988: LD_VAR 0 2
49992: ARRAY
49993: PUSH
49994: LD_INT 2
49996: ARRAY
49997: AND
49998: IFFALSE 50028
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
50000: LD_VAR 0 3
50004: PPUSH
50005: LD_EXP 105
50009: PUSH
50010: LD_VAR 0 2
50014: ARRAY
50015: PUSH
50016: LD_INT 2
50018: ARRAY
50019: PUSH
50020: LD_INT 1
50022: ARRAY
50023: PPUSH
50024: CALL_OW 128
// end ;
50028: GO 49806
50030: POP
50031: POP
// end ;
50032: GO 49649
50034: POP
50035: POP
// end ;
50036: LD_VAR 0 1
50040: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
50041: LD_INT 0
50043: PPUSH
50044: PPUSH
50045: PPUSH
50046: PPUSH
50047: PPUSH
50048: PPUSH
// if not mc_bases then
50049: LD_EXP 102
50053: NOT
50054: IFFALSE 50058
// exit ;
50056: GO 51221
// for i = 1 to mc_bases do
50058: LD_ADDR_VAR 0 2
50062: PUSH
50063: DOUBLE
50064: LD_INT 1
50066: DEC
50067: ST_TO_ADDR
50068: LD_EXP 102
50072: PUSH
50073: FOR_TO
50074: IFFALSE 51219
// begin if mc_scan [ i ] then
50076: LD_EXP 125
50080: PUSH
50081: LD_VAR 0 2
50085: ARRAY
50086: IFFALSE 50090
// continue ;
50088: GO 50073
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
50090: LD_EXP 107
50094: PUSH
50095: LD_VAR 0 2
50099: ARRAY
50100: NOT
50101: PUSH
50102: LD_EXP 109
50106: PUSH
50107: LD_VAR 0 2
50111: ARRAY
50112: NOT
50113: AND
50114: PUSH
50115: LD_EXP 108
50119: PUSH
50120: LD_VAR 0 2
50124: ARRAY
50125: AND
50126: IFFALSE 50164
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
50128: LD_ADDR_EXP 108
50132: PUSH
50133: LD_EXP 108
50137: PPUSH
50138: LD_VAR 0 2
50142: PPUSH
50143: EMPTY
50144: PPUSH
50145: CALL_OW 1
50149: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
50150: LD_VAR 0 2
50154: PPUSH
50155: LD_INT 103
50157: PPUSH
50158: CALL 43757 0 2
// continue ;
50162: GO 50073
// end ; if mc_construct_list [ i ] then
50164: LD_EXP 109
50168: PUSH
50169: LD_VAR 0 2
50173: ARRAY
50174: IFFALSE 50394
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
50176: LD_ADDR_VAR 0 5
50180: PUSH
50181: LD_EXP 102
50185: PUSH
50186: LD_VAR 0 2
50190: ARRAY
50191: PPUSH
50192: LD_INT 25
50194: PUSH
50195: LD_INT 2
50197: PUSH
50198: EMPTY
50199: LIST
50200: LIST
50201: PPUSH
50202: CALL_OW 72
50206: PUSH
50207: LD_EXP 104
50211: PUSH
50212: LD_VAR 0 2
50216: ARRAY
50217: DIFF
50218: ST_TO_ADDR
// if not tmp then
50219: LD_VAR 0 5
50223: NOT
50224: IFFALSE 50228
// continue ;
50226: GO 50073
// for j in tmp do
50228: LD_ADDR_VAR 0 3
50232: PUSH
50233: LD_VAR 0 5
50237: PUSH
50238: FOR_IN
50239: IFFALSE 50390
// begin if not mc_builders [ i ] then
50241: LD_EXP 108
50245: PUSH
50246: LD_VAR 0 2
50250: ARRAY
50251: NOT
50252: IFFALSE 50310
// begin SetTag ( j , 103 ) ;
50254: LD_VAR 0 3
50258: PPUSH
50259: LD_INT 103
50261: PPUSH
50262: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
50266: LD_ADDR_EXP 108
50270: PUSH
50271: LD_EXP 108
50275: PPUSH
50276: LD_VAR 0 2
50280: PUSH
50281: LD_EXP 108
50285: PUSH
50286: LD_VAR 0 2
50290: ARRAY
50291: PUSH
50292: LD_INT 1
50294: PLUS
50295: PUSH
50296: EMPTY
50297: LIST
50298: LIST
50299: PPUSH
50300: LD_VAR 0 3
50304: PPUSH
50305: CALL 75342 0 3
50309: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
50310: LD_VAR 0 3
50314: PPUSH
50315: CALL_OW 310
50319: IFFALSE 50330
// ComExitBuilding ( j ) ;
50321: LD_VAR 0 3
50325: PPUSH
50326: CALL_OW 122
// wait ( 3 ) ;
50330: LD_INT 3
50332: PPUSH
50333: CALL_OW 67
// if not mc_construct_list [ i ] then
50337: LD_EXP 109
50341: PUSH
50342: LD_VAR 0 2
50346: ARRAY
50347: NOT
50348: IFFALSE 50352
// break ;
50350: GO 50390
// if not HasTask ( j ) then
50352: LD_VAR 0 3
50356: PPUSH
50357: CALL_OW 314
50361: NOT
50362: IFFALSE 50388
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
50364: LD_VAR 0 3
50368: PPUSH
50369: LD_EXP 109
50373: PUSH
50374: LD_VAR 0 2
50378: ARRAY
50379: PUSH
50380: LD_INT 1
50382: ARRAY
50383: PPUSH
50384: CALL 78580 0 2
// end ;
50388: GO 50238
50390: POP
50391: POP
// end else
50392: GO 51217
// if mc_build_list [ i ] then
50394: LD_EXP 107
50398: PUSH
50399: LD_VAR 0 2
50403: ARRAY
50404: IFFALSE 51217
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
50406: LD_EXP 107
50410: PUSH
50411: LD_VAR 0 2
50415: ARRAY
50416: PUSH
50417: LD_INT 1
50419: ARRAY
50420: PUSH
50421: LD_INT 1
50423: ARRAY
50424: PPUSH
50425: CALL 78404 0 1
50429: PUSH
50430: LD_EXP 102
50434: PUSH
50435: LD_VAR 0 2
50439: ARRAY
50440: PPUSH
50441: LD_INT 2
50443: PUSH
50444: LD_INT 30
50446: PUSH
50447: LD_INT 2
50449: PUSH
50450: EMPTY
50451: LIST
50452: LIST
50453: PUSH
50454: LD_INT 30
50456: PUSH
50457: LD_INT 3
50459: PUSH
50460: EMPTY
50461: LIST
50462: LIST
50463: PUSH
50464: EMPTY
50465: LIST
50466: LIST
50467: LIST
50468: PPUSH
50469: CALL_OW 72
50473: NOT
50474: AND
50475: IFFALSE 50580
// begin for j = 1 to mc_build_list [ i ] do
50477: LD_ADDR_VAR 0 3
50481: PUSH
50482: DOUBLE
50483: LD_INT 1
50485: DEC
50486: ST_TO_ADDR
50487: LD_EXP 107
50491: PUSH
50492: LD_VAR 0 2
50496: ARRAY
50497: PUSH
50498: FOR_TO
50499: IFFALSE 50578
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
50501: LD_EXP 107
50505: PUSH
50506: LD_VAR 0 2
50510: ARRAY
50511: PUSH
50512: LD_VAR 0 3
50516: ARRAY
50517: PUSH
50518: LD_INT 1
50520: ARRAY
50521: PUSH
50522: LD_INT 2
50524: EQUAL
50525: IFFALSE 50576
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
50527: LD_ADDR_EXP 107
50531: PUSH
50532: LD_EXP 107
50536: PPUSH
50537: LD_VAR 0 2
50541: PPUSH
50542: LD_EXP 107
50546: PUSH
50547: LD_VAR 0 2
50551: ARRAY
50552: PPUSH
50553: LD_VAR 0 3
50557: PPUSH
50558: LD_INT 1
50560: PPUSH
50561: LD_INT 0
50563: PPUSH
50564: CALL 74760 0 4
50568: PPUSH
50569: CALL_OW 1
50573: ST_TO_ADDR
// break ;
50574: GO 50578
// end ;
50576: GO 50498
50578: POP
50579: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50580: LD_ADDR_VAR 0 6
50584: PUSH
50585: LD_EXP 102
50589: PUSH
50590: LD_VAR 0 2
50594: ARRAY
50595: PPUSH
50596: LD_INT 2
50598: PUSH
50599: LD_INT 30
50601: PUSH
50602: LD_INT 0
50604: PUSH
50605: EMPTY
50606: LIST
50607: LIST
50608: PUSH
50609: LD_INT 30
50611: PUSH
50612: LD_INT 1
50614: PUSH
50615: EMPTY
50616: LIST
50617: LIST
50618: PUSH
50619: EMPTY
50620: LIST
50621: LIST
50622: LIST
50623: PPUSH
50624: CALL_OW 72
50628: ST_TO_ADDR
// for k := 1 to depot do
50629: LD_ADDR_VAR 0 4
50633: PUSH
50634: DOUBLE
50635: LD_INT 1
50637: DEC
50638: ST_TO_ADDR
50639: LD_VAR 0 6
50643: PUSH
50644: FOR_TO
50645: IFFALSE 51215
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
50647: LD_EXP 107
50651: PUSH
50652: LD_VAR 0 2
50656: ARRAY
50657: PUSH
50658: LD_INT 1
50660: ARRAY
50661: PUSH
50662: LD_INT 1
50664: ARRAY
50665: PUSH
50666: LD_INT 0
50668: EQUAL
50669: PUSH
50670: LD_VAR 0 6
50674: PUSH
50675: LD_VAR 0 4
50679: ARRAY
50680: PPUSH
50681: LD_EXP 107
50685: PUSH
50686: LD_VAR 0 2
50690: ARRAY
50691: PUSH
50692: LD_INT 1
50694: ARRAY
50695: PUSH
50696: LD_INT 1
50698: ARRAY
50699: PPUSH
50700: LD_EXP 107
50704: PUSH
50705: LD_VAR 0 2
50709: ARRAY
50710: PUSH
50711: LD_INT 1
50713: ARRAY
50714: PUSH
50715: LD_INT 2
50717: ARRAY
50718: PPUSH
50719: LD_EXP 107
50723: PUSH
50724: LD_VAR 0 2
50728: ARRAY
50729: PUSH
50730: LD_INT 1
50732: ARRAY
50733: PUSH
50734: LD_INT 3
50736: ARRAY
50737: PPUSH
50738: LD_EXP 107
50742: PUSH
50743: LD_VAR 0 2
50747: ARRAY
50748: PUSH
50749: LD_INT 1
50751: ARRAY
50752: PUSH
50753: LD_INT 4
50755: ARRAY
50756: PPUSH
50757: CALL 83816 0 5
50761: OR
50762: IFFALSE 51043
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
50764: LD_ADDR_VAR 0 5
50768: PUSH
50769: LD_EXP 102
50773: PUSH
50774: LD_VAR 0 2
50778: ARRAY
50779: PPUSH
50780: LD_INT 25
50782: PUSH
50783: LD_INT 2
50785: PUSH
50786: EMPTY
50787: LIST
50788: LIST
50789: PPUSH
50790: CALL_OW 72
50794: PUSH
50795: LD_EXP 104
50799: PUSH
50800: LD_VAR 0 2
50804: ARRAY
50805: DIFF
50806: ST_TO_ADDR
// if not tmp then
50807: LD_VAR 0 5
50811: NOT
50812: IFFALSE 50816
// continue ;
50814: GO 50644
// for j in tmp do
50816: LD_ADDR_VAR 0 3
50820: PUSH
50821: LD_VAR 0 5
50825: PUSH
50826: FOR_IN
50827: IFFALSE 51039
// begin if not mc_builders [ i ] then
50829: LD_EXP 108
50833: PUSH
50834: LD_VAR 0 2
50838: ARRAY
50839: NOT
50840: IFFALSE 50898
// begin SetTag ( j , 103 ) ;
50842: LD_VAR 0 3
50846: PPUSH
50847: LD_INT 103
50849: PPUSH
50850: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
50854: LD_ADDR_EXP 108
50858: PUSH
50859: LD_EXP 108
50863: PPUSH
50864: LD_VAR 0 2
50868: PUSH
50869: LD_EXP 108
50873: PUSH
50874: LD_VAR 0 2
50878: ARRAY
50879: PUSH
50880: LD_INT 1
50882: PLUS
50883: PUSH
50884: EMPTY
50885: LIST
50886: LIST
50887: PPUSH
50888: LD_VAR 0 3
50892: PPUSH
50893: CALL 75342 0 3
50897: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
50898: LD_VAR 0 3
50902: PPUSH
50903: CALL_OW 310
50907: IFFALSE 50918
// ComExitBuilding ( j ) ;
50909: LD_VAR 0 3
50913: PPUSH
50914: CALL_OW 122
// wait ( 3 ) ;
50918: LD_INT 3
50920: PPUSH
50921: CALL_OW 67
// if not mc_build_list [ i ] then
50925: LD_EXP 107
50929: PUSH
50930: LD_VAR 0 2
50934: ARRAY
50935: NOT
50936: IFFALSE 50940
// break ;
50938: GO 51039
// if not HasTask ( j ) then
50940: LD_VAR 0 3
50944: PPUSH
50945: CALL_OW 314
50949: NOT
50950: IFFALSE 51037
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
50952: LD_VAR 0 3
50956: PPUSH
50957: LD_EXP 107
50961: PUSH
50962: LD_VAR 0 2
50966: ARRAY
50967: PUSH
50968: LD_INT 1
50970: ARRAY
50971: PUSH
50972: LD_INT 1
50974: ARRAY
50975: PPUSH
50976: LD_EXP 107
50980: PUSH
50981: LD_VAR 0 2
50985: ARRAY
50986: PUSH
50987: LD_INT 1
50989: ARRAY
50990: PUSH
50991: LD_INT 2
50993: ARRAY
50994: PPUSH
50995: LD_EXP 107
50999: PUSH
51000: LD_VAR 0 2
51004: ARRAY
51005: PUSH
51006: LD_INT 1
51008: ARRAY
51009: PUSH
51010: LD_INT 3
51012: ARRAY
51013: PPUSH
51014: LD_EXP 107
51018: PUSH
51019: LD_VAR 0 2
51023: ARRAY
51024: PUSH
51025: LD_INT 1
51027: ARRAY
51028: PUSH
51029: LD_INT 4
51031: ARRAY
51032: PPUSH
51033: CALL_OW 145
// end ;
51037: GO 50826
51039: POP
51040: POP
// end else
51041: GO 51213
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
51043: LD_EXP 102
51047: PUSH
51048: LD_VAR 0 2
51052: ARRAY
51053: PPUSH
51054: LD_EXP 107
51058: PUSH
51059: LD_VAR 0 2
51063: ARRAY
51064: PUSH
51065: LD_INT 1
51067: ARRAY
51068: PUSH
51069: LD_INT 1
51071: ARRAY
51072: PPUSH
51073: LD_EXP 107
51077: PUSH
51078: LD_VAR 0 2
51082: ARRAY
51083: PUSH
51084: LD_INT 1
51086: ARRAY
51087: PUSH
51088: LD_INT 2
51090: ARRAY
51091: PPUSH
51092: LD_EXP 107
51096: PUSH
51097: LD_VAR 0 2
51101: ARRAY
51102: PUSH
51103: LD_INT 1
51105: ARRAY
51106: PUSH
51107: LD_INT 3
51109: ARRAY
51110: PPUSH
51111: LD_EXP 107
51115: PUSH
51116: LD_VAR 0 2
51120: ARRAY
51121: PUSH
51122: LD_INT 1
51124: ARRAY
51125: PUSH
51126: LD_INT 4
51128: ARRAY
51129: PPUSH
51130: LD_EXP 102
51134: PUSH
51135: LD_VAR 0 2
51139: ARRAY
51140: PPUSH
51141: LD_INT 21
51143: PUSH
51144: LD_INT 3
51146: PUSH
51147: EMPTY
51148: LIST
51149: LIST
51150: PPUSH
51151: CALL_OW 72
51155: PPUSH
51156: EMPTY
51157: PPUSH
51158: CALL 82570 0 7
51162: NOT
51163: IFFALSE 51213
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
51165: LD_ADDR_EXP 107
51169: PUSH
51170: LD_EXP 107
51174: PPUSH
51175: LD_VAR 0 2
51179: PPUSH
51180: LD_EXP 107
51184: PUSH
51185: LD_VAR 0 2
51189: ARRAY
51190: PPUSH
51191: LD_INT 1
51193: PPUSH
51194: LD_INT 1
51196: NEG
51197: PPUSH
51198: LD_INT 0
51200: PPUSH
51201: CALL 74760 0 4
51205: PPUSH
51206: CALL_OW 1
51210: ST_TO_ADDR
// continue ;
51211: GO 50644
// end ; end ;
51213: GO 50644
51215: POP
51216: POP
// end ; end ;
51217: GO 50073
51219: POP
51220: POP
// end ;
51221: LD_VAR 0 1
51225: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
51226: LD_INT 0
51228: PPUSH
51229: PPUSH
51230: PPUSH
51231: PPUSH
51232: PPUSH
51233: PPUSH
// if not mc_bases then
51234: LD_EXP 102
51238: NOT
51239: IFFALSE 51243
// exit ;
51241: GO 51670
// for i = 1 to mc_bases do
51243: LD_ADDR_VAR 0 2
51247: PUSH
51248: DOUBLE
51249: LD_INT 1
51251: DEC
51252: ST_TO_ADDR
51253: LD_EXP 102
51257: PUSH
51258: FOR_TO
51259: IFFALSE 51668
// begin tmp := mc_build_upgrade [ i ] ;
51261: LD_ADDR_VAR 0 4
51265: PUSH
51266: LD_EXP 134
51270: PUSH
51271: LD_VAR 0 2
51275: ARRAY
51276: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
51277: LD_ADDR_VAR 0 6
51281: PUSH
51282: LD_EXP 135
51286: PUSH
51287: LD_VAR 0 2
51291: ARRAY
51292: PPUSH
51293: LD_INT 2
51295: PUSH
51296: LD_INT 30
51298: PUSH
51299: LD_INT 6
51301: PUSH
51302: EMPTY
51303: LIST
51304: LIST
51305: PUSH
51306: LD_INT 30
51308: PUSH
51309: LD_INT 7
51311: PUSH
51312: EMPTY
51313: LIST
51314: LIST
51315: PUSH
51316: EMPTY
51317: LIST
51318: LIST
51319: LIST
51320: PPUSH
51321: CALL_OW 72
51325: ST_TO_ADDR
// if not tmp and not lab then
51326: LD_VAR 0 4
51330: NOT
51331: PUSH
51332: LD_VAR 0 6
51336: NOT
51337: AND
51338: IFFALSE 51342
// continue ;
51340: GO 51258
// if tmp then
51342: LD_VAR 0 4
51346: IFFALSE 51466
// for j in tmp do
51348: LD_ADDR_VAR 0 3
51352: PUSH
51353: LD_VAR 0 4
51357: PUSH
51358: FOR_IN
51359: IFFALSE 51464
// begin if UpgradeCost ( j ) then
51361: LD_VAR 0 3
51365: PPUSH
51366: CALL 82230 0 1
51370: IFFALSE 51462
// begin ComUpgrade ( j ) ;
51372: LD_VAR 0 3
51376: PPUSH
51377: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
51381: LD_ADDR_EXP 134
51385: PUSH
51386: LD_EXP 134
51390: PPUSH
51391: LD_VAR 0 2
51395: PPUSH
51396: LD_EXP 134
51400: PUSH
51401: LD_VAR 0 2
51405: ARRAY
51406: PUSH
51407: LD_VAR 0 3
51411: DIFF
51412: PPUSH
51413: CALL_OW 1
51417: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
51418: LD_ADDR_EXP 109
51422: PUSH
51423: LD_EXP 109
51427: PPUSH
51428: LD_VAR 0 2
51432: PUSH
51433: LD_EXP 109
51437: PUSH
51438: LD_VAR 0 2
51442: ARRAY
51443: PUSH
51444: LD_INT 1
51446: PLUS
51447: PUSH
51448: EMPTY
51449: LIST
51450: LIST
51451: PPUSH
51452: LD_VAR 0 3
51456: PPUSH
51457: CALL 75342 0 3
51461: ST_TO_ADDR
// end ; end ;
51462: GO 51358
51464: POP
51465: POP
// if not lab or not mc_lab_upgrade [ i ] then
51466: LD_VAR 0 6
51470: NOT
51471: PUSH
51472: LD_EXP 136
51476: PUSH
51477: LD_VAR 0 2
51481: ARRAY
51482: NOT
51483: OR
51484: IFFALSE 51488
// continue ;
51486: GO 51258
// for j in lab do
51488: LD_ADDR_VAR 0 3
51492: PUSH
51493: LD_VAR 0 6
51497: PUSH
51498: FOR_IN
51499: IFFALSE 51664
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
51501: LD_VAR 0 3
51505: PPUSH
51506: CALL_OW 266
51510: PUSH
51511: LD_INT 6
51513: PUSH
51514: LD_INT 7
51516: PUSH
51517: EMPTY
51518: LIST
51519: LIST
51520: IN
51521: PUSH
51522: LD_VAR 0 3
51526: PPUSH
51527: CALL_OW 461
51531: PUSH
51532: LD_INT 1
51534: NONEQUAL
51535: AND
51536: IFFALSE 51662
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
51538: LD_VAR 0 3
51542: PPUSH
51543: LD_EXP 136
51547: PUSH
51548: LD_VAR 0 2
51552: ARRAY
51553: PUSH
51554: LD_INT 1
51556: ARRAY
51557: PPUSH
51558: CALL 82435 0 2
51562: IFFALSE 51662
// begin ComCancel ( j ) ;
51564: LD_VAR 0 3
51568: PPUSH
51569: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
51573: LD_VAR 0 3
51577: PPUSH
51578: LD_EXP 136
51582: PUSH
51583: LD_VAR 0 2
51587: ARRAY
51588: PUSH
51589: LD_INT 1
51591: ARRAY
51592: PPUSH
51593: CALL_OW 207
// if not j in mc_construct_list [ i ] then
51597: LD_VAR 0 3
51601: PUSH
51602: LD_EXP 109
51606: PUSH
51607: LD_VAR 0 2
51611: ARRAY
51612: IN
51613: NOT
51614: IFFALSE 51660
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
51616: LD_ADDR_EXP 109
51620: PUSH
51621: LD_EXP 109
51625: PPUSH
51626: LD_VAR 0 2
51630: PUSH
51631: LD_EXP 109
51635: PUSH
51636: LD_VAR 0 2
51640: ARRAY
51641: PUSH
51642: LD_INT 1
51644: PLUS
51645: PUSH
51646: EMPTY
51647: LIST
51648: LIST
51649: PPUSH
51650: LD_VAR 0 3
51654: PPUSH
51655: CALL 75342 0 3
51659: ST_TO_ADDR
// break ;
51660: GO 51664
// end ; end ; end ;
51662: GO 51498
51664: POP
51665: POP
// end ;
51666: GO 51258
51668: POP
51669: POP
// end ;
51670: LD_VAR 0 1
51674: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
51675: LD_INT 0
51677: PPUSH
51678: PPUSH
51679: PPUSH
51680: PPUSH
51681: PPUSH
51682: PPUSH
51683: PPUSH
51684: PPUSH
51685: PPUSH
// if not mc_bases then
51686: LD_EXP 102
51690: NOT
51691: IFFALSE 51695
// exit ;
51693: GO 52100
// for i = 1 to mc_bases do
51695: LD_ADDR_VAR 0 2
51699: PUSH
51700: DOUBLE
51701: LD_INT 1
51703: DEC
51704: ST_TO_ADDR
51705: LD_EXP 102
51709: PUSH
51710: FOR_TO
51711: IFFALSE 52098
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
51713: LD_EXP 110
51717: PUSH
51718: LD_VAR 0 2
51722: ARRAY
51723: NOT
51724: PUSH
51725: LD_EXP 102
51729: PUSH
51730: LD_VAR 0 2
51734: ARRAY
51735: PPUSH
51736: LD_INT 30
51738: PUSH
51739: LD_INT 3
51741: PUSH
51742: EMPTY
51743: LIST
51744: LIST
51745: PPUSH
51746: CALL_OW 72
51750: NOT
51751: OR
51752: IFFALSE 51756
// continue ;
51754: GO 51710
// busy := false ;
51756: LD_ADDR_VAR 0 8
51760: PUSH
51761: LD_INT 0
51763: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51764: LD_ADDR_VAR 0 4
51768: PUSH
51769: LD_EXP 102
51773: PUSH
51774: LD_VAR 0 2
51778: ARRAY
51779: PPUSH
51780: LD_INT 30
51782: PUSH
51783: LD_INT 3
51785: PUSH
51786: EMPTY
51787: LIST
51788: LIST
51789: PPUSH
51790: CALL_OW 72
51794: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
51795: LD_ADDR_VAR 0 6
51799: PUSH
51800: LD_EXP 110
51804: PUSH
51805: LD_VAR 0 2
51809: ARRAY
51810: PPUSH
51811: LD_INT 2
51813: PUSH
51814: LD_INT 30
51816: PUSH
51817: LD_INT 32
51819: PUSH
51820: EMPTY
51821: LIST
51822: LIST
51823: PUSH
51824: LD_INT 30
51826: PUSH
51827: LD_INT 33
51829: PUSH
51830: EMPTY
51831: LIST
51832: LIST
51833: PUSH
51834: EMPTY
51835: LIST
51836: LIST
51837: LIST
51838: PPUSH
51839: CALL_OW 72
51843: ST_TO_ADDR
// if not t then
51844: LD_VAR 0 6
51848: NOT
51849: IFFALSE 51853
// continue ;
51851: GO 51710
// for j in tmp do
51853: LD_ADDR_VAR 0 3
51857: PUSH
51858: LD_VAR 0 4
51862: PUSH
51863: FOR_IN
51864: IFFALSE 51894
// if not BuildingStatus ( j ) = bs_idle then
51866: LD_VAR 0 3
51870: PPUSH
51871: CALL_OW 461
51875: PUSH
51876: LD_INT 2
51878: EQUAL
51879: NOT
51880: IFFALSE 51892
// begin busy := true ;
51882: LD_ADDR_VAR 0 8
51886: PUSH
51887: LD_INT 1
51889: ST_TO_ADDR
// break ;
51890: GO 51894
// end ;
51892: GO 51863
51894: POP
51895: POP
// if busy then
51896: LD_VAR 0 8
51900: IFFALSE 51904
// continue ;
51902: GO 51710
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
51904: LD_ADDR_VAR 0 7
51908: PUSH
51909: LD_VAR 0 6
51913: PPUSH
51914: LD_INT 35
51916: PUSH
51917: LD_INT 0
51919: PUSH
51920: EMPTY
51921: LIST
51922: LIST
51923: PPUSH
51924: CALL_OW 72
51928: ST_TO_ADDR
// if tw then
51929: LD_VAR 0 7
51933: IFFALSE 52010
// begin tw := tw [ 1 ] ;
51935: LD_ADDR_VAR 0 7
51939: PUSH
51940: LD_VAR 0 7
51944: PUSH
51945: LD_INT 1
51947: ARRAY
51948: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
51949: LD_ADDR_VAR 0 9
51953: PUSH
51954: LD_VAR 0 7
51958: PPUSH
51959: LD_EXP 127
51963: PUSH
51964: LD_VAR 0 2
51968: ARRAY
51969: PPUSH
51970: CALL 80727 0 2
51974: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
51975: LD_EXP 141
51979: PUSH
51980: LD_VAR 0 2
51984: ARRAY
51985: IFFALSE 52008
// if not weapon in mc_allowed_tower_weapons [ i ] then
51987: LD_VAR 0 9
51991: PUSH
51992: LD_EXP 141
51996: PUSH
51997: LD_VAR 0 2
52001: ARRAY
52002: IN
52003: NOT
52004: IFFALSE 52008
// continue ;
52006: GO 51710
// end else
52008: GO 52073
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
52010: LD_ADDR_VAR 0 5
52014: PUSH
52015: LD_EXP 110
52019: PUSH
52020: LD_VAR 0 2
52024: ARRAY
52025: PPUSH
52026: LD_VAR 0 4
52030: PPUSH
52031: CALL 107639 0 2
52035: ST_TO_ADDR
// if not tmp2 then
52036: LD_VAR 0 5
52040: NOT
52041: IFFALSE 52045
// continue ;
52043: GO 51710
// tw := tmp2 [ 1 ] ;
52045: LD_ADDR_VAR 0 7
52049: PUSH
52050: LD_VAR 0 5
52054: PUSH
52055: LD_INT 1
52057: ARRAY
52058: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
52059: LD_ADDR_VAR 0 9
52063: PUSH
52064: LD_VAR 0 5
52068: PUSH
52069: LD_INT 2
52071: ARRAY
52072: ST_TO_ADDR
// end ; if not weapon then
52073: LD_VAR 0 9
52077: NOT
52078: IFFALSE 52082
// continue ;
52080: GO 51710
// ComPlaceWeapon ( tw , weapon ) ;
52082: LD_VAR 0 7
52086: PPUSH
52087: LD_VAR 0 9
52091: PPUSH
52092: CALL_OW 148
// end ;
52096: GO 51710
52098: POP
52099: POP
// end ;
52100: LD_VAR 0 1
52104: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
52105: LD_INT 0
52107: PPUSH
52108: PPUSH
52109: PPUSH
52110: PPUSH
52111: PPUSH
52112: PPUSH
52113: PPUSH
// if not mc_bases then
52114: LD_EXP 102
52118: NOT
52119: IFFALSE 52123
// exit ;
52121: GO 52898
// for i = 1 to mc_bases do
52123: LD_ADDR_VAR 0 2
52127: PUSH
52128: DOUBLE
52129: LD_INT 1
52131: DEC
52132: ST_TO_ADDR
52133: LD_EXP 102
52137: PUSH
52138: FOR_TO
52139: IFFALSE 52896
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
52141: LD_EXP 115
52145: PUSH
52146: LD_VAR 0 2
52150: ARRAY
52151: NOT
52152: PUSH
52153: LD_EXP 115
52157: PUSH
52158: LD_VAR 0 2
52162: ARRAY
52163: PUSH
52164: LD_EXP 116
52168: PUSH
52169: LD_VAR 0 2
52173: ARRAY
52174: EQUAL
52175: OR
52176: PUSH
52177: LD_EXP 125
52181: PUSH
52182: LD_VAR 0 2
52186: ARRAY
52187: OR
52188: IFFALSE 52192
// continue ;
52190: GO 52138
// if mc_miners [ i ] then
52192: LD_EXP 116
52196: PUSH
52197: LD_VAR 0 2
52201: ARRAY
52202: IFFALSE 52583
// begin for j = mc_miners [ i ] downto 1 do
52204: LD_ADDR_VAR 0 3
52208: PUSH
52209: DOUBLE
52210: LD_EXP 116
52214: PUSH
52215: LD_VAR 0 2
52219: ARRAY
52220: INC
52221: ST_TO_ADDR
52222: LD_INT 1
52224: PUSH
52225: FOR_DOWNTO
52226: IFFALSE 52581
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
52228: LD_EXP 116
52232: PUSH
52233: LD_VAR 0 2
52237: ARRAY
52238: PUSH
52239: LD_VAR 0 3
52243: ARRAY
52244: PPUSH
52245: CALL_OW 301
52249: PUSH
52250: LD_EXP 116
52254: PUSH
52255: LD_VAR 0 2
52259: ARRAY
52260: PUSH
52261: LD_VAR 0 3
52265: ARRAY
52266: PPUSH
52267: CALL_OW 257
52271: PUSH
52272: LD_INT 1
52274: NONEQUAL
52275: OR
52276: IFFALSE 52339
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
52278: LD_ADDR_VAR 0 5
52282: PUSH
52283: LD_EXP 116
52287: PUSH
52288: LD_VAR 0 2
52292: ARRAY
52293: PUSH
52294: LD_EXP 116
52298: PUSH
52299: LD_VAR 0 2
52303: ARRAY
52304: PUSH
52305: LD_VAR 0 3
52309: ARRAY
52310: DIFF
52311: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
52312: LD_ADDR_EXP 116
52316: PUSH
52317: LD_EXP 116
52321: PPUSH
52322: LD_VAR 0 2
52326: PPUSH
52327: LD_VAR 0 5
52331: PPUSH
52332: CALL_OW 1
52336: ST_TO_ADDR
// continue ;
52337: GO 52225
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
52339: LD_EXP 116
52343: PUSH
52344: LD_VAR 0 2
52348: ARRAY
52349: PUSH
52350: LD_VAR 0 3
52354: ARRAY
52355: PPUSH
52356: CALL_OW 257
52360: PUSH
52361: LD_INT 1
52363: EQUAL
52364: PUSH
52365: LD_EXP 116
52369: PUSH
52370: LD_VAR 0 2
52374: ARRAY
52375: PUSH
52376: LD_VAR 0 3
52380: ARRAY
52381: PPUSH
52382: CALL_OW 459
52386: NOT
52387: AND
52388: PUSH
52389: LD_EXP 116
52393: PUSH
52394: LD_VAR 0 2
52398: ARRAY
52399: PUSH
52400: LD_VAR 0 3
52404: ARRAY
52405: PPUSH
52406: CALL_OW 314
52410: NOT
52411: AND
52412: IFFALSE 52579
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
52414: LD_EXP 116
52418: PUSH
52419: LD_VAR 0 2
52423: ARRAY
52424: PUSH
52425: LD_VAR 0 3
52429: ARRAY
52430: PPUSH
52431: CALL_OW 310
52435: IFFALSE 52458
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
52437: LD_EXP 116
52441: PUSH
52442: LD_VAR 0 2
52446: ARRAY
52447: PUSH
52448: LD_VAR 0 3
52452: ARRAY
52453: PPUSH
52454: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
52458: LD_EXP 116
52462: PUSH
52463: LD_VAR 0 2
52467: ARRAY
52468: PUSH
52469: LD_VAR 0 3
52473: ARRAY
52474: PPUSH
52475: CALL_OW 314
52479: NOT
52480: IFFALSE 52579
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
52482: LD_ADDR_VAR 0 7
52486: PUSH
52487: LD_VAR 0 3
52491: PUSH
52492: LD_EXP 115
52496: PUSH
52497: LD_VAR 0 2
52501: ARRAY
52502: PPUSH
52503: CALL 72482 0 1
52507: MOD
52508: PUSH
52509: LD_INT 1
52511: PLUS
52512: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
52513: LD_EXP 116
52517: PUSH
52518: LD_VAR 0 2
52522: ARRAY
52523: PUSH
52524: LD_VAR 0 3
52528: ARRAY
52529: PPUSH
52530: LD_EXP 115
52534: PUSH
52535: LD_VAR 0 2
52539: ARRAY
52540: PUSH
52541: LD_VAR 0 7
52545: ARRAY
52546: PUSH
52547: LD_INT 1
52549: ARRAY
52550: PPUSH
52551: LD_EXP 115
52555: PUSH
52556: LD_VAR 0 2
52560: ARRAY
52561: PUSH
52562: LD_VAR 0 7
52566: ARRAY
52567: PUSH
52568: LD_INT 2
52570: ARRAY
52571: PPUSH
52572: LD_INT 0
52574: PPUSH
52575: CALL_OW 193
// end ; end ; end ;
52579: GO 52225
52581: POP
52582: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
52583: LD_ADDR_VAR 0 5
52587: PUSH
52588: LD_EXP 102
52592: PUSH
52593: LD_VAR 0 2
52597: ARRAY
52598: PPUSH
52599: LD_INT 2
52601: PUSH
52602: LD_INT 30
52604: PUSH
52605: LD_INT 4
52607: PUSH
52608: EMPTY
52609: LIST
52610: LIST
52611: PUSH
52612: LD_INT 30
52614: PUSH
52615: LD_INT 5
52617: PUSH
52618: EMPTY
52619: LIST
52620: LIST
52621: PUSH
52622: LD_INT 30
52624: PUSH
52625: LD_INT 32
52627: PUSH
52628: EMPTY
52629: LIST
52630: LIST
52631: PUSH
52632: EMPTY
52633: LIST
52634: LIST
52635: LIST
52636: LIST
52637: PPUSH
52638: CALL_OW 72
52642: ST_TO_ADDR
// if not tmp then
52643: LD_VAR 0 5
52647: NOT
52648: IFFALSE 52652
// continue ;
52650: GO 52138
// list := [ ] ;
52652: LD_ADDR_VAR 0 6
52656: PUSH
52657: EMPTY
52658: ST_TO_ADDR
// for j in tmp do
52659: LD_ADDR_VAR 0 3
52663: PUSH
52664: LD_VAR 0 5
52668: PUSH
52669: FOR_IN
52670: IFFALSE 52739
// begin for k in UnitsInside ( j ) do
52672: LD_ADDR_VAR 0 4
52676: PUSH
52677: LD_VAR 0 3
52681: PPUSH
52682: CALL_OW 313
52686: PUSH
52687: FOR_IN
52688: IFFALSE 52735
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
52690: LD_VAR 0 4
52694: PPUSH
52695: CALL_OW 257
52699: PUSH
52700: LD_INT 1
52702: EQUAL
52703: PUSH
52704: LD_VAR 0 4
52708: PPUSH
52709: CALL_OW 459
52713: NOT
52714: AND
52715: IFFALSE 52733
// list := list ^ k ;
52717: LD_ADDR_VAR 0 6
52721: PUSH
52722: LD_VAR 0 6
52726: PUSH
52727: LD_VAR 0 4
52731: ADD
52732: ST_TO_ADDR
52733: GO 52687
52735: POP
52736: POP
// end ;
52737: GO 52669
52739: POP
52740: POP
// list := list diff mc_miners [ i ] ;
52741: LD_ADDR_VAR 0 6
52745: PUSH
52746: LD_VAR 0 6
52750: PUSH
52751: LD_EXP 116
52755: PUSH
52756: LD_VAR 0 2
52760: ARRAY
52761: DIFF
52762: ST_TO_ADDR
// if not list then
52763: LD_VAR 0 6
52767: NOT
52768: IFFALSE 52772
// continue ;
52770: GO 52138
// k := mc_mines [ i ] - mc_miners [ i ] ;
52772: LD_ADDR_VAR 0 4
52776: PUSH
52777: LD_EXP 115
52781: PUSH
52782: LD_VAR 0 2
52786: ARRAY
52787: PUSH
52788: LD_EXP 116
52792: PUSH
52793: LD_VAR 0 2
52797: ARRAY
52798: MINUS
52799: ST_TO_ADDR
// if k > list then
52800: LD_VAR 0 4
52804: PUSH
52805: LD_VAR 0 6
52809: GREATER
52810: IFFALSE 52822
// k := list ;
52812: LD_ADDR_VAR 0 4
52816: PUSH
52817: LD_VAR 0 6
52821: ST_TO_ADDR
// for j = 1 to k do
52822: LD_ADDR_VAR 0 3
52826: PUSH
52827: DOUBLE
52828: LD_INT 1
52830: DEC
52831: ST_TO_ADDR
52832: LD_VAR 0 4
52836: PUSH
52837: FOR_TO
52838: IFFALSE 52892
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
52840: LD_ADDR_EXP 116
52844: PUSH
52845: LD_EXP 116
52849: PPUSH
52850: LD_VAR 0 2
52854: PUSH
52855: LD_EXP 116
52859: PUSH
52860: LD_VAR 0 2
52864: ARRAY
52865: PUSH
52866: LD_INT 1
52868: PLUS
52869: PUSH
52870: EMPTY
52871: LIST
52872: LIST
52873: PPUSH
52874: LD_VAR 0 6
52878: PUSH
52879: LD_VAR 0 3
52883: ARRAY
52884: PPUSH
52885: CALL 75342 0 3
52889: ST_TO_ADDR
52890: GO 52837
52892: POP
52893: POP
// end ;
52894: GO 52138
52896: POP
52897: POP
// end ;
52898: LD_VAR 0 1
52902: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
52903: LD_INT 0
52905: PPUSH
52906: PPUSH
52907: PPUSH
52908: PPUSH
52909: PPUSH
52910: PPUSH
52911: PPUSH
52912: PPUSH
52913: PPUSH
52914: PPUSH
52915: PPUSH
// if not mc_bases then
52916: LD_EXP 102
52920: NOT
52921: IFFALSE 52925
// exit ;
52923: GO 54748
// for i = 1 to mc_bases do
52925: LD_ADDR_VAR 0 2
52929: PUSH
52930: DOUBLE
52931: LD_INT 1
52933: DEC
52934: ST_TO_ADDR
52935: LD_EXP 102
52939: PUSH
52940: FOR_TO
52941: IFFALSE 54746
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
52943: LD_EXP 102
52947: PUSH
52948: LD_VAR 0 2
52952: ARRAY
52953: NOT
52954: PUSH
52955: LD_EXP 109
52959: PUSH
52960: LD_VAR 0 2
52964: ARRAY
52965: OR
52966: IFFALSE 52970
// continue ;
52968: GO 52940
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
52970: LD_EXP 118
52974: PUSH
52975: LD_VAR 0 2
52979: ARRAY
52980: NOT
52981: PUSH
52982: LD_EXP 119
52986: PUSH
52987: LD_VAR 0 2
52991: ARRAY
52992: AND
52993: IFFALSE 53031
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
52995: LD_ADDR_EXP 119
52999: PUSH
53000: LD_EXP 119
53004: PPUSH
53005: LD_VAR 0 2
53009: PPUSH
53010: EMPTY
53011: PPUSH
53012: CALL_OW 1
53016: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
53017: LD_VAR 0 2
53021: PPUSH
53022: LD_INT 107
53024: PPUSH
53025: CALL 43757 0 2
// continue ;
53029: GO 52940
// end ; target := [ ] ;
53031: LD_ADDR_VAR 0 7
53035: PUSH
53036: EMPTY
53037: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
53038: LD_ADDR_VAR 0 6
53042: PUSH
53043: LD_EXP 102
53047: PUSH
53048: LD_VAR 0 2
53052: ARRAY
53053: PUSH
53054: LD_INT 1
53056: ARRAY
53057: PPUSH
53058: CALL_OW 255
53062: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53063: LD_ADDR_VAR 0 9
53067: PUSH
53068: LD_EXP 102
53072: PUSH
53073: LD_VAR 0 2
53077: ARRAY
53078: PPUSH
53079: LD_INT 2
53081: PUSH
53082: LD_INT 30
53084: PUSH
53085: LD_INT 0
53087: PUSH
53088: EMPTY
53089: LIST
53090: LIST
53091: PUSH
53092: LD_INT 30
53094: PUSH
53095: LD_INT 1
53097: PUSH
53098: EMPTY
53099: LIST
53100: LIST
53101: PUSH
53102: EMPTY
53103: LIST
53104: LIST
53105: LIST
53106: PPUSH
53107: CALL_OW 72
53111: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
53112: LD_ADDR_VAR 0 3
53116: PUSH
53117: DOUBLE
53118: LD_EXP 118
53122: PUSH
53123: LD_VAR 0 2
53127: ARRAY
53128: INC
53129: ST_TO_ADDR
53130: LD_INT 1
53132: PUSH
53133: FOR_DOWNTO
53134: IFFALSE 53379
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
53136: LD_EXP 118
53140: PUSH
53141: LD_VAR 0 2
53145: ARRAY
53146: PUSH
53147: LD_VAR 0 3
53151: ARRAY
53152: PUSH
53153: LD_INT 2
53155: ARRAY
53156: PPUSH
53157: LD_EXP 118
53161: PUSH
53162: LD_VAR 0 2
53166: ARRAY
53167: PUSH
53168: LD_VAR 0 3
53172: ARRAY
53173: PUSH
53174: LD_INT 3
53176: ARRAY
53177: PPUSH
53178: CALL_OW 488
53182: PUSH
53183: LD_EXP 118
53187: PUSH
53188: LD_VAR 0 2
53192: ARRAY
53193: PUSH
53194: LD_VAR 0 3
53198: ARRAY
53199: PUSH
53200: LD_INT 2
53202: ARRAY
53203: PPUSH
53204: LD_EXP 118
53208: PUSH
53209: LD_VAR 0 2
53213: ARRAY
53214: PUSH
53215: LD_VAR 0 3
53219: ARRAY
53220: PUSH
53221: LD_INT 3
53223: ARRAY
53224: PPUSH
53225: CALL_OW 284
53229: PUSH
53230: LD_INT 0
53232: EQUAL
53233: AND
53234: IFFALSE 53289
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
53236: LD_ADDR_VAR 0 5
53240: PUSH
53241: LD_EXP 118
53245: PUSH
53246: LD_VAR 0 2
53250: ARRAY
53251: PPUSH
53252: LD_VAR 0 3
53256: PPUSH
53257: CALL_OW 3
53261: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
53262: LD_ADDR_EXP 118
53266: PUSH
53267: LD_EXP 118
53271: PPUSH
53272: LD_VAR 0 2
53276: PPUSH
53277: LD_VAR 0 5
53281: PPUSH
53282: CALL_OW 1
53286: ST_TO_ADDR
// continue ;
53287: GO 53133
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
53289: LD_VAR 0 6
53293: PPUSH
53294: LD_EXP 118
53298: PUSH
53299: LD_VAR 0 2
53303: ARRAY
53304: PUSH
53305: LD_VAR 0 3
53309: ARRAY
53310: PUSH
53311: LD_INT 2
53313: ARRAY
53314: PPUSH
53315: LD_EXP 118
53319: PUSH
53320: LD_VAR 0 2
53324: ARRAY
53325: PUSH
53326: LD_VAR 0 3
53330: ARRAY
53331: PUSH
53332: LD_INT 3
53334: ARRAY
53335: PPUSH
53336: LD_INT 30
53338: PPUSH
53339: CALL 76606 0 4
53343: PUSH
53344: LD_INT 4
53346: ARRAY
53347: PUSH
53348: LD_INT 0
53350: EQUAL
53351: IFFALSE 53377
// begin target := mc_crates [ i ] [ j ] ;
53353: LD_ADDR_VAR 0 7
53357: PUSH
53358: LD_EXP 118
53362: PUSH
53363: LD_VAR 0 2
53367: ARRAY
53368: PUSH
53369: LD_VAR 0 3
53373: ARRAY
53374: ST_TO_ADDR
// break ;
53375: GO 53379
// end ; end ;
53377: GO 53133
53379: POP
53380: POP
// if not target then
53381: LD_VAR 0 7
53385: NOT
53386: IFFALSE 53390
// continue ;
53388: GO 52940
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
53390: LD_ADDR_VAR 0 8
53394: PUSH
53395: LD_EXP 121
53399: PUSH
53400: LD_VAR 0 2
53404: ARRAY
53405: PPUSH
53406: LD_INT 2
53408: PUSH
53409: LD_INT 3
53411: PUSH
53412: LD_INT 58
53414: PUSH
53415: EMPTY
53416: LIST
53417: PUSH
53418: EMPTY
53419: LIST
53420: LIST
53421: PUSH
53422: LD_INT 61
53424: PUSH
53425: EMPTY
53426: LIST
53427: PUSH
53428: LD_INT 33
53430: PUSH
53431: LD_INT 5
53433: PUSH
53434: EMPTY
53435: LIST
53436: LIST
53437: PUSH
53438: LD_INT 33
53440: PUSH
53441: LD_INT 3
53443: PUSH
53444: EMPTY
53445: LIST
53446: LIST
53447: PUSH
53448: EMPTY
53449: LIST
53450: LIST
53451: LIST
53452: LIST
53453: LIST
53454: PUSH
53455: LD_INT 2
53457: PUSH
53458: LD_INT 34
53460: PUSH
53461: LD_INT 32
53463: PUSH
53464: EMPTY
53465: LIST
53466: LIST
53467: PUSH
53468: LD_INT 34
53470: PUSH
53471: LD_INT 51
53473: PUSH
53474: EMPTY
53475: LIST
53476: LIST
53477: PUSH
53478: LD_INT 34
53480: PUSH
53481: LD_INT 12
53483: PUSH
53484: EMPTY
53485: LIST
53486: LIST
53487: PUSH
53488: EMPTY
53489: LIST
53490: LIST
53491: LIST
53492: LIST
53493: PUSH
53494: EMPTY
53495: LIST
53496: LIST
53497: PPUSH
53498: CALL_OW 72
53502: ST_TO_ADDR
// if not cargo then
53503: LD_VAR 0 8
53507: NOT
53508: IFFALSE 54214
// begin if mc_crates_collector [ i ] < 5 then
53510: LD_EXP 119
53514: PUSH
53515: LD_VAR 0 2
53519: ARRAY
53520: PUSH
53521: LD_INT 5
53523: LESS
53524: IFFALSE 53890
// begin if mc_ape [ i ] then
53526: LD_EXP 131
53530: PUSH
53531: LD_VAR 0 2
53535: ARRAY
53536: IFFALSE 53583
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
53538: LD_ADDR_VAR 0 5
53542: PUSH
53543: LD_EXP 131
53547: PUSH
53548: LD_VAR 0 2
53552: ARRAY
53553: PPUSH
53554: LD_INT 25
53556: PUSH
53557: LD_INT 16
53559: PUSH
53560: EMPTY
53561: LIST
53562: LIST
53563: PUSH
53564: LD_INT 24
53566: PUSH
53567: LD_INT 750
53569: PUSH
53570: EMPTY
53571: LIST
53572: LIST
53573: PUSH
53574: EMPTY
53575: LIST
53576: LIST
53577: PPUSH
53578: CALL_OW 72
53582: ST_TO_ADDR
// if not tmp then
53583: LD_VAR 0 5
53587: NOT
53588: IFFALSE 53635
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
53590: LD_ADDR_VAR 0 5
53594: PUSH
53595: LD_EXP 102
53599: PUSH
53600: LD_VAR 0 2
53604: ARRAY
53605: PPUSH
53606: LD_INT 25
53608: PUSH
53609: LD_INT 2
53611: PUSH
53612: EMPTY
53613: LIST
53614: LIST
53615: PUSH
53616: LD_INT 24
53618: PUSH
53619: LD_INT 750
53621: PUSH
53622: EMPTY
53623: LIST
53624: LIST
53625: PUSH
53626: EMPTY
53627: LIST
53628: LIST
53629: PPUSH
53630: CALL_OW 72
53634: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
53635: LD_EXP 131
53639: PUSH
53640: LD_VAR 0 2
53644: ARRAY
53645: PUSH
53646: LD_EXP 102
53650: PUSH
53651: LD_VAR 0 2
53655: ARRAY
53656: PPUSH
53657: LD_INT 25
53659: PUSH
53660: LD_INT 2
53662: PUSH
53663: EMPTY
53664: LIST
53665: LIST
53666: PUSH
53667: LD_INT 24
53669: PUSH
53670: LD_INT 750
53672: PUSH
53673: EMPTY
53674: LIST
53675: LIST
53676: PUSH
53677: EMPTY
53678: LIST
53679: LIST
53680: PPUSH
53681: CALL_OW 72
53685: AND
53686: PUSH
53687: LD_VAR 0 5
53691: PUSH
53692: LD_INT 5
53694: LESS
53695: AND
53696: IFFALSE 53778
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
53698: LD_ADDR_VAR 0 3
53702: PUSH
53703: LD_EXP 102
53707: PUSH
53708: LD_VAR 0 2
53712: ARRAY
53713: PPUSH
53714: LD_INT 25
53716: PUSH
53717: LD_INT 2
53719: PUSH
53720: EMPTY
53721: LIST
53722: LIST
53723: PUSH
53724: LD_INT 24
53726: PUSH
53727: LD_INT 750
53729: PUSH
53730: EMPTY
53731: LIST
53732: LIST
53733: PUSH
53734: EMPTY
53735: LIST
53736: LIST
53737: PPUSH
53738: CALL_OW 72
53742: PUSH
53743: FOR_IN
53744: IFFALSE 53776
// begin tmp := tmp union j ;
53746: LD_ADDR_VAR 0 5
53750: PUSH
53751: LD_VAR 0 5
53755: PUSH
53756: LD_VAR 0 3
53760: UNION
53761: ST_TO_ADDR
// if tmp >= 5 then
53762: LD_VAR 0 5
53766: PUSH
53767: LD_INT 5
53769: GREATEREQUAL
53770: IFFALSE 53774
// break ;
53772: GO 53776
// end ;
53774: GO 53743
53776: POP
53777: POP
// end ; if not tmp then
53778: LD_VAR 0 5
53782: NOT
53783: IFFALSE 53787
// continue ;
53785: GO 52940
// for j in tmp do
53787: LD_ADDR_VAR 0 3
53791: PUSH
53792: LD_VAR 0 5
53796: PUSH
53797: FOR_IN
53798: IFFALSE 53888
// if not GetTag ( j ) then
53800: LD_VAR 0 3
53804: PPUSH
53805: CALL_OW 110
53809: NOT
53810: IFFALSE 53886
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
53812: LD_ADDR_EXP 119
53816: PUSH
53817: LD_EXP 119
53821: PPUSH
53822: LD_VAR 0 2
53826: PUSH
53827: LD_EXP 119
53831: PUSH
53832: LD_VAR 0 2
53836: ARRAY
53837: PUSH
53838: LD_INT 1
53840: PLUS
53841: PUSH
53842: EMPTY
53843: LIST
53844: LIST
53845: PPUSH
53846: LD_VAR 0 3
53850: PPUSH
53851: CALL 75342 0 3
53855: ST_TO_ADDR
// SetTag ( j , 107 ) ;
53856: LD_VAR 0 3
53860: PPUSH
53861: LD_INT 107
53863: PPUSH
53864: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
53868: LD_EXP 119
53872: PUSH
53873: LD_VAR 0 2
53877: ARRAY
53878: PUSH
53879: LD_INT 5
53881: GREATEREQUAL
53882: IFFALSE 53886
// break ;
53884: GO 53888
// end ;
53886: GO 53797
53888: POP
53889: POP
// end ; if mc_crates_collector [ i ] and target then
53890: LD_EXP 119
53894: PUSH
53895: LD_VAR 0 2
53899: ARRAY
53900: PUSH
53901: LD_VAR 0 7
53905: AND
53906: IFFALSE 54212
// begin if mc_crates_collector [ i ] < target [ 1 ] then
53908: LD_EXP 119
53912: PUSH
53913: LD_VAR 0 2
53917: ARRAY
53918: PUSH
53919: LD_VAR 0 7
53923: PUSH
53924: LD_INT 1
53926: ARRAY
53927: LESS
53928: IFFALSE 53948
// tmp := mc_crates_collector [ i ] else
53930: LD_ADDR_VAR 0 5
53934: PUSH
53935: LD_EXP 119
53939: PUSH
53940: LD_VAR 0 2
53944: ARRAY
53945: ST_TO_ADDR
53946: GO 53962
// tmp := target [ 1 ] ;
53948: LD_ADDR_VAR 0 5
53952: PUSH
53953: LD_VAR 0 7
53957: PUSH
53958: LD_INT 1
53960: ARRAY
53961: ST_TO_ADDR
// k := 0 ;
53962: LD_ADDR_VAR 0 4
53966: PUSH
53967: LD_INT 0
53969: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
53970: LD_ADDR_VAR 0 3
53974: PUSH
53975: LD_EXP 119
53979: PUSH
53980: LD_VAR 0 2
53984: ARRAY
53985: PUSH
53986: FOR_IN
53987: IFFALSE 54210
// begin k := k + 1 ;
53989: LD_ADDR_VAR 0 4
53993: PUSH
53994: LD_VAR 0 4
53998: PUSH
53999: LD_INT 1
54001: PLUS
54002: ST_TO_ADDR
// if k > tmp then
54003: LD_VAR 0 4
54007: PUSH
54008: LD_VAR 0 5
54012: GREATER
54013: IFFALSE 54017
// break ;
54015: GO 54210
// if not GetClass ( j ) in [ 2 , 16 ] then
54017: LD_VAR 0 3
54021: PPUSH
54022: CALL_OW 257
54026: PUSH
54027: LD_INT 2
54029: PUSH
54030: LD_INT 16
54032: PUSH
54033: EMPTY
54034: LIST
54035: LIST
54036: IN
54037: NOT
54038: IFFALSE 54091
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
54040: LD_ADDR_EXP 119
54044: PUSH
54045: LD_EXP 119
54049: PPUSH
54050: LD_VAR 0 2
54054: PPUSH
54055: LD_EXP 119
54059: PUSH
54060: LD_VAR 0 2
54064: ARRAY
54065: PUSH
54066: LD_VAR 0 3
54070: DIFF
54071: PPUSH
54072: CALL_OW 1
54076: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54077: LD_VAR 0 3
54081: PPUSH
54082: LD_INT 0
54084: PPUSH
54085: CALL_OW 109
// continue ;
54089: GO 53986
// end ; if IsInUnit ( j ) then
54091: LD_VAR 0 3
54095: PPUSH
54096: CALL_OW 310
54100: IFFALSE 54111
// ComExitBuilding ( j ) ;
54102: LD_VAR 0 3
54106: PPUSH
54107: CALL_OW 122
// wait ( 3 ) ;
54111: LD_INT 3
54113: PPUSH
54114: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
54118: LD_VAR 0 3
54122: PPUSH
54123: CALL_OW 314
54127: PUSH
54128: LD_VAR 0 6
54132: PPUSH
54133: LD_VAR 0 7
54137: PUSH
54138: LD_INT 2
54140: ARRAY
54141: PPUSH
54142: LD_VAR 0 7
54146: PUSH
54147: LD_INT 3
54149: ARRAY
54150: PPUSH
54151: LD_INT 30
54153: PPUSH
54154: CALL 76606 0 4
54158: PUSH
54159: LD_INT 4
54161: ARRAY
54162: AND
54163: IFFALSE 54181
// ComStandNearbyBuilding ( j , depot ) else
54165: LD_VAR 0 3
54169: PPUSH
54170: LD_VAR 0 9
54174: PPUSH
54175: CALL 71944 0 2
54179: GO 54208
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
54181: LD_VAR 0 3
54185: PPUSH
54186: LD_VAR 0 7
54190: PUSH
54191: LD_INT 2
54193: ARRAY
54194: PPUSH
54195: LD_VAR 0 7
54199: PUSH
54200: LD_INT 3
54202: ARRAY
54203: PPUSH
54204: CALL_OW 117
// end ;
54208: GO 53986
54210: POP
54211: POP
// end ; end else
54212: GO 54744
// begin for j in cargo do
54214: LD_ADDR_VAR 0 3
54218: PUSH
54219: LD_VAR 0 8
54223: PUSH
54224: FOR_IN
54225: IFFALSE 54742
// begin if GetTag ( j ) <> 0 then
54227: LD_VAR 0 3
54231: PPUSH
54232: CALL_OW 110
54236: PUSH
54237: LD_INT 0
54239: NONEQUAL
54240: IFFALSE 54244
// continue ;
54242: GO 54224
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
54244: LD_VAR 0 3
54248: PPUSH
54249: CALL_OW 256
54253: PUSH
54254: LD_INT 1000
54256: LESS
54257: PUSH
54258: LD_VAR 0 3
54262: PPUSH
54263: LD_EXP 126
54267: PUSH
54268: LD_VAR 0 2
54272: ARRAY
54273: PPUSH
54274: CALL_OW 308
54278: NOT
54279: AND
54280: IFFALSE 54302
// ComMoveToArea ( j , mc_parking [ i ] ) ;
54282: LD_VAR 0 3
54286: PPUSH
54287: LD_EXP 126
54291: PUSH
54292: LD_VAR 0 2
54296: ARRAY
54297: PPUSH
54298: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
54302: LD_VAR 0 3
54306: PPUSH
54307: CALL_OW 256
54311: PUSH
54312: LD_INT 1000
54314: LESS
54315: PUSH
54316: LD_VAR 0 3
54320: PPUSH
54321: LD_EXP 126
54325: PUSH
54326: LD_VAR 0 2
54330: ARRAY
54331: PPUSH
54332: CALL_OW 308
54336: AND
54337: IFFALSE 54341
// continue ;
54339: GO 54224
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
54341: LD_VAR 0 3
54345: PPUSH
54346: CALL_OW 262
54350: PUSH
54351: LD_INT 2
54353: EQUAL
54354: PUSH
54355: LD_VAR 0 3
54359: PPUSH
54360: CALL_OW 261
54364: PUSH
54365: LD_INT 15
54367: LESS
54368: AND
54369: IFFALSE 54373
// continue ;
54371: GO 54224
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
54373: LD_VAR 0 3
54377: PPUSH
54378: CALL_OW 262
54382: PUSH
54383: LD_INT 1
54385: EQUAL
54386: PUSH
54387: LD_VAR 0 3
54391: PPUSH
54392: CALL_OW 261
54396: PUSH
54397: LD_INT 10
54399: LESS
54400: AND
54401: IFFALSE 54681
// begin if not depot then
54403: LD_VAR 0 9
54407: NOT
54408: IFFALSE 54412
// continue ;
54410: GO 54224
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
54412: LD_VAR 0 3
54416: PPUSH
54417: LD_VAR 0 9
54421: PPUSH
54422: LD_VAR 0 3
54426: PPUSH
54427: CALL_OW 74
54431: PPUSH
54432: CALL_OW 296
54436: PUSH
54437: LD_INT 6
54439: LESS
54440: IFFALSE 54456
// SetFuel ( j , 100 ) else
54442: LD_VAR 0 3
54446: PPUSH
54447: LD_INT 100
54449: PPUSH
54450: CALL_OW 240
54454: GO 54681
// if GetFuel ( j ) = 0 then
54456: LD_VAR 0 3
54460: PPUSH
54461: CALL_OW 261
54465: PUSH
54466: LD_INT 0
54468: EQUAL
54469: IFFALSE 54681
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
54471: LD_ADDR_EXP 121
54475: PUSH
54476: LD_EXP 121
54480: PPUSH
54481: LD_VAR 0 2
54485: PPUSH
54486: LD_EXP 121
54490: PUSH
54491: LD_VAR 0 2
54495: ARRAY
54496: PUSH
54497: LD_VAR 0 3
54501: DIFF
54502: PPUSH
54503: CALL_OW 1
54507: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
54508: LD_VAR 0 3
54512: PPUSH
54513: CALL_OW 263
54517: PUSH
54518: LD_INT 1
54520: EQUAL
54521: IFFALSE 54537
// ComExitVehicle ( IsInUnit ( j ) ) ;
54523: LD_VAR 0 3
54527: PPUSH
54528: CALL_OW 310
54532: PPUSH
54533: CALL_OW 121
// if GetControl ( j ) = control_remote then
54537: LD_VAR 0 3
54541: PPUSH
54542: CALL_OW 263
54546: PUSH
54547: LD_INT 2
54549: EQUAL
54550: IFFALSE 54561
// ComUnlink ( j ) ;
54552: LD_VAR 0 3
54556: PPUSH
54557: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
54561: LD_ADDR_VAR 0 10
54565: PUSH
54566: LD_VAR 0 2
54570: PPUSH
54571: LD_INT 3
54573: PPUSH
54574: CALL 64325 0 2
54578: ST_TO_ADDR
// if fac then
54579: LD_VAR 0 10
54583: IFFALSE 54679
// begin for k in fac do
54585: LD_ADDR_VAR 0 4
54589: PUSH
54590: LD_VAR 0 10
54594: PUSH
54595: FOR_IN
54596: IFFALSE 54677
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
54598: LD_ADDR_VAR 0 11
54602: PUSH
54603: LD_VAR 0 10
54607: PPUSH
54608: LD_VAR 0 3
54612: PPUSH
54613: CALL_OW 265
54617: PPUSH
54618: LD_VAR 0 3
54622: PPUSH
54623: CALL_OW 262
54627: PPUSH
54628: LD_VAR 0 3
54632: PPUSH
54633: CALL_OW 263
54637: PPUSH
54638: LD_VAR 0 3
54642: PPUSH
54643: CALL_OW 264
54647: PPUSH
54648: CALL 72840 0 5
54652: ST_TO_ADDR
// if components then
54653: LD_VAR 0 11
54657: IFFALSE 54675
// begin MC_InsertProduceList ( i , components ) ;
54659: LD_VAR 0 2
54663: PPUSH
54664: LD_VAR 0 11
54668: PPUSH
54669: CALL 63870 0 2
// break ;
54673: GO 54677
// end ; end ;
54675: GO 54595
54677: POP
54678: POP
// end ; continue ;
54679: GO 54224
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
54681: LD_VAR 0 3
54685: PPUSH
54686: LD_INT 1
54688: PPUSH
54689: CALL_OW 289
54693: PUSH
54694: LD_INT 100
54696: LESS
54697: PUSH
54698: LD_VAR 0 3
54702: PPUSH
54703: CALL_OW 314
54707: NOT
54708: AND
54709: IFFALSE 54738
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
54711: LD_VAR 0 3
54715: PPUSH
54716: LD_VAR 0 7
54720: PUSH
54721: LD_INT 2
54723: ARRAY
54724: PPUSH
54725: LD_VAR 0 7
54729: PUSH
54730: LD_INT 3
54732: ARRAY
54733: PPUSH
54734: CALL_OW 117
// break ;
54738: GO 54742
// end ;
54740: GO 54224
54742: POP
54743: POP
// end ; end ;
54744: GO 52940
54746: POP
54747: POP
// end ;
54748: LD_VAR 0 1
54752: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
54753: LD_INT 0
54755: PPUSH
54756: PPUSH
54757: PPUSH
54758: PPUSH
// if not mc_bases then
54759: LD_EXP 102
54763: NOT
54764: IFFALSE 54768
// exit ;
54766: GO 54929
// for i = 1 to mc_bases do
54768: LD_ADDR_VAR 0 2
54772: PUSH
54773: DOUBLE
54774: LD_INT 1
54776: DEC
54777: ST_TO_ADDR
54778: LD_EXP 102
54782: PUSH
54783: FOR_TO
54784: IFFALSE 54927
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
54786: LD_ADDR_VAR 0 4
54790: PUSH
54791: LD_EXP 121
54795: PUSH
54796: LD_VAR 0 2
54800: ARRAY
54801: PUSH
54802: LD_EXP 124
54806: PUSH
54807: LD_VAR 0 2
54811: ARRAY
54812: UNION
54813: PPUSH
54814: LD_INT 33
54816: PUSH
54817: LD_INT 2
54819: PUSH
54820: EMPTY
54821: LIST
54822: LIST
54823: PPUSH
54824: CALL_OW 72
54828: ST_TO_ADDR
// if tmp then
54829: LD_VAR 0 4
54833: IFFALSE 54925
// for j in tmp do
54835: LD_ADDR_VAR 0 3
54839: PUSH
54840: LD_VAR 0 4
54844: PUSH
54845: FOR_IN
54846: IFFALSE 54923
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
54848: LD_VAR 0 3
54852: PPUSH
54853: CALL_OW 312
54857: NOT
54858: PUSH
54859: LD_VAR 0 3
54863: PPUSH
54864: CALL_OW 256
54868: PUSH
54869: LD_INT 250
54871: GREATEREQUAL
54872: AND
54873: IFFALSE 54886
// Connect ( j ) else
54875: LD_VAR 0 3
54879: PPUSH
54880: CALL 78688 0 1
54884: GO 54921
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
54886: LD_VAR 0 3
54890: PPUSH
54891: CALL_OW 256
54895: PUSH
54896: LD_INT 250
54898: LESS
54899: PUSH
54900: LD_VAR 0 3
54904: PPUSH
54905: CALL_OW 312
54909: AND
54910: IFFALSE 54921
// ComUnlink ( j ) ;
54912: LD_VAR 0 3
54916: PPUSH
54917: CALL_OW 136
54921: GO 54845
54923: POP
54924: POP
// end ;
54925: GO 54783
54927: POP
54928: POP
// end ;
54929: LD_VAR 0 1
54933: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
54934: LD_INT 0
54936: PPUSH
54937: PPUSH
54938: PPUSH
54939: PPUSH
54940: PPUSH
// if not mc_bases then
54941: LD_EXP 102
54945: NOT
54946: IFFALSE 54950
// exit ;
54948: GO 55395
// for i = 1 to mc_bases do
54950: LD_ADDR_VAR 0 2
54954: PUSH
54955: DOUBLE
54956: LD_INT 1
54958: DEC
54959: ST_TO_ADDR
54960: LD_EXP 102
54964: PUSH
54965: FOR_TO
54966: IFFALSE 55393
// begin if not mc_produce [ i ] then
54968: LD_EXP 123
54972: PUSH
54973: LD_VAR 0 2
54977: ARRAY
54978: NOT
54979: IFFALSE 54983
// continue ;
54981: GO 54965
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54983: LD_ADDR_VAR 0 5
54987: PUSH
54988: LD_EXP 102
54992: PUSH
54993: LD_VAR 0 2
54997: ARRAY
54998: PPUSH
54999: LD_INT 30
55001: PUSH
55002: LD_INT 3
55004: PUSH
55005: EMPTY
55006: LIST
55007: LIST
55008: PPUSH
55009: CALL_OW 72
55013: ST_TO_ADDR
// if not fac then
55014: LD_VAR 0 5
55018: NOT
55019: IFFALSE 55023
// continue ;
55021: GO 54965
// for j in fac do
55023: LD_ADDR_VAR 0 3
55027: PUSH
55028: LD_VAR 0 5
55032: PUSH
55033: FOR_IN
55034: IFFALSE 55389
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
55036: LD_VAR 0 3
55040: PPUSH
55041: CALL_OW 461
55045: PUSH
55046: LD_INT 2
55048: NONEQUAL
55049: PUSH
55050: LD_VAR 0 3
55054: PPUSH
55055: LD_INT 15
55057: PPUSH
55058: CALL 78307 0 2
55062: PUSH
55063: LD_INT 4
55065: ARRAY
55066: OR
55067: IFFALSE 55071
// continue ;
55069: GO 55033
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
55071: LD_VAR 0 3
55075: PPUSH
55076: LD_EXP 123
55080: PUSH
55081: LD_VAR 0 2
55085: ARRAY
55086: PUSH
55087: LD_INT 1
55089: ARRAY
55090: PUSH
55091: LD_INT 1
55093: ARRAY
55094: PPUSH
55095: LD_EXP 123
55099: PUSH
55100: LD_VAR 0 2
55104: ARRAY
55105: PUSH
55106: LD_INT 1
55108: ARRAY
55109: PUSH
55110: LD_INT 2
55112: ARRAY
55113: PPUSH
55114: LD_EXP 123
55118: PUSH
55119: LD_VAR 0 2
55123: ARRAY
55124: PUSH
55125: LD_INT 1
55127: ARRAY
55128: PUSH
55129: LD_INT 3
55131: ARRAY
55132: PPUSH
55133: LD_EXP 123
55137: PUSH
55138: LD_VAR 0 2
55142: ARRAY
55143: PUSH
55144: LD_INT 1
55146: ARRAY
55147: PUSH
55148: LD_INT 4
55150: ARRAY
55151: PPUSH
55152: CALL_OW 448
55156: PUSH
55157: LD_VAR 0 3
55161: PPUSH
55162: LD_EXP 123
55166: PUSH
55167: LD_VAR 0 2
55171: ARRAY
55172: PUSH
55173: LD_INT 1
55175: ARRAY
55176: PUSH
55177: LD_INT 1
55179: ARRAY
55180: PUSH
55181: LD_EXP 123
55185: PUSH
55186: LD_VAR 0 2
55190: ARRAY
55191: PUSH
55192: LD_INT 1
55194: ARRAY
55195: PUSH
55196: LD_INT 2
55198: ARRAY
55199: PUSH
55200: LD_EXP 123
55204: PUSH
55205: LD_VAR 0 2
55209: ARRAY
55210: PUSH
55211: LD_INT 1
55213: ARRAY
55214: PUSH
55215: LD_INT 3
55217: ARRAY
55218: PUSH
55219: LD_EXP 123
55223: PUSH
55224: LD_VAR 0 2
55228: ARRAY
55229: PUSH
55230: LD_INT 1
55232: ARRAY
55233: PUSH
55234: LD_INT 4
55236: ARRAY
55237: PUSH
55238: EMPTY
55239: LIST
55240: LIST
55241: LIST
55242: LIST
55243: PPUSH
55244: CALL 82083 0 2
55248: AND
55249: IFFALSE 55387
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
55251: LD_VAR 0 3
55255: PPUSH
55256: LD_EXP 123
55260: PUSH
55261: LD_VAR 0 2
55265: ARRAY
55266: PUSH
55267: LD_INT 1
55269: ARRAY
55270: PUSH
55271: LD_INT 1
55273: ARRAY
55274: PPUSH
55275: LD_EXP 123
55279: PUSH
55280: LD_VAR 0 2
55284: ARRAY
55285: PUSH
55286: LD_INT 1
55288: ARRAY
55289: PUSH
55290: LD_INT 2
55292: ARRAY
55293: PPUSH
55294: LD_EXP 123
55298: PUSH
55299: LD_VAR 0 2
55303: ARRAY
55304: PUSH
55305: LD_INT 1
55307: ARRAY
55308: PUSH
55309: LD_INT 3
55311: ARRAY
55312: PPUSH
55313: LD_EXP 123
55317: PUSH
55318: LD_VAR 0 2
55322: ARRAY
55323: PUSH
55324: LD_INT 1
55326: ARRAY
55327: PUSH
55328: LD_INT 4
55330: ARRAY
55331: PPUSH
55332: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
55336: LD_ADDR_VAR 0 4
55340: PUSH
55341: LD_EXP 123
55345: PUSH
55346: LD_VAR 0 2
55350: ARRAY
55351: PPUSH
55352: LD_INT 1
55354: PPUSH
55355: CALL_OW 3
55359: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
55360: LD_ADDR_EXP 123
55364: PUSH
55365: LD_EXP 123
55369: PPUSH
55370: LD_VAR 0 2
55374: PPUSH
55375: LD_VAR 0 4
55379: PPUSH
55380: CALL_OW 1
55384: ST_TO_ADDR
// break ;
55385: GO 55389
// end ; end ;
55387: GO 55033
55389: POP
55390: POP
// end ;
55391: GO 54965
55393: POP
55394: POP
// end ;
55395: LD_VAR 0 1
55399: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
55400: LD_INT 0
55402: PPUSH
55403: PPUSH
55404: PPUSH
// if not mc_bases then
55405: LD_EXP 102
55409: NOT
55410: IFFALSE 55414
// exit ;
55412: GO 55503
// for i = 1 to mc_bases do
55414: LD_ADDR_VAR 0 2
55418: PUSH
55419: DOUBLE
55420: LD_INT 1
55422: DEC
55423: ST_TO_ADDR
55424: LD_EXP 102
55428: PUSH
55429: FOR_TO
55430: IFFALSE 55501
// begin if mc_attack [ i ] then
55432: LD_EXP 122
55436: PUSH
55437: LD_VAR 0 2
55441: ARRAY
55442: IFFALSE 55499
// begin tmp := mc_attack [ i ] [ 1 ] ;
55444: LD_ADDR_VAR 0 3
55448: PUSH
55449: LD_EXP 122
55453: PUSH
55454: LD_VAR 0 2
55458: ARRAY
55459: PUSH
55460: LD_INT 1
55462: ARRAY
55463: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
55464: LD_ADDR_EXP 122
55468: PUSH
55469: LD_EXP 122
55473: PPUSH
55474: LD_VAR 0 2
55478: PPUSH
55479: EMPTY
55480: PPUSH
55481: CALL_OW 1
55485: ST_TO_ADDR
// Attack ( tmp ) ;
55486: LD_VAR 0 3
55490: PPUSH
55491: CALL 134492 0 1
// exit ;
55495: POP
55496: POP
55497: GO 55503
// end ; end ;
55499: GO 55429
55501: POP
55502: POP
// end ;
55503: LD_VAR 0 1
55507: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
55508: LD_INT 0
55510: PPUSH
55511: PPUSH
55512: PPUSH
55513: PPUSH
55514: PPUSH
55515: PPUSH
55516: PPUSH
// if not mc_bases then
55517: LD_EXP 102
55521: NOT
55522: IFFALSE 55526
// exit ;
55524: GO 56383
// for i = 1 to mc_bases do
55526: LD_ADDR_VAR 0 2
55530: PUSH
55531: DOUBLE
55532: LD_INT 1
55534: DEC
55535: ST_TO_ADDR
55536: LD_EXP 102
55540: PUSH
55541: FOR_TO
55542: IFFALSE 56381
// begin if not mc_bases [ i ] then
55544: LD_EXP 102
55548: PUSH
55549: LD_VAR 0 2
55553: ARRAY
55554: NOT
55555: IFFALSE 55559
// continue ;
55557: GO 55541
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
55559: LD_ADDR_VAR 0 7
55563: PUSH
55564: LD_EXP 102
55568: PUSH
55569: LD_VAR 0 2
55573: ARRAY
55574: PUSH
55575: LD_INT 1
55577: ARRAY
55578: PPUSH
55579: CALL 72166 0 1
55583: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
55584: LD_ADDR_EXP 125
55588: PUSH
55589: LD_EXP 125
55593: PPUSH
55594: LD_VAR 0 2
55598: PPUSH
55599: LD_EXP 102
55603: PUSH
55604: LD_VAR 0 2
55608: ARRAY
55609: PUSH
55610: LD_INT 1
55612: ARRAY
55613: PPUSH
55614: CALL_OW 255
55618: PPUSH
55619: LD_EXP 127
55623: PUSH
55624: LD_VAR 0 2
55628: ARRAY
55629: PPUSH
55630: CALL 72131 0 2
55634: PPUSH
55635: CALL_OW 1
55639: ST_TO_ADDR
// if not mc_scan [ i ] then
55640: LD_EXP 125
55644: PUSH
55645: LD_VAR 0 2
55649: ARRAY
55650: NOT
55651: IFFALSE 55829
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
55653: LD_ADDR_EXP 145
55657: PUSH
55658: LD_EXP 145
55662: PPUSH
55663: LD_VAR 0 2
55667: PPUSH
55668: LD_INT 0
55670: PPUSH
55671: CALL_OW 1
55675: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55676: LD_ADDR_VAR 0 4
55680: PUSH
55681: LD_EXP 102
55685: PUSH
55686: LD_VAR 0 2
55690: ARRAY
55691: PPUSH
55692: LD_INT 2
55694: PUSH
55695: LD_INT 25
55697: PUSH
55698: LD_INT 5
55700: PUSH
55701: EMPTY
55702: LIST
55703: LIST
55704: PUSH
55705: LD_INT 25
55707: PUSH
55708: LD_INT 8
55710: PUSH
55711: EMPTY
55712: LIST
55713: LIST
55714: PUSH
55715: LD_INT 25
55717: PUSH
55718: LD_INT 9
55720: PUSH
55721: EMPTY
55722: LIST
55723: LIST
55724: PUSH
55725: EMPTY
55726: LIST
55727: LIST
55728: LIST
55729: LIST
55730: PPUSH
55731: CALL_OW 72
55735: ST_TO_ADDR
// if not tmp then
55736: LD_VAR 0 4
55740: NOT
55741: IFFALSE 55745
// continue ;
55743: GO 55541
// for j in tmp do
55745: LD_ADDR_VAR 0 3
55749: PUSH
55750: LD_VAR 0 4
55754: PUSH
55755: FOR_IN
55756: IFFALSE 55827
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
55758: LD_VAR 0 3
55762: PPUSH
55763: CALL_OW 310
55767: PPUSH
55768: CALL_OW 266
55772: PUSH
55773: LD_INT 5
55775: EQUAL
55776: PUSH
55777: LD_VAR 0 3
55781: PPUSH
55782: CALL_OW 257
55786: PUSH
55787: LD_INT 1
55789: EQUAL
55790: AND
55791: PUSH
55792: LD_VAR 0 3
55796: PPUSH
55797: CALL_OW 459
55801: NOT
55802: AND
55803: PUSH
55804: LD_VAR 0 7
55808: AND
55809: IFFALSE 55825
// ComChangeProfession ( j , class ) ;
55811: LD_VAR 0 3
55815: PPUSH
55816: LD_VAR 0 7
55820: PPUSH
55821: CALL_OW 123
55825: GO 55755
55827: POP
55828: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
55829: LD_EXP 125
55833: PUSH
55834: LD_VAR 0 2
55838: ARRAY
55839: PUSH
55840: LD_EXP 145
55844: PUSH
55845: LD_VAR 0 2
55849: ARRAY
55850: NOT
55851: AND
55852: PUSH
55853: LD_EXP 124
55857: PUSH
55858: LD_VAR 0 2
55862: ARRAY
55863: NOT
55864: AND
55865: PUSH
55866: LD_EXP 102
55870: PUSH
55871: LD_VAR 0 2
55875: ARRAY
55876: PPUSH
55877: LD_INT 50
55879: PUSH
55880: EMPTY
55881: LIST
55882: PUSH
55883: LD_INT 2
55885: PUSH
55886: LD_INT 30
55888: PUSH
55889: LD_INT 32
55891: PUSH
55892: EMPTY
55893: LIST
55894: LIST
55895: PUSH
55896: LD_INT 30
55898: PUSH
55899: LD_INT 33
55901: PUSH
55902: EMPTY
55903: LIST
55904: LIST
55905: PUSH
55906: LD_INT 30
55908: PUSH
55909: LD_INT 4
55911: PUSH
55912: EMPTY
55913: LIST
55914: LIST
55915: PUSH
55916: LD_INT 30
55918: PUSH
55919: LD_INT 5
55921: PUSH
55922: EMPTY
55923: LIST
55924: LIST
55925: PUSH
55926: EMPTY
55927: LIST
55928: LIST
55929: LIST
55930: LIST
55931: LIST
55932: PUSH
55933: EMPTY
55934: LIST
55935: LIST
55936: PPUSH
55937: CALL_OW 72
55941: PUSH
55942: LD_INT 4
55944: LESS
55945: PUSH
55946: LD_EXP 102
55950: PUSH
55951: LD_VAR 0 2
55955: ARRAY
55956: PPUSH
55957: LD_INT 3
55959: PUSH
55960: LD_INT 24
55962: PUSH
55963: LD_INT 1000
55965: PUSH
55966: EMPTY
55967: LIST
55968: LIST
55969: PUSH
55970: EMPTY
55971: LIST
55972: LIST
55973: PUSH
55974: LD_INT 2
55976: PUSH
55977: LD_INT 30
55979: PUSH
55980: LD_INT 0
55982: PUSH
55983: EMPTY
55984: LIST
55985: LIST
55986: PUSH
55987: LD_INT 30
55989: PUSH
55990: LD_INT 1
55992: PUSH
55993: EMPTY
55994: LIST
55995: LIST
55996: PUSH
55997: EMPTY
55998: LIST
55999: LIST
56000: LIST
56001: PUSH
56002: EMPTY
56003: LIST
56004: LIST
56005: PPUSH
56006: CALL_OW 72
56010: OR
56011: AND
56012: IFFALSE 56263
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
56014: LD_ADDR_EXP 145
56018: PUSH
56019: LD_EXP 145
56023: PPUSH
56024: LD_VAR 0 2
56028: PPUSH
56029: LD_INT 1
56031: PPUSH
56032: CALL_OW 1
56036: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56037: LD_ADDR_VAR 0 4
56041: PUSH
56042: LD_EXP 102
56046: PUSH
56047: LD_VAR 0 2
56051: ARRAY
56052: PPUSH
56053: LD_INT 2
56055: PUSH
56056: LD_INT 25
56058: PUSH
56059: LD_INT 1
56061: PUSH
56062: EMPTY
56063: LIST
56064: LIST
56065: PUSH
56066: LD_INT 25
56068: PUSH
56069: LD_INT 5
56071: PUSH
56072: EMPTY
56073: LIST
56074: LIST
56075: PUSH
56076: LD_INT 25
56078: PUSH
56079: LD_INT 8
56081: PUSH
56082: EMPTY
56083: LIST
56084: LIST
56085: PUSH
56086: LD_INT 25
56088: PUSH
56089: LD_INT 9
56091: PUSH
56092: EMPTY
56093: LIST
56094: LIST
56095: PUSH
56096: EMPTY
56097: LIST
56098: LIST
56099: LIST
56100: LIST
56101: LIST
56102: PPUSH
56103: CALL_OW 72
56107: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
56108: LD_ADDR_VAR 0 4
56112: PUSH
56113: LD_VAR 0 4
56117: PUSH
56118: LD_VAR 0 4
56122: PPUSH
56123: LD_INT 18
56125: PPUSH
56126: CALL 105660 0 2
56130: DIFF
56131: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
56132: LD_VAR 0 4
56136: NOT
56137: PUSH
56138: LD_EXP 102
56142: PUSH
56143: LD_VAR 0 2
56147: ARRAY
56148: PPUSH
56149: LD_INT 2
56151: PUSH
56152: LD_INT 30
56154: PUSH
56155: LD_INT 4
56157: PUSH
56158: EMPTY
56159: LIST
56160: LIST
56161: PUSH
56162: LD_INT 30
56164: PUSH
56165: LD_INT 5
56167: PUSH
56168: EMPTY
56169: LIST
56170: LIST
56171: PUSH
56172: EMPTY
56173: LIST
56174: LIST
56175: LIST
56176: PPUSH
56177: CALL_OW 72
56181: NOT
56182: AND
56183: IFFALSE 56245
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
56185: LD_ADDR_VAR 0 4
56189: PUSH
56190: LD_EXP 102
56194: PUSH
56195: LD_VAR 0 2
56199: ARRAY
56200: PPUSH
56201: LD_INT 2
56203: PUSH
56204: LD_INT 25
56206: PUSH
56207: LD_INT 2
56209: PUSH
56210: EMPTY
56211: LIST
56212: LIST
56213: PUSH
56214: LD_INT 25
56216: PUSH
56217: LD_INT 3
56219: PUSH
56220: EMPTY
56221: LIST
56222: LIST
56223: PUSH
56224: LD_INT 25
56226: PUSH
56227: LD_INT 4
56229: PUSH
56230: EMPTY
56231: LIST
56232: LIST
56233: PUSH
56234: EMPTY
56235: LIST
56236: LIST
56237: LIST
56238: LIST
56239: PPUSH
56240: CALL_OW 72
56244: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
56245: LD_VAR 0 2
56249: PPUSH
56250: LD_VAR 0 4
56254: PPUSH
56255: CALL 139201 0 2
// exit ;
56259: POP
56260: POP
56261: GO 56383
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
56263: LD_EXP 125
56267: PUSH
56268: LD_VAR 0 2
56272: ARRAY
56273: PUSH
56274: LD_EXP 145
56278: PUSH
56279: LD_VAR 0 2
56283: ARRAY
56284: NOT
56285: AND
56286: PUSH
56287: LD_EXP 124
56291: PUSH
56292: LD_VAR 0 2
56296: ARRAY
56297: AND
56298: IFFALSE 56379
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
56300: LD_ADDR_EXP 145
56304: PUSH
56305: LD_EXP 145
56309: PPUSH
56310: LD_VAR 0 2
56314: PPUSH
56315: LD_INT 1
56317: PPUSH
56318: CALL_OW 1
56322: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
56323: LD_ADDR_VAR 0 4
56327: PUSH
56328: LD_EXP 124
56332: PUSH
56333: LD_VAR 0 2
56337: ARRAY
56338: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
56339: LD_ADDR_EXP 124
56343: PUSH
56344: LD_EXP 124
56348: PPUSH
56349: LD_VAR 0 2
56353: PPUSH
56354: EMPTY
56355: PPUSH
56356: CALL_OW 1
56360: ST_TO_ADDR
// Defend ( i , tmp ) ;
56361: LD_VAR 0 2
56365: PPUSH
56366: LD_VAR 0 4
56370: PPUSH
56371: CALL 139797 0 2
// exit ;
56375: POP
56376: POP
56377: GO 56383
// end ; end ;
56379: GO 55541
56381: POP
56382: POP
// end ;
56383: LD_VAR 0 1
56387: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
56388: LD_INT 0
56390: PPUSH
56391: PPUSH
56392: PPUSH
56393: PPUSH
56394: PPUSH
56395: PPUSH
56396: PPUSH
56397: PPUSH
56398: PPUSH
56399: PPUSH
56400: PPUSH
// if not mc_bases then
56401: LD_EXP 102
56405: NOT
56406: IFFALSE 56410
// exit ;
56408: GO 57497
// for i = 1 to mc_bases do
56410: LD_ADDR_VAR 0 2
56414: PUSH
56415: DOUBLE
56416: LD_INT 1
56418: DEC
56419: ST_TO_ADDR
56420: LD_EXP 102
56424: PUSH
56425: FOR_TO
56426: IFFALSE 57495
// begin tmp := mc_lab [ i ] ;
56428: LD_ADDR_VAR 0 6
56432: PUSH
56433: LD_EXP 135
56437: PUSH
56438: LD_VAR 0 2
56442: ARRAY
56443: ST_TO_ADDR
// if not tmp then
56444: LD_VAR 0 6
56448: NOT
56449: IFFALSE 56453
// continue ;
56451: GO 56425
// idle_lab := 0 ;
56453: LD_ADDR_VAR 0 11
56457: PUSH
56458: LD_INT 0
56460: ST_TO_ADDR
// for j in tmp do
56461: LD_ADDR_VAR 0 3
56465: PUSH
56466: LD_VAR 0 6
56470: PUSH
56471: FOR_IN
56472: IFFALSE 57491
// begin researching := false ;
56474: LD_ADDR_VAR 0 10
56478: PUSH
56479: LD_INT 0
56481: ST_TO_ADDR
// side := GetSide ( j ) ;
56482: LD_ADDR_VAR 0 4
56486: PUSH
56487: LD_VAR 0 3
56491: PPUSH
56492: CALL_OW 255
56496: ST_TO_ADDR
// if not mc_tech [ side ] then
56497: LD_EXP 129
56501: PUSH
56502: LD_VAR 0 4
56506: ARRAY
56507: NOT
56508: IFFALSE 56512
// continue ;
56510: GO 56471
// if BuildingStatus ( j ) = bs_idle then
56512: LD_VAR 0 3
56516: PPUSH
56517: CALL_OW 461
56521: PUSH
56522: LD_INT 2
56524: EQUAL
56525: IFFALSE 56713
// begin if idle_lab and UnitsInside ( j ) < 6 then
56527: LD_VAR 0 11
56531: PUSH
56532: LD_VAR 0 3
56536: PPUSH
56537: CALL_OW 313
56541: PUSH
56542: LD_INT 6
56544: LESS
56545: AND
56546: IFFALSE 56617
// begin tmp2 := UnitsInside ( idle_lab ) ;
56548: LD_ADDR_VAR 0 9
56552: PUSH
56553: LD_VAR 0 11
56557: PPUSH
56558: CALL_OW 313
56562: ST_TO_ADDR
// if tmp2 then
56563: LD_VAR 0 9
56567: IFFALSE 56609
// for x in tmp2 do
56569: LD_ADDR_VAR 0 7
56573: PUSH
56574: LD_VAR 0 9
56578: PUSH
56579: FOR_IN
56580: IFFALSE 56607
// begin ComExitBuilding ( x ) ;
56582: LD_VAR 0 7
56586: PPUSH
56587: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
56591: LD_VAR 0 7
56595: PPUSH
56596: LD_VAR 0 3
56600: PPUSH
56601: CALL_OW 180
// end ;
56605: GO 56579
56607: POP
56608: POP
// idle_lab := 0 ;
56609: LD_ADDR_VAR 0 11
56613: PUSH
56614: LD_INT 0
56616: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
56617: LD_ADDR_VAR 0 5
56621: PUSH
56622: LD_EXP 129
56626: PUSH
56627: LD_VAR 0 4
56631: ARRAY
56632: PUSH
56633: FOR_IN
56634: IFFALSE 56694
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
56636: LD_VAR 0 3
56640: PPUSH
56641: LD_VAR 0 5
56645: PPUSH
56646: CALL_OW 430
56650: PUSH
56651: LD_VAR 0 4
56655: PPUSH
56656: LD_VAR 0 5
56660: PPUSH
56661: CALL 71236 0 2
56665: AND
56666: IFFALSE 56692
// begin researching := true ;
56668: LD_ADDR_VAR 0 10
56672: PUSH
56673: LD_INT 1
56675: ST_TO_ADDR
// ComResearch ( j , t ) ;
56676: LD_VAR 0 3
56680: PPUSH
56681: LD_VAR 0 5
56685: PPUSH
56686: CALL_OW 124
// break ;
56690: GO 56694
// end ;
56692: GO 56633
56694: POP
56695: POP
// if not researching then
56696: LD_VAR 0 10
56700: NOT
56701: IFFALSE 56713
// idle_lab := j ;
56703: LD_ADDR_VAR 0 11
56707: PUSH
56708: LD_VAR 0 3
56712: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
56713: LD_VAR 0 3
56717: PPUSH
56718: CALL_OW 461
56722: PUSH
56723: LD_INT 10
56725: EQUAL
56726: IFFALSE 57314
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
56728: LD_EXP 131
56732: PUSH
56733: LD_VAR 0 2
56737: ARRAY
56738: NOT
56739: PUSH
56740: LD_EXP 132
56744: PUSH
56745: LD_VAR 0 2
56749: ARRAY
56750: NOT
56751: AND
56752: PUSH
56753: LD_EXP 129
56757: PUSH
56758: LD_VAR 0 4
56762: ARRAY
56763: PUSH
56764: LD_INT 1
56766: GREATER
56767: AND
56768: IFFALSE 56899
// begin ComCancel ( j ) ;
56770: LD_VAR 0 3
56774: PPUSH
56775: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
56779: LD_ADDR_EXP 129
56783: PUSH
56784: LD_EXP 129
56788: PPUSH
56789: LD_VAR 0 4
56793: PPUSH
56794: LD_EXP 129
56798: PUSH
56799: LD_VAR 0 4
56803: ARRAY
56804: PPUSH
56805: LD_EXP 129
56809: PUSH
56810: LD_VAR 0 4
56814: ARRAY
56815: PUSH
56816: LD_INT 1
56818: MINUS
56819: PPUSH
56820: LD_EXP 129
56824: PUSH
56825: LD_VAR 0 4
56829: ARRAY
56830: PPUSH
56831: LD_INT 0
56833: PPUSH
56834: CALL 74760 0 4
56838: PPUSH
56839: CALL_OW 1
56843: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
56844: LD_ADDR_EXP 129
56848: PUSH
56849: LD_EXP 129
56853: PPUSH
56854: LD_VAR 0 4
56858: PPUSH
56859: LD_EXP 129
56863: PUSH
56864: LD_VAR 0 4
56868: ARRAY
56869: PPUSH
56870: LD_EXP 129
56874: PUSH
56875: LD_VAR 0 4
56879: ARRAY
56880: PPUSH
56881: LD_INT 1
56883: PPUSH
56884: LD_INT 0
56886: PPUSH
56887: CALL 74760 0 4
56891: PPUSH
56892: CALL_OW 1
56896: ST_TO_ADDR
// continue ;
56897: GO 56471
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
56899: LD_EXP 131
56903: PUSH
56904: LD_VAR 0 2
56908: ARRAY
56909: PUSH
56910: LD_EXP 132
56914: PUSH
56915: LD_VAR 0 2
56919: ARRAY
56920: NOT
56921: AND
56922: IFFALSE 57049
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
56924: LD_ADDR_EXP 132
56928: PUSH
56929: LD_EXP 132
56933: PPUSH
56934: LD_VAR 0 2
56938: PUSH
56939: LD_EXP 132
56943: PUSH
56944: LD_VAR 0 2
56948: ARRAY
56949: PUSH
56950: LD_INT 1
56952: PLUS
56953: PUSH
56954: EMPTY
56955: LIST
56956: LIST
56957: PPUSH
56958: LD_EXP 131
56962: PUSH
56963: LD_VAR 0 2
56967: ARRAY
56968: PUSH
56969: LD_INT 1
56971: ARRAY
56972: PPUSH
56973: CALL 75342 0 3
56977: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
56978: LD_EXP 131
56982: PUSH
56983: LD_VAR 0 2
56987: ARRAY
56988: PUSH
56989: LD_INT 1
56991: ARRAY
56992: PPUSH
56993: LD_INT 112
56995: PPUSH
56996: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
57000: LD_ADDR_VAR 0 9
57004: PUSH
57005: LD_EXP 131
57009: PUSH
57010: LD_VAR 0 2
57014: ARRAY
57015: PPUSH
57016: LD_INT 1
57018: PPUSH
57019: CALL_OW 3
57023: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
57024: LD_ADDR_EXP 131
57028: PUSH
57029: LD_EXP 131
57033: PPUSH
57034: LD_VAR 0 2
57038: PPUSH
57039: LD_VAR 0 9
57043: PPUSH
57044: CALL_OW 1
57048: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
57049: LD_EXP 131
57053: PUSH
57054: LD_VAR 0 2
57058: ARRAY
57059: PUSH
57060: LD_EXP 132
57064: PUSH
57065: LD_VAR 0 2
57069: ARRAY
57070: AND
57071: PUSH
57072: LD_EXP 132
57076: PUSH
57077: LD_VAR 0 2
57081: ARRAY
57082: PUSH
57083: LD_INT 1
57085: ARRAY
57086: PPUSH
57087: CALL_OW 310
57091: NOT
57092: AND
57093: PUSH
57094: LD_VAR 0 3
57098: PPUSH
57099: CALL_OW 313
57103: PUSH
57104: LD_INT 6
57106: EQUAL
57107: AND
57108: IFFALSE 57164
// begin tmp2 := UnitsInside ( j ) ;
57110: LD_ADDR_VAR 0 9
57114: PUSH
57115: LD_VAR 0 3
57119: PPUSH
57120: CALL_OW 313
57124: ST_TO_ADDR
// if tmp2 = 6 then
57125: LD_VAR 0 9
57129: PUSH
57130: LD_INT 6
57132: EQUAL
57133: IFFALSE 57164
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
57135: LD_VAR 0 9
57139: PUSH
57140: LD_INT 1
57142: ARRAY
57143: PPUSH
57144: LD_INT 112
57146: PPUSH
57147: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
57151: LD_VAR 0 9
57155: PUSH
57156: LD_INT 1
57158: ARRAY
57159: PPUSH
57160: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
57164: LD_EXP 132
57168: PUSH
57169: LD_VAR 0 2
57173: ARRAY
57174: PUSH
57175: LD_EXP 132
57179: PUSH
57180: LD_VAR 0 2
57184: ARRAY
57185: PUSH
57186: LD_INT 1
57188: ARRAY
57189: PPUSH
57190: CALL_OW 314
57194: NOT
57195: AND
57196: PUSH
57197: LD_EXP 132
57201: PUSH
57202: LD_VAR 0 2
57206: ARRAY
57207: PUSH
57208: LD_INT 1
57210: ARRAY
57211: PPUSH
57212: CALL_OW 310
57216: NOT
57217: AND
57218: IFFALSE 57244
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
57220: LD_EXP 132
57224: PUSH
57225: LD_VAR 0 2
57229: ARRAY
57230: PUSH
57231: LD_INT 1
57233: ARRAY
57234: PPUSH
57235: LD_VAR 0 3
57239: PPUSH
57240: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
57244: LD_EXP 132
57248: PUSH
57249: LD_VAR 0 2
57253: ARRAY
57254: PUSH
57255: LD_INT 1
57257: ARRAY
57258: PPUSH
57259: CALL_OW 310
57263: PUSH
57264: LD_EXP 132
57268: PUSH
57269: LD_VAR 0 2
57273: ARRAY
57274: PUSH
57275: LD_INT 1
57277: ARRAY
57278: PPUSH
57279: CALL_OW 310
57283: PPUSH
57284: CALL_OW 461
57288: PUSH
57289: LD_INT 3
57291: NONEQUAL
57292: AND
57293: IFFALSE 57314
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
57295: LD_EXP 132
57299: PUSH
57300: LD_VAR 0 2
57304: ARRAY
57305: PUSH
57306: LD_INT 1
57308: ARRAY
57309: PPUSH
57310: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
57314: LD_VAR 0 3
57318: PPUSH
57319: CALL_OW 461
57323: PUSH
57324: LD_INT 6
57326: EQUAL
57327: PUSH
57328: LD_VAR 0 6
57332: PUSH
57333: LD_INT 1
57335: GREATER
57336: AND
57337: IFFALSE 57489
// begin sci := [ ] ;
57339: LD_ADDR_VAR 0 8
57343: PUSH
57344: EMPTY
57345: ST_TO_ADDR
// for x in ( tmp diff j ) do
57346: LD_ADDR_VAR 0 7
57350: PUSH
57351: LD_VAR 0 6
57355: PUSH
57356: LD_VAR 0 3
57360: DIFF
57361: PUSH
57362: FOR_IN
57363: IFFALSE 57415
// begin if sci = 6 then
57365: LD_VAR 0 8
57369: PUSH
57370: LD_INT 6
57372: EQUAL
57373: IFFALSE 57377
// break ;
57375: GO 57415
// if BuildingStatus ( x ) = bs_idle then
57377: LD_VAR 0 7
57381: PPUSH
57382: CALL_OW 461
57386: PUSH
57387: LD_INT 2
57389: EQUAL
57390: IFFALSE 57413
// sci := sci ^ UnitsInside ( x ) ;
57392: LD_ADDR_VAR 0 8
57396: PUSH
57397: LD_VAR 0 8
57401: PUSH
57402: LD_VAR 0 7
57406: PPUSH
57407: CALL_OW 313
57411: ADD
57412: ST_TO_ADDR
// end ;
57413: GO 57362
57415: POP
57416: POP
// if not sci then
57417: LD_VAR 0 8
57421: NOT
57422: IFFALSE 57426
// continue ;
57424: GO 56471
// for x in sci do
57426: LD_ADDR_VAR 0 7
57430: PUSH
57431: LD_VAR 0 8
57435: PUSH
57436: FOR_IN
57437: IFFALSE 57487
// if IsInUnit ( x ) and not HasTask ( x ) then
57439: LD_VAR 0 7
57443: PPUSH
57444: CALL_OW 310
57448: PUSH
57449: LD_VAR 0 7
57453: PPUSH
57454: CALL_OW 314
57458: NOT
57459: AND
57460: IFFALSE 57485
// begin ComExitBuilding ( x ) ;
57462: LD_VAR 0 7
57466: PPUSH
57467: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
57471: LD_VAR 0 7
57475: PPUSH
57476: LD_VAR 0 3
57480: PPUSH
57481: CALL_OW 180
// end ;
57485: GO 57436
57487: POP
57488: POP
// end ; end ;
57489: GO 56471
57491: POP
57492: POP
// end ;
57493: GO 56425
57495: POP
57496: POP
// end ;
57497: LD_VAR 0 1
57501: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
57502: LD_INT 0
57504: PPUSH
57505: PPUSH
// if not mc_bases then
57506: LD_EXP 102
57510: NOT
57511: IFFALSE 57515
// exit ;
57513: GO 57596
// for i = 1 to mc_bases do
57515: LD_ADDR_VAR 0 2
57519: PUSH
57520: DOUBLE
57521: LD_INT 1
57523: DEC
57524: ST_TO_ADDR
57525: LD_EXP 102
57529: PUSH
57530: FOR_TO
57531: IFFALSE 57594
// if mc_mines [ i ] and mc_miners [ i ] then
57533: LD_EXP 115
57537: PUSH
57538: LD_VAR 0 2
57542: ARRAY
57543: PUSH
57544: LD_EXP 116
57548: PUSH
57549: LD_VAR 0 2
57553: ARRAY
57554: AND
57555: IFFALSE 57592
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
57557: LD_EXP 116
57561: PUSH
57562: LD_VAR 0 2
57566: ARRAY
57567: PUSH
57568: LD_INT 1
57570: ARRAY
57571: PPUSH
57572: CALL_OW 255
57576: PPUSH
57577: LD_EXP 115
57581: PUSH
57582: LD_VAR 0 2
57586: ARRAY
57587: PPUSH
57588: CALL 72319 0 2
57592: GO 57530
57594: POP
57595: POP
// end ;
57596: LD_VAR 0 1
57600: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
57601: LD_INT 0
57603: PPUSH
57604: PPUSH
57605: PPUSH
57606: PPUSH
57607: PPUSH
57608: PPUSH
57609: PPUSH
57610: PPUSH
// if not mc_bases or not mc_parking then
57611: LD_EXP 102
57615: NOT
57616: PUSH
57617: LD_EXP 126
57621: NOT
57622: OR
57623: IFFALSE 57627
// exit ;
57625: GO 58365
// for i = 1 to mc_bases do
57627: LD_ADDR_VAR 0 2
57631: PUSH
57632: DOUBLE
57633: LD_INT 1
57635: DEC
57636: ST_TO_ADDR
57637: LD_EXP 102
57641: PUSH
57642: FOR_TO
57643: IFFALSE 58363
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
57645: LD_EXP 102
57649: PUSH
57650: LD_VAR 0 2
57654: ARRAY
57655: NOT
57656: PUSH
57657: LD_EXP 126
57661: PUSH
57662: LD_VAR 0 2
57666: ARRAY
57667: NOT
57668: OR
57669: IFFALSE 57673
// continue ;
57671: GO 57642
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
57673: LD_ADDR_VAR 0 5
57677: PUSH
57678: LD_EXP 102
57682: PUSH
57683: LD_VAR 0 2
57687: ARRAY
57688: PUSH
57689: LD_INT 1
57691: ARRAY
57692: PPUSH
57693: CALL_OW 255
57697: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
57698: LD_ADDR_VAR 0 6
57702: PUSH
57703: LD_EXP 102
57707: PUSH
57708: LD_VAR 0 2
57712: ARRAY
57713: PPUSH
57714: LD_INT 30
57716: PUSH
57717: LD_INT 3
57719: PUSH
57720: EMPTY
57721: LIST
57722: LIST
57723: PPUSH
57724: CALL_OW 72
57728: ST_TO_ADDR
// if not fac then
57729: LD_VAR 0 6
57733: NOT
57734: IFFALSE 57785
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57736: LD_ADDR_VAR 0 6
57740: PUSH
57741: LD_EXP 102
57745: PUSH
57746: LD_VAR 0 2
57750: ARRAY
57751: PPUSH
57752: LD_INT 2
57754: PUSH
57755: LD_INT 30
57757: PUSH
57758: LD_INT 0
57760: PUSH
57761: EMPTY
57762: LIST
57763: LIST
57764: PUSH
57765: LD_INT 30
57767: PUSH
57768: LD_INT 1
57770: PUSH
57771: EMPTY
57772: LIST
57773: LIST
57774: PUSH
57775: EMPTY
57776: LIST
57777: LIST
57778: LIST
57779: PPUSH
57780: CALL_OW 72
57784: ST_TO_ADDR
// if not fac then
57785: LD_VAR 0 6
57789: NOT
57790: IFFALSE 57794
// continue ;
57792: GO 57642
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
57794: LD_ADDR_VAR 0 7
57798: PUSH
57799: LD_EXP 126
57803: PUSH
57804: LD_VAR 0 2
57808: ARRAY
57809: PPUSH
57810: LD_INT 22
57812: PUSH
57813: LD_VAR 0 5
57817: PUSH
57818: EMPTY
57819: LIST
57820: LIST
57821: PUSH
57822: LD_INT 21
57824: PUSH
57825: LD_INT 2
57827: PUSH
57828: EMPTY
57829: LIST
57830: LIST
57831: PUSH
57832: LD_INT 3
57834: PUSH
57835: LD_INT 60
57837: PUSH
57838: EMPTY
57839: LIST
57840: PUSH
57841: EMPTY
57842: LIST
57843: LIST
57844: PUSH
57845: LD_INT 3
57847: PUSH
57848: LD_INT 24
57850: PUSH
57851: LD_INT 1000
57853: PUSH
57854: EMPTY
57855: LIST
57856: LIST
57857: PUSH
57858: EMPTY
57859: LIST
57860: LIST
57861: PUSH
57862: EMPTY
57863: LIST
57864: LIST
57865: LIST
57866: LIST
57867: PPUSH
57868: CALL_OW 70
57872: ST_TO_ADDR
// for j in fac do
57873: LD_ADDR_VAR 0 3
57877: PUSH
57878: LD_VAR 0 6
57882: PUSH
57883: FOR_IN
57884: IFFALSE 57979
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
57886: LD_ADDR_VAR 0 7
57890: PUSH
57891: LD_VAR 0 7
57895: PUSH
57896: LD_INT 22
57898: PUSH
57899: LD_VAR 0 5
57903: PUSH
57904: EMPTY
57905: LIST
57906: LIST
57907: PUSH
57908: LD_INT 91
57910: PUSH
57911: LD_VAR 0 3
57915: PUSH
57916: LD_INT 15
57918: PUSH
57919: EMPTY
57920: LIST
57921: LIST
57922: LIST
57923: PUSH
57924: LD_INT 21
57926: PUSH
57927: LD_INT 2
57929: PUSH
57930: EMPTY
57931: LIST
57932: LIST
57933: PUSH
57934: LD_INT 3
57936: PUSH
57937: LD_INT 60
57939: PUSH
57940: EMPTY
57941: LIST
57942: PUSH
57943: EMPTY
57944: LIST
57945: LIST
57946: PUSH
57947: LD_INT 3
57949: PUSH
57950: LD_INT 24
57952: PUSH
57953: LD_INT 1000
57955: PUSH
57956: EMPTY
57957: LIST
57958: LIST
57959: PUSH
57960: EMPTY
57961: LIST
57962: LIST
57963: PUSH
57964: EMPTY
57965: LIST
57966: LIST
57967: LIST
57968: LIST
57969: LIST
57970: PPUSH
57971: CALL_OW 69
57975: UNION
57976: ST_TO_ADDR
57977: GO 57883
57979: POP
57980: POP
// if not vehs then
57981: LD_VAR 0 7
57985: NOT
57986: IFFALSE 58012
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57988: LD_ADDR_EXP 114
57992: PUSH
57993: LD_EXP 114
57997: PPUSH
57998: LD_VAR 0 2
58002: PPUSH
58003: EMPTY
58004: PPUSH
58005: CALL_OW 1
58009: ST_TO_ADDR
// continue ;
58010: GO 57642
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
58012: LD_ADDR_VAR 0 8
58016: PUSH
58017: LD_EXP 102
58021: PUSH
58022: LD_VAR 0 2
58026: ARRAY
58027: PPUSH
58028: LD_INT 30
58030: PUSH
58031: LD_INT 3
58033: PUSH
58034: EMPTY
58035: LIST
58036: LIST
58037: PPUSH
58038: CALL_OW 72
58042: ST_TO_ADDR
// if tmp then
58043: LD_VAR 0 8
58047: IFFALSE 58150
// begin for j in tmp do
58049: LD_ADDR_VAR 0 3
58053: PUSH
58054: LD_VAR 0 8
58058: PUSH
58059: FOR_IN
58060: IFFALSE 58148
// for k in UnitsInside ( j ) do
58062: LD_ADDR_VAR 0 4
58066: PUSH
58067: LD_VAR 0 3
58071: PPUSH
58072: CALL_OW 313
58076: PUSH
58077: FOR_IN
58078: IFFALSE 58144
// if k then
58080: LD_VAR 0 4
58084: IFFALSE 58142
// if not k in mc_repair_vehicle [ i ] then
58086: LD_VAR 0 4
58090: PUSH
58091: LD_EXP 114
58095: PUSH
58096: LD_VAR 0 2
58100: ARRAY
58101: IN
58102: NOT
58103: IFFALSE 58142
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
58105: LD_ADDR_EXP 114
58109: PUSH
58110: LD_EXP 114
58114: PPUSH
58115: LD_VAR 0 2
58119: PPUSH
58120: LD_EXP 114
58124: PUSH
58125: LD_VAR 0 2
58129: ARRAY
58130: PUSH
58131: LD_VAR 0 4
58135: UNION
58136: PPUSH
58137: CALL_OW 1
58141: ST_TO_ADDR
58142: GO 58077
58144: POP
58145: POP
58146: GO 58059
58148: POP
58149: POP
// end ; if not mc_repair_vehicle [ i ] then
58150: LD_EXP 114
58154: PUSH
58155: LD_VAR 0 2
58159: ARRAY
58160: NOT
58161: IFFALSE 58165
// continue ;
58163: GO 57642
// for j in mc_repair_vehicle [ i ] do
58165: LD_ADDR_VAR 0 3
58169: PUSH
58170: LD_EXP 114
58174: PUSH
58175: LD_VAR 0 2
58179: ARRAY
58180: PUSH
58181: FOR_IN
58182: IFFALSE 58359
// begin if GetClass ( j ) <> 3 then
58184: LD_VAR 0 3
58188: PPUSH
58189: CALL_OW 257
58193: PUSH
58194: LD_INT 3
58196: NONEQUAL
58197: IFFALSE 58238
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
58199: LD_ADDR_EXP 114
58203: PUSH
58204: LD_EXP 114
58208: PPUSH
58209: LD_VAR 0 2
58213: PPUSH
58214: LD_EXP 114
58218: PUSH
58219: LD_VAR 0 2
58223: ARRAY
58224: PUSH
58225: LD_VAR 0 3
58229: DIFF
58230: PPUSH
58231: CALL_OW 1
58235: ST_TO_ADDR
// continue ;
58236: GO 58181
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
58238: LD_VAR 0 3
58242: PPUSH
58243: CALL_OW 311
58247: NOT
58248: PUSH
58249: LD_VAR 0 3
58253: PUSH
58254: LD_EXP 105
58258: PUSH
58259: LD_VAR 0 2
58263: ARRAY
58264: PUSH
58265: LD_INT 1
58267: ARRAY
58268: IN
58269: NOT
58270: AND
58271: PUSH
58272: LD_VAR 0 3
58276: PUSH
58277: LD_EXP 105
58281: PUSH
58282: LD_VAR 0 2
58286: ARRAY
58287: PUSH
58288: LD_INT 2
58290: ARRAY
58291: IN
58292: NOT
58293: AND
58294: IFFALSE 58357
// begin if IsInUnit ( j ) then
58296: LD_VAR 0 3
58300: PPUSH
58301: CALL_OW 310
58305: IFFALSE 58318
// ComExitBuilding ( j ) else
58307: LD_VAR 0 3
58311: PPUSH
58312: CALL_OW 122
58316: GO 58357
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
58318: LD_VAR 0 3
58322: PPUSH
58323: LD_VAR 0 7
58327: PUSH
58328: LD_INT 1
58330: ARRAY
58331: PPUSH
58332: CALL 110156 0 2
58336: NOT
58337: IFFALSE 58357
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
58339: LD_VAR 0 3
58343: PPUSH
58344: LD_VAR 0 7
58348: PUSH
58349: LD_INT 1
58351: ARRAY
58352: PPUSH
58353: CALL_OW 129
// end ; end ;
58357: GO 58181
58359: POP
58360: POP
// end ;
58361: GO 57642
58363: POP
58364: POP
// end ;
58365: LD_VAR 0 1
58369: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
58370: LD_INT 0
58372: PPUSH
58373: PPUSH
58374: PPUSH
58375: PPUSH
58376: PPUSH
58377: PPUSH
58378: PPUSH
58379: PPUSH
58380: PPUSH
58381: PPUSH
58382: PPUSH
// if not mc_bases then
58383: LD_EXP 102
58387: NOT
58388: IFFALSE 58392
// exit ;
58390: GO 59194
// for i = 1 to mc_bases do
58392: LD_ADDR_VAR 0 2
58396: PUSH
58397: DOUBLE
58398: LD_INT 1
58400: DEC
58401: ST_TO_ADDR
58402: LD_EXP 102
58406: PUSH
58407: FOR_TO
58408: IFFALSE 59192
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
58410: LD_EXP 130
58414: PUSH
58415: LD_VAR 0 2
58419: ARRAY
58420: NOT
58421: PUSH
58422: LD_EXP 105
58426: PUSH
58427: LD_VAR 0 2
58431: ARRAY
58432: PUSH
58433: LD_INT 1
58435: ARRAY
58436: OR
58437: PUSH
58438: LD_EXP 105
58442: PUSH
58443: LD_VAR 0 2
58447: ARRAY
58448: PUSH
58449: LD_INT 2
58451: ARRAY
58452: OR
58453: PUSH
58454: LD_EXP 128
58458: PUSH
58459: LD_VAR 0 2
58463: ARRAY
58464: PPUSH
58465: LD_INT 1
58467: PPUSH
58468: CALL_OW 325
58472: NOT
58473: OR
58474: PUSH
58475: LD_EXP 125
58479: PUSH
58480: LD_VAR 0 2
58484: ARRAY
58485: OR
58486: IFFALSE 58490
// continue ;
58488: GO 58407
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
58490: LD_ADDR_VAR 0 8
58494: PUSH
58495: LD_EXP 102
58499: PUSH
58500: LD_VAR 0 2
58504: ARRAY
58505: PPUSH
58506: LD_INT 25
58508: PUSH
58509: LD_INT 4
58511: PUSH
58512: EMPTY
58513: LIST
58514: LIST
58515: PUSH
58516: LD_INT 50
58518: PUSH
58519: EMPTY
58520: LIST
58521: PUSH
58522: LD_INT 3
58524: PUSH
58525: LD_INT 60
58527: PUSH
58528: EMPTY
58529: LIST
58530: PUSH
58531: EMPTY
58532: LIST
58533: LIST
58534: PUSH
58535: EMPTY
58536: LIST
58537: LIST
58538: LIST
58539: PPUSH
58540: CALL_OW 72
58544: PUSH
58545: LD_EXP 106
58549: PUSH
58550: LD_VAR 0 2
58554: ARRAY
58555: DIFF
58556: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58557: LD_ADDR_VAR 0 9
58561: PUSH
58562: LD_EXP 102
58566: PUSH
58567: LD_VAR 0 2
58571: ARRAY
58572: PPUSH
58573: LD_INT 2
58575: PUSH
58576: LD_INT 30
58578: PUSH
58579: LD_INT 0
58581: PUSH
58582: EMPTY
58583: LIST
58584: LIST
58585: PUSH
58586: LD_INT 30
58588: PUSH
58589: LD_INT 1
58591: PUSH
58592: EMPTY
58593: LIST
58594: LIST
58595: PUSH
58596: EMPTY
58597: LIST
58598: LIST
58599: LIST
58600: PPUSH
58601: CALL_OW 72
58605: ST_TO_ADDR
// if not tmp or not dep then
58606: LD_VAR 0 8
58610: NOT
58611: PUSH
58612: LD_VAR 0 9
58616: NOT
58617: OR
58618: IFFALSE 58622
// continue ;
58620: GO 58407
// side := GetSide ( tmp [ 1 ] ) ;
58622: LD_ADDR_VAR 0 11
58626: PUSH
58627: LD_VAR 0 8
58631: PUSH
58632: LD_INT 1
58634: ARRAY
58635: PPUSH
58636: CALL_OW 255
58640: ST_TO_ADDR
// dep := dep [ 1 ] ;
58641: LD_ADDR_VAR 0 9
58645: PUSH
58646: LD_VAR 0 9
58650: PUSH
58651: LD_INT 1
58653: ARRAY
58654: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
58655: LD_ADDR_VAR 0 7
58659: PUSH
58660: LD_EXP 130
58664: PUSH
58665: LD_VAR 0 2
58669: ARRAY
58670: PPUSH
58671: LD_INT 22
58673: PUSH
58674: LD_INT 0
58676: PUSH
58677: EMPTY
58678: LIST
58679: LIST
58680: PUSH
58681: LD_INT 25
58683: PUSH
58684: LD_INT 12
58686: PUSH
58687: EMPTY
58688: LIST
58689: LIST
58690: PUSH
58691: EMPTY
58692: LIST
58693: LIST
58694: PPUSH
58695: CALL_OW 70
58699: PUSH
58700: LD_INT 22
58702: PUSH
58703: LD_INT 0
58705: PUSH
58706: EMPTY
58707: LIST
58708: LIST
58709: PUSH
58710: LD_INT 25
58712: PUSH
58713: LD_INT 12
58715: PUSH
58716: EMPTY
58717: LIST
58718: LIST
58719: PUSH
58720: LD_INT 91
58722: PUSH
58723: LD_VAR 0 9
58727: PUSH
58728: LD_INT 20
58730: PUSH
58731: EMPTY
58732: LIST
58733: LIST
58734: LIST
58735: PUSH
58736: EMPTY
58737: LIST
58738: LIST
58739: LIST
58740: PPUSH
58741: CALL_OW 69
58745: UNION
58746: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
58747: LD_ADDR_VAR 0 10
58751: PUSH
58752: LD_EXP 130
58756: PUSH
58757: LD_VAR 0 2
58761: ARRAY
58762: PPUSH
58763: LD_INT 81
58765: PUSH
58766: LD_VAR 0 11
58770: PUSH
58771: EMPTY
58772: LIST
58773: LIST
58774: PPUSH
58775: CALL_OW 70
58779: ST_TO_ADDR
// if not apes or danger_at_area then
58780: LD_VAR 0 7
58784: NOT
58785: PUSH
58786: LD_VAR 0 10
58790: OR
58791: IFFALSE 58841
// begin if mc_taming [ i ] then
58793: LD_EXP 133
58797: PUSH
58798: LD_VAR 0 2
58802: ARRAY
58803: IFFALSE 58839
// begin MC_Reset ( i , 121 ) ;
58805: LD_VAR 0 2
58809: PPUSH
58810: LD_INT 121
58812: PPUSH
58813: CALL 43757 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
58817: LD_ADDR_EXP 133
58821: PUSH
58822: LD_EXP 133
58826: PPUSH
58827: LD_VAR 0 2
58831: PPUSH
58832: EMPTY
58833: PPUSH
58834: CALL_OW 1
58838: ST_TO_ADDR
// end ; continue ;
58839: GO 58407
// end ; for j in tmp do
58841: LD_ADDR_VAR 0 3
58845: PUSH
58846: LD_VAR 0 8
58850: PUSH
58851: FOR_IN
58852: IFFALSE 59188
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
58854: LD_VAR 0 3
58858: PUSH
58859: LD_EXP 133
58863: PUSH
58864: LD_VAR 0 2
58868: ARRAY
58869: IN
58870: NOT
58871: PUSH
58872: LD_EXP 133
58876: PUSH
58877: LD_VAR 0 2
58881: ARRAY
58882: PUSH
58883: LD_INT 3
58885: LESS
58886: AND
58887: IFFALSE 58945
// begin SetTag ( j , 121 ) ;
58889: LD_VAR 0 3
58893: PPUSH
58894: LD_INT 121
58896: PPUSH
58897: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
58901: LD_ADDR_EXP 133
58905: PUSH
58906: LD_EXP 133
58910: PPUSH
58911: LD_VAR 0 2
58915: PUSH
58916: LD_EXP 133
58920: PUSH
58921: LD_VAR 0 2
58925: ARRAY
58926: PUSH
58927: LD_INT 1
58929: PLUS
58930: PUSH
58931: EMPTY
58932: LIST
58933: LIST
58934: PPUSH
58935: LD_VAR 0 3
58939: PPUSH
58940: CALL 75342 0 3
58944: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
58945: LD_VAR 0 3
58949: PUSH
58950: LD_EXP 133
58954: PUSH
58955: LD_VAR 0 2
58959: ARRAY
58960: IN
58961: IFFALSE 59186
// begin if GetClass ( j ) <> 4 then
58963: LD_VAR 0 3
58967: PPUSH
58968: CALL_OW 257
58972: PUSH
58973: LD_INT 4
58975: NONEQUAL
58976: IFFALSE 59029
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
58978: LD_ADDR_EXP 133
58982: PUSH
58983: LD_EXP 133
58987: PPUSH
58988: LD_VAR 0 2
58992: PPUSH
58993: LD_EXP 133
58997: PUSH
58998: LD_VAR 0 2
59002: ARRAY
59003: PUSH
59004: LD_VAR 0 3
59008: DIFF
59009: PPUSH
59010: CALL_OW 1
59014: ST_TO_ADDR
// SetTag ( j , 0 ) ;
59015: LD_VAR 0 3
59019: PPUSH
59020: LD_INT 0
59022: PPUSH
59023: CALL_OW 109
// continue ;
59027: GO 58851
// end ; if IsInUnit ( j ) then
59029: LD_VAR 0 3
59033: PPUSH
59034: CALL_OW 310
59038: IFFALSE 59049
// ComExitBuilding ( j ) ;
59040: LD_VAR 0 3
59044: PPUSH
59045: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
59049: LD_ADDR_VAR 0 6
59053: PUSH
59054: LD_VAR 0 7
59058: PPUSH
59059: LD_VAR 0 3
59063: PPUSH
59064: CALL_OW 74
59068: ST_TO_ADDR
// if not ape then
59069: LD_VAR 0 6
59073: NOT
59074: IFFALSE 59078
// break ;
59076: GO 59188
// x := GetX ( ape ) ;
59078: LD_ADDR_VAR 0 4
59082: PUSH
59083: LD_VAR 0 6
59087: PPUSH
59088: CALL_OW 250
59092: ST_TO_ADDR
// y := GetY ( ape ) ;
59093: LD_ADDR_VAR 0 5
59097: PUSH
59098: LD_VAR 0 6
59102: PPUSH
59103: CALL_OW 251
59107: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
59108: LD_VAR 0 4
59112: PPUSH
59113: LD_VAR 0 5
59117: PPUSH
59118: CALL_OW 488
59122: NOT
59123: PUSH
59124: LD_VAR 0 11
59128: PPUSH
59129: LD_VAR 0 4
59133: PPUSH
59134: LD_VAR 0 5
59138: PPUSH
59139: LD_INT 20
59141: PPUSH
59142: CALL 76606 0 4
59146: PUSH
59147: LD_INT 4
59149: ARRAY
59150: OR
59151: IFFALSE 59155
// break ;
59153: GO 59188
// if not HasTask ( j ) then
59155: LD_VAR 0 3
59159: PPUSH
59160: CALL_OW 314
59164: NOT
59165: IFFALSE 59186
// ComTameXY ( j , x , y ) ;
59167: LD_VAR 0 3
59171: PPUSH
59172: LD_VAR 0 4
59176: PPUSH
59177: LD_VAR 0 5
59181: PPUSH
59182: CALL_OW 131
// end ; end ;
59186: GO 58851
59188: POP
59189: POP
// end ;
59190: GO 58407
59192: POP
59193: POP
// end ;
59194: LD_VAR 0 1
59198: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
59199: LD_INT 0
59201: PPUSH
59202: PPUSH
59203: PPUSH
59204: PPUSH
59205: PPUSH
59206: PPUSH
59207: PPUSH
59208: PPUSH
// if not mc_bases then
59209: LD_EXP 102
59213: NOT
59214: IFFALSE 59218
// exit ;
59216: GO 59844
// for i = 1 to mc_bases do
59218: LD_ADDR_VAR 0 2
59222: PUSH
59223: DOUBLE
59224: LD_INT 1
59226: DEC
59227: ST_TO_ADDR
59228: LD_EXP 102
59232: PUSH
59233: FOR_TO
59234: IFFALSE 59842
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
59236: LD_EXP 131
59240: PUSH
59241: LD_VAR 0 2
59245: ARRAY
59246: NOT
59247: PUSH
59248: LD_EXP 131
59252: PUSH
59253: LD_VAR 0 2
59257: ARRAY
59258: PPUSH
59259: LD_INT 25
59261: PUSH
59262: LD_INT 12
59264: PUSH
59265: EMPTY
59266: LIST
59267: LIST
59268: PPUSH
59269: CALL_OW 72
59273: NOT
59274: OR
59275: IFFALSE 59279
// continue ;
59277: GO 59233
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
59279: LD_ADDR_VAR 0 5
59283: PUSH
59284: LD_EXP 131
59288: PUSH
59289: LD_VAR 0 2
59293: ARRAY
59294: PUSH
59295: LD_INT 1
59297: ARRAY
59298: PPUSH
59299: CALL_OW 255
59303: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
59304: LD_VAR 0 5
59308: PPUSH
59309: LD_INT 2
59311: PPUSH
59312: CALL_OW 325
59316: IFFALSE 59569
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
59318: LD_ADDR_VAR 0 4
59322: PUSH
59323: LD_EXP 131
59327: PUSH
59328: LD_VAR 0 2
59332: ARRAY
59333: PPUSH
59334: LD_INT 25
59336: PUSH
59337: LD_INT 16
59339: PUSH
59340: EMPTY
59341: LIST
59342: LIST
59343: PPUSH
59344: CALL_OW 72
59348: ST_TO_ADDR
// if tmp < 6 then
59349: LD_VAR 0 4
59353: PUSH
59354: LD_INT 6
59356: LESS
59357: IFFALSE 59569
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59359: LD_ADDR_VAR 0 6
59363: PUSH
59364: LD_EXP 102
59368: PUSH
59369: LD_VAR 0 2
59373: ARRAY
59374: PPUSH
59375: LD_INT 2
59377: PUSH
59378: LD_INT 30
59380: PUSH
59381: LD_INT 0
59383: PUSH
59384: EMPTY
59385: LIST
59386: LIST
59387: PUSH
59388: LD_INT 30
59390: PUSH
59391: LD_INT 1
59393: PUSH
59394: EMPTY
59395: LIST
59396: LIST
59397: PUSH
59398: EMPTY
59399: LIST
59400: LIST
59401: LIST
59402: PPUSH
59403: CALL_OW 72
59407: ST_TO_ADDR
// if depot then
59408: LD_VAR 0 6
59412: IFFALSE 59569
// begin selected := 0 ;
59414: LD_ADDR_VAR 0 7
59418: PUSH
59419: LD_INT 0
59421: ST_TO_ADDR
// for j in depot do
59422: LD_ADDR_VAR 0 3
59426: PUSH
59427: LD_VAR 0 6
59431: PUSH
59432: FOR_IN
59433: IFFALSE 59464
// begin if UnitsInside ( j ) < 6 then
59435: LD_VAR 0 3
59439: PPUSH
59440: CALL_OW 313
59444: PUSH
59445: LD_INT 6
59447: LESS
59448: IFFALSE 59462
// begin selected := j ;
59450: LD_ADDR_VAR 0 7
59454: PUSH
59455: LD_VAR 0 3
59459: ST_TO_ADDR
// break ;
59460: GO 59464
// end ; end ;
59462: GO 59432
59464: POP
59465: POP
// if selected then
59466: LD_VAR 0 7
59470: IFFALSE 59569
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
59472: LD_ADDR_VAR 0 3
59476: PUSH
59477: LD_EXP 131
59481: PUSH
59482: LD_VAR 0 2
59486: ARRAY
59487: PPUSH
59488: LD_INT 25
59490: PUSH
59491: LD_INT 12
59493: PUSH
59494: EMPTY
59495: LIST
59496: LIST
59497: PPUSH
59498: CALL_OW 72
59502: PUSH
59503: FOR_IN
59504: IFFALSE 59567
// if not HasTask ( j ) then
59506: LD_VAR 0 3
59510: PPUSH
59511: CALL_OW 314
59515: NOT
59516: IFFALSE 59565
// begin if not IsInUnit ( j ) then
59518: LD_VAR 0 3
59522: PPUSH
59523: CALL_OW 310
59527: NOT
59528: IFFALSE 59544
// ComEnterUnit ( j , selected ) ;
59530: LD_VAR 0 3
59534: PPUSH
59535: LD_VAR 0 7
59539: PPUSH
59540: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
59544: LD_VAR 0 3
59548: PPUSH
59549: LD_INT 16
59551: PPUSH
59552: CALL_OW 183
// AddComExitBuilding ( j ) ;
59556: LD_VAR 0 3
59560: PPUSH
59561: CALL_OW 182
// end ;
59565: GO 59503
59567: POP
59568: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
59569: LD_VAR 0 5
59573: PPUSH
59574: LD_INT 11
59576: PPUSH
59577: CALL_OW 325
59581: IFFALSE 59840
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
59583: LD_ADDR_VAR 0 4
59587: PUSH
59588: LD_EXP 131
59592: PUSH
59593: LD_VAR 0 2
59597: ARRAY
59598: PPUSH
59599: LD_INT 25
59601: PUSH
59602: LD_INT 16
59604: PUSH
59605: EMPTY
59606: LIST
59607: LIST
59608: PPUSH
59609: CALL_OW 72
59613: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
59614: LD_VAR 0 4
59618: PUSH
59619: LD_INT 6
59621: GREATEREQUAL
59622: PUSH
59623: LD_VAR 0 5
59627: PPUSH
59628: LD_INT 2
59630: PPUSH
59631: CALL_OW 325
59635: NOT
59636: OR
59637: IFFALSE 59840
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
59639: LD_ADDR_VAR 0 8
59643: PUSH
59644: LD_EXP 102
59648: PUSH
59649: LD_VAR 0 2
59653: ARRAY
59654: PPUSH
59655: LD_INT 2
59657: PUSH
59658: LD_INT 30
59660: PUSH
59661: LD_INT 4
59663: PUSH
59664: EMPTY
59665: LIST
59666: LIST
59667: PUSH
59668: LD_INT 30
59670: PUSH
59671: LD_INT 5
59673: PUSH
59674: EMPTY
59675: LIST
59676: LIST
59677: PUSH
59678: EMPTY
59679: LIST
59680: LIST
59681: LIST
59682: PPUSH
59683: CALL_OW 72
59687: ST_TO_ADDR
// if barracks then
59688: LD_VAR 0 8
59692: IFFALSE 59840
// begin selected := 0 ;
59694: LD_ADDR_VAR 0 7
59698: PUSH
59699: LD_INT 0
59701: ST_TO_ADDR
// for j in barracks do
59702: LD_ADDR_VAR 0 3
59706: PUSH
59707: LD_VAR 0 8
59711: PUSH
59712: FOR_IN
59713: IFFALSE 59744
// begin if UnitsInside ( j ) < 6 then
59715: LD_VAR 0 3
59719: PPUSH
59720: CALL_OW 313
59724: PUSH
59725: LD_INT 6
59727: LESS
59728: IFFALSE 59742
// begin selected := j ;
59730: LD_ADDR_VAR 0 7
59734: PUSH
59735: LD_VAR 0 3
59739: ST_TO_ADDR
// break ;
59740: GO 59744
// end ; end ;
59742: GO 59712
59744: POP
59745: POP
// if selected then
59746: LD_VAR 0 7
59750: IFFALSE 59840
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
59752: LD_ADDR_VAR 0 3
59756: PUSH
59757: LD_EXP 131
59761: PUSH
59762: LD_VAR 0 2
59766: ARRAY
59767: PPUSH
59768: LD_INT 25
59770: PUSH
59771: LD_INT 12
59773: PUSH
59774: EMPTY
59775: LIST
59776: LIST
59777: PPUSH
59778: CALL_OW 72
59782: PUSH
59783: FOR_IN
59784: IFFALSE 59838
// if not IsInUnit ( j ) and not HasTask ( j ) then
59786: LD_VAR 0 3
59790: PPUSH
59791: CALL_OW 310
59795: NOT
59796: PUSH
59797: LD_VAR 0 3
59801: PPUSH
59802: CALL_OW 314
59806: NOT
59807: AND
59808: IFFALSE 59836
// begin ComEnterUnit ( j , selected ) ;
59810: LD_VAR 0 3
59814: PPUSH
59815: LD_VAR 0 7
59819: PPUSH
59820: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
59824: LD_VAR 0 3
59828: PPUSH
59829: LD_INT 15
59831: PPUSH
59832: CALL_OW 183
// end ;
59836: GO 59783
59838: POP
59839: POP
// end ; end ; end ; end ; end ;
59840: GO 59233
59842: POP
59843: POP
// end ;
59844: LD_VAR 0 1
59848: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
59849: LD_INT 0
59851: PPUSH
59852: PPUSH
59853: PPUSH
59854: PPUSH
// if not mc_bases then
59855: LD_EXP 102
59859: NOT
59860: IFFALSE 59864
// exit ;
59862: GO 60042
// for i = 1 to mc_bases do
59864: LD_ADDR_VAR 0 2
59868: PUSH
59869: DOUBLE
59870: LD_INT 1
59872: DEC
59873: ST_TO_ADDR
59874: LD_EXP 102
59878: PUSH
59879: FOR_TO
59880: IFFALSE 60040
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
59882: LD_ADDR_VAR 0 4
59886: PUSH
59887: LD_EXP 102
59891: PUSH
59892: LD_VAR 0 2
59896: ARRAY
59897: PPUSH
59898: LD_INT 25
59900: PUSH
59901: LD_INT 9
59903: PUSH
59904: EMPTY
59905: LIST
59906: LIST
59907: PPUSH
59908: CALL_OW 72
59912: ST_TO_ADDR
// if not tmp then
59913: LD_VAR 0 4
59917: NOT
59918: IFFALSE 59922
// continue ;
59920: GO 59879
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
59922: LD_EXP 128
59926: PUSH
59927: LD_VAR 0 2
59931: ARRAY
59932: PPUSH
59933: LD_INT 29
59935: PPUSH
59936: CALL_OW 325
59940: NOT
59941: PUSH
59942: LD_EXP 128
59946: PUSH
59947: LD_VAR 0 2
59951: ARRAY
59952: PPUSH
59953: LD_INT 28
59955: PPUSH
59956: CALL_OW 325
59960: NOT
59961: AND
59962: IFFALSE 59966
// continue ;
59964: GO 59879
// for j in tmp do
59966: LD_ADDR_VAR 0 3
59970: PUSH
59971: LD_VAR 0 4
59975: PUSH
59976: FOR_IN
59977: IFFALSE 60036
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
59979: LD_VAR 0 3
59983: PUSH
59984: LD_EXP 105
59988: PUSH
59989: LD_VAR 0 2
59993: ARRAY
59994: PUSH
59995: LD_INT 1
59997: ARRAY
59998: IN
59999: NOT
60000: PUSH
60001: LD_VAR 0 3
60005: PUSH
60006: LD_EXP 105
60010: PUSH
60011: LD_VAR 0 2
60015: ARRAY
60016: PUSH
60017: LD_INT 2
60019: ARRAY
60020: IN
60021: NOT
60022: AND
60023: IFFALSE 60034
// ComSpaceTimeShoot ( j ) ;
60025: LD_VAR 0 3
60029: PPUSH
60030: CALL 71327 0 1
60034: GO 59976
60036: POP
60037: POP
// end ;
60038: GO 59879
60040: POP
60041: POP
// end ;
60042: LD_VAR 0 1
60046: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
60047: LD_INT 0
60049: PPUSH
60050: PPUSH
60051: PPUSH
60052: PPUSH
60053: PPUSH
60054: PPUSH
60055: PPUSH
60056: PPUSH
60057: PPUSH
// if not mc_bases then
60058: LD_EXP 102
60062: NOT
60063: IFFALSE 60067
// exit ;
60065: GO 60689
// for i = 1 to mc_bases do
60067: LD_ADDR_VAR 0 2
60071: PUSH
60072: DOUBLE
60073: LD_INT 1
60075: DEC
60076: ST_TO_ADDR
60077: LD_EXP 102
60081: PUSH
60082: FOR_TO
60083: IFFALSE 60687
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
60085: LD_EXP 137
60089: PUSH
60090: LD_VAR 0 2
60094: ARRAY
60095: NOT
60096: PUSH
60097: LD_INT 38
60099: PPUSH
60100: LD_EXP 128
60104: PUSH
60105: LD_VAR 0 2
60109: ARRAY
60110: PPUSH
60111: CALL_OW 321
60115: PUSH
60116: LD_INT 2
60118: NONEQUAL
60119: OR
60120: IFFALSE 60124
// continue ;
60122: GO 60082
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
60124: LD_ADDR_VAR 0 8
60128: PUSH
60129: LD_EXP 102
60133: PUSH
60134: LD_VAR 0 2
60138: ARRAY
60139: PPUSH
60140: LD_INT 30
60142: PUSH
60143: LD_INT 34
60145: PUSH
60146: EMPTY
60147: LIST
60148: LIST
60149: PPUSH
60150: CALL_OW 72
60154: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
60155: LD_ADDR_VAR 0 9
60159: PUSH
60160: LD_EXP 102
60164: PUSH
60165: LD_VAR 0 2
60169: ARRAY
60170: PPUSH
60171: LD_INT 25
60173: PUSH
60174: LD_INT 4
60176: PUSH
60177: EMPTY
60178: LIST
60179: LIST
60180: PPUSH
60181: CALL_OW 72
60185: PPUSH
60186: LD_INT 0
60188: PPUSH
60189: CALL 105660 0 2
60193: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
60194: LD_VAR 0 9
60198: NOT
60199: PUSH
60200: LD_VAR 0 8
60204: NOT
60205: OR
60206: PUSH
60207: LD_EXP 102
60211: PUSH
60212: LD_VAR 0 2
60216: ARRAY
60217: PPUSH
60218: LD_INT 124
60220: PPUSH
60221: CALL 105660 0 2
60225: OR
60226: IFFALSE 60230
// continue ;
60228: GO 60082
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
60230: LD_EXP 138
60234: PUSH
60235: LD_VAR 0 2
60239: ARRAY
60240: PUSH
60241: LD_EXP 137
60245: PUSH
60246: LD_VAR 0 2
60250: ARRAY
60251: LESS
60252: PUSH
60253: LD_EXP 138
60257: PUSH
60258: LD_VAR 0 2
60262: ARRAY
60263: PUSH
60264: LD_VAR 0 8
60268: LESS
60269: AND
60270: IFFALSE 60685
// begin tmp := sci [ 1 ] ;
60272: LD_ADDR_VAR 0 7
60276: PUSH
60277: LD_VAR 0 9
60281: PUSH
60282: LD_INT 1
60284: ARRAY
60285: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
60286: LD_VAR 0 7
60290: PPUSH
60291: LD_INT 124
60293: PPUSH
60294: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
60298: LD_ADDR_VAR 0 3
60302: PUSH
60303: DOUBLE
60304: LD_EXP 137
60308: PUSH
60309: LD_VAR 0 2
60313: ARRAY
60314: INC
60315: ST_TO_ADDR
60316: LD_EXP 137
60320: PUSH
60321: LD_VAR 0 2
60325: ARRAY
60326: PUSH
60327: FOR_DOWNTO
60328: IFFALSE 60671
// begin if IsInUnit ( tmp ) then
60330: LD_VAR 0 7
60334: PPUSH
60335: CALL_OW 310
60339: IFFALSE 60350
// ComExitBuilding ( tmp ) ;
60341: LD_VAR 0 7
60345: PPUSH
60346: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
60350: LD_INT 35
60352: PPUSH
60353: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
60357: LD_VAR 0 7
60361: PPUSH
60362: CALL_OW 310
60366: NOT
60367: PUSH
60368: LD_VAR 0 7
60372: PPUSH
60373: CALL_OW 314
60377: NOT
60378: AND
60379: IFFALSE 60350
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
60381: LD_ADDR_VAR 0 6
60385: PUSH
60386: LD_VAR 0 7
60390: PPUSH
60391: CALL_OW 250
60395: PUSH
60396: LD_VAR 0 7
60400: PPUSH
60401: CALL_OW 251
60405: PUSH
60406: EMPTY
60407: LIST
60408: LIST
60409: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
60410: LD_INT 35
60412: PPUSH
60413: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
60417: LD_ADDR_VAR 0 4
60421: PUSH
60422: LD_EXP 137
60426: PUSH
60427: LD_VAR 0 2
60431: ARRAY
60432: PUSH
60433: LD_VAR 0 3
60437: ARRAY
60438: PUSH
60439: LD_INT 1
60441: ARRAY
60442: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
60443: LD_ADDR_VAR 0 5
60447: PUSH
60448: LD_EXP 137
60452: PUSH
60453: LD_VAR 0 2
60457: ARRAY
60458: PUSH
60459: LD_VAR 0 3
60463: ARRAY
60464: PUSH
60465: LD_INT 2
60467: ARRAY
60468: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
60469: LD_VAR 0 7
60473: PPUSH
60474: LD_INT 10
60476: PPUSH
60477: CALL 78307 0 2
60481: PUSH
60482: LD_INT 4
60484: ARRAY
60485: IFFALSE 60523
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
60487: LD_VAR 0 7
60491: PPUSH
60492: LD_VAR 0 6
60496: PUSH
60497: LD_INT 1
60499: ARRAY
60500: PPUSH
60501: LD_VAR 0 6
60505: PUSH
60506: LD_INT 2
60508: ARRAY
60509: PPUSH
60510: CALL_OW 111
// wait ( 0 0$10 ) ;
60514: LD_INT 350
60516: PPUSH
60517: CALL_OW 67
// end else
60521: GO 60549
// begin ComMoveXY ( tmp , x , y ) ;
60523: LD_VAR 0 7
60527: PPUSH
60528: LD_VAR 0 4
60532: PPUSH
60533: LD_VAR 0 5
60537: PPUSH
60538: CALL_OW 111
// wait ( 0 0$3 ) ;
60542: LD_INT 105
60544: PPUSH
60545: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
60549: LD_VAR 0 7
60553: PPUSH
60554: LD_VAR 0 4
60558: PPUSH
60559: LD_VAR 0 5
60563: PPUSH
60564: CALL_OW 307
60568: IFFALSE 60410
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
60570: LD_VAR 0 7
60574: PPUSH
60575: LD_VAR 0 4
60579: PPUSH
60580: LD_VAR 0 5
60584: PPUSH
60585: LD_VAR 0 8
60589: PUSH
60590: LD_VAR 0 3
60594: ARRAY
60595: PPUSH
60596: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
60600: LD_INT 35
60602: PPUSH
60603: CALL_OW 67
// until not HasTask ( tmp ) ;
60607: LD_VAR 0 7
60611: PPUSH
60612: CALL_OW 314
60616: NOT
60617: IFFALSE 60600
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
60619: LD_ADDR_EXP 138
60623: PUSH
60624: LD_EXP 138
60628: PPUSH
60629: LD_VAR 0 2
60633: PUSH
60634: LD_EXP 138
60638: PUSH
60639: LD_VAR 0 2
60643: ARRAY
60644: PUSH
60645: LD_INT 1
60647: PLUS
60648: PUSH
60649: EMPTY
60650: LIST
60651: LIST
60652: PPUSH
60653: LD_VAR 0 8
60657: PUSH
60658: LD_VAR 0 3
60662: ARRAY
60663: PPUSH
60664: CALL 75342 0 3
60668: ST_TO_ADDR
// end ;
60669: GO 60327
60671: POP
60672: POP
// MC_Reset ( i , 124 ) ;
60673: LD_VAR 0 2
60677: PPUSH
60678: LD_INT 124
60680: PPUSH
60681: CALL 43757 0 2
// end ; end ;
60685: GO 60082
60687: POP
60688: POP
// end ;
60689: LD_VAR 0 1
60693: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
60694: LD_INT 0
60696: PPUSH
60697: PPUSH
60698: PPUSH
// if not mc_bases then
60699: LD_EXP 102
60703: NOT
60704: IFFALSE 60708
// exit ;
60706: GO 61314
// for i = 1 to mc_bases do
60708: LD_ADDR_VAR 0 2
60712: PUSH
60713: DOUBLE
60714: LD_INT 1
60716: DEC
60717: ST_TO_ADDR
60718: LD_EXP 102
60722: PUSH
60723: FOR_TO
60724: IFFALSE 61312
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
60726: LD_ADDR_VAR 0 3
60730: PUSH
60731: LD_EXP 102
60735: PUSH
60736: LD_VAR 0 2
60740: ARRAY
60741: PPUSH
60742: LD_INT 25
60744: PUSH
60745: LD_INT 4
60747: PUSH
60748: EMPTY
60749: LIST
60750: LIST
60751: PPUSH
60752: CALL_OW 72
60756: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
60757: LD_VAR 0 3
60761: NOT
60762: PUSH
60763: LD_EXP 139
60767: PUSH
60768: LD_VAR 0 2
60772: ARRAY
60773: NOT
60774: OR
60775: PUSH
60776: LD_EXP 102
60780: PUSH
60781: LD_VAR 0 2
60785: ARRAY
60786: PPUSH
60787: LD_INT 2
60789: PUSH
60790: LD_INT 30
60792: PUSH
60793: LD_INT 0
60795: PUSH
60796: EMPTY
60797: LIST
60798: LIST
60799: PUSH
60800: LD_INT 30
60802: PUSH
60803: LD_INT 1
60805: PUSH
60806: EMPTY
60807: LIST
60808: LIST
60809: PUSH
60810: EMPTY
60811: LIST
60812: LIST
60813: LIST
60814: PPUSH
60815: CALL_OW 72
60819: NOT
60820: OR
60821: IFFALSE 60871
// begin if mc_deposits_finder [ i ] then
60823: LD_EXP 140
60827: PUSH
60828: LD_VAR 0 2
60832: ARRAY
60833: IFFALSE 60869
// begin MC_Reset ( i , 125 ) ;
60835: LD_VAR 0 2
60839: PPUSH
60840: LD_INT 125
60842: PPUSH
60843: CALL 43757 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60847: LD_ADDR_EXP 140
60851: PUSH
60852: LD_EXP 140
60856: PPUSH
60857: LD_VAR 0 2
60861: PPUSH
60862: EMPTY
60863: PPUSH
60864: CALL_OW 1
60868: ST_TO_ADDR
// end ; continue ;
60869: GO 60723
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
60871: LD_EXP 139
60875: PUSH
60876: LD_VAR 0 2
60880: ARRAY
60881: PUSH
60882: LD_INT 1
60884: ARRAY
60885: PUSH
60886: LD_INT 3
60888: ARRAY
60889: PUSH
60890: LD_INT 1
60892: EQUAL
60893: PUSH
60894: LD_INT 20
60896: PPUSH
60897: LD_EXP 128
60901: PUSH
60902: LD_VAR 0 2
60906: ARRAY
60907: PPUSH
60908: CALL_OW 321
60912: PUSH
60913: LD_INT 2
60915: NONEQUAL
60916: AND
60917: IFFALSE 60967
// begin if mc_deposits_finder [ i ] then
60919: LD_EXP 140
60923: PUSH
60924: LD_VAR 0 2
60928: ARRAY
60929: IFFALSE 60965
// begin MC_Reset ( i , 125 ) ;
60931: LD_VAR 0 2
60935: PPUSH
60936: LD_INT 125
60938: PPUSH
60939: CALL 43757 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60943: LD_ADDR_EXP 140
60947: PUSH
60948: LD_EXP 140
60952: PPUSH
60953: LD_VAR 0 2
60957: PPUSH
60958: EMPTY
60959: PPUSH
60960: CALL_OW 1
60964: ST_TO_ADDR
// end ; continue ;
60965: GO 60723
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
60967: LD_EXP 139
60971: PUSH
60972: LD_VAR 0 2
60976: ARRAY
60977: PUSH
60978: LD_INT 1
60980: ARRAY
60981: PUSH
60982: LD_INT 1
60984: ARRAY
60985: PPUSH
60986: LD_EXP 139
60990: PUSH
60991: LD_VAR 0 2
60995: ARRAY
60996: PUSH
60997: LD_INT 1
60999: ARRAY
61000: PUSH
61001: LD_INT 2
61003: ARRAY
61004: PPUSH
61005: LD_EXP 128
61009: PUSH
61010: LD_VAR 0 2
61014: ARRAY
61015: PPUSH
61016: CALL_OW 440
61020: IFFALSE 61063
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
61022: LD_ADDR_EXP 139
61026: PUSH
61027: LD_EXP 139
61031: PPUSH
61032: LD_VAR 0 2
61036: PPUSH
61037: LD_EXP 139
61041: PUSH
61042: LD_VAR 0 2
61046: ARRAY
61047: PPUSH
61048: LD_INT 1
61050: PPUSH
61051: CALL_OW 3
61055: PPUSH
61056: CALL_OW 1
61060: ST_TO_ADDR
61061: GO 61310
// begin if not mc_deposits_finder [ i ] then
61063: LD_EXP 140
61067: PUSH
61068: LD_VAR 0 2
61072: ARRAY
61073: NOT
61074: IFFALSE 61126
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
61076: LD_ADDR_EXP 140
61080: PUSH
61081: LD_EXP 140
61085: PPUSH
61086: LD_VAR 0 2
61090: PPUSH
61091: LD_VAR 0 3
61095: PUSH
61096: LD_INT 1
61098: ARRAY
61099: PUSH
61100: EMPTY
61101: LIST
61102: PPUSH
61103: CALL_OW 1
61107: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
61108: LD_VAR 0 3
61112: PUSH
61113: LD_INT 1
61115: ARRAY
61116: PPUSH
61117: LD_INT 125
61119: PPUSH
61120: CALL_OW 109
// end else
61124: GO 61310
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
61126: LD_EXP 140
61130: PUSH
61131: LD_VAR 0 2
61135: ARRAY
61136: PUSH
61137: LD_INT 1
61139: ARRAY
61140: PPUSH
61141: CALL_OW 310
61145: IFFALSE 61168
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
61147: LD_EXP 140
61151: PUSH
61152: LD_VAR 0 2
61156: ARRAY
61157: PUSH
61158: LD_INT 1
61160: ARRAY
61161: PPUSH
61162: CALL_OW 122
61166: GO 61310
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
61168: LD_EXP 140
61172: PUSH
61173: LD_VAR 0 2
61177: ARRAY
61178: PUSH
61179: LD_INT 1
61181: ARRAY
61182: PPUSH
61183: CALL_OW 314
61187: NOT
61188: PUSH
61189: LD_EXP 140
61193: PUSH
61194: LD_VAR 0 2
61198: ARRAY
61199: PUSH
61200: LD_INT 1
61202: ARRAY
61203: PPUSH
61204: LD_EXP 139
61208: PUSH
61209: LD_VAR 0 2
61213: ARRAY
61214: PUSH
61215: LD_INT 1
61217: ARRAY
61218: PUSH
61219: LD_INT 1
61221: ARRAY
61222: PPUSH
61223: LD_EXP 139
61227: PUSH
61228: LD_VAR 0 2
61232: ARRAY
61233: PUSH
61234: LD_INT 1
61236: ARRAY
61237: PUSH
61238: LD_INT 2
61240: ARRAY
61241: PPUSH
61242: CALL_OW 297
61246: PUSH
61247: LD_INT 6
61249: GREATER
61250: AND
61251: IFFALSE 61310
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
61253: LD_EXP 140
61257: PUSH
61258: LD_VAR 0 2
61262: ARRAY
61263: PUSH
61264: LD_INT 1
61266: ARRAY
61267: PPUSH
61268: LD_EXP 139
61272: PUSH
61273: LD_VAR 0 2
61277: ARRAY
61278: PUSH
61279: LD_INT 1
61281: ARRAY
61282: PUSH
61283: LD_INT 1
61285: ARRAY
61286: PPUSH
61287: LD_EXP 139
61291: PUSH
61292: LD_VAR 0 2
61296: ARRAY
61297: PUSH
61298: LD_INT 1
61300: ARRAY
61301: PUSH
61302: LD_INT 2
61304: ARRAY
61305: PPUSH
61306: CALL_OW 111
// end ; end ; end ;
61310: GO 60723
61312: POP
61313: POP
// end ;
61314: LD_VAR 0 1
61318: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
61319: LD_INT 0
61321: PPUSH
61322: PPUSH
61323: PPUSH
61324: PPUSH
61325: PPUSH
61326: PPUSH
61327: PPUSH
61328: PPUSH
61329: PPUSH
61330: PPUSH
61331: PPUSH
// if not mc_bases then
61332: LD_EXP 102
61336: NOT
61337: IFFALSE 61341
// exit ;
61339: GO 62281
// for i = 1 to mc_bases do
61341: LD_ADDR_VAR 0 2
61345: PUSH
61346: DOUBLE
61347: LD_INT 1
61349: DEC
61350: ST_TO_ADDR
61351: LD_EXP 102
61355: PUSH
61356: FOR_TO
61357: IFFALSE 62279
// begin if not mc_bases [ i ] or mc_scan [ i ] then
61359: LD_EXP 102
61363: PUSH
61364: LD_VAR 0 2
61368: ARRAY
61369: NOT
61370: PUSH
61371: LD_EXP 125
61375: PUSH
61376: LD_VAR 0 2
61380: ARRAY
61381: OR
61382: IFFALSE 61386
// continue ;
61384: GO 61356
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
61386: LD_ADDR_VAR 0 7
61390: PUSH
61391: LD_EXP 102
61395: PUSH
61396: LD_VAR 0 2
61400: ARRAY
61401: PUSH
61402: LD_INT 1
61404: ARRAY
61405: PPUSH
61406: CALL_OW 248
61410: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
61411: LD_VAR 0 7
61415: PUSH
61416: LD_INT 3
61418: EQUAL
61419: PUSH
61420: LD_EXP 121
61424: PUSH
61425: LD_VAR 0 2
61429: ARRAY
61430: PUSH
61431: LD_EXP 124
61435: PUSH
61436: LD_VAR 0 2
61440: ARRAY
61441: UNION
61442: PPUSH
61443: LD_INT 33
61445: PUSH
61446: LD_INT 2
61448: PUSH
61449: EMPTY
61450: LIST
61451: LIST
61452: PPUSH
61453: CALL_OW 72
61457: NOT
61458: OR
61459: IFFALSE 61463
// continue ;
61461: GO 61356
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
61463: LD_ADDR_VAR 0 9
61467: PUSH
61468: LD_EXP 102
61472: PUSH
61473: LD_VAR 0 2
61477: ARRAY
61478: PPUSH
61479: LD_INT 30
61481: PUSH
61482: LD_INT 36
61484: PUSH
61485: EMPTY
61486: LIST
61487: LIST
61488: PPUSH
61489: CALL_OW 72
61493: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
61494: LD_ADDR_VAR 0 10
61498: PUSH
61499: LD_EXP 121
61503: PUSH
61504: LD_VAR 0 2
61508: ARRAY
61509: PPUSH
61510: LD_INT 34
61512: PUSH
61513: LD_INT 31
61515: PUSH
61516: EMPTY
61517: LIST
61518: LIST
61519: PPUSH
61520: CALL_OW 72
61524: ST_TO_ADDR
// if not cts and not mcts then
61525: LD_VAR 0 9
61529: NOT
61530: PUSH
61531: LD_VAR 0 10
61535: NOT
61536: AND
61537: IFFALSE 61541
// continue ;
61539: GO 61356
// x := cts ;
61541: LD_ADDR_VAR 0 11
61545: PUSH
61546: LD_VAR 0 9
61550: ST_TO_ADDR
// if not x then
61551: LD_VAR 0 11
61555: NOT
61556: IFFALSE 61568
// x := mcts ;
61558: LD_ADDR_VAR 0 11
61562: PUSH
61563: LD_VAR 0 10
61567: ST_TO_ADDR
// if not x then
61568: LD_VAR 0 11
61572: NOT
61573: IFFALSE 61577
// continue ;
61575: GO 61356
// if mc_remote_driver [ i ] then
61577: LD_EXP 142
61581: PUSH
61582: LD_VAR 0 2
61586: ARRAY
61587: IFFALSE 61974
// for j in mc_remote_driver [ i ] do
61589: LD_ADDR_VAR 0 3
61593: PUSH
61594: LD_EXP 142
61598: PUSH
61599: LD_VAR 0 2
61603: ARRAY
61604: PUSH
61605: FOR_IN
61606: IFFALSE 61972
// begin if GetClass ( j ) <> 3 then
61608: LD_VAR 0 3
61612: PPUSH
61613: CALL_OW 257
61617: PUSH
61618: LD_INT 3
61620: NONEQUAL
61621: IFFALSE 61674
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
61623: LD_ADDR_EXP 142
61627: PUSH
61628: LD_EXP 142
61632: PPUSH
61633: LD_VAR 0 2
61637: PPUSH
61638: LD_EXP 142
61642: PUSH
61643: LD_VAR 0 2
61647: ARRAY
61648: PUSH
61649: LD_VAR 0 3
61653: DIFF
61654: PPUSH
61655: CALL_OW 1
61659: ST_TO_ADDR
// SetTag ( j , 0 ) ;
61660: LD_VAR 0 3
61664: PPUSH
61665: LD_INT 0
61667: PPUSH
61668: CALL_OW 109
// continue ;
61672: GO 61605
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
61674: LD_EXP 121
61678: PUSH
61679: LD_VAR 0 2
61683: ARRAY
61684: PPUSH
61685: LD_INT 34
61687: PUSH
61688: LD_INT 31
61690: PUSH
61691: EMPTY
61692: LIST
61693: LIST
61694: PUSH
61695: LD_INT 58
61697: PUSH
61698: EMPTY
61699: LIST
61700: PUSH
61701: EMPTY
61702: LIST
61703: LIST
61704: PPUSH
61705: CALL_OW 72
61709: PUSH
61710: LD_VAR 0 3
61714: PPUSH
61715: CALL 105695 0 1
61719: NOT
61720: AND
61721: IFFALSE 61792
// begin if IsInUnit ( j ) then
61723: LD_VAR 0 3
61727: PPUSH
61728: CALL_OW 310
61732: IFFALSE 61743
// ComExitBuilding ( j ) ;
61734: LD_VAR 0 3
61738: PPUSH
61739: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
61743: LD_VAR 0 3
61747: PPUSH
61748: LD_EXP 121
61752: PUSH
61753: LD_VAR 0 2
61757: ARRAY
61758: PPUSH
61759: LD_INT 34
61761: PUSH
61762: LD_INT 31
61764: PUSH
61765: EMPTY
61766: LIST
61767: LIST
61768: PUSH
61769: LD_INT 58
61771: PUSH
61772: EMPTY
61773: LIST
61774: PUSH
61775: EMPTY
61776: LIST
61777: LIST
61778: PPUSH
61779: CALL_OW 72
61783: PUSH
61784: LD_INT 1
61786: ARRAY
61787: PPUSH
61788: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
61792: LD_VAR 0 3
61796: PPUSH
61797: CALL_OW 310
61801: NOT
61802: PUSH
61803: LD_VAR 0 3
61807: PPUSH
61808: CALL_OW 310
61812: PPUSH
61813: CALL_OW 266
61817: PUSH
61818: LD_INT 36
61820: NONEQUAL
61821: PUSH
61822: LD_VAR 0 3
61826: PPUSH
61827: CALL 105695 0 1
61831: NOT
61832: AND
61833: OR
61834: IFFALSE 61970
// begin if IsInUnit ( j ) then
61836: LD_VAR 0 3
61840: PPUSH
61841: CALL_OW 310
61845: IFFALSE 61856
// ComExitBuilding ( j ) ;
61847: LD_VAR 0 3
61851: PPUSH
61852: CALL_OW 122
// ct := 0 ;
61856: LD_ADDR_VAR 0 8
61860: PUSH
61861: LD_INT 0
61863: ST_TO_ADDR
// for k in x do
61864: LD_ADDR_VAR 0 4
61868: PUSH
61869: LD_VAR 0 11
61873: PUSH
61874: FOR_IN
61875: IFFALSE 61948
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
61877: LD_VAR 0 4
61881: PPUSH
61882: CALL_OW 264
61886: PUSH
61887: LD_INT 31
61889: EQUAL
61890: PUSH
61891: LD_VAR 0 4
61895: PPUSH
61896: CALL_OW 311
61900: NOT
61901: AND
61902: PUSH
61903: LD_VAR 0 4
61907: PPUSH
61908: CALL_OW 266
61912: PUSH
61913: LD_INT 36
61915: EQUAL
61916: PUSH
61917: LD_VAR 0 4
61921: PPUSH
61922: CALL_OW 313
61926: PUSH
61927: LD_INT 3
61929: LESS
61930: AND
61931: OR
61932: IFFALSE 61946
// begin ct := k ;
61934: LD_ADDR_VAR 0 8
61938: PUSH
61939: LD_VAR 0 4
61943: ST_TO_ADDR
// break ;
61944: GO 61948
// end ;
61946: GO 61874
61948: POP
61949: POP
// if ct then
61950: LD_VAR 0 8
61954: IFFALSE 61970
// ComEnterUnit ( j , ct ) ;
61956: LD_VAR 0 3
61960: PPUSH
61961: LD_VAR 0 8
61965: PPUSH
61966: CALL_OW 120
// end ; end ;
61970: GO 61605
61972: POP
61973: POP
// places := 0 ;
61974: LD_ADDR_VAR 0 5
61978: PUSH
61979: LD_INT 0
61981: ST_TO_ADDR
// for j = 1 to x do
61982: LD_ADDR_VAR 0 3
61986: PUSH
61987: DOUBLE
61988: LD_INT 1
61990: DEC
61991: ST_TO_ADDR
61992: LD_VAR 0 11
61996: PUSH
61997: FOR_TO
61998: IFFALSE 62074
// if GetWeapon ( x [ j ] ) = ar_control_tower then
62000: LD_VAR 0 11
62004: PUSH
62005: LD_VAR 0 3
62009: ARRAY
62010: PPUSH
62011: CALL_OW 264
62015: PUSH
62016: LD_INT 31
62018: EQUAL
62019: IFFALSE 62037
// places := places + 1 else
62021: LD_ADDR_VAR 0 5
62025: PUSH
62026: LD_VAR 0 5
62030: PUSH
62031: LD_INT 1
62033: PLUS
62034: ST_TO_ADDR
62035: GO 62072
// if GetBType ( x [ j ] ) = b_control_tower then
62037: LD_VAR 0 11
62041: PUSH
62042: LD_VAR 0 3
62046: ARRAY
62047: PPUSH
62048: CALL_OW 266
62052: PUSH
62053: LD_INT 36
62055: EQUAL
62056: IFFALSE 62072
// places := places + 3 ;
62058: LD_ADDR_VAR 0 5
62062: PUSH
62063: LD_VAR 0 5
62067: PUSH
62068: LD_INT 3
62070: PLUS
62071: ST_TO_ADDR
62072: GO 61997
62074: POP
62075: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
62076: LD_VAR 0 5
62080: PUSH
62081: LD_INT 0
62083: EQUAL
62084: PUSH
62085: LD_VAR 0 5
62089: PUSH
62090: LD_EXP 142
62094: PUSH
62095: LD_VAR 0 2
62099: ARRAY
62100: LESSEQUAL
62101: OR
62102: IFFALSE 62106
// continue ;
62104: GO 61356
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
62106: LD_ADDR_VAR 0 6
62110: PUSH
62111: LD_EXP 102
62115: PUSH
62116: LD_VAR 0 2
62120: ARRAY
62121: PPUSH
62122: LD_INT 25
62124: PUSH
62125: LD_INT 3
62127: PUSH
62128: EMPTY
62129: LIST
62130: LIST
62131: PPUSH
62132: CALL_OW 72
62136: PUSH
62137: LD_EXP 142
62141: PUSH
62142: LD_VAR 0 2
62146: ARRAY
62147: DIFF
62148: PPUSH
62149: LD_INT 3
62151: PPUSH
62152: CALL 106595 0 2
62156: ST_TO_ADDR
// for j in tmp do
62157: LD_ADDR_VAR 0 3
62161: PUSH
62162: LD_VAR 0 6
62166: PUSH
62167: FOR_IN
62168: IFFALSE 62203
// if GetTag ( j ) > 0 then
62170: LD_VAR 0 3
62174: PPUSH
62175: CALL_OW 110
62179: PUSH
62180: LD_INT 0
62182: GREATER
62183: IFFALSE 62201
// tmp := tmp diff j ;
62185: LD_ADDR_VAR 0 6
62189: PUSH
62190: LD_VAR 0 6
62194: PUSH
62195: LD_VAR 0 3
62199: DIFF
62200: ST_TO_ADDR
62201: GO 62167
62203: POP
62204: POP
// if not tmp then
62205: LD_VAR 0 6
62209: NOT
62210: IFFALSE 62214
// continue ;
62212: GO 61356
// if places then
62214: LD_VAR 0 5
62218: IFFALSE 62277
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
62220: LD_ADDR_EXP 142
62224: PUSH
62225: LD_EXP 142
62229: PPUSH
62230: LD_VAR 0 2
62234: PPUSH
62235: LD_EXP 142
62239: PUSH
62240: LD_VAR 0 2
62244: ARRAY
62245: PUSH
62246: LD_VAR 0 6
62250: PUSH
62251: LD_INT 1
62253: ARRAY
62254: UNION
62255: PPUSH
62256: CALL_OW 1
62260: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
62261: LD_VAR 0 6
62265: PUSH
62266: LD_INT 1
62268: ARRAY
62269: PPUSH
62270: LD_INT 126
62272: PPUSH
62273: CALL_OW 109
// end ; end ;
62277: GO 61356
62279: POP
62280: POP
// end ;
62281: LD_VAR 0 1
62285: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
62286: LD_INT 0
62288: PPUSH
62289: PPUSH
62290: PPUSH
62291: PPUSH
62292: PPUSH
62293: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
62294: LD_VAR 0 1
62298: NOT
62299: PUSH
62300: LD_VAR 0 2
62304: NOT
62305: OR
62306: PUSH
62307: LD_VAR 0 3
62311: NOT
62312: OR
62313: PUSH
62314: LD_VAR 0 4
62318: PUSH
62319: LD_INT 1
62321: PUSH
62322: LD_INT 2
62324: PUSH
62325: LD_INT 3
62327: PUSH
62328: LD_INT 4
62330: PUSH
62331: LD_INT 5
62333: PUSH
62334: LD_INT 8
62336: PUSH
62337: LD_INT 9
62339: PUSH
62340: LD_INT 15
62342: PUSH
62343: LD_INT 16
62345: PUSH
62346: EMPTY
62347: LIST
62348: LIST
62349: LIST
62350: LIST
62351: LIST
62352: LIST
62353: LIST
62354: LIST
62355: LIST
62356: IN
62357: NOT
62358: OR
62359: IFFALSE 62363
// exit ;
62361: GO 63221
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
62363: LD_ADDR_VAR 0 2
62367: PUSH
62368: LD_VAR 0 2
62372: PPUSH
62373: LD_INT 21
62375: PUSH
62376: LD_INT 3
62378: PUSH
62379: EMPTY
62380: LIST
62381: LIST
62382: PUSH
62383: LD_INT 24
62385: PUSH
62386: LD_INT 250
62388: PUSH
62389: EMPTY
62390: LIST
62391: LIST
62392: PUSH
62393: EMPTY
62394: LIST
62395: LIST
62396: PPUSH
62397: CALL_OW 72
62401: ST_TO_ADDR
// case class of 1 , 15 :
62402: LD_VAR 0 4
62406: PUSH
62407: LD_INT 1
62409: DOUBLE
62410: EQUAL
62411: IFTRUE 62421
62413: LD_INT 15
62415: DOUBLE
62416: EQUAL
62417: IFTRUE 62421
62419: GO 62506
62421: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
62422: LD_ADDR_VAR 0 8
62426: PUSH
62427: LD_VAR 0 2
62431: PPUSH
62432: LD_INT 2
62434: PUSH
62435: LD_INT 30
62437: PUSH
62438: LD_INT 32
62440: PUSH
62441: EMPTY
62442: LIST
62443: LIST
62444: PUSH
62445: LD_INT 30
62447: PUSH
62448: LD_INT 31
62450: PUSH
62451: EMPTY
62452: LIST
62453: LIST
62454: PUSH
62455: EMPTY
62456: LIST
62457: LIST
62458: LIST
62459: PPUSH
62460: CALL_OW 72
62464: PUSH
62465: LD_VAR 0 2
62469: PPUSH
62470: LD_INT 2
62472: PUSH
62473: LD_INT 30
62475: PUSH
62476: LD_INT 4
62478: PUSH
62479: EMPTY
62480: LIST
62481: LIST
62482: PUSH
62483: LD_INT 30
62485: PUSH
62486: LD_INT 5
62488: PUSH
62489: EMPTY
62490: LIST
62491: LIST
62492: PUSH
62493: EMPTY
62494: LIST
62495: LIST
62496: LIST
62497: PPUSH
62498: CALL_OW 72
62502: ADD
62503: ST_TO_ADDR
62504: GO 62752
62506: LD_INT 2
62508: DOUBLE
62509: EQUAL
62510: IFTRUE 62520
62512: LD_INT 16
62514: DOUBLE
62515: EQUAL
62516: IFTRUE 62520
62518: GO 62566
62520: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
62521: LD_ADDR_VAR 0 8
62525: PUSH
62526: LD_VAR 0 2
62530: PPUSH
62531: LD_INT 2
62533: PUSH
62534: LD_INT 30
62536: PUSH
62537: LD_INT 0
62539: PUSH
62540: EMPTY
62541: LIST
62542: LIST
62543: PUSH
62544: LD_INT 30
62546: PUSH
62547: LD_INT 1
62549: PUSH
62550: EMPTY
62551: LIST
62552: LIST
62553: PUSH
62554: EMPTY
62555: LIST
62556: LIST
62557: LIST
62558: PPUSH
62559: CALL_OW 72
62563: ST_TO_ADDR
62564: GO 62752
62566: LD_INT 3
62568: DOUBLE
62569: EQUAL
62570: IFTRUE 62574
62572: GO 62620
62574: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
62575: LD_ADDR_VAR 0 8
62579: PUSH
62580: LD_VAR 0 2
62584: PPUSH
62585: LD_INT 2
62587: PUSH
62588: LD_INT 30
62590: PUSH
62591: LD_INT 2
62593: PUSH
62594: EMPTY
62595: LIST
62596: LIST
62597: PUSH
62598: LD_INT 30
62600: PUSH
62601: LD_INT 3
62603: PUSH
62604: EMPTY
62605: LIST
62606: LIST
62607: PUSH
62608: EMPTY
62609: LIST
62610: LIST
62611: LIST
62612: PPUSH
62613: CALL_OW 72
62617: ST_TO_ADDR
62618: GO 62752
62620: LD_INT 4
62622: DOUBLE
62623: EQUAL
62624: IFTRUE 62628
62626: GO 62685
62628: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
62629: LD_ADDR_VAR 0 8
62633: PUSH
62634: LD_VAR 0 2
62638: PPUSH
62639: LD_INT 2
62641: PUSH
62642: LD_INT 30
62644: PUSH
62645: LD_INT 6
62647: PUSH
62648: EMPTY
62649: LIST
62650: LIST
62651: PUSH
62652: LD_INT 30
62654: PUSH
62655: LD_INT 7
62657: PUSH
62658: EMPTY
62659: LIST
62660: LIST
62661: PUSH
62662: LD_INT 30
62664: PUSH
62665: LD_INT 8
62667: PUSH
62668: EMPTY
62669: LIST
62670: LIST
62671: PUSH
62672: EMPTY
62673: LIST
62674: LIST
62675: LIST
62676: LIST
62677: PPUSH
62678: CALL_OW 72
62682: ST_TO_ADDR
62683: GO 62752
62685: LD_INT 5
62687: DOUBLE
62688: EQUAL
62689: IFTRUE 62705
62691: LD_INT 8
62693: DOUBLE
62694: EQUAL
62695: IFTRUE 62705
62697: LD_INT 9
62699: DOUBLE
62700: EQUAL
62701: IFTRUE 62705
62703: GO 62751
62705: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
62706: LD_ADDR_VAR 0 8
62710: PUSH
62711: LD_VAR 0 2
62715: PPUSH
62716: LD_INT 2
62718: PUSH
62719: LD_INT 30
62721: PUSH
62722: LD_INT 4
62724: PUSH
62725: EMPTY
62726: LIST
62727: LIST
62728: PUSH
62729: LD_INT 30
62731: PUSH
62732: LD_INT 5
62734: PUSH
62735: EMPTY
62736: LIST
62737: LIST
62738: PUSH
62739: EMPTY
62740: LIST
62741: LIST
62742: LIST
62743: PPUSH
62744: CALL_OW 72
62748: ST_TO_ADDR
62749: GO 62752
62751: POP
// if not tmp then
62752: LD_VAR 0 8
62756: NOT
62757: IFFALSE 62761
// exit ;
62759: GO 63221
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
62761: LD_VAR 0 4
62765: PUSH
62766: LD_INT 1
62768: PUSH
62769: LD_INT 15
62771: PUSH
62772: EMPTY
62773: LIST
62774: LIST
62775: IN
62776: PUSH
62777: LD_EXP 111
62781: PUSH
62782: LD_VAR 0 1
62786: ARRAY
62787: AND
62788: IFFALSE 62944
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
62790: LD_ADDR_VAR 0 9
62794: PUSH
62795: LD_EXP 111
62799: PUSH
62800: LD_VAR 0 1
62804: ARRAY
62805: PUSH
62806: LD_INT 1
62808: ARRAY
62809: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
62810: LD_VAR 0 9
62814: PUSH
62815: LD_EXP 112
62819: PUSH
62820: LD_VAR 0 1
62824: ARRAY
62825: IN
62826: NOT
62827: IFFALSE 62942
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
62829: LD_ADDR_EXP 112
62833: PUSH
62834: LD_EXP 112
62838: PPUSH
62839: LD_VAR 0 1
62843: PUSH
62844: LD_EXP 112
62848: PUSH
62849: LD_VAR 0 1
62853: ARRAY
62854: PUSH
62855: LD_INT 1
62857: PLUS
62858: PUSH
62859: EMPTY
62860: LIST
62861: LIST
62862: PPUSH
62863: LD_VAR 0 9
62867: PPUSH
62868: CALL 75342 0 3
62872: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
62873: LD_ADDR_EXP 111
62877: PUSH
62878: LD_EXP 111
62882: PPUSH
62883: LD_VAR 0 1
62887: PPUSH
62888: LD_EXP 111
62892: PUSH
62893: LD_VAR 0 1
62897: ARRAY
62898: PUSH
62899: LD_VAR 0 9
62903: DIFF
62904: PPUSH
62905: CALL_OW 1
62909: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
62910: LD_VAR 0 3
62914: PPUSH
62915: LD_EXP 112
62919: PUSH
62920: LD_VAR 0 1
62924: ARRAY
62925: PUSH
62926: LD_EXP 112
62930: PUSH
62931: LD_VAR 0 1
62935: ARRAY
62936: ARRAY
62937: PPUSH
62938: CALL_OW 120
// end ; exit ;
62942: GO 63221
// end ; if tmp > 1 then
62944: LD_VAR 0 8
62948: PUSH
62949: LD_INT 1
62951: GREATER
62952: IFFALSE 63056
// for i = 2 to tmp do
62954: LD_ADDR_VAR 0 6
62958: PUSH
62959: DOUBLE
62960: LD_INT 2
62962: DEC
62963: ST_TO_ADDR
62964: LD_VAR 0 8
62968: PUSH
62969: FOR_TO
62970: IFFALSE 63054
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
62972: LD_VAR 0 8
62976: PUSH
62977: LD_VAR 0 6
62981: ARRAY
62982: PPUSH
62983: CALL_OW 461
62987: PUSH
62988: LD_INT 6
62990: EQUAL
62991: IFFALSE 63052
// begin x := tmp [ i ] ;
62993: LD_ADDR_VAR 0 9
62997: PUSH
62998: LD_VAR 0 8
63002: PUSH
63003: LD_VAR 0 6
63007: ARRAY
63008: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
63009: LD_ADDR_VAR 0 8
63013: PUSH
63014: LD_VAR 0 8
63018: PPUSH
63019: LD_VAR 0 6
63023: PPUSH
63024: CALL_OW 3
63028: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
63029: LD_ADDR_VAR 0 8
63033: PUSH
63034: LD_VAR 0 8
63038: PPUSH
63039: LD_INT 1
63041: PPUSH
63042: LD_VAR 0 9
63046: PPUSH
63047: CALL_OW 2
63051: ST_TO_ADDR
// end ;
63052: GO 62969
63054: POP
63055: POP
// for i in tmp do
63056: LD_ADDR_VAR 0 6
63060: PUSH
63061: LD_VAR 0 8
63065: PUSH
63066: FOR_IN
63067: IFFALSE 63094
// begin if IsNotFull ( i ) then
63069: LD_VAR 0 6
63073: PPUSH
63074: CALL 72564 0 1
63078: IFFALSE 63092
// begin j := i ;
63080: LD_ADDR_VAR 0 7
63084: PUSH
63085: LD_VAR 0 6
63089: ST_TO_ADDR
// break ;
63090: GO 63094
// end ; end ;
63092: GO 63066
63094: POP
63095: POP
// if j then
63096: LD_VAR 0 7
63100: IFFALSE 63118
// ComEnterUnit ( unit , j ) else
63102: LD_VAR 0 3
63106: PPUSH
63107: LD_VAR 0 7
63111: PPUSH
63112: CALL_OW 120
63116: GO 63221
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63118: LD_ADDR_VAR 0 10
63122: PUSH
63123: LD_VAR 0 2
63127: PPUSH
63128: LD_INT 2
63130: PUSH
63131: LD_INT 30
63133: PUSH
63134: LD_INT 0
63136: PUSH
63137: EMPTY
63138: LIST
63139: LIST
63140: PUSH
63141: LD_INT 30
63143: PUSH
63144: LD_INT 1
63146: PUSH
63147: EMPTY
63148: LIST
63149: LIST
63150: PUSH
63151: EMPTY
63152: LIST
63153: LIST
63154: LIST
63155: PPUSH
63156: CALL_OW 72
63160: ST_TO_ADDR
// if depot then
63161: LD_VAR 0 10
63165: IFFALSE 63221
// begin depot := NearestUnitToUnit ( depot , unit ) ;
63167: LD_ADDR_VAR 0 10
63171: PUSH
63172: LD_VAR 0 10
63176: PPUSH
63177: LD_VAR 0 3
63181: PPUSH
63182: CALL_OW 74
63186: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
63187: LD_VAR 0 3
63191: PPUSH
63192: LD_VAR 0 10
63196: PPUSH
63197: CALL_OW 296
63201: PUSH
63202: LD_INT 10
63204: GREATER
63205: IFFALSE 63221
// ComStandNearbyBuilding ( unit , depot ) ;
63207: LD_VAR 0 3
63211: PPUSH
63212: LD_VAR 0 10
63216: PPUSH
63217: CALL 71944 0 2
// end ; end ; end ;
63221: LD_VAR 0 5
63225: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
63226: LD_INT 0
63228: PPUSH
63229: PPUSH
63230: PPUSH
63231: PPUSH
// if not mc_bases then
63232: LD_EXP 102
63236: NOT
63237: IFFALSE 63241
// exit ;
63239: GO 63480
// for i = 1 to mc_bases do
63241: LD_ADDR_VAR 0 2
63245: PUSH
63246: DOUBLE
63247: LD_INT 1
63249: DEC
63250: ST_TO_ADDR
63251: LD_EXP 102
63255: PUSH
63256: FOR_TO
63257: IFFALSE 63478
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
63259: LD_ADDR_VAR 0 4
63263: PUSH
63264: LD_EXP 102
63268: PUSH
63269: LD_VAR 0 2
63273: ARRAY
63274: PPUSH
63275: LD_INT 21
63277: PUSH
63278: LD_INT 1
63280: PUSH
63281: EMPTY
63282: LIST
63283: LIST
63284: PPUSH
63285: CALL_OW 72
63289: PUSH
63290: LD_EXP 131
63294: PUSH
63295: LD_VAR 0 2
63299: ARRAY
63300: UNION
63301: ST_TO_ADDR
// if not tmp then
63302: LD_VAR 0 4
63306: NOT
63307: IFFALSE 63311
// continue ;
63309: GO 63256
// for j in tmp do
63311: LD_ADDR_VAR 0 3
63315: PUSH
63316: LD_VAR 0 4
63320: PUSH
63321: FOR_IN
63322: IFFALSE 63474
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
63324: LD_VAR 0 3
63328: PPUSH
63329: CALL_OW 110
63333: NOT
63334: PUSH
63335: LD_VAR 0 3
63339: PPUSH
63340: CALL_OW 314
63344: NOT
63345: AND
63346: PUSH
63347: LD_VAR 0 3
63351: PPUSH
63352: CALL_OW 311
63356: NOT
63357: AND
63358: PUSH
63359: LD_VAR 0 3
63363: PPUSH
63364: CALL_OW 310
63368: NOT
63369: AND
63370: PUSH
63371: LD_VAR 0 3
63375: PUSH
63376: LD_EXP 105
63380: PUSH
63381: LD_VAR 0 2
63385: ARRAY
63386: PUSH
63387: LD_INT 1
63389: ARRAY
63390: IN
63391: NOT
63392: AND
63393: PUSH
63394: LD_VAR 0 3
63398: PUSH
63399: LD_EXP 105
63403: PUSH
63404: LD_VAR 0 2
63408: ARRAY
63409: PUSH
63410: LD_INT 2
63412: ARRAY
63413: IN
63414: NOT
63415: AND
63416: PUSH
63417: LD_VAR 0 3
63421: PUSH
63422: LD_EXP 114
63426: PUSH
63427: LD_VAR 0 2
63431: ARRAY
63432: IN
63433: NOT
63434: AND
63435: IFFALSE 63472
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
63437: LD_VAR 0 2
63441: PPUSH
63442: LD_EXP 102
63446: PUSH
63447: LD_VAR 0 2
63451: ARRAY
63452: PPUSH
63453: LD_VAR 0 3
63457: PPUSH
63458: LD_VAR 0 3
63462: PPUSH
63463: CALL_OW 257
63467: PPUSH
63468: CALL 62286 0 4
// end ;
63472: GO 63321
63474: POP
63475: POP
// end ;
63476: GO 63256
63478: POP
63479: POP
// end ;
63480: LD_VAR 0 1
63484: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
63485: LD_INT 0
63487: PPUSH
63488: PPUSH
63489: PPUSH
63490: PPUSH
63491: PPUSH
63492: PPUSH
// if not mc_bases [ base ] then
63493: LD_EXP 102
63497: PUSH
63498: LD_VAR 0 1
63502: ARRAY
63503: NOT
63504: IFFALSE 63508
// exit ;
63506: GO 63709
// tmp := [ ] ;
63508: LD_ADDR_VAR 0 6
63512: PUSH
63513: EMPTY
63514: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
63515: LD_ADDR_VAR 0 7
63519: PUSH
63520: LD_VAR 0 3
63524: PPUSH
63525: LD_INT 0
63527: PPUSH
63528: CALL_OW 517
63532: ST_TO_ADDR
// if not list then
63533: LD_VAR 0 7
63537: NOT
63538: IFFALSE 63542
// exit ;
63540: GO 63709
// c := Count ( list [ 1 ] ) ;
63542: LD_ADDR_VAR 0 9
63546: PUSH
63547: LD_VAR 0 7
63551: PUSH
63552: LD_INT 1
63554: ARRAY
63555: PPUSH
63556: CALL 72482 0 1
63560: ST_TO_ADDR
// if amount > c then
63561: LD_VAR 0 2
63565: PUSH
63566: LD_VAR 0 9
63570: GREATER
63571: IFFALSE 63583
// amount := c ;
63573: LD_ADDR_VAR 0 2
63577: PUSH
63578: LD_VAR 0 9
63582: ST_TO_ADDR
// for i := 1 to amount do
63583: LD_ADDR_VAR 0 5
63587: PUSH
63588: DOUBLE
63589: LD_INT 1
63591: DEC
63592: ST_TO_ADDR
63593: LD_VAR 0 2
63597: PUSH
63598: FOR_TO
63599: IFFALSE 63657
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
63601: LD_ADDR_VAR 0 6
63605: PUSH
63606: LD_VAR 0 6
63610: PPUSH
63611: LD_VAR 0 5
63615: PPUSH
63616: LD_VAR 0 7
63620: PUSH
63621: LD_INT 1
63623: ARRAY
63624: PUSH
63625: LD_VAR 0 5
63629: ARRAY
63630: PUSH
63631: LD_VAR 0 7
63635: PUSH
63636: LD_INT 2
63638: ARRAY
63639: PUSH
63640: LD_VAR 0 5
63644: ARRAY
63645: PUSH
63646: EMPTY
63647: LIST
63648: LIST
63649: PPUSH
63650: CALL_OW 1
63654: ST_TO_ADDR
63655: GO 63598
63657: POP
63658: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
63659: LD_ADDR_EXP 115
63663: PUSH
63664: LD_EXP 115
63668: PPUSH
63669: LD_VAR 0 1
63673: PPUSH
63674: LD_VAR 0 6
63678: PPUSH
63679: CALL_OW 1
63683: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
63684: LD_ADDR_EXP 117
63688: PUSH
63689: LD_EXP 117
63693: PPUSH
63694: LD_VAR 0 1
63698: PPUSH
63699: LD_VAR 0 3
63703: PPUSH
63704: CALL_OW 1
63708: ST_TO_ADDR
// end ;
63709: LD_VAR 0 4
63713: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
63714: LD_INT 0
63716: PPUSH
// if not mc_bases [ base ] then
63717: LD_EXP 102
63721: PUSH
63722: LD_VAR 0 1
63726: ARRAY
63727: NOT
63728: IFFALSE 63732
// exit ;
63730: GO 63757
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
63732: LD_ADDR_EXP 107
63736: PUSH
63737: LD_EXP 107
63741: PPUSH
63742: LD_VAR 0 1
63746: PPUSH
63747: LD_VAR 0 2
63751: PPUSH
63752: CALL_OW 1
63756: ST_TO_ADDR
// end ;
63757: LD_VAR 0 3
63761: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
63762: LD_INT 0
63764: PPUSH
// if not mc_bases [ base ] then
63765: LD_EXP 102
63769: PUSH
63770: LD_VAR 0 1
63774: ARRAY
63775: NOT
63776: IFFALSE 63780
// exit ;
63778: GO 63817
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
63780: LD_ADDR_EXP 107
63784: PUSH
63785: LD_EXP 107
63789: PPUSH
63790: LD_VAR 0 1
63794: PPUSH
63795: LD_EXP 107
63799: PUSH
63800: LD_VAR 0 1
63804: ARRAY
63805: PUSH
63806: LD_VAR 0 2
63810: UNION
63811: PPUSH
63812: CALL_OW 1
63816: ST_TO_ADDR
// end ;
63817: LD_VAR 0 3
63821: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
63822: LD_INT 0
63824: PPUSH
// if not mc_bases [ base ] then
63825: LD_EXP 102
63829: PUSH
63830: LD_VAR 0 1
63834: ARRAY
63835: NOT
63836: IFFALSE 63840
// exit ;
63838: GO 63865
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
63840: LD_ADDR_EXP 123
63844: PUSH
63845: LD_EXP 123
63849: PPUSH
63850: LD_VAR 0 1
63854: PPUSH
63855: LD_VAR 0 2
63859: PPUSH
63860: CALL_OW 1
63864: ST_TO_ADDR
// end ;
63865: LD_VAR 0 3
63869: RET
// export function MC_InsertProduceList ( base , components ) ; begin
63870: LD_INT 0
63872: PPUSH
// if not mc_bases [ base ] then
63873: LD_EXP 102
63877: PUSH
63878: LD_VAR 0 1
63882: ARRAY
63883: NOT
63884: IFFALSE 63888
// exit ;
63886: GO 63925
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
63888: LD_ADDR_EXP 123
63892: PUSH
63893: LD_EXP 123
63897: PPUSH
63898: LD_VAR 0 1
63902: PPUSH
63903: LD_EXP 123
63907: PUSH
63908: LD_VAR 0 1
63912: ARRAY
63913: PUSH
63914: LD_VAR 0 2
63918: ADD
63919: PPUSH
63920: CALL_OW 1
63924: ST_TO_ADDR
// end ;
63925: LD_VAR 0 3
63929: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
63930: LD_INT 0
63932: PPUSH
// if not mc_bases [ base ] then
63933: LD_EXP 102
63937: PUSH
63938: LD_VAR 0 1
63942: ARRAY
63943: NOT
63944: IFFALSE 63948
// exit ;
63946: GO 64002
// mc_defender := Replace ( mc_defender , base , deflist ) ;
63948: LD_ADDR_EXP 124
63952: PUSH
63953: LD_EXP 124
63957: PPUSH
63958: LD_VAR 0 1
63962: PPUSH
63963: LD_VAR 0 2
63967: PPUSH
63968: CALL_OW 1
63972: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
63973: LD_ADDR_EXP 113
63977: PUSH
63978: LD_EXP 113
63982: PPUSH
63983: LD_VAR 0 1
63987: PPUSH
63988: LD_VAR 0 2
63992: PUSH
63993: LD_INT 0
63995: PLUS
63996: PPUSH
63997: CALL_OW 1
64001: ST_TO_ADDR
// end ;
64002: LD_VAR 0 3
64006: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
64007: LD_INT 0
64009: PPUSH
// if not mc_bases [ base ] then
64010: LD_EXP 102
64014: PUSH
64015: LD_VAR 0 1
64019: ARRAY
64020: NOT
64021: IFFALSE 64025
// exit ;
64023: GO 64050
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
64025: LD_ADDR_EXP 113
64029: PUSH
64030: LD_EXP 113
64034: PPUSH
64035: LD_VAR 0 1
64039: PPUSH
64040: LD_VAR 0 2
64044: PPUSH
64045: CALL_OW 1
64049: ST_TO_ADDR
// end ;
64050: LD_VAR 0 3
64054: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
64055: LD_INT 0
64057: PPUSH
64058: PPUSH
64059: PPUSH
64060: PPUSH
// if not mc_bases [ base ] then
64061: LD_EXP 102
64065: PUSH
64066: LD_VAR 0 1
64070: ARRAY
64071: NOT
64072: IFFALSE 64076
// exit ;
64074: GO 64141
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
64076: LD_ADDR_EXP 122
64080: PUSH
64081: LD_EXP 122
64085: PPUSH
64086: LD_VAR 0 1
64090: PUSH
64091: LD_EXP 122
64095: PUSH
64096: LD_VAR 0 1
64100: ARRAY
64101: PUSH
64102: LD_INT 1
64104: PLUS
64105: PUSH
64106: EMPTY
64107: LIST
64108: LIST
64109: PPUSH
64110: LD_VAR 0 1
64114: PUSH
64115: LD_VAR 0 2
64119: PUSH
64120: LD_VAR 0 3
64124: PUSH
64125: LD_VAR 0 4
64129: PUSH
64130: EMPTY
64131: LIST
64132: LIST
64133: LIST
64134: LIST
64135: PPUSH
64136: CALL 75342 0 3
64140: ST_TO_ADDR
// end ;
64141: LD_VAR 0 5
64145: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
64146: LD_INT 0
64148: PPUSH
// if not mc_bases [ base ] then
64149: LD_EXP 102
64153: PUSH
64154: LD_VAR 0 1
64158: ARRAY
64159: NOT
64160: IFFALSE 64164
// exit ;
64162: GO 64189
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
64164: LD_ADDR_EXP 139
64168: PUSH
64169: LD_EXP 139
64173: PPUSH
64174: LD_VAR 0 1
64178: PPUSH
64179: LD_VAR 0 2
64183: PPUSH
64184: CALL_OW 1
64188: ST_TO_ADDR
// end ;
64189: LD_VAR 0 3
64193: RET
// export function MC_GetMinesField ( base ) ; begin
64194: LD_INT 0
64196: PPUSH
// result := mc_mines [ base ] ;
64197: LD_ADDR_VAR 0 2
64201: PUSH
64202: LD_EXP 115
64206: PUSH
64207: LD_VAR 0 1
64211: ARRAY
64212: ST_TO_ADDR
// end ;
64213: LD_VAR 0 2
64217: RET
// export function MC_GetProduceList ( base ) ; begin
64218: LD_INT 0
64220: PPUSH
// result := mc_produce [ base ] ;
64221: LD_ADDR_VAR 0 2
64225: PUSH
64226: LD_EXP 123
64230: PUSH
64231: LD_VAR 0 1
64235: ARRAY
64236: ST_TO_ADDR
// end ;
64237: LD_VAR 0 2
64241: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
64242: LD_INT 0
64244: PPUSH
64245: PPUSH
// if not mc_bases then
64246: LD_EXP 102
64250: NOT
64251: IFFALSE 64255
// exit ;
64253: GO 64320
// if mc_bases [ base ] then
64255: LD_EXP 102
64259: PUSH
64260: LD_VAR 0 1
64264: ARRAY
64265: IFFALSE 64320
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
64267: LD_ADDR_VAR 0 3
64271: PUSH
64272: LD_EXP 102
64276: PUSH
64277: LD_VAR 0 1
64281: ARRAY
64282: PPUSH
64283: LD_INT 30
64285: PUSH
64286: LD_VAR 0 2
64290: PUSH
64291: EMPTY
64292: LIST
64293: LIST
64294: PPUSH
64295: CALL_OW 72
64299: ST_TO_ADDR
// if result then
64300: LD_VAR 0 3
64304: IFFALSE 64320
// result := result [ 1 ] ;
64306: LD_ADDR_VAR 0 3
64310: PUSH
64311: LD_VAR 0 3
64315: PUSH
64316: LD_INT 1
64318: ARRAY
64319: ST_TO_ADDR
// end ; end ;
64320: LD_VAR 0 3
64324: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
64325: LD_INT 0
64327: PPUSH
64328: PPUSH
// if not mc_bases then
64329: LD_EXP 102
64333: NOT
64334: IFFALSE 64338
// exit ;
64336: GO 64383
// if mc_bases [ base ] then
64338: LD_EXP 102
64342: PUSH
64343: LD_VAR 0 1
64347: ARRAY
64348: IFFALSE 64383
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
64350: LD_ADDR_VAR 0 3
64354: PUSH
64355: LD_EXP 102
64359: PUSH
64360: LD_VAR 0 1
64364: ARRAY
64365: PPUSH
64366: LD_INT 30
64368: PUSH
64369: LD_VAR 0 2
64373: PUSH
64374: EMPTY
64375: LIST
64376: LIST
64377: PPUSH
64378: CALL_OW 72
64382: ST_TO_ADDR
// end ;
64383: LD_VAR 0 3
64387: RET
// export function MC_SetTame ( base , area ) ; begin
64388: LD_INT 0
64390: PPUSH
// if not mc_bases or not base then
64391: LD_EXP 102
64395: NOT
64396: PUSH
64397: LD_VAR 0 1
64401: NOT
64402: OR
64403: IFFALSE 64407
// exit ;
64405: GO 64432
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
64407: LD_ADDR_EXP 130
64411: PUSH
64412: LD_EXP 130
64416: PPUSH
64417: LD_VAR 0 1
64421: PPUSH
64422: LD_VAR 0 2
64426: PPUSH
64427: CALL_OW 1
64431: ST_TO_ADDR
// end ;
64432: LD_VAR 0 3
64436: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
64437: LD_INT 0
64439: PPUSH
64440: PPUSH
// if not mc_bases or not base then
64441: LD_EXP 102
64445: NOT
64446: PUSH
64447: LD_VAR 0 1
64451: NOT
64452: OR
64453: IFFALSE 64457
// exit ;
64455: GO 64559
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
64457: LD_ADDR_VAR 0 4
64461: PUSH
64462: LD_EXP 102
64466: PUSH
64467: LD_VAR 0 1
64471: ARRAY
64472: PPUSH
64473: LD_INT 30
64475: PUSH
64476: LD_VAR 0 2
64480: PUSH
64481: EMPTY
64482: LIST
64483: LIST
64484: PPUSH
64485: CALL_OW 72
64489: ST_TO_ADDR
// if not tmp then
64490: LD_VAR 0 4
64494: NOT
64495: IFFALSE 64499
// exit ;
64497: GO 64559
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
64499: LD_ADDR_EXP 134
64503: PUSH
64504: LD_EXP 134
64508: PPUSH
64509: LD_VAR 0 1
64513: PPUSH
64514: LD_EXP 134
64518: PUSH
64519: LD_VAR 0 1
64523: ARRAY
64524: PPUSH
64525: LD_EXP 134
64529: PUSH
64530: LD_VAR 0 1
64534: ARRAY
64535: PUSH
64536: LD_INT 1
64538: PLUS
64539: PPUSH
64540: LD_VAR 0 4
64544: PUSH
64545: LD_INT 1
64547: ARRAY
64548: PPUSH
64549: CALL_OW 2
64553: PPUSH
64554: CALL_OW 1
64558: ST_TO_ADDR
// end ;
64559: LD_VAR 0 3
64563: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
64564: LD_INT 0
64566: PPUSH
64567: PPUSH
// if not mc_bases or not base or not kinds then
64568: LD_EXP 102
64572: NOT
64573: PUSH
64574: LD_VAR 0 1
64578: NOT
64579: OR
64580: PUSH
64581: LD_VAR 0 2
64585: NOT
64586: OR
64587: IFFALSE 64591
// exit ;
64589: GO 64652
// for i in kinds do
64591: LD_ADDR_VAR 0 4
64595: PUSH
64596: LD_VAR 0 2
64600: PUSH
64601: FOR_IN
64602: IFFALSE 64650
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
64604: LD_ADDR_EXP 136
64608: PUSH
64609: LD_EXP 136
64613: PPUSH
64614: LD_VAR 0 1
64618: PUSH
64619: LD_EXP 136
64623: PUSH
64624: LD_VAR 0 1
64628: ARRAY
64629: PUSH
64630: LD_INT 1
64632: PLUS
64633: PUSH
64634: EMPTY
64635: LIST
64636: LIST
64637: PPUSH
64638: LD_VAR 0 4
64642: PPUSH
64643: CALL 75342 0 3
64647: ST_TO_ADDR
64648: GO 64601
64650: POP
64651: POP
// end ;
64652: LD_VAR 0 3
64656: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
64657: LD_INT 0
64659: PPUSH
// if not mc_bases or not base or not areas then
64660: LD_EXP 102
64664: NOT
64665: PUSH
64666: LD_VAR 0 1
64670: NOT
64671: OR
64672: PUSH
64673: LD_VAR 0 2
64677: NOT
64678: OR
64679: IFFALSE 64683
// exit ;
64681: GO 64708
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
64683: LD_ADDR_EXP 120
64687: PUSH
64688: LD_EXP 120
64692: PPUSH
64693: LD_VAR 0 1
64697: PPUSH
64698: LD_VAR 0 2
64702: PPUSH
64703: CALL_OW 1
64707: ST_TO_ADDR
// end ;
64708: LD_VAR 0 3
64712: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
64713: LD_INT 0
64715: PPUSH
// if not mc_bases or not base or not teleports_exit then
64716: LD_EXP 102
64720: NOT
64721: PUSH
64722: LD_VAR 0 1
64726: NOT
64727: OR
64728: PUSH
64729: LD_VAR 0 2
64733: NOT
64734: OR
64735: IFFALSE 64739
// exit ;
64737: GO 64764
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
64739: LD_ADDR_EXP 137
64743: PUSH
64744: LD_EXP 137
64748: PPUSH
64749: LD_VAR 0 1
64753: PPUSH
64754: LD_VAR 0 2
64758: PPUSH
64759: CALL_OW 1
64763: ST_TO_ADDR
// end ;
64764: LD_VAR 0 3
64768: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
64769: LD_INT 0
64771: PPUSH
64772: PPUSH
64773: PPUSH
// if not mc_bases or not base or not ext_list then
64774: LD_EXP 102
64778: NOT
64779: PUSH
64780: LD_VAR 0 1
64784: NOT
64785: OR
64786: PUSH
64787: LD_VAR 0 5
64791: NOT
64792: OR
64793: IFFALSE 64797
// exit ;
64795: GO 64970
// tmp := GetFacExtXYD ( x , y , d ) ;
64797: LD_ADDR_VAR 0 8
64801: PUSH
64802: LD_VAR 0 2
64806: PPUSH
64807: LD_VAR 0 3
64811: PPUSH
64812: LD_VAR 0 4
64816: PPUSH
64817: CALL 105725 0 3
64821: ST_TO_ADDR
// if not tmp then
64822: LD_VAR 0 8
64826: NOT
64827: IFFALSE 64831
// exit ;
64829: GO 64970
// for i in tmp do
64831: LD_ADDR_VAR 0 7
64835: PUSH
64836: LD_VAR 0 8
64840: PUSH
64841: FOR_IN
64842: IFFALSE 64968
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
64844: LD_ADDR_EXP 107
64848: PUSH
64849: LD_EXP 107
64853: PPUSH
64854: LD_VAR 0 1
64858: PPUSH
64859: LD_EXP 107
64863: PUSH
64864: LD_VAR 0 1
64868: ARRAY
64869: PPUSH
64870: LD_EXP 107
64874: PUSH
64875: LD_VAR 0 1
64879: ARRAY
64880: PUSH
64881: LD_INT 1
64883: PLUS
64884: PPUSH
64885: LD_VAR 0 5
64889: PUSH
64890: LD_INT 1
64892: ARRAY
64893: PUSH
64894: LD_VAR 0 7
64898: PUSH
64899: LD_INT 1
64901: ARRAY
64902: PUSH
64903: LD_VAR 0 7
64907: PUSH
64908: LD_INT 2
64910: ARRAY
64911: PUSH
64912: LD_VAR 0 7
64916: PUSH
64917: LD_INT 3
64919: ARRAY
64920: PUSH
64921: EMPTY
64922: LIST
64923: LIST
64924: LIST
64925: LIST
64926: PPUSH
64927: CALL_OW 2
64931: PPUSH
64932: CALL_OW 1
64936: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
64937: LD_ADDR_VAR 0 5
64941: PUSH
64942: LD_VAR 0 5
64946: PPUSH
64947: LD_INT 1
64949: PPUSH
64950: CALL_OW 3
64954: ST_TO_ADDR
// if not ext_list then
64955: LD_VAR 0 5
64959: NOT
64960: IFFALSE 64966
// exit ;
64962: POP
64963: POP
64964: GO 64970
// end ;
64966: GO 64841
64968: POP
64969: POP
// end ;
64970: LD_VAR 0 6
64974: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
64975: LD_INT 0
64977: PPUSH
// if not mc_bases or not base or not weapon_list then
64978: LD_EXP 102
64982: NOT
64983: PUSH
64984: LD_VAR 0 1
64988: NOT
64989: OR
64990: PUSH
64991: LD_VAR 0 2
64995: NOT
64996: OR
64997: IFFALSE 65001
// exit ;
64999: GO 65026
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
65001: LD_ADDR_EXP 141
65005: PUSH
65006: LD_EXP 141
65010: PPUSH
65011: LD_VAR 0 1
65015: PPUSH
65016: LD_VAR 0 2
65020: PPUSH
65021: CALL_OW 1
65025: ST_TO_ADDR
// end ;
65026: LD_VAR 0 3
65030: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
65031: LD_INT 0
65033: PPUSH
// if not mc_bases or not base or not tech_list then
65034: LD_EXP 102
65038: NOT
65039: PUSH
65040: LD_VAR 0 1
65044: NOT
65045: OR
65046: PUSH
65047: LD_VAR 0 2
65051: NOT
65052: OR
65053: IFFALSE 65057
// exit ;
65055: GO 65082
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
65057: LD_ADDR_EXP 129
65061: PUSH
65062: LD_EXP 129
65066: PPUSH
65067: LD_VAR 0 1
65071: PPUSH
65072: LD_VAR 0 2
65076: PPUSH
65077: CALL_OW 1
65081: ST_TO_ADDR
// end ;
65082: LD_VAR 0 3
65086: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
65087: LD_INT 0
65089: PPUSH
// if not mc_bases or not parking_area or not base then
65090: LD_EXP 102
65094: NOT
65095: PUSH
65096: LD_VAR 0 2
65100: NOT
65101: OR
65102: PUSH
65103: LD_VAR 0 1
65107: NOT
65108: OR
65109: IFFALSE 65113
// exit ;
65111: GO 65138
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
65113: LD_ADDR_EXP 126
65117: PUSH
65118: LD_EXP 126
65122: PPUSH
65123: LD_VAR 0 1
65127: PPUSH
65128: LD_VAR 0 2
65132: PPUSH
65133: CALL_OW 1
65137: ST_TO_ADDR
// end ;
65138: LD_VAR 0 3
65142: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
65143: LD_INT 0
65145: PPUSH
// if not mc_bases or not base or not scan_area then
65146: LD_EXP 102
65150: NOT
65151: PUSH
65152: LD_VAR 0 1
65156: NOT
65157: OR
65158: PUSH
65159: LD_VAR 0 2
65163: NOT
65164: OR
65165: IFFALSE 65169
// exit ;
65167: GO 65194
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
65169: LD_ADDR_EXP 127
65173: PUSH
65174: LD_EXP 127
65178: PPUSH
65179: LD_VAR 0 1
65183: PPUSH
65184: LD_VAR 0 2
65188: PPUSH
65189: CALL_OW 1
65193: ST_TO_ADDR
// end ;
65194: LD_VAR 0 3
65198: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
65199: LD_INT 0
65201: PPUSH
65202: PPUSH
// if not mc_bases or not base then
65203: LD_EXP 102
65207: NOT
65208: PUSH
65209: LD_VAR 0 1
65213: NOT
65214: OR
65215: IFFALSE 65219
// exit ;
65217: GO 65283
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
65219: LD_ADDR_VAR 0 3
65223: PUSH
65224: LD_INT 1
65226: PUSH
65227: LD_INT 2
65229: PUSH
65230: LD_INT 3
65232: PUSH
65233: LD_INT 4
65235: PUSH
65236: LD_INT 11
65238: PUSH
65239: EMPTY
65240: LIST
65241: LIST
65242: LIST
65243: LIST
65244: LIST
65245: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
65246: LD_ADDR_EXP 129
65250: PUSH
65251: LD_EXP 129
65255: PPUSH
65256: LD_VAR 0 1
65260: PPUSH
65261: LD_EXP 129
65265: PUSH
65266: LD_VAR 0 1
65270: ARRAY
65271: PUSH
65272: LD_VAR 0 3
65276: DIFF
65277: PPUSH
65278: CALL_OW 1
65282: ST_TO_ADDR
// end ;
65283: LD_VAR 0 2
65287: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
65288: LD_INT 0
65290: PPUSH
// result := mc_vehicles [ base ] ;
65291: LD_ADDR_VAR 0 3
65295: PUSH
65296: LD_EXP 121
65300: PUSH
65301: LD_VAR 0 1
65305: ARRAY
65306: ST_TO_ADDR
// if onlyCombat then
65307: LD_VAR 0 2
65311: IFFALSE 65483
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
65313: LD_ADDR_VAR 0 3
65317: PUSH
65318: LD_VAR 0 3
65322: PUSH
65323: LD_VAR 0 3
65327: PPUSH
65328: LD_INT 2
65330: PUSH
65331: LD_INT 34
65333: PUSH
65334: LD_INT 12
65336: PUSH
65337: EMPTY
65338: LIST
65339: LIST
65340: PUSH
65341: LD_INT 34
65343: PUSH
65344: LD_INT 51
65346: PUSH
65347: EMPTY
65348: LIST
65349: LIST
65350: PUSH
65351: LD_INT 34
65353: PUSH
65354: LD_INT 89
65356: PUSH
65357: EMPTY
65358: LIST
65359: LIST
65360: PUSH
65361: LD_INT 34
65363: PUSH
65364: LD_INT 32
65366: PUSH
65367: EMPTY
65368: LIST
65369: LIST
65370: PUSH
65371: LD_INT 34
65373: PUSH
65374: LD_INT 13
65376: PUSH
65377: EMPTY
65378: LIST
65379: LIST
65380: PUSH
65381: LD_INT 34
65383: PUSH
65384: LD_INT 52
65386: PUSH
65387: EMPTY
65388: LIST
65389: LIST
65390: PUSH
65391: LD_INT 34
65393: PUSH
65394: LD_INT 88
65396: PUSH
65397: EMPTY
65398: LIST
65399: LIST
65400: PUSH
65401: LD_INT 34
65403: PUSH
65404: LD_INT 14
65406: PUSH
65407: EMPTY
65408: LIST
65409: LIST
65410: PUSH
65411: LD_INT 34
65413: PUSH
65414: LD_INT 53
65416: PUSH
65417: EMPTY
65418: LIST
65419: LIST
65420: PUSH
65421: LD_INT 34
65423: PUSH
65424: LD_INT 98
65426: PUSH
65427: EMPTY
65428: LIST
65429: LIST
65430: PUSH
65431: LD_INT 34
65433: PUSH
65434: LD_INT 31
65436: PUSH
65437: EMPTY
65438: LIST
65439: LIST
65440: PUSH
65441: LD_INT 34
65443: PUSH
65444: LD_INT 48
65446: PUSH
65447: EMPTY
65448: LIST
65449: LIST
65450: PUSH
65451: LD_INT 34
65453: PUSH
65454: LD_INT 8
65456: PUSH
65457: EMPTY
65458: LIST
65459: LIST
65460: PUSH
65461: EMPTY
65462: LIST
65463: LIST
65464: LIST
65465: LIST
65466: LIST
65467: LIST
65468: LIST
65469: LIST
65470: LIST
65471: LIST
65472: LIST
65473: LIST
65474: LIST
65475: LIST
65476: PPUSH
65477: CALL_OW 72
65481: DIFF
65482: ST_TO_ADDR
// end ; end_of_file
65483: LD_VAR 0 3
65487: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
65488: LD_INT 0
65490: PPUSH
65491: PPUSH
65492: PPUSH
// if not mc_bases or not skirmish then
65493: LD_EXP 102
65497: NOT
65498: PUSH
65499: LD_EXP 100
65503: NOT
65504: OR
65505: IFFALSE 65509
// exit ;
65507: GO 65674
// for i = 1 to mc_bases do
65509: LD_ADDR_VAR 0 4
65513: PUSH
65514: DOUBLE
65515: LD_INT 1
65517: DEC
65518: ST_TO_ADDR
65519: LD_EXP 102
65523: PUSH
65524: FOR_TO
65525: IFFALSE 65672
// begin if sci in mc_bases [ i ] then
65527: LD_VAR 0 2
65531: PUSH
65532: LD_EXP 102
65536: PUSH
65537: LD_VAR 0 4
65541: ARRAY
65542: IN
65543: IFFALSE 65670
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
65545: LD_ADDR_EXP 131
65549: PUSH
65550: LD_EXP 131
65554: PPUSH
65555: LD_VAR 0 4
65559: PUSH
65560: LD_EXP 131
65564: PUSH
65565: LD_VAR 0 4
65569: ARRAY
65570: PUSH
65571: LD_INT 1
65573: PLUS
65574: PUSH
65575: EMPTY
65576: LIST
65577: LIST
65578: PPUSH
65579: LD_VAR 0 1
65583: PPUSH
65584: CALL 75342 0 3
65588: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
65589: LD_ADDR_VAR 0 5
65593: PUSH
65594: LD_EXP 102
65598: PUSH
65599: LD_VAR 0 4
65603: ARRAY
65604: PPUSH
65605: LD_INT 2
65607: PUSH
65608: LD_INT 30
65610: PUSH
65611: LD_INT 0
65613: PUSH
65614: EMPTY
65615: LIST
65616: LIST
65617: PUSH
65618: LD_INT 30
65620: PUSH
65621: LD_INT 1
65623: PUSH
65624: EMPTY
65625: LIST
65626: LIST
65627: PUSH
65628: EMPTY
65629: LIST
65630: LIST
65631: LIST
65632: PPUSH
65633: CALL_OW 72
65637: PPUSH
65638: LD_VAR 0 1
65642: PPUSH
65643: CALL_OW 74
65647: ST_TO_ADDR
// if tmp then
65648: LD_VAR 0 5
65652: IFFALSE 65668
// ComStandNearbyBuilding ( ape , tmp ) ;
65654: LD_VAR 0 1
65658: PPUSH
65659: LD_VAR 0 5
65663: PPUSH
65664: CALL 71944 0 2
// break ;
65668: GO 65672
// end ; end ;
65670: GO 65524
65672: POP
65673: POP
// end ;
65674: LD_VAR 0 3
65678: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
65679: LD_INT 0
65681: PPUSH
65682: PPUSH
65683: PPUSH
// if not mc_bases or not skirmish then
65684: LD_EXP 102
65688: NOT
65689: PUSH
65690: LD_EXP 100
65694: NOT
65695: OR
65696: IFFALSE 65700
// exit ;
65698: GO 65789
// for i = 1 to mc_bases do
65700: LD_ADDR_VAR 0 4
65704: PUSH
65705: DOUBLE
65706: LD_INT 1
65708: DEC
65709: ST_TO_ADDR
65710: LD_EXP 102
65714: PUSH
65715: FOR_TO
65716: IFFALSE 65787
// begin if building in mc_busy_turret_list [ i ] then
65718: LD_VAR 0 1
65722: PUSH
65723: LD_EXP 112
65727: PUSH
65728: LD_VAR 0 4
65732: ARRAY
65733: IN
65734: IFFALSE 65785
// begin tmp := mc_busy_turret_list [ i ] diff building ;
65736: LD_ADDR_VAR 0 5
65740: PUSH
65741: LD_EXP 112
65745: PUSH
65746: LD_VAR 0 4
65750: ARRAY
65751: PUSH
65752: LD_VAR 0 1
65756: DIFF
65757: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
65758: LD_ADDR_EXP 112
65762: PUSH
65763: LD_EXP 112
65767: PPUSH
65768: LD_VAR 0 4
65772: PPUSH
65773: LD_VAR 0 5
65777: PPUSH
65778: CALL_OW 1
65782: ST_TO_ADDR
// break ;
65783: GO 65787
// end ; end ;
65785: GO 65715
65787: POP
65788: POP
// end ;
65789: LD_VAR 0 3
65793: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
65794: LD_INT 0
65796: PPUSH
65797: PPUSH
65798: PPUSH
// if not mc_bases or not skirmish then
65799: LD_EXP 102
65803: NOT
65804: PUSH
65805: LD_EXP 100
65809: NOT
65810: OR
65811: IFFALSE 65815
// exit ;
65813: GO 66014
// for i = 1 to mc_bases do
65815: LD_ADDR_VAR 0 5
65819: PUSH
65820: DOUBLE
65821: LD_INT 1
65823: DEC
65824: ST_TO_ADDR
65825: LD_EXP 102
65829: PUSH
65830: FOR_TO
65831: IFFALSE 66012
// if building in mc_bases [ i ] then
65833: LD_VAR 0 1
65837: PUSH
65838: LD_EXP 102
65842: PUSH
65843: LD_VAR 0 5
65847: ARRAY
65848: IN
65849: IFFALSE 66010
// begin tmp := mc_bases [ i ] diff building ;
65851: LD_ADDR_VAR 0 6
65855: PUSH
65856: LD_EXP 102
65860: PUSH
65861: LD_VAR 0 5
65865: ARRAY
65866: PUSH
65867: LD_VAR 0 1
65871: DIFF
65872: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
65873: LD_ADDR_EXP 102
65877: PUSH
65878: LD_EXP 102
65882: PPUSH
65883: LD_VAR 0 5
65887: PPUSH
65888: LD_VAR 0 6
65892: PPUSH
65893: CALL_OW 1
65897: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
65898: LD_VAR 0 1
65902: PUSH
65903: LD_EXP 110
65907: PUSH
65908: LD_VAR 0 5
65912: ARRAY
65913: IN
65914: IFFALSE 65953
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
65916: LD_ADDR_EXP 110
65920: PUSH
65921: LD_EXP 110
65925: PPUSH
65926: LD_VAR 0 5
65930: PPUSH
65931: LD_EXP 110
65935: PUSH
65936: LD_VAR 0 5
65940: ARRAY
65941: PUSH
65942: LD_VAR 0 1
65946: DIFF
65947: PPUSH
65948: CALL_OW 1
65952: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
65953: LD_VAR 0 1
65957: PUSH
65958: LD_EXP 111
65962: PUSH
65963: LD_VAR 0 5
65967: ARRAY
65968: IN
65969: IFFALSE 66008
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
65971: LD_ADDR_EXP 111
65975: PUSH
65976: LD_EXP 111
65980: PPUSH
65981: LD_VAR 0 5
65985: PPUSH
65986: LD_EXP 111
65990: PUSH
65991: LD_VAR 0 5
65995: ARRAY
65996: PUSH
65997: LD_VAR 0 1
66001: DIFF
66002: PPUSH
66003: CALL_OW 1
66007: ST_TO_ADDR
// break ;
66008: GO 66012
// end ;
66010: GO 65830
66012: POP
66013: POP
// end ;
66014: LD_VAR 0 4
66018: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
66019: LD_INT 0
66021: PPUSH
66022: PPUSH
66023: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
66024: LD_EXP 102
66028: NOT
66029: PUSH
66030: LD_EXP 100
66034: NOT
66035: OR
66036: PUSH
66037: LD_VAR 0 3
66041: PUSH
66042: LD_EXP 128
66046: IN
66047: NOT
66048: OR
66049: IFFALSE 66053
// exit ;
66051: GO 66176
// for i = 1 to mc_vehicles do
66053: LD_ADDR_VAR 0 6
66057: PUSH
66058: DOUBLE
66059: LD_INT 1
66061: DEC
66062: ST_TO_ADDR
66063: LD_EXP 121
66067: PUSH
66068: FOR_TO
66069: IFFALSE 66174
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
66071: LD_VAR 0 2
66075: PUSH
66076: LD_EXP 121
66080: PUSH
66081: LD_VAR 0 6
66085: ARRAY
66086: IN
66087: PUSH
66088: LD_VAR 0 1
66092: PUSH
66093: LD_EXP 121
66097: PUSH
66098: LD_VAR 0 6
66102: ARRAY
66103: IN
66104: OR
66105: IFFALSE 66172
// begin tmp := mc_vehicles [ i ] diff old ;
66107: LD_ADDR_VAR 0 7
66111: PUSH
66112: LD_EXP 121
66116: PUSH
66117: LD_VAR 0 6
66121: ARRAY
66122: PUSH
66123: LD_VAR 0 2
66127: DIFF
66128: ST_TO_ADDR
// tmp := tmp diff new ;
66129: LD_ADDR_VAR 0 7
66133: PUSH
66134: LD_VAR 0 7
66138: PUSH
66139: LD_VAR 0 1
66143: DIFF
66144: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
66145: LD_ADDR_EXP 121
66149: PUSH
66150: LD_EXP 121
66154: PPUSH
66155: LD_VAR 0 6
66159: PPUSH
66160: LD_VAR 0 7
66164: PPUSH
66165: CALL_OW 1
66169: ST_TO_ADDR
// break ;
66170: GO 66174
// end ;
66172: GO 66068
66174: POP
66175: POP
// end ;
66176: LD_VAR 0 5
66180: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
66181: LD_INT 0
66183: PPUSH
66184: PPUSH
66185: PPUSH
66186: PPUSH
// if not mc_bases or not skirmish then
66187: LD_EXP 102
66191: NOT
66192: PUSH
66193: LD_EXP 100
66197: NOT
66198: OR
66199: IFFALSE 66203
// exit ;
66201: GO 66623
// repeat wait ( 0 0$1 ) ;
66203: LD_INT 35
66205: PPUSH
66206: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
66210: LD_EXP 146
66214: NOT
66215: IFFALSE 66203
// mc_block_vehicle_constructed_thread := true ;
66217: LD_ADDR_EXP 146
66221: PUSH
66222: LD_INT 1
66224: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
66225: LD_ADDR_VAR 0 5
66229: PUSH
66230: LD_VAR 0 1
66234: PPUSH
66235: CALL_OW 255
66239: ST_TO_ADDR
// for i = 1 to mc_bases do
66240: LD_ADDR_VAR 0 4
66244: PUSH
66245: DOUBLE
66246: LD_INT 1
66248: DEC
66249: ST_TO_ADDR
66250: LD_EXP 102
66254: PUSH
66255: FOR_TO
66256: IFFALSE 66613
// begin if factory in mc_bases [ i ] then
66258: LD_VAR 0 2
66262: PUSH
66263: LD_EXP 102
66267: PUSH
66268: LD_VAR 0 4
66272: ARRAY
66273: IN
66274: IFFALSE 66611
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
66276: LD_EXP 124
66280: PUSH
66281: LD_VAR 0 4
66285: ARRAY
66286: PUSH
66287: LD_EXP 113
66291: PUSH
66292: LD_VAR 0 4
66296: ARRAY
66297: LESS
66298: PUSH
66299: LD_VAR 0 1
66303: PPUSH
66304: CALL_OW 264
66308: PUSH
66309: LD_INT 31
66311: PUSH
66312: LD_INT 32
66314: PUSH
66315: LD_INT 51
66317: PUSH
66318: LD_INT 89
66320: PUSH
66321: LD_INT 12
66323: PUSH
66324: LD_INT 30
66326: PUSH
66327: LD_INT 98
66329: PUSH
66330: LD_INT 11
66332: PUSH
66333: LD_INT 53
66335: PUSH
66336: LD_INT 14
66338: PUSH
66339: LD_INT 91
66341: PUSH
66342: LD_INT 29
66344: PUSH
66345: LD_INT 99
66347: PUSH
66348: LD_INT 13
66350: PUSH
66351: LD_INT 52
66353: PUSH
66354: LD_INT 88
66356: PUSH
66357: LD_INT 48
66359: PUSH
66360: LD_INT 8
66362: PUSH
66363: EMPTY
66364: LIST
66365: LIST
66366: LIST
66367: LIST
66368: LIST
66369: LIST
66370: LIST
66371: LIST
66372: LIST
66373: LIST
66374: LIST
66375: LIST
66376: LIST
66377: LIST
66378: LIST
66379: LIST
66380: LIST
66381: LIST
66382: IN
66383: NOT
66384: AND
66385: IFFALSE 66433
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
66387: LD_ADDR_EXP 124
66391: PUSH
66392: LD_EXP 124
66396: PPUSH
66397: LD_VAR 0 4
66401: PUSH
66402: LD_EXP 124
66406: PUSH
66407: LD_VAR 0 4
66411: ARRAY
66412: PUSH
66413: LD_INT 1
66415: PLUS
66416: PUSH
66417: EMPTY
66418: LIST
66419: LIST
66420: PPUSH
66421: LD_VAR 0 1
66425: PPUSH
66426: CALL 75342 0 3
66430: ST_TO_ADDR
66431: GO 66477
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
66433: LD_ADDR_EXP 121
66437: PUSH
66438: LD_EXP 121
66442: PPUSH
66443: LD_VAR 0 4
66447: PUSH
66448: LD_EXP 121
66452: PUSH
66453: LD_VAR 0 4
66457: ARRAY
66458: PUSH
66459: LD_INT 1
66461: PLUS
66462: PUSH
66463: EMPTY
66464: LIST
66465: LIST
66466: PPUSH
66467: LD_VAR 0 1
66471: PPUSH
66472: CALL 75342 0 3
66476: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
66477: LD_ADDR_EXP 146
66481: PUSH
66482: LD_INT 0
66484: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
66485: LD_VAR 0 1
66489: PPUSH
66490: CALL_OW 263
66494: PUSH
66495: LD_INT 2
66497: EQUAL
66498: IFFALSE 66527
// begin repeat wait ( 0 0$3 ) ;
66500: LD_INT 105
66502: PPUSH
66503: CALL_OW 67
// Connect ( vehicle ) ;
66507: LD_VAR 0 1
66511: PPUSH
66512: CALL 78688 0 1
// until IsControledBy ( vehicle ) ;
66516: LD_VAR 0 1
66520: PPUSH
66521: CALL_OW 312
66525: IFFALSE 66500
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
66527: LD_VAR 0 1
66531: PPUSH
66532: LD_EXP 126
66536: PUSH
66537: LD_VAR 0 4
66541: ARRAY
66542: PPUSH
66543: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
66547: LD_VAR 0 1
66551: PPUSH
66552: CALL_OW 263
66556: PUSH
66557: LD_INT 1
66559: NONEQUAL
66560: IFFALSE 66564
// break ;
66562: GO 66613
// repeat wait ( 0 0$1 ) ;
66564: LD_INT 35
66566: PPUSH
66567: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
66571: LD_VAR 0 1
66575: PPUSH
66576: LD_EXP 126
66580: PUSH
66581: LD_VAR 0 4
66585: ARRAY
66586: PPUSH
66587: CALL_OW 308
66591: IFFALSE 66564
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
66593: LD_VAR 0 1
66597: PPUSH
66598: CALL_OW 311
66602: PPUSH
66603: CALL_OW 121
// exit ;
66607: POP
66608: POP
66609: GO 66623
// end ; end ;
66611: GO 66255
66613: POP
66614: POP
// mc_block_vehicle_constructed_thread := false ;
66615: LD_ADDR_EXP 146
66619: PUSH
66620: LD_INT 0
66622: ST_TO_ADDR
// end ;
66623: LD_VAR 0 3
66627: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
66628: LD_INT 0
66630: PPUSH
66631: PPUSH
66632: PPUSH
66633: PPUSH
// if not mc_bases or not skirmish then
66634: LD_EXP 102
66638: NOT
66639: PUSH
66640: LD_EXP 100
66644: NOT
66645: OR
66646: IFFALSE 66650
// exit ;
66648: GO 67003
// repeat wait ( 0 0$1 ) ;
66650: LD_INT 35
66652: PPUSH
66653: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
66657: LD_VAR 0 2
66661: PPUSH
66662: LD_VAR 0 3
66666: PPUSH
66667: CALL_OW 284
66671: IFFALSE 66650
// if GetResourceTypeXY ( x , y ) = mat_artefact then
66673: LD_VAR 0 2
66677: PPUSH
66678: LD_VAR 0 3
66682: PPUSH
66683: CALL_OW 283
66687: PUSH
66688: LD_INT 4
66690: EQUAL
66691: IFFALSE 66695
// exit ;
66693: GO 67003
// for i = 1 to mc_bases do
66695: LD_ADDR_VAR 0 7
66699: PUSH
66700: DOUBLE
66701: LD_INT 1
66703: DEC
66704: ST_TO_ADDR
66705: LD_EXP 102
66709: PUSH
66710: FOR_TO
66711: IFFALSE 67001
// begin if mc_crates_area [ i ] then
66713: LD_EXP 120
66717: PUSH
66718: LD_VAR 0 7
66722: ARRAY
66723: IFFALSE 66834
// for j in mc_crates_area [ i ] do
66725: LD_ADDR_VAR 0 8
66729: PUSH
66730: LD_EXP 120
66734: PUSH
66735: LD_VAR 0 7
66739: ARRAY
66740: PUSH
66741: FOR_IN
66742: IFFALSE 66832
// if InArea ( x , y , j ) then
66744: LD_VAR 0 2
66748: PPUSH
66749: LD_VAR 0 3
66753: PPUSH
66754: LD_VAR 0 8
66758: PPUSH
66759: CALL_OW 309
66763: IFFALSE 66830
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
66765: LD_ADDR_EXP 118
66769: PUSH
66770: LD_EXP 118
66774: PPUSH
66775: LD_VAR 0 7
66779: PUSH
66780: LD_EXP 118
66784: PUSH
66785: LD_VAR 0 7
66789: ARRAY
66790: PUSH
66791: LD_INT 1
66793: PLUS
66794: PUSH
66795: EMPTY
66796: LIST
66797: LIST
66798: PPUSH
66799: LD_VAR 0 4
66803: PUSH
66804: LD_VAR 0 2
66808: PUSH
66809: LD_VAR 0 3
66813: PUSH
66814: EMPTY
66815: LIST
66816: LIST
66817: LIST
66818: PPUSH
66819: CALL 75342 0 3
66823: ST_TO_ADDR
// exit ;
66824: POP
66825: POP
66826: POP
66827: POP
66828: GO 67003
// end ;
66830: GO 66741
66832: POP
66833: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66834: LD_ADDR_VAR 0 9
66838: PUSH
66839: LD_EXP 102
66843: PUSH
66844: LD_VAR 0 7
66848: ARRAY
66849: PPUSH
66850: LD_INT 2
66852: PUSH
66853: LD_INT 30
66855: PUSH
66856: LD_INT 0
66858: PUSH
66859: EMPTY
66860: LIST
66861: LIST
66862: PUSH
66863: LD_INT 30
66865: PUSH
66866: LD_INT 1
66868: PUSH
66869: EMPTY
66870: LIST
66871: LIST
66872: PUSH
66873: EMPTY
66874: LIST
66875: LIST
66876: LIST
66877: PPUSH
66878: CALL_OW 72
66882: ST_TO_ADDR
// if not depot then
66883: LD_VAR 0 9
66887: NOT
66888: IFFALSE 66892
// continue ;
66890: GO 66710
// for j in depot do
66892: LD_ADDR_VAR 0 8
66896: PUSH
66897: LD_VAR 0 9
66901: PUSH
66902: FOR_IN
66903: IFFALSE 66997
// if GetDistUnitXY ( j , x , y ) < 30 then
66905: LD_VAR 0 8
66909: PPUSH
66910: LD_VAR 0 2
66914: PPUSH
66915: LD_VAR 0 3
66919: PPUSH
66920: CALL_OW 297
66924: PUSH
66925: LD_INT 30
66927: LESS
66928: IFFALSE 66995
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
66930: LD_ADDR_EXP 118
66934: PUSH
66935: LD_EXP 118
66939: PPUSH
66940: LD_VAR 0 7
66944: PUSH
66945: LD_EXP 118
66949: PUSH
66950: LD_VAR 0 7
66954: ARRAY
66955: PUSH
66956: LD_INT 1
66958: PLUS
66959: PUSH
66960: EMPTY
66961: LIST
66962: LIST
66963: PPUSH
66964: LD_VAR 0 4
66968: PUSH
66969: LD_VAR 0 2
66973: PUSH
66974: LD_VAR 0 3
66978: PUSH
66979: EMPTY
66980: LIST
66981: LIST
66982: LIST
66983: PPUSH
66984: CALL 75342 0 3
66988: ST_TO_ADDR
// exit ;
66989: POP
66990: POP
66991: POP
66992: POP
66993: GO 67003
// end ;
66995: GO 66902
66997: POP
66998: POP
// end ;
66999: GO 66710
67001: POP
67002: POP
// end ;
67003: LD_VAR 0 6
67007: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
67008: LD_INT 0
67010: PPUSH
67011: PPUSH
67012: PPUSH
67013: PPUSH
// if not mc_bases or not skirmish then
67014: LD_EXP 102
67018: NOT
67019: PUSH
67020: LD_EXP 100
67024: NOT
67025: OR
67026: IFFALSE 67030
// exit ;
67028: GO 67307
// side := GetSide ( lab ) ;
67030: LD_ADDR_VAR 0 4
67034: PUSH
67035: LD_VAR 0 2
67039: PPUSH
67040: CALL_OW 255
67044: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
67045: LD_VAR 0 4
67049: PUSH
67050: LD_EXP 128
67054: IN
67055: NOT
67056: PUSH
67057: LD_EXP 129
67061: NOT
67062: OR
67063: PUSH
67064: LD_EXP 102
67068: NOT
67069: OR
67070: IFFALSE 67074
// exit ;
67072: GO 67307
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
67074: LD_ADDR_EXP 129
67078: PUSH
67079: LD_EXP 129
67083: PPUSH
67084: LD_VAR 0 4
67088: PPUSH
67089: LD_EXP 129
67093: PUSH
67094: LD_VAR 0 4
67098: ARRAY
67099: PUSH
67100: LD_VAR 0 1
67104: DIFF
67105: PPUSH
67106: CALL_OW 1
67110: ST_TO_ADDR
// for i = 1 to mc_bases do
67111: LD_ADDR_VAR 0 5
67115: PUSH
67116: DOUBLE
67117: LD_INT 1
67119: DEC
67120: ST_TO_ADDR
67121: LD_EXP 102
67125: PUSH
67126: FOR_TO
67127: IFFALSE 67305
// begin if lab in mc_bases [ i ] then
67129: LD_VAR 0 2
67133: PUSH
67134: LD_EXP 102
67138: PUSH
67139: LD_VAR 0 5
67143: ARRAY
67144: IN
67145: IFFALSE 67303
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
67147: LD_VAR 0 1
67151: PUSH
67152: LD_INT 11
67154: PUSH
67155: LD_INT 4
67157: PUSH
67158: LD_INT 3
67160: PUSH
67161: LD_INT 2
67163: PUSH
67164: EMPTY
67165: LIST
67166: LIST
67167: LIST
67168: LIST
67169: IN
67170: PUSH
67171: LD_EXP 132
67175: PUSH
67176: LD_VAR 0 5
67180: ARRAY
67181: AND
67182: IFFALSE 67303
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
67184: LD_ADDR_VAR 0 6
67188: PUSH
67189: LD_EXP 132
67193: PUSH
67194: LD_VAR 0 5
67198: ARRAY
67199: PUSH
67200: LD_INT 1
67202: ARRAY
67203: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
67204: LD_ADDR_EXP 132
67208: PUSH
67209: LD_EXP 132
67213: PPUSH
67214: LD_VAR 0 5
67218: PPUSH
67219: EMPTY
67220: PPUSH
67221: CALL_OW 1
67225: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
67226: LD_VAR 0 6
67230: PPUSH
67231: LD_INT 0
67233: PPUSH
67234: CALL_OW 109
// ComExitBuilding ( tmp ) ;
67238: LD_VAR 0 6
67242: PPUSH
67243: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
67247: LD_ADDR_EXP 131
67251: PUSH
67252: LD_EXP 131
67256: PPUSH
67257: LD_VAR 0 5
67261: PPUSH
67262: LD_EXP 131
67266: PUSH
67267: LD_VAR 0 5
67271: ARRAY
67272: PPUSH
67273: LD_INT 1
67275: PPUSH
67276: LD_VAR 0 6
67280: PPUSH
67281: CALL_OW 2
67285: PPUSH
67286: CALL_OW 1
67290: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
67291: LD_VAR 0 5
67295: PPUSH
67296: LD_INT 112
67298: PPUSH
67299: CALL 43757 0 2
// end ; end ; end ;
67303: GO 67126
67305: POP
67306: POP
// end ;
67307: LD_VAR 0 3
67311: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
67312: LD_INT 0
67314: PPUSH
67315: PPUSH
67316: PPUSH
67317: PPUSH
67318: PPUSH
67319: PPUSH
67320: PPUSH
67321: PPUSH
// if not mc_bases or not skirmish then
67322: LD_EXP 102
67326: NOT
67327: PUSH
67328: LD_EXP 100
67332: NOT
67333: OR
67334: IFFALSE 67338
// exit ;
67336: GO 68707
// for i = 1 to mc_bases do
67338: LD_ADDR_VAR 0 3
67342: PUSH
67343: DOUBLE
67344: LD_INT 1
67346: DEC
67347: ST_TO_ADDR
67348: LD_EXP 102
67352: PUSH
67353: FOR_TO
67354: IFFALSE 68705
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
67356: LD_VAR 0 1
67360: PUSH
67361: LD_EXP 102
67365: PUSH
67366: LD_VAR 0 3
67370: ARRAY
67371: IN
67372: PUSH
67373: LD_VAR 0 1
67377: PUSH
67378: LD_EXP 109
67382: PUSH
67383: LD_VAR 0 3
67387: ARRAY
67388: IN
67389: OR
67390: PUSH
67391: LD_VAR 0 1
67395: PUSH
67396: LD_EXP 124
67400: PUSH
67401: LD_VAR 0 3
67405: ARRAY
67406: IN
67407: OR
67408: PUSH
67409: LD_VAR 0 1
67413: PUSH
67414: LD_EXP 121
67418: PUSH
67419: LD_VAR 0 3
67423: ARRAY
67424: IN
67425: OR
67426: PUSH
67427: LD_VAR 0 1
67431: PUSH
67432: LD_EXP 131
67436: PUSH
67437: LD_VAR 0 3
67441: ARRAY
67442: IN
67443: OR
67444: PUSH
67445: LD_VAR 0 1
67449: PUSH
67450: LD_EXP 132
67454: PUSH
67455: LD_VAR 0 3
67459: ARRAY
67460: IN
67461: OR
67462: IFFALSE 68703
// begin if un in mc_ape [ i ] then
67464: LD_VAR 0 1
67468: PUSH
67469: LD_EXP 131
67473: PUSH
67474: LD_VAR 0 3
67478: ARRAY
67479: IN
67480: IFFALSE 67519
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
67482: LD_ADDR_EXP 131
67486: PUSH
67487: LD_EXP 131
67491: PPUSH
67492: LD_VAR 0 3
67496: PPUSH
67497: LD_EXP 131
67501: PUSH
67502: LD_VAR 0 3
67506: ARRAY
67507: PUSH
67508: LD_VAR 0 1
67512: DIFF
67513: PPUSH
67514: CALL_OW 1
67518: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
67519: LD_VAR 0 1
67523: PUSH
67524: LD_EXP 132
67528: PUSH
67529: LD_VAR 0 3
67533: ARRAY
67534: IN
67535: IFFALSE 67559
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
67537: LD_ADDR_EXP 132
67541: PUSH
67542: LD_EXP 132
67546: PPUSH
67547: LD_VAR 0 3
67551: PPUSH
67552: EMPTY
67553: PPUSH
67554: CALL_OW 1
67558: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
67559: LD_VAR 0 1
67563: PPUSH
67564: CALL_OW 247
67568: PUSH
67569: LD_INT 2
67571: EQUAL
67572: PUSH
67573: LD_VAR 0 1
67577: PPUSH
67578: CALL_OW 110
67582: PUSH
67583: LD_INT 20
67585: EQUAL
67586: PUSH
67587: LD_VAR 0 1
67591: PUSH
67592: LD_EXP 124
67596: PUSH
67597: LD_VAR 0 3
67601: ARRAY
67602: IN
67603: OR
67604: PUSH
67605: LD_VAR 0 1
67609: PPUSH
67610: CALL_OW 264
67614: PUSH
67615: LD_INT 12
67617: PUSH
67618: LD_INT 51
67620: PUSH
67621: LD_INT 89
67623: PUSH
67624: LD_INT 32
67626: PUSH
67627: LD_INT 13
67629: PUSH
67630: LD_INT 52
67632: PUSH
67633: LD_INT 31
67635: PUSH
67636: EMPTY
67637: LIST
67638: LIST
67639: LIST
67640: LIST
67641: LIST
67642: LIST
67643: LIST
67644: IN
67645: OR
67646: AND
67647: IFFALSE 67955
// begin if un in mc_defender [ i ] then
67649: LD_VAR 0 1
67653: PUSH
67654: LD_EXP 124
67658: PUSH
67659: LD_VAR 0 3
67663: ARRAY
67664: IN
67665: IFFALSE 67704
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
67667: LD_ADDR_EXP 124
67671: PUSH
67672: LD_EXP 124
67676: PPUSH
67677: LD_VAR 0 3
67681: PPUSH
67682: LD_EXP 124
67686: PUSH
67687: LD_VAR 0 3
67691: ARRAY
67692: PUSH
67693: LD_VAR 0 1
67697: DIFF
67698: PPUSH
67699: CALL_OW 1
67703: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
67704: LD_ADDR_VAR 0 8
67708: PUSH
67709: LD_VAR 0 3
67713: PPUSH
67714: LD_INT 3
67716: PPUSH
67717: CALL 64325 0 2
67721: ST_TO_ADDR
// if fac then
67722: LD_VAR 0 8
67726: IFFALSE 67955
// begin for j in fac do
67728: LD_ADDR_VAR 0 4
67732: PUSH
67733: LD_VAR 0 8
67737: PUSH
67738: FOR_IN
67739: IFFALSE 67953
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
67741: LD_ADDR_VAR 0 9
67745: PUSH
67746: LD_VAR 0 8
67750: PPUSH
67751: LD_VAR 0 1
67755: PPUSH
67756: CALL_OW 265
67760: PPUSH
67761: LD_VAR 0 1
67765: PPUSH
67766: CALL_OW 262
67770: PPUSH
67771: LD_VAR 0 1
67775: PPUSH
67776: CALL_OW 263
67780: PPUSH
67781: LD_VAR 0 1
67785: PPUSH
67786: CALL_OW 264
67790: PPUSH
67791: CALL 72840 0 5
67795: ST_TO_ADDR
// if components then
67796: LD_VAR 0 9
67800: IFFALSE 67951
// begin if GetWeapon ( un ) = ar_control_tower then
67802: LD_VAR 0 1
67806: PPUSH
67807: CALL_OW 264
67811: PUSH
67812: LD_INT 31
67814: EQUAL
67815: IFFALSE 67932
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
67817: LD_VAR 0 1
67821: PPUSH
67822: CALL_OW 311
67826: PPUSH
67827: LD_INT 0
67829: PPUSH
67830: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
67834: LD_ADDR_EXP 142
67838: PUSH
67839: LD_EXP 142
67843: PPUSH
67844: LD_VAR 0 3
67848: PPUSH
67849: LD_EXP 142
67853: PUSH
67854: LD_VAR 0 3
67858: ARRAY
67859: PUSH
67860: LD_VAR 0 1
67864: PPUSH
67865: CALL_OW 311
67869: DIFF
67870: PPUSH
67871: CALL_OW 1
67875: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
67876: LD_ADDR_VAR 0 7
67880: PUSH
67881: LD_EXP 123
67885: PUSH
67886: LD_VAR 0 3
67890: ARRAY
67891: PPUSH
67892: LD_INT 1
67894: PPUSH
67895: LD_VAR 0 9
67899: PPUSH
67900: CALL_OW 2
67904: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
67905: LD_ADDR_EXP 123
67909: PUSH
67910: LD_EXP 123
67914: PPUSH
67915: LD_VAR 0 3
67919: PPUSH
67920: LD_VAR 0 7
67924: PPUSH
67925: CALL_OW 1
67929: ST_TO_ADDR
// end else
67930: GO 67949
// MC_InsertProduceList ( i , [ components ] ) ;
67932: LD_VAR 0 3
67936: PPUSH
67937: LD_VAR 0 9
67941: PUSH
67942: EMPTY
67943: LIST
67944: PPUSH
67945: CALL 63870 0 2
// break ;
67949: GO 67953
// end ; end ;
67951: GO 67738
67953: POP
67954: POP
// end ; end ; if GetType ( un ) = unit_building then
67955: LD_VAR 0 1
67959: PPUSH
67960: CALL_OW 247
67964: PUSH
67965: LD_INT 3
67967: EQUAL
67968: IFFALSE 68371
// begin btype := GetBType ( un ) ;
67970: LD_ADDR_VAR 0 5
67974: PUSH
67975: LD_VAR 0 1
67979: PPUSH
67980: CALL_OW 266
67984: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
67985: LD_VAR 0 5
67989: PUSH
67990: LD_INT 29
67992: PUSH
67993: LD_INT 30
67995: PUSH
67996: EMPTY
67997: LIST
67998: LIST
67999: IN
68000: IFFALSE 68073
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
68002: LD_VAR 0 1
68006: PPUSH
68007: CALL_OW 250
68011: PPUSH
68012: LD_VAR 0 1
68016: PPUSH
68017: CALL_OW 251
68021: PPUSH
68022: LD_VAR 0 1
68026: PPUSH
68027: CALL_OW 255
68031: PPUSH
68032: CALL_OW 440
68036: NOT
68037: IFFALSE 68073
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
68039: LD_VAR 0 1
68043: PPUSH
68044: CALL_OW 250
68048: PPUSH
68049: LD_VAR 0 1
68053: PPUSH
68054: CALL_OW 251
68058: PPUSH
68059: LD_VAR 0 1
68063: PPUSH
68064: CALL_OW 255
68068: PPUSH
68069: CALL_OW 441
// end ; if btype = b_warehouse then
68073: LD_VAR 0 5
68077: PUSH
68078: LD_INT 1
68080: EQUAL
68081: IFFALSE 68099
// begin btype := b_depot ;
68083: LD_ADDR_VAR 0 5
68087: PUSH
68088: LD_INT 0
68090: ST_TO_ADDR
// pos := 1 ;
68091: LD_ADDR_VAR 0 6
68095: PUSH
68096: LD_INT 1
68098: ST_TO_ADDR
// end ; if btype = b_factory then
68099: LD_VAR 0 5
68103: PUSH
68104: LD_INT 3
68106: EQUAL
68107: IFFALSE 68125
// begin btype := b_workshop ;
68109: LD_ADDR_VAR 0 5
68113: PUSH
68114: LD_INT 2
68116: ST_TO_ADDR
// pos := 1 ;
68117: LD_ADDR_VAR 0 6
68121: PUSH
68122: LD_INT 1
68124: ST_TO_ADDR
// end ; if btype = b_barracks then
68125: LD_VAR 0 5
68129: PUSH
68130: LD_INT 5
68132: EQUAL
68133: IFFALSE 68143
// btype := b_armoury ;
68135: LD_ADDR_VAR 0 5
68139: PUSH
68140: LD_INT 4
68142: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
68143: LD_VAR 0 5
68147: PUSH
68148: LD_INT 7
68150: PUSH
68151: LD_INT 8
68153: PUSH
68154: EMPTY
68155: LIST
68156: LIST
68157: IN
68158: IFFALSE 68168
// btype := b_lab ;
68160: LD_ADDR_VAR 0 5
68164: PUSH
68165: LD_INT 6
68167: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
68168: LD_ADDR_EXP 107
68172: PUSH
68173: LD_EXP 107
68177: PPUSH
68178: LD_VAR 0 3
68182: PUSH
68183: LD_EXP 107
68187: PUSH
68188: LD_VAR 0 3
68192: ARRAY
68193: PUSH
68194: LD_INT 1
68196: PLUS
68197: PUSH
68198: EMPTY
68199: LIST
68200: LIST
68201: PPUSH
68202: LD_VAR 0 5
68206: PUSH
68207: LD_VAR 0 1
68211: PPUSH
68212: CALL_OW 250
68216: PUSH
68217: LD_VAR 0 1
68221: PPUSH
68222: CALL_OW 251
68226: PUSH
68227: LD_VAR 0 1
68231: PPUSH
68232: CALL_OW 254
68236: PUSH
68237: EMPTY
68238: LIST
68239: LIST
68240: LIST
68241: LIST
68242: PPUSH
68243: CALL 75342 0 3
68247: ST_TO_ADDR
// if pos = 1 then
68248: LD_VAR 0 6
68252: PUSH
68253: LD_INT 1
68255: EQUAL
68256: IFFALSE 68371
// begin tmp := mc_build_list [ i ] ;
68258: LD_ADDR_VAR 0 7
68262: PUSH
68263: LD_EXP 107
68267: PUSH
68268: LD_VAR 0 3
68272: ARRAY
68273: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
68274: LD_VAR 0 7
68278: PPUSH
68279: LD_INT 2
68281: PUSH
68282: LD_INT 30
68284: PUSH
68285: LD_INT 0
68287: PUSH
68288: EMPTY
68289: LIST
68290: LIST
68291: PUSH
68292: LD_INT 30
68294: PUSH
68295: LD_INT 1
68297: PUSH
68298: EMPTY
68299: LIST
68300: LIST
68301: PUSH
68302: EMPTY
68303: LIST
68304: LIST
68305: LIST
68306: PPUSH
68307: CALL_OW 72
68311: IFFALSE 68321
// pos := 2 ;
68313: LD_ADDR_VAR 0 6
68317: PUSH
68318: LD_INT 2
68320: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
68321: LD_ADDR_VAR 0 7
68325: PUSH
68326: LD_VAR 0 7
68330: PPUSH
68331: LD_VAR 0 6
68335: PPUSH
68336: LD_VAR 0 7
68340: PPUSH
68341: CALL 75668 0 3
68345: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
68346: LD_ADDR_EXP 107
68350: PUSH
68351: LD_EXP 107
68355: PPUSH
68356: LD_VAR 0 3
68360: PPUSH
68361: LD_VAR 0 7
68365: PPUSH
68366: CALL_OW 1
68370: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
68371: LD_VAR 0 1
68375: PUSH
68376: LD_EXP 102
68380: PUSH
68381: LD_VAR 0 3
68385: ARRAY
68386: IN
68387: IFFALSE 68426
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
68389: LD_ADDR_EXP 102
68393: PUSH
68394: LD_EXP 102
68398: PPUSH
68399: LD_VAR 0 3
68403: PPUSH
68404: LD_EXP 102
68408: PUSH
68409: LD_VAR 0 3
68413: ARRAY
68414: PUSH
68415: LD_VAR 0 1
68419: DIFF
68420: PPUSH
68421: CALL_OW 1
68425: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
68426: LD_VAR 0 1
68430: PUSH
68431: LD_EXP 109
68435: PUSH
68436: LD_VAR 0 3
68440: ARRAY
68441: IN
68442: IFFALSE 68481
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
68444: LD_ADDR_EXP 109
68448: PUSH
68449: LD_EXP 109
68453: PPUSH
68454: LD_VAR 0 3
68458: PPUSH
68459: LD_EXP 109
68463: PUSH
68464: LD_VAR 0 3
68468: ARRAY
68469: PUSH
68470: LD_VAR 0 1
68474: DIFF
68475: PPUSH
68476: CALL_OW 1
68480: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
68481: LD_VAR 0 1
68485: PUSH
68486: LD_EXP 121
68490: PUSH
68491: LD_VAR 0 3
68495: ARRAY
68496: IN
68497: IFFALSE 68536
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
68499: LD_ADDR_EXP 121
68503: PUSH
68504: LD_EXP 121
68508: PPUSH
68509: LD_VAR 0 3
68513: PPUSH
68514: LD_EXP 121
68518: PUSH
68519: LD_VAR 0 3
68523: ARRAY
68524: PUSH
68525: LD_VAR 0 1
68529: DIFF
68530: PPUSH
68531: CALL_OW 1
68535: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
68536: LD_VAR 0 1
68540: PUSH
68541: LD_EXP 124
68545: PUSH
68546: LD_VAR 0 3
68550: ARRAY
68551: IN
68552: IFFALSE 68591
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
68554: LD_ADDR_EXP 124
68558: PUSH
68559: LD_EXP 124
68563: PPUSH
68564: LD_VAR 0 3
68568: PPUSH
68569: LD_EXP 124
68573: PUSH
68574: LD_VAR 0 3
68578: ARRAY
68579: PUSH
68580: LD_VAR 0 1
68584: DIFF
68585: PPUSH
68586: CALL_OW 1
68590: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
68591: LD_VAR 0 1
68595: PUSH
68596: LD_EXP 111
68600: PUSH
68601: LD_VAR 0 3
68605: ARRAY
68606: IN
68607: IFFALSE 68646
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
68609: LD_ADDR_EXP 111
68613: PUSH
68614: LD_EXP 111
68618: PPUSH
68619: LD_VAR 0 3
68623: PPUSH
68624: LD_EXP 111
68628: PUSH
68629: LD_VAR 0 3
68633: ARRAY
68634: PUSH
68635: LD_VAR 0 1
68639: DIFF
68640: PPUSH
68641: CALL_OW 1
68645: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
68646: LD_VAR 0 1
68650: PUSH
68651: LD_EXP 110
68655: PUSH
68656: LD_VAR 0 3
68660: ARRAY
68661: IN
68662: IFFALSE 68701
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
68664: LD_ADDR_EXP 110
68668: PUSH
68669: LD_EXP 110
68673: PPUSH
68674: LD_VAR 0 3
68678: PPUSH
68679: LD_EXP 110
68683: PUSH
68684: LD_VAR 0 3
68688: ARRAY
68689: PUSH
68690: LD_VAR 0 1
68694: DIFF
68695: PPUSH
68696: CALL_OW 1
68700: ST_TO_ADDR
// end ; break ;
68701: GO 68705
// end ;
68703: GO 67353
68705: POP
68706: POP
// end ;
68707: LD_VAR 0 2
68711: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
68712: LD_INT 0
68714: PPUSH
68715: PPUSH
68716: PPUSH
// if not mc_bases or not skirmish then
68717: LD_EXP 102
68721: NOT
68722: PUSH
68723: LD_EXP 100
68727: NOT
68728: OR
68729: IFFALSE 68733
// exit ;
68731: GO 68948
// for i = 1 to mc_bases do
68733: LD_ADDR_VAR 0 3
68737: PUSH
68738: DOUBLE
68739: LD_INT 1
68741: DEC
68742: ST_TO_ADDR
68743: LD_EXP 102
68747: PUSH
68748: FOR_TO
68749: IFFALSE 68946
// begin if building in mc_construct_list [ i ] then
68751: LD_VAR 0 1
68755: PUSH
68756: LD_EXP 109
68760: PUSH
68761: LD_VAR 0 3
68765: ARRAY
68766: IN
68767: IFFALSE 68944
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
68769: LD_ADDR_EXP 109
68773: PUSH
68774: LD_EXP 109
68778: PPUSH
68779: LD_VAR 0 3
68783: PPUSH
68784: LD_EXP 109
68788: PUSH
68789: LD_VAR 0 3
68793: ARRAY
68794: PUSH
68795: LD_VAR 0 1
68799: DIFF
68800: PPUSH
68801: CALL_OW 1
68805: ST_TO_ADDR
// if building in mc_lab [ i ] then
68806: LD_VAR 0 1
68810: PUSH
68811: LD_EXP 135
68815: PUSH
68816: LD_VAR 0 3
68820: ARRAY
68821: IN
68822: IFFALSE 68877
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
68824: LD_ADDR_EXP 136
68828: PUSH
68829: LD_EXP 136
68833: PPUSH
68834: LD_VAR 0 3
68838: PPUSH
68839: LD_EXP 136
68843: PUSH
68844: LD_VAR 0 3
68848: ARRAY
68849: PPUSH
68850: LD_INT 1
68852: PPUSH
68853: LD_EXP 136
68857: PUSH
68858: LD_VAR 0 3
68862: ARRAY
68863: PPUSH
68864: LD_INT 0
68866: PPUSH
68867: CALL 74760 0 4
68871: PPUSH
68872: CALL_OW 1
68876: ST_TO_ADDR
// if not building in mc_bases [ i ] then
68877: LD_VAR 0 1
68881: PUSH
68882: LD_EXP 102
68886: PUSH
68887: LD_VAR 0 3
68891: ARRAY
68892: IN
68893: NOT
68894: IFFALSE 68940
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
68896: LD_ADDR_EXP 102
68900: PUSH
68901: LD_EXP 102
68905: PPUSH
68906: LD_VAR 0 3
68910: PUSH
68911: LD_EXP 102
68915: PUSH
68916: LD_VAR 0 3
68920: ARRAY
68921: PUSH
68922: LD_INT 1
68924: PLUS
68925: PUSH
68926: EMPTY
68927: LIST
68928: LIST
68929: PPUSH
68930: LD_VAR 0 1
68934: PPUSH
68935: CALL 75342 0 3
68939: ST_TO_ADDR
// exit ;
68940: POP
68941: POP
68942: GO 68948
// end ; end ;
68944: GO 68748
68946: POP
68947: POP
// end ;
68948: LD_VAR 0 2
68952: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
68953: LD_INT 0
68955: PPUSH
68956: PPUSH
68957: PPUSH
68958: PPUSH
68959: PPUSH
68960: PPUSH
68961: PPUSH
// if not mc_bases or not skirmish then
68962: LD_EXP 102
68966: NOT
68967: PUSH
68968: LD_EXP 100
68972: NOT
68973: OR
68974: IFFALSE 68978
// exit ;
68976: GO 69639
// for i = 1 to mc_bases do
68978: LD_ADDR_VAR 0 3
68982: PUSH
68983: DOUBLE
68984: LD_INT 1
68986: DEC
68987: ST_TO_ADDR
68988: LD_EXP 102
68992: PUSH
68993: FOR_TO
68994: IFFALSE 69637
// begin if building in mc_construct_list [ i ] then
68996: LD_VAR 0 1
69000: PUSH
69001: LD_EXP 109
69005: PUSH
69006: LD_VAR 0 3
69010: ARRAY
69011: IN
69012: IFFALSE 69635
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
69014: LD_ADDR_EXP 109
69018: PUSH
69019: LD_EXP 109
69023: PPUSH
69024: LD_VAR 0 3
69028: PPUSH
69029: LD_EXP 109
69033: PUSH
69034: LD_VAR 0 3
69038: ARRAY
69039: PUSH
69040: LD_VAR 0 1
69044: DIFF
69045: PPUSH
69046: CALL_OW 1
69050: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
69051: LD_ADDR_EXP 102
69055: PUSH
69056: LD_EXP 102
69060: PPUSH
69061: LD_VAR 0 3
69065: PUSH
69066: LD_EXP 102
69070: PUSH
69071: LD_VAR 0 3
69075: ARRAY
69076: PUSH
69077: LD_INT 1
69079: PLUS
69080: PUSH
69081: EMPTY
69082: LIST
69083: LIST
69084: PPUSH
69085: LD_VAR 0 1
69089: PPUSH
69090: CALL 75342 0 3
69094: ST_TO_ADDR
// btype := GetBType ( building ) ;
69095: LD_ADDR_VAR 0 5
69099: PUSH
69100: LD_VAR 0 1
69104: PPUSH
69105: CALL_OW 266
69109: ST_TO_ADDR
// side := GetSide ( building ) ;
69110: LD_ADDR_VAR 0 8
69114: PUSH
69115: LD_VAR 0 1
69119: PPUSH
69120: CALL_OW 255
69124: ST_TO_ADDR
// if btype = b_lab then
69125: LD_VAR 0 5
69129: PUSH
69130: LD_INT 6
69132: EQUAL
69133: IFFALSE 69183
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
69135: LD_ADDR_EXP 135
69139: PUSH
69140: LD_EXP 135
69144: PPUSH
69145: LD_VAR 0 3
69149: PUSH
69150: LD_EXP 135
69154: PUSH
69155: LD_VAR 0 3
69159: ARRAY
69160: PUSH
69161: LD_INT 1
69163: PLUS
69164: PUSH
69165: EMPTY
69166: LIST
69167: LIST
69168: PPUSH
69169: LD_VAR 0 1
69173: PPUSH
69174: CALL 75342 0 3
69178: ST_TO_ADDR
// exit ;
69179: POP
69180: POP
69181: GO 69639
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
69183: LD_VAR 0 5
69187: PUSH
69188: LD_INT 0
69190: PUSH
69191: LD_INT 2
69193: PUSH
69194: LD_INT 4
69196: PUSH
69197: EMPTY
69198: LIST
69199: LIST
69200: LIST
69201: IN
69202: IFFALSE 69326
// begin if btype = b_armoury then
69204: LD_VAR 0 5
69208: PUSH
69209: LD_INT 4
69211: EQUAL
69212: IFFALSE 69222
// btype := b_barracks ;
69214: LD_ADDR_VAR 0 5
69218: PUSH
69219: LD_INT 5
69221: ST_TO_ADDR
// if btype = b_depot then
69222: LD_VAR 0 5
69226: PUSH
69227: LD_INT 0
69229: EQUAL
69230: IFFALSE 69240
// btype := b_warehouse ;
69232: LD_ADDR_VAR 0 5
69236: PUSH
69237: LD_INT 1
69239: ST_TO_ADDR
// if btype = b_workshop then
69240: LD_VAR 0 5
69244: PUSH
69245: LD_INT 2
69247: EQUAL
69248: IFFALSE 69258
// btype := b_factory ;
69250: LD_ADDR_VAR 0 5
69254: PUSH
69255: LD_INT 3
69257: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
69258: LD_VAR 0 5
69262: PPUSH
69263: LD_VAR 0 8
69267: PPUSH
69268: CALL_OW 323
69272: PUSH
69273: LD_INT 1
69275: EQUAL
69276: IFFALSE 69322
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
69278: LD_ADDR_EXP 134
69282: PUSH
69283: LD_EXP 134
69287: PPUSH
69288: LD_VAR 0 3
69292: PUSH
69293: LD_EXP 134
69297: PUSH
69298: LD_VAR 0 3
69302: ARRAY
69303: PUSH
69304: LD_INT 1
69306: PLUS
69307: PUSH
69308: EMPTY
69309: LIST
69310: LIST
69311: PPUSH
69312: LD_VAR 0 1
69316: PPUSH
69317: CALL 75342 0 3
69321: ST_TO_ADDR
// exit ;
69322: POP
69323: POP
69324: GO 69639
// end ; if btype in [ b_bunker , b_turret ] then
69326: LD_VAR 0 5
69330: PUSH
69331: LD_INT 32
69333: PUSH
69334: LD_INT 33
69336: PUSH
69337: EMPTY
69338: LIST
69339: LIST
69340: IN
69341: IFFALSE 69631
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
69343: LD_ADDR_EXP 110
69347: PUSH
69348: LD_EXP 110
69352: PPUSH
69353: LD_VAR 0 3
69357: PUSH
69358: LD_EXP 110
69362: PUSH
69363: LD_VAR 0 3
69367: ARRAY
69368: PUSH
69369: LD_INT 1
69371: PLUS
69372: PUSH
69373: EMPTY
69374: LIST
69375: LIST
69376: PPUSH
69377: LD_VAR 0 1
69381: PPUSH
69382: CALL 75342 0 3
69386: ST_TO_ADDR
// if btype = b_bunker then
69387: LD_VAR 0 5
69391: PUSH
69392: LD_INT 32
69394: EQUAL
69395: IFFALSE 69631
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
69397: LD_ADDR_EXP 111
69401: PUSH
69402: LD_EXP 111
69406: PPUSH
69407: LD_VAR 0 3
69411: PUSH
69412: LD_EXP 111
69416: PUSH
69417: LD_VAR 0 3
69421: ARRAY
69422: PUSH
69423: LD_INT 1
69425: PLUS
69426: PUSH
69427: EMPTY
69428: LIST
69429: LIST
69430: PPUSH
69431: LD_VAR 0 1
69435: PPUSH
69436: CALL 75342 0 3
69440: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
69441: LD_ADDR_VAR 0 6
69445: PUSH
69446: LD_EXP 102
69450: PUSH
69451: LD_VAR 0 3
69455: ARRAY
69456: PPUSH
69457: LD_INT 25
69459: PUSH
69460: LD_INT 1
69462: PUSH
69463: EMPTY
69464: LIST
69465: LIST
69466: PUSH
69467: LD_INT 3
69469: PUSH
69470: LD_INT 54
69472: PUSH
69473: EMPTY
69474: LIST
69475: PUSH
69476: EMPTY
69477: LIST
69478: LIST
69479: PUSH
69480: EMPTY
69481: LIST
69482: LIST
69483: PPUSH
69484: CALL_OW 72
69488: ST_TO_ADDR
// if tmp then
69489: LD_VAR 0 6
69493: IFFALSE 69499
// exit ;
69495: POP
69496: POP
69497: GO 69639
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
69499: LD_ADDR_VAR 0 6
69503: PUSH
69504: LD_EXP 102
69508: PUSH
69509: LD_VAR 0 3
69513: ARRAY
69514: PPUSH
69515: LD_INT 2
69517: PUSH
69518: LD_INT 30
69520: PUSH
69521: LD_INT 4
69523: PUSH
69524: EMPTY
69525: LIST
69526: LIST
69527: PUSH
69528: LD_INT 30
69530: PUSH
69531: LD_INT 5
69533: PUSH
69534: EMPTY
69535: LIST
69536: LIST
69537: PUSH
69538: EMPTY
69539: LIST
69540: LIST
69541: LIST
69542: PPUSH
69543: CALL_OW 72
69547: ST_TO_ADDR
// if not tmp then
69548: LD_VAR 0 6
69552: NOT
69553: IFFALSE 69559
// exit ;
69555: POP
69556: POP
69557: GO 69639
// for j in tmp do
69559: LD_ADDR_VAR 0 4
69563: PUSH
69564: LD_VAR 0 6
69568: PUSH
69569: FOR_IN
69570: IFFALSE 69629
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
69572: LD_ADDR_VAR 0 7
69576: PUSH
69577: LD_VAR 0 4
69581: PPUSH
69582: CALL_OW 313
69586: PPUSH
69587: LD_INT 25
69589: PUSH
69590: LD_INT 1
69592: PUSH
69593: EMPTY
69594: LIST
69595: LIST
69596: PPUSH
69597: CALL_OW 72
69601: ST_TO_ADDR
// if units then
69602: LD_VAR 0 7
69606: IFFALSE 69627
// begin ComExitBuilding ( units [ 1 ] ) ;
69608: LD_VAR 0 7
69612: PUSH
69613: LD_INT 1
69615: ARRAY
69616: PPUSH
69617: CALL_OW 122
// exit ;
69621: POP
69622: POP
69623: POP
69624: POP
69625: GO 69639
// end ; end ;
69627: GO 69569
69629: POP
69630: POP
// end ; end ; exit ;
69631: POP
69632: POP
69633: GO 69639
// end ; end ;
69635: GO 68993
69637: POP
69638: POP
// end ;
69639: LD_VAR 0 2
69643: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
69644: LD_INT 0
69646: PPUSH
69647: PPUSH
69648: PPUSH
69649: PPUSH
69650: PPUSH
69651: PPUSH
69652: PPUSH
// if not mc_bases or not skirmish then
69653: LD_EXP 102
69657: NOT
69658: PUSH
69659: LD_EXP 100
69663: NOT
69664: OR
69665: IFFALSE 69669
// exit ;
69667: GO 69934
// btype := GetBType ( building ) ;
69669: LD_ADDR_VAR 0 6
69673: PUSH
69674: LD_VAR 0 1
69678: PPUSH
69679: CALL_OW 266
69683: ST_TO_ADDR
// x := GetX ( building ) ;
69684: LD_ADDR_VAR 0 7
69688: PUSH
69689: LD_VAR 0 1
69693: PPUSH
69694: CALL_OW 250
69698: ST_TO_ADDR
// y := GetY ( building ) ;
69699: LD_ADDR_VAR 0 8
69703: PUSH
69704: LD_VAR 0 1
69708: PPUSH
69709: CALL_OW 251
69713: ST_TO_ADDR
// d := GetDir ( building ) ;
69714: LD_ADDR_VAR 0 9
69718: PUSH
69719: LD_VAR 0 1
69723: PPUSH
69724: CALL_OW 254
69728: ST_TO_ADDR
// for i = 1 to mc_bases do
69729: LD_ADDR_VAR 0 4
69733: PUSH
69734: DOUBLE
69735: LD_INT 1
69737: DEC
69738: ST_TO_ADDR
69739: LD_EXP 102
69743: PUSH
69744: FOR_TO
69745: IFFALSE 69932
// begin if not mc_build_list [ i ] then
69747: LD_EXP 107
69751: PUSH
69752: LD_VAR 0 4
69756: ARRAY
69757: NOT
69758: IFFALSE 69762
// continue ;
69760: GO 69744
// for j := 1 to mc_build_list [ i ] do
69762: LD_ADDR_VAR 0 5
69766: PUSH
69767: DOUBLE
69768: LD_INT 1
69770: DEC
69771: ST_TO_ADDR
69772: LD_EXP 107
69776: PUSH
69777: LD_VAR 0 4
69781: ARRAY
69782: PUSH
69783: FOR_TO
69784: IFFALSE 69928
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
69786: LD_VAR 0 6
69790: PUSH
69791: LD_VAR 0 7
69795: PUSH
69796: LD_VAR 0 8
69800: PUSH
69801: LD_VAR 0 9
69805: PUSH
69806: EMPTY
69807: LIST
69808: LIST
69809: LIST
69810: LIST
69811: PPUSH
69812: LD_EXP 107
69816: PUSH
69817: LD_VAR 0 4
69821: ARRAY
69822: PUSH
69823: LD_VAR 0 5
69827: ARRAY
69828: PPUSH
69829: CALL 81899 0 2
69833: IFFALSE 69926
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
69835: LD_ADDR_EXP 107
69839: PUSH
69840: LD_EXP 107
69844: PPUSH
69845: LD_VAR 0 4
69849: PPUSH
69850: LD_EXP 107
69854: PUSH
69855: LD_VAR 0 4
69859: ARRAY
69860: PPUSH
69861: LD_VAR 0 5
69865: PPUSH
69866: CALL_OW 3
69870: PPUSH
69871: CALL_OW 1
69875: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
69876: LD_ADDR_EXP 109
69880: PUSH
69881: LD_EXP 109
69885: PPUSH
69886: LD_VAR 0 4
69890: PUSH
69891: LD_EXP 109
69895: PUSH
69896: LD_VAR 0 4
69900: ARRAY
69901: PUSH
69902: LD_INT 1
69904: PLUS
69905: PUSH
69906: EMPTY
69907: LIST
69908: LIST
69909: PPUSH
69910: LD_VAR 0 1
69914: PPUSH
69915: CALL 75342 0 3
69919: ST_TO_ADDR
// exit ;
69920: POP
69921: POP
69922: POP
69923: POP
69924: GO 69934
// end ;
69926: GO 69783
69928: POP
69929: POP
// end ;
69930: GO 69744
69932: POP
69933: POP
// end ;
69934: LD_VAR 0 3
69938: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
69939: LD_INT 0
69941: PPUSH
69942: PPUSH
69943: PPUSH
// if not mc_bases or not skirmish then
69944: LD_EXP 102
69948: NOT
69949: PUSH
69950: LD_EXP 100
69954: NOT
69955: OR
69956: IFFALSE 69960
// exit ;
69958: GO 70150
// for i = 1 to mc_bases do
69960: LD_ADDR_VAR 0 4
69964: PUSH
69965: DOUBLE
69966: LD_INT 1
69968: DEC
69969: ST_TO_ADDR
69970: LD_EXP 102
69974: PUSH
69975: FOR_TO
69976: IFFALSE 70063
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
69978: LD_VAR 0 1
69982: PUSH
69983: LD_EXP 110
69987: PUSH
69988: LD_VAR 0 4
69992: ARRAY
69993: IN
69994: PUSH
69995: LD_VAR 0 1
69999: PUSH
70000: LD_EXP 111
70004: PUSH
70005: LD_VAR 0 4
70009: ARRAY
70010: IN
70011: NOT
70012: AND
70013: IFFALSE 70061
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
70015: LD_ADDR_EXP 111
70019: PUSH
70020: LD_EXP 111
70024: PPUSH
70025: LD_VAR 0 4
70029: PUSH
70030: LD_EXP 111
70034: PUSH
70035: LD_VAR 0 4
70039: ARRAY
70040: PUSH
70041: LD_INT 1
70043: PLUS
70044: PUSH
70045: EMPTY
70046: LIST
70047: LIST
70048: PPUSH
70049: LD_VAR 0 1
70053: PPUSH
70054: CALL 75342 0 3
70058: ST_TO_ADDR
// break ;
70059: GO 70063
// end ; end ;
70061: GO 69975
70063: POP
70064: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
70065: LD_VAR 0 1
70069: PPUSH
70070: CALL_OW 257
70074: PUSH
70075: LD_EXP 128
70079: IN
70080: PUSH
70081: LD_VAR 0 1
70085: PPUSH
70086: CALL_OW 266
70090: PUSH
70091: LD_INT 5
70093: EQUAL
70094: AND
70095: PUSH
70096: LD_VAR 0 2
70100: PPUSH
70101: CALL_OW 110
70105: PUSH
70106: LD_INT 18
70108: NONEQUAL
70109: AND
70110: IFFALSE 70150
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
70112: LD_VAR 0 2
70116: PPUSH
70117: CALL_OW 257
70121: PUSH
70122: LD_INT 5
70124: PUSH
70125: LD_INT 8
70127: PUSH
70128: LD_INT 9
70130: PUSH
70131: EMPTY
70132: LIST
70133: LIST
70134: LIST
70135: IN
70136: IFFALSE 70150
// SetClass ( unit , 1 ) ;
70138: LD_VAR 0 2
70142: PPUSH
70143: LD_INT 1
70145: PPUSH
70146: CALL_OW 336
// end ;
70150: LD_VAR 0 3
70154: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
70155: LD_INT 0
70157: PPUSH
70158: PPUSH
// if not mc_bases or not skirmish then
70159: LD_EXP 102
70163: NOT
70164: PUSH
70165: LD_EXP 100
70169: NOT
70170: OR
70171: IFFALSE 70175
// exit ;
70173: GO 70291
// if GetLives ( abandoned_vehicle ) > 250 then
70175: LD_VAR 0 2
70179: PPUSH
70180: CALL_OW 256
70184: PUSH
70185: LD_INT 250
70187: GREATER
70188: IFFALSE 70192
// exit ;
70190: GO 70291
// for i = 1 to mc_bases do
70192: LD_ADDR_VAR 0 6
70196: PUSH
70197: DOUBLE
70198: LD_INT 1
70200: DEC
70201: ST_TO_ADDR
70202: LD_EXP 102
70206: PUSH
70207: FOR_TO
70208: IFFALSE 70289
// begin if driver in mc_bases [ i ] then
70210: LD_VAR 0 1
70214: PUSH
70215: LD_EXP 102
70219: PUSH
70220: LD_VAR 0 6
70224: ARRAY
70225: IN
70226: IFFALSE 70287
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
70228: LD_VAR 0 1
70232: PPUSH
70233: LD_EXP 102
70237: PUSH
70238: LD_VAR 0 6
70242: ARRAY
70243: PPUSH
70244: LD_INT 2
70246: PUSH
70247: LD_INT 30
70249: PUSH
70250: LD_INT 0
70252: PUSH
70253: EMPTY
70254: LIST
70255: LIST
70256: PUSH
70257: LD_INT 30
70259: PUSH
70260: LD_INT 1
70262: PUSH
70263: EMPTY
70264: LIST
70265: LIST
70266: PUSH
70267: EMPTY
70268: LIST
70269: LIST
70270: LIST
70271: PPUSH
70272: CALL_OW 72
70276: PUSH
70277: LD_INT 1
70279: ARRAY
70280: PPUSH
70281: CALL 108968 0 2
// break ;
70285: GO 70289
// end ; end ;
70287: GO 70207
70289: POP
70290: POP
// end ; end_of_file
70291: LD_VAR 0 5
70295: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
70296: LD_INT 0
70298: PPUSH
70299: PPUSH
// if exist_mode then
70300: LD_VAR 0 2
70304: IFFALSE 70350
// begin unit := CreateCharacter ( prefix & ident ) ;
70306: LD_ADDR_VAR 0 5
70310: PUSH
70311: LD_VAR 0 3
70315: PUSH
70316: LD_VAR 0 1
70320: STR
70321: PPUSH
70322: CALL_OW 34
70326: ST_TO_ADDR
// if unit then
70327: LD_VAR 0 5
70331: IFFALSE 70348
// DeleteCharacters ( prefix & ident ) ;
70333: LD_VAR 0 3
70337: PUSH
70338: LD_VAR 0 1
70342: STR
70343: PPUSH
70344: CALL_OW 40
// end else
70348: GO 70365
// unit := NewCharacter ( ident ) ;
70350: LD_ADDR_VAR 0 5
70354: PUSH
70355: LD_VAR 0 1
70359: PPUSH
70360: CALL_OW 25
70364: ST_TO_ADDR
// result := unit ;
70365: LD_ADDR_VAR 0 4
70369: PUSH
70370: LD_VAR 0 5
70374: ST_TO_ADDR
// end ;
70375: LD_VAR 0 4
70379: RET
// export function PrepareUnitForce ( ident , exist_mode , prefix ) ; var unit ; begin
70380: LD_INT 0
70382: PPUSH
70383: PPUSH
// if exist_mode then
70384: LD_VAR 0 2
70388: IFFALSE 70413
// unit := CreateCharacter ( prefix & ident ) else
70390: LD_ADDR_VAR 0 5
70394: PUSH
70395: LD_VAR 0 3
70399: PUSH
70400: LD_VAR 0 1
70404: STR
70405: PPUSH
70406: CALL_OW 34
70410: ST_TO_ADDR
70411: GO 70428
// unit := NewCharacter ( ident ) ;
70413: LD_ADDR_VAR 0 5
70417: PUSH
70418: LD_VAR 0 1
70422: PPUSH
70423: CALL_OW 25
70427: ST_TO_ADDR
// result := unit ;
70428: LD_ADDR_VAR 0 4
70432: PUSH
70433: LD_VAR 0 5
70437: ST_TO_ADDR
// end ;
70438: LD_VAR 0 4
70442: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
70443: LD_INT 0
70445: PPUSH
70446: PPUSH
// if not side or not nation then
70447: LD_VAR 0 1
70451: NOT
70452: PUSH
70453: LD_VAR 0 2
70457: NOT
70458: OR
70459: IFFALSE 70463
// exit ;
70461: GO 71231
// case nation of nation_american :
70463: LD_VAR 0 2
70467: PUSH
70468: LD_INT 1
70470: DOUBLE
70471: EQUAL
70472: IFTRUE 70476
70474: GO 70690
70476: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
70477: LD_ADDR_VAR 0 4
70481: PUSH
70482: LD_INT 35
70484: PUSH
70485: LD_INT 45
70487: PUSH
70488: LD_INT 46
70490: PUSH
70491: LD_INT 47
70493: PUSH
70494: LD_INT 82
70496: PUSH
70497: LD_INT 83
70499: PUSH
70500: LD_INT 84
70502: PUSH
70503: LD_INT 85
70505: PUSH
70506: LD_INT 86
70508: PUSH
70509: LD_INT 1
70511: PUSH
70512: LD_INT 2
70514: PUSH
70515: LD_INT 6
70517: PUSH
70518: LD_INT 15
70520: PUSH
70521: LD_INT 16
70523: PUSH
70524: LD_INT 7
70526: PUSH
70527: LD_INT 12
70529: PUSH
70530: LD_INT 13
70532: PUSH
70533: LD_INT 10
70535: PUSH
70536: LD_INT 14
70538: PUSH
70539: LD_INT 20
70541: PUSH
70542: LD_INT 21
70544: PUSH
70545: LD_INT 22
70547: PUSH
70548: LD_INT 25
70550: PUSH
70551: LD_INT 32
70553: PUSH
70554: LD_INT 27
70556: PUSH
70557: LD_INT 36
70559: PUSH
70560: LD_INT 69
70562: PUSH
70563: LD_INT 39
70565: PUSH
70566: LD_INT 34
70568: PUSH
70569: LD_INT 40
70571: PUSH
70572: LD_INT 48
70574: PUSH
70575: LD_INT 49
70577: PUSH
70578: LD_INT 50
70580: PUSH
70581: LD_INT 51
70583: PUSH
70584: LD_INT 52
70586: PUSH
70587: LD_INT 53
70589: PUSH
70590: LD_INT 54
70592: PUSH
70593: LD_INT 55
70595: PUSH
70596: LD_INT 56
70598: PUSH
70599: LD_INT 57
70601: PUSH
70602: LD_INT 58
70604: PUSH
70605: LD_INT 59
70607: PUSH
70608: LD_INT 60
70610: PUSH
70611: LD_INT 61
70613: PUSH
70614: LD_INT 62
70616: PUSH
70617: LD_INT 80
70619: PUSH
70620: LD_INT 82
70622: PUSH
70623: LD_INT 83
70625: PUSH
70626: LD_INT 84
70628: PUSH
70629: LD_INT 85
70631: PUSH
70632: LD_INT 86
70634: PUSH
70635: EMPTY
70636: LIST
70637: LIST
70638: LIST
70639: LIST
70640: LIST
70641: LIST
70642: LIST
70643: LIST
70644: LIST
70645: LIST
70646: LIST
70647: LIST
70648: LIST
70649: LIST
70650: LIST
70651: LIST
70652: LIST
70653: LIST
70654: LIST
70655: LIST
70656: LIST
70657: LIST
70658: LIST
70659: LIST
70660: LIST
70661: LIST
70662: LIST
70663: LIST
70664: LIST
70665: LIST
70666: LIST
70667: LIST
70668: LIST
70669: LIST
70670: LIST
70671: LIST
70672: LIST
70673: LIST
70674: LIST
70675: LIST
70676: LIST
70677: LIST
70678: LIST
70679: LIST
70680: LIST
70681: LIST
70682: LIST
70683: LIST
70684: LIST
70685: LIST
70686: LIST
70687: ST_TO_ADDR
70688: GO 71155
70690: LD_INT 2
70692: DOUBLE
70693: EQUAL
70694: IFTRUE 70698
70696: GO 70924
70698: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
70699: LD_ADDR_VAR 0 4
70703: PUSH
70704: LD_INT 35
70706: PUSH
70707: LD_INT 45
70709: PUSH
70710: LD_INT 46
70712: PUSH
70713: LD_INT 47
70715: PUSH
70716: LD_INT 82
70718: PUSH
70719: LD_INT 83
70721: PUSH
70722: LD_INT 84
70724: PUSH
70725: LD_INT 85
70727: PUSH
70728: LD_INT 87
70730: PUSH
70731: LD_INT 70
70733: PUSH
70734: LD_INT 1
70736: PUSH
70737: LD_INT 11
70739: PUSH
70740: LD_INT 3
70742: PUSH
70743: LD_INT 4
70745: PUSH
70746: LD_INT 5
70748: PUSH
70749: LD_INT 6
70751: PUSH
70752: LD_INT 15
70754: PUSH
70755: LD_INT 18
70757: PUSH
70758: LD_INT 7
70760: PUSH
70761: LD_INT 17
70763: PUSH
70764: LD_INT 8
70766: PUSH
70767: LD_INT 20
70769: PUSH
70770: LD_INT 21
70772: PUSH
70773: LD_INT 22
70775: PUSH
70776: LD_INT 72
70778: PUSH
70779: LD_INT 26
70781: PUSH
70782: LD_INT 69
70784: PUSH
70785: LD_INT 39
70787: PUSH
70788: LD_INT 40
70790: PUSH
70791: LD_INT 41
70793: PUSH
70794: LD_INT 42
70796: PUSH
70797: LD_INT 43
70799: PUSH
70800: LD_INT 48
70802: PUSH
70803: LD_INT 49
70805: PUSH
70806: LD_INT 50
70808: PUSH
70809: LD_INT 51
70811: PUSH
70812: LD_INT 52
70814: PUSH
70815: LD_INT 53
70817: PUSH
70818: LD_INT 54
70820: PUSH
70821: LD_INT 55
70823: PUSH
70824: LD_INT 56
70826: PUSH
70827: LD_INT 60
70829: PUSH
70830: LD_INT 61
70832: PUSH
70833: LD_INT 62
70835: PUSH
70836: LD_INT 66
70838: PUSH
70839: LD_INT 67
70841: PUSH
70842: LD_INT 68
70844: PUSH
70845: LD_INT 81
70847: PUSH
70848: LD_INT 82
70850: PUSH
70851: LD_INT 83
70853: PUSH
70854: LD_INT 84
70856: PUSH
70857: LD_INT 85
70859: PUSH
70860: LD_INT 87
70862: PUSH
70863: LD_INT 88
70865: PUSH
70866: EMPTY
70867: LIST
70868: LIST
70869: LIST
70870: LIST
70871: LIST
70872: LIST
70873: LIST
70874: LIST
70875: LIST
70876: LIST
70877: LIST
70878: LIST
70879: LIST
70880: LIST
70881: LIST
70882: LIST
70883: LIST
70884: LIST
70885: LIST
70886: LIST
70887: LIST
70888: LIST
70889: LIST
70890: LIST
70891: LIST
70892: LIST
70893: LIST
70894: LIST
70895: LIST
70896: LIST
70897: LIST
70898: LIST
70899: LIST
70900: LIST
70901: LIST
70902: LIST
70903: LIST
70904: LIST
70905: LIST
70906: LIST
70907: LIST
70908: LIST
70909: LIST
70910: LIST
70911: LIST
70912: LIST
70913: LIST
70914: LIST
70915: LIST
70916: LIST
70917: LIST
70918: LIST
70919: LIST
70920: LIST
70921: ST_TO_ADDR
70922: GO 71155
70924: LD_INT 3
70926: DOUBLE
70927: EQUAL
70928: IFTRUE 70932
70930: GO 71154
70932: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
70933: LD_ADDR_VAR 0 4
70937: PUSH
70938: LD_INT 46
70940: PUSH
70941: LD_INT 47
70943: PUSH
70944: LD_INT 1
70946: PUSH
70947: LD_INT 2
70949: PUSH
70950: LD_INT 82
70952: PUSH
70953: LD_INT 83
70955: PUSH
70956: LD_INT 84
70958: PUSH
70959: LD_INT 85
70961: PUSH
70962: LD_INT 86
70964: PUSH
70965: LD_INT 11
70967: PUSH
70968: LD_INT 9
70970: PUSH
70971: LD_INT 20
70973: PUSH
70974: LD_INT 19
70976: PUSH
70977: LD_INT 21
70979: PUSH
70980: LD_INT 24
70982: PUSH
70983: LD_INT 22
70985: PUSH
70986: LD_INT 25
70988: PUSH
70989: LD_INT 28
70991: PUSH
70992: LD_INT 29
70994: PUSH
70995: LD_INT 30
70997: PUSH
70998: LD_INT 31
71000: PUSH
71001: LD_INT 37
71003: PUSH
71004: LD_INT 38
71006: PUSH
71007: LD_INT 32
71009: PUSH
71010: LD_INT 27
71012: PUSH
71013: LD_INT 33
71015: PUSH
71016: LD_INT 69
71018: PUSH
71019: LD_INT 39
71021: PUSH
71022: LD_INT 34
71024: PUSH
71025: LD_INT 40
71027: PUSH
71028: LD_INT 71
71030: PUSH
71031: LD_INT 23
71033: PUSH
71034: LD_INT 44
71036: PUSH
71037: LD_INT 48
71039: PUSH
71040: LD_INT 49
71042: PUSH
71043: LD_INT 50
71045: PUSH
71046: LD_INT 51
71048: PUSH
71049: LD_INT 52
71051: PUSH
71052: LD_INT 53
71054: PUSH
71055: LD_INT 54
71057: PUSH
71058: LD_INT 55
71060: PUSH
71061: LD_INT 56
71063: PUSH
71064: LD_INT 57
71066: PUSH
71067: LD_INT 58
71069: PUSH
71070: LD_INT 59
71072: PUSH
71073: LD_INT 63
71075: PUSH
71076: LD_INT 64
71078: PUSH
71079: LD_INT 65
71081: PUSH
71082: LD_INT 82
71084: PUSH
71085: LD_INT 83
71087: PUSH
71088: LD_INT 84
71090: PUSH
71091: LD_INT 85
71093: PUSH
71094: LD_INT 86
71096: PUSH
71097: EMPTY
71098: LIST
71099: LIST
71100: LIST
71101: LIST
71102: LIST
71103: LIST
71104: LIST
71105: LIST
71106: LIST
71107: LIST
71108: LIST
71109: LIST
71110: LIST
71111: LIST
71112: LIST
71113: LIST
71114: LIST
71115: LIST
71116: LIST
71117: LIST
71118: LIST
71119: LIST
71120: LIST
71121: LIST
71122: LIST
71123: LIST
71124: LIST
71125: LIST
71126: LIST
71127: LIST
71128: LIST
71129: LIST
71130: LIST
71131: LIST
71132: LIST
71133: LIST
71134: LIST
71135: LIST
71136: LIST
71137: LIST
71138: LIST
71139: LIST
71140: LIST
71141: LIST
71142: LIST
71143: LIST
71144: LIST
71145: LIST
71146: LIST
71147: LIST
71148: LIST
71149: LIST
71150: LIST
71151: ST_TO_ADDR
71152: GO 71155
71154: POP
// if state > - 1 and state < 3 then
71155: LD_VAR 0 3
71159: PUSH
71160: LD_INT 1
71162: NEG
71163: GREATER
71164: PUSH
71165: LD_VAR 0 3
71169: PUSH
71170: LD_INT 3
71172: LESS
71173: AND
71174: IFFALSE 71231
// for i in result do
71176: LD_ADDR_VAR 0 5
71180: PUSH
71181: LD_VAR 0 4
71185: PUSH
71186: FOR_IN
71187: IFFALSE 71229
// if GetTech ( i , side ) <> state then
71189: LD_VAR 0 5
71193: PPUSH
71194: LD_VAR 0 1
71198: PPUSH
71199: CALL_OW 321
71203: PUSH
71204: LD_VAR 0 3
71208: NONEQUAL
71209: IFFALSE 71227
// result := result diff i ;
71211: LD_ADDR_VAR 0 4
71215: PUSH
71216: LD_VAR 0 4
71220: PUSH
71221: LD_VAR 0 5
71225: DIFF
71226: ST_TO_ADDR
71227: GO 71186
71229: POP
71230: POP
// end ;
71231: LD_VAR 0 4
71235: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
71236: LD_INT 0
71238: PPUSH
71239: PPUSH
71240: PPUSH
// result := true ;
71241: LD_ADDR_VAR 0 3
71245: PUSH
71246: LD_INT 1
71248: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
71249: LD_ADDR_VAR 0 5
71253: PUSH
71254: LD_VAR 0 2
71258: PPUSH
71259: CALL_OW 480
71263: ST_TO_ADDR
// if not tmp then
71264: LD_VAR 0 5
71268: NOT
71269: IFFALSE 71273
// exit ;
71271: GO 71322
// for i in tmp do
71273: LD_ADDR_VAR 0 4
71277: PUSH
71278: LD_VAR 0 5
71282: PUSH
71283: FOR_IN
71284: IFFALSE 71320
// if GetTech ( i , side ) <> state_researched then
71286: LD_VAR 0 4
71290: PPUSH
71291: LD_VAR 0 1
71295: PPUSH
71296: CALL_OW 321
71300: PUSH
71301: LD_INT 2
71303: NONEQUAL
71304: IFFALSE 71318
// begin result := false ;
71306: LD_ADDR_VAR 0 3
71310: PUSH
71311: LD_INT 0
71313: ST_TO_ADDR
// exit ;
71314: POP
71315: POP
71316: GO 71322
// end ;
71318: GO 71283
71320: POP
71321: POP
// end ;
71322: LD_VAR 0 3
71326: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
71327: LD_INT 0
71329: PPUSH
71330: PPUSH
71331: PPUSH
71332: PPUSH
71333: PPUSH
71334: PPUSH
71335: PPUSH
71336: PPUSH
71337: PPUSH
71338: PPUSH
71339: PPUSH
71340: PPUSH
71341: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
71342: LD_VAR 0 1
71346: NOT
71347: PUSH
71348: LD_VAR 0 1
71352: PPUSH
71353: CALL_OW 257
71357: PUSH
71358: LD_INT 9
71360: NONEQUAL
71361: OR
71362: IFFALSE 71366
// exit ;
71364: GO 71939
// side := GetSide ( unit ) ;
71366: LD_ADDR_VAR 0 9
71370: PUSH
71371: LD_VAR 0 1
71375: PPUSH
71376: CALL_OW 255
71380: ST_TO_ADDR
// tech_space := tech_spacanom ;
71381: LD_ADDR_VAR 0 12
71385: PUSH
71386: LD_INT 29
71388: ST_TO_ADDR
// tech_time := tech_taurad ;
71389: LD_ADDR_VAR 0 13
71393: PUSH
71394: LD_INT 28
71396: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
71397: LD_ADDR_VAR 0 11
71401: PUSH
71402: LD_VAR 0 1
71406: PPUSH
71407: CALL_OW 310
71411: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
71412: LD_VAR 0 11
71416: PPUSH
71417: CALL_OW 247
71421: PUSH
71422: LD_INT 2
71424: EQUAL
71425: IFFALSE 71429
// exit ;
71427: GO 71939
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71429: LD_ADDR_VAR 0 8
71433: PUSH
71434: LD_INT 81
71436: PUSH
71437: LD_VAR 0 9
71441: PUSH
71442: EMPTY
71443: LIST
71444: LIST
71445: PUSH
71446: LD_INT 3
71448: PUSH
71449: LD_INT 21
71451: PUSH
71452: LD_INT 3
71454: PUSH
71455: EMPTY
71456: LIST
71457: LIST
71458: PUSH
71459: EMPTY
71460: LIST
71461: LIST
71462: PUSH
71463: EMPTY
71464: LIST
71465: LIST
71466: PPUSH
71467: CALL_OW 69
71471: ST_TO_ADDR
// if not tmp then
71472: LD_VAR 0 8
71476: NOT
71477: IFFALSE 71481
// exit ;
71479: GO 71939
// if in_unit then
71481: LD_VAR 0 11
71485: IFFALSE 71509
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
71487: LD_ADDR_VAR 0 10
71491: PUSH
71492: LD_VAR 0 8
71496: PPUSH
71497: LD_VAR 0 11
71501: PPUSH
71502: CALL_OW 74
71506: ST_TO_ADDR
71507: GO 71529
// enemy := NearestUnitToUnit ( tmp , unit ) ;
71509: LD_ADDR_VAR 0 10
71513: PUSH
71514: LD_VAR 0 8
71518: PPUSH
71519: LD_VAR 0 1
71523: PPUSH
71524: CALL_OW 74
71528: ST_TO_ADDR
// if not enemy then
71529: LD_VAR 0 10
71533: NOT
71534: IFFALSE 71538
// exit ;
71536: GO 71939
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
71538: LD_VAR 0 11
71542: PUSH
71543: LD_VAR 0 11
71547: PPUSH
71548: LD_VAR 0 10
71552: PPUSH
71553: CALL_OW 296
71557: PUSH
71558: LD_INT 13
71560: GREATER
71561: AND
71562: PUSH
71563: LD_VAR 0 1
71567: PPUSH
71568: LD_VAR 0 10
71572: PPUSH
71573: CALL_OW 296
71577: PUSH
71578: LD_INT 12
71580: GREATER
71581: OR
71582: IFFALSE 71586
// exit ;
71584: GO 71939
// missile := [ 1 ] ;
71586: LD_ADDR_VAR 0 14
71590: PUSH
71591: LD_INT 1
71593: PUSH
71594: EMPTY
71595: LIST
71596: ST_TO_ADDR
// if Researched ( side , tech_space ) then
71597: LD_VAR 0 9
71601: PPUSH
71602: LD_VAR 0 12
71606: PPUSH
71607: CALL_OW 325
71611: IFFALSE 71640
// missile := Replace ( missile , missile + 1 , 2 ) ;
71613: LD_ADDR_VAR 0 14
71617: PUSH
71618: LD_VAR 0 14
71622: PPUSH
71623: LD_VAR 0 14
71627: PUSH
71628: LD_INT 1
71630: PLUS
71631: PPUSH
71632: LD_INT 2
71634: PPUSH
71635: CALL_OW 1
71639: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
71640: LD_VAR 0 9
71644: PPUSH
71645: LD_VAR 0 13
71649: PPUSH
71650: CALL_OW 325
71654: PUSH
71655: LD_VAR 0 10
71659: PPUSH
71660: CALL_OW 255
71664: PPUSH
71665: LD_VAR 0 13
71669: PPUSH
71670: CALL_OW 325
71674: NOT
71675: AND
71676: IFFALSE 71705
// missile := Replace ( missile , missile + 1 , 3 ) ;
71678: LD_ADDR_VAR 0 14
71682: PUSH
71683: LD_VAR 0 14
71687: PPUSH
71688: LD_VAR 0 14
71692: PUSH
71693: LD_INT 1
71695: PLUS
71696: PPUSH
71697: LD_INT 3
71699: PPUSH
71700: CALL_OW 1
71704: ST_TO_ADDR
// if missile < 2 then
71705: LD_VAR 0 14
71709: PUSH
71710: LD_INT 2
71712: LESS
71713: IFFALSE 71717
// exit ;
71715: GO 71939
// x := GetX ( enemy ) ;
71717: LD_ADDR_VAR 0 4
71721: PUSH
71722: LD_VAR 0 10
71726: PPUSH
71727: CALL_OW 250
71731: ST_TO_ADDR
// y := GetY ( enemy ) ;
71732: LD_ADDR_VAR 0 5
71736: PUSH
71737: LD_VAR 0 10
71741: PPUSH
71742: CALL_OW 251
71746: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
71747: LD_ADDR_VAR 0 6
71751: PUSH
71752: LD_VAR 0 4
71756: PUSH
71757: LD_INT 1
71759: NEG
71760: PPUSH
71761: LD_INT 1
71763: PPUSH
71764: CALL_OW 12
71768: PLUS
71769: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
71770: LD_ADDR_VAR 0 7
71774: PUSH
71775: LD_VAR 0 5
71779: PUSH
71780: LD_INT 1
71782: NEG
71783: PPUSH
71784: LD_INT 1
71786: PPUSH
71787: CALL_OW 12
71791: PLUS
71792: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
71793: LD_VAR 0 6
71797: PPUSH
71798: LD_VAR 0 7
71802: PPUSH
71803: CALL_OW 488
71807: NOT
71808: IFFALSE 71830
// begin _x := x ;
71810: LD_ADDR_VAR 0 6
71814: PUSH
71815: LD_VAR 0 4
71819: ST_TO_ADDR
// _y := y ;
71820: LD_ADDR_VAR 0 7
71824: PUSH
71825: LD_VAR 0 5
71829: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
71830: LD_ADDR_VAR 0 3
71834: PUSH
71835: LD_INT 1
71837: PPUSH
71838: LD_VAR 0 14
71842: PPUSH
71843: CALL_OW 12
71847: ST_TO_ADDR
// case i of 1 :
71848: LD_VAR 0 3
71852: PUSH
71853: LD_INT 1
71855: DOUBLE
71856: EQUAL
71857: IFTRUE 71861
71859: GO 71878
71861: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
71862: LD_VAR 0 1
71866: PPUSH
71867: LD_VAR 0 10
71871: PPUSH
71872: CALL_OW 115
71876: GO 71939
71878: LD_INT 2
71880: DOUBLE
71881: EQUAL
71882: IFTRUE 71886
71884: GO 71908
71886: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
71887: LD_VAR 0 1
71891: PPUSH
71892: LD_VAR 0 6
71896: PPUSH
71897: LD_VAR 0 7
71901: PPUSH
71902: CALL_OW 153
71906: GO 71939
71908: LD_INT 3
71910: DOUBLE
71911: EQUAL
71912: IFTRUE 71916
71914: GO 71938
71916: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
71917: LD_VAR 0 1
71921: PPUSH
71922: LD_VAR 0 6
71926: PPUSH
71927: LD_VAR 0 7
71931: PPUSH
71932: CALL_OW 154
71936: GO 71939
71938: POP
// end ;
71939: LD_VAR 0 2
71943: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
71944: LD_INT 0
71946: PPUSH
71947: PPUSH
71948: PPUSH
71949: PPUSH
71950: PPUSH
71951: PPUSH
// if not unit or not building then
71952: LD_VAR 0 1
71956: NOT
71957: PUSH
71958: LD_VAR 0 2
71962: NOT
71963: OR
71964: IFFALSE 71968
// exit ;
71966: GO 72126
// x := GetX ( building ) ;
71968: LD_ADDR_VAR 0 5
71972: PUSH
71973: LD_VAR 0 2
71977: PPUSH
71978: CALL_OW 250
71982: ST_TO_ADDR
// y := GetY ( building ) ;
71983: LD_ADDR_VAR 0 6
71987: PUSH
71988: LD_VAR 0 2
71992: PPUSH
71993: CALL_OW 251
71997: ST_TO_ADDR
// for i = 0 to 5 do
71998: LD_ADDR_VAR 0 4
72002: PUSH
72003: DOUBLE
72004: LD_INT 0
72006: DEC
72007: ST_TO_ADDR
72008: LD_INT 5
72010: PUSH
72011: FOR_TO
72012: IFFALSE 72124
// begin _x := ShiftX ( x , i , 3 ) ;
72014: LD_ADDR_VAR 0 7
72018: PUSH
72019: LD_VAR 0 5
72023: PPUSH
72024: LD_VAR 0 4
72028: PPUSH
72029: LD_INT 3
72031: PPUSH
72032: CALL_OW 272
72036: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
72037: LD_ADDR_VAR 0 8
72041: PUSH
72042: LD_VAR 0 6
72046: PPUSH
72047: LD_VAR 0 4
72051: PPUSH
72052: LD_INT 3
72054: PPUSH
72055: CALL_OW 273
72059: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
72060: LD_VAR 0 7
72064: PPUSH
72065: LD_VAR 0 8
72069: PPUSH
72070: CALL_OW 488
72074: NOT
72075: IFFALSE 72079
// continue ;
72077: GO 72011
// if HexInfo ( _x , _y ) = 0 then
72079: LD_VAR 0 7
72083: PPUSH
72084: LD_VAR 0 8
72088: PPUSH
72089: CALL_OW 428
72093: PUSH
72094: LD_INT 0
72096: EQUAL
72097: IFFALSE 72122
// begin ComMoveXY ( unit , _x , _y ) ;
72099: LD_VAR 0 1
72103: PPUSH
72104: LD_VAR 0 7
72108: PPUSH
72109: LD_VAR 0 8
72113: PPUSH
72114: CALL_OW 111
// exit ;
72118: POP
72119: POP
72120: GO 72126
// end ; end ;
72122: GO 72011
72124: POP
72125: POP
// end ;
72126: LD_VAR 0 3
72130: RET
// export function ScanBase ( side , base_area ) ; begin
72131: LD_INT 0
72133: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
72134: LD_ADDR_VAR 0 3
72138: PUSH
72139: LD_VAR 0 2
72143: PPUSH
72144: LD_INT 81
72146: PUSH
72147: LD_VAR 0 1
72151: PUSH
72152: EMPTY
72153: LIST
72154: LIST
72155: PPUSH
72156: CALL_OW 70
72160: ST_TO_ADDR
// end ;
72161: LD_VAR 0 3
72165: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
72166: LD_INT 0
72168: PPUSH
72169: PPUSH
72170: PPUSH
72171: PPUSH
// result := false ;
72172: LD_ADDR_VAR 0 2
72176: PUSH
72177: LD_INT 0
72179: ST_TO_ADDR
// side := GetSide ( unit ) ;
72180: LD_ADDR_VAR 0 3
72184: PUSH
72185: LD_VAR 0 1
72189: PPUSH
72190: CALL_OW 255
72194: ST_TO_ADDR
// nat := GetNation ( unit ) ;
72195: LD_ADDR_VAR 0 4
72199: PUSH
72200: LD_VAR 0 1
72204: PPUSH
72205: CALL_OW 248
72209: ST_TO_ADDR
// case nat of 1 :
72210: LD_VAR 0 4
72214: PUSH
72215: LD_INT 1
72217: DOUBLE
72218: EQUAL
72219: IFTRUE 72223
72221: GO 72234
72223: POP
// tech := tech_lassight ; 2 :
72224: LD_ADDR_VAR 0 5
72228: PUSH
72229: LD_INT 12
72231: ST_TO_ADDR
72232: GO 72273
72234: LD_INT 2
72236: DOUBLE
72237: EQUAL
72238: IFTRUE 72242
72240: GO 72253
72242: POP
// tech := tech_mortar ; 3 :
72243: LD_ADDR_VAR 0 5
72247: PUSH
72248: LD_INT 41
72250: ST_TO_ADDR
72251: GO 72273
72253: LD_INT 3
72255: DOUBLE
72256: EQUAL
72257: IFTRUE 72261
72259: GO 72272
72261: POP
// tech := tech_bazooka ; end ;
72262: LD_ADDR_VAR 0 5
72266: PUSH
72267: LD_INT 44
72269: ST_TO_ADDR
72270: GO 72273
72272: POP
// if Researched ( side , tech ) then
72273: LD_VAR 0 3
72277: PPUSH
72278: LD_VAR 0 5
72282: PPUSH
72283: CALL_OW 325
72287: IFFALSE 72314
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
72289: LD_ADDR_VAR 0 2
72293: PUSH
72294: LD_INT 5
72296: PUSH
72297: LD_INT 8
72299: PUSH
72300: LD_INT 9
72302: PUSH
72303: EMPTY
72304: LIST
72305: LIST
72306: LIST
72307: PUSH
72308: LD_VAR 0 4
72312: ARRAY
72313: ST_TO_ADDR
// end ;
72314: LD_VAR 0 2
72318: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
72319: LD_INT 0
72321: PPUSH
72322: PPUSH
72323: PPUSH
// if not mines then
72324: LD_VAR 0 2
72328: NOT
72329: IFFALSE 72333
// exit ;
72331: GO 72477
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72333: LD_ADDR_VAR 0 5
72337: PUSH
72338: LD_INT 81
72340: PUSH
72341: LD_VAR 0 1
72345: PUSH
72346: EMPTY
72347: LIST
72348: LIST
72349: PUSH
72350: LD_INT 3
72352: PUSH
72353: LD_INT 21
72355: PUSH
72356: LD_INT 3
72358: PUSH
72359: EMPTY
72360: LIST
72361: LIST
72362: PUSH
72363: EMPTY
72364: LIST
72365: LIST
72366: PUSH
72367: EMPTY
72368: LIST
72369: LIST
72370: PPUSH
72371: CALL_OW 69
72375: ST_TO_ADDR
// for i in mines do
72376: LD_ADDR_VAR 0 4
72380: PUSH
72381: LD_VAR 0 2
72385: PUSH
72386: FOR_IN
72387: IFFALSE 72475
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
72389: LD_VAR 0 4
72393: PUSH
72394: LD_INT 1
72396: ARRAY
72397: PPUSH
72398: LD_VAR 0 4
72402: PUSH
72403: LD_INT 2
72405: ARRAY
72406: PPUSH
72407: CALL_OW 458
72411: NOT
72412: IFFALSE 72416
// continue ;
72414: GO 72386
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
72416: LD_VAR 0 4
72420: PUSH
72421: LD_INT 1
72423: ARRAY
72424: PPUSH
72425: LD_VAR 0 4
72429: PUSH
72430: LD_INT 2
72432: ARRAY
72433: PPUSH
72434: CALL_OW 428
72438: PUSH
72439: LD_VAR 0 5
72443: IN
72444: IFFALSE 72473
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
72446: LD_VAR 0 4
72450: PUSH
72451: LD_INT 1
72453: ARRAY
72454: PPUSH
72455: LD_VAR 0 4
72459: PUSH
72460: LD_INT 2
72462: ARRAY
72463: PPUSH
72464: LD_VAR 0 1
72468: PPUSH
72469: CALL_OW 456
// end ;
72473: GO 72386
72475: POP
72476: POP
// end ;
72477: LD_VAR 0 3
72481: RET
// export function Count ( array ) ; begin
72482: LD_INT 0
72484: PPUSH
// result := array + 0 ;
72485: LD_ADDR_VAR 0 2
72489: PUSH
72490: LD_VAR 0 1
72494: PUSH
72495: LD_INT 0
72497: PLUS
72498: ST_TO_ADDR
// end ;
72499: LD_VAR 0 2
72503: RET
// export function IsEmpty ( building ) ; begin
72504: LD_INT 0
72506: PPUSH
// if not building then
72507: LD_VAR 0 1
72511: NOT
72512: IFFALSE 72516
// exit ;
72514: GO 72559
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
72516: LD_ADDR_VAR 0 2
72520: PUSH
72521: LD_VAR 0 1
72525: PUSH
72526: LD_INT 22
72528: PUSH
72529: LD_VAR 0 1
72533: PPUSH
72534: CALL_OW 255
72538: PUSH
72539: EMPTY
72540: LIST
72541: LIST
72542: PUSH
72543: LD_INT 58
72545: PUSH
72546: EMPTY
72547: LIST
72548: PUSH
72549: EMPTY
72550: LIST
72551: LIST
72552: PPUSH
72553: CALL_OW 69
72557: IN
72558: ST_TO_ADDR
// end ;
72559: LD_VAR 0 2
72563: RET
// export function IsNotFull ( building ) ; var places ; begin
72564: LD_INT 0
72566: PPUSH
72567: PPUSH
// if not building then
72568: LD_VAR 0 1
72572: NOT
72573: IFFALSE 72577
// exit ;
72575: GO 72605
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
72577: LD_ADDR_VAR 0 2
72581: PUSH
72582: LD_VAR 0 1
72586: PPUSH
72587: LD_INT 3
72589: PUSH
72590: LD_INT 62
72592: PUSH
72593: EMPTY
72594: LIST
72595: PUSH
72596: EMPTY
72597: LIST
72598: LIST
72599: PPUSH
72600: CALL_OW 72
72604: ST_TO_ADDR
// end ;
72605: LD_VAR 0 2
72609: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
72610: LD_INT 0
72612: PPUSH
72613: PPUSH
72614: PPUSH
72615: PPUSH
// tmp := [ ] ;
72616: LD_ADDR_VAR 0 3
72620: PUSH
72621: EMPTY
72622: ST_TO_ADDR
// list := [ ] ;
72623: LD_ADDR_VAR 0 5
72627: PUSH
72628: EMPTY
72629: ST_TO_ADDR
// for i = 16 to 25 do
72630: LD_ADDR_VAR 0 4
72634: PUSH
72635: DOUBLE
72636: LD_INT 16
72638: DEC
72639: ST_TO_ADDR
72640: LD_INT 25
72642: PUSH
72643: FOR_TO
72644: IFFALSE 72717
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
72646: LD_ADDR_VAR 0 3
72650: PUSH
72651: LD_VAR 0 3
72655: PUSH
72656: LD_INT 22
72658: PUSH
72659: LD_VAR 0 1
72663: PPUSH
72664: CALL_OW 255
72668: PUSH
72669: EMPTY
72670: LIST
72671: LIST
72672: PUSH
72673: LD_INT 91
72675: PUSH
72676: LD_VAR 0 1
72680: PUSH
72681: LD_INT 6
72683: PUSH
72684: EMPTY
72685: LIST
72686: LIST
72687: LIST
72688: PUSH
72689: LD_INT 30
72691: PUSH
72692: LD_VAR 0 4
72696: PUSH
72697: EMPTY
72698: LIST
72699: LIST
72700: PUSH
72701: EMPTY
72702: LIST
72703: LIST
72704: LIST
72705: PUSH
72706: EMPTY
72707: LIST
72708: PPUSH
72709: CALL_OW 69
72713: ADD
72714: ST_TO_ADDR
72715: GO 72643
72717: POP
72718: POP
// for i = 1 to tmp do
72719: LD_ADDR_VAR 0 4
72723: PUSH
72724: DOUBLE
72725: LD_INT 1
72727: DEC
72728: ST_TO_ADDR
72729: LD_VAR 0 3
72733: PUSH
72734: FOR_TO
72735: IFFALSE 72823
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
72737: LD_ADDR_VAR 0 5
72741: PUSH
72742: LD_VAR 0 5
72746: PUSH
72747: LD_VAR 0 3
72751: PUSH
72752: LD_VAR 0 4
72756: ARRAY
72757: PPUSH
72758: CALL_OW 266
72762: PUSH
72763: LD_VAR 0 3
72767: PUSH
72768: LD_VAR 0 4
72772: ARRAY
72773: PPUSH
72774: CALL_OW 250
72778: PUSH
72779: LD_VAR 0 3
72783: PUSH
72784: LD_VAR 0 4
72788: ARRAY
72789: PPUSH
72790: CALL_OW 251
72794: PUSH
72795: LD_VAR 0 3
72799: PUSH
72800: LD_VAR 0 4
72804: ARRAY
72805: PPUSH
72806: CALL_OW 254
72810: PUSH
72811: EMPTY
72812: LIST
72813: LIST
72814: LIST
72815: LIST
72816: PUSH
72817: EMPTY
72818: LIST
72819: ADD
72820: ST_TO_ADDR
72821: GO 72734
72823: POP
72824: POP
// result := list ;
72825: LD_ADDR_VAR 0 2
72829: PUSH
72830: LD_VAR 0 5
72834: ST_TO_ADDR
// end ;
72835: LD_VAR 0 2
72839: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
72840: LD_INT 0
72842: PPUSH
72843: PPUSH
72844: PPUSH
72845: PPUSH
72846: PPUSH
72847: PPUSH
72848: PPUSH
// if not factory then
72849: LD_VAR 0 1
72853: NOT
72854: IFFALSE 72858
// exit ;
72856: GO 73451
// if control = control_apeman then
72858: LD_VAR 0 4
72862: PUSH
72863: LD_INT 5
72865: EQUAL
72866: IFFALSE 72975
// begin tmp := UnitsInside ( factory ) ;
72868: LD_ADDR_VAR 0 8
72872: PUSH
72873: LD_VAR 0 1
72877: PPUSH
72878: CALL_OW 313
72882: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
72883: LD_VAR 0 8
72887: PPUSH
72888: LD_INT 25
72890: PUSH
72891: LD_INT 12
72893: PUSH
72894: EMPTY
72895: LIST
72896: LIST
72897: PPUSH
72898: CALL_OW 72
72902: NOT
72903: IFFALSE 72913
// control := control_manual ;
72905: LD_ADDR_VAR 0 4
72909: PUSH
72910: LD_INT 1
72912: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
72913: LD_ADDR_VAR 0 8
72917: PUSH
72918: LD_VAR 0 1
72922: PPUSH
72923: CALL 72610 0 1
72927: ST_TO_ADDR
// if tmp then
72928: LD_VAR 0 8
72932: IFFALSE 72975
// begin for i in tmp do
72934: LD_ADDR_VAR 0 7
72938: PUSH
72939: LD_VAR 0 8
72943: PUSH
72944: FOR_IN
72945: IFFALSE 72973
// if i [ 1 ] = b_ext_radio then
72947: LD_VAR 0 7
72951: PUSH
72952: LD_INT 1
72954: ARRAY
72955: PUSH
72956: LD_INT 22
72958: EQUAL
72959: IFFALSE 72971
// begin control := control_remote ;
72961: LD_ADDR_VAR 0 4
72965: PUSH
72966: LD_INT 2
72968: ST_TO_ADDR
// break ;
72969: GO 72973
// end ;
72971: GO 72944
72973: POP
72974: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
72975: LD_VAR 0 1
72979: PPUSH
72980: LD_VAR 0 2
72984: PPUSH
72985: LD_VAR 0 3
72989: PPUSH
72990: LD_VAR 0 4
72994: PPUSH
72995: LD_VAR 0 5
72999: PPUSH
73000: CALL_OW 448
73004: IFFALSE 73039
// begin result := [ chassis , engine , control , weapon ] ;
73006: LD_ADDR_VAR 0 6
73010: PUSH
73011: LD_VAR 0 2
73015: PUSH
73016: LD_VAR 0 3
73020: PUSH
73021: LD_VAR 0 4
73025: PUSH
73026: LD_VAR 0 5
73030: PUSH
73031: EMPTY
73032: LIST
73033: LIST
73034: LIST
73035: LIST
73036: ST_TO_ADDR
// exit ;
73037: GO 73451
// end ; _chassis := AvailableChassisList ( factory ) ;
73039: LD_ADDR_VAR 0 9
73043: PUSH
73044: LD_VAR 0 1
73048: PPUSH
73049: CALL_OW 475
73053: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
73054: LD_ADDR_VAR 0 11
73058: PUSH
73059: LD_VAR 0 1
73063: PPUSH
73064: CALL_OW 476
73068: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
73069: LD_ADDR_VAR 0 12
73073: PUSH
73074: LD_VAR 0 1
73078: PPUSH
73079: CALL_OW 477
73083: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
73084: LD_ADDR_VAR 0 10
73088: PUSH
73089: LD_VAR 0 1
73093: PPUSH
73094: CALL_OW 478
73098: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
73099: LD_VAR 0 9
73103: NOT
73104: PUSH
73105: LD_VAR 0 11
73109: NOT
73110: OR
73111: PUSH
73112: LD_VAR 0 12
73116: NOT
73117: OR
73118: PUSH
73119: LD_VAR 0 10
73123: NOT
73124: OR
73125: IFFALSE 73160
// begin result := [ chassis , engine , control , weapon ] ;
73127: LD_ADDR_VAR 0 6
73131: PUSH
73132: LD_VAR 0 2
73136: PUSH
73137: LD_VAR 0 3
73141: PUSH
73142: LD_VAR 0 4
73146: PUSH
73147: LD_VAR 0 5
73151: PUSH
73152: EMPTY
73153: LIST
73154: LIST
73155: LIST
73156: LIST
73157: ST_TO_ADDR
// exit ;
73158: GO 73451
// end ; if not chassis in _chassis then
73160: LD_VAR 0 2
73164: PUSH
73165: LD_VAR 0 9
73169: IN
73170: NOT
73171: IFFALSE 73197
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
73173: LD_ADDR_VAR 0 2
73177: PUSH
73178: LD_VAR 0 9
73182: PUSH
73183: LD_INT 1
73185: PPUSH
73186: LD_VAR 0 9
73190: PPUSH
73191: CALL_OW 12
73195: ARRAY
73196: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
73197: LD_VAR 0 2
73201: PPUSH
73202: LD_VAR 0 3
73206: PPUSH
73207: CALL 73456 0 2
73211: NOT
73212: IFFALSE 73271
// repeat engine := _engine [ 1 ] ;
73214: LD_ADDR_VAR 0 3
73218: PUSH
73219: LD_VAR 0 11
73223: PUSH
73224: LD_INT 1
73226: ARRAY
73227: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
73228: LD_ADDR_VAR 0 11
73232: PUSH
73233: LD_VAR 0 11
73237: PPUSH
73238: LD_INT 1
73240: PPUSH
73241: CALL_OW 3
73245: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
73246: LD_VAR 0 2
73250: PPUSH
73251: LD_VAR 0 3
73255: PPUSH
73256: CALL 73456 0 2
73260: PUSH
73261: LD_VAR 0 11
73265: PUSH
73266: EMPTY
73267: EQUAL
73268: OR
73269: IFFALSE 73214
// if not control in _control then
73271: LD_VAR 0 4
73275: PUSH
73276: LD_VAR 0 12
73280: IN
73281: NOT
73282: IFFALSE 73308
// control := _control [ rand ( 1 , _control ) ] ;
73284: LD_ADDR_VAR 0 4
73288: PUSH
73289: LD_VAR 0 12
73293: PUSH
73294: LD_INT 1
73296: PPUSH
73297: LD_VAR 0 12
73301: PPUSH
73302: CALL_OW 12
73306: ARRAY
73307: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
73308: LD_VAR 0 2
73312: PPUSH
73313: LD_VAR 0 5
73317: PPUSH
73318: CALL 73676 0 2
73322: NOT
73323: IFFALSE 73382
// repeat weapon := _weapon [ 1 ] ;
73325: LD_ADDR_VAR 0 5
73329: PUSH
73330: LD_VAR 0 10
73334: PUSH
73335: LD_INT 1
73337: ARRAY
73338: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
73339: LD_ADDR_VAR 0 10
73343: PUSH
73344: LD_VAR 0 10
73348: PPUSH
73349: LD_INT 1
73351: PPUSH
73352: CALL_OW 3
73356: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
73357: LD_VAR 0 2
73361: PPUSH
73362: LD_VAR 0 5
73366: PPUSH
73367: CALL 73676 0 2
73371: PUSH
73372: LD_VAR 0 10
73376: PUSH
73377: EMPTY
73378: EQUAL
73379: OR
73380: IFFALSE 73325
// result := [ ] ;
73382: LD_ADDR_VAR 0 6
73386: PUSH
73387: EMPTY
73388: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
73389: LD_VAR 0 1
73393: PPUSH
73394: LD_VAR 0 2
73398: PPUSH
73399: LD_VAR 0 3
73403: PPUSH
73404: LD_VAR 0 4
73408: PPUSH
73409: LD_VAR 0 5
73413: PPUSH
73414: CALL_OW 448
73418: IFFALSE 73451
// result := [ chassis , engine , control , weapon ] ;
73420: LD_ADDR_VAR 0 6
73424: PUSH
73425: LD_VAR 0 2
73429: PUSH
73430: LD_VAR 0 3
73434: PUSH
73435: LD_VAR 0 4
73439: PUSH
73440: LD_VAR 0 5
73444: PUSH
73445: EMPTY
73446: LIST
73447: LIST
73448: LIST
73449: LIST
73450: ST_TO_ADDR
// end ;
73451: LD_VAR 0 6
73455: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
73456: LD_INT 0
73458: PPUSH
// if not chassis or not engine then
73459: LD_VAR 0 1
73463: NOT
73464: PUSH
73465: LD_VAR 0 2
73469: NOT
73470: OR
73471: IFFALSE 73475
// exit ;
73473: GO 73671
// case engine of engine_solar :
73475: LD_VAR 0 2
73479: PUSH
73480: LD_INT 2
73482: DOUBLE
73483: EQUAL
73484: IFTRUE 73488
73486: GO 73526
73488: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
73489: LD_ADDR_VAR 0 3
73493: PUSH
73494: LD_INT 11
73496: PUSH
73497: LD_INT 12
73499: PUSH
73500: LD_INT 13
73502: PUSH
73503: LD_INT 14
73505: PUSH
73506: LD_INT 1
73508: PUSH
73509: LD_INT 2
73511: PUSH
73512: LD_INT 3
73514: PUSH
73515: EMPTY
73516: LIST
73517: LIST
73518: LIST
73519: LIST
73520: LIST
73521: LIST
73522: LIST
73523: ST_TO_ADDR
73524: GO 73655
73526: LD_INT 1
73528: DOUBLE
73529: EQUAL
73530: IFTRUE 73534
73532: GO 73596
73534: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
73535: LD_ADDR_VAR 0 3
73539: PUSH
73540: LD_INT 11
73542: PUSH
73543: LD_INT 12
73545: PUSH
73546: LD_INT 13
73548: PUSH
73549: LD_INT 14
73551: PUSH
73552: LD_INT 1
73554: PUSH
73555: LD_INT 2
73557: PUSH
73558: LD_INT 3
73560: PUSH
73561: LD_INT 4
73563: PUSH
73564: LD_INT 5
73566: PUSH
73567: LD_INT 21
73569: PUSH
73570: LD_INT 23
73572: PUSH
73573: LD_INT 22
73575: PUSH
73576: LD_INT 24
73578: PUSH
73579: EMPTY
73580: LIST
73581: LIST
73582: LIST
73583: LIST
73584: LIST
73585: LIST
73586: LIST
73587: LIST
73588: LIST
73589: LIST
73590: LIST
73591: LIST
73592: LIST
73593: ST_TO_ADDR
73594: GO 73655
73596: LD_INT 3
73598: DOUBLE
73599: EQUAL
73600: IFTRUE 73604
73602: GO 73654
73604: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
73605: LD_ADDR_VAR 0 3
73609: PUSH
73610: LD_INT 13
73612: PUSH
73613: LD_INT 14
73615: PUSH
73616: LD_INT 2
73618: PUSH
73619: LD_INT 3
73621: PUSH
73622: LD_INT 4
73624: PUSH
73625: LD_INT 5
73627: PUSH
73628: LD_INT 21
73630: PUSH
73631: LD_INT 22
73633: PUSH
73634: LD_INT 23
73636: PUSH
73637: LD_INT 24
73639: PUSH
73640: EMPTY
73641: LIST
73642: LIST
73643: LIST
73644: LIST
73645: LIST
73646: LIST
73647: LIST
73648: LIST
73649: LIST
73650: LIST
73651: ST_TO_ADDR
73652: GO 73655
73654: POP
// result := ( chassis in result ) ;
73655: LD_ADDR_VAR 0 3
73659: PUSH
73660: LD_VAR 0 1
73664: PUSH
73665: LD_VAR 0 3
73669: IN
73670: ST_TO_ADDR
// end ;
73671: LD_VAR 0 3
73675: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
73676: LD_INT 0
73678: PPUSH
// if not chassis or not weapon then
73679: LD_VAR 0 1
73683: NOT
73684: PUSH
73685: LD_VAR 0 2
73689: NOT
73690: OR
73691: IFFALSE 73695
// exit ;
73693: GO 74755
// case weapon of us_machine_gun :
73695: LD_VAR 0 2
73699: PUSH
73700: LD_INT 2
73702: DOUBLE
73703: EQUAL
73704: IFTRUE 73708
73706: GO 73738
73708: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
73709: LD_ADDR_VAR 0 3
73713: PUSH
73714: LD_INT 1
73716: PUSH
73717: LD_INT 2
73719: PUSH
73720: LD_INT 3
73722: PUSH
73723: LD_INT 4
73725: PUSH
73726: LD_INT 5
73728: PUSH
73729: EMPTY
73730: LIST
73731: LIST
73732: LIST
73733: LIST
73734: LIST
73735: ST_TO_ADDR
73736: GO 74739
73738: LD_INT 3
73740: DOUBLE
73741: EQUAL
73742: IFTRUE 73746
73744: GO 73776
73746: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
73747: LD_ADDR_VAR 0 3
73751: PUSH
73752: LD_INT 1
73754: PUSH
73755: LD_INT 2
73757: PUSH
73758: LD_INT 3
73760: PUSH
73761: LD_INT 4
73763: PUSH
73764: LD_INT 5
73766: PUSH
73767: EMPTY
73768: LIST
73769: LIST
73770: LIST
73771: LIST
73772: LIST
73773: ST_TO_ADDR
73774: GO 74739
73776: LD_INT 11
73778: DOUBLE
73779: EQUAL
73780: IFTRUE 73784
73782: GO 73814
73784: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
73785: LD_ADDR_VAR 0 3
73789: PUSH
73790: LD_INT 1
73792: PUSH
73793: LD_INT 2
73795: PUSH
73796: LD_INT 3
73798: PUSH
73799: LD_INT 4
73801: PUSH
73802: LD_INT 5
73804: PUSH
73805: EMPTY
73806: LIST
73807: LIST
73808: LIST
73809: LIST
73810: LIST
73811: ST_TO_ADDR
73812: GO 74739
73814: LD_INT 4
73816: DOUBLE
73817: EQUAL
73818: IFTRUE 73822
73820: GO 73848
73822: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
73823: LD_ADDR_VAR 0 3
73827: PUSH
73828: LD_INT 2
73830: PUSH
73831: LD_INT 3
73833: PUSH
73834: LD_INT 4
73836: PUSH
73837: LD_INT 5
73839: PUSH
73840: EMPTY
73841: LIST
73842: LIST
73843: LIST
73844: LIST
73845: ST_TO_ADDR
73846: GO 74739
73848: LD_INT 5
73850: DOUBLE
73851: EQUAL
73852: IFTRUE 73856
73854: GO 73882
73856: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
73857: LD_ADDR_VAR 0 3
73861: PUSH
73862: LD_INT 2
73864: PUSH
73865: LD_INT 3
73867: PUSH
73868: LD_INT 4
73870: PUSH
73871: LD_INT 5
73873: PUSH
73874: EMPTY
73875: LIST
73876: LIST
73877: LIST
73878: LIST
73879: ST_TO_ADDR
73880: GO 74739
73882: LD_INT 9
73884: DOUBLE
73885: EQUAL
73886: IFTRUE 73890
73888: GO 73916
73890: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
73891: LD_ADDR_VAR 0 3
73895: PUSH
73896: LD_INT 2
73898: PUSH
73899: LD_INT 3
73901: PUSH
73902: LD_INT 4
73904: PUSH
73905: LD_INT 5
73907: PUSH
73908: EMPTY
73909: LIST
73910: LIST
73911: LIST
73912: LIST
73913: ST_TO_ADDR
73914: GO 74739
73916: LD_INT 7
73918: DOUBLE
73919: EQUAL
73920: IFTRUE 73924
73922: GO 73950
73924: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
73925: LD_ADDR_VAR 0 3
73929: PUSH
73930: LD_INT 2
73932: PUSH
73933: LD_INT 3
73935: PUSH
73936: LD_INT 4
73938: PUSH
73939: LD_INT 5
73941: PUSH
73942: EMPTY
73943: LIST
73944: LIST
73945: LIST
73946: LIST
73947: ST_TO_ADDR
73948: GO 74739
73950: LD_INT 12
73952: DOUBLE
73953: EQUAL
73954: IFTRUE 73958
73956: GO 73984
73958: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
73959: LD_ADDR_VAR 0 3
73963: PUSH
73964: LD_INT 2
73966: PUSH
73967: LD_INT 3
73969: PUSH
73970: LD_INT 4
73972: PUSH
73973: LD_INT 5
73975: PUSH
73976: EMPTY
73977: LIST
73978: LIST
73979: LIST
73980: LIST
73981: ST_TO_ADDR
73982: GO 74739
73984: LD_INT 13
73986: DOUBLE
73987: EQUAL
73988: IFTRUE 73992
73990: GO 74018
73992: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
73993: LD_ADDR_VAR 0 3
73997: PUSH
73998: LD_INT 2
74000: PUSH
74001: LD_INT 3
74003: PUSH
74004: LD_INT 4
74006: PUSH
74007: LD_INT 5
74009: PUSH
74010: EMPTY
74011: LIST
74012: LIST
74013: LIST
74014: LIST
74015: ST_TO_ADDR
74016: GO 74739
74018: LD_INT 14
74020: DOUBLE
74021: EQUAL
74022: IFTRUE 74026
74024: GO 74044
74026: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
74027: LD_ADDR_VAR 0 3
74031: PUSH
74032: LD_INT 4
74034: PUSH
74035: LD_INT 5
74037: PUSH
74038: EMPTY
74039: LIST
74040: LIST
74041: ST_TO_ADDR
74042: GO 74739
74044: LD_INT 6
74046: DOUBLE
74047: EQUAL
74048: IFTRUE 74052
74050: GO 74070
74052: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
74053: LD_ADDR_VAR 0 3
74057: PUSH
74058: LD_INT 4
74060: PUSH
74061: LD_INT 5
74063: PUSH
74064: EMPTY
74065: LIST
74066: LIST
74067: ST_TO_ADDR
74068: GO 74739
74070: LD_INT 10
74072: DOUBLE
74073: EQUAL
74074: IFTRUE 74078
74076: GO 74096
74078: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
74079: LD_ADDR_VAR 0 3
74083: PUSH
74084: LD_INT 4
74086: PUSH
74087: LD_INT 5
74089: PUSH
74090: EMPTY
74091: LIST
74092: LIST
74093: ST_TO_ADDR
74094: GO 74739
74096: LD_INT 22
74098: DOUBLE
74099: EQUAL
74100: IFTRUE 74104
74102: GO 74130
74104: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
74105: LD_ADDR_VAR 0 3
74109: PUSH
74110: LD_INT 11
74112: PUSH
74113: LD_INT 12
74115: PUSH
74116: LD_INT 13
74118: PUSH
74119: LD_INT 14
74121: PUSH
74122: EMPTY
74123: LIST
74124: LIST
74125: LIST
74126: LIST
74127: ST_TO_ADDR
74128: GO 74739
74130: LD_INT 23
74132: DOUBLE
74133: EQUAL
74134: IFTRUE 74138
74136: GO 74164
74138: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
74139: LD_ADDR_VAR 0 3
74143: PUSH
74144: LD_INT 11
74146: PUSH
74147: LD_INT 12
74149: PUSH
74150: LD_INT 13
74152: PUSH
74153: LD_INT 14
74155: PUSH
74156: EMPTY
74157: LIST
74158: LIST
74159: LIST
74160: LIST
74161: ST_TO_ADDR
74162: GO 74739
74164: LD_INT 24
74166: DOUBLE
74167: EQUAL
74168: IFTRUE 74172
74170: GO 74198
74172: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
74173: LD_ADDR_VAR 0 3
74177: PUSH
74178: LD_INT 11
74180: PUSH
74181: LD_INT 12
74183: PUSH
74184: LD_INT 13
74186: PUSH
74187: LD_INT 14
74189: PUSH
74190: EMPTY
74191: LIST
74192: LIST
74193: LIST
74194: LIST
74195: ST_TO_ADDR
74196: GO 74739
74198: LD_INT 30
74200: DOUBLE
74201: EQUAL
74202: IFTRUE 74206
74204: GO 74232
74206: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
74207: LD_ADDR_VAR 0 3
74211: PUSH
74212: LD_INT 11
74214: PUSH
74215: LD_INT 12
74217: PUSH
74218: LD_INT 13
74220: PUSH
74221: LD_INT 14
74223: PUSH
74224: EMPTY
74225: LIST
74226: LIST
74227: LIST
74228: LIST
74229: ST_TO_ADDR
74230: GO 74739
74232: LD_INT 25
74234: DOUBLE
74235: EQUAL
74236: IFTRUE 74240
74238: GO 74258
74240: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
74241: LD_ADDR_VAR 0 3
74245: PUSH
74246: LD_INT 13
74248: PUSH
74249: LD_INT 14
74251: PUSH
74252: EMPTY
74253: LIST
74254: LIST
74255: ST_TO_ADDR
74256: GO 74739
74258: LD_INT 27
74260: DOUBLE
74261: EQUAL
74262: IFTRUE 74266
74264: GO 74284
74266: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
74267: LD_ADDR_VAR 0 3
74271: PUSH
74272: LD_INT 13
74274: PUSH
74275: LD_INT 14
74277: PUSH
74278: EMPTY
74279: LIST
74280: LIST
74281: ST_TO_ADDR
74282: GO 74739
74284: LD_INT 92
74286: DOUBLE
74287: EQUAL
74288: IFTRUE 74292
74290: GO 74318
74292: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
74293: LD_ADDR_VAR 0 3
74297: PUSH
74298: LD_INT 11
74300: PUSH
74301: LD_INT 12
74303: PUSH
74304: LD_INT 13
74306: PUSH
74307: LD_INT 14
74309: PUSH
74310: EMPTY
74311: LIST
74312: LIST
74313: LIST
74314: LIST
74315: ST_TO_ADDR
74316: GO 74739
74318: LD_INT 28
74320: DOUBLE
74321: EQUAL
74322: IFTRUE 74326
74324: GO 74344
74326: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
74327: LD_ADDR_VAR 0 3
74331: PUSH
74332: LD_INT 13
74334: PUSH
74335: LD_INT 14
74337: PUSH
74338: EMPTY
74339: LIST
74340: LIST
74341: ST_TO_ADDR
74342: GO 74739
74344: LD_INT 29
74346: DOUBLE
74347: EQUAL
74348: IFTRUE 74352
74350: GO 74370
74352: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
74353: LD_ADDR_VAR 0 3
74357: PUSH
74358: LD_INT 13
74360: PUSH
74361: LD_INT 14
74363: PUSH
74364: EMPTY
74365: LIST
74366: LIST
74367: ST_TO_ADDR
74368: GO 74739
74370: LD_INT 31
74372: DOUBLE
74373: EQUAL
74374: IFTRUE 74378
74376: GO 74396
74378: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
74379: LD_ADDR_VAR 0 3
74383: PUSH
74384: LD_INT 13
74386: PUSH
74387: LD_INT 14
74389: PUSH
74390: EMPTY
74391: LIST
74392: LIST
74393: ST_TO_ADDR
74394: GO 74739
74396: LD_INT 26
74398: DOUBLE
74399: EQUAL
74400: IFTRUE 74404
74402: GO 74422
74404: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
74405: LD_ADDR_VAR 0 3
74409: PUSH
74410: LD_INT 13
74412: PUSH
74413: LD_INT 14
74415: PUSH
74416: EMPTY
74417: LIST
74418: LIST
74419: ST_TO_ADDR
74420: GO 74739
74422: LD_INT 42
74424: DOUBLE
74425: EQUAL
74426: IFTRUE 74430
74428: GO 74456
74430: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
74431: LD_ADDR_VAR 0 3
74435: PUSH
74436: LD_INT 21
74438: PUSH
74439: LD_INT 22
74441: PUSH
74442: LD_INT 23
74444: PUSH
74445: LD_INT 24
74447: PUSH
74448: EMPTY
74449: LIST
74450: LIST
74451: LIST
74452: LIST
74453: ST_TO_ADDR
74454: GO 74739
74456: LD_INT 43
74458: DOUBLE
74459: EQUAL
74460: IFTRUE 74464
74462: GO 74490
74464: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
74465: LD_ADDR_VAR 0 3
74469: PUSH
74470: LD_INT 21
74472: PUSH
74473: LD_INT 22
74475: PUSH
74476: LD_INT 23
74478: PUSH
74479: LD_INT 24
74481: PUSH
74482: EMPTY
74483: LIST
74484: LIST
74485: LIST
74486: LIST
74487: ST_TO_ADDR
74488: GO 74739
74490: LD_INT 44
74492: DOUBLE
74493: EQUAL
74494: IFTRUE 74498
74496: GO 74524
74498: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
74499: LD_ADDR_VAR 0 3
74503: PUSH
74504: LD_INT 21
74506: PUSH
74507: LD_INT 22
74509: PUSH
74510: LD_INT 23
74512: PUSH
74513: LD_INT 24
74515: PUSH
74516: EMPTY
74517: LIST
74518: LIST
74519: LIST
74520: LIST
74521: ST_TO_ADDR
74522: GO 74739
74524: LD_INT 45
74526: DOUBLE
74527: EQUAL
74528: IFTRUE 74532
74530: GO 74558
74532: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
74533: LD_ADDR_VAR 0 3
74537: PUSH
74538: LD_INT 21
74540: PUSH
74541: LD_INT 22
74543: PUSH
74544: LD_INT 23
74546: PUSH
74547: LD_INT 24
74549: PUSH
74550: EMPTY
74551: LIST
74552: LIST
74553: LIST
74554: LIST
74555: ST_TO_ADDR
74556: GO 74739
74558: LD_INT 49
74560: DOUBLE
74561: EQUAL
74562: IFTRUE 74566
74564: GO 74592
74566: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
74567: LD_ADDR_VAR 0 3
74571: PUSH
74572: LD_INT 21
74574: PUSH
74575: LD_INT 22
74577: PUSH
74578: LD_INT 23
74580: PUSH
74581: LD_INT 24
74583: PUSH
74584: EMPTY
74585: LIST
74586: LIST
74587: LIST
74588: LIST
74589: ST_TO_ADDR
74590: GO 74739
74592: LD_INT 51
74594: DOUBLE
74595: EQUAL
74596: IFTRUE 74600
74598: GO 74626
74600: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
74601: LD_ADDR_VAR 0 3
74605: PUSH
74606: LD_INT 21
74608: PUSH
74609: LD_INT 22
74611: PUSH
74612: LD_INT 23
74614: PUSH
74615: LD_INT 24
74617: PUSH
74618: EMPTY
74619: LIST
74620: LIST
74621: LIST
74622: LIST
74623: ST_TO_ADDR
74624: GO 74739
74626: LD_INT 52
74628: DOUBLE
74629: EQUAL
74630: IFTRUE 74634
74632: GO 74660
74634: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
74635: LD_ADDR_VAR 0 3
74639: PUSH
74640: LD_INT 21
74642: PUSH
74643: LD_INT 22
74645: PUSH
74646: LD_INT 23
74648: PUSH
74649: LD_INT 24
74651: PUSH
74652: EMPTY
74653: LIST
74654: LIST
74655: LIST
74656: LIST
74657: ST_TO_ADDR
74658: GO 74739
74660: LD_INT 53
74662: DOUBLE
74663: EQUAL
74664: IFTRUE 74668
74666: GO 74686
74668: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
74669: LD_ADDR_VAR 0 3
74673: PUSH
74674: LD_INT 23
74676: PUSH
74677: LD_INT 24
74679: PUSH
74680: EMPTY
74681: LIST
74682: LIST
74683: ST_TO_ADDR
74684: GO 74739
74686: LD_INT 46
74688: DOUBLE
74689: EQUAL
74690: IFTRUE 74694
74692: GO 74712
74694: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
74695: LD_ADDR_VAR 0 3
74699: PUSH
74700: LD_INT 23
74702: PUSH
74703: LD_INT 24
74705: PUSH
74706: EMPTY
74707: LIST
74708: LIST
74709: ST_TO_ADDR
74710: GO 74739
74712: LD_INT 47
74714: DOUBLE
74715: EQUAL
74716: IFTRUE 74720
74718: GO 74738
74720: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
74721: LD_ADDR_VAR 0 3
74725: PUSH
74726: LD_INT 23
74728: PUSH
74729: LD_INT 24
74731: PUSH
74732: EMPTY
74733: LIST
74734: LIST
74735: ST_TO_ADDR
74736: GO 74739
74738: POP
// result := ( chassis in result ) ;
74739: LD_ADDR_VAR 0 3
74743: PUSH
74744: LD_VAR 0 1
74748: PUSH
74749: LD_VAR 0 3
74753: IN
74754: ST_TO_ADDR
// end ;
74755: LD_VAR 0 3
74759: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
74760: LD_INT 0
74762: PPUSH
74763: PPUSH
74764: PPUSH
74765: PPUSH
74766: PPUSH
74767: PPUSH
74768: PPUSH
// result := array ;
74769: LD_ADDR_VAR 0 5
74773: PUSH
74774: LD_VAR 0 1
74778: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
74779: LD_VAR 0 1
74783: NOT
74784: PUSH
74785: LD_VAR 0 2
74789: NOT
74790: OR
74791: PUSH
74792: LD_VAR 0 3
74796: NOT
74797: OR
74798: PUSH
74799: LD_VAR 0 2
74803: PUSH
74804: LD_VAR 0 1
74808: GREATER
74809: OR
74810: PUSH
74811: LD_VAR 0 3
74815: PUSH
74816: LD_VAR 0 1
74820: GREATER
74821: OR
74822: IFFALSE 74826
// exit ;
74824: GO 75122
// if direction then
74826: LD_VAR 0 4
74830: IFFALSE 74894
// begin d := 1 ;
74832: LD_ADDR_VAR 0 9
74836: PUSH
74837: LD_INT 1
74839: ST_TO_ADDR
// if i_from > i_to then
74840: LD_VAR 0 2
74844: PUSH
74845: LD_VAR 0 3
74849: GREATER
74850: IFFALSE 74876
// length := ( array - i_from ) + i_to else
74852: LD_ADDR_VAR 0 11
74856: PUSH
74857: LD_VAR 0 1
74861: PUSH
74862: LD_VAR 0 2
74866: MINUS
74867: PUSH
74868: LD_VAR 0 3
74872: PLUS
74873: ST_TO_ADDR
74874: GO 74892
// length := i_to - i_from ;
74876: LD_ADDR_VAR 0 11
74880: PUSH
74881: LD_VAR 0 3
74885: PUSH
74886: LD_VAR 0 2
74890: MINUS
74891: ST_TO_ADDR
// end else
74892: GO 74955
// begin d := - 1 ;
74894: LD_ADDR_VAR 0 9
74898: PUSH
74899: LD_INT 1
74901: NEG
74902: ST_TO_ADDR
// if i_from > i_to then
74903: LD_VAR 0 2
74907: PUSH
74908: LD_VAR 0 3
74912: GREATER
74913: IFFALSE 74933
// length := i_from - i_to else
74915: LD_ADDR_VAR 0 11
74919: PUSH
74920: LD_VAR 0 2
74924: PUSH
74925: LD_VAR 0 3
74929: MINUS
74930: ST_TO_ADDR
74931: GO 74955
// length := ( array - i_to ) + i_from ;
74933: LD_ADDR_VAR 0 11
74937: PUSH
74938: LD_VAR 0 1
74942: PUSH
74943: LD_VAR 0 3
74947: MINUS
74948: PUSH
74949: LD_VAR 0 2
74953: PLUS
74954: ST_TO_ADDR
// end ; if not length then
74955: LD_VAR 0 11
74959: NOT
74960: IFFALSE 74964
// exit ;
74962: GO 75122
// tmp := array ;
74964: LD_ADDR_VAR 0 10
74968: PUSH
74969: LD_VAR 0 1
74973: ST_TO_ADDR
// for i = 1 to length do
74974: LD_ADDR_VAR 0 6
74978: PUSH
74979: DOUBLE
74980: LD_INT 1
74982: DEC
74983: ST_TO_ADDR
74984: LD_VAR 0 11
74988: PUSH
74989: FOR_TO
74990: IFFALSE 75110
// begin for j = 1 to array do
74992: LD_ADDR_VAR 0 7
74996: PUSH
74997: DOUBLE
74998: LD_INT 1
75000: DEC
75001: ST_TO_ADDR
75002: LD_VAR 0 1
75006: PUSH
75007: FOR_TO
75008: IFFALSE 75096
// begin k := j + d ;
75010: LD_ADDR_VAR 0 8
75014: PUSH
75015: LD_VAR 0 7
75019: PUSH
75020: LD_VAR 0 9
75024: PLUS
75025: ST_TO_ADDR
// if k > array then
75026: LD_VAR 0 8
75030: PUSH
75031: LD_VAR 0 1
75035: GREATER
75036: IFFALSE 75046
// k := 1 ;
75038: LD_ADDR_VAR 0 8
75042: PUSH
75043: LD_INT 1
75045: ST_TO_ADDR
// if not k then
75046: LD_VAR 0 8
75050: NOT
75051: IFFALSE 75063
// k := array ;
75053: LD_ADDR_VAR 0 8
75057: PUSH
75058: LD_VAR 0 1
75062: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
75063: LD_ADDR_VAR 0 10
75067: PUSH
75068: LD_VAR 0 10
75072: PPUSH
75073: LD_VAR 0 8
75077: PPUSH
75078: LD_VAR 0 1
75082: PUSH
75083: LD_VAR 0 7
75087: ARRAY
75088: PPUSH
75089: CALL_OW 1
75093: ST_TO_ADDR
// end ;
75094: GO 75007
75096: POP
75097: POP
// array := tmp ;
75098: LD_ADDR_VAR 0 1
75102: PUSH
75103: LD_VAR 0 10
75107: ST_TO_ADDR
// end ;
75108: GO 74989
75110: POP
75111: POP
// result := array ;
75112: LD_ADDR_VAR 0 5
75116: PUSH
75117: LD_VAR 0 1
75121: ST_TO_ADDR
// end ;
75122: LD_VAR 0 5
75126: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
75127: LD_INT 0
75129: PPUSH
75130: PPUSH
// result := 0 ;
75131: LD_ADDR_VAR 0 3
75135: PUSH
75136: LD_INT 0
75138: ST_TO_ADDR
// if not array or not value in array then
75139: LD_VAR 0 1
75143: NOT
75144: PUSH
75145: LD_VAR 0 2
75149: PUSH
75150: LD_VAR 0 1
75154: IN
75155: NOT
75156: OR
75157: IFFALSE 75161
// exit ;
75159: GO 75215
// for i = 1 to array do
75161: LD_ADDR_VAR 0 4
75165: PUSH
75166: DOUBLE
75167: LD_INT 1
75169: DEC
75170: ST_TO_ADDR
75171: LD_VAR 0 1
75175: PUSH
75176: FOR_TO
75177: IFFALSE 75213
// if value = array [ i ] then
75179: LD_VAR 0 2
75183: PUSH
75184: LD_VAR 0 1
75188: PUSH
75189: LD_VAR 0 4
75193: ARRAY
75194: EQUAL
75195: IFFALSE 75211
// begin result := i ;
75197: LD_ADDR_VAR 0 3
75201: PUSH
75202: LD_VAR 0 4
75206: ST_TO_ADDR
// exit ;
75207: POP
75208: POP
75209: GO 75215
// end ;
75211: GO 75176
75213: POP
75214: POP
// end ;
75215: LD_VAR 0 3
75219: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
75220: LD_INT 0
75222: PPUSH
// vc_chassis := chassis ;
75223: LD_ADDR_OWVAR 37
75227: PUSH
75228: LD_VAR 0 1
75232: ST_TO_ADDR
// vc_engine := engine ;
75233: LD_ADDR_OWVAR 39
75237: PUSH
75238: LD_VAR 0 2
75242: ST_TO_ADDR
// vc_control := control ;
75243: LD_ADDR_OWVAR 38
75247: PUSH
75248: LD_VAR 0 3
75252: ST_TO_ADDR
// vc_weapon := weapon ;
75253: LD_ADDR_OWVAR 40
75257: PUSH
75258: LD_VAR 0 4
75262: ST_TO_ADDR
// vc_fuel_battery := fuel ;
75263: LD_ADDR_OWVAR 41
75267: PUSH
75268: LD_VAR 0 5
75272: ST_TO_ADDR
// end ;
75273: LD_VAR 0 6
75277: RET
// export function WantPlant ( unit ) ; var task ; begin
75278: LD_INT 0
75280: PPUSH
75281: PPUSH
// result := false ;
75282: LD_ADDR_VAR 0 2
75286: PUSH
75287: LD_INT 0
75289: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
75290: LD_ADDR_VAR 0 3
75294: PUSH
75295: LD_VAR 0 1
75299: PPUSH
75300: CALL_OW 437
75304: ST_TO_ADDR
// if task then
75305: LD_VAR 0 3
75309: IFFALSE 75337
// if task [ 1 ] [ 1 ] = p then
75311: LD_VAR 0 3
75315: PUSH
75316: LD_INT 1
75318: ARRAY
75319: PUSH
75320: LD_INT 1
75322: ARRAY
75323: PUSH
75324: LD_STRING p
75326: EQUAL
75327: IFFALSE 75337
// result := true ;
75329: LD_ADDR_VAR 0 2
75333: PUSH
75334: LD_INT 1
75336: ST_TO_ADDR
// end ;
75337: LD_VAR 0 2
75341: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
75342: LD_INT 0
75344: PPUSH
75345: PPUSH
75346: PPUSH
75347: PPUSH
// if pos < 1 then
75348: LD_VAR 0 2
75352: PUSH
75353: LD_INT 1
75355: LESS
75356: IFFALSE 75360
// exit ;
75358: GO 75663
// if pos = 1 then
75360: LD_VAR 0 2
75364: PUSH
75365: LD_INT 1
75367: EQUAL
75368: IFFALSE 75401
// result := Replace ( arr , pos [ 1 ] , value ) else
75370: LD_ADDR_VAR 0 4
75374: PUSH
75375: LD_VAR 0 1
75379: PPUSH
75380: LD_VAR 0 2
75384: PUSH
75385: LD_INT 1
75387: ARRAY
75388: PPUSH
75389: LD_VAR 0 3
75393: PPUSH
75394: CALL_OW 1
75398: ST_TO_ADDR
75399: GO 75663
// begin tmp := arr ;
75401: LD_ADDR_VAR 0 6
75405: PUSH
75406: LD_VAR 0 1
75410: ST_TO_ADDR
// s_arr := [ tmp ] ;
75411: LD_ADDR_VAR 0 7
75415: PUSH
75416: LD_VAR 0 6
75420: PUSH
75421: EMPTY
75422: LIST
75423: ST_TO_ADDR
// for i = 1 to pos - 1 do
75424: LD_ADDR_VAR 0 5
75428: PUSH
75429: DOUBLE
75430: LD_INT 1
75432: DEC
75433: ST_TO_ADDR
75434: LD_VAR 0 2
75438: PUSH
75439: LD_INT 1
75441: MINUS
75442: PUSH
75443: FOR_TO
75444: IFFALSE 75489
// begin tmp := tmp [ pos [ i ] ] ;
75446: LD_ADDR_VAR 0 6
75450: PUSH
75451: LD_VAR 0 6
75455: PUSH
75456: LD_VAR 0 2
75460: PUSH
75461: LD_VAR 0 5
75465: ARRAY
75466: ARRAY
75467: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
75468: LD_ADDR_VAR 0 7
75472: PUSH
75473: LD_VAR 0 7
75477: PUSH
75478: LD_VAR 0 6
75482: PUSH
75483: EMPTY
75484: LIST
75485: ADD
75486: ST_TO_ADDR
// end ;
75487: GO 75443
75489: POP
75490: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
75491: LD_ADDR_VAR 0 6
75495: PUSH
75496: LD_VAR 0 6
75500: PPUSH
75501: LD_VAR 0 2
75505: PUSH
75506: LD_VAR 0 2
75510: ARRAY
75511: PPUSH
75512: LD_VAR 0 3
75516: PPUSH
75517: CALL_OW 1
75521: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
75522: LD_ADDR_VAR 0 7
75526: PUSH
75527: LD_VAR 0 7
75531: PPUSH
75532: LD_VAR 0 7
75536: PPUSH
75537: LD_VAR 0 6
75541: PPUSH
75542: CALL_OW 1
75546: ST_TO_ADDR
// for i = s_arr downto 2 do
75547: LD_ADDR_VAR 0 5
75551: PUSH
75552: DOUBLE
75553: LD_VAR 0 7
75557: INC
75558: ST_TO_ADDR
75559: LD_INT 2
75561: PUSH
75562: FOR_DOWNTO
75563: IFFALSE 75647
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
75565: LD_ADDR_VAR 0 6
75569: PUSH
75570: LD_VAR 0 7
75574: PUSH
75575: LD_VAR 0 5
75579: PUSH
75580: LD_INT 1
75582: MINUS
75583: ARRAY
75584: PPUSH
75585: LD_VAR 0 2
75589: PUSH
75590: LD_VAR 0 5
75594: PUSH
75595: LD_INT 1
75597: MINUS
75598: ARRAY
75599: PPUSH
75600: LD_VAR 0 7
75604: PUSH
75605: LD_VAR 0 5
75609: ARRAY
75610: PPUSH
75611: CALL_OW 1
75615: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
75616: LD_ADDR_VAR 0 7
75620: PUSH
75621: LD_VAR 0 7
75625: PPUSH
75626: LD_VAR 0 5
75630: PUSH
75631: LD_INT 1
75633: MINUS
75634: PPUSH
75635: LD_VAR 0 6
75639: PPUSH
75640: CALL_OW 1
75644: ST_TO_ADDR
// end ;
75645: GO 75562
75647: POP
75648: POP
// result := s_arr [ 1 ] ;
75649: LD_ADDR_VAR 0 4
75653: PUSH
75654: LD_VAR 0 7
75658: PUSH
75659: LD_INT 1
75661: ARRAY
75662: ST_TO_ADDR
// end ; end ;
75663: LD_VAR 0 4
75667: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
75668: LD_INT 0
75670: PPUSH
75671: PPUSH
// if not list then
75672: LD_VAR 0 1
75676: NOT
75677: IFFALSE 75681
// exit ;
75679: GO 75772
// i := list [ pos1 ] ;
75681: LD_ADDR_VAR 0 5
75685: PUSH
75686: LD_VAR 0 1
75690: PUSH
75691: LD_VAR 0 2
75695: ARRAY
75696: ST_TO_ADDR
// if not i then
75697: LD_VAR 0 5
75701: NOT
75702: IFFALSE 75706
// exit ;
75704: GO 75772
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
75706: LD_ADDR_VAR 0 1
75710: PUSH
75711: LD_VAR 0 1
75715: PPUSH
75716: LD_VAR 0 2
75720: PPUSH
75721: LD_VAR 0 1
75725: PUSH
75726: LD_VAR 0 3
75730: ARRAY
75731: PPUSH
75732: CALL_OW 1
75736: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
75737: LD_ADDR_VAR 0 1
75741: PUSH
75742: LD_VAR 0 1
75746: PPUSH
75747: LD_VAR 0 3
75751: PPUSH
75752: LD_VAR 0 5
75756: PPUSH
75757: CALL_OW 1
75761: ST_TO_ADDR
// result := list ;
75762: LD_ADDR_VAR 0 4
75766: PUSH
75767: LD_VAR 0 1
75771: ST_TO_ADDR
// end ;
75772: LD_VAR 0 4
75776: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
75777: LD_INT 0
75779: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
75780: LD_ADDR_VAR 0 5
75784: PUSH
75785: LD_VAR 0 1
75789: PPUSH
75790: CALL_OW 250
75794: PPUSH
75795: LD_VAR 0 1
75799: PPUSH
75800: CALL_OW 251
75804: PPUSH
75805: LD_VAR 0 2
75809: PPUSH
75810: LD_VAR 0 3
75814: PPUSH
75815: LD_VAR 0 4
75819: PPUSH
75820: CALL 76198 0 5
75824: ST_TO_ADDR
// end ;
75825: LD_VAR 0 5
75829: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
75830: LD_INT 0
75832: PPUSH
75833: PPUSH
75834: PPUSH
75835: PPUSH
// if not list or not unit then
75836: LD_VAR 0 2
75840: NOT
75841: PUSH
75842: LD_VAR 0 1
75846: NOT
75847: OR
75848: IFFALSE 75852
// exit ;
75850: GO 76193
// result := [ ] ;
75852: LD_ADDR_VAR 0 5
75856: PUSH
75857: EMPTY
75858: ST_TO_ADDR
// for i in list do
75859: LD_ADDR_VAR 0 6
75863: PUSH
75864: LD_VAR 0 2
75868: PUSH
75869: FOR_IN
75870: IFFALSE 76088
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
75872: LD_ADDR_VAR 0 8
75876: PUSH
75877: LD_VAR 0 1
75881: PPUSH
75882: LD_VAR 0 6
75886: PUSH
75887: LD_INT 1
75889: ARRAY
75890: PPUSH
75891: LD_VAR 0 6
75895: PUSH
75896: LD_INT 2
75898: ARRAY
75899: PPUSH
75900: CALL_OW 297
75904: ST_TO_ADDR
// if not Count ( result ) then
75905: LD_VAR 0 5
75909: PPUSH
75910: CALL 72482 0 1
75914: NOT
75915: IFFALSE 75948
// begin result := Join ( result , [ i , tmp ] ) ;
75917: LD_ADDR_VAR 0 5
75921: PUSH
75922: LD_VAR 0 5
75926: PPUSH
75927: LD_VAR 0 6
75931: PUSH
75932: LD_VAR 0 8
75936: PUSH
75937: EMPTY
75938: LIST
75939: LIST
75940: PPUSH
75941: CALL 108091 0 2
75945: ST_TO_ADDR
// continue ;
75946: GO 75869
// end ; if result [ result ] [ 2 ] <= tmp then
75948: LD_VAR 0 5
75952: PUSH
75953: LD_VAR 0 5
75957: ARRAY
75958: PUSH
75959: LD_INT 2
75961: ARRAY
75962: PUSH
75963: LD_VAR 0 8
75967: LESSEQUAL
75968: IFFALSE 76001
// result := Join ( result , [ i , tmp ] ) else
75970: LD_ADDR_VAR 0 5
75974: PUSH
75975: LD_VAR 0 5
75979: PPUSH
75980: LD_VAR 0 6
75984: PUSH
75985: LD_VAR 0 8
75989: PUSH
75990: EMPTY
75991: LIST
75992: LIST
75993: PPUSH
75994: CALL 108091 0 2
75998: ST_TO_ADDR
75999: GO 76086
// begin for j := 1 to Count ( result ) do
76001: LD_ADDR_VAR 0 7
76005: PUSH
76006: DOUBLE
76007: LD_INT 1
76009: DEC
76010: ST_TO_ADDR
76011: LD_VAR 0 5
76015: PPUSH
76016: CALL 72482 0 1
76020: PUSH
76021: FOR_TO
76022: IFFALSE 76084
// begin if tmp < result [ j ] [ 2 ] then
76024: LD_VAR 0 8
76028: PUSH
76029: LD_VAR 0 5
76033: PUSH
76034: LD_VAR 0 7
76038: ARRAY
76039: PUSH
76040: LD_INT 2
76042: ARRAY
76043: LESS
76044: IFFALSE 76082
// begin result := Insert ( result , j , [ i , tmp ] ) ;
76046: LD_ADDR_VAR 0 5
76050: PUSH
76051: LD_VAR 0 5
76055: PPUSH
76056: LD_VAR 0 7
76060: PPUSH
76061: LD_VAR 0 6
76065: PUSH
76066: LD_VAR 0 8
76070: PUSH
76071: EMPTY
76072: LIST
76073: LIST
76074: PPUSH
76075: CALL_OW 2
76079: ST_TO_ADDR
// break ;
76080: GO 76084
// end ; end ;
76082: GO 76021
76084: POP
76085: POP
// end ; end ;
76086: GO 75869
76088: POP
76089: POP
// if result and not asc then
76090: LD_VAR 0 5
76094: PUSH
76095: LD_VAR 0 3
76099: NOT
76100: AND
76101: IFFALSE 76118
// result := ReverseArray ( result ) ;
76103: LD_ADDR_VAR 0 5
76107: PUSH
76108: LD_VAR 0 5
76112: PPUSH
76113: CALL 103358 0 1
76117: ST_TO_ADDR
// tmp := [ ] ;
76118: LD_ADDR_VAR 0 8
76122: PUSH
76123: EMPTY
76124: ST_TO_ADDR
// if mode then
76125: LD_VAR 0 4
76129: IFFALSE 76193
// begin for i := 1 to result do
76131: LD_ADDR_VAR 0 6
76135: PUSH
76136: DOUBLE
76137: LD_INT 1
76139: DEC
76140: ST_TO_ADDR
76141: LD_VAR 0 5
76145: PUSH
76146: FOR_TO
76147: IFFALSE 76181
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
76149: LD_ADDR_VAR 0 8
76153: PUSH
76154: LD_VAR 0 8
76158: PPUSH
76159: LD_VAR 0 5
76163: PUSH
76164: LD_VAR 0 6
76168: ARRAY
76169: PUSH
76170: LD_INT 1
76172: ARRAY
76173: PPUSH
76174: CALL 108091 0 2
76178: ST_TO_ADDR
76179: GO 76146
76181: POP
76182: POP
// result := tmp ;
76183: LD_ADDR_VAR 0 5
76187: PUSH
76188: LD_VAR 0 8
76192: ST_TO_ADDR
// end ; end ;
76193: LD_VAR 0 5
76197: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
76198: LD_INT 0
76200: PPUSH
76201: PPUSH
76202: PPUSH
76203: PPUSH
// if not list then
76204: LD_VAR 0 3
76208: NOT
76209: IFFALSE 76213
// exit ;
76211: GO 76601
// result := [ ] ;
76213: LD_ADDR_VAR 0 6
76217: PUSH
76218: EMPTY
76219: ST_TO_ADDR
// for i in list do
76220: LD_ADDR_VAR 0 7
76224: PUSH
76225: LD_VAR 0 3
76229: PUSH
76230: FOR_IN
76231: IFFALSE 76433
// begin tmp := GetDistUnitXY ( i , x , y ) ;
76233: LD_ADDR_VAR 0 9
76237: PUSH
76238: LD_VAR 0 7
76242: PPUSH
76243: LD_VAR 0 1
76247: PPUSH
76248: LD_VAR 0 2
76252: PPUSH
76253: CALL_OW 297
76257: ST_TO_ADDR
// if not result then
76258: LD_VAR 0 6
76262: NOT
76263: IFFALSE 76289
// result := [ [ i , tmp ] ] else
76265: LD_ADDR_VAR 0 6
76269: PUSH
76270: LD_VAR 0 7
76274: PUSH
76275: LD_VAR 0 9
76279: PUSH
76280: EMPTY
76281: LIST
76282: LIST
76283: PUSH
76284: EMPTY
76285: LIST
76286: ST_TO_ADDR
76287: GO 76431
// begin if result [ result ] [ 2 ] <= tmp then
76289: LD_VAR 0 6
76293: PUSH
76294: LD_VAR 0 6
76298: ARRAY
76299: PUSH
76300: LD_INT 2
76302: ARRAY
76303: PUSH
76304: LD_VAR 0 9
76308: LESSEQUAL
76309: IFFALSE 76351
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
76311: LD_ADDR_VAR 0 6
76315: PUSH
76316: LD_VAR 0 6
76320: PPUSH
76321: LD_VAR 0 6
76325: PUSH
76326: LD_INT 1
76328: PLUS
76329: PPUSH
76330: LD_VAR 0 7
76334: PUSH
76335: LD_VAR 0 9
76339: PUSH
76340: EMPTY
76341: LIST
76342: LIST
76343: PPUSH
76344: CALL_OW 2
76348: ST_TO_ADDR
76349: GO 76431
// for j := 1 to result do
76351: LD_ADDR_VAR 0 8
76355: PUSH
76356: DOUBLE
76357: LD_INT 1
76359: DEC
76360: ST_TO_ADDR
76361: LD_VAR 0 6
76365: PUSH
76366: FOR_TO
76367: IFFALSE 76429
// begin if tmp < result [ j ] [ 2 ] then
76369: LD_VAR 0 9
76373: PUSH
76374: LD_VAR 0 6
76378: PUSH
76379: LD_VAR 0 8
76383: ARRAY
76384: PUSH
76385: LD_INT 2
76387: ARRAY
76388: LESS
76389: IFFALSE 76427
// begin result := Insert ( result , j , [ i , tmp ] ) ;
76391: LD_ADDR_VAR 0 6
76395: PUSH
76396: LD_VAR 0 6
76400: PPUSH
76401: LD_VAR 0 8
76405: PPUSH
76406: LD_VAR 0 7
76410: PUSH
76411: LD_VAR 0 9
76415: PUSH
76416: EMPTY
76417: LIST
76418: LIST
76419: PPUSH
76420: CALL_OW 2
76424: ST_TO_ADDR
// break ;
76425: GO 76429
// end ; end ;
76427: GO 76366
76429: POP
76430: POP
// end ; end ;
76431: GO 76230
76433: POP
76434: POP
// if result and not asc then
76435: LD_VAR 0 6
76439: PUSH
76440: LD_VAR 0 4
76444: NOT
76445: AND
76446: IFFALSE 76521
// begin tmp := result ;
76448: LD_ADDR_VAR 0 9
76452: PUSH
76453: LD_VAR 0 6
76457: ST_TO_ADDR
// for i = tmp downto 1 do
76458: LD_ADDR_VAR 0 7
76462: PUSH
76463: DOUBLE
76464: LD_VAR 0 9
76468: INC
76469: ST_TO_ADDR
76470: LD_INT 1
76472: PUSH
76473: FOR_DOWNTO
76474: IFFALSE 76519
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
76476: LD_ADDR_VAR 0 6
76480: PUSH
76481: LD_VAR 0 6
76485: PPUSH
76486: LD_VAR 0 9
76490: PUSH
76491: LD_VAR 0 7
76495: MINUS
76496: PUSH
76497: LD_INT 1
76499: PLUS
76500: PPUSH
76501: LD_VAR 0 9
76505: PUSH
76506: LD_VAR 0 7
76510: ARRAY
76511: PPUSH
76512: CALL_OW 1
76516: ST_TO_ADDR
76517: GO 76473
76519: POP
76520: POP
// end ; tmp := [ ] ;
76521: LD_ADDR_VAR 0 9
76525: PUSH
76526: EMPTY
76527: ST_TO_ADDR
// if mode then
76528: LD_VAR 0 5
76532: IFFALSE 76601
// begin for i = 1 to result do
76534: LD_ADDR_VAR 0 7
76538: PUSH
76539: DOUBLE
76540: LD_INT 1
76542: DEC
76543: ST_TO_ADDR
76544: LD_VAR 0 6
76548: PUSH
76549: FOR_TO
76550: IFFALSE 76589
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
76552: LD_ADDR_VAR 0 9
76556: PUSH
76557: LD_VAR 0 9
76561: PPUSH
76562: LD_VAR 0 7
76566: PPUSH
76567: LD_VAR 0 6
76571: PUSH
76572: LD_VAR 0 7
76576: ARRAY
76577: PUSH
76578: LD_INT 1
76580: ARRAY
76581: PPUSH
76582: CALL_OW 1
76586: ST_TO_ADDR
76587: GO 76549
76589: POP
76590: POP
// result := tmp ;
76591: LD_ADDR_VAR 0 6
76595: PUSH
76596: LD_VAR 0 9
76600: ST_TO_ADDR
// end ; end ;
76601: LD_VAR 0 6
76605: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
76606: LD_INT 0
76608: PPUSH
76609: PPUSH
76610: PPUSH
76611: PPUSH
76612: PPUSH
76613: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
76614: LD_ADDR_VAR 0 5
76618: PUSH
76619: LD_INT 0
76621: PUSH
76622: LD_INT 0
76624: PUSH
76625: LD_INT 0
76627: PUSH
76628: EMPTY
76629: PUSH
76630: EMPTY
76631: LIST
76632: LIST
76633: LIST
76634: LIST
76635: ST_TO_ADDR
// if not x or not y then
76636: LD_VAR 0 2
76640: NOT
76641: PUSH
76642: LD_VAR 0 3
76646: NOT
76647: OR
76648: IFFALSE 76652
// exit ;
76650: GO 78302
// if not range then
76652: LD_VAR 0 4
76656: NOT
76657: IFFALSE 76667
// range := 10 ;
76659: LD_ADDR_VAR 0 4
76663: PUSH
76664: LD_INT 10
76666: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
76667: LD_ADDR_VAR 0 8
76671: PUSH
76672: LD_INT 81
76674: PUSH
76675: LD_VAR 0 1
76679: PUSH
76680: EMPTY
76681: LIST
76682: LIST
76683: PUSH
76684: LD_INT 92
76686: PUSH
76687: LD_VAR 0 2
76691: PUSH
76692: LD_VAR 0 3
76696: PUSH
76697: LD_VAR 0 4
76701: PUSH
76702: EMPTY
76703: LIST
76704: LIST
76705: LIST
76706: LIST
76707: PUSH
76708: LD_INT 3
76710: PUSH
76711: LD_INT 21
76713: PUSH
76714: LD_INT 3
76716: PUSH
76717: EMPTY
76718: LIST
76719: LIST
76720: PUSH
76721: EMPTY
76722: LIST
76723: LIST
76724: PUSH
76725: EMPTY
76726: LIST
76727: LIST
76728: LIST
76729: PPUSH
76730: CALL_OW 69
76734: ST_TO_ADDR
// if not tmp then
76735: LD_VAR 0 8
76739: NOT
76740: IFFALSE 76744
// exit ;
76742: GO 78302
// for i in tmp do
76744: LD_ADDR_VAR 0 6
76748: PUSH
76749: LD_VAR 0 8
76753: PUSH
76754: FOR_IN
76755: IFFALSE 78277
// begin points := [ 0 , 0 , 0 ] ;
76757: LD_ADDR_VAR 0 9
76761: PUSH
76762: LD_INT 0
76764: PUSH
76765: LD_INT 0
76767: PUSH
76768: LD_INT 0
76770: PUSH
76771: EMPTY
76772: LIST
76773: LIST
76774: LIST
76775: ST_TO_ADDR
// bpoints := 1 ;
76776: LD_ADDR_VAR 0 10
76780: PUSH
76781: LD_INT 1
76783: ST_TO_ADDR
// case GetType ( i ) of unit_human :
76784: LD_VAR 0 6
76788: PPUSH
76789: CALL_OW 247
76793: PUSH
76794: LD_INT 1
76796: DOUBLE
76797: EQUAL
76798: IFTRUE 76802
76800: GO 77380
76802: POP
// begin if GetClass ( i ) = 1 then
76803: LD_VAR 0 6
76807: PPUSH
76808: CALL_OW 257
76812: PUSH
76813: LD_INT 1
76815: EQUAL
76816: IFFALSE 76837
// points := [ 10 , 5 , 3 ] ;
76818: LD_ADDR_VAR 0 9
76822: PUSH
76823: LD_INT 10
76825: PUSH
76826: LD_INT 5
76828: PUSH
76829: LD_INT 3
76831: PUSH
76832: EMPTY
76833: LIST
76834: LIST
76835: LIST
76836: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
76837: LD_VAR 0 6
76841: PPUSH
76842: CALL_OW 257
76846: PUSH
76847: LD_INT 2
76849: PUSH
76850: LD_INT 3
76852: PUSH
76853: LD_INT 4
76855: PUSH
76856: EMPTY
76857: LIST
76858: LIST
76859: LIST
76860: IN
76861: IFFALSE 76882
// points := [ 3 , 2 , 1 ] ;
76863: LD_ADDR_VAR 0 9
76867: PUSH
76868: LD_INT 3
76870: PUSH
76871: LD_INT 2
76873: PUSH
76874: LD_INT 1
76876: PUSH
76877: EMPTY
76878: LIST
76879: LIST
76880: LIST
76881: ST_TO_ADDR
// if GetClass ( i ) = 5 then
76882: LD_VAR 0 6
76886: PPUSH
76887: CALL_OW 257
76891: PUSH
76892: LD_INT 5
76894: EQUAL
76895: IFFALSE 76916
// points := [ 130 , 5 , 2 ] ;
76897: LD_ADDR_VAR 0 9
76901: PUSH
76902: LD_INT 130
76904: PUSH
76905: LD_INT 5
76907: PUSH
76908: LD_INT 2
76910: PUSH
76911: EMPTY
76912: LIST
76913: LIST
76914: LIST
76915: ST_TO_ADDR
// if GetClass ( i ) = 8 then
76916: LD_VAR 0 6
76920: PPUSH
76921: CALL_OW 257
76925: PUSH
76926: LD_INT 8
76928: EQUAL
76929: IFFALSE 76950
// points := [ 35 , 35 , 30 ] ;
76931: LD_ADDR_VAR 0 9
76935: PUSH
76936: LD_INT 35
76938: PUSH
76939: LD_INT 35
76941: PUSH
76942: LD_INT 30
76944: PUSH
76945: EMPTY
76946: LIST
76947: LIST
76948: LIST
76949: ST_TO_ADDR
// if GetClass ( i ) = 9 then
76950: LD_VAR 0 6
76954: PPUSH
76955: CALL_OW 257
76959: PUSH
76960: LD_INT 9
76962: EQUAL
76963: IFFALSE 76984
// points := [ 20 , 55 , 40 ] ;
76965: LD_ADDR_VAR 0 9
76969: PUSH
76970: LD_INT 20
76972: PUSH
76973: LD_INT 55
76975: PUSH
76976: LD_INT 40
76978: PUSH
76979: EMPTY
76980: LIST
76981: LIST
76982: LIST
76983: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
76984: LD_VAR 0 6
76988: PPUSH
76989: CALL_OW 257
76993: PUSH
76994: LD_INT 12
76996: PUSH
76997: LD_INT 16
76999: PUSH
77000: EMPTY
77001: LIST
77002: LIST
77003: IN
77004: IFFALSE 77025
// points := [ 5 , 3 , 2 ] ;
77006: LD_ADDR_VAR 0 9
77010: PUSH
77011: LD_INT 5
77013: PUSH
77014: LD_INT 3
77016: PUSH
77017: LD_INT 2
77019: PUSH
77020: EMPTY
77021: LIST
77022: LIST
77023: LIST
77024: ST_TO_ADDR
// if GetClass ( i ) = 17 then
77025: LD_VAR 0 6
77029: PPUSH
77030: CALL_OW 257
77034: PUSH
77035: LD_INT 17
77037: EQUAL
77038: IFFALSE 77059
// points := [ 100 , 50 , 75 ] ;
77040: LD_ADDR_VAR 0 9
77044: PUSH
77045: LD_INT 100
77047: PUSH
77048: LD_INT 50
77050: PUSH
77051: LD_INT 75
77053: PUSH
77054: EMPTY
77055: LIST
77056: LIST
77057: LIST
77058: ST_TO_ADDR
// if GetClass ( i ) = 15 then
77059: LD_VAR 0 6
77063: PPUSH
77064: CALL_OW 257
77068: PUSH
77069: LD_INT 15
77071: EQUAL
77072: IFFALSE 77093
// points := [ 10 , 5 , 3 ] ;
77074: LD_ADDR_VAR 0 9
77078: PUSH
77079: LD_INT 10
77081: PUSH
77082: LD_INT 5
77084: PUSH
77085: LD_INT 3
77087: PUSH
77088: EMPTY
77089: LIST
77090: LIST
77091: LIST
77092: ST_TO_ADDR
// if GetClass ( i ) = 14 then
77093: LD_VAR 0 6
77097: PPUSH
77098: CALL_OW 257
77102: PUSH
77103: LD_INT 14
77105: EQUAL
77106: IFFALSE 77127
// points := [ 10 , 0 , 0 ] ;
77108: LD_ADDR_VAR 0 9
77112: PUSH
77113: LD_INT 10
77115: PUSH
77116: LD_INT 0
77118: PUSH
77119: LD_INT 0
77121: PUSH
77122: EMPTY
77123: LIST
77124: LIST
77125: LIST
77126: ST_TO_ADDR
// if GetClass ( i ) = 11 then
77127: LD_VAR 0 6
77131: PPUSH
77132: CALL_OW 257
77136: PUSH
77137: LD_INT 11
77139: EQUAL
77140: IFFALSE 77161
// points := [ 30 , 10 , 5 ] ;
77142: LD_ADDR_VAR 0 9
77146: PUSH
77147: LD_INT 30
77149: PUSH
77150: LD_INT 10
77152: PUSH
77153: LD_INT 5
77155: PUSH
77156: EMPTY
77157: LIST
77158: LIST
77159: LIST
77160: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
77161: LD_VAR 0 1
77165: PPUSH
77166: LD_INT 5
77168: PPUSH
77169: CALL_OW 321
77173: PUSH
77174: LD_INT 2
77176: EQUAL
77177: IFFALSE 77194
// bpoints := bpoints * 1.8 ;
77179: LD_ADDR_VAR 0 10
77183: PUSH
77184: LD_VAR 0 10
77188: PUSH
77189: LD_REAL  1.80000000000000E+0000
77192: MUL
77193: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
77194: LD_VAR 0 6
77198: PPUSH
77199: CALL_OW 257
77203: PUSH
77204: LD_INT 1
77206: PUSH
77207: LD_INT 2
77209: PUSH
77210: LD_INT 3
77212: PUSH
77213: LD_INT 4
77215: PUSH
77216: EMPTY
77217: LIST
77218: LIST
77219: LIST
77220: LIST
77221: IN
77222: PUSH
77223: LD_VAR 0 1
77227: PPUSH
77228: LD_INT 51
77230: PPUSH
77231: CALL_OW 321
77235: PUSH
77236: LD_INT 2
77238: EQUAL
77239: AND
77240: IFFALSE 77257
// bpoints := bpoints * 1.2 ;
77242: LD_ADDR_VAR 0 10
77246: PUSH
77247: LD_VAR 0 10
77251: PUSH
77252: LD_REAL  1.20000000000000E+0000
77255: MUL
77256: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
77257: LD_VAR 0 6
77261: PPUSH
77262: CALL_OW 257
77266: PUSH
77267: LD_INT 5
77269: PUSH
77270: LD_INT 7
77272: PUSH
77273: LD_INT 9
77275: PUSH
77276: EMPTY
77277: LIST
77278: LIST
77279: LIST
77280: IN
77281: PUSH
77282: LD_VAR 0 1
77286: PPUSH
77287: LD_INT 52
77289: PPUSH
77290: CALL_OW 321
77294: PUSH
77295: LD_INT 2
77297: EQUAL
77298: AND
77299: IFFALSE 77316
// bpoints := bpoints * 1.5 ;
77301: LD_ADDR_VAR 0 10
77305: PUSH
77306: LD_VAR 0 10
77310: PUSH
77311: LD_REAL  1.50000000000000E+0000
77314: MUL
77315: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
77316: LD_VAR 0 1
77320: PPUSH
77321: LD_INT 66
77323: PPUSH
77324: CALL_OW 321
77328: PUSH
77329: LD_INT 2
77331: EQUAL
77332: IFFALSE 77349
// bpoints := bpoints * 1.1 ;
77334: LD_ADDR_VAR 0 10
77338: PUSH
77339: LD_VAR 0 10
77343: PUSH
77344: LD_REAL  1.10000000000000E+0000
77347: MUL
77348: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
77349: LD_ADDR_VAR 0 10
77353: PUSH
77354: LD_VAR 0 10
77358: PUSH
77359: LD_VAR 0 6
77363: PPUSH
77364: LD_INT 1
77366: PPUSH
77367: CALL_OW 259
77371: PUSH
77372: LD_REAL  1.15000000000000E+0000
77375: MUL
77376: MUL
77377: ST_TO_ADDR
// end ; unit_vehicle :
77378: GO 78206
77380: LD_INT 2
77382: DOUBLE
77383: EQUAL
77384: IFTRUE 77388
77386: GO 78194
77388: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
77389: LD_VAR 0 6
77393: PPUSH
77394: CALL_OW 264
77398: PUSH
77399: LD_INT 2
77401: PUSH
77402: LD_INT 42
77404: PUSH
77405: LD_INT 24
77407: PUSH
77408: EMPTY
77409: LIST
77410: LIST
77411: LIST
77412: IN
77413: IFFALSE 77434
// points := [ 25 , 5 , 3 ] ;
77415: LD_ADDR_VAR 0 9
77419: PUSH
77420: LD_INT 25
77422: PUSH
77423: LD_INT 5
77425: PUSH
77426: LD_INT 3
77428: PUSH
77429: EMPTY
77430: LIST
77431: LIST
77432: LIST
77433: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
77434: LD_VAR 0 6
77438: PPUSH
77439: CALL_OW 264
77443: PUSH
77444: LD_INT 4
77446: PUSH
77447: LD_INT 43
77449: PUSH
77450: LD_INT 25
77452: PUSH
77453: EMPTY
77454: LIST
77455: LIST
77456: LIST
77457: IN
77458: IFFALSE 77479
// points := [ 40 , 15 , 5 ] ;
77460: LD_ADDR_VAR 0 9
77464: PUSH
77465: LD_INT 40
77467: PUSH
77468: LD_INT 15
77470: PUSH
77471: LD_INT 5
77473: PUSH
77474: EMPTY
77475: LIST
77476: LIST
77477: LIST
77478: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
77479: LD_VAR 0 6
77483: PPUSH
77484: CALL_OW 264
77488: PUSH
77489: LD_INT 3
77491: PUSH
77492: LD_INT 23
77494: PUSH
77495: EMPTY
77496: LIST
77497: LIST
77498: IN
77499: IFFALSE 77520
// points := [ 7 , 25 , 8 ] ;
77501: LD_ADDR_VAR 0 9
77505: PUSH
77506: LD_INT 7
77508: PUSH
77509: LD_INT 25
77511: PUSH
77512: LD_INT 8
77514: PUSH
77515: EMPTY
77516: LIST
77517: LIST
77518: LIST
77519: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
77520: LD_VAR 0 6
77524: PPUSH
77525: CALL_OW 264
77529: PUSH
77530: LD_INT 5
77532: PUSH
77533: LD_INT 27
77535: PUSH
77536: LD_INT 44
77538: PUSH
77539: EMPTY
77540: LIST
77541: LIST
77542: LIST
77543: IN
77544: IFFALSE 77565
// points := [ 14 , 50 , 16 ] ;
77546: LD_ADDR_VAR 0 9
77550: PUSH
77551: LD_INT 14
77553: PUSH
77554: LD_INT 50
77556: PUSH
77557: LD_INT 16
77559: PUSH
77560: EMPTY
77561: LIST
77562: LIST
77563: LIST
77564: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
77565: LD_VAR 0 6
77569: PPUSH
77570: CALL_OW 264
77574: PUSH
77575: LD_INT 6
77577: PUSH
77578: LD_INT 46
77580: PUSH
77581: EMPTY
77582: LIST
77583: LIST
77584: IN
77585: IFFALSE 77606
// points := [ 32 , 120 , 70 ] ;
77587: LD_ADDR_VAR 0 9
77591: PUSH
77592: LD_INT 32
77594: PUSH
77595: LD_INT 120
77597: PUSH
77598: LD_INT 70
77600: PUSH
77601: EMPTY
77602: LIST
77603: LIST
77604: LIST
77605: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
77606: LD_VAR 0 6
77610: PPUSH
77611: CALL_OW 264
77615: PUSH
77616: LD_INT 7
77618: PUSH
77619: LD_INT 28
77621: PUSH
77622: LD_INT 45
77624: PUSH
77625: LD_INT 92
77627: PUSH
77628: EMPTY
77629: LIST
77630: LIST
77631: LIST
77632: LIST
77633: IN
77634: IFFALSE 77655
// points := [ 35 , 20 , 45 ] ;
77636: LD_ADDR_VAR 0 9
77640: PUSH
77641: LD_INT 35
77643: PUSH
77644: LD_INT 20
77646: PUSH
77647: LD_INT 45
77649: PUSH
77650: EMPTY
77651: LIST
77652: LIST
77653: LIST
77654: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
77655: LD_VAR 0 6
77659: PPUSH
77660: CALL_OW 264
77664: PUSH
77665: LD_INT 47
77667: PUSH
77668: EMPTY
77669: LIST
77670: IN
77671: IFFALSE 77692
// points := [ 67 , 45 , 75 ] ;
77673: LD_ADDR_VAR 0 9
77677: PUSH
77678: LD_INT 67
77680: PUSH
77681: LD_INT 45
77683: PUSH
77684: LD_INT 75
77686: PUSH
77687: EMPTY
77688: LIST
77689: LIST
77690: LIST
77691: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
77692: LD_VAR 0 6
77696: PPUSH
77697: CALL_OW 264
77701: PUSH
77702: LD_INT 26
77704: PUSH
77705: EMPTY
77706: LIST
77707: IN
77708: IFFALSE 77729
// points := [ 120 , 30 , 80 ] ;
77710: LD_ADDR_VAR 0 9
77714: PUSH
77715: LD_INT 120
77717: PUSH
77718: LD_INT 30
77720: PUSH
77721: LD_INT 80
77723: PUSH
77724: EMPTY
77725: LIST
77726: LIST
77727: LIST
77728: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
77729: LD_VAR 0 6
77733: PPUSH
77734: CALL_OW 264
77738: PUSH
77739: LD_INT 22
77741: PUSH
77742: EMPTY
77743: LIST
77744: IN
77745: IFFALSE 77766
// points := [ 40 , 1 , 1 ] ;
77747: LD_ADDR_VAR 0 9
77751: PUSH
77752: LD_INT 40
77754: PUSH
77755: LD_INT 1
77757: PUSH
77758: LD_INT 1
77760: PUSH
77761: EMPTY
77762: LIST
77763: LIST
77764: LIST
77765: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
77766: LD_VAR 0 6
77770: PPUSH
77771: CALL_OW 264
77775: PUSH
77776: LD_INT 29
77778: PUSH
77779: EMPTY
77780: LIST
77781: IN
77782: IFFALSE 77803
// points := [ 70 , 200 , 400 ] ;
77784: LD_ADDR_VAR 0 9
77788: PUSH
77789: LD_INT 70
77791: PUSH
77792: LD_INT 200
77794: PUSH
77795: LD_INT 400
77797: PUSH
77798: EMPTY
77799: LIST
77800: LIST
77801: LIST
77802: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
77803: LD_VAR 0 6
77807: PPUSH
77808: CALL_OW 264
77812: PUSH
77813: LD_INT 14
77815: PUSH
77816: LD_INT 53
77818: PUSH
77819: EMPTY
77820: LIST
77821: LIST
77822: IN
77823: IFFALSE 77844
// points := [ 40 , 10 , 20 ] ;
77825: LD_ADDR_VAR 0 9
77829: PUSH
77830: LD_INT 40
77832: PUSH
77833: LD_INT 10
77835: PUSH
77836: LD_INT 20
77838: PUSH
77839: EMPTY
77840: LIST
77841: LIST
77842: LIST
77843: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
77844: LD_VAR 0 6
77848: PPUSH
77849: CALL_OW 264
77853: PUSH
77854: LD_INT 9
77856: PUSH
77857: EMPTY
77858: LIST
77859: IN
77860: IFFALSE 77881
// points := [ 5 , 70 , 20 ] ;
77862: LD_ADDR_VAR 0 9
77866: PUSH
77867: LD_INT 5
77869: PUSH
77870: LD_INT 70
77872: PUSH
77873: LD_INT 20
77875: PUSH
77876: EMPTY
77877: LIST
77878: LIST
77879: LIST
77880: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
77881: LD_VAR 0 6
77885: PPUSH
77886: CALL_OW 264
77890: PUSH
77891: LD_INT 10
77893: PUSH
77894: EMPTY
77895: LIST
77896: IN
77897: IFFALSE 77918
// points := [ 35 , 110 , 70 ] ;
77899: LD_ADDR_VAR 0 9
77903: PUSH
77904: LD_INT 35
77906: PUSH
77907: LD_INT 110
77909: PUSH
77910: LD_INT 70
77912: PUSH
77913: EMPTY
77914: LIST
77915: LIST
77916: LIST
77917: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
77918: LD_VAR 0 6
77922: PPUSH
77923: CALL_OW 265
77927: PUSH
77928: LD_INT 25
77930: EQUAL
77931: IFFALSE 77952
// points := [ 80 , 65 , 100 ] ;
77933: LD_ADDR_VAR 0 9
77937: PUSH
77938: LD_INT 80
77940: PUSH
77941: LD_INT 65
77943: PUSH
77944: LD_INT 100
77946: PUSH
77947: EMPTY
77948: LIST
77949: LIST
77950: LIST
77951: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
77952: LD_VAR 0 6
77956: PPUSH
77957: CALL_OW 263
77961: PUSH
77962: LD_INT 1
77964: EQUAL
77965: IFFALSE 78000
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
77967: LD_ADDR_VAR 0 10
77971: PUSH
77972: LD_VAR 0 10
77976: PUSH
77977: LD_VAR 0 6
77981: PPUSH
77982: CALL_OW 311
77986: PPUSH
77987: LD_INT 3
77989: PPUSH
77990: CALL_OW 259
77994: PUSH
77995: LD_INT 4
77997: MUL
77998: MUL
77999: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
78000: LD_VAR 0 6
78004: PPUSH
78005: CALL_OW 263
78009: PUSH
78010: LD_INT 2
78012: EQUAL
78013: IFFALSE 78064
// begin j := IsControledBy ( i ) ;
78015: LD_ADDR_VAR 0 7
78019: PUSH
78020: LD_VAR 0 6
78024: PPUSH
78025: CALL_OW 312
78029: ST_TO_ADDR
// if j then
78030: LD_VAR 0 7
78034: IFFALSE 78064
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
78036: LD_ADDR_VAR 0 10
78040: PUSH
78041: LD_VAR 0 10
78045: PUSH
78046: LD_VAR 0 7
78050: PPUSH
78051: LD_INT 3
78053: PPUSH
78054: CALL_OW 259
78058: PUSH
78059: LD_INT 3
78061: MUL
78062: MUL
78063: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
78064: LD_VAR 0 6
78068: PPUSH
78069: CALL_OW 264
78073: PUSH
78074: LD_INT 5
78076: PUSH
78077: LD_INT 6
78079: PUSH
78080: LD_INT 46
78082: PUSH
78083: LD_INT 44
78085: PUSH
78086: LD_INT 47
78088: PUSH
78089: LD_INT 45
78091: PUSH
78092: LD_INT 28
78094: PUSH
78095: LD_INT 7
78097: PUSH
78098: LD_INT 27
78100: PUSH
78101: LD_INT 29
78103: PUSH
78104: EMPTY
78105: LIST
78106: LIST
78107: LIST
78108: LIST
78109: LIST
78110: LIST
78111: LIST
78112: LIST
78113: LIST
78114: LIST
78115: IN
78116: PUSH
78117: LD_VAR 0 1
78121: PPUSH
78122: LD_INT 52
78124: PPUSH
78125: CALL_OW 321
78129: PUSH
78130: LD_INT 2
78132: EQUAL
78133: AND
78134: IFFALSE 78151
// bpoints := bpoints * 1.2 ;
78136: LD_ADDR_VAR 0 10
78140: PUSH
78141: LD_VAR 0 10
78145: PUSH
78146: LD_REAL  1.20000000000000E+0000
78149: MUL
78150: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
78151: LD_VAR 0 6
78155: PPUSH
78156: CALL_OW 264
78160: PUSH
78161: LD_INT 6
78163: PUSH
78164: LD_INT 46
78166: PUSH
78167: LD_INT 47
78169: PUSH
78170: EMPTY
78171: LIST
78172: LIST
78173: LIST
78174: IN
78175: IFFALSE 78192
// bpoints := bpoints * 1.2 ;
78177: LD_ADDR_VAR 0 10
78181: PUSH
78182: LD_VAR 0 10
78186: PUSH
78187: LD_REAL  1.20000000000000E+0000
78190: MUL
78191: ST_TO_ADDR
// end ; unit_building :
78192: GO 78206
78194: LD_INT 3
78196: DOUBLE
78197: EQUAL
78198: IFTRUE 78202
78200: GO 78205
78202: POP
// ; end ;
78203: GO 78206
78205: POP
// for j = 1 to 3 do
78206: LD_ADDR_VAR 0 7
78210: PUSH
78211: DOUBLE
78212: LD_INT 1
78214: DEC
78215: ST_TO_ADDR
78216: LD_INT 3
78218: PUSH
78219: FOR_TO
78220: IFFALSE 78273
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
78222: LD_ADDR_VAR 0 5
78226: PUSH
78227: LD_VAR 0 5
78231: PPUSH
78232: LD_VAR 0 7
78236: PPUSH
78237: LD_VAR 0 5
78241: PUSH
78242: LD_VAR 0 7
78246: ARRAY
78247: PUSH
78248: LD_VAR 0 9
78252: PUSH
78253: LD_VAR 0 7
78257: ARRAY
78258: PUSH
78259: LD_VAR 0 10
78263: MUL
78264: PLUS
78265: PPUSH
78266: CALL_OW 1
78270: ST_TO_ADDR
78271: GO 78219
78273: POP
78274: POP
// end ;
78275: GO 76754
78277: POP
78278: POP
// result := Replace ( result , 4 , tmp ) ;
78279: LD_ADDR_VAR 0 5
78283: PUSH
78284: LD_VAR 0 5
78288: PPUSH
78289: LD_INT 4
78291: PPUSH
78292: LD_VAR 0 8
78296: PPUSH
78297: CALL_OW 1
78301: ST_TO_ADDR
// end ;
78302: LD_VAR 0 5
78306: RET
// export function DangerAtRange ( unit , range ) ; begin
78307: LD_INT 0
78309: PPUSH
// if not unit then
78310: LD_VAR 0 1
78314: NOT
78315: IFFALSE 78319
// exit ;
78317: GO 78364
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
78319: LD_ADDR_VAR 0 3
78323: PUSH
78324: LD_VAR 0 1
78328: PPUSH
78329: CALL_OW 255
78333: PPUSH
78334: LD_VAR 0 1
78338: PPUSH
78339: CALL_OW 250
78343: PPUSH
78344: LD_VAR 0 1
78348: PPUSH
78349: CALL_OW 251
78353: PPUSH
78354: LD_VAR 0 2
78358: PPUSH
78359: CALL 76606 0 4
78363: ST_TO_ADDR
// end ;
78364: LD_VAR 0 3
78368: RET
// export function DangerInArea ( side , area ) ; begin
78369: LD_INT 0
78371: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
78372: LD_ADDR_VAR 0 3
78376: PUSH
78377: LD_VAR 0 2
78381: PPUSH
78382: LD_INT 81
78384: PUSH
78385: LD_VAR 0 1
78389: PUSH
78390: EMPTY
78391: LIST
78392: LIST
78393: PPUSH
78394: CALL_OW 70
78398: ST_TO_ADDR
// end ;
78399: LD_VAR 0 3
78403: RET
// export function IsExtension ( b ) ; begin
78404: LD_INT 0
78406: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
78407: LD_ADDR_VAR 0 2
78411: PUSH
78412: LD_VAR 0 1
78416: PUSH
78417: LD_INT 23
78419: PUSH
78420: LD_INT 20
78422: PUSH
78423: LD_INT 22
78425: PUSH
78426: LD_INT 17
78428: PUSH
78429: LD_INT 24
78431: PUSH
78432: LD_INT 21
78434: PUSH
78435: LD_INT 19
78437: PUSH
78438: LD_INT 16
78440: PUSH
78441: LD_INT 25
78443: PUSH
78444: LD_INT 18
78446: PUSH
78447: EMPTY
78448: LIST
78449: LIST
78450: LIST
78451: LIST
78452: LIST
78453: LIST
78454: LIST
78455: LIST
78456: LIST
78457: LIST
78458: IN
78459: ST_TO_ADDR
// end ;
78460: LD_VAR 0 2
78464: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
78465: LD_INT 0
78467: PPUSH
78468: PPUSH
78469: PPUSH
// result := [ ] ;
78470: LD_ADDR_VAR 0 4
78474: PUSH
78475: EMPTY
78476: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
78477: LD_ADDR_VAR 0 5
78481: PUSH
78482: LD_VAR 0 2
78486: PPUSH
78487: LD_INT 21
78489: PUSH
78490: LD_INT 3
78492: PUSH
78493: EMPTY
78494: LIST
78495: LIST
78496: PPUSH
78497: CALL_OW 70
78501: ST_TO_ADDR
// if not tmp then
78502: LD_VAR 0 5
78506: NOT
78507: IFFALSE 78511
// exit ;
78509: GO 78575
// if checkLink then
78511: LD_VAR 0 3
78515: IFFALSE 78565
// begin for i in tmp do
78517: LD_ADDR_VAR 0 6
78521: PUSH
78522: LD_VAR 0 5
78526: PUSH
78527: FOR_IN
78528: IFFALSE 78563
// if GetBase ( i ) <> base then
78530: LD_VAR 0 6
78534: PPUSH
78535: CALL_OW 274
78539: PUSH
78540: LD_VAR 0 1
78544: NONEQUAL
78545: IFFALSE 78561
// ComLinkToBase ( base , i ) ;
78547: LD_VAR 0 1
78551: PPUSH
78552: LD_VAR 0 6
78556: PPUSH
78557: CALL_OW 169
78561: GO 78527
78563: POP
78564: POP
// end ; result := tmp ;
78565: LD_ADDR_VAR 0 4
78569: PUSH
78570: LD_VAR 0 5
78574: ST_TO_ADDR
// end ;
78575: LD_VAR 0 4
78579: RET
// export function ComComplete ( units , b ) ; var i ; begin
78580: LD_INT 0
78582: PPUSH
78583: PPUSH
// if not units then
78584: LD_VAR 0 1
78588: NOT
78589: IFFALSE 78593
// exit ;
78591: GO 78683
// for i in units do
78593: LD_ADDR_VAR 0 4
78597: PUSH
78598: LD_VAR 0 1
78602: PUSH
78603: FOR_IN
78604: IFFALSE 78681
// if BuildingStatus ( b ) = bs_build then
78606: LD_VAR 0 2
78610: PPUSH
78611: CALL_OW 461
78615: PUSH
78616: LD_INT 1
78618: EQUAL
78619: IFFALSE 78679
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
78621: LD_VAR 0 4
78625: PPUSH
78626: LD_STRING h
78628: PUSH
78629: LD_VAR 0 2
78633: PPUSH
78634: CALL_OW 250
78638: PUSH
78639: LD_VAR 0 2
78643: PPUSH
78644: CALL_OW 251
78648: PUSH
78649: LD_VAR 0 2
78653: PUSH
78654: LD_INT 0
78656: PUSH
78657: LD_INT 0
78659: PUSH
78660: LD_INT 0
78662: PUSH
78663: EMPTY
78664: LIST
78665: LIST
78666: LIST
78667: LIST
78668: LIST
78669: LIST
78670: LIST
78671: PUSH
78672: EMPTY
78673: LIST
78674: PPUSH
78675: CALL_OW 446
78679: GO 78603
78681: POP
78682: POP
// end ;
78683: LD_VAR 0 3
78687: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
78688: LD_INT 0
78690: PPUSH
78691: PPUSH
78692: PPUSH
78693: PPUSH
78694: PPUSH
78695: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
78696: LD_VAR 0 1
78700: NOT
78701: PUSH
78702: LD_VAR 0 1
78706: PPUSH
78707: CALL_OW 263
78711: PUSH
78712: LD_INT 2
78714: NONEQUAL
78715: OR
78716: IFFALSE 78720
// exit ;
78718: GO 79036
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
78720: LD_ADDR_VAR 0 6
78724: PUSH
78725: LD_INT 22
78727: PUSH
78728: LD_VAR 0 1
78732: PPUSH
78733: CALL_OW 255
78737: PUSH
78738: EMPTY
78739: LIST
78740: LIST
78741: PUSH
78742: LD_INT 2
78744: PUSH
78745: LD_INT 30
78747: PUSH
78748: LD_INT 36
78750: PUSH
78751: EMPTY
78752: LIST
78753: LIST
78754: PUSH
78755: LD_INT 34
78757: PUSH
78758: LD_INT 31
78760: PUSH
78761: EMPTY
78762: LIST
78763: LIST
78764: PUSH
78765: EMPTY
78766: LIST
78767: LIST
78768: LIST
78769: PUSH
78770: EMPTY
78771: LIST
78772: LIST
78773: PPUSH
78774: CALL_OW 69
78778: ST_TO_ADDR
// if not tmp then
78779: LD_VAR 0 6
78783: NOT
78784: IFFALSE 78788
// exit ;
78786: GO 79036
// result := [ ] ;
78788: LD_ADDR_VAR 0 2
78792: PUSH
78793: EMPTY
78794: ST_TO_ADDR
// for i in tmp do
78795: LD_ADDR_VAR 0 3
78799: PUSH
78800: LD_VAR 0 6
78804: PUSH
78805: FOR_IN
78806: IFFALSE 78877
// begin t := UnitsInside ( i ) ;
78808: LD_ADDR_VAR 0 4
78812: PUSH
78813: LD_VAR 0 3
78817: PPUSH
78818: CALL_OW 313
78822: ST_TO_ADDR
// if t then
78823: LD_VAR 0 4
78827: IFFALSE 78875
// for j in t do
78829: LD_ADDR_VAR 0 7
78833: PUSH
78834: LD_VAR 0 4
78838: PUSH
78839: FOR_IN
78840: IFFALSE 78873
// result := Replace ( result , result + 1 , j ) ;
78842: LD_ADDR_VAR 0 2
78846: PUSH
78847: LD_VAR 0 2
78851: PPUSH
78852: LD_VAR 0 2
78856: PUSH
78857: LD_INT 1
78859: PLUS
78860: PPUSH
78861: LD_VAR 0 7
78865: PPUSH
78866: CALL_OW 1
78870: ST_TO_ADDR
78871: GO 78839
78873: POP
78874: POP
// end ;
78875: GO 78805
78877: POP
78878: POP
// if not result then
78879: LD_VAR 0 2
78883: NOT
78884: IFFALSE 78888
// exit ;
78886: GO 79036
// mech := result [ 1 ] ;
78888: LD_ADDR_VAR 0 5
78892: PUSH
78893: LD_VAR 0 2
78897: PUSH
78898: LD_INT 1
78900: ARRAY
78901: ST_TO_ADDR
// if result > 1 then
78902: LD_VAR 0 2
78906: PUSH
78907: LD_INT 1
78909: GREATER
78910: IFFALSE 79022
// begin for i = 2 to result do
78912: LD_ADDR_VAR 0 3
78916: PUSH
78917: DOUBLE
78918: LD_INT 2
78920: DEC
78921: ST_TO_ADDR
78922: LD_VAR 0 2
78926: PUSH
78927: FOR_TO
78928: IFFALSE 79020
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
78930: LD_ADDR_VAR 0 4
78934: PUSH
78935: LD_VAR 0 2
78939: PUSH
78940: LD_VAR 0 3
78944: ARRAY
78945: PPUSH
78946: LD_INT 3
78948: PPUSH
78949: CALL_OW 259
78953: PUSH
78954: LD_VAR 0 2
78958: PUSH
78959: LD_VAR 0 3
78963: ARRAY
78964: PPUSH
78965: CALL_OW 432
78969: MINUS
78970: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
78971: LD_VAR 0 4
78975: PUSH
78976: LD_VAR 0 5
78980: PPUSH
78981: LD_INT 3
78983: PPUSH
78984: CALL_OW 259
78988: PUSH
78989: LD_VAR 0 5
78993: PPUSH
78994: CALL_OW 432
78998: MINUS
78999: GREATEREQUAL
79000: IFFALSE 79018
// mech := result [ i ] ;
79002: LD_ADDR_VAR 0 5
79006: PUSH
79007: LD_VAR 0 2
79011: PUSH
79012: LD_VAR 0 3
79016: ARRAY
79017: ST_TO_ADDR
// end ;
79018: GO 78927
79020: POP
79021: POP
// end ; ComLinkTo ( vehicle , mech ) ;
79022: LD_VAR 0 1
79026: PPUSH
79027: LD_VAR 0 5
79031: PPUSH
79032: CALL_OW 135
// end ;
79036: LD_VAR 0 2
79040: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
79041: LD_INT 0
79043: PPUSH
79044: PPUSH
79045: PPUSH
79046: PPUSH
79047: PPUSH
79048: PPUSH
79049: PPUSH
79050: PPUSH
79051: PPUSH
79052: PPUSH
79053: PPUSH
79054: PPUSH
79055: PPUSH
// result := [ ] ;
79056: LD_ADDR_VAR 0 7
79060: PUSH
79061: EMPTY
79062: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
79063: LD_VAR 0 1
79067: PPUSH
79068: CALL_OW 266
79072: PUSH
79073: LD_INT 0
79075: PUSH
79076: LD_INT 1
79078: PUSH
79079: EMPTY
79080: LIST
79081: LIST
79082: IN
79083: NOT
79084: IFFALSE 79088
// exit ;
79086: GO 80722
// if name then
79088: LD_VAR 0 3
79092: IFFALSE 79108
// SetBName ( base_dep , name ) ;
79094: LD_VAR 0 1
79098: PPUSH
79099: LD_VAR 0 3
79103: PPUSH
79104: CALL_OW 500
// base := GetBase ( base_dep ) ;
79108: LD_ADDR_VAR 0 15
79112: PUSH
79113: LD_VAR 0 1
79117: PPUSH
79118: CALL_OW 274
79122: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
79123: LD_ADDR_VAR 0 16
79127: PUSH
79128: LD_VAR 0 1
79132: PPUSH
79133: CALL_OW 255
79137: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
79138: LD_ADDR_VAR 0 17
79142: PUSH
79143: LD_VAR 0 1
79147: PPUSH
79148: CALL_OW 248
79152: ST_TO_ADDR
// if sources then
79153: LD_VAR 0 5
79157: IFFALSE 79204
// for i = 1 to 3 do
79159: LD_ADDR_VAR 0 8
79163: PUSH
79164: DOUBLE
79165: LD_INT 1
79167: DEC
79168: ST_TO_ADDR
79169: LD_INT 3
79171: PUSH
79172: FOR_TO
79173: IFFALSE 79202
// AddResourceType ( base , i , sources [ i ] ) ;
79175: LD_VAR 0 15
79179: PPUSH
79180: LD_VAR 0 8
79184: PPUSH
79185: LD_VAR 0 5
79189: PUSH
79190: LD_VAR 0 8
79194: ARRAY
79195: PPUSH
79196: CALL_OW 276
79200: GO 79172
79202: POP
79203: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
79204: LD_ADDR_VAR 0 18
79208: PUSH
79209: LD_VAR 0 15
79213: PPUSH
79214: LD_VAR 0 2
79218: PPUSH
79219: LD_INT 1
79221: PPUSH
79222: CALL 78465 0 3
79226: ST_TO_ADDR
// InitHc ;
79227: CALL_OW 19
// InitUc ;
79231: CALL_OW 18
// uc_side := side ;
79235: LD_ADDR_OWVAR 20
79239: PUSH
79240: LD_VAR 0 16
79244: ST_TO_ADDR
// uc_nation := nation ;
79245: LD_ADDR_OWVAR 21
79249: PUSH
79250: LD_VAR 0 17
79254: ST_TO_ADDR
// if buildings then
79255: LD_VAR 0 18
79259: IFFALSE 80581
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
79261: LD_ADDR_VAR 0 19
79265: PUSH
79266: LD_VAR 0 18
79270: PPUSH
79271: LD_INT 2
79273: PUSH
79274: LD_INT 30
79276: PUSH
79277: LD_INT 29
79279: PUSH
79280: EMPTY
79281: LIST
79282: LIST
79283: PUSH
79284: LD_INT 30
79286: PUSH
79287: LD_INT 30
79289: PUSH
79290: EMPTY
79291: LIST
79292: LIST
79293: PUSH
79294: EMPTY
79295: LIST
79296: LIST
79297: LIST
79298: PPUSH
79299: CALL_OW 72
79303: ST_TO_ADDR
// if tmp then
79304: LD_VAR 0 19
79308: IFFALSE 79356
// for i in tmp do
79310: LD_ADDR_VAR 0 8
79314: PUSH
79315: LD_VAR 0 19
79319: PUSH
79320: FOR_IN
79321: IFFALSE 79354
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
79323: LD_VAR 0 8
79327: PPUSH
79328: CALL_OW 250
79332: PPUSH
79333: LD_VAR 0 8
79337: PPUSH
79338: CALL_OW 251
79342: PPUSH
79343: LD_VAR 0 16
79347: PPUSH
79348: CALL_OW 441
79352: GO 79320
79354: POP
79355: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
79356: LD_VAR 0 18
79360: PPUSH
79361: LD_INT 2
79363: PUSH
79364: LD_INT 30
79366: PUSH
79367: LD_INT 32
79369: PUSH
79370: EMPTY
79371: LIST
79372: LIST
79373: PUSH
79374: LD_INT 30
79376: PUSH
79377: LD_INT 33
79379: PUSH
79380: EMPTY
79381: LIST
79382: LIST
79383: PUSH
79384: EMPTY
79385: LIST
79386: LIST
79387: LIST
79388: PPUSH
79389: CALL_OW 72
79393: IFFALSE 79481
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
79395: LD_ADDR_VAR 0 8
79399: PUSH
79400: LD_VAR 0 18
79404: PPUSH
79405: LD_INT 2
79407: PUSH
79408: LD_INT 30
79410: PUSH
79411: LD_INT 32
79413: PUSH
79414: EMPTY
79415: LIST
79416: LIST
79417: PUSH
79418: LD_INT 30
79420: PUSH
79421: LD_INT 33
79423: PUSH
79424: EMPTY
79425: LIST
79426: LIST
79427: PUSH
79428: EMPTY
79429: LIST
79430: LIST
79431: LIST
79432: PPUSH
79433: CALL_OW 72
79437: PUSH
79438: FOR_IN
79439: IFFALSE 79479
// begin if not GetBWeapon ( i ) then
79441: LD_VAR 0 8
79445: PPUSH
79446: CALL_OW 269
79450: NOT
79451: IFFALSE 79477
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
79453: LD_VAR 0 8
79457: PPUSH
79458: LD_VAR 0 8
79462: PPUSH
79463: LD_VAR 0 2
79467: PPUSH
79468: CALL 80727 0 2
79472: PPUSH
79473: CALL_OW 431
// end ;
79477: GO 79438
79479: POP
79480: POP
// end ; for i = 1 to personel do
79481: LD_ADDR_VAR 0 8
79485: PUSH
79486: DOUBLE
79487: LD_INT 1
79489: DEC
79490: ST_TO_ADDR
79491: LD_VAR 0 6
79495: PUSH
79496: FOR_TO
79497: IFFALSE 80561
// begin if i > 4 then
79499: LD_VAR 0 8
79503: PUSH
79504: LD_INT 4
79506: GREATER
79507: IFFALSE 79511
// break ;
79509: GO 80561
// case i of 1 :
79511: LD_VAR 0 8
79515: PUSH
79516: LD_INT 1
79518: DOUBLE
79519: EQUAL
79520: IFTRUE 79524
79522: GO 79604
79524: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
79525: LD_ADDR_VAR 0 12
79529: PUSH
79530: LD_VAR 0 18
79534: PPUSH
79535: LD_INT 22
79537: PUSH
79538: LD_VAR 0 16
79542: PUSH
79543: EMPTY
79544: LIST
79545: LIST
79546: PUSH
79547: LD_INT 58
79549: PUSH
79550: EMPTY
79551: LIST
79552: PUSH
79553: LD_INT 2
79555: PUSH
79556: LD_INT 30
79558: PUSH
79559: LD_INT 32
79561: PUSH
79562: EMPTY
79563: LIST
79564: LIST
79565: PUSH
79566: LD_INT 30
79568: PUSH
79569: LD_INT 4
79571: PUSH
79572: EMPTY
79573: LIST
79574: LIST
79575: PUSH
79576: LD_INT 30
79578: PUSH
79579: LD_INT 5
79581: PUSH
79582: EMPTY
79583: LIST
79584: LIST
79585: PUSH
79586: EMPTY
79587: LIST
79588: LIST
79589: LIST
79590: LIST
79591: PUSH
79592: EMPTY
79593: LIST
79594: LIST
79595: LIST
79596: PPUSH
79597: CALL_OW 72
79601: ST_TO_ADDR
79602: GO 79826
79604: LD_INT 2
79606: DOUBLE
79607: EQUAL
79608: IFTRUE 79612
79610: GO 79674
79612: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
79613: LD_ADDR_VAR 0 12
79617: PUSH
79618: LD_VAR 0 18
79622: PPUSH
79623: LD_INT 22
79625: PUSH
79626: LD_VAR 0 16
79630: PUSH
79631: EMPTY
79632: LIST
79633: LIST
79634: PUSH
79635: LD_INT 2
79637: PUSH
79638: LD_INT 30
79640: PUSH
79641: LD_INT 0
79643: PUSH
79644: EMPTY
79645: LIST
79646: LIST
79647: PUSH
79648: LD_INT 30
79650: PUSH
79651: LD_INT 1
79653: PUSH
79654: EMPTY
79655: LIST
79656: LIST
79657: PUSH
79658: EMPTY
79659: LIST
79660: LIST
79661: LIST
79662: PUSH
79663: EMPTY
79664: LIST
79665: LIST
79666: PPUSH
79667: CALL_OW 72
79671: ST_TO_ADDR
79672: GO 79826
79674: LD_INT 3
79676: DOUBLE
79677: EQUAL
79678: IFTRUE 79682
79680: GO 79744
79682: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
79683: LD_ADDR_VAR 0 12
79687: PUSH
79688: LD_VAR 0 18
79692: PPUSH
79693: LD_INT 22
79695: PUSH
79696: LD_VAR 0 16
79700: PUSH
79701: EMPTY
79702: LIST
79703: LIST
79704: PUSH
79705: LD_INT 2
79707: PUSH
79708: LD_INT 30
79710: PUSH
79711: LD_INT 2
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: PUSH
79718: LD_INT 30
79720: PUSH
79721: LD_INT 3
79723: PUSH
79724: EMPTY
79725: LIST
79726: LIST
79727: PUSH
79728: EMPTY
79729: LIST
79730: LIST
79731: LIST
79732: PUSH
79733: EMPTY
79734: LIST
79735: LIST
79736: PPUSH
79737: CALL_OW 72
79741: ST_TO_ADDR
79742: GO 79826
79744: LD_INT 4
79746: DOUBLE
79747: EQUAL
79748: IFTRUE 79752
79750: GO 79825
79752: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
79753: LD_ADDR_VAR 0 12
79757: PUSH
79758: LD_VAR 0 18
79762: PPUSH
79763: LD_INT 22
79765: PUSH
79766: LD_VAR 0 16
79770: PUSH
79771: EMPTY
79772: LIST
79773: LIST
79774: PUSH
79775: LD_INT 2
79777: PUSH
79778: LD_INT 30
79780: PUSH
79781: LD_INT 6
79783: PUSH
79784: EMPTY
79785: LIST
79786: LIST
79787: PUSH
79788: LD_INT 30
79790: PUSH
79791: LD_INT 7
79793: PUSH
79794: EMPTY
79795: LIST
79796: LIST
79797: PUSH
79798: LD_INT 30
79800: PUSH
79801: LD_INT 8
79803: PUSH
79804: EMPTY
79805: LIST
79806: LIST
79807: PUSH
79808: EMPTY
79809: LIST
79810: LIST
79811: LIST
79812: LIST
79813: PUSH
79814: EMPTY
79815: LIST
79816: LIST
79817: PPUSH
79818: CALL_OW 72
79822: ST_TO_ADDR
79823: GO 79826
79825: POP
// if i = 1 then
79826: LD_VAR 0 8
79830: PUSH
79831: LD_INT 1
79833: EQUAL
79834: IFFALSE 79945
// begin tmp := [ ] ;
79836: LD_ADDR_VAR 0 19
79840: PUSH
79841: EMPTY
79842: ST_TO_ADDR
// for j in f do
79843: LD_ADDR_VAR 0 9
79847: PUSH
79848: LD_VAR 0 12
79852: PUSH
79853: FOR_IN
79854: IFFALSE 79927
// if GetBType ( j ) = b_bunker then
79856: LD_VAR 0 9
79860: PPUSH
79861: CALL_OW 266
79865: PUSH
79866: LD_INT 32
79868: EQUAL
79869: IFFALSE 79896
// tmp := Insert ( tmp , 1 , j ) else
79871: LD_ADDR_VAR 0 19
79875: PUSH
79876: LD_VAR 0 19
79880: PPUSH
79881: LD_INT 1
79883: PPUSH
79884: LD_VAR 0 9
79888: PPUSH
79889: CALL_OW 2
79893: ST_TO_ADDR
79894: GO 79925
// tmp := Insert ( tmp , tmp + 1 , j ) ;
79896: LD_ADDR_VAR 0 19
79900: PUSH
79901: LD_VAR 0 19
79905: PPUSH
79906: LD_VAR 0 19
79910: PUSH
79911: LD_INT 1
79913: PLUS
79914: PPUSH
79915: LD_VAR 0 9
79919: PPUSH
79920: CALL_OW 2
79924: ST_TO_ADDR
79925: GO 79853
79927: POP
79928: POP
// if tmp then
79929: LD_VAR 0 19
79933: IFFALSE 79945
// f := tmp ;
79935: LD_ADDR_VAR 0 12
79939: PUSH
79940: LD_VAR 0 19
79944: ST_TO_ADDR
// end ; x := personel [ i ] ;
79945: LD_ADDR_VAR 0 13
79949: PUSH
79950: LD_VAR 0 6
79954: PUSH
79955: LD_VAR 0 8
79959: ARRAY
79960: ST_TO_ADDR
// if x = - 1 then
79961: LD_VAR 0 13
79965: PUSH
79966: LD_INT 1
79968: NEG
79969: EQUAL
79970: IFFALSE 80179
// begin for j in f do
79972: LD_ADDR_VAR 0 9
79976: PUSH
79977: LD_VAR 0 12
79981: PUSH
79982: FOR_IN
79983: IFFALSE 80175
// repeat InitHc ;
79985: CALL_OW 19
// if GetBType ( j ) = b_barracks then
79989: LD_VAR 0 9
79993: PPUSH
79994: CALL_OW 266
79998: PUSH
79999: LD_INT 5
80001: EQUAL
80002: IFFALSE 80072
// begin if UnitsInside ( j ) < 3 then
80004: LD_VAR 0 9
80008: PPUSH
80009: CALL_OW 313
80013: PUSH
80014: LD_INT 3
80016: LESS
80017: IFFALSE 80053
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
80019: LD_INT 0
80021: PPUSH
80022: LD_INT 5
80024: PUSH
80025: LD_INT 8
80027: PUSH
80028: LD_INT 9
80030: PUSH
80031: EMPTY
80032: LIST
80033: LIST
80034: LIST
80035: PUSH
80036: LD_VAR 0 17
80040: ARRAY
80041: PPUSH
80042: LD_VAR 0 4
80046: PPUSH
80047: CALL_OW 380
80051: GO 80070
// PrepareHuman ( false , i , skill ) ;
80053: LD_INT 0
80055: PPUSH
80056: LD_VAR 0 8
80060: PPUSH
80061: LD_VAR 0 4
80065: PPUSH
80066: CALL_OW 380
// end else
80070: GO 80089
// PrepareHuman ( false , i , skill ) ;
80072: LD_INT 0
80074: PPUSH
80075: LD_VAR 0 8
80079: PPUSH
80080: LD_VAR 0 4
80084: PPUSH
80085: CALL_OW 380
// un := CreateHuman ;
80089: LD_ADDR_VAR 0 14
80093: PUSH
80094: CALL_OW 44
80098: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
80099: LD_ADDR_VAR 0 7
80103: PUSH
80104: LD_VAR 0 7
80108: PPUSH
80109: LD_INT 1
80111: PPUSH
80112: LD_VAR 0 14
80116: PPUSH
80117: CALL_OW 2
80121: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
80122: LD_VAR 0 14
80126: PPUSH
80127: LD_VAR 0 9
80131: PPUSH
80132: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
80136: LD_VAR 0 9
80140: PPUSH
80141: CALL_OW 313
80145: PUSH
80146: LD_INT 6
80148: EQUAL
80149: PUSH
80150: LD_VAR 0 9
80154: PPUSH
80155: CALL_OW 266
80159: PUSH
80160: LD_INT 32
80162: PUSH
80163: LD_INT 31
80165: PUSH
80166: EMPTY
80167: LIST
80168: LIST
80169: IN
80170: OR
80171: IFFALSE 79985
80173: GO 79982
80175: POP
80176: POP
// end else
80177: GO 80559
// for j = 1 to x do
80179: LD_ADDR_VAR 0 9
80183: PUSH
80184: DOUBLE
80185: LD_INT 1
80187: DEC
80188: ST_TO_ADDR
80189: LD_VAR 0 13
80193: PUSH
80194: FOR_TO
80195: IFFALSE 80557
// begin InitHc ;
80197: CALL_OW 19
// if not f then
80201: LD_VAR 0 12
80205: NOT
80206: IFFALSE 80295
// begin PrepareHuman ( false , i , skill ) ;
80208: LD_INT 0
80210: PPUSH
80211: LD_VAR 0 8
80215: PPUSH
80216: LD_VAR 0 4
80220: PPUSH
80221: CALL_OW 380
// un := CreateHuman ;
80225: LD_ADDR_VAR 0 14
80229: PUSH
80230: CALL_OW 44
80234: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
80235: LD_ADDR_VAR 0 7
80239: PUSH
80240: LD_VAR 0 7
80244: PPUSH
80245: LD_INT 1
80247: PPUSH
80248: LD_VAR 0 14
80252: PPUSH
80253: CALL_OW 2
80257: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
80258: LD_VAR 0 14
80262: PPUSH
80263: LD_VAR 0 1
80267: PPUSH
80268: CALL_OW 250
80272: PPUSH
80273: LD_VAR 0 1
80277: PPUSH
80278: CALL_OW 251
80282: PPUSH
80283: LD_INT 10
80285: PPUSH
80286: LD_INT 0
80288: PPUSH
80289: CALL_OW 50
// continue ;
80293: GO 80194
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
80295: LD_VAR 0 12
80299: PUSH
80300: LD_INT 1
80302: ARRAY
80303: PPUSH
80304: CALL_OW 313
80308: PUSH
80309: LD_VAR 0 12
80313: PUSH
80314: LD_INT 1
80316: ARRAY
80317: PPUSH
80318: CALL_OW 266
80322: PUSH
80323: LD_INT 32
80325: PUSH
80326: LD_INT 31
80328: PUSH
80329: EMPTY
80330: LIST
80331: LIST
80332: IN
80333: AND
80334: PUSH
80335: LD_VAR 0 12
80339: PUSH
80340: LD_INT 1
80342: ARRAY
80343: PPUSH
80344: CALL_OW 313
80348: PUSH
80349: LD_INT 6
80351: EQUAL
80352: OR
80353: IFFALSE 80373
// f := Delete ( f , 1 ) ;
80355: LD_ADDR_VAR 0 12
80359: PUSH
80360: LD_VAR 0 12
80364: PPUSH
80365: LD_INT 1
80367: PPUSH
80368: CALL_OW 3
80372: ST_TO_ADDR
// if not f then
80373: LD_VAR 0 12
80377: NOT
80378: IFFALSE 80396
// begin x := x + 2 ;
80380: LD_ADDR_VAR 0 13
80384: PUSH
80385: LD_VAR 0 13
80389: PUSH
80390: LD_INT 2
80392: PLUS
80393: ST_TO_ADDR
// continue ;
80394: GO 80194
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
80396: LD_VAR 0 12
80400: PUSH
80401: LD_INT 1
80403: ARRAY
80404: PPUSH
80405: CALL_OW 266
80409: PUSH
80410: LD_INT 5
80412: EQUAL
80413: IFFALSE 80487
// begin if UnitsInside ( f [ 1 ] ) < 3 then
80415: LD_VAR 0 12
80419: PUSH
80420: LD_INT 1
80422: ARRAY
80423: PPUSH
80424: CALL_OW 313
80428: PUSH
80429: LD_INT 3
80431: LESS
80432: IFFALSE 80468
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
80434: LD_INT 0
80436: PPUSH
80437: LD_INT 5
80439: PUSH
80440: LD_INT 8
80442: PUSH
80443: LD_INT 9
80445: PUSH
80446: EMPTY
80447: LIST
80448: LIST
80449: LIST
80450: PUSH
80451: LD_VAR 0 17
80455: ARRAY
80456: PPUSH
80457: LD_VAR 0 4
80461: PPUSH
80462: CALL_OW 380
80466: GO 80485
// PrepareHuman ( false , i , skill ) ;
80468: LD_INT 0
80470: PPUSH
80471: LD_VAR 0 8
80475: PPUSH
80476: LD_VAR 0 4
80480: PPUSH
80481: CALL_OW 380
// end else
80485: GO 80504
// PrepareHuman ( false , i , skill ) ;
80487: LD_INT 0
80489: PPUSH
80490: LD_VAR 0 8
80494: PPUSH
80495: LD_VAR 0 4
80499: PPUSH
80500: CALL_OW 380
// un := CreateHuman ;
80504: LD_ADDR_VAR 0 14
80508: PUSH
80509: CALL_OW 44
80513: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
80514: LD_ADDR_VAR 0 7
80518: PUSH
80519: LD_VAR 0 7
80523: PPUSH
80524: LD_INT 1
80526: PPUSH
80527: LD_VAR 0 14
80531: PPUSH
80532: CALL_OW 2
80536: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
80537: LD_VAR 0 14
80541: PPUSH
80542: LD_VAR 0 12
80546: PUSH
80547: LD_INT 1
80549: ARRAY
80550: PPUSH
80551: CALL_OW 52
// end ;
80555: GO 80194
80557: POP
80558: POP
// end ;
80559: GO 79496
80561: POP
80562: POP
// result := result ^ buildings ;
80563: LD_ADDR_VAR 0 7
80567: PUSH
80568: LD_VAR 0 7
80572: PUSH
80573: LD_VAR 0 18
80577: ADD
80578: ST_TO_ADDR
// end else
80579: GO 80722
// begin for i = 1 to personel do
80581: LD_ADDR_VAR 0 8
80585: PUSH
80586: DOUBLE
80587: LD_INT 1
80589: DEC
80590: ST_TO_ADDR
80591: LD_VAR 0 6
80595: PUSH
80596: FOR_TO
80597: IFFALSE 80720
// begin if i > 4 then
80599: LD_VAR 0 8
80603: PUSH
80604: LD_INT 4
80606: GREATER
80607: IFFALSE 80611
// break ;
80609: GO 80720
// x := personel [ i ] ;
80611: LD_ADDR_VAR 0 13
80615: PUSH
80616: LD_VAR 0 6
80620: PUSH
80621: LD_VAR 0 8
80625: ARRAY
80626: ST_TO_ADDR
// if x = - 1 then
80627: LD_VAR 0 13
80631: PUSH
80632: LD_INT 1
80634: NEG
80635: EQUAL
80636: IFFALSE 80640
// continue ;
80638: GO 80596
// PrepareHuman ( false , i , skill ) ;
80640: LD_INT 0
80642: PPUSH
80643: LD_VAR 0 8
80647: PPUSH
80648: LD_VAR 0 4
80652: PPUSH
80653: CALL_OW 380
// un := CreateHuman ;
80657: LD_ADDR_VAR 0 14
80661: PUSH
80662: CALL_OW 44
80666: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
80667: LD_VAR 0 14
80671: PPUSH
80672: LD_VAR 0 1
80676: PPUSH
80677: CALL_OW 250
80681: PPUSH
80682: LD_VAR 0 1
80686: PPUSH
80687: CALL_OW 251
80691: PPUSH
80692: LD_INT 10
80694: PPUSH
80695: LD_INT 0
80697: PPUSH
80698: CALL_OW 50
// result := result ^ un ;
80702: LD_ADDR_VAR 0 7
80706: PUSH
80707: LD_VAR 0 7
80711: PUSH
80712: LD_VAR 0 14
80716: ADD
80717: ST_TO_ADDR
// end ;
80718: GO 80596
80720: POP
80721: POP
// end ; end ;
80722: LD_VAR 0 7
80726: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
80727: LD_INT 0
80729: PPUSH
80730: PPUSH
80731: PPUSH
80732: PPUSH
80733: PPUSH
80734: PPUSH
80735: PPUSH
80736: PPUSH
80737: PPUSH
80738: PPUSH
80739: PPUSH
80740: PPUSH
80741: PPUSH
80742: PPUSH
80743: PPUSH
80744: PPUSH
// result := false ;
80745: LD_ADDR_VAR 0 3
80749: PUSH
80750: LD_INT 0
80752: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
80753: LD_VAR 0 1
80757: NOT
80758: PUSH
80759: LD_VAR 0 1
80763: PPUSH
80764: CALL_OW 266
80768: PUSH
80769: LD_INT 32
80771: PUSH
80772: LD_INT 33
80774: PUSH
80775: EMPTY
80776: LIST
80777: LIST
80778: IN
80779: NOT
80780: OR
80781: IFFALSE 80785
// exit ;
80783: GO 81894
// nat := GetNation ( tower ) ;
80785: LD_ADDR_VAR 0 12
80789: PUSH
80790: LD_VAR 0 1
80794: PPUSH
80795: CALL_OW 248
80799: ST_TO_ADDR
// side := GetSide ( tower ) ;
80800: LD_ADDR_VAR 0 16
80804: PUSH
80805: LD_VAR 0 1
80809: PPUSH
80810: CALL_OW 255
80814: ST_TO_ADDR
// x := GetX ( tower ) ;
80815: LD_ADDR_VAR 0 10
80819: PUSH
80820: LD_VAR 0 1
80824: PPUSH
80825: CALL_OW 250
80829: ST_TO_ADDR
// y := GetY ( tower ) ;
80830: LD_ADDR_VAR 0 11
80834: PUSH
80835: LD_VAR 0 1
80839: PPUSH
80840: CALL_OW 251
80844: ST_TO_ADDR
// if not x or not y then
80845: LD_VAR 0 10
80849: NOT
80850: PUSH
80851: LD_VAR 0 11
80855: NOT
80856: OR
80857: IFFALSE 80861
// exit ;
80859: GO 81894
// weapon := 0 ;
80861: LD_ADDR_VAR 0 18
80865: PUSH
80866: LD_INT 0
80868: ST_TO_ADDR
// fac_list := [ ] ;
80869: LD_ADDR_VAR 0 17
80873: PUSH
80874: EMPTY
80875: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
80876: LD_ADDR_VAR 0 6
80880: PUSH
80881: LD_VAR 0 1
80885: PPUSH
80886: CALL_OW 274
80890: PPUSH
80891: LD_VAR 0 2
80895: PPUSH
80896: LD_INT 0
80898: PPUSH
80899: CALL 78465 0 3
80903: PPUSH
80904: LD_INT 30
80906: PUSH
80907: LD_INT 3
80909: PUSH
80910: EMPTY
80911: LIST
80912: LIST
80913: PPUSH
80914: CALL_OW 72
80918: ST_TO_ADDR
// if not factories then
80919: LD_VAR 0 6
80923: NOT
80924: IFFALSE 80928
// exit ;
80926: GO 81894
// for i in factories do
80928: LD_ADDR_VAR 0 8
80932: PUSH
80933: LD_VAR 0 6
80937: PUSH
80938: FOR_IN
80939: IFFALSE 80964
// fac_list := fac_list union AvailableWeaponList ( i ) ;
80941: LD_ADDR_VAR 0 17
80945: PUSH
80946: LD_VAR 0 17
80950: PUSH
80951: LD_VAR 0 8
80955: PPUSH
80956: CALL_OW 478
80960: UNION
80961: ST_TO_ADDR
80962: GO 80938
80964: POP
80965: POP
// if not fac_list then
80966: LD_VAR 0 17
80970: NOT
80971: IFFALSE 80975
// exit ;
80973: GO 81894
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
80975: LD_ADDR_VAR 0 5
80979: PUSH
80980: LD_INT 4
80982: PUSH
80983: LD_INT 5
80985: PUSH
80986: LD_INT 9
80988: PUSH
80989: LD_INT 10
80991: PUSH
80992: LD_INT 6
80994: PUSH
80995: LD_INT 7
80997: PUSH
80998: LD_INT 11
81000: PUSH
81001: EMPTY
81002: LIST
81003: LIST
81004: LIST
81005: LIST
81006: LIST
81007: LIST
81008: LIST
81009: PUSH
81010: LD_INT 27
81012: PUSH
81013: LD_INT 28
81015: PUSH
81016: LD_INT 26
81018: PUSH
81019: LD_INT 30
81021: PUSH
81022: EMPTY
81023: LIST
81024: LIST
81025: LIST
81026: LIST
81027: PUSH
81028: LD_INT 43
81030: PUSH
81031: LD_INT 44
81033: PUSH
81034: LD_INT 46
81036: PUSH
81037: LD_INT 45
81039: PUSH
81040: LD_INT 47
81042: PUSH
81043: LD_INT 49
81045: PUSH
81046: EMPTY
81047: LIST
81048: LIST
81049: LIST
81050: LIST
81051: LIST
81052: LIST
81053: PUSH
81054: EMPTY
81055: LIST
81056: LIST
81057: LIST
81058: PUSH
81059: LD_VAR 0 12
81063: ARRAY
81064: ST_TO_ADDR
// list := list isect fac_list ;
81065: LD_ADDR_VAR 0 5
81069: PUSH
81070: LD_VAR 0 5
81074: PUSH
81075: LD_VAR 0 17
81079: ISECT
81080: ST_TO_ADDR
// if not list then
81081: LD_VAR 0 5
81085: NOT
81086: IFFALSE 81090
// exit ;
81088: GO 81894
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
81090: LD_VAR 0 12
81094: PUSH
81095: LD_INT 3
81097: EQUAL
81098: PUSH
81099: LD_INT 49
81101: PUSH
81102: LD_VAR 0 5
81106: IN
81107: AND
81108: PUSH
81109: LD_INT 31
81111: PPUSH
81112: LD_VAR 0 16
81116: PPUSH
81117: CALL_OW 321
81121: PUSH
81122: LD_INT 2
81124: EQUAL
81125: AND
81126: IFFALSE 81186
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
81128: LD_INT 22
81130: PUSH
81131: LD_VAR 0 16
81135: PUSH
81136: EMPTY
81137: LIST
81138: LIST
81139: PUSH
81140: LD_INT 35
81142: PUSH
81143: LD_INT 49
81145: PUSH
81146: EMPTY
81147: LIST
81148: LIST
81149: PUSH
81150: LD_INT 91
81152: PUSH
81153: LD_VAR 0 1
81157: PUSH
81158: LD_INT 10
81160: PUSH
81161: EMPTY
81162: LIST
81163: LIST
81164: LIST
81165: PUSH
81166: EMPTY
81167: LIST
81168: LIST
81169: LIST
81170: PPUSH
81171: CALL_OW 69
81175: NOT
81176: IFFALSE 81186
// weapon := ru_time_lapser ;
81178: LD_ADDR_VAR 0 18
81182: PUSH
81183: LD_INT 49
81185: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
81186: LD_VAR 0 12
81190: PUSH
81191: LD_INT 1
81193: PUSH
81194: LD_INT 2
81196: PUSH
81197: EMPTY
81198: LIST
81199: LIST
81200: IN
81201: PUSH
81202: LD_INT 11
81204: PUSH
81205: LD_VAR 0 5
81209: IN
81210: PUSH
81211: LD_INT 30
81213: PUSH
81214: LD_VAR 0 5
81218: IN
81219: OR
81220: AND
81221: PUSH
81222: LD_INT 6
81224: PPUSH
81225: LD_VAR 0 16
81229: PPUSH
81230: CALL_OW 321
81234: PUSH
81235: LD_INT 2
81237: EQUAL
81238: AND
81239: IFFALSE 81404
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
81241: LD_INT 22
81243: PUSH
81244: LD_VAR 0 16
81248: PUSH
81249: EMPTY
81250: LIST
81251: LIST
81252: PUSH
81253: LD_INT 2
81255: PUSH
81256: LD_INT 35
81258: PUSH
81259: LD_INT 11
81261: PUSH
81262: EMPTY
81263: LIST
81264: LIST
81265: PUSH
81266: LD_INT 35
81268: PUSH
81269: LD_INT 30
81271: PUSH
81272: EMPTY
81273: LIST
81274: LIST
81275: PUSH
81276: EMPTY
81277: LIST
81278: LIST
81279: LIST
81280: PUSH
81281: LD_INT 91
81283: PUSH
81284: LD_VAR 0 1
81288: PUSH
81289: LD_INT 18
81291: PUSH
81292: EMPTY
81293: LIST
81294: LIST
81295: LIST
81296: PUSH
81297: EMPTY
81298: LIST
81299: LIST
81300: LIST
81301: PPUSH
81302: CALL_OW 69
81306: NOT
81307: PUSH
81308: LD_INT 22
81310: PUSH
81311: LD_VAR 0 16
81315: PUSH
81316: EMPTY
81317: LIST
81318: LIST
81319: PUSH
81320: LD_INT 2
81322: PUSH
81323: LD_INT 30
81325: PUSH
81326: LD_INT 32
81328: PUSH
81329: EMPTY
81330: LIST
81331: LIST
81332: PUSH
81333: LD_INT 30
81335: PUSH
81336: LD_INT 33
81338: PUSH
81339: EMPTY
81340: LIST
81341: LIST
81342: PUSH
81343: EMPTY
81344: LIST
81345: LIST
81346: LIST
81347: PUSH
81348: LD_INT 91
81350: PUSH
81351: LD_VAR 0 1
81355: PUSH
81356: LD_INT 12
81358: PUSH
81359: EMPTY
81360: LIST
81361: LIST
81362: LIST
81363: PUSH
81364: EMPTY
81365: LIST
81366: LIST
81367: LIST
81368: PUSH
81369: EMPTY
81370: LIST
81371: PPUSH
81372: CALL_OW 69
81376: PUSH
81377: LD_INT 2
81379: GREATER
81380: AND
81381: IFFALSE 81404
// weapon := [ us_radar , ar_radar ] [ nat ] ;
81383: LD_ADDR_VAR 0 18
81387: PUSH
81388: LD_INT 11
81390: PUSH
81391: LD_INT 30
81393: PUSH
81394: EMPTY
81395: LIST
81396: LIST
81397: PUSH
81398: LD_VAR 0 12
81402: ARRAY
81403: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
81404: LD_VAR 0 18
81408: NOT
81409: PUSH
81410: LD_INT 40
81412: PPUSH
81413: LD_VAR 0 16
81417: PPUSH
81418: CALL_OW 321
81422: PUSH
81423: LD_INT 2
81425: EQUAL
81426: AND
81427: PUSH
81428: LD_INT 7
81430: PUSH
81431: LD_VAR 0 5
81435: IN
81436: PUSH
81437: LD_INT 28
81439: PUSH
81440: LD_VAR 0 5
81444: IN
81445: OR
81446: PUSH
81447: LD_INT 45
81449: PUSH
81450: LD_VAR 0 5
81454: IN
81455: OR
81456: AND
81457: IFFALSE 81711
// begin hex := GetHexInfo ( x , y ) ;
81459: LD_ADDR_VAR 0 4
81463: PUSH
81464: LD_VAR 0 10
81468: PPUSH
81469: LD_VAR 0 11
81473: PPUSH
81474: CALL_OW 546
81478: ST_TO_ADDR
// if hex [ 1 ] then
81479: LD_VAR 0 4
81483: PUSH
81484: LD_INT 1
81486: ARRAY
81487: IFFALSE 81491
// exit ;
81489: GO 81894
// height := hex [ 2 ] ;
81491: LD_ADDR_VAR 0 15
81495: PUSH
81496: LD_VAR 0 4
81500: PUSH
81501: LD_INT 2
81503: ARRAY
81504: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
81505: LD_ADDR_VAR 0 14
81509: PUSH
81510: LD_INT 0
81512: PUSH
81513: LD_INT 2
81515: PUSH
81516: LD_INT 3
81518: PUSH
81519: LD_INT 5
81521: PUSH
81522: EMPTY
81523: LIST
81524: LIST
81525: LIST
81526: LIST
81527: ST_TO_ADDR
// for i in tmp do
81528: LD_ADDR_VAR 0 8
81532: PUSH
81533: LD_VAR 0 14
81537: PUSH
81538: FOR_IN
81539: IFFALSE 81709
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
81541: LD_ADDR_VAR 0 9
81545: PUSH
81546: LD_VAR 0 10
81550: PPUSH
81551: LD_VAR 0 8
81555: PPUSH
81556: LD_INT 5
81558: PPUSH
81559: CALL_OW 272
81563: PUSH
81564: LD_VAR 0 11
81568: PPUSH
81569: LD_VAR 0 8
81573: PPUSH
81574: LD_INT 5
81576: PPUSH
81577: CALL_OW 273
81581: PUSH
81582: EMPTY
81583: LIST
81584: LIST
81585: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
81586: LD_VAR 0 9
81590: PUSH
81591: LD_INT 1
81593: ARRAY
81594: PPUSH
81595: LD_VAR 0 9
81599: PUSH
81600: LD_INT 2
81602: ARRAY
81603: PPUSH
81604: CALL_OW 488
81608: IFFALSE 81707
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
81610: LD_ADDR_VAR 0 4
81614: PUSH
81615: LD_VAR 0 9
81619: PUSH
81620: LD_INT 1
81622: ARRAY
81623: PPUSH
81624: LD_VAR 0 9
81628: PUSH
81629: LD_INT 2
81631: ARRAY
81632: PPUSH
81633: CALL_OW 546
81637: ST_TO_ADDR
// if hex [ 1 ] then
81638: LD_VAR 0 4
81642: PUSH
81643: LD_INT 1
81645: ARRAY
81646: IFFALSE 81650
// continue ;
81648: GO 81538
// h := hex [ 2 ] ;
81650: LD_ADDR_VAR 0 13
81654: PUSH
81655: LD_VAR 0 4
81659: PUSH
81660: LD_INT 2
81662: ARRAY
81663: ST_TO_ADDR
// if h + 7 < height then
81664: LD_VAR 0 13
81668: PUSH
81669: LD_INT 7
81671: PLUS
81672: PUSH
81673: LD_VAR 0 15
81677: LESS
81678: IFFALSE 81707
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
81680: LD_ADDR_VAR 0 18
81684: PUSH
81685: LD_INT 7
81687: PUSH
81688: LD_INT 28
81690: PUSH
81691: LD_INT 45
81693: PUSH
81694: EMPTY
81695: LIST
81696: LIST
81697: LIST
81698: PUSH
81699: LD_VAR 0 12
81703: ARRAY
81704: ST_TO_ADDR
// break ;
81705: GO 81709
// end ; end ; end ;
81707: GO 81538
81709: POP
81710: POP
// end ; if not weapon then
81711: LD_VAR 0 18
81715: NOT
81716: IFFALSE 81776
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
81718: LD_ADDR_VAR 0 5
81722: PUSH
81723: LD_VAR 0 5
81727: PUSH
81728: LD_INT 11
81730: PUSH
81731: LD_INT 30
81733: PUSH
81734: LD_INT 49
81736: PUSH
81737: EMPTY
81738: LIST
81739: LIST
81740: LIST
81741: DIFF
81742: ST_TO_ADDR
// if not list then
81743: LD_VAR 0 5
81747: NOT
81748: IFFALSE 81752
// exit ;
81750: GO 81894
// weapon := list [ rand ( 1 , list ) ] ;
81752: LD_ADDR_VAR 0 18
81756: PUSH
81757: LD_VAR 0 5
81761: PUSH
81762: LD_INT 1
81764: PPUSH
81765: LD_VAR 0 5
81769: PPUSH
81770: CALL_OW 12
81774: ARRAY
81775: ST_TO_ADDR
// end ; if weapon then
81776: LD_VAR 0 18
81780: IFFALSE 81894
// begin tmp := CostOfWeapon ( weapon ) ;
81782: LD_ADDR_VAR 0 14
81786: PUSH
81787: LD_VAR 0 18
81791: PPUSH
81792: CALL_OW 451
81796: ST_TO_ADDR
// j := GetBase ( tower ) ;
81797: LD_ADDR_VAR 0 9
81801: PUSH
81802: LD_VAR 0 1
81806: PPUSH
81807: CALL_OW 274
81811: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
81812: LD_VAR 0 9
81816: PPUSH
81817: LD_INT 1
81819: PPUSH
81820: CALL_OW 275
81824: PUSH
81825: LD_VAR 0 14
81829: PUSH
81830: LD_INT 1
81832: ARRAY
81833: GREATEREQUAL
81834: PUSH
81835: LD_VAR 0 9
81839: PPUSH
81840: LD_INT 2
81842: PPUSH
81843: CALL_OW 275
81847: PUSH
81848: LD_VAR 0 14
81852: PUSH
81853: LD_INT 2
81855: ARRAY
81856: GREATEREQUAL
81857: AND
81858: PUSH
81859: LD_VAR 0 9
81863: PPUSH
81864: LD_INT 3
81866: PPUSH
81867: CALL_OW 275
81871: PUSH
81872: LD_VAR 0 14
81876: PUSH
81877: LD_INT 3
81879: ARRAY
81880: GREATEREQUAL
81881: AND
81882: IFFALSE 81894
// result := weapon ;
81884: LD_ADDR_VAR 0 3
81888: PUSH
81889: LD_VAR 0 18
81893: ST_TO_ADDR
// end ; end ;
81894: LD_VAR 0 3
81898: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
81899: LD_INT 0
81901: PPUSH
81902: PPUSH
// result := true ;
81903: LD_ADDR_VAR 0 3
81907: PUSH
81908: LD_INT 1
81910: ST_TO_ADDR
// if array1 = array2 then
81911: LD_VAR 0 1
81915: PUSH
81916: LD_VAR 0 2
81920: EQUAL
81921: IFFALSE 81981
// begin for i = 1 to array1 do
81923: LD_ADDR_VAR 0 4
81927: PUSH
81928: DOUBLE
81929: LD_INT 1
81931: DEC
81932: ST_TO_ADDR
81933: LD_VAR 0 1
81937: PUSH
81938: FOR_TO
81939: IFFALSE 81977
// if array1 [ i ] <> array2 [ i ] then
81941: LD_VAR 0 1
81945: PUSH
81946: LD_VAR 0 4
81950: ARRAY
81951: PUSH
81952: LD_VAR 0 2
81956: PUSH
81957: LD_VAR 0 4
81961: ARRAY
81962: NONEQUAL
81963: IFFALSE 81975
// begin result := false ;
81965: LD_ADDR_VAR 0 3
81969: PUSH
81970: LD_INT 0
81972: ST_TO_ADDR
// break ;
81973: GO 81977
// end ;
81975: GO 81938
81977: POP
81978: POP
// end else
81979: GO 81989
// result := false ;
81981: LD_ADDR_VAR 0 3
81985: PUSH
81986: LD_INT 0
81988: ST_TO_ADDR
// end ;
81989: LD_VAR 0 3
81993: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
81994: LD_INT 0
81996: PPUSH
81997: PPUSH
// if not array1 or not array2 then
81998: LD_VAR 0 1
82002: NOT
82003: PUSH
82004: LD_VAR 0 2
82008: NOT
82009: OR
82010: IFFALSE 82014
// exit ;
82012: GO 82078
// result := true ;
82014: LD_ADDR_VAR 0 3
82018: PUSH
82019: LD_INT 1
82021: ST_TO_ADDR
// for i = 1 to array1 do
82022: LD_ADDR_VAR 0 4
82026: PUSH
82027: DOUBLE
82028: LD_INT 1
82030: DEC
82031: ST_TO_ADDR
82032: LD_VAR 0 1
82036: PUSH
82037: FOR_TO
82038: IFFALSE 82076
// if array1 [ i ] <> array2 [ i ] then
82040: LD_VAR 0 1
82044: PUSH
82045: LD_VAR 0 4
82049: ARRAY
82050: PUSH
82051: LD_VAR 0 2
82055: PUSH
82056: LD_VAR 0 4
82060: ARRAY
82061: NONEQUAL
82062: IFFALSE 82074
// begin result := false ;
82064: LD_ADDR_VAR 0 3
82068: PUSH
82069: LD_INT 0
82071: ST_TO_ADDR
// break ;
82072: GO 82076
// end ;
82074: GO 82037
82076: POP
82077: POP
// end ;
82078: LD_VAR 0 3
82082: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
82083: LD_INT 0
82085: PPUSH
82086: PPUSH
82087: PPUSH
// pom := GetBase ( fac ) ;
82088: LD_ADDR_VAR 0 5
82092: PUSH
82093: LD_VAR 0 1
82097: PPUSH
82098: CALL_OW 274
82102: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
82103: LD_ADDR_VAR 0 4
82107: PUSH
82108: LD_VAR 0 2
82112: PUSH
82113: LD_INT 1
82115: ARRAY
82116: PPUSH
82117: LD_VAR 0 2
82121: PUSH
82122: LD_INT 2
82124: ARRAY
82125: PPUSH
82126: LD_VAR 0 2
82130: PUSH
82131: LD_INT 3
82133: ARRAY
82134: PPUSH
82135: LD_VAR 0 2
82139: PUSH
82140: LD_INT 4
82142: ARRAY
82143: PPUSH
82144: CALL_OW 449
82148: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
82149: LD_ADDR_VAR 0 3
82153: PUSH
82154: LD_VAR 0 5
82158: PPUSH
82159: LD_INT 1
82161: PPUSH
82162: CALL_OW 275
82166: PUSH
82167: LD_VAR 0 4
82171: PUSH
82172: LD_INT 1
82174: ARRAY
82175: GREATEREQUAL
82176: PUSH
82177: LD_VAR 0 5
82181: PPUSH
82182: LD_INT 2
82184: PPUSH
82185: CALL_OW 275
82189: PUSH
82190: LD_VAR 0 4
82194: PUSH
82195: LD_INT 2
82197: ARRAY
82198: GREATEREQUAL
82199: AND
82200: PUSH
82201: LD_VAR 0 5
82205: PPUSH
82206: LD_INT 3
82208: PPUSH
82209: CALL_OW 275
82213: PUSH
82214: LD_VAR 0 4
82218: PUSH
82219: LD_INT 3
82221: ARRAY
82222: GREATEREQUAL
82223: AND
82224: ST_TO_ADDR
// end ;
82225: LD_VAR 0 3
82229: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
82230: LD_INT 0
82232: PPUSH
82233: PPUSH
82234: PPUSH
82235: PPUSH
// pom := GetBase ( building ) ;
82236: LD_ADDR_VAR 0 3
82240: PUSH
82241: LD_VAR 0 1
82245: PPUSH
82246: CALL_OW 274
82250: ST_TO_ADDR
// if not pom then
82251: LD_VAR 0 3
82255: NOT
82256: IFFALSE 82260
// exit ;
82258: GO 82430
// btype := GetBType ( building ) ;
82260: LD_ADDR_VAR 0 5
82264: PUSH
82265: LD_VAR 0 1
82269: PPUSH
82270: CALL_OW 266
82274: ST_TO_ADDR
// if btype = b_armoury then
82275: LD_VAR 0 5
82279: PUSH
82280: LD_INT 4
82282: EQUAL
82283: IFFALSE 82293
// btype := b_barracks ;
82285: LD_ADDR_VAR 0 5
82289: PUSH
82290: LD_INT 5
82292: ST_TO_ADDR
// if btype = b_depot then
82293: LD_VAR 0 5
82297: PUSH
82298: LD_INT 0
82300: EQUAL
82301: IFFALSE 82311
// btype := b_warehouse ;
82303: LD_ADDR_VAR 0 5
82307: PUSH
82308: LD_INT 1
82310: ST_TO_ADDR
// if btype = b_workshop then
82311: LD_VAR 0 5
82315: PUSH
82316: LD_INT 2
82318: EQUAL
82319: IFFALSE 82329
// btype := b_factory ;
82321: LD_ADDR_VAR 0 5
82325: PUSH
82326: LD_INT 3
82328: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
82329: LD_ADDR_VAR 0 4
82333: PUSH
82334: LD_VAR 0 5
82338: PPUSH
82339: LD_VAR 0 1
82343: PPUSH
82344: CALL_OW 248
82348: PPUSH
82349: CALL_OW 450
82353: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
82354: LD_ADDR_VAR 0 2
82358: PUSH
82359: LD_VAR 0 3
82363: PPUSH
82364: LD_INT 1
82366: PPUSH
82367: CALL_OW 275
82371: PUSH
82372: LD_VAR 0 4
82376: PUSH
82377: LD_INT 1
82379: ARRAY
82380: GREATEREQUAL
82381: PUSH
82382: LD_VAR 0 3
82386: PPUSH
82387: LD_INT 2
82389: PPUSH
82390: CALL_OW 275
82394: PUSH
82395: LD_VAR 0 4
82399: PUSH
82400: LD_INT 2
82402: ARRAY
82403: GREATEREQUAL
82404: AND
82405: PUSH
82406: LD_VAR 0 3
82410: PPUSH
82411: LD_INT 3
82413: PPUSH
82414: CALL_OW 275
82418: PUSH
82419: LD_VAR 0 4
82423: PUSH
82424: LD_INT 3
82426: ARRAY
82427: GREATEREQUAL
82428: AND
82429: ST_TO_ADDR
// end ;
82430: LD_VAR 0 2
82434: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
82435: LD_INT 0
82437: PPUSH
82438: PPUSH
82439: PPUSH
// pom := GetBase ( building ) ;
82440: LD_ADDR_VAR 0 4
82444: PUSH
82445: LD_VAR 0 1
82449: PPUSH
82450: CALL_OW 274
82454: ST_TO_ADDR
// if not pom then
82455: LD_VAR 0 4
82459: NOT
82460: IFFALSE 82464
// exit ;
82462: GO 82565
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
82464: LD_ADDR_VAR 0 5
82468: PUSH
82469: LD_VAR 0 2
82473: PPUSH
82474: LD_VAR 0 1
82478: PPUSH
82479: CALL_OW 248
82483: PPUSH
82484: CALL_OW 450
82488: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
82489: LD_ADDR_VAR 0 3
82493: PUSH
82494: LD_VAR 0 4
82498: PPUSH
82499: LD_INT 1
82501: PPUSH
82502: CALL_OW 275
82506: PUSH
82507: LD_VAR 0 5
82511: PUSH
82512: LD_INT 1
82514: ARRAY
82515: GREATEREQUAL
82516: PUSH
82517: LD_VAR 0 4
82521: PPUSH
82522: LD_INT 2
82524: PPUSH
82525: CALL_OW 275
82529: PUSH
82530: LD_VAR 0 5
82534: PUSH
82535: LD_INT 2
82537: ARRAY
82538: GREATEREQUAL
82539: AND
82540: PUSH
82541: LD_VAR 0 4
82545: PPUSH
82546: LD_INT 3
82548: PPUSH
82549: CALL_OW 275
82553: PUSH
82554: LD_VAR 0 5
82558: PUSH
82559: LD_INT 3
82561: ARRAY
82562: GREATEREQUAL
82563: AND
82564: ST_TO_ADDR
// end ;
82565: LD_VAR 0 3
82569: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
82570: LD_INT 0
82572: PPUSH
82573: PPUSH
82574: PPUSH
82575: PPUSH
82576: PPUSH
82577: PPUSH
82578: PPUSH
82579: PPUSH
82580: PPUSH
82581: PPUSH
82582: PPUSH
// result := false ;
82583: LD_ADDR_VAR 0 8
82587: PUSH
82588: LD_INT 0
82590: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
82591: LD_VAR 0 5
82595: NOT
82596: PUSH
82597: LD_VAR 0 1
82601: NOT
82602: OR
82603: PUSH
82604: LD_VAR 0 2
82608: NOT
82609: OR
82610: PUSH
82611: LD_VAR 0 3
82615: NOT
82616: OR
82617: IFFALSE 82621
// exit ;
82619: GO 83435
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
82621: LD_ADDR_VAR 0 14
82625: PUSH
82626: LD_VAR 0 1
82630: PPUSH
82631: LD_VAR 0 2
82635: PPUSH
82636: LD_VAR 0 3
82640: PPUSH
82641: LD_VAR 0 4
82645: PPUSH
82646: LD_VAR 0 5
82650: PUSH
82651: LD_INT 1
82653: ARRAY
82654: PPUSH
82655: CALL_OW 248
82659: PPUSH
82660: LD_INT 0
82662: PPUSH
82663: CALL 84688 0 6
82667: ST_TO_ADDR
// if not hexes then
82668: LD_VAR 0 14
82672: NOT
82673: IFFALSE 82677
// exit ;
82675: GO 83435
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
82677: LD_ADDR_VAR 0 17
82681: PUSH
82682: LD_VAR 0 5
82686: PPUSH
82687: LD_INT 22
82689: PUSH
82690: LD_VAR 0 13
82694: PPUSH
82695: CALL_OW 255
82699: PUSH
82700: EMPTY
82701: LIST
82702: LIST
82703: PUSH
82704: LD_INT 2
82706: PUSH
82707: LD_INT 30
82709: PUSH
82710: LD_INT 0
82712: PUSH
82713: EMPTY
82714: LIST
82715: LIST
82716: PUSH
82717: LD_INT 30
82719: PUSH
82720: LD_INT 1
82722: PUSH
82723: EMPTY
82724: LIST
82725: LIST
82726: PUSH
82727: EMPTY
82728: LIST
82729: LIST
82730: LIST
82731: PUSH
82732: EMPTY
82733: LIST
82734: LIST
82735: PPUSH
82736: CALL_OW 72
82740: ST_TO_ADDR
// for i = 1 to hexes do
82741: LD_ADDR_VAR 0 9
82745: PUSH
82746: DOUBLE
82747: LD_INT 1
82749: DEC
82750: ST_TO_ADDR
82751: LD_VAR 0 14
82755: PUSH
82756: FOR_TO
82757: IFFALSE 83433
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
82759: LD_ADDR_VAR 0 13
82763: PUSH
82764: LD_VAR 0 14
82768: PUSH
82769: LD_VAR 0 9
82773: ARRAY
82774: PUSH
82775: LD_INT 1
82777: ARRAY
82778: PPUSH
82779: LD_VAR 0 14
82783: PUSH
82784: LD_VAR 0 9
82788: ARRAY
82789: PUSH
82790: LD_INT 2
82792: ARRAY
82793: PPUSH
82794: CALL_OW 428
82798: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
82799: LD_VAR 0 14
82803: PUSH
82804: LD_VAR 0 9
82808: ARRAY
82809: PUSH
82810: LD_INT 1
82812: ARRAY
82813: PPUSH
82814: LD_VAR 0 14
82818: PUSH
82819: LD_VAR 0 9
82823: ARRAY
82824: PUSH
82825: LD_INT 2
82827: ARRAY
82828: PPUSH
82829: CALL_OW 351
82833: PUSH
82834: LD_VAR 0 14
82838: PUSH
82839: LD_VAR 0 9
82843: ARRAY
82844: PUSH
82845: LD_INT 1
82847: ARRAY
82848: PPUSH
82849: LD_VAR 0 14
82853: PUSH
82854: LD_VAR 0 9
82858: ARRAY
82859: PUSH
82860: LD_INT 2
82862: ARRAY
82863: PPUSH
82864: CALL_OW 488
82868: NOT
82869: OR
82870: PUSH
82871: LD_VAR 0 13
82875: PPUSH
82876: CALL_OW 247
82880: PUSH
82881: LD_INT 3
82883: EQUAL
82884: OR
82885: IFFALSE 82891
// exit ;
82887: POP
82888: POP
82889: GO 83435
// if not tmp then
82891: LD_VAR 0 13
82895: NOT
82896: IFFALSE 82900
// continue ;
82898: GO 82756
// result := true ;
82900: LD_ADDR_VAR 0 8
82904: PUSH
82905: LD_INT 1
82907: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
82908: LD_VAR 0 6
82912: PUSH
82913: LD_VAR 0 13
82917: PPUSH
82918: CALL_OW 247
82922: PUSH
82923: LD_INT 2
82925: EQUAL
82926: AND
82927: PUSH
82928: LD_VAR 0 13
82932: PPUSH
82933: CALL_OW 263
82937: PUSH
82938: LD_INT 1
82940: EQUAL
82941: AND
82942: IFFALSE 83106
// begin if IsDrivenBy ( tmp ) then
82944: LD_VAR 0 13
82948: PPUSH
82949: CALL_OW 311
82953: IFFALSE 82957
// continue ;
82955: GO 82756
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
82957: LD_VAR 0 6
82961: PPUSH
82962: LD_INT 3
82964: PUSH
82965: LD_INT 60
82967: PUSH
82968: EMPTY
82969: LIST
82970: PUSH
82971: EMPTY
82972: LIST
82973: LIST
82974: PUSH
82975: LD_INT 3
82977: PUSH
82978: LD_INT 55
82980: PUSH
82981: EMPTY
82982: LIST
82983: PUSH
82984: EMPTY
82985: LIST
82986: LIST
82987: PUSH
82988: EMPTY
82989: LIST
82990: LIST
82991: PPUSH
82992: CALL_OW 72
82996: IFFALSE 83104
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
82998: LD_ADDR_VAR 0 18
83002: PUSH
83003: LD_VAR 0 6
83007: PPUSH
83008: LD_INT 3
83010: PUSH
83011: LD_INT 60
83013: PUSH
83014: EMPTY
83015: LIST
83016: PUSH
83017: EMPTY
83018: LIST
83019: LIST
83020: PUSH
83021: LD_INT 3
83023: PUSH
83024: LD_INT 55
83026: PUSH
83027: EMPTY
83028: LIST
83029: PUSH
83030: EMPTY
83031: LIST
83032: LIST
83033: PUSH
83034: EMPTY
83035: LIST
83036: LIST
83037: PPUSH
83038: CALL_OW 72
83042: PUSH
83043: LD_INT 1
83045: ARRAY
83046: ST_TO_ADDR
// if IsInUnit ( driver ) then
83047: LD_VAR 0 18
83051: PPUSH
83052: CALL_OW 310
83056: IFFALSE 83067
// ComExit ( driver ) ;
83058: LD_VAR 0 18
83062: PPUSH
83063: CALL 108489 0 1
// AddComEnterUnit ( driver , tmp ) ;
83067: LD_VAR 0 18
83071: PPUSH
83072: LD_VAR 0 13
83076: PPUSH
83077: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
83081: LD_VAR 0 18
83085: PPUSH
83086: LD_VAR 0 7
83090: PPUSH
83091: CALL_OW 173
// AddComExitVehicle ( driver ) ;
83095: LD_VAR 0 18
83099: PPUSH
83100: CALL_OW 181
// end ; continue ;
83104: GO 82756
// end ; if not cleaners or not tmp in cleaners then
83106: LD_VAR 0 6
83110: NOT
83111: PUSH
83112: LD_VAR 0 13
83116: PUSH
83117: LD_VAR 0 6
83121: IN
83122: NOT
83123: OR
83124: IFFALSE 83431
// begin if dep then
83126: LD_VAR 0 17
83130: IFFALSE 83266
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
83132: LD_ADDR_VAR 0 16
83136: PUSH
83137: LD_VAR 0 17
83141: PUSH
83142: LD_INT 1
83144: ARRAY
83145: PPUSH
83146: CALL_OW 250
83150: PPUSH
83151: LD_VAR 0 17
83155: PUSH
83156: LD_INT 1
83158: ARRAY
83159: PPUSH
83160: CALL_OW 254
83164: PPUSH
83165: LD_INT 5
83167: PPUSH
83168: CALL_OW 272
83172: PUSH
83173: LD_VAR 0 17
83177: PUSH
83178: LD_INT 1
83180: ARRAY
83181: PPUSH
83182: CALL_OW 251
83186: PPUSH
83187: LD_VAR 0 17
83191: PUSH
83192: LD_INT 1
83194: ARRAY
83195: PPUSH
83196: CALL_OW 254
83200: PPUSH
83201: LD_INT 5
83203: PPUSH
83204: CALL_OW 273
83208: PUSH
83209: EMPTY
83210: LIST
83211: LIST
83212: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
83213: LD_VAR 0 16
83217: PUSH
83218: LD_INT 1
83220: ARRAY
83221: PPUSH
83222: LD_VAR 0 16
83226: PUSH
83227: LD_INT 2
83229: ARRAY
83230: PPUSH
83231: CALL_OW 488
83235: IFFALSE 83266
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
83237: LD_VAR 0 13
83241: PPUSH
83242: LD_VAR 0 16
83246: PUSH
83247: LD_INT 1
83249: ARRAY
83250: PPUSH
83251: LD_VAR 0 16
83255: PUSH
83256: LD_INT 2
83258: ARRAY
83259: PPUSH
83260: CALL_OW 111
// continue ;
83264: GO 82756
// end ; end ; r := GetDir ( tmp ) ;
83266: LD_ADDR_VAR 0 15
83270: PUSH
83271: LD_VAR 0 13
83275: PPUSH
83276: CALL_OW 254
83280: ST_TO_ADDR
// if r = 5 then
83281: LD_VAR 0 15
83285: PUSH
83286: LD_INT 5
83288: EQUAL
83289: IFFALSE 83299
// r := 0 ;
83291: LD_ADDR_VAR 0 15
83295: PUSH
83296: LD_INT 0
83298: ST_TO_ADDR
// for j = r to 5 do
83299: LD_ADDR_VAR 0 10
83303: PUSH
83304: DOUBLE
83305: LD_VAR 0 15
83309: DEC
83310: ST_TO_ADDR
83311: LD_INT 5
83313: PUSH
83314: FOR_TO
83315: IFFALSE 83429
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
83317: LD_ADDR_VAR 0 11
83321: PUSH
83322: LD_VAR 0 13
83326: PPUSH
83327: CALL_OW 250
83331: PPUSH
83332: LD_VAR 0 10
83336: PPUSH
83337: LD_INT 2
83339: PPUSH
83340: CALL_OW 272
83344: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
83345: LD_ADDR_VAR 0 12
83349: PUSH
83350: LD_VAR 0 13
83354: PPUSH
83355: CALL_OW 251
83359: PPUSH
83360: LD_VAR 0 10
83364: PPUSH
83365: LD_INT 2
83367: PPUSH
83368: CALL_OW 273
83372: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
83373: LD_VAR 0 11
83377: PPUSH
83378: LD_VAR 0 12
83382: PPUSH
83383: CALL_OW 488
83387: PUSH
83388: LD_VAR 0 11
83392: PPUSH
83393: LD_VAR 0 12
83397: PPUSH
83398: CALL_OW 428
83402: NOT
83403: AND
83404: IFFALSE 83427
// begin ComMoveXY ( tmp , _x , _y ) ;
83406: LD_VAR 0 13
83410: PPUSH
83411: LD_VAR 0 11
83415: PPUSH
83416: LD_VAR 0 12
83420: PPUSH
83421: CALL_OW 111
// break ;
83425: GO 83429
// end ; end ;
83427: GO 83314
83429: POP
83430: POP
// end ; end ;
83431: GO 82756
83433: POP
83434: POP
// end ;
83435: LD_VAR 0 8
83439: RET
// export function BuildingTechInvented ( side , btype ) ; begin
83440: LD_INT 0
83442: PPUSH
// result := true ;
83443: LD_ADDR_VAR 0 3
83447: PUSH
83448: LD_INT 1
83450: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
83451: LD_VAR 0 2
83455: PUSH
83456: LD_INT 24
83458: DOUBLE
83459: EQUAL
83460: IFTRUE 83470
83462: LD_INT 33
83464: DOUBLE
83465: EQUAL
83466: IFTRUE 83470
83468: GO 83495
83470: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
83471: LD_ADDR_VAR 0 3
83475: PUSH
83476: LD_INT 32
83478: PPUSH
83479: LD_VAR 0 1
83483: PPUSH
83484: CALL_OW 321
83488: PUSH
83489: LD_INT 2
83491: EQUAL
83492: ST_TO_ADDR
83493: GO 83811
83495: LD_INT 20
83497: DOUBLE
83498: EQUAL
83499: IFTRUE 83503
83501: GO 83528
83503: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
83504: LD_ADDR_VAR 0 3
83508: PUSH
83509: LD_INT 6
83511: PPUSH
83512: LD_VAR 0 1
83516: PPUSH
83517: CALL_OW 321
83521: PUSH
83522: LD_INT 2
83524: EQUAL
83525: ST_TO_ADDR
83526: GO 83811
83528: LD_INT 22
83530: DOUBLE
83531: EQUAL
83532: IFTRUE 83542
83534: LD_INT 36
83536: DOUBLE
83537: EQUAL
83538: IFTRUE 83542
83540: GO 83567
83542: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
83543: LD_ADDR_VAR 0 3
83547: PUSH
83548: LD_INT 15
83550: PPUSH
83551: LD_VAR 0 1
83555: PPUSH
83556: CALL_OW 321
83560: PUSH
83561: LD_INT 2
83563: EQUAL
83564: ST_TO_ADDR
83565: GO 83811
83567: LD_INT 30
83569: DOUBLE
83570: EQUAL
83571: IFTRUE 83575
83573: GO 83600
83575: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
83576: LD_ADDR_VAR 0 3
83580: PUSH
83581: LD_INT 20
83583: PPUSH
83584: LD_VAR 0 1
83588: PPUSH
83589: CALL_OW 321
83593: PUSH
83594: LD_INT 2
83596: EQUAL
83597: ST_TO_ADDR
83598: GO 83811
83600: LD_INT 28
83602: DOUBLE
83603: EQUAL
83604: IFTRUE 83614
83606: LD_INT 21
83608: DOUBLE
83609: EQUAL
83610: IFTRUE 83614
83612: GO 83639
83614: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
83615: LD_ADDR_VAR 0 3
83619: PUSH
83620: LD_INT 21
83622: PPUSH
83623: LD_VAR 0 1
83627: PPUSH
83628: CALL_OW 321
83632: PUSH
83633: LD_INT 2
83635: EQUAL
83636: ST_TO_ADDR
83637: GO 83811
83639: LD_INT 16
83641: DOUBLE
83642: EQUAL
83643: IFTRUE 83647
83645: GO 83672
83647: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
83648: LD_ADDR_VAR 0 3
83652: PUSH
83653: LD_INT 84
83655: PPUSH
83656: LD_VAR 0 1
83660: PPUSH
83661: CALL_OW 321
83665: PUSH
83666: LD_INT 2
83668: EQUAL
83669: ST_TO_ADDR
83670: GO 83811
83672: LD_INT 19
83674: DOUBLE
83675: EQUAL
83676: IFTRUE 83686
83678: LD_INT 23
83680: DOUBLE
83681: EQUAL
83682: IFTRUE 83686
83684: GO 83711
83686: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
83687: LD_ADDR_VAR 0 3
83691: PUSH
83692: LD_INT 83
83694: PPUSH
83695: LD_VAR 0 1
83699: PPUSH
83700: CALL_OW 321
83704: PUSH
83705: LD_INT 2
83707: EQUAL
83708: ST_TO_ADDR
83709: GO 83811
83711: LD_INT 17
83713: DOUBLE
83714: EQUAL
83715: IFTRUE 83719
83717: GO 83744
83719: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
83720: LD_ADDR_VAR 0 3
83724: PUSH
83725: LD_INT 39
83727: PPUSH
83728: LD_VAR 0 1
83732: PPUSH
83733: CALL_OW 321
83737: PUSH
83738: LD_INT 2
83740: EQUAL
83741: ST_TO_ADDR
83742: GO 83811
83744: LD_INT 18
83746: DOUBLE
83747: EQUAL
83748: IFTRUE 83752
83750: GO 83777
83752: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
83753: LD_ADDR_VAR 0 3
83757: PUSH
83758: LD_INT 40
83760: PPUSH
83761: LD_VAR 0 1
83765: PPUSH
83766: CALL_OW 321
83770: PUSH
83771: LD_INT 2
83773: EQUAL
83774: ST_TO_ADDR
83775: GO 83811
83777: LD_INT 27
83779: DOUBLE
83780: EQUAL
83781: IFTRUE 83785
83783: GO 83810
83785: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
83786: LD_ADDR_VAR 0 3
83790: PUSH
83791: LD_INT 35
83793: PPUSH
83794: LD_VAR 0 1
83798: PPUSH
83799: CALL_OW 321
83803: PUSH
83804: LD_INT 2
83806: EQUAL
83807: ST_TO_ADDR
83808: GO 83811
83810: POP
// end ;
83811: LD_VAR 0 3
83815: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
83816: LD_INT 0
83818: PPUSH
83819: PPUSH
83820: PPUSH
83821: PPUSH
83822: PPUSH
83823: PPUSH
83824: PPUSH
83825: PPUSH
83826: PPUSH
83827: PPUSH
83828: PPUSH
// result := false ;
83829: LD_ADDR_VAR 0 6
83833: PUSH
83834: LD_INT 0
83836: ST_TO_ADDR
// if btype = b_depot then
83837: LD_VAR 0 2
83841: PUSH
83842: LD_INT 0
83844: EQUAL
83845: IFFALSE 83857
// begin result := true ;
83847: LD_ADDR_VAR 0 6
83851: PUSH
83852: LD_INT 1
83854: ST_TO_ADDR
// exit ;
83855: GO 84683
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
83857: LD_VAR 0 1
83861: NOT
83862: PUSH
83863: LD_VAR 0 1
83867: PPUSH
83868: CALL_OW 266
83872: PUSH
83873: LD_INT 0
83875: PUSH
83876: LD_INT 1
83878: PUSH
83879: EMPTY
83880: LIST
83881: LIST
83882: IN
83883: NOT
83884: OR
83885: PUSH
83886: LD_VAR 0 2
83890: NOT
83891: OR
83892: PUSH
83893: LD_VAR 0 5
83897: PUSH
83898: LD_INT 0
83900: PUSH
83901: LD_INT 1
83903: PUSH
83904: LD_INT 2
83906: PUSH
83907: LD_INT 3
83909: PUSH
83910: LD_INT 4
83912: PUSH
83913: LD_INT 5
83915: PUSH
83916: EMPTY
83917: LIST
83918: LIST
83919: LIST
83920: LIST
83921: LIST
83922: LIST
83923: IN
83924: NOT
83925: OR
83926: PUSH
83927: LD_VAR 0 3
83931: PPUSH
83932: LD_VAR 0 4
83936: PPUSH
83937: CALL_OW 488
83941: NOT
83942: OR
83943: IFFALSE 83947
// exit ;
83945: GO 84683
// side := GetSide ( depot ) ;
83947: LD_ADDR_VAR 0 9
83951: PUSH
83952: LD_VAR 0 1
83956: PPUSH
83957: CALL_OW 255
83961: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
83962: LD_VAR 0 9
83966: PPUSH
83967: LD_VAR 0 2
83971: PPUSH
83972: CALL 83440 0 2
83976: NOT
83977: IFFALSE 83981
// exit ;
83979: GO 84683
// pom := GetBase ( depot ) ;
83981: LD_ADDR_VAR 0 10
83985: PUSH
83986: LD_VAR 0 1
83990: PPUSH
83991: CALL_OW 274
83995: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
83996: LD_ADDR_VAR 0 11
84000: PUSH
84001: LD_VAR 0 2
84005: PPUSH
84006: LD_VAR 0 1
84010: PPUSH
84011: CALL_OW 248
84015: PPUSH
84016: CALL_OW 450
84020: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
84021: LD_VAR 0 10
84025: PPUSH
84026: LD_INT 1
84028: PPUSH
84029: CALL_OW 275
84033: PUSH
84034: LD_VAR 0 11
84038: PUSH
84039: LD_INT 1
84041: ARRAY
84042: GREATEREQUAL
84043: PUSH
84044: LD_VAR 0 10
84048: PPUSH
84049: LD_INT 2
84051: PPUSH
84052: CALL_OW 275
84056: PUSH
84057: LD_VAR 0 11
84061: PUSH
84062: LD_INT 2
84064: ARRAY
84065: GREATEREQUAL
84066: AND
84067: PUSH
84068: LD_VAR 0 10
84072: PPUSH
84073: LD_INT 3
84075: PPUSH
84076: CALL_OW 275
84080: PUSH
84081: LD_VAR 0 11
84085: PUSH
84086: LD_INT 3
84088: ARRAY
84089: GREATEREQUAL
84090: AND
84091: NOT
84092: IFFALSE 84096
// exit ;
84094: GO 84683
// if GetBType ( depot ) = b_depot then
84096: LD_VAR 0 1
84100: PPUSH
84101: CALL_OW 266
84105: PUSH
84106: LD_INT 0
84108: EQUAL
84109: IFFALSE 84121
// dist := 28 else
84111: LD_ADDR_VAR 0 14
84115: PUSH
84116: LD_INT 28
84118: ST_TO_ADDR
84119: GO 84129
// dist := 36 ;
84121: LD_ADDR_VAR 0 14
84125: PUSH
84126: LD_INT 36
84128: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
84129: LD_VAR 0 1
84133: PPUSH
84134: LD_VAR 0 3
84138: PPUSH
84139: LD_VAR 0 4
84143: PPUSH
84144: CALL_OW 297
84148: PUSH
84149: LD_VAR 0 14
84153: GREATER
84154: IFFALSE 84158
// exit ;
84156: GO 84683
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
84158: LD_ADDR_VAR 0 12
84162: PUSH
84163: LD_VAR 0 2
84167: PPUSH
84168: LD_VAR 0 3
84172: PPUSH
84173: LD_VAR 0 4
84177: PPUSH
84178: LD_VAR 0 5
84182: PPUSH
84183: LD_VAR 0 1
84187: PPUSH
84188: CALL_OW 248
84192: PPUSH
84193: LD_INT 0
84195: PPUSH
84196: CALL 84688 0 6
84200: ST_TO_ADDR
// if not hexes then
84201: LD_VAR 0 12
84205: NOT
84206: IFFALSE 84210
// exit ;
84208: GO 84683
// hex := GetHexInfo ( x , y ) ;
84210: LD_ADDR_VAR 0 15
84214: PUSH
84215: LD_VAR 0 3
84219: PPUSH
84220: LD_VAR 0 4
84224: PPUSH
84225: CALL_OW 546
84229: ST_TO_ADDR
// if hex [ 1 ] then
84230: LD_VAR 0 15
84234: PUSH
84235: LD_INT 1
84237: ARRAY
84238: IFFALSE 84242
// exit ;
84240: GO 84683
// height := hex [ 2 ] ;
84242: LD_ADDR_VAR 0 13
84246: PUSH
84247: LD_VAR 0 15
84251: PUSH
84252: LD_INT 2
84254: ARRAY
84255: ST_TO_ADDR
// for i = 1 to hexes do
84256: LD_ADDR_VAR 0 7
84260: PUSH
84261: DOUBLE
84262: LD_INT 1
84264: DEC
84265: ST_TO_ADDR
84266: LD_VAR 0 12
84270: PUSH
84271: FOR_TO
84272: IFFALSE 84602
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
84274: LD_VAR 0 12
84278: PUSH
84279: LD_VAR 0 7
84283: ARRAY
84284: PUSH
84285: LD_INT 1
84287: ARRAY
84288: PPUSH
84289: LD_VAR 0 12
84293: PUSH
84294: LD_VAR 0 7
84298: ARRAY
84299: PUSH
84300: LD_INT 2
84302: ARRAY
84303: PPUSH
84304: CALL_OW 488
84308: NOT
84309: PUSH
84310: LD_VAR 0 12
84314: PUSH
84315: LD_VAR 0 7
84319: ARRAY
84320: PUSH
84321: LD_INT 1
84323: ARRAY
84324: PPUSH
84325: LD_VAR 0 12
84329: PUSH
84330: LD_VAR 0 7
84334: ARRAY
84335: PUSH
84336: LD_INT 2
84338: ARRAY
84339: PPUSH
84340: CALL_OW 428
84344: PUSH
84345: LD_INT 0
84347: GREATER
84348: OR
84349: PUSH
84350: LD_VAR 0 12
84354: PUSH
84355: LD_VAR 0 7
84359: ARRAY
84360: PUSH
84361: LD_INT 1
84363: ARRAY
84364: PPUSH
84365: LD_VAR 0 12
84369: PUSH
84370: LD_VAR 0 7
84374: ARRAY
84375: PUSH
84376: LD_INT 2
84378: ARRAY
84379: PPUSH
84380: CALL_OW 351
84384: OR
84385: IFFALSE 84391
// exit ;
84387: POP
84388: POP
84389: GO 84683
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84391: LD_ADDR_VAR 0 8
84395: PUSH
84396: LD_VAR 0 12
84400: PUSH
84401: LD_VAR 0 7
84405: ARRAY
84406: PUSH
84407: LD_INT 1
84409: ARRAY
84410: PPUSH
84411: LD_VAR 0 12
84415: PUSH
84416: LD_VAR 0 7
84420: ARRAY
84421: PUSH
84422: LD_INT 2
84424: ARRAY
84425: PPUSH
84426: CALL_OW 546
84430: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
84431: LD_VAR 0 8
84435: PUSH
84436: LD_INT 1
84438: ARRAY
84439: PUSH
84440: LD_VAR 0 8
84444: PUSH
84445: LD_INT 2
84447: ARRAY
84448: PUSH
84449: LD_VAR 0 13
84453: PUSH
84454: LD_INT 2
84456: PLUS
84457: GREATER
84458: OR
84459: PUSH
84460: LD_VAR 0 8
84464: PUSH
84465: LD_INT 2
84467: ARRAY
84468: PUSH
84469: LD_VAR 0 13
84473: PUSH
84474: LD_INT 2
84476: MINUS
84477: LESS
84478: OR
84479: PUSH
84480: LD_VAR 0 8
84484: PUSH
84485: LD_INT 3
84487: ARRAY
84488: PUSH
84489: LD_INT 0
84491: PUSH
84492: LD_INT 8
84494: PUSH
84495: LD_INT 9
84497: PUSH
84498: LD_INT 10
84500: PUSH
84501: LD_INT 11
84503: PUSH
84504: LD_INT 12
84506: PUSH
84507: LD_INT 13
84509: PUSH
84510: LD_INT 16
84512: PUSH
84513: LD_INT 17
84515: PUSH
84516: LD_INT 18
84518: PUSH
84519: LD_INT 19
84521: PUSH
84522: LD_INT 20
84524: PUSH
84525: LD_INT 21
84527: PUSH
84528: EMPTY
84529: LIST
84530: LIST
84531: LIST
84532: LIST
84533: LIST
84534: LIST
84535: LIST
84536: LIST
84537: LIST
84538: LIST
84539: LIST
84540: LIST
84541: LIST
84542: IN
84543: NOT
84544: OR
84545: PUSH
84546: LD_VAR 0 8
84550: PUSH
84551: LD_INT 5
84553: ARRAY
84554: NOT
84555: OR
84556: PUSH
84557: LD_VAR 0 8
84561: PUSH
84562: LD_INT 6
84564: ARRAY
84565: PUSH
84566: LD_INT 1
84568: PUSH
84569: LD_INT 2
84571: PUSH
84572: LD_INT 7
84574: PUSH
84575: LD_INT 9
84577: PUSH
84578: LD_INT 10
84580: PUSH
84581: LD_INT 11
84583: PUSH
84584: EMPTY
84585: LIST
84586: LIST
84587: LIST
84588: LIST
84589: LIST
84590: LIST
84591: IN
84592: NOT
84593: OR
84594: IFFALSE 84600
// exit ;
84596: POP
84597: POP
84598: GO 84683
// end ;
84600: GO 84271
84602: POP
84603: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
84604: LD_VAR 0 9
84608: PPUSH
84609: LD_VAR 0 3
84613: PPUSH
84614: LD_VAR 0 4
84618: PPUSH
84619: LD_INT 20
84621: PPUSH
84622: CALL 76606 0 4
84626: PUSH
84627: LD_INT 4
84629: ARRAY
84630: IFFALSE 84634
// exit ;
84632: GO 84683
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
84634: LD_VAR 0 2
84638: PUSH
84639: LD_INT 29
84641: PUSH
84642: LD_INT 30
84644: PUSH
84645: EMPTY
84646: LIST
84647: LIST
84648: IN
84649: PUSH
84650: LD_VAR 0 3
84654: PPUSH
84655: LD_VAR 0 4
84659: PPUSH
84660: LD_VAR 0 9
84664: PPUSH
84665: CALL_OW 440
84669: NOT
84670: AND
84671: IFFALSE 84675
// exit ;
84673: GO 84683
// result := true ;
84675: LD_ADDR_VAR 0 6
84679: PUSH
84680: LD_INT 1
84682: ST_TO_ADDR
// end ;
84683: LD_VAR 0 6
84687: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
84688: LD_INT 0
84690: PPUSH
84691: PPUSH
84692: PPUSH
84693: PPUSH
84694: PPUSH
84695: PPUSH
84696: PPUSH
84697: PPUSH
84698: PPUSH
84699: PPUSH
84700: PPUSH
84701: PPUSH
84702: PPUSH
84703: PPUSH
84704: PPUSH
84705: PPUSH
84706: PPUSH
84707: PPUSH
84708: PPUSH
84709: PPUSH
84710: PPUSH
84711: PPUSH
84712: PPUSH
84713: PPUSH
84714: PPUSH
84715: PPUSH
84716: PPUSH
84717: PPUSH
84718: PPUSH
84719: PPUSH
84720: PPUSH
84721: PPUSH
84722: PPUSH
84723: PPUSH
84724: PPUSH
84725: PPUSH
84726: PPUSH
84727: PPUSH
84728: PPUSH
84729: PPUSH
84730: PPUSH
84731: PPUSH
84732: PPUSH
84733: PPUSH
84734: PPUSH
84735: PPUSH
84736: PPUSH
84737: PPUSH
84738: PPUSH
84739: PPUSH
84740: PPUSH
84741: PPUSH
84742: PPUSH
84743: PPUSH
84744: PPUSH
84745: PPUSH
84746: PPUSH
84747: PPUSH
// result = [ ] ;
84748: LD_ADDR_VAR 0 7
84752: PUSH
84753: EMPTY
84754: ST_TO_ADDR
// temp_list = [ ] ;
84755: LD_ADDR_VAR 0 9
84759: PUSH
84760: EMPTY
84761: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
84762: LD_VAR 0 4
84766: PUSH
84767: LD_INT 0
84769: PUSH
84770: LD_INT 1
84772: PUSH
84773: LD_INT 2
84775: PUSH
84776: LD_INT 3
84778: PUSH
84779: LD_INT 4
84781: PUSH
84782: LD_INT 5
84784: PUSH
84785: EMPTY
84786: LIST
84787: LIST
84788: LIST
84789: LIST
84790: LIST
84791: LIST
84792: IN
84793: NOT
84794: PUSH
84795: LD_VAR 0 1
84799: PUSH
84800: LD_INT 0
84802: PUSH
84803: LD_INT 1
84805: PUSH
84806: EMPTY
84807: LIST
84808: LIST
84809: IN
84810: PUSH
84811: LD_VAR 0 5
84815: PUSH
84816: LD_INT 1
84818: PUSH
84819: LD_INT 2
84821: PUSH
84822: LD_INT 3
84824: PUSH
84825: EMPTY
84826: LIST
84827: LIST
84828: LIST
84829: IN
84830: NOT
84831: AND
84832: OR
84833: IFFALSE 84837
// exit ;
84835: GO 103228
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
84837: LD_VAR 0 1
84841: PUSH
84842: LD_INT 6
84844: PUSH
84845: LD_INT 7
84847: PUSH
84848: LD_INT 8
84850: PUSH
84851: LD_INT 13
84853: PUSH
84854: LD_INT 12
84856: PUSH
84857: LD_INT 15
84859: PUSH
84860: LD_INT 11
84862: PUSH
84863: LD_INT 14
84865: PUSH
84866: LD_INT 10
84868: PUSH
84869: EMPTY
84870: LIST
84871: LIST
84872: LIST
84873: LIST
84874: LIST
84875: LIST
84876: LIST
84877: LIST
84878: LIST
84879: IN
84880: IFFALSE 84890
// btype = b_lab ;
84882: LD_ADDR_VAR 0 1
84886: PUSH
84887: LD_INT 6
84889: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
84890: LD_VAR 0 6
84894: PUSH
84895: LD_INT 0
84897: PUSH
84898: LD_INT 1
84900: PUSH
84901: LD_INT 2
84903: PUSH
84904: EMPTY
84905: LIST
84906: LIST
84907: LIST
84908: IN
84909: NOT
84910: PUSH
84911: LD_VAR 0 1
84915: PUSH
84916: LD_INT 0
84918: PUSH
84919: LD_INT 1
84921: PUSH
84922: LD_INT 2
84924: PUSH
84925: LD_INT 3
84927: PUSH
84928: LD_INT 6
84930: PUSH
84931: LD_INT 36
84933: PUSH
84934: LD_INT 4
84936: PUSH
84937: LD_INT 5
84939: PUSH
84940: LD_INT 31
84942: PUSH
84943: LD_INT 32
84945: PUSH
84946: LD_INT 33
84948: PUSH
84949: EMPTY
84950: LIST
84951: LIST
84952: LIST
84953: LIST
84954: LIST
84955: LIST
84956: LIST
84957: LIST
84958: LIST
84959: LIST
84960: LIST
84961: IN
84962: NOT
84963: PUSH
84964: LD_VAR 0 6
84968: PUSH
84969: LD_INT 1
84971: EQUAL
84972: AND
84973: OR
84974: PUSH
84975: LD_VAR 0 1
84979: PUSH
84980: LD_INT 2
84982: PUSH
84983: LD_INT 3
84985: PUSH
84986: EMPTY
84987: LIST
84988: LIST
84989: IN
84990: NOT
84991: PUSH
84992: LD_VAR 0 6
84996: PUSH
84997: LD_INT 2
84999: EQUAL
85000: AND
85001: OR
85002: IFFALSE 85012
// mode = 0 ;
85004: LD_ADDR_VAR 0 6
85008: PUSH
85009: LD_INT 0
85011: ST_TO_ADDR
// case mode of 0 :
85012: LD_VAR 0 6
85016: PUSH
85017: LD_INT 0
85019: DOUBLE
85020: EQUAL
85021: IFTRUE 85025
85023: GO 96478
85025: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
85026: LD_ADDR_VAR 0 11
85030: PUSH
85031: LD_INT 0
85033: PUSH
85034: LD_INT 0
85036: PUSH
85037: EMPTY
85038: LIST
85039: LIST
85040: PUSH
85041: LD_INT 0
85043: PUSH
85044: LD_INT 1
85046: NEG
85047: PUSH
85048: EMPTY
85049: LIST
85050: LIST
85051: PUSH
85052: LD_INT 1
85054: PUSH
85055: LD_INT 0
85057: PUSH
85058: EMPTY
85059: LIST
85060: LIST
85061: PUSH
85062: LD_INT 1
85064: PUSH
85065: LD_INT 1
85067: PUSH
85068: EMPTY
85069: LIST
85070: LIST
85071: PUSH
85072: LD_INT 0
85074: PUSH
85075: LD_INT 1
85077: PUSH
85078: EMPTY
85079: LIST
85080: LIST
85081: PUSH
85082: LD_INT 1
85084: NEG
85085: PUSH
85086: LD_INT 0
85088: PUSH
85089: EMPTY
85090: LIST
85091: LIST
85092: PUSH
85093: LD_INT 1
85095: NEG
85096: PUSH
85097: LD_INT 1
85099: NEG
85100: PUSH
85101: EMPTY
85102: LIST
85103: LIST
85104: PUSH
85105: LD_INT 1
85107: NEG
85108: PUSH
85109: LD_INT 2
85111: NEG
85112: PUSH
85113: EMPTY
85114: LIST
85115: LIST
85116: PUSH
85117: LD_INT 0
85119: PUSH
85120: LD_INT 2
85122: NEG
85123: PUSH
85124: EMPTY
85125: LIST
85126: LIST
85127: PUSH
85128: LD_INT 1
85130: PUSH
85131: LD_INT 1
85133: NEG
85134: PUSH
85135: EMPTY
85136: LIST
85137: LIST
85138: PUSH
85139: LD_INT 1
85141: PUSH
85142: LD_INT 2
85144: PUSH
85145: EMPTY
85146: LIST
85147: LIST
85148: PUSH
85149: LD_INT 0
85151: PUSH
85152: LD_INT 2
85154: PUSH
85155: EMPTY
85156: LIST
85157: LIST
85158: PUSH
85159: LD_INT 1
85161: NEG
85162: PUSH
85163: LD_INT 1
85165: PUSH
85166: EMPTY
85167: LIST
85168: LIST
85169: PUSH
85170: LD_INT 1
85172: PUSH
85173: LD_INT 3
85175: PUSH
85176: EMPTY
85177: LIST
85178: LIST
85179: PUSH
85180: LD_INT 0
85182: PUSH
85183: LD_INT 3
85185: PUSH
85186: EMPTY
85187: LIST
85188: LIST
85189: PUSH
85190: LD_INT 1
85192: NEG
85193: PUSH
85194: LD_INT 2
85196: PUSH
85197: EMPTY
85198: LIST
85199: LIST
85200: PUSH
85201: EMPTY
85202: LIST
85203: LIST
85204: LIST
85205: LIST
85206: LIST
85207: LIST
85208: LIST
85209: LIST
85210: LIST
85211: LIST
85212: LIST
85213: LIST
85214: LIST
85215: LIST
85216: LIST
85217: LIST
85218: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85219: LD_ADDR_VAR 0 12
85223: PUSH
85224: LD_INT 0
85226: PUSH
85227: LD_INT 0
85229: PUSH
85230: EMPTY
85231: LIST
85232: LIST
85233: PUSH
85234: LD_INT 0
85236: PUSH
85237: LD_INT 1
85239: NEG
85240: PUSH
85241: EMPTY
85242: LIST
85243: LIST
85244: PUSH
85245: LD_INT 1
85247: PUSH
85248: LD_INT 0
85250: PUSH
85251: EMPTY
85252: LIST
85253: LIST
85254: PUSH
85255: LD_INT 1
85257: PUSH
85258: LD_INT 1
85260: PUSH
85261: EMPTY
85262: LIST
85263: LIST
85264: PUSH
85265: LD_INT 0
85267: PUSH
85268: LD_INT 1
85270: PUSH
85271: EMPTY
85272: LIST
85273: LIST
85274: PUSH
85275: LD_INT 1
85277: NEG
85278: PUSH
85279: LD_INT 0
85281: PUSH
85282: EMPTY
85283: LIST
85284: LIST
85285: PUSH
85286: LD_INT 1
85288: NEG
85289: PUSH
85290: LD_INT 1
85292: NEG
85293: PUSH
85294: EMPTY
85295: LIST
85296: LIST
85297: PUSH
85298: LD_INT 1
85300: PUSH
85301: LD_INT 1
85303: NEG
85304: PUSH
85305: EMPTY
85306: LIST
85307: LIST
85308: PUSH
85309: LD_INT 2
85311: PUSH
85312: LD_INT 0
85314: PUSH
85315: EMPTY
85316: LIST
85317: LIST
85318: PUSH
85319: LD_INT 2
85321: PUSH
85322: LD_INT 1
85324: PUSH
85325: EMPTY
85326: LIST
85327: LIST
85328: PUSH
85329: LD_INT 1
85331: NEG
85332: PUSH
85333: LD_INT 1
85335: PUSH
85336: EMPTY
85337: LIST
85338: LIST
85339: PUSH
85340: LD_INT 2
85342: NEG
85343: PUSH
85344: LD_INT 0
85346: PUSH
85347: EMPTY
85348: LIST
85349: LIST
85350: PUSH
85351: LD_INT 2
85353: NEG
85354: PUSH
85355: LD_INT 1
85357: NEG
85358: PUSH
85359: EMPTY
85360: LIST
85361: LIST
85362: PUSH
85363: LD_INT 2
85365: NEG
85366: PUSH
85367: LD_INT 1
85369: PUSH
85370: EMPTY
85371: LIST
85372: LIST
85373: PUSH
85374: LD_INT 3
85376: NEG
85377: PUSH
85378: LD_INT 0
85380: PUSH
85381: EMPTY
85382: LIST
85383: LIST
85384: PUSH
85385: LD_INT 3
85387: NEG
85388: PUSH
85389: LD_INT 1
85391: NEG
85392: PUSH
85393: EMPTY
85394: LIST
85395: LIST
85396: PUSH
85397: EMPTY
85398: LIST
85399: LIST
85400: LIST
85401: LIST
85402: LIST
85403: LIST
85404: LIST
85405: LIST
85406: LIST
85407: LIST
85408: LIST
85409: LIST
85410: LIST
85411: LIST
85412: LIST
85413: LIST
85414: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85415: LD_ADDR_VAR 0 13
85419: PUSH
85420: LD_INT 0
85422: PUSH
85423: LD_INT 0
85425: PUSH
85426: EMPTY
85427: LIST
85428: LIST
85429: PUSH
85430: LD_INT 0
85432: PUSH
85433: LD_INT 1
85435: NEG
85436: PUSH
85437: EMPTY
85438: LIST
85439: LIST
85440: PUSH
85441: LD_INT 1
85443: PUSH
85444: LD_INT 0
85446: PUSH
85447: EMPTY
85448: LIST
85449: LIST
85450: PUSH
85451: LD_INT 1
85453: PUSH
85454: LD_INT 1
85456: PUSH
85457: EMPTY
85458: LIST
85459: LIST
85460: PUSH
85461: LD_INT 0
85463: PUSH
85464: LD_INT 1
85466: PUSH
85467: EMPTY
85468: LIST
85469: LIST
85470: PUSH
85471: LD_INT 1
85473: NEG
85474: PUSH
85475: LD_INT 0
85477: PUSH
85478: EMPTY
85479: LIST
85480: LIST
85481: PUSH
85482: LD_INT 1
85484: NEG
85485: PUSH
85486: LD_INT 1
85488: NEG
85489: PUSH
85490: EMPTY
85491: LIST
85492: LIST
85493: PUSH
85494: LD_INT 1
85496: NEG
85497: PUSH
85498: LD_INT 2
85500: NEG
85501: PUSH
85502: EMPTY
85503: LIST
85504: LIST
85505: PUSH
85506: LD_INT 2
85508: PUSH
85509: LD_INT 1
85511: PUSH
85512: EMPTY
85513: LIST
85514: LIST
85515: PUSH
85516: LD_INT 2
85518: PUSH
85519: LD_INT 2
85521: PUSH
85522: EMPTY
85523: LIST
85524: LIST
85525: PUSH
85526: LD_INT 1
85528: PUSH
85529: LD_INT 2
85531: PUSH
85532: EMPTY
85533: LIST
85534: LIST
85535: PUSH
85536: LD_INT 2
85538: NEG
85539: PUSH
85540: LD_INT 1
85542: NEG
85543: PUSH
85544: EMPTY
85545: LIST
85546: LIST
85547: PUSH
85548: LD_INT 2
85550: NEG
85551: PUSH
85552: LD_INT 2
85554: NEG
85555: PUSH
85556: EMPTY
85557: LIST
85558: LIST
85559: PUSH
85560: LD_INT 2
85562: NEG
85563: PUSH
85564: LD_INT 3
85566: NEG
85567: PUSH
85568: EMPTY
85569: LIST
85570: LIST
85571: PUSH
85572: LD_INT 3
85574: NEG
85575: PUSH
85576: LD_INT 2
85578: NEG
85579: PUSH
85580: EMPTY
85581: LIST
85582: LIST
85583: PUSH
85584: LD_INT 3
85586: NEG
85587: PUSH
85588: LD_INT 3
85590: NEG
85591: PUSH
85592: EMPTY
85593: LIST
85594: LIST
85595: PUSH
85596: EMPTY
85597: LIST
85598: LIST
85599: LIST
85600: LIST
85601: LIST
85602: LIST
85603: LIST
85604: LIST
85605: LIST
85606: LIST
85607: LIST
85608: LIST
85609: LIST
85610: LIST
85611: LIST
85612: LIST
85613: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
85614: LD_ADDR_VAR 0 14
85618: PUSH
85619: LD_INT 0
85621: PUSH
85622: LD_INT 0
85624: PUSH
85625: EMPTY
85626: LIST
85627: LIST
85628: PUSH
85629: LD_INT 0
85631: PUSH
85632: LD_INT 1
85634: NEG
85635: PUSH
85636: EMPTY
85637: LIST
85638: LIST
85639: PUSH
85640: LD_INT 1
85642: PUSH
85643: LD_INT 0
85645: PUSH
85646: EMPTY
85647: LIST
85648: LIST
85649: PUSH
85650: LD_INT 1
85652: PUSH
85653: LD_INT 1
85655: PUSH
85656: EMPTY
85657: LIST
85658: LIST
85659: PUSH
85660: LD_INT 0
85662: PUSH
85663: LD_INT 1
85665: PUSH
85666: EMPTY
85667: LIST
85668: LIST
85669: PUSH
85670: LD_INT 1
85672: NEG
85673: PUSH
85674: LD_INT 0
85676: PUSH
85677: EMPTY
85678: LIST
85679: LIST
85680: PUSH
85681: LD_INT 1
85683: NEG
85684: PUSH
85685: LD_INT 1
85687: NEG
85688: PUSH
85689: EMPTY
85690: LIST
85691: LIST
85692: PUSH
85693: LD_INT 1
85695: NEG
85696: PUSH
85697: LD_INT 2
85699: NEG
85700: PUSH
85701: EMPTY
85702: LIST
85703: LIST
85704: PUSH
85705: LD_INT 0
85707: PUSH
85708: LD_INT 2
85710: NEG
85711: PUSH
85712: EMPTY
85713: LIST
85714: LIST
85715: PUSH
85716: LD_INT 1
85718: PUSH
85719: LD_INT 1
85721: NEG
85722: PUSH
85723: EMPTY
85724: LIST
85725: LIST
85726: PUSH
85727: LD_INT 1
85729: PUSH
85730: LD_INT 2
85732: PUSH
85733: EMPTY
85734: LIST
85735: LIST
85736: PUSH
85737: LD_INT 0
85739: PUSH
85740: LD_INT 2
85742: PUSH
85743: EMPTY
85744: LIST
85745: LIST
85746: PUSH
85747: LD_INT 1
85749: NEG
85750: PUSH
85751: LD_INT 1
85753: PUSH
85754: EMPTY
85755: LIST
85756: LIST
85757: PUSH
85758: LD_INT 1
85760: NEG
85761: PUSH
85762: LD_INT 3
85764: NEG
85765: PUSH
85766: EMPTY
85767: LIST
85768: LIST
85769: PUSH
85770: LD_INT 0
85772: PUSH
85773: LD_INT 3
85775: NEG
85776: PUSH
85777: EMPTY
85778: LIST
85779: LIST
85780: PUSH
85781: LD_INT 1
85783: PUSH
85784: LD_INT 2
85786: NEG
85787: PUSH
85788: EMPTY
85789: LIST
85790: LIST
85791: PUSH
85792: EMPTY
85793: LIST
85794: LIST
85795: LIST
85796: LIST
85797: LIST
85798: LIST
85799: LIST
85800: LIST
85801: LIST
85802: LIST
85803: LIST
85804: LIST
85805: LIST
85806: LIST
85807: LIST
85808: LIST
85809: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
85810: LD_ADDR_VAR 0 15
85814: PUSH
85815: LD_INT 0
85817: PUSH
85818: LD_INT 0
85820: PUSH
85821: EMPTY
85822: LIST
85823: LIST
85824: PUSH
85825: LD_INT 0
85827: PUSH
85828: LD_INT 1
85830: NEG
85831: PUSH
85832: EMPTY
85833: LIST
85834: LIST
85835: PUSH
85836: LD_INT 1
85838: PUSH
85839: LD_INT 0
85841: PUSH
85842: EMPTY
85843: LIST
85844: LIST
85845: PUSH
85846: LD_INT 1
85848: PUSH
85849: LD_INT 1
85851: PUSH
85852: EMPTY
85853: LIST
85854: LIST
85855: PUSH
85856: LD_INT 0
85858: PUSH
85859: LD_INT 1
85861: PUSH
85862: EMPTY
85863: LIST
85864: LIST
85865: PUSH
85866: LD_INT 1
85868: NEG
85869: PUSH
85870: LD_INT 0
85872: PUSH
85873: EMPTY
85874: LIST
85875: LIST
85876: PUSH
85877: LD_INT 1
85879: NEG
85880: PUSH
85881: LD_INT 1
85883: NEG
85884: PUSH
85885: EMPTY
85886: LIST
85887: LIST
85888: PUSH
85889: LD_INT 1
85891: PUSH
85892: LD_INT 1
85894: NEG
85895: PUSH
85896: EMPTY
85897: LIST
85898: LIST
85899: PUSH
85900: LD_INT 2
85902: PUSH
85903: LD_INT 0
85905: PUSH
85906: EMPTY
85907: LIST
85908: LIST
85909: PUSH
85910: LD_INT 2
85912: PUSH
85913: LD_INT 1
85915: PUSH
85916: EMPTY
85917: LIST
85918: LIST
85919: PUSH
85920: LD_INT 1
85922: NEG
85923: PUSH
85924: LD_INT 1
85926: PUSH
85927: EMPTY
85928: LIST
85929: LIST
85930: PUSH
85931: LD_INT 2
85933: NEG
85934: PUSH
85935: LD_INT 0
85937: PUSH
85938: EMPTY
85939: LIST
85940: LIST
85941: PUSH
85942: LD_INT 2
85944: NEG
85945: PUSH
85946: LD_INT 1
85948: NEG
85949: PUSH
85950: EMPTY
85951: LIST
85952: LIST
85953: PUSH
85954: LD_INT 2
85956: PUSH
85957: LD_INT 1
85959: NEG
85960: PUSH
85961: EMPTY
85962: LIST
85963: LIST
85964: PUSH
85965: LD_INT 3
85967: PUSH
85968: LD_INT 0
85970: PUSH
85971: EMPTY
85972: LIST
85973: LIST
85974: PUSH
85975: LD_INT 3
85977: PUSH
85978: LD_INT 1
85980: PUSH
85981: EMPTY
85982: LIST
85983: LIST
85984: PUSH
85985: EMPTY
85986: LIST
85987: LIST
85988: LIST
85989: LIST
85990: LIST
85991: LIST
85992: LIST
85993: LIST
85994: LIST
85995: LIST
85996: LIST
85997: LIST
85998: LIST
85999: LIST
86000: LIST
86001: LIST
86002: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
86003: LD_ADDR_VAR 0 16
86007: PUSH
86008: LD_INT 0
86010: PUSH
86011: LD_INT 0
86013: PUSH
86014: EMPTY
86015: LIST
86016: LIST
86017: PUSH
86018: LD_INT 0
86020: PUSH
86021: LD_INT 1
86023: NEG
86024: PUSH
86025: EMPTY
86026: LIST
86027: LIST
86028: PUSH
86029: LD_INT 1
86031: PUSH
86032: LD_INT 0
86034: PUSH
86035: EMPTY
86036: LIST
86037: LIST
86038: PUSH
86039: LD_INT 1
86041: PUSH
86042: LD_INT 1
86044: PUSH
86045: EMPTY
86046: LIST
86047: LIST
86048: PUSH
86049: LD_INT 0
86051: PUSH
86052: LD_INT 1
86054: PUSH
86055: EMPTY
86056: LIST
86057: LIST
86058: PUSH
86059: LD_INT 1
86061: NEG
86062: PUSH
86063: LD_INT 0
86065: PUSH
86066: EMPTY
86067: LIST
86068: LIST
86069: PUSH
86070: LD_INT 1
86072: NEG
86073: PUSH
86074: LD_INT 1
86076: NEG
86077: PUSH
86078: EMPTY
86079: LIST
86080: LIST
86081: PUSH
86082: LD_INT 1
86084: NEG
86085: PUSH
86086: LD_INT 2
86088: NEG
86089: PUSH
86090: EMPTY
86091: LIST
86092: LIST
86093: PUSH
86094: LD_INT 2
86096: PUSH
86097: LD_INT 1
86099: PUSH
86100: EMPTY
86101: LIST
86102: LIST
86103: PUSH
86104: LD_INT 2
86106: PUSH
86107: LD_INT 2
86109: PUSH
86110: EMPTY
86111: LIST
86112: LIST
86113: PUSH
86114: LD_INT 1
86116: PUSH
86117: LD_INT 2
86119: PUSH
86120: EMPTY
86121: LIST
86122: LIST
86123: PUSH
86124: LD_INT 2
86126: NEG
86127: PUSH
86128: LD_INT 1
86130: NEG
86131: PUSH
86132: EMPTY
86133: LIST
86134: LIST
86135: PUSH
86136: LD_INT 2
86138: NEG
86139: PUSH
86140: LD_INT 2
86142: NEG
86143: PUSH
86144: EMPTY
86145: LIST
86146: LIST
86147: PUSH
86148: LD_INT 3
86150: PUSH
86151: LD_INT 2
86153: PUSH
86154: EMPTY
86155: LIST
86156: LIST
86157: PUSH
86158: LD_INT 3
86160: PUSH
86161: LD_INT 3
86163: PUSH
86164: EMPTY
86165: LIST
86166: LIST
86167: PUSH
86168: LD_INT 2
86170: PUSH
86171: LD_INT 3
86173: PUSH
86174: EMPTY
86175: LIST
86176: LIST
86177: PUSH
86178: EMPTY
86179: LIST
86180: LIST
86181: LIST
86182: LIST
86183: LIST
86184: LIST
86185: LIST
86186: LIST
86187: LIST
86188: LIST
86189: LIST
86190: LIST
86191: LIST
86192: LIST
86193: LIST
86194: LIST
86195: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86196: LD_ADDR_VAR 0 17
86200: PUSH
86201: LD_INT 0
86203: PUSH
86204: LD_INT 0
86206: PUSH
86207: EMPTY
86208: LIST
86209: LIST
86210: PUSH
86211: LD_INT 0
86213: PUSH
86214: LD_INT 1
86216: NEG
86217: PUSH
86218: EMPTY
86219: LIST
86220: LIST
86221: PUSH
86222: LD_INT 1
86224: PUSH
86225: LD_INT 0
86227: PUSH
86228: EMPTY
86229: LIST
86230: LIST
86231: PUSH
86232: LD_INT 1
86234: PUSH
86235: LD_INT 1
86237: PUSH
86238: EMPTY
86239: LIST
86240: LIST
86241: PUSH
86242: LD_INT 0
86244: PUSH
86245: LD_INT 1
86247: PUSH
86248: EMPTY
86249: LIST
86250: LIST
86251: PUSH
86252: LD_INT 1
86254: NEG
86255: PUSH
86256: LD_INT 0
86258: PUSH
86259: EMPTY
86260: LIST
86261: LIST
86262: PUSH
86263: LD_INT 1
86265: NEG
86266: PUSH
86267: LD_INT 1
86269: NEG
86270: PUSH
86271: EMPTY
86272: LIST
86273: LIST
86274: PUSH
86275: LD_INT 1
86277: NEG
86278: PUSH
86279: LD_INT 2
86281: NEG
86282: PUSH
86283: EMPTY
86284: LIST
86285: LIST
86286: PUSH
86287: LD_INT 0
86289: PUSH
86290: LD_INT 2
86292: NEG
86293: PUSH
86294: EMPTY
86295: LIST
86296: LIST
86297: PUSH
86298: LD_INT 1
86300: PUSH
86301: LD_INT 1
86303: NEG
86304: PUSH
86305: EMPTY
86306: LIST
86307: LIST
86308: PUSH
86309: LD_INT 2
86311: PUSH
86312: LD_INT 0
86314: PUSH
86315: EMPTY
86316: LIST
86317: LIST
86318: PUSH
86319: LD_INT 2
86321: PUSH
86322: LD_INT 1
86324: PUSH
86325: EMPTY
86326: LIST
86327: LIST
86328: PUSH
86329: LD_INT 2
86331: PUSH
86332: LD_INT 2
86334: PUSH
86335: EMPTY
86336: LIST
86337: LIST
86338: PUSH
86339: LD_INT 1
86341: PUSH
86342: LD_INT 2
86344: PUSH
86345: EMPTY
86346: LIST
86347: LIST
86348: PUSH
86349: LD_INT 0
86351: PUSH
86352: LD_INT 2
86354: PUSH
86355: EMPTY
86356: LIST
86357: LIST
86358: PUSH
86359: LD_INT 1
86361: NEG
86362: PUSH
86363: LD_INT 1
86365: PUSH
86366: EMPTY
86367: LIST
86368: LIST
86369: PUSH
86370: LD_INT 2
86372: NEG
86373: PUSH
86374: LD_INT 0
86376: PUSH
86377: EMPTY
86378: LIST
86379: LIST
86380: PUSH
86381: LD_INT 2
86383: NEG
86384: PUSH
86385: LD_INT 1
86387: NEG
86388: PUSH
86389: EMPTY
86390: LIST
86391: LIST
86392: PUSH
86393: LD_INT 2
86395: NEG
86396: PUSH
86397: LD_INT 2
86399: NEG
86400: PUSH
86401: EMPTY
86402: LIST
86403: LIST
86404: PUSH
86405: EMPTY
86406: LIST
86407: LIST
86408: LIST
86409: LIST
86410: LIST
86411: LIST
86412: LIST
86413: LIST
86414: LIST
86415: LIST
86416: LIST
86417: LIST
86418: LIST
86419: LIST
86420: LIST
86421: LIST
86422: LIST
86423: LIST
86424: LIST
86425: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86426: LD_ADDR_VAR 0 18
86430: PUSH
86431: LD_INT 0
86433: PUSH
86434: LD_INT 0
86436: PUSH
86437: EMPTY
86438: LIST
86439: LIST
86440: PUSH
86441: LD_INT 0
86443: PUSH
86444: LD_INT 1
86446: NEG
86447: PUSH
86448: EMPTY
86449: LIST
86450: LIST
86451: PUSH
86452: LD_INT 1
86454: PUSH
86455: LD_INT 0
86457: PUSH
86458: EMPTY
86459: LIST
86460: LIST
86461: PUSH
86462: LD_INT 1
86464: PUSH
86465: LD_INT 1
86467: PUSH
86468: EMPTY
86469: LIST
86470: LIST
86471: PUSH
86472: LD_INT 0
86474: PUSH
86475: LD_INT 1
86477: PUSH
86478: EMPTY
86479: LIST
86480: LIST
86481: PUSH
86482: LD_INT 1
86484: NEG
86485: PUSH
86486: LD_INT 0
86488: PUSH
86489: EMPTY
86490: LIST
86491: LIST
86492: PUSH
86493: LD_INT 1
86495: NEG
86496: PUSH
86497: LD_INT 1
86499: NEG
86500: PUSH
86501: EMPTY
86502: LIST
86503: LIST
86504: PUSH
86505: LD_INT 1
86507: NEG
86508: PUSH
86509: LD_INT 2
86511: NEG
86512: PUSH
86513: EMPTY
86514: LIST
86515: LIST
86516: PUSH
86517: LD_INT 0
86519: PUSH
86520: LD_INT 2
86522: NEG
86523: PUSH
86524: EMPTY
86525: LIST
86526: LIST
86527: PUSH
86528: LD_INT 1
86530: PUSH
86531: LD_INT 1
86533: NEG
86534: PUSH
86535: EMPTY
86536: LIST
86537: LIST
86538: PUSH
86539: LD_INT 2
86541: PUSH
86542: LD_INT 0
86544: PUSH
86545: EMPTY
86546: LIST
86547: LIST
86548: PUSH
86549: LD_INT 2
86551: PUSH
86552: LD_INT 1
86554: PUSH
86555: EMPTY
86556: LIST
86557: LIST
86558: PUSH
86559: LD_INT 2
86561: PUSH
86562: LD_INT 2
86564: PUSH
86565: EMPTY
86566: LIST
86567: LIST
86568: PUSH
86569: LD_INT 1
86571: PUSH
86572: LD_INT 2
86574: PUSH
86575: EMPTY
86576: LIST
86577: LIST
86578: PUSH
86579: LD_INT 0
86581: PUSH
86582: LD_INT 2
86584: PUSH
86585: EMPTY
86586: LIST
86587: LIST
86588: PUSH
86589: LD_INT 1
86591: NEG
86592: PUSH
86593: LD_INT 1
86595: PUSH
86596: EMPTY
86597: LIST
86598: LIST
86599: PUSH
86600: LD_INT 2
86602: NEG
86603: PUSH
86604: LD_INT 0
86606: PUSH
86607: EMPTY
86608: LIST
86609: LIST
86610: PUSH
86611: LD_INT 2
86613: NEG
86614: PUSH
86615: LD_INT 1
86617: NEG
86618: PUSH
86619: EMPTY
86620: LIST
86621: LIST
86622: PUSH
86623: LD_INT 2
86625: NEG
86626: PUSH
86627: LD_INT 2
86629: NEG
86630: PUSH
86631: EMPTY
86632: LIST
86633: LIST
86634: PUSH
86635: EMPTY
86636: LIST
86637: LIST
86638: LIST
86639: LIST
86640: LIST
86641: LIST
86642: LIST
86643: LIST
86644: LIST
86645: LIST
86646: LIST
86647: LIST
86648: LIST
86649: LIST
86650: LIST
86651: LIST
86652: LIST
86653: LIST
86654: LIST
86655: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86656: LD_ADDR_VAR 0 19
86660: PUSH
86661: LD_INT 0
86663: PUSH
86664: LD_INT 0
86666: PUSH
86667: EMPTY
86668: LIST
86669: LIST
86670: PUSH
86671: LD_INT 0
86673: PUSH
86674: LD_INT 1
86676: NEG
86677: PUSH
86678: EMPTY
86679: LIST
86680: LIST
86681: PUSH
86682: LD_INT 1
86684: PUSH
86685: LD_INT 0
86687: PUSH
86688: EMPTY
86689: LIST
86690: LIST
86691: PUSH
86692: LD_INT 1
86694: PUSH
86695: LD_INT 1
86697: PUSH
86698: EMPTY
86699: LIST
86700: LIST
86701: PUSH
86702: LD_INT 0
86704: PUSH
86705: LD_INT 1
86707: PUSH
86708: EMPTY
86709: LIST
86710: LIST
86711: PUSH
86712: LD_INT 1
86714: NEG
86715: PUSH
86716: LD_INT 0
86718: PUSH
86719: EMPTY
86720: LIST
86721: LIST
86722: PUSH
86723: LD_INT 1
86725: NEG
86726: PUSH
86727: LD_INT 1
86729: NEG
86730: PUSH
86731: EMPTY
86732: LIST
86733: LIST
86734: PUSH
86735: LD_INT 1
86737: NEG
86738: PUSH
86739: LD_INT 2
86741: NEG
86742: PUSH
86743: EMPTY
86744: LIST
86745: LIST
86746: PUSH
86747: LD_INT 0
86749: PUSH
86750: LD_INT 2
86752: NEG
86753: PUSH
86754: EMPTY
86755: LIST
86756: LIST
86757: PUSH
86758: LD_INT 1
86760: PUSH
86761: LD_INT 1
86763: NEG
86764: PUSH
86765: EMPTY
86766: LIST
86767: LIST
86768: PUSH
86769: LD_INT 2
86771: PUSH
86772: LD_INT 0
86774: PUSH
86775: EMPTY
86776: LIST
86777: LIST
86778: PUSH
86779: LD_INT 2
86781: PUSH
86782: LD_INT 1
86784: PUSH
86785: EMPTY
86786: LIST
86787: LIST
86788: PUSH
86789: LD_INT 2
86791: PUSH
86792: LD_INT 2
86794: PUSH
86795: EMPTY
86796: LIST
86797: LIST
86798: PUSH
86799: LD_INT 1
86801: PUSH
86802: LD_INT 2
86804: PUSH
86805: EMPTY
86806: LIST
86807: LIST
86808: PUSH
86809: LD_INT 0
86811: PUSH
86812: LD_INT 2
86814: PUSH
86815: EMPTY
86816: LIST
86817: LIST
86818: PUSH
86819: LD_INT 1
86821: NEG
86822: PUSH
86823: LD_INT 1
86825: PUSH
86826: EMPTY
86827: LIST
86828: LIST
86829: PUSH
86830: LD_INT 2
86832: NEG
86833: PUSH
86834: LD_INT 0
86836: PUSH
86837: EMPTY
86838: LIST
86839: LIST
86840: PUSH
86841: LD_INT 2
86843: NEG
86844: PUSH
86845: LD_INT 1
86847: NEG
86848: PUSH
86849: EMPTY
86850: LIST
86851: LIST
86852: PUSH
86853: LD_INT 2
86855: NEG
86856: PUSH
86857: LD_INT 2
86859: NEG
86860: PUSH
86861: EMPTY
86862: LIST
86863: LIST
86864: PUSH
86865: EMPTY
86866: LIST
86867: LIST
86868: LIST
86869: LIST
86870: LIST
86871: LIST
86872: LIST
86873: LIST
86874: LIST
86875: LIST
86876: LIST
86877: LIST
86878: LIST
86879: LIST
86880: LIST
86881: LIST
86882: LIST
86883: LIST
86884: LIST
86885: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86886: LD_ADDR_VAR 0 20
86890: PUSH
86891: LD_INT 0
86893: PUSH
86894: LD_INT 0
86896: PUSH
86897: EMPTY
86898: LIST
86899: LIST
86900: PUSH
86901: LD_INT 0
86903: PUSH
86904: LD_INT 1
86906: NEG
86907: PUSH
86908: EMPTY
86909: LIST
86910: LIST
86911: PUSH
86912: LD_INT 1
86914: PUSH
86915: LD_INT 0
86917: PUSH
86918: EMPTY
86919: LIST
86920: LIST
86921: PUSH
86922: LD_INT 1
86924: PUSH
86925: LD_INT 1
86927: PUSH
86928: EMPTY
86929: LIST
86930: LIST
86931: PUSH
86932: LD_INT 0
86934: PUSH
86935: LD_INT 1
86937: PUSH
86938: EMPTY
86939: LIST
86940: LIST
86941: PUSH
86942: LD_INT 1
86944: NEG
86945: PUSH
86946: LD_INT 0
86948: PUSH
86949: EMPTY
86950: LIST
86951: LIST
86952: PUSH
86953: LD_INT 1
86955: NEG
86956: PUSH
86957: LD_INT 1
86959: NEG
86960: PUSH
86961: EMPTY
86962: LIST
86963: LIST
86964: PUSH
86965: LD_INT 1
86967: NEG
86968: PUSH
86969: LD_INT 2
86971: NEG
86972: PUSH
86973: EMPTY
86974: LIST
86975: LIST
86976: PUSH
86977: LD_INT 0
86979: PUSH
86980: LD_INT 2
86982: NEG
86983: PUSH
86984: EMPTY
86985: LIST
86986: LIST
86987: PUSH
86988: LD_INT 1
86990: PUSH
86991: LD_INT 1
86993: NEG
86994: PUSH
86995: EMPTY
86996: LIST
86997: LIST
86998: PUSH
86999: LD_INT 2
87001: PUSH
87002: LD_INT 0
87004: PUSH
87005: EMPTY
87006: LIST
87007: LIST
87008: PUSH
87009: LD_INT 2
87011: PUSH
87012: LD_INT 1
87014: PUSH
87015: EMPTY
87016: LIST
87017: LIST
87018: PUSH
87019: LD_INT 2
87021: PUSH
87022: LD_INT 2
87024: PUSH
87025: EMPTY
87026: LIST
87027: LIST
87028: PUSH
87029: LD_INT 1
87031: PUSH
87032: LD_INT 2
87034: PUSH
87035: EMPTY
87036: LIST
87037: LIST
87038: PUSH
87039: LD_INT 0
87041: PUSH
87042: LD_INT 2
87044: PUSH
87045: EMPTY
87046: LIST
87047: LIST
87048: PUSH
87049: LD_INT 1
87051: NEG
87052: PUSH
87053: LD_INT 1
87055: PUSH
87056: EMPTY
87057: LIST
87058: LIST
87059: PUSH
87060: LD_INT 2
87062: NEG
87063: PUSH
87064: LD_INT 0
87066: PUSH
87067: EMPTY
87068: LIST
87069: LIST
87070: PUSH
87071: LD_INT 2
87073: NEG
87074: PUSH
87075: LD_INT 1
87077: NEG
87078: PUSH
87079: EMPTY
87080: LIST
87081: LIST
87082: PUSH
87083: LD_INT 2
87085: NEG
87086: PUSH
87087: LD_INT 2
87089: NEG
87090: PUSH
87091: EMPTY
87092: LIST
87093: LIST
87094: PUSH
87095: EMPTY
87096: LIST
87097: LIST
87098: LIST
87099: LIST
87100: LIST
87101: LIST
87102: LIST
87103: LIST
87104: LIST
87105: LIST
87106: LIST
87107: LIST
87108: LIST
87109: LIST
87110: LIST
87111: LIST
87112: LIST
87113: LIST
87114: LIST
87115: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87116: LD_ADDR_VAR 0 21
87120: PUSH
87121: LD_INT 0
87123: PUSH
87124: LD_INT 0
87126: PUSH
87127: EMPTY
87128: LIST
87129: LIST
87130: PUSH
87131: LD_INT 0
87133: PUSH
87134: LD_INT 1
87136: NEG
87137: PUSH
87138: EMPTY
87139: LIST
87140: LIST
87141: PUSH
87142: LD_INT 1
87144: PUSH
87145: LD_INT 0
87147: PUSH
87148: EMPTY
87149: LIST
87150: LIST
87151: PUSH
87152: LD_INT 1
87154: PUSH
87155: LD_INT 1
87157: PUSH
87158: EMPTY
87159: LIST
87160: LIST
87161: PUSH
87162: LD_INT 0
87164: PUSH
87165: LD_INT 1
87167: PUSH
87168: EMPTY
87169: LIST
87170: LIST
87171: PUSH
87172: LD_INT 1
87174: NEG
87175: PUSH
87176: LD_INT 0
87178: PUSH
87179: EMPTY
87180: LIST
87181: LIST
87182: PUSH
87183: LD_INT 1
87185: NEG
87186: PUSH
87187: LD_INT 1
87189: NEG
87190: PUSH
87191: EMPTY
87192: LIST
87193: LIST
87194: PUSH
87195: LD_INT 1
87197: NEG
87198: PUSH
87199: LD_INT 2
87201: NEG
87202: PUSH
87203: EMPTY
87204: LIST
87205: LIST
87206: PUSH
87207: LD_INT 0
87209: PUSH
87210: LD_INT 2
87212: NEG
87213: PUSH
87214: EMPTY
87215: LIST
87216: LIST
87217: PUSH
87218: LD_INT 1
87220: PUSH
87221: LD_INT 1
87223: NEG
87224: PUSH
87225: EMPTY
87226: LIST
87227: LIST
87228: PUSH
87229: LD_INT 2
87231: PUSH
87232: LD_INT 0
87234: PUSH
87235: EMPTY
87236: LIST
87237: LIST
87238: PUSH
87239: LD_INT 2
87241: PUSH
87242: LD_INT 1
87244: PUSH
87245: EMPTY
87246: LIST
87247: LIST
87248: PUSH
87249: LD_INT 2
87251: PUSH
87252: LD_INT 2
87254: PUSH
87255: EMPTY
87256: LIST
87257: LIST
87258: PUSH
87259: LD_INT 1
87261: PUSH
87262: LD_INT 2
87264: PUSH
87265: EMPTY
87266: LIST
87267: LIST
87268: PUSH
87269: LD_INT 0
87271: PUSH
87272: LD_INT 2
87274: PUSH
87275: EMPTY
87276: LIST
87277: LIST
87278: PUSH
87279: LD_INT 1
87281: NEG
87282: PUSH
87283: LD_INT 1
87285: PUSH
87286: EMPTY
87287: LIST
87288: LIST
87289: PUSH
87290: LD_INT 2
87292: NEG
87293: PUSH
87294: LD_INT 0
87296: PUSH
87297: EMPTY
87298: LIST
87299: LIST
87300: PUSH
87301: LD_INT 2
87303: NEG
87304: PUSH
87305: LD_INT 1
87307: NEG
87308: PUSH
87309: EMPTY
87310: LIST
87311: LIST
87312: PUSH
87313: LD_INT 2
87315: NEG
87316: PUSH
87317: LD_INT 2
87319: NEG
87320: PUSH
87321: EMPTY
87322: LIST
87323: LIST
87324: PUSH
87325: EMPTY
87326: LIST
87327: LIST
87328: LIST
87329: LIST
87330: LIST
87331: LIST
87332: LIST
87333: LIST
87334: LIST
87335: LIST
87336: LIST
87337: LIST
87338: LIST
87339: LIST
87340: LIST
87341: LIST
87342: LIST
87343: LIST
87344: LIST
87345: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87346: LD_ADDR_VAR 0 22
87350: PUSH
87351: LD_INT 0
87353: PUSH
87354: LD_INT 0
87356: PUSH
87357: EMPTY
87358: LIST
87359: LIST
87360: PUSH
87361: LD_INT 0
87363: PUSH
87364: LD_INT 1
87366: NEG
87367: PUSH
87368: EMPTY
87369: LIST
87370: LIST
87371: PUSH
87372: LD_INT 1
87374: PUSH
87375: LD_INT 0
87377: PUSH
87378: EMPTY
87379: LIST
87380: LIST
87381: PUSH
87382: LD_INT 1
87384: PUSH
87385: LD_INT 1
87387: PUSH
87388: EMPTY
87389: LIST
87390: LIST
87391: PUSH
87392: LD_INT 0
87394: PUSH
87395: LD_INT 1
87397: PUSH
87398: EMPTY
87399: LIST
87400: LIST
87401: PUSH
87402: LD_INT 1
87404: NEG
87405: PUSH
87406: LD_INT 0
87408: PUSH
87409: EMPTY
87410: LIST
87411: LIST
87412: PUSH
87413: LD_INT 1
87415: NEG
87416: PUSH
87417: LD_INT 1
87419: NEG
87420: PUSH
87421: EMPTY
87422: LIST
87423: LIST
87424: PUSH
87425: LD_INT 1
87427: NEG
87428: PUSH
87429: LD_INT 2
87431: NEG
87432: PUSH
87433: EMPTY
87434: LIST
87435: LIST
87436: PUSH
87437: LD_INT 0
87439: PUSH
87440: LD_INT 2
87442: NEG
87443: PUSH
87444: EMPTY
87445: LIST
87446: LIST
87447: PUSH
87448: LD_INT 1
87450: PUSH
87451: LD_INT 1
87453: NEG
87454: PUSH
87455: EMPTY
87456: LIST
87457: LIST
87458: PUSH
87459: LD_INT 2
87461: PUSH
87462: LD_INT 0
87464: PUSH
87465: EMPTY
87466: LIST
87467: LIST
87468: PUSH
87469: LD_INT 2
87471: PUSH
87472: LD_INT 1
87474: PUSH
87475: EMPTY
87476: LIST
87477: LIST
87478: PUSH
87479: LD_INT 2
87481: PUSH
87482: LD_INT 2
87484: PUSH
87485: EMPTY
87486: LIST
87487: LIST
87488: PUSH
87489: LD_INT 1
87491: PUSH
87492: LD_INT 2
87494: PUSH
87495: EMPTY
87496: LIST
87497: LIST
87498: PUSH
87499: LD_INT 0
87501: PUSH
87502: LD_INT 2
87504: PUSH
87505: EMPTY
87506: LIST
87507: LIST
87508: PUSH
87509: LD_INT 1
87511: NEG
87512: PUSH
87513: LD_INT 1
87515: PUSH
87516: EMPTY
87517: LIST
87518: LIST
87519: PUSH
87520: LD_INT 2
87522: NEG
87523: PUSH
87524: LD_INT 0
87526: PUSH
87527: EMPTY
87528: LIST
87529: LIST
87530: PUSH
87531: LD_INT 2
87533: NEG
87534: PUSH
87535: LD_INT 1
87537: NEG
87538: PUSH
87539: EMPTY
87540: LIST
87541: LIST
87542: PUSH
87543: LD_INT 2
87545: NEG
87546: PUSH
87547: LD_INT 2
87549: NEG
87550: PUSH
87551: EMPTY
87552: LIST
87553: LIST
87554: PUSH
87555: EMPTY
87556: LIST
87557: LIST
87558: LIST
87559: LIST
87560: LIST
87561: LIST
87562: LIST
87563: LIST
87564: LIST
87565: LIST
87566: LIST
87567: LIST
87568: LIST
87569: LIST
87570: LIST
87571: LIST
87572: LIST
87573: LIST
87574: LIST
87575: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
87576: LD_ADDR_VAR 0 23
87580: PUSH
87581: LD_INT 0
87583: PUSH
87584: LD_INT 0
87586: PUSH
87587: EMPTY
87588: LIST
87589: LIST
87590: PUSH
87591: LD_INT 0
87593: PUSH
87594: LD_INT 1
87596: NEG
87597: PUSH
87598: EMPTY
87599: LIST
87600: LIST
87601: PUSH
87602: LD_INT 1
87604: PUSH
87605: LD_INT 0
87607: PUSH
87608: EMPTY
87609: LIST
87610: LIST
87611: PUSH
87612: LD_INT 1
87614: PUSH
87615: LD_INT 1
87617: PUSH
87618: EMPTY
87619: LIST
87620: LIST
87621: PUSH
87622: LD_INT 0
87624: PUSH
87625: LD_INT 1
87627: PUSH
87628: EMPTY
87629: LIST
87630: LIST
87631: PUSH
87632: LD_INT 1
87634: NEG
87635: PUSH
87636: LD_INT 0
87638: PUSH
87639: EMPTY
87640: LIST
87641: LIST
87642: PUSH
87643: LD_INT 1
87645: NEG
87646: PUSH
87647: LD_INT 1
87649: NEG
87650: PUSH
87651: EMPTY
87652: LIST
87653: LIST
87654: PUSH
87655: LD_INT 1
87657: NEG
87658: PUSH
87659: LD_INT 2
87661: NEG
87662: PUSH
87663: EMPTY
87664: LIST
87665: LIST
87666: PUSH
87667: LD_INT 0
87669: PUSH
87670: LD_INT 2
87672: NEG
87673: PUSH
87674: EMPTY
87675: LIST
87676: LIST
87677: PUSH
87678: LD_INT 1
87680: PUSH
87681: LD_INT 1
87683: NEG
87684: PUSH
87685: EMPTY
87686: LIST
87687: LIST
87688: PUSH
87689: LD_INT 2
87691: PUSH
87692: LD_INT 0
87694: PUSH
87695: EMPTY
87696: LIST
87697: LIST
87698: PUSH
87699: LD_INT 2
87701: PUSH
87702: LD_INT 1
87704: PUSH
87705: EMPTY
87706: LIST
87707: LIST
87708: PUSH
87709: LD_INT 2
87711: PUSH
87712: LD_INT 2
87714: PUSH
87715: EMPTY
87716: LIST
87717: LIST
87718: PUSH
87719: LD_INT 1
87721: PUSH
87722: LD_INT 2
87724: PUSH
87725: EMPTY
87726: LIST
87727: LIST
87728: PUSH
87729: LD_INT 0
87731: PUSH
87732: LD_INT 2
87734: PUSH
87735: EMPTY
87736: LIST
87737: LIST
87738: PUSH
87739: LD_INT 1
87741: NEG
87742: PUSH
87743: LD_INT 1
87745: PUSH
87746: EMPTY
87747: LIST
87748: LIST
87749: PUSH
87750: LD_INT 2
87752: NEG
87753: PUSH
87754: LD_INT 0
87756: PUSH
87757: EMPTY
87758: LIST
87759: LIST
87760: PUSH
87761: LD_INT 2
87763: NEG
87764: PUSH
87765: LD_INT 1
87767: NEG
87768: PUSH
87769: EMPTY
87770: LIST
87771: LIST
87772: PUSH
87773: LD_INT 2
87775: NEG
87776: PUSH
87777: LD_INT 2
87779: NEG
87780: PUSH
87781: EMPTY
87782: LIST
87783: LIST
87784: PUSH
87785: LD_INT 2
87787: NEG
87788: PUSH
87789: LD_INT 3
87791: NEG
87792: PUSH
87793: EMPTY
87794: LIST
87795: LIST
87796: PUSH
87797: LD_INT 1
87799: NEG
87800: PUSH
87801: LD_INT 3
87803: NEG
87804: PUSH
87805: EMPTY
87806: LIST
87807: LIST
87808: PUSH
87809: LD_INT 1
87811: PUSH
87812: LD_INT 2
87814: NEG
87815: PUSH
87816: EMPTY
87817: LIST
87818: LIST
87819: PUSH
87820: LD_INT 2
87822: PUSH
87823: LD_INT 1
87825: NEG
87826: PUSH
87827: EMPTY
87828: LIST
87829: LIST
87830: PUSH
87831: EMPTY
87832: LIST
87833: LIST
87834: LIST
87835: LIST
87836: LIST
87837: LIST
87838: LIST
87839: LIST
87840: LIST
87841: LIST
87842: LIST
87843: LIST
87844: LIST
87845: LIST
87846: LIST
87847: LIST
87848: LIST
87849: LIST
87850: LIST
87851: LIST
87852: LIST
87853: LIST
87854: LIST
87855: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
87856: LD_ADDR_VAR 0 24
87860: PUSH
87861: LD_INT 0
87863: PUSH
87864: LD_INT 0
87866: PUSH
87867: EMPTY
87868: LIST
87869: LIST
87870: PUSH
87871: LD_INT 0
87873: PUSH
87874: LD_INT 1
87876: NEG
87877: PUSH
87878: EMPTY
87879: LIST
87880: LIST
87881: PUSH
87882: LD_INT 1
87884: PUSH
87885: LD_INT 0
87887: PUSH
87888: EMPTY
87889: LIST
87890: LIST
87891: PUSH
87892: LD_INT 1
87894: PUSH
87895: LD_INT 1
87897: PUSH
87898: EMPTY
87899: LIST
87900: LIST
87901: PUSH
87902: LD_INT 0
87904: PUSH
87905: LD_INT 1
87907: PUSH
87908: EMPTY
87909: LIST
87910: LIST
87911: PUSH
87912: LD_INT 1
87914: NEG
87915: PUSH
87916: LD_INT 0
87918: PUSH
87919: EMPTY
87920: LIST
87921: LIST
87922: PUSH
87923: LD_INT 1
87925: NEG
87926: PUSH
87927: LD_INT 1
87929: NEG
87930: PUSH
87931: EMPTY
87932: LIST
87933: LIST
87934: PUSH
87935: LD_INT 1
87937: NEG
87938: PUSH
87939: LD_INT 2
87941: NEG
87942: PUSH
87943: EMPTY
87944: LIST
87945: LIST
87946: PUSH
87947: LD_INT 0
87949: PUSH
87950: LD_INT 2
87952: NEG
87953: PUSH
87954: EMPTY
87955: LIST
87956: LIST
87957: PUSH
87958: LD_INT 1
87960: PUSH
87961: LD_INT 1
87963: NEG
87964: PUSH
87965: EMPTY
87966: LIST
87967: LIST
87968: PUSH
87969: LD_INT 2
87971: PUSH
87972: LD_INT 0
87974: PUSH
87975: EMPTY
87976: LIST
87977: LIST
87978: PUSH
87979: LD_INT 2
87981: PUSH
87982: LD_INT 1
87984: PUSH
87985: EMPTY
87986: LIST
87987: LIST
87988: PUSH
87989: LD_INT 2
87991: PUSH
87992: LD_INT 2
87994: PUSH
87995: EMPTY
87996: LIST
87997: LIST
87998: PUSH
87999: LD_INT 1
88001: PUSH
88002: LD_INT 2
88004: PUSH
88005: EMPTY
88006: LIST
88007: LIST
88008: PUSH
88009: LD_INT 0
88011: PUSH
88012: LD_INT 2
88014: PUSH
88015: EMPTY
88016: LIST
88017: LIST
88018: PUSH
88019: LD_INT 1
88021: NEG
88022: PUSH
88023: LD_INT 1
88025: PUSH
88026: EMPTY
88027: LIST
88028: LIST
88029: PUSH
88030: LD_INT 2
88032: NEG
88033: PUSH
88034: LD_INT 0
88036: PUSH
88037: EMPTY
88038: LIST
88039: LIST
88040: PUSH
88041: LD_INT 2
88043: NEG
88044: PUSH
88045: LD_INT 1
88047: NEG
88048: PUSH
88049: EMPTY
88050: LIST
88051: LIST
88052: PUSH
88053: LD_INT 2
88055: NEG
88056: PUSH
88057: LD_INT 2
88059: NEG
88060: PUSH
88061: EMPTY
88062: LIST
88063: LIST
88064: PUSH
88065: LD_INT 1
88067: PUSH
88068: LD_INT 2
88070: NEG
88071: PUSH
88072: EMPTY
88073: LIST
88074: LIST
88075: PUSH
88076: LD_INT 2
88078: PUSH
88079: LD_INT 1
88081: NEG
88082: PUSH
88083: EMPTY
88084: LIST
88085: LIST
88086: PUSH
88087: LD_INT 3
88089: PUSH
88090: LD_INT 1
88092: PUSH
88093: EMPTY
88094: LIST
88095: LIST
88096: PUSH
88097: LD_INT 3
88099: PUSH
88100: LD_INT 2
88102: PUSH
88103: EMPTY
88104: LIST
88105: LIST
88106: PUSH
88107: EMPTY
88108: LIST
88109: LIST
88110: LIST
88111: LIST
88112: LIST
88113: LIST
88114: LIST
88115: LIST
88116: LIST
88117: LIST
88118: LIST
88119: LIST
88120: LIST
88121: LIST
88122: LIST
88123: LIST
88124: LIST
88125: LIST
88126: LIST
88127: LIST
88128: LIST
88129: LIST
88130: LIST
88131: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
88132: LD_ADDR_VAR 0 25
88136: PUSH
88137: LD_INT 0
88139: PUSH
88140: LD_INT 0
88142: PUSH
88143: EMPTY
88144: LIST
88145: LIST
88146: PUSH
88147: LD_INT 0
88149: PUSH
88150: LD_INT 1
88152: NEG
88153: PUSH
88154: EMPTY
88155: LIST
88156: LIST
88157: PUSH
88158: LD_INT 1
88160: PUSH
88161: LD_INT 0
88163: PUSH
88164: EMPTY
88165: LIST
88166: LIST
88167: PUSH
88168: LD_INT 1
88170: PUSH
88171: LD_INT 1
88173: PUSH
88174: EMPTY
88175: LIST
88176: LIST
88177: PUSH
88178: LD_INT 0
88180: PUSH
88181: LD_INT 1
88183: PUSH
88184: EMPTY
88185: LIST
88186: LIST
88187: PUSH
88188: LD_INT 1
88190: NEG
88191: PUSH
88192: LD_INT 0
88194: PUSH
88195: EMPTY
88196: LIST
88197: LIST
88198: PUSH
88199: LD_INT 1
88201: NEG
88202: PUSH
88203: LD_INT 1
88205: NEG
88206: PUSH
88207: EMPTY
88208: LIST
88209: LIST
88210: PUSH
88211: LD_INT 1
88213: NEG
88214: PUSH
88215: LD_INT 2
88217: NEG
88218: PUSH
88219: EMPTY
88220: LIST
88221: LIST
88222: PUSH
88223: LD_INT 0
88225: PUSH
88226: LD_INT 2
88228: NEG
88229: PUSH
88230: EMPTY
88231: LIST
88232: LIST
88233: PUSH
88234: LD_INT 1
88236: PUSH
88237: LD_INT 1
88239: NEG
88240: PUSH
88241: EMPTY
88242: LIST
88243: LIST
88244: PUSH
88245: LD_INT 2
88247: PUSH
88248: LD_INT 0
88250: PUSH
88251: EMPTY
88252: LIST
88253: LIST
88254: PUSH
88255: LD_INT 2
88257: PUSH
88258: LD_INT 1
88260: PUSH
88261: EMPTY
88262: LIST
88263: LIST
88264: PUSH
88265: LD_INT 2
88267: PUSH
88268: LD_INT 2
88270: PUSH
88271: EMPTY
88272: LIST
88273: LIST
88274: PUSH
88275: LD_INT 1
88277: PUSH
88278: LD_INT 2
88280: PUSH
88281: EMPTY
88282: LIST
88283: LIST
88284: PUSH
88285: LD_INT 0
88287: PUSH
88288: LD_INT 2
88290: PUSH
88291: EMPTY
88292: LIST
88293: LIST
88294: PUSH
88295: LD_INT 1
88297: NEG
88298: PUSH
88299: LD_INT 1
88301: PUSH
88302: EMPTY
88303: LIST
88304: LIST
88305: PUSH
88306: LD_INT 2
88308: NEG
88309: PUSH
88310: LD_INT 0
88312: PUSH
88313: EMPTY
88314: LIST
88315: LIST
88316: PUSH
88317: LD_INT 2
88319: NEG
88320: PUSH
88321: LD_INT 1
88323: NEG
88324: PUSH
88325: EMPTY
88326: LIST
88327: LIST
88328: PUSH
88329: LD_INT 2
88331: NEG
88332: PUSH
88333: LD_INT 2
88335: NEG
88336: PUSH
88337: EMPTY
88338: LIST
88339: LIST
88340: PUSH
88341: LD_INT 3
88343: PUSH
88344: LD_INT 1
88346: PUSH
88347: EMPTY
88348: LIST
88349: LIST
88350: PUSH
88351: LD_INT 3
88353: PUSH
88354: LD_INT 2
88356: PUSH
88357: EMPTY
88358: LIST
88359: LIST
88360: PUSH
88361: LD_INT 2
88363: PUSH
88364: LD_INT 3
88366: PUSH
88367: EMPTY
88368: LIST
88369: LIST
88370: PUSH
88371: LD_INT 1
88373: PUSH
88374: LD_INT 3
88376: PUSH
88377: EMPTY
88378: LIST
88379: LIST
88380: PUSH
88381: EMPTY
88382: LIST
88383: LIST
88384: LIST
88385: LIST
88386: LIST
88387: LIST
88388: LIST
88389: LIST
88390: LIST
88391: LIST
88392: LIST
88393: LIST
88394: LIST
88395: LIST
88396: LIST
88397: LIST
88398: LIST
88399: LIST
88400: LIST
88401: LIST
88402: LIST
88403: LIST
88404: LIST
88405: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
88406: LD_ADDR_VAR 0 26
88410: PUSH
88411: LD_INT 0
88413: PUSH
88414: LD_INT 0
88416: PUSH
88417: EMPTY
88418: LIST
88419: LIST
88420: PUSH
88421: LD_INT 0
88423: PUSH
88424: LD_INT 1
88426: NEG
88427: PUSH
88428: EMPTY
88429: LIST
88430: LIST
88431: PUSH
88432: LD_INT 1
88434: PUSH
88435: LD_INT 0
88437: PUSH
88438: EMPTY
88439: LIST
88440: LIST
88441: PUSH
88442: LD_INT 1
88444: PUSH
88445: LD_INT 1
88447: PUSH
88448: EMPTY
88449: LIST
88450: LIST
88451: PUSH
88452: LD_INT 0
88454: PUSH
88455: LD_INT 1
88457: PUSH
88458: EMPTY
88459: LIST
88460: LIST
88461: PUSH
88462: LD_INT 1
88464: NEG
88465: PUSH
88466: LD_INT 0
88468: PUSH
88469: EMPTY
88470: LIST
88471: LIST
88472: PUSH
88473: LD_INT 1
88475: NEG
88476: PUSH
88477: LD_INT 1
88479: NEG
88480: PUSH
88481: EMPTY
88482: LIST
88483: LIST
88484: PUSH
88485: LD_INT 1
88487: NEG
88488: PUSH
88489: LD_INT 2
88491: NEG
88492: PUSH
88493: EMPTY
88494: LIST
88495: LIST
88496: PUSH
88497: LD_INT 0
88499: PUSH
88500: LD_INT 2
88502: NEG
88503: PUSH
88504: EMPTY
88505: LIST
88506: LIST
88507: PUSH
88508: LD_INT 1
88510: PUSH
88511: LD_INT 1
88513: NEG
88514: PUSH
88515: EMPTY
88516: LIST
88517: LIST
88518: PUSH
88519: LD_INT 2
88521: PUSH
88522: LD_INT 0
88524: PUSH
88525: EMPTY
88526: LIST
88527: LIST
88528: PUSH
88529: LD_INT 2
88531: PUSH
88532: LD_INT 1
88534: PUSH
88535: EMPTY
88536: LIST
88537: LIST
88538: PUSH
88539: LD_INT 2
88541: PUSH
88542: LD_INT 2
88544: PUSH
88545: EMPTY
88546: LIST
88547: LIST
88548: PUSH
88549: LD_INT 1
88551: PUSH
88552: LD_INT 2
88554: PUSH
88555: EMPTY
88556: LIST
88557: LIST
88558: PUSH
88559: LD_INT 0
88561: PUSH
88562: LD_INT 2
88564: PUSH
88565: EMPTY
88566: LIST
88567: LIST
88568: PUSH
88569: LD_INT 1
88571: NEG
88572: PUSH
88573: LD_INT 1
88575: PUSH
88576: EMPTY
88577: LIST
88578: LIST
88579: PUSH
88580: LD_INT 2
88582: NEG
88583: PUSH
88584: LD_INT 0
88586: PUSH
88587: EMPTY
88588: LIST
88589: LIST
88590: PUSH
88591: LD_INT 2
88593: NEG
88594: PUSH
88595: LD_INT 1
88597: NEG
88598: PUSH
88599: EMPTY
88600: LIST
88601: LIST
88602: PUSH
88603: LD_INT 2
88605: NEG
88606: PUSH
88607: LD_INT 2
88609: NEG
88610: PUSH
88611: EMPTY
88612: LIST
88613: LIST
88614: PUSH
88615: LD_INT 2
88617: PUSH
88618: LD_INT 3
88620: PUSH
88621: EMPTY
88622: LIST
88623: LIST
88624: PUSH
88625: LD_INT 1
88627: PUSH
88628: LD_INT 3
88630: PUSH
88631: EMPTY
88632: LIST
88633: LIST
88634: PUSH
88635: LD_INT 1
88637: NEG
88638: PUSH
88639: LD_INT 2
88641: PUSH
88642: EMPTY
88643: LIST
88644: LIST
88645: PUSH
88646: LD_INT 2
88648: NEG
88649: PUSH
88650: LD_INT 1
88652: PUSH
88653: EMPTY
88654: LIST
88655: LIST
88656: PUSH
88657: EMPTY
88658: LIST
88659: LIST
88660: LIST
88661: LIST
88662: LIST
88663: LIST
88664: LIST
88665: LIST
88666: LIST
88667: LIST
88668: LIST
88669: LIST
88670: LIST
88671: LIST
88672: LIST
88673: LIST
88674: LIST
88675: LIST
88676: LIST
88677: LIST
88678: LIST
88679: LIST
88680: LIST
88681: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
88682: LD_ADDR_VAR 0 27
88686: PUSH
88687: LD_INT 0
88689: PUSH
88690: LD_INT 0
88692: PUSH
88693: EMPTY
88694: LIST
88695: LIST
88696: PUSH
88697: LD_INT 0
88699: PUSH
88700: LD_INT 1
88702: NEG
88703: PUSH
88704: EMPTY
88705: LIST
88706: LIST
88707: PUSH
88708: LD_INT 1
88710: PUSH
88711: LD_INT 0
88713: PUSH
88714: EMPTY
88715: LIST
88716: LIST
88717: PUSH
88718: LD_INT 1
88720: PUSH
88721: LD_INT 1
88723: PUSH
88724: EMPTY
88725: LIST
88726: LIST
88727: PUSH
88728: LD_INT 0
88730: PUSH
88731: LD_INT 1
88733: PUSH
88734: EMPTY
88735: LIST
88736: LIST
88737: PUSH
88738: LD_INT 1
88740: NEG
88741: PUSH
88742: LD_INT 0
88744: PUSH
88745: EMPTY
88746: LIST
88747: LIST
88748: PUSH
88749: LD_INT 1
88751: NEG
88752: PUSH
88753: LD_INT 1
88755: NEG
88756: PUSH
88757: EMPTY
88758: LIST
88759: LIST
88760: PUSH
88761: LD_INT 1
88763: NEG
88764: PUSH
88765: LD_INT 2
88767: NEG
88768: PUSH
88769: EMPTY
88770: LIST
88771: LIST
88772: PUSH
88773: LD_INT 0
88775: PUSH
88776: LD_INT 2
88778: NEG
88779: PUSH
88780: EMPTY
88781: LIST
88782: LIST
88783: PUSH
88784: LD_INT 1
88786: PUSH
88787: LD_INT 1
88789: NEG
88790: PUSH
88791: EMPTY
88792: LIST
88793: LIST
88794: PUSH
88795: LD_INT 2
88797: PUSH
88798: LD_INT 0
88800: PUSH
88801: EMPTY
88802: LIST
88803: LIST
88804: PUSH
88805: LD_INT 2
88807: PUSH
88808: LD_INT 1
88810: PUSH
88811: EMPTY
88812: LIST
88813: LIST
88814: PUSH
88815: LD_INT 2
88817: PUSH
88818: LD_INT 2
88820: PUSH
88821: EMPTY
88822: LIST
88823: LIST
88824: PUSH
88825: LD_INT 1
88827: PUSH
88828: LD_INT 2
88830: PUSH
88831: EMPTY
88832: LIST
88833: LIST
88834: PUSH
88835: LD_INT 0
88837: PUSH
88838: LD_INT 2
88840: PUSH
88841: EMPTY
88842: LIST
88843: LIST
88844: PUSH
88845: LD_INT 1
88847: NEG
88848: PUSH
88849: LD_INT 1
88851: PUSH
88852: EMPTY
88853: LIST
88854: LIST
88855: PUSH
88856: LD_INT 2
88858: NEG
88859: PUSH
88860: LD_INT 0
88862: PUSH
88863: EMPTY
88864: LIST
88865: LIST
88866: PUSH
88867: LD_INT 2
88869: NEG
88870: PUSH
88871: LD_INT 1
88873: NEG
88874: PUSH
88875: EMPTY
88876: LIST
88877: LIST
88878: PUSH
88879: LD_INT 2
88881: NEG
88882: PUSH
88883: LD_INT 2
88885: NEG
88886: PUSH
88887: EMPTY
88888: LIST
88889: LIST
88890: PUSH
88891: LD_INT 1
88893: NEG
88894: PUSH
88895: LD_INT 2
88897: PUSH
88898: EMPTY
88899: LIST
88900: LIST
88901: PUSH
88902: LD_INT 2
88904: NEG
88905: PUSH
88906: LD_INT 1
88908: PUSH
88909: EMPTY
88910: LIST
88911: LIST
88912: PUSH
88913: LD_INT 3
88915: NEG
88916: PUSH
88917: LD_INT 1
88919: NEG
88920: PUSH
88921: EMPTY
88922: LIST
88923: LIST
88924: PUSH
88925: LD_INT 3
88927: NEG
88928: PUSH
88929: LD_INT 2
88931: NEG
88932: PUSH
88933: EMPTY
88934: LIST
88935: LIST
88936: PUSH
88937: EMPTY
88938: LIST
88939: LIST
88940: LIST
88941: LIST
88942: LIST
88943: LIST
88944: LIST
88945: LIST
88946: LIST
88947: LIST
88948: LIST
88949: LIST
88950: LIST
88951: LIST
88952: LIST
88953: LIST
88954: LIST
88955: LIST
88956: LIST
88957: LIST
88958: LIST
88959: LIST
88960: LIST
88961: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
88962: LD_ADDR_VAR 0 28
88966: PUSH
88967: LD_INT 0
88969: PUSH
88970: LD_INT 0
88972: PUSH
88973: EMPTY
88974: LIST
88975: LIST
88976: PUSH
88977: LD_INT 0
88979: PUSH
88980: LD_INT 1
88982: NEG
88983: PUSH
88984: EMPTY
88985: LIST
88986: LIST
88987: PUSH
88988: LD_INT 1
88990: PUSH
88991: LD_INT 0
88993: PUSH
88994: EMPTY
88995: LIST
88996: LIST
88997: PUSH
88998: LD_INT 1
89000: PUSH
89001: LD_INT 1
89003: PUSH
89004: EMPTY
89005: LIST
89006: LIST
89007: PUSH
89008: LD_INT 0
89010: PUSH
89011: LD_INT 1
89013: PUSH
89014: EMPTY
89015: LIST
89016: LIST
89017: PUSH
89018: LD_INT 1
89020: NEG
89021: PUSH
89022: LD_INT 0
89024: PUSH
89025: EMPTY
89026: LIST
89027: LIST
89028: PUSH
89029: LD_INT 1
89031: NEG
89032: PUSH
89033: LD_INT 1
89035: NEG
89036: PUSH
89037: EMPTY
89038: LIST
89039: LIST
89040: PUSH
89041: LD_INT 1
89043: NEG
89044: PUSH
89045: LD_INT 2
89047: NEG
89048: PUSH
89049: EMPTY
89050: LIST
89051: LIST
89052: PUSH
89053: LD_INT 0
89055: PUSH
89056: LD_INT 2
89058: NEG
89059: PUSH
89060: EMPTY
89061: LIST
89062: LIST
89063: PUSH
89064: LD_INT 1
89066: PUSH
89067: LD_INT 1
89069: NEG
89070: PUSH
89071: EMPTY
89072: LIST
89073: LIST
89074: PUSH
89075: LD_INT 2
89077: PUSH
89078: LD_INT 0
89080: PUSH
89081: EMPTY
89082: LIST
89083: LIST
89084: PUSH
89085: LD_INT 2
89087: PUSH
89088: LD_INT 1
89090: PUSH
89091: EMPTY
89092: LIST
89093: LIST
89094: PUSH
89095: LD_INT 2
89097: PUSH
89098: LD_INT 2
89100: PUSH
89101: EMPTY
89102: LIST
89103: LIST
89104: PUSH
89105: LD_INT 1
89107: PUSH
89108: LD_INT 2
89110: PUSH
89111: EMPTY
89112: LIST
89113: LIST
89114: PUSH
89115: LD_INT 0
89117: PUSH
89118: LD_INT 2
89120: PUSH
89121: EMPTY
89122: LIST
89123: LIST
89124: PUSH
89125: LD_INT 1
89127: NEG
89128: PUSH
89129: LD_INT 1
89131: PUSH
89132: EMPTY
89133: LIST
89134: LIST
89135: PUSH
89136: LD_INT 2
89138: NEG
89139: PUSH
89140: LD_INT 0
89142: PUSH
89143: EMPTY
89144: LIST
89145: LIST
89146: PUSH
89147: LD_INT 2
89149: NEG
89150: PUSH
89151: LD_INT 1
89153: NEG
89154: PUSH
89155: EMPTY
89156: LIST
89157: LIST
89158: PUSH
89159: LD_INT 2
89161: NEG
89162: PUSH
89163: LD_INT 2
89165: NEG
89166: PUSH
89167: EMPTY
89168: LIST
89169: LIST
89170: PUSH
89171: LD_INT 2
89173: NEG
89174: PUSH
89175: LD_INT 3
89177: NEG
89178: PUSH
89179: EMPTY
89180: LIST
89181: LIST
89182: PUSH
89183: LD_INT 1
89185: NEG
89186: PUSH
89187: LD_INT 3
89189: NEG
89190: PUSH
89191: EMPTY
89192: LIST
89193: LIST
89194: PUSH
89195: LD_INT 3
89197: NEG
89198: PUSH
89199: LD_INT 1
89201: NEG
89202: PUSH
89203: EMPTY
89204: LIST
89205: LIST
89206: PUSH
89207: LD_INT 3
89209: NEG
89210: PUSH
89211: LD_INT 2
89213: NEG
89214: PUSH
89215: EMPTY
89216: LIST
89217: LIST
89218: PUSH
89219: EMPTY
89220: LIST
89221: LIST
89222: LIST
89223: LIST
89224: LIST
89225: LIST
89226: LIST
89227: LIST
89228: LIST
89229: LIST
89230: LIST
89231: LIST
89232: LIST
89233: LIST
89234: LIST
89235: LIST
89236: LIST
89237: LIST
89238: LIST
89239: LIST
89240: LIST
89241: LIST
89242: LIST
89243: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
89244: LD_ADDR_VAR 0 29
89248: PUSH
89249: LD_INT 0
89251: PUSH
89252: LD_INT 0
89254: PUSH
89255: EMPTY
89256: LIST
89257: LIST
89258: PUSH
89259: LD_INT 0
89261: PUSH
89262: LD_INT 1
89264: NEG
89265: PUSH
89266: EMPTY
89267: LIST
89268: LIST
89269: PUSH
89270: LD_INT 1
89272: PUSH
89273: LD_INT 0
89275: PUSH
89276: EMPTY
89277: LIST
89278: LIST
89279: PUSH
89280: LD_INT 1
89282: PUSH
89283: LD_INT 1
89285: PUSH
89286: EMPTY
89287: LIST
89288: LIST
89289: PUSH
89290: LD_INT 0
89292: PUSH
89293: LD_INT 1
89295: PUSH
89296: EMPTY
89297: LIST
89298: LIST
89299: PUSH
89300: LD_INT 1
89302: NEG
89303: PUSH
89304: LD_INT 0
89306: PUSH
89307: EMPTY
89308: LIST
89309: LIST
89310: PUSH
89311: LD_INT 1
89313: NEG
89314: PUSH
89315: LD_INT 1
89317: NEG
89318: PUSH
89319: EMPTY
89320: LIST
89321: LIST
89322: PUSH
89323: LD_INT 1
89325: NEG
89326: PUSH
89327: LD_INT 2
89329: NEG
89330: PUSH
89331: EMPTY
89332: LIST
89333: LIST
89334: PUSH
89335: LD_INT 0
89337: PUSH
89338: LD_INT 2
89340: NEG
89341: PUSH
89342: EMPTY
89343: LIST
89344: LIST
89345: PUSH
89346: LD_INT 1
89348: PUSH
89349: LD_INT 1
89351: NEG
89352: PUSH
89353: EMPTY
89354: LIST
89355: LIST
89356: PUSH
89357: LD_INT 2
89359: PUSH
89360: LD_INT 0
89362: PUSH
89363: EMPTY
89364: LIST
89365: LIST
89366: PUSH
89367: LD_INT 2
89369: PUSH
89370: LD_INT 1
89372: PUSH
89373: EMPTY
89374: LIST
89375: LIST
89376: PUSH
89377: LD_INT 1
89379: PUSH
89380: LD_INT 2
89382: PUSH
89383: EMPTY
89384: LIST
89385: LIST
89386: PUSH
89387: LD_INT 0
89389: PUSH
89390: LD_INT 2
89392: PUSH
89393: EMPTY
89394: LIST
89395: LIST
89396: PUSH
89397: LD_INT 1
89399: NEG
89400: PUSH
89401: LD_INT 1
89403: PUSH
89404: EMPTY
89405: LIST
89406: LIST
89407: PUSH
89408: LD_INT 2
89410: NEG
89411: PUSH
89412: LD_INT 1
89414: NEG
89415: PUSH
89416: EMPTY
89417: LIST
89418: LIST
89419: PUSH
89420: LD_INT 2
89422: NEG
89423: PUSH
89424: LD_INT 2
89426: NEG
89427: PUSH
89428: EMPTY
89429: LIST
89430: LIST
89431: PUSH
89432: LD_INT 2
89434: NEG
89435: PUSH
89436: LD_INT 3
89438: NEG
89439: PUSH
89440: EMPTY
89441: LIST
89442: LIST
89443: PUSH
89444: LD_INT 2
89446: PUSH
89447: LD_INT 1
89449: NEG
89450: PUSH
89451: EMPTY
89452: LIST
89453: LIST
89454: PUSH
89455: LD_INT 3
89457: PUSH
89458: LD_INT 1
89460: PUSH
89461: EMPTY
89462: LIST
89463: LIST
89464: PUSH
89465: LD_INT 1
89467: PUSH
89468: LD_INT 3
89470: PUSH
89471: EMPTY
89472: LIST
89473: LIST
89474: PUSH
89475: LD_INT 1
89477: NEG
89478: PUSH
89479: LD_INT 2
89481: PUSH
89482: EMPTY
89483: LIST
89484: LIST
89485: PUSH
89486: LD_INT 3
89488: NEG
89489: PUSH
89490: LD_INT 2
89492: NEG
89493: PUSH
89494: EMPTY
89495: LIST
89496: LIST
89497: PUSH
89498: EMPTY
89499: LIST
89500: LIST
89501: LIST
89502: LIST
89503: LIST
89504: LIST
89505: LIST
89506: LIST
89507: LIST
89508: LIST
89509: LIST
89510: LIST
89511: LIST
89512: LIST
89513: LIST
89514: LIST
89515: LIST
89516: LIST
89517: LIST
89518: LIST
89519: LIST
89520: LIST
89521: LIST
89522: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
89523: LD_ADDR_VAR 0 30
89527: PUSH
89528: LD_INT 0
89530: PUSH
89531: LD_INT 0
89533: PUSH
89534: EMPTY
89535: LIST
89536: LIST
89537: PUSH
89538: LD_INT 0
89540: PUSH
89541: LD_INT 1
89543: NEG
89544: PUSH
89545: EMPTY
89546: LIST
89547: LIST
89548: PUSH
89549: LD_INT 1
89551: PUSH
89552: LD_INT 0
89554: PUSH
89555: EMPTY
89556: LIST
89557: LIST
89558: PUSH
89559: LD_INT 1
89561: PUSH
89562: LD_INT 1
89564: PUSH
89565: EMPTY
89566: LIST
89567: LIST
89568: PUSH
89569: LD_INT 0
89571: PUSH
89572: LD_INT 1
89574: PUSH
89575: EMPTY
89576: LIST
89577: LIST
89578: PUSH
89579: LD_INT 1
89581: NEG
89582: PUSH
89583: LD_INT 0
89585: PUSH
89586: EMPTY
89587: LIST
89588: LIST
89589: PUSH
89590: LD_INT 1
89592: NEG
89593: PUSH
89594: LD_INT 1
89596: NEG
89597: PUSH
89598: EMPTY
89599: LIST
89600: LIST
89601: PUSH
89602: LD_INT 1
89604: NEG
89605: PUSH
89606: LD_INT 2
89608: NEG
89609: PUSH
89610: EMPTY
89611: LIST
89612: LIST
89613: PUSH
89614: LD_INT 0
89616: PUSH
89617: LD_INT 2
89619: NEG
89620: PUSH
89621: EMPTY
89622: LIST
89623: LIST
89624: PUSH
89625: LD_INT 1
89627: PUSH
89628: LD_INT 1
89630: NEG
89631: PUSH
89632: EMPTY
89633: LIST
89634: LIST
89635: PUSH
89636: LD_INT 2
89638: PUSH
89639: LD_INT 0
89641: PUSH
89642: EMPTY
89643: LIST
89644: LIST
89645: PUSH
89646: LD_INT 2
89648: PUSH
89649: LD_INT 1
89651: PUSH
89652: EMPTY
89653: LIST
89654: LIST
89655: PUSH
89656: LD_INT 2
89658: PUSH
89659: LD_INT 2
89661: PUSH
89662: EMPTY
89663: LIST
89664: LIST
89665: PUSH
89666: LD_INT 1
89668: PUSH
89669: LD_INT 2
89671: PUSH
89672: EMPTY
89673: LIST
89674: LIST
89675: PUSH
89676: LD_INT 1
89678: NEG
89679: PUSH
89680: LD_INT 1
89682: PUSH
89683: EMPTY
89684: LIST
89685: LIST
89686: PUSH
89687: LD_INT 2
89689: NEG
89690: PUSH
89691: LD_INT 0
89693: PUSH
89694: EMPTY
89695: LIST
89696: LIST
89697: PUSH
89698: LD_INT 2
89700: NEG
89701: PUSH
89702: LD_INT 1
89704: NEG
89705: PUSH
89706: EMPTY
89707: LIST
89708: LIST
89709: PUSH
89710: LD_INT 1
89712: NEG
89713: PUSH
89714: LD_INT 3
89716: NEG
89717: PUSH
89718: EMPTY
89719: LIST
89720: LIST
89721: PUSH
89722: LD_INT 1
89724: PUSH
89725: LD_INT 2
89727: NEG
89728: PUSH
89729: EMPTY
89730: LIST
89731: LIST
89732: PUSH
89733: LD_INT 3
89735: PUSH
89736: LD_INT 2
89738: PUSH
89739: EMPTY
89740: LIST
89741: LIST
89742: PUSH
89743: LD_INT 2
89745: PUSH
89746: LD_INT 3
89748: PUSH
89749: EMPTY
89750: LIST
89751: LIST
89752: PUSH
89753: LD_INT 2
89755: NEG
89756: PUSH
89757: LD_INT 1
89759: PUSH
89760: EMPTY
89761: LIST
89762: LIST
89763: PUSH
89764: LD_INT 3
89766: NEG
89767: PUSH
89768: LD_INT 1
89770: NEG
89771: PUSH
89772: EMPTY
89773: LIST
89774: LIST
89775: PUSH
89776: EMPTY
89777: LIST
89778: LIST
89779: LIST
89780: LIST
89781: LIST
89782: LIST
89783: LIST
89784: LIST
89785: LIST
89786: LIST
89787: LIST
89788: LIST
89789: LIST
89790: LIST
89791: LIST
89792: LIST
89793: LIST
89794: LIST
89795: LIST
89796: LIST
89797: LIST
89798: LIST
89799: LIST
89800: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
89801: LD_ADDR_VAR 0 31
89805: PUSH
89806: LD_INT 0
89808: PUSH
89809: LD_INT 0
89811: PUSH
89812: EMPTY
89813: LIST
89814: LIST
89815: PUSH
89816: LD_INT 0
89818: PUSH
89819: LD_INT 1
89821: NEG
89822: PUSH
89823: EMPTY
89824: LIST
89825: LIST
89826: PUSH
89827: LD_INT 1
89829: PUSH
89830: LD_INT 0
89832: PUSH
89833: EMPTY
89834: LIST
89835: LIST
89836: PUSH
89837: LD_INT 1
89839: PUSH
89840: LD_INT 1
89842: PUSH
89843: EMPTY
89844: LIST
89845: LIST
89846: PUSH
89847: LD_INT 0
89849: PUSH
89850: LD_INT 1
89852: PUSH
89853: EMPTY
89854: LIST
89855: LIST
89856: PUSH
89857: LD_INT 1
89859: NEG
89860: PUSH
89861: LD_INT 0
89863: PUSH
89864: EMPTY
89865: LIST
89866: LIST
89867: PUSH
89868: LD_INT 1
89870: NEG
89871: PUSH
89872: LD_INT 1
89874: NEG
89875: PUSH
89876: EMPTY
89877: LIST
89878: LIST
89879: PUSH
89880: LD_INT 1
89882: NEG
89883: PUSH
89884: LD_INT 2
89886: NEG
89887: PUSH
89888: EMPTY
89889: LIST
89890: LIST
89891: PUSH
89892: LD_INT 1
89894: PUSH
89895: LD_INT 1
89897: NEG
89898: PUSH
89899: EMPTY
89900: LIST
89901: LIST
89902: PUSH
89903: LD_INT 2
89905: PUSH
89906: LD_INT 0
89908: PUSH
89909: EMPTY
89910: LIST
89911: LIST
89912: PUSH
89913: LD_INT 2
89915: PUSH
89916: LD_INT 1
89918: PUSH
89919: EMPTY
89920: LIST
89921: LIST
89922: PUSH
89923: LD_INT 2
89925: PUSH
89926: LD_INT 2
89928: PUSH
89929: EMPTY
89930: LIST
89931: LIST
89932: PUSH
89933: LD_INT 1
89935: PUSH
89936: LD_INT 2
89938: PUSH
89939: EMPTY
89940: LIST
89941: LIST
89942: PUSH
89943: LD_INT 0
89945: PUSH
89946: LD_INT 2
89948: PUSH
89949: EMPTY
89950: LIST
89951: LIST
89952: PUSH
89953: LD_INT 1
89955: NEG
89956: PUSH
89957: LD_INT 1
89959: PUSH
89960: EMPTY
89961: LIST
89962: LIST
89963: PUSH
89964: LD_INT 2
89966: NEG
89967: PUSH
89968: LD_INT 1
89970: NEG
89971: PUSH
89972: EMPTY
89973: LIST
89974: LIST
89975: PUSH
89976: LD_INT 2
89978: NEG
89979: PUSH
89980: LD_INT 2
89982: NEG
89983: PUSH
89984: EMPTY
89985: LIST
89986: LIST
89987: PUSH
89988: LD_INT 2
89990: NEG
89991: PUSH
89992: LD_INT 3
89994: NEG
89995: PUSH
89996: EMPTY
89997: LIST
89998: LIST
89999: PUSH
90000: LD_INT 2
90002: PUSH
90003: LD_INT 1
90005: NEG
90006: PUSH
90007: EMPTY
90008: LIST
90009: LIST
90010: PUSH
90011: LD_INT 3
90013: PUSH
90014: LD_INT 1
90016: PUSH
90017: EMPTY
90018: LIST
90019: LIST
90020: PUSH
90021: LD_INT 1
90023: PUSH
90024: LD_INT 3
90026: PUSH
90027: EMPTY
90028: LIST
90029: LIST
90030: PUSH
90031: LD_INT 1
90033: NEG
90034: PUSH
90035: LD_INT 2
90037: PUSH
90038: EMPTY
90039: LIST
90040: LIST
90041: PUSH
90042: LD_INT 3
90044: NEG
90045: PUSH
90046: LD_INT 2
90048: NEG
90049: PUSH
90050: EMPTY
90051: LIST
90052: LIST
90053: PUSH
90054: EMPTY
90055: LIST
90056: LIST
90057: LIST
90058: LIST
90059: LIST
90060: LIST
90061: LIST
90062: LIST
90063: LIST
90064: LIST
90065: LIST
90066: LIST
90067: LIST
90068: LIST
90069: LIST
90070: LIST
90071: LIST
90072: LIST
90073: LIST
90074: LIST
90075: LIST
90076: LIST
90077: LIST
90078: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
90079: LD_ADDR_VAR 0 32
90083: PUSH
90084: LD_INT 0
90086: PUSH
90087: LD_INT 0
90089: PUSH
90090: EMPTY
90091: LIST
90092: LIST
90093: PUSH
90094: LD_INT 0
90096: PUSH
90097: LD_INT 1
90099: NEG
90100: PUSH
90101: EMPTY
90102: LIST
90103: LIST
90104: PUSH
90105: LD_INT 1
90107: PUSH
90108: LD_INT 0
90110: PUSH
90111: EMPTY
90112: LIST
90113: LIST
90114: PUSH
90115: LD_INT 1
90117: PUSH
90118: LD_INT 1
90120: PUSH
90121: EMPTY
90122: LIST
90123: LIST
90124: PUSH
90125: LD_INT 0
90127: PUSH
90128: LD_INT 1
90130: PUSH
90131: EMPTY
90132: LIST
90133: LIST
90134: PUSH
90135: LD_INT 1
90137: NEG
90138: PUSH
90139: LD_INT 0
90141: PUSH
90142: EMPTY
90143: LIST
90144: LIST
90145: PUSH
90146: LD_INT 1
90148: NEG
90149: PUSH
90150: LD_INT 1
90152: NEG
90153: PUSH
90154: EMPTY
90155: LIST
90156: LIST
90157: PUSH
90158: LD_INT 1
90160: NEG
90161: PUSH
90162: LD_INT 2
90164: NEG
90165: PUSH
90166: EMPTY
90167: LIST
90168: LIST
90169: PUSH
90170: LD_INT 0
90172: PUSH
90173: LD_INT 2
90175: NEG
90176: PUSH
90177: EMPTY
90178: LIST
90179: LIST
90180: PUSH
90181: LD_INT 1
90183: PUSH
90184: LD_INT 1
90186: NEG
90187: PUSH
90188: EMPTY
90189: LIST
90190: LIST
90191: PUSH
90192: LD_INT 2
90194: PUSH
90195: LD_INT 1
90197: PUSH
90198: EMPTY
90199: LIST
90200: LIST
90201: PUSH
90202: LD_INT 2
90204: PUSH
90205: LD_INT 2
90207: PUSH
90208: EMPTY
90209: LIST
90210: LIST
90211: PUSH
90212: LD_INT 1
90214: PUSH
90215: LD_INT 2
90217: PUSH
90218: EMPTY
90219: LIST
90220: LIST
90221: PUSH
90222: LD_INT 0
90224: PUSH
90225: LD_INT 2
90227: PUSH
90228: EMPTY
90229: LIST
90230: LIST
90231: PUSH
90232: LD_INT 1
90234: NEG
90235: PUSH
90236: LD_INT 1
90238: PUSH
90239: EMPTY
90240: LIST
90241: LIST
90242: PUSH
90243: LD_INT 2
90245: NEG
90246: PUSH
90247: LD_INT 0
90249: PUSH
90250: EMPTY
90251: LIST
90252: LIST
90253: PUSH
90254: LD_INT 2
90256: NEG
90257: PUSH
90258: LD_INT 1
90260: NEG
90261: PUSH
90262: EMPTY
90263: LIST
90264: LIST
90265: PUSH
90266: LD_INT 1
90268: NEG
90269: PUSH
90270: LD_INT 3
90272: NEG
90273: PUSH
90274: EMPTY
90275: LIST
90276: LIST
90277: PUSH
90278: LD_INT 1
90280: PUSH
90281: LD_INT 2
90283: NEG
90284: PUSH
90285: EMPTY
90286: LIST
90287: LIST
90288: PUSH
90289: LD_INT 3
90291: PUSH
90292: LD_INT 2
90294: PUSH
90295: EMPTY
90296: LIST
90297: LIST
90298: PUSH
90299: LD_INT 2
90301: PUSH
90302: LD_INT 3
90304: PUSH
90305: EMPTY
90306: LIST
90307: LIST
90308: PUSH
90309: LD_INT 2
90311: NEG
90312: PUSH
90313: LD_INT 1
90315: PUSH
90316: EMPTY
90317: LIST
90318: LIST
90319: PUSH
90320: LD_INT 3
90322: NEG
90323: PUSH
90324: LD_INT 1
90326: NEG
90327: PUSH
90328: EMPTY
90329: LIST
90330: LIST
90331: PUSH
90332: EMPTY
90333: LIST
90334: LIST
90335: LIST
90336: LIST
90337: LIST
90338: LIST
90339: LIST
90340: LIST
90341: LIST
90342: LIST
90343: LIST
90344: LIST
90345: LIST
90346: LIST
90347: LIST
90348: LIST
90349: LIST
90350: LIST
90351: LIST
90352: LIST
90353: LIST
90354: LIST
90355: LIST
90356: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
90357: LD_ADDR_VAR 0 33
90361: PUSH
90362: LD_INT 0
90364: PUSH
90365: LD_INT 0
90367: PUSH
90368: EMPTY
90369: LIST
90370: LIST
90371: PUSH
90372: LD_INT 0
90374: PUSH
90375: LD_INT 1
90377: NEG
90378: PUSH
90379: EMPTY
90380: LIST
90381: LIST
90382: PUSH
90383: LD_INT 1
90385: PUSH
90386: LD_INT 0
90388: PUSH
90389: EMPTY
90390: LIST
90391: LIST
90392: PUSH
90393: LD_INT 1
90395: PUSH
90396: LD_INT 1
90398: PUSH
90399: EMPTY
90400: LIST
90401: LIST
90402: PUSH
90403: LD_INT 0
90405: PUSH
90406: LD_INT 1
90408: PUSH
90409: EMPTY
90410: LIST
90411: LIST
90412: PUSH
90413: LD_INT 1
90415: NEG
90416: PUSH
90417: LD_INT 0
90419: PUSH
90420: EMPTY
90421: LIST
90422: LIST
90423: PUSH
90424: LD_INT 1
90426: NEG
90427: PUSH
90428: LD_INT 1
90430: NEG
90431: PUSH
90432: EMPTY
90433: LIST
90434: LIST
90435: PUSH
90436: LD_INT 1
90438: NEG
90439: PUSH
90440: LD_INT 2
90442: NEG
90443: PUSH
90444: EMPTY
90445: LIST
90446: LIST
90447: PUSH
90448: LD_INT 1
90450: PUSH
90451: LD_INT 1
90453: NEG
90454: PUSH
90455: EMPTY
90456: LIST
90457: LIST
90458: PUSH
90459: LD_INT 2
90461: PUSH
90462: LD_INT 0
90464: PUSH
90465: EMPTY
90466: LIST
90467: LIST
90468: PUSH
90469: LD_INT 2
90471: PUSH
90472: LD_INT 1
90474: PUSH
90475: EMPTY
90476: LIST
90477: LIST
90478: PUSH
90479: LD_INT 1
90481: PUSH
90482: LD_INT 2
90484: PUSH
90485: EMPTY
90486: LIST
90487: LIST
90488: PUSH
90489: LD_INT 0
90491: PUSH
90492: LD_INT 2
90494: PUSH
90495: EMPTY
90496: LIST
90497: LIST
90498: PUSH
90499: LD_INT 1
90501: NEG
90502: PUSH
90503: LD_INT 1
90505: PUSH
90506: EMPTY
90507: LIST
90508: LIST
90509: PUSH
90510: LD_INT 2
90512: NEG
90513: PUSH
90514: LD_INT 0
90516: PUSH
90517: EMPTY
90518: LIST
90519: LIST
90520: PUSH
90521: LD_INT 2
90523: NEG
90524: PUSH
90525: LD_INT 1
90527: NEG
90528: PUSH
90529: EMPTY
90530: LIST
90531: LIST
90532: PUSH
90533: LD_INT 2
90535: NEG
90536: PUSH
90537: LD_INT 2
90539: NEG
90540: PUSH
90541: EMPTY
90542: LIST
90543: LIST
90544: PUSH
90545: LD_INT 2
90547: NEG
90548: PUSH
90549: LD_INT 3
90551: NEG
90552: PUSH
90553: EMPTY
90554: LIST
90555: LIST
90556: PUSH
90557: LD_INT 2
90559: PUSH
90560: LD_INT 1
90562: NEG
90563: PUSH
90564: EMPTY
90565: LIST
90566: LIST
90567: PUSH
90568: LD_INT 3
90570: PUSH
90571: LD_INT 1
90573: PUSH
90574: EMPTY
90575: LIST
90576: LIST
90577: PUSH
90578: LD_INT 1
90580: PUSH
90581: LD_INT 3
90583: PUSH
90584: EMPTY
90585: LIST
90586: LIST
90587: PUSH
90588: LD_INT 1
90590: NEG
90591: PUSH
90592: LD_INT 2
90594: PUSH
90595: EMPTY
90596: LIST
90597: LIST
90598: PUSH
90599: LD_INT 3
90601: NEG
90602: PUSH
90603: LD_INT 2
90605: NEG
90606: PUSH
90607: EMPTY
90608: LIST
90609: LIST
90610: PUSH
90611: EMPTY
90612: LIST
90613: LIST
90614: LIST
90615: LIST
90616: LIST
90617: LIST
90618: LIST
90619: LIST
90620: LIST
90621: LIST
90622: LIST
90623: LIST
90624: LIST
90625: LIST
90626: LIST
90627: LIST
90628: LIST
90629: LIST
90630: LIST
90631: LIST
90632: LIST
90633: LIST
90634: LIST
90635: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
90636: LD_ADDR_VAR 0 34
90640: PUSH
90641: LD_INT 0
90643: PUSH
90644: LD_INT 0
90646: PUSH
90647: EMPTY
90648: LIST
90649: LIST
90650: PUSH
90651: LD_INT 0
90653: PUSH
90654: LD_INT 1
90656: NEG
90657: PUSH
90658: EMPTY
90659: LIST
90660: LIST
90661: PUSH
90662: LD_INT 1
90664: PUSH
90665: LD_INT 0
90667: PUSH
90668: EMPTY
90669: LIST
90670: LIST
90671: PUSH
90672: LD_INT 1
90674: PUSH
90675: LD_INT 1
90677: PUSH
90678: EMPTY
90679: LIST
90680: LIST
90681: PUSH
90682: LD_INT 0
90684: PUSH
90685: LD_INT 1
90687: PUSH
90688: EMPTY
90689: LIST
90690: LIST
90691: PUSH
90692: LD_INT 1
90694: NEG
90695: PUSH
90696: LD_INT 0
90698: PUSH
90699: EMPTY
90700: LIST
90701: LIST
90702: PUSH
90703: LD_INT 1
90705: NEG
90706: PUSH
90707: LD_INT 1
90709: NEG
90710: PUSH
90711: EMPTY
90712: LIST
90713: LIST
90714: PUSH
90715: LD_INT 1
90717: NEG
90718: PUSH
90719: LD_INT 2
90721: NEG
90722: PUSH
90723: EMPTY
90724: LIST
90725: LIST
90726: PUSH
90727: LD_INT 0
90729: PUSH
90730: LD_INT 2
90732: NEG
90733: PUSH
90734: EMPTY
90735: LIST
90736: LIST
90737: PUSH
90738: LD_INT 1
90740: PUSH
90741: LD_INT 1
90743: NEG
90744: PUSH
90745: EMPTY
90746: LIST
90747: LIST
90748: PUSH
90749: LD_INT 2
90751: PUSH
90752: LD_INT 1
90754: PUSH
90755: EMPTY
90756: LIST
90757: LIST
90758: PUSH
90759: LD_INT 2
90761: PUSH
90762: LD_INT 2
90764: PUSH
90765: EMPTY
90766: LIST
90767: LIST
90768: PUSH
90769: LD_INT 1
90771: PUSH
90772: LD_INT 2
90774: PUSH
90775: EMPTY
90776: LIST
90777: LIST
90778: PUSH
90779: LD_INT 1
90781: NEG
90782: PUSH
90783: LD_INT 1
90785: PUSH
90786: EMPTY
90787: LIST
90788: LIST
90789: PUSH
90790: LD_INT 2
90792: NEG
90793: PUSH
90794: LD_INT 0
90796: PUSH
90797: EMPTY
90798: LIST
90799: LIST
90800: PUSH
90801: LD_INT 2
90803: NEG
90804: PUSH
90805: LD_INT 1
90807: NEG
90808: PUSH
90809: EMPTY
90810: LIST
90811: LIST
90812: PUSH
90813: LD_INT 2
90815: NEG
90816: PUSH
90817: LD_INT 2
90819: NEG
90820: PUSH
90821: EMPTY
90822: LIST
90823: LIST
90824: PUSH
90825: LD_INT 1
90827: NEG
90828: PUSH
90829: LD_INT 3
90831: NEG
90832: PUSH
90833: EMPTY
90834: LIST
90835: LIST
90836: PUSH
90837: LD_INT 1
90839: PUSH
90840: LD_INT 2
90842: NEG
90843: PUSH
90844: EMPTY
90845: LIST
90846: LIST
90847: PUSH
90848: LD_INT 3
90850: PUSH
90851: LD_INT 2
90853: PUSH
90854: EMPTY
90855: LIST
90856: LIST
90857: PUSH
90858: LD_INT 2
90860: PUSH
90861: LD_INT 3
90863: PUSH
90864: EMPTY
90865: LIST
90866: LIST
90867: PUSH
90868: LD_INT 2
90870: NEG
90871: PUSH
90872: LD_INT 1
90874: PUSH
90875: EMPTY
90876: LIST
90877: LIST
90878: PUSH
90879: LD_INT 3
90881: NEG
90882: PUSH
90883: LD_INT 1
90885: NEG
90886: PUSH
90887: EMPTY
90888: LIST
90889: LIST
90890: PUSH
90891: EMPTY
90892: LIST
90893: LIST
90894: LIST
90895: LIST
90896: LIST
90897: LIST
90898: LIST
90899: LIST
90900: LIST
90901: LIST
90902: LIST
90903: LIST
90904: LIST
90905: LIST
90906: LIST
90907: LIST
90908: LIST
90909: LIST
90910: LIST
90911: LIST
90912: LIST
90913: LIST
90914: LIST
90915: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
90916: LD_ADDR_VAR 0 35
90920: PUSH
90921: LD_INT 0
90923: PUSH
90924: LD_INT 0
90926: PUSH
90927: EMPTY
90928: LIST
90929: LIST
90930: PUSH
90931: LD_INT 0
90933: PUSH
90934: LD_INT 1
90936: NEG
90937: PUSH
90938: EMPTY
90939: LIST
90940: LIST
90941: PUSH
90942: LD_INT 1
90944: PUSH
90945: LD_INT 0
90947: PUSH
90948: EMPTY
90949: LIST
90950: LIST
90951: PUSH
90952: LD_INT 1
90954: PUSH
90955: LD_INT 1
90957: PUSH
90958: EMPTY
90959: LIST
90960: LIST
90961: PUSH
90962: LD_INT 0
90964: PUSH
90965: LD_INT 1
90967: PUSH
90968: EMPTY
90969: LIST
90970: LIST
90971: PUSH
90972: LD_INT 1
90974: NEG
90975: PUSH
90976: LD_INT 0
90978: PUSH
90979: EMPTY
90980: LIST
90981: LIST
90982: PUSH
90983: LD_INT 1
90985: NEG
90986: PUSH
90987: LD_INT 1
90989: NEG
90990: PUSH
90991: EMPTY
90992: LIST
90993: LIST
90994: PUSH
90995: LD_INT 2
90997: PUSH
90998: LD_INT 1
91000: PUSH
91001: EMPTY
91002: LIST
91003: LIST
91004: PUSH
91005: LD_INT 2
91007: NEG
91008: PUSH
91009: LD_INT 1
91011: NEG
91012: PUSH
91013: EMPTY
91014: LIST
91015: LIST
91016: PUSH
91017: EMPTY
91018: LIST
91019: LIST
91020: LIST
91021: LIST
91022: LIST
91023: LIST
91024: LIST
91025: LIST
91026: LIST
91027: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
91028: LD_ADDR_VAR 0 36
91032: PUSH
91033: LD_INT 0
91035: PUSH
91036: LD_INT 0
91038: PUSH
91039: EMPTY
91040: LIST
91041: LIST
91042: PUSH
91043: LD_INT 0
91045: PUSH
91046: LD_INT 1
91048: NEG
91049: PUSH
91050: EMPTY
91051: LIST
91052: LIST
91053: PUSH
91054: LD_INT 1
91056: PUSH
91057: LD_INT 0
91059: PUSH
91060: EMPTY
91061: LIST
91062: LIST
91063: PUSH
91064: LD_INT 1
91066: PUSH
91067: LD_INT 1
91069: PUSH
91070: EMPTY
91071: LIST
91072: LIST
91073: PUSH
91074: LD_INT 0
91076: PUSH
91077: LD_INT 1
91079: PUSH
91080: EMPTY
91081: LIST
91082: LIST
91083: PUSH
91084: LD_INT 1
91086: NEG
91087: PUSH
91088: LD_INT 0
91090: PUSH
91091: EMPTY
91092: LIST
91093: LIST
91094: PUSH
91095: LD_INT 1
91097: NEG
91098: PUSH
91099: LD_INT 1
91101: NEG
91102: PUSH
91103: EMPTY
91104: LIST
91105: LIST
91106: PUSH
91107: LD_INT 1
91109: NEG
91110: PUSH
91111: LD_INT 2
91113: NEG
91114: PUSH
91115: EMPTY
91116: LIST
91117: LIST
91118: PUSH
91119: LD_INT 1
91121: PUSH
91122: LD_INT 2
91124: PUSH
91125: EMPTY
91126: LIST
91127: LIST
91128: PUSH
91129: EMPTY
91130: LIST
91131: LIST
91132: LIST
91133: LIST
91134: LIST
91135: LIST
91136: LIST
91137: LIST
91138: LIST
91139: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
91140: LD_ADDR_VAR 0 37
91144: PUSH
91145: LD_INT 0
91147: PUSH
91148: LD_INT 0
91150: PUSH
91151: EMPTY
91152: LIST
91153: LIST
91154: PUSH
91155: LD_INT 0
91157: PUSH
91158: LD_INT 1
91160: NEG
91161: PUSH
91162: EMPTY
91163: LIST
91164: LIST
91165: PUSH
91166: LD_INT 1
91168: PUSH
91169: LD_INT 0
91171: PUSH
91172: EMPTY
91173: LIST
91174: LIST
91175: PUSH
91176: LD_INT 1
91178: PUSH
91179: LD_INT 1
91181: PUSH
91182: EMPTY
91183: LIST
91184: LIST
91185: PUSH
91186: LD_INT 0
91188: PUSH
91189: LD_INT 1
91191: PUSH
91192: EMPTY
91193: LIST
91194: LIST
91195: PUSH
91196: LD_INT 1
91198: NEG
91199: PUSH
91200: LD_INT 0
91202: PUSH
91203: EMPTY
91204: LIST
91205: LIST
91206: PUSH
91207: LD_INT 1
91209: NEG
91210: PUSH
91211: LD_INT 1
91213: NEG
91214: PUSH
91215: EMPTY
91216: LIST
91217: LIST
91218: PUSH
91219: LD_INT 1
91221: PUSH
91222: LD_INT 1
91224: NEG
91225: PUSH
91226: EMPTY
91227: LIST
91228: LIST
91229: PUSH
91230: LD_INT 1
91232: NEG
91233: PUSH
91234: LD_INT 1
91236: PUSH
91237: EMPTY
91238: LIST
91239: LIST
91240: PUSH
91241: EMPTY
91242: LIST
91243: LIST
91244: LIST
91245: LIST
91246: LIST
91247: LIST
91248: LIST
91249: LIST
91250: LIST
91251: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
91252: LD_ADDR_VAR 0 38
91256: PUSH
91257: LD_INT 0
91259: PUSH
91260: LD_INT 0
91262: PUSH
91263: EMPTY
91264: LIST
91265: LIST
91266: PUSH
91267: LD_INT 0
91269: PUSH
91270: LD_INT 1
91272: NEG
91273: PUSH
91274: EMPTY
91275: LIST
91276: LIST
91277: PUSH
91278: LD_INT 1
91280: PUSH
91281: LD_INT 0
91283: PUSH
91284: EMPTY
91285: LIST
91286: LIST
91287: PUSH
91288: LD_INT 1
91290: PUSH
91291: LD_INT 1
91293: PUSH
91294: EMPTY
91295: LIST
91296: LIST
91297: PUSH
91298: LD_INT 0
91300: PUSH
91301: LD_INT 1
91303: PUSH
91304: EMPTY
91305: LIST
91306: LIST
91307: PUSH
91308: LD_INT 1
91310: NEG
91311: PUSH
91312: LD_INT 0
91314: PUSH
91315: EMPTY
91316: LIST
91317: LIST
91318: PUSH
91319: LD_INT 1
91321: NEG
91322: PUSH
91323: LD_INT 1
91325: NEG
91326: PUSH
91327: EMPTY
91328: LIST
91329: LIST
91330: PUSH
91331: LD_INT 2
91333: PUSH
91334: LD_INT 1
91336: PUSH
91337: EMPTY
91338: LIST
91339: LIST
91340: PUSH
91341: LD_INT 2
91343: NEG
91344: PUSH
91345: LD_INT 1
91347: NEG
91348: PUSH
91349: EMPTY
91350: LIST
91351: LIST
91352: PUSH
91353: EMPTY
91354: LIST
91355: LIST
91356: LIST
91357: LIST
91358: LIST
91359: LIST
91360: LIST
91361: LIST
91362: LIST
91363: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
91364: LD_ADDR_VAR 0 39
91368: PUSH
91369: LD_INT 0
91371: PUSH
91372: LD_INT 0
91374: PUSH
91375: EMPTY
91376: LIST
91377: LIST
91378: PUSH
91379: LD_INT 0
91381: PUSH
91382: LD_INT 1
91384: NEG
91385: PUSH
91386: EMPTY
91387: LIST
91388: LIST
91389: PUSH
91390: LD_INT 1
91392: PUSH
91393: LD_INT 0
91395: PUSH
91396: EMPTY
91397: LIST
91398: LIST
91399: PUSH
91400: LD_INT 1
91402: PUSH
91403: LD_INT 1
91405: PUSH
91406: EMPTY
91407: LIST
91408: LIST
91409: PUSH
91410: LD_INT 0
91412: PUSH
91413: LD_INT 1
91415: PUSH
91416: EMPTY
91417: LIST
91418: LIST
91419: PUSH
91420: LD_INT 1
91422: NEG
91423: PUSH
91424: LD_INT 0
91426: PUSH
91427: EMPTY
91428: LIST
91429: LIST
91430: PUSH
91431: LD_INT 1
91433: NEG
91434: PUSH
91435: LD_INT 1
91437: NEG
91438: PUSH
91439: EMPTY
91440: LIST
91441: LIST
91442: PUSH
91443: LD_INT 1
91445: NEG
91446: PUSH
91447: LD_INT 2
91449: NEG
91450: PUSH
91451: EMPTY
91452: LIST
91453: LIST
91454: PUSH
91455: LD_INT 1
91457: PUSH
91458: LD_INT 2
91460: PUSH
91461: EMPTY
91462: LIST
91463: LIST
91464: PUSH
91465: EMPTY
91466: LIST
91467: LIST
91468: LIST
91469: LIST
91470: LIST
91471: LIST
91472: LIST
91473: LIST
91474: LIST
91475: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
91476: LD_ADDR_VAR 0 40
91480: PUSH
91481: LD_INT 0
91483: PUSH
91484: LD_INT 0
91486: PUSH
91487: EMPTY
91488: LIST
91489: LIST
91490: PUSH
91491: LD_INT 0
91493: PUSH
91494: LD_INT 1
91496: NEG
91497: PUSH
91498: EMPTY
91499: LIST
91500: LIST
91501: PUSH
91502: LD_INT 1
91504: PUSH
91505: LD_INT 0
91507: PUSH
91508: EMPTY
91509: LIST
91510: LIST
91511: PUSH
91512: LD_INT 1
91514: PUSH
91515: LD_INT 1
91517: PUSH
91518: EMPTY
91519: LIST
91520: LIST
91521: PUSH
91522: LD_INT 0
91524: PUSH
91525: LD_INT 1
91527: PUSH
91528: EMPTY
91529: LIST
91530: LIST
91531: PUSH
91532: LD_INT 1
91534: NEG
91535: PUSH
91536: LD_INT 0
91538: PUSH
91539: EMPTY
91540: LIST
91541: LIST
91542: PUSH
91543: LD_INT 1
91545: NEG
91546: PUSH
91547: LD_INT 1
91549: NEG
91550: PUSH
91551: EMPTY
91552: LIST
91553: LIST
91554: PUSH
91555: LD_INT 1
91557: PUSH
91558: LD_INT 1
91560: NEG
91561: PUSH
91562: EMPTY
91563: LIST
91564: LIST
91565: PUSH
91566: LD_INT 1
91568: NEG
91569: PUSH
91570: LD_INT 1
91572: PUSH
91573: EMPTY
91574: LIST
91575: LIST
91576: PUSH
91577: EMPTY
91578: LIST
91579: LIST
91580: LIST
91581: LIST
91582: LIST
91583: LIST
91584: LIST
91585: LIST
91586: LIST
91587: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91588: LD_ADDR_VAR 0 41
91592: PUSH
91593: LD_INT 0
91595: PUSH
91596: LD_INT 0
91598: PUSH
91599: EMPTY
91600: LIST
91601: LIST
91602: PUSH
91603: LD_INT 0
91605: PUSH
91606: LD_INT 1
91608: NEG
91609: PUSH
91610: EMPTY
91611: LIST
91612: LIST
91613: PUSH
91614: LD_INT 1
91616: PUSH
91617: LD_INT 0
91619: PUSH
91620: EMPTY
91621: LIST
91622: LIST
91623: PUSH
91624: LD_INT 1
91626: PUSH
91627: LD_INT 1
91629: PUSH
91630: EMPTY
91631: LIST
91632: LIST
91633: PUSH
91634: LD_INT 0
91636: PUSH
91637: LD_INT 1
91639: PUSH
91640: EMPTY
91641: LIST
91642: LIST
91643: PUSH
91644: LD_INT 1
91646: NEG
91647: PUSH
91648: LD_INT 0
91650: PUSH
91651: EMPTY
91652: LIST
91653: LIST
91654: PUSH
91655: LD_INT 1
91657: NEG
91658: PUSH
91659: LD_INT 1
91661: NEG
91662: PUSH
91663: EMPTY
91664: LIST
91665: LIST
91666: PUSH
91667: LD_INT 1
91669: NEG
91670: PUSH
91671: LD_INT 2
91673: NEG
91674: PUSH
91675: EMPTY
91676: LIST
91677: LIST
91678: PUSH
91679: LD_INT 1
91681: PUSH
91682: LD_INT 1
91684: NEG
91685: PUSH
91686: EMPTY
91687: LIST
91688: LIST
91689: PUSH
91690: LD_INT 2
91692: PUSH
91693: LD_INT 0
91695: PUSH
91696: EMPTY
91697: LIST
91698: LIST
91699: PUSH
91700: LD_INT 2
91702: PUSH
91703: LD_INT 1
91705: PUSH
91706: EMPTY
91707: LIST
91708: LIST
91709: PUSH
91710: LD_INT 2
91712: PUSH
91713: LD_INT 2
91715: PUSH
91716: EMPTY
91717: LIST
91718: LIST
91719: PUSH
91720: LD_INT 1
91722: PUSH
91723: LD_INT 2
91725: PUSH
91726: EMPTY
91727: LIST
91728: LIST
91729: PUSH
91730: LD_INT 1
91732: NEG
91733: PUSH
91734: LD_INT 1
91736: PUSH
91737: EMPTY
91738: LIST
91739: LIST
91740: PUSH
91741: LD_INT 2
91743: NEG
91744: PUSH
91745: LD_INT 0
91747: PUSH
91748: EMPTY
91749: LIST
91750: LIST
91751: PUSH
91752: LD_INT 2
91754: NEG
91755: PUSH
91756: LD_INT 1
91758: NEG
91759: PUSH
91760: EMPTY
91761: LIST
91762: LIST
91763: PUSH
91764: LD_INT 2
91766: NEG
91767: PUSH
91768: LD_INT 2
91770: NEG
91771: PUSH
91772: EMPTY
91773: LIST
91774: LIST
91775: PUSH
91776: LD_INT 2
91778: NEG
91779: PUSH
91780: LD_INT 3
91782: NEG
91783: PUSH
91784: EMPTY
91785: LIST
91786: LIST
91787: PUSH
91788: LD_INT 2
91790: PUSH
91791: LD_INT 1
91793: NEG
91794: PUSH
91795: EMPTY
91796: LIST
91797: LIST
91798: PUSH
91799: LD_INT 3
91801: PUSH
91802: LD_INT 0
91804: PUSH
91805: EMPTY
91806: LIST
91807: LIST
91808: PUSH
91809: LD_INT 3
91811: PUSH
91812: LD_INT 1
91814: PUSH
91815: EMPTY
91816: LIST
91817: LIST
91818: PUSH
91819: LD_INT 3
91821: PUSH
91822: LD_INT 2
91824: PUSH
91825: EMPTY
91826: LIST
91827: LIST
91828: PUSH
91829: LD_INT 3
91831: PUSH
91832: LD_INT 3
91834: PUSH
91835: EMPTY
91836: LIST
91837: LIST
91838: PUSH
91839: LD_INT 2
91841: PUSH
91842: LD_INT 3
91844: PUSH
91845: EMPTY
91846: LIST
91847: LIST
91848: PUSH
91849: LD_INT 2
91851: NEG
91852: PUSH
91853: LD_INT 1
91855: PUSH
91856: EMPTY
91857: LIST
91858: LIST
91859: PUSH
91860: LD_INT 3
91862: NEG
91863: PUSH
91864: LD_INT 0
91866: PUSH
91867: EMPTY
91868: LIST
91869: LIST
91870: PUSH
91871: LD_INT 3
91873: NEG
91874: PUSH
91875: LD_INT 1
91877: NEG
91878: PUSH
91879: EMPTY
91880: LIST
91881: LIST
91882: PUSH
91883: LD_INT 3
91885: NEG
91886: PUSH
91887: LD_INT 2
91889: NEG
91890: PUSH
91891: EMPTY
91892: LIST
91893: LIST
91894: PUSH
91895: LD_INT 3
91897: NEG
91898: PUSH
91899: LD_INT 3
91901: NEG
91902: PUSH
91903: EMPTY
91904: LIST
91905: LIST
91906: PUSH
91907: EMPTY
91908: LIST
91909: LIST
91910: LIST
91911: LIST
91912: LIST
91913: LIST
91914: LIST
91915: LIST
91916: LIST
91917: LIST
91918: LIST
91919: LIST
91920: LIST
91921: LIST
91922: LIST
91923: LIST
91924: LIST
91925: LIST
91926: LIST
91927: LIST
91928: LIST
91929: LIST
91930: LIST
91931: LIST
91932: LIST
91933: LIST
91934: LIST
91935: LIST
91936: LIST
91937: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91938: LD_ADDR_VAR 0 42
91942: PUSH
91943: LD_INT 0
91945: PUSH
91946: LD_INT 0
91948: PUSH
91949: EMPTY
91950: LIST
91951: LIST
91952: PUSH
91953: LD_INT 0
91955: PUSH
91956: LD_INT 1
91958: NEG
91959: PUSH
91960: EMPTY
91961: LIST
91962: LIST
91963: PUSH
91964: LD_INT 1
91966: PUSH
91967: LD_INT 0
91969: PUSH
91970: EMPTY
91971: LIST
91972: LIST
91973: PUSH
91974: LD_INT 1
91976: PUSH
91977: LD_INT 1
91979: PUSH
91980: EMPTY
91981: LIST
91982: LIST
91983: PUSH
91984: LD_INT 0
91986: PUSH
91987: LD_INT 1
91989: PUSH
91990: EMPTY
91991: LIST
91992: LIST
91993: PUSH
91994: LD_INT 1
91996: NEG
91997: PUSH
91998: LD_INT 0
92000: PUSH
92001: EMPTY
92002: LIST
92003: LIST
92004: PUSH
92005: LD_INT 1
92007: NEG
92008: PUSH
92009: LD_INT 1
92011: NEG
92012: PUSH
92013: EMPTY
92014: LIST
92015: LIST
92016: PUSH
92017: LD_INT 1
92019: NEG
92020: PUSH
92021: LD_INT 2
92023: NEG
92024: PUSH
92025: EMPTY
92026: LIST
92027: LIST
92028: PUSH
92029: LD_INT 0
92031: PUSH
92032: LD_INT 2
92034: NEG
92035: PUSH
92036: EMPTY
92037: LIST
92038: LIST
92039: PUSH
92040: LD_INT 1
92042: PUSH
92043: LD_INT 1
92045: NEG
92046: PUSH
92047: EMPTY
92048: LIST
92049: LIST
92050: PUSH
92051: LD_INT 2
92053: PUSH
92054: LD_INT 1
92056: PUSH
92057: EMPTY
92058: LIST
92059: LIST
92060: PUSH
92061: LD_INT 2
92063: PUSH
92064: LD_INT 2
92066: PUSH
92067: EMPTY
92068: LIST
92069: LIST
92070: PUSH
92071: LD_INT 1
92073: PUSH
92074: LD_INT 2
92076: PUSH
92077: EMPTY
92078: LIST
92079: LIST
92080: PUSH
92081: LD_INT 0
92083: PUSH
92084: LD_INT 2
92086: PUSH
92087: EMPTY
92088: LIST
92089: LIST
92090: PUSH
92091: LD_INT 1
92093: NEG
92094: PUSH
92095: LD_INT 1
92097: PUSH
92098: EMPTY
92099: LIST
92100: LIST
92101: PUSH
92102: LD_INT 2
92104: NEG
92105: PUSH
92106: LD_INT 1
92108: NEG
92109: PUSH
92110: EMPTY
92111: LIST
92112: LIST
92113: PUSH
92114: LD_INT 2
92116: NEG
92117: PUSH
92118: LD_INT 2
92120: NEG
92121: PUSH
92122: EMPTY
92123: LIST
92124: LIST
92125: PUSH
92126: LD_INT 2
92128: NEG
92129: PUSH
92130: LD_INT 3
92132: NEG
92133: PUSH
92134: EMPTY
92135: LIST
92136: LIST
92137: PUSH
92138: LD_INT 1
92140: NEG
92141: PUSH
92142: LD_INT 3
92144: NEG
92145: PUSH
92146: EMPTY
92147: LIST
92148: LIST
92149: PUSH
92150: LD_INT 0
92152: PUSH
92153: LD_INT 3
92155: NEG
92156: PUSH
92157: EMPTY
92158: LIST
92159: LIST
92160: PUSH
92161: LD_INT 1
92163: PUSH
92164: LD_INT 2
92166: NEG
92167: PUSH
92168: EMPTY
92169: LIST
92170: LIST
92171: PUSH
92172: LD_INT 3
92174: PUSH
92175: LD_INT 2
92177: PUSH
92178: EMPTY
92179: LIST
92180: LIST
92181: PUSH
92182: LD_INT 3
92184: PUSH
92185: LD_INT 3
92187: PUSH
92188: EMPTY
92189: LIST
92190: LIST
92191: PUSH
92192: LD_INT 2
92194: PUSH
92195: LD_INT 3
92197: PUSH
92198: EMPTY
92199: LIST
92200: LIST
92201: PUSH
92202: LD_INT 1
92204: PUSH
92205: LD_INT 3
92207: PUSH
92208: EMPTY
92209: LIST
92210: LIST
92211: PUSH
92212: LD_INT 0
92214: PUSH
92215: LD_INT 3
92217: PUSH
92218: EMPTY
92219: LIST
92220: LIST
92221: PUSH
92222: LD_INT 1
92224: NEG
92225: PUSH
92226: LD_INT 2
92228: PUSH
92229: EMPTY
92230: LIST
92231: LIST
92232: PUSH
92233: LD_INT 3
92235: NEG
92236: PUSH
92237: LD_INT 2
92239: NEG
92240: PUSH
92241: EMPTY
92242: LIST
92243: LIST
92244: PUSH
92245: LD_INT 3
92247: NEG
92248: PUSH
92249: LD_INT 3
92251: NEG
92252: PUSH
92253: EMPTY
92254: LIST
92255: LIST
92256: PUSH
92257: EMPTY
92258: LIST
92259: LIST
92260: LIST
92261: LIST
92262: LIST
92263: LIST
92264: LIST
92265: LIST
92266: LIST
92267: LIST
92268: LIST
92269: LIST
92270: LIST
92271: LIST
92272: LIST
92273: LIST
92274: LIST
92275: LIST
92276: LIST
92277: LIST
92278: LIST
92279: LIST
92280: LIST
92281: LIST
92282: LIST
92283: LIST
92284: LIST
92285: LIST
92286: LIST
92287: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92288: LD_ADDR_VAR 0 43
92292: PUSH
92293: LD_INT 0
92295: PUSH
92296: LD_INT 0
92298: PUSH
92299: EMPTY
92300: LIST
92301: LIST
92302: PUSH
92303: LD_INT 0
92305: PUSH
92306: LD_INT 1
92308: NEG
92309: PUSH
92310: EMPTY
92311: LIST
92312: LIST
92313: PUSH
92314: LD_INT 1
92316: PUSH
92317: LD_INT 0
92319: PUSH
92320: EMPTY
92321: LIST
92322: LIST
92323: PUSH
92324: LD_INT 1
92326: PUSH
92327: LD_INT 1
92329: PUSH
92330: EMPTY
92331: LIST
92332: LIST
92333: PUSH
92334: LD_INT 0
92336: PUSH
92337: LD_INT 1
92339: PUSH
92340: EMPTY
92341: LIST
92342: LIST
92343: PUSH
92344: LD_INT 1
92346: NEG
92347: PUSH
92348: LD_INT 0
92350: PUSH
92351: EMPTY
92352: LIST
92353: LIST
92354: PUSH
92355: LD_INT 1
92357: NEG
92358: PUSH
92359: LD_INT 1
92361: NEG
92362: PUSH
92363: EMPTY
92364: LIST
92365: LIST
92366: PUSH
92367: LD_INT 1
92369: NEG
92370: PUSH
92371: LD_INT 2
92373: NEG
92374: PUSH
92375: EMPTY
92376: LIST
92377: LIST
92378: PUSH
92379: LD_INT 0
92381: PUSH
92382: LD_INT 2
92384: NEG
92385: PUSH
92386: EMPTY
92387: LIST
92388: LIST
92389: PUSH
92390: LD_INT 1
92392: PUSH
92393: LD_INT 1
92395: NEG
92396: PUSH
92397: EMPTY
92398: LIST
92399: LIST
92400: PUSH
92401: LD_INT 2
92403: PUSH
92404: LD_INT 0
92406: PUSH
92407: EMPTY
92408: LIST
92409: LIST
92410: PUSH
92411: LD_INT 2
92413: PUSH
92414: LD_INT 1
92416: PUSH
92417: EMPTY
92418: LIST
92419: LIST
92420: PUSH
92421: LD_INT 1
92423: PUSH
92424: LD_INT 2
92426: PUSH
92427: EMPTY
92428: LIST
92429: LIST
92430: PUSH
92431: LD_INT 0
92433: PUSH
92434: LD_INT 2
92436: PUSH
92437: EMPTY
92438: LIST
92439: LIST
92440: PUSH
92441: LD_INT 1
92443: NEG
92444: PUSH
92445: LD_INT 1
92447: PUSH
92448: EMPTY
92449: LIST
92450: LIST
92451: PUSH
92452: LD_INT 2
92454: NEG
92455: PUSH
92456: LD_INT 0
92458: PUSH
92459: EMPTY
92460: LIST
92461: LIST
92462: PUSH
92463: LD_INT 2
92465: NEG
92466: PUSH
92467: LD_INT 1
92469: NEG
92470: PUSH
92471: EMPTY
92472: LIST
92473: LIST
92474: PUSH
92475: LD_INT 1
92477: NEG
92478: PUSH
92479: LD_INT 3
92481: NEG
92482: PUSH
92483: EMPTY
92484: LIST
92485: LIST
92486: PUSH
92487: LD_INT 0
92489: PUSH
92490: LD_INT 3
92492: NEG
92493: PUSH
92494: EMPTY
92495: LIST
92496: LIST
92497: PUSH
92498: LD_INT 1
92500: PUSH
92501: LD_INT 2
92503: NEG
92504: PUSH
92505: EMPTY
92506: LIST
92507: LIST
92508: PUSH
92509: LD_INT 2
92511: PUSH
92512: LD_INT 1
92514: NEG
92515: PUSH
92516: EMPTY
92517: LIST
92518: LIST
92519: PUSH
92520: LD_INT 3
92522: PUSH
92523: LD_INT 0
92525: PUSH
92526: EMPTY
92527: LIST
92528: LIST
92529: PUSH
92530: LD_INT 3
92532: PUSH
92533: LD_INT 1
92535: PUSH
92536: EMPTY
92537: LIST
92538: LIST
92539: PUSH
92540: LD_INT 1
92542: PUSH
92543: LD_INT 3
92545: PUSH
92546: EMPTY
92547: LIST
92548: LIST
92549: PUSH
92550: LD_INT 0
92552: PUSH
92553: LD_INT 3
92555: PUSH
92556: EMPTY
92557: LIST
92558: LIST
92559: PUSH
92560: LD_INT 1
92562: NEG
92563: PUSH
92564: LD_INT 2
92566: PUSH
92567: EMPTY
92568: LIST
92569: LIST
92570: PUSH
92571: LD_INT 2
92573: NEG
92574: PUSH
92575: LD_INT 1
92577: PUSH
92578: EMPTY
92579: LIST
92580: LIST
92581: PUSH
92582: LD_INT 3
92584: NEG
92585: PUSH
92586: LD_INT 0
92588: PUSH
92589: EMPTY
92590: LIST
92591: LIST
92592: PUSH
92593: LD_INT 3
92595: NEG
92596: PUSH
92597: LD_INT 1
92599: NEG
92600: PUSH
92601: EMPTY
92602: LIST
92603: LIST
92604: PUSH
92605: EMPTY
92606: LIST
92607: LIST
92608: LIST
92609: LIST
92610: LIST
92611: LIST
92612: LIST
92613: LIST
92614: LIST
92615: LIST
92616: LIST
92617: LIST
92618: LIST
92619: LIST
92620: LIST
92621: LIST
92622: LIST
92623: LIST
92624: LIST
92625: LIST
92626: LIST
92627: LIST
92628: LIST
92629: LIST
92630: LIST
92631: LIST
92632: LIST
92633: LIST
92634: LIST
92635: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92636: LD_ADDR_VAR 0 44
92640: PUSH
92641: LD_INT 0
92643: PUSH
92644: LD_INT 0
92646: PUSH
92647: EMPTY
92648: LIST
92649: LIST
92650: PUSH
92651: LD_INT 0
92653: PUSH
92654: LD_INT 1
92656: NEG
92657: PUSH
92658: EMPTY
92659: LIST
92660: LIST
92661: PUSH
92662: LD_INT 1
92664: PUSH
92665: LD_INT 0
92667: PUSH
92668: EMPTY
92669: LIST
92670: LIST
92671: PUSH
92672: LD_INT 1
92674: PUSH
92675: LD_INT 1
92677: PUSH
92678: EMPTY
92679: LIST
92680: LIST
92681: PUSH
92682: LD_INT 0
92684: PUSH
92685: LD_INT 1
92687: PUSH
92688: EMPTY
92689: LIST
92690: LIST
92691: PUSH
92692: LD_INT 1
92694: NEG
92695: PUSH
92696: LD_INT 0
92698: PUSH
92699: EMPTY
92700: LIST
92701: LIST
92702: PUSH
92703: LD_INT 1
92705: NEG
92706: PUSH
92707: LD_INT 1
92709: NEG
92710: PUSH
92711: EMPTY
92712: LIST
92713: LIST
92714: PUSH
92715: LD_INT 1
92717: NEG
92718: PUSH
92719: LD_INT 2
92721: NEG
92722: PUSH
92723: EMPTY
92724: LIST
92725: LIST
92726: PUSH
92727: LD_INT 1
92729: PUSH
92730: LD_INT 1
92732: NEG
92733: PUSH
92734: EMPTY
92735: LIST
92736: LIST
92737: PUSH
92738: LD_INT 2
92740: PUSH
92741: LD_INT 0
92743: PUSH
92744: EMPTY
92745: LIST
92746: LIST
92747: PUSH
92748: LD_INT 2
92750: PUSH
92751: LD_INT 1
92753: PUSH
92754: EMPTY
92755: LIST
92756: LIST
92757: PUSH
92758: LD_INT 2
92760: PUSH
92761: LD_INT 2
92763: PUSH
92764: EMPTY
92765: LIST
92766: LIST
92767: PUSH
92768: LD_INT 1
92770: PUSH
92771: LD_INT 2
92773: PUSH
92774: EMPTY
92775: LIST
92776: LIST
92777: PUSH
92778: LD_INT 1
92780: NEG
92781: PUSH
92782: LD_INT 1
92784: PUSH
92785: EMPTY
92786: LIST
92787: LIST
92788: PUSH
92789: LD_INT 2
92791: NEG
92792: PUSH
92793: LD_INT 0
92795: PUSH
92796: EMPTY
92797: LIST
92798: LIST
92799: PUSH
92800: LD_INT 2
92802: NEG
92803: PUSH
92804: LD_INT 1
92806: NEG
92807: PUSH
92808: EMPTY
92809: LIST
92810: LIST
92811: PUSH
92812: LD_INT 2
92814: NEG
92815: PUSH
92816: LD_INT 2
92818: NEG
92819: PUSH
92820: EMPTY
92821: LIST
92822: LIST
92823: PUSH
92824: LD_INT 2
92826: NEG
92827: PUSH
92828: LD_INT 3
92830: NEG
92831: PUSH
92832: EMPTY
92833: LIST
92834: LIST
92835: PUSH
92836: LD_INT 2
92838: PUSH
92839: LD_INT 1
92841: NEG
92842: PUSH
92843: EMPTY
92844: LIST
92845: LIST
92846: PUSH
92847: LD_INT 3
92849: PUSH
92850: LD_INT 0
92852: PUSH
92853: EMPTY
92854: LIST
92855: LIST
92856: PUSH
92857: LD_INT 3
92859: PUSH
92860: LD_INT 1
92862: PUSH
92863: EMPTY
92864: LIST
92865: LIST
92866: PUSH
92867: LD_INT 3
92869: PUSH
92870: LD_INT 2
92872: PUSH
92873: EMPTY
92874: LIST
92875: LIST
92876: PUSH
92877: LD_INT 3
92879: PUSH
92880: LD_INT 3
92882: PUSH
92883: EMPTY
92884: LIST
92885: LIST
92886: PUSH
92887: LD_INT 2
92889: PUSH
92890: LD_INT 3
92892: PUSH
92893: EMPTY
92894: LIST
92895: LIST
92896: PUSH
92897: LD_INT 2
92899: NEG
92900: PUSH
92901: LD_INT 1
92903: PUSH
92904: EMPTY
92905: LIST
92906: LIST
92907: PUSH
92908: LD_INT 3
92910: NEG
92911: PUSH
92912: LD_INT 0
92914: PUSH
92915: EMPTY
92916: LIST
92917: LIST
92918: PUSH
92919: LD_INT 3
92921: NEG
92922: PUSH
92923: LD_INT 1
92925: NEG
92926: PUSH
92927: EMPTY
92928: LIST
92929: LIST
92930: PUSH
92931: LD_INT 3
92933: NEG
92934: PUSH
92935: LD_INT 2
92937: NEG
92938: PUSH
92939: EMPTY
92940: LIST
92941: LIST
92942: PUSH
92943: LD_INT 3
92945: NEG
92946: PUSH
92947: LD_INT 3
92949: NEG
92950: PUSH
92951: EMPTY
92952: LIST
92953: LIST
92954: PUSH
92955: EMPTY
92956: LIST
92957: LIST
92958: LIST
92959: LIST
92960: LIST
92961: LIST
92962: LIST
92963: LIST
92964: LIST
92965: LIST
92966: LIST
92967: LIST
92968: LIST
92969: LIST
92970: LIST
92971: LIST
92972: LIST
92973: LIST
92974: LIST
92975: LIST
92976: LIST
92977: LIST
92978: LIST
92979: LIST
92980: LIST
92981: LIST
92982: LIST
92983: LIST
92984: LIST
92985: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92986: LD_ADDR_VAR 0 45
92990: PUSH
92991: LD_INT 0
92993: PUSH
92994: LD_INT 0
92996: PUSH
92997: EMPTY
92998: LIST
92999: LIST
93000: PUSH
93001: LD_INT 0
93003: PUSH
93004: LD_INT 1
93006: NEG
93007: PUSH
93008: EMPTY
93009: LIST
93010: LIST
93011: PUSH
93012: LD_INT 1
93014: PUSH
93015: LD_INT 0
93017: PUSH
93018: EMPTY
93019: LIST
93020: LIST
93021: PUSH
93022: LD_INT 1
93024: PUSH
93025: LD_INT 1
93027: PUSH
93028: EMPTY
93029: LIST
93030: LIST
93031: PUSH
93032: LD_INT 0
93034: PUSH
93035: LD_INT 1
93037: PUSH
93038: EMPTY
93039: LIST
93040: LIST
93041: PUSH
93042: LD_INT 1
93044: NEG
93045: PUSH
93046: LD_INT 0
93048: PUSH
93049: EMPTY
93050: LIST
93051: LIST
93052: PUSH
93053: LD_INT 1
93055: NEG
93056: PUSH
93057: LD_INT 1
93059: NEG
93060: PUSH
93061: EMPTY
93062: LIST
93063: LIST
93064: PUSH
93065: LD_INT 1
93067: NEG
93068: PUSH
93069: LD_INT 2
93071: NEG
93072: PUSH
93073: EMPTY
93074: LIST
93075: LIST
93076: PUSH
93077: LD_INT 0
93079: PUSH
93080: LD_INT 2
93082: NEG
93083: PUSH
93084: EMPTY
93085: LIST
93086: LIST
93087: PUSH
93088: LD_INT 1
93090: PUSH
93091: LD_INT 1
93093: NEG
93094: PUSH
93095: EMPTY
93096: LIST
93097: LIST
93098: PUSH
93099: LD_INT 2
93101: PUSH
93102: LD_INT 1
93104: PUSH
93105: EMPTY
93106: LIST
93107: LIST
93108: PUSH
93109: LD_INT 2
93111: PUSH
93112: LD_INT 2
93114: PUSH
93115: EMPTY
93116: LIST
93117: LIST
93118: PUSH
93119: LD_INT 1
93121: PUSH
93122: LD_INT 2
93124: PUSH
93125: EMPTY
93126: LIST
93127: LIST
93128: PUSH
93129: LD_INT 0
93131: PUSH
93132: LD_INT 2
93134: PUSH
93135: EMPTY
93136: LIST
93137: LIST
93138: PUSH
93139: LD_INT 1
93141: NEG
93142: PUSH
93143: LD_INT 1
93145: PUSH
93146: EMPTY
93147: LIST
93148: LIST
93149: PUSH
93150: LD_INT 2
93152: NEG
93153: PUSH
93154: LD_INT 1
93156: NEG
93157: PUSH
93158: EMPTY
93159: LIST
93160: LIST
93161: PUSH
93162: LD_INT 2
93164: NEG
93165: PUSH
93166: LD_INT 2
93168: NEG
93169: PUSH
93170: EMPTY
93171: LIST
93172: LIST
93173: PUSH
93174: LD_INT 2
93176: NEG
93177: PUSH
93178: LD_INT 3
93180: NEG
93181: PUSH
93182: EMPTY
93183: LIST
93184: LIST
93185: PUSH
93186: LD_INT 1
93188: NEG
93189: PUSH
93190: LD_INT 3
93192: NEG
93193: PUSH
93194: EMPTY
93195: LIST
93196: LIST
93197: PUSH
93198: LD_INT 0
93200: PUSH
93201: LD_INT 3
93203: NEG
93204: PUSH
93205: EMPTY
93206: LIST
93207: LIST
93208: PUSH
93209: LD_INT 1
93211: PUSH
93212: LD_INT 2
93214: NEG
93215: PUSH
93216: EMPTY
93217: LIST
93218: LIST
93219: PUSH
93220: LD_INT 3
93222: PUSH
93223: LD_INT 2
93225: PUSH
93226: EMPTY
93227: LIST
93228: LIST
93229: PUSH
93230: LD_INT 3
93232: PUSH
93233: LD_INT 3
93235: PUSH
93236: EMPTY
93237: LIST
93238: LIST
93239: PUSH
93240: LD_INT 2
93242: PUSH
93243: LD_INT 3
93245: PUSH
93246: EMPTY
93247: LIST
93248: LIST
93249: PUSH
93250: LD_INT 1
93252: PUSH
93253: LD_INT 3
93255: PUSH
93256: EMPTY
93257: LIST
93258: LIST
93259: PUSH
93260: LD_INT 0
93262: PUSH
93263: LD_INT 3
93265: PUSH
93266: EMPTY
93267: LIST
93268: LIST
93269: PUSH
93270: LD_INT 1
93272: NEG
93273: PUSH
93274: LD_INT 2
93276: PUSH
93277: EMPTY
93278: LIST
93279: LIST
93280: PUSH
93281: LD_INT 3
93283: NEG
93284: PUSH
93285: LD_INT 2
93287: NEG
93288: PUSH
93289: EMPTY
93290: LIST
93291: LIST
93292: PUSH
93293: LD_INT 3
93295: NEG
93296: PUSH
93297: LD_INT 3
93299: NEG
93300: PUSH
93301: EMPTY
93302: LIST
93303: LIST
93304: PUSH
93305: EMPTY
93306: LIST
93307: LIST
93308: LIST
93309: LIST
93310: LIST
93311: LIST
93312: LIST
93313: LIST
93314: LIST
93315: LIST
93316: LIST
93317: LIST
93318: LIST
93319: LIST
93320: LIST
93321: LIST
93322: LIST
93323: LIST
93324: LIST
93325: LIST
93326: LIST
93327: LIST
93328: LIST
93329: LIST
93330: LIST
93331: LIST
93332: LIST
93333: LIST
93334: LIST
93335: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93336: LD_ADDR_VAR 0 46
93340: PUSH
93341: LD_INT 0
93343: PUSH
93344: LD_INT 0
93346: PUSH
93347: EMPTY
93348: LIST
93349: LIST
93350: PUSH
93351: LD_INT 0
93353: PUSH
93354: LD_INT 1
93356: NEG
93357: PUSH
93358: EMPTY
93359: LIST
93360: LIST
93361: PUSH
93362: LD_INT 1
93364: PUSH
93365: LD_INT 0
93367: PUSH
93368: EMPTY
93369: LIST
93370: LIST
93371: PUSH
93372: LD_INT 1
93374: PUSH
93375: LD_INT 1
93377: PUSH
93378: EMPTY
93379: LIST
93380: LIST
93381: PUSH
93382: LD_INT 0
93384: PUSH
93385: LD_INT 1
93387: PUSH
93388: EMPTY
93389: LIST
93390: LIST
93391: PUSH
93392: LD_INT 1
93394: NEG
93395: PUSH
93396: LD_INT 0
93398: PUSH
93399: EMPTY
93400: LIST
93401: LIST
93402: PUSH
93403: LD_INT 1
93405: NEG
93406: PUSH
93407: LD_INT 1
93409: NEG
93410: PUSH
93411: EMPTY
93412: LIST
93413: LIST
93414: PUSH
93415: LD_INT 1
93417: NEG
93418: PUSH
93419: LD_INT 2
93421: NEG
93422: PUSH
93423: EMPTY
93424: LIST
93425: LIST
93426: PUSH
93427: LD_INT 0
93429: PUSH
93430: LD_INT 2
93432: NEG
93433: PUSH
93434: EMPTY
93435: LIST
93436: LIST
93437: PUSH
93438: LD_INT 1
93440: PUSH
93441: LD_INT 1
93443: NEG
93444: PUSH
93445: EMPTY
93446: LIST
93447: LIST
93448: PUSH
93449: LD_INT 2
93451: PUSH
93452: LD_INT 0
93454: PUSH
93455: EMPTY
93456: LIST
93457: LIST
93458: PUSH
93459: LD_INT 2
93461: PUSH
93462: LD_INT 1
93464: PUSH
93465: EMPTY
93466: LIST
93467: LIST
93468: PUSH
93469: LD_INT 1
93471: PUSH
93472: LD_INT 2
93474: PUSH
93475: EMPTY
93476: LIST
93477: LIST
93478: PUSH
93479: LD_INT 0
93481: PUSH
93482: LD_INT 2
93484: PUSH
93485: EMPTY
93486: LIST
93487: LIST
93488: PUSH
93489: LD_INT 1
93491: NEG
93492: PUSH
93493: LD_INT 1
93495: PUSH
93496: EMPTY
93497: LIST
93498: LIST
93499: PUSH
93500: LD_INT 2
93502: NEG
93503: PUSH
93504: LD_INT 0
93506: PUSH
93507: EMPTY
93508: LIST
93509: LIST
93510: PUSH
93511: LD_INT 2
93513: NEG
93514: PUSH
93515: LD_INT 1
93517: NEG
93518: PUSH
93519: EMPTY
93520: LIST
93521: LIST
93522: PUSH
93523: LD_INT 1
93525: NEG
93526: PUSH
93527: LD_INT 3
93529: NEG
93530: PUSH
93531: EMPTY
93532: LIST
93533: LIST
93534: PUSH
93535: LD_INT 0
93537: PUSH
93538: LD_INT 3
93540: NEG
93541: PUSH
93542: EMPTY
93543: LIST
93544: LIST
93545: PUSH
93546: LD_INT 1
93548: PUSH
93549: LD_INT 2
93551: NEG
93552: PUSH
93553: EMPTY
93554: LIST
93555: LIST
93556: PUSH
93557: LD_INT 2
93559: PUSH
93560: LD_INT 1
93562: NEG
93563: PUSH
93564: EMPTY
93565: LIST
93566: LIST
93567: PUSH
93568: LD_INT 3
93570: PUSH
93571: LD_INT 0
93573: PUSH
93574: EMPTY
93575: LIST
93576: LIST
93577: PUSH
93578: LD_INT 3
93580: PUSH
93581: LD_INT 1
93583: PUSH
93584: EMPTY
93585: LIST
93586: LIST
93587: PUSH
93588: LD_INT 1
93590: PUSH
93591: LD_INT 3
93593: PUSH
93594: EMPTY
93595: LIST
93596: LIST
93597: PUSH
93598: LD_INT 0
93600: PUSH
93601: LD_INT 3
93603: PUSH
93604: EMPTY
93605: LIST
93606: LIST
93607: PUSH
93608: LD_INT 1
93610: NEG
93611: PUSH
93612: LD_INT 2
93614: PUSH
93615: EMPTY
93616: LIST
93617: LIST
93618: PUSH
93619: LD_INT 2
93621: NEG
93622: PUSH
93623: LD_INT 1
93625: PUSH
93626: EMPTY
93627: LIST
93628: LIST
93629: PUSH
93630: LD_INT 3
93632: NEG
93633: PUSH
93634: LD_INT 0
93636: PUSH
93637: EMPTY
93638: LIST
93639: LIST
93640: PUSH
93641: LD_INT 3
93643: NEG
93644: PUSH
93645: LD_INT 1
93647: NEG
93648: PUSH
93649: EMPTY
93650: LIST
93651: LIST
93652: PUSH
93653: EMPTY
93654: LIST
93655: LIST
93656: LIST
93657: LIST
93658: LIST
93659: LIST
93660: LIST
93661: LIST
93662: LIST
93663: LIST
93664: LIST
93665: LIST
93666: LIST
93667: LIST
93668: LIST
93669: LIST
93670: LIST
93671: LIST
93672: LIST
93673: LIST
93674: LIST
93675: LIST
93676: LIST
93677: LIST
93678: LIST
93679: LIST
93680: LIST
93681: LIST
93682: LIST
93683: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93684: LD_ADDR_VAR 0 47
93688: PUSH
93689: LD_INT 0
93691: PUSH
93692: LD_INT 0
93694: PUSH
93695: EMPTY
93696: LIST
93697: LIST
93698: PUSH
93699: LD_INT 0
93701: PUSH
93702: LD_INT 1
93704: NEG
93705: PUSH
93706: EMPTY
93707: LIST
93708: LIST
93709: PUSH
93710: LD_INT 1
93712: PUSH
93713: LD_INT 0
93715: PUSH
93716: EMPTY
93717: LIST
93718: LIST
93719: PUSH
93720: LD_INT 1
93722: PUSH
93723: LD_INT 1
93725: PUSH
93726: EMPTY
93727: LIST
93728: LIST
93729: PUSH
93730: LD_INT 0
93732: PUSH
93733: LD_INT 1
93735: PUSH
93736: EMPTY
93737: LIST
93738: LIST
93739: PUSH
93740: LD_INT 1
93742: NEG
93743: PUSH
93744: LD_INT 0
93746: PUSH
93747: EMPTY
93748: LIST
93749: LIST
93750: PUSH
93751: LD_INT 1
93753: NEG
93754: PUSH
93755: LD_INT 1
93757: NEG
93758: PUSH
93759: EMPTY
93760: LIST
93761: LIST
93762: PUSH
93763: LD_INT 1
93765: NEG
93766: PUSH
93767: LD_INT 2
93769: NEG
93770: PUSH
93771: EMPTY
93772: LIST
93773: LIST
93774: PUSH
93775: LD_INT 0
93777: PUSH
93778: LD_INT 2
93780: NEG
93781: PUSH
93782: EMPTY
93783: LIST
93784: LIST
93785: PUSH
93786: LD_INT 1
93788: PUSH
93789: LD_INT 1
93791: NEG
93792: PUSH
93793: EMPTY
93794: LIST
93795: LIST
93796: PUSH
93797: LD_INT 2
93799: NEG
93800: PUSH
93801: LD_INT 1
93803: NEG
93804: PUSH
93805: EMPTY
93806: LIST
93807: LIST
93808: PUSH
93809: LD_INT 2
93811: NEG
93812: PUSH
93813: LD_INT 2
93815: NEG
93816: PUSH
93817: EMPTY
93818: LIST
93819: LIST
93820: PUSH
93821: EMPTY
93822: LIST
93823: LIST
93824: LIST
93825: LIST
93826: LIST
93827: LIST
93828: LIST
93829: LIST
93830: LIST
93831: LIST
93832: LIST
93833: LIST
93834: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
93835: LD_ADDR_VAR 0 48
93839: PUSH
93840: LD_INT 0
93842: PUSH
93843: LD_INT 0
93845: PUSH
93846: EMPTY
93847: LIST
93848: LIST
93849: PUSH
93850: LD_INT 0
93852: PUSH
93853: LD_INT 1
93855: NEG
93856: PUSH
93857: EMPTY
93858: LIST
93859: LIST
93860: PUSH
93861: LD_INT 1
93863: PUSH
93864: LD_INT 0
93866: PUSH
93867: EMPTY
93868: LIST
93869: LIST
93870: PUSH
93871: LD_INT 1
93873: PUSH
93874: LD_INT 1
93876: PUSH
93877: EMPTY
93878: LIST
93879: LIST
93880: PUSH
93881: LD_INT 0
93883: PUSH
93884: LD_INT 1
93886: PUSH
93887: EMPTY
93888: LIST
93889: LIST
93890: PUSH
93891: LD_INT 1
93893: NEG
93894: PUSH
93895: LD_INT 0
93897: PUSH
93898: EMPTY
93899: LIST
93900: LIST
93901: PUSH
93902: LD_INT 1
93904: NEG
93905: PUSH
93906: LD_INT 1
93908: NEG
93909: PUSH
93910: EMPTY
93911: LIST
93912: LIST
93913: PUSH
93914: LD_INT 1
93916: NEG
93917: PUSH
93918: LD_INT 2
93920: NEG
93921: PUSH
93922: EMPTY
93923: LIST
93924: LIST
93925: PUSH
93926: LD_INT 0
93928: PUSH
93929: LD_INT 2
93931: NEG
93932: PUSH
93933: EMPTY
93934: LIST
93935: LIST
93936: PUSH
93937: LD_INT 1
93939: PUSH
93940: LD_INT 1
93942: NEG
93943: PUSH
93944: EMPTY
93945: LIST
93946: LIST
93947: PUSH
93948: LD_INT 2
93950: PUSH
93951: LD_INT 0
93953: PUSH
93954: EMPTY
93955: LIST
93956: LIST
93957: PUSH
93958: LD_INT 2
93960: PUSH
93961: LD_INT 1
93963: PUSH
93964: EMPTY
93965: LIST
93966: LIST
93967: PUSH
93968: EMPTY
93969: LIST
93970: LIST
93971: LIST
93972: LIST
93973: LIST
93974: LIST
93975: LIST
93976: LIST
93977: LIST
93978: LIST
93979: LIST
93980: LIST
93981: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
93982: LD_ADDR_VAR 0 49
93986: PUSH
93987: LD_INT 0
93989: PUSH
93990: LD_INT 0
93992: PUSH
93993: EMPTY
93994: LIST
93995: LIST
93996: PUSH
93997: LD_INT 0
93999: PUSH
94000: LD_INT 1
94002: NEG
94003: PUSH
94004: EMPTY
94005: LIST
94006: LIST
94007: PUSH
94008: LD_INT 1
94010: PUSH
94011: LD_INT 0
94013: PUSH
94014: EMPTY
94015: LIST
94016: LIST
94017: PUSH
94018: LD_INT 1
94020: PUSH
94021: LD_INT 1
94023: PUSH
94024: EMPTY
94025: LIST
94026: LIST
94027: PUSH
94028: LD_INT 0
94030: PUSH
94031: LD_INT 1
94033: PUSH
94034: EMPTY
94035: LIST
94036: LIST
94037: PUSH
94038: LD_INT 1
94040: NEG
94041: PUSH
94042: LD_INT 0
94044: PUSH
94045: EMPTY
94046: LIST
94047: LIST
94048: PUSH
94049: LD_INT 1
94051: NEG
94052: PUSH
94053: LD_INT 1
94055: NEG
94056: PUSH
94057: EMPTY
94058: LIST
94059: LIST
94060: PUSH
94061: LD_INT 1
94063: PUSH
94064: LD_INT 1
94066: NEG
94067: PUSH
94068: EMPTY
94069: LIST
94070: LIST
94071: PUSH
94072: LD_INT 2
94074: PUSH
94075: LD_INT 0
94077: PUSH
94078: EMPTY
94079: LIST
94080: LIST
94081: PUSH
94082: LD_INT 2
94084: PUSH
94085: LD_INT 1
94087: PUSH
94088: EMPTY
94089: LIST
94090: LIST
94091: PUSH
94092: LD_INT 2
94094: PUSH
94095: LD_INT 2
94097: PUSH
94098: EMPTY
94099: LIST
94100: LIST
94101: PUSH
94102: LD_INT 1
94104: PUSH
94105: LD_INT 2
94107: PUSH
94108: EMPTY
94109: LIST
94110: LIST
94111: PUSH
94112: EMPTY
94113: LIST
94114: LIST
94115: LIST
94116: LIST
94117: LIST
94118: LIST
94119: LIST
94120: LIST
94121: LIST
94122: LIST
94123: LIST
94124: LIST
94125: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94126: LD_ADDR_VAR 0 50
94130: PUSH
94131: LD_INT 0
94133: PUSH
94134: LD_INT 0
94136: PUSH
94137: EMPTY
94138: LIST
94139: LIST
94140: PUSH
94141: LD_INT 0
94143: PUSH
94144: LD_INT 1
94146: NEG
94147: PUSH
94148: EMPTY
94149: LIST
94150: LIST
94151: PUSH
94152: LD_INT 1
94154: PUSH
94155: LD_INT 0
94157: PUSH
94158: EMPTY
94159: LIST
94160: LIST
94161: PUSH
94162: LD_INT 1
94164: PUSH
94165: LD_INT 1
94167: PUSH
94168: EMPTY
94169: LIST
94170: LIST
94171: PUSH
94172: LD_INT 0
94174: PUSH
94175: LD_INT 1
94177: PUSH
94178: EMPTY
94179: LIST
94180: LIST
94181: PUSH
94182: LD_INT 1
94184: NEG
94185: PUSH
94186: LD_INT 0
94188: PUSH
94189: EMPTY
94190: LIST
94191: LIST
94192: PUSH
94193: LD_INT 1
94195: NEG
94196: PUSH
94197: LD_INT 1
94199: NEG
94200: PUSH
94201: EMPTY
94202: LIST
94203: LIST
94204: PUSH
94205: LD_INT 2
94207: PUSH
94208: LD_INT 1
94210: PUSH
94211: EMPTY
94212: LIST
94213: LIST
94214: PUSH
94215: LD_INT 2
94217: PUSH
94218: LD_INT 2
94220: PUSH
94221: EMPTY
94222: LIST
94223: LIST
94224: PUSH
94225: LD_INT 1
94227: PUSH
94228: LD_INT 2
94230: PUSH
94231: EMPTY
94232: LIST
94233: LIST
94234: PUSH
94235: LD_INT 0
94237: PUSH
94238: LD_INT 2
94240: PUSH
94241: EMPTY
94242: LIST
94243: LIST
94244: PUSH
94245: LD_INT 1
94247: NEG
94248: PUSH
94249: LD_INT 1
94251: PUSH
94252: EMPTY
94253: LIST
94254: LIST
94255: PUSH
94256: EMPTY
94257: LIST
94258: LIST
94259: LIST
94260: LIST
94261: LIST
94262: LIST
94263: LIST
94264: LIST
94265: LIST
94266: LIST
94267: LIST
94268: LIST
94269: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94270: LD_ADDR_VAR 0 51
94274: PUSH
94275: LD_INT 0
94277: PUSH
94278: LD_INT 0
94280: PUSH
94281: EMPTY
94282: LIST
94283: LIST
94284: PUSH
94285: LD_INT 0
94287: PUSH
94288: LD_INT 1
94290: NEG
94291: PUSH
94292: EMPTY
94293: LIST
94294: LIST
94295: PUSH
94296: LD_INT 1
94298: PUSH
94299: LD_INT 0
94301: PUSH
94302: EMPTY
94303: LIST
94304: LIST
94305: PUSH
94306: LD_INT 1
94308: PUSH
94309: LD_INT 1
94311: PUSH
94312: EMPTY
94313: LIST
94314: LIST
94315: PUSH
94316: LD_INT 0
94318: PUSH
94319: LD_INT 1
94321: PUSH
94322: EMPTY
94323: LIST
94324: LIST
94325: PUSH
94326: LD_INT 1
94328: NEG
94329: PUSH
94330: LD_INT 0
94332: PUSH
94333: EMPTY
94334: LIST
94335: LIST
94336: PUSH
94337: LD_INT 1
94339: NEG
94340: PUSH
94341: LD_INT 1
94343: NEG
94344: PUSH
94345: EMPTY
94346: LIST
94347: LIST
94348: PUSH
94349: LD_INT 1
94351: PUSH
94352: LD_INT 2
94354: PUSH
94355: EMPTY
94356: LIST
94357: LIST
94358: PUSH
94359: LD_INT 0
94361: PUSH
94362: LD_INT 2
94364: PUSH
94365: EMPTY
94366: LIST
94367: LIST
94368: PUSH
94369: LD_INT 1
94371: NEG
94372: PUSH
94373: LD_INT 1
94375: PUSH
94376: EMPTY
94377: LIST
94378: LIST
94379: PUSH
94380: LD_INT 2
94382: NEG
94383: PUSH
94384: LD_INT 0
94386: PUSH
94387: EMPTY
94388: LIST
94389: LIST
94390: PUSH
94391: LD_INT 2
94393: NEG
94394: PUSH
94395: LD_INT 1
94397: NEG
94398: PUSH
94399: EMPTY
94400: LIST
94401: LIST
94402: PUSH
94403: EMPTY
94404: LIST
94405: LIST
94406: LIST
94407: LIST
94408: LIST
94409: LIST
94410: LIST
94411: LIST
94412: LIST
94413: LIST
94414: LIST
94415: LIST
94416: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94417: LD_ADDR_VAR 0 52
94421: PUSH
94422: LD_INT 0
94424: PUSH
94425: LD_INT 0
94427: PUSH
94428: EMPTY
94429: LIST
94430: LIST
94431: PUSH
94432: LD_INT 0
94434: PUSH
94435: LD_INT 1
94437: NEG
94438: PUSH
94439: EMPTY
94440: LIST
94441: LIST
94442: PUSH
94443: LD_INT 1
94445: PUSH
94446: LD_INT 0
94448: PUSH
94449: EMPTY
94450: LIST
94451: LIST
94452: PUSH
94453: LD_INT 1
94455: PUSH
94456: LD_INT 1
94458: PUSH
94459: EMPTY
94460: LIST
94461: LIST
94462: PUSH
94463: LD_INT 0
94465: PUSH
94466: LD_INT 1
94468: PUSH
94469: EMPTY
94470: LIST
94471: LIST
94472: PUSH
94473: LD_INT 1
94475: NEG
94476: PUSH
94477: LD_INT 0
94479: PUSH
94480: EMPTY
94481: LIST
94482: LIST
94483: PUSH
94484: LD_INT 1
94486: NEG
94487: PUSH
94488: LD_INT 1
94490: NEG
94491: PUSH
94492: EMPTY
94493: LIST
94494: LIST
94495: PUSH
94496: LD_INT 1
94498: NEG
94499: PUSH
94500: LD_INT 2
94502: NEG
94503: PUSH
94504: EMPTY
94505: LIST
94506: LIST
94507: PUSH
94508: LD_INT 1
94510: NEG
94511: PUSH
94512: LD_INT 1
94514: PUSH
94515: EMPTY
94516: LIST
94517: LIST
94518: PUSH
94519: LD_INT 2
94521: NEG
94522: PUSH
94523: LD_INT 0
94525: PUSH
94526: EMPTY
94527: LIST
94528: LIST
94529: PUSH
94530: LD_INT 2
94532: NEG
94533: PUSH
94534: LD_INT 1
94536: NEG
94537: PUSH
94538: EMPTY
94539: LIST
94540: LIST
94541: PUSH
94542: LD_INT 2
94544: NEG
94545: PUSH
94546: LD_INT 2
94548: NEG
94549: PUSH
94550: EMPTY
94551: LIST
94552: LIST
94553: PUSH
94554: EMPTY
94555: LIST
94556: LIST
94557: LIST
94558: LIST
94559: LIST
94560: LIST
94561: LIST
94562: LIST
94563: LIST
94564: LIST
94565: LIST
94566: LIST
94567: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94568: LD_ADDR_VAR 0 53
94572: PUSH
94573: LD_INT 0
94575: PUSH
94576: LD_INT 0
94578: PUSH
94579: EMPTY
94580: LIST
94581: LIST
94582: PUSH
94583: LD_INT 0
94585: PUSH
94586: LD_INT 1
94588: NEG
94589: PUSH
94590: EMPTY
94591: LIST
94592: LIST
94593: PUSH
94594: LD_INT 1
94596: PUSH
94597: LD_INT 0
94599: PUSH
94600: EMPTY
94601: LIST
94602: LIST
94603: PUSH
94604: LD_INT 1
94606: PUSH
94607: LD_INT 1
94609: PUSH
94610: EMPTY
94611: LIST
94612: LIST
94613: PUSH
94614: LD_INT 0
94616: PUSH
94617: LD_INT 1
94619: PUSH
94620: EMPTY
94621: LIST
94622: LIST
94623: PUSH
94624: LD_INT 1
94626: NEG
94627: PUSH
94628: LD_INT 0
94630: PUSH
94631: EMPTY
94632: LIST
94633: LIST
94634: PUSH
94635: LD_INT 1
94637: NEG
94638: PUSH
94639: LD_INT 1
94641: NEG
94642: PUSH
94643: EMPTY
94644: LIST
94645: LIST
94646: PUSH
94647: LD_INT 1
94649: NEG
94650: PUSH
94651: LD_INT 2
94653: NEG
94654: PUSH
94655: EMPTY
94656: LIST
94657: LIST
94658: PUSH
94659: LD_INT 0
94661: PUSH
94662: LD_INT 2
94664: NEG
94665: PUSH
94666: EMPTY
94667: LIST
94668: LIST
94669: PUSH
94670: LD_INT 1
94672: PUSH
94673: LD_INT 1
94675: NEG
94676: PUSH
94677: EMPTY
94678: LIST
94679: LIST
94680: PUSH
94681: LD_INT 2
94683: PUSH
94684: LD_INT 0
94686: PUSH
94687: EMPTY
94688: LIST
94689: LIST
94690: PUSH
94691: LD_INT 2
94693: PUSH
94694: LD_INT 1
94696: PUSH
94697: EMPTY
94698: LIST
94699: LIST
94700: PUSH
94701: LD_INT 2
94703: PUSH
94704: LD_INT 2
94706: PUSH
94707: EMPTY
94708: LIST
94709: LIST
94710: PUSH
94711: LD_INT 1
94713: PUSH
94714: LD_INT 2
94716: PUSH
94717: EMPTY
94718: LIST
94719: LIST
94720: PUSH
94721: LD_INT 0
94723: PUSH
94724: LD_INT 2
94726: PUSH
94727: EMPTY
94728: LIST
94729: LIST
94730: PUSH
94731: LD_INT 1
94733: NEG
94734: PUSH
94735: LD_INT 1
94737: PUSH
94738: EMPTY
94739: LIST
94740: LIST
94741: PUSH
94742: LD_INT 2
94744: NEG
94745: PUSH
94746: LD_INT 0
94748: PUSH
94749: EMPTY
94750: LIST
94751: LIST
94752: PUSH
94753: LD_INT 2
94755: NEG
94756: PUSH
94757: LD_INT 1
94759: NEG
94760: PUSH
94761: EMPTY
94762: LIST
94763: LIST
94764: PUSH
94765: LD_INT 2
94767: NEG
94768: PUSH
94769: LD_INT 2
94771: NEG
94772: PUSH
94773: EMPTY
94774: LIST
94775: LIST
94776: PUSH
94777: EMPTY
94778: LIST
94779: LIST
94780: LIST
94781: LIST
94782: LIST
94783: LIST
94784: LIST
94785: LIST
94786: LIST
94787: LIST
94788: LIST
94789: LIST
94790: LIST
94791: LIST
94792: LIST
94793: LIST
94794: LIST
94795: LIST
94796: LIST
94797: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94798: LD_ADDR_VAR 0 54
94802: PUSH
94803: LD_INT 0
94805: PUSH
94806: LD_INT 0
94808: PUSH
94809: EMPTY
94810: LIST
94811: LIST
94812: PUSH
94813: LD_INT 0
94815: PUSH
94816: LD_INT 1
94818: NEG
94819: PUSH
94820: EMPTY
94821: LIST
94822: LIST
94823: PUSH
94824: LD_INT 1
94826: PUSH
94827: LD_INT 0
94829: PUSH
94830: EMPTY
94831: LIST
94832: LIST
94833: PUSH
94834: LD_INT 1
94836: PUSH
94837: LD_INT 1
94839: PUSH
94840: EMPTY
94841: LIST
94842: LIST
94843: PUSH
94844: LD_INT 0
94846: PUSH
94847: LD_INT 1
94849: PUSH
94850: EMPTY
94851: LIST
94852: LIST
94853: PUSH
94854: LD_INT 1
94856: NEG
94857: PUSH
94858: LD_INT 0
94860: PUSH
94861: EMPTY
94862: LIST
94863: LIST
94864: PUSH
94865: LD_INT 1
94867: NEG
94868: PUSH
94869: LD_INT 1
94871: NEG
94872: PUSH
94873: EMPTY
94874: LIST
94875: LIST
94876: PUSH
94877: LD_INT 1
94879: NEG
94880: PUSH
94881: LD_INT 2
94883: NEG
94884: PUSH
94885: EMPTY
94886: LIST
94887: LIST
94888: PUSH
94889: LD_INT 0
94891: PUSH
94892: LD_INT 2
94894: NEG
94895: PUSH
94896: EMPTY
94897: LIST
94898: LIST
94899: PUSH
94900: LD_INT 1
94902: PUSH
94903: LD_INT 1
94905: NEG
94906: PUSH
94907: EMPTY
94908: LIST
94909: LIST
94910: PUSH
94911: LD_INT 2
94913: PUSH
94914: LD_INT 0
94916: PUSH
94917: EMPTY
94918: LIST
94919: LIST
94920: PUSH
94921: LD_INT 2
94923: PUSH
94924: LD_INT 1
94926: PUSH
94927: EMPTY
94928: LIST
94929: LIST
94930: PUSH
94931: LD_INT 2
94933: PUSH
94934: LD_INT 2
94936: PUSH
94937: EMPTY
94938: LIST
94939: LIST
94940: PUSH
94941: LD_INT 1
94943: PUSH
94944: LD_INT 2
94946: PUSH
94947: EMPTY
94948: LIST
94949: LIST
94950: PUSH
94951: LD_INT 0
94953: PUSH
94954: LD_INT 2
94956: PUSH
94957: EMPTY
94958: LIST
94959: LIST
94960: PUSH
94961: LD_INT 1
94963: NEG
94964: PUSH
94965: LD_INT 1
94967: PUSH
94968: EMPTY
94969: LIST
94970: LIST
94971: PUSH
94972: LD_INT 2
94974: NEG
94975: PUSH
94976: LD_INT 0
94978: PUSH
94979: EMPTY
94980: LIST
94981: LIST
94982: PUSH
94983: LD_INT 2
94985: NEG
94986: PUSH
94987: LD_INT 1
94989: NEG
94990: PUSH
94991: EMPTY
94992: LIST
94993: LIST
94994: PUSH
94995: LD_INT 2
94997: NEG
94998: PUSH
94999: LD_INT 2
95001: NEG
95002: PUSH
95003: EMPTY
95004: LIST
95005: LIST
95006: PUSH
95007: EMPTY
95008: LIST
95009: LIST
95010: LIST
95011: LIST
95012: LIST
95013: LIST
95014: LIST
95015: LIST
95016: LIST
95017: LIST
95018: LIST
95019: LIST
95020: LIST
95021: LIST
95022: LIST
95023: LIST
95024: LIST
95025: LIST
95026: LIST
95027: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95028: LD_ADDR_VAR 0 55
95032: PUSH
95033: LD_INT 0
95035: PUSH
95036: LD_INT 0
95038: PUSH
95039: EMPTY
95040: LIST
95041: LIST
95042: PUSH
95043: LD_INT 0
95045: PUSH
95046: LD_INT 1
95048: NEG
95049: PUSH
95050: EMPTY
95051: LIST
95052: LIST
95053: PUSH
95054: LD_INT 1
95056: PUSH
95057: LD_INT 0
95059: PUSH
95060: EMPTY
95061: LIST
95062: LIST
95063: PUSH
95064: LD_INT 1
95066: PUSH
95067: LD_INT 1
95069: PUSH
95070: EMPTY
95071: LIST
95072: LIST
95073: PUSH
95074: LD_INT 0
95076: PUSH
95077: LD_INT 1
95079: PUSH
95080: EMPTY
95081: LIST
95082: LIST
95083: PUSH
95084: LD_INT 1
95086: NEG
95087: PUSH
95088: LD_INT 0
95090: PUSH
95091: EMPTY
95092: LIST
95093: LIST
95094: PUSH
95095: LD_INT 1
95097: NEG
95098: PUSH
95099: LD_INT 1
95101: NEG
95102: PUSH
95103: EMPTY
95104: LIST
95105: LIST
95106: PUSH
95107: LD_INT 1
95109: NEG
95110: PUSH
95111: LD_INT 2
95113: NEG
95114: PUSH
95115: EMPTY
95116: LIST
95117: LIST
95118: PUSH
95119: LD_INT 0
95121: PUSH
95122: LD_INT 2
95124: NEG
95125: PUSH
95126: EMPTY
95127: LIST
95128: LIST
95129: PUSH
95130: LD_INT 1
95132: PUSH
95133: LD_INT 1
95135: NEG
95136: PUSH
95137: EMPTY
95138: LIST
95139: LIST
95140: PUSH
95141: LD_INT 2
95143: PUSH
95144: LD_INT 0
95146: PUSH
95147: EMPTY
95148: LIST
95149: LIST
95150: PUSH
95151: LD_INT 2
95153: PUSH
95154: LD_INT 1
95156: PUSH
95157: EMPTY
95158: LIST
95159: LIST
95160: PUSH
95161: LD_INT 2
95163: PUSH
95164: LD_INT 2
95166: PUSH
95167: EMPTY
95168: LIST
95169: LIST
95170: PUSH
95171: LD_INT 1
95173: PUSH
95174: LD_INT 2
95176: PUSH
95177: EMPTY
95178: LIST
95179: LIST
95180: PUSH
95181: LD_INT 0
95183: PUSH
95184: LD_INT 2
95186: PUSH
95187: EMPTY
95188: LIST
95189: LIST
95190: PUSH
95191: LD_INT 1
95193: NEG
95194: PUSH
95195: LD_INT 1
95197: PUSH
95198: EMPTY
95199: LIST
95200: LIST
95201: PUSH
95202: LD_INT 2
95204: NEG
95205: PUSH
95206: LD_INT 0
95208: PUSH
95209: EMPTY
95210: LIST
95211: LIST
95212: PUSH
95213: LD_INT 2
95215: NEG
95216: PUSH
95217: LD_INT 1
95219: NEG
95220: PUSH
95221: EMPTY
95222: LIST
95223: LIST
95224: PUSH
95225: LD_INT 2
95227: NEG
95228: PUSH
95229: LD_INT 2
95231: NEG
95232: PUSH
95233: EMPTY
95234: LIST
95235: LIST
95236: PUSH
95237: EMPTY
95238: LIST
95239: LIST
95240: LIST
95241: LIST
95242: LIST
95243: LIST
95244: LIST
95245: LIST
95246: LIST
95247: LIST
95248: LIST
95249: LIST
95250: LIST
95251: LIST
95252: LIST
95253: LIST
95254: LIST
95255: LIST
95256: LIST
95257: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95258: LD_ADDR_VAR 0 56
95262: PUSH
95263: LD_INT 0
95265: PUSH
95266: LD_INT 0
95268: PUSH
95269: EMPTY
95270: LIST
95271: LIST
95272: PUSH
95273: LD_INT 0
95275: PUSH
95276: LD_INT 1
95278: NEG
95279: PUSH
95280: EMPTY
95281: LIST
95282: LIST
95283: PUSH
95284: LD_INT 1
95286: PUSH
95287: LD_INT 0
95289: PUSH
95290: EMPTY
95291: LIST
95292: LIST
95293: PUSH
95294: LD_INT 1
95296: PUSH
95297: LD_INT 1
95299: PUSH
95300: EMPTY
95301: LIST
95302: LIST
95303: PUSH
95304: LD_INT 0
95306: PUSH
95307: LD_INT 1
95309: PUSH
95310: EMPTY
95311: LIST
95312: LIST
95313: PUSH
95314: LD_INT 1
95316: NEG
95317: PUSH
95318: LD_INT 0
95320: PUSH
95321: EMPTY
95322: LIST
95323: LIST
95324: PUSH
95325: LD_INT 1
95327: NEG
95328: PUSH
95329: LD_INT 1
95331: NEG
95332: PUSH
95333: EMPTY
95334: LIST
95335: LIST
95336: PUSH
95337: LD_INT 1
95339: NEG
95340: PUSH
95341: LD_INT 2
95343: NEG
95344: PUSH
95345: EMPTY
95346: LIST
95347: LIST
95348: PUSH
95349: LD_INT 0
95351: PUSH
95352: LD_INT 2
95354: NEG
95355: PUSH
95356: EMPTY
95357: LIST
95358: LIST
95359: PUSH
95360: LD_INT 1
95362: PUSH
95363: LD_INT 1
95365: NEG
95366: PUSH
95367: EMPTY
95368: LIST
95369: LIST
95370: PUSH
95371: LD_INT 2
95373: PUSH
95374: LD_INT 0
95376: PUSH
95377: EMPTY
95378: LIST
95379: LIST
95380: PUSH
95381: LD_INT 2
95383: PUSH
95384: LD_INT 1
95386: PUSH
95387: EMPTY
95388: LIST
95389: LIST
95390: PUSH
95391: LD_INT 2
95393: PUSH
95394: LD_INT 2
95396: PUSH
95397: EMPTY
95398: LIST
95399: LIST
95400: PUSH
95401: LD_INT 1
95403: PUSH
95404: LD_INT 2
95406: PUSH
95407: EMPTY
95408: LIST
95409: LIST
95410: PUSH
95411: LD_INT 0
95413: PUSH
95414: LD_INT 2
95416: PUSH
95417: EMPTY
95418: LIST
95419: LIST
95420: PUSH
95421: LD_INT 1
95423: NEG
95424: PUSH
95425: LD_INT 1
95427: PUSH
95428: EMPTY
95429: LIST
95430: LIST
95431: PUSH
95432: LD_INT 2
95434: NEG
95435: PUSH
95436: LD_INT 0
95438: PUSH
95439: EMPTY
95440: LIST
95441: LIST
95442: PUSH
95443: LD_INT 2
95445: NEG
95446: PUSH
95447: LD_INT 1
95449: NEG
95450: PUSH
95451: EMPTY
95452: LIST
95453: LIST
95454: PUSH
95455: LD_INT 2
95457: NEG
95458: PUSH
95459: LD_INT 2
95461: NEG
95462: PUSH
95463: EMPTY
95464: LIST
95465: LIST
95466: PUSH
95467: EMPTY
95468: LIST
95469: LIST
95470: LIST
95471: LIST
95472: LIST
95473: LIST
95474: LIST
95475: LIST
95476: LIST
95477: LIST
95478: LIST
95479: LIST
95480: LIST
95481: LIST
95482: LIST
95483: LIST
95484: LIST
95485: LIST
95486: LIST
95487: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95488: LD_ADDR_VAR 0 57
95492: PUSH
95493: LD_INT 0
95495: PUSH
95496: LD_INT 0
95498: PUSH
95499: EMPTY
95500: LIST
95501: LIST
95502: PUSH
95503: LD_INT 0
95505: PUSH
95506: LD_INT 1
95508: NEG
95509: PUSH
95510: EMPTY
95511: LIST
95512: LIST
95513: PUSH
95514: LD_INT 1
95516: PUSH
95517: LD_INT 0
95519: PUSH
95520: EMPTY
95521: LIST
95522: LIST
95523: PUSH
95524: LD_INT 1
95526: PUSH
95527: LD_INT 1
95529: PUSH
95530: EMPTY
95531: LIST
95532: LIST
95533: PUSH
95534: LD_INT 0
95536: PUSH
95537: LD_INT 1
95539: PUSH
95540: EMPTY
95541: LIST
95542: LIST
95543: PUSH
95544: LD_INT 1
95546: NEG
95547: PUSH
95548: LD_INT 0
95550: PUSH
95551: EMPTY
95552: LIST
95553: LIST
95554: PUSH
95555: LD_INT 1
95557: NEG
95558: PUSH
95559: LD_INT 1
95561: NEG
95562: PUSH
95563: EMPTY
95564: LIST
95565: LIST
95566: PUSH
95567: LD_INT 1
95569: NEG
95570: PUSH
95571: LD_INT 2
95573: NEG
95574: PUSH
95575: EMPTY
95576: LIST
95577: LIST
95578: PUSH
95579: LD_INT 0
95581: PUSH
95582: LD_INT 2
95584: NEG
95585: PUSH
95586: EMPTY
95587: LIST
95588: LIST
95589: PUSH
95590: LD_INT 1
95592: PUSH
95593: LD_INT 1
95595: NEG
95596: PUSH
95597: EMPTY
95598: LIST
95599: LIST
95600: PUSH
95601: LD_INT 2
95603: PUSH
95604: LD_INT 0
95606: PUSH
95607: EMPTY
95608: LIST
95609: LIST
95610: PUSH
95611: LD_INT 2
95613: PUSH
95614: LD_INT 1
95616: PUSH
95617: EMPTY
95618: LIST
95619: LIST
95620: PUSH
95621: LD_INT 2
95623: PUSH
95624: LD_INT 2
95626: PUSH
95627: EMPTY
95628: LIST
95629: LIST
95630: PUSH
95631: LD_INT 1
95633: PUSH
95634: LD_INT 2
95636: PUSH
95637: EMPTY
95638: LIST
95639: LIST
95640: PUSH
95641: LD_INT 0
95643: PUSH
95644: LD_INT 2
95646: PUSH
95647: EMPTY
95648: LIST
95649: LIST
95650: PUSH
95651: LD_INT 1
95653: NEG
95654: PUSH
95655: LD_INT 1
95657: PUSH
95658: EMPTY
95659: LIST
95660: LIST
95661: PUSH
95662: LD_INT 2
95664: NEG
95665: PUSH
95666: LD_INT 0
95668: PUSH
95669: EMPTY
95670: LIST
95671: LIST
95672: PUSH
95673: LD_INT 2
95675: NEG
95676: PUSH
95677: LD_INT 1
95679: NEG
95680: PUSH
95681: EMPTY
95682: LIST
95683: LIST
95684: PUSH
95685: LD_INT 2
95687: NEG
95688: PUSH
95689: LD_INT 2
95691: NEG
95692: PUSH
95693: EMPTY
95694: LIST
95695: LIST
95696: PUSH
95697: EMPTY
95698: LIST
95699: LIST
95700: LIST
95701: LIST
95702: LIST
95703: LIST
95704: LIST
95705: LIST
95706: LIST
95707: LIST
95708: LIST
95709: LIST
95710: LIST
95711: LIST
95712: LIST
95713: LIST
95714: LIST
95715: LIST
95716: LIST
95717: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95718: LD_ADDR_VAR 0 58
95722: PUSH
95723: LD_INT 0
95725: PUSH
95726: LD_INT 0
95728: PUSH
95729: EMPTY
95730: LIST
95731: LIST
95732: PUSH
95733: LD_INT 0
95735: PUSH
95736: LD_INT 1
95738: NEG
95739: PUSH
95740: EMPTY
95741: LIST
95742: LIST
95743: PUSH
95744: LD_INT 1
95746: PUSH
95747: LD_INT 0
95749: PUSH
95750: EMPTY
95751: LIST
95752: LIST
95753: PUSH
95754: LD_INT 1
95756: PUSH
95757: LD_INT 1
95759: PUSH
95760: EMPTY
95761: LIST
95762: LIST
95763: PUSH
95764: LD_INT 0
95766: PUSH
95767: LD_INT 1
95769: PUSH
95770: EMPTY
95771: LIST
95772: LIST
95773: PUSH
95774: LD_INT 1
95776: NEG
95777: PUSH
95778: LD_INT 0
95780: PUSH
95781: EMPTY
95782: LIST
95783: LIST
95784: PUSH
95785: LD_INT 1
95787: NEG
95788: PUSH
95789: LD_INT 1
95791: NEG
95792: PUSH
95793: EMPTY
95794: LIST
95795: LIST
95796: PUSH
95797: LD_INT 1
95799: NEG
95800: PUSH
95801: LD_INT 2
95803: NEG
95804: PUSH
95805: EMPTY
95806: LIST
95807: LIST
95808: PUSH
95809: LD_INT 0
95811: PUSH
95812: LD_INT 2
95814: NEG
95815: PUSH
95816: EMPTY
95817: LIST
95818: LIST
95819: PUSH
95820: LD_INT 1
95822: PUSH
95823: LD_INT 1
95825: NEG
95826: PUSH
95827: EMPTY
95828: LIST
95829: LIST
95830: PUSH
95831: LD_INT 2
95833: PUSH
95834: LD_INT 0
95836: PUSH
95837: EMPTY
95838: LIST
95839: LIST
95840: PUSH
95841: LD_INT 2
95843: PUSH
95844: LD_INT 1
95846: PUSH
95847: EMPTY
95848: LIST
95849: LIST
95850: PUSH
95851: LD_INT 2
95853: PUSH
95854: LD_INT 2
95856: PUSH
95857: EMPTY
95858: LIST
95859: LIST
95860: PUSH
95861: LD_INT 1
95863: PUSH
95864: LD_INT 2
95866: PUSH
95867: EMPTY
95868: LIST
95869: LIST
95870: PUSH
95871: LD_INT 0
95873: PUSH
95874: LD_INT 2
95876: PUSH
95877: EMPTY
95878: LIST
95879: LIST
95880: PUSH
95881: LD_INT 1
95883: NEG
95884: PUSH
95885: LD_INT 1
95887: PUSH
95888: EMPTY
95889: LIST
95890: LIST
95891: PUSH
95892: LD_INT 2
95894: NEG
95895: PUSH
95896: LD_INT 0
95898: PUSH
95899: EMPTY
95900: LIST
95901: LIST
95902: PUSH
95903: LD_INT 2
95905: NEG
95906: PUSH
95907: LD_INT 1
95909: NEG
95910: PUSH
95911: EMPTY
95912: LIST
95913: LIST
95914: PUSH
95915: LD_INT 2
95917: NEG
95918: PUSH
95919: LD_INT 2
95921: NEG
95922: PUSH
95923: EMPTY
95924: LIST
95925: LIST
95926: PUSH
95927: EMPTY
95928: LIST
95929: LIST
95930: LIST
95931: LIST
95932: LIST
95933: LIST
95934: LIST
95935: LIST
95936: LIST
95937: LIST
95938: LIST
95939: LIST
95940: LIST
95941: LIST
95942: LIST
95943: LIST
95944: LIST
95945: LIST
95946: LIST
95947: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95948: LD_ADDR_VAR 0 59
95952: PUSH
95953: LD_INT 0
95955: PUSH
95956: LD_INT 0
95958: PUSH
95959: EMPTY
95960: LIST
95961: LIST
95962: PUSH
95963: LD_INT 0
95965: PUSH
95966: LD_INT 1
95968: NEG
95969: PUSH
95970: EMPTY
95971: LIST
95972: LIST
95973: PUSH
95974: LD_INT 1
95976: PUSH
95977: LD_INT 0
95979: PUSH
95980: EMPTY
95981: LIST
95982: LIST
95983: PUSH
95984: LD_INT 1
95986: PUSH
95987: LD_INT 1
95989: PUSH
95990: EMPTY
95991: LIST
95992: LIST
95993: PUSH
95994: LD_INT 0
95996: PUSH
95997: LD_INT 1
95999: PUSH
96000: EMPTY
96001: LIST
96002: LIST
96003: PUSH
96004: LD_INT 1
96006: NEG
96007: PUSH
96008: LD_INT 0
96010: PUSH
96011: EMPTY
96012: LIST
96013: LIST
96014: PUSH
96015: LD_INT 1
96017: NEG
96018: PUSH
96019: LD_INT 1
96021: NEG
96022: PUSH
96023: EMPTY
96024: LIST
96025: LIST
96026: PUSH
96027: EMPTY
96028: LIST
96029: LIST
96030: LIST
96031: LIST
96032: LIST
96033: LIST
96034: LIST
96035: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96036: LD_ADDR_VAR 0 60
96040: PUSH
96041: LD_INT 0
96043: PUSH
96044: LD_INT 0
96046: PUSH
96047: EMPTY
96048: LIST
96049: LIST
96050: PUSH
96051: LD_INT 0
96053: PUSH
96054: LD_INT 1
96056: NEG
96057: PUSH
96058: EMPTY
96059: LIST
96060: LIST
96061: PUSH
96062: LD_INT 1
96064: PUSH
96065: LD_INT 0
96067: PUSH
96068: EMPTY
96069: LIST
96070: LIST
96071: PUSH
96072: LD_INT 1
96074: PUSH
96075: LD_INT 1
96077: PUSH
96078: EMPTY
96079: LIST
96080: LIST
96081: PUSH
96082: LD_INT 0
96084: PUSH
96085: LD_INT 1
96087: PUSH
96088: EMPTY
96089: LIST
96090: LIST
96091: PUSH
96092: LD_INT 1
96094: NEG
96095: PUSH
96096: LD_INT 0
96098: PUSH
96099: EMPTY
96100: LIST
96101: LIST
96102: PUSH
96103: LD_INT 1
96105: NEG
96106: PUSH
96107: LD_INT 1
96109: NEG
96110: PUSH
96111: EMPTY
96112: LIST
96113: LIST
96114: PUSH
96115: EMPTY
96116: LIST
96117: LIST
96118: LIST
96119: LIST
96120: LIST
96121: LIST
96122: LIST
96123: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96124: LD_ADDR_VAR 0 61
96128: PUSH
96129: LD_INT 0
96131: PUSH
96132: LD_INT 0
96134: PUSH
96135: EMPTY
96136: LIST
96137: LIST
96138: PUSH
96139: LD_INT 0
96141: PUSH
96142: LD_INT 1
96144: NEG
96145: PUSH
96146: EMPTY
96147: LIST
96148: LIST
96149: PUSH
96150: LD_INT 1
96152: PUSH
96153: LD_INT 0
96155: PUSH
96156: EMPTY
96157: LIST
96158: LIST
96159: PUSH
96160: LD_INT 1
96162: PUSH
96163: LD_INT 1
96165: PUSH
96166: EMPTY
96167: LIST
96168: LIST
96169: PUSH
96170: LD_INT 0
96172: PUSH
96173: LD_INT 1
96175: PUSH
96176: EMPTY
96177: LIST
96178: LIST
96179: PUSH
96180: LD_INT 1
96182: NEG
96183: PUSH
96184: LD_INT 0
96186: PUSH
96187: EMPTY
96188: LIST
96189: LIST
96190: PUSH
96191: LD_INT 1
96193: NEG
96194: PUSH
96195: LD_INT 1
96197: NEG
96198: PUSH
96199: EMPTY
96200: LIST
96201: LIST
96202: PUSH
96203: EMPTY
96204: LIST
96205: LIST
96206: LIST
96207: LIST
96208: LIST
96209: LIST
96210: LIST
96211: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96212: LD_ADDR_VAR 0 62
96216: PUSH
96217: LD_INT 0
96219: PUSH
96220: LD_INT 0
96222: PUSH
96223: EMPTY
96224: LIST
96225: LIST
96226: PUSH
96227: LD_INT 0
96229: PUSH
96230: LD_INT 1
96232: NEG
96233: PUSH
96234: EMPTY
96235: LIST
96236: LIST
96237: PUSH
96238: LD_INT 1
96240: PUSH
96241: LD_INT 0
96243: PUSH
96244: EMPTY
96245: LIST
96246: LIST
96247: PUSH
96248: LD_INT 1
96250: PUSH
96251: LD_INT 1
96253: PUSH
96254: EMPTY
96255: LIST
96256: LIST
96257: PUSH
96258: LD_INT 0
96260: PUSH
96261: LD_INT 1
96263: PUSH
96264: EMPTY
96265: LIST
96266: LIST
96267: PUSH
96268: LD_INT 1
96270: NEG
96271: PUSH
96272: LD_INT 0
96274: PUSH
96275: EMPTY
96276: LIST
96277: LIST
96278: PUSH
96279: LD_INT 1
96281: NEG
96282: PUSH
96283: LD_INT 1
96285: NEG
96286: PUSH
96287: EMPTY
96288: LIST
96289: LIST
96290: PUSH
96291: EMPTY
96292: LIST
96293: LIST
96294: LIST
96295: LIST
96296: LIST
96297: LIST
96298: LIST
96299: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96300: LD_ADDR_VAR 0 63
96304: PUSH
96305: LD_INT 0
96307: PUSH
96308: LD_INT 0
96310: PUSH
96311: EMPTY
96312: LIST
96313: LIST
96314: PUSH
96315: LD_INT 0
96317: PUSH
96318: LD_INT 1
96320: NEG
96321: PUSH
96322: EMPTY
96323: LIST
96324: LIST
96325: PUSH
96326: LD_INT 1
96328: PUSH
96329: LD_INT 0
96331: PUSH
96332: EMPTY
96333: LIST
96334: LIST
96335: PUSH
96336: LD_INT 1
96338: PUSH
96339: LD_INT 1
96341: PUSH
96342: EMPTY
96343: LIST
96344: LIST
96345: PUSH
96346: LD_INT 0
96348: PUSH
96349: LD_INT 1
96351: PUSH
96352: EMPTY
96353: LIST
96354: LIST
96355: PUSH
96356: LD_INT 1
96358: NEG
96359: PUSH
96360: LD_INT 0
96362: PUSH
96363: EMPTY
96364: LIST
96365: LIST
96366: PUSH
96367: LD_INT 1
96369: NEG
96370: PUSH
96371: LD_INT 1
96373: NEG
96374: PUSH
96375: EMPTY
96376: LIST
96377: LIST
96378: PUSH
96379: EMPTY
96380: LIST
96381: LIST
96382: LIST
96383: LIST
96384: LIST
96385: LIST
96386: LIST
96387: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96388: LD_ADDR_VAR 0 64
96392: PUSH
96393: LD_INT 0
96395: PUSH
96396: LD_INT 0
96398: PUSH
96399: EMPTY
96400: LIST
96401: LIST
96402: PUSH
96403: LD_INT 0
96405: PUSH
96406: LD_INT 1
96408: NEG
96409: PUSH
96410: EMPTY
96411: LIST
96412: LIST
96413: PUSH
96414: LD_INT 1
96416: PUSH
96417: LD_INT 0
96419: PUSH
96420: EMPTY
96421: LIST
96422: LIST
96423: PUSH
96424: LD_INT 1
96426: PUSH
96427: LD_INT 1
96429: PUSH
96430: EMPTY
96431: LIST
96432: LIST
96433: PUSH
96434: LD_INT 0
96436: PUSH
96437: LD_INT 1
96439: PUSH
96440: EMPTY
96441: LIST
96442: LIST
96443: PUSH
96444: LD_INT 1
96446: NEG
96447: PUSH
96448: LD_INT 0
96450: PUSH
96451: EMPTY
96452: LIST
96453: LIST
96454: PUSH
96455: LD_INT 1
96457: NEG
96458: PUSH
96459: LD_INT 1
96461: NEG
96462: PUSH
96463: EMPTY
96464: LIST
96465: LIST
96466: PUSH
96467: EMPTY
96468: LIST
96469: LIST
96470: LIST
96471: LIST
96472: LIST
96473: LIST
96474: LIST
96475: ST_TO_ADDR
// end ; 1 :
96476: GO 102373
96478: LD_INT 1
96480: DOUBLE
96481: EQUAL
96482: IFTRUE 96486
96484: GO 99109
96486: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
96487: LD_ADDR_VAR 0 11
96491: PUSH
96492: LD_INT 1
96494: NEG
96495: PUSH
96496: LD_INT 3
96498: NEG
96499: PUSH
96500: EMPTY
96501: LIST
96502: LIST
96503: PUSH
96504: LD_INT 0
96506: PUSH
96507: LD_INT 3
96509: NEG
96510: PUSH
96511: EMPTY
96512: LIST
96513: LIST
96514: PUSH
96515: LD_INT 1
96517: PUSH
96518: LD_INT 2
96520: NEG
96521: PUSH
96522: EMPTY
96523: LIST
96524: LIST
96525: PUSH
96526: EMPTY
96527: LIST
96528: LIST
96529: LIST
96530: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
96531: LD_ADDR_VAR 0 12
96535: PUSH
96536: LD_INT 2
96538: PUSH
96539: LD_INT 1
96541: NEG
96542: PUSH
96543: EMPTY
96544: LIST
96545: LIST
96546: PUSH
96547: LD_INT 3
96549: PUSH
96550: LD_INT 0
96552: PUSH
96553: EMPTY
96554: LIST
96555: LIST
96556: PUSH
96557: LD_INT 3
96559: PUSH
96560: LD_INT 1
96562: PUSH
96563: EMPTY
96564: LIST
96565: LIST
96566: PUSH
96567: EMPTY
96568: LIST
96569: LIST
96570: LIST
96571: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
96572: LD_ADDR_VAR 0 13
96576: PUSH
96577: LD_INT 3
96579: PUSH
96580: LD_INT 2
96582: PUSH
96583: EMPTY
96584: LIST
96585: LIST
96586: PUSH
96587: LD_INT 3
96589: PUSH
96590: LD_INT 3
96592: PUSH
96593: EMPTY
96594: LIST
96595: LIST
96596: PUSH
96597: LD_INT 2
96599: PUSH
96600: LD_INT 3
96602: PUSH
96603: EMPTY
96604: LIST
96605: LIST
96606: PUSH
96607: EMPTY
96608: LIST
96609: LIST
96610: LIST
96611: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
96612: LD_ADDR_VAR 0 14
96616: PUSH
96617: LD_INT 1
96619: PUSH
96620: LD_INT 3
96622: PUSH
96623: EMPTY
96624: LIST
96625: LIST
96626: PUSH
96627: LD_INT 0
96629: PUSH
96630: LD_INT 3
96632: PUSH
96633: EMPTY
96634: LIST
96635: LIST
96636: PUSH
96637: LD_INT 1
96639: NEG
96640: PUSH
96641: LD_INT 2
96643: PUSH
96644: EMPTY
96645: LIST
96646: LIST
96647: PUSH
96648: EMPTY
96649: LIST
96650: LIST
96651: LIST
96652: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
96653: LD_ADDR_VAR 0 15
96657: PUSH
96658: LD_INT 2
96660: NEG
96661: PUSH
96662: LD_INT 1
96664: PUSH
96665: EMPTY
96666: LIST
96667: LIST
96668: PUSH
96669: LD_INT 3
96671: NEG
96672: PUSH
96673: LD_INT 0
96675: PUSH
96676: EMPTY
96677: LIST
96678: LIST
96679: PUSH
96680: LD_INT 3
96682: NEG
96683: PUSH
96684: LD_INT 1
96686: NEG
96687: PUSH
96688: EMPTY
96689: LIST
96690: LIST
96691: PUSH
96692: EMPTY
96693: LIST
96694: LIST
96695: LIST
96696: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
96697: LD_ADDR_VAR 0 16
96701: PUSH
96702: LD_INT 2
96704: NEG
96705: PUSH
96706: LD_INT 3
96708: NEG
96709: PUSH
96710: EMPTY
96711: LIST
96712: LIST
96713: PUSH
96714: LD_INT 3
96716: NEG
96717: PUSH
96718: LD_INT 2
96720: NEG
96721: PUSH
96722: EMPTY
96723: LIST
96724: LIST
96725: PUSH
96726: LD_INT 3
96728: NEG
96729: PUSH
96730: LD_INT 3
96732: NEG
96733: PUSH
96734: EMPTY
96735: LIST
96736: LIST
96737: PUSH
96738: EMPTY
96739: LIST
96740: LIST
96741: LIST
96742: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
96743: LD_ADDR_VAR 0 17
96747: PUSH
96748: LD_INT 1
96750: NEG
96751: PUSH
96752: LD_INT 3
96754: NEG
96755: PUSH
96756: EMPTY
96757: LIST
96758: LIST
96759: PUSH
96760: LD_INT 0
96762: PUSH
96763: LD_INT 3
96765: NEG
96766: PUSH
96767: EMPTY
96768: LIST
96769: LIST
96770: PUSH
96771: LD_INT 1
96773: PUSH
96774: LD_INT 2
96776: NEG
96777: PUSH
96778: EMPTY
96779: LIST
96780: LIST
96781: PUSH
96782: EMPTY
96783: LIST
96784: LIST
96785: LIST
96786: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
96787: LD_ADDR_VAR 0 18
96791: PUSH
96792: LD_INT 2
96794: PUSH
96795: LD_INT 1
96797: NEG
96798: PUSH
96799: EMPTY
96800: LIST
96801: LIST
96802: PUSH
96803: LD_INT 3
96805: PUSH
96806: LD_INT 0
96808: PUSH
96809: EMPTY
96810: LIST
96811: LIST
96812: PUSH
96813: LD_INT 3
96815: PUSH
96816: LD_INT 1
96818: PUSH
96819: EMPTY
96820: LIST
96821: LIST
96822: PUSH
96823: EMPTY
96824: LIST
96825: LIST
96826: LIST
96827: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
96828: LD_ADDR_VAR 0 19
96832: PUSH
96833: LD_INT 3
96835: PUSH
96836: LD_INT 2
96838: PUSH
96839: EMPTY
96840: LIST
96841: LIST
96842: PUSH
96843: LD_INT 3
96845: PUSH
96846: LD_INT 3
96848: PUSH
96849: EMPTY
96850: LIST
96851: LIST
96852: PUSH
96853: LD_INT 2
96855: PUSH
96856: LD_INT 3
96858: PUSH
96859: EMPTY
96860: LIST
96861: LIST
96862: PUSH
96863: EMPTY
96864: LIST
96865: LIST
96866: LIST
96867: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
96868: LD_ADDR_VAR 0 20
96872: PUSH
96873: LD_INT 1
96875: PUSH
96876: LD_INT 3
96878: PUSH
96879: EMPTY
96880: LIST
96881: LIST
96882: PUSH
96883: LD_INT 0
96885: PUSH
96886: LD_INT 3
96888: PUSH
96889: EMPTY
96890: LIST
96891: LIST
96892: PUSH
96893: LD_INT 1
96895: NEG
96896: PUSH
96897: LD_INT 2
96899: PUSH
96900: EMPTY
96901: LIST
96902: LIST
96903: PUSH
96904: EMPTY
96905: LIST
96906: LIST
96907: LIST
96908: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
96909: LD_ADDR_VAR 0 21
96913: PUSH
96914: LD_INT 2
96916: NEG
96917: PUSH
96918: LD_INT 1
96920: PUSH
96921: EMPTY
96922: LIST
96923: LIST
96924: PUSH
96925: LD_INT 3
96927: NEG
96928: PUSH
96929: LD_INT 0
96931: PUSH
96932: EMPTY
96933: LIST
96934: LIST
96935: PUSH
96936: LD_INT 3
96938: NEG
96939: PUSH
96940: LD_INT 1
96942: NEG
96943: PUSH
96944: EMPTY
96945: LIST
96946: LIST
96947: PUSH
96948: EMPTY
96949: LIST
96950: LIST
96951: LIST
96952: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
96953: LD_ADDR_VAR 0 22
96957: PUSH
96958: LD_INT 2
96960: NEG
96961: PUSH
96962: LD_INT 3
96964: NEG
96965: PUSH
96966: EMPTY
96967: LIST
96968: LIST
96969: PUSH
96970: LD_INT 3
96972: NEG
96973: PUSH
96974: LD_INT 2
96976: NEG
96977: PUSH
96978: EMPTY
96979: LIST
96980: LIST
96981: PUSH
96982: LD_INT 3
96984: NEG
96985: PUSH
96986: LD_INT 3
96988: NEG
96989: PUSH
96990: EMPTY
96991: LIST
96992: LIST
96993: PUSH
96994: EMPTY
96995: LIST
96996: LIST
96997: LIST
96998: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
96999: LD_ADDR_VAR 0 23
97003: PUSH
97004: LD_INT 0
97006: PUSH
97007: LD_INT 3
97009: NEG
97010: PUSH
97011: EMPTY
97012: LIST
97013: LIST
97014: PUSH
97015: LD_INT 1
97017: NEG
97018: PUSH
97019: LD_INT 4
97021: NEG
97022: PUSH
97023: EMPTY
97024: LIST
97025: LIST
97026: PUSH
97027: LD_INT 1
97029: PUSH
97030: LD_INT 3
97032: NEG
97033: PUSH
97034: EMPTY
97035: LIST
97036: LIST
97037: PUSH
97038: EMPTY
97039: LIST
97040: LIST
97041: LIST
97042: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
97043: LD_ADDR_VAR 0 24
97047: PUSH
97048: LD_INT 3
97050: PUSH
97051: LD_INT 0
97053: PUSH
97054: EMPTY
97055: LIST
97056: LIST
97057: PUSH
97058: LD_INT 3
97060: PUSH
97061: LD_INT 1
97063: NEG
97064: PUSH
97065: EMPTY
97066: LIST
97067: LIST
97068: PUSH
97069: LD_INT 4
97071: PUSH
97072: LD_INT 1
97074: PUSH
97075: EMPTY
97076: LIST
97077: LIST
97078: PUSH
97079: EMPTY
97080: LIST
97081: LIST
97082: LIST
97083: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
97084: LD_ADDR_VAR 0 25
97088: PUSH
97089: LD_INT 3
97091: PUSH
97092: LD_INT 3
97094: PUSH
97095: EMPTY
97096: LIST
97097: LIST
97098: PUSH
97099: LD_INT 4
97101: PUSH
97102: LD_INT 3
97104: PUSH
97105: EMPTY
97106: LIST
97107: LIST
97108: PUSH
97109: LD_INT 3
97111: PUSH
97112: LD_INT 4
97114: PUSH
97115: EMPTY
97116: LIST
97117: LIST
97118: PUSH
97119: EMPTY
97120: LIST
97121: LIST
97122: LIST
97123: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
97124: LD_ADDR_VAR 0 26
97128: PUSH
97129: LD_INT 0
97131: PUSH
97132: LD_INT 3
97134: PUSH
97135: EMPTY
97136: LIST
97137: LIST
97138: PUSH
97139: LD_INT 1
97141: PUSH
97142: LD_INT 4
97144: PUSH
97145: EMPTY
97146: LIST
97147: LIST
97148: PUSH
97149: LD_INT 1
97151: NEG
97152: PUSH
97153: LD_INT 3
97155: PUSH
97156: EMPTY
97157: LIST
97158: LIST
97159: PUSH
97160: EMPTY
97161: LIST
97162: LIST
97163: LIST
97164: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
97165: LD_ADDR_VAR 0 27
97169: PUSH
97170: LD_INT 3
97172: NEG
97173: PUSH
97174: LD_INT 0
97176: PUSH
97177: EMPTY
97178: LIST
97179: LIST
97180: PUSH
97181: LD_INT 3
97183: NEG
97184: PUSH
97185: LD_INT 1
97187: PUSH
97188: EMPTY
97189: LIST
97190: LIST
97191: PUSH
97192: LD_INT 4
97194: NEG
97195: PUSH
97196: LD_INT 1
97198: NEG
97199: PUSH
97200: EMPTY
97201: LIST
97202: LIST
97203: PUSH
97204: EMPTY
97205: LIST
97206: LIST
97207: LIST
97208: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
97209: LD_ADDR_VAR 0 28
97213: PUSH
97214: LD_INT 3
97216: NEG
97217: PUSH
97218: LD_INT 3
97220: NEG
97221: PUSH
97222: EMPTY
97223: LIST
97224: LIST
97225: PUSH
97226: LD_INT 3
97228: NEG
97229: PUSH
97230: LD_INT 4
97232: NEG
97233: PUSH
97234: EMPTY
97235: LIST
97236: LIST
97237: PUSH
97238: LD_INT 4
97240: NEG
97241: PUSH
97242: LD_INT 3
97244: NEG
97245: PUSH
97246: EMPTY
97247: LIST
97248: LIST
97249: PUSH
97250: EMPTY
97251: LIST
97252: LIST
97253: LIST
97254: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
97255: LD_ADDR_VAR 0 29
97259: PUSH
97260: LD_INT 1
97262: NEG
97263: PUSH
97264: LD_INT 3
97266: NEG
97267: PUSH
97268: EMPTY
97269: LIST
97270: LIST
97271: PUSH
97272: LD_INT 0
97274: PUSH
97275: LD_INT 3
97277: NEG
97278: PUSH
97279: EMPTY
97280: LIST
97281: LIST
97282: PUSH
97283: LD_INT 1
97285: PUSH
97286: LD_INT 2
97288: NEG
97289: PUSH
97290: EMPTY
97291: LIST
97292: LIST
97293: PUSH
97294: LD_INT 1
97296: NEG
97297: PUSH
97298: LD_INT 4
97300: NEG
97301: PUSH
97302: EMPTY
97303: LIST
97304: LIST
97305: PUSH
97306: LD_INT 0
97308: PUSH
97309: LD_INT 4
97311: NEG
97312: PUSH
97313: EMPTY
97314: LIST
97315: LIST
97316: PUSH
97317: LD_INT 1
97319: PUSH
97320: LD_INT 3
97322: NEG
97323: PUSH
97324: EMPTY
97325: LIST
97326: LIST
97327: PUSH
97328: LD_INT 1
97330: NEG
97331: PUSH
97332: LD_INT 5
97334: NEG
97335: PUSH
97336: EMPTY
97337: LIST
97338: LIST
97339: PUSH
97340: LD_INT 0
97342: PUSH
97343: LD_INT 5
97345: NEG
97346: PUSH
97347: EMPTY
97348: LIST
97349: LIST
97350: PUSH
97351: LD_INT 1
97353: PUSH
97354: LD_INT 4
97356: NEG
97357: PUSH
97358: EMPTY
97359: LIST
97360: LIST
97361: PUSH
97362: LD_INT 1
97364: NEG
97365: PUSH
97366: LD_INT 6
97368: NEG
97369: PUSH
97370: EMPTY
97371: LIST
97372: LIST
97373: PUSH
97374: LD_INT 0
97376: PUSH
97377: LD_INT 6
97379: NEG
97380: PUSH
97381: EMPTY
97382: LIST
97383: LIST
97384: PUSH
97385: LD_INT 1
97387: PUSH
97388: LD_INT 5
97390: NEG
97391: PUSH
97392: EMPTY
97393: LIST
97394: LIST
97395: PUSH
97396: EMPTY
97397: LIST
97398: LIST
97399: LIST
97400: LIST
97401: LIST
97402: LIST
97403: LIST
97404: LIST
97405: LIST
97406: LIST
97407: LIST
97408: LIST
97409: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
97410: LD_ADDR_VAR 0 30
97414: PUSH
97415: LD_INT 2
97417: PUSH
97418: LD_INT 1
97420: NEG
97421: PUSH
97422: EMPTY
97423: LIST
97424: LIST
97425: PUSH
97426: LD_INT 3
97428: PUSH
97429: LD_INT 0
97431: PUSH
97432: EMPTY
97433: LIST
97434: LIST
97435: PUSH
97436: LD_INT 3
97438: PUSH
97439: LD_INT 1
97441: PUSH
97442: EMPTY
97443: LIST
97444: LIST
97445: PUSH
97446: LD_INT 3
97448: PUSH
97449: LD_INT 1
97451: NEG
97452: PUSH
97453: EMPTY
97454: LIST
97455: LIST
97456: PUSH
97457: LD_INT 4
97459: PUSH
97460: LD_INT 0
97462: PUSH
97463: EMPTY
97464: LIST
97465: LIST
97466: PUSH
97467: LD_INT 4
97469: PUSH
97470: LD_INT 1
97472: PUSH
97473: EMPTY
97474: LIST
97475: LIST
97476: PUSH
97477: LD_INT 4
97479: PUSH
97480: LD_INT 1
97482: NEG
97483: PUSH
97484: EMPTY
97485: LIST
97486: LIST
97487: PUSH
97488: LD_INT 5
97490: PUSH
97491: LD_INT 0
97493: PUSH
97494: EMPTY
97495: LIST
97496: LIST
97497: PUSH
97498: LD_INT 5
97500: PUSH
97501: LD_INT 1
97503: PUSH
97504: EMPTY
97505: LIST
97506: LIST
97507: PUSH
97508: LD_INT 5
97510: PUSH
97511: LD_INT 1
97513: NEG
97514: PUSH
97515: EMPTY
97516: LIST
97517: LIST
97518: PUSH
97519: LD_INT 6
97521: PUSH
97522: LD_INT 0
97524: PUSH
97525: EMPTY
97526: LIST
97527: LIST
97528: PUSH
97529: LD_INT 6
97531: PUSH
97532: LD_INT 1
97534: PUSH
97535: EMPTY
97536: LIST
97537: LIST
97538: PUSH
97539: EMPTY
97540: LIST
97541: LIST
97542: LIST
97543: LIST
97544: LIST
97545: LIST
97546: LIST
97547: LIST
97548: LIST
97549: LIST
97550: LIST
97551: LIST
97552: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
97553: LD_ADDR_VAR 0 31
97557: PUSH
97558: LD_INT 3
97560: PUSH
97561: LD_INT 2
97563: PUSH
97564: EMPTY
97565: LIST
97566: LIST
97567: PUSH
97568: LD_INT 3
97570: PUSH
97571: LD_INT 3
97573: PUSH
97574: EMPTY
97575: LIST
97576: LIST
97577: PUSH
97578: LD_INT 2
97580: PUSH
97581: LD_INT 3
97583: PUSH
97584: EMPTY
97585: LIST
97586: LIST
97587: PUSH
97588: LD_INT 4
97590: PUSH
97591: LD_INT 3
97593: PUSH
97594: EMPTY
97595: LIST
97596: LIST
97597: PUSH
97598: LD_INT 4
97600: PUSH
97601: LD_INT 4
97603: PUSH
97604: EMPTY
97605: LIST
97606: LIST
97607: PUSH
97608: LD_INT 3
97610: PUSH
97611: LD_INT 4
97613: PUSH
97614: EMPTY
97615: LIST
97616: LIST
97617: PUSH
97618: LD_INT 5
97620: PUSH
97621: LD_INT 4
97623: PUSH
97624: EMPTY
97625: LIST
97626: LIST
97627: PUSH
97628: LD_INT 5
97630: PUSH
97631: LD_INT 5
97633: PUSH
97634: EMPTY
97635: LIST
97636: LIST
97637: PUSH
97638: LD_INT 4
97640: PUSH
97641: LD_INT 5
97643: PUSH
97644: EMPTY
97645: LIST
97646: LIST
97647: PUSH
97648: LD_INT 6
97650: PUSH
97651: LD_INT 5
97653: PUSH
97654: EMPTY
97655: LIST
97656: LIST
97657: PUSH
97658: LD_INT 6
97660: PUSH
97661: LD_INT 6
97663: PUSH
97664: EMPTY
97665: LIST
97666: LIST
97667: PUSH
97668: LD_INT 5
97670: PUSH
97671: LD_INT 6
97673: PUSH
97674: EMPTY
97675: LIST
97676: LIST
97677: PUSH
97678: EMPTY
97679: LIST
97680: LIST
97681: LIST
97682: LIST
97683: LIST
97684: LIST
97685: LIST
97686: LIST
97687: LIST
97688: LIST
97689: LIST
97690: LIST
97691: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
97692: LD_ADDR_VAR 0 32
97696: PUSH
97697: LD_INT 1
97699: PUSH
97700: LD_INT 3
97702: PUSH
97703: EMPTY
97704: LIST
97705: LIST
97706: PUSH
97707: LD_INT 0
97709: PUSH
97710: LD_INT 3
97712: PUSH
97713: EMPTY
97714: LIST
97715: LIST
97716: PUSH
97717: LD_INT 1
97719: NEG
97720: PUSH
97721: LD_INT 2
97723: PUSH
97724: EMPTY
97725: LIST
97726: LIST
97727: PUSH
97728: LD_INT 1
97730: PUSH
97731: LD_INT 4
97733: PUSH
97734: EMPTY
97735: LIST
97736: LIST
97737: PUSH
97738: LD_INT 0
97740: PUSH
97741: LD_INT 4
97743: PUSH
97744: EMPTY
97745: LIST
97746: LIST
97747: PUSH
97748: LD_INT 1
97750: NEG
97751: PUSH
97752: LD_INT 3
97754: PUSH
97755: EMPTY
97756: LIST
97757: LIST
97758: PUSH
97759: LD_INT 1
97761: PUSH
97762: LD_INT 5
97764: PUSH
97765: EMPTY
97766: LIST
97767: LIST
97768: PUSH
97769: LD_INT 0
97771: PUSH
97772: LD_INT 5
97774: PUSH
97775: EMPTY
97776: LIST
97777: LIST
97778: PUSH
97779: LD_INT 1
97781: NEG
97782: PUSH
97783: LD_INT 4
97785: PUSH
97786: EMPTY
97787: LIST
97788: LIST
97789: PUSH
97790: LD_INT 1
97792: PUSH
97793: LD_INT 6
97795: PUSH
97796: EMPTY
97797: LIST
97798: LIST
97799: PUSH
97800: LD_INT 0
97802: PUSH
97803: LD_INT 6
97805: PUSH
97806: EMPTY
97807: LIST
97808: LIST
97809: PUSH
97810: LD_INT 1
97812: NEG
97813: PUSH
97814: LD_INT 5
97816: PUSH
97817: EMPTY
97818: LIST
97819: LIST
97820: PUSH
97821: EMPTY
97822: LIST
97823: LIST
97824: LIST
97825: LIST
97826: LIST
97827: LIST
97828: LIST
97829: LIST
97830: LIST
97831: LIST
97832: LIST
97833: LIST
97834: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
97835: LD_ADDR_VAR 0 33
97839: PUSH
97840: LD_INT 2
97842: NEG
97843: PUSH
97844: LD_INT 1
97846: PUSH
97847: EMPTY
97848: LIST
97849: LIST
97850: PUSH
97851: LD_INT 3
97853: NEG
97854: PUSH
97855: LD_INT 0
97857: PUSH
97858: EMPTY
97859: LIST
97860: LIST
97861: PUSH
97862: LD_INT 3
97864: NEG
97865: PUSH
97866: LD_INT 1
97868: NEG
97869: PUSH
97870: EMPTY
97871: LIST
97872: LIST
97873: PUSH
97874: LD_INT 3
97876: NEG
97877: PUSH
97878: LD_INT 1
97880: PUSH
97881: EMPTY
97882: LIST
97883: LIST
97884: PUSH
97885: LD_INT 4
97887: NEG
97888: PUSH
97889: LD_INT 0
97891: PUSH
97892: EMPTY
97893: LIST
97894: LIST
97895: PUSH
97896: LD_INT 4
97898: NEG
97899: PUSH
97900: LD_INT 1
97902: NEG
97903: PUSH
97904: EMPTY
97905: LIST
97906: LIST
97907: PUSH
97908: LD_INT 4
97910: NEG
97911: PUSH
97912: LD_INT 1
97914: PUSH
97915: EMPTY
97916: LIST
97917: LIST
97918: PUSH
97919: LD_INT 5
97921: NEG
97922: PUSH
97923: LD_INT 0
97925: PUSH
97926: EMPTY
97927: LIST
97928: LIST
97929: PUSH
97930: LD_INT 5
97932: NEG
97933: PUSH
97934: LD_INT 1
97936: NEG
97937: PUSH
97938: EMPTY
97939: LIST
97940: LIST
97941: PUSH
97942: LD_INT 5
97944: NEG
97945: PUSH
97946: LD_INT 1
97948: PUSH
97949: EMPTY
97950: LIST
97951: LIST
97952: PUSH
97953: LD_INT 6
97955: NEG
97956: PUSH
97957: LD_INT 0
97959: PUSH
97960: EMPTY
97961: LIST
97962: LIST
97963: PUSH
97964: LD_INT 6
97966: NEG
97967: PUSH
97968: LD_INT 1
97970: NEG
97971: PUSH
97972: EMPTY
97973: LIST
97974: LIST
97975: PUSH
97976: EMPTY
97977: LIST
97978: LIST
97979: LIST
97980: LIST
97981: LIST
97982: LIST
97983: LIST
97984: LIST
97985: LIST
97986: LIST
97987: LIST
97988: LIST
97989: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
97990: LD_ADDR_VAR 0 34
97994: PUSH
97995: LD_INT 2
97997: NEG
97998: PUSH
97999: LD_INT 3
98001: NEG
98002: PUSH
98003: EMPTY
98004: LIST
98005: LIST
98006: PUSH
98007: LD_INT 3
98009: NEG
98010: PUSH
98011: LD_INT 2
98013: NEG
98014: PUSH
98015: EMPTY
98016: LIST
98017: LIST
98018: PUSH
98019: LD_INT 3
98021: NEG
98022: PUSH
98023: LD_INT 3
98025: NEG
98026: PUSH
98027: EMPTY
98028: LIST
98029: LIST
98030: PUSH
98031: LD_INT 3
98033: NEG
98034: PUSH
98035: LD_INT 4
98037: NEG
98038: PUSH
98039: EMPTY
98040: LIST
98041: LIST
98042: PUSH
98043: LD_INT 4
98045: NEG
98046: PUSH
98047: LD_INT 3
98049: NEG
98050: PUSH
98051: EMPTY
98052: LIST
98053: LIST
98054: PUSH
98055: LD_INT 4
98057: NEG
98058: PUSH
98059: LD_INT 4
98061: NEG
98062: PUSH
98063: EMPTY
98064: LIST
98065: LIST
98066: PUSH
98067: LD_INT 4
98069: NEG
98070: PUSH
98071: LD_INT 5
98073: NEG
98074: PUSH
98075: EMPTY
98076: LIST
98077: LIST
98078: PUSH
98079: LD_INT 5
98081: NEG
98082: PUSH
98083: LD_INT 4
98085: NEG
98086: PUSH
98087: EMPTY
98088: LIST
98089: LIST
98090: PUSH
98091: LD_INT 5
98093: NEG
98094: PUSH
98095: LD_INT 5
98097: NEG
98098: PUSH
98099: EMPTY
98100: LIST
98101: LIST
98102: PUSH
98103: LD_INT 5
98105: NEG
98106: PUSH
98107: LD_INT 6
98109: NEG
98110: PUSH
98111: EMPTY
98112: LIST
98113: LIST
98114: PUSH
98115: LD_INT 6
98117: NEG
98118: PUSH
98119: LD_INT 5
98121: NEG
98122: PUSH
98123: EMPTY
98124: LIST
98125: LIST
98126: PUSH
98127: LD_INT 6
98129: NEG
98130: PUSH
98131: LD_INT 6
98133: NEG
98134: PUSH
98135: EMPTY
98136: LIST
98137: LIST
98138: PUSH
98139: EMPTY
98140: LIST
98141: LIST
98142: LIST
98143: LIST
98144: LIST
98145: LIST
98146: LIST
98147: LIST
98148: LIST
98149: LIST
98150: LIST
98151: LIST
98152: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
98153: LD_ADDR_VAR 0 41
98157: PUSH
98158: LD_INT 0
98160: PUSH
98161: LD_INT 2
98163: NEG
98164: PUSH
98165: EMPTY
98166: LIST
98167: LIST
98168: PUSH
98169: LD_INT 1
98171: NEG
98172: PUSH
98173: LD_INT 3
98175: NEG
98176: PUSH
98177: EMPTY
98178: LIST
98179: LIST
98180: PUSH
98181: LD_INT 1
98183: PUSH
98184: LD_INT 2
98186: NEG
98187: PUSH
98188: EMPTY
98189: LIST
98190: LIST
98191: PUSH
98192: EMPTY
98193: LIST
98194: LIST
98195: LIST
98196: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
98197: LD_ADDR_VAR 0 42
98201: PUSH
98202: LD_INT 2
98204: PUSH
98205: LD_INT 0
98207: PUSH
98208: EMPTY
98209: LIST
98210: LIST
98211: PUSH
98212: LD_INT 2
98214: PUSH
98215: LD_INT 1
98217: NEG
98218: PUSH
98219: EMPTY
98220: LIST
98221: LIST
98222: PUSH
98223: LD_INT 3
98225: PUSH
98226: LD_INT 1
98228: PUSH
98229: EMPTY
98230: LIST
98231: LIST
98232: PUSH
98233: EMPTY
98234: LIST
98235: LIST
98236: LIST
98237: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
98238: LD_ADDR_VAR 0 43
98242: PUSH
98243: LD_INT 2
98245: PUSH
98246: LD_INT 2
98248: PUSH
98249: EMPTY
98250: LIST
98251: LIST
98252: PUSH
98253: LD_INT 3
98255: PUSH
98256: LD_INT 2
98258: PUSH
98259: EMPTY
98260: LIST
98261: LIST
98262: PUSH
98263: LD_INT 2
98265: PUSH
98266: LD_INT 3
98268: PUSH
98269: EMPTY
98270: LIST
98271: LIST
98272: PUSH
98273: EMPTY
98274: LIST
98275: LIST
98276: LIST
98277: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
98278: LD_ADDR_VAR 0 44
98282: PUSH
98283: LD_INT 0
98285: PUSH
98286: LD_INT 2
98288: PUSH
98289: EMPTY
98290: LIST
98291: LIST
98292: PUSH
98293: LD_INT 1
98295: PUSH
98296: LD_INT 3
98298: PUSH
98299: EMPTY
98300: LIST
98301: LIST
98302: PUSH
98303: LD_INT 1
98305: NEG
98306: PUSH
98307: LD_INT 2
98309: PUSH
98310: EMPTY
98311: LIST
98312: LIST
98313: PUSH
98314: EMPTY
98315: LIST
98316: LIST
98317: LIST
98318: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
98319: LD_ADDR_VAR 0 45
98323: PUSH
98324: LD_INT 2
98326: NEG
98327: PUSH
98328: LD_INT 0
98330: PUSH
98331: EMPTY
98332: LIST
98333: LIST
98334: PUSH
98335: LD_INT 2
98337: NEG
98338: PUSH
98339: LD_INT 1
98341: PUSH
98342: EMPTY
98343: LIST
98344: LIST
98345: PUSH
98346: LD_INT 3
98348: NEG
98349: PUSH
98350: LD_INT 1
98352: NEG
98353: PUSH
98354: EMPTY
98355: LIST
98356: LIST
98357: PUSH
98358: EMPTY
98359: LIST
98360: LIST
98361: LIST
98362: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
98363: LD_ADDR_VAR 0 46
98367: PUSH
98368: LD_INT 2
98370: NEG
98371: PUSH
98372: LD_INT 2
98374: NEG
98375: PUSH
98376: EMPTY
98377: LIST
98378: LIST
98379: PUSH
98380: LD_INT 2
98382: NEG
98383: PUSH
98384: LD_INT 3
98386: NEG
98387: PUSH
98388: EMPTY
98389: LIST
98390: LIST
98391: PUSH
98392: LD_INT 3
98394: NEG
98395: PUSH
98396: LD_INT 2
98398: NEG
98399: PUSH
98400: EMPTY
98401: LIST
98402: LIST
98403: PUSH
98404: EMPTY
98405: LIST
98406: LIST
98407: LIST
98408: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
98409: LD_ADDR_VAR 0 47
98413: PUSH
98414: LD_INT 2
98416: NEG
98417: PUSH
98418: LD_INT 3
98420: NEG
98421: PUSH
98422: EMPTY
98423: LIST
98424: LIST
98425: PUSH
98426: LD_INT 1
98428: NEG
98429: PUSH
98430: LD_INT 3
98432: NEG
98433: PUSH
98434: EMPTY
98435: LIST
98436: LIST
98437: PUSH
98438: EMPTY
98439: LIST
98440: LIST
98441: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
98442: LD_ADDR_VAR 0 48
98446: PUSH
98447: LD_INT 1
98449: PUSH
98450: LD_INT 2
98452: NEG
98453: PUSH
98454: EMPTY
98455: LIST
98456: LIST
98457: PUSH
98458: LD_INT 2
98460: PUSH
98461: LD_INT 1
98463: NEG
98464: PUSH
98465: EMPTY
98466: LIST
98467: LIST
98468: PUSH
98469: EMPTY
98470: LIST
98471: LIST
98472: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
98473: LD_ADDR_VAR 0 49
98477: PUSH
98478: LD_INT 3
98480: PUSH
98481: LD_INT 1
98483: PUSH
98484: EMPTY
98485: LIST
98486: LIST
98487: PUSH
98488: LD_INT 3
98490: PUSH
98491: LD_INT 2
98493: PUSH
98494: EMPTY
98495: LIST
98496: LIST
98497: PUSH
98498: EMPTY
98499: LIST
98500: LIST
98501: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
98502: LD_ADDR_VAR 0 50
98506: PUSH
98507: LD_INT 2
98509: PUSH
98510: LD_INT 3
98512: PUSH
98513: EMPTY
98514: LIST
98515: LIST
98516: PUSH
98517: LD_INT 1
98519: PUSH
98520: LD_INT 3
98522: PUSH
98523: EMPTY
98524: LIST
98525: LIST
98526: PUSH
98527: EMPTY
98528: LIST
98529: LIST
98530: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
98531: LD_ADDR_VAR 0 51
98535: PUSH
98536: LD_INT 1
98538: NEG
98539: PUSH
98540: LD_INT 2
98542: PUSH
98543: EMPTY
98544: LIST
98545: LIST
98546: PUSH
98547: LD_INT 2
98549: NEG
98550: PUSH
98551: LD_INT 1
98553: PUSH
98554: EMPTY
98555: LIST
98556: LIST
98557: PUSH
98558: EMPTY
98559: LIST
98560: LIST
98561: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
98562: LD_ADDR_VAR 0 52
98566: PUSH
98567: LD_INT 3
98569: NEG
98570: PUSH
98571: LD_INT 1
98573: NEG
98574: PUSH
98575: EMPTY
98576: LIST
98577: LIST
98578: PUSH
98579: LD_INT 3
98581: NEG
98582: PUSH
98583: LD_INT 2
98585: NEG
98586: PUSH
98587: EMPTY
98588: LIST
98589: LIST
98590: PUSH
98591: EMPTY
98592: LIST
98593: LIST
98594: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
98595: LD_ADDR_VAR 0 53
98599: PUSH
98600: LD_INT 1
98602: NEG
98603: PUSH
98604: LD_INT 3
98606: NEG
98607: PUSH
98608: EMPTY
98609: LIST
98610: LIST
98611: PUSH
98612: LD_INT 0
98614: PUSH
98615: LD_INT 3
98617: NEG
98618: PUSH
98619: EMPTY
98620: LIST
98621: LIST
98622: PUSH
98623: LD_INT 1
98625: PUSH
98626: LD_INT 2
98628: NEG
98629: PUSH
98630: EMPTY
98631: LIST
98632: LIST
98633: PUSH
98634: EMPTY
98635: LIST
98636: LIST
98637: LIST
98638: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
98639: LD_ADDR_VAR 0 54
98643: PUSH
98644: LD_INT 2
98646: PUSH
98647: LD_INT 1
98649: NEG
98650: PUSH
98651: EMPTY
98652: LIST
98653: LIST
98654: PUSH
98655: LD_INT 3
98657: PUSH
98658: LD_INT 0
98660: PUSH
98661: EMPTY
98662: LIST
98663: LIST
98664: PUSH
98665: LD_INT 3
98667: PUSH
98668: LD_INT 1
98670: PUSH
98671: EMPTY
98672: LIST
98673: LIST
98674: PUSH
98675: EMPTY
98676: LIST
98677: LIST
98678: LIST
98679: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
98680: LD_ADDR_VAR 0 55
98684: PUSH
98685: LD_INT 3
98687: PUSH
98688: LD_INT 2
98690: PUSH
98691: EMPTY
98692: LIST
98693: LIST
98694: PUSH
98695: LD_INT 3
98697: PUSH
98698: LD_INT 3
98700: PUSH
98701: EMPTY
98702: LIST
98703: LIST
98704: PUSH
98705: LD_INT 2
98707: PUSH
98708: LD_INT 3
98710: PUSH
98711: EMPTY
98712: LIST
98713: LIST
98714: PUSH
98715: EMPTY
98716: LIST
98717: LIST
98718: LIST
98719: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
98720: LD_ADDR_VAR 0 56
98724: PUSH
98725: LD_INT 1
98727: PUSH
98728: LD_INT 3
98730: PUSH
98731: EMPTY
98732: LIST
98733: LIST
98734: PUSH
98735: LD_INT 0
98737: PUSH
98738: LD_INT 3
98740: PUSH
98741: EMPTY
98742: LIST
98743: LIST
98744: PUSH
98745: LD_INT 1
98747: NEG
98748: PUSH
98749: LD_INT 2
98751: PUSH
98752: EMPTY
98753: LIST
98754: LIST
98755: PUSH
98756: EMPTY
98757: LIST
98758: LIST
98759: LIST
98760: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
98761: LD_ADDR_VAR 0 57
98765: PUSH
98766: LD_INT 2
98768: NEG
98769: PUSH
98770: LD_INT 1
98772: PUSH
98773: EMPTY
98774: LIST
98775: LIST
98776: PUSH
98777: LD_INT 3
98779: NEG
98780: PUSH
98781: LD_INT 0
98783: PUSH
98784: EMPTY
98785: LIST
98786: LIST
98787: PUSH
98788: LD_INT 3
98790: NEG
98791: PUSH
98792: LD_INT 1
98794: NEG
98795: PUSH
98796: EMPTY
98797: LIST
98798: LIST
98799: PUSH
98800: EMPTY
98801: LIST
98802: LIST
98803: LIST
98804: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
98805: LD_ADDR_VAR 0 58
98809: PUSH
98810: LD_INT 2
98812: NEG
98813: PUSH
98814: LD_INT 3
98816: NEG
98817: PUSH
98818: EMPTY
98819: LIST
98820: LIST
98821: PUSH
98822: LD_INT 3
98824: NEG
98825: PUSH
98826: LD_INT 2
98828: NEG
98829: PUSH
98830: EMPTY
98831: LIST
98832: LIST
98833: PUSH
98834: LD_INT 3
98836: NEG
98837: PUSH
98838: LD_INT 3
98840: NEG
98841: PUSH
98842: EMPTY
98843: LIST
98844: LIST
98845: PUSH
98846: EMPTY
98847: LIST
98848: LIST
98849: LIST
98850: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
98851: LD_ADDR_VAR 0 59
98855: PUSH
98856: LD_INT 1
98858: NEG
98859: PUSH
98860: LD_INT 2
98862: NEG
98863: PUSH
98864: EMPTY
98865: LIST
98866: LIST
98867: PUSH
98868: LD_INT 0
98870: PUSH
98871: LD_INT 2
98873: NEG
98874: PUSH
98875: EMPTY
98876: LIST
98877: LIST
98878: PUSH
98879: LD_INT 1
98881: PUSH
98882: LD_INT 1
98884: NEG
98885: PUSH
98886: EMPTY
98887: LIST
98888: LIST
98889: PUSH
98890: EMPTY
98891: LIST
98892: LIST
98893: LIST
98894: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
98895: LD_ADDR_VAR 0 60
98899: PUSH
98900: LD_INT 1
98902: PUSH
98903: LD_INT 1
98905: NEG
98906: PUSH
98907: EMPTY
98908: LIST
98909: LIST
98910: PUSH
98911: LD_INT 2
98913: PUSH
98914: LD_INT 0
98916: PUSH
98917: EMPTY
98918: LIST
98919: LIST
98920: PUSH
98921: LD_INT 2
98923: PUSH
98924: LD_INT 1
98926: PUSH
98927: EMPTY
98928: LIST
98929: LIST
98930: PUSH
98931: EMPTY
98932: LIST
98933: LIST
98934: LIST
98935: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
98936: LD_ADDR_VAR 0 61
98940: PUSH
98941: LD_INT 2
98943: PUSH
98944: LD_INT 1
98946: PUSH
98947: EMPTY
98948: LIST
98949: LIST
98950: PUSH
98951: LD_INT 2
98953: PUSH
98954: LD_INT 2
98956: PUSH
98957: EMPTY
98958: LIST
98959: LIST
98960: PUSH
98961: LD_INT 1
98963: PUSH
98964: LD_INT 2
98966: PUSH
98967: EMPTY
98968: LIST
98969: LIST
98970: PUSH
98971: EMPTY
98972: LIST
98973: LIST
98974: LIST
98975: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
98976: LD_ADDR_VAR 0 62
98980: PUSH
98981: LD_INT 1
98983: PUSH
98984: LD_INT 2
98986: PUSH
98987: EMPTY
98988: LIST
98989: LIST
98990: PUSH
98991: LD_INT 0
98993: PUSH
98994: LD_INT 2
98996: PUSH
98997: EMPTY
98998: LIST
98999: LIST
99000: PUSH
99001: LD_INT 1
99003: NEG
99004: PUSH
99005: LD_INT 1
99007: PUSH
99008: EMPTY
99009: LIST
99010: LIST
99011: PUSH
99012: EMPTY
99013: LIST
99014: LIST
99015: LIST
99016: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
99017: LD_ADDR_VAR 0 63
99021: PUSH
99022: LD_INT 1
99024: NEG
99025: PUSH
99026: LD_INT 1
99028: PUSH
99029: EMPTY
99030: LIST
99031: LIST
99032: PUSH
99033: LD_INT 2
99035: NEG
99036: PUSH
99037: LD_INT 0
99039: PUSH
99040: EMPTY
99041: LIST
99042: LIST
99043: PUSH
99044: LD_INT 2
99046: NEG
99047: PUSH
99048: LD_INT 1
99050: NEG
99051: PUSH
99052: EMPTY
99053: LIST
99054: LIST
99055: PUSH
99056: EMPTY
99057: LIST
99058: LIST
99059: LIST
99060: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
99061: LD_ADDR_VAR 0 64
99065: PUSH
99066: LD_INT 1
99068: NEG
99069: PUSH
99070: LD_INT 2
99072: NEG
99073: PUSH
99074: EMPTY
99075: LIST
99076: LIST
99077: PUSH
99078: LD_INT 2
99080: NEG
99081: PUSH
99082: LD_INT 1
99084: NEG
99085: PUSH
99086: EMPTY
99087: LIST
99088: LIST
99089: PUSH
99090: LD_INT 2
99092: NEG
99093: PUSH
99094: LD_INT 2
99096: NEG
99097: PUSH
99098: EMPTY
99099: LIST
99100: LIST
99101: PUSH
99102: EMPTY
99103: LIST
99104: LIST
99105: LIST
99106: ST_TO_ADDR
// end ; 2 :
99107: GO 102373
99109: LD_INT 2
99111: DOUBLE
99112: EQUAL
99113: IFTRUE 99117
99115: GO 102372
99117: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
99118: LD_ADDR_VAR 0 29
99122: PUSH
99123: LD_INT 4
99125: PUSH
99126: LD_INT 0
99128: PUSH
99129: EMPTY
99130: LIST
99131: LIST
99132: PUSH
99133: LD_INT 4
99135: PUSH
99136: LD_INT 1
99138: NEG
99139: PUSH
99140: EMPTY
99141: LIST
99142: LIST
99143: PUSH
99144: LD_INT 5
99146: PUSH
99147: LD_INT 0
99149: PUSH
99150: EMPTY
99151: LIST
99152: LIST
99153: PUSH
99154: LD_INT 5
99156: PUSH
99157: LD_INT 1
99159: PUSH
99160: EMPTY
99161: LIST
99162: LIST
99163: PUSH
99164: LD_INT 4
99166: PUSH
99167: LD_INT 1
99169: PUSH
99170: EMPTY
99171: LIST
99172: LIST
99173: PUSH
99174: LD_INT 3
99176: PUSH
99177: LD_INT 0
99179: PUSH
99180: EMPTY
99181: LIST
99182: LIST
99183: PUSH
99184: LD_INT 3
99186: PUSH
99187: LD_INT 1
99189: NEG
99190: PUSH
99191: EMPTY
99192: LIST
99193: LIST
99194: PUSH
99195: LD_INT 3
99197: PUSH
99198: LD_INT 2
99200: NEG
99201: PUSH
99202: EMPTY
99203: LIST
99204: LIST
99205: PUSH
99206: LD_INT 5
99208: PUSH
99209: LD_INT 2
99211: PUSH
99212: EMPTY
99213: LIST
99214: LIST
99215: PUSH
99216: LD_INT 3
99218: PUSH
99219: LD_INT 3
99221: PUSH
99222: EMPTY
99223: LIST
99224: LIST
99225: PUSH
99226: LD_INT 3
99228: PUSH
99229: LD_INT 2
99231: PUSH
99232: EMPTY
99233: LIST
99234: LIST
99235: PUSH
99236: LD_INT 4
99238: PUSH
99239: LD_INT 3
99241: PUSH
99242: EMPTY
99243: LIST
99244: LIST
99245: PUSH
99246: LD_INT 4
99248: PUSH
99249: LD_INT 4
99251: PUSH
99252: EMPTY
99253: LIST
99254: LIST
99255: PUSH
99256: LD_INT 3
99258: PUSH
99259: LD_INT 4
99261: PUSH
99262: EMPTY
99263: LIST
99264: LIST
99265: PUSH
99266: LD_INT 2
99268: PUSH
99269: LD_INT 3
99271: PUSH
99272: EMPTY
99273: LIST
99274: LIST
99275: PUSH
99276: LD_INT 2
99278: PUSH
99279: LD_INT 2
99281: PUSH
99282: EMPTY
99283: LIST
99284: LIST
99285: PUSH
99286: LD_INT 4
99288: PUSH
99289: LD_INT 2
99291: PUSH
99292: EMPTY
99293: LIST
99294: LIST
99295: PUSH
99296: LD_INT 2
99298: PUSH
99299: LD_INT 4
99301: PUSH
99302: EMPTY
99303: LIST
99304: LIST
99305: PUSH
99306: LD_INT 0
99308: PUSH
99309: LD_INT 4
99311: PUSH
99312: EMPTY
99313: LIST
99314: LIST
99315: PUSH
99316: LD_INT 0
99318: PUSH
99319: LD_INT 3
99321: PUSH
99322: EMPTY
99323: LIST
99324: LIST
99325: PUSH
99326: LD_INT 1
99328: PUSH
99329: LD_INT 4
99331: PUSH
99332: EMPTY
99333: LIST
99334: LIST
99335: PUSH
99336: LD_INT 1
99338: PUSH
99339: LD_INT 5
99341: PUSH
99342: EMPTY
99343: LIST
99344: LIST
99345: PUSH
99346: LD_INT 0
99348: PUSH
99349: LD_INT 5
99351: PUSH
99352: EMPTY
99353: LIST
99354: LIST
99355: PUSH
99356: LD_INT 1
99358: NEG
99359: PUSH
99360: LD_INT 4
99362: PUSH
99363: EMPTY
99364: LIST
99365: LIST
99366: PUSH
99367: LD_INT 1
99369: NEG
99370: PUSH
99371: LD_INT 3
99373: PUSH
99374: EMPTY
99375: LIST
99376: LIST
99377: PUSH
99378: LD_INT 2
99380: PUSH
99381: LD_INT 5
99383: PUSH
99384: EMPTY
99385: LIST
99386: LIST
99387: PUSH
99388: LD_INT 2
99390: NEG
99391: PUSH
99392: LD_INT 3
99394: PUSH
99395: EMPTY
99396: LIST
99397: LIST
99398: PUSH
99399: LD_INT 3
99401: NEG
99402: PUSH
99403: LD_INT 0
99405: PUSH
99406: EMPTY
99407: LIST
99408: LIST
99409: PUSH
99410: LD_INT 3
99412: NEG
99413: PUSH
99414: LD_INT 1
99416: NEG
99417: PUSH
99418: EMPTY
99419: LIST
99420: LIST
99421: PUSH
99422: LD_INT 2
99424: NEG
99425: PUSH
99426: LD_INT 0
99428: PUSH
99429: EMPTY
99430: LIST
99431: LIST
99432: PUSH
99433: LD_INT 2
99435: NEG
99436: PUSH
99437: LD_INT 1
99439: PUSH
99440: EMPTY
99441: LIST
99442: LIST
99443: PUSH
99444: LD_INT 3
99446: NEG
99447: PUSH
99448: LD_INT 1
99450: PUSH
99451: EMPTY
99452: LIST
99453: LIST
99454: PUSH
99455: LD_INT 4
99457: NEG
99458: PUSH
99459: LD_INT 0
99461: PUSH
99462: EMPTY
99463: LIST
99464: LIST
99465: PUSH
99466: LD_INT 4
99468: NEG
99469: PUSH
99470: LD_INT 1
99472: NEG
99473: PUSH
99474: EMPTY
99475: LIST
99476: LIST
99477: PUSH
99478: LD_INT 4
99480: NEG
99481: PUSH
99482: LD_INT 2
99484: NEG
99485: PUSH
99486: EMPTY
99487: LIST
99488: LIST
99489: PUSH
99490: LD_INT 2
99492: NEG
99493: PUSH
99494: LD_INT 2
99496: PUSH
99497: EMPTY
99498: LIST
99499: LIST
99500: PUSH
99501: LD_INT 4
99503: NEG
99504: PUSH
99505: LD_INT 4
99507: NEG
99508: PUSH
99509: EMPTY
99510: LIST
99511: LIST
99512: PUSH
99513: LD_INT 4
99515: NEG
99516: PUSH
99517: LD_INT 5
99519: NEG
99520: PUSH
99521: EMPTY
99522: LIST
99523: LIST
99524: PUSH
99525: LD_INT 3
99527: NEG
99528: PUSH
99529: LD_INT 4
99531: NEG
99532: PUSH
99533: EMPTY
99534: LIST
99535: LIST
99536: PUSH
99537: LD_INT 3
99539: NEG
99540: PUSH
99541: LD_INT 3
99543: NEG
99544: PUSH
99545: EMPTY
99546: LIST
99547: LIST
99548: PUSH
99549: LD_INT 4
99551: NEG
99552: PUSH
99553: LD_INT 3
99555: NEG
99556: PUSH
99557: EMPTY
99558: LIST
99559: LIST
99560: PUSH
99561: LD_INT 5
99563: NEG
99564: PUSH
99565: LD_INT 4
99567: NEG
99568: PUSH
99569: EMPTY
99570: LIST
99571: LIST
99572: PUSH
99573: LD_INT 5
99575: NEG
99576: PUSH
99577: LD_INT 5
99579: NEG
99580: PUSH
99581: EMPTY
99582: LIST
99583: LIST
99584: PUSH
99585: LD_INT 3
99587: NEG
99588: PUSH
99589: LD_INT 5
99591: NEG
99592: PUSH
99593: EMPTY
99594: LIST
99595: LIST
99596: PUSH
99597: LD_INT 5
99599: NEG
99600: PUSH
99601: LD_INT 3
99603: NEG
99604: PUSH
99605: EMPTY
99606: LIST
99607: LIST
99608: PUSH
99609: EMPTY
99610: LIST
99611: LIST
99612: LIST
99613: LIST
99614: LIST
99615: LIST
99616: LIST
99617: LIST
99618: LIST
99619: LIST
99620: LIST
99621: LIST
99622: LIST
99623: LIST
99624: LIST
99625: LIST
99626: LIST
99627: LIST
99628: LIST
99629: LIST
99630: LIST
99631: LIST
99632: LIST
99633: LIST
99634: LIST
99635: LIST
99636: LIST
99637: LIST
99638: LIST
99639: LIST
99640: LIST
99641: LIST
99642: LIST
99643: LIST
99644: LIST
99645: LIST
99646: LIST
99647: LIST
99648: LIST
99649: LIST
99650: LIST
99651: LIST
99652: LIST
99653: LIST
99654: LIST
99655: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
99656: LD_ADDR_VAR 0 30
99660: PUSH
99661: LD_INT 4
99663: PUSH
99664: LD_INT 4
99666: PUSH
99667: EMPTY
99668: LIST
99669: LIST
99670: PUSH
99671: LD_INT 4
99673: PUSH
99674: LD_INT 3
99676: PUSH
99677: EMPTY
99678: LIST
99679: LIST
99680: PUSH
99681: LD_INT 5
99683: PUSH
99684: LD_INT 4
99686: PUSH
99687: EMPTY
99688: LIST
99689: LIST
99690: PUSH
99691: LD_INT 5
99693: PUSH
99694: LD_INT 5
99696: PUSH
99697: EMPTY
99698: LIST
99699: LIST
99700: PUSH
99701: LD_INT 4
99703: PUSH
99704: LD_INT 5
99706: PUSH
99707: EMPTY
99708: LIST
99709: LIST
99710: PUSH
99711: LD_INT 3
99713: PUSH
99714: LD_INT 4
99716: PUSH
99717: EMPTY
99718: LIST
99719: LIST
99720: PUSH
99721: LD_INT 3
99723: PUSH
99724: LD_INT 3
99726: PUSH
99727: EMPTY
99728: LIST
99729: LIST
99730: PUSH
99731: LD_INT 5
99733: PUSH
99734: LD_INT 3
99736: PUSH
99737: EMPTY
99738: LIST
99739: LIST
99740: PUSH
99741: LD_INT 3
99743: PUSH
99744: LD_INT 5
99746: PUSH
99747: EMPTY
99748: LIST
99749: LIST
99750: PUSH
99751: LD_INT 0
99753: PUSH
99754: LD_INT 3
99756: PUSH
99757: EMPTY
99758: LIST
99759: LIST
99760: PUSH
99761: LD_INT 0
99763: PUSH
99764: LD_INT 2
99766: PUSH
99767: EMPTY
99768: LIST
99769: LIST
99770: PUSH
99771: LD_INT 1
99773: PUSH
99774: LD_INT 3
99776: PUSH
99777: EMPTY
99778: LIST
99779: LIST
99780: PUSH
99781: LD_INT 1
99783: PUSH
99784: LD_INT 4
99786: PUSH
99787: EMPTY
99788: LIST
99789: LIST
99790: PUSH
99791: LD_INT 0
99793: PUSH
99794: LD_INT 4
99796: PUSH
99797: EMPTY
99798: LIST
99799: LIST
99800: PUSH
99801: LD_INT 1
99803: NEG
99804: PUSH
99805: LD_INT 3
99807: PUSH
99808: EMPTY
99809: LIST
99810: LIST
99811: PUSH
99812: LD_INT 1
99814: NEG
99815: PUSH
99816: LD_INT 2
99818: PUSH
99819: EMPTY
99820: LIST
99821: LIST
99822: PUSH
99823: LD_INT 2
99825: PUSH
99826: LD_INT 4
99828: PUSH
99829: EMPTY
99830: LIST
99831: LIST
99832: PUSH
99833: LD_INT 2
99835: NEG
99836: PUSH
99837: LD_INT 2
99839: PUSH
99840: EMPTY
99841: LIST
99842: LIST
99843: PUSH
99844: LD_INT 4
99846: NEG
99847: PUSH
99848: LD_INT 0
99850: PUSH
99851: EMPTY
99852: LIST
99853: LIST
99854: PUSH
99855: LD_INT 4
99857: NEG
99858: PUSH
99859: LD_INT 1
99861: NEG
99862: PUSH
99863: EMPTY
99864: LIST
99865: LIST
99866: PUSH
99867: LD_INT 3
99869: NEG
99870: PUSH
99871: LD_INT 0
99873: PUSH
99874: EMPTY
99875: LIST
99876: LIST
99877: PUSH
99878: LD_INT 3
99880: NEG
99881: PUSH
99882: LD_INT 1
99884: PUSH
99885: EMPTY
99886: LIST
99887: LIST
99888: PUSH
99889: LD_INT 4
99891: NEG
99892: PUSH
99893: LD_INT 1
99895: PUSH
99896: EMPTY
99897: LIST
99898: LIST
99899: PUSH
99900: LD_INT 5
99902: NEG
99903: PUSH
99904: LD_INT 0
99906: PUSH
99907: EMPTY
99908: LIST
99909: LIST
99910: PUSH
99911: LD_INT 5
99913: NEG
99914: PUSH
99915: LD_INT 1
99917: NEG
99918: PUSH
99919: EMPTY
99920: LIST
99921: LIST
99922: PUSH
99923: LD_INT 5
99925: NEG
99926: PUSH
99927: LD_INT 2
99929: NEG
99930: PUSH
99931: EMPTY
99932: LIST
99933: LIST
99934: PUSH
99935: LD_INT 3
99937: NEG
99938: PUSH
99939: LD_INT 2
99941: PUSH
99942: EMPTY
99943: LIST
99944: LIST
99945: PUSH
99946: LD_INT 3
99948: NEG
99949: PUSH
99950: LD_INT 3
99952: NEG
99953: PUSH
99954: EMPTY
99955: LIST
99956: LIST
99957: PUSH
99958: LD_INT 3
99960: NEG
99961: PUSH
99962: LD_INT 4
99964: NEG
99965: PUSH
99966: EMPTY
99967: LIST
99968: LIST
99969: PUSH
99970: LD_INT 2
99972: NEG
99973: PUSH
99974: LD_INT 3
99976: NEG
99977: PUSH
99978: EMPTY
99979: LIST
99980: LIST
99981: PUSH
99982: LD_INT 2
99984: NEG
99985: PUSH
99986: LD_INT 2
99988: NEG
99989: PUSH
99990: EMPTY
99991: LIST
99992: LIST
99993: PUSH
99994: LD_INT 3
99996: NEG
99997: PUSH
99998: LD_INT 2
100000: NEG
100001: PUSH
100002: EMPTY
100003: LIST
100004: LIST
100005: PUSH
100006: LD_INT 4
100008: NEG
100009: PUSH
100010: LD_INT 3
100012: NEG
100013: PUSH
100014: EMPTY
100015: LIST
100016: LIST
100017: PUSH
100018: LD_INT 4
100020: NEG
100021: PUSH
100022: LD_INT 4
100024: NEG
100025: PUSH
100026: EMPTY
100027: LIST
100028: LIST
100029: PUSH
100030: LD_INT 2
100032: NEG
100033: PUSH
100034: LD_INT 4
100036: NEG
100037: PUSH
100038: EMPTY
100039: LIST
100040: LIST
100041: PUSH
100042: LD_INT 4
100044: NEG
100045: PUSH
100046: LD_INT 2
100048: NEG
100049: PUSH
100050: EMPTY
100051: LIST
100052: LIST
100053: PUSH
100054: LD_INT 0
100056: PUSH
100057: LD_INT 4
100059: NEG
100060: PUSH
100061: EMPTY
100062: LIST
100063: LIST
100064: PUSH
100065: LD_INT 0
100067: PUSH
100068: LD_INT 5
100070: NEG
100071: PUSH
100072: EMPTY
100073: LIST
100074: LIST
100075: PUSH
100076: LD_INT 1
100078: PUSH
100079: LD_INT 4
100081: NEG
100082: PUSH
100083: EMPTY
100084: LIST
100085: LIST
100086: PUSH
100087: LD_INT 1
100089: PUSH
100090: LD_INT 3
100092: NEG
100093: PUSH
100094: EMPTY
100095: LIST
100096: LIST
100097: PUSH
100098: LD_INT 0
100100: PUSH
100101: LD_INT 3
100103: NEG
100104: PUSH
100105: EMPTY
100106: LIST
100107: LIST
100108: PUSH
100109: LD_INT 1
100111: NEG
100112: PUSH
100113: LD_INT 4
100115: NEG
100116: PUSH
100117: EMPTY
100118: LIST
100119: LIST
100120: PUSH
100121: LD_INT 1
100123: NEG
100124: PUSH
100125: LD_INT 5
100127: NEG
100128: PUSH
100129: EMPTY
100130: LIST
100131: LIST
100132: PUSH
100133: LD_INT 2
100135: PUSH
100136: LD_INT 3
100138: NEG
100139: PUSH
100140: EMPTY
100141: LIST
100142: LIST
100143: PUSH
100144: LD_INT 2
100146: NEG
100147: PUSH
100148: LD_INT 5
100150: NEG
100151: PUSH
100152: EMPTY
100153: LIST
100154: LIST
100155: PUSH
100156: EMPTY
100157: LIST
100158: LIST
100159: LIST
100160: LIST
100161: LIST
100162: LIST
100163: LIST
100164: LIST
100165: LIST
100166: LIST
100167: LIST
100168: LIST
100169: LIST
100170: LIST
100171: LIST
100172: LIST
100173: LIST
100174: LIST
100175: LIST
100176: LIST
100177: LIST
100178: LIST
100179: LIST
100180: LIST
100181: LIST
100182: LIST
100183: LIST
100184: LIST
100185: LIST
100186: LIST
100187: LIST
100188: LIST
100189: LIST
100190: LIST
100191: LIST
100192: LIST
100193: LIST
100194: LIST
100195: LIST
100196: LIST
100197: LIST
100198: LIST
100199: LIST
100200: LIST
100201: LIST
100202: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
100203: LD_ADDR_VAR 0 31
100207: PUSH
100208: LD_INT 0
100210: PUSH
100211: LD_INT 4
100213: PUSH
100214: EMPTY
100215: LIST
100216: LIST
100217: PUSH
100218: LD_INT 0
100220: PUSH
100221: LD_INT 3
100223: PUSH
100224: EMPTY
100225: LIST
100226: LIST
100227: PUSH
100228: LD_INT 1
100230: PUSH
100231: LD_INT 4
100233: PUSH
100234: EMPTY
100235: LIST
100236: LIST
100237: PUSH
100238: LD_INT 1
100240: PUSH
100241: LD_INT 5
100243: PUSH
100244: EMPTY
100245: LIST
100246: LIST
100247: PUSH
100248: LD_INT 0
100250: PUSH
100251: LD_INT 5
100253: PUSH
100254: EMPTY
100255: LIST
100256: LIST
100257: PUSH
100258: LD_INT 1
100260: NEG
100261: PUSH
100262: LD_INT 4
100264: PUSH
100265: EMPTY
100266: LIST
100267: LIST
100268: PUSH
100269: LD_INT 1
100271: NEG
100272: PUSH
100273: LD_INT 3
100275: PUSH
100276: EMPTY
100277: LIST
100278: LIST
100279: PUSH
100280: LD_INT 2
100282: PUSH
100283: LD_INT 5
100285: PUSH
100286: EMPTY
100287: LIST
100288: LIST
100289: PUSH
100290: LD_INT 2
100292: NEG
100293: PUSH
100294: LD_INT 3
100296: PUSH
100297: EMPTY
100298: LIST
100299: LIST
100300: PUSH
100301: LD_INT 3
100303: NEG
100304: PUSH
100305: LD_INT 0
100307: PUSH
100308: EMPTY
100309: LIST
100310: LIST
100311: PUSH
100312: LD_INT 3
100314: NEG
100315: PUSH
100316: LD_INT 1
100318: NEG
100319: PUSH
100320: EMPTY
100321: LIST
100322: LIST
100323: PUSH
100324: LD_INT 2
100326: NEG
100327: PUSH
100328: LD_INT 0
100330: PUSH
100331: EMPTY
100332: LIST
100333: LIST
100334: PUSH
100335: LD_INT 2
100337: NEG
100338: PUSH
100339: LD_INT 1
100341: PUSH
100342: EMPTY
100343: LIST
100344: LIST
100345: PUSH
100346: LD_INT 3
100348: NEG
100349: PUSH
100350: LD_INT 1
100352: PUSH
100353: EMPTY
100354: LIST
100355: LIST
100356: PUSH
100357: LD_INT 4
100359: NEG
100360: PUSH
100361: LD_INT 0
100363: PUSH
100364: EMPTY
100365: LIST
100366: LIST
100367: PUSH
100368: LD_INT 4
100370: NEG
100371: PUSH
100372: LD_INT 1
100374: NEG
100375: PUSH
100376: EMPTY
100377: LIST
100378: LIST
100379: PUSH
100380: LD_INT 4
100382: NEG
100383: PUSH
100384: LD_INT 2
100386: NEG
100387: PUSH
100388: EMPTY
100389: LIST
100390: LIST
100391: PUSH
100392: LD_INT 2
100394: NEG
100395: PUSH
100396: LD_INT 2
100398: PUSH
100399: EMPTY
100400: LIST
100401: LIST
100402: PUSH
100403: LD_INT 4
100405: NEG
100406: PUSH
100407: LD_INT 4
100409: NEG
100410: PUSH
100411: EMPTY
100412: LIST
100413: LIST
100414: PUSH
100415: LD_INT 4
100417: NEG
100418: PUSH
100419: LD_INT 5
100421: NEG
100422: PUSH
100423: EMPTY
100424: LIST
100425: LIST
100426: PUSH
100427: LD_INT 3
100429: NEG
100430: PUSH
100431: LD_INT 4
100433: NEG
100434: PUSH
100435: EMPTY
100436: LIST
100437: LIST
100438: PUSH
100439: LD_INT 3
100441: NEG
100442: PUSH
100443: LD_INT 3
100445: NEG
100446: PUSH
100447: EMPTY
100448: LIST
100449: LIST
100450: PUSH
100451: LD_INT 4
100453: NEG
100454: PUSH
100455: LD_INT 3
100457: NEG
100458: PUSH
100459: EMPTY
100460: LIST
100461: LIST
100462: PUSH
100463: LD_INT 5
100465: NEG
100466: PUSH
100467: LD_INT 4
100469: NEG
100470: PUSH
100471: EMPTY
100472: LIST
100473: LIST
100474: PUSH
100475: LD_INT 5
100477: NEG
100478: PUSH
100479: LD_INT 5
100481: NEG
100482: PUSH
100483: EMPTY
100484: LIST
100485: LIST
100486: PUSH
100487: LD_INT 3
100489: NEG
100490: PUSH
100491: LD_INT 5
100493: NEG
100494: PUSH
100495: EMPTY
100496: LIST
100497: LIST
100498: PUSH
100499: LD_INT 5
100501: NEG
100502: PUSH
100503: LD_INT 3
100505: NEG
100506: PUSH
100507: EMPTY
100508: LIST
100509: LIST
100510: PUSH
100511: LD_INT 0
100513: PUSH
100514: LD_INT 3
100516: NEG
100517: PUSH
100518: EMPTY
100519: LIST
100520: LIST
100521: PUSH
100522: LD_INT 0
100524: PUSH
100525: LD_INT 4
100527: NEG
100528: PUSH
100529: EMPTY
100530: LIST
100531: LIST
100532: PUSH
100533: LD_INT 1
100535: PUSH
100536: LD_INT 3
100538: NEG
100539: PUSH
100540: EMPTY
100541: LIST
100542: LIST
100543: PUSH
100544: LD_INT 1
100546: PUSH
100547: LD_INT 2
100549: NEG
100550: PUSH
100551: EMPTY
100552: LIST
100553: LIST
100554: PUSH
100555: LD_INT 0
100557: PUSH
100558: LD_INT 2
100560: NEG
100561: PUSH
100562: EMPTY
100563: LIST
100564: LIST
100565: PUSH
100566: LD_INT 1
100568: NEG
100569: PUSH
100570: LD_INT 3
100572: NEG
100573: PUSH
100574: EMPTY
100575: LIST
100576: LIST
100577: PUSH
100578: LD_INT 1
100580: NEG
100581: PUSH
100582: LD_INT 4
100584: NEG
100585: PUSH
100586: EMPTY
100587: LIST
100588: LIST
100589: PUSH
100590: LD_INT 2
100592: PUSH
100593: LD_INT 2
100595: NEG
100596: PUSH
100597: EMPTY
100598: LIST
100599: LIST
100600: PUSH
100601: LD_INT 2
100603: NEG
100604: PUSH
100605: LD_INT 4
100607: NEG
100608: PUSH
100609: EMPTY
100610: LIST
100611: LIST
100612: PUSH
100613: LD_INT 4
100615: PUSH
100616: LD_INT 0
100618: PUSH
100619: EMPTY
100620: LIST
100621: LIST
100622: PUSH
100623: LD_INT 4
100625: PUSH
100626: LD_INT 1
100628: NEG
100629: PUSH
100630: EMPTY
100631: LIST
100632: LIST
100633: PUSH
100634: LD_INT 5
100636: PUSH
100637: LD_INT 0
100639: PUSH
100640: EMPTY
100641: LIST
100642: LIST
100643: PUSH
100644: LD_INT 5
100646: PUSH
100647: LD_INT 1
100649: PUSH
100650: EMPTY
100651: LIST
100652: LIST
100653: PUSH
100654: LD_INT 4
100656: PUSH
100657: LD_INT 1
100659: PUSH
100660: EMPTY
100661: LIST
100662: LIST
100663: PUSH
100664: LD_INT 3
100666: PUSH
100667: LD_INT 0
100669: PUSH
100670: EMPTY
100671: LIST
100672: LIST
100673: PUSH
100674: LD_INT 3
100676: PUSH
100677: LD_INT 1
100679: NEG
100680: PUSH
100681: EMPTY
100682: LIST
100683: LIST
100684: PUSH
100685: LD_INT 3
100687: PUSH
100688: LD_INT 2
100690: NEG
100691: PUSH
100692: EMPTY
100693: LIST
100694: LIST
100695: PUSH
100696: LD_INT 5
100698: PUSH
100699: LD_INT 2
100701: PUSH
100702: EMPTY
100703: LIST
100704: LIST
100705: PUSH
100706: EMPTY
100707: LIST
100708: LIST
100709: LIST
100710: LIST
100711: LIST
100712: LIST
100713: LIST
100714: LIST
100715: LIST
100716: LIST
100717: LIST
100718: LIST
100719: LIST
100720: LIST
100721: LIST
100722: LIST
100723: LIST
100724: LIST
100725: LIST
100726: LIST
100727: LIST
100728: LIST
100729: LIST
100730: LIST
100731: LIST
100732: LIST
100733: LIST
100734: LIST
100735: LIST
100736: LIST
100737: LIST
100738: LIST
100739: LIST
100740: LIST
100741: LIST
100742: LIST
100743: LIST
100744: LIST
100745: LIST
100746: LIST
100747: LIST
100748: LIST
100749: LIST
100750: LIST
100751: LIST
100752: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
100753: LD_ADDR_VAR 0 32
100757: PUSH
100758: LD_INT 4
100760: NEG
100761: PUSH
100762: LD_INT 0
100764: PUSH
100765: EMPTY
100766: LIST
100767: LIST
100768: PUSH
100769: LD_INT 4
100771: NEG
100772: PUSH
100773: LD_INT 1
100775: NEG
100776: PUSH
100777: EMPTY
100778: LIST
100779: LIST
100780: PUSH
100781: LD_INT 3
100783: NEG
100784: PUSH
100785: LD_INT 0
100787: PUSH
100788: EMPTY
100789: LIST
100790: LIST
100791: PUSH
100792: LD_INT 3
100794: NEG
100795: PUSH
100796: LD_INT 1
100798: PUSH
100799: EMPTY
100800: LIST
100801: LIST
100802: PUSH
100803: LD_INT 4
100805: NEG
100806: PUSH
100807: LD_INT 1
100809: PUSH
100810: EMPTY
100811: LIST
100812: LIST
100813: PUSH
100814: LD_INT 5
100816: NEG
100817: PUSH
100818: LD_INT 0
100820: PUSH
100821: EMPTY
100822: LIST
100823: LIST
100824: PUSH
100825: LD_INT 5
100827: NEG
100828: PUSH
100829: LD_INT 1
100831: NEG
100832: PUSH
100833: EMPTY
100834: LIST
100835: LIST
100836: PUSH
100837: LD_INT 5
100839: NEG
100840: PUSH
100841: LD_INT 2
100843: NEG
100844: PUSH
100845: EMPTY
100846: LIST
100847: LIST
100848: PUSH
100849: LD_INT 3
100851: NEG
100852: PUSH
100853: LD_INT 2
100855: PUSH
100856: EMPTY
100857: LIST
100858: LIST
100859: PUSH
100860: LD_INT 3
100862: NEG
100863: PUSH
100864: LD_INT 3
100866: NEG
100867: PUSH
100868: EMPTY
100869: LIST
100870: LIST
100871: PUSH
100872: LD_INT 3
100874: NEG
100875: PUSH
100876: LD_INT 4
100878: NEG
100879: PUSH
100880: EMPTY
100881: LIST
100882: LIST
100883: PUSH
100884: LD_INT 2
100886: NEG
100887: PUSH
100888: LD_INT 3
100890: NEG
100891: PUSH
100892: EMPTY
100893: LIST
100894: LIST
100895: PUSH
100896: LD_INT 2
100898: NEG
100899: PUSH
100900: LD_INT 2
100902: NEG
100903: PUSH
100904: EMPTY
100905: LIST
100906: LIST
100907: PUSH
100908: LD_INT 3
100910: NEG
100911: PUSH
100912: LD_INT 2
100914: NEG
100915: PUSH
100916: EMPTY
100917: LIST
100918: LIST
100919: PUSH
100920: LD_INT 4
100922: NEG
100923: PUSH
100924: LD_INT 3
100926: NEG
100927: PUSH
100928: EMPTY
100929: LIST
100930: LIST
100931: PUSH
100932: LD_INT 4
100934: NEG
100935: PUSH
100936: LD_INT 4
100938: NEG
100939: PUSH
100940: EMPTY
100941: LIST
100942: LIST
100943: PUSH
100944: LD_INT 2
100946: NEG
100947: PUSH
100948: LD_INT 4
100950: NEG
100951: PUSH
100952: EMPTY
100953: LIST
100954: LIST
100955: PUSH
100956: LD_INT 4
100958: NEG
100959: PUSH
100960: LD_INT 2
100962: NEG
100963: PUSH
100964: EMPTY
100965: LIST
100966: LIST
100967: PUSH
100968: LD_INT 0
100970: PUSH
100971: LD_INT 4
100973: NEG
100974: PUSH
100975: EMPTY
100976: LIST
100977: LIST
100978: PUSH
100979: LD_INT 0
100981: PUSH
100982: LD_INT 5
100984: NEG
100985: PUSH
100986: EMPTY
100987: LIST
100988: LIST
100989: PUSH
100990: LD_INT 1
100992: PUSH
100993: LD_INT 4
100995: NEG
100996: PUSH
100997: EMPTY
100998: LIST
100999: LIST
101000: PUSH
101001: LD_INT 1
101003: PUSH
101004: LD_INT 3
101006: NEG
101007: PUSH
101008: EMPTY
101009: LIST
101010: LIST
101011: PUSH
101012: LD_INT 0
101014: PUSH
101015: LD_INT 3
101017: NEG
101018: PUSH
101019: EMPTY
101020: LIST
101021: LIST
101022: PUSH
101023: LD_INT 1
101025: NEG
101026: PUSH
101027: LD_INT 4
101029: NEG
101030: PUSH
101031: EMPTY
101032: LIST
101033: LIST
101034: PUSH
101035: LD_INT 1
101037: NEG
101038: PUSH
101039: LD_INT 5
101041: NEG
101042: PUSH
101043: EMPTY
101044: LIST
101045: LIST
101046: PUSH
101047: LD_INT 2
101049: PUSH
101050: LD_INT 3
101052: NEG
101053: PUSH
101054: EMPTY
101055: LIST
101056: LIST
101057: PUSH
101058: LD_INT 2
101060: NEG
101061: PUSH
101062: LD_INT 5
101064: NEG
101065: PUSH
101066: EMPTY
101067: LIST
101068: LIST
101069: PUSH
101070: LD_INT 3
101072: PUSH
101073: LD_INT 0
101075: PUSH
101076: EMPTY
101077: LIST
101078: LIST
101079: PUSH
101080: LD_INT 3
101082: PUSH
101083: LD_INT 1
101085: NEG
101086: PUSH
101087: EMPTY
101088: LIST
101089: LIST
101090: PUSH
101091: LD_INT 4
101093: PUSH
101094: LD_INT 0
101096: PUSH
101097: EMPTY
101098: LIST
101099: LIST
101100: PUSH
101101: LD_INT 4
101103: PUSH
101104: LD_INT 1
101106: PUSH
101107: EMPTY
101108: LIST
101109: LIST
101110: PUSH
101111: LD_INT 3
101113: PUSH
101114: LD_INT 1
101116: PUSH
101117: EMPTY
101118: LIST
101119: LIST
101120: PUSH
101121: LD_INT 2
101123: PUSH
101124: LD_INT 0
101126: PUSH
101127: EMPTY
101128: LIST
101129: LIST
101130: PUSH
101131: LD_INT 2
101133: PUSH
101134: LD_INT 1
101136: NEG
101137: PUSH
101138: EMPTY
101139: LIST
101140: LIST
101141: PUSH
101142: LD_INT 2
101144: PUSH
101145: LD_INT 2
101147: NEG
101148: PUSH
101149: EMPTY
101150: LIST
101151: LIST
101152: PUSH
101153: LD_INT 4
101155: PUSH
101156: LD_INT 2
101158: PUSH
101159: EMPTY
101160: LIST
101161: LIST
101162: PUSH
101163: LD_INT 4
101165: PUSH
101166: LD_INT 4
101168: PUSH
101169: EMPTY
101170: LIST
101171: LIST
101172: PUSH
101173: LD_INT 4
101175: PUSH
101176: LD_INT 3
101178: PUSH
101179: EMPTY
101180: LIST
101181: LIST
101182: PUSH
101183: LD_INT 5
101185: PUSH
101186: LD_INT 4
101188: PUSH
101189: EMPTY
101190: LIST
101191: LIST
101192: PUSH
101193: LD_INT 5
101195: PUSH
101196: LD_INT 5
101198: PUSH
101199: EMPTY
101200: LIST
101201: LIST
101202: PUSH
101203: LD_INT 4
101205: PUSH
101206: LD_INT 5
101208: PUSH
101209: EMPTY
101210: LIST
101211: LIST
101212: PUSH
101213: LD_INT 3
101215: PUSH
101216: LD_INT 4
101218: PUSH
101219: EMPTY
101220: LIST
101221: LIST
101222: PUSH
101223: LD_INT 3
101225: PUSH
101226: LD_INT 3
101228: PUSH
101229: EMPTY
101230: LIST
101231: LIST
101232: PUSH
101233: LD_INT 5
101235: PUSH
101236: LD_INT 3
101238: PUSH
101239: EMPTY
101240: LIST
101241: LIST
101242: PUSH
101243: LD_INT 3
101245: PUSH
101246: LD_INT 5
101248: PUSH
101249: EMPTY
101250: LIST
101251: LIST
101252: PUSH
101253: EMPTY
101254: LIST
101255: LIST
101256: LIST
101257: LIST
101258: LIST
101259: LIST
101260: LIST
101261: LIST
101262: LIST
101263: LIST
101264: LIST
101265: LIST
101266: LIST
101267: LIST
101268: LIST
101269: LIST
101270: LIST
101271: LIST
101272: LIST
101273: LIST
101274: LIST
101275: LIST
101276: LIST
101277: LIST
101278: LIST
101279: LIST
101280: LIST
101281: LIST
101282: LIST
101283: LIST
101284: LIST
101285: LIST
101286: LIST
101287: LIST
101288: LIST
101289: LIST
101290: LIST
101291: LIST
101292: LIST
101293: LIST
101294: LIST
101295: LIST
101296: LIST
101297: LIST
101298: LIST
101299: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
101300: LD_ADDR_VAR 0 33
101304: PUSH
101305: LD_INT 4
101307: NEG
101308: PUSH
101309: LD_INT 4
101311: NEG
101312: PUSH
101313: EMPTY
101314: LIST
101315: LIST
101316: PUSH
101317: LD_INT 4
101319: NEG
101320: PUSH
101321: LD_INT 5
101323: NEG
101324: PUSH
101325: EMPTY
101326: LIST
101327: LIST
101328: PUSH
101329: LD_INT 3
101331: NEG
101332: PUSH
101333: LD_INT 4
101335: NEG
101336: PUSH
101337: EMPTY
101338: LIST
101339: LIST
101340: PUSH
101341: LD_INT 3
101343: NEG
101344: PUSH
101345: LD_INT 3
101347: NEG
101348: PUSH
101349: EMPTY
101350: LIST
101351: LIST
101352: PUSH
101353: LD_INT 4
101355: NEG
101356: PUSH
101357: LD_INT 3
101359: NEG
101360: PUSH
101361: EMPTY
101362: LIST
101363: LIST
101364: PUSH
101365: LD_INT 5
101367: NEG
101368: PUSH
101369: LD_INT 4
101371: NEG
101372: PUSH
101373: EMPTY
101374: LIST
101375: LIST
101376: PUSH
101377: LD_INT 5
101379: NEG
101380: PUSH
101381: LD_INT 5
101383: NEG
101384: PUSH
101385: EMPTY
101386: LIST
101387: LIST
101388: PUSH
101389: LD_INT 3
101391: NEG
101392: PUSH
101393: LD_INT 5
101395: NEG
101396: PUSH
101397: EMPTY
101398: LIST
101399: LIST
101400: PUSH
101401: LD_INT 5
101403: NEG
101404: PUSH
101405: LD_INT 3
101407: NEG
101408: PUSH
101409: EMPTY
101410: LIST
101411: LIST
101412: PUSH
101413: LD_INT 0
101415: PUSH
101416: LD_INT 3
101418: NEG
101419: PUSH
101420: EMPTY
101421: LIST
101422: LIST
101423: PUSH
101424: LD_INT 0
101426: PUSH
101427: LD_INT 4
101429: NEG
101430: PUSH
101431: EMPTY
101432: LIST
101433: LIST
101434: PUSH
101435: LD_INT 1
101437: PUSH
101438: LD_INT 3
101440: NEG
101441: PUSH
101442: EMPTY
101443: LIST
101444: LIST
101445: PUSH
101446: LD_INT 1
101448: PUSH
101449: LD_INT 2
101451: NEG
101452: PUSH
101453: EMPTY
101454: LIST
101455: LIST
101456: PUSH
101457: LD_INT 0
101459: PUSH
101460: LD_INT 2
101462: NEG
101463: PUSH
101464: EMPTY
101465: LIST
101466: LIST
101467: PUSH
101468: LD_INT 1
101470: NEG
101471: PUSH
101472: LD_INT 3
101474: NEG
101475: PUSH
101476: EMPTY
101477: LIST
101478: LIST
101479: PUSH
101480: LD_INT 1
101482: NEG
101483: PUSH
101484: LD_INT 4
101486: NEG
101487: PUSH
101488: EMPTY
101489: LIST
101490: LIST
101491: PUSH
101492: LD_INT 2
101494: PUSH
101495: LD_INT 2
101497: NEG
101498: PUSH
101499: EMPTY
101500: LIST
101501: LIST
101502: PUSH
101503: LD_INT 2
101505: NEG
101506: PUSH
101507: LD_INT 4
101509: NEG
101510: PUSH
101511: EMPTY
101512: LIST
101513: LIST
101514: PUSH
101515: LD_INT 4
101517: PUSH
101518: LD_INT 0
101520: PUSH
101521: EMPTY
101522: LIST
101523: LIST
101524: PUSH
101525: LD_INT 4
101527: PUSH
101528: LD_INT 1
101530: NEG
101531: PUSH
101532: EMPTY
101533: LIST
101534: LIST
101535: PUSH
101536: LD_INT 5
101538: PUSH
101539: LD_INT 0
101541: PUSH
101542: EMPTY
101543: LIST
101544: LIST
101545: PUSH
101546: LD_INT 5
101548: PUSH
101549: LD_INT 1
101551: PUSH
101552: EMPTY
101553: LIST
101554: LIST
101555: PUSH
101556: LD_INT 4
101558: PUSH
101559: LD_INT 1
101561: PUSH
101562: EMPTY
101563: LIST
101564: LIST
101565: PUSH
101566: LD_INT 3
101568: PUSH
101569: LD_INT 0
101571: PUSH
101572: EMPTY
101573: LIST
101574: LIST
101575: PUSH
101576: LD_INT 3
101578: PUSH
101579: LD_INT 1
101581: NEG
101582: PUSH
101583: EMPTY
101584: LIST
101585: LIST
101586: PUSH
101587: LD_INT 3
101589: PUSH
101590: LD_INT 2
101592: NEG
101593: PUSH
101594: EMPTY
101595: LIST
101596: LIST
101597: PUSH
101598: LD_INT 5
101600: PUSH
101601: LD_INT 2
101603: PUSH
101604: EMPTY
101605: LIST
101606: LIST
101607: PUSH
101608: LD_INT 3
101610: PUSH
101611: LD_INT 3
101613: PUSH
101614: EMPTY
101615: LIST
101616: LIST
101617: PUSH
101618: LD_INT 3
101620: PUSH
101621: LD_INT 2
101623: PUSH
101624: EMPTY
101625: LIST
101626: LIST
101627: PUSH
101628: LD_INT 4
101630: PUSH
101631: LD_INT 3
101633: PUSH
101634: EMPTY
101635: LIST
101636: LIST
101637: PUSH
101638: LD_INT 4
101640: PUSH
101641: LD_INT 4
101643: PUSH
101644: EMPTY
101645: LIST
101646: LIST
101647: PUSH
101648: LD_INT 3
101650: PUSH
101651: LD_INT 4
101653: PUSH
101654: EMPTY
101655: LIST
101656: LIST
101657: PUSH
101658: LD_INT 2
101660: PUSH
101661: LD_INT 3
101663: PUSH
101664: EMPTY
101665: LIST
101666: LIST
101667: PUSH
101668: LD_INT 2
101670: PUSH
101671: LD_INT 2
101673: PUSH
101674: EMPTY
101675: LIST
101676: LIST
101677: PUSH
101678: LD_INT 4
101680: PUSH
101681: LD_INT 2
101683: PUSH
101684: EMPTY
101685: LIST
101686: LIST
101687: PUSH
101688: LD_INT 2
101690: PUSH
101691: LD_INT 4
101693: PUSH
101694: EMPTY
101695: LIST
101696: LIST
101697: PUSH
101698: LD_INT 0
101700: PUSH
101701: LD_INT 4
101703: PUSH
101704: EMPTY
101705: LIST
101706: LIST
101707: PUSH
101708: LD_INT 0
101710: PUSH
101711: LD_INT 3
101713: PUSH
101714: EMPTY
101715: LIST
101716: LIST
101717: PUSH
101718: LD_INT 1
101720: PUSH
101721: LD_INT 4
101723: PUSH
101724: EMPTY
101725: LIST
101726: LIST
101727: PUSH
101728: LD_INT 1
101730: PUSH
101731: LD_INT 5
101733: PUSH
101734: EMPTY
101735: LIST
101736: LIST
101737: PUSH
101738: LD_INT 0
101740: PUSH
101741: LD_INT 5
101743: PUSH
101744: EMPTY
101745: LIST
101746: LIST
101747: PUSH
101748: LD_INT 1
101750: NEG
101751: PUSH
101752: LD_INT 4
101754: PUSH
101755: EMPTY
101756: LIST
101757: LIST
101758: PUSH
101759: LD_INT 1
101761: NEG
101762: PUSH
101763: LD_INT 3
101765: PUSH
101766: EMPTY
101767: LIST
101768: LIST
101769: PUSH
101770: LD_INT 2
101772: PUSH
101773: LD_INT 5
101775: PUSH
101776: EMPTY
101777: LIST
101778: LIST
101779: PUSH
101780: LD_INT 2
101782: NEG
101783: PUSH
101784: LD_INT 3
101786: PUSH
101787: EMPTY
101788: LIST
101789: LIST
101790: PUSH
101791: EMPTY
101792: LIST
101793: LIST
101794: LIST
101795: LIST
101796: LIST
101797: LIST
101798: LIST
101799: LIST
101800: LIST
101801: LIST
101802: LIST
101803: LIST
101804: LIST
101805: LIST
101806: LIST
101807: LIST
101808: LIST
101809: LIST
101810: LIST
101811: LIST
101812: LIST
101813: LIST
101814: LIST
101815: LIST
101816: LIST
101817: LIST
101818: LIST
101819: LIST
101820: LIST
101821: LIST
101822: LIST
101823: LIST
101824: LIST
101825: LIST
101826: LIST
101827: LIST
101828: LIST
101829: LIST
101830: LIST
101831: LIST
101832: LIST
101833: LIST
101834: LIST
101835: LIST
101836: LIST
101837: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
101838: LD_ADDR_VAR 0 34
101842: PUSH
101843: LD_INT 0
101845: PUSH
101846: LD_INT 4
101848: NEG
101849: PUSH
101850: EMPTY
101851: LIST
101852: LIST
101853: PUSH
101854: LD_INT 0
101856: PUSH
101857: LD_INT 5
101859: NEG
101860: PUSH
101861: EMPTY
101862: LIST
101863: LIST
101864: PUSH
101865: LD_INT 1
101867: PUSH
101868: LD_INT 4
101870: NEG
101871: PUSH
101872: EMPTY
101873: LIST
101874: LIST
101875: PUSH
101876: LD_INT 1
101878: PUSH
101879: LD_INT 3
101881: NEG
101882: PUSH
101883: EMPTY
101884: LIST
101885: LIST
101886: PUSH
101887: LD_INT 0
101889: PUSH
101890: LD_INT 3
101892: NEG
101893: PUSH
101894: EMPTY
101895: LIST
101896: LIST
101897: PUSH
101898: LD_INT 1
101900: NEG
101901: PUSH
101902: LD_INT 4
101904: NEG
101905: PUSH
101906: EMPTY
101907: LIST
101908: LIST
101909: PUSH
101910: LD_INT 1
101912: NEG
101913: PUSH
101914: LD_INT 5
101916: NEG
101917: PUSH
101918: EMPTY
101919: LIST
101920: LIST
101921: PUSH
101922: LD_INT 2
101924: PUSH
101925: LD_INT 3
101927: NEG
101928: PUSH
101929: EMPTY
101930: LIST
101931: LIST
101932: PUSH
101933: LD_INT 2
101935: NEG
101936: PUSH
101937: LD_INT 5
101939: NEG
101940: PUSH
101941: EMPTY
101942: LIST
101943: LIST
101944: PUSH
101945: LD_INT 3
101947: PUSH
101948: LD_INT 0
101950: PUSH
101951: EMPTY
101952: LIST
101953: LIST
101954: PUSH
101955: LD_INT 3
101957: PUSH
101958: LD_INT 1
101960: NEG
101961: PUSH
101962: EMPTY
101963: LIST
101964: LIST
101965: PUSH
101966: LD_INT 4
101968: PUSH
101969: LD_INT 0
101971: PUSH
101972: EMPTY
101973: LIST
101974: LIST
101975: PUSH
101976: LD_INT 4
101978: PUSH
101979: LD_INT 1
101981: PUSH
101982: EMPTY
101983: LIST
101984: LIST
101985: PUSH
101986: LD_INT 3
101988: PUSH
101989: LD_INT 1
101991: PUSH
101992: EMPTY
101993: LIST
101994: LIST
101995: PUSH
101996: LD_INT 2
101998: PUSH
101999: LD_INT 0
102001: PUSH
102002: EMPTY
102003: LIST
102004: LIST
102005: PUSH
102006: LD_INT 2
102008: PUSH
102009: LD_INT 1
102011: NEG
102012: PUSH
102013: EMPTY
102014: LIST
102015: LIST
102016: PUSH
102017: LD_INT 2
102019: PUSH
102020: LD_INT 2
102022: NEG
102023: PUSH
102024: EMPTY
102025: LIST
102026: LIST
102027: PUSH
102028: LD_INT 4
102030: PUSH
102031: LD_INT 2
102033: PUSH
102034: EMPTY
102035: LIST
102036: LIST
102037: PUSH
102038: LD_INT 4
102040: PUSH
102041: LD_INT 4
102043: PUSH
102044: EMPTY
102045: LIST
102046: LIST
102047: PUSH
102048: LD_INT 4
102050: PUSH
102051: LD_INT 3
102053: PUSH
102054: EMPTY
102055: LIST
102056: LIST
102057: PUSH
102058: LD_INT 5
102060: PUSH
102061: LD_INT 4
102063: PUSH
102064: EMPTY
102065: LIST
102066: LIST
102067: PUSH
102068: LD_INT 5
102070: PUSH
102071: LD_INT 5
102073: PUSH
102074: EMPTY
102075: LIST
102076: LIST
102077: PUSH
102078: LD_INT 4
102080: PUSH
102081: LD_INT 5
102083: PUSH
102084: EMPTY
102085: LIST
102086: LIST
102087: PUSH
102088: LD_INT 3
102090: PUSH
102091: LD_INT 4
102093: PUSH
102094: EMPTY
102095: LIST
102096: LIST
102097: PUSH
102098: LD_INT 3
102100: PUSH
102101: LD_INT 3
102103: PUSH
102104: EMPTY
102105: LIST
102106: LIST
102107: PUSH
102108: LD_INT 5
102110: PUSH
102111: LD_INT 3
102113: PUSH
102114: EMPTY
102115: LIST
102116: LIST
102117: PUSH
102118: LD_INT 3
102120: PUSH
102121: LD_INT 5
102123: PUSH
102124: EMPTY
102125: LIST
102126: LIST
102127: PUSH
102128: LD_INT 0
102130: PUSH
102131: LD_INT 3
102133: PUSH
102134: EMPTY
102135: LIST
102136: LIST
102137: PUSH
102138: LD_INT 0
102140: PUSH
102141: LD_INT 2
102143: PUSH
102144: EMPTY
102145: LIST
102146: LIST
102147: PUSH
102148: LD_INT 1
102150: PUSH
102151: LD_INT 3
102153: PUSH
102154: EMPTY
102155: LIST
102156: LIST
102157: PUSH
102158: LD_INT 1
102160: PUSH
102161: LD_INT 4
102163: PUSH
102164: EMPTY
102165: LIST
102166: LIST
102167: PUSH
102168: LD_INT 0
102170: PUSH
102171: LD_INT 4
102173: PUSH
102174: EMPTY
102175: LIST
102176: LIST
102177: PUSH
102178: LD_INT 1
102180: NEG
102181: PUSH
102182: LD_INT 3
102184: PUSH
102185: EMPTY
102186: LIST
102187: LIST
102188: PUSH
102189: LD_INT 1
102191: NEG
102192: PUSH
102193: LD_INT 2
102195: PUSH
102196: EMPTY
102197: LIST
102198: LIST
102199: PUSH
102200: LD_INT 2
102202: PUSH
102203: LD_INT 4
102205: PUSH
102206: EMPTY
102207: LIST
102208: LIST
102209: PUSH
102210: LD_INT 2
102212: NEG
102213: PUSH
102214: LD_INT 2
102216: PUSH
102217: EMPTY
102218: LIST
102219: LIST
102220: PUSH
102221: LD_INT 4
102223: NEG
102224: PUSH
102225: LD_INT 0
102227: PUSH
102228: EMPTY
102229: LIST
102230: LIST
102231: PUSH
102232: LD_INT 4
102234: NEG
102235: PUSH
102236: LD_INT 1
102238: NEG
102239: PUSH
102240: EMPTY
102241: LIST
102242: LIST
102243: PUSH
102244: LD_INT 3
102246: NEG
102247: PUSH
102248: LD_INT 0
102250: PUSH
102251: EMPTY
102252: LIST
102253: LIST
102254: PUSH
102255: LD_INT 3
102257: NEG
102258: PUSH
102259: LD_INT 1
102261: PUSH
102262: EMPTY
102263: LIST
102264: LIST
102265: PUSH
102266: LD_INT 4
102268: NEG
102269: PUSH
102270: LD_INT 1
102272: PUSH
102273: EMPTY
102274: LIST
102275: LIST
102276: PUSH
102277: LD_INT 5
102279: NEG
102280: PUSH
102281: LD_INT 0
102283: PUSH
102284: EMPTY
102285: LIST
102286: LIST
102287: PUSH
102288: LD_INT 5
102290: NEG
102291: PUSH
102292: LD_INT 1
102294: NEG
102295: PUSH
102296: EMPTY
102297: LIST
102298: LIST
102299: PUSH
102300: LD_INT 5
102302: NEG
102303: PUSH
102304: LD_INT 2
102306: NEG
102307: PUSH
102308: EMPTY
102309: LIST
102310: LIST
102311: PUSH
102312: LD_INT 3
102314: NEG
102315: PUSH
102316: LD_INT 2
102318: PUSH
102319: EMPTY
102320: LIST
102321: LIST
102322: PUSH
102323: EMPTY
102324: LIST
102325: LIST
102326: LIST
102327: LIST
102328: LIST
102329: LIST
102330: LIST
102331: LIST
102332: LIST
102333: LIST
102334: LIST
102335: LIST
102336: LIST
102337: LIST
102338: LIST
102339: LIST
102340: LIST
102341: LIST
102342: LIST
102343: LIST
102344: LIST
102345: LIST
102346: LIST
102347: LIST
102348: LIST
102349: LIST
102350: LIST
102351: LIST
102352: LIST
102353: LIST
102354: LIST
102355: LIST
102356: LIST
102357: LIST
102358: LIST
102359: LIST
102360: LIST
102361: LIST
102362: LIST
102363: LIST
102364: LIST
102365: LIST
102366: LIST
102367: LIST
102368: LIST
102369: ST_TO_ADDR
// end ; end ;
102370: GO 102373
102372: POP
// case btype of b_depot , b_warehouse :
102373: LD_VAR 0 1
102377: PUSH
102378: LD_INT 0
102380: DOUBLE
102381: EQUAL
102382: IFTRUE 102392
102384: LD_INT 1
102386: DOUBLE
102387: EQUAL
102388: IFTRUE 102392
102390: GO 102593
102392: POP
// case nation of nation_american :
102393: LD_VAR 0 5
102397: PUSH
102398: LD_INT 1
102400: DOUBLE
102401: EQUAL
102402: IFTRUE 102406
102404: GO 102462
102406: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
102407: LD_ADDR_VAR 0 9
102411: PUSH
102412: LD_VAR 0 11
102416: PUSH
102417: LD_VAR 0 12
102421: PUSH
102422: LD_VAR 0 13
102426: PUSH
102427: LD_VAR 0 14
102431: PUSH
102432: LD_VAR 0 15
102436: PUSH
102437: LD_VAR 0 16
102441: PUSH
102442: EMPTY
102443: LIST
102444: LIST
102445: LIST
102446: LIST
102447: LIST
102448: LIST
102449: PUSH
102450: LD_VAR 0 4
102454: PUSH
102455: LD_INT 1
102457: PLUS
102458: ARRAY
102459: ST_TO_ADDR
102460: GO 102591
102462: LD_INT 2
102464: DOUBLE
102465: EQUAL
102466: IFTRUE 102470
102468: GO 102526
102470: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
102471: LD_ADDR_VAR 0 9
102475: PUSH
102476: LD_VAR 0 17
102480: PUSH
102481: LD_VAR 0 18
102485: PUSH
102486: LD_VAR 0 19
102490: PUSH
102491: LD_VAR 0 20
102495: PUSH
102496: LD_VAR 0 21
102500: PUSH
102501: LD_VAR 0 22
102505: PUSH
102506: EMPTY
102507: LIST
102508: LIST
102509: LIST
102510: LIST
102511: LIST
102512: LIST
102513: PUSH
102514: LD_VAR 0 4
102518: PUSH
102519: LD_INT 1
102521: PLUS
102522: ARRAY
102523: ST_TO_ADDR
102524: GO 102591
102526: LD_INT 3
102528: DOUBLE
102529: EQUAL
102530: IFTRUE 102534
102532: GO 102590
102534: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
102535: LD_ADDR_VAR 0 9
102539: PUSH
102540: LD_VAR 0 23
102544: PUSH
102545: LD_VAR 0 24
102549: PUSH
102550: LD_VAR 0 25
102554: PUSH
102555: LD_VAR 0 26
102559: PUSH
102560: LD_VAR 0 27
102564: PUSH
102565: LD_VAR 0 28
102569: PUSH
102570: EMPTY
102571: LIST
102572: LIST
102573: LIST
102574: LIST
102575: LIST
102576: LIST
102577: PUSH
102578: LD_VAR 0 4
102582: PUSH
102583: LD_INT 1
102585: PLUS
102586: ARRAY
102587: ST_TO_ADDR
102588: GO 102591
102590: POP
102591: GO 103146
102593: LD_INT 2
102595: DOUBLE
102596: EQUAL
102597: IFTRUE 102607
102599: LD_INT 3
102601: DOUBLE
102602: EQUAL
102603: IFTRUE 102607
102605: GO 102663
102607: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
102608: LD_ADDR_VAR 0 9
102612: PUSH
102613: LD_VAR 0 29
102617: PUSH
102618: LD_VAR 0 30
102622: PUSH
102623: LD_VAR 0 31
102627: PUSH
102628: LD_VAR 0 32
102632: PUSH
102633: LD_VAR 0 33
102637: PUSH
102638: LD_VAR 0 34
102642: PUSH
102643: EMPTY
102644: LIST
102645: LIST
102646: LIST
102647: LIST
102648: LIST
102649: LIST
102650: PUSH
102651: LD_VAR 0 4
102655: PUSH
102656: LD_INT 1
102658: PLUS
102659: ARRAY
102660: ST_TO_ADDR
102661: GO 103146
102663: LD_INT 16
102665: DOUBLE
102666: EQUAL
102667: IFTRUE 102725
102669: LD_INT 17
102671: DOUBLE
102672: EQUAL
102673: IFTRUE 102725
102675: LD_INT 18
102677: DOUBLE
102678: EQUAL
102679: IFTRUE 102725
102681: LD_INT 19
102683: DOUBLE
102684: EQUAL
102685: IFTRUE 102725
102687: LD_INT 22
102689: DOUBLE
102690: EQUAL
102691: IFTRUE 102725
102693: LD_INT 20
102695: DOUBLE
102696: EQUAL
102697: IFTRUE 102725
102699: LD_INT 21
102701: DOUBLE
102702: EQUAL
102703: IFTRUE 102725
102705: LD_INT 23
102707: DOUBLE
102708: EQUAL
102709: IFTRUE 102725
102711: LD_INT 24
102713: DOUBLE
102714: EQUAL
102715: IFTRUE 102725
102717: LD_INT 25
102719: DOUBLE
102720: EQUAL
102721: IFTRUE 102725
102723: GO 102781
102725: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
102726: LD_ADDR_VAR 0 9
102730: PUSH
102731: LD_VAR 0 35
102735: PUSH
102736: LD_VAR 0 36
102740: PUSH
102741: LD_VAR 0 37
102745: PUSH
102746: LD_VAR 0 38
102750: PUSH
102751: LD_VAR 0 39
102755: PUSH
102756: LD_VAR 0 40
102760: PUSH
102761: EMPTY
102762: LIST
102763: LIST
102764: LIST
102765: LIST
102766: LIST
102767: LIST
102768: PUSH
102769: LD_VAR 0 4
102773: PUSH
102774: LD_INT 1
102776: PLUS
102777: ARRAY
102778: ST_TO_ADDR
102779: GO 103146
102781: LD_INT 6
102783: DOUBLE
102784: EQUAL
102785: IFTRUE 102837
102787: LD_INT 7
102789: DOUBLE
102790: EQUAL
102791: IFTRUE 102837
102793: LD_INT 8
102795: DOUBLE
102796: EQUAL
102797: IFTRUE 102837
102799: LD_INT 13
102801: DOUBLE
102802: EQUAL
102803: IFTRUE 102837
102805: LD_INT 12
102807: DOUBLE
102808: EQUAL
102809: IFTRUE 102837
102811: LD_INT 15
102813: DOUBLE
102814: EQUAL
102815: IFTRUE 102837
102817: LD_INT 11
102819: DOUBLE
102820: EQUAL
102821: IFTRUE 102837
102823: LD_INT 14
102825: DOUBLE
102826: EQUAL
102827: IFTRUE 102837
102829: LD_INT 10
102831: DOUBLE
102832: EQUAL
102833: IFTRUE 102837
102835: GO 102893
102837: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
102838: LD_ADDR_VAR 0 9
102842: PUSH
102843: LD_VAR 0 41
102847: PUSH
102848: LD_VAR 0 42
102852: PUSH
102853: LD_VAR 0 43
102857: PUSH
102858: LD_VAR 0 44
102862: PUSH
102863: LD_VAR 0 45
102867: PUSH
102868: LD_VAR 0 46
102872: PUSH
102873: EMPTY
102874: LIST
102875: LIST
102876: LIST
102877: LIST
102878: LIST
102879: LIST
102880: PUSH
102881: LD_VAR 0 4
102885: PUSH
102886: LD_INT 1
102888: PLUS
102889: ARRAY
102890: ST_TO_ADDR
102891: GO 103146
102893: LD_INT 36
102895: DOUBLE
102896: EQUAL
102897: IFTRUE 102901
102899: GO 102957
102901: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
102902: LD_ADDR_VAR 0 9
102906: PUSH
102907: LD_VAR 0 47
102911: PUSH
102912: LD_VAR 0 48
102916: PUSH
102917: LD_VAR 0 49
102921: PUSH
102922: LD_VAR 0 50
102926: PUSH
102927: LD_VAR 0 51
102931: PUSH
102932: LD_VAR 0 52
102936: PUSH
102937: EMPTY
102938: LIST
102939: LIST
102940: LIST
102941: LIST
102942: LIST
102943: LIST
102944: PUSH
102945: LD_VAR 0 4
102949: PUSH
102950: LD_INT 1
102952: PLUS
102953: ARRAY
102954: ST_TO_ADDR
102955: GO 103146
102957: LD_INT 4
102959: DOUBLE
102960: EQUAL
102961: IFTRUE 102983
102963: LD_INT 5
102965: DOUBLE
102966: EQUAL
102967: IFTRUE 102983
102969: LD_INT 34
102971: DOUBLE
102972: EQUAL
102973: IFTRUE 102983
102975: LD_INT 37
102977: DOUBLE
102978: EQUAL
102979: IFTRUE 102983
102981: GO 103039
102983: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
102984: LD_ADDR_VAR 0 9
102988: PUSH
102989: LD_VAR 0 53
102993: PUSH
102994: LD_VAR 0 54
102998: PUSH
102999: LD_VAR 0 55
103003: PUSH
103004: LD_VAR 0 56
103008: PUSH
103009: LD_VAR 0 57
103013: PUSH
103014: LD_VAR 0 58
103018: PUSH
103019: EMPTY
103020: LIST
103021: LIST
103022: LIST
103023: LIST
103024: LIST
103025: LIST
103026: PUSH
103027: LD_VAR 0 4
103031: PUSH
103032: LD_INT 1
103034: PLUS
103035: ARRAY
103036: ST_TO_ADDR
103037: GO 103146
103039: LD_INT 31
103041: DOUBLE
103042: EQUAL
103043: IFTRUE 103089
103045: LD_INT 32
103047: DOUBLE
103048: EQUAL
103049: IFTRUE 103089
103051: LD_INT 33
103053: DOUBLE
103054: EQUAL
103055: IFTRUE 103089
103057: LD_INT 27
103059: DOUBLE
103060: EQUAL
103061: IFTRUE 103089
103063: LD_INT 26
103065: DOUBLE
103066: EQUAL
103067: IFTRUE 103089
103069: LD_INT 28
103071: DOUBLE
103072: EQUAL
103073: IFTRUE 103089
103075: LD_INT 29
103077: DOUBLE
103078: EQUAL
103079: IFTRUE 103089
103081: LD_INT 30
103083: DOUBLE
103084: EQUAL
103085: IFTRUE 103089
103087: GO 103145
103089: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
103090: LD_ADDR_VAR 0 9
103094: PUSH
103095: LD_VAR 0 59
103099: PUSH
103100: LD_VAR 0 60
103104: PUSH
103105: LD_VAR 0 61
103109: PUSH
103110: LD_VAR 0 62
103114: PUSH
103115: LD_VAR 0 63
103119: PUSH
103120: LD_VAR 0 64
103124: PUSH
103125: EMPTY
103126: LIST
103127: LIST
103128: LIST
103129: LIST
103130: LIST
103131: LIST
103132: PUSH
103133: LD_VAR 0 4
103137: PUSH
103138: LD_INT 1
103140: PLUS
103141: ARRAY
103142: ST_TO_ADDR
103143: GO 103146
103145: POP
// temp_list2 = [ ] ;
103146: LD_ADDR_VAR 0 10
103150: PUSH
103151: EMPTY
103152: ST_TO_ADDR
// for i in temp_list do
103153: LD_ADDR_VAR 0 8
103157: PUSH
103158: LD_VAR 0 9
103162: PUSH
103163: FOR_IN
103164: IFFALSE 103216
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
103166: LD_ADDR_VAR 0 10
103170: PUSH
103171: LD_VAR 0 10
103175: PUSH
103176: LD_VAR 0 8
103180: PUSH
103181: LD_INT 1
103183: ARRAY
103184: PUSH
103185: LD_VAR 0 2
103189: PLUS
103190: PUSH
103191: LD_VAR 0 8
103195: PUSH
103196: LD_INT 2
103198: ARRAY
103199: PUSH
103200: LD_VAR 0 3
103204: PLUS
103205: PUSH
103206: EMPTY
103207: LIST
103208: LIST
103209: PUSH
103210: EMPTY
103211: LIST
103212: ADD
103213: ST_TO_ADDR
103214: GO 103163
103216: POP
103217: POP
// result = temp_list2 ;
103218: LD_ADDR_VAR 0 7
103222: PUSH
103223: LD_VAR 0 10
103227: ST_TO_ADDR
// end ;
103228: LD_VAR 0 7
103232: RET
// export function EnemyInRange ( unit , dist ) ; begin
103233: LD_INT 0
103235: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
103236: LD_ADDR_VAR 0 3
103240: PUSH
103241: LD_VAR 0 1
103245: PPUSH
103246: CALL_OW 255
103250: PPUSH
103251: LD_VAR 0 1
103255: PPUSH
103256: CALL_OW 250
103260: PPUSH
103261: LD_VAR 0 1
103265: PPUSH
103266: CALL_OW 251
103270: PPUSH
103271: LD_VAR 0 2
103275: PPUSH
103276: CALL 76606 0 4
103280: PUSH
103281: LD_INT 4
103283: ARRAY
103284: ST_TO_ADDR
// end ;
103285: LD_VAR 0 3
103289: RET
// export function PlayerSeeMe ( unit ) ; begin
103290: LD_INT 0
103292: PPUSH
// result := See ( your_side , unit ) ;
103293: LD_ADDR_VAR 0 2
103297: PUSH
103298: LD_OWVAR 2
103302: PPUSH
103303: LD_VAR 0 1
103307: PPUSH
103308: CALL_OW 292
103312: ST_TO_ADDR
// end ;
103313: LD_VAR 0 2
103317: RET
// export function ReverseDir ( unit ) ; begin
103318: LD_INT 0
103320: PPUSH
// if not unit then
103321: LD_VAR 0 1
103325: NOT
103326: IFFALSE 103330
// exit ;
103328: GO 103353
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
103330: LD_ADDR_VAR 0 2
103334: PUSH
103335: LD_VAR 0 1
103339: PPUSH
103340: CALL_OW 254
103344: PUSH
103345: LD_INT 3
103347: PLUS
103348: PUSH
103349: LD_INT 6
103351: MOD
103352: ST_TO_ADDR
// end ;
103353: LD_VAR 0 2
103357: RET
// export function ReverseArray ( array ) ; var i ; begin
103358: LD_INT 0
103360: PPUSH
103361: PPUSH
// if not array then
103362: LD_VAR 0 1
103366: NOT
103367: IFFALSE 103371
// exit ;
103369: GO 103426
// result := [ ] ;
103371: LD_ADDR_VAR 0 2
103375: PUSH
103376: EMPTY
103377: ST_TO_ADDR
// for i := array downto 1 do
103378: LD_ADDR_VAR 0 3
103382: PUSH
103383: DOUBLE
103384: LD_VAR 0 1
103388: INC
103389: ST_TO_ADDR
103390: LD_INT 1
103392: PUSH
103393: FOR_DOWNTO
103394: IFFALSE 103424
// result := Join ( result , array [ i ] ) ;
103396: LD_ADDR_VAR 0 2
103400: PUSH
103401: LD_VAR 0 2
103405: PPUSH
103406: LD_VAR 0 1
103410: PUSH
103411: LD_VAR 0 3
103415: ARRAY
103416: PPUSH
103417: CALL 108091 0 2
103421: ST_TO_ADDR
103422: GO 103393
103424: POP
103425: POP
// end ;
103426: LD_VAR 0 2
103430: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
103431: LD_INT 0
103433: PPUSH
103434: PPUSH
103435: PPUSH
103436: PPUSH
103437: PPUSH
103438: PPUSH
// if not unit or not hexes then
103439: LD_VAR 0 1
103443: NOT
103444: PUSH
103445: LD_VAR 0 2
103449: NOT
103450: OR
103451: IFFALSE 103455
// exit ;
103453: GO 103578
// dist := 9999 ;
103455: LD_ADDR_VAR 0 5
103459: PUSH
103460: LD_INT 9999
103462: ST_TO_ADDR
// for i = 1 to hexes do
103463: LD_ADDR_VAR 0 4
103467: PUSH
103468: DOUBLE
103469: LD_INT 1
103471: DEC
103472: ST_TO_ADDR
103473: LD_VAR 0 2
103477: PUSH
103478: FOR_TO
103479: IFFALSE 103566
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
103481: LD_ADDR_VAR 0 6
103485: PUSH
103486: LD_VAR 0 1
103490: PPUSH
103491: LD_VAR 0 2
103495: PUSH
103496: LD_VAR 0 4
103500: ARRAY
103501: PUSH
103502: LD_INT 1
103504: ARRAY
103505: PPUSH
103506: LD_VAR 0 2
103510: PUSH
103511: LD_VAR 0 4
103515: ARRAY
103516: PUSH
103517: LD_INT 2
103519: ARRAY
103520: PPUSH
103521: CALL_OW 297
103525: ST_TO_ADDR
// if tdist < dist then
103526: LD_VAR 0 6
103530: PUSH
103531: LD_VAR 0 5
103535: LESS
103536: IFFALSE 103564
// begin hex := hexes [ i ] ;
103538: LD_ADDR_VAR 0 8
103542: PUSH
103543: LD_VAR 0 2
103547: PUSH
103548: LD_VAR 0 4
103552: ARRAY
103553: ST_TO_ADDR
// dist := tdist ;
103554: LD_ADDR_VAR 0 5
103558: PUSH
103559: LD_VAR 0 6
103563: ST_TO_ADDR
// end ; end ;
103564: GO 103478
103566: POP
103567: POP
// result := hex ;
103568: LD_ADDR_VAR 0 3
103572: PUSH
103573: LD_VAR 0 8
103577: ST_TO_ADDR
// end ;
103578: LD_VAR 0 3
103582: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
103583: LD_INT 0
103585: PPUSH
103586: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
103587: LD_VAR 0 1
103591: NOT
103592: PUSH
103593: LD_VAR 0 1
103597: PUSH
103598: LD_INT 21
103600: PUSH
103601: LD_INT 2
103603: PUSH
103604: EMPTY
103605: LIST
103606: LIST
103607: PUSH
103608: LD_INT 23
103610: PUSH
103611: LD_INT 2
103613: PUSH
103614: EMPTY
103615: LIST
103616: LIST
103617: PUSH
103618: EMPTY
103619: LIST
103620: LIST
103621: PPUSH
103622: CALL_OW 69
103626: IN
103627: NOT
103628: OR
103629: IFFALSE 103633
// exit ;
103631: GO 103680
// for i = 1 to 3 do
103633: LD_ADDR_VAR 0 3
103637: PUSH
103638: DOUBLE
103639: LD_INT 1
103641: DEC
103642: ST_TO_ADDR
103643: LD_INT 3
103645: PUSH
103646: FOR_TO
103647: IFFALSE 103678
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
103649: LD_VAR 0 1
103653: PPUSH
103654: CALL_OW 250
103658: PPUSH
103659: LD_VAR 0 1
103663: PPUSH
103664: CALL_OW 251
103668: PPUSH
103669: LD_INT 1
103671: PPUSH
103672: CALL_OW 453
103676: GO 103646
103678: POP
103679: POP
// end ;
103680: LD_VAR 0 2
103684: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
103685: LD_INT 0
103687: PPUSH
103688: PPUSH
103689: PPUSH
103690: PPUSH
103691: PPUSH
103692: PPUSH
// if not unit or not enemy_unit then
103693: LD_VAR 0 1
103697: NOT
103698: PUSH
103699: LD_VAR 0 2
103703: NOT
103704: OR
103705: IFFALSE 103709
// exit ;
103707: GO 104176
// if GetLives ( i ) < 250 then
103709: LD_VAR 0 4
103713: PPUSH
103714: CALL_OW 256
103718: PUSH
103719: LD_INT 250
103721: LESS
103722: IFFALSE 103735
// begin ComAutodestruct ( i ) ;
103724: LD_VAR 0 4
103728: PPUSH
103729: CALL 103583 0 1
// exit ;
103733: GO 104176
// end ; x := GetX ( enemy_unit ) ;
103735: LD_ADDR_VAR 0 7
103739: PUSH
103740: LD_VAR 0 2
103744: PPUSH
103745: CALL_OW 250
103749: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
103750: LD_ADDR_VAR 0 8
103754: PUSH
103755: LD_VAR 0 2
103759: PPUSH
103760: CALL_OW 251
103764: ST_TO_ADDR
// if not x or not y then
103765: LD_VAR 0 7
103769: NOT
103770: PUSH
103771: LD_VAR 0 8
103775: NOT
103776: OR
103777: IFFALSE 103781
// exit ;
103779: GO 104176
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
103781: LD_ADDR_VAR 0 6
103785: PUSH
103786: LD_VAR 0 7
103790: PPUSH
103791: LD_INT 0
103793: PPUSH
103794: LD_INT 4
103796: PPUSH
103797: CALL_OW 272
103801: PUSH
103802: LD_VAR 0 8
103806: PPUSH
103807: LD_INT 0
103809: PPUSH
103810: LD_INT 4
103812: PPUSH
103813: CALL_OW 273
103817: PUSH
103818: EMPTY
103819: LIST
103820: LIST
103821: PUSH
103822: LD_VAR 0 7
103826: PPUSH
103827: LD_INT 1
103829: PPUSH
103830: LD_INT 4
103832: PPUSH
103833: CALL_OW 272
103837: PUSH
103838: LD_VAR 0 8
103842: PPUSH
103843: LD_INT 1
103845: PPUSH
103846: LD_INT 4
103848: PPUSH
103849: CALL_OW 273
103853: PUSH
103854: EMPTY
103855: LIST
103856: LIST
103857: PUSH
103858: LD_VAR 0 7
103862: PPUSH
103863: LD_INT 2
103865: PPUSH
103866: LD_INT 4
103868: PPUSH
103869: CALL_OW 272
103873: PUSH
103874: LD_VAR 0 8
103878: PPUSH
103879: LD_INT 2
103881: PPUSH
103882: LD_INT 4
103884: PPUSH
103885: CALL_OW 273
103889: PUSH
103890: EMPTY
103891: LIST
103892: LIST
103893: PUSH
103894: LD_VAR 0 7
103898: PPUSH
103899: LD_INT 3
103901: PPUSH
103902: LD_INT 4
103904: PPUSH
103905: CALL_OW 272
103909: PUSH
103910: LD_VAR 0 8
103914: PPUSH
103915: LD_INT 3
103917: PPUSH
103918: LD_INT 4
103920: PPUSH
103921: CALL_OW 273
103925: PUSH
103926: EMPTY
103927: LIST
103928: LIST
103929: PUSH
103930: LD_VAR 0 7
103934: PPUSH
103935: LD_INT 4
103937: PPUSH
103938: LD_INT 4
103940: PPUSH
103941: CALL_OW 272
103945: PUSH
103946: LD_VAR 0 8
103950: PPUSH
103951: LD_INT 4
103953: PPUSH
103954: LD_INT 4
103956: PPUSH
103957: CALL_OW 273
103961: PUSH
103962: EMPTY
103963: LIST
103964: LIST
103965: PUSH
103966: LD_VAR 0 7
103970: PPUSH
103971: LD_INT 5
103973: PPUSH
103974: LD_INT 4
103976: PPUSH
103977: CALL_OW 272
103981: PUSH
103982: LD_VAR 0 8
103986: PPUSH
103987: LD_INT 5
103989: PPUSH
103990: LD_INT 4
103992: PPUSH
103993: CALL_OW 273
103997: PUSH
103998: EMPTY
103999: LIST
104000: LIST
104001: PUSH
104002: EMPTY
104003: LIST
104004: LIST
104005: LIST
104006: LIST
104007: LIST
104008: LIST
104009: ST_TO_ADDR
// for i = tmp downto 1 do
104010: LD_ADDR_VAR 0 4
104014: PUSH
104015: DOUBLE
104016: LD_VAR 0 6
104020: INC
104021: ST_TO_ADDR
104022: LD_INT 1
104024: PUSH
104025: FOR_DOWNTO
104026: IFFALSE 104127
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
104028: LD_VAR 0 6
104032: PUSH
104033: LD_VAR 0 4
104037: ARRAY
104038: PUSH
104039: LD_INT 1
104041: ARRAY
104042: PPUSH
104043: LD_VAR 0 6
104047: PUSH
104048: LD_VAR 0 4
104052: ARRAY
104053: PUSH
104054: LD_INT 2
104056: ARRAY
104057: PPUSH
104058: CALL_OW 488
104062: NOT
104063: PUSH
104064: LD_VAR 0 6
104068: PUSH
104069: LD_VAR 0 4
104073: ARRAY
104074: PUSH
104075: LD_INT 1
104077: ARRAY
104078: PPUSH
104079: LD_VAR 0 6
104083: PUSH
104084: LD_VAR 0 4
104088: ARRAY
104089: PUSH
104090: LD_INT 2
104092: ARRAY
104093: PPUSH
104094: CALL_OW 428
104098: PUSH
104099: LD_INT 0
104101: NONEQUAL
104102: OR
104103: IFFALSE 104125
// tmp := Delete ( tmp , i ) ;
104105: LD_ADDR_VAR 0 6
104109: PUSH
104110: LD_VAR 0 6
104114: PPUSH
104115: LD_VAR 0 4
104119: PPUSH
104120: CALL_OW 3
104124: ST_TO_ADDR
104125: GO 104025
104127: POP
104128: POP
// j := GetClosestHex ( unit , tmp ) ;
104129: LD_ADDR_VAR 0 5
104133: PUSH
104134: LD_VAR 0 1
104138: PPUSH
104139: LD_VAR 0 6
104143: PPUSH
104144: CALL 103431 0 2
104148: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
104149: LD_VAR 0 1
104153: PPUSH
104154: LD_VAR 0 5
104158: PUSH
104159: LD_INT 1
104161: ARRAY
104162: PPUSH
104163: LD_VAR 0 5
104167: PUSH
104168: LD_INT 2
104170: ARRAY
104171: PPUSH
104172: CALL_OW 111
// end ;
104176: LD_VAR 0 3
104180: RET
// export function PrepareApemanSoldier ( ) ; begin
104181: LD_INT 0
104183: PPUSH
// uc_nation := 0 ;
104184: LD_ADDR_OWVAR 21
104188: PUSH
104189: LD_INT 0
104191: ST_TO_ADDR
// hc_sex := sex_male ;
104192: LD_ADDR_OWVAR 27
104196: PUSH
104197: LD_INT 1
104199: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
104200: LD_ADDR_OWVAR 28
104204: PUSH
104205: LD_INT 15
104207: ST_TO_ADDR
// hc_gallery :=  ;
104208: LD_ADDR_OWVAR 33
104212: PUSH
104213: LD_STRING 
104215: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
104216: LD_ADDR_OWVAR 31
104220: PUSH
104221: LD_INT 0
104223: PPUSH
104224: LD_INT 3
104226: PPUSH
104227: CALL_OW 12
104231: PUSH
104232: LD_INT 0
104234: PPUSH
104235: LD_INT 3
104237: PPUSH
104238: CALL_OW 12
104242: PUSH
104243: LD_INT 0
104245: PUSH
104246: LD_INT 0
104248: PUSH
104249: EMPTY
104250: LIST
104251: LIST
104252: LIST
104253: LIST
104254: ST_TO_ADDR
// end ;
104255: LD_VAR 0 1
104259: RET
// export function PrepareApemanEngineer ( ) ; begin
104260: LD_INT 0
104262: PPUSH
// uc_nation := 0 ;
104263: LD_ADDR_OWVAR 21
104267: PUSH
104268: LD_INT 0
104270: ST_TO_ADDR
// hc_sex := sex_male ;
104271: LD_ADDR_OWVAR 27
104275: PUSH
104276: LD_INT 1
104278: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
104279: LD_ADDR_OWVAR 28
104283: PUSH
104284: LD_INT 16
104286: ST_TO_ADDR
// hc_gallery :=  ;
104287: LD_ADDR_OWVAR 33
104291: PUSH
104292: LD_STRING 
104294: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
104295: LD_ADDR_OWVAR 31
104299: PUSH
104300: LD_INT 0
104302: PPUSH
104303: LD_INT 3
104305: PPUSH
104306: CALL_OW 12
104310: PUSH
104311: LD_INT 0
104313: PPUSH
104314: LD_INT 3
104316: PPUSH
104317: CALL_OW 12
104321: PUSH
104322: LD_INT 0
104324: PUSH
104325: LD_INT 0
104327: PUSH
104328: EMPTY
104329: LIST
104330: LIST
104331: LIST
104332: LIST
104333: ST_TO_ADDR
// end ;
104334: LD_VAR 0 1
104338: RET
// export function PrepareApeman ( agressivity ) ; begin
104339: LD_INT 0
104341: PPUSH
// uc_side := 0 ;
104342: LD_ADDR_OWVAR 20
104346: PUSH
104347: LD_INT 0
104349: ST_TO_ADDR
// uc_nation := 0 ;
104350: LD_ADDR_OWVAR 21
104354: PUSH
104355: LD_INT 0
104357: ST_TO_ADDR
// hc_sex := sex_male ;
104358: LD_ADDR_OWVAR 27
104362: PUSH
104363: LD_INT 1
104365: ST_TO_ADDR
// hc_class := class_apeman ;
104366: LD_ADDR_OWVAR 28
104370: PUSH
104371: LD_INT 12
104373: ST_TO_ADDR
// hc_gallery :=  ;
104374: LD_ADDR_OWVAR 33
104378: PUSH
104379: LD_STRING 
104381: ST_TO_ADDR
// if agressivity = 0 then
104382: LD_VAR 0 1
104386: PUSH
104387: LD_INT 0
104389: EQUAL
104390: IFFALSE 104402
// hc_agressivity := 0 else
104392: LD_ADDR_OWVAR 35
104396: PUSH
104397: LD_INT 0
104399: ST_TO_ADDR
104400: GO 104423
// hc_agressivity := rand ( - agressivity , agressivity ) ;
104402: LD_ADDR_OWVAR 35
104406: PUSH
104407: LD_VAR 0 1
104411: NEG
104412: PPUSH
104413: LD_VAR 0 1
104417: PPUSH
104418: CALL_OW 12
104422: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
104423: LD_ADDR_OWVAR 31
104427: PUSH
104428: LD_INT 0
104430: PPUSH
104431: LD_INT 3
104433: PPUSH
104434: CALL_OW 12
104438: PUSH
104439: LD_INT 0
104441: PPUSH
104442: LD_INT 3
104444: PPUSH
104445: CALL_OW 12
104449: PUSH
104450: LD_INT 0
104452: PUSH
104453: LD_INT 0
104455: PUSH
104456: EMPTY
104457: LIST
104458: LIST
104459: LIST
104460: LIST
104461: ST_TO_ADDR
// end ;
104462: LD_VAR 0 2
104466: RET
// export function PrepareTiger ( agressivity ) ; begin
104467: LD_INT 0
104469: PPUSH
// uc_side := 0 ;
104470: LD_ADDR_OWVAR 20
104474: PUSH
104475: LD_INT 0
104477: ST_TO_ADDR
// uc_nation := 0 ;
104478: LD_ADDR_OWVAR 21
104482: PUSH
104483: LD_INT 0
104485: ST_TO_ADDR
// hc_class := class_tiger ;
104486: LD_ADDR_OWVAR 28
104490: PUSH
104491: LD_INT 14
104493: ST_TO_ADDR
// hc_gallery :=  ;
104494: LD_ADDR_OWVAR 33
104498: PUSH
104499: LD_STRING 
104501: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
104502: LD_ADDR_OWVAR 35
104506: PUSH
104507: LD_VAR 0 1
104511: NEG
104512: PPUSH
104513: LD_VAR 0 1
104517: PPUSH
104518: CALL_OW 12
104522: ST_TO_ADDR
// end ;
104523: LD_VAR 0 2
104527: RET
// export function PrepareEnchidna ( ) ; begin
104528: LD_INT 0
104530: PPUSH
// uc_side := 0 ;
104531: LD_ADDR_OWVAR 20
104535: PUSH
104536: LD_INT 0
104538: ST_TO_ADDR
// uc_nation := 0 ;
104539: LD_ADDR_OWVAR 21
104543: PUSH
104544: LD_INT 0
104546: ST_TO_ADDR
// hc_class := class_baggie ;
104547: LD_ADDR_OWVAR 28
104551: PUSH
104552: LD_INT 13
104554: ST_TO_ADDR
// hc_gallery :=  ;
104555: LD_ADDR_OWVAR 33
104559: PUSH
104560: LD_STRING 
104562: ST_TO_ADDR
// end ;
104563: LD_VAR 0 1
104567: RET
// export function PrepareFrog ( ) ; begin
104568: LD_INT 0
104570: PPUSH
// uc_side := 0 ;
104571: LD_ADDR_OWVAR 20
104575: PUSH
104576: LD_INT 0
104578: ST_TO_ADDR
// uc_nation := 0 ;
104579: LD_ADDR_OWVAR 21
104583: PUSH
104584: LD_INT 0
104586: ST_TO_ADDR
// hc_class := class_frog ;
104587: LD_ADDR_OWVAR 28
104591: PUSH
104592: LD_INT 19
104594: ST_TO_ADDR
// hc_gallery :=  ;
104595: LD_ADDR_OWVAR 33
104599: PUSH
104600: LD_STRING 
104602: ST_TO_ADDR
// end ;
104603: LD_VAR 0 1
104607: RET
// export function PrepareFish ( ) ; begin
104608: LD_INT 0
104610: PPUSH
// uc_side := 0 ;
104611: LD_ADDR_OWVAR 20
104615: PUSH
104616: LD_INT 0
104618: ST_TO_ADDR
// uc_nation := 0 ;
104619: LD_ADDR_OWVAR 21
104623: PUSH
104624: LD_INT 0
104626: ST_TO_ADDR
// hc_class := class_fish ;
104627: LD_ADDR_OWVAR 28
104631: PUSH
104632: LD_INT 20
104634: ST_TO_ADDR
// hc_gallery :=  ;
104635: LD_ADDR_OWVAR 33
104639: PUSH
104640: LD_STRING 
104642: ST_TO_ADDR
// end ;
104643: LD_VAR 0 1
104647: RET
// export function PrepareBird ( ) ; begin
104648: LD_INT 0
104650: PPUSH
// uc_side := 0 ;
104651: LD_ADDR_OWVAR 20
104655: PUSH
104656: LD_INT 0
104658: ST_TO_ADDR
// uc_nation := 0 ;
104659: LD_ADDR_OWVAR 21
104663: PUSH
104664: LD_INT 0
104666: ST_TO_ADDR
// hc_class := class_phororhacos ;
104667: LD_ADDR_OWVAR 28
104671: PUSH
104672: LD_INT 18
104674: ST_TO_ADDR
// hc_gallery :=  ;
104675: LD_ADDR_OWVAR 33
104679: PUSH
104680: LD_STRING 
104682: ST_TO_ADDR
// end ;
104683: LD_VAR 0 1
104687: RET
// export function PrepareHorse ( ) ; begin
104688: LD_INT 0
104690: PPUSH
// uc_side := 0 ;
104691: LD_ADDR_OWVAR 20
104695: PUSH
104696: LD_INT 0
104698: ST_TO_ADDR
// uc_nation := 0 ;
104699: LD_ADDR_OWVAR 21
104703: PUSH
104704: LD_INT 0
104706: ST_TO_ADDR
// hc_class := class_horse ;
104707: LD_ADDR_OWVAR 28
104711: PUSH
104712: LD_INT 21
104714: ST_TO_ADDR
// hc_gallery :=  ;
104715: LD_ADDR_OWVAR 33
104719: PUSH
104720: LD_STRING 
104722: ST_TO_ADDR
// end ;
104723: LD_VAR 0 1
104727: RET
// export function PrepareMastodont ( ) ; begin
104728: LD_INT 0
104730: PPUSH
// uc_side := 0 ;
104731: LD_ADDR_OWVAR 20
104735: PUSH
104736: LD_INT 0
104738: ST_TO_ADDR
// uc_nation := 0 ;
104739: LD_ADDR_OWVAR 21
104743: PUSH
104744: LD_INT 0
104746: ST_TO_ADDR
// vc_chassis := class_mastodont ;
104747: LD_ADDR_OWVAR 37
104751: PUSH
104752: LD_INT 31
104754: ST_TO_ADDR
// vc_control := control_rider ;
104755: LD_ADDR_OWVAR 38
104759: PUSH
104760: LD_INT 4
104762: ST_TO_ADDR
// end ;
104763: LD_VAR 0 1
104767: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
104768: LD_INT 0
104770: PPUSH
104771: PPUSH
104772: PPUSH
// uc_side = 0 ;
104773: LD_ADDR_OWVAR 20
104777: PUSH
104778: LD_INT 0
104780: ST_TO_ADDR
// uc_nation = 0 ;
104781: LD_ADDR_OWVAR 21
104785: PUSH
104786: LD_INT 0
104788: ST_TO_ADDR
// InitHc_All ( ) ;
104789: CALL_OW 584
// InitVc ;
104793: CALL_OW 20
// if mastodonts then
104797: LD_VAR 0 6
104801: IFFALSE 104868
// for i = 1 to mastodonts do
104803: LD_ADDR_VAR 0 11
104807: PUSH
104808: DOUBLE
104809: LD_INT 1
104811: DEC
104812: ST_TO_ADDR
104813: LD_VAR 0 6
104817: PUSH
104818: FOR_TO
104819: IFFALSE 104866
// begin vc_chassis := 31 ;
104821: LD_ADDR_OWVAR 37
104825: PUSH
104826: LD_INT 31
104828: ST_TO_ADDR
// vc_control := control_rider ;
104829: LD_ADDR_OWVAR 38
104833: PUSH
104834: LD_INT 4
104836: ST_TO_ADDR
// animal := CreateVehicle ;
104837: LD_ADDR_VAR 0 12
104841: PUSH
104842: CALL_OW 45
104846: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104847: LD_VAR 0 12
104851: PPUSH
104852: LD_VAR 0 8
104856: PPUSH
104857: LD_INT 0
104859: PPUSH
104860: CALL 106996 0 3
// end ;
104864: GO 104818
104866: POP
104867: POP
// if horses then
104868: LD_VAR 0 5
104872: IFFALSE 104939
// for i = 1 to horses do
104874: LD_ADDR_VAR 0 11
104878: PUSH
104879: DOUBLE
104880: LD_INT 1
104882: DEC
104883: ST_TO_ADDR
104884: LD_VAR 0 5
104888: PUSH
104889: FOR_TO
104890: IFFALSE 104937
// begin hc_class := 21 ;
104892: LD_ADDR_OWVAR 28
104896: PUSH
104897: LD_INT 21
104899: ST_TO_ADDR
// hc_gallery :=  ;
104900: LD_ADDR_OWVAR 33
104904: PUSH
104905: LD_STRING 
104907: ST_TO_ADDR
// animal := CreateHuman ;
104908: LD_ADDR_VAR 0 12
104912: PUSH
104913: CALL_OW 44
104917: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104918: LD_VAR 0 12
104922: PPUSH
104923: LD_VAR 0 8
104927: PPUSH
104928: LD_INT 0
104930: PPUSH
104931: CALL 106996 0 3
// end ;
104935: GO 104889
104937: POP
104938: POP
// if birds then
104939: LD_VAR 0 1
104943: IFFALSE 105010
// for i = 1 to birds do
104945: LD_ADDR_VAR 0 11
104949: PUSH
104950: DOUBLE
104951: LD_INT 1
104953: DEC
104954: ST_TO_ADDR
104955: LD_VAR 0 1
104959: PUSH
104960: FOR_TO
104961: IFFALSE 105008
// begin hc_class := 18 ;
104963: LD_ADDR_OWVAR 28
104967: PUSH
104968: LD_INT 18
104970: ST_TO_ADDR
// hc_gallery =  ;
104971: LD_ADDR_OWVAR 33
104975: PUSH
104976: LD_STRING 
104978: ST_TO_ADDR
// animal := CreateHuman ;
104979: LD_ADDR_VAR 0 12
104983: PUSH
104984: CALL_OW 44
104988: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104989: LD_VAR 0 12
104993: PPUSH
104994: LD_VAR 0 8
104998: PPUSH
104999: LD_INT 0
105001: PPUSH
105002: CALL 106996 0 3
// end ;
105006: GO 104960
105008: POP
105009: POP
// if tigers then
105010: LD_VAR 0 2
105014: IFFALSE 105098
// for i = 1 to tigers do
105016: LD_ADDR_VAR 0 11
105020: PUSH
105021: DOUBLE
105022: LD_INT 1
105024: DEC
105025: ST_TO_ADDR
105026: LD_VAR 0 2
105030: PUSH
105031: FOR_TO
105032: IFFALSE 105096
// begin hc_class = class_tiger ;
105034: LD_ADDR_OWVAR 28
105038: PUSH
105039: LD_INT 14
105041: ST_TO_ADDR
// hc_gallery =  ;
105042: LD_ADDR_OWVAR 33
105046: PUSH
105047: LD_STRING 
105049: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
105050: LD_ADDR_OWVAR 35
105054: PUSH
105055: LD_INT 7
105057: NEG
105058: PPUSH
105059: LD_INT 7
105061: PPUSH
105062: CALL_OW 12
105066: ST_TO_ADDR
// animal := CreateHuman ;
105067: LD_ADDR_VAR 0 12
105071: PUSH
105072: CALL_OW 44
105076: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
105077: LD_VAR 0 12
105081: PPUSH
105082: LD_VAR 0 8
105086: PPUSH
105087: LD_INT 0
105089: PPUSH
105090: CALL 106996 0 3
// end ;
105094: GO 105031
105096: POP
105097: POP
// if apemans then
105098: LD_VAR 0 3
105102: IFFALSE 105225
// for i = 1 to apemans do
105104: LD_ADDR_VAR 0 11
105108: PUSH
105109: DOUBLE
105110: LD_INT 1
105112: DEC
105113: ST_TO_ADDR
105114: LD_VAR 0 3
105118: PUSH
105119: FOR_TO
105120: IFFALSE 105223
// begin hc_class = class_apeman ;
105122: LD_ADDR_OWVAR 28
105126: PUSH
105127: LD_INT 12
105129: ST_TO_ADDR
// hc_gallery =  ;
105130: LD_ADDR_OWVAR 33
105134: PUSH
105135: LD_STRING 
105137: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
105138: LD_ADDR_OWVAR 35
105142: PUSH
105143: LD_INT 2
105145: NEG
105146: PPUSH
105147: LD_INT 2
105149: PPUSH
105150: CALL_OW 12
105154: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
105155: LD_ADDR_OWVAR 31
105159: PUSH
105160: LD_INT 1
105162: PPUSH
105163: LD_INT 3
105165: PPUSH
105166: CALL_OW 12
105170: PUSH
105171: LD_INT 1
105173: PPUSH
105174: LD_INT 3
105176: PPUSH
105177: CALL_OW 12
105181: PUSH
105182: LD_INT 0
105184: PUSH
105185: LD_INT 0
105187: PUSH
105188: EMPTY
105189: LIST
105190: LIST
105191: LIST
105192: LIST
105193: ST_TO_ADDR
// animal := CreateHuman ;
105194: LD_ADDR_VAR 0 12
105198: PUSH
105199: CALL_OW 44
105203: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
105204: LD_VAR 0 12
105208: PPUSH
105209: LD_VAR 0 8
105213: PPUSH
105214: LD_INT 0
105216: PPUSH
105217: CALL 106996 0 3
// end ;
105221: GO 105119
105223: POP
105224: POP
// if enchidnas then
105225: LD_VAR 0 4
105229: IFFALSE 105296
// for i = 1 to enchidnas do
105231: LD_ADDR_VAR 0 11
105235: PUSH
105236: DOUBLE
105237: LD_INT 1
105239: DEC
105240: ST_TO_ADDR
105241: LD_VAR 0 4
105245: PUSH
105246: FOR_TO
105247: IFFALSE 105294
// begin hc_class = 13 ;
105249: LD_ADDR_OWVAR 28
105253: PUSH
105254: LD_INT 13
105256: ST_TO_ADDR
// hc_gallery =  ;
105257: LD_ADDR_OWVAR 33
105261: PUSH
105262: LD_STRING 
105264: ST_TO_ADDR
// animal := CreateHuman ;
105265: LD_ADDR_VAR 0 12
105269: PUSH
105270: CALL_OW 44
105274: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
105275: LD_VAR 0 12
105279: PPUSH
105280: LD_VAR 0 8
105284: PPUSH
105285: LD_INT 0
105287: PPUSH
105288: CALL 106996 0 3
// end ;
105292: GO 105246
105294: POP
105295: POP
// if fishes then
105296: LD_VAR 0 7
105300: IFFALSE 105367
// for i = 1 to fishes do
105302: LD_ADDR_VAR 0 11
105306: PUSH
105307: DOUBLE
105308: LD_INT 1
105310: DEC
105311: ST_TO_ADDR
105312: LD_VAR 0 7
105316: PUSH
105317: FOR_TO
105318: IFFALSE 105365
// begin hc_class = 20 ;
105320: LD_ADDR_OWVAR 28
105324: PUSH
105325: LD_INT 20
105327: ST_TO_ADDR
// hc_gallery =  ;
105328: LD_ADDR_OWVAR 33
105332: PUSH
105333: LD_STRING 
105335: ST_TO_ADDR
// animal := CreateHuman ;
105336: LD_ADDR_VAR 0 12
105340: PUSH
105341: CALL_OW 44
105345: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
105346: LD_VAR 0 12
105350: PPUSH
105351: LD_VAR 0 9
105355: PPUSH
105356: LD_INT 0
105358: PPUSH
105359: CALL 106996 0 3
// end ;
105363: GO 105317
105365: POP
105366: POP
// end ;
105367: LD_VAR 0 10
105371: RET
// export function WantHeal ( sci , unit ) ; begin
105372: LD_INT 0
105374: PPUSH
// if GetTaskList ( sci ) > 0 then
105375: LD_VAR 0 1
105379: PPUSH
105380: CALL_OW 437
105384: PUSH
105385: LD_INT 0
105387: GREATER
105388: IFFALSE 105458
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
105390: LD_VAR 0 1
105394: PPUSH
105395: CALL_OW 437
105399: PUSH
105400: LD_INT 1
105402: ARRAY
105403: PUSH
105404: LD_INT 1
105406: ARRAY
105407: PUSH
105408: LD_STRING l
105410: EQUAL
105411: PUSH
105412: LD_VAR 0 1
105416: PPUSH
105417: CALL_OW 437
105421: PUSH
105422: LD_INT 1
105424: ARRAY
105425: PUSH
105426: LD_INT 4
105428: ARRAY
105429: PUSH
105430: LD_VAR 0 2
105434: EQUAL
105435: AND
105436: IFFALSE 105448
// result := true else
105438: LD_ADDR_VAR 0 3
105442: PUSH
105443: LD_INT 1
105445: ST_TO_ADDR
105446: GO 105456
// result := false ;
105448: LD_ADDR_VAR 0 3
105452: PUSH
105453: LD_INT 0
105455: ST_TO_ADDR
// end else
105456: GO 105466
// result := false ;
105458: LD_ADDR_VAR 0 3
105462: PUSH
105463: LD_INT 0
105465: ST_TO_ADDR
// end ;
105466: LD_VAR 0 3
105470: RET
// export function HealTarget ( sci ) ; begin
105471: LD_INT 0
105473: PPUSH
// if not sci then
105474: LD_VAR 0 1
105478: NOT
105479: IFFALSE 105483
// exit ;
105481: GO 105548
// result := 0 ;
105483: LD_ADDR_VAR 0 2
105487: PUSH
105488: LD_INT 0
105490: ST_TO_ADDR
// if GetTaskList ( sci ) then
105491: LD_VAR 0 1
105495: PPUSH
105496: CALL_OW 437
105500: IFFALSE 105548
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
105502: LD_VAR 0 1
105506: PPUSH
105507: CALL_OW 437
105511: PUSH
105512: LD_INT 1
105514: ARRAY
105515: PUSH
105516: LD_INT 1
105518: ARRAY
105519: PUSH
105520: LD_STRING l
105522: EQUAL
105523: IFFALSE 105548
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
105525: LD_ADDR_VAR 0 2
105529: PUSH
105530: LD_VAR 0 1
105534: PPUSH
105535: CALL_OW 437
105539: PUSH
105540: LD_INT 1
105542: ARRAY
105543: PUSH
105544: LD_INT 4
105546: ARRAY
105547: ST_TO_ADDR
// end ;
105548: LD_VAR 0 2
105552: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
105553: LD_INT 0
105555: PPUSH
105556: PPUSH
105557: PPUSH
105558: PPUSH
// if not base_units then
105559: LD_VAR 0 1
105563: NOT
105564: IFFALSE 105568
// exit ;
105566: GO 105655
// result := false ;
105568: LD_ADDR_VAR 0 2
105572: PUSH
105573: LD_INT 0
105575: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
105576: LD_ADDR_VAR 0 5
105580: PUSH
105581: LD_VAR 0 1
105585: PPUSH
105586: LD_INT 21
105588: PUSH
105589: LD_INT 3
105591: PUSH
105592: EMPTY
105593: LIST
105594: LIST
105595: PPUSH
105596: CALL_OW 72
105600: ST_TO_ADDR
// if not tmp then
105601: LD_VAR 0 5
105605: NOT
105606: IFFALSE 105610
// exit ;
105608: GO 105655
// for i in tmp do
105610: LD_ADDR_VAR 0 3
105614: PUSH
105615: LD_VAR 0 5
105619: PUSH
105620: FOR_IN
105621: IFFALSE 105653
// begin result := EnemyInRange ( i , 22 ) ;
105623: LD_ADDR_VAR 0 2
105627: PUSH
105628: LD_VAR 0 3
105632: PPUSH
105633: LD_INT 22
105635: PPUSH
105636: CALL 103233 0 2
105640: ST_TO_ADDR
// if result then
105641: LD_VAR 0 2
105645: IFFALSE 105651
// exit ;
105647: POP
105648: POP
105649: GO 105655
// end ;
105651: GO 105620
105653: POP
105654: POP
// end ;
105655: LD_VAR 0 2
105659: RET
// export function FilterByTag ( units , tag ) ; begin
105660: LD_INT 0
105662: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
105663: LD_ADDR_VAR 0 3
105667: PUSH
105668: LD_VAR 0 1
105672: PPUSH
105673: LD_INT 120
105675: PUSH
105676: LD_VAR 0 2
105680: PUSH
105681: EMPTY
105682: LIST
105683: LIST
105684: PPUSH
105685: CALL_OW 72
105689: ST_TO_ADDR
// end ;
105690: LD_VAR 0 3
105694: RET
// export function IsDriver ( un ) ; begin
105695: LD_INT 0
105697: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
105698: LD_ADDR_VAR 0 2
105702: PUSH
105703: LD_VAR 0 1
105707: PUSH
105708: LD_INT 55
105710: PUSH
105711: EMPTY
105712: LIST
105713: PPUSH
105714: CALL_OW 69
105718: IN
105719: ST_TO_ADDR
// end ;
105720: LD_VAR 0 2
105724: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
105725: LD_INT 0
105727: PPUSH
105728: PPUSH
// list := [ ] ;
105729: LD_ADDR_VAR 0 5
105733: PUSH
105734: EMPTY
105735: ST_TO_ADDR
// case d of 0 :
105736: LD_VAR 0 3
105740: PUSH
105741: LD_INT 0
105743: DOUBLE
105744: EQUAL
105745: IFTRUE 105749
105747: GO 105882
105749: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
105750: LD_ADDR_VAR 0 5
105754: PUSH
105755: LD_VAR 0 1
105759: PUSH
105760: LD_INT 4
105762: MINUS
105763: PUSH
105764: LD_VAR 0 2
105768: PUSH
105769: LD_INT 4
105771: MINUS
105772: PUSH
105773: LD_INT 2
105775: PUSH
105776: EMPTY
105777: LIST
105778: LIST
105779: LIST
105780: PUSH
105781: LD_VAR 0 1
105785: PUSH
105786: LD_INT 3
105788: MINUS
105789: PUSH
105790: LD_VAR 0 2
105794: PUSH
105795: LD_INT 1
105797: PUSH
105798: EMPTY
105799: LIST
105800: LIST
105801: LIST
105802: PUSH
105803: LD_VAR 0 1
105807: PUSH
105808: LD_INT 4
105810: PLUS
105811: PUSH
105812: LD_VAR 0 2
105816: PUSH
105817: LD_INT 4
105819: PUSH
105820: EMPTY
105821: LIST
105822: LIST
105823: LIST
105824: PUSH
105825: LD_VAR 0 1
105829: PUSH
105830: LD_INT 3
105832: PLUS
105833: PUSH
105834: LD_VAR 0 2
105838: PUSH
105839: LD_INT 3
105841: PLUS
105842: PUSH
105843: LD_INT 5
105845: PUSH
105846: EMPTY
105847: LIST
105848: LIST
105849: LIST
105850: PUSH
105851: LD_VAR 0 1
105855: PUSH
105856: LD_VAR 0 2
105860: PUSH
105861: LD_INT 4
105863: PLUS
105864: PUSH
105865: LD_INT 0
105867: PUSH
105868: EMPTY
105869: LIST
105870: LIST
105871: LIST
105872: PUSH
105873: EMPTY
105874: LIST
105875: LIST
105876: LIST
105877: LIST
105878: LIST
105879: ST_TO_ADDR
// end ; 1 :
105880: GO 106580
105882: LD_INT 1
105884: DOUBLE
105885: EQUAL
105886: IFTRUE 105890
105888: GO 106023
105890: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
105891: LD_ADDR_VAR 0 5
105895: PUSH
105896: LD_VAR 0 1
105900: PUSH
105901: LD_VAR 0 2
105905: PUSH
105906: LD_INT 4
105908: MINUS
105909: PUSH
105910: LD_INT 3
105912: PUSH
105913: EMPTY
105914: LIST
105915: LIST
105916: LIST
105917: PUSH
105918: LD_VAR 0 1
105922: PUSH
105923: LD_INT 3
105925: MINUS
105926: PUSH
105927: LD_VAR 0 2
105931: PUSH
105932: LD_INT 3
105934: MINUS
105935: PUSH
105936: LD_INT 2
105938: PUSH
105939: EMPTY
105940: LIST
105941: LIST
105942: LIST
105943: PUSH
105944: LD_VAR 0 1
105948: PUSH
105949: LD_INT 4
105951: MINUS
105952: PUSH
105953: LD_VAR 0 2
105957: PUSH
105958: LD_INT 1
105960: PUSH
105961: EMPTY
105962: LIST
105963: LIST
105964: LIST
105965: PUSH
105966: LD_VAR 0 1
105970: PUSH
105971: LD_VAR 0 2
105975: PUSH
105976: LD_INT 3
105978: PLUS
105979: PUSH
105980: LD_INT 0
105982: PUSH
105983: EMPTY
105984: LIST
105985: LIST
105986: LIST
105987: PUSH
105988: LD_VAR 0 1
105992: PUSH
105993: LD_INT 4
105995: PLUS
105996: PUSH
105997: LD_VAR 0 2
106001: PUSH
106002: LD_INT 4
106004: PLUS
106005: PUSH
106006: LD_INT 5
106008: PUSH
106009: EMPTY
106010: LIST
106011: LIST
106012: LIST
106013: PUSH
106014: EMPTY
106015: LIST
106016: LIST
106017: LIST
106018: LIST
106019: LIST
106020: ST_TO_ADDR
// end ; 2 :
106021: GO 106580
106023: LD_INT 2
106025: DOUBLE
106026: EQUAL
106027: IFTRUE 106031
106029: GO 106160
106031: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
106032: LD_ADDR_VAR 0 5
106036: PUSH
106037: LD_VAR 0 1
106041: PUSH
106042: LD_VAR 0 2
106046: PUSH
106047: LD_INT 3
106049: MINUS
106050: PUSH
106051: LD_INT 3
106053: PUSH
106054: EMPTY
106055: LIST
106056: LIST
106057: LIST
106058: PUSH
106059: LD_VAR 0 1
106063: PUSH
106064: LD_INT 4
106066: PLUS
106067: PUSH
106068: LD_VAR 0 2
106072: PUSH
106073: LD_INT 4
106075: PUSH
106076: EMPTY
106077: LIST
106078: LIST
106079: LIST
106080: PUSH
106081: LD_VAR 0 1
106085: PUSH
106086: LD_VAR 0 2
106090: PUSH
106091: LD_INT 4
106093: PLUS
106094: PUSH
106095: LD_INT 0
106097: PUSH
106098: EMPTY
106099: LIST
106100: LIST
106101: LIST
106102: PUSH
106103: LD_VAR 0 1
106107: PUSH
106108: LD_INT 3
106110: MINUS
106111: PUSH
106112: LD_VAR 0 2
106116: PUSH
106117: LD_INT 1
106119: PUSH
106120: EMPTY
106121: LIST
106122: LIST
106123: LIST
106124: PUSH
106125: LD_VAR 0 1
106129: PUSH
106130: LD_INT 4
106132: MINUS
106133: PUSH
106134: LD_VAR 0 2
106138: PUSH
106139: LD_INT 4
106141: MINUS
106142: PUSH
106143: LD_INT 2
106145: PUSH
106146: EMPTY
106147: LIST
106148: LIST
106149: LIST
106150: PUSH
106151: EMPTY
106152: LIST
106153: LIST
106154: LIST
106155: LIST
106156: LIST
106157: ST_TO_ADDR
// end ; 3 :
106158: GO 106580
106160: LD_INT 3
106162: DOUBLE
106163: EQUAL
106164: IFTRUE 106168
106166: GO 106301
106168: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
106169: LD_ADDR_VAR 0 5
106173: PUSH
106174: LD_VAR 0 1
106178: PUSH
106179: LD_INT 3
106181: PLUS
106182: PUSH
106183: LD_VAR 0 2
106187: PUSH
106188: LD_INT 4
106190: PUSH
106191: EMPTY
106192: LIST
106193: LIST
106194: LIST
106195: PUSH
106196: LD_VAR 0 1
106200: PUSH
106201: LD_INT 4
106203: PLUS
106204: PUSH
106205: LD_VAR 0 2
106209: PUSH
106210: LD_INT 4
106212: PLUS
106213: PUSH
106214: LD_INT 5
106216: PUSH
106217: EMPTY
106218: LIST
106219: LIST
106220: LIST
106221: PUSH
106222: LD_VAR 0 1
106226: PUSH
106227: LD_INT 4
106229: MINUS
106230: PUSH
106231: LD_VAR 0 2
106235: PUSH
106236: LD_INT 1
106238: PUSH
106239: EMPTY
106240: LIST
106241: LIST
106242: LIST
106243: PUSH
106244: LD_VAR 0 1
106248: PUSH
106249: LD_VAR 0 2
106253: PUSH
106254: LD_INT 4
106256: MINUS
106257: PUSH
106258: LD_INT 3
106260: PUSH
106261: EMPTY
106262: LIST
106263: LIST
106264: LIST
106265: PUSH
106266: LD_VAR 0 1
106270: PUSH
106271: LD_INT 3
106273: MINUS
106274: PUSH
106275: LD_VAR 0 2
106279: PUSH
106280: LD_INT 3
106282: MINUS
106283: PUSH
106284: LD_INT 2
106286: PUSH
106287: EMPTY
106288: LIST
106289: LIST
106290: LIST
106291: PUSH
106292: EMPTY
106293: LIST
106294: LIST
106295: LIST
106296: LIST
106297: LIST
106298: ST_TO_ADDR
// end ; 4 :
106299: GO 106580
106301: LD_INT 4
106303: DOUBLE
106304: EQUAL
106305: IFTRUE 106309
106307: GO 106442
106309: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
106310: LD_ADDR_VAR 0 5
106314: PUSH
106315: LD_VAR 0 1
106319: PUSH
106320: LD_VAR 0 2
106324: PUSH
106325: LD_INT 4
106327: PLUS
106328: PUSH
106329: LD_INT 0
106331: PUSH
106332: EMPTY
106333: LIST
106334: LIST
106335: LIST
106336: PUSH
106337: LD_VAR 0 1
106341: PUSH
106342: LD_INT 3
106344: PLUS
106345: PUSH
106346: LD_VAR 0 2
106350: PUSH
106351: LD_INT 3
106353: PLUS
106354: PUSH
106355: LD_INT 5
106357: PUSH
106358: EMPTY
106359: LIST
106360: LIST
106361: LIST
106362: PUSH
106363: LD_VAR 0 1
106367: PUSH
106368: LD_INT 4
106370: PLUS
106371: PUSH
106372: LD_VAR 0 2
106376: PUSH
106377: LD_INT 4
106379: PUSH
106380: EMPTY
106381: LIST
106382: LIST
106383: LIST
106384: PUSH
106385: LD_VAR 0 1
106389: PUSH
106390: LD_VAR 0 2
106394: PUSH
106395: LD_INT 3
106397: MINUS
106398: PUSH
106399: LD_INT 3
106401: PUSH
106402: EMPTY
106403: LIST
106404: LIST
106405: LIST
106406: PUSH
106407: LD_VAR 0 1
106411: PUSH
106412: LD_INT 4
106414: MINUS
106415: PUSH
106416: LD_VAR 0 2
106420: PUSH
106421: LD_INT 4
106423: MINUS
106424: PUSH
106425: LD_INT 2
106427: PUSH
106428: EMPTY
106429: LIST
106430: LIST
106431: LIST
106432: PUSH
106433: EMPTY
106434: LIST
106435: LIST
106436: LIST
106437: LIST
106438: LIST
106439: ST_TO_ADDR
// end ; 5 :
106440: GO 106580
106442: LD_INT 5
106444: DOUBLE
106445: EQUAL
106446: IFTRUE 106450
106448: GO 106579
106450: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
106451: LD_ADDR_VAR 0 5
106455: PUSH
106456: LD_VAR 0 1
106460: PUSH
106461: LD_INT 4
106463: MINUS
106464: PUSH
106465: LD_VAR 0 2
106469: PUSH
106470: LD_INT 1
106472: PUSH
106473: EMPTY
106474: LIST
106475: LIST
106476: LIST
106477: PUSH
106478: LD_VAR 0 1
106482: PUSH
106483: LD_VAR 0 2
106487: PUSH
106488: LD_INT 4
106490: MINUS
106491: PUSH
106492: LD_INT 3
106494: PUSH
106495: EMPTY
106496: LIST
106497: LIST
106498: LIST
106499: PUSH
106500: LD_VAR 0 1
106504: PUSH
106505: LD_INT 4
106507: PLUS
106508: PUSH
106509: LD_VAR 0 2
106513: PUSH
106514: LD_INT 4
106516: PLUS
106517: PUSH
106518: LD_INT 5
106520: PUSH
106521: EMPTY
106522: LIST
106523: LIST
106524: LIST
106525: PUSH
106526: LD_VAR 0 1
106530: PUSH
106531: LD_INT 3
106533: PLUS
106534: PUSH
106535: LD_VAR 0 2
106539: PUSH
106540: LD_INT 4
106542: PUSH
106543: EMPTY
106544: LIST
106545: LIST
106546: LIST
106547: PUSH
106548: LD_VAR 0 1
106552: PUSH
106553: LD_VAR 0 2
106557: PUSH
106558: LD_INT 3
106560: PLUS
106561: PUSH
106562: LD_INT 0
106564: PUSH
106565: EMPTY
106566: LIST
106567: LIST
106568: LIST
106569: PUSH
106570: EMPTY
106571: LIST
106572: LIST
106573: LIST
106574: LIST
106575: LIST
106576: ST_TO_ADDR
// end ; end ;
106577: GO 106580
106579: POP
// result := list ;
106580: LD_ADDR_VAR 0 4
106584: PUSH
106585: LD_VAR 0 5
106589: ST_TO_ADDR
// end ;
106590: LD_VAR 0 4
106594: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
106595: LD_INT 0
106597: PPUSH
106598: PPUSH
106599: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
106600: LD_VAR 0 1
106604: NOT
106605: PUSH
106606: LD_VAR 0 2
106610: PUSH
106611: LD_INT 1
106613: PUSH
106614: LD_INT 2
106616: PUSH
106617: LD_INT 3
106619: PUSH
106620: LD_INT 4
106622: PUSH
106623: EMPTY
106624: LIST
106625: LIST
106626: LIST
106627: LIST
106628: IN
106629: NOT
106630: OR
106631: IFFALSE 106635
// exit ;
106633: GO 106718
// tmp := [ ] ;
106635: LD_ADDR_VAR 0 5
106639: PUSH
106640: EMPTY
106641: ST_TO_ADDR
// for i in units do
106642: LD_ADDR_VAR 0 4
106646: PUSH
106647: LD_VAR 0 1
106651: PUSH
106652: FOR_IN
106653: IFFALSE 106687
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
106655: LD_ADDR_VAR 0 5
106659: PUSH
106660: LD_VAR 0 5
106664: PPUSH
106665: LD_VAR 0 4
106669: PPUSH
106670: LD_VAR 0 2
106674: PPUSH
106675: CALL_OW 259
106679: PPUSH
106680: CALL 108091 0 2
106684: ST_TO_ADDR
106685: GO 106652
106687: POP
106688: POP
// if not tmp then
106689: LD_VAR 0 5
106693: NOT
106694: IFFALSE 106698
// exit ;
106696: GO 106718
// result := SortListByListDesc ( units , tmp ) ;
106698: LD_ADDR_VAR 0 3
106702: PUSH
106703: LD_VAR 0 1
106707: PPUSH
106708: LD_VAR 0 5
106712: PPUSH
106713: CALL_OW 77
106717: ST_TO_ADDR
// end ;
106718: LD_VAR 0 3
106722: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
106723: LD_INT 0
106725: PPUSH
106726: PPUSH
106727: PPUSH
// result := false ;
106728: LD_ADDR_VAR 0 3
106732: PUSH
106733: LD_INT 0
106735: ST_TO_ADDR
// if not building then
106736: LD_VAR 0 2
106740: NOT
106741: IFFALSE 106745
// exit ;
106743: GO 106883
// x := GetX ( building ) ;
106745: LD_ADDR_VAR 0 4
106749: PUSH
106750: LD_VAR 0 2
106754: PPUSH
106755: CALL_OW 250
106759: ST_TO_ADDR
// y := GetY ( building ) ;
106760: LD_ADDR_VAR 0 5
106764: PUSH
106765: LD_VAR 0 2
106769: PPUSH
106770: CALL_OW 251
106774: ST_TO_ADDR
// if not x or not y then
106775: LD_VAR 0 4
106779: NOT
106780: PUSH
106781: LD_VAR 0 5
106785: NOT
106786: OR
106787: IFFALSE 106791
// exit ;
106789: GO 106883
// if GetTaskList ( unit ) then
106791: LD_VAR 0 1
106795: PPUSH
106796: CALL_OW 437
106800: IFFALSE 106883
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106802: LD_STRING e
106804: PUSH
106805: LD_VAR 0 1
106809: PPUSH
106810: CALL_OW 437
106814: PUSH
106815: LD_INT 1
106817: ARRAY
106818: PUSH
106819: LD_INT 1
106821: ARRAY
106822: EQUAL
106823: PUSH
106824: LD_VAR 0 4
106828: PUSH
106829: LD_VAR 0 1
106833: PPUSH
106834: CALL_OW 437
106838: PUSH
106839: LD_INT 1
106841: ARRAY
106842: PUSH
106843: LD_INT 2
106845: ARRAY
106846: EQUAL
106847: AND
106848: PUSH
106849: LD_VAR 0 5
106853: PUSH
106854: LD_VAR 0 1
106858: PPUSH
106859: CALL_OW 437
106863: PUSH
106864: LD_INT 1
106866: ARRAY
106867: PUSH
106868: LD_INT 3
106870: ARRAY
106871: EQUAL
106872: AND
106873: IFFALSE 106883
// result := true end ;
106875: LD_ADDR_VAR 0 3
106879: PUSH
106880: LD_INT 1
106882: ST_TO_ADDR
// end ;
106883: LD_VAR 0 3
106887: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
106888: LD_INT 0
106890: PPUSH
// result := false ;
106891: LD_ADDR_VAR 0 4
106895: PUSH
106896: LD_INT 0
106898: ST_TO_ADDR
// if GetTaskList ( unit ) then
106899: LD_VAR 0 1
106903: PPUSH
106904: CALL_OW 437
106908: IFFALSE 106991
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106910: LD_STRING M
106912: PUSH
106913: LD_VAR 0 1
106917: PPUSH
106918: CALL_OW 437
106922: PUSH
106923: LD_INT 1
106925: ARRAY
106926: PUSH
106927: LD_INT 1
106929: ARRAY
106930: EQUAL
106931: PUSH
106932: LD_VAR 0 2
106936: PUSH
106937: LD_VAR 0 1
106941: PPUSH
106942: CALL_OW 437
106946: PUSH
106947: LD_INT 1
106949: ARRAY
106950: PUSH
106951: LD_INT 2
106953: ARRAY
106954: EQUAL
106955: AND
106956: PUSH
106957: LD_VAR 0 3
106961: PUSH
106962: LD_VAR 0 1
106966: PPUSH
106967: CALL_OW 437
106971: PUSH
106972: LD_INT 1
106974: ARRAY
106975: PUSH
106976: LD_INT 3
106978: ARRAY
106979: EQUAL
106980: AND
106981: IFFALSE 106991
// result := true ;
106983: LD_ADDR_VAR 0 4
106987: PUSH
106988: LD_INT 1
106990: ST_TO_ADDR
// end ; end ;
106991: LD_VAR 0 4
106995: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
106996: LD_INT 0
106998: PPUSH
106999: PPUSH
107000: PPUSH
107001: PPUSH
// if not unit or not area then
107002: LD_VAR 0 1
107006: NOT
107007: PUSH
107008: LD_VAR 0 2
107012: NOT
107013: OR
107014: IFFALSE 107018
// exit ;
107016: GO 107194
// tmp := AreaToList ( area , i ) ;
107018: LD_ADDR_VAR 0 6
107022: PUSH
107023: LD_VAR 0 2
107027: PPUSH
107028: LD_VAR 0 5
107032: PPUSH
107033: CALL_OW 517
107037: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
107038: LD_ADDR_VAR 0 5
107042: PUSH
107043: DOUBLE
107044: LD_INT 1
107046: DEC
107047: ST_TO_ADDR
107048: LD_VAR 0 6
107052: PUSH
107053: LD_INT 1
107055: ARRAY
107056: PUSH
107057: FOR_TO
107058: IFFALSE 107192
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
107060: LD_ADDR_VAR 0 7
107064: PUSH
107065: LD_VAR 0 6
107069: PUSH
107070: LD_INT 1
107072: ARRAY
107073: PUSH
107074: LD_VAR 0 5
107078: ARRAY
107079: PUSH
107080: LD_VAR 0 6
107084: PUSH
107085: LD_INT 2
107087: ARRAY
107088: PUSH
107089: LD_VAR 0 5
107093: ARRAY
107094: PUSH
107095: EMPTY
107096: LIST
107097: LIST
107098: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
107099: LD_INT 92
107101: PUSH
107102: LD_VAR 0 7
107106: PUSH
107107: LD_INT 1
107109: ARRAY
107110: PUSH
107111: LD_VAR 0 7
107115: PUSH
107116: LD_INT 2
107118: ARRAY
107119: PUSH
107120: LD_INT 2
107122: PUSH
107123: EMPTY
107124: LIST
107125: LIST
107126: LIST
107127: LIST
107128: PPUSH
107129: CALL_OW 69
107133: PUSH
107134: LD_INT 0
107136: EQUAL
107137: IFFALSE 107190
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
107139: LD_VAR 0 1
107143: PPUSH
107144: LD_VAR 0 7
107148: PUSH
107149: LD_INT 1
107151: ARRAY
107152: PPUSH
107153: LD_VAR 0 7
107157: PUSH
107158: LD_INT 2
107160: ARRAY
107161: PPUSH
107162: LD_VAR 0 3
107166: PPUSH
107167: CALL_OW 48
// result := IsPlaced ( unit ) ;
107171: LD_ADDR_VAR 0 4
107175: PUSH
107176: LD_VAR 0 1
107180: PPUSH
107181: CALL_OW 305
107185: ST_TO_ADDR
// exit ;
107186: POP
107187: POP
107188: GO 107194
// end ; end ;
107190: GO 107057
107192: POP
107193: POP
// end ;
107194: LD_VAR 0 4
107198: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
107199: LD_INT 0
107201: PPUSH
107202: PPUSH
107203: PPUSH
// if not side or side > 8 then
107204: LD_VAR 0 1
107208: NOT
107209: PUSH
107210: LD_VAR 0 1
107214: PUSH
107215: LD_INT 8
107217: GREATER
107218: OR
107219: IFFALSE 107223
// exit ;
107221: GO 107410
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
107223: LD_ADDR_VAR 0 4
107227: PUSH
107228: LD_INT 22
107230: PUSH
107231: LD_VAR 0 1
107235: PUSH
107236: EMPTY
107237: LIST
107238: LIST
107239: PUSH
107240: LD_INT 21
107242: PUSH
107243: LD_INT 3
107245: PUSH
107246: EMPTY
107247: LIST
107248: LIST
107249: PUSH
107250: EMPTY
107251: LIST
107252: LIST
107253: PPUSH
107254: CALL_OW 69
107258: ST_TO_ADDR
// if not tmp then
107259: LD_VAR 0 4
107263: NOT
107264: IFFALSE 107268
// exit ;
107266: GO 107410
// enable_addtolog := true ;
107268: LD_ADDR_OWVAR 81
107272: PUSH
107273: LD_INT 1
107275: ST_TO_ADDR
// AddToLog ( [ ) ;
107276: LD_STRING [
107278: PPUSH
107279: CALL_OW 561
// for i in tmp do
107283: LD_ADDR_VAR 0 3
107287: PUSH
107288: LD_VAR 0 4
107292: PUSH
107293: FOR_IN
107294: IFFALSE 107401
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
107296: LD_STRING [
107298: PUSH
107299: LD_VAR 0 3
107303: PPUSH
107304: CALL_OW 266
107308: STR
107309: PUSH
107310: LD_STRING , 
107312: STR
107313: PUSH
107314: LD_VAR 0 3
107318: PPUSH
107319: CALL_OW 250
107323: STR
107324: PUSH
107325: LD_STRING , 
107327: STR
107328: PUSH
107329: LD_VAR 0 3
107333: PPUSH
107334: CALL_OW 251
107338: STR
107339: PUSH
107340: LD_STRING , 
107342: STR
107343: PUSH
107344: LD_VAR 0 3
107348: PPUSH
107349: CALL_OW 254
107353: STR
107354: PUSH
107355: LD_STRING , 
107357: STR
107358: PUSH
107359: LD_VAR 0 3
107363: PPUSH
107364: LD_INT 1
107366: PPUSH
107367: CALL_OW 268
107371: STR
107372: PUSH
107373: LD_STRING , 
107375: STR
107376: PUSH
107377: LD_VAR 0 3
107381: PPUSH
107382: LD_INT 2
107384: PPUSH
107385: CALL_OW 268
107389: STR
107390: PUSH
107391: LD_STRING ],
107393: STR
107394: PPUSH
107395: CALL_OW 561
// end ;
107399: GO 107293
107401: POP
107402: POP
// AddToLog ( ]; ) ;
107403: LD_STRING ];
107405: PPUSH
107406: CALL_OW 561
// end ;
107410: LD_VAR 0 2
107414: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
107415: LD_INT 0
107417: PPUSH
107418: PPUSH
107419: PPUSH
107420: PPUSH
107421: PPUSH
// if not area or not rate or not max then
107422: LD_VAR 0 1
107426: NOT
107427: PUSH
107428: LD_VAR 0 2
107432: NOT
107433: OR
107434: PUSH
107435: LD_VAR 0 4
107439: NOT
107440: OR
107441: IFFALSE 107445
// exit ;
107443: GO 107634
// while 1 do
107445: LD_INT 1
107447: IFFALSE 107634
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
107449: LD_ADDR_VAR 0 9
107453: PUSH
107454: LD_VAR 0 1
107458: PPUSH
107459: LD_INT 1
107461: PPUSH
107462: CALL_OW 287
107466: PUSH
107467: LD_INT 10
107469: MUL
107470: ST_TO_ADDR
// r := rate / 10 ;
107471: LD_ADDR_VAR 0 7
107475: PUSH
107476: LD_VAR 0 2
107480: PUSH
107481: LD_INT 10
107483: DIVREAL
107484: ST_TO_ADDR
// time := 1 1$00 ;
107485: LD_ADDR_VAR 0 8
107489: PUSH
107490: LD_INT 2100
107492: ST_TO_ADDR
// if amount < min then
107493: LD_VAR 0 9
107497: PUSH
107498: LD_VAR 0 3
107502: LESS
107503: IFFALSE 107521
// r := r * 2 else
107505: LD_ADDR_VAR 0 7
107509: PUSH
107510: LD_VAR 0 7
107514: PUSH
107515: LD_INT 2
107517: MUL
107518: ST_TO_ADDR
107519: GO 107547
// if amount > max then
107521: LD_VAR 0 9
107525: PUSH
107526: LD_VAR 0 4
107530: GREATER
107531: IFFALSE 107547
// r := r / 2 ;
107533: LD_ADDR_VAR 0 7
107537: PUSH
107538: LD_VAR 0 7
107542: PUSH
107543: LD_INT 2
107545: DIVREAL
107546: ST_TO_ADDR
// time := time / r ;
107547: LD_ADDR_VAR 0 8
107551: PUSH
107552: LD_VAR 0 8
107556: PUSH
107557: LD_VAR 0 7
107561: DIVREAL
107562: ST_TO_ADDR
// if time < 0 then
107563: LD_VAR 0 8
107567: PUSH
107568: LD_INT 0
107570: LESS
107571: IFFALSE 107588
// time := time * - 1 ;
107573: LD_ADDR_VAR 0 8
107577: PUSH
107578: LD_VAR 0 8
107582: PUSH
107583: LD_INT 1
107585: NEG
107586: MUL
107587: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
107588: LD_VAR 0 8
107592: PUSH
107593: LD_INT 35
107595: PPUSH
107596: LD_INT 875
107598: PPUSH
107599: CALL_OW 12
107603: PLUS
107604: PPUSH
107605: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
107609: LD_INT 1
107611: PPUSH
107612: LD_INT 5
107614: PPUSH
107615: CALL_OW 12
107619: PPUSH
107620: LD_VAR 0 1
107624: PPUSH
107625: LD_INT 1
107627: PPUSH
107628: CALL_OW 55
// end ;
107632: GO 107445
// end ;
107634: LD_VAR 0 5
107638: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
107639: LD_INT 0
107641: PPUSH
107642: PPUSH
107643: PPUSH
107644: PPUSH
107645: PPUSH
107646: PPUSH
107647: PPUSH
107648: PPUSH
// if not turrets or not factories then
107649: LD_VAR 0 1
107653: NOT
107654: PUSH
107655: LD_VAR 0 2
107659: NOT
107660: OR
107661: IFFALSE 107665
// exit ;
107663: GO 107972
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
107665: LD_ADDR_VAR 0 10
107669: PUSH
107670: LD_INT 5
107672: PUSH
107673: LD_INT 6
107675: PUSH
107676: EMPTY
107677: LIST
107678: LIST
107679: PUSH
107680: LD_INT 2
107682: PUSH
107683: LD_INT 4
107685: PUSH
107686: EMPTY
107687: LIST
107688: LIST
107689: PUSH
107690: LD_INT 3
107692: PUSH
107693: LD_INT 5
107695: PUSH
107696: EMPTY
107697: LIST
107698: LIST
107699: PUSH
107700: EMPTY
107701: LIST
107702: LIST
107703: LIST
107704: PUSH
107705: LD_INT 24
107707: PUSH
107708: LD_INT 25
107710: PUSH
107711: EMPTY
107712: LIST
107713: LIST
107714: PUSH
107715: LD_INT 23
107717: PUSH
107718: LD_INT 27
107720: PUSH
107721: EMPTY
107722: LIST
107723: LIST
107724: PUSH
107725: EMPTY
107726: LIST
107727: LIST
107728: PUSH
107729: LD_INT 42
107731: PUSH
107732: LD_INT 43
107734: PUSH
107735: EMPTY
107736: LIST
107737: LIST
107738: PUSH
107739: LD_INT 44
107741: PUSH
107742: LD_INT 46
107744: PUSH
107745: EMPTY
107746: LIST
107747: LIST
107748: PUSH
107749: LD_INT 45
107751: PUSH
107752: LD_INT 47
107754: PUSH
107755: EMPTY
107756: LIST
107757: LIST
107758: PUSH
107759: EMPTY
107760: LIST
107761: LIST
107762: LIST
107763: PUSH
107764: EMPTY
107765: LIST
107766: LIST
107767: LIST
107768: ST_TO_ADDR
// result := [ ] ;
107769: LD_ADDR_VAR 0 3
107773: PUSH
107774: EMPTY
107775: ST_TO_ADDR
// for i in turrets do
107776: LD_ADDR_VAR 0 4
107780: PUSH
107781: LD_VAR 0 1
107785: PUSH
107786: FOR_IN
107787: IFFALSE 107970
// begin nat := GetNation ( i ) ;
107789: LD_ADDR_VAR 0 7
107793: PUSH
107794: LD_VAR 0 4
107798: PPUSH
107799: CALL_OW 248
107803: ST_TO_ADDR
// weapon := 0 ;
107804: LD_ADDR_VAR 0 8
107808: PUSH
107809: LD_INT 0
107811: ST_TO_ADDR
// if not nat then
107812: LD_VAR 0 7
107816: NOT
107817: IFFALSE 107821
// continue ;
107819: GO 107786
// for j in list [ nat ] do
107821: LD_ADDR_VAR 0 5
107825: PUSH
107826: LD_VAR 0 10
107830: PUSH
107831: LD_VAR 0 7
107835: ARRAY
107836: PUSH
107837: FOR_IN
107838: IFFALSE 107879
// if GetBWeapon ( i ) = j [ 1 ] then
107840: LD_VAR 0 4
107844: PPUSH
107845: CALL_OW 269
107849: PUSH
107850: LD_VAR 0 5
107854: PUSH
107855: LD_INT 1
107857: ARRAY
107858: EQUAL
107859: IFFALSE 107877
// begin weapon := j [ 2 ] ;
107861: LD_ADDR_VAR 0 8
107865: PUSH
107866: LD_VAR 0 5
107870: PUSH
107871: LD_INT 2
107873: ARRAY
107874: ST_TO_ADDR
// break ;
107875: GO 107879
// end ;
107877: GO 107837
107879: POP
107880: POP
// if not weapon then
107881: LD_VAR 0 8
107885: NOT
107886: IFFALSE 107890
// continue ;
107888: GO 107786
// for k in factories do
107890: LD_ADDR_VAR 0 6
107894: PUSH
107895: LD_VAR 0 2
107899: PUSH
107900: FOR_IN
107901: IFFALSE 107966
// begin weapons := AvailableWeaponList ( k ) ;
107903: LD_ADDR_VAR 0 9
107907: PUSH
107908: LD_VAR 0 6
107912: PPUSH
107913: CALL_OW 478
107917: ST_TO_ADDR
// if not weapons then
107918: LD_VAR 0 9
107922: NOT
107923: IFFALSE 107927
// continue ;
107925: GO 107900
// if weapon in weapons then
107927: LD_VAR 0 8
107931: PUSH
107932: LD_VAR 0 9
107936: IN
107937: IFFALSE 107964
// begin result := [ i , weapon ] ;
107939: LD_ADDR_VAR 0 3
107943: PUSH
107944: LD_VAR 0 4
107948: PUSH
107949: LD_VAR 0 8
107953: PUSH
107954: EMPTY
107955: LIST
107956: LIST
107957: ST_TO_ADDR
// exit ;
107958: POP
107959: POP
107960: POP
107961: POP
107962: GO 107972
// end ; end ;
107964: GO 107900
107966: POP
107967: POP
// end ;
107968: GO 107786
107970: POP
107971: POP
// end ;
107972: LD_VAR 0 3
107976: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
107977: LD_INT 0
107979: PPUSH
// if not side or side > 8 then
107980: LD_VAR 0 3
107984: NOT
107985: PUSH
107986: LD_VAR 0 3
107990: PUSH
107991: LD_INT 8
107993: GREATER
107994: OR
107995: IFFALSE 107999
// exit ;
107997: GO 108058
// if not range then
107999: LD_VAR 0 4
108003: NOT
108004: IFFALSE 108015
// range := - 12 ;
108006: LD_ADDR_VAR 0 4
108010: PUSH
108011: LD_INT 12
108013: NEG
108014: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
108015: LD_VAR 0 1
108019: PPUSH
108020: LD_VAR 0 2
108024: PPUSH
108025: LD_VAR 0 3
108029: PPUSH
108030: LD_VAR 0 4
108034: PPUSH
108035: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
108039: LD_VAR 0 1
108043: PPUSH
108044: LD_VAR 0 2
108048: PPUSH
108049: LD_VAR 0 3
108053: PPUSH
108054: CALL_OW 331
// end ;
108058: LD_VAR 0 5
108062: RET
// export function Video ( mode ) ; begin
108063: LD_INT 0
108065: PPUSH
// ingame_video = mode ;
108066: LD_ADDR_OWVAR 52
108070: PUSH
108071: LD_VAR 0 1
108075: ST_TO_ADDR
// interface_hidden = mode ;
108076: LD_ADDR_OWVAR 54
108080: PUSH
108081: LD_VAR 0 1
108085: ST_TO_ADDR
// end ;
108086: LD_VAR 0 2
108090: RET
// export function Join ( array , element ) ; begin
108091: LD_INT 0
108093: PPUSH
// result := Replace ( array , array + 1 , element ) ;
108094: LD_ADDR_VAR 0 3
108098: PUSH
108099: LD_VAR 0 1
108103: PPUSH
108104: LD_VAR 0 1
108108: PUSH
108109: LD_INT 1
108111: PLUS
108112: PPUSH
108113: LD_VAR 0 2
108117: PPUSH
108118: CALL_OW 1
108122: ST_TO_ADDR
// end ;
108123: LD_VAR 0 3
108127: RET
// export function JoinUnion ( array , element ) ; begin
108128: LD_INT 0
108130: PPUSH
// result := array union element ;
108131: LD_ADDR_VAR 0 3
108135: PUSH
108136: LD_VAR 0 1
108140: PUSH
108141: LD_VAR 0 2
108145: UNION
108146: ST_TO_ADDR
// end ;
108147: LD_VAR 0 3
108151: RET
// export function GetBehemoths ( side ) ; begin
108152: LD_INT 0
108154: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
108155: LD_ADDR_VAR 0 2
108159: PUSH
108160: LD_INT 22
108162: PUSH
108163: LD_VAR 0 1
108167: PUSH
108168: EMPTY
108169: LIST
108170: LIST
108171: PUSH
108172: LD_INT 31
108174: PUSH
108175: LD_INT 25
108177: PUSH
108178: EMPTY
108179: LIST
108180: LIST
108181: PUSH
108182: EMPTY
108183: LIST
108184: LIST
108185: PPUSH
108186: CALL_OW 69
108190: ST_TO_ADDR
// end ;
108191: LD_VAR 0 2
108195: RET
// export function Shuffle ( array ) ; var i , index ; begin
108196: LD_INT 0
108198: PPUSH
108199: PPUSH
108200: PPUSH
// result := [ ] ;
108201: LD_ADDR_VAR 0 2
108205: PUSH
108206: EMPTY
108207: ST_TO_ADDR
// if not array then
108208: LD_VAR 0 1
108212: NOT
108213: IFFALSE 108217
// exit ;
108215: GO 108316
// Randomize ;
108217: CALL_OW 10
// for i = array downto 1 do
108221: LD_ADDR_VAR 0 3
108225: PUSH
108226: DOUBLE
108227: LD_VAR 0 1
108231: INC
108232: ST_TO_ADDR
108233: LD_INT 1
108235: PUSH
108236: FOR_DOWNTO
108237: IFFALSE 108314
// begin index := rand ( 1 , array ) ;
108239: LD_ADDR_VAR 0 4
108243: PUSH
108244: LD_INT 1
108246: PPUSH
108247: LD_VAR 0 1
108251: PPUSH
108252: CALL_OW 12
108256: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
108257: LD_ADDR_VAR 0 2
108261: PUSH
108262: LD_VAR 0 2
108266: PPUSH
108267: LD_VAR 0 2
108271: PUSH
108272: LD_INT 1
108274: PLUS
108275: PPUSH
108276: LD_VAR 0 1
108280: PUSH
108281: LD_VAR 0 4
108285: ARRAY
108286: PPUSH
108287: CALL_OW 2
108291: ST_TO_ADDR
// array := Delete ( array , index ) ;
108292: LD_ADDR_VAR 0 1
108296: PUSH
108297: LD_VAR 0 1
108301: PPUSH
108302: LD_VAR 0 4
108306: PPUSH
108307: CALL_OW 3
108311: ST_TO_ADDR
// end ;
108312: GO 108236
108314: POP
108315: POP
// end ;
108316: LD_VAR 0 2
108320: RET
// export function GetBaseMaterials ( base ) ; begin
108321: LD_INT 0
108323: PPUSH
// result := [ 0 , 0 , 0 ] ;
108324: LD_ADDR_VAR 0 2
108328: PUSH
108329: LD_INT 0
108331: PUSH
108332: LD_INT 0
108334: PUSH
108335: LD_INT 0
108337: PUSH
108338: EMPTY
108339: LIST
108340: LIST
108341: LIST
108342: ST_TO_ADDR
// if not base then
108343: LD_VAR 0 1
108347: NOT
108348: IFFALSE 108352
// exit ;
108350: GO 108401
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
108352: LD_ADDR_VAR 0 2
108356: PUSH
108357: LD_VAR 0 1
108361: PPUSH
108362: LD_INT 1
108364: PPUSH
108365: CALL_OW 275
108369: PUSH
108370: LD_VAR 0 1
108374: PPUSH
108375: LD_INT 2
108377: PPUSH
108378: CALL_OW 275
108382: PUSH
108383: LD_VAR 0 1
108387: PPUSH
108388: LD_INT 3
108390: PPUSH
108391: CALL_OW 275
108395: PUSH
108396: EMPTY
108397: LIST
108398: LIST
108399: LIST
108400: ST_TO_ADDR
// end ;
108401: LD_VAR 0 2
108405: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
108406: LD_INT 0
108408: PPUSH
108409: PPUSH
// result := array ;
108410: LD_ADDR_VAR 0 3
108414: PUSH
108415: LD_VAR 0 1
108419: ST_TO_ADDR
// if size >= result then
108420: LD_VAR 0 2
108424: PUSH
108425: LD_VAR 0 3
108429: GREATEREQUAL
108430: IFFALSE 108434
// exit ;
108432: GO 108484
// if size then
108434: LD_VAR 0 2
108438: IFFALSE 108484
// for i := array downto size do
108440: LD_ADDR_VAR 0 4
108444: PUSH
108445: DOUBLE
108446: LD_VAR 0 1
108450: INC
108451: ST_TO_ADDR
108452: LD_VAR 0 2
108456: PUSH
108457: FOR_DOWNTO
108458: IFFALSE 108482
// result := Delete ( result , result ) ;
108460: LD_ADDR_VAR 0 3
108464: PUSH
108465: LD_VAR 0 3
108469: PPUSH
108470: LD_VAR 0 3
108474: PPUSH
108475: CALL_OW 3
108479: ST_TO_ADDR
108480: GO 108457
108482: POP
108483: POP
// end ;
108484: LD_VAR 0 3
108488: RET
// export function ComExit ( unit ) ; var tmp ; begin
108489: LD_INT 0
108491: PPUSH
108492: PPUSH
// if not IsInUnit ( unit ) then
108493: LD_VAR 0 1
108497: PPUSH
108498: CALL_OW 310
108502: NOT
108503: IFFALSE 108507
// exit ;
108505: GO 108567
// tmp := IsInUnit ( unit ) ;
108507: LD_ADDR_VAR 0 3
108511: PUSH
108512: LD_VAR 0 1
108516: PPUSH
108517: CALL_OW 310
108521: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
108522: LD_VAR 0 3
108526: PPUSH
108527: CALL_OW 247
108531: PUSH
108532: LD_INT 2
108534: EQUAL
108535: IFFALSE 108548
// ComExitVehicle ( unit ) else
108537: LD_VAR 0 1
108541: PPUSH
108542: CALL_OW 121
108546: GO 108557
// ComExitBuilding ( unit ) ;
108548: LD_VAR 0 1
108552: PPUSH
108553: CALL_OW 122
// result := tmp ;
108557: LD_ADDR_VAR 0 2
108561: PUSH
108562: LD_VAR 0 3
108566: ST_TO_ADDR
// end ;
108567: LD_VAR 0 2
108571: RET
// export function ComExitAll ( units ) ; var i ; begin
108572: LD_INT 0
108574: PPUSH
108575: PPUSH
// if not units then
108576: LD_VAR 0 1
108580: NOT
108581: IFFALSE 108585
// exit ;
108583: GO 108611
// for i in units do
108585: LD_ADDR_VAR 0 3
108589: PUSH
108590: LD_VAR 0 1
108594: PUSH
108595: FOR_IN
108596: IFFALSE 108609
// ComExit ( i ) ;
108598: LD_VAR 0 3
108602: PPUSH
108603: CALL 108489 0 1
108607: GO 108595
108609: POP
108610: POP
// end ;
108611: LD_VAR 0 2
108615: RET
// export function ResetHc ; begin
108616: LD_INT 0
108618: PPUSH
// InitHc ;
108619: CALL_OW 19
// hc_importance := 0 ;
108623: LD_ADDR_OWVAR 32
108627: PUSH
108628: LD_INT 0
108630: ST_TO_ADDR
// end ;
108631: LD_VAR 0 1
108635: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
108636: LD_INT 0
108638: PPUSH
108639: PPUSH
108640: PPUSH
// _x := ( x1 + x2 ) div 2 ;
108641: LD_ADDR_VAR 0 6
108645: PUSH
108646: LD_VAR 0 1
108650: PUSH
108651: LD_VAR 0 3
108655: PLUS
108656: PUSH
108657: LD_INT 2
108659: DIV
108660: ST_TO_ADDR
// if _x < 0 then
108661: LD_VAR 0 6
108665: PUSH
108666: LD_INT 0
108668: LESS
108669: IFFALSE 108686
// _x := _x * - 1 ;
108671: LD_ADDR_VAR 0 6
108675: PUSH
108676: LD_VAR 0 6
108680: PUSH
108681: LD_INT 1
108683: NEG
108684: MUL
108685: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
108686: LD_ADDR_VAR 0 7
108690: PUSH
108691: LD_VAR 0 2
108695: PUSH
108696: LD_VAR 0 4
108700: PLUS
108701: PUSH
108702: LD_INT 2
108704: DIV
108705: ST_TO_ADDR
// if _y < 0 then
108706: LD_VAR 0 7
108710: PUSH
108711: LD_INT 0
108713: LESS
108714: IFFALSE 108731
// _y := _y * - 1 ;
108716: LD_ADDR_VAR 0 7
108720: PUSH
108721: LD_VAR 0 7
108725: PUSH
108726: LD_INT 1
108728: NEG
108729: MUL
108730: ST_TO_ADDR
// result := [ _x , _y ] ;
108731: LD_ADDR_VAR 0 5
108735: PUSH
108736: LD_VAR 0 6
108740: PUSH
108741: LD_VAR 0 7
108745: PUSH
108746: EMPTY
108747: LIST
108748: LIST
108749: ST_TO_ADDR
// end ;
108750: LD_VAR 0 5
108754: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
108755: LD_INT 0
108757: PPUSH
108758: PPUSH
108759: PPUSH
108760: PPUSH
// task := GetTaskList ( unit ) ;
108761: LD_ADDR_VAR 0 7
108765: PUSH
108766: LD_VAR 0 1
108770: PPUSH
108771: CALL_OW 437
108775: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
108776: LD_VAR 0 7
108780: NOT
108781: PUSH
108782: LD_VAR 0 1
108786: PPUSH
108787: LD_VAR 0 2
108791: PPUSH
108792: CALL_OW 308
108796: NOT
108797: AND
108798: IFFALSE 108802
// exit ;
108800: GO 108920
// if IsInArea ( unit , area ) then
108802: LD_VAR 0 1
108806: PPUSH
108807: LD_VAR 0 2
108811: PPUSH
108812: CALL_OW 308
108816: IFFALSE 108834
// begin ComMoveToArea ( unit , goAway ) ;
108818: LD_VAR 0 1
108822: PPUSH
108823: LD_VAR 0 3
108827: PPUSH
108828: CALL_OW 113
// exit ;
108832: GO 108920
// end ; if task [ 1 ] [ 1 ] <> M then
108834: LD_VAR 0 7
108838: PUSH
108839: LD_INT 1
108841: ARRAY
108842: PUSH
108843: LD_INT 1
108845: ARRAY
108846: PUSH
108847: LD_STRING M
108849: NONEQUAL
108850: IFFALSE 108854
// exit ;
108852: GO 108920
// x := task [ 1 ] [ 2 ] ;
108854: LD_ADDR_VAR 0 5
108858: PUSH
108859: LD_VAR 0 7
108863: PUSH
108864: LD_INT 1
108866: ARRAY
108867: PUSH
108868: LD_INT 2
108870: ARRAY
108871: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
108872: LD_ADDR_VAR 0 6
108876: PUSH
108877: LD_VAR 0 7
108881: PUSH
108882: LD_INT 1
108884: ARRAY
108885: PUSH
108886: LD_INT 3
108888: ARRAY
108889: ST_TO_ADDR
// if InArea ( x , y , area ) then
108890: LD_VAR 0 5
108894: PPUSH
108895: LD_VAR 0 6
108899: PPUSH
108900: LD_VAR 0 2
108904: PPUSH
108905: CALL_OW 309
108909: IFFALSE 108920
// ComStop ( unit ) ;
108911: LD_VAR 0 1
108915: PPUSH
108916: CALL_OW 141
// end ;
108920: LD_VAR 0 4
108924: RET
// export function Abs ( value ) ; begin
108925: LD_INT 0
108927: PPUSH
// result := value ;
108928: LD_ADDR_VAR 0 2
108932: PUSH
108933: LD_VAR 0 1
108937: ST_TO_ADDR
// if value < 0 then
108938: LD_VAR 0 1
108942: PUSH
108943: LD_INT 0
108945: LESS
108946: IFFALSE 108963
// result := value * - 1 ;
108948: LD_ADDR_VAR 0 2
108952: PUSH
108953: LD_VAR 0 1
108957: PUSH
108958: LD_INT 1
108960: NEG
108961: MUL
108962: ST_TO_ADDR
// end ;
108963: LD_VAR 0 2
108967: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
108968: LD_INT 0
108970: PPUSH
108971: PPUSH
108972: PPUSH
108973: PPUSH
108974: PPUSH
108975: PPUSH
108976: PPUSH
108977: PPUSH
// if not unit or not building then
108978: LD_VAR 0 1
108982: NOT
108983: PUSH
108984: LD_VAR 0 2
108988: NOT
108989: OR
108990: IFFALSE 108994
// exit ;
108992: GO 109220
// x := GetX ( building ) ;
108994: LD_ADDR_VAR 0 4
108998: PUSH
108999: LD_VAR 0 2
109003: PPUSH
109004: CALL_OW 250
109008: ST_TO_ADDR
// y := GetY ( building ) ;
109009: LD_ADDR_VAR 0 6
109013: PUSH
109014: LD_VAR 0 2
109018: PPUSH
109019: CALL_OW 251
109023: ST_TO_ADDR
// d := GetDir ( building ) ;
109024: LD_ADDR_VAR 0 8
109028: PUSH
109029: LD_VAR 0 2
109033: PPUSH
109034: CALL_OW 254
109038: ST_TO_ADDR
// r := 4 ;
109039: LD_ADDR_VAR 0 9
109043: PUSH
109044: LD_INT 4
109046: ST_TO_ADDR
// for i := 1 to 5 do
109047: LD_ADDR_VAR 0 10
109051: PUSH
109052: DOUBLE
109053: LD_INT 1
109055: DEC
109056: ST_TO_ADDR
109057: LD_INT 5
109059: PUSH
109060: FOR_TO
109061: IFFALSE 109218
// begin _x := ShiftX ( x , d , r + i ) ;
109063: LD_ADDR_VAR 0 5
109067: PUSH
109068: LD_VAR 0 4
109072: PPUSH
109073: LD_VAR 0 8
109077: PPUSH
109078: LD_VAR 0 9
109082: PUSH
109083: LD_VAR 0 10
109087: PLUS
109088: PPUSH
109089: CALL_OW 272
109093: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
109094: LD_ADDR_VAR 0 7
109098: PUSH
109099: LD_VAR 0 6
109103: PPUSH
109104: LD_VAR 0 8
109108: PPUSH
109109: LD_VAR 0 9
109113: PUSH
109114: LD_VAR 0 10
109118: PLUS
109119: PPUSH
109120: CALL_OW 273
109124: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
109125: LD_VAR 0 5
109129: PPUSH
109130: LD_VAR 0 7
109134: PPUSH
109135: CALL_OW 488
109139: PUSH
109140: LD_VAR 0 5
109144: PPUSH
109145: LD_VAR 0 7
109149: PPUSH
109150: CALL_OW 428
109154: PPUSH
109155: CALL_OW 247
109159: PUSH
109160: LD_INT 3
109162: PUSH
109163: LD_INT 2
109165: PUSH
109166: EMPTY
109167: LIST
109168: LIST
109169: IN
109170: NOT
109171: AND
109172: IFFALSE 109216
// begin ComMoveXY ( unit , _x , _y ) ;
109174: LD_VAR 0 1
109178: PPUSH
109179: LD_VAR 0 5
109183: PPUSH
109184: LD_VAR 0 7
109188: PPUSH
109189: CALL_OW 111
// result := [ _x , _y ] ;
109193: LD_ADDR_VAR 0 3
109197: PUSH
109198: LD_VAR 0 5
109202: PUSH
109203: LD_VAR 0 7
109207: PUSH
109208: EMPTY
109209: LIST
109210: LIST
109211: ST_TO_ADDR
// exit ;
109212: POP
109213: POP
109214: GO 109220
// end ; end ;
109216: GO 109060
109218: POP
109219: POP
// end ;
109220: LD_VAR 0 3
109224: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
109225: LD_INT 0
109227: PPUSH
109228: PPUSH
109229: PPUSH
// result := 0 ;
109230: LD_ADDR_VAR 0 3
109234: PUSH
109235: LD_INT 0
109237: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
109238: LD_VAR 0 1
109242: PUSH
109243: LD_INT 0
109245: LESS
109246: PUSH
109247: LD_VAR 0 1
109251: PUSH
109252: LD_INT 8
109254: GREATER
109255: OR
109256: PUSH
109257: LD_VAR 0 2
109261: PUSH
109262: LD_INT 0
109264: LESS
109265: OR
109266: PUSH
109267: LD_VAR 0 2
109271: PUSH
109272: LD_INT 8
109274: GREATER
109275: OR
109276: IFFALSE 109280
// exit ;
109278: GO 109355
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
109280: LD_ADDR_VAR 0 4
109284: PUSH
109285: LD_INT 22
109287: PUSH
109288: LD_VAR 0 2
109292: PUSH
109293: EMPTY
109294: LIST
109295: LIST
109296: PPUSH
109297: CALL_OW 69
109301: PUSH
109302: FOR_IN
109303: IFFALSE 109353
// begin un := UnitShoot ( i ) ;
109305: LD_ADDR_VAR 0 5
109309: PUSH
109310: LD_VAR 0 4
109314: PPUSH
109315: CALL_OW 504
109319: ST_TO_ADDR
// if GetSide ( un ) = side1 then
109320: LD_VAR 0 5
109324: PPUSH
109325: CALL_OW 255
109329: PUSH
109330: LD_VAR 0 1
109334: EQUAL
109335: IFFALSE 109351
// begin result := un ;
109337: LD_ADDR_VAR 0 3
109341: PUSH
109342: LD_VAR 0 5
109346: ST_TO_ADDR
// exit ;
109347: POP
109348: POP
109349: GO 109355
// end ; end ;
109351: GO 109302
109353: POP
109354: POP
// end ;
109355: LD_VAR 0 3
109359: RET
// export function GetCargoBay ( units ) ; begin
109360: LD_INT 0
109362: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
109363: LD_ADDR_VAR 0 2
109367: PUSH
109368: LD_VAR 0 1
109372: PPUSH
109373: LD_INT 2
109375: PUSH
109376: LD_INT 34
109378: PUSH
109379: LD_INT 12
109381: PUSH
109382: EMPTY
109383: LIST
109384: LIST
109385: PUSH
109386: LD_INT 34
109388: PUSH
109389: LD_INT 51
109391: PUSH
109392: EMPTY
109393: LIST
109394: LIST
109395: PUSH
109396: LD_INT 34
109398: PUSH
109399: LD_INT 32
109401: PUSH
109402: EMPTY
109403: LIST
109404: LIST
109405: PUSH
109406: LD_INT 34
109408: PUSH
109409: LD_INT 89
109411: PUSH
109412: EMPTY
109413: LIST
109414: LIST
109415: PUSH
109416: EMPTY
109417: LIST
109418: LIST
109419: LIST
109420: LIST
109421: LIST
109422: PPUSH
109423: CALL_OW 72
109427: ST_TO_ADDR
// end ;
109428: LD_VAR 0 2
109432: RET
// export function Negate ( value ) ; begin
109433: LD_INT 0
109435: PPUSH
// result := not value ;
109436: LD_ADDR_VAR 0 2
109440: PUSH
109441: LD_VAR 0 1
109445: NOT
109446: ST_TO_ADDR
// end ;
109447: LD_VAR 0 2
109451: RET
// export function Inc ( value ) ; begin
109452: LD_INT 0
109454: PPUSH
// result := value + 1 ;
109455: LD_ADDR_VAR 0 2
109459: PUSH
109460: LD_VAR 0 1
109464: PUSH
109465: LD_INT 1
109467: PLUS
109468: ST_TO_ADDR
// end ;
109469: LD_VAR 0 2
109473: RET
// export function Dec ( value ) ; begin
109474: LD_INT 0
109476: PPUSH
// result := value - 1 ;
109477: LD_ADDR_VAR 0 2
109481: PUSH
109482: LD_VAR 0 1
109486: PUSH
109487: LD_INT 1
109489: MINUS
109490: ST_TO_ADDR
// end ;
109491: LD_VAR 0 2
109495: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
109496: LD_INT 0
109498: PPUSH
109499: PPUSH
109500: PPUSH
109501: PPUSH
109502: PPUSH
109503: PPUSH
109504: PPUSH
109505: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
109506: LD_VAR 0 1
109510: PPUSH
109511: LD_VAR 0 2
109515: PPUSH
109516: CALL_OW 488
109520: NOT
109521: PUSH
109522: LD_VAR 0 3
109526: PPUSH
109527: LD_VAR 0 4
109531: PPUSH
109532: CALL_OW 488
109536: NOT
109537: OR
109538: IFFALSE 109551
// begin result := - 1 ;
109540: LD_ADDR_VAR 0 5
109544: PUSH
109545: LD_INT 1
109547: NEG
109548: ST_TO_ADDR
// exit ;
109549: GO 109786
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
109551: LD_ADDR_VAR 0 12
109555: PUSH
109556: LD_VAR 0 1
109560: PPUSH
109561: LD_VAR 0 2
109565: PPUSH
109566: LD_VAR 0 3
109570: PPUSH
109571: LD_VAR 0 4
109575: PPUSH
109576: CALL 108636 0 4
109580: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
109581: LD_ADDR_VAR 0 11
109585: PUSH
109586: LD_VAR 0 1
109590: PPUSH
109591: LD_VAR 0 2
109595: PPUSH
109596: LD_VAR 0 12
109600: PUSH
109601: LD_INT 1
109603: ARRAY
109604: PPUSH
109605: LD_VAR 0 12
109609: PUSH
109610: LD_INT 2
109612: ARRAY
109613: PPUSH
109614: CALL_OW 298
109618: ST_TO_ADDR
// distance := 9999 ;
109619: LD_ADDR_VAR 0 10
109623: PUSH
109624: LD_INT 9999
109626: ST_TO_ADDR
// for i := 0 to 5 do
109627: LD_ADDR_VAR 0 6
109631: PUSH
109632: DOUBLE
109633: LD_INT 0
109635: DEC
109636: ST_TO_ADDR
109637: LD_INT 5
109639: PUSH
109640: FOR_TO
109641: IFFALSE 109784
// begin _x := ShiftX ( x1 , i , centerDist ) ;
109643: LD_ADDR_VAR 0 7
109647: PUSH
109648: LD_VAR 0 1
109652: PPUSH
109653: LD_VAR 0 6
109657: PPUSH
109658: LD_VAR 0 11
109662: PPUSH
109663: CALL_OW 272
109667: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
109668: LD_ADDR_VAR 0 8
109672: PUSH
109673: LD_VAR 0 2
109677: PPUSH
109678: LD_VAR 0 6
109682: PPUSH
109683: LD_VAR 0 11
109687: PPUSH
109688: CALL_OW 273
109692: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
109693: LD_VAR 0 7
109697: PPUSH
109698: LD_VAR 0 8
109702: PPUSH
109703: CALL_OW 488
109707: NOT
109708: IFFALSE 109712
// continue ;
109710: GO 109640
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
109712: LD_ADDR_VAR 0 9
109716: PUSH
109717: LD_VAR 0 12
109721: PUSH
109722: LD_INT 1
109724: ARRAY
109725: PPUSH
109726: LD_VAR 0 12
109730: PUSH
109731: LD_INT 2
109733: ARRAY
109734: PPUSH
109735: LD_VAR 0 7
109739: PPUSH
109740: LD_VAR 0 8
109744: PPUSH
109745: CALL_OW 298
109749: ST_TO_ADDR
// if tmp < distance then
109750: LD_VAR 0 9
109754: PUSH
109755: LD_VAR 0 10
109759: LESS
109760: IFFALSE 109782
// begin result := i ;
109762: LD_ADDR_VAR 0 5
109766: PUSH
109767: LD_VAR 0 6
109771: ST_TO_ADDR
// distance := tmp ;
109772: LD_ADDR_VAR 0 10
109776: PUSH
109777: LD_VAR 0 9
109781: ST_TO_ADDR
// end ; end ;
109782: GO 109640
109784: POP
109785: POP
// end ;
109786: LD_VAR 0 5
109790: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
109791: LD_INT 0
109793: PPUSH
109794: PPUSH
// if not driver or not IsInUnit ( driver ) then
109795: LD_VAR 0 1
109799: NOT
109800: PUSH
109801: LD_VAR 0 1
109805: PPUSH
109806: CALL_OW 310
109810: NOT
109811: OR
109812: IFFALSE 109816
// exit ;
109814: GO 109906
// vehicle := IsInUnit ( driver ) ;
109816: LD_ADDR_VAR 0 3
109820: PUSH
109821: LD_VAR 0 1
109825: PPUSH
109826: CALL_OW 310
109830: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
109831: LD_VAR 0 1
109835: PPUSH
109836: LD_STRING \
109838: PUSH
109839: LD_INT 0
109841: PUSH
109842: LD_INT 0
109844: PUSH
109845: LD_INT 0
109847: PUSH
109848: LD_INT 0
109850: PUSH
109851: LD_INT 0
109853: PUSH
109854: LD_INT 0
109856: PUSH
109857: EMPTY
109858: LIST
109859: LIST
109860: LIST
109861: LIST
109862: LIST
109863: LIST
109864: LIST
109865: PUSH
109866: LD_STRING E
109868: PUSH
109869: LD_INT 0
109871: PUSH
109872: LD_INT 0
109874: PUSH
109875: LD_VAR 0 3
109879: PUSH
109880: LD_INT 0
109882: PUSH
109883: LD_INT 0
109885: PUSH
109886: LD_INT 0
109888: PUSH
109889: EMPTY
109890: LIST
109891: LIST
109892: LIST
109893: LIST
109894: LIST
109895: LIST
109896: LIST
109897: PUSH
109898: EMPTY
109899: LIST
109900: LIST
109901: PPUSH
109902: CALL_OW 446
// end ;
109906: LD_VAR 0 2
109910: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
109911: LD_INT 0
109913: PPUSH
109914: PPUSH
// if not driver or not IsInUnit ( driver ) then
109915: LD_VAR 0 1
109919: NOT
109920: PUSH
109921: LD_VAR 0 1
109925: PPUSH
109926: CALL_OW 310
109930: NOT
109931: OR
109932: IFFALSE 109936
// exit ;
109934: GO 110026
// vehicle := IsInUnit ( driver ) ;
109936: LD_ADDR_VAR 0 3
109940: PUSH
109941: LD_VAR 0 1
109945: PPUSH
109946: CALL_OW 310
109950: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
109951: LD_VAR 0 1
109955: PPUSH
109956: LD_STRING \
109958: PUSH
109959: LD_INT 0
109961: PUSH
109962: LD_INT 0
109964: PUSH
109965: LD_INT 0
109967: PUSH
109968: LD_INT 0
109970: PUSH
109971: LD_INT 0
109973: PUSH
109974: LD_INT 0
109976: PUSH
109977: EMPTY
109978: LIST
109979: LIST
109980: LIST
109981: LIST
109982: LIST
109983: LIST
109984: LIST
109985: PUSH
109986: LD_STRING E
109988: PUSH
109989: LD_INT 0
109991: PUSH
109992: LD_INT 0
109994: PUSH
109995: LD_VAR 0 3
109999: PUSH
110000: LD_INT 0
110002: PUSH
110003: LD_INT 0
110005: PUSH
110006: LD_INT 0
110008: PUSH
110009: EMPTY
110010: LIST
110011: LIST
110012: LIST
110013: LIST
110014: LIST
110015: LIST
110016: LIST
110017: PUSH
110018: EMPTY
110019: LIST
110020: LIST
110021: PPUSH
110022: CALL_OW 447
// end ;
110026: LD_VAR 0 2
110030: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
110031: LD_INT 0
110033: PPUSH
110034: PPUSH
110035: PPUSH
// tmp := [ ] ;
110036: LD_ADDR_VAR 0 5
110040: PUSH
110041: EMPTY
110042: ST_TO_ADDR
// for i in units do
110043: LD_ADDR_VAR 0 4
110047: PUSH
110048: LD_VAR 0 1
110052: PUSH
110053: FOR_IN
110054: IFFALSE 110092
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
110056: LD_ADDR_VAR 0 5
110060: PUSH
110061: LD_VAR 0 5
110065: PPUSH
110066: LD_VAR 0 5
110070: PUSH
110071: LD_INT 1
110073: PLUS
110074: PPUSH
110075: LD_VAR 0 4
110079: PPUSH
110080: CALL_OW 256
110084: PPUSH
110085: CALL_OW 2
110089: ST_TO_ADDR
110090: GO 110053
110092: POP
110093: POP
// if not tmp then
110094: LD_VAR 0 5
110098: NOT
110099: IFFALSE 110103
// exit ;
110101: GO 110151
// if asc then
110103: LD_VAR 0 2
110107: IFFALSE 110131
// result := SortListByListAsc ( units , tmp ) else
110109: LD_ADDR_VAR 0 3
110113: PUSH
110114: LD_VAR 0 1
110118: PPUSH
110119: LD_VAR 0 5
110123: PPUSH
110124: CALL_OW 76
110128: ST_TO_ADDR
110129: GO 110151
// result := SortListByListDesc ( units , tmp ) ;
110131: LD_ADDR_VAR 0 3
110135: PUSH
110136: LD_VAR 0 1
110140: PPUSH
110141: LD_VAR 0 5
110145: PPUSH
110146: CALL_OW 77
110150: ST_TO_ADDR
// end ;
110151: LD_VAR 0 3
110155: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
110156: LD_INT 0
110158: PPUSH
110159: PPUSH
// task := GetTaskList ( mech ) ;
110160: LD_ADDR_VAR 0 4
110164: PUSH
110165: LD_VAR 0 1
110169: PPUSH
110170: CALL_OW 437
110174: ST_TO_ADDR
// if not task then
110175: LD_VAR 0 4
110179: NOT
110180: IFFALSE 110184
// exit ;
110182: GO 110226
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
110184: LD_ADDR_VAR 0 3
110188: PUSH
110189: LD_VAR 0 4
110193: PUSH
110194: LD_INT 1
110196: ARRAY
110197: PUSH
110198: LD_INT 1
110200: ARRAY
110201: PUSH
110202: LD_STRING r
110204: EQUAL
110205: PUSH
110206: LD_VAR 0 4
110210: PUSH
110211: LD_INT 1
110213: ARRAY
110214: PUSH
110215: LD_INT 4
110217: ARRAY
110218: PUSH
110219: LD_VAR 0 2
110223: EQUAL
110224: AND
110225: ST_TO_ADDR
// end ;
110226: LD_VAR 0 3
110230: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
110231: LD_INT 0
110233: PPUSH
// SetDir ( unit , d ) ;
110234: LD_VAR 0 1
110238: PPUSH
110239: LD_VAR 0 4
110243: PPUSH
110244: CALL_OW 233
// result := PlaceUnitXY ( unit , x , y , mode ) ;
110248: LD_ADDR_VAR 0 6
110252: PUSH
110253: LD_VAR 0 1
110257: PPUSH
110258: LD_VAR 0 2
110262: PPUSH
110263: LD_VAR 0 3
110267: PPUSH
110268: LD_VAR 0 5
110272: PPUSH
110273: CALL_OW 48
110277: ST_TO_ADDR
// end ;
110278: LD_VAR 0 6
110282: RET
// export function ToNaturalNumber ( number ) ; begin
110283: LD_INT 0
110285: PPUSH
// result := number div 1 ;
110286: LD_ADDR_VAR 0 2
110290: PUSH
110291: LD_VAR 0 1
110295: PUSH
110296: LD_INT 1
110298: DIV
110299: ST_TO_ADDR
// if number < 0 then
110300: LD_VAR 0 1
110304: PUSH
110305: LD_INT 0
110307: LESS
110308: IFFALSE 110318
// result := 0 ;
110310: LD_ADDR_VAR 0 2
110314: PUSH
110315: LD_INT 0
110317: ST_TO_ADDR
// end ;
110318: LD_VAR 0 2
110322: RET
// export function SortByClass ( units , class ) ; var un ; begin
110323: LD_INT 0
110325: PPUSH
110326: PPUSH
// if not units or not class then
110327: LD_VAR 0 1
110331: NOT
110332: PUSH
110333: LD_VAR 0 2
110337: NOT
110338: OR
110339: IFFALSE 110343
// exit ;
110341: GO 110438
// result := [ ] ;
110343: LD_ADDR_VAR 0 3
110347: PUSH
110348: EMPTY
110349: ST_TO_ADDR
// for un in units do
110350: LD_ADDR_VAR 0 4
110354: PUSH
110355: LD_VAR 0 1
110359: PUSH
110360: FOR_IN
110361: IFFALSE 110436
// if GetClass ( un ) = class then
110363: LD_VAR 0 4
110367: PPUSH
110368: CALL_OW 257
110372: PUSH
110373: LD_VAR 0 2
110377: EQUAL
110378: IFFALSE 110405
// result := Insert ( result , 1 , un ) else
110380: LD_ADDR_VAR 0 3
110384: PUSH
110385: LD_VAR 0 3
110389: PPUSH
110390: LD_INT 1
110392: PPUSH
110393: LD_VAR 0 4
110397: PPUSH
110398: CALL_OW 2
110402: ST_TO_ADDR
110403: GO 110434
// result := Replace ( result , result + 1 , un ) ;
110405: LD_ADDR_VAR 0 3
110409: PUSH
110410: LD_VAR 0 3
110414: PPUSH
110415: LD_VAR 0 3
110419: PUSH
110420: LD_INT 1
110422: PLUS
110423: PPUSH
110424: LD_VAR 0 4
110428: PPUSH
110429: CALL_OW 1
110433: ST_TO_ADDR
110434: GO 110360
110436: POP
110437: POP
// end ;
110438: LD_VAR 0 3
110442: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
110443: LD_INT 0
110445: PPUSH
110446: PPUSH
110447: PPUSH
110448: PPUSH
110449: PPUSH
110450: PPUSH
110451: PPUSH
// result := [ ] ;
110452: LD_ADDR_VAR 0 4
110456: PUSH
110457: EMPTY
110458: ST_TO_ADDR
// if x - r < 0 then
110459: LD_VAR 0 1
110463: PUSH
110464: LD_VAR 0 3
110468: MINUS
110469: PUSH
110470: LD_INT 0
110472: LESS
110473: IFFALSE 110485
// min_x := 0 else
110475: LD_ADDR_VAR 0 8
110479: PUSH
110480: LD_INT 0
110482: ST_TO_ADDR
110483: GO 110501
// min_x := x - r ;
110485: LD_ADDR_VAR 0 8
110489: PUSH
110490: LD_VAR 0 1
110494: PUSH
110495: LD_VAR 0 3
110499: MINUS
110500: ST_TO_ADDR
// if y - r < 0 then
110501: LD_VAR 0 2
110505: PUSH
110506: LD_VAR 0 3
110510: MINUS
110511: PUSH
110512: LD_INT 0
110514: LESS
110515: IFFALSE 110527
// min_y := 0 else
110517: LD_ADDR_VAR 0 7
110521: PUSH
110522: LD_INT 0
110524: ST_TO_ADDR
110525: GO 110543
// min_y := y - r ;
110527: LD_ADDR_VAR 0 7
110531: PUSH
110532: LD_VAR 0 2
110536: PUSH
110537: LD_VAR 0 3
110541: MINUS
110542: ST_TO_ADDR
// max_x := x + r ;
110543: LD_ADDR_VAR 0 9
110547: PUSH
110548: LD_VAR 0 1
110552: PUSH
110553: LD_VAR 0 3
110557: PLUS
110558: ST_TO_ADDR
// max_y := y + r ;
110559: LD_ADDR_VAR 0 10
110563: PUSH
110564: LD_VAR 0 2
110568: PUSH
110569: LD_VAR 0 3
110573: PLUS
110574: ST_TO_ADDR
// for _x = min_x to max_x do
110575: LD_ADDR_VAR 0 5
110579: PUSH
110580: DOUBLE
110581: LD_VAR 0 8
110585: DEC
110586: ST_TO_ADDR
110587: LD_VAR 0 9
110591: PUSH
110592: FOR_TO
110593: IFFALSE 110694
// for _y = min_y to max_y do
110595: LD_ADDR_VAR 0 6
110599: PUSH
110600: DOUBLE
110601: LD_VAR 0 7
110605: DEC
110606: ST_TO_ADDR
110607: LD_VAR 0 10
110611: PUSH
110612: FOR_TO
110613: IFFALSE 110690
// begin if not ValidHex ( _x , _y ) then
110615: LD_VAR 0 5
110619: PPUSH
110620: LD_VAR 0 6
110624: PPUSH
110625: CALL_OW 488
110629: NOT
110630: IFFALSE 110634
// continue ;
110632: GO 110612
// if GetResourceTypeXY ( _x , _y ) then
110634: LD_VAR 0 5
110638: PPUSH
110639: LD_VAR 0 6
110643: PPUSH
110644: CALL_OW 283
110648: IFFALSE 110688
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
110650: LD_ADDR_VAR 0 4
110654: PUSH
110655: LD_VAR 0 4
110659: PPUSH
110660: LD_VAR 0 4
110664: PUSH
110665: LD_INT 1
110667: PLUS
110668: PPUSH
110669: LD_VAR 0 5
110673: PUSH
110674: LD_VAR 0 6
110678: PUSH
110679: EMPTY
110680: LIST
110681: LIST
110682: PPUSH
110683: CALL_OW 1
110687: ST_TO_ADDR
// end ;
110688: GO 110612
110690: POP
110691: POP
110692: GO 110592
110694: POP
110695: POP
// end ;
110696: LD_VAR 0 4
110700: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
110701: LD_INT 0
110703: PPUSH
110704: PPUSH
110705: PPUSH
110706: PPUSH
110707: PPUSH
110708: PPUSH
110709: PPUSH
110710: PPUSH
// if not units then
110711: LD_VAR 0 1
110715: NOT
110716: IFFALSE 110720
// exit ;
110718: GO 111248
// result := UnitFilter ( units , [ f_ok ] ) ;
110720: LD_ADDR_VAR 0 3
110724: PUSH
110725: LD_VAR 0 1
110729: PPUSH
110730: LD_INT 50
110732: PUSH
110733: EMPTY
110734: LIST
110735: PPUSH
110736: CALL_OW 72
110740: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
110741: LD_ADDR_VAR 0 8
110745: PUSH
110746: LD_VAR 0 1
110750: PUSH
110751: LD_INT 1
110753: ARRAY
110754: PPUSH
110755: CALL_OW 255
110759: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
110760: LD_ADDR_VAR 0 10
110764: PUSH
110765: LD_INT 29
110767: PUSH
110768: LD_INT 91
110770: PUSH
110771: LD_INT 49
110773: PUSH
110774: EMPTY
110775: LIST
110776: LIST
110777: LIST
110778: ST_TO_ADDR
// if not result then
110779: LD_VAR 0 3
110783: NOT
110784: IFFALSE 110788
// exit ;
110786: GO 111248
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
110788: LD_ADDR_VAR 0 5
110792: PUSH
110793: LD_INT 81
110795: PUSH
110796: LD_VAR 0 8
110800: PUSH
110801: EMPTY
110802: LIST
110803: LIST
110804: PPUSH
110805: CALL_OW 69
110809: ST_TO_ADDR
// for i in result do
110810: LD_ADDR_VAR 0 4
110814: PUSH
110815: LD_VAR 0 3
110819: PUSH
110820: FOR_IN
110821: IFFALSE 111246
// begin tag := GetTag ( i ) + 1 ;
110823: LD_ADDR_VAR 0 9
110827: PUSH
110828: LD_VAR 0 4
110832: PPUSH
110833: CALL_OW 110
110837: PUSH
110838: LD_INT 1
110840: PLUS
110841: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
110842: LD_ADDR_VAR 0 7
110846: PUSH
110847: LD_VAR 0 4
110851: PPUSH
110852: CALL_OW 250
110856: PPUSH
110857: LD_VAR 0 4
110861: PPUSH
110862: CALL_OW 251
110866: PPUSH
110867: LD_INT 4
110869: PPUSH
110870: CALL 110443 0 3
110874: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
110875: LD_VAR 0 4
110879: PPUSH
110880: CALL_OW 247
110884: PUSH
110885: LD_INT 2
110887: EQUAL
110888: PUSH
110889: LD_VAR 0 7
110893: PUSH
110894: LD_INT 2
110896: GREATER
110897: AND
110898: PUSH
110899: LD_VAR 0 4
110903: PPUSH
110904: CALL_OW 264
110908: PUSH
110909: LD_VAR 0 10
110913: IN
110914: NOT
110915: AND
110916: IFFALSE 110955
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
110918: LD_VAR 0 4
110922: PPUSH
110923: LD_VAR 0 7
110927: PUSH
110928: LD_INT 1
110930: ARRAY
110931: PUSH
110932: LD_INT 1
110934: ARRAY
110935: PPUSH
110936: LD_VAR 0 7
110940: PUSH
110941: LD_INT 1
110943: ARRAY
110944: PUSH
110945: LD_INT 2
110947: ARRAY
110948: PPUSH
110949: CALL_OW 116
110953: GO 111244
// if path > tag then
110955: LD_VAR 0 2
110959: PUSH
110960: LD_VAR 0 9
110964: GREATER
110965: IFFALSE 111173
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
110967: LD_ADDR_VAR 0 6
110971: PUSH
110972: LD_VAR 0 5
110976: PPUSH
110977: LD_INT 91
110979: PUSH
110980: LD_VAR 0 4
110984: PUSH
110985: LD_INT 8
110987: PUSH
110988: EMPTY
110989: LIST
110990: LIST
110991: LIST
110992: PPUSH
110993: CALL_OW 72
110997: ST_TO_ADDR
// if nearEnemy then
110998: LD_VAR 0 6
111002: IFFALSE 111071
// begin if GetWeapon ( i ) = ru_time_lapser then
111004: LD_VAR 0 4
111008: PPUSH
111009: CALL_OW 264
111013: PUSH
111014: LD_INT 49
111016: EQUAL
111017: IFFALSE 111045
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
111019: LD_VAR 0 4
111023: PPUSH
111024: LD_VAR 0 6
111028: PPUSH
111029: LD_VAR 0 4
111033: PPUSH
111034: CALL_OW 74
111038: PPUSH
111039: CALL_OW 112
111043: GO 111069
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
111045: LD_VAR 0 4
111049: PPUSH
111050: LD_VAR 0 6
111054: PPUSH
111055: LD_VAR 0 4
111059: PPUSH
111060: CALL_OW 74
111064: PPUSH
111065: CALL 112319 0 2
// end else
111069: GO 111171
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
111071: LD_VAR 0 4
111075: PPUSH
111076: LD_VAR 0 2
111080: PUSH
111081: LD_VAR 0 9
111085: ARRAY
111086: PUSH
111087: LD_INT 1
111089: ARRAY
111090: PPUSH
111091: LD_VAR 0 2
111095: PUSH
111096: LD_VAR 0 9
111100: ARRAY
111101: PUSH
111102: LD_INT 2
111104: ARRAY
111105: PPUSH
111106: CALL_OW 297
111110: PUSH
111111: LD_INT 6
111113: GREATER
111114: IFFALSE 111157
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
111116: LD_VAR 0 4
111120: PPUSH
111121: LD_VAR 0 2
111125: PUSH
111126: LD_VAR 0 9
111130: ARRAY
111131: PUSH
111132: LD_INT 1
111134: ARRAY
111135: PPUSH
111136: LD_VAR 0 2
111140: PUSH
111141: LD_VAR 0 9
111145: ARRAY
111146: PUSH
111147: LD_INT 2
111149: ARRAY
111150: PPUSH
111151: CALL_OW 114
111155: GO 111171
// SetTag ( i , tag ) ;
111157: LD_VAR 0 4
111161: PPUSH
111162: LD_VAR 0 9
111166: PPUSH
111167: CALL_OW 109
// end else
111171: GO 111244
// if enemy then
111173: LD_VAR 0 5
111177: IFFALSE 111244
// begin if GetWeapon ( i ) = ru_time_lapser then
111179: LD_VAR 0 4
111183: PPUSH
111184: CALL_OW 264
111188: PUSH
111189: LD_INT 49
111191: EQUAL
111192: IFFALSE 111220
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
111194: LD_VAR 0 4
111198: PPUSH
111199: LD_VAR 0 5
111203: PPUSH
111204: LD_VAR 0 4
111208: PPUSH
111209: CALL_OW 74
111213: PPUSH
111214: CALL_OW 112
111218: GO 111244
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
111220: LD_VAR 0 4
111224: PPUSH
111225: LD_VAR 0 5
111229: PPUSH
111230: LD_VAR 0 4
111234: PPUSH
111235: CALL_OW 74
111239: PPUSH
111240: CALL 112319 0 2
// end ; end ;
111244: GO 110820
111246: POP
111247: POP
// end ;
111248: LD_VAR 0 3
111252: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
111253: LD_INT 0
111255: PPUSH
111256: PPUSH
111257: PPUSH
// if not unit or IsInUnit ( unit ) then
111258: LD_VAR 0 1
111262: NOT
111263: PUSH
111264: LD_VAR 0 1
111268: PPUSH
111269: CALL_OW 310
111273: OR
111274: IFFALSE 111278
// exit ;
111276: GO 111369
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
111278: LD_ADDR_VAR 0 4
111282: PUSH
111283: LD_VAR 0 1
111287: PPUSH
111288: CALL_OW 250
111292: PPUSH
111293: LD_VAR 0 2
111297: PPUSH
111298: LD_INT 1
111300: PPUSH
111301: CALL_OW 272
111305: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
111306: LD_ADDR_VAR 0 5
111310: PUSH
111311: LD_VAR 0 1
111315: PPUSH
111316: CALL_OW 251
111320: PPUSH
111321: LD_VAR 0 2
111325: PPUSH
111326: LD_INT 1
111328: PPUSH
111329: CALL_OW 273
111333: ST_TO_ADDR
// if ValidHex ( x , y ) then
111334: LD_VAR 0 4
111338: PPUSH
111339: LD_VAR 0 5
111343: PPUSH
111344: CALL_OW 488
111348: IFFALSE 111369
// ComTurnXY ( unit , x , y ) ;
111350: LD_VAR 0 1
111354: PPUSH
111355: LD_VAR 0 4
111359: PPUSH
111360: LD_VAR 0 5
111364: PPUSH
111365: CALL_OW 118
// end ;
111369: LD_VAR 0 3
111373: RET
// export function SeeUnits ( side , units ) ; var i ; begin
111374: LD_INT 0
111376: PPUSH
111377: PPUSH
// result := false ;
111378: LD_ADDR_VAR 0 3
111382: PUSH
111383: LD_INT 0
111385: ST_TO_ADDR
// if not units then
111386: LD_VAR 0 2
111390: NOT
111391: IFFALSE 111395
// exit ;
111393: GO 111440
// for i in units do
111395: LD_ADDR_VAR 0 4
111399: PUSH
111400: LD_VAR 0 2
111404: PUSH
111405: FOR_IN
111406: IFFALSE 111438
// if See ( side , i ) then
111408: LD_VAR 0 1
111412: PPUSH
111413: LD_VAR 0 4
111417: PPUSH
111418: CALL_OW 292
111422: IFFALSE 111436
// begin result := true ;
111424: LD_ADDR_VAR 0 3
111428: PUSH
111429: LD_INT 1
111431: ST_TO_ADDR
// exit ;
111432: POP
111433: POP
111434: GO 111440
// end ;
111436: GO 111405
111438: POP
111439: POP
// end ;
111440: LD_VAR 0 3
111444: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
111445: LD_INT 0
111447: PPUSH
111448: PPUSH
111449: PPUSH
111450: PPUSH
// if not unit or not points then
111451: LD_VAR 0 1
111455: NOT
111456: PUSH
111457: LD_VAR 0 2
111461: NOT
111462: OR
111463: IFFALSE 111467
// exit ;
111465: GO 111557
// dist := 99999 ;
111467: LD_ADDR_VAR 0 5
111471: PUSH
111472: LD_INT 99999
111474: ST_TO_ADDR
// for i in points do
111475: LD_ADDR_VAR 0 4
111479: PUSH
111480: LD_VAR 0 2
111484: PUSH
111485: FOR_IN
111486: IFFALSE 111555
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
111488: LD_ADDR_VAR 0 6
111492: PUSH
111493: LD_VAR 0 1
111497: PPUSH
111498: LD_VAR 0 4
111502: PUSH
111503: LD_INT 1
111505: ARRAY
111506: PPUSH
111507: LD_VAR 0 4
111511: PUSH
111512: LD_INT 2
111514: ARRAY
111515: PPUSH
111516: CALL_OW 297
111520: ST_TO_ADDR
// if tmpDist < dist then
111521: LD_VAR 0 6
111525: PUSH
111526: LD_VAR 0 5
111530: LESS
111531: IFFALSE 111553
// begin result := i ;
111533: LD_ADDR_VAR 0 3
111537: PUSH
111538: LD_VAR 0 4
111542: ST_TO_ADDR
// dist := tmpDist ;
111543: LD_ADDR_VAR 0 5
111547: PUSH
111548: LD_VAR 0 6
111552: ST_TO_ADDR
// end ; end ;
111553: GO 111485
111555: POP
111556: POP
// end ;
111557: LD_VAR 0 3
111561: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
111562: LD_INT 0
111564: PPUSH
// uc_side := side ;
111565: LD_ADDR_OWVAR 20
111569: PUSH
111570: LD_VAR 0 1
111574: ST_TO_ADDR
// uc_nation := 3 ;
111575: LD_ADDR_OWVAR 21
111579: PUSH
111580: LD_INT 3
111582: ST_TO_ADDR
// vc_chassis := 25 ;
111583: LD_ADDR_OWVAR 37
111587: PUSH
111588: LD_INT 25
111590: ST_TO_ADDR
// vc_engine := engine_siberite ;
111591: LD_ADDR_OWVAR 39
111595: PUSH
111596: LD_INT 3
111598: ST_TO_ADDR
// vc_control := control_computer ;
111599: LD_ADDR_OWVAR 38
111603: PUSH
111604: LD_INT 3
111606: ST_TO_ADDR
// vc_weapon := 59 ;
111607: LD_ADDR_OWVAR 40
111611: PUSH
111612: LD_INT 59
111614: ST_TO_ADDR
// result := CreateVehicle ;
111615: LD_ADDR_VAR 0 5
111619: PUSH
111620: CALL_OW 45
111624: ST_TO_ADDR
// SetDir ( result , d ) ;
111625: LD_VAR 0 5
111629: PPUSH
111630: LD_VAR 0 4
111634: PPUSH
111635: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
111639: LD_VAR 0 5
111643: PPUSH
111644: LD_VAR 0 2
111648: PPUSH
111649: LD_VAR 0 3
111653: PPUSH
111654: LD_INT 0
111656: PPUSH
111657: CALL_OW 48
// end ;
111661: LD_VAR 0 5
111665: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
111666: LD_INT 0
111668: PPUSH
111669: PPUSH
111670: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
111671: LD_ADDR_VAR 0 2
111675: PUSH
111676: LD_INT 0
111678: PUSH
111679: LD_INT 0
111681: PUSH
111682: LD_INT 0
111684: PUSH
111685: LD_INT 0
111687: PUSH
111688: EMPTY
111689: LIST
111690: LIST
111691: LIST
111692: LIST
111693: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
111694: LD_VAR 0 1
111698: NOT
111699: PUSH
111700: LD_VAR 0 1
111704: PPUSH
111705: CALL_OW 264
111709: PUSH
111710: LD_INT 12
111712: PUSH
111713: LD_INT 51
111715: PUSH
111716: LD_INT 32
111718: PUSH
111719: LD_INT 89
111721: PUSH
111722: EMPTY
111723: LIST
111724: LIST
111725: LIST
111726: LIST
111727: IN
111728: NOT
111729: OR
111730: IFFALSE 111734
// exit ;
111732: GO 111832
// for i := 1 to 3 do
111734: LD_ADDR_VAR 0 3
111738: PUSH
111739: DOUBLE
111740: LD_INT 1
111742: DEC
111743: ST_TO_ADDR
111744: LD_INT 3
111746: PUSH
111747: FOR_TO
111748: IFFALSE 111830
// begin tmp := GetCargo ( cargo , i ) ;
111750: LD_ADDR_VAR 0 4
111754: PUSH
111755: LD_VAR 0 1
111759: PPUSH
111760: LD_VAR 0 3
111764: PPUSH
111765: CALL_OW 289
111769: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
111770: LD_ADDR_VAR 0 2
111774: PUSH
111775: LD_VAR 0 2
111779: PPUSH
111780: LD_VAR 0 3
111784: PPUSH
111785: LD_VAR 0 4
111789: PPUSH
111790: CALL_OW 1
111794: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
111795: LD_ADDR_VAR 0 2
111799: PUSH
111800: LD_VAR 0 2
111804: PPUSH
111805: LD_INT 4
111807: PPUSH
111808: LD_VAR 0 2
111812: PUSH
111813: LD_INT 4
111815: ARRAY
111816: PUSH
111817: LD_VAR 0 4
111821: PLUS
111822: PPUSH
111823: CALL_OW 1
111827: ST_TO_ADDR
// end ;
111828: GO 111747
111830: POP
111831: POP
// end ;
111832: LD_VAR 0 2
111836: RET
// export function Length ( array ) ; begin
111837: LD_INT 0
111839: PPUSH
// result := array + 0 ;
111840: LD_ADDR_VAR 0 2
111844: PUSH
111845: LD_VAR 0 1
111849: PUSH
111850: LD_INT 0
111852: PLUS
111853: ST_TO_ADDR
// end ;
111854: LD_VAR 0 2
111858: RET
// export function PrepareArray ( array ) ; begin
111859: LD_INT 0
111861: PPUSH
// result := array diff 0 ;
111862: LD_ADDR_VAR 0 2
111866: PUSH
111867: LD_VAR 0 1
111871: PUSH
111872: LD_INT 0
111874: DIFF
111875: ST_TO_ADDR
// if not result [ 1 ] then
111876: LD_VAR 0 2
111880: PUSH
111881: LD_INT 1
111883: ARRAY
111884: NOT
111885: IFFALSE 111905
// result := Delete ( result , 1 ) ;
111887: LD_ADDR_VAR 0 2
111891: PUSH
111892: LD_VAR 0 2
111896: PPUSH
111897: LD_INT 1
111899: PPUSH
111900: CALL_OW 3
111904: ST_TO_ADDR
// end ;
111905: LD_VAR 0 2
111909: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
111910: LD_INT 0
111912: PPUSH
111913: PPUSH
111914: PPUSH
111915: PPUSH
// sibRocketRange := 25 ;
111916: LD_ADDR_VAR 0 6
111920: PUSH
111921: LD_INT 25
111923: ST_TO_ADDR
// result := false ;
111924: LD_ADDR_VAR 0 4
111928: PUSH
111929: LD_INT 0
111931: ST_TO_ADDR
// for i := 0 to 5 do
111932: LD_ADDR_VAR 0 5
111936: PUSH
111937: DOUBLE
111938: LD_INT 0
111940: DEC
111941: ST_TO_ADDR
111942: LD_INT 5
111944: PUSH
111945: FOR_TO
111946: IFFALSE 112013
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
111948: LD_VAR 0 1
111952: PPUSH
111953: LD_VAR 0 5
111957: PPUSH
111958: LD_VAR 0 6
111962: PPUSH
111963: CALL_OW 272
111967: PPUSH
111968: LD_VAR 0 2
111972: PPUSH
111973: LD_VAR 0 5
111977: PPUSH
111978: LD_VAR 0 6
111982: PPUSH
111983: CALL_OW 273
111987: PPUSH
111988: LD_VAR 0 3
111992: PPUSH
111993: CALL_OW 309
111997: IFFALSE 112011
// begin result := true ;
111999: LD_ADDR_VAR 0 4
112003: PUSH
112004: LD_INT 1
112006: ST_TO_ADDR
// exit ;
112007: POP
112008: POP
112009: GO 112015
// end ;
112011: GO 111945
112013: POP
112014: POP
// end ;
112015: LD_VAR 0 4
112019: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
112020: LD_INT 0
112022: PPUSH
112023: PPUSH
112024: PPUSH
// if btype = b_depot then
112025: LD_VAR 0 2
112029: PUSH
112030: LD_INT 0
112032: EQUAL
112033: IFFALSE 112045
// begin result := true ;
112035: LD_ADDR_VAR 0 3
112039: PUSH
112040: LD_INT 1
112042: ST_TO_ADDR
// exit ;
112043: GO 112161
// end ; pom := GetBase ( depot ) ;
112045: LD_ADDR_VAR 0 4
112049: PUSH
112050: LD_VAR 0 1
112054: PPUSH
112055: CALL_OW 274
112059: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
112060: LD_ADDR_VAR 0 5
112064: PUSH
112065: LD_VAR 0 2
112069: PPUSH
112070: LD_VAR 0 1
112074: PPUSH
112075: CALL_OW 248
112079: PPUSH
112080: CALL_OW 450
112084: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
112085: LD_ADDR_VAR 0 3
112089: PUSH
112090: LD_VAR 0 4
112094: PPUSH
112095: LD_INT 1
112097: PPUSH
112098: CALL_OW 275
112102: PUSH
112103: LD_VAR 0 5
112107: PUSH
112108: LD_INT 1
112110: ARRAY
112111: GREATEREQUAL
112112: PUSH
112113: LD_VAR 0 4
112117: PPUSH
112118: LD_INT 2
112120: PPUSH
112121: CALL_OW 275
112125: PUSH
112126: LD_VAR 0 5
112130: PUSH
112131: LD_INT 2
112133: ARRAY
112134: GREATEREQUAL
112135: AND
112136: PUSH
112137: LD_VAR 0 4
112141: PPUSH
112142: LD_INT 3
112144: PPUSH
112145: CALL_OW 275
112149: PUSH
112150: LD_VAR 0 5
112154: PUSH
112155: LD_INT 3
112157: ARRAY
112158: GREATEREQUAL
112159: AND
112160: ST_TO_ADDR
// end ;
112161: LD_VAR 0 3
112165: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
112166: LD_INT 0
112168: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
112169: LD_VAR 0 1
112173: PPUSH
112174: LD_VAR 0 2
112178: PPUSH
112179: LD_INT 0
112181: PPUSH
112182: LD_INT 0
112184: PPUSH
112185: LD_INT 1
112187: PPUSH
112188: LD_INT 0
112190: PPUSH
112191: CALL_OW 587
// end ;
112195: LD_VAR 0 3
112199: RET
// export function CenterOnNow ( unit ) ; begin
112200: LD_INT 0
112202: PPUSH
// result := IsInUnit ( unit ) ;
112203: LD_ADDR_VAR 0 2
112207: PUSH
112208: LD_VAR 0 1
112212: PPUSH
112213: CALL_OW 310
112217: ST_TO_ADDR
// if not result then
112218: LD_VAR 0 2
112222: NOT
112223: IFFALSE 112235
// result := unit ;
112225: LD_ADDR_VAR 0 2
112229: PUSH
112230: LD_VAR 0 1
112234: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
112235: LD_VAR 0 1
112239: PPUSH
112240: CALL_OW 87
// end ;
112244: LD_VAR 0 2
112248: RET
// export function ComMoveHex ( unit , hex ) ; begin
112249: LD_INT 0
112251: PPUSH
// if not hex then
112252: LD_VAR 0 2
112256: NOT
112257: IFFALSE 112261
// exit ;
112259: GO 112314
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
112261: LD_VAR 0 2
112265: PUSH
112266: LD_INT 1
112268: ARRAY
112269: PPUSH
112270: LD_VAR 0 2
112274: PUSH
112275: LD_INT 2
112277: ARRAY
112278: PPUSH
112279: CALL_OW 428
112283: IFFALSE 112287
// exit ;
112285: GO 112314
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
112287: LD_VAR 0 1
112291: PPUSH
112292: LD_VAR 0 2
112296: PUSH
112297: LD_INT 1
112299: ARRAY
112300: PPUSH
112301: LD_VAR 0 2
112305: PUSH
112306: LD_INT 2
112308: ARRAY
112309: PPUSH
112310: CALL_OW 111
// end ;
112314: LD_VAR 0 3
112318: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
112319: LD_INT 0
112321: PPUSH
112322: PPUSH
112323: PPUSH
// if not unit or not enemy then
112324: LD_VAR 0 1
112328: NOT
112329: PUSH
112330: LD_VAR 0 2
112334: NOT
112335: OR
112336: IFFALSE 112340
// exit ;
112338: GO 112464
// x := GetX ( enemy ) ;
112340: LD_ADDR_VAR 0 4
112344: PUSH
112345: LD_VAR 0 2
112349: PPUSH
112350: CALL_OW 250
112354: ST_TO_ADDR
// y := GetY ( enemy ) ;
112355: LD_ADDR_VAR 0 5
112359: PUSH
112360: LD_VAR 0 2
112364: PPUSH
112365: CALL_OW 251
112369: ST_TO_ADDR
// if ValidHex ( x , y ) then
112370: LD_VAR 0 4
112374: PPUSH
112375: LD_VAR 0 5
112379: PPUSH
112380: CALL_OW 488
112384: IFFALSE 112464
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
112386: LD_VAR 0 2
112390: PPUSH
112391: CALL_OW 247
112395: PUSH
112396: LD_INT 3
112398: PUSH
112399: LD_INT 2
112401: PUSH
112402: EMPTY
112403: LIST
112404: LIST
112405: IN
112406: PUSH
112407: LD_VAR 0 1
112411: PPUSH
112412: CALL_OW 255
112416: PPUSH
112417: LD_VAR 0 2
112421: PPUSH
112422: CALL_OW 292
112426: OR
112427: IFFALSE 112445
// ComAttackUnit ( unit , enemy ) else
112429: LD_VAR 0 1
112433: PPUSH
112434: LD_VAR 0 2
112438: PPUSH
112439: CALL_OW 115
112443: GO 112464
// ComAgressiveMove ( unit , x , y ) ;
112445: LD_VAR 0 1
112449: PPUSH
112450: LD_VAR 0 4
112454: PPUSH
112455: LD_VAR 0 5
112459: PPUSH
112460: CALL_OW 114
// end ;
112464: LD_VAR 0 3
112468: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
112469: LD_INT 0
112471: PPUSH
112472: PPUSH
112473: PPUSH
// list := AreaToList ( area , 0 ) ;
112474: LD_ADDR_VAR 0 5
112478: PUSH
112479: LD_VAR 0 1
112483: PPUSH
112484: LD_INT 0
112486: PPUSH
112487: CALL_OW 517
112491: ST_TO_ADDR
// if not list then
112492: LD_VAR 0 5
112496: NOT
112497: IFFALSE 112501
// exit ;
112499: GO 112631
// if all then
112501: LD_VAR 0 2
112505: IFFALSE 112593
// begin for i := 1 to list [ 1 ] do
112507: LD_ADDR_VAR 0 4
112511: PUSH
112512: DOUBLE
112513: LD_INT 1
112515: DEC
112516: ST_TO_ADDR
112517: LD_VAR 0 5
112521: PUSH
112522: LD_INT 1
112524: ARRAY
112525: PUSH
112526: FOR_TO
112527: IFFALSE 112589
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
112529: LD_ADDR_VAR 0 3
112533: PUSH
112534: LD_VAR 0 3
112538: PPUSH
112539: LD_VAR 0 3
112543: PUSH
112544: LD_INT 1
112546: PLUS
112547: PPUSH
112548: LD_VAR 0 5
112552: PUSH
112553: LD_INT 1
112555: ARRAY
112556: PUSH
112557: LD_VAR 0 4
112561: ARRAY
112562: PUSH
112563: LD_VAR 0 5
112567: PUSH
112568: LD_INT 2
112570: ARRAY
112571: PUSH
112572: LD_VAR 0 4
112576: ARRAY
112577: PUSH
112578: EMPTY
112579: LIST
112580: LIST
112581: PPUSH
112582: CALL_OW 1
112586: ST_TO_ADDR
112587: GO 112526
112589: POP
112590: POP
// exit ;
112591: GO 112631
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
112593: LD_ADDR_VAR 0 3
112597: PUSH
112598: LD_VAR 0 5
112602: PUSH
112603: LD_INT 1
112605: ARRAY
112606: PUSH
112607: LD_INT 1
112609: ARRAY
112610: PUSH
112611: LD_VAR 0 5
112615: PUSH
112616: LD_INT 2
112618: ARRAY
112619: PUSH
112620: LD_INT 1
112622: ARRAY
112623: PUSH
112624: EMPTY
112625: LIST
112626: LIST
112627: PUSH
112628: EMPTY
112629: LIST
112630: ST_TO_ADDR
// end ;
112631: LD_VAR 0 3
112635: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
112636: LD_INT 0
112638: PPUSH
112639: PPUSH
// list := AreaToList ( area , 0 ) ;
112640: LD_ADDR_VAR 0 4
112644: PUSH
112645: LD_VAR 0 1
112649: PPUSH
112650: LD_INT 0
112652: PPUSH
112653: CALL_OW 517
112657: ST_TO_ADDR
// if not list then
112658: LD_VAR 0 4
112662: NOT
112663: IFFALSE 112667
// exit ;
112665: GO 112708
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
112667: LD_ADDR_VAR 0 3
112671: PUSH
112672: LD_VAR 0 4
112676: PUSH
112677: LD_INT 1
112679: ARRAY
112680: PUSH
112681: LD_INT 1
112683: ARRAY
112684: PUSH
112685: LD_VAR 0 4
112689: PUSH
112690: LD_INT 2
112692: ARRAY
112693: PUSH
112694: LD_INT 1
112696: ARRAY
112697: PUSH
112698: LD_VAR 0 2
112702: PUSH
112703: EMPTY
112704: LIST
112705: LIST
112706: LIST
112707: ST_TO_ADDR
// end ;
112708: LD_VAR 0 3
112712: RET
// export function First ( array ) ; begin
112713: LD_INT 0
112715: PPUSH
// if not array then
112716: LD_VAR 0 1
112720: NOT
112721: IFFALSE 112725
// exit ;
112723: GO 112739
// result := array [ 1 ] ;
112725: LD_ADDR_VAR 0 2
112729: PUSH
112730: LD_VAR 0 1
112734: PUSH
112735: LD_INT 1
112737: ARRAY
112738: ST_TO_ADDR
// end ;
112739: LD_VAR 0 2
112743: RET
// export function Last ( array ) ; begin
112744: LD_INT 0
112746: PPUSH
// if not array then
112747: LD_VAR 0 1
112751: NOT
112752: IFFALSE 112756
// exit ;
112754: GO 112772
// result := array [ array ] ;
112756: LD_ADDR_VAR 0 2
112760: PUSH
112761: LD_VAR 0 1
112765: PUSH
112766: LD_VAR 0 1
112770: ARRAY
112771: ST_TO_ADDR
// end ;
112772: LD_VAR 0 2
112776: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
112777: LD_INT 0
112779: PPUSH
112780: PPUSH
// result := [ ] ;
112781: LD_ADDR_VAR 0 5
112785: PUSH
112786: EMPTY
112787: ST_TO_ADDR
// if not array then
112788: LD_VAR 0 1
112792: NOT
112793: IFFALSE 112797
// exit ;
112795: GO 112909
// for i := 1 to array do
112797: LD_ADDR_VAR 0 6
112801: PUSH
112802: DOUBLE
112803: LD_INT 1
112805: DEC
112806: ST_TO_ADDR
112807: LD_VAR 0 1
112811: PUSH
112812: FOR_TO
112813: IFFALSE 112907
// if array [ i ] [ index ] = value then
112815: LD_VAR 0 1
112819: PUSH
112820: LD_VAR 0 6
112824: ARRAY
112825: PUSH
112826: LD_VAR 0 2
112830: ARRAY
112831: PUSH
112832: LD_VAR 0 3
112836: EQUAL
112837: IFFALSE 112905
// begin if indexColumn then
112839: LD_VAR 0 4
112843: IFFALSE 112879
// result := Join ( result , array [ i ] [ indexColumn ] ) else
112845: LD_ADDR_VAR 0 5
112849: PUSH
112850: LD_VAR 0 5
112854: PPUSH
112855: LD_VAR 0 1
112859: PUSH
112860: LD_VAR 0 6
112864: ARRAY
112865: PUSH
112866: LD_VAR 0 4
112870: ARRAY
112871: PPUSH
112872: CALL 108091 0 2
112876: ST_TO_ADDR
112877: GO 112905
// result := Join ( result , array [ i ] ) ;
112879: LD_ADDR_VAR 0 5
112883: PUSH
112884: LD_VAR 0 5
112888: PPUSH
112889: LD_VAR 0 1
112893: PUSH
112894: LD_VAR 0 6
112898: ARRAY
112899: PPUSH
112900: CALL 108091 0 2
112904: ST_TO_ADDR
// end ;
112905: GO 112812
112907: POP
112908: POP
// end ;
112909: LD_VAR 0 5
112913: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
112914: LD_INT 0
112916: PPUSH
// if not vehicles or not parkingPoint then
112917: LD_VAR 0 1
112921: NOT
112922: PUSH
112923: LD_VAR 0 2
112927: NOT
112928: OR
112929: IFFALSE 112933
// exit ;
112931: GO 113031
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
112933: LD_ADDR_VAR 0 1
112937: PUSH
112938: LD_VAR 0 1
112942: PPUSH
112943: LD_INT 50
112945: PUSH
112946: EMPTY
112947: LIST
112948: PUSH
112949: LD_INT 3
112951: PUSH
112952: LD_INT 92
112954: PUSH
112955: LD_VAR 0 2
112959: PUSH
112960: LD_INT 1
112962: ARRAY
112963: PUSH
112964: LD_VAR 0 2
112968: PUSH
112969: LD_INT 2
112971: ARRAY
112972: PUSH
112973: LD_INT 8
112975: PUSH
112976: EMPTY
112977: LIST
112978: LIST
112979: LIST
112980: LIST
112981: PUSH
112982: EMPTY
112983: LIST
112984: LIST
112985: PUSH
112986: EMPTY
112987: LIST
112988: LIST
112989: PPUSH
112990: CALL_OW 72
112994: ST_TO_ADDR
// if not vehicles then
112995: LD_VAR 0 1
112999: NOT
113000: IFFALSE 113004
// exit ;
113002: GO 113031
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
113004: LD_VAR 0 1
113008: PPUSH
113009: LD_VAR 0 2
113013: PUSH
113014: LD_INT 1
113016: ARRAY
113017: PPUSH
113018: LD_VAR 0 2
113022: PUSH
113023: LD_INT 2
113025: ARRAY
113026: PPUSH
113027: CALL_OW 111
// end ;
113031: LD_VAR 0 3
113035: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
113036: LD_INT 0
113038: PPUSH
113039: PPUSH
113040: PPUSH
// if not side or not area then
113041: LD_VAR 0 1
113045: NOT
113046: PUSH
113047: LD_VAR 0 2
113051: NOT
113052: OR
113053: IFFALSE 113057
// exit ;
113055: GO 113176
// tmp := AreaToList ( area , 0 ) ;
113057: LD_ADDR_VAR 0 5
113061: PUSH
113062: LD_VAR 0 2
113066: PPUSH
113067: LD_INT 0
113069: PPUSH
113070: CALL_OW 517
113074: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
113075: LD_ADDR_VAR 0 4
113079: PUSH
113080: DOUBLE
113081: LD_INT 1
113083: DEC
113084: ST_TO_ADDR
113085: LD_VAR 0 5
113089: PUSH
113090: LD_INT 1
113092: ARRAY
113093: PUSH
113094: FOR_TO
113095: IFFALSE 113174
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
113097: LD_VAR 0 5
113101: PUSH
113102: LD_INT 1
113104: ARRAY
113105: PUSH
113106: LD_VAR 0 4
113110: ARRAY
113111: PPUSH
113112: LD_VAR 0 5
113116: PUSH
113117: LD_INT 2
113119: ARRAY
113120: PUSH
113121: LD_VAR 0 4
113125: ARRAY
113126: PPUSH
113127: CALL_OW 351
113131: IFFALSE 113172
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
113133: LD_VAR 0 5
113137: PUSH
113138: LD_INT 1
113140: ARRAY
113141: PUSH
113142: LD_VAR 0 4
113146: ARRAY
113147: PPUSH
113148: LD_VAR 0 5
113152: PUSH
113153: LD_INT 2
113155: ARRAY
113156: PUSH
113157: LD_VAR 0 4
113161: ARRAY
113162: PPUSH
113163: LD_VAR 0 1
113167: PPUSH
113168: CALL_OW 244
// end ;
113172: GO 113094
113174: POP
113175: POP
// end ; end_of_file end_of_file
113176: LD_VAR 0 3
113180: RET
// export globalGameSaveCounter ; every 0 0$1 do
113181: GO 113183
113183: DISABLE
// begin enable ;
113184: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
113185: LD_STRING updateTimer(
113187: PUSH
113188: LD_OWVAR 1
113192: STR
113193: PUSH
113194: LD_STRING );
113196: STR
113197: PPUSH
113198: CALL_OW 559
// end ;
113202: END
// every 0 0$1 do
113203: GO 113205
113205: DISABLE
// begin globalGameSaveCounter := 0 ;
113206: LD_ADDR_EXP 147
113210: PUSH
113211: LD_INT 0
113213: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
113214: LD_STRING setGameSaveCounter(0)
113216: PPUSH
113217: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
113221: LD_STRING initStreamRollete();
113223: PPUSH
113224: CALL_OW 559
// InitStreamMode ;
113228: CALL 114571 0 0
// DefineStreamItems ( false ) ;
113232: LD_INT 0
113234: PPUSH
113235: CALL 115035 0 1
// end ;
113239: END
// export function SOS_MapStart ( ) ; begin
113240: LD_INT 0
113242: PPUSH
// if streamModeActive then
113243: LD_EXP 148
113247: IFFALSE 113256
// DefineStreamItems ( true ) ;
113249: LD_INT 1
113251: PPUSH
113252: CALL 115035 0 1
// UpdateLuaVariables ( ) ;
113256: CALL 113273 0 0
// UpdateFactoryWaypoints ( ) ;
113260: CALL 128037 0 0
// UpdateWarehouseGatheringPoints ( ) ;
113264: CALL 128289 0 0
// end ;
113268: LD_VAR 0 1
113272: RET
// function UpdateLuaVariables ( ) ; begin
113273: LD_INT 0
113275: PPUSH
// if globalGameSaveCounter then
113276: LD_EXP 147
113280: IFFALSE 113314
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
113282: LD_ADDR_EXP 147
113286: PUSH
113287: LD_EXP 147
113291: PPUSH
113292: CALL 109452 0 1
113296: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
113297: LD_STRING setGameSaveCounter(
113299: PUSH
113300: LD_EXP 147
113304: STR
113305: PUSH
113306: LD_STRING )
113308: STR
113309: PPUSH
113310: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
113314: LD_STRING setGameDifficulty(
113316: PUSH
113317: LD_OWVAR 67
113321: STR
113322: PUSH
113323: LD_STRING )
113325: STR
113326: PPUSH
113327: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
113331: LD_STRING displayDifficulty(
113333: PUSH
113334: LD_OWVAR 67
113338: STR
113339: PUSH
113340: LD_STRING )
113342: STR
113343: PPUSH
113344: CALL_OW 559
// end ;
113348: LD_VAR 0 1
113352: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
113353: LD_INT 0
113355: PPUSH
// if p2 = stream_mode then
113356: LD_VAR 0 2
113360: PUSH
113361: LD_INT 100
113363: EQUAL
113364: IFFALSE 114367
// begin if not StreamModeActive then
113366: LD_EXP 148
113370: NOT
113371: IFFALSE 113381
// StreamModeActive := true ;
113373: LD_ADDR_EXP 148
113377: PUSH
113378: LD_INT 1
113380: ST_TO_ADDR
// if p3 = 0 then
113381: LD_VAR 0 3
113385: PUSH
113386: LD_INT 0
113388: EQUAL
113389: IFFALSE 113395
// InitStreamMode ;
113391: CALL 114571 0 0
// if p3 = 1 then
113395: LD_VAR 0 3
113399: PUSH
113400: LD_INT 1
113402: EQUAL
113403: IFFALSE 113413
// sRocket := true ;
113405: LD_ADDR_EXP 153
113409: PUSH
113410: LD_INT 1
113412: ST_TO_ADDR
// if p3 = 2 then
113413: LD_VAR 0 3
113417: PUSH
113418: LD_INT 2
113420: EQUAL
113421: IFFALSE 113431
// sSpeed := true ;
113423: LD_ADDR_EXP 152
113427: PUSH
113428: LD_INT 1
113430: ST_TO_ADDR
// if p3 = 3 then
113431: LD_VAR 0 3
113435: PUSH
113436: LD_INT 3
113438: EQUAL
113439: IFFALSE 113449
// sEngine := true ;
113441: LD_ADDR_EXP 154
113445: PUSH
113446: LD_INT 1
113448: ST_TO_ADDR
// if p3 = 4 then
113449: LD_VAR 0 3
113453: PUSH
113454: LD_INT 4
113456: EQUAL
113457: IFFALSE 113467
// sSpec := true ;
113459: LD_ADDR_EXP 151
113463: PUSH
113464: LD_INT 1
113466: ST_TO_ADDR
// if p3 = 5 then
113467: LD_VAR 0 3
113471: PUSH
113472: LD_INT 5
113474: EQUAL
113475: IFFALSE 113485
// sLevel := true ;
113477: LD_ADDR_EXP 155
113481: PUSH
113482: LD_INT 1
113484: ST_TO_ADDR
// if p3 = 6 then
113485: LD_VAR 0 3
113489: PUSH
113490: LD_INT 6
113492: EQUAL
113493: IFFALSE 113503
// sArmoury := true ;
113495: LD_ADDR_EXP 156
113499: PUSH
113500: LD_INT 1
113502: ST_TO_ADDR
// if p3 = 7 then
113503: LD_VAR 0 3
113507: PUSH
113508: LD_INT 7
113510: EQUAL
113511: IFFALSE 113521
// sRadar := true ;
113513: LD_ADDR_EXP 157
113517: PUSH
113518: LD_INT 1
113520: ST_TO_ADDR
// if p3 = 8 then
113521: LD_VAR 0 3
113525: PUSH
113526: LD_INT 8
113528: EQUAL
113529: IFFALSE 113539
// sBunker := true ;
113531: LD_ADDR_EXP 158
113535: PUSH
113536: LD_INT 1
113538: ST_TO_ADDR
// if p3 = 9 then
113539: LD_VAR 0 3
113543: PUSH
113544: LD_INT 9
113546: EQUAL
113547: IFFALSE 113557
// sHack := true ;
113549: LD_ADDR_EXP 159
113553: PUSH
113554: LD_INT 1
113556: ST_TO_ADDR
// if p3 = 10 then
113557: LD_VAR 0 3
113561: PUSH
113562: LD_INT 10
113564: EQUAL
113565: IFFALSE 113575
// sFire := true ;
113567: LD_ADDR_EXP 160
113571: PUSH
113572: LD_INT 1
113574: ST_TO_ADDR
// if p3 = 11 then
113575: LD_VAR 0 3
113579: PUSH
113580: LD_INT 11
113582: EQUAL
113583: IFFALSE 113593
// sRefresh := true ;
113585: LD_ADDR_EXP 161
113589: PUSH
113590: LD_INT 1
113592: ST_TO_ADDR
// if p3 = 12 then
113593: LD_VAR 0 3
113597: PUSH
113598: LD_INT 12
113600: EQUAL
113601: IFFALSE 113611
// sExp := true ;
113603: LD_ADDR_EXP 162
113607: PUSH
113608: LD_INT 1
113610: ST_TO_ADDR
// if p3 = 13 then
113611: LD_VAR 0 3
113615: PUSH
113616: LD_INT 13
113618: EQUAL
113619: IFFALSE 113629
// sDepot := true ;
113621: LD_ADDR_EXP 163
113625: PUSH
113626: LD_INT 1
113628: ST_TO_ADDR
// if p3 = 14 then
113629: LD_VAR 0 3
113633: PUSH
113634: LD_INT 14
113636: EQUAL
113637: IFFALSE 113647
// sFlag := true ;
113639: LD_ADDR_EXP 164
113643: PUSH
113644: LD_INT 1
113646: ST_TO_ADDR
// if p3 = 15 then
113647: LD_VAR 0 3
113651: PUSH
113652: LD_INT 15
113654: EQUAL
113655: IFFALSE 113665
// sKamikadze := true ;
113657: LD_ADDR_EXP 172
113661: PUSH
113662: LD_INT 1
113664: ST_TO_ADDR
// if p3 = 16 then
113665: LD_VAR 0 3
113669: PUSH
113670: LD_INT 16
113672: EQUAL
113673: IFFALSE 113683
// sTroll := true ;
113675: LD_ADDR_EXP 173
113679: PUSH
113680: LD_INT 1
113682: ST_TO_ADDR
// if p3 = 17 then
113683: LD_VAR 0 3
113687: PUSH
113688: LD_INT 17
113690: EQUAL
113691: IFFALSE 113701
// sSlow := true ;
113693: LD_ADDR_EXP 174
113697: PUSH
113698: LD_INT 1
113700: ST_TO_ADDR
// if p3 = 18 then
113701: LD_VAR 0 3
113705: PUSH
113706: LD_INT 18
113708: EQUAL
113709: IFFALSE 113719
// sLack := true ;
113711: LD_ADDR_EXP 175
113715: PUSH
113716: LD_INT 1
113718: ST_TO_ADDR
// if p3 = 19 then
113719: LD_VAR 0 3
113723: PUSH
113724: LD_INT 19
113726: EQUAL
113727: IFFALSE 113737
// sTank := true ;
113729: LD_ADDR_EXP 177
113733: PUSH
113734: LD_INT 1
113736: ST_TO_ADDR
// if p3 = 20 then
113737: LD_VAR 0 3
113741: PUSH
113742: LD_INT 20
113744: EQUAL
113745: IFFALSE 113755
// sRemote := true ;
113747: LD_ADDR_EXP 178
113751: PUSH
113752: LD_INT 1
113754: ST_TO_ADDR
// if p3 = 21 then
113755: LD_VAR 0 3
113759: PUSH
113760: LD_INT 21
113762: EQUAL
113763: IFFALSE 113773
// sPowell := true ;
113765: LD_ADDR_EXP 179
113769: PUSH
113770: LD_INT 1
113772: ST_TO_ADDR
// if p3 = 22 then
113773: LD_VAR 0 3
113777: PUSH
113778: LD_INT 22
113780: EQUAL
113781: IFFALSE 113791
// sTeleport := true ;
113783: LD_ADDR_EXP 182
113787: PUSH
113788: LD_INT 1
113790: ST_TO_ADDR
// if p3 = 23 then
113791: LD_VAR 0 3
113795: PUSH
113796: LD_INT 23
113798: EQUAL
113799: IFFALSE 113809
// sOilTower := true ;
113801: LD_ADDR_EXP 184
113805: PUSH
113806: LD_INT 1
113808: ST_TO_ADDR
// if p3 = 24 then
113809: LD_VAR 0 3
113813: PUSH
113814: LD_INT 24
113816: EQUAL
113817: IFFALSE 113827
// sShovel := true ;
113819: LD_ADDR_EXP 185
113823: PUSH
113824: LD_INT 1
113826: ST_TO_ADDR
// if p3 = 25 then
113827: LD_VAR 0 3
113831: PUSH
113832: LD_INT 25
113834: EQUAL
113835: IFFALSE 113845
// sSheik := true ;
113837: LD_ADDR_EXP 186
113841: PUSH
113842: LD_INT 1
113844: ST_TO_ADDR
// if p3 = 26 then
113845: LD_VAR 0 3
113849: PUSH
113850: LD_INT 26
113852: EQUAL
113853: IFFALSE 113863
// sEarthquake := true ;
113855: LD_ADDR_EXP 188
113859: PUSH
113860: LD_INT 1
113862: ST_TO_ADDR
// if p3 = 27 then
113863: LD_VAR 0 3
113867: PUSH
113868: LD_INT 27
113870: EQUAL
113871: IFFALSE 113881
// sAI := true ;
113873: LD_ADDR_EXP 189
113877: PUSH
113878: LD_INT 1
113880: ST_TO_ADDR
// if p3 = 28 then
113881: LD_VAR 0 3
113885: PUSH
113886: LD_INT 28
113888: EQUAL
113889: IFFALSE 113899
// sCargo := true ;
113891: LD_ADDR_EXP 192
113895: PUSH
113896: LD_INT 1
113898: ST_TO_ADDR
// if p3 = 29 then
113899: LD_VAR 0 3
113903: PUSH
113904: LD_INT 29
113906: EQUAL
113907: IFFALSE 113917
// sDLaser := true ;
113909: LD_ADDR_EXP 193
113913: PUSH
113914: LD_INT 1
113916: ST_TO_ADDR
// if p3 = 30 then
113917: LD_VAR 0 3
113921: PUSH
113922: LD_INT 30
113924: EQUAL
113925: IFFALSE 113935
// sExchange := true ;
113927: LD_ADDR_EXP 194
113931: PUSH
113932: LD_INT 1
113934: ST_TO_ADDR
// if p3 = 31 then
113935: LD_VAR 0 3
113939: PUSH
113940: LD_INT 31
113942: EQUAL
113943: IFFALSE 113953
// sFac := true ;
113945: LD_ADDR_EXP 195
113949: PUSH
113950: LD_INT 1
113952: ST_TO_ADDR
// if p3 = 32 then
113953: LD_VAR 0 3
113957: PUSH
113958: LD_INT 32
113960: EQUAL
113961: IFFALSE 113971
// sPower := true ;
113963: LD_ADDR_EXP 196
113967: PUSH
113968: LD_INT 1
113970: ST_TO_ADDR
// if p3 = 33 then
113971: LD_VAR 0 3
113975: PUSH
113976: LD_INT 33
113978: EQUAL
113979: IFFALSE 113989
// sRandom := true ;
113981: LD_ADDR_EXP 197
113985: PUSH
113986: LD_INT 1
113988: ST_TO_ADDR
// if p3 = 34 then
113989: LD_VAR 0 3
113993: PUSH
113994: LD_INT 34
113996: EQUAL
113997: IFFALSE 114007
// sShield := true ;
113999: LD_ADDR_EXP 198
114003: PUSH
114004: LD_INT 1
114006: ST_TO_ADDR
// if p3 = 35 then
114007: LD_VAR 0 3
114011: PUSH
114012: LD_INT 35
114014: EQUAL
114015: IFFALSE 114025
// sTime := true ;
114017: LD_ADDR_EXP 199
114021: PUSH
114022: LD_INT 1
114024: ST_TO_ADDR
// if p3 = 36 then
114025: LD_VAR 0 3
114029: PUSH
114030: LD_INT 36
114032: EQUAL
114033: IFFALSE 114043
// sTools := true ;
114035: LD_ADDR_EXP 200
114039: PUSH
114040: LD_INT 1
114042: ST_TO_ADDR
// if p3 = 101 then
114043: LD_VAR 0 3
114047: PUSH
114048: LD_INT 101
114050: EQUAL
114051: IFFALSE 114061
// sSold := true ;
114053: LD_ADDR_EXP 165
114057: PUSH
114058: LD_INT 1
114060: ST_TO_ADDR
// if p3 = 102 then
114061: LD_VAR 0 3
114065: PUSH
114066: LD_INT 102
114068: EQUAL
114069: IFFALSE 114079
// sDiff := true ;
114071: LD_ADDR_EXP 166
114075: PUSH
114076: LD_INT 1
114078: ST_TO_ADDR
// if p3 = 103 then
114079: LD_VAR 0 3
114083: PUSH
114084: LD_INT 103
114086: EQUAL
114087: IFFALSE 114097
// sFog := true ;
114089: LD_ADDR_EXP 169
114093: PUSH
114094: LD_INT 1
114096: ST_TO_ADDR
// if p3 = 104 then
114097: LD_VAR 0 3
114101: PUSH
114102: LD_INT 104
114104: EQUAL
114105: IFFALSE 114115
// sReset := true ;
114107: LD_ADDR_EXP 170
114111: PUSH
114112: LD_INT 1
114114: ST_TO_ADDR
// if p3 = 105 then
114115: LD_VAR 0 3
114119: PUSH
114120: LD_INT 105
114122: EQUAL
114123: IFFALSE 114133
// sSun := true ;
114125: LD_ADDR_EXP 171
114129: PUSH
114130: LD_INT 1
114132: ST_TO_ADDR
// if p3 = 106 then
114133: LD_VAR 0 3
114137: PUSH
114138: LD_INT 106
114140: EQUAL
114141: IFFALSE 114151
// sTiger := true ;
114143: LD_ADDR_EXP 167
114147: PUSH
114148: LD_INT 1
114150: ST_TO_ADDR
// if p3 = 107 then
114151: LD_VAR 0 3
114155: PUSH
114156: LD_INT 107
114158: EQUAL
114159: IFFALSE 114169
// sBomb := true ;
114161: LD_ADDR_EXP 168
114165: PUSH
114166: LD_INT 1
114168: ST_TO_ADDR
// if p3 = 108 then
114169: LD_VAR 0 3
114173: PUSH
114174: LD_INT 108
114176: EQUAL
114177: IFFALSE 114187
// sWound := true ;
114179: LD_ADDR_EXP 176
114183: PUSH
114184: LD_INT 1
114186: ST_TO_ADDR
// if p3 = 109 then
114187: LD_VAR 0 3
114191: PUSH
114192: LD_INT 109
114194: EQUAL
114195: IFFALSE 114205
// sBetray := true ;
114197: LD_ADDR_EXP 180
114201: PUSH
114202: LD_INT 1
114204: ST_TO_ADDR
// if p3 = 110 then
114205: LD_VAR 0 3
114209: PUSH
114210: LD_INT 110
114212: EQUAL
114213: IFFALSE 114223
// sContamin := true ;
114215: LD_ADDR_EXP 181
114219: PUSH
114220: LD_INT 1
114222: ST_TO_ADDR
// if p3 = 111 then
114223: LD_VAR 0 3
114227: PUSH
114228: LD_INT 111
114230: EQUAL
114231: IFFALSE 114241
// sOil := true ;
114233: LD_ADDR_EXP 183
114237: PUSH
114238: LD_INT 1
114240: ST_TO_ADDR
// if p3 = 112 then
114241: LD_VAR 0 3
114245: PUSH
114246: LD_INT 112
114248: EQUAL
114249: IFFALSE 114259
// sStu := true ;
114251: LD_ADDR_EXP 187
114255: PUSH
114256: LD_INT 1
114258: ST_TO_ADDR
// if p3 = 113 then
114259: LD_VAR 0 3
114263: PUSH
114264: LD_INT 113
114266: EQUAL
114267: IFFALSE 114277
// sBazooka := true ;
114269: LD_ADDR_EXP 190
114273: PUSH
114274: LD_INT 1
114276: ST_TO_ADDR
// if p3 = 114 then
114277: LD_VAR 0 3
114281: PUSH
114282: LD_INT 114
114284: EQUAL
114285: IFFALSE 114295
// sMortar := true ;
114287: LD_ADDR_EXP 191
114291: PUSH
114292: LD_INT 1
114294: ST_TO_ADDR
// if p3 = 115 then
114295: LD_VAR 0 3
114299: PUSH
114300: LD_INT 115
114302: EQUAL
114303: IFFALSE 114313
// sRanger := true ;
114305: LD_ADDR_EXP 201
114309: PUSH
114310: LD_INT 1
114312: ST_TO_ADDR
// if p3 = 116 then
114313: LD_VAR 0 3
114317: PUSH
114318: LD_INT 116
114320: EQUAL
114321: IFFALSE 114331
// sComputer := true ;
114323: LD_ADDR_EXP 202
114327: PUSH
114328: LD_INT 1
114330: ST_TO_ADDR
// if p3 = 117 then
114331: LD_VAR 0 3
114335: PUSH
114336: LD_INT 117
114338: EQUAL
114339: IFFALSE 114349
// s30 := true ;
114341: LD_ADDR_EXP 203
114345: PUSH
114346: LD_INT 1
114348: ST_TO_ADDR
// if p3 = 118 then
114349: LD_VAR 0 3
114353: PUSH
114354: LD_INT 118
114356: EQUAL
114357: IFFALSE 114367
// s60 := true ;
114359: LD_ADDR_EXP 204
114363: PUSH
114364: LD_INT 1
114366: ST_TO_ADDR
// end ; if p2 = hack_mode then
114367: LD_VAR 0 2
114371: PUSH
114372: LD_INT 101
114374: EQUAL
114375: IFFALSE 114503
// begin case p3 of 1 :
114377: LD_VAR 0 3
114381: PUSH
114382: LD_INT 1
114384: DOUBLE
114385: EQUAL
114386: IFTRUE 114390
114388: GO 114397
114390: POP
// hHackUnlimitedResources ; 2 :
114391: CALL 126650 0 0
114395: GO 114503
114397: LD_INT 2
114399: DOUBLE
114400: EQUAL
114401: IFTRUE 114405
114403: GO 114412
114405: POP
// hHackSetLevel10 ; 3 :
114406: CALL 126783 0 0
114410: GO 114503
114412: LD_INT 3
114414: DOUBLE
114415: EQUAL
114416: IFTRUE 114420
114418: GO 114427
114420: POP
// hHackSetLevel10YourUnits ; 4 :
114421: CALL 126868 0 0
114425: GO 114503
114427: LD_INT 4
114429: DOUBLE
114430: EQUAL
114431: IFTRUE 114435
114433: GO 114442
114435: POP
// hHackInvincible ; 5 :
114436: CALL 127316 0 0
114440: GO 114503
114442: LD_INT 5
114444: DOUBLE
114445: EQUAL
114446: IFTRUE 114450
114448: GO 114457
114450: POP
// hHackInvisible ; 6 :
114451: CALL 127427 0 0
114455: GO 114503
114457: LD_INT 6
114459: DOUBLE
114460: EQUAL
114461: IFTRUE 114465
114463: GO 114472
114465: POP
// hHackChangeYourSide ; 7 :
114466: CALL 127484 0 0
114470: GO 114503
114472: LD_INT 7
114474: DOUBLE
114475: EQUAL
114476: IFTRUE 114480
114478: GO 114487
114480: POP
// hHackChangeUnitSide ; 8 :
114481: CALL 127526 0 0
114485: GO 114503
114487: LD_INT 8
114489: DOUBLE
114490: EQUAL
114491: IFTRUE 114495
114493: GO 114502
114495: POP
// hHackFog ; end ;
114496: CALL 127627 0 0
114500: GO 114503
114502: POP
// end ; if p2 = game_save_mode then
114503: LD_VAR 0 2
114507: PUSH
114508: LD_INT 102
114510: EQUAL
114511: IFFALSE 114566
// begin if p3 = 1 then
114513: LD_VAR 0 3
114517: PUSH
114518: LD_INT 1
114520: EQUAL
114521: IFFALSE 114533
// globalGameSaveCounter := p4 ;
114523: LD_ADDR_EXP 147
114527: PUSH
114528: LD_VAR 0 4
114532: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
114533: LD_VAR 0 3
114537: PUSH
114538: LD_INT 2
114540: EQUAL
114541: PUSH
114542: LD_EXP 147
114546: AND
114547: IFFALSE 114566
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
114549: LD_STRING setGameSaveCounter(
114551: PUSH
114552: LD_EXP 147
114556: STR
114557: PUSH
114558: LD_STRING )
114560: STR
114561: PPUSH
114562: CALL_OW 559
// end ; end ;
114566: LD_VAR 0 7
114570: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
114571: LD_INT 0
114573: PPUSH
// streamModeActive := false ;
114574: LD_ADDR_EXP 148
114578: PUSH
114579: LD_INT 0
114581: ST_TO_ADDR
// normalCounter := 36 ;
114582: LD_ADDR_EXP 149
114586: PUSH
114587: LD_INT 36
114589: ST_TO_ADDR
// hardcoreCounter := 18 ;
114590: LD_ADDR_EXP 150
114594: PUSH
114595: LD_INT 18
114597: ST_TO_ADDR
// sRocket := false ;
114598: LD_ADDR_EXP 153
114602: PUSH
114603: LD_INT 0
114605: ST_TO_ADDR
// sSpeed := false ;
114606: LD_ADDR_EXP 152
114610: PUSH
114611: LD_INT 0
114613: ST_TO_ADDR
// sEngine := false ;
114614: LD_ADDR_EXP 154
114618: PUSH
114619: LD_INT 0
114621: ST_TO_ADDR
// sSpec := false ;
114622: LD_ADDR_EXP 151
114626: PUSH
114627: LD_INT 0
114629: ST_TO_ADDR
// sLevel := false ;
114630: LD_ADDR_EXP 155
114634: PUSH
114635: LD_INT 0
114637: ST_TO_ADDR
// sArmoury := false ;
114638: LD_ADDR_EXP 156
114642: PUSH
114643: LD_INT 0
114645: ST_TO_ADDR
// sRadar := false ;
114646: LD_ADDR_EXP 157
114650: PUSH
114651: LD_INT 0
114653: ST_TO_ADDR
// sBunker := false ;
114654: LD_ADDR_EXP 158
114658: PUSH
114659: LD_INT 0
114661: ST_TO_ADDR
// sHack := false ;
114662: LD_ADDR_EXP 159
114666: PUSH
114667: LD_INT 0
114669: ST_TO_ADDR
// sFire := false ;
114670: LD_ADDR_EXP 160
114674: PUSH
114675: LD_INT 0
114677: ST_TO_ADDR
// sRefresh := false ;
114678: LD_ADDR_EXP 161
114682: PUSH
114683: LD_INT 0
114685: ST_TO_ADDR
// sExp := false ;
114686: LD_ADDR_EXP 162
114690: PUSH
114691: LD_INT 0
114693: ST_TO_ADDR
// sDepot := false ;
114694: LD_ADDR_EXP 163
114698: PUSH
114699: LD_INT 0
114701: ST_TO_ADDR
// sFlag := false ;
114702: LD_ADDR_EXP 164
114706: PUSH
114707: LD_INT 0
114709: ST_TO_ADDR
// sKamikadze := false ;
114710: LD_ADDR_EXP 172
114714: PUSH
114715: LD_INT 0
114717: ST_TO_ADDR
// sTroll := false ;
114718: LD_ADDR_EXP 173
114722: PUSH
114723: LD_INT 0
114725: ST_TO_ADDR
// sSlow := false ;
114726: LD_ADDR_EXP 174
114730: PUSH
114731: LD_INT 0
114733: ST_TO_ADDR
// sLack := false ;
114734: LD_ADDR_EXP 175
114738: PUSH
114739: LD_INT 0
114741: ST_TO_ADDR
// sTank := false ;
114742: LD_ADDR_EXP 177
114746: PUSH
114747: LD_INT 0
114749: ST_TO_ADDR
// sRemote := false ;
114750: LD_ADDR_EXP 178
114754: PUSH
114755: LD_INT 0
114757: ST_TO_ADDR
// sPowell := false ;
114758: LD_ADDR_EXP 179
114762: PUSH
114763: LD_INT 0
114765: ST_TO_ADDR
// sTeleport := false ;
114766: LD_ADDR_EXP 182
114770: PUSH
114771: LD_INT 0
114773: ST_TO_ADDR
// sOilTower := false ;
114774: LD_ADDR_EXP 184
114778: PUSH
114779: LD_INT 0
114781: ST_TO_ADDR
// sShovel := false ;
114782: LD_ADDR_EXP 185
114786: PUSH
114787: LD_INT 0
114789: ST_TO_ADDR
// sSheik := false ;
114790: LD_ADDR_EXP 186
114794: PUSH
114795: LD_INT 0
114797: ST_TO_ADDR
// sEarthquake := false ;
114798: LD_ADDR_EXP 188
114802: PUSH
114803: LD_INT 0
114805: ST_TO_ADDR
// sAI := false ;
114806: LD_ADDR_EXP 189
114810: PUSH
114811: LD_INT 0
114813: ST_TO_ADDR
// sCargo := false ;
114814: LD_ADDR_EXP 192
114818: PUSH
114819: LD_INT 0
114821: ST_TO_ADDR
// sDLaser := false ;
114822: LD_ADDR_EXP 193
114826: PUSH
114827: LD_INT 0
114829: ST_TO_ADDR
// sExchange := false ;
114830: LD_ADDR_EXP 194
114834: PUSH
114835: LD_INT 0
114837: ST_TO_ADDR
// sFac := false ;
114838: LD_ADDR_EXP 195
114842: PUSH
114843: LD_INT 0
114845: ST_TO_ADDR
// sPower := false ;
114846: LD_ADDR_EXP 196
114850: PUSH
114851: LD_INT 0
114853: ST_TO_ADDR
// sRandom := false ;
114854: LD_ADDR_EXP 197
114858: PUSH
114859: LD_INT 0
114861: ST_TO_ADDR
// sShield := false ;
114862: LD_ADDR_EXP 198
114866: PUSH
114867: LD_INT 0
114869: ST_TO_ADDR
// sTime := false ;
114870: LD_ADDR_EXP 199
114874: PUSH
114875: LD_INT 0
114877: ST_TO_ADDR
// sTools := false ;
114878: LD_ADDR_EXP 200
114882: PUSH
114883: LD_INT 0
114885: ST_TO_ADDR
// sSold := false ;
114886: LD_ADDR_EXP 165
114890: PUSH
114891: LD_INT 0
114893: ST_TO_ADDR
// sDiff := false ;
114894: LD_ADDR_EXP 166
114898: PUSH
114899: LD_INT 0
114901: ST_TO_ADDR
// sFog := false ;
114902: LD_ADDR_EXP 169
114906: PUSH
114907: LD_INT 0
114909: ST_TO_ADDR
// sReset := false ;
114910: LD_ADDR_EXP 170
114914: PUSH
114915: LD_INT 0
114917: ST_TO_ADDR
// sSun := false ;
114918: LD_ADDR_EXP 171
114922: PUSH
114923: LD_INT 0
114925: ST_TO_ADDR
// sTiger := false ;
114926: LD_ADDR_EXP 167
114930: PUSH
114931: LD_INT 0
114933: ST_TO_ADDR
// sBomb := false ;
114934: LD_ADDR_EXP 168
114938: PUSH
114939: LD_INT 0
114941: ST_TO_ADDR
// sWound := false ;
114942: LD_ADDR_EXP 176
114946: PUSH
114947: LD_INT 0
114949: ST_TO_ADDR
// sBetray := false ;
114950: LD_ADDR_EXP 180
114954: PUSH
114955: LD_INT 0
114957: ST_TO_ADDR
// sContamin := false ;
114958: LD_ADDR_EXP 181
114962: PUSH
114963: LD_INT 0
114965: ST_TO_ADDR
// sOil := false ;
114966: LD_ADDR_EXP 183
114970: PUSH
114971: LD_INT 0
114973: ST_TO_ADDR
// sStu := false ;
114974: LD_ADDR_EXP 187
114978: PUSH
114979: LD_INT 0
114981: ST_TO_ADDR
// sBazooka := false ;
114982: LD_ADDR_EXP 190
114986: PUSH
114987: LD_INT 0
114989: ST_TO_ADDR
// sMortar := false ;
114990: LD_ADDR_EXP 191
114994: PUSH
114995: LD_INT 0
114997: ST_TO_ADDR
// sRanger := false ;
114998: LD_ADDR_EXP 201
115002: PUSH
115003: LD_INT 0
115005: ST_TO_ADDR
// sComputer := false ;
115006: LD_ADDR_EXP 202
115010: PUSH
115011: LD_INT 0
115013: ST_TO_ADDR
// s30 := false ;
115014: LD_ADDR_EXP 203
115018: PUSH
115019: LD_INT 0
115021: ST_TO_ADDR
// s60 := false ;
115022: LD_ADDR_EXP 204
115026: PUSH
115027: LD_INT 0
115029: ST_TO_ADDR
// end ;
115030: LD_VAR 0 1
115034: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
115035: LD_INT 0
115037: PPUSH
115038: PPUSH
115039: PPUSH
115040: PPUSH
115041: PPUSH
115042: PPUSH
115043: PPUSH
// result := [ ] ;
115044: LD_ADDR_VAR 0 2
115048: PUSH
115049: EMPTY
115050: ST_TO_ADDR
// if campaign_id = 1 then
115051: LD_OWVAR 69
115055: PUSH
115056: LD_INT 1
115058: EQUAL
115059: IFFALSE 118225
// begin case mission_number of 1 :
115061: LD_OWVAR 70
115065: PUSH
115066: LD_INT 1
115068: DOUBLE
115069: EQUAL
115070: IFTRUE 115074
115072: GO 115150
115074: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
115075: LD_ADDR_VAR 0 2
115079: PUSH
115080: LD_INT 2
115082: PUSH
115083: LD_INT 4
115085: PUSH
115086: LD_INT 11
115088: PUSH
115089: LD_INT 12
115091: PUSH
115092: LD_INT 15
115094: PUSH
115095: LD_INT 16
115097: PUSH
115098: LD_INT 22
115100: PUSH
115101: LD_INT 23
115103: PUSH
115104: LD_INT 26
115106: PUSH
115107: EMPTY
115108: LIST
115109: LIST
115110: LIST
115111: LIST
115112: LIST
115113: LIST
115114: LIST
115115: LIST
115116: LIST
115117: PUSH
115118: LD_INT 101
115120: PUSH
115121: LD_INT 102
115123: PUSH
115124: LD_INT 106
115126: PUSH
115127: LD_INT 116
115129: PUSH
115130: LD_INT 117
115132: PUSH
115133: LD_INT 118
115135: PUSH
115136: EMPTY
115137: LIST
115138: LIST
115139: LIST
115140: LIST
115141: LIST
115142: LIST
115143: PUSH
115144: EMPTY
115145: LIST
115146: LIST
115147: ST_TO_ADDR
115148: GO 118223
115150: LD_INT 2
115152: DOUBLE
115153: EQUAL
115154: IFTRUE 115158
115156: GO 115242
115158: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
115159: LD_ADDR_VAR 0 2
115163: PUSH
115164: LD_INT 2
115166: PUSH
115167: LD_INT 4
115169: PUSH
115170: LD_INT 11
115172: PUSH
115173: LD_INT 12
115175: PUSH
115176: LD_INT 15
115178: PUSH
115179: LD_INT 16
115181: PUSH
115182: LD_INT 22
115184: PUSH
115185: LD_INT 23
115187: PUSH
115188: LD_INT 26
115190: PUSH
115191: EMPTY
115192: LIST
115193: LIST
115194: LIST
115195: LIST
115196: LIST
115197: LIST
115198: LIST
115199: LIST
115200: LIST
115201: PUSH
115202: LD_INT 101
115204: PUSH
115205: LD_INT 102
115207: PUSH
115208: LD_INT 105
115210: PUSH
115211: LD_INT 106
115213: PUSH
115214: LD_INT 108
115216: PUSH
115217: LD_INT 116
115219: PUSH
115220: LD_INT 117
115222: PUSH
115223: LD_INT 118
115225: PUSH
115226: EMPTY
115227: LIST
115228: LIST
115229: LIST
115230: LIST
115231: LIST
115232: LIST
115233: LIST
115234: LIST
115235: PUSH
115236: EMPTY
115237: LIST
115238: LIST
115239: ST_TO_ADDR
115240: GO 118223
115242: LD_INT 3
115244: DOUBLE
115245: EQUAL
115246: IFTRUE 115250
115248: GO 115338
115250: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
115251: LD_ADDR_VAR 0 2
115255: PUSH
115256: LD_INT 2
115258: PUSH
115259: LD_INT 4
115261: PUSH
115262: LD_INT 5
115264: PUSH
115265: LD_INT 11
115267: PUSH
115268: LD_INT 12
115270: PUSH
115271: LD_INT 15
115273: PUSH
115274: LD_INT 16
115276: PUSH
115277: LD_INT 22
115279: PUSH
115280: LD_INT 26
115282: PUSH
115283: LD_INT 36
115285: PUSH
115286: EMPTY
115287: LIST
115288: LIST
115289: LIST
115290: LIST
115291: LIST
115292: LIST
115293: LIST
115294: LIST
115295: LIST
115296: LIST
115297: PUSH
115298: LD_INT 101
115300: PUSH
115301: LD_INT 102
115303: PUSH
115304: LD_INT 105
115306: PUSH
115307: LD_INT 106
115309: PUSH
115310: LD_INT 108
115312: PUSH
115313: LD_INT 116
115315: PUSH
115316: LD_INT 117
115318: PUSH
115319: LD_INT 118
115321: PUSH
115322: EMPTY
115323: LIST
115324: LIST
115325: LIST
115326: LIST
115327: LIST
115328: LIST
115329: LIST
115330: LIST
115331: PUSH
115332: EMPTY
115333: LIST
115334: LIST
115335: ST_TO_ADDR
115336: GO 118223
115338: LD_INT 4
115340: DOUBLE
115341: EQUAL
115342: IFTRUE 115346
115344: GO 115442
115346: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
115347: LD_ADDR_VAR 0 2
115351: PUSH
115352: LD_INT 2
115354: PUSH
115355: LD_INT 4
115357: PUSH
115358: LD_INT 5
115360: PUSH
115361: LD_INT 8
115363: PUSH
115364: LD_INT 11
115366: PUSH
115367: LD_INT 12
115369: PUSH
115370: LD_INT 15
115372: PUSH
115373: LD_INT 16
115375: PUSH
115376: LD_INT 22
115378: PUSH
115379: LD_INT 23
115381: PUSH
115382: LD_INT 26
115384: PUSH
115385: LD_INT 36
115387: PUSH
115388: EMPTY
115389: LIST
115390: LIST
115391: LIST
115392: LIST
115393: LIST
115394: LIST
115395: LIST
115396: LIST
115397: LIST
115398: LIST
115399: LIST
115400: LIST
115401: PUSH
115402: LD_INT 101
115404: PUSH
115405: LD_INT 102
115407: PUSH
115408: LD_INT 105
115410: PUSH
115411: LD_INT 106
115413: PUSH
115414: LD_INT 108
115416: PUSH
115417: LD_INT 116
115419: PUSH
115420: LD_INT 117
115422: PUSH
115423: LD_INT 118
115425: PUSH
115426: EMPTY
115427: LIST
115428: LIST
115429: LIST
115430: LIST
115431: LIST
115432: LIST
115433: LIST
115434: LIST
115435: PUSH
115436: EMPTY
115437: LIST
115438: LIST
115439: ST_TO_ADDR
115440: GO 118223
115442: LD_INT 5
115444: DOUBLE
115445: EQUAL
115446: IFTRUE 115450
115448: GO 115562
115450: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
115451: LD_ADDR_VAR 0 2
115455: PUSH
115456: LD_INT 2
115458: PUSH
115459: LD_INT 4
115461: PUSH
115462: LD_INT 5
115464: PUSH
115465: LD_INT 6
115467: PUSH
115468: LD_INT 8
115470: PUSH
115471: LD_INT 11
115473: PUSH
115474: LD_INT 12
115476: PUSH
115477: LD_INT 15
115479: PUSH
115480: LD_INT 16
115482: PUSH
115483: LD_INT 22
115485: PUSH
115486: LD_INT 23
115488: PUSH
115489: LD_INT 25
115491: PUSH
115492: LD_INT 26
115494: PUSH
115495: LD_INT 36
115497: PUSH
115498: EMPTY
115499: LIST
115500: LIST
115501: LIST
115502: LIST
115503: LIST
115504: LIST
115505: LIST
115506: LIST
115507: LIST
115508: LIST
115509: LIST
115510: LIST
115511: LIST
115512: LIST
115513: PUSH
115514: LD_INT 101
115516: PUSH
115517: LD_INT 102
115519: PUSH
115520: LD_INT 105
115522: PUSH
115523: LD_INT 106
115525: PUSH
115526: LD_INT 108
115528: PUSH
115529: LD_INT 109
115531: PUSH
115532: LD_INT 112
115534: PUSH
115535: LD_INT 116
115537: PUSH
115538: LD_INT 117
115540: PUSH
115541: LD_INT 118
115543: PUSH
115544: EMPTY
115545: LIST
115546: LIST
115547: LIST
115548: LIST
115549: LIST
115550: LIST
115551: LIST
115552: LIST
115553: LIST
115554: LIST
115555: PUSH
115556: EMPTY
115557: LIST
115558: LIST
115559: ST_TO_ADDR
115560: GO 118223
115562: LD_INT 6
115564: DOUBLE
115565: EQUAL
115566: IFTRUE 115570
115568: GO 115702
115570: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
115571: LD_ADDR_VAR 0 2
115575: PUSH
115576: LD_INT 2
115578: PUSH
115579: LD_INT 4
115581: PUSH
115582: LD_INT 5
115584: PUSH
115585: LD_INT 6
115587: PUSH
115588: LD_INT 8
115590: PUSH
115591: LD_INT 11
115593: PUSH
115594: LD_INT 12
115596: PUSH
115597: LD_INT 15
115599: PUSH
115600: LD_INT 16
115602: PUSH
115603: LD_INT 20
115605: PUSH
115606: LD_INT 21
115608: PUSH
115609: LD_INT 22
115611: PUSH
115612: LD_INT 23
115614: PUSH
115615: LD_INT 25
115617: PUSH
115618: LD_INT 26
115620: PUSH
115621: LD_INT 30
115623: PUSH
115624: LD_INT 31
115626: PUSH
115627: LD_INT 32
115629: PUSH
115630: LD_INT 36
115632: PUSH
115633: EMPTY
115634: LIST
115635: LIST
115636: LIST
115637: LIST
115638: LIST
115639: LIST
115640: LIST
115641: LIST
115642: LIST
115643: LIST
115644: LIST
115645: LIST
115646: LIST
115647: LIST
115648: LIST
115649: LIST
115650: LIST
115651: LIST
115652: LIST
115653: PUSH
115654: LD_INT 101
115656: PUSH
115657: LD_INT 102
115659: PUSH
115660: LD_INT 105
115662: PUSH
115663: LD_INT 106
115665: PUSH
115666: LD_INT 108
115668: PUSH
115669: LD_INT 109
115671: PUSH
115672: LD_INT 112
115674: PUSH
115675: LD_INT 116
115677: PUSH
115678: LD_INT 117
115680: PUSH
115681: LD_INT 118
115683: PUSH
115684: EMPTY
115685: LIST
115686: LIST
115687: LIST
115688: LIST
115689: LIST
115690: LIST
115691: LIST
115692: LIST
115693: LIST
115694: LIST
115695: PUSH
115696: EMPTY
115697: LIST
115698: LIST
115699: ST_TO_ADDR
115700: GO 118223
115702: LD_INT 7
115704: DOUBLE
115705: EQUAL
115706: IFTRUE 115710
115708: GO 115822
115710: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
115711: LD_ADDR_VAR 0 2
115715: PUSH
115716: LD_INT 2
115718: PUSH
115719: LD_INT 4
115721: PUSH
115722: LD_INT 5
115724: PUSH
115725: LD_INT 7
115727: PUSH
115728: LD_INT 11
115730: PUSH
115731: LD_INT 12
115733: PUSH
115734: LD_INT 15
115736: PUSH
115737: LD_INT 16
115739: PUSH
115740: LD_INT 20
115742: PUSH
115743: LD_INT 21
115745: PUSH
115746: LD_INT 22
115748: PUSH
115749: LD_INT 23
115751: PUSH
115752: LD_INT 25
115754: PUSH
115755: LD_INT 26
115757: PUSH
115758: EMPTY
115759: LIST
115760: LIST
115761: LIST
115762: LIST
115763: LIST
115764: LIST
115765: LIST
115766: LIST
115767: LIST
115768: LIST
115769: LIST
115770: LIST
115771: LIST
115772: LIST
115773: PUSH
115774: LD_INT 101
115776: PUSH
115777: LD_INT 102
115779: PUSH
115780: LD_INT 103
115782: PUSH
115783: LD_INT 105
115785: PUSH
115786: LD_INT 106
115788: PUSH
115789: LD_INT 108
115791: PUSH
115792: LD_INT 112
115794: PUSH
115795: LD_INT 116
115797: PUSH
115798: LD_INT 117
115800: PUSH
115801: LD_INT 118
115803: PUSH
115804: EMPTY
115805: LIST
115806: LIST
115807: LIST
115808: LIST
115809: LIST
115810: LIST
115811: LIST
115812: LIST
115813: LIST
115814: LIST
115815: PUSH
115816: EMPTY
115817: LIST
115818: LIST
115819: ST_TO_ADDR
115820: GO 118223
115822: LD_INT 8
115824: DOUBLE
115825: EQUAL
115826: IFTRUE 115830
115828: GO 115970
115830: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
115831: LD_ADDR_VAR 0 2
115835: PUSH
115836: LD_INT 2
115838: PUSH
115839: LD_INT 4
115841: PUSH
115842: LD_INT 5
115844: PUSH
115845: LD_INT 6
115847: PUSH
115848: LD_INT 7
115850: PUSH
115851: LD_INT 8
115853: PUSH
115854: LD_INT 11
115856: PUSH
115857: LD_INT 12
115859: PUSH
115860: LD_INT 15
115862: PUSH
115863: LD_INT 16
115865: PUSH
115866: LD_INT 20
115868: PUSH
115869: LD_INT 21
115871: PUSH
115872: LD_INT 22
115874: PUSH
115875: LD_INT 23
115877: PUSH
115878: LD_INT 25
115880: PUSH
115881: LD_INT 26
115883: PUSH
115884: LD_INT 30
115886: PUSH
115887: LD_INT 31
115889: PUSH
115890: LD_INT 32
115892: PUSH
115893: LD_INT 36
115895: PUSH
115896: EMPTY
115897: LIST
115898: LIST
115899: LIST
115900: LIST
115901: LIST
115902: LIST
115903: LIST
115904: LIST
115905: LIST
115906: LIST
115907: LIST
115908: LIST
115909: LIST
115910: LIST
115911: LIST
115912: LIST
115913: LIST
115914: LIST
115915: LIST
115916: LIST
115917: PUSH
115918: LD_INT 101
115920: PUSH
115921: LD_INT 102
115923: PUSH
115924: LD_INT 103
115926: PUSH
115927: LD_INT 105
115929: PUSH
115930: LD_INT 106
115932: PUSH
115933: LD_INT 108
115935: PUSH
115936: LD_INT 109
115938: PUSH
115939: LD_INT 112
115941: PUSH
115942: LD_INT 116
115944: PUSH
115945: LD_INT 117
115947: PUSH
115948: LD_INT 118
115950: PUSH
115951: EMPTY
115952: LIST
115953: LIST
115954: LIST
115955: LIST
115956: LIST
115957: LIST
115958: LIST
115959: LIST
115960: LIST
115961: LIST
115962: LIST
115963: PUSH
115964: EMPTY
115965: LIST
115966: LIST
115967: ST_TO_ADDR
115968: GO 118223
115970: LD_INT 9
115972: DOUBLE
115973: EQUAL
115974: IFTRUE 115978
115976: GO 116126
115978: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
115979: LD_ADDR_VAR 0 2
115983: PUSH
115984: LD_INT 2
115986: PUSH
115987: LD_INT 4
115989: PUSH
115990: LD_INT 5
115992: PUSH
115993: LD_INT 6
115995: PUSH
115996: LD_INT 7
115998: PUSH
115999: LD_INT 8
116001: PUSH
116002: LD_INT 11
116004: PUSH
116005: LD_INT 12
116007: PUSH
116008: LD_INT 15
116010: PUSH
116011: LD_INT 16
116013: PUSH
116014: LD_INT 20
116016: PUSH
116017: LD_INT 21
116019: PUSH
116020: LD_INT 22
116022: PUSH
116023: LD_INT 23
116025: PUSH
116026: LD_INT 25
116028: PUSH
116029: LD_INT 26
116031: PUSH
116032: LD_INT 28
116034: PUSH
116035: LD_INT 30
116037: PUSH
116038: LD_INT 31
116040: PUSH
116041: LD_INT 32
116043: PUSH
116044: LD_INT 36
116046: PUSH
116047: EMPTY
116048: LIST
116049: LIST
116050: LIST
116051: LIST
116052: LIST
116053: LIST
116054: LIST
116055: LIST
116056: LIST
116057: LIST
116058: LIST
116059: LIST
116060: LIST
116061: LIST
116062: LIST
116063: LIST
116064: LIST
116065: LIST
116066: LIST
116067: LIST
116068: LIST
116069: PUSH
116070: LD_INT 101
116072: PUSH
116073: LD_INT 102
116075: PUSH
116076: LD_INT 103
116078: PUSH
116079: LD_INT 105
116081: PUSH
116082: LD_INT 106
116084: PUSH
116085: LD_INT 108
116087: PUSH
116088: LD_INT 109
116090: PUSH
116091: LD_INT 112
116093: PUSH
116094: LD_INT 114
116096: PUSH
116097: LD_INT 116
116099: PUSH
116100: LD_INT 117
116102: PUSH
116103: LD_INT 118
116105: PUSH
116106: EMPTY
116107: LIST
116108: LIST
116109: LIST
116110: LIST
116111: LIST
116112: LIST
116113: LIST
116114: LIST
116115: LIST
116116: LIST
116117: LIST
116118: LIST
116119: PUSH
116120: EMPTY
116121: LIST
116122: LIST
116123: ST_TO_ADDR
116124: GO 118223
116126: LD_INT 10
116128: DOUBLE
116129: EQUAL
116130: IFTRUE 116134
116132: GO 116330
116134: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
116135: LD_ADDR_VAR 0 2
116139: PUSH
116140: LD_INT 2
116142: PUSH
116143: LD_INT 4
116145: PUSH
116146: LD_INT 5
116148: PUSH
116149: LD_INT 6
116151: PUSH
116152: LD_INT 7
116154: PUSH
116155: LD_INT 8
116157: PUSH
116158: LD_INT 9
116160: PUSH
116161: LD_INT 10
116163: PUSH
116164: LD_INT 11
116166: PUSH
116167: LD_INT 12
116169: PUSH
116170: LD_INT 13
116172: PUSH
116173: LD_INT 14
116175: PUSH
116176: LD_INT 15
116178: PUSH
116179: LD_INT 16
116181: PUSH
116182: LD_INT 17
116184: PUSH
116185: LD_INT 18
116187: PUSH
116188: LD_INT 19
116190: PUSH
116191: LD_INT 20
116193: PUSH
116194: LD_INT 21
116196: PUSH
116197: LD_INT 22
116199: PUSH
116200: LD_INT 23
116202: PUSH
116203: LD_INT 24
116205: PUSH
116206: LD_INT 25
116208: PUSH
116209: LD_INT 26
116211: PUSH
116212: LD_INT 28
116214: PUSH
116215: LD_INT 30
116217: PUSH
116218: LD_INT 31
116220: PUSH
116221: LD_INT 32
116223: PUSH
116224: LD_INT 36
116226: PUSH
116227: EMPTY
116228: LIST
116229: LIST
116230: LIST
116231: LIST
116232: LIST
116233: LIST
116234: LIST
116235: LIST
116236: LIST
116237: LIST
116238: LIST
116239: LIST
116240: LIST
116241: LIST
116242: LIST
116243: LIST
116244: LIST
116245: LIST
116246: LIST
116247: LIST
116248: LIST
116249: LIST
116250: LIST
116251: LIST
116252: LIST
116253: LIST
116254: LIST
116255: LIST
116256: LIST
116257: PUSH
116258: LD_INT 101
116260: PUSH
116261: LD_INT 102
116263: PUSH
116264: LD_INT 103
116266: PUSH
116267: LD_INT 104
116269: PUSH
116270: LD_INT 105
116272: PUSH
116273: LD_INT 106
116275: PUSH
116276: LD_INT 107
116278: PUSH
116279: LD_INT 108
116281: PUSH
116282: LD_INT 109
116284: PUSH
116285: LD_INT 110
116287: PUSH
116288: LD_INT 111
116290: PUSH
116291: LD_INT 112
116293: PUSH
116294: LD_INT 114
116296: PUSH
116297: LD_INT 116
116299: PUSH
116300: LD_INT 117
116302: PUSH
116303: LD_INT 118
116305: PUSH
116306: EMPTY
116307: LIST
116308: LIST
116309: LIST
116310: LIST
116311: LIST
116312: LIST
116313: LIST
116314: LIST
116315: LIST
116316: LIST
116317: LIST
116318: LIST
116319: LIST
116320: LIST
116321: LIST
116322: LIST
116323: PUSH
116324: EMPTY
116325: LIST
116326: LIST
116327: ST_TO_ADDR
116328: GO 118223
116330: LD_INT 11
116332: DOUBLE
116333: EQUAL
116334: IFTRUE 116338
116336: GO 116542
116338: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
116339: LD_ADDR_VAR 0 2
116343: PUSH
116344: LD_INT 2
116346: PUSH
116347: LD_INT 3
116349: PUSH
116350: LD_INT 4
116352: PUSH
116353: LD_INT 5
116355: PUSH
116356: LD_INT 6
116358: PUSH
116359: LD_INT 7
116361: PUSH
116362: LD_INT 8
116364: PUSH
116365: LD_INT 9
116367: PUSH
116368: LD_INT 10
116370: PUSH
116371: LD_INT 11
116373: PUSH
116374: LD_INT 12
116376: PUSH
116377: LD_INT 13
116379: PUSH
116380: LD_INT 14
116382: PUSH
116383: LD_INT 15
116385: PUSH
116386: LD_INT 16
116388: PUSH
116389: LD_INT 17
116391: PUSH
116392: LD_INT 18
116394: PUSH
116395: LD_INT 19
116397: PUSH
116398: LD_INT 20
116400: PUSH
116401: LD_INT 21
116403: PUSH
116404: LD_INT 22
116406: PUSH
116407: LD_INT 23
116409: PUSH
116410: LD_INT 24
116412: PUSH
116413: LD_INT 25
116415: PUSH
116416: LD_INT 26
116418: PUSH
116419: LD_INT 28
116421: PUSH
116422: LD_INT 30
116424: PUSH
116425: LD_INT 31
116427: PUSH
116428: LD_INT 32
116430: PUSH
116431: LD_INT 34
116433: PUSH
116434: LD_INT 36
116436: PUSH
116437: EMPTY
116438: LIST
116439: LIST
116440: LIST
116441: LIST
116442: LIST
116443: LIST
116444: LIST
116445: LIST
116446: LIST
116447: LIST
116448: LIST
116449: LIST
116450: LIST
116451: LIST
116452: LIST
116453: LIST
116454: LIST
116455: LIST
116456: LIST
116457: LIST
116458: LIST
116459: LIST
116460: LIST
116461: LIST
116462: LIST
116463: LIST
116464: LIST
116465: LIST
116466: LIST
116467: LIST
116468: LIST
116469: PUSH
116470: LD_INT 101
116472: PUSH
116473: LD_INT 102
116475: PUSH
116476: LD_INT 103
116478: PUSH
116479: LD_INT 104
116481: PUSH
116482: LD_INT 105
116484: PUSH
116485: LD_INT 106
116487: PUSH
116488: LD_INT 107
116490: PUSH
116491: LD_INT 108
116493: PUSH
116494: LD_INT 109
116496: PUSH
116497: LD_INT 110
116499: PUSH
116500: LD_INT 111
116502: PUSH
116503: LD_INT 112
116505: PUSH
116506: LD_INT 114
116508: PUSH
116509: LD_INT 116
116511: PUSH
116512: LD_INT 117
116514: PUSH
116515: LD_INT 118
116517: PUSH
116518: EMPTY
116519: LIST
116520: LIST
116521: LIST
116522: LIST
116523: LIST
116524: LIST
116525: LIST
116526: LIST
116527: LIST
116528: LIST
116529: LIST
116530: LIST
116531: LIST
116532: LIST
116533: LIST
116534: LIST
116535: PUSH
116536: EMPTY
116537: LIST
116538: LIST
116539: ST_TO_ADDR
116540: GO 118223
116542: LD_INT 12
116544: DOUBLE
116545: EQUAL
116546: IFTRUE 116550
116548: GO 116770
116550: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
116551: LD_ADDR_VAR 0 2
116555: PUSH
116556: LD_INT 1
116558: PUSH
116559: LD_INT 2
116561: PUSH
116562: LD_INT 3
116564: PUSH
116565: LD_INT 4
116567: PUSH
116568: LD_INT 5
116570: PUSH
116571: LD_INT 6
116573: PUSH
116574: LD_INT 7
116576: PUSH
116577: LD_INT 8
116579: PUSH
116580: LD_INT 9
116582: PUSH
116583: LD_INT 10
116585: PUSH
116586: LD_INT 11
116588: PUSH
116589: LD_INT 12
116591: PUSH
116592: LD_INT 13
116594: PUSH
116595: LD_INT 14
116597: PUSH
116598: LD_INT 15
116600: PUSH
116601: LD_INT 16
116603: PUSH
116604: LD_INT 17
116606: PUSH
116607: LD_INT 18
116609: PUSH
116610: LD_INT 19
116612: PUSH
116613: LD_INT 20
116615: PUSH
116616: LD_INT 21
116618: PUSH
116619: LD_INT 22
116621: PUSH
116622: LD_INT 23
116624: PUSH
116625: LD_INT 24
116627: PUSH
116628: LD_INT 25
116630: PUSH
116631: LD_INT 26
116633: PUSH
116634: LD_INT 27
116636: PUSH
116637: LD_INT 28
116639: PUSH
116640: LD_INT 30
116642: PUSH
116643: LD_INT 31
116645: PUSH
116646: LD_INT 32
116648: PUSH
116649: LD_INT 33
116651: PUSH
116652: LD_INT 34
116654: PUSH
116655: LD_INT 36
116657: PUSH
116658: EMPTY
116659: LIST
116660: LIST
116661: LIST
116662: LIST
116663: LIST
116664: LIST
116665: LIST
116666: LIST
116667: LIST
116668: LIST
116669: LIST
116670: LIST
116671: LIST
116672: LIST
116673: LIST
116674: LIST
116675: LIST
116676: LIST
116677: LIST
116678: LIST
116679: LIST
116680: LIST
116681: LIST
116682: LIST
116683: LIST
116684: LIST
116685: LIST
116686: LIST
116687: LIST
116688: LIST
116689: LIST
116690: LIST
116691: LIST
116692: LIST
116693: PUSH
116694: LD_INT 101
116696: PUSH
116697: LD_INT 102
116699: PUSH
116700: LD_INT 103
116702: PUSH
116703: LD_INT 104
116705: PUSH
116706: LD_INT 105
116708: PUSH
116709: LD_INT 106
116711: PUSH
116712: LD_INT 107
116714: PUSH
116715: LD_INT 108
116717: PUSH
116718: LD_INT 109
116720: PUSH
116721: LD_INT 110
116723: PUSH
116724: LD_INT 111
116726: PUSH
116727: LD_INT 112
116729: PUSH
116730: LD_INT 113
116732: PUSH
116733: LD_INT 114
116735: PUSH
116736: LD_INT 116
116738: PUSH
116739: LD_INT 117
116741: PUSH
116742: LD_INT 118
116744: PUSH
116745: EMPTY
116746: LIST
116747: LIST
116748: LIST
116749: LIST
116750: LIST
116751: LIST
116752: LIST
116753: LIST
116754: LIST
116755: LIST
116756: LIST
116757: LIST
116758: LIST
116759: LIST
116760: LIST
116761: LIST
116762: LIST
116763: PUSH
116764: EMPTY
116765: LIST
116766: LIST
116767: ST_TO_ADDR
116768: GO 118223
116770: LD_INT 13
116772: DOUBLE
116773: EQUAL
116774: IFTRUE 116778
116776: GO 116986
116778: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
116779: LD_ADDR_VAR 0 2
116783: PUSH
116784: LD_INT 1
116786: PUSH
116787: LD_INT 2
116789: PUSH
116790: LD_INT 3
116792: PUSH
116793: LD_INT 4
116795: PUSH
116796: LD_INT 5
116798: PUSH
116799: LD_INT 8
116801: PUSH
116802: LD_INT 9
116804: PUSH
116805: LD_INT 10
116807: PUSH
116808: LD_INT 11
116810: PUSH
116811: LD_INT 12
116813: PUSH
116814: LD_INT 14
116816: PUSH
116817: LD_INT 15
116819: PUSH
116820: LD_INT 16
116822: PUSH
116823: LD_INT 17
116825: PUSH
116826: LD_INT 18
116828: PUSH
116829: LD_INT 19
116831: PUSH
116832: LD_INT 20
116834: PUSH
116835: LD_INT 21
116837: PUSH
116838: LD_INT 22
116840: PUSH
116841: LD_INT 23
116843: PUSH
116844: LD_INT 24
116846: PUSH
116847: LD_INT 25
116849: PUSH
116850: LD_INT 26
116852: PUSH
116853: LD_INT 27
116855: PUSH
116856: LD_INT 28
116858: PUSH
116859: LD_INT 30
116861: PUSH
116862: LD_INT 31
116864: PUSH
116865: LD_INT 32
116867: PUSH
116868: LD_INT 33
116870: PUSH
116871: LD_INT 34
116873: PUSH
116874: LD_INT 36
116876: PUSH
116877: EMPTY
116878: LIST
116879: LIST
116880: LIST
116881: LIST
116882: LIST
116883: LIST
116884: LIST
116885: LIST
116886: LIST
116887: LIST
116888: LIST
116889: LIST
116890: LIST
116891: LIST
116892: LIST
116893: LIST
116894: LIST
116895: LIST
116896: LIST
116897: LIST
116898: LIST
116899: LIST
116900: LIST
116901: LIST
116902: LIST
116903: LIST
116904: LIST
116905: LIST
116906: LIST
116907: LIST
116908: LIST
116909: PUSH
116910: LD_INT 101
116912: PUSH
116913: LD_INT 102
116915: PUSH
116916: LD_INT 103
116918: PUSH
116919: LD_INT 104
116921: PUSH
116922: LD_INT 105
116924: PUSH
116925: LD_INT 106
116927: PUSH
116928: LD_INT 107
116930: PUSH
116931: LD_INT 108
116933: PUSH
116934: LD_INT 109
116936: PUSH
116937: LD_INT 110
116939: PUSH
116940: LD_INT 111
116942: PUSH
116943: LD_INT 112
116945: PUSH
116946: LD_INT 113
116948: PUSH
116949: LD_INT 114
116951: PUSH
116952: LD_INT 116
116954: PUSH
116955: LD_INT 117
116957: PUSH
116958: LD_INT 118
116960: PUSH
116961: EMPTY
116962: LIST
116963: LIST
116964: LIST
116965: LIST
116966: LIST
116967: LIST
116968: LIST
116969: LIST
116970: LIST
116971: LIST
116972: LIST
116973: LIST
116974: LIST
116975: LIST
116976: LIST
116977: LIST
116978: LIST
116979: PUSH
116980: EMPTY
116981: LIST
116982: LIST
116983: ST_TO_ADDR
116984: GO 118223
116986: LD_INT 14
116988: DOUBLE
116989: EQUAL
116990: IFTRUE 116994
116992: GO 117218
116994: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
116995: LD_ADDR_VAR 0 2
116999: PUSH
117000: LD_INT 1
117002: PUSH
117003: LD_INT 2
117005: PUSH
117006: LD_INT 3
117008: PUSH
117009: LD_INT 4
117011: PUSH
117012: LD_INT 5
117014: PUSH
117015: LD_INT 6
117017: PUSH
117018: LD_INT 7
117020: PUSH
117021: LD_INT 8
117023: PUSH
117024: LD_INT 9
117026: PUSH
117027: LD_INT 10
117029: PUSH
117030: LD_INT 11
117032: PUSH
117033: LD_INT 12
117035: PUSH
117036: LD_INT 13
117038: PUSH
117039: LD_INT 14
117041: PUSH
117042: LD_INT 15
117044: PUSH
117045: LD_INT 16
117047: PUSH
117048: LD_INT 17
117050: PUSH
117051: LD_INT 18
117053: PUSH
117054: LD_INT 19
117056: PUSH
117057: LD_INT 20
117059: PUSH
117060: LD_INT 21
117062: PUSH
117063: LD_INT 22
117065: PUSH
117066: LD_INT 23
117068: PUSH
117069: LD_INT 24
117071: PUSH
117072: LD_INT 25
117074: PUSH
117075: LD_INT 26
117077: PUSH
117078: LD_INT 27
117080: PUSH
117081: LD_INT 28
117083: PUSH
117084: LD_INT 29
117086: PUSH
117087: LD_INT 30
117089: PUSH
117090: LD_INT 31
117092: PUSH
117093: LD_INT 32
117095: PUSH
117096: LD_INT 33
117098: PUSH
117099: LD_INT 34
117101: PUSH
117102: LD_INT 36
117104: PUSH
117105: EMPTY
117106: LIST
117107: LIST
117108: LIST
117109: LIST
117110: LIST
117111: LIST
117112: LIST
117113: LIST
117114: LIST
117115: LIST
117116: LIST
117117: LIST
117118: LIST
117119: LIST
117120: LIST
117121: LIST
117122: LIST
117123: LIST
117124: LIST
117125: LIST
117126: LIST
117127: LIST
117128: LIST
117129: LIST
117130: LIST
117131: LIST
117132: LIST
117133: LIST
117134: LIST
117135: LIST
117136: LIST
117137: LIST
117138: LIST
117139: LIST
117140: LIST
117141: PUSH
117142: LD_INT 101
117144: PUSH
117145: LD_INT 102
117147: PUSH
117148: LD_INT 103
117150: PUSH
117151: LD_INT 104
117153: PUSH
117154: LD_INT 105
117156: PUSH
117157: LD_INT 106
117159: PUSH
117160: LD_INT 107
117162: PUSH
117163: LD_INT 108
117165: PUSH
117166: LD_INT 109
117168: PUSH
117169: LD_INT 110
117171: PUSH
117172: LD_INT 111
117174: PUSH
117175: LD_INT 112
117177: PUSH
117178: LD_INT 113
117180: PUSH
117181: LD_INT 114
117183: PUSH
117184: LD_INT 116
117186: PUSH
117187: LD_INT 117
117189: PUSH
117190: LD_INT 118
117192: PUSH
117193: EMPTY
117194: LIST
117195: LIST
117196: LIST
117197: LIST
117198: LIST
117199: LIST
117200: LIST
117201: LIST
117202: LIST
117203: LIST
117204: LIST
117205: LIST
117206: LIST
117207: LIST
117208: LIST
117209: LIST
117210: LIST
117211: PUSH
117212: EMPTY
117213: LIST
117214: LIST
117215: ST_TO_ADDR
117216: GO 118223
117218: LD_INT 15
117220: DOUBLE
117221: EQUAL
117222: IFTRUE 117226
117224: GO 117450
117226: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
117227: LD_ADDR_VAR 0 2
117231: PUSH
117232: LD_INT 1
117234: PUSH
117235: LD_INT 2
117237: PUSH
117238: LD_INT 3
117240: PUSH
117241: LD_INT 4
117243: PUSH
117244: LD_INT 5
117246: PUSH
117247: LD_INT 6
117249: PUSH
117250: LD_INT 7
117252: PUSH
117253: LD_INT 8
117255: PUSH
117256: LD_INT 9
117258: PUSH
117259: LD_INT 10
117261: PUSH
117262: LD_INT 11
117264: PUSH
117265: LD_INT 12
117267: PUSH
117268: LD_INT 13
117270: PUSH
117271: LD_INT 14
117273: PUSH
117274: LD_INT 15
117276: PUSH
117277: LD_INT 16
117279: PUSH
117280: LD_INT 17
117282: PUSH
117283: LD_INT 18
117285: PUSH
117286: LD_INT 19
117288: PUSH
117289: LD_INT 20
117291: PUSH
117292: LD_INT 21
117294: PUSH
117295: LD_INT 22
117297: PUSH
117298: LD_INT 23
117300: PUSH
117301: LD_INT 24
117303: PUSH
117304: LD_INT 25
117306: PUSH
117307: LD_INT 26
117309: PUSH
117310: LD_INT 27
117312: PUSH
117313: LD_INT 28
117315: PUSH
117316: LD_INT 29
117318: PUSH
117319: LD_INT 30
117321: PUSH
117322: LD_INT 31
117324: PUSH
117325: LD_INT 32
117327: PUSH
117328: LD_INT 33
117330: PUSH
117331: LD_INT 34
117333: PUSH
117334: LD_INT 36
117336: PUSH
117337: EMPTY
117338: LIST
117339: LIST
117340: LIST
117341: LIST
117342: LIST
117343: LIST
117344: LIST
117345: LIST
117346: LIST
117347: LIST
117348: LIST
117349: LIST
117350: LIST
117351: LIST
117352: LIST
117353: LIST
117354: LIST
117355: LIST
117356: LIST
117357: LIST
117358: LIST
117359: LIST
117360: LIST
117361: LIST
117362: LIST
117363: LIST
117364: LIST
117365: LIST
117366: LIST
117367: LIST
117368: LIST
117369: LIST
117370: LIST
117371: LIST
117372: LIST
117373: PUSH
117374: LD_INT 101
117376: PUSH
117377: LD_INT 102
117379: PUSH
117380: LD_INT 103
117382: PUSH
117383: LD_INT 104
117385: PUSH
117386: LD_INT 105
117388: PUSH
117389: LD_INT 106
117391: PUSH
117392: LD_INT 107
117394: PUSH
117395: LD_INT 108
117397: PUSH
117398: LD_INT 109
117400: PUSH
117401: LD_INT 110
117403: PUSH
117404: LD_INT 111
117406: PUSH
117407: LD_INT 112
117409: PUSH
117410: LD_INT 113
117412: PUSH
117413: LD_INT 114
117415: PUSH
117416: LD_INT 116
117418: PUSH
117419: LD_INT 117
117421: PUSH
117422: LD_INT 118
117424: PUSH
117425: EMPTY
117426: LIST
117427: LIST
117428: LIST
117429: LIST
117430: LIST
117431: LIST
117432: LIST
117433: LIST
117434: LIST
117435: LIST
117436: LIST
117437: LIST
117438: LIST
117439: LIST
117440: LIST
117441: LIST
117442: LIST
117443: PUSH
117444: EMPTY
117445: LIST
117446: LIST
117447: ST_TO_ADDR
117448: GO 118223
117450: LD_INT 16
117452: DOUBLE
117453: EQUAL
117454: IFTRUE 117458
117456: GO 117594
117458: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
117459: LD_ADDR_VAR 0 2
117463: PUSH
117464: LD_INT 2
117466: PUSH
117467: LD_INT 4
117469: PUSH
117470: LD_INT 5
117472: PUSH
117473: LD_INT 7
117475: PUSH
117476: LD_INT 11
117478: PUSH
117479: LD_INT 12
117481: PUSH
117482: LD_INT 15
117484: PUSH
117485: LD_INT 16
117487: PUSH
117488: LD_INT 20
117490: PUSH
117491: LD_INT 21
117493: PUSH
117494: LD_INT 22
117496: PUSH
117497: LD_INT 23
117499: PUSH
117500: LD_INT 25
117502: PUSH
117503: LD_INT 26
117505: PUSH
117506: LD_INT 30
117508: PUSH
117509: LD_INT 31
117511: PUSH
117512: LD_INT 32
117514: PUSH
117515: LD_INT 33
117517: PUSH
117518: LD_INT 34
117520: PUSH
117521: EMPTY
117522: LIST
117523: LIST
117524: LIST
117525: LIST
117526: LIST
117527: LIST
117528: LIST
117529: LIST
117530: LIST
117531: LIST
117532: LIST
117533: LIST
117534: LIST
117535: LIST
117536: LIST
117537: LIST
117538: LIST
117539: LIST
117540: LIST
117541: PUSH
117542: LD_INT 101
117544: PUSH
117545: LD_INT 102
117547: PUSH
117548: LD_INT 103
117550: PUSH
117551: LD_INT 106
117553: PUSH
117554: LD_INT 108
117556: PUSH
117557: LD_INT 112
117559: PUSH
117560: LD_INT 113
117562: PUSH
117563: LD_INT 114
117565: PUSH
117566: LD_INT 116
117568: PUSH
117569: LD_INT 117
117571: PUSH
117572: LD_INT 118
117574: PUSH
117575: EMPTY
117576: LIST
117577: LIST
117578: LIST
117579: LIST
117580: LIST
117581: LIST
117582: LIST
117583: LIST
117584: LIST
117585: LIST
117586: LIST
117587: PUSH
117588: EMPTY
117589: LIST
117590: LIST
117591: ST_TO_ADDR
117592: GO 118223
117594: LD_INT 17
117596: DOUBLE
117597: EQUAL
117598: IFTRUE 117602
117600: GO 117826
117602: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
117603: LD_ADDR_VAR 0 2
117607: PUSH
117608: LD_INT 1
117610: PUSH
117611: LD_INT 2
117613: PUSH
117614: LD_INT 3
117616: PUSH
117617: LD_INT 4
117619: PUSH
117620: LD_INT 5
117622: PUSH
117623: LD_INT 6
117625: PUSH
117626: LD_INT 7
117628: PUSH
117629: LD_INT 8
117631: PUSH
117632: LD_INT 9
117634: PUSH
117635: LD_INT 10
117637: PUSH
117638: LD_INT 11
117640: PUSH
117641: LD_INT 12
117643: PUSH
117644: LD_INT 13
117646: PUSH
117647: LD_INT 14
117649: PUSH
117650: LD_INT 15
117652: PUSH
117653: LD_INT 16
117655: PUSH
117656: LD_INT 17
117658: PUSH
117659: LD_INT 18
117661: PUSH
117662: LD_INT 19
117664: PUSH
117665: LD_INT 20
117667: PUSH
117668: LD_INT 21
117670: PUSH
117671: LD_INT 22
117673: PUSH
117674: LD_INT 23
117676: PUSH
117677: LD_INT 24
117679: PUSH
117680: LD_INT 25
117682: PUSH
117683: LD_INT 26
117685: PUSH
117686: LD_INT 27
117688: PUSH
117689: LD_INT 28
117691: PUSH
117692: LD_INT 29
117694: PUSH
117695: LD_INT 30
117697: PUSH
117698: LD_INT 31
117700: PUSH
117701: LD_INT 32
117703: PUSH
117704: LD_INT 33
117706: PUSH
117707: LD_INT 34
117709: PUSH
117710: LD_INT 36
117712: PUSH
117713: EMPTY
117714: LIST
117715: LIST
117716: LIST
117717: LIST
117718: LIST
117719: LIST
117720: LIST
117721: LIST
117722: LIST
117723: LIST
117724: LIST
117725: LIST
117726: LIST
117727: LIST
117728: LIST
117729: LIST
117730: LIST
117731: LIST
117732: LIST
117733: LIST
117734: LIST
117735: LIST
117736: LIST
117737: LIST
117738: LIST
117739: LIST
117740: LIST
117741: LIST
117742: LIST
117743: LIST
117744: LIST
117745: LIST
117746: LIST
117747: LIST
117748: LIST
117749: PUSH
117750: LD_INT 101
117752: PUSH
117753: LD_INT 102
117755: PUSH
117756: LD_INT 103
117758: PUSH
117759: LD_INT 104
117761: PUSH
117762: LD_INT 105
117764: PUSH
117765: LD_INT 106
117767: PUSH
117768: LD_INT 107
117770: PUSH
117771: LD_INT 108
117773: PUSH
117774: LD_INT 109
117776: PUSH
117777: LD_INT 110
117779: PUSH
117780: LD_INT 111
117782: PUSH
117783: LD_INT 112
117785: PUSH
117786: LD_INT 113
117788: PUSH
117789: LD_INT 114
117791: PUSH
117792: LD_INT 116
117794: PUSH
117795: LD_INT 117
117797: PUSH
117798: LD_INT 118
117800: PUSH
117801: EMPTY
117802: LIST
117803: LIST
117804: LIST
117805: LIST
117806: LIST
117807: LIST
117808: LIST
117809: LIST
117810: LIST
117811: LIST
117812: LIST
117813: LIST
117814: LIST
117815: LIST
117816: LIST
117817: LIST
117818: LIST
117819: PUSH
117820: EMPTY
117821: LIST
117822: LIST
117823: ST_TO_ADDR
117824: GO 118223
117826: LD_INT 18
117828: DOUBLE
117829: EQUAL
117830: IFTRUE 117834
117832: GO 117982
117834: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
117835: LD_ADDR_VAR 0 2
117839: PUSH
117840: LD_INT 2
117842: PUSH
117843: LD_INT 4
117845: PUSH
117846: LD_INT 5
117848: PUSH
117849: LD_INT 7
117851: PUSH
117852: LD_INT 11
117854: PUSH
117855: LD_INT 12
117857: PUSH
117858: LD_INT 15
117860: PUSH
117861: LD_INT 16
117863: PUSH
117864: LD_INT 20
117866: PUSH
117867: LD_INT 21
117869: PUSH
117870: LD_INT 22
117872: PUSH
117873: LD_INT 23
117875: PUSH
117876: LD_INT 25
117878: PUSH
117879: LD_INT 26
117881: PUSH
117882: LD_INT 30
117884: PUSH
117885: LD_INT 31
117887: PUSH
117888: LD_INT 32
117890: PUSH
117891: LD_INT 33
117893: PUSH
117894: LD_INT 34
117896: PUSH
117897: LD_INT 35
117899: PUSH
117900: LD_INT 36
117902: PUSH
117903: EMPTY
117904: LIST
117905: LIST
117906: LIST
117907: LIST
117908: LIST
117909: LIST
117910: LIST
117911: LIST
117912: LIST
117913: LIST
117914: LIST
117915: LIST
117916: LIST
117917: LIST
117918: LIST
117919: LIST
117920: LIST
117921: LIST
117922: LIST
117923: LIST
117924: LIST
117925: PUSH
117926: LD_INT 101
117928: PUSH
117929: LD_INT 102
117931: PUSH
117932: LD_INT 103
117934: PUSH
117935: LD_INT 106
117937: PUSH
117938: LD_INT 108
117940: PUSH
117941: LD_INT 112
117943: PUSH
117944: LD_INT 113
117946: PUSH
117947: LD_INT 114
117949: PUSH
117950: LD_INT 115
117952: PUSH
117953: LD_INT 116
117955: PUSH
117956: LD_INT 117
117958: PUSH
117959: LD_INT 118
117961: PUSH
117962: EMPTY
117963: LIST
117964: LIST
117965: LIST
117966: LIST
117967: LIST
117968: LIST
117969: LIST
117970: LIST
117971: LIST
117972: LIST
117973: LIST
117974: LIST
117975: PUSH
117976: EMPTY
117977: LIST
117978: LIST
117979: ST_TO_ADDR
117980: GO 118223
117982: LD_INT 19
117984: DOUBLE
117985: EQUAL
117986: IFTRUE 117990
117988: GO 118222
117990: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
117991: LD_ADDR_VAR 0 2
117995: PUSH
117996: LD_INT 1
117998: PUSH
117999: LD_INT 2
118001: PUSH
118002: LD_INT 3
118004: PUSH
118005: LD_INT 4
118007: PUSH
118008: LD_INT 5
118010: PUSH
118011: LD_INT 6
118013: PUSH
118014: LD_INT 7
118016: PUSH
118017: LD_INT 8
118019: PUSH
118020: LD_INT 9
118022: PUSH
118023: LD_INT 10
118025: PUSH
118026: LD_INT 11
118028: PUSH
118029: LD_INT 12
118031: PUSH
118032: LD_INT 13
118034: PUSH
118035: LD_INT 14
118037: PUSH
118038: LD_INT 15
118040: PUSH
118041: LD_INT 16
118043: PUSH
118044: LD_INT 17
118046: PUSH
118047: LD_INT 18
118049: PUSH
118050: LD_INT 19
118052: PUSH
118053: LD_INT 20
118055: PUSH
118056: LD_INT 21
118058: PUSH
118059: LD_INT 22
118061: PUSH
118062: LD_INT 23
118064: PUSH
118065: LD_INT 24
118067: PUSH
118068: LD_INT 25
118070: PUSH
118071: LD_INT 26
118073: PUSH
118074: LD_INT 27
118076: PUSH
118077: LD_INT 28
118079: PUSH
118080: LD_INT 29
118082: PUSH
118083: LD_INT 30
118085: PUSH
118086: LD_INT 31
118088: PUSH
118089: LD_INT 32
118091: PUSH
118092: LD_INT 33
118094: PUSH
118095: LD_INT 34
118097: PUSH
118098: LD_INT 35
118100: PUSH
118101: LD_INT 36
118103: PUSH
118104: EMPTY
118105: LIST
118106: LIST
118107: LIST
118108: LIST
118109: LIST
118110: LIST
118111: LIST
118112: LIST
118113: LIST
118114: LIST
118115: LIST
118116: LIST
118117: LIST
118118: LIST
118119: LIST
118120: LIST
118121: LIST
118122: LIST
118123: LIST
118124: LIST
118125: LIST
118126: LIST
118127: LIST
118128: LIST
118129: LIST
118130: LIST
118131: LIST
118132: LIST
118133: LIST
118134: LIST
118135: LIST
118136: LIST
118137: LIST
118138: LIST
118139: LIST
118140: LIST
118141: PUSH
118142: LD_INT 101
118144: PUSH
118145: LD_INT 102
118147: PUSH
118148: LD_INT 103
118150: PUSH
118151: LD_INT 104
118153: PUSH
118154: LD_INT 105
118156: PUSH
118157: LD_INT 106
118159: PUSH
118160: LD_INT 107
118162: PUSH
118163: LD_INT 108
118165: PUSH
118166: LD_INT 109
118168: PUSH
118169: LD_INT 110
118171: PUSH
118172: LD_INT 111
118174: PUSH
118175: LD_INT 112
118177: PUSH
118178: LD_INT 113
118180: PUSH
118181: LD_INT 114
118183: PUSH
118184: LD_INT 115
118186: PUSH
118187: LD_INT 116
118189: PUSH
118190: LD_INT 117
118192: PUSH
118193: LD_INT 118
118195: PUSH
118196: EMPTY
118197: LIST
118198: LIST
118199: LIST
118200: LIST
118201: LIST
118202: LIST
118203: LIST
118204: LIST
118205: LIST
118206: LIST
118207: LIST
118208: LIST
118209: LIST
118210: LIST
118211: LIST
118212: LIST
118213: LIST
118214: LIST
118215: PUSH
118216: EMPTY
118217: LIST
118218: LIST
118219: ST_TO_ADDR
118220: GO 118223
118222: POP
// end else
118223: GO 118454
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
118225: LD_ADDR_VAR 0 2
118229: PUSH
118230: LD_INT 1
118232: PUSH
118233: LD_INT 2
118235: PUSH
118236: LD_INT 3
118238: PUSH
118239: LD_INT 4
118241: PUSH
118242: LD_INT 5
118244: PUSH
118245: LD_INT 6
118247: PUSH
118248: LD_INT 7
118250: PUSH
118251: LD_INT 8
118253: PUSH
118254: LD_INT 9
118256: PUSH
118257: LD_INT 10
118259: PUSH
118260: LD_INT 11
118262: PUSH
118263: LD_INT 12
118265: PUSH
118266: LD_INT 13
118268: PUSH
118269: LD_INT 14
118271: PUSH
118272: LD_INT 15
118274: PUSH
118275: LD_INT 16
118277: PUSH
118278: LD_INT 17
118280: PUSH
118281: LD_INT 18
118283: PUSH
118284: LD_INT 19
118286: PUSH
118287: LD_INT 20
118289: PUSH
118290: LD_INT 21
118292: PUSH
118293: LD_INT 22
118295: PUSH
118296: LD_INT 23
118298: PUSH
118299: LD_INT 24
118301: PUSH
118302: LD_INT 25
118304: PUSH
118305: LD_INT 26
118307: PUSH
118308: LD_INT 27
118310: PUSH
118311: LD_INT 28
118313: PUSH
118314: LD_INT 29
118316: PUSH
118317: LD_INT 30
118319: PUSH
118320: LD_INT 31
118322: PUSH
118323: LD_INT 32
118325: PUSH
118326: LD_INT 33
118328: PUSH
118329: LD_INT 34
118331: PUSH
118332: LD_INT 35
118334: PUSH
118335: LD_INT 36
118337: PUSH
118338: EMPTY
118339: LIST
118340: LIST
118341: LIST
118342: LIST
118343: LIST
118344: LIST
118345: LIST
118346: LIST
118347: LIST
118348: LIST
118349: LIST
118350: LIST
118351: LIST
118352: LIST
118353: LIST
118354: LIST
118355: LIST
118356: LIST
118357: LIST
118358: LIST
118359: LIST
118360: LIST
118361: LIST
118362: LIST
118363: LIST
118364: LIST
118365: LIST
118366: LIST
118367: LIST
118368: LIST
118369: LIST
118370: LIST
118371: LIST
118372: LIST
118373: LIST
118374: LIST
118375: PUSH
118376: LD_INT 101
118378: PUSH
118379: LD_INT 102
118381: PUSH
118382: LD_INT 103
118384: PUSH
118385: LD_INT 104
118387: PUSH
118388: LD_INT 105
118390: PUSH
118391: LD_INT 106
118393: PUSH
118394: LD_INT 107
118396: PUSH
118397: LD_INT 108
118399: PUSH
118400: LD_INT 109
118402: PUSH
118403: LD_INT 110
118405: PUSH
118406: LD_INT 111
118408: PUSH
118409: LD_INT 112
118411: PUSH
118412: LD_INT 113
118414: PUSH
118415: LD_INT 114
118417: PUSH
118418: LD_INT 115
118420: PUSH
118421: LD_INT 116
118423: PUSH
118424: LD_INT 117
118426: PUSH
118427: LD_INT 118
118429: PUSH
118430: EMPTY
118431: LIST
118432: LIST
118433: LIST
118434: LIST
118435: LIST
118436: LIST
118437: LIST
118438: LIST
118439: LIST
118440: LIST
118441: LIST
118442: LIST
118443: LIST
118444: LIST
118445: LIST
118446: LIST
118447: LIST
118448: LIST
118449: PUSH
118450: EMPTY
118451: LIST
118452: LIST
118453: ST_TO_ADDR
// if result then
118454: LD_VAR 0 2
118458: IFFALSE 119244
// begin normal :=  ;
118460: LD_ADDR_VAR 0 5
118464: PUSH
118465: LD_STRING 
118467: ST_TO_ADDR
// hardcore :=  ;
118468: LD_ADDR_VAR 0 6
118472: PUSH
118473: LD_STRING 
118475: ST_TO_ADDR
// active :=  ;
118476: LD_ADDR_VAR 0 7
118480: PUSH
118481: LD_STRING 
118483: ST_TO_ADDR
// for i = 1 to normalCounter do
118484: LD_ADDR_VAR 0 8
118488: PUSH
118489: DOUBLE
118490: LD_INT 1
118492: DEC
118493: ST_TO_ADDR
118494: LD_EXP 149
118498: PUSH
118499: FOR_TO
118500: IFFALSE 118601
// begin tmp := 0 ;
118502: LD_ADDR_VAR 0 3
118506: PUSH
118507: LD_STRING 0
118509: ST_TO_ADDR
// if result [ 1 ] then
118510: LD_VAR 0 2
118514: PUSH
118515: LD_INT 1
118517: ARRAY
118518: IFFALSE 118583
// if result [ 1 ] [ 1 ] = i then
118520: LD_VAR 0 2
118524: PUSH
118525: LD_INT 1
118527: ARRAY
118528: PUSH
118529: LD_INT 1
118531: ARRAY
118532: PUSH
118533: LD_VAR 0 8
118537: EQUAL
118538: IFFALSE 118583
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
118540: LD_ADDR_VAR 0 2
118544: PUSH
118545: LD_VAR 0 2
118549: PPUSH
118550: LD_INT 1
118552: PPUSH
118553: LD_VAR 0 2
118557: PUSH
118558: LD_INT 1
118560: ARRAY
118561: PPUSH
118562: LD_INT 1
118564: PPUSH
118565: CALL_OW 3
118569: PPUSH
118570: CALL_OW 1
118574: ST_TO_ADDR
// tmp := 1 ;
118575: LD_ADDR_VAR 0 3
118579: PUSH
118580: LD_STRING 1
118582: ST_TO_ADDR
// end ; normal := normal & tmp ;
118583: LD_ADDR_VAR 0 5
118587: PUSH
118588: LD_VAR 0 5
118592: PUSH
118593: LD_VAR 0 3
118597: STR
118598: ST_TO_ADDR
// end ;
118599: GO 118499
118601: POP
118602: POP
// for i = 1 to hardcoreCounter do
118603: LD_ADDR_VAR 0 8
118607: PUSH
118608: DOUBLE
118609: LD_INT 1
118611: DEC
118612: ST_TO_ADDR
118613: LD_EXP 150
118617: PUSH
118618: FOR_TO
118619: IFFALSE 118724
// begin tmp := 0 ;
118621: LD_ADDR_VAR 0 3
118625: PUSH
118626: LD_STRING 0
118628: ST_TO_ADDR
// if result [ 2 ] then
118629: LD_VAR 0 2
118633: PUSH
118634: LD_INT 2
118636: ARRAY
118637: IFFALSE 118706
// if result [ 2 ] [ 1 ] = 100 + i then
118639: LD_VAR 0 2
118643: PUSH
118644: LD_INT 2
118646: ARRAY
118647: PUSH
118648: LD_INT 1
118650: ARRAY
118651: PUSH
118652: LD_INT 100
118654: PUSH
118655: LD_VAR 0 8
118659: PLUS
118660: EQUAL
118661: IFFALSE 118706
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
118663: LD_ADDR_VAR 0 2
118667: PUSH
118668: LD_VAR 0 2
118672: PPUSH
118673: LD_INT 2
118675: PPUSH
118676: LD_VAR 0 2
118680: PUSH
118681: LD_INT 2
118683: ARRAY
118684: PPUSH
118685: LD_INT 1
118687: PPUSH
118688: CALL_OW 3
118692: PPUSH
118693: CALL_OW 1
118697: ST_TO_ADDR
// tmp := 1 ;
118698: LD_ADDR_VAR 0 3
118702: PUSH
118703: LD_STRING 1
118705: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
118706: LD_ADDR_VAR 0 6
118710: PUSH
118711: LD_VAR 0 6
118715: PUSH
118716: LD_VAR 0 3
118720: STR
118721: ST_TO_ADDR
// end ;
118722: GO 118618
118724: POP
118725: POP
// if isGameLoad then
118726: LD_VAR 0 1
118730: IFFALSE 119205
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
118732: LD_ADDR_VAR 0 4
118736: PUSH
118737: LD_EXP 153
118741: PUSH
118742: LD_EXP 152
118746: PUSH
118747: LD_EXP 154
118751: PUSH
118752: LD_EXP 151
118756: PUSH
118757: LD_EXP 155
118761: PUSH
118762: LD_EXP 156
118766: PUSH
118767: LD_EXP 157
118771: PUSH
118772: LD_EXP 158
118776: PUSH
118777: LD_EXP 159
118781: PUSH
118782: LD_EXP 160
118786: PUSH
118787: LD_EXP 161
118791: PUSH
118792: LD_EXP 162
118796: PUSH
118797: LD_EXP 163
118801: PUSH
118802: LD_EXP 164
118806: PUSH
118807: LD_EXP 172
118811: PUSH
118812: LD_EXP 173
118816: PUSH
118817: LD_EXP 174
118821: PUSH
118822: LD_EXP 175
118826: PUSH
118827: LD_EXP 177
118831: PUSH
118832: LD_EXP 178
118836: PUSH
118837: LD_EXP 179
118841: PUSH
118842: LD_EXP 182
118846: PUSH
118847: LD_EXP 184
118851: PUSH
118852: LD_EXP 185
118856: PUSH
118857: LD_EXP 186
118861: PUSH
118862: LD_EXP 188
118866: PUSH
118867: LD_EXP 189
118871: PUSH
118872: LD_EXP 192
118876: PUSH
118877: LD_EXP 193
118881: PUSH
118882: LD_EXP 194
118886: PUSH
118887: LD_EXP 195
118891: PUSH
118892: LD_EXP 196
118896: PUSH
118897: LD_EXP 197
118901: PUSH
118902: LD_EXP 198
118906: PUSH
118907: LD_EXP 199
118911: PUSH
118912: LD_EXP 200
118916: PUSH
118917: LD_EXP 165
118921: PUSH
118922: LD_EXP 166
118926: PUSH
118927: LD_EXP 169
118931: PUSH
118932: LD_EXP 170
118936: PUSH
118937: LD_EXP 171
118941: PUSH
118942: LD_EXP 167
118946: PUSH
118947: LD_EXP 168
118951: PUSH
118952: LD_EXP 176
118956: PUSH
118957: LD_EXP 180
118961: PUSH
118962: LD_EXP 181
118966: PUSH
118967: LD_EXP 183
118971: PUSH
118972: LD_EXP 187
118976: PUSH
118977: LD_EXP 190
118981: PUSH
118982: LD_EXP 191
118986: PUSH
118987: LD_EXP 201
118991: PUSH
118992: LD_EXP 202
118996: PUSH
118997: LD_EXP 203
119001: PUSH
119002: LD_EXP 204
119006: PUSH
119007: EMPTY
119008: LIST
119009: LIST
119010: LIST
119011: LIST
119012: LIST
119013: LIST
119014: LIST
119015: LIST
119016: LIST
119017: LIST
119018: LIST
119019: LIST
119020: LIST
119021: LIST
119022: LIST
119023: LIST
119024: LIST
119025: LIST
119026: LIST
119027: LIST
119028: LIST
119029: LIST
119030: LIST
119031: LIST
119032: LIST
119033: LIST
119034: LIST
119035: LIST
119036: LIST
119037: LIST
119038: LIST
119039: LIST
119040: LIST
119041: LIST
119042: LIST
119043: LIST
119044: LIST
119045: LIST
119046: LIST
119047: LIST
119048: LIST
119049: LIST
119050: LIST
119051: LIST
119052: LIST
119053: LIST
119054: LIST
119055: LIST
119056: LIST
119057: LIST
119058: LIST
119059: LIST
119060: LIST
119061: LIST
119062: ST_TO_ADDR
// tmp :=  ;
119063: LD_ADDR_VAR 0 3
119067: PUSH
119068: LD_STRING 
119070: ST_TO_ADDR
// for i = 1 to normalCounter do
119071: LD_ADDR_VAR 0 8
119075: PUSH
119076: DOUBLE
119077: LD_INT 1
119079: DEC
119080: ST_TO_ADDR
119081: LD_EXP 149
119085: PUSH
119086: FOR_TO
119087: IFFALSE 119123
// begin if flags [ i ] then
119089: LD_VAR 0 4
119093: PUSH
119094: LD_VAR 0 8
119098: ARRAY
119099: IFFALSE 119121
// tmp := tmp & i & ; ;
119101: LD_ADDR_VAR 0 3
119105: PUSH
119106: LD_VAR 0 3
119110: PUSH
119111: LD_VAR 0 8
119115: STR
119116: PUSH
119117: LD_STRING ;
119119: STR
119120: ST_TO_ADDR
// end ;
119121: GO 119086
119123: POP
119124: POP
// for i = 1 to hardcoreCounter do
119125: LD_ADDR_VAR 0 8
119129: PUSH
119130: DOUBLE
119131: LD_INT 1
119133: DEC
119134: ST_TO_ADDR
119135: LD_EXP 150
119139: PUSH
119140: FOR_TO
119141: IFFALSE 119187
// begin if flags [ normalCounter + i ] then
119143: LD_VAR 0 4
119147: PUSH
119148: LD_EXP 149
119152: PUSH
119153: LD_VAR 0 8
119157: PLUS
119158: ARRAY
119159: IFFALSE 119185
// tmp := tmp & ( 100 + i ) & ; ;
119161: LD_ADDR_VAR 0 3
119165: PUSH
119166: LD_VAR 0 3
119170: PUSH
119171: LD_INT 100
119173: PUSH
119174: LD_VAR 0 8
119178: PLUS
119179: STR
119180: PUSH
119181: LD_STRING ;
119183: STR
119184: ST_TO_ADDR
// end ;
119185: GO 119140
119187: POP
119188: POP
// if tmp then
119189: LD_VAR 0 3
119193: IFFALSE 119205
// active := tmp ;
119195: LD_ADDR_VAR 0 7
119199: PUSH
119200: LD_VAR 0 3
119204: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
119205: LD_STRING getStreamItemsFromMission("
119207: PUSH
119208: LD_VAR 0 5
119212: STR
119213: PUSH
119214: LD_STRING ","
119216: STR
119217: PUSH
119218: LD_VAR 0 6
119222: STR
119223: PUSH
119224: LD_STRING ","
119226: STR
119227: PUSH
119228: LD_VAR 0 7
119232: STR
119233: PUSH
119234: LD_STRING ")
119236: STR
119237: PPUSH
119238: CALL_OW 559
// end else
119242: GO 119251
// ToLua ( getStreamItemsFromMission("","","") ) ;
119244: LD_STRING getStreamItemsFromMission("","","")
119246: PPUSH
119247: CALL_OW 559
// end ;
119251: LD_VAR 0 2
119255: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
119256: LD_EXP 148
119260: PUSH
119261: LD_EXP 153
119265: AND
119266: IFFALSE 119390
119268: GO 119270
119270: DISABLE
119271: LD_INT 0
119273: PPUSH
119274: PPUSH
// begin enable ;
119275: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
119276: LD_ADDR_VAR 0 2
119280: PUSH
119281: LD_INT 22
119283: PUSH
119284: LD_OWVAR 2
119288: PUSH
119289: EMPTY
119290: LIST
119291: LIST
119292: PUSH
119293: LD_INT 2
119295: PUSH
119296: LD_INT 34
119298: PUSH
119299: LD_INT 7
119301: PUSH
119302: EMPTY
119303: LIST
119304: LIST
119305: PUSH
119306: LD_INT 34
119308: PUSH
119309: LD_INT 45
119311: PUSH
119312: EMPTY
119313: LIST
119314: LIST
119315: PUSH
119316: LD_INT 34
119318: PUSH
119319: LD_INT 28
119321: PUSH
119322: EMPTY
119323: LIST
119324: LIST
119325: PUSH
119326: LD_INT 34
119328: PUSH
119329: LD_INT 47
119331: PUSH
119332: EMPTY
119333: LIST
119334: LIST
119335: PUSH
119336: EMPTY
119337: LIST
119338: LIST
119339: LIST
119340: LIST
119341: LIST
119342: PUSH
119343: EMPTY
119344: LIST
119345: LIST
119346: PPUSH
119347: CALL_OW 69
119351: ST_TO_ADDR
// if not tmp then
119352: LD_VAR 0 2
119356: NOT
119357: IFFALSE 119361
// exit ;
119359: GO 119390
// for i in tmp do
119361: LD_ADDR_VAR 0 1
119365: PUSH
119366: LD_VAR 0 2
119370: PUSH
119371: FOR_IN
119372: IFFALSE 119388
// begin SetLives ( i , 0 ) ;
119374: LD_VAR 0 1
119378: PPUSH
119379: LD_INT 0
119381: PPUSH
119382: CALL_OW 234
// end ;
119386: GO 119371
119388: POP
119389: POP
// end ;
119390: PPOPN 2
119392: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
119393: LD_EXP 148
119397: PUSH
119398: LD_EXP 154
119402: AND
119403: IFFALSE 119487
119405: GO 119407
119407: DISABLE
119408: LD_INT 0
119410: PPUSH
119411: PPUSH
// begin enable ;
119412: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
119413: LD_ADDR_VAR 0 2
119417: PUSH
119418: LD_INT 22
119420: PUSH
119421: LD_OWVAR 2
119425: PUSH
119426: EMPTY
119427: LIST
119428: LIST
119429: PUSH
119430: LD_INT 32
119432: PUSH
119433: LD_INT 3
119435: PUSH
119436: EMPTY
119437: LIST
119438: LIST
119439: PUSH
119440: EMPTY
119441: LIST
119442: LIST
119443: PPUSH
119444: CALL_OW 69
119448: ST_TO_ADDR
// if not tmp then
119449: LD_VAR 0 2
119453: NOT
119454: IFFALSE 119458
// exit ;
119456: GO 119487
// for i in tmp do
119458: LD_ADDR_VAR 0 1
119462: PUSH
119463: LD_VAR 0 2
119467: PUSH
119468: FOR_IN
119469: IFFALSE 119485
// begin SetLives ( i , 0 ) ;
119471: LD_VAR 0 1
119475: PPUSH
119476: LD_INT 0
119478: PPUSH
119479: CALL_OW 234
// end ;
119483: GO 119468
119485: POP
119486: POP
// end ;
119487: PPOPN 2
119489: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
119490: LD_EXP 148
119494: PUSH
119495: LD_EXP 151
119499: AND
119500: IFFALSE 119593
119502: GO 119504
119504: DISABLE
119505: LD_INT 0
119507: PPUSH
// begin enable ;
119508: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
119509: LD_ADDR_VAR 0 1
119513: PUSH
119514: LD_INT 22
119516: PUSH
119517: LD_OWVAR 2
119521: PUSH
119522: EMPTY
119523: LIST
119524: LIST
119525: PUSH
119526: LD_INT 2
119528: PUSH
119529: LD_INT 25
119531: PUSH
119532: LD_INT 5
119534: PUSH
119535: EMPTY
119536: LIST
119537: LIST
119538: PUSH
119539: LD_INT 25
119541: PUSH
119542: LD_INT 9
119544: PUSH
119545: EMPTY
119546: LIST
119547: LIST
119548: PUSH
119549: LD_INT 25
119551: PUSH
119552: LD_INT 8
119554: PUSH
119555: EMPTY
119556: LIST
119557: LIST
119558: PUSH
119559: EMPTY
119560: LIST
119561: LIST
119562: LIST
119563: LIST
119564: PUSH
119565: EMPTY
119566: LIST
119567: LIST
119568: PPUSH
119569: CALL_OW 69
119573: PUSH
119574: FOR_IN
119575: IFFALSE 119591
// begin SetClass ( i , 1 ) ;
119577: LD_VAR 0 1
119581: PPUSH
119582: LD_INT 1
119584: PPUSH
119585: CALL_OW 336
// end ;
119589: GO 119574
119591: POP
119592: POP
// end ;
119593: PPOPN 1
119595: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
119596: LD_EXP 148
119600: PUSH
119601: LD_EXP 152
119605: AND
119606: PUSH
119607: LD_OWVAR 65
119611: PUSH
119612: LD_INT 7
119614: LESS
119615: AND
119616: IFFALSE 119630
119618: GO 119620
119620: DISABLE
// begin enable ;
119621: ENABLE
// game_speed := 7 ;
119622: LD_ADDR_OWVAR 65
119626: PUSH
119627: LD_INT 7
119629: ST_TO_ADDR
// end ;
119630: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
119631: LD_EXP 148
119635: PUSH
119636: LD_EXP 155
119640: AND
119641: IFFALSE 119843
119643: GO 119645
119645: DISABLE
119646: LD_INT 0
119648: PPUSH
119649: PPUSH
119650: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
119651: LD_ADDR_VAR 0 3
119655: PUSH
119656: LD_INT 81
119658: PUSH
119659: LD_OWVAR 2
119663: PUSH
119664: EMPTY
119665: LIST
119666: LIST
119667: PUSH
119668: LD_INT 21
119670: PUSH
119671: LD_INT 1
119673: PUSH
119674: EMPTY
119675: LIST
119676: LIST
119677: PUSH
119678: EMPTY
119679: LIST
119680: LIST
119681: PPUSH
119682: CALL_OW 69
119686: ST_TO_ADDR
// if not tmp then
119687: LD_VAR 0 3
119691: NOT
119692: IFFALSE 119696
// exit ;
119694: GO 119843
// if tmp > 5 then
119696: LD_VAR 0 3
119700: PUSH
119701: LD_INT 5
119703: GREATER
119704: IFFALSE 119716
// k := 5 else
119706: LD_ADDR_VAR 0 2
119710: PUSH
119711: LD_INT 5
119713: ST_TO_ADDR
119714: GO 119726
// k := tmp ;
119716: LD_ADDR_VAR 0 2
119720: PUSH
119721: LD_VAR 0 3
119725: ST_TO_ADDR
// for i := 1 to k do
119726: LD_ADDR_VAR 0 1
119730: PUSH
119731: DOUBLE
119732: LD_INT 1
119734: DEC
119735: ST_TO_ADDR
119736: LD_VAR 0 2
119740: PUSH
119741: FOR_TO
119742: IFFALSE 119841
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
119744: LD_VAR 0 3
119748: PUSH
119749: LD_VAR 0 1
119753: ARRAY
119754: PPUSH
119755: LD_VAR 0 1
119759: PUSH
119760: LD_INT 4
119762: MOD
119763: PUSH
119764: LD_INT 1
119766: PLUS
119767: PPUSH
119768: CALL_OW 259
119772: PUSH
119773: LD_INT 10
119775: LESS
119776: IFFALSE 119839
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
119778: LD_VAR 0 3
119782: PUSH
119783: LD_VAR 0 1
119787: ARRAY
119788: PPUSH
119789: LD_VAR 0 1
119793: PUSH
119794: LD_INT 4
119796: MOD
119797: PUSH
119798: LD_INT 1
119800: PLUS
119801: PPUSH
119802: LD_VAR 0 3
119806: PUSH
119807: LD_VAR 0 1
119811: ARRAY
119812: PPUSH
119813: LD_VAR 0 1
119817: PUSH
119818: LD_INT 4
119820: MOD
119821: PUSH
119822: LD_INT 1
119824: PLUS
119825: PPUSH
119826: CALL_OW 259
119830: PUSH
119831: LD_INT 1
119833: PLUS
119834: PPUSH
119835: CALL_OW 237
119839: GO 119741
119841: POP
119842: POP
// end ;
119843: PPOPN 3
119845: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
119846: LD_EXP 148
119850: PUSH
119851: LD_EXP 156
119855: AND
119856: IFFALSE 119876
119858: GO 119860
119860: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
119861: LD_INT 4
119863: PPUSH
119864: LD_OWVAR 2
119868: PPUSH
119869: LD_INT 0
119871: PPUSH
119872: CALL_OW 324
119876: END
// every 0 0$1 trigger StreamModeActive and sShovel do
119877: LD_EXP 148
119881: PUSH
119882: LD_EXP 185
119886: AND
119887: IFFALSE 119907
119889: GO 119891
119891: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
119892: LD_INT 19
119894: PPUSH
119895: LD_OWVAR 2
119899: PPUSH
119900: LD_INT 0
119902: PPUSH
119903: CALL_OW 324
119907: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
119908: LD_EXP 148
119912: PUSH
119913: LD_EXP 157
119917: AND
119918: IFFALSE 120020
119920: GO 119922
119922: DISABLE
119923: LD_INT 0
119925: PPUSH
119926: PPUSH
// begin enable ;
119927: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
119928: LD_ADDR_VAR 0 2
119932: PUSH
119933: LD_INT 22
119935: PUSH
119936: LD_OWVAR 2
119940: PUSH
119941: EMPTY
119942: LIST
119943: LIST
119944: PUSH
119945: LD_INT 2
119947: PUSH
119948: LD_INT 34
119950: PUSH
119951: LD_INT 11
119953: PUSH
119954: EMPTY
119955: LIST
119956: LIST
119957: PUSH
119958: LD_INT 34
119960: PUSH
119961: LD_INT 30
119963: PUSH
119964: EMPTY
119965: LIST
119966: LIST
119967: PUSH
119968: EMPTY
119969: LIST
119970: LIST
119971: LIST
119972: PUSH
119973: EMPTY
119974: LIST
119975: LIST
119976: PPUSH
119977: CALL_OW 69
119981: ST_TO_ADDR
// if not tmp then
119982: LD_VAR 0 2
119986: NOT
119987: IFFALSE 119991
// exit ;
119989: GO 120020
// for i in tmp do
119991: LD_ADDR_VAR 0 1
119995: PUSH
119996: LD_VAR 0 2
120000: PUSH
120001: FOR_IN
120002: IFFALSE 120018
// begin SetLives ( i , 0 ) ;
120004: LD_VAR 0 1
120008: PPUSH
120009: LD_INT 0
120011: PPUSH
120012: CALL_OW 234
// end ;
120016: GO 120001
120018: POP
120019: POP
// end ;
120020: PPOPN 2
120022: END
// every 0 0$1 trigger StreamModeActive and sBunker do
120023: LD_EXP 148
120027: PUSH
120028: LD_EXP 158
120032: AND
120033: IFFALSE 120053
120035: GO 120037
120037: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
120038: LD_INT 32
120040: PPUSH
120041: LD_OWVAR 2
120045: PPUSH
120046: LD_INT 0
120048: PPUSH
120049: CALL_OW 324
120053: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
120054: LD_EXP 148
120058: PUSH
120059: LD_EXP 159
120063: AND
120064: IFFALSE 120245
120066: GO 120068
120068: DISABLE
120069: LD_INT 0
120071: PPUSH
120072: PPUSH
120073: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
120074: LD_ADDR_VAR 0 2
120078: PUSH
120079: LD_INT 22
120081: PUSH
120082: LD_OWVAR 2
120086: PUSH
120087: EMPTY
120088: LIST
120089: LIST
120090: PUSH
120091: LD_INT 33
120093: PUSH
120094: LD_INT 3
120096: PUSH
120097: EMPTY
120098: LIST
120099: LIST
120100: PUSH
120101: EMPTY
120102: LIST
120103: LIST
120104: PPUSH
120105: CALL_OW 69
120109: ST_TO_ADDR
// if not tmp then
120110: LD_VAR 0 2
120114: NOT
120115: IFFALSE 120119
// exit ;
120117: GO 120245
// side := 0 ;
120119: LD_ADDR_VAR 0 3
120123: PUSH
120124: LD_INT 0
120126: ST_TO_ADDR
// for i := 1 to 8 do
120127: LD_ADDR_VAR 0 1
120131: PUSH
120132: DOUBLE
120133: LD_INT 1
120135: DEC
120136: ST_TO_ADDR
120137: LD_INT 8
120139: PUSH
120140: FOR_TO
120141: IFFALSE 120189
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
120143: LD_OWVAR 2
120147: PUSH
120148: LD_VAR 0 1
120152: NONEQUAL
120153: PUSH
120154: LD_OWVAR 2
120158: PPUSH
120159: LD_VAR 0 1
120163: PPUSH
120164: CALL_OW 81
120168: PUSH
120169: LD_INT 2
120171: EQUAL
120172: AND
120173: IFFALSE 120187
// begin side := i ;
120175: LD_ADDR_VAR 0 3
120179: PUSH
120180: LD_VAR 0 1
120184: ST_TO_ADDR
// break ;
120185: GO 120189
// end ;
120187: GO 120140
120189: POP
120190: POP
// if not side then
120191: LD_VAR 0 3
120195: NOT
120196: IFFALSE 120200
// exit ;
120198: GO 120245
// for i := 1 to tmp do
120200: LD_ADDR_VAR 0 1
120204: PUSH
120205: DOUBLE
120206: LD_INT 1
120208: DEC
120209: ST_TO_ADDR
120210: LD_VAR 0 2
120214: PUSH
120215: FOR_TO
120216: IFFALSE 120243
// if Prob ( 60 ) then
120218: LD_INT 60
120220: PPUSH
120221: CALL_OW 13
120225: IFFALSE 120241
// SetSide ( i , side ) ;
120227: LD_VAR 0 1
120231: PPUSH
120232: LD_VAR 0 3
120236: PPUSH
120237: CALL_OW 235
120241: GO 120215
120243: POP
120244: POP
// end ;
120245: PPOPN 3
120247: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
120248: LD_EXP 148
120252: PUSH
120253: LD_EXP 161
120257: AND
120258: IFFALSE 120377
120260: GO 120262
120262: DISABLE
120263: LD_INT 0
120265: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
120266: LD_ADDR_VAR 0 1
120270: PUSH
120271: LD_INT 22
120273: PUSH
120274: LD_OWVAR 2
120278: PUSH
120279: EMPTY
120280: LIST
120281: LIST
120282: PUSH
120283: LD_INT 21
120285: PUSH
120286: LD_INT 1
120288: PUSH
120289: EMPTY
120290: LIST
120291: LIST
120292: PUSH
120293: LD_INT 3
120295: PUSH
120296: LD_INT 23
120298: PUSH
120299: LD_INT 0
120301: PUSH
120302: EMPTY
120303: LIST
120304: LIST
120305: PUSH
120306: EMPTY
120307: LIST
120308: LIST
120309: PUSH
120310: EMPTY
120311: LIST
120312: LIST
120313: LIST
120314: PPUSH
120315: CALL_OW 69
120319: PUSH
120320: FOR_IN
120321: IFFALSE 120375
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
120323: LD_VAR 0 1
120327: PPUSH
120328: CALL_OW 257
120332: PUSH
120333: LD_INT 1
120335: PUSH
120336: LD_INT 2
120338: PUSH
120339: LD_INT 3
120341: PUSH
120342: LD_INT 4
120344: PUSH
120345: EMPTY
120346: LIST
120347: LIST
120348: LIST
120349: LIST
120350: IN
120351: IFFALSE 120373
// SetClass ( un , rand ( 1 , 4 ) ) ;
120353: LD_VAR 0 1
120357: PPUSH
120358: LD_INT 1
120360: PPUSH
120361: LD_INT 4
120363: PPUSH
120364: CALL_OW 12
120368: PPUSH
120369: CALL_OW 336
120373: GO 120320
120375: POP
120376: POP
// end ;
120377: PPOPN 1
120379: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
120380: LD_EXP 148
120384: PUSH
120385: LD_EXP 160
120389: AND
120390: IFFALSE 120469
120392: GO 120394
120394: DISABLE
120395: LD_INT 0
120397: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
120398: LD_ADDR_VAR 0 1
120402: PUSH
120403: LD_INT 22
120405: PUSH
120406: LD_OWVAR 2
120410: PUSH
120411: EMPTY
120412: LIST
120413: LIST
120414: PUSH
120415: LD_INT 21
120417: PUSH
120418: LD_INT 3
120420: PUSH
120421: EMPTY
120422: LIST
120423: LIST
120424: PUSH
120425: EMPTY
120426: LIST
120427: LIST
120428: PPUSH
120429: CALL_OW 69
120433: ST_TO_ADDR
// if not tmp then
120434: LD_VAR 0 1
120438: NOT
120439: IFFALSE 120443
// exit ;
120441: GO 120469
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
120443: LD_VAR 0 1
120447: PUSH
120448: LD_INT 1
120450: PPUSH
120451: LD_VAR 0 1
120455: PPUSH
120456: CALL_OW 12
120460: ARRAY
120461: PPUSH
120462: LD_INT 100
120464: PPUSH
120465: CALL_OW 234
// end ;
120469: PPOPN 1
120471: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
120472: LD_EXP 148
120476: PUSH
120477: LD_EXP 162
120481: AND
120482: IFFALSE 120580
120484: GO 120486
120486: DISABLE
120487: LD_INT 0
120489: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
120490: LD_ADDR_VAR 0 1
120494: PUSH
120495: LD_INT 22
120497: PUSH
120498: LD_OWVAR 2
120502: PUSH
120503: EMPTY
120504: LIST
120505: LIST
120506: PUSH
120507: LD_INT 21
120509: PUSH
120510: LD_INT 1
120512: PUSH
120513: EMPTY
120514: LIST
120515: LIST
120516: PUSH
120517: EMPTY
120518: LIST
120519: LIST
120520: PPUSH
120521: CALL_OW 69
120525: ST_TO_ADDR
// if not tmp then
120526: LD_VAR 0 1
120530: NOT
120531: IFFALSE 120535
// exit ;
120533: GO 120580
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
120535: LD_VAR 0 1
120539: PUSH
120540: LD_INT 1
120542: PPUSH
120543: LD_VAR 0 1
120547: PPUSH
120548: CALL_OW 12
120552: ARRAY
120553: PPUSH
120554: LD_INT 1
120556: PPUSH
120557: LD_INT 4
120559: PPUSH
120560: CALL_OW 12
120564: PPUSH
120565: LD_INT 3000
120567: PPUSH
120568: LD_INT 9000
120570: PPUSH
120571: CALL_OW 12
120575: PPUSH
120576: CALL_OW 492
// end ;
120580: PPOPN 1
120582: END
// every 0 0$1 trigger StreamModeActive and sDepot do
120583: LD_EXP 148
120587: PUSH
120588: LD_EXP 163
120592: AND
120593: IFFALSE 120613
120595: GO 120597
120597: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
120598: LD_INT 1
120600: PPUSH
120601: LD_OWVAR 2
120605: PPUSH
120606: LD_INT 0
120608: PPUSH
120609: CALL_OW 324
120613: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
120614: LD_EXP 148
120618: PUSH
120619: LD_EXP 164
120623: AND
120624: IFFALSE 120707
120626: GO 120628
120628: DISABLE
120629: LD_INT 0
120631: PPUSH
120632: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
120633: LD_ADDR_VAR 0 2
120637: PUSH
120638: LD_INT 22
120640: PUSH
120641: LD_OWVAR 2
120645: PUSH
120646: EMPTY
120647: LIST
120648: LIST
120649: PUSH
120650: LD_INT 21
120652: PUSH
120653: LD_INT 3
120655: PUSH
120656: EMPTY
120657: LIST
120658: LIST
120659: PUSH
120660: EMPTY
120661: LIST
120662: LIST
120663: PPUSH
120664: CALL_OW 69
120668: ST_TO_ADDR
// if not tmp then
120669: LD_VAR 0 2
120673: NOT
120674: IFFALSE 120678
// exit ;
120676: GO 120707
// for i in tmp do
120678: LD_ADDR_VAR 0 1
120682: PUSH
120683: LD_VAR 0 2
120687: PUSH
120688: FOR_IN
120689: IFFALSE 120705
// SetBLevel ( i , 10 ) ;
120691: LD_VAR 0 1
120695: PPUSH
120696: LD_INT 10
120698: PPUSH
120699: CALL_OW 241
120703: GO 120688
120705: POP
120706: POP
// end ;
120707: PPOPN 2
120709: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
120710: LD_EXP 148
120714: PUSH
120715: LD_EXP 165
120719: AND
120720: IFFALSE 120831
120722: GO 120724
120724: DISABLE
120725: LD_INT 0
120727: PPUSH
120728: PPUSH
120729: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
120730: LD_ADDR_VAR 0 3
120734: PUSH
120735: LD_INT 22
120737: PUSH
120738: LD_OWVAR 2
120742: PUSH
120743: EMPTY
120744: LIST
120745: LIST
120746: PUSH
120747: LD_INT 25
120749: PUSH
120750: LD_INT 1
120752: PUSH
120753: EMPTY
120754: LIST
120755: LIST
120756: PUSH
120757: EMPTY
120758: LIST
120759: LIST
120760: PPUSH
120761: CALL_OW 69
120765: ST_TO_ADDR
// if not tmp then
120766: LD_VAR 0 3
120770: NOT
120771: IFFALSE 120775
// exit ;
120773: GO 120831
// un := tmp [ rand ( 1 , tmp ) ] ;
120775: LD_ADDR_VAR 0 2
120779: PUSH
120780: LD_VAR 0 3
120784: PUSH
120785: LD_INT 1
120787: PPUSH
120788: LD_VAR 0 3
120792: PPUSH
120793: CALL_OW 12
120797: ARRAY
120798: ST_TO_ADDR
// if Crawls ( un ) then
120799: LD_VAR 0 2
120803: PPUSH
120804: CALL_OW 318
120808: IFFALSE 120819
// ComWalk ( un ) ;
120810: LD_VAR 0 2
120814: PPUSH
120815: CALL_OW 138
// SetClass ( un , class_sniper ) ;
120819: LD_VAR 0 2
120823: PPUSH
120824: LD_INT 5
120826: PPUSH
120827: CALL_OW 336
// end ;
120831: PPOPN 3
120833: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
120834: LD_EXP 148
120838: PUSH
120839: LD_EXP 166
120843: AND
120844: PUSH
120845: LD_OWVAR 67
120849: PUSH
120850: LD_INT 4
120852: LESS
120853: AND
120854: IFFALSE 120873
120856: GO 120858
120858: DISABLE
// begin Difficulty := Difficulty + 1 ;
120859: LD_ADDR_OWVAR 67
120863: PUSH
120864: LD_OWVAR 67
120868: PUSH
120869: LD_INT 1
120871: PLUS
120872: ST_TO_ADDR
// end ;
120873: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
120874: LD_EXP 148
120878: PUSH
120879: LD_EXP 167
120883: AND
120884: IFFALSE 120987
120886: GO 120888
120888: DISABLE
120889: LD_INT 0
120891: PPUSH
// begin for i := 1 to 5 do
120892: LD_ADDR_VAR 0 1
120896: PUSH
120897: DOUBLE
120898: LD_INT 1
120900: DEC
120901: ST_TO_ADDR
120902: LD_INT 5
120904: PUSH
120905: FOR_TO
120906: IFFALSE 120985
// begin uc_nation := nation_nature ;
120908: LD_ADDR_OWVAR 21
120912: PUSH
120913: LD_INT 0
120915: ST_TO_ADDR
// uc_side := 0 ;
120916: LD_ADDR_OWVAR 20
120920: PUSH
120921: LD_INT 0
120923: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
120924: LD_ADDR_OWVAR 29
120928: PUSH
120929: LD_INT 12
120931: PUSH
120932: LD_INT 12
120934: PUSH
120935: EMPTY
120936: LIST
120937: LIST
120938: ST_TO_ADDR
// hc_agressivity := 20 ;
120939: LD_ADDR_OWVAR 35
120943: PUSH
120944: LD_INT 20
120946: ST_TO_ADDR
// hc_class := class_tiger ;
120947: LD_ADDR_OWVAR 28
120951: PUSH
120952: LD_INT 14
120954: ST_TO_ADDR
// hc_gallery :=  ;
120955: LD_ADDR_OWVAR 33
120959: PUSH
120960: LD_STRING 
120962: ST_TO_ADDR
// hc_name :=  ;
120963: LD_ADDR_OWVAR 26
120967: PUSH
120968: LD_STRING 
120970: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
120971: CALL_OW 44
120975: PPUSH
120976: LD_INT 0
120978: PPUSH
120979: CALL_OW 51
// end ;
120983: GO 120905
120985: POP
120986: POP
// end ;
120987: PPOPN 1
120989: END
// every 0 0$1 trigger StreamModeActive and sBomb do
120990: LD_EXP 148
120994: PUSH
120995: LD_EXP 168
120999: AND
121000: IFFALSE 121009
121002: GO 121004
121004: DISABLE
// StreamSibBomb ;
121005: CALL 121010 0 0
121009: END
// export function StreamSibBomb ; var i , x , y ; begin
121010: LD_INT 0
121012: PPUSH
121013: PPUSH
121014: PPUSH
121015: PPUSH
// result := false ;
121016: LD_ADDR_VAR 0 1
121020: PUSH
121021: LD_INT 0
121023: ST_TO_ADDR
// for i := 1 to 16 do
121024: LD_ADDR_VAR 0 2
121028: PUSH
121029: DOUBLE
121030: LD_INT 1
121032: DEC
121033: ST_TO_ADDR
121034: LD_INT 16
121036: PUSH
121037: FOR_TO
121038: IFFALSE 121237
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
121040: LD_ADDR_VAR 0 3
121044: PUSH
121045: LD_INT 10
121047: PUSH
121048: LD_INT 20
121050: PUSH
121051: LD_INT 30
121053: PUSH
121054: LD_INT 40
121056: PUSH
121057: LD_INT 50
121059: PUSH
121060: LD_INT 60
121062: PUSH
121063: LD_INT 70
121065: PUSH
121066: LD_INT 80
121068: PUSH
121069: LD_INT 90
121071: PUSH
121072: LD_INT 100
121074: PUSH
121075: LD_INT 110
121077: PUSH
121078: LD_INT 120
121080: PUSH
121081: LD_INT 130
121083: PUSH
121084: LD_INT 140
121086: PUSH
121087: LD_INT 150
121089: PUSH
121090: EMPTY
121091: LIST
121092: LIST
121093: LIST
121094: LIST
121095: LIST
121096: LIST
121097: LIST
121098: LIST
121099: LIST
121100: LIST
121101: LIST
121102: LIST
121103: LIST
121104: LIST
121105: LIST
121106: PUSH
121107: LD_INT 1
121109: PPUSH
121110: LD_INT 15
121112: PPUSH
121113: CALL_OW 12
121117: ARRAY
121118: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
121119: LD_ADDR_VAR 0 4
121123: PUSH
121124: LD_INT 10
121126: PUSH
121127: LD_INT 20
121129: PUSH
121130: LD_INT 30
121132: PUSH
121133: LD_INT 40
121135: PUSH
121136: LD_INT 50
121138: PUSH
121139: LD_INT 60
121141: PUSH
121142: LD_INT 70
121144: PUSH
121145: LD_INT 80
121147: PUSH
121148: LD_INT 90
121150: PUSH
121151: LD_INT 100
121153: PUSH
121154: LD_INT 110
121156: PUSH
121157: LD_INT 120
121159: PUSH
121160: LD_INT 130
121162: PUSH
121163: LD_INT 140
121165: PUSH
121166: LD_INT 150
121168: PUSH
121169: EMPTY
121170: LIST
121171: LIST
121172: LIST
121173: LIST
121174: LIST
121175: LIST
121176: LIST
121177: LIST
121178: LIST
121179: LIST
121180: LIST
121181: LIST
121182: LIST
121183: LIST
121184: LIST
121185: PUSH
121186: LD_INT 1
121188: PPUSH
121189: LD_INT 15
121191: PPUSH
121192: CALL_OW 12
121196: ARRAY
121197: ST_TO_ADDR
// if ValidHex ( x , y ) then
121198: LD_VAR 0 3
121202: PPUSH
121203: LD_VAR 0 4
121207: PPUSH
121208: CALL_OW 488
121212: IFFALSE 121235
// begin result := [ x , y ] ;
121214: LD_ADDR_VAR 0 1
121218: PUSH
121219: LD_VAR 0 3
121223: PUSH
121224: LD_VAR 0 4
121228: PUSH
121229: EMPTY
121230: LIST
121231: LIST
121232: ST_TO_ADDR
// break ;
121233: GO 121237
// end ; end ;
121235: GO 121037
121237: POP
121238: POP
// if result then
121239: LD_VAR 0 1
121243: IFFALSE 121303
// begin ToLua ( playSibBomb() ) ;
121245: LD_STRING playSibBomb()
121247: PPUSH
121248: CALL_OW 559
// wait ( 0 0$14 ) ;
121252: LD_INT 490
121254: PPUSH
121255: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
121259: LD_VAR 0 1
121263: PUSH
121264: LD_INT 1
121266: ARRAY
121267: PPUSH
121268: LD_VAR 0 1
121272: PUSH
121273: LD_INT 2
121275: ARRAY
121276: PPUSH
121277: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
121281: LD_VAR 0 1
121285: PUSH
121286: LD_INT 1
121288: ARRAY
121289: PPUSH
121290: LD_VAR 0 1
121294: PUSH
121295: LD_INT 2
121297: ARRAY
121298: PPUSH
121299: CALL_OW 429
// end ; end ;
121303: LD_VAR 0 1
121307: RET
// every 0 0$1 trigger StreamModeActive and sReset do
121308: LD_EXP 148
121312: PUSH
121313: LD_EXP 170
121317: AND
121318: IFFALSE 121330
121320: GO 121322
121322: DISABLE
// YouLost (  ) ;
121323: LD_STRING 
121325: PPUSH
121326: CALL_OW 104
121330: END
// every 0 0$1 trigger StreamModeActive and sFog do
121331: LD_EXP 148
121335: PUSH
121336: LD_EXP 169
121340: AND
121341: IFFALSE 121355
121343: GO 121345
121345: DISABLE
// FogOff ( your_side ) ;
121346: LD_OWVAR 2
121350: PPUSH
121351: CALL_OW 344
121355: END
// every 0 0$1 trigger StreamModeActive and sSun do
121356: LD_EXP 148
121360: PUSH
121361: LD_EXP 171
121365: AND
121366: IFFALSE 121394
121368: GO 121370
121370: DISABLE
// begin solar_recharge_percent := 0 ;
121371: LD_ADDR_OWVAR 79
121375: PUSH
121376: LD_INT 0
121378: ST_TO_ADDR
// wait ( 5 5$00 ) ;
121379: LD_INT 10500
121381: PPUSH
121382: CALL_OW 67
// solar_recharge_percent := 100 ;
121386: LD_ADDR_OWVAR 79
121390: PUSH
121391: LD_INT 100
121393: ST_TO_ADDR
// end ;
121394: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
121395: LD_EXP 148
121399: PUSH
121400: LD_EXP 172
121404: AND
121405: IFFALSE 121644
121407: GO 121409
121409: DISABLE
121410: LD_INT 0
121412: PPUSH
121413: PPUSH
121414: PPUSH
// begin tmp := [ ] ;
121415: LD_ADDR_VAR 0 3
121419: PUSH
121420: EMPTY
121421: ST_TO_ADDR
// for i := 1 to 6 do
121422: LD_ADDR_VAR 0 1
121426: PUSH
121427: DOUBLE
121428: LD_INT 1
121430: DEC
121431: ST_TO_ADDR
121432: LD_INT 6
121434: PUSH
121435: FOR_TO
121436: IFFALSE 121541
// begin uc_nation := nation_nature ;
121438: LD_ADDR_OWVAR 21
121442: PUSH
121443: LD_INT 0
121445: ST_TO_ADDR
// uc_side := 0 ;
121446: LD_ADDR_OWVAR 20
121450: PUSH
121451: LD_INT 0
121453: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
121454: LD_ADDR_OWVAR 29
121458: PUSH
121459: LD_INT 12
121461: PUSH
121462: LD_INT 12
121464: PUSH
121465: EMPTY
121466: LIST
121467: LIST
121468: ST_TO_ADDR
// hc_agressivity := 20 ;
121469: LD_ADDR_OWVAR 35
121473: PUSH
121474: LD_INT 20
121476: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
121477: LD_ADDR_OWVAR 28
121481: PUSH
121482: LD_INT 17
121484: ST_TO_ADDR
// hc_gallery :=  ;
121485: LD_ADDR_OWVAR 33
121489: PUSH
121490: LD_STRING 
121492: ST_TO_ADDR
// hc_name :=  ;
121493: LD_ADDR_OWVAR 26
121497: PUSH
121498: LD_STRING 
121500: ST_TO_ADDR
// un := CreateHuman ;
121501: LD_ADDR_VAR 0 2
121505: PUSH
121506: CALL_OW 44
121510: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
121511: LD_VAR 0 2
121515: PPUSH
121516: LD_INT 1
121518: PPUSH
121519: CALL_OW 51
// tmp := tmp ^ un ;
121523: LD_ADDR_VAR 0 3
121527: PUSH
121528: LD_VAR 0 3
121532: PUSH
121533: LD_VAR 0 2
121537: ADD
121538: ST_TO_ADDR
// end ;
121539: GO 121435
121541: POP
121542: POP
// repeat wait ( 0 0$1 ) ;
121543: LD_INT 35
121545: PPUSH
121546: CALL_OW 67
// for un in tmp do
121550: LD_ADDR_VAR 0 2
121554: PUSH
121555: LD_VAR 0 3
121559: PUSH
121560: FOR_IN
121561: IFFALSE 121635
// begin if IsDead ( un ) then
121563: LD_VAR 0 2
121567: PPUSH
121568: CALL_OW 301
121572: IFFALSE 121592
// begin tmp := tmp diff un ;
121574: LD_ADDR_VAR 0 3
121578: PUSH
121579: LD_VAR 0 3
121583: PUSH
121584: LD_VAR 0 2
121588: DIFF
121589: ST_TO_ADDR
// continue ;
121590: GO 121560
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
121592: LD_VAR 0 2
121596: PPUSH
121597: LD_INT 3
121599: PUSH
121600: LD_INT 22
121602: PUSH
121603: LD_INT 0
121605: PUSH
121606: EMPTY
121607: LIST
121608: LIST
121609: PUSH
121610: EMPTY
121611: LIST
121612: LIST
121613: PPUSH
121614: CALL_OW 69
121618: PPUSH
121619: LD_VAR 0 2
121623: PPUSH
121624: CALL_OW 74
121628: PPUSH
121629: CALL_OW 115
// end ;
121633: GO 121560
121635: POP
121636: POP
// until not tmp ;
121637: LD_VAR 0 3
121641: NOT
121642: IFFALSE 121543
// end ;
121644: PPOPN 3
121646: END
// every 0 0$1 trigger StreamModeActive and sTroll do
121647: LD_EXP 148
121651: PUSH
121652: LD_EXP 173
121656: AND
121657: IFFALSE 121711
121659: GO 121661
121661: DISABLE
// begin ToLua ( displayTroll(); ) ;
121662: LD_STRING displayTroll();
121664: PPUSH
121665: CALL_OW 559
// wait ( 3 3$00 ) ;
121669: LD_INT 6300
121671: PPUSH
121672: CALL_OW 67
// ToLua ( hideTroll(); ) ;
121676: LD_STRING hideTroll();
121678: PPUSH
121679: CALL_OW 559
// wait ( 1 1$00 ) ;
121683: LD_INT 2100
121685: PPUSH
121686: CALL_OW 67
// ToLua ( displayTroll(); ) ;
121690: LD_STRING displayTroll();
121692: PPUSH
121693: CALL_OW 559
// wait ( 1 1$00 ) ;
121697: LD_INT 2100
121699: PPUSH
121700: CALL_OW 67
// ToLua ( hideTroll(); ) ;
121704: LD_STRING hideTroll();
121706: PPUSH
121707: CALL_OW 559
// end ;
121711: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
121712: LD_EXP 148
121716: PUSH
121717: LD_EXP 174
121721: AND
121722: IFFALSE 121785
121724: GO 121726
121726: DISABLE
121727: LD_INT 0
121729: PPUSH
// begin p := 0 ;
121730: LD_ADDR_VAR 0 1
121734: PUSH
121735: LD_INT 0
121737: ST_TO_ADDR
// repeat game_speed := 1 ;
121738: LD_ADDR_OWVAR 65
121742: PUSH
121743: LD_INT 1
121745: ST_TO_ADDR
// wait ( 0 0$1 ) ;
121746: LD_INT 35
121748: PPUSH
121749: CALL_OW 67
// p := p + 1 ;
121753: LD_ADDR_VAR 0 1
121757: PUSH
121758: LD_VAR 0 1
121762: PUSH
121763: LD_INT 1
121765: PLUS
121766: ST_TO_ADDR
// until p >= 60 ;
121767: LD_VAR 0 1
121771: PUSH
121772: LD_INT 60
121774: GREATEREQUAL
121775: IFFALSE 121738
// game_speed := 4 ;
121777: LD_ADDR_OWVAR 65
121781: PUSH
121782: LD_INT 4
121784: ST_TO_ADDR
// end ;
121785: PPOPN 1
121787: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
121788: LD_EXP 148
121792: PUSH
121793: LD_EXP 175
121797: AND
121798: IFFALSE 121944
121800: GO 121802
121802: DISABLE
121803: LD_INT 0
121805: PPUSH
121806: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
121807: LD_ADDR_VAR 0 1
121811: PUSH
121812: LD_INT 22
121814: PUSH
121815: LD_OWVAR 2
121819: PUSH
121820: EMPTY
121821: LIST
121822: LIST
121823: PUSH
121824: LD_INT 2
121826: PUSH
121827: LD_INT 30
121829: PUSH
121830: LD_INT 0
121832: PUSH
121833: EMPTY
121834: LIST
121835: LIST
121836: PUSH
121837: LD_INT 30
121839: PUSH
121840: LD_INT 1
121842: PUSH
121843: EMPTY
121844: LIST
121845: LIST
121846: PUSH
121847: EMPTY
121848: LIST
121849: LIST
121850: LIST
121851: PUSH
121852: EMPTY
121853: LIST
121854: LIST
121855: PPUSH
121856: CALL_OW 69
121860: ST_TO_ADDR
// if not depot then
121861: LD_VAR 0 1
121865: NOT
121866: IFFALSE 121870
// exit ;
121868: GO 121944
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
121870: LD_ADDR_VAR 0 2
121874: PUSH
121875: LD_VAR 0 1
121879: PUSH
121880: LD_INT 1
121882: PPUSH
121883: LD_VAR 0 1
121887: PPUSH
121888: CALL_OW 12
121892: ARRAY
121893: PPUSH
121894: CALL_OW 274
121898: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
121899: LD_VAR 0 2
121903: PPUSH
121904: LD_INT 1
121906: PPUSH
121907: LD_INT 0
121909: PPUSH
121910: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
121914: LD_VAR 0 2
121918: PPUSH
121919: LD_INT 2
121921: PPUSH
121922: LD_INT 0
121924: PPUSH
121925: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
121929: LD_VAR 0 2
121933: PPUSH
121934: LD_INT 3
121936: PPUSH
121937: LD_INT 0
121939: PPUSH
121940: CALL_OW 277
// end ;
121944: PPOPN 2
121946: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
121947: LD_EXP 148
121951: PUSH
121952: LD_EXP 176
121956: AND
121957: IFFALSE 122054
121959: GO 121961
121961: DISABLE
121962: LD_INT 0
121964: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
121965: LD_ADDR_VAR 0 1
121969: PUSH
121970: LD_INT 22
121972: PUSH
121973: LD_OWVAR 2
121977: PUSH
121978: EMPTY
121979: LIST
121980: LIST
121981: PUSH
121982: LD_INT 21
121984: PUSH
121985: LD_INT 1
121987: PUSH
121988: EMPTY
121989: LIST
121990: LIST
121991: PUSH
121992: LD_INT 3
121994: PUSH
121995: LD_INT 23
121997: PUSH
121998: LD_INT 0
122000: PUSH
122001: EMPTY
122002: LIST
122003: LIST
122004: PUSH
122005: EMPTY
122006: LIST
122007: LIST
122008: PUSH
122009: EMPTY
122010: LIST
122011: LIST
122012: LIST
122013: PPUSH
122014: CALL_OW 69
122018: ST_TO_ADDR
// if not tmp then
122019: LD_VAR 0 1
122023: NOT
122024: IFFALSE 122028
// exit ;
122026: GO 122054
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
122028: LD_VAR 0 1
122032: PUSH
122033: LD_INT 1
122035: PPUSH
122036: LD_VAR 0 1
122040: PPUSH
122041: CALL_OW 12
122045: ARRAY
122046: PPUSH
122047: LD_INT 200
122049: PPUSH
122050: CALL_OW 234
// end ;
122054: PPOPN 1
122056: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
122057: LD_EXP 148
122061: PUSH
122062: LD_EXP 177
122066: AND
122067: IFFALSE 122146
122069: GO 122071
122071: DISABLE
122072: LD_INT 0
122074: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
122075: LD_ADDR_VAR 0 1
122079: PUSH
122080: LD_INT 22
122082: PUSH
122083: LD_OWVAR 2
122087: PUSH
122088: EMPTY
122089: LIST
122090: LIST
122091: PUSH
122092: LD_INT 21
122094: PUSH
122095: LD_INT 2
122097: PUSH
122098: EMPTY
122099: LIST
122100: LIST
122101: PUSH
122102: EMPTY
122103: LIST
122104: LIST
122105: PPUSH
122106: CALL_OW 69
122110: ST_TO_ADDR
// if not tmp then
122111: LD_VAR 0 1
122115: NOT
122116: IFFALSE 122120
// exit ;
122118: GO 122146
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
122120: LD_VAR 0 1
122124: PUSH
122125: LD_INT 1
122127: PPUSH
122128: LD_VAR 0 1
122132: PPUSH
122133: CALL_OW 12
122137: ARRAY
122138: PPUSH
122139: LD_INT 60
122141: PPUSH
122142: CALL_OW 234
// end ;
122146: PPOPN 1
122148: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
122149: LD_EXP 148
122153: PUSH
122154: LD_EXP 178
122158: AND
122159: IFFALSE 122258
122161: GO 122163
122163: DISABLE
122164: LD_INT 0
122166: PPUSH
122167: PPUSH
// begin enable ;
122168: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
122169: LD_ADDR_VAR 0 1
122173: PUSH
122174: LD_INT 22
122176: PUSH
122177: LD_OWVAR 2
122181: PUSH
122182: EMPTY
122183: LIST
122184: LIST
122185: PUSH
122186: LD_INT 61
122188: PUSH
122189: EMPTY
122190: LIST
122191: PUSH
122192: LD_INT 33
122194: PUSH
122195: LD_INT 2
122197: PUSH
122198: EMPTY
122199: LIST
122200: LIST
122201: PUSH
122202: EMPTY
122203: LIST
122204: LIST
122205: LIST
122206: PPUSH
122207: CALL_OW 69
122211: ST_TO_ADDR
// if not tmp then
122212: LD_VAR 0 1
122216: NOT
122217: IFFALSE 122221
// exit ;
122219: GO 122258
// for i in tmp do
122221: LD_ADDR_VAR 0 2
122225: PUSH
122226: LD_VAR 0 1
122230: PUSH
122231: FOR_IN
122232: IFFALSE 122256
// if IsControledBy ( i ) then
122234: LD_VAR 0 2
122238: PPUSH
122239: CALL_OW 312
122243: IFFALSE 122254
// ComUnlink ( i ) ;
122245: LD_VAR 0 2
122249: PPUSH
122250: CALL_OW 136
122254: GO 122231
122256: POP
122257: POP
// end ;
122258: PPOPN 2
122260: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
122261: LD_EXP 148
122265: PUSH
122266: LD_EXP 179
122270: AND
122271: IFFALSE 122411
122273: GO 122275
122275: DISABLE
122276: LD_INT 0
122278: PPUSH
122279: PPUSH
// begin ToLua ( displayPowell(); ) ;
122280: LD_STRING displayPowell();
122282: PPUSH
122283: CALL_OW 559
// uc_side := 0 ;
122287: LD_ADDR_OWVAR 20
122291: PUSH
122292: LD_INT 0
122294: ST_TO_ADDR
// uc_nation := 2 ;
122295: LD_ADDR_OWVAR 21
122299: PUSH
122300: LD_INT 2
122302: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
122303: LD_ADDR_OWVAR 37
122307: PUSH
122308: LD_INT 14
122310: ST_TO_ADDR
// vc_engine := engine_siberite ;
122311: LD_ADDR_OWVAR 39
122315: PUSH
122316: LD_INT 3
122318: ST_TO_ADDR
// vc_control := control_apeman ;
122319: LD_ADDR_OWVAR 38
122323: PUSH
122324: LD_INT 5
122326: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
122327: LD_ADDR_OWVAR 40
122331: PUSH
122332: LD_INT 29
122334: ST_TO_ADDR
// un := CreateVehicle ;
122335: LD_ADDR_VAR 0 2
122339: PUSH
122340: CALL_OW 45
122344: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
122345: LD_VAR 0 2
122349: PPUSH
122350: LD_INT 1
122352: PPUSH
122353: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
122357: LD_INT 35
122359: PPUSH
122360: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
122364: LD_VAR 0 2
122368: PPUSH
122369: LD_INT 22
122371: PUSH
122372: LD_OWVAR 2
122376: PUSH
122377: EMPTY
122378: LIST
122379: LIST
122380: PPUSH
122381: CALL_OW 69
122385: PPUSH
122386: LD_VAR 0 2
122390: PPUSH
122391: CALL_OW 74
122395: PPUSH
122396: CALL_OW 115
// until IsDead ( un ) ;
122400: LD_VAR 0 2
122404: PPUSH
122405: CALL_OW 301
122409: IFFALSE 122357
// end ;
122411: PPOPN 2
122413: END
// every 0 0$1 trigger StreamModeActive and sStu do
122414: LD_EXP 148
122418: PUSH
122419: LD_EXP 187
122423: AND
122424: IFFALSE 122440
122426: GO 122428
122428: DISABLE
// begin ToLua ( displayStucuk(); ) ;
122429: LD_STRING displayStucuk();
122431: PPUSH
122432: CALL_OW 559
// ResetFog ;
122436: CALL_OW 335
// end ;
122440: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
122441: LD_EXP 148
122445: PUSH
122446: LD_EXP 180
122450: AND
122451: IFFALSE 122592
122453: GO 122455
122455: DISABLE
122456: LD_INT 0
122458: PPUSH
122459: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
122460: LD_ADDR_VAR 0 2
122464: PUSH
122465: LD_INT 22
122467: PUSH
122468: LD_OWVAR 2
122472: PUSH
122473: EMPTY
122474: LIST
122475: LIST
122476: PUSH
122477: LD_INT 21
122479: PUSH
122480: LD_INT 1
122482: PUSH
122483: EMPTY
122484: LIST
122485: LIST
122486: PUSH
122487: EMPTY
122488: LIST
122489: LIST
122490: PPUSH
122491: CALL_OW 69
122495: ST_TO_ADDR
// if not tmp then
122496: LD_VAR 0 2
122500: NOT
122501: IFFALSE 122505
// exit ;
122503: GO 122592
// un := tmp [ rand ( 1 , tmp ) ] ;
122505: LD_ADDR_VAR 0 1
122509: PUSH
122510: LD_VAR 0 2
122514: PUSH
122515: LD_INT 1
122517: PPUSH
122518: LD_VAR 0 2
122522: PPUSH
122523: CALL_OW 12
122527: ARRAY
122528: ST_TO_ADDR
// SetSide ( un , 0 ) ;
122529: LD_VAR 0 1
122533: PPUSH
122534: LD_INT 0
122536: PPUSH
122537: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
122541: LD_VAR 0 1
122545: PPUSH
122546: LD_OWVAR 3
122550: PUSH
122551: LD_VAR 0 1
122555: DIFF
122556: PPUSH
122557: LD_VAR 0 1
122561: PPUSH
122562: CALL_OW 74
122566: PPUSH
122567: CALL_OW 115
// wait ( 0 0$20 ) ;
122571: LD_INT 700
122573: PPUSH
122574: CALL_OW 67
// SetSide ( un , your_side ) ;
122578: LD_VAR 0 1
122582: PPUSH
122583: LD_OWVAR 2
122587: PPUSH
122588: CALL_OW 235
// end ;
122592: PPOPN 2
122594: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
122595: LD_EXP 148
122599: PUSH
122600: LD_EXP 181
122604: AND
122605: IFFALSE 122711
122607: GO 122609
122609: DISABLE
122610: LD_INT 0
122612: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
122613: LD_ADDR_VAR 0 1
122617: PUSH
122618: LD_INT 22
122620: PUSH
122621: LD_OWVAR 2
122625: PUSH
122626: EMPTY
122627: LIST
122628: LIST
122629: PUSH
122630: LD_INT 2
122632: PUSH
122633: LD_INT 30
122635: PUSH
122636: LD_INT 0
122638: PUSH
122639: EMPTY
122640: LIST
122641: LIST
122642: PUSH
122643: LD_INT 30
122645: PUSH
122646: LD_INT 1
122648: PUSH
122649: EMPTY
122650: LIST
122651: LIST
122652: PUSH
122653: EMPTY
122654: LIST
122655: LIST
122656: LIST
122657: PUSH
122658: EMPTY
122659: LIST
122660: LIST
122661: PPUSH
122662: CALL_OW 69
122666: ST_TO_ADDR
// if not depot then
122667: LD_VAR 0 1
122671: NOT
122672: IFFALSE 122676
// exit ;
122674: GO 122711
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
122676: LD_VAR 0 1
122680: PUSH
122681: LD_INT 1
122683: ARRAY
122684: PPUSH
122685: CALL_OW 250
122689: PPUSH
122690: LD_VAR 0 1
122694: PUSH
122695: LD_INT 1
122697: ARRAY
122698: PPUSH
122699: CALL_OW 251
122703: PPUSH
122704: LD_INT 70
122706: PPUSH
122707: CALL_OW 495
// end ;
122711: PPOPN 1
122713: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
122714: LD_EXP 148
122718: PUSH
122719: LD_EXP 182
122723: AND
122724: IFFALSE 122935
122726: GO 122728
122728: DISABLE
122729: LD_INT 0
122731: PPUSH
122732: PPUSH
122733: PPUSH
122734: PPUSH
122735: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
122736: LD_ADDR_VAR 0 5
122740: PUSH
122741: LD_INT 22
122743: PUSH
122744: LD_OWVAR 2
122748: PUSH
122749: EMPTY
122750: LIST
122751: LIST
122752: PUSH
122753: LD_INT 21
122755: PUSH
122756: LD_INT 1
122758: PUSH
122759: EMPTY
122760: LIST
122761: LIST
122762: PUSH
122763: EMPTY
122764: LIST
122765: LIST
122766: PPUSH
122767: CALL_OW 69
122771: ST_TO_ADDR
// if not tmp then
122772: LD_VAR 0 5
122776: NOT
122777: IFFALSE 122781
// exit ;
122779: GO 122935
// for i in tmp do
122781: LD_ADDR_VAR 0 1
122785: PUSH
122786: LD_VAR 0 5
122790: PUSH
122791: FOR_IN
122792: IFFALSE 122933
// begin d := rand ( 0 , 5 ) ;
122794: LD_ADDR_VAR 0 4
122798: PUSH
122799: LD_INT 0
122801: PPUSH
122802: LD_INT 5
122804: PPUSH
122805: CALL_OW 12
122809: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
122810: LD_ADDR_VAR 0 2
122814: PUSH
122815: LD_VAR 0 1
122819: PPUSH
122820: CALL_OW 250
122824: PPUSH
122825: LD_VAR 0 4
122829: PPUSH
122830: LD_INT 3
122832: PPUSH
122833: LD_INT 12
122835: PPUSH
122836: CALL_OW 12
122840: PPUSH
122841: CALL_OW 272
122845: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
122846: LD_ADDR_VAR 0 3
122850: PUSH
122851: LD_VAR 0 1
122855: PPUSH
122856: CALL_OW 251
122860: PPUSH
122861: LD_VAR 0 4
122865: PPUSH
122866: LD_INT 3
122868: PPUSH
122869: LD_INT 12
122871: PPUSH
122872: CALL_OW 12
122876: PPUSH
122877: CALL_OW 273
122881: ST_TO_ADDR
// if ValidHex ( x , y ) then
122882: LD_VAR 0 2
122886: PPUSH
122887: LD_VAR 0 3
122891: PPUSH
122892: CALL_OW 488
122896: IFFALSE 122931
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
122898: LD_VAR 0 1
122902: PPUSH
122903: LD_VAR 0 2
122907: PPUSH
122908: LD_VAR 0 3
122912: PPUSH
122913: LD_INT 3
122915: PPUSH
122916: LD_INT 6
122918: PPUSH
122919: CALL_OW 12
122923: PPUSH
122924: LD_INT 1
122926: PPUSH
122927: CALL_OW 483
// end ;
122931: GO 122791
122933: POP
122934: POP
// end ;
122935: PPOPN 5
122937: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
122938: LD_EXP 148
122942: PUSH
122943: LD_EXP 183
122947: AND
122948: IFFALSE 123042
122950: GO 122952
122952: DISABLE
122953: LD_INT 0
122955: PPUSH
122956: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
122957: LD_ADDR_VAR 0 2
122961: PUSH
122962: LD_INT 22
122964: PUSH
122965: LD_OWVAR 2
122969: PUSH
122970: EMPTY
122971: LIST
122972: LIST
122973: PUSH
122974: LD_INT 32
122976: PUSH
122977: LD_INT 1
122979: PUSH
122980: EMPTY
122981: LIST
122982: LIST
122983: PUSH
122984: LD_INT 21
122986: PUSH
122987: LD_INT 2
122989: PUSH
122990: EMPTY
122991: LIST
122992: LIST
122993: PUSH
122994: EMPTY
122995: LIST
122996: LIST
122997: LIST
122998: PPUSH
122999: CALL_OW 69
123003: ST_TO_ADDR
// if not tmp then
123004: LD_VAR 0 2
123008: NOT
123009: IFFALSE 123013
// exit ;
123011: GO 123042
// for i in tmp do
123013: LD_ADDR_VAR 0 1
123017: PUSH
123018: LD_VAR 0 2
123022: PUSH
123023: FOR_IN
123024: IFFALSE 123040
// SetFuel ( i , 0 ) ;
123026: LD_VAR 0 1
123030: PPUSH
123031: LD_INT 0
123033: PPUSH
123034: CALL_OW 240
123038: GO 123023
123040: POP
123041: POP
// end ;
123042: PPOPN 2
123044: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
123045: LD_EXP 148
123049: PUSH
123050: LD_EXP 184
123054: AND
123055: IFFALSE 123121
123057: GO 123059
123059: DISABLE
123060: LD_INT 0
123062: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
123063: LD_ADDR_VAR 0 1
123067: PUSH
123068: LD_INT 22
123070: PUSH
123071: LD_OWVAR 2
123075: PUSH
123076: EMPTY
123077: LIST
123078: LIST
123079: PUSH
123080: LD_INT 30
123082: PUSH
123083: LD_INT 29
123085: PUSH
123086: EMPTY
123087: LIST
123088: LIST
123089: PUSH
123090: EMPTY
123091: LIST
123092: LIST
123093: PPUSH
123094: CALL_OW 69
123098: ST_TO_ADDR
// if not tmp then
123099: LD_VAR 0 1
123103: NOT
123104: IFFALSE 123108
// exit ;
123106: GO 123121
// DestroyUnit ( tmp [ 1 ] ) ;
123108: LD_VAR 0 1
123112: PUSH
123113: LD_INT 1
123115: ARRAY
123116: PPUSH
123117: CALL_OW 65
// end ;
123121: PPOPN 1
123123: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
123124: LD_EXP 148
123128: PUSH
123129: LD_EXP 186
123133: AND
123134: IFFALSE 123263
123136: GO 123138
123138: DISABLE
123139: LD_INT 0
123141: PPUSH
// begin uc_side := 0 ;
123142: LD_ADDR_OWVAR 20
123146: PUSH
123147: LD_INT 0
123149: ST_TO_ADDR
// uc_nation := nation_arabian ;
123150: LD_ADDR_OWVAR 21
123154: PUSH
123155: LD_INT 2
123157: ST_TO_ADDR
// hc_gallery :=  ;
123158: LD_ADDR_OWVAR 33
123162: PUSH
123163: LD_STRING 
123165: ST_TO_ADDR
// hc_name :=  ;
123166: LD_ADDR_OWVAR 26
123170: PUSH
123171: LD_STRING 
123173: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
123174: LD_INT 1
123176: PPUSH
123177: LD_INT 11
123179: PPUSH
123180: LD_INT 10
123182: PPUSH
123183: CALL_OW 380
// un := CreateHuman ;
123187: LD_ADDR_VAR 0 1
123191: PUSH
123192: CALL_OW 44
123196: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
123197: LD_VAR 0 1
123201: PPUSH
123202: LD_INT 1
123204: PPUSH
123205: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
123209: LD_INT 35
123211: PPUSH
123212: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
123216: LD_VAR 0 1
123220: PPUSH
123221: LD_INT 22
123223: PUSH
123224: LD_OWVAR 2
123228: PUSH
123229: EMPTY
123230: LIST
123231: LIST
123232: PPUSH
123233: CALL_OW 69
123237: PPUSH
123238: LD_VAR 0 1
123242: PPUSH
123243: CALL_OW 74
123247: PPUSH
123248: CALL_OW 115
// until IsDead ( un ) ;
123252: LD_VAR 0 1
123256: PPUSH
123257: CALL_OW 301
123261: IFFALSE 123209
// end ;
123263: PPOPN 1
123265: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
123266: LD_EXP 148
123270: PUSH
123271: LD_EXP 188
123275: AND
123276: IFFALSE 123288
123278: GO 123280
123280: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
123281: LD_STRING earthquake(getX(game), 0, 32)
123283: PPUSH
123284: CALL_OW 559
123288: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
123289: LD_EXP 148
123293: PUSH
123294: LD_EXP 189
123298: AND
123299: IFFALSE 123390
123301: GO 123303
123303: DISABLE
123304: LD_INT 0
123306: PPUSH
// begin enable ;
123307: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
123308: LD_ADDR_VAR 0 1
123312: PUSH
123313: LD_INT 22
123315: PUSH
123316: LD_OWVAR 2
123320: PUSH
123321: EMPTY
123322: LIST
123323: LIST
123324: PUSH
123325: LD_INT 21
123327: PUSH
123328: LD_INT 2
123330: PUSH
123331: EMPTY
123332: LIST
123333: LIST
123334: PUSH
123335: LD_INT 33
123337: PUSH
123338: LD_INT 3
123340: PUSH
123341: EMPTY
123342: LIST
123343: LIST
123344: PUSH
123345: EMPTY
123346: LIST
123347: LIST
123348: LIST
123349: PPUSH
123350: CALL_OW 69
123354: ST_TO_ADDR
// if not tmp then
123355: LD_VAR 0 1
123359: NOT
123360: IFFALSE 123364
// exit ;
123362: GO 123390
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
123364: LD_VAR 0 1
123368: PUSH
123369: LD_INT 1
123371: PPUSH
123372: LD_VAR 0 1
123376: PPUSH
123377: CALL_OW 12
123381: ARRAY
123382: PPUSH
123383: LD_INT 1
123385: PPUSH
123386: CALL_OW 234
// end ;
123390: PPOPN 1
123392: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
123393: LD_EXP 148
123397: PUSH
123398: LD_EXP 190
123402: AND
123403: IFFALSE 123544
123405: GO 123407
123407: DISABLE
123408: LD_INT 0
123410: PPUSH
123411: PPUSH
123412: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
123413: LD_ADDR_VAR 0 3
123417: PUSH
123418: LD_INT 22
123420: PUSH
123421: LD_OWVAR 2
123425: PUSH
123426: EMPTY
123427: LIST
123428: LIST
123429: PUSH
123430: LD_INT 25
123432: PUSH
123433: LD_INT 1
123435: PUSH
123436: EMPTY
123437: LIST
123438: LIST
123439: PUSH
123440: EMPTY
123441: LIST
123442: LIST
123443: PPUSH
123444: CALL_OW 69
123448: ST_TO_ADDR
// if not tmp then
123449: LD_VAR 0 3
123453: NOT
123454: IFFALSE 123458
// exit ;
123456: GO 123544
// un := tmp [ rand ( 1 , tmp ) ] ;
123458: LD_ADDR_VAR 0 2
123462: PUSH
123463: LD_VAR 0 3
123467: PUSH
123468: LD_INT 1
123470: PPUSH
123471: LD_VAR 0 3
123475: PPUSH
123476: CALL_OW 12
123480: ARRAY
123481: ST_TO_ADDR
// if Crawls ( un ) then
123482: LD_VAR 0 2
123486: PPUSH
123487: CALL_OW 318
123491: IFFALSE 123502
// ComWalk ( un ) ;
123493: LD_VAR 0 2
123497: PPUSH
123498: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
123502: LD_VAR 0 2
123506: PPUSH
123507: LD_INT 9
123509: PPUSH
123510: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
123514: LD_INT 28
123516: PPUSH
123517: LD_OWVAR 2
123521: PPUSH
123522: LD_INT 2
123524: PPUSH
123525: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
123529: LD_INT 29
123531: PPUSH
123532: LD_OWVAR 2
123536: PPUSH
123537: LD_INT 2
123539: PPUSH
123540: CALL_OW 322
// end ;
123544: PPOPN 3
123546: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
123547: LD_EXP 148
123551: PUSH
123552: LD_EXP 191
123556: AND
123557: IFFALSE 123668
123559: GO 123561
123561: DISABLE
123562: LD_INT 0
123564: PPUSH
123565: PPUSH
123566: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
123567: LD_ADDR_VAR 0 3
123571: PUSH
123572: LD_INT 22
123574: PUSH
123575: LD_OWVAR 2
123579: PUSH
123580: EMPTY
123581: LIST
123582: LIST
123583: PUSH
123584: LD_INT 25
123586: PUSH
123587: LD_INT 1
123589: PUSH
123590: EMPTY
123591: LIST
123592: LIST
123593: PUSH
123594: EMPTY
123595: LIST
123596: LIST
123597: PPUSH
123598: CALL_OW 69
123602: ST_TO_ADDR
// if not tmp then
123603: LD_VAR 0 3
123607: NOT
123608: IFFALSE 123612
// exit ;
123610: GO 123668
// un := tmp [ rand ( 1 , tmp ) ] ;
123612: LD_ADDR_VAR 0 2
123616: PUSH
123617: LD_VAR 0 3
123621: PUSH
123622: LD_INT 1
123624: PPUSH
123625: LD_VAR 0 3
123629: PPUSH
123630: CALL_OW 12
123634: ARRAY
123635: ST_TO_ADDR
// if Crawls ( un ) then
123636: LD_VAR 0 2
123640: PPUSH
123641: CALL_OW 318
123645: IFFALSE 123656
// ComWalk ( un ) ;
123647: LD_VAR 0 2
123651: PPUSH
123652: CALL_OW 138
// SetClass ( un , class_mortar ) ;
123656: LD_VAR 0 2
123660: PPUSH
123661: LD_INT 8
123663: PPUSH
123664: CALL_OW 336
// end ;
123668: PPOPN 3
123670: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
123671: LD_EXP 148
123675: PUSH
123676: LD_EXP 192
123680: AND
123681: IFFALSE 123825
123683: GO 123685
123685: DISABLE
123686: LD_INT 0
123688: PPUSH
123689: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
123690: LD_ADDR_VAR 0 2
123694: PUSH
123695: LD_INT 22
123697: PUSH
123698: LD_OWVAR 2
123702: PUSH
123703: EMPTY
123704: LIST
123705: LIST
123706: PUSH
123707: LD_INT 21
123709: PUSH
123710: LD_INT 2
123712: PUSH
123713: EMPTY
123714: LIST
123715: LIST
123716: PUSH
123717: LD_INT 2
123719: PUSH
123720: LD_INT 34
123722: PUSH
123723: LD_INT 12
123725: PUSH
123726: EMPTY
123727: LIST
123728: LIST
123729: PUSH
123730: LD_INT 34
123732: PUSH
123733: LD_INT 51
123735: PUSH
123736: EMPTY
123737: LIST
123738: LIST
123739: PUSH
123740: LD_INT 34
123742: PUSH
123743: LD_INT 32
123745: PUSH
123746: EMPTY
123747: LIST
123748: LIST
123749: PUSH
123750: EMPTY
123751: LIST
123752: LIST
123753: LIST
123754: LIST
123755: PUSH
123756: EMPTY
123757: LIST
123758: LIST
123759: LIST
123760: PPUSH
123761: CALL_OW 69
123765: ST_TO_ADDR
// if not tmp then
123766: LD_VAR 0 2
123770: NOT
123771: IFFALSE 123775
// exit ;
123773: GO 123825
// for i in tmp do
123775: LD_ADDR_VAR 0 1
123779: PUSH
123780: LD_VAR 0 2
123784: PUSH
123785: FOR_IN
123786: IFFALSE 123823
// if GetCargo ( i , mat_artifact ) = 0 then
123788: LD_VAR 0 1
123792: PPUSH
123793: LD_INT 4
123795: PPUSH
123796: CALL_OW 289
123800: PUSH
123801: LD_INT 0
123803: EQUAL
123804: IFFALSE 123821
// SetCargo ( i , mat_siberit , 100 ) ;
123806: LD_VAR 0 1
123810: PPUSH
123811: LD_INT 3
123813: PPUSH
123814: LD_INT 100
123816: PPUSH
123817: CALL_OW 290
123821: GO 123785
123823: POP
123824: POP
// end ;
123825: PPOPN 2
123827: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
123828: LD_EXP 148
123832: PUSH
123833: LD_EXP 193
123837: AND
123838: IFFALSE 124021
123840: GO 123842
123842: DISABLE
123843: LD_INT 0
123845: PPUSH
123846: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
123847: LD_ADDR_VAR 0 2
123851: PUSH
123852: LD_INT 22
123854: PUSH
123855: LD_OWVAR 2
123859: PUSH
123860: EMPTY
123861: LIST
123862: LIST
123863: PPUSH
123864: CALL_OW 69
123868: ST_TO_ADDR
// if not tmp then
123869: LD_VAR 0 2
123873: NOT
123874: IFFALSE 123878
// exit ;
123876: GO 124021
// for i := 1 to 2 do
123878: LD_ADDR_VAR 0 1
123882: PUSH
123883: DOUBLE
123884: LD_INT 1
123886: DEC
123887: ST_TO_ADDR
123888: LD_INT 2
123890: PUSH
123891: FOR_TO
123892: IFFALSE 124019
// begin uc_side := your_side ;
123894: LD_ADDR_OWVAR 20
123898: PUSH
123899: LD_OWVAR 2
123903: ST_TO_ADDR
// uc_nation := nation_american ;
123904: LD_ADDR_OWVAR 21
123908: PUSH
123909: LD_INT 1
123911: ST_TO_ADDR
// vc_chassis := us_morphling ;
123912: LD_ADDR_OWVAR 37
123916: PUSH
123917: LD_INT 5
123919: ST_TO_ADDR
// vc_engine := engine_siberite ;
123920: LD_ADDR_OWVAR 39
123924: PUSH
123925: LD_INT 3
123927: ST_TO_ADDR
// vc_control := control_computer ;
123928: LD_ADDR_OWVAR 38
123932: PUSH
123933: LD_INT 3
123935: ST_TO_ADDR
// vc_weapon := us_double_laser ;
123936: LD_ADDR_OWVAR 40
123940: PUSH
123941: LD_INT 10
123943: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
123944: LD_VAR 0 2
123948: PUSH
123949: LD_INT 1
123951: ARRAY
123952: PPUSH
123953: CALL_OW 310
123957: NOT
123958: IFFALSE 124005
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
123960: CALL_OW 45
123964: PPUSH
123965: LD_VAR 0 2
123969: PUSH
123970: LD_INT 1
123972: ARRAY
123973: PPUSH
123974: CALL_OW 250
123978: PPUSH
123979: LD_VAR 0 2
123983: PUSH
123984: LD_INT 1
123986: ARRAY
123987: PPUSH
123988: CALL_OW 251
123992: PPUSH
123993: LD_INT 12
123995: PPUSH
123996: LD_INT 1
123998: PPUSH
123999: CALL_OW 50
124003: GO 124017
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
124005: CALL_OW 45
124009: PPUSH
124010: LD_INT 1
124012: PPUSH
124013: CALL_OW 51
// end ;
124017: GO 123891
124019: POP
124020: POP
// end ;
124021: PPOPN 2
124023: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
124024: LD_EXP 148
124028: PUSH
124029: LD_EXP 194
124033: AND
124034: IFFALSE 124256
124036: GO 124038
124038: DISABLE
124039: LD_INT 0
124041: PPUSH
124042: PPUSH
124043: PPUSH
124044: PPUSH
124045: PPUSH
124046: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
124047: LD_ADDR_VAR 0 6
124051: PUSH
124052: LD_INT 22
124054: PUSH
124055: LD_OWVAR 2
124059: PUSH
124060: EMPTY
124061: LIST
124062: LIST
124063: PUSH
124064: LD_INT 21
124066: PUSH
124067: LD_INT 1
124069: PUSH
124070: EMPTY
124071: LIST
124072: LIST
124073: PUSH
124074: LD_INT 3
124076: PUSH
124077: LD_INT 23
124079: PUSH
124080: LD_INT 0
124082: PUSH
124083: EMPTY
124084: LIST
124085: LIST
124086: PUSH
124087: EMPTY
124088: LIST
124089: LIST
124090: PUSH
124091: EMPTY
124092: LIST
124093: LIST
124094: LIST
124095: PPUSH
124096: CALL_OW 69
124100: ST_TO_ADDR
// if not tmp then
124101: LD_VAR 0 6
124105: NOT
124106: IFFALSE 124110
// exit ;
124108: GO 124256
// s1 := rand ( 1 , 4 ) ;
124110: LD_ADDR_VAR 0 2
124114: PUSH
124115: LD_INT 1
124117: PPUSH
124118: LD_INT 4
124120: PPUSH
124121: CALL_OW 12
124125: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
124126: LD_ADDR_VAR 0 4
124130: PUSH
124131: LD_VAR 0 6
124135: PUSH
124136: LD_INT 1
124138: ARRAY
124139: PPUSH
124140: LD_VAR 0 2
124144: PPUSH
124145: CALL_OW 259
124149: ST_TO_ADDR
// if s1 = 1 then
124150: LD_VAR 0 2
124154: PUSH
124155: LD_INT 1
124157: EQUAL
124158: IFFALSE 124178
// s2 := rand ( 2 , 4 ) else
124160: LD_ADDR_VAR 0 3
124164: PUSH
124165: LD_INT 2
124167: PPUSH
124168: LD_INT 4
124170: PPUSH
124171: CALL_OW 12
124175: ST_TO_ADDR
124176: GO 124186
// s2 := 1 ;
124178: LD_ADDR_VAR 0 3
124182: PUSH
124183: LD_INT 1
124185: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
124186: LD_ADDR_VAR 0 5
124190: PUSH
124191: LD_VAR 0 6
124195: PUSH
124196: LD_INT 1
124198: ARRAY
124199: PPUSH
124200: LD_VAR 0 3
124204: PPUSH
124205: CALL_OW 259
124209: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
124210: LD_VAR 0 6
124214: PUSH
124215: LD_INT 1
124217: ARRAY
124218: PPUSH
124219: LD_VAR 0 2
124223: PPUSH
124224: LD_VAR 0 5
124228: PPUSH
124229: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
124233: LD_VAR 0 6
124237: PUSH
124238: LD_INT 1
124240: ARRAY
124241: PPUSH
124242: LD_VAR 0 3
124246: PPUSH
124247: LD_VAR 0 4
124251: PPUSH
124252: CALL_OW 237
// end ;
124256: PPOPN 6
124258: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
124259: LD_EXP 148
124263: PUSH
124264: LD_EXP 195
124268: AND
124269: IFFALSE 124348
124271: GO 124273
124273: DISABLE
124274: LD_INT 0
124276: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
124277: LD_ADDR_VAR 0 1
124281: PUSH
124282: LD_INT 22
124284: PUSH
124285: LD_OWVAR 2
124289: PUSH
124290: EMPTY
124291: LIST
124292: LIST
124293: PUSH
124294: LD_INT 30
124296: PUSH
124297: LD_INT 3
124299: PUSH
124300: EMPTY
124301: LIST
124302: LIST
124303: PUSH
124304: EMPTY
124305: LIST
124306: LIST
124307: PPUSH
124308: CALL_OW 69
124312: ST_TO_ADDR
// if not tmp then
124313: LD_VAR 0 1
124317: NOT
124318: IFFALSE 124322
// exit ;
124320: GO 124348
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
124322: LD_VAR 0 1
124326: PUSH
124327: LD_INT 1
124329: PPUSH
124330: LD_VAR 0 1
124334: PPUSH
124335: CALL_OW 12
124339: ARRAY
124340: PPUSH
124341: LD_INT 1
124343: PPUSH
124344: CALL_OW 234
// end ;
124348: PPOPN 1
124350: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
124351: LD_EXP 148
124355: PUSH
124356: LD_EXP 196
124360: AND
124361: IFFALSE 124473
124363: GO 124365
124365: DISABLE
124366: LD_INT 0
124368: PPUSH
124369: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
124370: LD_ADDR_VAR 0 2
124374: PUSH
124375: LD_INT 22
124377: PUSH
124378: LD_OWVAR 2
124382: PUSH
124383: EMPTY
124384: LIST
124385: LIST
124386: PUSH
124387: LD_INT 2
124389: PUSH
124390: LD_INT 30
124392: PUSH
124393: LD_INT 27
124395: PUSH
124396: EMPTY
124397: LIST
124398: LIST
124399: PUSH
124400: LD_INT 30
124402: PUSH
124403: LD_INT 26
124405: PUSH
124406: EMPTY
124407: LIST
124408: LIST
124409: PUSH
124410: LD_INT 30
124412: PUSH
124413: LD_INT 28
124415: PUSH
124416: EMPTY
124417: LIST
124418: LIST
124419: PUSH
124420: EMPTY
124421: LIST
124422: LIST
124423: LIST
124424: LIST
124425: PUSH
124426: EMPTY
124427: LIST
124428: LIST
124429: PPUSH
124430: CALL_OW 69
124434: ST_TO_ADDR
// if not tmp then
124435: LD_VAR 0 2
124439: NOT
124440: IFFALSE 124444
// exit ;
124442: GO 124473
// for i in tmp do
124444: LD_ADDR_VAR 0 1
124448: PUSH
124449: LD_VAR 0 2
124453: PUSH
124454: FOR_IN
124455: IFFALSE 124471
// SetLives ( i , 1 ) ;
124457: LD_VAR 0 1
124461: PPUSH
124462: LD_INT 1
124464: PPUSH
124465: CALL_OW 234
124469: GO 124454
124471: POP
124472: POP
// end ;
124473: PPOPN 2
124475: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
124476: LD_EXP 148
124480: PUSH
124481: LD_EXP 197
124485: AND
124486: IFFALSE 124773
124488: GO 124490
124490: DISABLE
124491: LD_INT 0
124493: PPUSH
124494: PPUSH
124495: PPUSH
// begin i := rand ( 1 , 7 ) ;
124496: LD_ADDR_VAR 0 1
124500: PUSH
124501: LD_INT 1
124503: PPUSH
124504: LD_INT 7
124506: PPUSH
124507: CALL_OW 12
124511: ST_TO_ADDR
// case i of 1 :
124512: LD_VAR 0 1
124516: PUSH
124517: LD_INT 1
124519: DOUBLE
124520: EQUAL
124521: IFTRUE 124525
124523: GO 124535
124525: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
124526: LD_STRING earthquake(getX(game), 0, 32)
124528: PPUSH
124529: CALL_OW 559
124533: GO 124773
124535: LD_INT 2
124537: DOUBLE
124538: EQUAL
124539: IFTRUE 124543
124541: GO 124557
124543: POP
// begin ToLua ( displayStucuk(); ) ;
124544: LD_STRING displayStucuk();
124546: PPUSH
124547: CALL_OW 559
// ResetFog ;
124551: CALL_OW 335
// end ; 3 :
124555: GO 124773
124557: LD_INT 3
124559: DOUBLE
124560: EQUAL
124561: IFTRUE 124565
124563: GO 124669
124565: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
124566: LD_ADDR_VAR 0 2
124570: PUSH
124571: LD_INT 22
124573: PUSH
124574: LD_OWVAR 2
124578: PUSH
124579: EMPTY
124580: LIST
124581: LIST
124582: PUSH
124583: LD_INT 25
124585: PUSH
124586: LD_INT 1
124588: PUSH
124589: EMPTY
124590: LIST
124591: LIST
124592: PUSH
124593: EMPTY
124594: LIST
124595: LIST
124596: PPUSH
124597: CALL_OW 69
124601: ST_TO_ADDR
// if not tmp then
124602: LD_VAR 0 2
124606: NOT
124607: IFFALSE 124611
// exit ;
124609: GO 124773
// un := tmp [ rand ( 1 , tmp ) ] ;
124611: LD_ADDR_VAR 0 3
124615: PUSH
124616: LD_VAR 0 2
124620: PUSH
124621: LD_INT 1
124623: PPUSH
124624: LD_VAR 0 2
124628: PPUSH
124629: CALL_OW 12
124633: ARRAY
124634: ST_TO_ADDR
// if Crawls ( un ) then
124635: LD_VAR 0 3
124639: PPUSH
124640: CALL_OW 318
124644: IFFALSE 124655
// ComWalk ( un ) ;
124646: LD_VAR 0 3
124650: PPUSH
124651: CALL_OW 138
// SetClass ( un , class_mortar ) ;
124655: LD_VAR 0 3
124659: PPUSH
124660: LD_INT 8
124662: PPUSH
124663: CALL_OW 336
// end ; 4 :
124667: GO 124773
124669: LD_INT 4
124671: DOUBLE
124672: EQUAL
124673: IFTRUE 124677
124675: GO 124751
124677: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
124678: LD_ADDR_VAR 0 2
124682: PUSH
124683: LD_INT 22
124685: PUSH
124686: LD_OWVAR 2
124690: PUSH
124691: EMPTY
124692: LIST
124693: LIST
124694: PUSH
124695: LD_INT 30
124697: PUSH
124698: LD_INT 29
124700: PUSH
124701: EMPTY
124702: LIST
124703: LIST
124704: PUSH
124705: EMPTY
124706: LIST
124707: LIST
124708: PPUSH
124709: CALL_OW 69
124713: ST_TO_ADDR
// if not tmp then
124714: LD_VAR 0 2
124718: NOT
124719: IFFALSE 124723
// exit ;
124721: GO 124773
// CenterNowOnUnits ( tmp [ 1 ] ) ;
124723: LD_VAR 0 2
124727: PUSH
124728: LD_INT 1
124730: ARRAY
124731: PPUSH
124732: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
124736: LD_VAR 0 2
124740: PUSH
124741: LD_INT 1
124743: ARRAY
124744: PPUSH
124745: CALL_OW 65
// end ; 5 .. 7 :
124749: GO 124773
124751: LD_INT 5
124753: DOUBLE
124754: GREATEREQUAL
124755: IFFALSE 124763
124757: LD_INT 7
124759: DOUBLE
124760: LESSEQUAL
124761: IFTRUE 124765
124763: GO 124772
124765: POP
// StreamSibBomb ; end ;
124766: CALL 121010 0 0
124770: GO 124773
124772: POP
// end ;
124773: PPOPN 3
124775: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
124776: LD_EXP 148
124780: PUSH
124781: LD_EXP 198
124785: AND
124786: IFFALSE 124942
124788: GO 124790
124790: DISABLE
124791: LD_INT 0
124793: PPUSH
124794: PPUSH
124795: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
124796: LD_ADDR_VAR 0 2
124800: PUSH
124801: LD_INT 81
124803: PUSH
124804: LD_OWVAR 2
124808: PUSH
124809: EMPTY
124810: LIST
124811: LIST
124812: PUSH
124813: LD_INT 2
124815: PUSH
124816: LD_INT 21
124818: PUSH
124819: LD_INT 1
124821: PUSH
124822: EMPTY
124823: LIST
124824: LIST
124825: PUSH
124826: LD_INT 21
124828: PUSH
124829: LD_INT 2
124831: PUSH
124832: EMPTY
124833: LIST
124834: LIST
124835: PUSH
124836: EMPTY
124837: LIST
124838: LIST
124839: LIST
124840: PUSH
124841: EMPTY
124842: LIST
124843: LIST
124844: PPUSH
124845: CALL_OW 69
124849: ST_TO_ADDR
// if not tmp then
124850: LD_VAR 0 2
124854: NOT
124855: IFFALSE 124859
// exit ;
124857: GO 124942
// p := 0 ;
124859: LD_ADDR_VAR 0 3
124863: PUSH
124864: LD_INT 0
124866: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
124867: LD_INT 35
124869: PPUSH
124870: CALL_OW 67
// p := p + 1 ;
124874: LD_ADDR_VAR 0 3
124878: PUSH
124879: LD_VAR 0 3
124883: PUSH
124884: LD_INT 1
124886: PLUS
124887: ST_TO_ADDR
// for i in tmp do
124888: LD_ADDR_VAR 0 1
124892: PUSH
124893: LD_VAR 0 2
124897: PUSH
124898: FOR_IN
124899: IFFALSE 124930
// if GetLives ( i ) < 1000 then
124901: LD_VAR 0 1
124905: PPUSH
124906: CALL_OW 256
124910: PUSH
124911: LD_INT 1000
124913: LESS
124914: IFFALSE 124928
// SetLives ( i , 1000 ) ;
124916: LD_VAR 0 1
124920: PPUSH
124921: LD_INT 1000
124923: PPUSH
124924: CALL_OW 234
124928: GO 124898
124930: POP
124931: POP
// until p > 20 ;
124932: LD_VAR 0 3
124936: PUSH
124937: LD_INT 20
124939: GREATER
124940: IFFALSE 124867
// end ;
124942: PPOPN 3
124944: END
// every 0 0$1 trigger StreamModeActive and sTime do
124945: LD_EXP 148
124949: PUSH
124950: LD_EXP 199
124954: AND
124955: IFFALSE 124990
124957: GO 124959
124959: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
124960: LD_INT 28
124962: PPUSH
124963: LD_OWVAR 2
124967: PPUSH
124968: LD_INT 2
124970: PPUSH
124971: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
124975: LD_INT 30
124977: PPUSH
124978: LD_OWVAR 2
124982: PPUSH
124983: LD_INT 2
124985: PPUSH
124986: CALL_OW 322
// end ;
124990: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
124991: LD_EXP 148
124995: PUSH
124996: LD_EXP 200
125000: AND
125001: IFFALSE 125122
125003: GO 125005
125005: DISABLE
125006: LD_INT 0
125008: PPUSH
125009: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
125010: LD_ADDR_VAR 0 2
125014: PUSH
125015: LD_INT 22
125017: PUSH
125018: LD_OWVAR 2
125022: PUSH
125023: EMPTY
125024: LIST
125025: LIST
125026: PUSH
125027: LD_INT 21
125029: PUSH
125030: LD_INT 1
125032: PUSH
125033: EMPTY
125034: LIST
125035: LIST
125036: PUSH
125037: LD_INT 3
125039: PUSH
125040: LD_INT 23
125042: PUSH
125043: LD_INT 0
125045: PUSH
125046: EMPTY
125047: LIST
125048: LIST
125049: PUSH
125050: EMPTY
125051: LIST
125052: LIST
125053: PUSH
125054: EMPTY
125055: LIST
125056: LIST
125057: LIST
125058: PPUSH
125059: CALL_OW 69
125063: ST_TO_ADDR
// if not tmp then
125064: LD_VAR 0 2
125068: NOT
125069: IFFALSE 125073
// exit ;
125071: GO 125122
// for i in tmp do
125073: LD_ADDR_VAR 0 1
125077: PUSH
125078: LD_VAR 0 2
125082: PUSH
125083: FOR_IN
125084: IFFALSE 125120
// begin if Crawls ( i ) then
125086: LD_VAR 0 1
125090: PPUSH
125091: CALL_OW 318
125095: IFFALSE 125106
// ComWalk ( i ) ;
125097: LD_VAR 0 1
125101: PPUSH
125102: CALL_OW 138
// SetClass ( i , 2 ) ;
125106: LD_VAR 0 1
125110: PPUSH
125111: LD_INT 2
125113: PPUSH
125114: CALL_OW 336
// end ;
125118: GO 125083
125120: POP
125121: POP
// end ;
125122: PPOPN 2
125124: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
125125: LD_EXP 148
125129: PUSH
125130: LD_EXP 201
125134: AND
125135: IFFALSE 125423
125137: GO 125139
125139: DISABLE
125140: LD_INT 0
125142: PPUSH
125143: PPUSH
125144: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
125145: LD_OWVAR 2
125149: PPUSH
125150: LD_INT 9
125152: PPUSH
125153: LD_INT 1
125155: PPUSH
125156: LD_INT 1
125158: PPUSH
125159: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
125163: LD_INT 9
125165: PPUSH
125166: LD_OWVAR 2
125170: PPUSH
125171: CALL_OW 343
// uc_side := 9 ;
125175: LD_ADDR_OWVAR 20
125179: PUSH
125180: LD_INT 9
125182: ST_TO_ADDR
// uc_nation := 2 ;
125183: LD_ADDR_OWVAR 21
125187: PUSH
125188: LD_INT 2
125190: ST_TO_ADDR
// hc_name := Dark Warrior ;
125191: LD_ADDR_OWVAR 26
125195: PUSH
125196: LD_STRING Dark Warrior
125198: ST_TO_ADDR
// hc_gallery :=  ;
125199: LD_ADDR_OWVAR 33
125203: PUSH
125204: LD_STRING 
125206: ST_TO_ADDR
// hc_noskilllimit := true ;
125207: LD_ADDR_OWVAR 76
125211: PUSH
125212: LD_INT 1
125214: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
125215: LD_ADDR_OWVAR 31
125219: PUSH
125220: LD_INT 30
125222: PUSH
125223: LD_INT 30
125225: PUSH
125226: LD_INT 30
125228: PUSH
125229: LD_INT 30
125231: PUSH
125232: EMPTY
125233: LIST
125234: LIST
125235: LIST
125236: LIST
125237: ST_TO_ADDR
// un := CreateHuman ;
125238: LD_ADDR_VAR 0 3
125242: PUSH
125243: CALL_OW 44
125247: ST_TO_ADDR
// hc_noskilllimit := false ;
125248: LD_ADDR_OWVAR 76
125252: PUSH
125253: LD_INT 0
125255: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
125256: LD_VAR 0 3
125260: PPUSH
125261: LD_INT 1
125263: PPUSH
125264: CALL_OW 51
// ToLua ( playRanger() ) ;
125268: LD_STRING playRanger()
125270: PPUSH
125271: CALL_OW 559
// p := 0 ;
125275: LD_ADDR_VAR 0 2
125279: PUSH
125280: LD_INT 0
125282: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
125283: LD_INT 35
125285: PPUSH
125286: CALL_OW 67
// p := p + 1 ;
125290: LD_ADDR_VAR 0 2
125294: PUSH
125295: LD_VAR 0 2
125299: PUSH
125300: LD_INT 1
125302: PLUS
125303: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
125304: LD_VAR 0 3
125308: PPUSH
125309: CALL_OW 256
125313: PUSH
125314: LD_INT 1000
125316: LESS
125317: IFFALSE 125331
// SetLives ( un , 1000 ) ;
125319: LD_VAR 0 3
125323: PPUSH
125324: LD_INT 1000
125326: PPUSH
125327: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
125331: LD_VAR 0 3
125335: PPUSH
125336: LD_INT 81
125338: PUSH
125339: LD_OWVAR 2
125343: PUSH
125344: EMPTY
125345: LIST
125346: LIST
125347: PUSH
125348: LD_INT 91
125350: PUSH
125351: LD_VAR 0 3
125355: PUSH
125356: LD_INT 30
125358: PUSH
125359: EMPTY
125360: LIST
125361: LIST
125362: LIST
125363: PUSH
125364: EMPTY
125365: LIST
125366: LIST
125367: PPUSH
125368: CALL_OW 69
125372: PPUSH
125373: LD_VAR 0 3
125377: PPUSH
125378: CALL_OW 74
125382: PPUSH
125383: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
125387: LD_VAR 0 2
125391: PUSH
125392: LD_INT 80
125394: GREATER
125395: PUSH
125396: LD_VAR 0 3
125400: PPUSH
125401: CALL_OW 301
125405: OR
125406: IFFALSE 125283
// if un then
125408: LD_VAR 0 3
125412: IFFALSE 125423
// RemoveUnit ( un ) ;
125414: LD_VAR 0 3
125418: PPUSH
125419: CALL_OW 64
// end ;
125423: PPOPN 3
125425: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
125426: LD_EXP 202
125430: IFFALSE 125546
125432: GO 125434
125434: DISABLE
125435: LD_INT 0
125437: PPUSH
125438: PPUSH
125439: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
125440: LD_ADDR_VAR 0 2
125444: PUSH
125445: LD_INT 81
125447: PUSH
125448: LD_OWVAR 2
125452: PUSH
125453: EMPTY
125454: LIST
125455: LIST
125456: PUSH
125457: LD_INT 21
125459: PUSH
125460: LD_INT 1
125462: PUSH
125463: EMPTY
125464: LIST
125465: LIST
125466: PUSH
125467: EMPTY
125468: LIST
125469: LIST
125470: PPUSH
125471: CALL_OW 69
125475: ST_TO_ADDR
// ToLua ( playComputer() ) ;
125476: LD_STRING playComputer()
125478: PPUSH
125479: CALL_OW 559
// if not tmp then
125483: LD_VAR 0 2
125487: NOT
125488: IFFALSE 125492
// exit ;
125490: GO 125546
// for i in tmp do
125492: LD_ADDR_VAR 0 1
125496: PUSH
125497: LD_VAR 0 2
125501: PUSH
125502: FOR_IN
125503: IFFALSE 125544
// for j := 1 to 4 do
125505: LD_ADDR_VAR 0 3
125509: PUSH
125510: DOUBLE
125511: LD_INT 1
125513: DEC
125514: ST_TO_ADDR
125515: LD_INT 4
125517: PUSH
125518: FOR_TO
125519: IFFALSE 125540
// SetSkill ( i , j , 10 ) ;
125521: LD_VAR 0 1
125525: PPUSH
125526: LD_VAR 0 3
125530: PPUSH
125531: LD_INT 10
125533: PPUSH
125534: CALL_OW 237
125538: GO 125518
125540: POP
125541: POP
125542: GO 125502
125544: POP
125545: POP
// end ;
125546: PPOPN 3
125548: END
// every 0 0$1 trigger s30 do var i , tmp ;
125549: LD_EXP 203
125553: IFFALSE 125622
125555: GO 125557
125557: DISABLE
125558: LD_INT 0
125560: PPUSH
125561: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
125562: LD_ADDR_VAR 0 2
125566: PUSH
125567: LD_INT 22
125569: PUSH
125570: LD_OWVAR 2
125574: PUSH
125575: EMPTY
125576: LIST
125577: LIST
125578: PPUSH
125579: CALL_OW 69
125583: ST_TO_ADDR
// if not tmp then
125584: LD_VAR 0 2
125588: NOT
125589: IFFALSE 125593
// exit ;
125591: GO 125622
// for i in tmp do
125593: LD_ADDR_VAR 0 1
125597: PUSH
125598: LD_VAR 0 2
125602: PUSH
125603: FOR_IN
125604: IFFALSE 125620
// SetLives ( i , 300 ) ;
125606: LD_VAR 0 1
125610: PPUSH
125611: LD_INT 300
125613: PPUSH
125614: CALL_OW 234
125618: GO 125603
125620: POP
125621: POP
// end ;
125622: PPOPN 2
125624: END
// every 0 0$1 trigger s60 do var i , tmp ;
125625: LD_EXP 204
125629: IFFALSE 125698
125631: GO 125633
125633: DISABLE
125634: LD_INT 0
125636: PPUSH
125637: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
125638: LD_ADDR_VAR 0 2
125642: PUSH
125643: LD_INT 22
125645: PUSH
125646: LD_OWVAR 2
125650: PUSH
125651: EMPTY
125652: LIST
125653: LIST
125654: PPUSH
125655: CALL_OW 69
125659: ST_TO_ADDR
// if not tmp then
125660: LD_VAR 0 2
125664: NOT
125665: IFFALSE 125669
// exit ;
125667: GO 125698
// for i in tmp do
125669: LD_ADDR_VAR 0 1
125673: PUSH
125674: LD_VAR 0 2
125678: PUSH
125679: FOR_IN
125680: IFFALSE 125696
// SetLives ( i , 600 ) ;
125682: LD_VAR 0 1
125686: PPUSH
125687: LD_INT 600
125689: PPUSH
125690: CALL_OW 234
125694: GO 125679
125696: POP
125697: POP
// end ;
125698: PPOPN 2
125700: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
125701: LD_INT 0
125703: PPUSH
// case cmd of 301 :
125704: LD_VAR 0 1
125708: PUSH
125709: LD_INT 301
125711: DOUBLE
125712: EQUAL
125713: IFTRUE 125717
125715: GO 125749
125717: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
125718: LD_VAR 0 6
125722: PPUSH
125723: LD_VAR 0 7
125727: PPUSH
125728: LD_VAR 0 8
125732: PPUSH
125733: LD_VAR 0 4
125737: PPUSH
125738: LD_VAR 0 5
125742: PPUSH
125743: CALL 126958 0 5
125747: GO 125870
125749: LD_INT 302
125751: DOUBLE
125752: EQUAL
125753: IFTRUE 125757
125755: GO 125794
125757: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
125758: LD_VAR 0 6
125762: PPUSH
125763: LD_VAR 0 7
125767: PPUSH
125768: LD_VAR 0 8
125772: PPUSH
125773: LD_VAR 0 9
125777: PPUSH
125778: LD_VAR 0 4
125782: PPUSH
125783: LD_VAR 0 5
125787: PPUSH
125788: CALL 127049 0 6
125792: GO 125870
125794: LD_INT 303
125796: DOUBLE
125797: EQUAL
125798: IFTRUE 125802
125800: GO 125839
125802: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
125803: LD_VAR 0 6
125807: PPUSH
125808: LD_VAR 0 7
125812: PPUSH
125813: LD_VAR 0 8
125817: PPUSH
125818: LD_VAR 0 9
125822: PPUSH
125823: LD_VAR 0 4
125827: PPUSH
125828: LD_VAR 0 5
125832: PPUSH
125833: CALL 125875 0 6
125837: GO 125870
125839: LD_INT 304
125841: DOUBLE
125842: EQUAL
125843: IFTRUE 125847
125845: GO 125869
125847: POP
// hHackTeleport ( unit , x , y ) ; end ;
125848: LD_VAR 0 2
125852: PPUSH
125853: LD_VAR 0 4
125857: PPUSH
125858: LD_VAR 0 5
125862: PPUSH
125863: CALL 127642 0 3
125867: GO 125870
125869: POP
// end ;
125870: LD_VAR 0 12
125874: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
125875: LD_INT 0
125877: PPUSH
125878: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
125879: LD_VAR 0 1
125883: PUSH
125884: LD_INT 1
125886: LESS
125887: PUSH
125888: LD_VAR 0 1
125892: PUSH
125893: LD_INT 3
125895: GREATER
125896: OR
125897: PUSH
125898: LD_VAR 0 5
125902: PPUSH
125903: LD_VAR 0 6
125907: PPUSH
125908: CALL_OW 428
125912: OR
125913: IFFALSE 125917
// exit ;
125915: GO 126645
// uc_side := your_side ;
125917: LD_ADDR_OWVAR 20
125921: PUSH
125922: LD_OWVAR 2
125926: ST_TO_ADDR
// uc_nation := nation ;
125927: LD_ADDR_OWVAR 21
125931: PUSH
125932: LD_VAR 0 1
125936: ST_TO_ADDR
// bc_level = 1 ;
125937: LD_ADDR_OWVAR 43
125941: PUSH
125942: LD_INT 1
125944: ST_TO_ADDR
// case btype of 1 :
125945: LD_VAR 0 2
125949: PUSH
125950: LD_INT 1
125952: DOUBLE
125953: EQUAL
125954: IFTRUE 125958
125956: GO 125969
125958: POP
// bc_type := b_depot ; 2 :
125959: LD_ADDR_OWVAR 42
125963: PUSH
125964: LD_INT 0
125966: ST_TO_ADDR
125967: GO 126589
125969: LD_INT 2
125971: DOUBLE
125972: EQUAL
125973: IFTRUE 125977
125975: GO 125988
125977: POP
// bc_type := b_warehouse ; 3 :
125978: LD_ADDR_OWVAR 42
125982: PUSH
125983: LD_INT 1
125985: ST_TO_ADDR
125986: GO 126589
125988: LD_INT 3
125990: DOUBLE
125991: EQUAL
125992: IFTRUE 125996
125994: GO 126007
125996: POP
// bc_type := b_lab ; 4 .. 9 :
125997: LD_ADDR_OWVAR 42
126001: PUSH
126002: LD_INT 6
126004: ST_TO_ADDR
126005: GO 126589
126007: LD_INT 4
126009: DOUBLE
126010: GREATEREQUAL
126011: IFFALSE 126019
126013: LD_INT 9
126015: DOUBLE
126016: LESSEQUAL
126017: IFTRUE 126021
126019: GO 126081
126021: POP
// begin bc_type := b_lab_half ;
126022: LD_ADDR_OWVAR 42
126026: PUSH
126027: LD_INT 7
126029: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
126030: LD_ADDR_OWVAR 44
126034: PUSH
126035: LD_INT 10
126037: PUSH
126038: LD_INT 11
126040: PUSH
126041: LD_INT 12
126043: PUSH
126044: LD_INT 15
126046: PUSH
126047: LD_INT 14
126049: PUSH
126050: LD_INT 13
126052: PUSH
126053: EMPTY
126054: LIST
126055: LIST
126056: LIST
126057: LIST
126058: LIST
126059: LIST
126060: PUSH
126061: LD_VAR 0 2
126065: PUSH
126066: LD_INT 3
126068: MINUS
126069: ARRAY
126070: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
126071: LD_ADDR_OWVAR 45
126075: PUSH
126076: LD_INT 9
126078: ST_TO_ADDR
// end ; 10 .. 13 :
126079: GO 126589
126081: LD_INT 10
126083: DOUBLE
126084: GREATEREQUAL
126085: IFFALSE 126093
126087: LD_INT 13
126089: DOUBLE
126090: LESSEQUAL
126091: IFTRUE 126095
126093: GO 126172
126095: POP
// begin bc_type := b_lab_full ;
126096: LD_ADDR_OWVAR 42
126100: PUSH
126101: LD_INT 8
126103: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
126104: LD_ADDR_OWVAR 44
126108: PUSH
126109: LD_INT 10
126111: PUSH
126112: LD_INT 12
126114: PUSH
126115: LD_INT 14
126117: PUSH
126118: LD_INT 13
126120: PUSH
126121: EMPTY
126122: LIST
126123: LIST
126124: LIST
126125: LIST
126126: PUSH
126127: LD_VAR 0 2
126131: PUSH
126132: LD_INT 9
126134: MINUS
126135: ARRAY
126136: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
126137: LD_ADDR_OWVAR 45
126141: PUSH
126142: LD_INT 11
126144: PUSH
126145: LD_INT 15
126147: PUSH
126148: LD_INT 12
126150: PUSH
126151: LD_INT 15
126153: PUSH
126154: EMPTY
126155: LIST
126156: LIST
126157: LIST
126158: LIST
126159: PUSH
126160: LD_VAR 0 2
126164: PUSH
126165: LD_INT 9
126167: MINUS
126168: ARRAY
126169: ST_TO_ADDR
// end ; 14 :
126170: GO 126589
126172: LD_INT 14
126174: DOUBLE
126175: EQUAL
126176: IFTRUE 126180
126178: GO 126191
126180: POP
// bc_type := b_workshop ; 15 :
126181: LD_ADDR_OWVAR 42
126185: PUSH
126186: LD_INT 2
126188: ST_TO_ADDR
126189: GO 126589
126191: LD_INT 15
126193: DOUBLE
126194: EQUAL
126195: IFTRUE 126199
126197: GO 126210
126199: POP
// bc_type := b_factory ; 16 :
126200: LD_ADDR_OWVAR 42
126204: PUSH
126205: LD_INT 3
126207: ST_TO_ADDR
126208: GO 126589
126210: LD_INT 16
126212: DOUBLE
126213: EQUAL
126214: IFTRUE 126218
126216: GO 126229
126218: POP
// bc_type := b_ext_gun ; 17 :
126219: LD_ADDR_OWVAR 42
126223: PUSH
126224: LD_INT 17
126226: ST_TO_ADDR
126227: GO 126589
126229: LD_INT 17
126231: DOUBLE
126232: EQUAL
126233: IFTRUE 126237
126235: GO 126265
126237: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
126238: LD_ADDR_OWVAR 42
126242: PUSH
126243: LD_INT 19
126245: PUSH
126246: LD_INT 23
126248: PUSH
126249: LD_INT 19
126251: PUSH
126252: EMPTY
126253: LIST
126254: LIST
126255: LIST
126256: PUSH
126257: LD_VAR 0 1
126261: ARRAY
126262: ST_TO_ADDR
126263: GO 126589
126265: LD_INT 18
126267: DOUBLE
126268: EQUAL
126269: IFTRUE 126273
126271: GO 126284
126273: POP
// bc_type := b_ext_radar ; 19 :
126274: LD_ADDR_OWVAR 42
126278: PUSH
126279: LD_INT 20
126281: ST_TO_ADDR
126282: GO 126589
126284: LD_INT 19
126286: DOUBLE
126287: EQUAL
126288: IFTRUE 126292
126290: GO 126303
126292: POP
// bc_type := b_ext_radio ; 20 :
126293: LD_ADDR_OWVAR 42
126297: PUSH
126298: LD_INT 22
126300: ST_TO_ADDR
126301: GO 126589
126303: LD_INT 20
126305: DOUBLE
126306: EQUAL
126307: IFTRUE 126311
126309: GO 126322
126311: POP
// bc_type := b_ext_siberium ; 21 :
126312: LD_ADDR_OWVAR 42
126316: PUSH
126317: LD_INT 21
126319: ST_TO_ADDR
126320: GO 126589
126322: LD_INT 21
126324: DOUBLE
126325: EQUAL
126326: IFTRUE 126330
126328: GO 126341
126330: POP
// bc_type := b_ext_computer ; 22 :
126331: LD_ADDR_OWVAR 42
126335: PUSH
126336: LD_INT 24
126338: ST_TO_ADDR
126339: GO 126589
126341: LD_INT 22
126343: DOUBLE
126344: EQUAL
126345: IFTRUE 126349
126347: GO 126360
126349: POP
// bc_type := b_ext_track ; 23 :
126350: LD_ADDR_OWVAR 42
126354: PUSH
126355: LD_INT 16
126357: ST_TO_ADDR
126358: GO 126589
126360: LD_INT 23
126362: DOUBLE
126363: EQUAL
126364: IFTRUE 126368
126366: GO 126379
126368: POP
// bc_type := b_ext_laser ; 24 :
126369: LD_ADDR_OWVAR 42
126373: PUSH
126374: LD_INT 25
126376: ST_TO_ADDR
126377: GO 126589
126379: LD_INT 24
126381: DOUBLE
126382: EQUAL
126383: IFTRUE 126387
126385: GO 126398
126387: POP
// bc_type := b_control_tower ; 25 :
126388: LD_ADDR_OWVAR 42
126392: PUSH
126393: LD_INT 36
126395: ST_TO_ADDR
126396: GO 126589
126398: LD_INT 25
126400: DOUBLE
126401: EQUAL
126402: IFTRUE 126406
126404: GO 126417
126406: POP
// bc_type := b_breastwork ; 26 :
126407: LD_ADDR_OWVAR 42
126411: PUSH
126412: LD_INT 31
126414: ST_TO_ADDR
126415: GO 126589
126417: LD_INT 26
126419: DOUBLE
126420: EQUAL
126421: IFTRUE 126425
126423: GO 126436
126425: POP
// bc_type := b_bunker ; 27 :
126426: LD_ADDR_OWVAR 42
126430: PUSH
126431: LD_INT 32
126433: ST_TO_ADDR
126434: GO 126589
126436: LD_INT 27
126438: DOUBLE
126439: EQUAL
126440: IFTRUE 126444
126442: GO 126455
126444: POP
// bc_type := b_turret ; 28 :
126445: LD_ADDR_OWVAR 42
126449: PUSH
126450: LD_INT 33
126452: ST_TO_ADDR
126453: GO 126589
126455: LD_INT 28
126457: DOUBLE
126458: EQUAL
126459: IFTRUE 126463
126461: GO 126474
126463: POP
// bc_type := b_armoury ; 29 :
126464: LD_ADDR_OWVAR 42
126468: PUSH
126469: LD_INT 4
126471: ST_TO_ADDR
126472: GO 126589
126474: LD_INT 29
126476: DOUBLE
126477: EQUAL
126478: IFTRUE 126482
126480: GO 126493
126482: POP
// bc_type := b_barracks ; 30 :
126483: LD_ADDR_OWVAR 42
126487: PUSH
126488: LD_INT 5
126490: ST_TO_ADDR
126491: GO 126589
126493: LD_INT 30
126495: DOUBLE
126496: EQUAL
126497: IFTRUE 126501
126499: GO 126512
126501: POP
// bc_type := b_solar_power ; 31 :
126502: LD_ADDR_OWVAR 42
126506: PUSH
126507: LD_INT 27
126509: ST_TO_ADDR
126510: GO 126589
126512: LD_INT 31
126514: DOUBLE
126515: EQUAL
126516: IFTRUE 126520
126518: GO 126531
126520: POP
// bc_type := b_oil_power ; 32 :
126521: LD_ADDR_OWVAR 42
126525: PUSH
126526: LD_INT 26
126528: ST_TO_ADDR
126529: GO 126589
126531: LD_INT 32
126533: DOUBLE
126534: EQUAL
126535: IFTRUE 126539
126537: GO 126550
126539: POP
// bc_type := b_siberite_power ; 33 :
126540: LD_ADDR_OWVAR 42
126544: PUSH
126545: LD_INT 28
126547: ST_TO_ADDR
126548: GO 126589
126550: LD_INT 33
126552: DOUBLE
126553: EQUAL
126554: IFTRUE 126558
126556: GO 126569
126558: POP
// bc_type := b_oil_mine ; 34 :
126559: LD_ADDR_OWVAR 42
126563: PUSH
126564: LD_INT 29
126566: ST_TO_ADDR
126567: GO 126589
126569: LD_INT 34
126571: DOUBLE
126572: EQUAL
126573: IFTRUE 126577
126575: GO 126588
126577: POP
// bc_type := b_siberite_mine ; end ;
126578: LD_ADDR_OWVAR 42
126582: PUSH
126583: LD_INT 30
126585: ST_TO_ADDR
126586: GO 126589
126588: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
126589: LD_ADDR_VAR 0 8
126593: PUSH
126594: LD_VAR 0 5
126598: PPUSH
126599: LD_VAR 0 6
126603: PPUSH
126604: LD_VAR 0 3
126608: PPUSH
126609: CALL_OW 47
126613: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
126614: LD_OWVAR 42
126618: PUSH
126619: LD_INT 32
126621: PUSH
126622: LD_INT 33
126624: PUSH
126625: EMPTY
126626: LIST
126627: LIST
126628: IN
126629: IFFALSE 126645
// PlaceWeaponTurret ( b , weapon ) ;
126631: LD_VAR 0 8
126635: PPUSH
126636: LD_VAR 0 4
126640: PPUSH
126641: CALL_OW 431
// end ;
126645: LD_VAR 0 7
126649: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
126650: LD_INT 0
126652: PPUSH
126653: PPUSH
126654: PPUSH
126655: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
126656: LD_ADDR_VAR 0 4
126660: PUSH
126661: LD_INT 22
126663: PUSH
126664: LD_OWVAR 2
126668: PUSH
126669: EMPTY
126670: LIST
126671: LIST
126672: PUSH
126673: LD_INT 2
126675: PUSH
126676: LD_INT 30
126678: PUSH
126679: LD_INT 0
126681: PUSH
126682: EMPTY
126683: LIST
126684: LIST
126685: PUSH
126686: LD_INT 30
126688: PUSH
126689: LD_INT 1
126691: PUSH
126692: EMPTY
126693: LIST
126694: LIST
126695: PUSH
126696: EMPTY
126697: LIST
126698: LIST
126699: LIST
126700: PUSH
126701: EMPTY
126702: LIST
126703: LIST
126704: PPUSH
126705: CALL_OW 69
126709: ST_TO_ADDR
// if not tmp then
126710: LD_VAR 0 4
126714: NOT
126715: IFFALSE 126719
// exit ;
126717: GO 126778
// for i in tmp do
126719: LD_ADDR_VAR 0 2
126723: PUSH
126724: LD_VAR 0 4
126728: PUSH
126729: FOR_IN
126730: IFFALSE 126776
// for j = 1 to 3 do
126732: LD_ADDR_VAR 0 3
126736: PUSH
126737: DOUBLE
126738: LD_INT 1
126740: DEC
126741: ST_TO_ADDR
126742: LD_INT 3
126744: PUSH
126745: FOR_TO
126746: IFFALSE 126772
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
126748: LD_VAR 0 2
126752: PPUSH
126753: CALL_OW 274
126757: PPUSH
126758: LD_VAR 0 3
126762: PPUSH
126763: LD_INT 99999
126765: PPUSH
126766: CALL_OW 277
126770: GO 126745
126772: POP
126773: POP
126774: GO 126729
126776: POP
126777: POP
// end ;
126778: LD_VAR 0 1
126782: RET
// export function hHackSetLevel10 ; var i , j ; begin
126783: LD_INT 0
126785: PPUSH
126786: PPUSH
126787: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
126788: LD_ADDR_VAR 0 2
126792: PUSH
126793: LD_INT 21
126795: PUSH
126796: LD_INT 1
126798: PUSH
126799: EMPTY
126800: LIST
126801: LIST
126802: PPUSH
126803: CALL_OW 69
126807: PUSH
126808: FOR_IN
126809: IFFALSE 126861
// if IsSelected ( i ) then
126811: LD_VAR 0 2
126815: PPUSH
126816: CALL_OW 306
126820: IFFALSE 126859
// begin for j := 1 to 4 do
126822: LD_ADDR_VAR 0 3
126826: PUSH
126827: DOUBLE
126828: LD_INT 1
126830: DEC
126831: ST_TO_ADDR
126832: LD_INT 4
126834: PUSH
126835: FOR_TO
126836: IFFALSE 126857
// SetSkill ( i , j , 10 ) ;
126838: LD_VAR 0 2
126842: PPUSH
126843: LD_VAR 0 3
126847: PPUSH
126848: LD_INT 10
126850: PPUSH
126851: CALL_OW 237
126855: GO 126835
126857: POP
126858: POP
// end ;
126859: GO 126808
126861: POP
126862: POP
// end ;
126863: LD_VAR 0 1
126867: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
126868: LD_INT 0
126870: PPUSH
126871: PPUSH
126872: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
126873: LD_ADDR_VAR 0 2
126877: PUSH
126878: LD_INT 22
126880: PUSH
126881: LD_OWVAR 2
126885: PUSH
126886: EMPTY
126887: LIST
126888: LIST
126889: PUSH
126890: LD_INT 21
126892: PUSH
126893: LD_INT 1
126895: PUSH
126896: EMPTY
126897: LIST
126898: LIST
126899: PUSH
126900: EMPTY
126901: LIST
126902: LIST
126903: PPUSH
126904: CALL_OW 69
126908: PUSH
126909: FOR_IN
126910: IFFALSE 126951
// begin for j := 1 to 4 do
126912: LD_ADDR_VAR 0 3
126916: PUSH
126917: DOUBLE
126918: LD_INT 1
126920: DEC
126921: ST_TO_ADDR
126922: LD_INT 4
126924: PUSH
126925: FOR_TO
126926: IFFALSE 126947
// SetSkill ( i , j , 10 ) ;
126928: LD_VAR 0 2
126932: PPUSH
126933: LD_VAR 0 3
126937: PPUSH
126938: LD_INT 10
126940: PPUSH
126941: CALL_OW 237
126945: GO 126925
126947: POP
126948: POP
// end ;
126949: GO 126909
126951: POP
126952: POP
// end ;
126953: LD_VAR 0 1
126957: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
126958: LD_INT 0
126960: PPUSH
// uc_side := your_side ;
126961: LD_ADDR_OWVAR 20
126965: PUSH
126966: LD_OWVAR 2
126970: ST_TO_ADDR
// uc_nation := nation ;
126971: LD_ADDR_OWVAR 21
126975: PUSH
126976: LD_VAR 0 1
126980: ST_TO_ADDR
// InitHc ;
126981: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
126985: LD_INT 0
126987: PPUSH
126988: LD_VAR 0 2
126992: PPUSH
126993: LD_VAR 0 3
126997: PPUSH
126998: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
127002: LD_VAR 0 4
127006: PPUSH
127007: LD_VAR 0 5
127011: PPUSH
127012: CALL_OW 428
127016: PUSH
127017: LD_INT 0
127019: EQUAL
127020: IFFALSE 127044
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
127022: CALL_OW 44
127026: PPUSH
127027: LD_VAR 0 4
127031: PPUSH
127032: LD_VAR 0 5
127036: PPUSH
127037: LD_INT 1
127039: PPUSH
127040: CALL_OW 48
// end ;
127044: LD_VAR 0 6
127048: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
127049: LD_INT 0
127051: PPUSH
127052: PPUSH
// uc_side := your_side ;
127053: LD_ADDR_OWVAR 20
127057: PUSH
127058: LD_OWVAR 2
127062: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
127063: LD_VAR 0 1
127067: PUSH
127068: LD_INT 1
127070: PUSH
127071: LD_INT 2
127073: PUSH
127074: LD_INT 3
127076: PUSH
127077: LD_INT 4
127079: PUSH
127080: LD_INT 5
127082: PUSH
127083: EMPTY
127084: LIST
127085: LIST
127086: LIST
127087: LIST
127088: LIST
127089: IN
127090: IFFALSE 127102
// uc_nation := nation_american else
127092: LD_ADDR_OWVAR 21
127096: PUSH
127097: LD_INT 1
127099: ST_TO_ADDR
127100: GO 127145
// if chassis in [ 11 , 12 , 13 , 14 ] then
127102: LD_VAR 0 1
127106: PUSH
127107: LD_INT 11
127109: PUSH
127110: LD_INT 12
127112: PUSH
127113: LD_INT 13
127115: PUSH
127116: LD_INT 14
127118: PUSH
127119: EMPTY
127120: LIST
127121: LIST
127122: LIST
127123: LIST
127124: IN
127125: IFFALSE 127137
// uc_nation := nation_arabian else
127127: LD_ADDR_OWVAR 21
127131: PUSH
127132: LD_INT 2
127134: ST_TO_ADDR
127135: GO 127145
// uc_nation := nation_russian ;
127137: LD_ADDR_OWVAR 21
127141: PUSH
127142: LD_INT 3
127144: ST_TO_ADDR
// vc_chassis := chassis ;
127145: LD_ADDR_OWVAR 37
127149: PUSH
127150: LD_VAR 0 1
127154: ST_TO_ADDR
// vc_engine := engine ;
127155: LD_ADDR_OWVAR 39
127159: PUSH
127160: LD_VAR 0 2
127164: ST_TO_ADDR
// vc_control := control ;
127165: LD_ADDR_OWVAR 38
127169: PUSH
127170: LD_VAR 0 3
127174: ST_TO_ADDR
// vc_weapon := weapon ;
127175: LD_ADDR_OWVAR 40
127179: PUSH
127180: LD_VAR 0 4
127184: ST_TO_ADDR
// un := CreateVehicle ;
127185: LD_ADDR_VAR 0 8
127189: PUSH
127190: CALL_OW 45
127194: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
127195: LD_VAR 0 8
127199: PPUSH
127200: LD_INT 0
127202: PPUSH
127203: LD_INT 5
127205: PPUSH
127206: CALL_OW 12
127210: PPUSH
127211: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
127215: LD_VAR 0 8
127219: PPUSH
127220: LD_VAR 0 5
127224: PPUSH
127225: LD_VAR 0 6
127229: PPUSH
127230: LD_INT 1
127232: PPUSH
127233: CALL_OW 48
// end ;
127237: LD_VAR 0 7
127241: RET
// export hInvincible ; every 1 do
127242: GO 127244
127244: DISABLE
// hInvincible := [ ] ;
127245: LD_ADDR_EXP 205
127249: PUSH
127250: EMPTY
127251: ST_TO_ADDR
127252: END
// every 10 do var i ;
127253: GO 127255
127255: DISABLE
127256: LD_INT 0
127258: PPUSH
// begin enable ;
127259: ENABLE
// if not hInvincible then
127260: LD_EXP 205
127264: NOT
127265: IFFALSE 127269
// exit ;
127267: GO 127313
// for i in hInvincible do
127269: LD_ADDR_VAR 0 1
127273: PUSH
127274: LD_EXP 205
127278: PUSH
127279: FOR_IN
127280: IFFALSE 127311
// if GetLives ( i ) < 1000 then
127282: LD_VAR 0 1
127286: PPUSH
127287: CALL_OW 256
127291: PUSH
127292: LD_INT 1000
127294: LESS
127295: IFFALSE 127309
// SetLives ( i , 1000 ) ;
127297: LD_VAR 0 1
127301: PPUSH
127302: LD_INT 1000
127304: PPUSH
127305: CALL_OW 234
127309: GO 127279
127311: POP
127312: POP
// end ;
127313: PPOPN 1
127315: END
// export function hHackInvincible ; var i ; begin
127316: LD_INT 0
127318: PPUSH
127319: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
127320: LD_ADDR_VAR 0 2
127324: PUSH
127325: LD_INT 2
127327: PUSH
127328: LD_INT 21
127330: PUSH
127331: LD_INT 1
127333: PUSH
127334: EMPTY
127335: LIST
127336: LIST
127337: PUSH
127338: LD_INT 21
127340: PUSH
127341: LD_INT 2
127343: PUSH
127344: EMPTY
127345: LIST
127346: LIST
127347: PUSH
127348: EMPTY
127349: LIST
127350: LIST
127351: LIST
127352: PPUSH
127353: CALL_OW 69
127357: PUSH
127358: FOR_IN
127359: IFFALSE 127420
// if IsSelected ( i ) then
127361: LD_VAR 0 2
127365: PPUSH
127366: CALL_OW 306
127370: IFFALSE 127418
// begin if i in hInvincible then
127372: LD_VAR 0 2
127376: PUSH
127377: LD_EXP 205
127381: IN
127382: IFFALSE 127402
// hInvincible := hInvincible diff i else
127384: LD_ADDR_EXP 205
127388: PUSH
127389: LD_EXP 205
127393: PUSH
127394: LD_VAR 0 2
127398: DIFF
127399: ST_TO_ADDR
127400: GO 127418
// hInvincible := hInvincible union i ;
127402: LD_ADDR_EXP 205
127406: PUSH
127407: LD_EXP 205
127411: PUSH
127412: LD_VAR 0 2
127416: UNION
127417: ST_TO_ADDR
// end ;
127418: GO 127358
127420: POP
127421: POP
// end ;
127422: LD_VAR 0 1
127426: RET
// export function hHackInvisible ; var i , j ; begin
127427: LD_INT 0
127429: PPUSH
127430: PPUSH
127431: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
127432: LD_ADDR_VAR 0 2
127436: PUSH
127437: LD_INT 21
127439: PUSH
127440: LD_INT 1
127442: PUSH
127443: EMPTY
127444: LIST
127445: LIST
127446: PPUSH
127447: CALL_OW 69
127451: PUSH
127452: FOR_IN
127453: IFFALSE 127477
// if IsSelected ( i ) then
127455: LD_VAR 0 2
127459: PPUSH
127460: CALL_OW 306
127464: IFFALSE 127475
// ComForceInvisible ( i ) ;
127466: LD_VAR 0 2
127470: PPUSH
127471: CALL_OW 496
127475: GO 127452
127477: POP
127478: POP
// end ;
127479: LD_VAR 0 1
127483: RET
// export function hHackChangeYourSide ; begin
127484: LD_INT 0
127486: PPUSH
// if your_side = 8 then
127487: LD_OWVAR 2
127491: PUSH
127492: LD_INT 8
127494: EQUAL
127495: IFFALSE 127507
// your_side := 0 else
127497: LD_ADDR_OWVAR 2
127501: PUSH
127502: LD_INT 0
127504: ST_TO_ADDR
127505: GO 127521
// your_side := your_side + 1 ;
127507: LD_ADDR_OWVAR 2
127511: PUSH
127512: LD_OWVAR 2
127516: PUSH
127517: LD_INT 1
127519: PLUS
127520: ST_TO_ADDR
// end ;
127521: LD_VAR 0 1
127525: RET
// export function hHackChangeUnitSide ; var i , j ; begin
127526: LD_INT 0
127528: PPUSH
127529: PPUSH
127530: PPUSH
// for i in all_units do
127531: LD_ADDR_VAR 0 2
127535: PUSH
127536: LD_OWVAR 3
127540: PUSH
127541: FOR_IN
127542: IFFALSE 127620
// if IsSelected ( i ) then
127544: LD_VAR 0 2
127548: PPUSH
127549: CALL_OW 306
127553: IFFALSE 127618
// begin j := GetSide ( i ) ;
127555: LD_ADDR_VAR 0 3
127559: PUSH
127560: LD_VAR 0 2
127564: PPUSH
127565: CALL_OW 255
127569: ST_TO_ADDR
// if j = 8 then
127570: LD_VAR 0 3
127574: PUSH
127575: LD_INT 8
127577: EQUAL
127578: IFFALSE 127590
// j := 0 else
127580: LD_ADDR_VAR 0 3
127584: PUSH
127585: LD_INT 0
127587: ST_TO_ADDR
127588: GO 127604
// j := j + 1 ;
127590: LD_ADDR_VAR 0 3
127594: PUSH
127595: LD_VAR 0 3
127599: PUSH
127600: LD_INT 1
127602: PLUS
127603: ST_TO_ADDR
// SetSide ( i , j ) ;
127604: LD_VAR 0 2
127608: PPUSH
127609: LD_VAR 0 3
127613: PPUSH
127614: CALL_OW 235
// end ;
127618: GO 127541
127620: POP
127621: POP
// end ;
127622: LD_VAR 0 1
127626: RET
// export function hHackFog ; begin
127627: LD_INT 0
127629: PPUSH
// FogOff ( true ) ;
127630: LD_INT 1
127632: PPUSH
127633: CALL_OW 344
// end ;
127637: LD_VAR 0 1
127641: RET
// export function hHackTeleport ( unit , x , y ) ; begin
127642: LD_INT 0
127644: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
127645: LD_VAR 0 1
127649: PPUSH
127650: LD_VAR 0 2
127654: PPUSH
127655: LD_VAR 0 3
127659: PPUSH
127660: LD_INT 1
127662: PPUSH
127663: LD_INT 1
127665: PPUSH
127666: CALL_OW 483
// CenterOnXY ( x , y ) ;
127670: LD_VAR 0 2
127674: PPUSH
127675: LD_VAR 0 3
127679: PPUSH
127680: CALL_OW 84
// end ;
127684: LD_VAR 0 4
127688: RET
// export factoryWaypoints , factoryWaypointsDrivers ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
127689: LD_INT 0
127691: PPUSH
127692: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
127693: LD_VAR 0 1
127697: NOT
127698: PUSH
127699: LD_VAR 0 2
127703: PPUSH
127704: LD_VAR 0 3
127708: PPUSH
127709: CALL_OW 488
127713: NOT
127714: OR
127715: PUSH
127716: LD_VAR 0 1
127720: PPUSH
127721: CALL_OW 266
127725: PUSH
127726: LD_INT 3
127728: NONEQUAL
127729: PUSH
127730: LD_VAR 0 1
127734: PPUSH
127735: CALL_OW 247
127739: PUSH
127740: LD_INT 1
127742: EQUAL
127743: NOT
127744: AND
127745: OR
127746: IFFALSE 127750
// exit ;
127748: GO 128032
// if GetType ( factory ) = unit_human then
127750: LD_VAR 0 1
127754: PPUSH
127755: CALL_OW 247
127759: PUSH
127760: LD_INT 1
127762: EQUAL
127763: IFFALSE 127780
// factory := IsInUnit ( factory ) ;
127765: LD_ADDR_VAR 0 1
127769: PUSH
127770: LD_VAR 0 1
127774: PPUSH
127775: CALL_OW 310
127779: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
127780: LD_VAR 0 1
127784: PPUSH
127785: CALL_OW 266
127789: PUSH
127790: LD_INT 3
127792: NONEQUAL
127793: IFFALSE 127797
// exit ;
127795: GO 128032
// for i := 1 to Count ( factoryWaypoints ) do
127797: LD_ADDR_VAR 0 5
127801: PUSH
127802: DOUBLE
127803: LD_INT 1
127805: DEC
127806: ST_TO_ADDR
127807: LD_EXP 206
127811: PPUSH
127812: CALL 72482 0 1
127816: PUSH
127817: FOR_TO
127818: IFFALSE 127980
// begin if HexInfo ( x , y ) = factoryWaypoints [ i ] [ 2 ] then
127820: LD_VAR 0 2
127824: PPUSH
127825: LD_VAR 0 3
127829: PPUSH
127830: CALL_OW 428
127834: PUSH
127835: LD_EXP 206
127839: PUSH
127840: LD_VAR 0 5
127844: ARRAY
127845: PUSH
127846: LD_INT 2
127848: ARRAY
127849: EQUAL
127850: IFFALSE 127882
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
127852: LD_ADDR_EXP 206
127856: PUSH
127857: LD_EXP 206
127861: PPUSH
127862: LD_VAR 0 5
127866: PPUSH
127867: CALL_OW 3
127871: ST_TO_ADDR
// UpdateFactoryWaypoints ;
127872: CALL 128037 0 0
// exit ;
127876: POP
127877: POP
127878: GO 128032
// end else
127880: GO 127978
// if factory = factoryWaypoints [ i ] [ 2 ] then
127882: LD_VAR 0 1
127886: PUSH
127887: LD_EXP 206
127891: PUSH
127892: LD_VAR 0 5
127896: ARRAY
127897: PUSH
127898: LD_INT 2
127900: ARRAY
127901: EQUAL
127902: IFFALSE 127978
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
127904: LD_ADDR_EXP 206
127908: PUSH
127909: LD_EXP 206
127913: PPUSH
127914: LD_VAR 0 5
127918: PPUSH
127919: CALL_OW 3
127923: ST_TO_ADDR
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
127924: LD_ADDR_EXP 206
127928: PUSH
127929: LD_EXP 206
127933: PPUSH
127934: LD_VAR 0 1
127938: PPUSH
127939: CALL_OW 255
127943: PUSH
127944: LD_VAR 0 1
127948: PUSH
127949: LD_VAR 0 2
127953: PUSH
127954: LD_VAR 0 3
127958: PUSH
127959: EMPTY
127960: LIST
127961: LIST
127962: LIST
127963: LIST
127964: PPUSH
127965: CALL 108091 0 2
127969: ST_TO_ADDR
// UpdateFactoryWaypoints ;
127970: CALL 128037 0 0
// exit ;
127974: POP
127975: POP
127976: GO 128032
// end ; end ;
127978: GO 127817
127980: POP
127981: POP
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
127982: LD_ADDR_EXP 206
127986: PUSH
127987: LD_EXP 206
127991: PPUSH
127992: LD_VAR 0 1
127996: PPUSH
127997: CALL_OW 255
128001: PUSH
128002: LD_VAR 0 1
128006: PUSH
128007: LD_VAR 0 2
128011: PUSH
128012: LD_VAR 0 3
128016: PUSH
128017: EMPTY
128018: LIST
128019: LIST
128020: LIST
128021: LIST
128022: PPUSH
128023: CALL 108091 0 2
128027: ST_TO_ADDR
// UpdateFactoryWaypoints ;
128028: CALL 128037 0 0
// end ;
128032: LD_VAR 0 4
128036: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
128037: LD_INT 0
128039: PPUSH
128040: PPUSH
128041: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
128042: LD_STRING resetFactoryWaypoint();
128044: PPUSH
128045: CALL_OW 559
// if factoryWaypoints then
128049: LD_EXP 206
128053: IFFALSE 128174
// begin list := factoryWaypoints ;
128055: LD_ADDR_VAR 0 3
128059: PUSH
128060: LD_EXP 206
128064: ST_TO_ADDR
// for i := 1 to list do
128065: LD_ADDR_VAR 0 2
128069: PUSH
128070: DOUBLE
128071: LD_INT 1
128073: DEC
128074: ST_TO_ADDR
128075: LD_VAR 0 3
128079: PUSH
128080: FOR_TO
128081: IFFALSE 128172
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
128083: LD_STRING setFactoryWaypointXY(
128085: PUSH
128086: LD_VAR 0 3
128090: PUSH
128091: LD_VAR 0 2
128095: ARRAY
128096: PUSH
128097: LD_INT 1
128099: ARRAY
128100: STR
128101: PUSH
128102: LD_STRING ,
128104: STR
128105: PUSH
128106: LD_VAR 0 3
128110: PUSH
128111: LD_VAR 0 2
128115: ARRAY
128116: PUSH
128117: LD_INT 2
128119: ARRAY
128120: STR
128121: PUSH
128122: LD_STRING ,
128124: STR
128125: PUSH
128126: LD_VAR 0 3
128130: PUSH
128131: LD_VAR 0 2
128135: ARRAY
128136: PUSH
128137: LD_INT 3
128139: ARRAY
128140: STR
128141: PUSH
128142: LD_STRING ,
128144: STR
128145: PUSH
128146: LD_VAR 0 3
128150: PUSH
128151: LD_VAR 0 2
128155: ARRAY
128156: PUSH
128157: LD_INT 4
128159: ARRAY
128160: STR
128161: PUSH
128162: LD_STRING )
128164: STR
128165: PPUSH
128166: CALL_OW 559
128170: GO 128080
128172: POP
128173: POP
// end ; end ;
128174: LD_VAR 0 1
128178: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
128179: LD_INT 0
128181: PPUSH
// if HexInfo ( x , y ) = warehouse then
128182: LD_VAR 0 2
128186: PPUSH
128187: LD_VAR 0 3
128191: PPUSH
128192: CALL_OW 428
128196: PUSH
128197: LD_VAR 0 1
128201: EQUAL
128202: IFFALSE 128229
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
128204: LD_ADDR_EXP 208
128208: PUSH
128209: LD_EXP 208
128213: PPUSH
128214: LD_VAR 0 1
128218: PPUSH
128219: LD_INT 0
128221: PPUSH
128222: CALL_OW 1
128226: ST_TO_ADDR
128227: GO 128280
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
128229: LD_ADDR_EXP 208
128233: PUSH
128234: LD_EXP 208
128238: PPUSH
128239: LD_VAR 0 1
128243: PPUSH
128244: LD_VAR 0 1
128248: PPUSH
128249: CALL_OW 255
128253: PUSH
128254: LD_VAR 0 1
128258: PUSH
128259: LD_VAR 0 2
128263: PUSH
128264: LD_VAR 0 3
128268: PUSH
128269: EMPTY
128270: LIST
128271: LIST
128272: LIST
128273: LIST
128274: PPUSH
128275: CALL_OW 1
128279: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
128280: CALL 128289 0 0
// end ;
128284: LD_VAR 0 4
128288: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
128289: LD_INT 0
128291: PPUSH
128292: PPUSH
128293: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
128294: LD_STRING resetWarehouseGatheringPoints();
128296: PPUSH
128297: CALL_OW 559
// if warehouseGatheringPoints then
128301: LD_EXP 208
128305: IFFALSE 128431
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
128307: LD_ADDR_VAR 0 3
128311: PUSH
128312: LD_EXP 208
128316: PPUSH
128317: CALL 111859 0 1
128321: ST_TO_ADDR
// for i := 1 to list do
128322: LD_ADDR_VAR 0 2
128326: PUSH
128327: DOUBLE
128328: LD_INT 1
128330: DEC
128331: ST_TO_ADDR
128332: LD_VAR 0 3
128336: PUSH
128337: FOR_TO
128338: IFFALSE 128429
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
128340: LD_STRING setWarehouseGatheringPointXY(
128342: PUSH
128343: LD_VAR 0 3
128347: PUSH
128348: LD_VAR 0 2
128352: ARRAY
128353: PUSH
128354: LD_INT 1
128356: ARRAY
128357: STR
128358: PUSH
128359: LD_STRING ,
128361: STR
128362: PUSH
128363: LD_VAR 0 3
128367: PUSH
128368: LD_VAR 0 2
128372: ARRAY
128373: PUSH
128374: LD_INT 2
128376: ARRAY
128377: STR
128378: PUSH
128379: LD_STRING ,
128381: STR
128382: PUSH
128383: LD_VAR 0 3
128387: PUSH
128388: LD_VAR 0 2
128392: ARRAY
128393: PUSH
128394: LD_INT 3
128396: ARRAY
128397: STR
128398: PUSH
128399: LD_STRING ,
128401: STR
128402: PUSH
128403: LD_VAR 0 3
128407: PUSH
128408: LD_VAR 0 2
128412: ARRAY
128413: PUSH
128414: LD_INT 4
128416: ARRAY
128417: STR
128418: PUSH
128419: LD_STRING )
128421: STR
128422: PPUSH
128423: CALL_OW 559
128427: GO 128337
128429: POP
128430: POP
// end ; end ;
128431: LD_VAR 0 1
128435: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
128436: LD_EXP 208
128440: IFFALSE 129125
128442: GO 128444
128444: DISABLE
128445: LD_INT 0
128447: PPUSH
128448: PPUSH
128449: PPUSH
128450: PPUSH
128451: PPUSH
128452: PPUSH
128453: PPUSH
128454: PPUSH
128455: PPUSH
// begin enable ;
128456: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
128457: LD_ADDR_VAR 0 3
128461: PUSH
128462: LD_EXP 208
128466: PPUSH
128467: CALL 111859 0 1
128471: ST_TO_ADDR
// if not list then
128472: LD_VAR 0 3
128476: NOT
128477: IFFALSE 128481
// exit ;
128479: GO 129125
// for i := 1 to list do
128481: LD_ADDR_VAR 0 1
128485: PUSH
128486: DOUBLE
128487: LD_INT 1
128489: DEC
128490: ST_TO_ADDR
128491: LD_VAR 0 3
128495: PUSH
128496: FOR_TO
128497: IFFALSE 129123
// begin depot := list [ i ] [ 2 ] ;
128499: LD_ADDR_VAR 0 8
128503: PUSH
128504: LD_VAR 0 3
128508: PUSH
128509: LD_VAR 0 1
128513: ARRAY
128514: PUSH
128515: LD_INT 2
128517: ARRAY
128518: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
128519: LD_ADDR_VAR 0 5
128523: PUSH
128524: LD_VAR 0 3
128528: PUSH
128529: LD_VAR 0 1
128533: ARRAY
128534: PUSH
128535: LD_INT 1
128537: ARRAY
128538: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
128539: LD_VAR 0 8
128543: PPUSH
128544: CALL_OW 301
128548: PUSH
128549: LD_VAR 0 5
128553: PUSH
128554: LD_VAR 0 8
128558: PPUSH
128559: CALL_OW 255
128563: NONEQUAL
128564: OR
128565: IFFALSE 128594
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
128567: LD_ADDR_EXP 208
128571: PUSH
128572: LD_EXP 208
128576: PPUSH
128577: LD_VAR 0 8
128581: PPUSH
128582: LD_INT 0
128584: PPUSH
128585: CALL_OW 1
128589: ST_TO_ADDR
// exit ;
128590: POP
128591: POP
128592: GO 129125
// end ; x := list [ i ] [ 3 ] ;
128594: LD_ADDR_VAR 0 6
128598: PUSH
128599: LD_VAR 0 3
128603: PUSH
128604: LD_VAR 0 1
128608: ARRAY
128609: PUSH
128610: LD_INT 3
128612: ARRAY
128613: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
128614: LD_ADDR_VAR 0 7
128618: PUSH
128619: LD_VAR 0 3
128623: PUSH
128624: LD_VAR 0 1
128628: ARRAY
128629: PUSH
128630: LD_INT 4
128632: ARRAY
128633: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
128634: LD_ADDR_VAR 0 9
128638: PUSH
128639: LD_VAR 0 6
128643: PPUSH
128644: LD_VAR 0 7
128648: PPUSH
128649: LD_INT 16
128651: PPUSH
128652: CALL 110443 0 3
128656: ST_TO_ADDR
// if not cratesNearbyPoint then
128657: LD_VAR 0 9
128661: NOT
128662: IFFALSE 128668
// exit ;
128664: POP
128665: POP
128666: GO 129125
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
128668: LD_ADDR_VAR 0 4
128672: PUSH
128673: LD_INT 22
128675: PUSH
128676: LD_VAR 0 5
128680: PUSH
128681: EMPTY
128682: LIST
128683: LIST
128684: PUSH
128685: LD_INT 3
128687: PUSH
128688: LD_INT 60
128690: PUSH
128691: EMPTY
128692: LIST
128693: PUSH
128694: EMPTY
128695: LIST
128696: LIST
128697: PUSH
128698: LD_INT 91
128700: PUSH
128701: LD_VAR 0 8
128705: PUSH
128706: LD_INT 6
128708: PUSH
128709: EMPTY
128710: LIST
128711: LIST
128712: LIST
128713: PUSH
128714: LD_INT 2
128716: PUSH
128717: LD_INT 25
128719: PUSH
128720: LD_INT 2
128722: PUSH
128723: EMPTY
128724: LIST
128725: LIST
128726: PUSH
128727: LD_INT 25
128729: PUSH
128730: LD_INT 16
128732: PUSH
128733: EMPTY
128734: LIST
128735: LIST
128736: PUSH
128737: EMPTY
128738: LIST
128739: LIST
128740: LIST
128741: PUSH
128742: EMPTY
128743: LIST
128744: LIST
128745: LIST
128746: LIST
128747: PPUSH
128748: CALL_OW 69
128752: PUSH
128753: LD_VAR 0 8
128757: PPUSH
128758: CALL_OW 313
128762: PPUSH
128763: LD_INT 3
128765: PUSH
128766: LD_INT 60
128768: PUSH
128769: EMPTY
128770: LIST
128771: PUSH
128772: EMPTY
128773: LIST
128774: LIST
128775: PUSH
128776: LD_INT 2
128778: PUSH
128779: LD_INT 25
128781: PUSH
128782: LD_INT 2
128784: PUSH
128785: EMPTY
128786: LIST
128787: LIST
128788: PUSH
128789: LD_INT 25
128791: PUSH
128792: LD_INT 16
128794: PUSH
128795: EMPTY
128796: LIST
128797: LIST
128798: PUSH
128799: EMPTY
128800: LIST
128801: LIST
128802: LIST
128803: PUSH
128804: EMPTY
128805: LIST
128806: LIST
128807: PPUSH
128808: CALL_OW 72
128812: UNION
128813: ST_TO_ADDR
// if tmp then
128814: LD_VAR 0 4
128818: IFFALSE 128898
// begin tmp := ShrinkArray ( tmp , 3 ) ;
128820: LD_ADDR_VAR 0 4
128824: PUSH
128825: LD_VAR 0 4
128829: PPUSH
128830: LD_INT 3
128832: PPUSH
128833: CALL 108406 0 2
128837: ST_TO_ADDR
// for j in tmp do
128838: LD_ADDR_VAR 0 2
128842: PUSH
128843: LD_VAR 0 4
128847: PUSH
128848: FOR_IN
128849: IFFALSE 128892
// begin if IsInUnit ( j ) then
128851: LD_VAR 0 2
128855: PPUSH
128856: CALL_OW 310
128860: IFFALSE 128871
// ComExit ( j ) ;
128862: LD_VAR 0 2
128866: PPUSH
128867: CALL 108489 0 1
// AddComCollect ( j , x , y ) ;
128871: LD_VAR 0 2
128875: PPUSH
128876: LD_VAR 0 6
128880: PPUSH
128881: LD_VAR 0 7
128885: PPUSH
128886: CALL_OW 177
// end ;
128890: GO 128848
128892: POP
128893: POP
// exit ;
128894: POP
128895: POP
128896: GO 129125
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
128898: LD_ADDR_VAR 0 4
128902: PUSH
128903: LD_INT 22
128905: PUSH
128906: LD_VAR 0 5
128910: PUSH
128911: EMPTY
128912: LIST
128913: LIST
128914: PUSH
128915: LD_INT 91
128917: PUSH
128918: LD_VAR 0 8
128922: PUSH
128923: LD_INT 8
128925: PUSH
128926: EMPTY
128927: LIST
128928: LIST
128929: LIST
128930: PUSH
128931: LD_INT 2
128933: PUSH
128934: LD_INT 34
128936: PUSH
128937: LD_INT 12
128939: PUSH
128940: EMPTY
128941: LIST
128942: LIST
128943: PUSH
128944: LD_INT 34
128946: PUSH
128947: LD_INT 51
128949: PUSH
128950: EMPTY
128951: LIST
128952: LIST
128953: PUSH
128954: LD_INT 34
128956: PUSH
128957: LD_INT 32
128959: PUSH
128960: EMPTY
128961: LIST
128962: LIST
128963: PUSH
128964: LD_INT 34
128966: PUSH
128967: LD_INT 89
128969: PUSH
128970: EMPTY
128971: LIST
128972: LIST
128973: PUSH
128974: EMPTY
128975: LIST
128976: LIST
128977: LIST
128978: LIST
128979: LIST
128980: PUSH
128981: EMPTY
128982: LIST
128983: LIST
128984: LIST
128985: PPUSH
128986: CALL_OW 69
128990: ST_TO_ADDR
// if tmp then
128991: LD_VAR 0 4
128995: IFFALSE 129121
// begin for j in tmp do
128997: LD_ADDR_VAR 0 2
129001: PUSH
129002: LD_VAR 0 4
129006: PUSH
129007: FOR_IN
129008: IFFALSE 129119
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
129010: LD_VAR 0 2
129014: PPUSH
129015: CALL_OW 262
129019: PUSH
129020: LD_INT 3
129022: EQUAL
129023: PUSH
129024: LD_VAR 0 2
129028: PPUSH
129029: CALL_OW 261
129033: PUSH
129034: LD_INT 20
129036: GREATER
129037: OR
129038: PUSH
129039: LD_VAR 0 2
129043: PPUSH
129044: CALL_OW 314
129048: NOT
129049: AND
129050: PUSH
129051: LD_VAR 0 2
129055: PPUSH
129056: CALL_OW 263
129060: PUSH
129061: LD_INT 1
129063: NONEQUAL
129064: PUSH
129065: LD_VAR 0 2
129069: PPUSH
129070: CALL_OW 311
129074: OR
129075: AND
129076: IFFALSE 129117
// begin ComCollect ( j , x , y ) ;
129078: LD_VAR 0 2
129082: PPUSH
129083: LD_VAR 0 6
129087: PPUSH
129088: LD_VAR 0 7
129092: PPUSH
129093: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
129097: LD_VAR 0 2
129101: PPUSH
129102: LD_VAR 0 8
129106: PPUSH
129107: CALL_OW 172
// exit ;
129111: POP
129112: POP
129113: POP
129114: POP
129115: GO 129125
// end ;
129117: GO 129007
129119: POP
129120: POP
// end ; end ;
129121: GO 128496
129123: POP
129124: POP
// end ; end_of_file
129125: PPOPN 9
129127: END
// export function SOS_UnitDestroyed ( un ) ; begin
129128: LD_INT 0
129130: PPUSH
// ComRadiation ( un ) ;
129131: LD_VAR 0 1
129135: PPUSH
129136: CALL 130197 0 1
// end ;
129140: LD_VAR 0 2
129144: RET
// export function SOS_UnitKamikazed ( un ) ; begin
129145: LD_INT 0
129147: PPUSH
// ComRadiation ( un ) ;
129148: LD_VAR 0 1
129152: PPUSH
129153: CALL 130197 0 1
// end ;
129157: LD_VAR 0 2
129161: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
129162: LD_INT 0
129164: PPUSH
// end ;
129165: LD_VAR 0 4
129169: RET
// export function SOS_Command ( cmd ) ; begin
129170: LD_INT 0
129172: PPUSH
// end ;
129173: LD_VAR 0 2
129177: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
129178: LD_INT 0
129180: PPUSH
// end ;
129181: LD_VAR 0 6
129185: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var i , driver , hex ; begin
129186: LD_INT 0
129188: PPUSH
129189: PPUSH
129190: PPUSH
129191: PPUSH
// if not vehicle or not factory then
129192: LD_VAR 0 1
129196: NOT
129197: PUSH
129198: LD_VAR 0 2
129202: NOT
129203: OR
129204: IFFALSE 129208
// exit ;
129206: GO 129788
// if not factoryWaypoints then
129208: LD_EXP 206
129212: NOT
129213: IFFALSE 129217
// exit ;
129215: GO 129788
// for i := 1 to Count ( factoryWaypoints ) do
129217: LD_ADDR_VAR 0 4
129221: PUSH
129222: DOUBLE
129223: LD_INT 1
129225: DEC
129226: ST_TO_ADDR
129227: LD_EXP 206
129231: PPUSH
129232: CALL 72482 0 1
129236: PUSH
129237: FOR_TO
129238: IFFALSE 129786
// if factoryWaypoints [ i ] [ 2 ] = factory then
129240: LD_EXP 206
129244: PUSH
129245: LD_VAR 0 4
129249: ARRAY
129250: PUSH
129251: LD_INT 2
129253: ARRAY
129254: PUSH
129255: LD_VAR 0 2
129259: EQUAL
129260: IFFALSE 129784
// begin if GetControl ( vehicle ) = control_manual then
129262: LD_VAR 0 1
129266: PPUSH
129267: CALL_OW 263
129271: PUSH
129272: LD_INT 1
129274: EQUAL
129275: IFFALSE 129637
// begin driver := IsDrivenBy ( vehicle ) ;
129277: LD_ADDR_VAR 0 5
129281: PUSH
129282: LD_VAR 0 1
129286: PPUSH
129287: CALL_OW 311
129291: ST_TO_ADDR
// if driver in factoryWaypointsDrivers or vehicle in factoryWaypointsDrivers then
129292: LD_VAR 0 5
129296: PUSH
129297: LD_EXP 207
129301: IN
129302: PUSH
129303: LD_VAR 0 1
129307: PUSH
129308: LD_EXP 207
129312: IN
129313: OR
129314: IFFALSE 129320
// exit ;
129316: POP
129317: POP
129318: GO 129788
// if not HasTask ( driver ) then
129320: LD_VAR 0 5
129324: PPUSH
129325: CALL_OW 314
129329: NOT
129330: IFFALSE 129635
// begin factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , driver ) ;
129332: LD_ADDR_EXP 207
129336: PUSH
129337: LD_EXP 207
129341: PPUSH
129342: LD_VAR 0 5
129346: PPUSH
129347: CALL 108091 0 2
129351: ST_TO_ADDR
// factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , vehicle ) ;
129352: LD_ADDR_EXP 207
129356: PUSH
129357: LD_EXP 207
129361: PPUSH
129362: LD_VAR 0 1
129366: PPUSH
129367: CALL 108091 0 2
129371: ST_TO_ADDR
// hex := HexInfo ( factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
129372: LD_ADDR_VAR 0 6
129376: PUSH
129377: LD_EXP 206
129381: PUSH
129382: LD_VAR 0 4
129386: ARRAY
129387: PUSH
129388: LD_INT 3
129390: ARRAY
129391: PPUSH
129392: LD_EXP 206
129396: PUSH
129397: LD_VAR 0 4
129401: ARRAY
129402: PUSH
129403: LD_INT 4
129405: ARRAY
129406: PPUSH
129407: CALL_OW 428
129411: ST_TO_ADDR
// if hex then
129412: LD_VAR 0 6
129416: IFFALSE 129434
// ComMoveUnit ( driver , hex ) else
129418: LD_VAR 0 5
129422: PPUSH
129423: LD_VAR 0 6
129427: PPUSH
129428: CALL_OW 112
129432: GO 129518
// if GetDistUnitXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) > 0 then
129434: LD_VAR 0 1
129438: PPUSH
129439: LD_EXP 206
129443: PUSH
129444: LD_VAR 0 4
129448: ARRAY
129449: PUSH
129450: LD_INT 3
129452: ARRAY
129453: PPUSH
129454: LD_EXP 206
129458: PUSH
129459: LD_VAR 0 4
129463: ARRAY
129464: PUSH
129465: LD_INT 4
129467: ARRAY
129468: PPUSH
129469: CALL_OW 297
129473: PUSH
129474: LD_INT 0
129476: GREATER
129477: IFFALSE 129518
// ComMoveXY ( driver , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
129479: LD_VAR 0 5
129483: PPUSH
129484: LD_EXP 206
129488: PUSH
129489: LD_VAR 0 4
129493: ARRAY
129494: PUSH
129495: LD_INT 3
129497: ARRAY
129498: PPUSH
129499: LD_EXP 206
129503: PUSH
129504: LD_VAR 0 4
129508: ARRAY
129509: PUSH
129510: LD_INT 4
129512: ARRAY
129513: PPUSH
129514: CALL_OW 111
// AddComExitVehicle ( driver ) ;
129518: LD_VAR 0 5
129522: PPUSH
129523: CALL_OW 181
// if Multiplayer then
129527: LD_OWVAR 4
129531: IFFALSE 129580
// begin repeat wait ( 10 ) ;
129533: LD_INT 10
129535: PPUSH
129536: CALL_OW 67
// until not IsInUnit ( driver ) ;
129540: LD_VAR 0 5
129544: PPUSH
129545: CALL_OW 310
129549: NOT
129550: IFFALSE 129533
// if not HasTask ( driver ) then
129552: LD_VAR 0 5
129556: PPUSH
129557: CALL_OW 314
129561: NOT
129562: IFFALSE 129578
// ComEnterUnit ( driver , factory ) ;
129564: LD_VAR 0 5
129568: PPUSH
129569: LD_VAR 0 2
129573: PPUSH
129574: CALL_OW 120
// end else
129578: GO 129594
// AddComEnterUnit ( driver , factory ) ;
129580: LD_VAR 0 5
129584: PPUSH
129585: LD_VAR 0 2
129589: PPUSH
129590: CALL_OW 180
// wait ( 0 0$1 ) ;
129594: LD_INT 35
129596: PPUSH
129597: CALL_OW 67
// factoryWaypointsDrivers := factoryWaypointsDrivers diff driver ;
129601: LD_ADDR_EXP 207
129605: PUSH
129606: LD_EXP 207
129610: PUSH
129611: LD_VAR 0 5
129615: DIFF
129616: ST_TO_ADDR
// factoryWaypointsDrivers := factoryWaypointsDrivers diff vehicle ;
129617: LD_ADDR_EXP 207
129621: PUSH
129622: LD_EXP 207
129626: PUSH
129627: LD_VAR 0 1
129631: DIFF
129632: ST_TO_ADDR
// break ;
129633: GO 129786
// end ; end else
129635: GO 129784
// if GetControl ( vehicle ) = control_remote then
129637: LD_VAR 0 1
129641: PPUSH
129642: CALL_OW 263
129646: PUSH
129647: LD_INT 2
129649: EQUAL
129650: IFFALSE 129736
// begin wait ( 0 0$2 ) ;
129652: LD_INT 70
129654: PPUSH
129655: CALL_OW 67
// repeat wait ( 10 ) ;
129659: LD_INT 10
129661: PPUSH
129662: CALL_OW 67
// Connect ( vehicle ) ;
129666: LD_VAR 0 1
129670: PPUSH
129671: CALL 78688 0 1
// until IsControledBy ( vehicle ) ;
129675: LD_VAR 0 1
129679: PPUSH
129680: CALL_OW 312
129684: IFFALSE 129659
// wait ( 10 ) ;
129686: LD_INT 10
129688: PPUSH
129689: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
129693: LD_VAR 0 1
129697: PPUSH
129698: LD_EXP 206
129702: PUSH
129703: LD_VAR 0 4
129707: ARRAY
129708: PUSH
129709: LD_INT 3
129711: ARRAY
129712: PPUSH
129713: LD_EXP 206
129717: PUSH
129718: LD_VAR 0 4
129722: ARRAY
129723: PUSH
129724: LD_INT 4
129726: ARRAY
129727: PPUSH
129728: CALL_OW 111
// break ;
129732: GO 129786
// end else
129734: GO 129784
// begin wait ( 0 0$3 ) ;
129736: LD_INT 105
129738: PPUSH
129739: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
129743: LD_VAR 0 1
129747: PPUSH
129748: LD_EXP 206
129752: PUSH
129753: LD_VAR 0 4
129757: ARRAY
129758: PUSH
129759: LD_INT 3
129761: ARRAY
129762: PPUSH
129763: LD_EXP 206
129767: PUSH
129768: LD_VAR 0 4
129772: ARRAY
129773: PUSH
129774: LD_INT 4
129776: ARRAY
129777: PPUSH
129778: CALL_OW 111
// break ;
129782: GO 129786
// end ; end ;
129784: GO 129237
129786: POP
129787: POP
// end ;
129788: LD_VAR 0 3
129792: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
129793: LD_INT 0
129795: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
129796: LD_VAR 0 1
129800: PUSH
129801: LD_INT 250
129803: EQUAL
129804: PUSH
129805: LD_VAR 0 2
129809: PPUSH
129810: CALL_OW 264
129814: PUSH
129815: LD_INT 81
129817: EQUAL
129818: AND
129819: IFFALSE 129840
// MinerPlaceMine ( unit , x , y ) ;
129821: LD_VAR 0 2
129825: PPUSH
129826: LD_VAR 0 4
129830: PPUSH
129831: LD_VAR 0 5
129835: PPUSH
129836: CALL 132932 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
129840: LD_VAR 0 1
129844: PUSH
129845: LD_INT 251
129847: EQUAL
129848: PUSH
129849: LD_VAR 0 2
129853: PPUSH
129854: CALL_OW 264
129858: PUSH
129859: LD_INT 81
129861: EQUAL
129862: AND
129863: IFFALSE 129884
// MinerDetonateMine ( unit , x , y ) ;
129865: LD_VAR 0 2
129869: PPUSH
129870: LD_VAR 0 4
129874: PPUSH
129875: LD_VAR 0 5
129879: PPUSH
129880: CALL 133207 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
129884: LD_VAR 0 1
129888: PUSH
129889: LD_INT 252
129891: EQUAL
129892: PUSH
129893: LD_VAR 0 2
129897: PPUSH
129898: CALL_OW 264
129902: PUSH
129903: LD_INT 81
129905: EQUAL
129906: AND
129907: IFFALSE 129928
// MinerCreateMinefield ( unit , x , y ) ;
129909: LD_VAR 0 2
129913: PPUSH
129914: LD_VAR 0 4
129918: PPUSH
129919: LD_VAR 0 5
129923: PPUSH
129924: CALL 133624 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
129928: LD_VAR 0 1
129932: PUSH
129933: LD_INT 253
129935: EQUAL
129936: PUSH
129937: LD_VAR 0 2
129941: PPUSH
129942: CALL_OW 257
129946: PUSH
129947: LD_INT 5
129949: EQUAL
129950: AND
129951: IFFALSE 129972
// ComBinocular ( unit , x , y ) ;
129953: LD_VAR 0 2
129957: PPUSH
129958: LD_VAR 0 4
129962: PPUSH
129963: LD_VAR 0 5
129967: PPUSH
129968: CALL 133993 0 3
// if selectedUnit then
129972: LD_VAR 0 3
129976: IFFALSE 130032
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
129978: LD_VAR 0 1
129982: PUSH
129983: LD_INT 254
129985: EQUAL
129986: PUSH
129987: LD_VAR 0 2
129991: PPUSH
129992: CALL_OW 264
129996: PUSH
129997: LD_INT 99
129999: EQUAL
130000: AND
130001: PUSH
130002: LD_VAR 0 3
130006: PPUSH
130007: CALL_OW 263
130011: PUSH
130012: LD_INT 3
130014: EQUAL
130015: AND
130016: IFFALSE 130032
// HackDestroyVehicle ( unit , selectedUnit ) ;
130018: LD_VAR 0 2
130022: PPUSH
130023: LD_VAR 0 3
130027: PPUSH
130028: CALL 132296 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
130032: LD_VAR 0 1
130036: PUSH
130037: LD_INT 255
130039: EQUAL
130040: PUSH
130041: LD_VAR 0 2
130045: PPUSH
130046: CALL_OW 264
130050: PUSH
130051: LD_INT 14
130053: PUSH
130054: LD_INT 53
130056: PUSH
130057: EMPTY
130058: LIST
130059: LIST
130060: IN
130061: AND
130062: PUSH
130063: LD_VAR 0 4
130067: PPUSH
130068: LD_VAR 0 5
130072: PPUSH
130073: CALL_OW 488
130077: AND
130078: IFFALSE 130102
// CutTreeXYR ( unit , x , y , 12 ) ;
130080: LD_VAR 0 2
130084: PPUSH
130085: LD_VAR 0 4
130089: PPUSH
130090: LD_VAR 0 5
130094: PPUSH
130095: LD_INT 12
130097: PPUSH
130098: CALL 130293 0 4
// if cmd = 256 then
130102: LD_VAR 0 1
130106: PUSH
130107: LD_INT 256
130109: EQUAL
130110: IFFALSE 130131
// SetFactoryWaypoint ( unit , x , y ) ;
130112: LD_VAR 0 2
130116: PPUSH
130117: LD_VAR 0 4
130121: PPUSH
130122: LD_VAR 0 5
130126: PPUSH
130127: CALL 127689 0 3
// if cmd = 257 then
130131: LD_VAR 0 1
130135: PUSH
130136: LD_INT 257
130138: EQUAL
130139: IFFALSE 130160
// SetWarehouseGatheringPoint ( unit , x , y ) ;
130141: LD_VAR 0 2
130145: PPUSH
130146: LD_VAR 0 4
130150: PPUSH
130151: LD_VAR 0 5
130155: PPUSH
130156: CALL 128179 0 3
// if cmd = 258 then
130160: LD_VAR 0 1
130164: PUSH
130165: LD_INT 258
130167: EQUAL
130168: IFFALSE 130192
// BurnTreeXYR ( unit , x , y , 8 ) ;
130170: LD_VAR 0 2
130174: PPUSH
130175: LD_VAR 0 4
130179: PPUSH
130180: LD_VAR 0 5
130184: PPUSH
130185: LD_INT 8
130187: PPUSH
130188: CALL 130687 0 4
// end ;
130192: LD_VAR 0 6
130196: RET
// export function ComRadiation ( un ) ; var eff ; begin
130197: LD_INT 0
130199: PPUSH
130200: PPUSH
// if GetWeapon ( un ) <> ar_bio_bomb then
130201: LD_VAR 0 1
130205: PPUSH
130206: CALL_OW 264
130210: PUSH
130211: LD_INT 91
130213: NONEQUAL
130214: IFFALSE 130218
// exit ;
130216: GO 130288
// if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
130218: LD_INT 68
130220: PPUSH
130221: LD_VAR 0 1
130225: PPUSH
130226: CALL_OW 255
130230: PPUSH
130231: CALL_OW 321
130235: PUSH
130236: LD_INT 2
130238: EQUAL
130239: IFFALSE 130251
// eff := 50 else
130241: LD_ADDR_VAR 0 3
130245: PUSH
130246: LD_INT 50
130248: ST_TO_ADDR
130249: GO 130259
// eff := 25 ;
130251: LD_ADDR_VAR 0 3
130255: PUSH
130256: LD_INT 25
130258: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
130259: LD_VAR 0 1
130263: PPUSH
130264: CALL_OW 250
130268: PPUSH
130269: LD_VAR 0 1
130273: PPUSH
130274: CALL_OW 251
130278: PPUSH
130279: LD_VAR 0 3
130283: PPUSH
130284: CALL_OW 495
// end ;
130288: LD_VAR 0 2
130292: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
130293: LD_INT 0
130295: PPUSH
130296: PPUSH
130297: PPUSH
130298: PPUSH
130299: PPUSH
130300: PPUSH
130301: PPUSH
130302: PPUSH
130303: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
130304: LD_VAR 0 1
130308: PPUSH
130309: CALL_OW 302
130313: NOT
130314: PUSH
130315: LD_VAR 0 2
130319: PPUSH
130320: LD_VAR 0 3
130324: PPUSH
130325: CALL_OW 488
130329: NOT
130330: OR
130331: PUSH
130332: LD_VAR 0 4
130336: NOT
130337: OR
130338: IFFALSE 130342
// exit ;
130340: GO 130682
// list := [ ] ;
130342: LD_ADDR_VAR 0 13
130346: PUSH
130347: EMPTY
130348: ST_TO_ADDR
// if x - r < 0 then
130349: LD_VAR 0 2
130353: PUSH
130354: LD_VAR 0 4
130358: MINUS
130359: PUSH
130360: LD_INT 0
130362: LESS
130363: IFFALSE 130375
// min_x := 0 else
130365: LD_ADDR_VAR 0 7
130369: PUSH
130370: LD_INT 0
130372: ST_TO_ADDR
130373: GO 130391
// min_x := x - r ;
130375: LD_ADDR_VAR 0 7
130379: PUSH
130380: LD_VAR 0 2
130384: PUSH
130385: LD_VAR 0 4
130389: MINUS
130390: ST_TO_ADDR
// if y - r < 0 then
130391: LD_VAR 0 3
130395: PUSH
130396: LD_VAR 0 4
130400: MINUS
130401: PUSH
130402: LD_INT 0
130404: LESS
130405: IFFALSE 130417
// min_y := 0 else
130407: LD_ADDR_VAR 0 8
130411: PUSH
130412: LD_INT 0
130414: ST_TO_ADDR
130415: GO 130433
// min_y := y - r ;
130417: LD_ADDR_VAR 0 8
130421: PUSH
130422: LD_VAR 0 3
130426: PUSH
130427: LD_VAR 0 4
130431: MINUS
130432: ST_TO_ADDR
// max_x := x + r ;
130433: LD_ADDR_VAR 0 9
130437: PUSH
130438: LD_VAR 0 2
130442: PUSH
130443: LD_VAR 0 4
130447: PLUS
130448: ST_TO_ADDR
// max_y := y + r ;
130449: LD_ADDR_VAR 0 10
130453: PUSH
130454: LD_VAR 0 3
130458: PUSH
130459: LD_VAR 0 4
130463: PLUS
130464: ST_TO_ADDR
// for _x = min_x to max_x do
130465: LD_ADDR_VAR 0 11
130469: PUSH
130470: DOUBLE
130471: LD_VAR 0 7
130475: DEC
130476: ST_TO_ADDR
130477: LD_VAR 0 9
130481: PUSH
130482: FOR_TO
130483: IFFALSE 130600
// for _y = min_y to max_y do
130485: LD_ADDR_VAR 0 12
130489: PUSH
130490: DOUBLE
130491: LD_VAR 0 8
130495: DEC
130496: ST_TO_ADDR
130497: LD_VAR 0 10
130501: PUSH
130502: FOR_TO
130503: IFFALSE 130596
// begin if not ValidHex ( _x , _y ) then
130505: LD_VAR 0 11
130509: PPUSH
130510: LD_VAR 0 12
130514: PPUSH
130515: CALL_OW 488
130519: NOT
130520: IFFALSE 130524
// continue ;
130522: GO 130502
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
130524: LD_VAR 0 11
130528: PPUSH
130529: LD_VAR 0 12
130533: PPUSH
130534: CALL_OW 351
130538: PUSH
130539: LD_VAR 0 11
130543: PPUSH
130544: LD_VAR 0 12
130548: PPUSH
130549: CALL_OW 554
130553: AND
130554: IFFALSE 130594
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
130556: LD_ADDR_VAR 0 13
130560: PUSH
130561: LD_VAR 0 13
130565: PPUSH
130566: LD_VAR 0 13
130570: PUSH
130571: LD_INT 1
130573: PLUS
130574: PPUSH
130575: LD_VAR 0 11
130579: PUSH
130580: LD_VAR 0 12
130584: PUSH
130585: EMPTY
130586: LIST
130587: LIST
130588: PPUSH
130589: CALL_OW 2
130593: ST_TO_ADDR
// end ;
130594: GO 130502
130596: POP
130597: POP
130598: GO 130482
130600: POP
130601: POP
// if not list then
130602: LD_VAR 0 13
130606: NOT
130607: IFFALSE 130611
// exit ;
130609: GO 130682
// for i in list do
130611: LD_ADDR_VAR 0 6
130615: PUSH
130616: LD_VAR 0 13
130620: PUSH
130621: FOR_IN
130622: IFFALSE 130680
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
130624: LD_VAR 0 1
130628: PPUSH
130629: LD_STRING M
130631: PUSH
130632: LD_VAR 0 6
130636: PUSH
130637: LD_INT 1
130639: ARRAY
130640: PUSH
130641: LD_VAR 0 6
130645: PUSH
130646: LD_INT 2
130648: ARRAY
130649: PUSH
130650: LD_INT 0
130652: PUSH
130653: LD_INT 0
130655: PUSH
130656: LD_INT 0
130658: PUSH
130659: LD_INT 0
130661: PUSH
130662: EMPTY
130663: LIST
130664: LIST
130665: LIST
130666: LIST
130667: LIST
130668: LIST
130669: LIST
130670: PUSH
130671: EMPTY
130672: LIST
130673: PPUSH
130674: CALL_OW 447
130678: GO 130621
130680: POP
130681: POP
// end ;
130682: LD_VAR 0 5
130686: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
130687: LD_INT 0
130689: PPUSH
130690: PPUSH
130691: PPUSH
130692: PPUSH
130693: PPUSH
130694: PPUSH
130695: PPUSH
130696: PPUSH
130697: PPUSH
130698: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
130699: LD_VAR 0 1
130703: PPUSH
130704: CALL_OW 302
130708: NOT
130709: PUSH
130710: LD_VAR 0 2
130714: PPUSH
130715: LD_VAR 0 3
130719: PPUSH
130720: CALL_OW 488
130724: NOT
130725: OR
130726: PUSH
130727: LD_VAR 0 4
130731: NOT
130732: OR
130733: IFFALSE 130737
// exit ;
130735: GO 131250
// list := [ ] ;
130737: LD_ADDR_VAR 0 13
130741: PUSH
130742: EMPTY
130743: ST_TO_ADDR
// if x - r < 0 then
130744: LD_VAR 0 2
130748: PUSH
130749: LD_VAR 0 4
130753: MINUS
130754: PUSH
130755: LD_INT 0
130757: LESS
130758: IFFALSE 130770
// min_x := 0 else
130760: LD_ADDR_VAR 0 7
130764: PUSH
130765: LD_INT 0
130767: ST_TO_ADDR
130768: GO 130786
// min_x := x - r ;
130770: LD_ADDR_VAR 0 7
130774: PUSH
130775: LD_VAR 0 2
130779: PUSH
130780: LD_VAR 0 4
130784: MINUS
130785: ST_TO_ADDR
// if y - r < 0 then
130786: LD_VAR 0 3
130790: PUSH
130791: LD_VAR 0 4
130795: MINUS
130796: PUSH
130797: LD_INT 0
130799: LESS
130800: IFFALSE 130812
// min_y := 0 else
130802: LD_ADDR_VAR 0 8
130806: PUSH
130807: LD_INT 0
130809: ST_TO_ADDR
130810: GO 130828
// min_y := y - r ;
130812: LD_ADDR_VAR 0 8
130816: PUSH
130817: LD_VAR 0 3
130821: PUSH
130822: LD_VAR 0 4
130826: MINUS
130827: ST_TO_ADDR
// max_x := x + r ;
130828: LD_ADDR_VAR 0 9
130832: PUSH
130833: LD_VAR 0 2
130837: PUSH
130838: LD_VAR 0 4
130842: PLUS
130843: ST_TO_ADDR
// max_y := y + r ;
130844: LD_ADDR_VAR 0 10
130848: PUSH
130849: LD_VAR 0 3
130853: PUSH
130854: LD_VAR 0 4
130858: PLUS
130859: ST_TO_ADDR
// for _x = min_x to max_x do
130860: LD_ADDR_VAR 0 11
130864: PUSH
130865: DOUBLE
130866: LD_VAR 0 7
130870: DEC
130871: ST_TO_ADDR
130872: LD_VAR 0 9
130876: PUSH
130877: FOR_TO
130878: IFFALSE 130995
// for _y = min_y to max_y do
130880: LD_ADDR_VAR 0 12
130884: PUSH
130885: DOUBLE
130886: LD_VAR 0 8
130890: DEC
130891: ST_TO_ADDR
130892: LD_VAR 0 10
130896: PUSH
130897: FOR_TO
130898: IFFALSE 130991
// begin if not ValidHex ( _x , _y ) then
130900: LD_VAR 0 11
130904: PPUSH
130905: LD_VAR 0 12
130909: PPUSH
130910: CALL_OW 488
130914: NOT
130915: IFFALSE 130919
// continue ;
130917: GO 130897
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
130919: LD_VAR 0 11
130923: PPUSH
130924: LD_VAR 0 12
130928: PPUSH
130929: CALL_OW 351
130933: PUSH
130934: LD_VAR 0 11
130938: PPUSH
130939: LD_VAR 0 12
130943: PPUSH
130944: CALL_OW 554
130948: AND
130949: IFFALSE 130989
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
130951: LD_ADDR_VAR 0 13
130955: PUSH
130956: LD_VAR 0 13
130960: PPUSH
130961: LD_VAR 0 13
130965: PUSH
130966: LD_INT 1
130968: PLUS
130969: PPUSH
130970: LD_VAR 0 11
130974: PUSH
130975: LD_VAR 0 12
130979: PUSH
130980: EMPTY
130981: LIST
130982: LIST
130983: PPUSH
130984: CALL_OW 2
130988: ST_TO_ADDR
// end ;
130989: GO 130897
130991: POP
130992: POP
130993: GO 130877
130995: POP
130996: POP
// if not list then
130997: LD_VAR 0 13
131001: NOT
131002: IFFALSE 131006
// exit ;
131004: GO 131250
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
131006: LD_ADDR_VAR 0 13
131010: PUSH
131011: LD_VAR 0 1
131015: PPUSH
131016: LD_VAR 0 13
131020: PPUSH
131021: LD_INT 1
131023: PPUSH
131024: LD_INT 1
131026: PPUSH
131027: CALL 75830 0 4
131031: ST_TO_ADDR
// ComStop ( flame ) ;
131032: LD_VAR 0 1
131036: PPUSH
131037: CALL_OW 141
// for i in list do
131041: LD_ADDR_VAR 0 6
131045: PUSH
131046: LD_VAR 0 13
131050: PUSH
131051: FOR_IN
131052: IFFALSE 131083
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
131054: LD_VAR 0 1
131058: PPUSH
131059: LD_VAR 0 6
131063: PUSH
131064: LD_INT 1
131066: ARRAY
131067: PPUSH
131068: LD_VAR 0 6
131072: PUSH
131073: LD_INT 2
131075: ARRAY
131076: PPUSH
131077: CALL_OW 176
131081: GO 131051
131083: POP
131084: POP
// repeat wait ( 0 0$1 ) ;
131085: LD_INT 35
131087: PPUSH
131088: CALL_OW 67
// task := GetTaskList ( flame ) ;
131092: LD_ADDR_VAR 0 14
131096: PUSH
131097: LD_VAR 0 1
131101: PPUSH
131102: CALL_OW 437
131106: ST_TO_ADDR
// if not task then
131107: LD_VAR 0 14
131111: NOT
131112: IFFALSE 131116
// exit ;
131114: GO 131250
// if task [ 1 ] [ 1 ] <> | then
131116: LD_VAR 0 14
131120: PUSH
131121: LD_INT 1
131123: ARRAY
131124: PUSH
131125: LD_INT 1
131127: ARRAY
131128: PUSH
131129: LD_STRING |
131131: NONEQUAL
131132: IFFALSE 131136
// exit ;
131134: GO 131250
// _x := task [ 1 ] [ 2 ] ;
131136: LD_ADDR_VAR 0 11
131140: PUSH
131141: LD_VAR 0 14
131145: PUSH
131146: LD_INT 1
131148: ARRAY
131149: PUSH
131150: LD_INT 2
131152: ARRAY
131153: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
131154: LD_ADDR_VAR 0 12
131158: PUSH
131159: LD_VAR 0 14
131163: PUSH
131164: LD_INT 1
131166: ARRAY
131167: PUSH
131168: LD_INT 3
131170: ARRAY
131171: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
131172: LD_VAR 0 11
131176: PPUSH
131177: LD_VAR 0 12
131181: PPUSH
131182: CALL_OW 351
131186: NOT
131187: PUSH
131188: LD_VAR 0 11
131192: PPUSH
131193: LD_VAR 0 12
131197: PPUSH
131198: CALL_OW 554
131202: NOT
131203: OR
131204: IFFALSE 131238
// begin task := Delete ( task , 1 ) ;
131206: LD_ADDR_VAR 0 14
131210: PUSH
131211: LD_VAR 0 14
131215: PPUSH
131216: LD_INT 1
131218: PPUSH
131219: CALL_OW 3
131223: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
131224: LD_VAR 0 1
131228: PPUSH
131229: LD_VAR 0 14
131233: PPUSH
131234: CALL_OW 446
// end ; until not HasTask ( flame ) ;
131238: LD_VAR 0 1
131242: PPUSH
131243: CALL_OW 314
131247: NOT
131248: IFFALSE 131085
// end ;
131250: LD_VAR 0 5
131254: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
131255: LD_EXP 210
131259: NOT
131260: IFFALSE 131310
131262: GO 131264
131264: DISABLE
// begin initHack := true ;
131265: LD_ADDR_EXP 210
131269: PUSH
131270: LD_INT 1
131272: ST_TO_ADDR
// hackTanks := [ ] ;
131273: LD_ADDR_EXP 211
131277: PUSH
131278: EMPTY
131279: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
131280: LD_ADDR_EXP 212
131284: PUSH
131285: EMPTY
131286: ST_TO_ADDR
// hackLimit := 3 ;
131287: LD_ADDR_EXP 213
131291: PUSH
131292: LD_INT 3
131294: ST_TO_ADDR
// hackDist := 12 ;
131295: LD_ADDR_EXP 214
131299: PUSH
131300: LD_INT 12
131302: ST_TO_ADDR
// hackCounter := [ ] ;
131303: LD_ADDR_EXP 215
131307: PUSH
131308: EMPTY
131309: ST_TO_ADDR
// end ;
131310: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
131311: LD_EXP 210
131315: PUSH
131316: LD_INT 34
131318: PUSH
131319: LD_INT 99
131321: PUSH
131322: EMPTY
131323: LIST
131324: LIST
131325: PPUSH
131326: CALL_OW 69
131330: AND
131331: IFFALSE 131584
131333: GO 131335
131335: DISABLE
131336: LD_INT 0
131338: PPUSH
131339: PPUSH
// begin enable ;
131340: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
131341: LD_ADDR_VAR 0 1
131345: PUSH
131346: LD_INT 34
131348: PUSH
131349: LD_INT 99
131351: PUSH
131352: EMPTY
131353: LIST
131354: LIST
131355: PPUSH
131356: CALL_OW 69
131360: PUSH
131361: FOR_IN
131362: IFFALSE 131582
// begin if not i in hackTanks then
131364: LD_VAR 0 1
131368: PUSH
131369: LD_EXP 211
131373: IN
131374: NOT
131375: IFFALSE 131458
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
131377: LD_ADDR_EXP 211
131381: PUSH
131382: LD_EXP 211
131386: PPUSH
131387: LD_EXP 211
131391: PUSH
131392: LD_INT 1
131394: PLUS
131395: PPUSH
131396: LD_VAR 0 1
131400: PPUSH
131401: CALL_OW 1
131405: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
131406: LD_ADDR_EXP 212
131410: PUSH
131411: LD_EXP 212
131415: PPUSH
131416: LD_EXP 212
131420: PUSH
131421: LD_INT 1
131423: PLUS
131424: PPUSH
131425: EMPTY
131426: PPUSH
131427: CALL_OW 1
131431: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
131432: LD_ADDR_EXP 215
131436: PUSH
131437: LD_EXP 215
131441: PPUSH
131442: LD_EXP 215
131446: PUSH
131447: LD_INT 1
131449: PLUS
131450: PPUSH
131451: EMPTY
131452: PPUSH
131453: CALL_OW 1
131457: ST_TO_ADDR
// end ; if not IsOk ( i ) then
131458: LD_VAR 0 1
131462: PPUSH
131463: CALL_OW 302
131467: NOT
131468: IFFALSE 131481
// begin HackUnlinkAll ( i ) ;
131470: LD_VAR 0 1
131474: PPUSH
131475: CALL 131587 0 1
// continue ;
131479: GO 131361
// end ; HackCheckCapturedStatus ( i ) ;
131481: LD_VAR 0 1
131485: PPUSH
131486: CALL 132030 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
131490: LD_ADDR_VAR 0 2
131494: PUSH
131495: LD_INT 81
131497: PUSH
131498: LD_VAR 0 1
131502: PPUSH
131503: CALL_OW 255
131507: PUSH
131508: EMPTY
131509: LIST
131510: LIST
131511: PUSH
131512: LD_INT 33
131514: PUSH
131515: LD_INT 3
131517: PUSH
131518: EMPTY
131519: LIST
131520: LIST
131521: PUSH
131522: LD_INT 91
131524: PUSH
131525: LD_VAR 0 1
131529: PUSH
131530: LD_EXP 214
131534: PUSH
131535: EMPTY
131536: LIST
131537: LIST
131538: LIST
131539: PUSH
131540: LD_INT 50
131542: PUSH
131543: EMPTY
131544: LIST
131545: PUSH
131546: EMPTY
131547: LIST
131548: LIST
131549: LIST
131550: LIST
131551: PPUSH
131552: CALL_OW 69
131556: ST_TO_ADDR
// if not tmp then
131557: LD_VAR 0 2
131561: NOT
131562: IFFALSE 131566
// continue ;
131564: GO 131361
// HackLink ( i , tmp ) ;
131566: LD_VAR 0 1
131570: PPUSH
131571: LD_VAR 0 2
131575: PPUSH
131576: CALL 131723 0 2
// end ;
131580: GO 131361
131582: POP
131583: POP
// end ;
131584: PPOPN 2
131586: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
131587: LD_INT 0
131589: PPUSH
131590: PPUSH
131591: PPUSH
// if not hack in hackTanks then
131592: LD_VAR 0 1
131596: PUSH
131597: LD_EXP 211
131601: IN
131602: NOT
131603: IFFALSE 131607
// exit ;
131605: GO 131718
// index := GetElementIndex ( hackTanks , hack ) ;
131607: LD_ADDR_VAR 0 4
131611: PUSH
131612: LD_EXP 211
131616: PPUSH
131617: LD_VAR 0 1
131621: PPUSH
131622: CALL 75127 0 2
131626: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
131627: LD_EXP 212
131631: PUSH
131632: LD_VAR 0 4
131636: ARRAY
131637: IFFALSE 131718
// begin for i in hackTanksCaptured [ index ] do
131639: LD_ADDR_VAR 0 3
131643: PUSH
131644: LD_EXP 212
131648: PUSH
131649: LD_VAR 0 4
131653: ARRAY
131654: PUSH
131655: FOR_IN
131656: IFFALSE 131682
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
131658: LD_VAR 0 3
131662: PUSH
131663: LD_INT 1
131665: ARRAY
131666: PPUSH
131667: LD_VAR 0 3
131671: PUSH
131672: LD_INT 2
131674: ARRAY
131675: PPUSH
131676: CALL_OW 235
131680: GO 131655
131682: POP
131683: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
131684: LD_ADDR_EXP 212
131688: PUSH
131689: LD_EXP 212
131693: PPUSH
131694: LD_VAR 0 4
131698: PPUSH
131699: EMPTY
131700: PPUSH
131701: CALL_OW 1
131705: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
131706: LD_VAR 0 1
131710: PPUSH
131711: LD_INT 0
131713: PPUSH
131714: CALL_OW 505
// end ; end ;
131718: LD_VAR 0 2
131722: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
131723: LD_INT 0
131725: PPUSH
131726: PPUSH
131727: PPUSH
// if not hack in hackTanks or not vehicles then
131728: LD_VAR 0 1
131732: PUSH
131733: LD_EXP 211
131737: IN
131738: NOT
131739: PUSH
131740: LD_VAR 0 2
131744: NOT
131745: OR
131746: IFFALSE 131750
// exit ;
131748: GO 132025
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
131750: LD_ADDR_VAR 0 2
131754: PUSH
131755: LD_VAR 0 1
131759: PPUSH
131760: LD_VAR 0 2
131764: PPUSH
131765: LD_INT 1
131767: PPUSH
131768: LD_INT 1
131770: PPUSH
131771: CALL 75777 0 4
131775: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
131776: LD_ADDR_VAR 0 5
131780: PUSH
131781: LD_EXP 211
131785: PPUSH
131786: LD_VAR 0 1
131790: PPUSH
131791: CALL 75127 0 2
131795: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
131796: LD_EXP 212
131800: PUSH
131801: LD_VAR 0 5
131805: ARRAY
131806: PUSH
131807: LD_EXP 213
131811: LESS
131812: IFFALSE 132001
// begin for i := 1 to vehicles do
131814: LD_ADDR_VAR 0 4
131818: PUSH
131819: DOUBLE
131820: LD_INT 1
131822: DEC
131823: ST_TO_ADDR
131824: LD_VAR 0 2
131828: PUSH
131829: FOR_TO
131830: IFFALSE 131999
// begin if hackTanksCaptured [ index ] = hackLimit then
131832: LD_EXP 212
131836: PUSH
131837: LD_VAR 0 5
131841: ARRAY
131842: PUSH
131843: LD_EXP 213
131847: EQUAL
131848: IFFALSE 131852
// break ;
131850: GO 131999
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
131852: LD_ADDR_EXP 215
131856: PUSH
131857: LD_EXP 215
131861: PPUSH
131862: LD_VAR 0 5
131866: PPUSH
131867: LD_EXP 215
131871: PUSH
131872: LD_VAR 0 5
131876: ARRAY
131877: PUSH
131878: LD_INT 1
131880: PLUS
131881: PPUSH
131882: CALL_OW 1
131886: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
131887: LD_ADDR_EXP 212
131891: PUSH
131892: LD_EXP 212
131896: PPUSH
131897: LD_VAR 0 5
131901: PUSH
131902: LD_EXP 212
131906: PUSH
131907: LD_VAR 0 5
131911: ARRAY
131912: PUSH
131913: LD_INT 1
131915: PLUS
131916: PUSH
131917: EMPTY
131918: LIST
131919: LIST
131920: PPUSH
131921: LD_VAR 0 2
131925: PUSH
131926: LD_VAR 0 4
131930: ARRAY
131931: PUSH
131932: LD_VAR 0 2
131936: PUSH
131937: LD_VAR 0 4
131941: ARRAY
131942: PPUSH
131943: CALL_OW 255
131947: PUSH
131948: EMPTY
131949: LIST
131950: LIST
131951: PPUSH
131952: CALL 75342 0 3
131956: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
131957: LD_VAR 0 2
131961: PUSH
131962: LD_VAR 0 4
131966: ARRAY
131967: PPUSH
131968: LD_VAR 0 1
131972: PPUSH
131973: CALL_OW 255
131977: PPUSH
131978: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
131982: LD_VAR 0 2
131986: PUSH
131987: LD_VAR 0 4
131991: ARRAY
131992: PPUSH
131993: CALL_OW 141
// end ;
131997: GO 131829
131999: POP
132000: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
132001: LD_VAR 0 1
132005: PPUSH
132006: LD_EXP 212
132010: PUSH
132011: LD_VAR 0 5
132015: ARRAY
132016: PUSH
132017: LD_INT 0
132019: PLUS
132020: PPUSH
132021: CALL_OW 505
// end ;
132025: LD_VAR 0 3
132029: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
132030: LD_INT 0
132032: PPUSH
132033: PPUSH
132034: PPUSH
132035: PPUSH
// if not hack in hackTanks then
132036: LD_VAR 0 1
132040: PUSH
132041: LD_EXP 211
132045: IN
132046: NOT
132047: IFFALSE 132051
// exit ;
132049: GO 132291
// index := GetElementIndex ( hackTanks , hack ) ;
132051: LD_ADDR_VAR 0 4
132055: PUSH
132056: LD_EXP 211
132060: PPUSH
132061: LD_VAR 0 1
132065: PPUSH
132066: CALL 75127 0 2
132070: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
132071: LD_ADDR_VAR 0 3
132075: PUSH
132076: DOUBLE
132077: LD_EXP 212
132081: PUSH
132082: LD_VAR 0 4
132086: ARRAY
132087: INC
132088: ST_TO_ADDR
132089: LD_INT 1
132091: PUSH
132092: FOR_DOWNTO
132093: IFFALSE 132265
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
132095: LD_ADDR_VAR 0 5
132099: PUSH
132100: LD_EXP 212
132104: PUSH
132105: LD_VAR 0 4
132109: ARRAY
132110: PUSH
132111: LD_VAR 0 3
132115: ARRAY
132116: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
132117: LD_VAR 0 5
132121: PUSH
132122: LD_INT 1
132124: ARRAY
132125: PPUSH
132126: CALL_OW 302
132130: NOT
132131: PUSH
132132: LD_VAR 0 5
132136: PUSH
132137: LD_INT 1
132139: ARRAY
132140: PPUSH
132141: CALL_OW 255
132145: PUSH
132146: LD_VAR 0 1
132150: PPUSH
132151: CALL_OW 255
132155: NONEQUAL
132156: OR
132157: IFFALSE 132263
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
132159: LD_VAR 0 5
132163: PUSH
132164: LD_INT 1
132166: ARRAY
132167: PPUSH
132168: CALL_OW 305
132172: PUSH
132173: LD_VAR 0 5
132177: PUSH
132178: LD_INT 1
132180: ARRAY
132181: PPUSH
132182: CALL_OW 255
132186: PUSH
132187: LD_VAR 0 1
132191: PPUSH
132192: CALL_OW 255
132196: EQUAL
132197: AND
132198: IFFALSE 132222
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
132200: LD_VAR 0 5
132204: PUSH
132205: LD_INT 1
132207: ARRAY
132208: PPUSH
132209: LD_VAR 0 5
132213: PUSH
132214: LD_INT 2
132216: ARRAY
132217: PPUSH
132218: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
132222: LD_ADDR_EXP 212
132226: PUSH
132227: LD_EXP 212
132231: PPUSH
132232: LD_VAR 0 4
132236: PPUSH
132237: LD_EXP 212
132241: PUSH
132242: LD_VAR 0 4
132246: ARRAY
132247: PPUSH
132248: LD_VAR 0 3
132252: PPUSH
132253: CALL_OW 3
132257: PPUSH
132258: CALL_OW 1
132262: ST_TO_ADDR
// end ; end ;
132263: GO 132092
132265: POP
132266: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
132267: LD_VAR 0 1
132271: PPUSH
132272: LD_EXP 212
132276: PUSH
132277: LD_VAR 0 4
132281: ARRAY
132282: PUSH
132283: LD_INT 0
132285: PLUS
132286: PPUSH
132287: CALL_OW 505
// end ;
132291: LD_VAR 0 2
132295: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
132296: LD_INT 0
132298: PPUSH
132299: PPUSH
132300: PPUSH
132301: PPUSH
// if not hack in hackTanks then
132302: LD_VAR 0 1
132306: PUSH
132307: LD_EXP 211
132311: IN
132312: NOT
132313: IFFALSE 132317
// exit ;
132315: GO 132402
// index := GetElementIndex ( hackTanks , hack ) ;
132317: LD_ADDR_VAR 0 5
132321: PUSH
132322: LD_EXP 211
132326: PPUSH
132327: LD_VAR 0 1
132331: PPUSH
132332: CALL 75127 0 2
132336: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
132337: LD_ADDR_VAR 0 4
132341: PUSH
132342: DOUBLE
132343: LD_INT 1
132345: DEC
132346: ST_TO_ADDR
132347: LD_EXP 212
132351: PUSH
132352: LD_VAR 0 5
132356: ARRAY
132357: PUSH
132358: FOR_TO
132359: IFFALSE 132400
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
132361: LD_EXP 212
132365: PUSH
132366: LD_VAR 0 5
132370: ARRAY
132371: PUSH
132372: LD_VAR 0 4
132376: ARRAY
132377: PUSH
132378: LD_INT 1
132380: ARRAY
132381: PUSH
132382: LD_VAR 0 2
132386: EQUAL
132387: IFFALSE 132398
// KillUnit ( vehicle ) ;
132389: LD_VAR 0 2
132393: PPUSH
132394: CALL_OW 66
132398: GO 132358
132400: POP
132401: POP
// end ;
132402: LD_VAR 0 3
132406: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
132407: LD_EXP 216
132411: NOT
132412: IFFALSE 132447
132414: GO 132416
132416: DISABLE
// begin initMiner := true ;
132417: LD_ADDR_EXP 216
132421: PUSH
132422: LD_INT 1
132424: ST_TO_ADDR
// minersList := [ ] ;
132425: LD_ADDR_EXP 217
132429: PUSH
132430: EMPTY
132431: ST_TO_ADDR
// minerMinesList := [ ] ;
132432: LD_ADDR_EXP 218
132436: PUSH
132437: EMPTY
132438: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
132439: LD_ADDR_EXP 219
132443: PUSH
132444: LD_INT 5
132446: ST_TO_ADDR
// end ;
132447: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
132448: LD_EXP 216
132452: PUSH
132453: LD_INT 34
132455: PUSH
132456: LD_INT 81
132458: PUSH
132459: EMPTY
132460: LIST
132461: LIST
132462: PPUSH
132463: CALL_OW 69
132467: AND
132468: IFFALSE 132929
132470: GO 132472
132472: DISABLE
132473: LD_INT 0
132475: PPUSH
132476: PPUSH
132477: PPUSH
132478: PPUSH
// begin enable ;
132479: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
132480: LD_ADDR_VAR 0 1
132484: PUSH
132485: LD_INT 34
132487: PUSH
132488: LD_INT 81
132490: PUSH
132491: EMPTY
132492: LIST
132493: LIST
132494: PPUSH
132495: CALL_OW 69
132499: PUSH
132500: FOR_IN
132501: IFFALSE 132573
// begin if not i in minersList then
132503: LD_VAR 0 1
132507: PUSH
132508: LD_EXP 217
132512: IN
132513: NOT
132514: IFFALSE 132571
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
132516: LD_ADDR_EXP 217
132520: PUSH
132521: LD_EXP 217
132525: PPUSH
132526: LD_EXP 217
132530: PUSH
132531: LD_INT 1
132533: PLUS
132534: PPUSH
132535: LD_VAR 0 1
132539: PPUSH
132540: CALL_OW 1
132544: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
132545: LD_ADDR_EXP 218
132549: PUSH
132550: LD_EXP 218
132554: PPUSH
132555: LD_EXP 218
132559: PUSH
132560: LD_INT 1
132562: PLUS
132563: PPUSH
132564: EMPTY
132565: PPUSH
132566: CALL_OW 1
132570: ST_TO_ADDR
// end end ;
132571: GO 132500
132573: POP
132574: POP
// for i := minerMinesList downto 1 do
132575: LD_ADDR_VAR 0 1
132579: PUSH
132580: DOUBLE
132581: LD_EXP 218
132585: INC
132586: ST_TO_ADDR
132587: LD_INT 1
132589: PUSH
132590: FOR_DOWNTO
132591: IFFALSE 132927
// begin if IsLive ( minersList [ i ] ) then
132593: LD_EXP 217
132597: PUSH
132598: LD_VAR 0 1
132602: ARRAY
132603: PPUSH
132604: CALL_OW 300
132608: IFFALSE 132636
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
132610: LD_EXP 217
132614: PUSH
132615: LD_VAR 0 1
132619: ARRAY
132620: PPUSH
132621: LD_EXP 218
132625: PUSH
132626: LD_VAR 0 1
132630: ARRAY
132631: PPUSH
132632: CALL_OW 505
// if not minerMinesList [ i ] then
132636: LD_EXP 218
132640: PUSH
132641: LD_VAR 0 1
132645: ARRAY
132646: NOT
132647: IFFALSE 132651
// continue ;
132649: GO 132590
// for j := minerMinesList [ i ] downto 1 do
132651: LD_ADDR_VAR 0 2
132655: PUSH
132656: DOUBLE
132657: LD_EXP 218
132661: PUSH
132662: LD_VAR 0 1
132666: ARRAY
132667: INC
132668: ST_TO_ADDR
132669: LD_INT 1
132671: PUSH
132672: FOR_DOWNTO
132673: IFFALSE 132923
// begin side := GetSide ( minersList [ i ] ) ;
132675: LD_ADDR_VAR 0 3
132679: PUSH
132680: LD_EXP 217
132684: PUSH
132685: LD_VAR 0 1
132689: ARRAY
132690: PPUSH
132691: CALL_OW 255
132695: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
132696: LD_ADDR_VAR 0 4
132700: PUSH
132701: LD_EXP 218
132705: PUSH
132706: LD_VAR 0 1
132710: ARRAY
132711: PUSH
132712: LD_VAR 0 2
132716: ARRAY
132717: PUSH
132718: LD_INT 1
132720: ARRAY
132721: PPUSH
132722: LD_EXP 218
132726: PUSH
132727: LD_VAR 0 1
132731: ARRAY
132732: PUSH
132733: LD_VAR 0 2
132737: ARRAY
132738: PUSH
132739: LD_INT 2
132741: ARRAY
132742: PPUSH
132743: CALL_OW 428
132747: ST_TO_ADDR
// if not tmp then
132748: LD_VAR 0 4
132752: NOT
132753: IFFALSE 132757
// continue ;
132755: GO 132672
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
132757: LD_VAR 0 4
132761: PUSH
132762: LD_INT 81
132764: PUSH
132765: LD_VAR 0 3
132769: PUSH
132770: EMPTY
132771: LIST
132772: LIST
132773: PPUSH
132774: CALL_OW 69
132778: IN
132779: PUSH
132780: LD_EXP 218
132784: PUSH
132785: LD_VAR 0 1
132789: ARRAY
132790: PUSH
132791: LD_VAR 0 2
132795: ARRAY
132796: PUSH
132797: LD_INT 1
132799: ARRAY
132800: PPUSH
132801: LD_EXP 218
132805: PUSH
132806: LD_VAR 0 1
132810: ARRAY
132811: PUSH
132812: LD_VAR 0 2
132816: ARRAY
132817: PUSH
132818: LD_INT 2
132820: ARRAY
132821: PPUSH
132822: CALL_OW 458
132826: AND
132827: IFFALSE 132921
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
132829: LD_EXP 218
132833: PUSH
132834: LD_VAR 0 1
132838: ARRAY
132839: PUSH
132840: LD_VAR 0 2
132844: ARRAY
132845: PUSH
132846: LD_INT 1
132848: ARRAY
132849: PPUSH
132850: LD_EXP 218
132854: PUSH
132855: LD_VAR 0 1
132859: ARRAY
132860: PUSH
132861: LD_VAR 0 2
132865: ARRAY
132866: PUSH
132867: LD_INT 2
132869: ARRAY
132870: PPUSH
132871: LD_VAR 0 3
132875: PPUSH
132876: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
132880: LD_ADDR_EXP 218
132884: PUSH
132885: LD_EXP 218
132889: PPUSH
132890: LD_VAR 0 1
132894: PPUSH
132895: LD_EXP 218
132899: PUSH
132900: LD_VAR 0 1
132904: ARRAY
132905: PPUSH
132906: LD_VAR 0 2
132910: PPUSH
132911: CALL_OW 3
132915: PPUSH
132916: CALL_OW 1
132920: ST_TO_ADDR
// end ; end ;
132921: GO 132672
132923: POP
132924: POP
// end ;
132925: GO 132590
132927: POP
132928: POP
// end ;
132929: PPOPN 4
132931: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
132932: LD_INT 0
132934: PPUSH
132935: PPUSH
// result := false ;
132936: LD_ADDR_VAR 0 4
132940: PUSH
132941: LD_INT 0
132943: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
132944: LD_VAR 0 1
132948: PPUSH
132949: CALL_OW 264
132953: PUSH
132954: LD_INT 81
132956: EQUAL
132957: NOT
132958: IFFALSE 132962
// exit ;
132960: GO 133202
// index := GetElementIndex ( minersList , unit ) ;
132962: LD_ADDR_VAR 0 5
132966: PUSH
132967: LD_EXP 217
132971: PPUSH
132972: LD_VAR 0 1
132976: PPUSH
132977: CALL 75127 0 2
132981: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
132982: LD_EXP 218
132986: PUSH
132987: LD_VAR 0 5
132991: ARRAY
132992: PUSH
132993: LD_EXP 219
132997: GREATEREQUAL
132998: IFFALSE 133002
// exit ;
133000: GO 133202
// ComMoveXY ( unit , x , y ) ;
133002: LD_VAR 0 1
133006: PPUSH
133007: LD_VAR 0 2
133011: PPUSH
133012: LD_VAR 0 3
133016: PPUSH
133017: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
133021: LD_INT 35
133023: PPUSH
133024: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
133028: LD_VAR 0 1
133032: PPUSH
133033: LD_VAR 0 2
133037: PPUSH
133038: LD_VAR 0 3
133042: PPUSH
133043: CALL 106888 0 3
133047: NOT
133048: PUSH
133049: LD_VAR 0 1
133053: PPUSH
133054: CALL_OW 314
133058: AND
133059: IFFALSE 133063
// exit ;
133061: GO 133202
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
133063: LD_VAR 0 2
133067: PPUSH
133068: LD_VAR 0 3
133072: PPUSH
133073: CALL_OW 428
133077: PUSH
133078: LD_VAR 0 1
133082: EQUAL
133083: PUSH
133084: LD_VAR 0 1
133088: PPUSH
133089: CALL_OW 314
133093: NOT
133094: AND
133095: IFFALSE 133021
// PlaySoundXY ( x , y , PlantMine ) ;
133097: LD_VAR 0 2
133101: PPUSH
133102: LD_VAR 0 3
133106: PPUSH
133107: LD_STRING PlantMine
133109: PPUSH
133110: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
133114: LD_VAR 0 2
133118: PPUSH
133119: LD_VAR 0 3
133123: PPUSH
133124: LD_VAR 0 1
133128: PPUSH
133129: CALL_OW 255
133133: PPUSH
133134: LD_INT 0
133136: PPUSH
133137: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
133141: LD_ADDR_EXP 218
133145: PUSH
133146: LD_EXP 218
133150: PPUSH
133151: LD_VAR 0 5
133155: PUSH
133156: LD_EXP 218
133160: PUSH
133161: LD_VAR 0 5
133165: ARRAY
133166: PUSH
133167: LD_INT 1
133169: PLUS
133170: PUSH
133171: EMPTY
133172: LIST
133173: LIST
133174: PPUSH
133175: LD_VAR 0 2
133179: PUSH
133180: LD_VAR 0 3
133184: PUSH
133185: EMPTY
133186: LIST
133187: LIST
133188: PPUSH
133189: CALL 75342 0 3
133193: ST_TO_ADDR
// result := true ;
133194: LD_ADDR_VAR 0 4
133198: PUSH
133199: LD_INT 1
133201: ST_TO_ADDR
// end ;
133202: LD_VAR 0 4
133206: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
133207: LD_INT 0
133209: PPUSH
133210: PPUSH
133211: PPUSH
// if not unit in minersList then
133212: LD_VAR 0 1
133216: PUSH
133217: LD_EXP 217
133221: IN
133222: NOT
133223: IFFALSE 133227
// exit ;
133225: GO 133619
// index := GetElementIndex ( minersList , unit ) ;
133227: LD_ADDR_VAR 0 6
133231: PUSH
133232: LD_EXP 217
133236: PPUSH
133237: LD_VAR 0 1
133241: PPUSH
133242: CALL 75127 0 2
133246: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
133247: LD_ADDR_VAR 0 5
133251: PUSH
133252: DOUBLE
133253: LD_EXP 218
133257: PUSH
133258: LD_VAR 0 6
133262: ARRAY
133263: INC
133264: ST_TO_ADDR
133265: LD_INT 1
133267: PUSH
133268: FOR_DOWNTO
133269: IFFALSE 133430
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
133271: LD_EXP 218
133275: PUSH
133276: LD_VAR 0 6
133280: ARRAY
133281: PUSH
133282: LD_VAR 0 5
133286: ARRAY
133287: PUSH
133288: LD_INT 1
133290: ARRAY
133291: PUSH
133292: LD_VAR 0 2
133296: EQUAL
133297: PUSH
133298: LD_EXP 218
133302: PUSH
133303: LD_VAR 0 6
133307: ARRAY
133308: PUSH
133309: LD_VAR 0 5
133313: ARRAY
133314: PUSH
133315: LD_INT 2
133317: ARRAY
133318: PUSH
133319: LD_VAR 0 3
133323: EQUAL
133324: AND
133325: IFFALSE 133428
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
133327: LD_EXP 218
133331: PUSH
133332: LD_VAR 0 6
133336: ARRAY
133337: PUSH
133338: LD_VAR 0 5
133342: ARRAY
133343: PUSH
133344: LD_INT 1
133346: ARRAY
133347: PPUSH
133348: LD_EXP 218
133352: PUSH
133353: LD_VAR 0 6
133357: ARRAY
133358: PUSH
133359: LD_VAR 0 5
133363: ARRAY
133364: PUSH
133365: LD_INT 2
133367: ARRAY
133368: PPUSH
133369: LD_VAR 0 1
133373: PPUSH
133374: CALL_OW 255
133378: PPUSH
133379: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
133383: LD_ADDR_EXP 218
133387: PUSH
133388: LD_EXP 218
133392: PPUSH
133393: LD_VAR 0 6
133397: PPUSH
133398: LD_EXP 218
133402: PUSH
133403: LD_VAR 0 6
133407: ARRAY
133408: PPUSH
133409: LD_VAR 0 5
133413: PPUSH
133414: CALL_OW 3
133418: PPUSH
133419: CALL_OW 1
133423: ST_TO_ADDR
// exit ;
133424: POP
133425: POP
133426: GO 133619
// end ; end ;
133428: GO 133268
133430: POP
133431: POP
// for i := minerMinesList [ index ] downto 1 do
133432: LD_ADDR_VAR 0 5
133436: PUSH
133437: DOUBLE
133438: LD_EXP 218
133442: PUSH
133443: LD_VAR 0 6
133447: ARRAY
133448: INC
133449: ST_TO_ADDR
133450: LD_INT 1
133452: PUSH
133453: FOR_DOWNTO
133454: IFFALSE 133617
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
133456: LD_EXP 218
133460: PUSH
133461: LD_VAR 0 6
133465: ARRAY
133466: PUSH
133467: LD_VAR 0 5
133471: ARRAY
133472: PUSH
133473: LD_INT 1
133475: ARRAY
133476: PPUSH
133477: LD_EXP 218
133481: PUSH
133482: LD_VAR 0 6
133486: ARRAY
133487: PUSH
133488: LD_VAR 0 5
133492: ARRAY
133493: PUSH
133494: LD_INT 2
133496: ARRAY
133497: PPUSH
133498: LD_VAR 0 2
133502: PPUSH
133503: LD_VAR 0 3
133507: PPUSH
133508: CALL_OW 298
133512: PUSH
133513: LD_INT 6
133515: LESS
133516: IFFALSE 133615
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
133518: LD_EXP 218
133522: PUSH
133523: LD_VAR 0 6
133527: ARRAY
133528: PUSH
133529: LD_VAR 0 5
133533: ARRAY
133534: PUSH
133535: LD_INT 1
133537: ARRAY
133538: PPUSH
133539: LD_EXP 218
133543: PUSH
133544: LD_VAR 0 6
133548: ARRAY
133549: PUSH
133550: LD_VAR 0 5
133554: ARRAY
133555: PUSH
133556: LD_INT 2
133558: ARRAY
133559: PPUSH
133560: LD_VAR 0 1
133564: PPUSH
133565: CALL_OW 255
133569: PPUSH
133570: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
133574: LD_ADDR_EXP 218
133578: PUSH
133579: LD_EXP 218
133583: PPUSH
133584: LD_VAR 0 6
133588: PPUSH
133589: LD_EXP 218
133593: PUSH
133594: LD_VAR 0 6
133598: ARRAY
133599: PPUSH
133600: LD_VAR 0 5
133604: PPUSH
133605: CALL_OW 3
133609: PPUSH
133610: CALL_OW 1
133614: ST_TO_ADDR
// end ; end ;
133615: GO 133453
133617: POP
133618: POP
// end ;
133619: LD_VAR 0 4
133623: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
133624: LD_INT 0
133626: PPUSH
133627: PPUSH
133628: PPUSH
133629: PPUSH
133630: PPUSH
133631: PPUSH
133632: PPUSH
133633: PPUSH
133634: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
133635: LD_VAR 0 1
133639: PPUSH
133640: CALL_OW 264
133644: PUSH
133645: LD_INT 81
133647: EQUAL
133648: NOT
133649: PUSH
133650: LD_VAR 0 1
133654: PUSH
133655: LD_EXP 217
133659: IN
133660: NOT
133661: OR
133662: IFFALSE 133666
// exit ;
133664: GO 133988
// index := GetElementIndex ( minersList , unit ) ;
133666: LD_ADDR_VAR 0 6
133670: PUSH
133671: LD_EXP 217
133675: PPUSH
133676: LD_VAR 0 1
133680: PPUSH
133681: CALL 75127 0 2
133685: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
133686: LD_ADDR_VAR 0 8
133690: PUSH
133691: LD_EXP 219
133695: PUSH
133696: LD_EXP 218
133700: PUSH
133701: LD_VAR 0 6
133705: ARRAY
133706: MINUS
133707: ST_TO_ADDR
// if not minesFreeAmount then
133708: LD_VAR 0 8
133712: NOT
133713: IFFALSE 133717
// exit ;
133715: GO 133988
// tmp := [ ] ;
133717: LD_ADDR_VAR 0 7
133721: PUSH
133722: EMPTY
133723: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
133724: LD_ADDR_VAR 0 5
133728: PUSH
133729: DOUBLE
133730: LD_INT 1
133732: DEC
133733: ST_TO_ADDR
133734: LD_VAR 0 8
133738: PUSH
133739: FOR_TO
133740: IFFALSE 133935
// begin _d := rand ( 0 , 5 ) ;
133742: LD_ADDR_VAR 0 11
133746: PUSH
133747: LD_INT 0
133749: PPUSH
133750: LD_INT 5
133752: PPUSH
133753: CALL_OW 12
133757: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
133758: LD_ADDR_VAR 0 12
133762: PUSH
133763: LD_INT 2
133765: PPUSH
133766: LD_INT 6
133768: PPUSH
133769: CALL_OW 12
133773: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
133774: LD_ADDR_VAR 0 9
133778: PUSH
133779: LD_VAR 0 2
133783: PPUSH
133784: LD_VAR 0 11
133788: PPUSH
133789: LD_VAR 0 12
133793: PPUSH
133794: CALL_OW 272
133798: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
133799: LD_ADDR_VAR 0 10
133803: PUSH
133804: LD_VAR 0 3
133808: PPUSH
133809: LD_VAR 0 11
133813: PPUSH
133814: LD_VAR 0 12
133818: PPUSH
133819: CALL_OW 273
133823: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
133824: LD_VAR 0 9
133828: PPUSH
133829: LD_VAR 0 10
133833: PPUSH
133834: CALL_OW 488
133838: PUSH
133839: LD_VAR 0 9
133843: PUSH
133844: LD_VAR 0 10
133848: PUSH
133849: EMPTY
133850: LIST
133851: LIST
133852: PUSH
133853: LD_VAR 0 7
133857: IN
133858: NOT
133859: AND
133860: PUSH
133861: LD_VAR 0 9
133865: PPUSH
133866: LD_VAR 0 10
133870: PPUSH
133871: CALL_OW 458
133875: NOT
133876: AND
133877: IFFALSE 133919
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
133879: LD_ADDR_VAR 0 7
133883: PUSH
133884: LD_VAR 0 7
133888: PPUSH
133889: LD_VAR 0 7
133893: PUSH
133894: LD_INT 1
133896: PLUS
133897: PPUSH
133898: LD_VAR 0 9
133902: PUSH
133903: LD_VAR 0 10
133907: PUSH
133908: EMPTY
133909: LIST
133910: LIST
133911: PPUSH
133912: CALL_OW 1
133916: ST_TO_ADDR
133917: GO 133933
// i := i - 1 ;
133919: LD_ADDR_VAR 0 5
133923: PUSH
133924: LD_VAR 0 5
133928: PUSH
133929: LD_INT 1
133931: MINUS
133932: ST_TO_ADDR
// end ;
133933: GO 133739
133935: POP
133936: POP
// for i in tmp do
133937: LD_ADDR_VAR 0 5
133941: PUSH
133942: LD_VAR 0 7
133946: PUSH
133947: FOR_IN
133948: IFFALSE 133986
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
133950: LD_VAR 0 1
133954: PPUSH
133955: LD_VAR 0 5
133959: PUSH
133960: LD_INT 1
133962: ARRAY
133963: PPUSH
133964: LD_VAR 0 5
133968: PUSH
133969: LD_INT 2
133971: ARRAY
133972: PPUSH
133973: CALL 132932 0 3
133977: NOT
133978: IFFALSE 133984
// exit ;
133980: POP
133981: POP
133982: GO 133988
133984: GO 133947
133986: POP
133987: POP
// end ;
133988: LD_VAR 0 4
133992: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , dir , viewRange , _x , _y , _d , p ; begin
133993: LD_INT 0
133995: PPUSH
133996: PPUSH
133997: PPUSH
133998: PPUSH
133999: PPUSH
134000: PPUSH
134001: PPUSH
134002: PPUSH
134003: PPUSH
// if GetClass ( unit ) <> class_sniper then
134004: LD_VAR 0 1
134008: PPUSH
134009: CALL_OW 257
134013: PUSH
134014: LD_INT 5
134016: NONEQUAL
134017: IFFALSE 134021
// exit ;
134019: GO 134487
// dist := 8 ;
134021: LD_ADDR_VAR 0 5
134025: PUSH
134026: LD_INT 8
134028: ST_TO_ADDR
// viewRange := 12 ;
134029: LD_ADDR_VAR 0 8
134033: PUSH
134034: LD_INT 12
134036: ST_TO_ADDR
// side := GetSide ( unit ) ;
134037: LD_ADDR_VAR 0 6
134041: PUSH
134042: LD_VAR 0 1
134046: PPUSH
134047: CALL_OW 255
134051: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
134052: LD_INT 61
134054: PPUSH
134055: LD_VAR 0 6
134059: PPUSH
134060: CALL_OW 321
134064: PUSH
134065: LD_INT 2
134067: EQUAL
134068: IFFALSE 134078
// viewRange := 16 ;
134070: LD_ADDR_VAR 0 8
134074: PUSH
134075: LD_INT 16
134077: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
134078: LD_VAR 0 1
134082: PPUSH
134083: LD_VAR 0 2
134087: PPUSH
134088: LD_VAR 0 3
134092: PPUSH
134093: CALL_OW 297
134097: PUSH
134098: LD_VAR 0 5
134102: GREATER
134103: IFFALSE 134182
// begin ComMoveXY ( unit , x , y ) ;
134105: LD_VAR 0 1
134109: PPUSH
134110: LD_VAR 0 2
134114: PPUSH
134115: LD_VAR 0 3
134119: PPUSH
134120: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
134124: LD_INT 35
134126: PPUSH
134127: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
134131: LD_VAR 0 1
134135: PPUSH
134136: LD_VAR 0 2
134140: PPUSH
134141: LD_VAR 0 3
134145: PPUSH
134146: CALL 106888 0 3
134150: NOT
134151: IFFALSE 134155
// exit ;
134153: GO 134487
// until GetDistUnitXY ( unit , x , y ) < dist ;
134155: LD_VAR 0 1
134159: PPUSH
134160: LD_VAR 0 2
134164: PPUSH
134165: LD_VAR 0 3
134169: PPUSH
134170: CALL_OW 297
134174: PUSH
134175: LD_VAR 0 5
134179: LESS
134180: IFFALSE 134124
// end ; ComTurnXY ( unit , x , y ) ;
134182: LD_VAR 0 1
134186: PPUSH
134187: LD_VAR 0 2
134191: PPUSH
134192: LD_VAR 0 3
134196: PPUSH
134197: CALL_OW 118
// repeat if Multiplayer then
134201: LD_OWVAR 4
134205: IFFALSE 134216
// wait ( 35 ) else
134207: LD_INT 35
134209: PPUSH
134210: CALL_OW 67
134214: GO 134223
// wait ( 5 ) ;
134216: LD_INT 5
134218: PPUSH
134219: CALL_OW 67
// _d := GetDir ( unit ) ;
134223: LD_ADDR_VAR 0 11
134227: PUSH
134228: LD_VAR 0 1
134232: PPUSH
134233: CALL_OW 254
134237: ST_TO_ADDR
// dir := GetDirFromHex ( GetX ( unit ) , GetY ( unit ) , x , y ) ;
134238: LD_ADDR_VAR 0 7
134242: PUSH
134243: LD_VAR 0 1
134247: PPUSH
134248: CALL_OW 250
134252: PPUSH
134253: LD_VAR 0 1
134257: PPUSH
134258: CALL_OW 251
134262: PPUSH
134263: LD_VAR 0 2
134267: PPUSH
134268: LD_VAR 0 3
134272: PPUSH
134273: CALL 109496 0 4
134277: ST_TO_ADDR
// until dir = _d ;
134278: LD_VAR 0 7
134282: PUSH
134283: LD_VAR 0 11
134287: EQUAL
134288: IFFALSE 134201
// _x := ShiftX ( GetX ( unit ) , dir , dist ) ;
134290: LD_ADDR_VAR 0 9
134294: PUSH
134295: LD_VAR 0 1
134299: PPUSH
134300: CALL_OW 250
134304: PPUSH
134305: LD_VAR 0 7
134309: PPUSH
134310: LD_VAR 0 5
134314: PPUSH
134315: CALL_OW 272
134319: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , dir , dist ) ;
134320: LD_ADDR_VAR 0 10
134324: PUSH
134325: LD_VAR 0 1
134329: PPUSH
134330: CALL_OW 251
134334: PPUSH
134335: LD_VAR 0 7
134339: PPUSH
134340: LD_VAR 0 5
134344: PPUSH
134345: CALL_OW 273
134349: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
134350: LD_VAR 0 9
134354: PPUSH
134355: LD_VAR 0 10
134359: PPUSH
134360: CALL_OW 488
134364: NOT
134365: IFFALSE 134369
// exit ;
134367: GO 134487
// ComAnimCustom ( unit , 1 ) ;
134369: LD_VAR 0 1
134373: PPUSH
134374: LD_INT 1
134376: PPUSH
134377: CALL_OW 592
// p := 0 ;
134381: LD_ADDR_VAR 0 12
134385: PUSH
134386: LD_INT 0
134388: ST_TO_ADDR
// PlaceSeeing ( _x , _y , side , viewRange ) ;
134389: LD_VAR 0 9
134393: PPUSH
134394: LD_VAR 0 10
134398: PPUSH
134399: LD_VAR 0 6
134403: PPUSH
134404: LD_VAR 0 8
134408: PPUSH
134409: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
134413: LD_INT 35
134415: PPUSH
134416: CALL_OW 67
// p := Inc ( p ) ;
134420: LD_ADDR_VAR 0 12
134424: PUSH
134425: LD_VAR 0 12
134429: PPUSH
134430: CALL 109452 0 1
134434: ST_TO_ADDR
// until p = 3 or not IsOk ( unit ) or IsDead ( unit ) ;
134435: LD_VAR 0 12
134439: PUSH
134440: LD_INT 3
134442: EQUAL
134443: PUSH
134444: LD_VAR 0 1
134448: PPUSH
134449: CALL_OW 302
134453: NOT
134454: OR
134455: PUSH
134456: LD_VAR 0 1
134460: PPUSH
134461: CALL_OW 301
134465: OR
134466: IFFALSE 134413
// RemoveSeeing ( _x , _y , side ) ;
134468: LD_VAR 0 9
134472: PPUSH
134473: LD_VAR 0 10
134477: PPUSH
134478: LD_VAR 0 6
134482: PPUSH
134483: CALL_OW 331
// end ; end_of_file
134487: LD_VAR 0 4
134491: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
134492: LD_INT 0
134494: PPUSH
134495: PPUSH
134496: PPUSH
134497: PPUSH
134498: PPUSH
134499: PPUSH
134500: PPUSH
134501: PPUSH
134502: PPUSH
134503: PPUSH
134504: PPUSH
134505: PPUSH
134506: PPUSH
134507: PPUSH
134508: PPUSH
134509: PPUSH
134510: PPUSH
134511: PPUSH
134512: PPUSH
134513: PPUSH
134514: PPUSH
134515: PPUSH
134516: PPUSH
134517: PPUSH
134518: PPUSH
134519: PPUSH
134520: PPUSH
134521: PPUSH
134522: PPUSH
134523: PPUSH
134524: PPUSH
134525: PPUSH
134526: PPUSH
134527: PPUSH
// if not list then
134528: LD_VAR 0 1
134532: NOT
134533: IFFALSE 134537
// exit ;
134535: GO 139196
// base := list [ 1 ] ;
134537: LD_ADDR_VAR 0 3
134541: PUSH
134542: LD_VAR 0 1
134546: PUSH
134547: LD_INT 1
134549: ARRAY
134550: ST_TO_ADDR
// group := list [ 2 ] ;
134551: LD_ADDR_VAR 0 4
134555: PUSH
134556: LD_VAR 0 1
134560: PUSH
134561: LD_INT 2
134563: ARRAY
134564: ST_TO_ADDR
// path := list [ 3 ] ;
134565: LD_ADDR_VAR 0 5
134569: PUSH
134570: LD_VAR 0 1
134574: PUSH
134575: LD_INT 3
134577: ARRAY
134578: ST_TO_ADDR
// flags := list [ 4 ] ;
134579: LD_ADDR_VAR 0 6
134583: PUSH
134584: LD_VAR 0 1
134588: PUSH
134589: LD_INT 4
134591: ARRAY
134592: ST_TO_ADDR
// mined := [ ] ;
134593: LD_ADDR_VAR 0 27
134597: PUSH
134598: EMPTY
134599: ST_TO_ADDR
// bombed := [ ] ;
134600: LD_ADDR_VAR 0 28
134604: PUSH
134605: EMPTY
134606: ST_TO_ADDR
// healers := [ ] ;
134607: LD_ADDR_VAR 0 31
134611: PUSH
134612: EMPTY
134613: ST_TO_ADDR
// to_heal := [ ] ;
134614: LD_ADDR_VAR 0 30
134618: PUSH
134619: EMPTY
134620: ST_TO_ADDR
// repairs := [ ] ;
134621: LD_ADDR_VAR 0 33
134625: PUSH
134626: EMPTY
134627: ST_TO_ADDR
// to_repair := [ ] ;
134628: LD_ADDR_VAR 0 32
134632: PUSH
134633: EMPTY
134634: ST_TO_ADDR
// if not group or not path then
134635: LD_VAR 0 4
134639: NOT
134640: PUSH
134641: LD_VAR 0 5
134645: NOT
134646: OR
134647: IFFALSE 134651
// exit ;
134649: GO 139196
// side := GetSide ( group [ 1 ] ) ;
134651: LD_ADDR_VAR 0 35
134655: PUSH
134656: LD_VAR 0 4
134660: PUSH
134661: LD_INT 1
134663: ARRAY
134664: PPUSH
134665: CALL_OW 255
134669: ST_TO_ADDR
// if flags then
134670: LD_VAR 0 6
134674: IFFALSE 134818
// begin f_ignore_area := flags [ 1 ] ;
134676: LD_ADDR_VAR 0 17
134680: PUSH
134681: LD_VAR 0 6
134685: PUSH
134686: LD_INT 1
134688: ARRAY
134689: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
134690: LD_ADDR_VAR 0 18
134694: PUSH
134695: LD_VAR 0 6
134699: PUSH
134700: LD_INT 2
134702: ARRAY
134703: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
134704: LD_ADDR_VAR 0 19
134708: PUSH
134709: LD_VAR 0 6
134713: PUSH
134714: LD_INT 3
134716: ARRAY
134717: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
134718: LD_ADDR_VAR 0 20
134722: PUSH
134723: LD_VAR 0 6
134727: PUSH
134728: LD_INT 4
134730: ARRAY
134731: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
134732: LD_ADDR_VAR 0 21
134736: PUSH
134737: LD_VAR 0 6
134741: PUSH
134742: LD_INT 5
134744: ARRAY
134745: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
134746: LD_ADDR_VAR 0 22
134750: PUSH
134751: LD_VAR 0 6
134755: PUSH
134756: LD_INT 6
134758: ARRAY
134759: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
134760: LD_ADDR_VAR 0 23
134764: PUSH
134765: LD_VAR 0 6
134769: PUSH
134770: LD_INT 7
134772: ARRAY
134773: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
134774: LD_ADDR_VAR 0 24
134778: PUSH
134779: LD_VAR 0 6
134783: PUSH
134784: LD_INT 8
134786: ARRAY
134787: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
134788: LD_ADDR_VAR 0 25
134792: PUSH
134793: LD_VAR 0 6
134797: PUSH
134798: LD_INT 9
134800: ARRAY
134801: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
134802: LD_ADDR_VAR 0 26
134806: PUSH
134807: LD_VAR 0 6
134811: PUSH
134812: LD_INT 10
134814: ARRAY
134815: ST_TO_ADDR
// end else
134816: GO 134898
// begin f_ignore_area := false ;
134818: LD_ADDR_VAR 0 17
134822: PUSH
134823: LD_INT 0
134825: ST_TO_ADDR
// f_capture := false ;
134826: LD_ADDR_VAR 0 18
134830: PUSH
134831: LD_INT 0
134833: ST_TO_ADDR
// f_ignore_civ := false ;
134834: LD_ADDR_VAR 0 19
134838: PUSH
134839: LD_INT 0
134841: ST_TO_ADDR
// f_murder := false ;
134842: LD_ADDR_VAR 0 20
134846: PUSH
134847: LD_INT 0
134849: ST_TO_ADDR
// f_mines := false ;
134850: LD_ADDR_VAR 0 21
134854: PUSH
134855: LD_INT 0
134857: ST_TO_ADDR
// f_repair := false ;
134858: LD_ADDR_VAR 0 22
134862: PUSH
134863: LD_INT 0
134865: ST_TO_ADDR
// f_heal := false ;
134866: LD_ADDR_VAR 0 23
134870: PUSH
134871: LD_INT 0
134873: ST_TO_ADDR
// f_spacetime := false ;
134874: LD_ADDR_VAR 0 24
134878: PUSH
134879: LD_INT 0
134881: ST_TO_ADDR
// f_attack_depot := false ;
134882: LD_ADDR_VAR 0 25
134886: PUSH
134887: LD_INT 0
134889: ST_TO_ADDR
// f_crawl := false ;
134890: LD_ADDR_VAR 0 26
134894: PUSH
134895: LD_INT 0
134897: ST_TO_ADDR
// end ; if f_heal then
134898: LD_VAR 0 23
134902: IFFALSE 134929
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
134904: LD_ADDR_VAR 0 31
134908: PUSH
134909: LD_VAR 0 4
134913: PPUSH
134914: LD_INT 25
134916: PUSH
134917: LD_INT 4
134919: PUSH
134920: EMPTY
134921: LIST
134922: LIST
134923: PPUSH
134924: CALL_OW 72
134928: ST_TO_ADDR
// if f_repair then
134929: LD_VAR 0 22
134933: IFFALSE 134960
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
134935: LD_ADDR_VAR 0 33
134939: PUSH
134940: LD_VAR 0 4
134944: PPUSH
134945: LD_INT 25
134947: PUSH
134948: LD_INT 3
134950: PUSH
134951: EMPTY
134952: LIST
134953: LIST
134954: PPUSH
134955: CALL_OW 72
134959: ST_TO_ADDR
// units_path := [ ] ;
134960: LD_ADDR_VAR 0 16
134964: PUSH
134965: EMPTY
134966: ST_TO_ADDR
// for i = 1 to group do
134967: LD_ADDR_VAR 0 7
134971: PUSH
134972: DOUBLE
134973: LD_INT 1
134975: DEC
134976: ST_TO_ADDR
134977: LD_VAR 0 4
134981: PUSH
134982: FOR_TO
134983: IFFALSE 135012
// units_path := Replace ( units_path , i , path ) ;
134985: LD_ADDR_VAR 0 16
134989: PUSH
134990: LD_VAR 0 16
134994: PPUSH
134995: LD_VAR 0 7
134999: PPUSH
135000: LD_VAR 0 5
135004: PPUSH
135005: CALL_OW 1
135009: ST_TO_ADDR
135010: GO 134982
135012: POP
135013: POP
// repeat for i = group downto 1 do
135014: LD_ADDR_VAR 0 7
135018: PUSH
135019: DOUBLE
135020: LD_VAR 0 4
135024: INC
135025: ST_TO_ADDR
135026: LD_INT 1
135028: PUSH
135029: FOR_DOWNTO
135030: IFFALSE 139152
// begin wait ( 5 ) ;
135032: LD_INT 5
135034: PPUSH
135035: CALL_OW 67
// tmp := [ ] ;
135039: LD_ADDR_VAR 0 14
135043: PUSH
135044: EMPTY
135045: ST_TO_ADDR
// attacking := false ;
135046: LD_ADDR_VAR 0 29
135050: PUSH
135051: LD_INT 0
135053: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
135054: LD_VAR 0 4
135058: PUSH
135059: LD_VAR 0 7
135063: ARRAY
135064: PPUSH
135065: CALL_OW 301
135069: PUSH
135070: LD_VAR 0 4
135074: PUSH
135075: LD_VAR 0 7
135079: ARRAY
135080: NOT
135081: OR
135082: IFFALSE 135191
// begin if GetType ( group [ i ] ) = unit_human then
135084: LD_VAR 0 4
135088: PUSH
135089: LD_VAR 0 7
135093: ARRAY
135094: PPUSH
135095: CALL_OW 247
135099: PUSH
135100: LD_INT 1
135102: EQUAL
135103: IFFALSE 135149
// begin to_heal := to_heal diff group [ i ] ;
135105: LD_ADDR_VAR 0 30
135109: PUSH
135110: LD_VAR 0 30
135114: PUSH
135115: LD_VAR 0 4
135119: PUSH
135120: LD_VAR 0 7
135124: ARRAY
135125: DIFF
135126: ST_TO_ADDR
// healers := healers diff group [ i ] ;
135127: LD_ADDR_VAR 0 31
135131: PUSH
135132: LD_VAR 0 31
135136: PUSH
135137: LD_VAR 0 4
135141: PUSH
135142: LD_VAR 0 7
135146: ARRAY
135147: DIFF
135148: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
135149: LD_ADDR_VAR 0 4
135153: PUSH
135154: LD_VAR 0 4
135158: PPUSH
135159: LD_VAR 0 7
135163: PPUSH
135164: CALL_OW 3
135168: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
135169: LD_ADDR_VAR 0 16
135173: PUSH
135174: LD_VAR 0 16
135178: PPUSH
135179: LD_VAR 0 7
135183: PPUSH
135184: CALL_OW 3
135188: ST_TO_ADDR
// continue ;
135189: GO 135029
// end ; if f_repair then
135191: LD_VAR 0 22
135195: IFFALSE 135684
// begin if GetType ( group [ i ] ) = unit_vehicle then
135197: LD_VAR 0 4
135201: PUSH
135202: LD_VAR 0 7
135206: ARRAY
135207: PPUSH
135208: CALL_OW 247
135212: PUSH
135213: LD_INT 2
135215: EQUAL
135216: IFFALSE 135406
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
135218: LD_VAR 0 4
135222: PUSH
135223: LD_VAR 0 7
135227: ARRAY
135228: PPUSH
135229: CALL_OW 256
135233: PUSH
135234: LD_INT 700
135236: LESS
135237: PUSH
135238: LD_VAR 0 4
135242: PUSH
135243: LD_VAR 0 7
135247: ARRAY
135248: PUSH
135249: LD_VAR 0 32
135253: IN
135254: NOT
135255: AND
135256: IFFALSE 135280
// to_repair := to_repair union group [ i ] ;
135258: LD_ADDR_VAR 0 32
135262: PUSH
135263: LD_VAR 0 32
135267: PUSH
135268: LD_VAR 0 4
135272: PUSH
135273: LD_VAR 0 7
135277: ARRAY
135278: UNION
135279: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
135280: LD_VAR 0 4
135284: PUSH
135285: LD_VAR 0 7
135289: ARRAY
135290: PPUSH
135291: CALL_OW 256
135295: PUSH
135296: LD_INT 1000
135298: EQUAL
135299: PUSH
135300: LD_VAR 0 4
135304: PUSH
135305: LD_VAR 0 7
135309: ARRAY
135310: PUSH
135311: LD_VAR 0 32
135315: IN
135316: AND
135317: IFFALSE 135341
// to_repair := to_repair diff group [ i ] ;
135319: LD_ADDR_VAR 0 32
135323: PUSH
135324: LD_VAR 0 32
135328: PUSH
135329: LD_VAR 0 4
135333: PUSH
135334: LD_VAR 0 7
135338: ARRAY
135339: DIFF
135340: ST_TO_ADDR
// if group [ i ] in to_repair then
135341: LD_VAR 0 4
135345: PUSH
135346: LD_VAR 0 7
135350: ARRAY
135351: PUSH
135352: LD_VAR 0 32
135356: IN
135357: IFFALSE 135404
// begin if not IsInArea ( group [ i ] , f_repair ) then
135359: LD_VAR 0 4
135363: PUSH
135364: LD_VAR 0 7
135368: ARRAY
135369: PPUSH
135370: LD_VAR 0 22
135374: PPUSH
135375: CALL_OW 308
135379: NOT
135380: IFFALSE 135402
// ComMoveToArea ( group [ i ] , f_repair ) ;
135382: LD_VAR 0 4
135386: PUSH
135387: LD_VAR 0 7
135391: ARRAY
135392: PPUSH
135393: LD_VAR 0 22
135397: PPUSH
135398: CALL_OW 113
// continue ;
135402: GO 135029
// end ; end else
135404: GO 135684
// if group [ i ] in repairs then
135406: LD_VAR 0 4
135410: PUSH
135411: LD_VAR 0 7
135415: ARRAY
135416: PUSH
135417: LD_VAR 0 33
135421: IN
135422: IFFALSE 135684
// begin if IsInUnit ( group [ i ] ) then
135424: LD_VAR 0 4
135428: PUSH
135429: LD_VAR 0 7
135433: ARRAY
135434: PPUSH
135435: CALL_OW 310
135439: IFFALSE 135507
// begin z := IsInUnit ( group [ i ] ) ;
135441: LD_ADDR_VAR 0 13
135445: PUSH
135446: LD_VAR 0 4
135450: PUSH
135451: LD_VAR 0 7
135455: ARRAY
135456: PPUSH
135457: CALL_OW 310
135461: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
135462: LD_VAR 0 13
135466: PUSH
135467: LD_VAR 0 32
135471: IN
135472: PUSH
135473: LD_VAR 0 13
135477: PPUSH
135478: LD_VAR 0 22
135482: PPUSH
135483: CALL_OW 308
135487: AND
135488: IFFALSE 135505
// ComExitVehicle ( group [ i ] ) ;
135490: LD_VAR 0 4
135494: PUSH
135495: LD_VAR 0 7
135499: ARRAY
135500: PPUSH
135501: CALL_OW 121
// end else
135505: GO 135684
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
135507: LD_ADDR_VAR 0 13
135511: PUSH
135512: LD_VAR 0 4
135516: PPUSH
135517: LD_INT 95
135519: PUSH
135520: LD_VAR 0 22
135524: PUSH
135525: EMPTY
135526: LIST
135527: LIST
135528: PUSH
135529: LD_INT 58
135531: PUSH
135532: EMPTY
135533: LIST
135534: PUSH
135535: EMPTY
135536: LIST
135537: LIST
135538: PPUSH
135539: CALL_OW 72
135543: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
135544: LD_VAR 0 4
135548: PUSH
135549: LD_VAR 0 7
135553: ARRAY
135554: PPUSH
135555: CALL_OW 314
135559: NOT
135560: IFFALSE 135682
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
135562: LD_ADDR_VAR 0 10
135566: PUSH
135567: LD_VAR 0 13
135571: PPUSH
135572: LD_VAR 0 4
135576: PUSH
135577: LD_VAR 0 7
135581: ARRAY
135582: PPUSH
135583: CALL_OW 74
135587: ST_TO_ADDR
// if not x then
135588: LD_VAR 0 10
135592: NOT
135593: IFFALSE 135597
// continue ;
135595: GO 135029
// if GetLives ( x ) < 1000 then
135597: LD_VAR 0 10
135601: PPUSH
135602: CALL_OW 256
135606: PUSH
135607: LD_INT 1000
135609: LESS
135610: IFFALSE 135634
// ComRepairVehicle ( group [ i ] , x ) else
135612: LD_VAR 0 4
135616: PUSH
135617: LD_VAR 0 7
135621: ARRAY
135622: PPUSH
135623: LD_VAR 0 10
135627: PPUSH
135628: CALL_OW 129
135632: GO 135682
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
135634: LD_VAR 0 23
135638: PUSH
135639: LD_VAR 0 4
135643: PUSH
135644: LD_VAR 0 7
135648: ARRAY
135649: PPUSH
135650: CALL_OW 256
135654: PUSH
135655: LD_INT 1000
135657: LESS
135658: AND
135659: NOT
135660: IFFALSE 135682
// ComEnterUnit ( group [ i ] , x ) ;
135662: LD_VAR 0 4
135666: PUSH
135667: LD_VAR 0 7
135671: ARRAY
135672: PPUSH
135673: LD_VAR 0 10
135677: PPUSH
135678: CALL_OW 120
// end ; continue ;
135682: GO 135029
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
135684: LD_VAR 0 23
135688: PUSH
135689: LD_VAR 0 4
135693: PUSH
135694: LD_VAR 0 7
135698: ARRAY
135699: PPUSH
135700: CALL_OW 247
135704: PUSH
135705: LD_INT 1
135707: EQUAL
135708: AND
135709: IFFALSE 136187
// begin if group [ i ] in healers then
135711: LD_VAR 0 4
135715: PUSH
135716: LD_VAR 0 7
135720: ARRAY
135721: PUSH
135722: LD_VAR 0 31
135726: IN
135727: IFFALSE 136000
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
135729: LD_VAR 0 4
135733: PUSH
135734: LD_VAR 0 7
135738: ARRAY
135739: PPUSH
135740: LD_VAR 0 23
135744: PPUSH
135745: CALL_OW 308
135749: NOT
135750: PUSH
135751: LD_VAR 0 4
135755: PUSH
135756: LD_VAR 0 7
135760: ARRAY
135761: PPUSH
135762: CALL_OW 314
135766: NOT
135767: AND
135768: IFFALSE 135792
// ComMoveToArea ( group [ i ] , f_heal ) else
135770: LD_VAR 0 4
135774: PUSH
135775: LD_VAR 0 7
135779: ARRAY
135780: PPUSH
135781: LD_VAR 0 23
135785: PPUSH
135786: CALL_OW 113
135790: GO 135998
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
135792: LD_VAR 0 4
135796: PUSH
135797: LD_VAR 0 7
135801: ARRAY
135802: PPUSH
135803: CALL 105471 0 1
135807: PPUSH
135808: CALL_OW 256
135812: PUSH
135813: LD_INT 1000
135815: EQUAL
135816: IFFALSE 135835
// ComStop ( group [ i ] ) else
135818: LD_VAR 0 4
135822: PUSH
135823: LD_VAR 0 7
135827: ARRAY
135828: PPUSH
135829: CALL_OW 141
135833: GO 135998
// if not HasTask ( group [ i ] ) and to_heal then
135835: LD_VAR 0 4
135839: PUSH
135840: LD_VAR 0 7
135844: ARRAY
135845: PPUSH
135846: CALL_OW 314
135850: NOT
135851: PUSH
135852: LD_VAR 0 30
135856: AND
135857: IFFALSE 135998
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
135859: LD_ADDR_VAR 0 13
135863: PUSH
135864: LD_VAR 0 30
135868: PPUSH
135869: LD_INT 3
135871: PUSH
135872: LD_INT 54
135874: PUSH
135875: EMPTY
135876: LIST
135877: PUSH
135878: EMPTY
135879: LIST
135880: LIST
135881: PPUSH
135882: CALL_OW 72
135886: PPUSH
135887: LD_VAR 0 4
135891: PUSH
135892: LD_VAR 0 7
135896: ARRAY
135897: PPUSH
135898: CALL_OW 74
135902: ST_TO_ADDR
// if z then
135903: LD_VAR 0 13
135907: IFFALSE 135998
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
135909: LD_INT 91
135911: PUSH
135912: LD_VAR 0 13
135916: PUSH
135917: LD_INT 10
135919: PUSH
135920: EMPTY
135921: LIST
135922: LIST
135923: LIST
135924: PUSH
135925: LD_INT 81
135927: PUSH
135928: LD_VAR 0 13
135932: PPUSH
135933: CALL_OW 255
135937: PUSH
135938: EMPTY
135939: LIST
135940: LIST
135941: PUSH
135942: EMPTY
135943: LIST
135944: LIST
135945: PPUSH
135946: CALL_OW 69
135950: PUSH
135951: LD_INT 0
135953: EQUAL
135954: IFFALSE 135978
// ComHeal ( group [ i ] , z ) else
135956: LD_VAR 0 4
135960: PUSH
135961: LD_VAR 0 7
135965: ARRAY
135966: PPUSH
135967: LD_VAR 0 13
135971: PPUSH
135972: CALL_OW 128
135976: GO 135998
// ComMoveToArea ( group [ i ] , f_heal ) ;
135978: LD_VAR 0 4
135982: PUSH
135983: LD_VAR 0 7
135987: ARRAY
135988: PPUSH
135989: LD_VAR 0 23
135993: PPUSH
135994: CALL_OW 113
// end ; continue ;
135998: GO 135029
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
136000: LD_VAR 0 4
136004: PUSH
136005: LD_VAR 0 7
136009: ARRAY
136010: PPUSH
136011: CALL_OW 256
136015: PUSH
136016: LD_INT 700
136018: LESS
136019: PUSH
136020: LD_VAR 0 4
136024: PUSH
136025: LD_VAR 0 7
136029: ARRAY
136030: PUSH
136031: LD_VAR 0 30
136035: IN
136036: NOT
136037: AND
136038: IFFALSE 136062
// to_heal := to_heal union group [ i ] ;
136040: LD_ADDR_VAR 0 30
136044: PUSH
136045: LD_VAR 0 30
136049: PUSH
136050: LD_VAR 0 4
136054: PUSH
136055: LD_VAR 0 7
136059: ARRAY
136060: UNION
136061: ST_TO_ADDR
// if group [ i ] in to_heal then
136062: LD_VAR 0 4
136066: PUSH
136067: LD_VAR 0 7
136071: ARRAY
136072: PUSH
136073: LD_VAR 0 30
136077: IN
136078: IFFALSE 136187
// begin if GetLives ( group [ i ] ) = 1000 then
136080: LD_VAR 0 4
136084: PUSH
136085: LD_VAR 0 7
136089: ARRAY
136090: PPUSH
136091: CALL_OW 256
136095: PUSH
136096: LD_INT 1000
136098: EQUAL
136099: IFFALSE 136125
// to_heal := to_heal diff group [ i ] else
136101: LD_ADDR_VAR 0 30
136105: PUSH
136106: LD_VAR 0 30
136110: PUSH
136111: LD_VAR 0 4
136115: PUSH
136116: LD_VAR 0 7
136120: ARRAY
136121: DIFF
136122: ST_TO_ADDR
136123: GO 136187
// begin if not IsInArea ( group [ i ] , to_heal ) then
136125: LD_VAR 0 4
136129: PUSH
136130: LD_VAR 0 7
136134: ARRAY
136135: PPUSH
136136: LD_VAR 0 30
136140: PPUSH
136141: CALL_OW 308
136145: NOT
136146: IFFALSE 136170
// ComMoveToArea ( group [ i ] , f_heal ) else
136148: LD_VAR 0 4
136152: PUSH
136153: LD_VAR 0 7
136157: ARRAY
136158: PPUSH
136159: LD_VAR 0 23
136163: PPUSH
136164: CALL_OW 113
136168: GO 136185
// ComHold ( group [ i ] ) ;
136170: LD_VAR 0 4
136174: PUSH
136175: LD_VAR 0 7
136179: ARRAY
136180: PPUSH
136181: CALL_OW 140
// continue ;
136185: GO 135029
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
136187: LD_VAR 0 4
136191: PUSH
136192: LD_VAR 0 7
136196: ARRAY
136197: PPUSH
136198: LD_INT 10
136200: PPUSH
136201: CALL 103233 0 2
136205: NOT
136206: PUSH
136207: LD_VAR 0 16
136211: PUSH
136212: LD_VAR 0 7
136216: ARRAY
136217: PUSH
136218: EMPTY
136219: EQUAL
136220: NOT
136221: AND
136222: IFFALSE 136488
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
136224: LD_VAR 0 4
136228: PUSH
136229: LD_VAR 0 7
136233: ARRAY
136234: PPUSH
136235: CALL_OW 262
136239: PUSH
136240: LD_INT 1
136242: PUSH
136243: LD_INT 2
136245: PUSH
136246: EMPTY
136247: LIST
136248: LIST
136249: IN
136250: IFFALSE 136291
// if GetFuel ( group [ i ] ) < 10 then
136252: LD_VAR 0 4
136256: PUSH
136257: LD_VAR 0 7
136261: ARRAY
136262: PPUSH
136263: CALL_OW 261
136267: PUSH
136268: LD_INT 10
136270: LESS
136271: IFFALSE 136291
// SetFuel ( group [ i ] , 12 ) ;
136273: LD_VAR 0 4
136277: PUSH
136278: LD_VAR 0 7
136282: ARRAY
136283: PPUSH
136284: LD_INT 12
136286: PPUSH
136287: CALL_OW 240
// if units_path [ i ] then
136291: LD_VAR 0 16
136295: PUSH
136296: LD_VAR 0 7
136300: ARRAY
136301: IFFALSE 136486
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
136303: LD_VAR 0 4
136307: PUSH
136308: LD_VAR 0 7
136312: ARRAY
136313: PPUSH
136314: LD_VAR 0 16
136318: PUSH
136319: LD_VAR 0 7
136323: ARRAY
136324: PUSH
136325: LD_INT 1
136327: ARRAY
136328: PUSH
136329: LD_INT 1
136331: ARRAY
136332: PPUSH
136333: LD_VAR 0 16
136337: PUSH
136338: LD_VAR 0 7
136342: ARRAY
136343: PUSH
136344: LD_INT 1
136346: ARRAY
136347: PUSH
136348: LD_INT 2
136350: ARRAY
136351: PPUSH
136352: CALL_OW 297
136356: PUSH
136357: LD_INT 6
136359: GREATER
136360: IFFALSE 136435
// begin if not HasTask ( group [ i ] ) then
136362: LD_VAR 0 4
136366: PUSH
136367: LD_VAR 0 7
136371: ARRAY
136372: PPUSH
136373: CALL_OW 314
136377: NOT
136378: IFFALSE 136433
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
136380: LD_VAR 0 4
136384: PUSH
136385: LD_VAR 0 7
136389: ARRAY
136390: PPUSH
136391: LD_VAR 0 16
136395: PUSH
136396: LD_VAR 0 7
136400: ARRAY
136401: PUSH
136402: LD_INT 1
136404: ARRAY
136405: PUSH
136406: LD_INT 1
136408: ARRAY
136409: PPUSH
136410: LD_VAR 0 16
136414: PUSH
136415: LD_VAR 0 7
136419: ARRAY
136420: PUSH
136421: LD_INT 1
136423: ARRAY
136424: PUSH
136425: LD_INT 2
136427: ARRAY
136428: PPUSH
136429: CALL_OW 114
// end else
136433: GO 136486
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
136435: LD_ADDR_VAR 0 15
136439: PUSH
136440: LD_VAR 0 16
136444: PUSH
136445: LD_VAR 0 7
136449: ARRAY
136450: PPUSH
136451: LD_INT 1
136453: PPUSH
136454: CALL_OW 3
136458: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
136459: LD_ADDR_VAR 0 16
136463: PUSH
136464: LD_VAR 0 16
136468: PPUSH
136469: LD_VAR 0 7
136473: PPUSH
136474: LD_VAR 0 15
136478: PPUSH
136479: CALL_OW 1
136483: ST_TO_ADDR
// continue ;
136484: GO 135029
// end ; end ; end else
136486: GO 139150
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
136488: LD_ADDR_VAR 0 14
136492: PUSH
136493: LD_INT 81
136495: PUSH
136496: LD_VAR 0 4
136500: PUSH
136501: LD_VAR 0 7
136505: ARRAY
136506: PPUSH
136507: CALL_OW 255
136511: PUSH
136512: EMPTY
136513: LIST
136514: LIST
136515: PPUSH
136516: CALL_OW 69
136520: ST_TO_ADDR
// if not tmp then
136521: LD_VAR 0 14
136525: NOT
136526: IFFALSE 136530
// continue ;
136528: GO 135029
// if f_ignore_area then
136530: LD_VAR 0 17
136534: IFFALSE 136622
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
136536: LD_ADDR_VAR 0 15
136540: PUSH
136541: LD_VAR 0 14
136545: PPUSH
136546: LD_INT 3
136548: PUSH
136549: LD_INT 92
136551: PUSH
136552: LD_VAR 0 17
136556: PUSH
136557: LD_INT 1
136559: ARRAY
136560: PUSH
136561: LD_VAR 0 17
136565: PUSH
136566: LD_INT 2
136568: ARRAY
136569: PUSH
136570: LD_VAR 0 17
136574: PUSH
136575: LD_INT 3
136577: ARRAY
136578: PUSH
136579: EMPTY
136580: LIST
136581: LIST
136582: LIST
136583: LIST
136584: PUSH
136585: EMPTY
136586: LIST
136587: LIST
136588: PPUSH
136589: CALL_OW 72
136593: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
136594: LD_VAR 0 14
136598: PUSH
136599: LD_VAR 0 15
136603: DIFF
136604: IFFALSE 136622
// tmp := tmp diff tmp2 ;
136606: LD_ADDR_VAR 0 14
136610: PUSH
136611: LD_VAR 0 14
136615: PUSH
136616: LD_VAR 0 15
136620: DIFF
136621: ST_TO_ADDR
// end ; if not f_murder then
136622: LD_VAR 0 20
136626: NOT
136627: IFFALSE 136685
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
136629: LD_ADDR_VAR 0 15
136633: PUSH
136634: LD_VAR 0 14
136638: PPUSH
136639: LD_INT 3
136641: PUSH
136642: LD_INT 50
136644: PUSH
136645: EMPTY
136646: LIST
136647: PUSH
136648: EMPTY
136649: LIST
136650: LIST
136651: PPUSH
136652: CALL_OW 72
136656: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
136657: LD_VAR 0 14
136661: PUSH
136662: LD_VAR 0 15
136666: DIFF
136667: IFFALSE 136685
// tmp := tmp diff tmp2 ;
136669: LD_ADDR_VAR 0 14
136673: PUSH
136674: LD_VAR 0 14
136678: PUSH
136679: LD_VAR 0 15
136683: DIFF
136684: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
136685: LD_ADDR_VAR 0 14
136689: PUSH
136690: LD_VAR 0 4
136694: PUSH
136695: LD_VAR 0 7
136699: ARRAY
136700: PPUSH
136701: LD_VAR 0 14
136705: PPUSH
136706: LD_INT 1
136708: PPUSH
136709: LD_INT 1
136711: PPUSH
136712: CALL 75777 0 4
136716: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
136717: LD_VAR 0 4
136721: PUSH
136722: LD_VAR 0 7
136726: ARRAY
136727: PPUSH
136728: CALL_OW 257
136732: PUSH
136733: LD_INT 1
136735: EQUAL
136736: IFFALSE 137184
// begin if WantPlant ( group [ i ] ) then
136738: LD_VAR 0 4
136742: PUSH
136743: LD_VAR 0 7
136747: ARRAY
136748: PPUSH
136749: CALL 75278 0 1
136753: IFFALSE 136757
// continue ;
136755: GO 135029
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
136757: LD_VAR 0 18
136761: PUSH
136762: LD_VAR 0 4
136766: PUSH
136767: LD_VAR 0 7
136771: ARRAY
136772: PPUSH
136773: CALL_OW 310
136777: NOT
136778: AND
136779: PUSH
136780: LD_VAR 0 14
136784: PUSH
136785: LD_INT 1
136787: ARRAY
136788: PUSH
136789: LD_VAR 0 14
136793: PPUSH
136794: LD_INT 21
136796: PUSH
136797: LD_INT 2
136799: PUSH
136800: EMPTY
136801: LIST
136802: LIST
136803: PUSH
136804: LD_INT 58
136806: PUSH
136807: EMPTY
136808: LIST
136809: PUSH
136810: EMPTY
136811: LIST
136812: LIST
136813: PPUSH
136814: CALL_OW 72
136818: IN
136819: AND
136820: IFFALSE 136856
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
136822: LD_VAR 0 4
136826: PUSH
136827: LD_VAR 0 7
136831: ARRAY
136832: PPUSH
136833: LD_VAR 0 14
136837: PUSH
136838: LD_INT 1
136840: ARRAY
136841: PPUSH
136842: CALL_OW 120
// attacking := true ;
136846: LD_ADDR_VAR 0 29
136850: PUSH
136851: LD_INT 1
136853: ST_TO_ADDR
// continue ;
136854: GO 135029
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
136856: LD_VAR 0 26
136860: PUSH
136861: LD_VAR 0 4
136865: PUSH
136866: LD_VAR 0 7
136870: ARRAY
136871: PPUSH
136872: CALL_OW 257
136876: PUSH
136877: LD_INT 1
136879: EQUAL
136880: AND
136881: PUSH
136882: LD_VAR 0 4
136886: PUSH
136887: LD_VAR 0 7
136891: ARRAY
136892: PPUSH
136893: CALL_OW 256
136897: PUSH
136898: LD_INT 800
136900: LESS
136901: AND
136902: PUSH
136903: LD_VAR 0 4
136907: PUSH
136908: LD_VAR 0 7
136912: ARRAY
136913: PPUSH
136914: CALL_OW 318
136918: NOT
136919: AND
136920: IFFALSE 136937
// ComCrawl ( group [ i ] ) ;
136922: LD_VAR 0 4
136926: PUSH
136927: LD_VAR 0 7
136931: ARRAY
136932: PPUSH
136933: CALL_OW 137
// if f_mines then
136937: LD_VAR 0 21
136941: IFFALSE 137184
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
136943: LD_VAR 0 14
136947: PUSH
136948: LD_INT 1
136950: ARRAY
136951: PPUSH
136952: CALL_OW 247
136956: PUSH
136957: LD_INT 3
136959: EQUAL
136960: PUSH
136961: LD_VAR 0 14
136965: PUSH
136966: LD_INT 1
136968: ARRAY
136969: PUSH
136970: LD_VAR 0 27
136974: IN
136975: NOT
136976: AND
136977: IFFALSE 137184
// begin x := GetX ( tmp [ 1 ] ) ;
136979: LD_ADDR_VAR 0 10
136983: PUSH
136984: LD_VAR 0 14
136988: PUSH
136989: LD_INT 1
136991: ARRAY
136992: PPUSH
136993: CALL_OW 250
136997: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
136998: LD_ADDR_VAR 0 11
137002: PUSH
137003: LD_VAR 0 14
137007: PUSH
137008: LD_INT 1
137010: ARRAY
137011: PPUSH
137012: CALL_OW 251
137016: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
137017: LD_ADDR_VAR 0 12
137021: PUSH
137022: LD_VAR 0 4
137026: PUSH
137027: LD_VAR 0 7
137031: ARRAY
137032: PPUSH
137033: CALL 103318 0 1
137037: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
137038: LD_VAR 0 4
137042: PUSH
137043: LD_VAR 0 7
137047: ARRAY
137048: PPUSH
137049: LD_VAR 0 10
137053: PPUSH
137054: LD_VAR 0 11
137058: PPUSH
137059: LD_VAR 0 14
137063: PUSH
137064: LD_INT 1
137066: ARRAY
137067: PPUSH
137068: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
137072: LD_VAR 0 4
137076: PUSH
137077: LD_VAR 0 7
137081: ARRAY
137082: PPUSH
137083: LD_VAR 0 10
137087: PPUSH
137088: LD_VAR 0 12
137092: PPUSH
137093: LD_INT 7
137095: PPUSH
137096: CALL_OW 272
137100: PPUSH
137101: LD_VAR 0 11
137105: PPUSH
137106: LD_VAR 0 12
137110: PPUSH
137111: LD_INT 7
137113: PPUSH
137114: CALL_OW 273
137118: PPUSH
137119: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
137123: LD_VAR 0 4
137127: PUSH
137128: LD_VAR 0 7
137132: ARRAY
137133: PPUSH
137134: LD_INT 71
137136: PPUSH
137137: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
137141: LD_ADDR_VAR 0 27
137145: PUSH
137146: LD_VAR 0 27
137150: PPUSH
137151: LD_VAR 0 27
137155: PUSH
137156: LD_INT 1
137158: PLUS
137159: PPUSH
137160: LD_VAR 0 14
137164: PUSH
137165: LD_INT 1
137167: ARRAY
137168: PPUSH
137169: CALL_OW 1
137173: ST_TO_ADDR
// attacking := true ;
137174: LD_ADDR_VAR 0 29
137178: PUSH
137179: LD_INT 1
137181: ST_TO_ADDR
// continue ;
137182: GO 135029
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
137184: LD_VAR 0 4
137188: PUSH
137189: LD_VAR 0 7
137193: ARRAY
137194: PPUSH
137195: CALL_OW 257
137199: PUSH
137200: LD_INT 17
137202: EQUAL
137203: PUSH
137204: LD_VAR 0 4
137208: PUSH
137209: LD_VAR 0 7
137213: ARRAY
137214: PPUSH
137215: CALL_OW 110
137219: PUSH
137220: LD_INT 71
137222: EQUAL
137223: NOT
137224: AND
137225: IFFALSE 137371
// begin attacking := false ;
137227: LD_ADDR_VAR 0 29
137231: PUSH
137232: LD_INT 0
137234: ST_TO_ADDR
// k := 5 ;
137235: LD_ADDR_VAR 0 9
137239: PUSH
137240: LD_INT 5
137242: ST_TO_ADDR
// if tmp < k then
137243: LD_VAR 0 14
137247: PUSH
137248: LD_VAR 0 9
137252: LESS
137253: IFFALSE 137265
// k := tmp ;
137255: LD_ADDR_VAR 0 9
137259: PUSH
137260: LD_VAR 0 14
137264: ST_TO_ADDR
// for j = 1 to k do
137265: LD_ADDR_VAR 0 8
137269: PUSH
137270: DOUBLE
137271: LD_INT 1
137273: DEC
137274: ST_TO_ADDR
137275: LD_VAR 0 9
137279: PUSH
137280: FOR_TO
137281: IFFALSE 137369
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
137283: LD_VAR 0 14
137287: PUSH
137288: LD_VAR 0 8
137292: ARRAY
137293: PUSH
137294: LD_VAR 0 14
137298: PPUSH
137299: LD_INT 58
137301: PUSH
137302: EMPTY
137303: LIST
137304: PPUSH
137305: CALL_OW 72
137309: IN
137310: NOT
137311: IFFALSE 137367
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
137313: LD_VAR 0 4
137317: PUSH
137318: LD_VAR 0 7
137322: ARRAY
137323: PPUSH
137324: LD_VAR 0 14
137328: PUSH
137329: LD_VAR 0 8
137333: ARRAY
137334: PPUSH
137335: CALL_OW 115
// attacking := true ;
137339: LD_ADDR_VAR 0 29
137343: PUSH
137344: LD_INT 1
137346: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
137347: LD_VAR 0 4
137351: PUSH
137352: LD_VAR 0 7
137356: ARRAY
137357: PPUSH
137358: LD_INT 71
137360: PPUSH
137361: CALL_OW 109
// continue ;
137365: GO 137280
// end ; end ;
137367: GO 137280
137369: POP
137370: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
137371: LD_VAR 0 4
137375: PUSH
137376: LD_VAR 0 7
137380: ARRAY
137381: PPUSH
137382: CALL_OW 257
137386: PUSH
137387: LD_INT 8
137389: EQUAL
137390: PUSH
137391: LD_VAR 0 4
137395: PUSH
137396: LD_VAR 0 7
137400: ARRAY
137401: PPUSH
137402: CALL_OW 264
137406: PUSH
137407: LD_INT 28
137409: PUSH
137410: LD_INT 45
137412: PUSH
137413: LD_INT 7
137415: PUSH
137416: LD_INT 47
137418: PUSH
137419: EMPTY
137420: LIST
137421: LIST
137422: LIST
137423: LIST
137424: IN
137425: OR
137426: IFFALSE 137682
// begin attacking := false ;
137428: LD_ADDR_VAR 0 29
137432: PUSH
137433: LD_INT 0
137435: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
137436: LD_VAR 0 14
137440: PUSH
137441: LD_INT 1
137443: ARRAY
137444: PPUSH
137445: CALL_OW 266
137449: PUSH
137450: LD_INT 32
137452: PUSH
137453: LD_INT 31
137455: PUSH
137456: LD_INT 33
137458: PUSH
137459: LD_INT 4
137461: PUSH
137462: LD_INT 5
137464: PUSH
137465: EMPTY
137466: LIST
137467: LIST
137468: LIST
137469: LIST
137470: LIST
137471: IN
137472: IFFALSE 137658
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
137474: LD_ADDR_VAR 0 9
137478: PUSH
137479: LD_VAR 0 14
137483: PUSH
137484: LD_INT 1
137486: ARRAY
137487: PPUSH
137488: CALL_OW 266
137492: PPUSH
137493: LD_VAR 0 14
137497: PUSH
137498: LD_INT 1
137500: ARRAY
137501: PPUSH
137502: CALL_OW 250
137506: PPUSH
137507: LD_VAR 0 14
137511: PUSH
137512: LD_INT 1
137514: ARRAY
137515: PPUSH
137516: CALL_OW 251
137520: PPUSH
137521: LD_VAR 0 14
137525: PUSH
137526: LD_INT 1
137528: ARRAY
137529: PPUSH
137530: CALL_OW 254
137534: PPUSH
137535: LD_VAR 0 14
137539: PUSH
137540: LD_INT 1
137542: ARRAY
137543: PPUSH
137544: CALL_OW 248
137548: PPUSH
137549: LD_INT 0
137551: PPUSH
137552: CALL 84688 0 6
137556: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
137557: LD_ADDR_VAR 0 8
137561: PUSH
137562: LD_VAR 0 4
137566: PUSH
137567: LD_VAR 0 7
137571: ARRAY
137572: PPUSH
137573: LD_VAR 0 9
137577: PPUSH
137578: CALL 103431 0 2
137582: ST_TO_ADDR
// if j then
137583: LD_VAR 0 8
137587: IFFALSE 137656
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
137589: LD_VAR 0 8
137593: PUSH
137594: LD_INT 1
137596: ARRAY
137597: PPUSH
137598: LD_VAR 0 8
137602: PUSH
137603: LD_INT 2
137605: ARRAY
137606: PPUSH
137607: CALL_OW 488
137611: IFFALSE 137656
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
137613: LD_VAR 0 4
137617: PUSH
137618: LD_VAR 0 7
137622: ARRAY
137623: PPUSH
137624: LD_VAR 0 8
137628: PUSH
137629: LD_INT 1
137631: ARRAY
137632: PPUSH
137633: LD_VAR 0 8
137637: PUSH
137638: LD_INT 2
137640: ARRAY
137641: PPUSH
137642: CALL_OW 116
// attacking := true ;
137646: LD_ADDR_VAR 0 29
137650: PUSH
137651: LD_INT 1
137653: ST_TO_ADDR
// continue ;
137654: GO 135029
// end ; end else
137656: GO 137682
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
137658: LD_VAR 0 4
137662: PUSH
137663: LD_VAR 0 7
137667: ARRAY
137668: PPUSH
137669: LD_VAR 0 14
137673: PUSH
137674: LD_INT 1
137676: ARRAY
137677: PPUSH
137678: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
137682: LD_VAR 0 4
137686: PUSH
137687: LD_VAR 0 7
137691: ARRAY
137692: PPUSH
137693: CALL_OW 265
137697: PUSH
137698: LD_INT 11
137700: EQUAL
137701: IFFALSE 137979
// begin k := 10 ;
137703: LD_ADDR_VAR 0 9
137707: PUSH
137708: LD_INT 10
137710: ST_TO_ADDR
// x := 0 ;
137711: LD_ADDR_VAR 0 10
137715: PUSH
137716: LD_INT 0
137718: ST_TO_ADDR
// if tmp < k then
137719: LD_VAR 0 14
137723: PUSH
137724: LD_VAR 0 9
137728: LESS
137729: IFFALSE 137741
// k := tmp ;
137731: LD_ADDR_VAR 0 9
137735: PUSH
137736: LD_VAR 0 14
137740: ST_TO_ADDR
// for j = k downto 1 do
137741: LD_ADDR_VAR 0 8
137745: PUSH
137746: DOUBLE
137747: LD_VAR 0 9
137751: INC
137752: ST_TO_ADDR
137753: LD_INT 1
137755: PUSH
137756: FOR_DOWNTO
137757: IFFALSE 137832
// begin if GetType ( tmp [ j ] ) = unit_human then
137759: LD_VAR 0 14
137763: PUSH
137764: LD_VAR 0 8
137768: ARRAY
137769: PPUSH
137770: CALL_OW 247
137774: PUSH
137775: LD_INT 1
137777: EQUAL
137778: IFFALSE 137830
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
137780: LD_VAR 0 4
137784: PUSH
137785: LD_VAR 0 7
137789: ARRAY
137790: PPUSH
137791: LD_VAR 0 14
137795: PUSH
137796: LD_VAR 0 8
137800: ARRAY
137801: PPUSH
137802: CALL 103685 0 2
// x := tmp [ j ] ;
137806: LD_ADDR_VAR 0 10
137810: PUSH
137811: LD_VAR 0 14
137815: PUSH
137816: LD_VAR 0 8
137820: ARRAY
137821: ST_TO_ADDR
// attacking := true ;
137822: LD_ADDR_VAR 0 29
137826: PUSH
137827: LD_INT 1
137829: ST_TO_ADDR
// end ; end ;
137830: GO 137756
137832: POP
137833: POP
// if not x then
137834: LD_VAR 0 10
137838: NOT
137839: IFFALSE 137979
// begin attacking := true ;
137841: LD_ADDR_VAR 0 29
137845: PUSH
137846: LD_INT 1
137848: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
137849: LD_VAR 0 4
137853: PUSH
137854: LD_VAR 0 7
137858: ARRAY
137859: PPUSH
137860: CALL_OW 250
137864: PPUSH
137865: LD_VAR 0 4
137869: PUSH
137870: LD_VAR 0 7
137874: ARRAY
137875: PPUSH
137876: CALL_OW 251
137880: PPUSH
137881: CALL_OW 546
137885: PUSH
137886: LD_INT 2
137888: ARRAY
137889: PUSH
137890: LD_VAR 0 14
137894: PUSH
137895: LD_INT 1
137897: ARRAY
137898: PPUSH
137899: CALL_OW 250
137903: PPUSH
137904: LD_VAR 0 14
137908: PUSH
137909: LD_INT 1
137911: ARRAY
137912: PPUSH
137913: CALL_OW 251
137917: PPUSH
137918: CALL_OW 546
137922: PUSH
137923: LD_INT 2
137925: ARRAY
137926: EQUAL
137927: IFFALSE 137955
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
137929: LD_VAR 0 4
137933: PUSH
137934: LD_VAR 0 7
137938: ARRAY
137939: PPUSH
137940: LD_VAR 0 14
137944: PUSH
137945: LD_INT 1
137947: ARRAY
137948: PPUSH
137949: CALL 103685 0 2
137953: GO 137979
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
137955: LD_VAR 0 4
137959: PUSH
137960: LD_VAR 0 7
137964: ARRAY
137965: PPUSH
137966: LD_VAR 0 14
137970: PUSH
137971: LD_INT 1
137973: ARRAY
137974: PPUSH
137975: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
137979: LD_VAR 0 4
137983: PUSH
137984: LD_VAR 0 7
137988: ARRAY
137989: PPUSH
137990: CALL_OW 264
137994: PUSH
137995: LD_INT 29
137997: EQUAL
137998: IFFALSE 138364
// begin if WantsToAttack ( group [ i ] ) in bombed then
138000: LD_VAR 0 4
138004: PUSH
138005: LD_VAR 0 7
138009: ARRAY
138010: PPUSH
138011: CALL_OW 319
138015: PUSH
138016: LD_VAR 0 28
138020: IN
138021: IFFALSE 138025
// continue ;
138023: GO 135029
// k := 8 ;
138025: LD_ADDR_VAR 0 9
138029: PUSH
138030: LD_INT 8
138032: ST_TO_ADDR
// x := 0 ;
138033: LD_ADDR_VAR 0 10
138037: PUSH
138038: LD_INT 0
138040: ST_TO_ADDR
// if tmp < k then
138041: LD_VAR 0 14
138045: PUSH
138046: LD_VAR 0 9
138050: LESS
138051: IFFALSE 138063
// k := tmp ;
138053: LD_ADDR_VAR 0 9
138057: PUSH
138058: LD_VAR 0 14
138062: ST_TO_ADDR
// for j = 1 to k do
138063: LD_ADDR_VAR 0 8
138067: PUSH
138068: DOUBLE
138069: LD_INT 1
138071: DEC
138072: ST_TO_ADDR
138073: LD_VAR 0 9
138077: PUSH
138078: FOR_TO
138079: IFFALSE 138211
// begin if GetType ( tmp [ j ] ) = unit_building then
138081: LD_VAR 0 14
138085: PUSH
138086: LD_VAR 0 8
138090: ARRAY
138091: PPUSH
138092: CALL_OW 247
138096: PUSH
138097: LD_INT 3
138099: EQUAL
138100: IFFALSE 138209
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
138102: LD_VAR 0 14
138106: PUSH
138107: LD_VAR 0 8
138111: ARRAY
138112: PUSH
138113: LD_VAR 0 28
138117: IN
138118: NOT
138119: PUSH
138120: LD_VAR 0 14
138124: PUSH
138125: LD_VAR 0 8
138129: ARRAY
138130: PPUSH
138131: CALL_OW 313
138135: AND
138136: IFFALSE 138209
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
138138: LD_VAR 0 4
138142: PUSH
138143: LD_VAR 0 7
138147: ARRAY
138148: PPUSH
138149: LD_VAR 0 14
138153: PUSH
138154: LD_VAR 0 8
138158: ARRAY
138159: PPUSH
138160: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
138164: LD_ADDR_VAR 0 28
138168: PUSH
138169: LD_VAR 0 28
138173: PPUSH
138174: LD_VAR 0 28
138178: PUSH
138179: LD_INT 1
138181: PLUS
138182: PPUSH
138183: LD_VAR 0 14
138187: PUSH
138188: LD_VAR 0 8
138192: ARRAY
138193: PPUSH
138194: CALL_OW 1
138198: ST_TO_ADDR
// attacking := true ;
138199: LD_ADDR_VAR 0 29
138203: PUSH
138204: LD_INT 1
138206: ST_TO_ADDR
// break ;
138207: GO 138211
// end ; end ;
138209: GO 138078
138211: POP
138212: POP
// if not attacking and f_attack_depot then
138213: LD_VAR 0 29
138217: NOT
138218: PUSH
138219: LD_VAR 0 25
138223: AND
138224: IFFALSE 138319
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
138226: LD_ADDR_VAR 0 13
138230: PUSH
138231: LD_VAR 0 14
138235: PPUSH
138236: LD_INT 2
138238: PUSH
138239: LD_INT 30
138241: PUSH
138242: LD_INT 0
138244: PUSH
138245: EMPTY
138246: LIST
138247: LIST
138248: PUSH
138249: LD_INT 30
138251: PUSH
138252: LD_INT 1
138254: PUSH
138255: EMPTY
138256: LIST
138257: LIST
138258: PUSH
138259: EMPTY
138260: LIST
138261: LIST
138262: LIST
138263: PPUSH
138264: CALL_OW 72
138268: ST_TO_ADDR
// if z then
138269: LD_VAR 0 13
138273: IFFALSE 138319
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
138275: LD_VAR 0 4
138279: PUSH
138280: LD_VAR 0 7
138284: ARRAY
138285: PPUSH
138286: LD_VAR 0 13
138290: PPUSH
138291: LD_VAR 0 4
138295: PUSH
138296: LD_VAR 0 7
138300: ARRAY
138301: PPUSH
138302: CALL_OW 74
138306: PPUSH
138307: CALL_OW 115
// attacking := true ;
138311: LD_ADDR_VAR 0 29
138315: PUSH
138316: LD_INT 1
138318: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
138319: LD_VAR 0 4
138323: PUSH
138324: LD_VAR 0 7
138328: ARRAY
138329: PPUSH
138330: CALL_OW 256
138334: PUSH
138335: LD_INT 500
138337: LESS
138338: IFFALSE 138364
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
138340: LD_VAR 0 4
138344: PUSH
138345: LD_VAR 0 7
138349: ARRAY
138350: PPUSH
138351: LD_VAR 0 14
138355: PUSH
138356: LD_INT 1
138358: ARRAY
138359: PPUSH
138360: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
138364: LD_VAR 0 4
138368: PUSH
138369: LD_VAR 0 7
138373: ARRAY
138374: PPUSH
138375: CALL_OW 264
138379: PUSH
138380: LD_INT 49
138382: EQUAL
138383: IFFALSE 138504
// begin if not HasTask ( group [ i ] ) then
138385: LD_VAR 0 4
138389: PUSH
138390: LD_VAR 0 7
138394: ARRAY
138395: PPUSH
138396: CALL_OW 314
138400: NOT
138401: IFFALSE 138504
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
138403: LD_ADDR_VAR 0 9
138407: PUSH
138408: LD_INT 81
138410: PUSH
138411: LD_VAR 0 4
138415: PUSH
138416: LD_VAR 0 7
138420: ARRAY
138421: PPUSH
138422: CALL_OW 255
138426: PUSH
138427: EMPTY
138428: LIST
138429: LIST
138430: PPUSH
138431: CALL_OW 69
138435: PPUSH
138436: LD_VAR 0 4
138440: PUSH
138441: LD_VAR 0 7
138445: ARRAY
138446: PPUSH
138447: CALL_OW 74
138451: ST_TO_ADDR
// if k then
138452: LD_VAR 0 9
138456: IFFALSE 138504
// if GetDistUnits ( group [ i ] , k ) > 10 then
138458: LD_VAR 0 4
138462: PUSH
138463: LD_VAR 0 7
138467: ARRAY
138468: PPUSH
138469: LD_VAR 0 9
138473: PPUSH
138474: CALL_OW 296
138478: PUSH
138479: LD_INT 10
138481: GREATER
138482: IFFALSE 138504
// ComMoveUnit ( group [ i ] , k ) ;
138484: LD_VAR 0 4
138488: PUSH
138489: LD_VAR 0 7
138493: ARRAY
138494: PPUSH
138495: LD_VAR 0 9
138499: PPUSH
138500: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
138504: LD_VAR 0 4
138508: PUSH
138509: LD_VAR 0 7
138513: ARRAY
138514: PPUSH
138515: CALL_OW 256
138519: PUSH
138520: LD_INT 250
138522: LESS
138523: PUSH
138524: LD_VAR 0 4
138528: PUSH
138529: LD_VAR 0 7
138533: ARRAY
138534: PUSH
138535: LD_INT 21
138537: PUSH
138538: LD_INT 2
138540: PUSH
138541: EMPTY
138542: LIST
138543: LIST
138544: PUSH
138545: LD_INT 23
138547: PUSH
138548: LD_INT 2
138550: PUSH
138551: EMPTY
138552: LIST
138553: LIST
138554: PUSH
138555: EMPTY
138556: LIST
138557: LIST
138558: PPUSH
138559: CALL_OW 69
138563: IN
138564: AND
138565: IFFALSE 138690
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
138567: LD_ADDR_VAR 0 9
138571: PUSH
138572: LD_OWVAR 3
138576: PUSH
138577: LD_VAR 0 4
138581: PUSH
138582: LD_VAR 0 7
138586: ARRAY
138587: DIFF
138588: PPUSH
138589: LD_VAR 0 4
138593: PUSH
138594: LD_VAR 0 7
138598: ARRAY
138599: PPUSH
138600: CALL_OW 74
138604: ST_TO_ADDR
// if not k then
138605: LD_VAR 0 9
138609: NOT
138610: IFFALSE 138614
// continue ;
138612: GO 135029
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
138614: LD_VAR 0 9
138618: PUSH
138619: LD_INT 81
138621: PUSH
138622: LD_VAR 0 4
138626: PUSH
138627: LD_VAR 0 7
138631: ARRAY
138632: PPUSH
138633: CALL_OW 255
138637: PUSH
138638: EMPTY
138639: LIST
138640: LIST
138641: PPUSH
138642: CALL_OW 69
138646: IN
138647: PUSH
138648: LD_VAR 0 9
138652: PPUSH
138653: LD_VAR 0 4
138657: PUSH
138658: LD_VAR 0 7
138662: ARRAY
138663: PPUSH
138664: CALL_OW 296
138668: PUSH
138669: LD_INT 5
138671: LESS
138672: AND
138673: IFFALSE 138690
// ComAutodestruct ( group [ i ] ) ;
138675: LD_VAR 0 4
138679: PUSH
138680: LD_VAR 0 7
138684: ARRAY
138685: PPUSH
138686: CALL 103583 0 1
// end ; if f_attack_depot then
138690: LD_VAR 0 25
138694: IFFALSE 138806
// begin k := 6 ;
138696: LD_ADDR_VAR 0 9
138700: PUSH
138701: LD_INT 6
138703: ST_TO_ADDR
// if tmp < k then
138704: LD_VAR 0 14
138708: PUSH
138709: LD_VAR 0 9
138713: LESS
138714: IFFALSE 138726
// k := tmp ;
138716: LD_ADDR_VAR 0 9
138720: PUSH
138721: LD_VAR 0 14
138725: ST_TO_ADDR
// for j = 1 to k do
138726: LD_ADDR_VAR 0 8
138730: PUSH
138731: DOUBLE
138732: LD_INT 1
138734: DEC
138735: ST_TO_ADDR
138736: LD_VAR 0 9
138740: PUSH
138741: FOR_TO
138742: IFFALSE 138804
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
138744: LD_VAR 0 8
138748: PPUSH
138749: CALL_OW 266
138753: PUSH
138754: LD_INT 0
138756: PUSH
138757: LD_INT 1
138759: PUSH
138760: EMPTY
138761: LIST
138762: LIST
138763: IN
138764: IFFALSE 138802
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
138766: LD_VAR 0 4
138770: PUSH
138771: LD_VAR 0 7
138775: ARRAY
138776: PPUSH
138777: LD_VAR 0 14
138781: PUSH
138782: LD_VAR 0 8
138786: ARRAY
138787: PPUSH
138788: CALL_OW 115
// attacking := true ;
138792: LD_ADDR_VAR 0 29
138796: PUSH
138797: LD_INT 1
138799: ST_TO_ADDR
// break ;
138800: GO 138804
// end ;
138802: GO 138741
138804: POP
138805: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
138806: LD_VAR 0 4
138810: PUSH
138811: LD_VAR 0 7
138815: ARRAY
138816: PPUSH
138817: CALL_OW 302
138821: PUSH
138822: LD_VAR 0 29
138826: NOT
138827: AND
138828: IFFALSE 139150
// begin if GetTag ( group [ i ] ) = 71 then
138830: LD_VAR 0 4
138834: PUSH
138835: LD_VAR 0 7
138839: ARRAY
138840: PPUSH
138841: CALL_OW 110
138845: PUSH
138846: LD_INT 71
138848: EQUAL
138849: IFFALSE 138890
// begin if HasTask ( group [ i ] ) then
138851: LD_VAR 0 4
138855: PUSH
138856: LD_VAR 0 7
138860: ARRAY
138861: PPUSH
138862: CALL_OW 314
138866: IFFALSE 138872
// continue else
138868: GO 135029
138870: GO 138890
// SetTag ( group [ i ] , 0 ) ;
138872: LD_VAR 0 4
138876: PUSH
138877: LD_VAR 0 7
138881: ARRAY
138882: PPUSH
138883: LD_INT 0
138885: PPUSH
138886: CALL_OW 109
// end ; k := 8 ;
138890: LD_ADDR_VAR 0 9
138894: PUSH
138895: LD_INT 8
138897: ST_TO_ADDR
// x := 0 ;
138898: LD_ADDR_VAR 0 10
138902: PUSH
138903: LD_INT 0
138905: ST_TO_ADDR
// if tmp < k then
138906: LD_VAR 0 14
138910: PUSH
138911: LD_VAR 0 9
138915: LESS
138916: IFFALSE 138928
// k := tmp ;
138918: LD_ADDR_VAR 0 9
138922: PUSH
138923: LD_VAR 0 14
138927: ST_TO_ADDR
// for j = 1 to k do
138928: LD_ADDR_VAR 0 8
138932: PUSH
138933: DOUBLE
138934: LD_INT 1
138936: DEC
138937: ST_TO_ADDR
138938: LD_VAR 0 9
138942: PUSH
138943: FOR_TO
138944: IFFALSE 139042
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
138946: LD_VAR 0 14
138950: PUSH
138951: LD_VAR 0 8
138955: ARRAY
138956: PPUSH
138957: CALL_OW 247
138961: PUSH
138962: LD_INT 1
138964: EQUAL
138965: PUSH
138966: LD_VAR 0 14
138970: PUSH
138971: LD_VAR 0 8
138975: ARRAY
138976: PPUSH
138977: CALL_OW 256
138981: PUSH
138982: LD_INT 250
138984: LESS
138985: PUSH
138986: LD_VAR 0 20
138990: AND
138991: PUSH
138992: LD_VAR 0 20
138996: NOT
138997: PUSH
138998: LD_VAR 0 14
139002: PUSH
139003: LD_VAR 0 8
139007: ARRAY
139008: PPUSH
139009: CALL_OW 256
139013: PUSH
139014: LD_INT 250
139016: GREATEREQUAL
139017: AND
139018: OR
139019: AND
139020: IFFALSE 139040
// begin x := tmp [ j ] ;
139022: LD_ADDR_VAR 0 10
139026: PUSH
139027: LD_VAR 0 14
139031: PUSH
139032: LD_VAR 0 8
139036: ARRAY
139037: ST_TO_ADDR
// break ;
139038: GO 139042
// end ;
139040: GO 138943
139042: POP
139043: POP
// if x then
139044: LD_VAR 0 10
139048: IFFALSE 139072
// ComAttackUnit ( group [ i ] , x ) else
139050: LD_VAR 0 4
139054: PUSH
139055: LD_VAR 0 7
139059: ARRAY
139060: PPUSH
139061: LD_VAR 0 10
139065: PPUSH
139066: CALL_OW 115
139070: GO 139096
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
139072: LD_VAR 0 4
139076: PUSH
139077: LD_VAR 0 7
139081: ARRAY
139082: PPUSH
139083: LD_VAR 0 14
139087: PUSH
139088: LD_INT 1
139090: ARRAY
139091: PPUSH
139092: CALL_OW 115
// if not HasTask ( group [ i ] ) then
139096: LD_VAR 0 4
139100: PUSH
139101: LD_VAR 0 7
139105: ARRAY
139106: PPUSH
139107: CALL_OW 314
139111: NOT
139112: IFFALSE 139150
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
139114: LD_VAR 0 4
139118: PUSH
139119: LD_VAR 0 7
139123: ARRAY
139124: PPUSH
139125: LD_VAR 0 14
139129: PPUSH
139130: LD_VAR 0 4
139134: PUSH
139135: LD_VAR 0 7
139139: ARRAY
139140: PPUSH
139141: CALL_OW 74
139145: PPUSH
139146: CALL_OW 115
// end ; end ; end ;
139150: GO 135029
139152: POP
139153: POP
// wait ( 0 0$2 ) ;
139154: LD_INT 70
139156: PPUSH
139157: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
139161: LD_VAR 0 4
139165: NOT
139166: PUSH
139167: LD_VAR 0 4
139171: PUSH
139172: EMPTY
139173: EQUAL
139174: OR
139175: PUSH
139176: LD_INT 81
139178: PUSH
139179: LD_VAR 0 35
139183: PUSH
139184: EMPTY
139185: LIST
139186: LIST
139187: PPUSH
139188: CALL_OW 69
139192: NOT
139193: OR
139194: IFFALSE 135014
// end ;
139196: LD_VAR 0 2
139200: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
139201: LD_INT 0
139203: PPUSH
139204: PPUSH
139205: PPUSH
139206: PPUSH
139207: PPUSH
139208: PPUSH
// if not base or not mc_bases [ base ] or not solds then
139209: LD_VAR 0 1
139213: NOT
139214: PUSH
139215: LD_EXP 102
139219: PUSH
139220: LD_VAR 0 1
139224: ARRAY
139225: NOT
139226: OR
139227: PUSH
139228: LD_VAR 0 2
139232: NOT
139233: OR
139234: IFFALSE 139238
// exit ;
139236: GO 139792
// side := mc_sides [ base ] ;
139238: LD_ADDR_VAR 0 6
139242: PUSH
139243: LD_EXP 128
139247: PUSH
139248: LD_VAR 0 1
139252: ARRAY
139253: ST_TO_ADDR
// if not side then
139254: LD_VAR 0 6
139258: NOT
139259: IFFALSE 139263
// exit ;
139261: GO 139792
// for i in solds do
139263: LD_ADDR_VAR 0 7
139267: PUSH
139268: LD_VAR 0 2
139272: PUSH
139273: FOR_IN
139274: IFFALSE 139335
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
139276: LD_VAR 0 7
139280: PPUSH
139281: CALL_OW 310
139285: PPUSH
139286: CALL_OW 266
139290: PUSH
139291: LD_INT 32
139293: PUSH
139294: LD_INT 31
139296: PUSH
139297: EMPTY
139298: LIST
139299: LIST
139300: IN
139301: IFFALSE 139321
// solds := solds diff i else
139303: LD_ADDR_VAR 0 2
139307: PUSH
139308: LD_VAR 0 2
139312: PUSH
139313: LD_VAR 0 7
139317: DIFF
139318: ST_TO_ADDR
139319: GO 139333
// SetTag ( i , 18 ) ;
139321: LD_VAR 0 7
139325: PPUSH
139326: LD_INT 18
139328: PPUSH
139329: CALL_OW 109
139333: GO 139273
139335: POP
139336: POP
// if not solds then
139337: LD_VAR 0 2
139341: NOT
139342: IFFALSE 139346
// exit ;
139344: GO 139792
// repeat wait ( 0 0$2 ) ;
139346: LD_INT 70
139348: PPUSH
139349: CALL_OW 67
// enemy := mc_scan [ base ] ;
139353: LD_ADDR_VAR 0 4
139357: PUSH
139358: LD_EXP 125
139362: PUSH
139363: LD_VAR 0 1
139367: ARRAY
139368: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
139369: LD_EXP 102
139373: PUSH
139374: LD_VAR 0 1
139378: ARRAY
139379: NOT
139380: PUSH
139381: LD_EXP 102
139385: PUSH
139386: LD_VAR 0 1
139390: ARRAY
139391: PUSH
139392: EMPTY
139393: EQUAL
139394: OR
139395: IFFALSE 139432
// begin for i in solds do
139397: LD_ADDR_VAR 0 7
139401: PUSH
139402: LD_VAR 0 2
139406: PUSH
139407: FOR_IN
139408: IFFALSE 139421
// ComStop ( i ) ;
139410: LD_VAR 0 7
139414: PPUSH
139415: CALL_OW 141
139419: GO 139407
139421: POP
139422: POP
// solds := [ ] ;
139423: LD_ADDR_VAR 0 2
139427: PUSH
139428: EMPTY
139429: ST_TO_ADDR
// exit ;
139430: GO 139792
// end ; for i in solds do
139432: LD_ADDR_VAR 0 7
139436: PUSH
139437: LD_VAR 0 2
139441: PUSH
139442: FOR_IN
139443: IFFALSE 139764
// begin if IsInUnit ( i ) then
139445: LD_VAR 0 7
139449: PPUSH
139450: CALL_OW 310
139454: IFFALSE 139465
// ComExitBuilding ( i ) ;
139456: LD_VAR 0 7
139460: PPUSH
139461: CALL_OW 122
// if GetLives ( i ) > 500 then
139465: LD_VAR 0 7
139469: PPUSH
139470: CALL_OW 256
139474: PUSH
139475: LD_INT 500
139477: GREATER
139478: IFFALSE 139531
// begin e := NearestUnitToUnit ( enemy , i ) ;
139480: LD_ADDR_VAR 0 5
139484: PUSH
139485: LD_VAR 0 4
139489: PPUSH
139490: LD_VAR 0 7
139494: PPUSH
139495: CALL_OW 74
139499: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
139500: LD_VAR 0 7
139504: PPUSH
139505: LD_VAR 0 5
139509: PPUSH
139510: CALL_OW 250
139514: PPUSH
139515: LD_VAR 0 5
139519: PPUSH
139520: CALL_OW 251
139524: PPUSH
139525: CALL_OW 114
// end else
139529: GO 139762
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
139531: LD_VAR 0 7
139535: PPUSH
139536: LD_EXP 102
139540: PUSH
139541: LD_VAR 0 1
139545: ARRAY
139546: PPUSH
139547: LD_INT 2
139549: PUSH
139550: LD_INT 30
139552: PUSH
139553: LD_INT 0
139555: PUSH
139556: EMPTY
139557: LIST
139558: LIST
139559: PUSH
139560: LD_INT 30
139562: PUSH
139563: LD_INT 1
139565: PUSH
139566: EMPTY
139567: LIST
139568: LIST
139569: PUSH
139570: LD_INT 30
139572: PUSH
139573: LD_INT 6
139575: PUSH
139576: EMPTY
139577: LIST
139578: LIST
139579: PUSH
139580: EMPTY
139581: LIST
139582: LIST
139583: LIST
139584: LIST
139585: PPUSH
139586: CALL_OW 72
139590: PPUSH
139591: LD_VAR 0 7
139595: PPUSH
139596: CALL_OW 74
139600: PPUSH
139601: CALL_OW 296
139605: PUSH
139606: LD_INT 10
139608: GREATER
139609: IFFALSE 139762
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
139611: LD_ADDR_VAR 0 8
139615: PUSH
139616: LD_EXP 102
139620: PUSH
139621: LD_VAR 0 1
139625: ARRAY
139626: PPUSH
139627: LD_INT 2
139629: PUSH
139630: LD_INT 30
139632: PUSH
139633: LD_INT 0
139635: PUSH
139636: EMPTY
139637: LIST
139638: LIST
139639: PUSH
139640: LD_INT 30
139642: PUSH
139643: LD_INT 1
139645: PUSH
139646: EMPTY
139647: LIST
139648: LIST
139649: PUSH
139650: LD_INT 30
139652: PUSH
139653: LD_INT 6
139655: PUSH
139656: EMPTY
139657: LIST
139658: LIST
139659: PUSH
139660: EMPTY
139661: LIST
139662: LIST
139663: LIST
139664: LIST
139665: PPUSH
139666: CALL_OW 72
139670: PPUSH
139671: LD_VAR 0 7
139675: PPUSH
139676: CALL_OW 74
139680: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
139681: LD_VAR 0 7
139685: PPUSH
139686: LD_VAR 0 8
139690: PPUSH
139691: CALL_OW 250
139695: PPUSH
139696: LD_INT 3
139698: PPUSH
139699: LD_INT 5
139701: PPUSH
139702: CALL_OW 272
139706: PPUSH
139707: LD_VAR 0 8
139711: PPUSH
139712: CALL_OW 251
139716: PPUSH
139717: LD_INT 3
139719: PPUSH
139720: LD_INT 5
139722: PPUSH
139723: CALL_OW 273
139727: PPUSH
139728: CALL_OW 111
// SetTag ( i , 0 ) ;
139732: LD_VAR 0 7
139736: PPUSH
139737: LD_INT 0
139739: PPUSH
139740: CALL_OW 109
// solds := solds diff i ;
139744: LD_ADDR_VAR 0 2
139748: PUSH
139749: LD_VAR 0 2
139753: PUSH
139754: LD_VAR 0 7
139758: DIFF
139759: ST_TO_ADDR
// continue ;
139760: GO 139442
// end ; end ;
139762: GO 139442
139764: POP
139765: POP
// until not solds or not enemy ;
139766: LD_VAR 0 2
139770: NOT
139771: PUSH
139772: LD_VAR 0 4
139776: NOT
139777: OR
139778: IFFALSE 139346
// MC_Reset ( base , 18 ) ;
139780: LD_VAR 0 1
139784: PPUSH
139785: LD_INT 18
139787: PPUSH
139788: CALL 43757 0 2
// end ;
139792: LD_VAR 0 3
139796: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
139797: LD_INT 0
139799: PPUSH
139800: PPUSH
139801: PPUSH
139802: PPUSH
139803: PPUSH
139804: PPUSH
139805: PPUSH
139806: PPUSH
139807: PPUSH
139808: PPUSH
139809: PPUSH
139810: PPUSH
139811: PPUSH
139812: PPUSH
139813: PPUSH
139814: PPUSH
139815: PPUSH
139816: PPUSH
139817: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
139818: LD_ADDR_VAR 0 12
139822: PUSH
139823: LD_EXP 102
139827: PUSH
139828: LD_VAR 0 1
139832: ARRAY
139833: PPUSH
139834: LD_INT 25
139836: PUSH
139837: LD_INT 3
139839: PUSH
139840: EMPTY
139841: LIST
139842: LIST
139843: PPUSH
139844: CALL_OW 72
139848: ST_TO_ADDR
// if mc_remote_driver [ base ] then
139849: LD_EXP 142
139853: PUSH
139854: LD_VAR 0 1
139858: ARRAY
139859: IFFALSE 139883
// mechs := mechs diff mc_remote_driver [ base ] ;
139861: LD_ADDR_VAR 0 12
139865: PUSH
139866: LD_VAR 0 12
139870: PUSH
139871: LD_EXP 142
139875: PUSH
139876: LD_VAR 0 1
139880: ARRAY
139881: DIFF
139882: ST_TO_ADDR
// for i in mechs do
139883: LD_ADDR_VAR 0 4
139887: PUSH
139888: LD_VAR 0 12
139892: PUSH
139893: FOR_IN
139894: IFFALSE 139929
// if GetTag ( i ) > 0 then
139896: LD_VAR 0 4
139900: PPUSH
139901: CALL_OW 110
139905: PUSH
139906: LD_INT 0
139908: GREATER
139909: IFFALSE 139927
// mechs := mechs diff i ;
139911: LD_ADDR_VAR 0 12
139915: PUSH
139916: LD_VAR 0 12
139920: PUSH
139921: LD_VAR 0 4
139925: DIFF
139926: ST_TO_ADDR
139927: GO 139893
139929: POP
139930: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
139931: LD_ADDR_VAR 0 8
139935: PUSH
139936: LD_EXP 102
139940: PUSH
139941: LD_VAR 0 1
139945: ARRAY
139946: PPUSH
139947: LD_INT 2
139949: PUSH
139950: LD_INT 25
139952: PUSH
139953: LD_INT 1
139955: PUSH
139956: EMPTY
139957: LIST
139958: LIST
139959: PUSH
139960: LD_INT 25
139962: PUSH
139963: LD_INT 5
139965: PUSH
139966: EMPTY
139967: LIST
139968: LIST
139969: PUSH
139970: LD_INT 25
139972: PUSH
139973: LD_INT 8
139975: PUSH
139976: EMPTY
139977: LIST
139978: LIST
139979: PUSH
139980: LD_INT 25
139982: PUSH
139983: LD_INT 9
139985: PUSH
139986: EMPTY
139987: LIST
139988: LIST
139989: PUSH
139990: EMPTY
139991: LIST
139992: LIST
139993: LIST
139994: LIST
139995: LIST
139996: PPUSH
139997: CALL_OW 72
140001: ST_TO_ADDR
// if not defenders and not solds then
140002: LD_VAR 0 2
140006: NOT
140007: PUSH
140008: LD_VAR 0 8
140012: NOT
140013: AND
140014: IFFALSE 140018
// exit ;
140016: GO 141788
// depot_under_attack := false ;
140018: LD_ADDR_VAR 0 16
140022: PUSH
140023: LD_INT 0
140025: ST_TO_ADDR
// sold_defenders := [ ] ;
140026: LD_ADDR_VAR 0 17
140030: PUSH
140031: EMPTY
140032: ST_TO_ADDR
// if mechs then
140033: LD_VAR 0 12
140037: IFFALSE 140190
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
140039: LD_ADDR_VAR 0 4
140043: PUSH
140044: LD_VAR 0 2
140048: PPUSH
140049: LD_INT 21
140051: PUSH
140052: LD_INT 2
140054: PUSH
140055: EMPTY
140056: LIST
140057: LIST
140058: PPUSH
140059: CALL_OW 72
140063: PUSH
140064: FOR_IN
140065: IFFALSE 140188
// begin if GetTag ( i ) <> 20 then
140067: LD_VAR 0 4
140071: PPUSH
140072: CALL_OW 110
140076: PUSH
140077: LD_INT 20
140079: NONEQUAL
140080: IFFALSE 140094
// SetTag ( i , 20 ) ;
140082: LD_VAR 0 4
140086: PPUSH
140087: LD_INT 20
140089: PPUSH
140090: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
140094: LD_VAR 0 4
140098: PPUSH
140099: CALL_OW 263
140103: PUSH
140104: LD_INT 1
140106: EQUAL
140107: PUSH
140108: LD_VAR 0 4
140112: PPUSH
140113: CALL_OW 311
140117: NOT
140118: AND
140119: IFFALSE 140186
// begin un := mechs [ 1 ] ;
140121: LD_ADDR_VAR 0 10
140125: PUSH
140126: LD_VAR 0 12
140130: PUSH
140131: LD_INT 1
140133: ARRAY
140134: ST_TO_ADDR
// ComExit ( un ) ;
140135: LD_VAR 0 10
140139: PPUSH
140140: CALL 108489 0 1
// AddComEnterUnit ( un , i ) ;
140144: LD_VAR 0 10
140148: PPUSH
140149: LD_VAR 0 4
140153: PPUSH
140154: CALL_OW 180
// SetTag ( un , 19 ) ;
140158: LD_VAR 0 10
140162: PPUSH
140163: LD_INT 19
140165: PPUSH
140166: CALL_OW 109
// mechs := mechs diff un ;
140170: LD_ADDR_VAR 0 12
140174: PUSH
140175: LD_VAR 0 12
140179: PUSH
140180: LD_VAR 0 10
140184: DIFF
140185: ST_TO_ADDR
// end ; end ;
140186: GO 140064
140188: POP
140189: POP
// if solds then
140190: LD_VAR 0 8
140194: IFFALSE 140253
// for i in solds do
140196: LD_ADDR_VAR 0 4
140200: PUSH
140201: LD_VAR 0 8
140205: PUSH
140206: FOR_IN
140207: IFFALSE 140251
// if not GetTag ( i ) then
140209: LD_VAR 0 4
140213: PPUSH
140214: CALL_OW 110
140218: NOT
140219: IFFALSE 140249
// begin defenders := defenders union i ;
140221: LD_ADDR_VAR 0 2
140225: PUSH
140226: LD_VAR 0 2
140230: PUSH
140231: LD_VAR 0 4
140235: UNION
140236: ST_TO_ADDR
// SetTag ( i , 18 ) ;
140237: LD_VAR 0 4
140241: PPUSH
140242: LD_INT 18
140244: PPUSH
140245: CALL_OW 109
// end ;
140249: GO 140206
140251: POP
140252: POP
// repeat wait ( 0 0$2 ) ;
140253: LD_INT 70
140255: PPUSH
140256: CALL_OW 67
// enemy := mc_scan [ base ] ;
140260: LD_ADDR_VAR 0 21
140264: PUSH
140265: LD_EXP 125
140269: PUSH
140270: LD_VAR 0 1
140274: ARRAY
140275: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
140276: LD_EXP 102
140280: PUSH
140281: LD_VAR 0 1
140285: ARRAY
140286: NOT
140287: PUSH
140288: LD_EXP 102
140292: PUSH
140293: LD_VAR 0 1
140297: ARRAY
140298: PUSH
140299: EMPTY
140300: EQUAL
140301: OR
140302: IFFALSE 140339
// begin for i in defenders do
140304: LD_ADDR_VAR 0 4
140308: PUSH
140309: LD_VAR 0 2
140313: PUSH
140314: FOR_IN
140315: IFFALSE 140328
// ComStop ( i ) ;
140317: LD_VAR 0 4
140321: PPUSH
140322: CALL_OW 141
140326: GO 140314
140328: POP
140329: POP
// defenders := [ ] ;
140330: LD_ADDR_VAR 0 2
140334: PUSH
140335: EMPTY
140336: ST_TO_ADDR
// exit ;
140337: GO 141788
// end ; for i in defenders do
140339: LD_ADDR_VAR 0 4
140343: PUSH
140344: LD_VAR 0 2
140348: PUSH
140349: FOR_IN
140350: IFFALSE 141248
// begin e := NearestUnitToUnit ( enemy , i ) ;
140352: LD_ADDR_VAR 0 13
140356: PUSH
140357: LD_VAR 0 21
140361: PPUSH
140362: LD_VAR 0 4
140366: PPUSH
140367: CALL_OW 74
140371: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
140372: LD_ADDR_VAR 0 7
140376: PUSH
140377: LD_EXP 102
140381: PUSH
140382: LD_VAR 0 1
140386: ARRAY
140387: PPUSH
140388: LD_INT 2
140390: PUSH
140391: LD_INT 30
140393: PUSH
140394: LD_INT 0
140396: PUSH
140397: EMPTY
140398: LIST
140399: LIST
140400: PUSH
140401: LD_INT 30
140403: PUSH
140404: LD_INT 1
140406: PUSH
140407: EMPTY
140408: LIST
140409: LIST
140410: PUSH
140411: EMPTY
140412: LIST
140413: LIST
140414: LIST
140415: PPUSH
140416: CALL_OW 72
140420: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
140421: LD_ADDR_VAR 0 16
140425: PUSH
140426: LD_VAR 0 7
140430: NOT
140431: PUSH
140432: LD_VAR 0 7
140436: PPUSH
140437: LD_INT 3
140439: PUSH
140440: LD_INT 24
140442: PUSH
140443: LD_INT 600
140445: PUSH
140446: EMPTY
140447: LIST
140448: LIST
140449: PUSH
140450: EMPTY
140451: LIST
140452: LIST
140453: PPUSH
140454: CALL_OW 72
140458: OR
140459: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
140460: LD_VAR 0 4
140464: PPUSH
140465: CALL_OW 247
140469: PUSH
140470: LD_INT 2
140472: DOUBLE
140473: EQUAL
140474: IFTRUE 140478
140476: GO 140874
140478: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
140479: LD_VAR 0 4
140483: PPUSH
140484: CALL_OW 256
140488: PUSH
140489: LD_INT 1000
140491: EQUAL
140492: PUSH
140493: LD_VAR 0 4
140497: PPUSH
140498: LD_VAR 0 13
140502: PPUSH
140503: CALL_OW 296
140507: PUSH
140508: LD_INT 40
140510: LESS
140511: PUSH
140512: LD_VAR 0 13
140516: PPUSH
140517: LD_EXP 127
140521: PUSH
140522: LD_VAR 0 1
140526: ARRAY
140527: PPUSH
140528: CALL_OW 308
140532: OR
140533: AND
140534: IFFALSE 140656
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
140536: LD_VAR 0 4
140540: PPUSH
140541: CALL_OW 262
140545: PUSH
140546: LD_INT 1
140548: EQUAL
140549: PUSH
140550: LD_VAR 0 4
140554: PPUSH
140555: CALL_OW 261
140559: PUSH
140560: LD_INT 30
140562: LESS
140563: AND
140564: PUSH
140565: LD_VAR 0 7
140569: AND
140570: IFFALSE 140640
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
140572: LD_VAR 0 4
140576: PPUSH
140577: LD_VAR 0 7
140581: PPUSH
140582: LD_VAR 0 4
140586: PPUSH
140587: CALL_OW 74
140591: PPUSH
140592: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
140596: LD_VAR 0 4
140600: PPUSH
140601: LD_VAR 0 7
140605: PPUSH
140606: LD_VAR 0 4
140610: PPUSH
140611: CALL_OW 74
140615: PPUSH
140616: CALL_OW 296
140620: PUSH
140621: LD_INT 6
140623: LESS
140624: IFFALSE 140638
// SetFuel ( i , 100 ) ;
140626: LD_VAR 0 4
140630: PPUSH
140631: LD_INT 100
140633: PPUSH
140634: CALL_OW 240
// end else
140638: GO 140654
// ComAttackUnit ( i , e ) ;
140640: LD_VAR 0 4
140644: PPUSH
140645: LD_VAR 0 13
140649: PPUSH
140650: CALL_OW 115
// end else
140654: GO 140757
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
140656: LD_VAR 0 13
140660: PPUSH
140661: LD_EXP 127
140665: PUSH
140666: LD_VAR 0 1
140670: ARRAY
140671: PPUSH
140672: CALL_OW 308
140676: NOT
140677: PUSH
140678: LD_VAR 0 4
140682: PPUSH
140683: LD_VAR 0 13
140687: PPUSH
140688: CALL_OW 296
140692: PUSH
140693: LD_INT 40
140695: GREATEREQUAL
140696: AND
140697: PUSH
140698: LD_VAR 0 4
140702: PPUSH
140703: CALL_OW 256
140707: PUSH
140708: LD_INT 650
140710: LESSEQUAL
140711: OR
140712: PUSH
140713: LD_VAR 0 4
140717: PPUSH
140718: LD_EXP 126
140722: PUSH
140723: LD_VAR 0 1
140727: ARRAY
140728: PPUSH
140729: CALL_OW 308
140733: NOT
140734: AND
140735: IFFALSE 140757
// ComMoveToArea ( i , mc_parking [ base ] ) ;
140737: LD_VAR 0 4
140741: PPUSH
140742: LD_EXP 126
140746: PUSH
140747: LD_VAR 0 1
140751: ARRAY
140752: PPUSH
140753: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
140757: LD_VAR 0 4
140761: PPUSH
140762: CALL_OW 256
140766: PUSH
140767: LD_INT 1000
140769: LESS
140770: PUSH
140771: LD_VAR 0 4
140775: PPUSH
140776: CALL_OW 263
140780: PUSH
140781: LD_INT 1
140783: EQUAL
140784: AND
140785: PUSH
140786: LD_VAR 0 4
140790: PPUSH
140791: CALL_OW 311
140795: AND
140796: PUSH
140797: LD_VAR 0 4
140801: PPUSH
140802: LD_EXP 126
140806: PUSH
140807: LD_VAR 0 1
140811: ARRAY
140812: PPUSH
140813: CALL_OW 308
140817: AND
140818: IFFALSE 140872
// begin mech := IsDrivenBy ( i ) ;
140820: LD_ADDR_VAR 0 9
140824: PUSH
140825: LD_VAR 0 4
140829: PPUSH
140830: CALL_OW 311
140834: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
140835: LD_VAR 0 9
140839: PPUSH
140840: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
140844: LD_VAR 0 9
140848: PPUSH
140849: LD_VAR 0 4
140853: PPUSH
140854: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
140858: LD_VAR 0 9
140862: PPUSH
140863: LD_VAR 0 4
140867: PPUSH
140868: CALL_OW 180
// end ; end ; unit_human :
140872: GO 141219
140874: LD_INT 1
140876: DOUBLE
140877: EQUAL
140878: IFTRUE 140882
140880: GO 141218
140882: POP
// begin b := IsInUnit ( i ) ;
140883: LD_ADDR_VAR 0 18
140887: PUSH
140888: LD_VAR 0 4
140892: PPUSH
140893: CALL_OW 310
140897: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
140898: LD_ADDR_VAR 0 19
140902: PUSH
140903: LD_VAR 0 18
140907: NOT
140908: PUSH
140909: LD_VAR 0 18
140913: PPUSH
140914: CALL_OW 266
140918: PUSH
140919: LD_INT 32
140921: PUSH
140922: LD_INT 31
140924: PUSH
140925: EMPTY
140926: LIST
140927: LIST
140928: IN
140929: OR
140930: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
140931: LD_VAR 0 18
140935: PPUSH
140936: CALL_OW 266
140940: PUSH
140941: LD_INT 5
140943: EQUAL
140944: PUSH
140945: LD_VAR 0 4
140949: PPUSH
140950: CALL_OW 257
140954: PUSH
140955: LD_INT 1
140957: PUSH
140958: LD_INT 2
140960: PUSH
140961: LD_INT 3
140963: PUSH
140964: LD_INT 4
140966: PUSH
140967: EMPTY
140968: LIST
140969: LIST
140970: LIST
140971: LIST
140972: IN
140973: AND
140974: IFFALSE 141011
// begin class := AllowSpecClass ( i ) ;
140976: LD_ADDR_VAR 0 20
140980: PUSH
140981: LD_VAR 0 4
140985: PPUSH
140986: CALL 72166 0 1
140990: ST_TO_ADDR
// if class then
140991: LD_VAR 0 20
140995: IFFALSE 141011
// ComChangeProfession ( i , class ) ;
140997: LD_VAR 0 4
141001: PPUSH
141002: LD_VAR 0 20
141006: PPUSH
141007: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
141011: LD_VAR 0 16
141015: PUSH
141016: LD_VAR 0 2
141020: PPUSH
141021: LD_INT 21
141023: PUSH
141024: LD_INT 2
141026: PUSH
141027: EMPTY
141028: LIST
141029: LIST
141030: PPUSH
141031: CALL_OW 72
141035: PUSH
141036: LD_INT 1
141038: LESSEQUAL
141039: OR
141040: PUSH
141041: LD_VAR 0 19
141045: AND
141046: PUSH
141047: LD_VAR 0 4
141051: PUSH
141052: LD_VAR 0 17
141056: IN
141057: NOT
141058: AND
141059: IFFALSE 141152
// begin if b then
141061: LD_VAR 0 18
141065: IFFALSE 141114
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
141067: LD_VAR 0 18
141071: PPUSH
141072: LD_VAR 0 21
141076: PPUSH
141077: LD_VAR 0 18
141081: PPUSH
141082: CALL_OW 74
141086: PPUSH
141087: CALL_OW 296
141091: PUSH
141092: LD_INT 10
141094: LESS
141095: PUSH
141096: LD_VAR 0 18
141100: PPUSH
141101: CALL_OW 461
141105: PUSH
141106: LD_INT 7
141108: NONEQUAL
141109: AND
141110: IFFALSE 141114
// continue ;
141112: GO 140349
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
141114: LD_ADDR_VAR 0 17
141118: PUSH
141119: LD_VAR 0 17
141123: PPUSH
141124: LD_VAR 0 17
141128: PUSH
141129: LD_INT 1
141131: PLUS
141132: PPUSH
141133: LD_VAR 0 4
141137: PPUSH
141138: CALL_OW 1
141142: ST_TO_ADDR
// ComExitBuilding ( i ) ;
141143: LD_VAR 0 4
141147: PPUSH
141148: CALL_OW 122
// end ; if sold_defenders then
141152: LD_VAR 0 17
141156: IFFALSE 141216
// if i in sold_defenders then
141158: LD_VAR 0 4
141162: PUSH
141163: LD_VAR 0 17
141167: IN
141168: IFFALSE 141216
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
141170: LD_VAR 0 4
141174: PPUSH
141175: CALL_OW 314
141179: NOT
141180: PUSH
141181: LD_VAR 0 4
141185: PPUSH
141186: LD_VAR 0 13
141190: PPUSH
141191: CALL_OW 296
141195: PUSH
141196: LD_INT 30
141198: LESS
141199: AND
141200: IFFALSE 141216
// ComAttackUnit ( i , e ) ;
141202: LD_VAR 0 4
141206: PPUSH
141207: LD_VAR 0 13
141211: PPUSH
141212: CALL_OW 115
// end ; end ; end ;
141216: GO 141219
141218: POP
// if IsDead ( i ) then
141219: LD_VAR 0 4
141223: PPUSH
141224: CALL_OW 301
141228: IFFALSE 141246
// defenders := defenders diff i ;
141230: LD_ADDR_VAR 0 2
141234: PUSH
141235: LD_VAR 0 2
141239: PUSH
141240: LD_VAR 0 4
141244: DIFF
141245: ST_TO_ADDR
// end ;
141246: GO 140349
141248: POP
141249: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
141250: LD_VAR 0 21
141254: NOT
141255: PUSH
141256: LD_VAR 0 2
141260: NOT
141261: OR
141262: PUSH
141263: LD_EXP 102
141267: PUSH
141268: LD_VAR 0 1
141272: ARRAY
141273: NOT
141274: OR
141275: IFFALSE 140253
// MC_Reset ( base , 18 ) ;
141277: LD_VAR 0 1
141281: PPUSH
141282: LD_INT 18
141284: PPUSH
141285: CALL 43757 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
141289: LD_ADDR_VAR 0 2
141293: PUSH
141294: LD_VAR 0 2
141298: PUSH
141299: LD_VAR 0 2
141303: PPUSH
141304: LD_INT 2
141306: PUSH
141307: LD_INT 25
141309: PUSH
141310: LD_INT 1
141312: PUSH
141313: EMPTY
141314: LIST
141315: LIST
141316: PUSH
141317: LD_INT 25
141319: PUSH
141320: LD_INT 5
141322: PUSH
141323: EMPTY
141324: LIST
141325: LIST
141326: PUSH
141327: LD_INT 25
141329: PUSH
141330: LD_INT 8
141332: PUSH
141333: EMPTY
141334: LIST
141335: LIST
141336: PUSH
141337: LD_INT 25
141339: PUSH
141340: LD_INT 9
141342: PUSH
141343: EMPTY
141344: LIST
141345: LIST
141346: PUSH
141347: EMPTY
141348: LIST
141349: LIST
141350: LIST
141351: LIST
141352: LIST
141353: PPUSH
141354: CALL_OW 72
141358: DIFF
141359: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
141360: LD_VAR 0 21
141364: NOT
141365: PUSH
141366: LD_VAR 0 2
141370: PPUSH
141371: LD_INT 21
141373: PUSH
141374: LD_INT 2
141376: PUSH
141377: EMPTY
141378: LIST
141379: LIST
141380: PPUSH
141381: CALL_OW 72
141385: AND
141386: IFFALSE 141724
// begin tmp := FilterByTag ( defenders , 19 ) ;
141388: LD_ADDR_VAR 0 11
141392: PUSH
141393: LD_VAR 0 2
141397: PPUSH
141398: LD_INT 19
141400: PPUSH
141401: CALL 105660 0 2
141405: ST_TO_ADDR
// if tmp then
141406: LD_VAR 0 11
141410: IFFALSE 141480
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
141412: LD_ADDR_VAR 0 11
141416: PUSH
141417: LD_VAR 0 11
141421: PPUSH
141422: LD_INT 25
141424: PUSH
141425: LD_INT 3
141427: PUSH
141428: EMPTY
141429: LIST
141430: LIST
141431: PPUSH
141432: CALL_OW 72
141436: ST_TO_ADDR
// if tmp then
141437: LD_VAR 0 11
141441: IFFALSE 141480
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
141443: LD_ADDR_EXP 114
141447: PUSH
141448: LD_EXP 114
141452: PPUSH
141453: LD_VAR 0 1
141457: PPUSH
141458: LD_EXP 114
141462: PUSH
141463: LD_VAR 0 1
141467: ARRAY
141468: PUSH
141469: LD_VAR 0 11
141473: UNION
141474: PPUSH
141475: CALL_OW 1
141479: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
141480: LD_VAR 0 1
141484: PPUSH
141485: LD_INT 19
141487: PPUSH
141488: CALL 43757 0 2
// repeat wait ( 0 0$1 ) ;
141492: LD_INT 35
141494: PPUSH
141495: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
141499: LD_EXP 102
141503: PUSH
141504: LD_VAR 0 1
141508: ARRAY
141509: NOT
141510: PUSH
141511: LD_EXP 102
141515: PUSH
141516: LD_VAR 0 1
141520: ARRAY
141521: PUSH
141522: EMPTY
141523: EQUAL
141524: OR
141525: IFFALSE 141562
// begin for i in defenders do
141527: LD_ADDR_VAR 0 4
141531: PUSH
141532: LD_VAR 0 2
141536: PUSH
141537: FOR_IN
141538: IFFALSE 141551
// ComStop ( i ) ;
141540: LD_VAR 0 4
141544: PPUSH
141545: CALL_OW 141
141549: GO 141537
141551: POP
141552: POP
// defenders := [ ] ;
141553: LD_ADDR_VAR 0 2
141557: PUSH
141558: EMPTY
141559: ST_TO_ADDR
// exit ;
141560: GO 141788
// end ; for i in defenders do
141562: LD_ADDR_VAR 0 4
141566: PUSH
141567: LD_VAR 0 2
141571: PUSH
141572: FOR_IN
141573: IFFALSE 141662
// begin if not IsInArea ( i , mc_parking [ base ] ) then
141575: LD_VAR 0 4
141579: PPUSH
141580: LD_EXP 126
141584: PUSH
141585: LD_VAR 0 1
141589: ARRAY
141590: PPUSH
141591: CALL_OW 308
141595: NOT
141596: IFFALSE 141620
// ComMoveToArea ( i , mc_parking [ base ] ) else
141598: LD_VAR 0 4
141602: PPUSH
141603: LD_EXP 126
141607: PUSH
141608: LD_VAR 0 1
141612: ARRAY
141613: PPUSH
141614: CALL_OW 113
141618: GO 141660
// if GetControl ( i ) = control_manual then
141620: LD_VAR 0 4
141624: PPUSH
141625: CALL_OW 263
141629: PUSH
141630: LD_INT 1
141632: EQUAL
141633: IFFALSE 141660
// if IsDrivenBy ( i ) then
141635: LD_VAR 0 4
141639: PPUSH
141640: CALL_OW 311
141644: IFFALSE 141660
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
141646: LD_VAR 0 4
141650: PPUSH
141651: CALL_OW 311
141655: PPUSH
141656: CALL_OW 121
// end ;
141660: GO 141572
141662: POP
141663: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
141664: LD_VAR 0 2
141668: PPUSH
141669: LD_INT 95
141671: PUSH
141672: LD_EXP 126
141676: PUSH
141677: LD_VAR 0 1
141681: ARRAY
141682: PUSH
141683: EMPTY
141684: LIST
141685: LIST
141686: PPUSH
141687: CALL_OW 72
141691: PUSH
141692: LD_VAR 0 2
141696: EQUAL
141697: PUSH
141698: LD_EXP 125
141702: PUSH
141703: LD_VAR 0 1
141707: ARRAY
141708: OR
141709: PUSH
141710: LD_EXP 102
141714: PUSH
141715: LD_VAR 0 1
141719: ARRAY
141720: NOT
141721: OR
141722: IFFALSE 141492
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
141724: LD_ADDR_EXP 124
141728: PUSH
141729: LD_EXP 124
141733: PPUSH
141734: LD_VAR 0 1
141738: PPUSH
141739: LD_VAR 0 2
141743: PPUSH
141744: LD_INT 21
141746: PUSH
141747: LD_INT 2
141749: PUSH
141750: EMPTY
141751: LIST
141752: LIST
141753: PPUSH
141754: CALL_OW 72
141758: PPUSH
141759: CALL_OW 1
141763: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
141764: LD_VAR 0 1
141768: PPUSH
141769: LD_INT 19
141771: PPUSH
141772: CALL 43757 0 2
// MC_Reset ( base , 20 ) ;
141776: LD_VAR 0 1
141780: PPUSH
141781: LD_INT 20
141783: PPUSH
141784: CALL 43757 0 2
// end ; end_of_file
141788: LD_VAR 0 3
141792: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
141793: LD_VAR 0 1
141797: PUSH
141798: LD_INT 200
141800: DOUBLE
141801: GREATEREQUAL
141802: IFFALSE 141810
141804: LD_INT 299
141806: DOUBLE
141807: LESSEQUAL
141808: IFTRUE 141812
141810: GO 141844
141812: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
141813: LD_VAR 0 1
141817: PPUSH
141818: LD_VAR 0 2
141822: PPUSH
141823: LD_VAR 0 3
141827: PPUSH
141828: LD_VAR 0 4
141832: PPUSH
141833: LD_VAR 0 5
141837: PPUSH
141838: CALL 129793 0 5
141842: GO 141921
141844: LD_INT 300
141846: DOUBLE
141847: GREATEREQUAL
141848: IFFALSE 141856
141850: LD_INT 399
141852: DOUBLE
141853: LESSEQUAL
141854: IFTRUE 141858
141856: GO 141920
141858: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
141859: LD_VAR 0 1
141863: PPUSH
141864: LD_VAR 0 2
141868: PPUSH
141869: LD_VAR 0 3
141873: PPUSH
141874: LD_VAR 0 4
141878: PPUSH
141879: LD_VAR 0 5
141883: PPUSH
141884: LD_VAR 0 6
141888: PPUSH
141889: LD_VAR 0 7
141893: PPUSH
141894: LD_VAR 0 8
141898: PPUSH
141899: LD_VAR 0 9
141903: PPUSH
141904: LD_VAR 0 10
141908: PPUSH
141909: LD_VAR 0 11
141913: PPUSH
141914: CALL 125701 0 11
141918: GO 141921
141920: POP
// end ;
141921: PPOPN 11
141923: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
141924: LD_VAR 0 1
141928: PPUSH
141929: LD_VAR 0 2
141933: PPUSH
141934: LD_VAR 0 3
141938: PPUSH
141939: LD_VAR 0 4
141943: PPUSH
141944: LD_VAR 0 5
141948: PPUSH
141949: CALL 129178 0 5
// end ; end_of_file
141953: PPOPN 5
141955: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
141956: LD_VAR 0 1
141960: PPUSH
141961: LD_VAR 0 2
141965: PPUSH
141966: LD_VAR 0 3
141970: PPUSH
141971: LD_VAR 0 4
141975: PPUSH
141976: LD_VAR 0 5
141980: PPUSH
141981: LD_VAR 0 6
141985: PPUSH
141986: CALL 113353 0 6
// end ;
141990: PPOPN 6
141992: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
141993: LD_INT 0
141995: PPUSH
// begin if not units then
141996: LD_VAR 0 1
142000: NOT
142001: IFFALSE 142005
// exit ;
142003: GO 142005
// end ;
142005: PPOPN 7
142007: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
142008: CALL 113240 0 0
// end ;
142012: PPOPN 1
142014: END
