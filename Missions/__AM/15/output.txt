// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 38736 0 0
// InitNature ;
  19: CALL 38604 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 12514 0 0
// PrepareRussian ;
  40: CALL 7396 0 0
// PrepareLegion ;
  44: CALL 4478 0 0
// PreparePowell ;
  48: CALL 3056 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 17377 0 0
// MC_Start ( ) ;
  60: CALL 40916 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 125
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 126
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 63712 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 63805 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 63155 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 3
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 3
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 62970 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 63712 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 63805 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 62970 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 63155 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 63585 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 62633 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 63712 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 63805 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 130
 971: PUSH
 972: LD_EXP 130
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 62970 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 63712 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 63805 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 62862 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 64123 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 63294 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 63585 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 63585 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 63917 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 62970 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 63536 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker , Mike ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 69444 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1900
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 74284 0 5
1898: GO 1959
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1900: LD_EXP 4
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 1
1911: ARRAY
1912: PPUSH
1913: LD_EXP 4
1917: PUSH
1918: LD_INT 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_EXP 4
1930: PUSH
1931: LD_INT 3
1933: ARRAY
1934: PUSH
1935: LD_INT 1
1937: ARRAY
1938: PPUSH
1939: LD_EXP 4
1943: PUSH
1944: LD_INT 4
1946: ARRAY
1947: PUSH
1948: LD_INT 1
1950: ARRAY
1951: PPUSH
1952: LD_INT 30
1954: PPUSH
1955: CALL 74284 0 5
// JMMNewVeh := CreateVehicle ;
1959: LD_ADDR_EXP 58
1963: PUSH
1964: CALL_OW 45
1968: ST_TO_ADDR
// if not JMMNewVeh then
1969: LD_EXP 58
1973: NOT
1974: IFFALSE 2005
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1976: LD_INT 5
1978: PPUSH
1979: LD_INT 3
1981: PPUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 9
1987: PPUSH
1988: LD_INT 100
1990: PPUSH
1991: CALL 74284 0 5
// JMMNewVeh := CreateVehicle ;
1995: LD_ADDR_EXP 58
1999: PUSH
2000: CALL_OW 45
2004: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2005: LD_EXP 58
2009: PPUSH
2010: LD_INT 4
2012: PPUSH
2013: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2017: LD_EXP 58
2021: PPUSH
2022: LD_INT 79
2024: PPUSH
2025: LD_INT 91
2027: PPUSH
2028: LD_INT 0
2030: PPUSH
2031: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2035: LD_EXP 40
2039: PPUSH
2040: LD_EXP 58
2044: PPUSH
2045: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2049: LD_EXP 6
2053: PUSH
2054: LD_EXP 2
2058: NOT
2059: AND
2060: IFFALSE 2318
// begin if not JMMGirlVeh then
2062: LD_EXP 5
2066: NOT
2067: IFFALSE 2090
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2069: LD_INT 3
2071: PPUSH
2072: LD_INT 3
2074: PPUSH
2075: LD_INT 1
2077: PPUSH
2078: LD_INT 9
2080: PPUSH
2081: LD_INT 100
2083: PPUSH
2084: CALL 74284 0 5
2088: GO 2149
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2090: LD_EXP 5
2094: PUSH
2095: LD_INT 1
2097: ARRAY
2098: PUSH
2099: LD_INT 1
2101: ARRAY
2102: PPUSH
2103: LD_EXP 5
2107: PUSH
2108: LD_INT 2
2110: ARRAY
2111: PUSH
2112: LD_INT 1
2114: ARRAY
2115: PPUSH
2116: LD_EXP 5
2120: PUSH
2121: LD_INT 3
2123: ARRAY
2124: PUSH
2125: LD_INT 1
2127: ARRAY
2128: PPUSH
2129: LD_EXP 5
2133: PUSH
2134: LD_INT 4
2136: ARRAY
2137: PUSH
2138: LD_INT 1
2140: ARRAY
2141: PPUSH
2142: LD_INT 30
2144: PPUSH
2145: CALL 74284 0 5
// GirlNewVeh := CreateVehicle ;
2149: LD_ADDR_EXP 59
2153: PUSH
2154: CALL_OW 45
2158: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2159: LD_EXP 59
2163: PPUSH
2164: LD_INT 4
2166: PPUSH
2167: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2171: LD_EXP 59
2175: PPUSH
2176: LD_INT 82
2178: PPUSH
2179: LD_INT 96
2181: PPUSH
2182: LD_INT 0
2184: PPUSH
2185: CALL_OW 48
// if JMMGirl = 1 then
2189: LD_EXP 7
2193: PUSH
2194: LD_INT 1
2196: EQUAL
2197: IFFALSE 2232
// begin Joan := PrepareUnit ( Joan , true , 14_ ) ;
2199: LD_ADDR_EXP 41
2203: PUSH
2204: LD_STRING Joan
2206: PPUSH
2207: LD_INT 1
2209: PPUSH
2210: LD_STRING 14_
2212: PPUSH
2213: CALL 69444 0 3
2217: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2218: LD_EXP 41
2222: PPUSH
2223: LD_EXP 59
2227: PPUSH
2228: CALL_OW 52
// end ; if JMMGirl = 2 then
2232: LD_EXP 7
2236: PUSH
2237: LD_INT 2
2239: EQUAL
2240: IFFALSE 2275
// begin Lisa := PrepareUnit ( Lisa , true , 14_ ) ;
2242: LD_ADDR_EXP 43
2246: PUSH
2247: LD_STRING Lisa
2249: PPUSH
2250: LD_INT 1
2252: PPUSH
2253: LD_STRING 14_
2255: PPUSH
2256: CALL 69444 0 3
2260: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2261: LD_EXP 43
2265: PPUSH
2266: LD_EXP 59
2270: PPUSH
2271: CALL_OW 52
// end ; if JMMGirl = 3 then
2275: LD_EXP 7
2279: PUSH
2280: LD_INT 3
2282: EQUAL
2283: IFFALSE 2318
// begin Connie := PrepareUnit ( Connie , true , 14_ ) ;
2285: LD_ADDR_EXP 55
2289: PUSH
2290: LD_STRING Connie
2292: PPUSH
2293: LD_INT 1
2295: PPUSH
2296: LD_STRING 14_
2298: PPUSH
2299: CALL 69444 0 3
2303: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2304: LD_EXP 55
2308: PPUSH
2309: LD_EXP 59
2313: PPUSH
2314: CALL_OW 52
// end ; end ; end ;
2318: LD_VAR 0 1
2322: RET
// export function PrepareStevensSquad ; var tmp ; begin
2323: LD_INT 0
2325: PPUSH
2326: PPUSH
// uc_side := 1 ;
2327: LD_ADDR_OWVAR 20
2331: PUSH
2332: LD_INT 1
2334: ST_TO_ADDR
// uc_nation := 1 ;
2335: LD_ADDR_OWVAR 21
2339: PUSH
2340: LD_INT 1
2342: ST_TO_ADDR
// tmp := [ ] ;
2343: LD_ADDR_VAR 0 2
2347: PUSH
2348: EMPTY
2349: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2350: LD_ADDR_EXP 42
2354: PUSH
2355: LD_STRING Stevens
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13f_
2366: PPUSH
2367: CALL 69444 0 3
2371: ST_TO_ADDR
// if not Stevens then
2372: LD_EXP 42
2376: NOT
2377: IFFALSE 2445
// begin hc_name = Baker Smith ;
2379: LD_ADDR_OWVAR 26
2383: PUSH
2384: LD_STRING Baker Smith
2386: ST_TO_ADDR
// hc_gallery = us ;
2387: LD_ADDR_OWVAR 33
2391: PUSH
2392: LD_STRING us
2394: ST_TO_ADDR
// hc_face_number := 29 ;
2395: LD_ADDR_OWVAR 34
2399: PUSH
2400: LD_INT 29
2402: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2403: LD_INT 1
2405: PPUSH
2406: LD_INT 10
2408: PPUSH
2409: CALL_OW 384
// Baker = CreateHuman ;
2413: LD_ADDR_EXP 56
2417: PUSH
2418: CALL_OW 44
2422: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2423: LD_ADDR_VAR 0 2
2427: PUSH
2428: LD_VAR 0 2
2432: PUSH
2433: LD_EXP 56
2437: ADD
2438: ST_TO_ADDR
// InitHc ;
2439: CALL_OW 19
// end else
2443: GO 2461
// tmp := tmp ^ Stevens ;
2445: LD_ADDR_VAR 0 2
2449: PUSH
2450: LD_VAR 0 2
2454: PUSH
2455: LD_EXP 42
2459: ADD
2460: ST_TO_ADDR
// if not Lisa then
2461: LD_EXP 43
2465: NOT
2466: IFFALSE 2512
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2468: LD_ADDR_EXP 43
2472: PUSH
2473: LD_STRING Lisa
2475: PPUSH
2476: LD_EXP 1
2480: NOT
2481: PPUSH
2482: LD_STRING 13f_
2484: PPUSH
2485: CALL 69444 0 3
2489: ST_TO_ADDR
// if Lisa then
2490: LD_EXP 43
2494: IFFALSE 2512
// tmp := tmp ^ Lisa ;
2496: LD_ADDR_VAR 0 2
2500: PUSH
2501: LD_VAR 0 2
2505: PUSH
2506: LD_EXP 43
2510: ADD
2511: ST_TO_ADDR
// end ; if not Donaldson then
2512: LD_EXP 44
2516: NOT
2517: IFFALSE 2563
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2519: LD_ADDR_EXP 44
2523: PUSH
2524: LD_STRING Donaldson
2526: PPUSH
2527: LD_EXP 1
2531: NOT
2532: PPUSH
2533: LD_STRING 13f_
2535: PPUSH
2536: CALL 69444 0 3
2540: ST_TO_ADDR
// if Donaldson then
2541: LD_EXP 44
2545: IFFALSE 2563
// tmp := tmp ^ Donaldson ;
2547: LD_ADDR_VAR 0 2
2551: PUSH
2552: LD_VAR 0 2
2556: PUSH
2557: LD_EXP 44
2561: ADD
2562: ST_TO_ADDR
// end ; if not Bobby then
2563: LD_EXP 45
2567: NOT
2568: IFFALSE 2614
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2570: LD_ADDR_EXP 45
2574: PUSH
2575: LD_STRING Bobby
2577: PPUSH
2578: LD_EXP 1
2582: NOT
2583: PPUSH
2584: LD_STRING 13f_
2586: PPUSH
2587: CALL 69444 0 3
2591: ST_TO_ADDR
// if Bobby then
2592: LD_EXP 45
2596: IFFALSE 2614
// tmp := tmp ^ Bobby ;
2598: LD_ADDR_VAR 0 2
2602: PUSH
2603: LD_VAR 0 2
2607: PUSH
2608: LD_EXP 45
2612: ADD
2613: ST_TO_ADDR
// end ; if not Cyrus then
2614: LD_EXP 46
2618: NOT
2619: IFFALSE 2665
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2621: LD_ADDR_EXP 46
2625: PUSH
2626: LD_STRING Cyrus
2628: PPUSH
2629: LD_EXP 1
2633: NOT
2634: PPUSH
2635: LD_STRING 13f_
2637: PPUSH
2638: CALL 69444 0 3
2642: ST_TO_ADDR
// if Cyrus then
2643: LD_EXP 46
2647: IFFALSE 2665
// tmp := tmp ^ Cyrus ;
2649: LD_ADDR_VAR 0 2
2653: PUSH
2654: LD_VAR 0 2
2658: PUSH
2659: LD_EXP 46
2663: ADD
2664: ST_TO_ADDR
// end ; if not Brown then
2665: LD_EXP 48
2669: NOT
2670: IFFALSE 2716
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2672: LD_ADDR_EXP 48
2676: PUSH
2677: LD_STRING Brown
2679: PPUSH
2680: LD_EXP 1
2684: NOT
2685: PPUSH
2686: LD_STRING 13f_
2688: PPUSH
2689: CALL 69444 0 3
2693: ST_TO_ADDR
// if Brown then
2694: LD_EXP 48
2698: IFFALSE 2716
// tmp := tmp ^ Brown ;
2700: LD_ADDR_VAR 0 2
2704: PUSH
2705: LD_VAR 0 2
2709: PUSH
2710: LD_EXP 48
2714: ADD
2715: ST_TO_ADDR
// end ; if not Gladstone then
2716: LD_EXP 49
2720: NOT
2721: IFFALSE 2767
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2723: LD_ADDR_EXP 49
2727: PUSH
2728: LD_STRING Gladstone
2730: PPUSH
2731: LD_EXP 1
2735: NOT
2736: PPUSH
2737: LD_STRING 13f_
2739: PPUSH
2740: CALL 69444 0 3
2744: ST_TO_ADDR
// if Gladstone then
2745: LD_EXP 49
2749: IFFALSE 2767
// tmp := tmp ^ Gladstone ;
2751: LD_ADDR_VAR 0 2
2755: PUSH
2756: LD_VAR 0 2
2760: PUSH
2761: LD_EXP 49
2765: ADD
2766: ST_TO_ADDR
// end ; if not Houten then
2767: LD_EXP 50
2771: NOT
2772: IFFALSE 2818
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2774: LD_ADDR_EXP 50
2778: PUSH
2779: LD_STRING Houten
2781: PPUSH
2782: LD_EXP 1
2786: NOT
2787: PPUSH
2788: LD_STRING 13f_
2790: PPUSH
2791: CALL 69444 0 3
2795: ST_TO_ADDR
// if Houten then
2796: LD_EXP 50
2800: IFFALSE 2818
// tmp := tmp ^ Houten ;
2802: LD_ADDR_VAR 0 2
2806: PUSH
2807: LD_VAR 0 2
2811: PUSH
2812: LD_EXP 50
2816: ADD
2817: ST_TO_ADDR
// end ; if not Cornel then
2818: LD_EXP 51
2822: NOT
2823: IFFALSE 2869
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2825: LD_ADDR_EXP 51
2829: PUSH
2830: LD_STRING Cornell
2832: PPUSH
2833: LD_EXP 1
2837: NOT
2838: PPUSH
2839: LD_STRING 13f_
2841: PPUSH
2842: CALL 69444 0 3
2846: ST_TO_ADDR
// if Cornel then
2847: LD_EXP 51
2851: IFFALSE 2869
// tmp := tmp ^ Cornel ;
2853: LD_ADDR_VAR 0 2
2857: PUSH
2858: LD_VAR 0 2
2862: PUSH
2863: LD_EXP 51
2867: ADD
2868: ST_TO_ADDR
// end ; if not Gary then
2869: LD_EXP 52
2873: NOT
2874: IFFALSE 2920
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2876: LD_ADDR_EXP 52
2880: PUSH
2881: LD_STRING Gary
2883: PPUSH
2884: LD_EXP 1
2888: NOT
2889: PPUSH
2890: LD_STRING 13f_
2892: PPUSH
2893: CALL 69444 0 3
2897: ST_TO_ADDR
// if Gary then
2898: LD_EXP 52
2902: IFFALSE 2920
// tmp := tmp ^ Gary ;
2904: LD_ADDR_VAR 0 2
2908: PUSH
2909: LD_VAR 0 2
2913: PUSH
2914: LD_EXP 52
2918: ADD
2919: ST_TO_ADDR
// end ; if not Frank then
2920: LD_EXP 53
2924: NOT
2925: IFFALSE 2971
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2927: LD_ADDR_EXP 53
2931: PUSH
2932: LD_STRING Frank
2934: PPUSH
2935: LD_EXP 1
2939: NOT
2940: PPUSH
2941: LD_STRING 13f_
2943: PPUSH
2944: CALL 69444 0 3
2948: ST_TO_ADDR
// if Frank then
2949: LD_EXP 53
2953: IFFALSE 2971
// tmp := tmp ^ Frank ;
2955: LD_ADDR_VAR 0 2
2959: PUSH
2960: LD_VAR 0 2
2964: PUSH
2965: LD_EXP 53
2969: ADD
2970: ST_TO_ADDR
// end ; if not Kikuchi then
2971: LD_EXP 54
2975: NOT
2976: IFFALSE 3022
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2978: LD_ADDR_EXP 54
2982: PUSH
2983: LD_STRING Kikuchi
2985: PPUSH
2986: LD_EXP 1
2990: NOT
2991: PPUSH
2992: LD_STRING 13f_
2994: PPUSH
2995: CALL 69444 0 3
2999: ST_TO_ADDR
// if Kikuchi then
3000: LD_EXP 54
3004: IFFALSE 3022
// tmp := tmp ^ Kikuchi ;
3006: LD_ADDR_VAR 0 2
3010: PUSH
3011: LD_VAR 0 2
3015: PUSH
3016: LD_EXP 54
3020: ADD
3021: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3022: LD_ADDR_VAR 0 2
3026: PUSH
3027: LD_VAR 0 2
3031: PUSH
3032: LD_STRING 13_other_survivors
3034: PPUSH
3035: CALL_OW 31
3039: UNION
3040: ST_TO_ADDR
// result := tmp ;
3041: LD_ADDR_VAR 0 1
3045: PUSH
3046: LD_VAR 0 2
3050: ST_TO_ADDR
// end ; end_of_file
3051: LD_VAR 0 1
3055: RET
// export Powell ; export vip , extraSquad ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3056: LD_INT 0
3058: PPUSH
3059: PPUSH
3060: PPUSH
3061: PPUSH
3062: PPUSH
3063: PPUSH
3064: PPUSH
3065: PPUSH
3066: PPUSH
3067: PPUSH
// uc_side := 4 ;
3068: LD_ADDR_OWVAR 20
3072: PUSH
3073: LD_INT 4
3075: ST_TO_ADDR
// uc_nation := 1 ;
3076: LD_ADDR_OWVAR 21
3080: PUSH
3081: LD_INT 1
3083: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3084: LD_INT 387
3086: PPUSH
3087: CALL_OW 274
3091: PPUSH
3092: LD_INT 1
3094: PPUSH
3095: LD_INT 3500
3097: PUSH
3098: LD_INT 3000
3100: PUSH
3101: LD_INT 2500
3103: PUSH
3104: LD_INT 2000
3106: PUSH
3107: EMPTY
3108: LIST
3109: LIST
3110: LIST
3111: LIST
3112: PUSH
3113: LD_OWVAR 67
3117: ARRAY
3118: PPUSH
3119: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3123: LD_INT 387
3125: PPUSH
3126: CALL_OW 274
3130: PPUSH
3131: LD_INT 2
3133: PPUSH
3134: LD_INT 400
3136: PPUSH
3137: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3141: LD_INT 387
3143: PPUSH
3144: CALL_OW 274
3148: PPUSH
3149: LD_INT 3
3151: PPUSH
3152: LD_INT 10
3154: PPUSH
3155: CALL_OW 277
// SetBName ( am_depot , sigma ) ;
3159: LD_INT 387
3161: PPUSH
3162: LD_STRING sigma
3164: PPUSH
3165: CALL_OW 500
// Powell := NewCharacter ( Powell ) ;
3169: LD_ADDR_EXP 60
3173: PUSH
3174: LD_STRING Powell
3176: PPUSH
3177: CALL_OW 25
3181: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3182: LD_EXP 60
3186: PPUSH
3187: LD_INT 57
3189: PPUSH
3190: LD_INT 94
3192: PPUSH
3193: LD_INT 0
3195: PPUSH
3196: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3200: LD_EXP 60
3204: PPUSH
3205: LD_INT 58
3207: PPUSH
3208: LD_INT 94
3210: PPUSH
3211: CALL_OW 118
// vip := [ ] ;
3215: LD_ADDR_EXP 61
3219: PUSH
3220: EMPTY
3221: ST_TO_ADDR
// extraSquad := [ ] ;
3222: LD_ADDR_EXP 62
3226: PUSH
3227: EMPTY
3228: ST_TO_ADDR
// tmp := [ ] ;
3229: LD_ADDR_VAR 0 5
3233: PUSH
3234: EMPTY
3235: ST_TO_ADDR
// if JMMGirl <> 2 then
3236: LD_EXP 7
3240: PUSH
3241: LD_INT 2
3243: NONEQUAL
3244: IFFALSE 3268
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3246: LD_ADDR_EXP 43
3250: PUSH
3251: LD_STRING Lisa
3253: PPUSH
3254: LD_EXP 1
3258: NOT
3259: PPUSH
3260: LD_STRING 13s_
3262: PPUSH
3263: CALL 69444 0 3
3267: ST_TO_ADDR
// if Lisa then
3268: LD_EXP 43
3272: IFFALSE 3290
// tmp := tmp ^ Lisa ;
3274: LD_ADDR_VAR 0 5
3278: PUSH
3279: LD_VAR 0 5
3283: PUSH
3284: LD_EXP 43
3288: ADD
3289: ST_TO_ADDR
// if JMMGirl < 3 then
3290: LD_EXP 7
3294: PUSH
3295: LD_INT 3
3297: LESS
3298: IFFALSE 3329
// begin Connie := NewCharacter ( Coonie ) ;
3300: LD_ADDR_EXP 55
3304: PUSH
3305: LD_STRING Coonie
3307: PPUSH
3308: CALL_OW 25
3312: ST_TO_ADDR
// tmp := tmp ^ Connie ;
3313: LD_ADDR_VAR 0 5
3317: PUSH
3318: LD_VAR 0 5
3322: PUSH
3323: LD_EXP 55
3327: ADD
3328: ST_TO_ADDR
// end ; Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3329: LD_ADDR_EXP 44
3333: PUSH
3334: LD_STRING Donaldson
3336: PPUSH
3337: LD_EXP 1
3341: NOT
3342: PPUSH
3343: LD_STRING 13s_
3345: PPUSH
3346: CALL 69444 0 3
3350: ST_TO_ADDR
// if Donaldson then
3351: LD_EXP 44
3355: IFFALSE 3373
// tmp := tmp ^ Donaldson ;
3357: LD_ADDR_VAR 0 5
3361: PUSH
3362: LD_VAR 0 5
3366: PUSH
3367: LD_EXP 44
3371: ADD
3372: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3373: LD_ADDR_EXP 45
3377: PUSH
3378: LD_STRING Bobby
3380: PPUSH
3381: LD_EXP 1
3385: NOT
3386: PPUSH
3387: LD_STRING 13s_
3389: PPUSH
3390: CALL 69444 0 3
3394: ST_TO_ADDR
// if Bobby then
3395: LD_EXP 45
3399: IFFALSE 3417
// tmp := tmp ^ Bobby ;
3401: LD_ADDR_VAR 0 5
3405: PUSH
3406: LD_VAR 0 5
3410: PUSH
3411: LD_EXP 45
3415: ADD
3416: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3417: LD_ADDR_EXP 46
3421: PUSH
3422: LD_STRING Cyrus
3424: PPUSH
3425: LD_EXP 1
3429: NOT
3430: PPUSH
3431: LD_STRING 13s_
3433: PPUSH
3434: CALL 69444 0 3
3438: ST_TO_ADDR
// if Cyrus then
3439: LD_EXP 46
3443: IFFALSE 3461
// tmp := tmp ^ Cyrus ;
3445: LD_ADDR_VAR 0 5
3449: PUSH
3450: LD_VAR 0 5
3454: PUSH
3455: LD_EXP 46
3459: ADD
3460: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3461: LD_ADDR_EXP 47
3465: PUSH
3466: LD_STRING Denis
3468: PPUSH
3469: LD_EXP 1
3473: NOT
3474: PPUSH
3475: LD_STRING 13s_
3477: PPUSH
3478: CALL 69444 0 3
3482: ST_TO_ADDR
// if not Denis then
3483: LD_EXP 47
3487: NOT
3488: IFFALSE 3512
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3490: LD_ADDR_EXP 47
3494: PUSH
3495: LD_STRING Denis
3497: PPUSH
3498: LD_EXP 1
3502: NOT
3503: PPUSH
3504: LD_STRING 13f_
3506: PPUSH
3507: CALL 69444 0 3
3511: ST_TO_ADDR
// if Denis then
3512: LD_EXP 47
3516: IFFALSE 3534
// tmp := tmp ^ Denis ;
3518: LD_ADDR_VAR 0 5
3522: PUSH
3523: LD_VAR 0 5
3527: PUSH
3528: LD_EXP 47
3532: ADD
3533: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3534: LD_ADDR_EXP 48
3538: PUSH
3539: LD_STRING Brown
3541: PPUSH
3542: LD_EXP 1
3546: NOT
3547: PPUSH
3548: LD_STRING 13s_
3550: PPUSH
3551: CALL 69444 0 3
3555: ST_TO_ADDR
// if Brown then
3556: LD_EXP 48
3560: IFFALSE 3578
// tmp := tmp ^ Brown ;
3562: LD_ADDR_VAR 0 5
3566: PUSH
3567: LD_VAR 0 5
3571: PUSH
3572: LD_EXP 48
3576: ADD
3577: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3578: LD_ADDR_EXP 49
3582: PUSH
3583: LD_STRING Gladstone
3585: PPUSH
3586: LD_EXP 1
3590: NOT
3591: PPUSH
3592: LD_STRING 13s_
3594: PPUSH
3595: CALL 69444 0 3
3599: ST_TO_ADDR
// if Gladstone then
3600: LD_EXP 49
3604: IFFALSE 3622
// tmp := tmp ^ Gladstone ;
3606: LD_ADDR_VAR 0 5
3610: PUSH
3611: LD_VAR 0 5
3615: PUSH
3616: LD_EXP 49
3620: ADD
3621: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3622: LD_ADDR_EXP 50
3626: PUSH
3627: LD_STRING Houten
3629: PPUSH
3630: LD_EXP 1
3634: NOT
3635: PPUSH
3636: LD_STRING 13s_
3638: PPUSH
3639: CALL 69444 0 3
3643: ST_TO_ADDR
// if Houten then
3644: LD_EXP 50
3648: IFFALSE 3666
// tmp := tmp ^ Houten ;
3650: LD_ADDR_VAR 0 5
3654: PUSH
3655: LD_VAR 0 5
3659: PUSH
3660: LD_EXP 50
3664: ADD
3665: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3666: LD_ADDR_EXP 51
3670: PUSH
3671: LD_STRING Cornel
3673: PPUSH
3674: LD_EXP 1
3678: NOT
3679: PPUSH
3680: LD_STRING 13s_
3682: PPUSH
3683: CALL 69444 0 3
3687: ST_TO_ADDR
// if Cornel then
3688: LD_EXP 51
3692: IFFALSE 3710
// tmp := tmp ^ Cornel ;
3694: LD_ADDR_VAR 0 5
3698: PUSH
3699: LD_VAR 0 5
3703: PUSH
3704: LD_EXP 51
3708: ADD
3709: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3710: LD_ADDR_EXP 52
3714: PUSH
3715: LD_STRING Gary
3717: PPUSH
3718: LD_EXP 1
3722: NOT
3723: PPUSH
3724: LD_STRING 13s_
3726: PPUSH
3727: CALL 69444 0 3
3731: ST_TO_ADDR
// if Gary then
3732: LD_EXP 52
3736: IFFALSE 3754
// tmp := tmp ^ Gary ;
3738: LD_ADDR_VAR 0 5
3742: PUSH
3743: LD_VAR 0 5
3747: PUSH
3748: LD_EXP 52
3752: ADD
3753: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3754: LD_ADDR_EXP 53
3758: PUSH
3759: LD_STRING Frank
3761: PPUSH
3762: LD_EXP 1
3766: NOT
3767: PPUSH
3768: LD_STRING 13s_
3770: PPUSH
3771: CALL 69444 0 3
3775: ST_TO_ADDR
// if Frank then
3776: LD_EXP 53
3780: IFFALSE 3798
// tmp := tmp ^ Frank ;
3782: LD_ADDR_VAR 0 5
3786: PUSH
3787: LD_VAR 0 5
3791: PUSH
3792: LD_EXP 53
3796: ADD
3797: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3798: LD_ADDR_EXP 54
3802: PUSH
3803: LD_STRING Kikuchi
3805: PPUSH
3806: LD_EXP 1
3810: NOT
3811: PPUSH
3812: LD_STRING 13s_
3814: PPUSH
3815: CALL 69444 0 3
3819: ST_TO_ADDR
// if Kikuchi then
3820: LD_EXP 54
3824: IFFALSE 3842
// tmp := tmp ^ Kikuchi ;
3826: LD_ADDR_VAR 0 5
3830: PUSH
3831: LD_VAR 0 5
3835: PUSH
3836: LD_EXP 54
3840: ADD
3841: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 10c_ ) ;
3842: LD_ADDR_EXP 57
3846: PUSH
3847: LD_STRING Mike
3849: PPUSH
3850: LD_EXP 1
3854: NOT
3855: PPUSH
3856: LD_STRING 10c_
3858: PPUSH
3859: CALL 69444 0 3
3863: ST_TO_ADDR
// if Mike then
3864: LD_EXP 57
3868: IFFALSE 3891
// PlaceUnitXYR ( Mike , 61 , 89 , 8 , false ) ;
3870: LD_EXP 57
3874: PPUSH
3875: LD_INT 61
3877: PPUSH
3878: LD_INT 89
3880: PPUSH
3881: LD_INT 8
3883: PPUSH
3884: LD_INT 0
3886: PPUSH
3887: CALL_OW 50
// vip := tmp ;
3891: LD_ADDR_EXP 61
3895: PUSH
3896: LD_VAR 0 5
3900: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3901: LD_ADDR_VAR 0 5
3905: PUSH
3906: LD_VAR 0 5
3910: PUSH
3911: LD_STRING 13s_others
3913: PPUSH
3914: CALL_OW 31
3918: UNION
3919: ST_TO_ADDR
// if tmp < 18 then
3920: LD_VAR 0 5
3924: PUSH
3925: LD_INT 18
3927: LESS
3928: IFFALSE 4033
// begin InitHC_All ( ) ;
3930: CALL_OW 584
// for i = 1 to 18 - tmp do
3934: LD_ADDR_VAR 0 2
3938: PUSH
3939: DOUBLE
3940: LD_INT 1
3942: DEC
3943: ST_TO_ADDR
3944: LD_INT 18
3946: PUSH
3947: LD_VAR 0 5
3951: MINUS
3952: PUSH
3953: FOR_TO
3954: IFFALSE 4031
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
3956: LD_INT 1
3958: PPUSH
3959: LD_VAR 0 2
3963: PUSH
3964: LD_INT 4
3966: MOD
3967: PUSH
3968: LD_INT 1
3970: PLUS
3971: PPUSH
3972: LD_INT 4
3974: PPUSH
3975: CALL_OW 380
// un := CreateHuman ;
3979: LD_ADDR_VAR 0 10
3983: PUSH
3984: CALL_OW 44
3988: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
3989: LD_ADDR_VAR 0 5
3993: PUSH
3994: LD_VAR 0 5
3998: PPUSH
3999: LD_VAR 0 10
4003: PPUSH
4004: CALL 107135 0 2
4008: ST_TO_ADDR
// extraSquad := Join ( extraSquad , un ) ;
4009: LD_ADDR_EXP 62
4013: PUSH
4014: LD_EXP 62
4018: PPUSH
4019: LD_VAR 0 10
4023: PPUSH
4024: CALL 107135 0 2
4028: ST_TO_ADDR
// end ;
4029: GO 3953
4031: POP
4032: POP
// end ; depot := HexInfo ( 53 , 94 ) ;
4033: LD_ADDR_VAR 0 6
4037: PUSH
4038: LD_INT 53
4040: PPUSH
4041: LD_INT 94
4043: PPUSH
4044: CALL_OW 428
4048: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
4049: LD_ADDR_VAR 0 7
4053: PUSH
4054: LD_INT 56
4056: PPUSH
4057: LD_INT 101
4059: PPUSH
4060: CALL_OW 428
4064: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
4065: LD_ADDR_VAR 0 8
4069: PUSH
4070: LD_INT 67
4072: PPUSH
4073: LD_INT 101
4075: PPUSH
4076: CALL_OW 428
4080: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
4081: LD_ADDR_VAR 0 9
4085: PUSH
4086: LD_INT 54
4088: PPUSH
4089: LD_INT 85
4091: PPUSH
4092: CALL_OW 428
4096: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
4097: LD_ADDR_VAR 0 3
4101: PUSH
4102: LD_VAR 0 8
4106: PUSH
4107: LD_VAR 0 6
4111: PUSH
4112: LD_VAR 0 9
4116: PUSH
4117: LD_VAR 0 7
4121: PUSH
4122: EMPTY
4123: LIST
4124: LIST
4125: LIST
4126: LIST
4127: ST_TO_ADDR
// for i in tmp do
4128: LD_ADDR_VAR 0 2
4132: PUSH
4133: LD_VAR 0 5
4137: PUSH
4138: FOR_IN
4139: IFFALSE 4334
// begin case GetBType ( b [ 1 ] ) of b_armoury :
4141: LD_VAR 0 3
4145: PUSH
4146: LD_INT 1
4148: ARRAY
4149: PPUSH
4150: CALL_OW 266
4154: PUSH
4155: LD_INT 4
4157: DOUBLE
4158: EQUAL
4159: IFTRUE 4163
4161: GO 4178
4163: POP
// SetClass ( i , class_soldier ) ; b_depot :
4164: LD_VAR 0 2
4168: PPUSH
4169: LD_INT 1
4171: PPUSH
4172: CALL_OW 336
4176: GO 4248
4178: LD_INT 0
4180: DOUBLE
4181: EQUAL
4182: IFTRUE 4186
4184: GO 4201
4186: POP
// SetClass ( i , class_engineer ) ; b_workshop :
4187: LD_VAR 0 2
4191: PPUSH
4192: LD_INT 2
4194: PPUSH
4195: CALL_OW 336
4199: GO 4248
4201: LD_INT 2
4203: DOUBLE
4204: EQUAL
4205: IFTRUE 4209
4207: GO 4224
4209: POP
// SetClass ( i , class_mechanic ) ; b_lab :
4210: LD_VAR 0 2
4214: PPUSH
4215: LD_INT 3
4217: PPUSH
4218: CALL_OW 336
4222: GO 4248
4224: LD_INT 6
4226: DOUBLE
4227: EQUAL
4228: IFTRUE 4232
4230: GO 4247
4232: POP
// SetClass ( i , class_scientistic ) ; end ;
4233: LD_VAR 0 2
4237: PPUSH
4238: LD_INT 4
4240: PPUSH
4241: CALL_OW 336
4245: GO 4248
4247: POP
// if UnitsInside ( b [ 1 ] ) = 6 then
4248: LD_VAR 0 3
4252: PUSH
4253: LD_INT 1
4255: ARRAY
4256: PPUSH
4257: CALL_OW 313
4261: PUSH
4262: LD_INT 6
4264: EQUAL
4265: IFFALSE 4285
// b := Delete ( b , 1 ) ;
4267: LD_ADDR_VAR 0 3
4271: PUSH
4272: LD_VAR 0 3
4276: PPUSH
4277: LD_INT 1
4279: PPUSH
4280: CALL_OW 3
4284: ST_TO_ADDR
// if b then
4285: LD_VAR 0 3
4289: IFFALSE 4311
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4291: LD_VAR 0 2
4295: PPUSH
4296: LD_VAR 0 3
4300: PUSH
4301: LD_INT 1
4303: ARRAY
4304: PPUSH
4305: CALL_OW 52
4309: GO 4332
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4311: LD_VAR 0 2
4315: PPUSH
4316: LD_INT 61
4318: PPUSH
4319: LD_INT 89
4321: PPUSH
4322: LD_INT 8
4324: PPUSH
4325: LD_INT 0
4327: PPUSH
4328: CALL_OW 50
// end ;
4332: GO 4138
4334: POP
4335: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4336: LD_INT 2
4338: PPUSH
4339: LD_INT 1
4341: PPUSH
4342: LD_INT 1
4344: PPUSH
4345: LD_INT 12
4347: PPUSH
4348: LD_INT 100
4350: PPUSH
4351: CALL 74284 0 5
// veh := CreateVehicle ;
4355: LD_ADDR_VAR 0 4
4359: PUSH
4360: CALL_OW 45
4364: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4365: LD_VAR 0 4
4369: PPUSH
4370: LD_INT 4
4372: PPUSH
4373: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4377: LD_VAR 0 4
4381: PPUSH
4382: LD_INT 49
4384: PPUSH
4385: LD_INT 88
4387: PPUSH
4388: LD_INT 0
4390: PPUSH
4391: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4395: LD_VAR 0 4
4399: PPUSH
4400: LD_INT 1
4402: PPUSH
4403: LD_INT 100
4405: PPUSH
4406: CALL_OW 290
// uc_side := 0 ;
4410: LD_ADDR_OWVAR 20
4414: PUSH
4415: LD_INT 0
4417: ST_TO_ADDR
// uc_nation := 0 ;
4418: LD_ADDR_OWVAR 21
4422: PUSH
4423: LD_INT 0
4425: ST_TO_ADDR
// for i := 1 to 3 do
4426: LD_ADDR_VAR 0 2
4430: PUSH
4431: DOUBLE
4432: LD_INT 1
4434: DEC
4435: ST_TO_ADDR
4436: LD_INT 3
4438: PUSH
4439: FOR_TO
4440: IFFALSE 4471
// begin InitHc ;
4442: CALL_OW 19
// hc_class := class_apeman ;
4446: LD_ADDR_OWVAR 28
4450: PUSH
4451: LD_INT 12
4453: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4454: CALL_OW 44
4458: PPUSH
4459: LD_INT 13
4461: PPUSH
4462: LD_INT 0
4464: PPUSH
4465: CALL_OW 49
// end ;
4469: GO 4439
4471: POP
4472: POP
// end ; end_of_file
4473: LD_VAR 0 1
4477: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4478: LD_INT 0
4480: PPUSH
4481: PPUSH
4482: PPUSH
4483: PPUSH
4484: PPUSH
// side := 8 ;
4485: LD_ADDR_VAR 0 3
4489: PUSH
4490: LD_INT 8
4492: ST_TO_ADDR
// uc_side := side ;
4493: LD_ADDR_OWVAR 20
4497: PUSH
4498: LD_VAR 0 3
4502: ST_TO_ADDR
// uc_nation := 2 ;
4503: LD_ADDR_OWVAR 21
4507: PUSH
4508: LD_INT 2
4510: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4511: LD_ADDR_VAR 0 2
4515: PUSH
4516: LD_INT 22
4518: PUSH
4519: LD_VAR 0 3
4523: PUSH
4524: EMPTY
4525: LIST
4526: LIST
4527: PUSH
4528: LD_INT 21
4530: PUSH
4531: LD_INT 3
4533: PUSH
4534: EMPTY
4535: LIST
4536: LIST
4537: PUSH
4538: EMPTY
4539: LIST
4540: LIST
4541: PPUSH
4542: CALL_OW 69
4546: PUSH
4547: FOR_IN
4548: IFFALSE 4564
// SetBLevel ( i , 10 ) ;
4550: LD_VAR 0 2
4554: PPUSH
4555: LD_INT 10
4557: PPUSH
4558: CALL_OW 241
4562: GO 4547
4564: POP
4565: POP
// if KurtStatus then
4566: LD_EXP 3
4570: IFFALSE 4593
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4572: LD_ADDR_EXP 63
4576: PUSH
4577: LD_STRING Kurt
4579: PPUSH
4580: LD_INT 0
4582: PPUSH
4583: LD_STRING 
4585: PPUSH
4586: CALL 69444 0 3
4590: ST_TO_ADDR
4591: GO 4615
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4593: LD_ADDR_EXP 63
4597: PUSH
4598: LD_STRING AltKurt
4600: PPUSH
4601: LD_EXP 1
4605: NOT
4606: PPUSH
4607: LD_STRING 
4609: PPUSH
4610: CALL 69444 0 3
4614: ST_TO_ADDR
// if not Kurt then
4615: LD_EXP 63
4619: NOT
4620: IFFALSE 4646
// begin InitHc ;
4622: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4626: LD_INT 1
4628: PPUSH
4629: LD_INT 10
4631: PPUSH
4632: CALL_OW 381
// Kurt := CreateHuman ;
4636: LD_ADDR_EXP 63
4640: PUSH
4641: CALL_OW 44
4645: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4646: LD_EXP 63
4650: PPUSH
4651: LD_INT 324
4653: PPUSH
4654: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4658: LD_ADDR_EXP 64
4662: PUSH
4663: LD_STRING Kozlov
4665: PPUSH
4666: LD_INT 0
4668: PPUSH
4669: LD_STRING 
4671: PPUSH
4672: CALL 69444 0 3
4676: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4677: LD_EXP 64
4681: PPUSH
4682: LD_INT 22
4684: PUSH
4685: LD_INT 8
4687: PUSH
4688: EMPTY
4689: LIST
4690: LIST
4691: PUSH
4692: LD_INT 23
4694: PUSH
4695: LD_INT 3
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: PUSH
4702: LD_INT 30
4704: PUSH
4705: LD_INT 8
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PUSH
4712: EMPTY
4713: LIST
4714: LIST
4715: LIST
4716: PPUSH
4717: CALL_OW 69
4721: PUSH
4722: LD_INT 1
4724: ARRAY
4725: PPUSH
4726: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4730: LD_EXP 64
4734: PPUSH
4735: LD_INT 3
4737: PPUSH
4738: LD_INT 10
4740: PPUSH
4741: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4745: LD_EXP 64
4749: PPUSH
4750: LD_INT 4
4752: PPUSH
4753: LD_INT 10
4755: PPUSH
4756: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4760: LD_ADDR_VAR 0 5
4764: PUSH
4765: LD_INT 22
4767: PUSH
4768: LD_VAR 0 3
4772: PUSH
4773: EMPTY
4774: LIST
4775: LIST
4776: PUSH
4777: LD_INT 30
4779: PUSH
4780: LD_INT 32
4782: PUSH
4783: EMPTY
4784: LIST
4785: LIST
4786: PUSH
4787: LD_INT 58
4789: PUSH
4790: EMPTY
4791: LIST
4792: PUSH
4793: EMPTY
4794: LIST
4795: LIST
4796: LIST
4797: PPUSH
4798: CALL_OW 69
4802: ST_TO_ADDR
// for i = 1 to 10 do
4803: LD_ADDR_VAR 0 2
4807: PUSH
4808: DOUBLE
4809: LD_INT 1
4811: DEC
4812: ST_TO_ADDR
4813: LD_INT 10
4815: PUSH
4816: FOR_TO
4817: IFFALSE 4889
// begin uc_nation := nation_nature ;
4819: LD_ADDR_OWVAR 21
4823: PUSH
4824: LD_INT 0
4826: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4827: LD_ADDR_OWVAR 28
4831: PUSH
4832: LD_INT 15
4834: ST_TO_ADDR
// hc_gallery :=  ;
4835: LD_ADDR_OWVAR 33
4839: PUSH
4840: LD_STRING 
4842: ST_TO_ADDR
// hc_name :=  ;
4843: LD_ADDR_OWVAR 26
4847: PUSH
4848: LD_STRING 
4850: ST_TO_ADDR
// un := CreateHuman ;
4851: LD_ADDR_VAR 0 4
4855: PUSH
4856: CALL_OW 44
4860: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4861: LD_VAR 0 4
4865: PPUSH
4866: LD_VAR 0 5
4870: PUSH
4871: LD_VAR 0 5
4875: PUSH
4876: LD_VAR 0 2
4880: MINUS
4881: ARRAY
4882: PPUSH
4883: CALL_OW 52
// end ;
4887: GO 4816
4889: POP
4890: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4891: LD_ADDR_VAR 0 5
4895: PUSH
4896: LD_STRING 12_kurt_squad
4898: PPUSH
4899: CALL_OW 31
4903: ST_TO_ADDR
// if tmp then
4904: LD_VAR 0 5
4908: IFFALSE 4942
// for i in tmp do
4910: LD_ADDR_VAR 0 2
4914: PUSH
4915: LD_VAR 0 5
4919: PUSH
4920: FOR_IN
4921: IFFALSE 4940
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4923: LD_VAR 0 2
4927: PPUSH
4928: LD_INT 5
4930: PPUSH
4931: LD_INT 0
4933: PPUSH
4934: CALL_OW 49
4938: GO 4920
4940: POP
4941: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4942: LD_INT 324
4944: PPUSH
4945: LD_INT 5
4947: PPUSH
4948: LD_STRING 
4950: PPUSH
4951: LD_INT 8
4953: PUSH
4954: LD_INT 9
4956: PUSH
4957: LD_INT 10
4959: PUSH
4960: LD_INT 10
4962: PUSH
4963: EMPTY
4964: LIST
4965: LIST
4966: LIST
4967: LIST
4968: PUSH
4969: LD_OWVAR 67
4973: ARRAY
4974: PPUSH
4975: LD_INT 3000
4977: PUSH
4978: LD_INT 500
4980: PUSH
4981: LD_INT 150
4983: PUSH
4984: EMPTY
4985: LIST
4986: LIST
4987: LIST
4988: PPUSH
4989: LD_INT 16
4991: PUSH
4992: LD_INT 6
4994: PUSH
4995: LD_INT 6
4997: PUSH
4998: LD_INT 8
5000: PUSH
5001: EMPTY
5002: LIST
5003: LIST
5004: LIST
5005: LIST
5006: PPUSH
5007: CALL 78105 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
5011: LD_ADDR_EXP 101
5015: PUSH
5016: LD_EXP 101
5020: PPUSH
5021: LD_INT 3
5023: PPUSH
5024: LD_INT 22
5026: PUSH
5027: LD_VAR 0 3
5031: PUSH
5032: EMPTY
5033: LIST
5034: LIST
5035: PUSH
5036: LD_INT 23
5038: PUSH
5039: LD_INT 2
5041: PUSH
5042: EMPTY
5043: LIST
5044: LIST
5045: PUSH
5046: LD_INT 3
5048: PUSH
5049: LD_INT 21
5051: PUSH
5052: LD_INT 2
5054: PUSH
5055: EMPTY
5056: LIST
5057: LIST
5058: PUSH
5059: EMPTY
5060: LIST
5061: LIST
5062: PUSH
5063: EMPTY
5064: LIST
5065: LIST
5066: LIST
5067: PPUSH
5068: CALL_OW 69
5072: PUSH
5073: LD_EXP 63
5077: DIFF
5078: PPUSH
5079: CALL_OW 1
5083: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
5084: LD_INT 1
5086: PPUSH
5087: LD_INT 7
5089: PPUSH
5090: CALL_OW 383
// hc_name := Ali Hadrach ;
5094: LD_ADDR_OWVAR 26
5098: PUSH
5099: LD_STRING Ali Hadrach
5101: ST_TO_ADDR
// hc_face_number := 31 ;
5102: LD_ADDR_OWVAR 34
5106: PUSH
5107: LD_INT 31
5109: ST_TO_ADDR
// Friend := CreateHuman ;
5110: LD_ADDR_EXP 65
5114: PUSH
5115: CALL_OW 44
5119: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
5120: LD_INT 14
5122: PPUSH
5123: LD_INT 3
5125: PPUSH
5126: LD_INT 1
5128: PPUSH
5129: LD_INT 29
5131: PPUSH
5132: LD_INT 100
5134: PPUSH
5135: CALL 74284 0 5
// powellBomb := CreateVehicle ;
5139: LD_ADDR_EXP 66
5143: PUSH
5144: CALL_OW 45
5148: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
5149: LD_EXP 66
5153: PPUSH
5154: LD_INT 90
5156: PPUSH
5157: LD_INT 51
5159: PPUSH
5160: LD_INT 0
5162: PPUSH
5163: CALL_OW 48
// end ;
5167: LD_VAR 0 1
5171: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
5172: LD_INT 0
5174: PPUSH
5175: PPUSH
5176: PPUSH
// if IsLive ( kozlov_fac ) then
5177: LD_INT 332
5179: PPUSH
5180: CALL_OW 300
5184: IFFALSE 5188
// exit ;
5186: GO 5755
// ComExitBuilding ( Kozlov ) ;
5188: LD_EXP 64
5192: PPUSH
5193: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
5197: LD_EXP 64
5201: PPUSH
5202: CALL_OW 257
5206: PUSH
5207: LD_INT 2
5209: NONEQUAL
5210: IFFALSE 5245
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
5212: LD_EXP 64
5216: PPUSH
5217: LD_INT 324
5219: PPUSH
5220: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
5224: LD_EXP 64
5228: PPUSH
5229: LD_INT 2
5231: PPUSH
5232: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
5236: LD_EXP 64
5240: PPUSH
5241: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
5245: LD_EXP 64
5249: PPUSH
5250: LD_INT 2
5252: PPUSH
5253: LD_INT 93
5255: PPUSH
5256: LD_INT 32
5258: PPUSH
5259: LD_INT 3
5261: PPUSH
5262: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5266: LD_INT 35
5268: PPUSH
5269: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5273: LD_INT 22
5275: PUSH
5276: LD_INT 8
5278: PUSH
5279: EMPTY
5280: LIST
5281: LIST
5282: PUSH
5283: LD_INT 30
5285: PUSH
5286: LD_INT 3
5288: PUSH
5289: EMPTY
5290: LIST
5291: LIST
5292: PUSH
5293: LD_INT 23
5295: PUSH
5296: LD_INT 3
5298: PUSH
5299: EMPTY
5300: LIST
5301: LIST
5302: PUSH
5303: LD_INT 57
5305: PUSH
5306: EMPTY
5307: LIST
5308: PUSH
5309: EMPTY
5310: LIST
5311: LIST
5312: LIST
5313: LIST
5314: PPUSH
5315: CALL_OW 69
5319: IFFALSE 5266
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5321: LD_ADDR_VAR 0 2
5325: PUSH
5326: LD_INT 22
5328: PUSH
5329: LD_INT 8
5331: PUSH
5332: EMPTY
5333: LIST
5334: LIST
5335: PUSH
5336: LD_INT 30
5338: PUSH
5339: LD_INT 3
5341: PUSH
5342: EMPTY
5343: LIST
5344: LIST
5345: PUSH
5346: LD_INT 23
5348: PUSH
5349: LD_INT 3
5351: PUSH
5352: EMPTY
5353: LIST
5354: LIST
5355: PUSH
5356: LD_INT 57
5358: PUSH
5359: EMPTY
5360: LIST
5361: PUSH
5362: EMPTY
5363: LIST
5364: LIST
5365: LIST
5366: LIST
5367: PPUSH
5368: CALL_OW 69
5372: PUSH
5373: LD_INT 1
5375: ARRAY
5376: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5377: LD_INT 22
5379: PUSH
5380: LD_INT 8
5382: PUSH
5383: EMPTY
5384: LIST
5385: LIST
5386: PUSH
5387: LD_INT 23
5389: PUSH
5390: LD_INT 3
5392: PUSH
5393: EMPTY
5394: LIST
5395: LIST
5396: PUSH
5397: LD_INT 30
5399: PUSH
5400: LD_INT 21
5402: PUSH
5403: EMPTY
5404: LIST
5405: LIST
5406: PUSH
5407: EMPTY
5408: LIST
5409: LIST
5410: LIST
5411: PPUSH
5412: CALL_OW 69
5416: NOT
5417: IFFALSE 5495
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5419: LD_EXP 64
5423: PPUSH
5424: LD_INT 21
5426: PPUSH
5427: LD_INT 97
5429: PPUSH
5430: LD_INT 36
5432: PPUSH
5433: LD_INT 5
5435: PPUSH
5436: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5440: LD_INT 35
5442: PPUSH
5443: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5447: LD_INT 22
5449: PUSH
5450: LD_INT 8
5452: PUSH
5453: EMPTY
5454: LIST
5455: LIST
5456: PUSH
5457: LD_INT 23
5459: PUSH
5460: LD_INT 3
5462: PUSH
5463: EMPTY
5464: LIST
5465: LIST
5466: PUSH
5467: LD_INT 30
5469: PUSH
5470: LD_INT 21
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: PUSH
5477: LD_INT 57
5479: PUSH
5480: EMPTY
5481: LIST
5482: PUSH
5483: EMPTY
5484: LIST
5485: LIST
5486: LIST
5487: LIST
5488: PPUSH
5489: CALL_OW 69
5493: IFFALSE 5440
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5495: LD_INT 22
5497: PUSH
5498: LD_INT 8
5500: PUSH
5501: EMPTY
5502: LIST
5503: LIST
5504: PUSH
5505: LD_INT 23
5507: PUSH
5508: LD_INT 3
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: PUSH
5515: LD_INT 30
5517: PUSH
5518: LD_INT 18
5520: PUSH
5521: EMPTY
5522: LIST
5523: LIST
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: LIST
5529: PPUSH
5530: CALL_OW 69
5534: NOT
5535: IFFALSE 5613
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5537: LD_EXP 64
5541: PPUSH
5542: LD_INT 18
5544: PPUSH
5545: LD_INT 89
5547: PPUSH
5548: LD_INT 32
5550: PPUSH
5551: LD_INT 1
5553: PPUSH
5554: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5558: LD_INT 35
5560: PPUSH
5561: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5565: LD_INT 22
5567: PUSH
5568: LD_INT 8
5570: PUSH
5571: EMPTY
5572: LIST
5573: LIST
5574: PUSH
5575: LD_INT 23
5577: PUSH
5578: LD_INT 3
5580: PUSH
5581: EMPTY
5582: LIST
5583: LIST
5584: PUSH
5585: LD_INT 30
5587: PUSH
5588: LD_INT 18
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: PUSH
5595: LD_INT 57
5597: PUSH
5598: EMPTY
5599: LIST
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: LIST
5605: LIST
5606: PPUSH
5607: CALL_OW 69
5611: IFFALSE 5558
// end ; lab := kozlov_lab ;
5613: LD_ADDR_VAR 0 3
5617: PUSH
5618: LD_INT 336
5620: ST_TO_ADDR
// if not lab then
5621: LD_VAR 0 3
5625: NOT
5626: IFFALSE 5630
// exit ;
5628: GO 5755
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5630: LD_EXP 64
5634: PPUSH
5635: LD_VAR 0 3
5639: PUSH
5640: LD_INT 1
5642: ARRAY
5643: PPUSH
5644: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5648: LD_EXP 64
5652: PPUSH
5653: LD_INT 4
5655: PPUSH
5656: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5660: LD_VAR 0 3
5664: PUSH
5665: LD_INT 1
5667: ARRAY
5668: PPUSH
5669: LD_INT 25
5671: PPUSH
5672: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5676: LD_INT 35
5678: PPUSH
5679: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5683: LD_INT 25
5685: PPUSH
5686: LD_INT 8
5688: PPUSH
5689: CALL_OW 321
5693: PUSH
5694: LD_INT 2
5696: EQUAL
5697: IFFALSE 5676
// ComExitBuilding ( Kozlov ) ;
5699: LD_EXP 64
5703: PPUSH
5704: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5708: LD_EXP 64
5712: PPUSH
5713: LD_VAR 0 2
5717: PPUSH
5718: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5722: LD_EXP 64
5726: PPUSH
5727: LD_INT 3
5729: PPUSH
5730: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5734: LD_VAR 0 2
5738: PPUSH
5739: LD_INT 23
5741: PPUSH
5742: LD_INT 3
5744: PPUSH
5745: LD_INT 1
5747: PPUSH
5748: LD_INT 48
5750: PPUSH
5751: CALL_OW 125
// end ;
5755: LD_VAR 0 1
5759: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5760: LD_EXP 22
5764: NOT
5765: PUSH
5766: LD_EXP 15
5770: PUSH
5771: LD_INT 6
5773: GREATEREQUAL
5774: AND
5775: IFFALSE 5856
5777: GO 5779
5779: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5780: LD_INT 3
5782: PPUSH
5783: LD_INT 3
5785: PPUSH
5786: CALL 63155 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5790: LD_INT 3
5792: PPUSH
5793: LD_INT 14
5795: PUSH
5796: LD_INT 1
5798: PUSH
5799: LD_INT 1
5801: PUSH
5802: LD_INT 28
5804: PUSH
5805: EMPTY
5806: LIST
5807: LIST
5808: LIST
5809: LIST
5810: PUSH
5811: LD_INT 14
5813: PUSH
5814: LD_INT 1
5816: PUSH
5817: LD_INT 1
5819: PUSH
5820: LD_INT 28
5822: PUSH
5823: EMPTY
5824: LIST
5825: LIST
5826: LIST
5827: LIST
5828: PUSH
5829: LD_INT 14
5831: PUSH
5832: LD_INT 1
5834: PUSH
5835: LD_INT 1
5837: PUSH
5838: LD_INT 28
5840: PUSH
5841: EMPTY
5842: LIST
5843: LIST
5844: LIST
5845: LIST
5846: PUSH
5847: EMPTY
5848: LIST
5849: LIST
5850: LIST
5851: PPUSH
5852: CALL 63018 0 2
// end ;
5856: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target , p ;
5857: LD_EXP 22
5861: NOT
5862: PUSH
5863: LD_EXP 15
5867: PUSH
5868: LD_INT 6
5870: GREATEREQUAL
5871: AND
5872: PUSH
5873: LD_INT 3
5875: PPUSH
5876: LD_INT 1
5878: PPUSH
5879: CALL 64436 0 2
5883: NOT
5884: AND
5885: IFFALSE 6832
5887: GO 5889
5889: DISABLE
5890: LD_INT 0
5892: PPUSH
5893: PPUSH
5894: PPUSH
5895: PPUSH
// begin enable ;
5896: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5897: LD_INT 22
5899: PUSH
5900: LD_INT 8
5902: PUSH
5903: EMPTY
5904: LIST
5905: LIST
5906: PUSH
5907: LD_INT 23
5909: PUSH
5910: LD_INT 2
5912: PUSH
5913: EMPTY
5914: LIST
5915: LIST
5916: PUSH
5917: LD_INT 30
5919: PUSH
5920: LD_INT 3
5922: PUSH
5923: EMPTY
5924: LIST
5925: LIST
5926: PUSH
5927: EMPTY
5928: LIST
5929: LIST
5930: LIST
5931: PPUSH
5932: CALL_OW 69
5936: NOT
5937: IFFALSE 5941
// exit ;
5939: GO 6832
// if Prob ( 40 ) then
5941: LD_INT 40
5943: PPUSH
5944: CALL_OW 13
5948: IFFALSE 6075
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5950: LD_INT 3
5952: PPUSH
5953: LD_INT 14
5955: PUSH
5956: LD_INT 1
5958: PUSH
5959: LD_INT 2
5961: PUSH
5962: LD_INT 28
5964: PUSH
5965: EMPTY
5966: LIST
5967: LIST
5968: LIST
5969: LIST
5970: PUSH
5971: LD_INT 14
5973: PUSH
5974: LD_INT 1
5976: PUSH
5977: LD_INT 2
5979: PUSH
5980: LD_INT 28
5982: PUSH
5983: EMPTY
5984: LIST
5985: LIST
5986: LIST
5987: LIST
5988: PUSH
5989: LD_INT 14
5991: PUSH
5992: LD_INT 1
5994: PUSH
5995: LD_INT 2
5997: PUSH
5998: LD_INT 28
6000: PUSH
6001: EMPTY
6002: LIST
6003: LIST
6004: LIST
6005: LIST
6006: PUSH
6007: LD_INT 14
6009: PUSH
6010: LD_INT 1
6012: PUSH
6013: LD_INT 2
6015: PUSH
6016: LD_INT 28
6018: PUSH
6019: EMPTY
6020: LIST
6021: LIST
6022: LIST
6023: LIST
6024: PUSH
6025: LD_INT 14
6027: PUSH
6028: LD_INT 1
6030: PUSH
6031: LD_INT 2
6033: PUSH
6034: LD_INT 28
6036: PUSH
6037: EMPTY
6038: LIST
6039: LIST
6040: LIST
6041: LIST
6042: PUSH
6043: LD_INT 14
6045: PUSH
6046: LD_INT 1
6048: PUSH
6049: LD_INT 2
6051: PUSH
6052: LD_INT 26
6054: PUSH
6055: EMPTY
6056: LIST
6057: LIST
6058: LIST
6059: LIST
6060: PUSH
6061: EMPTY
6062: LIST
6063: LIST
6064: LIST
6065: LIST
6066: LIST
6067: LIST
6068: PPUSH
6069: CALL 63018 0 2
// end else
6073: GO 6282
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6075: LD_INT 3
6077: PPUSH
6078: LD_INT 14
6080: PUSH
6081: LD_INT 1
6083: PUSH
6084: LD_INT 2
6086: PUSH
6087: LD_INT 27
6089: PUSH
6090: LD_INT 26
6092: PUSH
6093: LD_INT 26
6095: PUSH
6096: LD_INT 28
6098: PUSH
6099: EMPTY
6100: LIST
6101: LIST
6102: LIST
6103: LIST
6104: PUSH
6105: LD_OWVAR 67
6109: ARRAY
6110: PUSH
6111: EMPTY
6112: LIST
6113: LIST
6114: LIST
6115: LIST
6116: PUSH
6117: LD_INT 14
6119: PUSH
6120: LD_INT 1
6122: PUSH
6123: LD_INT 2
6125: PUSH
6126: LD_INT 27
6128: PUSH
6129: LD_INT 26
6131: PUSH
6132: LD_INT 26
6134: PUSH
6135: LD_INT 26
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: LIST
6142: LIST
6143: PUSH
6144: LD_OWVAR 67
6148: ARRAY
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: PUSH
6156: LD_INT 14
6158: PUSH
6159: LD_INT 1
6161: PUSH
6162: LD_INT 2
6164: PUSH
6165: LD_INT 26
6167: PUSH
6168: LD_INT 26
6170: PUSH
6171: LD_INT 29
6173: PUSH
6174: LD_INT 29
6176: PUSH
6177: EMPTY
6178: LIST
6179: LIST
6180: LIST
6181: LIST
6182: PUSH
6183: LD_OWVAR 67
6187: ARRAY
6188: PUSH
6189: EMPTY
6190: LIST
6191: LIST
6192: LIST
6193: LIST
6194: PUSH
6195: LD_INT 13
6197: PUSH
6198: LD_INT 1
6200: PUSH
6201: LD_INT 2
6203: PUSH
6204: LD_INT 26
6206: PUSH
6207: LD_INT 29
6209: PUSH
6210: LD_INT 29
6212: PUSH
6213: LD_INT 29
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: LIST
6220: LIST
6221: PUSH
6222: LD_OWVAR 67
6226: ARRAY
6227: PUSH
6228: EMPTY
6229: LIST
6230: LIST
6231: LIST
6232: LIST
6233: PUSH
6234: LD_INT 13
6236: PUSH
6237: LD_INT 1
6239: PUSH
6240: LD_INT 2
6242: PUSH
6243: LD_INT 29
6245: PUSH
6246: EMPTY
6247: LIST
6248: LIST
6249: LIST
6250: LIST
6251: PUSH
6252: LD_INT 14
6254: PUSH
6255: LD_INT 1
6257: PUSH
6258: LD_INT 2
6260: PUSH
6261: LD_INT 26
6263: PUSH
6264: EMPTY
6265: LIST
6266: LIST
6267: LIST
6268: LIST
6269: PUSH
6270: EMPTY
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: LIST
6276: LIST
6277: PPUSH
6278: CALL 63018 0 2
// end ; wait ( 2 2$00 ) ;
6282: LD_INT 4200
6284: PPUSH
6285: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) diff mc_defender [ 3 ] ;
6289: LD_ADDR_VAR 0 2
6293: PUSH
6294: LD_INT 22
6296: PUSH
6297: LD_INT 8
6299: PUSH
6300: EMPTY
6301: LIST
6302: LIST
6303: PUSH
6304: LD_INT 21
6306: PUSH
6307: LD_INT 2
6309: PUSH
6310: EMPTY
6311: LIST
6312: LIST
6313: PUSH
6314: LD_INT 3
6316: PUSH
6317: LD_INT 34
6319: PUSH
6320: LD_INT 31
6322: PUSH
6323: EMPTY
6324: LIST
6325: LIST
6326: PUSH
6327: LD_INT 34
6329: PUSH
6330: LD_INT 32
6332: PUSH
6333: EMPTY
6334: LIST
6335: LIST
6336: PUSH
6337: LD_INT 34
6339: PUSH
6340: LD_INT 88
6342: PUSH
6343: EMPTY
6344: LIST
6345: LIST
6346: PUSH
6347: EMPTY
6348: LIST
6349: LIST
6350: LIST
6351: LIST
6352: PUSH
6353: EMPTY
6354: LIST
6355: LIST
6356: LIST
6357: PPUSH
6358: CALL_OW 69
6362: PUSH
6363: LD_EXP 123
6367: PUSH
6368: LD_INT 3
6370: ARRAY
6371: DIFF
6372: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6373: LD_ADDR_EXP 120
6377: PUSH
6378: LD_EXP 120
6382: PPUSH
6383: LD_INT 3
6385: PPUSH
6386: LD_EXP 120
6390: PUSH
6391: LD_INT 3
6393: ARRAY
6394: PUSH
6395: LD_VAR 0 2
6399: DIFF
6400: PPUSH
6401: CALL_OW 1
6405: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6406: LD_ADDR_VAR 0 3
6410: PUSH
6411: LD_INT 0
6413: PPUSH
6414: LD_INT 2
6416: PPUSH
6417: CALL_OW 12
6421: ST_TO_ADDR
// if target then
6422: LD_VAR 0 3
6426: IFFALSE 6588
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6428: LD_ADDR_VAR 0 2
6432: PUSH
6433: LD_VAR 0 2
6437: PPUSH
6438: LD_INT 24
6440: PUSH
6441: LD_INT 250
6443: PUSH
6444: EMPTY
6445: LIST
6446: LIST
6447: PPUSH
6448: CALL_OW 72
6452: ST_TO_ADDR
// if not tmp then
6453: LD_VAR 0 2
6457: NOT
6458: IFFALSE 6462
// break ;
6460: GO 6586
// for i in tmp do
6462: LD_ADDR_VAR 0 1
6466: PUSH
6467: LD_VAR 0 2
6471: PUSH
6472: FOR_IN
6473: IFFALSE 6513
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6475: LD_VAR 0 1
6479: PPUSH
6480: LD_INT 89
6482: PPUSH
6483: LD_INT 71
6485: PPUSH
6486: CALL_OW 297
6490: PUSH
6491: LD_INT 9
6493: GREATER
6494: IFFALSE 6511
// ComMoveXY ( i , 89 , 71 ) ;
6496: LD_VAR 0 1
6500: PPUSH
6501: LD_INT 89
6503: PPUSH
6504: LD_INT 71
6506: PPUSH
6507: CALL_OW 111
6511: GO 6472
6513: POP
6514: POP
// wait ( 0 0$1 ) ;
6515: LD_INT 35
6517: PPUSH
6518: CALL_OW 67
// p := Inc ( p ) ;
6522: LD_ADDR_VAR 0 4
6526: PUSH
6527: LD_VAR 0 4
6531: PPUSH
6532: CALL 108496 0 1
6536: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6537: LD_VAR 0 2
6541: PPUSH
6542: LD_INT 92
6544: PUSH
6545: LD_INT 89
6547: PUSH
6548: LD_INT 71
6550: PUSH
6551: LD_INT 9
6553: PUSH
6554: EMPTY
6555: LIST
6556: LIST
6557: LIST
6558: LIST
6559: PPUSH
6560: CALL_OW 72
6564: PUSH
6565: LD_VAR 0 2
6569: PUSH
6570: LD_INT 1
6572: MINUS
6573: GREATEREQUAL
6574: PUSH
6575: LD_VAR 0 4
6579: PUSH
6580: LD_INT 30
6582: GREATER
6583: OR
6584: IFFALSE 6428
// end else
6586: GO 6746
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6588: LD_ADDR_VAR 0 2
6592: PUSH
6593: LD_VAR 0 2
6597: PPUSH
6598: LD_INT 24
6600: PUSH
6601: LD_INT 250
6603: PUSH
6604: EMPTY
6605: LIST
6606: LIST
6607: PPUSH
6608: CALL_OW 72
6612: ST_TO_ADDR
// if not tmp then
6613: LD_VAR 0 2
6617: NOT
6618: IFFALSE 6622
// break ;
6620: GO 6746
// for i in tmp do
6622: LD_ADDR_VAR 0 1
6626: PUSH
6627: LD_VAR 0 2
6631: PUSH
6632: FOR_IN
6633: IFFALSE 6673
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6635: LD_VAR 0 1
6639: PPUSH
6640: LD_INT 125
6642: PPUSH
6643: LD_INT 129
6645: PPUSH
6646: CALL_OW 297
6650: PUSH
6651: LD_INT 9
6653: GREATER
6654: IFFALSE 6671
// ComMoveXY ( i , 125 , 129 ) ;
6656: LD_VAR 0 1
6660: PPUSH
6661: LD_INT 125
6663: PPUSH
6664: LD_INT 129
6666: PPUSH
6667: CALL_OW 111
6671: GO 6632
6673: POP
6674: POP
// wait ( 0 0$1 ) ;
6675: LD_INT 35
6677: PPUSH
6678: CALL_OW 67
// p := Inc ( p ) ;
6682: LD_ADDR_VAR 0 4
6686: PUSH
6687: LD_VAR 0 4
6691: PPUSH
6692: CALL 108496 0 1
6696: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6697: LD_VAR 0 2
6701: PPUSH
6702: LD_INT 92
6704: PUSH
6705: LD_INT 125
6707: PUSH
6708: LD_INT 129
6710: PUSH
6711: LD_INT 9
6713: PUSH
6714: EMPTY
6715: LIST
6716: LIST
6717: LIST
6718: LIST
6719: PPUSH
6720: CALL_OW 72
6724: PUSH
6725: LD_VAR 0 2
6729: PUSH
6730: LD_INT 1
6732: MINUS
6733: GREATEREQUAL
6734: PUSH
6735: LD_VAR 0 4
6739: PUSH
6740: LD_INT 30
6742: GREATER
6743: OR
6744: IFFALSE 6588
// end ; repeat wait ( 0 0$1 ) ;
6746: LD_INT 35
6748: PPUSH
6749: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6753: LD_ADDR_VAR 0 2
6757: PUSH
6758: LD_VAR 0 2
6762: PPUSH
6763: LD_INT 50
6765: PUSH
6766: EMPTY
6767: LIST
6768: PPUSH
6769: CALL_OW 72
6773: ST_TO_ADDR
// for i in tmp do
6774: LD_ADDR_VAR 0 1
6778: PUSH
6779: LD_VAR 0 2
6783: PUSH
6784: FOR_IN
6785: IFFALSE 6823
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6787: LD_VAR 0 1
6791: PPUSH
6792: LD_INT 81
6794: PUSH
6795: LD_INT 8
6797: PUSH
6798: EMPTY
6799: LIST
6800: LIST
6801: PPUSH
6802: CALL_OW 69
6806: PPUSH
6807: LD_VAR 0 1
6811: PPUSH
6812: CALL_OW 74
6816: PPUSH
6817: CALL_OW 115
6821: GO 6784
6823: POP
6824: POP
// until not tmp ;
6825: LD_VAR 0 2
6829: NOT
6830: IFFALSE 6746
// end ;
6832: PPOPN 4
6834: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6835: LD_EXP 22
6839: NOT
6840: PUSH
6841: LD_EXP 15
6845: PUSH
6846: LD_INT 6
6848: GREATEREQUAL
6849: AND
6850: PUSH
6851: LD_OWVAR 67
6855: PUSH
6856: LD_INT 1
6858: GREATER
6859: AND
6860: IFFALSE 7393
6862: GO 6864
6864: DISABLE
6865: LD_INT 0
6867: PPUSH
6868: PPUSH
6869: PPUSH
// begin enable ;
6870: ENABLE
// tmp := [ ] ;
6871: LD_ADDR_VAR 0 3
6875: PUSH
6876: EMPTY
6877: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6878: LD_ADDR_VAR 0 1
6882: PUSH
6883: DOUBLE
6884: LD_INT 1
6886: DEC
6887: ST_TO_ADDR
6888: LD_INT 4
6890: PUSH
6891: LD_INT 6
6893: PUSH
6894: LD_INT 7
6896: PUSH
6897: LD_INT 8
6899: PUSH
6900: EMPTY
6901: LIST
6902: LIST
6903: LIST
6904: LIST
6905: PUSH
6906: LD_OWVAR 67
6910: ARRAY
6911: PUSH
6912: FOR_TO
6913: IFFALSE 7073
// begin uc_side := 8 ;
6915: LD_ADDR_OWVAR 20
6919: PUSH
6920: LD_INT 8
6922: ST_TO_ADDR
// uc_nation := 2 ;
6923: LD_ADDR_OWVAR 21
6927: PUSH
6928: LD_INT 2
6930: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6931: LD_INT 13
6933: PUSH
6934: LD_INT 14
6936: PUSH
6937: EMPTY
6938: LIST
6939: LIST
6940: PUSH
6941: LD_INT 1
6943: PPUSH
6944: LD_INT 2
6946: PPUSH
6947: CALL_OW 12
6951: ARRAY
6952: PPUSH
6953: LD_INT 1
6955: PPUSH
6956: LD_INT 5
6958: PPUSH
6959: LD_INT 27
6961: PUSH
6962: LD_INT 28
6964: PUSH
6965: LD_INT 26
6967: PUSH
6968: LD_INT 25
6970: PUSH
6971: EMPTY
6972: LIST
6973: LIST
6974: LIST
6975: LIST
6976: PUSH
6977: LD_INT 1
6979: PPUSH
6980: LD_INT 4
6982: PPUSH
6983: CALL_OW 12
6987: ARRAY
6988: PPUSH
6989: LD_INT 88
6991: PPUSH
6992: CALL 74284 0 5
// un := CreateVehicle ;
6996: LD_ADDR_VAR 0 2
7000: PUSH
7001: CALL_OW 45
7005: ST_TO_ADDR
// tmp := tmp ^ un ;
7006: LD_ADDR_VAR 0 3
7010: PUSH
7011: LD_VAR 0 3
7015: PUSH
7016: LD_VAR 0 2
7020: ADD
7021: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7022: LD_VAR 0 2
7026: PPUSH
7027: LD_INT 3
7029: PPUSH
7030: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7034: LD_VAR 0 2
7038: PPUSH
7039: LD_INT 30
7041: PPUSH
7042: LD_INT 0
7044: PPUSH
7045: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7049: LD_VAR 0 2
7053: PPUSH
7054: LD_INT 16
7056: PPUSH
7057: LD_INT 11
7059: PPUSH
7060: CALL_OW 111
// wait ( 0 0$2 ) ;
7064: LD_INT 70
7066: PPUSH
7067: CALL_OW 67
// end ;
7071: GO 6912
7073: POP
7074: POP
// for i = 1 to Difficulty do
7075: LD_ADDR_VAR 0 1
7079: PUSH
7080: DOUBLE
7081: LD_INT 1
7083: DEC
7084: ST_TO_ADDR
7085: LD_OWVAR 67
7089: PUSH
7090: FOR_TO
7091: IFFALSE 7220
// begin uc_side := 8 ;
7093: LD_ADDR_OWVAR 20
7097: PUSH
7098: LD_INT 8
7100: ST_TO_ADDR
// uc_nation := 2 ;
7101: LD_ADDR_OWVAR 21
7105: PUSH
7106: LD_INT 2
7108: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
7109: LD_INT 0
7111: PPUSH
7112: LD_INT 8
7114: PPUSH
7115: LD_INT 8
7117: PUSH
7118: LD_INT 8
7120: PUSH
7121: LD_INT 9
7123: PUSH
7124: LD_INT 10
7126: PUSH
7127: EMPTY
7128: LIST
7129: LIST
7130: LIST
7131: LIST
7132: PUSH
7133: LD_OWVAR 67
7137: ARRAY
7138: PPUSH
7139: CALL_OW 380
// un := CreateHuman ;
7143: LD_ADDR_VAR 0 2
7147: PUSH
7148: CALL_OW 44
7152: ST_TO_ADDR
// tmp := tmp ^ un ;
7153: LD_ADDR_VAR 0 3
7157: PUSH
7158: LD_VAR 0 3
7162: PUSH
7163: LD_VAR 0 2
7167: ADD
7168: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7169: LD_VAR 0 2
7173: PPUSH
7174: LD_INT 3
7176: PPUSH
7177: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7181: LD_VAR 0 2
7185: PPUSH
7186: LD_INT 30
7188: PPUSH
7189: LD_INT 0
7191: PPUSH
7192: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7196: LD_VAR 0 2
7200: PPUSH
7201: LD_INT 16
7203: PPUSH
7204: LD_INT 11
7206: PPUSH
7207: CALL_OW 111
// wait ( 0 0$2 ) ;
7211: LD_INT 70
7213: PPUSH
7214: CALL_OW 67
// end ;
7218: GO 7090
7220: POP
7221: POP
// repeat wait ( 0 0$1 ) ;
7222: LD_INT 35
7224: PPUSH
7225: CALL_OW 67
// if legionDestroyed then
7229: LD_EXP 22
7233: IFFALSE 7237
// exit ;
7235: GO 7393
// for i in tmp do
7237: LD_ADDR_VAR 0 1
7241: PUSH
7242: LD_VAR 0 3
7246: PUSH
7247: FOR_IN
7248: IFFALSE 7384
// begin if GetLives ( i ) > 250 then
7250: LD_VAR 0 1
7254: PPUSH
7255: CALL_OW 256
7259: PUSH
7260: LD_INT 250
7262: GREATER
7263: IFFALSE 7355
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
7265: LD_INT 81
7267: PUSH
7268: LD_INT 8
7270: PUSH
7271: EMPTY
7272: LIST
7273: LIST
7274: PUSH
7275: LD_INT 91
7277: PUSH
7278: LD_VAR 0 1
7282: PUSH
7283: LD_INT 10
7285: PUSH
7286: EMPTY
7287: LIST
7288: LIST
7289: LIST
7290: PUSH
7291: EMPTY
7292: LIST
7293: LIST
7294: PPUSH
7295: CALL_OW 69
7299: NOT
7300: IFFALSE 7319
// ComAgressiveMove ( i , 67 , 110 ) else
7302: LD_VAR 0 1
7306: PPUSH
7307: LD_INT 67
7309: PPUSH
7310: LD_INT 110
7312: PPUSH
7313: CALL_OW 114
7317: GO 7353
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7319: LD_VAR 0 1
7323: PPUSH
7324: LD_INT 81
7326: PUSH
7327: LD_INT 8
7329: PUSH
7330: EMPTY
7331: LIST
7332: LIST
7333: PPUSH
7334: CALL_OW 69
7338: PPUSH
7339: LD_VAR 0 1
7343: PPUSH
7344: CALL_OW 74
7348: PPUSH
7349: CALL_OW 115
// end else
7353: GO 7382
// if IsDead ( i ) then
7355: LD_VAR 0 1
7359: PPUSH
7360: CALL_OW 301
7364: IFFALSE 7382
// tmp := tmp diff i ;
7366: LD_ADDR_VAR 0 3
7370: PUSH
7371: LD_VAR 0 3
7375: PUSH
7376: LD_VAR 0 1
7380: DIFF
7381: ST_TO_ADDR
// end ;
7382: GO 7247
7384: POP
7385: POP
// until not tmp ;
7386: LD_VAR 0 3
7390: NOT
7391: IFFALSE 7222
// end ; end_of_file
7393: PPOPN 3
7395: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
7396: LD_INT 0
7398: PPUSH
7399: PPUSH
7400: PPUSH
7401: PPUSH
7402: PPUSH
7403: PPUSH
7404: PPUSH
7405: PPUSH
7406: PPUSH
7407: PPUSH
// side := 3 ;
7408: LD_ADDR_VAR 0 6
7412: PUSH
7413: LD_INT 3
7415: ST_TO_ADDR
// uc_side := side ;
7416: LD_ADDR_OWVAR 20
7420: PUSH
7421: LD_VAR 0 6
7425: ST_TO_ADDR
// uc_nation := 3 ;
7426: LD_ADDR_OWVAR 21
7430: PUSH
7431: LD_INT 3
7433: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7434: LD_ADDR_VAR 0 2
7438: PUSH
7439: LD_INT 22
7441: PUSH
7442: LD_VAR 0 6
7446: PUSH
7447: EMPTY
7448: LIST
7449: LIST
7450: PUSH
7451: LD_INT 21
7453: PUSH
7454: LD_INT 3
7456: PUSH
7457: EMPTY
7458: LIST
7459: LIST
7460: PUSH
7461: EMPTY
7462: LIST
7463: LIST
7464: PPUSH
7465: CALL_OW 69
7469: PUSH
7470: FOR_IN
7471: IFFALSE 7487
// SetBLevel ( i , 10 ) ;
7473: LD_VAR 0 2
7477: PPUSH
7478: LD_INT 10
7480: PPUSH
7481: CALL_OW 241
7485: GO 7470
7487: POP
7488: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7489: LD_ADDR_VAR 0 10
7493: PUSH
7494: LD_INT 22
7496: PUSH
7497: LD_VAR 0 6
7501: PUSH
7502: EMPTY
7503: LIST
7504: LIST
7505: PUSH
7506: LD_INT 30
7508: PUSH
7509: LD_INT 34
7511: PUSH
7512: EMPTY
7513: LIST
7514: LIST
7515: PUSH
7516: EMPTY
7517: LIST
7518: LIST
7519: PPUSH
7520: CALL_OW 69
7524: ST_TO_ADDR
// if teleport then
7525: LD_VAR 0 10
7529: IFFALSE 7550
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7531: LD_VAR 0 10
7535: PUSH
7536: LD_INT 1
7538: ARRAY
7539: PPUSH
7540: LD_INT 123
7542: PPUSH
7543: LD_INT 122
7545: PPUSH
7546: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7550: LD_ADDR_EXP 67
7554: PUSH
7555: LD_STRING Platonov
7557: PPUSH
7558: CALL_OW 25
7562: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7563: LD_ADDR_EXP 68
7567: PUSH
7568: LD_STRING Kovalyuk
7570: PPUSH
7571: CALL_OW 25
7575: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7576: LD_ADDR_EXP 70
7580: PUSH
7581: LD_STRING Yakotich
7583: PPUSH
7584: LD_EXP 1
7588: NOT
7589: PPUSH
7590: LD_STRING 09_
7592: PPUSH
7593: CALL 69444 0 3
7597: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7598: LD_ADDR_EXP 69
7602: PUSH
7603: LD_STRING Bystrov
7605: PPUSH
7606: CALL_OW 25
7610: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7611: LD_ADDR_EXP 71
7615: PUSH
7616: LD_STRING Gleb
7618: PPUSH
7619: CALL_OW 25
7623: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7624: LD_STRING 03_Cornel
7626: PPUSH
7627: CALL_OW 28
7631: IFFALSE 7679
// begin Bierezov := NewCharacter ( Mikhail ) ;
7633: LD_ADDR_EXP 72
7637: PUSH
7638: LD_STRING Mikhail
7640: PPUSH
7641: CALL_OW 25
7645: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7646: LD_EXP 72
7650: PPUSH
7651: LD_INT 197
7653: PPUSH
7654: LD_INT 111
7656: PPUSH
7657: LD_INT 9
7659: PPUSH
7660: LD_INT 0
7662: PPUSH
7663: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7667: LD_EXP 72
7671: PPUSH
7672: LD_INT 3
7674: PPUSH
7675: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7679: LD_EXP 67
7683: PPUSH
7684: LD_INT 126
7686: PPUSH
7687: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7691: LD_EXP 68
7695: PPUSH
7696: LD_INT 134
7698: PPUSH
7699: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7703: LD_EXP 70
7707: PPUSH
7708: LD_INT 197
7710: PPUSH
7711: LD_INT 111
7713: PPUSH
7714: LD_INT 9
7716: PPUSH
7717: LD_INT 0
7719: PPUSH
7720: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7724: LD_EXP 69
7728: PPUSH
7729: LD_INT 197
7731: PPUSH
7732: LD_INT 111
7734: PPUSH
7735: LD_INT 9
7737: PPUSH
7738: LD_INT 0
7740: PPUSH
7741: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7745: LD_EXP 71
7749: PPUSH
7750: LD_INT 197
7752: PPUSH
7753: LD_INT 111
7755: PPUSH
7756: LD_INT 9
7758: PPUSH
7759: LD_INT 0
7761: PPUSH
7762: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 12 , 6 ] ) ;
7766: LD_ADDR_VAR 0 5
7770: PUSH
7771: LD_INT 126
7773: PPUSH
7774: LD_INT 4
7776: PPUSH
7777: LD_STRING zhukov
7779: PPUSH
7780: LD_INT 9
7782: PUSH
7783: LD_INT 10
7785: PUSH
7786: LD_INT 10
7788: PUSH
7789: LD_INT 10
7791: PUSH
7792: EMPTY
7793: LIST
7794: LIST
7795: LIST
7796: LIST
7797: PUSH
7798: LD_OWVAR 67
7802: ARRAY
7803: PPUSH
7804: LD_INT 90000
7806: PUSH
7807: LD_INT 1000
7809: PUSH
7810: LD_INT 300
7812: PUSH
7813: EMPTY
7814: LIST
7815: LIST
7816: LIST
7817: PPUSH
7818: LD_INT 18
7820: PUSH
7821: LD_INT 8
7823: PUSH
7824: LD_INT 12
7826: PUSH
7827: LD_INT 6
7829: PUSH
7830: EMPTY
7831: LIST
7832: LIST
7833: LIST
7834: LIST
7835: PPUSH
7836: CALL 78105 0 6
7840: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Bystrov , Gleb , Bierezov ] ) ;
7841: LD_ADDR_EXP 101
7845: PUSH
7846: LD_EXP 101
7850: PPUSH
7851: LD_INT 2
7853: PPUSH
7854: LD_VAR 0 5
7858: PUSH
7859: LD_EXP 70
7863: PUSH
7864: LD_EXP 69
7868: PUSH
7869: LD_EXP 71
7873: PUSH
7874: LD_EXP 72
7878: PUSH
7879: EMPTY
7880: LIST
7881: LIST
7882: LIST
7883: LIST
7884: UNION
7885: PPUSH
7886: CALL_OW 1
7890: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7891: LD_ADDR_VAR 0 4
7895: PUSH
7896: LD_INT 267
7898: PPUSH
7899: CALL_OW 274
7903: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7904: LD_VAR 0 4
7908: PPUSH
7909: LD_INT 1
7911: PPUSH
7912: LD_INT 5000
7914: PPUSH
7915: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7919: LD_VAR 0 4
7923: PPUSH
7924: LD_INT 2
7926: PPUSH
7927: LD_INT 200
7929: PPUSH
7930: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7934: LD_VAR 0 4
7938: PPUSH
7939: LD_INT 3
7941: PPUSH
7942: LD_INT 200
7944: PPUSH
7945: CALL_OW 277
// for i := 1 to 6 do
7949: LD_ADDR_VAR 0 2
7953: PUSH
7954: DOUBLE
7955: LD_INT 1
7957: DEC
7958: ST_TO_ADDR
7959: LD_INT 6
7961: PUSH
7962: FOR_TO
7963: IFFALSE 8046
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
7965: LD_INT 0
7967: PPUSH
7968: LD_INT 8
7970: PUSH
7971: LD_INT 9
7973: PUSH
7974: LD_INT 10
7976: PUSH
7977: LD_INT 10
7979: PUSH
7980: EMPTY
7981: LIST
7982: LIST
7983: LIST
7984: LIST
7985: PUSH
7986: LD_OWVAR 67
7990: ARRAY
7991: PPUSH
7992: CALL_OW 381
// un := CreateHuman ;
7996: LD_ADDR_VAR 0 8
8000: PUSH
8001: CALL_OW 44
8005: ST_TO_ADDR
// if i mod 2 = 0 then
8006: LD_VAR 0 2
8010: PUSH
8011: LD_INT 2
8013: MOD
8014: PUSH
8015: LD_INT 0
8017: EQUAL
8018: IFFALSE 8032
// SetClass ( un , class_bazooker ) ;
8020: LD_VAR 0 8
8024: PPUSH
8025: LD_INT 9
8027: PPUSH
8028: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
8032: LD_VAR 0 8
8036: PPUSH
8037: LD_INT 460
8039: PPUSH
8040: CALL_OW 52
// end ;
8044: GO 7962
8046: POP
8047: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
8048: LD_INT 21
8050: PPUSH
8051: LD_INT 3
8053: PPUSH
8054: LD_INT 3
8056: PPUSH
8057: LD_INT 52
8059: PPUSH
8060: LD_INT 100
8062: PPUSH
8063: CALL 74284 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
8067: CALL_OW 45
8071: PPUSH
8072: LD_INT 259
8074: PPUSH
8075: LD_INT 145
8077: PPUSH
8078: LD_INT 3
8080: PPUSH
8081: LD_INT 0
8083: PPUSH
8084: CALL 109275 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
8088: CALL_OW 45
8092: PPUSH
8093: LD_INT 245
8095: PPUSH
8096: LD_INT 139
8098: PPUSH
8099: LD_INT 3
8101: PPUSH
8102: LD_INT 0
8104: PPUSH
8105: CALL 109275 0 5
// behemoths := [ ] ;
8109: LD_ADDR_EXP 75
8113: PUSH
8114: EMPTY
8115: ST_TO_ADDR
// behemothBuilders := [ ] ;
8116: LD_ADDR_EXP 76
8120: PUSH
8121: EMPTY
8122: ST_TO_ADDR
// if Kovalyuk then
8123: LD_EXP 68
8127: IFFALSE 8149
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
8129: LD_ADDR_EXP 76
8133: PUSH
8134: LD_EXP 76
8138: PPUSH
8139: LD_EXP 68
8143: PPUSH
8144: CALL 107135 0 2
8148: ST_TO_ADDR
// j := 3 ;
8149: LD_ADDR_VAR 0 3
8153: PUSH
8154: LD_INT 3
8156: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
8157: LD_ADDR_VAR 0 2
8161: PUSH
8162: LD_INT 22
8164: PUSH
8165: LD_INT 3
8167: PUSH
8168: EMPTY
8169: LIST
8170: LIST
8171: PUSH
8172: LD_INT 25
8174: PUSH
8175: LD_INT 3
8177: PUSH
8178: EMPTY
8179: LIST
8180: LIST
8181: PUSH
8182: EMPTY
8183: LIST
8184: LIST
8185: PPUSH
8186: CALL_OW 69
8190: PUSH
8191: LD_EXP 68
8195: DIFF
8196: PUSH
8197: FOR_IN
8198: IFFALSE 8248
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8200: LD_ADDR_EXP 76
8204: PUSH
8205: LD_EXP 76
8209: PPUSH
8210: LD_VAR 0 2
8214: PPUSH
8215: CALL 107135 0 2
8219: ST_TO_ADDR
// j := j - 1 ;
8220: LD_ADDR_VAR 0 3
8224: PUSH
8225: LD_VAR 0 3
8229: PUSH
8230: LD_INT 1
8232: MINUS
8233: ST_TO_ADDR
// if j = 0 then
8234: LD_VAR 0 3
8238: PUSH
8239: LD_INT 0
8241: EQUAL
8242: IFFALSE 8246
// break ;
8244: GO 8248
// end ;
8246: GO 8197
8248: POP
8249: POP
// end ;
8250: LD_VAR 0 1
8254: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8255: LD_INT 0
8257: PPUSH
8258: PPUSH
8259: PPUSH
8260: PPUSH
8261: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8262: LD_ADDR_VAR 0 4
8266: PUSH
8267: LD_INT 209
8269: PUSH
8270: LD_INT 149
8272: PUSH
8273: EMPTY
8274: LIST
8275: LIST
8276: PUSH
8277: LD_INT 219
8279: PUSH
8280: LD_INT 154
8282: PUSH
8283: EMPTY
8284: LIST
8285: LIST
8286: PUSH
8287: LD_INT 223
8289: PUSH
8290: LD_INT 149
8292: PUSH
8293: EMPTY
8294: LIST
8295: LIST
8296: PUSH
8297: LD_INT 232
8299: PUSH
8300: LD_INT 155
8302: PUSH
8303: EMPTY
8304: LIST
8305: LIST
8306: PUSH
8307: EMPTY
8308: LIST
8309: LIST
8310: LIST
8311: LIST
8312: ST_TO_ADDR
// if not behemothBuilders then
8313: LD_EXP 76
8317: NOT
8318: IFFALSE 8322
// exit ;
8320: GO 8453
// j := 1 ;
8322: LD_ADDR_VAR 0 3
8326: PUSH
8327: LD_INT 1
8329: ST_TO_ADDR
// for i in behemothBuilders do
8330: LD_ADDR_VAR 0 2
8334: PUSH
8335: LD_EXP 76
8339: PUSH
8340: FOR_IN
8341: IFFALSE 8451
// begin if GetClass ( i ) <> class_mechanic then
8343: LD_VAR 0 2
8347: PPUSH
8348: CALL_OW 257
8352: PUSH
8353: LD_INT 3
8355: NONEQUAL
8356: IFFALSE 8370
// SetClass ( i , class_mechanic ) ;
8358: LD_VAR 0 2
8362: PPUSH
8363: LD_INT 3
8365: PPUSH
8366: CALL_OW 336
// if IsInUnit ( i ) then
8370: LD_VAR 0 2
8374: PPUSH
8375: CALL_OW 310
8379: IFFALSE 8390
// ComExitBuilding ( i ) ;
8381: LD_VAR 0 2
8385: PPUSH
8386: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8390: LD_VAR 0 2
8394: PPUSH
8395: LD_INT 37
8397: PPUSH
8398: LD_VAR 0 4
8402: PUSH
8403: LD_VAR 0 3
8407: ARRAY
8408: PUSH
8409: LD_INT 1
8411: ARRAY
8412: PPUSH
8413: LD_VAR 0 4
8417: PUSH
8418: LD_VAR 0 3
8422: ARRAY
8423: PUSH
8424: LD_INT 2
8426: ARRAY
8427: PPUSH
8428: LD_INT 0
8430: PPUSH
8431: CALL_OW 230
// j := j + 1 ;
8435: LD_ADDR_VAR 0 3
8439: PUSH
8440: LD_VAR 0 3
8444: PUSH
8445: LD_INT 1
8447: PLUS
8448: ST_TO_ADDR
// end ;
8449: GO 8340
8451: POP
8452: POP
// end ;
8453: LD_VAR 0 1
8457: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
8458: LD_INT 24
8460: PPUSH
8461: LD_INT 30
8463: PUSH
8464: LD_INT 37
8466: PUSH
8467: EMPTY
8468: LIST
8469: LIST
8470: PPUSH
8471: CALL_OW 70
8475: IFFALSE 8488
8477: GO 8479
8479: DISABLE
// behemothUnderConstruct := true ;
8480: LD_ADDR_EXP 26
8484: PUSH
8485: LD_INT 1
8487: ST_TO_ADDR
8488: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8489: LD_INT 3
8491: PPUSH
8492: CALL 107196 0 1
8496: PUSH
8497: LD_INT 22
8499: PUSH
8500: LD_INT 3
8502: PUSH
8503: EMPTY
8504: LIST
8505: LIST
8506: PUSH
8507: LD_INT 30
8509: PUSH
8510: LD_INT 37
8512: PUSH
8513: EMPTY
8514: LIST
8515: LIST
8516: PUSH
8517: EMPTY
8518: LIST
8519: LIST
8520: PPUSH
8521: CALL_OW 69
8525: NOT
8526: AND
8527: IFFALSE 8713
8529: GO 8531
8531: DISABLE
8532: LD_INT 0
8534: PPUSH
8535: PPUSH
// begin enable ;
8536: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8537: LD_ADDR_VAR 0 2
8541: PUSH
8542: LD_INT 3
8544: PPUSH
8545: CALL 107196 0 1
8549: ST_TO_ADDR
// for i in tmp do
8550: LD_ADDR_VAR 0 1
8554: PUSH
8555: LD_VAR 0 2
8559: PUSH
8560: FOR_IN
8561: IFFALSE 8711
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8563: LD_VAR 0 1
8567: PPUSH
8568: LD_INT 9
8570: PPUSH
8571: CALL_OW 308
8575: PUSH
8576: LD_VAR 0 1
8580: PPUSH
8581: CALL_OW 110
8585: PUSH
8586: LD_INT 2
8588: EQUAL
8589: NOT
8590: AND
8591: IFFALSE 8605
// SetTag ( i , 2 ) ;
8593: LD_VAR 0 1
8597: PPUSH
8598: LD_INT 2
8600: PPUSH
8601: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8605: LD_INT 81
8607: PUSH
8608: LD_INT 3
8610: PUSH
8611: EMPTY
8612: LIST
8613: LIST
8614: PUSH
8615: LD_INT 91
8617: PUSH
8618: LD_VAR 0 1
8622: PUSH
8623: LD_INT 12
8625: PUSH
8626: EMPTY
8627: LIST
8628: LIST
8629: LIST
8630: PUSH
8631: EMPTY
8632: LIST
8633: LIST
8634: PPUSH
8635: CALL_OW 69
8639: NOT
8640: PUSH
8641: LD_VAR 0 1
8645: PPUSH
8646: CALL_OW 110
8650: PUSH
8651: LD_INT 2
8653: EQUAL
8654: NOT
8655: AND
8656: IFFALSE 8675
// ComAgressiveMove ( i , 64 , 93 ) else
8658: LD_VAR 0 1
8662: PPUSH
8663: LD_INT 64
8665: PPUSH
8666: LD_INT 93
8668: PPUSH
8669: CALL_OW 114
8673: GO 8709
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8675: LD_VAR 0 1
8679: PPUSH
8680: LD_INT 81
8682: PUSH
8683: LD_INT 3
8685: PUSH
8686: EMPTY
8687: LIST
8688: LIST
8689: PPUSH
8690: CALL_OW 69
8694: PPUSH
8695: LD_VAR 0 1
8699: PPUSH
8700: CALL_OW 74
8704: PPUSH
8705: CALL_OW 115
// end ;
8709: GO 8560
8711: POP
8712: POP
// end ;
8713: PPOPN 2
8715: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8716: LD_INT 0
8718: PPUSH
8719: PPUSH
8720: PPUSH
// result := [ ] ;
8721: LD_ADDR_VAR 0 2
8725: PUSH
8726: EMPTY
8727: ST_TO_ADDR
// uc_side := 6 ;
8728: LD_ADDR_OWVAR 20
8732: PUSH
8733: LD_INT 6
8735: ST_TO_ADDR
// uc_nation := 3 ;
8736: LD_ADDR_OWVAR 21
8740: PUSH
8741: LD_INT 3
8743: ST_TO_ADDR
// case strength of 1 :
8744: LD_VAR 0 1
8748: PUSH
8749: LD_INT 1
8751: DOUBLE
8752: EQUAL
8753: IFTRUE 8757
8755: GO 8899
8757: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8758: LD_ADDR_VAR 0 3
8762: PUSH
8763: DOUBLE
8764: LD_INT 1
8766: DEC
8767: ST_TO_ADDR
8768: LD_INT 4
8770: PUSH
8771: LD_INT 5
8773: PUSH
8774: LD_INT 6
8776: PUSH
8777: LD_INT 7
8779: PUSH
8780: EMPTY
8781: LIST
8782: LIST
8783: LIST
8784: LIST
8785: PUSH
8786: LD_OWVAR 67
8790: ARRAY
8791: PUSH
8792: FOR_TO
8793: IFFALSE 8895
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8795: LD_INT 22
8797: PUSH
8798: LD_INT 24
8800: PUSH
8801: EMPTY
8802: LIST
8803: LIST
8804: PUSH
8805: LD_VAR 0 3
8809: PUSH
8810: LD_INT 2
8812: MOD
8813: PUSH
8814: LD_INT 1
8816: PLUS
8817: ARRAY
8818: PPUSH
8819: LD_INT 1
8821: PUSH
8822: LD_INT 3
8824: PUSH
8825: EMPTY
8826: LIST
8827: LIST
8828: PUSH
8829: LD_INT 1
8831: PPUSH
8832: LD_INT 2
8834: PPUSH
8835: CALL_OW 12
8839: ARRAY
8840: PPUSH
8841: LD_INT 3
8843: PPUSH
8844: LD_INT 43
8846: PUSH
8847: LD_INT 44
8849: PUSH
8850: LD_INT 45
8852: PUSH
8853: EMPTY
8854: LIST
8855: LIST
8856: LIST
8857: PUSH
8858: LD_INT 1
8860: PPUSH
8861: LD_INT 3
8863: PPUSH
8864: CALL_OW 12
8868: ARRAY
8869: PPUSH
8870: LD_INT 80
8872: PPUSH
8873: CALL 74284 0 5
// result := result union CreateVehicle ;
8877: LD_ADDR_VAR 0 2
8881: PUSH
8882: LD_VAR 0 2
8886: PUSH
8887: CALL_OW 45
8891: UNION
8892: ST_TO_ADDR
// end ;
8893: GO 8792
8895: POP
8896: POP
// end ; 2 :
8897: GO 9894
8899: LD_INT 2
8901: DOUBLE
8902: EQUAL
8903: IFTRUE 8907
8905: GO 9075
8907: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8908: LD_ADDR_VAR 0 3
8912: PUSH
8913: DOUBLE
8914: LD_INT 1
8916: DEC
8917: ST_TO_ADDR
8918: LD_INT 5
8920: PUSH
8921: LD_INT 6
8923: PUSH
8924: LD_INT 7
8926: PUSH
8927: LD_INT 8
8929: PUSH
8930: EMPTY
8931: LIST
8932: LIST
8933: LIST
8934: LIST
8935: PUSH
8936: LD_OWVAR 67
8940: ARRAY
8941: PUSH
8942: FOR_TO
8943: IFFALSE 9071
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
8945: LD_INT 22
8947: PUSH
8948: LD_INT 24
8950: PUSH
8951: LD_INT 24
8953: PUSH
8954: EMPTY
8955: LIST
8956: LIST
8957: LIST
8958: PUSH
8959: LD_VAR 0 3
8963: PUSH
8964: LD_INT 3
8966: MOD
8967: PUSH
8968: LD_INT 1
8970: PLUS
8971: ARRAY
8972: PPUSH
8973: LD_INT 1
8975: PUSH
8976: LD_INT 3
8978: PUSH
8979: EMPTY
8980: LIST
8981: LIST
8982: PUSH
8983: LD_INT 1
8985: PPUSH
8986: LD_INT 2
8988: PPUSH
8989: CALL_OW 12
8993: ARRAY
8994: PPUSH
8995: LD_INT 3
8997: PPUSH
8998: LD_INT 43
9000: PUSH
9001: LD_INT 44
9003: PUSH
9004: LD_INT 45
9006: PUSH
9007: LD_INT 44
9009: PUSH
9010: LD_INT 46
9012: PUSH
9013: LD_INT 46
9015: PUSH
9016: LD_INT 49
9018: PUSH
9019: LD_INT 49
9021: PUSH
9022: EMPTY
9023: LIST
9024: LIST
9025: LIST
9026: LIST
9027: LIST
9028: LIST
9029: LIST
9030: LIST
9031: PUSH
9032: LD_VAR 0 3
9036: PUSH
9037: LD_INT 8
9039: MOD
9040: PUSH
9041: LD_INT 1
9043: PLUS
9044: ARRAY
9045: PPUSH
9046: LD_INT 80
9048: PPUSH
9049: CALL 74284 0 5
// result := result union CreateVehicle ;
9053: LD_ADDR_VAR 0 2
9057: PUSH
9058: LD_VAR 0 2
9062: PUSH
9063: CALL_OW 45
9067: UNION
9068: ST_TO_ADDR
// end ;
9069: GO 8942
9071: POP
9072: POP
// end ; 3 :
9073: GO 9894
9075: LD_INT 3
9077: DOUBLE
9078: EQUAL
9079: IFTRUE 9083
9081: GO 9255
9083: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
9084: LD_ADDR_VAR 0 3
9088: PUSH
9089: DOUBLE
9090: LD_INT 1
9092: DEC
9093: ST_TO_ADDR
9094: LD_INT 6
9096: PUSH
9097: LD_INT 7
9099: PUSH
9100: LD_INT 8
9102: PUSH
9103: LD_INT 9
9105: PUSH
9106: EMPTY
9107: LIST
9108: LIST
9109: LIST
9110: LIST
9111: PUSH
9112: LD_OWVAR 67
9116: ARRAY
9117: PUSH
9118: FOR_TO
9119: IFFALSE 9251
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9121: LD_INT 22
9123: PUSH
9124: LD_INT 24
9126: PUSH
9127: LD_INT 24
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: LIST
9134: PUSH
9135: LD_VAR 0 3
9139: PUSH
9140: LD_INT 3
9142: MOD
9143: PUSH
9144: LD_INT 1
9146: PLUS
9147: ARRAY
9148: PPUSH
9149: LD_INT 1
9151: PUSH
9152: LD_INT 3
9154: PUSH
9155: EMPTY
9156: LIST
9157: LIST
9158: PUSH
9159: LD_INT 1
9161: PPUSH
9162: LD_INT 2
9164: PPUSH
9165: CALL_OW 12
9169: ARRAY
9170: PPUSH
9171: LD_INT 3
9173: PPUSH
9174: LD_INT 43
9176: PUSH
9177: LD_INT 47
9179: PUSH
9180: LD_INT 45
9182: PUSH
9183: LD_INT 45
9185: PUSH
9186: LD_INT 46
9188: PUSH
9189: LD_INT 46
9191: PUSH
9192: LD_INT 49
9194: PUSH
9195: LD_INT 49
9197: PUSH
9198: LD_INT 49
9200: PUSH
9201: EMPTY
9202: LIST
9203: LIST
9204: LIST
9205: LIST
9206: LIST
9207: LIST
9208: LIST
9209: LIST
9210: LIST
9211: PUSH
9212: LD_VAR 0 3
9216: PUSH
9217: LD_INT 9
9219: MOD
9220: PUSH
9221: LD_INT 1
9223: PLUS
9224: ARRAY
9225: PPUSH
9226: LD_INT 80
9228: PPUSH
9229: CALL 74284 0 5
// result := result union CreateVehicle ;
9233: LD_ADDR_VAR 0 2
9237: PUSH
9238: LD_VAR 0 2
9242: PUSH
9243: CALL_OW 45
9247: UNION
9248: ST_TO_ADDR
// end ;
9249: GO 9118
9251: POP
9252: POP
// end ; 4 :
9253: GO 9894
9255: LD_INT 4
9257: DOUBLE
9258: EQUAL
9259: IFTRUE 9263
9261: GO 9893
9263: POP
// begin uc_nation := 3 ;
9264: LD_ADDR_OWVAR 21
9268: PUSH
9269: LD_INT 3
9271: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
9272: LD_ADDR_VAR 0 3
9276: PUSH
9277: DOUBLE
9278: LD_INT 1
9280: DEC
9281: ST_TO_ADDR
9282: LD_INT 6
9284: PUSH
9285: LD_INT 8
9287: PUSH
9288: LD_INT 9
9290: PUSH
9291: LD_INT 10
9293: PUSH
9294: EMPTY
9295: LIST
9296: LIST
9297: LIST
9298: LIST
9299: PUSH
9300: LD_OWVAR 67
9304: ARRAY
9305: PUSH
9306: FOR_TO
9307: IFFALSE 9439
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9309: LD_INT 22
9311: PUSH
9312: LD_INT 24
9314: PUSH
9315: LD_INT 24
9317: PUSH
9318: EMPTY
9319: LIST
9320: LIST
9321: LIST
9322: PUSH
9323: LD_VAR 0 3
9327: PUSH
9328: LD_INT 3
9330: MOD
9331: PUSH
9332: LD_INT 1
9334: PLUS
9335: ARRAY
9336: PPUSH
9337: LD_INT 1
9339: PUSH
9340: LD_INT 3
9342: PUSH
9343: EMPTY
9344: LIST
9345: LIST
9346: PUSH
9347: LD_INT 1
9349: PPUSH
9350: LD_INT 2
9352: PPUSH
9353: CALL_OW 12
9357: ARRAY
9358: PPUSH
9359: LD_INT 3
9361: PPUSH
9362: LD_INT 45
9364: PUSH
9365: LD_INT 47
9367: PUSH
9368: LD_INT 47
9370: PUSH
9371: LD_INT 45
9373: PUSH
9374: LD_INT 46
9376: PUSH
9377: LD_INT 46
9379: PUSH
9380: LD_INT 49
9382: PUSH
9383: LD_INT 49
9385: PUSH
9386: LD_INT 49
9388: PUSH
9389: EMPTY
9390: LIST
9391: LIST
9392: LIST
9393: LIST
9394: LIST
9395: LIST
9396: LIST
9397: LIST
9398: LIST
9399: PUSH
9400: LD_VAR 0 3
9404: PUSH
9405: LD_INT 9
9407: MOD
9408: PUSH
9409: LD_INT 1
9411: PLUS
9412: ARRAY
9413: PPUSH
9414: LD_INT 80
9416: PPUSH
9417: CALL 74284 0 5
// result := result union CreateVehicle ;
9421: LD_ADDR_VAR 0 2
9425: PUSH
9426: LD_VAR 0 2
9430: PUSH
9431: CALL_OW 45
9435: UNION
9436: ST_TO_ADDR
// end ;
9437: GO 9306
9439: POP
9440: POP
// if not KappaStatus then
9441: LD_EXP 2
9445: NOT
9446: IFFALSE 9681
// begin uc_nation := 1 ;
9448: LD_ADDR_OWVAR 21
9452: PUSH
9453: LD_INT 1
9455: ST_TO_ADDR
// for i = 1 to 3 do
9456: LD_ADDR_VAR 0 3
9460: PUSH
9461: DOUBLE
9462: LD_INT 1
9464: DEC
9465: ST_TO_ADDR
9466: LD_INT 3
9468: PUSH
9469: FOR_TO
9470: IFFALSE 9606
// begin j := rand ( 0 , 1 ) ;
9472: LD_ADDR_VAR 0 4
9476: PUSH
9477: LD_INT 0
9479: PPUSH
9480: LD_INT 1
9482: PPUSH
9483: CALL_OW 12
9487: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9488: LD_INT 3
9490: PUSH
9491: LD_INT 5
9493: PUSH
9494: LD_INT 5
9496: PUSH
9497: LD_INT 4
9499: PUSH
9500: EMPTY
9501: LIST
9502: LIST
9503: LIST
9504: LIST
9505: PUSH
9506: LD_VAR 0 4
9510: PUSH
9511: LD_INT 1
9513: PPUSH
9514: LD_INT 3
9516: PPUSH
9517: CALL_OW 12
9521: PLUS
9522: ARRAY
9523: PPUSH
9524: LD_INT 1
9526: PUSH
9527: LD_INT 3
9529: PUSH
9530: EMPTY
9531: LIST
9532: LIST
9533: PUSH
9534: LD_INT 1
9536: PPUSH
9537: LD_INT 2
9539: PPUSH
9540: CALL_OW 12
9544: ARRAY
9545: PPUSH
9546: LD_INT 3
9548: PPUSH
9549: LD_INT 9
9551: PUSH
9552: LD_INT 7
9554: PUSH
9555: LD_INT 6
9557: PUSH
9558: EMPTY
9559: LIST
9560: LIST
9561: LIST
9562: PUSH
9563: LD_VAR 0 4
9567: PUSH
9568: LD_INT 1
9570: PPUSH
9571: LD_INT 2
9573: PPUSH
9574: CALL_OW 12
9578: PLUS
9579: ARRAY
9580: PPUSH
9581: LD_INT 85
9583: PPUSH
9584: CALL 74284 0 5
// result := result union CreateVehicle ;
9588: LD_ADDR_VAR 0 2
9592: PUSH
9593: LD_VAR 0 2
9597: PUSH
9598: CALL_OW 45
9602: UNION
9603: ST_TO_ADDR
// end ;
9604: GO 9469
9606: POP
9607: POP
// if vsevolodFirstAttack then
9608: LD_EXP 24
9612: IFFALSE 9679
// begin vsevolodFirstAttack := false ;
9614: LD_ADDR_EXP 24
9618: PUSH
9619: LD_INT 0
9621: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9622: LD_INT 5
9624: PPUSH
9625: LD_INT 3
9627: PPUSH
9628: LD_INT 1
9630: PPUSH
9631: LD_INT 6
9633: PPUSH
9634: LD_INT 100
9636: PPUSH
9637: CALL 74284 0 5
// sewiVeh := CreateVehicle ;
9641: LD_ADDR_EXP 74
9645: PUSH
9646: CALL_OW 45
9650: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9651: LD_EXP 74
9655: PPUSH
9656: LD_INT 1
9658: PPUSH
9659: CALL_OW 242
// result := result union sewiVeh ;
9663: LD_ADDR_VAR 0 2
9667: PUSH
9668: LD_VAR 0 2
9672: PUSH
9673: LD_EXP 74
9677: UNION
9678: ST_TO_ADDR
// end ; end else
9679: GO 9891
// if vsevolodFirstAttack then
9681: LD_EXP 24
9685: IFFALSE 9891
// begin vsevolodFirstAttack := false ;
9687: LD_ADDR_EXP 24
9691: PUSH
9692: LD_INT 0
9694: ST_TO_ADDR
// uc_nation := 3 ;
9695: LD_ADDR_OWVAR 21
9699: PUSH
9700: LD_INT 3
9702: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9703: LD_ADDR_VAR 0 3
9707: PUSH
9708: DOUBLE
9709: LD_INT 1
9711: DEC
9712: ST_TO_ADDR
9713: LD_INT 2
9715: PUSH
9716: LD_OWVAR 67
9720: PLUS
9721: PUSH
9722: FOR_TO
9723: IFFALSE 9831
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9725: LD_INT 22
9727: PUSH
9728: LD_INT 24
9730: PUSH
9731: LD_INT 24
9733: PUSH
9734: EMPTY
9735: LIST
9736: LIST
9737: LIST
9738: PUSH
9739: LD_VAR 0 3
9743: PUSH
9744: LD_INT 3
9746: MOD
9747: PUSH
9748: LD_INT 1
9750: PLUS
9751: ARRAY
9752: PPUSH
9753: LD_INT 1
9755: PUSH
9756: LD_INT 3
9758: PUSH
9759: EMPTY
9760: LIST
9761: LIST
9762: PUSH
9763: LD_INT 1
9765: PPUSH
9766: LD_INT 2
9768: PPUSH
9769: CALL_OW 12
9773: ARRAY
9774: PPUSH
9775: LD_INT 1
9777: PPUSH
9778: LD_INT 45
9780: PUSH
9781: LD_INT 47
9783: PUSH
9784: LD_INT 47
9786: PUSH
9787: EMPTY
9788: LIST
9789: LIST
9790: LIST
9791: PUSH
9792: LD_VAR 0 3
9796: PUSH
9797: LD_INT 3
9799: MOD
9800: PUSH
9801: LD_INT 1
9803: PLUS
9804: ARRAY
9805: PPUSH
9806: LD_INT 80
9808: PPUSH
9809: CALL 74284 0 5
// result := result union CreateVehicle ;
9813: LD_ADDR_VAR 0 2
9817: PUSH
9818: LD_VAR 0 2
9822: PUSH
9823: CALL_OW 45
9827: UNION
9828: ST_TO_ADDR
// end ;
9829: GO 9722
9831: POP
9832: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9833: LD_INT 24
9835: PPUSH
9836: LD_INT 3
9838: PPUSH
9839: LD_INT 1
9841: PPUSH
9842: LD_INT 47
9844: PPUSH
9845: LD_INT 100
9847: PPUSH
9848: CALL 74284 0 5
// sewiVeh := CreateVehicle ;
9852: LD_ADDR_EXP 74
9856: PUSH
9857: CALL_OW 45
9861: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9862: LD_EXP 74
9866: PPUSH
9867: LD_INT 6
9869: NEG
9870: PPUSH
9871: CALL_OW 242
// result := result union sewiVeh ;
9875: LD_ADDR_VAR 0 2
9879: PUSH
9880: LD_VAR 0 2
9884: PUSH
9885: LD_EXP 74
9889: UNION
9890: ST_TO_ADDR
// end ; end ; end ;
9891: GO 9894
9893: POP
// end ;
9894: LD_VAR 0 2
9898: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9899: LD_EXP 16
9903: IFFALSE 10644
9905: GO 9907
9907: DISABLE
9908: LD_INT 0
9910: PPUSH
9911: PPUSH
9912: PPUSH
9913: PPUSH
9914: PPUSH
9915: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9916: LD_ADDR_VAR 0 4
9920: PUSH
9921: LD_INT 11
9923: PUSH
9924: LD_INT 12
9926: PUSH
9927: EMPTY
9928: LIST
9929: LIST
9930: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9931: LD_ADDR_VAR 0 3
9935: PUSH
9936: LD_INT 11550
9938: PUSH
9939: LD_INT 10150
9941: PUSH
9942: LD_INT 9800
9944: PUSH
9945: LD_INT 9450
9947: PUSH
9948: EMPTY
9949: LIST
9950: LIST
9951: LIST
9952: LIST
9953: PUSH
9954: LD_OWVAR 67
9958: ARRAY
9959: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9960: LD_ADDR_VAR 0 6
9964: PUSH
9965: LD_INT 70
9967: PUSH
9968: LD_INT 118
9970: PUSH
9971: EMPTY
9972: LIST
9973: LIST
9974: PUSH
9975: LD_INT 78
9977: PUSH
9978: LD_INT 31
9980: PUSH
9981: EMPTY
9982: LIST
9983: LIST
9984: PUSH
9985: EMPTY
9986: LIST
9987: LIST
9988: ST_TO_ADDR
// repeat if missionStage = 2 then
9989: LD_EXP 15
9993: PUSH
9994: LD_INT 2
9996: EQUAL
9997: IFFALSE 10008
// wait ( 1 1$30 ) else
9999: LD_INT 3150
10001: PPUSH
10002: CALL_OW 67
10006: GO 10017
// wait ( time ) ;
10008: LD_VAR 0 3
10012: PPUSH
10013: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
10017: LD_EXP 15
10021: PUSH
10022: LD_INT 6
10024: EQUAL
10025: PUSH
10026: LD_OWVAR 67
10030: PUSH
10031: LD_INT 2
10033: GREATER
10034: OR
10035: IFFALSE 10063
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
10037: LD_INT 51
10039: PPUSH
10040: LD_INT 6
10042: PPUSH
10043: LD_INT 2
10045: PPUSH
10046: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
10050: LD_INT 57
10052: PPUSH
10053: LD_INT 6
10055: PPUSH
10056: LD_INT 2
10058: PPUSH
10059: CALL_OW 322
// end ; if missionStage = 8 then
10063: LD_EXP 15
10067: PUSH
10068: LD_INT 8
10070: EQUAL
10071: IFFALSE 10099
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
10073: LD_INT 52
10075: PPUSH
10076: LD_INT 6
10078: PPUSH
10079: LD_INT 2
10081: PPUSH
10082: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
10086: LD_INT 58
10088: PPUSH
10089: LD_INT 6
10091: PPUSH
10092: LD_INT 2
10094: PPUSH
10095: CALL_OW 322
// end ; if Difficulty = 4 or missionStage = 10 then
10099: LD_OWVAR 67
10103: PUSH
10104: LD_INT 4
10106: EQUAL
10107: PUSH
10108: LD_EXP 15
10112: PUSH
10113: LD_INT 10
10115: EQUAL
10116: OR
10117: IFFALSE 10145
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
10119: LD_INT 53
10121: PPUSH
10122: LD_INT 6
10124: PPUSH
10125: LD_INT 2
10127: PPUSH
10128: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
10132: LD_INT 59
10134: PPUSH
10135: LD_INT 6
10137: PPUSH
10138: LD_INT 2
10140: PPUSH
10141: CALL_OW 322
// end ; if activeAttacks then
10145: LD_EXP 16
10149: IFFALSE 10638
// begin if missionStage = 2 then
10151: LD_EXP 15
10155: PUSH
10156: LD_INT 2
10158: EQUAL
10159: IFFALSE 10169
// strength := 1 ;
10161: LD_ADDR_VAR 0 5
10165: PUSH
10166: LD_INT 1
10168: ST_TO_ADDR
// if missionStage > 2 then
10169: LD_EXP 15
10173: PUSH
10174: LD_INT 2
10176: GREATER
10177: IFFALSE 10187
// strength := 2 ;
10179: LD_ADDR_VAR 0 5
10183: PUSH
10184: LD_INT 2
10186: ST_TO_ADDR
// if missionStage > 6 then
10187: LD_EXP 15
10191: PUSH
10192: LD_INT 6
10194: GREATER
10195: IFFALSE 10205
// strength := 3 ;
10197: LD_ADDR_VAR 0 5
10201: PUSH
10202: LD_INT 3
10204: ST_TO_ADDR
// if missionStage > 10 then
10205: LD_EXP 15
10209: PUSH
10210: LD_INT 10
10212: GREATER
10213: IFFALSE 10223
// strength := 4 ;
10215: LD_ADDR_VAR 0 5
10219: PUSH
10220: LD_INT 4
10222: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
10223: LD_ADDR_VAR 0 2
10227: PUSH
10228: LD_VAR 0 5
10232: PPUSH
10233: CALL 8716 0 1
10237: ST_TO_ADDR
// for i in tmp do
10238: LD_ADDR_VAR 0 1
10242: PUSH
10243: LD_VAR 0 2
10247: PUSH
10248: FOR_IN
10249: IFFALSE 10507
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
10251: LD_VAR 0 1
10255: PPUSH
10256: LD_VAR 0 4
10260: PUSH
10261: LD_INT 1
10263: PPUSH
10264: LD_INT 2
10266: PPUSH
10267: CALL_OW 12
10271: ARRAY
10272: PPUSH
10273: LD_INT 0
10275: PPUSH
10276: CALL_OW 49
// if i = sewiVeh then
10280: LD_VAR 0 1
10284: PUSH
10285: LD_EXP 74
10289: EQUAL
10290: IFFALSE 10327
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
10292: LD_ADDR_EXP 73
10296: PUSH
10297: LD_STRING Vsevolod
10299: PPUSH
10300: LD_INT 0
10302: PPUSH
10303: LD_STRING 
10305: PPUSH
10306: CALL 69444 0 3
10310: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
10311: LD_EXP 73
10315: PPUSH
10316: LD_VAR 0 1
10320: PPUSH
10321: CALL_OW 52
// end else
10325: GO 10408
// if GetControl ( i ) = control_manual then
10327: LD_VAR 0 1
10331: PPUSH
10332: CALL_OW 263
10336: PUSH
10337: LD_INT 1
10339: EQUAL
10340: IFFALSE 10408
// begin uc_side := 6 ;
10342: LD_ADDR_OWVAR 20
10346: PUSH
10347: LD_INT 6
10349: ST_TO_ADDR
// uc_nation := 3 ;
10350: LD_ADDR_OWVAR 21
10354: PUSH
10355: LD_INT 3
10357: ST_TO_ADDR
// hc_gallery :=  ;
10358: LD_ADDR_OWVAR 33
10362: PUSH
10363: LD_STRING 
10365: ST_TO_ADDR
// hc_name :=  ;
10366: LD_ADDR_OWVAR 26
10370: PUSH
10371: LD_STRING 
10373: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
10374: LD_INT 0
10376: PPUSH
10377: LD_INT 3
10379: PPUSH
10380: LD_INT 10
10382: PPUSH
10383: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
10387: CALL_OW 44
10391: PPUSH
10392: LD_VAR 0 1
10396: PPUSH
10397: CALL_OW 52
// wait ( 0 0$0.3 ) ;
10401: LD_INT 10
10403: PPUSH
10404: CALL_OW 67
// end ; case rand ( 1 , 3 ) of 1 :
10408: LD_INT 1
10410: PPUSH
10411: LD_INT 3
10413: PPUSH
10414: CALL_OW 12
10418: PUSH
10419: LD_INT 1
10421: DOUBLE
10422: EQUAL
10423: IFTRUE 10427
10425: GO 10445
10427: POP
// ComMoveXY ( i , 111 , 197 ) ; 2 :
10428: LD_VAR 0 1
10432: PPUSH
10433: LD_INT 111
10435: PPUSH
10436: LD_INT 197
10438: PPUSH
10439: CALL_OW 111
10443: GO 10498
10445: LD_INT 2
10447: DOUBLE
10448: EQUAL
10449: IFTRUE 10453
10451: GO 10471
10453: POP
// ComMoveXY ( i , 91 , 165 ) ; 3 :
10454: LD_VAR 0 1
10458: PPUSH
10459: LD_INT 91
10461: PPUSH
10462: LD_INT 165
10464: PPUSH
10465: CALL_OW 111
10469: GO 10498
10471: LD_INT 3
10473: DOUBLE
10474: EQUAL
10475: IFTRUE 10479
10477: GO 10497
10479: POP
// ComMoveXY ( i , 137 , 157 ) ; end ;
10480: LD_VAR 0 1
10484: PPUSH
10485: LD_INT 137
10487: PPUSH
10488: LD_INT 157
10490: PPUSH
10491: CALL_OW 111
10495: GO 10498
10497: POP
// wait ( 0 0$2 ) ;
10498: LD_INT 70
10500: PPUSH
10501: CALL_OW 67
// end ;
10505: GO 10248
10507: POP
10508: POP
// repeat wait ( 0 0$1 ) ;
10509: LD_INT 35
10511: PPUSH
10512: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
10516: LD_ADDR_VAR 0 1
10520: PUSH
10521: LD_VAR 0 2
10525: PPUSH
10526: LD_INT 50
10528: PUSH
10529: EMPTY
10530: LIST
10531: PPUSH
10532: CALL_OW 72
10536: PUSH
10537: FOR_IN
10538: IFFALSE 10597
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10540: LD_VAR 0 1
10544: PPUSH
10545: LD_INT 108
10547: PUSH
10548: LD_INT 153
10550: PUSH
10551: EMPTY
10552: LIST
10553: LIST
10554: PUSH
10555: LD_INT 105
10557: PUSH
10558: LD_INT 149
10560: PUSH
10561: EMPTY
10562: LIST
10563: LIST
10564: PUSH
10565: LD_INT 85
10567: PUSH
10568: LD_INT 131
10570: PUSH
10571: EMPTY
10572: LIST
10573: LIST
10574: PUSH
10575: LD_INT 64
10577: PUSH
10578: LD_INT 105
10580: PUSH
10581: EMPTY
10582: LIST
10583: LIST
10584: PUSH
10585: EMPTY
10586: LIST
10587: LIST
10588: LIST
10589: LIST
10590: PPUSH
10591: CALL 109739 0 2
10595: GO 10537
10597: POP
10598: POP
// until not UnitFilter ( tmp , [ [ f_not , [ f_weapon , ru_time_lapser ] ] , [ f_ok ] ] ) ;
10599: LD_VAR 0 2
10603: PPUSH
10604: LD_INT 3
10606: PUSH
10607: LD_INT 34
10609: PUSH
10610: LD_INT 49
10612: PUSH
10613: EMPTY
10614: LIST
10615: LIST
10616: PUSH
10617: EMPTY
10618: LIST
10619: LIST
10620: PUSH
10621: LD_INT 50
10623: PUSH
10624: EMPTY
10625: LIST
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: PPUSH
10631: CALL_OW 72
10635: NOT
10636: IFFALSE 10509
// end ; until russianDestroyed ;
10638: LD_EXP 21
10642: IFFALSE 9989
// end ;
10644: PPOPN 6
10646: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 do var i , tmp , target , teleport , p ;
10647: LD_EXP 21
10651: NOT
10652: PUSH
10653: LD_EXP 15
10657: PUSH
10658: LD_INT 6
10660: GREATEREQUAL
10661: AND
10662: IFFALSE 11682
10664: GO 10666
10666: DISABLE
10667: LD_INT 0
10669: PPUSH
10670: PPUSH
10671: PPUSH
10672: PPUSH
10673: PPUSH
// begin enable ;
10674: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10675: LD_INT 22
10677: PUSH
10678: LD_INT 3
10680: PUSH
10681: EMPTY
10682: LIST
10683: LIST
10684: PUSH
10685: LD_INT 30
10687: PUSH
10688: LD_INT 3
10690: PUSH
10691: EMPTY
10692: LIST
10693: LIST
10694: PUSH
10695: EMPTY
10696: LIST
10697: LIST
10698: PPUSH
10699: CALL_OW 69
10703: NOT
10704: IFFALSE 10708
// exit ;
10706: GO 11682
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10708: LD_ADDR_VAR 0 4
10712: PUSH
10713: LD_INT 22
10715: PUSH
10716: LD_INT 3
10718: PUSH
10719: EMPTY
10720: LIST
10721: LIST
10722: PUSH
10723: LD_INT 30
10725: PUSH
10726: LD_INT 34
10728: PUSH
10729: EMPTY
10730: LIST
10731: LIST
10732: PUSH
10733: EMPTY
10734: LIST
10735: LIST
10736: PPUSH
10737: CALL_OW 69
10741: ST_TO_ADDR
// if Prob ( 40 ) then
10742: LD_INT 40
10744: PPUSH
10745: CALL_OW 13
10749: IFFALSE 10895
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10751: LD_INT 2
10753: PPUSH
10754: LD_INT 22
10756: PUSH
10757: LD_INT 3
10759: PUSH
10760: LD_INT 3
10762: PUSH
10763: LD_INT 49
10765: PUSH
10766: EMPTY
10767: LIST
10768: LIST
10769: LIST
10770: LIST
10771: PUSH
10772: LD_INT 22
10774: PUSH
10775: LD_INT 3
10777: PUSH
10778: LD_INT 3
10780: PUSH
10781: LD_INT 49
10783: PUSH
10784: EMPTY
10785: LIST
10786: LIST
10787: LIST
10788: LIST
10789: PUSH
10790: LD_INT 22
10792: PUSH
10793: LD_INT 3
10795: PUSH
10796: LD_INT 3
10798: PUSH
10799: LD_INT 49
10801: PUSH
10802: EMPTY
10803: LIST
10804: LIST
10805: LIST
10806: LIST
10807: PUSH
10808: LD_INT 24
10810: PUSH
10811: LD_INT 3
10813: PUSH
10814: LD_INT 3
10816: PUSH
10817: LD_INT 46
10819: PUSH
10820: EMPTY
10821: LIST
10822: LIST
10823: LIST
10824: LIST
10825: PUSH
10826: LD_INT 24
10828: PUSH
10829: LD_INT 3
10831: PUSH
10832: LD_INT 3
10834: PUSH
10835: LD_INT 46
10837: PUSH
10838: EMPTY
10839: LIST
10840: LIST
10841: LIST
10842: LIST
10843: PUSH
10844: LD_INT 24
10846: PUSH
10847: LD_INT 3
10849: PUSH
10850: LD_INT 3
10852: PUSH
10853: LD_INT 46
10855: PUSH
10856: EMPTY
10857: LIST
10858: LIST
10859: LIST
10860: LIST
10861: PUSH
10862: LD_INT 24
10864: PUSH
10865: LD_INT 3
10867: PUSH
10868: LD_INT 3
10870: PUSH
10871: LD_INT 46
10873: PUSH
10874: EMPTY
10875: LIST
10876: LIST
10877: LIST
10878: LIST
10879: PUSH
10880: EMPTY
10881: LIST
10882: LIST
10883: LIST
10884: LIST
10885: LIST
10886: LIST
10887: LIST
10888: PPUSH
10889: CALL 63018 0 2
// end else
10893: GO 11037
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10895: LD_INT 2
10897: PPUSH
10898: LD_INT 24
10900: PUSH
10901: LD_INT 3
10903: PUSH
10904: LD_INT 3
10906: PUSH
10907: LD_INT 47
10909: PUSH
10910: EMPTY
10911: LIST
10912: LIST
10913: LIST
10914: LIST
10915: PUSH
10916: LD_INT 24
10918: PUSH
10919: LD_INT 3
10921: PUSH
10922: LD_INT 3
10924: PUSH
10925: LD_INT 47
10927: PUSH
10928: EMPTY
10929: LIST
10930: LIST
10931: LIST
10932: LIST
10933: PUSH
10934: LD_INT 24
10936: PUSH
10937: LD_INT 3
10939: PUSH
10940: LD_INT 3
10942: PUSH
10943: LD_INT 47
10945: PUSH
10946: EMPTY
10947: LIST
10948: LIST
10949: LIST
10950: LIST
10951: PUSH
10952: LD_INT 24
10954: PUSH
10955: LD_INT 3
10957: PUSH
10958: LD_INT 3
10960: PUSH
10961: LD_INT 46
10963: PUSH
10964: EMPTY
10965: LIST
10966: LIST
10967: LIST
10968: LIST
10969: PUSH
10970: LD_INT 24
10972: PUSH
10973: LD_INT 3
10975: PUSH
10976: LD_INT 3
10978: PUSH
10979: LD_INT 46
10981: PUSH
10982: EMPTY
10983: LIST
10984: LIST
10985: LIST
10986: LIST
10987: PUSH
10988: LD_INT 24
10990: PUSH
10991: LD_INT 3
10993: PUSH
10994: LD_INT 3
10996: PUSH
10997: LD_INT 46
10999: PUSH
11000: EMPTY
11001: LIST
11002: LIST
11003: LIST
11004: LIST
11005: PUSH
11006: LD_INT 24
11008: PUSH
11009: LD_INT 3
11011: PUSH
11012: LD_INT 3
11014: PUSH
11015: LD_INT 46
11017: PUSH
11018: EMPTY
11019: LIST
11020: LIST
11021: LIST
11022: LIST
11023: PUSH
11024: EMPTY
11025: LIST
11026: LIST
11027: LIST
11028: LIST
11029: LIST
11030: LIST
11031: LIST
11032: PPUSH
11033: CALL 63018 0 2
// end ; wait ( 2 2$00 ) ;
11037: LD_INT 4200
11039: PPUSH
11040: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 2 ] ;
11044: LD_ADDR_VAR 0 2
11048: PUSH
11049: LD_INT 22
11051: PUSH
11052: LD_INT 3
11054: PUSH
11055: EMPTY
11056: LIST
11057: LIST
11058: PUSH
11059: LD_INT 21
11061: PUSH
11062: LD_INT 2
11064: PUSH
11065: EMPTY
11066: LIST
11067: LIST
11068: PUSH
11069: LD_INT 3
11071: PUSH
11072: LD_INT 34
11074: PUSH
11075: LD_INT 48
11077: PUSH
11078: EMPTY
11079: LIST
11080: LIST
11081: PUSH
11082: LD_INT 34
11084: PUSH
11085: LD_INT 51
11087: PUSH
11088: EMPTY
11089: LIST
11090: LIST
11091: PUSH
11092: LD_INT 34
11094: PUSH
11095: LD_INT 52
11097: PUSH
11098: EMPTY
11099: LIST
11100: LIST
11101: PUSH
11102: EMPTY
11103: LIST
11104: LIST
11105: LIST
11106: LIST
11107: PUSH
11108: EMPTY
11109: LIST
11110: LIST
11111: LIST
11112: PPUSH
11113: CALL_OW 69
11117: PUSH
11118: LD_EXP 123
11122: PUSH
11123: LD_INT 2
11125: ARRAY
11126: DIFF
11127: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
11128: LD_ADDR_EXP 120
11132: PUSH
11133: LD_EXP 120
11137: PPUSH
11138: LD_INT 2
11140: PPUSH
11141: LD_EXP 120
11145: PUSH
11146: LD_INT 2
11148: ARRAY
11149: PUSH
11150: LD_VAR 0 2
11154: DIFF
11155: PPUSH
11156: CALL_OW 1
11160: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
11161: LD_ADDR_VAR 0 3
11165: PUSH
11166: LD_INT 0
11168: PPUSH
11169: LD_INT 1
11171: PPUSH
11172: CALL_OW 12
11176: ST_TO_ADDR
// p := 0 ;
11177: LD_ADDR_VAR 0 5
11181: PUSH
11182: LD_INT 0
11184: ST_TO_ADDR
// if target then
11185: LD_VAR 0 3
11189: IFFALSE 11342
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11191: LD_ADDR_VAR 0 2
11195: PUSH
11196: LD_VAR 0 2
11200: PPUSH
11201: LD_INT 24
11203: PUSH
11204: LD_INT 250
11206: PUSH
11207: EMPTY
11208: LIST
11209: LIST
11210: PPUSH
11211: CALL_OW 72
11215: ST_TO_ADDR
// for i in tmp do
11216: LD_ADDR_VAR 0 1
11220: PUSH
11221: LD_VAR 0 2
11225: PUSH
11226: FOR_IN
11227: IFFALSE 11267
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
11229: LD_VAR 0 1
11233: PPUSH
11234: LD_INT 139
11236: PPUSH
11237: LD_INT 89
11239: PPUSH
11240: CALL_OW 297
11244: PUSH
11245: LD_INT 9
11247: GREATER
11248: IFFALSE 11265
// ComMoveXY ( i , 139 , 89 ) ;
11250: LD_VAR 0 1
11254: PPUSH
11255: LD_INT 139
11257: PPUSH
11258: LD_INT 89
11260: PPUSH
11261: CALL_OW 111
11265: GO 11226
11267: POP
11268: POP
// wait ( 0 0$1 ) ;
11269: LD_INT 35
11271: PPUSH
11272: CALL_OW 67
// p := Inc ( p ) ;
11276: LD_ADDR_VAR 0 5
11280: PUSH
11281: LD_VAR 0 5
11285: PPUSH
11286: CALL 108496 0 1
11290: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11291: LD_VAR 0 2
11295: PPUSH
11296: LD_INT 92
11298: PUSH
11299: LD_INT 139
11301: PUSH
11302: LD_INT 89
11304: PUSH
11305: LD_INT 9
11307: PUSH
11308: EMPTY
11309: LIST
11310: LIST
11311: LIST
11312: LIST
11313: PPUSH
11314: CALL_OW 72
11318: PUSH
11319: LD_VAR 0 2
11323: PUSH
11324: LD_INT 1
11326: MINUS
11327: GREATEREQUAL
11328: PUSH
11329: LD_VAR 0 5
11333: PUSH
11334: LD_INT 60
11336: GREATER
11337: OR
11338: IFFALSE 11191
// end else
11340: GO 11509
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11342: LD_VAR 0 2
11346: PPUSH
11347: LD_VAR 0 4
11351: PUSH
11352: LD_INT 1
11354: ARRAY
11355: PPUSH
11356: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11360: LD_ADDR_VAR 0 2
11364: PUSH
11365: LD_VAR 0 2
11369: PPUSH
11370: LD_INT 24
11372: PUSH
11373: LD_INT 250
11375: PUSH
11376: EMPTY
11377: LIST
11378: LIST
11379: PPUSH
11380: CALL_OW 72
11384: ST_TO_ADDR
// for i in tmp do
11385: LD_ADDR_VAR 0 1
11389: PUSH
11390: LD_VAR 0 2
11394: PUSH
11395: FOR_IN
11396: IFFALSE 11436
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11398: LD_VAR 0 1
11402: PPUSH
11403: LD_INT 124
11405: PPUSH
11406: LD_INT 139
11408: PPUSH
11409: CALL_OW 297
11413: PUSH
11414: LD_INT 9
11416: GREATER
11417: IFFALSE 11434
// ComMoveXY ( i , 124 , 139 ) ;
11419: LD_VAR 0 1
11423: PPUSH
11424: LD_INT 124
11426: PPUSH
11427: LD_INT 139
11429: PPUSH
11430: CALL_OW 111
11434: GO 11395
11436: POP
11437: POP
// wait ( 0 0$1 ) ;
11438: LD_INT 35
11440: PPUSH
11441: CALL_OW 67
// p := Inc ( p ) ;
11445: LD_ADDR_VAR 0 5
11449: PUSH
11450: LD_VAR 0 5
11454: PPUSH
11455: CALL 108496 0 1
11459: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11460: LD_VAR 0 2
11464: PPUSH
11465: LD_INT 92
11467: PUSH
11468: LD_INT 124
11470: PUSH
11471: LD_INT 139
11473: PUSH
11474: LD_INT 9
11476: PUSH
11477: EMPTY
11478: LIST
11479: LIST
11480: LIST
11481: LIST
11482: PPUSH
11483: CALL_OW 72
11487: PUSH
11488: LD_VAR 0 2
11492: PUSH
11493: LD_INT 1
11495: MINUS
11496: GREATEREQUAL
11497: PUSH
11498: LD_VAR 0 5
11502: PUSH
11503: LD_INT 60
11505: GREATER
11506: OR
11507: IFFALSE 11360
// end ; repeat wait ( 0 0$1 ) ;
11509: LD_INT 35
11511: PPUSH
11512: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11516: LD_ADDR_VAR 0 2
11520: PUSH
11521: LD_VAR 0 2
11525: PPUSH
11526: LD_INT 50
11528: PUSH
11529: EMPTY
11530: LIST
11531: PPUSH
11532: CALL_OW 72
11536: ST_TO_ADDR
// for i in tmp do
11537: LD_ADDR_VAR 0 1
11541: PUSH
11542: LD_VAR 0 2
11546: PUSH
11547: FOR_IN
11548: IFFALSE 11673
// begin if GetWeapon ( i ) = ru_time_lapser then
11550: LD_VAR 0 1
11554: PPUSH
11555: CALL_OW 264
11559: PUSH
11560: LD_INT 49
11562: EQUAL
11563: IFFALSE 11619
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11565: LD_VAR 0 1
11569: PPUSH
11570: LD_INT 2
11572: PUSH
11573: LD_INT 22
11575: PUSH
11576: LD_INT 1
11578: PUSH
11579: EMPTY
11580: LIST
11581: LIST
11582: PUSH
11583: LD_INT 22
11585: PUSH
11586: LD_INT 8
11588: PUSH
11589: EMPTY
11590: LIST
11591: LIST
11592: PUSH
11593: EMPTY
11594: LIST
11595: LIST
11596: LIST
11597: PPUSH
11598: CALL_OW 69
11602: PPUSH
11603: LD_VAR 0 1
11607: PPUSH
11608: CALL_OW 74
11612: PPUSH
11613: CALL_OW 112
11617: GO 11671
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11619: LD_VAR 0 1
11623: PPUSH
11624: LD_INT 2
11626: PUSH
11627: LD_INT 22
11629: PUSH
11630: LD_INT 1
11632: PUSH
11633: EMPTY
11634: LIST
11635: LIST
11636: PUSH
11637: LD_INT 22
11639: PUSH
11640: LD_INT 8
11642: PUSH
11643: EMPTY
11644: LIST
11645: LIST
11646: PUSH
11647: EMPTY
11648: LIST
11649: LIST
11650: LIST
11651: PPUSH
11652: CALL_OW 69
11656: PPUSH
11657: LD_VAR 0 1
11661: PPUSH
11662: CALL_OW 74
11666: PPUSH
11667: CALL_OW 115
// end ;
11671: GO 11547
11673: POP
11674: POP
// until not tmp ;
11675: LD_VAR 0 2
11679: NOT
11680: IFFALSE 11509
// end ;
11682: PPOPN 5
11684: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 7 and Difficulty > 1 do var i , veh , un ;
11685: LD_EXP 15
11689: PUSH
11690: LD_INT 7
11692: GREATEREQUAL
11693: PUSH
11694: LD_OWVAR 67
11698: PUSH
11699: LD_INT 1
11701: GREATER
11702: AND
11703: IFFALSE 11995
11705: GO 11707
11707: DISABLE
11708: LD_INT 0
11710: PPUSH
11711: PPUSH
11712: PPUSH
// begin ruMobile := [ ] ;
11713: LD_ADDR_EXP 77
11717: PUSH
11718: EMPTY
11719: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 ] [ Difficulty - 1 ] do
11720: LD_ADDR_VAR 0 1
11724: PUSH
11725: DOUBLE
11726: LD_INT 1
11728: DEC
11729: ST_TO_ADDR
11730: LD_INT 4
11732: PUSH
11733: LD_INT 5
11735: PUSH
11736: LD_INT 6
11738: PUSH
11739: EMPTY
11740: LIST
11741: LIST
11742: LIST
11743: PUSH
11744: LD_OWVAR 67
11748: PUSH
11749: LD_INT 1
11751: MINUS
11752: ARRAY
11753: PUSH
11754: FOR_TO
11755: IFFALSE 11993
// begin uc_side := 3 ;
11757: LD_ADDR_OWVAR 20
11761: PUSH
11762: LD_INT 3
11764: ST_TO_ADDR
// uc_nation := 1 ;
11765: LD_ADDR_OWVAR 21
11769: PUSH
11770: LD_INT 1
11772: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_laser , us_rocket_launcher ] [ i mod 2 + 1 ] , 100 ) ;
11773: LD_INT 5
11775: PPUSH
11776: LD_INT 3
11778: PPUSH
11779: LD_INT 1
11781: PPUSH
11782: LD_INT 9
11784: PUSH
11785: LD_INT 7
11787: PUSH
11788: EMPTY
11789: LIST
11790: LIST
11791: PUSH
11792: LD_VAR 0 1
11796: PUSH
11797: LD_INT 2
11799: MOD
11800: PUSH
11801: LD_INT 1
11803: PLUS
11804: ARRAY
11805: PPUSH
11806: LD_INT 100
11808: PPUSH
11809: CALL 74284 0 5
// veh := CreateVehicle ;
11813: LD_ADDR_VAR 0 2
11817: PUSH
11818: CALL_OW 45
11822: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11823: LD_VAR 0 2
11827: PPUSH
11828: LD_INT 3
11830: PPUSH
11831: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11835: LD_VAR 0 2
11839: PPUSH
11840: LD_INT 29
11842: PPUSH
11843: LD_INT 0
11845: PPUSH
11846: CALL_OW 49
// uc_nation := 3 ;
11850: LD_ADDR_OWVAR 21
11854: PUSH
11855: LD_INT 3
11857: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
11858: LD_INT 0
11860: PPUSH
11861: LD_INT 10
11863: PPUSH
11864: CALL_OW 383
// un := CreateHuman ;
11868: LD_ADDR_VAR 0 3
11872: PUSH
11873: CALL_OW 44
11877: ST_TO_ADDR
// SetTag ( un , 105 ) ;
11878: LD_VAR 0 3
11882: PPUSH
11883: LD_INT 105
11885: PPUSH
11886: CALL_OW 109
// if GetSkill ( un , skill_mechanical ) < [ 8 , 9 , 10 ] [ Difficulty ] then
11890: LD_VAR 0 3
11894: PPUSH
11895: LD_INT 3
11897: PPUSH
11898: CALL_OW 259
11902: PUSH
11903: LD_INT 8
11905: PUSH
11906: LD_INT 9
11908: PUSH
11909: LD_INT 10
11911: PUSH
11912: EMPTY
11913: LIST
11914: LIST
11915: LIST
11916: PUSH
11917: LD_OWVAR 67
11921: ARRAY
11922: LESS
11923: IFFALSE 11957
// SetSkill ( un , skill_mechanical , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
11925: LD_VAR 0 3
11929: PPUSH
11930: LD_INT 3
11932: PPUSH
11933: LD_INT 8
11935: PUSH
11936: LD_INT 9
11938: PUSH
11939: LD_INT 10
11941: PUSH
11942: EMPTY
11943: LIST
11944: LIST
11945: LIST
11946: PUSH
11947: LD_OWVAR 67
11951: ARRAY
11952: PPUSH
11953: CALL_OW 237
// PlaceHumanInUnit ( un , veh ) ;
11957: LD_VAR 0 3
11961: PPUSH
11962: LD_VAR 0 2
11966: PPUSH
11967: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
11971: LD_ADDR_EXP 77
11975: PUSH
11976: LD_EXP 77
11980: PPUSH
11981: LD_VAR 0 2
11985: PPUSH
11986: CALL 107135 0 2
11990: ST_TO_ADDR
// end ;
11991: GO 11754
11993: POP
11994: POP
// end ;
11995: PPOPN 3
11997: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
11998: LD_EXP 77
12002: IFFALSE 12511
12004: GO 12006
12006: DISABLE
12007: LD_INT 0
12009: PPUSH
12010: PPUSH
12011: PPUSH
// begin enable ;
12012: ENABLE
// if not ruMobile then
12013: LD_EXP 77
12017: NOT
12018: IFFALSE 12023
// begin disable ;
12020: DISABLE
// exit ;
12021: GO 12511
// end ; for i in ruMobile do
12023: LD_ADDR_VAR 0 1
12027: PUSH
12028: LD_EXP 77
12032: PUSH
12033: FOR_IN
12034: IFFALSE 12509
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
12036: LD_VAR 0 1
12040: PPUSH
12041: CALL_OW 302
12045: NOT
12046: PUSH
12047: LD_VAR 0 1
12051: PPUSH
12052: CALL_OW 255
12056: PUSH
12057: LD_INT 3
12059: NONEQUAL
12060: OR
12061: IFFALSE 12081
// begin ruMobile := ruMobile diff i ;
12063: LD_ADDR_EXP 77
12067: PUSH
12068: LD_EXP 77
12072: PUSH
12073: LD_VAR 0 1
12077: DIFF
12078: ST_TO_ADDR
// continue ;
12079: GO 12033
// end ; if GetTag ( i ) = 300 then
12081: LD_VAR 0 1
12085: PPUSH
12086: CALL_OW 110
12090: PUSH
12091: LD_INT 300
12093: EQUAL
12094: IFFALSE 12144
// begin ComMoveXY ( i , 160 , 81 ) ;
12096: LD_VAR 0 1
12100: PPUSH
12101: LD_INT 160
12103: PPUSH
12104: LD_INT 81
12106: PPUSH
12107: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
12111: LD_VAR 0 1
12115: PPUSH
12116: LD_INT 160
12118: PPUSH
12119: LD_INT 81
12121: PPUSH
12122: CALL_OW 297
12126: PUSH
12127: LD_INT 8
12129: LESS
12130: IFFALSE 12144
// SetTag ( i , 301 ) ;
12132: LD_VAR 0 1
12136: PPUSH
12137: LD_INT 301
12139: PPUSH
12140: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
12144: LD_VAR 0 1
12148: PPUSH
12149: CALL_OW 110
12153: PUSH
12154: LD_INT 301
12156: EQUAL
12157: IFFALSE 12200
// begin if not IsInArea ( i , ruMobileParkingArea ) then
12159: LD_VAR 0 1
12163: PPUSH
12164: LD_INT 33
12166: PPUSH
12167: CALL_OW 308
12171: NOT
12172: IFFALSE 12188
// ComMoveToArea ( i , ruMobileParkingArea ) else
12174: LD_VAR 0 1
12178: PPUSH
12179: LD_INT 33
12181: PPUSH
12182: CALL_OW 113
12186: GO 12200
// SetTag ( i , 302 ) ;
12188: LD_VAR 0 1
12192: PPUSH
12193: LD_INT 302
12195: PPUSH
12196: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
12200: LD_VAR 0 1
12204: PPUSH
12205: CALL_OW 110
12209: PUSH
12210: LD_INT 302
12212: EQUAL
12213: IFFALSE 12343
// begin if GetLives ( i ) < 1000 then
12215: LD_VAR 0 1
12219: PPUSH
12220: CALL_OW 256
12224: PUSH
12225: LD_INT 1000
12227: LESS
12228: IFFALSE 12320
// begin if not IsDrivenBy ( i ) then
12230: LD_VAR 0 1
12234: PPUSH
12235: CALL_OW 311
12239: NOT
12240: IFFALSE 12244
// continue ;
12242: GO 12033
// mech := IsDrivenBy ( i ) ;
12244: LD_ADDR_VAR 0 2
12248: PUSH
12249: LD_VAR 0 1
12253: PPUSH
12254: CALL_OW 311
12258: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
12259: LD_VAR 0 2
12263: PPUSH
12264: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
12268: LD_VAR 0 2
12272: PPUSH
12273: LD_VAR 0 1
12277: PPUSH
12278: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
12282: LD_INT 35
12284: PPUSH
12285: CALL_OW 67
// until GetLives ( i ) = 1000 ;
12289: LD_VAR 0 1
12293: PPUSH
12294: CALL_OW 256
12298: PUSH
12299: LD_INT 1000
12301: EQUAL
12302: IFFALSE 12282
// ComEnterUnit ( mech , i ) ;
12304: LD_VAR 0 2
12308: PPUSH
12309: LD_VAR 0 1
12313: PPUSH
12314: CALL_OW 120
// end else
12318: GO 12343
// if IsDrivenBy ( i ) then
12320: LD_VAR 0 1
12324: PPUSH
12325: CALL_OW 311
12329: IFFALSE 12343
// SetTag ( i , 0 ) ;
12331: LD_VAR 0 1
12335: PPUSH
12336: LD_INT 0
12338: PPUSH
12339: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
12343: LD_VAR 0 1
12347: PPUSH
12348: CALL_OW 110
12352: PUSH
12353: LD_INT 300
12355: LESS
12356: IFFALSE 12507
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
12358: LD_ADDR_VAR 0 3
12362: PUSH
12363: LD_INT 4
12365: PPUSH
12366: LD_INT 81
12368: PUSH
12369: LD_INT 3
12371: PUSH
12372: EMPTY
12373: LIST
12374: LIST
12375: PPUSH
12376: CALL_OW 70
12380: ST_TO_ADDR
// if GetLives ( i ) < 650 then
12381: LD_VAR 0 1
12385: PPUSH
12386: CALL_OW 256
12390: PUSH
12391: LD_INT 650
12393: LESS
12394: IFFALSE 12419
// begin ComStop ( i ) ;
12396: LD_VAR 0 1
12400: PPUSH
12401: CALL_OW 141
// SetTag ( i , 300 ) ;
12405: LD_VAR 0 1
12409: PPUSH
12410: LD_INT 300
12412: PPUSH
12413: CALL_OW 109
// continue ;
12417: GO 12033
// end ; if enemy then
12419: LD_VAR 0 3
12423: IFFALSE 12463
// begin if not HasTask ( i ) then
12425: LD_VAR 0 1
12429: PPUSH
12430: CALL_OW 314
12434: NOT
12435: IFFALSE 12461
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
12437: LD_VAR 0 1
12441: PPUSH
12442: LD_VAR 0 3
12446: PPUSH
12447: LD_VAR 0 1
12451: PPUSH
12452: CALL_OW 74
12456: PPUSH
12457: CALL_OW 115
// end else
12461: GO 12507
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
12463: LD_VAR 0 1
12467: PPUSH
12468: LD_INT 158
12470: PUSH
12471: LD_INT 61
12473: PUSH
12474: EMPTY
12475: LIST
12476: LIST
12477: PUSH
12478: LD_INT 98
12480: PUSH
12481: LD_INT 100
12483: PUSH
12484: EMPTY
12485: LIST
12486: LIST
12487: PUSH
12488: LD_INT 78
12490: PUSH
12491: LD_INT 93
12493: PUSH
12494: EMPTY
12495: LIST
12496: LIST
12497: PUSH
12498: EMPTY
12499: LIST
12500: LIST
12501: LIST
12502: PPUSH
12503: CALL 109739 0 2
// end ; end ;
12507: GO 12033
12509: POP
12510: POP
// end ; end_of_file
12511: PPOPN 3
12513: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport , b ; begin
12514: LD_INT 0
12516: PPUSH
12517: PPUSH
12518: PPUSH
12519: PPUSH
12520: PPUSH
12521: PPUSH
12522: PPUSH
// SetInvulnrability ( alien , true ) ;
12523: LD_INT 1
12525: PPUSH
12526: LD_INT 1
12528: PPUSH
12529: CALL_OW 607
// side := 7 ;
12533: LD_ADDR_VAR 0 5
12537: PUSH
12538: LD_INT 7
12540: ST_TO_ADDR
// uc_side := side ;
12541: LD_ADDR_OWVAR 20
12545: PUSH
12546: LD_VAR 0 5
12550: ST_TO_ADDR
// uc_nation := 1 ;
12551: LD_ADDR_OWVAR 21
12555: PUSH
12556: LD_INT 1
12558: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
12559: LD_ADDR_VAR 0 2
12563: PUSH
12564: LD_INT 22
12566: PUSH
12567: LD_VAR 0 5
12571: PUSH
12572: EMPTY
12573: LIST
12574: LIST
12575: PUSH
12576: LD_INT 21
12578: PUSH
12579: LD_INT 3
12581: PUSH
12582: EMPTY
12583: LIST
12584: LIST
12585: PUSH
12586: EMPTY
12587: LIST
12588: LIST
12589: PPUSH
12590: CALL_OW 69
12594: PUSH
12595: FOR_IN
12596: IFFALSE 12612
// SetBLevel ( i , 10 ) ;
12598: LD_VAR 0 2
12602: PPUSH
12603: LD_INT 10
12605: PPUSH
12606: CALL_OW 241
12610: GO 12595
12612: POP
12613: POP
// base := GetBase ( al_depot ) ;
12614: LD_ADDR_VAR 0 4
12618: PUSH
12619: LD_INT 2
12621: PPUSH
12622: CALL_OW 274
12626: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
12627: LD_ADDR_VAR 0 6
12631: PUSH
12632: LD_INT 22
12634: PUSH
12635: LD_VAR 0 5
12639: PUSH
12640: EMPTY
12641: LIST
12642: LIST
12643: PUSH
12644: LD_INT 30
12646: PUSH
12647: LD_INT 34
12649: PUSH
12650: EMPTY
12651: LIST
12652: LIST
12653: PUSH
12654: EMPTY
12655: LIST
12656: LIST
12657: PPUSH
12658: CALL_OW 69
12662: ST_TO_ADDR
// if teleport then
12663: LD_VAR 0 6
12667: IFFALSE 12688
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
12669: LD_VAR 0 6
12673: PUSH
12674: LD_INT 1
12676: ARRAY
12677: PPUSH
12678: LD_INT 262
12680: PPUSH
12681: LD_INT 119
12683: PPUSH
12684: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
12688: LD_VAR 0 4
12692: PPUSH
12693: LD_INT 1
12695: PPUSH
12696: LD_INT 19500
12698: PPUSH
12699: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
12703: LD_VAR 0 4
12707: PPUSH
12708: LD_INT 2
12710: PPUSH
12711: LD_INT 200
12713: PPUSH
12714: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
12718: LD_VAR 0 4
12722: PPUSH
12723: LD_INT 3
12725: PPUSH
12726: LD_INT 650
12728: PPUSH
12729: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12733: LD_ADDR_EXP 78
12737: PUSH
12738: LD_STRING Roth
12740: PPUSH
12741: CALL_OW 25
12745: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12746: LD_ADDR_EXP 79
12750: PUSH
12751: LD_STRING Simms
12753: PPUSH
12754: LD_EXP 1
12758: NOT
12759: PPUSH
12760: LD_STRING 10c_
12762: PPUSH
12763: CALL 69444 0 3
12767: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
12768: LD_EXP 79
12772: PPUSH
12773: LD_INT 4
12775: PPUSH
12776: CALL_OW 336
// if not Simms then
12780: LD_EXP 79
12784: NOT
12785: IFFALSE 12815
// begin uc_nation := 1 ;
12787: LD_ADDR_OWVAR 21
12791: PUSH
12792: LD_INT 1
12794: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12795: LD_INT 2
12797: PPUSH
12798: LD_INT 10
12800: PPUSH
12801: CALL_OW 384
// Simms := CreateHuman ;
12805: LD_ADDR_EXP 79
12809: PUSH
12810: CALL_OW 44
12814: ST_TO_ADDR
// end ; uc_nation := 3 ;
12815: LD_ADDR_OWVAR 21
12819: PUSH
12820: LD_INT 3
12822: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
12823: LD_ADDR_EXP 80
12827: PUSH
12828: LD_STRING Kirilenkova
12830: PPUSH
12831: CALL_OW 25
12835: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
12836: LD_ADDR_EXP 94
12840: PUSH
12841: LD_STRING Oblukov
12843: PPUSH
12844: CALL_OW 25
12848: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
12849: LD_ADDR_EXP 81
12853: PUSH
12854: LD_STRING Dolgov
12856: PPUSH
12857: CALL_OW 25
12861: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
12862: LD_ADDR_EXP 82
12866: PUSH
12867: LD_STRING Petrosyan
12869: PPUSH
12870: CALL_OW 25
12874: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
12875: LD_ADDR_EXP 93
12879: PUSH
12880: LD_STRING Scholtze
12882: PPUSH
12883: CALL_OW 25
12887: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
12888: LD_ADDR_EXP 92
12892: PUSH
12893: LD_STRING Kapitsova
12895: PPUSH
12896: CALL_OW 25
12900: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
12901: LD_ADDR_EXP 83
12905: PUSH
12906: LD_STRING Petrovova
12908: PPUSH
12909: CALL_OW 25
12913: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
12914: LD_ADDR_EXP 84
12918: PUSH
12919: LD_STRING Kuzmov
12921: PPUSH
12922: CALL_OW 25
12926: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
12927: LD_ADDR_EXP 91
12931: PUSH
12932: LD_STRING Karamazov
12934: PPUSH
12935: CALL_OW 25
12939: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
12940: LD_STRING 13_Lipshchin_1
12942: PPUSH
12943: LD_INT 0
12945: PPUSH
12946: CALL_OW 30
12950: IFFALSE 12965
// Lipshchin := NewCharacter ( Lipshchin ) ;
12952: LD_ADDR_EXP 85
12956: PUSH
12957: LD_STRING Lipshchin
12959: PPUSH
12960: CALL_OW 25
12964: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
12965: LD_STRING 13_Titov_1
12967: PPUSH
12968: LD_INT 0
12970: PPUSH
12971: CALL_OW 30
12975: IFFALSE 12990
// Titov := NewCharacter ( Titov ) ;
12977: LD_ADDR_EXP 87
12981: PUSH
12982: LD_STRING Titov
12984: PPUSH
12985: CALL_OW 25
12989: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
12990: LD_STRING 13_Gnyevko_1
12992: PPUSH
12993: LD_INT 0
12995: PPUSH
12996: CALL_OW 30
13000: IFFALSE 13015
// Gnyevko := NewCharacter ( Gnyevko ) ;
13002: LD_ADDR_EXP 86
13006: PUSH
13007: LD_STRING Gnyevko
13009: PPUSH
13010: CALL_OW 25
13014: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
13015: LD_STRING 13_Xavier_1
13017: PPUSH
13018: LD_INT 0
13020: PPUSH
13021: CALL_OW 30
13025: IFFALSE 13040
// Xavier := NewCharacter ( Xavier2 ) ;
13027: LD_ADDR_EXP 88
13031: PUSH
13032: LD_STRING Xavier2
13034: PPUSH
13035: CALL_OW 25
13039: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
13040: LD_STRING 13_Belkov_1
13042: PPUSH
13043: LD_INT 0
13045: PPUSH
13046: CALL_OW 30
13050: IFFALSE 13065
// Belkov := NewCharacter ( Belkov ) ;
13052: LD_ADDR_EXP 89
13056: PUSH
13057: LD_STRING Belkov
13059: PPUSH
13060: CALL_OW 25
13064: ST_TO_ADDR
// if not BurlakStatus then
13065: LD_EXP 9
13069: NOT
13070: IFFALSE 13085
// Burlak = NewCharacter ( Burlak ) ;
13072: LD_ADDR_EXP 90
13076: PUSH
13077: LD_STRING Burlak
13079: PPUSH
13080: CALL_OW 25
13084: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
13085: LD_ADDR_VAR 0 3
13089: PUSH
13090: LD_EXP 78
13094: PUSH
13095: LD_EXP 80
13099: PUSH
13100: LD_EXP 94
13104: PUSH
13105: LD_EXP 81
13109: PUSH
13110: LD_EXP 82
13114: PUSH
13115: LD_EXP 93
13119: PUSH
13120: LD_EXP 92
13124: PUSH
13125: LD_EXP 83
13129: PUSH
13130: LD_EXP 84
13134: PUSH
13135: LD_EXP 91
13139: PUSH
13140: EMPTY
13141: LIST
13142: LIST
13143: LIST
13144: LIST
13145: LIST
13146: LIST
13147: LIST
13148: LIST
13149: LIST
13150: LIST
13151: ST_TO_ADDR
// if Simms then
13152: LD_EXP 79
13156: IFFALSE 13174
// tmp := tmp ^ Simms ;
13158: LD_ADDR_VAR 0 3
13162: PUSH
13163: LD_VAR 0 3
13167: PUSH
13168: LD_EXP 79
13172: ADD
13173: ST_TO_ADDR
// if Titov then
13174: LD_EXP 87
13178: IFFALSE 13196
// tmp := tmp ^ Titov ;
13180: LD_ADDR_VAR 0 3
13184: PUSH
13185: LD_VAR 0 3
13189: PUSH
13190: LD_EXP 87
13194: ADD
13195: ST_TO_ADDR
// if Lipshchin then
13196: LD_EXP 85
13200: IFFALSE 13218
// tmp := tmp ^ Lipshchin ;
13202: LD_ADDR_VAR 0 3
13206: PUSH
13207: LD_VAR 0 3
13211: PUSH
13212: LD_EXP 85
13216: ADD
13217: ST_TO_ADDR
// if Gnyevko then
13218: LD_EXP 86
13222: IFFALSE 13240
// tmp := tmp ^ Gnyevko ;
13224: LD_ADDR_VAR 0 3
13228: PUSH
13229: LD_VAR 0 3
13233: PUSH
13234: LD_EXP 86
13238: ADD
13239: ST_TO_ADDR
// if Xavier then
13240: LD_EXP 88
13244: IFFALSE 13262
// tmp := tmp ^ Xavier ;
13246: LD_ADDR_VAR 0 3
13250: PUSH
13251: LD_VAR 0 3
13255: PUSH
13256: LD_EXP 88
13260: ADD
13261: ST_TO_ADDR
// if Belkov then
13262: LD_EXP 89
13266: IFFALSE 13284
// tmp := tmp ^ Belkov ;
13268: LD_ADDR_VAR 0 3
13272: PUSH
13273: LD_VAR 0 3
13277: PUSH
13278: LD_EXP 89
13282: ADD
13283: ST_TO_ADDR
// if Burlak then
13284: LD_EXP 90
13288: IFFALSE 13306
// tmp := tmp ^ Burlak ;
13290: LD_ADDR_VAR 0 3
13294: PUSH
13295: LD_VAR 0 3
13299: PUSH
13300: LD_EXP 90
13304: ADD
13305: ST_TO_ADDR
// for i = 1 to 11 do
13306: LD_ADDR_VAR 0 2
13310: PUSH
13311: DOUBLE
13312: LD_INT 1
13314: DEC
13315: ST_TO_ADDR
13316: LD_INT 11
13318: PUSH
13319: FOR_TO
13320: IFFALSE 13388
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
13322: LD_ADDR_OWVAR 21
13326: PUSH
13327: LD_INT 1
13329: PUSH
13330: LD_INT 3
13332: PUSH
13333: EMPTY
13334: LIST
13335: LIST
13336: PUSH
13337: LD_INT 1
13339: PPUSH
13340: LD_INT 2
13342: PPUSH
13343: CALL_OW 12
13347: ARRAY
13348: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 10 ) ;
13349: LD_INT 0
13351: PPUSH
13352: LD_INT 1
13354: PPUSH
13355: LD_INT 4
13357: PPUSH
13358: CALL_OW 12
13362: PPUSH
13363: LD_INT 10
13365: PPUSH
13366: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
13370: LD_ADDR_VAR 0 3
13374: PUSH
13375: LD_VAR 0 3
13379: PUSH
13380: CALL_OW 44
13384: ADD
13385: ST_TO_ADDR
// end ;
13386: GO 13319
13388: POP
13389: POP
// for i in tmp do
13390: LD_ADDR_VAR 0 2
13394: PUSH
13395: LD_VAR 0 3
13399: PUSH
13400: FOR_IN
13401: IFFALSE 13426
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
13403: LD_VAR 0 2
13407: PPUSH
13408: LD_INT 260
13410: PPUSH
13411: LD_INT 235
13413: PPUSH
13414: LD_INT 8
13416: PPUSH
13417: LD_INT 0
13419: PPUSH
13420: CALL_OW 50
13424: GO 13400
13426: POP
13427: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
13428: LD_ADDR_EXP 101
13432: PUSH
13433: LD_EXP 101
13437: PPUSH
13438: LD_INT 1
13440: PPUSH
13441: LD_INT 22
13443: PUSH
13444: LD_VAR 0 5
13448: PUSH
13449: EMPTY
13450: LIST
13451: LIST
13452: PUSH
13453: LD_INT 3
13455: PUSH
13456: LD_INT 21
13458: PUSH
13459: LD_INT 2
13461: PUSH
13462: EMPTY
13463: LIST
13464: LIST
13465: PUSH
13466: EMPTY
13467: LIST
13468: LIST
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PPUSH
13474: CALL_OW 69
13478: PUSH
13479: LD_EXP 78
13483: PUSH
13484: LD_EXP 79
13488: PUSH
13489: EMPTY
13490: LIST
13491: LIST
13492: DIFF
13493: PPUSH
13494: CALL_OW 1
13498: ST_TO_ADDR
// uc_side := 0 ;
13499: LD_ADDR_OWVAR 20
13503: PUSH
13504: LD_INT 0
13506: ST_TO_ADDR
// uc_nation := 0 ;
13507: LD_ADDR_OWVAR 21
13511: PUSH
13512: LD_INT 0
13514: ST_TO_ADDR
// for i = 1 to 5 do
13515: LD_ADDR_VAR 0 2
13519: PUSH
13520: DOUBLE
13521: LD_INT 1
13523: DEC
13524: ST_TO_ADDR
13525: LD_INT 5
13527: PUSH
13528: FOR_TO
13529: IFFALSE 13566
// begin InitHc ;
13531: CALL_OW 19
// hc_class := class_apeman ;
13535: LD_ADDR_OWVAR 28
13539: PUSH
13540: LD_INT 12
13542: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
13543: CALL_OW 44
13547: PPUSH
13548: LD_INT 299
13550: PPUSH
13551: LD_INT 229
13553: PPUSH
13554: LD_INT 10
13556: PPUSH
13557: LD_INT 0
13559: PPUSH
13560: CALL_OW 50
// end ;
13564: GO 13528
13566: POP
13567: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
13568: LD_EXP 78
13572: PPUSH
13573: LD_INT 259
13575: PPUSH
13576: LD_INT 235
13578: PPUSH
13579: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
13583: LD_EXP 78
13587: PPUSH
13588: LD_INT 262
13590: PPUSH
13591: LD_INT 235
13593: PPUSH
13594: CALL_OW 178
// if Simms then
13598: LD_EXP 79
13602: IFFALSE 13633
// begin ComMoveXY ( Simms , 262 , 235 ) ;
13604: LD_EXP 79
13608: PPUSH
13609: LD_INT 262
13611: PPUSH
13612: LD_INT 235
13614: PPUSH
13615: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
13619: LD_EXP 79
13623: PPUSH
13624: LD_EXP 78
13628: PPUSH
13629: CALL_OW 179
// end ; uc_side := 7 ;
13633: LD_ADDR_OWVAR 20
13637: PUSH
13638: LD_INT 7
13640: ST_TO_ADDR
// uc_nation := 1 ;
13641: LD_ADDR_OWVAR 21
13645: PUSH
13646: LD_INT 1
13648: ST_TO_ADDR
// bc_type := b_control_tower ;
13649: LD_ADDR_OWVAR 42
13653: PUSH
13654: LD_INT 36
13656: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 268 , 251 , 4 ) ;
13657: LD_ADDR_VAR 0 7
13661: PUSH
13662: LD_INT 268
13664: PPUSH
13665: LD_INT 251
13667: PPUSH
13668: LD_INT 4
13670: PPUSH
13671: CALL_OW 47
13675: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
13676: LD_INT 0
13678: PPUSH
13679: LD_INT 10
13681: PPUSH
13682: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , b ) ;
13686: CALL_OW 44
13690: PPUSH
13691: LD_VAR 0 7
13695: PPUSH
13696: CALL_OW 52
// end ;
13700: LD_VAR 0 1
13704: RET
// every 9 9$00 trigger allianceActive and not allianceDestroyed and FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_lab_full ] ] ) do var i , tmp , target ;
13705: LD_EXP 31
13709: PUSH
13710: LD_EXP 23
13714: NOT
13715: AND
13716: PUSH
13717: LD_INT 22
13719: PUSH
13720: LD_INT 7
13722: PUSH
13723: EMPTY
13724: LIST
13725: LIST
13726: PUSH
13727: LD_INT 30
13729: PUSH
13730: LD_INT 8
13732: PUSH
13733: EMPTY
13734: LIST
13735: LIST
13736: PUSH
13737: EMPTY
13738: LIST
13739: LIST
13740: PPUSH
13741: CALL_OW 69
13745: AND
13746: IFFALSE 13974
13748: GO 13750
13750: DISABLE
13751: LD_INT 0
13753: PPUSH
13754: PPUSH
13755: PPUSH
// begin enable ;
13756: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
13757: LD_ADDR_VAR 0 2
13761: PUSH
13762: LD_INT 81
13764: PUSH
13765: LD_INT 7
13767: PUSH
13768: EMPTY
13769: LIST
13770: LIST
13771: PUSH
13772: LD_INT 2
13774: PUSH
13775: LD_INT 32
13777: PUSH
13778: LD_INT 3
13780: PUSH
13781: EMPTY
13782: LIST
13783: LIST
13784: PUSH
13785: LD_INT 30
13787: PUSH
13788: LD_INT 30
13790: PUSH
13791: EMPTY
13792: LIST
13793: LIST
13794: PUSH
13795: LD_INT 30
13797: PUSH
13798: LD_INT 28
13800: PUSH
13801: EMPTY
13802: LIST
13803: LIST
13804: PUSH
13805: LD_INT 34
13807: PUSH
13808: LD_INT 49
13810: PUSH
13811: EMPTY
13812: LIST
13813: LIST
13814: PUSH
13815: LD_INT 34
13817: PUSH
13818: LD_INT 10
13820: PUSH
13821: EMPTY
13822: LIST
13823: LIST
13824: PUSH
13825: LD_INT 34
13827: PUSH
13828: LD_INT 8
13830: PUSH
13831: EMPTY
13832: LIST
13833: LIST
13834: PUSH
13835: EMPTY
13836: LIST
13837: LIST
13838: LIST
13839: LIST
13840: LIST
13841: LIST
13842: LIST
13843: PUSH
13844: EMPTY
13845: LIST
13846: LIST
13847: PPUSH
13848: CALL_OW 69
13852: ST_TO_ADDR
// if not tmp then
13853: LD_VAR 0 2
13857: NOT
13858: IFFALSE 13862
// exit ;
13860: GO 13974
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
13862: LD_VAR 0 2
13866: PPUSH
13867: LD_INT 34
13869: PUSH
13870: LD_INT 8
13872: PUSH
13873: EMPTY
13874: LIST
13875: LIST
13876: PPUSH
13877: CALL_OW 72
13881: IFFALSE 13914
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
13883: LD_ADDR_VAR 0 3
13887: PUSH
13888: LD_VAR 0 2
13892: PPUSH
13893: LD_INT 34
13895: PUSH
13896: LD_INT 8
13898: PUSH
13899: EMPTY
13900: LIST
13901: LIST
13902: PPUSH
13903: CALL_OW 72
13907: PUSH
13908: LD_INT 1
13910: ARRAY
13911: ST_TO_ADDR
13912: GO 13938
// target := tmp [ rand ( 1 , tmp ) ] ;
13914: LD_ADDR_VAR 0 3
13918: PUSH
13919: LD_VAR 0 2
13923: PUSH
13924: LD_INT 1
13926: PPUSH
13927: LD_VAR 0 2
13931: PPUSH
13932: CALL_OW 12
13936: ARRAY
13937: ST_TO_ADDR
// if GetSide ( target ) = 1 then
13938: LD_VAR 0 3
13942: PPUSH
13943: CALL_OW 255
13947: PUSH
13948: LD_INT 1
13950: EQUAL
13951: IFFALSE 13962
// CenterNowOnUnits ( target ) ;
13953: LD_VAR 0 3
13957: PPUSH
13958: CALL_OW 87
// SetLives ( target , 0 ) ;
13962: LD_VAR 0 3
13966: PPUSH
13967: LD_INT 0
13969: PPUSH
13970: CALL_OW 234
// end ;
13974: PPOPN 3
13976: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
13977: LD_EXP 23
13981: NOT
13982: PUSH
13983: LD_EXP 31
13987: AND
13988: IFFALSE 14504
13990: GO 13992
13992: DISABLE
13993: LD_INT 0
13995: PPUSH
13996: PPUSH
13997: PPUSH
// begin uc_side := 7 ;
13998: LD_ADDR_OWVAR 20
14002: PUSH
14003: LD_INT 7
14005: ST_TO_ADDR
// uc_nation := 1 ;
14006: LD_ADDR_OWVAR 21
14010: PUSH
14011: LD_INT 1
14013: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] , [ 94 , 114 ] ] ) ;
14014: LD_ADDR_VAR 0 3
14018: PUSH
14019: LD_INT 125
14021: PUSH
14022: LD_INT 163
14024: PUSH
14025: EMPTY
14026: LIST
14027: LIST
14028: PUSH
14029: LD_INT 185
14031: PUSH
14032: LD_INT 168
14034: PUSH
14035: EMPTY
14036: LIST
14037: LIST
14038: PUSH
14039: LD_INT 111
14041: PUSH
14042: LD_INT 97
14044: PUSH
14045: EMPTY
14046: LIST
14047: LIST
14048: PUSH
14049: LD_INT 94
14051: PUSH
14052: LD_INT 114
14054: PUSH
14055: EMPTY
14056: LIST
14057: LIST
14058: PUSH
14059: EMPTY
14060: LIST
14061: LIST
14062: LIST
14063: LIST
14064: PPUSH
14065: CALL 107240 0 1
14069: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
14070: LD_ADDR_EXP 95
14074: PUSH
14075: EMPTY
14076: ST_TO_ADDR
// for i = 1 to Difficulty do
14077: LD_ADDR_VAR 0 1
14081: PUSH
14082: DOUBLE
14083: LD_INT 1
14085: DEC
14086: ST_TO_ADDR
14087: LD_OWVAR 67
14091: PUSH
14092: FOR_TO
14093: IFFALSE 14251
// begin InitHc ;
14095: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
14099: LD_INT 0
14101: PPUSH
14102: LD_INT 8
14104: PPUSH
14105: CALL_OW 381
// un := CreateHuman ;
14109: LD_ADDR_VAR 0 2
14113: PUSH
14114: CALL_OW 44
14118: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
14119: LD_VAR 0 2
14123: PPUSH
14124: LD_INT 258
14126: PPUSH
14127: LD_INT 267
14129: PPUSH
14130: LD_INT 4
14132: PPUSH
14133: LD_INT 0
14135: PPUSH
14136: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
14140: LD_ADDR_EXP 95
14144: PUSH
14145: LD_EXP 95
14149: PUSH
14150: LD_VAR 0 2
14154: UNION
14155: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
14156: LD_VAR 0 2
14160: PPUSH
14161: LD_VAR 0 3
14165: PUSH
14166: LD_VAR 0 1
14170: ARRAY
14171: PUSH
14172: LD_INT 1
14174: ARRAY
14175: PPUSH
14176: LD_VAR 0 3
14180: PUSH
14181: LD_VAR 0 1
14185: ARRAY
14186: PUSH
14187: LD_INT 2
14189: ARRAY
14190: PPUSH
14191: LD_INT 4
14193: PPUSH
14194: LD_INT 1
14196: PPUSH
14197: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
14201: LD_VAR 0 2
14205: PPUSH
14206: LD_VAR 0 3
14210: PUSH
14211: LD_VAR 0 1
14215: ARRAY
14216: PUSH
14217: LD_INT 1
14219: ARRAY
14220: PPUSH
14221: LD_VAR 0 3
14225: PUSH
14226: LD_VAR 0 1
14230: ARRAY
14231: PUSH
14232: LD_INT 2
14234: ARRAY
14235: PPUSH
14236: CALL_OW 171
// AddComInvisible ( un ) ;
14240: LD_VAR 0 2
14244: PPUSH
14245: CALL_OW 212
// end ;
14249: GO 14092
14251: POP
14252: POP
// repeat wait ( 0 0$45 ) ;
14253: LD_INT 1575
14255: PPUSH
14256: CALL_OW 67
// for i in allianceSpecialForce do
14260: LD_ADDR_VAR 0 1
14264: PUSH
14265: LD_EXP 95
14269: PUSH
14270: FOR_IN
14271: IFFALSE 14489
// begin if IsInvisible ( i ) then
14273: LD_VAR 0 1
14277: PPUSH
14278: CALL_OW 571
14282: IFFALSE 14458
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , 25 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
14284: LD_ADDR_VAR 0 3
14288: PUSH
14289: LD_INT 22
14291: PUSH
14292: LD_INT 1
14294: PUSH
14295: EMPTY
14296: LIST
14297: LIST
14298: PUSH
14299: LD_INT 50
14301: PUSH
14302: EMPTY
14303: LIST
14304: PUSH
14305: LD_INT 56
14307: PUSH
14308: EMPTY
14309: LIST
14310: PUSH
14311: LD_INT 91
14313: PUSH
14314: LD_VAR 0 1
14318: PUSH
14319: LD_INT 25
14321: PUSH
14322: EMPTY
14323: LIST
14324: LIST
14325: LIST
14326: PUSH
14327: LD_INT 2
14329: PUSH
14330: LD_INT 25
14332: PUSH
14333: LD_INT 1
14335: PUSH
14336: EMPTY
14337: LIST
14338: LIST
14339: PUSH
14340: LD_INT 25
14342: PUSH
14343: LD_INT 2
14345: PUSH
14346: EMPTY
14347: LIST
14348: LIST
14349: PUSH
14350: LD_INT 25
14352: PUSH
14353: LD_INT 3
14355: PUSH
14356: EMPTY
14357: LIST
14358: LIST
14359: PUSH
14360: LD_INT 25
14362: PUSH
14363: LD_INT 4
14365: PUSH
14366: EMPTY
14367: LIST
14368: LIST
14369: PUSH
14370: LD_INT 25
14372: PUSH
14373: LD_INT 5
14375: PUSH
14376: EMPTY
14377: LIST
14378: LIST
14379: PUSH
14380: LD_INT 25
14382: PUSH
14383: LD_INT 8
14385: PUSH
14386: EMPTY
14387: LIST
14388: LIST
14389: PUSH
14390: EMPTY
14391: LIST
14392: LIST
14393: LIST
14394: LIST
14395: LIST
14396: LIST
14397: LIST
14398: PUSH
14399: EMPTY
14400: LIST
14401: LIST
14402: LIST
14403: LIST
14404: LIST
14405: PPUSH
14406: CALL_OW 69
14410: ST_TO_ADDR
// if not tmp then
14411: LD_VAR 0 3
14415: NOT
14416: IFFALSE 14420
// continue ;
14418: GO 14270
// if Prob ( 30 * Difficulty ) then
14420: LD_INT 30
14422: PUSH
14423: LD_OWVAR 67
14427: MUL
14428: PPUSH
14429: CALL_OW 13
14433: IFFALSE 14458
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
14435: LD_VAR 0 3
14439: PUSH
14440: LD_INT 1
14442: PPUSH
14443: LD_VAR 0 3
14447: PPUSH
14448: CALL_OW 12
14452: ARRAY
14453: PPUSH
14454: CALL 34540 0 1
// end ; if IsDead ( i ) then
14458: LD_VAR 0 1
14462: PPUSH
14463: CALL_OW 301
14467: IFFALSE 14487
// begin allianceSpecialForce := allianceSpecialForce diff i ;
14469: LD_ADDR_EXP 95
14473: PUSH
14474: LD_EXP 95
14478: PUSH
14479: LD_VAR 0 1
14483: DIFF
14484: ST_TO_ADDR
// continue ;
14485: GO 14270
// end ; end ;
14487: GO 14270
14489: POP
14490: POP
// until allianceDestroyed or not allianceSpecialForce ;
14491: LD_EXP 23
14495: PUSH
14496: LD_EXP 95
14500: NOT
14501: OR
14502: IFFALSE 14253
// end ;
14504: PPOPN 3
14506: END
// every 0 0$30 trigger allianceActive and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_bweapon , us_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ] ) do var i , un , tmp , e ;
14507: LD_EXP 31
14511: PUSH
14512: LD_INT 22
14514: PUSH
14515: LD_INT 1
14517: PUSH
14518: EMPTY
14519: LIST
14520: LIST
14521: PUSH
14522: LD_INT 2
14524: PUSH
14525: LD_INT 35
14527: PUSH
14528: LD_INT 8
14530: PUSH
14531: EMPTY
14532: LIST
14533: LIST
14534: PUSH
14535: LD_INT 34
14537: PUSH
14538: LD_INT 8
14540: PUSH
14541: EMPTY
14542: LIST
14543: LIST
14544: PUSH
14545: EMPTY
14546: LIST
14547: LIST
14548: LIST
14549: PUSH
14550: EMPTY
14551: LIST
14552: LIST
14553: PPUSH
14554: CALL_OW 69
14558: AND
14559: IFFALSE 14959
14561: GO 14563
14563: DISABLE
14564: LD_INT 0
14566: PPUSH
14567: PPUSH
14568: PPUSH
14569: PPUSH
// begin for i := 1 to [ 6 , 8 , 10 , 12 ] [ Difficulty ] do
14570: LD_ADDR_VAR 0 1
14574: PUSH
14575: DOUBLE
14576: LD_INT 1
14578: DEC
14579: ST_TO_ADDR
14580: LD_INT 6
14582: PUSH
14583: LD_INT 8
14585: PUSH
14586: LD_INT 10
14588: PUSH
14589: LD_INT 12
14591: PUSH
14592: EMPTY
14593: LIST
14594: LIST
14595: LIST
14596: LIST
14597: PUSH
14598: LD_OWVAR 67
14602: ARRAY
14603: PUSH
14604: FOR_TO
14605: IFFALSE 14797
// begin uc_side := 7 ;
14607: LD_ADDR_OWVAR 20
14611: PUSH
14612: LD_INT 7
14614: ST_TO_ADDR
// uc_nation := 1 ;
14615: LD_ADDR_OWVAR 21
14619: PUSH
14620: LD_INT 1
14622: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , [ control_remote , control_computer ] [ rand ( 1 , 2 ) ] , [ us_heavy_gun , us_laser ] [ rand ( 1 , 2 ) ] , 100 ) ;
14623: LD_INT 5
14625: PPUSH
14626: LD_INT 3
14628: PPUSH
14629: LD_INT 2
14631: PUSH
14632: LD_INT 3
14634: PUSH
14635: EMPTY
14636: LIST
14637: LIST
14638: PUSH
14639: LD_INT 1
14641: PPUSH
14642: LD_INT 2
14644: PPUSH
14645: CALL_OW 12
14649: ARRAY
14650: PPUSH
14651: LD_INT 6
14653: PUSH
14654: LD_INT 9
14656: PUSH
14657: EMPTY
14658: LIST
14659: LIST
14660: PUSH
14661: LD_INT 1
14663: PPUSH
14664: LD_INT 2
14666: PPUSH
14667: CALL_OW 12
14671: ARRAY
14672: PPUSH
14673: LD_INT 100
14675: PPUSH
14676: CALL 74284 0 5
// un := CreateVehicle ;
14680: LD_ADDR_VAR 0 2
14684: PUSH
14685: CALL_OW 45
14689: ST_TO_ADDR
// SetDir ( un , 4 ) ;
14690: LD_VAR 0 2
14694: PPUSH
14695: LD_INT 4
14697: PPUSH
14698: CALL_OW 233
// PlaceUnitXYR ( un , 307 , 219 , 6 , false ) ;
14702: LD_VAR 0 2
14706: PPUSH
14707: LD_INT 307
14709: PPUSH
14710: LD_INT 219
14712: PPUSH
14713: LD_INT 6
14715: PPUSH
14716: LD_INT 0
14718: PPUSH
14719: CALL_OW 50
// if GetControl ( un ) = control_remote then
14723: LD_VAR 0 2
14727: PPUSH
14728: CALL_OW 263
14732: PUSH
14733: LD_INT 2
14735: EQUAL
14736: IFFALSE 14747
// Connect ( un ) ;
14738: LD_VAR 0 2
14742: PPUSH
14743: CALL 77752 0 1
// TeleportUnit ( un , 124 , 92 , 12 , true ) ;
14747: LD_VAR 0 2
14751: PPUSH
14752: LD_INT 124
14754: PPUSH
14755: LD_INT 92
14757: PPUSH
14758: LD_INT 12
14760: PPUSH
14761: LD_INT 1
14763: PPUSH
14764: CALL_OW 483
// tmp := Join ( tmp , un ) ;
14768: LD_ADDR_VAR 0 3
14772: PUSH
14773: LD_VAR 0 3
14777: PPUSH
14778: LD_VAR 0 2
14782: PPUSH
14783: CALL 107135 0 2
14787: ST_TO_ADDR
// wait ( 0 0$0.3 ) ;
14788: LD_INT 10
14790: PPUSH
14791: CALL_OW 67
// end ;
14795: GO 14604
14797: POP
14798: POP
// repeat wait ( 0 0$2 ) ;
14799: LD_INT 70
14801: PPUSH
14802: CALL_OW 67
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) ;
14806: LD_ADDR_VAR 0 4
14810: PUSH
14811: LD_INT 22
14813: PUSH
14814: LD_INT 1
14816: PUSH
14817: EMPTY
14818: LIST
14819: LIST
14820: PUSH
14821: LD_INT 34
14823: PUSH
14824: LD_INT 8
14826: PUSH
14827: EMPTY
14828: LIST
14829: LIST
14830: PUSH
14831: EMPTY
14832: LIST
14833: LIST
14834: PPUSH
14835: CALL_OW 69
14839: ST_TO_ADDR
// if not e then
14840: LD_VAR 0 4
14844: NOT
14845: IFFALSE 14881
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
14847: LD_ADDR_VAR 0 4
14851: PUSH
14852: LD_INT 22
14854: PUSH
14855: LD_INT 1
14857: PUSH
14858: EMPTY
14859: LIST
14860: LIST
14861: PUSH
14862: LD_INT 21
14864: PUSH
14865: LD_INT 2
14867: PUSH
14868: EMPTY
14869: LIST
14870: LIST
14871: PUSH
14872: EMPTY
14873: LIST
14874: LIST
14875: PPUSH
14876: CALL_OW 69
14880: ST_TO_ADDR
// for i in tmp do
14881: LD_ADDR_VAR 0 1
14885: PUSH
14886: LD_VAR 0 3
14890: PUSH
14891: FOR_IN
14892: IFFALSE 14950
// if not IsOK ( i ) then
14894: LD_VAR 0 1
14898: PPUSH
14899: CALL_OW 302
14903: NOT
14904: IFFALSE 14924
// tmp := tmp diff i else
14906: LD_ADDR_VAR 0 3
14910: PUSH
14911: LD_VAR 0 3
14915: PUSH
14916: LD_VAR 0 1
14920: DIFF
14921: ST_TO_ADDR
14922: GO 14948
// ComAttackUnit ( i , NearestUnitToUnit ( e , i ) ) ;
14924: LD_VAR 0 1
14928: PPUSH
14929: LD_VAR 0 4
14933: PPUSH
14934: LD_VAR 0 1
14938: PPUSH
14939: CALL_OW 74
14943: PPUSH
14944: CALL_OW 115
14948: GO 14891
14950: POP
14951: POP
// until not tmp ;
14952: LD_VAR 0 3
14956: NOT
14957: IFFALSE 14799
// end ;
14959: PPOPN 4
14961: END
// every 8 8$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport , p ;
14962: LD_EXP 23
14966: NOT
14967: PUSH
14968: LD_EXP 31
14972: AND
14973: IFFALSE 16026
14975: GO 14977
14977: DISABLE
14978: LD_INT 0
14980: PPUSH
14981: PPUSH
14982: PPUSH
14983: PPUSH
14984: PPUSH
// begin enable ;
14985: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
14986: LD_INT 22
14988: PUSH
14989: LD_INT 7
14991: PUSH
14992: EMPTY
14993: LIST
14994: LIST
14995: PUSH
14996: LD_INT 30
14998: PUSH
14999: LD_INT 3
15001: PUSH
15002: EMPTY
15003: LIST
15004: LIST
15005: PUSH
15006: EMPTY
15007: LIST
15008: LIST
15009: PPUSH
15010: CALL_OW 69
15014: NOT
15015: IFFALSE 15019
// exit ;
15017: GO 16026
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
15019: LD_ADDR_VAR 0 4
15023: PUSH
15024: LD_INT 22
15026: PUSH
15027: LD_INT 7
15029: PUSH
15030: EMPTY
15031: LIST
15032: LIST
15033: PUSH
15034: LD_INT 30
15036: PUSH
15037: LD_INT 34
15039: PUSH
15040: EMPTY
15041: LIST
15042: LIST
15043: PUSH
15044: EMPTY
15045: LIST
15046: LIST
15047: PPUSH
15048: CALL_OW 69
15052: ST_TO_ADDR
// if Prob ( 40 ) then
15053: LD_INT 40
15055: PPUSH
15056: CALL_OW 13
15060: IFFALSE 15206
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
15062: LD_INT 1
15064: PPUSH
15065: LD_INT 5
15067: PUSH
15068: LD_INT 3
15070: PUSH
15071: LD_INT 2
15073: PUSH
15074: LD_INT 6
15076: PUSH
15077: EMPTY
15078: LIST
15079: LIST
15080: LIST
15081: LIST
15082: PUSH
15083: LD_INT 5
15085: PUSH
15086: LD_INT 3
15088: PUSH
15089: LD_INT 2
15091: PUSH
15092: LD_INT 6
15094: PUSH
15095: EMPTY
15096: LIST
15097: LIST
15098: LIST
15099: LIST
15100: PUSH
15101: LD_INT 5
15103: PUSH
15104: LD_INT 3
15106: PUSH
15107: LD_INT 2
15109: PUSH
15110: LD_INT 6
15112: PUSH
15113: EMPTY
15114: LIST
15115: LIST
15116: LIST
15117: LIST
15118: PUSH
15119: LD_INT 5
15121: PUSH
15122: LD_INT 3
15124: PUSH
15125: LD_INT 2
15127: PUSH
15128: LD_INT 9
15130: PUSH
15131: EMPTY
15132: LIST
15133: LIST
15134: LIST
15135: LIST
15136: PUSH
15137: LD_INT 24
15139: PUSH
15140: LD_INT 3
15142: PUSH
15143: LD_INT 3
15145: PUSH
15146: LD_INT 45
15148: PUSH
15149: EMPTY
15150: LIST
15151: LIST
15152: LIST
15153: LIST
15154: PUSH
15155: LD_INT 24
15157: PUSH
15158: LD_INT 3
15160: PUSH
15161: LD_INT 3
15163: PUSH
15164: LD_INT 47
15166: PUSH
15167: EMPTY
15168: LIST
15169: LIST
15170: LIST
15171: LIST
15172: PUSH
15173: LD_INT 24
15175: PUSH
15176: LD_INT 3
15178: PUSH
15179: LD_INT 3
15181: PUSH
15182: LD_INT 45
15184: PUSH
15185: EMPTY
15186: LIST
15187: LIST
15188: LIST
15189: LIST
15190: PUSH
15191: EMPTY
15192: LIST
15193: LIST
15194: LIST
15195: LIST
15196: LIST
15197: LIST
15198: LIST
15199: PPUSH
15200: CALL 63018 0 2
// end else
15204: GO 15348
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
15206: LD_INT 1
15208: PPUSH
15209: LD_INT 24
15211: PUSH
15212: LD_INT 3
15214: PUSH
15215: LD_INT 3
15217: PUSH
15218: LD_INT 47
15220: PUSH
15221: EMPTY
15222: LIST
15223: LIST
15224: LIST
15225: LIST
15226: PUSH
15227: LD_INT 24
15229: PUSH
15230: LD_INT 3
15232: PUSH
15233: LD_INT 3
15235: PUSH
15236: LD_INT 47
15238: PUSH
15239: EMPTY
15240: LIST
15241: LIST
15242: LIST
15243: LIST
15244: PUSH
15245: LD_INT 5
15247: PUSH
15248: LD_INT 3
15250: PUSH
15251: LD_INT 2
15253: PUSH
15254: LD_INT 9
15256: PUSH
15257: EMPTY
15258: LIST
15259: LIST
15260: LIST
15261: LIST
15262: PUSH
15263: LD_INT 5
15265: PUSH
15266: LD_INT 3
15268: PUSH
15269: LD_INT 2
15271: PUSH
15272: LD_INT 9
15274: PUSH
15275: EMPTY
15276: LIST
15277: LIST
15278: LIST
15279: LIST
15280: PUSH
15281: LD_INT 5
15283: PUSH
15284: LD_INT 3
15286: PUSH
15287: LD_INT 2
15289: PUSH
15290: LD_INT 9
15292: PUSH
15293: EMPTY
15294: LIST
15295: LIST
15296: LIST
15297: LIST
15298: PUSH
15299: LD_INT 24
15301: PUSH
15302: LD_INT 1
15304: PUSH
15305: LD_INT 3
15307: PUSH
15308: LD_INT 45
15310: PUSH
15311: EMPTY
15312: LIST
15313: LIST
15314: LIST
15315: LIST
15316: PUSH
15317: LD_INT 24
15319: PUSH
15320: LD_INT 1
15322: PUSH
15323: LD_INT 3
15325: PUSH
15326: LD_INT 45
15328: PUSH
15329: EMPTY
15330: LIST
15331: LIST
15332: LIST
15333: LIST
15334: PUSH
15335: EMPTY
15336: LIST
15337: LIST
15338: LIST
15339: LIST
15340: LIST
15341: LIST
15342: LIST
15343: PPUSH
15344: CALL 63018 0 2
// end ; wait ( 2 2$00 ) ;
15348: LD_INT 4200
15350: PPUSH
15351: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_crane ] , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 1 ] ;
15355: LD_ADDR_VAR 0 2
15359: PUSH
15360: LD_INT 22
15362: PUSH
15363: LD_INT 7
15365: PUSH
15366: EMPTY
15367: LIST
15368: LIST
15369: PUSH
15370: LD_INT 21
15372: PUSH
15373: LD_INT 2
15375: PUSH
15376: EMPTY
15377: LIST
15378: LIST
15379: PUSH
15380: LD_INT 3
15382: PUSH
15383: LD_INT 34
15385: PUSH
15386: LD_INT 13
15388: PUSH
15389: EMPTY
15390: LIST
15391: LIST
15392: PUSH
15393: LD_INT 34
15395: PUSH
15396: LD_INT 12
15398: PUSH
15399: EMPTY
15400: LIST
15401: LIST
15402: PUSH
15403: LD_INT 34
15405: PUSH
15406: LD_INT 51
15408: PUSH
15409: EMPTY
15410: LIST
15411: LIST
15412: PUSH
15413: LD_INT 34
15415: PUSH
15416: LD_INT 52
15418: PUSH
15419: EMPTY
15420: LIST
15421: LIST
15422: PUSH
15423: EMPTY
15424: LIST
15425: LIST
15426: LIST
15427: LIST
15428: LIST
15429: PUSH
15430: EMPTY
15431: LIST
15432: LIST
15433: LIST
15434: PPUSH
15435: CALL_OW 69
15439: PUSH
15440: LD_EXP 123
15444: PUSH
15445: LD_INT 1
15447: ARRAY
15448: DIFF
15449: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
15450: LD_ADDR_EXP 120
15454: PUSH
15455: LD_EXP 120
15459: PPUSH
15460: LD_INT 1
15462: PPUSH
15463: LD_EXP 120
15467: PUSH
15468: LD_INT 1
15470: ARRAY
15471: PUSH
15472: LD_VAR 0 2
15476: DIFF
15477: PPUSH
15478: CALL_OW 1
15482: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
15483: LD_ADDR_VAR 0 3
15487: PUSH
15488: LD_INT 0
15490: PPUSH
15491: LD_INT 1
15493: PPUSH
15494: CALL_OW 12
15498: ST_TO_ADDR
// p := 0 ;
15499: LD_ADDR_VAR 0 5
15503: PUSH
15504: LD_INT 0
15506: ST_TO_ADDR
// if target then
15507: LD_VAR 0 3
15511: IFFALSE 15702
// begin for i in tmp do
15513: LD_ADDR_VAR 0 1
15517: PUSH
15518: LD_VAR 0 2
15522: PUSH
15523: FOR_IN
15524: IFFALSE 15549
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
15526: LD_VAR 0 1
15530: PPUSH
15531: LD_INT 179
15533: PPUSH
15534: LD_INT 209
15536: PPUSH
15537: LD_INT 8
15539: PPUSH
15540: LD_INT 1
15542: PPUSH
15543: CALL_OW 483
15547: GO 15523
15549: POP
15550: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15551: LD_ADDR_VAR 0 2
15555: PUSH
15556: LD_VAR 0 2
15560: PPUSH
15561: LD_INT 24
15563: PUSH
15564: LD_INT 250
15566: PUSH
15567: EMPTY
15568: LIST
15569: LIST
15570: PPUSH
15571: CALL_OW 72
15575: ST_TO_ADDR
// for i in tmp do
15576: LD_ADDR_VAR 0 1
15580: PUSH
15581: LD_VAR 0 2
15585: PUSH
15586: FOR_IN
15587: IFFALSE 15627
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
15589: LD_VAR 0 1
15593: PPUSH
15594: LD_INT 179
15596: PPUSH
15597: LD_INT 209
15599: PPUSH
15600: CALL_OW 297
15604: PUSH
15605: LD_INT 9
15607: GREATER
15608: IFFALSE 15625
// ComMoveXY ( i , 179 , 209 ) ;
15610: LD_VAR 0 1
15614: PPUSH
15615: LD_INT 179
15617: PPUSH
15618: LD_INT 209
15620: PPUSH
15621: CALL_OW 111
15625: GO 15586
15627: POP
15628: POP
// wait ( 0 0$1 ) ;
15629: LD_INT 35
15631: PPUSH
15632: CALL_OW 67
// p := Inc ( p ) ;
15636: LD_ADDR_VAR 0 5
15640: PUSH
15641: LD_VAR 0 5
15645: PPUSH
15646: CALL 108496 0 1
15650: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
15651: LD_VAR 0 2
15655: PPUSH
15656: LD_INT 92
15658: PUSH
15659: LD_INT 179
15661: PUSH
15662: LD_INT 209
15664: PUSH
15665: LD_INT 9
15667: PUSH
15668: EMPTY
15669: LIST
15670: LIST
15671: LIST
15672: LIST
15673: PPUSH
15674: CALL_OW 72
15678: PUSH
15679: LD_VAR 0 2
15683: PUSH
15684: LD_INT 1
15686: MINUS
15687: GREATEREQUAL
15688: PUSH
15689: LD_VAR 0 5
15693: PUSH
15694: LD_INT 30
15696: GREATER
15697: OR
15698: IFFALSE 15551
// end else
15700: GO 15889
// begin for i in tmp do
15702: LD_ADDR_VAR 0 1
15706: PUSH
15707: LD_VAR 0 2
15711: PUSH
15712: FOR_IN
15713: IFFALSE 15738
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
15715: LD_VAR 0 1
15719: PPUSH
15720: LD_INT 285
15722: PPUSH
15723: LD_INT 163
15725: PPUSH
15726: LD_INT 8
15728: PPUSH
15729: LD_INT 1
15731: PPUSH
15732: CALL_OW 483
15736: GO 15712
15738: POP
15739: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15740: LD_ADDR_VAR 0 2
15744: PUSH
15745: LD_VAR 0 2
15749: PPUSH
15750: LD_INT 24
15752: PUSH
15753: LD_INT 250
15755: PUSH
15756: EMPTY
15757: LIST
15758: LIST
15759: PPUSH
15760: CALL_OW 72
15764: ST_TO_ADDR
// for i in tmp do
15765: LD_ADDR_VAR 0 1
15769: PUSH
15770: LD_VAR 0 2
15774: PUSH
15775: FOR_IN
15776: IFFALSE 15816
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
15778: LD_VAR 0 1
15782: PPUSH
15783: LD_INT 285
15785: PPUSH
15786: LD_INT 163
15788: PPUSH
15789: CALL_OW 297
15793: PUSH
15794: LD_INT 9
15796: GREATER
15797: IFFALSE 15814
// ComMoveXY ( i , 285 , 163 ) ;
15799: LD_VAR 0 1
15803: PPUSH
15804: LD_INT 285
15806: PPUSH
15807: LD_INT 163
15809: PPUSH
15810: CALL_OW 111
15814: GO 15775
15816: POP
15817: POP
// wait ( 0 0$1 ) ;
15818: LD_INT 35
15820: PPUSH
15821: CALL_OW 67
// p := Inc ( p ) ;
15825: LD_ADDR_VAR 0 5
15829: PUSH
15830: LD_VAR 0 5
15834: PPUSH
15835: CALL 108496 0 1
15839: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
15840: LD_VAR 0 2
15844: PPUSH
15845: LD_INT 92
15847: PUSH
15848: LD_INT 285
15850: PUSH
15851: LD_INT 163
15853: PUSH
15854: LD_INT 9
15856: PUSH
15857: EMPTY
15858: LIST
15859: LIST
15860: LIST
15861: LIST
15862: PPUSH
15863: CALL_OW 72
15867: PUSH
15868: LD_VAR 0 2
15872: PUSH
15873: LD_INT 1
15875: MINUS
15876: GREATEREQUAL
15877: PUSH
15878: LD_VAR 0 5
15882: PUSH
15883: LD_INT 30
15885: GREATER
15886: OR
15887: IFFALSE 15740
// end ; repeat wait ( 0 0$1 ) ;
15889: LD_INT 35
15891: PPUSH
15892: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
15896: LD_ADDR_VAR 0 2
15900: PUSH
15901: LD_VAR 0 2
15905: PPUSH
15906: LD_INT 50
15908: PUSH
15909: EMPTY
15910: LIST
15911: PPUSH
15912: CALL_OW 72
15916: ST_TO_ADDR
// for i in tmp do
15917: LD_ADDR_VAR 0 1
15921: PUSH
15922: LD_VAR 0 2
15926: PUSH
15927: FOR_IN
15928: IFFALSE 16017
// if GetWeapon ( i ) = ru_time_lapser then
15930: LD_VAR 0 1
15934: PPUSH
15935: CALL_OW 264
15939: PUSH
15940: LD_INT 49
15942: EQUAL
15943: IFFALSE 15981
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
15945: LD_VAR 0 1
15949: PPUSH
15950: LD_INT 81
15952: PUSH
15953: LD_INT 7
15955: PUSH
15956: EMPTY
15957: LIST
15958: LIST
15959: PPUSH
15960: CALL_OW 69
15964: PPUSH
15965: LD_VAR 0 1
15969: PPUSH
15970: CALL_OW 74
15974: PPUSH
15975: CALL_OW 112
15979: GO 16015
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
15981: LD_VAR 0 1
15985: PPUSH
15986: LD_INT 81
15988: PUSH
15989: LD_INT 7
15991: PUSH
15992: EMPTY
15993: LIST
15994: LIST
15995: PPUSH
15996: CALL_OW 69
16000: PPUSH
16001: LD_VAR 0 1
16005: PPUSH
16006: CALL_OW 74
16010: PPUSH
16011: CALL_OW 115
16015: GO 15927
16017: POP
16018: POP
// until not tmp ;
16019: LD_VAR 0 2
16023: NOT
16024: IFFALSE 15889
// end ;
16026: PPOPN 5
16028: END
// every 1 1$30 trigger allianceActive and IsOk ( Roth ) and Difficulty > 2 do
16029: LD_EXP 31
16033: PUSH
16034: LD_EXP 78
16038: PPUSH
16039: CALL_OW 302
16043: AND
16044: PUSH
16045: LD_OWVAR 67
16049: PUSH
16050: LD_INT 2
16052: GREATER
16053: AND
16054: IFFALSE 16154
16056: GO 16058
16058: DISABLE
// begin enable ;
16059: ENABLE
// if GetDistUnitXY ( Roth , 245 , 234 ) > 6 then
16060: LD_EXP 78
16064: PPUSH
16065: LD_INT 245
16067: PPUSH
16068: LD_INT 234
16070: PPUSH
16071: CALL_OW 297
16075: PUSH
16076: LD_INT 6
16078: GREATER
16079: IFFALSE 16098
// ComMoveXY ( Roth , 245 , 234 ) else
16081: LD_EXP 78
16085: PPUSH
16086: LD_INT 245
16088: PPUSH
16089: LD_INT 234
16091: PPUSH
16092: CALL_OW 111
16096: GO 16154
// ComMoveHex ( Roth , [ [ 259 , 235 ] , [ 252 , 209 ] , [ 275 , 235 ] ] [ rand ( 1 , 3 ) ] ) ;
16098: LD_EXP 78
16102: PPUSH
16103: LD_INT 259
16105: PUSH
16106: LD_INT 235
16108: PUSH
16109: EMPTY
16110: LIST
16111: LIST
16112: PUSH
16113: LD_INT 252
16115: PUSH
16116: LD_INT 209
16118: PUSH
16119: EMPTY
16120: LIST
16121: LIST
16122: PUSH
16123: LD_INT 275
16125: PUSH
16126: LD_INT 235
16128: PUSH
16129: EMPTY
16130: LIST
16131: LIST
16132: PUSH
16133: EMPTY
16134: LIST
16135: LIST
16136: LIST
16137: PUSH
16138: LD_INT 1
16140: PPUSH
16141: LD_INT 3
16143: PPUSH
16144: CALL_OW 12
16148: ARRAY
16149: PPUSH
16150: CALL 111137 0 2
// end ; end_of_file
16154: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
16155: LD_INT 0
16157: PPUSH
16158: PPUSH
16159: PPUSH
16160: PPUSH
// missionStage := 13 ;
16161: LD_ADDR_EXP 15
16165: PUSH
16166: LD_INT 13
16168: ST_TO_ADDR
// uc_side := 2 ;
16169: LD_ADDR_OWVAR 20
16173: PUSH
16174: LD_INT 2
16176: ST_TO_ADDR
// uc_nation := 2 ;
16177: LD_ADDR_OWVAR 21
16181: PUSH
16182: LD_INT 2
16184: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
16185: LD_ADDR_EXP 96
16189: PUSH
16190: LD_STRING Omar
16192: PPUSH
16193: CALL_OW 25
16197: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
16198: LD_EXP 96
16202: PPUSH
16203: LD_INT 4
16205: PPUSH
16206: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
16210: LD_EXP 96
16214: PPUSH
16215: LD_INT 242
16217: PPUSH
16218: LD_INT 75
16220: PPUSH
16221: LD_INT 0
16223: PPUSH
16224: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
16228: LD_ADDR_EXP 97
16232: PUSH
16233: LD_STRING Heike
16235: PPUSH
16236: CALL_OW 25
16240: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
16241: LD_INT 14
16243: PPUSH
16244: LD_INT 3
16246: PPUSH
16247: LD_INT 1
16249: PPUSH
16250: LD_INT 27
16252: PPUSH
16253: LD_INT 100
16255: PPUSH
16256: CALL 74284 0 5
// veh := CreateVehicle ;
16260: LD_ADDR_VAR 0 3
16264: PUSH
16265: CALL_OW 45
16269: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
16270: LD_VAR 0 3
16274: PPUSH
16275: LD_INT 2
16277: NEG
16278: PPUSH
16279: CALL_OW 242
// SetDir ( veh , 4 ) ;
16283: LD_VAR 0 3
16287: PPUSH
16288: LD_INT 4
16290: PPUSH
16291: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
16295: LD_VAR 0 3
16299: PPUSH
16300: LD_INT 241
16302: PPUSH
16303: LD_INT 72
16305: PPUSH
16306: LD_INT 0
16308: PPUSH
16309: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
16313: LD_EXP 97
16317: PPUSH
16318: LD_VAR 0 3
16322: PPUSH
16323: CALL_OW 52
// if KhatamStatus then
16327: LD_EXP 8
16331: IFFALSE 16394
// begin Khatam := NewCharacter ( Khatam ) ;
16333: LD_ADDR_EXP 98
16337: PUSH
16338: LD_STRING Khatam
16340: PPUSH
16341: CALL_OW 25
16345: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
16346: LD_EXP 98
16350: PPUSH
16351: LD_INT 245
16353: PPUSH
16354: LD_INT 78
16356: PPUSH
16357: LD_INT 3
16359: PPUSH
16360: LD_INT 0
16362: PPUSH
16363: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
16367: LD_EXP 98
16371: PPUSH
16372: LD_INT 4
16374: PPUSH
16375: LD_INT 10
16377: PPUSH
16378: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
16382: LD_EXP 98
16386: PPUSH
16387: LD_INT 4
16389: PPUSH
16390: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
16394: LD_ADDR_VAR 0 2
16398: PUSH
16399: DOUBLE
16400: LD_INT 1
16402: DEC
16403: ST_TO_ADDR
16404: LD_INT 2
16406: PUSH
16407: LD_INT 2
16409: PUSH
16410: LD_INT 3
16412: PUSH
16413: LD_INT 3
16415: PUSH
16416: EMPTY
16417: LIST
16418: LIST
16419: LIST
16420: LIST
16421: PUSH
16422: LD_OWVAR 67
16426: ARRAY
16427: PUSH
16428: FOR_TO
16429: IFFALSE 16495
// begin PrepareScientist ( false , 6 + Difficulty ) ;
16431: LD_INT 0
16433: PPUSH
16434: LD_INT 6
16436: PUSH
16437: LD_OWVAR 67
16441: PLUS
16442: PPUSH
16443: CALL_OW 384
// un := CreateHuman ;
16447: LD_ADDR_VAR 0 4
16451: PUSH
16452: CALL_OW 44
16456: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
16457: LD_VAR 0 4
16461: PPUSH
16462: LD_INT 28
16464: PUSH
16465: LD_INT 29
16467: PUSH
16468: EMPTY
16469: LIST
16470: LIST
16471: PUSH
16472: LD_VAR 0 2
16476: PUSH
16477: LD_INT 2
16479: MOD
16480: PUSH
16481: LD_INT 1
16483: PLUS
16484: ARRAY
16485: PPUSH
16486: LD_INT 0
16488: PPUSH
16489: CALL_OW 49
// end ;
16493: GO 16428
16495: POP
16496: POP
// for i = 1 to 6 do
16497: LD_ADDR_VAR 0 2
16501: PUSH
16502: DOUBLE
16503: LD_INT 1
16505: DEC
16506: ST_TO_ADDR
16507: LD_INT 6
16509: PUSH
16510: FOR_TO
16511: IFFALSE 16556
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
16513: LD_INT 0
16515: PPUSH
16516: LD_INT 6
16518: PUSH
16519: LD_OWVAR 67
16523: PLUS
16524: PPUSH
16525: CALL_OW 381
// un := CreateHuman ;
16529: LD_ADDR_VAR 0 4
16533: PUSH
16534: CALL_OW 44
16538: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16539: LD_VAR 0 4
16543: PPUSH
16544: LD_INT 32
16546: PPUSH
16547: LD_INT 0
16549: PPUSH
16550: CALL_OW 49
// end ;
16554: GO 16510
16556: POP
16557: POP
// for i = 1 to 3 do
16558: LD_ADDR_VAR 0 2
16562: PUSH
16563: DOUBLE
16564: LD_INT 1
16566: DEC
16567: ST_TO_ADDR
16568: LD_INT 3
16570: PUSH
16571: FOR_TO
16572: IFFALSE 16620
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
16574: LD_INT 0
16576: PPUSH
16577: LD_INT 8
16579: PPUSH
16580: LD_INT 6
16582: PUSH
16583: LD_OWVAR 67
16587: PLUS
16588: PPUSH
16589: CALL_OW 380
// un := CreateHuman ;
16593: LD_ADDR_VAR 0 4
16597: PUSH
16598: CALL_OW 44
16602: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16603: LD_VAR 0 4
16607: PPUSH
16608: LD_INT 32
16610: PPUSH
16611: LD_INT 0
16613: PPUSH
16614: CALL_OW 49
// end ;
16618: GO 16571
16620: POP
16621: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
16622: LD_ADDR_VAR 0 2
16626: PUSH
16627: DOUBLE
16628: LD_INT 1
16630: DEC
16631: ST_TO_ADDR
16632: LD_INT 2
16634: PUSH
16635: LD_INT 3
16637: PUSH
16638: LD_INT 4
16640: PUSH
16641: LD_INT 4
16643: PUSH
16644: EMPTY
16645: LIST
16646: LIST
16647: LIST
16648: LIST
16649: PUSH
16650: LD_OWVAR 67
16654: ARRAY
16655: PUSH
16656: FOR_TO
16657: IFFALSE 16747
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
16659: LD_INT 14
16661: PPUSH
16662: LD_INT 2
16664: PPUSH
16665: LD_INT 1
16667: PPUSH
16668: LD_INT 28
16670: PPUSH
16671: LD_INT 80
16673: PPUSH
16674: CALL 74284 0 5
// veh := CreateVehicle ;
16678: LD_ADDR_VAR 0 3
16682: PUSH
16683: CALL_OW 45
16687: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
16688: LD_VAR 0 3
16692: PPUSH
16693: LD_INT 3
16695: PPUSH
16696: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
16700: LD_VAR 0 3
16704: PPUSH
16705: LD_INT 29
16707: PPUSH
16708: LD_INT 0
16710: PPUSH
16711: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16715: LD_INT 0
16717: PPUSH
16718: LD_INT 6
16720: PUSH
16721: LD_OWVAR 67
16725: PLUS
16726: PPUSH
16727: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
16731: CALL_OW 44
16735: PPUSH
16736: LD_VAR 0 3
16740: PPUSH
16741: CALL_OW 52
// end ;
16745: GO 16656
16747: POP
16748: POP
// for i = 1 to 5 + Difficulty do
16749: LD_ADDR_VAR 0 2
16753: PUSH
16754: DOUBLE
16755: LD_INT 1
16757: DEC
16758: ST_TO_ADDR
16759: LD_INT 5
16761: PUSH
16762: LD_OWVAR 67
16766: PLUS
16767: PUSH
16768: FOR_TO
16769: IFFALSE 16896
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
16771: LD_INT 14
16773: PPUSH
16774: LD_INT 1
16776: PPUSH
16777: LD_INT 3
16779: PPUSH
16780: CALL_OW 12
16784: PPUSH
16785: LD_INT 1
16787: PPUSH
16788: LD_INT 28
16790: PUSH
16791: LD_INT 26
16793: PUSH
16794: LD_INT 27
16796: PUSH
16797: LD_INT 25
16799: PUSH
16800: EMPTY
16801: LIST
16802: LIST
16803: LIST
16804: LIST
16805: PUSH
16806: LD_VAR 0 2
16810: PUSH
16811: LD_INT 4
16813: MOD
16814: PUSH
16815: LD_INT 1
16817: PLUS
16818: ARRAY
16819: PPUSH
16820: LD_INT 80
16822: PPUSH
16823: CALL 74284 0 5
// veh := CreateVehicle ;
16827: LD_ADDR_VAR 0 3
16831: PUSH
16832: CALL_OW 45
16836: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
16837: LD_VAR 0 3
16841: PPUSH
16842: LD_INT 4
16844: PPUSH
16845: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
16849: LD_VAR 0 3
16853: PPUSH
16854: LD_INT 28
16856: PPUSH
16857: LD_INT 0
16859: PPUSH
16860: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16864: LD_INT 0
16866: PPUSH
16867: LD_INT 6
16869: PUSH
16870: LD_OWVAR 67
16874: PLUS
16875: PPUSH
16876: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
16880: CALL_OW 44
16884: PPUSH
16885: LD_VAR 0 3
16889: PPUSH
16890: CALL_OW 52
// end ;
16894: GO 16768
16896: POP
16897: POP
// for i = 1 to Difficulty do
16898: LD_ADDR_VAR 0 2
16902: PUSH
16903: DOUBLE
16904: LD_INT 1
16906: DEC
16907: ST_TO_ADDR
16908: LD_OWVAR 67
16912: PUSH
16913: FOR_TO
16914: IFFALSE 16974
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
16916: LD_INT 14
16918: PPUSH
16919: LD_INT 3
16921: PPUSH
16922: LD_INT 5
16924: PPUSH
16925: LD_INT 29
16927: PPUSH
16928: LD_INT 80
16930: PPUSH
16931: CALL 74284 0 5
// veh := CreateVehicle ;
16935: LD_ADDR_VAR 0 3
16939: PUSH
16940: CALL_OW 45
16944: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
16945: LD_VAR 0 3
16949: PPUSH
16950: LD_INT 4
16952: PPUSH
16953: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
16957: LD_VAR 0 3
16961: PPUSH
16962: LD_INT 28
16964: PPUSH
16965: LD_INT 0
16967: PPUSH
16968: CALL_OW 49
// end ;
16972: GO 16913
16974: POP
16975: POP
// end ;
16976: LD_VAR 0 1
16980: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
16981: LD_INT 22
16983: PUSH
16984: LD_INT 2
16986: PUSH
16987: EMPTY
16988: LIST
16989: LIST
16990: PPUSH
16991: CALL_OW 69
16995: IFFALSE 17374
16997: GO 16999
16999: DISABLE
17000: LD_INT 0
17002: PPUSH
17003: PPUSH
17004: PPUSH
17005: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
17006: LD_ADDR_VAR 0 3
17010: PUSH
17011: LD_INT 22
17013: PUSH
17014: LD_INT 2
17016: PUSH
17017: EMPTY
17018: LIST
17019: LIST
17020: PUSH
17021: LD_INT 25
17023: PUSH
17024: LD_INT 4
17026: PUSH
17027: EMPTY
17028: LIST
17029: LIST
17030: PUSH
17031: EMPTY
17032: LIST
17033: LIST
17034: PPUSH
17035: CALL_OW 69
17039: PUSH
17040: LD_EXP 98
17044: DIFF
17045: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
17046: LD_ADDR_VAR 0 2
17050: PUSH
17051: LD_INT 22
17053: PUSH
17054: LD_INT 2
17056: PUSH
17057: EMPTY
17058: LIST
17059: LIST
17060: PPUSH
17061: CALL_OW 69
17065: PUSH
17066: LD_EXP 98
17070: PUSH
17071: LD_VAR 0 3
17075: UNION
17076: DIFF
17077: ST_TO_ADDR
// if Khatam then
17078: LD_EXP 98
17082: IFFALSE 17099
// ComMoveXY ( Khatam , 211 , 92 ) ;
17084: LD_EXP 98
17088: PPUSH
17089: LD_INT 211
17091: PPUSH
17092: LD_INT 92
17094: PPUSH
17095: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
17099: LD_INT 197
17101: PPUSH
17102: LD_INT 80
17104: PPUSH
17105: LD_INT 2
17107: PPUSH
17108: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
17112: LD_INT 213
17114: PPUSH
17115: LD_INT 90
17117: PPUSH
17118: LD_INT 2
17120: PPUSH
17121: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
17125: LD_INT 215
17127: PPUSH
17128: LD_INT 129
17130: PPUSH
17131: LD_INT 2
17133: PPUSH
17134: CALL_OW 441
// if sci then
17138: LD_VAR 0 3
17142: IFFALSE 17163
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
17144: LD_VAR 0 3
17148: PUSH
17149: LD_INT 1
17151: ARRAY
17152: PPUSH
17153: LD_INT 197
17155: PPUSH
17156: LD_INT 80
17158: PPUSH
17159: CALL_OW 158
// if sci > 1 then
17163: LD_VAR 0 3
17167: PUSH
17168: LD_INT 1
17170: GREATER
17171: IFFALSE 17192
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
17173: LD_VAR 0 3
17177: PUSH
17178: LD_INT 2
17180: ARRAY
17181: PPUSH
17182: LD_INT 213
17184: PPUSH
17185: LD_INT 90
17187: PPUSH
17188: CALL_OW 158
// if sci > 2 then
17192: LD_VAR 0 3
17196: PUSH
17197: LD_INT 2
17199: GREATER
17200: IFFALSE 17221
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
17202: LD_VAR 0 3
17206: PUSH
17207: LD_INT 3
17209: ARRAY
17210: PPUSH
17211: LD_INT 215
17213: PPUSH
17214: LD_INT 129
17216: PPUSH
17217: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
17221: LD_VAR 0 2
17225: PPUSH
17226: LD_INT 195
17228: PPUSH
17229: LD_INT 102
17231: PPUSH
17232: CALL_OW 114
// wait ( 0 0$5 ) ;
17236: LD_INT 175
17238: PPUSH
17239: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
17243: LD_INT 70
17245: PPUSH
17246: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
17250: LD_ADDR_VAR 0 4
17254: PUSH
17255: LD_INT 92
17257: PUSH
17258: LD_INT 195
17260: PUSH
17261: LD_INT 102
17263: PUSH
17264: LD_INT 36
17266: PUSH
17267: EMPTY
17268: LIST
17269: LIST
17270: LIST
17271: LIST
17272: PUSH
17273: LD_INT 22
17275: PUSH
17276: LD_INT 1
17278: PUSH
17279: EMPTY
17280: LIST
17281: LIST
17282: PUSH
17283: EMPTY
17284: LIST
17285: LIST
17286: PPUSH
17287: CALL_OW 69
17291: ST_TO_ADDR
// for i in tmp do
17292: LD_ADDR_VAR 0 1
17296: PUSH
17297: LD_VAR 0 2
17301: PUSH
17302: FOR_IN
17303: IFFALSE 17354
// if enemy then
17305: LD_VAR 0 4
17309: IFFALSE 17337
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
17311: LD_VAR 0 1
17315: PPUSH
17316: LD_VAR 0 4
17320: PPUSH
17321: LD_VAR 0 1
17325: PPUSH
17326: CALL_OW 74
17330: PPUSH
17331: CALL_OW 115
17335: GO 17352
// ComAgressiveMove ( i , 195 , 102 ) ;
17337: LD_VAR 0 1
17341: PPUSH
17342: LD_INT 195
17344: PPUSH
17345: LD_INT 102
17347: PPUSH
17348: CALL_OW 114
17352: GO 17302
17354: POP
17355: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
17356: LD_VAR 0 2
17360: PPUSH
17361: LD_INT 50
17363: PUSH
17364: EMPTY
17365: LIST
17366: PPUSH
17367: CALL_OW 72
17371: NOT
17372: IFFALSE 17243
// end ; end_of_file
17374: PPOPN 4
17376: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
17377: LD_INT 0
17379: PPUSH
17380: PPUSH
17381: PPUSH
17382: PPUSH
17383: PPUSH
17384: PPUSH
17385: PPUSH
17386: PPUSH
17387: PPUSH
// Video ( true ) ;
17388: LD_INT 1
17390: PPUSH
17391: CALL 107107 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
17395: LD_ADDR_VAR 0 5
17399: PUSH
17400: LD_INT 7
17402: PPUSH
17403: LD_INT 0
17405: PPUSH
17406: CALL_OW 517
17410: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
17411: LD_ADDR_VAR 0 2
17415: PUSH
17416: DOUBLE
17417: LD_INT 1
17419: DEC
17420: ST_TO_ADDR
17421: LD_VAR 0 5
17425: PUSH
17426: LD_INT 1
17428: ARRAY
17429: PUSH
17430: FOR_TO
17431: IFFALSE 17476
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
17433: LD_VAR 0 5
17437: PUSH
17438: LD_INT 1
17440: ARRAY
17441: PUSH
17442: LD_VAR 0 2
17446: ARRAY
17447: PPUSH
17448: LD_VAR 0 5
17452: PUSH
17453: LD_INT 2
17455: ARRAY
17456: PUSH
17457: LD_VAR 0 2
17461: ARRAY
17462: PPUSH
17463: LD_INT 1
17465: PPUSH
17466: LD_INT 15
17468: NEG
17469: PPUSH
17470: CALL 107021 0 4
17474: GO 17430
17476: POP
17477: POP
// CenterNowOnUnits ( Powell ) ;
17478: LD_EXP 60
17482: PPUSH
17483: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
17487: LD_ADDR_VAR 0 5
17491: PUSH
17492: LD_EXP 58
17496: PUSH
17497: EMPTY
17498: LIST
17499: ST_TO_ADDR
// if GirlNewVeh then
17500: LD_EXP 59
17504: IFFALSE 17522
// tmp := tmp ^ GirlNewVeh ;
17506: LD_ADDR_VAR 0 5
17510: PUSH
17511: LD_VAR 0 5
17515: PUSH
17516: LD_EXP 59
17520: ADD
17521: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
17522: LD_VAR 0 5
17526: PPUSH
17527: LD_INT 60
17529: PPUSH
17530: LD_INT 109
17532: PPUSH
17533: CALL_OW 111
// if KappaStatus then
17537: LD_EXP 2
17541: IFFALSE 17593
// begin Say ( JMM , D1nT-JMM-1 ) ;
17543: LD_EXP 40
17547: PPUSH
17548: LD_STRING D1nT-JMM-1
17550: PPUSH
17551: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17555: LD_EXP 60
17559: PPUSH
17560: LD_STRING D1T-Pow-1
17562: PPUSH
17563: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
17567: LD_EXP 40
17571: PPUSH
17572: LD_STRING D1T-JMM-2
17574: PPUSH
17575: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
17579: LD_EXP 60
17583: PPUSH
17584: LD_STRING D1T-Pow-2
17586: PPUSH
17587: CALL_OW 88
// end else
17591: GO 17799
// if JMMGirlStatus then
17593: LD_EXP 6
17597: IFFALSE 17742
// begin Say ( JMM , D1T-JMM-1 ) ;
17599: LD_EXP 40
17603: PPUSH
17604: LD_STRING D1T-JMM-1
17606: PPUSH
17607: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17611: LD_EXP 60
17615: PPUSH
17616: LD_STRING D1T-Pow-1
17618: PPUSH
17619: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
17623: LD_EXP 40
17627: PPUSH
17628: LD_STRING D1T-JMM-3
17630: PPUSH
17631: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
17635: LD_EXP 60
17639: PPUSH
17640: LD_STRING D1T-Pow-3
17642: PPUSH
17643: CALL_OW 88
// if JMMGirl then
17647: LD_EXP 7
17651: IFFALSE 17740
// begin case JMMGirl of 1 :
17653: LD_EXP 7
17657: PUSH
17658: LD_INT 1
17660: DOUBLE
17661: EQUAL
17662: IFTRUE 17666
17664: GO 17681
17666: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
17667: LD_EXP 41
17671: PPUSH
17672: LD_STRING D1T-Joan-3
17674: PPUSH
17675: CALL_OW 88
17679: GO 17728
17681: LD_INT 2
17683: DOUBLE
17684: EQUAL
17685: IFTRUE 17689
17687: GO 17704
17689: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
17690: LD_EXP 43
17694: PPUSH
17695: LD_STRING D1T-Lisa-3
17697: PPUSH
17698: CALL_OW 88
17702: GO 17728
17704: LD_INT 3
17706: DOUBLE
17707: EQUAL
17708: IFTRUE 17712
17710: GO 17727
17712: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
17713: LD_EXP 55
17717: PPUSH
17718: LD_STRING D1T-Con-3
17720: PPUSH
17721: CALL_OW 88
17725: GO 17728
17727: POP
// Say ( Powell , D1T-Pow-4 ) ;
17728: LD_EXP 60
17732: PPUSH
17733: LD_STRING D1T-Pow-4
17735: PPUSH
17736: CALL_OW 88
// end ; end else
17740: GO 17799
// if not FastEnd then
17742: LD_EXP 11
17746: NOT
17747: IFFALSE 17775
// begin Say ( JMM , D1T-JMM-4 ) ;
17749: LD_EXP 40
17753: PPUSH
17754: LD_STRING D1T-JMM-4
17756: PPUSH
17757: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
17761: LD_EXP 60
17765: PPUSH
17766: LD_STRING D1T-Pow-5
17768: PPUSH
17769: CALL_OW 88
// end else
17773: GO 17799
// begin Say ( JMM , D1nT-JMM-1 ) ;
17775: LD_EXP 40
17779: PPUSH
17780: LD_STRING D1nT-JMM-1
17782: PPUSH
17783: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
17787: LD_EXP 60
17791: PPUSH
17792: LD_STRING D1nT-Pow-1
17794: PPUSH
17795: CALL_OW 88
// end ; repeat wait ( 3 ) ;
17799: LD_INT 3
17801: PPUSH
17802: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
17806: LD_EXP 58
17810: PPUSH
17811: CALL_OW 314
17815: NOT
17816: IFFALSE 17799
// ComExitVehicle ( JMM ) ;
17818: LD_EXP 40
17822: PPUSH
17823: CALL_OW 121
// repeat wait ( 3 ) ;
17827: LD_INT 3
17829: PPUSH
17830: CALL_OW 67
// until not IsInUnit ( JMM ) ;
17834: LD_EXP 40
17838: PPUSH
17839: CALL_OW 310
17843: NOT
17844: IFFALSE 17827
// ComMoveXY ( JMM , 60 , 94 ) ;
17846: LD_EXP 40
17850: PPUSH
17851: LD_INT 60
17853: PPUSH
17854: LD_INT 94
17856: PPUSH
17857: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
17861: LD_EXP 40
17865: PPUSH
17866: LD_EXP 60
17870: PPUSH
17871: CALL_OW 179
// if Joan then
17875: LD_EXP 41
17879: IFFALSE 17933
// begin ComExitVehicle ( Joan ) ;
17881: LD_EXP 41
17885: PPUSH
17886: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
17890: LD_EXP 41
17894: PPUSH
17895: LD_INT 35
17897: PPUSH
17898: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
17902: LD_EXP 41
17906: PPUSH
17907: LD_INT 65
17909: PPUSH
17910: LD_INT 104
17912: PPUSH
17913: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
17917: LD_EXP 41
17921: PPUSH
17922: LD_EXP 40
17926: PPUSH
17927: CALL_OW 179
// end else
17931: GO 18067
// if Lisa and JMMGirl = 2 then
17933: LD_EXP 43
17937: PUSH
17938: LD_EXP 7
17942: PUSH
17943: LD_INT 2
17945: EQUAL
17946: AND
17947: IFFALSE 18001
// begin ComExitVehicle ( Lisa ) ;
17949: LD_EXP 43
17953: PPUSH
17954: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
17958: LD_EXP 43
17962: PPUSH
17963: LD_INT 35
17965: PPUSH
17966: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
17970: LD_EXP 43
17974: PPUSH
17975: LD_INT 65
17977: PPUSH
17978: LD_INT 104
17980: PPUSH
17981: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
17985: LD_EXP 43
17989: PPUSH
17990: LD_EXP 40
17994: PPUSH
17995: CALL_OW 179
// end else
17999: GO 18067
// if Connie and JMMGirl = 3 then
18001: LD_EXP 55
18005: PUSH
18006: LD_EXP 7
18010: PUSH
18011: LD_INT 3
18013: EQUAL
18014: AND
18015: IFFALSE 18067
// begin ComExitVehicle ( Connie ) ;
18017: LD_EXP 55
18021: PPUSH
18022: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
18026: LD_EXP 55
18030: PPUSH
18031: LD_INT 35
18033: PPUSH
18034: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
18038: LD_EXP 55
18042: PPUSH
18043: LD_INT 65
18045: PPUSH
18046: LD_INT 104
18048: PPUSH
18049: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
18053: LD_EXP 55
18057: PPUSH
18058: LD_EXP 40
18062: PPUSH
18063: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
18067: LD_INT 35
18069: PPUSH
18070: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
18074: LD_EXP 40
18078: PPUSH
18079: LD_EXP 60
18083: PPUSH
18084: CALL_OW 296
18088: PUSH
18089: LD_INT 8
18091: LESS
18092: IFFALSE 18067
// wait ( 0 0$0.5 ) ;
18094: LD_INT 18
18096: PPUSH
18097: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
18101: LD_EXP 40
18105: PPUSH
18106: LD_STRING D1-JMM-1
18108: PPUSH
18109: CALL_OW 88
// async ;
18113: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
18114: LD_EXP 60
18118: PPUSH
18119: LD_STRING D1-Pow-1
18121: PPUSH
18122: CALL_OW 88
// if not dialogue_skipped then
18126: LD_OWVAR 59
18130: NOT
18131: IFFALSE 18140
// wait ( 0 0$2 ) ;
18133: LD_INT 70
18135: PPUSH
18136: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
18140: LD_INT 170
18142: PPUSH
18143: LD_INT 99
18145: PPUSH
18146: LD_INT 1
18148: PPUSH
18149: LD_INT 6
18151: NEG
18152: PPUSH
18153: CALL 107021 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
18157: LD_INT 174
18159: PPUSH
18160: LD_INT 115
18162: PPUSH
18163: LD_INT 1
18165: PPUSH
18166: LD_INT 6
18168: NEG
18169: PPUSH
18170: CALL 107021 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
18174: LD_INT 169
18176: PPUSH
18177: LD_INT 71
18179: PPUSH
18180: LD_INT 1
18182: PPUSH
18183: LD_INT 6
18185: NEG
18186: PPUSH
18187: CALL 107021 0 4
// if not dialogue_skipped then
18191: LD_OWVAR 59
18195: NOT
18196: IFFALSE 18215
// begin CenterOnXY ( 170 , 99 ) ;
18198: LD_INT 170
18200: PPUSH
18201: LD_INT 99
18203: PPUSH
18204: CALL_OW 84
// wait ( 0 0$2.3 ) ;
18208: LD_INT 80
18210: PPUSH
18211: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
18215: LD_INT 75
18217: PPUSH
18218: LD_INT 53
18220: PPUSH
18221: LD_INT 1
18223: PPUSH
18224: LD_INT 9
18226: NEG
18227: PPUSH
18228: CALL 107021 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
18232: LD_INT 54
18234: PPUSH
18235: LD_INT 42
18237: PPUSH
18238: LD_INT 1
18240: PPUSH
18241: LD_INT 9
18243: NEG
18244: PPUSH
18245: CALL 107021 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
18249: LD_INT 62
18251: PPUSH
18252: LD_INT 51
18254: PPUSH
18255: LD_INT 1
18257: PPUSH
18258: LD_INT 9
18260: NEG
18261: PPUSH
18262: CALL 107021 0 4
// if not dialogue_skipped then
18266: LD_OWVAR 59
18270: NOT
18271: IFFALSE 18290
// begin CenterOnXY ( 75 , 53 ) ;
18273: LD_INT 75
18275: PPUSH
18276: LD_INT 53
18278: PPUSH
18279: CALL_OW 84
// wait ( 0 0$4 ) ;
18283: LD_INT 140
18285: PPUSH
18286: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
18290: LD_EXP 60
18294: PPUSH
18295: CALL_OW 87
// if not dialogue_skipped then
18299: LD_OWVAR 59
18303: NOT
18304: IFFALSE 18313
// wait ( 0 0$2 ) ;
18306: LD_INT 70
18308: PPUSH
18309: CALL_OW 67
// sync ;
18313: SYNC
// Say ( JMM , D1-JMM-2 ) ;
18314: LD_EXP 40
18318: PPUSH
18319: LD_STRING D1-JMM-2
18321: PPUSH
18322: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
18326: LD_EXP 60
18330: PPUSH
18331: LD_STRING D1-Pow-2
18333: PPUSH
18334: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
18338: LD_EXP 40
18342: PPUSH
18343: LD_STRING D1-JMM-3
18345: PPUSH
18346: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
18350: LD_EXP 60
18354: PPUSH
18355: LD_STRING D1-Pow-3
18357: PPUSH
18358: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
18362: LD_EXP 40
18366: PPUSH
18367: LD_STRING D1-JMM-4
18369: PPUSH
18370: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
18374: LD_EXP 60
18378: PPUSH
18379: LD_STRING D1-Pow-4
18381: PPUSH
18382: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
18386: LD_EXP 40
18390: PPUSH
18391: LD_STRING D1-JMM-5
18393: PPUSH
18394: CALL_OW 88
// async ;
18398: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
18399: LD_EXP 60
18403: PPUSH
18404: LD_STRING D1-Pow-5
18406: PPUSH
18407: CALL_OW 88
// if not dialogue_skipped then
18411: LD_OWVAR 59
18415: NOT
18416: IFFALSE 18425
// wait ( 0 0$3.6 ) ;
18418: LD_INT 126
18420: PPUSH
18421: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
18425: LD_INT 134
18427: PPUSH
18428: LD_INT 210
18430: PPUSH
18431: LD_INT 1
18433: PPUSH
18434: LD_INT 11
18436: NEG
18437: PPUSH
18438: CALL 107021 0 4
// if not dialogue_skipped then
18442: LD_OWVAR 59
18446: NOT
18447: IFFALSE 18466
// begin CenterOnXY ( 134 , 210 ) ;
18449: LD_INT 134
18451: PPUSH
18452: LD_INT 210
18454: PPUSH
18455: CALL_OW 84
// wait ( 0 0$2 ) ;
18459: LD_INT 70
18461: PPUSH
18462: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
18466: LD_INT 101
18468: PPUSH
18469: LD_INT 159
18471: PPUSH
18472: LD_INT 1
18474: PPUSH
18475: LD_INT 10
18477: NEG
18478: PPUSH
18479: CALL 107021 0 4
// if not dialogue_skipped then
18483: LD_OWVAR 59
18487: NOT
18488: IFFALSE 18507
// begin CenterOnXY ( 101 , 159 ) ;
18490: LD_INT 101
18492: PPUSH
18493: LD_INT 159
18495: PPUSH
18496: CALL_OW 84
// wait ( 0 0$2 ) ;
18500: LD_INT 70
18502: PPUSH
18503: CALL_OW 67
// end ; sync ;
18507: SYNC
// CenterNowOnUnits ( Powell ) ;
18508: LD_EXP 60
18512: PPUSH
18513: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
18517: LD_ADDR_VAR 0 6
18521: PUSH
18522: LD_INT 1
18524: PUSH
18525: LD_INT 2
18527: PUSH
18528: LD_INT 3
18530: PUSH
18531: LD_INT 4
18533: PUSH
18534: LD_INT 5
18536: PUSH
18537: LD_INT 6
18539: PUSH
18540: EMPTY
18541: LIST
18542: LIST
18543: LIST
18544: LIST
18545: LIST
18546: LIST
18547: ST_TO_ADDR
// if not dialogue_skipped then
18548: LD_OWVAR 59
18552: NOT
18553: IFFALSE 18722
// begin game_speed := 4 ;
18555: LD_ADDR_OWVAR 65
18559: PUSH
18560: LD_INT 4
18562: ST_TO_ADDR
// wait ( 0 0$6 ) ;
18563: LD_INT 210
18565: PPUSH
18566: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
18570: LD_ADDR_VAR 0 7
18574: PUSH
18575: LD_STRING Q1
18577: PPUSH
18578: LD_VAR 0 6
18582: PPUSH
18583: CALL_OW 98
18587: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
18588: LD_ADDR_VAR 0 7
18592: PUSH
18593: LD_STRING Q1
18595: PPUSH
18596: LD_VAR 0 6
18600: PPUSH
18601: CALL_OW 98
18605: ST_TO_ADDR
// options := options diff dec ;
18606: LD_ADDR_VAR 0 6
18610: PUSH
18611: LD_VAR 0 6
18615: PUSH
18616: LD_VAR 0 7
18620: DIFF
18621: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
18622: LD_VAR 0 7
18626: PPUSH
18627: LD_VAR 0 6
18631: PPUSH
18632: CALL 20286 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
18636: LD_VAR 0 7
18640: PUSH
18641: LD_INT 5
18643: PUSH
18644: LD_INT 6
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: IN
18651: PUSH
18652: LD_VAR 0 6
18656: PUSH
18657: LD_INT 2
18659: EQUAL
18660: OR
18661: IFFALSE 18588
// if not ( dec in [ 5 , 6 ] ) then
18663: LD_VAR 0 7
18667: PUSH
18668: LD_INT 5
18670: PUSH
18671: LD_INT 6
18673: PUSH
18674: EMPTY
18675: LIST
18676: LIST
18677: IN
18678: NOT
18679: IFFALSE 18722
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
18681: LD_ADDR_VAR 0 7
18685: PUSH
18686: LD_STRING Q1a
18688: PPUSH
18689: LD_INT 1
18691: PUSH
18692: LD_INT 2
18694: PUSH
18695: EMPTY
18696: LIST
18697: LIST
18698: PPUSH
18699: CALL_OW 98
18703: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
18704: LD_VAR 0 7
18708: PUSH
18709: LD_INT 4
18711: PLUS
18712: PPUSH
18713: LD_VAR 0 6
18717: PPUSH
18718: CALL 20286 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
18722: LD_INT 81
18724: PPUSH
18725: LD_INT 127
18727: PPUSH
18728: CALL_OW 84
// amount := 8 ;
18732: LD_ADDR_VAR 0 8
18736: PUSH
18737: LD_INT 8
18739: ST_TO_ADDR
// macmilan_squad := [ ] ;
18740: LD_ADDR_VAR 0 9
18744: PUSH
18745: EMPTY
18746: ST_TO_ADDR
// if vip < amount then
18747: LD_EXP 61
18751: PUSH
18752: LD_VAR 0 8
18756: LESS
18757: IFFALSE 18801
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
18759: LD_ADDR_VAR 0 5
18763: PUSH
18764: LD_EXP 61
18768: PUSH
18769: LD_INT 22
18771: PUSH
18772: LD_INT 4
18774: PUSH
18775: EMPTY
18776: LIST
18777: LIST
18778: PUSH
18779: LD_INT 21
18781: PUSH
18782: LD_INT 1
18784: PUSH
18785: EMPTY
18786: LIST
18787: LIST
18788: PUSH
18789: EMPTY
18790: LIST
18791: LIST
18792: PPUSH
18793: CALL_OW 69
18797: UNION
18798: ST_TO_ADDR
18799: GO 18811
// tmp := vip ;
18801: LD_ADDR_VAR 0 5
18805: PUSH
18806: LD_EXP 61
18810: ST_TO_ADDR
// tmp := tmp diff Powell ;
18811: LD_ADDR_VAR 0 5
18815: PUSH
18816: LD_VAR 0 5
18820: PUSH
18821: LD_EXP 60
18825: DIFF
18826: ST_TO_ADDR
// if tmp < amount then
18827: LD_VAR 0 5
18831: PUSH
18832: LD_VAR 0 8
18836: LESS
18837: IFFALSE 18849
// amount := tmp ;
18839: LD_ADDR_VAR 0 8
18843: PUSH
18844: LD_VAR 0 5
18848: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
18849: LD_VAR 0 5
18853: PUSH
18854: LD_INT 1
18856: ARRAY
18857: PPUSH
18858: CALL_OW 257
18862: PUSH
18863: LD_INT 2
18865: NONEQUAL
18866: IFFALSE 18964
// begin if IsInUnit ( tmp [ 1 ] ) then
18868: LD_VAR 0 5
18872: PUSH
18873: LD_INT 1
18875: ARRAY
18876: PPUSH
18877: CALL_OW 310
18881: IFFALSE 18896
// ComExitBuilding ( tmp [ 1 ] ) ;
18883: LD_VAR 0 5
18887: PUSH
18888: LD_INT 1
18890: ARRAY
18891: PPUSH
18892: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
18896: LD_INT 387
18898: PPUSH
18899: CALL_OW 313
18903: PUSH
18904: LD_INT 6
18906: EQUAL
18907: IFFALSE 18932
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
18909: LD_INT 387
18911: PPUSH
18912: CALL_OW 313
18916: PUSH
18917: LD_INT 1
18919: ARRAY
18920: PPUSH
18921: CALL_OW 122
// wait ( 3 ) ;
18925: LD_INT 3
18927: PPUSH
18928: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
18932: LD_VAR 0 5
18936: PUSH
18937: LD_INT 1
18939: ARRAY
18940: PPUSH
18941: LD_INT 387
18943: PPUSH
18944: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
18948: LD_VAR 0 5
18952: PUSH
18953: LD_INT 1
18955: ARRAY
18956: PPUSH
18957: LD_INT 2
18959: PPUSH
18960: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
18964: LD_EXP 40
18968: PPUSH
18969: LD_INT 82
18971: PPUSH
18972: LD_INT 129
18974: PPUSH
18975: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
18979: LD_EXP 40
18983: PPUSH
18984: LD_EXP 60
18988: PPUSH
18989: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
18993: LD_INT 22
18995: PUSH
18996: LD_INT 1
18998: PUSH
18999: EMPTY
19000: LIST
19001: LIST
19002: PPUSH
19003: CALL_OW 69
19007: PUSH
19008: LD_EXP 40
19012: DIFF
19013: PPUSH
19014: LD_INT 84
19016: PPUSH
19017: LD_INT 128
19019: PPUSH
19020: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
19024: LD_INT 22
19026: PUSH
19027: LD_INT 1
19029: PUSH
19030: EMPTY
19031: LIST
19032: LIST
19033: PPUSH
19034: CALL_OW 69
19038: PUSH
19039: LD_EXP 40
19043: DIFF
19044: PPUSH
19045: LD_EXP 40
19049: PPUSH
19050: CALL_OW 179
// for i = 1 to amount do
19054: LD_ADDR_VAR 0 2
19058: PUSH
19059: DOUBLE
19060: LD_INT 1
19062: DEC
19063: ST_TO_ADDR
19064: LD_VAR 0 8
19068: PUSH
19069: FOR_TO
19070: IFFALSE 19238
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
19072: LD_ADDR_VAR 0 9
19076: PUSH
19077: LD_VAR 0 9
19081: PUSH
19082: LD_VAR 0 5
19086: PUSH
19087: LD_VAR 0 2
19091: ARRAY
19092: ADD
19093: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
19094: LD_VAR 0 5
19098: PUSH
19099: LD_VAR 0 2
19103: ARRAY
19104: PPUSH
19105: CALL_OW 310
19109: IFFALSE 19126
// AddComExitBuilding ( tmp [ i ] ) ;
19111: LD_VAR 0 5
19115: PUSH
19116: LD_VAR 0 2
19120: ARRAY
19121: PPUSH
19122: CALL_OW 182
// if i = 2 and JMMNewVeh then
19126: LD_VAR 0 2
19130: PUSH
19131: LD_INT 2
19133: EQUAL
19134: PUSH
19135: LD_EXP 58
19139: AND
19140: IFFALSE 19198
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
19142: LD_VAR 0 5
19146: PUSH
19147: LD_VAR 0 2
19151: ARRAY
19152: PPUSH
19153: LD_EXP 58
19157: PPUSH
19158: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
19162: LD_VAR 0 5
19166: PUSH
19167: LD_VAR 0 2
19171: ARRAY
19172: PPUSH
19173: LD_INT 86
19175: PPUSH
19176: LD_INT 133
19178: PPUSH
19179: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
19183: LD_VAR 0 5
19187: PUSH
19188: LD_VAR 0 2
19192: ARRAY
19193: PPUSH
19194: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
19198: LD_VAR 0 5
19202: PUSH
19203: LD_VAR 0 2
19207: ARRAY
19208: PPUSH
19209: LD_INT 8
19211: PPUSH
19212: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
19216: LD_VAR 0 5
19220: PUSH
19221: LD_VAR 0 2
19225: ARRAY
19226: PPUSH
19227: LD_EXP 40
19231: PPUSH
19232: CALL_OW 179
// end ;
19236: GO 19069
19238: POP
19239: POP
// if GirlNewVeh then
19240: LD_EXP 59
19244: IFFALSE 19258
// SetSide ( GirlNewVeh , 4 ) ;
19246: LD_EXP 59
19250: PPUSH
19251: LD_INT 4
19253: PPUSH
19254: CALL_OW 235
// if Mike then
19258: LD_EXP 57
19262: IFFALSE 19299
// begin macmilan_squad := Join ( macmilan_squad , Mike ) ;
19264: LD_ADDR_VAR 0 9
19268: PUSH
19269: LD_VAR 0 9
19273: PPUSH
19274: LD_EXP 57
19278: PPUSH
19279: CALL 107135 0 2
19283: ST_TO_ADDR
// ComMoveXY ( Mike , 86 , 133 ) ;
19284: LD_EXP 57
19288: PPUSH
19289: LD_INT 86
19291: PPUSH
19292: LD_INT 133
19294: PPUSH
19295: CALL_OW 111
// end ; repeat wait ( 0 0$1 ) ;
19299: LD_INT 35
19301: PPUSH
19302: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
19306: LD_VAR 0 9
19310: PPUSH
19311: LD_INT 95
19313: PUSH
19314: LD_INT 9
19316: PUSH
19317: EMPTY
19318: LIST
19319: LIST
19320: PPUSH
19321: CALL_OW 72
19325: PUSH
19326: LD_INT 0
19328: EQUAL
19329: PUSH
19330: LD_EXP 40
19334: PPUSH
19335: LD_INT 9
19337: PPUSH
19338: CALL_OW 308
19342: NOT
19343: AND
19344: IFFALSE 19299
// wait ( 0 0$2 ) ;
19346: LD_INT 70
19348: PPUSH
19349: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
19353: LD_VAR 0 9
19357: PPUSH
19358: LD_INT 1
19360: PPUSH
19361: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
19365: LD_INT 21
19367: PUSH
19368: LD_INT 2
19370: PUSH
19371: EMPTY
19372: LIST
19373: LIST
19374: PUSH
19375: LD_INT 92
19377: PUSH
19378: LD_INT 83
19380: PUSH
19381: LD_INT 130
19383: PUSH
19384: LD_INT 10
19386: PUSH
19387: EMPTY
19388: LIST
19389: LIST
19390: LIST
19391: LIST
19392: PUSH
19393: EMPTY
19394: LIST
19395: LIST
19396: PPUSH
19397: CALL_OW 69
19401: PPUSH
19402: LD_INT 1
19404: PPUSH
19405: CALL_OW 235
// tick := 0 ;
19409: LD_ADDR_OWVAR 1
19413: PUSH
19414: LD_INT 0
19416: ST_TO_ADDR
// Video ( false ) ;
19417: LD_INT 0
19419: PPUSH
19420: CALL 107107 0 1
// ChangeMissionObjectives ( M1 ) ;
19424: LD_STRING M1
19426: PPUSH
19427: CALL_OW 337
// SaveForQuickRestart ;
19431: CALL_OW 22
// missionStart := true ;
19435: LD_ADDR_EXP 13
19439: PUSH
19440: LD_INT 1
19442: ST_TO_ADDR
// missionStage := 2 ;
19443: LD_ADDR_EXP 15
19447: PUSH
19448: LD_INT 2
19450: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19451: LD_INT 35
19453: PPUSH
19454: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
19458: LD_ADDR_VAR 0 5
19462: PUSH
19463: LD_INT 22
19465: PUSH
19466: LD_INT 4
19468: PUSH
19469: EMPTY
19470: LIST
19471: LIST
19472: PUSH
19473: LD_INT 21
19475: PUSH
19476: LD_INT 1
19478: PUSH
19479: EMPTY
19480: LIST
19481: LIST
19482: PUSH
19483: EMPTY
19484: LIST
19485: LIST
19486: PPUSH
19487: CALL_OW 69
19491: PUSH
19492: LD_EXP 60
19496: DIFF
19497: ST_TO_ADDR
// if not tmp then
19498: LD_VAR 0 5
19502: NOT
19503: IFFALSE 19518
// tmp := [ Powell ] ;
19505: LD_ADDR_VAR 0 5
19509: PUSH
19510: LD_EXP 60
19514: PUSH
19515: EMPTY
19516: LIST
19517: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
19518: LD_ADDR_VAR 0 4
19522: PUSH
19523: LD_INT 22
19525: PUSH
19526: LD_INT 4
19528: PUSH
19529: EMPTY
19530: LIST
19531: LIST
19532: PUSH
19533: LD_INT 34
19535: PUSH
19536: LD_INT 12
19538: PUSH
19539: EMPTY
19540: LIST
19541: LIST
19542: PUSH
19543: EMPTY
19544: LIST
19545: LIST
19546: PPUSH
19547: CALL_OW 69
19551: PUSH
19552: LD_INT 1
19554: ARRAY
19555: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
19556: LD_VAR 0 5
19560: PUSH
19561: LD_INT 1
19563: ARRAY
19564: PPUSH
19565: CALL_OW 310
19569: IFFALSE 19584
// ComExitBuilding ( tmp [ 1 ] ) ;
19571: LD_VAR 0 5
19575: PUSH
19576: LD_INT 1
19578: ARRAY
19579: PPUSH
19580: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
19584: LD_VAR 0 5
19588: PUSH
19589: LD_INT 1
19591: ARRAY
19592: PPUSH
19593: LD_VAR 0 4
19597: PPUSH
19598: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
19602: LD_VAR 0 5
19606: PUSH
19607: LD_INT 1
19609: ARRAY
19610: PPUSH
19611: LD_INT 80
19613: PPUSH
19614: LD_INT 136
19616: PPUSH
19617: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
19621: LD_VAR 0 5
19625: PUSH
19626: LD_INT 1
19628: ARRAY
19629: PPUSH
19630: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
19634: LD_VAR 0 5
19638: PUSH
19639: LD_INT 1
19641: ARRAY
19642: PPUSH
19643: LD_INT 59
19645: PPUSH
19646: LD_INT 112
19648: PPUSH
19649: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
19653: LD_VAR 0 5
19657: PUSH
19658: LD_INT 1
19660: ARRAY
19661: PPUSH
19662: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
19666: LD_EXP 41
19670: PUSH
19671: LD_EXP 41
19675: PPUSH
19676: CALL_OW 255
19680: PUSH
19681: LD_INT 1
19683: EQUAL
19684: AND
19685: IFFALSE 19711
// begin Say ( Joan , D3W-Joan-1 ) ;
19687: LD_EXP 41
19691: PPUSH
19692: LD_STRING D3W-Joan-1
19694: PPUSH
19695: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19699: LD_EXP 40
19703: PPUSH
19704: LD_STRING D3W-JMM-1
19706: PPUSH
19707: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
19711: LD_EXP 43
19715: PUSH
19716: LD_EXP 43
19720: PPUSH
19721: CALL_OW 255
19725: PUSH
19726: LD_INT 1
19728: EQUAL
19729: AND
19730: PUSH
19731: LD_EXP 43
19735: PUSH
19736: LD_EXP 61
19740: IN
19741: NOT
19742: AND
19743: IFFALSE 19769
// begin Say ( Lisa , D3W-Lisa-1 ) ;
19745: LD_EXP 43
19749: PPUSH
19750: LD_STRING D3W-Lisa-1
19752: PPUSH
19753: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19757: LD_EXP 40
19761: PPUSH
19762: LD_STRING D3W-JMM-1
19764: PPUSH
19765: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
19769: LD_EXP 55
19773: PUSH
19774: LD_EXP 55
19778: PPUSH
19779: CALL_OW 255
19783: PUSH
19784: LD_INT 1
19786: EQUAL
19787: AND
19788: IFFALSE 19814
// begin Say ( Connie , D3W-Con-1 ) ;
19790: LD_EXP 55
19794: PPUSH
19795: LD_STRING D3W-Con-1
19797: PPUSH
19798: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19802: LD_EXP 40
19806: PPUSH
19807: LD_STRING D3W-JMM-1
19809: PPUSH
19810: CALL_OW 88
// end ; wait ( 0 0$0.5 ) ;
19814: LD_INT 18
19816: PPUSH
19817: CALL_OW 67
// if Lisa in vip and GetSide ( Lisa ) = 1 then
19821: LD_EXP 43
19825: PUSH
19826: LD_EXP 61
19830: IN
19831: PUSH
19832: LD_EXP 43
19836: PPUSH
19837: CALL_OW 255
19841: PUSH
19842: LD_INT 1
19844: EQUAL
19845: AND
19846: IFFALSE 19862
// Say ( Lisa , D3nW-Lisa-1 ) else
19848: LD_EXP 43
19852: PPUSH
19853: LD_STRING D3nW-Lisa-1
19855: PPUSH
19856: CALL_OW 88
19860: GO 20106
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
19862: LD_EXP 46
19866: PUSH
19867: LD_EXP 61
19871: IN
19872: PUSH
19873: LD_EXP 46
19877: PPUSH
19878: CALL_OW 255
19882: PUSH
19883: LD_INT 1
19885: EQUAL
19886: AND
19887: IFFALSE 19903
// Say ( Cyrus , D3nW-Cyrus-1 ) else
19889: LD_EXP 46
19893: PPUSH
19894: LD_STRING D3nW-Cyrus-1
19896: PPUSH
19897: CALL_OW 88
19901: GO 20106
// if Bobby in vip and GetSide ( Bobby ) = 1 then
19903: LD_EXP 45
19907: PUSH
19908: LD_EXP 61
19912: IN
19913: PUSH
19914: LD_EXP 45
19918: PPUSH
19919: CALL_OW 255
19923: PUSH
19924: LD_INT 1
19926: EQUAL
19927: AND
19928: IFFALSE 19944
// Say ( Bobby , D3nW-Bobby-1 ) else
19930: LD_EXP 45
19934: PPUSH
19935: LD_STRING D3nW-Bobby-1
19937: PPUSH
19938: CALL_OW 88
19942: GO 20106
// if Gary in vip and GetSide ( Gary ) = 1 then
19944: LD_EXP 52
19948: PUSH
19949: LD_EXP 61
19953: IN
19954: PUSH
19955: LD_EXP 52
19959: PPUSH
19960: CALL_OW 255
19964: PUSH
19965: LD_INT 1
19967: EQUAL
19968: AND
19969: IFFALSE 19985
// Say ( Gary , D3nW-Gary-1 ) else
19971: LD_EXP 52
19975: PPUSH
19976: LD_STRING D3nW-Gary-1
19978: PPUSH
19979: CALL_OW 88
19983: GO 20106
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
19985: LD_EXP 44
19989: PUSH
19990: LD_EXP 61
19994: IN
19995: PUSH
19996: LD_EXP 44
20000: PPUSH
20001: CALL_OW 255
20005: PUSH
20006: LD_INT 1
20008: EQUAL
20009: AND
20010: IFFALSE 20026
// Say ( Donaldson , D3nW-Don-1 ) else
20012: LD_EXP 44
20016: PPUSH
20017: LD_STRING D3nW-Don-1
20019: PPUSH
20020: CALL_OW 88
20024: GO 20106
// if Cornel in vip and GetSide ( Cornel ) = 1 then
20026: LD_EXP 51
20030: PUSH
20031: LD_EXP 61
20035: IN
20036: PUSH
20037: LD_EXP 51
20041: PPUSH
20042: CALL_OW 255
20046: PUSH
20047: LD_INT 1
20049: EQUAL
20050: AND
20051: IFFALSE 20067
// Say ( Cornel , D3nW-Corn-1 ) else
20053: LD_EXP 51
20057: PPUSH
20058: LD_STRING D3nW-Corn-1
20060: PPUSH
20061: CALL_OW 88
20065: GO 20106
// if Frank in vip and GetSide ( Frank ) = 1 then
20067: LD_EXP 53
20071: PUSH
20072: LD_EXP 61
20076: IN
20077: PUSH
20078: LD_EXP 53
20082: PPUSH
20083: CALL_OW 255
20087: PUSH
20088: LD_INT 1
20090: EQUAL
20091: AND
20092: IFFALSE 20106
// Say ( Frank , D3nW-Frank-1 ) ;
20094: LD_EXP 53
20098: PPUSH
20099: LD_STRING D3nW-Frank-1
20101: PPUSH
20102: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
20106: LD_EXP 61
20110: PPUSH
20111: LD_INT 22
20113: PUSH
20114: LD_INT 1
20116: PUSH
20117: EMPTY
20118: LIST
20119: LIST
20120: PPUSH
20121: CALL_OW 72
20125: IFFALSE 20151
// begin Say ( JMM , D3nW-JMM-1 ) ;
20127: LD_EXP 40
20131: PPUSH
20132: LD_STRING D3nW-JMM-1
20134: PPUSH
20135: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
20139: LD_EXP 40
20143: PPUSH
20144: LD_STRING D3nW-JMM-1a
20146: PPUSH
20147: CALL_OW 88
// end ; t := 0 0$00 ;
20151: LD_ADDR_VAR 0 3
20155: PUSH
20156: LD_INT 0
20158: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20159: LD_INT 35
20161: PPUSH
20162: CALL_OW 67
// t := t + 0 0$1 ;
20166: LD_ADDR_VAR 0 3
20170: PUSH
20171: LD_VAR 0 3
20175: PUSH
20176: LD_INT 35
20178: PLUS
20179: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
20180: LD_INT 59
20182: PPUSH
20183: LD_INT 112
20185: PPUSH
20186: CALL_OW 428
20190: PUSH
20191: LD_VAR 0 3
20195: PUSH
20196: LD_INT 2100
20198: GREATER
20199: OR
20200: IFFALSE 20159
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
20202: LD_ADDR_EXP 101
20206: PUSH
20207: LD_EXP 101
20211: PPUSH
20212: LD_INT 4
20214: PPUSH
20215: LD_INT 22
20217: PUSH
20218: LD_INT 4
20220: PUSH
20221: EMPTY
20222: LIST
20223: LIST
20224: PUSH
20225: LD_INT 23
20227: PUSH
20228: LD_INT 1
20230: PUSH
20231: EMPTY
20232: LIST
20233: LIST
20234: PUSH
20235: LD_INT 3
20237: PUSH
20238: LD_INT 21
20240: PUSH
20241: LD_INT 2
20243: PUSH
20244: EMPTY
20245: LIST
20246: LIST
20247: PUSH
20248: EMPTY
20249: LIST
20250: LIST
20251: PUSH
20252: EMPTY
20253: LIST
20254: LIST
20255: LIST
20256: PPUSH
20257: CALL_OW 69
20261: PUSH
20262: LD_EXP 60
20266: DIFF
20267: PPUSH
20268: CALL_OW 1
20272: ST_TO_ADDR
// activeAttacks := true ;
20273: LD_ADDR_EXP 16
20277: PUSH
20278: LD_INT 1
20280: ST_TO_ADDR
// end ;
20281: LD_VAR 0 1
20285: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
20286: LD_INT 0
20288: PPUSH
// case question of 1 :
20289: LD_VAR 0 1
20293: PUSH
20294: LD_INT 1
20296: DOUBLE
20297: EQUAL
20298: IFTRUE 20302
20300: GO 20353
20302: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
20303: LD_EXP 40
20307: PPUSH
20308: LD_STRING D2Mot-JMM-1
20310: PPUSH
20311: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
20315: LD_EXP 60
20319: PPUSH
20320: LD_STRING D2Mot-Pow-1
20322: PPUSH
20323: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
20327: LD_EXP 40
20331: PPUSH
20332: LD_STRING D2Mot-JMM-2
20334: PPUSH
20335: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
20339: LD_EXP 60
20343: PPUSH
20344: LD_STRING D2Mot-Pow-2
20346: PPUSH
20347: CALL_OW 88
// end ; 2 :
20351: GO 20704
20353: LD_INT 2
20355: DOUBLE
20356: EQUAL
20357: IFTRUE 20361
20359: GO 20437
20361: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
20362: LD_EXP 40
20366: PPUSH
20367: LD_STRING D2Rus-JMM-1
20369: PPUSH
20370: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
20374: LD_EXP 60
20378: PPUSH
20379: LD_STRING D2Rus-Pow-1
20381: PPUSH
20382: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
20386: LD_EXP 40
20390: PPUSH
20391: LD_STRING D2Rus-JMM-2
20393: PPUSH
20394: CALL_OW 88
// if not ( 3 in list_of_q ) then
20398: LD_INT 3
20400: PUSH
20401: LD_VAR 0 2
20405: IN
20406: NOT
20407: IFFALSE 20423
// Say ( Powell , D2Rus-Pow-2 ) else
20409: LD_EXP 60
20413: PPUSH
20414: LD_STRING D2Rus-Pow-2
20416: PPUSH
20417: CALL_OW 88
20421: GO 20435
// Say ( Powell , D2Rus-Pow-2a ) ;
20423: LD_EXP 60
20427: PPUSH
20428: LD_STRING D2Rus-Pow-2a
20430: PPUSH
20431: CALL_OW 88
// end ; 3 :
20435: GO 20704
20437: LD_INT 3
20439: DOUBLE
20440: EQUAL
20441: IFTRUE 20445
20443: GO 20530
20445: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
20446: LD_EXP 40
20450: PPUSH
20451: LD_STRING D2Leg-JMM-1
20453: PPUSH
20454: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
20458: LD_EXP 60
20462: PPUSH
20463: LD_STRING D2Leg-Pow-1
20465: PPUSH
20466: CALL_OW 88
// if 2 in list_of_q then
20470: LD_INT 2
20472: PUSH
20473: LD_VAR 0 2
20477: IN
20478: IFFALSE 20504
// begin Say ( JMM , D2Leg-JMM-2 ) ;
20480: LD_EXP 40
20484: PPUSH
20485: LD_STRING D2Leg-JMM-2
20487: PPUSH
20488: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
20492: LD_EXP 60
20496: PPUSH
20497: LD_STRING D2Leg-Pow-2
20499: PPUSH
20500: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
20504: LD_EXP 40
20508: PPUSH
20509: LD_STRING D2Leg-JMM-3
20511: PPUSH
20512: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
20516: LD_EXP 60
20520: PPUSH
20521: LD_STRING D2Leg-Pow-3
20523: PPUSH
20524: CALL_OW 88
// end ; 4 :
20528: GO 20704
20530: LD_INT 4
20532: DOUBLE
20533: EQUAL
20534: IFTRUE 20538
20536: GO 20613
20538: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
20539: LD_EXP 40
20543: PPUSH
20544: LD_STRING D2Ar-JMM-1
20546: PPUSH
20547: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
20551: LD_EXP 60
20555: PPUSH
20556: LD_STRING D2Ar-Pow-1
20558: PPUSH
20559: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
20563: LD_EXP 40
20567: PPUSH
20568: LD_STRING D2Ar-JMM-2
20570: PPUSH
20571: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
20575: LD_EXP 60
20579: PPUSH
20580: LD_STRING D2Ar-Pow-2
20582: PPUSH
20583: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
20587: LD_EXP 40
20591: PPUSH
20592: LD_STRING D2Ar-JMM-3
20594: PPUSH
20595: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
20599: LD_EXP 60
20603: PPUSH
20604: LD_STRING D2Ar-Pow-3
20606: PPUSH
20607: CALL_OW 88
// end ; 5 :
20611: GO 20704
20613: LD_INT 5
20615: DOUBLE
20616: EQUAL
20617: IFTRUE 20621
20619: GO 20636
20621: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
20622: LD_EXP 40
20626: PPUSH
20627: LD_STRING D2Conf-JMM-1
20629: PPUSH
20630: CALL_OW 88
20634: GO 20704
20636: LD_INT 6
20638: DOUBLE
20639: EQUAL
20640: IFTRUE 20644
20642: GO 20703
20644: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
20645: LD_EXP 40
20649: PPUSH
20650: LD_STRING D2Com-JMM-1
20652: PPUSH
20653: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
20657: LD_EXP 60
20661: PPUSH
20662: LD_STRING D2Com-Pow-1
20664: PPUSH
20665: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
20669: LD_EXP 40
20673: PPUSH
20674: LD_STRING D2Com-JMM-2
20676: PPUSH
20677: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
20681: LD_EXP 60
20685: PPUSH
20686: LD_STRING D2Com-Pow-2
20688: PPUSH
20689: CALL_OW 88
// powellAngerQuery := true ;
20693: LD_ADDR_EXP 36
20697: PUSH
20698: LD_INT 1
20700: ST_TO_ADDR
// end ; end ;
20701: GO 20704
20703: POP
// end ;
20704: LD_VAR 0 3
20708: RET
// every 0 0$5 trigger missionStart do var tmp ;
20709: LD_EXP 13
20713: IFFALSE 21038
20715: GO 20717
20717: DISABLE
20718: LD_INT 0
20720: PPUSH
// begin repeat wait ( 0 0$1 ) ;
20721: LD_INT 35
20723: PPUSH
20724: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
20728: LD_INT 14
20730: PPUSH
20731: LD_INT 22
20733: PUSH
20734: LD_INT 1
20736: PUSH
20737: EMPTY
20738: LIST
20739: LIST
20740: PUSH
20741: LD_INT 3
20743: PUSH
20744: LD_INT 21
20746: PUSH
20747: LD_INT 3
20749: PUSH
20750: EMPTY
20751: LIST
20752: LIST
20753: PUSH
20754: EMPTY
20755: LIST
20756: LIST
20757: PUSH
20758: EMPTY
20759: LIST
20760: LIST
20761: PPUSH
20762: CALL_OW 70
20766: PUSH
20767: LD_EXP 15
20771: PUSH
20772: LD_INT 2
20774: PUSH
20775: LD_INT 3
20777: PUSH
20778: LD_INT 4
20780: PUSH
20781: LD_INT 5
20783: PUSH
20784: EMPTY
20785: LIST
20786: LIST
20787: LIST
20788: LIST
20789: IN
20790: AND
20791: IFFALSE 21028
// begin powellAnger := powellAnger + 1 ;
20793: LD_ADDR_EXP 17
20797: PUSH
20798: LD_EXP 17
20802: PUSH
20803: LD_INT 1
20805: PLUS
20806: ST_TO_ADDR
// Video ( true ) ;
20807: LD_INT 1
20809: PPUSH
20810: CALL 107107 0 1
// CenterNowOnUnits ( tmp ) ;
20814: LD_VAR 0 1
20818: PPUSH
20819: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
20823: LD_INT 14
20825: PPUSH
20826: LD_INT 22
20828: PUSH
20829: LD_INT 1
20831: PUSH
20832: EMPTY
20833: LIST
20834: LIST
20835: PPUSH
20836: CALL_OW 70
20840: PPUSH
20841: LD_INT 86
20843: PPUSH
20844: LD_INT 133
20846: PPUSH
20847: CALL_OW 111
// async ;
20851: ASYNC
// case powellAnger of 1 :
20852: LD_EXP 17
20856: PUSH
20857: LD_INT 1
20859: DOUBLE
20860: EQUAL
20861: IFTRUE 20865
20863: GO 20880
20865: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
20866: LD_EXP 60
20870: PPUSH
20871: LD_STRING DBack1-Pow-1
20873: PPUSH
20874: CALL_OW 88
20878: GO 20927
20880: LD_INT 2
20882: DOUBLE
20883: EQUAL
20884: IFTRUE 20888
20886: GO 20903
20888: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
20889: LD_EXP 60
20893: PPUSH
20894: LD_STRING DBack2-Pow-1
20896: PPUSH
20897: CALL_OW 88
20901: GO 20927
20903: LD_INT 3
20905: DOUBLE
20906: EQUAL
20907: IFTRUE 20911
20909: GO 20926
20911: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
20912: LD_EXP 60
20916: PPUSH
20917: LD_STRING DBack3-Pow-1
20919: PPUSH
20920: CALL_OW 88
20924: GO 20927
20926: POP
// sync ;
20927: SYNC
// repeat wait ( 0 0$1 ) ;
20928: LD_INT 35
20930: PPUSH
20931: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
20935: LD_INT 14
20937: PPUSH
20938: LD_INT 22
20940: PUSH
20941: LD_INT 1
20943: PUSH
20944: EMPTY
20945: LIST
20946: LIST
20947: PPUSH
20948: CALL_OW 70
20952: PPUSH
20953: LD_INT 86
20955: PPUSH
20956: LD_INT 133
20958: PPUSH
20959: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20963: LD_INT 14
20965: PPUSH
20966: LD_INT 22
20968: PUSH
20969: LD_INT 1
20971: PUSH
20972: EMPTY
20973: LIST
20974: LIST
20975: PUSH
20976: LD_INT 3
20978: PUSH
20979: LD_INT 21
20981: PUSH
20982: LD_INT 3
20984: PUSH
20985: EMPTY
20986: LIST
20987: LIST
20988: PUSH
20989: EMPTY
20990: LIST
20991: LIST
20992: PUSH
20993: EMPTY
20994: LIST
20995: LIST
20996: PPUSH
20997: CALL_OW 70
21001: NOT
21002: IFFALSE 20928
// if powellAnger >= 3 then
21004: LD_EXP 17
21008: PUSH
21009: LD_INT 3
21011: GREATEREQUAL
21012: IFFALSE 21021
// YouLost ( Dismissed ) ;
21014: LD_STRING Dismissed
21016: PPUSH
21017: CALL_OW 104
// Video ( false ) ;
21021: LD_INT 0
21023: PPUSH
21024: CALL 107107 0 1
// end ; until missionStage > 5 ;
21028: LD_EXP 15
21032: PUSH
21033: LD_INT 5
21035: GREATER
21036: IFFALSE 20721
// end ;
21038: PPOPN 1
21040: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t , p ;
21041: LD_EXP 13
21045: PUSH
21046: LD_INT 22
21048: PUSH
21049: LD_INT 4
21051: PUSH
21052: EMPTY
21053: LIST
21054: LIST
21055: PUSH
21056: LD_INT 21
21058: PUSH
21059: LD_INT 2
21061: PUSH
21062: EMPTY
21063: LIST
21064: LIST
21065: PUSH
21066: EMPTY
21067: LIST
21068: LIST
21069: PPUSH
21070: CALL_OW 69
21074: PUSH
21075: LD_INT 4
21077: GREATEREQUAL
21078: AND
21079: PUSH
21080: LD_EXP 15
21084: PUSH
21085: LD_INT 2
21087: EQUAL
21088: AND
21089: IFFALSE 23339
21091: GO 21093
21093: DISABLE
21094: LD_INT 0
21096: PPUSH
21097: PPUSH
21098: PPUSH
21099: PPUSH
21100: PPUSH
21101: PPUSH
21102: PPUSH
21103: PPUSH
21104: PPUSH
21105: PPUSH
21106: PPUSH
// begin missionStage := 3 ;
21107: LD_ADDR_EXP 15
21111: PUSH
21112: LD_INT 3
21114: ST_TO_ADDR
// retreat := false ;
21115: LD_ADDR_VAR 0 4
21119: PUSH
21120: LD_INT 0
21122: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
21123: LD_ADDR_VAR 0 5
21127: PUSH
21128: LD_INT 22
21130: PUSH
21131: LD_INT 4
21133: PUSH
21134: EMPTY
21135: LIST
21136: LIST
21137: PUSH
21138: LD_INT 30
21140: PUSH
21141: LD_INT 4
21143: PUSH
21144: EMPTY
21145: LIST
21146: LIST
21147: PUSH
21148: EMPTY
21149: LIST
21150: LIST
21151: PPUSH
21152: CALL_OW 69
21156: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21157: LD_ADDR_VAR 0 6
21161: PUSH
21162: LD_INT 22
21164: PUSH
21165: LD_INT 4
21167: PUSH
21168: EMPTY
21169: LIST
21170: LIST
21171: PUSH
21172: LD_INT 30
21174: PUSH
21175: LD_INT 5
21177: PUSH
21178: EMPTY
21179: LIST
21180: LIST
21181: PUSH
21182: EMPTY
21183: LIST
21184: LIST
21185: PPUSH
21186: CALL_OW 69
21190: ST_TO_ADDR
// if not bar then
21191: LD_VAR 0 6
21195: NOT
21196: IFFALSE 21249
// begin repeat wait ( 0 0$1 ) ;
21198: LD_INT 35
21200: PPUSH
21201: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
21205: LD_INT 22
21207: PUSH
21208: LD_INT 4
21210: PUSH
21211: EMPTY
21212: LIST
21213: LIST
21214: PUSH
21215: LD_INT 3
21217: PUSH
21218: LD_INT 57
21220: PUSH
21221: EMPTY
21222: LIST
21223: PUSH
21224: EMPTY
21225: LIST
21226: LIST
21227: PUSH
21228: LD_INT 30
21230: PUSH
21231: LD_INT 5
21233: PUSH
21234: EMPTY
21235: LIST
21236: LIST
21237: PUSH
21238: EMPTY
21239: LIST
21240: LIST
21241: LIST
21242: PPUSH
21243: CALL_OW 69
21247: IFFALSE 21198
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21249: LD_ADDR_VAR 0 6
21253: PUSH
21254: LD_INT 22
21256: PUSH
21257: LD_INT 4
21259: PUSH
21260: EMPTY
21261: LIST
21262: LIST
21263: PUSH
21264: LD_INT 30
21266: PUSH
21267: LD_INT 5
21269: PUSH
21270: EMPTY
21271: LIST
21272: LIST
21273: PUSH
21274: EMPTY
21275: LIST
21276: LIST
21277: PPUSH
21278: CALL_OW 69
21282: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21283: LD_INT 35
21285: PPUSH
21286: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
21290: LD_EXP 120
21294: PUSH
21295: LD_INT 4
21297: ARRAY
21298: PUSH
21299: LD_INT 4
21301: GREATEREQUAL
21302: IFFALSE 21283
// tmp := [ ] ;
21304: LD_ADDR_VAR 0 2
21308: PUSH
21309: EMPTY
21310: ST_TO_ADDR
// tmp2 := [ ] ;
21311: LD_ADDR_VAR 0 3
21315: PUSH
21316: EMPTY
21317: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell union vip ) do
21318: LD_ADDR_VAR 0 1
21322: PUSH
21323: LD_INT 22
21325: PUSH
21326: LD_INT 4
21328: PUSH
21329: EMPTY
21330: LIST
21331: LIST
21332: PUSH
21333: LD_INT 2
21335: PUSH
21336: LD_INT 25
21338: PUSH
21339: LD_INT 1
21341: PUSH
21342: EMPTY
21343: LIST
21344: LIST
21345: PUSH
21346: LD_INT 25
21348: PUSH
21349: LD_INT 2
21351: PUSH
21352: EMPTY
21353: LIST
21354: LIST
21355: PUSH
21356: LD_INT 25
21358: PUSH
21359: LD_INT 3
21361: PUSH
21362: EMPTY
21363: LIST
21364: LIST
21365: PUSH
21366: LD_INT 25
21368: PUSH
21369: LD_INT 4
21371: PUSH
21372: EMPTY
21373: LIST
21374: LIST
21375: PUSH
21376: LD_INT 25
21378: PUSH
21379: LD_INT 5
21381: PUSH
21382: EMPTY
21383: LIST
21384: LIST
21385: PUSH
21386: EMPTY
21387: LIST
21388: LIST
21389: LIST
21390: LIST
21391: LIST
21392: LIST
21393: PUSH
21394: EMPTY
21395: LIST
21396: LIST
21397: PPUSH
21398: CALL_OW 69
21402: PUSH
21403: LD_EXP 60
21407: PUSH
21408: LD_EXP 61
21412: UNION
21413: DIFF
21414: PUSH
21415: FOR_IN
21416: IFFALSE 21478
// if not i in extraSquad then
21418: LD_VAR 0 1
21422: PUSH
21423: LD_EXP 62
21427: IN
21428: NOT
21429: IFFALSE 21453
// tmp := Join ( tmp , i ) else
21431: LD_ADDR_VAR 0 2
21435: PUSH
21436: LD_VAR 0 2
21440: PPUSH
21441: LD_VAR 0 1
21445: PPUSH
21446: CALL 107135 0 2
21450: ST_TO_ADDR
21451: GO 21476
// tmp := Insert ( tmp , 1 , i ) ;
21453: LD_ADDR_VAR 0 2
21457: PUSH
21458: LD_VAR 0 2
21462: PPUSH
21463: LD_INT 1
21465: PPUSH
21466: LD_VAR 0 1
21470: PPUSH
21471: CALL_OW 2
21475: ST_TO_ADDR
21476: GO 21415
21478: POP
21479: POP
// for i in UnitFilter ( tmp , [ f_sex , sex_male ] ) do
21480: LD_ADDR_VAR 0 1
21484: PUSH
21485: LD_VAR 0 2
21489: PPUSH
21490: LD_INT 26
21492: PUSH
21493: LD_INT 1
21495: PUSH
21496: EMPTY
21497: LIST
21498: LIST
21499: PPUSH
21500: CALL_OW 72
21504: PUSH
21505: FOR_IN
21506: IFFALSE 21557
// begin p := Inc ( p ) ;
21508: LD_ADDR_VAR 0 11
21512: PUSH
21513: LD_VAR 0 11
21517: PPUSH
21518: CALL 108496 0 1
21522: ST_TO_ADDR
// tmp2 := Join ( tmp2 , i ) ;
21523: LD_ADDR_VAR 0 3
21527: PUSH
21528: LD_VAR 0 3
21532: PPUSH
21533: LD_VAR 0 1
21537: PPUSH
21538: CALL 107135 0 2
21542: ST_TO_ADDR
// if p = 4 then
21543: LD_VAR 0 11
21547: PUSH
21548: LD_INT 4
21550: EQUAL
21551: IFFALSE 21555
// break ;
21553: GO 21557
// end ;
21555: GO 21505
21557: POP
21558: POP
// tmp := tmp diff tmp2 ;
21559: LD_ADDR_VAR 0 2
21563: PUSH
21564: LD_VAR 0 2
21568: PUSH
21569: LD_VAR 0 3
21573: DIFF
21574: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
21575: LD_ADDR_VAR 0 2
21579: PUSH
21580: LD_VAR 0 2
21584: PPUSH
21585: LD_INT 3
21587: PPUSH
21588: CALL 105639 0 2
21592: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
21593: LD_ADDR_VAR 0 3
21597: PUSH
21598: LD_VAR 0 3
21602: PPUSH
21603: LD_INT 3
21605: PPUSH
21606: CALL 105639 0 2
21610: ST_TO_ADDR
// for i := 1 to 4 do
21611: LD_ADDR_VAR 0 1
21615: PUSH
21616: DOUBLE
21617: LD_INT 1
21619: DEC
21620: ST_TO_ADDR
21621: LD_INT 4
21623: PUSH
21624: FOR_TO
21625: IFFALSE 21778
// begin if tmp2 then
21627: LD_VAR 0 3
21631: IFFALSE 21699
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
21633: LD_ADDR_EXP 18
21637: PUSH
21638: LD_EXP 18
21642: PPUSH
21643: LD_INT 1
21645: PPUSH
21646: LD_EXP 18
21650: PUSH
21651: LD_INT 1
21653: ARRAY
21654: PUSH
21655: LD_VAR 0 3
21659: PUSH
21660: LD_VAR 0 3
21664: ARRAY
21665: ADD
21666: PPUSH
21667: CALL_OW 1
21671: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
21672: LD_VAR 0 3
21676: PUSH
21677: LD_VAR 0 3
21681: ARRAY
21682: PPUSH
21683: LD_INT 1
21685: PPUSH
21686: CALL_OW 109
// tmp2 := [ ] ;
21690: LD_ADDR_VAR 0 3
21694: PUSH
21695: EMPTY
21696: ST_TO_ADDR
// end else
21697: GO 21776
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
21699: LD_ADDR_EXP 18
21703: PUSH
21704: LD_EXP 18
21708: PPUSH
21709: LD_INT 1
21711: PPUSH
21712: LD_EXP 18
21716: PUSH
21717: LD_INT 1
21719: ARRAY
21720: PUSH
21721: LD_VAR 0 2
21725: PUSH
21726: LD_VAR 0 2
21730: ARRAY
21731: ADD
21732: PPUSH
21733: CALL_OW 1
21737: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
21738: LD_VAR 0 2
21742: PUSH
21743: LD_VAR 0 2
21747: ARRAY
21748: PPUSH
21749: LD_INT 1
21751: PPUSH
21752: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
21756: LD_ADDR_VAR 0 2
21760: PUSH
21761: LD_VAR 0 2
21765: PPUSH
21766: LD_VAR 0 2
21770: PPUSH
21771: CALL_OW 3
21775: ST_TO_ADDR
// end ; end ;
21776: GO 21624
21778: POP
21779: POP
// if tmp2 then
21780: LD_VAR 0 3
21784: IFFALSE 21802
// tmp := tmp union tmp2 ;
21786: LD_ADDR_VAR 0 2
21790: PUSH
21791: LD_VAR 0 2
21795: PUSH
21796: LD_VAR 0 3
21800: UNION
21801: ST_TO_ADDR
// for i := 1 to 4 do
21802: LD_ADDR_VAR 0 1
21806: PUSH
21807: DOUBLE
21808: LD_INT 1
21810: DEC
21811: ST_TO_ADDR
21812: LD_INT 4
21814: PUSH
21815: FOR_TO
21816: IFFALSE 21865
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
21818: LD_ADDR_EXP 18
21822: PUSH
21823: LD_EXP 18
21827: PPUSH
21828: LD_INT 2
21830: PPUSH
21831: LD_EXP 18
21835: PUSH
21836: LD_INT 2
21838: ARRAY
21839: PUSH
21840: LD_VAR 0 2
21844: PUSH
21845: LD_VAR 0 2
21849: PUSH
21850: LD_VAR 0 1
21854: MINUS
21855: ARRAY
21856: ADD
21857: PPUSH
21858: CALL_OW 1
21862: ST_TO_ADDR
21863: GO 21815
21865: POP
21866: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
21867: LD_ADDR_EXP 101
21871: PUSH
21872: LD_EXP 101
21876: PPUSH
21877: LD_INT 4
21879: PPUSH
21880: LD_EXP 101
21884: PUSH
21885: LD_INT 4
21887: ARRAY
21888: PUSH
21889: LD_EXP 18
21893: PUSH
21894: LD_INT 1
21896: ARRAY
21897: DIFF
21898: PPUSH
21899: CALL_OW 1
21903: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
21904: LD_VAR 0 5
21908: PUSH
21909: LD_INT 1
21911: ARRAY
21912: PPUSH
21913: CALL_OW 313
21917: IFFALSE 21972
// begin for i in UnitsInside ( arm [ 1 ] ) do
21919: LD_ADDR_VAR 0 1
21923: PUSH
21924: LD_VAR 0 5
21928: PUSH
21929: LD_INT 1
21931: ARRAY
21932: PPUSH
21933: CALL_OW 313
21937: PUSH
21938: FOR_IN
21939: IFFALSE 21970
// begin ComExitBuilding ( i ) ;
21941: LD_VAR 0 1
21945: PPUSH
21946: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
21950: LD_VAR 0 1
21954: PPUSH
21955: LD_VAR 0 6
21959: PUSH
21960: LD_INT 1
21962: ARRAY
21963: PPUSH
21964: CALL_OW 180
// end ;
21968: GO 21938
21970: POP
21971: POP
// end ; wait ( 0 0$3 ) ;
21972: LD_INT 105
21974: PPUSH
21975: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
21979: LD_ADDR_VAR 0 1
21983: PUSH
21984: LD_EXP 18
21988: PUSH
21989: LD_INT 1
21991: ARRAY
21992: PUSH
21993: FOR_IN
21994: IFFALSE 22101
// begin if IsInUnit ( i ) then
21996: LD_VAR 0 1
22000: PPUSH
22001: CALL_OW 310
22005: IFFALSE 22016
// ComExitBuilding ( i ) ;
22007: LD_VAR 0 1
22011: PPUSH
22012: CALL_OW 122
// if GetClass ( i ) <> 1 then
22016: LD_VAR 0 1
22020: PPUSH
22021: CALL_OW 257
22025: PUSH
22026: LD_INT 1
22028: NONEQUAL
22029: IFFALSE 22070
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
22031: LD_VAR 0 1
22035: PPUSH
22036: LD_VAR 0 5
22040: PUSH
22041: LD_INT 1
22043: ARRAY
22044: PPUSH
22045: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
22049: LD_VAR 0 1
22053: PPUSH
22054: LD_INT 1
22056: PPUSH
22057: CALL_OW 183
// AddComExitBuilding ( i ) ;
22061: LD_VAR 0 1
22065: PPUSH
22066: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
22070: LD_VAR 0 1
22074: PPUSH
22075: LD_INT 60
22077: PPUSH
22078: LD_INT 94
22080: PPUSH
22081: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
22085: LD_VAR 0 1
22089: PPUSH
22090: LD_EXP 60
22094: PPUSH
22095: CALL_OW 179
// end ;
22099: GO 21993
22101: POP
22102: POP
// wait ( 0 0$45 ) ;
22103: LD_INT 1575
22105: PPUSH
22106: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
22110: LD_EXP 60
22114: PPUSH
22115: LD_STRING D4-Pow-1
22117: PPUSH
22118: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
22122: LD_ADDR_VAR 0 2
22126: PUSH
22127: LD_EXP 18
22131: PUSH
22132: LD_INT 1
22134: ARRAY
22135: PPUSH
22136: LD_INT 26
22138: PUSH
22139: LD_INT 1
22141: PUSH
22142: EMPTY
22143: LIST
22144: LIST
22145: PPUSH
22146: CALL_OW 72
22150: ST_TO_ADDR
// if tmp then
22151: LD_VAR 0 2
22155: IFFALSE 22173
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
22157: LD_VAR 0 2
22161: PUSH
22162: LD_INT 1
22164: ARRAY
22165: PPUSH
22166: LD_STRING D4-Sol1-1
22168: PPUSH
22169: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
22173: LD_EXP 60
22177: PPUSH
22178: LD_STRING D4-Pow-2
22180: PPUSH
22181: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
22185: LD_ADDR_VAR 0 1
22189: PUSH
22190: DOUBLE
22191: LD_INT 1
22193: DEC
22194: ST_TO_ADDR
22195: LD_EXP 18
22199: PUSH
22200: LD_INT 1
22202: ARRAY
22203: PUSH
22204: FOR_TO
22205: IFFALSE 22298
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
22207: LD_EXP 18
22211: PUSH
22212: LD_INT 1
22214: ARRAY
22215: PUSH
22216: LD_VAR 0 1
22220: ARRAY
22221: PPUSH
22222: LD_EXP 120
22226: PUSH
22227: LD_INT 4
22229: ARRAY
22230: PUSH
22231: LD_INT 1
22233: ARRAY
22234: PPUSH
22235: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
22239: LD_ADDR_EXP 120
22243: PUSH
22244: LD_EXP 120
22248: PPUSH
22249: LD_INT 4
22251: PPUSH
22252: LD_EXP 120
22256: PUSH
22257: LD_INT 4
22259: ARRAY
22260: PPUSH
22261: LD_INT 1
22263: PPUSH
22264: CALL_OW 3
22268: PPUSH
22269: CALL_OW 1
22273: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
22274: LD_INT 8
22276: PPUSH
22277: LD_EXP 18
22281: PUSH
22282: LD_INT 1
22284: ARRAY
22285: PUSH
22286: LD_VAR 0 1
22290: ARRAY
22291: PPUSH
22292: CALL_OW 471
// end ;
22296: GO 22204
22298: POP
22299: POP
// repeat wait ( 0 0$1 ) ;
22300: LD_INT 35
22302: PPUSH
22303: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
22307: LD_EXP 18
22311: PUSH
22312: LD_INT 1
22314: ARRAY
22315: PPUSH
22316: LD_INT 55
22318: PUSH
22319: EMPTY
22320: LIST
22321: PPUSH
22322: CALL_OW 72
22326: PUSH
22327: LD_INT 4
22329: GREATEREQUAL
22330: IFFALSE 22300
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
22332: LD_EXP 18
22336: PUSH
22337: LD_INT 1
22339: ARRAY
22340: PPUSH
22341: LD_INT 69
22343: PPUSH
22344: LD_INT 94
22346: PPUSH
22347: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
22351: LD_EXP 18
22355: PUSH
22356: LD_INT 1
22358: ARRAY
22359: PPUSH
22360: LD_INT 82
22362: PPUSH
22363: LD_INT 83
22365: PPUSH
22366: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
22370: LD_EXP 18
22374: PUSH
22375: LD_INT 1
22377: ARRAY
22378: PPUSH
22379: LD_INT 77
22381: PPUSH
22382: LD_INT 69
22384: PPUSH
22385: CALL_OW 174
// repeat wait ( 3 ) ;
22389: LD_INT 3
22391: PPUSH
22392: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
22396: LD_ADDR_VAR 0 1
22400: PUSH
22401: LD_EXP 18
22405: PUSH
22406: LD_INT 1
22408: ARRAY
22409: PUSH
22410: FOR_IN
22411: IFFALSE 22547
// begin if GetLives ( i ) < 990 then
22413: LD_VAR 0 1
22417: PPUSH
22418: CALL_OW 256
22422: PUSH
22423: LD_INT 990
22425: LESS
22426: IFFALSE 22440
// SetLives ( i , 1000 ) ;
22428: LD_VAR 0 1
22432: PPUSH
22433: LD_INT 1000
22435: PPUSH
22436: CALL_OW 234
// if not IsInUnit ( i ) then
22440: LD_VAR 0 1
22444: PPUSH
22445: CALL_OW 310
22449: NOT
22450: IFFALSE 22545
// begin if not HasTask ( i ) then
22452: LD_VAR 0 1
22456: PPUSH
22457: CALL_OW 314
22461: NOT
22462: IFFALSE 22479
// ComMoveXY ( i , 64 , 93 ) ;
22464: LD_VAR 0 1
22468: PPUSH
22469: LD_INT 64
22471: PPUSH
22472: LD_INT 93
22474: PPUSH
22475: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
22479: LD_VAR 0 4
22483: NOT
22484: PUSH
22485: LD_VAR 0 1
22489: PPUSH
22490: CALL_OW 258
22494: PUSH
22495: LD_INT 1
22497: EQUAL
22498: AND
22499: IFFALSE 22545
// begin retreat := true ;
22501: LD_ADDR_VAR 0 4
22505: PUSH
22506: LD_INT 1
22508: ST_TO_ADDR
// SetTag ( i , 2 ) ;
22509: LD_VAR 0 1
22513: PPUSH
22514: LD_INT 2
22516: PPUSH
22517: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
22521: LD_VAR 0 1
22525: PPUSH
22526: LD_STRING D4a-Sol1-1
22528: PPUSH
22529: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
22533: LD_EXP 60
22537: PPUSH
22538: LD_STRING D4a-Pow-1
22540: PPUSH
22541: CALL_OW 88
// end ; end ; end ;
22545: GO 22410
22547: POP
22548: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
22549: LD_EXP 18
22553: PUSH
22554: LD_INT 1
22556: ARRAY
22557: PPUSH
22558: LD_INT 95
22560: PUSH
22561: LD_INT 9
22563: PUSH
22564: EMPTY
22565: LIST
22566: LIST
22567: PUSH
22568: LD_INT 3
22570: PUSH
22571: LD_INT 55
22573: PUSH
22574: EMPTY
22575: LIST
22576: PUSH
22577: EMPTY
22578: LIST
22579: LIST
22580: PUSH
22581: EMPTY
22582: LIST
22583: LIST
22584: PPUSH
22585: CALL_OW 72
22589: PUSH
22590: LD_INT 4
22592: GREATEREQUAL
22593: IFFALSE 22389
// for i in powellSquadAttack [ 1 ] do
22595: LD_ADDR_VAR 0 1
22599: PUSH
22600: LD_EXP 18
22604: PUSH
22605: LD_INT 1
22607: ARRAY
22608: PUSH
22609: FOR_IN
22610: IFFALSE 22746
// begin if GetTag ( i ) = 2 then
22612: LD_VAR 0 1
22616: PPUSH
22617: CALL_OW 110
22621: PUSH
22622: LD_INT 2
22624: EQUAL
22625: IFFALSE 22687
// begin ComMoveXY ( i , 60 , 94 ) ;
22627: LD_VAR 0 1
22631: PPUSH
22632: LD_INT 60
22634: PPUSH
22635: LD_INT 94
22637: PPUSH
22638: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
22642: LD_VAR 0 1
22646: PPUSH
22647: LD_EXP 60
22651: PPUSH
22652: CALL_OW 179
// wait ( 0 0$3 ) ;
22656: LD_INT 105
22658: PPUSH
22659: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
22663: LD_VAR 0 1
22667: PPUSH
22668: LD_STRING D4a-Sol1-2
22670: PPUSH
22671: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
22675: LD_EXP 60
22679: PPUSH
22680: LD_STRING D4a-Pow-2
22682: PPUSH
22683: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
22687: LD_VAR 0 1
22691: PPUSH
22692: LD_INT 0
22694: PPUSH
22695: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
22699: LD_ADDR_EXP 101
22703: PUSH
22704: LD_EXP 101
22708: PPUSH
22709: LD_INT 4
22711: PPUSH
22712: LD_EXP 101
22716: PUSH
22717: LD_INT 4
22719: ARRAY
22720: PUSH
22721: LD_VAR 0 1
22725: UNION
22726: PPUSH
22727: CALL_OW 1
22731: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
22732: LD_INT 8
22734: PPUSH
22735: LD_VAR 0 1
22739: PPUSH
22740: CALL_OW 472
// end ;
22744: GO 22609
22746: POP
22747: POP
// wait ( 2 2$00 ) ;
22748: LD_INT 4200
22750: PPUSH
22751: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
22755: LD_ADDR_VAR 0 9
22759: PUSH
22760: LD_INT 22
22762: PUSH
22763: LD_INT 4
22765: PUSH
22766: EMPTY
22767: LIST
22768: LIST
22769: PUSH
22770: LD_INT 30
22772: PUSH
22773: LD_INT 32
22775: PUSH
22776: EMPTY
22777: LIST
22778: LIST
22779: PUSH
22780: LD_INT 58
22782: PUSH
22783: EMPTY
22784: LIST
22785: PUSH
22786: EMPTY
22787: LIST
22788: LIST
22789: LIST
22790: PPUSH
22791: CALL_OW 69
22795: ST_TO_ADDR
// if tmp then
22796: LD_VAR 0 2
22800: IFFALSE 23040
// begin for i := 1 to tmp do
22802: LD_ADDR_VAR 0 1
22806: PUSH
22807: DOUBLE
22808: LD_INT 1
22810: DEC
22811: ST_TO_ADDR
22812: LD_VAR 0 2
22816: PUSH
22817: FOR_TO
22818: IFFALSE 23031
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
22820: LD_ADDR_EXP 101
22824: PUSH
22825: LD_EXP 101
22829: PPUSH
22830: LD_INT 4
22832: PPUSH
22833: LD_EXP 101
22837: PUSH
22838: LD_INT 4
22840: ARRAY
22841: PUSH
22842: LD_VAR 0 2
22846: PUSH
22847: LD_VAR 0 1
22851: ARRAY
22852: DIFF
22853: PPUSH
22854: CALL_OW 1
22858: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
22859: LD_ADDR_VAR 0 10
22863: PUSH
22864: LD_VAR 0 2
22868: PUSH
22869: LD_VAR 0 1
22873: ARRAY
22874: PPUSH
22875: CALL_OW 310
22879: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
22880: LD_VAR 0 10
22884: PUSH
22885: LD_VAR 0 10
22889: PPUSH
22890: CALL_OW 266
22894: PUSH
22895: LD_INT 32
22897: EQUAL
22898: AND
22899: IFFALSE 22903
// continue ;
22901: GO 22817
// if t then
22903: LD_VAR 0 10
22907: IFFALSE 22924
// ComExitBuilding ( tmp [ i ] ) ;
22909: LD_VAR 0 2
22913: PUSH
22914: LD_VAR 0 1
22918: ARRAY
22919: PPUSH
22920: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
22924: LD_VAR 0 2
22928: PUSH
22929: LD_VAR 0 1
22933: ARRAY
22934: PPUSH
22935: LD_VAR 0 5
22939: PUSH
22940: LD_INT 1
22942: ARRAY
22943: PPUSH
22944: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
22948: LD_VAR 0 2
22952: PUSH
22953: LD_VAR 0 1
22957: ARRAY
22958: PPUSH
22959: LD_INT 1
22961: PPUSH
22962: CALL_OW 183
// if emptyTowers then
22966: LD_VAR 0 9
22970: IFFALSE 23029
// begin AddComExitBuilding ( tmp [ i ] ) ;
22972: LD_VAR 0 2
22976: PUSH
22977: LD_VAR 0 1
22981: ARRAY
22982: PPUSH
22983: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
22987: LD_VAR 0 2
22991: PUSH
22992: LD_VAR 0 1
22996: ARRAY
22997: PPUSH
22998: LD_VAR 0 9
23002: PUSH
23003: LD_INT 1
23005: ARRAY
23006: PPUSH
23007: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
23011: LD_ADDR_VAR 0 9
23015: PUSH
23016: LD_VAR 0 9
23020: PPUSH
23021: LD_INT 1
23023: PPUSH
23024: CALL_OW 3
23028: ST_TO_ADDR
// end ; end ;
23029: GO 22817
23031: POP
23032: POP
// wait ( 0 0$30 ) ;
23033: LD_INT 1050
23035: PPUSH
23036: CALL_OW 67
// end ; uc_side := 6 ;
23040: LD_ADDR_OWVAR 20
23044: PUSH
23045: LD_INT 6
23047: ST_TO_ADDR
// uc_nation := 3 ;
23048: LD_ADDR_OWVAR 21
23052: PUSH
23053: LD_INT 3
23055: ST_TO_ADDR
// ru := [ ] ;
23056: LD_ADDR_VAR 0 7
23060: PUSH
23061: EMPTY
23062: ST_TO_ADDR
// for i = 1 to 5 do
23063: LD_ADDR_VAR 0 1
23067: PUSH
23068: DOUBLE
23069: LD_INT 1
23071: DEC
23072: ST_TO_ADDR
23073: LD_INT 5
23075: PUSH
23076: FOR_TO
23077: IFFALSE 23197
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
23079: LD_INT 22
23081: PUSH
23082: LD_INT 23
23084: PUSH
23085: EMPTY
23086: LIST
23087: LIST
23088: PUSH
23089: LD_INT 1
23091: PPUSH
23092: LD_INT 2
23094: PPUSH
23095: CALL_OW 12
23099: ARRAY
23100: PPUSH
23101: LD_INT 1
23103: PPUSH
23104: LD_INT 3
23106: PPUSH
23107: LD_INT 43
23109: PUSH
23110: LD_INT 44
23112: PUSH
23113: EMPTY
23114: LIST
23115: LIST
23116: PUSH
23117: LD_INT 1
23119: PPUSH
23120: LD_INT 2
23122: PPUSH
23123: CALL_OW 12
23127: ARRAY
23128: PPUSH
23129: LD_INT 89
23131: PPUSH
23132: CALL 74284 0 5
// un := CreateVehicle ;
23136: LD_ADDR_VAR 0 8
23140: PUSH
23141: CALL_OW 45
23145: ST_TO_ADDR
// SetDir ( un , 4 ) ;
23146: LD_VAR 0 8
23150: PPUSH
23151: LD_INT 4
23153: PPUSH
23154: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
23158: LD_VAR 0 8
23162: PPUSH
23163: LD_INT 136
23165: PPUSH
23166: LD_INT 90
23168: PPUSH
23169: LD_INT 8
23171: PPUSH
23172: LD_INT 0
23174: PPUSH
23175: CALL_OW 50
// ru := ru ^ un ;
23179: LD_ADDR_VAR 0 7
23183: PUSH
23184: LD_VAR 0 7
23188: PUSH
23189: LD_VAR 0 8
23193: ADD
23194: ST_TO_ADDR
// end ;
23195: GO 23076
23197: POP
23198: POP
// if ru then
23199: LD_VAR 0 7
23203: IFFALSE 23220
// ComAgressiveMove ( ru , 57 , 94 ) ;
23205: LD_VAR 0 7
23209: PPUSH
23210: LD_INT 57
23212: PPUSH
23213: LD_INT 94
23215: PPUSH
23216: CALL_OW 114
// wait ( 3 3$00 ) ;
23220: LD_INT 6300
23222: PPUSH
23223: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
23227: LD_INT 4
23229: PPUSH
23230: LD_INT 3
23232: PUSH
23233: LD_INT 1
23235: PUSH
23236: LD_INT 1
23238: PUSH
23239: LD_INT 5
23241: PUSH
23242: EMPTY
23243: LIST
23244: LIST
23245: LIST
23246: LIST
23247: PUSH
23248: LD_INT 4
23250: PUSH
23251: LD_INT 1
23253: PUSH
23254: LD_INT 1
23256: PUSH
23257: LD_INT 6
23259: PUSH
23260: EMPTY
23261: LIST
23262: LIST
23263: LIST
23264: LIST
23265: PUSH
23266: LD_INT 4
23268: PUSH
23269: LD_INT 1
23271: PUSH
23272: LD_INT 1
23274: PUSH
23275: LD_INT 7
23277: PUSH
23278: EMPTY
23279: LIST
23280: LIST
23281: LIST
23282: LIST
23283: PUSH
23284: LD_INT 3
23286: PUSH
23287: LD_INT 1
23289: PUSH
23290: LD_INT 1
23292: PUSH
23293: LD_INT 7
23295: PUSH
23296: EMPTY
23297: LIST
23298: LIST
23299: LIST
23300: LIST
23301: PUSH
23302: LD_INT 3
23304: PUSH
23305: LD_INT 1
23307: PUSH
23308: LD_INT 1
23310: PUSH
23311: LD_INT 5
23313: PUSH
23314: EMPTY
23315: LIST
23316: LIST
23317: LIST
23318: LIST
23319: PUSH
23320: EMPTY
23321: LIST
23322: LIST
23323: LIST
23324: LIST
23325: LIST
23326: PPUSH
23327: CALL 62970 0 2
// missionStage := 4 ;
23331: LD_ADDR_EXP 15
23335: PUSH
23336: LD_INT 4
23338: ST_TO_ADDR
// end ;
23339: PPOPN 11
23341: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
23342: LD_EXP 15
23346: PUSH
23347: LD_INT 4
23349: EQUAL
23350: PUSH
23351: LD_INT 22
23353: PUSH
23354: LD_INT 4
23356: PUSH
23357: EMPTY
23358: LIST
23359: LIST
23360: PUSH
23361: LD_INT 21
23363: PUSH
23364: LD_INT 2
23366: PUSH
23367: EMPTY
23368: LIST
23369: LIST
23370: PUSH
23371: EMPTY
23372: LIST
23373: LIST
23374: PPUSH
23375: CALL_OW 69
23379: PUSH
23380: LD_INT 5
23382: GREATEREQUAL
23383: AND
23384: IFFALSE 27651
23386: GO 23388
23388: DISABLE
23389: LD_INT 0
23391: PPUSH
23392: PPUSH
23393: PPUSH
23394: PPUSH
23395: PPUSH
23396: PPUSH
23397: PPUSH
23398: PPUSH
23399: PPUSH
23400: PPUSH
23401: PPUSH
23402: PPUSH
23403: PPUSH
// begin wait ( 0 0$10 ) ;
23404: LD_INT 350
23406: PPUSH
23407: CALL_OW 67
// missionStage := 5 ;
23411: LD_ADDR_EXP 15
23415: PUSH
23416: LD_INT 5
23418: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
23419: LD_ADDR_VAR 0 10
23423: PUSH
23424: LD_INT 22
23426: PUSH
23427: LD_INT 4
23429: PUSH
23430: EMPTY
23431: LIST
23432: LIST
23433: PUSH
23434: LD_INT 2
23436: PUSH
23437: LD_INT 30
23439: PUSH
23440: LD_INT 4
23442: PUSH
23443: EMPTY
23444: LIST
23445: LIST
23446: PUSH
23447: LD_INT 30
23449: PUSH
23450: LD_INT 5
23452: PUSH
23453: EMPTY
23454: LIST
23455: LIST
23456: PUSH
23457: EMPTY
23458: LIST
23459: LIST
23460: LIST
23461: PUSH
23462: EMPTY
23463: LIST
23464: LIST
23465: PPUSH
23466: CALL_OW 69
23470: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
23471: LD_ADDR_VAR 0 6
23475: PUSH
23476: LD_INT 22
23478: PUSH
23479: LD_INT 4
23481: PUSH
23482: EMPTY
23483: LIST
23484: LIST
23485: PUSH
23486: LD_INT 21
23488: PUSH
23489: LD_INT 1
23491: PUSH
23492: EMPTY
23493: LIST
23494: LIST
23495: PUSH
23496: LD_INT 3
23498: PUSH
23499: LD_INT 25
23501: PUSH
23502: LD_INT 16
23504: PUSH
23505: EMPTY
23506: LIST
23507: LIST
23508: PUSH
23509: EMPTY
23510: LIST
23511: LIST
23512: PUSH
23513: LD_INT 3
23515: PUSH
23516: LD_INT 25
23518: PUSH
23519: LD_INT 12
23521: PUSH
23522: EMPTY
23523: LIST
23524: LIST
23525: PUSH
23526: EMPTY
23527: LIST
23528: LIST
23529: PUSH
23530: EMPTY
23531: LIST
23532: LIST
23533: LIST
23534: LIST
23535: PPUSH
23536: CALL_OW 69
23540: PUSH
23541: LD_EXP 60
23545: DIFF
23546: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
23547: LD_ADDR_VAR 0 9
23551: PUSH
23552: LD_INT 22
23554: PUSH
23555: LD_INT 4
23557: PUSH
23558: EMPTY
23559: LIST
23560: LIST
23561: PUSH
23562: LD_INT 30
23564: PUSH
23565: LD_INT 3
23567: PUSH
23568: EMPTY
23569: LIST
23570: LIST
23571: PUSH
23572: EMPTY
23573: LIST
23574: LIST
23575: PPUSH
23576: CALL_OW 69
23580: PUSH
23581: LD_INT 1
23583: ARRAY
23584: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
23585: LD_INT 350
23587: PPUSH
23588: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
23592: LD_EXP 120
23596: PUSH
23597: LD_INT 4
23599: ARRAY
23600: PUSH
23601: LD_INT 5
23603: LESS
23604: PUSH
23605: LD_VAR 0 9
23609: PPUSH
23610: CALL_OW 461
23614: PUSH
23615: LD_INT 2
23617: EQUAL
23618: AND
23619: IFFALSE 23649
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
23621: LD_INT 4
23623: PPUSH
23624: LD_INT 3
23626: PUSH
23627: LD_INT 1
23629: PUSH
23630: LD_INT 1
23632: PUSH
23633: LD_INT 5
23635: PUSH
23636: EMPTY
23637: LIST
23638: LIST
23639: LIST
23640: LIST
23641: PUSH
23642: EMPTY
23643: LIST
23644: PPUSH
23645: CALL 63018 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
23649: LD_EXP 120
23653: PUSH
23654: LD_INT 4
23656: ARRAY
23657: PUSH
23658: LD_INT 5
23660: GREATEREQUAL
23661: PUSH
23662: LD_EXP 120
23666: PUSH
23667: LD_INT 4
23669: ARRAY
23670: PPUSH
23671: LD_INT 58
23673: PUSH
23674: EMPTY
23675: LIST
23676: PPUSH
23677: CALL_OW 72
23681: PUSH
23682: LD_INT 5
23684: GREATEREQUAL
23685: AND
23686: IFFALSE 23585
// powellAllowRetreat := false ;
23688: LD_ADDR_EXP 19
23692: PUSH
23693: LD_INT 0
23695: ST_TO_ADDR
// activeAttacks := false ;
23696: LD_ADDR_EXP 16
23700: PUSH
23701: LD_INT 0
23703: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
23704: LD_INT 35
23706: PPUSH
23707: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
23711: LD_INT 22
23713: PUSH
23714: LD_INT 6
23716: PUSH
23717: EMPTY
23718: LIST
23719: LIST
23720: PPUSH
23721: CALL_OW 69
23725: PUSH
23726: LD_INT 0
23728: EQUAL
23729: IFFALSE 23704
// tmp := mc_vehicles [ 4 ] ;
23731: LD_ADDR_VAR 0 3
23735: PUSH
23736: LD_EXP 120
23740: PUSH
23741: LD_INT 4
23743: ARRAY
23744: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
23745: LD_ADDR_VAR 0 1
23749: PUSH
23750: DOUBLE
23751: LD_INT 1
23753: DEC
23754: ST_TO_ADDR
23755: LD_EXP 18
23759: PUSH
23760: FOR_TO
23761: IFFALSE 24022
// begin for j in powellSquadAttack [ i ] do
23763: LD_ADDR_VAR 0 2
23767: PUSH
23768: LD_EXP 18
23772: PUSH
23773: LD_VAR 0 1
23777: ARRAY
23778: PUSH
23779: FOR_IN
23780: IFFALSE 24018
// begin forces := forces diff j ;
23782: LD_ADDR_VAR 0 6
23786: PUSH
23787: LD_VAR 0 6
23791: PUSH
23792: LD_VAR 0 2
23796: DIFF
23797: ST_TO_ADDR
// SetTag ( j , 1 ) ;
23798: LD_VAR 0 2
23802: PPUSH
23803: LD_INT 1
23805: PPUSH
23806: CALL_OW 109
// wait ( 0 0$2 ) ;
23810: LD_INT 70
23812: PPUSH
23813: CALL_OW 67
// if IsInUnit ( j ) then
23817: LD_VAR 0 2
23821: PPUSH
23822: CALL_OW 310
23826: IFFALSE 23837
// ComExitBuilding ( j ) ;
23828: LD_VAR 0 2
23832: PPUSH
23833: CALL_OW 122
// if GetClass ( j ) <> 1 then
23837: LD_VAR 0 2
23841: PPUSH
23842: CALL_OW 257
23846: PUSH
23847: LD_INT 1
23849: NONEQUAL
23850: IFFALSE 23930
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
23852: LD_VAR 0 10
23856: PUSH
23857: LD_INT 1
23859: ARRAY
23860: PPUSH
23861: CALL_OW 313
23865: PUSH
23866: LD_INT 5
23868: GREATEREQUAL
23869: IFFALSE 23891
// AddComEnterUnit ( j , arm [ 2 ] ) else
23871: LD_VAR 0 2
23875: PPUSH
23876: LD_VAR 0 10
23880: PUSH
23881: LD_INT 2
23883: ARRAY
23884: PPUSH
23885: CALL_OW 180
23889: GO 23909
// AddComEnterUnit ( j , arm [ 1 ] ) ;
23891: LD_VAR 0 2
23895: PPUSH
23896: LD_VAR 0 10
23900: PUSH
23901: LD_INT 1
23903: ARRAY
23904: PPUSH
23905: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
23909: LD_VAR 0 2
23913: PPUSH
23914: LD_INT 1
23916: PPUSH
23917: CALL_OW 183
// AddComExitBuilding ( j ) ;
23921: LD_VAR 0 2
23925: PPUSH
23926: CALL_OW 182
// end ; if i = 2 then
23930: LD_VAR 0 1
23934: PUSH
23935: LD_INT 2
23937: EQUAL
23938: IFFALSE 23955
// AddComMoveXY ( j , 61 , 93 ) ;
23940: LD_VAR 0 2
23944: PPUSH
23945: LD_INT 61
23947: PPUSH
23948: LD_INT 93
23950: PPUSH
23951: CALL_OW 171
// if i = 1 then
23955: LD_VAR 0 1
23959: PUSH
23960: LD_INT 1
23962: EQUAL
23963: IFFALSE 24016
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
23965: LD_VAR 0 2
23969: PPUSH
23970: LD_VAR 0 3
23974: PUSH
23975: LD_INT 1
23977: ARRAY
23978: PPUSH
23979: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
23983: LD_ADDR_VAR 0 3
23987: PUSH
23988: LD_VAR 0 3
23992: PPUSH
23993: LD_INT 1
23995: PPUSH
23996: CALL_OW 3
24000: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
24001: LD_VAR 0 2
24005: PPUSH
24006: LD_INT 69
24008: PPUSH
24009: LD_INT 94
24011: PPUSH
24012: CALL_OW 171
// end ; end ;
24016: GO 23779
24018: POP
24019: POP
// end ;
24020: GO 23760
24022: POP
24023: POP
// wait ( 0 0$30 ) ;
24024: LD_INT 1050
24026: PPUSH
24027: CALL_OW 67
// MC_Kill ( 4 ) ;
24031: LD_INT 4
24033: PPUSH
24034: CALL 38993 0 1
// tmp := UnitsInside ( fac ) ;
24038: LD_ADDR_VAR 0 3
24042: PUSH
24043: LD_VAR 0 9
24047: PPUSH
24048: CALL_OW 313
24052: ST_TO_ADDR
// if tmp then
24053: LD_VAR 0 3
24057: IFFALSE 24178
// for i in tmp do
24059: LD_ADDR_VAR 0 1
24063: PUSH
24064: LD_VAR 0 3
24068: PUSH
24069: FOR_IN
24070: IFFALSE 24176
// begin ComExitBuilding ( i ) ;
24072: LD_VAR 0 1
24076: PPUSH
24077: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
24081: LD_VAR 0 10
24085: PUSH
24086: LD_INT 2
24088: ARRAY
24089: PPUSH
24090: CALL_OW 313
24094: PUSH
24095: LD_INT 6
24097: LESS
24098: IFFALSE 24120
// AddComEnterUnit ( i , arm [ 2 ] ) else
24100: LD_VAR 0 1
24104: PPUSH
24105: LD_VAR 0 10
24109: PUSH
24110: LD_INT 2
24112: ARRAY
24113: PPUSH
24114: CALL_OW 180
24118: GO 24174
// if UnitsInside ( arm [ 1 ] ) < 6 then
24120: LD_VAR 0 10
24124: PUSH
24125: LD_INT 1
24127: ARRAY
24128: PPUSH
24129: CALL_OW 313
24133: PUSH
24134: LD_INT 6
24136: LESS
24137: IFFALSE 24159
// AddComEnterUnit ( i , arm [ 1 ] ) else
24139: LD_VAR 0 1
24143: PPUSH
24144: LD_VAR 0 10
24148: PUSH
24149: LD_INT 1
24151: ARRAY
24152: PPUSH
24153: CALL_OW 180
24157: GO 24174
// AddComMoveXY ( i , 37 , 68 ) ;
24159: LD_VAR 0 1
24163: PPUSH
24164: LD_INT 37
24166: PPUSH
24167: LD_INT 68
24169: PPUSH
24170: CALL_OW 171
// end ;
24174: GO 24069
24176: POP
24177: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
24178: LD_ADDR_VAR 0 11
24182: PUSH
24183: LD_VAR 0 6
24187: PPUSH
24188: LD_INT 26
24190: PUSH
24191: LD_INT 1
24193: PUSH
24194: EMPTY
24195: LIST
24196: LIST
24197: PPUSH
24198: CALL_OW 72
24202: PUSH
24203: LD_EXP 61
24207: DIFF
24208: ST_TO_ADDR
// if not speaker then
24209: LD_VAR 0 11
24213: NOT
24214: IFFALSE 24241
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
24216: LD_ADDR_VAR 0 11
24220: PUSH
24221: LD_VAR 0 6
24225: PPUSH
24226: LD_INT 26
24228: PUSH
24229: LD_INT 1
24231: PUSH
24232: EMPTY
24233: LIST
24234: LIST
24235: PPUSH
24236: CALL_OW 72
24240: ST_TO_ADDR
// if speaker then
24241: LD_VAR 0 11
24245: IFFALSE 24261
// speaker := speaker [ 1 ] ;
24247: LD_ADDR_VAR 0 11
24251: PUSH
24252: LD_VAR 0 11
24256: PUSH
24257: LD_INT 1
24259: ARRAY
24260: ST_TO_ADDR
// Video ( true ) ;
24261: LD_INT 1
24263: PPUSH
24264: CALL 107107 0 1
// CenterNowOnUnits ( Powell ) ;
24268: LD_EXP 60
24272: PPUSH
24273: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
24277: LD_ADDR_VAR 0 3
24281: PUSH
24282: LD_VAR 0 6
24286: PPUSH
24287: LD_INT 3
24289: PUSH
24290: LD_INT 25
24292: PUSH
24293: LD_INT 1
24295: PUSH
24296: EMPTY
24297: LIST
24298: LIST
24299: PUSH
24300: EMPTY
24301: LIST
24302: LIST
24303: PPUSH
24304: CALL_OW 72
24308: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
24309: LD_ADDR_VAR 0 12
24313: PUSH
24314: LD_INT 22
24316: PUSH
24317: LD_INT 4
24319: PUSH
24320: EMPTY
24321: LIST
24322: LIST
24323: PUSH
24324: LD_INT 30
24326: PUSH
24327: LD_INT 32
24329: PUSH
24330: EMPTY
24331: LIST
24332: LIST
24333: PUSH
24334: LD_INT 58
24336: PUSH
24337: EMPTY
24338: LIST
24339: PUSH
24340: EMPTY
24341: LIST
24342: LIST
24343: LIST
24344: PPUSH
24345: CALL_OW 69
24349: ST_TO_ADDR
// for i := 1 to 4 do
24350: LD_ADDR_VAR 0 1
24354: PUSH
24355: DOUBLE
24356: LD_INT 1
24358: DEC
24359: ST_TO_ADDR
24360: LD_INT 4
24362: PUSH
24363: FOR_TO
24364: IFFALSE 24510
// begin if IsInUnit ( tmp [ i ] ) then
24366: LD_VAR 0 3
24370: PUSH
24371: LD_VAR 0 1
24375: ARRAY
24376: PPUSH
24377: CALL_OW 310
24381: IFFALSE 24398
// ComExitBuilding ( tmp [ i ] ) ;
24383: LD_VAR 0 3
24387: PUSH
24388: LD_VAR 0 1
24392: ARRAY
24393: PPUSH
24394: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
24398: LD_VAR 0 3
24402: PUSH
24403: LD_VAR 0 1
24407: ARRAY
24408: PPUSH
24409: LD_VAR 0 10
24413: PUSH
24414: LD_INT 1
24416: ARRAY
24417: PPUSH
24418: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
24422: LD_VAR 0 3
24426: PUSH
24427: LD_VAR 0 1
24431: ARRAY
24432: PPUSH
24433: LD_INT 1
24435: PPUSH
24436: CALL_OW 183
// if Count ( emp_towers ) then
24440: LD_VAR 0 12
24444: PPUSH
24445: CALL 71546 0 1
24449: IFFALSE 24508
// begin AddComExitBuilding ( tmp [ i ] ) ;
24451: LD_VAR 0 3
24455: PUSH
24456: LD_VAR 0 1
24460: ARRAY
24461: PPUSH
24462: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
24466: LD_VAR 0 3
24470: PUSH
24471: LD_VAR 0 1
24475: ARRAY
24476: PPUSH
24477: LD_VAR 0 12
24481: PUSH
24482: LD_INT 1
24484: ARRAY
24485: PPUSH
24486: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
24490: LD_ADDR_VAR 0 12
24494: PUSH
24495: LD_VAR 0 12
24499: PPUSH
24500: LD_INT 1
24502: PPUSH
24503: CALL_OW 3
24507: ST_TO_ADDR
// end ; end ;
24508: GO 24363
24510: POP
24511: POP
// wait ( 0 0$5 ) ;
24512: LD_INT 175
24514: PPUSH
24515: CALL_OW 67
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
24519: LD_VAR 0 3
24523: PPUSH
24524: LD_INT 3
24526: PUSH
24527: LD_INT 54
24529: PUSH
24530: EMPTY
24531: LIST
24532: PUSH
24533: EMPTY
24534: LIST
24535: LIST
24536: PPUSH
24537: CALL_OW 72
24541: IFFALSE 24561
// ComEnterUnit ( tmp , arm [ 1 ] ) ;
24543: LD_VAR 0 3
24547: PPUSH
24548: LD_VAR 0 10
24552: PUSH
24553: LD_INT 1
24555: ARRAY
24556: PPUSH
24557: CALL_OW 120
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
24561: LD_ADDR_VAR 0 3
24565: PUSH
24566: LD_EXP 18
24570: PUSH
24571: LD_INT 1
24573: ARRAY
24574: PUSH
24575: LD_EXP 18
24579: PUSH
24580: LD_INT 2
24582: ARRAY
24583: ADD
24584: PPUSH
24585: LD_INT 26
24587: PUSH
24588: LD_INT 1
24590: PUSH
24591: EMPTY
24592: LIST
24593: LIST
24594: PPUSH
24595: CALL_OW 72
24599: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
24600: LD_ADDR_VAR 0 1
24604: PUSH
24605: LD_EXP 18
24609: PUSH
24610: LD_INT 2
24612: ARRAY
24613: PUSH
24614: FOR_IN
24615: IFFALSE 24633
// ComTurnUnit ( i , Powell ) ;
24617: LD_VAR 0 1
24621: PPUSH
24622: LD_EXP 60
24626: PPUSH
24627: CALL_OW 119
24631: GO 24614
24633: POP
24634: POP
// Say ( Powell , D5-Pow-1 ) ;
24635: LD_EXP 60
24639: PPUSH
24640: LD_STRING D5-Pow-1
24642: PPUSH
24643: CALL_OW 88
// if tmp then
24647: LD_VAR 0 3
24651: IFFALSE 24669
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
24653: LD_VAR 0 3
24657: PUSH
24658: LD_INT 1
24660: ARRAY
24661: PPUSH
24662: LD_STRING D5-Sol2-1
24664: PPUSH
24665: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
24669: LD_EXP 60
24673: PPUSH
24674: LD_STRING D5-Pow-2
24676: PPUSH
24677: CALL_OW 88
// if tmp > 1 then
24681: LD_VAR 0 3
24685: PUSH
24686: LD_INT 1
24688: GREATER
24689: IFFALSE 24707
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
24691: LD_VAR 0 3
24695: PUSH
24696: LD_INT 2
24698: ARRAY
24699: PPUSH
24700: LD_STRING D5-Sol2-2
24702: PPUSH
24703: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
24707: LD_EXP 60
24711: PPUSH
24712: LD_STRING D5-Pow-3
24714: PPUSH
24715: CALL_OW 88
// wait ( 0 0$1 ) ;
24719: LD_INT 35
24721: PPUSH
24722: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
24726: LD_ADDR_VAR 0 3
24730: PUSH
24731: LD_EXP 18
24735: PUSH
24736: LD_INT 1
24738: ARRAY
24739: PUSH
24740: LD_EXP 18
24744: PUSH
24745: LD_INT 2
24747: ARRAY
24748: UNION
24749: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
24750: LD_VAR 0 3
24754: PPUSH
24755: LD_INT 80
24757: PPUSH
24758: LD_INT 67
24760: PPUSH
24761: CALL_OW 114
// wait ( 0 0$2 ) ;
24765: LD_INT 70
24767: PPUSH
24768: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
24772: LD_INT 79
24774: PPUSH
24775: LD_INT 72
24777: PPUSH
24778: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
24782: LD_INT 70
24784: PPUSH
24785: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
24789: LD_VAR 0 3
24793: PPUSH
24794: LD_INT 3
24796: PUSH
24797: LD_INT 24
24799: PUSH
24800: LD_INT 1000
24802: PUSH
24803: EMPTY
24804: LIST
24805: LIST
24806: PUSH
24807: EMPTY
24808: LIST
24809: LIST
24810: PPUSH
24811: CALL_OW 72
24815: IFFALSE 24782
// Say ( Powell , D5a-Pow-1 ) ;
24817: LD_EXP 60
24821: PPUSH
24822: LD_STRING D5a-Pow-1
24824: PPUSH
24825: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
24829: LD_EXP 60
24833: PPUSH
24834: LD_STRING D5a-Pow-1a
24836: PPUSH
24837: CALL_OW 88
// wait ( 0 0$0.7 ) ;
24841: LD_INT 24
24843: PPUSH
24844: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
24848: LD_EXP 60
24852: PPUSH
24853: LD_STRING D5a-Pow-1b
24855: PPUSH
24856: CALL_OW 88
// wait ( 0 0$0.3 ) ;
24860: LD_INT 10
24862: PPUSH
24863: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
24867: LD_EXP 60
24871: PPUSH
24872: LD_STRING D5a-Pow-1c
24874: PPUSH
24875: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
24879: LD_VAR 0 3
24883: PPUSH
24884: LD_INT 68
24886: PPUSH
24887: LD_INT 63
24889: PPUSH
24890: CALL_OW 111
// wait ( 0 0$0.5 ) ;
24894: LD_INT 18
24896: PPUSH
24897: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
24901: LD_EXP 60
24905: PPUSH
24906: LD_STRING D5a-Pow-1d
24908: PPUSH
24909: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
24913: LD_INT 35
24915: PPUSH
24916: CALL_OW 67
// if not HasTask ( tmp ) then
24920: LD_VAR 0 3
24924: PPUSH
24925: CALL_OW 314
24929: NOT
24930: IFFALSE 24947
// ComAgressiveMove ( tmp , 68 , 63 ) ;
24932: LD_VAR 0 3
24936: PPUSH
24937: LD_INT 68
24939: PPUSH
24940: LD_INT 63
24942: PPUSH
24943: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
24947: LD_VAR 0 3
24951: PPUSH
24952: LD_INT 24
24954: PUSH
24955: LD_INT 1
24957: PUSH
24958: EMPTY
24959: LIST
24960: LIST
24961: PPUSH
24962: CALL_OW 72
24966: NOT
24967: IFFALSE 24913
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
24969: LD_ADDR_VAR 0 3
24973: PUSH
24974: LD_INT 22
24976: PUSH
24977: LD_INT 4
24979: PUSH
24980: EMPTY
24981: LIST
24982: LIST
24983: PUSH
24984: LD_INT 92
24986: PUSH
24987: LD_INT 60
24989: PUSH
24990: LD_INT 93
24992: PUSH
24993: LD_INT 10
24995: PUSH
24996: EMPTY
24997: LIST
24998: LIST
24999: LIST
25000: LIST
25001: PUSH
25002: LD_INT 3
25004: PUSH
25005: LD_INT 54
25007: PUSH
25008: EMPTY
25009: LIST
25010: PUSH
25011: EMPTY
25012: LIST
25013: LIST
25014: PUSH
25015: EMPTY
25016: LIST
25017: LIST
25018: LIST
25019: PPUSH
25020: CALL_OW 69
25024: PUSH
25025: LD_EXP 60
25029: DIFF
25030: ST_TO_ADDR
// if tmp then
25031: LD_VAR 0 3
25035: IFFALSE 25069
// for i in tmp do
25037: LD_ADDR_VAR 0 1
25041: PUSH
25042: LD_VAR 0 3
25046: PUSH
25047: FOR_IN
25048: IFFALSE 25067
// ComMoveXY ( i , 36 , 67 ) ;
25050: LD_VAR 0 1
25054: PPUSH
25055: LD_INT 36
25057: PPUSH
25058: LD_INT 67
25060: PPUSH
25061: CALL_OW 111
25065: GO 25047
25067: POP
25068: POP
// wait ( 0 0$3 ) ;
25069: LD_INT 105
25071: PPUSH
25072: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
25076: LD_VAR 0 11
25080: PPUSH
25081: LD_STRING D6-Sol3-1
25083: PPUSH
25084: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
25088: LD_EXP 60
25092: PPUSH
25093: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
25097: LD_EXP 60
25101: PPUSH
25102: LD_STRING D6-Pow-1
25104: PPUSH
25105: CALL_OW 88
// tmp := [ ] ;
25109: LD_ADDR_VAR 0 3
25113: PUSH
25114: EMPTY
25115: ST_TO_ADDR
// for i = 1 to 2 do
25116: LD_ADDR_VAR 0 1
25120: PUSH
25121: DOUBLE
25122: LD_INT 1
25124: DEC
25125: ST_TO_ADDR
25126: LD_INT 2
25128: PUSH
25129: FOR_TO
25130: IFFALSE 25244
// begin uc_side := 8 ;
25132: LD_ADDR_OWVAR 20
25136: PUSH
25137: LD_INT 8
25139: ST_TO_ADDR
// uc_nation := 2 ;
25140: LD_ADDR_OWVAR 21
25144: PUSH
25145: LD_INT 2
25147: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
25148: LD_INT 14
25150: PPUSH
25151: LD_INT 3
25153: PPUSH
25154: LD_INT 2
25156: PPUSH
25157: LD_INT 29
25159: PPUSH
25160: LD_INT 100
25162: PPUSH
25163: CALL 74284 0 5
// veh := CreateVehicle ;
25167: LD_ADDR_VAR 0 13
25171: PUSH
25172: CALL_OW 45
25176: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
25177: LD_VAR 0 13
25181: PPUSH
25182: LD_INT 4
25184: PPUSH
25185: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
25189: LD_VAR 0 13
25193: PPUSH
25194: LD_INT 99
25196: PPUSH
25197: LD_INT 83
25199: PPUSH
25200: LD_INT 3
25202: PPUSH
25203: LD_INT 0
25205: PPUSH
25206: CALL_OW 50
// wait ( 3 ) ;
25210: LD_INT 3
25212: PPUSH
25213: CALL_OW 67
// Connect ( veh ) ;
25217: LD_VAR 0 13
25221: PPUSH
25222: CALL 77752 0 1
// tmp := tmp ^ veh ;
25226: LD_ADDR_VAR 0 3
25230: PUSH
25231: LD_VAR 0 3
25235: PUSH
25236: LD_VAR 0 13
25240: ADD
25241: ST_TO_ADDR
// end ;
25242: GO 25129
25244: POP
25245: POP
// wait ( 0 0$1 ) ;
25246: LD_INT 35
25248: PPUSH
25249: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
25253: LD_INT 99
25255: PPUSH
25256: LD_INT 83
25258: PPUSH
25259: LD_INT 1
25261: PPUSH
25262: LD_INT 10
25264: PPUSH
25265: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
25269: LD_INT 99
25271: PPUSH
25272: LD_INT 83
25274: PPUSH
25275: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
25279: LD_VAR 0 11
25283: PPUSH
25284: LD_STRING D6-Sol3-2
25286: PPUSH
25287: CALL_OW 88
// async ;
25291: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
25292: LD_EXP 60
25296: PPUSH
25297: LD_STRING D6-Pow-2
25299: PPUSH
25300: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
25304: LD_VAR 0 3
25308: PUSH
25309: LD_INT 1
25311: ARRAY
25312: PPUSH
25313: LD_VAR 0 9
25317: PPUSH
25318: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
25322: LD_VAR 0 3
25326: PUSH
25327: LD_INT 2
25329: ARRAY
25330: PPUSH
25331: LD_INT 22
25333: PUSH
25334: LD_INT 4
25336: PUSH
25337: EMPTY
25338: LIST
25339: LIST
25340: PUSH
25341: LD_INT 21
25343: PUSH
25344: LD_INT 3
25346: PUSH
25347: EMPTY
25348: LIST
25349: LIST
25350: PUSH
25351: EMPTY
25352: LIST
25353: LIST
25354: PPUSH
25355: CALL_OW 69
25359: PPUSH
25360: LD_VAR 0 3
25364: PUSH
25365: LD_INT 2
25367: ARRAY
25368: PPUSH
25369: CALL_OW 74
25373: PPUSH
25374: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
25378: LD_EXP 60
25382: PPUSH
25383: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
25387: LD_INT 99
25389: PPUSH
25390: LD_INT 83
25392: PPUSH
25393: LD_INT 1
25395: PPUSH
25396: CALL_OW 331
// repeat wait ( 4 ) ;
25400: LD_INT 4
25402: PPUSH
25403: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
25407: LD_VAR 0 3
25411: PUSH
25412: LD_INT 1
25414: ARRAY
25415: PPUSH
25416: CALL_OW 256
25420: PUSH
25421: LD_INT 1000
25423: LESS
25424: IFFALSE 25442
// SetLives ( tmp [ 1 ] , 1000 ) ;
25426: LD_VAR 0 3
25430: PUSH
25431: LD_INT 1
25433: ARRAY
25434: PPUSH
25435: LD_INT 1000
25437: PPUSH
25438: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
25442: LD_INT 22
25444: PUSH
25445: LD_INT 4
25447: PUSH
25448: EMPTY
25449: LIST
25450: LIST
25451: PUSH
25452: LD_INT 30
25454: PUSH
25455: LD_INT 3
25457: PUSH
25458: EMPTY
25459: LIST
25460: LIST
25461: PUSH
25462: EMPTY
25463: LIST
25464: LIST
25465: PPUSH
25466: CALL_OW 69
25470: PUSH
25471: LD_INT 0
25473: EQUAL
25474: IFFALSE 25400
// skirmish := false ;
25476: LD_ADDR_EXP 99
25480: PUSH
25481: LD_INT 0
25483: ST_TO_ADDR
// sync ;
25484: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
25485: LD_EXP 60
25489: PPUSH
25490: LD_STRING D6a-Pow-1
25492: PPUSH
25493: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
25497: LD_VAR 0 11
25501: PPUSH
25502: LD_STRING D6a-Sol3-1
25504: PPUSH
25505: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
25509: LD_EXP 60
25513: PPUSH
25514: LD_STRING D6a-Pow-2
25516: PPUSH
25517: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
25521: LD_VAR 0 11
25525: PPUSH
25526: LD_STRING D6a-Sol3-2
25528: PPUSH
25529: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
25533: LD_EXP 60
25537: PPUSH
25538: LD_STRING D6a-Pow-3
25540: PPUSH
25541: CALL_OW 88
// powellCenterCameraMode := true ;
25545: LD_ADDR_EXP 20
25549: PUSH
25550: LD_INT 1
25552: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
25553: LD_ADDR_VAR 0 1
25557: PUSH
25558: LD_INT 22
25560: PUSH
25561: LD_INT 8
25563: PUSH
25564: EMPTY
25565: LIST
25566: LIST
25567: PUSH
25568: LD_INT 25
25570: PUSH
25571: LD_INT 2
25573: PUSH
25574: EMPTY
25575: LIST
25576: LIST
25577: PUSH
25578: EMPTY
25579: LIST
25580: LIST
25581: PPUSH
25582: CALL_OW 69
25586: PUSH
25587: FOR_IN
25588: IFFALSE 25643
// begin SetTag ( i , 1 ) ;
25590: LD_VAR 0 1
25594: PPUSH
25595: LD_INT 1
25597: PPUSH
25598: CALL_OW 109
// ComExitBuilding ( i ) ;
25602: LD_VAR 0 1
25606: PPUSH
25607: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
25611: LD_VAR 0 1
25615: PPUSH
25616: LD_INT 35
25618: PPUSH
25619: LD_INT 6
25621: PPUSH
25622: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
25626: LD_VAR 0 1
25630: PPUSH
25631: LD_INT 53
25633: PPUSH
25634: LD_INT 4
25636: PPUSH
25637: CALL_OW 171
// end ;
25641: GO 25587
25643: POP
25644: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
25645: LD_ADDR_VAR 0 3
25649: PUSH
25650: LD_INT 22
25652: PUSH
25653: LD_INT 4
25655: PUSH
25656: EMPTY
25657: LIST
25658: LIST
25659: PUSH
25660: LD_INT 21
25662: PUSH
25663: LD_INT 2
25665: PUSH
25666: EMPTY
25667: LIST
25668: LIST
25669: PUSH
25670: LD_INT 3
25672: PUSH
25673: LD_INT 34
25675: PUSH
25676: LD_INT 12
25678: PUSH
25679: EMPTY
25680: LIST
25681: LIST
25682: PUSH
25683: EMPTY
25684: LIST
25685: LIST
25686: PUSH
25687: EMPTY
25688: LIST
25689: LIST
25690: LIST
25691: PPUSH
25692: CALL_OW 69
25696: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
25697: LD_EXP 60
25701: PPUSH
25702: LD_VAR 0 3
25706: PPUSH
25707: LD_EXP 60
25711: PPUSH
25712: CALL_OW 74
25716: PPUSH
25717: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
25721: LD_EXP 60
25725: PPUSH
25726: LD_INT 100
25728: PPUSH
25729: LD_INT 88
25731: PPUSH
25732: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
25736: LD_EXP 60
25740: PPUSH
25741: LD_INT 100
25743: PPUSH
25744: LD_INT 75
25746: PPUSH
25747: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
25751: LD_EXP 60
25755: PPUSH
25756: LD_INT 88
25758: PPUSH
25759: LD_INT 53
25761: PPUSH
25762: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
25766: LD_INT 8
25768: PPUSH
25769: LD_EXP 60
25773: PPUSH
25774: CALL_OW 471
// repeat wait ( 3 ) ;
25778: LD_INT 3
25780: PPUSH
25781: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
25785: LD_INT 22
25787: PUSH
25788: LD_INT 4
25790: PUSH
25791: EMPTY
25792: LIST
25793: LIST
25794: PUSH
25795: LD_INT 92
25797: PUSH
25798: LD_INT 100
25800: PUSH
25801: LD_INT 75
25803: PUSH
25804: LD_INT 6
25806: PUSH
25807: EMPTY
25808: LIST
25809: LIST
25810: LIST
25811: LIST
25812: PUSH
25813: EMPTY
25814: LIST
25815: LIST
25816: PPUSH
25817: CALL_OW 69
25821: IFFALSE 25778
// async ;
25823: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
25824: LD_EXP 60
25828: PPUSH
25829: LD_STRING D6b-Pow-1
25831: PPUSH
25832: CALL_OW 88
// repeat wait ( 3 ) ;
25836: LD_INT 3
25838: PPUSH
25839: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
25843: LD_EXP 60
25847: PPUSH
25848: CALL_OW 310
25852: PPUSH
25853: CALL_OW 256
25857: PUSH
25858: LD_INT 1000
25860: LESS
25861: IFFALSE 25880
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
25863: LD_EXP 60
25867: PPUSH
25868: CALL_OW 310
25872: PPUSH
25873: LD_INT 1000
25875: PPUSH
25876: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
25880: LD_EXP 60
25884: PPUSH
25885: CALL_OW 256
25889: PUSH
25890: LD_INT 1000
25892: LESS
25893: IFFALSE 25907
// SetLives ( Powell , 1000 ) ;
25895: LD_EXP 60
25899: PPUSH
25900: LD_INT 1000
25902: PPUSH
25903: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
25907: LD_EXP 60
25911: PPUSH
25912: LD_EXP 66
25916: PPUSH
25917: CALL_OW 296
25921: PUSH
25922: LD_INT 5
25924: LESS
25925: PUSH
25926: LD_EXP 60
25930: PPUSH
25931: CALL_OW 310
25935: PPUSH
25936: LD_EXP 66
25940: PPUSH
25941: CALL_OW 296
25945: PUSH
25946: LD_INT 5
25948: LESS
25949: OR
25950: IFFALSE 25969
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
25952: LD_EXP 60
25956: PPUSH
25957: CALL_OW 310
25961: PPUSH
25962: LD_INT 100
25964: PPUSH
25965: CALL_OW 234
// until not IsInUnit ( Powell ) ;
25969: LD_EXP 60
25973: PPUSH
25974: CALL_OW 310
25978: NOT
25979: IFFALSE 25836
// DoNotAttack ( 8 , powellBomb ) ;
25981: LD_INT 8
25983: PPUSH
25984: LD_EXP 66
25988: PPUSH
25989: CALL_OW 471
// game_speed := 4 ;
25993: LD_ADDR_OWVAR 65
25997: PUSH
25998: LD_INT 4
26000: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
26001: LD_EXP 60
26005: PPUSH
26006: LD_STRING D6b-Pow-1a
26008: PPUSH
26009: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
26013: LD_EXP 60
26017: PPUSH
26018: LD_EXP 66
26022: PPUSH
26023: CALL_OW 180
// sync ;
26027: SYNC
// repeat wait ( 0 0$1 ) ;
26028: LD_INT 35
26030: PPUSH
26031: CALL_OW 67
// until IsInUnit ( Powell ) ;
26035: LD_EXP 60
26039: PPUSH
26040: CALL_OW 310
26044: IFFALSE 26028
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
26046: LD_INT 8
26048: PPUSH
26049: LD_EXP 60
26053: PPUSH
26054: CALL_OW 310
26058: PPUSH
26059: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
26063: LD_EXP 60
26067: PPUSH
26068: LD_INT 91
26070: PPUSH
26071: LD_INT 44
26073: PPUSH
26074: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26078: LD_EXP 60
26082: PPUSH
26083: LD_INT 96
26085: PPUSH
26086: LD_INT 44
26088: PPUSH
26089: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26093: LD_EXP 60
26097: PPUSH
26098: LD_INT 96
26100: PPUSH
26101: LD_INT 41
26103: PPUSH
26104: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
26108: LD_EXP 60
26112: PPUSH
26113: LD_INT 92
26115: PPUSH
26116: LD_INT 39
26118: PPUSH
26119: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
26123: LD_EXP 60
26127: PPUSH
26128: LD_INT 88
26130: PPUSH
26131: LD_INT 41
26133: PPUSH
26134: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
26138: LD_EXP 60
26142: PPUSH
26143: LD_INT 91
26145: PPUSH
26146: LD_INT 44
26148: PPUSH
26149: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26153: LD_EXP 60
26157: PPUSH
26158: LD_INT 96
26160: PPUSH
26161: LD_INT 44
26163: PPUSH
26164: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26168: LD_EXP 60
26172: PPUSH
26173: LD_INT 96
26175: PPUSH
26176: LD_INT 41
26178: PPUSH
26179: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
26183: LD_EXP 60
26187: PPUSH
26188: LD_INT 92
26190: PPUSH
26191: LD_INT 39
26193: PPUSH
26194: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
26198: LD_EXP 60
26202: PPUSH
26203: LD_INT 88
26205: PPUSH
26206: LD_INT 41
26208: PPUSH
26209: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
26213: LD_EXP 60
26217: PPUSH
26218: LD_INT 91
26220: PPUSH
26221: LD_INT 44
26223: PPUSH
26224: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
26228: LD_EXP 60
26232: PPUSH
26233: LD_INT 93
26235: PPUSH
26236: LD_INT 39
26238: PPUSH
26239: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
26243: LD_EXP 60
26247: PPUSH
26248: LD_INT 93
26250: PPUSH
26251: LD_INT 36
26253: PPUSH
26254: CALL_OW 171
// wait ( 0 0$3.5 ) ;
26258: LD_INT 122
26260: PPUSH
26261: CALL_OW 67
// game_speed := 4 ;
26265: LD_ADDR_OWVAR 65
26269: PUSH
26270: LD_INT 4
26272: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
26273: LD_EXP 60
26277: PPUSH
26278: LD_STRING D6b-Pow-1b
26280: PPUSH
26281: CALL_OW 88
// tmp := [ ] ;
26285: LD_ADDR_VAR 0 3
26289: PUSH
26290: EMPTY
26291: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
26292: LD_ADDR_VAR 0 5
26296: PUSH
26297: LD_INT 78
26299: PUSH
26300: LD_INT 47
26302: PUSH
26303: EMPTY
26304: LIST
26305: LIST
26306: PUSH
26307: LD_INT 106
26309: PUSH
26310: LD_INT 53
26312: PUSH
26313: EMPTY
26314: LIST
26315: LIST
26316: PUSH
26317: EMPTY
26318: LIST
26319: LIST
26320: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
26321: LD_ADDR_VAR 0 1
26325: PUSH
26326: LD_INT 22
26328: PUSH
26329: LD_INT 8
26331: PUSH
26332: EMPTY
26333: LIST
26334: LIST
26335: PUSH
26336: LD_INT 21
26338: PUSH
26339: LD_INT 3
26341: PUSH
26342: EMPTY
26343: LIST
26344: LIST
26345: PUSH
26346: LD_INT 92
26348: PUSH
26349: LD_INT 90
26351: PUSH
26352: LD_INT 52
26354: PUSH
26355: LD_INT 12
26357: PUSH
26358: EMPTY
26359: LIST
26360: LIST
26361: LIST
26362: LIST
26363: PUSH
26364: EMPTY
26365: LIST
26366: LIST
26367: LIST
26368: PPUSH
26369: CALL_OW 69
26373: PUSH
26374: FOR_IN
26375: IFFALSE 26400
// tmp := tmp ^ UnitsInside ( i ) ;
26377: LD_ADDR_VAR 0 3
26381: PUSH
26382: LD_VAR 0 3
26386: PUSH
26387: LD_VAR 0 1
26391: PPUSH
26392: CALL_OW 313
26396: ADD
26397: ST_TO_ADDR
26398: GO 26374
26400: POP
26401: POP
// for i in tmp do
26402: LD_ADDR_VAR 0 1
26406: PUSH
26407: LD_VAR 0 3
26411: PUSH
26412: FOR_IN
26413: IFFALSE 26575
// begin dist := 9999 ;
26415: LD_ADDR_VAR 0 8
26419: PUSH
26420: LD_INT 9999
26422: ST_TO_ADDR
// _xy := [ ] ;
26423: LD_ADDR_VAR 0 7
26427: PUSH
26428: EMPTY
26429: ST_TO_ADDR
// SetTag ( i , 1 ) ;
26430: LD_VAR 0 1
26434: PPUSH
26435: LD_INT 1
26437: PPUSH
26438: CALL_OW 109
// ComExitBuilding ( i ) ;
26442: LD_VAR 0 1
26446: PPUSH
26447: CALL_OW 122
// for j in xy do
26451: LD_ADDR_VAR 0 2
26455: PUSH
26456: LD_VAR 0 5
26460: PUSH
26461: FOR_IN
26462: IFFALSE 26544
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
26464: LD_VAR 0 1
26468: PPUSH
26469: LD_VAR 0 2
26473: PUSH
26474: LD_INT 1
26476: ARRAY
26477: PPUSH
26478: LD_VAR 0 2
26482: PUSH
26483: LD_INT 2
26485: ARRAY
26486: PPUSH
26487: CALL_OW 297
26491: PUSH
26492: LD_VAR 0 8
26496: LESS
26497: IFFALSE 26542
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
26499: LD_ADDR_VAR 0 8
26503: PUSH
26504: LD_VAR 0 1
26508: PPUSH
26509: LD_VAR 0 2
26513: PUSH
26514: LD_INT 1
26516: ARRAY
26517: PPUSH
26518: LD_VAR 0 2
26522: PUSH
26523: LD_INT 2
26525: ARRAY
26526: PPUSH
26527: CALL_OW 297
26531: ST_TO_ADDR
// _xy := j ;
26532: LD_ADDR_VAR 0 7
26536: PUSH
26537: LD_VAR 0 2
26541: ST_TO_ADDR
// end ;
26542: GO 26461
26544: POP
26545: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
26546: LD_VAR 0 1
26550: PPUSH
26551: LD_VAR 0 7
26555: PUSH
26556: LD_INT 1
26558: ARRAY
26559: PPUSH
26560: LD_VAR 0 7
26564: PUSH
26565: LD_INT 2
26567: ARRAY
26568: PPUSH
26569: CALL_OW 171
// end ;
26573: GO 26412
26575: POP
26576: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
26577: LD_ADDR_VAR 0 4
26581: PUSH
26582: LD_VAR 0 3
26586: PPUSH
26587: LD_INT 26
26589: PUSH
26590: LD_INT 1
26592: PUSH
26593: EMPTY
26594: LIST
26595: LIST
26596: PUSH
26597: LD_INT 25
26599: PUSH
26600: LD_INT 1
26602: PUSH
26603: EMPTY
26604: LIST
26605: LIST
26606: PUSH
26607: EMPTY
26608: LIST
26609: LIST
26610: PPUSH
26611: CALL_OW 72
26615: ST_TO_ADDR
// if tmp2 < 2 then
26616: LD_VAR 0 4
26620: PUSH
26621: LD_INT 2
26623: LESS
26624: IFFALSE 26693
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
26626: LD_ADDR_VAR 0 4
26630: PUSH
26631: LD_INT 22
26633: PUSH
26634: LD_INT 8
26636: PUSH
26637: EMPTY
26638: LIST
26639: LIST
26640: PUSH
26641: LD_INT 26
26643: PUSH
26644: LD_INT 1
26646: PUSH
26647: EMPTY
26648: LIST
26649: LIST
26650: PUSH
26651: LD_INT 3
26653: PUSH
26654: LD_INT 25
26656: PUSH
26657: LD_INT 15
26659: PUSH
26660: EMPTY
26661: LIST
26662: LIST
26663: PUSH
26664: EMPTY
26665: LIST
26666: LIST
26667: PUSH
26668: EMPTY
26669: LIST
26670: LIST
26671: LIST
26672: PPUSH
26673: CALL_OW 69
26677: PUSH
26678: LD_EXP 63
26682: PUSH
26683: LD_EXP 64
26687: PUSH
26688: EMPTY
26689: LIST
26690: LIST
26691: DIFF
26692: ST_TO_ADDR
// if tmp2 then
26693: LD_VAR 0 4
26697: IFFALSE 26715
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
26699: LD_VAR 0 4
26703: PUSH
26704: LD_INT 1
26706: ARRAY
26707: PPUSH
26708: LD_STRING D6b-ArSol1-1
26710: PPUSH
26711: CALL_OW 88
// async ;
26715: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
26716: LD_EXP 60
26720: PPUSH
26721: LD_STRING D6b-Pow-2
26723: PPUSH
26724: CALL_OW 88
// wait ( 0 0$0.5 ) ;
26728: LD_INT 18
26730: PPUSH
26731: CALL_OW 67
// if tmp2 > 1 then
26735: LD_VAR 0 4
26739: PUSH
26740: LD_INT 1
26742: GREATER
26743: IFFALSE 26761
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
26745: LD_VAR 0 4
26749: PUSH
26750: LD_INT 2
26752: ARRAY
26753: PPUSH
26754: LD_STRING D6b-ArSol2-1
26756: PPUSH
26757: CALL_OW 88
// sync ;
26761: SYNC
// repeat wait ( 5 ) ;
26762: LD_INT 5
26764: PPUSH
26765: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
26769: LD_INT 93
26771: PPUSH
26772: LD_INT 36
26774: PPUSH
26775: CALL_OW 428
26779: PPUSH
26780: CALL_OW 255
26784: PUSH
26785: LD_INT 4
26787: EQUAL
26788: IFFALSE 26762
// DialogueOn ;
26790: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
26794: LD_INT 10
26796: PPUSH
26797: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
26801: LD_EXP 60
26805: PPUSH
26806: LD_STRING D6b-Pow-2a
26808: PPUSH
26809: CALL_OW 88
// DialogueOff ;
26813: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
26817: LD_EXP 60
26821: PPUSH
26822: CALL_OW 310
26826: PPUSH
26827: LD_INT 332
26829: PPUSH
26830: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
26834: LD_INT 93
26836: PPUSH
26837: LD_INT 35
26839: PPUSH
26840: LD_INT 1
26842: PPUSH
26843: LD_INT 6
26845: NEG
26846: PPUSH
26847: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
26851: LD_INT 35
26853: PPUSH
26854: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
26858: LD_INT 332
26860: PPUSH
26861: CALL_OW 256
26865: PUSH
26866: LD_INT 1000
26868: LESS
26869: PUSH
26870: LD_INT 332
26872: PPUSH
26873: CALL_OW 300
26877: AND
26878: IFFALSE 26890
// SetLives ( kozlov_fac , 0 ) ;
26880: LD_INT 332
26882: PPUSH
26883: LD_INT 0
26885: PPUSH
26886: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
26890: LD_INT 332
26892: PPUSH
26893: CALL_OW 301
26897: PUSH
26898: LD_EXP 60
26902: PPUSH
26903: CALL_OW 301
26907: OR
26908: IFFALSE 26851
// game_speed := 4 ;
26910: LD_ADDR_OWVAR 65
26914: PUSH
26915: LD_INT 4
26917: ST_TO_ADDR
// powellCenterCameraMode := false ;
26918: LD_ADDR_EXP 20
26922: PUSH
26923: LD_INT 0
26925: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
26926: LD_ADDR_VAR 0 1
26930: PUSH
26931: LD_VAR 0 3
26935: PUSH
26936: LD_INT 22
26938: PUSH
26939: LD_INT 8
26941: PUSH
26942: EMPTY
26943: LIST
26944: LIST
26945: PUSH
26946: LD_INT 25
26948: PUSH
26949: LD_INT 2
26951: PUSH
26952: EMPTY
26953: LIST
26954: LIST
26955: PUSH
26956: EMPTY
26957: LIST
26958: LIST
26959: PPUSH
26960: CALL_OW 69
26964: UNION
26965: PUSH
26966: FOR_IN
26967: IFFALSE 26983
// SetTag ( i , 0 ) ;
26969: LD_VAR 0 1
26973: PPUSH
26974: LD_INT 0
26976: PPUSH
26977: CALL_OW 109
26981: GO 26966
26983: POP
26984: POP
// wait ( 0 0$3 ) ;
26985: LD_INT 105
26987: PPUSH
26988: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
26992: LD_INT 93
26994: PPUSH
26995: LD_INT 35
26997: PPUSH
26998: LD_INT 1
27000: PPUSH
27001: CALL_OW 331
// DialogueOn ;
27005: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
27009: LD_VAR 0 11
27013: PPUSH
27014: LD_STRING D6c-Sol3-1
27016: PPUSH
27017: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
27021: LD_INT 10
27023: PPUSH
27024: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
27028: LD_EXP 40
27032: PPUSH
27033: LD_STRING D6c-JMM-1
27035: PPUSH
27036: CALL_OW 88
// if Cyrus then
27040: LD_EXP 46
27044: IFFALSE 27058
// Say ( Cyrus , D6c-Cyrus-1 ) ;
27046: LD_EXP 46
27050: PPUSH
27051: LD_STRING D6c-Cyrus-1
27053: PPUSH
27054: CALL_OW 88
// if Bobby then
27058: LD_EXP 45
27062: IFFALSE 27076
// Say ( Bobby , D6c-Bobby-1 ) ;
27064: LD_EXP 45
27068: PPUSH
27069: LD_STRING D6c-Bobby-1
27071: PPUSH
27072: CALL_OW 88
// if Cornel then
27076: LD_EXP 51
27080: IFFALSE 27094
// Say ( Cornel , D6c-Corn-1 ) ;
27082: LD_EXP 51
27086: PPUSH
27087: LD_STRING D6c-Corn-1
27089: PPUSH
27090: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
27094: LD_ADDR_VAR 0 4
27098: PUSH
27099: LD_INT 2
27101: PUSH
27102: LD_INT 22
27104: PUSH
27105: LD_INT 1
27107: PUSH
27108: EMPTY
27109: LIST
27110: LIST
27111: PUSH
27112: LD_INT 22
27114: PUSH
27115: LD_INT 4
27117: PUSH
27118: EMPTY
27119: LIST
27120: LIST
27121: PUSH
27122: EMPTY
27123: LIST
27124: LIST
27125: LIST
27126: PUSH
27127: LD_INT 26
27129: PUSH
27130: LD_INT 1
27132: PUSH
27133: EMPTY
27134: LIST
27135: LIST
27136: PUSH
27137: LD_INT 23
27139: PUSH
27140: LD_INT 1
27142: PUSH
27143: EMPTY
27144: LIST
27145: LIST
27146: PUSH
27147: EMPTY
27148: LIST
27149: LIST
27150: LIST
27151: PPUSH
27152: CALL_OW 69
27156: PUSH
27157: LD_VAR 0 11
27161: PUSH
27162: LD_EXP 40
27166: UNION
27167: PUSH
27168: LD_EXP 61
27172: UNION
27173: DIFF
27174: ST_TO_ADDR
// if tmp2 then
27175: LD_VAR 0 4
27179: IFFALSE 27197
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
27181: LD_VAR 0 4
27185: PUSH
27186: LD_INT 1
27188: ARRAY
27189: PPUSH
27190: LD_STRING D6c-Sol1-1
27192: PPUSH
27193: CALL_OW 88
// if Lisa then
27197: LD_EXP 43
27201: IFFALSE 27215
// Say ( Lisa , D6c-Lisa-1 ) ;
27203: LD_EXP 43
27207: PPUSH
27208: LD_STRING D6c-Lisa-1
27210: PPUSH
27211: CALL_OW 88
// if Gary then
27215: LD_EXP 52
27219: IFFALSE 27233
// Say ( Gary , D6c-Gary-1 ) ;
27221: LD_EXP 52
27225: PPUSH
27226: LD_STRING D6c-Gary-1
27228: PPUSH
27229: CALL_OW 88
// if Donaldson then
27233: LD_EXP 44
27237: IFFALSE 27251
// Say ( Donaldson , D6c-Don-1 ) ;
27239: LD_EXP 44
27243: PPUSH
27244: LD_STRING D6c-Don-1
27246: PPUSH
27247: CALL_OW 88
// if tmp2 > 1 then
27251: LD_VAR 0 4
27255: PUSH
27256: LD_INT 1
27258: GREATER
27259: IFFALSE 27277
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
27261: LD_VAR 0 4
27265: PUSH
27266: LD_INT 2
27268: ARRAY
27269: PPUSH
27270: LD_STRING D6c-Sol2-1
27272: PPUSH
27273: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
27277: LD_VAR 0 11
27281: PPUSH
27282: LD_STRING D6c-Sol3-2
27284: PPUSH
27285: CALL_OW 88
// if IsInUnit ( JMM ) then
27289: LD_EXP 40
27293: PPUSH
27294: CALL_OW 310
27298: IFFALSE 27316
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
27300: LD_EXP 40
27304: PPUSH
27305: CALL_OW 310
27309: PPUSH
27310: CALL_OW 87
27314: GO 27325
// CenterNowOnUnits ( JMM ) ;
27316: LD_EXP 40
27320: PPUSH
27321: CALL_OW 87
// dwait ( 0 0$2 ) ;
27325: LD_INT 70
27327: PPUSH
27328: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
27332: LD_EXP 40
27336: PPUSH
27337: LD_STRING D6c-JMM-2
27339: PPUSH
27340: CALL_OW 88
// DialogueOff ;
27344: CALL_OW 7
// Video ( false ) ;
27348: LD_INT 0
27350: PPUSH
27351: CALL 107107 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
27355: LD_INT 22
27357: PUSH
27358: LD_INT 4
27360: PUSH
27361: EMPTY
27362: LIST
27363: LIST
27364: PPUSH
27365: CALL_OW 69
27369: PPUSH
27370: LD_INT 1
27372: PPUSH
27373: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
27377: LD_INT 4
27379: PPUSH
27380: LD_INT 4
27382: PPUSH
27383: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
27387: LD_ADDR_VAR 0 1
27391: PUSH
27392: LD_INT 4
27394: PPUSH
27395: LD_INT 1
27397: PPUSH
27398: LD_INT 2
27400: PPUSH
27401: CALL 69507 0 3
27405: PUSH
27406: FOR_IN
27407: IFFALSE 27444
// if GetTech ( i , 1 ) <> state_researched then
27409: LD_VAR 0 1
27413: PPUSH
27414: LD_INT 1
27416: PPUSH
27417: CALL_OW 321
27421: PUSH
27422: LD_INT 2
27424: NONEQUAL
27425: IFFALSE 27442
// SetTech ( i , 1 , state_researched ) ;
27427: LD_VAR 0 1
27431: PPUSH
27432: LD_INT 1
27434: PPUSH
27435: LD_INT 2
27437: PPUSH
27438: CALL_OW 322
27442: GO 27406
27444: POP
27445: POP
// missionStage := 6 ;
27446: LD_ADDR_EXP 15
27450: PUSH
27451: LD_INT 6
27453: ST_TO_ADDR
// activeAttacks := true ;
27454: LD_ADDR_EXP 16
27458: PUSH
27459: LD_INT 1
27461: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
27462: LD_STRING M2
27464: PPUSH
27465: CALL_OW 337
// SaveForQuickRestart ;
27469: CALL_OW 22
// wait ( 0 0$40 ) ;
27473: LD_INT 1400
27475: PPUSH
27476: CALL_OW 67
// DialogueOn ;
27480: CALL_OW 6
// SayRadioNoFaceNoName ( Friend , D7-Friend-1 ) ;
27484: LD_EXP 65
27488: PPUSH
27489: LD_STRING D7-Friend-1
27491: PPUSH
27492: CALL 111054 0 2
// Say ( JMM , D7-JMM-1 ) ;
27496: LD_EXP 40
27500: PPUSH
27501: LD_STRING D7-JMM-1
27503: PPUSH
27504: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-2 ) ;
27508: LD_EXP 65
27512: PPUSH
27513: LD_STRING D7-Friend-2
27515: PPUSH
27516: CALL 111054 0 2
// Say ( JMM , D7-JMM-2 ) ;
27520: LD_EXP 40
27524: PPUSH
27525: LD_STRING D7-JMM-2
27527: PPUSH
27528: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-3 ) ;
27532: LD_EXP 65
27536: PPUSH
27537: LD_STRING D7-Friend-3
27539: PPUSH
27540: CALL 111054 0 2
// Say ( JMM , D7-JMM-3 ) ;
27544: LD_EXP 40
27548: PPUSH
27549: LD_STRING D7-JMM-3
27551: PPUSH
27552: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-4 ) ;
27556: LD_EXP 65
27560: PPUSH
27561: LD_STRING D7-Friend-4
27563: PPUSH
27564: CALL 111054 0 2
// Say ( JMM , D7-JMM-4 ) ;
27568: LD_EXP 40
27572: PPUSH
27573: LD_STRING D7-JMM-4
27575: PPUSH
27576: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-5 ) ;
27580: LD_EXP 65
27584: PPUSH
27585: LD_STRING D7-Friend-5
27587: PPUSH
27588: CALL 111054 0 2
// Say ( JMM , D7-JMM-5 ) ;
27592: LD_EXP 40
27596: PPUSH
27597: LD_STRING D7-JMM-5
27599: PPUSH
27600: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-6 ) ;
27604: LD_EXP 65
27608: PPUSH
27609: LD_STRING D7-Friend-6
27611: PPUSH
27612: CALL 111054 0 2
// Say ( JMM , D7-JMM-6 ) ;
27616: LD_EXP 40
27620: PPUSH
27621: LD_STRING D7-JMM-6
27623: PPUSH
27624: CALL_OW 88
// DialogueOff ;
27628: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
27632: LD_STRING Mlegion
27634: PPUSH
27635: CALL_OW 337
// skirmish := true ;
27639: LD_ADDR_EXP 99
27643: PUSH
27644: LD_INT 1
27646: ST_TO_ADDR
// RebuildKozlovFactory ;
27647: CALL 5172 0 0
// end ;
27651: PPOPN 13
27653: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
27654: LD_EXP 20
27658: PUSH
27659: LD_EXP 60
27663: PPUSH
27664: CALL_OW 300
27668: AND
27669: IFFALSE 27711
27671: GO 27673
27673: DISABLE
// begin enable ;
27674: ENABLE
// if IsInUnit ( Powell ) then
27675: LD_EXP 60
27679: PPUSH
27680: CALL_OW 310
27684: IFFALSE 27702
// CenterOnUnits ( IsInUnit ( Powell ) ) else
27686: LD_EXP 60
27690: PPUSH
27691: CALL_OW 310
27695: PPUSH
27696: CALL_OW 85
27700: GO 27711
// CenterOnUnits ( Powell ) ;
27702: LD_EXP 60
27706: PPUSH
27707: CALL_OW 85
// end ;
27711: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
27712: LD_INT 22
27714: PUSH
27715: LD_INT 8
27717: PUSH
27718: EMPTY
27719: LIST
27720: LIST
27721: PUSH
27722: LD_INT 34
27724: PUSH
27725: LD_INT 48
27727: PUSH
27728: EMPTY
27729: LIST
27730: LIST
27731: PUSH
27732: EMPTY
27733: LIST
27734: LIST
27735: PPUSH
27736: CALL_OW 69
27740: IFFALSE 28014
27742: GO 27744
27744: DISABLE
27745: LD_INT 0
27747: PPUSH
27748: PPUSH
// begin if missionStage < 9 then
27749: LD_EXP 15
27753: PUSH
27754: LD_INT 9
27756: LESS
27757: IFFALSE 27767
// missionStage := 9 ;
27759: LD_ADDR_EXP 15
27763: PUSH
27764: LD_INT 9
27766: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27767: LD_ADDR_VAR 0 1
27771: PUSH
27772: LD_INT 22
27774: PUSH
27775: LD_INT 8
27777: PUSH
27778: EMPTY
27779: LIST
27780: LIST
27781: PUSH
27782: LD_INT 34
27784: PUSH
27785: LD_INT 48
27787: PUSH
27788: EMPTY
27789: LIST
27790: LIST
27791: PUSH
27792: EMPTY
27793: LIST
27794: LIST
27795: PPUSH
27796: CALL_OW 69
27800: PUSH
27801: LD_INT 1
27803: ARRAY
27804: ST_TO_ADDR
// wait ( 0 0$05 ) ;
27805: LD_INT 175
27807: PPUSH
27808: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
27812: LD_EXP 12
27816: PUSH
27817: LD_EXP 3
27821: PUSH
27822: LD_INT 0
27824: PUSH
27825: LD_INT 2
27827: PUSH
27828: EMPTY
27829: LIST
27830: LIST
27831: IN
27832: OR
27833: IFFALSE 27856
// target := [ 68 , 108 , 1 ] else
27835: LD_ADDR_VAR 0 2
27839: PUSH
27840: LD_INT 68
27842: PUSH
27843: LD_INT 108
27845: PUSH
27846: LD_INT 1
27848: PUSH
27849: EMPTY
27850: LIST
27851: LIST
27852: LIST
27853: ST_TO_ADDR
27854: GO 27875
// target := [ 181 , 88 , 2 ] ;
27856: LD_ADDR_VAR 0 2
27860: PUSH
27861: LD_INT 181
27863: PUSH
27864: LD_INT 88
27866: PUSH
27867: LD_INT 2
27869: PUSH
27870: EMPTY
27871: LIST
27872: LIST
27873: LIST
27874: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
27875: LD_VAR 0 1
27879: PPUSH
27880: LD_VAR 0 2
27884: PUSH
27885: LD_INT 1
27887: ARRAY
27888: PPUSH
27889: LD_VAR 0 2
27893: PUSH
27894: LD_INT 2
27896: ARRAY
27897: PPUSH
27898: CALL_OW 176
// if target [ 3 ] = 1 then
27902: LD_VAR 0 2
27906: PUSH
27907: LD_INT 3
27909: ARRAY
27910: PUSH
27911: LD_INT 1
27913: EQUAL
27914: IFFALSE 27930
// SayRadio ( Kurt , D12-Kurt-1 ) else
27916: LD_EXP 63
27920: PPUSH
27921: LD_STRING D12-Kurt-1
27923: PPUSH
27924: CALL_OW 94
27928: GO 27954
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
27930: LD_EXP 63
27934: PPUSH
27935: LD_STRING D12a-Kurt-1
27937: PPUSH
27938: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
27942: LD_EXP 78
27946: PPUSH
27947: LD_STRING D12a-Roth-1
27949: PPUSH
27950: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
27954: LD_INT 350
27956: PPUSH
27957: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
27961: LD_VAR 0 1
27965: PPUSH
27966: LD_INT 22
27968: PUSH
27969: LD_INT 8
27971: PUSH
27972: EMPTY
27973: LIST
27974: LIST
27975: PUSH
27976: LD_INT 23
27978: PUSH
27979: LD_INT 2
27981: PUSH
27982: EMPTY
27983: LIST
27984: LIST
27985: PUSH
27986: LD_INT 30
27988: PUSH
27989: LD_INT 3
27991: PUSH
27992: EMPTY
27993: LIST
27994: LIST
27995: PUSH
27996: EMPTY
27997: LIST
27998: LIST
27999: LIST
28000: PPUSH
28001: CALL_OW 69
28005: PUSH
28006: LD_INT 1
28008: ARRAY
28009: PPUSH
28010: CALL_OW 228
// end ;
28014: PPOPN 2
28016: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
28017: LD_EXP 63
28021: PPUSH
28022: CALL_OW 256
28026: PUSH
28027: LD_INT 999
28029: LESS
28030: PUSH
28031: LD_INT 22
28033: PUSH
28034: LD_INT 8
28036: PUSH
28037: EMPTY
28038: LIST
28039: LIST
28040: PUSH
28041: LD_INT 21
28043: PUSH
28044: LD_INT 1
28046: PUSH
28047: EMPTY
28048: LIST
28049: LIST
28050: PUSH
28051: LD_INT 23
28053: PUSH
28054: LD_INT 2
28056: PUSH
28057: EMPTY
28058: LIST
28059: LIST
28060: PUSH
28061: EMPTY
28062: LIST
28063: LIST
28064: LIST
28065: PPUSH
28066: CALL_OW 69
28070: PUSH
28071: LD_INT 9
28073: PUSH
28074: LD_INT 8
28076: PUSH
28077: LD_INT 7
28079: PUSH
28080: LD_INT 6
28082: PUSH
28083: EMPTY
28084: LIST
28085: LIST
28086: LIST
28087: LIST
28088: PUSH
28089: LD_OWVAR 67
28093: ARRAY
28094: LESSEQUAL
28095: OR
28096: PUSH
28097: LD_INT 22
28099: PUSH
28100: LD_INT 8
28102: PUSH
28103: EMPTY
28104: LIST
28105: LIST
28106: PUSH
28107: LD_INT 34
28109: PUSH
28110: LD_INT 48
28112: PUSH
28113: EMPTY
28114: LIST
28115: LIST
28116: PUSH
28117: EMPTY
28118: LIST
28119: LIST
28120: PPUSH
28121: CALL_OW 69
28125: NOT
28126: AND
28127: PUSH
28128: LD_EXP 63
28132: PPUSH
28133: CALL_OW 302
28137: AND
28138: PUSH
28139: LD_INT 5
28141: PPUSH
28142: LD_INT 22
28144: PUSH
28145: LD_INT 1
28147: PUSH
28148: EMPTY
28149: LIST
28150: LIST
28151: PPUSH
28152: CALL_OW 70
28156: AND
28157: IFFALSE 28919
28159: GO 28161
28161: DISABLE
28162: LD_INT 0
28164: PPUSH
28165: PPUSH
28166: PPUSH
// begin legionDestroyed := true ;
28167: LD_ADDR_EXP 22
28171: PUSH
28172: LD_INT 1
28174: ST_TO_ADDR
// DialogueOn ;
28175: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
28179: LD_EXP 40
28183: PPUSH
28184: LD_STRING D13-JMM-1
28186: PPUSH
28187: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
28191: LD_EXP 63
28195: PPUSH
28196: LD_STRING D13-Kurt-1
28198: PPUSH
28199: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
28203: LD_EXP 40
28207: PPUSH
28208: LD_STRING D13-JMM-2
28210: PPUSH
28211: CALL_OW 88
// if FakeInfo then
28215: LD_EXP 12
28219: IFFALSE 28239
// begin Say ( Kurt , D13-Kurt-2 ) ;
28221: LD_EXP 63
28225: PPUSH
28226: LD_STRING D13-Kurt-2
28228: PPUSH
28229: CALL_OW 88
// DialogueOff ;
28233: CALL_OW 7
// exit ;
28237: GO 28919
// end ; if not KurtStatus then
28239: LD_EXP 3
28243: NOT
28244: IFFALSE 28260
// Say ( Kurt , D13-Kurt-2b ) else
28246: LD_EXP 63
28250: PPUSH
28251: LD_STRING D13-Kurt-2b
28253: PPUSH
28254: CALL_OW 88
28258: GO 28272
// Say ( Kurt , D13-Kurt-2a ) ;
28260: LD_EXP 63
28264: PPUSH
28265: LD_STRING D13-Kurt-2a
28267: PPUSH
28268: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
28272: LD_EXP 40
28276: PPUSH
28277: LD_STRING D13-JMM-3
28279: PPUSH
28280: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
28284: LD_EXP 63
28288: PPUSH
28289: LD_STRING D13-Kurt-3
28291: PPUSH
28292: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
28296: LD_EXP 40
28300: PPUSH
28301: LD_STRING D13-JMM-4
28303: PPUSH
28304: CALL_OW 88
// DialogueOff ;
28308: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
28312: LD_STRING MlegionOut
28314: PPUSH
28315: CALL_OW 337
// MC_Kill ( 3 ) ;
28319: LD_INT 3
28321: PPUSH
28322: CALL 38993 0 1
// KillUnit ( Kozlov ) ;
28326: LD_EXP 64
28330: PPUSH
28331: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
28335: LD_ADDR_VAR 0 1
28339: PUSH
28340: LD_INT 22
28342: PUSH
28343: LD_INT 8
28345: PUSH
28346: EMPTY
28347: LIST
28348: LIST
28349: PUSH
28350: LD_INT 23
28352: PUSH
28353: LD_INT 3
28355: PUSH
28356: EMPTY
28357: LIST
28358: LIST
28359: PUSH
28360: LD_INT 3
28362: PUSH
28363: LD_INT 21
28365: PUSH
28366: LD_INT 33
28368: PUSH
28369: EMPTY
28370: LIST
28371: LIST
28372: PUSH
28373: EMPTY
28374: LIST
28375: LIST
28376: PUSH
28377: EMPTY
28378: LIST
28379: LIST
28380: LIST
28381: PPUSH
28382: CALL_OW 69
28386: PUSH
28387: FOR_IN
28388: IFFALSE 28401
// KillUnit ( i ) ;
28390: LD_VAR 0 1
28394: PPUSH
28395: CALL_OW 66
28399: GO 28387
28401: POP
28402: POP
// ChangeSideFog ( 8 , 1 ) ;
28403: LD_INT 8
28405: PPUSH
28406: LD_INT 1
28408: PPUSH
28409: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
28413: LD_ADDR_VAR 0 2
28417: PUSH
28418: LD_INT 22
28420: PUSH
28421: LD_INT 8
28423: PUSH
28424: EMPTY
28425: LIST
28426: LIST
28427: PUSH
28428: LD_INT 21
28430: PUSH
28431: LD_INT 1
28433: PUSH
28434: EMPTY
28435: LIST
28436: LIST
28437: PUSH
28438: EMPTY
28439: LIST
28440: LIST
28441: PPUSH
28442: CALL_OW 69
28446: PUSH
28447: LD_EXP 64
28451: PUSH
28452: LD_EXP 63
28456: PUSH
28457: EMPTY
28458: LIST
28459: LIST
28460: DIFF
28461: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
28462: LD_VAR 0 2
28466: PUSH
28467: LD_INT 6
28469: PUSH
28470: LD_INT 5
28472: PUSH
28473: LD_INT 4
28475: PUSH
28476: LD_INT 3
28478: PUSH
28479: EMPTY
28480: LIST
28481: LIST
28482: LIST
28483: LIST
28484: PUSH
28485: LD_OWVAR 67
28489: ARRAY
28490: GREATEREQUAL
28491: IFFALSE 28643
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
28493: LD_ADDR_VAR 0 3
28497: PUSH
28498: LD_INT 6
28500: PUSH
28501: LD_INT 5
28503: PUSH
28504: LD_INT 4
28506: PUSH
28507: LD_INT 3
28509: PUSH
28510: EMPTY
28511: LIST
28512: LIST
28513: LIST
28514: LIST
28515: PUSH
28516: LD_OWVAR 67
28520: ARRAY
28521: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
28522: LD_ADDR_VAR 0 1
28526: PUSH
28527: DOUBLE
28528: LD_VAR 0 2
28532: PUSH
28533: LD_VAR 0 3
28537: PUSH
28538: LD_INT 1
28540: PLUS
28541: MINUS
28542: INC
28543: ST_TO_ADDR
28544: LD_INT 1
28546: PUSH
28547: FOR_DOWNTO
28548: IFFALSE 28639
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
28550: LD_ADDR_EXP 38
28554: PUSH
28555: LD_EXP 38
28559: PUSH
28560: LD_VAR 0 2
28564: PUSH
28565: LD_VAR 0 1
28569: ARRAY
28570: ADD
28571: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
28572: LD_VAR 0 2
28576: PUSH
28577: LD_VAR 0 1
28581: ARRAY
28582: PPUSH
28583: CALL_OW 310
28587: IFFALSE 28604
// ComExit ( tmp [ i ] ) ;
28589: LD_VAR 0 2
28593: PUSH
28594: LD_VAR 0 1
28598: ARRAY
28599: PPUSH
28600: CALL 107533 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
28604: LD_VAR 0 2
28608: PUSH
28609: LD_VAR 0 1
28613: ARRAY
28614: PPUSH
28615: LD_INT 34
28617: PUSH
28618: LD_INT 0
28620: PPUSH
28621: LD_INT 6
28623: PPUSH
28624: CALL_OW 12
28628: PLUS
28629: PPUSH
28630: LD_INT 1
28632: PPUSH
28633: CALL_OW 171
// end ;
28637: GO 28547
28639: POP
28640: POP
// end else
28641: GO 28653
// x := tmp ;
28643: LD_ADDR_VAR 0 3
28647: PUSH
28648: LD_VAR 0 2
28652: ST_TO_ADDR
// for i := tmp downto tmp - x do
28653: LD_ADDR_VAR 0 1
28657: PUSH
28658: DOUBLE
28659: LD_VAR 0 2
28663: INC
28664: ST_TO_ADDR
28665: LD_VAR 0 2
28669: PUSH
28670: LD_VAR 0 3
28674: MINUS
28675: PUSH
28676: FOR_DOWNTO
28677: IFFALSE 28749
// begin if IsInUnit ( tmp [ i ] ) then
28679: LD_VAR 0 2
28683: PUSH
28684: LD_VAR 0 1
28688: ARRAY
28689: PPUSH
28690: CALL_OW 310
28694: IFFALSE 28711
// ComExit ( tmp [ i ] ) ;
28696: LD_VAR 0 2
28700: PUSH
28701: LD_VAR 0 1
28705: ARRAY
28706: PPUSH
28707: CALL 107533 0 1
// SetSide ( tmp [ i ] , 1 ) ;
28711: LD_VAR 0 2
28715: PUSH
28716: LD_VAR 0 1
28720: ARRAY
28721: PPUSH
28722: LD_INT 1
28724: PPUSH
28725: CALL_OW 235
// SetLives ( tmp [ i ] , 1000 ) ;
28729: LD_VAR 0 2
28733: PUSH
28734: LD_VAR 0 1
28738: ARRAY
28739: PPUSH
28740: LD_INT 1000
28742: PPUSH
28743: CALL_OW 234
// end ;
28747: GO 28676
28749: POP
28750: POP
// wait ( 0 0$0.3 ) ;
28751: LD_INT 10
28753: PPUSH
28754: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
28758: LD_ADDR_VAR 0 1
28762: PUSH
28763: LD_INT 22
28765: PUSH
28766: LD_INT 8
28768: PUSH
28769: EMPTY
28770: LIST
28771: LIST
28772: PUSH
28773: LD_INT 21
28775: PUSH
28776: LD_INT 2
28778: PUSH
28779: EMPTY
28780: LIST
28781: LIST
28782: PUSH
28783: EMPTY
28784: LIST
28785: LIST
28786: PPUSH
28787: CALL_OW 69
28791: PUSH
28792: FOR_IN
28793: IFFALSE 28806
// KillUnit ( i ) ;
28795: LD_VAR 0 1
28799: PPUSH
28800: CALL_OW 66
28804: GO 28792
28806: POP
28807: POP
// SetSide ( Kurt , 1 ) ;
28808: LD_EXP 63
28812: PPUSH
28813: LD_INT 1
28815: PPUSH
28816: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
28820: LD_INT 22
28822: PUSH
28823: LD_INT 8
28825: PUSH
28826: EMPTY
28827: LIST
28828: LIST
28829: PUSH
28830: LD_INT 21
28832: PUSH
28833: LD_INT 3
28835: PUSH
28836: EMPTY
28837: LIST
28838: LIST
28839: PUSH
28840: EMPTY
28841: LIST
28842: LIST
28843: PPUSH
28844: CALL_OW 69
28848: PPUSH
28849: LD_INT 1
28851: PPUSH
28852: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
28856: LD_INT 8
28858: PPUSH
28859: LD_INT 1
28861: PPUSH
28862: LD_INT 1
28864: PPUSH
28865: LD_INT 1
28867: PPUSH
28868: CALL_OW 80
// wait ( 1 1$20 ) ;
28872: LD_INT 2800
28874: PPUSH
28875: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
28879: LD_EXP 65
28883: PPUSH
28884: LD_INT 37
28886: PPUSH
28887: LD_INT 1
28889: PPUSH
28890: LD_INT 0
28892: PPUSH
28893: CALL_OW 48
// wait ( 0 0$1 ) ;
28897: LD_INT 35
28899: PPUSH
28900: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
28904: LD_EXP 65
28908: PPUSH
28909: LD_INT 60
28911: PPUSH
28912: LD_INT 95
28914: PPUSH
28915: CALL_OW 111
// end ;
28919: PPOPN 3
28921: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
28922: LD_EXP 22
28926: NOT
28927: PUSH
28928: LD_INT 22
28930: PUSH
28931: LD_INT 8
28933: PUSH
28934: EMPTY
28935: LIST
28936: LIST
28937: PUSH
28938: LD_INT 21
28940: PUSH
28941: LD_INT 1
28943: PUSH
28944: EMPTY
28945: LIST
28946: LIST
28947: PUSH
28948: EMPTY
28949: LIST
28950: LIST
28951: PPUSH
28952: CALL_OW 69
28956: PUSH
28957: LD_INT 0
28959: EQUAL
28960: AND
28961: IFFALSE 28981
28963: GO 28965
28965: DISABLE
// begin legionDestroyed := true ;
28966: LD_ADDR_EXP 22
28970: PUSH
28971: LD_INT 1
28973: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
28974: LD_STRING MlegionOut
28976: PPUSH
28977: CALL_OW 337
// end ;
28981: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
28982: LD_EXP 38
28986: IFFALSE 29061
28988: GO 28990
28990: DISABLE
28991: LD_INT 0
28993: PPUSH
// begin enable ;
28994: ENABLE
// for i in legionEscapeUnits do
28995: LD_ADDR_VAR 0 1
28999: PUSH
29000: LD_EXP 38
29004: PUSH
29005: FOR_IN
29006: IFFALSE 29059
// begin if IsInArea ( i , legionEscapeArea ) then
29008: LD_VAR 0 1
29012: PPUSH
29013: LD_INT 31
29015: PPUSH
29016: CALL_OW 308
29020: IFFALSE 29033
// RemoveUnit ( i ) else
29022: LD_VAR 0 1
29026: PPUSH
29027: CALL_OW 64
29031: GO 29057
// if not HasTask ( i ) then
29033: LD_VAR 0 1
29037: PPUSH
29038: CALL_OW 314
29042: NOT
29043: IFFALSE 29057
// ComMoveToArea ( i , legionEscapeArea ) ;
29045: LD_VAR 0 1
29049: PPUSH
29050: LD_INT 31
29052: PPUSH
29053: CALL_OW 113
// end ;
29057: GO 29005
29059: POP
29060: POP
// end ;
29061: PPOPN 1
29063: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
29064: LD_INT 1
29066: PPUSH
29067: LD_EXP 65
29071: PPUSH
29072: CALL_OW 292
29076: IFFALSE 29374
29078: GO 29080
29080: DISABLE
29081: LD_INT 0
29083: PPUSH
// begin wait ( 0 0$2 ) ;
29084: LD_INT 70
29086: PPUSH
29087: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
29091: LD_EXP 65
29095: PPUSH
29096: CALL_OW 87
// DialogueOn ;
29100: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
29104: LD_EXP 40
29108: PPUSH
29109: LD_STRING D14-JMM-1
29111: PPUSH
29112: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
29116: LD_EXP 65
29120: PPUSH
29121: LD_STRING D14-Friend-1
29123: PPUSH
29124: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
29128: LD_EXP 40
29132: PPUSH
29133: LD_STRING D14-JMM-2
29135: PPUSH
29136: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
29140: LD_EXP 65
29144: PPUSH
29145: LD_STRING D14-Friend-2
29147: PPUSH
29148: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
29152: LD_EXP 40
29156: PPUSH
29157: LD_STRING D14-JMM-3
29159: PPUSH
29160: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
29164: LD_EXP 65
29168: PPUSH
29169: LD_STRING D14-Friend-3
29171: PPUSH
29172: CALL_OW 88
// DialogueOff ;
29176: CALL_OW 7
// dec := Query ( Q14 ) ;
29180: LD_ADDR_VAR 0 1
29184: PUSH
29185: LD_STRING Q14
29187: PPUSH
29188: CALL_OW 97
29192: ST_TO_ADDR
// if dec = 1 then
29193: LD_VAR 0 1
29197: PUSH
29198: LD_INT 1
29200: EQUAL
29201: IFFALSE 29235
// begin DialogueOn ;
29203: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
29207: LD_EXP 40
29211: PPUSH
29212: LD_STRING D14a-JMM-1
29214: PPUSH
29215: CALL_OW 88
// DialogueOff ;
29219: CALL_OW 7
// SetSide ( Friend , 1 ) ;
29223: LD_EXP 65
29227: PPUSH
29228: LD_INT 1
29230: PPUSH
29231: CALL_OW 235
// end ; if dec = 2 then
29235: LD_VAR 0 1
29239: PUSH
29240: LD_INT 2
29242: EQUAL
29243: IFFALSE 29296
// begin DialogueOn ;
29245: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
29249: LD_EXP 40
29253: PPUSH
29254: LD_STRING D14b-JMM-1
29256: PPUSH
29257: CALL_OW 88
// DialogueOff ;
29261: CALL_OW 7
// wait ( 0 0$1 ) ;
29265: LD_INT 35
29267: PPUSH
29268: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
29272: LD_EXP 65
29276: PPUSH
29277: LD_INT 9
29279: PPUSH
29280: LD_INT 2
29282: PPUSH
29283: CALL_OW 111
// AddComHold ( Friend ) ;
29287: LD_EXP 65
29291: PPUSH
29292: CALL_OW 200
// end ; if dec = 3 then
29296: LD_VAR 0 1
29300: PUSH
29301: LD_INT 3
29303: EQUAL
29304: IFFALSE 29374
// begin DialogueOn ;
29306: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
29310: LD_EXP 40
29314: PPUSH
29315: LD_STRING D14c-JMM-1
29317: PPUSH
29318: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
29322: LD_EXP 65
29326: PPUSH
29327: LD_STRING D14c-Friend-1
29329: PPUSH
29330: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
29334: LD_EXP 40
29338: PPUSH
29339: LD_STRING D14c-JMM-2
29341: PPUSH
29342: CALL_OW 88
// DialogueOff ;
29346: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
29350: LD_EXP 65
29354: PPUSH
29355: LD_INT 9
29357: PPUSH
29358: LD_INT 2
29360: PPUSH
29361: CALL_OW 111
// AddComHold ( Friend ) ;
29365: LD_EXP 65
29369: PPUSH
29370: CALL_OW 200
// end ; end ;
29374: PPOPN 1
29376: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
29377: LD_INT 9
29379: PPUSH
29380: LD_INT 2
29382: PPUSH
29383: CALL_OW 428
29387: PUSH
29388: LD_EXP 65
29392: EQUAL
29393: PUSH
29394: LD_EXP 65
29398: PPUSH
29399: CALL_OW 255
29403: PUSH
29404: LD_INT 8
29406: EQUAL
29407: AND
29408: IFFALSE 29422
29410: GO 29412
29412: DISABLE
// RemoveUnit ( Friend ) ;
29413: LD_EXP 65
29417: PPUSH
29418: CALL_OW 64
29422: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
29423: LD_EXP 14
29427: PUSH
29428: LD_INT 31500
29430: GREATEREQUAL
29431: PUSH
29432: LD_EXP 7
29436: AND
29437: PUSH
29438: LD_EXP 2
29442: AND
29443: IFFALSE 29889
29445: GO 29447
29447: DISABLE
29448: LD_INT 0
29450: PPUSH
29451: PPUSH
29452: PPUSH
// begin missionStage := 7 ;
29453: LD_ADDR_EXP 15
29457: PUSH
29458: LD_INT 7
29460: ST_TO_ADDR
// for i := 1 to 5 do
29461: LD_ADDR_VAR 0 1
29465: PUSH
29466: DOUBLE
29467: LD_INT 1
29469: DEC
29470: ST_TO_ADDR
29471: LD_INT 5
29473: PUSH
29474: FOR_TO
29475: IFFALSE 29587
// begin uc_side = 1 ;
29477: LD_ADDR_OWVAR 20
29481: PUSH
29482: LD_INT 1
29484: ST_TO_ADDR
// uc_nation = 1 ;
29485: LD_ADDR_OWVAR 21
29489: PUSH
29490: LD_INT 1
29492: ST_TO_ADDR
// vc_engine = 3 ;
29493: LD_ADDR_OWVAR 39
29497: PUSH
29498: LD_INT 3
29500: ST_TO_ADDR
// vc_control = 3 ;
29501: LD_ADDR_OWVAR 38
29505: PUSH
29506: LD_INT 3
29508: ST_TO_ADDR
// vc_chassis = 3 ;
29509: LD_ADDR_OWVAR 37
29513: PUSH
29514: LD_INT 3
29516: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
29517: LD_ADDR_OWVAR 40
29521: PUSH
29522: LD_INT 5
29524: PUSH
29525: LD_INT 9
29527: PUSH
29528: LD_INT 7
29530: PUSH
29531: EMPTY
29532: LIST
29533: LIST
29534: LIST
29535: PUSH
29536: LD_INT 1
29538: PPUSH
29539: LD_INT 3
29541: PPUSH
29542: CALL_OW 12
29546: ARRAY
29547: ST_TO_ADDR
// veh = CreateVehicle ;
29548: LD_ADDR_VAR 0 2
29552: PUSH
29553: CALL_OW 45
29557: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
29558: LD_VAR 0 2
29562: PPUSH
29563: LD_INT 1
29565: PPUSH
29566: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
29570: LD_VAR 0 2
29574: PPUSH
29575: LD_INT 19
29577: PPUSH
29578: LD_INT 0
29580: PPUSH
29581: CALL_OW 49
// end ;
29585: GO 29474
29587: POP
29588: POP
// uc_side = 1 ;
29589: LD_ADDR_OWVAR 20
29593: PUSH
29594: LD_INT 1
29596: ST_TO_ADDR
// uc_nation = 1 ;
29597: LD_ADDR_OWVAR 21
29601: PUSH
29602: LD_INT 1
29604: ST_TO_ADDR
// vc_engine = 3 ;
29605: LD_ADDR_OWVAR 39
29609: PUSH
29610: LD_INT 3
29612: ST_TO_ADDR
// vc_control = 1 ;
29613: LD_ADDR_OWVAR 38
29617: PUSH
29618: LD_INT 1
29620: ST_TO_ADDR
// vc_chassis = 3 ;
29621: LD_ADDR_OWVAR 37
29625: PUSH
29626: LD_INT 3
29628: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
29629: LD_ADDR_OWVAR 40
29633: PUSH
29634: LD_INT 5
29636: PUSH
29637: LD_INT 9
29639: PUSH
29640: LD_INT 7
29642: PUSH
29643: EMPTY
29644: LIST
29645: LIST
29646: LIST
29647: PUSH
29648: LD_INT 1
29650: PPUSH
29651: LD_INT 3
29653: PPUSH
29654: CALL_OW 12
29658: ARRAY
29659: ST_TO_ADDR
// vehG = CreateVehicle ;
29660: LD_ADDR_VAR 0 3
29664: PUSH
29665: CALL_OW 45
29669: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
29670: LD_VAR 0 3
29674: PPUSH
29675: LD_INT 1
29677: PPUSH
29678: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
29682: LD_VAR 0 3
29686: PPUSH
29687: LD_INT 19
29689: PPUSH
29690: LD_INT 0
29692: PPUSH
29693: CALL_OW 49
// if JMMGirl = 1 then
29697: LD_EXP 7
29701: PUSH
29702: LD_INT 1
29704: EQUAL
29705: IFFALSE 29761
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
29707: LD_ADDR_EXP 41
29711: PUSH
29712: LD_STRING Joan
29714: PPUSH
29715: LD_INT 1
29717: PPUSH
29718: LD_STRING 14_
29720: PPUSH
29721: CALL 69444 0 3
29725: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
29726: LD_EXP 41
29730: PPUSH
29731: LD_VAR 0 3
29735: PPUSH
29736: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29740: LD_VAR 0 3
29744: PPUSH
29745: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
29749: LD_EXP 41
29753: PPUSH
29754: LD_STRING D10BW-Joan-1
29756: PPUSH
29757: CALL_OW 94
// end ; if JMMGirl = 2 then
29761: LD_EXP 7
29765: PUSH
29766: LD_INT 2
29768: EQUAL
29769: IFFALSE 29825
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
29771: LD_ADDR_EXP 43
29775: PUSH
29776: LD_STRING Lisa
29778: PPUSH
29779: LD_INT 1
29781: PPUSH
29782: LD_STRING 14_
29784: PPUSH
29785: CALL 69444 0 3
29789: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
29790: LD_EXP 43
29794: PPUSH
29795: LD_VAR 0 3
29799: PPUSH
29800: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29804: LD_VAR 0 3
29808: PPUSH
29809: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
29813: LD_EXP 43
29817: PPUSH
29818: LD_STRING D10BW-Lisa-1
29820: PPUSH
29821: CALL_OW 94
// end ; if JMMGirl = 3 then
29825: LD_EXP 7
29829: PUSH
29830: LD_INT 3
29832: EQUAL
29833: IFFALSE 29889
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
29835: LD_ADDR_EXP 55
29839: PUSH
29840: LD_STRING Connie
29842: PPUSH
29843: LD_INT 1
29845: PPUSH
29846: LD_STRING 14_
29848: PPUSH
29849: CALL 69444 0 3
29853: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
29854: LD_EXP 55
29858: PPUSH
29859: LD_VAR 0 3
29863: PPUSH
29864: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29868: LD_VAR 0 3
29872: PPUSH
29873: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
29877: LD_EXP 55
29881: PPUSH
29882: LD_STRING D10BW-Con-1
29884: PPUSH
29885: CALL_OW 94
// end ; end ;
29889: PPOPN 3
29891: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
29892: LD_EXP 14
29896: PUSH
29897: LD_INT 94500
29899: GREATEREQUAL
29900: IFFALSE 30312
29902: GO 29904
29904: DISABLE
29905: LD_INT 0
29907: PPUSH
29908: PPUSH
29909: PPUSH
// begin tmp := PrepareStevensSquad ;
29910: LD_ADDR_VAR 0 3
29914: PUSH
29915: CALL 2323 0 0
29919: ST_TO_ADDR
// if not tmp then
29920: LD_VAR 0 3
29924: NOT
29925: IFFALSE 29929
// exit ;
29927: GO 30312
// uc_side := 1 ;
29929: LD_ADDR_OWVAR 20
29933: PUSH
29934: LD_INT 1
29936: ST_TO_ADDR
// uc_nation := 1 ;
29937: LD_ADDR_OWVAR 21
29941: PUSH
29942: LD_INT 1
29944: ST_TO_ADDR
// for i in tmp do
29945: LD_ADDR_VAR 0 1
29949: PUSH
29950: LD_VAR 0 3
29954: PUSH
29955: FOR_IN
29956: IFFALSE 30053
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
29958: LD_INT 3
29960: PPUSH
29961: LD_INT 3
29963: PPUSH
29964: LD_INT 1
29966: PPUSH
29967: LD_INT 5
29969: PUSH
29970: LD_INT 9
29972: PUSH
29973: LD_INT 7
29975: PUSH
29976: EMPTY
29977: LIST
29978: LIST
29979: LIST
29980: PUSH
29981: LD_INT 1
29983: PPUSH
29984: LD_INT 3
29986: PPUSH
29987: CALL_OW 12
29991: ARRAY
29992: PPUSH
29993: LD_INT 40
29995: PPUSH
29996: CALL 74284 0 5
// veh := CreateVehicle ;
30000: LD_ADDR_VAR 0 2
30004: PUSH
30005: CALL_OW 45
30009: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
30010: LD_VAR 0 2
30014: PPUSH
30015: LD_INT 1
30017: PPUSH
30018: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
30022: LD_VAR 0 2
30026: PPUSH
30027: LD_INT 19
30029: PPUSH
30030: LD_INT 0
30032: PPUSH
30033: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
30037: LD_VAR 0 1
30041: PPUSH
30042: LD_VAR 0 2
30046: PPUSH
30047: CALL_OW 52
// end ;
30051: GO 29955
30053: POP
30054: POP
// missionStage := 8 ;
30055: LD_ADDR_EXP 15
30059: PUSH
30060: LD_INT 8
30062: ST_TO_ADDR
// DialogueOn ;
30063: CALL_OW 6
// if Stevens then
30067: LD_EXP 42
30071: IFFALSE 30185
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
30073: LD_EXP 42
30077: PPUSH
30078: CALL_OW 310
30082: PPUSH
30083: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
30087: LD_EXP 42
30091: PPUSH
30092: LD_STRING D8-Huck-1
30094: PPUSH
30095: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
30099: LD_EXP 40
30103: PPUSH
30104: LD_STRING D8-JMM-1
30106: PPUSH
30107: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
30111: LD_EXP 42
30115: PPUSH
30116: LD_STRING D8-Huck-2
30118: PPUSH
30119: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
30123: LD_EXP 40
30127: PPUSH
30128: LD_STRING D8-JMM-2
30130: PPUSH
30131: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
30135: LD_EXP 42
30139: PPUSH
30140: LD_STRING D8-Huck-3
30142: PPUSH
30143: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
30147: LD_EXP 40
30151: PPUSH
30152: LD_STRING D8-JMM-3
30154: PPUSH
30155: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
30159: LD_EXP 42
30163: PPUSH
30164: LD_STRING D8-Huck-4
30166: PPUSH
30167: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
30171: LD_EXP 40
30175: PPUSH
30176: LD_STRING D8-JMM-4
30178: PPUSH
30179: CALL_OW 88
// end else
30183: GO 30295
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
30185: LD_EXP 56
30189: PPUSH
30190: CALL_OW 310
30194: PPUSH
30195: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
30199: LD_EXP 56
30203: PPUSH
30204: LD_STRING D8-Huck-1
30206: PPUSH
30207: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
30211: LD_EXP 40
30215: PPUSH
30216: LD_STRING D8-JMM-1a
30218: PPUSH
30219: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
30223: LD_EXP 56
30227: PPUSH
30228: LD_STRING D8-Huck-2
30230: PPUSH
30231: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
30235: LD_EXP 40
30239: PPUSH
30240: LD_STRING D8-JMM-2
30242: PPUSH
30243: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
30247: LD_EXP 56
30251: PPUSH
30252: LD_STRING D8-Huck-3
30254: PPUSH
30255: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
30259: LD_EXP 40
30263: PPUSH
30264: LD_STRING D8-JMM-3
30266: PPUSH
30267: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
30271: LD_EXP 56
30275: PPUSH
30276: LD_STRING D8-Huck-4
30278: PPUSH
30279: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
30283: LD_EXP 40
30287: PPUSH
30288: LD_STRING D8-JMM-4
30290: PPUSH
30291: CALL_OW 88
// end ; DialogueOff ;
30295: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
30299: LD_INT 25
30301: PPUSH
30302: LD_INT 1
30304: PPUSH
30305: LD_INT 1
30307: PPUSH
30308: CALL_OW 322
// end ;
30312: PPOPN 3
30314: END
// every 0 0$1 trigger IsOk ( sewiVeh ) and See ( 1 , sewiVeh ) do
30315: LD_EXP 74
30319: PPUSH
30320: CALL_OW 302
30324: PUSH
30325: LD_INT 1
30327: PPUSH
30328: LD_EXP 74
30332: PPUSH
30333: CALL_OW 292
30337: AND
30338: IFFALSE 30589
30340: GO 30342
30342: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
30343: LD_EXP 74
30347: PPUSH
30348: CALL_OW 87
// DialogueOn ;
30352: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
30356: LD_EXP 40
30360: PPUSH
30361: LD_STRING D10nB-JMM-1
30363: PPUSH
30364: CALL_OW 88
// if BurlakStatus = 1 then
30368: LD_EXP 9
30372: PUSH
30373: LD_INT 1
30375: EQUAL
30376: IFFALSE 30390
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
30378: LD_EXP 73
30382: PPUSH
30383: LD_STRING D10nB-Vse-1a
30385: PPUSH
30386: CALL_OW 94
// end ; if BurlakStatus = 0 then
30390: LD_EXP 9
30394: PUSH
30395: LD_INT 0
30397: EQUAL
30398: IFFALSE 30412
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
30400: LD_EXP 73
30404: PPUSH
30405: LD_STRING D10nB-Vse-1
30407: PPUSH
30408: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
30412: LD_EXP 40
30416: PPUSH
30417: LD_STRING D10nB-JMM-2
30419: PPUSH
30420: CALL_OW 88
// if KappaStatus then
30424: LD_EXP 2
30428: IFFALSE 30442
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
30430: LD_EXP 73
30434: PPUSH
30435: LD_STRING D10nB-Vse-5a
30437: PPUSH
30438: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
30442: LD_EXP 2
30446: NOT
30447: PUSH
30448: LD_EXP 6
30452: PUSH
30453: LD_INT 0
30455: EQUAL
30456: AND
30457: IFFALSE 30585
// begin if JMMGirl = 1 then
30459: LD_EXP 7
30463: PUSH
30464: LD_INT 1
30466: EQUAL
30467: IFFALSE 30517
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
30469: LD_EXP 73
30473: PPUSH
30474: LD_STRING D10nB-Vse-2
30476: PPUSH
30477: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
30481: LD_EXP 40
30485: PPUSH
30486: LD_STRING D10nB-JMM-3
30488: PPUSH
30489: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
30493: LD_EXP 73
30497: PPUSH
30498: LD_STRING D10nB-Vse-3
30500: PPUSH
30501: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
30505: LD_EXP 40
30509: PPUSH
30510: LD_STRING D10nB-JMM-4
30512: PPUSH
30513: CALL_OW 88
// end ; if JMMGirl = 2 then
30517: LD_EXP 7
30521: PUSH
30522: LD_INT 2
30524: EQUAL
30525: IFFALSE 30551
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
30527: LD_EXP 73
30531: PPUSH
30532: LD_STRING D10nB-Vse-4
30534: PPUSH
30535: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
30539: LD_EXP 40
30543: PPUSH
30544: LD_STRING D10nB-JMM-5
30546: PPUSH
30547: CALL_OW 88
// end ; if JMMGirl = 3 then
30551: LD_EXP 7
30555: PUSH
30556: LD_INT 3
30558: EQUAL
30559: IFFALSE 30585
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
30561: LD_EXP 73
30565: PPUSH
30566: LD_STRING D10nB-Vse-5
30568: PPUSH
30569: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
30573: LD_EXP 40
30577: PPUSH
30578: LD_STRING D10nB-JMM-6
30580: PPUSH
30581: CALL_OW 88
// end ; end ; DialogueOff ;
30585: CALL_OW 7
// end ;
30589: END
// every 0 0$1 trigger missionTime >= 55 55$00 and IsOk ( Kovalyuk ) and IsOk ( ru_depot2 ) do var tmp ;
30590: LD_EXP 14
30594: PUSH
30595: LD_INT 115500
30597: GREATEREQUAL
30598: PUSH
30599: LD_EXP 68
30603: PPUSH
30604: CALL_OW 302
30608: AND
30609: PUSH
30610: LD_INT 267
30612: PPUSH
30613: CALL_OW 302
30617: AND
30618: IFFALSE 30994
30620: GO 30622
30622: DISABLE
30623: LD_INT 0
30625: PPUSH
// begin missionStage := 10 ;
30626: LD_ADDR_EXP 15
30630: PUSH
30631: LD_INT 10
30633: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
30634: LD_ADDR_VAR 0 1
30638: PUSH
30639: LD_INT 22
30641: PUSH
30642: LD_INT 1
30644: PUSH
30645: EMPTY
30646: LIST
30647: LIST
30648: PUSH
30649: LD_INT 23
30651: PUSH
30652: LD_INT 1
30654: PUSH
30655: EMPTY
30656: LIST
30657: LIST
30658: PUSH
30659: LD_INT 26
30661: PUSH
30662: LD_INT 1
30664: PUSH
30665: EMPTY
30666: LIST
30667: LIST
30668: PUSH
30669: LD_INT 3
30671: PUSH
30672: LD_INT 25
30674: PUSH
30675: LD_INT 12
30677: PUSH
30678: EMPTY
30679: LIST
30680: LIST
30681: PUSH
30682: EMPTY
30683: LIST
30684: LIST
30685: PUSH
30686: LD_INT 3
30688: PUSH
30689: LD_INT 25
30691: PUSH
30692: LD_INT 16
30694: PUSH
30695: EMPTY
30696: LIST
30697: LIST
30698: PUSH
30699: EMPTY
30700: LIST
30701: LIST
30702: PUSH
30703: EMPTY
30704: LIST
30705: LIST
30706: LIST
30707: LIST
30708: LIST
30709: PPUSH
30710: CALL_OW 69
30714: PUSH
30715: LD_EXP 40
30719: PUSH
30720: LD_EXP 63
30724: PUSH
30725: LD_EXP 42
30729: PUSH
30730: LD_EXP 56
30734: PUSH
30735: LD_EXP 43
30739: PUSH
30740: LD_EXP 44
30744: PUSH
30745: LD_EXP 45
30749: PUSH
30750: LD_EXP 46
30754: PUSH
30755: LD_EXP 47
30759: PUSH
30760: LD_EXP 48
30764: PUSH
30765: LD_EXP 49
30769: PUSH
30770: LD_EXP 50
30774: PUSH
30775: LD_EXP 51
30779: PUSH
30780: LD_EXP 52
30784: PUSH
30785: LD_EXP 53
30789: PUSH
30790: LD_EXP 54
30794: PUSH
30795: EMPTY
30796: LIST
30797: LIST
30798: LIST
30799: LIST
30800: LIST
30801: LIST
30802: LIST
30803: LIST
30804: LIST
30805: LIST
30806: LIST
30807: LIST
30808: LIST
30809: LIST
30810: LIST
30811: LIST
30812: DIFF
30813: ST_TO_ADDR
// if not tmp and Brown then
30814: LD_VAR 0 1
30818: NOT
30819: PUSH
30820: LD_EXP 48
30824: AND
30825: IFFALSE 30840
// tmp := [ Brown ] ;
30827: LD_ADDR_VAR 0 1
30831: PUSH
30832: LD_EXP 48
30836: PUSH
30837: EMPTY
30838: LIST
30839: ST_TO_ADDR
// DialogueOn ;
30840: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
30844: LD_VAR 0 1
30848: PUSH
30849: LD_INT 1
30851: ARRAY
30852: PPUSH
30853: LD_STRING D11-Sol1-1
30855: PPUSH
30856: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
30860: LD_EXP 67
30864: PPUSH
30865: LD_STRING D11-Pla-1
30867: PPUSH
30868: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
30872: LD_EXP 68
30876: PPUSH
30877: LD_STRING D11-Kov-1
30879: PPUSH
30880: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
30884: LD_EXP 67
30888: PPUSH
30889: LD_STRING D11-Pla-2
30891: PPUSH
30892: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
30896: LD_VAR 0 1
30900: PUSH
30901: LD_INT 1
30903: ARRAY
30904: PPUSH
30905: LD_STRING D11-Sol1-2
30907: PPUSH
30908: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
30912: LD_EXP 40
30916: PPUSH
30917: LD_STRING D11-JMM-2
30919: PPUSH
30920: CALL_OW 88
// DialogueOff ;
30924: CALL_OW 7
// allowBehemothConstruct := true ;
30928: LD_ADDR_EXP 25
30932: PUSH
30933: LD_INT 1
30935: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
30936: LD_STRING M4
30938: PPUSH
30939: CALL_OW 337
// BuildBehemoths ;
30943: CALL 8255 0 0
// repeat wait ( 15 15$00 ) ;
30947: LD_INT 31500
30949: PPUSH
30950: CALL_OW 67
// if behemothDestroyedBeforeFinish then
30954: LD_EXP 27
30958: IFFALSE 30962
// break ;
30960: GO 30994
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
30962: LD_INT 267
30964: PPUSH
30965: CALL_OW 274
30969: PPUSH
30970: LD_INT 1
30972: PPUSH
30973: CALL_OW 275
30977: PUSH
30978: LD_INT 1000
30980: GREATEREQUAL
30981: IFFALSE 30987
// BuildBehemoths ;
30983: CALL 8255 0 0
// until not behemothBuilders ;
30987: LD_EXP 76
30991: NOT
30992: IFFALSE 30947
// end ;
30994: PPOPN 1
30996: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
30997: LD_EXP 76
31001: NOT
31002: PUSH
31003: LD_EXP 28
31007: NOT
31008: AND
31009: PUSH
31010: LD_EXP 25
31014: AND
31015: IFFALSE 31035
31017: GO 31019
31019: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
31020: LD_STRING M4a
31022: PPUSH
31023: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
31027: LD_ADDR_EXP 27
31031: PUSH
31032: LD_INT 1
31034: ST_TO_ADDR
// end ;
31035: END
// every 0 0$1 trigger behemothDone do
31036: LD_EXP 28
31040: IFFALSE 31052
31042: GO 31044
31044: DISABLE
// ChangeMissionObjectives ( M4b ) ;
31045: LD_STRING M4b
31047: PPUSH
31048: CALL_OW 337
31052: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
31053: LD_EXP 29
31057: NOT
31058: IFFALSE 31254
31060: GO 31062
31062: DISABLE
31063: LD_INT 0
31065: PPUSH
31066: PPUSH
// begin enable ;
31067: ENABLE
// tmp := GetBehemoths ( 3 ) ;
31068: LD_ADDR_VAR 0 1
31072: PUSH
31073: LD_INT 3
31075: PPUSH
31076: CALL 107196 0 1
31080: ST_TO_ADDR
// if not tmp and not behemothDone then
31081: LD_VAR 0 1
31085: NOT
31086: PUSH
31087: LD_EXP 28
31091: NOT
31092: AND
31093: IFFALSE 31129
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
31095: LD_ADDR_VAR 0 1
31099: PUSH
31100: LD_INT 22
31102: PUSH
31103: LD_INT 3
31105: PUSH
31106: EMPTY
31107: LIST
31108: LIST
31109: PUSH
31110: LD_INT 30
31112: PUSH
31113: LD_INT 37
31115: PUSH
31116: EMPTY
31117: LIST
31118: LIST
31119: PUSH
31120: EMPTY
31121: LIST
31122: LIST
31123: PPUSH
31124: CALL_OW 69
31128: ST_TO_ADDR
// if not tmp then
31129: LD_VAR 0 1
31133: NOT
31134: IFFALSE 31138
// exit ;
31136: GO 31254
// for i in tmp do
31138: LD_ADDR_VAR 0 2
31142: PUSH
31143: LD_VAR 0 1
31147: PUSH
31148: FOR_IN
31149: IFFALSE 31252
// if See ( 1 , i ) then
31151: LD_INT 1
31153: PPUSH
31154: LD_VAR 0 2
31158: PPUSH
31159: CALL_OW 292
31163: IFFALSE 31250
// begin if GetType ( i ) = unit_building then
31165: LD_VAR 0 2
31169: PPUSH
31170: CALL_OW 247
31174: PUSH
31175: LD_INT 3
31177: EQUAL
31178: IFFALSE 31216
// begin disable ;
31180: DISABLE
// CenterNowOnUnits ( i ) ;
31181: LD_VAR 0 2
31185: PPUSH
31186: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
31190: LD_EXP 40
31194: PPUSH
31195: LD_STRING D17a-JMM-1
31197: PPUSH
31198: CALL_OW 88
// seeBehemoth := true ;
31202: LD_ADDR_EXP 29
31206: PUSH
31207: LD_INT 1
31209: ST_TO_ADDR
// exit ;
31210: POP
31211: POP
31212: GO 31254
// end else
31214: GO 31250
// begin disable ;
31216: DISABLE
// CenterNowOnUnits ( i ) ;
31217: LD_VAR 0 2
31221: PPUSH
31222: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
31226: LD_EXP 40
31230: PPUSH
31231: LD_STRING D17b-JMM-1
31233: PPUSH
31234: CALL_OW 88
// seeBehemoth := true ;
31238: LD_ADDR_EXP 29
31242: PUSH
31243: LD_INT 1
31245: ST_TO_ADDR
// exit ;
31246: POP
31247: POP
31248: GO 31254
// end ; end ;
31250: GO 31148
31252: POP
31253: POP
// end ;
31254: PPOPN 2
31256: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
31257: LD_EXP 14
31261: PUSH
31262: LD_INT 123200
31264: GREATEREQUAL
31265: IFFALSE 32465
31267: GO 31269
31269: DISABLE
31270: LD_INT 0
31272: PPUSH
31273: PPUSH
31274: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
31275: LD_INT 2
31277: PPUSH
31278: LD_INT 23
31280: PUSH
31281: LD_INT 3
31283: PUSH
31284: LD_INT 3
31286: PUSH
31287: LD_INT 48
31289: PUSH
31290: EMPTY
31291: LIST
31292: LIST
31293: LIST
31294: LIST
31295: PUSH
31296: EMPTY
31297: LIST
31298: PPUSH
31299: CALL 63018 0 2
// repeat wait ( 0 0$1 ) ;
31303: LD_INT 35
31305: PPUSH
31306: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
31310: LD_INT 22
31312: PUSH
31313: LD_INT 3
31315: PUSH
31316: EMPTY
31317: LIST
31318: LIST
31319: PUSH
31320: LD_INT 34
31322: PUSH
31323: LD_INT 48
31325: PUSH
31326: EMPTY
31327: LIST
31328: LIST
31329: PUSH
31330: EMPTY
31331: LIST
31332: LIST
31333: PPUSH
31334: CALL_OW 69
31338: IFFALSE 31303
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
31340: LD_ADDR_VAR 0 1
31344: PUSH
31345: LD_INT 22
31347: PUSH
31348: LD_INT 3
31350: PUSH
31351: EMPTY
31352: LIST
31353: LIST
31354: PUSH
31355: LD_INT 34
31357: PUSH
31358: LD_INT 48
31360: PUSH
31361: EMPTY
31362: LIST
31363: LIST
31364: PUSH
31365: EMPTY
31366: LIST
31367: LIST
31368: PPUSH
31369: CALL_OW 69
31373: PUSH
31374: LD_INT 1
31376: ARRAY
31377: ST_TO_ADDR
// missionStage := 12 ;
31378: LD_ADDR_EXP 15
31382: PUSH
31383: LD_INT 12
31385: ST_TO_ADDR
// platonovHasBomb := true ;
31386: LD_ADDR_EXP 30
31390: PUSH
31391: LD_INT 1
31393: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
31394: LD_VAR 0 1
31398: PPUSH
31399: LD_INT 181
31401: PPUSH
31402: LD_INT 86
31404: PPUSH
31405: CALL_OW 171
// AddComHold ( bomb ) ;
31409: LD_VAR 0 1
31413: PPUSH
31414: CALL_OW 200
// wait ( 0 0$10 ) ;
31418: LD_INT 350
31420: PPUSH
31421: CALL_OW 67
// DialogueOn ;
31425: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
31429: LD_EXP 67
31433: PPUSH
31434: LD_STRING D15-Pla-1
31436: PPUSH
31437: CALL_OW 94
// dec := Query ( Q15a ) ;
31441: LD_ADDR_VAR 0 2
31445: PUSH
31446: LD_STRING Q15a
31448: PPUSH
31449: CALL_OW 97
31453: ST_TO_ADDR
// if dec = 1 then
31454: LD_VAR 0 2
31458: PUSH
31459: LD_INT 1
31461: EQUAL
31462: IFFALSE 31485
// begin Say ( JMM , D15a-JMM-1 ) ;
31464: LD_EXP 40
31468: PPUSH
31469: LD_STRING D15a-JMM-1
31471: PPUSH
31472: CALL_OW 88
// YouLost ( Surrender ) ;
31476: LD_STRING Surrender
31478: PPUSH
31479: CALL_OW 104
// exit ;
31483: GO 32465
// end ; if dec = 2 then
31485: LD_VAR 0 2
31489: PUSH
31490: LD_INT 2
31492: EQUAL
31493: IFFALSE 31562
// begin Say ( JMM , D15b-JMM-1 ) ;
31495: LD_EXP 40
31499: PPUSH
31500: LD_STRING D15b-JMM-1
31502: PPUSH
31503: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
31507: LD_EXP 67
31511: PPUSH
31512: LD_STRING D15b-Pla-1
31514: PPUSH
31515: CALL_OW 94
// DialogueOff ;
31519: CALL_OW 7
// wait ( 3 3$00 ) ;
31523: LD_INT 6300
31525: PPUSH
31526: CALL_OW 67
// DialogueOn ;
31530: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
31534: LD_EXP 40
31538: PPUSH
31539: LD_STRING D15d-JMM-1a
31541: PPUSH
31542: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
31546: LD_EXP 67
31550: PPUSH
31551: LD_STRING D15d-Pla-1
31553: PPUSH
31554: CALL_OW 94
// DialogueOff ;
31558: CALL_OW 7
// end ; if dec = 3 then
31562: LD_VAR 0 2
31566: PUSH
31567: LD_INT 3
31569: EQUAL
31570: IFFALSE 31624
// begin Say ( JMM , D15c-JMM-1 ) ;
31572: LD_EXP 40
31576: PPUSH
31577: LD_STRING D15c-JMM-1
31579: PPUSH
31580: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
31584: LD_EXP 67
31588: PPUSH
31589: LD_STRING D15c-Pla-1
31591: PPUSH
31592: CALL_OW 94
// DialogueOff ;
31596: CALL_OW 7
// wait ( 0 0$15 ) ;
31600: LD_INT 525
31602: PPUSH
31603: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
31607: LD_VAR 0 1
31611: PPUSH
31612: LD_INT 60
31614: PPUSH
31615: LD_INT 95
31617: PPUSH
31618: CALL_OW 116
// exit ;
31622: GO 32465
// end ; if dec = 4 then
31624: LD_VAR 0 2
31628: PUSH
31629: LD_INT 4
31631: EQUAL
31632: IFFALSE 31662
// begin Say ( JMM , D15d-JMM-1 ) ;
31634: LD_EXP 40
31638: PPUSH
31639: LD_STRING D15d-JMM-1
31641: PPUSH
31642: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
31646: LD_EXP 67
31650: PPUSH
31651: LD_STRING D15d-Pla-1
31653: PPUSH
31654: CALL_OW 94
// DialogueOff ;
31658: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
31662: LD_EXP 65
31666: PPUSH
31667: CALL_OW 302
31671: PUSH
31672: LD_EXP 65
31676: PPUSH
31677: CALL_OW 255
31681: PUSH
31682: LD_INT 1
31684: EQUAL
31685: AND
31686: PUSH
31687: LD_INT 22
31689: PUSH
31690: LD_INT 1
31692: PUSH
31693: EMPTY
31694: LIST
31695: LIST
31696: PUSH
31697: LD_INT 34
31699: PUSH
31700: LD_INT 8
31702: PUSH
31703: EMPTY
31704: LIST
31705: LIST
31706: PUSH
31707: EMPTY
31708: LIST
31709: LIST
31710: PPUSH
31711: CALL_OW 69
31715: NOT
31716: AND
31717: IFFALSE 32366
// begin SetSide ( Friend , 8 ) ;
31719: LD_EXP 65
31723: PPUSH
31724: LD_INT 8
31726: PPUSH
31727: CALL_OW 235
// if IsInUnit ( Friend ) then
31731: LD_EXP 65
31735: PPUSH
31736: CALL_OW 310
31740: IFFALSE 31751
// ComExitBuilding ( Friend ) ;
31742: LD_EXP 65
31746: PPUSH
31747: CALL_OW 122
// if IsDriver ( Friend ) then
31751: LD_EXP 65
31755: PPUSH
31756: CALL 104739 0 1
31760: IFFALSE 31771
// ComExitVehicle ( Friend ) ;
31762: LD_EXP 65
31766: PPUSH
31767: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
31771: LD_EXP 65
31775: PPUSH
31776: LD_INT 9
31778: PPUSH
31779: LD_INT 2
31781: PPUSH
31782: CALL_OW 171
// wait ( 0 0$05 ) ;
31786: LD_INT 175
31788: PPUSH
31789: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
31793: LD_EXP 65
31797: PPUSH
31798: CALL_OW 87
// DialogueOn ;
31802: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
31806: LD_EXP 40
31810: PPUSH
31811: LD_STRING D16-JMM-1
31813: PPUSH
31814: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
31818: LD_EXP 65
31822: PPUSH
31823: LD_STRING D16-Friend-1
31825: PPUSH
31826: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
31830: LD_EXP 40
31834: PPUSH
31835: LD_STRING D16-JMM-2
31837: PPUSH
31838: CALL_OW 88
// DialogueOff ;
31842: CALL_OW 7
// SetSide ( Friend , 1 ) ;
31846: LD_EXP 65
31850: PPUSH
31851: LD_INT 1
31853: PPUSH
31854: CALL_OW 235
// ComHold ( Friend ) ;
31858: LD_EXP 65
31862: PPUSH
31863: CALL_OW 140
// wait ( 0 0$20 ) ;
31867: LD_INT 700
31869: PPUSH
31870: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
31874: LD_EXP 65
31878: PPUSH
31879: LD_INT 9
31881: PPUSH
31882: LD_INT 2
31884: PPUSH
31885: CALL_OW 297
31889: PUSH
31890: LD_INT 30
31892: LESS
31893: IFFALSE 31962
// begin SetSide ( Friend , 8 ) ;
31895: LD_EXP 65
31899: PPUSH
31900: LD_INT 8
31902: PPUSH
31903: CALL_OW 235
// if IsInUnit ( Friend ) then
31907: LD_EXP 65
31911: PPUSH
31912: CALL_OW 310
31916: IFFALSE 31927
// ComExitBuilding ( Friend ) ;
31918: LD_EXP 65
31922: PPUSH
31923: CALL_OW 122
// if IsDriver ( Friend ) then
31927: LD_EXP 65
31931: PPUSH
31932: CALL 104739 0 1
31936: IFFALSE 31947
// ComExitVehicle ( Friend ) ;
31938: LD_EXP 65
31942: PPUSH
31943: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
31947: LD_EXP 65
31951: PPUSH
31952: LD_INT 9
31954: PPUSH
31955: LD_INT 2
31957: PPUSH
31958: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
31962: LD_INT 1050
31964: PPUSH
31965: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
31969: LD_INT 22
31971: PUSH
31972: LD_INT 1
31974: PUSH
31975: EMPTY
31976: LIST
31977: LIST
31978: PUSH
31979: LD_INT 34
31981: PUSH
31982: LD_INT 8
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PUSH
31989: EMPTY
31990: LIST
31991: LIST
31992: PPUSH
31993: CALL_OW 69
31997: NOT
31998: IFFALSE 32344
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
32000: LD_ADDR_VAR 0 3
32004: PUSH
32005: LD_INT 22
32007: PUSH
32008: LD_INT 1
32010: PUSH
32011: EMPTY
32012: LIST
32013: LIST
32014: PUSH
32015: LD_INT 26
32017: PUSH
32018: LD_INT 1
32020: PUSH
32021: EMPTY
32022: LIST
32023: LIST
32024: PUSH
32025: LD_INT 3
32027: PUSH
32028: LD_INT 25
32030: PUSH
32031: LD_INT 12
32033: PUSH
32034: EMPTY
32035: LIST
32036: LIST
32037: PUSH
32038: LD_INT 25
32040: PUSH
32041: LD_INT 16
32043: PUSH
32044: EMPTY
32045: LIST
32046: LIST
32047: PUSH
32048: EMPTY
32049: LIST
32050: LIST
32051: LIST
32052: PUSH
32053: EMPTY
32054: LIST
32055: LIST
32056: LIST
32057: PPUSH
32058: CALL_OW 69
32062: PUSH
32063: LD_EXP 40
32067: PUSH
32068: LD_EXP 42
32072: PUSH
32073: LD_EXP 56
32077: PUSH
32078: LD_EXP 43
32082: PUSH
32083: LD_EXP 44
32087: PUSH
32088: LD_EXP 45
32092: PUSH
32093: LD_EXP 46
32097: PUSH
32098: LD_EXP 47
32102: PUSH
32103: LD_EXP 48
32107: PUSH
32108: LD_EXP 49
32112: PUSH
32113: LD_EXP 50
32117: PUSH
32118: LD_EXP 51
32122: PUSH
32123: LD_EXP 52
32127: PUSH
32128: LD_EXP 53
32132: PUSH
32133: LD_EXP 54
32137: PUSH
32138: EMPTY
32139: LIST
32140: LIST
32141: LIST
32142: LIST
32143: LIST
32144: LIST
32145: LIST
32146: LIST
32147: LIST
32148: LIST
32149: LIST
32150: LIST
32151: LIST
32152: LIST
32153: LIST
32154: DIFF
32155: ST_TO_ADDR
// DialogueOn ;
32156: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
32160: LD_EXP 67
32164: PPUSH
32165: LD_STRING D16a-Pla-1
32167: PPUSH
32168: CALL_OW 94
// if Stevens then
32172: LD_EXP 42
32176: IFFALSE 32192
// Say ( Stevens , D16a-Huck-1 ) else
32178: LD_EXP 42
32182: PPUSH
32183: LD_STRING D16a-Huck-1
32185: PPUSH
32186: CALL_OW 88
32190: GO 32234
// if Baker then
32192: LD_EXP 56
32196: IFFALSE 32212
// Say ( Baker , D16a-Huck-1 ) else
32198: LD_EXP 56
32202: PPUSH
32203: LD_STRING D16a-Huck-1
32205: PPUSH
32206: CALL_OW 88
32210: GO 32234
// if tmp then
32212: LD_VAR 0 3
32216: IFFALSE 32234
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
32218: LD_VAR 0 3
32222: PUSH
32223: LD_INT 1
32225: ARRAY
32226: PPUSH
32227: LD_STRING D16a-Sol1-1
32229: PPUSH
32230: CALL_OW 88
// if GetSide ( Friend ) = 8 then
32234: LD_EXP 65
32238: PPUSH
32239: CALL_OW 255
32243: PUSH
32244: LD_INT 8
32246: EQUAL
32247: IFFALSE 32263
// Say ( JMM , D16a-JMM-1 ) else
32249: LD_EXP 40
32253: PPUSH
32254: LD_STRING D16a-JMM-1
32256: PPUSH
32257: CALL_OW 88
32261: GO 32323
// begin Say ( JMM , D16a-JMM-1a ) ;
32263: LD_EXP 40
32267: PPUSH
32268: LD_STRING D16a-JMM-1a
32270: PPUSH
32271: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
32275: LD_EXP 65
32279: PPUSH
32280: LD_STRING D16a-Friend-1
32282: PPUSH
32283: CALL_OW 88
// ComExitBuilding ( Friend ) ;
32287: LD_EXP 65
32291: PPUSH
32292: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
32296: LD_EXP 65
32300: PPUSH
32301: LD_INT 191
32303: PPUSH
32304: LD_INT 103
32306: PPUSH
32307: CALL_OW 171
// SetSide ( Friend , 3 ) ;
32311: LD_EXP 65
32315: PPUSH
32316: LD_INT 3
32318: PPUSH
32319: CALL_OW 235
// end ; DialogueOff ;
32323: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
32327: LD_VAR 0 1
32331: PPUSH
32332: LD_INT 60
32334: PPUSH
32335: LD_INT 95
32337: PPUSH
32338: CALL_OW 116
// end else
32342: GO 32364
// begin DialogueOn ;
32344: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
32348: LD_EXP 67
32352: PPUSH
32353: LD_STRING D16c-Pla-1
32355: PPUSH
32356: CALL_OW 94
// DialogueOff ;
32360: CALL_OW 7
// end ; end else
32364: GO 32465
// begin wait ( 3 3$00 ) ;
32366: LD_INT 6300
32368: PPUSH
32369: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32373: LD_INT 22
32375: PUSH
32376: LD_INT 1
32378: PUSH
32379: EMPTY
32380: LIST
32381: LIST
32382: PUSH
32383: LD_INT 34
32385: PUSH
32386: LD_INT 8
32388: PUSH
32389: EMPTY
32390: LIST
32391: LIST
32392: PUSH
32393: EMPTY
32394: LIST
32395: LIST
32396: PPUSH
32397: CALL_OW 69
32401: NOT
32402: IFFALSE 32445
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
32404: LD_EXP 67
32408: PPUSH
32409: LD_STRING D16b-Pla-1
32411: PPUSH
32412: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
32416: LD_EXP 40
32420: PPUSH
32421: LD_STRING D16b-JMM-1
32423: PPUSH
32424: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
32428: LD_VAR 0 1
32432: PPUSH
32433: LD_INT 60
32435: PPUSH
32436: LD_INT 95
32438: PPUSH
32439: CALL_OW 116
// end else
32443: GO 32465
// begin DialogueOn ;
32445: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
32449: LD_EXP 67
32453: PPUSH
32454: LD_STRING D16c-Pla-1
32456: PPUSH
32457: CALL_OW 94
// DialogueOff ;
32461: CALL_OW 7
// end ; end ; end ;
32465: PPOPN 3
32467: END
// every 0 0$10 trigger ( GetTech ( tech_SibFiss , 1 ) = state_researched or missionTime >= 60 60$00 ) and not allianceDestroyed and IsOk ( Roth ) do var dec ;
32468: LD_INT 25
32470: PPUSH
32471: LD_INT 1
32473: PPUSH
32474: CALL_OW 321
32478: PUSH
32479: LD_INT 2
32481: EQUAL
32482: PUSH
32483: LD_EXP 14
32487: PUSH
32488: LD_INT 126000
32490: GREATEREQUAL
32491: OR
32492: PUSH
32493: LD_EXP 23
32497: NOT
32498: AND
32499: PUSH
32500: LD_EXP 78
32504: PPUSH
32505: CALL_OW 302
32509: AND
32510: IFFALSE 32868
32512: GO 32514
32514: DISABLE
32515: LD_INT 0
32517: PPUSH
// begin missionStage := 11 ;
32518: LD_ADDR_EXP 15
32522: PUSH
32523: LD_INT 11
32525: ST_TO_ADDR
// DialogueOn ;
32526: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
32530: LD_EXP 78
32534: PPUSH
32535: LD_STRING D9-Roth-1
32537: PPUSH
32538: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
32542: LD_EXP 40
32546: PPUSH
32547: LD_STRING D9-JMM-1
32549: PPUSH
32550: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
32554: LD_EXP 78
32558: PPUSH
32559: LD_STRING D9-Roth-2
32561: PPUSH
32562: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
32566: LD_EXP 78
32570: PPUSH
32571: LD_STRING D9-Roth-2a
32573: PPUSH
32574: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
32578: LD_EXP 67
32582: PPUSH
32583: LD_STRING D9-Pla-2
32585: PPUSH
32586: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
32590: LD_EXP 78
32594: PPUSH
32595: LD_STRING D9-Roth-3
32597: PPUSH
32598: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
32602: LD_EXP 67
32606: PPUSH
32607: LD_STRING D9-Pla-3
32609: PPUSH
32610: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
32614: LD_EXP 78
32618: PPUSH
32619: LD_STRING D9-Roth-4
32621: PPUSH
32622: CALL_OW 94
// dec := Query ( Q9 ) ;
32626: LD_ADDR_VAR 0 1
32630: PUSH
32631: LD_STRING Q9
32633: PPUSH
32634: CALL_OW 97
32638: ST_TO_ADDR
// if dec = 1 then
32639: LD_VAR 0 1
32643: PUSH
32644: LD_INT 1
32646: EQUAL
32647: IFFALSE 32661
// SayRadio ( Roth , D9a-Roth-1 ) ;
32649: LD_EXP 78
32653: PPUSH
32654: LD_STRING D9a-Roth-1
32656: PPUSH
32657: CALL_OW 94
// if dec = 2 then
32661: LD_VAR 0 1
32665: PUSH
32666: LD_INT 2
32668: EQUAL
32669: IFFALSE 32695
// begin Say ( JMM , D9b-JMM-1 ) ;
32671: LD_EXP 40
32675: PPUSH
32676: LD_STRING D9b-JMM-1
32678: PPUSH
32679: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
32683: LD_EXP 78
32687: PPUSH
32688: LD_STRING D9b-Roth-1
32690: PPUSH
32691: CALL_OW 94
// end ; if dec = 3 then
32695: LD_VAR 0 1
32699: PUSH
32700: LD_INT 3
32702: EQUAL
32703: IFFALSE 32765
// begin Say ( JMM , D9c-JMM-1 ) ;
32705: LD_EXP 40
32709: PPUSH
32710: LD_STRING D9c-JMM-1
32712: PPUSH
32713: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
32717: LD_EXP 78
32721: PPUSH
32722: LD_STRING D9c-Roth-1
32724: PPUSH
32725: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
32729: LD_EXP 40
32733: PPUSH
32734: LD_STRING D9c-JMM-2
32736: PPUSH
32737: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
32741: LD_EXP 78
32745: PPUSH
32746: LD_STRING D9c-Roth-2
32748: PPUSH
32749: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
32753: LD_EXP 40
32757: PPUSH
32758: LD_STRING D9c-JMM-3
32760: PPUSH
32761: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
32765: LD_EXP 78
32769: PPUSH
32770: LD_STRING D9c-Roth-3
32772: PPUSH
32773: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
32777: LD_EXP 78
32781: PPUSH
32782: LD_STRING D9cont-Roth-1
32784: PPUSH
32785: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
32789: LD_EXP 40
32793: PPUSH
32794: LD_STRING D9cont-JMM-1
32796: PPUSH
32797: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
32801: LD_EXP 78
32805: PPUSH
32806: LD_STRING D9cont-Roth-2
32808: PPUSH
32809: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
32813: LD_EXP 40
32817: PPUSH
32818: LD_STRING D9cont-JMM-2
32820: PPUSH
32821: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
32825: LD_EXP 78
32829: PPUSH
32830: LD_STRING D9cont-Roth-3
32832: PPUSH
32833: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
32837: LD_EXP 40
32841: PPUSH
32842: LD_STRING D9cont-JMM-3
32844: PPUSH
32845: CALL_OW 88
// DialogueOff ;
32849: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
32853: LD_STRING M3
32855: PPUSH
32856: CALL_OW 337
// allianceActive := true ;
32860: LD_ADDR_EXP 31
32864: PUSH
32865: LD_INT 1
32867: ST_TO_ADDR
// end ;
32868: PPOPN 1
32870: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
32871: LD_INT 1
32873: PPUSH
32874: LD_INT 126
32876: PPUSH
32877: CALL_OW 292
32881: PUSH
32882: LD_EXP 67
32886: PPUSH
32887: CALL_OW 310
32891: AND
32892: IFFALSE 33045
32894: GO 32896
32896: DISABLE
32897: LD_INT 0
32899: PPUSH
// begin ComExitBuilding ( Platonov ) ;
32900: LD_EXP 67
32904: PPUSH
32905: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
32909: LD_ADDR_VAR 0 1
32913: PUSH
32914: LD_INT 4
32916: PPUSH
32917: LD_INT 22
32919: PUSH
32920: LD_INT 1
32922: PUSH
32923: EMPTY
32924: LIST
32925: LIST
32926: PPUSH
32927: CALL_OW 70
32931: PPUSH
32932: LD_EXP 67
32936: PPUSH
32937: CALL_OW 74
32941: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
32942: LD_EXP 67
32946: PPUSH
32947: LD_VAR 0 1
32951: PUSH
32952: LD_INT 1
32954: ARRAY
32955: PPUSH
32956: CALL_OW 175
// SayRadio ( Platonov , D18-Pla-1 ) ;
32960: LD_EXP 67
32964: PPUSH
32965: LD_STRING D18-Pla-1
32967: PPUSH
32968: CALL_OW 94
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
32972: LD_INT 22
32974: PUSH
32975: LD_INT 3
32977: PUSH
32978: EMPTY
32979: LIST
32980: LIST
32981: PUSH
32982: LD_INT 34
32984: PUSH
32985: LD_INT 48
32987: PUSH
32988: EMPTY
32989: LIST
32990: LIST
32991: PUSH
32992: EMPTY
32993: LIST
32994: LIST
32995: PPUSH
32996: CALL_OW 69
33000: IFFALSE 33045
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 111 , 97 ) ;
33002: LD_INT 22
33004: PUSH
33005: LD_INT 3
33007: PUSH
33008: EMPTY
33009: LIST
33010: LIST
33011: PUSH
33012: LD_INT 34
33014: PUSH
33015: LD_INT 48
33017: PUSH
33018: EMPTY
33019: LIST
33020: LIST
33021: PUSH
33022: EMPTY
33023: LIST
33024: LIST
33025: PPUSH
33026: CALL_OW 69
33030: PUSH
33031: LD_INT 1
33033: ARRAY
33034: PPUSH
33035: LD_INT 111
33037: PPUSH
33038: LD_INT 97
33040: PPUSH
33041: CALL_OW 116
// end ;
33045: PPOPN 1
33047: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
33048: LD_EXP 67
33052: PPUSH
33053: CALL_OW 301
33057: PUSH
33058: LD_EXP 70
33062: PPUSH
33063: CALL_OW 301
33067: AND
33068: PUSH
33069: LD_INT 22
33071: PUSH
33072: LD_INT 3
33074: PUSH
33075: EMPTY
33076: LIST
33077: LIST
33078: PUSH
33079: LD_INT 21
33081: PUSH
33082: LD_INT 1
33084: PUSH
33085: EMPTY
33086: LIST
33087: LIST
33088: PUSH
33089: LD_INT 50
33091: PUSH
33092: EMPTY
33093: LIST
33094: PUSH
33095: EMPTY
33096: LIST
33097: LIST
33098: LIST
33099: PPUSH
33100: CALL_OW 69
33104: PUSH
33105: LD_INT 7
33107: PUSH
33108: LD_INT 8
33110: PUSH
33111: LD_INT 9
33113: PUSH
33114: LD_INT 10
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: LIST
33121: LIST
33122: PUSH
33123: LD_OWVAR 67
33127: ARRAY
33128: LESS
33129: AND
33130: IFFALSE 33929
33132: GO 33134
33134: DISABLE
33135: LD_INT 0
33137: PPUSH
33138: PPUSH
33139: PPUSH
33140: PPUSH
// begin MC_Kill ( 2 ) ;
33141: LD_INT 2
33143: PPUSH
33144: CALL 38993 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
33148: LD_INT 1
33150: PPUSH
33151: LD_INT 3
33153: PPUSH
33154: LD_INT 1
33156: PPUSH
33157: LD_INT 1
33159: PPUSH
33160: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
33164: LD_ADDR_VAR 0 2
33168: PUSH
33169: LD_INT 22
33171: PUSH
33172: LD_INT 3
33174: PUSH
33175: EMPTY
33176: LIST
33177: LIST
33178: PUSH
33179: LD_INT 21
33181: PUSH
33182: LD_INT 1
33184: PUSH
33185: EMPTY
33186: LIST
33187: LIST
33188: PUSH
33189: LD_INT 50
33191: PUSH
33192: EMPTY
33193: LIST
33194: PUSH
33195: LD_INT 26
33197: PUSH
33198: LD_INT 1
33200: PUSH
33201: EMPTY
33202: LIST
33203: LIST
33204: PUSH
33205: EMPTY
33206: LIST
33207: LIST
33208: LIST
33209: LIST
33210: PPUSH
33211: CALL_OW 69
33215: ST_TO_ADDR
// if not tmp then
33216: LD_VAR 0 2
33220: NOT
33221: IFFALSE 33277
// begin uc_side = 3 ;
33223: LD_ADDR_OWVAR 20
33227: PUSH
33228: LD_INT 3
33230: ST_TO_ADDR
// uc_nation = 3 ;
33231: LD_ADDR_OWVAR 21
33235: PUSH
33236: LD_INT 3
33238: ST_TO_ADDR
// hc_name =  ;
33239: LD_ADDR_OWVAR 26
33243: PUSH
33244: LD_STRING 
33246: ST_TO_ADDR
// hc_gallery =  ;
33247: LD_ADDR_OWVAR 33
33251: PUSH
33252: LD_STRING 
33254: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
33255: LD_INT 1
33257: PPUSH
33258: LD_INT 10
33260: PPUSH
33261: CALL_OW 381
// tmp = CreateHuman ;
33265: LD_ADDR_VAR 0 2
33269: PUSH
33270: CALL_OW 44
33274: ST_TO_ADDR
// end else
33275: GO 33291
// tmp := tmp [ 1 ] ;
33277: LD_ADDR_VAR 0 2
33281: PUSH
33282: LD_VAR 0 2
33286: PUSH
33287: LD_INT 1
33289: ARRAY
33290: ST_TO_ADDR
// DialogueOn ;
33291: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
33295: LD_VAR 0 2
33299: PPUSH
33300: LD_STRING DSurrenderRussians-RSol1-1a
33302: PPUSH
33303: CALL_OW 94
// DialogueOff ;
33307: CALL_OW 7
// russianDestroyed := true ;
33311: LD_ADDR_EXP 21
33315: PUSH
33316: LD_INT 1
33318: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
33319: LD_ADDR_VAR 0 1
33323: PUSH
33324: LD_INT 22
33326: PUSH
33327: LD_INT 6
33329: PUSH
33330: EMPTY
33331: LIST
33332: LIST
33333: PPUSH
33334: CALL_OW 69
33338: PUSH
33339: FOR_IN
33340: IFFALSE 33353
// KillUnit ( i ) ;
33342: LD_VAR 0 1
33346: PPUSH
33347: CALL_OW 66
33351: GO 33339
33353: POP
33354: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
33355: LD_INT 22
33357: PUSH
33358: LD_INT 3
33360: PUSH
33361: EMPTY
33362: LIST
33363: LIST
33364: PUSH
33365: LD_INT 21
33367: PUSH
33368: LD_INT 1
33370: PUSH
33371: EMPTY
33372: LIST
33373: LIST
33374: PUSH
33375: EMPTY
33376: LIST
33377: LIST
33378: PPUSH
33379: CALL_OW 69
33383: PPUSH
33384: CALL_OW 122
// wait ( 0 0$1 ) ;
33388: LD_INT 35
33390: PPUSH
33391: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
33395: LD_INT 22
33397: PUSH
33398: LD_INT 3
33400: PUSH
33401: EMPTY
33402: LIST
33403: LIST
33404: PUSH
33405: LD_INT 21
33407: PUSH
33408: LD_INT 1
33410: PUSH
33411: EMPTY
33412: LIST
33413: LIST
33414: PUSH
33415: EMPTY
33416: LIST
33417: LIST
33418: PPUSH
33419: CALL_OW 69
33423: PPUSH
33424: LD_INT 25
33426: PPUSH
33427: CALL_OW 173
// wait ( 0 0$35 ) ;
33431: LD_INT 1225
33433: PPUSH
33434: CALL_OW 67
// PrepareOmarInvasion ;
33438: CALL 16155 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
33442: LD_ADDR_VAR 0 2
33446: PUSH
33447: LD_EXP 96
33451: PPUSH
33452: CALL_OW 250
33456: PUSH
33457: LD_EXP 96
33461: PPUSH
33462: CALL_OW 251
33466: PUSH
33467: EMPTY
33468: LIST
33469: LIST
33470: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
33471: LD_VAR 0 2
33475: PUSH
33476: LD_INT 1
33478: ARRAY
33479: PPUSH
33480: LD_VAR 0 2
33484: PUSH
33485: LD_INT 2
33487: ARRAY
33488: PPUSH
33489: LD_INT 1
33491: PPUSH
33492: LD_INT 8
33494: NEG
33495: PPUSH
33496: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
33500: LD_EXP 96
33504: PPUSH
33505: CALL_OW 87
// DialogueOn ;
33509: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
33513: LD_EXP 40
33517: PPUSH
33518: LD_STRING D19-JMM-1
33520: PPUSH
33521: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Kurt , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
33525: LD_ADDR_VAR 0 3
33529: PUSH
33530: LD_INT 22
33532: PUSH
33533: LD_INT 1
33535: PUSH
33536: EMPTY
33537: LIST
33538: LIST
33539: PUSH
33540: LD_INT 26
33542: PUSH
33543: LD_INT 1
33545: PUSH
33546: EMPTY
33547: LIST
33548: LIST
33549: PUSH
33550: LD_INT 2
33552: PUSH
33553: LD_INT 25
33555: PUSH
33556: LD_INT 1
33558: PUSH
33559: EMPTY
33560: LIST
33561: LIST
33562: PUSH
33563: LD_INT 25
33565: PUSH
33566: LD_INT 2
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: PUSH
33573: LD_INT 25
33575: PUSH
33576: LD_INT 3
33578: PUSH
33579: EMPTY
33580: LIST
33581: LIST
33582: PUSH
33583: LD_INT 25
33585: PUSH
33586: LD_INT 4
33588: PUSH
33589: EMPTY
33590: LIST
33591: LIST
33592: PUSH
33593: LD_INT 25
33595: PUSH
33596: LD_INT 5
33598: PUSH
33599: EMPTY
33600: LIST
33601: LIST
33602: PUSH
33603: LD_INT 25
33605: PUSH
33606: LD_INT 8
33608: PUSH
33609: EMPTY
33610: LIST
33611: LIST
33612: PUSH
33613: EMPTY
33614: LIST
33615: LIST
33616: LIST
33617: LIST
33618: LIST
33619: LIST
33620: LIST
33621: PUSH
33622: EMPTY
33623: LIST
33624: LIST
33625: LIST
33626: PPUSH
33627: CALL_OW 69
33631: PUSH
33632: LD_EXP 40
33636: PUSH
33637: LD_EXP 41
33641: PUSH
33642: LD_EXP 63
33646: PUSH
33647: LD_EXP 42
33651: PUSH
33652: LD_EXP 43
33656: PUSH
33657: LD_EXP 44
33661: PUSH
33662: LD_EXP 45
33666: PUSH
33667: LD_EXP 46
33671: PUSH
33672: LD_EXP 47
33676: PUSH
33677: LD_EXP 48
33681: PUSH
33682: LD_EXP 49
33686: PUSH
33687: LD_EXP 50
33691: PUSH
33692: LD_EXP 51
33696: PUSH
33697: LD_EXP 52
33701: PUSH
33702: LD_EXP 53
33706: PUSH
33707: LD_EXP 54
33711: PUSH
33712: LD_EXP 55
33716: PUSH
33717: LD_EXP 56
33721: PUSH
33722: EMPTY
33723: LIST
33724: LIST
33725: LIST
33726: LIST
33727: LIST
33728: LIST
33729: LIST
33730: LIST
33731: LIST
33732: LIST
33733: LIST
33734: LIST
33735: LIST
33736: LIST
33737: LIST
33738: LIST
33739: LIST
33740: LIST
33741: DIFF
33742: ST_TO_ADDR
// if tmp2 then
33743: LD_VAR 0 3
33747: IFFALSE 33765
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
33749: LD_VAR 0 3
33753: PUSH
33754: LD_INT 1
33756: ARRAY
33757: PPUSH
33758: LD_STRING D19-Sol1-1
33760: PPUSH
33761: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
33765: LD_EXP 40
33769: PPUSH
33770: LD_STRING D19-JMM-2
33772: PPUSH
33773: CALL_OW 88
// DialogueOff ;
33777: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
33781: LD_VAR 0 2
33785: PUSH
33786: LD_INT 1
33788: ARRAY
33789: PPUSH
33790: LD_VAR 0 2
33794: PUSH
33795: LD_INT 2
33797: ARRAY
33798: PPUSH
33799: LD_INT 1
33801: PPUSH
33802: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
33806: LD_STRING M5
33808: PPUSH
33809: CALL_OW 337
// omarOnMotherLode := false ;
33813: LD_ADDR_VAR 0 4
33817: PUSH
33818: LD_INT 0
33820: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
33821: LD_INT 35
33823: PPUSH
33824: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
33828: LD_EXP 96
33832: PPUSH
33833: LD_INT 215
33835: PPUSH
33836: LD_INT 100
33838: PPUSH
33839: CALL_OW 297
33843: PUSH
33844: LD_INT 10
33846: LESS
33847: PUSH
33848: LD_VAR 0 4
33852: NOT
33853: AND
33854: IFFALSE 33888
// begin omarOnMotherLode := true ;
33856: LD_ADDR_VAR 0 4
33860: PUSH
33861: LD_INT 1
33863: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
33864: LD_EXP 40
33868: PPUSH
33869: LD_STRING D19b-JMM-1
33871: PPUSH
33872: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
33876: LD_EXP 96
33880: PPUSH
33881: LD_STRING DOmarContam-Omar-1
33883: PPUSH
33884: CALL_OW 88
// end ; until IsDead ( Omar ) ;
33888: LD_EXP 96
33892: PPUSH
33893: CALL_OW 301
33897: IFFALSE 33821
// Say ( JMM , D19a-JMM-1 ) ;
33899: LD_EXP 40
33903: PPUSH
33904: LD_STRING D19a-JMM-1
33906: PPUSH
33907: CALL_OW 88
// if Heike then
33911: LD_EXP 97
33915: IFFALSE 33929
// Say ( Heike , D19a-Hke-1 ) ;
33917: LD_EXP 97
33921: PPUSH
33922: LD_STRING D19a-Hke-1
33924: PPUSH
33925: CALL_OW 88
// end ;
33929: PPOPN 4
33931: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
33932: LD_INT 22
33934: PUSH
33935: LD_INT 3
33937: PUSH
33938: EMPTY
33939: LIST
33940: LIST
33941: PUSH
33942: LD_INT 21
33944: PUSH
33945: LD_INT 1
33947: PUSH
33948: EMPTY
33949: LIST
33950: LIST
33951: PUSH
33952: EMPTY
33953: LIST
33954: LIST
33955: PPUSH
33956: CALL_OW 69
33960: PUSH
33961: LD_EXP 21
33965: AND
33966: IFFALSE 34034
33968: GO 33970
33970: DISABLE
33971: LD_INT 0
33973: PPUSH
33974: PPUSH
// begin enable ;
33975: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
33976: LD_ADDR_VAR 0 2
33980: PUSH
33981: LD_INT 25
33983: PPUSH
33984: LD_INT 22
33986: PUSH
33987: LD_INT 3
33989: PUSH
33990: EMPTY
33991: LIST
33992: LIST
33993: PPUSH
33994: CALL_OW 70
33998: ST_TO_ADDR
// if not tmp then
33999: LD_VAR 0 2
34003: NOT
34004: IFFALSE 34008
// exit ;
34006: GO 34034
// for i in tmp do
34008: LD_ADDR_VAR 0 1
34012: PUSH
34013: LD_VAR 0 2
34017: PUSH
34018: FOR_IN
34019: IFFALSE 34032
// RemoveUnit ( i ) ;
34021: LD_VAR 0 1
34025: PPUSH
34026: CALL_OW 64
34030: GO 34018
34032: POP
34033: POP
// end ;
34034: PPOPN 2
34036: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
34037: LD_INT 22
34039: PUSH
34040: LD_INT 7
34042: PUSH
34043: EMPTY
34044: LIST
34045: LIST
34046: PUSH
34047: LD_INT 21
34049: PUSH
34050: LD_INT 1
34052: PUSH
34053: EMPTY
34054: LIST
34055: LIST
34056: PUSH
34057: EMPTY
34058: LIST
34059: LIST
34060: PPUSH
34061: CALL_OW 69
34065: PUSH
34066: LD_INT 6
34068: LESS
34069: IFFALSE 34537
34071: GO 34073
34073: DISABLE
34074: LD_INT 0
34076: PPUSH
34077: PPUSH
// begin MC_Kill ( 1 ) ;
34078: LD_INT 1
34080: PPUSH
34081: CALL 38993 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
34085: LD_INT 7
34087: PPUSH
34088: LD_INT 1
34090: PPUSH
34091: LD_INT 1
34093: PPUSH
34094: LD_INT 1
34096: PPUSH
34097: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
34101: LD_ADDR_VAR 0 1
34105: PUSH
34106: LD_INT 22
34108: PUSH
34109: LD_INT 7
34111: PUSH
34112: EMPTY
34113: LIST
34114: LIST
34115: PUSH
34116: LD_INT 26
34118: PUSH
34119: LD_INT 1
34121: PUSH
34122: EMPTY
34123: LIST
34124: LIST
34125: PUSH
34126: EMPTY
34127: LIST
34128: LIST
34129: PPUSH
34130: CALL_OW 69
34134: PUSH
34135: LD_EXP 78
34139: DIFF
34140: ST_TO_ADDR
// if tmp then
34141: LD_VAR 0 1
34145: IFFALSE 34163
// tmp := tmp [ 1 ] else
34147: LD_ADDR_VAR 0 1
34151: PUSH
34152: LD_VAR 0 1
34156: PUSH
34157: LD_INT 1
34159: ARRAY
34160: ST_TO_ADDR
34161: GO 34199
// begin uc_side := 7 ;
34163: LD_ADDR_OWVAR 20
34167: PUSH
34168: LD_INT 7
34170: ST_TO_ADDR
// uc_nation := 1 ;
34171: LD_ADDR_OWVAR 21
34175: PUSH
34176: LD_INT 1
34178: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
34179: LD_INT 1
34181: PPUSH
34182: LD_INT 8
34184: PPUSH
34185: CALL_OW 384
// tmp := CreateHuman ;
34189: LD_ADDR_VAR 0 1
34193: PUSH
34194: CALL_OW 44
34198: ST_TO_ADDR
// end ; DialogueOn ;
34199: CALL_OW 6
// if IsOK ( Roth ) then
34203: LD_EXP 78
34207: PPUSH
34208: CALL_OW 302
34212: IFFALSE 34226
// Say ( JMM , DAb-JMM-1 ) ;
34214: LD_EXP 40
34218: PPUSH
34219: LD_STRING DAb-JMM-1
34221: PPUSH
34222: CALL_OW 88
// if IsOK ( Roth ) then
34226: LD_EXP 78
34230: PPUSH
34231: CALL_OW 302
34235: IFFALSE 34259
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
34237: LD_EXP 78
34241: PPUSH
34242: LD_STRING DSurrenderAlliance-Roth-1
34244: PPUSH
34245: CALL_OW 88
// RothCaptured := true ;
34249: LD_ADDR_EXP 33
34253: PUSH
34254: LD_INT 1
34256: ST_TO_ADDR
// end else
34257: GO 34271
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
34259: LD_VAR 0 1
34263: PPUSH
34264: LD_STRING DSurrenderAlliance-Sci1-1
34266: PPUSH
34267: CALL_OW 88
// DialogueOff ;
34271: CALL_OW 7
// allianceDestroyed := true ;
34275: LD_ADDR_EXP 23
34279: PUSH
34280: LD_INT 1
34282: ST_TO_ADDR
// if capturedUnit = 0 then
34283: LD_EXP 34
34287: PUSH
34288: LD_INT 0
34290: EQUAL
34291: IFFALSE 34300
// SetAchievement ( ACH_ALLIANCE ) ;
34293: LD_STRING ACH_ALLIANCE
34295: PPUSH
34296: CALL_OW 543
// if trueAmericans then
34300: LD_EXP 35
34304: IFFALSE 34380
// begin if trueAmericans = 1 then
34306: LD_EXP 35
34310: PUSH
34311: LD_INT 1
34313: EQUAL
34314: IFFALSE 34330
// Say ( JMM , DAb-JMM-1a ) else
34316: LD_EXP 40
34320: PPUSH
34321: LD_STRING DAb-JMM-1a
34323: PPUSH
34324: CALL_OW 88
34328: GO 34342
// Say ( JMM , DAb-JMM-1b ) ;
34330: LD_EXP 40
34334: PPUSH
34335: LD_STRING DAb-JMM-1b
34337: PPUSH
34338: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
34342: LD_EXP 35
34346: PPUSH
34347: CALL_OW 87
// for i in trueAmericans do
34351: LD_ADDR_VAR 0 2
34355: PUSH
34356: LD_EXP 35
34360: PUSH
34361: FOR_IN
34362: IFFALSE 34378
// SetSide ( i , 1 ) ;
34364: LD_VAR 0 2
34368: PPUSH
34369: LD_INT 1
34371: PPUSH
34372: CALL_OW 235
34376: GO 34361
34378: POP
34379: POP
// end ; repeat wait ( 0 0$1 ) ;
34380: LD_INT 35
34382: PPUSH
34383: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
34387: LD_ADDR_VAR 0 2
34391: PUSH
34392: LD_INT 22
34394: PUSH
34395: LD_INT 7
34397: PUSH
34398: EMPTY
34399: LIST
34400: LIST
34401: PUSH
34402: LD_INT 21
34404: PUSH
34405: LD_INT 1
34407: PUSH
34408: EMPTY
34409: LIST
34410: LIST
34411: PUSH
34412: EMPTY
34413: LIST
34414: LIST
34415: PPUSH
34416: CALL_OW 69
34420: PUSH
34421: FOR_IN
34422: IFFALSE 34504
// begin if IsInUnit ( i ) then
34424: LD_VAR 0 2
34428: PPUSH
34429: CALL_OW 310
34433: IFFALSE 34444
// ComExitBuilding ( i ) ;
34435: LD_VAR 0 2
34439: PPUSH
34440: CALL_OW 122
// if IsDriver ( i ) then
34444: LD_VAR 0 2
34448: PPUSH
34449: CALL 104739 0 1
34453: IFFALSE 34464
// ComExitVehicle ( i ) ;
34455: LD_VAR 0 2
34459: PPUSH
34460: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
34464: LD_VAR 0 2
34468: PPUSH
34469: LD_INT 26
34471: PPUSH
34472: CALL_OW 308
34476: NOT
34477: IFFALSE 34493
// AddComMoveToArea ( i , allianceEscapeArea ) else
34479: LD_VAR 0 2
34483: PPUSH
34484: LD_INT 26
34486: PPUSH
34487: CALL_OW 173
34491: GO 34502
// RemoveUnit ( i ) ;
34493: LD_VAR 0 2
34497: PPUSH
34498: CALL_OW 64
// end ;
34502: GO 34421
34504: POP
34505: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
34506: LD_INT 22
34508: PUSH
34509: LD_INT 7
34511: PUSH
34512: EMPTY
34513: LIST
34514: LIST
34515: PUSH
34516: LD_INT 21
34518: PUSH
34519: LD_INT 1
34521: PUSH
34522: EMPTY
34523: LIST
34524: LIST
34525: PUSH
34526: EMPTY
34527: LIST
34528: LIST
34529: PPUSH
34530: CALL_OW 69
34534: NOT
34535: IFFALSE 34380
// end ;
34537: PPOPN 2
34539: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
34540: LD_INT 0
34542: PPUSH
34543: PPUSH
// if not unit then
34544: LD_VAR 0 1
34548: NOT
34549: IFFALSE 34553
// exit ;
34551: GO 36061
// DoNotAttack ( 7 , unit ) ;
34553: LD_INT 7
34555: PPUSH
34556: LD_VAR 0 1
34560: PPUSH
34561: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
34565: LD_VAR 0 1
34569: PPUSH
34570: LD_INT 260
34572: PPUSH
34573: LD_INT 235
34575: PPUSH
34576: LD_INT 3
34578: PPUSH
34579: LD_INT 1
34581: PPUSH
34582: CALL_OW 483
// SetSide ( unit , 4 ) ;
34586: LD_VAR 0 1
34590: PPUSH
34591: LD_INT 4
34593: PPUSH
34594: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
34598: LD_ADDR_EXP 34
34602: PUSH
34603: LD_EXP 34
34607: PUSH
34608: LD_INT 1
34610: PLUS
34611: ST_TO_ADDR
// wait ( 0 0$2 ) ;
34612: LD_INT 70
34614: PPUSH
34615: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
34619: LD_INT 260
34621: PPUSH
34622: LD_INT 235
34624: PPUSH
34625: LD_INT 1
34627: PPUSH
34628: LD_INT 8
34630: NEG
34631: PPUSH
34632: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
34636: LD_VAR 0 1
34640: PPUSH
34641: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
34645: LD_VAR 0 1
34649: PPUSH
34650: LD_EXP 78
34654: PPUSH
34655: CALL_OW 119
// DialogueOn ;
34659: CALL_OW 6
// case unit of JMM :
34663: LD_VAR 0 1
34667: PUSH
34668: LD_EXP 40
34672: DOUBLE
34673: EQUAL
34674: IFTRUE 34678
34676: GO 34693
34678: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
34679: LD_EXP 40
34683: PPUSH
34684: LD_STRING DA1-JMM-1
34686: PPUSH
34687: CALL_OW 91
34691: GO 35135
34693: LD_EXP 41
34697: DOUBLE
34698: EQUAL
34699: IFTRUE 34703
34701: GO 34718
34703: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
34704: LD_EXP 41
34708: PPUSH
34709: LD_STRING DA1-Joan-1
34711: PPUSH
34712: CALL_OW 91
34716: GO 35135
34718: LD_EXP 43
34722: DOUBLE
34723: EQUAL
34724: IFTRUE 34728
34726: GO 34743
34728: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
34729: LD_EXP 43
34733: PPUSH
34734: LD_STRING DA1-Lisa-1
34736: PPUSH
34737: CALL_OW 91
34741: GO 35135
34743: LD_EXP 44
34747: DOUBLE
34748: EQUAL
34749: IFTRUE 34753
34751: GO 34768
34753: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
34754: LD_EXP 44
34758: PPUSH
34759: LD_STRING DA1-Don-1
34761: PPUSH
34762: CALL_OW 91
34766: GO 35135
34768: LD_EXP 51
34772: DOUBLE
34773: EQUAL
34774: IFTRUE 34778
34776: GO 34793
34778: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
34779: LD_EXP 51
34783: PPUSH
34784: LD_STRING DA1-Corn-1
34786: PPUSH
34787: CALL_OW 91
34791: GO 35135
34793: LD_EXP 47
34797: DOUBLE
34798: EQUAL
34799: IFTRUE 34803
34801: GO 34818
34803: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
34804: LD_EXP 47
34808: PPUSH
34809: LD_STRING DA1-Den-1
34811: PPUSH
34812: CALL_OW 91
34816: GO 35135
34818: LD_EXP 45
34822: DOUBLE
34823: EQUAL
34824: IFTRUE 34828
34826: GO 34843
34828: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
34829: LD_EXP 45
34833: PPUSH
34834: LD_STRING DA1-Bobby-1
34836: PPUSH
34837: CALL_OW 91
34841: GO 35135
34843: LD_EXP 49
34847: DOUBLE
34848: EQUAL
34849: IFTRUE 34853
34851: GO 34868
34853: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
34854: LD_EXP 49
34858: PPUSH
34859: LD_STRING DA1-Glad-1
34861: PPUSH
34862: CALL_OW 91
34866: GO 35135
34868: LD_EXP 46
34872: DOUBLE
34873: EQUAL
34874: IFTRUE 34878
34876: GO 34893
34878: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
34879: LD_EXP 46
34883: PPUSH
34884: LD_STRING DA1-Cyrus-1
34886: PPUSH
34887: CALL_OW 91
34891: GO 35135
34893: LD_EXP 42
34897: DOUBLE
34898: EQUAL
34899: IFTRUE 34903
34901: GO 34918
34903: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
34904: LD_EXP 42
34908: PPUSH
34909: LD_STRING DA1-Huck-1
34911: PPUSH
34912: CALL_OW 91
34916: GO 35135
34918: LD_EXP 56
34922: DOUBLE
34923: EQUAL
34924: IFTRUE 34928
34926: GO 34943
34928: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
34929: LD_EXP 56
34933: PPUSH
34934: LD_STRING DA1-Huck-1
34936: PPUSH
34937: CALL_OW 91
34941: GO 35135
34943: LD_EXP 48
34947: DOUBLE
34948: EQUAL
34949: IFTRUE 34953
34951: GO 34968
34953: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
34954: LD_EXP 48
34958: PPUSH
34959: LD_STRING DA1-Brown-1
34961: PPUSH
34962: CALL_OW 91
34966: GO 35135
34968: LD_EXP 52
34972: DOUBLE
34973: EQUAL
34974: IFTRUE 34978
34976: GO 34993
34978: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
34979: LD_EXP 52
34983: PPUSH
34984: LD_STRING DA1-Gary-1
34986: PPUSH
34987: CALL_OW 91
34991: GO 35135
34993: LD_EXP 55
34997: DOUBLE
34998: EQUAL
34999: IFTRUE 35003
35001: GO 35018
35003: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
35004: LD_EXP 55
35008: PPUSH
35009: LD_STRING DA1-Con-1
35011: PPUSH
35012: CALL_OW 91
35016: GO 35135
35018: LD_EXP 63
35022: DOUBLE
35023: EQUAL
35024: IFTRUE 35028
35026: GO 35043
35028: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
35029: LD_EXP 63
35033: PPUSH
35034: LD_STRING DA1-Kurt-1
35036: PPUSH
35037: CALL_OW 91
35041: GO 35135
35043: LD_EXP 54
35047: DOUBLE
35048: EQUAL
35049: IFTRUE 35053
35051: GO 35068
35053: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
35054: LD_EXP 54
35058: PPUSH
35059: LD_STRING DA1-Yam-1
35061: PPUSH
35062: CALL_OW 91
35066: GO 35135
35068: LD_EXP 53
35072: DOUBLE
35073: EQUAL
35074: IFTRUE 35078
35076: GO 35093
35078: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
35079: LD_EXP 53
35083: PPUSH
35084: LD_STRING DA1-Frank-1
35086: PPUSH
35087: CALL_OW 91
35091: GO 35135
35093: POP
// begin if GetSex ( unit ) = sex_male then
35094: LD_VAR 0 1
35098: PPUSH
35099: CALL_OW 258
35103: PUSH
35104: LD_INT 1
35106: EQUAL
35107: IFFALSE 35123
// ForceSay ( unit , DA1-Sol1-1 ) else
35109: LD_VAR 0 1
35113: PPUSH
35114: LD_STRING DA1-Sol1-1
35116: PPUSH
35117: CALL_OW 91
35121: GO 35135
// ForceSay ( unit , DA1-FSol1-1 ) ;
35123: LD_VAR 0 1
35127: PPUSH
35128: LD_STRING DA1-FSol1-1
35130: PPUSH
35131: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
35135: LD_EXP 78
35139: PPUSH
35140: LD_STRING DA-Roth-1
35142: PPUSH
35143: CALL_OW 88
// if capturedUnit = 1 then
35147: LD_EXP 34
35151: PUSH
35152: LD_INT 1
35154: EQUAL
35155: IFFALSE 35183
// begin Say ( Simms , DA-Sim-1 ) ;
35157: LD_EXP 79
35161: PPUSH
35162: LD_STRING DA-Sim-1
35164: PPUSH
35165: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
35169: LD_EXP 78
35173: PPUSH
35174: LD_STRING DA-Roth-2
35176: PPUSH
35177: CALL_OW 88
// end else
35181: GO 35195
// Say ( Simms , DA-Sim-2 ) ;
35183: LD_EXP 79
35187: PPUSH
35188: LD_STRING DA-Sim-2
35190: PPUSH
35191: CALL_OW 88
// case unit of JMM :
35195: LD_VAR 0 1
35199: PUSH
35200: LD_EXP 40
35204: DOUBLE
35205: EQUAL
35206: IFTRUE 35210
35208: GO 35225
35210: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
35211: LD_EXP 40
35215: PPUSH
35216: LD_STRING DA1-JMM-1a
35218: PPUSH
35219: CALL_OW 91
35223: GO 35742
35225: LD_EXP 41
35229: DOUBLE
35230: EQUAL
35231: IFTRUE 35235
35233: GO 35250
35235: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
35236: LD_EXP 41
35240: PPUSH
35241: LD_STRING DA1-Joan-1a
35243: PPUSH
35244: CALL_OW 91
35248: GO 35742
35250: LD_EXP 43
35254: DOUBLE
35255: EQUAL
35256: IFTRUE 35260
35258: GO 35275
35260: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
35261: LD_EXP 43
35265: PPUSH
35266: LD_STRING DA1-Lisa-1a
35268: PPUSH
35269: CALL_OW 91
35273: GO 35742
35275: LD_EXP 44
35279: DOUBLE
35280: EQUAL
35281: IFTRUE 35285
35283: GO 35300
35285: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
35286: LD_EXP 44
35290: PPUSH
35291: LD_STRING DA1-Don-1a
35293: PPUSH
35294: CALL_OW 91
35298: GO 35742
35300: LD_EXP 51
35304: DOUBLE
35305: EQUAL
35306: IFTRUE 35310
35308: GO 35325
35310: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
35311: LD_EXP 51
35315: PPUSH
35316: LD_STRING DA1-Corn-1a
35318: PPUSH
35319: CALL_OW 91
35323: GO 35742
35325: LD_EXP 47
35329: DOUBLE
35330: EQUAL
35331: IFTRUE 35335
35333: GO 35350
35335: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
35336: LD_EXP 47
35340: PPUSH
35341: LD_STRING DA1-Den-1a
35343: PPUSH
35344: CALL_OW 91
35348: GO 35742
35350: LD_EXP 45
35354: DOUBLE
35355: EQUAL
35356: IFTRUE 35360
35358: GO 35375
35360: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
35361: LD_EXP 45
35365: PPUSH
35366: LD_STRING DA1-Bobby-1a
35368: PPUSH
35369: CALL_OW 91
35373: GO 35742
35375: LD_EXP 49
35379: DOUBLE
35380: EQUAL
35381: IFTRUE 35385
35383: GO 35400
35385: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
35386: LD_EXP 49
35390: PPUSH
35391: LD_STRING DA1-Glad-1a
35393: PPUSH
35394: CALL_OW 91
35398: GO 35742
35400: LD_EXP 46
35404: DOUBLE
35405: EQUAL
35406: IFTRUE 35410
35408: GO 35425
35410: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
35411: LD_EXP 46
35415: PPUSH
35416: LD_STRING DA1-Cyrus-1a
35418: PPUSH
35419: CALL_OW 91
35423: GO 35742
35425: LD_EXP 42
35429: DOUBLE
35430: EQUAL
35431: IFTRUE 35435
35433: GO 35450
35435: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
35436: LD_EXP 42
35440: PPUSH
35441: LD_STRING DA1-Huck-1a
35443: PPUSH
35444: CALL_OW 91
35448: GO 35742
35450: LD_EXP 56
35454: DOUBLE
35455: EQUAL
35456: IFTRUE 35460
35458: GO 35475
35460: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
35461: LD_EXP 56
35465: PPUSH
35466: LD_STRING DA1-Huck-1a
35468: PPUSH
35469: CALL_OW 91
35473: GO 35742
35475: LD_EXP 48
35479: DOUBLE
35480: EQUAL
35481: IFTRUE 35485
35483: GO 35500
35485: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
35486: LD_EXP 48
35490: PPUSH
35491: LD_STRING DA1-Brown-1a
35493: PPUSH
35494: CALL_OW 91
35498: GO 35742
35500: LD_EXP 52
35504: DOUBLE
35505: EQUAL
35506: IFTRUE 35510
35508: GO 35525
35510: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
35511: LD_EXP 52
35515: PPUSH
35516: LD_STRING DA1-Gary-1a
35518: PPUSH
35519: CALL_OW 91
35523: GO 35742
35525: LD_EXP 55
35529: DOUBLE
35530: EQUAL
35531: IFTRUE 35535
35533: GO 35560
35535: POP
// if JMMGirl = 3 then
35536: LD_EXP 7
35540: PUSH
35541: LD_INT 3
35543: EQUAL
35544: IFFALSE 35558
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
35546: LD_EXP 55
35550: PPUSH
35551: LD_STRING DA1-Con-1a
35553: PPUSH
35554: CALL_OW 91
35558: GO 35742
35560: LD_EXP 63
35564: DOUBLE
35565: EQUAL
35566: IFTRUE 35570
35568: GO 35585
35570: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
35571: LD_EXP 63
35575: PPUSH
35576: LD_STRING DA1-Kurt-1a
35578: PPUSH
35579: CALL_OW 91
35583: GO 35742
35585: LD_EXP 54
35589: DOUBLE
35590: EQUAL
35591: IFTRUE 35595
35593: GO 35610
35595: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
35596: LD_EXP 54
35600: PPUSH
35601: LD_STRING DA1-Yam-1a
35603: PPUSH
35604: CALL_OW 91
35608: GO 35742
35610: LD_EXP 53
35614: DOUBLE
35615: EQUAL
35616: IFTRUE 35620
35618: GO 35635
35620: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
35621: LD_EXP 53
35625: PPUSH
35626: LD_STRING DA1-Frank-1a
35628: PPUSH
35629: CALL_OW 91
35633: GO 35742
35635: POP
// begin join := rand ( 0 , 1 ) ;
35636: LD_ADDR_VAR 0 3
35640: PUSH
35641: LD_INT 0
35643: PPUSH
35644: LD_INT 1
35646: PPUSH
35647: CALL_OW 12
35651: ST_TO_ADDR
// if join then
35652: LD_VAR 0 3
35656: IFFALSE 35701
// begin if GetSex ( unit ) = sex_male then
35658: LD_VAR 0 1
35662: PPUSH
35663: CALL_OW 258
35667: PUSH
35668: LD_INT 1
35670: EQUAL
35671: IFFALSE 35687
// ForceSay ( unit , DA1-Sol1-1b ) else
35673: LD_VAR 0 1
35677: PPUSH
35678: LD_STRING DA1-Sol1-1b
35680: PPUSH
35681: CALL_OW 91
35685: GO 35699
// ForceSay ( unit , DA1-FSol1-1b ) ;
35687: LD_VAR 0 1
35691: PPUSH
35692: LD_STRING DA1-FSol1-1b
35694: PPUSH
35695: CALL_OW 91
// end else
35699: GO 35742
// begin if GetSex ( unit ) = sex_male then
35701: LD_VAR 0 1
35705: PPUSH
35706: CALL_OW 258
35710: PUSH
35711: LD_INT 1
35713: EQUAL
35714: IFFALSE 35730
// ForceSay ( unit , DA1-Sol1-1a ) else
35716: LD_VAR 0 1
35720: PPUSH
35721: LD_STRING DA1-Sol1-1a
35723: PPUSH
35724: CALL_OW 91
35728: GO 35742
// ForceSay ( unit , DA1-FSol1-1a ) ;
35730: LD_VAR 0 1
35734: PPUSH
35735: LD_STRING DA1-FSol1-1a
35737: PPUSH
35738: CALL_OW 91
// end ; end ; end ; if unit = JMM then
35742: LD_VAR 0 1
35746: PUSH
35747: LD_EXP 40
35751: EQUAL
35752: IFFALSE 35763
// begin YouLost ( JMMCaptured ) ;
35754: LD_STRING JMMCaptured
35756: PPUSH
35757: CALL_OW 104
// exit ;
35761: GO 36061
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
35763: LD_VAR 0 1
35767: PUSH
35768: LD_EXP 44
35772: PUSH
35773: LD_EXP 47
35777: PUSH
35778: LD_EXP 45
35782: PUSH
35783: LD_EXP 42
35787: PUSH
35788: LD_EXP 56
35792: PUSH
35793: LD_EXP 48
35797: PUSH
35798: LD_EXP 54
35802: PUSH
35803: EMPTY
35804: LIST
35805: LIST
35806: LIST
35807: LIST
35808: LIST
35809: LIST
35810: LIST
35811: IN
35812: PUSH
35813: LD_VAR 0 3
35817: OR
35818: IFFALSE 35917
// begin Say ( Roth , DA-Roth-3 ) ;
35820: LD_EXP 78
35824: PPUSH
35825: LD_STRING DA-Roth-3
35827: PPUSH
35828: CALL_OW 88
// SetSide ( unit , 7 ) ;
35832: LD_VAR 0 1
35836: PPUSH
35837: LD_INT 7
35839: PPUSH
35840: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
35844: LD_ADDR_EXP 101
35848: PUSH
35849: LD_EXP 101
35853: PPUSH
35854: LD_INT 1
35856: PPUSH
35857: LD_EXP 101
35861: PUSH
35862: LD_INT 1
35864: ARRAY
35865: PUSH
35866: LD_VAR 0 1
35870: ADD
35871: PPUSH
35872: CALL_OW 1
35876: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
35877: LD_INT 260
35879: PPUSH
35880: LD_INT 235
35882: PPUSH
35883: LD_INT 1
35885: PPUSH
35886: CALL_OW 331
// SetLives ( unit , 1000 ) ;
35890: LD_VAR 0 1
35894: PPUSH
35895: LD_INT 1000
35897: PPUSH
35898: CALL_OW 234
// DialogueOff ;
35902: CALL_OW 7
// ComFree ( unit ) ;
35906: LD_VAR 0 1
35910: PPUSH
35911: CALL_OW 139
// end else
35915: GO 35998
// begin Say ( Roth , DA-Roth-3a ) ;
35917: LD_EXP 78
35921: PPUSH
35922: LD_STRING DA-Roth-3a
35924: PPUSH
35925: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
35929: LD_ADDR_EXP 35
35933: PUSH
35934: LD_EXP 35
35938: PUSH
35939: LD_VAR 0 1
35943: ADD
35944: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
35945: LD_INT 260
35947: PPUSH
35948: LD_INT 235
35950: PPUSH
35951: LD_INT 1
35953: PPUSH
35954: CALL_OW 331
// SetLives ( unit , 1000 ) ;
35958: LD_VAR 0 1
35962: PPUSH
35963: LD_INT 1000
35965: PPUSH
35966: CALL_OW 234
// DialogueOff ;
35970: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
35974: LD_VAR 0 1
35978: PPUSH
35979: LD_INT 272
35981: PPUSH
35982: LD_INT 254
35984: PPUSH
35985: CALL_OW 111
// AddComHold ( unit ) ;
35989: LD_VAR 0 1
35993: PPUSH
35994: CALL_OW 200
// end ; if capturedUnit = 1 then
35998: LD_EXP 34
36002: PUSH
36003: LD_INT 1
36005: EQUAL
36006: IFFALSE 36061
// begin DialogueOn ;
36008: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
36012: LD_EXP 40
36016: PPUSH
36017: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
36021: LD_EXP 40
36025: PPUSH
36026: LD_STRING DAa-JMM-1
36028: PPUSH
36029: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
36033: LD_EXP 40
36037: PPUSH
36038: LD_STRING DAa-JMM-1a
36040: PPUSH
36041: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
36045: LD_EXP 40
36049: PPUSH
36050: LD_STRING DAa-JMM-1b
36052: PPUSH
36053: CALL_OW 88
// DialogueOff ;
36057: CALL_OW 7
// end ; end ;
36061: LD_VAR 0 2
36065: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
36066: LD_EXP 15
36070: PUSH
36071: LD_INT 13
36073: GREATEREQUAL
36074: PUSH
36075: LD_INT 22
36077: PUSH
36078: LD_INT 2
36080: PUSH
36081: EMPTY
36082: LIST
36083: LIST
36084: PUSH
36085: LD_INT 21
36087: PUSH
36088: LD_INT 1
36090: PUSH
36091: EMPTY
36092: LIST
36093: LIST
36094: PUSH
36095: EMPTY
36096: LIST
36097: LIST
36098: PPUSH
36099: CALL_OW 69
36103: PUSH
36104: LD_INT 0
36106: EQUAL
36107: AND
36108: PUSH
36109: LD_INT 22
36111: PUSH
36112: LD_INT 2
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: LD_INT 33
36121: PUSH
36122: LD_INT 5
36124: PUSH
36125: EMPTY
36126: LIST
36127: LIST
36128: PUSH
36129: LD_INT 21
36131: PUSH
36132: LD_INT 2
36134: PUSH
36135: EMPTY
36136: LIST
36137: LIST
36138: PUSH
36139: LD_INT 50
36141: PUSH
36142: EMPTY
36143: LIST
36144: PUSH
36145: EMPTY
36146: LIST
36147: LIST
36148: LIST
36149: LIST
36150: PPUSH
36151: CALL_OW 69
36155: PUSH
36156: LD_INT 0
36158: EQUAL
36159: AND
36160: PUSH
36161: LD_EXP 21
36165: AND
36166: PUSH
36167: LD_EXP 22
36171: AND
36172: PUSH
36173: LD_EXP 23
36177: AND
36178: IFFALSE 36947
36180: GO 36182
36182: DISABLE
36183: LD_INT 0
36185: PPUSH
36186: PPUSH
36187: PPUSH
// begin wait ( 0 0$05 ) ;
36188: LD_INT 175
36190: PPUSH
36191: CALL_OW 67
// if Count ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 2 then
36195: LD_INT 22
36197: PUSH
36198: LD_INT 1
36200: PUSH
36201: EMPTY
36202: LIST
36203: LIST
36204: PUSH
36205: LD_INT 21
36207: PUSH
36208: LD_INT 1
36210: PUSH
36211: EMPTY
36212: LIST
36213: LIST
36214: PUSH
36215: LD_INT 23
36217: PUSH
36218: LD_INT 1
36220: PUSH
36221: EMPTY
36222: LIST
36223: LIST
36224: PUSH
36225: LD_INT 50
36227: PUSH
36228: EMPTY
36229: LIST
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: LIST
36235: LIST
36236: PPUSH
36237: CALL_OW 69
36241: PPUSH
36242: CALL 71546 0 1
36246: PUSH
36247: LD_INT 2
36249: LESS
36250: IFFALSE 36261
// begin YouLost ( LostVictory ) ;
36252: LD_STRING LostVictory
36254: PPUSH
36255: CALL_OW 104
// exit ;
36259: GO 36947
// end ; m1 := false ;
36261: LD_ADDR_VAR 0 1
36265: PUSH
36266: LD_INT 0
36268: ST_TO_ADDR
// m2 := false ;
36269: LD_ADDR_VAR 0 2
36273: PUSH
36274: LD_INT 0
36276: ST_TO_ADDR
// m3 := false ;
36277: LD_ADDR_VAR 0 3
36281: PUSH
36282: LD_INT 0
36284: ST_TO_ADDR
// if not bombExploded then
36285: LD_EXP 37
36289: NOT
36290: IFFALSE 36299
// SetAchievement ( ACH_SIBROCKET ) ;
36292: LD_STRING ACH_SIBROCKET
36294: PPUSH
36295: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
36299: LD_EXP 65
36303: PPUSH
36304: CALL_OW 255
36308: PUSH
36309: LD_INT 1
36311: EQUAL
36312: PUSH
36313: LD_EXP 65
36317: PPUSH
36318: CALL_OW 302
36322: AND
36323: IFFALSE 36339
// begin wait ( 3 ) ;
36325: LD_INT 3
36327: PPUSH
36328: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
36332: LD_STRING ACH_OPO
36334: PPUSH
36335: CALL_OW 543
// end ; if tick <= 120 120$00 then
36339: LD_OWVAR 1
36343: PUSH
36344: LD_INT 252000
36346: LESSEQUAL
36347: IFFALSE 36363
// begin wait ( 3 ) ;
36349: LD_INT 3
36351: PPUSH
36352: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
36356: LD_STRING ACH_ASPEED_15
36358: PPUSH
36359: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
36363: LD_EXP 40
36367: PPUSH
36368: CALL_OW 87
// music_class := 5 ;
36372: LD_ADDR_OWVAR 72
36376: PUSH
36377: LD_INT 5
36379: ST_TO_ADDR
// music_nat := 5 ;
36380: LD_ADDR_OWVAR 71
36384: PUSH
36385: LD_INT 5
36387: ST_TO_ADDR
// DialogueOn ;
36388: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
36392: LD_EXP 40
36396: PPUSH
36397: LD_STRING D20-JMM-1
36399: PPUSH
36400: CALL_OW 88
// if IsOK ( Joan ) then
36404: LD_EXP 41
36408: PPUSH
36409: CALL_OW 302
36413: IFFALSE 36427
// Say ( Joan , D20-Joan-1 ) ;
36415: LD_EXP 41
36419: PPUSH
36420: LD_STRING D20-Joan-1
36422: PPUSH
36423: CALL_OW 88
// if IsOk ( Lisa ) then
36427: LD_EXP 43
36431: PPUSH
36432: CALL_OW 302
36436: IFFALSE 36450
// Say ( Lisa , D20-Lisa-1 ) ;
36438: LD_EXP 43
36442: PPUSH
36443: LD_STRING D20-Lisa-1
36445: PPUSH
36446: CALL_OW 88
// if IsOk ( Donaldson ) then
36450: LD_EXP 44
36454: PPUSH
36455: CALL_OW 302
36459: IFFALSE 36473
// Say ( Donaldson , D20-Don-1 ) ;
36461: LD_EXP 44
36465: PPUSH
36466: LD_STRING D20-Don-1
36468: PPUSH
36469: CALL_OW 88
// if IsOK ( Cornel ) then
36473: LD_EXP 51
36477: PPUSH
36478: CALL_OW 302
36482: IFFALSE 36496
// Say ( Cornel , D20-Corn-1 ) ;
36484: LD_EXP 51
36488: PPUSH
36489: LD_STRING D20-Corn-1
36491: PPUSH
36492: CALL_OW 88
// if IsOk ( Denis ) then
36496: LD_EXP 47
36500: PPUSH
36501: CALL_OW 302
36505: IFFALSE 36519
// Say ( Denis , D20-Den-1 ) ;
36507: LD_EXP 47
36511: PPUSH
36512: LD_STRING D20-Den-1
36514: PPUSH
36515: CALL_OW 88
// if IsOk ( Bobby ) then
36519: LD_EXP 45
36523: PPUSH
36524: CALL_OW 302
36528: IFFALSE 36542
// Say ( Bobby , D20-Bobby-1 ) ;
36530: LD_EXP 45
36534: PPUSH
36535: LD_STRING D20-Bobby-1
36537: PPUSH
36538: CALL_OW 88
// if IsOk ( Gladstone ) then
36542: LD_EXP 49
36546: PPUSH
36547: CALL_OW 302
36551: IFFALSE 36565
// Say ( Gladstone , D20-Glad-1 ) ;
36553: LD_EXP 49
36557: PPUSH
36558: LD_STRING D20-Glad-1
36560: PPUSH
36561: CALL_OW 88
// if IsOk ( Cyrus ) then
36565: LD_EXP 46
36569: PPUSH
36570: CALL_OW 302
36574: IFFALSE 36588
// Say ( Cyrus , D20-Cyrus-1 ) ;
36576: LD_EXP 46
36580: PPUSH
36581: LD_STRING D20-Cyrus-1
36583: PPUSH
36584: CALL_OW 88
// if IsOk ( Stevens ) then
36588: LD_EXP 42
36592: PPUSH
36593: CALL_OW 302
36597: IFFALSE 36611
// Say ( Stevens , D20-Huck-1 ) ;
36599: LD_EXP 42
36603: PPUSH
36604: LD_STRING D20-Huck-1
36606: PPUSH
36607: CALL_OW 88
// if IsOk ( Brown ) then
36611: LD_EXP 48
36615: PPUSH
36616: CALL_OW 302
36620: IFFALSE 36634
// Say ( Brown , D20-Brown-1 ) ;
36622: LD_EXP 48
36626: PPUSH
36627: LD_STRING D20-Brown-1
36629: PPUSH
36630: CALL_OW 88
// if IsOk ( Gary ) then
36634: LD_EXP 52
36638: PPUSH
36639: CALL_OW 302
36643: IFFALSE 36657
// Say ( Gary , D20-Gary-1 ) ;
36645: LD_EXP 52
36649: PPUSH
36650: LD_STRING D20-Gary-1
36652: PPUSH
36653: CALL_OW 88
// if IsOk ( Connie ) then
36657: LD_EXP 55
36661: PPUSH
36662: CALL_OW 302
36666: IFFALSE 36680
// Say ( Connie , D20-Con-1 ) ;
36668: LD_EXP 55
36672: PPUSH
36673: LD_STRING D20-Con-1
36675: PPUSH
36676: CALL_OW 88
// if IsOk ( Kurt ) then
36680: LD_EXP 63
36684: PPUSH
36685: CALL_OW 302
36689: IFFALSE 36703
// Say ( Kurt , D20-Kurt-1 ) ;
36691: LD_EXP 63
36695: PPUSH
36696: LD_STRING D20-Kurt-1
36698: PPUSH
36699: CALL_OW 88
// if IsOk ( Kikuchi ) then
36703: LD_EXP 54
36707: PPUSH
36708: CALL_OW 302
36712: IFFALSE 36726
// Say ( Kikuchi , D20-Yam-1 ) ;
36714: LD_EXP 54
36718: PPUSH
36719: LD_STRING D20-Yam-1
36721: PPUSH
36722: CALL_OW 88
// if IsOk ( Frank ) then
36726: LD_EXP 53
36730: PPUSH
36731: CALL_OW 302
36735: IFFALSE 36749
// Say ( Frank , D20-Frank-1 ) ;
36737: LD_EXP 53
36741: PPUSH
36742: LD_STRING D20-Frank-1
36744: PPUSH
36745: CALL_OW 88
// DialogueOff ;
36749: CALL_OW 7
// if RothCaptured then
36753: LD_EXP 33
36757: IFFALSE 36779
// begin m1 := true ;
36759: LD_ADDR_VAR 0 1
36763: PUSH
36764: LD_INT 1
36766: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
36767: LD_STRING Roth
36769: PPUSH
36770: LD_INT 1
36772: PPUSH
36773: CALL_OW 101
// end else
36777: GO 36790
// AddMedal ( Roth , - 1 ) ;
36779: LD_STRING Roth
36781: PPUSH
36782: LD_INT 1
36784: NEG
36785: PPUSH
36786: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish or not behemothDone then
36790: LD_EXP 25
36794: NOT
36795: PUSH
36796: LD_EXP 27
36800: OR
36801: PUSH
36802: LD_EXP 28
36806: NOT
36807: OR
36808: IFFALSE 36830
// begin m2 := true ;
36810: LD_ADDR_VAR 0 2
36814: PUSH
36815: LD_INT 1
36817: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
36818: LD_STRING Project
36820: PPUSH
36821: LD_INT 1
36823: PPUSH
36824: CALL_OW 101
// end else
36828: GO 36841
// AddMedal ( Project , - 1 ) ;
36830: LD_STRING Project
36832: PPUSH
36833: LD_INT 1
36835: NEG
36836: PPUSH
36837: CALL_OW 101
// if lostCounter = 0 then
36841: LD_EXP 32
36845: PUSH
36846: LD_INT 0
36848: EQUAL
36849: IFFALSE 36871
// begin m3 := true ;
36851: LD_ADDR_VAR 0 3
36855: PUSH
36856: LD_INT 1
36858: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
36859: LD_STRING NoLosses
36861: PPUSH
36862: LD_INT 1
36864: PPUSH
36865: CALL_OW 101
// end else
36869: GO 36882
// AddMedal ( NoLosses , - 1 ) ;
36871: LD_STRING NoLosses
36873: PPUSH
36874: LD_INT 1
36876: NEG
36877: PPUSH
36878: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
36882: LD_VAR 0 1
36886: PUSH
36887: LD_VAR 0 2
36891: AND
36892: PUSH
36893: LD_VAR 0 3
36897: AND
36898: PUSH
36899: LD_OWVAR 67
36903: PUSH
36904: LD_INT 3
36906: GREATEREQUAL
36907: AND
36908: IFFALSE 36920
// SetAchievementEX ( ACH_AMER , 15 ) ;
36910: LD_STRING ACH_AMER
36912: PPUSH
36913: LD_INT 15
36915: PPUSH
36916: CALL_OW 564
// GiveMedals ( MAIN ) ;
36920: LD_STRING MAIN
36922: PPUSH
36923: CALL_OW 102
// music_class := 4 ;
36927: LD_ADDR_OWVAR 72
36931: PUSH
36932: LD_INT 4
36934: ST_TO_ADDR
// music_nat := 1 ;
36935: LD_ADDR_OWVAR 71
36939: PUSH
36940: LD_INT 1
36942: ST_TO_ADDR
// YouWin ;
36943: CALL_OW 103
// end ; end_of_file
36947: PPOPN 3
36949: END
// export function CustomEvent ( event ) ; begin
36950: LD_INT 0
36952: PPUSH
// end ;
36953: LD_VAR 0 2
36957: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
36958: LD_VAR 0 1
36962: PUSH
36963: LD_INT 1
36965: EQUAL
36966: PUSH
36967: LD_VAR 0 2
36971: PUSH
36972: LD_INT 4
36974: EQUAL
36975: AND
36976: PUSH
36977: LD_EXP 60
36981: PPUSH
36982: CALL_OW 300
36986: AND
36987: IFFALSE 37003
// begin wait ( 0 0$2 ) ;
36989: LD_INT 70
36991: PPUSH
36992: CALL_OW 67
// YouLost ( Dismissed ) ;
36996: LD_STRING Dismissed
36998: PPUSH
36999: CALL_OW 104
// end ; end ;
37003: PPOPN 2
37005: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
37006: LD_VAR 0 2
37010: PPUSH
37011: LD_VAR 0 3
37015: PPUSH
37016: LD_INT 18
37018: PPUSH
37019: CALL_OW 309
37023: IFFALSE 37032
// YouLost ( Motherlode3 ) ;
37025: LD_STRING Motherlode3
37027: PPUSH
37028: CALL_OW 104
// end ;
37032: PPOPN 3
37034: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
37035: LD_EXP 27
37039: NOT
37040: IFFALSE 37050
// behemothDone := true ;
37042: LD_ADDR_EXP 28
37046: PUSH
37047: LD_INT 1
37049: ST_TO_ADDR
// end ;
37050: PPOPN 1
37052: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
37053: LD_VAR 0 1
37057: PPUSH
37058: CALL_OW 255
37062: PUSH
37063: LD_INT 1
37065: EQUAL
37066: IFFALSE 37076
// bombExploded := true ;
37068: LD_ADDR_EXP 37
37072: PUSH
37073: LD_INT 1
37075: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
37076: LD_VAR 0 1
37080: PPUSH
37081: CALL_OW 255
37085: PUSH
37086: LD_INT 3
37088: EQUAL
37089: IFFALSE 37119
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
37091: LD_INT 2
37093: PPUSH
37094: LD_INT 23
37096: PUSH
37097: LD_INT 3
37099: PUSH
37100: LD_INT 3
37102: PUSH
37103: LD_INT 48
37105: PUSH
37106: EMPTY
37107: LIST
37108: LIST
37109: LIST
37110: LIST
37111: PUSH
37112: EMPTY
37113: LIST
37114: PPUSH
37115: CALL 63018 0 2
// if GetSide ( unit ) = 1 and GetSide ( Friend ) = 1 and IsOk ( Friend ) and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
37119: LD_VAR 0 1
37123: PPUSH
37124: CALL_OW 255
37128: PUSH
37129: LD_INT 1
37131: EQUAL
37132: PUSH
37133: LD_EXP 65
37137: PPUSH
37138: CALL_OW 255
37142: PUSH
37143: LD_INT 1
37145: EQUAL
37146: AND
37147: PUSH
37148: LD_EXP 65
37152: PPUSH
37153: CALL_OW 302
37157: AND
37158: PUSH
37159: LD_EXP 30
37163: AND
37164: PUSH
37165: LD_INT 22
37167: PUSH
37168: LD_INT 3
37170: PUSH
37171: EMPTY
37172: LIST
37173: LIST
37174: PUSH
37175: LD_INT 34
37177: PUSH
37178: LD_INT 48
37180: PUSH
37181: EMPTY
37182: LIST
37183: LIST
37184: PUSH
37185: EMPTY
37186: LIST
37187: LIST
37188: PPUSH
37189: CALL_OW 69
37193: AND
37194: PUSH
37195: LD_INT 22
37197: PUSH
37198: LD_INT 1
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PUSH
37205: LD_INT 34
37207: PUSH
37208: LD_INT 8
37210: PUSH
37211: EMPTY
37212: LIST
37213: LIST
37214: PUSH
37215: EMPTY
37216: LIST
37217: LIST
37218: PPUSH
37219: CALL_OW 69
37223: NOT
37224: AND
37225: IFFALSE 37277
// begin wait ( 0 0$5 ) ;
37227: LD_INT 175
37229: PPUSH
37230: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
37234: LD_INT 22
37236: PUSH
37237: LD_INT 3
37239: PUSH
37240: EMPTY
37241: LIST
37242: LIST
37243: PUSH
37244: LD_INT 34
37246: PUSH
37247: LD_INT 48
37249: PUSH
37250: EMPTY
37251: LIST
37252: LIST
37253: PUSH
37254: EMPTY
37255: LIST
37256: LIST
37257: PPUSH
37258: CALL_OW 69
37262: PUSH
37263: LD_INT 1
37265: ARRAY
37266: PPUSH
37267: LD_INT 60
37269: PPUSH
37270: LD_INT 95
37272: PPUSH
37273: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
37277: LD_VAR 0 2
37281: PPUSH
37282: LD_VAR 0 3
37286: PPUSH
37287: LD_INT 18
37289: PPUSH
37290: CALL_OW 309
37294: PUSH
37295: LD_VAR 0 2
37299: PPUSH
37300: LD_VAR 0 3
37304: PPUSH
37305: LD_INT 18
37307: PPUSH
37308: CALL 110944 0 3
37312: OR
37313: IFFALSE 37360
// begin if GetSide ( unit ) = 1 then
37315: LD_VAR 0 1
37319: PPUSH
37320: CALL_OW 255
37324: PUSH
37325: LD_INT 1
37327: EQUAL
37328: IFFALSE 37346
// begin wait ( 0 0$6 ) ;
37330: LD_INT 210
37332: PPUSH
37333: CALL_OW 67
// YouLost ( Motherlode2 ) ;
37337: LD_STRING Motherlode2
37339: PPUSH
37340: CALL_OW 104
// end else
37344: GO 37360
// begin wait ( 0 0$6 ) ;
37346: LD_INT 210
37348: PPUSH
37349: CALL_OW 67
// YouLost ( Motherlode1 ) ;
37353: LD_STRING Motherlode1
37355: PPUSH
37356: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
37360: LD_VAR 0 1
37364: PPUSH
37365: CALL_OW 255
37369: PUSH
37370: LD_INT 3
37372: EQUAL
37373: IFFALSE 37394
// begin wait ( 0 0$5 ) ;
37375: LD_INT 175
37377: PPUSH
37378: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
37382: LD_EXP 67
37386: PPUSH
37387: LD_STRING D18-Pla-1
37389: PPUSH
37390: CALL_OW 94
// end ; end ;
37394: PPOPN 3
37396: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
37397: LD_VAR 0 1
37401: PPUSH
37402: CALL 127872 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
37406: LD_VAR 0 1
37410: PUSH
37411: LD_INT 22
37413: PUSH
37414: LD_INT 1
37416: PUSH
37417: EMPTY
37418: LIST
37419: LIST
37420: PUSH
37421: LD_INT 21
37423: PUSH
37424: LD_INT 1
37426: PUSH
37427: EMPTY
37428: LIST
37429: LIST
37430: PUSH
37431: LD_INT 23
37433: PUSH
37434: LD_INT 1
37436: PUSH
37437: EMPTY
37438: LIST
37439: LIST
37440: PUSH
37441: EMPTY
37442: LIST
37443: LIST
37444: LIST
37445: PPUSH
37446: CALL_OW 69
37450: IN
37451: IFFALSE 37467
// lostCounter := lostCounter + 1 ;
37453: LD_ADDR_EXP 32
37457: PUSH
37458: LD_EXP 32
37462: PUSH
37463: LD_INT 1
37465: PLUS
37466: ST_TO_ADDR
// if un in behemothBuilders then
37467: LD_VAR 0 1
37471: PUSH
37472: LD_EXP 76
37476: IN
37477: IFFALSE 37497
// begin behemothBuilders := behemothBuilders diff un ;
37479: LD_ADDR_EXP 76
37483: PUSH
37484: LD_EXP 76
37488: PUSH
37489: LD_VAR 0 1
37493: DIFF
37494: ST_TO_ADDR
// exit ;
37495: GO 37527
// end ; if un = JMM then
37497: LD_VAR 0 1
37501: PUSH
37502: LD_EXP 40
37506: EQUAL
37507: IFFALSE 37518
// begin YouLost ( JMM ) ;
37509: LD_STRING JMM
37511: PPUSH
37512: CALL_OW 104
// exit ;
37516: GO 37527
// end ; MCE_UnitDestroyed ( un ) ;
37518: LD_VAR 0 1
37522: PPUSH
37523: CALL 66460 0 1
// end ;
37527: PPOPN 1
37529: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
37530: LD_VAR 0 1
37534: PPUSH
37535: LD_VAR 0 2
37539: PPUSH
37540: CALL 68792 0 2
// end ;
37544: PPOPN 2
37546: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
37547: LD_VAR 0 1
37551: PPUSH
37552: CALL 67860 0 1
// end ;
37556: PPOPN 1
37558: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
37559: LD_VAR 0 1
37563: PUSH
37564: LD_INT 22
37566: PUSH
37567: LD_INT 8
37569: PUSH
37570: EMPTY
37571: LIST
37572: LIST
37573: PUSH
37574: LD_INT 30
37576: PUSH
37577: LD_INT 2
37579: PUSH
37580: EMPTY
37581: LIST
37582: LIST
37583: PUSH
37584: LD_INT 23
37586: PUSH
37587: LD_INT 3
37589: PUSH
37590: EMPTY
37591: LIST
37592: LIST
37593: PUSH
37594: EMPTY
37595: LIST
37596: LIST
37597: LIST
37598: PPUSH
37599: CALL_OW 69
37603: IN
37604: IFFALSE 37631
// begin ComUpgrade ( building ) ;
37606: LD_VAR 0 1
37610: PPUSH
37611: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
37615: LD_EXP 64
37619: PPUSH
37620: LD_VAR 0 1
37624: PPUSH
37625: CALL 77644 0 2
// exit ;
37629: GO 37640
// end ; MCE_BuildingComplete ( building ) ;
37631: LD_VAR 0 1
37635: PPUSH
37636: CALL 68101 0 1
// end ;
37640: PPOPN 1
37642: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
37643: LD_VAR 0 1
37647: PPUSH
37648: LD_VAR 0 2
37652: PPUSH
37653: CALL 66156 0 2
// end ;
37657: PPOPN 2
37659: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
37660: LD_VAR 0 1
37664: PPUSH
37665: LD_VAR 0 2
37669: PPUSH
37670: LD_VAR 0 3
37674: PPUSH
37675: LD_VAR 0 4
37679: PPUSH
37680: LD_VAR 0 5
37684: PPUSH
37685: CALL 65776 0 5
// end ;
37689: PPOPN 5
37691: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
37692: LD_VAR 0 1
37696: PPUSH
37697: CALL_OW 255
37701: PUSH
37702: LD_INT 1
37704: EQUAL
37705: IFFALSE 37722
// amConstructCounter := Inc ( amConstructCounter ) ;
37707: LD_ADDR_EXP 39
37711: PUSH
37712: LD_EXP 39
37716: PPUSH
37717: CALL 108496 0 1
37721: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
37722: LD_VAR 0 1
37726: PPUSH
37727: LD_VAR 0 2
37731: PPUSH
37732: CALL 127992 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
37736: LD_VAR 0 1
37740: PPUSH
37741: LD_VAR 0 2
37745: PPUSH
37746: CALL 65329 0 2
// end ;
37750: PPOPN 2
37752: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
37753: LD_VAR 0 1
37757: PPUSH
37758: LD_VAR 0 2
37762: PPUSH
37763: LD_VAR 0 3
37767: PPUSH
37768: LD_VAR 0 4
37772: PPUSH
37773: CALL 65167 0 4
// end ;
37777: PPOPN 4
37779: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
37780: LD_VAR 0 1
37784: PPUSH
37785: LD_VAR 0 2
37789: PPUSH
37790: LD_VAR 0 3
37794: PPUSH
37795: CALL 64942 0 3
// end ;
37799: PPOPN 3
37801: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
37802: LD_VAR 0 1
37806: PPUSH
37807: LD_VAR 0 2
37811: PPUSH
37812: CALL 64827 0 2
// end ;
37816: PPOPN 2
37818: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
37819: LD_VAR 0 1
37823: PPUSH
37824: LD_VAR 0 2
37828: PPUSH
37829: CALL 69087 0 2
// end ;
37833: PPOPN 2
37835: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
37836: LD_VAR 0 1
37840: PUSH
37841: LD_INT 460
37843: EQUAL
37844: IFFALSE 37866
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
37846: LD_VAR 0 2
37850: PPUSH
37851: LD_INT 227
37853: PPUSH
37854: LD_INT 136
37856: PPUSH
37857: CALL_OW 428
37861: PPUSH
37862: CALL_OW 120
// end ;
37866: PPOPN 2
37868: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
37869: LD_VAR 0 1
37873: PPUSH
37874: CALL_OW 255
37878: PUSH
37879: LD_INT 4
37881: EQUAL
37882: PUSH
37883: LD_VAR 0 1
37887: PUSH
37888: LD_EXP 18
37892: PUSH
37893: LD_INT 1
37895: ARRAY
37896: IN
37897: AND
37898: PUSH
37899: LD_EXP 19
37903: AND
37904: IFFALSE 37923
// begin ComMoveXY ( driver , 61 , 93 ) ;
37906: LD_VAR 0 1
37910: PPUSH
37911: LD_INT 61
37913: PPUSH
37914: LD_INT 93
37916: PPUSH
37917: CALL_OW 111
// exit ;
37921: GO 37992
// end ; if GetSide ( driver ) = 3 and GetTag ( driver ) = 105 then
37923: LD_VAR 0 1
37927: PPUSH
37928: CALL_OW 255
37932: PUSH
37933: LD_INT 3
37935: EQUAL
37936: PUSH
37937: LD_VAR 0 1
37941: PPUSH
37942: CALL_OW 110
37946: PUSH
37947: LD_INT 105
37949: EQUAL
37950: AND
37951: IFFALSE 37968
// begin ComMoveXY ( driver , 187 , 92 ) ;
37953: LD_VAR 0 1
37957: PPUSH
37958: LD_INT 187
37960: PPUSH
37961: LD_INT 92
37963: PPUSH
37964: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
37968: LD_VAR 0 1
37972: PPUSH
37973: LD_VAR 0 2
37977: PPUSH
37978: LD_VAR 0 3
37982: PPUSH
37983: LD_VAR 0 4
37987: PPUSH
37988: CALL 69303 0 4
// end ;
37992: PPOPN 4
37994: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
37995: LD_VAR 0 1
37999: PPUSH
38000: LD_VAR 0 2
38004: PPUSH
38005: CALL 64636 0 2
// end ;
38009: PPOPN 2
38011: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
38012: LD_VAR 0 1
38016: PPUSH
38017: CALL 127976 0 1
// end ; end_of_file
38021: PPOPN 1
38023: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
38024: LD_EXP 15
38028: PUSH
38029: LD_INT 2
38031: EQUAL
38032: IFFALSE 38549
38034: GO 38036
38036: DISABLE
38037: LD_INT 0
38039: PPUSH
38040: PPUSH
// begin time := 0 0$35 ;
38041: LD_ADDR_VAR 0 2
38045: PUSH
38046: LD_INT 1225
38048: ST_TO_ADDR
// repeat wait ( time ) ;
38049: LD_VAR 0 2
38053: PPUSH
38054: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
38058: LD_INT 1
38060: PPUSH
38061: LD_INT 5
38063: PPUSH
38064: CALL_OW 12
38068: PPUSH
38069: LD_INT 106
38071: PPUSH
38072: LD_INT 150
38074: PPUSH
38075: LD_INT 19
38077: PPUSH
38078: LD_INT 1
38080: PPUSH
38081: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
38085: LD_INT 455
38087: PPUSH
38088: LD_INT 770
38090: PPUSH
38091: CALL_OW 12
38095: PPUSH
38096: CALL_OW 67
// if Prob ( 50 ) then
38100: LD_INT 50
38102: PPUSH
38103: CALL_OW 13
38107: IFFALSE 38136
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
38109: LD_INT 1
38111: PPUSH
38112: LD_INT 5
38114: PPUSH
38115: CALL_OW 12
38119: PPUSH
38120: LD_INT 62
38122: PPUSH
38123: LD_INT 108
38125: PPUSH
38126: LD_INT 10
38128: PPUSH
38129: LD_INT 1
38131: PPUSH
38132: CALL_OW 56
// until missionStage > 4 ;
38136: LD_EXP 15
38140: PUSH
38141: LD_INT 4
38143: GREATER
38144: IFFALSE 38049
// repeat wait ( 0 0$1 ) ;
38146: LD_INT 35
38148: PPUSH
38149: CALL_OW 67
// until missionStage = 6 ;
38153: LD_EXP 15
38157: PUSH
38158: LD_INT 6
38160: EQUAL
38161: IFFALSE 38146
// time := 0 0$20 ;
38163: LD_ADDR_VAR 0 2
38167: PUSH
38168: LD_INT 700
38170: ST_TO_ADDR
// repeat wait ( time ) ;
38171: LD_VAR 0 2
38175: PPUSH
38176: CALL_OW 67
// if Prob ( 90 ) then
38180: LD_INT 90
38182: PPUSH
38183: CALL_OW 13
38187: IFFALSE 38230
// begin time := time + 0 0$2 ;
38189: LD_ADDR_VAR 0 2
38193: PUSH
38194: LD_VAR 0 2
38198: PUSH
38199: LD_INT 70
38201: PLUS
38202: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
38203: LD_INT 1
38205: PPUSH
38206: LD_INT 5
38208: PPUSH
38209: CALL_OW 12
38213: PPUSH
38214: LD_INT 106
38216: PPUSH
38217: LD_INT 89
38219: PPUSH
38220: LD_INT 45
38222: PPUSH
38223: LD_INT 1
38225: PPUSH
38226: CALL_OW 56
// end ; if Prob ( 45 ) then
38230: LD_INT 45
38232: PPUSH
38233: CALL_OW 13
38237: IFFALSE 38293
// begin for i := 1 to 4 do
38239: LD_ADDR_VAR 0 1
38243: PUSH
38244: DOUBLE
38245: LD_INT 1
38247: DEC
38248: ST_TO_ADDR
38249: LD_INT 4
38251: PUSH
38252: FOR_TO
38253: IFFALSE 38291
// begin wait ( 0 0$5 ) ;
38255: LD_INT 175
38257: PPUSH
38258: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
38262: LD_INT 1
38264: PPUSH
38265: LD_INT 5
38267: PPUSH
38268: CALL_OW 12
38272: PPUSH
38273: LD_INT 113
38275: PPUSH
38276: LD_INT 117
38278: PPUSH
38279: LD_INT 25
38281: PPUSH
38282: LD_INT 1
38284: PPUSH
38285: CALL_OW 56
// end ;
38289: GO 38252
38291: POP
38292: POP
// end ; if Prob ( 40 ) then
38293: LD_INT 40
38295: PPUSH
38296: CALL_OW 13
38300: IFFALSE 38346
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
38302: LD_INT 385
38304: PPUSH
38305: LD_INT 945
38307: PPUSH
38308: CALL_OW 12
38312: PPUSH
38313: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
38317: LD_INT 1
38319: PPUSH
38320: LD_INT 5
38322: PPUSH
38323: CALL_OW 12
38327: PPUSH
38328: LD_INT 21
38330: PPUSH
38331: LD_INT 26
38333: PPUSH
38334: LD_INT 12
38336: PPUSH
38337: LD_INT 1
38339: PPUSH
38340: CALL_OW 56
// end else
38344: GO 38382
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
38346: LD_INT 700
38348: PPUSH
38349: LD_INT 1225
38351: PPUSH
38352: CALL_OW 12
38356: PPUSH
38357: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
38361: LD_INT 1
38363: PPUSH
38364: LD_INT 5
38366: PPUSH
38367: CALL_OW 12
38371: PPUSH
38372: LD_INT 16
38374: PPUSH
38375: LD_INT 1
38377: PPUSH
38378: CALL_OW 55
// end ; if Prob ( 50 ) then
38382: LD_INT 50
38384: PPUSH
38385: CALL_OW 13
38389: IFFALSE 38435
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
38391: LD_INT 700
38393: PPUSH
38394: LD_INT 1050
38396: PPUSH
38397: CALL_OW 12
38401: PPUSH
38402: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
38406: LD_INT 1
38408: PPUSH
38409: LD_INT 5
38411: PPUSH
38412: CALL_OW 12
38416: PPUSH
38417: LD_INT 168
38419: PPUSH
38420: LD_INT 168
38422: PPUSH
38423: LD_INT 16
38425: PPUSH
38426: LD_INT 1
38428: PPUSH
38429: CALL_OW 56
// end else
38433: GO 38471
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
38435: LD_INT 350
38437: PPUSH
38438: LD_INT 525
38440: PPUSH
38441: CALL_OW 12
38445: PPUSH
38446: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
38450: LD_INT 1
38452: PPUSH
38453: LD_INT 5
38455: PPUSH
38456: CALL_OW 12
38460: PPUSH
38461: LD_INT 15
38463: PPUSH
38464: LD_INT 1
38466: PPUSH
38467: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
38471: LD_INT 175
38473: PPUSH
38474: LD_INT 315
38476: PPUSH
38477: CALL_OW 12
38481: PPUSH
38482: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
38486: LD_INT 1
38488: PPUSH
38489: LD_INT 5
38491: PPUSH
38492: CALL_OW 12
38496: PPUSH
38497: LD_INT 103
38499: PPUSH
38500: LD_INT 140
38502: PPUSH
38503: LD_INT 20
38505: PPUSH
38506: LD_INT 1
38508: PPUSH
38509: CALL_OW 56
// time := time + 0 0$2 ;
38513: LD_ADDR_VAR 0 2
38517: PUSH
38518: LD_VAR 0 2
38522: PUSH
38523: LD_INT 70
38525: PLUS
38526: ST_TO_ADDR
// if time > 1 1$20 then
38527: LD_VAR 0 2
38531: PUSH
38532: LD_INT 2800
38534: GREATER
38535: IFFALSE 38545
// time := 0 0$30 ;
38537: LD_ADDR_VAR 0 2
38541: PUSH
38542: LD_INT 1050
38544: ST_TO_ADDR
// until false ;
38545: LD_INT 0
38547: IFFALSE 38171
// end ; end_of_file
38549: PPOPN 2
38551: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
38552: LD_EXP 13
38556: PUSH
38557: LD_EXP 15
38561: PUSH
38562: LD_INT 6
38564: GREATEREQUAL
38565: AND
38566: IFFALSE 38603
38568: GO 38570
38570: DISABLE
// begin enable ;
38571: ENABLE
// missionTime := missionTime + 0 0$1 ;
38572: LD_ADDR_EXP 14
38576: PUSH
38577: LD_EXP 14
38581: PUSH
38582: LD_INT 35
38584: PLUS
38585: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
38586: LD_ADDR_OWVAR 47
38590: PUSH
38591: LD_STRING #Am15-1
38593: PUSH
38594: LD_EXP 14
38598: PUSH
38599: EMPTY
38600: LIST
38601: LIST
38602: ST_TO_ADDR
// end ; end_of_file
38603: END
// export function InitNature ; begin
38604: LD_INT 0
38606: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
38607: LD_INT 3
38609: PPUSH
38610: LD_INT 3
38612: PPUSH
38613: LD_INT 2
38615: PPUSH
38616: LD_INT 1
38618: PPUSH
38619: LD_INT 1
38621: PPUSH
38622: LD_INT 0
38624: PPUSH
38625: LD_INT 0
38627: PPUSH
38628: LD_INT 20
38630: PPUSH
38631: LD_INT 0
38633: PPUSH
38634: CALL 103812 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
38638: LD_INT 2
38640: PPUSH
38641: LD_INT 1
38643: PPUSH
38644: LD_INT 1
38646: PPUSH
38647: LD_INT 1
38649: PPUSH
38650: LD_INT 1
38652: PPUSH
38653: LD_INT 0
38655: PPUSH
38656: LD_INT 0
38658: PPUSH
38659: LD_INT 21
38661: PPUSH
38662: LD_INT 0
38664: PPUSH
38665: CALL 103812 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
38669: LD_INT 4
38671: PPUSH
38672: LD_INT 1
38674: PPUSH
38675: LD_INT 2
38677: PPUSH
38678: LD_INT 4
38680: PPUSH
38681: LD_INT 2
38683: PPUSH
38684: LD_INT 1
38686: PPUSH
38687: LD_INT 0
38689: PPUSH
38690: LD_INT 22
38692: PPUSH
38693: LD_INT 0
38695: PPUSH
38696: CALL 103812 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
38700: LD_INT 0
38702: PPUSH
38703: LD_INT 0
38705: PPUSH
38706: LD_INT 0
38708: PPUSH
38709: LD_INT 0
38711: PPUSH
38712: LD_INT 0
38714: PPUSH
38715: LD_INT 0
38717: PPUSH
38718: LD_INT 9
38720: PPUSH
38721: LD_INT 0
38723: PPUSH
38724: LD_INT 23
38726: PPUSH
38727: CALL 103812 0 9
// end ; end_of_file
38731: LD_VAR 0 1
38735: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
38736: LD_INT 0
38738: PPUSH
38739: PPUSH
// skirmish := false ;
38740: LD_ADDR_EXP 99
38744: PUSH
38745: LD_INT 0
38747: ST_TO_ADDR
// debug_mc := false ;
38748: LD_ADDR_EXP 100
38752: PUSH
38753: LD_INT 0
38755: ST_TO_ADDR
// mc_bases := [ ] ;
38756: LD_ADDR_EXP 101
38760: PUSH
38761: EMPTY
38762: ST_TO_ADDR
// mc_sides := [ ] ;
38763: LD_ADDR_EXP 127
38767: PUSH
38768: EMPTY
38769: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
38770: LD_ADDR_EXP 102
38774: PUSH
38775: EMPTY
38776: ST_TO_ADDR
// mc_building_repairs := [ ] ;
38777: LD_ADDR_EXP 103
38781: PUSH
38782: EMPTY
38783: ST_TO_ADDR
// mc_need_heal := [ ] ;
38784: LD_ADDR_EXP 104
38788: PUSH
38789: EMPTY
38790: ST_TO_ADDR
// mc_healers := [ ] ;
38791: LD_ADDR_EXP 105
38795: PUSH
38796: EMPTY
38797: ST_TO_ADDR
// mc_build_list := [ ] ;
38798: LD_ADDR_EXP 106
38802: PUSH
38803: EMPTY
38804: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
38805: LD_ADDR_EXP 133
38809: PUSH
38810: EMPTY
38811: ST_TO_ADDR
// mc_builders := [ ] ;
38812: LD_ADDR_EXP 107
38816: PUSH
38817: EMPTY
38818: ST_TO_ADDR
// mc_construct_list := [ ] ;
38819: LD_ADDR_EXP 108
38823: PUSH
38824: EMPTY
38825: ST_TO_ADDR
// mc_turret_list := [ ] ;
38826: LD_ADDR_EXP 109
38830: PUSH
38831: EMPTY
38832: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
38833: LD_ADDR_EXP 110
38837: PUSH
38838: EMPTY
38839: ST_TO_ADDR
// mc_miners := [ ] ;
38840: LD_ADDR_EXP 115
38844: PUSH
38845: EMPTY
38846: ST_TO_ADDR
// mc_mines := [ ] ;
38847: LD_ADDR_EXP 114
38851: PUSH
38852: EMPTY
38853: ST_TO_ADDR
// mc_minefields := [ ] ;
38854: LD_ADDR_EXP 116
38858: PUSH
38859: EMPTY
38860: ST_TO_ADDR
// mc_crates := [ ] ;
38861: LD_ADDR_EXP 117
38865: PUSH
38866: EMPTY
38867: ST_TO_ADDR
// mc_crates_collector := [ ] ;
38868: LD_ADDR_EXP 118
38872: PUSH
38873: EMPTY
38874: ST_TO_ADDR
// mc_crates_area := [ ] ;
38875: LD_ADDR_EXP 119
38879: PUSH
38880: EMPTY
38881: ST_TO_ADDR
// mc_vehicles := [ ] ;
38882: LD_ADDR_EXP 120
38886: PUSH
38887: EMPTY
38888: ST_TO_ADDR
// mc_attack := [ ] ;
38889: LD_ADDR_EXP 121
38893: PUSH
38894: EMPTY
38895: ST_TO_ADDR
// mc_produce := [ ] ;
38896: LD_ADDR_EXP 122
38900: PUSH
38901: EMPTY
38902: ST_TO_ADDR
// mc_defender := [ ] ;
38903: LD_ADDR_EXP 123
38907: PUSH
38908: EMPTY
38909: ST_TO_ADDR
// mc_parking := [ ] ;
38910: LD_ADDR_EXP 125
38914: PUSH
38915: EMPTY
38916: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
38917: LD_ADDR_EXP 111
38921: PUSH
38922: EMPTY
38923: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
38924: LD_ADDR_EXP 113
38928: PUSH
38929: EMPTY
38930: ST_TO_ADDR
// mc_scan := [ ] ;
38931: LD_ADDR_EXP 124
38935: PUSH
38936: EMPTY
38937: ST_TO_ADDR
// mc_scan_area := [ ] ;
38938: LD_ADDR_EXP 126
38942: PUSH
38943: EMPTY
38944: ST_TO_ADDR
// mc_tech := [ ] ;
38945: LD_ADDR_EXP 128
38949: PUSH
38950: EMPTY
38951: ST_TO_ADDR
// mc_class := [ ] ;
38952: LD_ADDR_EXP 142
38956: PUSH
38957: EMPTY
38958: ST_TO_ADDR
// mc_class_case_use := [ ] ;
38959: LD_ADDR_EXP 143
38963: PUSH
38964: EMPTY
38965: ST_TO_ADDR
// mc_is_defending := [ ] ;
38966: LD_ADDR_EXP 144
38970: PUSH
38971: EMPTY
38972: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
38973: LD_ADDR_EXP 135
38977: PUSH
38978: EMPTY
38979: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
38980: LD_ADDR_EXP 145
38984: PUSH
38985: LD_INT 0
38987: ST_TO_ADDR
// end ;
38988: LD_VAR 0 1
38992: RET
// export function MC_Kill ( base ) ; begin
38993: LD_INT 0
38995: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
38996: LD_ADDR_EXP 101
39000: PUSH
39001: LD_EXP 101
39005: PPUSH
39006: LD_VAR 0 1
39010: PPUSH
39011: EMPTY
39012: PPUSH
39013: CALL_OW 1
39017: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
39018: LD_ADDR_EXP 102
39022: PUSH
39023: LD_EXP 102
39027: PPUSH
39028: LD_VAR 0 1
39032: PPUSH
39033: EMPTY
39034: PPUSH
39035: CALL_OW 1
39039: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
39040: LD_ADDR_EXP 103
39044: PUSH
39045: LD_EXP 103
39049: PPUSH
39050: LD_VAR 0 1
39054: PPUSH
39055: EMPTY
39056: PPUSH
39057: CALL_OW 1
39061: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
39062: LD_ADDR_EXP 104
39066: PUSH
39067: LD_EXP 104
39071: PPUSH
39072: LD_VAR 0 1
39076: PPUSH
39077: EMPTY
39078: PPUSH
39079: CALL_OW 1
39083: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
39084: LD_ADDR_EXP 105
39088: PUSH
39089: LD_EXP 105
39093: PPUSH
39094: LD_VAR 0 1
39098: PPUSH
39099: EMPTY
39100: PPUSH
39101: CALL_OW 1
39105: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
39106: LD_ADDR_EXP 106
39110: PUSH
39111: LD_EXP 106
39115: PPUSH
39116: LD_VAR 0 1
39120: PPUSH
39121: EMPTY
39122: PPUSH
39123: CALL_OW 1
39127: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
39128: LD_ADDR_EXP 107
39132: PUSH
39133: LD_EXP 107
39137: PPUSH
39138: LD_VAR 0 1
39142: PPUSH
39143: EMPTY
39144: PPUSH
39145: CALL_OW 1
39149: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
39150: LD_ADDR_EXP 108
39154: PUSH
39155: LD_EXP 108
39159: PPUSH
39160: LD_VAR 0 1
39164: PPUSH
39165: EMPTY
39166: PPUSH
39167: CALL_OW 1
39171: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
39172: LD_ADDR_EXP 109
39176: PUSH
39177: LD_EXP 109
39181: PPUSH
39182: LD_VAR 0 1
39186: PPUSH
39187: EMPTY
39188: PPUSH
39189: CALL_OW 1
39193: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
39194: LD_ADDR_EXP 110
39198: PUSH
39199: LD_EXP 110
39203: PPUSH
39204: LD_VAR 0 1
39208: PPUSH
39209: EMPTY
39210: PPUSH
39211: CALL_OW 1
39215: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
39216: LD_ADDR_EXP 111
39220: PUSH
39221: LD_EXP 111
39225: PPUSH
39226: LD_VAR 0 1
39230: PPUSH
39231: EMPTY
39232: PPUSH
39233: CALL_OW 1
39237: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
39238: LD_ADDR_EXP 112
39242: PUSH
39243: LD_EXP 112
39247: PPUSH
39248: LD_VAR 0 1
39252: PPUSH
39253: LD_INT 0
39255: PPUSH
39256: CALL_OW 1
39260: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
39261: LD_ADDR_EXP 113
39265: PUSH
39266: LD_EXP 113
39270: PPUSH
39271: LD_VAR 0 1
39275: PPUSH
39276: EMPTY
39277: PPUSH
39278: CALL_OW 1
39282: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
39283: LD_ADDR_EXP 114
39287: PUSH
39288: LD_EXP 114
39292: PPUSH
39293: LD_VAR 0 1
39297: PPUSH
39298: EMPTY
39299: PPUSH
39300: CALL_OW 1
39304: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
39305: LD_ADDR_EXP 115
39309: PUSH
39310: LD_EXP 115
39314: PPUSH
39315: LD_VAR 0 1
39319: PPUSH
39320: EMPTY
39321: PPUSH
39322: CALL_OW 1
39326: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
39327: LD_ADDR_EXP 116
39331: PUSH
39332: LD_EXP 116
39336: PPUSH
39337: LD_VAR 0 1
39341: PPUSH
39342: EMPTY
39343: PPUSH
39344: CALL_OW 1
39348: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
39349: LD_ADDR_EXP 117
39353: PUSH
39354: LD_EXP 117
39358: PPUSH
39359: LD_VAR 0 1
39363: PPUSH
39364: EMPTY
39365: PPUSH
39366: CALL_OW 1
39370: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
39371: LD_ADDR_EXP 118
39375: PUSH
39376: LD_EXP 118
39380: PPUSH
39381: LD_VAR 0 1
39385: PPUSH
39386: EMPTY
39387: PPUSH
39388: CALL_OW 1
39392: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
39393: LD_ADDR_EXP 119
39397: PUSH
39398: LD_EXP 119
39402: PPUSH
39403: LD_VAR 0 1
39407: PPUSH
39408: EMPTY
39409: PPUSH
39410: CALL_OW 1
39414: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
39415: LD_ADDR_EXP 120
39419: PUSH
39420: LD_EXP 120
39424: PPUSH
39425: LD_VAR 0 1
39429: PPUSH
39430: EMPTY
39431: PPUSH
39432: CALL_OW 1
39436: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
39437: LD_ADDR_EXP 121
39441: PUSH
39442: LD_EXP 121
39446: PPUSH
39447: LD_VAR 0 1
39451: PPUSH
39452: EMPTY
39453: PPUSH
39454: CALL_OW 1
39458: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
39459: LD_ADDR_EXP 122
39463: PUSH
39464: LD_EXP 122
39468: PPUSH
39469: LD_VAR 0 1
39473: PPUSH
39474: EMPTY
39475: PPUSH
39476: CALL_OW 1
39480: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
39481: LD_ADDR_EXP 123
39485: PUSH
39486: LD_EXP 123
39490: PPUSH
39491: LD_VAR 0 1
39495: PPUSH
39496: EMPTY
39497: PPUSH
39498: CALL_OW 1
39502: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
39503: LD_ADDR_EXP 124
39507: PUSH
39508: LD_EXP 124
39512: PPUSH
39513: LD_VAR 0 1
39517: PPUSH
39518: EMPTY
39519: PPUSH
39520: CALL_OW 1
39524: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
39525: LD_ADDR_EXP 125
39529: PUSH
39530: LD_EXP 125
39534: PPUSH
39535: LD_VAR 0 1
39539: PPUSH
39540: EMPTY
39541: PPUSH
39542: CALL_OW 1
39546: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
39547: LD_ADDR_EXP 126
39551: PUSH
39552: LD_EXP 126
39556: PPUSH
39557: LD_VAR 0 1
39561: PPUSH
39562: EMPTY
39563: PPUSH
39564: CALL_OW 1
39568: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
39569: LD_ADDR_EXP 128
39573: PUSH
39574: LD_EXP 128
39578: PPUSH
39579: LD_VAR 0 1
39583: PPUSH
39584: EMPTY
39585: PPUSH
39586: CALL_OW 1
39590: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
39591: LD_ADDR_EXP 130
39595: PUSH
39596: LD_EXP 130
39600: PPUSH
39601: LD_VAR 0 1
39605: PPUSH
39606: EMPTY
39607: PPUSH
39608: CALL_OW 1
39612: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
39613: LD_ADDR_EXP 131
39617: PUSH
39618: LD_EXP 131
39622: PPUSH
39623: LD_VAR 0 1
39627: PPUSH
39628: EMPTY
39629: PPUSH
39630: CALL_OW 1
39634: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
39635: LD_ADDR_EXP 132
39639: PUSH
39640: LD_EXP 132
39644: PPUSH
39645: LD_VAR 0 1
39649: PPUSH
39650: EMPTY
39651: PPUSH
39652: CALL_OW 1
39656: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
39657: LD_ADDR_EXP 133
39661: PUSH
39662: LD_EXP 133
39666: PPUSH
39667: LD_VAR 0 1
39671: PPUSH
39672: EMPTY
39673: PPUSH
39674: CALL_OW 1
39678: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
39679: LD_ADDR_EXP 134
39683: PUSH
39684: LD_EXP 134
39688: PPUSH
39689: LD_VAR 0 1
39693: PPUSH
39694: EMPTY
39695: PPUSH
39696: CALL_OW 1
39700: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
39701: LD_ADDR_EXP 135
39705: PUSH
39706: LD_EXP 135
39710: PPUSH
39711: LD_VAR 0 1
39715: PPUSH
39716: EMPTY
39717: PPUSH
39718: CALL_OW 1
39722: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
39723: LD_ADDR_EXP 136
39727: PUSH
39728: LD_EXP 136
39732: PPUSH
39733: LD_VAR 0 1
39737: PPUSH
39738: EMPTY
39739: PPUSH
39740: CALL_OW 1
39744: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
39745: LD_ADDR_EXP 137
39749: PUSH
39750: LD_EXP 137
39754: PPUSH
39755: LD_VAR 0 1
39759: PPUSH
39760: EMPTY
39761: PPUSH
39762: CALL_OW 1
39766: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
39767: LD_ADDR_EXP 138
39771: PUSH
39772: LD_EXP 138
39776: PPUSH
39777: LD_VAR 0 1
39781: PPUSH
39782: EMPTY
39783: PPUSH
39784: CALL_OW 1
39788: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
39789: LD_ADDR_EXP 139
39793: PUSH
39794: LD_EXP 139
39798: PPUSH
39799: LD_VAR 0 1
39803: PPUSH
39804: EMPTY
39805: PPUSH
39806: CALL_OW 1
39810: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
39811: LD_ADDR_EXP 140
39815: PUSH
39816: LD_EXP 140
39820: PPUSH
39821: LD_VAR 0 1
39825: PPUSH
39826: EMPTY
39827: PPUSH
39828: CALL_OW 1
39832: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
39833: LD_ADDR_EXP 141
39837: PUSH
39838: LD_EXP 141
39842: PPUSH
39843: LD_VAR 0 1
39847: PPUSH
39848: EMPTY
39849: PPUSH
39850: CALL_OW 1
39854: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
39855: LD_ADDR_EXP 142
39859: PUSH
39860: LD_EXP 142
39864: PPUSH
39865: LD_VAR 0 1
39869: PPUSH
39870: EMPTY
39871: PPUSH
39872: CALL_OW 1
39876: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
39877: LD_ADDR_EXP 143
39881: PUSH
39882: LD_EXP 143
39886: PPUSH
39887: LD_VAR 0 1
39891: PPUSH
39892: LD_INT 0
39894: PPUSH
39895: CALL_OW 1
39899: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
39900: LD_ADDR_EXP 144
39904: PUSH
39905: LD_EXP 144
39909: PPUSH
39910: LD_VAR 0 1
39914: PPUSH
39915: LD_INT 0
39917: PPUSH
39918: CALL_OW 1
39922: ST_TO_ADDR
// end ;
39923: LD_VAR 0 2
39927: RET
// export function MC_Add ( side , units ) ; var base ; begin
39928: LD_INT 0
39930: PPUSH
39931: PPUSH
// base := mc_bases + 1 ;
39932: LD_ADDR_VAR 0 4
39936: PUSH
39937: LD_EXP 101
39941: PUSH
39942: LD_INT 1
39944: PLUS
39945: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
39946: LD_ADDR_EXP 127
39950: PUSH
39951: LD_EXP 127
39955: PPUSH
39956: LD_VAR 0 4
39960: PPUSH
39961: LD_VAR 0 1
39965: PPUSH
39966: CALL_OW 1
39970: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
39971: LD_ADDR_EXP 101
39975: PUSH
39976: LD_EXP 101
39980: PPUSH
39981: LD_VAR 0 4
39985: PPUSH
39986: LD_VAR 0 2
39990: PPUSH
39991: CALL_OW 1
39995: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
39996: LD_ADDR_EXP 102
40000: PUSH
40001: LD_EXP 102
40005: PPUSH
40006: LD_VAR 0 4
40010: PPUSH
40011: EMPTY
40012: PPUSH
40013: CALL_OW 1
40017: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
40018: LD_ADDR_EXP 103
40022: PUSH
40023: LD_EXP 103
40027: PPUSH
40028: LD_VAR 0 4
40032: PPUSH
40033: EMPTY
40034: PPUSH
40035: CALL_OW 1
40039: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
40040: LD_ADDR_EXP 104
40044: PUSH
40045: LD_EXP 104
40049: PPUSH
40050: LD_VAR 0 4
40054: PPUSH
40055: EMPTY
40056: PPUSH
40057: CALL_OW 1
40061: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
40062: LD_ADDR_EXP 105
40066: PUSH
40067: LD_EXP 105
40071: PPUSH
40072: LD_VAR 0 4
40076: PPUSH
40077: EMPTY
40078: PPUSH
40079: CALL_OW 1
40083: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
40084: LD_ADDR_EXP 106
40088: PUSH
40089: LD_EXP 106
40093: PPUSH
40094: LD_VAR 0 4
40098: PPUSH
40099: EMPTY
40100: PPUSH
40101: CALL_OW 1
40105: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
40106: LD_ADDR_EXP 107
40110: PUSH
40111: LD_EXP 107
40115: PPUSH
40116: LD_VAR 0 4
40120: PPUSH
40121: EMPTY
40122: PPUSH
40123: CALL_OW 1
40127: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
40128: LD_ADDR_EXP 108
40132: PUSH
40133: LD_EXP 108
40137: PPUSH
40138: LD_VAR 0 4
40142: PPUSH
40143: EMPTY
40144: PPUSH
40145: CALL_OW 1
40149: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
40150: LD_ADDR_EXP 109
40154: PUSH
40155: LD_EXP 109
40159: PPUSH
40160: LD_VAR 0 4
40164: PPUSH
40165: EMPTY
40166: PPUSH
40167: CALL_OW 1
40171: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
40172: LD_ADDR_EXP 110
40176: PUSH
40177: LD_EXP 110
40181: PPUSH
40182: LD_VAR 0 4
40186: PPUSH
40187: EMPTY
40188: PPUSH
40189: CALL_OW 1
40193: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
40194: LD_ADDR_EXP 111
40198: PUSH
40199: LD_EXP 111
40203: PPUSH
40204: LD_VAR 0 4
40208: PPUSH
40209: EMPTY
40210: PPUSH
40211: CALL_OW 1
40215: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
40216: LD_ADDR_EXP 112
40220: PUSH
40221: LD_EXP 112
40225: PPUSH
40226: LD_VAR 0 4
40230: PPUSH
40231: LD_INT 0
40233: PPUSH
40234: CALL_OW 1
40238: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
40239: LD_ADDR_EXP 113
40243: PUSH
40244: LD_EXP 113
40248: PPUSH
40249: LD_VAR 0 4
40253: PPUSH
40254: EMPTY
40255: PPUSH
40256: CALL_OW 1
40260: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
40261: LD_ADDR_EXP 114
40265: PUSH
40266: LD_EXP 114
40270: PPUSH
40271: LD_VAR 0 4
40275: PPUSH
40276: EMPTY
40277: PPUSH
40278: CALL_OW 1
40282: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
40283: LD_ADDR_EXP 115
40287: PUSH
40288: LD_EXP 115
40292: PPUSH
40293: LD_VAR 0 4
40297: PPUSH
40298: EMPTY
40299: PPUSH
40300: CALL_OW 1
40304: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
40305: LD_ADDR_EXP 116
40309: PUSH
40310: LD_EXP 116
40314: PPUSH
40315: LD_VAR 0 4
40319: PPUSH
40320: EMPTY
40321: PPUSH
40322: CALL_OW 1
40326: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
40327: LD_ADDR_EXP 117
40331: PUSH
40332: LD_EXP 117
40336: PPUSH
40337: LD_VAR 0 4
40341: PPUSH
40342: EMPTY
40343: PPUSH
40344: CALL_OW 1
40348: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
40349: LD_ADDR_EXP 118
40353: PUSH
40354: LD_EXP 118
40358: PPUSH
40359: LD_VAR 0 4
40363: PPUSH
40364: EMPTY
40365: PPUSH
40366: CALL_OW 1
40370: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
40371: LD_ADDR_EXP 119
40375: PUSH
40376: LD_EXP 119
40380: PPUSH
40381: LD_VAR 0 4
40385: PPUSH
40386: EMPTY
40387: PPUSH
40388: CALL_OW 1
40392: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
40393: LD_ADDR_EXP 120
40397: PUSH
40398: LD_EXP 120
40402: PPUSH
40403: LD_VAR 0 4
40407: PPUSH
40408: EMPTY
40409: PPUSH
40410: CALL_OW 1
40414: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
40415: LD_ADDR_EXP 121
40419: PUSH
40420: LD_EXP 121
40424: PPUSH
40425: LD_VAR 0 4
40429: PPUSH
40430: EMPTY
40431: PPUSH
40432: CALL_OW 1
40436: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
40437: LD_ADDR_EXP 122
40441: PUSH
40442: LD_EXP 122
40446: PPUSH
40447: LD_VAR 0 4
40451: PPUSH
40452: EMPTY
40453: PPUSH
40454: CALL_OW 1
40458: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
40459: LD_ADDR_EXP 123
40463: PUSH
40464: LD_EXP 123
40468: PPUSH
40469: LD_VAR 0 4
40473: PPUSH
40474: EMPTY
40475: PPUSH
40476: CALL_OW 1
40480: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
40481: LD_ADDR_EXP 124
40485: PUSH
40486: LD_EXP 124
40490: PPUSH
40491: LD_VAR 0 4
40495: PPUSH
40496: EMPTY
40497: PPUSH
40498: CALL_OW 1
40502: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
40503: LD_ADDR_EXP 125
40507: PUSH
40508: LD_EXP 125
40512: PPUSH
40513: LD_VAR 0 4
40517: PPUSH
40518: EMPTY
40519: PPUSH
40520: CALL_OW 1
40524: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
40525: LD_ADDR_EXP 126
40529: PUSH
40530: LD_EXP 126
40534: PPUSH
40535: LD_VAR 0 4
40539: PPUSH
40540: EMPTY
40541: PPUSH
40542: CALL_OW 1
40546: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
40547: LD_ADDR_EXP 128
40551: PUSH
40552: LD_EXP 128
40556: PPUSH
40557: LD_VAR 0 4
40561: PPUSH
40562: EMPTY
40563: PPUSH
40564: CALL_OW 1
40568: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
40569: LD_ADDR_EXP 130
40573: PUSH
40574: LD_EXP 130
40578: PPUSH
40579: LD_VAR 0 4
40583: PPUSH
40584: EMPTY
40585: PPUSH
40586: CALL_OW 1
40590: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
40591: LD_ADDR_EXP 131
40595: PUSH
40596: LD_EXP 131
40600: PPUSH
40601: LD_VAR 0 4
40605: PPUSH
40606: EMPTY
40607: PPUSH
40608: CALL_OW 1
40612: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
40613: LD_ADDR_EXP 132
40617: PUSH
40618: LD_EXP 132
40622: PPUSH
40623: LD_VAR 0 4
40627: PPUSH
40628: EMPTY
40629: PPUSH
40630: CALL_OW 1
40634: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
40635: LD_ADDR_EXP 133
40639: PUSH
40640: LD_EXP 133
40644: PPUSH
40645: LD_VAR 0 4
40649: PPUSH
40650: EMPTY
40651: PPUSH
40652: CALL_OW 1
40656: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
40657: LD_ADDR_EXP 134
40661: PUSH
40662: LD_EXP 134
40666: PPUSH
40667: LD_VAR 0 4
40671: PPUSH
40672: EMPTY
40673: PPUSH
40674: CALL_OW 1
40678: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
40679: LD_ADDR_EXP 135
40683: PUSH
40684: LD_EXP 135
40688: PPUSH
40689: LD_VAR 0 4
40693: PPUSH
40694: EMPTY
40695: PPUSH
40696: CALL_OW 1
40700: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
40701: LD_ADDR_EXP 136
40705: PUSH
40706: LD_EXP 136
40710: PPUSH
40711: LD_VAR 0 4
40715: PPUSH
40716: EMPTY
40717: PPUSH
40718: CALL_OW 1
40722: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
40723: LD_ADDR_EXP 137
40727: PUSH
40728: LD_EXP 137
40732: PPUSH
40733: LD_VAR 0 4
40737: PPUSH
40738: EMPTY
40739: PPUSH
40740: CALL_OW 1
40744: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
40745: LD_ADDR_EXP 138
40749: PUSH
40750: LD_EXP 138
40754: PPUSH
40755: LD_VAR 0 4
40759: PPUSH
40760: EMPTY
40761: PPUSH
40762: CALL_OW 1
40766: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
40767: LD_ADDR_EXP 139
40771: PUSH
40772: LD_EXP 139
40776: PPUSH
40777: LD_VAR 0 4
40781: PPUSH
40782: EMPTY
40783: PPUSH
40784: CALL_OW 1
40788: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
40789: LD_ADDR_EXP 140
40793: PUSH
40794: LD_EXP 140
40798: PPUSH
40799: LD_VAR 0 4
40803: PPUSH
40804: EMPTY
40805: PPUSH
40806: CALL_OW 1
40810: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
40811: LD_ADDR_EXP 141
40815: PUSH
40816: LD_EXP 141
40820: PPUSH
40821: LD_VAR 0 4
40825: PPUSH
40826: EMPTY
40827: PPUSH
40828: CALL_OW 1
40832: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
40833: LD_ADDR_EXP 142
40837: PUSH
40838: LD_EXP 142
40842: PPUSH
40843: LD_VAR 0 4
40847: PPUSH
40848: EMPTY
40849: PPUSH
40850: CALL_OW 1
40854: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
40855: LD_ADDR_EXP 143
40859: PUSH
40860: LD_EXP 143
40864: PPUSH
40865: LD_VAR 0 4
40869: PPUSH
40870: LD_INT 0
40872: PPUSH
40873: CALL_OW 1
40877: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
40878: LD_ADDR_EXP 144
40882: PUSH
40883: LD_EXP 144
40887: PPUSH
40888: LD_VAR 0 4
40892: PPUSH
40893: LD_INT 0
40895: PPUSH
40896: CALL_OW 1
40900: ST_TO_ADDR
// result := base ;
40901: LD_ADDR_VAR 0 3
40905: PUSH
40906: LD_VAR 0 4
40910: ST_TO_ADDR
// end ;
40911: LD_VAR 0 3
40915: RET
// export function MC_Start ( ) ; var i ; begin
40916: LD_INT 0
40918: PPUSH
40919: PPUSH
// for i = 1 to mc_bases do
40920: LD_ADDR_VAR 0 2
40924: PUSH
40925: DOUBLE
40926: LD_INT 1
40928: DEC
40929: ST_TO_ADDR
40930: LD_EXP 101
40934: PUSH
40935: FOR_TO
40936: IFFALSE 42036
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
40938: LD_ADDR_EXP 101
40942: PUSH
40943: LD_EXP 101
40947: PPUSH
40948: LD_VAR 0 2
40952: PPUSH
40953: LD_EXP 101
40957: PUSH
40958: LD_VAR 0 2
40962: ARRAY
40963: PUSH
40964: LD_INT 0
40966: DIFF
40967: PPUSH
40968: CALL_OW 1
40972: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
40973: LD_ADDR_EXP 102
40977: PUSH
40978: LD_EXP 102
40982: PPUSH
40983: LD_VAR 0 2
40987: PPUSH
40988: EMPTY
40989: PPUSH
40990: CALL_OW 1
40994: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
40995: LD_ADDR_EXP 103
40999: PUSH
41000: LD_EXP 103
41004: PPUSH
41005: LD_VAR 0 2
41009: PPUSH
41010: EMPTY
41011: PPUSH
41012: CALL_OW 1
41016: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
41017: LD_ADDR_EXP 104
41021: PUSH
41022: LD_EXP 104
41026: PPUSH
41027: LD_VAR 0 2
41031: PPUSH
41032: EMPTY
41033: PPUSH
41034: CALL_OW 1
41038: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
41039: LD_ADDR_EXP 105
41043: PUSH
41044: LD_EXP 105
41048: PPUSH
41049: LD_VAR 0 2
41053: PPUSH
41054: EMPTY
41055: PUSH
41056: EMPTY
41057: PUSH
41058: EMPTY
41059: LIST
41060: LIST
41061: PPUSH
41062: CALL_OW 1
41066: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
41067: LD_ADDR_EXP 106
41071: PUSH
41072: LD_EXP 106
41076: PPUSH
41077: LD_VAR 0 2
41081: PPUSH
41082: EMPTY
41083: PPUSH
41084: CALL_OW 1
41088: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
41089: LD_ADDR_EXP 133
41093: PUSH
41094: LD_EXP 133
41098: PPUSH
41099: LD_VAR 0 2
41103: PPUSH
41104: EMPTY
41105: PPUSH
41106: CALL_OW 1
41110: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
41111: LD_ADDR_EXP 107
41115: PUSH
41116: LD_EXP 107
41120: PPUSH
41121: LD_VAR 0 2
41125: PPUSH
41126: EMPTY
41127: PPUSH
41128: CALL_OW 1
41132: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
41133: LD_ADDR_EXP 108
41137: PUSH
41138: LD_EXP 108
41142: PPUSH
41143: LD_VAR 0 2
41147: PPUSH
41148: EMPTY
41149: PPUSH
41150: CALL_OW 1
41154: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
41155: LD_ADDR_EXP 109
41159: PUSH
41160: LD_EXP 109
41164: PPUSH
41165: LD_VAR 0 2
41169: PPUSH
41170: LD_EXP 101
41174: PUSH
41175: LD_VAR 0 2
41179: ARRAY
41180: PPUSH
41181: LD_INT 2
41183: PUSH
41184: LD_INT 30
41186: PUSH
41187: LD_INT 32
41189: PUSH
41190: EMPTY
41191: LIST
41192: LIST
41193: PUSH
41194: LD_INT 30
41196: PUSH
41197: LD_INT 33
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: PUSH
41204: EMPTY
41205: LIST
41206: LIST
41207: LIST
41208: PPUSH
41209: CALL_OW 72
41213: PPUSH
41214: CALL_OW 1
41218: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
41219: LD_ADDR_EXP 110
41223: PUSH
41224: LD_EXP 110
41228: PPUSH
41229: LD_VAR 0 2
41233: PPUSH
41234: LD_EXP 101
41238: PUSH
41239: LD_VAR 0 2
41243: ARRAY
41244: PPUSH
41245: LD_INT 2
41247: PUSH
41248: LD_INT 30
41250: PUSH
41251: LD_INT 32
41253: PUSH
41254: EMPTY
41255: LIST
41256: LIST
41257: PUSH
41258: LD_INT 30
41260: PUSH
41261: LD_INT 31
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: PUSH
41268: EMPTY
41269: LIST
41270: LIST
41271: LIST
41272: PUSH
41273: LD_INT 58
41275: PUSH
41276: EMPTY
41277: LIST
41278: PUSH
41279: EMPTY
41280: LIST
41281: LIST
41282: PPUSH
41283: CALL_OW 72
41287: PPUSH
41288: CALL_OW 1
41292: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
41293: LD_ADDR_EXP 111
41297: PUSH
41298: LD_EXP 111
41302: PPUSH
41303: LD_VAR 0 2
41307: PPUSH
41308: EMPTY
41309: PPUSH
41310: CALL_OW 1
41314: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
41315: LD_ADDR_EXP 115
41319: PUSH
41320: LD_EXP 115
41324: PPUSH
41325: LD_VAR 0 2
41329: PPUSH
41330: EMPTY
41331: PPUSH
41332: CALL_OW 1
41336: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
41337: LD_ADDR_EXP 114
41341: PUSH
41342: LD_EXP 114
41346: PPUSH
41347: LD_VAR 0 2
41351: PPUSH
41352: EMPTY
41353: PPUSH
41354: CALL_OW 1
41358: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
41359: LD_ADDR_EXP 116
41363: PUSH
41364: LD_EXP 116
41368: PPUSH
41369: LD_VAR 0 2
41373: PPUSH
41374: EMPTY
41375: PPUSH
41376: CALL_OW 1
41380: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
41381: LD_ADDR_EXP 117
41385: PUSH
41386: LD_EXP 117
41390: PPUSH
41391: LD_VAR 0 2
41395: PPUSH
41396: EMPTY
41397: PPUSH
41398: CALL_OW 1
41402: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
41403: LD_ADDR_EXP 118
41407: PUSH
41408: LD_EXP 118
41412: PPUSH
41413: LD_VAR 0 2
41417: PPUSH
41418: EMPTY
41419: PPUSH
41420: CALL_OW 1
41424: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
41425: LD_ADDR_EXP 119
41429: PUSH
41430: LD_EXP 119
41434: PPUSH
41435: LD_VAR 0 2
41439: PPUSH
41440: EMPTY
41441: PPUSH
41442: CALL_OW 1
41446: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
41447: LD_ADDR_EXP 120
41451: PUSH
41452: LD_EXP 120
41456: PPUSH
41457: LD_VAR 0 2
41461: PPUSH
41462: EMPTY
41463: PPUSH
41464: CALL_OW 1
41468: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
41469: LD_ADDR_EXP 121
41473: PUSH
41474: LD_EXP 121
41478: PPUSH
41479: LD_VAR 0 2
41483: PPUSH
41484: EMPTY
41485: PPUSH
41486: CALL_OW 1
41490: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
41491: LD_ADDR_EXP 122
41495: PUSH
41496: LD_EXP 122
41500: PPUSH
41501: LD_VAR 0 2
41505: PPUSH
41506: EMPTY
41507: PPUSH
41508: CALL_OW 1
41512: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
41513: LD_ADDR_EXP 123
41517: PUSH
41518: LD_EXP 123
41522: PPUSH
41523: LD_VAR 0 2
41527: PPUSH
41528: EMPTY
41529: PPUSH
41530: CALL_OW 1
41534: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
41535: LD_ADDR_EXP 112
41539: PUSH
41540: LD_EXP 112
41544: PPUSH
41545: LD_VAR 0 2
41549: PPUSH
41550: LD_INT 0
41552: PPUSH
41553: CALL_OW 1
41557: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
41558: LD_ADDR_EXP 125
41562: PUSH
41563: LD_EXP 125
41567: PPUSH
41568: LD_VAR 0 2
41572: PPUSH
41573: LD_INT 0
41575: PPUSH
41576: CALL_OW 1
41580: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
41581: LD_ADDR_EXP 113
41585: PUSH
41586: LD_EXP 113
41590: PPUSH
41591: LD_VAR 0 2
41595: PPUSH
41596: EMPTY
41597: PPUSH
41598: CALL_OW 1
41602: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
41603: LD_ADDR_EXP 124
41607: PUSH
41608: LD_EXP 124
41612: PPUSH
41613: LD_VAR 0 2
41617: PPUSH
41618: LD_INT 0
41620: PPUSH
41621: CALL_OW 1
41625: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
41626: LD_ADDR_EXP 126
41630: PUSH
41631: LD_EXP 126
41635: PPUSH
41636: LD_VAR 0 2
41640: PPUSH
41641: EMPTY
41642: PPUSH
41643: CALL_OW 1
41647: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
41648: LD_ADDR_EXP 129
41652: PUSH
41653: LD_EXP 129
41657: PPUSH
41658: LD_VAR 0 2
41662: PPUSH
41663: LD_INT 0
41665: PPUSH
41666: CALL_OW 1
41670: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
41671: LD_ADDR_EXP 130
41675: PUSH
41676: LD_EXP 130
41680: PPUSH
41681: LD_VAR 0 2
41685: PPUSH
41686: EMPTY
41687: PPUSH
41688: CALL_OW 1
41692: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
41693: LD_ADDR_EXP 131
41697: PUSH
41698: LD_EXP 131
41702: PPUSH
41703: LD_VAR 0 2
41707: PPUSH
41708: EMPTY
41709: PPUSH
41710: CALL_OW 1
41714: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
41715: LD_ADDR_EXP 132
41719: PUSH
41720: LD_EXP 132
41724: PPUSH
41725: LD_VAR 0 2
41729: PPUSH
41730: EMPTY
41731: PPUSH
41732: CALL_OW 1
41736: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
41737: LD_ADDR_EXP 134
41741: PUSH
41742: LD_EXP 134
41746: PPUSH
41747: LD_VAR 0 2
41751: PPUSH
41752: LD_EXP 101
41756: PUSH
41757: LD_VAR 0 2
41761: ARRAY
41762: PPUSH
41763: LD_INT 2
41765: PUSH
41766: LD_INT 30
41768: PUSH
41769: LD_INT 6
41771: PUSH
41772: EMPTY
41773: LIST
41774: LIST
41775: PUSH
41776: LD_INT 30
41778: PUSH
41779: LD_INT 7
41781: PUSH
41782: EMPTY
41783: LIST
41784: LIST
41785: PUSH
41786: LD_INT 30
41788: PUSH
41789: LD_INT 8
41791: PUSH
41792: EMPTY
41793: LIST
41794: LIST
41795: PUSH
41796: EMPTY
41797: LIST
41798: LIST
41799: LIST
41800: LIST
41801: PPUSH
41802: CALL_OW 72
41806: PPUSH
41807: CALL_OW 1
41811: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
41812: LD_ADDR_EXP 135
41816: PUSH
41817: LD_EXP 135
41821: PPUSH
41822: LD_VAR 0 2
41826: PPUSH
41827: EMPTY
41828: PPUSH
41829: CALL_OW 1
41833: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
41834: LD_ADDR_EXP 136
41838: PUSH
41839: LD_EXP 136
41843: PPUSH
41844: LD_VAR 0 2
41848: PPUSH
41849: EMPTY
41850: PPUSH
41851: CALL_OW 1
41855: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
41856: LD_ADDR_EXP 137
41860: PUSH
41861: LD_EXP 137
41865: PPUSH
41866: LD_VAR 0 2
41870: PPUSH
41871: EMPTY
41872: PPUSH
41873: CALL_OW 1
41877: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
41878: LD_ADDR_EXP 138
41882: PUSH
41883: LD_EXP 138
41887: PPUSH
41888: LD_VAR 0 2
41892: PPUSH
41893: EMPTY
41894: PPUSH
41895: CALL_OW 1
41899: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41900: LD_ADDR_EXP 139
41904: PUSH
41905: LD_EXP 139
41909: PPUSH
41910: LD_VAR 0 2
41914: PPUSH
41915: EMPTY
41916: PPUSH
41917: CALL_OW 1
41921: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
41922: LD_ADDR_EXP 140
41926: PUSH
41927: LD_EXP 140
41931: PPUSH
41932: LD_VAR 0 2
41936: PPUSH
41937: EMPTY
41938: PPUSH
41939: CALL_OW 1
41943: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
41944: LD_ADDR_EXP 141
41948: PUSH
41949: LD_EXP 141
41953: PPUSH
41954: LD_VAR 0 2
41958: PPUSH
41959: EMPTY
41960: PPUSH
41961: CALL_OW 1
41965: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
41966: LD_ADDR_EXP 142
41970: PUSH
41971: LD_EXP 142
41975: PPUSH
41976: LD_VAR 0 2
41980: PPUSH
41981: EMPTY
41982: PPUSH
41983: CALL_OW 1
41987: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
41988: LD_ADDR_EXP 143
41992: PUSH
41993: LD_EXP 143
41997: PPUSH
41998: LD_VAR 0 2
42002: PPUSH
42003: LD_INT 0
42005: PPUSH
42006: CALL_OW 1
42010: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
42011: LD_ADDR_EXP 144
42015: PUSH
42016: LD_EXP 144
42020: PPUSH
42021: LD_VAR 0 2
42025: PPUSH
42026: LD_INT 0
42028: PPUSH
42029: CALL_OW 1
42033: ST_TO_ADDR
// end ;
42034: GO 40935
42036: POP
42037: POP
// MC_InitSides ( ) ;
42038: CALL 42324 0 0
// MC_InitResearch ( ) ;
42042: CALL 42063 0 0
// CustomInitMacro ( ) ;
42046: CALL 475 0 0
// skirmish := true ;
42050: LD_ADDR_EXP 99
42054: PUSH
42055: LD_INT 1
42057: ST_TO_ADDR
// end ;
42058: LD_VAR 0 1
42062: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
42063: LD_INT 0
42065: PPUSH
42066: PPUSH
42067: PPUSH
42068: PPUSH
42069: PPUSH
42070: PPUSH
// if not mc_bases then
42071: LD_EXP 101
42075: NOT
42076: IFFALSE 42080
// exit ;
42078: GO 42319
// for i = 1 to 8 do
42080: LD_ADDR_VAR 0 2
42084: PUSH
42085: DOUBLE
42086: LD_INT 1
42088: DEC
42089: ST_TO_ADDR
42090: LD_INT 8
42092: PUSH
42093: FOR_TO
42094: IFFALSE 42120
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
42096: LD_ADDR_EXP 128
42100: PUSH
42101: LD_EXP 128
42105: PPUSH
42106: LD_VAR 0 2
42110: PPUSH
42111: EMPTY
42112: PPUSH
42113: CALL_OW 1
42117: ST_TO_ADDR
42118: GO 42093
42120: POP
42121: POP
// tmp := [ ] ;
42122: LD_ADDR_VAR 0 5
42126: PUSH
42127: EMPTY
42128: ST_TO_ADDR
// for i = 1 to mc_sides do
42129: LD_ADDR_VAR 0 2
42133: PUSH
42134: DOUBLE
42135: LD_INT 1
42137: DEC
42138: ST_TO_ADDR
42139: LD_EXP 127
42143: PUSH
42144: FOR_TO
42145: IFFALSE 42203
// if not mc_sides [ i ] in tmp then
42147: LD_EXP 127
42151: PUSH
42152: LD_VAR 0 2
42156: ARRAY
42157: PUSH
42158: LD_VAR 0 5
42162: IN
42163: NOT
42164: IFFALSE 42201
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
42166: LD_ADDR_VAR 0 5
42170: PUSH
42171: LD_VAR 0 5
42175: PPUSH
42176: LD_VAR 0 5
42180: PUSH
42181: LD_INT 1
42183: PLUS
42184: PPUSH
42185: LD_EXP 127
42189: PUSH
42190: LD_VAR 0 2
42194: ARRAY
42195: PPUSH
42196: CALL_OW 2
42200: ST_TO_ADDR
42201: GO 42144
42203: POP
42204: POP
// if not tmp then
42205: LD_VAR 0 5
42209: NOT
42210: IFFALSE 42214
// exit ;
42212: GO 42319
// for j in tmp do
42214: LD_ADDR_VAR 0 3
42218: PUSH
42219: LD_VAR 0 5
42223: PUSH
42224: FOR_IN
42225: IFFALSE 42317
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
42227: LD_ADDR_VAR 0 6
42231: PUSH
42232: LD_INT 22
42234: PUSH
42235: LD_VAR 0 3
42239: PUSH
42240: EMPTY
42241: LIST
42242: LIST
42243: PPUSH
42244: CALL_OW 69
42248: ST_TO_ADDR
// if not un then
42249: LD_VAR 0 6
42253: NOT
42254: IFFALSE 42258
// continue ;
42256: GO 42224
// nation := GetNation ( un [ 1 ] ) ;
42258: LD_ADDR_VAR 0 4
42262: PUSH
42263: LD_VAR 0 6
42267: PUSH
42268: LD_INT 1
42270: ARRAY
42271: PPUSH
42272: CALL_OW 248
42276: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
42277: LD_ADDR_EXP 128
42281: PUSH
42282: LD_EXP 128
42286: PPUSH
42287: LD_VAR 0 3
42291: PPUSH
42292: LD_VAR 0 3
42296: PPUSH
42297: LD_VAR 0 4
42301: PPUSH
42302: LD_INT 1
42304: PPUSH
42305: CALL 69507 0 3
42309: PPUSH
42310: CALL_OW 1
42314: ST_TO_ADDR
// end ;
42315: GO 42224
42317: POP
42318: POP
// end ;
42319: LD_VAR 0 1
42323: RET
// export function MC_InitSides ( ) ; var i ; begin
42324: LD_INT 0
42326: PPUSH
42327: PPUSH
// if not mc_bases then
42328: LD_EXP 101
42332: NOT
42333: IFFALSE 42337
// exit ;
42335: GO 42411
// for i = 1 to mc_bases do
42337: LD_ADDR_VAR 0 2
42341: PUSH
42342: DOUBLE
42343: LD_INT 1
42345: DEC
42346: ST_TO_ADDR
42347: LD_EXP 101
42351: PUSH
42352: FOR_TO
42353: IFFALSE 42409
// if mc_bases [ i ] then
42355: LD_EXP 101
42359: PUSH
42360: LD_VAR 0 2
42364: ARRAY
42365: IFFALSE 42407
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
42367: LD_ADDR_EXP 127
42371: PUSH
42372: LD_EXP 127
42376: PPUSH
42377: LD_VAR 0 2
42381: PPUSH
42382: LD_EXP 101
42386: PUSH
42387: LD_VAR 0 2
42391: ARRAY
42392: PUSH
42393: LD_INT 1
42395: ARRAY
42396: PPUSH
42397: CALL_OW 255
42401: PPUSH
42402: CALL_OW 1
42406: ST_TO_ADDR
42407: GO 42352
42409: POP
42410: POP
// end ;
42411: LD_VAR 0 1
42415: RET
// every 0 0$03 trigger skirmish do
42416: LD_EXP 99
42420: IFFALSE 42574
42422: GO 42424
42424: DISABLE
// begin enable ;
42425: ENABLE
// MC_CheckBuildings ( ) ;
42426: CALL 47086 0 0
// MC_CheckPeopleLife ( ) ;
42430: CALL 47247 0 0
// RaiseSailEvent ( 100 ) ;
42434: LD_INT 100
42436: PPUSH
42437: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
42441: LD_INT 103
42443: PPUSH
42444: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
42448: LD_INT 104
42450: PPUSH
42451: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
42455: LD_INT 105
42457: PPUSH
42458: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
42462: LD_INT 106
42464: PPUSH
42465: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
42469: LD_INT 107
42471: PPUSH
42472: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
42476: LD_INT 108
42478: PPUSH
42479: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
42483: LD_INT 109
42485: PPUSH
42486: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
42490: LD_INT 110
42492: PPUSH
42493: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
42497: LD_INT 111
42499: PPUSH
42500: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
42504: LD_INT 112
42506: PPUSH
42507: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
42511: LD_INT 113
42513: PPUSH
42514: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
42518: LD_INT 120
42520: PPUSH
42521: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
42525: LD_INT 121
42527: PPUSH
42528: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
42532: LD_INT 122
42534: PPUSH
42535: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
42539: LD_INT 123
42541: PPUSH
42542: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
42546: LD_INT 124
42548: PPUSH
42549: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
42553: LD_INT 125
42555: PPUSH
42556: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
42560: LD_INT 126
42562: PPUSH
42563: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
42567: LD_INT 200
42569: PPUSH
42570: CALL_OW 427
// end ;
42574: END
// on SailEvent ( event ) do begin if event < 100 then
42575: LD_VAR 0 1
42579: PUSH
42580: LD_INT 100
42582: LESS
42583: IFFALSE 42594
// CustomEvent ( event ) ;
42585: LD_VAR 0 1
42589: PPUSH
42590: CALL 36950 0 1
// if event = 100 then
42594: LD_VAR 0 1
42598: PUSH
42599: LD_INT 100
42601: EQUAL
42602: IFFALSE 42608
// MC_ClassManager ( ) ;
42604: CALL 43000 0 0
// if event = 101 then
42608: LD_VAR 0 1
42612: PUSH
42613: LD_INT 101
42615: EQUAL
42616: IFFALSE 42622
// MC_RepairBuildings ( ) ;
42618: CALL 47832 0 0
// if event = 102 then
42622: LD_VAR 0 1
42626: PUSH
42627: LD_INT 102
42629: EQUAL
42630: IFFALSE 42636
// MC_Heal ( ) ;
42632: CALL 48767 0 0
// if event = 103 then
42636: LD_VAR 0 1
42640: PUSH
42641: LD_INT 103
42643: EQUAL
42644: IFFALSE 42650
// MC_Build ( ) ;
42646: CALL 49189 0 0
// if event = 104 then
42650: LD_VAR 0 1
42654: PUSH
42655: LD_INT 104
42657: EQUAL
42658: IFFALSE 42664
// MC_TurretWeapon ( ) ;
42660: CALL 50823 0 0
// if event = 105 then
42664: LD_VAR 0 1
42668: PUSH
42669: LD_INT 105
42671: EQUAL
42672: IFFALSE 42678
// MC_BuildUpgrade ( ) ;
42674: CALL 50374 0 0
// if event = 106 then
42678: LD_VAR 0 1
42682: PUSH
42683: LD_INT 106
42685: EQUAL
42686: IFFALSE 42692
// MC_PlantMines ( ) ;
42688: CALL 51253 0 0
// if event = 107 then
42692: LD_VAR 0 1
42696: PUSH
42697: LD_INT 107
42699: EQUAL
42700: IFFALSE 42706
// MC_CollectCrates ( ) ;
42702: CALL 52051 0 0
// if event = 108 then
42706: LD_VAR 0 1
42710: PUSH
42711: LD_INT 108
42713: EQUAL
42714: IFFALSE 42720
// MC_LinkRemoteControl ( ) ;
42716: CALL 53901 0 0
// if event = 109 then
42720: LD_VAR 0 1
42724: PUSH
42725: LD_INT 109
42727: EQUAL
42728: IFFALSE 42734
// MC_ProduceVehicle ( ) ;
42730: CALL 54082 0 0
// if event = 110 then
42734: LD_VAR 0 1
42738: PUSH
42739: LD_INT 110
42741: EQUAL
42742: IFFALSE 42748
// MC_SendAttack ( ) ;
42744: CALL 54548 0 0
// if event = 111 then
42748: LD_VAR 0 1
42752: PUSH
42753: LD_INT 111
42755: EQUAL
42756: IFFALSE 42762
// MC_Defend ( ) ;
42758: CALL 54656 0 0
// if event = 112 then
42762: LD_VAR 0 1
42766: PUSH
42767: LD_INT 112
42769: EQUAL
42770: IFFALSE 42776
// MC_Research ( ) ;
42772: CALL 55536 0 0
// if event = 113 then
42776: LD_VAR 0 1
42780: PUSH
42781: LD_INT 113
42783: EQUAL
42784: IFFALSE 42790
// MC_MinesTrigger ( ) ;
42786: CALL 56650 0 0
// if event = 120 then
42790: LD_VAR 0 1
42794: PUSH
42795: LD_INT 120
42797: EQUAL
42798: IFFALSE 42804
// MC_RepairVehicle ( ) ;
42800: CALL 56749 0 0
// if event = 121 then
42804: LD_VAR 0 1
42808: PUSH
42809: LD_INT 121
42811: EQUAL
42812: IFFALSE 42818
// MC_TameApe ( ) ;
42814: CALL 57518 0 0
// if event = 122 then
42818: LD_VAR 0 1
42822: PUSH
42823: LD_INT 122
42825: EQUAL
42826: IFFALSE 42832
// MC_ChangeApeClass ( ) ;
42828: CALL 58347 0 0
// if event = 123 then
42832: LD_VAR 0 1
42836: PUSH
42837: LD_INT 123
42839: EQUAL
42840: IFFALSE 42846
// MC_Bazooka ( ) ;
42842: CALL 58997 0 0
// if event = 124 then
42846: LD_VAR 0 1
42850: PUSH
42851: LD_INT 124
42853: EQUAL
42854: IFFALSE 42860
// MC_TeleportExit ( ) ;
42856: CALL 59195 0 0
// if event = 125 then
42860: LD_VAR 0 1
42864: PUSH
42865: LD_INT 125
42867: EQUAL
42868: IFFALSE 42874
// MC_Deposits ( ) ;
42870: CALL 59842 0 0
// if event = 126 then
42874: LD_VAR 0 1
42878: PUSH
42879: LD_INT 126
42881: EQUAL
42882: IFFALSE 42888
// MC_RemoteDriver ( ) ;
42884: CALL 60467 0 0
// if event = 200 then
42888: LD_VAR 0 1
42892: PUSH
42893: LD_INT 200
42895: EQUAL
42896: IFFALSE 42902
// MC_Idle ( ) ;
42898: CALL 62374 0 0
// end ;
42902: PPOPN 1
42904: END
// export function MC_Reset ( base , tag ) ; var i ; begin
42905: LD_INT 0
42907: PPUSH
42908: PPUSH
// if not mc_bases [ base ] or not tag then
42909: LD_EXP 101
42913: PUSH
42914: LD_VAR 0 1
42918: ARRAY
42919: NOT
42920: PUSH
42921: LD_VAR 0 2
42925: NOT
42926: OR
42927: IFFALSE 42931
// exit ;
42929: GO 42995
// for i in mc_bases [ base ] union mc_ape [ base ] do
42931: LD_ADDR_VAR 0 4
42935: PUSH
42936: LD_EXP 101
42940: PUSH
42941: LD_VAR 0 1
42945: ARRAY
42946: PUSH
42947: LD_EXP 130
42951: PUSH
42952: LD_VAR 0 1
42956: ARRAY
42957: UNION
42958: PUSH
42959: FOR_IN
42960: IFFALSE 42993
// if GetTag ( i ) = tag then
42962: LD_VAR 0 4
42966: PPUSH
42967: CALL_OW 110
42971: PUSH
42972: LD_VAR 0 2
42976: EQUAL
42977: IFFALSE 42991
// SetTag ( i , 0 ) ;
42979: LD_VAR 0 4
42983: PPUSH
42984: LD_INT 0
42986: PPUSH
42987: CALL_OW 109
42991: GO 42959
42993: POP
42994: POP
// end ;
42995: LD_VAR 0 3
42999: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
43000: LD_INT 0
43002: PPUSH
43003: PPUSH
43004: PPUSH
43005: PPUSH
43006: PPUSH
43007: PPUSH
43008: PPUSH
43009: PPUSH
// if not mc_bases then
43010: LD_EXP 101
43014: NOT
43015: IFFALSE 43019
// exit ;
43017: GO 43468
// for i = 1 to mc_bases do
43019: LD_ADDR_VAR 0 2
43023: PUSH
43024: DOUBLE
43025: LD_INT 1
43027: DEC
43028: ST_TO_ADDR
43029: LD_EXP 101
43033: PUSH
43034: FOR_TO
43035: IFFALSE 43466
// begin tmp := MC_ClassCheckReq ( i ) ;
43037: LD_ADDR_VAR 0 4
43041: PUSH
43042: LD_VAR 0 2
43046: PPUSH
43047: CALL 43473 0 1
43051: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
43052: LD_ADDR_EXP 142
43056: PUSH
43057: LD_EXP 142
43061: PPUSH
43062: LD_VAR 0 2
43066: PPUSH
43067: LD_VAR 0 4
43071: PPUSH
43072: CALL_OW 1
43076: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
43077: LD_ADDR_VAR 0 6
43081: PUSH
43082: LD_EXP 101
43086: PUSH
43087: LD_VAR 0 2
43091: ARRAY
43092: PPUSH
43093: LD_INT 2
43095: PUSH
43096: LD_INT 30
43098: PUSH
43099: LD_INT 4
43101: PUSH
43102: EMPTY
43103: LIST
43104: LIST
43105: PUSH
43106: LD_INT 30
43108: PUSH
43109: LD_INT 5
43111: PUSH
43112: EMPTY
43113: LIST
43114: LIST
43115: PUSH
43116: EMPTY
43117: LIST
43118: LIST
43119: LIST
43120: PPUSH
43121: CALL_OW 72
43125: PUSH
43126: LD_EXP 101
43130: PUSH
43131: LD_VAR 0 2
43135: ARRAY
43136: PPUSH
43137: LD_INT 2
43139: PUSH
43140: LD_INT 30
43142: PUSH
43143: LD_INT 0
43145: PUSH
43146: EMPTY
43147: LIST
43148: LIST
43149: PUSH
43150: LD_INT 30
43152: PUSH
43153: LD_INT 1
43155: PUSH
43156: EMPTY
43157: LIST
43158: LIST
43159: PUSH
43160: EMPTY
43161: LIST
43162: LIST
43163: LIST
43164: PPUSH
43165: CALL_OW 72
43169: PUSH
43170: LD_EXP 101
43174: PUSH
43175: LD_VAR 0 2
43179: ARRAY
43180: PPUSH
43181: LD_INT 30
43183: PUSH
43184: LD_INT 3
43186: PUSH
43187: EMPTY
43188: LIST
43189: LIST
43190: PPUSH
43191: CALL_OW 72
43195: PUSH
43196: LD_EXP 101
43200: PUSH
43201: LD_VAR 0 2
43205: ARRAY
43206: PPUSH
43207: LD_INT 2
43209: PUSH
43210: LD_INT 30
43212: PUSH
43213: LD_INT 6
43215: PUSH
43216: EMPTY
43217: LIST
43218: LIST
43219: PUSH
43220: LD_INT 30
43222: PUSH
43223: LD_INT 7
43225: PUSH
43226: EMPTY
43227: LIST
43228: LIST
43229: PUSH
43230: LD_INT 30
43232: PUSH
43233: LD_INT 8
43235: PUSH
43236: EMPTY
43237: LIST
43238: LIST
43239: PUSH
43240: EMPTY
43241: LIST
43242: LIST
43243: LIST
43244: LIST
43245: PPUSH
43246: CALL_OW 72
43250: PUSH
43251: EMPTY
43252: LIST
43253: LIST
43254: LIST
43255: LIST
43256: ST_TO_ADDR
// for j := 1 to 4 do
43257: LD_ADDR_VAR 0 3
43261: PUSH
43262: DOUBLE
43263: LD_INT 1
43265: DEC
43266: ST_TO_ADDR
43267: LD_INT 4
43269: PUSH
43270: FOR_TO
43271: IFFALSE 43462
// begin if not tmp [ j ] then
43273: LD_VAR 0 4
43277: PUSH
43278: LD_VAR 0 3
43282: ARRAY
43283: NOT
43284: IFFALSE 43288
// continue ;
43286: GO 43270
// for p in tmp [ j ] do
43288: LD_ADDR_VAR 0 5
43292: PUSH
43293: LD_VAR 0 4
43297: PUSH
43298: LD_VAR 0 3
43302: ARRAY
43303: PUSH
43304: FOR_IN
43305: IFFALSE 43458
// begin if not b [ j ] then
43307: LD_VAR 0 6
43311: PUSH
43312: LD_VAR 0 3
43316: ARRAY
43317: NOT
43318: IFFALSE 43322
// break ;
43320: GO 43458
// e := 0 ;
43322: LD_ADDR_VAR 0 7
43326: PUSH
43327: LD_INT 0
43329: ST_TO_ADDR
// for k in b [ j ] do
43330: LD_ADDR_VAR 0 8
43334: PUSH
43335: LD_VAR 0 6
43339: PUSH
43340: LD_VAR 0 3
43344: ARRAY
43345: PUSH
43346: FOR_IN
43347: IFFALSE 43374
// if IsNotFull ( k ) then
43349: LD_VAR 0 8
43353: PPUSH
43354: CALL 71628 0 1
43358: IFFALSE 43372
// begin e := k ;
43360: LD_ADDR_VAR 0 7
43364: PUSH
43365: LD_VAR 0 8
43369: ST_TO_ADDR
// break ;
43370: GO 43374
// end ;
43372: GO 43346
43374: POP
43375: POP
// if e and not UnitGoingToBuilding ( p , e ) then
43376: LD_VAR 0 7
43380: PUSH
43381: LD_VAR 0 5
43385: PPUSH
43386: LD_VAR 0 7
43390: PPUSH
43391: CALL 105767 0 2
43395: NOT
43396: AND
43397: IFFALSE 43456
// begin if IsInUnit ( p ) then
43399: LD_VAR 0 5
43403: PPUSH
43404: CALL_OW 310
43408: IFFALSE 43419
// ComExitBuilding ( p ) ;
43410: LD_VAR 0 5
43414: PPUSH
43415: CALL_OW 122
// ComEnterUnit ( p , e ) ;
43419: LD_VAR 0 5
43423: PPUSH
43424: LD_VAR 0 7
43428: PPUSH
43429: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
43433: LD_VAR 0 5
43437: PPUSH
43438: LD_VAR 0 3
43442: PPUSH
43443: CALL_OW 183
// AddComExitBuilding ( p ) ;
43447: LD_VAR 0 5
43451: PPUSH
43452: CALL_OW 182
// end ; end ;
43456: GO 43304
43458: POP
43459: POP
// end ;
43460: GO 43270
43462: POP
43463: POP
// end ;
43464: GO 43034
43466: POP
43467: POP
// end ;
43468: LD_VAR 0 1
43472: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
43473: LD_INT 0
43475: PPUSH
43476: PPUSH
43477: PPUSH
43478: PPUSH
43479: PPUSH
43480: PPUSH
43481: PPUSH
43482: PPUSH
43483: PPUSH
43484: PPUSH
43485: PPUSH
43486: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
43487: LD_ADDR_VAR 0 2
43491: PUSH
43492: LD_INT 0
43494: PUSH
43495: LD_INT 0
43497: PUSH
43498: LD_INT 0
43500: PUSH
43501: LD_INT 0
43503: PUSH
43504: EMPTY
43505: LIST
43506: LIST
43507: LIST
43508: LIST
43509: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
43510: LD_VAR 0 1
43514: NOT
43515: PUSH
43516: LD_EXP 101
43520: PUSH
43521: LD_VAR 0 1
43525: ARRAY
43526: NOT
43527: OR
43528: PUSH
43529: LD_EXP 101
43533: PUSH
43534: LD_VAR 0 1
43538: ARRAY
43539: PPUSH
43540: LD_INT 2
43542: PUSH
43543: LD_INT 30
43545: PUSH
43546: LD_INT 0
43548: PUSH
43549: EMPTY
43550: LIST
43551: LIST
43552: PUSH
43553: LD_INT 30
43555: PUSH
43556: LD_INT 1
43558: PUSH
43559: EMPTY
43560: LIST
43561: LIST
43562: PUSH
43563: EMPTY
43564: LIST
43565: LIST
43566: LIST
43567: PPUSH
43568: CALL_OW 72
43572: NOT
43573: OR
43574: IFFALSE 43578
// exit ;
43576: GO 47081
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
43578: LD_ADDR_VAR 0 4
43582: PUSH
43583: LD_EXP 101
43587: PUSH
43588: LD_VAR 0 1
43592: ARRAY
43593: PPUSH
43594: LD_INT 2
43596: PUSH
43597: LD_INT 25
43599: PUSH
43600: LD_INT 1
43602: PUSH
43603: EMPTY
43604: LIST
43605: LIST
43606: PUSH
43607: LD_INT 25
43609: PUSH
43610: LD_INT 2
43612: PUSH
43613: EMPTY
43614: LIST
43615: LIST
43616: PUSH
43617: LD_INT 25
43619: PUSH
43620: LD_INT 3
43622: PUSH
43623: EMPTY
43624: LIST
43625: LIST
43626: PUSH
43627: LD_INT 25
43629: PUSH
43630: LD_INT 4
43632: PUSH
43633: EMPTY
43634: LIST
43635: LIST
43636: PUSH
43637: LD_INT 25
43639: PUSH
43640: LD_INT 5
43642: PUSH
43643: EMPTY
43644: LIST
43645: LIST
43646: PUSH
43647: LD_INT 25
43649: PUSH
43650: LD_INT 8
43652: PUSH
43653: EMPTY
43654: LIST
43655: LIST
43656: PUSH
43657: LD_INT 25
43659: PUSH
43660: LD_INT 9
43662: PUSH
43663: EMPTY
43664: LIST
43665: LIST
43666: PUSH
43667: EMPTY
43668: LIST
43669: LIST
43670: LIST
43671: LIST
43672: LIST
43673: LIST
43674: LIST
43675: LIST
43676: PPUSH
43677: CALL_OW 72
43681: ST_TO_ADDR
// if not tmp then
43682: LD_VAR 0 4
43686: NOT
43687: IFFALSE 43691
// exit ;
43689: GO 47081
// for i in tmp do
43691: LD_ADDR_VAR 0 3
43695: PUSH
43696: LD_VAR 0 4
43700: PUSH
43701: FOR_IN
43702: IFFALSE 43733
// if GetTag ( i ) then
43704: LD_VAR 0 3
43708: PPUSH
43709: CALL_OW 110
43713: IFFALSE 43731
// tmp := tmp diff i ;
43715: LD_ADDR_VAR 0 4
43719: PUSH
43720: LD_VAR 0 4
43724: PUSH
43725: LD_VAR 0 3
43729: DIFF
43730: ST_TO_ADDR
43731: GO 43701
43733: POP
43734: POP
// if not tmp then
43735: LD_VAR 0 4
43739: NOT
43740: IFFALSE 43744
// exit ;
43742: GO 47081
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
43744: LD_ADDR_VAR 0 5
43748: PUSH
43749: LD_EXP 101
43753: PUSH
43754: LD_VAR 0 1
43758: ARRAY
43759: PPUSH
43760: LD_INT 2
43762: PUSH
43763: LD_INT 25
43765: PUSH
43766: LD_INT 1
43768: PUSH
43769: EMPTY
43770: LIST
43771: LIST
43772: PUSH
43773: LD_INT 25
43775: PUSH
43776: LD_INT 5
43778: PUSH
43779: EMPTY
43780: LIST
43781: LIST
43782: PUSH
43783: LD_INT 25
43785: PUSH
43786: LD_INT 8
43788: PUSH
43789: EMPTY
43790: LIST
43791: LIST
43792: PUSH
43793: LD_INT 25
43795: PUSH
43796: LD_INT 9
43798: PUSH
43799: EMPTY
43800: LIST
43801: LIST
43802: PUSH
43803: EMPTY
43804: LIST
43805: LIST
43806: LIST
43807: LIST
43808: LIST
43809: PPUSH
43810: CALL_OW 72
43814: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
43815: LD_ADDR_VAR 0 6
43819: PUSH
43820: LD_EXP 101
43824: PUSH
43825: LD_VAR 0 1
43829: ARRAY
43830: PPUSH
43831: LD_INT 25
43833: PUSH
43834: LD_INT 2
43836: PUSH
43837: EMPTY
43838: LIST
43839: LIST
43840: PPUSH
43841: CALL_OW 72
43845: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
43846: LD_ADDR_VAR 0 7
43850: PUSH
43851: LD_EXP 101
43855: PUSH
43856: LD_VAR 0 1
43860: ARRAY
43861: PPUSH
43862: LD_INT 25
43864: PUSH
43865: LD_INT 3
43867: PUSH
43868: EMPTY
43869: LIST
43870: LIST
43871: PPUSH
43872: CALL_OW 72
43876: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
43877: LD_ADDR_VAR 0 8
43881: PUSH
43882: LD_EXP 101
43886: PUSH
43887: LD_VAR 0 1
43891: ARRAY
43892: PPUSH
43893: LD_INT 25
43895: PUSH
43896: LD_INT 4
43898: PUSH
43899: EMPTY
43900: LIST
43901: LIST
43902: PUSH
43903: LD_INT 24
43905: PUSH
43906: LD_INT 251
43908: PUSH
43909: EMPTY
43910: LIST
43911: LIST
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PPUSH
43917: CALL_OW 72
43921: ST_TO_ADDR
// if mc_is_defending [ base ] then
43922: LD_EXP 144
43926: PUSH
43927: LD_VAR 0 1
43931: ARRAY
43932: IFFALSE 44393
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
43934: LD_ADDR_EXP 143
43938: PUSH
43939: LD_EXP 143
43943: PPUSH
43944: LD_VAR 0 1
43948: PPUSH
43949: LD_INT 4
43951: PPUSH
43952: CALL_OW 1
43956: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
43957: LD_ADDR_VAR 0 12
43961: PUSH
43962: LD_EXP 101
43966: PUSH
43967: LD_VAR 0 1
43971: ARRAY
43972: PPUSH
43973: LD_INT 2
43975: PUSH
43976: LD_INT 30
43978: PUSH
43979: LD_INT 4
43981: PUSH
43982: EMPTY
43983: LIST
43984: LIST
43985: PUSH
43986: LD_INT 30
43988: PUSH
43989: LD_INT 5
43991: PUSH
43992: EMPTY
43993: LIST
43994: LIST
43995: PUSH
43996: EMPTY
43997: LIST
43998: LIST
43999: LIST
44000: PPUSH
44001: CALL_OW 72
44005: ST_TO_ADDR
// if not b then
44006: LD_VAR 0 12
44010: NOT
44011: IFFALSE 44015
// exit ;
44013: GO 47081
// p := [ ] ;
44015: LD_ADDR_VAR 0 11
44019: PUSH
44020: EMPTY
44021: ST_TO_ADDR
// if sci >= 2 then
44022: LD_VAR 0 8
44026: PUSH
44027: LD_INT 2
44029: GREATEREQUAL
44030: IFFALSE 44061
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
44032: LD_ADDR_VAR 0 8
44036: PUSH
44037: LD_VAR 0 8
44041: PUSH
44042: LD_INT 1
44044: ARRAY
44045: PUSH
44046: LD_VAR 0 8
44050: PUSH
44051: LD_INT 2
44053: ARRAY
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: ST_TO_ADDR
44059: GO 44122
// if sci = 1 then
44061: LD_VAR 0 8
44065: PUSH
44066: LD_INT 1
44068: EQUAL
44069: IFFALSE 44090
// sci := [ sci [ 1 ] ] else
44071: LD_ADDR_VAR 0 8
44075: PUSH
44076: LD_VAR 0 8
44080: PUSH
44081: LD_INT 1
44083: ARRAY
44084: PUSH
44085: EMPTY
44086: LIST
44087: ST_TO_ADDR
44088: GO 44122
// if sci = 0 then
44090: LD_VAR 0 8
44094: PUSH
44095: LD_INT 0
44097: EQUAL
44098: IFFALSE 44122
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
44100: LD_ADDR_VAR 0 11
44104: PUSH
44105: LD_VAR 0 4
44109: PPUSH
44110: LD_INT 4
44112: PPUSH
44113: CALL 105639 0 2
44117: PUSH
44118: LD_INT 1
44120: ARRAY
44121: ST_TO_ADDR
// if eng > 4 then
44122: LD_VAR 0 6
44126: PUSH
44127: LD_INT 4
44129: GREATER
44130: IFFALSE 44176
// for i = eng downto 4 do
44132: LD_ADDR_VAR 0 3
44136: PUSH
44137: DOUBLE
44138: LD_VAR 0 6
44142: INC
44143: ST_TO_ADDR
44144: LD_INT 4
44146: PUSH
44147: FOR_DOWNTO
44148: IFFALSE 44174
// eng := eng diff eng [ i ] ;
44150: LD_ADDR_VAR 0 6
44154: PUSH
44155: LD_VAR 0 6
44159: PUSH
44160: LD_VAR 0 6
44164: PUSH
44165: LD_VAR 0 3
44169: ARRAY
44170: DIFF
44171: ST_TO_ADDR
44172: GO 44147
44174: POP
44175: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
44176: LD_ADDR_VAR 0 4
44180: PUSH
44181: LD_VAR 0 4
44185: PUSH
44186: LD_VAR 0 5
44190: PUSH
44191: LD_VAR 0 6
44195: UNION
44196: PUSH
44197: LD_VAR 0 7
44201: UNION
44202: PUSH
44203: LD_VAR 0 8
44207: UNION
44208: DIFF
44209: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
44210: LD_ADDR_VAR 0 13
44214: PUSH
44215: LD_EXP 101
44219: PUSH
44220: LD_VAR 0 1
44224: ARRAY
44225: PPUSH
44226: LD_INT 2
44228: PUSH
44229: LD_INT 30
44231: PUSH
44232: LD_INT 32
44234: PUSH
44235: EMPTY
44236: LIST
44237: LIST
44238: PUSH
44239: LD_INT 30
44241: PUSH
44242: LD_INT 31
44244: PUSH
44245: EMPTY
44246: LIST
44247: LIST
44248: PUSH
44249: EMPTY
44250: LIST
44251: LIST
44252: LIST
44253: PPUSH
44254: CALL_OW 72
44258: PUSH
44259: LD_EXP 101
44263: PUSH
44264: LD_VAR 0 1
44268: ARRAY
44269: PPUSH
44270: LD_INT 2
44272: PUSH
44273: LD_INT 30
44275: PUSH
44276: LD_INT 4
44278: PUSH
44279: EMPTY
44280: LIST
44281: LIST
44282: PUSH
44283: LD_INT 30
44285: PUSH
44286: LD_INT 5
44288: PUSH
44289: EMPTY
44290: LIST
44291: LIST
44292: PUSH
44293: EMPTY
44294: LIST
44295: LIST
44296: LIST
44297: PPUSH
44298: CALL_OW 72
44302: PUSH
44303: LD_INT 6
44305: MUL
44306: PLUS
44307: ST_TO_ADDR
// if bcount < tmp then
44308: LD_VAR 0 13
44312: PUSH
44313: LD_VAR 0 4
44317: LESS
44318: IFFALSE 44364
// for i = tmp downto bcount do
44320: LD_ADDR_VAR 0 3
44324: PUSH
44325: DOUBLE
44326: LD_VAR 0 4
44330: INC
44331: ST_TO_ADDR
44332: LD_VAR 0 13
44336: PUSH
44337: FOR_DOWNTO
44338: IFFALSE 44362
// tmp := Delete ( tmp , tmp ) ;
44340: LD_ADDR_VAR 0 4
44344: PUSH
44345: LD_VAR 0 4
44349: PPUSH
44350: LD_VAR 0 4
44354: PPUSH
44355: CALL_OW 3
44359: ST_TO_ADDR
44360: GO 44337
44362: POP
44363: POP
// result := [ tmp , 0 , 0 , p ] ;
44364: LD_ADDR_VAR 0 2
44368: PUSH
44369: LD_VAR 0 4
44373: PUSH
44374: LD_INT 0
44376: PUSH
44377: LD_INT 0
44379: PUSH
44380: LD_VAR 0 11
44384: PUSH
44385: EMPTY
44386: LIST
44387: LIST
44388: LIST
44389: LIST
44390: ST_TO_ADDR
// exit ;
44391: GO 47081
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
44393: LD_EXP 101
44397: PUSH
44398: LD_VAR 0 1
44402: ARRAY
44403: PPUSH
44404: LD_INT 2
44406: PUSH
44407: LD_INT 30
44409: PUSH
44410: LD_INT 6
44412: PUSH
44413: EMPTY
44414: LIST
44415: LIST
44416: PUSH
44417: LD_INT 30
44419: PUSH
44420: LD_INT 7
44422: PUSH
44423: EMPTY
44424: LIST
44425: LIST
44426: PUSH
44427: LD_INT 30
44429: PUSH
44430: LD_INT 8
44432: PUSH
44433: EMPTY
44434: LIST
44435: LIST
44436: PUSH
44437: EMPTY
44438: LIST
44439: LIST
44440: LIST
44441: LIST
44442: PPUSH
44443: CALL_OW 72
44447: NOT
44448: PUSH
44449: LD_EXP 101
44453: PUSH
44454: LD_VAR 0 1
44458: ARRAY
44459: PPUSH
44460: LD_INT 30
44462: PUSH
44463: LD_INT 3
44465: PUSH
44466: EMPTY
44467: LIST
44468: LIST
44469: PPUSH
44470: CALL_OW 72
44474: NOT
44475: AND
44476: IFFALSE 44548
// begin if eng = tmp then
44478: LD_VAR 0 6
44482: PUSH
44483: LD_VAR 0 4
44487: EQUAL
44488: IFFALSE 44492
// exit ;
44490: GO 47081
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
44492: LD_ADDR_EXP 143
44496: PUSH
44497: LD_EXP 143
44501: PPUSH
44502: LD_VAR 0 1
44506: PPUSH
44507: LD_INT 1
44509: PPUSH
44510: CALL_OW 1
44514: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
44515: LD_ADDR_VAR 0 2
44519: PUSH
44520: LD_INT 0
44522: PUSH
44523: LD_VAR 0 4
44527: PUSH
44528: LD_VAR 0 6
44532: DIFF
44533: PUSH
44534: LD_INT 0
44536: PUSH
44537: LD_INT 0
44539: PUSH
44540: EMPTY
44541: LIST
44542: LIST
44543: LIST
44544: LIST
44545: ST_TO_ADDR
// exit ;
44546: GO 47081
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
44548: LD_EXP 128
44552: PUSH
44553: LD_EXP 127
44557: PUSH
44558: LD_VAR 0 1
44562: ARRAY
44563: ARRAY
44564: PUSH
44565: LD_EXP 101
44569: PUSH
44570: LD_VAR 0 1
44574: ARRAY
44575: PPUSH
44576: LD_INT 2
44578: PUSH
44579: LD_INT 30
44581: PUSH
44582: LD_INT 6
44584: PUSH
44585: EMPTY
44586: LIST
44587: LIST
44588: PUSH
44589: LD_INT 30
44591: PUSH
44592: LD_INT 7
44594: PUSH
44595: EMPTY
44596: LIST
44597: LIST
44598: PUSH
44599: LD_INT 30
44601: PUSH
44602: LD_INT 8
44604: PUSH
44605: EMPTY
44606: LIST
44607: LIST
44608: PUSH
44609: EMPTY
44610: LIST
44611: LIST
44612: LIST
44613: LIST
44614: PPUSH
44615: CALL_OW 72
44619: AND
44620: PUSH
44621: LD_EXP 101
44625: PUSH
44626: LD_VAR 0 1
44630: ARRAY
44631: PPUSH
44632: LD_INT 30
44634: PUSH
44635: LD_INT 3
44637: PUSH
44638: EMPTY
44639: LIST
44640: LIST
44641: PPUSH
44642: CALL_OW 72
44646: NOT
44647: AND
44648: IFFALSE 44862
// begin if sci >= 6 then
44650: LD_VAR 0 8
44654: PUSH
44655: LD_INT 6
44657: GREATEREQUAL
44658: IFFALSE 44662
// exit ;
44660: GO 47081
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
44662: LD_ADDR_EXP 143
44666: PUSH
44667: LD_EXP 143
44671: PPUSH
44672: LD_VAR 0 1
44676: PPUSH
44677: LD_INT 2
44679: PPUSH
44680: CALL_OW 1
44684: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
44685: LD_ADDR_VAR 0 9
44689: PUSH
44690: LD_VAR 0 4
44694: PUSH
44695: LD_VAR 0 8
44699: DIFF
44700: PPUSH
44701: LD_INT 4
44703: PPUSH
44704: CALL 105639 0 2
44708: ST_TO_ADDR
// p := [ ] ;
44709: LD_ADDR_VAR 0 11
44713: PUSH
44714: EMPTY
44715: ST_TO_ADDR
// if sci < 6 and sort > 6 then
44716: LD_VAR 0 8
44720: PUSH
44721: LD_INT 6
44723: LESS
44724: PUSH
44725: LD_VAR 0 9
44729: PUSH
44730: LD_INT 6
44732: GREATER
44733: AND
44734: IFFALSE 44815
// begin for i = 1 to 6 - sci do
44736: LD_ADDR_VAR 0 3
44740: PUSH
44741: DOUBLE
44742: LD_INT 1
44744: DEC
44745: ST_TO_ADDR
44746: LD_INT 6
44748: PUSH
44749: LD_VAR 0 8
44753: MINUS
44754: PUSH
44755: FOR_TO
44756: IFFALSE 44811
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
44758: LD_ADDR_VAR 0 11
44762: PUSH
44763: LD_VAR 0 11
44767: PPUSH
44768: LD_VAR 0 11
44772: PUSH
44773: LD_INT 1
44775: PLUS
44776: PPUSH
44777: LD_VAR 0 9
44781: PUSH
44782: LD_INT 1
44784: ARRAY
44785: PPUSH
44786: CALL_OW 2
44790: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
44791: LD_ADDR_VAR 0 9
44795: PUSH
44796: LD_VAR 0 9
44800: PPUSH
44801: LD_INT 1
44803: PPUSH
44804: CALL_OW 3
44808: ST_TO_ADDR
// end ;
44809: GO 44755
44811: POP
44812: POP
// end else
44813: GO 44835
// if sort then
44815: LD_VAR 0 9
44819: IFFALSE 44835
// p := sort [ 1 ] ;
44821: LD_ADDR_VAR 0 11
44825: PUSH
44826: LD_VAR 0 9
44830: PUSH
44831: LD_INT 1
44833: ARRAY
44834: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
44835: LD_ADDR_VAR 0 2
44839: PUSH
44840: LD_INT 0
44842: PUSH
44843: LD_INT 0
44845: PUSH
44846: LD_INT 0
44848: PUSH
44849: LD_VAR 0 11
44853: PUSH
44854: EMPTY
44855: LIST
44856: LIST
44857: LIST
44858: LIST
44859: ST_TO_ADDR
// exit ;
44860: GO 47081
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
44862: LD_EXP 128
44866: PUSH
44867: LD_EXP 127
44871: PUSH
44872: LD_VAR 0 1
44876: ARRAY
44877: ARRAY
44878: PUSH
44879: LD_EXP 101
44883: PUSH
44884: LD_VAR 0 1
44888: ARRAY
44889: PPUSH
44890: LD_INT 2
44892: PUSH
44893: LD_INT 30
44895: PUSH
44896: LD_INT 6
44898: PUSH
44899: EMPTY
44900: LIST
44901: LIST
44902: PUSH
44903: LD_INT 30
44905: PUSH
44906: LD_INT 7
44908: PUSH
44909: EMPTY
44910: LIST
44911: LIST
44912: PUSH
44913: LD_INT 30
44915: PUSH
44916: LD_INT 8
44918: PUSH
44919: EMPTY
44920: LIST
44921: LIST
44922: PUSH
44923: EMPTY
44924: LIST
44925: LIST
44926: LIST
44927: LIST
44928: PPUSH
44929: CALL_OW 72
44933: AND
44934: PUSH
44935: LD_EXP 101
44939: PUSH
44940: LD_VAR 0 1
44944: ARRAY
44945: PPUSH
44946: LD_INT 30
44948: PUSH
44949: LD_INT 3
44951: PUSH
44952: EMPTY
44953: LIST
44954: LIST
44955: PPUSH
44956: CALL_OW 72
44960: AND
44961: IFFALSE 45695
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
44963: LD_ADDR_EXP 143
44967: PUSH
44968: LD_EXP 143
44972: PPUSH
44973: LD_VAR 0 1
44977: PPUSH
44978: LD_INT 3
44980: PPUSH
44981: CALL_OW 1
44985: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
44986: LD_ADDR_VAR 0 2
44990: PUSH
44991: LD_INT 0
44993: PUSH
44994: LD_INT 0
44996: PUSH
44997: LD_INT 0
44999: PUSH
45000: LD_INT 0
45002: PUSH
45003: EMPTY
45004: LIST
45005: LIST
45006: LIST
45007: LIST
45008: ST_TO_ADDR
// if not eng then
45009: LD_VAR 0 6
45013: NOT
45014: IFFALSE 45077
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
45016: LD_ADDR_VAR 0 11
45020: PUSH
45021: LD_VAR 0 4
45025: PPUSH
45026: LD_INT 2
45028: PPUSH
45029: CALL 105639 0 2
45033: PUSH
45034: LD_INT 1
45036: ARRAY
45037: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
45038: LD_ADDR_VAR 0 2
45042: PUSH
45043: LD_VAR 0 2
45047: PPUSH
45048: LD_INT 2
45050: PPUSH
45051: LD_VAR 0 11
45055: PPUSH
45056: CALL_OW 1
45060: ST_TO_ADDR
// tmp := tmp diff p ;
45061: LD_ADDR_VAR 0 4
45065: PUSH
45066: LD_VAR 0 4
45070: PUSH
45071: LD_VAR 0 11
45075: DIFF
45076: ST_TO_ADDR
// end ; if tmp and sci < 6 then
45077: LD_VAR 0 4
45081: PUSH
45082: LD_VAR 0 8
45086: PUSH
45087: LD_INT 6
45089: LESS
45090: AND
45091: IFFALSE 45279
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
45093: LD_ADDR_VAR 0 9
45097: PUSH
45098: LD_VAR 0 4
45102: PUSH
45103: LD_VAR 0 8
45107: PUSH
45108: LD_VAR 0 7
45112: UNION
45113: DIFF
45114: PPUSH
45115: LD_INT 4
45117: PPUSH
45118: CALL 105639 0 2
45122: ST_TO_ADDR
// p := [ ] ;
45123: LD_ADDR_VAR 0 11
45127: PUSH
45128: EMPTY
45129: ST_TO_ADDR
// if sort then
45130: LD_VAR 0 9
45134: IFFALSE 45250
// for i = 1 to 6 - sci do
45136: LD_ADDR_VAR 0 3
45140: PUSH
45141: DOUBLE
45142: LD_INT 1
45144: DEC
45145: ST_TO_ADDR
45146: LD_INT 6
45148: PUSH
45149: LD_VAR 0 8
45153: MINUS
45154: PUSH
45155: FOR_TO
45156: IFFALSE 45248
// begin if i = sort then
45158: LD_VAR 0 3
45162: PUSH
45163: LD_VAR 0 9
45167: EQUAL
45168: IFFALSE 45172
// break ;
45170: GO 45248
// if GetClass ( i ) = 4 then
45172: LD_VAR 0 3
45176: PPUSH
45177: CALL_OW 257
45181: PUSH
45182: LD_INT 4
45184: EQUAL
45185: IFFALSE 45189
// continue ;
45187: GO 45155
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45189: LD_ADDR_VAR 0 11
45193: PUSH
45194: LD_VAR 0 11
45198: PPUSH
45199: LD_VAR 0 11
45203: PUSH
45204: LD_INT 1
45206: PLUS
45207: PPUSH
45208: LD_VAR 0 9
45212: PUSH
45213: LD_VAR 0 3
45217: ARRAY
45218: PPUSH
45219: CALL_OW 2
45223: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45224: LD_ADDR_VAR 0 4
45228: PUSH
45229: LD_VAR 0 4
45233: PUSH
45234: LD_VAR 0 9
45238: PUSH
45239: LD_VAR 0 3
45243: ARRAY
45244: DIFF
45245: ST_TO_ADDR
// end ;
45246: GO 45155
45248: POP
45249: POP
// if p then
45250: LD_VAR 0 11
45254: IFFALSE 45279
// result := Replace ( result , 4 , p ) ;
45256: LD_ADDR_VAR 0 2
45260: PUSH
45261: LD_VAR 0 2
45265: PPUSH
45266: LD_INT 4
45268: PPUSH
45269: LD_VAR 0 11
45273: PPUSH
45274: CALL_OW 1
45278: ST_TO_ADDR
// end ; if tmp and mech < 6 then
45279: LD_VAR 0 4
45283: PUSH
45284: LD_VAR 0 7
45288: PUSH
45289: LD_INT 6
45291: LESS
45292: AND
45293: IFFALSE 45481
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
45295: LD_ADDR_VAR 0 9
45299: PUSH
45300: LD_VAR 0 4
45304: PUSH
45305: LD_VAR 0 8
45309: PUSH
45310: LD_VAR 0 7
45314: UNION
45315: DIFF
45316: PPUSH
45317: LD_INT 3
45319: PPUSH
45320: CALL 105639 0 2
45324: ST_TO_ADDR
// p := [ ] ;
45325: LD_ADDR_VAR 0 11
45329: PUSH
45330: EMPTY
45331: ST_TO_ADDR
// if sort then
45332: LD_VAR 0 9
45336: IFFALSE 45452
// for i = 1 to 6 - mech do
45338: LD_ADDR_VAR 0 3
45342: PUSH
45343: DOUBLE
45344: LD_INT 1
45346: DEC
45347: ST_TO_ADDR
45348: LD_INT 6
45350: PUSH
45351: LD_VAR 0 7
45355: MINUS
45356: PUSH
45357: FOR_TO
45358: IFFALSE 45450
// begin if i = sort then
45360: LD_VAR 0 3
45364: PUSH
45365: LD_VAR 0 9
45369: EQUAL
45370: IFFALSE 45374
// break ;
45372: GO 45450
// if GetClass ( i ) = 3 then
45374: LD_VAR 0 3
45378: PPUSH
45379: CALL_OW 257
45383: PUSH
45384: LD_INT 3
45386: EQUAL
45387: IFFALSE 45391
// continue ;
45389: GO 45357
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45391: LD_ADDR_VAR 0 11
45395: PUSH
45396: LD_VAR 0 11
45400: PPUSH
45401: LD_VAR 0 11
45405: PUSH
45406: LD_INT 1
45408: PLUS
45409: PPUSH
45410: LD_VAR 0 9
45414: PUSH
45415: LD_VAR 0 3
45419: ARRAY
45420: PPUSH
45421: CALL_OW 2
45425: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45426: LD_ADDR_VAR 0 4
45430: PUSH
45431: LD_VAR 0 4
45435: PUSH
45436: LD_VAR 0 9
45440: PUSH
45441: LD_VAR 0 3
45445: ARRAY
45446: DIFF
45447: ST_TO_ADDR
// end ;
45448: GO 45357
45450: POP
45451: POP
// if p then
45452: LD_VAR 0 11
45456: IFFALSE 45481
// result := Replace ( result , 3 , p ) ;
45458: LD_ADDR_VAR 0 2
45462: PUSH
45463: LD_VAR 0 2
45467: PPUSH
45468: LD_INT 3
45470: PPUSH
45471: LD_VAR 0 11
45475: PPUSH
45476: CALL_OW 1
45480: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
45481: LD_VAR 0 4
45485: PUSH
45486: LD_INT 6
45488: GREATER
45489: PUSH
45490: LD_VAR 0 6
45494: PUSH
45495: LD_INT 6
45497: LESS
45498: AND
45499: IFFALSE 45693
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
45501: LD_ADDR_VAR 0 9
45505: PUSH
45506: LD_VAR 0 4
45510: PUSH
45511: LD_VAR 0 8
45515: PUSH
45516: LD_VAR 0 7
45520: UNION
45521: PUSH
45522: LD_VAR 0 6
45526: UNION
45527: DIFF
45528: PPUSH
45529: LD_INT 2
45531: PPUSH
45532: CALL 105639 0 2
45536: ST_TO_ADDR
// p := [ ] ;
45537: LD_ADDR_VAR 0 11
45541: PUSH
45542: EMPTY
45543: ST_TO_ADDR
// if sort then
45544: LD_VAR 0 9
45548: IFFALSE 45664
// for i = 1 to 6 - eng do
45550: LD_ADDR_VAR 0 3
45554: PUSH
45555: DOUBLE
45556: LD_INT 1
45558: DEC
45559: ST_TO_ADDR
45560: LD_INT 6
45562: PUSH
45563: LD_VAR 0 6
45567: MINUS
45568: PUSH
45569: FOR_TO
45570: IFFALSE 45662
// begin if i = sort then
45572: LD_VAR 0 3
45576: PUSH
45577: LD_VAR 0 9
45581: EQUAL
45582: IFFALSE 45586
// break ;
45584: GO 45662
// if GetClass ( i ) = 2 then
45586: LD_VAR 0 3
45590: PPUSH
45591: CALL_OW 257
45595: PUSH
45596: LD_INT 2
45598: EQUAL
45599: IFFALSE 45603
// continue ;
45601: GO 45569
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45603: LD_ADDR_VAR 0 11
45607: PUSH
45608: LD_VAR 0 11
45612: PPUSH
45613: LD_VAR 0 11
45617: PUSH
45618: LD_INT 1
45620: PLUS
45621: PPUSH
45622: LD_VAR 0 9
45626: PUSH
45627: LD_VAR 0 3
45631: ARRAY
45632: PPUSH
45633: CALL_OW 2
45637: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45638: LD_ADDR_VAR 0 4
45642: PUSH
45643: LD_VAR 0 4
45647: PUSH
45648: LD_VAR 0 9
45652: PUSH
45653: LD_VAR 0 3
45657: ARRAY
45658: DIFF
45659: ST_TO_ADDR
// end ;
45660: GO 45569
45662: POP
45663: POP
// if p then
45664: LD_VAR 0 11
45668: IFFALSE 45693
// result := Replace ( result , 2 , p ) ;
45670: LD_ADDR_VAR 0 2
45674: PUSH
45675: LD_VAR 0 2
45679: PPUSH
45680: LD_INT 2
45682: PPUSH
45683: LD_VAR 0 11
45687: PPUSH
45688: CALL_OW 1
45692: ST_TO_ADDR
// end ; exit ;
45693: GO 47081
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
45695: LD_EXP 128
45699: PUSH
45700: LD_EXP 127
45704: PUSH
45705: LD_VAR 0 1
45709: ARRAY
45710: ARRAY
45711: NOT
45712: PUSH
45713: LD_EXP 101
45717: PUSH
45718: LD_VAR 0 1
45722: ARRAY
45723: PPUSH
45724: LD_INT 30
45726: PUSH
45727: LD_INT 3
45729: PUSH
45730: EMPTY
45731: LIST
45732: LIST
45733: PPUSH
45734: CALL_OW 72
45738: AND
45739: PUSH
45740: LD_EXP 106
45744: PUSH
45745: LD_VAR 0 1
45749: ARRAY
45750: AND
45751: IFFALSE 46359
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
45753: LD_ADDR_EXP 143
45757: PUSH
45758: LD_EXP 143
45762: PPUSH
45763: LD_VAR 0 1
45767: PPUSH
45768: LD_INT 5
45770: PPUSH
45771: CALL_OW 1
45775: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
45776: LD_ADDR_VAR 0 2
45780: PUSH
45781: LD_INT 0
45783: PUSH
45784: LD_INT 0
45786: PUSH
45787: LD_INT 0
45789: PUSH
45790: LD_INT 0
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: LIST
45797: LIST
45798: ST_TO_ADDR
// if sci > 1 then
45799: LD_VAR 0 8
45803: PUSH
45804: LD_INT 1
45806: GREATER
45807: IFFALSE 45835
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
45809: LD_ADDR_VAR 0 4
45813: PUSH
45814: LD_VAR 0 4
45818: PUSH
45819: LD_VAR 0 8
45823: PUSH
45824: LD_VAR 0 8
45828: PUSH
45829: LD_INT 1
45831: ARRAY
45832: DIFF
45833: DIFF
45834: ST_TO_ADDR
// if tmp and not sci then
45835: LD_VAR 0 4
45839: PUSH
45840: LD_VAR 0 8
45844: NOT
45845: AND
45846: IFFALSE 45915
// begin sort := SortBySkill ( tmp , 4 ) ;
45848: LD_ADDR_VAR 0 9
45852: PUSH
45853: LD_VAR 0 4
45857: PPUSH
45858: LD_INT 4
45860: PPUSH
45861: CALL 105639 0 2
45865: ST_TO_ADDR
// if sort then
45866: LD_VAR 0 9
45870: IFFALSE 45886
// p := sort [ 1 ] ;
45872: LD_ADDR_VAR 0 11
45876: PUSH
45877: LD_VAR 0 9
45881: PUSH
45882: LD_INT 1
45884: ARRAY
45885: ST_TO_ADDR
// if p then
45886: LD_VAR 0 11
45890: IFFALSE 45915
// result := Replace ( result , 4 , p ) ;
45892: LD_ADDR_VAR 0 2
45896: PUSH
45897: LD_VAR 0 2
45901: PPUSH
45902: LD_INT 4
45904: PPUSH
45905: LD_VAR 0 11
45909: PPUSH
45910: CALL_OW 1
45914: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
45915: LD_ADDR_VAR 0 4
45919: PUSH
45920: LD_VAR 0 4
45924: PUSH
45925: LD_VAR 0 7
45929: DIFF
45930: ST_TO_ADDR
// if tmp and mech < 6 then
45931: LD_VAR 0 4
45935: PUSH
45936: LD_VAR 0 7
45940: PUSH
45941: LD_INT 6
45943: LESS
45944: AND
45945: IFFALSE 46133
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
45947: LD_ADDR_VAR 0 9
45951: PUSH
45952: LD_VAR 0 4
45956: PUSH
45957: LD_VAR 0 8
45961: PUSH
45962: LD_VAR 0 7
45966: UNION
45967: DIFF
45968: PPUSH
45969: LD_INT 3
45971: PPUSH
45972: CALL 105639 0 2
45976: ST_TO_ADDR
// p := [ ] ;
45977: LD_ADDR_VAR 0 11
45981: PUSH
45982: EMPTY
45983: ST_TO_ADDR
// if sort then
45984: LD_VAR 0 9
45988: IFFALSE 46104
// for i = 1 to 6 - mech do
45990: LD_ADDR_VAR 0 3
45994: PUSH
45995: DOUBLE
45996: LD_INT 1
45998: DEC
45999: ST_TO_ADDR
46000: LD_INT 6
46002: PUSH
46003: LD_VAR 0 7
46007: MINUS
46008: PUSH
46009: FOR_TO
46010: IFFALSE 46102
// begin if i = sort then
46012: LD_VAR 0 3
46016: PUSH
46017: LD_VAR 0 9
46021: EQUAL
46022: IFFALSE 46026
// break ;
46024: GO 46102
// if GetClass ( i ) = 3 then
46026: LD_VAR 0 3
46030: PPUSH
46031: CALL_OW 257
46035: PUSH
46036: LD_INT 3
46038: EQUAL
46039: IFFALSE 46043
// continue ;
46041: GO 46009
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46043: LD_ADDR_VAR 0 11
46047: PUSH
46048: LD_VAR 0 11
46052: PPUSH
46053: LD_VAR 0 11
46057: PUSH
46058: LD_INT 1
46060: PLUS
46061: PPUSH
46062: LD_VAR 0 9
46066: PUSH
46067: LD_VAR 0 3
46071: ARRAY
46072: PPUSH
46073: CALL_OW 2
46077: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46078: LD_ADDR_VAR 0 4
46082: PUSH
46083: LD_VAR 0 4
46087: PUSH
46088: LD_VAR 0 9
46092: PUSH
46093: LD_VAR 0 3
46097: ARRAY
46098: DIFF
46099: ST_TO_ADDR
// end ;
46100: GO 46009
46102: POP
46103: POP
// if p then
46104: LD_VAR 0 11
46108: IFFALSE 46133
// result := Replace ( result , 3 , p ) ;
46110: LD_ADDR_VAR 0 2
46114: PUSH
46115: LD_VAR 0 2
46119: PPUSH
46120: LD_INT 3
46122: PPUSH
46123: LD_VAR 0 11
46127: PPUSH
46128: CALL_OW 1
46132: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
46133: LD_ADDR_VAR 0 4
46137: PUSH
46138: LD_VAR 0 4
46142: PUSH
46143: LD_VAR 0 6
46147: DIFF
46148: ST_TO_ADDR
// if tmp and eng < 6 then
46149: LD_VAR 0 4
46153: PUSH
46154: LD_VAR 0 6
46158: PUSH
46159: LD_INT 6
46161: LESS
46162: AND
46163: IFFALSE 46357
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
46165: LD_ADDR_VAR 0 9
46169: PUSH
46170: LD_VAR 0 4
46174: PUSH
46175: LD_VAR 0 8
46179: PUSH
46180: LD_VAR 0 7
46184: UNION
46185: PUSH
46186: LD_VAR 0 6
46190: UNION
46191: DIFF
46192: PPUSH
46193: LD_INT 2
46195: PPUSH
46196: CALL 105639 0 2
46200: ST_TO_ADDR
// p := [ ] ;
46201: LD_ADDR_VAR 0 11
46205: PUSH
46206: EMPTY
46207: ST_TO_ADDR
// if sort then
46208: LD_VAR 0 9
46212: IFFALSE 46328
// for i = 1 to 6 - eng do
46214: LD_ADDR_VAR 0 3
46218: PUSH
46219: DOUBLE
46220: LD_INT 1
46222: DEC
46223: ST_TO_ADDR
46224: LD_INT 6
46226: PUSH
46227: LD_VAR 0 6
46231: MINUS
46232: PUSH
46233: FOR_TO
46234: IFFALSE 46326
// begin if i = sort then
46236: LD_VAR 0 3
46240: PUSH
46241: LD_VAR 0 9
46245: EQUAL
46246: IFFALSE 46250
// break ;
46248: GO 46326
// if GetClass ( i ) = 2 then
46250: LD_VAR 0 3
46254: PPUSH
46255: CALL_OW 257
46259: PUSH
46260: LD_INT 2
46262: EQUAL
46263: IFFALSE 46267
// continue ;
46265: GO 46233
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46267: LD_ADDR_VAR 0 11
46271: PUSH
46272: LD_VAR 0 11
46276: PPUSH
46277: LD_VAR 0 11
46281: PUSH
46282: LD_INT 1
46284: PLUS
46285: PPUSH
46286: LD_VAR 0 9
46290: PUSH
46291: LD_VAR 0 3
46295: ARRAY
46296: PPUSH
46297: CALL_OW 2
46301: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46302: LD_ADDR_VAR 0 4
46306: PUSH
46307: LD_VAR 0 4
46311: PUSH
46312: LD_VAR 0 9
46316: PUSH
46317: LD_VAR 0 3
46321: ARRAY
46322: DIFF
46323: ST_TO_ADDR
// end ;
46324: GO 46233
46326: POP
46327: POP
// if p then
46328: LD_VAR 0 11
46332: IFFALSE 46357
// result := Replace ( result , 2 , p ) ;
46334: LD_ADDR_VAR 0 2
46338: PUSH
46339: LD_VAR 0 2
46343: PPUSH
46344: LD_INT 2
46346: PPUSH
46347: LD_VAR 0 11
46351: PPUSH
46352: CALL_OW 1
46356: ST_TO_ADDR
// end ; exit ;
46357: GO 47081
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
46359: LD_EXP 128
46363: PUSH
46364: LD_EXP 127
46368: PUSH
46369: LD_VAR 0 1
46373: ARRAY
46374: ARRAY
46375: NOT
46376: PUSH
46377: LD_EXP 101
46381: PUSH
46382: LD_VAR 0 1
46386: ARRAY
46387: PPUSH
46388: LD_INT 30
46390: PUSH
46391: LD_INT 3
46393: PUSH
46394: EMPTY
46395: LIST
46396: LIST
46397: PPUSH
46398: CALL_OW 72
46402: AND
46403: PUSH
46404: LD_EXP 106
46408: PUSH
46409: LD_VAR 0 1
46413: ARRAY
46414: NOT
46415: AND
46416: IFFALSE 47081
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
46418: LD_ADDR_EXP 143
46422: PUSH
46423: LD_EXP 143
46427: PPUSH
46428: LD_VAR 0 1
46432: PPUSH
46433: LD_INT 6
46435: PPUSH
46436: CALL_OW 1
46440: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
46441: LD_ADDR_VAR 0 2
46445: PUSH
46446: LD_INT 0
46448: PUSH
46449: LD_INT 0
46451: PUSH
46452: LD_INT 0
46454: PUSH
46455: LD_INT 0
46457: PUSH
46458: EMPTY
46459: LIST
46460: LIST
46461: LIST
46462: LIST
46463: ST_TO_ADDR
// if sci >= 1 then
46464: LD_VAR 0 8
46468: PUSH
46469: LD_INT 1
46471: GREATEREQUAL
46472: IFFALSE 46494
// tmp := tmp diff sci [ 1 ] ;
46474: LD_ADDR_VAR 0 4
46478: PUSH
46479: LD_VAR 0 4
46483: PUSH
46484: LD_VAR 0 8
46488: PUSH
46489: LD_INT 1
46491: ARRAY
46492: DIFF
46493: ST_TO_ADDR
// if tmp and not sci then
46494: LD_VAR 0 4
46498: PUSH
46499: LD_VAR 0 8
46503: NOT
46504: AND
46505: IFFALSE 46574
// begin sort := SortBySkill ( tmp , 4 ) ;
46507: LD_ADDR_VAR 0 9
46511: PUSH
46512: LD_VAR 0 4
46516: PPUSH
46517: LD_INT 4
46519: PPUSH
46520: CALL 105639 0 2
46524: ST_TO_ADDR
// if sort then
46525: LD_VAR 0 9
46529: IFFALSE 46545
// p := sort [ 1 ] ;
46531: LD_ADDR_VAR 0 11
46535: PUSH
46536: LD_VAR 0 9
46540: PUSH
46541: LD_INT 1
46543: ARRAY
46544: ST_TO_ADDR
// if p then
46545: LD_VAR 0 11
46549: IFFALSE 46574
// result := Replace ( result , 4 , p ) ;
46551: LD_ADDR_VAR 0 2
46555: PUSH
46556: LD_VAR 0 2
46560: PPUSH
46561: LD_INT 4
46563: PPUSH
46564: LD_VAR 0 11
46568: PPUSH
46569: CALL_OW 1
46573: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
46574: LD_ADDR_VAR 0 4
46578: PUSH
46579: LD_VAR 0 4
46583: PUSH
46584: LD_VAR 0 7
46588: DIFF
46589: ST_TO_ADDR
// if tmp and mech < 6 then
46590: LD_VAR 0 4
46594: PUSH
46595: LD_VAR 0 7
46599: PUSH
46600: LD_INT 6
46602: LESS
46603: AND
46604: IFFALSE 46786
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
46606: LD_ADDR_VAR 0 9
46610: PUSH
46611: LD_VAR 0 4
46615: PUSH
46616: LD_VAR 0 7
46620: DIFF
46621: PPUSH
46622: LD_INT 3
46624: PPUSH
46625: CALL 105639 0 2
46629: ST_TO_ADDR
// p := [ ] ;
46630: LD_ADDR_VAR 0 11
46634: PUSH
46635: EMPTY
46636: ST_TO_ADDR
// if sort then
46637: LD_VAR 0 9
46641: IFFALSE 46757
// for i = 1 to 6 - mech do
46643: LD_ADDR_VAR 0 3
46647: PUSH
46648: DOUBLE
46649: LD_INT 1
46651: DEC
46652: ST_TO_ADDR
46653: LD_INT 6
46655: PUSH
46656: LD_VAR 0 7
46660: MINUS
46661: PUSH
46662: FOR_TO
46663: IFFALSE 46755
// begin if i = sort then
46665: LD_VAR 0 3
46669: PUSH
46670: LD_VAR 0 9
46674: EQUAL
46675: IFFALSE 46679
// break ;
46677: GO 46755
// if GetClass ( i ) = 3 then
46679: LD_VAR 0 3
46683: PPUSH
46684: CALL_OW 257
46688: PUSH
46689: LD_INT 3
46691: EQUAL
46692: IFFALSE 46696
// continue ;
46694: GO 46662
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46696: LD_ADDR_VAR 0 11
46700: PUSH
46701: LD_VAR 0 11
46705: PPUSH
46706: LD_VAR 0 11
46710: PUSH
46711: LD_INT 1
46713: PLUS
46714: PPUSH
46715: LD_VAR 0 9
46719: PUSH
46720: LD_VAR 0 3
46724: ARRAY
46725: PPUSH
46726: CALL_OW 2
46730: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46731: LD_ADDR_VAR 0 4
46735: PUSH
46736: LD_VAR 0 4
46740: PUSH
46741: LD_VAR 0 9
46745: PUSH
46746: LD_VAR 0 3
46750: ARRAY
46751: DIFF
46752: ST_TO_ADDR
// end ;
46753: GO 46662
46755: POP
46756: POP
// if p then
46757: LD_VAR 0 11
46761: IFFALSE 46786
// result := Replace ( result , 3 , p ) ;
46763: LD_ADDR_VAR 0 2
46767: PUSH
46768: LD_VAR 0 2
46772: PPUSH
46773: LD_INT 3
46775: PPUSH
46776: LD_VAR 0 11
46780: PPUSH
46781: CALL_OW 1
46785: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
46786: LD_ADDR_VAR 0 4
46790: PUSH
46791: LD_VAR 0 4
46795: PUSH
46796: LD_VAR 0 6
46800: DIFF
46801: ST_TO_ADDR
// if tmp and eng < 4 then
46802: LD_VAR 0 4
46806: PUSH
46807: LD_VAR 0 6
46811: PUSH
46812: LD_INT 4
46814: LESS
46815: AND
46816: IFFALSE 47006
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
46818: LD_ADDR_VAR 0 9
46822: PUSH
46823: LD_VAR 0 4
46827: PUSH
46828: LD_VAR 0 7
46832: PUSH
46833: LD_VAR 0 6
46837: UNION
46838: DIFF
46839: PPUSH
46840: LD_INT 2
46842: PPUSH
46843: CALL 105639 0 2
46847: ST_TO_ADDR
// p := [ ] ;
46848: LD_ADDR_VAR 0 11
46852: PUSH
46853: EMPTY
46854: ST_TO_ADDR
// if sort then
46855: LD_VAR 0 9
46859: IFFALSE 46975
// for i = 1 to 4 - eng do
46861: LD_ADDR_VAR 0 3
46865: PUSH
46866: DOUBLE
46867: LD_INT 1
46869: DEC
46870: ST_TO_ADDR
46871: LD_INT 4
46873: PUSH
46874: LD_VAR 0 6
46878: MINUS
46879: PUSH
46880: FOR_TO
46881: IFFALSE 46973
// begin if i = sort then
46883: LD_VAR 0 3
46887: PUSH
46888: LD_VAR 0 9
46892: EQUAL
46893: IFFALSE 46897
// break ;
46895: GO 46973
// if GetClass ( i ) = 2 then
46897: LD_VAR 0 3
46901: PPUSH
46902: CALL_OW 257
46906: PUSH
46907: LD_INT 2
46909: EQUAL
46910: IFFALSE 46914
// continue ;
46912: GO 46880
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46914: LD_ADDR_VAR 0 11
46918: PUSH
46919: LD_VAR 0 11
46923: PPUSH
46924: LD_VAR 0 11
46928: PUSH
46929: LD_INT 1
46931: PLUS
46932: PPUSH
46933: LD_VAR 0 9
46937: PUSH
46938: LD_VAR 0 3
46942: ARRAY
46943: PPUSH
46944: CALL_OW 2
46948: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46949: LD_ADDR_VAR 0 4
46953: PUSH
46954: LD_VAR 0 4
46958: PUSH
46959: LD_VAR 0 9
46963: PUSH
46964: LD_VAR 0 3
46968: ARRAY
46969: DIFF
46970: ST_TO_ADDR
// end ;
46971: GO 46880
46973: POP
46974: POP
// if p then
46975: LD_VAR 0 11
46979: IFFALSE 47004
// result := Replace ( result , 2 , p ) ;
46981: LD_ADDR_VAR 0 2
46985: PUSH
46986: LD_VAR 0 2
46990: PPUSH
46991: LD_INT 2
46993: PPUSH
46994: LD_VAR 0 11
46998: PPUSH
46999: CALL_OW 1
47003: ST_TO_ADDR
// end else
47004: GO 47050
// for i = eng downto 5 do
47006: LD_ADDR_VAR 0 3
47010: PUSH
47011: DOUBLE
47012: LD_VAR 0 6
47016: INC
47017: ST_TO_ADDR
47018: LD_INT 5
47020: PUSH
47021: FOR_DOWNTO
47022: IFFALSE 47048
// tmp := tmp union eng [ i ] ;
47024: LD_ADDR_VAR 0 4
47028: PUSH
47029: LD_VAR 0 4
47033: PUSH
47034: LD_VAR 0 6
47038: PUSH
47039: LD_VAR 0 3
47043: ARRAY
47044: UNION
47045: ST_TO_ADDR
47046: GO 47021
47048: POP
47049: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
47050: LD_ADDR_VAR 0 2
47054: PUSH
47055: LD_VAR 0 2
47059: PPUSH
47060: LD_INT 1
47062: PPUSH
47063: LD_VAR 0 4
47067: PUSH
47068: LD_VAR 0 5
47072: DIFF
47073: PPUSH
47074: CALL_OW 1
47078: ST_TO_ADDR
// exit ;
47079: GO 47081
// end ; end ;
47081: LD_VAR 0 2
47085: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
47086: LD_INT 0
47088: PPUSH
47089: PPUSH
47090: PPUSH
// if not mc_bases then
47091: LD_EXP 101
47095: NOT
47096: IFFALSE 47100
// exit ;
47098: GO 47242
// for i = 1 to mc_bases do
47100: LD_ADDR_VAR 0 2
47104: PUSH
47105: DOUBLE
47106: LD_INT 1
47108: DEC
47109: ST_TO_ADDR
47110: LD_EXP 101
47114: PUSH
47115: FOR_TO
47116: IFFALSE 47233
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
47118: LD_ADDR_VAR 0 3
47122: PUSH
47123: LD_EXP 101
47127: PUSH
47128: LD_VAR 0 2
47132: ARRAY
47133: PPUSH
47134: LD_INT 21
47136: PUSH
47137: LD_INT 3
47139: PUSH
47140: EMPTY
47141: LIST
47142: LIST
47143: PUSH
47144: LD_INT 3
47146: PUSH
47147: LD_INT 2
47149: PUSH
47150: LD_INT 30
47152: PUSH
47153: LD_INT 29
47155: PUSH
47156: EMPTY
47157: LIST
47158: LIST
47159: PUSH
47160: LD_INT 30
47162: PUSH
47163: LD_INT 30
47165: PUSH
47166: EMPTY
47167: LIST
47168: LIST
47169: PUSH
47170: EMPTY
47171: LIST
47172: LIST
47173: LIST
47174: PUSH
47175: EMPTY
47176: LIST
47177: LIST
47178: PUSH
47179: LD_INT 3
47181: PUSH
47182: LD_INT 24
47184: PUSH
47185: LD_INT 1000
47187: PUSH
47188: EMPTY
47189: LIST
47190: LIST
47191: PUSH
47192: EMPTY
47193: LIST
47194: LIST
47195: PUSH
47196: EMPTY
47197: LIST
47198: LIST
47199: LIST
47200: PPUSH
47201: CALL_OW 72
47205: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
47206: LD_ADDR_EXP 102
47210: PUSH
47211: LD_EXP 102
47215: PPUSH
47216: LD_VAR 0 2
47220: PPUSH
47221: LD_VAR 0 3
47225: PPUSH
47226: CALL_OW 1
47230: ST_TO_ADDR
// end ;
47231: GO 47115
47233: POP
47234: POP
// RaiseSailEvent ( 101 ) ;
47235: LD_INT 101
47237: PPUSH
47238: CALL_OW 427
// end ;
47242: LD_VAR 0 1
47246: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
47247: LD_INT 0
47249: PPUSH
47250: PPUSH
47251: PPUSH
47252: PPUSH
47253: PPUSH
47254: PPUSH
47255: PPUSH
// if not mc_bases then
47256: LD_EXP 101
47260: NOT
47261: IFFALSE 47265
// exit ;
47263: GO 47827
// for i = 1 to mc_bases do
47265: LD_ADDR_VAR 0 2
47269: PUSH
47270: DOUBLE
47271: LD_INT 1
47273: DEC
47274: ST_TO_ADDR
47275: LD_EXP 101
47279: PUSH
47280: FOR_TO
47281: IFFALSE 47818
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
47283: LD_ADDR_VAR 0 5
47287: PUSH
47288: LD_EXP 101
47292: PUSH
47293: LD_VAR 0 2
47297: ARRAY
47298: PUSH
47299: LD_EXP 130
47303: PUSH
47304: LD_VAR 0 2
47308: ARRAY
47309: UNION
47310: PPUSH
47311: LD_INT 21
47313: PUSH
47314: LD_INT 1
47316: PUSH
47317: EMPTY
47318: LIST
47319: LIST
47320: PUSH
47321: LD_INT 1
47323: PUSH
47324: LD_INT 3
47326: PUSH
47327: LD_INT 54
47329: PUSH
47330: EMPTY
47331: LIST
47332: PUSH
47333: EMPTY
47334: LIST
47335: LIST
47336: PUSH
47337: LD_INT 3
47339: PUSH
47340: LD_INT 24
47342: PUSH
47343: LD_INT 1000
47345: PUSH
47346: EMPTY
47347: LIST
47348: LIST
47349: PUSH
47350: EMPTY
47351: LIST
47352: LIST
47353: PUSH
47354: EMPTY
47355: LIST
47356: LIST
47357: LIST
47358: PUSH
47359: EMPTY
47360: LIST
47361: LIST
47362: PPUSH
47363: CALL_OW 72
47367: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
47368: LD_ADDR_VAR 0 6
47372: PUSH
47373: LD_EXP 101
47377: PUSH
47378: LD_VAR 0 2
47382: ARRAY
47383: PPUSH
47384: LD_INT 21
47386: PUSH
47387: LD_INT 1
47389: PUSH
47390: EMPTY
47391: LIST
47392: LIST
47393: PUSH
47394: LD_INT 1
47396: PUSH
47397: LD_INT 3
47399: PUSH
47400: LD_INT 54
47402: PUSH
47403: EMPTY
47404: LIST
47405: PUSH
47406: EMPTY
47407: LIST
47408: LIST
47409: PUSH
47410: LD_INT 3
47412: PUSH
47413: LD_INT 24
47415: PUSH
47416: LD_INT 250
47418: PUSH
47419: EMPTY
47420: LIST
47421: LIST
47422: PUSH
47423: EMPTY
47424: LIST
47425: LIST
47426: PUSH
47427: EMPTY
47428: LIST
47429: LIST
47430: LIST
47431: PUSH
47432: EMPTY
47433: LIST
47434: LIST
47435: PPUSH
47436: CALL_OW 72
47440: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
47441: LD_ADDR_VAR 0 7
47445: PUSH
47446: LD_VAR 0 5
47450: PUSH
47451: LD_VAR 0 6
47455: DIFF
47456: ST_TO_ADDR
// if not need_heal_1 then
47457: LD_VAR 0 6
47461: NOT
47462: IFFALSE 47495
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
47464: LD_ADDR_EXP 104
47468: PUSH
47469: LD_EXP 104
47473: PPUSH
47474: LD_VAR 0 2
47478: PUSH
47479: LD_INT 1
47481: PUSH
47482: EMPTY
47483: LIST
47484: LIST
47485: PPUSH
47486: EMPTY
47487: PPUSH
47488: CALL 74406 0 3
47492: ST_TO_ADDR
47493: GO 47565
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
47495: LD_ADDR_EXP 104
47499: PUSH
47500: LD_EXP 104
47504: PPUSH
47505: LD_VAR 0 2
47509: PUSH
47510: LD_INT 1
47512: PUSH
47513: EMPTY
47514: LIST
47515: LIST
47516: PPUSH
47517: LD_EXP 104
47521: PUSH
47522: LD_VAR 0 2
47526: ARRAY
47527: PUSH
47528: LD_INT 1
47530: ARRAY
47531: PPUSH
47532: LD_INT 3
47534: PUSH
47535: LD_INT 24
47537: PUSH
47538: LD_INT 1000
47540: PUSH
47541: EMPTY
47542: LIST
47543: LIST
47544: PUSH
47545: EMPTY
47546: LIST
47547: LIST
47548: PPUSH
47549: CALL_OW 72
47553: PUSH
47554: LD_VAR 0 6
47558: UNION
47559: PPUSH
47560: CALL 74406 0 3
47564: ST_TO_ADDR
// if not need_heal_2 then
47565: LD_VAR 0 7
47569: NOT
47570: IFFALSE 47603
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
47572: LD_ADDR_EXP 104
47576: PUSH
47577: LD_EXP 104
47581: PPUSH
47582: LD_VAR 0 2
47586: PUSH
47587: LD_INT 2
47589: PUSH
47590: EMPTY
47591: LIST
47592: LIST
47593: PPUSH
47594: EMPTY
47595: PPUSH
47596: CALL 74406 0 3
47600: ST_TO_ADDR
47601: GO 47635
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
47603: LD_ADDR_EXP 104
47607: PUSH
47608: LD_EXP 104
47612: PPUSH
47613: LD_VAR 0 2
47617: PUSH
47618: LD_INT 2
47620: PUSH
47621: EMPTY
47622: LIST
47623: LIST
47624: PPUSH
47625: LD_VAR 0 7
47629: PPUSH
47630: CALL 74406 0 3
47634: ST_TO_ADDR
// if need_heal_2 then
47635: LD_VAR 0 7
47639: IFFALSE 47800
// for j in need_heal_2 do
47641: LD_ADDR_VAR 0 3
47645: PUSH
47646: LD_VAR 0 7
47650: PUSH
47651: FOR_IN
47652: IFFALSE 47798
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47654: LD_ADDR_VAR 0 5
47658: PUSH
47659: LD_EXP 101
47663: PUSH
47664: LD_VAR 0 2
47668: ARRAY
47669: PPUSH
47670: LD_INT 2
47672: PUSH
47673: LD_INT 30
47675: PUSH
47676: LD_INT 6
47678: PUSH
47679: EMPTY
47680: LIST
47681: LIST
47682: PUSH
47683: LD_INT 30
47685: PUSH
47686: LD_INT 7
47688: PUSH
47689: EMPTY
47690: LIST
47691: LIST
47692: PUSH
47693: LD_INT 30
47695: PUSH
47696: LD_INT 8
47698: PUSH
47699: EMPTY
47700: LIST
47701: LIST
47702: PUSH
47703: LD_INT 30
47705: PUSH
47706: LD_INT 0
47708: PUSH
47709: EMPTY
47710: LIST
47711: LIST
47712: PUSH
47713: LD_INT 30
47715: PUSH
47716: LD_INT 1
47718: PUSH
47719: EMPTY
47720: LIST
47721: LIST
47722: PUSH
47723: EMPTY
47724: LIST
47725: LIST
47726: LIST
47727: LIST
47728: LIST
47729: LIST
47730: PPUSH
47731: CALL_OW 72
47735: ST_TO_ADDR
// if tmp then
47736: LD_VAR 0 5
47740: IFFALSE 47796
// begin k := NearestUnitToUnit ( tmp , j ) ;
47742: LD_ADDR_VAR 0 4
47746: PUSH
47747: LD_VAR 0 5
47751: PPUSH
47752: LD_VAR 0 3
47756: PPUSH
47757: CALL_OW 74
47761: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
47762: LD_VAR 0 3
47766: PPUSH
47767: LD_VAR 0 4
47771: PPUSH
47772: CALL_OW 296
47776: PUSH
47777: LD_INT 5
47779: GREATER
47780: IFFALSE 47796
// ComMoveToNearbyEntrance ( j , k ) ;
47782: LD_VAR 0 3
47786: PPUSH
47787: LD_VAR 0 4
47791: PPUSH
47792: CALL 108012 0 2
// end ; end ;
47796: GO 47651
47798: POP
47799: POP
// if not need_heal_1 and not need_heal_2 then
47800: LD_VAR 0 6
47804: NOT
47805: PUSH
47806: LD_VAR 0 7
47810: NOT
47811: AND
47812: IFFALSE 47816
// continue ;
47814: GO 47280
// end ;
47816: GO 47280
47818: POP
47819: POP
// RaiseSailEvent ( 102 ) ;
47820: LD_INT 102
47822: PPUSH
47823: CALL_OW 427
// end ;
47827: LD_VAR 0 1
47831: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
47832: LD_INT 0
47834: PPUSH
47835: PPUSH
47836: PPUSH
47837: PPUSH
47838: PPUSH
47839: PPUSH
47840: PPUSH
47841: PPUSH
// if not mc_bases then
47842: LD_EXP 101
47846: NOT
47847: IFFALSE 47851
// exit ;
47849: GO 48762
// for i = 1 to mc_bases do
47851: LD_ADDR_VAR 0 2
47855: PUSH
47856: DOUBLE
47857: LD_INT 1
47859: DEC
47860: ST_TO_ADDR
47861: LD_EXP 101
47865: PUSH
47866: FOR_TO
47867: IFFALSE 48760
// begin if not mc_building_need_repair [ i ] then
47869: LD_EXP 102
47873: PUSH
47874: LD_VAR 0 2
47878: ARRAY
47879: NOT
47880: IFFALSE 48065
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
47882: LD_ADDR_VAR 0 6
47886: PUSH
47887: LD_EXP 120
47891: PUSH
47892: LD_VAR 0 2
47896: ARRAY
47897: PPUSH
47898: LD_INT 3
47900: PUSH
47901: LD_INT 24
47903: PUSH
47904: LD_INT 1000
47906: PUSH
47907: EMPTY
47908: LIST
47909: LIST
47910: PUSH
47911: EMPTY
47912: LIST
47913: LIST
47914: PUSH
47915: LD_INT 2
47917: PUSH
47918: LD_INT 34
47920: PUSH
47921: LD_INT 13
47923: PUSH
47924: EMPTY
47925: LIST
47926: LIST
47927: PUSH
47928: LD_INT 34
47930: PUSH
47931: LD_INT 52
47933: PUSH
47934: EMPTY
47935: LIST
47936: LIST
47937: PUSH
47938: LD_INT 34
47940: PUSH
47941: LD_INT 88
47943: PUSH
47944: EMPTY
47945: LIST
47946: LIST
47947: PUSH
47948: EMPTY
47949: LIST
47950: LIST
47951: LIST
47952: LIST
47953: PUSH
47954: EMPTY
47955: LIST
47956: LIST
47957: PPUSH
47958: CALL_OW 72
47962: ST_TO_ADDR
// if cranes then
47963: LD_VAR 0 6
47967: IFFALSE 48029
// for j in cranes do
47969: LD_ADDR_VAR 0 3
47973: PUSH
47974: LD_VAR 0 6
47978: PUSH
47979: FOR_IN
47980: IFFALSE 48027
// if not IsInArea ( j , mc_parking [ i ] ) then
47982: LD_VAR 0 3
47986: PPUSH
47987: LD_EXP 125
47991: PUSH
47992: LD_VAR 0 2
47996: ARRAY
47997: PPUSH
47998: CALL_OW 308
48002: NOT
48003: IFFALSE 48025
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48005: LD_VAR 0 3
48009: PPUSH
48010: LD_EXP 125
48014: PUSH
48015: LD_VAR 0 2
48019: ARRAY
48020: PPUSH
48021: CALL_OW 113
48025: GO 47979
48027: POP
48028: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
48029: LD_ADDR_EXP 103
48033: PUSH
48034: LD_EXP 103
48038: PPUSH
48039: LD_VAR 0 2
48043: PPUSH
48044: EMPTY
48045: PPUSH
48046: CALL_OW 1
48050: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
48051: LD_VAR 0 2
48055: PPUSH
48056: LD_INT 101
48058: PPUSH
48059: CALL 42905 0 2
// continue ;
48063: GO 47866
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
48065: LD_ADDR_EXP 107
48069: PUSH
48070: LD_EXP 107
48074: PPUSH
48075: LD_VAR 0 2
48079: PPUSH
48080: EMPTY
48081: PPUSH
48082: CALL_OW 1
48086: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
48087: LD_VAR 0 2
48091: PPUSH
48092: LD_INT 103
48094: PPUSH
48095: CALL 42905 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
48099: LD_ADDR_VAR 0 5
48103: PUSH
48104: LD_EXP 101
48108: PUSH
48109: LD_VAR 0 2
48113: ARRAY
48114: PUSH
48115: LD_EXP 130
48119: PUSH
48120: LD_VAR 0 2
48124: ARRAY
48125: UNION
48126: PPUSH
48127: LD_INT 2
48129: PUSH
48130: LD_INT 25
48132: PUSH
48133: LD_INT 2
48135: PUSH
48136: EMPTY
48137: LIST
48138: LIST
48139: PUSH
48140: LD_INT 25
48142: PUSH
48143: LD_INT 16
48145: PUSH
48146: EMPTY
48147: LIST
48148: LIST
48149: PUSH
48150: EMPTY
48151: LIST
48152: LIST
48153: LIST
48154: PUSH
48155: EMPTY
48156: LIST
48157: PPUSH
48158: CALL_OW 72
48162: ST_TO_ADDR
// if mc_need_heal [ i ] then
48163: LD_EXP 104
48167: PUSH
48168: LD_VAR 0 2
48172: ARRAY
48173: IFFALSE 48217
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
48175: LD_ADDR_VAR 0 5
48179: PUSH
48180: LD_VAR 0 5
48184: PUSH
48185: LD_EXP 104
48189: PUSH
48190: LD_VAR 0 2
48194: ARRAY
48195: PUSH
48196: LD_INT 1
48198: ARRAY
48199: PUSH
48200: LD_EXP 104
48204: PUSH
48205: LD_VAR 0 2
48209: ARRAY
48210: PUSH
48211: LD_INT 2
48213: ARRAY
48214: UNION
48215: DIFF
48216: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
48217: LD_ADDR_VAR 0 6
48221: PUSH
48222: LD_EXP 120
48226: PUSH
48227: LD_VAR 0 2
48231: ARRAY
48232: PPUSH
48233: LD_INT 2
48235: PUSH
48236: LD_INT 34
48238: PUSH
48239: LD_INT 13
48241: PUSH
48242: EMPTY
48243: LIST
48244: LIST
48245: PUSH
48246: LD_INT 34
48248: PUSH
48249: LD_INT 52
48251: PUSH
48252: EMPTY
48253: LIST
48254: LIST
48255: PUSH
48256: LD_INT 34
48258: PUSH
48259: LD_INT 88
48261: PUSH
48262: EMPTY
48263: LIST
48264: LIST
48265: PUSH
48266: EMPTY
48267: LIST
48268: LIST
48269: LIST
48270: LIST
48271: PPUSH
48272: CALL_OW 72
48276: ST_TO_ADDR
// if cranes then
48277: LD_VAR 0 6
48281: IFFALSE 48449
// begin for j in cranes do
48283: LD_ADDR_VAR 0 3
48287: PUSH
48288: LD_VAR 0 6
48292: PUSH
48293: FOR_IN
48294: IFFALSE 48447
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
48296: LD_VAR 0 3
48300: PPUSH
48301: CALL_OW 256
48305: PUSH
48306: LD_INT 1000
48308: EQUAL
48309: PUSH
48310: LD_VAR 0 3
48314: PPUSH
48315: CALL_OW 314
48319: NOT
48320: AND
48321: IFFALSE 48387
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
48323: LD_ADDR_VAR 0 8
48327: PUSH
48328: LD_EXP 102
48332: PUSH
48333: LD_VAR 0 2
48337: ARRAY
48338: PPUSH
48339: LD_VAR 0 3
48343: PPUSH
48344: CALL_OW 74
48348: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
48349: LD_VAR 0 8
48353: PPUSH
48354: LD_INT 16
48356: PPUSH
48357: CALL 77371 0 2
48361: PUSH
48362: LD_INT 4
48364: ARRAY
48365: PUSH
48366: LD_INT 10
48368: LESS
48369: IFFALSE 48385
// ComRepairBuilding ( j , to_repair ) ;
48371: LD_VAR 0 3
48375: PPUSH
48376: LD_VAR 0 8
48380: PPUSH
48381: CALL_OW 130
// end else
48385: GO 48445
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
48387: LD_VAR 0 3
48391: PPUSH
48392: CALL_OW 256
48396: PUSH
48397: LD_INT 500
48399: LESS
48400: PUSH
48401: LD_VAR 0 3
48405: PPUSH
48406: LD_EXP 125
48410: PUSH
48411: LD_VAR 0 2
48415: ARRAY
48416: PPUSH
48417: CALL_OW 308
48421: NOT
48422: AND
48423: IFFALSE 48445
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48425: LD_VAR 0 3
48429: PPUSH
48430: LD_EXP 125
48434: PUSH
48435: LD_VAR 0 2
48439: ARRAY
48440: PPUSH
48441: CALL_OW 113
// end ;
48445: GO 48293
48447: POP
48448: POP
// end ; if tmp > 3 then
48449: LD_VAR 0 5
48453: PUSH
48454: LD_INT 3
48456: GREATER
48457: IFFALSE 48477
// tmp := ShrinkArray ( tmp , 4 ) ;
48459: LD_ADDR_VAR 0 5
48463: PUSH
48464: LD_VAR 0 5
48468: PPUSH
48469: LD_INT 4
48471: PPUSH
48472: CALL 107450 0 2
48476: ST_TO_ADDR
// if not tmp then
48477: LD_VAR 0 5
48481: NOT
48482: IFFALSE 48486
// continue ;
48484: GO 47866
// for j in tmp do
48486: LD_ADDR_VAR 0 3
48490: PUSH
48491: LD_VAR 0 5
48495: PUSH
48496: FOR_IN
48497: IFFALSE 48756
// begin if IsInUnit ( j ) then
48499: LD_VAR 0 3
48503: PPUSH
48504: CALL_OW 310
48508: IFFALSE 48519
// ComExitBuilding ( j ) ;
48510: LD_VAR 0 3
48514: PPUSH
48515: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
48519: LD_VAR 0 3
48523: PUSH
48524: LD_EXP 103
48528: PUSH
48529: LD_VAR 0 2
48533: ARRAY
48534: IN
48535: NOT
48536: IFFALSE 48594
// begin SetTag ( j , 101 ) ;
48538: LD_VAR 0 3
48542: PPUSH
48543: LD_INT 101
48545: PPUSH
48546: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
48550: LD_ADDR_EXP 103
48554: PUSH
48555: LD_EXP 103
48559: PPUSH
48560: LD_VAR 0 2
48564: PUSH
48565: LD_EXP 103
48569: PUSH
48570: LD_VAR 0 2
48574: ARRAY
48575: PUSH
48576: LD_INT 1
48578: PLUS
48579: PUSH
48580: EMPTY
48581: LIST
48582: LIST
48583: PPUSH
48584: LD_VAR 0 3
48588: PPUSH
48589: CALL 74406 0 3
48593: ST_TO_ADDR
// end ; wait ( 1 ) ;
48594: LD_INT 1
48596: PPUSH
48597: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
48601: LD_ADDR_VAR 0 7
48605: PUSH
48606: LD_EXP 102
48610: PUSH
48611: LD_VAR 0 2
48615: ARRAY
48616: ST_TO_ADDR
// if mc_scan [ i ] then
48617: LD_EXP 124
48621: PUSH
48622: LD_VAR 0 2
48626: ARRAY
48627: IFFALSE 48689
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
48629: LD_ADDR_VAR 0 7
48633: PUSH
48634: LD_EXP 102
48638: PUSH
48639: LD_VAR 0 2
48643: ARRAY
48644: PPUSH
48645: LD_INT 3
48647: PUSH
48648: LD_INT 30
48650: PUSH
48651: LD_INT 32
48653: PUSH
48654: EMPTY
48655: LIST
48656: LIST
48657: PUSH
48658: LD_INT 30
48660: PUSH
48661: LD_INT 33
48663: PUSH
48664: EMPTY
48665: LIST
48666: LIST
48667: PUSH
48668: LD_INT 30
48670: PUSH
48671: LD_INT 31
48673: PUSH
48674: EMPTY
48675: LIST
48676: LIST
48677: PUSH
48678: EMPTY
48679: LIST
48680: LIST
48681: LIST
48682: LIST
48683: PPUSH
48684: CALL_OW 72
48688: ST_TO_ADDR
// if not to_repair_tmp then
48689: LD_VAR 0 7
48693: NOT
48694: IFFALSE 48698
// continue ;
48696: GO 48496
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
48698: LD_ADDR_VAR 0 8
48702: PUSH
48703: LD_VAR 0 7
48707: PPUSH
48708: LD_VAR 0 3
48712: PPUSH
48713: CALL_OW 74
48717: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
48718: LD_VAR 0 8
48722: PPUSH
48723: LD_INT 16
48725: PPUSH
48726: CALL 77371 0 2
48730: PUSH
48731: LD_INT 4
48733: ARRAY
48734: PUSH
48735: LD_INT 14
48737: LESS
48738: IFFALSE 48754
// ComRepairBuilding ( j , to_repair ) ;
48740: LD_VAR 0 3
48744: PPUSH
48745: LD_VAR 0 8
48749: PPUSH
48750: CALL_OW 130
// end ;
48754: GO 48496
48756: POP
48757: POP
// end ;
48758: GO 47866
48760: POP
48761: POP
// end ;
48762: LD_VAR 0 1
48766: RET
// export function MC_Heal ; var i , j , tmp ; begin
48767: LD_INT 0
48769: PPUSH
48770: PPUSH
48771: PPUSH
48772: PPUSH
// if not mc_bases then
48773: LD_EXP 101
48777: NOT
48778: IFFALSE 48782
// exit ;
48780: GO 49184
// for i = 1 to mc_bases do
48782: LD_ADDR_VAR 0 2
48786: PUSH
48787: DOUBLE
48788: LD_INT 1
48790: DEC
48791: ST_TO_ADDR
48792: LD_EXP 101
48796: PUSH
48797: FOR_TO
48798: IFFALSE 49182
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
48800: LD_EXP 104
48804: PUSH
48805: LD_VAR 0 2
48809: ARRAY
48810: PUSH
48811: LD_INT 1
48813: ARRAY
48814: NOT
48815: PUSH
48816: LD_EXP 104
48820: PUSH
48821: LD_VAR 0 2
48825: ARRAY
48826: PUSH
48827: LD_INT 2
48829: ARRAY
48830: NOT
48831: AND
48832: IFFALSE 48870
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
48834: LD_ADDR_EXP 105
48838: PUSH
48839: LD_EXP 105
48843: PPUSH
48844: LD_VAR 0 2
48848: PPUSH
48849: EMPTY
48850: PPUSH
48851: CALL_OW 1
48855: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
48856: LD_VAR 0 2
48860: PPUSH
48861: LD_INT 102
48863: PPUSH
48864: CALL 42905 0 2
// continue ;
48868: GO 48797
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
48870: LD_ADDR_VAR 0 4
48874: PUSH
48875: LD_EXP 101
48879: PUSH
48880: LD_VAR 0 2
48884: ARRAY
48885: PPUSH
48886: LD_INT 25
48888: PUSH
48889: LD_INT 4
48891: PUSH
48892: EMPTY
48893: LIST
48894: LIST
48895: PPUSH
48896: CALL_OW 72
48900: ST_TO_ADDR
// if not tmp then
48901: LD_VAR 0 4
48905: NOT
48906: IFFALSE 48910
// continue ;
48908: GO 48797
// if mc_taming [ i ] then
48910: LD_EXP 132
48914: PUSH
48915: LD_VAR 0 2
48919: ARRAY
48920: IFFALSE 48944
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
48922: LD_ADDR_EXP 132
48926: PUSH
48927: LD_EXP 132
48931: PPUSH
48932: LD_VAR 0 2
48936: PPUSH
48937: EMPTY
48938: PPUSH
48939: CALL_OW 1
48943: ST_TO_ADDR
// for j in tmp do
48944: LD_ADDR_VAR 0 3
48948: PUSH
48949: LD_VAR 0 4
48953: PUSH
48954: FOR_IN
48955: IFFALSE 49178
// begin if IsInUnit ( j ) then
48957: LD_VAR 0 3
48961: PPUSH
48962: CALL_OW 310
48966: IFFALSE 48977
// ComExitBuilding ( j ) ;
48968: LD_VAR 0 3
48972: PPUSH
48973: CALL_OW 122
// if not j in mc_healers [ i ] then
48977: LD_VAR 0 3
48981: PUSH
48982: LD_EXP 105
48986: PUSH
48987: LD_VAR 0 2
48991: ARRAY
48992: IN
48993: NOT
48994: IFFALSE 49040
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
48996: LD_ADDR_EXP 105
49000: PUSH
49001: LD_EXP 105
49005: PPUSH
49006: LD_VAR 0 2
49010: PUSH
49011: LD_EXP 105
49015: PUSH
49016: LD_VAR 0 2
49020: ARRAY
49021: PUSH
49022: LD_INT 1
49024: PLUS
49025: PUSH
49026: EMPTY
49027: LIST
49028: LIST
49029: PPUSH
49030: LD_VAR 0 3
49034: PPUSH
49035: CALL 74406 0 3
49039: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
49040: LD_VAR 0 3
49044: PPUSH
49045: CALL_OW 110
49049: PUSH
49050: LD_INT 102
49052: NONEQUAL
49053: IFFALSE 49067
// SetTag ( j , 102 ) ;
49055: LD_VAR 0 3
49059: PPUSH
49060: LD_INT 102
49062: PPUSH
49063: CALL_OW 109
// Wait ( 3 ) ;
49067: LD_INT 3
49069: PPUSH
49070: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
49074: LD_EXP 104
49078: PUSH
49079: LD_VAR 0 2
49083: ARRAY
49084: PUSH
49085: LD_INT 1
49087: ARRAY
49088: IFFALSE 49120
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
49090: LD_VAR 0 3
49094: PPUSH
49095: LD_EXP 104
49099: PUSH
49100: LD_VAR 0 2
49104: ARRAY
49105: PUSH
49106: LD_INT 1
49108: ARRAY
49109: PUSH
49110: LD_INT 1
49112: ARRAY
49113: PPUSH
49114: CALL_OW 128
49118: GO 49176
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
49120: LD_VAR 0 3
49124: PPUSH
49125: CALL_OW 314
49129: NOT
49130: PUSH
49131: LD_EXP 104
49135: PUSH
49136: LD_VAR 0 2
49140: ARRAY
49141: PUSH
49142: LD_INT 2
49144: ARRAY
49145: AND
49146: IFFALSE 49176
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
49148: LD_VAR 0 3
49152: PPUSH
49153: LD_EXP 104
49157: PUSH
49158: LD_VAR 0 2
49162: ARRAY
49163: PUSH
49164: LD_INT 2
49166: ARRAY
49167: PUSH
49168: LD_INT 1
49170: ARRAY
49171: PPUSH
49172: CALL_OW 128
// end ;
49176: GO 48954
49178: POP
49179: POP
// end ;
49180: GO 48797
49182: POP
49183: POP
// end ;
49184: LD_VAR 0 1
49188: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
49189: LD_INT 0
49191: PPUSH
49192: PPUSH
49193: PPUSH
49194: PPUSH
49195: PPUSH
49196: PPUSH
// if not mc_bases then
49197: LD_EXP 101
49201: NOT
49202: IFFALSE 49206
// exit ;
49204: GO 50369
// for i = 1 to mc_bases do
49206: LD_ADDR_VAR 0 2
49210: PUSH
49211: DOUBLE
49212: LD_INT 1
49214: DEC
49215: ST_TO_ADDR
49216: LD_EXP 101
49220: PUSH
49221: FOR_TO
49222: IFFALSE 50367
// begin if mc_scan [ i ] then
49224: LD_EXP 124
49228: PUSH
49229: LD_VAR 0 2
49233: ARRAY
49234: IFFALSE 49238
// continue ;
49236: GO 49221
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
49238: LD_EXP 106
49242: PUSH
49243: LD_VAR 0 2
49247: ARRAY
49248: NOT
49249: PUSH
49250: LD_EXP 108
49254: PUSH
49255: LD_VAR 0 2
49259: ARRAY
49260: NOT
49261: AND
49262: PUSH
49263: LD_EXP 107
49267: PUSH
49268: LD_VAR 0 2
49272: ARRAY
49273: AND
49274: IFFALSE 49312
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
49276: LD_ADDR_EXP 107
49280: PUSH
49281: LD_EXP 107
49285: PPUSH
49286: LD_VAR 0 2
49290: PPUSH
49291: EMPTY
49292: PPUSH
49293: CALL_OW 1
49297: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
49298: LD_VAR 0 2
49302: PPUSH
49303: LD_INT 103
49305: PPUSH
49306: CALL 42905 0 2
// continue ;
49310: GO 49221
// end ; if mc_construct_list [ i ] then
49312: LD_EXP 108
49316: PUSH
49317: LD_VAR 0 2
49321: ARRAY
49322: IFFALSE 49542
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
49324: LD_ADDR_VAR 0 5
49328: PUSH
49329: LD_EXP 101
49333: PUSH
49334: LD_VAR 0 2
49338: ARRAY
49339: PPUSH
49340: LD_INT 25
49342: PUSH
49343: LD_INT 2
49345: PUSH
49346: EMPTY
49347: LIST
49348: LIST
49349: PPUSH
49350: CALL_OW 72
49354: PUSH
49355: LD_EXP 103
49359: PUSH
49360: LD_VAR 0 2
49364: ARRAY
49365: DIFF
49366: ST_TO_ADDR
// if not tmp then
49367: LD_VAR 0 5
49371: NOT
49372: IFFALSE 49376
// continue ;
49374: GO 49221
// for j in tmp do
49376: LD_ADDR_VAR 0 3
49380: PUSH
49381: LD_VAR 0 5
49385: PUSH
49386: FOR_IN
49387: IFFALSE 49538
// begin if not mc_builders [ i ] then
49389: LD_EXP 107
49393: PUSH
49394: LD_VAR 0 2
49398: ARRAY
49399: NOT
49400: IFFALSE 49458
// begin SetTag ( j , 103 ) ;
49402: LD_VAR 0 3
49406: PPUSH
49407: LD_INT 103
49409: PPUSH
49410: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
49414: LD_ADDR_EXP 107
49418: PUSH
49419: LD_EXP 107
49423: PPUSH
49424: LD_VAR 0 2
49428: PUSH
49429: LD_EXP 107
49433: PUSH
49434: LD_VAR 0 2
49438: ARRAY
49439: PUSH
49440: LD_INT 1
49442: PLUS
49443: PUSH
49444: EMPTY
49445: LIST
49446: LIST
49447: PPUSH
49448: LD_VAR 0 3
49452: PPUSH
49453: CALL 74406 0 3
49457: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
49458: LD_VAR 0 3
49462: PPUSH
49463: CALL_OW 310
49467: IFFALSE 49478
// ComExitBuilding ( j ) ;
49469: LD_VAR 0 3
49473: PPUSH
49474: CALL_OW 122
// wait ( 3 ) ;
49478: LD_INT 3
49480: PPUSH
49481: CALL_OW 67
// if not mc_construct_list [ i ] then
49485: LD_EXP 108
49489: PUSH
49490: LD_VAR 0 2
49494: ARRAY
49495: NOT
49496: IFFALSE 49500
// break ;
49498: GO 49538
// if not HasTask ( j ) then
49500: LD_VAR 0 3
49504: PPUSH
49505: CALL_OW 314
49509: NOT
49510: IFFALSE 49536
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
49512: LD_VAR 0 3
49516: PPUSH
49517: LD_EXP 108
49521: PUSH
49522: LD_VAR 0 2
49526: ARRAY
49527: PUSH
49528: LD_INT 1
49530: ARRAY
49531: PPUSH
49532: CALL 77644 0 2
// end ;
49536: GO 49386
49538: POP
49539: POP
// end else
49540: GO 50365
// if mc_build_list [ i ] then
49542: LD_EXP 106
49546: PUSH
49547: LD_VAR 0 2
49551: ARRAY
49552: IFFALSE 50365
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
49554: LD_EXP 106
49558: PUSH
49559: LD_VAR 0 2
49563: ARRAY
49564: PUSH
49565: LD_INT 1
49567: ARRAY
49568: PUSH
49569: LD_INT 1
49571: ARRAY
49572: PPUSH
49573: CALL 77468 0 1
49577: PUSH
49578: LD_EXP 101
49582: PUSH
49583: LD_VAR 0 2
49587: ARRAY
49588: PPUSH
49589: LD_INT 2
49591: PUSH
49592: LD_INT 30
49594: PUSH
49595: LD_INT 2
49597: PUSH
49598: EMPTY
49599: LIST
49600: LIST
49601: PUSH
49602: LD_INT 30
49604: PUSH
49605: LD_INT 3
49607: PUSH
49608: EMPTY
49609: LIST
49610: LIST
49611: PUSH
49612: EMPTY
49613: LIST
49614: LIST
49615: LIST
49616: PPUSH
49617: CALL_OW 72
49621: NOT
49622: AND
49623: IFFALSE 49728
// begin for j = 1 to mc_build_list [ i ] do
49625: LD_ADDR_VAR 0 3
49629: PUSH
49630: DOUBLE
49631: LD_INT 1
49633: DEC
49634: ST_TO_ADDR
49635: LD_EXP 106
49639: PUSH
49640: LD_VAR 0 2
49644: ARRAY
49645: PUSH
49646: FOR_TO
49647: IFFALSE 49726
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
49649: LD_EXP 106
49653: PUSH
49654: LD_VAR 0 2
49658: ARRAY
49659: PUSH
49660: LD_VAR 0 3
49664: ARRAY
49665: PUSH
49666: LD_INT 1
49668: ARRAY
49669: PUSH
49670: LD_INT 2
49672: EQUAL
49673: IFFALSE 49724
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
49675: LD_ADDR_EXP 106
49679: PUSH
49680: LD_EXP 106
49684: PPUSH
49685: LD_VAR 0 2
49689: PPUSH
49690: LD_EXP 106
49694: PUSH
49695: LD_VAR 0 2
49699: ARRAY
49700: PPUSH
49701: LD_VAR 0 3
49705: PPUSH
49706: LD_INT 1
49708: PPUSH
49709: LD_INT 0
49711: PPUSH
49712: CALL 73824 0 4
49716: PPUSH
49717: CALL_OW 1
49721: ST_TO_ADDR
// break ;
49722: GO 49726
// end ;
49724: GO 49646
49726: POP
49727: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49728: LD_ADDR_VAR 0 6
49732: PUSH
49733: LD_EXP 101
49737: PUSH
49738: LD_VAR 0 2
49742: ARRAY
49743: PPUSH
49744: LD_INT 2
49746: PUSH
49747: LD_INT 30
49749: PUSH
49750: LD_INT 0
49752: PUSH
49753: EMPTY
49754: LIST
49755: LIST
49756: PUSH
49757: LD_INT 30
49759: PUSH
49760: LD_INT 1
49762: PUSH
49763: EMPTY
49764: LIST
49765: LIST
49766: PUSH
49767: EMPTY
49768: LIST
49769: LIST
49770: LIST
49771: PPUSH
49772: CALL_OW 72
49776: ST_TO_ADDR
// for k := 1 to depot do
49777: LD_ADDR_VAR 0 4
49781: PUSH
49782: DOUBLE
49783: LD_INT 1
49785: DEC
49786: ST_TO_ADDR
49787: LD_VAR 0 6
49791: PUSH
49792: FOR_TO
49793: IFFALSE 50363
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
49795: LD_EXP 106
49799: PUSH
49800: LD_VAR 0 2
49804: ARRAY
49805: PUSH
49806: LD_INT 1
49808: ARRAY
49809: PUSH
49810: LD_INT 1
49812: ARRAY
49813: PUSH
49814: LD_INT 0
49816: EQUAL
49817: PUSH
49818: LD_VAR 0 6
49822: PUSH
49823: LD_VAR 0 4
49827: ARRAY
49828: PPUSH
49829: LD_EXP 106
49833: PUSH
49834: LD_VAR 0 2
49838: ARRAY
49839: PUSH
49840: LD_INT 1
49842: ARRAY
49843: PUSH
49844: LD_INT 1
49846: ARRAY
49847: PPUSH
49848: LD_EXP 106
49852: PUSH
49853: LD_VAR 0 2
49857: ARRAY
49858: PUSH
49859: LD_INT 1
49861: ARRAY
49862: PUSH
49863: LD_INT 2
49865: ARRAY
49866: PPUSH
49867: LD_EXP 106
49871: PUSH
49872: LD_VAR 0 2
49876: ARRAY
49877: PUSH
49878: LD_INT 1
49880: ARRAY
49881: PUSH
49882: LD_INT 3
49884: ARRAY
49885: PPUSH
49886: LD_EXP 106
49890: PUSH
49891: LD_VAR 0 2
49895: ARRAY
49896: PUSH
49897: LD_INT 1
49899: ARRAY
49900: PUSH
49901: LD_INT 4
49903: ARRAY
49904: PPUSH
49905: CALL 82880 0 5
49909: OR
49910: IFFALSE 50191
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
49912: LD_ADDR_VAR 0 5
49916: PUSH
49917: LD_EXP 101
49921: PUSH
49922: LD_VAR 0 2
49926: ARRAY
49927: PPUSH
49928: LD_INT 25
49930: PUSH
49931: LD_INT 2
49933: PUSH
49934: EMPTY
49935: LIST
49936: LIST
49937: PPUSH
49938: CALL_OW 72
49942: PUSH
49943: LD_EXP 103
49947: PUSH
49948: LD_VAR 0 2
49952: ARRAY
49953: DIFF
49954: ST_TO_ADDR
// if not tmp then
49955: LD_VAR 0 5
49959: NOT
49960: IFFALSE 49964
// continue ;
49962: GO 49792
// for j in tmp do
49964: LD_ADDR_VAR 0 3
49968: PUSH
49969: LD_VAR 0 5
49973: PUSH
49974: FOR_IN
49975: IFFALSE 50187
// begin if not mc_builders [ i ] then
49977: LD_EXP 107
49981: PUSH
49982: LD_VAR 0 2
49986: ARRAY
49987: NOT
49988: IFFALSE 50046
// begin SetTag ( j , 103 ) ;
49990: LD_VAR 0 3
49994: PPUSH
49995: LD_INT 103
49997: PPUSH
49998: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
50002: LD_ADDR_EXP 107
50006: PUSH
50007: LD_EXP 107
50011: PPUSH
50012: LD_VAR 0 2
50016: PUSH
50017: LD_EXP 107
50021: PUSH
50022: LD_VAR 0 2
50026: ARRAY
50027: PUSH
50028: LD_INT 1
50030: PLUS
50031: PUSH
50032: EMPTY
50033: LIST
50034: LIST
50035: PPUSH
50036: LD_VAR 0 3
50040: PPUSH
50041: CALL 74406 0 3
50045: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
50046: LD_VAR 0 3
50050: PPUSH
50051: CALL_OW 310
50055: IFFALSE 50066
// ComExitBuilding ( j ) ;
50057: LD_VAR 0 3
50061: PPUSH
50062: CALL_OW 122
// wait ( 3 ) ;
50066: LD_INT 3
50068: PPUSH
50069: CALL_OW 67
// if not mc_build_list [ i ] then
50073: LD_EXP 106
50077: PUSH
50078: LD_VAR 0 2
50082: ARRAY
50083: NOT
50084: IFFALSE 50088
// break ;
50086: GO 50187
// if not HasTask ( j ) then
50088: LD_VAR 0 3
50092: PPUSH
50093: CALL_OW 314
50097: NOT
50098: IFFALSE 50185
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
50100: LD_VAR 0 3
50104: PPUSH
50105: LD_EXP 106
50109: PUSH
50110: LD_VAR 0 2
50114: ARRAY
50115: PUSH
50116: LD_INT 1
50118: ARRAY
50119: PUSH
50120: LD_INT 1
50122: ARRAY
50123: PPUSH
50124: LD_EXP 106
50128: PUSH
50129: LD_VAR 0 2
50133: ARRAY
50134: PUSH
50135: LD_INT 1
50137: ARRAY
50138: PUSH
50139: LD_INT 2
50141: ARRAY
50142: PPUSH
50143: LD_EXP 106
50147: PUSH
50148: LD_VAR 0 2
50152: ARRAY
50153: PUSH
50154: LD_INT 1
50156: ARRAY
50157: PUSH
50158: LD_INT 3
50160: ARRAY
50161: PPUSH
50162: LD_EXP 106
50166: PUSH
50167: LD_VAR 0 2
50171: ARRAY
50172: PUSH
50173: LD_INT 1
50175: ARRAY
50176: PUSH
50177: LD_INT 4
50179: ARRAY
50180: PPUSH
50181: CALL_OW 145
// end ;
50185: GO 49974
50187: POP
50188: POP
// end else
50189: GO 50361
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
50191: LD_EXP 101
50195: PUSH
50196: LD_VAR 0 2
50200: ARRAY
50201: PPUSH
50202: LD_EXP 106
50206: PUSH
50207: LD_VAR 0 2
50211: ARRAY
50212: PUSH
50213: LD_INT 1
50215: ARRAY
50216: PUSH
50217: LD_INT 1
50219: ARRAY
50220: PPUSH
50221: LD_EXP 106
50225: PUSH
50226: LD_VAR 0 2
50230: ARRAY
50231: PUSH
50232: LD_INT 1
50234: ARRAY
50235: PUSH
50236: LD_INT 2
50238: ARRAY
50239: PPUSH
50240: LD_EXP 106
50244: PUSH
50245: LD_VAR 0 2
50249: ARRAY
50250: PUSH
50251: LD_INT 1
50253: ARRAY
50254: PUSH
50255: LD_INT 3
50257: ARRAY
50258: PPUSH
50259: LD_EXP 106
50263: PUSH
50264: LD_VAR 0 2
50268: ARRAY
50269: PUSH
50270: LD_INT 1
50272: ARRAY
50273: PUSH
50274: LD_INT 4
50276: ARRAY
50277: PPUSH
50278: LD_EXP 101
50282: PUSH
50283: LD_VAR 0 2
50287: ARRAY
50288: PPUSH
50289: LD_INT 21
50291: PUSH
50292: LD_INT 3
50294: PUSH
50295: EMPTY
50296: LIST
50297: LIST
50298: PPUSH
50299: CALL_OW 72
50303: PPUSH
50304: EMPTY
50305: PPUSH
50306: CALL 81634 0 7
50310: NOT
50311: IFFALSE 50361
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
50313: LD_ADDR_EXP 106
50317: PUSH
50318: LD_EXP 106
50322: PPUSH
50323: LD_VAR 0 2
50327: PPUSH
50328: LD_EXP 106
50332: PUSH
50333: LD_VAR 0 2
50337: ARRAY
50338: PPUSH
50339: LD_INT 1
50341: PPUSH
50342: LD_INT 1
50344: NEG
50345: PPUSH
50346: LD_INT 0
50348: PPUSH
50349: CALL 73824 0 4
50353: PPUSH
50354: CALL_OW 1
50358: ST_TO_ADDR
// continue ;
50359: GO 49792
// end ; end ;
50361: GO 49792
50363: POP
50364: POP
// end ; end ;
50365: GO 49221
50367: POP
50368: POP
// end ;
50369: LD_VAR 0 1
50373: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
50374: LD_INT 0
50376: PPUSH
50377: PPUSH
50378: PPUSH
50379: PPUSH
50380: PPUSH
50381: PPUSH
// if not mc_bases then
50382: LD_EXP 101
50386: NOT
50387: IFFALSE 50391
// exit ;
50389: GO 50818
// for i = 1 to mc_bases do
50391: LD_ADDR_VAR 0 2
50395: PUSH
50396: DOUBLE
50397: LD_INT 1
50399: DEC
50400: ST_TO_ADDR
50401: LD_EXP 101
50405: PUSH
50406: FOR_TO
50407: IFFALSE 50816
// begin tmp := mc_build_upgrade [ i ] ;
50409: LD_ADDR_VAR 0 4
50413: PUSH
50414: LD_EXP 133
50418: PUSH
50419: LD_VAR 0 2
50423: ARRAY
50424: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
50425: LD_ADDR_VAR 0 6
50429: PUSH
50430: LD_EXP 134
50434: PUSH
50435: LD_VAR 0 2
50439: ARRAY
50440: PPUSH
50441: LD_INT 2
50443: PUSH
50444: LD_INT 30
50446: PUSH
50447: LD_INT 6
50449: PUSH
50450: EMPTY
50451: LIST
50452: LIST
50453: PUSH
50454: LD_INT 30
50456: PUSH
50457: LD_INT 7
50459: PUSH
50460: EMPTY
50461: LIST
50462: LIST
50463: PUSH
50464: EMPTY
50465: LIST
50466: LIST
50467: LIST
50468: PPUSH
50469: CALL_OW 72
50473: ST_TO_ADDR
// if not tmp and not lab then
50474: LD_VAR 0 4
50478: NOT
50479: PUSH
50480: LD_VAR 0 6
50484: NOT
50485: AND
50486: IFFALSE 50490
// continue ;
50488: GO 50406
// if tmp then
50490: LD_VAR 0 4
50494: IFFALSE 50614
// for j in tmp do
50496: LD_ADDR_VAR 0 3
50500: PUSH
50501: LD_VAR 0 4
50505: PUSH
50506: FOR_IN
50507: IFFALSE 50612
// begin if UpgradeCost ( j ) then
50509: LD_VAR 0 3
50513: PPUSH
50514: CALL 81294 0 1
50518: IFFALSE 50610
// begin ComUpgrade ( j ) ;
50520: LD_VAR 0 3
50524: PPUSH
50525: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
50529: LD_ADDR_EXP 133
50533: PUSH
50534: LD_EXP 133
50538: PPUSH
50539: LD_VAR 0 2
50543: PPUSH
50544: LD_EXP 133
50548: PUSH
50549: LD_VAR 0 2
50553: ARRAY
50554: PUSH
50555: LD_VAR 0 3
50559: DIFF
50560: PPUSH
50561: CALL_OW 1
50565: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
50566: LD_ADDR_EXP 108
50570: PUSH
50571: LD_EXP 108
50575: PPUSH
50576: LD_VAR 0 2
50580: PUSH
50581: LD_EXP 108
50585: PUSH
50586: LD_VAR 0 2
50590: ARRAY
50591: PUSH
50592: LD_INT 1
50594: PLUS
50595: PUSH
50596: EMPTY
50597: LIST
50598: LIST
50599: PPUSH
50600: LD_VAR 0 3
50604: PPUSH
50605: CALL 74406 0 3
50609: ST_TO_ADDR
// end ; end ;
50610: GO 50506
50612: POP
50613: POP
// if not lab or not mc_lab_upgrade [ i ] then
50614: LD_VAR 0 6
50618: NOT
50619: PUSH
50620: LD_EXP 135
50624: PUSH
50625: LD_VAR 0 2
50629: ARRAY
50630: NOT
50631: OR
50632: IFFALSE 50636
// continue ;
50634: GO 50406
// for j in lab do
50636: LD_ADDR_VAR 0 3
50640: PUSH
50641: LD_VAR 0 6
50645: PUSH
50646: FOR_IN
50647: IFFALSE 50812
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
50649: LD_VAR 0 3
50653: PPUSH
50654: CALL_OW 266
50658: PUSH
50659: LD_INT 6
50661: PUSH
50662: LD_INT 7
50664: PUSH
50665: EMPTY
50666: LIST
50667: LIST
50668: IN
50669: PUSH
50670: LD_VAR 0 3
50674: PPUSH
50675: CALL_OW 461
50679: PUSH
50680: LD_INT 1
50682: NONEQUAL
50683: AND
50684: IFFALSE 50810
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
50686: LD_VAR 0 3
50690: PPUSH
50691: LD_EXP 135
50695: PUSH
50696: LD_VAR 0 2
50700: ARRAY
50701: PUSH
50702: LD_INT 1
50704: ARRAY
50705: PPUSH
50706: CALL 81499 0 2
50710: IFFALSE 50810
// begin ComCancel ( j ) ;
50712: LD_VAR 0 3
50716: PPUSH
50717: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
50721: LD_VAR 0 3
50725: PPUSH
50726: LD_EXP 135
50730: PUSH
50731: LD_VAR 0 2
50735: ARRAY
50736: PUSH
50737: LD_INT 1
50739: ARRAY
50740: PPUSH
50741: CALL_OW 207
// if not j in mc_construct_list [ i ] then
50745: LD_VAR 0 3
50749: PUSH
50750: LD_EXP 108
50754: PUSH
50755: LD_VAR 0 2
50759: ARRAY
50760: IN
50761: NOT
50762: IFFALSE 50808
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
50764: LD_ADDR_EXP 108
50768: PUSH
50769: LD_EXP 108
50773: PPUSH
50774: LD_VAR 0 2
50778: PUSH
50779: LD_EXP 108
50783: PUSH
50784: LD_VAR 0 2
50788: ARRAY
50789: PUSH
50790: LD_INT 1
50792: PLUS
50793: PUSH
50794: EMPTY
50795: LIST
50796: LIST
50797: PPUSH
50798: LD_VAR 0 3
50802: PPUSH
50803: CALL 74406 0 3
50807: ST_TO_ADDR
// break ;
50808: GO 50812
// end ; end ; end ;
50810: GO 50646
50812: POP
50813: POP
// end ;
50814: GO 50406
50816: POP
50817: POP
// end ;
50818: LD_VAR 0 1
50822: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
50823: LD_INT 0
50825: PPUSH
50826: PPUSH
50827: PPUSH
50828: PPUSH
50829: PPUSH
50830: PPUSH
50831: PPUSH
50832: PPUSH
50833: PPUSH
// if not mc_bases then
50834: LD_EXP 101
50838: NOT
50839: IFFALSE 50843
// exit ;
50841: GO 51248
// for i = 1 to mc_bases do
50843: LD_ADDR_VAR 0 2
50847: PUSH
50848: DOUBLE
50849: LD_INT 1
50851: DEC
50852: ST_TO_ADDR
50853: LD_EXP 101
50857: PUSH
50858: FOR_TO
50859: IFFALSE 51246
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
50861: LD_EXP 109
50865: PUSH
50866: LD_VAR 0 2
50870: ARRAY
50871: NOT
50872: PUSH
50873: LD_EXP 101
50877: PUSH
50878: LD_VAR 0 2
50882: ARRAY
50883: PPUSH
50884: LD_INT 30
50886: PUSH
50887: LD_INT 3
50889: PUSH
50890: EMPTY
50891: LIST
50892: LIST
50893: PPUSH
50894: CALL_OW 72
50898: NOT
50899: OR
50900: IFFALSE 50904
// continue ;
50902: GO 50858
// busy := false ;
50904: LD_ADDR_VAR 0 8
50908: PUSH
50909: LD_INT 0
50911: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50912: LD_ADDR_VAR 0 4
50916: PUSH
50917: LD_EXP 101
50921: PUSH
50922: LD_VAR 0 2
50926: ARRAY
50927: PPUSH
50928: LD_INT 30
50930: PUSH
50931: LD_INT 3
50933: PUSH
50934: EMPTY
50935: LIST
50936: LIST
50937: PPUSH
50938: CALL_OW 72
50942: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
50943: LD_ADDR_VAR 0 6
50947: PUSH
50948: LD_EXP 109
50952: PUSH
50953: LD_VAR 0 2
50957: ARRAY
50958: PPUSH
50959: LD_INT 2
50961: PUSH
50962: LD_INT 30
50964: PUSH
50965: LD_INT 32
50967: PUSH
50968: EMPTY
50969: LIST
50970: LIST
50971: PUSH
50972: LD_INT 30
50974: PUSH
50975: LD_INT 33
50977: PUSH
50978: EMPTY
50979: LIST
50980: LIST
50981: PUSH
50982: EMPTY
50983: LIST
50984: LIST
50985: LIST
50986: PPUSH
50987: CALL_OW 72
50991: ST_TO_ADDR
// if not t then
50992: LD_VAR 0 6
50996: NOT
50997: IFFALSE 51001
// continue ;
50999: GO 50858
// for j in tmp do
51001: LD_ADDR_VAR 0 3
51005: PUSH
51006: LD_VAR 0 4
51010: PUSH
51011: FOR_IN
51012: IFFALSE 51042
// if not BuildingStatus ( j ) = bs_idle then
51014: LD_VAR 0 3
51018: PPUSH
51019: CALL_OW 461
51023: PUSH
51024: LD_INT 2
51026: EQUAL
51027: NOT
51028: IFFALSE 51040
// begin busy := true ;
51030: LD_ADDR_VAR 0 8
51034: PUSH
51035: LD_INT 1
51037: ST_TO_ADDR
// break ;
51038: GO 51042
// end ;
51040: GO 51011
51042: POP
51043: POP
// if busy then
51044: LD_VAR 0 8
51048: IFFALSE 51052
// continue ;
51050: GO 50858
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
51052: LD_ADDR_VAR 0 7
51056: PUSH
51057: LD_VAR 0 6
51061: PPUSH
51062: LD_INT 35
51064: PUSH
51065: LD_INT 0
51067: PUSH
51068: EMPTY
51069: LIST
51070: LIST
51071: PPUSH
51072: CALL_OW 72
51076: ST_TO_ADDR
// if tw then
51077: LD_VAR 0 7
51081: IFFALSE 51158
// begin tw := tw [ 1 ] ;
51083: LD_ADDR_VAR 0 7
51087: PUSH
51088: LD_VAR 0 7
51092: PUSH
51093: LD_INT 1
51095: ARRAY
51096: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
51097: LD_ADDR_VAR 0 9
51101: PUSH
51102: LD_VAR 0 7
51106: PPUSH
51107: LD_EXP 126
51111: PUSH
51112: LD_VAR 0 2
51116: ARRAY
51117: PPUSH
51118: CALL 79791 0 2
51122: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
51123: LD_EXP 140
51127: PUSH
51128: LD_VAR 0 2
51132: ARRAY
51133: IFFALSE 51156
// if not weapon in mc_allowed_tower_weapons [ i ] then
51135: LD_VAR 0 9
51139: PUSH
51140: LD_EXP 140
51144: PUSH
51145: LD_VAR 0 2
51149: ARRAY
51150: IN
51151: NOT
51152: IFFALSE 51156
// continue ;
51154: GO 50858
// end else
51156: GO 51221
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
51158: LD_ADDR_VAR 0 5
51162: PUSH
51163: LD_EXP 109
51167: PUSH
51168: LD_VAR 0 2
51172: ARRAY
51173: PPUSH
51174: LD_VAR 0 4
51178: PPUSH
51179: CALL 106683 0 2
51183: ST_TO_ADDR
// if not tmp2 then
51184: LD_VAR 0 5
51188: NOT
51189: IFFALSE 51193
// continue ;
51191: GO 50858
// tw := tmp2 [ 1 ] ;
51193: LD_ADDR_VAR 0 7
51197: PUSH
51198: LD_VAR 0 5
51202: PUSH
51203: LD_INT 1
51205: ARRAY
51206: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
51207: LD_ADDR_VAR 0 9
51211: PUSH
51212: LD_VAR 0 5
51216: PUSH
51217: LD_INT 2
51219: ARRAY
51220: ST_TO_ADDR
// end ; if not weapon then
51221: LD_VAR 0 9
51225: NOT
51226: IFFALSE 51230
// continue ;
51228: GO 50858
// ComPlaceWeapon ( tw , weapon ) ;
51230: LD_VAR 0 7
51234: PPUSH
51235: LD_VAR 0 9
51239: PPUSH
51240: CALL_OW 148
// end ;
51244: GO 50858
51246: POP
51247: POP
// end ;
51248: LD_VAR 0 1
51252: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
51253: LD_INT 0
51255: PPUSH
51256: PPUSH
51257: PPUSH
51258: PPUSH
51259: PPUSH
51260: PPUSH
51261: PPUSH
// if not mc_bases then
51262: LD_EXP 101
51266: NOT
51267: IFFALSE 51271
// exit ;
51269: GO 52046
// for i = 1 to mc_bases do
51271: LD_ADDR_VAR 0 2
51275: PUSH
51276: DOUBLE
51277: LD_INT 1
51279: DEC
51280: ST_TO_ADDR
51281: LD_EXP 101
51285: PUSH
51286: FOR_TO
51287: IFFALSE 52044
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
51289: LD_EXP 114
51293: PUSH
51294: LD_VAR 0 2
51298: ARRAY
51299: NOT
51300: PUSH
51301: LD_EXP 114
51305: PUSH
51306: LD_VAR 0 2
51310: ARRAY
51311: PUSH
51312: LD_EXP 115
51316: PUSH
51317: LD_VAR 0 2
51321: ARRAY
51322: EQUAL
51323: OR
51324: PUSH
51325: LD_EXP 124
51329: PUSH
51330: LD_VAR 0 2
51334: ARRAY
51335: OR
51336: IFFALSE 51340
// continue ;
51338: GO 51286
// if mc_miners [ i ] then
51340: LD_EXP 115
51344: PUSH
51345: LD_VAR 0 2
51349: ARRAY
51350: IFFALSE 51731
// begin for j = mc_miners [ i ] downto 1 do
51352: LD_ADDR_VAR 0 3
51356: PUSH
51357: DOUBLE
51358: LD_EXP 115
51362: PUSH
51363: LD_VAR 0 2
51367: ARRAY
51368: INC
51369: ST_TO_ADDR
51370: LD_INT 1
51372: PUSH
51373: FOR_DOWNTO
51374: IFFALSE 51729
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
51376: LD_EXP 115
51380: PUSH
51381: LD_VAR 0 2
51385: ARRAY
51386: PUSH
51387: LD_VAR 0 3
51391: ARRAY
51392: PPUSH
51393: CALL_OW 301
51397: PUSH
51398: LD_EXP 115
51402: PUSH
51403: LD_VAR 0 2
51407: ARRAY
51408: PUSH
51409: LD_VAR 0 3
51413: ARRAY
51414: PPUSH
51415: CALL_OW 257
51419: PUSH
51420: LD_INT 1
51422: NONEQUAL
51423: OR
51424: IFFALSE 51487
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
51426: LD_ADDR_VAR 0 5
51430: PUSH
51431: LD_EXP 115
51435: PUSH
51436: LD_VAR 0 2
51440: ARRAY
51441: PUSH
51442: LD_EXP 115
51446: PUSH
51447: LD_VAR 0 2
51451: ARRAY
51452: PUSH
51453: LD_VAR 0 3
51457: ARRAY
51458: DIFF
51459: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
51460: LD_ADDR_EXP 115
51464: PUSH
51465: LD_EXP 115
51469: PPUSH
51470: LD_VAR 0 2
51474: PPUSH
51475: LD_VAR 0 5
51479: PPUSH
51480: CALL_OW 1
51484: ST_TO_ADDR
// continue ;
51485: GO 51373
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
51487: LD_EXP 115
51491: PUSH
51492: LD_VAR 0 2
51496: ARRAY
51497: PUSH
51498: LD_VAR 0 3
51502: ARRAY
51503: PPUSH
51504: CALL_OW 257
51508: PUSH
51509: LD_INT 1
51511: EQUAL
51512: PUSH
51513: LD_EXP 115
51517: PUSH
51518: LD_VAR 0 2
51522: ARRAY
51523: PUSH
51524: LD_VAR 0 3
51528: ARRAY
51529: PPUSH
51530: CALL_OW 459
51534: NOT
51535: AND
51536: PUSH
51537: LD_EXP 115
51541: PUSH
51542: LD_VAR 0 2
51546: ARRAY
51547: PUSH
51548: LD_VAR 0 3
51552: ARRAY
51553: PPUSH
51554: CALL_OW 314
51558: NOT
51559: AND
51560: IFFALSE 51727
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
51562: LD_EXP 115
51566: PUSH
51567: LD_VAR 0 2
51571: ARRAY
51572: PUSH
51573: LD_VAR 0 3
51577: ARRAY
51578: PPUSH
51579: CALL_OW 310
51583: IFFALSE 51606
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
51585: LD_EXP 115
51589: PUSH
51590: LD_VAR 0 2
51594: ARRAY
51595: PUSH
51596: LD_VAR 0 3
51600: ARRAY
51601: PPUSH
51602: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
51606: LD_EXP 115
51610: PUSH
51611: LD_VAR 0 2
51615: ARRAY
51616: PUSH
51617: LD_VAR 0 3
51621: ARRAY
51622: PPUSH
51623: CALL_OW 314
51627: NOT
51628: IFFALSE 51727
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
51630: LD_ADDR_VAR 0 7
51634: PUSH
51635: LD_VAR 0 3
51639: PUSH
51640: LD_EXP 114
51644: PUSH
51645: LD_VAR 0 2
51649: ARRAY
51650: PPUSH
51651: CALL 71546 0 1
51655: MOD
51656: PUSH
51657: LD_INT 1
51659: PLUS
51660: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
51661: LD_EXP 115
51665: PUSH
51666: LD_VAR 0 2
51670: ARRAY
51671: PUSH
51672: LD_VAR 0 3
51676: ARRAY
51677: PPUSH
51678: LD_EXP 114
51682: PUSH
51683: LD_VAR 0 2
51687: ARRAY
51688: PUSH
51689: LD_VAR 0 7
51693: ARRAY
51694: PUSH
51695: LD_INT 1
51697: ARRAY
51698: PPUSH
51699: LD_EXP 114
51703: PUSH
51704: LD_VAR 0 2
51708: ARRAY
51709: PUSH
51710: LD_VAR 0 7
51714: ARRAY
51715: PUSH
51716: LD_INT 2
51718: ARRAY
51719: PPUSH
51720: LD_INT 0
51722: PPUSH
51723: CALL_OW 193
// end ; end ; end ;
51727: GO 51373
51729: POP
51730: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
51731: LD_ADDR_VAR 0 5
51735: PUSH
51736: LD_EXP 101
51740: PUSH
51741: LD_VAR 0 2
51745: ARRAY
51746: PPUSH
51747: LD_INT 2
51749: PUSH
51750: LD_INT 30
51752: PUSH
51753: LD_INT 4
51755: PUSH
51756: EMPTY
51757: LIST
51758: LIST
51759: PUSH
51760: LD_INT 30
51762: PUSH
51763: LD_INT 5
51765: PUSH
51766: EMPTY
51767: LIST
51768: LIST
51769: PUSH
51770: LD_INT 30
51772: PUSH
51773: LD_INT 32
51775: PUSH
51776: EMPTY
51777: LIST
51778: LIST
51779: PUSH
51780: EMPTY
51781: LIST
51782: LIST
51783: LIST
51784: LIST
51785: PPUSH
51786: CALL_OW 72
51790: ST_TO_ADDR
// if not tmp then
51791: LD_VAR 0 5
51795: NOT
51796: IFFALSE 51800
// continue ;
51798: GO 51286
// list := [ ] ;
51800: LD_ADDR_VAR 0 6
51804: PUSH
51805: EMPTY
51806: ST_TO_ADDR
// for j in tmp do
51807: LD_ADDR_VAR 0 3
51811: PUSH
51812: LD_VAR 0 5
51816: PUSH
51817: FOR_IN
51818: IFFALSE 51887
// begin for k in UnitsInside ( j ) do
51820: LD_ADDR_VAR 0 4
51824: PUSH
51825: LD_VAR 0 3
51829: PPUSH
51830: CALL_OW 313
51834: PUSH
51835: FOR_IN
51836: IFFALSE 51883
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
51838: LD_VAR 0 4
51842: PPUSH
51843: CALL_OW 257
51847: PUSH
51848: LD_INT 1
51850: EQUAL
51851: PUSH
51852: LD_VAR 0 4
51856: PPUSH
51857: CALL_OW 459
51861: NOT
51862: AND
51863: IFFALSE 51881
// list := list ^ k ;
51865: LD_ADDR_VAR 0 6
51869: PUSH
51870: LD_VAR 0 6
51874: PUSH
51875: LD_VAR 0 4
51879: ADD
51880: ST_TO_ADDR
51881: GO 51835
51883: POP
51884: POP
// end ;
51885: GO 51817
51887: POP
51888: POP
// list := list diff mc_miners [ i ] ;
51889: LD_ADDR_VAR 0 6
51893: PUSH
51894: LD_VAR 0 6
51898: PUSH
51899: LD_EXP 115
51903: PUSH
51904: LD_VAR 0 2
51908: ARRAY
51909: DIFF
51910: ST_TO_ADDR
// if not list then
51911: LD_VAR 0 6
51915: NOT
51916: IFFALSE 51920
// continue ;
51918: GO 51286
// k := mc_mines [ i ] - mc_miners [ i ] ;
51920: LD_ADDR_VAR 0 4
51924: PUSH
51925: LD_EXP 114
51929: PUSH
51930: LD_VAR 0 2
51934: ARRAY
51935: PUSH
51936: LD_EXP 115
51940: PUSH
51941: LD_VAR 0 2
51945: ARRAY
51946: MINUS
51947: ST_TO_ADDR
// if k > list then
51948: LD_VAR 0 4
51952: PUSH
51953: LD_VAR 0 6
51957: GREATER
51958: IFFALSE 51970
// k := list ;
51960: LD_ADDR_VAR 0 4
51964: PUSH
51965: LD_VAR 0 6
51969: ST_TO_ADDR
// for j = 1 to k do
51970: LD_ADDR_VAR 0 3
51974: PUSH
51975: DOUBLE
51976: LD_INT 1
51978: DEC
51979: ST_TO_ADDR
51980: LD_VAR 0 4
51984: PUSH
51985: FOR_TO
51986: IFFALSE 52040
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
51988: LD_ADDR_EXP 115
51992: PUSH
51993: LD_EXP 115
51997: PPUSH
51998: LD_VAR 0 2
52002: PUSH
52003: LD_EXP 115
52007: PUSH
52008: LD_VAR 0 2
52012: ARRAY
52013: PUSH
52014: LD_INT 1
52016: PLUS
52017: PUSH
52018: EMPTY
52019: LIST
52020: LIST
52021: PPUSH
52022: LD_VAR 0 6
52026: PUSH
52027: LD_VAR 0 3
52031: ARRAY
52032: PPUSH
52033: CALL 74406 0 3
52037: ST_TO_ADDR
52038: GO 51985
52040: POP
52041: POP
// end ;
52042: GO 51286
52044: POP
52045: POP
// end ;
52046: LD_VAR 0 1
52050: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
52051: LD_INT 0
52053: PPUSH
52054: PPUSH
52055: PPUSH
52056: PPUSH
52057: PPUSH
52058: PPUSH
52059: PPUSH
52060: PPUSH
52061: PPUSH
52062: PPUSH
52063: PPUSH
// if not mc_bases then
52064: LD_EXP 101
52068: NOT
52069: IFFALSE 52073
// exit ;
52071: GO 53896
// for i = 1 to mc_bases do
52073: LD_ADDR_VAR 0 2
52077: PUSH
52078: DOUBLE
52079: LD_INT 1
52081: DEC
52082: ST_TO_ADDR
52083: LD_EXP 101
52087: PUSH
52088: FOR_TO
52089: IFFALSE 53894
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
52091: LD_EXP 101
52095: PUSH
52096: LD_VAR 0 2
52100: ARRAY
52101: NOT
52102: PUSH
52103: LD_EXP 108
52107: PUSH
52108: LD_VAR 0 2
52112: ARRAY
52113: OR
52114: IFFALSE 52118
// continue ;
52116: GO 52088
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
52118: LD_EXP 117
52122: PUSH
52123: LD_VAR 0 2
52127: ARRAY
52128: NOT
52129: PUSH
52130: LD_EXP 118
52134: PUSH
52135: LD_VAR 0 2
52139: ARRAY
52140: AND
52141: IFFALSE 52179
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
52143: LD_ADDR_EXP 118
52147: PUSH
52148: LD_EXP 118
52152: PPUSH
52153: LD_VAR 0 2
52157: PPUSH
52158: EMPTY
52159: PPUSH
52160: CALL_OW 1
52164: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
52165: LD_VAR 0 2
52169: PPUSH
52170: LD_INT 107
52172: PPUSH
52173: CALL 42905 0 2
// continue ;
52177: GO 52088
// end ; target := [ ] ;
52179: LD_ADDR_VAR 0 7
52183: PUSH
52184: EMPTY
52185: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52186: LD_ADDR_VAR 0 6
52190: PUSH
52191: LD_EXP 101
52195: PUSH
52196: LD_VAR 0 2
52200: ARRAY
52201: PUSH
52202: LD_INT 1
52204: ARRAY
52205: PPUSH
52206: CALL_OW 255
52210: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52211: LD_ADDR_VAR 0 9
52215: PUSH
52216: LD_EXP 101
52220: PUSH
52221: LD_VAR 0 2
52225: ARRAY
52226: PPUSH
52227: LD_INT 2
52229: PUSH
52230: LD_INT 30
52232: PUSH
52233: LD_INT 0
52235: PUSH
52236: EMPTY
52237: LIST
52238: LIST
52239: PUSH
52240: LD_INT 30
52242: PUSH
52243: LD_INT 1
52245: PUSH
52246: EMPTY
52247: LIST
52248: LIST
52249: PUSH
52250: EMPTY
52251: LIST
52252: LIST
52253: LIST
52254: PPUSH
52255: CALL_OW 72
52259: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
52260: LD_ADDR_VAR 0 3
52264: PUSH
52265: DOUBLE
52266: LD_EXP 117
52270: PUSH
52271: LD_VAR 0 2
52275: ARRAY
52276: INC
52277: ST_TO_ADDR
52278: LD_INT 1
52280: PUSH
52281: FOR_DOWNTO
52282: IFFALSE 52527
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
52284: LD_EXP 117
52288: PUSH
52289: LD_VAR 0 2
52293: ARRAY
52294: PUSH
52295: LD_VAR 0 3
52299: ARRAY
52300: PUSH
52301: LD_INT 2
52303: ARRAY
52304: PPUSH
52305: LD_EXP 117
52309: PUSH
52310: LD_VAR 0 2
52314: ARRAY
52315: PUSH
52316: LD_VAR 0 3
52320: ARRAY
52321: PUSH
52322: LD_INT 3
52324: ARRAY
52325: PPUSH
52326: CALL_OW 488
52330: PUSH
52331: LD_EXP 117
52335: PUSH
52336: LD_VAR 0 2
52340: ARRAY
52341: PUSH
52342: LD_VAR 0 3
52346: ARRAY
52347: PUSH
52348: LD_INT 2
52350: ARRAY
52351: PPUSH
52352: LD_EXP 117
52356: PUSH
52357: LD_VAR 0 2
52361: ARRAY
52362: PUSH
52363: LD_VAR 0 3
52367: ARRAY
52368: PUSH
52369: LD_INT 3
52371: ARRAY
52372: PPUSH
52373: CALL_OW 284
52377: PUSH
52378: LD_INT 0
52380: EQUAL
52381: AND
52382: IFFALSE 52437
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
52384: LD_ADDR_VAR 0 5
52388: PUSH
52389: LD_EXP 117
52393: PUSH
52394: LD_VAR 0 2
52398: ARRAY
52399: PPUSH
52400: LD_VAR 0 3
52404: PPUSH
52405: CALL_OW 3
52409: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
52410: LD_ADDR_EXP 117
52414: PUSH
52415: LD_EXP 117
52419: PPUSH
52420: LD_VAR 0 2
52424: PPUSH
52425: LD_VAR 0 5
52429: PPUSH
52430: CALL_OW 1
52434: ST_TO_ADDR
// continue ;
52435: GO 52281
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
52437: LD_VAR 0 6
52441: PPUSH
52442: LD_EXP 117
52446: PUSH
52447: LD_VAR 0 2
52451: ARRAY
52452: PUSH
52453: LD_VAR 0 3
52457: ARRAY
52458: PUSH
52459: LD_INT 2
52461: ARRAY
52462: PPUSH
52463: LD_EXP 117
52467: PUSH
52468: LD_VAR 0 2
52472: ARRAY
52473: PUSH
52474: LD_VAR 0 3
52478: ARRAY
52479: PUSH
52480: LD_INT 3
52482: ARRAY
52483: PPUSH
52484: LD_INT 30
52486: PPUSH
52487: CALL 75670 0 4
52491: PUSH
52492: LD_INT 4
52494: ARRAY
52495: PUSH
52496: LD_INT 0
52498: EQUAL
52499: IFFALSE 52525
// begin target := mc_crates [ i ] [ j ] ;
52501: LD_ADDR_VAR 0 7
52505: PUSH
52506: LD_EXP 117
52510: PUSH
52511: LD_VAR 0 2
52515: ARRAY
52516: PUSH
52517: LD_VAR 0 3
52521: ARRAY
52522: ST_TO_ADDR
// break ;
52523: GO 52527
// end ; end ;
52525: GO 52281
52527: POP
52528: POP
// if not target then
52529: LD_VAR 0 7
52533: NOT
52534: IFFALSE 52538
// continue ;
52536: GO 52088
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
52538: LD_ADDR_VAR 0 8
52542: PUSH
52543: LD_EXP 120
52547: PUSH
52548: LD_VAR 0 2
52552: ARRAY
52553: PPUSH
52554: LD_INT 2
52556: PUSH
52557: LD_INT 3
52559: PUSH
52560: LD_INT 58
52562: PUSH
52563: EMPTY
52564: LIST
52565: PUSH
52566: EMPTY
52567: LIST
52568: LIST
52569: PUSH
52570: LD_INT 61
52572: PUSH
52573: EMPTY
52574: LIST
52575: PUSH
52576: LD_INT 33
52578: PUSH
52579: LD_INT 5
52581: PUSH
52582: EMPTY
52583: LIST
52584: LIST
52585: PUSH
52586: LD_INT 33
52588: PUSH
52589: LD_INT 3
52591: PUSH
52592: EMPTY
52593: LIST
52594: LIST
52595: PUSH
52596: EMPTY
52597: LIST
52598: LIST
52599: LIST
52600: LIST
52601: LIST
52602: PUSH
52603: LD_INT 2
52605: PUSH
52606: LD_INT 34
52608: PUSH
52609: LD_INT 32
52611: PUSH
52612: EMPTY
52613: LIST
52614: LIST
52615: PUSH
52616: LD_INT 34
52618: PUSH
52619: LD_INT 51
52621: PUSH
52622: EMPTY
52623: LIST
52624: LIST
52625: PUSH
52626: LD_INT 34
52628: PUSH
52629: LD_INT 12
52631: PUSH
52632: EMPTY
52633: LIST
52634: LIST
52635: PUSH
52636: EMPTY
52637: LIST
52638: LIST
52639: LIST
52640: LIST
52641: PUSH
52642: EMPTY
52643: LIST
52644: LIST
52645: PPUSH
52646: CALL_OW 72
52650: ST_TO_ADDR
// if not cargo then
52651: LD_VAR 0 8
52655: NOT
52656: IFFALSE 53362
// begin if mc_crates_collector [ i ] < 5 then
52658: LD_EXP 118
52662: PUSH
52663: LD_VAR 0 2
52667: ARRAY
52668: PUSH
52669: LD_INT 5
52671: LESS
52672: IFFALSE 53038
// begin if mc_ape [ i ] then
52674: LD_EXP 130
52678: PUSH
52679: LD_VAR 0 2
52683: ARRAY
52684: IFFALSE 52731
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
52686: LD_ADDR_VAR 0 5
52690: PUSH
52691: LD_EXP 130
52695: PUSH
52696: LD_VAR 0 2
52700: ARRAY
52701: PPUSH
52702: LD_INT 25
52704: PUSH
52705: LD_INT 16
52707: PUSH
52708: EMPTY
52709: LIST
52710: LIST
52711: PUSH
52712: LD_INT 24
52714: PUSH
52715: LD_INT 750
52717: PUSH
52718: EMPTY
52719: LIST
52720: LIST
52721: PUSH
52722: EMPTY
52723: LIST
52724: LIST
52725: PPUSH
52726: CALL_OW 72
52730: ST_TO_ADDR
// if not tmp then
52731: LD_VAR 0 5
52735: NOT
52736: IFFALSE 52783
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
52738: LD_ADDR_VAR 0 5
52742: PUSH
52743: LD_EXP 101
52747: PUSH
52748: LD_VAR 0 2
52752: ARRAY
52753: PPUSH
52754: LD_INT 25
52756: PUSH
52757: LD_INT 2
52759: PUSH
52760: EMPTY
52761: LIST
52762: LIST
52763: PUSH
52764: LD_INT 24
52766: PUSH
52767: LD_INT 750
52769: PUSH
52770: EMPTY
52771: LIST
52772: LIST
52773: PUSH
52774: EMPTY
52775: LIST
52776: LIST
52777: PPUSH
52778: CALL_OW 72
52782: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
52783: LD_EXP 130
52787: PUSH
52788: LD_VAR 0 2
52792: ARRAY
52793: PUSH
52794: LD_EXP 101
52798: PUSH
52799: LD_VAR 0 2
52803: ARRAY
52804: PPUSH
52805: LD_INT 25
52807: PUSH
52808: LD_INT 2
52810: PUSH
52811: EMPTY
52812: LIST
52813: LIST
52814: PUSH
52815: LD_INT 24
52817: PUSH
52818: LD_INT 750
52820: PUSH
52821: EMPTY
52822: LIST
52823: LIST
52824: PUSH
52825: EMPTY
52826: LIST
52827: LIST
52828: PPUSH
52829: CALL_OW 72
52833: AND
52834: PUSH
52835: LD_VAR 0 5
52839: PUSH
52840: LD_INT 5
52842: LESS
52843: AND
52844: IFFALSE 52926
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
52846: LD_ADDR_VAR 0 3
52850: PUSH
52851: LD_EXP 101
52855: PUSH
52856: LD_VAR 0 2
52860: ARRAY
52861: PPUSH
52862: LD_INT 25
52864: PUSH
52865: LD_INT 2
52867: PUSH
52868: EMPTY
52869: LIST
52870: LIST
52871: PUSH
52872: LD_INT 24
52874: PUSH
52875: LD_INT 750
52877: PUSH
52878: EMPTY
52879: LIST
52880: LIST
52881: PUSH
52882: EMPTY
52883: LIST
52884: LIST
52885: PPUSH
52886: CALL_OW 72
52890: PUSH
52891: FOR_IN
52892: IFFALSE 52924
// begin tmp := tmp union j ;
52894: LD_ADDR_VAR 0 5
52898: PUSH
52899: LD_VAR 0 5
52903: PUSH
52904: LD_VAR 0 3
52908: UNION
52909: ST_TO_ADDR
// if tmp >= 5 then
52910: LD_VAR 0 5
52914: PUSH
52915: LD_INT 5
52917: GREATEREQUAL
52918: IFFALSE 52922
// break ;
52920: GO 52924
// end ;
52922: GO 52891
52924: POP
52925: POP
// end ; if not tmp then
52926: LD_VAR 0 5
52930: NOT
52931: IFFALSE 52935
// continue ;
52933: GO 52088
// for j in tmp do
52935: LD_ADDR_VAR 0 3
52939: PUSH
52940: LD_VAR 0 5
52944: PUSH
52945: FOR_IN
52946: IFFALSE 53036
// if not GetTag ( j ) then
52948: LD_VAR 0 3
52952: PPUSH
52953: CALL_OW 110
52957: NOT
52958: IFFALSE 53034
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
52960: LD_ADDR_EXP 118
52964: PUSH
52965: LD_EXP 118
52969: PPUSH
52970: LD_VAR 0 2
52974: PUSH
52975: LD_EXP 118
52979: PUSH
52980: LD_VAR 0 2
52984: ARRAY
52985: PUSH
52986: LD_INT 1
52988: PLUS
52989: PUSH
52990: EMPTY
52991: LIST
52992: LIST
52993: PPUSH
52994: LD_VAR 0 3
52998: PPUSH
52999: CALL 74406 0 3
53003: ST_TO_ADDR
// SetTag ( j , 107 ) ;
53004: LD_VAR 0 3
53008: PPUSH
53009: LD_INT 107
53011: PPUSH
53012: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
53016: LD_EXP 118
53020: PUSH
53021: LD_VAR 0 2
53025: ARRAY
53026: PUSH
53027: LD_INT 5
53029: GREATEREQUAL
53030: IFFALSE 53034
// break ;
53032: GO 53036
// end ;
53034: GO 52945
53036: POP
53037: POP
// end ; if mc_crates_collector [ i ] and target then
53038: LD_EXP 118
53042: PUSH
53043: LD_VAR 0 2
53047: ARRAY
53048: PUSH
53049: LD_VAR 0 7
53053: AND
53054: IFFALSE 53360
// begin if mc_crates_collector [ i ] < target [ 1 ] then
53056: LD_EXP 118
53060: PUSH
53061: LD_VAR 0 2
53065: ARRAY
53066: PUSH
53067: LD_VAR 0 7
53071: PUSH
53072: LD_INT 1
53074: ARRAY
53075: LESS
53076: IFFALSE 53096
// tmp := mc_crates_collector [ i ] else
53078: LD_ADDR_VAR 0 5
53082: PUSH
53083: LD_EXP 118
53087: PUSH
53088: LD_VAR 0 2
53092: ARRAY
53093: ST_TO_ADDR
53094: GO 53110
// tmp := target [ 1 ] ;
53096: LD_ADDR_VAR 0 5
53100: PUSH
53101: LD_VAR 0 7
53105: PUSH
53106: LD_INT 1
53108: ARRAY
53109: ST_TO_ADDR
// k := 0 ;
53110: LD_ADDR_VAR 0 4
53114: PUSH
53115: LD_INT 0
53117: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
53118: LD_ADDR_VAR 0 3
53122: PUSH
53123: LD_EXP 118
53127: PUSH
53128: LD_VAR 0 2
53132: ARRAY
53133: PUSH
53134: FOR_IN
53135: IFFALSE 53358
// begin k := k + 1 ;
53137: LD_ADDR_VAR 0 4
53141: PUSH
53142: LD_VAR 0 4
53146: PUSH
53147: LD_INT 1
53149: PLUS
53150: ST_TO_ADDR
// if k > tmp then
53151: LD_VAR 0 4
53155: PUSH
53156: LD_VAR 0 5
53160: GREATER
53161: IFFALSE 53165
// break ;
53163: GO 53358
// if not GetClass ( j ) in [ 2 , 16 ] then
53165: LD_VAR 0 3
53169: PPUSH
53170: CALL_OW 257
53174: PUSH
53175: LD_INT 2
53177: PUSH
53178: LD_INT 16
53180: PUSH
53181: EMPTY
53182: LIST
53183: LIST
53184: IN
53185: NOT
53186: IFFALSE 53239
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
53188: LD_ADDR_EXP 118
53192: PUSH
53193: LD_EXP 118
53197: PPUSH
53198: LD_VAR 0 2
53202: PPUSH
53203: LD_EXP 118
53207: PUSH
53208: LD_VAR 0 2
53212: ARRAY
53213: PUSH
53214: LD_VAR 0 3
53218: DIFF
53219: PPUSH
53220: CALL_OW 1
53224: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53225: LD_VAR 0 3
53229: PPUSH
53230: LD_INT 0
53232: PPUSH
53233: CALL_OW 109
// continue ;
53237: GO 53134
// end ; if IsInUnit ( j ) then
53239: LD_VAR 0 3
53243: PPUSH
53244: CALL_OW 310
53248: IFFALSE 53259
// ComExitBuilding ( j ) ;
53250: LD_VAR 0 3
53254: PPUSH
53255: CALL_OW 122
// wait ( 3 ) ;
53259: LD_INT 3
53261: PPUSH
53262: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
53266: LD_VAR 0 3
53270: PPUSH
53271: CALL_OW 314
53275: PUSH
53276: LD_VAR 0 6
53280: PPUSH
53281: LD_VAR 0 7
53285: PUSH
53286: LD_INT 2
53288: ARRAY
53289: PPUSH
53290: LD_VAR 0 7
53294: PUSH
53295: LD_INT 3
53297: ARRAY
53298: PPUSH
53299: LD_INT 30
53301: PPUSH
53302: CALL 75670 0 4
53306: PUSH
53307: LD_INT 4
53309: ARRAY
53310: AND
53311: IFFALSE 53329
// ComStandNearbyBuilding ( j , depot ) else
53313: LD_VAR 0 3
53317: PPUSH
53318: LD_VAR 0 9
53322: PPUSH
53323: CALL 71008 0 2
53327: GO 53356
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
53329: LD_VAR 0 3
53333: PPUSH
53334: LD_VAR 0 7
53338: PUSH
53339: LD_INT 2
53341: ARRAY
53342: PPUSH
53343: LD_VAR 0 7
53347: PUSH
53348: LD_INT 3
53350: ARRAY
53351: PPUSH
53352: CALL_OW 117
// end ;
53356: GO 53134
53358: POP
53359: POP
// end ; end else
53360: GO 53892
// begin for j in cargo do
53362: LD_ADDR_VAR 0 3
53366: PUSH
53367: LD_VAR 0 8
53371: PUSH
53372: FOR_IN
53373: IFFALSE 53890
// begin if GetTag ( j ) <> 0 then
53375: LD_VAR 0 3
53379: PPUSH
53380: CALL_OW 110
53384: PUSH
53385: LD_INT 0
53387: NONEQUAL
53388: IFFALSE 53392
// continue ;
53390: GO 53372
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
53392: LD_VAR 0 3
53396: PPUSH
53397: CALL_OW 256
53401: PUSH
53402: LD_INT 1000
53404: LESS
53405: PUSH
53406: LD_VAR 0 3
53410: PPUSH
53411: LD_EXP 125
53415: PUSH
53416: LD_VAR 0 2
53420: ARRAY
53421: PPUSH
53422: CALL_OW 308
53426: NOT
53427: AND
53428: IFFALSE 53450
// ComMoveToArea ( j , mc_parking [ i ] ) ;
53430: LD_VAR 0 3
53434: PPUSH
53435: LD_EXP 125
53439: PUSH
53440: LD_VAR 0 2
53444: ARRAY
53445: PPUSH
53446: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
53450: LD_VAR 0 3
53454: PPUSH
53455: CALL_OW 256
53459: PUSH
53460: LD_INT 1000
53462: LESS
53463: PUSH
53464: LD_VAR 0 3
53468: PPUSH
53469: LD_EXP 125
53473: PUSH
53474: LD_VAR 0 2
53478: ARRAY
53479: PPUSH
53480: CALL_OW 308
53484: AND
53485: IFFALSE 53489
// continue ;
53487: GO 53372
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
53489: LD_VAR 0 3
53493: PPUSH
53494: CALL_OW 262
53498: PUSH
53499: LD_INT 2
53501: EQUAL
53502: PUSH
53503: LD_VAR 0 3
53507: PPUSH
53508: CALL_OW 261
53512: PUSH
53513: LD_INT 15
53515: LESS
53516: AND
53517: IFFALSE 53521
// continue ;
53519: GO 53372
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
53521: LD_VAR 0 3
53525: PPUSH
53526: CALL_OW 262
53530: PUSH
53531: LD_INT 1
53533: EQUAL
53534: PUSH
53535: LD_VAR 0 3
53539: PPUSH
53540: CALL_OW 261
53544: PUSH
53545: LD_INT 10
53547: LESS
53548: AND
53549: IFFALSE 53829
// begin if not depot then
53551: LD_VAR 0 9
53555: NOT
53556: IFFALSE 53560
// continue ;
53558: GO 53372
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
53560: LD_VAR 0 3
53564: PPUSH
53565: LD_VAR 0 9
53569: PPUSH
53570: LD_VAR 0 3
53574: PPUSH
53575: CALL_OW 74
53579: PPUSH
53580: CALL_OW 296
53584: PUSH
53585: LD_INT 6
53587: LESS
53588: IFFALSE 53604
// SetFuel ( j , 100 ) else
53590: LD_VAR 0 3
53594: PPUSH
53595: LD_INT 100
53597: PPUSH
53598: CALL_OW 240
53602: GO 53829
// if GetFuel ( j ) = 0 then
53604: LD_VAR 0 3
53608: PPUSH
53609: CALL_OW 261
53613: PUSH
53614: LD_INT 0
53616: EQUAL
53617: IFFALSE 53829
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
53619: LD_ADDR_EXP 120
53623: PUSH
53624: LD_EXP 120
53628: PPUSH
53629: LD_VAR 0 2
53633: PPUSH
53634: LD_EXP 120
53638: PUSH
53639: LD_VAR 0 2
53643: ARRAY
53644: PUSH
53645: LD_VAR 0 3
53649: DIFF
53650: PPUSH
53651: CALL_OW 1
53655: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
53656: LD_VAR 0 3
53660: PPUSH
53661: CALL_OW 263
53665: PUSH
53666: LD_INT 1
53668: EQUAL
53669: IFFALSE 53685
// ComExitVehicle ( IsInUnit ( j ) ) ;
53671: LD_VAR 0 3
53675: PPUSH
53676: CALL_OW 310
53680: PPUSH
53681: CALL_OW 121
// if GetControl ( j ) = control_remote then
53685: LD_VAR 0 3
53689: PPUSH
53690: CALL_OW 263
53694: PUSH
53695: LD_INT 2
53697: EQUAL
53698: IFFALSE 53709
// ComUnlink ( j ) ;
53700: LD_VAR 0 3
53704: PPUSH
53705: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
53709: LD_ADDR_VAR 0 10
53713: PUSH
53714: LD_VAR 0 2
53718: PPUSH
53719: LD_INT 3
53721: PPUSH
53722: CALL 63473 0 2
53726: ST_TO_ADDR
// if fac then
53727: LD_VAR 0 10
53731: IFFALSE 53827
// begin for k in fac do
53733: LD_ADDR_VAR 0 4
53737: PUSH
53738: LD_VAR 0 10
53742: PUSH
53743: FOR_IN
53744: IFFALSE 53825
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
53746: LD_ADDR_VAR 0 11
53750: PUSH
53751: LD_VAR 0 10
53755: PPUSH
53756: LD_VAR 0 3
53760: PPUSH
53761: CALL_OW 265
53765: PPUSH
53766: LD_VAR 0 3
53770: PPUSH
53771: CALL_OW 262
53775: PPUSH
53776: LD_VAR 0 3
53780: PPUSH
53781: CALL_OW 263
53785: PPUSH
53786: LD_VAR 0 3
53790: PPUSH
53791: CALL_OW 264
53795: PPUSH
53796: CALL 71904 0 5
53800: ST_TO_ADDR
// if components then
53801: LD_VAR 0 11
53805: IFFALSE 53823
// begin MC_InsertProduceList ( i , components ) ;
53807: LD_VAR 0 2
53811: PPUSH
53812: LD_VAR 0 11
53816: PPUSH
53817: CALL 63018 0 2
// break ;
53821: GO 53825
// end ; end ;
53823: GO 53743
53825: POP
53826: POP
// end ; continue ;
53827: GO 53372
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
53829: LD_VAR 0 3
53833: PPUSH
53834: LD_INT 1
53836: PPUSH
53837: CALL_OW 289
53841: PUSH
53842: LD_INT 100
53844: LESS
53845: PUSH
53846: LD_VAR 0 3
53850: PPUSH
53851: CALL_OW 314
53855: NOT
53856: AND
53857: IFFALSE 53886
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
53859: LD_VAR 0 3
53863: PPUSH
53864: LD_VAR 0 7
53868: PUSH
53869: LD_INT 2
53871: ARRAY
53872: PPUSH
53873: LD_VAR 0 7
53877: PUSH
53878: LD_INT 3
53880: ARRAY
53881: PPUSH
53882: CALL_OW 117
// break ;
53886: GO 53890
// end ;
53888: GO 53372
53890: POP
53891: POP
// end ; end ;
53892: GO 52088
53894: POP
53895: POP
// end ;
53896: LD_VAR 0 1
53900: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
53901: LD_INT 0
53903: PPUSH
53904: PPUSH
53905: PPUSH
53906: PPUSH
// if not mc_bases then
53907: LD_EXP 101
53911: NOT
53912: IFFALSE 53916
// exit ;
53914: GO 54077
// for i = 1 to mc_bases do
53916: LD_ADDR_VAR 0 2
53920: PUSH
53921: DOUBLE
53922: LD_INT 1
53924: DEC
53925: ST_TO_ADDR
53926: LD_EXP 101
53930: PUSH
53931: FOR_TO
53932: IFFALSE 54075
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
53934: LD_ADDR_VAR 0 4
53938: PUSH
53939: LD_EXP 120
53943: PUSH
53944: LD_VAR 0 2
53948: ARRAY
53949: PUSH
53950: LD_EXP 123
53954: PUSH
53955: LD_VAR 0 2
53959: ARRAY
53960: UNION
53961: PPUSH
53962: LD_INT 33
53964: PUSH
53965: LD_INT 2
53967: PUSH
53968: EMPTY
53969: LIST
53970: LIST
53971: PPUSH
53972: CALL_OW 72
53976: ST_TO_ADDR
// if tmp then
53977: LD_VAR 0 4
53981: IFFALSE 54073
// for j in tmp do
53983: LD_ADDR_VAR 0 3
53987: PUSH
53988: LD_VAR 0 4
53992: PUSH
53993: FOR_IN
53994: IFFALSE 54071
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
53996: LD_VAR 0 3
54000: PPUSH
54001: CALL_OW 312
54005: NOT
54006: PUSH
54007: LD_VAR 0 3
54011: PPUSH
54012: CALL_OW 256
54016: PUSH
54017: LD_INT 250
54019: GREATEREQUAL
54020: AND
54021: IFFALSE 54034
// Connect ( j ) else
54023: LD_VAR 0 3
54027: PPUSH
54028: CALL 77752 0 1
54032: GO 54069
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
54034: LD_VAR 0 3
54038: PPUSH
54039: CALL_OW 256
54043: PUSH
54044: LD_INT 250
54046: LESS
54047: PUSH
54048: LD_VAR 0 3
54052: PPUSH
54053: CALL_OW 312
54057: AND
54058: IFFALSE 54069
// ComUnlink ( j ) ;
54060: LD_VAR 0 3
54064: PPUSH
54065: CALL_OW 136
54069: GO 53993
54071: POP
54072: POP
// end ;
54073: GO 53931
54075: POP
54076: POP
// end ;
54077: LD_VAR 0 1
54081: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
54082: LD_INT 0
54084: PPUSH
54085: PPUSH
54086: PPUSH
54087: PPUSH
54088: PPUSH
// if not mc_bases then
54089: LD_EXP 101
54093: NOT
54094: IFFALSE 54098
// exit ;
54096: GO 54543
// for i = 1 to mc_bases do
54098: LD_ADDR_VAR 0 2
54102: PUSH
54103: DOUBLE
54104: LD_INT 1
54106: DEC
54107: ST_TO_ADDR
54108: LD_EXP 101
54112: PUSH
54113: FOR_TO
54114: IFFALSE 54541
// begin if not mc_produce [ i ] then
54116: LD_EXP 122
54120: PUSH
54121: LD_VAR 0 2
54125: ARRAY
54126: NOT
54127: IFFALSE 54131
// continue ;
54129: GO 54113
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54131: LD_ADDR_VAR 0 5
54135: PUSH
54136: LD_EXP 101
54140: PUSH
54141: LD_VAR 0 2
54145: ARRAY
54146: PPUSH
54147: LD_INT 30
54149: PUSH
54150: LD_INT 3
54152: PUSH
54153: EMPTY
54154: LIST
54155: LIST
54156: PPUSH
54157: CALL_OW 72
54161: ST_TO_ADDR
// if not fac then
54162: LD_VAR 0 5
54166: NOT
54167: IFFALSE 54171
// continue ;
54169: GO 54113
// for j in fac do
54171: LD_ADDR_VAR 0 3
54175: PUSH
54176: LD_VAR 0 5
54180: PUSH
54181: FOR_IN
54182: IFFALSE 54537
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
54184: LD_VAR 0 3
54188: PPUSH
54189: CALL_OW 461
54193: PUSH
54194: LD_INT 2
54196: NONEQUAL
54197: PUSH
54198: LD_VAR 0 3
54202: PPUSH
54203: LD_INT 15
54205: PPUSH
54206: CALL 77371 0 2
54210: PUSH
54211: LD_INT 4
54213: ARRAY
54214: OR
54215: IFFALSE 54219
// continue ;
54217: GO 54181
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
54219: LD_VAR 0 3
54223: PPUSH
54224: LD_EXP 122
54228: PUSH
54229: LD_VAR 0 2
54233: ARRAY
54234: PUSH
54235: LD_INT 1
54237: ARRAY
54238: PUSH
54239: LD_INT 1
54241: ARRAY
54242: PPUSH
54243: LD_EXP 122
54247: PUSH
54248: LD_VAR 0 2
54252: ARRAY
54253: PUSH
54254: LD_INT 1
54256: ARRAY
54257: PUSH
54258: LD_INT 2
54260: ARRAY
54261: PPUSH
54262: LD_EXP 122
54266: PUSH
54267: LD_VAR 0 2
54271: ARRAY
54272: PUSH
54273: LD_INT 1
54275: ARRAY
54276: PUSH
54277: LD_INT 3
54279: ARRAY
54280: PPUSH
54281: LD_EXP 122
54285: PUSH
54286: LD_VAR 0 2
54290: ARRAY
54291: PUSH
54292: LD_INT 1
54294: ARRAY
54295: PUSH
54296: LD_INT 4
54298: ARRAY
54299: PPUSH
54300: CALL_OW 448
54304: PUSH
54305: LD_VAR 0 3
54309: PPUSH
54310: LD_EXP 122
54314: PUSH
54315: LD_VAR 0 2
54319: ARRAY
54320: PUSH
54321: LD_INT 1
54323: ARRAY
54324: PUSH
54325: LD_INT 1
54327: ARRAY
54328: PUSH
54329: LD_EXP 122
54333: PUSH
54334: LD_VAR 0 2
54338: ARRAY
54339: PUSH
54340: LD_INT 1
54342: ARRAY
54343: PUSH
54344: LD_INT 2
54346: ARRAY
54347: PUSH
54348: LD_EXP 122
54352: PUSH
54353: LD_VAR 0 2
54357: ARRAY
54358: PUSH
54359: LD_INT 1
54361: ARRAY
54362: PUSH
54363: LD_INT 3
54365: ARRAY
54366: PUSH
54367: LD_EXP 122
54371: PUSH
54372: LD_VAR 0 2
54376: ARRAY
54377: PUSH
54378: LD_INT 1
54380: ARRAY
54381: PUSH
54382: LD_INT 4
54384: ARRAY
54385: PUSH
54386: EMPTY
54387: LIST
54388: LIST
54389: LIST
54390: LIST
54391: PPUSH
54392: CALL 81147 0 2
54396: AND
54397: IFFALSE 54535
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
54399: LD_VAR 0 3
54403: PPUSH
54404: LD_EXP 122
54408: PUSH
54409: LD_VAR 0 2
54413: ARRAY
54414: PUSH
54415: LD_INT 1
54417: ARRAY
54418: PUSH
54419: LD_INT 1
54421: ARRAY
54422: PPUSH
54423: LD_EXP 122
54427: PUSH
54428: LD_VAR 0 2
54432: ARRAY
54433: PUSH
54434: LD_INT 1
54436: ARRAY
54437: PUSH
54438: LD_INT 2
54440: ARRAY
54441: PPUSH
54442: LD_EXP 122
54446: PUSH
54447: LD_VAR 0 2
54451: ARRAY
54452: PUSH
54453: LD_INT 1
54455: ARRAY
54456: PUSH
54457: LD_INT 3
54459: ARRAY
54460: PPUSH
54461: LD_EXP 122
54465: PUSH
54466: LD_VAR 0 2
54470: ARRAY
54471: PUSH
54472: LD_INT 1
54474: ARRAY
54475: PUSH
54476: LD_INT 4
54478: ARRAY
54479: PPUSH
54480: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
54484: LD_ADDR_VAR 0 4
54488: PUSH
54489: LD_EXP 122
54493: PUSH
54494: LD_VAR 0 2
54498: ARRAY
54499: PPUSH
54500: LD_INT 1
54502: PPUSH
54503: CALL_OW 3
54507: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
54508: LD_ADDR_EXP 122
54512: PUSH
54513: LD_EXP 122
54517: PPUSH
54518: LD_VAR 0 2
54522: PPUSH
54523: LD_VAR 0 4
54527: PPUSH
54528: CALL_OW 1
54532: ST_TO_ADDR
// break ;
54533: GO 54537
// end ; end ;
54535: GO 54181
54537: POP
54538: POP
// end ;
54539: GO 54113
54541: POP
54542: POP
// end ;
54543: LD_VAR 0 1
54547: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
54548: LD_INT 0
54550: PPUSH
54551: PPUSH
54552: PPUSH
// if not mc_bases then
54553: LD_EXP 101
54557: NOT
54558: IFFALSE 54562
// exit ;
54560: GO 54651
// for i = 1 to mc_bases do
54562: LD_ADDR_VAR 0 2
54566: PUSH
54567: DOUBLE
54568: LD_INT 1
54570: DEC
54571: ST_TO_ADDR
54572: LD_EXP 101
54576: PUSH
54577: FOR_TO
54578: IFFALSE 54649
// begin if mc_attack [ i ] then
54580: LD_EXP 121
54584: PUSH
54585: LD_VAR 0 2
54589: ARRAY
54590: IFFALSE 54647
// begin tmp := mc_attack [ i ] [ 1 ] ;
54592: LD_ADDR_VAR 0 3
54596: PUSH
54597: LD_EXP 121
54601: PUSH
54602: LD_VAR 0 2
54606: ARRAY
54607: PUSH
54608: LD_INT 1
54610: ARRAY
54611: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
54612: LD_ADDR_EXP 121
54616: PUSH
54617: LD_EXP 121
54621: PPUSH
54622: LD_VAR 0 2
54626: PPUSH
54627: EMPTY
54628: PPUSH
54629: CALL_OW 1
54633: ST_TO_ADDR
// Attack ( tmp ) ;
54634: LD_VAR 0 3
54638: PPUSH
54639: CALL 132766 0 1
// exit ;
54643: POP
54644: POP
54645: GO 54651
// end ; end ;
54647: GO 54577
54649: POP
54650: POP
// end ;
54651: LD_VAR 0 1
54655: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
54656: LD_INT 0
54658: PPUSH
54659: PPUSH
54660: PPUSH
54661: PPUSH
54662: PPUSH
54663: PPUSH
54664: PPUSH
// if not mc_bases then
54665: LD_EXP 101
54669: NOT
54670: IFFALSE 54674
// exit ;
54672: GO 55531
// for i = 1 to mc_bases do
54674: LD_ADDR_VAR 0 2
54678: PUSH
54679: DOUBLE
54680: LD_INT 1
54682: DEC
54683: ST_TO_ADDR
54684: LD_EXP 101
54688: PUSH
54689: FOR_TO
54690: IFFALSE 55529
// begin if not mc_bases [ i ] then
54692: LD_EXP 101
54696: PUSH
54697: LD_VAR 0 2
54701: ARRAY
54702: NOT
54703: IFFALSE 54707
// continue ;
54705: GO 54689
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
54707: LD_ADDR_VAR 0 7
54711: PUSH
54712: LD_EXP 101
54716: PUSH
54717: LD_VAR 0 2
54721: ARRAY
54722: PUSH
54723: LD_INT 1
54725: ARRAY
54726: PPUSH
54727: CALL 71230 0 1
54731: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
54732: LD_ADDR_EXP 124
54736: PUSH
54737: LD_EXP 124
54741: PPUSH
54742: LD_VAR 0 2
54746: PPUSH
54747: LD_EXP 101
54751: PUSH
54752: LD_VAR 0 2
54756: ARRAY
54757: PUSH
54758: LD_INT 1
54760: ARRAY
54761: PPUSH
54762: CALL_OW 255
54766: PPUSH
54767: LD_EXP 126
54771: PUSH
54772: LD_VAR 0 2
54776: ARRAY
54777: PPUSH
54778: CALL 71195 0 2
54782: PPUSH
54783: CALL_OW 1
54787: ST_TO_ADDR
// if not mc_scan [ i ] then
54788: LD_EXP 124
54792: PUSH
54793: LD_VAR 0 2
54797: ARRAY
54798: NOT
54799: IFFALSE 54977
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
54801: LD_ADDR_EXP 144
54805: PUSH
54806: LD_EXP 144
54810: PPUSH
54811: LD_VAR 0 2
54815: PPUSH
54816: LD_INT 0
54818: PPUSH
54819: CALL_OW 1
54823: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54824: LD_ADDR_VAR 0 4
54828: PUSH
54829: LD_EXP 101
54833: PUSH
54834: LD_VAR 0 2
54838: ARRAY
54839: PPUSH
54840: LD_INT 2
54842: PUSH
54843: LD_INT 25
54845: PUSH
54846: LD_INT 5
54848: PUSH
54849: EMPTY
54850: LIST
54851: LIST
54852: PUSH
54853: LD_INT 25
54855: PUSH
54856: LD_INT 8
54858: PUSH
54859: EMPTY
54860: LIST
54861: LIST
54862: PUSH
54863: LD_INT 25
54865: PUSH
54866: LD_INT 9
54868: PUSH
54869: EMPTY
54870: LIST
54871: LIST
54872: PUSH
54873: EMPTY
54874: LIST
54875: LIST
54876: LIST
54877: LIST
54878: PPUSH
54879: CALL_OW 72
54883: ST_TO_ADDR
// if not tmp then
54884: LD_VAR 0 4
54888: NOT
54889: IFFALSE 54893
// continue ;
54891: GO 54689
// for j in tmp do
54893: LD_ADDR_VAR 0 3
54897: PUSH
54898: LD_VAR 0 4
54902: PUSH
54903: FOR_IN
54904: IFFALSE 54975
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
54906: LD_VAR 0 3
54910: PPUSH
54911: CALL_OW 310
54915: PPUSH
54916: CALL_OW 266
54920: PUSH
54921: LD_INT 5
54923: EQUAL
54924: PUSH
54925: LD_VAR 0 3
54929: PPUSH
54930: CALL_OW 257
54934: PUSH
54935: LD_INT 1
54937: EQUAL
54938: AND
54939: PUSH
54940: LD_VAR 0 3
54944: PPUSH
54945: CALL_OW 459
54949: NOT
54950: AND
54951: PUSH
54952: LD_VAR 0 7
54956: AND
54957: IFFALSE 54973
// ComChangeProfession ( j , class ) ;
54959: LD_VAR 0 3
54963: PPUSH
54964: LD_VAR 0 7
54968: PPUSH
54969: CALL_OW 123
54973: GO 54903
54975: POP
54976: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
54977: LD_EXP 124
54981: PUSH
54982: LD_VAR 0 2
54986: ARRAY
54987: PUSH
54988: LD_EXP 144
54992: PUSH
54993: LD_VAR 0 2
54997: ARRAY
54998: NOT
54999: AND
55000: PUSH
55001: LD_EXP 123
55005: PUSH
55006: LD_VAR 0 2
55010: ARRAY
55011: NOT
55012: AND
55013: PUSH
55014: LD_EXP 101
55018: PUSH
55019: LD_VAR 0 2
55023: ARRAY
55024: PPUSH
55025: LD_INT 50
55027: PUSH
55028: EMPTY
55029: LIST
55030: PUSH
55031: LD_INT 2
55033: PUSH
55034: LD_INT 30
55036: PUSH
55037: LD_INT 32
55039: PUSH
55040: EMPTY
55041: LIST
55042: LIST
55043: PUSH
55044: LD_INT 30
55046: PUSH
55047: LD_INT 33
55049: PUSH
55050: EMPTY
55051: LIST
55052: LIST
55053: PUSH
55054: LD_INT 30
55056: PUSH
55057: LD_INT 4
55059: PUSH
55060: EMPTY
55061: LIST
55062: LIST
55063: PUSH
55064: LD_INT 30
55066: PUSH
55067: LD_INT 5
55069: PUSH
55070: EMPTY
55071: LIST
55072: LIST
55073: PUSH
55074: EMPTY
55075: LIST
55076: LIST
55077: LIST
55078: LIST
55079: LIST
55080: PUSH
55081: EMPTY
55082: LIST
55083: LIST
55084: PPUSH
55085: CALL_OW 72
55089: PUSH
55090: LD_INT 4
55092: LESS
55093: PUSH
55094: LD_EXP 101
55098: PUSH
55099: LD_VAR 0 2
55103: ARRAY
55104: PPUSH
55105: LD_INT 3
55107: PUSH
55108: LD_INT 24
55110: PUSH
55111: LD_INT 1000
55113: PUSH
55114: EMPTY
55115: LIST
55116: LIST
55117: PUSH
55118: EMPTY
55119: LIST
55120: LIST
55121: PUSH
55122: LD_INT 2
55124: PUSH
55125: LD_INT 30
55127: PUSH
55128: LD_INT 0
55130: PUSH
55131: EMPTY
55132: LIST
55133: LIST
55134: PUSH
55135: LD_INT 30
55137: PUSH
55138: LD_INT 1
55140: PUSH
55141: EMPTY
55142: LIST
55143: LIST
55144: PUSH
55145: EMPTY
55146: LIST
55147: LIST
55148: LIST
55149: PUSH
55150: EMPTY
55151: LIST
55152: LIST
55153: PPUSH
55154: CALL_OW 72
55158: OR
55159: AND
55160: IFFALSE 55411
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
55162: LD_ADDR_EXP 144
55166: PUSH
55167: LD_EXP 144
55171: PPUSH
55172: LD_VAR 0 2
55176: PPUSH
55177: LD_INT 1
55179: PPUSH
55180: CALL_OW 1
55184: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55185: LD_ADDR_VAR 0 4
55189: PUSH
55190: LD_EXP 101
55194: PUSH
55195: LD_VAR 0 2
55199: ARRAY
55200: PPUSH
55201: LD_INT 2
55203: PUSH
55204: LD_INT 25
55206: PUSH
55207: LD_INT 1
55209: PUSH
55210: EMPTY
55211: LIST
55212: LIST
55213: PUSH
55214: LD_INT 25
55216: PUSH
55217: LD_INT 5
55219: PUSH
55220: EMPTY
55221: LIST
55222: LIST
55223: PUSH
55224: LD_INT 25
55226: PUSH
55227: LD_INT 8
55229: PUSH
55230: EMPTY
55231: LIST
55232: LIST
55233: PUSH
55234: LD_INT 25
55236: PUSH
55237: LD_INT 9
55239: PUSH
55240: EMPTY
55241: LIST
55242: LIST
55243: PUSH
55244: EMPTY
55245: LIST
55246: LIST
55247: LIST
55248: LIST
55249: LIST
55250: PPUSH
55251: CALL_OW 72
55255: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
55256: LD_ADDR_VAR 0 4
55260: PUSH
55261: LD_VAR 0 4
55265: PUSH
55266: LD_VAR 0 4
55270: PPUSH
55271: LD_INT 18
55273: PPUSH
55274: CALL 104704 0 2
55278: DIFF
55279: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
55280: LD_VAR 0 4
55284: NOT
55285: PUSH
55286: LD_EXP 101
55290: PUSH
55291: LD_VAR 0 2
55295: ARRAY
55296: PPUSH
55297: LD_INT 2
55299: PUSH
55300: LD_INT 30
55302: PUSH
55303: LD_INT 4
55305: PUSH
55306: EMPTY
55307: LIST
55308: LIST
55309: PUSH
55310: LD_INT 30
55312: PUSH
55313: LD_INT 5
55315: PUSH
55316: EMPTY
55317: LIST
55318: LIST
55319: PUSH
55320: EMPTY
55321: LIST
55322: LIST
55323: LIST
55324: PPUSH
55325: CALL_OW 72
55329: NOT
55330: AND
55331: IFFALSE 55393
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
55333: LD_ADDR_VAR 0 4
55337: PUSH
55338: LD_EXP 101
55342: PUSH
55343: LD_VAR 0 2
55347: ARRAY
55348: PPUSH
55349: LD_INT 2
55351: PUSH
55352: LD_INT 25
55354: PUSH
55355: LD_INT 2
55357: PUSH
55358: EMPTY
55359: LIST
55360: LIST
55361: PUSH
55362: LD_INT 25
55364: PUSH
55365: LD_INT 3
55367: PUSH
55368: EMPTY
55369: LIST
55370: LIST
55371: PUSH
55372: LD_INT 25
55374: PUSH
55375: LD_INT 4
55377: PUSH
55378: EMPTY
55379: LIST
55380: LIST
55381: PUSH
55382: EMPTY
55383: LIST
55384: LIST
55385: LIST
55386: LIST
55387: PPUSH
55388: CALL_OW 72
55392: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
55393: LD_VAR 0 2
55397: PPUSH
55398: LD_VAR 0 4
55402: PPUSH
55403: CALL 137475 0 2
// exit ;
55407: POP
55408: POP
55409: GO 55531
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
55411: LD_EXP 124
55415: PUSH
55416: LD_VAR 0 2
55420: ARRAY
55421: PUSH
55422: LD_EXP 144
55426: PUSH
55427: LD_VAR 0 2
55431: ARRAY
55432: NOT
55433: AND
55434: PUSH
55435: LD_EXP 123
55439: PUSH
55440: LD_VAR 0 2
55444: ARRAY
55445: AND
55446: IFFALSE 55527
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
55448: LD_ADDR_EXP 144
55452: PUSH
55453: LD_EXP 144
55457: PPUSH
55458: LD_VAR 0 2
55462: PPUSH
55463: LD_INT 1
55465: PPUSH
55466: CALL_OW 1
55470: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
55471: LD_ADDR_VAR 0 4
55475: PUSH
55476: LD_EXP 123
55480: PUSH
55481: LD_VAR 0 2
55485: ARRAY
55486: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
55487: LD_ADDR_EXP 123
55491: PUSH
55492: LD_EXP 123
55496: PPUSH
55497: LD_VAR 0 2
55501: PPUSH
55502: EMPTY
55503: PPUSH
55504: CALL_OW 1
55508: ST_TO_ADDR
// Defend ( i , tmp ) ;
55509: LD_VAR 0 2
55513: PPUSH
55514: LD_VAR 0 4
55518: PPUSH
55519: CALL 138071 0 2
// exit ;
55523: POP
55524: POP
55525: GO 55531
// end ; end ;
55527: GO 54689
55529: POP
55530: POP
// end ;
55531: LD_VAR 0 1
55535: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
55536: LD_INT 0
55538: PPUSH
55539: PPUSH
55540: PPUSH
55541: PPUSH
55542: PPUSH
55543: PPUSH
55544: PPUSH
55545: PPUSH
55546: PPUSH
55547: PPUSH
55548: PPUSH
// if not mc_bases then
55549: LD_EXP 101
55553: NOT
55554: IFFALSE 55558
// exit ;
55556: GO 56645
// for i = 1 to mc_bases do
55558: LD_ADDR_VAR 0 2
55562: PUSH
55563: DOUBLE
55564: LD_INT 1
55566: DEC
55567: ST_TO_ADDR
55568: LD_EXP 101
55572: PUSH
55573: FOR_TO
55574: IFFALSE 56643
// begin tmp := mc_lab [ i ] ;
55576: LD_ADDR_VAR 0 6
55580: PUSH
55581: LD_EXP 134
55585: PUSH
55586: LD_VAR 0 2
55590: ARRAY
55591: ST_TO_ADDR
// if not tmp then
55592: LD_VAR 0 6
55596: NOT
55597: IFFALSE 55601
// continue ;
55599: GO 55573
// idle_lab := 0 ;
55601: LD_ADDR_VAR 0 11
55605: PUSH
55606: LD_INT 0
55608: ST_TO_ADDR
// for j in tmp do
55609: LD_ADDR_VAR 0 3
55613: PUSH
55614: LD_VAR 0 6
55618: PUSH
55619: FOR_IN
55620: IFFALSE 56639
// begin researching := false ;
55622: LD_ADDR_VAR 0 10
55626: PUSH
55627: LD_INT 0
55629: ST_TO_ADDR
// side := GetSide ( j ) ;
55630: LD_ADDR_VAR 0 4
55634: PUSH
55635: LD_VAR 0 3
55639: PPUSH
55640: CALL_OW 255
55644: ST_TO_ADDR
// if not mc_tech [ side ] then
55645: LD_EXP 128
55649: PUSH
55650: LD_VAR 0 4
55654: ARRAY
55655: NOT
55656: IFFALSE 55660
// continue ;
55658: GO 55619
// if BuildingStatus ( j ) = bs_idle then
55660: LD_VAR 0 3
55664: PPUSH
55665: CALL_OW 461
55669: PUSH
55670: LD_INT 2
55672: EQUAL
55673: IFFALSE 55861
// begin if idle_lab and UnitsInside ( j ) < 6 then
55675: LD_VAR 0 11
55679: PUSH
55680: LD_VAR 0 3
55684: PPUSH
55685: CALL_OW 313
55689: PUSH
55690: LD_INT 6
55692: LESS
55693: AND
55694: IFFALSE 55765
// begin tmp2 := UnitsInside ( idle_lab ) ;
55696: LD_ADDR_VAR 0 9
55700: PUSH
55701: LD_VAR 0 11
55705: PPUSH
55706: CALL_OW 313
55710: ST_TO_ADDR
// if tmp2 then
55711: LD_VAR 0 9
55715: IFFALSE 55757
// for x in tmp2 do
55717: LD_ADDR_VAR 0 7
55721: PUSH
55722: LD_VAR 0 9
55726: PUSH
55727: FOR_IN
55728: IFFALSE 55755
// begin ComExitBuilding ( x ) ;
55730: LD_VAR 0 7
55734: PPUSH
55735: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
55739: LD_VAR 0 7
55743: PPUSH
55744: LD_VAR 0 3
55748: PPUSH
55749: CALL_OW 180
// end ;
55753: GO 55727
55755: POP
55756: POP
// idle_lab := 0 ;
55757: LD_ADDR_VAR 0 11
55761: PUSH
55762: LD_INT 0
55764: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
55765: LD_ADDR_VAR 0 5
55769: PUSH
55770: LD_EXP 128
55774: PUSH
55775: LD_VAR 0 4
55779: ARRAY
55780: PUSH
55781: FOR_IN
55782: IFFALSE 55842
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
55784: LD_VAR 0 3
55788: PPUSH
55789: LD_VAR 0 5
55793: PPUSH
55794: CALL_OW 430
55798: PUSH
55799: LD_VAR 0 4
55803: PPUSH
55804: LD_VAR 0 5
55808: PPUSH
55809: CALL 70300 0 2
55813: AND
55814: IFFALSE 55840
// begin researching := true ;
55816: LD_ADDR_VAR 0 10
55820: PUSH
55821: LD_INT 1
55823: ST_TO_ADDR
// ComResearch ( j , t ) ;
55824: LD_VAR 0 3
55828: PPUSH
55829: LD_VAR 0 5
55833: PPUSH
55834: CALL_OW 124
// break ;
55838: GO 55842
// end ;
55840: GO 55781
55842: POP
55843: POP
// if not researching then
55844: LD_VAR 0 10
55848: NOT
55849: IFFALSE 55861
// idle_lab := j ;
55851: LD_ADDR_VAR 0 11
55855: PUSH
55856: LD_VAR 0 3
55860: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
55861: LD_VAR 0 3
55865: PPUSH
55866: CALL_OW 461
55870: PUSH
55871: LD_INT 10
55873: EQUAL
55874: IFFALSE 56462
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
55876: LD_EXP 130
55880: PUSH
55881: LD_VAR 0 2
55885: ARRAY
55886: NOT
55887: PUSH
55888: LD_EXP 131
55892: PUSH
55893: LD_VAR 0 2
55897: ARRAY
55898: NOT
55899: AND
55900: PUSH
55901: LD_EXP 128
55905: PUSH
55906: LD_VAR 0 4
55910: ARRAY
55911: PUSH
55912: LD_INT 1
55914: GREATER
55915: AND
55916: IFFALSE 56047
// begin ComCancel ( j ) ;
55918: LD_VAR 0 3
55922: PPUSH
55923: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
55927: LD_ADDR_EXP 128
55931: PUSH
55932: LD_EXP 128
55936: PPUSH
55937: LD_VAR 0 4
55941: PPUSH
55942: LD_EXP 128
55946: PUSH
55947: LD_VAR 0 4
55951: ARRAY
55952: PPUSH
55953: LD_EXP 128
55957: PUSH
55958: LD_VAR 0 4
55962: ARRAY
55963: PUSH
55964: LD_INT 1
55966: MINUS
55967: PPUSH
55968: LD_EXP 128
55972: PUSH
55973: LD_VAR 0 4
55977: ARRAY
55978: PPUSH
55979: LD_INT 0
55981: PPUSH
55982: CALL 73824 0 4
55986: PPUSH
55987: CALL_OW 1
55991: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
55992: LD_ADDR_EXP 128
55996: PUSH
55997: LD_EXP 128
56001: PPUSH
56002: LD_VAR 0 4
56006: PPUSH
56007: LD_EXP 128
56011: PUSH
56012: LD_VAR 0 4
56016: ARRAY
56017: PPUSH
56018: LD_EXP 128
56022: PUSH
56023: LD_VAR 0 4
56027: ARRAY
56028: PPUSH
56029: LD_INT 1
56031: PPUSH
56032: LD_INT 0
56034: PPUSH
56035: CALL 73824 0 4
56039: PPUSH
56040: CALL_OW 1
56044: ST_TO_ADDR
// continue ;
56045: GO 55619
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
56047: LD_EXP 130
56051: PUSH
56052: LD_VAR 0 2
56056: ARRAY
56057: PUSH
56058: LD_EXP 131
56062: PUSH
56063: LD_VAR 0 2
56067: ARRAY
56068: NOT
56069: AND
56070: IFFALSE 56197
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
56072: LD_ADDR_EXP 131
56076: PUSH
56077: LD_EXP 131
56081: PPUSH
56082: LD_VAR 0 2
56086: PUSH
56087: LD_EXP 131
56091: PUSH
56092: LD_VAR 0 2
56096: ARRAY
56097: PUSH
56098: LD_INT 1
56100: PLUS
56101: PUSH
56102: EMPTY
56103: LIST
56104: LIST
56105: PPUSH
56106: LD_EXP 130
56110: PUSH
56111: LD_VAR 0 2
56115: ARRAY
56116: PUSH
56117: LD_INT 1
56119: ARRAY
56120: PPUSH
56121: CALL 74406 0 3
56125: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
56126: LD_EXP 130
56130: PUSH
56131: LD_VAR 0 2
56135: ARRAY
56136: PUSH
56137: LD_INT 1
56139: ARRAY
56140: PPUSH
56141: LD_INT 112
56143: PPUSH
56144: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
56148: LD_ADDR_VAR 0 9
56152: PUSH
56153: LD_EXP 130
56157: PUSH
56158: LD_VAR 0 2
56162: ARRAY
56163: PPUSH
56164: LD_INT 1
56166: PPUSH
56167: CALL_OW 3
56171: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
56172: LD_ADDR_EXP 130
56176: PUSH
56177: LD_EXP 130
56181: PPUSH
56182: LD_VAR 0 2
56186: PPUSH
56187: LD_VAR 0 9
56191: PPUSH
56192: CALL_OW 1
56196: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
56197: LD_EXP 130
56201: PUSH
56202: LD_VAR 0 2
56206: ARRAY
56207: PUSH
56208: LD_EXP 131
56212: PUSH
56213: LD_VAR 0 2
56217: ARRAY
56218: AND
56219: PUSH
56220: LD_EXP 131
56224: PUSH
56225: LD_VAR 0 2
56229: ARRAY
56230: PUSH
56231: LD_INT 1
56233: ARRAY
56234: PPUSH
56235: CALL_OW 310
56239: NOT
56240: AND
56241: PUSH
56242: LD_VAR 0 3
56246: PPUSH
56247: CALL_OW 313
56251: PUSH
56252: LD_INT 6
56254: EQUAL
56255: AND
56256: IFFALSE 56312
// begin tmp2 := UnitsInside ( j ) ;
56258: LD_ADDR_VAR 0 9
56262: PUSH
56263: LD_VAR 0 3
56267: PPUSH
56268: CALL_OW 313
56272: ST_TO_ADDR
// if tmp2 = 6 then
56273: LD_VAR 0 9
56277: PUSH
56278: LD_INT 6
56280: EQUAL
56281: IFFALSE 56312
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
56283: LD_VAR 0 9
56287: PUSH
56288: LD_INT 1
56290: ARRAY
56291: PPUSH
56292: LD_INT 112
56294: PPUSH
56295: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
56299: LD_VAR 0 9
56303: PUSH
56304: LD_INT 1
56306: ARRAY
56307: PPUSH
56308: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
56312: LD_EXP 131
56316: PUSH
56317: LD_VAR 0 2
56321: ARRAY
56322: PUSH
56323: LD_EXP 131
56327: PUSH
56328: LD_VAR 0 2
56332: ARRAY
56333: PUSH
56334: LD_INT 1
56336: ARRAY
56337: PPUSH
56338: CALL_OW 314
56342: NOT
56343: AND
56344: PUSH
56345: LD_EXP 131
56349: PUSH
56350: LD_VAR 0 2
56354: ARRAY
56355: PUSH
56356: LD_INT 1
56358: ARRAY
56359: PPUSH
56360: CALL_OW 310
56364: NOT
56365: AND
56366: IFFALSE 56392
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
56368: LD_EXP 131
56372: PUSH
56373: LD_VAR 0 2
56377: ARRAY
56378: PUSH
56379: LD_INT 1
56381: ARRAY
56382: PPUSH
56383: LD_VAR 0 3
56387: PPUSH
56388: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
56392: LD_EXP 131
56396: PUSH
56397: LD_VAR 0 2
56401: ARRAY
56402: PUSH
56403: LD_INT 1
56405: ARRAY
56406: PPUSH
56407: CALL_OW 310
56411: PUSH
56412: LD_EXP 131
56416: PUSH
56417: LD_VAR 0 2
56421: ARRAY
56422: PUSH
56423: LD_INT 1
56425: ARRAY
56426: PPUSH
56427: CALL_OW 310
56431: PPUSH
56432: CALL_OW 461
56436: PUSH
56437: LD_INT 3
56439: NONEQUAL
56440: AND
56441: IFFALSE 56462
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
56443: LD_EXP 131
56447: PUSH
56448: LD_VAR 0 2
56452: ARRAY
56453: PUSH
56454: LD_INT 1
56456: ARRAY
56457: PPUSH
56458: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
56462: LD_VAR 0 3
56466: PPUSH
56467: CALL_OW 461
56471: PUSH
56472: LD_INT 6
56474: EQUAL
56475: PUSH
56476: LD_VAR 0 6
56480: PUSH
56481: LD_INT 1
56483: GREATER
56484: AND
56485: IFFALSE 56637
// begin sci := [ ] ;
56487: LD_ADDR_VAR 0 8
56491: PUSH
56492: EMPTY
56493: ST_TO_ADDR
// for x in ( tmp diff j ) do
56494: LD_ADDR_VAR 0 7
56498: PUSH
56499: LD_VAR 0 6
56503: PUSH
56504: LD_VAR 0 3
56508: DIFF
56509: PUSH
56510: FOR_IN
56511: IFFALSE 56563
// begin if sci = 6 then
56513: LD_VAR 0 8
56517: PUSH
56518: LD_INT 6
56520: EQUAL
56521: IFFALSE 56525
// break ;
56523: GO 56563
// if BuildingStatus ( x ) = bs_idle then
56525: LD_VAR 0 7
56529: PPUSH
56530: CALL_OW 461
56534: PUSH
56535: LD_INT 2
56537: EQUAL
56538: IFFALSE 56561
// sci := sci ^ UnitsInside ( x ) ;
56540: LD_ADDR_VAR 0 8
56544: PUSH
56545: LD_VAR 0 8
56549: PUSH
56550: LD_VAR 0 7
56554: PPUSH
56555: CALL_OW 313
56559: ADD
56560: ST_TO_ADDR
// end ;
56561: GO 56510
56563: POP
56564: POP
// if not sci then
56565: LD_VAR 0 8
56569: NOT
56570: IFFALSE 56574
// continue ;
56572: GO 55619
// for x in sci do
56574: LD_ADDR_VAR 0 7
56578: PUSH
56579: LD_VAR 0 8
56583: PUSH
56584: FOR_IN
56585: IFFALSE 56635
// if IsInUnit ( x ) and not HasTask ( x ) then
56587: LD_VAR 0 7
56591: PPUSH
56592: CALL_OW 310
56596: PUSH
56597: LD_VAR 0 7
56601: PPUSH
56602: CALL_OW 314
56606: NOT
56607: AND
56608: IFFALSE 56633
// begin ComExitBuilding ( x ) ;
56610: LD_VAR 0 7
56614: PPUSH
56615: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
56619: LD_VAR 0 7
56623: PPUSH
56624: LD_VAR 0 3
56628: PPUSH
56629: CALL_OW 180
// end ;
56633: GO 56584
56635: POP
56636: POP
// end ; end ;
56637: GO 55619
56639: POP
56640: POP
// end ;
56641: GO 55573
56643: POP
56644: POP
// end ;
56645: LD_VAR 0 1
56649: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
56650: LD_INT 0
56652: PPUSH
56653: PPUSH
// if not mc_bases then
56654: LD_EXP 101
56658: NOT
56659: IFFALSE 56663
// exit ;
56661: GO 56744
// for i = 1 to mc_bases do
56663: LD_ADDR_VAR 0 2
56667: PUSH
56668: DOUBLE
56669: LD_INT 1
56671: DEC
56672: ST_TO_ADDR
56673: LD_EXP 101
56677: PUSH
56678: FOR_TO
56679: IFFALSE 56742
// if mc_mines [ i ] and mc_miners [ i ] then
56681: LD_EXP 114
56685: PUSH
56686: LD_VAR 0 2
56690: ARRAY
56691: PUSH
56692: LD_EXP 115
56696: PUSH
56697: LD_VAR 0 2
56701: ARRAY
56702: AND
56703: IFFALSE 56740
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
56705: LD_EXP 115
56709: PUSH
56710: LD_VAR 0 2
56714: ARRAY
56715: PUSH
56716: LD_INT 1
56718: ARRAY
56719: PPUSH
56720: CALL_OW 255
56724: PPUSH
56725: LD_EXP 114
56729: PUSH
56730: LD_VAR 0 2
56734: ARRAY
56735: PPUSH
56736: CALL 71383 0 2
56740: GO 56678
56742: POP
56743: POP
// end ;
56744: LD_VAR 0 1
56748: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
56749: LD_INT 0
56751: PPUSH
56752: PPUSH
56753: PPUSH
56754: PPUSH
56755: PPUSH
56756: PPUSH
56757: PPUSH
56758: PPUSH
// if not mc_bases or not mc_parking then
56759: LD_EXP 101
56763: NOT
56764: PUSH
56765: LD_EXP 125
56769: NOT
56770: OR
56771: IFFALSE 56775
// exit ;
56773: GO 57513
// for i = 1 to mc_bases do
56775: LD_ADDR_VAR 0 2
56779: PUSH
56780: DOUBLE
56781: LD_INT 1
56783: DEC
56784: ST_TO_ADDR
56785: LD_EXP 101
56789: PUSH
56790: FOR_TO
56791: IFFALSE 57511
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
56793: LD_EXP 101
56797: PUSH
56798: LD_VAR 0 2
56802: ARRAY
56803: NOT
56804: PUSH
56805: LD_EXP 125
56809: PUSH
56810: LD_VAR 0 2
56814: ARRAY
56815: NOT
56816: OR
56817: IFFALSE 56821
// continue ;
56819: GO 56790
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
56821: LD_ADDR_VAR 0 5
56825: PUSH
56826: LD_EXP 101
56830: PUSH
56831: LD_VAR 0 2
56835: ARRAY
56836: PUSH
56837: LD_INT 1
56839: ARRAY
56840: PPUSH
56841: CALL_OW 255
56845: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
56846: LD_ADDR_VAR 0 6
56850: PUSH
56851: LD_EXP 101
56855: PUSH
56856: LD_VAR 0 2
56860: ARRAY
56861: PPUSH
56862: LD_INT 30
56864: PUSH
56865: LD_INT 3
56867: PUSH
56868: EMPTY
56869: LIST
56870: LIST
56871: PPUSH
56872: CALL_OW 72
56876: ST_TO_ADDR
// if not fac then
56877: LD_VAR 0 6
56881: NOT
56882: IFFALSE 56933
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56884: LD_ADDR_VAR 0 6
56888: PUSH
56889: LD_EXP 101
56893: PUSH
56894: LD_VAR 0 2
56898: ARRAY
56899: PPUSH
56900: LD_INT 2
56902: PUSH
56903: LD_INT 30
56905: PUSH
56906: LD_INT 0
56908: PUSH
56909: EMPTY
56910: LIST
56911: LIST
56912: PUSH
56913: LD_INT 30
56915: PUSH
56916: LD_INT 1
56918: PUSH
56919: EMPTY
56920: LIST
56921: LIST
56922: PUSH
56923: EMPTY
56924: LIST
56925: LIST
56926: LIST
56927: PPUSH
56928: CALL_OW 72
56932: ST_TO_ADDR
// if not fac then
56933: LD_VAR 0 6
56937: NOT
56938: IFFALSE 56942
// continue ;
56940: GO 56790
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
56942: LD_ADDR_VAR 0 7
56946: PUSH
56947: LD_EXP 125
56951: PUSH
56952: LD_VAR 0 2
56956: ARRAY
56957: PPUSH
56958: LD_INT 22
56960: PUSH
56961: LD_VAR 0 5
56965: PUSH
56966: EMPTY
56967: LIST
56968: LIST
56969: PUSH
56970: LD_INT 21
56972: PUSH
56973: LD_INT 2
56975: PUSH
56976: EMPTY
56977: LIST
56978: LIST
56979: PUSH
56980: LD_INT 3
56982: PUSH
56983: LD_INT 60
56985: PUSH
56986: EMPTY
56987: LIST
56988: PUSH
56989: EMPTY
56990: LIST
56991: LIST
56992: PUSH
56993: LD_INT 3
56995: PUSH
56996: LD_INT 24
56998: PUSH
56999: LD_INT 1000
57001: PUSH
57002: EMPTY
57003: LIST
57004: LIST
57005: PUSH
57006: EMPTY
57007: LIST
57008: LIST
57009: PUSH
57010: EMPTY
57011: LIST
57012: LIST
57013: LIST
57014: LIST
57015: PPUSH
57016: CALL_OW 70
57020: ST_TO_ADDR
// for j in fac do
57021: LD_ADDR_VAR 0 3
57025: PUSH
57026: LD_VAR 0 6
57030: PUSH
57031: FOR_IN
57032: IFFALSE 57127
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
57034: LD_ADDR_VAR 0 7
57038: PUSH
57039: LD_VAR 0 7
57043: PUSH
57044: LD_INT 22
57046: PUSH
57047: LD_VAR 0 5
57051: PUSH
57052: EMPTY
57053: LIST
57054: LIST
57055: PUSH
57056: LD_INT 91
57058: PUSH
57059: LD_VAR 0 3
57063: PUSH
57064: LD_INT 15
57066: PUSH
57067: EMPTY
57068: LIST
57069: LIST
57070: LIST
57071: PUSH
57072: LD_INT 21
57074: PUSH
57075: LD_INT 2
57077: PUSH
57078: EMPTY
57079: LIST
57080: LIST
57081: PUSH
57082: LD_INT 3
57084: PUSH
57085: LD_INT 60
57087: PUSH
57088: EMPTY
57089: LIST
57090: PUSH
57091: EMPTY
57092: LIST
57093: LIST
57094: PUSH
57095: LD_INT 3
57097: PUSH
57098: LD_INT 24
57100: PUSH
57101: LD_INT 1000
57103: PUSH
57104: EMPTY
57105: LIST
57106: LIST
57107: PUSH
57108: EMPTY
57109: LIST
57110: LIST
57111: PUSH
57112: EMPTY
57113: LIST
57114: LIST
57115: LIST
57116: LIST
57117: LIST
57118: PPUSH
57119: CALL_OW 69
57123: UNION
57124: ST_TO_ADDR
57125: GO 57031
57127: POP
57128: POP
// if not vehs then
57129: LD_VAR 0 7
57133: NOT
57134: IFFALSE 57160
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57136: LD_ADDR_EXP 113
57140: PUSH
57141: LD_EXP 113
57145: PPUSH
57146: LD_VAR 0 2
57150: PPUSH
57151: EMPTY
57152: PPUSH
57153: CALL_OW 1
57157: ST_TO_ADDR
// continue ;
57158: GO 56790
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
57160: LD_ADDR_VAR 0 8
57164: PUSH
57165: LD_EXP 101
57169: PUSH
57170: LD_VAR 0 2
57174: ARRAY
57175: PPUSH
57176: LD_INT 30
57178: PUSH
57179: LD_INT 3
57181: PUSH
57182: EMPTY
57183: LIST
57184: LIST
57185: PPUSH
57186: CALL_OW 72
57190: ST_TO_ADDR
// if tmp then
57191: LD_VAR 0 8
57195: IFFALSE 57298
// begin for j in tmp do
57197: LD_ADDR_VAR 0 3
57201: PUSH
57202: LD_VAR 0 8
57206: PUSH
57207: FOR_IN
57208: IFFALSE 57296
// for k in UnitsInside ( j ) do
57210: LD_ADDR_VAR 0 4
57214: PUSH
57215: LD_VAR 0 3
57219: PPUSH
57220: CALL_OW 313
57224: PUSH
57225: FOR_IN
57226: IFFALSE 57292
// if k then
57228: LD_VAR 0 4
57232: IFFALSE 57290
// if not k in mc_repair_vehicle [ i ] then
57234: LD_VAR 0 4
57238: PUSH
57239: LD_EXP 113
57243: PUSH
57244: LD_VAR 0 2
57248: ARRAY
57249: IN
57250: NOT
57251: IFFALSE 57290
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
57253: LD_ADDR_EXP 113
57257: PUSH
57258: LD_EXP 113
57262: PPUSH
57263: LD_VAR 0 2
57267: PPUSH
57268: LD_EXP 113
57272: PUSH
57273: LD_VAR 0 2
57277: ARRAY
57278: PUSH
57279: LD_VAR 0 4
57283: UNION
57284: PPUSH
57285: CALL_OW 1
57289: ST_TO_ADDR
57290: GO 57225
57292: POP
57293: POP
57294: GO 57207
57296: POP
57297: POP
// end ; if not mc_repair_vehicle [ i ] then
57298: LD_EXP 113
57302: PUSH
57303: LD_VAR 0 2
57307: ARRAY
57308: NOT
57309: IFFALSE 57313
// continue ;
57311: GO 56790
// for j in mc_repair_vehicle [ i ] do
57313: LD_ADDR_VAR 0 3
57317: PUSH
57318: LD_EXP 113
57322: PUSH
57323: LD_VAR 0 2
57327: ARRAY
57328: PUSH
57329: FOR_IN
57330: IFFALSE 57507
// begin if GetClass ( j ) <> 3 then
57332: LD_VAR 0 3
57336: PPUSH
57337: CALL_OW 257
57341: PUSH
57342: LD_INT 3
57344: NONEQUAL
57345: IFFALSE 57386
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
57347: LD_ADDR_EXP 113
57351: PUSH
57352: LD_EXP 113
57356: PPUSH
57357: LD_VAR 0 2
57361: PPUSH
57362: LD_EXP 113
57366: PUSH
57367: LD_VAR 0 2
57371: ARRAY
57372: PUSH
57373: LD_VAR 0 3
57377: DIFF
57378: PPUSH
57379: CALL_OW 1
57383: ST_TO_ADDR
// continue ;
57384: GO 57329
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
57386: LD_VAR 0 3
57390: PPUSH
57391: CALL_OW 311
57395: NOT
57396: PUSH
57397: LD_VAR 0 3
57401: PUSH
57402: LD_EXP 104
57406: PUSH
57407: LD_VAR 0 2
57411: ARRAY
57412: PUSH
57413: LD_INT 1
57415: ARRAY
57416: IN
57417: NOT
57418: AND
57419: PUSH
57420: LD_VAR 0 3
57424: PUSH
57425: LD_EXP 104
57429: PUSH
57430: LD_VAR 0 2
57434: ARRAY
57435: PUSH
57436: LD_INT 2
57438: ARRAY
57439: IN
57440: NOT
57441: AND
57442: IFFALSE 57505
// begin if IsInUnit ( j ) then
57444: LD_VAR 0 3
57448: PPUSH
57449: CALL_OW 310
57453: IFFALSE 57466
// ComExitBuilding ( j ) else
57455: LD_VAR 0 3
57459: PPUSH
57460: CALL_OW 122
57464: GO 57505
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
57466: LD_VAR 0 3
57470: PPUSH
57471: LD_VAR 0 7
57475: PUSH
57476: LD_INT 1
57478: ARRAY
57479: PPUSH
57480: CALL 109200 0 2
57484: NOT
57485: IFFALSE 57505
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
57487: LD_VAR 0 3
57491: PPUSH
57492: LD_VAR 0 7
57496: PUSH
57497: LD_INT 1
57499: ARRAY
57500: PPUSH
57501: CALL_OW 129
// end ; end ;
57505: GO 57329
57507: POP
57508: POP
// end ;
57509: GO 56790
57511: POP
57512: POP
// end ;
57513: LD_VAR 0 1
57517: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
57518: LD_INT 0
57520: PPUSH
57521: PPUSH
57522: PPUSH
57523: PPUSH
57524: PPUSH
57525: PPUSH
57526: PPUSH
57527: PPUSH
57528: PPUSH
57529: PPUSH
57530: PPUSH
// if not mc_bases then
57531: LD_EXP 101
57535: NOT
57536: IFFALSE 57540
// exit ;
57538: GO 58342
// for i = 1 to mc_bases do
57540: LD_ADDR_VAR 0 2
57544: PUSH
57545: DOUBLE
57546: LD_INT 1
57548: DEC
57549: ST_TO_ADDR
57550: LD_EXP 101
57554: PUSH
57555: FOR_TO
57556: IFFALSE 58340
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
57558: LD_EXP 129
57562: PUSH
57563: LD_VAR 0 2
57567: ARRAY
57568: NOT
57569: PUSH
57570: LD_EXP 104
57574: PUSH
57575: LD_VAR 0 2
57579: ARRAY
57580: PUSH
57581: LD_INT 1
57583: ARRAY
57584: OR
57585: PUSH
57586: LD_EXP 104
57590: PUSH
57591: LD_VAR 0 2
57595: ARRAY
57596: PUSH
57597: LD_INT 2
57599: ARRAY
57600: OR
57601: PUSH
57602: LD_EXP 127
57606: PUSH
57607: LD_VAR 0 2
57611: ARRAY
57612: PPUSH
57613: LD_INT 1
57615: PPUSH
57616: CALL_OW 325
57620: NOT
57621: OR
57622: PUSH
57623: LD_EXP 124
57627: PUSH
57628: LD_VAR 0 2
57632: ARRAY
57633: OR
57634: IFFALSE 57638
// continue ;
57636: GO 57555
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
57638: LD_ADDR_VAR 0 8
57642: PUSH
57643: LD_EXP 101
57647: PUSH
57648: LD_VAR 0 2
57652: ARRAY
57653: PPUSH
57654: LD_INT 25
57656: PUSH
57657: LD_INT 4
57659: PUSH
57660: EMPTY
57661: LIST
57662: LIST
57663: PUSH
57664: LD_INT 50
57666: PUSH
57667: EMPTY
57668: LIST
57669: PUSH
57670: LD_INT 3
57672: PUSH
57673: LD_INT 60
57675: PUSH
57676: EMPTY
57677: LIST
57678: PUSH
57679: EMPTY
57680: LIST
57681: LIST
57682: PUSH
57683: EMPTY
57684: LIST
57685: LIST
57686: LIST
57687: PPUSH
57688: CALL_OW 72
57692: PUSH
57693: LD_EXP 105
57697: PUSH
57698: LD_VAR 0 2
57702: ARRAY
57703: DIFF
57704: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57705: LD_ADDR_VAR 0 9
57709: PUSH
57710: LD_EXP 101
57714: PUSH
57715: LD_VAR 0 2
57719: ARRAY
57720: PPUSH
57721: LD_INT 2
57723: PUSH
57724: LD_INT 30
57726: PUSH
57727: LD_INT 0
57729: PUSH
57730: EMPTY
57731: LIST
57732: LIST
57733: PUSH
57734: LD_INT 30
57736: PUSH
57737: LD_INT 1
57739: PUSH
57740: EMPTY
57741: LIST
57742: LIST
57743: PUSH
57744: EMPTY
57745: LIST
57746: LIST
57747: LIST
57748: PPUSH
57749: CALL_OW 72
57753: ST_TO_ADDR
// if not tmp or not dep then
57754: LD_VAR 0 8
57758: NOT
57759: PUSH
57760: LD_VAR 0 9
57764: NOT
57765: OR
57766: IFFALSE 57770
// continue ;
57768: GO 57555
// side := GetSide ( tmp [ 1 ] ) ;
57770: LD_ADDR_VAR 0 11
57774: PUSH
57775: LD_VAR 0 8
57779: PUSH
57780: LD_INT 1
57782: ARRAY
57783: PPUSH
57784: CALL_OW 255
57788: ST_TO_ADDR
// dep := dep [ 1 ] ;
57789: LD_ADDR_VAR 0 9
57793: PUSH
57794: LD_VAR 0 9
57798: PUSH
57799: LD_INT 1
57801: ARRAY
57802: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
57803: LD_ADDR_VAR 0 7
57807: PUSH
57808: LD_EXP 129
57812: PUSH
57813: LD_VAR 0 2
57817: ARRAY
57818: PPUSH
57819: LD_INT 22
57821: PUSH
57822: LD_INT 0
57824: PUSH
57825: EMPTY
57826: LIST
57827: LIST
57828: PUSH
57829: LD_INT 25
57831: PUSH
57832: LD_INT 12
57834: PUSH
57835: EMPTY
57836: LIST
57837: LIST
57838: PUSH
57839: EMPTY
57840: LIST
57841: LIST
57842: PPUSH
57843: CALL_OW 70
57847: PUSH
57848: LD_INT 22
57850: PUSH
57851: LD_INT 0
57853: PUSH
57854: EMPTY
57855: LIST
57856: LIST
57857: PUSH
57858: LD_INT 25
57860: PUSH
57861: LD_INT 12
57863: PUSH
57864: EMPTY
57865: LIST
57866: LIST
57867: PUSH
57868: LD_INT 91
57870: PUSH
57871: LD_VAR 0 9
57875: PUSH
57876: LD_INT 20
57878: PUSH
57879: EMPTY
57880: LIST
57881: LIST
57882: LIST
57883: PUSH
57884: EMPTY
57885: LIST
57886: LIST
57887: LIST
57888: PPUSH
57889: CALL_OW 69
57893: UNION
57894: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
57895: LD_ADDR_VAR 0 10
57899: PUSH
57900: LD_EXP 129
57904: PUSH
57905: LD_VAR 0 2
57909: ARRAY
57910: PPUSH
57911: LD_INT 81
57913: PUSH
57914: LD_VAR 0 11
57918: PUSH
57919: EMPTY
57920: LIST
57921: LIST
57922: PPUSH
57923: CALL_OW 70
57927: ST_TO_ADDR
// if not apes or danger_at_area then
57928: LD_VAR 0 7
57932: NOT
57933: PUSH
57934: LD_VAR 0 10
57938: OR
57939: IFFALSE 57989
// begin if mc_taming [ i ] then
57941: LD_EXP 132
57945: PUSH
57946: LD_VAR 0 2
57950: ARRAY
57951: IFFALSE 57987
// begin MC_Reset ( i , 121 ) ;
57953: LD_VAR 0 2
57957: PPUSH
57958: LD_INT 121
57960: PPUSH
57961: CALL 42905 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57965: LD_ADDR_EXP 132
57969: PUSH
57970: LD_EXP 132
57974: PPUSH
57975: LD_VAR 0 2
57979: PPUSH
57980: EMPTY
57981: PPUSH
57982: CALL_OW 1
57986: ST_TO_ADDR
// end ; continue ;
57987: GO 57555
// end ; for j in tmp do
57989: LD_ADDR_VAR 0 3
57993: PUSH
57994: LD_VAR 0 8
57998: PUSH
57999: FOR_IN
58000: IFFALSE 58336
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
58002: LD_VAR 0 3
58006: PUSH
58007: LD_EXP 132
58011: PUSH
58012: LD_VAR 0 2
58016: ARRAY
58017: IN
58018: NOT
58019: PUSH
58020: LD_EXP 132
58024: PUSH
58025: LD_VAR 0 2
58029: ARRAY
58030: PUSH
58031: LD_INT 3
58033: LESS
58034: AND
58035: IFFALSE 58093
// begin SetTag ( j , 121 ) ;
58037: LD_VAR 0 3
58041: PPUSH
58042: LD_INT 121
58044: PPUSH
58045: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
58049: LD_ADDR_EXP 132
58053: PUSH
58054: LD_EXP 132
58058: PPUSH
58059: LD_VAR 0 2
58063: PUSH
58064: LD_EXP 132
58068: PUSH
58069: LD_VAR 0 2
58073: ARRAY
58074: PUSH
58075: LD_INT 1
58077: PLUS
58078: PUSH
58079: EMPTY
58080: LIST
58081: LIST
58082: PPUSH
58083: LD_VAR 0 3
58087: PPUSH
58088: CALL 74406 0 3
58092: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
58093: LD_VAR 0 3
58097: PUSH
58098: LD_EXP 132
58102: PUSH
58103: LD_VAR 0 2
58107: ARRAY
58108: IN
58109: IFFALSE 58334
// begin if GetClass ( j ) <> 4 then
58111: LD_VAR 0 3
58115: PPUSH
58116: CALL_OW 257
58120: PUSH
58121: LD_INT 4
58123: NONEQUAL
58124: IFFALSE 58177
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
58126: LD_ADDR_EXP 132
58130: PUSH
58131: LD_EXP 132
58135: PPUSH
58136: LD_VAR 0 2
58140: PPUSH
58141: LD_EXP 132
58145: PUSH
58146: LD_VAR 0 2
58150: ARRAY
58151: PUSH
58152: LD_VAR 0 3
58156: DIFF
58157: PPUSH
58158: CALL_OW 1
58162: ST_TO_ADDR
// SetTag ( j , 0 ) ;
58163: LD_VAR 0 3
58167: PPUSH
58168: LD_INT 0
58170: PPUSH
58171: CALL_OW 109
// continue ;
58175: GO 57999
// end ; if IsInUnit ( j ) then
58177: LD_VAR 0 3
58181: PPUSH
58182: CALL_OW 310
58186: IFFALSE 58197
// ComExitBuilding ( j ) ;
58188: LD_VAR 0 3
58192: PPUSH
58193: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
58197: LD_ADDR_VAR 0 6
58201: PUSH
58202: LD_VAR 0 7
58206: PPUSH
58207: LD_VAR 0 3
58211: PPUSH
58212: CALL_OW 74
58216: ST_TO_ADDR
// if not ape then
58217: LD_VAR 0 6
58221: NOT
58222: IFFALSE 58226
// break ;
58224: GO 58336
// x := GetX ( ape ) ;
58226: LD_ADDR_VAR 0 4
58230: PUSH
58231: LD_VAR 0 6
58235: PPUSH
58236: CALL_OW 250
58240: ST_TO_ADDR
// y := GetY ( ape ) ;
58241: LD_ADDR_VAR 0 5
58245: PUSH
58246: LD_VAR 0 6
58250: PPUSH
58251: CALL_OW 251
58255: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
58256: LD_VAR 0 4
58260: PPUSH
58261: LD_VAR 0 5
58265: PPUSH
58266: CALL_OW 488
58270: NOT
58271: PUSH
58272: LD_VAR 0 11
58276: PPUSH
58277: LD_VAR 0 4
58281: PPUSH
58282: LD_VAR 0 5
58286: PPUSH
58287: LD_INT 20
58289: PPUSH
58290: CALL 75670 0 4
58294: PUSH
58295: LD_INT 4
58297: ARRAY
58298: OR
58299: IFFALSE 58303
// break ;
58301: GO 58336
// if not HasTask ( j ) then
58303: LD_VAR 0 3
58307: PPUSH
58308: CALL_OW 314
58312: NOT
58313: IFFALSE 58334
// ComTameXY ( j , x , y ) ;
58315: LD_VAR 0 3
58319: PPUSH
58320: LD_VAR 0 4
58324: PPUSH
58325: LD_VAR 0 5
58329: PPUSH
58330: CALL_OW 131
// end ; end ;
58334: GO 57999
58336: POP
58337: POP
// end ;
58338: GO 57555
58340: POP
58341: POP
// end ;
58342: LD_VAR 0 1
58346: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
58347: LD_INT 0
58349: PPUSH
58350: PPUSH
58351: PPUSH
58352: PPUSH
58353: PPUSH
58354: PPUSH
58355: PPUSH
58356: PPUSH
// if not mc_bases then
58357: LD_EXP 101
58361: NOT
58362: IFFALSE 58366
// exit ;
58364: GO 58992
// for i = 1 to mc_bases do
58366: LD_ADDR_VAR 0 2
58370: PUSH
58371: DOUBLE
58372: LD_INT 1
58374: DEC
58375: ST_TO_ADDR
58376: LD_EXP 101
58380: PUSH
58381: FOR_TO
58382: IFFALSE 58990
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
58384: LD_EXP 130
58388: PUSH
58389: LD_VAR 0 2
58393: ARRAY
58394: NOT
58395: PUSH
58396: LD_EXP 130
58400: PUSH
58401: LD_VAR 0 2
58405: ARRAY
58406: PPUSH
58407: LD_INT 25
58409: PUSH
58410: LD_INT 12
58412: PUSH
58413: EMPTY
58414: LIST
58415: LIST
58416: PPUSH
58417: CALL_OW 72
58421: NOT
58422: OR
58423: IFFALSE 58427
// continue ;
58425: GO 58381
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
58427: LD_ADDR_VAR 0 5
58431: PUSH
58432: LD_EXP 130
58436: PUSH
58437: LD_VAR 0 2
58441: ARRAY
58442: PUSH
58443: LD_INT 1
58445: ARRAY
58446: PPUSH
58447: CALL_OW 255
58451: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
58452: LD_VAR 0 5
58456: PPUSH
58457: LD_INT 2
58459: PPUSH
58460: CALL_OW 325
58464: IFFALSE 58717
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
58466: LD_ADDR_VAR 0 4
58470: PUSH
58471: LD_EXP 130
58475: PUSH
58476: LD_VAR 0 2
58480: ARRAY
58481: PPUSH
58482: LD_INT 25
58484: PUSH
58485: LD_INT 16
58487: PUSH
58488: EMPTY
58489: LIST
58490: LIST
58491: PPUSH
58492: CALL_OW 72
58496: ST_TO_ADDR
// if tmp < 6 then
58497: LD_VAR 0 4
58501: PUSH
58502: LD_INT 6
58504: LESS
58505: IFFALSE 58717
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58507: LD_ADDR_VAR 0 6
58511: PUSH
58512: LD_EXP 101
58516: PUSH
58517: LD_VAR 0 2
58521: ARRAY
58522: PPUSH
58523: LD_INT 2
58525: PUSH
58526: LD_INT 30
58528: PUSH
58529: LD_INT 0
58531: PUSH
58532: EMPTY
58533: LIST
58534: LIST
58535: PUSH
58536: LD_INT 30
58538: PUSH
58539: LD_INT 1
58541: PUSH
58542: EMPTY
58543: LIST
58544: LIST
58545: PUSH
58546: EMPTY
58547: LIST
58548: LIST
58549: LIST
58550: PPUSH
58551: CALL_OW 72
58555: ST_TO_ADDR
// if depot then
58556: LD_VAR 0 6
58560: IFFALSE 58717
// begin selected := 0 ;
58562: LD_ADDR_VAR 0 7
58566: PUSH
58567: LD_INT 0
58569: ST_TO_ADDR
// for j in depot do
58570: LD_ADDR_VAR 0 3
58574: PUSH
58575: LD_VAR 0 6
58579: PUSH
58580: FOR_IN
58581: IFFALSE 58612
// begin if UnitsInside ( j ) < 6 then
58583: LD_VAR 0 3
58587: PPUSH
58588: CALL_OW 313
58592: PUSH
58593: LD_INT 6
58595: LESS
58596: IFFALSE 58610
// begin selected := j ;
58598: LD_ADDR_VAR 0 7
58602: PUSH
58603: LD_VAR 0 3
58607: ST_TO_ADDR
// break ;
58608: GO 58612
// end ; end ;
58610: GO 58580
58612: POP
58613: POP
// if selected then
58614: LD_VAR 0 7
58618: IFFALSE 58717
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
58620: LD_ADDR_VAR 0 3
58624: PUSH
58625: LD_EXP 130
58629: PUSH
58630: LD_VAR 0 2
58634: ARRAY
58635: PPUSH
58636: LD_INT 25
58638: PUSH
58639: LD_INT 12
58641: PUSH
58642: EMPTY
58643: LIST
58644: LIST
58645: PPUSH
58646: CALL_OW 72
58650: PUSH
58651: FOR_IN
58652: IFFALSE 58715
// if not HasTask ( j ) then
58654: LD_VAR 0 3
58658: PPUSH
58659: CALL_OW 314
58663: NOT
58664: IFFALSE 58713
// begin if not IsInUnit ( j ) then
58666: LD_VAR 0 3
58670: PPUSH
58671: CALL_OW 310
58675: NOT
58676: IFFALSE 58692
// ComEnterUnit ( j , selected ) ;
58678: LD_VAR 0 3
58682: PPUSH
58683: LD_VAR 0 7
58687: PPUSH
58688: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
58692: LD_VAR 0 3
58696: PPUSH
58697: LD_INT 16
58699: PPUSH
58700: CALL_OW 183
// AddComExitBuilding ( j ) ;
58704: LD_VAR 0 3
58708: PPUSH
58709: CALL_OW 182
// end ;
58713: GO 58651
58715: POP
58716: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
58717: LD_VAR 0 5
58721: PPUSH
58722: LD_INT 11
58724: PPUSH
58725: CALL_OW 325
58729: IFFALSE 58988
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
58731: LD_ADDR_VAR 0 4
58735: PUSH
58736: LD_EXP 130
58740: PUSH
58741: LD_VAR 0 2
58745: ARRAY
58746: PPUSH
58747: LD_INT 25
58749: PUSH
58750: LD_INT 16
58752: PUSH
58753: EMPTY
58754: LIST
58755: LIST
58756: PPUSH
58757: CALL_OW 72
58761: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
58762: LD_VAR 0 4
58766: PUSH
58767: LD_INT 6
58769: GREATEREQUAL
58770: PUSH
58771: LD_VAR 0 5
58775: PPUSH
58776: LD_INT 2
58778: PPUSH
58779: CALL_OW 325
58783: NOT
58784: OR
58785: IFFALSE 58988
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
58787: LD_ADDR_VAR 0 8
58791: PUSH
58792: LD_EXP 101
58796: PUSH
58797: LD_VAR 0 2
58801: ARRAY
58802: PPUSH
58803: LD_INT 2
58805: PUSH
58806: LD_INT 30
58808: PUSH
58809: LD_INT 4
58811: PUSH
58812: EMPTY
58813: LIST
58814: LIST
58815: PUSH
58816: LD_INT 30
58818: PUSH
58819: LD_INT 5
58821: PUSH
58822: EMPTY
58823: LIST
58824: LIST
58825: PUSH
58826: EMPTY
58827: LIST
58828: LIST
58829: LIST
58830: PPUSH
58831: CALL_OW 72
58835: ST_TO_ADDR
// if barracks then
58836: LD_VAR 0 8
58840: IFFALSE 58988
// begin selected := 0 ;
58842: LD_ADDR_VAR 0 7
58846: PUSH
58847: LD_INT 0
58849: ST_TO_ADDR
// for j in barracks do
58850: LD_ADDR_VAR 0 3
58854: PUSH
58855: LD_VAR 0 8
58859: PUSH
58860: FOR_IN
58861: IFFALSE 58892
// begin if UnitsInside ( j ) < 6 then
58863: LD_VAR 0 3
58867: PPUSH
58868: CALL_OW 313
58872: PUSH
58873: LD_INT 6
58875: LESS
58876: IFFALSE 58890
// begin selected := j ;
58878: LD_ADDR_VAR 0 7
58882: PUSH
58883: LD_VAR 0 3
58887: ST_TO_ADDR
// break ;
58888: GO 58892
// end ; end ;
58890: GO 58860
58892: POP
58893: POP
// if selected then
58894: LD_VAR 0 7
58898: IFFALSE 58988
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
58900: LD_ADDR_VAR 0 3
58904: PUSH
58905: LD_EXP 130
58909: PUSH
58910: LD_VAR 0 2
58914: ARRAY
58915: PPUSH
58916: LD_INT 25
58918: PUSH
58919: LD_INT 12
58921: PUSH
58922: EMPTY
58923: LIST
58924: LIST
58925: PPUSH
58926: CALL_OW 72
58930: PUSH
58931: FOR_IN
58932: IFFALSE 58986
// if not IsInUnit ( j ) and not HasTask ( j ) then
58934: LD_VAR 0 3
58938: PPUSH
58939: CALL_OW 310
58943: NOT
58944: PUSH
58945: LD_VAR 0 3
58949: PPUSH
58950: CALL_OW 314
58954: NOT
58955: AND
58956: IFFALSE 58984
// begin ComEnterUnit ( j , selected ) ;
58958: LD_VAR 0 3
58962: PPUSH
58963: LD_VAR 0 7
58967: PPUSH
58968: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
58972: LD_VAR 0 3
58976: PPUSH
58977: LD_INT 15
58979: PPUSH
58980: CALL_OW 183
// end ;
58984: GO 58931
58986: POP
58987: POP
// end ; end ; end ; end ; end ;
58988: GO 58381
58990: POP
58991: POP
// end ;
58992: LD_VAR 0 1
58996: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
58997: LD_INT 0
58999: PPUSH
59000: PPUSH
59001: PPUSH
59002: PPUSH
// if not mc_bases then
59003: LD_EXP 101
59007: NOT
59008: IFFALSE 59012
// exit ;
59010: GO 59190
// for i = 1 to mc_bases do
59012: LD_ADDR_VAR 0 2
59016: PUSH
59017: DOUBLE
59018: LD_INT 1
59020: DEC
59021: ST_TO_ADDR
59022: LD_EXP 101
59026: PUSH
59027: FOR_TO
59028: IFFALSE 59188
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
59030: LD_ADDR_VAR 0 4
59034: PUSH
59035: LD_EXP 101
59039: PUSH
59040: LD_VAR 0 2
59044: ARRAY
59045: PPUSH
59046: LD_INT 25
59048: PUSH
59049: LD_INT 9
59051: PUSH
59052: EMPTY
59053: LIST
59054: LIST
59055: PPUSH
59056: CALL_OW 72
59060: ST_TO_ADDR
// if not tmp then
59061: LD_VAR 0 4
59065: NOT
59066: IFFALSE 59070
// continue ;
59068: GO 59027
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
59070: LD_EXP 127
59074: PUSH
59075: LD_VAR 0 2
59079: ARRAY
59080: PPUSH
59081: LD_INT 29
59083: PPUSH
59084: CALL_OW 325
59088: NOT
59089: PUSH
59090: LD_EXP 127
59094: PUSH
59095: LD_VAR 0 2
59099: ARRAY
59100: PPUSH
59101: LD_INT 28
59103: PPUSH
59104: CALL_OW 325
59108: NOT
59109: AND
59110: IFFALSE 59114
// continue ;
59112: GO 59027
// for j in tmp do
59114: LD_ADDR_VAR 0 3
59118: PUSH
59119: LD_VAR 0 4
59123: PUSH
59124: FOR_IN
59125: IFFALSE 59184
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
59127: LD_VAR 0 3
59131: PUSH
59132: LD_EXP 104
59136: PUSH
59137: LD_VAR 0 2
59141: ARRAY
59142: PUSH
59143: LD_INT 1
59145: ARRAY
59146: IN
59147: NOT
59148: PUSH
59149: LD_VAR 0 3
59153: PUSH
59154: LD_EXP 104
59158: PUSH
59159: LD_VAR 0 2
59163: ARRAY
59164: PUSH
59165: LD_INT 2
59167: ARRAY
59168: IN
59169: NOT
59170: AND
59171: IFFALSE 59182
// ComSpaceTimeShoot ( j ) ;
59173: LD_VAR 0 3
59177: PPUSH
59178: CALL 70391 0 1
59182: GO 59124
59184: POP
59185: POP
// end ;
59186: GO 59027
59188: POP
59189: POP
// end ;
59190: LD_VAR 0 1
59194: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
59195: LD_INT 0
59197: PPUSH
59198: PPUSH
59199: PPUSH
59200: PPUSH
59201: PPUSH
59202: PPUSH
59203: PPUSH
59204: PPUSH
59205: PPUSH
// if not mc_bases then
59206: LD_EXP 101
59210: NOT
59211: IFFALSE 59215
// exit ;
59213: GO 59837
// for i = 1 to mc_bases do
59215: LD_ADDR_VAR 0 2
59219: PUSH
59220: DOUBLE
59221: LD_INT 1
59223: DEC
59224: ST_TO_ADDR
59225: LD_EXP 101
59229: PUSH
59230: FOR_TO
59231: IFFALSE 59835
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
59233: LD_EXP 136
59237: PUSH
59238: LD_VAR 0 2
59242: ARRAY
59243: NOT
59244: PUSH
59245: LD_INT 38
59247: PPUSH
59248: LD_EXP 127
59252: PUSH
59253: LD_VAR 0 2
59257: ARRAY
59258: PPUSH
59259: CALL_OW 321
59263: PUSH
59264: LD_INT 2
59266: NONEQUAL
59267: OR
59268: IFFALSE 59272
// continue ;
59270: GO 59230
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
59272: LD_ADDR_VAR 0 8
59276: PUSH
59277: LD_EXP 101
59281: PUSH
59282: LD_VAR 0 2
59286: ARRAY
59287: PPUSH
59288: LD_INT 30
59290: PUSH
59291: LD_INT 34
59293: PUSH
59294: EMPTY
59295: LIST
59296: LIST
59297: PPUSH
59298: CALL_OW 72
59302: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
59303: LD_ADDR_VAR 0 9
59307: PUSH
59308: LD_EXP 101
59312: PUSH
59313: LD_VAR 0 2
59317: ARRAY
59318: PPUSH
59319: LD_INT 25
59321: PUSH
59322: LD_INT 4
59324: PUSH
59325: EMPTY
59326: LIST
59327: LIST
59328: PPUSH
59329: CALL_OW 72
59333: PPUSH
59334: LD_INT 0
59336: PPUSH
59337: CALL 104704 0 2
59341: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
59342: LD_VAR 0 9
59346: NOT
59347: PUSH
59348: LD_VAR 0 8
59352: NOT
59353: OR
59354: PUSH
59355: LD_EXP 101
59359: PUSH
59360: LD_VAR 0 2
59364: ARRAY
59365: PPUSH
59366: LD_INT 124
59368: PPUSH
59369: CALL 104704 0 2
59373: OR
59374: IFFALSE 59378
// continue ;
59376: GO 59230
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
59378: LD_EXP 137
59382: PUSH
59383: LD_VAR 0 2
59387: ARRAY
59388: PUSH
59389: LD_EXP 136
59393: PUSH
59394: LD_VAR 0 2
59398: ARRAY
59399: LESS
59400: PUSH
59401: LD_EXP 137
59405: PUSH
59406: LD_VAR 0 2
59410: ARRAY
59411: PUSH
59412: LD_VAR 0 8
59416: LESS
59417: AND
59418: IFFALSE 59833
// begin tmp := sci [ 1 ] ;
59420: LD_ADDR_VAR 0 7
59424: PUSH
59425: LD_VAR 0 9
59429: PUSH
59430: LD_INT 1
59432: ARRAY
59433: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
59434: LD_VAR 0 7
59438: PPUSH
59439: LD_INT 124
59441: PPUSH
59442: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
59446: LD_ADDR_VAR 0 3
59450: PUSH
59451: DOUBLE
59452: LD_EXP 136
59456: PUSH
59457: LD_VAR 0 2
59461: ARRAY
59462: INC
59463: ST_TO_ADDR
59464: LD_EXP 136
59468: PUSH
59469: LD_VAR 0 2
59473: ARRAY
59474: PUSH
59475: FOR_DOWNTO
59476: IFFALSE 59819
// begin if IsInUnit ( tmp ) then
59478: LD_VAR 0 7
59482: PPUSH
59483: CALL_OW 310
59487: IFFALSE 59498
// ComExitBuilding ( tmp ) ;
59489: LD_VAR 0 7
59493: PPUSH
59494: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
59498: LD_INT 35
59500: PPUSH
59501: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
59505: LD_VAR 0 7
59509: PPUSH
59510: CALL_OW 310
59514: NOT
59515: PUSH
59516: LD_VAR 0 7
59520: PPUSH
59521: CALL_OW 314
59525: NOT
59526: AND
59527: IFFALSE 59498
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
59529: LD_ADDR_VAR 0 6
59533: PUSH
59534: LD_VAR 0 7
59538: PPUSH
59539: CALL_OW 250
59543: PUSH
59544: LD_VAR 0 7
59548: PPUSH
59549: CALL_OW 251
59553: PUSH
59554: EMPTY
59555: LIST
59556: LIST
59557: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
59558: LD_INT 35
59560: PPUSH
59561: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
59565: LD_ADDR_VAR 0 4
59569: PUSH
59570: LD_EXP 136
59574: PUSH
59575: LD_VAR 0 2
59579: ARRAY
59580: PUSH
59581: LD_VAR 0 3
59585: ARRAY
59586: PUSH
59587: LD_INT 1
59589: ARRAY
59590: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
59591: LD_ADDR_VAR 0 5
59595: PUSH
59596: LD_EXP 136
59600: PUSH
59601: LD_VAR 0 2
59605: ARRAY
59606: PUSH
59607: LD_VAR 0 3
59611: ARRAY
59612: PUSH
59613: LD_INT 2
59615: ARRAY
59616: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
59617: LD_VAR 0 7
59621: PPUSH
59622: LD_INT 10
59624: PPUSH
59625: CALL 77371 0 2
59629: PUSH
59630: LD_INT 4
59632: ARRAY
59633: IFFALSE 59671
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
59635: LD_VAR 0 7
59639: PPUSH
59640: LD_VAR 0 6
59644: PUSH
59645: LD_INT 1
59647: ARRAY
59648: PPUSH
59649: LD_VAR 0 6
59653: PUSH
59654: LD_INT 2
59656: ARRAY
59657: PPUSH
59658: CALL_OW 111
// wait ( 0 0$10 ) ;
59662: LD_INT 350
59664: PPUSH
59665: CALL_OW 67
// end else
59669: GO 59697
// begin ComMoveXY ( tmp , x , y ) ;
59671: LD_VAR 0 7
59675: PPUSH
59676: LD_VAR 0 4
59680: PPUSH
59681: LD_VAR 0 5
59685: PPUSH
59686: CALL_OW 111
// wait ( 0 0$3 ) ;
59690: LD_INT 105
59692: PPUSH
59693: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
59697: LD_VAR 0 7
59701: PPUSH
59702: LD_VAR 0 4
59706: PPUSH
59707: LD_VAR 0 5
59711: PPUSH
59712: CALL_OW 307
59716: IFFALSE 59558
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
59718: LD_VAR 0 7
59722: PPUSH
59723: LD_VAR 0 4
59727: PPUSH
59728: LD_VAR 0 5
59732: PPUSH
59733: LD_VAR 0 8
59737: PUSH
59738: LD_VAR 0 3
59742: ARRAY
59743: PPUSH
59744: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
59748: LD_INT 35
59750: PPUSH
59751: CALL_OW 67
// until not HasTask ( tmp ) ;
59755: LD_VAR 0 7
59759: PPUSH
59760: CALL_OW 314
59764: NOT
59765: IFFALSE 59748
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
59767: LD_ADDR_EXP 137
59771: PUSH
59772: LD_EXP 137
59776: PPUSH
59777: LD_VAR 0 2
59781: PUSH
59782: LD_EXP 137
59786: PUSH
59787: LD_VAR 0 2
59791: ARRAY
59792: PUSH
59793: LD_INT 1
59795: PLUS
59796: PUSH
59797: EMPTY
59798: LIST
59799: LIST
59800: PPUSH
59801: LD_VAR 0 8
59805: PUSH
59806: LD_VAR 0 3
59810: ARRAY
59811: PPUSH
59812: CALL 74406 0 3
59816: ST_TO_ADDR
// end ;
59817: GO 59475
59819: POP
59820: POP
// MC_Reset ( i , 124 ) ;
59821: LD_VAR 0 2
59825: PPUSH
59826: LD_INT 124
59828: PPUSH
59829: CALL 42905 0 2
// end ; end ;
59833: GO 59230
59835: POP
59836: POP
// end ;
59837: LD_VAR 0 1
59841: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
59842: LD_INT 0
59844: PPUSH
59845: PPUSH
59846: PPUSH
// if not mc_bases then
59847: LD_EXP 101
59851: NOT
59852: IFFALSE 59856
// exit ;
59854: GO 60462
// for i = 1 to mc_bases do
59856: LD_ADDR_VAR 0 2
59860: PUSH
59861: DOUBLE
59862: LD_INT 1
59864: DEC
59865: ST_TO_ADDR
59866: LD_EXP 101
59870: PUSH
59871: FOR_TO
59872: IFFALSE 60460
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
59874: LD_ADDR_VAR 0 3
59878: PUSH
59879: LD_EXP 101
59883: PUSH
59884: LD_VAR 0 2
59888: ARRAY
59889: PPUSH
59890: LD_INT 25
59892: PUSH
59893: LD_INT 4
59895: PUSH
59896: EMPTY
59897: LIST
59898: LIST
59899: PPUSH
59900: CALL_OW 72
59904: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59905: LD_VAR 0 3
59909: NOT
59910: PUSH
59911: LD_EXP 138
59915: PUSH
59916: LD_VAR 0 2
59920: ARRAY
59921: NOT
59922: OR
59923: PUSH
59924: LD_EXP 101
59928: PUSH
59929: LD_VAR 0 2
59933: ARRAY
59934: PPUSH
59935: LD_INT 2
59937: PUSH
59938: LD_INT 30
59940: PUSH
59941: LD_INT 0
59943: PUSH
59944: EMPTY
59945: LIST
59946: LIST
59947: PUSH
59948: LD_INT 30
59950: PUSH
59951: LD_INT 1
59953: PUSH
59954: EMPTY
59955: LIST
59956: LIST
59957: PUSH
59958: EMPTY
59959: LIST
59960: LIST
59961: LIST
59962: PPUSH
59963: CALL_OW 72
59967: NOT
59968: OR
59969: IFFALSE 60019
// begin if mc_deposits_finder [ i ] then
59971: LD_EXP 139
59975: PUSH
59976: LD_VAR 0 2
59980: ARRAY
59981: IFFALSE 60017
// begin MC_Reset ( i , 125 ) ;
59983: LD_VAR 0 2
59987: PPUSH
59988: LD_INT 125
59990: PPUSH
59991: CALL 42905 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
59995: LD_ADDR_EXP 139
59999: PUSH
60000: LD_EXP 139
60004: PPUSH
60005: LD_VAR 0 2
60009: PPUSH
60010: EMPTY
60011: PPUSH
60012: CALL_OW 1
60016: ST_TO_ADDR
// end ; continue ;
60017: GO 59871
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
60019: LD_EXP 138
60023: PUSH
60024: LD_VAR 0 2
60028: ARRAY
60029: PUSH
60030: LD_INT 1
60032: ARRAY
60033: PUSH
60034: LD_INT 3
60036: ARRAY
60037: PUSH
60038: LD_INT 1
60040: EQUAL
60041: PUSH
60042: LD_INT 20
60044: PPUSH
60045: LD_EXP 127
60049: PUSH
60050: LD_VAR 0 2
60054: ARRAY
60055: PPUSH
60056: CALL_OW 321
60060: PUSH
60061: LD_INT 2
60063: NONEQUAL
60064: AND
60065: IFFALSE 60115
// begin if mc_deposits_finder [ i ] then
60067: LD_EXP 139
60071: PUSH
60072: LD_VAR 0 2
60076: ARRAY
60077: IFFALSE 60113
// begin MC_Reset ( i , 125 ) ;
60079: LD_VAR 0 2
60083: PPUSH
60084: LD_INT 125
60086: PPUSH
60087: CALL 42905 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60091: LD_ADDR_EXP 139
60095: PUSH
60096: LD_EXP 139
60100: PPUSH
60101: LD_VAR 0 2
60105: PPUSH
60106: EMPTY
60107: PPUSH
60108: CALL_OW 1
60112: ST_TO_ADDR
// end ; continue ;
60113: GO 59871
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
60115: LD_EXP 138
60119: PUSH
60120: LD_VAR 0 2
60124: ARRAY
60125: PUSH
60126: LD_INT 1
60128: ARRAY
60129: PUSH
60130: LD_INT 1
60132: ARRAY
60133: PPUSH
60134: LD_EXP 138
60138: PUSH
60139: LD_VAR 0 2
60143: ARRAY
60144: PUSH
60145: LD_INT 1
60147: ARRAY
60148: PUSH
60149: LD_INT 2
60151: ARRAY
60152: PPUSH
60153: LD_EXP 127
60157: PUSH
60158: LD_VAR 0 2
60162: ARRAY
60163: PPUSH
60164: CALL_OW 440
60168: IFFALSE 60211
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
60170: LD_ADDR_EXP 138
60174: PUSH
60175: LD_EXP 138
60179: PPUSH
60180: LD_VAR 0 2
60184: PPUSH
60185: LD_EXP 138
60189: PUSH
60190: LD_VAR 0 2
60194: ARRAY
60195: PPUSH
60196: LD_INT 1
60198: PPUSH
60199: CALL_OW 3
60203: PPUSH
60204: CALL_OW 1
60208: ST_TO_ADDR
60209: GO 60458
// begin if not mc_deposits_finder [ i ] then
60211: LD_EXP 139
60215: PUSH
60216: LD_VAR 0 2
60220: ARRAY
60221: NOT
60222: IFFALSE 60274
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
60224: LD_ADDR_EXP 139
60228: PUSH
60229: LD_EXP 139
60233: PPUSH
60234: LD_VAR 0 2
60238: PPUSH
60239: LD_VAR 0 3
60243: PUSH
60244: LD_INT 1
60246: ARRAY
60247: PUSH
60248: EMPTY
60249: LIST
60250: PPUSH
60251: CALL_OW 1
60255: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
60256: LD_VAR 0 3
60260: PUSH
60261: LD_INT 1
60263: ARRAY
60264: PPUSH
60265: LD_INT 125
60267: PPUSH
60268: CALL_OW 109
// end else
60272: GO 60458
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
60274: LD_EXP 139
60278: PUSH
60279: LD_VAR 0 2
60283: ARRAY
60284: PUSH
60285: LD_INT 1
60287: ARRAY
60288: PPUSH
60289: CALL_OW 310
60293: IFFALSE 60316
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
60295: LD_EXP 139
60299: PUSH
60300: LD_VAR 0 2
60304: ARRAY
60305: PUSH
60306: LD_INT 1
60308: ARRAY
60309: PPUSH
60310: CALL_OW 122
60314: GO 60458
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
60316: LD_EXP 139
60320: PUSH
60321: LD_VAR 0 2
60325: ARRAY
60326: PUSH
60327: LD_INT 1
60329: ARRAY
60330: PPUSH
60331: CALL_OW 314
60335: NOT
60336: PUSH
60337: LD_EXP 139
60341: PUSH
60342: LD_VAR 0 2
60346: ARRAY
60347: PUSH
60348: LD_INT 1
60350: ARRAY
60351: PPUSH
60352: LD_EXP 138
60356: PUSH
60357: LD_VAR 0 2
60361: ARRAY
60362: PUSH
60363: LD_INT 1
60365: ARRAY
60366: PUSH
60367: LD_INT 1
60369: ARRAY
60370: PPUSH
60371: LD_EXP 138
60375: PUSH
60376: LD_VAR 0 2
60380: ARRAY
60381: PUSH
60382: LD_INT 1
60384: ARRAY
60385: PUSH
60386: LD_INT 2
60388: ARRAY
60389: PPUSH
60390: CALL_OW 297
60394: PUSH
60395: LD_INT 6
60397: GREATER
60398: AND
60399: IFFALSE 60458
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
60401: LD_EXP 139
60405: PUSH
60406: LD_VAR 0 2
60410: ARRAY
60411: PUSH
60412: LD_INT 1
60414: ARRAY
60415: PPUSH
60416: LD_EXP 138
60420: PUSH
60421: LD_VAR 0 2
60425: ARRAY
60426: PUSH
60427: LD_INT 1
60429: ARRAY
60430: PUSH
60431: LD_INT 1
60433: ARRAY
60434: PPUSH
60435: LD_EXP 138
60439: PUSH
60440: LD_VAR 0 2
60444: ARRAY
60445: PUSH
60446: LD_INT 1
60448: ARRAY
60449: PUSH
60450: LD_INT 2
60452: ARRAY
60453: PPUSH
60454: CALL_OW 111
// end ; end ; end ;
60458: GO 59871
60460: POP
60461: POP
// end ;
60462: LD_VAR 0 1
60466: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
60467: LD_INT 0
60469: PPUSH
60470: PPUSH
60471: PPUSH
60472: PPUSH
60473: PPUSH
60474: PPUSH
60475: PPUSH
60476: PPUSH
60477: PPUSH
60478: PPUSH
60479: PPUSH
// if not mc_bases then
60480: LD_EXP 101
60484: NOT
60485: IFFALSE 60489
// exit ;
60487: GO 61429
// for i = 1 to mc_bases do
60489: LD_ADDR_VAR 0 2
60493: PUSH
60494: DOUBLE
60495: LD_INT 1
60497: DEC
60498: ST_TO_ADDR
60499: LD_EXP 101
60503: PUSH
60504: FOR_TO
60505: IFFALSE 61427
// begin if not mc_bases [ i ] or mc_scan [ i ] then
60507: LD_EXP 101
60511: PUSH
60512: LD_VAR 0 2
60516: ARRAY
60517: NOT
60518: PUSH
60519: LD_EXP 124
60523: PUSH
60524: LD_VAR 0 2
60528: ARRAY
60529: OR
60530: IFFALSE 60534
// continue ;
60532: GO 60504
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
60534: LD_ADDR_VAR 0 7
60538: PUSH
60539: LD_EXP 101
60543: PUSH
60544: LD_VAR 0 2
60548: ARRAY
60549: PUSH
60550: LD_INT 1
60552: ARRAY
60553: PPUSH
60554: CALL_OW 248
60558: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
60559: LD_VAR 0 7
60563: PUSH
60564: LD_INT 3
60566: EQUAL
60567: PUSH
60568: LD_EXP 120
60572: PUSH
60573: LD_VAR 0 2
60577: ARRAY
60578: PUSH
60579: LD_EXP 123
60583: PUSH
60584: LD_VAR 0 2
60588: ARRAY
60589: UNION
60590: PPUSH
60591: LD_INT 33
60593: PUSH
60594: LD_INT 2
60596: PUSH
60597: EMPTY
60598: LIST
60599: LIST
60600: PPUSH
60601: CALL_OW 72
60605: NOT
60606: OR
60607: IFFALSE 60611
// continue ;
60609: GO 60504
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
60611: LD_ADDR_VAR 0 9
60615: PUSH
60616: LD_EXP 101
60620: PUSH
60621: LD_VAR 0 2
60625: ARRAY
60626: PPUSH
60627: LD_INT 30
60629: PUSH
60630: LD_INT 36
60632: PUSH
60633: EMPTY
60634: LIST
60635: LIST
60636: PPUSH
60637: CALL_OW 72
60641: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
60642: LD_ADDR_VAR 0 10
60646: PUSH
60647: LD_EXP 120
60651: PUSH
60652: LD_VAR 0 2
60656: ARRAY
60657: PPUSH
60658: LD_INT 34
60660: PUSH
60661: LD_INT 31
60663: PUSH
60664: EMPTY
60665: LIST
60666: LIST
60667: PPUSH
60668: CALL_OW 72
60672: ST_TO_ADDR
// if not cts and not mcts then
60673: LD_VAR 0 9
60677: NOT
60678: PUSH
60679: LD_VAR 0 10
60683: NOT
60684: AND
60685: IFFALSE 60689
// continue ;
60687: GO 60504
// x := cts ;
60689: LD_ADDR_VAR 0 11
60693: PUSH
60694: LD_VAR 0 9
60698: ST_TO_ADDR
// if not x then
60699: LD_VAR 0 11
60703: NOT
60704: IFFALSE 60716
// x := mcts ;
60706: LD_ADDR_VAR 0 11
60710: PUSH
60711: LD_VAR 0 10
60715: ST_TO_ADDR
// if not x then
60716: LD_VAR 0 11
60720: NOT
60721: IFFALSE 60725
// continue ;
60723: GO 60504
// if mc_remote_driver [ i ] then
60725: LD_EXP 141
60729: PUSH
60730: LD_VAR 0 2
60734: ARRAY
60735: IFFALSE 61122
// for j in mc_remote_driver [ i ] do
60737: LD_ADDR_VAR 0 3
60741: PUSH
60742: LD_EXP 141
60746: PUSH
60747: LD_VAR 0 2
60751: ARRAY
60752: PUSH
60753: FOR_IN
60754: IFFALSE 61120
// begin if GetClass ( j ) <> 3 then
60756: LD_VAR 0 3
60760: PPUSH
60761: CALL_OW 257
60765: PUSH
60766: LD_INT 3
60768: NONEQUAL
60769: IFFALSE 60822
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
60771: LD_ADDR_EXP 141
60775: PUSH
60776: LD_EXP 141
60780: PPUSH
60781: LD_VAR 0 2
60785: PPUSH
60786: LD_EXP 141
60790: PUSH
60791: LD_VAR 0 2
60795: ARRAY
60796: PUSH
60797: LD_VAR 0 3
60801: DIFF
60802: PPUSH
60803: CALL_OW 1
60807: ST_TO_ADDR
// SetTag ( j , 0 ) ;
60808: LD_VAR 0 3
60812: PPUSH
60813: LD_INT 0
60815: PPUSH
60816: CALL_OW 109
// continue ;
60820: GO 60753
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
60822: LD_EXP 120
60826: PUSH
60827: LD_VAR 0 2
60831: ARRAY
60832: PPUSH
60833: LD_INT 34
60835: PUSH
60836: LD_INT 31
60838: PUSH
60839: EMPTY
60840: LIST
60841: LIST
60842: PUSH
60843: LD_INT 58
60845: PUSH
60846: EMPTY
60847: LIST
60848: PUSH
60849: EMPTY
60850: LIST
60851: LIST
60852: PPUSH
60853: CALL_OW 72
60857: PUSH
60858: LD_VAR 0 3
60862: PPUSH
60863: CALL 104739 0 1
60867: NOT
60868: AND
60869: IFFALSE 60940
// begin if IsInUnit ( j ) then
60871: LD_VAR 0 3
60875: PPUSH
60876: CALL_OW 310
60880: IFFALSE 60891
// ComExitBuilding ( j ) ;
60882: LD_VAR 0 3
60886: PPUSH
60887: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
60891: LD_VAR 0 3
60895: PPUSH
60896: LD_EXP 120
60900: PUSH
60901: LD_VAR 0 2
60905: ARRAY
60906: PPUSH
60907: LD_INT 34
60909: PUSH
60910: LD_INT 31
60912: PUSH
60913: EMPTY
60914: LIST
60915: LIST
60916: PUSH
60917: LD_INT 58
60919: PUSH
60920: EMPTY
60921: LIST
60922: PUSH
60923: EMPTY
60924: LIST
60925: LIST
60926: PPUSH
60927: CALL_OW 72
60931: PUSH
60932: LD_INT 1
60934: ARRAY
60935: PPUSH
60936: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
60940: LD_VAR 0 3
60944: PPUSH
60945: CALL_OW 310
60949: NOT
60950: PUSH
60951: LD_VAR 0 3
60955: PPUSH
60956: CALL_OW 310
60960: PPUSH
60961: CALL_OW 266
60965: PUSH
60966: LD_INT 36
60968: NONEQUAL
60969: PUSH
60970: LD_VAR 0 3
60974: PPUSH
60975: CALL 104739 0 1
60979: NOT
60980: AND
60981: OR
60982: IFFALSE 61118
// begin if IsInUnit ( j ) then
60984: LD_VAR 0 3
60988: PPUSH
60989: CALL_OW 310
60993: IFFALSE 61004
// ComExitBuilding ( j ) ;
60995: LD_VAR 0 3
60999: PPUSH
61000: CALL_OW 122
// ct := 0 ;
61004: LD_ADDR_VAR 0 8
61008: PUSH
61009: LD_INT 0
61011: ST_TO_ADDR
// for k in x do
61012: LD_ADDR_VAR 0 4
61016: PUSH
61017: LD_VAR 0 11
61021: PUSH
61022: FOR_IN
61023: IFFALSE 61096
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
61025: LD_VAR 0 4
61029: PPUSH
61030: CALL_OW 264
61034: PUSH
61035: LD_INT 31
61037: EQUAL
61038: PUSH
61039: LD_VAR 0 4
61043: PPUSH
61044: CALL_OW 311
61048: NOT
61049: AND
61050: PUSH
61051: LD_VAR 0 4
61055: PPUSH
61056: CALL_OW 266
61060: PUSH
61061: LD_INT 36
61063: EQUAL
61064: PUSH
61065: LD_VAR 0 4
61069: PPUSH
61070: CALL_OW 313
61074: PUSH
61075: LD_INT 3
61077: LESS
61078: AND
61079: OR
61080: IFFALSE 61094
// begin ct := k ;
61082: LD_ADDR_VAR 0 8
61086: PUSH
61087: LD_VAR 0 4
61091: ST_TO_ADDR
// break ;
61092: GO 61096
// end ;
61094: GO 61022
61096: POP
61097: POP
// if ct then
61098: LD_VAR 0 8
61102: IFFALSE 61118
// ComEnterUnit ( j , ct ) ;
61104: LD_VAR 0 3
61108: PPUSH
61109: LD_VAR 0 8
61113: PPUSH
61114: CALL_OW 120
// end ; end ;
61118: GO 60753
61120: POP
61121: POP
// places := 0 ;
61122: LD_ADDR_VAR 0 5
61126: PUSH
61127: LD_INT 0
61129: ST_TO_ADDR
// for j = 1 to x do
61130: LD_ADDR_VAR 0 3
61134: PUSH
61135: DOUBLE
61136: LD_INT 1
61138: DEC
61139: ST_TO_ADDR
61140: LD_VAR 0 11
61144: PUSH
61145: FOR_TO
61146: IFFALSE 61222
// if GetWeapon ( x [ j ] ) = ar_control_tower then
61148: LD_VAR 0 11
61152: PUSH
61153: LD_VAR 0 3
61157: ARRAY
61158: PPUSH
61159: CALL_OW 264
61163: PUSH
61164: LD_INT 31
61166: EQUAL
61167: IFFALSE 61185
// places := places + 1 else
61169: LD_ADDR_VAR 0 5
61173: PUSH
61174: LD_VAR 0 5
61178: PUSH
61179: LD_INT 1
61181: PLUS
61182: ST_TO_ADDR
61183: GO 61220
// if GetBType ( x [ j ] ) = b_control_tower then
61185: LD_VAR 0 11
61189: PUSH
61190: LD_VAR 0 3
61194: ARRAY
61195: PPUSH
61196: CALL_OW 266
61200: PUSH
61201: LD_INT 36
61203: EQUAL
61204: IFFALSE 61220
// places := places + 3 ;
61206: LD_ADDR_VAR 0 5
61210: PUSH
61211: LD_VAR 0 5
61215: PUSH
61216: LD_INT 3
61218: PLUS
61219: ST_TO_ADDR
61220: GO 61145
61222: POP
61223: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
61224: LD_VAR 0 5
61228: PUSH
61229: LD_INT 0
61231: EQUAL
61232: PUSH
61233: LD_VAR 0 5
61237: PUSH
61238: LD_EXP 141
61242: PUSH
61243: LD_VAR 0 2
61247: ARRAY
61248: LESSEQUAL
61249: OR
61250: IFFALSE 61254
// continue ;
61252: GO 60504
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
61254: LD_ADDR_VAR 0 6
61258: PUSH
61259: LD_EXP 101
61263: PUSH
61264: LD_VAR 0 2
61268: ARRAY
61269: PPUSH
61270: LD_INT 25
61272: PUSH
61273: LD_INT 3
61275: PUSH
61276: EMPTY
61277: LIST
61278: LIST
61279: PPUSH
61280: CALL_OW 72
61284: PUSH
61285: LD_EXP 141
61289: PUSH
61290: LD_VAR 0 2
61294: ARRAY
61295: DIFF
61296: PPUSH
61297: LD_INT 3
61299: PPUSH
61300: CALL 105639 0 2
61304: ST_TO_ADDR
// for j in tmp do
61305: LD_ADDR_VAR 0 3
61309: PUSH
61310: LD_VAR 0 6
61314: PUSH
61315: FOR_IN
61316: IFFALSE 61351
// if GetTag ( j ) > 0 then
61318: LD_VAR 0 3
61322: PPUSH
61323: CALL_OW 110
61327: PUSH
61328: LD_INT 0
61330: GREATER
61331: IFFALSE 61349
// tmp := tmp diff j ;
61333: LD_ADDR_VAR 0 6
61337: PUSH
61338: LD_VAR 0 6
61342: PUSH
61343: LD_VAR 0 3
61347: DIFF
61348: ST_TO_ADDR
61349: GO 61315
61351: POP
61352: POP
// if not tmp then
61353: LD_VAR 0 6
61357: NOT
61358: IFFALSE 61362
// continue ;
61360: GO 60504
// if places then
61362: LD_VAR 0 5
61366: IFFALSE 61425
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
61368: LD_ADDR_EXP 141
61372: PUSH
61373: LD_EXP 141
61377: PPUSH
61378: LD_VAR 0 2
61382: PPUSH
61383: LD_EXP 141
61387: PUSH
61388: LD_VAR 0 2
61392: ARRAY
61393: PUSH
61394: LD_VAR 0 6
61398: PUSH
61399: LD_INT 1
61401: ARRAY
61402: UNION
61403: PPUSH
61404: CALL_OW 1
61408: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
61409: LD_VAR 0 6
61413: PUSH
61414: LD_INT 1
61416: ARRAY
61417: PPUSH
61418: LD_INT 126
61420: PPUSH
61421: CALL_OW 109
// end ; end ;
61425: GO 60504
61427: POP
61428: POP
// end ;
61429: LD_VAR 0 1
61433: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
61434: LD_INT 0
61436: PPUSH
61437: PPUSH
61438: PPUSH
61439: PPUSH
61440: PPUSH
61441: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
61442: LD_VAR 0 1
61446: NOT
61447: PUSH
61448: LD_VAR 0 2
61452: NOT
61453: OR
61454: PUSH
61455: LD_VAR 0 3
61459: NOT
61460: OR
61461: PUSH
61462: LD_VAR 0 4
61466: PUSH
61467: LD_INT 1
61469: PUSH
61470: LD_INT 2
61472: PUSH
61473: LD_INT 3
61475: PUSH
61476: LD_INT 4
61478: PUSH
61479: LD_INT 5
61481: PUSH
61482: LD_INT 8
61484: PUSH
61485: LD_INT 9
61487: PUSH
61488: LD_INT 15
61490: PUSH
61491: LD_INT 16
61493: PUSH
61494: EMPTY
61495: LIST
61496: LIST
61497: LIST
61498: LIST
61499: LIST
61500: LIST
61501: LIST
61502: LIST
61503: LIST
61504: IN
61505: NOT
61506: OR
61507: IFFALSE 61511
// exit ;
61509: GO 62369
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
61511: LD_ADDR_VAR 0 2
61515: PUSH
61516: LD_VAR 0 2
61520: PPUSH
61521: LD_INT 21
61523: PUSH
61524: LD_INT 3
61526: PUSH
61527: EMPTY
61528: LIST
61529: LIST
61530: PUSH
61531: LD_INT 24
61533: PUSH
61534: LD_INT 250
61536: PUSH
61537: EMPTY
61538: LIST
61539: LIST
61540: PUSH
61541: EMPTY
61542: LIST
61543: LIST
61544: PPUSH
61545: CALL_OW 72
61549: ST_TO_ADDR
// case class of 1 , 15 :
61550: LD_VAR 0 4
61554: PUSH
61555: LD_INT 1
61557: DOUBLE
61558: EQUAL
61559: IFTRUE 61569
61561: LD_INT 15
61563: DOUBLE
61564: EQUAL
61565: IFTRUE 61569
61567: GO 61654
61569: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
61570: LD_ADDR_VAR 0 8
61574: PUSH
61575: LD_VAR 0 2
61579: PPUSH
61580: LD_INT 2
61582: PUSH
61583: LD_INT 30
61585: PUSH
61586: LD_INT 32
61588: PUSH
61589: EMPTY
61590: LIST
61591: LIST
61592: PUSH
61593: LD_INT 30
61595: PUSH
61596: LD_INT 31
61598: PUSH
61599: EMPTY
61600: LIST
61601: LIST
61602: PUSH
61603: EMPTY
61604: LIST
61605: LIST
61606: LIST
61607: PPUSH
61608: CALL_OW 72
61612: PUSH
61613: LD_VAR 0 2
61617: PPUSH
61618: LD_INT 2
61620: PUSH
61621: LD_INT 30
61623: PUSH
61624: LD_INT 4
61626: PUSH
61627: EMPTY
61628: LIST
61629: LIST
61630: PUSH
61631: LD_INT 30
61633: PUSH
61634: LD_INT 5
61636: PUSH
61637: EMPTY
61638: LIST
61639: LIST
61640: PUSH
61641: EMPTY
61642: LIST
61643: LIST
61644: LIST
61645: PPUSH
61646: CALL_OW 72
61650: ADD
61651: ST_TO_ADDR
61652: GO 61900
61654: LD_INT 2
61656: DOUBLE
61657: EQUAL
61658: IFTRUE 61668
61660: LD_INT 16
61662: DOUBLE
61663: EQUAL
61664: IFTRUE 61668
61666: GO 61714
61668: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
61669: LD_ADDR_VAR 0 8
61673: PUSH
61674: LD_VAR 0 2
61678: PPUSH
61679: LD_INT 2
61681: PUSH
61682: LD_INT 30
61684: PUSH
61685: LD_INT 0
61687: PUSH
61688: EMPTY
61689: LIST
61690: LIST
61691: PUSH
61692: LD_INT 30
61694: PUSH
61695: LD_INT 1
61697: PUSH
61698: EMPTY
61699: LIST
61700: LIST
61701: PUSH
61702: EMPTY
61703: LIST
61704: LIST
61705: LIST
61706: PPUSH
61707: CALL_OW 72
61711: ST_TO_ADDR
61712: GO 61900
61714: LD_INT 3
61716: DOUBLE
61717: EQUAL
61718: IFTRUE 61722
61720: GO 61768
61722: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
61723: LD_ADDR_VAR 0 8
61727: PUSH
61728: LD_VAR 0 2
61732: PPUSH
61733: LD_INT 2
61735: PUSH
61736: LD_INT 30
61738: PUSH
61739: LD_INT 2
61741: PUSH
61742: EMPTY
61743: LIST
61744: LIST
61745: PUSH
61746: LD_INT 30
61748: PUSH
61749: LD_INT 3
61751: PUSH
61752: EMPTY
61753: LIST
61754: LIST
61755: PUSH
61756: EMPTY
61757: LIST
61758: LIST
61759: LIST
61760: PPUSH
61761: CALL_OW 72
61765: ST_TO_ADDR
61766: GO 61900
61768: LD_INT 4
61770: DOUBLE
61771: EQUAL
61772: IFTRUE 61776
61774: GO 61833
61776: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
61777: LD_ADDR_VAR 0 8
61781: PUSH
61782: LD_VAR 0 2
61786: PPUSH
61787: LD_INT 2
61789: PUSH
61790: LD_INT 30
61792: PUSH
61793: LD_INT 6
61795: PUSH
61796: EMPTY
61797: LIST
61798: LIST
61799: PUSH
61800: LD_INT 30
61802: PUSH
61803: LD_INT 7
61805: PUSH
61806: EMPTY
61807: LIST
61808: LIST
61809: PUSH
61810: LD_INT 30
61812: PUSH
61813: LD_INT 8
61815: PUSH
61816: EMPTY
61817: LIST
61818: LIST
61819: PUSH
61820: EMPTY
61821: LIST
61822: LIST
61823: LIST
61824: LIST
61825: PPUSH
61826: CALL_OW 72
61830: ST_TO_ADDR
61831: GO 61900
61833: LD_INT 5
61835: DOUBLE
61836: EQUAL
61837: IFTRUE 61853
61839: LD_INT 8
61841: DOUBLE
61842: EQUAL
61843: IFTRUE 61853
61845: LD_INT 9
61847: DOUBLE
61848: EQUAL
61849: IFTRUE 61853
61851: GO 61899
61853: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
61854: LD_ADDR_VAR 0 8
61858: PUSH
61859: LD_VAR 0 2
61863: PPUSH
61864: LD_INT 2
61866: PUSH
61867: LD_INT 30
61869: PUSH
61870: LD_INT 4
61872: PUSH
61873: EMPTY
61874: LIST
61875: LIST
61876: PUSH
61877: LD_INT 30
61879: PUSH
61880: LD_INT 5
61882: PUSH
61883: EMPTY
61884: LIST
61885: LIST
61886: PUSH
61887: EMPTY
61888: LIST
61889: LIST
61890: LIST
61891: PPUSH
61892: CALL_OW 72
61896: ST_TO_ADDR
61897: GO 61900
61899: POP
// if not tmp then
61900: LD_VAR 0 8
61904: NOT
61905: IFFALSE 61909
// exit ;
61907: GO 62369
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
61909: LD_VAR 0 4
61913: PUSH
61914: LD_INT 1
61916: PUSH
61917: LD_INT 15
61919: PUSH
61920: EMPTY
61921: LIST
61922: LIST
61923: IN
61924: PUSH
61925: LD_EXP 110
61929: PUSH
61930: LD_VAR 0 1
61934: ARRAY
61935: AND
61936: IFFALSE 62092
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
61938: LD_ADDR_VAR 0 9
61942: PUSH
61943: LD_EXP 110
61947: PUSH
61948: LD_VAR 0 1
61952: ARRAY
61953: PUSH
61954: LD_INT 1
61956: ARRAY
61957: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
61958: LD_VAR 0 9
61962: PUSH
61963: LD_EXP 111
61967: PUSH
61968: LD_VAR 0 1
61972: ARRAY
61973: IN
61974: NOT
61975: IFFALSE 62090
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
61977: LD_ADDR_EXP 111
61981: PUSH
61982: LD_EXP 111
61986: PPUSH
61987: LD_VAR 0 1
61991: PUSH
61992: LD_EXP 111
61996: PUSH
61997: LD_VAR 0 1
62001: ARRAY
62002: PUSH
62003: LD_INT 1
62005: PLUS
62006: PUSH
62007: EMPTY
62008: LIST
62009: LIST
62010: PPUSH
62011: LD_VAR 0 9
62015: PPUSH
62016: CALL 74406 0 3
62020: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
62021: LD_ADDR_EXP 110
62025: PUSH
62026: LD_EXP 110
62030: PPUSH
62031: LD_VAR 0 1
62035: PPUSH
62036: LD_EXP 110
62040: PUSH
62041: LD_VAR 0 1
62045: ARRAY
62046: PUSH
62047: LD_VAR 0 9
62051: DIFF
62052: PPUSH
62053: CALL_OW 1
62057: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
62058: LD_VAR 0 3
62062: PPUSH
62063: LD_EXP 111
62067: PUSH
62068: LD_VAR 0 1
62072: ARRAY
62073: PUSH
62074: LD_EXP 111
62078: PUSH
62079: LD_VAR 0 1
62083: ARRAY
62084: ARRAY
62085: PPUSH
62086: CALL_OW 120
// end ; exit ;
62090: GO 62369
// end ; if tmp > 1 then
62092: LD_VAR 0 8
62096: PUSH
62097: LD_INT 1
62099: GREATER
62100: IFFALSE 62204
// for i = 2 to tmp do
62102: LD_ADDR_VAR 0 6
62106: PUSH
62107: DOUBLE
62108: LD_INT 2
62110: DEC
62111: ST_TO_ADDR
62112: LD_VAR 0 8
62116: PUSH
62117: FOR_TO
62118: IFFALSE 62202
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
62120: LD_VAR 0 8
62124: PUSH
62125: LD_VAR 0 6
62129: ARRAY
62130: PPUSH
62131: CALL_OW 461
62135: PUSH
62136: LD_INT 6
62138: EQUAL
62139: IFFALSE 62200
// begin x := tmp [ i ] ;
62141: LD_ADDR_VAR 0 9
62145: PUSH
62146: LD_VAR 0 8
62150: PUSH
62151: LD_VAR 0 6
62155: ARRAY
62156: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
62157: LD_ADDR_VAR 0 8
62161: PUSH
62162: LD_VAR 0 8
62166: PPUSH
62167: LD_VAR 0 6
62171: PPUSH
62172: CALL_OW 3
62176: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
62177: LD_ADDR_VAR 0 8
62181: PUSH
62182: LD_VAR 0 8
62186: PPUSH
62187: LD_INT 1
62189: PPUSH
62190: LD_VAR 0 9
62194: PPUSH
62195: CALL_OW 2
62199: ST_TO_ADDR
// end ;
62200: GO 62117
62202: POP
62203: POP
// for i in tmp do
62204: LD_ADDR_VAR 0 6
62208: PUSH
62209: LD_VAR 0 8
62213: PUSH
62214: FOR_IN
62215: IFFALSE 62242
// begin if IsNotFull ( i ) then
62217: LD_VAR 0 6
62221: PPUSH
62222: CALL 71628 0 1
62226: IFFALSE 62240
// begin j := i ;
62228: LD_ADDR_VAR 0 7
62232: PUSH
62233: LD_VAR 0 6
62237: ST_TO_ADDR
// break ;
62238: GO 62242
// end ; end ;
62240: GO 62214
62242: POP
62243: POP
// if j then
62244: LD_VAR 0 7
62248: IFFALSE 62266
// ComEnterUnit ( unit , j ) else
62250: LD_VAR 0 3
62254: PPUSH
62255: LD_VAR 0 7
62259: PPUSH
62260: CALL_OW 120
62264: GO 62369
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62266: LD_ADDR_VAR 0 10
62270: PUSH
62271: LD_VAR 0 2
62275: PPUSH
62276: LD_INT 2
62278: PUSH
62279: LD_INT 30
62281: PUSH
62282: LD_INT 0
62284: PUSH
62285: EMPTY
62286: LIST
62287: LIST
62288: PUSH
62289: LD_INT 30
62291: PUSH
62292: LD_INT 1
62294: PUSH
62295: EMPTY
62296: LIST
62297: LIST
62298: PUSH
62299: EMPTY
62300: LIST
62301: LIST
62302: LIST
62303: PPUSH
62304: CALL_OW 72
62308: ST_TO_ADDR
// if depot then
62309: LD_VAR 0 10
62313: IFFALSE 62369
// begin depot := NearestUnitToUnit ( depot , unit ) ;
62315: LD_ADDR_VAR 0 10
62319: PUSH
62320: LD_VAR 0 10
62324: PPUSH
62325: LD_VAR 0 3
62329: PPUSH
62330: CALL_OW 74
62334: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
62335: LD_VAR 0 3
62339: PPUSH
62340: LD_VAR 0 10
62344: PPUSH
62345: CALL_OW 296
62349: PUSH
62350: LD_INT 10
62352: GREATER
62353: IFFALSE 62369
// ComStandNearbyBuilding ( unit , depot ) ;
62355: LD_VAR 0 3
62359: PPUSH
62360: LD_VAR 0 10
62364: PPUSH
62365: CALL 71008 0 2
// end ; end ; end ;
62369: LD_VAR 0 5
62373: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
62374: LD_INT 0
62376: PPUSH
62377: PPUSH
62378: PPUSH
62379: PPUSH
// if not mc_bases then
62380: LD_EXP 101
62384: NOT
62385: IFFALSE 62389
// exit ;
62387: GO 62628
// for i = 1 to mc_bases do
62389: LD_ADDR_VAR 0 2
62393: PUSH
62394: DOUBLE
62395: LD_INT 1
62397: DEC
62398: ST_TO_ADDR
62399: LD_EXP 101
62403: PUSH
62404: FOR_TO
62405: IFFALSE 62626
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
62407: LD_ADDR_VAR 0 4
62411: PUSH
62412: LD_EXP 101
62416: PUSH
62417: LD_VAR 0 2
62421: ARRAY
62422: PPUSH
62423: LD_INT 21
62425: PUSH
62426: LD_INT 1
62428: PUSH
62429: EMPTY
62430: LIST
62431: LIST
62432: PPUSH
62433: CALL_OW 72
62437: PUSH
62438: LD_EXP 130
62442: PUSH
62443: LD_VAR 0 2
62447: ARRAY
62448: UNION
62449: ST_TO_ADDR
// if not tmp then
62450: LD_VAR 0 4
62454: NOT
62455: IFFALSE 62459
// continue ;
62457: GO 62404
// for j in tmp do
62459: LD_ADDR_VAR 0 3
62463: PUSH
62464: LD_VAR 0 4
62468: PUSH
62469: FOR_IN
62470: IFFALSE 62622
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
62472: LD_VAR 0 3
62476: PPUSH
62477: CALL_OW 110
62481: NOT
62482: PUSH
62483: LD_VAR 0 3
62487: PPUSH
62488: CALL_OW 314
62492: NOT
62493: AND
62494: PUSH
62495: LD_VAR 0 3
62499: PPUSH
62500: CALL_OW 311
62504: NOT
62505: AND
62506: PUSH
62507: LD_VAR 0 3
62511: PPUSH
62512: CALL_OW 310
62516: NOT
62517: AND
62518: PUSH
62519: LD_VAR 0 3
62523: PUSH
62524: LD_EXP 104
62528: PUSH
62529: LD_VAR 0 2
62533: ARRAY
62534: PUSH
62535: LD_INT 1
62537: ARRAY
62538: IN
62539: NOT
62540: AND
62541: PUSH
62542: LD_VAR 0 3
62546: PUSH
62547: LD_EXP 104
62551: PUSH
62552: LD_VAR 0 2
62556: ARRAY
62557: PUSH
62558: LD_INT 2
62560: ARRAY
62561: IN
62562: NOT
62563: AND
62564: PUSH
62565: LD_VAR 0 3
62569: PUSH
62570: LD_EXP 113
62574: PUSH
62575: LD_VAR 0 2
62579: ARRAY
62580: IN
62581: NOT
62582: AND
62583: IFFALSE 62620
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
62585: LD_VAR 0 2
62589: PPUSH
62590: LD_EXP 101
62594: PUSH
62595: LD_VAR 0 2
62599: ARRAY
62600: PPUSH
62601: LD_VAR 0 3
62605: PPUSH
62606: LD_VAR 0 3
62610: PPUSH
62611: CALL_OW 257
62615: PPUSH
62616: CALL 61434 0 4
// end ;
62620: GO 62469
62622: POP
62623: POP
// end ;
62624: GO 62404
62626: POP
62627: POP
// end ;
62628: LD_VAR 0 1
62632: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
62633: LD_INT 0
62635: PPUSH
62636: PPUSH
62637: PPUSH
62638: PPUSH
62639: PPUSH
62640: PPUSH
// if not mc_bases [ base ] then
62641: LD_EXP 101
62645: PUSH
62646: LD_VAR 0 1
62650: ARRAY
62651: NOT
62652: IFFALSE 62656
// exit ;
62654: GO 62857
// tmp := [ ] ;
62656: LD_ADDR_VAR 0 6
62660: PUSH
62661: EMPTY
62662: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
62663: LD_ADDR_VAR 0 7
62667: PUSH
62668: LD_VAR 0 3
62672: PPUSH
62673: LD_INT 0
62675: PPUSH
62676: CALL_OW 517
62680: ST_TO_ADDR
// if not list then
62681: LD_VAR 0 7
62685: NOT
62686: IFFALSE 62690
// exit ;
62688: GO 62857
// c := Count ( list [ 1 ] ) ;
62690: LD_ADDR_VAR 0 9
62694: PUSH
62695: LD_VAR 0 7
62699: PUSH
62700: LD_INT 1
62702: ARRAY
62703: PPUSH
62704: CALL 71546 0 1
62708: ST_TO_ADDR
// if amount > c then
62709: LD_VAR 0 2
62713: PUSH
62714: LD_VAR 0 9
62718: GREATER
62719: IFFALSE 62731
// amount := c ;
62721: LD_ADDR_VAR 0 2
62725: PUSH
62726: LD_VAR 0 9
62730: ST_TO_ADDR
// for i := 1 to amount do
62731: LD_ADDR_VAR 0 5
62735: PUSH
62736: DOUBLE
62737: LD_INT 1
62739: DEC
62740: ST_TO_ADDR
62741: LD_VAR 0 2
62745: PUSH
62746: FOR_TO
62747: IFFALSE 62805
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
62749: LD_ADDR_VAR 0 6
62753: PUSH
62754: LD_VAR 0 6
62758: PPUSH
62759: LD_VAR 0 5
62763: PPUSH
62764: LD_VAR 0 7
62768: PUSH
62769: LD_INT 1
62771: ARRAY
62772: PUSH
62773: LD_VAR 0 5
62777: ARRAY
62778: PUSH
62779: LD_VAR 0 7
62783: PUSH
62784: LD_INT 2
62786: ARRAY
62787: PUSH
62788: LD_VAR 0 5
62792: ARRAY
62793: PUSH
62794: EMPTY
62795: LIST
62796: LIST
62797: PPUSH
62798: CALL_OW 1
62802: ST_TO_ADDR
62803: GO 62746
62805: POP
62806: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
62807: LD_ADDR_EXP 114
62811: PUSH
62812: LD_EXP 114
62816: PPUSH
62817: LD_VAR 0 1
62821: PPUSH
62822: LD_VAR 0 6
62826: PPUSH
62827: CALL_OW 1
62831: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
62832: LD_ADDR_EXP 116
62836: PUSH
62837: LD_EXP 116
62841: PPUSH
62842: LD_VAR 0 1
62846: PPUSH
62847: LD_VAR 0 3
62851: PPUSH
62852: CALL_OW 1
62856: ST_TO_ADDR
// end ;
62857: LD_VAR 0 4
62861: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
62862: LD_INT 0
62864: PPUSH
// if not mc_bases [ base ] then
62865: LD_EXP 101
62869: PUSH
62870: LD_VAR 0 1
62874: ARRAY
62875: NOT
62876: IFFALSE 62880
// exit ;
62878: GO 62905
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
62880: LD_ADDR_EXP 106
62884: PUSH
62885: LD_EXP 106
62889: PPUSH
62890: LD_VAR 0 1
62894: PPUSH
62895: LD_VAR 0 2
62899: PPUSH
62900: CALL_OW 1
62904: ST_TO_ADDR
// end ;
62905: LD_VAR 0 3
62909: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
62910: LD_INT 0
62912: PPUSH
// if not mc_bases [ base ] then
62913: LD_EXP 101
62917: PUSH
62918: LD_VAR 0 1
62922: ARRAY
62923: NOT
62924: IFFALSE 62928
// exit ;
62926: GO 62965
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
62928: LD_ADDR_EXP 106
62932: PUSH
62933: LD_EXP 106
62937: PPUSH
62938: LD_VAR 0 1
62942: PPUSH
62943: LD_EXP 106
62947: PUSH
62948: LD_VAR 0 1
62952: ARRAY
62953: PUSH
62954: LD_VAR 0 2
62958: UNION
62959: PPUSH
62960: CALL_OW 1
62964: ST_TO_ADDR
// end ;
62965: LD_VAR 0 3
62969: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
62970: LD_INT 0
62972: PPUSH
// if not mc_bases [ base ] then
62973: LD_EXP 101
62977: PUSH
62978: LD_VAR 0 1
62982: ARRAY
62983: NOT
62984: IFFALSE 62988
// exit ;
62986: GO 63013
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
62988: LD_ADDR_EXP 122
62992: PUSH
62993: LD_EXP 122
62997: PPUSH
62998: LD_VAR 0 1
63002: PPUSH
63003: LD_VAR 0 2
63007: PPUSH
63008: CALL_OW 1
63012: ST_TO_ADDR
// end ;
63013: LD_VAR 0 3
63017: RET
// export function MC_InsertProduceList ( base , components ) ; begin
63018: LD_INT 0
63020: PPUSH
// if not mc_bases [ base ] then
63021: LD_EXP 101
63025: PUSH
63026: LD_VAR 0 1
63030: ARRAY
63031: NOT
63032: IFFALSE 63036
// exit ;
63034: GO 63073
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
63036: LD_ADDR_EXP 122
63040: PUSH
63041: LD_EXP 122
63045: PPUSH
63046: LD_VAR 0 1
63050: PPUSH
63051: LD_EXP 122
63055: PUSH
63056: LD_VAR 0 1
63060: ARRAY
63061: PUSH
63062: LD_VAR 0 2
63066: ADD
63067: PPUSH
63068: CALL_OW 1
63072: ST_TO_ADDR
// end ;
63073: LD_VAR 0 3
63077: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
63078: LD_INT 0
63080: PPUSH
// if not mc_bases [ base ] then
63081: LD_EXP 101
63085: PUSH
63086: LD_VAR 0 1
63090: ARRAY
63091: NOT
63092: IFFALSE 63096
// exit ;
63094: GO 63150
// mc_defender := Replace ( mc_defender , base , deflist ) ;
63096: LD_ADDR_EXP 123
63100: PUSH
63101: LD_EXP 123
63105: PPUSH
63106: LD_VAR 0 1
63110: PPUSH
63111: LD_VAR 0 2
63115: PPUSH
63116: CALL_OW 1
63120: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
63121: LD_ADDR_EXP 112
63125: PUSH
63126: LD_EXP 112
63130: PPUSH
63131: LD_VAR 0 1
63135: PPUSH
63136: LD_VAR 0 2
63140: PUSH
63141: LD_INT 0
63143: PLUS
63144: PPUSH
63145: CALL_OW 1
63149: ST_TO_ADDR
// end ;
63150: LD_VAR 0 3
63154: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
63155: LD_INT 0
63157: PPUSH
// if not mc_bases [ base ] then
63158: LD_EXP 101
63162: PUSH
63163: LD_VAR 0 1
63167: ARRAY
63168: NOT
63169: IFFALSE 63173
// exit ;
63171: GO 63198
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
63173: LD_ADDR_EXP 112
63177: PUSH
63178: LD_EXP 112
63182: PPUSH
63183: LD_VAR 0 1
63187: PPUSH
63188: LD_VAR 0 2
63192: PPUSH
63193: CALL_OW 1
63197: ST_TO_ADDR
// end ;
63198: LD_VAR 0 3
63202: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
63203: LD_INT 0
63205: PPUSH
63206: PPUSH
63207: PPUSH
63208: PPUSH
// if not mc_bases [ base ] then
63209: LD_EXP 101
63213: PUSH
63214: LD_VAR 0 1
63218: ARRAY
63219: NOT
63220: IFFALSE 63224
// exit ;
63222: GO 63289
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
63224: LD_ADDR_EXP 121
63228: PUSH
63229: LD_EXP 121
63233: PPUSH
63234: LD_VAR 0 1
63238: PUSH
63239: LD_EXP 121
63243: PUSH
63244: LD_VAR 0 1
63248: ARRAY
63249: PUSH
63250: LD_INT 1
63252: PLUS
63253: PUSH
63254: EMPTY
63255: LIST
63256: LIST
63257: PPUSH
63258: LD_VAR 0 1
63262: PUSH
63263: LD_VAR 0 2
63267: PUSH
63268: LD_VAR 0 3
63272: PUSH
63273: LD_VAR 0 4
63277: PUSH
63278: EMPTY
63279: LIST
63280: LIST
63281: LIST
63282: LIST
63283: PPUSH
63284: CALL 74406 0 3
63288: ST_TO_ADDR
// end ;
63289: LD_VAR 0 5
63293: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
63294: LD_INT 0
63296: PPUSH
// if not mc_bases [ base ] then
63297: LD_EXP 101
63301: PUSH
63302: LD_VAR 0 1
63306: ARRAY
63307: NOT
63308: IFFALSE 63312
// exit ;
63310: GO 63337
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
63312: LD_ADDR_EXP 138
63316: PUSH
63317: LD_EXP 138
63321: PPUSH
63322: LD_VAR 0 1
63326: PPUSH
63327: LD_VAR 0 2
63331: PPUSH
63332: CALL_OW 1
63336: ST_TO_ADDR
// end ;
63337: LD_VAR 0 3
63341: RET
// export function MC_GetMinesField ( base ) ; begin
63342: LD_INT 0
63344: PPUSH
// result := mc_mines [ base ] ;
63345: LD_ADDR_VAR 0 2
63349: PUSH
63350: LD_EXP 114
63354: PUSH
63355: LD_VAR 0 1
63359: ARRAY
63360: ST_TO_ADDR
// end ;
63361: LD_VAR 0 2
63365: RET
// export function MC_GetProduceList ( base ) ; begin
63366: LD_INT 0
63368: PPUSH
// result := mc_produce [ base ] ;
63369: LD_ADDR_VAR 0 2
63373: PUSH
63374: LD_EXP 122
63378: PUSH
63379: LD_VAR 0 1
63383: ARRAY
63384: ST_TO_ADDR
// end ;
63385: LD_VAR 0 2
63389: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
63390: LD_INT 0
63392: PPUSH
63393: PPUSH
// if not mc_bases then
63394: LD_EXP 101
63398: NOT
63399: IFFALSE 63403
// exit ;
63401: GO 63468
// if mc_bases [ base ] then
63403: LD_EXP 101
63407: PUSH
63408: LD_VAR 0 1
63412: ARRAY
63413: IFFALSE 63468
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
63415: LD_ADDR_VAR 0 3
63419: PUSH
63420: LD_EXP 101
63424: PUSH
63425: LD_VAR 0 1
63429: ARRAY
63430: PPUSH
63431: LD_INT 30
63433: PUSH
63434: LD_VAR 0 2
63438: PUSH
63439: EMPTY
63440: LIST
63441: LIST
63442: PPUSH
63443: CALL_OW 72
63447: ST_TO_ADDR
// if result then
63448: LD_VAR 0 3
63452: IFFALSE 63468
// result := result [ 1 ] ;
63454: LD_ADDR_VAR 0 3
63458: PUSH
63459: LD_VAR 0 3
63463: PUSH
63464: LD_INT 1
63466: ARRAY
63467: ST_TO_ADDR
// end ; end ;
63468: LD_VAR 0 3
63472: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
63473: LD_INT 0
63475: PPUSH
63476: PPUSH
// if not mc_bases then
63477: LD_EXP 101
63481: NOT
63482: IFFALSE 63486
// exit ;
63484: GO 63531
// if mc_bases [ base ] then
63486: LD_EXP 101
63490: PUSH
63491: LD_VAR 0 1
63495: ARRAY
63496: IFFALSE 63531
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
63498: LD_ADDR_VAR 0 3
63502: PUSH
63503: LD_EXP 101
63507: PUSH
63508: LD_VAR 0 1
63512: ARRAY
63513: PPUSH
63514: LD_INT 30
63516: PUSH
63517: LD_VAR 0 2
63521: PUSH
63522: EMPTY
63523: LIST
63524: LIST
63525: PPUSH
63526: CALL_OW 72
63530: ST_TO_ADDR
// end ;
63531: LD_VAR 0 3
63535: RET
// export function MC_SetTame ( base , area ) ; begin
63536: LD_INT 0
63538: PPUSH
// if not mc_bases or not base then
63539: LD_EXP 101
63543: NOT
63544: PUSH
63545: LD_VAR 0 1
63549: NOT
63550: OR
63551: IFFALSE 63555
// exit ;
63553: GO 63580
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
63555: LD_ADDR_EXP 129
63559: PUSH
63560: LD_EXP 129
63564: PPUSH
63565: LD_VAR 0 1
63569: PPUSH
63570: LD_VAR 0 2
63574: PPUSH
63575: CALL_OW 1
63579: ST_TO_ADDR
// end ;
63580: LD_VAR 0 3
63584: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
63585: LD_INT 0
63587: PPUSH
63588: PPUSH
// if not mc_bases or not base then
63589: LD_EXP 101
63593: NOT
63594: PUSH
63595: LD_VAR 0 1
63599: NOT
63600: OR
63601: IFFALSE 63605
// exit ;
63603: GO 63707
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
63605: LD_ADDR_VAR 0 4
63609: PUSH
63610: LD_EXP 101
63614: PUSH
63615: LD_VAR 0 1
63619: ARRAY
63620: PPUSH
63621: LD_INT 30
63623: PUSH
63624: LD_VAR 0 2
63628: PUSH
63629: EMPTY
63630: LIST
63631: LIST
63632: PPUSH
63633: CALL_OW 72
63637: ST_TO_ADDR
// if not tmp then
63638: LD_VAR 0 4
63642: NOT
63643: IFFALSE 63647
// exit ;
63645: GO 63707
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
63647: LD_ADDR_EXP 133
63651: PUSH
63652: LD_EXP 133
63656: PPUSH
63657: LD_VAR 0 1
63661: PPUSH
63662: LD_EXP 133
63666: PUSH
63667: LD_VAR 0 1
63671: ARRAY
63672: PPUSH
63673: LD_EXP 133
63677: PUSH
63678: LD_VAR 0 1
63682: ARRAY
63683: PUSH
63684: LD_INT 1
63686: PLUS
63687: PPUSH
63688: LD_VAR 0 4
63692: PUSH
63693: LD_INT 1
63695: ARRAY
63696: PPUSH
63697: CALL_OW 2
63701: PPUSH
63702: CALL_OW 1
63706: ST_TO_ADDR
// end ;
63707: LD_VAR 0 3
63711: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
63712: LD_INT 0
63714: PPUSH
63715: PPUSH
// if not mc_bases or not base or not kinds then
63716: LD_EXP 101
63720: NOT
63721: PUSH
63722: LD_VAR 0 1
63726: NOT
63727: OR
63728: PUSH
63729: LD_VAR 0 2
63733: NOT
63734: OR
63735: IFFALSE 63739
// exit ;
63737: GO 63800
// for i in kinds do
63739: LD_ADDR_VAR 0 4
63743: PUSH
63744: LD_VAR 0 2
63748: PUSH
63749: FOR_IN
63750: IFFALSE 63798
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
63752: LD_ADDR_EXP 135
63756: PUSH
63757: LD_EXP 135
63761: PPUSH
63762: LD_VAR 0 1
63766: PUSH
63767: LD_EXP 135
63771: PUSH
63772: LD_VAR 0 1
63776: ARRAY
63777: PUSH
63778: LD_INT 1
63780: PLUS
63781: PUSH
63782: EMPTY
63783: LIST
63784: LIST
63785: PPUSH
63786: LD_VAR 0 4
63790: PPUSH
63791: CALL 74406 0 3
63795: ST_TO_ADDR
63796: GO 63749
63798: POP
63799: POP
// end ;
63800: LD_VAR 0 3
63804: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
63805: LD_INT 0
63807: PPUSH
// if not mc_bases or not base or not areas then
63808: LD_EXP 101
63812: NOT
63813: PUSH
63814: LD_VAR 0 1
63818: NOT
63819: OR
63820: PUSH
63821: LD_VAR 0 2
63825: NOT
63826: OR
63827: IFFALSE 63831
// exit ;
63829: GO 63856
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
63831: LD_ADDR_EXP 119
63835: PUSH
63836: LD_EXP 119
63840: PPUSH
63841: LD_VAR 0 1
63845: PPUSH
63846: LD_VAR 0 2
63850: PPUSH
63851: CALL_OW 1
63855: ST_TO_ADDR
// end ;
63856: LD_VAR 0 3
63860: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
63861: LD_INT 0
63863: PPUSH
// if not mc_bases or not base or not teleports_exit then
63864: LD_EXP 101
63868: NOT
63869: PUSH
63870: LD_VAR 0 1
63874: NOT
63875: OR
63876: PUSH
63877: LD_VAR 0 2
63881: NOT
63882: OR
63883: IFFALSE 63887
// exit ;
63885: GO 63912
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
63887: LD_ADDR_EXP 136
63891: PUSH
63892: LD_EXP 136
63896: PPUSH
63897: LD_VAR 0 1
63901: PPUSH
63902: LD_VAR 0 2
63906: PPUSH
63907: CALL_OW 1
63911: ST_TO_ADDR
// end ;
63912: LD_VAR 0 3
63916: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
63917: LD_INT 0
63919: PPUSH
63920: PPUSH
63921: PPUSH
// if not mc_bases or not base or not ext_list then
63922: LD_EXP 101
63926: NOT
63927: PUSH
63928: LD_VAR 0 1
63932: NOT
63933: OR
63934: PUSH
63935: LD_VAR 0 5
63939: NOT
63940: OR
63941: IFFALSE 63945
// exit ;
63943: GO 64118
// tmp := GetFacExtXYD ( x , y , d ) ;
63945: LD_ADDR_VAR 0 8
63949: PUSH
63950: LD_VAR 0 2
63954: PPUSH
63955: LD_VAR 0 3
63959: PPUSH
63960: LD_VAR 0 4
63964: PPUSH
63965: CALL 104769 0 3
63969: ST_TO_ADDR
// if not tmp then
63970: LD_VAR 0 8
63974: NOT
63975: IFFALSE 63979
// exit ;
63977: GO 64118
// for i in tmp do
63979: LD_ADDR_VAR 0 7
63983: PUSH
63984: LD_VAR 0 8
63988: PUSH
63989: FOR_IN
63990: IFFALSE 64116
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
63992: LD_ADDR_EXP 106
63996: PUSH
63997: LD_EXP 106
64001: PPUSH
64002: LD_VAR 0 1
64006: PPUSH
64007: LD_EXP 106
64011: PUSH
64012: LD_VAR 0 1
64016: ARRAY
64017: PPUSH
64018: LD_EXP 106
64022: PUSH
64023: LD_VAR 0 1
64027: ARRAY
64028: PUSH
64029: LD_INT 1
64031: PLUS
64032: PPUSH
64033: LD_VAR 0 5
64037: PUSH
64038: LD_INT 1
64040: ARRAY
64041: PUSH
64042: LD_VAR 0 7
64046: PUSH
64047: LD_INT 1
64049: ARRAY
64050: PUSH
64051: LD_VAR 0 7
64055: PUSH
64056: LD_INT 2
64058: ARRAY
64059: PUSH
64060: LD_VAR 0 7
64064: PUSH
64065: LD_INT 3
64067: ARRAY
64068: PUSH
64069: EMPTY
64070: LIST
64071: LIST
64072: LIST
64073: LIST
64074: PPUSH
64075: CALL_OW 2
64079: PPUSH
64080: CALL_OW 1
64084: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
64085: LD_ADDR_VAR 0 5
64089: PUSH
64090: LD_VAR 0 5
64094: PPUSH
64095: LD_INT 1
64097: PPUSH
64098: CALL_OW 3
64102: ST_TO_ADDR
// if not ext_list then
64103: LD_VAR 0 5
64107: NOT
64108: IFFALSE 64114
// exit ;
64110: POP
64111: POP
64112: GO 64118
// end ;
64114: GO 63989
64116: POP
64117: POP
// end ;
64118: LD_VAR 0 6
64122: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
64123: LD_INT 0
64125: PPUSH
// if not mc_bases or not base or not weapon_list then
64126: LD_EXP 101
64130: NOT
64131: PUSH
64132: LD_VAR 0 1
64136: NOT
64137: OR
64138: PUSH
64139: LD_VAR 0 2
64143: NOT
64144: OR
64145: IFFALSE 64149
// exit ;
64147: GO 64174
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
64149: LD_ADDR_EXP 140
64153: PUSH
64154: LD_EXP 140
64158: PPUSH
64159: LD_VAR 0 1
64163: PPUSH
64164: LD_VAR 0 2
64168: PPUSH
64169: CALL_OW 1
64173: ST_TO_ADDR
// end ;
64174: LD_VAR 0 3
64178: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
64179: LD_INT 0
64181: PPUSH
// if not mc_bases or not base or not tech_list then
64182: LD_EXP 101
64186: NOT
64187: PUSH
64188: LD_VAR 0 1
64192: NOT
64193: OR
64194: PUSH
64195: LD_VAR 0 2
64199: NOT
64200: OR
64201: IFFALSE 64205
// exit ;
64203: GO 64230
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
64205: LD_ADDR_EXP 128
64209: PUSH
64210: LD_EXP 128
64214: PPUSH
64215: LD_VAR 0 1
64219: PPUSH
64220: LD_VAR 0 2
64224: PPUSH
64225: CALL_OW 1
64229: ST_TO_ADDR
// end ;
64230: LD_VAR 0 3
64234: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
64235: LD_INT 0
64237: PPUSH
// if not mc_bases or not parking_area or not base then
64238: LD_EXP 101
64242: NOT
64243: PUSH
64244: LD_VAR 0 2
64248: NOT
64249: OR
64250: PUSH
64251: LD_VAR 0 1
64255: NOT
64256: OR
64257: IFFALSE 64261
// exit ;
64259: GO 64286
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
64261: LD_ADDR_EXP 125
64265: PUSH
64266: LD_EXP 125
64270: PPUSH
64271: LD_VAR 0 1
64275: PPUSH
64276: LD_VAR 0 2
64280: PPUSH
64281: CALL_OW 1
64285: ST_TO_ADDR
// end ;
64286: LD_VAR 0 3
64290: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
64291: LD_INT 0
64293: PPUSH
// if not mc_bases or not base or not scan_area then
64294: LD_EXP 101
64298: NOT
64299: PUSH
64300: LD_VAR 0 1
64304: NOT
64305: OR
64306: PUSH
64307: LD_VAR 0 2
64311: NOT
64312: OR
64313: IFFALSE 64317
// exit ;
64315: GO 64342
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
64317: LD_ADDR_EXP 126
64321: PUSH
64322: LD_EXP 126
64326: PPUSH
64327: LD_VAR 0 1
64331: PPUSH
64332: LD_VAR 0 2
64336: PPUSH
64337: CALL_OW 1
64341: ST_TO_ADDR
// end ;
64342: LD_VAR 0 3
64346: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
64347: LD_INT 0
64349: PPUSH
64350: PPUSH
// if not mc_bases or not base then
64351: LD_EXP 101
64355: NOT
64356: PUSH
64357: LD_VAR 0 1
64361: NOT
64362: OR
64363: IFFALSE 64367
// exit ;
64365: GO 64431
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
64367: LD_ADDR_VAR 0 3
64371: PUSH
64372: LD_INT 1
64374: PUSH
64375: LD_INT 2
64377: PUSH
64378: LD_INT 3
64380: PUSH
64381: LD_INT 4
64383: PUSH
64384: LD_INT 11
64386: PUSH
64387: EMPTY
64388: LIST
64389: LIST
64390: LIST
64391: LIST
64392: LIST
64393: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
64394: LD_ADDR_EXP 128
64398: PUSH
64399: LD_EXP 128
64403: PPUSH
64404: LD_VAR 0 1
64408: PPUSH
64409: LD_EXP 128
64413: PUSH
64414: LD_VAR 0 1
64418: ARRAY
64419: PUSH
64420: LD_VAR 0 3
64424: DIFF
64425: PPUSH
64426: CALL_OW 1
64430: ST_TO_ADDR
// end ;
64431: LD_VAR 0 2
64435: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
64436: LD_INT 0
64438: PPUSH
// result := mc_vehicles [ base ] ;
64439: LD_ADDR_VAR 0 3
64443: PUSH
64444: LD_EXP 120
64448: PUSH
64449: LD_VAR 0 1
64453: ARRAY
64454: ST_TO_ADDR
// if onlyCombat then
64455: LD_VAR 0 2
64459: IFFALSE 64631
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
64461: LD_ADDR_VAR 0 3
64465: PUSH
64466: LD_VAR 0 3
64470: PUSH
64471: LD_VAR 0 3
64475: PPUSH
64476: LD_INT 2
64478: PUSH
64479: LD_INT 34
64481: PUSH
64482: LD_INT 12
64484: PUSH
64485: EMPTY
64486: LIST
64487: LIST
64488: PUSH
64489: LD_INT 34
64491: PUSH
64492: LD_INT 51
64494: PUSH
64495: EMPTY
64496: LIST
64497: LIST
64498: PUSH
64499: LD_INT 34
64501: PUSH
64502: LD_INT 89
64504: PUSH
64505: EMPTY
64506: LIST
64507: LIST
64508: PUSH
64509: LD_INT 34
64511: PUSH
64512: LD_INT 32
64514: PUSH
64515: EMPTY
64516: LIST
64517: LIST
64518: PUSH
64519: LD_INT 34
64521: PUSH
64522: LD_INT 13
64524: PUSH
64525: EMPTY
64526: LIST
64527: LIST
64528: PUSH
64529: LD_INT 34
64531: PUSH
64532: LD_INT 52
64534: PUSH
64535: EMPTY
64536: LIST
64537: LIST
64538: PUSH
64539: LD_INT 34
64541: PUSH
64542: LD_INT 88
64544: PUSH
64545: EMPTY
64546: LIST
64547: LIST
64548: PUSH
64549: LD_INT 34
64551: PUSH
64552: LD_INT 14
64554: PUSH
64555: EMPTY
64556: LIST
64557: LIST
64558: PUSH
64559: LD_INT 34
64561: PUSH
64562: LD_INT 53
64564: PUSH
64565: EMPTY
64566: LIST
64567: LIST
64568: PUSH
64569: LD_INT 34
64571: PUSH
64572: LD_INT 98
64574: PUSH
64575: EMPTY
64576: LIST
64577: LIST
64578: PUSH
64579: LD_INT 34
64581: PUSH
64582: LD_INT 31
64584: PUSH
64585: EMPTY
64586: LIST
64587: LIST
64588: PUSH
64589: LD_INT 34
64591: PUSH
64592: LD_INT 48
64594: PUSH
64595: EMPTY
64596: LIST
64597: LIST
64598: PUSH
64599: LD_INT 34
64601: PUSH
64602: LD_INT 8
64604: PUSH
64605: EMPTY
64606: LIST
64607: LIST
64608: PUSH
64609: EMPTY
64610: LIST
64611: LIST
64612: LIST
64613: LIST
64614: LIST
64615: LIST
64616: LIST
64617: LIST
64618: LIST
64619: LIST
64620: LIST
64621: LIST
64622: LIST
64623: LIST
64624: PPUSH
64625: CALL_OW 72
64629: DIFF
64630: ST_TO_ADDR
// end ; end_of_file
64631: LD_VAR 0 3
64635: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
64636: LD_INT 0
64638: PPUSH
64639: PPUSH
64640: PPUSH
// if not mc_bases or not skirmish then
64641: LD_EXP 101
64645: NOT
64646: PUSH
64647: LD_EXP 99
64651: NOT
64652: OR
64653: IFFALSE 64657
// exit ;
64655: GO 64822
// for i = 1 to mc_bases do
64657: LD_ADDR_VAR 0 4
64661: PUSH
64662: DOUBLE
64663: LD_INT 1
64665: DEC
64666: ST_TO_ADDR
64667: LD_EXP 101
64671: PUSH
64672: FOR_TO
64673: IFFALSE 64820
// begin if sci in mc_bases [ i ] then
64675: LD_VAR 0 2
64679: PUSH
64680: LD_EXP 101
64684: PUSH
64685: LD_VAR 0 4
64689: ARRAY
64690: IN
64691: IFFALSE 64818
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
64693: LD_ADDR_EXP 130
64697: PUSH
64698: LD_EXP 130
64702: PPUSH
64703: LD_VAR 0 4
64707: PUSH
64708: LD_EXP 130
64712: PUSH
64713: LD_VAR 0 4
64717: ARRAY
64718: PUSH
64719: LD_INT 1
64721: PLUS
64722: PUSH
64723: EMPTY
64724: LIST
64725: LIST
64726: PPUSH
64727: LD_VAR 0 1
64731: PPUSH
64732: CALL 74406 0 3
64736: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
64737: LD_ADDR_VAR 0 5
64741: PUSH
64742: LD_EXP 101
64746: PUSH
64747: LD_VAR 0 4
64751: ARRAY
64752: PPUSH
64753: LD_INT 2
64755: PUSH
64756: LD_INT 30
64758: PUSH
64759: LD_INT 0
64761: PUSH
64762: EMPTY
64763: LIST
64764: LIST
64765: PUSH
64766: LD_INT 30
64768: PUSH
64769: LD_INT 1
64771: PUSH
64772: EMPTY
64773: LIST
64774: LIST
64775: PUSH
64776: EMPTY
64777: LIST
64778: LIST
64779: LIST
64780: PPUSH
64781: CALL_OW 72
64785: PPUSH
64786: LD_VAR 0 1
64790: PPUSH
64791: CALL_OW 74
64795: ST_TO_ADDR
// if tmp then
64796: LD_VAR 0 5
64800: IFFALSE 64816
// ComStandNearbyBuilding ( ape , tmp ) ;
64802: LD_VAR 0 1
64806: PPUSH
64807: LD_VAR 0 5
64811: PPUSH
64812: CALL 71008 0 2
// break ;
64816: GO 64820
// end ; end ;
64818: GO 64672
64820: POP
64821: POP
// end ;
64822: LD_VAR 0 3
64826: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
64827: LD_INT 0
64829: PPUSH
64830: PPUSH
64831: PPUSH
// if not mc_bases or not skirmish then
64832: LD_EXP 101
64836: NOT
64837: PUSH
64838: LD_EXP 99
64842: NOT
64843: OR
64844: IFFALSE 64848
// exit ;
64846: GO 64937
// for i = 1 to mc_bases do
64848: LD_ADDR_VAR 0 4
64852: PUSH
64853: DOUBLE
64854: LD_INT 1
64856: DEC
64857: ST_TO_ADDR
64858: LD_EXP 101
64862: PUSH
64863: FOR_TO
64864: IFFALSE 64935
// begin if building in mc_busy_turret_list [ i ] then
64866: LD_VAR 0 1
64870: PUSH
64871: LD_EXP 111
64875: PUSH
64876: LD_VAR 0 4
64880: ARRAY
64881: IN
64882: IFFALSE 64933
// begin tmp := mc_busy_turret_list [ i ] diff building ;
64884: LD_ADDR_VAR 0 5
64888: PUSH
64889: LD_EXP 111
64893: PUSH
64894: LD_VAR 0 4
64898: ARRAY
64899: PUSH
64900: LD_VAR 0 1
64904: DIFF
64905: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
64906: LD_ADDR_EXP 111
64910: PUSH
64911: LD_EXP 111
64915: PPUSH
64916: LD_VAR 0 4
64920: PPUSH
64921: LD_VAR 0 5
64925: PPUSH
64926: CALL_OW 1
64930: ST_TO_ADDR
// break ;
64931: GO 64935
// end ; end ;
64933: GO 64863
64935: POP
64936: POP
// end ;
64937: LD_VAR 0 3
64941: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
64942: LD_INT 0
64944: PPUSH
64945: PPUSH
64946: PPUSH
// if not mc_bases or not skirmish then
64947: LD_EXP 101
64951: NOT
64952: PUSH
64953: LD_EXP 99
64957: NOT
64958: OR
64959: IFFALSE 64963
// exit ;
64961: GO 65162
// for i = 1 to mc_bases do
64963: LD_ADDR_VAR 0 5
64967: PUSH
64968: DOUBLE
64969: LD_INT 1
64971: DEC
64972: ST_TO_ADDR
64973: LD_EXP 101
64977: PUSH
64978: FOR_TO
64979: IFFALSE 65160
// if building in mc_bases [ i ] then
64981: LD_VAR 0 1
64985: PUSH
64986: LD_EXP 101
64990: PUSH
64991: LD_VAR 0 5
64995: ARRAY
64996: IN
64997: IFFALSE 65158
// begin tmp := mc_bases [ i ] diff building ;
64999: LD_ADDR_VAR 0 6
65003: PUSH
65004: LD_EXP 101
65008: PUSH
65009: LD_VAR 0 5
65013: ARRAY
65014: PUSH
65015: LD_VAR 0 1
65019: DIFF
65020: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
65021: LD_ADDR_EXP 101
65025: PUSH
65026: LD_EXP 101
65030: PPUSH
65031: LD_VAR 0 5
65035: PPUSH
65036: LD_VAR 0 6
65040: PPUSH
65041: CALL_OW 1
65045: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
65046: LD_VAR 0 1
65050: PUSH
65051: LD_EXP 109
65055: PUSH
65056: LD_VAR 0 5
65060: ARRAY
65061: IN
65062: IFFALSE 65101
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
65064: LD_ADDR_EXP 109
65068: PUSH
65069: LD_EXP 109
65073: PPUSH
65074: LD_VAR 0 5
65078: PPUSH
65079: LD_EXP 109
65083: PUSH
65084: LD_VAR 0 5
65088: ARRAY
65089: PUSH
65090: LD_VAR 0 1
65094: DIFF
65095: PPUSH
65096: CALL_OW 1
65100: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
65101: LD_VAR 0 1
65105: PUSH
65106: LD_EXP 110
65110: PUSH
65111: LD_VAR 0 5
65115: ARRAY
65116: IN
65117: IFFALSE 65156
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
65119: LD_ADDR_EXP 110
65123: PUSH
65124: LD_EXP 110
65128: PPUSH
65129: LD_VAR 0 5
65133: PPUSH
65134: LD_EXP 110
65138: PUSH
65139: LD_VAR 0 5
65143: ARRAY
65144: PUSH
65145: LD_VAR 0 1
65149: DIFF
65150: PPUSH
65151: CALL_OW 1
65155: ST_TO_ADDR
// break ;
65156: GO 65160
// end ;
65158: GO 64978
65160: POP
65161: POP
// end ;
65162: LD_VAR 0 4
65166: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
65167: LD_INT 0
65169: PPUSH
65170: PPUSH
65171: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
65172: LD_EXP 101
65176: NOT
65177: PUSH
65178: LD_EXP 99
65182: NOT
65183: OR
65184: PUSH
65185: LD_VAR 0 3
65189: PUSH
65190: LD_EXP 127
65194: IN
65195: NOT
65196: OR
65197: IFFALSE 65201
// exit ;
65199: GO 65324
// for i = 1 to mc_vehicles do
65201: LD_ADDR_VAR 0 6
65205: PUSH
65206: DOUBLE
65207: LD_INT 1
65209: DEC
65210: ST_TO_ADDR
65211: LD_EXP 120
65215: PUSH
65216: FOR_TO
65217: IFFALSE 65322
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
65219: LD_VAR 0 2
65223: PUSH
65224: LD_EXP 120
65228: PUSH
65229: LD_VAR 0 6
65233: ARRAY
65234: IN
65235: PUSH
65236: LD_VAR 0 1
65240: PUSH
65241: LD_EXP 120
65245: PUSH
65246: LD_VAR 0 6
65250: ARRAY
65251: IN
65252: OR
65253: IFFALSE 65320
// begin tmp := mc_vehicles [ i ] diff old ;
65255: LD_ADDR_VAR 0 7
65259: PUSH
65260: LD_EXP 120
65264: PUSH
65265: LD_VAR 0 6
65269: ARRAY
65270: PUSH
65271: LD_VAR 0 2
65275: DIFF
65276: ST_TO_ADDR
// tmp := tmp diff new ;
65277: LD_ADDR_VAR 0 7
65281: PUSH
65282: LD_VAR 0 7
65286: PUSH
65287: LD_VAR 0 1
65291: DIFF
65292: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
65293: LD_ADDR_EXP 120
65297: PUSH
65298: LD_EXP 120
65302: PPUSH
65303: LD_VAR 0 6
65307: PPUSH
65308: LD_VAR 0 7
65312: PPUSH
65313: CALL_OW 1
65317: ST_TO_ADDR
// break ;
65318: GO 65322
// end ;
65320: GO 65216
65322: POP
65323: POP
// end ;
65324: LD_VAR 0 5
65328: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
65329: LD_INT 0
65331: PPUSH
65332: PPUSH
65333: PPUSH
65334: PPUSH
// if not mc_bases or not skirmish then
65335: LD_EXP 101
65339: NOT
65340: PUSH
65341: LD_EXP 99
65345: NOT
65346: OR
65347: IFFALSE 65351
// exit ;
65349: GO 65771
// repeat wait ( 0 0$1 ) ;
65351: LD_INT 35
65353: PPUSH
65354: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
65358: LD_EXP 145
65362: NOT
65363: IFFALSE 65351
// mc_block_vehicle_constructed_thread := true ;
65365: LD_ADDR_EXP 145
65369: PUSH
65370: LD_INT 1
65372: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
65373: LD_ADDR_VAR 0 5
65377: PUSH
65378: LD_VAR 0 1
65382: PPUSH
65383: CALL_OW 255
65387: ST_TO_ADDR
// for i = 1 to mc_bases do
65388: LD_ADDR_VAR 0 4
65392: PUSH
65393: DOUBLE
65394: LD_INT 1
65396: DEC
65397: ST_TO_ADDR
65398: LD_EXP 101
65402: PUSH
65403: FOR_TO
65404: IFFALSE 65761
// begin if factory in mc_bases [ i ] then
65406: LD_VAR 0 2
65410: PUSH
65411: LD_EXP 101
65415: PUSH
65416: LD_VAR 0 4
65420: ARRAY
65421: IN
65422: IFFALSE 65759
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
65424: LD_EXP 123
65428: PUSH
65429: LD_VAR 0 4
65433: ARRAY
65434: PUSH
65435: LD_EXP 112
65439: PUSH
65440: LD_VAR 0 4
65444: ARRAY
65445: LESS
65446: PUSH
65447: LD_VAR 0 1
65451: PPUSH
65452: CALL_OW 264
65456: PUSH
65457: LD_INT 31
65459: PUSH
65460: LD_INT 32
65462: PUSH
65463: LD_INT 51
65465: PUSH
65466: LD_INT 89
65468: PUSH
65469: LD_INT 12
65471: PUSH
65472: LD_INT 30
65474: PUSH
65475: LD_INT 98
65477: PUSH
65478: LD_INT 11
65480: PUSH
65481: LD_INT 53
65483: PUSH
65484: LD_INT 14
65486: PUSH
65487: LD_INT 91
65489: PUSH
65490: LD_INT 29
65492: PUSH
65493: LD_INT 99
65495: PUSH
65496: LD_INT 13
65498: PUSH
65499: LD_INT 52
65501: PUSH
65502: LD_INT 88
65504: PUSH
65505: LD_INT 48
65507: PUSH
65508: LD_INT 8
65510: PUSH
65511: EMPTY
65512: LIST
65513: LIST
65514: LIST
65515: LIST
65516: LIST
65517: LIST
65518: LIST
65519: LIST
65520: LIST
65521: LIST
65522: LIST
65523: LIST
65524: LIST
65525: LIST
65526: LIST
65527: LIST
65528: LIST
65529: LIST
65530: IN
65531: NOT
65532: AND
65533: IFFALSE 65581
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
65535: LD_ADDR_EXP 123
65539: PUSH
65540: LD_EXP 123
65544: PPUSH
65545: LD_VAR 0 4
65549: PUSH
65550: LD_EXP 123
65554: PUSH
65555: LD_VAR 0 4
65559: ARRAY
65560: PUSH
65561: LD_INT 1
65563: PLUS
65564: PUSH
65565: EMPTY
65566: LIST
65567: LIST
65568: PPUSH
65569: LD_VAR 0 1
65573: PPUSH
65574: CALL 74406 0 3
65578: ST_TO_ADDR
65579: GO 65625
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
65581: LD_ADDR_EXP 120
65585: PUSH
65586: LD_EXP 120
65590: PPUSH
65591: LD_VAR 0 4
65595: PUSH
65596: LD_EXP 120
65600: PUSH
65601: LD_VAR 0 4
65605: ARRAY
65606: PUSH
65607: LD_INT 1
65609: PLUS
65610: PUSH
65611: EMPTY
65612: LIST
65613: LIST
65614: PPUSH
65615: LD_VAR 0 1
65619: PPUSH
65620: CALL 74406 0 3
65624: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
65625: LD_ADDR_EXP 145
65629: PUSH
65630: LD_INT 0
65632: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
65633: LD_VAR 0 1
65637: PPUSH
65638: CALL_OW 263
65642: PUSH
65643: LD_INT 2
65645: EQUAL
65646: IFFALSE 65675
// begin repeat wait ( 0 0$3 ) ;
65648: LD_INT 105
65650: PPUSH
65651: CALL_OW 67
// Connect ( vehicle ) ;
65655: LD_VAR 0 1
65659: PPUSH
65660: CALL 77752 0 1
// until IsControledBy ( vehicle ) ;
65664: LD_VAR 0 1
65668: PPUSH
65669: CALL_OW 312
65673: IFFALSE 65648
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
65675: LD_VAR 0 1
65679: PPUSH
65680: LD_EXP 125
65684: PUSH
65685: LD_VAR 0 4
65689: ARRAY
65690: PPUSH
65691: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
65695: LD_VAR 0 1
65699: PPUSH
65700: CALL_OW 263
65704: PUSH
65705: LD_INT 1
65707: NONEQUAL
65708: IFFALSE 65712
// break ;
65710: GO 65761
// repeat wait ( 0 0$1 ) ;
65712: LD_INT 35
65714: PPUSH
65715: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
65719: LD_VAR 0 1
65723: PPUSH
65724: LD_EXP 125
65728: PUSH
65729: LD_VAR 0 4
65733: ARRAY
65734: PPUSH
65735: CALL_OW 308
65739: IFFALSE 65712
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
65741: LD_VAR 0 1
65745: PPUSH
65746: CALL_OW 311
65750: PPUSH
65751: CALL_OW 121
// exit ;
65755: POP
65756: POP
65757: GO 65771
// end ; end ;
65759: GO 65403
65761: POP
65762: POP
// mc_block_vehicle_constructed_thread := false ;
65763: LD_ADDR_EXP 145
65767: PUSH
65768: LD_INT 0
65770: ST_TO_ADDR
// end ;
65771: LD_VAR 0 3
65775: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
65776: LD_INT 0
65778: PPUSH
65779: PPUSH
65780: PPUSH
65781: PPUSH
// if not mc_bases or not skirmish then
65782: LD_EXP 101
65786: NOT
65787: PUSH
65788: LD_EXP 99
65792: NOT
65793: OR
65794: IFFALSE 65798
// exit ;
65796: GO 66151
// repeat wait ( 0 0$1 ) ;
65798: LD_INT 35
65800: PPUSH
65801: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
65805: LD_VAR 0 2
65809: PPUSH
65810: LD_VAR 0 3
65814: PPUSH
65815: CALL_OW 284
65819: IFFALSE 65798
// if GetResourceTypeXY ( x , y ) = mat_artefact then
65821: LD_VAR 0 2
65825: PPUSH
65826: LD_VAR 0 3
65830: PPUSH
65831: CALL_OW 283
65835: PUSH
65836: LD_INT 4
65838: EQUAL
65839: IFFALSE 65843
// exit ;
65841: GO 66151
// for i = 1 to mc_bases do
65843: LD_ADDR_VAR 0 7
65847: PUSH
65848: DOUBLE
65849: LD_INT 1
65851: DEC
65852: ST_TO_ADDR
65853: LD_EXP 101
65857: PUSH
65858: FOR_TO
65859: IFFALSE 66149
// begin if mc_crates_area [ i ] then
65861: LD_EXP 119
65865: PUSH
65866: LD_VAR 0 7
65870: ARRAY
65871: IFFALSE 65982
// for j in mc_crates_area [ i ] do
65873: LD_ADDR_VAR 0 8
65877: PUSH
65878: LD_EXP 119
65882: PUSH
65883: LD_VAR 0 7
65887: ARRAY
65888: PUSH
65889: FOR_IN
65890: IFFALSE 65980
// if InArea ( x , y , j ) then
65892: LD_VAR 0 2
65896: PPUSH
65897: LD_VAR 0 3
65901: PPUSH
65902: LD_VAR 0 8
65906: PPUSH
65907: CALL_OW 309
65911: IFFALSE 65978
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
65913: LD_ADDR_EXP 117
65917: PUSH
65918: LD_EXP 117
65922: PPUSH
65923: LD_VAR 0 7
65927: PUSH
65928: LD_EXP 117
65932: PUSH
65933: LD_VAR 0 7
65937: ARRAY
65938: PUSH
65939: LD_INT 1
65941: PLUS
65942: PUSH
65943: EMPTY
65944: LIST
65945: LIST
65946: PPUSH
65947: LD_VAR 0 4
65951: PUSH
65952: LD_VAR 0 2
65956: PUSH
65957: LD_VAR 0 3
65961: PUSH
65962: EMPTY
65963: LIST
65964: LIST
65965: LIST
65966: PPUSH
65967: CALL 74406 0 3
65971: ST_TO_ADDR
// exit ;
65972: POP
65973: POP
65974: POP
65975: POP
65976: GO 66151
// end ;
65978: GO 65889
65980: POP
65981: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65982: LD_ADDR_VAR 0 9
65986: PUSH
65987: LD_EXP 101
65991: PUSH
65992: LD_VAR 0 7
65996: ARRAY
65997: PPUSH
65998: LD_INT 2
66000: PUSH
66001: LD_INT 30
66003: PUSH
66004: LD_INT 0
66006: PUSH
66007: EMPTY
66008: LIST
66009: LIST
66010: PUSH
66011: LD_INT 30
66013: PUSH
66014: LD_INT 1
66016: PUSH
66017: EMPTY
66018: LIST
66019: LIST
66020: PUSH
66021: EMPTY
66022: LIST
66023: LIST
66024: LIST
66025: PPUSH
66026: CALL_OW 72
66030: ST_TO_ADDR
// if not depot then
66031: LD_VAR 0 9
66035: NOT
66036: IFFALSE 66040
// continue ;
66038: GO 65858
// for j in depot do
66040: LD_ADDR_VAR 0 8
66044: PUSH
66045: LD_VAR 0 9
66049: PUSH
66050: FOR_IN
66051: IFFALSE 66145
// if GetDistUnitXY ( j , x , y ) < 30 then
66053: LD_VAR 0 8
66057: PPUSH
66058: LD_VAR 0 2
66062: PPUSH
66063: LD_VAR 0 3
66067: PPUSH
66068: CALL_OW 297
66072: PUSH
66073: LD_INT 30
66075: LESS
66076: IFFALSE 66143
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
66078: LD_ADDR_EXP 117
66082: PUSH
66083: LD_EXP 117
66087: PPUSH
66088: LD_VAR 0 7
66092: PUSH
66093: LD_EXP 117
66097: PUSH
66098: LD_VAR 0 7
66102: ARRAY
66103: PUSH
66104: LD_INT 1
66106: PLUS
66107: PUSH
66108: EMPTY
66109: LIST
66110: LIST
66111: PPUSH
66112: LD_VAR 0 4
66116: PUSH
66117: LD_VAR 0 2
66121: PUSH
66122: LD_VAR 0 3
66126: PUSH
66127: EMPTY
66128: LIST
66129: LIST
66130: LIST
66131: PPUSH
66132: CALL 74406 0 3
66136: ST_TO_ADDR
// exit ;
66137: POP
66138: POP
66139: POP
66140: POP
66141: GO 66151
// end ;
66143: GO 66050
66145: POP
66146: POP
// end ;
66147: GO 65858
66149: POP
66150: POP
// end ;
66151: LD_VAR 0 6
66155: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
66156: LD_INT 0
66158: PPUSH
66159: PPUSH
66160: PPUSH
66161: PPUSH
// if not mc_bases or not skirmish then
66162: LD_EXP 101
66166: NOT
66167: PUSH
66168: LD_EXP 99
66172: NOT
66173: OR
66174: IFFALSE 66178
// exit ;
66176: GO 66455
// side := GetSide ( lab ) ;
66178: LD_ADDR_VAR 0 4
66182: PUSH
66183: LD_VAR 0 2
66187: PPUSH
66188: CALL_OW 255
66192: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
66193: LD_VAR 0 4
66197: PUSH
66198: LD_EXP 127
66202: IN
66203: NOT
66204: PUSH
66205: LD_EXP 128
66209: NOT
66210: OR
66211: PUSH
66212: LD_EXP 101
66216: NOT
66217: OR
66218: IFFALSE 66222
// exit ;
66220: GO 66455
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
66222: LD_ADDR_EXP 128
66226: PUSH
66227: LD_EXP 128
66231: PPUSH
66232: LD_VAR 0 4
66236: PPUSH
66237: LD_EXP 128
66241: PUSH
66242: LD_VAR 0 4
66246: ARRAY
66247: PUSH
66248: LD_VAR 0 1
66252: DIFF
66253: PPUSH
66254: CALL_OW 1
66258: ST_TO_ADDR
// for i = 1 to mc_bases do
66259: LD_ADDR_VAR 0 5
66263: PUSH
66264: DOUBLE
66265: LD_INT 1
66267: DEC
66268: ST_TO_ADDR
66269: LD_EXP 101
66273: PUSH
66274: FOR_TO
66275: IFFALSE 66453
// begin if lab in mc_bases [ i ] then
66277: LD_VAR 0 2
66281: PUSH
66282: LD_EXP 101
66286: PUSH
66287: LD_VAR 0 5
66291: ARRAY
66292: IN
66293: IFFALSE 66451
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
66295: LD_VAR 0 1
66299: PUSH
66300: LD_INT 11
66302: PUSH
66303: LD_INT 4
66305: PUSH
66306: LD_INT 3
66308: PUSH
66309: LD_INT 2
66311: PUSH
66312: EMPTY
66313: LIST
66314: LIST
66315: LIST
66316: LIST
66317: IN
66318: PUSH
66319: LD_EXP 131
66323: PUSH
66324: LD_VAR 0 5
66328: ARRAY
66329: AND
66330: IFFALSE 66451
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
66332: LD_ADDR_VAR 0 6
66336: PUSH
66337: LD_EXP 131
66341: PUSH
66342: LD_VAR 0 5
66346: ARRAY
66347: PUSH
66348: LD_INT 1
66350: ARRAY
66351: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
66352: LD_ADDR_EXP 131
66356: PUSH
66357: LD_EXP 131
66361: PPUSH
66362: LD_VAR 0 5
66366: PPUSH
66367: EMPTY
66368: PPUSH
66369: CALL_OW 1
66373: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
66374: LD_VAR 0 6
66378: PPUSH
66379: LD_INT 0
66381: PPUSH
66382: CALL_OW 109
// ComExitBuilding ( tmp ) ;
66386: LD_VAR 0 6
66390: PPUSH
66391: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
66395: LD_ADDR_EXP 130
66399: PUSH
66400: LD_EXP 130
66404: PPUSH
66405: LD_VAR 0 5
66409: PPUSH
66410: LD_EXP 130
66414: PUSH
66415: LD_VAR 0 5
66419: ARRAY
66420: PPUSH
66421: LD_INT 1
66423: PPUSH
66424: LD_VAR 0 6
66428: PPUSH
66429: CALL_OW 2
66433: PPUSH
66434: CALL_OW 1
66438: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
66439: LD_VAR 0 5
66443: PPUSH
66444: LD_INT 112
66446: PPUSH
66447: CALL 42905 0 2
// end ; end ; end ;
66451: GO 66274
66453: POP
66454: POP
// end ;
66455: LD_VAR 0 3
66459: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
66460: LD_INT 0
66462: PPUSH
66463: PPUSH
66464: PPUSH
66465: PPUSH
66466: PPUSH
66467: PPUSH
66468: PPUSH
66469: PPUSH
// if not mc_bases or not skirmish then
66470: LD_EXP 101
66474: NOT
66475: PUSH
66476: LD_EXP 99
66480: NOT
66481: OR
66482: IFFALSE 66486
// exit ;
66484: GO 67855
// for i = 1 to mc_bases do
66486: LD_ADDR_VAR 0 3
66490: PUSH
66491: DOUBLE
66492: LD_INT 1
66494: DEC
66495: ST_TO_ADDR
66496: LD_EXP 101
66500: PUSH
66501: FOR_TO
66502: IFFALSE 67853
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
66504: LD_VAR 0 1
66508: PUSH
66509: LD_EXP 101
66513: PUSH
66514: LD_VAR 0 3
66518: ARRAY
66519: IN
66520: PUSH
66521: LD_VAR 0 1
66525: PUSH
66526: LD_EXP 108
66530: PUSH
66531: LD_VAR 0 3
66535: ARRAY
66536: IN
66537: OR
66538: PUSH
66539: LD_VAR 0 1
66543: PUSH
66544: LD_EXP 123
66548: PUSH
66549: LD_VAR 0 3
66553: ARRAY
66554: IN
66555: OR
66556: PUSH
66557: LD_VAR 0 1
66561: PUSH
66562: LD_EXP 120
66566: PUSH
66567: LD_VAR 0 3
66571: ARRAY
66572: IN
66573: OR
66574: PUSH
66575: LD_VAR 0 1
66579: PUSH
66580: LD_EXP 130
66584: PUSH
66585: LD_VAR 0 3
66589: ARRAY
66590: IN
66591: OR
66592: PUSH
66593: LD_VAR 0 1
66597: PUSH
66598: LD_EXP 131
66602: PUSH
66603: LD_VAR 0 3
66607: ARRAY
66608: IN
66609: OR
66610: IFFALSE 67851
// begin if un in mc_ape [ i ] then
66612: LD_VAR 0 1
66616: PUSH
66617: LD_EXP 130
66621: PUSH
66622: LD_VAR 0 3
66626: ARRAY
66627: IN
66628: IFFALSE 66667
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
66630: LD_ADDR_EXP 130
66634: PUSH
66635: LD_EXP 130
66639: PPUSH
66640: LD_VAR 0 3
66644: PPUSH
66645: LD_EXP 130
66649: PUSH
66650: LD_VAR 0 3
66654: ARRAY
66655: PUSH
66656: LD_VAR 0 1
66660: DIFF
66661: PPUSH
66662: CALL_OW 1
66666: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
66667: LD_VAR 0 1
66671: PUSH
66672: LD_EXP 131
66676: PUSH
66677: LD_VAR 0 3
66681: ARRAY
66682: IN
66683: IFFALSE 66707
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
66685: LD_ADDR_EXP 131
66689: PUSH
66690: LD_EXP 131
66694: PPUSH
66695: LD_VAR 0 3
66699: PPUSH
66700: EMPTY
66701: PPUSH
66702: CALL_OW 1
66706: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
66707: LD_VAR 0 1
66711: PPUSH
66712: CALL_OW 247
66716: PUSH
66717: LD_INT 2
66719: EQUAL
66720: PUSH
66721: LD_VAR 0 1
66725: PPUSH
66726: CALL_OW 110
66730: PUSH
66731: LD_INT 20
66733: EQUAL
66734: PUSH
66735: LD_VAR 0 1
66739: PUSH
66740: LD_EXP 123
66744: PUSH
66745: LD_VAR 0 3
66749: ARRAY
66750: IN
66751: OR
66752: PUSH
66753: LD_VAR 0 1
66757: PPUSH
66758: CALL_OW 264
66762: PUSH
66763: LD_INT 12
66765: PUSH
66766: LD_INT 51
66768: PUSH
66769: LD_INT 89
66771: PUSH
66772: LD_INT 32
66774: PUSH
66775: LD_INT 13
66777: PUSH
66778: LD_INT 52
66780: PUSH
66781: LD_INT 31
66783: PUSH
66784: EMPTY
66785: LIST
66786: LIST
66787: LIST
66788: LIST
66789: LIST
66790: LIST
66791: LIST
66792: IN
66793: OR
66794: AND
66795: IFFALSE 67103
// begin if un in mc_defender [ i ] then
66797: LD_VAR 0 1
66801: PUSH
66802: LD_EXP 123
66806: PUSH
66807: LD_VAR 0 3
66811: ARRAY
66812: IN
66813: IFFALSE 66852
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
66815: LD_ADDR_EXP 123
66819: PUSH
66820: LD_EXP 123
66824: PPUSH
66825: LD_VAR 0 3
66829: PPUSH
66830: LD_EXP 123
66834: PUSH
66835: LD_VAR 0 3
66839: ARRAY
66840: PUSH
66841: LD_VAR 0 1
66845: DIFF
66846: PPUSH
66847: CALL_OW 1
66851: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
66852: LD_ADDR_VAR 0 8
66856: PUSH
66857: LD_VAR 0 3
66861: PPUSH
66862: LD_INT 3
66864: PPUSH
66865: CALL 63473 0 2
66869: ST_TO_ADDR
// if fac then
66870: LD_VAR 0 8
66874: IFFALSE 67103
// begin for j in fac do
66876: LD_ADDR_VAR 0 4
66880: PUSH
66881: LD_VAR 0 8
66885: PUSH
66886: FOR_IN
66887: IFFALSE 67101
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
66889: LD_ADDR_VAR 0 9
66893: PUSH
66894: LD_VAR 0 8
66898: PPUSH
66899: LD_VAR 0 1
66903: PPUSH
66904: CALL_OW 265
66908: PPUSH
66909: LD_VAR 0 1
66913: PPUSH
66914: CALL_OW 262
66918: PPUSH
66919: LD_VAR 0 1
66923: PPUSH
66924: CALL_OW 263
66928: PPUSH
66929: LD_VAR 0 1
66933: PPUSH
66934: CALL_OW 264
66938: PPUSH
66939: CALL 71904 0 5
66943: ST_TO_ADDR
// if components then
66944: LD_VAR 0 9
66948: IFFALSE 67099
// begin if GetWeapon ( un ) = ar_control_tower then
66950: LD_VAR 0 1
66954: PPUSH
66955: CALL_OW 264
66959: PUSH
66960: LD_INT 31
66962: EQUAL
66963: IFFALSE 67080
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
66965: LD_VAR 0 1
66969: PPUSH
66970: CALL_OW 311
66974: PPUSH
66975: LD_INT 0
66977: PPUSH
66978: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
66982: LD_ADDR_EXP 141
66986: PUSH
66987: LD_EXP 141
66991: PPUSH
66992: LD_VAR 0 3
66996: PPUSH
66997: LD_EXP 141
67001: PUSH
67002: LD_VAR 0 3
67006: ARRAY
67007: PUSH
67008: LD_VAR 0 1
67012: PPUSH
67013: CALL_OW 311
67017: DIFF
67018: PPUSH
67019: CALL_OW 1
67023: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
67024: LD_ADDR_VAR 0 7
67028: PUSH
67029: LD_EXP 122
67033: PUSH
67034: LD_VAR 0 3
67038: ARRAY
67039: PPUSH
67040: LD_INT 1
67042: PPUSH
67043: LD_VAR 0 9
67047: PPUSH
67048: CALL_OW 2
67052: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
67053: LD_ADDR_EXP 122
67057: PUSH
67058: LD_EXP 122
67062: PPUSH
67063: LD_VAR 0 3
67067: PPUSH
67068: LD_VAR 0 7
67072: PPUSH
67073: CALL_OW 1
67077: ST_TO_ADDR
// end else
67078: GO 67097
// MC_InsertProduceList ( i , [ components ] ) ;
67080: LD_VAR 0 3
67084: PPUSH
67085: LD_VAR 0 9
67089: PUSH
67090: EMPTY
67091: LIST
67092: PPUSH
67093: CALL 63018 0 2
// break ;
67097: GO 67101
// end ; end ;
67099: GO 66886
67101: POP
67102: POP
// end ; end ; if GetType ( un ) = unit_building then
67103: LD_VAR 0 1
67107: PPUSH
67108: CALL_OW 247
67112: PUSH
67113: LD_INT 3
67115: EQUAL
67116: IFFALSE 67519
// begin btype := GetBType ( un ) ;
67118: LD_ADDR_VAR 0 5
67122: PUSH
67123: LD_VAR 0 1
67127: PPUSH
67128: CALL_OW 266
67132: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
67133: LD_VAR 0 5
67137: PUSH
67138: LD_INT 29
67140: PUSH
67141: LD_INT 30
67143: PUSH
67144: EMPTY
67145: LIST
67146: LIST
67147: IN
67148: IFFALSE 67221
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
67150: LD_VAR 0 1
67154: PPUSH
67155: CALL_OW 250
67159: PPUSH
67160: LD_VAR 0 1
67164: PPUSH
67165: CALL_OW 251
67169: PPUSH
67170: LD_VAR 0 1
67174: PPUSH
67175: CALL_OW 255
67179: PPUSH
67180: CALL_OW 440
67184: NOT
67185: IFFALSE 67221
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
67187: LD_VAR 0 1
67191: PPUSH
67192: CALL_OW 250
67196: PPUSH
67197: LD_VAR 0 1
67201: PPUSH
67202: CALL_OW 251
67206: PPUSH
67207: LD_VAR 0 1
67211: PPUSH
67212: CALL_OW 255
67216: PPUSH
67217: CALL_OW 441
// end ; if btype = b_warehouse then
67221: LD_VAR 0 5
67225: PUSH
67226: LD_INT 1
67228: EQUAL
67229: IFFALSE 67247
// begin btype := b_depot ;
67231: LD_ADDR_VAR 0 5
67235: PUSH
67236: LD_INT 0
67238: ST_TO_ADDR
// pos := 1 ;
67239: LD_ADDR_VAR 0 6
67243: PUSH
67244: LD_INT 1
67246: ST_TO_ADDR
// end ; if btype = b_factory then
67247: LD_VAR 0 5
67251: PUSH
67252: LD_INT 3
67254: EQUAL
67255: IFFALSE 67273
// begin btype := b_workshop ;
67257: LD_ADDR_VAR 0 5
67261: PUSH
67262: LD_INT 2
67264: ST_TO_ADDR
// pos := 1 ;
67265: LD_ADDR_VAR 0 6
67269: PUSH
67270: LD_INT 1
67272: ST_TO_ADDR
// end ; if btype = b_barracks then
67273: LD_VAR 0 5
67277: PUSH
67278: LD_INT 5
67280: EQUAL
67281: IFFALSE 67291
// btype := b_armoury ;
67283: LD_ADDR_VAR 0 5
67287: PUSH
67288: LD_INT 4
67290: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
67291: LD_VAR 0 5
67295: PUSH
67296: LD_INT 7
67298: PUSH
67299: LD_INT 8
67301: PUSH
67302: EMPTY
67303: LIST
67304: LIST
67305: IN
67306: IFFALSE 67316
// btype := b_lab ;
67308: LD_ADDR_VAR 0 5
67312: PUSH
67313: LD_INT 6
67315: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
67316: LD_ADDR_EXP 106
67320: PUSH
67321: LD_EXP 106
67325: PPUSH
67326: LD_VAR 0 3
67330: PUSH
67331: LD_EXP 106
67335: PUSH
67336: LD_VAR 0 3
67340: ARRAY
67341: PUSH
67342: LD_INT 1
67344: PLUS
67345: PUSH
67346: EMPTY
67347: LIST
67348: LIST
67349: PPUSH
67350: LD_VAR 0 5
67354: PUSH
67355: LD_VAR 0 1
67359: PPUSH
67360: CALL_OW 250
67364: PUSH
67365: LD_VAR 0 1
67369: PPUSH
67370: CALL_OW 251
67374: PUSH
67375: LD_VAR 0 1
67379: PPUSH
67380: CALL_OW 254
67384: PUSH
67385: EMPTY
67386: LIST
67387: LIST
67388: LIST
67389: LIST
67390: PPUSH
67391: CALL 74406 0 3
67395: ST_TO_ADDR
// if pos = 1 then
67396: LD_VAR 0 6
67400: PUSH
67401: LD_INT 1
67403: EQUAL
67404: IFFALSE 67519
// begin tmp := mc_build_list [ i ] ;
67406: LD_ADDR_VAR 0 7
67410: PUSH
67411: LD_EXP 106
67415: PUSH
67416: LD_VAR 0 3
67420: ARRAY
67421: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
67422: LD_VAR 0 7
67426: PPUSH
67427: LD_INT 2
67429: PUSH
67430: LD_INT 30
67432: PUSH
67433: LD_INT 0
67435: PUSH
67436: EMPTY
67437: LIST
67438: LIST
67439: PUSH
67440: LD_INT 30
67442: PUSH
67443: LD_INT 1
67445: PUSH
67446: EMPTY
67447: LIST
67448: LIST
67449: PUSH
67450: EMPTY
67451: LIST
67452: LIST
67453: LIST
67454: PPUSH
67455: CALL_OW 72
67459: IFFALSE 67469
// pos := 2 ;
67461: LD_ADDR_VAR 0 6
67465: PUSH
67466: LD_INT 2
67468: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
67469: LD_ADDR_VAR 0 7
67473: PUSH
67474: LD_VAR 0 7
67478: PPUSH
67479: LD_VAR 0 6
67483: PPUSH
67484: LD_VAR 0 7
67488: PPUSH
67489: CALL 74732 0 3
67493: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
67494: LD_ADDR_EXP 106
67498: PUSH
67499: LD_EXP 106
67503: PPUSH
67504: LD_VAR 0 3
67508: PPUSH
67509: LD_VAR 0 7
67513: PPUSH
67514: CALL_OW 1
67518: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
67519: LD_VAR 0 1
67523: PUSH
67524: LD_EXP 101
67528: PUSH
67529: LD_VAR 0 3
67533: ARRAY
67534: IN
67535: IFFALSE 67574
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
67537: LD_ADDR_EXP 101
67541: PUSH
67542: LD_EXP 101
67546: PPUSH
67547: LD_VAR 0 3
67551: PPUSH
67552: LD_EXP 101
67556: PUSH
67557: LD_VAR 0 3
67561: ARRAY
67562: PUSH
67563: LD_VAR 0 1
67567: DIFF
67568: PPUSH
67569: CALL_OW 1
67573: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
67574: LD_VAR 0 1
67578: PUSH
67579: LD_EXP 108
67583: PUSH
67584: LD_VAR 0 3
67588: ARRAY
67589: IN
67590: IFFALSE 67629
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
67592: LD_ADDR_EXP 108
67596: PUSH
67597: LD_EXP 108
67601: PPUSH
67602: LD_VAR 0 3
67606: PPUSH
67607: LD_EXP 108
67611: PUSH
67612: LD_VAR 0 3
67616: ARRAY
67617: PUSH
67618: LD_VAR 0 1
67622: DIFF
67623: PPUSH
67624: CALL_OW 1
67628: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
67629: LD_VAR 0 1
67633: PUSH
67634: LD_EXP 120
67638: PUSH
67639: LD_VAR 0 3
67643: ARRAY
67644: IN
67645: IFFALSE 67684
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
67647: LD_ADDR_EXP 120
67651: PUSH
67652: LD_EXP 120
67656: PPUSH
67657: LD_VAR 0 3
67661: PPUSH
67662: LD_EXP 120
67666: PUSH
67667: LD_VAR 0 3
67671: ARRAY
67672: PUSH
67673: LD_VAR 0 1
67677: DIFF
67678: PPUSH
67679: CALL_OW 1
67683: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
67684: LD_VAR 0 1
67688: PUSH
67689: LD_EXP 123
67693: PUSH
67694: LD_VAR 0 3
67698: ARRAY
67699: IN
67700: IFFALSE 67739
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
67702: LD_ADDR_EXP 123
67706: PUSH
67707: LD_EXP 123
67711: PPUSH
67712: LD_VAR 0 3
67716: PPUSH
67717: LD_EXP 123
67721: PUSH
67722: LD_VAR 0 3
67726: ARRAY
67727: PUSH
67728: LD_VAR 0 1
67732: DIFF
67733: PPUSH
67734: CALL_OW 1
67738: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
67739: LD_VAR 0 1
67743: PUSH
67744: LD_EXP 110
67748: PUSH
67749: LD_VAR 0 3
67753: ARRAY
67754: IN
67755: IFFALSE 67794
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
67757: LD_ADDR_EXP 110
67761: PUSH
67762: LD_EXP 110
67766: PPUSH
67767: LD_VAR 0 3
67771: PPUSH
67772: LD_EXP 110
67776: PUSH
67777: LD_VAR 0 3
67781: ARRAY
67782: PUSH
67783: LD_VAR 0 1
67787: DIFF
67788: PPUSH
67789: CALL_OW 1
67793: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
67794: LD_VAR 0 1
67798: PUSH
67799: LD_EXP 109
67803: PUSH
67804: LD_VAR 0 3
67808: ARRAY
67809: IN
67810: IFFALSE 67849
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
67812: LD_ADDR_EXP 109
67816: PUSH
67817: LD_EXP 109
67821: PPUSH
67822: LD_VAR 0 3
67826: PPUSH
67827: LD_EXP 109
67831: PUSH
67832: LD_VAR 0 3
67836: ARRAY
67837: PUSH
67838: LD_VAR 0 1
67842: DIFF
67843: PPUSH
67844: CALL_OW 1
67848: ST_TO_ADDR
// end ; break ;
67849: GO 67853
// end ;
67851: GO 66501
67853: POP
67854: POP
// end ;
67855: LD_VAR 0 2
67859: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
67860: LD_INT 0
67862: PPUSH
67863: PPUSH
67864: PPUSH
// if not mc_bases or not skirmish then
67865: LD_EXP 101
67869: NOT
67870: PUSH
67871: LD_EXP 99
67875: NOT
67876: OR
67877: IFFALSE 67881
// exit ;
67879: GO 68096
// for i = 1 to mc_bases do
67881: LD_ADDR_VAR 0 3
67885: PUSH
67886: DOUBLE
67887: LD_INT 1
67889: DEC
67890: ST_TO_ADDR
67891: LD_EXP 101
67895: PUSH
67896: FOR_TO
67897: IFFALSE 68094
// begin if building in mc_construct_list [ i ] then
67899: LD_VAR 0 1
67903: PUSH
67904: LD_EXP 108
67908: PUSH
67909: LD_VAR 0 3
67913: ARRAY
67914: IN
67915: IFFALSE 68092
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
67917: LD_ADDR_EXP 108
67921: PUSH
67922: LD_EXP 108
67926: PPUSH
67927: LD_VAR 0 3
67931: PPUSH
67932: LD_EXP 108
67936: PUSH
67937: LD_VAR 0 3
67941: ARRAY
67942: PUSH
67943: LD_VAR 0 1
67947: DIFF
67948: PPUSH
67949: CALL_OW 1
67953: ST_TO_ADDR
// if building in mc_lab [ i ] then
67954: LD_VAR 0 1
67958: PUSH
67959: LD_EXP 134
67963: PUSH
67964: LD_VAR 0 3
67968: ARRAY
67969: IN
67970: IFFALSE 68025
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
67972: LD_ADDR_EXP 135
67976: PUSH
67977: LD_EXP 135
67981: PPUSH
67982: LD_VAR 0 3
67986: PPUSH
67987: LD_EXP 135
67991: PUSH
67992: LD_VAR 0 3
67996: ARRAY
67997: PPUSH
67998: LD_INT 1
68000: PPUSH
68001: LD_EXP 135
68005: PUSH
68006: LD_VAR 0 3
68010: ARRAY
68011: PPUSH
68012: LD_INT 0
68014: PPUSH
68015: CALL 73824 0 4
68019: PPUSH
68020: CALL_OW 1
68024: ST_TO_ADDR
// if not building in mc_bases [ i ] then
68025: LD_VAR 0 1
68029: PUSH
68030: LD_EXP 101
68034: PUSH
68035: LD_VAR 0 3
68039: ARRAY
68040: IN
68041: NOT
68042: IFFALSE 68088
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
68044: LD_ADDR_EXP 101
68048: PUSH
68049: LD_EXP 101
68053: PPUSH
68054: LD_VAR 0 3
68058: PUSH
68059: LD_EXP 101
68063: PUSH
68064: LD_VAR 0 3
68068: ARRAY
68069: PUSH
68070: LD_INT 1
68072: PLUS
68073: PUSH
68074: EMPTY
68075: LIST
68076: LIST
68077: PPUSH
68078: LD_VAR 0 1
68082: PPUSH
68083: CALL 74406 0 3
68087: ST_TO_ADDR
// exit ;
68088: POP
68089: POP
68090: GO 68096
// end ; end ;
68092: GO 67896
68094: POP
68095: POP
// end ;
68096: LD_VAR 0 2
68100: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
68101: LD_INT 0
68103: PPUSH
68104: PPUSH
68105: PPUSH
68106: PPUSH
68107: PPUSH
68108: PPUSH
68109: PPUSH
// if not mc_bases or not skirmish then
68110: LD_EXP 101
68114: NOT
68115: PUSH
68116: LD_EXP 99
68120: NOT
68121: OR
68122: IFFALSE 68126
// exit ;
68124: GO 68787
// for i = 1 to mc_bases do
68126: LD_ADDR_VAR 0 3
68130: PUSH
68131: DOUBLE
68132: LD_INT 1
68134: DEC
68135: ST_TO_ADDR
68136: LD_EXP 101
68140: PUSH
68141: FOR_TO
68142: IFFALSE 68785
// begin if building in mc_construct_list [ i ] then
68144: LD_VAR 0 1
68148: PUSH
68149: LD_EXP 108
68153: PUSH
68154: LD_VAR 0 3
68158: ARRAY
68159: IN
68160: IFFALSE 68783
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
68162: LD_ADDR_EXP 108
68166: PUSH
68167: LD_EXP 108
68171: PPUSH
68172: LD_VAR 0 3
68176: PPUSH
68177: LD_EXP 108
68181: PUSH
68182: LD_VAR 0 3
68186: ARRAY
68187: PUSH
68188: LD_VAR 0 1
68192: DIFF
68193: PPUSH
68194: CALL_OW 1
68198: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
68199: LD_ADDR_EXP 101
68203: PUSH
68204: LD_EXP 101
68208: PPUSH
68209: LD_VAR 0 3
68213: PUSH
68214: LD_EXP 101
68218: PUSH
68219: LD_VAR 0 3
68223: ARRAY
68224: PUSH
68225: LD_INT 1
68227: PLUS
68228: PUSH
68229: EMPTY
68230: LIST
68231: LIST
68232: PPUSH
68233: LD_VAR 0 1
68237: PPUSH
68238: CALL 74406 0 3
68242: ST_TO_ADDR
// btype := GetBType ( building ) ;
68243: LD_ADDR_VAR 0 5
68247: PUSH
68248: LD_VAR 0 1
68252: PPUSH
68253: CALL_OW 266
68257: ST_TO_ADDR
// side := GetSide ( building ) ;
68258: LD_ADDR_VAR 0 8
68262: PUSH
68263: LD_VAR 0 1
68267: PPUSH
68268: CALL_OW 255
68272: ST_TO_ADDR
// if btype = b_lab then
68273: LD_VAR 0 5
68277: PUSH
68278: LD_INT 6
68280: EQUAL
68281: IFFALSE 68331
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
68283: LD_ADDR_EXP 134
68287: PUSH
68288: LD_EXP 134
68292: PPUSH
68293: LD_VAR 0 3
68297: PUSH
68298: LD_EXP 134
68302: PUSH
68303: LD_VAR 0 3
68307: ARRAY
68308: PUSH
68309: LD_INT 1
68311: PLUS
68312: PUSH
68313: EMPTY
68314: LIST
68315: LIST
68316: PPUSH
68317: LD_VAR 0 1
68321: PPUSH
68322: CALL 74406 0 3
68326: ST_TO_ADDR
// exit ;
68327: POP
68328: POP
68329: GO 68787
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
68331: LD_VAR 0 5
68335: PUSH
68336: LD_INT 0
68338: PUSH
68339: LD_INT 2
68341: PUSH
68342: LD_INT 4
68344: PUSH
68345: EMPTY
68346: LIST
68347: LIST
68348: LIST
68349: IN
68350: IFFALSE 68474
// begin if btype = b_armoury then
68352: LD_VAR 0 5
68356: PUSH
68357: LD_INT 4
68359: EQUAL
68360: IFFALSE 68370
// btype := b_barracks ;
68362: LD_ADDR_VAR 0 5
68366: PUSH
68367: LD_INT 5
68369: ST_TO_ADDR
// if btype = b_depot then
68370: LD_VAR 0 5
68374: PUSH
68375: LD_INT 0
68377: EQUAL
68378: IFFALSE 68388
// btype := b_warehouse ;
68380: LD_ADDR_VAR 0 5
68384: PUSH
68385: LD_INT 1
68387: ST_TO_ADDR
// if btype = b_workshop then
68388: LD_VAR 0 5
68392: PUSH
68393: LD_INT 2
68395: EQUAL
68396: IFFALSE 68406
// btype := b_factory ;
68398: LD_ADDR_VAR 0 5
68402: PUSH
68403: LD_INT 3
68405: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
68406: LD_VAR 0 5
68410: PPUSH
68411: LD_VAR 0 8
68415: PPUSH
68416: CALL_OW 323
68420: PUSH
68421: LD_INT 1
68423: EQUAL
68424: IFFALSE 68470
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
68426: LD_ADDR_EXP 133
68430: PUSH
68431: LD_EXP 133
68435: PPUSH
68436: LD_VAR 0 3
68440: PUSH
68441: LD_EXP 133
68445: PUSH
68446: LD_VAR 0 3
68450: ARRAY
68451: PUSH
68452: LD_INT 1
68454: PLUS
68455: PUSH
68456: EMPTY
68457: LIST
68458: LIST
68459: PPUSH
68460: LD_VAR 0 1
68464: PPUSH
68465: CALL 74406 0 3
68469: ST_TO_ADDR
// exit ;
68470: POP
68471: POP
68472: GO 68787
// end ; if btype in [ b_bunker , b_turret ] then
68474: LD_VAR 0 5
68478: PUSH
68479: LD_INT 32
68481: PUSH
68482: LD_INT 33
68484: PUSH
68485: EMPTY
68486: LIST
68487: LIST
68488: IN
68489: IFFALSE 68779
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
68491: LD_ADDR_EXP 109
68495: PUSH
68496: LD_EXP 109
68500: PPUSH
68501: LD_VAR 0 3
68505: PUSH
68506: LD_EXP 109
68510: PUSH
68511: LD_VAR 0 3
68515: ARRAY
68516: PUSH
68517: LD_INT 1
68519: PLUS
68520: PUSH
68521: EMPTY
68522: LIST
68523: LIST
68524: PPUSH
68525: LD_VAR 0 1
68529: PPUSH
68530: CALL 74406 0 3
68534: ST_TO_ADDR
// if btype = b_bunker then
68535: LD_VAR 0 5
68539: PUSH
68540: LD_INT 32
68542: EQUAL
68543: IFFALSE 68779
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
68545: LD_ADDR_EXP 110
68549: PUSH
68550: LD_EXP 110
68554: PPUSH
68555: LD_VAR 0 3
68559: PUSH
68560: LD_EXP 110
68564: PUSH
68565: LD_VAR 0 3
68569: ARRAY
68570: PUSH
68571: LD_INT 1
68573: PLUS
68574: PUSH
68575: EMPTY
68576: LIST
68577: LIST
68578: PPUSH
68579: LD_VAR 0 1
68583: PPUSH
68584: CALL 74406 0 3
68588: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
68589: LD_ADDR_VAR 0 6
68593: PUSH
68594: LD_EXP 101
68598: PUSH
68599: LD_VAR 0 3
68603: ARRAY
68604: PPUSH
68605: LD_INT 25
68607: PUSH
68608: LD_INT 1
68610: PUSH
68611: EMPTY
68612: LIST
68613: LIST
68614: PUSH
68615: LD_INT 3
68617: PUSH
68618: LD_INT 54
68620: PUSH
68621: EMPTY
68622: LIST
68623: PUSH
68624: EMPTY
68625: LIST
68626: LIST
68627: PUSH
68628: EMPTY
68629: LIST
68630: LIST
68631: PPUSH
68632: CALL_OW 72
68636: ST_TO_ADDR
// if tmp then
68637: LD_VAR 0 6
68641: IFFALSE 68647
// exit ;
68643: POP
68644: POP
68645: GO 68787
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
68647: LD_ADDR_VAR 0 6
68651: PUSH
68652: LD_EXP 101
68656: PUSH
68657: LD_VAR 0 3
68661: ARRAY
68662: PPUSH
68663: LD_INT 2
68665: PUSH
68666: LD_INT 30
68668: PUSH
68669: LD_INT 4
68671: PUSH
68672: EMPTY
68673: LIST
68674: LIST
68675: PUSH
68676: LD_INT 30
68678: PUSH
68679: LD_INT 5
68681: PUSH
68682: EMPTY
68683: LIST
68684: LIST
68685: PUSH
68686: EMPTY
68687: LIST
68688: LIST
68689: LIST
68690: PPUSH
68691: CALL_OW 72
68695: ST_TO_ADDR
// if not tmp then
68696: LD_VAR 0 6
68700: NOT
68701: IFFALSE 68707
// exit ;
68703: POP
68704: POP
68705: GO 68787
// for j in tmp do
68707: LD_ADDR_VAR 0 4
68711: PUSH
68712: LD_VAR 0 6
68716: PUSH
68717: FOR_IN
68718: IFFALSE 68777
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
68720: LD_ADDR_VAR 0 7
68724: PUSH
68725: LD_VAR 0 4
68729: PPUSH
68730: CALL_OW 313
68734: PPUSH
68735: LD_INT 25
68737: PUSH
68738: LD_INT 1
68740: PUSH
68741: EMPTY
68742: LIST
68743: LIST
68744: PPUSH
68745: CALL_OW 72
68749: ST_TO_ADDR
// if units then
68750: LD_VAR 0 7
68754: IFFALSE 68775
// begin ComExitBuilding ( units [ 1 ] ) ;
68756: LD_VAR 0 7
68760: PUSH
68761: LD_INT 1
68763: ARRAY
68764: PPUSH
68765: CALL_OW 122
// exit ;
68769: POP
68770: POP
68771: POP
68772: POP
68773: GO 68787
// end ; end ;
68775: GO 68717
68777: POP
68778: POP
// end ; end ; exit ;
68779: POP
68780: POP
68781: GO 68787
// end ; end ;
68783: GO 68141
68785: POP
68786: POP
// end ;
68787: LD_VAR 0 2
68791: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
68792: LD_INT 0
68794: PPUSH
68795: PPUSH
68796: PPUSH
68797: PPUSH
68798: PPUSH
68799: PPUSH
68800: PPUSH
// if not mc_bases or not skirmish then
68801: LD_EXP 101
68805: NOT
68806: PUSH
68807: LD_EXP 99
68811: NOT
68812: OR
68813: IFFALSE 68817
// exit ;
68815: GO 69082
// btype := GetBType ( building ) ;
68817: LD_ADDR_VAR 0 6
68821: PUSH
68822: LD_VAR 0 1
68826: PPUSH
68827: CALL_OW 266
68831: ST_TO_ADDR
// x := GetX ( building ) ;
68832: LD_ADDR_VAR 0 7
68836: PUSH
68837: LD_VAR 0 1
68841: PPUSH
68842: CALL_OW 250
68846: ST_TO_ADDR
// y := GetY ( building ) ;
68847: LD_ADDR_VAR 0 8
68851: PUSH
68852: LD_VAR 0 1
68856: PPUSH
68857: CALL_OW 251
68861: ST_TO_ADDR
// d := GetDir ( building ) ;
68862: LD_ADDR_VAR 0 9
68866: PUSH
68867: LD_VAR 0 1
68871: PPUSH
68872: CALL_OW 254
68876: ST_TO_ADDR
// for i = 1 to mc_bases do
68877: LD_ADDR_VAR 0 4
68881: PUSH
68882: DOUBLE
68883: LD_INT 1
68885: DEC
68886: ST_TO_ADDR
68887: LD_EXP 101
68891: PUSH
68892: FOR_TO
68893: IFFALSE 69080
// begin if not mc_build_list [ i ] then
68895: LD_EXP 106
68899: PUSH
68900: LD_VAR 0 4
68904: ARRAY
68905: NOT
68906: IFFALSE 68910
// continue ;
68908: GO 68892
// for j := 1 to mc_build_list [ i ] do
68910: LD_ADDR_VAR 0 5
68914: PUSH
68915: DOUBLE
68916: LD_INT 1
68918: DEC
68919: ST_TO_ADDR
68920: LD_EXP 106
68924: PUSH
68925: LD_VAR 0 4
68929: ARRAY
68930: PUSH
68931: FOR_TO
68932: IFFALSE 69076
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
68934: LD_VAR 0 6
68938: PUSH
68939: LD_VAR 0 7
68943: PUSH
68944: LD_VAR 0 8
68948: PUSH
68949: LD_VAR 0 9
68953: PUSH
68954: EMPTY
68955: LIST
68956: LIST
68957: LIST
68958: LIST
68959: PPUSH
68960: LD_EXP 106
68964: PUSH
68965: LD_VAR 0 4
68969: ARRAY
68970: PUSH
68971: LD_VAR 0 5
68975: ARRAY
68976: PPUSH
68977: CALL 80963 0 2
68981: IFFALSE 69074
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
68983: LD_ADDR_EXP 106
68987: PUSH
68988: LD_EXP 106
68992: PPUSH
68993: LD_VAR 0 4
68997: PPUSH
68998: LD_EXP 106
69002: PUSH
69003: LD_VAR 0 4
69007: ARRAY
69008: PPUSH
69009: LD_VAR 0 5
69013: PPUSH
69014: CALL_OW 3
69018: PPUSH
69019: CALL_OW 1
69023: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
69024: LD_ADDR_EXP 108
69028: PUSH
69029: LD_EXP 108
69033: PPUSH
69034: LD_VAR 0 4
69038: PUSH
69039: LD_EXP 108
69043: PUSH
69044: LD_VAR 0 4
69048: ARRAY
69049: PUSH
69050: LD_INT 1
69052: PLUS
69053: PUSH
69054: EMPTY
69055: LIST
69056: LIST
69057: PPUSH
69058: LD_VAR 0 1
69062: PPUSH
69063: CALL 74406 0 3
69067: ST_TO_ADDR
// exit ;
69068: POP
69069: POP
69070: POP
69071: POP
69072: GO 69082
// end ;
69074: GO 68931
69076: POP
69077: POP
// end ;
69078: GO 68892
69080: POP
69081: POP
// end ;
69082: LD_VAR 0 3
69086: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
69087: LD_INT 0
69089: PPUSH
69090: PPUSH
69091: PPUSH
// if not mc_bases or not skirmish then
69092: LD_EXP 101
69096: NOT
69097: PUSH
69098: LD_EXP 99
69102: NOT
69103: OR
69104: IFFALSE 69108
// exit ;
69106: GO 69298
// for i = 1 to mc_bases do
69108: LD_ADDR_VAR 0 4
69112: PUSH
69113: DOUBLE
69114: LD_INT 1
69116: DEC
69117: ST_TO_ADDR
69118: LD_EXP 101
69122: PUSH
69123: FOR_TO
69124: IFFALSE 69211
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
69126: LD_VAR 0 1
69130: PUSH
69131: LD_EXP 109
69135: PUSH
69136: LD_VAR 0 4
69140: ARRAY
69141: IN
69142: PUSH
69143: LD_VAR 0 1
69147: PUSH
69148: LD_EXP 110
69152: PUSH
69153: LD_VAR 0 4
69157: ARRAY
69158: IN
69159: NOT
69160: AND
69161: IFFALSE 69209
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
69163: LD_ADDR_EXP 110
69167: PUSH
69168: LD_EXP 110
69172: PPUSH
69173: LD_VAR 0 4
69177: PUSH
69178: LD_EXP 110
69182: PUSH
69183: LD_VAR 0 4
69187: ARRAY
69188: PUSH
69189: LD_INT 1
69191: PLUS
69192: PUSH
69193: EMPTY
69194: LIST
69195: LIST
69196: PPUSH
69197: LD_VAR 0 1
69201: PPUSH
69202: CALL 74406 0 3
69206: ST_TO_ADDR
// break ;
69207: GO 69211
// end ; end ;
69209: GO 69123
69211: POP
69212: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
69213: LD_VAR 0 1
69217: PPUSH
69218: CALL_OW 257
69222: PUSH
69223: LD_EXP 127
69227: IN
69228: PUSH
69229: LD_VAR 0 1
69233: PPUSH
69234: CALL_OW 266
69238: PUSH
69239: LD_INT 5
69241: EQUAL
69242: AND
69243: PUSH
69244: LD_VAR 0 2
69248: PPUSH
69249: CALL_OW 110
69253: PUSH
69254: LD_INT 18
69256: NONEQUAL
69257: AND
69258: IFFALSE 69298
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
69260: LD_VAR 0 2
69264: PPUSH
69265: CALL_OW 257
69269: PUSH
69270: LD_INT 5
69272: PUSH
69273: LD_INT 8
69275: PUSH
69276: LD_INT 9
69278: PUSH
69279: EMPTY
69280: LIST
69281: LIST
69282: LIST
69283: IN
69284: IFFALSE 69298
// SetClass ( unit , 1 ) ;
69286: LD_VAR 0 2
69290: PPUSH
69291: LD_INT 1
69293: PPUSH
69294: CALL_OW 336
// end ;
69298: LD_VAR 0 3
69302: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
69303: LD_INT 0
69305: PPUSH
69306: PPUSH
// if not mc_bases or not skirmish then
69307: LD_EXP 101
69311: NOT
69312: PUSH
69313: LD_EXP 99
69317: NOT
69318: OR
69319: IFFALSE 69323
// exit ;
69321: GO 69439
// if GetLives ( abandoned_vehicle ) > 250 then
69323: LD_VAR 0 2
69327: PPUSH
69328: CALL_OW 256
69332: PUSH
69333: LD_INT 250
69335: GREATER
69336: IFFALSE 69340
// exit ;
69338: GO 69439
// for i = 1 to mc_bases do
69340: LD_ADDR_VAR 0 6
69344: PUSH
69345: DOUBLE
69346: LD_INT 1
69348: DEC
69349: ST_TO_ADDR
69350: LD_EXP 101
69354: PUSH
69355: FOR_TO
69356: IFFALSE 69437
// begin if driver in mc_bases [ i ] then
69358: LD_VAR 0 1
69362: PUSH
69363: LD_EXP 101
69367: PUSH
69368: LD_VAR 0 6
69372: ARRAY
69373: IN
69374: IFFALSE 69435
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
69376: LD_VAR 0 1
69380: PPUSH
69381: LD_EXP 101
69385: PUSH
69386: LD_VAR 0 6
69390: ARRAY
69391: PPUSH
69392: LD_INT 2
69394: PUSH
69395: LD_INT 30
69397: PUSH
69398: LD_INT 0
69400: PUSH
69401: EMPTY
69402: LIST
69403: LIST
69404: PUSH
69405: LD_INT 30
69407: PUSH
69408: LD_INT 1
69410: PUSH
69411: EMPTY
69412: LIST
69413: LIST
69414: PUSH
69415: EMPTY
69416: LIST
69417: LIST
69418: LIST
69419: PPUSH
69420: CALL_OW 72
69424: PUSH
69425: LD_INT 1
69427: ARRAY
69428: PPUSH
69429: CALL 108012 0 2
// break ;
69433: GO 69437
// end ; end ;
69435: GO 69355
69437: POP
69438: POP
// end ; end_of_file
69439: LD_VAR 0 5
69443: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
69444: LD_INT 0
69446: PPUSH
69447: PPUSH
// if exist_mode then
69448: LD_VAR 0 2
69452: IFFALSE 69477
// unit := CreateCharacter ( prefix & ident ) else
69454: LD_ADDR_VAR 0 5
69458: PUSH
69459: LD_VAR 0 3
69463: PUSH
69464: LD_VAR 0 1
69468: STR
69469: PPUSH
69470: CALL_OW 34
69474: ST_TO_ADDR
69475: GO 69492
// unit := NewCharacter ( ident ) ;
69477: LD_ADDR_VAR 0 5
69481: PUSH
69482: LD_VAR 0 1
69486: PPUSH
69487: CALL_OW 25
69491: ST_TO_ADDR
// result := unit ;
69492: LD_ADDR_VAR 0 4
69496: PUSH
69497: LD_VAR 0 5
69501: ST_TO_ADDR
// end ;
69502: LD_VAR 0 4
69506: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
69507: LD_INT 0
69509: PPUSH
69510: PPUSH
// if not side or not nation then
69511: LD_VAR 0 1
69515: NOT
69516: PUSH
69517: LD_VAR 0 2
69521: NOT
69522: OR
69523: IFFALSE 69527
// exit ;
69525: GO 70295
// case nation of nation_american :
69527: LD_VAR 0 2
69531: PUSH
69532: LD_INT 1
69534: DOUBLE
69535: EQUAL
69536: IFTRUE 69540
69538: GO 69754
69540: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
69541: LD_ADDR_VAR 0 4
69545: PUSH
69546: LD_INT 35
69548: PUSH
69549: LD_INT 45
69551: PUSH
69552: LD_INT 46
69554: PUSH
69555: LD_INT 47
69557: PUSH
69558: LD_INT 82
69560: PUSH
69561: LD_INT 83
69563: PUSH
69564: LD_INT 84
69566: PUSH
69567: LD_INT 85
69569: PUSH
69570: LD_INT 86
69572: PUSH
69573: LD_INT 1
69575: PUSH
69576: LD_INT 2
69578: PUSH
69579: LD_INT 6
69581: PUSH
69582: LD_INT 15
69584: PUSH
69585: LD_INT 16
69587: PUSH
69588: LD_INT 7
69590: PUSH
69591: LD_INT 12
69593: PUSH
69594: LD_INT 13
69596: PUSH
69597: LD_INT 10
69599: PUSH
69600: LD_INT 14
69602: PUSH
69603: LD_INT 20
69605: PUSH
69606: LD_INT 21
69608: PUSH
69609: LD_INT 22
69611: PUSH
69612: LD_INT 25
69614: PUSH
69615: LD_INT 32
69617: PUSH
69618: LD_INT 27
69620: PUSH
69621: LD_INT 36
69623: PUSH
69624: LD_INT 69
69626: PUSH
69627: LD_INT 39
69629: PUSH
69630: LD_INT 34
69632: PUSH
69633: LD_INT 40
69635: PUSH
69636: LD_INT 48
69638: PUSH
69639: LD_INT 49
69641: PUSH
69642: LD_INT 50
69644: PUSH
69645: LD_INT 51
69647: PUSH
69648: LD_INT 52
69650: PUSH
69651: LD_INT 53
69653: PUSH
69654: LD_INT 54
69656: PUSH
69657: LD_INT 55
69659: PUSH
69660: LD_INT 56
69662: PUSH
69663: LD_INT 57
69665: PUSH
69666: LD_INT 58
69668: PUSH
69669: LD_INT 59
69671: PUSH
69672: LD_INT 60
69674: PUSH
69675: LD_INT 61
69677: PUSH
69678: LD_INT 62
69680: PUSH
69681: LD_INT 80
69683: PUSH
69684: LD_INT 82
69686: PUSH
69687: LD_INT 83
69689: PUSH
69690: LD_INT 84
69692: PUSH
69693: LD_INT 85
69695: PUSH
69696: LD_INT 86
69698: PUSH
69699: EMPTY
69700: LIST
69701: LIST
69702: LIST
69703: LIST
69704: LIST
69705: LIST
69706: LIST
69707: LIST
69708: LIST
69709: LIST
69710: LIST
69711: LIST
69712: LIST
69713: LIST
69714: LIST
69715: LIST
69716: LIST
69717: LIST
69718: LIST
69719: LIST
69720: LIST
69721: LIST
69722: LIST
69723: LIST
69724: LIST
69725: LIST
69726: LIST
69727: LIST
69728: LIST
69729: LIST
69730: LIST
69731: LIST
69732: LIST
69733: LIST
69734: LIST
69735: LIST
69736: LIST
69737: LIST
69738: LIST
69739: LIST
69740: LIST
69741: LIST
69742: LIST
69743: LIST
69744: LIST
69745: LIST
69746: LIST
69747: LIST
69748: LIST
69749: LIST
69750: LIST
69751: ST_TO_ADDR
69752: GO 70219
69754: LD_INT 2
69756: DOUBLE
69757: EQUAL
69758: IFTRUE 69762
69760: GO 69988
69762: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
69763: LD_ADDR_VAR 0 4
69767: PUSH
69768: LD_INT 35
69770: PUSH
69771: LD_INT 45
69773: PUSH
69774: LD_INT 46
69776: PUSH
69777: LD_INT 47
69779: PUSH
69780: LD_INT 82
69782: PUSH
69783: LD_INT 83
69785: PUSH
69786: LD_INT 84
69788: PUSH
69789: LD_INT 85
69791: PUSH
69792: LD_INT 87
69794: PUSH
69795: LD_INT 70
69797: PUSH
69798: LD_INT 1
69800: PUSH
69801: LD_INT 11
69803: PUSH
69804: LD_INT 3
69806: PUSH
69807: LD_INT 4
69809: PUSH
69810: LD_INT 5
69812: PUSH
69813: LD_INT 6
69815: PUSH
69816: LD_INT 15
69818: PUSH
69819: LD_INT 18
69821: PUSH
69822: LD_INT 7
69824: PUSH
69825: LD_INT 17
69827: PUSH
69828: LD_INT 8
69830: PUSH
69831: LD_INT 20
69833: PUSH
69834: LD_INT 21
69836: PUSH
69837: LD_INT 22
69839: PUSH
69840: LD_INT 72
69842: PUSH
69843: LD_INT 26
69845: PUSH
69846: LD_INT 69
69848: PUSH
69849: LD_INT 39
69851: PUSH
69852: LD_INT 40
69854: PUSH
69855: LD_INT 41
69857: PUSH
69858: LD_INT 42
69860: PUSH
69861: LD_INT 43
69863: PUSH
69864: LD_INT 48
69866: PUSH
69867: LD_INT 49
69869: PUSH
69870: LD_INT 50
69872: PUSH
69873: LD_INT 51
69875: PUSH
69876: LD_INT 52
69878: PUSH
69879: LD_INT 53
69881: PUSH
69882: LD_INT 54
69884: PUSH
69885: LD_INT 55
69887: PUSH
69888: LD_INT 56
69890: PUSH
69891: LD_INT 60
69893: PUSH
69894: LD_INT 61
69896: PUSH
69897: LD_INT 62
69899: PUSH
69900: LD_INT 66
69902: PUSH
69903: LD_INT 67
69905: PUSH
69906: LD_INT 68
69908: PUSH
69909: LD_INT 81
69911: PUSH
69912: LD_INT 82
69914: PUSH
69915: LD_INT 83
69917: PUSH
69918: LD_INT 84
69920: PUSH
69921: LD_INT 85
69923: PUSH
69924: LD_INT 87
69926: PUSH
69927: LD_INT 88
69929: PUSH
69930: EMPTY
69931: LIST
69932: LIST
69933: LIST
69934: LIST
69935: LIST
69936: LIST
69937: LIST
69938: LIST
69939: LIST
69940: LIST
69941: LIST
69942: LIST
69943: LIST
69944: LIST
69945: LIST
69946: LIST
69947: LIST
69948: LIST
69949: LIST
69950: LIST
69951: LIST
69952: LIST
69953: LIST
69954: LIST
69955: LIST
69956: LIST
69957: LIST
69958: LIST
69959: LIST
69960: LIST
69961: LIST
69962: LIST
69963: LIST
69964: LIST
69965: LIST
69966: LIST
69967: LIST
69968: LIST
69969: LIST
69970: LIST
69971: LIST
69972: LIST
69973: LIST
69974: LIST
69975: LIST
69976: LIST
69977: LIST
69978: LIST
69979: LIST
69980: LIST
69981: LIST
69982: LIST
69983: LIST
69984: LIST
69985: ST_TO_ADDR
69986: GO 70219
69988: LD_INT 3
69990: DOUBLE
69991: EQUAL
69992: IFTRUE 69996
69994: GO 70218
69996: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
69997: LD_ADDR_VAR 0 4
70001: PUSH
70002: LD_INT 46
70004: PUSH
70005: LD_INT 47
70007: PUSH
70008: LD_INT 1
70010: PUSH
70011: LD_INT 2
70013: PUSH
70014: LD_INT 82
70016: PUSH
70017: LD_INT 83
70019: PUSH
70020: LD_INT 84
70022: PUSH
70023: LD_INT 85
70025: PUSH
70026: LD_INT 86
70028: PUSH
70029: LD_INT 11
70031: PUSH
70032: LD_INT 9
70034: PUSH
70035: LD_INT 20
70037: PUSH
70038: LD_INT 19
70040: PUSH
70041: LD_INT 21
70043: PUSH
70044: LD_INT 24
70046: PUSH
70047: LD_INT 22
70049: PUSH
70050: LD_INT 25
70052: PUSH
70053: LD_INT 28
70055: PUSH
70056: LD_INT 29
70058: PUSH
70059: LD_INT 30
70061: PUSH
70062: LD_INT 31
70064: PUSH
70065: LD_INT 37
70067: PUSH
70068: LD_INT 38
70070: PUSH
70071: LD_INT 32
70073: PUSH
70074: LD_INT 27
70076: PUSH
70077: LD_INT 33
70079: PUSH
70080: LD_INT 69
70082: PUSH
70083: LD_INT 39
70085: PUSH
70086: LD_INT 34
70088: PUSH
70089: LD_INT 40
70091: PUSH
70092: LD_INT 71
70094: PUSH
70095: LD_INT 23
70097: PUSH
70098: LD_INT 44
70100: PUSH
70101: LD_INT 48
70103: PUSH
70104: LD_INT 49
70106: PUSH
70107: LD_INT 50
70109: PUSH
70110: LD_INT 51
70112: PUSH
70113: LD_INT 52
70115: PUSH
70116: LD_INT 53
70118: PUSH
70119: LD_INT 54
70121: PUSH
70122: LD_INT 55
70124: PUSH
70125: LD_INT 56
70127: PUSH
70128: LD_INT 57
70130: PUSH
70131: LD_INT 58
70133: PUSH
70134: LD_INT 59
70136: PUSH
70137: LD_INT 63
70139: PUSH
70140: LD_INT 64
70142: PUSH
70143: LD_INT 65
70145: PUSH
70146: LD_INT 82
70148: PUSH
70149: LD_INT 83
70151: PUSH
70152: LD_INT 84
70154: PUSH
70155: LD_INT 85
70157: PUSH
70158: LD_INT 86
70160: PUSH
70161: EMPTY
70162: LIST
70163: LIST
70164: LIST
70165: LIST
70166: LIST
70167: LIST
70168: LIST
70169: LIST
70170: LIST
70171: LIST
70172: LIST
70173: LIST
70174: LIST
70175: LIST
70176: LIST
70177: LIST
70178: LIST
70179: LIST
70180: LIST
70181: LIST
70182: LIST
70183: LIST
70184: LIST
70185: LIST
70186: LIST
70187: LIST
70188: LIST
70189: LIST
70190: LIST
70191: LIST
70192: LIST
70193: LIST
70194: LIST
70195: LIST
70196: LIST
70197: LIST
70198: LIST
70199: LIST
70200: LIST
70201: LIST
70202: LIST
70203: LIST
70204: LIST
70205: LIST
70206: LIST
70207: LIST
70208: LIST
70209: LIST
70210: LIST
70211: LIST
70212: LIST
70213: LIST
70214: LIST
70215: ST_TO_ADDR
70216: GO 70219
70218: POP
// if state > - 1 and state < 3 then
70219: LD_VAR 0 3
70223: PUSH
70224: LD_INT 1
70226: NEG
70227: GREATER
70228: PUSH
70229: LD_VAR 0 3
70233: PUSH
70234: LD_INT 3
70236: LESS
70237: AND
70238: IFFALSE 70295
// for i in result do
70240: LD_ADDR_VAR 0 5
70244: PUSH
70245: LD_VAR 0 4
70249: PUSH
70250: FOR_IN
70251: IFFALSE 70293
// if GetTech ( i , side ) <> state then
70253: LD_VAR 0 5
70257: PPUSH
70258: LD_VAR 0 1
70262: PPUSH
70263: CALL_OW 321
70267: PUSH
70268: LD_VAR 0 3
70272: NONEQUAL
70273: IFFALSE 70291
// result := result diff i ;
70275: LD_ADDR_VAR 0 4
70279: PUSH
70280: LD_VAR 0 4
70284: PUSH
70285: LD_VAR 0 5
70289: DIFF
70290: ST_TO_ADDR
70291: GO 70250
70293: POP
70294: POP
// end ;
70295: LD_VAR 0 4
70299: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
70300: LD_INT 0
70302: PPUSH
70303: PPUSH
70304: PPUSH
// result := true ;
70305: LD_ADDR_VAR 0 3
70309: PUSH
70310: LD_INT 1
70312: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
70313: LD_ADDR_VAR 0 5
70317: PUSH
70318: LD_VAR 0 2
70322: PPUSH
70323: CALL_OW 480
70327: ST_TO_ADDR
// if not tmp then
70328: LD_VAR 0 5
70332: NOT
70333: IFFALSE 70337
// exit ;
70335: GO 70386
// for i in tmp do
70337: LD_ADDR_VAR 0 4
70341: PUSH
70342: LD_VAR 0 5
70346: PUSH
70347: FOR_IN
70348: IFFALSE 70384
// if GetTech ( i , side ) <> state_researched then
70350: LD_VAR 0 4
70354: PPUSH
70355: LD_VAR 0 1
70359: PPUSH
70360: CALL_OW 321
70364: PUSH
70365: LD_INT 2
70367: NONEQUAL
70368: IFFALSE 70382
// begin result := false ;
70370: LD_ADDR_VAR 0 3
70374: PUSH
70375: LD_INT 0
70377: ST_TO_ADDR
// exit ;
70378: POP
70379: POP
70380: GO 70386
// end ;
70382: GO 70347
70384: POP
70385: POP
// end ;
70386: LD_VAR 0 3
70390: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
70391: LD_INT 0
70393: PPUSH
70394: PPUSH
70395: PPUSH
70396: PPUSH
70397: PPUSH
70398: PPUSH
70399: PPUSH
70400: PPUSH
70401: PPUSH
70402: PPUSH
70403: PPUSH
70404: PPUSH
70405: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
70406: LD_VAR 0 1
70410: NOT
70411: PUSH
70412: LD_VAR 0 1
70416: PPUSH
70417: CALL_OW 257
70421: PUSH
70422: LD_INT 9
70424: NONEQUAL
70425: OR
70426: IFFALSE 70430
// exit ;
70428: GO 71003
// side := GetSide ( unit ) ;
70430: LD_ADDR_VAR 0 9
70434: PUSH
70435: LD_VAR 0 1
70439: PPUSH
70440: CALL_OW 255
70444: ST_TO_ADDR
// tech_space := tech_spacanom ;
70445: LD_ADDR_VAR 0 12
70449: PUSH
70450: LD_INT 29
70452: ST_TO_ADDR
// tech_time := tech_taurad ;
70453: LD_ADDR_VAR 0 13
70457: PUSH
70458: LD_INT 28
70460: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
70461: LD_ADDR_VAR 0 11
70465: PUSH
70466: LD_VAR 0 1
70470: PPUSH
70471: CALL_OW 310
70475: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
70476: LD_VAR 0 11
70480: PPUSH
70481: CALL_OW 247
70485: PUSH
70486: LD_INT 2
70488: EQUAL
70489: IFFALSE 70493
// exit ;
70491: GO 71003
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
70493: LD_ADDR_VAR 0 8
70497: PUSH
70498: LD_INT 81
70500: PUSH
70501: LD_VAR 0 9
70505: PUSH
70506: EMPTY
70507: LIST
70508: LIST
70509: PUSH
70510: LD_INT 3
70512: PUSH
70513: LD_INT 21
70515: PUSH
70516: LD_INT 3
70518: PUSH
70519: EMPTY
70520: LIST
70521: LIST
70522: PUSH
70523: EMPTY
70524: LIST
70525: LIST
70526: PUSH
70527: EMPTY
70528: LIST
70529: LIST
70530: PPUSH
70531: CALL_OW 69
70535: ST_TO_ADDR
// if not tmp then
70536: LD_VAR 0 8
70540: NOT
70541: IFFALSE 70545
// exit ;
70543: GO 71003
// if in_unit then
70545: LD_VAR 0 11
70549: IFFALSE 70573
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
70551: LD_ADDR_VAR 0 10
70555: PUSH
70556: LD_VAR 0 8
70560: PPUSH
70561: LD_VAR 0 11
70565: PPUSH
70566: CALL_OW 74
70570: ST_TO_ADDR
70571: GO 70593
// enemy := NearestUnitToUnit ( tmp , unit ) ;
70573: LD_ADDR_VAR 0 10
70577: PUSH
70578: LD_VAR 0 8
70582: PPUSH
70583: LD_VAR 0 1
70587: PPUSH
70588: CALL_OW 74
70592: ST_TO_ADDR
// if not enemy then
70593: LD_VAR 0 10
70597: NOT
70598: IFFALSE 70602
// exit ;
70600: GO 71003
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
70602: LD_VAR 0 11
70606: PUSH
70607: LD_VAR 0 11
70611: PPUSH
70612: LD_VAR 0 10
70616: PPUSH
70617: CALL_OW 296
70621: PUSH
70622: LD_INT 13
70624: GREATER
70625: AND
70626: PUSH
70627: LD_VAR 0 1
70631: PPUSH
70632: LD_VAR 0 10
70636: PPUSH
70637: CALL_OW 296
70641: PUSH
70642: LD_INT 12
70644: GREATER
70645: OR
70646: IFFALSE 70650
// exit ;
70648: GO 71003
// missile := [ 1 ] ;
70650: LD_ADDR_VAR 0 14
70654: PUSH
70655: LD_INT 1
70657: PUSH
70658: EMPTY
70659: LIST
70660: ST_TO_ADDR
// if Researched ( side , tech_space ) then
70661: LD_VAR 0 9
70665: PPUSH
70666: LD_VAR 0 12
70670: PPUSH
70671: CALL_OW 325
70675: IFFALSE 70704
// missile := Replace ( missile , missile + 1 , 2 ) ;
70677: LD_ADDR_VAR 0 14
70681: PUSH
70682: LD_VAR 0 14
70686: PPUSH
70687: LD_VAR 0 14
70691: PUSH
70692: LD_INT 1
70694: PLUS
70695: PPUSH
70696: LD_INT 2
70698: PPUSH
70699: CALL_OW 1
70703: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
70704: LD_VAR 0 9
70708: PPUSH
70709: LD_VAR 0 13
70713: PPUSH
70714: CALL_OW 325
70718: PUSH
70719: LD_VAR 0 10
70723: PPUSH
70724: CALL_OW 255
70728: PPUSH
70729: LD_VAR 0 13
70733: PPUSH
70734: CALL_OW 325
70738: NOT
70739: AND
70740: IFFALSE 70769
// missile := Replace ( missile , missile + 1 , 3 ) ;
70742: LD_ADDR_VAR 0 14
70746: PUSH
70747: LD_VAR 0 14
70751: PPUSH
70752: LD_VAR 0 14
70756: PUSH
70757: LD_INT 1
70759: PLUS
70760: PPUSH
70761: LD_INT 3
70763: PPUSH
70764: CALL_OW 1
70768: ST_TO_ADDR
// if missile < 2 then
70769: LD_VAR 0 14
70773: PUSH
70774: LD_INT 2
70776: LESS
70777: IFFALSE 70781
// exit ;
70779: GO 71003
// x := GetX ( enemy ) ;
70781: LD_ADDR_VAR 0 4
70785: PUSH
70786: LD_VAR 0 10
70790: PPUSH
70791: CALL_OW 250
70795: ST_TO_ADDR
// y := GetY ( enemy ) ;
70796: LD_ADDR_VAR 0 5
70800: PUSH
70801: LD_VAR 0 10
70805: PPUSH
70806: CALL_OW 251
70810: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
70811: LD_ADDR_VAR 0 6
70815: PUSH
70816: LD_VAR 0 4
70820: PUSH
70821: LD_INT 1
70823: NEG
70824: PPUSH
70825: LD_INT 1
70827: PPUSH
70828: CALL_OW 12
70832: PLUS
70833: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
70834: LD_ADDR_VAR 0 7
70838: PUSH
70839: LD_VAR 0 5
70843: PUSH
70844: LD_INT 1
70846: NEG
70847: PPUSH
70848: LD_INT 1
70850: PPUSH
70851: CALL_OW 12
70855: PLUS
70856: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
70857: LD_VAR 0 6
70861: PPUSH
70862: LD_VAR 0 7
70866: PPUSH
70867: CALL_OW 488
70871: NOT
70872: IFFALSE 70894
// begin _x := x ;
70874: LD_ADDR_VAR 0 6
70878: PUSH
70879: LD_VAR 0 4
70883: ST_TO_ADDR
// _y := y ;
70884: LD_ADDR_VAR 0 7
70888: PUSH
70889: LD_VAR 0 5
70893: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
70894: LD_ADDR_VAR 0 3
70898: PUSH
70899: LD_INT 1
70901: PPUSH
70902: LD_VAR 0 14
70906: PPUSH
70907: CALL_OW 12
70911: ST_TO_ADDR
// case i of 1 :
70912: LD_VAR 0 3
70916: PUSH
70917: LD_INT 1
70919: DOUBLE
70920: EQUAL
70921: IFTRUE 70925
70923: GO 70942
70925: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
70926: LD_VAR 0 1
70930: PPUSH
70931: LD_VAR 0 10
70935: PPUSH
70936: CALL_OW 115
70940: GO 71003
70942: LD_INT 2
70944: DOUBLE
70945: EQUAL
70946: IFTRUE 70950
70948: GO 70972
70950: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
70951: LD_VAR 0 1
70955: PPUSH
70956: LD_VAR 0 6
70960: PPUSH
70961: LD_VAR 0 7
70965: PPUSH
70966: CALL_OW 153
70970: GO 71003
70972: LD_INT 3
70974: DOUBLE
70975: EQUAL
70976: IFTRUE 70980
70978: GO 71002
70980: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
70981: LD_VAR 0 1
70985: PPUSH
70986: LD_VAR 0 6
70990: PPUSH
70991: LD_VAR 0 7
70995: PPUSH
70996: CALL_OW 154
71000: GO 71003
71002: POP
// end ;
71003: LD_VAR 0 2
71007: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
71008: LD_INT 0
71010: PPUSH
71011: PPUSH
71012: PPUSH
71013: PPUSH
71014: PPUSH
71015: PPUSH
// if not unit or not building then
71016: LD_VAR 0 1
71020: NOT
71021: PUSH
71022: LD_VAR 0 2
71026: NOT
71027: OR
71028: IFFALSE 71032
// exit ;
71030: GO 71190
// x := GetX ( building ) ;
71032: LD_ADDR_VAR 0 5
71036: PUSH
71037: LD_VAR 0 2
71041: PPUSH
71042: CALL_OW 250
71046: ST_TO_ADDR
// y := GetY ( building ) ;
71047: LD_ADDR_VAR 0 6
71051: PUSH
71052: LD_VAR 0 2
71056: PPUSH
71057: CALL_OW 251
71061: ST_TO_ADDR
// for i = 0 to 5 do
71062: LD_ADDR_VAR 0 4
71066: PUSH
71067: DOUBLE
71068: LD_INT 0
71070: DEC
71071: ST_TO_ADDR
71072: LD_INT 5
71074: PUSH
71075: FOR_TO
71076: IFFALSE 71188
// begin _x := ShiftX ( x , i , 3 ) ;
71078: LD_ADDR_VAR 0 7
71082: PUSH
71083: LD_VAR 0 5
71087: PPUSH
71088: LD_VAR 0 4
71092: PPUSH
71093: LD_INT 3
71095: PPUSH
71096: CALL_OW 272
71100: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
71101: LD_ADDR_VAR 0 8
71105: PUSH
71106: LD_VAR 0 6
71110: PPUSH
71111: LD_VAR 0 4
71115: PPUSH
71116: LD_INT 3
71118: PPUSH
71119: CALL_OW 273
71123: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
71124: LD_VAR 0 7
71128: PPUSH
71129: LD_VAR 0 8
71133: PPUSH
71134: CALL_OW 488
71138: NOT
71139: IFFALSE 71143
// continue ;
71141: GO 71075
// if HexInfo ( _x , _y ) = 0 then
71143: LD_VAR 0 7
71147: PPUSH
71148: LD_VAR 0 8
71152: PPUSH
71153: CALL_OW 428
71157: PUSH
71158: LD_INT 0
71160: EQUAL
71161: IFFALSE 71186
// begin ComMoveXY ( unit , _x , _y ) ;
71163: LD_VAR 0 1
71167: PPUSH
71168: LD_VAR 0 7
71172: PPUSH
71173: LD_VAR 0 8
71177: PPUSH
71178: CALL_OW 111
// exit ;
71182: POP
71183: POP
71184: GO 71190
// end ; end ;
71186: GO 71075
71188: POP
71189: POP
// end ;
71190: LD_VAR 0 3
71194: RET
// export function ScanBase ( side , base_area ) ; begin
71195: LD_INT 0
71197: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
71198: LD_ADDR_VAR 0 3
71202: PUSH
71203: LD_VAR 0 2
71207: PPUSH
71208: LD_INT 81
71210: PUSH
71211: LD_VAR 0 1
71215: PUSH
71216: EMPTY
71217: LIST
71218: LIST
71219: PPUSH
71220: CALL_OW 70
71224: ST_TO_ADDR
// end ;
71225: LD_VAR 0 3
71229: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
71230: LD_INT 0
71232: PPUSH
71233: PPUSH
71234: PPUSH
71235: PPUSH
// result := false ;
71236: LD_ADDR_VAR 0 2
71240: PUSH
71241: LD_INT 0
71243: ST_TO_ADDR
// side := GetSide ( unit ) ;
71244: LD_ADDR_VAR 0 3
71248: PUSH
71249: LD_VAR 0 1
71253: PPUSH
71254: CALL_OW 255
71258: ST_TO_ADDR
// nat := GetNation ( unit ) ;
71259: LD_ADDR_VAR 0 4
71263: PUSH
71264: LD_VAR 0 1
71268: PPUSH
71269: CALL_OW 248
71273: ST_TO_ADDR
// case nat of 1 :
71274: LD_VAR 0 4
71278: PUSH
71279: LD_INT 1
71281: DOUBLE
71282: EQUAL
71283: IFTRUE 71287
71285: GO 71298
71287: POP
// tech := tech_lassight ; 2 :
71288: LD_ADDR_VAR 0 5
71292: PUSH
71293: LD_INT 12
71295: ST_TO_ADDR
71296: GO 71337
71298: LD_INT 2
71300: DOUBLE
71301: EQUAL
71302: IFTRUE 71306
71304: GO 71317
71306: POP
// tech := tech_mortar ; 3 :
71307: LD_ADDR_VAR 0 5
71311: PUSH
71312: LD_INT 41
71314: ST_TO_ADDR
71315: GO 71337
71317: LD_INT 3
71319: DOUBLE
71320: EQUAL
71321: IFTRUE 71325
71323: GO 71336
71325: POP
// tech := tech_bazooka ; end ;
71326: LD_ADDR_VAR 0 5
71330: PUSH
71331: LD_INT 44
71333: ST_TO_ADDR
71334: GO 71337
71336: POP
// if Researched ( side , tech ) then
71337: LD_VAR 0 3
71341: PPUSH
71342: LD_VAR 0 5
71346: PPUSH
71347: CALL_OW 325
71351: IFFALSE 71378
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
71353: LD_ADDR_VAR 0 2
71357: PUSH
71358: LD_INT 5
71360: PUSH
71361: LD_INT 8
71363: PUSH
71364: LD_INT 9
71366: PUSH
71367: EMPTY
71368: LIST
71369: LIST
71370: LIST
71371: PUSH
71372: LD_VAR 0 4
71376: ARRAY
71377: ST_TO_ADDR
// end ;
71378: LD_VAR 0 2
71382: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
71383: LD_INT 0
71385: PPUSH
71386: PPUSH
71387: PPUSH
// if not mines then
71388: LD_VAR 0 2
71392: NOT
71393: IFFALSE 71397
// exit ;
71395: GO 71541
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71397: LD_ADDR_VAR 0 5
71401: PUSH
71402: LD_INT 81
71404: PUSH
71405: LD_VAR 0 1
71409: PUSH
71410: EMPTY
71411: LIST
71412: LIST
71413: PUSH
71414: LD_INT 3
71416: PUSH
71417: LD_INT 21
71419: PUSH
71420: LD_INT 3
71422: PUSH
71423: EMPTY
71424: LIST
71425: LIST
71426: PUSH
71427: EMPTY
71428: LIST
71429: LIST
71430: PUSH
71431: EMPTY
71432: LIST
71433: LIST
71434: PPUSH
71435: CALL_OW 69
71439: ST_TO_ADDR
// for i in mines do
71440: LD_ADDR_VAR 0 4
71444: PUSH
71445: LD_VAR 0 2
71449: PUSH
71450: FOR_IN
71451: IFFALSE 71539
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
71453: LD_VAR 0 4
71457: PUSH
71458: LD_INT 1
71460: ARRAY
71461: PPUSH
71462: LD_VAR 0 4
71466: PUSH
71467: LD_INT 2
71469: ARRAY
71470: PPUSH
71471: CALL_OW 458
71475: NOT
71476: IFFALSE 71480
// continue ;
71478: GO 71450
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
71480: LD_VAR 0 4
71484: PUSH
71485: LD_INT 1
71487: ARRAY
71488: PPUSH
71489: LD_VAR 0 4
71493: PUSH
71494: LD_INT 2
71496: ARRAY
71497: PPUSH
71498: CALL_OW 428
71502: PUSH
71503: LD_VAR 0 5
71507: IN
71508: IFFALSE 71537
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
71510: LD_VAR 0 4
71514: PUSH
71515: LD_INT 1
71517: ARRAY
71518: PPUSH
71519: LD_VAR 0 4
71523: PUSH
71524: LD_INT 2
71526: ARRAY
71527: PPUSH
71528: LD_VAR 0 1
71532: PPUSH
71533: CALL_OW 456
// end ;
71537: GO 71450
71539: POP
71540: POP
// end ;
71541: LD_VAR 0 3
71545: RET
// export function Count ( array ) ; begin
71546: LD_INT 0
71548: PPUSH
// result := array + 0 ;
71549: LD_ADDR_VAR 0 2
71553: PUSH
71554: LD_VAR 0 1
71558: PUSH
71559: LD_INT 0
71561: PLUS
71562: ST_TO_ADDR
// end ;
71563: LD_VAR 0 2
71567: RET
// export function IsEmpty ( building ) ; begin
71568: LD_INT 0
71570: PPUSH
// if not building then
71571: LD_VAR 0 1
71575: NOT
71576: IFFALSE 71580
// exit ;
71578: GO 71623
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
71580: LD_ADDR_VAR 0 2
71584: PUSH
71585: LD_VAR 0 1
71589: PUSH
71590: LD_INT 22
71592: PUSH
71593: LD_VAR 0 1
71597: PPUSH
71598: CALL_OW 255
71602: PUSH
71603: EMPTY
71604: LIST
71605: LIST
71606: PUSH
71607: LD_INT 58
71609: PUSH
71610: EMPTY
71611: LIST
71612: PUSH
71613: EMPTY
71614: LIST
71615: LIST
71616: PPUSH
71617: CALL_OW 69
71621: IN
71622: ST_TO_ADDR
// end ;
71623: LD_VAR 0 2
71627: RET
// export function IsNotFull ( building ) ; var places ; begin
71628: LD_INT 0
71630: PPUSH
71631: PPUSH
// if not building then
71632: LD_VAR 0 1
71636: NOT
71637: IFFALSE 71641
// exit ;
71639: GO 71669
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
71641: LD_ADDR_VAR 0 2
71645: PUSH
71646: LD_VAR 0 1
71650: PPUSH
71651: LD_INT 3
71653: PUSH
71654: LD_INT 62
71656: PUSH
71657: EMPTY
71658: LIST
71659: PUSH
71660: EMPTY
71661: LIST
71662: LIST
71663: PPUSH
71664: CALL_OW 72
71668: ST_TO_ADDR
// end ;
71669: LD_VAR 0 2
71673: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
71674: LD_INT 0
71676: PPUSH
71677: PPUSH
71678: PPUSH
71679: PPUSH
// tmp := [ ] ;
71680: LD_ADDR_VAR 0 3
71684: PUSH
71685: EMPTY
71686: ST_TO_ADDR
// list := [ ] ;
71687: LD_ADDR_VAR 0 5
71691: PUSH
71692: EMPTY
71693: ST_TO_ADDR
// for i = 16 to 25 do
71694: LD_ADDR_VAR 0 4
71698: PUSH
71699: DOUBLE
71700: LD_INT 16
71702: DEC
71703: ST_TO_ADDR
71704: LD_INT 25
71706: PUSH
71707: FOR_TO
71708: IFFALSE 71781
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
71710: LD_ADDR_VAR 0 3
71714: PUSH
71715: LD_VAR 0 3
71719: PUSH
71720: LD_INT 22
71722: PUSH
71723: LD_VAR 0 1
71727: PPUSH
71728: CALL_OW 255
71732: PUSH
71733: EMPTY
71734: LIST
71735: LIST
71736: PUSH
71737: LD_INT 91
71739: PUSH
71740: LD_VAR 0 1
71744: PUSH
71745: LD_INT 6
71747: PUSH
71748: EMPTY
71749: LIST
71750: LIST
71751: LIST
71752: PUSH
71753: LD_INT 30
71755: PUSH
71756: LD_VAR 0 4
71760: PUSH
71761: EMPTY
71762: LIST
71763: LIST
71764: PUSH
71765: EMPTY
71766: LIST
71767: LIST
71768: LIST
71769: PUSH
71770: EMPTY
71771: LIST
71772: PPUSH
71773: CALL_OW 69
71777: ADD
71778: ST_TO_ADDR
71779: GO 71707
71781: POP
71782: POP
// for i = 1 to tmp do
71783: LD_ADDR_VAR 0 4
71787: PUSH
71788: DOUBLE
71789: LD_INT 1
71791: DEC
71792: ST_TO_ADDR
71793: LD_VAR 0 3
71797: PUSH
71798: FOR_TO
71799: IFFALSE 71887
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
71801: LD_ADDR_VAR 0 5
71805: PUSH
71806: LD_VAR 0 5
71810: PUSH
71811: LD_VAR 0 3
71815: PUSH
71816: LD_VAR 0 4
71820: ARRAY
71821: PPUSH
71822: CALL_OW 266
71826: PUSH
71827: LD_VAR 0 3
71831: PUSH
71832: LD_VAR 0 4
71836: ARRAY
71837: PPUSH
71838: CALL_OW 250
71842: PUSH
71843: LD_VAR 0 3
71847: PUSH
71848: LD_VAR 0 4
71852: ARRAY
71853: PPUSH
71854: CALL_OW 251
71858: PUSH
71859: LD_VAR 0 3
71863: PUSH
71864: LD_VAR 0 4
71868: ARRAY
71869: PPUSH
71870: CALL_OW 254
71874: PUSH
71875: EMPTY
71876: LIST
71877: LIST
71878: LIST
71879: LIST
71880: PUSH
71881: EMPTY
71882: LIST
71883: ADD
71884: ST_TO_ADDR
71885: GO 71798
71887: POP
71888: POP
// result := list ;
71889: LD_ADDR_VAR 0 2
71893: PUSH
71894: LD_VAR 0 5
71898: ST_TO_ADDR
// end ;
71899: LD_VAR 0 2
71903: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
71904: LD_INT 0
71906: PPUSH
71907: PPUSH
71908: PPUSH
71909: PPUSH
71910: PPUSH
71911: PPUSH
71912: PPUSH
// if not factory then
71913: LD_VAR 0 1
71917: NOT
71918: IFFALSE 71922
// exit ;
71920: GO 72515
// if control = control_apeman then
71922: LD_VAR 0 4
71926: PUSH
71927: LD_INT 5
71929: EQUAL
71930: IFFALSE 72039
// begin tmp := UnitsInside ( factory ) ;
71932: LD_ADDR_VAR 0 8
71936: PUSH
71937: LD_VAR 0 1
71941: PPUSH
71942: CALL_OW 313
71946: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
71947: LD_VAR 0 8
71951: PPUSH
71952: LD_INT 25
71954: PUSH
71955: LD_INT 12
71957: PUSH
71958: EMPTY
71959: LIST
71960: LIST
71961: PPUSH
71962: CALL_OW 72
71966: NOT
71967: IFFALSE 71977
// control := control_manual ;
71969: LD_ADDR_VAR 0 4
71973: PUSH
71974: LD_INT 1
71976: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
71977: LD_ADDR_VAR 0 8
71981: PUSH
71982: LD_VAR 0 1
71986: PPUSH
71987: CALL 71674 0 1
71991: ST_TO_ADDR
// if tmp then
71992: LD_VAR 0 8
71996: IFFALSE 72039
// begin for i in tmp do
71998: LD_ADDR_VAR 0 7
72002: PUSH
72003: LD_VAR 0 8
72007: PUSH
72008: FOR_IN
72009: IFFALSE 72037
// if i [ 1 ] = b_ext_radio then
72011: LD_VAR 0 7
72015: PUSH
72016: LD_INT 1
72018: ARRAY
72019: PUSH
72020: LD_INT 22
72022: EQUAL
72023: IFFALSE 72035
// begin control := control_remote ;
72025: LD_ADDR_VAR 0 4
72029: PUSH
72030: LD_INT 2
72032: ST_TO_ADDR
// break ;
72033: GO 72037
// end ;
72035: GO 72008
72037: POP
72038: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
72039: LD_VAR 0 1
72043: PPUSH
72044: LD_VAR 0 2
72048: PPUSH
72049: LD_VAR 0 3
72053: PPUSH
72054: LD_VAR 0 4
72058: PPUSH
72059: LD_VAR 0 5
72063: PPUSH
72064: CALL_OW 448
72068: IFFALSE 72103
// begin result := [ chassis , engine , control , weapon ] ;
72070: LD_ADDR_VAR 0 6
72074: PUSH
72075: LD_VAR 0 2
72079: PUSH
72080: LD_VAR 0 3
72084: PUSH
72085: LD_VAR 0 4
72089: PUSH
72090: LD_VAR 0 5
72094: PUSH
72095: EMPTY
72096: LIST
72097: LIST
72098: LIST
72099: LIST
72100: ST_TO_ADDR
// exit ;
72101: GO 72515
// end ; _chassis := AvailableChassisList ( factory ) ;
72103: LD_ADDR_VAR 0 9
72107: PUSH
72108: LD_VAR 0 1
72112: PPUSH
72113: CALL_OW 475
72117: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
72118: LD_ADDR_VAR 0 11
72122: PUSH
72123: LD_VAR 0 1
72127: PPUSH
72128: CALL_OW 476
72132: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
72133: LD_ADDR_VAR 0 12
72137: PUSH
72138: LD_VAR 0 1
72142: PPUSH
72143: CALL_OW 477
72147: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
72148: LD_ADDR_VAR 0 10
72152: PUSH
72153: LD_VAR 0 1
72157: PPUSH
72158: CALL_OW 478
72162: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
72163: LD_VAR 0 9
72167: NOT
72168: PUSH
72169: LD_VAR 0 11
72173: NOT
72174: OR
72175: PUSH
72176: LD_VAR 0 12
72180: NOT
72181: OR
72182: PUSH
72183: LD_VAR 0 10
72187: NOT
72188: OR
72189: IFFALSE 72224
// begin result := [ chassis , engine , control , weapon ] ;
72191: LD_ADDR_VAR 0 6
72195: PUSH
72196: LD_VAR 0 2
72200: PUSH
72201: LD_VAR 0 3
72205: PUSH
72206: LD_VAR 0 4
72210: PUSH
72211: LD_VAR 0 5
72215: PUSH
72216: EMPTY
72217: LIST
72218: LIST
72219: LIST
72220: LIST
72221: ST_TO_ADDR
// exit ;
72222: GO 72515
// end ; if not chassis in _chassis then
72224: LD_VAR 0 2
72228: PUSH
72229: LD_VAR 0 9
72233: IN
72234: NOT
72235: IFFALSE 72261
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
72237: LD_ADDR_VAR 0 2
72241: PUSH
72242: LD_VAR 0 9
72246: PUSH
72247: LD_INT 1
72249: PPUSH
72250: LD_VAR 0 9
72254: PPUSH
72255: CALL_OW 12
72259: ARRAY
72260: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
72261: LD_VAR 0 2
72265: PPUSH
72266: LD_VAR 0 3
72270: PPUSH
72271: CALL 72520 0 2
72275: NOT
72276: IFFALSE 72335
// repeat engine := _engine [ 1 ] ;
72278: LD_ADDR_VAR 0 3
72282: PUSH
72283: LD_VAR 0 11
72287: PUSH
72288: LD_INT 1
72290: ARRAY
72291: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
72292: LD_ADDR_VAR 0 11
72296: PUSH
72297: LD_VAR 0 11
72301: PPUSH
72302: LD_INT 1
72304: PPUSH
72305: CALL_OW 3
72309: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
72310: LD_VAR 0 2
72314: PPUSH
72315: LD_VAR 0 3
72319: PPUSH
72320: CALL 72520 0 2
72324: PUSH
72325: LD_VAR 0 11
72329: PUSH
72330: EMPTY
72331: EQUAL
72332: OR
72333: IFFALSE 72278
// if not control in _control then
72335: LD_VAR 0 4
72339: PUSH
72340: LD_VAR 0 12
72344: IN
72345: NOT
72346: IFFALSE 72372
// control := _control [ rand ( 1 , _control ) ] ;
72348: LD_ADDR_VAR 0 4
72352: PUSH
72353: LD_VAR 0 12
72357: PUSH
72358: LD_INT 1
72360: PPUSH
72361: LD_VAR 0 12
72365: PPUSH
72366: CALL_OW 12
72370: ARRAY
72371: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
72372: LD_VAR 0 2
72376: PPUSH
72377: LD_VAR 0 5
72381: PPUSH
72382: CALL 72740 0 2
72386: NOT
72387: IFFALSE 72446
// repeat weapon := _weapon [ 1 ] ;
72389: LD_ADDR_VAR 0 5
72393: PUSH
72394: LD_VAR 0 10
72398: PUSH
72399: LD_INT 1
72401: ARRAY
72402: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
72403: LD_ADDR_VAR 0 10
72407: PUSH
72408: LD_VAR 0 10
72412: PPUSH
72413: LD_INT 1
72415: PPUSH
72416: CALL_OW 3
72420: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
72421: LD_VAR 0 2
72425: PPUSH
72426: LD_VAR 0 5
72430: PPUSH
72431: CALL 72740 0 2
72435: PUSH
72436: LD_VAR 0 10
72440: PUSH
72441: EMPTY
72442: EQUAL
72443: OR
72444: IFFALSE 72389
// result := [ ] ;
72446: LD_ADDR_VAR 0 6
72450: PUSH
72451: EMPTY
72452: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
72453: LD_VAR 0 1
72457: PPUSH
72458: LD_VAR 0 2
72462: PPUSH
72463: LD_VAR 0 3
72467: PPUSH
72468: LD_VAR 0 4
72472: PPUSH
72473: LD_VAR 0 5
72477: PPUSH
72478: CALL_OW 448
72482: IFFALSE 72515
// result := [ chassis , engine , control , weapon ] ;
72484: LD_ADDR_VAR 0 6
72488: PUSH
72489: LD_VAR 0 2
72493: PUSH
72494: LD_VAR 0 3
72498: PUSH
72499: LD_VAR 0 4
72503: PUSH
72504: LD_VAR 0 5
72508: PUSH
72509: EMPTY
72510: LIST
72511: LIST
72512: LIST
72513: LIST
72514: ST_TO_ADDR
// end ;
72515: LD_VAR 0 6
72519: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
72520: LD_INT 0
72522: PPUSH
// if not chassis or not engine then
72523: LD_VAR 0 1
72527: NOT
72528: PUSH
72529: LD_VAR 0 2
72533: NOT
72534: OR
72535: IFFALSE 72539
// exit ;
72537: GO 72735
// case engine of engine_solar :
72539: LD_VAR 0 2
72543: PUSH
72544: LD_INT 2
72546: DOUBLE
72547: EQUAL
72548: IFTRUE 72552
72550: GO 72590
72552: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
72553: LD_ADDR_VAR 0 3
72557: PUSH
72558: LD_INT 11
72560: PUSH
72561: LD_INT 12
72563: PUSH
72564: LD_INT 13
72566: PUSH
72567: LD_INT 14
72569: PUSH
72570: LD_INT 1
72572: PUSH
72573: LD_INT 2
72575: PUSH
72576: LD_INT 3
72578: PUSH
72579: EMPTY
72580: LIST
72581: LIST
72582: LIST
72583: LIST
72584: LIST
72585: LIST
72586: LIST
72587: ST_TO_ADDR
72588: GO 72719
72590: LD_INT 1
72592: DOUBLE
72593: EQUAL
72594: IFTRUE 72598
72596: GO 72660
72598: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
72599: LD_ADDR_VAR 0 3
72603: PUSH
72604: LD_INT 11
72606: PUSH
72607: LD_INT 12
72609: PUSH
72610: LD_INT 13
72612: PUSH
72613: LD_INT 14
72615: PUSH
72616: LD_INT 1
72618: PUSH
72619: LD_INT 2
72621: PUSH
72622: LD_INT 3
72624: PUSH
72625: LD_INT 4
72627: PUSH
72628: LD_INT 5
72630: PUSH
72631: LD_INT 21
72633: PUSH
72634: LD_INT 23
72636: PUSH
72637: LD_INT 22
72639: PUSH
72640: LD_INT 24
72642: PUSH
72643: EMPTY
72644: LIST
72645: LIST
72646: LIST
72647: LIST
72648: LIST
72649: LIST
72650: LIST
72651: LIST
72652: LIST
72653: LIST
72654: LIST
72655: LIST
72656: LIST
72657: ST_TO_ADDR
72658: GO 72719
72660: LD_INT 3
72662: DOUBLE
72663: EQUAL
72664: IFTRUE 72668
72666: GO 72718
72668: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
72669: LD_ADDR_VAR 0 3
72673: PUSH
72674: LD_INT 13
72676: PUSH
72677: LD_INT 14
72679: PUSH
72680: LD_INT 2
72682: PUSH
72683: LD_INT 3
72685: PUSH
72686: LD_INT 4
72688: PUSH
72689: LD_INT 5
72691: PUSH
72692: LD_INT 21
72694: PUSH
72695: LD_INT 22
72697: PUSH
72698: LD_INT 23
72700: PUSH
72701: LD_INT 24
72703: PUSH
72704: EMPTY
72705: LIST
72706: LIST
72707: LIST
72708: LIST
72709: LIST
72710: LIST
72711: LIST
72712: LIST
72713: LIST
72714: LIST
72715: ST_TO_ADDR
72716: GO 72719
72718: POP
// result := ( chassis in result ) ;
72719: LD_ADDR_VAR 0 3
72723: PUSH
72724: LD_VAR 0 1
72728: PUSH
72729: LD_VAR 0 3
72733: IN
72734: ST_TO_ADDR
// end ;
72735: LD_VAR 0 3
72739: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
72740: LD_INT 0
72742: PPUSH
// if not chassis or not weapon then
72743: LD_VAR 0 1
72747: NOT
72748: PUSH
72749: LD_VAR 0 2
72753: NOT
72754: OR
72755: IFFALSE 72759
// exit ;
72757: GO 73819
// case weapon of us_machine_gun :
72759: LD_VAR 0 2
72763: PUSH
72764: LD_INT 2
72766: DOUBLE
72767: EQUAL
72768: IFTRUE 72772
72770: GO 72802
72772: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
72773: LD_ADDR_VAR 0 3
72777: PUSH
72778: LD_INT 1
72780: PUSH
72781: LD_INT 2
72783: PUSH
72784: LD_INT 3
72786: PUSH
72787: LD_INT 4
72789: PUSH
72790: LD_INT 5
72792: PUSH
72793: EMPTY
72794: LIST
72795: LIST
72796: LIST
72797: LIST
72798: LIST
72799: ST_TO_ADDR
72800: GO 73803
72802: LD_INT 3
72804: DOUBLE
72805: EQUAL
72806: IFTRUE 72810
72808: GO 72840
72810: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
72811: LD_ADDR_VAR 0 3
72815: PUSH
72816: LD_INT 1
72818: PUSH
72819: LD_INT 2
72821: PUSH
72822: LD_INT 3
72824: PUSH
72825: LD_INT 4
72827: PUSH
72828: LD_INT 5
72830: PUSH
72831: EMPTY
72832: LIST
72833: LIST
72834: LIST
72835: LIST
72836: LIST
72837: ST_TO_ADDR
72838: GO 73803
72840: LD_INT 11
72842: DOUBLE
72843: EQUAL
72844: IFTRUE 72848
72846: GO 72878
72848: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
72849: LD_ADDR_VAR 0 3
72853: PUSH
72854: LD_INT 1
72856: PUSH
72857: LD_INT 2
72859: PUSH
72860: LD_INT 3
72862: PUSH
72863: LD_INT 4
72865: PUSH
72866: LD_INT 5
72868: PUSH
72869: EMPTY
72870: LIST
72871: LIST
72872: LIST
72873: LIST
72874: LIST
72875: ST_TO_ADDR
72876: GO 73803
72878: LD_INT 4
72880: DOUBLE
72881: EQUAL
72882: IFTRUE 72886
72884: GO 72912
72886: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
72887: LD_ADDR_VAR 0 3
72891: PUSH
72892: LD_INT 2
72894: PUSH
72895: LD_INT 3
72897: PUSH
72898: LD_INT 4
72900: PUSH
72901: LD_INT 5
72903: PUSH
72904: EMPTY
72905: LIST
72906: LIST
72907: LIST
72908: LIST
72909: ST_TO_ADDR
72910: GO 73803
72912: LD_INT 5
72914: DOUBLE
72915: EQUAL
72916: IFTRUE 72920
72918: GO 72946
72920: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
72921: LD_ADDR_VAR 0 3
72925: PUSH
72926: LD_INT 2
72928: PUSH
72929: LD_INT 3
72931: PUSH
72932: LD_INT 4
72934: PUSH
72935: LD_INT 5
72937: PUSH
72938: EMPTY
72939: LIST
72940: LIST
72941: LIST
72942: LIST
72943: ST_TO_ADDR
72944: GO 73803
72946: LD_INT 9
72948: DOUBLE
72949: EQUAL
72950: IFTRUE 72954
72952: GO 72980
72954: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
72955: LD_ADDR_VAR 0 3
72959: PUSH
72960: LD_INT 2
72962: PUSH
72963: LD_INT 3
72965: PUSH
72966: LD_INT 4
72968: PUSH
72969: LD_INT 5
72971: PUSH
72972: EMPTY
72973: LIST
72974: LIST
72975: LIST
72976: LIST
72977: ST_TO_ADDR
72978: GO 73803
72980: LD_INT 7
72982: DOUBLE
72983: EQUAL
72984: IFTRUE 72988
72986: GO 73014
72988: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
72989: LD_ADDR_VAR 0 3
72993: PUSH
72994: LD_INT 2
72996: PUSH
72997: LD_INT 3
72999: PUSH
73000: LD_INT 4
73002: PUSH
73003: LD_INT 5
73005: PUSH
73006: EMPTY
73007: LIST
73008: LIST
73009: LIST
73010: LIST
73011: ST_TO_ADDR
73012: GO 73803
73014: LD_INT 12
73016: DOUBLE
73017: EQUAL
73018: IFTRUE 73022
73020: GO 73048
73022: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
73023: LD_ADDR_VAR 0 3
73027: PUSH
73028: LD_INT 2
73030: PUSH
73031: LD_INT 3
73033: PUSH
73034: LD_INT 4
73036: PUSH
73037: LD_INT 5
73039: PUSH
73040: EMPTY
73041: LIST
73042: LIST
73043: LIST
73044: LIST
73045: ST_TO_ADDR
73046: GO 73803
73048: LD_INT 13
73050: DOUBLE
73051: EQUAL
73052: IFTRUE 73056
73054: GO 73082
73056: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
73057: LD_ADDR_VAR 0 3
73061: PUSH
73062: LD_INT 2
73064: PUSH
73065: LD_INT 3
73067: PUSH
73068: LD_INT 4
73070: PUSH
73071: LD_INT 5
73073: PUSH
73074: EMPTY
73075: LIST
73076: LIST
73077: LIST
73078: LIST
73079: ST_TO_ADDR
73080: GO 73803
73082: LD_INT 14
73084: DOUBLE
73085: EQUAL
73086: IFTRUE 73090
73088: GO 73108
73090: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
73091: LD_ADDR_VAR 0 3
73095: PUSH
73096: LD_INT 4
73098: PUSH
73099: LD_INT 5
73101: PUSH
73102: EMPTY
73103: LIST
73104: LIST
73105: ST_TO_ADDR
73106: GO 73803
73108: LD_INT 6
73110: DOUBLE
73111: EQUAL
73112: IFTRUE 73116
73114: GO 73134
73116: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
73117: LD_ADDR_VAR 0 3
73121: PUSH
73122: LD_INT 4
73124: PUSH
73125: LD_INT 5
73127: PUSH
73128: EMPTY
73129: LIST
73130: LIST
73131: ST_TO_ADDR
73132: GO 73803
73134: LD_INT 10
73136: DOUBLE
73137: EQUAL
73138: IFTRUE 73142
73140: GO 73160
73142: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
73143: LD_ADDR_VAR 0 3
73147: PUSH
73148: LD_INT 4
73150: PUSH
73151: LD_INT 5
73153: PUSH
73154: EMPTY
73155: LIST
73156: LIST
73157: ST_TO_ADDR
73158: GO 73803
73160: LD_INT 22
73162: DOUBLE
73163: EQUAL
73164: IFTRUE 73168
73166: GO 73194
73168: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
73169: LD_ADDR_VAR 0 3
73173: PUSH
73174: LD_INT 11
73176: PUSH
73177: LD_INT 12
73179: PUSH
73180: LD_INT 13
73182: PUSH
73183: LD_INT 14
73185: PUSH
73186: EMPTY
73187: LIST
73188: LIST
73189: LIST
73190: LIST
73191: ST_TO_ADDR
73192: GO 73803
73194: LD_INT 23
73196: DOUBLE
73197: EQUAL
73198: IFTRUE 73202
73200: GO 73228
73202: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
73203: LD_ADDR_VAR 0 3
73207: PUSH
73208: LD_INT 11
73210: PUSH
73211: LD_INT 12
73213: PUSH
73214: LD_INT 13
73216: PUSH
73217: LD_INT 14
73219: PUSH
73220: EMPTY
73221: LIST
73222: LIST
73223: LIST
73224: LIST
73225: ST_TO_ADDR
73226: GO 73803
73228: LD_INT 24
73230: DOUBLE
73231: EQUAL
73232: IFTRUE 73236
73234: GO 73262
73236: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
73237: LD_ADDR_VAR 0 3
73241: PUSH
73242: LD_INT 11
73244: PUSH
73245: LD_INT 12
73247: PUSH
73248: LD_INT 13
73250: PUSH
73251: LD_INT 14
73253: PUSH
73254: EMPTY
73255: LIST
73256: LIST
73257: LIST
73258: LIST
73259: ST_TO_ADDR
73260: GO 73803
73262: LD_INT 30
73264: DOUBLE
73265: EQUAL
73266: IFTRUE 73270
73268: GO 73296
73270: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
73271: LD_ADDR_VAR 0 3
73275: PUSH
73276: LD_INT 11
73278: PUSH
73279: LD_INT 12
73281: PUSH
73282: LD_INT 13
73284: PUSH
73285: LD_INT 14
73287: PUSH
73288: EMPTY
73289: LIST
73290: LIST
73291: LIST
73292: LIST
73293: ST_TO_ADDR
73294: GO 73803
73296: LD_INT 25
73298: DOUBLE
73299: EQUAL
73300: IFTRUE 73304
73302: GO 73322
73304: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
73305: LD_ADDR_VAR 0 3
73309: PUSH
73310: LD_INT 13
73312: PUSH
73313: LD_INT 14
73315: PUSH
73316: EMPTY
73317: LIST
73318: LIST
73319: ST_TO_ADDR
73320: GO 73803
73322: LD_INT 27
73324: DOUBLE
73325: EQUAL
73326: IFTRUE 73330
73328: GO 73348
73330: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
73331: LD_ADDR_VAR 0 3
73335: PUSH
73336: LD_INT 13
73338: PUSH
73339: LD_INT 14
73341: PUSH
73342: EMPTY
73343: LIST
73344: LIST
73345: ST_TO_ADDR
73346: GO 73803
73348: LD_INT 92
73350: DOUBLE
73351: EQUAL
73352: IFTRUE 73356
73354: GO 73382
73356: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
73357: LD_ADDR_VAR 0 3
73361: PUSH
73362: LD_INT 11
73364: PUSH
73365: LD_INT 12
73367: PUSH
73368: LD_INT 13
73370: PUSH
73371: LD_INT 14
73373: PUSH
73374: EMPTY
73375: LIST
73376: LIST
73377: LIST
73378: LIST
73379: ST_TO_ADDR
73380: GO 73803
73382: LD_INT 28
73384: DOUBLE
73385: EQUAL
73386: IFTRUE 73390
73388: GO 73408
73390: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
73391: LD_ADDR_VAR 0 3
73395: PUSH
73396: LD_INT 13
73398: PUSH
73399: LD_INT 14
73401: PUSH
73402: EMPTY
73403: LIST
73404: LIST
73405: ST_TO_ADDR
73406: GO 73803
73408: LD_INT 29
73410: DOUBLE
73411: EQUAL
73412: IFTRUE 73416
73414: GO 73434
73416: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
73417: LD_ADDR_VAR 0 3
73421: PUSH
73422: LD_INT 13
73424: PUSH
73425: LD_INT 14
73427: PUSH
73428: EMPTY
73429: LIST
73430: LIST
73431: ST_TO_ADDR
73432: GO 73803
73434: LD_INT 31
73436: DOUBLE
73437: EQUAL
73438: IFTRUE 73442
73440: GO 73460
73442: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
73443: LD_ADDR_VAR 0 3
73447: PUSH
73448: LD_INT 13
73450: PUSH
73451: LD_INT 14
73453: PUSH
73454: EMPTY
73455: LIST
73456: LIST
73457: ST_TO_ADDR
73458: GO 73803
73460: LD_INT 26
73462: DOUBLE
73463: EQUAL
73464: IFTRUE 73468
73466: GO 73486
73468: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
73469: LD_ADDR_VAR 0 3
73473: PUSH
73474: LD_INT 13
73476: PUSH
73477: LD_INT 14
73479: PUSH
73480: EMPTY
73481: LIST
73482: LIST
73483: ST_TO_ADDR
73484: GO 73803
73486: LD_INT 42
73488: DOUBLE
73489: EQUAL
73490: IFTRUE 73494
73492: GO 73520
73494: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
73495: LD_ADDR_VAR 0 3
73499: PUSH
73500: LD_INT 21
73502: PUSH
73503: LD_INT 22
73505: PUSH
73506: LD_INT 23
73508: PUSH
73509: LD_INT 24
73511: PUSH
73512: EMPTY
73513: LIST
73514: LIST
73515: LIST
73516: LIST
73517: ST_TO_ADDR
73518: GO 73803
73520: LD_INT 43
73522: DOUBLE
73523: EQUAL
73524: IFTRUE 73528
73526: GO 73554
73528: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
73529: LD_ADDR_VAR 0 3
73533: PUSH
73534: LD_INT 21
73536: PUSH
73537: LD_INT 22
73539: PUSH
73540: LD_INT 23
73542: PUSH
73543: LD_INT 24
73545: PUSH
73546: EMPTY
73547: LIST
73548: LIST
73549: LIST
73550: LIST
73551: ST_TO_ADDR
73552: GO 73803
73554: LD_INT 44
73556: DOUBLE
73557: EQUAL
73558: IFTRUE 73562
73560: GO 73588
73562: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
73563: LD_ADDR_VAR 0 3
73567: PUSH
73568: LD_INT 21
73570: PUSH
73571: LD_INT 22
73573: PUSH
73574: LD_INT 23
73576: PUSH
73577: LD_INT 24
73579: PUSH
73580: EMPTY
73581: LIST
73582: LIST
73583: LIST
73584: LIST
73585: ST_TO_ADDR
73586: GO 73803
73588: LD_INT 45
73590: DOUBLE
73591: EQUAL
73592: IFTRUE 73596
73594: GO 73622
73596: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
73597: LD_ADDR_VAR 0 3
73601: PUSH
73602: LD_INT 21
73604: PUSH
73605: LD_INT 22
73607: PUSH
73608: LD_INT 23
73610: PUSH
73611: LD_INT 24
73613: PUSH
73614: EMPTY
73615: LIST
73616: LIST
73617: LIST
73618: LIST
73619: ST_TO_ADDR
73620: GO 73803
73622: LD_INT 49
73624: DOUBLE
73625: EQUAL
73626: IFTRUE 73630
73628: GO 73656
73630: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
73631: LD_ADDR_VAR 0 3
73635: PUSH
73636: LD_INT 21
73638: PUSH
73639: LD_INT 22
73641: PUSH
73642: LD_INT 23
73644: PUSH
73645: LD_INT 24
73647: PUSH
73648: EMPTY
73649: LIST
73650: LIST
73651: LIST
73652: LIST
73653: ST_TO_ADDR
73654: GO 73803
73656: LD_INT 51
73658: DOUBLE
73659: EQUAL
73660: IFTRUE 73664
73662: GO 73690
73664: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
73665: LD_ADDR_VAR 0 3
73669: PUSH
73670: LD_INT 21
73672: PUSH
73673: LD_INT 22
73675: PUSH
73676: LD_INT 23
73678: PUSH
73679: LD_INT 24
73681: PUSH
73682: EMPTY
73683: LIST
73684: LIST
73685: LIST
73686: LIST
73687: ST_TO_ADDR
73688: GO 73803
73690: LD_INT 52
73692: DOUBLE
73693: EQUAL
73694: IFTRUE 73698
73696: GO 73724
73698: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
73699: LD_ADDR_VAR 0 3
73703: PUSH
73704: LD_INT 21
73706: PUSH
73707: LD_INT 22
73709: PUSH
73710: LD_INT 23
73712: PUSH
73713: LD_INT 24
73715: PUSH
73716: EMPTY
73717: LIST
73718: LIST
73719: LIST
73720: LIST
73721: ST_TO_ADDR
73722: GO 73803
73724: LD_INT 53
73726: DOUBLE
73727: EQUAL
73728: IFTRUE 73732
73730: GO 73750
73732: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
73733: LD_ADDR_VAR 0 3
73737: PUSH
73738: LD_INT 23
73740: PUSH
73741: LD_INT 24
73743: PUSH
73744: EMPTY
73745: LIST
73746: LIST
73747: ST_TO_ADDR
73748: GO 73803
73750: LD_INT 46
73752: DOUBLE
73753: EQUAL
73754: IFTRUE 73758
73756: GO 73776
73758: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
73759: LD_ADDR_VAR 0 3
73763: PUSH
73764: LD_INT 23
73766: PUSH
73767: LD_INT 24
73769: PUSH
73770: EMPTY
73771: LIST
73772: LIST
73773: ST_TO_ADDR
73774: GO 73803
73776: LD_INT 47
73778: DOUBLE
73779: EQUAL
73780: IFTRUE 73784
73782: GO 73802
73784: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
73785: LD_ADDR_VAR 0 3
73789: PUSH
73790: LD_INT 23
73792: PUSH
73793: LD_INT 24
73795: PUSH
73796: EMPTY
73797: LIST
73798: LIST
73799: ST_TO_ADDR
73800: GO 73803
73802: POP
// result := ( chassis in result ) ;
73803: LD_ADDR_VAR 0 3
73807: PUSH
73808: LD_VAR 0 1
73812: PUSH
73813: LD_VAR 0 3
73817: IN
73818: ST_TO_ADDR
// end ;
73819: LD_VAR 0 3
73823: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
73824: LD_INT 0
73826: PPUSH
73827: PPUSH
73828: PPUSH
73829: PPUSH
73830: PPUSH
73831: PPUSH
73832: PPUSH
// result := array ;
73833: LD_ADDR_VAR 0 5
73837: PUSH
73838: LD_VAR 0 1
73842: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
73843: LD_VAR 0 1
73847: NOT
73848: PUSH
73849: LD_VAR 0 2
73853: NOT
73854: OR
73855: PUSH
73856: LD_VAR 0 3
73860: NOT
73861: OR
73862: PUSH
73863: LD_VAR 0 2
73867: PUSH
73868: LD_VAR 0 1
73872: GREATER
73873: OR
73874: PUSH
73875: LD_VAR 0 3
73879: PUSH
73880: LD_VAR 0 1
73884: GREATER
73885: OR
73886: IFFALSE 73890
// exit ;
73888: GO 74186
// if direction then
73890: LD_VAR 0 4
73894: IFFALSE 73958
// begin d := 1 ;
73896: LD_ADDR_VAR 0 9
73900: PUSH
73901: LD_INT 1
73903: ST_TO_ADDR
// if i_from > i_to then
73904: LD_VAR 0 2
73908: PUSH
73909: LD_VAR 0 3
73913: GREATER
73914: IFFALSE 73940
// length := ( array - i_from ) + i_to else
73916: LD_ADDR_VAR 0 11
73920: PUSH
73921: LD_VAR 0 1
73925: PUSH
73926: LD_VAR 0 2
73930: MINUS
73931: PUSH
73932: LD_VAR 0 3
73936: PLUS
73937: ST_TO_ADDR
73938: GO 73956
// length := i_to - i_from ;
73940: LD_ADDR_VAR 0 11
73944: PUSH
73945: LD_VAR 0 3
73949: PUSH
73950: LD_VAR 0 2
73954: MINUS
73955: ST_TO_ADDR
// end else
73956: GO 74019
// begin d := - 1 ;
73958: LD_ADDR_VAR 0 9
73962: PUSH
73963: LD_INT 1
73965: NEG
73966: ST_TO_ADDR
// if i_from > i_to then
73967: LD_VAR 0 2
73971: PUSH
73972: LD_VAR 0 3
73976: GREATER
73977: IFFALSE 73997
// length := i_from - i_to else
73979: LD_ADDR_VAR 0 11
73983: PUSH
73984: LD_VAR 0 2
73988: PUSH
73989: LD_VAR 0 3
73993: MINUS
73994: ST_TO_ADDR
73995: GO 74019
// length := ( array - i_to ) + i_from ;
73997: LD_ADDR_VAR 0 11
74001: PUSH
74002: LD_VAR 0 1
74006: PUSH
74007: LD_VAR 0 3
74011: MINUS
74012: PUSH
74013: LD_VAR 0 2
74017: PLUS
74018: ST_TO_ADDR
// end ; if not length then
74019: LD_VAR 0 11
74023: NOT
74024: IFFALSE 74028
// exit ;
74026: GO 74186
// tmp := array ;
74028: LD_ADDR_VAR 0 10
74032: PUSH
74033: LD_VAR 0 1
74037: ST_TO_ADDR
// for i = 1 to length do
74038: LD_ADDR_VAR 0 6
74042: PUSH
74043: DOUBLE
74044: LD_INT 1
74046: DEC
74047: ST_TO_ADDR
74048: LD_VAR 0 11
74052: PUSH
74053: FOR_TO
74054: IFFALSE 74174
// begin for j = 1 to array do
74056: LD_ADDR_VAR 0 7
74060: PUSH
74061: DOUBLE
74062: LD_INT 1
74064: DEC
74065: ST_TO_ADDR
74066: LD_VAR 0 1
74070: PUSH
74071: FOR_TO
74072: IFFALSE 74160
// begin k := j + d ;
74074: LD_ADDR_VAR 0 8
74078: PUSH
74079: LD_VAR 0 7
74083: PUSH
74084: LD_VAR 0 9
74088: PLUS
74089: ST_TO_ADDR
// if k > array then
74090: LD_VAR 0 8
74094: PUSH
74095: LD_VAR 0 1
74099: GREATER
74100: IFFALSE 74110
// k := 1 ;
74102: LD_ADDR_VAR 0 8
74106: PUSH
74107: LD_INT 1
74109: ST_TO_ADDR
// if not k then
74110: LD_VAR 0 8
74114: NOT
74115: IFFALSE 74127
// k := array ;
74117: LD_ADDR_VAR 0 8
74121: PUSH
74122: LD_VAR 0 1
74126: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
74127: LD_ADDR_VAR 0 10
74131: PUSH
74132: LD_VAR 0 10
74136: PPUSH
74137: LD_VAR 0 8
74141: PPUSH
74142: LD_VAR 0 1
74146: PUSH
74147: LD_VAR 0 7
74151: ARRAY
74152: PPUSH
74153: CALL_OW 1
74157: ST_TO_ADDR
// end ;
74158: GO 74071
74160: POP
74161: POP
// array := tmp ;
74162: LD_ADDR_VAR 0 1
74166: PUSH
74167: LD_VAR 0 10
74171: ST_TO_ADDR
// end ;
74172: GO 74053
74174: POP
74175: POP
// result := array ;
74176: LD_ADDR_VAR 0 5
74180: PUSH
74181: LD_VAR 0 1
74185: ST_TO_ADDR
// end ;
74186: LD_VAR 0 5
74190: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
74191: LD_INT 0
74193: PPUSH
74194: PPUSH
// result := 0 ;
74195: LD_ADDR_VAR 0 3
74199: PUSH
74200: LD_INT 0
74202: ST_TO_ADDR
// if not array or not value in array then
74203: LD_VAR 0 1
74207: NOT
74208: PUSH
74209: LD_VAR 0 2
74213: PUSH
74214: LD_VAR 0 1
74218: IN
74219: NOT
74220: OR
74221: IFFALSE 74225
// exit ;
74223: GO 74279
// for i = 1 to array do
74225: LD_ADDR_VAR 0 4
74229: PUSH
74230: DOUBLE
74231: LD_INT 1
74233: DEC
74234: ST_TO_ADDR
74235: LD_VAR 0 1
74239: PUSH
74240: FOR_TO
74241: IFFALSE 74277
// if value = array [ i ] then
74243: LD_VAR 0 2
74247: PUSH
74248: LD_VAR 0 1
74252: PUSH
74253: LD_VAR 0 4
74257: ARRAY
74258: EQUAL
74259: IFFALSE 74275
// begin result := i ;
74261: LD_ADDR_VAR 0 3
74265: PUSH
74266: LD_VAR 0 4
74270: ST_TO_ADDR
// exit ;
74271: POP
74272: POP
74273: GO 74279
// end ;
74275: GO 74240
74277: POP
74278: POP
// end ;
74279: LD_VAR 0 3
74283: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
74284: LD_INT 0
74286: PPUSH
// vc_chassis := chassis ;
74287: LD_ADDR_OWVAR 37
74291: PUSH
74292: LD_VAR 0 1
74296: ST_TO_ADDR
// vc_engine := engine ;
74297: LD_ADDR_OWVAR 39
74301: PUSH
74302: LD_VAR 0 2
74306: ST_TO_ADDR
// vc_control := control ;
74307: LD_ADDR_OWVAR 38
74311: PUSH
74312: LD_VAR 0 3
74316: ST_TO_ADDR
// vc_weapon := weapon ;
74317: LD_ADDR_OWVAR 40
74321: PUSH
74322: LD_VAR 0 4
74326: ST_TO_ADDR
// vc_fuel_battery := fuel ;
74327: LD_ADDR_OWVAR 41
74331: PUSH
74332: LD_VAR 0 5
74336: ST_TO_ADDR
// end ;
74337: LD_VAR 0 6
74341: RET
// export function WantPlant ( unit ) ; var task ; begin
74342: LD_INT 0
74344: PPUSH
74345: PPUSH
// result := false ;
74346: LD_ADDR_VAR 0 2
74350: PUSH
74351: LD_INT 0
74353: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
74354: LD_ADDR_VAR 0 3
74358: PUSH
74359: LD_VAR 0 1
74363: PPUSH
74364: CALL_OW 437
74368: ST_TO_ADDR
// if task then
74369: LD_VAR 0 3
74373: IFFALSE 74401
// if task [ 1 ] [ 1 ] = p then
74375: LD_VAR 0 3
74379: PUSH
74380: LD_INT 1
74382: ARRAY
74383: PUSH
74384: LD_INT 1
74386: ARRAY
74387: PUSH
74388: LD_STRING p
74390: EQUAL
74391: IFFALSE 74401
// result := true ;
74393: LD_ADDR_VAR 0 2
74397: PUSH
74398: LD_INT 1
74400: ST_TO_ADDR
// end ;
74401: LD_VAR 0 2
74405: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
74406: LD_INT 0
74408: PPUSH
74409: PPUSH
74410: PPUSH
74411: PPUSH
// if pos < 1 then
74412: LD_VAR 0 2
74416: PUSH
74417: LD_INT 1
74419: LESS
74420: IFFALSE 74424
// exit ;
74422: GO 74727
// if pos = 1 then
74424: LD_VAR 0 2
74428: PUSH
74429: LD_INT 1
74431: EQUAL
74432: IFFALSE 74465
// result := Replace ( arr , pos [ 1 ] , value ) else
74434: LD_ADDR_VAR 0 4
74438: PUSH
74439: LD_VAR 0 1
74443: PPUSH
74444: LD_VAR 0 2
74448: PUSH
74449: LD_INT 1
74451: ARRAY
74452: PPUSH
74453: LD_VAR 0 3
74457: PPUSH
74458: CALL_OW 1
74462: ST_TO_ADDR
74463: GO 74727
// begin tmp := arr ;
74465: LD_ADDR_VAR 0 6
74469: PUSH
74470: LD_VAR 0 1
74474: ST_TO_ADDR
// s_arr := [ tmp ] ;
74475: LD_ADDR_VAR 0 7
74479: PUSH
74480: LD_VAR 0 6
74484: PUSH
74485: EMPTY
74486: LIST
74487: ST_TO_ADDR
// for i = 1 to pos - 1 do
74488: LD_ADDR_VAR 0 5
74492: PUSH
74493: DOUBLE
74494: LD_INT 1
74496: DEC
74497: ST_TO_ADDR
74498: LD_VAR 0 2
74502: PUSH
74503: LD_INT 1
74505: MINUS
74506: PUSH
74507: FOR_TO
74508: IFFALSE 74553
// begin tmp := tmp [ pos [ i ] ] ;
74510: LD_ADDR_VAR 0 6
74514: PUSH
74515: LD_VAR 0 6
74519: PUSH
74520: LD_VAR 0 2
74524: PUSH
74525: LD_VAR 0 5
74529: ARRAY
74530: ARRAY
74531: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
74532: LD_ADDR_VAR 0 7
74536: PUSH
74537: LD_VAR 0 7
74541: PUSH
74542: LD_VAR 0 6
74546: PUSH
74547: EMPTY
74548: LIST
74549: ADD
74550: ST_TO_ADDR
// end ;
74551: GO 74507
74553: POP
74554: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
74555: LD_ADDR_VAR 0 6
74559: PUSH
74560: LD_VAR 0 6
74564: PPUSH
74565: LD_VAR 0 2
74569: PUSH
74570: LD_VAR 0 2
74574: ARRAY
74575: PPUSH
74576: LD_VAR 0 3
74580: PPUSH
74581: CALL_OW 1
74585: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
74586: LD_ADDR_VAR 0 7
74590: PUSH
74591: LD_VAR 0 7
74595: PPUSH
74596: LD_VAR 0 7
74600: PPUSH
74601: LD_VAR 0 6
74605: PPUSH
74606: CALL_OW 1
74610: ST_TO_ADDR
// for i = s_arr downto 2 do
74611: LD_ADDR_VAR 0 5
74615: PUSH
74616: DOUBLE
74617: LD_VAR 0 7
74621: INC
74622: ST_TO_ADDR
74623: LD_INT 2
74625: PUSH
74626: FOR_DOWNTO
74627: IFFALSE 74711
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
74629: LD_ADDR_VAR 0 6
74633: PUSH
74634: LD_VAR 0 7
74638: PUSH
74639: LD_VAR 0 5
74643: PUSH
74644: LD_INT 1
74646: MINUS
74647: ARRAY
74648: PPUSH
74649: LD_VAR 0 2
74653: PUSH
74654: LD_VAR 0 5
74658: PUSH
74659: LD_INT 1
74661: MINUS
74662: ARRAY
74663: PPUSH
74664: LD_VAR 0 7
74668: PUSH
74669: LD_VAR 0 5
74673: ARRAY
74674: PPUSH
74675: CALL_OW 1
74679: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
74680: LD_ADDR_VAR 0 7
74684: PUSH
74685: LD_VAR 0 7
74689: PPUSH
74690: LD_VAR 0 5
74694: PUSH
74695: LD_INT 1
74697: MINUS
74698: PPUSH
74699: LD_VAR 0 6
74703: PPUSH
74704: CALL_OW 1
74708: ST_TO_ADDR
// end ;
74709: GO 74626
74711: POP
74712: POP
// result := s_arr [ 1 ] ;
74713: LD_ADDR_VAR 0 4
74717: PUSH
74718: LD_VAR 0 7
74722: PUSH
74723: LD_INT 1
74725: ARRAY
74726: ST_TO_ADDR
// end ; end ;
74727: LD_VAR 0 4
74731: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
74732: LD_INT 0
74734: PPUSH
74735: PPUSH
// if not list then
74736: LD_VAR 0 1
74740: NOT
74741: IFFALSE 74745
// exit ;
74743: GO 74836
// i := list [ pos1 ] ;
74745: LD_ADDR_VAR 0 5
74749: PUSH
74750: LD_VAR 0 1
74754: PUSH
74755: LD_VAR 0 2
74759: ARRAY
74760: ST_TO_ADDR
// if not i then
74761: LD_VAR 0 5
74765: NOT
74766: IFFALSE 74770
// exit ;
74768: GO 74836
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
74770: LD_ADDR_VAR 0 1
74774: PUSH
74775: LD_VAR 0 1
74779: PPUSH
74780: LD_VAR 0 2
74784: PPUSH
74785: LD_VAR 0 1
74789: PUSH
74790: LD_VAR 0 3
74794: ARRAY
74795: PPUSH
74796: CALL_OW 1
74800: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
74801: LD_ADDR_VAR 0 1
74805: PUSH
74806: LD_VAR 0 1
74810: PPUSH
74811: LD_VAR 0 3
74815: PPUSH
74816: LD_VAR 0 5
74820: PPUSH
74821: CALL_OW 1
74825: ST_TO_ADDR
// result := list ;
74826: LD_ADDR_VAR 0 4
74830: PUSH
74831: LD_VAR 0 1
74835: ST_TO_ADDR
// end ;
74836: LD_VAR 0 4
74840: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
74841: LD_INT 0
74843: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
74844: LD_ADDR_VAR 0 5
74848: PUSH
74849: LD_VAR 0 1
74853: PPUSH
74854: CALL_OW 250
74858: PPUSH
74859: LD_VAR 0 1
74863: PPUSH
74864: CALL_OW 251
74868: PPUSH
74869: LD_VAR 0 2
74873: PPUSH
74874: LD_VAR 0 3
74878: PPUSH
74879: LD_VAR 0 4
74883: PPUSH
74884: CALL 75262 0 5
74888: ST_TO_ADDR
// end ;
74889: LD_VAR 0 5
74893: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
74894: LD_INT 0
74896: PPUSH
74897: PPUSH
74898: PPUSH
74899: PPUSH
// if not list or not unit then
74900: LD_VAR 0 2
74904: NOT
74905: PUSH
74906: LD_VAR 0 1
74910: NOT
74911: OR
74912: IFFALSE 74916
// exit ;
74914: GO 75257
// result := [ ] ;
74916: LD_ADDR_VAR 0 5
74920: PUSH
74921: EMPTY
74922: ST_TO_ADDR
// for i in list do
74923: LD_ADDR_VAR 0 6
74927: PUSH
74928: LD_VAR 0 2
74932: PUSH
74933: FOR_IN
74934: IFFALSE 75152
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
74936: LD_ADDR_VAR 0 8
74940: PUSH
74941: LD_VAR 0 1
74945: PPUSH
74946: LD_VAR 0 6
74950: PUSH
74951: LD_INT 1
74953: ARRAY
74954: PPUSH
74955: LD_VAR 0 6
74959: PUSH
74960: LD_INT 2
74962: ARRAY
74963: PPUSH
74964: CALL_OW 297
74968: ST_TO_ADDR
// if not Count ( result ) then
74969: LD_VAR 0 5
74973: PPUSH
74974: CALL 71546 0 1
74978: NOT
74979: IFFALSE 75012
// begin result := Join ( result , [ i , tmp ] ) ;
74981: LD_ADDR_VAR 0 5
74985: PUSH
74986: LD_VAR 0 5
74990: PPUSH
74991: LD_VAR 0 6
74995: PUSH
74996: LD_VAR 0 8
75000: PUSH
75001: EMPTY
75002: LIST
75003: LIST
75004: PPUSH
75005: CALL 107135 0 2
75009: ST_TO_ADDR
// continue ;
75010: GO 74933
// end ; if result [ result ] [ 2 ] <= tmp then
75012: LD_VAR 0 5
75016: PUSH
75017: LD_VAR 0 5
75021: ARRAY
75022: PUSH
75023: LD_INT 2
75025: ARRAY
75026: PUSH
75027: LD_VAR 0 8
75031: LESSEQUAL
75032: IFFALSE 75065
// result := Join ( result , [ i , tmp ] ) else
75034: LD_ADDR_VAR 0 5
75038: PUSH
75039: LD_VAR 0 5
75043: PPUSH
75044: LD_VAR 0 6
75048: PUSH
75049: LD_VAR 0 8
75053: PUSH
75054: EMPTY
75055: LIST
75056: LIST
75057: PPUSH
75058: CALL 107135 0 2
75062: ST_TO_ADDR
75063: GO 75150
// begin for j := 1 to Count ( result ) do
75065: LD_ADDR_VAR 0 7
75069: PUSH
75070: DOUBLE
75071: LD_INT 1
75073: DEC
75074: ST_TO_ADDR
75075: LD_VAR 0 5
75079: PPUSH
75080: CALL 71546 0 1
75084: PUSH
75085: FOR_TO
75086: IFFALSE 75148
// begin if tmp < result [ j ] [ 2 ] then
75088: LD_VAR 0 8
75092: PUSH
75093: LD_VAR 0 5
75097: PUSH
75098: LD_VAR 0 7
75102: ARRAY
75103: PUSH
75104: LD_INT 2
75106: ARRAY
75107: LESS
75108: IFFALSE 75146
// begin result := Insert ( result , j , [ i , tmp ] ) ;
75110: LD_ADDR_VAR 0 5
75114: PUSH
75115: LD_VAR 0 5
75119: PPUSH
75120: LD_VAR 0 7
75124: PPUSH
75125: LD_VAR 0 6
75129: PUSH
75130: LD_VAR 0 8
75134: PUSH
75135: EMPTY
75136: LIST
75137: LIST
75138: PPUSH
75139: CALL_OW 2
75143: ST_TO_ADDR
// break ;
75144: GO 75148
// end ; end ;
75146: GO 75085
75148: POP
75149: POP
// end ; end ;
75150: GO 74933
75152: POP
75153: POP
// if result and not asc then
75154: LD_VAR 0 5
75158: PUSH
75159: LD_VAR 0 3
75163: NOT
75164: AND
75165: IFFALSE 75182
// result := ReverseArray ( result ) ;
75167: LD_ADDR_VAR 0 5
75171: PUSH
75172: LD_VAR 0 5
75176: PPUSH
75177: CALL 102422 0 1
75181: ST_TO_ADDR
// tmp := [ ] ;
75182: LD_ADDR_VAR 0 8
75186: PUSH
75187: EMPTY
75188: ST_TO_ADDR
// if mode then
75189: LD_VAR 0 4
75193: IFFALSE 75257
// begin for i := 1 to result do
75195: LD_ADDR_VAR 0 6
75199: PUSH
75200: DOUBLE
75201: LD_INT 1
75203: DEC
75204: ST_TO_ADDR
75205: LD_VAR 0 5
75209: PUSH
75210: FOR_TO
75211: IFFALSE 75245
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
75213: LD_ADDR_VAR 0 8
75217: PUSH
75218: LD_VAR 0 8
75222: PPUSH
75223: LD_VAR 0 5
75227: PUSH
75228: LD_VAR 0 6
75232: ARRAY
75233: PUSH
75234: LD_INT 1
75236: ARRAY
75237: PPUSH
75238: CALL 107135 0 2
75242: ST_TO_ADDR
75243: GO 75210
75245: POP
75246: POP
// result := tmp ;
75247: LD_ADDR_VAR 0 5
75251: PUSH
75252: LD_VAR 0 8
75256: ST_TO_ADDR
// end ; end ;
75257: LD_VAR 0 5
75261: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
75262: LD_INT 0
75264: PPUSH
75265: PPUSH
75266: PPUSH
75267: PPUSH
// if not list then
75268: LD_VAR 0 3
75272: NOT
75273: IFFALSE 75277
// exit ;
75275: GO 75665
// result := [ ] ;
75277: LD_ADDR_VAR 0 6
75281: PUSH
75282: EMPTY
75283: ST_TO_ADDR
// for i in list do
75284: LD_ADDR_VAR 0 7
75288: PUSH
75289: LD_VAR 0 3
75293: PUSH
75294: FOR_IN
75295: IFFALSE 75497
// begin tmp := GetDistUnitXY ( i , x , y ) ;
75297: LD_ADDR_VAR 0 9
75301: PUSH
75302: LD_VAR 0 7
75306: PPUSH
75307: LD_VAR 0 1
75311: PPUSH
75312: LD_VAR 0 2
75316: PPUSH
75317: CALL_OW 297
75321: ST_TO_ADDR
// if not result then
75322: LD_VAR 0 6
75326: NOT
75327: IFFALSE 75353
// result := [ [ i , tmp ] ] else
75329: LD_ADDR_VAR 0 6
75333: PUSH
75334: LD_VAR 0 7
75338: PUSH
75339: LD_VAR 0 9
75343: PUSH
75344: EMPTY
75345: LIST
75346: LIST
75347: PUSH
75348: EMPTY
75349: LIST
75350: ST_TO_ADDR
75351: GO 75495
// begin if result [ result ] [ 2 ] < tmp then
75353: LD_VAR 0 6
75357: PUSH
75358: LD_VAR 0 6
75362: ARRAY
75363: PUSH
75364: LD_INT 2
75366: ARRAY
75367: PUSH
75368: LD_VAR 0 9
75372: LESS
75373: IFFALSE 75415
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
75375: LD_ADDR_VAR 0 6
75379: PUSH
75380: LD_VAR 0 6
75384: PPUSH
75385: LD_VAR 0 6
75389: PUSH
75390: LD_INT 1
75392: PLUS
75393: PPUSH
75394: LD_VAR 0 7
75398: PUSH
75399: LD_VAR 0 9
75403: PUSH
75404: EMPTY
75405: LIST
75406: LIST
75407: PPUSH
75408: CALL_OW 2
75412: ST_TO_ADDR
75413: GO 75495
// for j = 1 to result do
75415: LD_ADDR_VAR 0 8
75419: PUSH
75420: DOUBLE
75421: LD_INT 1
75423: DEC
75424: ST_TO_ADDR
75425: LD_VAR 0 6
75429: PUSH
75430: FOR_TO
75431: IFFALSE 75493
// begin if tmp < result [ j ] [ 2 ] then
75433: LD_VAR 0 9
75437: PUSH
75438: LD_VAR 0 6
75442: PUSH
75443: LD_VAR 0 8
75447: ARRAY
75448: PUSH
75449: LD_INT 2
75451: ARRAY
75452: LESS
75453: IFFALSE 75491
// begin result := Insert ( result , j , [ i , tmp ] ) ;
75455: LD_ADDR_VAR 0 6
75459: PUSH
75460: LD_VAR 0 6
75464: PPUSH
75465: LD_VAR 0 8
75469: PPUSH
75470: LD_VAR 0 7
75474: PUSH
75475: LD_VAR 0 9
75479: PUSH
75480: EMPTY
75481: LIST
75482: LIST
75483: PPUSH
75484: CALL_OW 2
75488: ST_TO_ADDR
// break ;
75489: GO 75493
// end ; end ;
75491: GO 75430
75493: POP
75494: POP
// end ; end ;
75495: GO 75294
75497: POP
75498: POP
// if result and not asc then
75499: LD_VAR 0 6
75503: PUSH
75504: LD_VAR 0 4
75508: NOT
75509: AND
75510: IFFALSE 75585
// begin tmp := result ;
75512: LD_ADDR_VAR 0 9
75516: PUSH
75517: LD_VAR 0 6
75521: ST_TO_ADDR
// for i = tmp downto 1 do
75522: LD_ADDR_VAR 0 7
75526: PUSH
75527: DOUBLE
75528: LD_VAR 0 9
75532: INC
75533: ST_TO_ADDR
75534: LD_INT 1
75536: PUSH
75537: FOR_DOWNTO
75538: IFFALSE 75583
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
75540: LD_ADDR_VAR 0 6
75544: PUSH
75545: LD_VAR 0 6
75549: PPUSH
75550: LD_VAR 0 9
75554: PUSH
75555: LD_VAR 0 7
75559: MINUS
75560: PUSH
75561: LD_INT 1
75563: PLUS
75564: PPUSH
75565: LD_VAR 0 9
75569: PUSH
75570: LD_VAR 0 7
75574: ARRAY
75575: PPUSH
75576: CALL_OW 1
75580: ST_TO_ADDR
75581: GO 75537
75583: POP
75584: POP
// end ; tmp := [ ] ;
75585: LD_ADDR_VAR 0 9
75589: PUSH
75590: EMPTY
75591: ST_TO_ADDR
// if mode then
75592: LD_VAR 0 5
75596: IFFALSE 75665
// begin for i = 1 to result do
75598: LD_ADDR_VAR 0 7
75602: PUSH
75603: DOUBLE
75604: LD_INT 1
75606: DEC
75607: ST_TO_ADDR
75608: LD_VAR 0 6
75612: PUSH
75613: FOR_TO
75614: IFFALSE 75653
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
75616: LD_ADDR_VAR 0 9
75620: PUSH
75621: LD_VAR 0 9
75625: PPUSH
75626: LD_VAR 0 7
75630: PPUSH
75631: LD_VAR 0 6
75635: PUSH
75636: LD_VAR 0 7
75640: ARRAY
75641: PUSH
75642: LD_INT 1
75644: ARRAY
75645: PPUSH
75646: CALL_OW 1
75650: ST_TO_ADDR
75651: GO 75613
75653: POP
75654: POP
// result := tmp ;
75655: LD_ADDR_VAR 0 6
75659: PUSH
75660: LD_VAR 0 9
75664: ST_TO_ADDR
// end ; end ;
75665: LD_VAR 0 6
75669: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
75670: LD_INT 0
75672: PPUSH
75673: PPUSH
75674: PPUSH
75675: PPUSH
75676: PPUSH
75677: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
75678: LD_ADDR_VAR 0 5
75682: PUSH
75683: LD_INT 0
75685: PUSH
75686: LD_INT 0
75688: PUSH
75689: LD_INT 0
75691: PUSH
75692: EMPTY
75693: PUSH
75694: EMPTY
75695: LIST
75696: LIST
75697: LIST
75698: LIST
75699: ST_TO_ADDR
// if not x or not y then
75700: LD_VAR 0 2
75704: NOT
75705: PUSH
75706: LD_VAR 0 3
75710: NOT
75711: OR
75712: IFFALSE 75716
// exit ;
75714: GO 77366
// if not range then
75716: LD_VAR 0 4
75720: NOT
75721: IFFALSE 75731
// range := 10 ;
75723: LD_ADDR_VAR 0 4
75727: PUSH
75728: LD_INT 10
75730: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
75731: LD_ADDR_VAR 0 8
75735: PUSH
75736: LD_INT 81
75738: PUSH
75739: LD_VAR 0 1
75743: PUSH
75744: EMPTY
75745: LIST
75746: LIST
75747: PUSH
75748: LD_INT 92
75750: PUSH
75751: LD_VAR 0 2
75755: PUSH
75756: LD_VAR 0 3
75760: PUSH
75761: LD_VAR 0 4
75765: PUSH
75766: EMPTY
75767: LIST
75768: LIST
75769: LIST
75770: LIST
75771: PUSH
75772: LD_INT 3
75774: PUSH
75775: LD_INT 21
75777: PUSH
75778: LD_INT 3
75780: PUSH
75781: EMPTY
75782: LIST
75783: LIST
75784: PUSH
75785: EMPTY
75786: LIST
75787: LIST
75788: PUSH
75789: EMPTY
75790: LIST
75791: LIST
75792: LIST
75793: PPUSH
75794: CALL_OW 69
75798: ST_TO_ADDR
// if not tmp then
75799: LD_VAR 0 8
75803: NOT
75804: IFFALSE 75808
// exit ;
75806: GO 77366
// for i in tmp do
75808: LD_ADDR_VAR 0 6
75812: PUSH
75813: LD_VAR 0 8
75817: PUSH
75818: FOR_IN
75819: IFFALSE 77341
// begin points := [ 0 , 0 , 0 ] ;
75821: LD_ADDR_VAR 0 9
75825: PUSH
75826: LD_INT 0
75828: PUSH
75829: LD_INT 0
75831: PUSH
75832: LD_INT 0
75834: PUSH
75835: EMPTY
75836: LIST
75837: LIST
75838: LIST
75839: ST_TO_ADDR
// bpoints := 1 ;
75840: LD_ADDR_VAR 0 10
75844: PUSH
75845: LD_INT 1
75847: ST_TO_ADDR
// case GetType ( i ) of unit_human :
75848: LD_VAR 0 6
75852: PPUSH
75853: CALL_OW 247
75857: PUSH
75858: LD_INT 1
75860: DOUBLE
75861: EQUAL
75862: IFTRUE 75866
75864: GO 76444
75866: POP
// begin if GetClass ( i ) = 1 then
75867: LD_VAR 0 6
75871: PPUSH
75872: CALL_OW 257
75876: PUSH
75877: LD_INT 1
75879: EQUAL
75880: IFFALSE 75901
// points := [ 10 , 5 , 3 ] ;
75882: LD_ADDR_VAR 0 9
75886: PUSH
75887: LD_INT 10
75889: PUSH
75890: LD_INT 5
75892: PUSH
75893: LD_INT 3
75895: PUSH
75896: EMPTY
75897: LIST
75898: LIST
75899: LIST
75900: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
75901: LD_VAR 0 6
75905: PPUSH
75906: CALL_OW 257
75910: PUSH
75911: LD_INT 2
75913: PUSH
75914: LD_INT 3
75916: PUSH
75917: LD_INT 4
75919: PUSH
75920: EMPTY
75921: LIST
75922: LIST
75923: LIST
75924: IN
75925: IFFALSE 75946
// points := [ 3 , 2 , 1 ] ;
75927: LD_ADDR_VAR 0 9
75931: PUSH
75932: LD_INT 3
75934: PUSH
75935: LD_INT 2
75937: PUSH
75938: LD_INT 1
75940: PUSH
75941: EMPTY
75942: LIST
75943: LIST
75944: LIST
75945: ST_TO_ADDR
// if GetClass ( i ) = 5 then
75946: LD_VAR 0 6
75950: PPUSH
75951: CALL_OW 257
75955: PUSH
75956: LD_INT 5
75958: EQUAL
75959: IFFALSE 75980
// points := [ 130 , 5 , 2 ] ;
75961: LD_ADDR_VAR 0 9
75965: PUSH
75966: LD_INT 130
75968: PUSH
75969: LD_INT 5
75971: PUSH
75972: LD_INT 2
75974: PUSH
75975: EMPTY
75976: LIST
75977: LIST
75978: LIST
75979: ST_TO_ADDR
// if GetClass ( i ) = 8 then
75980: LD_VAR 0 6
75984: PPUSH
75985: CALL_OW 257
75989: PUSH
75990: LD_INT 8
75992: EQUAL
75993: IFFALSE 76014
// points := [ 35 , 35 , 30 ] ;
75995: LD_ADDR_VAR 0 9
75999: PUSH
76000: LD_INT 35
76002: PUSH
76003: LD_INT 35
76005: PUSH
76006: LD_INT 30
76008: PUSH
76009: EMPTY
76010: LIST
76011: LIST
76012: LIST
76013: ST_TO_ADDR
// if GetClass ( i ) = 9 then
76014: LD_VAR 0 6
76018: PPUSH
76019: CALL_OW 257
76023: PUSH
76024: LD_INT 9
76026: EQUAL
76027: IFFALSE 76048
// points := [ 20 , 55 , 40 ] ;
76029: LD_ADDR_VAR 0 9
76033: PUSH
76034: LD_INT 20
76036: PUSH
76037: LD_INT 55
76039: PUSH
76040: LD_INT 40
76042: PUSH
76043: EMPTY
76044: LIST
76045: LIST
76046: LIST
76047: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
76048: LD_VAR 0 6
76052: PPUSH
76053: CALL_OW 257
76057: PUSH
76058: LD_INT 12
76060: PUSH
76061: LD_INT 16
76063: PUSH
76064: EMPTY
76065: LIST
76066: LIST
76067: IN
76068: IFFALSE 76089
// points := [ 5 , 3 , 2 ] ;
76070: LD_ADDR_VAR 0 9
76074: PUSH
76075: LD_INT 5
76077: PUSH
76078: LD_INT 3
76080: PUSH
76081: LD_INT 2
76083: PUSH
76084: EMPTY
76085: LIST
76086: LIST
76087: LIST
76088: ST_TO_ADDR
// if GetClass ( i ) = 17 then
76089: LD_VAR 0 6
76093: PPUSH
76094: CALL_OW 257
76098: PUSH
76099: LD_INT 17
76101: EQUAL
76102: IFFALSE 76123
// points := [ 100 , 50 , 75 ] ;
76104: LD_ADDR_VAR 0 9
76108: PUSH
76109: LD_INT 100
76111: PUSH
76112: LD_INT 50
76114: PUSH
76115: LD_INT 75
76117: PUSH
76118: EMPTY
76119: LIST
76120: LIST
76121: LIST
76122: ST_TO_ADDR
// if GetClass ( i ) = 15 then
76123: LD_VAR 0 6
76127: PPUSH
76128: CALL_OW 257
76132: PUSH
76133: LD_INT 15
76135: EQUAL
76136: IFFALSE 76157
// points := [ 10 , 5 , 3 ] ;
76138: LD_ADDR_VAR 0 9
76142: PUSH
76143: LD_INT 10
76145: PUSH
76146: LD_INT 5
76148: PUSH
76149: LD_INT 3
76151: PUSH
76152: EMPTY
76153: LIST
76154: LIST
76155: LIST
76156: ST_TO_ADDR
// if GetClass ( i ) = 14 then
76157: LD_VAR 0 6
76161: PPUSH
76162: CALL_OW 257
76166: PUSH
76167: LD_INT 14
76169: EQUAL
76170: IFFALSE 76191
// points := [ 10 , 0 , 0 ] ;
76172: LD_ADDR_VAR 0 9
76176: PUSH
76177: LD_INT 10
76179: PUSH
76180: LD_INT 0
76182: PUSH
76183: LD_INT 0
76185: PUSH
76186: EMPTY
76187: LIST
76188: LIST
76189: LIST
76190: ST_TO_ADDR
// if GetClass ( i ) = 11 then
76191: LD_VAR 0 6
76195: PPUSH
76196: CALL_OW 257
76200: PUSH
76201: LD_INT 11
76203: EQUAL
76204: IFFALSE 76225
// points := [ 30 , 10 , 5 ] ;
76206: LD_ADDR_VAR 0 9
76210: PUSH
76211: LD_INT 30
76213: PUSH
76214: LD_INT 10
76216: PUSH
76217: LD_INT 5
76219: PUSH
76220: EMPTY
76221: LIST
76222: LIST
76223: LIST
76224: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
76225: LD_VAR 0 1
76229: PPUSH
76230: LD_INT 5
76232: PPUSH
76233: CALL_OW 321
76237: PUSH
76238: LD_INT 2
76240: EQUAL
76241: IFFALSE 76258
// bpoints := bpoints * 1.8 ;
76243: LD_ADDR_VAR 0 10
76247: PUSH
76248: LD_VAR 0 10
76252: PUSH
76253: LD_REAL  1.80000000000000E+0000
76256: MUL
76257: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
76258: LD_VAR 0 6
76262: PPUSH
76263: CALL_OW 257
76267: PUSH
76268: LD_INT 1
76270: PUSH
76271: LD_INT 2
76273: PUSH
76274: LD_INT 3
76276: PUSH
76277: LD_INT 4
76279: PUSH
76280: EMPTY
76281: LIST
76282: LIST
76283: LIST
76284: LIST
76285: IN
76286: PUSH
76287: LD_VAR 0 1
76291: PPUSH
76292: LD_INT 51
76294: PPUSH
76295: CALL_OW 321
76299: PUSH
76300: LD_INT 2
76302: EQUAL
76303: AND
76304: IFFALSE 76321
// bpoints := bpoints * 1.2 ;
76306: LD_ADDR_VAR 0 10
76310: PUSH
76311: LD_VAR 0 10
76315: PUSH
76316: LD_REAL  1.20000000000000E+0000
76319: MUL
76320: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
76321: LD_VAR 0 6
76325: PPUSH
76326: CALL_OW 257
76330: PUSH
76331: LD_INT 5
76333: PUSH
76334: LD_INT 7
76336: PUSH
76337: LD_INT 9
76339: PUSH
76340: EMPTY
76341: LIST
76342: LIST
76343: LIST
76344: IN
76345: PUSH
76346: LD_VAR 0 1
76350: PPUSH
76351: LD_INT 52
76353: PPUSH
76354: CALL_OW 321
76358: PUSH
76359: LD_INT 2
76361: EQUAL
76362: AND
76363: IFFALSE 76380
// bpoints := bpoints * 1.5 ;
76365: LD_ADDR_VAR 0 10
76369: PUSH
76370: LD_VAR 0 10
76374: PUSH
76375: LD_REAL  1.50000000000000E+0000
76378: MUL
76379: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
76380: LD_VAR 0 1
76384: PPUSH
76385: LD_INT 66
76387: PPUSH
76388: CALL_OW 321
76392: PUSH
76393: LD_INT 2
76395: EQUAL
76396: IFFALSE 76413
// bpoints := bpoints * 1.1 ;
76398: LD_ADDR_VAR 0 10
76402: PUSH
76403: LD_VAR 0 10
76407: PUSH
76408: LD_REAL  1.10000000000000E+0000
76411: MUL
76412: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
76413: LD_ADDR_VAR 0 10
76417: PUSH
76418: LD_VAR 0 10
76422: PUSH
76423: LD_VAR 0 6
76427: PPUSH
76428: LD_INT 1
76430: PPUSH
76431: CALL_OW 259
76435: PUSH
76436: LD_REAL  1.15000000000000E+0000
76439: MUL
76440: MUL
76441: ST_TO_ADDR
// end ; unit_vehicle :
76442: GO 77270
76444: LD_INT 2
76446: DOUBLE
76447: EQUAL
76448: IFTRUE 76452
76450: GO 77258
76452: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
76453: LD_VAR 0 6
76457: PPUSH
76458: CALL_OW 264
76462: PUSH
76463: LD_INT 2
76465: PUSH
76466: LD_INT 42
76468: PUSH
76469: LD_INT 24
76471: PUSH
76472: EMPTY
76473: LIST
76474: LIST
76475: LIST
76476: IN
76477: IFFALSE 76498
// points := [ 25 , 5 , 3 ] ;
76479: LD_ADDR_VAR 0 9
76483: PUSH
76484: LD_INT 25
76486: PUSH
76487: LD_INT 5
76489: PUSH
76490: LD_INT 3
76492: PUSH
76493: EMPTY
76494: LIST
76495: LIST
76496: LIST
76497: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
76498: LD_VAR 0 6
76502: PPUSH
76503: CALL_OW 264
76507: PUSH
76508: LD_INT 4
76510: PUSH
76511: LD_INT 43
76513: PUSH
76514: LD_INT 25
76516: PUSH
76517: EMPTY
76518: LIST
76519: LIST
76520: LIST
76521: IN
76522: IFFALSE 76543
// points := [ 40 , 15 , 5 ] ;
76524: LD_ADDR_VAR 0 9
76528: PUSH
76529: LD_INT 40
76531: PUSH
76532: LD_INT 15
76534: PUSH
76535: LD_INT 5
76537: PUSH
76538: EMPTY
76539: LIST
76540: LIST
76541: LIST
76542: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
76543: LD_VAR 0 6
76547: PPUSH
76548: CALL_OW 264
76552: PUSH
76553: LD_INT 3
76555: PUSH
76556: LD_INT 23
76558: PUSH
76559: EMPTY
76560: LIST
76561: LIST
76562: IN
76563: IFFALSE 76584
// points := [ 7 , 25 , 8 ] ;
76565: LD_ADDR_VAR 0 9
76569: PUSH
76570: LD_INT 7
76572: PUSH
76573: LD_INT 25
76575: PUSH
76576: LD_INT 8
76578: PUSH
76579: EMPTY
76580: LIST
76581: LIST
76582: LIST
76583: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
76584: LD_VAR 0 6
76588: PPUSH
76589: CALL_OW 264
76593: PUSH
76594: LD_INT 5
76596: PUSH
76597: LD_INT 27
76599: PUSH
76600: LD_INT 44
76602: PUSH
76603: EMPTY
76604: LIST
76605: LIST
76606: LIST
76607: IN
76608: IFFALSE 76629
// points := [ 14 , 50 , 16 ] ;
76610: LD_ADDR_VAR 0 9
76614: PUSH
76615: LD_INT 14
76617: PUSH
76618: LD_INT 50
76620: PUSH
76621: LD_INT 16
76623: PUSH
76624: EMPTY
76625: LIST
76626: LIST
76627: LIST
76628: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
76629: LD_VAR 0 6
76633: PPUSH
76634: CALL_OW 264
76638: PUSH
76639: LD_INT 6
76641: PUSH
76642: LD_INT 46
76644: PUSH
76645: EMPTY
76646: LIST
76647: LIST
76648: IN
76649: IFFALSE 76670
// points := [ 32 , 120 , 70 ] ;
76651: LD_ADDR_VAR 0 9
76655: PUSH
76656: LD_INT 32
76658: PUSH
76659: LD_INT 120
76661: PUSH
76662: LD_INT 70
76664: PUSH
76665: EMPTY
76666: LIST
76667: LIST
76668: LIST
76669: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
76670: LD_VAR 0 6
76674: PPUSH
76675: CALL_OW 264
76679: PUSH
76680: LD_INT 7
76682: PUSH
76683: LD_INT 28
76685: PUSH
76686: LD_INT 45
76688: PUSH
76689: LD_INT 92
76691: PUSH
76692: EMPTY
76693: LIST
76694: LIST
76695: LIST
76696: LIST
76697: IN
76698: IFFALSE 76719
// points := [ 35 , 20 , 45 ] ;
76700: LD_ADDR_VAR 0 9
76704: PUSH
76705: LD_INT 35
76707: PUSH
76708: LD_INT 20
76710: PUSH
76711: LD_INT 45
76713: PUSH
76714: EMPTY
76715: LIST
76716: LIST
76717: LIST
76718: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
76719: LD_VAR 0 6
76723: PPUSH
76724: CALL_OW 264
76728: PUSH
76729: LD_INT 47
76731: PUSH
76732: EMPTY
76733: LIST
76734: IN
76735: IFFALSE 76756
// points := [ 67 , 45 , 75 ] ;
76737: LD_ADDR_VAR 0 9
76741: PUSH
76742: LD_INT 67
76744: PUSH
76745: LD_INT 45
76747: PUSH
76748: LD_INT 75
76750: PUSH
76751: EMPTY
76752: LIST
76753: LIST
76754: LIST
76755: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
76756: LD_VAR 0 6
76760: PPUSH
76761: CALL_OW 264
76765: PUSH
76766: LD_INT 26
76768: PUSH
76769: EMPTY
76770: LIST
76771: IN
76772: IFFALSE 76793
// points := [ 120 , 30 , 80 ] ;
76774: LD_ADDR_VAR 0 9
76778: PUSH
76779: LD_INT 120
76781: PUSH
76782: LD_INT 30
76784: PUSH
76785: LD_INT 80
76787: PUSH
76788: EMPTY
76789: LIST
76790: LIST
76791: LIST
76792: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
76793: LD_VAR 0 6
76797: PPUSH
76798: CALL_OW 264
76802: PUSH
76803: LD_INT 22
76805: PUSH
76806: EMPTY
76807: LIST
76808: IN
76809: IFFALSE 76830
// points := [ 40 , 1 , 1 ] ;
76811: LD_ADDR_VAR 0 9
76815: PUSH
76816: LD_INT 40
76818: PUSH
76819: LD_INT 1
76821: PUSH
76822: LD_INT 1
76824: PUSH
76825: EMPTY
76826: LIST
76827: LIST
76828: LIST
76829: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
76830: LD_VAR 0 6
76834: PPUSH
76835: CALL_OW 264
76839: PUSH
76840: LD_INT 29
76842: PUSH
76843: EMPTY
76844: LIST
76845: IN
76846: IFFALSE 76867
// points := [ 70 , 200 , 400 ] ;
76848: LD_ADDR_VAR 0 9
76852: PUSH
76853: LD_INT 70
76855: PUSH
76856: LD_INT 200
76858: PUSH
76859: LD_INT 400
76861: PUSH
76862: EMPTY
76863: LIST
76864: LIST
76865: LIST
76866: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
76867: LD_VAR 0 6
76871: PPUSH
76872: CALL_OW 264
76876: PUSH
76877: LD_INT 14
76879: PUSH
76880: LD_INT 53
76882: PUSH
76883: EMPTY
76884: LIST
76885: LIST
76886: IN
76887: IFFALSE 76908
// points := [ 40 , 10 , 20 ] ;
76889: LD_ADDR_VAR 0 9
76893: PUSH
76894: LD_INT 40
76896: PUSH
76897: LD_INT 10
76899: PUSH
76900: LD_INT 20
76902: PUSH
76903: EMPTY
76904: LIST
76905: LIST
76906: LIST
76907: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
76908: LD_VAR 0 6
76912: PPUSH
76913: CALL_OW 264
76917: PUSH
76918: LD_INT 9
76920: PUSH
76921: EMPTY
76922: LIST
76923: IN
76924: IFFALSE 76945
// points := [ 5 , 70 , 20 ] ;
76926: LD_ADDR_VAR 0 9
76930: PUSH
76931: LD_INT 5
76933: PUSH
76934: LD_INT 70
76936: PUSH
76937: LD_INT 20
76939: PUSH
76940: EMPTY
76941: LIST
76942: LIST
76943: LIST
76944: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
76945: LD_VAR 0 6
76949: PPUSH
76950: CALL_OW 264
76954: PUSH
76955: LD_INT 10
76957: PUSH
76958: EMPTY
76959: LIST
76960: IN
76961: IFFALSE 76982
// points := [ 35 , 110 , 70 ] ;
76963: LD_ADDR_VAR 0 9
76967: PUSH
76968: LD_INT 35
76970: PUSH
76971: LD_INT 110
76973: PUSH
76974: LD_INT 70
76976: PUSH
76977: EMPTY
76978: LIST
76979: LIST
76980: LIST
76981: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
76982: LD_VAR 0 6
76986: PPUSH
76987: CALL_OW 265
76991: PUSH
76992: LD_INT 25
76994: EQUAL
76995: IFFALSE 77016
// points := [ 80 , 65 , 100 ] ;
76997: LD_ADDR_VAR 0 9
77001: PUSH
77002: LD_INT 80
77004: PUSH
77005: LD_INT 65
77007: PUSH
77008: LD_INT 100
77010: PUSH
77011: EMPTY
77012: LIST
77013: LIST
77014: LIST
77015: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
77016: LD_VAR 0 6
77020: PPUSH
77021: CALL_OW 263
77025: PUSH
77026: LD_INT 1
77028: EQUAL
77029: IFFALSE 77064
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
77031: LD_ADDR_VAR 0 10
77035: PUSH
77036: LD_VAR 0 10
77040: PUSH
77041: LD_VAR 0 6
77045: PPUSH
77046: CALL_OW 311
77050: PPUSH
77051: LD_INT 3
77053: PPUSH
77054: CALL_OW 259
77058: PUSH
77059: LD_INT 4
77061: MUL
77062: MUL
77063: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
77064: LD_VAR 0 6
77068: PPUSH
77069: CALL_OW 263
77073: PUSH
77074: LD_INT 2
77076: EQUAL
77077: IFFALSE 77128
// begin j := IsControledBy ( i ) ;
77079: LD_ADDR_VAR 0 7
77083: PUSH
77084: LD_VAR 0 6
77088: PPUSH
77089: CALL_OW 312
77093: ST_TO_ADDR
// if j then
77094: LD_VAR 0 7
77098: IFFALSE 77128
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
77100: LD_ADDR_VAR 0 10
77104: PUSH
77105: LD_VAR 0 10
77109: PUSH
77110: LD_VAR 0 7
77114: PPUSH
77115: LD_INT 3
77117: PPUSH
77118: CALL_OW 259
77122: PUSH
77123: LD_INT 3
77125: MUL
77126: MUL
77127: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
77128: LD_VAR 0 6
77132: PPUSH
77133: CALL_OW 264
77137: PUSH
77138: LD_INT 5
77140: PUSH
77141: LD_INT 6
77143: PUSH
77144: LD_INT 46
77146: PUSH
77147: LD_INT 44
77149: PUSH
77150: LD_INT 47
77152: PUSH
77153: LD_INT 45
77155: PUSH
77156: LD_INT 28
77158: PUSH
77159: LD_INT 7
77161: PUSH
77162: LD_INT 27
77164: PUSH
77165: LD_INT 29
77167: PUSH
77168: EMPTY
77169: LIST
77170: LIST
77171: LIST
77172: LIST
77173: LIST
77174: LIST
77175: LIST
77176: LIST
77177: LIST
77178: LIST
77179: IN
77180: PUSH
77181: LD_VAR 0 1
77185: PPUSH
77186: LD_INT 52
77188: PPUSH
77189: CALL_OW 321
77193: PUSH
77194: LD_INT 2
77196: EQUAL
77197: AND
77198: IFFALSE 77215
// bpoints := bpoints * 1.2 ;
77200: LD_ADDR_VAR 0 10
77204: PUSH
77205: LD_VAR 0 10
77209: PUSH
77210: LD_REAL  1.20000000000000E+0000
77213: MUL
77214: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
77215: LD_VAR 0 6
77219: PPUSH
77220: CALL_OW 264
77224: PUSH
77225: LD_INT 6
77227: PUSH
77228: LD_INT 46
77230: PUSH
77231: LD_INT 47
77233: PUSH
77234: EMPTY
77235: LIST
77236: LIST
77237: LIST
77238: IN
77239: IFFALSE 77256
// bpoints := bpoints * 1.2 ;
77241: LD_ADDR_VAR 0 10
77245: PUSH
77246: LD_VAR 0 10
77250: PUSH
77251: LD_REAL  1.20000000000000E+0000
77254: MUL
77255: ST_TO_ADDR
// end ; unit_building :
77256: GO 77270
77258: LD_INT 3
77260: DOUBLE
77261: EQUAL
77262: IFTRUE 77266
77264: GO 77269
77266: POP
// ; end ;
77267: GO 77270
77269: POP
// for j = 1 to 3 do
77270: LD_ADDR_VAR 0 7
77274: PUSH
77275: DOUBLE
77276: LD_INT 1
77278: DEC
77279: ST_TO_ADDR
77280: LD_INT 3
77282: PUSH
77283: FOR_TO
77284: IFFALSE 77337
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
77286: LD_ADDR_VAR 0 5
77290: PUSH
77291: LD_VAR 0 5
77295: PPUSH
77296: LD_VAR 0 7
77300: PPUSH
77301: LD_VAR 0 5
77305: PUSH
77306: LD_VAR 0 7
77310: ARRAY
77311: PUSH
77312: LD_VAR 0 9
77316: PUSH
77317: LD_VAR 0 7
77321: ARRAY
77322: PUSH
77323: LD_VAR 0 10
77327: MUL
77328: PLUS
77329: PPUSH
77330: CALL_OW 1
77334: ST_TO_ADDR
77335: GO 77283
77337: POP
77338: POP
// end ;
77339: GO 75818
77341: POP
77342: POP
// result := Replace ( result , 4 , tmp ) ;
77343: LD_ADDR_VAR 0 5
77347: PUSH
77348: LD_VAR 0 5
77352: PPUSH
77353: LD_INT 4
77355: PPUSH
77356: LD_VAR 0 8
77360: PPUSH
77361: CALL_OW 1
77365: ST_TO_ADDR
// end ;
77366: LD_VAR 0 5
77370: RET
// export function DangerAtRange ( unit , range ) ; begin
77371: LD_INT 0
77373: PPUSH
// if not unit then
77374: LD_VAR 0 1
77378: NOT
77379: IFFALSE 77383
// exit ;
77381: GO 77428
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
77383: LD_ADDR_VAR 0 3
77387: PUSH
77388: LD_VAR 0 1
77392: PPUSH
77393: CALL_OW 255
77397: PPUSH
77398: LD_VAR 0 1
77402: PPUSH
77403: CALL_OW 250
77407: PPUSH
77408: LD_VAR 0 1
77412: PPUSH
77413: CALL_OW 251
77417: PPUSH
77418: LD_VAR 0 2
77422: PPUSH
77423: CALL 75670 0 4
77427: ST_TO_ADDR
// end ;
77428: LD_VAR 0 3
77432: RET
// export function DangerInArea ( side , area ) ; begin
77433: LD_INT 0
77435: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
77436: LD_ADDR_VAR 0 3
77440: PUSH
77441: LD_VAR 0 2
77445: PPUSH
77446: LD_INT 81
77448: PUSH
77449: LD_VAR 0 1
77453: PUSH
77454: EMPTY
77455: LIST
77456: LIST
77457: PPUSH
77458: CALL_OW 70
77462: ST_TO_ADDR
// end ;
77463: LD_VAR 0 3
77467: RET
// export function IsExtension ( b ) ; begin
77468: LD_INT 0
77470: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
77471: LD_ADDR_VAR 0 2
77475: PUSH
77476: LD_VAR 0 1
77480: PUSH
77481: LD_INT 23
77483: PUSH
77484: LD_INT 20
77486: PUSH
77487: LD_INT 22
77489: PUSH
77490: LD_INT 17
77492: PUSH
77493: LD_INT 24
77495: PUSH
77496: LD_INT 21
77498: PUSH
77499: LD_INT 19
77501: PUSH
77502: LD_INT 16
77504: PUSH
77505: LD_INT 25
77507: PUSH
77508: LD_INT 18
77510: PUSH
77511: EMPTY
77512: LIST
77513: LIST
77514: LIST
77515: LIST
77516: LIST
77517: LIST
77518: LIST
77519: LIST
77520: LIST
77521: LIST
77522: IN
77523: ST_TO_ADDR
// end ;
77524: LD_VAR 0 2
77528: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
77529: LD_INT 0
77531: PPUSH
77532: PPUSH
77533: PPUSH
// result := [ ] ;
77534: LD_ADDR_VAR 0 4
77538: PUSH
77539: EMPTY
77540: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
77541: LD_ADDR_VAR 0 5
77545: PUSH
77546: LD_VAR 0 2
77550: PPUSH
77551: LD_INT 21
77553: PUSH
77554: LD_INT 3
77556: PUSH
77557: EMPTY
77558: LIST
77559: LIST
77560: PPUSH
77561: CALL_OW 70
77565: ST_TO_ADDR
// if not tmp then
77566: LD_VAR 0 5
77570: NOT
77571: IFFALSE 77575
// exit ;
77573: GO 77639
// if checkLink then
77575: LD_VAR 0 3
77579: IFFALSE 77629
// begin for i in tmp do
77581: LD_ADDR_VAR 0 6
77585: PUSH
77586: LD_VAR 0 5
77590: PUSH
77591: FOR_IN
77592: IFFALSE 77627
// if GetBase ( i ) <> base then
77594: LD_VAR 0 6
77598: PPUSH
77599: CALL_OW 274
77603: PUSH
77604: LD_VAR 0 1
77608: NONEQUAL
77609: IFFALSE 77625
// ComLinkToBase ( base , i ) ;
77611: LD_VAR 0 1
77615: PPUSH
77616: LD_VAR 0 6
77620: PPUSH
77621: CALL_OW 169
77625: GO 77591
77627: POP
77628: POP
// end ; result := tmp ;
77629: LD_ADDR_VAR 0 4
77633: PUSH
77634: LD_VAR 0 5
77638: ST_TO_ADDR
// end ;
77639: LD_VAR 0 4
77643: RET
// export function ComComplete ( units , b ) ; var i ; begin
77644: LD_INT 0
77646: PPUSH
77647: PPUSH
// if not units then
77648: LD_VAR 0 1
77652: NOT
77653: IFFALSE 77657
// exit ;
77655: GO 77747
// for i in units do
77657: LD_ADDR_VAR 0 4
77661: PUSH
77662: LD_VAR 0 1
77666: PUSH
77667: FOR_IN
77668: IFFALSE 77745
// if BuildingStatus ( b ) = bs_build then
77670: LD_VAR 0 2
77674: PPUSH
77675: CALL_OW 461
77679: PUSH
77680: LD_INT 1
77682: EQUAL
77683: IFFALSE 77743
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
77685: LD_VAR 0 4
77689: PPUSH
77690: LD_STRING h
77692: PUSH
77693: LD_VAR 0 2
77697: PPUSH
77698: CALL_OW 250
77702: PUSH
77703: LD_VAR 0 2
77707: PPUSH
77708: CALL_OW 251
77712: PUSH
77713: LD_VAR 0 2
77717: PUSH
77718: LD_INT 0
77720: PUSH
77721: LD_INT 0
77723: PUSH
77724: LD_INT 0
77726: PUSH
77727: EMPTY
77728: LIST
77729: LIST
77730: LIST
77731: LIST
77732: LIST
77733: LIST
77734: LIST
77735: PUSH
77736: EMPTY
77737: LIST
77738: PPUSH
77739: CALL_OW 446
77743: GO 77667
77745: POP
77746: POP
// end ;
77747: LD_VAR 0 3
77751: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
77752: LD_INT 0
77754: PPUSH
77755: PPUSH
77756: PPUSH
77757: PPUSH
77758: PPUSH
77759: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
77760: LD_VAR 0 1
77764: NOT
77765: PUSH
77766: LD_VAR 0 1
77770: PPUSH
77771: CALL_OW 263
77775: PUSH
77776: LD_INT 2
77778: NONEQUAL
77779: OR
77780: IFFALSE 77784
// exit ;
77782: GO 78100
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
77784: LD_ADDR_VAR 0 6
77788: PUSH
77789: LD_INT 22
77791: PUSH
77792: LD_VAR 0 1
77796: PPUSH
77797: CALL_OW 255
77801: PUSH
77802: EMPTY
77803: LIST
77804: LIST
77805: PUSH
77806: LD_INT 2
77808: PUSH
77809: LD_INT 30
77811: PUSH
77812: LD_INT 36
77814: PUSH
77815: EMPTY
77816: LIST
77817: LIST
77818: PUSH
77819: LD_INT 34
77821: PUSH
77822: LD_INT 31
77824: PUSH
77825: EMPTY
77826: LIST
77827: LIST
77828: PUSH
77829: EMPTY
77830: LIST
77831: LIST
77832: LIST
77833: PUSH
77834: EMPTY
77835: LIST
77836: LIST
77837: PPUSH
77838: CALL_OW 69
77842: ST_TO_ADDR
// if not tmp then
77843: LD_VAR 0 6
77847: NOT
77848: IFFALSE 77852
// exit ;
77850: GO 78100
// result := [ ] ;
77852: LD_ADDR_VAR 0 2
77856: PUSH
77857: EMPTY
77858: ST_TO_ADDR
// for i in tmp do
77859: LD_ADDR_VAR 0 3
77863: PUSH
77864: LD_VAR 0 6
77868: PUSH
77869: FOR_IN
77870: IFFALSE 77941
// begin t := UnitsInside ( i ) ;
77872: LD_ADDR_VAR 0 4
77876: PUSH
77877: LD_VAR 0 3
77881: PPUSH
77882: CALL_OW 313
77886: ST_TO_ADDR
// if t then
77887: LD_VAR 0 4
77891: IFFALSE 77939
// for j in t do
77893: LD_ADDR_VAR 0 7
77897: PUSH
77898: LD_VAR 0 4
77902: PUSH
77903: FOR_IN
77904: IFFALSE 77937
// result := Replace ( result , result + 1 , j ) ;
77906: LD_ADDR_VAR 0 2
77910: PUSH
77911: LD_VAR 0 2
77915: PPUSH
77916: LD_VAR 0 2
77920: PUSH
77921: LD_INT 1
77923: PLUS
77924: PPUSH
77925: LD_VAR 0 7
77929: PPUSH
77930: CALL_OW 1
77934: ST_TO_ADDR
77935: GO 77903
77937: POP
77938: POP
// end ;
77939: GO 77869
77941: POP
77942: POP
// if not result then
77943: LD_VAR 0 2
77947: NOT
77948: IFFALSE 77952
// exit ;
77950: GO 78100
// mech := result [ 1 ] ;
77952: LD_ADDR_VAR 0 5
77956: PUSH
77957: LD_VAR 0 2
77961: PUSH
77962: LD_INT 1
77964: ARRAY
77965: ST_TO_ADDR
// if result > 1 then
77966: LD_VAR 0 2
77970: PUSH
77971: LD_INT 1
77973: GREATER
77974: IFFALSE 78086
// begin for i = 2 to result do
77976: LD_ADDR_VAR 0 3
77980: PUSH
77981: DOUBLE
77982: LD_INT 2
77984: DEC
77985: ST_TO_ADDR
77986: LD_VAR 0 2
77990: PUSH
77991: FOR_TO
77992: IFFALSE 78084
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
77994: LD_ADDR_VAR 0 4
77998: PUSH
77999: LD_VAR 0 2
78003: PUSH
78004: LD_VAR 0 3
78008: ARRAY
78009: PPUSH
78010: LD_INT 3
78012: PPUSH
78013: CALL_OW 259
78017: PUSH
78018: LD_VAR 0 2
78022: PUSH
78023: LD_VAR 0 3
78027: ARRAY
78028: PPUSH
78029: CALL_OW 432
78033: MINUS
78034: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
78035: LD_VAR 0 4
78039: PUSH
78040: LD_VAR 0 5
78044: PPUSH
78045: LD_INT 3
78047: PPUSH
78048: CALL_OW 259
78052: PUSH
78053: LD_VAR 0 5
78057: PPUSH
78058: CALL_OW 432
78062: MINUS
78063: GREATEREQUAL
78064: IFFALSE 78082
// mech := result [ i ] ;
78066: LD_ADDR_VAR 0 5
78070: PUSH
78071: LD_VAR 0 2
78075: PUSH
78076: LD_VAR 0 3
78080: ARRAY
78081: ST_TO_ADDR
// end ;
78082: GO 77991
78084: POP
78085: POP
// end ; ComLinkTo ( vehicle , mech ) ;
78086: LD_VAR 0 1
78090: PPUSH
78091: LD_VAR 0 5
78095: PPUSH
78096: CALL_OW 135
// end ;
78100: LD_VAR 0 2
78104: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
78105: LD_INT 0
78107: PPUSH
78108: PPUSH
78109: PPUSH
78110: PPUSH
78111: PPUSH
78112: PPUSH
78113: PPUSH
78114: PPUSH
78115: PPUSH
78116: PPUSH
78117: PPUSH
78118: PPUSH
78119: PPUSH
// result := [ ] ;
78120: LD_ADDR_VAR 0 7
78124: PUSH
78125: EMPTY
78126: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
78127: LD_VAR 0 1
78131: PPUSH
78132: CALL_OW 266
78136: PUSH
78137: LD_INT 0
78139: PUSH
78140: LD_INT 1
78142: PUSH
78143: EMPTY
78144: LIST
78145: LIST
78146: IN
78147: NOT
78148: IFFALSE 78152
// exit ;
78150: GO 79786
// if name then
78152: LD_VAR 0 3
78156: IFFALSE 78172
// SetBName ( base_dep , name ) ;
78158: LD_VAR 0 1
78162: PPUSH
78163: LD_VAR 0 3
78167: PPUSH
78168: CALL_OW 500
// base := GetBase ( base_dep ) ;
78172: LD_ADDR_VAR 0 15
78176: PUSH
78177: LD_VAR 0 1
78181: PPUSH
78182: CALL_OW 274
78186: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
78187: LD_ADDR_VAR 0 16
78191: PUSH
78192: LD_VAR 0 1
78196: PPUSH
78197: CALL_OW 255
78201: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
78202: LD_ADDR_VAR 0 17
78206: PUSH
78207: LD_VAR 0 1
78211: PPUSH
78212: CALL_OW 248
78216: ST_TO_ADDR
// if sources then
78217: LD_VAR 0 5
78221: IFFALSE 78268
// for i = 1 to 3 do
78223: LD_ADDR_VAR 0 8
78227: PUSH
78228: DOUBLE
78229: LD_INT 1
78231: DEC
78232: ST_TO_ADDR
78233: LD_INT 3
78235: PUSH
78236: FOR_TO
78237: IFFALSE 78266
// AddResourceType ( base , i , sources [ i ] ) ;
78239: LD_VAR 0 15
78243: PPUSH
78244: LD_VAR 0 8
78248: PPUSH
78249: LD_VAR 0 5
78253: PUSH
78254: LD_VAR 0 8
78258: ARRAY
78259: PPUSH
78260: CALL_OW 276
78264: GO 78236
78266: POP
78267: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
78268: LD_ADDR_VAR 0 18
78272: PUSH
78273: LD_VAR 0 15
78277: PPUSH
78278: LD_VAR 0 2
78282: PPUSH
78283: LD_INT 1
78285: PPUSH
78286: CALL 77529 0 3
78290: ST_TO_ADDR
// InitHc ;
78291: CALL_OW 19
// InitUc ;
78295: CALL_OW 18
// uc_side := side ;
78299: LD_ADDR_OWVAR 20
78303: PUSH
78304: LD_VAR 0 16
78308: ST_TO_ADDR
// uc_nation := nation ;
78309: LD_ADDR_OWVAR 21
78313: PUSH
78314: LD_VAR 0 17
78318: ST_TO_ADDR
// if buildings then
78319: LD_VAR 0 18
78323: IFFALSE 79645
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
78325: LD_ADDR_VAR 0 19
78329: PUSH
78330: LD_VAR 0 18
78334: PPUSH
78335: LD_INT 2
78337: PUSH
78338: LD_INT 30
78340: PUSH
78341: LD_INT 29
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: PUSH
78348: LD_INT 30
78350: PUSH
78351: LD_INT 30
78353: PUSH
78354: EMPTY
78355: LIST
78356: LIST
78357: PUSH
78358: EMPTY
78359: LIST
78360: LIST
78361: LIST
78362: PPUSH
78363: CALL_OW 72
78367: ST_TO_ADDR
// if tmp then
78368: LD_VAR 0 19
78372: IFFALSE 78420
// for i in tmp do
78374: LD_ADDR_VAR 0 8
78378: PUSH
78379: LD_VAR 0 19
78383: PUSH
78384: FOR_IN
78385: IFFALSE 78418
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
78387: LD_VAR 0 8
78391: PPUSH
78392: CALL_OW 250
78396: PPUSH
78397: LD_VAR 0 8
78401: PPUSH
78402: CALL_OW 251
78406: PPUSH
78407: LD_VAR 0 16
78411: PPUSH
78412: CALL_OW 441
78416: GO 78384
78418: POP
78419: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
78420: LD_VAR 0 18
78424: PPUSH
78425: LD_INT 2
78427: PUSH
78428: LD_INT 30
78430: PUSH
78431: LD_INT 32
78433: PUSH
78434: EMPTY
78435: LIST
78436: LIST
78437: PUSH
78438: LD_INT 30
78440: PUSH
78441: LD_INT 33
78443: PUSH
78444: EMPTY
78445: LIST
78446: LIST
78447: PUSH
78448: EMPTY
78449: LIST
78450: LIST
78451: LIST
78452: PPUSH
78453: CALL_OW 72
78457: IFFALSE 78545
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
78459: LD_ADDR_VAR 0 8
78463: PUSH
78464: LD_VAR 0 18
78468: PPUSH
78469: LD_INT 2
78471: PUSH
78472: LD_INT 30
78474: PUSH
78475: LD_INT 32
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: PUSH
78482: LD_INT 30
78484: PUSH
78485: LD_INT 33
78487: PUSH
78488: EMPTY
78489: LIST
78490: LIST
78491: PUSH
78492: EMPTY
78493: LIST
78494: LIST
78495: LIST
78496: PPUSH
78497: CALL_OW 72
78501: PUSH
78502: FOR_IN
78503: IFFALSE 78543
// begin if not GetBWeapon ( i ) then
78505: LD_VAR 0 8
78509: PPUSH
78510: CALL_OW 269
78514: NOT
78515: IFFALSE 78541
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
78517: LD_VAR 0 8
78521: PPUSH
78522: LD_VAR 0 8
78526: PPUSH
78527: LD_VAR 0 2
78531: PPUSH
78532: CALL 79791 0 2
78536: PPUSH
78537: CALL_OW 431
// end ;
78541: GO 78502
78543: POP
78544: POP
// end ; for i = 1 to personel do
78545: LD_ADDR_VAR 0 8
78549: PUSH
78550: DOUBLE
78551: LD_INT 1
78553: DEC
78554: ST_TO_ADDR
78555: LD_VAR 0 6
78559: PUSH
78560: FOR_TO
78561: IFFALSE 79625
// begin if i > 4 then
78563: LD_VAR 0 8
78567: PUSH
78568: LD_INT 4
78570: GREATER
78571: IFFALSE 78575
// break ;
78573: GO 79625
// case i of 1 :
78575: LD_VAR 0 8
78579: PUSH
78580: LD_INT 1
78582: DOUBLE
78583: EQUAL
78584: IFTRUE 78588
78586: GO 78668
78588: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
78589: LD_ADDR_VAR 0 12
78593: PUSH
78594: LD_VAR 0 18
78598: PPUSH
78599: LD_INT 22
78601: PUSH
78602: LD_VAR 0 16
78606: PUSH
78607: EMPTY
78608: LIST
78609: LIST
78610: PUSH
78611: LD_INT 58
78613: PUSH
78614: EMPTY
78615: LIST
78616: PUSH
78617: LD_INT 2
78619: PUSH
78620: LD_INT 30
78622: PUSH
78623: LD_INT 32
78625: PUSH
78626: EMPTY
78627: LIST
78628: LIST
78629: PUSH
78630: LD_INT 30
78632: PUSH
78633: LD_INT 4
78635: PUSH
78636: EMPTY
78637: LIST
78638: LIST
78639: PUSH
78640: LD_INT 30
78642: PUSH
78643: LD_INT 5
78645: PUSH
78646: EMPTY
78647: LIST
78648: LIST
78649: PUSH
78650: EMPTY
78651: LIST
78652: LIST
78653: LIST
78654: LIST
78655: PUSH
78656: EMPTY
78657: LIST
78658: LIST
78659: LIST
78660: PPUSH
78661: CALL_OW 72
78665: ST_TO_ADDR
78666: GO 78890
78668: LD_INT 2
78670: DOUBLE
78671: EQUAL
78672: IFTRUE 78676
78674: GO 78738
78676: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
78677: LD_ADDR_VAR 0 12
78681: PUSH
78682: LD_VAR 0 18
78686: PPUSH
78687: LD_INT 22
78689: PUSH
78690: LD_VAR 0 16
78694: PUSH
78695: EMPTY
78696: LIST
78697: LIST
78698: PUSH
78699: LD_INT 2
78701: PUSH
78702: LD_INT 30
78704: PUSH
78705: LD_INT 0
78707: PUSH
78708: EMPTY
78709: LIST
78710: LIST
78711: PUSH
78712: LD_INT 30
78714: PUSH
78715: LD_INT 1
78717: PUSH
78718: EMPTY
78719: LIST
78720: LIST
78721: PUSH
78722: EMPTY
78723: LIST
78724: LIST
78725: LIST
78726: PUSH
78727: EMPTY
78728: LIST
78729: LIST
78730: PPUSH
78731: CALL_OW 72
78735: ST_TO_ADDR
78736: GO 78890
78738: LD_INT 3
78740: DOUBLE
78741: EQUAL
78742: IFTRUE 78746
78744: GO 78808
78746: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
78747: LD_ADDR_VAR 0 12
78751: PUSH
78752: LD_VAR 0 18
78756: PPUSH
78757: LD_INT 22
78759: PUSH
78760: LD_VAR 0 16
78764: PUSH
78765: EMPTY
78766: LIST
78767: LIST
78768: PUSH
78769: LD_INT 2
78771: PUSH
78772: LD_INT 30
78774: PUSH
78775: LD_INT 2
78777: PUSH
78778: EMPTY
78779: LIST
78780: LIST
78781: PUSH
78782: LD_INT 30
78784: PUSH
78785: LD_INT 3
78787: PUSH
78788: EMPTY
78789: LIST
78790: LIST
78791: PUSH
78792: EMPTY
78793: LIST
78794: LIST
78795: LIST
78796: PUSH
78797: EMPTY
78798: LIST
78799: LIST
78800: PPUSH
78801: CALL_OW 72
78805: ST_TO_ADDR
78806: GO 78890
78808: LD_INT 4
78810: DOUBLE
78811: EQUAL
78812: IFTRUE 78816
78814: GO 78889
78816: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
78817: LD_ADDR_VAR 0 12
78821: PUSH
78822: LD_VAR 0 18
78826: PPUSH
78827: LD_INT 22
78829: PUSH
78830: LD_VAR 0 16
78834: PUSH
78835: EMPTY
78836: LIST
78837: LIST
78838: PUSH
78839: LD_INT 2
78841: PUSH
78842: LD_INT 30
78844: PUSH
78845: LD_INT 6
78847: PUSH
78848: EMPTY
78849: LIST
78850: LIST
78851: PUSH
78852: LD_INT 30
78854: PUSH
78855: LD_INT 7
78857: PUSH
78858: EMPTY
78859: LIST
78860: LIST
78861: PUSH
78862: LD_INT 30
78864: PUSH
78865: LD_INT 8
78867: PUSH
78868: EMPTY
78869: LIST
78870: LIST
78871: PUSH
78872: EMPTY
78873: LIST
78874: LIST
78875: LIST
78876: LIST
78877: PUSH
78878: EMPTY
78879: LIST
78880: LIST
78881: PPUSH
78882: CALL_OW 72
78886: ST_TO_ADDR
78887: GO 78890
78889: POP
// if i = 1 then
78890: LD_VAR 0 8
78894: PUSH
78895: LD_INT 1
78897: EQUAL
78898: IFFALSE 79009
// begin tmp := [ ] ;
78900: LD_ADDR_VAR 0 19
78904: PUSH
78905: EMPTY
78906: ST_TO_ADDR
// for j in f do
78907: LD_ADDR_VAR 0 9
78911: PUSH
78912: LD_VAR 0 12
78916: PUSH
78917: FOR_IN
78918: IFFALSE 78991
// if GetBType ( j ) = b_bunker then
78920: LD_VAR 0 9
78924: PPUSH
78925: CALL_OW 266
78929: PUSH
78930: LD_INT 32
78932: EQUAL
78933: IFFALSE 78960
// tmp := Insert ( tmp , 1 , j ) else
78935: LD_ADDR_VAR 0 19
78939: PUSH
78940: LD_VAR 0 19
78944: PPUSH
78945: LD_INT 1
78947: PPUSH
78948: LD_VAR 0 9
78952: PPUSH
78953: CALL_OW 2
78957: ST_TO_ADDR
78958: GO 78989
// tmp := Insert ( tmp , tmp + 1 , j ) ;
78960: LD_ADDR_VAR 0 19
78964: PUSH
78965: LD_VAR 0 19
78969: PPUSH
78970: LD_VAR 0 19
78974: PUSH
78975: LD_INT 1
78977: PLUS
78978: PPUSH
78979: LD_VAR 0 9
78983: PPUSH
78984: CALL_OW 2
78988: ST_TO_ADDR
78989: GO 78917
78991: POP
78992: POP
// if tmp then
78993: LD_VAR 0 19
78997: IFFALSE 79009
// f := tmp ;
78999: LD_ADDR_VAR 0 12
79003: PUSH
79004: LD_VAR 0 19
79008: ST_TO_ADDR
// end ; x := personel [ i ] ;
79009: LD_ADDR_VAR 0 13
79013: PUSH
79014: LD_VAR 0 6
79018: PUSH
79019: LD_VAR 0 8
79023: ARRAY
79024: ST_TO_ADDR
// if x = - 1 then
79025: LD_VAR 0 13
79029: PUSH
79030: LD_INT 1
79032: NEG
79033: EQUAL
79034: IFFALSE 79243
// begin for j in f do
79036: LD_ADDR_VAR 0 9
79040: PUSH
79041: LD_VAR 0 12
79045: PUSH
79046: FOR_IN
79047: IFFALSE 79239
// repeat InitHc ;
79049: CALL_OW 19
// if GetBType ( j ) = b_barracks then
79053: LD_VAR 0 9
79057: PPUSH
79058: CALL_OW 266
79062: PUSH
79063: LD_INT 5
79065: EQUAL
79066: IFFALSE 79136
// begin if UnitsInside ( j ) < 3 then
79068: LD_VAR 0 9
79072: PPUSH
79073: CALL_OW 313
79077: PUSH
79078: LD_INT 3
79080: LESS
79081: IFFALSE 79117
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
79083: LD_INT 0
79085: PPUSH
79086: LD_INT 5
79088: PUSH
79089: LD_INT 8
79091: PUSH
79092: LD_INT 9
79094: PUSH
79095: EMPTY
79096: LIST
79097: LIST
79098: LIST
79099: PUSH
79100: LD_VAR 0 17
79104: ARRAY
79105: PPUSH
79106: LD_VAR 0 4
79110: PPUSH
79111: CALL_OW 380
79115: GO 79134
// PrepareHuman ( false , i , skill ) ;
79117: LD_INT 0
79119: PPUSH
79120: LD_VAR 0 8
79124: PPUSH
79125: LD_VAR 0 4
79129: PPUSH
79130: CALL_OW 380
// end else
79134: GO 79153
// PrepareHuman ( false , i , skill ) ;
79136: LD_INT 0
79138: PPUSH
79139: LD_VAR 0 8
79143: PPUSH
79144: LD_VAR 0 4
79148: PPUSH
79149: CALL_OW 380
// un := CreateHuman ;
79153: LD_ADDR_VAR 0 14
79157: PUSH
79158: CALL_OW 44
79162: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
79163: LD_ADDR_VAR 0 7
79167: PUSH
79168: LD_VAR 0 7
79172: PPUSH
79173: LD_INT 1
79175: PPUSH
79176: LD_VAR 0 14
79180: PPUSH
79181: CALL_OW 2
79185: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
79186: LD_VAR 0 14
79190: PPUSH
79191: LD_VAR 0 9
79195: PPUSH
79196: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
79200: LD_VAR 0 9
79204: PPUSH
79205: CALL_OW 313
79209: PUSH
79210: LD_INT 6
79212: EQUAL
79213: PUSH
79214: LD_VAR 0 9
79218: PPUSH
79219: CALL_OW 266
79223: PUSH
79224: LD_INT 32
79226: PUSH
79227: LD_INT 31
79229: PUSH
79230: EMPTY
79231: LIST
79232: LIST
79233: IN
79234: OR
79235: IFFALSE 79049
79237: GO 79046
79239: POP
79240: POP
// end else
79241: GO 79623
// for j = 1 to x do
79243: LD_ADDR_VAR 0 9
79247: PUSH
79248: DOUBLE
79249: LD_INT 1
79251: DEC
79252: ST_TO_ADDR
79253: LD_VAR 0 13
79257: PUSH
79258: FOR_TO
79259: IFFALSE 79621
// begin InitHc ;
79261: CALL_OW 19
// if not f then
79265: LD_VAR 0 12
79269: NOT
79270: IFFALSE 79359
// begin PrepareHuman ( false , i , skill ) ;
79272: LD_INT 0
79274: PPUSH
79275: LD_VAR 0 8
79279: PPUSH
79280: LD_VAR 0 4
79284: PPUSH
79285: CALL_OW 380
// un := CreateHuman ;
79289: LD_ADDR_VAR 0 14
79293: PUSH
79294: CALL_OW 44
79298: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
79299: LD_ADDR_VAR 0 7
79303: PUSH
79304: LD_VAR 0 7
79308: PPUSH
79309: LD_INT 1
79311: PPUSH
79312: LD_VAR 0 14
79316: PPUSH
79317: CALL_OW 2
79321: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
79322: LD_VAR 0 14
79326: PPUSH
79327: LD_VAR 0 1
79331: PPUSH
79332: CALL_OW 250
79336: PPUSH
79337: LD_VAR 0 1
79341: PPUSH
79342: CALL_OW 251
79346: PPUSH
79347: LD_INT 10
79349: PPUSH
79350: LD_INT 0
79352: PPUSH
79353: CALL_OW 50
// continue ;
79357: GO 79258
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
79359: LD_VAR 0 12
79363: PUSH
79364: LD_INT 1
79366: ARRAY
79367: PPUSH
79368: CALL_OW 313
79372: PUSH
79373: LD_VAR 0 12
79377: PUSH
79378: LD_INT 1
79380: ARRAY
79381: PPUSH
79382: CALL_OW 266
79386: PUSH
79387: LD_INT 32
79389: PUSH
79390: LD_INT 31
79392: PUSH
79393: EMPTY
79394: LIST
79395: LIST
79396: IN
79397: AND
79398: PUSH
79399: LD_VAR 0 12
79403: PUSH
79404: LD_INT 1
79406: ARRAY
79407: PPUSH
79408: CALL_OW 313
79412: PUSH
79413: LD_INT 6
79415: EQUAL
79416: OR
79417: IFFALSE 79437
// f := Delete ( f , 1 ) ;
79419: LD_ADDR_VAR 0 12
79423: PUSH
79424: LD_VAR 0 12
79428: PPUSH
79429: LD_INT 1
79431: PPUSH
79432: CALL_OW 3
79436: ST_TO_ADDR
// if not f then
79437: LD_VAR 0 12
79441: NOT
79442: IFFALSE 79460
// begin x := x + 2 ;
79444: LD_ADDR_VAR 0 13
79448: PUSH
79449: LD_VAR 0 13
79453: PUSH
79454: LD_INT 2
79456: PLUS
79457: ST_TO_ADDR
// continue ;
79458: GO 79258
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
79460: LD_VAR 0 12
79464: PUSH
79465: LD_INT 1
79467: ARRAY
79468: PPUSH
79469: CALL_OW 266
79473: PUSH
79474: LD_INT 5
79476: EQUAL
79477: IFFALSE 79551
// begin if UnitsInside ( f [ 1 ] ) < 3 then
79479: LD_VAR 0 12
79483: PUSH
79484: LD_INT 1
79486: ARRAY
79487: PPUSH
79488: CALL_OW 313
79492: PUSH
79493: LD_INT 3
79495: LESS
79496: IFFALSE 79532
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
79498: LD_INT 0
79500: PPUSH
79501: LD_INT 5
79503: PUSH
79504: LD_INT 8
79506: PUSH
79507: LD_INT 9
79509: PUSH
79510: EMPTY
79511: LIST
79512: LIST
79513: LIST
79514: PUSH
79515: LD_VAR 0 17
79519: ARRAY
79520: PPUSH
79521: LD_VAR 0 4
79525: PPUSH
79526: CALL_OW 380
79530: GO 79549
// PrepareHuman ( false , i , skill ) ;
79532: LD_INT 0
79534: PPUSH
79535: LD_VAR 0 8
79539: PPUSH
79540: LD_VAR 0 4
79544: PPUSH
79545: CALL_OW 380
// end else
79549: GO 79568
// PrepareHuman ( false , i , skill ) ;
79551: LD_INT 0
79553: PPUSH
79554: LD_VAR 0 8
79558: PPUSH
79559: LD_VAR 0 4
79563: PPUSH
79564: CALL_OW 380
// un := CreateHuman ;
79568: LD_ADDR_VAR 0 14
79572: PUSH
79573: CALL_OW 44
79577: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
79578: LD_ADDR_VAR 0 7
79582: PUSH
79583: LD_VAR 0 7
79587: PPUSH
79588: LD_INT 1
79590: PPUSH
79591: LD_VAR 0 14
79595: PPUSH
79596: CALL_OW 2
79600: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
79601: LD_VAR 0 14
79605: PPUSH
79606: LD_VAR 0 12
79610: PUSH
79611: LD_INT 1
79613: ARRAY
79614: PPUSH
79615: CALL_OW 52
// end ;
79619: GO 79258
79621: POP
79622: POP
// end ;
79623: GO 78560
79625: POP
79626: POP
// result := result ^ buildings ;
79627: LD_ADDR_VAR 0 7
79631: PUSH
79632: LD_VAR 0 7
79636: PUSH
79637: LD_VAR 0 18
79641: ADD
79642: ST_TO_ADDR
// end else
79643: GO 79786
// begin for i = 1 to personel do
79645: LD_ADDR_VAR 0 8
79649: PUSH
79650: DOUBLE
79651: LD_INT 1
79653: DEC
79654: ST_TO_ADDR
79655: LD_VAR 0 6
79659: PUSH
79660: FOR_TO
79661: IFFALSE 79784
// begin if i > 4 then
79663: LD_VAR 0 8
79667: PUSH
79668: LD_INT 4
79670: GREATER
79671: IFFALSE 79675
// break ;
79673: GO 79784
// x := personel [ i ] ;
79675: LD_ADDR_VAR 0 13
79679: PUSH
79680: LD_VAR 0 6
79684: PUSH
79685: LD_VAR 0 8
79689: ARRAY
79690: ST_TO_ADDR
// if x = - 1 then
79691: LD_VAR 0 13
79695: PUSH
79696: LD_INT 1
79698: NEG
79699: EQUAL
79700: IFFALSE 79704
// continue ;
79702: GO 79660
// PrepareHuman ( false , i , skill ) ;
79704: LD_INT 0
79706: PPUSH
79707: LD_VAR 0 8
79711: PPUSH
79712: LD_VAR 0 4
79716: PPUSH
79717: CALL_OW 380
// un := CreateHuman ;
79721: LD_ADDR_VAR 0 14
79725: PUSH
79726: CALL_OW 44
79730: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
79731: LD_VAR 0 14
79735: PPUSH
79736: LD_VAR 0 1
79740: PPUSH
79741: CALL_OW 250
79745: PPUSH
79746: LD_VAR 0 1
79750: PPUSH
79751: CALL_OW 251
79755: PPUSH
79756: LD_INT 10
79758: PPUSH
79759: LD_INT 0
79761: PPUSH
79762: CALL_OW 50
// result := result ^ un ;
79766: LD_ADDR_VAR 0 7
79770: PUSH
79771: LD_VAR 0 7
79775: PUSH
79776: LD_VAR 0 14
79780: ADD
79781: ST_TO_ADDR
// end ;
79782: GO 79660
79784: POP
79785: POP
// end ; end ;
79786: LD_VAR 0 7
79790: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
79791: LD_INT 0
79793: PPUSH
79794: PPUSH
79795: PPUSH
79796: PPUSH
79797: PPUSH
79798: PPUSH
79799: PPUSH
79800: PPUSH
79801: PPUSH
79802: PPUSH
79803: PPUSH
79804: PPUSH
79805: PPUSH
79806: PPUSH
79807: PPUSH
79808: PPUSH
// result := false ;
79809: LD_ADDR_VAR 0 3
79813: PUSH
79814: LD_INT 0
79816: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
79817: LD_VAR 0 1
79821: NOT
79822: PUSH
79823: LD_VAR 0 1
79827: PPUSH
79828: CALL_OW 266
79832: PUSH
79833: LD_INT 32
79835: PUSH
79836: LD_INT 33
79838: PUSH
79839: EMPTY
79840: LIST
79841: LIST
79842: IN
79843: NOT
79844: OR
79845: IFFALSE 79849
// exit ;
79847: GO 80958
// nat := GetNation ( tower ) ;
79849: LD_ADDR_VAR 0 12
79853: PUSH
79854: LD_VAR 0 1
79858: PPUSH
79859: CALL_OW 248
79863: ST_TO_ADDR
// side := GetSide ( tower ) ;
79864: LD_ADDR_VAR 0 16
79868: PUSH
79869: LD_VAR 0 1
79873: PPUSH
79874: CALL_OW 255
79878: ST_TO_ADDR
// x := GetX ( tower ) ;
79879: LD_ADDR_VAR 0 10
79883: PUSH
79884: LD_VAR 0 1
79888: PPUSH
79889: CALL_OW 250
79893: ST_TO_ADDR
// y := GetY ( tower ) ;
79894: LD_ADDR_VAR 0 11
79898: PUSH
79899: LD_VAR 0 1
79903: PPUSH
79904: CALL_OW 251
79908: ST_TO_ADDR
// if not x or not y then
79909: LD_VAR 0 10
79913: NOT
79914: PUSH
79915: LD_VAR 0 11
79919: NOT
79920: OR
79921: IFFALSE 79925
// exit ;
79923: GO 80958
// weapon := 0 ;
79925: LD_ADDR_VAR 0 18
79929: PUSH
79930: LD_INT 0
79932: ST_TO_ADDR
// fac_list := [ ] ;
79933: LD_ADDR_VAR 0 17
79937: PUSH
79938: EMPTY
79939: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
79940: LD_ADDR_VAR 0 6
79944: PUSH
79945: LD_VAR 0 1
79949: PPUSH
79950: CALL_OW 274
79954: PPUSH
79955: LD_VAR 0 2
79959: PPUSH
79960: LD_INT 0
79962: PPUSH
79963: CALL 77529 0 3
79967: PPUSH
79968: LD_INT 30
79970: PUSH
79971: LD_INT 3
79973: PUSH
79974: EMPTY
79975: LIST
79976: LIST
79977: PPUSH
79978: CALL_OW 72
79982: ST_TO_ADDR
// if not factories then
79983: LD_VAR 0 6
79987: NOT
79988: IFFALSE 79992
// exit ;
79990: GO 80958
// for i in factories do
79992: LD_ADDR_VAR 0 8
79996: PUSH
79997: LD_VAR 0 6
80001: PUSH
80002: FOR_IN
80003: IFFALSE 80028
// fac_list := fac_list union AvailableWeaponList ( i ) ;
80005: LD_ADDR_VAR 0 17
80009: PUSH
80010: LD_VAR 0 17
80014: PUSH
80015: LD_VAR 0 8
80019: PPUSH
80020: CALL_OW 478
80024: UNION
80025: ST_TO_ADDR
80026: GO 80002
80028: POP
80029: POP
// if not fac_list then
80030: LD_VAR 0 17
80034: NOT
80035: IFFALSE 80039
// exit ;
80037: GO 80958
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
80039: LD_ADDR_VAR 0 5
80043: PUSH
80044: LD_INT 4
80046: PUSH
80047: LD_INT 5
80049: PUSH
80050: LD_INT 9
80052: PUSH
80053: LD_INT 10
80055: PUSH
80056: LD_INT 6
80058: PUSH
80059: LD_INT 7
80061: PUSH
80062: LD_INT 11
80064: PUSH
80065: EMPTY
80066: LIST
80067: LIST
80068: LIST
80069: LIST
80070: LIST
80071: LIST
80072: LIST
80073: PUSH
80074: LD_INT 27
80076: PUSH
80077: LD_INT 28
80079: PUSH
80080: LD_INT 26
80082: PUSH
80083: LD_INT 30
80085: PUSH
80086: EMPTY
80087: LIST
80088: LIST
80089: LIST
80090: LIST
80091: PUSH
80092: LD_INT 43
80094: PUSH
80095: LD_INT 44
80097: PUSH
80098: LD_INT 46
80100: PUSH
80101: LD_INT 45
80103: PUSH
80104: LD_INT 47
80106: PUSH
80107: LD_INT 49
80109: PUSH
80110: EMPTY
80111: LIST
80112: LIST
80113: LIST
80114: LIST
80115: LIST
80116: LIST
80117: PUSH
80118: EMPTY
80119: LIST
80120: LIST
80121: LIST
80122: PUSH
80123: LD_VAR 0 12
80127: ARRAY
80128: ST_TO_ADDR
// list := list isect fac_list ;
80129: LD_ADDR_VAR 0 5
80133: PUSH
80134: LD_VAR 0 5
80138: PUSH
80139: LD_VAR 0 17
80143: ISECT
80144: ST_TO_ADDR
// if not list then
80145: LD_VAR 0 5
80149: NOT
80150: IFFALSE 80154
// exit ;
80152: GO 80958
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
80154: LD_VAR 0 12
80158: PUSH
80159: LD_INT 3
80161: EQUAL
80162: PUSH
80163: LD_INT 49
80165: PUSH
80166: LD_VAR 0 5
80170: IN
80171: AND
80172: PUSH
80173: LD_INT 31
80175: PPUSH
80176: LD_VAR 0 16
80180: PPUSH
80181: CALL_OW 321
80185: PUSH
80186: LD_INT 2
80188: EQUAL
80189: AND
80190: IFFALSE 80250
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
80192: LD_INT 22
80194: PUSH
80195: LD_VAR 0 16
80199: PUSH
80200: EMPTY
80201: LIST
80202: LIST
80203: PUSH
80204: LD_INT 35
80206: PUSH
80207: LD_INT 49
80209: PUSH
80210: EMPTY
80211: LIST
80212: LIST
80213: PUSH
80214: LD_INT 91
80216: PUSH
80217: LD_VAR 0 1
80221: PUSH
80222: LD_INT 10
80224: PUSH
80225: EMPTY
80226: LIST
80227: LIST
80228: LIST
80229: PUSH
80230: EMPTY
80231: LIST
80232: LIST
80233: LIST
80234: PPUSH
80235: CALL_OW 69
80239: NOT
80240: IFFALSE 80250
// weapon := ru_time_lapser ;
80242: LD_ADDR_VAR 0 18
80246: PUSH
80247: LD_INT 49
80249: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
80250: LD_VAR 0 12
80254: PUSH
80255: LD_INT 1
80257: PUSH
80258: LD_INT 2
80260: PUSH
80261: EMPTY
80262: LIST
80263: LIST
80264: IN
80265: PUSH
80266: LD_INT 11
80268: PUSH
80269: LD_VAR 0 5
80273: IN
80274: PUSH
80275: LD_INT 30
80277: PUSH
80278: LD_VAR 0 5
80282: IN
80283: OR
80284: AND
80285: PUSH
80286: LD_INT 6
80288: PPUSH
80289: LD_VAR 0 16
80293: PPUSH
80294: CALL_OW 321
80298: PUSH
80299: LD_INT 2
80301: EQUAL
80302: AND
80303: IFFALSE 80468
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
80305: LD_INT 22
80307: PUSH
80308: LD_VAR 0 16
80312: PUSH
80313: EMPTY
80314: LIST
80315: LIST
80316: PUSH
80317: LD_INT 2
80319: PUSH
80320: LD_INT 35
80322: PUSH
80323: LD_INT 11
80325: PUSH
80326: EMPTY
80327: LIST
80328: LIST
80329: PUSH
80330: LD_INT 35
80332: PUSH
80333: LD_INT 30
80335: PUSH
80336: EMPTY
80337: LIST
80338: LIST
80339: PUSH
80340: EMPTY
80341: LIST
80342: LIST
80343: LIST
80344: PUSH
80345: LD_INT 91
80347: PUSH
80348: LD_VAR 0 1
80352: PUSH
80353: LD_INT 18
80355: PUSH
80356: EMPTY
80357: LIST
80358: LIST
80359: LIST
80360: PUSH
80361: EMPTY
80362: LIST
80363: LIST
80364: LIST
80365: PPUSH
80366: CALL_OW 69
80370: NOT
80371: PUSH
80372: LD_INT 22
80374: PUSH
80375: LD_VAR 0 16
80379: PUSH
80380: EMPTY
80381: LIST
80382: LIST
80383: PUSH
80384: LD_INT 2
80386: PUSH
80387: LD_INT 30
80389: PUSH
80390: LD_INT 32
80392: PUSH
80393: EMPTY
80394: LIST
80395: LIST
80396: PUSH
80397: LD_INT 30
80399: PUSH
80400: LD_INT 33
80402: PUSH
80403: EMPTY
80404: LIST
80405: LIST
80406: PUSH
80407: EMPTY
80408: LIST
80409: LIST
80410: LIST
80411: PUSH
80412: LD_INT 91
80414: PUSH
80415: LD_VAR 0 1
80419: PUSH
80420: LD_INT 12
80422: PUSH
80423: EMPTY
80424: LIST
80425: LIST
80426: LIST
80427: PUSH
80428: EMPTY
80429: LIST
80430: LIST
80431: LIST
80432: PUSH
80433: EMPTY
80434: LIST
80435: PPUSH
80436: CALL_OW 69
80440: PUSH
80441: LD_INT 2
80443: GREATER
80444: AND
80445: IFFALSE 80468
// weapon := [ us_radar , ar_radar ] [ nat ] ;
80447: LD_ADDR_VAR 0 18
80451: PUSH
80452: LD_INT 11
80454: PUSH
80455: LD_INT 30
80457: PUSH
80458: EMPTY
80459: LIST
80460: LIST
80461: PUSH
80462: LD_VAR 0 12
80466: ARRAY
80467: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
80468: LD_VAR 0 18
80472: NOT
80473: PUSH
80474: LD_INT 40
80476: PPUSH
80477: LD_VAR 0 16
80481: PPUSH
80482: CALL_OW 321
80486: PUSH
80487: LD_INT 2
80489: EQUAL
80490: AND
80491: PUSH
80492: LD_INT 7
80494: PUSH
80495: LD_VAR 0 5
80499: IN
80500: PUSH
80501: LD_INT 28
80503: PUSH
80504: LD_VAR 0 5
80508: IN
80509: OR
80510: PUSH
80511: LD_INT 45
80513: PUSH
80514: LD_VAR 0 5
80518: IN
80519: OR
80520: AND
80521: IFFALSE 80775
// begin hex := GetHexInfo ( x , y ) ;
80523: LD_ADDR_VAR 0 4
80527: PUSH
80528: LD_VAR 0 10
80532: PPUSH
80533: LD_VAR 0 11
80537: PPUSH
80538: CALL_OW 546
80542: ST_TO_ADDR
// if hex [ 1 ] then
80543: LD_VAR 0 4
80547: PUSH
80548: LD_INT 1
80550: ARRAY
80551: IFFALSE 80555
// exit ;
80553: GO 80958
// height := hex [ 2 ] ;
80555: LD_ADDR_VAR 0 15
80559: PUSH
80560: LD_VAR 0 4
80564: PUSH
80565: LD_INT 2
80567: ARRAY
80568: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
80569: LD_ADDR_VAR 0 14
80573: PUSH
80574: LD_INT 0
80576: PUSH
80577: LD_INT 2
80579: PUSH
80580: LD_INT 3
80582: PUSH
80583: LD_INT 5
80585: PUSH
80586: EMPTY
80587: LIST
80588: LIST
80589: LIST
80590: LIST
80591: ST_TO_ADDR
// for i in tmp do
80592: LD_ADDR_VAR 0 8
80596: PUSH
80597: LD_VAR 0 14
80601: PUSH
80602: FOR_IN
80603: IFFALSE 80773
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
80605: LD_ADDR_VAR 0 9
80609: PUSH
80610: LD_VAR 0 10
80614: PPUSH
80615: LD_VAR 0 8
80619: PPUSH
80620: LD_INT 5
80622: PPUSH
80623: CALL_OW 272
80627: PUSH
80628: LD_VAR 0 11
80632: PPUSH
80633: LD_VAR 0 8
80637: PPUSH
80638: LD_INT 5
80640: PPUSH
80641: CALL_OW 273
80645: PUSH
80646: EMPTY
80647: LIST
80648: LIST
80649: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
80650: LD_VAR 0 9
80654: PUSH
80655: LD_INT 1
80657: ARRAY
80658: PPUSH
80659: LD_VAR 0 9
80663: PUSH
80664: LD_INT 2
80666: ARRAY
80667: PPUSH
80668: CALL_OW 488
80672: IFFALSE 80771
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
80674: LD_ADDR_VAR 0 4
80678: PUSH
80679: LD_VAR 0 9
80683: PUSH
80684: LD_INT 1
80686: ARRAY
80687: PPUSH
80688: LD_VAR 0 9
80692: PUSH
80693: LD_INT 2
80695: ARRAY
80696: PPUSH
80697: CALL_OW 546
80701: ST_TO_ADDR
// if hex [ 1 ] then
80702: LD_VAR 0 4
80706: PUSH
80707: LD_INT 1
80709: ARRAY
80710: IFFALSE 80714
// continue ;
80712: GO 80602
// h := hex [ 2 ] ;
80714: LD_ADDR_VAR 0 13
80718: PUSH
80719: LD_VAR 0 4
80723: PUSH
80724: LD_INT 2
80726: ARRAY
80727: ST_TO_ADDR
// if h + 7 < height then
80728: LD_VAR 0 13
80732: PUSH
80733: LD_INT 7
80735: PLUS
80736: PUSH
80737: LD_VAR 0 15
80741: LESS
80742: IFFALSE 80771
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
80744: LD_ADDR_VAR 0 18
80748: PUSH
80749: LD_INT 7
80751: PUSH
80752: LD_INT 28
80754: PUSH
80755: LD_INT 45
80757: PUSH
80758: EMPTY
80759: LIST
80760: LIST
80761: LIST
80762: PUSH
80763: LD_VAR 0 12
80767: ARRAY
80768: ST_TO_ADDR
// break ;
80769: GO 80773
// end ; end ; end ;
80771: GO 80602
80773: POP
80774: POP
// end ; if not weapon then
80775: LD_VAR 0 18
80779: NOT
80780: IFFALSE 80840
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
80782: LD_ADDR_VAR 0 5
80786: PUSH
80787: LD_VAR 0 5
80791: PUSH
80792: LD_INT 11
80794: PUSH
80795: LD_INT 30
80797: PUSH
80798: LD_INT 49
80800: PUSH
80801: EMPTY
80802: LIST
80803: LIST
80804: LIST
80805: DIFF
80806: ST_TO_ADDR
// if not list then
80807: LD_VAR 0 5
80811: NOT
80812: IFFALSE 80816
// exit ;
80814: GO 80958
// weapon := list [ rand ( 1 , list ) ] ;
80816: LD_ADDR_VAR 0 18
80820: PUSH
80821: LD_VAR 0 5
80825: PUSH
80826: LD_INT 1
80828: PPUSH
80829: LD_VAR 0 5
80833: PPUSH
80834: CALL_OW 12
80838: ARRAY
80839: ST_TO_ADDR
// end ; if weapon then
80840: LD_VAR 0 18
80844: IFFALSE 80958
// begin tmp := CostOfWeapon ( weapon ) ;
80846: LD_ADDR_VAR 0 14
80850: PUSH
80851: LD_VAR 0 18
80855: PPUSH
80856: CALL_OW 451
80860: ST_TO_ADDR
// j := GetBase ( tower ) ;
80861: LD_ADDR_VAR 0 9
80865: PUSH
80866: LD_VAR 0 1
80870: PPUSH
80871: CALL_OW 274
80875: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
80876: LD_VAR 0 9
80880: PPUSH
80881: LD_INT 1
80883: PPUSH
80884: CALL_OW 275
80888: PUSH
80889: LD_VAR 0 14
80893: PUSH
80894: LD_INT 1
80896: ARRAY
80897: GREATEREQUAL
80898: PUSH
80899: LD_VAR 0 9
80903: PPUSH
80904: LD_INT 2
80906: PPUSH
80907: CALL_OW 275
80911: PUSH
80912: LD_VAR 0 14
80916: PUSH
80917: LD_INT 2
80919: ARRAY
80920: GREATEREQUAL
80921: AND
80922: PUSH
80923: LD_VAR 0 9
80927: PPUSH
80928: LD_INT 3
80930: PPUSH
80931: CALL_OW 275
80935: PUSH
80936: LD_VAR 0 14
80940: PUSH
80941: LD_INT 3
80943: ARRAY
80944: GREATEREQUAL
80945: AND
80946: IFFALSE 80958
// result := weapon ;
80948: LD_ADDR_VAR 0 3
80952: PUSH
80953: LD_VAR 0 18
80957: ST_TO_ADDR
// end ; end ;
80958: LD_VAR 0 3
80962: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
80963: LD_INT 0
80965: PPUSH
80966: PPUSH
// result := true ;
80967: LD_ADDR_VAR 0 3
80971: PUSH
80972: LD_INT 1
80974: ST_TO_ADDR
// if array1 = array2 then
80975: LD_VAR 0 1
80979: PUSH
80980: LD_VAR 0 2
80984: EQUAL
80985: IFFALSE 81045
// begin for i = 1 to array1 do
80987: LD_ADDR_VAR 0 4
80991: PUSH
80992: DOUBLE
80993: LD_INT 1
80995: DEC
80996: ST_TO_ADDR
80997: LD_VAR 0 1
81001: PUSH
81002: FOR_TO
81003: IFFALSE 81041
// if array1 [ i ] <> array2 [ i ] then
81005: LD_VAR 0 1
81009: PUSH
81010: LD_VAR 0 4
81014: ARRAY
81015: PUSH
81016: LD_VAR 0 2
81020: PUSH
81021: LD_VAR 0 4
81025: ARRAY
81026: NONEQUAL
81027: IFFALSE 81039
// begin result := false ;
81029: LD_ADDR_VAR 0 3
81033: PUSH
81034: LD_INT 0
81036: ST_TO_ADDR
// break ;
81037: GO 81041
// end ;
81039: GO 81002
81041: POP
81042: POP
// end else
81043: GO 81053
// result := false ;
81045: LD_ADDR_VAR 0 3
81049: PUSH
81050: LD_INT 0
81052: ST_TO_ADDR
// end ;
81053: LD_VAR 0 3
81057: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
81058: LD_INT 0
81060: PPUSH
81061: PPUSH
// if not array1 or not array2 then
81062: LD_VAR 0 1
81066: NOT
81067: PUSH
81068: LD_VAR 0 2
81072: NOT
81073: OR
81074: IFFALSE 81078
// exit ;
81076: GO 81142
// result := true ;
81078: LD_ADDR_VAR 0 3
81082: PUSH
81083: LD_INT 1
81085: ST_TO_ADDR
// for i = 1 to array1 do
81086: LD_ADDR_VAR 0 4
81090: PUSH
81091: DOUBLE
81092: LD_INT 1
81094: DEC
81095: ST_TO_ADDR
81096: LD_VAR 0 1
81100: PUSH
81101: FOR_TO
81102: IFFALSE 81140
// if array1 [ i ] <> array2 [ i ] then
81104: LD_VAR 0 1
81108: PUSH
81109: LD_VAR 0 4
81113: ARRAY
81114: PUSH
81115: LD_VAR 0 2
81119: PUSH
81120: LD_VAR 0 4
81124: ARRAY
81125: NONEQUAL
81126: IFFALSE 81138
// begin result := false ;
81128: LD_ADDR_VAR 0 3
81132: PUSH
81133: LD_INT 0
81135: ST_TO_ADDR
// break ;
81136: GO 81140
// end ;
81138: GO 81101
81140: POP
81141: POP
// end ;
81142: LD_VAR 0 3
81146: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
81147: LD_INT 0
81149: PPUSH
81150: PPUSH
81151: PPUSH
// pom := GetBase ( fac ) ;
81152: LD_ADDR_VAR 0 5
81156: PUSH
81157: LD_VAR 0 1
81161: PPUSH
81162: CALL_OW 274
81166: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
81167: LD_ADDR_VAR 0 4
81171: PUSH
81172: LD_VAR 0 2
81176: PUSH
81177: LD_INT 1
81179: ARRAY
81180: PPUSH
81181: LD_VAR 0 2
81185: PUSH
81186: LD_INT 2
81188: ARRAY
81189: PPUSH
81190: LD_VAR 0 2
81194: PUSH
81195: LD_INT 3
81197: ARRAY
81198: PPUSH
81199: LD_VAR 0 2
81203: PUSH
81204: LD_INT 4
81206: ARRAY
81207: PPUSH
81208: CALL_OW 449
81212: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
81213: LD_ADDR_VAR 0 3
81217: PUSH
81218: LD_VAR 0 5
81222: PPUSH
81223: LD_INT 1
81225: PPUSH
81226: CALL_OW 275
81230: PUSH
81231: LD_VAR 0 4
81235: PUSH
81236: LD_INT 1
81238: ARRAY
81239: GREATEREQUAL
81240: PUSH
81241: LD_VAR 0 5
81245: PPUSH
81246: LD_INT 2
81248: PPUSH
81249: CALL_OW 275
81253: PUSH
81254: LD_VAR 0 4
81258: PUSH
81259: LD_INT 2
81261: ARRAY
81262: GREATEREQUAL
81263: AND
81264: PUSH
81265: LD_VAR 0 5
81269: PPUSH
81270: LD_INT 3
81272: PPUSH
81273: CALL_OW 275
81277: PUSH
81278: LD_VAR 0 4
81282: PUSH
81283: LD_INT 3
81285: ARRAY
81286: GREATEREQUAL
81287: AND
81288: ST_TO_ADDR
// end ;
81289: LD_VAR 0 3
81293: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
81294: LD_INT 0
81296: PPUSH
81297: PPUSH
81298: PPUSH
81299: PPUSH
// pom := GetBase ( building ) ;
81300: LD_ADDR_VAR 0 3
81304: PUSH
81305: LD_VAR 0 1
81309: PPUSH
81310: CALL_OW 274
81314: ST_TO_ADDR
// if not pom then
81315: LD_VAR 0 3
81319: NOT
81320: IFFALSE 81324
// exit ;
81322: GO 81494
// btype := GetBType ( building ) ;
81324: LD_ADDR_VAR 0 5
81328: PUSH
81329: LD_VAR 0 1
81333: PPUSH
81334: CALL_OW 266
81338: ST_TO_ADDR
// if btype = b_armoury then
81339: LD_VAR 0 5
81343: PUSH
81344: LD_INT 4
81346: EQUAL
81347: IFFALSE 81357
// btype := b_barracks ;
81349: LD_ADDR_VAR 0 5
81353: PUSH
81354: LD_INT 5
81356: ST_TO_ADDR
// if btype = b_depot then
81357: LD_VAR 0 5
81361: PUSH
81362: LD_INT 0
81364: EQUAL
81365: IFFALSE 81375
// btype := b_warehouse ;
81367: LD_ADDR_VAR 0 5
81371: PUSH
81372: LD_INT 1
81374: ST_TO_ADDR
// if btype = b_workshop then
81375: LD_VAR 0 5
81379: PUSH
81380: LD_INT 2
81382: EQUAL
81383: IFFALSE 81393
// btype := b_factory ;
81385: LD_ADDR_VAR 0 5
81389: PUSH
81390: LD_INT 3
81392: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
81393: LD_ADDR_VAR 0 4
81397: PUSH
81398: LD_VAR 0 5
81402: PPUSH
81403: LD_VAR 0 1
81407: PPUSH
81408: CALL_OW 248
81412: PPUSH
81413: CALL_OW 450
81417: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
81418: LD_ADDR_VAR 0 2
81422: PUSH
81423: LD_VAR 0 3
81427: PPUSH
81428: LD_INT 1
81430: PPUSH
81431: CALL_OW 275
81435: PUSH
81436: LD_VAR 0 4
81440: PUSH
81441: LD_INT 1
81443: ARRAY
81444: GREATEREQUAL
81445: PUSH
81446: LD_VAR 0 3
81450: PPUSH
81451: LD_INT 2
81453: PPUSH
81454: CALL_OW 275
81458: PUSH
81459: LD_VAR 0 4
81463: PUSH
81464: LD_INT 2
81466: ARRAY
81467: GREATEREQUAL
81468: AND
81469: PUSH
81470: LD_VAR 0 3
81474: PPUSH
81475: LD_INT 3
81477: PPUSH
81478: CALL_OW 275
81482: PUSH
81483: LD_VAR 0 4
81487: PUSH
81488: LD_INT 3
81490: ARRAY
81491: GREATEREQUAL
81492: AND
81493: ST_TO_ADDR
// end ;
81494: LD_VAR 0 2
81498: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
81499: LD_INT 0
81501: PPUSH
81502: PPUSH
81503: PPUSH
// pom := GetBase ( building ) ;
81504: LD_ADDR_VAR 0 4
81508: PUSH
81509: LD_VAR 0 1
81513: PPUSH
81514: CALL_OW 274
81518: ST_TO_ADDR
// if not pom then
81519: LD_VAR 0 4
81523: NOT
81524: IFFALSE 81528
// exit ;
81526: GO 81629
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
81528: LD_ADDR_VAR 0 5
81532: PUSH
81533: LD_VAR 0 2
81537: PPUSH
81538: LD_VAR 0 1
81542: PPUSH
81543: CALL_OW 248
81547: PPUSH
81548: CALL_OW 450
81552: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
81553: LD_ADDR_VAR 0 3
81557: PUSH
81558: LD_VAR 0 4
81562: PPUSH
81563: LD_INT 1
81565: PPUSH
81566: CALL_OW 275
81570: PUSH
81571: LD_VAR 0 5
81575: PUSH
81576: LD_INT 1
81578: ARRAY
81579: GREATEREQUAL
81580: PUSH
81581: LD_VAR 0 4
81585: PPUSH
81586: LD_INT 2
81588: PPUSH
81589: CALL_OW 275
81593: PUSH
81594: LD_VAR 0 5
81598: PUSH
81599: LD_INT 2
81601: ARRAY
81602: GREATEREQUAL
81603: AND
81604: PUSH
81605: LD_VAR 0 4
81609: PPUSH
81610: LD_INT 3
81612: PPUSH
81613: CALL_OW 275
81617: PUSH
81618: LD_VAR 0 5
81622: PUSH
81623: LD_INT 3
81625: ARRAY
81626: GREATEREQUAL
81627: AND
81628: ST_TO_ADDR
// end ;
81629: LD_VAR 0 3
81633: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
81634: LD_INT 0
81636: PPUSH
81637: PPUSH
81638: PPUSH
81639: PPUSH
81640: PPUSH
81641: PPUSH
81642: PPUSH
81643: PPUSH
81644: PPUSH
81645: PPUSH
81646: PPUSH
// result := false ;
81647: LD_ADDR_VAR 0 8
81651: PUSH
81652: LD_INT 0
81654: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
81655: LD_VAR 0 5
81659: NOT
81660: PUSH
81661: LD_VAR 0 1
81665: NOT
81666: OR
81667: PUSH
81668: LD_VAR 0 2
81672: NOT
81673: OR
81674: PUSH
81675: LD_VAR 0 3
81679: NOT
81680: OR
81681: IFFALSE 81685
// exit ;
81683: GO 82499
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
81685: LD_ADDR_VAR 0 14
81689: PUSH
81690: LD_VAR 0 1
81694: PPUSH
81695: LD_VAR 0 2
81699: PPUSH
81700: LD_VAR 0 3
81704: PPUSH
81705: LD_VAR 0 4
81709: PPUSH
81710: LD_VAR 0 5
81714: PUSH
81715: LD_INT 1
81717: ARRAY
81718: PPUSH
81719: CALL_OW 248
81723: PPUSH
81724: LD_INT 0
81726: PPUSH
81727: CALL 83752 0 6
81731: ST_TO_ADDR
// if not hexes then
81732: LD_VAR 0 14
81736: NOT
81737: IFFALSE 81741
// exit ;
81739: GO 82499
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
81741: LD_ADDR_VAR 0 17
81745: PUSH
81746: LD_VAR 0 5
81750: PPUSH
81751: LD_INT 22
81753: PUSH
81754: LD_VAR 0 13
81758: PPUSH
81759: CALL_OW 255
81763: PUSH
81764: EMPTY
81765: LIST
81766: LIST
81767: PUSH
81768: LD_INT 2
81770: PUSH
81771: LD_INT 30
81773: PUSH
81774: LD_INT 0
81776: PUSH
81777: EMPTY
81778: LIST
81779: LIST
81780: PUSH
81781: LD_INT 30
81783: PUSH
81784: LD_INT 1
81786: PUSH
81787: EMPTY
81788: LIST
81789: LIST
81790: PUSH
81791: EMPTY
81792: LIST
81793: LIST
81794: LIST
81795: PUSH
81796: EMPTY
81797: LIST
81798: LIST
81799: PPUSH
81800: CALL_OW 72
81804: ST_TO_ADDR
// for i = 1 to hexes do
81805: LD_ADDR_VAR 0 9
81809: PUSH
81810: DOUBLE
81811: LD_INT 1
81813: DEC
81814: ST_TO_ADDR
81815: LD_VAR 0 14
81819: PUSH
81820: FOR_TO
81821: IFFALSE 82497
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81823: LD_ADDR_VAR 0 13
81827: PUSH
81828: LD_VAR 0 14
81832: PUSH
81833: LD_VAR 0 9
81837: ARRAY
81838: PUSH
81839: LD_INT 1
81841: ARRAY
81842: PPUSH
81843: LD_VAR 0 14
81847: PUSH
81848: LD_VAR 0 9
81852: ARRAY
81853: PUSH
81854: LD_INT 2
81856: ARRAY
81857: PPUSH
81858: CALL_OW 428
81862: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
81863: LD_VAR 0 14
81867: PUSH
81868: LD_VAR 0 9
81872: ARRAY
81873: PUSH
81874: LD_INT 1
81876: ARRAY
81877: PPUSH
81878: LD_VAR 0 14
81882: PUSH
81883: LD_VAR 0 9
81887: ARRAY
81888: PUSH
81889: LD_INT 2
81891: ARRAY
81892: PPUSH
81893: CALL_OW 351
81897: PUSH
81898: LD_VAR 0 14
81902: PUSH
81903: LD_VAR 0 9
81907: ARRAY
81908: PUSH
81909: LD_INT 1
81911: ARRAY
81912: PPUSH
81913: LD_VAR 0 14
81917: PUSH
81918: LD_VAR 0 9
81922: ARRAY
81923: PUSH
81924: LD_INT 2
81926: ARRAY
81927: PPUSH
81928: CALL_OW 488
81932: NOT
81933: OR
81934: PUSH
81935: LD_VAR 0 13
81939: PPUSH
81940: CALL_OW 247
81944: PUSH
81945: LD_INT 3
81947: EQUAL
81948: OR
81949: IFFALSE 81955
// exit ;
81951: POP
81952: POP
81953: GO 82499
// if not tmp then
81955: LD_VAR 0 13
81959: NOT
81960: IFFALSE 81964
// continue ;
81962: GO 81820
// result := true ;
81964: LD_ADDR_VAR 0 8
81968: PUSH
81969: LD_INT 1
81971: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
81972: LD_VAR 0 6
81976: PUSH
81977: LD_VAR 0 13
81981: PPUSH
81982: CALL_OW 247
81986: PUSH
81987: LD_INT 2
81989: EQUAL
81990: AND
81991: PUSH
81992: LD_VAR 0 13
81996: PPUSH
81997: CALL_OW 263
82001: PUSH
82002: LD_INT 1
82004: EQUAL
82005: AND
82006: IFFALSE 82170
// begin if IsDrivenBy ( tmp ) then
82008: LD_VAR 0 13
82012: PPUSH
82013: CALL_OW 311
82017: IFFALSE 82021
// continue ;
82019: GO 81820
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
82021: LD_VAR 0 6
82025: PPUSH
82026: LD_INT 3
82028: PUSH
82029: LD_INT 60
82031: PUSH
82032: EMPTY
82033: LIST
82034: PUSH
82035: EMPTY
82036: LIST
82037: LIST
82038: PUSH
82039: LD_INT 3
82041: PUSH
82042: LD_INT 55
82044: PUSH
82045: EMPTY
82046: LIST
82047: PUSH
82048: EMPTY
82049: LIST
82050: LIST
82051: PUSH
82052: EMPTY
82053: LIST
82054: LIST
82055: PPUSH
82056: CALL_OW 72
82060: IFFALSE 82168
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
82062: LD_ADDR_VAR 0 18
82066: PUSH
82067: LD_VAR 0 6
82071: PPUSH
82072: LD_INT 3
82074: PUSH
82075: LD_INT 60
82077: PUSH
82078: EMPTY
82079: LIST
82080: PUSH
82081: EMPTY
82082: LIST
82083: LIST
82084: PUSH
82085: LD_INT 3
82087: PUSH
82088: LD_INT 55
82090: PUSH
82091: EMPTY
82092: LIST
82093: PUSH
82094: EMPTY
82095: LIST
82096: LIST
82097: PUSH
82098: EMPTY
82099: LIST
82100: LIST
82101: PPUSH
82102: CALL_OW 72
82106: PUSH
82107: LD_INT 1
82109: ARRAY
82110: ST_TO_ADDR
// if IsInUnit ( driver ) then
82111: LD_VAR 0 18
82115: PPUSH
82116: CALL_OW 310
82120: IFFALSE 82131
// ComExit ( driver ) ;
82122: LD_VAR 0 18
82126: PPUSH
82127: CALL 107533 0 1
// AddComEnterUnit ( driver , tmp ) ;
82131: LD_VAR 0 18
82135: PPUSH
82136: LD_VAR 0 13
82140: PPUSH
82141: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
82145: LD_VAR 0 18
82149: PPUSH
82150: LD_VAR 0 7
82154: PPUSH
82155: CALL_OW 173
// AddComExitVehicle ( driver ) ;
82159: LD_VAR 0 18
82163: PPUSH
82164: CALL_OW 181
// end ; continue ;
82168: GO 81820
// end ; if not cleaners or not tmp in cleaners then
82170: LD_VAR 0 6
82174: NOT
82175: PUSH
82176: LD_VAR 0 13
82180: PUSH
82181: LD_VAR 0 6
82185: IN
82186: NOT
82187: OR
82188: IFFALSE 82495
// begin if dep then
82190: LD_VAR 0 17
82194: IFFALSE 82330
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
82196: LD_ADDR_VAR 0 16
82200: PUSH
82201: LD_VAR 0 17
82205: PUSH
82206: LD_INT 1
82208: ARRAY
82209: PPUSH
82210: CALL_OW 250
82214: PPUSH
82215: LD_VAR 0 17
82219: PUSH
82220: LD_INT 1
82222: ARRAY
82223: PPUSH
82224: CALL_OW 254
82228: PPUSH
82229: LD_INT 5
82231: PPUSH
82232: CALL_OW 272
82236: PUSH
82237: LD_VAR 0 17
82241: PUSH
82242: LD_INT 1
82244: ARRAY
82245: PPUSH
82246: CALL_OW 251
82250: PPUSH
82251: LD_VAR 0 17
82255: PUSH
82256: LD_INT 1
82258: ARRAY
82259: PPUSH
82260: CALL_OW 254
82264: PPUSH
82265: LD_INT 5
82267: PPUSH
82268: CALL_OW 273
82272: PUSH
82273: EMPTY
82274: LIST
82275: LIST
82276: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
82277: LD_VAR 0 16
82281: PUSH
82282: LD_INT 1
82284: ARRAY
82285: PPUSH
82286: LD_VAR 0 16
82290: PUSH
82291: LD_INT 2
82293: ARRAY
82294: PPUSH
82295: CALL_OW 488
82299: IFFALSE 82330
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
82301: LD_VAR 0 13
82305: PPUSH
82306: LD_VAR 0 16
82310: PUSH
82311: LD_INT 1
82313: ARRAY
82314: PPUSH
82315: LD_VAR 0 16
82319: PUSH
82320: LD_INT 2
82322: ARRAY
82323: PPUSH
82324: CALL_OW 111
// continue ;
82328: GO 81820
// end ; end ; r := GetDir ( tmp ) ;
82330: LD_ADDR_VAR 0 15
82334: PUSH
82335: LD_VAR 0 13
82339: PPUSH
82340: CALL_OW 254
82344: ST_TO_ADDR
// if r = 5 then
82345: LD_VAR 0 15
82349: PUSH
82350: LD_INT 5
82352: EQUAL
82353: IFFALSE 82363
// r := 0 ;
82355: LD_ADDR_VAR 0 15
82359: PUSH
82360: LD_INT 0
82362: ST_TO_ADDR
// for j = r to 5 do
82363: LD_ADDR_VAR 0 10
82367: PUSH
82368: DOUBLE
82369: LD_VAR 0 15
82373: DEC
82374: ST_TO_ADDR
82375: LD_INT 5
82377: PUSH
82378: FOR_TO
82379: IFFALSE 82493
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
82381: LD_ADDR_VAR 0 11
82385: PUSH
82386: LD_VAR 0 13
82390: PPUSH
82391: CALL_OW 250
82395: PPUSH
82396: LD_VAR 0 10
82400: PPUSH
82401: LD_INT 2
82403: PPUSH
82404: CALL_OW 272
82408: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
82409: LD_ADDR_VAR 0 12
82413: PUSH
82414: LD_VAR 0 13
82418: PPUSH
82419: CALL_OW 251
82423: PPUSH
82424: LD_VAR 0 10
82428: PPUSH
82429: LD_INT 2
82431: PPUSH
82432: CALL_OW 273
82436: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
82437: LD_VAR 0 11
82441: PPUSH
82442: LD_VAR 0 12
82446: PPUSH
82447: CALL_OW 488
82451: PUSH
82452: LD_VAR 0 11
82456: PPUSH
82457: LD_VAR 0 12
82461: PPUSH
82462: CALL_OW 428
82466: NOT
82467: AND
82468: IFFALSE 82491
// begin ComMoveXY ( tmp , _x , _y ) ;
82470: LD_VAR 0 13
82474: PPUSH
82475: LD_VAR 0 11
82479: PPUSH
82480: LD_VAR 0 12
82484: PPUSH
82485: CALL_OW 111
// break ;
82489: GO 82493
// end ; end ;
82491: GO 82378
82493: POP
82494: POP
// end ; end ;
82495: GO 81820
82497: POP
82498: POP
// end ;
82499: LD_VAR 0 8
82503: RET
// export function BuildingTechInvented ( side , btype ) ; begin
82504: LD_INT 0
82506: PPUSH
// result := true ;
82507: LD_ADDR_VAR 0 3
82511: PUSH
82512: LD_INT 1
82514: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
82515: LD_VAR 0 2
82519: PUSH
82520: LD_INT 24
82522: DOUBLE
82523: EQUAL
82524: IFTRUE 82534
82526: LD_INT 33
82528: DOUBLE
82529: EQUAL
82530: IFTRUE 82534
82532: GO 82559
82534: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
82535: LD_ADDR_VAR 0 3
82539: PUSH
82540: LD_INT 32
82542: PPUSH
82543: LD_VAR 0 1
82547: PPUSH
82548: CALL_OW 321
82552: PUSH
82553: LD_INT 2
82555: EQUAL
82556: ST_TO_ADDR
82557: GO 82875
82559: LD_INT 20
82561: DOUBLE
82562: EQUAL
82563: IFTRUE 82567
82565: GO 82592
82567: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
82568: LD_ADDR_VAR 0 3
82572: PUSH
82573: LD_INT 6
82575: PPUSH
82576: LD_VAR 0 1
82580: PPUSH
82581: CALL_OW 321
82585: PUSH
82586: LD_INT 2
82588: EQUAL
82589: ST_TO_ADDR
82590: GO 82875
82592: LD_INT 22
82594: DOUBLE
82595: EQUAL
82596: IFTRUE 82606
82598: LD_INT 36
82600: DOUBLE
82601: EQUAL
82602: IFTRUE 82606
82604: GO 82631
82606: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
82607: LD_ADDR_VAR 0 3
82611: PUSH
82612: LD_INT 15
82614: PPUSH
82615: LD_VAR 0 1
82619: PPUSH
82620: CALL_OW 321
82624: PUSH
82625: LD_INT 2
82627: EQUAL
82628: ST_TO_ADDR
82629: GO 82875
82631: LD_INT 30
82633: DOUBLE
82634: EQUAL
82635: IFTRUE 82639
82637: GO 82664
82639: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
82640: LD_ADDR_VAR 0 3
82644: PUSH
82645: LD_INT 20
82647: PPUSH
82648: LD_VAR 0 1
82652: PPUSH
82653: CALL_OW 321
82657: PUSH
82658: LD_INT 2
82660: EQUAL
82661: ST_TO_ADDR
82662: GO 82875
82664: LD_INT 28
82666: DOUBLE
82667: EQUAL
82668: IFTRUE 82678
82670: LD_INT 21
82672: DOUBLE
82673: EQUAL
82674: IFTRUE 82678
82676: GO 82703
82678: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
82679: LD_ADDR_VAR 0 3
82683: PUSH
82684: LD_INT 21
82686: PPUSH
82687: LD_VAR 0 1
82691: PPUSH
82692: CALL_OW 321
82696: PUSH
82697: LD_INT 2
82699: EQUAL
82700: ST_TO_ADDR
82701: GO 82875
82703: LD_INT 16
82705: DOUBLE
82706: EQUAL
82707: IFTRUE 82711
82709: GO 82736
82711: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
82712: LD_ADDR_VAR 0 3
82716: PUSH
82717: LD_INT 84
82719: PPUSH
82720: LD_VAR 0 1
82724: PPUSH
82725: CALL_OW 321
82729: PUSH
82730: LD_INT 2
82732: EQUAL
82733: ST_TO_ADDR
82734: GO 82875
82736: LD_INT 19
82738: DOUBLE
82739: EQUAL
82740: IFTRUE 82750
82742: LD_INT 23
82744: DOUBLE
82745: EQUAL
82746: IFTRUE 82750
82748: GO 82775
82750: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
82751: LD_ADDR_VAR 0 3
82755: PUSH
82756: LD_INT 83
82758: PPUSH
82759: LD_VAR 0 1
82763: PPUSH
82764: CALL_OW 321
82768: PUSH
82769: LD_INT 2
82771: EQUAL
82772: ST_TO_ADDR
82773: GO 82875
82775: LD_INT 17
82777: DOUBLE
82778: EQUAL
82779: IFTRUE 82783
82781: GO 82808
82783: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
82784: LD_ADDR_VAR 0 3
82788: PUSH
82789: LD_INT 39
82791: PPUSH
82792: LD_VAR 0 1
82796: PPUSH
82797: CALL_OW 321
82801: PUSH
82802: LD_INT 2
82804: EQUAL
82805: ST_TO_ADDR
82806: GO 82875
82808: LD_INT 18
82810: DOUBLE
82811: EQUAL
82812: IFTRUE 82816
82814: GO 82841
82816: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
82817: LD_ADDR_VAR 0 3
82821: PUSH
82822: LD_INT 40
82824: PPUSH
82825: LD_VAR 0 1
82829: PPUSH
82830: CALL_OW 321
82834: PUSH
82835: LD_INT 2
82837: EQUAL
82838: ST_TO_ADDR
82839: GO 82875
82841: LD_INT 27
82843: DOUBLE
82844: EQUAL
82845: IFTRUE 82849
82847: GO 82874
82849: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
82850: LD_ADDR_VAR 0 3
82854: PUSH
82855: LD_INT 35
82857: PPUSH
82858: LD_VAR 0 1
82862: PPUSH
82863: CALL_OW 321
82867: PUSH
82868: LD_INT 2
82870: EQUAL
82871: ST_TO_ADDR
82872: GO 82875
82874: POP
// end ;
82875: LD_VAR 0 3
82879: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
82880: LD_INT 0
82882: PPUSH
82883: PPUSH
82884: PPUSH
82885: PPUSH
82886: PPUSH
82887: PPUSH
82888: PPUSH
82889: PPUSH
82890: PPUSH
82891: PPUSH
82892: PPUSH
// result := false ;
82893: LD_ADDR_VAR 0 6
82897: PUSH
82898: LD_INT 0
82900: ST_TO_ADDR
// if btype = b_depot then
82901: LD_VAR 0 2
82905: PUSH
82906: LD_INT 0
82908: EQUAL
82909: IFFALSE 82921
// begin result := true ;
82911: LD_ADDR_VAR 0 6
82915: PUSH
82916: LD_INT 1
82918: ST_TO_ADDR
// exit ;
82919: GO 83747
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
82921: LD_VAR 0 1
82925: NOT
82926: PUSH
82927: LD_VAR 0 1
82931: PPUSH
82932: CALL_OW 266
82936: PUSH
82937: LD_INT 0
82939: PUSH
82940: LD_INT 1
82942: PUSH
82943: EMPTY
82944: LIST
82945: LIST
82946: IN
82947: NOT
82948: OR
82949: PUSH
82950: LD_VAR 0 2
82954: NOT
82955: OR
82956: PUSH
82957: LD_VAR 0 5
82961: PUSH
82962: LD_INT 0
82964: PUSH
82965: LD_INT 1
82967: PUSH
82968: LD_INT 2
82970: PUSH
82971: LD_INT 3
82973: PUSH
82974: LD_INT 4
82976: PUSH
82977: LD_INT 5
82979: PUSH
82980: EMPTY
82981: LIST
82982: LIST
82983: LIST
82984: LIST
82985: LIST
82986: LIST
82987: IN
82988: NOT
82989: OR
82990: PUSH
82991: LD_VAR 0 3
82995: PPUSH
82996: LD_VAR 0 4
83000: PPUSH
83001: CALL_OW 488
83005: NOT
83006: OR
83007: IFFALSE 83011
// exit ;
83009: GO 83747
// side := GetSide ( depot ) ;
83011: LD_ADDR_VAR 0 9
83015: PUSH
83016: LD_VAR 0 1
83020: PPUSH
83021: CALL_OW 255
83025: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
83026: LD_VAR 0 9
83030: PPUSH
83031: LD_VAR 0 2
83035: PPUSH
83036: CALL 82504 0 2
83040: NOT
83041: IFFALSE 83045
// exit ;
83043: GO 83747
// pom := GetBase ( depot ) ;
83045: LD_ADDR_VAR 0 10
83049: PUSH
83050: LD_VAR 0 1
83054: PPUSH
83055: CALL_OW 274
83059: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
83060: LD_ADDR_VAR 0 11
83064: PUSH
83065: LD_VAR 0 2
83069: PPUSH
83070: LD_VAR 0 1
83074: PPUSH
83075: CALL_OW 248
83079: PPUSH
83080: CALL_OW 450
83084: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
83085: LD_VAR 0 10
83089: PPUSH
83090: LD_INT 1
83092: PPUSH
83093: CALL_OW 275
83097: PUSH
83098: LD_VAR 0 11
83102: PUSH
83103: LD_INT 1
83105: ARRAY
83106: GREATEREQUAL
83107: PUSH
83108: LD_VAR 0 10
83112: PPUSH
83113: LD_INT 2
83115: PPUSH
83116: CALL_OW 275
83120: PUSH
83121: LD_VAR 0 11
83125: PUSH
83126: LD_INT 2
83128: ARRAY
83129: GREATEREQUAL
83130: AND
83131: PUSH
83132: LD_VAR 0 10
83136: PPUSH
83137: LD_INT 3
83139: PPUSH
83140: CALL_OW 275
83144: PUSH
83145: LD_VAR 0 11
83149: PUSH
83150: LD_INT 3
83152: ARRAY
83153: GREATEREQUAL
83154: AND
83155: NOT
83156: IFFALSE 83160
// exit ;
83158: GO 83747
// if GetBType ( depot ) = b_depot then
83160: LD_VAR 0 1
83164: PPUSH
83165: CALL_OW 266
83169: PUSH
83170: LD_INT 0
83172: EQUAL
83173: IFFALSE 83185
// dist := 28 else
83175: LD_ADDR_VAR 0 14
83179: PUSH
83180: LD_INT 28
83182: ST_TO_ADDR
83183: GO 83193
// dist := 36 ;
83185: LD_ADDR_VAR 0 14
83189: PUSH
83190: LD_INT 36
83192: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
83193: LD_VAR 0 1
83197: PPUSH
83198: LD_VAR 0 3
83202: PPUSH
83203: LD_VAR 0 4
83207: PPUSH
83208: CALL_OW 297
83212: PUSH
83213: LD_VAR 0 14
83217: GREATER
83218: IFFALSE 83222
// exit ;
83220: GO 83747
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
83222: LD_ADDR_VAR 0 12
83226: PUSH
83227: LD_VAR 0 2
83231: PPUSH
83232: LD_VAR 0 3
83236: PPUSH
83237: LD_VAR 0 4
83241: PPUSH
83242: LD_VAR 0 5
83246: PPUSH
83247: LD_VAR 0 1
83251: PPUSH
83252: CALL_OW 248
83256: PPUSH
83257: LD_INT 0
83259: PPUSH
83260: CALL 83752 0 6
83264: ST_TO_ADDR
// if not hexes then
83265: LD_VAR 0 12
83269: NOT
83270: IFFALSE 83274
// exit ;
83272: GO 83747
// hex := GetHexInfo ( x , y ) ;
83274: LD_ADDR_VAR 0 15
83278: PUSH
83279: LD_VAR 0 3
83283: PPUSH
83284: LD_VAR 0 4
83288: PPUSH
83289: CALL_OW 546
83293: ST_TO_ADDR
// if hex [ 1 ] then
83294: LD_VAR 0 15
83298: PUSH
83299: LD_INT 1
83301: ARRAY
83302: IFFALSE 83306
// exit ;
83304: GO 83747
// height := hex [ 2 ] ;
83306: LD_ADDR_VAR 0 13
83310: PUSH
83311: LD_VAR 0 15
83315: PUSH
83316: LD_INT 2
83318: ARRAY
83319: ST_TO_ADDR
// for i = 1 to hexes do
83320: LD_ADDR_VAR 0 7
83324: PUSH
83325: DOUBLE
83326: LD_INT 1
83328: DEC
83329: ST_TO_ADDR
83330: LD_VAR 0 12
83334: PUSH
83335: FOR_TO
83336: IFFALSE 83666
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
83338: LD_VAR 0 12
83342: PUSH
83343: LD_VAR 0 7
83347: ARRAY
83348: PUSH
83349: LD_INT 1
83351: ARRAY
83352: PPUSH
83353: LD_VAR 0 12
83357: PUSH
83358: LD_VAR 0 7
83362: ARRAY
83363: PUSH
83364: LD_INT 2
83366: ARRAY
83367: PPUSH
83368: CALL_OW 488
83372: NOT
83373: PUSH
83374: LD_VAR 0 12
83378: PUSH
83379: LD_VAR 0 7
83383: ARRAY
83384: PUSH
83385: LD_INT 1
83387: ARRAY
83388: PPUSH
83389: LD_VAR 0 12
83393: PUSH
83394: LD_VAR 0 7
83398: ARRAY
83399: PUSH
83400: LD_INT 2
83402: ARRAY
83403: PPUSH
83404: CALL_OW 428
83408: PUSH
83409: LD_INT 0
83411: GREATER
83412: OR
83413: PUSH
83414: LD_VAR 0 12
83418: PUSH
83419: LD_VAR 0 7
83423: ARRAY
83424: PUSH
83425: LD_INT 1
83427: ARRAY
83428: PPUSH
83429: LD_VAR 0 12
83433: PUSH
83434: LD_VAR 0 7
83438: ARRAY
83439: PUSH
83440: LD_INT 2
83442: ARRAY
83443: PPUSH
83444: CALL_OW 351
83448: OR
83449: IFFALSE 83455
// exit ;
83451: POP
83452: POP
83453: GO 83747
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
83455: LD_ADDR_VAR 0 8
83459: PUSH
83460: LD_VAR 0 12
83464: PUSH
83465: LD_VAR 0 7
83469: ARRAY
83470: PUSH
83471: LD_INT 1
83473: ARRAY
83474: PPUSH
83475: LD_VAR 0 12
83479: PUSH
83480: LD_VAR 0 7
83484: ARRAY
83485: PUSH
83486: LD_INT 2
83488: ARRAY
83489: PPUSH
83490: CALL_OW 546
83494: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
83495: LD_VAR 0 8
83499: PUSH
83500: LD_INT 1
83502: ARRAY
83503: PUSH
83504: LD_VAR 0 8
83508: PUSH
83509: LD_INT 2
83511: ARRAY
83512: PUSH
83513: LD_VAR 0 13
83517: PUSH
83518: LD_INT 2
83520: PLUS
83521: GREATER
83522: OR
83523: PUSH
83524: LD_VAR 0 8
83528: PUSH
83529: LD_INT 2
83531: ARRAY
83532: PUSH
83533: LD_VAR 0 13
83537: PUSH
83538: LD_INT 2
83540: MINUS
83541: LESS
83542: OR
83543: PUSH
83544: LD_VAR 0 8
83548: PUSH
83549: LD_INT 3
83551: ARRAY
83552: PUSH
83553: LD_INT 0
83555: PUSH
83556: LD_INT 8
83558: PUSH
83559: LD_INT 9
83561: PUSH
83562: LD_INT 10
83564: PUSH
83565: LD_INT 11
83567: PUSH
83568: LD_INT 12
83570: PUSH
83571: LD_INT 13
83573: PUSH
83574: LD_INT 16
83576: PUSH
83577: LD_INT 17
83579: PUSH
83580: LD_INT 18
83582: PUSH
83583: LD_INT 19
83585: PUSH
83586: LD_INT 20
83588: PUSH
83589: LD_INT 21
83591: PUSH
83592: EMPTY
83593: LIST
83594: LIST
83595: LIST
83596: LIST
83597: LIST
83598: LIST
83599: LIST
83600: LIST
83601: LIST
83602: LIST
83603: LIST
83604: LIST
83605: LIST
83606: IN
83607: NOT
83608: OR
83609: PUSH
83610: LD_VAR 0 8
83614: PUSH
83615: LD_INT 5
83617: ARRAY
83618: NOT
83619: OR
83620: PUSH
83621: LD_VAR 0 8
83625: PUSH
83626: LD_INT 6
83628: ARRAY
83629: PUSH
83630: LD_INT 1
83632: PUSH
83633: LD_INT 2
83635: PUSH
83636: LD_INT 7
83638: PUSH
83639: LD_INT 9
83641: PUSH
83642: LD_INT 10
83644: PUSH
83645: LD_INT 11
83647: PUSH
83648: EMPTY
83649: LIST
83650: LIST
83651: LIST
83652: LIST
83653: LIST
83654: LIST
83655: IN
83656: NOT
83657: OR
83658: IFFALSE 83664
// exit ;
83660: POP
83661: POP
83662: GO 83747
// end ;
83664: GO 83335
83666: POP
83667: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
83668: LD_VAR 0 9
83672: PPUSH
83673: LD_VAR 0 3
83677: PPUSH
83678: LD_VAR 0 4
83682: PPUSH
83683: LD_INT 20
83685: PPUSH
83686: CALL 75670 0 4
83690: PUSH
83691: LD_INT 4
83693: ARRAY
83694: IFFALSE 83698
// exit ;
83696: GO 83747
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
83698: LD_VAR 0 2
83702: PUSH
83703: LD_INT 29
83705: PUSH
83706: LD_INT 30
83708: PUSH
83709: EMPTY
83710: LIST
83711: LIST
83712: IN
83713: PUSH
83714: LD_VAR 0 3
83718: PPUSH
83719: LD_VAR 0 4
83723: PPUSH
83724: LD_VAR 0 9
83728: PPUSH
83729: CALL_OW 440
83733: NOT
83734: AND
83735: IFFALSE 83739
// exit ;
83737: GO 83747
// result := true ;
83739: LD_ADDR_VAR 0 6
83743: PUSH
83744: LD_INT 1
83746: ST_TO_ADDR
// end ;
83747: LD_VAR 0 6
83751: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
83752: LD_INT 0
83754: PPUSH
83755: PPUSH
83756: PPUSH
83757: PPUSH
83758: PPUSH
83759: PPUSH
83760: PPUSH
83761: PPUSH
83762: PPUSH
83763: PPUSH
83764: PPUSH
83765: PPUSH
83766: PPUSH
83767: PPUSH
83768: PPUSH
83769: PPUSH
83770: PPUSH
83771: PPUSH
83772: PPUSH
83773: PPUSH
83774: PPUSH
83775: PPUSH
83776: PPUSH
83777: PPUSH
83778: PPUSH
83779: PPUSH
83780: PPUSH
83781: PPUSH
83782: PPUSH
83783: PPUSH
83784: PPUSH
83785: PPUSH
83786: PPUSH
83787: PPUSH
83788: PPUSH
83789: PPUSH
83790: PPUSH
83791: PPUSH
83792: PPUSH
83793: PPUSH
83794: PPUSH
83795: PPUSH
83796: PPUSH
83797: PPUSH
83798: PPUSH
83799: PPUSH
83800: PPUSH
83801: PPUSH
83802: PPUSH
83803: PPUSH
83804: PPUSH
83805: PPUSH
83806: PPUSH
83807: PPUSH
83808: PPUSH
83809: PPUSH
83810: PPUSH
83811: PPUSH
// result = [ ] ;
83812: LD_ADDR_VAR 0 7
83816: PUSH
83817: EMPTY
83818: ST_TO_ADDR
// temp_list = [ ] ;
83819: LD_ADDR_VAR 0 9
83823: PUSH
83824: EMPTY
83825: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
83826: LD_VAR 0 4
83830: PUSH
83831: LD_INT 0
83833: PUSH
83834: LD_INT 1
83836: PUSH
83837: LD_INT 2
83839: PUSH
83840: LD_INT 3
83842: PUSH
83843: LD_INT 4
83845: PUSH
83846: LD_INT 5
83848: PUSH
83849: EMPTY
83850: LIST
83851: LIST
83852: LIST
83853: LIST
83854: LIST
83855: LIST
83856: IN
83857: NOT
83858: PUSH
83859: LD_VAR 0 1
83863: PUSH
83864: LD_INT 0
83866: PUSH
83867: LD_INT 1
83869: PUSH
83870: EMPTY
83871: LIST
83872: LIST
83873: IN
83874: PUSH
83875: LD_VAR 0 5
83879: PUSH
83880: LD_INT 1
83882: PUSH
83883: LD_INT 2
83885: PUSH
83886: LD_INT 3
83888: PUSH
83889: EMPTY
83890: LIST
83891: LIST
83892: LIST
83893: IN
83894: NOT
83895: AND
83896: OR
83897: IFFALSE 83901
// exit ;
83899: GO 102292
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
83901: LD_VAR 0 1
83905: PUSH
83906: LD_INT 6
83908: PUSH
83909: LD_INT 7
83911: PUSH
83912: LD_INT 8
83914: PUSH
83915: LD_INT 13
83917: PUSH
83918: LD_INT 12
83920: PUSH
83921: LD_INT 15
83923: PUSH
83924: LD_INT 11
83926: PUSH
83927: LD_INT 14
83929: PUSH
83930: LD_INT 10
83932: PUSH
83933: EMPTY
83934: LIST
83935: LIST
83936: LIST
83937: LIST
83938: LIST
83939: LIST
83940: LIST
83941: LIST
83942: LIST
83943: IN
83944: IFFALSE 83954
// btype = b_lab ;
83946: LD_ADDR_VAR 0 1
83950: PUSH
83951: LD_INT 6
83953: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
83954: LD_VAR 0 6
83958: PUSH
83959: LD_INT 0
83961: PUSH
83962: LD_INT 1
83964: PUSH
83965: LD_INT 2
83967: PUSH
83968: EMPTY
83969: LIST
83970: LIST
83971: LIST
83972: IN
83973: NOT
83974: PUSH
83975: LD_VAR 0 1
83979: PUSH
83980: LD_INT 0
83982: PUSH
83983: LD_INT 1
83985: PUSH
83986: LD_INT 2
83988: PUSH
83989: LD_INT 3
83991: PUSH
83992: LD_INT 6
83994: PUSH
83995: LD_INT 36
83997: PUSH
83998: LD_INT 4
84000: PUSH
84001: LD_INT 5
84003: PUSH
84004: LD_INT 31
84006: PUSH
84007: LD_INT 32
84009: PUSH
84010: LD_INT 33
84012: PUSH
84013: EMPTY
84014: LIST
84015: LIST
84016: LIST
84017: LIST
84018: LIST
84019: LIST
84020: LIST
84021: LIST
84022: LIST
84023: LIST
84024: LIST
84025: IN
84026: NOT
84027: PUSH
84028: LD_VAR 0 6
84032: PUSH
84033: LD_INT 1
84035: EQUAL
84036: AND
84037: OR
84038: PUSH
84039: LD_VAR 0 1
84043: PUSH
84044: LD_INT 2
84046: PUSH
84047: LD_INT 3
84049: PUSH
84050: EMPTY
84051: LIST
84052: LIST
84053: IN
84054: NOT
84055: PUSH
84056: LD_VAR 0 6
84060: PUSH
84061: LD_INT 2
84063: EQUAL
84064: AND
84065: OR
84066: IFFALSE 84076
// mode = 0 ;
84068: LD_ADDR_VAR 0 6
84072: PUSH
84073: LD_INT 0
84075: ST_TO_ADDR
// case mode of 0 :
84076: LD_VAR 0 6
84080: PUSH
84081: LD_INT 0
84083: DOUBLE
84084: EQUAL
84085: IFTRUE 84089
84087: GO 95542
84089: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
84090: LD_ADDR_VAR 0 11
84094: PUSH
84095: LD_INT 0
84097: PUSH
84098: LD_INT 0
84100: PUSH
84101: EMPTY
84102: LIST
84103: LIST
84104: PUSH
84105: LD_INT 0
84107: PUSH
84108: LD_INT 1
84110: NEG
84111: PUSH
84112: EMPTY
84113: LIST
84114: LIST
84115: PUSH
84116: LD_INT 1
84118: PUSH
84119: LD_INT 0
84121: PUSH
84122: EMPTY
84123: LIST
84124: LIST
84125: PUSH
84126: LD_INT 1
84128: PUSH
84129: LD_INT 1
84131: PUSH
84132: EMPTY
84133: LIST
84134: LIST
84135: PUSH
84136: LD_INT 0
84138: PUSH
84139: LD_INT 1
84141: PUSH
84142: EMPTY
84143: LIST
84144: LIST
84145: PUSH
84146: LD_INT 1
84148: NEG
84149: PUSH
84150: LD_INT 0
84152: PUSH
84153: EMPTY
84154: LIST
84155: LIST
84156: PUSH
84157: LD_INT 1
84159: NEG
84160: PUSH
84161: LD_INT 1
84163: NEG
84164: PUSH
84165: EMPTY
84166: LIST
84167: LIST
84168: PUSH
84169: LD_INT 1
84171: NEG
84172: PUSH
84173: LD_INT 2
84175: NEG
84176: PUSH
84177: EMPTY
84178: LIST
84179: LIST
84180: PUSH
84181: LD_INT 0
84183: PUSH
84184: LD_INT 2
84186: NEG
84187: PUSH
84188: EMPTY
84189: LIST
84190: LIST
84191: PUSH
84192: LD_INT 1
84194: PUSH
84195: LD_INT 1
84197: NEG
84198: PUSH
84199: EMPTY
84200: LIST
84201: LIST
84202: PUSH
84203: LD_INT 1
84205: PUSH
84206: LD_INT 2
84208: PUSH
84209: EMPTY
84210: LIST
84211: LIST
84212: PUSH
84213: LD_INT 0
84215: PUSH
84216: LD_INT 2
84218: PUSH
84219: EMPTY
84220: LIST
84221: LIST
84222: PUSH
84223: LD_INT 1
84225: NEG
84226: PUSH
84227: LD_INT 1
84229: PUSH
84230: EMPTY
84231: LIST
84232: LIST
84233: PUSH
84234: LD_INT 1
84236: PUSH
84237: LD_INT 3
84239: PUSH
84240: EMPTY
84241: LIST
84242: LIST
84243: PUSH
84244: LD_INT 0
84246: PUSH
84247: LD_INT 3
84249: PUSH
84250: EMPTY
84251: LIST
84252: LIST
84253: PUSH
84254: LD_INT 1
84256: NEG
84257: PUSH
84258: LD_INT 2
84260: PUSH
84261: EMPTY
84262: LIST
84263: LIST
84264: PUSH
84265: EMPTY
84266: LIST
84267: LIST
84268: LIST
84269: LIST
84270: LIST
84271: LIST
84272: LIST
84273: LIST
84274: LIST
84275: LIST
84276: LIST
84277: LIST
84278: LIST
84279: LIST
84280: LIST
84281: LIST
84282: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
84283: LD_ADDR_VAR 0 12
84287: PUSH
84288: LD_INT 0
84290: PUSH
84291: LD_INT 0
84293: PUSH
84294: EMPTY
84295: LIST
84296: LIST
84297: PUSH
84298: LD_INT 0
84300: PUSH
84301: LD_INT 1
84303: NEG
84304: PUSH
84305: EMPTY
84306: LIST
84307: LIST
84308: PUSH
84309: LD_INT 1
84311: PUSH
84312: LD_INT 0
84314: PUSH
84315: EMPTY
84316: LIST
84317: LIST
84318: PUSH
84319: LD_INT 1
84321: PUSH
84322: LD_INT 1
84324: PUSH
84325: EMPTY
84326: LIST
84327: LIST
84328: PUSH
84329: LD_INT 0
84331: PUSH
84332: LD_INT 1
84334: PUSH
84335: EMPTY
84336: LIST
84337: LIST
84338: PUSH
84339: LD_INT 1
84341: NEG
84342: PUSH
84343: LD_INT 0
84345: PUSH
84346: EMPTY
84347: LIST
84348: LIST
84349: PUSH
84350: LD_INT 1
84352: NEG
84353: PUSH
84354: LD_INT 1
84356: NEG
84357: PUSH
84358: EMPTY
84359: LIST
84360: LIST
84361: PUSH
84362: LD_INT 1
84364: PUSH
84365: LD_INT 1
84367: NEG
84368: PUSH
84369: EMPTY
84370: LIST
84371: LIST
84372: PUSH
84373: LD_INT 2
84375: PUSH
84376: LD_INT 0
84378: PUSH
84379: EMPTY
84380: LIST
84381: LIST
84382: PUSH
84383: LD_INT 2
84385: PUSH
84386: LD_INT 1
84388: PUSH
84389: EMPTY
84390: LIST
84391: LIST
84392: PUSH
84393: LD_INT 1
84395: NEG
84396: PUSH
84397: LD_INT 1
84399: PUSH
84400: EMPTY
84401: LIST
84402: LIST
84403: PUSH
84404: LD_INT 2
84406: NEG
84407: PUSH
84408: LD_INT 0
84410: PUSH
84411: EMPTY
84412: LIST
84413: LIST
84414: PUSH
84415: LD_INT 2
84417: NEG
84418: PUSH
84419: LD_INT 1
84421: NEG
84422: PUSH
84423: EMPTY
84424: LIST
84425: LIST
84426: PUSH
84427: LD_INT 2
84429: NEG
84430: PUSH
84431: LD_INT 1
84433: PUSH
84434: EMPTY
84435: LIST
84436: LIST
84437: PUSH
84438: LD_INT 3
84440: NEG
84441: PUSH
84442: LD_INT 0
84444: PUSH
84445: EMPTY
84446: LIST
84447: LIST
84448: PUSH
84449: LD_INT 3
84451: NEG
84452: PUSH
84453: LD_INT 1
84455: NEG
84456: PUSH
84457: EMPTY
84458: LIST
84459: LIST
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: LIST
84465: LIST
84466: LIST
84467: LIST
84468: LIST
84469: LIST
84470: LIST
84471: LIST
84472: LIST
84473: LIST
84474: LIST
84475: LIST
84476: LIST
84477: LIST
84478: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84479: LD_ADDR_VAR 0 13
84483: PUSH
84484: LD_INT 0
84486: PUSH
84487: LD_INT 0
84489: PUSH
84490: EMPTY
84491: LIST
84492: LIST
84493: PUSH
84494: LD_INT 0
84496: PUSH
84497: LD_INT 1
84499: NEG
84500: PUSH
84501: EMPTY
84502: LIST
84503: LIST
84504: PUSH
84505: LD_INT 1
84507: PUSH
84508: LD_INT 0
84510: PUSH
84511: EMPTY
84512: LIST
84513: LIST
84514: PUSH
84515: LD_INT 1
84517: PUSH
84518: LD_INT 1
84520: PUSH
84521: EMPTY
84522: LIST
84523: LIST
84524: PUSH
84525: LD_INT 0
84527: PUSH
84528: LD_INT 1
84530: PUSH
84531: EMPTY
84532: LIST
84533: LIST
84534: PUSH
84535: LD_INT 1
84537: NEG
84538: PUSH
84539: LD_INT 0
84541: PUSH
84542: EMPTY
84543: LIST
84544: LIST
84545: PUSH
84546: LD_INT 1
84548: NEG
84549: PUSH
84550: LD_INT 1
84552: NEG
84553: PUSH
84554: EMPTY
84555: LIST
84556: LIST
84557: PUSH
84558: LD_INT 1
84560: NEG
84561: PUSH
84562: LD_INT 2
84564: NEG
84565: PUSH
84566: EMPTY
84567: LIST
84568: LIST
84569: PUSH
84570: LD_INT 2
84572: PUSH
84573: LD_INT 1
84575: PUSH
84576: EMPTY
84577: LIST
84578: LIST
84579: PUSH
84580: LD_INT 2
84582: PUSH
84583: LD_INT 2
84585: PUSH
84586: EMPTY
84587: LIST
84588: LIST
84589: PUSH
84590: LD_INT 1
84592: PUSH
84593: LD_INT 2
84595: PUSH
84596: EMPTY
84597: LIST
84598: LIST
84599: PUSH
84600: LD_INT 2
84602: NEG
84603: PUSH
84604: LD_INT 1
84606: NEG
84607: PUSH
84608: EMPTY
84609: LIST
84610: LIST
84611: PUSH
84612: LD_INT 2
84614: NEG
84615: PUSH
84616: LD_INT 2
84618: NEG
84619: PUSH
84620: EMPTY
84621: LIST
84622: LIST
84623: PUSH
84624: LD_INT 2
84626: NEG
84627: PUSH
84628: LD_INT 3
84630: NEG
84631: PUSH
84632: EMPTY
84633: LIST
84634: LIST
84635: PUSH
84636: LD_INT 3
84638: NEG
84639: PUSH
84640: LD_INT 2
84642: NEG
84643: PUSH
84644: EMPTY
84645: LIST
84646: LIST
84647: PUSH
84648: LD_INT 3
84650: NEG
84651: PUSH
84652: LD_INT 3
84654: NEG
84655: PUSH
84656: EMPTY
84657: LIST
84658: LIST
84659: PUSH
84660: EMPTY
84661: LIST
84662: LIST
84663: LIST
84664: LIST
84665: LIST
84666: LIST
84667: LIST
84668: LIST
84669: LIST
84670: LIST
84671: LIST
84672: LIST
84673: LIST
84674: LIST
84675: LIST
84676: LIST
84677: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
84678: LD_ADDR_VAR 0 14
84682: PUSH
84683: LD_INT 0
84685: PUSH
84686: LD_INT 0
84688: PUSH
84689: EMPTY
84690: LIST
84691: LIST
84692: PUSH
84693: LD_INT 0
84695: PUSH
84696: LD_INT 1
84698: NEG
84699: PUSH
84700: EMPTY
84701: LIST
84702: LIST
84703: PUSH
84704: LD_INT 1
84706: PUSH
84707: LD_INT 0
84709: PUSH
84710: EMPTY
84711: LIST
84712: LIST
84713: PUSH
84714: LD_INT 1
84716: PUSH
84717: LD_INT 1
84719: PUSH
84720: EMPTY
84721: LIST
84722: LIST
84723: PUSH
84724: LD_INT 0
84726: PUSH
84727: LD_INT 1
84729: PUSH
84730: EMPTY
84731: LIST
84732: LIST
84733: PUSH
84734: LD_INT 1
84736: NEG
84737: PUSH
84738: LD_INT 0
84740: PUSH
84741: EMPTY
84742: LIST
84743: LIST
84744: PUSH
84745: LD_INT 1
84747: NEG
84748: PUSH
84749: LD_INT 1
84751: NEG
84752: PUSH
84753: EMPTY
84754: LIST
84755: LIST
84756: PUSH
84757: LD_INT 1
84759: NEG
84760: PUSH
84761: LD_INT 2
84763: NEG
84764: PUSH
84765: EMPTY
84766: LIST
84767: LIST
84768: PUSH
84769: LD_INT 0
84771: PUSH
84772: LD_INT 2
84774: NEG
84775: PUSH
84776: EMPTY
84777: LIST
84778: LIST
84779: PUSH
84780: LD_INT 1
84782: PUSH
84783: LD_INT 1
84785: NEG
84786: PUSH
84787: EMPTY
84788: LIST
84789: LIST
84790: PUSH
84791: LD_INT 1
84793: PUSH
84794: LD_INT 2
84796: PUSH
84797: EMPTY
84798: LIST
84799: LIST
84800: PUSH
84801: LD_INT 0
84803: PUSH
84804: LD_INT 2
84806: PUSH
84807: EMPTY
84808: LIST
84809: LIST
84810: PUSH
84811: LD_INT 1
84813: NEG
84814: PUSH
84815: LD_INT 1
84817: PUSH
84818: EMPTY
84819: LIST
84820: LIST
84821: PUSH
84822: LD_INT 1
84824: NEG
84825: PUSH
84826: LD_INT 3
84828: NEG
84829: PUSH
84830: EMPTY
84831: LIST
84832: LIST
84833: PUSH
84834: LD_INT 0
84836: PUSH
84837: LD_INT 3
84839: NEG
84840: PUSH
84841: EMPTY
84842: LIST
84843: LIST
84844: PUSH
84845: LD_INT 1
84847: PUSH
84848: LD_INT 2
84850: NEG
84851: PUSH
84852: EMPTY
84853: LIST
84854: LIST
84855: PUSH
84856: EMPTY
84857: LIST
84858: LIST
84859: LIST
84860: LIST
84861: LIST
84862: LIST
84863: LIST
84864: LIST
84865: LIST
84866: LIST
84867: LIST
84868: LIST
84869: LIST
84870: LIST
84871: LIST
84872: LIST
84873: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
84874: LD_ADDR_VAR 0 15
84878: PUSH
84879: LD_INT 0
84881: PUSH
84882: LD_INT 0
84884: PUSH
84885: EMPTY
84886: LIST
84887: LIST
84888: PUSH
84889: LD_INT 0
84891: PUSH
84892: LD_INT 1
84894: NEG
84895: PUSH
84896: EMPTY
84897: LIST
84898: LIST
84899: PUSH
84900: LD_INT 1
84902: PUSH
84903: LD_INT 0
84905: PUSH
84906: EMPTY
84907: LIST
84908: LIST
84909: PUSH
84910: LD_INT 1
84912: PUSH
84913: LD_INT 1
84915: PUSH
84916: EMPTY
84917: LIST
84918: LIST
84919: PUSH
84920: LD_INT 0
84922: PUSH
84923: LD_INT 1
84925: PUSH
84926: EMPTY
84927: LIST
84928: LIST
84929: PUSH
84930: LD_INT 1
84932: NEG
84933: PUSH
84934: LD_INT 0
84936: PUSH
84937: EMPTY
84938: LIST
84939: LIST
84940: PUSH
84941: LD_INT 1
84943: NEG
84944: PUSH
84945: LD_INT 1
84947: NEG
84948: PUSH
84949: EMPTY
84950: LIST
84951: LIST
84952: PUSH
84953: LD_INT 1
84955: PUSH
84956: LD_INT 1
84958: NEG
84959: PUSH
84960: EMPTY
84961: LIST
84962: LIST
84963: PUSH
84964: LD_INT 2
84966: PUSH
84967: LD_INT 0
84969: PUSH
84970: EMPTY
84971: LIST
84972: LIST
84973: PUSH
84974: LD_INT 2
84976: PUSH
84977: LD_INT 1
84979: PUSH
84980: EMPTY
84981: LIST
84982: LIST
84983: PUSH
84984: LD_INT 1
84986: NEG
84987: PUSH
84988: LD_INT 1
84990: PUSH
84991: EMPTY
84992: LIST
84993: LIST
84994: PUSH
84995: LD_INT 2
84997: NEG
84998: PUSH
84999: LD_INT 0
85001: PUSH
85002: EMPTY
85003: LIST
85004: LIST
85005: PUSH
85006: LD_INT 2
85008: NEG
85009: PUSH
85010: LD_INT 1
85012: NEG
85013: PUSH
85014: EMPTY
85015: LIST
85016: LIST
85017: PUSH
85018: LD_INT 2
85020: PUSH
85021: LD_INT 1
85023: NEG
85024: PUSH
85025: EMPTY
85026: LIST
85027: LIST
85028: PUSH
85029: LD_INT 3
85031: PUSH
85032: LD_INT 0
85034: PUSH
85035: EMPTY
85036: LIST
85037: LIST
85038: PUSH
85039: LD_INT 3
85041: PUSH
85042: LD_INT 1
85044: PUSH
85045: EMPTY
85046: LIST
85047: LIST
85048: PUSH
85049: EMPTY
85050: LIST
85051: LIST
85052: LIST
85053: LIST
85054: LIST
85055: LIST
85056: LIST
85057: LIST
85058: LIST
85059: LIST
85060: LIST
85061: LIST
85062: LIST
85063: LIST
85064: LIST
85065: LIST
85066: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
85067: LD_ADDR_VAR 0 16
85071: PUSH
85072: LD_INT 0
85074: PUSH
85075: LD_INT 0
85077: PUSH
85078: EMPTY
85079: LIST
85080: LIST
85081: PUSH
85082: LD_INT 0
85084: PUSH
85085: LD_INT 1
85087: NEG
85088: PUSH
85089: EMPTY
85090: LIST
85091: LIST
85092: PUSH
85093: LD_INT 1
85095: PUSH
85096: LD_INT 0
85098: PUSH
85099: EMPTY
85100: LIST
85101: LIST
85102: PUSH
85103: LD_INT 1
85105: PUSH
85106: LD_INT 1
85108: PUSH
85109: EMPTY
85110: LIST
85111: LIST
85112: PUSH
85113: LD_INT 0
85115: PUSH
85116: LD_INT 1
85118: PUSH
85119: EMPTY
85120: LIST
85121: LIST
85122: PUSH
85123: LD_INT 1
85125: NEG
85126: PUSH
85127: LD_INT 0
85129: PUSH
85130: EMPTY
85131: LIST
85132: LIST
85133: PUSH
85134: LD_INT 1
85136: NEG
85137: PUSH
85138: LD_INT 1
85140: NEG
85141: PUSH
85142: EMPTY
85143: LIST
85144: LIST
85145: PUSH
85146: LD_INT 1
85148: NEG
85149: PUSH
85150: LD_INT 2
85152: NEG
85153: PUSH
85154: EMPTY
85155: LIST
85156: LIST
85157: PUSH
85158: LD_INT 2
85160: PUSH
85161: LD_INT 1
85163: PUSH
85164: EMPTY
85165: LIST
85166: LIST
85167: PUSH
85168: LD_INT 2
85170: PUSH
85171: LD_INT 2
85173: PUSH
85174: EMPTY
85175: LIST
85176: LIST
85177: PUSH
85178: LD_INT 1
85180: PUSH
85181: LD_INT 2
85183: PUSH
85184: EMPTY
85185: LIST
85186: LIST
85187: PUSH
85188: LD_INT 2
85190: NEG
85191: PUSH
85192: LD_INT 1
85194: NEG
85195: PUSH
85196: EMPTY
85197: LIST
85198: LIST
85199: PUSH
85200: LD_INT 2
85202: NEG
85203: PUSH
85204: LD_INT 2
85206: NEG
85207: PUSH
85208: EMPTY
85209: LIST
85210: LIST
85211: PUSH
85212: LD_INT 3
85214: PUSH
85215: LD_INT 2
85217: PUSH
85218: EMPTY
85219: LIST
85220: LIST
85221: PUSH
85222: LD_INT 3
85224: PUSH
85225: LD_INT 3
85227: PUSH
85228: EMPTY
85229: LIST
85230: LIST
85231: PUSH
85232: LD_INT 2
85234: PUSH
85235: LD_INT 3
85237: PUSH
85238: EMPTY
85239: LIST
85240: LIST
85241: PUSH
85242: EMPTY
85243: LIST
85244: LIST
85245: LIST
85246: LIST
85247: LIST
85248: LIST
85249: LIST
85250: LIST
85251: LIST
85252: LIST
85253: LIST
85254: LIST
85255: LIST
85256: LIST
85257: LIST
85258: LIST
85259: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85260: LD_ADDR_VAR 0 17
85264: PUSH
85265: LD_INT 0
85267: PUSH
85268: LD_INT 0
85270: PUSH
85271: EMPTY
85272: LIST
85273: LIST
85274: PUSH
85275: LD_INT 0
85277: PUSH
85278: LD_INT 1
85280: NEG
85281: PUSH
85282: EMPTY
85283: LIST
85284: LIST
85285: PUSH
85286: LD_INT 1
85288: PUSH
85289: LD_INT 0
85291: PUSH
85292: EMPTY
85293: LIST
85294: LIST
85295: PUSH
85296: LD_INT 1
85298: PUSH
85299: LD_INT 1
85301: PUSH
85302: EMPTY
85303: LIST
85304: LIST
85305: PUSH
85306: LD_INT 0
85308: PUSH
85309: LD_INT 1
85311: PUSH
85312: EMPTY
85313: LIST
85314: LIST
85315: PUSH
85316: LD_INT 1
85318: NEG
85319: PUSH
85320: LD_INT 0
85322: PUSH
85323: EMPTY
85324: LIST
85325: LIST
85326: PUSH
85327: LD_INT 1
85329: NEG
85330: PUSH
85331: LD_INT 1
85333: NEG
85334: PUSH
85335: EMPTY
85336: LIST
85337: LIST
85338: PUSH
85339: LD_INT 1
85341: NEG
85342: PUSH
85343: LD_INT 2
85345: NEG
85346: PUSH
85347: EMPTY
85348: LIST
85349: LIST
85350: PUSH
85351: LD_INT 0
85353: PUSH
85354: LD_INT 2
85356: NEG
85357: PUSH
85358: EMPTY
85359: LIST
85360: LIST
85361: PUSH
85362: LD_INT 1
85364: PUSH
85365: LD_INT 1
85367: NEG
85368: PUSH
85369: EMPTY
85370: LIST
85371: LIST
85372: PUSH
85373: LD_INT 2
85375: PUSH
85376: LD_INT 0
85378: PUSH
85379: EMPTY
85380: LIST
85381: LIST
85382: PUSH
85383: LD_INT 2
85385: PUSH
85386: LD_INT 1
85388: PUSH
85389: EMPTY
85390: LIST
85391: LIST
85392: PUSH
85393: LD_INT 2
85395: PUSH
85396: LD_INT 2
85398: PUSH
85399: EMPTY
85400: LIST
85401: LIST
85402: PUSH
85403: LD_INT 1
85405: PUSH
85406: LD_INT 2
85408: PUSH
85409: EMPTY
85410: LIST
85411: LIST
85412: PUSH
85413: LD_INT 0
85415: PUSH
85416: LD_INT 2
85418: PUSH
85419: EMPTY
85420: LIST
85421: LIST
85422: PUSH
85423: LD_INT 1
85425: NEG
85426: PUSH
85427: LD_INT 1
85429: PUSH
85430: EMPTY
85431: LIST
85432: LIST
85433: PUSH
85434: LD_INT 2
85436: NEG
85437: PUSH
85438: LD_INT 0
85440: PUSH
85441: EMPTY
85442: LIST
85443: LIST
85444: PUSH
85445: LD_INT 2
85447: NEG
85448: PUSH
85449: LD_INT 1
85451: NEG
85452: PUSH
85453: EMPTY
85454: LIST
85455: LIST
85456: PUSH
85457: LD_INT 2
85459: NEG
85460: PUSH
85461: LD_INT 2
85463: NEG
85464: PUSH
85465: EMPTY
85466: LIST
85467: LIST
85468: PUSH
85469: EMPTY
85470: LIST
85471: LIST
85472: LIST
85473: LIST
85474: LIST
85475: LIST
85476: LIST
85477: LIST
85478: LIST
85479: LIST
85480: LIST
85481: LIST
85482: LIST
85483: LIST
85484: LIST
85485: LIST
85486: LIST
85487: LIST
85488: LIST
85489: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85490: LD_ADDR_VAR 0 18
85494: PUSH
85495: LD_INT 0
85497: PUSH
85498: LD_INT 0
85500: PUSH
85501: EMPTY
85502: LIST
85503: LIST
85504: PUSH
85505: LD_INT 0
85507: PUSH
85508: LD_INT 1
85510: NEG
85511: PUSH
85512: EMPTY
85513: LIST
85514: LIST
85515: PUSH
85516: LD_INT 1
85518: PUSH
85519: LD_INT 0
85521: PUSH
85522: EMPTY
85523: LIST
85524: LIST
85525: PUSH
85526: LD_INT 1
85528: PUSH
85529: LD_INT 1
85531: PUSH
85532: EMPTY
85533: LIST
85534: LIST
85535: PUSH
85536: LD_INT 0
85538: PUSH
85539: LD_INT 1
85541: PUSH
85542: EMPTY
85543: LIST
85544: LIST
85545: PUSH
85546: LD_INT 1
85548: NEG
85549: PUSH
85550: LD_INT 0
85552: PUSH
85553: EMPTY
85554: LIST
85555: LIST
85556: PUSH
85557: LD_INT 1
85559: NEG
85560: PUSH
85561: LD_INT 1
85563: NEG
85564: PUSH
85565: EMPTY
85566: LIST
85567: LIST
85568: PUSH
85569: LD_INT 1
85571: NEG
85572: PUSH
85573: LD_INT 2
85575: NEG
85576: PUSH
85577: EMPTY
85578: LIST
85579: LIST
85580: PUSH
85581: LD_INT 0
85583: PUSH
85584: LD_INT 2
85586: NEG
85587: PUSH
85588: EMPTY
85589: LIST
85590: LIST
85591: PUSH
85592: LD_INT 1
85594: PUSH
85595: LD_INT 1
85597: NEG
85598: PUSH
85599: EMPTY
85600: LIST
85601: LIST
85602: PUSH
85603: LD_INT 2
85605: PUSH
85606: LD_INT 0
85608: PUSH
85609: EMPTY
85610: LIST
85611: LIST
85612: PUSH
85613: LD_INT 2
85615: PUSH
85616: LD_INT 1
85618: PUSH
85619: EMPTY
85620: LIST
85621: LIST
85622: PUSH
85623: LD_INT 2
85625: PUSH
85626: LD_INT 2
85628: PUSH
85629: EMPTY
85630: LIST
85631: LIST
85632: PUSH
85633: LD_INT 1
85635: PUSH
85636: LD_INT 2
85638: PUSH
85639: EMPTY
85640: LIST
85641: LIST
85642: PUSH
85643: LD_INT 0
85645: PUSH
85646: LD_INT 2
85648: PUSH
85649: EMPTY
85650: LIST
85651: LIST
85652: PUSH
85653: LD_INT 1
85655: NEG
85656: PUSH
85657: LD_INT 1
85659: PUSH
85660: EMPTY
85661: LIST
85662: LIST
85663: PUSH
85664: LD_INT 2
85666: NEG
85667: PUSH
85668: LD_INT 0
85670: PUSH
85671: EMPTY
85672: LIST
85673: LIST
85674: PUSH
85675: LD_INT 2
85677: NEG
85678: PUSH
85679: LD_INT 1
85681: NEG
85682: PUSH
85683: EMPTY
85684: LIST
85685: LIST
85686: PUSH
85687: LD_INT 2
85689: NEG
85690: PUSH
85691: LD_INT 2
85693: NEG
85694: PUSH
85695: EMPTY
85696: LIST
85697: LIST
85698: PUSH
85699: EMPTY
85700: LIST
85701: LIST
85702: LIST
85703: LIST
85704: LIST
85705: LIST
85706: LIST
85707: LIST
85708: LIST
85709: LIST
85710: LIST
85711: LIST
85712: LIST
85713: LIST
85714: LIST
85715: LIST
85716: LIST
85717: LIST
85718: LIST
85719: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85720: LD_ADDR_VAR 0 19
85724: PUSH
85725: LD_INT 0
85727: PUSH
85728: LD_INT 0
85730: PUSH
85731: EMPTY
85732: LIST
85733: LIST
85734: PUSH
85735: LD_INT 0
85737: PUSH
85738: LD_INT 1
85740: NEG
85741: PUSH
85742: EMPTY
85743: LIST
85744: LIST
85745: PUSH
85746: LD_INT 1
85748: PUSH
85749: LD_INT 0
85751: PUSH
85752: EMPTY
85753: LIST
85754: LIST
85755: PUSH
85756: LD_INT 1
85758: PUSH
85759: LD_INT 1
85761: PUSH
85762: EMPTY
85763: LIST
85764: LIST
85765: PUSH
85766: LD_INT 0
85768: PUSH
85769: LD_INT 1
85771: PUSH
85772: EMPTY
85773: LIST
85774: LIST
85775: PUSH
85776: LD_INT 1
85778: NEG
85779: PUSH
85780: LD_INT 0
85782: PUSH
85783: EMPTY
85784: LIST
85785: LIST
85786: PUSH
85787: LD_INT 1
85789: NEG
85790: PUSH
85791: LD_INT 1
85793: NEG
85794: PUSH
85795: EMPTY
85796: LIST
85797: LIST
85798: PUSH
85799: LD_INT 1
85801: NEG
85802: PUSH
85803: LD_INT 2
85805: NEG
85806: PUSH
85807: EMPTY
85808: LIST
85809: LIST
85810: PUSH
85811: LD_INT 0
85813: PUSH
85814: LD_INT 2
85816: NEG
85817: PUSH
85818: EMPTY
85819: LIST
85820: LIST
85821: PUSH
85822: LD_INT 1
85824: PUSH
85825: LD_INT 1
85827: NEG
85828: PUSH
85829: EMPTY
85830: LIST
85831: LIST
85832: PUSH
85833: LD_INT 2
85835: PUSH
85836: LD_INT 0
85838: PUSH
85839: EMPTY
85840: LIST
85841: LIST
85842: PUSH
85843: LD_INT 2
85845: PUSH
85846: LD_INT 1
85848: PUSH
85849: EMPTY
85850: LIST
85851: LIST
85852: PUSH
85853: LD_INT 2
85855: PUSH
85856: LD_INT 2
85858: PUSH
85859: EMPTY
85860: LIST
85861: LIST
85862: PUSH
85863: LD_INT 1
85865: PUSH
85866: LD_INT 2
85868: PUSH
85869: EMPTY
85870: LIST
85871: LIST
85872: PUSH
85873: LD_INT 0
85875: PUSH
85876: LD_INT 2
85878: PUSH
85879: EMPTY
85880: LIST
85881: LIST
85882: PUSH
85883: LD_INT 1
85885: NEG
85886: PUSH
85887: LD_INT 1
85889: PUSH
85890: EMPTY
85891: LIST
85892: LIST
85893: PUSH
85894: LD_INT 2
85896: NEG
85897: PUSH
85898: LD_INT 0
85900: PUSH
85901: EMPTY
85902: LIST
85903: LIST
85904: PUSH
85905: LD_INT 2
85907: NEG
85908: PUSH
85909: LD_INT 1
85911: NEG
85912: PUSH
85913: EMPTY
85914: LIST
85915: LIST
85916: PUSH
85917: LD_INT 2
85919: NEG
85920: PUSH
85921: LD_INT 2
85923: NEG
85924: PUSH
85925: EMPTY
85926: LIST
85927: LIST
85928: PUSH
85929: EMPTY
85930: LIST
85931: LIST
85932: LIST
85933: LIST
85934: LIST
85935: LIST
85936: LIST
85937: LIST
85938: LIST
85939: LIST
85940: LIST
85941: LIST
85942: LIST
85943: LIST
85944: LIST
85945: LIST
85946: LIST
85947: LIST
85948: LIST
85949: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85950: LD_ADDR_VAR 0 20
85954: PUSH
85955: LD_INT 0
85957: PUSH
85958: LD_INT 0
85960: PUSH
85961: EMPTY
85962: LIST
85963: LIST
85964: PUSH
85965: LD_INT 0
85967: PUSH
85968: LD_INT 1
85970: NEG
85971: PUSH
85972: EMPTY
85973: LIST
85974: LIST
85975: PUSH
85976: LD_INT 1
85978: PUSH
85979: LD_INT 0
85981: PUSH
85982: EMPTY
85983: LIST
85984: LIST
85985: PUSH
85986: LD_INT 1
85988: PUSH
85989: LD_INT 1
85991: PUSH
85992: EMPTY
85993: LIST
85994: LIST
85995: PUSH
85996: LD_INT 0
85998: PUSH
85999: LD_INT 1
86001: PUSH
86002: EMPTY
86003: LIST
86004: LIST
86005: PUSH
86006: LD_INT 1
86008: NEG
86009: PUSH
86010: LD_INT 0
86012: PUSH
86013: EMPTY
86014: LIST
86015: LIST
86016: PUSH
86017: LD_INT 1
86019: NEG
86020: PUSH
86021: LD_INT 1
86023: NEG
86024: PUSH
86025: EMPTY
86026: LIST
86027: LIST
86028: PUSH
86029: LD_INT 1
86031: NEG
86032: PUSH
86033: LD_INT 2
86035: NEG
86036: PUSH
86037: EMPTY
86038: LIST
86039: LIST
86040: PUSH
86041: LD_INT 0
86043: PUSH
86044: LD_INT 2
86046: NEG
86047: PUSH
86048: EMPTY
86049: LIST
86050: LIST
86051: PUSH
86052: LD_INT 1
86054: PUSH
86055: LD_INT 1
86057: NEG
86058: PUSH
86059: EMPTY
86060: LIST
86061: LIST
86062: PUSH
86063: LD_INT 2
86065: PUSH
86066: LD_INT 0
86068: PUSH
86069: EMPTY
86070: LIST
86071: LIST
86072: PUSH
86073: LD_INT 2
86075: PUSH
86076: LD_INT 1
86078: PUSH
86079: EMPTY
86080: LIST
86081: LIST
86082: PUSH
86083: LD_INT 2
86085: PUSH
86086: LD_INT 2
86088: PUSH
86089: EMPTY
86090: LIST
86091: LIST
86092: PUSH
86093: LD_INT 1
86095: PUSH
86096: LD_INT 2
86098: PUSH
86099: EMPTY
86100: LIST
86101: LIST
86102: PUSH
86103: LD_INT 0
86105: PUSH
86106: LD_INT 2
86108: PUSH
86109: EMPTY
86110: LIST
86111: LIST
86112: PUSH
86113: LD_INT 1
86115: NEG
86116: PUSH
86117: LD_INT 1
86119: PUSH
86120: EMPTY
86121: LIST
86122: LIST
86123: PUSH
86124: LD_INT 2
86126: NEG
86127: PUSH
86128: LD_INT 0
86130: PUSH
86131: EMPTY
86132: LIST
86133: LIST
86134: PUSH
86135: LD_INT 2
86137: NEG
86138: PUSH
86139: LD_INT 1
86141: NEG
86142: PUSH
86143: EMPTY
86144: LIST
86145: LIST
86146: PUSH
86147: LD_INT 2
86149: NEG
86150: PUSH
86151: LD_INT 2
86153: NEG
86154: PUSH
86155: EMPTY
86156: LIST
86157: LIST
86158: PUSH
86159: EMPTY
86160: LIST
86161: LIST
86162: LIST
86163: LIST
86164: LIST
86165: LIST
86166: LIST
86167: LIST
86168: LIST
86169: LIST
86170: LIST
86171: LIST
86172: LIST
86173: LIST
86174: LIST
86175: LIST
86176: LIST
86177: LIST
86178: LIST
86179: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86180: LD_ADDR_VAR 0 21
86184: PUSH
86185: LD_INT 0
86187: PUSH
86188: LD_INT 0
86190: PUSH
86191: EMPTY
86192: LIST
86193: LIST
86194: PUSH
86195: LD_INT 0
86197: PUSH
86198: LD_INT 1
86200: NEG
86201: PUSH
86202: EMPTY
86203: LIST
86204: LIST
86205: PUSH
86206: LD_INT 1
86208: PUSH
86209: LD_INT 0
86211: PUSH
86212: EMPTY
86213: LIST
86214: LIST
86215: PUSH
86216: LD_INT 1
86218: PUSH
86219: LD_INT 1
86221: PUSH
86222: EMPTY
86223: LIST
86224: LIST
86225: PUSH
86226: LD_INT 0
86228: PUSH
86229: LD_INT 1
86231: PUSH
86232: EMPTY
86233: LIST
86234: LIST
86235: PUSH
86236: LD_INT 1
86238: NEG
86239: PUSH
86240: LD_INT 0
86242: PUSH
86243: EMPTY
86244: LIST
86245: LIST
86246: PUSH
86247: LD_INT 1
86249: NEG
86250: PUSH
86251: LD_INT 1
86253: NEG
86254: PUSH
86255: EMPTY
86256: LIST
86257: LIST
86258: PUSH
86259: LD_INT 1
86261: NEG
86262: PUSH
86263: LD_INT 2
86265: NEG
86266: PUSH
86267: EMPTY
86268: LIST
86269: LIST
86270: PUSH
86271: LD_INT 0
86273: PUSH
86274: LD_INT 2
86276: NEG
86277: PUSH
86278: EMPTY
86279: LIST
86280: LIST
86281: PUSH
86282: LD_INT 1
86284: PUSH
86285: LD_INT 1
86287: NEG
86288: PUSH
86289: EMPTY
86290: LIST
86291: LIST
86292: PUSH
86293: LD_INT 2
86295: PUSH
86296: LD_INT 0
86298: PUSH
86299: EMPTY
86300: LIST
86301: LIST
86302: PUSH
86303: LD_INT 2
86305: PUSH
86306: LD_INT 1
86308: PUSH
86309: EMPTY
86310: LIST
86311: LIST
86312: PUSH
86313: LD_INT 2
86315: PUSH
86316: LD_INT 2
86318: PUSH
86319: EMPTY
86320: LIST
86321: LIST
86322: PUSH
86323: LD_INT 1
86325: PUSH
86326: LD_INT 2
86328: PUSH
86329: EMPTY
86330: LIST
86331: LIST
86332: PUSH
86333: LD_INT 0
86335: PUSH
86336: LD_INT 2
86338: PUSH
86339: EMPTY
86340: LIST
86341: LIST
86342: PUSH
86343: LD_INT 1
86345: NEG
86346: PUSH
86347: LD_INT 1
86349: PUSH
86350: EMPTY
86351: LIST
86352: LIST
86353: PUSH
86354: LD_INT 2
86356: NEG
86357: PUSH
86358: LD_INT 0
86360: PUSH
86361: EMPTY
86362: LIST
86363: LIST
86364: PUSH
86365: LD_INT 2
86367: NEG
86368: PUSH
86369: LD_INT 1
86371: NEG
86372: PUSH
86373: EMPTY
86374: LIST
86375: LIST
86376: PUSH
86377: LD_INT 2
86379: NEG
86380: PUSH
86381: LD_INT 2
86383: NEG
86384: PUSH
86385: EMPTY
86386: LIST
86387: LIST
86388: PUSH
86389: EMPTY
86390: LIST
86391: LIST
86392: LIST
86393: LIST
86394: LIST
86395: LIST
86396: LIST
86397: LIST
86398: LIST
86399: LIST
86400: LIST
86401: LIST
86402: LIST
86403: LIST
86404: LIST
86405: LIST
86406: LIST
86407: LIST
86408: LIST
86409: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86410: LD_ADDR_VAR 0 22
86414: PUSH
86415: LD_INT 0
86417: PUSH
86418: LD_INT 0
86420: PUSH
86421: EMPTY
86422: LIST
86423: LIST
86424: PUSH
86425: LD_INT 0
86427: PUSH
86428: LD_INT 1
86430: NEG
86431: PUSH
86432: EMPTY
86433: LIST
86434: LIST
86435: PUSH
86436: LD_INT 1
86438: PUSH
86439: LD_INT 0
86441: PUSH
86442: EMPTY
86443: LIST
86444: LIST
86445: PUSH
86446: LD_INT 1
86448: PUSH
86449: LD_INT 1
86451: PUSH
86452: EMPTY
86453: LIST
86454: LIST
86455: PUSH
86456: LD_INT 0
86458: PUSH
86459: LD_INT 1
86461: PUSH
86462: EMPTY
86463: LIST
86464: LIST
86465: PUSH
86466: LD_INT 1
86468: NEG
86469: PUSH
86470: LD_INT 0
86472: PUSH
86473: EMPTY
86474: LIST
86475: LIST
86476: PUSH
86477: LD_INT 1
86479: NEG
86480: PUSH
86481: LD_INT 1
86483: NEG
86484: PUSH
86485: EMPTY
86486: LIST
86487: LIST
86488: PUSH
86489: LD_INT 1
86491: NEG
86492: PUSH
86493: LD_INT 2
86495: NEG
86496: PUSH
86497: EMPTY
86498: LIST
86499: LIST
86500: PUSH
86501: LD_INT 0
86503: PUSH
86504: LD_INT 2
86506: NEG
86507: PUSH
86508: EMPTY
86509: LIST
86510: LIST
86511: PUSH
86512: LD_INT 1
86514: PUSH
86515: LD_INT 1
86517: NEG
86518: PUSH
86519: EMPTY
86520: LIST
86521: LIST
86522: PUSH
86523: LD_INT 2
86525: PUSH
86526: LD_INT 0
86528: PUSH
86529: EMPTY
86530: LIST
86531: LIST
86532: PUSH
86533: LD_INT 2
86535: PUSH
86536: LD_INT 1
86538: PUSH
86539: EMPTY
86540: LIST
86541: LIST
86542: PUSH
86543: LD_INT 2
86545: PUSH
86546: LD_INT 2
86548: PUSH
86549: EMPTY
86550: LIST
86551: LIST
86552: PUSH
86553: LD_INT 1
86555: PUSH
86556: LD_INT 2
86558: PUSH
86559: EMPTY
86560: LIST
86561: LIST
86562: PUSH
86563: LD_INT 0
86565: PUSH
86566: LD_INT 2
86568: PUSH
86569: EMPTY
86570: LIST
86571: LIST
86572: PUSH
86573: LD_INT 1
86575: NEG
86576: PUSH
86577: LD_INT 1
86579: PUSH
86580: EMPTY
86581: LIST
86582: LIST
86583: PUSH
86584: LD_INT 2
86586: NEG
86587: PUSH
86588: LD_INT 0
86590: PUSH
86591: EMPTY
86592: LIST
86593: LIST
86594: PUSH
86595: LD_INT 2
86597: NEG
86598: PUSH
86599: LD_INT 1
86601: NEG
86602: PUSH
86603: EMPTY
86604: LIST
86605: LIST
86606: PUSH
86607: LD_INT 2
86609: NEG
86610: PUSH
86611: LD_INT 2
86613: NEG
86614: PUSH
86615: EMPTY
86616: LIST
86617: LIST
86618: PUSH
86619: EMPTY
86620: LIST
86621: LIST
86622: LIST
86623: LIST
86624: LIST
86625: LIST
86626: LIST
86627: LIST
86628: LIST
86629: LIST
86630: LIST
86631: LIST
86632: LIST
86633: LIST
86634: LIST
86635: LIST
86636: LIST
86637: LIST
86638: LIST
86639: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
86640: LD_ADDR_VAR 0 23
86644: PUSH
86645: LD_INT 0
86647: PUSH
86648: LD_INT 0
86650: PUSH
86651: EMPTY
86652: LIST
86653: LIST
86654: PUSH
86655: LD_INT 0
86657: PUSH
86658: LD_INT 1
86660: NEG
86661: PUSH
86662: EMPTY
86663: LIST
86664: LIST
86665: PUSH
86666: LD_INT 1
86668: PUSH
86669: LD_INT 0
86671: PUSH
86672: EMPTY
86673: LIST
86674: LIST
86675: PUSH
86676: LD_INT 1
86678: PUSH
86679: LD_INT 1
86681: PUSH
86682: EMPTY
86683: LIST
86684: LIST
86685: PUSH
86686: LD_INT 0
86688: PUSH
86689: LD_INT 1
86691: PUSH
86692: EMPTY
86693: LIST
86694: LIST
86695: PUSH
86696: LD_INT 1
86698: NEG
86699: PUSH
86700: LD_INT 0
86702: PUSH
86703: EMPTY
86704: LIST
86705: LIST
86706: PUSH
86707: LD_INT 1
86709: NEG
86710: PUSH
86711: LD_INT 1
86713: NEG
86714: PUSH
86715: EMPTY
86716: LIST
86717: LIST
86718: PUSH
86719: LD_INT 1
86721: NEG
86722: PUSH
86723: LD_INT 2
86725: NEG
86726: PUSH
86727: EMPTY
86728: LIST
86729: LIST
86730: PUSH
86731: LD_INT 0
86733: PUSH
86734: LD_INT 2
86736: NEG
86737: PUSH
86738: EMPTY
86739: LIST
86740: LIST
86741: PUSH
86742: LD_INT 1
86744: PUSH
86745: LD_INT 1
86747: NEG
86748: PUSH
86749: EMPTY
86750: LIST
86751: LIST
86752: PUSH
86753: LD_INT 2
86755: PUSH
86756: LD_INT 0
86758: PUSH
86759: EMPTY
86760: LIST
86761: LIST
86762: PUSH
86763: LD_INT 2
86765: PUSH
86766: LD_INT 1
86768: PUSH
86769: EMPTY
86770: LIST
86771: LIST
86772: PUSH
86773: LD_INT 2
86775: PUSH
86776: LD_INT 2
86778: PUSH
86779: EMPTY
86780: LIST
86781: LIST
86782: PUSH
86783: LD_INT 1
86785: PUSH
86786: LD_INT 2
86788: PUSH
86789: EMPTY
86790: LIST
86791: LIST
86792: PUSH
86793: LD_INT 0
86795: PUSH
86796: LD_INT 2
86798: PUSH
86799: EMPTY
86800: LIST
86801: LIST
86802: PUSH
86803: LD_INT 1
86805: NEG
86806: PUSH
86807: LD_INT 1
86809: PUSH
86810: EMPTY
86811: LIST
86812: LIST
86813: PUSH
86814: LD_INT 2
86816: NEG
86817: PUSH
86818: LD_INT 0
86820: PUSH
86821: EMPTY
86822: LIST
86823: LIST
86824: PUSH
86825: LD_INT 2
86827: NEG
86828: PUSH
86829: LD_INT 1
86831: NEG
86832: PUSH
86833: EMPTY
86834: LIST
86835: LIST
86836: PUSH
86837: LD_INT 2
86839: NEG
86840: PUSH
86841: LD_INT 2
86843: NEG
86844: PUSH
86845: EMPTY
86846: LIST
86847: LIST
86848: PUSH
86849: LD_INT 2
86851: NEG
86852: PUSH
86853: LD_INT 3
86855: NEG
86856: PUSH
86857: EMPTY
86858: LIST
86859: LIST
86860: PUSH
86861: LD_INT 1
86863: NEG
86864: PUSH
86865: LD_INT 3
86867: NEG
86868: PUSH
86869: EMPTY
86870: LIST
86871: LIST
86872: PUSH
86873: LD_INT 1
86875: PUSH
86876: LD_INT 2
86878: NEG
86879: PUSH
86880: EMPTY
86881: LIST
86882: LIST
86883: PUSH
86884: LD_INT 2
86886: PUSH
86887: LD_INT 1
86889: NEG
86890: PUSH
86891: EMPTY
86892: LIST
86893: LIST
86894: PUSH
86895: EMPTY
86896: LIST
86897: LIST
86898: LIST
86899: LIST
86900: LIST
86901: LIST
86902: LIST
86903: LIST
86904: LIST
86905: LIST
86906: LIST
86907: LIST
86908: LIST
86909: LIST
86910: LIST
86911: LIST
86912: LIST
86913: LIST
86914: LIST
86915: LIST
86916: LIST
86917: LIST
86918: LIST
86919: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
86920: LD_ADDR_VAR 0 24
86924: PUSH
86925: LD_INT 0
86927: PUSH
86928: LD_INT 0
86930: PUSH
86931: EMPTY
86932: LIST
86933: LIST
86934: PUSH
86935: LD_INT 0
86937: PUSH
86938: LD_INT 1
86940: NEG
86941: PUSH
86942: EMPTY
86943: LIST
86944: LIST
86945: PUSH
86946: LD_INT 1
86948: PUSH
86949: LD_INT 0
86951: PUSH
86952: EMPTY
86953: LIST
86954: LIST
86955: PUSH
86956: LD_INT 1
86958: PUSH
86959: LD_INT 1
86961: PUSH
86962: EMPTY
86963: LIST
86964: LIST
86965: PUSH
86966: LD_INT 0
86968: PUSH
86969: LD_INT 1
86971: PUSH
86972: EMPTY
86973: LIST
86974: LIST
86975: PUSH
86976: LD_INT 1
86978: NEG
86979: PUSH
86980: LD_INT 0
86982: PUSH
86983: EMPTY
86984: LIST
86985: LIST
86986: PUSH
86987: LD_INT 1
86989: NEG
86990: PUSH
86991: LD_INT 1
86993: NEG
86994: PUSH
86995: EMPTY
86996: LIST
86997: LIST
86998: PUSH
86999: LD_INT 1
87001: NEG
87002: PUSH
87003: LD_INT 2
87005: NEG
87006: PUSH
87007: EMPTY
87008: LIST
87009: LIST
87010: PUSH
87011: LD_INT 0
87013: PUSH
87014: LD_INT 2
87016: NEG
87017: PUSH
87018: EMPTY
87019: LIST
87020: LIST
87021: PUSH
87022: LD_INT 1
87024: PUSH
87025: LD_INT 1
87027: NEG
87028: PUSH
87029: EMPTY
87030: LIST
87031: LIST
87032: PUSH
87033: LD_INT 2
87035: PUSH
87036: LD_INT 0
87038: PUSH
87039: EMPTY
87040: LIST
87041: LIST
87042: PUSH
87043: LD_INT 2
87045: PUSH
87046: LD_INT 1
87048: PUSH
87049: EMPTY
87050: LIST
87051: LIST
87052: PUSH
87053: LD_INT 2
87055: PUSH
87056: LD_INT 2
87058: PUSH
87059: EMPTY
87060: LIST
87061: LIST
87062: PUSH
87063: LD_INT 1
87065: PUSH
87066: LD_INT 2
87068: PUSH
87069: EMPTY
87070: LIST
87071: LIST
87072: PUSH
87073: LD_INT 0
87075: PUSH
87076: LD_INT 2
87078: PUSH
87079: EMPTY
87080: LIST
87081: LIST
87082: PUSH
87083: LD_INT 1
87085: NEG
87086: PUSH
87087: LD_INT 1
87089: PUSH
87090: EMPTY
87091: LIST
87092: LIST
87093: PUSH
87094: LD_INT 2
87096: NEG
87097: PUSH
87098: LD_INT 0
87100: PUSH
87101: EMPTY
87102: LIST
87103: LIST
87104: PUSH
87105: LD_INT 2
87107: NEG
87108: PUSH
87109: LD_INT 1
87111: NEG
87112: PUSH
87113: EMPTY
87114: LIST
87115: LIST
87116: PUSH
87117: LD_INT 2
87119: NEG
87120: PUSH
87121: LD_INT 2
87123: NEG
87124: PUSH
87125: EMPTY
87126: LIST
87127: LIST
87128: PUSH
87129: LD_INT 1
87131: PUSH
87132: LD_INT 2
87134: NEG
87135: PUSH
87136: EMPTY
87137: LIST
87138: LIST
87139: PUSH
87140: LD_INT 2
87142: PUSH
87143: LD_INT 1
87145: NEG
87146: PUSH
87147: EMPTY
87148: LIST
87149: LIST
87150: PUSH
87151: LD_INT 3
87153: PUSH
87154: LD_INT 1
87156: PUSH
87157: EMPTY
87158: LIST
87159: LIST
87160: PUSH
87161: LD_INT 3
87163: PUSH
87164: LD_INT 2
87166: PUSH
87167: EMPTY
87168: LIST
87169: LIST
87170: PUSH
87171: EMPTY
87172: LIST
87173: LIST
87174: LIST
87175: LIST
87176: LIST
87177: LIST
87178: LIST
87179: LIST
87180: LIST
87181: LIST
87182: LIST
87183: LIST
87184: LIST
87185: LIST
87186: LIST
87187: LIST
87188: LIST
87189: LIST
87190: LIST
87191: LIST
87192: LIST
87193: LIST
87194: LIST
87195: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
87196: LD_ADDR_VAR 0 25
87200: PUSH
87201: LD_INT 0
87203: PUSH
87204: LD_INT 0
87206: PUSH
87207: EMPTY
87208: LIST
87209: LIST
87210: PUSH
87211: LD_INT 0
87213: PUSH
87214: LD_INT 1
87216: NEG
87217: PUSH
87218: EMPTY
87219: LIST
87220: LIST
87221: PUSH
87222: LD_INT 1
87224: PUSH
87225: LD_INT 0
87227: PUSH
87228: EMPTY
87229: LIST
87230: LIST
87231: PUSH
87232: LD_INT 1
87234: PUSH
87235: LD_INT 1
87237: PUSH
87238: EMPTY
87239: LIST
87240: LIST
87241: PUSH
87242: LD_INT 0
87244: PUSH
87245: LD_INT 1
87247: PUSH
87248: EMPTY
87249: LIST
87250: LIST
87251: PUSH
87252: LD_INT 1
87254: NEG
87255: PUSH
87256: LD_INT 0
87258: PUSH
87259: EMPTY
87260: LIST
87261: LIST
87262: PUSH
87263: LD_INT 1
87265: NEG
87266: PUSH
87267: LD_INT 1
87269: NEG
87270: PUSH
87271: EMPTY
87272: LIST
87273: LIST
87274: PUSH
87275: LD_INT 1
87277: NEG
87278: PUSH
87279: LD_INT 2
87281: NEG
87282: PUSH
87283: EMPTY
87284: LIST
87285: LIST
87286: PUSH
87287: LD_INT 0
87289: PUSH
87290: LD_INT 2
87292: NEG
87293: PUSH
87294: EMPTY
87295: LIST
87296: LIST
87297: PUSH
87298: LD_INT 1
87300: PUSH
87301: LD_INT 1
87303: NEG
87304: PUSH
87305: EMPTY
87306: LIST
87307: LIST
87308: PUSH
87309: LD_INT 2
87311: PUSH
87312: LD_INT 0
87314: PUSH
87315: EMPTY
87316: LIST
87317: LIST
87318: PUSH
87319: LD_INT 2
87321: PUSH
87322: LD_INT 1
87324: PUSH
87325: EMPTY
87326: LIST
87327: LIST
87328: PUSH
87329: LD_INT 2
87331: PUSH
87332: LD_INT 2
87334: PUSH
87335: EMPTY
87336: LIST
87337: LIST
87338: PUSH
87339: LD_INT 1
87341: PUSH
87342: LD_INT 2
87344: PUSH
87345: EMPTY
87346: LIST
87347: LIST
87348: PUSH
87349: LD_INT 0
87351: PUSH
87352: LD_INT 2
87354: PUSH
87355: EMPTY
87356: LIST
87357: LIST
87358: PUSH
87359: LD_INT 1
87361: NEG
87362: PUSH
87363: LD_INT 1
87365: PUSH
87366: EMPTY
87367: LIST
87368: LIST
87369: PUSH
87370: LD_INT 2
87372: NEG
87373: PUSH
87374: LD_INT 0
87376: PUSH
87377: EMPTY
87378: LIST
87379: LIST
87380: PUSH
87381: LD_INT 2
87383: NEG
87384: PUSH
87385: LD_INT 1
87387: NEG
87388: PUSH
87389: EMPTY
87390: LIST
87391: LIST
87392: PUSH
87393: LD_INT 2
87395: NEG
87396: PUSH
87397: LD_INT 2
87399: NEG
87400: PUSH
87401: EMPTY
87402: LIST
87403: LIST
87404: PUSH
87405: LD_INT 3
87407: PUSH
87408: LD_INT 1
87410: PUSH
87411: EMPTY
87412: LIST
87413: LIST
87414: PUSH
87415: LD_INT 3
87417: PUSH
87418: LD_INT 2
87420: PUSH
87421: EMPTY
87422: LIST
87423: LIST
87424: PUSH
87425: LD_INT 2
87427: PUSH
87428: LD_INT 3
87430: PUSH
87431: EMPTY
87432: LIST
87433: LIST
87434: PUSH
87435: LD_INT 1
87437: PUSH
87438: LD_INT 3
87440: PUSH
87441: EMPTY
87442: LIST
87443: LIST
87444: PUSH
87445: EMPTY
87446: LIST
87447: LIST
87448: LIST
87449: LIST
87450: LIST
87451: LIST
87452: LIST
87453: LIST
87454: LIST
87455: LIST
87456: LIST
87457: LIST
87458: LIST
87459: LIST
87460: LIST
87461: LIST
87462: LIST
87463: LIST
87464: LIST
87465: LIST
87466: LIST
87467: LIST
87468: LIST
87469: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
87470: LD_ADDR_VAR 0 26
87474: PUSH
87475: LD_INT 0
87477: PUSH
87478: LD_INT 0
87480: PUSH
87481: EMPTY
87482: LIST
87483: LIST
87484: PUSH
87485: LD_INT 0
87487: PUSH
87488: LD_INT 1
87490: NEG
87491: PUSH
87492: EMPTY
87493: LIST
87494: LIST
87495: PUSH
87496: LD_INT 1
87498: PUSH
87499: LD_INT 0
87501: PUSH
87502: EMPTY
87503: LIST
87504: LIST
87505: PUSH
87506: LD_INT 1
87508: PUSH
87509: LD_INT 1
87511: PUSH
87512: EMPTY
87513: LIST
87514: LIST
87515: PUSH
87516: LD_INT 0
87518: PUSH
87519: LD_INT 1
87521: PUSH
87522: EMPTY
87523: LIST
87524: LIST
87525: PUSH
87526: LD_INT 1
87528: NEG
87529: PUSH
87530: LD_INT 0
87532: PUSH
87533: EMPTY
87534: LIST
87535: LIST
87536: PUSH
87537: LD_INT 1
87539: NEG
87540: PUSH
87541: LD_INT 1
87543: NEG
87544: PUSH
87545: EMPTY
87546: LIST
87547: LIST
87548: PUSH
87549: LD_INT 1
87551: NEG
87552: PUSH
87553: LD_INT 2
87555: NEG
87556: PUSH
87557: EMPTY
87558: LIST
87559: LIST
87560: PUSH
87561: LD_INT 0
87563: PUSH
87564: LD_INT 2
87566: NEG
87567: PUSH
87568: EMPTY
87569: LIST
87570: LIST
87571: PUSH
87572: LD_INT 1
87574: PUSH
87575: LD_INT 1
87577: NEG
87578: PUSH
87579: EMPTY
87580: LIST
87581: LIST
87582: PUSH
87583: LD_INT 2
87585: PUSH
87586: LD_INT 0
87588: PUSH
87589: EMPTY
87590: LIST
87591: LIST
87592: PUSH
87593: LD_INT 2
87595: PUSH
87596: LD_INT 1
87598: PUSH
87599: EMPTY
87600: LIST
87601: LIST
87602: PUSH
87603: LD_INT 2
87605: PUSH
87606: LD_INT 2
87608: PUSH
87609: EMPTY
87610: LIST
87611: LIST
87612: PUSH
87613: LD_INT 1
87615: PUSH
87616: LD_INT 2
87618: PUSH
87619: EMPTY
87620: LIST
87621: LIST
87622: PUSH
87623: LD_INT 0
87625: PUSH
87626: LD_INT 2
87628: PUSH
87629: EMPTY
87630: LIST
87631: LIST
87632: PUSH
87633: LD_INT 1
87635: NEG
87636: PUSH
87637: LD_INT 1
87639: PUSH
87640: EMPTY
87641: LIST
87642: LIST
87643: PUSH
87644: LD_INT 2
87646: NEG
87647: PUSH
87648: LD_INT 0
87650: PUSH
87651: EMPTY
87652: LIST
87653: LIST
87654: PUSH
87655: LD_INT 2
87657: NEG
87658: PUSH
87659: LD_INT 1
87661: NEG
87662: PUSH
87663: EMPTY
87664: LIST
87665: LIST
87666: PUSH
87667: LD_INT 2
87669: NEG
87670: PUSH
87671: LD_INT 2
87673: NEG
87674: PUSH
87675: EMPTY
87676: LIST
87677: LIST
87678: PUSH
87679: LD_INT 2
87681: PUSH
87682: LD_INT 3
87684: PUSH
87685: EMPTY
87686: LIST
87687: LIST
87688: PUSH
87689: LD_INT 1
87691: PUSH
87692: LD_INT 3
87694: PUSH
87695: EMPTY
87696: LIST
87697: LIST
87698: PUSH
87699: LD_INT 1
87701: NEG
87702: PUSH
87703: LD_INT 2
87705: PUSH
87706: EMPTY
87707: LIST
87708: LIST
87709: PUSH
87710: LD_INT 2
87712: NEG
87713: PUSH
87714: LD_INT 1
87716: PUSH
87717: EMPTY
87718: LIST
87719: LIST
87720: PUSH
87721: EMPTY
87722: LIST
87723: LIST
87724: LIST
87725: LIST
87726: LIST
87727: LIST
87728: LIST
87729: LIST
87730: LIST
87731: LIST
87732: LIST
87733: LIST
87734: LIST
87735: LIST
87736: LIST
87737: LIST
87738: LIST
87739: LIST
87740: LIST
87741: LIST
87742: LIST
87743: LIST
87744: LIST
87745: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
87746: LD_ADDR_VAR 0 27
87750: PUSH
87751: LD_INT 0
87753: PUSH
87754: LD_INT 0
87756: PUSH
87757: EMPTY
87758: LIST
87759: LIST
87760: PUSH
87761: LD_INT 0
87763: PUSH
87764: LD_INT 1
87766: NEG
87767: PUSH
87768: EMPTY
87769: LIST
87770: LIST
87771: PUSH
87772: LD_INT 1
87774: PUSH
87775: LD_INT 0
87777: PUSH
87778: EMPTY
87779: LIST
87780: LIST
87781: PUSH
87782: LD_INT 1
87784: PUSH
87785: LD_INT 1
87787: PUSH
87788: EMPTY
87789: LIST
87790: LIST
87791: PUSH
87792: LD_INT 0
87794: PUSH
87795: LD_INT 1
87797: PUSH
87798: EMPTY
87799: LIST
87800: LIST
87801: PUSH
87802: LD_INT 1
87804: NEG
87805: PUSH
87806: LD_INT 0
87808: PUSH
87809: EMPTY
87810: LIST
87811: LIST
87812: PUSH
87813: LD_INT 1
87815: NEG
87816: PUSH
87817: LD_INT 1
87819: NEG
87820: PUSH
87821: EMPTY
87822: LIST
87823: LIST
87824: PUSH
87825: LD_INT 1
87827: NEG
87828: PUSH
87829: LD_INT 2
87831: NEG
87832: PUSH
87833: EMPTY
87834: LIST
87835: LIST
87836: PUSH
87837: LD_INT 0
87839: PUSH
87840: LD_INT 2
87842: NEG
87843: PUSH
87844: EMPTY
87845: LIST
87846: LIST
87847: PUSH
87848: LD_INT 1
87850: PUSH
87851: LD_INT 1
87853: NEG
87854: PUSH
87855: EMPTY
87856: LIST
87857: LIST
87858: PUSH
87859: LD_INT 2
87861: PUSH
87862: LD_INT 0
87864: PUSH
87865: EMPTY
87866: LIST
87867: LIST
87868: PUSH
87869: LD_INT 2
87871: PUSH
87872: LD_INT 1
87874: PUSH
87875: EMPTY
87876: LIST
87877: LIST
87878: PUSH
87879: LD_INT 2
87881: PUSH
87882: LD_INT 2
87884: PUSH
87885: EMPTY
87886: LIST
87887: LIST
87888: PUSH
87889: LD_INT 1
87891: PUSH
87892: LD_INT 2
87894: PUSH
87895: EMPTY
87896: LIST
87897: LIST
87898: PUSH
87899: LD_INT 0
87901: PUSH
87902: LD_INT 2
87904: PUSH
87905: EMPTY
87906: LIST
87907: LIST
87908: PUSH
87909: LD_INT 1
87911: NEG
87912: PUSH
87913: LD_INT 1
87915: PUSH
87916: EMPTY
87917: LIST
87918: LIST
87919: PUSH
87920: LD_INT 2
87922: NEG
87923: PUSH
87924: LD_INT 0
87926: PUSH
87927: EMPTY
87928: LIST
87929: LIST
87930: PUSH
87931: LD_INT 2
87933: NEG
87934: PUSH
87935: LD_INT 1
87937: NEG
87938: PUSH
87939: EMPTY
87940: LIST
87941: LIST
87942: PUSH
87943: LD_INT 2
87945: NEG
87946: PUSH
87947: LD_INT 2
87949: NEG
87950: PUSH
87951: EMPTY
87952: LIST
87953: LIST
87954: PUSH
87955: LD_INT 1
87957: NEG
87958: PUSH
87959: LD_INT 2
87961: PUSH
87962: EMPTY
87963: LIST
87964: LIST
87965: PUSH
87966: LD_INT 2
87968: NEG
87969: PUSH
87970: LD_INT 1
87972: PUSH
87973: EMPTY
87974: LIST
87975: LIST
87976: PUSH
87977: LD_INT 3
87979: NEG
87980: PUSH
87981: LD_INT 1
87983: NEG
87984: PUSH
87985: EMPTY
87986: LIST
87987: LIST
87988: PUSH
87989: LD_INT 3
87991: NEG
87992: PUSH
87993: LD_INT 2
87995: NEG
87996: PUSH
87997: EMPTY
87998: LIST
87999: LIST
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: LIST
88005: LIST
88006: LIST
88007: LIST
88008: LIST
88009: LIST
88010: LIST
88011: LIST
88012: LIST
88013: LIST
88014: LIST
88015: LIST
88016: LIST
88017: LIST
88018: LIST
88019: LIST
88020: LIST
88021: LIST
88022: LIST
88023: LIST
88024: LIST
88025: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
88026: LD_ADDR_VAR 0 28
88030: PUSH
88031: LD_INT 0
88033: PUSH
88034: LD_INT 0
88036: PUSH
88037: EMPTY
88038: LIST
88039: LIST
88040: PUSH
88041: LD_INT 0
88043: PUSH
88044: LD_INT 1
88046: NEG
88047: PUSH
88048: EMPTY
88049: LIST
88050: LIST
88051: PUSH
88052: LD_INT 1
88054: PUSH
88055: LD_INT 0
88057: PUSH
88058: EMPTY
88059: LIST
88060: LIST
88061: PUSH
88062: LD_INT 1
88064: PUSH
88065: LD_INT 1
88067: PUSH
88068: EMPTY
88069: LIST
88070: LIST
88071: PUSH
88072: LD_INT 0
88074: PUSH
88075: LD_INT 1
88077: PUSH
88078: EMPTY
88079: LIST
88080: LIST
88081: PUSH
88082: LD_INT 1
88084: NEG
88085: PUSH
88086: LD_INT 0
88088: PUSH
88089: EMPTY
88090: LIST
88091: LIST
88092: PUSH
88093: LD_INT 1
88095: NEG
88096: PUSH
88097: LD_INT 1
88099: NEG
88100: PUSH
88101: EMPTY
88102: LIST
88103: LIST
88104: PUSH
88105: LD_INT 1
88107: NEG
88108: PUSH
88109: LD_INT 2
88111: NEG
88112: PUSH
88113: EMPTY
88114: LIST
88115: LIST
88116: PUSH
88117: LD_INT 0
88119: PUSH
88120: LD_INT 2
88122: NEG
88123: PUSH
88124: EMPTY
88125: LIST
88126: LIST
88127: PUSH
88128: LD_INT 1
88130: PUSH
88131: LD_INT 1
88133: NEG
88134: PUSH
88135: EMPTY
88136: LIST
88137: LIST
88138: PUSH
88139: LD_INT 2
88141: PUSH
88142: LD_INT 0
88144: PUSH
88145: EMPTY
88146: LIST
88147: LIST
88148: PUSH
88149: LD_INT 2
88151: PUSH
88152: LD_INT 1
88154: PUSH
88155: EMPTY
88156: LIST
88157: LIST
88158: PUSH
88159: LD_INT 2
88161: PUSH
88162: LD_INT 2
88164: PUSH
88165: EMPTY
88166: LIST
88167: LIST
88168: PUSH
88169: LD_INT 1
88171: PUSH
88172: LD_INT 2
88174: PUSH
88175: EMPTY
88176: LIST
88177: LIST
88178: PUSH
88179: LD_INT 0
88181: PUSH
88182: LD_INT 2
88184: PUSH
88185: EMPTY
88186: LIST
88187: LIST
88188: PUSH
88189: LD_INT 1
88191: NEG
88192: PUSH
88193: LD_INT 1
88195: PUSH
88196: EMPTY
88197: LIST
88198: LIST
88199: PUSH
88200: LD_INT 2
88202: NEG
88203: PUSH
88204: LD_INT 0
88206: PUSH
88207: EMPTY
88208: LIST
88209: LIST
88210: PUSH
88211: LD_INT 2
88213: NEG
88214: PUSH
88215: LD_INT 1
88217: NEG
88218: PUSH
88219: EMPTY
88220: LIST
88221: LIST
88222: PUSH
88223: LD_INT 2
88225: NEG
88226: PUSH
88227: LD_INT 2
88229: NEG
88230: PUSH
88231: EMPTY
88232: LIST
88233: LIST
88234: PUSH
88235: LD_INT 2
88237: NEG
88238: PUSH
88239: LD_INT 3
88241: NEG
88242: PUSH
88243: EMPTY
88244: LIST
88245: LIST
88246: PUSH
88247: LD_INT 1
88249: NEG
88250: PUSH
88251: LD_INT 3
88253: NEG
88254: PUSH
88255: EMPTY
88256: LIST
88257: LIST
88258: PUSH
88259: LD_INT 3
88261: NEG
88262: PUSH
88263: LD_INT 1
88265: NEG
88266: PUSH
88267: EMPTY
88268: LIST
88269: LIST
88270: PUSH
88271: LD_INT 3
88273: NEG
88274: PUSH
88275: LD_INT 2
88277: NEG
88278: PUSH
88279: EMPTY
88280: LIST
88281: LIST
88282: PUSH
88283: EMPTY
88284: LIST
88285: LIST
88286: LIST
88287: LIST
88288: LIST
88289: LIST
88290: LIST
88291: LIST
88292: LIST
88293: LIST
88294: LIST
88295: LIST
88296: LIST
88297: LIST
88298: LIST
88299: LIST
88300: LIST
88301: LIST
88302: LIST
88303: LIST
88304: LIST
88305: LIST
88306: LIST
88307: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
88308: LD_ADDR_VAR 0 29
88312: PUSH
88313: LD_INT 0
88315: PUSH
88316: LD_INT 0
88318: PUSH
88319: EMPTY
88320: LIST
88321: LIST
88322: PUSH
88323: LD_INT 0
88325: PUSH
88326: LD_INT 1
88328: NEG
88329: PUSH
88330: EMPTY
88331: LIST
88332: LIST
88333: PUSH
88334: LD_INT 1
88336: PUSH
88337: LD_INT 0
88339: PUSH
88340: EMPTY
88341: LIST
88342: LIST
88343: PUSH
88344: LD_INT 1
88346: PUSH
88347: LD_INT 1
88349: PUSH
88350: EMPTY
88351: LIST
88352: LIST
88353: PUSH
88354: LD_INT 0
88356: PUSH
88357: LD_INT 1
88359: PUSH
88360: EMPTY
88361: LIST
88362: LIST
88363: PUSH
88364: LD_INT 1
88366: NEG
88367: PUSH
88368: LD_INT 0
88370: PUSH
88371: EMPTY
88372: LIST
88373: LIST
88374: PUSH
88375: LD_INT 1
88377: NEG
88378: PUSH
88379: LD_INT 1
88381: NEG
88382: PUSH
88383: EMPTY
88384: LIST
88385: LIST
88386: PUSH
88387: LD_INT 1
88389: NEG
88390: PUSH
88391: LD_INT 2
88393: NEG
88394: PUSH
88395: EMPTY
88396: LIST
88397: LIST
88398: PUSH
88399: LD_INT 0
88401: PUSH
88402: LD_INT 2
88404: NEG
88405: PUSH
88406: EMPTY
88407: LIST
88408: LIST
88409: PUSH
88410: LD_INT 1
88412: PUSH
88413: LD_INT 1
88415: NEG
88416: PUSH
88417: EMPTY
88418: LIST
88419: LIST
88420: PUSH
88421: LD_INT 2
88423: PUSH
88424: LD_INT 0
88426: PUSH
88427: EMPTY
88428: LIST
88429: LIST
88430: PUSH
88431: LD_INT 2
88433: PUSH
88434: LD_INT 1
88436: PUSH
88437: EMPTY
88438: LIST
88439: LIST
88440: PUSH
88441: LD_INT 1
88443: PUSH
88444: LD_INT 2
88446: PUSH
88447: EMPTY
88448: LIST
88449: LIST
88450: PUSH
88451: LD_INT 0
88453: PUSH
88454: LD_INT 2
88456: PUSH
88457: EMPTY
88458: LIST
88459: LIST
88460: PUSH
88461: LD_INT 1
88463: NEG
88464: PUSH
88465: LD_INT 1
88467: PUSH
88468: EMPTY
88469: LIST
88470: LIST
88471: PUSH
88472: LD_INT 2
88474: NEG
88475: PUSH
88476: LD_INT 1
88478: NEG
88479: PUSH
88480: EMPTY
88481: LIST
88482: LIST
88483: PUSH
88484: LD_INT 2
88486: NEG
88487: PUSH
88488: LD_INT 2
88490: NEG
88491: PUSH
88492: EMPTY
88493: LIST
88494: LIST
88495: PUSH
88496: LD_INT 2
88498: NEG
88499: PUSH
88500: LD_INT 3
88502: NEG
88503: PUSH
88504: EMPTY
88505: LIST
88506: LIST
88507: PUSH
88508: LD_INT 2
88510: PUSH
88511: LD_INT 1
88513: NEG
88514: PUSH
88515: EMPTY
88516: LIST
88517: LIST
88518: PUSH
88519: LD_INT 3
88521: PUSH
88522: LD_INT 1
88524: PUSH
88525: EMPTY
88526: LIST
88527: LIST
88528: PUSH
88529: LD_INT 1
88531: PUSH
88532: LD_INT 3
88534: PUSH
88535: EMPTY
88536: LIST
88537: LIST
88538: PUSH
88539: LD_INT 1
88541: NEG
88542: PUSH
88543: LD_INT 2
88545: PUSH
88546: EMPTY
88547: LIST
88548: LIST
88549: PUSH
88550: LD_INT 3
88552: NEG
88553: PUSH
88554: LD_INT 2
88556: NEG
88557: PUSH
88558: EMPTY
88559: LIST
88560: LIST
88561: PUSH
88562: EMPTY
88563: LIST
88564: LIST
88565: LIST
88566: LIST
88567: LIST
88568: LIST
88569: LIST
88570: LIST
88571: LIST
88572: LIST
88573: LIST
88574: LIST
88575: LIST
88576: LIST
88577: LIST
88578: LIST
88579: LIST
88580: LIST
88581: LIST
88582: LIST
88583: LIST
88584: LIST
88585: LIST
88586: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
88587: LD_ADDR_VAR 0 30
88591: PUSH
88592: LD_INT 0
88594: PUSH
88595: LD_INT 0
88597: PUSH
88598: EMPTY
88599: LIST
88600: LIST
88601: PUSH
88602: LD_INT 0
88604: PUSH
88605: LD_INT 1
88607: NEG
88608: PUSH
88609: EMPTY
88610: LIST
88611: LIST
88612: PUSH
88613: LD_INT 1
88615: PUSH
88616: LD_INT 0
88618: PUSH
88619: EMPTY
88620: LIST
88621: LIST
88622: PUSH
88623: LD_INT 1
88625: PUSH
88626: LD_INT 1
88628: PUSH
88629: EMPTY
88630: LIST
88631: LIST
88632: PUSH
88633: LD_INT 0
88635: PUSH
88636: LD_INT 1
88638: PUSH
88639: EMPTY
88640: LIST
88641: LIST
88642: PUSH
88643: LD_INT 1
88645: NEG
88646: PUSH
88647: LD_INT 0
88649: PUSH
88650: EMPTY
88651: LIST
88652: LIST
88653: PUSH
88654: LD_INT 1
88656: NEG
88657: PUSH
88658: LD_INT 1
88660: NEG
88661: PUSH
88662: EMPTY
88663: LIST
88664: LIST
88665: PUSH
88666: LD_INT 1
88668: NEG
88669: PUSH
88670: LD_INT 2
88672: NEG
88673: PUSH
88674: EMPTY
88675: LIST
88676: LIST
88677: PUSH
88678: LD_INT 0
88680: PUSH
88681: LD_INT 2
88683: NEG
88684: PUSH
88685: EMPTY
88686: LIST
88687: LIST
88688: PUSH
88689: LD_INT 1
88691: PUSH
88692: LD_INT 1
88694: NEG
88695: PUSH
88696: EMPTY
88697: LIST
88698: LIST
88699: PUSH
88700: LD_INT 2
88702: PUSH
88703: LD_INT 0
88705: PUSH
88706: EMPTY
88707: LIST
88708: LIST
88709: PUSH
88710: LD_INT 2
88712: PUSH
88713: LD_INT 1
88715: PUSH
88716: EMPTY
88717: LIST
88718: LIST
88719: PUSH
88720: LD_INT 2
88722: PUSH
88723: LD_INT 2
88725: PUSH
88726: EMPTY
88727: LIST
88728: LIST
88729: PUSH
88730: LD_INT 1
88732: PUSH
88733: LD_INT 2
88735: PUSH
88736: EMPTY
88737: LIST
88738: LIST
88739: PUSH
88740: LD_INT 1
88742: NEG
88743: PUSH
88744: LD_INT 1
88746: PUSH
88747: EMPTY
88748: LIST
88749: LIST
88750: PUSH
88751: LD_INT 2
88753: NEG
88754: PUSH
88755: LD_INT 0
88757: PUSH
88758: EMPTY
88759: LIST
88760: LIST
88761: PUSH
88762: LD_INT 2
88764: NEG
88765: PUSH
88766: LD_INT 1
88768: NEG
88769: PUSH
88770: EMPTY
88771: LIST
88772: LIST
88773: PUSH
88774: LD_INT 1
88776: NEG
88777: PUSH
88778: LD_INT 3
88780: NEG
88781: PUSH
88782: EMPTY
88783: LIST
88784: LIST
88785: PUSH
88786: LD_INT 1
88788: PUSH
88789: LD_INT 2
88791: NEG
88792: PUSH
88793: EMPTY
88794: LIST
88795: LIST
88796: PUSH
88797: LD_INT 3
88799: PUSH
88800: LD_INT 2
88802: PUSH
88803: EMPTY
88804: LIST
88805: LIST
88806: PUSH
88807: LD_INT 2
88809: PUSH
88810: LD_INT 3
88812: PUSH
88813: EMPTY
88814: LIST
88815: LIST
88816: PUSH
88817: LD_INT 2
88819: NEG
88820: PUSH
88821: LD_INT 1
88823: PUSH
88824: EMPTY
88825: LIST
88826: LIST
88827: PUSH
88828: LD_INT 3
88830: NEG
88831: PUSH
88832: LD_INT 1
88834: NEG
88835: PUSH
88836: EMPTY
88837: LIST
88838: LIST
88839: PUSH
88840: EMPTY
88841: LIST
88842: LIST
88843: LIST
88844: LIST
88845: LIST
88846: LIST
88847: LIST
88848: LIST
88849: LIST
88850: LIST
88851: LIST
88852: LIST
88853: LIST
88854: LIST
88855: LIST
88856: LIST
88857: LIST
88858: LIST
88859: LIST
88860: LIST
88861: LIST
88862: LIST
88863: LIST
88864: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
88865: LD_ADDR_VAR 0 31
88869: PUSH
88870: LD_INT 0
88872: PUSH
88873: LD_INT 0
88875: PUSH
88876: EMPTY
88877: LIST
88878: LIST
88879: PUSH
88880: LD_INT 0
88882: PUSH
88883: LD_INT 1
88885: NEG
88886: PUSH
88887: EMPTY
88888: LIST
88889: LIST
88890: PUSH
88891: LD_INT 1
88893: PUSH
88894: LD_INT 0
88896: PUSH
88897: EMPTY
88898: LIST
88899: LIST
88900: PUSH
88901: LD_INT 1
88903: PUSH
88904: LD_INT 1
88906: PUSH
88907: EMPTY
88908: LIST
88909: LIST
88910: PUSH
88911: LD_INT 0
88913: PUSH
88914: LD_INT 1
88916: PUSH
88917: EMPTY
88918: LIST
88919: LIST
88920: PUSH
88921: LD_INT 1
88923: NEG
88924: PUSH
88925: LD_INT 0
88927: PUSH
88928: EMPTY
88929: LIST
88930: LIST
88931: PUSH
88932: LD_INT 1
88934: NEG
88935: PUSH
88936: LD_INT 1
88938: NEG
88939: PUSH
88940: EMPTY
88941: LIST
88942: LIST
88943: PUSH
88944: LD_INT 1
88946: NEG
88947: PUSH
88948: LD_INT 2
88950: NEG
88951: PUSH
88952: EMPTY
88953: LIST
88954: LIST
88955: PUSH
88956: LD_INT 1
88958: PUSH
88959: LD_INT 1
88961: NEG
88962: PUSH
88963: EMPTY
88964: LIST
88965: LIST
88966: PUSH
88967: LD_INT 2
88969: PUSH
88970: LD_INT 0
88972: PUSH
88973: EMPTY
88974: LIST
88975: LIST
88976: PUSH
88977: LD_INT 2
88979: PUSH
88980: LD_INT 1
88982: PUSH
88983: EMPTY
88984: LIST
88985: LIST
88986: PUSH
88987: LD_INT 2
88989: PUSH
88990: LD_INT 2
88992: PUSH
88993: EMPTY
88994: LIST
88995: LIST
88996: PUSH
88997: LD_INT 1
88999: PUSH
89000: LD_INT 2
89002: PUSH
89003: EMPTY
89004: LIST
89005: LIST
89006: PUSH
89007: LD_INT 0
89009: PUSH
89010: LD_INT 2
89012: PUSH
89013: EMPTY
89014: LIST
89015: LIST
89016: PUSH
89017: LD_INT 1
89019: NEG
89020: PUSH
89021: LD_INT 1
89023: PUSH
89024: EMPTY
89025: LIST
89026: LIST
89027: PUSH
89028: LD_INT 2
89030: NEG
89031: PUSH
89032: LD_INT 1
89034: NEG
89035: PUSH
89036: EMPTY
89037: LIST
89038: LIST
89039: PUSH
89040: LD_INT 2
89042: NEG
89043: PUSH
89044: LD_INT 2
89046: NEG
89047: PUSH
89048: EMPTY
89049: LIST
89050: LIST
89051: PUSH
89052: LD_INT 2
89054: NEG
89055: PUSH
89056: LD_INT 3
89058: NEG
89059: PUSH
89060: EMPTY
89061: LIST
89062: LIST
89063: PUSH
89064: LD_INT 2
89066: PUSH
89067: LD_INT 1
89069: NEG
89070: PUSH
89071: EMPTY
89072: LIST
89073: LIST
89074: PUSH
89075: LD_INT 3
89077: PUSH
89078: LD_INT 1
89080: PUSH
89081: EMPTY
89082: LIST
89083: LIST
89084: PUSH
89085: LD_INT 1
89087: PUSH
89088: LD_INT 3
89090: PUSH
89091: EMPTY
89092: LIST
89093: LIST
89094: PUSH
89095: LD_INT 1
89097: NEG
89098: PUSH
89099: LD_INT 2
89101: PUSH
89102: EMPTY
89103: LIST
89104: LIST
89105: PUSH
89106: LD_INT 3
89108: NEG
89109: PUSH
89110: LD_INT 2
89112: NEG
89113: PUSH
89114: EMPTY
89115: LIST
89116: LIST
89117: PUSH
89118: EMPTY
89119: LIST
89120: LIST
89121: LIST
89122: LIST
89123: LIST
89124: LIST
89125: LIST
89126: LIST
89127: LIST
89128: LIST
89129: LIST
89130: LIST
89131: LIST
89132: LIST
89133: LIST
89134: LIST
89135: LIST
89136: LIST
89137: LIST
89138: LIST
89139: LIST
89140: LIST
89141: LIST
89142: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
89143: LD_ADDR_VAR 0 32
89147: PUSH
89148: LD_INT 0
89150: PUSH
89151: LD_INT 0
89153: PUSH
89154: EMPTY
89155: LIST
89156: LIST
89157: PUSH
89158: LD_INT 0
89160: PUSH
89161: LD_INT 1
89163: NEG
89164: PUSH
89165: EMPTY
89166: LIST
89167: LIST
89168: PUSH
89169: LD_INT 1
89171: PUSH
89172: LD_INT 0
89174: PUSH
89175: EMPTY
89176: LIST
89177: LIST
89178: PUSH
89179: LD_INT 1
89181: PUSH
89182: LD_INT 1
89184: PUSH
89185: EMPTY
89186: LIST
89187: LIST
89188: PUSH
89189: LD_INT 0
89191: PUSH
89192: LD_INT 1
89194: PUSH
89195: EMPTY
89196: LIST
89197: LIST
89198: PUSH
89199: LD_INT 1
89201: NEG
89202: PUSH
89203: LD_INT 0
89205: PUSH
89206: EMPTY
89207: LIST
89208: LIST
89209: PUSH
89210: LD_INT 1
89212: NEG
89213: PUSH
89214: LD_INT 1
89216: NEG
89217: PUSH
89218: EMPTY
89219: LIST
89220: LIST
89221: PUSH
89222: LD_INT 1
89224: NEG
89225: PUSH
89226: LD_INT 2
89228: NEG
89229: PUSH
89230: EMPTY
89231: LIST
89232: LIST
89233: PUSH
89234: LD_INT 0
89236: PUSH
89237: LD_INT 2
89239: NEG
89240: PUSH
89241: EMPTY
89242: LIST
89243: LIST
89244: PUSH
89245: LD_INT 1
89247: PUSH
89248: LD_INT 1
89250: NEG
89251: PUSH
89252: EMPTY
89253: LIST
89254: LIST
89255: PUSH
89256: LD_INT 2
89258: PUSH
89259: LD_INT 1
89261: PUSH
89262: EMPTY
89263: LIST
89264: LIST
89265: PUSH
89266: LD_INT 2
89268: PUSH
89269: LD_INT 2
89271: PUSH
89272: EMPTY
89273: LIST
89274: LIST
89275: PUSH
89276: LD_INT 1
89278: PUSH
89279: LD_INT 2
89281: PUSH
89282: EMPTY
89283: LIST
89284: LIST
89285: PUSH
89286: LD_INT 0
89288: PUSH
89289: LD_INT 2
89291: PUSH
89292: EMPTY
89293: LIST
89294: LIST
89295: PUSH
89296: LD_INT 1
89298: NEG
89299: PUSH
89300: LD_INT 1
89302: PUSH
89303: EMPTY
89304: LIST
89305: LIST
89306: PUSH
89307: LD_INT 2
89309: NEG
89310: PUSH
89311: LD_INT 0
89313: PUSH
89314: EMPTY
89315: LIST
89316: LIST
89317: PUSH
89318: LD_INT 2
89320: NEG
89321: PUSH
89322: LD_INT 1
89324: NEG
89325: PUSH
89326: EMPTY
89327: LIST
89328: LIST
89329: PUSH
89330: LD_INT 1
89332: NEG
89333: PUSH
89334: LD_INT 3
89336: NEG
89337: PUSH
89338: EMPTY
89339: LIST
89340: LIST
89341: PUSH
89342: LD_INT 1
89344: PUSH
89345: LD_INT 2
89347: NEG
89348: PUSH
89349: EMPTY
89350: LIST
89351: LIST
89352: PUSH
89353: LD_INT 3
89355: PUSH
89356: LD_INT 2
89358: PUSH
89359: EMPTY
89360: LIST
89361: LIST
89362: PUSH
89363: LD_INT 2
89365: PUSH
89366: LD_INT 3
89368: PUSH
89369: EMPTY
89370: LIST
89371: LIST
89372: PUSH
89373: LD_INT 2
89375: NEG
89376: PUSH
89377: LD_INT 1
89379: PUSH
89380: EMPTY
89381: LIST
89382: LIST
89383: PUSH
89384: LD_INT 3
89386: NEG
89387: PUSH
89388: LD_INT 1
89390: NEG
89391: PUSH
89392: EMPTY
89393: LIST
89394: LIST
89395: PUSH
89396: EMPTY
89397: LIST
89398: LIST
89399: LIST
89400: LIST
89401: LIST
89402: LIST
89403: LIST
89404: LIST
89405: LIST
89406: LIST
89407: LIST
89408: LIST
89409: LIST
89410: LIST
89411: LIST
89412: LIST
89413: LIST
89414: LIST
89415: LIST
89416: LIST
89417: LIST
89418: LIST
89419: LIST
89420: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
89421: LD_ADDR_VAR 0 33
89425: PUSH
89426: LD_INT 0
89428: PUSH
89429: LD_INT 0
89431: PUSH
89432: EMPTY
89433: LIST
89434: LIST
89435: PUSH
89436: LD_INT 0
89438: PUSH
89439: LD_INT 1
89441: NEG
89442: PUSH
89443: EMPTY
89444: LIST
89445: LIST
89446: PUSH
89447: LD_INT 1
89449: PUSH
89450: LD_INT 0
89452: PUSH
89453: EMPTY
89454: LIST
89455: LIST
89456: PUSH
89457: LD_INT 1
89459: PUSH
89460: LD_INT 1
89462: PUSH
89463: EMPTY
89464: LIST
89465: LIST
89466: PUSH
89467: LD_INT 0
89469: PUSH
89470: LD_INT 1
89472: PUSH
89473: EMPTY
89474: LIST
89475: LIST
89476: PUSH
89477: LD_INT 1
89479: NEG
89480: PUSH
89481: LD_INT 0
89483: PUSH
89484: EMPTY
89485: LIST
89486: LIST
89487: PUSH
89488: LD_INT 1
89490: NEG
89491: PUSH
89492: LD_INT 1
89494: NEG
89495: PUSH
89496: EMPTY
89497: LIST
89498: LIST
89499: PUSH
89500: LD_INT 1
89502: NEG
89503: PUSH
89504: LD_INT 2
89506: NEG
89507: PUSH
89508: EMPTY
89509: LIST
89510: LIST
89511: PUSH
89512: LD_INT 1
89514: PUSH
89515: LD_INT 1
89517: NEG
89518: PUSH
89519: EMPTY
89520: LIST
89521: LIST
89522: PUSH
89523: LD_INT 2
89525: PUSH
89526: LD_INT 0
89528: PUSH
89529: EMPTY
89530: LIST
89531: LIST
89532: PUSH
89533: LD_INT 2
89535: PUSH
89536: LD_INT 1
89538: PUSH
89539: EMPTY
89540: LIST
89541: LIST
89542: PUSH
89543: LD_INT 1
89545: PUSH
89546: LD_INT 2
89548: PUSH
89549: EMPTY
89550: LIST
89551: LIST
89552: PUSH
89553: LD_INT 0
89555: PUSH
89556: LD_INT 2
89558: PUSH
89559: EMPTY
89560: LIST
89561: LIST
89562: PUSH
89563: LD_INT 1
89565: NEG
89566: PUSH
89567: LD_INT 1
89569: PUSH
89570: EMPTY
89571: LIST
89572: LIST
89573: PUSH
89574: LD_INT 2
89576: NEG
89577: PUSH
89578: LD_INT 0
89580: PUSH
89581: EMPTY
89582: LIST
89583: LIST
89584: PUSH
89585: LD_INT 2
89587: NEG
89588: PUSH
89589: LD_INT 1
89591: NEG
89592: PUSH
89593: EMPTY
89594: LIST
89595: LIST
89596: PUSH
89597: LD_INT 2
89599: NEG
89600: PUSH
89601: LD_INT 2
89603: NEG
89604: PUSH
89605: EMPTY
89606: LIST
89607: LIST
89608: PUSH
89609: LD_INT 2
89611: NEG
89612: PUSH
89613: LD_INT 3
89615: NEG
89616: PUSH
89617: EMPTY
89618: LIST
89619: LIST
89620: PUSH
89621: LD_INT 2
89623: PUSH
89624: LD_INT 1
89626: NEG
89627: PUSH
89628: EMPTY
89629: LIST
89630: LIST
89631: PUSH
89632: LD_INT 3
89634: PUSH
89635: LD_INT 1
89637: PUSH
89638: EMPTY
89639: LIST
89640: LIST
89641: PUSH
89642: LD_INT 1
89644: PUSH
89645: LD_INT 3
89647: PUSH
89648: EMPTY
89649: LIST
89650: LIST
89651: PUSH
89652: LD_INT 1
89654: NEG
89655: PUSH
89656: LD_INT 2
89658: PUSH
89659: EMPTY
89660: LIST
89661: LIST
89662: PUSH
89663: LD_INT 3
89665: NEG
89666: PUSH
89667: LD_INT 2
89669: NEG
89670: PUSH
89671: EMPTY
89672: LIST
89673: LIST
89674: PUSH
89675: EMPTY
89676: LIST
89677: LIST
89678: LIST
89679: LIST
89680: LIST
89681: LIST
89682: LIST
89683: LIST
89684: LIST
89685: LIST
89686: LIST
89687: LIST
89688: LIST
89689: LIST
89690: LIST
89691: LIST
89692: LIST
89693: LIST
89694: LIST
89695: LIST
89696: LIST
89697: LIST
89698: LIST
89699: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
89700: LD_ADDR_VAR 0 34
89704: PUSH
89705: LD_INT 0
89707: PUSH
89708: LD_INT 0
89710: PUSH
89711: EMPTY
89712: LIST
89713: LIST
89714: PUSH
89715: LD_INT 0
89717: PUSH
89718: LD_INT 1
89720: NEG
89721: PUSH
89722: EMPTY
89723: LIST
89724: LIST
89725: PUSH
89726: LD_INT 1
89728: PUSH
89729: LD_INT 0
89731: PUSH
89732: EMPTY
89733: LIST
89734: LIST
89735: PUSH
89736: LD_INT 1
89738: PUSH
89739: LD_INT 1
89741: PUSH
89742: EMPTY
89743: LIST
89744: LIST
89745: PUSH
89746: LD_INT 0
89748: PUSH
89749: LD_INT 1
89751: PUSH
89752: EMPTY
89753: LIST
89754: LIST
89755: PUSH
89756: LD_INT 1
89758: NEG
89759: PUSH
89760: LD_INT 0
89762: PUSH
89763: EMPTY
89764: LIST
89765: LIST
89766: PUSH
89767: LD_INT 1
89769: NEG
89770: PUSH
89771: LD_INT 1
89773: NEG
89774: PUSH
89775: EMPTY
89776: LIST
89777: LIST
89778: PUSH
89779: LD_INT 1
89781: NEG
89782: PUSH
89783: LD_INT 2
89785: NEG
89786: PUSH
89787: EMPTY
89788: LIST
89789: LIST
89790: PUSH
89791: LD_INT 0
89793: PUSH
89794: LD_INT 2
89796: NEG
89797: PUSH
89798: EMPTY
89799: LIST
89800: LIST
89801: PUSH
89802: LD_INT 1
89804: PUSH
89805: LD_INT 1
89807: NEG
89808: PUSH
89809: EMPTY
89810: LIST
89811: LIST
89812: PUSH
89813: LD_INT 2
89815: PUSH
89816: LD_INT 1
89818: PUSH
89819: EMPTY
89820: LIST
89821: LIST
89822: PUSH
89823: LD_INT 2
89825: PUSH
89826: LD_INT 2
89828: PUSH
89829: EMPTY
89830: LIST
89831: LIST
89832: PUSH
89833: LD_INT 1
89835: PUSH
89836: LD_INT 2
89838: PUSH
89839: EMPTY
89840: LIST
89841: LIST
89842: PUSH
89843: LD_INT 1
89845: NEG
89846: PUSH
89847: LD_INT 1
89849: PUSH
89850: EMPTY
89851: LIST
89852: LIST
89853: PUSH
89854: LD_INT 2
89856: NEG
89857: PUSH
89858: LD_INT 0
89860: PUSH
89861: EMPTY
89862: LIST
89863: LIST
89864: PUSH
89865: LD_INT 2
89867: NEG
89868: PUSH
89869: LD_INT 1
89871: NEG
89872: PUSH
89873: EMPTY
89874: LIST
89875: LIST
89876: PUSH
89877: LD_INT 2
89879: NEG
89880: PUSH
89881: LD_INT 2
89883: NEG
89884: PUSH
89885: EMPTY
89886: LIST
89887: LIST
89888: PUSH
89889: LD_INT 1
89891: NEG
89892: PUSH
89893: LD_INT 3
89895: NEG
89896: PUSH
89897: EMPTY
89898: LIST
89899: LIST
89900: PUSH
89901: LD_INT 1
89903: PUSH
89904: LD_INT 2
89906: NEG
89907: PUSH
89908: EMPTY
89909: LIST
89910: LIST
89911: PUSH
89912: LD_INT 3
89914: PUSH
89915: LD_INT 2
89917: PUSH
89918: EMPTY
89919: LIST
89920: LIST
89921: PUSH
89922: LD_INT 2
89924: PUSH
89925: LD_INT 3
89927: PUSH
89928: EMPTY
89929: LIST
89930: LIST
89931: PUSH
89932: LD_INT 2
89934: NEG
89935: PUSH
89936: LD_INT 1
89938: PUSH
89939: EMPTY
89940: LIST
89941: LIST
89942: PUSH
89943: LD_INT 3
89945: NEG
89946: PUSH
89947: LD_INT 1
89949: NEG
89950: PUSH
89951: EMPTY
89952: LIST
89953: LIST
89954: PUSH
89955: EMPTY
89956: LIST
89957: LIST
89958: LIST
89959: LIST
89960: LIST
89961: LIST
89962: LIST
89963: LIST
89964: LIST
89965: LIST
89966: LIST
89967: LIST
89968: LIST
89969: LIST
89970: LIST
89971: LIST
89972: LIST
89973: LIST
89974: LIST
89975: LIST
89976: LIST
89977: LIST
89978: LIST
89979: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
89980: LD_ADDR_VAR 0 35
89984: PUSH
89985: LD_INT 0
89987: PUSH
89988: LD_INT 0
89990: PUSH
89991: EMPTY
89992: LIST
89993: LIST
89994: PUSH
89995: LD_INT 0
89997: PUSH
89998: LD_INT 1
90000: NEG
90001: PUSH
90002: EMPTY
90003: LIST
90004: LIST
90005: PUSH
90006: LD_INT 1
90008: PUSH
90009: LD_INT 0
90011: PUSH
90012: EMPTY
90013: LIST
90014: LIST
90015: PUSH
90016: LD_INT 1
90018: PUSH
90019: LD_INT 1
90021: PUSH
90022: EMPTY
90023: LIST
90024: LIST
90025: PUSH
90026: LD_INT 0
90028: PUSH
90029: LD_INT 1
90031: PUSH
90032: EMPTY
90033: LIST
90034: LIST
90035: PUSH
90036: LD_INT 1
90038: NEG
90039: PUSH
90040: LD_INT 0
90042: PUSH
90043: EMPTY
90044: LIST
90045: LIST
90046: PUSH
90047: LD_INT 1
90049: NEG
90050: PUSH
90051: LD_INT 1
90053: NEG
90054: PUSH
90055: EMPTY
90056: LIST
90057: LIST
90058: PUSH
90059: LD_INT 2
90061: PUSH
90062: LD_INT 1
90064: PUSH
90065: EMPTY
90066: LIST
90067: LIST
90068: PUSH
90069: LD_INT 2
90071: NEG
90072: PUSH
90073: LD_INT 1
90075: NEG
90076: PUSH
90077: EMPTY
90078: LIST
90079: LIST
90080: PUSH
90081: EMPTY
90082: LIST
90083: LIST
90084: LIST
90085: LIST
90086: LIST
90087: LIST
90088: LIST
90089: LIST
90090: LIST
90091: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
90092: LD_ADDR_VAR 0 36
90096: PUSH
90097: LD_INT 0
90099: PUSH
90100: LD_INT 0
90102: PUSH
90103: EMPTY
90104: LIST
90105: LIST
90106: PUSH
90107: LD_INT 0
90109: PUSH
90110: LD_INT 1
90112: NEG
90113: PUSH
90114: EMPTY
90115: LIST
90116: LIST
90117: PUSH
90118: LD_INT 1
90120: PUSH
90121: LD_INT 0
90123: PUSH
90124: EMPTY
90125: LIST
90126: LIST
90127: PUSH
90128: LD_INT 1
90130: PUSH
90131: LD_INT 1
90133: PUSH
90134: EMPTY
90135: LIST
90136: LIST
90137: PUSH
90138: LD_INT 0
90140: PUSH
90141: LD_INT 1
90143: PUSH
90144: EMPTY
90145: LIST
90146: LIST
90147: PUSH
90148: LD_INT 1
90150: NEG
90151: PUSH
90152: LD_INT 0
90154: PUSH
90155: EMPTY
90156: LIST
90157: LIST
90158: PUSH
90159: LD_INT 1
90161: NEG
90162: PUSH
90163: LD_INT 1
90165: NEG
90166: PUSH
90167: EMPTY
90168: LIST
90169: LIST
90170: PUSH
90171: LD_INT 1
90173: NEG
90174: PUSH
90175: LD_INT 2
90177: NEG
90178: PUSH
90179: EMPTY
90180: LIST
90181: LIST
90182: PUSH
90183: LD_INT 1
90185: PUSH
90186: LD_INT 2
90188: PUSH
90189: EMPTY
90190: LIST
90191: LIST
90192: PUSH
90193: EMPTY
90194: LIST
90195: LIST
90196: LIST
90197: LIST
90198: LIST
90199: LIST
90200: LIST
90201: LIST
90202: LIST
90203: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
90204: LD_ADDR_VAR 0 37
90208: PUSH
90209: LD_INT 0
90211: PUSH
90212: LD_INT 0
90214: PUSH
90215: EMPTY
90216: LIST
90217: LIST
90218: PUSH
90219: LD_INT 0
90221: PUSH
90222: LD_INT 1
90224: NEG
90225: PUSH
90226: EMPTY
90227: LIST
90228: LIST
90229: PUSH
90230: LD_INT 1
90232: PUSH
90233: LD_INT 0
90235: PUSH
90236: EMPTY
90237: LIST
90238: LIST
90239: PUSH
90240: LD_INT 1
90242: PUSH
90243: LD_INT 1
90245: PUSH
90246: EMPTY
90247: LIST
90248: LIST
90249: PUSH
90250: LD_INT 0
90252: PUSH
90253: LD_INT 1
90255: PUSH
90256: EMPTY
90257: LIST
90258: LIST
90259: PUSH
90260: LD_INT 1
90262: NEG
90263: PUSH
90264: LD_INT 0
90266: PUSH
90267: EMPTY
90268: LIST
90269: LIST
90270: PUSH
90271: LD_INT 1
90273: NEG
90274: PUSH
90275: LD_INT 1
90277: NEG
90278: PUSH
90279: EMPTY
90280: LIST
90281: LIST
90282: PUSH
90283: LD_INT 1
90285: PUSH
90286: LD_INT 1
90288: NEG
90289: PUSH
90290: EMPTY
90291: LIST
90292: LIST
90293: PUSH
90294: LD_INT 1
90296: NEG
90297: PUSH
90298: LD_INT 1
90300: PUSH
90301: EMPTY
90302: LIST
90303: LIST
90304: PUSH
90305: EMPTY
90306: LIST
90307: LIST
90308: LIST
90309: LIST
90310: LIST
90311: LIST
90312: LIST
90313: LIST
90314: LIST
90315: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
90316: LD_ADDR_VAR 0 38
90320: PUSH
90321: LD_INT 0
90323: PUSH
90324: LD_INT 0
90326: PUSH
90327: EMPTY
90328: LIST
90329: LIST
90330: PUSH
90331: LD_INT 0
90333: PUSH
90334: LD_INT 1
90336: NEG
90337: PUSH
90338: EMPTY
90339: LIST
90340: LIST
90341: PUSH
90342: LD_INT 1
90344: PUSH
90345: LD_INT 0
90347: PUSH
90348: EMPTY
90349: LIST
90350: LIST
90351: PUSH
90352: LD_INT 1
90354: PUSH
90355: LD_INT 1
90357: PUSH
90358: EMPTY
90359: LIST
90360: LIST
90361: PUSH
90362: LD_INT 0
90364: PUSH
90365: LD_INT 1
90367: PUSH
90368: EMPTY
90369: LIST
90370: LIST
90371: PUSH
90372: LD_INT 1
90374: NEG
90375: PUSH
90376: LD_INT 0
90378: PUSH
90379: EMPTY
90380: LIST
90381: LIST
90382: PUSH
90383: LD_INT 1
90385: NEG
90386: PUSH
90387: LD_INT 1
90389: NEG
90390: PUSH
90391: EMPTY
90392: LIST
90393: LIST
90394: PUSH
90395: LD_INT 2
90397: PUSH
90398: LD_INT 1
90400: PUSH
90401: EMPTY
90402: LIST
90403: LIST
90404: PUSH
90405: LD_INT 2
90407: NEG
90408: PUSH
90409: LD_INT 1
90411: NEG
90412: PUSH
90413: EMPTY
90414: LIST
90415: LIST
90416: PUSH
90417: EMPTY
90418: LIST
90419: LIST
90420: LIST
90421: LIST
90422: LIST
90423: LIST
90424: LIST
90425: LIST
90426: LIST
90427: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
90428: LD_ADDR_VAR 0 39
90432: PUSH
90433: LD_INT 0
90435: PUSH
90436: LD_INT 0
90438: PUSH
90439: EMPTY
90440: LIST
90441: LIST
90442: PUSH
90443: LD_INT 0
90445: PUSH
90446: LD_INT 1
90448: NEG
90449: PUSH
90450: EMPTY
90451: LIST
90452: LIST
90453: PUSH
90454: LD_INT 1
90456: PUSH
90457: LD_INT 0
90459: PUSH
90460: EMPTY
90461: LIST
90462: LIST
90463: PUSH
90464: LD_INT 1
90466: PUSH
90467: LD_INT 1
90469: PUSH
90470: EMPTY
90471: LIST
90472: LIST
90473: PUSH
90474: LD_INT 0
90476: PUSH
90477: LD_INT 1
90479: PUSH
90480: EMPTY
90481: LIST
90482: LIST
90483: PUSH
90484: LD_INT 1
90486: NEG
90487: PUSH
90488: LD_INT 0
90490: PUSH
90491: EMPTY
90492: LIST
90493: LIST
90494: PUSH
90495: LD_INT 1
90497: NEG
90498: PUSH
90499: LD_INT 1
90501: NEG
90502: PUSH
90503: EMPTY
90504: LIST
90505: LIST
90506: PUSH
90507: LD_INT 1
90509: NEG
90510: PUSH
90511: LD_INT 2
90513: NEG
90514: PUSH
90515: EMPTY
90516: LIST
90517: LIST
90518: PUSH
90519: LD_INT 1
90521: PUSH
90522: LD_INT 2
90524: PUSH
90525: EMPTY
90526: LIST
90527: LIST
90528: PUSH
90529: EMPTY
90530: LIST
90531: LIST
90532: LIST
90533: LIST
90534: LIST
90535: LIST
90536: LIST
90537: LIST
90538: LIST
90539: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
90540: LD_ADDR_VAR 0 40
90544: PUSH
90545: LD_INT 0
90547: PUSH
90548: LD_INT 0
90550: PUSH
90551: EMPTY
90552: LIST
90553: LIST
90554: PUSH
90555: LD_INT 0
90557: PUSH
90558: LD_INT 1
90560: NEG
90561: PUSH
90562: EMPTY
90563: LIST
90564: LIST
90565: PUSH
90566: LD_INT 1
90568: PUSH
90569: LD_INT 0
90571: PUSH
90572: EMPTY
90573: LIST
90574: LIST
90575: PUSH
90576: LD_INT 1
90578: PUSH
90579: LD_INT 1
90581: PUSH
90582: EMPTY
90583: LIST
90584: LIST
90585: PUSH
90586: LD_INT 0
90588: PUSH
90589: LD_INT 1
90591: PUSH
90592: EMPTY
90593: LIST
90594: LIST
90595: PUSH
90596: LD_INT 1
90598: NEG
90599: PUSH
90600: LD_INT 0
90602: PUSH
90603: EMPTY
90604: LIST
90605: LIST
90606: PUSH
90607: LD_INT 1
90609: NEG
90610: PUSH
90611: LD_INT 1
90613: NEG
90614: PUSH
90615: EMPTY
90616: LIST
90617: LIST
90618: PUSH
90619: LD_INT 1
90621: PUSH
90622: LD_INT 1
90624: NEG
90625: PUSH
90626: EMPTY
90627: LIST
90628: LIST
90629: PUSH
90630: LD_INT 1
90632: NEG
90633: PUSH
90634: LD_INT 1
90636: PUSH
90637: EMPTY
90638: LIST
90639: LIST
90640: PUSH
90641: EMPTY
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: LIST
90647: LIST
90648: LIST
90649: LIST
90650: LIST
90651: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90652: LD_ADDR_VAR 0 41
90656: PUSH
90657: LD_INT 0
90659: PUSH
90660: LD_INT 0
90662: PUSH
90663: EMPTY
90664: LIST
90665: LIST
90666: PUSH
90667: LD_INT 0
90669: PUSH
90670: LD_INT 1
90672: NEG
90673: PUSH
90674: EMPTY
90675: LIST
90676: LIST
90677: PUSH
90678: LD_INT 1
90680: PUSH
90681: LD_INT 0
90683: PUSH
90684: EMPTY
90685: LIST
90686: LIST
90687: PUSH
90688: LD_INT 1
90690: PUSH
90691: LD_INT 1
90693: PUSH
90694: EMPTY
90695: LIST
90696: LIST
90697: PUSH
90698: LD_INT 0
90700: PUSH
90701: LD_INT 1
90703: PUSH
90704: EMPTY
90705: LIST
90706: LIST
90707: PUSH
90708: LD_INT 1
90710: NEG
90711: PUSH
90712: LD_INT 0
90714: PUSH
90715: EMPTY
90716: LIST
90717: LIST
90718: PUSH
90719: LD_INT 1
90721: NEG
90722: PUSH
90723: LD_INT 1
90725: NEG
90726: PUSH
90727: EMPTY
90728: LIST
90729: LIST
90730: PUSH
90731: LD_INT 1
90733: NEG
90734: PUSH
90735: LD_INT 2
90737: NEG
90738: PUSH
90739: EMPTY
90740: LIST
90741: LIST
90742: PUSH
90743: LD_INT 1
90745: PUSH
90746: LD_INT 1
90748: NEG
90749: PUSH
90750: EMPTY
90751: LIST
90752: LIST
90753: PUSH
90754: LD_INT 2
90756: PUSH
90757: LD_INT 0
90759: PUSH
90760: EMPTY
90761: LIST
90762: LIST
90763: PUSH
90764: LD_INT 2
90766: PUSH
90767: LD_INT 1
90769: PUSH
90770: EMPTY
90771: LIST
90772: LIST
90773: PUSH
90774: LD_INT 2
90776: PUSH
90777: LD_INT 2
90779: PUSH
90780: EMPTY
90781: LIST
90782: LIST
90783: PUSH
90784: LD_INT 1
90786: PUSH
90787: LD_INT 2
90789: PUSH
90790: EMPTY
90791: LIST
90792: LIST
90793: PUSH
90794: LD_INT 1
90796: NEG
90797: PUSH
90798: LD_INT 1
90800: PUSH
90801: EMPTY
90802: LIST
90803: LIST
90804: PUSH
90805: LD_INT 2
90807: NEG
90808: PUSH
90809: LD_INT 0
90811: PUSH
90812: EMPTY
90813: LIST
90814: LIST
90815: PUSH
90816: LD_INT 2
90818: NEG
90819: PUSH
90820: LD_INT 1
90822: NEG
90823: PUSH
90824: EMPTY
90825: LIST
90826: LIST
90827: PUSH
90828: LD_INT 2
90830: NEG
90831: PUSH
90832: LD_INT 2
90834: NEG
90835: PUSH
90836: EMPTY
90837: LIST
90838: LIST
90839: PUSH
90840: LD_INT 2
90842: NEG
90843: PUSH
90844: LD_INT 3
90846: NEG
90847: PUSH
90848: EMPTY
90849: LIST
90850: LIST
90851: PUSH
90852: LD_INT 2
90854: PUSH
90855: LD_INT 1
90857: NEG
90858: PUSH
90859: EMPTY
90860: LIST
90861: LIST
90862: PUSH
90863: LD_INT 3
90865: PUSH
90866: LD_INT 0
90868: PUSH
90869: EMPTY
90870: LIST
90871: LIST
90872: PUSH
90873: LD_INT 3
90875: PUSH
90876: LD_INT 1
90878: PUSH
90879: EMPTY
90880: LIST
90881: LIST
90882: PUSH
90883: LD_INT 3
90885: PUSH
90886: LD_INT 2
90888: PUSH
90889: EMPTY
90890: LIST
90891: LIST
90892: PUSH
90893: LD_INT 3
90895: PUSH
90896: LD_INT 3
90898: PUSH
90899: EMPTY
90900: LIST
90901: LIST
90902: PUSH
90903: LD_INT 2
90905: PUSH
90906: LD_INT 3
90908: PUSH
90909: EMPTY
90910: LIST
90911: LIST
90912: PUSH
90913: LD_INT 2
90915: NEG
90916: PUSH
90917: LD_INT 1
90919: PUSH
90920: EMPTY
90921: LIST
90922: LIST
90923: PUSH
90924: LD_INT 3
90926: NEG
90927: PUSH
90928: LD_INT 0
90930: PUSH
90931: EMPTY
90932: LIST
90933: LIST
90934: PUSH
90935: LD_INT 3
90937: NEG
90938: PUSH
90939: LD_INT 1
90941: NEG
90942: PUSH
90943: EMPTY
90944: LIST
90945: LIST
90946: PUSH
90947: LD_INT 3
90949: NEG
90950: PUSH
90951: LD_INT 2
90953: NEG
90954: PUSH
90955: EMPTY
90956: LIST
90957: LIST
90958: PUSH
90959: LD_INT 3
90961: NEG
90962: PUSH
90963: LD_INT 3
90965: NEG
90966: PUSH
90967: EMPTY
90968: LIST
90969: LIST
90970: PUSH
90971: EMPTY
90972: LIST
90973: LIST
90974: LIST
90975: LIST
90976: LIST
90977: LIST
90978: LIST
90979: LIST
90980: LIST
90981: LIST
90982: LIST
90983: LIST
90984: LIST
90985: LIST
90986: LIST
90987: LIST
90988: LIST
90989: LIST
90990: LIST
90991: LIST
90992: LIST
90993: LIST
90994: LIST
90995: LIST
90996: LIST
90997: LIST
90998: LIST
90999: LIST
91000: LIST
91001: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91002: LD_ADDR_VAR 0 42
91006: PUSH
91007: LD_INT 0
91009: PUSH
91010: LD_INT 0
91012: PUSH
91013: EMPTY
91014: LIST
91015: LIST
91016: PUSH
91017: LD_INT 0
91019: PUSH
91020: LD_INT 1
91022: NEG
91023: PUSH
91024: EMPTY
91025: LIST
91026: LIST
91027: PUSH
91028: LD_INT 1
91030: PUSH
91031: LD_INT 0
91033: PUSH
91034: EMPTY
91035: LIST
91036: LIST
91037: PUSH
91038: LD_INT 1
91040: PUSH
91041: LD_INT 1
91043: PUSH
91044: EMPTY
91045: LIST
91046: LIST
91047: PUSH
91048: LD_INT 0
91050: PUSH
91051: LD_INT 1
91053: PUSH
91054: EMPTY
91055: LIST
91056: LIST
91057: PUSH
91058: LD_INT 1
91060: NEG
91061: PUSH
91062: LD_INT 0
91064: PUSH
91065: EMPTY
91066: LIST
91067: LIST
91068: PUSH
91069: LD_INT 1
91071: NEG
91072: PUSH
91073: LD_INT 1
91075: NEG
91076: PUSH
91077: EMPTY
91078: LIST
91079: LIST
91080: PUSH
91081: LD_INT 1
91083: NEG
91084: PUSH
91085: LD_INT 2
91087: NEG
91088: PUSH
91089: EMPTY
91090: LIST
91091: LIST
91092: PUSH
91093: LD_INT 0
91095: PUSH
91096: LD_INT 2
91098: NEG
91099: PUSH
91100: EMPTY
91101: LIST
91102: LIST
91103: PUSH
91104: LD_INT 1
91106: PUSH
91107: LD_INT 1
91109: NEG
91110: PUSH
91111: EMPTY
91112: LIST
91113: LIST
91114: PUSH
91115: LD_INT 2
91117: PUSH
91118: LD_INT 1
91120: PUSH
91121: EMPTY
91122: LIST
91123: LIST
91124: PUSH
91125: LD_INT 2
91127: PUSH
91128: LD_INT 2
91130: PUSH
91131: EMPTY
91132: LIST
91133: LIST
91134: PUSH
91135: LD_INT 1
91137: PUSH
91138: LD_INT 2
91140: PUSH
91141: EMPTY
91142: LIST
91143: LIST
91144: PUSH
91145: LD_INT 0
91147: PUSH
91148: LD_INT 2
91150: PUSH
91151: EMPTY
91152: LIST
91153: LIST
91154: PUSH
91155: LD_INT 1
91157: NEG
91158: PUSH
91159: LD_INT 1
91161: PUSH
91162: EMPTY
91163: LIST
91164: LIST
91165: PUSH
91166: LD_INT 2
91168: NEG
91169: PUSH
91170: LD_INT 1
91172: NEG
91173: PUSH
91174: EMPTY
91175: LIST
91176: LIST
91177: PUSH
91178: LD_INT 2
91180: NEG
91181: PUSH
91182: LD_INT 2
91184: NEG
91185: PUSH
91186: EMPTY
91187: LIST
91188: LIST
91189: PUSH
91190: LD_INT 2
91192: NEG
91193: PUSH
91194: LD_INT 3
91196: NEG
91197: PUSH
91198: EMPTY
91199: LIST
91200: LIST
91201: PUSH
91202: LD_INT 1
91204: NEG
91205: PUSH
91206: LD_INT 3
91208: NEG
91209: PUSH
91210: EMPTY
91211: LIST
91212: LIST
91213: PUSH
91214: LD_INT 0
91216: PUSH
91217: LD_INT 3
91219: NEG
91220: PUSH
91221: EMPTY
91222: LIST
91223: LIST
91224: PUSH
91225: LD_INT 1
91227: PUSH
91228: LD_INT 2
91230: NEG
91231: PUSH
91232: EMPTY
91233: LIST
91234: LIST
91235: PUSH
91236: LD_INT 3
91238: PUSH
91239: LD_INT 2
91241: PUSH
91242: EMPTY
91243: LIST
91244: LIST
91245: PUSH
91246: LD_INT 3
91248: PUSH
91249: LD_INT 3
91251: PUSH
91252: EMPTY
91253: LIST
91254: LIST
91255: PUSH
91256: LD_INT 2
91258: PUSH
91259: LD_INT 3
91261: PUSH
91262: EMPTY
91263: LIST
91264: LIST
91265: PUSH
91266: LD_INT 1
91268: PUSH
91269: LD_INT 3
91271: PUSH
91272: EMPTY
91273: LIST
91274: LIST
91275: PUSH
91276: LD_INT 0
91278: PUSH
91279: LD_INT 3
91281: PUSH
91282: EMPTY
91283: LIST
91284: LIST
91285: PUSH
91286: LD_INT 1
91288: NEG
91289: PUSH
91290: LD_INT 2
91292: PUSH
91293: EMPTY
91294: LIST
91295: LIST
91296: PUSH
91297: LD_INT 3
91299: NEG
91300: PUSH
91301: LD_INT 2
91303: NEG
91304: PUSH
91305: EMPTY
91306: LIST
91307: LIST
91308: PUSH
91309: LD_INT 3
91311: NEG
91312: PUSH
91313: LD_INT 3
91315: NEG
91316: PUSH
91317: EMPTY
91318: LIST
91319: LIST
91320: PUSH
91321: EMPTY
91322: LIST
91323: LIST
91324: LIST
91325: LIST
91326: LIST
91327: LIST
91328: LIST
91329: LIST
91330: LIST
91331: LIST
91332: LIST
91333: LIST
91334: LIST
91335: LIST
91336: LIST
91337: LIST
91338: LIST
91339: LIST
91340: LIST
91341: LIST
91342: LIST
91343: LIST
91344: LIST
91345: LIST
91346: LIST
91347: LIST
91348: LIST
91349: LIST
91350: LIST
91351: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91352: LD_ADDR_VAR 0 43
91356: PUSH
91357: LD_INT 0
91359: PUSH
91360: LD_INT 0
91362: PUSH
91363: EMPTY
91364: LIST
91365: LIST
91366: PUSH
91367: LD_INT 0
91369: PUSH
91370: LD_INT 1
91372: NEG
91373: PUSH
91374: EMPTY
91375: LIST
91376: LIST
91377: PUSH
91378: LD_INT 1
91380: PUSH
91381: LD_INT 0
91383: PUSH
91384: EMPTY
91385: LIST
91386: LIST
91387: PUSH
91388: LD_INT 1
91390: PUSH
91391: LD_INT 1
91393: PUSH
91394: EMPTY
91395: LIST
91396: LIST
91397: PUSH
91398: LD_INT 0
91400: PUSH
91401: LD_INT 1
91403: PUSH
91404: EMPTY
91405: LIST
91406: LIST
91407: PUSH
91408: LD_INT 1
91410: NEG
91411: PUSH
91412: LD_INT 0
91414: PUSH
91415: EMPTY
91416: LIST
91417: LIST
91418: PUSH
91419: LD_INT 1
91421: NEG
91422: PUSH
91423: LD_INT 1
91425: NEG
91426: PUSH
91427: EMPTY
91428: LIST
91429: LIST
91430: PUSH
91431: LD_INT 1
91433: NEG
91434: PUSH
91435: LD_INT 2
91437: NEG
91438: PUSH
91439: EMPTY
91440: LIST
91441: LIST
91442: PUSH
91443: LD_INT 0
91445: PUSH
91446: LD_INT 2
91448: NEG
91449: PUSH
91450: EMPTY
91451: LIST
91452: LIST
91453: PUSH
91454: LD_INT 1
91456: PUSH
91457: LD_INT 1
91459: NEG
91460: PUSH
91461: EMPTY
91462: LIST
91463: LIST
91464: PUSH
91465: LD_INT 2
91467: PUSH
91468: LD_INT 0
91470: PUSH
91471: EMPTY
91472: LIST
91473: LIST
91474: PUSH
91475: LD_INT 2
91477: PUSH
91478: LD_INT 1
91480: PUSH
91481: EMPTY
91482: LIST
91483: LIST
91484: PUSH
91485: LD_INT 1
91487: PUSH
91488: LD_INT 2
91490: PUSH
91491: EMPTY
91492: LIST
91493: LIST
91494: PUSH
91495: LD_INT 0
91497: PUSH
91498: LD_INT 2
91500: PUSH
91501: EMPTY
91502: LIST
91503: LIST
91504: PUSH
91505: LD_INT 1
91507: NEG
91508: PUSH
91509: LD_INT 1
91511: PUSH
91512: EMPTY
91513: LIST
91514: LIST
91515: PUSH
91516: LD_INT 2
91518: NEG
91519: PUSH
91520: LD_INT 0
91522: PUSH
91523: EMPTY
91524: LIST
91525: LIST
91526: PUSH
91527: LD_INT 2
91529: NEG
91530: PUSH
91531: LD_INT 1
91533: NEG
91534: PUSH
91535: EMPTY
91536: LIST
91537: LIST
91538: PUSH
91539: LD_INT 1
91541: NEG
91542: PUSH
91543: LD_INT 3
91545: NEG
91546: PUSH
91547: EMPTY
91548: LIST
91549: LIST
91550: PUSH
91551: LD_INT 0
91553: PUSH
91554: LD_INT 3
91556: NEG
91557: PUSH
91558: EMPTY
91559: LIST
91560: LIST
91561: PUSH
91562: LD_INT 1
91564: PUSH
91565: LD_INT 2
91567: NEG
91568: PUSH
91569: EMPTY
91570: LIST
91571: LIST
91572: PUSH
91573: LD_INT 2
91575: PUSH
91576: LD_INT 1
91578: NEG
91579: PUSH
91580: EMPTY
91581: LIST
91582: LIST
91583: PUSH
91584: LD_INT 3
91586: PUSH
91587: LD_INT 0
91589: PUSH
91590: EMPTY
91591: LIST
91592: LIST
91593: PUSH
91594: LD_INT 3
91596: PUSH
91597: LD_INT 1
91599: PUSH
91600: EMPTY
91601: LIST
91602: LIST
91603: PUSH
91604: LD_INT 1
91606: PUSH
91607: LD_INT 3
91609: PUSH
91610: EMPTY
91611: LIST
91612: LIST
91613: PUSH
91614: LD_INT 0
91616: PUSH
91617: LD_INT 3
91619: PUSH
91620: EMPTY
91621: LIST
91622: LIST
91623: PUSH
91624: LD_INT 1
91626: NEG
91627: PUSH
91628: LD_INT 2
91630: PUSH
91631: EMPTY
91632: LIST
91633: LIST
91634: PUSH
91635: LD_INT 2
91637: NEG
91638: PUSH
91639: LD_INT 1
91641: PUSH
91642: EMPTY
91643: LIST
91644: LIST
91645: PUSH
91646: LD_INT 3
91648: NEG
91649: PUSH
91650: LD_INT 0
91652: PUSH
91653: EMPTY
91654: LIST
91655: LIST
91656: PUSH
91657: LD_INT 3
91659: NEG
91660: PUSH
91661: LD_INT 1
91663: NEG
91664: PUSH
91665: EMPTY
91666: LIST
91667: LIST
91668: PUSH
91669: EMPTY
91670: LIST
91671: LIST
91672: LIST
91673: LIST
91674: LIST
91675: LIST
91676: LIST
91677: LIST
91678: LIST
91679: LIST
91680: LIST
91681: LIST
91682: LIST
91683: LIST
91684: LIST
91685: LIST
91686: LIST
91687: LIST
91688: LIST
91689: LIST
91690: LIST
91691: LIST
91692: LIST
91693: LIST
91694: LIST
91695: LIST
91696: LIST
91697: LIST
91698: LIST
91699: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91700: LD_ADDR_VAR 0 44
91704: PUSH
91705: LD_INT 0
91707: PUSH
91708: LD_INT 0
91710: PUSH
91711: EMPTY
91712: LIST
91713: LIST
91714: PUSH
91715: LD_INT 0
91717: PUSH
91718: LD_INT 1
91720: NEG
91721: PUSH
91722: EMPTY
91723: LIST
91724: LIST
91725: PUSH
91726: LD_INT 1
91728: PUSH
91729: LD_INT 0
91731: PUSH
91732: EMPTY
91733: LIST
91734: LIST
91735: PUSH
91736: LD_INT 1
91738: PUSH
91739: LD_INT 1
91741: PUSH
91742: EMPTY
91743: LIST
91744: LIST
91745: PUSH
91746: LD_INT 0
91748: PUSH
91749: LD_INT 1
91751: PUSH
91752: EMPTY
91753: LIST
91754: LIST
91755: PUSH
91756: LD_INT 1
91758: NEG
91759: PUSH
91760: LD_INT 0
91762: PUSH
91763: EMPTY
91764: LIST
91765: LIST
91766: PUSH
91767: LD_INT 1
91769: NEG
91770: PUSH
91771: LD_INT 1
91773: NEG
91774: PUSH
91775: EMPTY
91776: LIST
91777: LIST
91778: PUSH
91779: LD_INT 1
91781: NEG
91782: PUSH
91783: LD_INT 2
91785: NEG
91786: PUSH
91787: EMPTY
91788: LIST
91789: LIST
91790: PUSH
91791: LD_INT 1
91793: PUSH
91794: LD_INT 1
91796: NEG
91797: PUSH
91798: EMPTY
91799: LIST
91800: LIST
91801: PUSH
91802: LD_INT 2
91804: PUSH
91805: LD_INT 0
91807: PUSH
91808: EMPTY
91809: LIST
91810: LIST
91811: PUSH
91812: LD_INT 2
91814: PUSH
91815: LD_INT 1
91817: PUSH
91818: EMPTY
91819: LIST
91820: LIST
91821: PUSH
91822: LD_INT 2
91824: PUSH
91825: LD_INT 2
91827: PUSH
91828: EMPTY
91829: LIST
91830: LIST
91831: PUSH
91832: LD_INT 1
91834: PUSH
91835: LD_INT 2
91837: PUSH
91838: EMPTY
91839: LIST
91840: LIST
91841: PUSH
91842: LD_INT 1
91844: NEG
91845: PUSH
91846: LD_INT 1
91848: PUSH
91849: EMPTY
91850: LIST
91851: LIST
91852: PUSH
91853: LD_INT 2
91855: NEG
91856: PUSH
91857: LD_INT 0
91859: PUSH
91860: EMPTY
91861: LIST
91862: LIST
91863: PUSH
91864: LD_INT 2
91866: NEG
91867: PUSH
91868: LD_INT 1
91870: NEG
91871: PUSH
91872: EMPTY
91873: LIST
91874: LIST
91875: PUSH
91876: LD_INT 2
91878: NEG
91879: PUSH
91880: LD_INT 2
91882: NEG
91883: PUSH
91884: EMPTY
91885: LIST
91886: LIST
91887: PUSH
91888: LD_INT 2
91890: NEG
91891: PUSH
91892: LD_INT 3
91894: NEG
91895: PUSH
91896: EMPTY
91897: LIST
91898: LIST
91899: PUSH
91900: LD_INT 2
91902: PUSH
91903: LD_INT 1
91905: NEG
91906: PUSH
91907: EMPTY
91908: LIST
91909: LIST
91910: PUSH
91911: LD_INT 3
91913: PUSH
91914: LD_INT 0
91916: PUSH
91917: EMPTY
91918: LIST
91919: LIST
91920: PUSH
91921: LD_INT 3
91923: PUSH
91924: LD_INT 1
91926: PUSH
91927: EMPTY
91928: LIST
91929: LIST
91930: PUSH
91931: LD_INT 3
91933: PUSH
91934: LD_INT 2
91936: PUSH
91937: EMPTY
91938: LIST
91939: LIST
91940: PUSH
91941: LD_INT 3
91943: PUSH
91944: LD_INT 3
91946: PUSH
91947: EMPTY
91948: LIST
91949: LIST
91950: PUSH
91951: LD_INT 2
91953: PUSH
91954: LD_INT 3
91956: PUSH
91957: EMPTY
91958: LIST
91959: LIST
91960: PUSH
91961: LD_INT 2
91963: NEG
91964: PUSH
91965: LD_INT 1
91967: PUSH
91968: EMPTY
91969: LIST
91970: LIST
91971: PUSH
91972: LD_INT 3
91974: NEG
91975: PUSH
91976: LD_INT 0
91978: PUSH
91979: EMPTY
91980: LIST
91981: LIST
91982: PUSH
91983: LD_INT 3
91985: NEG
91986: PUSH
91987: LD_INT 1
91989: NEG
91990: PUSH
91991: EMPTY
91992: LIST
91993: LIST
91994: PUSH
91995: LD_INT 3
91997: NEG
91998: PUSH
91999: LD_INT 2
92001: NEG
92002: PUSH
92003: EMPTY
92004: LIST
92005: LIST
92006: PUSH
92007: LD_INT 3
92009: NEG
92010: PUSH
92011: LD_INT 3
92013: NEG
92014: PUSH
92015: EMPTY
92016: LIST
92017: LIST
92018: PUSH
92019: EMPTY
92020: LIST
92021: LIST
92022: LIST
92023: LIST
92024: LIST
92025: LIST
92026: LIST
92027: LIST
92028: LIST
92029: LIST
92030: LIST
92031: LIST
92032: LIST
92033: LIST
92034: LIST
92035: LIST
92036: LIST
92037: LIST
92038: LIST
92039: LIST
92040: LIST
92041: LIST
92042: LIST
92043: LIST
92044: LIST
92045: LIST
92046: LIST
92047: LIST
92048: LIST
92049: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92050: LD_ADDR_VAR 0 45
92054: PUSH
92055: LD_INT 0
92057: PUSH
92058: LD_INT 0
92060: PUSH
92061: EMPTY
92062: LIST
92063: LIST
92064: PUSH
92065: LD_INT 0
92067: PUSH
92068: LD_INT 1
92070: NEG
92071: PUSH
92072: EMPTY
92073: LIST
92074: LIST
92075: PUSH
92076: LD_INT 1
92078: PUSH
92079: LD_INT 0
92081: PUSH
92082: EMPTY
92083: LIST
92084: LIST
92085: PUSH
92086: LD_INT 1
92088: PUSH
92089: LD_INT 1
92091: PUSH
92092: EMPTY
92093: LIST
92094: LIST
92095: PUSH
92096: LD_INT 0
92098: PUSH
92099: LD_INT 1
92101: PUSH
92102: EMPTY
92103: LIST
92104: LIST
92105: PUSH
92106: LD_INT 1
92108: NEG
92109: PUSH
92110: LD_INT 0
92112: PUSH
92113: EMPTY
92114: LIST
92115: LIST
92116: PUSH
92117: LD_INT 1
92119: NEG
92120: PUSH
92121: LD_INT 1
92123: NEG
92124: PUSH
92125: EMPTY
92126: LIST
92127: LIST
92128: PUSH
92129: LD_INT 1
92131: NEG
92132: PUSH
92133: LD_INT 2
92135: NEG
92136: PUSH
92137: EMPTY
92138: LIST
92139: LIST
92140: PUSH
92141: LD_INT 0
92143: PUSH
92144: LD_INT 2
92146: NEG
92147: PUSH
92148: EMPTY
92149: LIST
92150: LIST
92151: PUSH
92152: LD_INT 1
92154: PUSH
92155: LD_INT 1
92157: NEG
92158: PUSH
92159: EMPTY
92160: LIST
92161: LIST
92162: PUSH
92163: LD_INT 2
92165: PUSH
92166: LD_INT 1
92168: PUSH
92169: EMPTY
92170: LIST
92171: LIST
92172: PUSH
92173: LD_INT 2
92175: PUSH
92176: LD_INT 2
92178: PUSH
92179: EMPTY
92180: LIST
92181: LIST
92182: PUSH
92183: LD_INT 1
92185: PUSH
92186: LD_INT 2
92188: PUSH
92189: EMPTY
92190: LIST
92191: LIST
92192: PUSH
92193: LD_INT 0
92195: PUSH
92196: LD_INT 2
92198: PUSH
92199: EMPTY
92200: LIST
92201: LIST
92202: PUSH
92203: LD_INT 1
92205: NEG
92206: PUSH
92207: LD_INT 1
92209: PUSH
92210: EMPTY
92211: LIST
92212: LIST
92213: PUSH
92214: LD_INT 2
92216: NEG
92217: PUSH
92218: LD_INT 1
92220: NEG
92221: PUSH
92222: EMPTY
92223: LIST
92224: LIST
92225: PUSH
92226: LD_INT 2
92228: NEG
92229: PUSH
92230: LD_INT 2
92232: NEG
92233: PUSH
92234: EMPTY
92235: LIST
92236: LIST
92237: PUSH
92238: LD_INT 2
92240: NEG
92241: PUSH
92242: LD_INT 3
92244: NEG
92245: PUSH
92246: EMPTY
92247: LIST
92248: LIST
92249: PUSH
92250: LD_INT 1
92252: NEG
92253: PUSH
92254: LD_INT 3
92256: NEG
92257: PUSH
92258: EMPTY
92259: LIST
92260: LIST
92261: PUSH
92262: LD_INT 0
92264: PUSH
92265: LD_INT 3
92267: NEG
92268: PUSH
92269: EMPTY
92270: LIST
92271: LIST
92272: PUSH
92273: LD_INT 1
92275: PUSH
92276: LD_INT 2
92278: NEG
92279: PUSH
92280: EMPTY
92281: LIST
92282: LIST
92283: PUSH
92284: LD_INT 3
92286: PUSH
92287: LD_INT 2
92289: PUSH
92290: EMPTY
92291: LIST
92292: LIST
92293: PUSH
92294: LD_INT 3
92296: PUSH
92297: LD_INT 3
92299: PUSH
92300: EMPTY
92301: LIST
92302: LIST
92303: PUSH
92304: LD_INT 2
92306: PUSH
92307: LD_INT 3
92309: PUSH
92310: EMPTY
92311: LIST
92312: LIST
92313: PUSH
92314: LD_INT 1
92316: PUSH
92317: LD_INT 3
92319: PUSH
92320: EMPTY
92321: LIST
92322: LIST
92323: PUSH
92324: LD_INT 0
92326: PUSH
92327: LD_INT 3
92329: PUSH
92330: EMPTY
92331: LIST
92332: LIST
92333: PUSH
92334: LD_INT 1
92336: NEG
92337: PUSH
92338: LD_INT 2
92340: PUSH
92341: EMPTY
92342: LIST
92343: LIST
92344: PUSH
92345: LD_INT 3
92347: NEG
92348: PUSH
92349: LD_INT 2
92351: NEG
92352: PUSH
92353: EMPTY
92354: LIST
92355: LIST
92356: PUSH
92357: LD_INT 3
92359: NEG
92360: PUSH
92361: LD_INT 3
92363: NEG
92364: PUSH
92365: EMPTY
92366: LIST
92367: LIST
92368: PUSH
92369: EMPTY
92370: LIST
92371: LIST
92372: LIST
92373: LIST
92374: LIST
92375: LIST
92376: LIST
92377: LIST
92378: LIST
92379: LIST
92380: LIST
92381: LIST
92382: LIST
92383: LIST
92384: LIST
92385: LIST
92386: LIST
92387: LIST
92388: LIST
92389: LIST
92390: LIST
92391: LIST
92392: LIST
92393: LIST
92394: LIST
92395: LIST
92396: LIST
92397: LIST
92398: LIST
92399: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92400: LD_ADDR_VAR 0 46
92404: PUSH
92405: LD_INT 0
92407: PUSH
92408: LD_INT 0
92410: PUSH
92411: EMPTY
92412: LIST
92413: LIST
92414: PUSH
92415: LD_INT 0
92417: PUSH
92418: LD_INT 1
92420: NEG
92421: PUSH
92422: EMPTY
92423: LIST
92424: LIST
92425: PUSH
92426: LD_INT 1
92428: PUSH
92429: LD_INT 0
92431: PUSH
92432: EMPTY
92433: LIST
92434: LIST
92435: PUSH
92436: LD_INT 1
92438: PUSH
92439: LD_INT 1
92441: PUSH
92442: EMPTY
92443: LIST
92444: LIST
92445: PUSH
92446: LD_INT 0
92448: PUSH
92449: LD_INT 1
92451: PUSH
92452: EMPTY
92453: LIST
92454: LIST
92455: PUSH
92456: LD_INT 1
92458: NEG
92459: PUSH
92460: LD_INT 0
92462: PUSH
92463: EMPTY
92464: LIST
92465: LIST
92466: PUSH
92467: LD_INT 1
92469: NEG
92470: PUSH
92471: LD_INT 1
92473: NEG
92474: PUSH
92475: EMPTY
92476: LIST
92477: LIST
92478: PUSH
92479: LD_INT 1
92481: NEG
92482: PUSH
92483: LD_INT 2
92485: NEG
92486: PUSH
92487: EMPTY
92488: LIST
92489: LIST
92490: PUSH
92491: LD_INT 0
92493: PUSH
92494: LD_INT 2
92496: NEG
92497: PUSH
92498: EMPTY
92499: LIST
92500: LIST
92501: PUSH
92502: LD_INT 1
92504: PUSH
92505: LD_INT 1
92507: NEG
92508: PUSH
92509: EMPTY
92510: LIST
92511: LIST
92512: PUSH
92513: LD_INT 2
92515: PUSH
92516: LD_INT 0
92518: PUSH
92519: EMPTY
92520: LIST
92521: LIST
92522: PUSH
92523: LD_INT 2
92525: PUSH
92526: LD_INT 1
92528: PUSH
92529: EMPTY
92530: LIST
92531: LIST
92532: PUSH
92533: LD_INT 1
92535: PUSH
92536: LD_INT 2
92538: PUSH
92539: EMPTY
92540: LIST
92541: LIST
92542: PUSH
92543: LD_INT 0
92545: PUSH
92546: LD_INT 2
92548: PUSH
92549: EMPTY
92550: LIST
92551: LIST
92552: PUSH
92553: LD_INT 1
92555: NEG
92556: PUSH
92557: LD_INT 1
92559: PUSH
92560: EMPTY
92561: LIST
92562: LIST
92563: PUSH
92564: LD_INT 2
92566: NEG
92567: PUSH
92568: LD_INT 0
92570: PUSH
92571: EMPTY
92572: LIST
92573: LIST
92574: PUSH
92575: LD_INT 2
92577: NEG
92578: PUSH
92579: LD_INT 1
92581: NEG
92582: PUSH
92583: EMPTY
92584: LIST
92585: LIST
92586: PUSH
92587: LD_INT 1
92589: NEG
92590: PUSH
92591: LD_INT 3
92593: NEG
92594: PUSH
92595: EMPTY
92596: LIST
92597: LIST
92598: PUSH
92599: LD_INT 0
92601: PUSH
92602: LD_INT 3
92604: NEG
92605: PUSH
92606: EMPTY
92607: LIST
92608: LIST
92609: PUSH
92610: LD_INT 1
92612: PUSH
92613: LD_INT 2
92615: NEG
92616: PUSH
92617: EMPTY
92618: LIST
92619: LIST
92620: PUSH
92621: LD_INT 2
92623: PUSH
92624: LD_INT 1
92626: NEG
92627: PUSH
92628: EMPTY
92629: LIST
92630: LIST
92631: PUSH
92632: LD_INT 3
92634: PUSH
92635: LD_INT 0
92637: PUSH
92638: EMPTY
92639: LIST
92640: LIST
92641: PUSH
92642: LD_INT 3
92644: PUSH
92645: LD_INT 1
92647: PUSH
92648: EMPTY
92649: LIST
92650: LIST
92651: PUSH
92652: LD_INT 1
92654: PUSH
92655: LD_INT 3
92657: PUSH
92658: EMPTY
92659: LIST
92660: LIST
92661: PUSH
92662: LD_INT 0
92664: PUSH
92665: LD_INT 3
92667: PUSH
92668: EMPTY
92669: LIST
92670: LIST
92671: PUSH
92672: LD_INT 1
92674: NEG
92675: PUSH
92676: LD_INT 2
92678: PUSH
92679: EMPTY
92680: LIST
92681: LIST
92682: PUSH
92683: LD_INT 2
92685: NEG
92686: PUSH
92687: LD_INT 1
92689: PUSH
92690: EMPTY
92691: LIST
92692: LIST
92693: PUSH
92694: LD_INT 3
92696: NEG
92697: PUSH
92698: LD_INT 0
92700: PUSH
92701: EMPTY
92702: LIST
92703: LIST
92704: PUSH
92705: LD_INT 3
92707: NEG
92708: PUSH
92709: LD_INT 1
92711: NEG
92712: PUSH
92713: EMPTY
92714: LIST
92715: LIST
92716: PUSH
92717: EMPTY
92718: LIST
92719: LIST
92720: LIST
92721: LIST
92722: LIST
92723: LIST
92724: LIST
92725: LIST
92726: LIST
92727: LIST
92728: LIST
92729: LIST
92730: LIST
92731: LIST
92732: LIST
92733: LIST
92734: LIST
92735: LIST
92736: LIST
92737: LIST
92738: LIST
92739: LIST
92740: LIST
92741: LIST
92742: LIST
92743: LIST
92744: LIST
92745: LIST
92746: LIST
92747: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92748: LD_ADDR_VAR 0 47
92752: PUSH
92753: LD_INT 0
92755: PUSH
92756: LD_INT 0
92758: PUSH
92759: EMPTY
92760: LIST
92761: LIST
92762: PUSH
92763: LD_INT 0
92765: PUSH
92766: LD_INT 1
92768: NEG
92769: PUSH
92770: EMPTY
92771: LIST
92772: LIST
92773: PUSH
92774: LD_INT 1
92776: PUSH
92777: LD_INT 0
92779: PUSH
92780: EMPTY
92781: LIST
92782: LIST
92783: PUSH
92784: LD_INT 1
92786: PUSH
92787: LD_INT 1
92789: PUSH
92790: EMPTY
92791: LIST
92792: LIST
92793: PUSH
92794: LD_INT 0
92796: PUSH
92797: LD_INT 1
92799: PUSH
92800: EMPTY
92801: LIST
92802: LIST
92803: PUSH
92804: LD_INT 1
92806: NEG
92807: PUSH
92808: LD_INT 0
92810: PUSH
92811: EMPTY
92812: LIST
92813: LIST
92814: PUSH
92815: LD_INT 1
92817: NEG
92818: PUSH
92819: LD_INT 1
92821: NEG
92822: PUSH
92823: EMPTY
92824: LIST
92825: LIST
92826: PUSH
92827: LD_INT 1
92829: NEG
92830: PUSH
92831: LD_INT 2
92833: NEG
92834: PUSH
92835: EMPTY
92836: LIST
92837: LIST
92838: PUSH
92839: LD_INT 0
92841: PUSH
92842: LD_INT 2
92844: NEG
92845: PUSH
92846: EMPTY
92847: LIST
92848: LIST
92849: PUSH
92850: LD_INT 1
92852: PUSH
92853: LD_INT 1
92855: NEG
92856: PUSH
92857: EMPTY
92858: LIST
92859: LIST
92860: PUSH
92861: LD_INT 2
92863: NEG
92864: PUSH
92865: LD_INT 1
92867: NEG
92868: PUSH
92869: EMPTY
92870: LIST
92871: LIST
92872: PUSH
92873: LD_INT 2
92875: NEG
92876: PUSH
92877: LD_INT 2
92879: NEG
92880: PUSH
92881: EMPTY
92882: LIST
92883: LIST
92884: PUSH
92885: EMPTY
92886: LIST
92887: LIST
92888: LIST
92889: LIST
92890: LIST
92891: LIST
92892: LIST
92893: LIST
92894: LIST
92895: LIST
92896: LIST
92897: LIST
92898: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
92899: LD_ADDR_VAR 0 48
92903: PUSH
92904: LD_INT 0
92906: PUSH
92907: LD_INT 0
92909: PUSH
92910: EMPTY
92911: LIST
92912: LIST
92913: PUSH
92914: LD_INT 0
92916: PUSH
92917: LD_INT 1
92919: NEG
92920: PUSH
92921: EMPTY
92922: LIST
92923: LIST
92924: PUSH
92925: LD_INT 1
92927: PUSH
92928: LD_INT 0
92930: PUSH
92931: EMPTY
92932: LIST
92933: LIST
92934: PUSH
92935: LD_INT 1
92937: PUSH
92938: LD_INT 1
92940: PUSH
92941: EMPTY
92942: LIST
92943: LIST
92944: PUSH
92945: LD_INT 0
92947: PUSH
92948: LD_INT 1
92950: PUSH
92951: EMPTY
92952: LIST
92953: LIST
92954: PUSH
92955: LD_INT 1
92957: NEG
92958: PUSH
92959: LD_INT 0
92961: PUSH
92962: EMPTY
92963: LIST
92964: LIST
92965: PUSH
92966: LD_INT 1
92968: NEG
92969: PUSH
92970: LD_INT 1
92972: NEG
92973: PUSH
92974: EMPTY
92975: LIST
92976: LIST
92977: PUSH
92978: LD_INT 1
92980: NEG
92981: PUSH
92982: LD_INT 2
92984: NEG
92985: PUSH
92986: EMPTY
92987: LIST
92988: LIST
92989: PUSH
92990: LD_INT 0
92992: PUSH
92993: LD_INT 2
92995: NEG
92996: PUSH
92997: EMPTY
92998: LIST
92999: LIST
93000: PUSH
93001: LD_INT 1
93003: PUSH
93004: LD_INT 1
93006: NEG
93007: PUSH
93008: EMPTY
93009: LIST
93010: LIST
93011: PUSH
93012: LD_INT 2
93014: PUSH
93015: LD_INT 0
93017: PUSH
93018: EMPTY
93019: LIST
93020: LIST
93021: PUSH
93022: LD_INT 2
93024: PUSH
93025: LD_INT 1
93027: PUSH
93028: EMPTY
93029: LIST
93030: LIST
93031: PUSH
93032: EMPTY
93033: LIST
93034: LIST
93035: LIST
93036: LIST
93037: LIST
93038: LIST
93039: LIST
93040: LIST
93041: LIST
93042: LIST
93043: LIST
93044: LIST
93045: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
93046: LD_ADDR_VAR 0 49
93050: PUSH
93051: LD_INT 0
93053: PUSH
93054: LD_INT 0
93056: PUSH
93057: EMPTY
93058: LIST
93059: LIST
93060: PUSH
93061: LD_INT 0
93063: PUSH
93064: LD_INT 1
93066: NEG
93067: PUSH
93068: EMPTY
93069: LIST
93070: LIST
93071: PUSH
93072: LD_INT 1
93074: PUSH
93075: LD_INT 0
93077: PUSH
93078: EMPTY
93079: LIST
93080: LIST
93081: PUSH
93082: LD_INT 1
93084: PUSH
93085: LD_INT 1
93087: PUSH
93088: EMPTY
93089: LIST
93090: LIST
93091: PUSH
93092: LD_INT 0
93094: PUSH
93095: LD_INT 1
93097: PUSH
93098: EMPTY
93099: LIST
93100: LIST
93101: PUSH
93102: LD_INT 1
93104: NEG
93105: PUSH
93106: LD_INT 0
93108: PUSH
93109: EMPTY
93110: LIST
93111: LIST
93112: PUSH
93113: LD_INT 1
93115: NEG
93116: PUSH
93117: LD_INT 1
93119: NEG
93120: PUSH
93121: EMPTY
93122: LIST
93123: LIST
93124: PUSH
93125: LD_INT 1
93127: PUSH
93128: LD_INT 1
93130: NEG
93131: PUSH
93132: EMPTY
93133: LIST
93134: LIST
93135: PUSH
93136: LD_INT 2
93138: PUSH
93139: LD_INT 0
93141: PUSH
93142: EMPTY
93143: LIST
93144: LIST
93145: PUSH
93146: LD_INT 2
93148: PUSH
93149: LD_INT 1
93151: PUSH
93152: EMPTY
93153: LIST
93154: LIST
93155: PUSH
93156: LD_INT 2
93158: PUSH
93159: LD_INT 2
93161: PUSH
93162: EMPTY
93163: LIST
93164: LIST
93165: PUSH
93166: LD_INT 1
93168: PUSH
93169: LD_INT 2
93171: PUSH
93172: EMPTY
93173: LIST
93174: LIST
93175: PUSH
93176: EMPTY
93177: LIST
93178: LIST
93179: LIST
93180: LIST
93181: LIST
93182: LIST
93183: LIST
93184: LIST
93185: LIST
93186: LIST
93187: LIST
93188: LIST
93189: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
93190: LD_ADDR_VAR 0 50
93194: PUSH
93195: LD_INT 0
93197: PUSH
93198: LD_INT 0
93200: PUSH
93201: EMPTY
93202: LIST
93203: LIST
93204: PUSH
93205: LD_INT 0
93207: PUSH
93208: LD_INT 1
93210: NEG
93211: PUSH
93212: EMPTY
93213: LIST
93214: LIST
93215: PUSH
93216: LD_INT 1
93218: PUSH
93219: LD_INT 0
93221: PUSH
93222: EMPTY
93223: LIST
93224: LIST
93225: PUSH
93226: LD_INT 1
93228: PUSH
93229: LD_INT 1
93231: PUSH
93232: EMPTY
93233: LIST
93234: LIST
93235: PUSH
93236: LD_INT 0
93238: PUSH
93239: LD_INT 1
93241: PUSH
93242: EMPTY
93243: LIST
93244: LIST
93245: PUSH
93246: LD_INT 1
93248: NEG
93249: PUSH
93250: LD_INT 0
93252: PUSH
93253: EMPTY
93254: LIST
93255: LIST
93256: PUSH
93257: LD_INT 1
93259: NEG
93260: PUSH
93261: LD_INT 1
93263: NEG
93264: PUSH
93265: EMPTY
93266: LIST
93267: LIST
93268: PUSH
93269: LD_INT 2
93271: PUSH
93272: LD_INT 1
93274: PUSH
93275: EMPTY
93276: LIST
93277: LIST
93278: PUSH
93279: LD_INT 2
93281: PUSH
93282: LD_INT 2
93284: PUSH
93285: EMPTY
93286: LIST
93287: LIST
93288: PUSH
93289: LD_INT 1
93291: PUSH
93292: LD_INT 2
93294: PUSH
93295: EMPTY
93296: LIST
93297: LIST
93298: PUSH
93299: LD_INT 0
93301: PUSH
93302: LD_INT 2
93304: PUSH
93305: EMPTY
93306: LIST
93307: LIST
93308: PUSH
93309: LD_INT 1
93311: NEG
93312: PUSH
93313: LD_INT 1
93315: PUSH
93316: EMPTY
93317: LIST
93318: LIST
93319: PUSH
93320: EMPTY
93321: LIST
93322: LIST
93323: LIST
93324: LIST
93325: LIST
93326: LIST
93327: LIST
93328: LIST
93329: LIST
93330: LIST
93331: LIST
93332: LIST
93333: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
93334: LD_ADDR_VAR 0 51
93338: PUSH
93339: LD_INT 0
93341: PUSH
93342: LD_INT 0
93344: PUSH
93345: EMPTY
93346: LIST
93347: LIST
93348: PUSH
93349: LD_INT 0
93351: PUSH
93352: LD_INT 1
93354: NEG
93355: PUSH
93356: EMPTY
93357: LIST
93358: LIST
93359: PUSH
93360: LD_INT 1
93362: PUSH
93363: LD_INT 0
93365: PUSH
93366: EMPTY
93367: LIST
93368: LIST
93369: PUSH
93370: LD_INT 1
93372: PUSH
93373: LD_INT 1
93375: PUSH
93376: EMPTY
93377: LIST
93378: LIST
93379: PUSH
93380: LD_INT 0
93382: PUSH
93383: LD_INT 1
93385: PUSH
93386: EMPTY
93387: LIST
93388: LIST
93389: PUSH
93390: LD_INT 1
93392: NEG
93393: PUSH
93394: LD_INT 0
93396: PUSH
93397: EMPTY
93398: LIST
93399: LIST
93400: PUSH
93401: LD_INT 1
93403: NEG
93404: PUSH
93405: LD_INT 1
93407: NEG
93408: PUSH
93409: EMPTY
93410: LIST
93411: LIST
93412: PUSH
93413: LD_INT 1
93415: PUSH
93416: LD_INT 2
93418: PUSH
93419: EMPTY
93420: LIST
93421: LIST
93422: PUSH
93423: LD_INT 0
93425: PUSH
93426: LD_INT 2
93428: PUSH
93429: EMPTY
93430: LIST
93431: LIST
93432: PUSH
93433: LD_INT 1
93435: NEG
93436: PUSH
93437: LD_INT 1
93439: PUSH
93440: EMPTY
93441: LIST
93442: LIST
93443: PUSH
93444: LD_INT 2
93446: NEG
93447: PUSH
93448: LD_INT 0
93450: PUSH
93451: EMPTY
93452: LIST
93453: LIST
93454: PUSH
93455: LD_INT 2
93457: NEG
93458: PUSH
93459: LD_INT 1
93461: NEG
93462: PUSH
93463: EMPTY
93464: LIST
93465: LIST
93466: PUSH
93467: EMPTY
93468: LIST
93469: LIST
93470: LIST
93471: LIST
93472: LIST
93473: LIST
93474: LIST
93475: LIST
93476: LIST
93477: LIST
93478: LIST
93479: LIST
93480: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93481: LD_ADDR_VAR 0 52
93485: PUSH
93486: LD_INT 0
93488: PUSH
93489: LD_INT 0
93491: PUSH
93492: EMPTY
93493: LIST
93494: LIST
93495: PUSH
93496: LD_INT 0
93498: PUSH
93499: LD_INT 1
93501: NEG
93502: PUSH
93503: EMPTY
93504: LIST
93505: LIST
93506: PUSH
93507: LD_INT 1
93509: PUSH
93510: LD_INT 0
93512: PUSH
93513: EMPTY
93514: LIST
93515: LIST
93516: PUSH
93517: LD_INT 1
93519: PUSH
93520: LD_INT 1
93522: PUSH
93523: EMPTY
93524: LIST
93525: LIST
93526: PUSH
93527: LD_INT 0
93529: PUSH
93530: LD_INT 1
93532: PUSH
93533: EMPTY
93534: LIST
93535: LIST
93536: PUSH
93537: LD_INT 1
93539: NEG
93540: PUSH
93541: LD_INT 0
93543: PUSH
93544: EMPTY
93545: LIST
93546: LIST
93547: PUSH
93548: LD_INT 1
93550: NEG
93551: PUSH
93552: LD_INT 1
93554: NEG
93555: PUSH
93556: EMPTY
93557: LIST
93558: LIST
93559: PUSH
93560: LD_INT 1
93562: NEG
93563: PUSH
93564: LD_INT 2
93566: NEG
93567: PUSH
93568: EMPTY
93569: LIST
93570: LIST
93571: PUSH
93572: LD_INT 1
93574: NEG
93575: PUSH
93576: LD_INT 1
93578: PUSH
93579: EMPTY
93580: LIST
93581: LIST
93582: PUSH
93583: LD_INT 2
93585: NEG
93586: PUSH
93587: LD_INT 0
93589: PUSH
93590: EMPTY
93591: LIST
93592: LIST
93593: PUSH
93594: LD_INT 2
93596: NEG
93597: PUSH
93598: LD_INT 1
93600: NEG
93601: PUSH
93602: EMPTY
93603: LIST
93604: LIST
93605: PUSH
93606: LD_INT 2
93608: NEG
93609: PUSH
93610: LD_INT 2
93612: NEG
93613: PUSH
93614: EMPTY
93615: LIST
93616: LIST
93617: PUSH
93618: EMPTY
93619: LIST
93620: LIST
93621: LIST
93622: LIST
93623: LIST
93624: LIST
93625: LIST
93626: LIST
93627: LIST
93628: LIST
93629: LIST
93630: LIST
93631: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93632: LD_ADDR_VAR 0 53
93636: PUSH
93637: LD_INT 0
93639: PUSH
93640: LD_INT 0
93642: PUSH
93643: EMPTY
93644: LIST
93645: LIST
93646: PUSH
93647: LD_INT 0
93649: PUSH
93650: LD_INT 1
93652: NEG
93653: PUSH
93654: EMPTY
93655: LIST
93656: LIST
93657: PUSH
93658: LD_INT 1
93660: PUSH
93661: LD_INT 0
93663: PUSH
93664: EMPTY
93665: LIST
93666: LIST
93667: PUSH
93668: LD_INT 1
93670: PUSH
93671: LD_INT 1
93673: PUSH
93674: EMPTY
93675: LIST
93676: LIST
93677: PUSH
93678: LD_INT 0
93680: PUSH
93681: LD_INT 1
93683: PUSH
93684: EMPTY
93685: LIST
93686: LIST
93687: PUSH
93688: LD_INT 1
93690: NEG
93691: PUSH
93692: LD_INT 0
93694: PUSH
93695: EMPTY
93696: LIST
93697: LIST
93698: PUSH
93699: LD_INT 1
93701: NEG
93702: PUSH
93703: LD_INT 1
93705: NEG
93706: PUSH
93707: EMPTY
93708: LIST
93709: LIST
93710: PUSH
93711: LD_INT 1
93713: NEG
93714: PUSH
93715: LD_INT 2
93717: NEG
93718: PUSH
93719: EMPTY
93720: LIST
93721: LIST
93722: PUSH
93723: LD_INT 0
93725: PUSH
93726: LD_INT 2
93728: NEG
93729: PUSH
93730: EMPTY
93731: LIST
93732: LIST
93733: PUSH
93734: LD_INT 1
93736: PUSH
93737: LD_INT 1
93739: NEG
93740: PUSH
93741: EMPTY
93742: LIST
93743: LIST
93744: PUSH
93745: LD_INT 2
93747: PUSH
93748: LD_INT 0
93750: PUSH
93751: EMPTY
93752: LIST
93753: LIST
93754: PUSH
93755: LD_INT 2
93757: PUSH
93758: LD_INT 1
93760: PUSH
93761: EMPTY
93762: LIST
93763: LIST
93764: PUSH
93765: LD_INT 2
93767: PUSH
93768: LD_INT 2
93770: PUSH
93771: EMPTY
93772: LIST
93773: LIST
93774: PUSH
93775: LD_INT 1
93777: PUSH
93778: LD_INT 2
93780: PUSH
93781: EMPTY
93782: LIST
93783: LIST
93784: PUSH
93785: LD_INT 0
93787: PUSH
93788: LD_INT 2
93790: PUSH
93791: EMPTY
93792: LIST
93793: LIST
93794: PUSH
93795: LD_INT 1
93797: NEG
93798: PUSH
93799: LD_INT 1
93801: PUSH
93802: EMPTY
93803: LIST
93804: LIST
93805: PUSH
93806: LD_INT 2
93808: NEG
93809: PUSH
93810: LD_INT 0
93812: PUSH
93813: EMPTY
93814: LIST
93815: LIST
93816: PUSH
93817: LD_INT 2
93819: NEG
93820: PUSH
93821: LD_INT 1
93823: NEG
93824: PUSH
93825: EMPTY
93826: LIST
93827: LIST
93828: PUSH
93829: LD_INT 2
93831: NEG
93832: PUSH
93833: LD_INT 2
93835: NEG
93836: PUSH
93837: EMPTY
93838: LIST
93839: LIST
93840: PUSH
93841: EMPTY
93842: LIST
93843: LIST
93844: LIST
93845: LIST
93846: LIST
93847: LIST
93848: LIST
93849: LIST
93850: LIST
93851: LIST
93852: LIST
93853: LIST
93854: LIST
93855: LIST
93856: LIST
93857: LIST
93858: LIST
93859: LIST
93860: LIST
93861: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93862: LD_ADDR_VAR 0 54
93866: PUSH
93867: LD_INT 0
93869: PUSH
93870: LD_INT 0
93872: PUSH
93873: EMPTY
93874: LIST
93875: LIST
93876: PUSH
93877: LD_INT 0
93879: PUSH
93880: LD_INT 1
93882: NEG
93883: PUSH
93884: EMPTY
93885: LIST
93886: LIST
93887: PUSH
93888: LD_INT 1
93890: PUSH
93891: LD_INT 0
93893: PUSH
93894: EMPTY
93895: LIST
93896: LIST
93897: PUSH
93898: LD_INT 1
93900: PUSH
93901: LD_INT 1
93903: PUSH
93904: EMPTY
93905: LIST
93906: LIST
93907: PUSH
93908: LD_INT 0
93910: PUSH
93911: LD_INT 1
93913: PUSH
93914: EMPTY
93915: LIST
93916: LIST
93917: PUSH
93918: LD_INT 1
93920: NEG
93921: PUSH
93922: LD_INT 0
93924: PUSH
93925: EMPTY
93926: LIST
93927: LIST
93928: PUSH
93929: LD_INT 1
93931: NEG
93932: PUSH
93933: LD_INT 1
93935: NEG
93936: PUSH
93937: EMPTY
93938: LIST
93939: LIST
93940: PUSH
93941: LD_INT 1
93943: NEG
93944: PUSH
93945: LD_INT 2
93947: NEG
93948: PUSH
93949: EMPTY
93950: LIST
93951: LIST
93952: PUSH
93953: LD_INT 0
93955: PUSH
93956: LD_INT 2
93958: NEG
93959: PUSH
93960: EMPTY
93961: LIST
93962: LIST
93963: PUSH
93964: LD_INT 1
93966: PUSH
93967: LD_INT 1
93969: NEG
93970: PUSH
93971: EMPTY
93972: LIST
93973: LIST
93974: PUSH
93975: LD_INT 2
93977: PUSH
93978: LD_INT 0
93980: PUSH
93981: EMPTY
93982: LIST
93983: LIST
93984: PUSH
93985: LD_INT 2
93987: PUSH
93988: LD_INT 1
93990: PUSH
93991: EMPTY
93992: LIST
93993: LIST
93994: PUSH
93995: LD_INT 2
93997: PUSH
93998: LD_INT 2
94000: PUSH
94001: EMPTY
94002: LIST
94003: LIST
94004: PUSH
94005: LD_INT 1
94007: PUSH
94008: LD_INT 2
94010: PUSH
94011: EMPTY
94012: LIST
94013: LIST
94014: PUSH
94015: LD_INT 0
94017: PUSH
94018: LD_INT 2
94020: PUSH
94021: EMPTY
94022: LIST
94023: LIST
94024: PUSH
94025: LD_INT 1
94027: NEG
94028: PUSH
94029: LD_INT 1
94031: PUSH
94032: EMPTY
94033: LIST
94034: LIST
94035: PUSH
94036: LD_INT 2
94038: NEG
94039: PUSH
94040: LD_INT 0
94042: PUSH
94043: EMPTY
94044: LIST
94045: LIST
94046: PUSH
94047: LD_INT 2
94049: NEG
94050: PUSH
94051: LD_INT 1
94053: NEG
94054: PUSH
94055: EMPTY
94056: LIST
94057: LIST
94058: PUSH
94059: LD_INT 2
94061: NEG
94062: PUSH
94063: LD_INT 2
94065: NEG
94066: PUSH
94067: EMPTY
94068: LIST
94069: LIST
94070: PUSH
94071: EMPTY
94072: LIST
94073: LIST
94074: LIST
94075: LIST
94076: LIST
94077: LIST
94078: LIST
94079: LIST
94080: LIST
94081: LIST
94082: LIST
94083: LIST
94084: LIST
94085: LIST
94086: LIST
94087: LIST
94088: LIST
94089: LIST
94090: LIST
94091: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94092: LD_ADDR_VAR 0 55
94096: PUSH
94097: LD_INT 0
94099: PUSH
94100: LD_INT 0
94102: PUSH
94103: EMPTY
94104: LIST
94105: LIST
94106: PUSH
94107: LD_INT 0
94109: PUSH
94110: LD_INT 1
94112: NEG
94113: PUSH
94114: EMPTY
94115: LIST
94116: LIST
94117: PUSH
94118: LD_INT 1
94120: PUSH
94121: LD_INT 0
94123: PUSH
94124: EMPTY
94125: LIST
94126: LIST
94127: PUSH
94128: LD_INT 1
94130: PUSH
94131: LD_INT 1
94133: PUSH
94134: EMPTY
94135: LIST
94136: LIST
94137: PUSH
94138: LD_INT 0
94140: PUSH
94141: LD_INT 1
94143: PUSH
94144: EMPTY
94145: LIST
94146: LIST
94147: PUSH
94148: LD_INT 1
94150: NEG
94151: PUSH
94152: LD_INT 0
94154: PUSH
94155: EMPTY
94156: LIST
94157: LIST
94158: PUSH
94159: LD_INT 1
94161: NEG
94162: PUSH
94163: LD_INT 1
94165: NEG
94166: PUSH
94167: EMPTY
94168: LIST
94169: LIST
94170: PUSH
94171: LD_INT 1
94173: NEG
94174: PUSH
94175: LD_INT 2
94177: NEG
94178: PUSH
94179: EMPTY
94180: LIST
94181: LIST
94182: PUSH
94183: LD_INT 0
94185: PUSH
94186: LD_INT 2
94188: NEG
94189: PUSH
94190: EMPTY
94191: LIST
94192: LIST
94193: PUSH
94194: LD_INT 1
94196: PUSH
94197: LD_INT 1
94199: NEG
94200: PUSH
94201: EMPTY
94202: LIST
94203: LIST
94204: PUSH
94205: LD_INT 2
94207: PUSH
94208: LD_INT 0
94210: PUSH
94211: EMPTY
94212: LIST
94213: LIST
94214: PUSH
94215: LD_INT 2
94217: PUSH
94218: LD_INT 1
94220: PUSH
94221: EMPTY
94222: LIST
94223: LIST
94224: PUSH
94225: LD_INT 2
94227: PUSH
94228: LD_INT 2
94230: PUSH
94231: EMPTY
94232: LIST
94233: LIST
94234: PUSH
94235: LD_INT 1
94237: PUSH
94238: LD_INT 2
94240: PUSH
94241: EMPTY
94242: LIST
94243: LIST
94244: PUSH
94245: LD_INT 0
94247: PUSH
94248: LD_INT 2
94250: PUSH
94251: EMPTY
94252: LIST
94253: LIST
94254: PUSH
94255: LD_INT 1
94257: NEG
94258: PUSH
94259: LD_INT 1
94261: PUSH
94262: EMPTY
94263: LIST
94264: LIST
94265: PUSH
94266: LD_INT 2
94268: NEG
94269: PUSH
94270: LD_INT 0
94272: PUSH
94273: EMPTY
94274: LIST
94275: LIST
94276: PUSH
94277: LD_INT 2
94279: NEG
94280: PUSH
94281: LD_INT 1
94283: NEG
94284: PUSH
94285: EMPTY
94286: LIST
94287: LIST
94288: PUSH
94289: LD_INT 2
94291: NEG
94292: PUSH
94293: LD_INT 2
94295: NEG
94296: PUSH
94297: EMPTY
94298: LIST
94299: LIST
94300: PUSH
94301: EMPTY
94302: LIST
94303: LIST
94304: LIST
94305: LIST
94306: LIST
94307: LIST
94308: LIST
94309: LIST
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: LIST
94318: LIST
94319: LIST
94320: LIST
94321: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94322: LD_ADDR_VAR 0 56
94326: PUSH
94327: LD_INT 0
94329: PUSH
94330: LD_INT 0
94332: PUSH
94333: EMPTY
94334: LIST
94335: LIST
94336: PUSH
94337: LD_INT 0
94339: PUSH
94340: LD_INT 1
94342: NEG
94343: PUSH
94344: EMPTY
94345: LIST
94346: LIST
94347: PUSH
94348: LD_INT 1
94350: PUSH
94351: LD_INT 0
94353: PUSH
94354: EMPTY
94355: LIST
94356: LIST
94357: PUSH
94358: LD_INT 1
94360: PUSH
94361: LD_INT 1
94363: PUSH
94364: EMPTY
94365: LIST
94366: LIST
94367: PUSH
94368: LD_INT 0
94370: PUSH
94371: LD_INT 1
94373: PUSH
94374: EMPTY
94375: LIST
94376: LIST
94377: PUSH
94378: LD_INT 1
94380: NEG
94381: PUSH
94382: LD_INT 0
94384: PUSH
94385: EMPTY
94386: LIST
94387: LIST
94388: PUSH
94389: LD_INT 1
94391: NEG
94392: PUSH
94393: LD_INT 1
94395: NEG
94396: PUSH
94397: EMPTY
94398: LIST
94399: LIST
94400: PUSH
94401: LD_INT 1
94403: NEG
94404: PUSH
94405: LD_INT 2
94407: NEG
94408: PUSH
94409: EMPTY
94410: LIST
94411: LIST
94412: PUSH
94413: LD_INT 0
94415: PUSH
94416: LD_INT 2
94418: NEG
94419: PUSH
94420: EMPTY
94421: LIST
94422: LIST
94423: PUSH
94424: LD_INT 1
94426: PUSH
94427: LD_INT 1
94429: NEG
94430: PUSH
94431: EMPTY
94432: LIST
94433: LIST
94434: PUSH
94435: LD_INT 2
94437: PUSH
94438: LD_INT 0
94440: PUSH
94441: EMPTY
94442: LIST
94443: LIST
94444: PUSH
94445: LD_INT 2
94447: PUSH
94448: LD_INT 1
94450: PUSH
94451: EMPTY
94452: LIST
94453: LIST
94454: PUSH
94455: LD_INT 2
94457: PUSH
94458: LD_INT 2
94460: PUSH
94461: EMPTY
94462: LIST
94463: LIST
94464: PUSH
94465: LD_INT 1
94467: PUSH
94468: LD_INT 2
94470: PUSH
94471: EMPTY
94472: LIST
94473: LIST
94474: PUSH
94475: LD_INT 0
94477: PUSH
94478: LD_INT 2
94480: PUSH
94481: EMPTY
94482: LIST
94483: LIST
94484: PUSH
94485: LD_INT 1
94487: NEG
94488: PUSH
94489: LD_INT 1
94491: PUSH
94492: EMPTY
94493: LIST
94494: LIST
94495: PUSH
94496: LD_INT 2
94498: NEG
94499: PUSH
94500: LD_INT 0
94502: PUSH
94503: EMPTY
94504: LIST
94505: LIST
94506: PUSH
94507: LD_INT 2
94509: NEG
94510: PUSH
94511: LD_INT 1
94513: NEG
94514: PUSH
94515: EMPTY
94516: LIST
94517: LIST
94518: PUSH
94519: LD_INT 2
94521: NEG
94522: PUSH
94523: LD_INT 2
94525: NEG
94526: PUSH
94527: EMPTY
94528: LIST
94529: LIST
94530: PUSH
94531: EMPTY
94532: LIST
94533: LIST
94534: LIST
94535: LIST
94536: LIST
94537: LIST
94538: LIST
94539: LIST
94540: LIST
94541: LIST
94542: LIST
94543: LIST
94544: LIST
94545: LIST
94546: LIST
94547: LIST
94548: LIST
94549: LIST
94550: LIST
94551: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94552: LD_ADDR_VAR 0 57
94556: PUSH
94557: LD_INT 0
94559: PUSH
94560: LD_INT 0
94562: PUSH
94563: EMPTY
94564: LIST
94565: LIST
94566: PUSH
94567: LD_INT 0
94569: PUSH
94570: LD_INT 1
94572: NEG
94573: PUSH
94574: EMPTY
94575: LIST
94576: LIST
94577: PUSH
94578: LD_INT 1
94580: PUSH
94581: LD_INT 0
94583: PUSH
94584: EMPTY
94585: LIST
94586: LIST
94587: PUSH
94588: LD_INT 1
94590: PUSH
94591: LD_INT 1
94593: PUSH
94594: EMPTY
94595: LIST
94596: LIST
94597: PUSH
94598: LD_INT 0
94600: PUSH
94601: LD_INT 1
94603: PUSH
94604: EMPTY
94605: LIST
94606: LIST
94607: PUSH
94608: LD_INT 1
94610: NEG
94611: PUSH
94612: LD_INT 0
94614: PUSH
94615: EMPTY
94616: LIST
94617: LIST
94618: PUSH
94619: LD_INT 1
94621: NEG
94622: PUSH
94623: LD_INT 1
94625: NEG
94626: PUSH
94627: EMPTY
94628: LIST
94629: LIST
94630: PUSH
94631: LD_INT 1
94633: NEG
94634: PUSH
94635: LD_INT 2
94637: NEG
94638: PUSH
94639: EMPTY
94640: LIST
94641: LIST
94642: PUSH
94643: LD_INT 0
94645: PUSH
94646: LD_INT 2
94648: NEG
94649: PUSH
94650: EMPTY
94651: LIST
94652: LIST
94653: PUSH
94654: LD_INT 1
94656: PUSH
94657: LD_INT 1
94659: NEG
94660: PUSH
94661: EMPTY
94662: LIST
94663: LIST
94664: PUSH
94665: LD_INT 2
94667: PUSH
94668: LD_INT 0
94670: PUSH
94671: EMPTY
94672: LIST
94673: LIST
94674: PUSH
94675: LD_INT 2
94677: PUSH
94678: LD_INT 1
94680: PUSH
94681: EMPTY
94682: LIST
94683: LIST
94684: PUSH
94685: LD_INT 2
94687: PUSH
94688: LD_INT 2
94690: PUSH
94691: EMPTY
94692: LIST
94693: LIST
94694: PUSH
94695: LD_INT 1
94697: PUSH
94698: LD_INT 2
94700: PUSH
94701: EMPTY
94702: LIST
94703: LIST
94704: PUSH
94705: LD_INT 0
94707: PUSH
94708: LD_INT 2
94710: PUSH
94711: EMPTY
94712: LIST
94713: LIST
94714: PUSH
94715: LD_INT 1
94717: NEG
94718: PUSH
94719: LD_INT 1
94721: PUSH
94722: EMPTY
94723: LIST
94724: LIST
94725: PUSH
94726: LD_INT 2
94728: NEG
94729: PUSH
94730: LD_INT 0
94732: PUSH
94733: EMPTY
94734: LIST
94735: LIST
94736: PUSH
94737: LD_INT 2
94739: NEG
94740: PUSH
94741: LD_INT 1
94743: NEG
94744: PUSH
94745: EMPTY
94746: LIST
94747: LIST
94748: PUSH
94749: LD_INT 2
94751: NEG
94752: PUSH
94753: LD_INT 2
94755: NEG
94756: PUSH
94757: EMPTY
94758: LIST
94759: LIST
94760: PUSH
94761: EMPTY
94762: LIST
94763: LIST
94764: LIST
94765: LIST
94766: LIST
94767: LIST
94768: LIST
94769: LIST
94770: LIST
94771: LIST
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: LIST
94778: LIST
94779: LIST
94780: LIST
94781: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94782: LD_ADDR_VAR 0 58
94786: PUSH
94787: LD_INT 0
94789: PUSH
94790: LD_INT 0
94792: PUSH
94793: EMPTY
94794: LIST
94795: LIST
94796: PUSH
94797: LD_INT 0
94799: PUSH
94800: LD_INT 1
94802: NEG
94803: PUSH
94804: EMPTY
94805: LIST
94806: LIST
94807: PUSH
94808: LD_INT 1
94810: PUSH
94811: LD_INT 0
94813: PUSH
94814: EMPTY
94815: LIST
94816: LIST
94817: PUSH
94818: LD_INT 1
94820: PUSH
94821: LD_INT 1
94823: PUSH
94824: EMPTY
94825: LIST
94826: LIST
94827: PUSH
94828: LD_INT 0
94830: PUSH
94831: LD_INT 1
94833: PUSH
94834: EMPTY
94835: LIST
94836: LIST
94837: PUSH
94838: LD_INT 1
94840: NEG
94841: PUSH
94842: LD_INT 0
94844: PUSH
94845: EMPTY
94846: LIST
94847: LIST
94848: PUSH
94849: LD_INT 1
94851: NEG
94852: PUSH
94853: LD_INT 1
94855: NEG
94856: PUSH
94857: EMPTY
94858: LIST
94859: LIST
94860: PUSH
94861: LD_INT 1
94863: NEG
94864: PUSH
94865: LD_INT 2
94867: NEG
94868: PUSH
94869: EMPTY
94870: LIST
94871: LIST
94872: PUSH
94873: LD_INT 0
94875: PUSH
94876: LD_INT 2
94878: NEG
94879: PUSH
94880: EMPTY
94881: LIST
94882: LIST
94883: PUSH
94884: LD_INT 1
94886: PUSH
94887: LD_INT 1
94889: NEG
94890: PUSH
94891: EMPTY
94892: LIST
94893: LIST
94894: PUSH
94895: LD_INT 2
94897: PUSH
94898: LD_INT 0
94900: PUSH
94901: EMPTY
94902: LIST
94903: LIST
94904: PUSH
94905: LD_INT 2
94907: PUSH
94908: LD_INT 1
94910: PUSH
94911: EMPTY
94912: LIST
94913: LIST
94914: PUSH
94915: LD_INT 2
94917: PUSH
94918: LD_INT 2
94920: PUSH
94921: EMPTY
94922: LIST
94923: LIST
94924: PUSH
94925: LD_INT 1
94927: PUSH
94928: LD_INT 2
94930: PUSH
94931: EMPTY
94932: LIST
94933: LIST
94934: PUSH
94935: LD_INT 0
94937: PUSH
94938: LD_INT 2
94940: PUSH
94941: EMPTY
94942: LIST
94943: LIST
94944: PUSH
94945: LD_INT 1
94947: NEG
94948: PUSH
94949: LD_INT 1
94951: PUSH
94952: EMPTY
94953: LIST
94954: LIST
94955: PUSH
94956: LD_INT 2
94958: NEG
94959: PUSH
94960: LD_INT 0
94962: PUSH
94963: EMPTY
94964: LIST
94965: LIST
94966: PUSH
94967: LD_INT 2
94969: NEG
94970: PUSH
94971: LD_INT 1
94973: NEG
94974: PUSH
94975: EMPTY
94976: LIST
94977: LIST
94978: PUSH
94979: LD_INT 2
94981: NEG
94982: PUSH
94983: LD_INT 2
94985: NEG
94986: PUSH
94987: EMPTY
94988: LIST
94989: LIST
94990: PUSH
94991: EMPTY
94992: LIST
94993: LIST
94994: LIST
94995: LIST
94996: LIST
94997: LIST
94998: LIST
94999: LIST
95000: LIST
95001: LIST
95002: LIST
95003: LIST
95004: LIST
95005: LIST
95006: LIST
95007: LIST
95008: LIST
95009: LIST
95010: LIST
95011: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95012: LD_ADDR_VAR 0 59
95016: PUSH
95017: LD_INT 0
95019: PUSH
95020: LD_INT 0
95022: PUSH
95023: EMPTY
95024: LIST
95025: LIST
95026: PUSH
95027: LD_INT 0
95029: PUSH
95030: LD_INT 1
95032: NEG
95033: PUSH
95034: EMPTY
95035: LIST
95036: LIST
95037: PUSH
95038: LD_INT 1
95040: PUSH
95041: LD_INT 0
95043: PUSH
95044: EMPTY
95045: LIST
95046: LIST
95047: PUSH
95048: LD_INT 1
95050: PUSH
95051: LD_INT 1
95053: PUSH
95054: EMPTY
95055: LIST
95056: LIST
95057: PUSH
95058: LD_INT 0
95060: PUSH
95061: LD_INT 1
95063: PUSH
95064: EMPTY
95065: LIST
95066: LIST
95067: PUSH
95068: LD_INT 1
95070: NEG
95071: PUSH
95072: LD_INT 0
95074: PUSH
95075: EMPTY
95076: LIST
95077: LIST
95078: PUSH
95079: LD_INT 1
95081: NEG
95082: PUSH
95083: LD_INT 1
95085: NEG
95086: PUSH
95087: EMPTY
95088: LIST
95089: LIST
95090: PUSH
95091: EMPTY
95092: LIST
95093: LIST
95094: LIST
95095: LIST
95096: LIST
95097: LIST
95098: LIST
95099: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95100: LD_ADDR_VAR 0 60
95104: PUSH
95105: LD_INT 0
95107: PUSH
95108: LD_INT 0
95110: PUSH
95111: EMPTY
95112: LIST
95113: LIST
95114: PUSH
95115: LD_INT 0
95117: PUSH
95118: LD_INT 1
95120: NEG
95121: PUSH
95122: EMPTY
95123: LIST
95124: LIST
95125: PUSH
95126: LD_INT 1
95128: PUSH
95129: LD_INT 0
95131: PUSH
95132: EMPTY
95133: LIST
95134: LIST
95135: PUSH
95136: LD_INT 1
95138: PUSH
95139: LD_INT 1
95141: PUSH
95142: EMPTY
95143: LIST
95144: LIST
95145: PUSH
95146: LD_INT 0
95148: PUSH
95149: LD_INT 1
95151: PUSH
95152: EMPTY
95153: LIST
95154: LIST
95155: PUSH
95156: LD_INT 1
95158: NEG
95159: PUSH
95160: LD_INT 0
95162: PUSH
95163: EMPTY
95164: LIST
95165: LIST
95166: PUSH
95167: LD_INT 1
95169: NEG
95170: PUSH
95171: LD_INT 1
95173: NEG
95174: PUSH
95175: EMPTY
95176: LIST
95177: LIST
95178: PUSH
95179: EMPTY
95180: LIST
95181: LIST
95182: LIST
95183: LIST
95184: LIST
95185: LIST
95186: LIST
95187: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95188: LD_ADDR_VAR 0 61
95192: PUSH
95193: LD_INT 0
95195: PUSH
95196: LD_INT 0
95198: PUSH
95199: EMPTY
95200: LIST
95201: LIST
95202: PUSH
95203: LD_INT 0
95205: PUSH
95206: LD_INT 1
95208: NEG
95209: PUSH
95210: EMPTY
95211: LIST
95212: LIST
95213: PUSH
95214: LD_INT 1
95216: PUSH
95217: LD_INT 0
95219: PUSH
95220: EMPTY
95221: LIST
95222: LIST
95223: PUSH
95224: LD_INT 1
95226: PUSH
95227: LD_INT 1
95229: PUSH
95230: EMPTY
95231: LIST
95232: LIST
95233: PUSH
95234: LD_INT 0
95236: PUSH
95237: LD_INT 1
95239: PUSH
95240: EMPTY
95241: LIST
95242: LIST
95243: PUSH
95244: LD_INT 1
95246: NEG
95247: PUSH
95248: LD_INT 0
95250: PUSH
95251: EMPTY
95252: LIST
95253: LIST
95254: PUSH
95255: LD_INT 1
95257: NEG
95258: PUSH
95259: LD_INT 1
95261: NEG
95262: PUSH
95263: EMPTY
95264: LIST
95265: LIST
95266: PUSH
95267: EMPTY
95268: LIST
95269: LIST
95270: LIST
95271: LIST
95272: LIST
95273: LIST
95274: LIST
95275: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95276: LD_ADDR_VAR 0 62
95280: PUSH
95281: LD_INT 0
95283: PUSH
95284: LD_INT 0
95286: PUSH
95287: EMPTY
95288: LIST
95289: LIST
95290: PUSH
95291: LD_INT 0
95293: PUSH
95294: LD_INT 1
95296: NEG
95297: PUSH
95298: EMPTY
95299: LIST
95300: LIST
95301: PUSH
95302: LD_INT 1
95304: PUSH
95305: LD_INT 0
95307: PUSH
95308: EMPTY
95309: LIST
95310: LIST
95311: PUSH
95312: LD_INT 1
95314: PUSH
95315: LD_INT 1
95317: PUSH
95318: EMPTY
95319: LIST
95320: LIST
95321: PUSH
95322: LD_INT 0
95324: PUSH
95325: LD_INT 1
95327: PUSH
95328: EMPTY
95329: LIST
95330: LIST
95331: PUSH
95332: LD_INT 1
95334: NEG
95335: PUSH
95336: LD_INT 0
95338: PUSH
95339: EMPTY
95340: LIST
95341: LIST
95342: PUSH
95343: LD_INT 1
95345: NEG
95346: PUSH
95347: LD_INT 1
95349: NEG
95350: PUSH
95351: EMPTY
95352: LIST
95353: LIST
95354: PUSH
95355: EMPTY
95356: LIST
95357: LIST
95358: LIST
95359: LIST
95360: LIST
95361: LIST
95362: LIST
95363: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95364: LD_ADDR_VAR 0 63
95368: PUSH
95369: LD_INT 0
95371: PUSH
95372: LD_INT 0
95374: PUSH
95375: EMPTY
95376: LIST
95377: LIST
95378: PUSH
95379: LD_INT 0
95381: PUSH
95382: LD_INT 1
95384: NEG
95385: PUSH
95386: EMPTY
95387: LIST
95388: LIST
95389: PUSH
95390: LD_INT 1
95392: PUSH
95393: LD_INT 0
95395: PUSH
95396: EMPTY
95397: LIST
95398: LIST
95399: PUSH
95400: LD_INT 1
95402: PUSH
95403: LD_INT 1
95405: PUSH
95406: EMPTY
95407: LIST
95408: LIST
95409: PUSH
95410: LD_INT 0
95412: PUSH
95413: LD_INT 1
95415: PUSH
95416: EMPTY
95417: LIST
95418: LIST
95419: PUSH
95420: LD_INT 1
95422: NEG
95423: PUSH
95424: LD_INT 0
95426: PUSH
95427: EMPTY
95428: LIST
95429: LIST
95430: PUSH
95431: LD_INT 1
95433: NEG
95434: PUSH
95435: LD_INT 1
95437: NEG
95438: PUSH
95439: EMPTY
95440: LIST
95441: LIST
95442: PUSH
95443: EMPTY
95444: LIST
95445: LIST
95446: LIST
95447: LIST
95448: LIST
95449: LIST
95450: LIST
95451: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95452: LD_ADDR_VAR 0 64
95456: PUSH
95457: LD_INT 0
95459: PUSH
95460: LD_INT 0
95462: PUSH
95463: EMPTY
95464: LIST
95465: LIST
95466: PUSH
95467: LD_INT 0
95469: PUSH
95470: LD_INT 1
95472: NEG
95473: PUSH
95474: EMPTY
95475: LIST
95476: LIST
95477: PUSH
95478: LD_INT 1
95480: PUSH
95481: LD_INT 0
95483: PUSH
95484: EMPTY
95485: LIST
95486: LIST
95487: PUSH
95488: LD_INT 1
95490: PUSH
95491: LD_INT 1
95493: PUSH
95494: EMPTY
95495: LIST
95496: LIST
95497: PUSH
95498: LD_INT 0
95500: PUSH
95501: LD_INT 1
95503: PUSH
95504: EMPTY
95505: LIST
95506: LIST
95507: PUSH
95508: LD_INT 1
95510: NEG
95511: PUSH
95512: LD_INT 0
95514: PUSH
95515: EMPTY
95516: LIST
95517: LIST
95518: PUSH
95519: LD_INT 1
95521: NEG
95522: PUSH
95523: LD_INT 1
95525: NEG
95526: PUSH
95527: EMPTY
95528: LIST
95529: LIST
95530: PUSH
95531: EMPTY
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: LIST
95538: LIST
95539: ST_TO_ADDR
// end ; 1 :
95540: GO 101437
95542: LD_INT 1
95544: DOUBLE
95545: EQUAL
95546: IFTRUE 95550
95548: GO 98173
95550: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
95551: LD_ADDR_VAR 0 11
95555: PUSH
95556: LD_INT 1
95558: NEG
95559: PUSH
95560: LD_INT 3
95562: NEG
95563: PUSH
95564: EMPTY
95565: LIST
95566: LIST
95567: PUSH
95568: LD_INT 0
95570: PUSH
95571: LD_INT 3
95573: NEG
95574: PUSH
95575: EMPTY
95576: LIST
95577: LIST
95578: PUSH
95579: LD_INT 1
95581: PUSH
95582: LD_INT 2
95584: NEG
95585: PUSH
95586: EMPTY
95587: LIST
95588: LIST
95589: PUSH
95590: EMPTY
95591: LIST
95592: LIST
95593: LIST
95594: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
95595: LD_ADDR_VAR 0 12
95599: PUSH
95600: LD_INT 2
95602: PUSH
95603: LD_INT 1
95605: NEG
95606: PUSH
95607: EMPTY
95608: LIST
95609: LIST
95610: PUSH
95611: LD_INT 3
95613: PUSH
95614: LD_INT 0
95616: PUSH
95617: EMPTY
95618: LIST
95619: LIST
95620: PUSH
95621: LD_INT 3
95623: PUSH
95624: LD_INT 1
95626: PUSH
95627: EMPTY
95628: LIST
95629: LIST
95630: PUSH
95631: EMPTY
95632: LIST
95633: LIST
95634: LIST
95635: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
95636: LD_ADDR_VAR 0 13
95640: PUSH
95641: LD_INT 3
95643: PUSH
95644: LD_INT 2
95646: PUSH
95647: EMPTY
95648: LIST
95649: LIST
95650: PUSH
95651: LD_INT 3
95653: PUSH
95654: LD_INT 3
95656: PUSH
95657: EMPTY
95658: LIST
95659: LIST
95660: PUSH
95661: LD_INT 2
95663: PUSH
95664: LD_INT 3
95666: PUSH
95667: EMPTY
95668: LIST
95669: LIST
95670: PUSH
95671: EMPTY
95672: LIST
95673: LIST
95674: LIST
95675: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
95676: LD_ADDR_VAR 0 14
95680: PUSH
95681: LD_INT 1
95683: PUSH
95684: LD_INT 3
95686: PUSH
95687: EMPTY
95688: LIST
95689: LIST
95690: PUSH
95691: LD_INT 0
95693: PUSH
95694: LD_INT 3
95696: PUSH
95697: EMPTY
95698: LIST
95699: LIST
95700: PUSH
95701: LD_INT 1
95703: NEG
95704: PUSH
95705: LD_INT 2
95707: PUSH
95708: EMPTY
95709: LIST
95710: LIST
95711: PUSH
95712: EMPTY
95713: LIST
95714: LIST
95715: LIST
95716: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
95717: LD_ADDR_VAR 0 15
95721: PUSH
95722: LD_INT 2
95724: NEG
95725: PUSH
95726: LD_INT 1
95728: PUSH
95729: EMPTY
95730: LIST
95731: LIST
95732: PUSH
95733: LD_INT 3
95735: NEG
95736: PUSH
95737: LD_INT 0
95739: PUSH
95740: EMPTY
95741: LIST
95742: LIST
95743: PUSH
95744: LD_INT 3
95746: NEG
95747: PUSH
95748: LD_INT 1
95750: NEG
95751: PUSH
95752: EMPTY
95753: LIST
95754: LIST
95755: PUSH
95756: EMPTY
95757: LIST
95758: LIST
95759: LIST
95760: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
95761: LD_ADDR_VAR 0 16
95765: PUSH
95766: LD_INT 2
95768: NEG
95769: PUSH
95770: LD_INT 3
95772: NEG
95773: PUSH
95774: EMPTY
95775: LIST
95776: LIST
95777: PUSH
95778: LD_INT 3
95780: NEG
95781: PUSH
95782: LD_INT 2
95784: NEG
95785: PUSH
95786: EMPTY
95787: LIST
95788: LIST
95789: PUSH
95790: LD_INT 3
95792: NEG
95793: PUSH
95794: LD_INT 3
95796: NEG
95797: PUSH
95798: EMPTY
95799: LIST
95800: LIST
95801: PUSH
95802: EMPTY
95803: LIST
95804: LIST
95805: LIST
95806: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
95807: LD_ADDR_VAR 0 17
95811: PUSH
95812: LD_INT 1
95814: NEG
95815: PUSH
95816: LD_INT 3
95818: NEG
95819: PUSH
95820: EMPTY
95821: LIST
95822: LIST
95823: PUSH
95824: LD_INT 0
95826: PUSH
95827: LD_INT 3
95829: NEG
95830: PUSH
95831: EMPTY
95832: LIST
95833: LIST
95834: PUSH
95835: LD_INT 1
95837: PUSH
95838: LD_INT 2
95840: NEG
95841: PUSH
95842: EMPTY
95843: LIST
95844: LIST
95845: PUSH
95846: EMPTY
95847: LIST
95848: LIST
95849: LIST
95850: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
95851: LD_ADDR_VAR 0 18
95855: PUSH
95856: LD_INT 2
95858: PUSH
95859: LD_INT 1
95861: NEG
95862: PUSH
95863: EMPTY
95864: LIST
95865: LIST
95866: PUSH
95867: LD_INT 3
95869: PUSH
95870: LD_INT 0
95872: PUSH
95873: EMPTY
95874: LIST
95875: LIST
95876: PUSH
95877: LD_INT 3
95879: PUSH
95880: LD_INT 1
95882: PUSH
95883: EMPTY
95884: LIST
95885: LIST
95886: PUSH
95887: EMPTY
95888: LIST
95889: LIST
95890: LIST
95891: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
95892: LD_ADDR_VAR 0 19
95896: PUSH
95897: LD_INT 3
95899: PUSH
95900: LD_INT 2
95902: PUSH
95903: EMPTY
95904: LIST
95905: LIST
95906: PUSH
95907: LD_INT 3
95909: PUSH
95910: LD_INT 3
95912: PUSH
95913: EMPTY
95914: LIST
95915: LIST
95916: PUSH
95917: LD_INT 2
95919: PUSH
95920: LD_INT 3
95922: PUSH
95923: EMPTY
95924: LIST
95925: LIST
95926: PUSH
95927: EMPTY
95928: LIST
95929: LIST
95930: LIST
95931: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
95932: LD_ADDR_VAR 0 20
95936: PUSH
95937: LD_INT 1
95939: PUSH
95940: LD_INT 3
95942: PUSH
95943: EMPTY
95944: LIST
95945: LIST
95946: PUSH
95947: LD_INT 0
95949: PUSH
95950: LD_INT 3
95952: PUSH
95953: EMPTY
95954: LIST
95955: LIST
95956: PUSH
95957: LD_INT 1
95959: NEG
95960: PUSH
95961: LD_INT 2
95963: PUSH
95964: EMPTY
95965: LIST
95966: LIST
95967: PUSH
95968: EMPTY
95969: LIST
95970: LIST
95971: LIST
95972: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
95973: LD_ADDR_VAR 0 21
95977: PUSH
95978: LD_INT 2
95980: NEG
95981: PUSH
95982: LD_INT 1
95984: PUSH
95985: EMPTY
95986: LIST
95987: LIST
95988: PUSH
95989: LD_INT 3
95991: NEG
95992: PUSH
95993: LD_INT 0
95995: PUSH
95996: EMPTY
95997: LIST
95998: LIST
95999: PUSH
96000: LD_INT 3
96002: NEG
96003: PUSH
96004: LD_INT 1
96006: NEG
96007: PUSH
96008: EMPTY
96009: LIST
96010: LIST
96011: PUSH
96012: EMPTY
96013: LIST
96014: LIST
96015: LIST
96016: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
96017: LD_ADDR_VAR 0 22
96021: PUSH
96022: LD_INT 2
96024: NEG
96025: PUSH
96026: LD_INT 3
96028: NEG
96029: PUSH
96030: EMPTY
96031: LIST
96032: LIST
96033: PUSH
96034: LD_INT 3
96036: NEG
96037: PUSH
96038: LD_INT 2
96040: NEG
96041: PUSH
96042: EMPTY
96043: LIST
96044: LIST
96045: PUSH
96046: LD_INT 3
96048: NEG
96049: PUSH
96050: LD_INT 3
96052: NEG
96053: PUSH
96054: EMPTY
96055: LIST
96056: LIST
96057: PUSH
96058: EMPTY
96059: LIST
96060: LIST
96061: LIST
96062: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
96063: LD_ADDR_VAR 0 23
96067: PUSH
96068: LD_INT 0
96070: PUSH
96071: LD_INT 3
96073: NEG
96074: PUSH
96075: EMPTY
96076: LIST
96077: LIST
96078: PUSH
96079: LD_INT 1
96081: NEG
96082: PUSH
96083: LD_INT 4
96085: NEG
96086: PUSH
96087: EMPTY
96088: LIST
96089: LIST
96090: PUSH
96091: LD_INT 1
96093: PUSH
96094: LD_INT 3
96096: NEG
96097: PUSH
96098: EMPTY
96099: LIST
96100: LIST
96101: PUSH
96102: EMPTY
96103: LIST
96104: LIST
96105: LIST
96106: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
96107: LD_ADDR_VAR 0 24
96111: PUSH
96112: LD_INT 3
96114: PUSH
96115: LD_INT 0
96117: PUSH
96118: EMPTY
96119: LIST
96120: LIST
96121: PUSH
96122: LD_INT 3
96124: PUSH
96125: LD_INT 1
96127: NEG
96128: PUSH
96129: EMPTY
96130: LIST
96131: LIST
96132: PUSH
96133: LD_INT 4
96135: PUSH
96136: LD_INT 1
96138: PUSH
96139: EMPTY
96140: LIST
96141: LIST
96142: PUSH
96143: EMPTY
96144: LIST
96145: LIST
96146: LIST
96147: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
96148: LD_ADDR_VAR 0 25
96152: PUSH
96153: LD_INT 3
96155: PUSH
96156: LD_INT 3
96158: PUSH
96159: EMPTY
96160: LIST
96161: LIST
96162: PUSH
96163: LD_INT 4
96165: PUSH
96166: LD_INT 3
96168: PUSH
96169: EMPTY
96170: LIST
96171: LIST
96172: PUSH
96173: LD_INT 3
96175: PUSH
96176: LD_INT 4
96178: PUSH
96179: EMPTY
96180: LIST
96181: LIST
96182: PUSH
96183: EMPTY
96184: LIST
96185: LIST
96186: LIST
96187: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
96188: LD_ADDR_VAR 0 26
96192: PUSH
96193: LD_INT 0
96195: PUSH
96196: LD_INT 3
96198: PUSH
96199: EMPTY
96200: LIST
96201: LIST
96202: PUSH
96203: LD_INT 1
96205: PUSH
96206: LD_INT 4
96208: PUSH
96209: EMPTY
96210: LIST
96211: LIST
96212: PUSH
96213: LD_INT 1
96215: NEG
96216: PUSH
96217: LD_INT 3
96219: PUSH
96220: EMPTY
96221: LIST
96222: LIST
96223: PUSH
96224: EMPTY
96225: LIST
96226: LIST
96227: LIST
96228: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
96229: LD_ADDR_VAR 0 27
96233: PUSH
96234: LD_INT 3
96236: NEG
96237: PUSH
96238: LD_INT 0
96240: PUSH
96241: EMPTY
96242: LIST
96243: LIST
96244: PUSH
96245: LD_INT 3
96247: NEG
96248: PUSH
96249: LD_INT 1
96251: PUSH
96252: EMPTY
96253: LIST
96254: LIST
96255: PUSH
96256: LD_INT 4
96258: NEG
96259: PUSH
96260: LD_INT 1
96262: NEG
96263: PUSH
96264: EMPTY
96265: LIST
96266: LIST
96267: PUSH
96268: EMPTY
96269: LIST
96270: LIST
96271: LIST
96272: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
96273: LD_ADDR_VAR 0 28
96277: PUSH
96278: LD_INT 3
96280: NEG
96281: PUSH
96282: LD_INT 3
96284: NEG
96285: PUSH
96286: EMPTY
96287: LIST
96288: LIST
96289: PUSH
96290: LD_INT 3
96292: NEG
96293: PUSH
96294: LD_INT 4
96296: NEG
96297: PUSH
96298: EMPTY
96299: LIST
96300: LIST
96301: PUSH
96302: LD_INT 4
96304: NEG
96305: PUSH
96306: LD_INT 3
96308: NEG
96309: PUSH
96310: EMPTY
96311: LIST
96312: LIST
96313: PUSH
96314: EMPTY
96315: LIST
96316: LIST
96317: LIST
96318: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
96319: LD_ADDR_VAR 0 29
96323: PUSH
96324: LD_INT 1
96326: NEG
96327: PUSH
96328: LD_INT 3
96330: NEG
96331: PUSH
96332: EMPTY
96333: LIST
96334: LIST
96335: PUSH
96336: LD_INT 0
96338: PUSH
96339: LD_INT 3
96341: NEG
96342: PUSH
96343: EMPTY
96344: LIST
96345: LIST
96346: PUSH
96347: LD_INT 1
96349: PUSH
96350: LD_INT 2
96352: NEG
96353: PUSH
96354: EMPTY
96355: LIST
96356: LIST
96357: PUSH
96358: LD_INT 1
96360: NEG
96361: PUSH
96362: LD_INT 4
96364: NEG
96365: PUSH
96366: EMPTY
96367: LIST
96368: LIST
96369: PUSH
96370: LD_INT 0
96372: PUSH
96373: LD_INT 4
96375: NEG
96376: PUSH
96377: EMPTY
96378: LIST
96379: LIST
96380: PUSH
96381: LD_INT 1
96383: PUSH
96384: LD_INT 3
96386: NEG
96387: PUSH
96388: EMPTY
96389: LIST
96390: LIST
96391: PUSH
96392: LD_INT 1
96394: NEG
96395: PUSH
96396: LD_INT 5
96398: NEG
96399: PUSH
96400: EMPTY
96401: LIST
96402: LIST
96403: PUSH
96404: LD_INT 0
96406: PUSH
96407: LD_INT 5
96409: NEG
96410: PUSH
96411: EMPTY
96412: LIST
96413: LIST
96414: PUSH
96415: LD_INT 1
96417: PUSH
96418: LD_INT 4
96420: NEG
96421: PUSH
96422: EMPTY
96423: LIST
96424: LIST
96425: PUSH
96426: LD_INT 1
96428: NEG
96429: PUSH
96430: LD_INT 6
96432: NEG
96433: PUSH
96434: EMPTY
96435: LIST
96436: LIST
96437: PUSH
96438: LD_INT 0
96440: PUSH
96441: LD_INT 6
96443: NEG
96444: PUSH
96445: EMPTY
96446: LIST
96447: LIST
96448: PUSH
96449: LD_INT 1
96451: PUSH
96452: LD_INT 5
96454: NEG
96455: PUSH
96456: EMPTY
96457: LIST
96458: LIST
96459: PUSH
96460: EMPTY
96461: LIST
96462: LIST
96463: LIST
96464: LIST
96465: LIST
96466: LIST
96467: LIST
96468: LIST
96469: LIST
96470: LIST
96471: LIST
96472: LIST
96473: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
96474: LD_ADDR_VAR 0 30
96478: PUSH
96479: LD_INT 2
96481: PUSH
96482: LD_INT 1
96484: NEG
96485: PUSH
96486: EMPTY
96487: LIST
96488: LIST
96489: PUSH
96490: LD_INT 3
96492: PUSH
96493: LD_INT 0
96495: PUSH
96496: EMPTY
96497: LIST
96498: LIST
96499: PUSH
96500: LD_INT 3
96502: PUSH
96503: LD_INT 1
96505: PUSH
96506: EMPTY
96507: LIST
96508: LIST
96509: PUSH
96510: LD_INT 3
96512: PUSH
96513: LD_INT 1
96515: NEG
96516: PUSH
96517: EMPTY
96518: LIST
96519: LIST
96520: PUSH
96521: LD_INT 4
96523: PUSH
96524: LD_INT 0
96526: PUSH
96527: EMPTY
96528: LIST
96529: LIST
96530: PUSH
96531: LD_INT 4
96533: PUSH
96534: LD_INT 1
96536: PUSH
96537: EMPTY
96538: LIST
96539: LIST
96540: PUSH
96541: LD_INT 4
96543: PUSH
96544: LD_INT 1
96546: NEG
96547: PUSH
96548: EMPTY
96549: LIST
96550: LIST
96551: PUSH
96552: LD_INT 5
96554: PUSH
96555: LD_INT 0
96557: PUSH
96558: EMPTY
96559: LIST
96560: LIST
96561: PUSH
96562: LD_INT 5
96564: PUSH
96565: LD_INT 1
96567: PUSH
96568: EMPTY
96569: LIST
96570: LIST
96571: PUSH
96572: LD_INT 5
96574: PUSH
96575: LD_INT 1
96577: NEG
96578: PUSH
96579: EMPTY
96580: LIST
96581: LIST
96582: PUSH
96583: LD_INT 6
96585: PUSH
96586: LD_INT 0
96588: PUSH
96589: EMPTY
96590: LIST
96591: LIST
96592: PUSH
96593: LD_INT 6
96595: PUSH
96596: LD_INT 1
96598: PUSH
96599: EMPTY
96600: LIST
96601: LIST
96602: PUSH
96603: EMPTY
96604: LIST
96605: LIST
96606: LIST
96607: LIST
96608: LIST
96609: LIST
96610: LIST
96611: LIST
96612: LIST
96613: LIST
96614: LIST
96615: LIST
96616: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
96617: LD_ADDR_VAR 0 31
96621: PUSH
96622: LD_INT 3
96624: PUSH
96625: LD_INT 2
96627: PUSH
96628: EMPTY
96629: LIST
96630: LIST
96631: PUSH
96632: LD_INT 3
96634: PUSH
96635: LD_INT 3
96637: PUSH
96638: EMPTY
96639: LIST
96640: LIST
96641: PUSH
96642: LD_INT 2
96644: PUSH
96645: LD_INT 3
96647: PUSH
96648: EMPTY
96649: LIST
96650: LIST
96651: PUSH
96652: LD_INT 4
96654: PUSH
96655: LD_INT 3
96657: PUSH
96658: EMPTY
96659: LIST
96660: LIST
96661: PUSH
96662: LD_INT 4
96664: PUSH
96665: LD_INT 4
96667: PUSH
96668: EMPTY
96669: LIST
96670: LIST
96671: PUSH
96672: LD_INT 3
96674: PUSH
96675: LD_INT 4
96677: PUSH
96678: EMPTY
96679: LIST
96680: LIST
96681: PUSH
96682: LD_INT 5
96684: PUSH
96685: LD_INT 4
96687: PUSH
96688: EMPTY
96689: LIST
96690: LIST
96691: PUSH
96692: LD_INT 5
96694: PUSH
96695: LD_INT 5
96697: PUSH
96698: EMPTY
96699: LIST
96700: LIST
96701: PUSH
96702: LD_INT 4
96704: PUSH
96705: LD_INT 5
96707: PUSH
96708: EMPTY
96709: LIST
96710: LIST
96711: PUSH
96712: LD_INT 6
96714: PUSH
96715: LD_INT 5
96717: PUSH
96718: EMPTY
96719: LIST
96720: LIST
96721: PUSH
96722: LD_INT 6
96724: PUSH
96725: LD_INT 6
96727: PUSH
96728: EMPTY
96729: LIST
96730: LIST
96731: PUSH
96732: LD_INT 5
96734: PUSH
96735: LD_INT 6
96737: PUSH
96738: EMPTY
96739: LIST
96740: LIST
96741: PUSH
96742: EMPTY
96743: LIST
96744: LIST
96745: LIST
96746: LIST
96747: LIST
96748: LIST
96749: LIST
96750: LIST
96751: LIST
96752: LIST
96753: LIST
96754: LIST
96755: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
96756: LD_ADDR_VAR 0 32
96760: PUSH
96761: LD_INT 1
96763: PUSH
96764: LD_INT 3
96766: PUSH
96767: EMPTY
96768: LIST
96769: LIST
96770: PUSH
96771: LD_INT 0
96773: PUSH
96774: LD_INT 3
96776: PUSH
96777: EMPTY
96778: LIST
96779: LIST
96780: PUSH
96781: LD_INT 1
96783: NEG
96784: PUSH
96785: LD_INT 2
96787: PUSH
96788: EMPTY
96789: LIST
96790: LIST
96791: PUSH
96792: LD_INT 1
96794: PUSH
96795: LD_INT 4
96797: PUSH
96798: EMPTY
96799: LIST
96800: LIST
96801: PUSH
96802: LD_INT 0
96804: PUSH
96805: LD_INT 4
96807: PUSH
96808: EMPTY
96809: LIST
96810: LIST
96811: PUSH
96812: LD_INT 1
96814: NEG
96815: PUSH
96816: LD_INT 3
96818: PUSH
96819: EMPTY
96820: LIST
96821: LIST
96822: PUSH
96823: LD_INT 1
96825: PUSH
96826: LD_INT 5
96828: PUSH
96829: EMPTY
96830: LIST
96831: LIST
96832: PUSH
96833: LD_INT 0
96835: PUSH
96836: LD_INT 5
96838: PUSH
96839: EMPTY
96840: LIST
96841: LIST
96842: PUSH
96843: LD_INT 1
96845: NEG
96846: PUSH
96847: LD_INT 4
96849: PUSH
96850: EMPTY
96851: LIST
96852: LIST
96853: PUSH
96854: LD_INT 1
96856: PUSH
96857: LD_INT 6
96859: PUSH
96860: EMPTY
96861: LIST
96862: LIST
96863: PUSH
96864: LD_INT 0
96866: PUSH
96867: LD_INT 6
96869: PUSH
96870: EMPTY
96871: LIST
96872: LIST
96873: PUSH
96874: LD_INT 1
96876: NEG
96877: PUSH
96878: LD_INT 5
96880: PUSH
96881: EMPTY
96882: LIST
96883: LIST
96884: PUSH
96885: EMPTY
96886: LIST
96887: LIST
96888: LIST
96889: LIST
96890: LIST
96891: LIST
96892: LIST
96893: LIST
96894: LIST
96895: LIST
96896: LIST
96897: LIST
96898: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
96899: LD_ADDR_VAR 0 33
96903: PUSH
96904: LD_INT 2
96906: NEG
96907: PUSH
96908: LD_INT 1
96910: PUSH
96911: EMPTY
96912: LIST
96913: LIST
96914: PUSH
96915: LD_INT 3
96917: NEG
96918: PUSH
96919: LD_INT 0
96921: PUSH
96922: EMPTY
96923: LIST
96924: LIST
96925: PUSH
96926: LD_INT 3
96928: NEG
96929: PUSH
96930: LD_INT 1
96932: NEG
96933: PUSH
96934: EMPTY
96935: LIST
96936: LIST
96937: PUSH
96938: LD_INT 3
96940: NEG
96941: PUSH
96942: LD_INT 1
96944: PUSH
96945: EMPTY
96946: LIST
96947: LIST
96948: PUSH
96949: LD_INT 4
96951: NEG
96952: PUSH
96953: LD_INT 0
96955: PUSH
96956: EMPTY
96957: LIST
96958: LIST
96959: PUSH
96960: LD_INT 4
96962: NEG
96963: PUSH
96964: LD_INT 1
96966: NEG
96967: PUSH
96968: EMPTY
96969: LIST
96970: LIST
96971: PUSH
96972: LD_INT 4
96974: NEG
96975: PUSH
96976: LD_INT 1
96978: PUSH
96979: EMPTY
96980: LIST
96981: LIST
96982: PUSH
96983: LD_INT 5
96985: NEG
96986: PUSH
96987: LD_INT 0
96989: PUSH
96990: EMPTY
96991: LIST
96992: LIST
96993: PUSH
96994: LD_INT 5
96996: NEG
96997: PUSH
96998: LD_INT 1
97000: NEG
97001: PUSH
97002: EMPTY
97003: LIST
97004: LIST
97005: PUSH
97006: LD_INT 5
97008: NEG
97009: PUSH
97010: LD_INT 1
97012: PUSH
97013: EMPTY
97014: LIST
97015: LIST
97016: PUSH
97017: LD_INT 6
97019: NEG
97020: PUSH
97021: LD_INT 0
97023: PUSH
97024: EMPTY
97025: LIST
97026: LIST
97027: PUSH
97028: LD_INT 6
97030: NEG
97031: PUSH
97032: LD_INT 1
97034: NEG
97035: PUSH
97036: EMPTY
97037: LIST
97038: LIST
97039: PUSH
97040: EMPTY
97041: LIST
97042: LIST
97043: LIST
97044: LIST
97045: LIST
97046: LIST
97047: LIST
97048: LIST
97049: LIST
97050: LIST
97051: LIST
97052: LIST
97053: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
97054: LD_ADDR_VAR 0 34
97058: PUSH
97059: LD_INT 2
97061: NEG
97062: PUSH
97063: LD_INT 3
97065: NEG
97066: PUSH
97067: EMPTY
97068: LIST
97069: LIST
97070: PUSH
97071: LD_INT 3
97073: NEG
97074: PUSH
97075: LD_INT 2
97077: NEG
97078: PUSH
97079: EMPTY
97080: LIST
97081: LIST
97082: PUSH
97083: LD_INT 3
97085: NEG
97086: PUSH
97087: LD_INT 3
97089: NEG
97090: PUSH
97091: EMPTY
97092: LIST
97093: LIST
97094: PUSH
97095: LD_INT 3
97097: NEG
97098: PUSH
97099: LD_INT 4
97101: NEG
97102: PUSH
97103: EMPTY
97104: LIST
97105: LIST
97106: PUSH
97107: LD_INT 4
97109: NEG
97110: PUSH
97111: LD_INT 3
97113: NEG
97114: PUSH
97115: EMPTY
97116: LIST
97117: LIST
97118: PUSH
97119: LD_INT 4
97121: NEG
97122: PUSH
97123: LD_INT 4
97125: NEG
97126: PUSH
97127: EMPTY
97128: LIST
97129: LIST
97130: PUSH
97131: LD_INT 4
97133: NEG
97134: PUSH
97135: LD_INT 5
97137: NEG
97138: PUSH
97139: EMPTY
97140: LIST
97141: LIST
97142: PUSH
97143: LD_INT 5
97145: NEG
97146: PUSH
97147: LD_INT 4
97149: NEG
97150: PUSH
97151: EMPTY
97152: LIST
97153: LIST
97154: PUSH
97155: LD_INT 5
97157: NEG
97158: PUSH
97159: LD_INT 5
97161: NEG
97162: PUSH
97163: EMPTY
97164: LIST
97165: LIST
97166: PUSH
97167: LD_INT 5
97169: NEG
97170: PUSH
97171: LD_INT 6
97173: NEG
97174: PUSH
97175: EMPTY
97176: LIST
97177: LIST
97178: PUSH
97179: LD_INT 6
97181: NEG
97182: PUSH
97183: LD_INT 5
97185: NEG
97186: PUSH
97187: EMPTY
97188: LIST
97189: LIST
97190: PUSH
97191: LD_INT 6
97193: NEG
97194: PUSH
97195: LD_INT 6
97197: NEG
97198: PUSH
97199: EMPTY
97200: LIST
97201: LIST
97202: PUSH
97203: EMPTY
97204: LIST
97205: LIST
97206: LIST
97207: LIST
97208: LIST
97209: LIST
97210: LIST
97211: LIST
97212: LIST
97213: LIST
97214: LIST
97215: LIST
97216: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
97217: LD_ADDR_VAR 0 41
97221: PUSH
97222: LD_INT 0
97224: PUSH
97225: LD_INT 2
97227: NEG
97228: PUSH
97229: EMPTY
97230: LIST
97231: LIST
97232: PUSH
97233: LD_INT 1
97235: NEG
97236: PUSH
97237: LD_INT 3
97239: NEG
97240: PUSH
97241: EMPTY
97242: LIST
97243: LIST
97244: PUSH
97245: LD_INT 1
97247: PUSH
97248: LD_INT 2
97250: NEG
97251: PUSH
97252: EMPTY
97253: LIST
97254: LIST
97255: PUSH
97256: EMPTY
97257: LIST
97258: LIST
97259: LIST
97260: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
97261: LD_ADDR_VAR 0 42
97265: PUSH
97266: LD_INT 2
97268: PUSH
97269: LD_INT 0
97271: PUSH
97272: EMPTY
97273: LIST
97274: LIST
97275: PUSH
97276: LD_INT 2
97278: PUSH
97279: LD_INT 1
97281: NEG
97282: PUSH
97283: EMPTY
97284: LIST
97285: LIST
97286: PUSH
97287: LD_INT 3
97289: PUSH
97290: LD_INT 1
97292: PUSH
97293: EMPTY
97294: LIST
97295: LIST
97296: PUSH
97297: EMPTY
97298: LIST
97299: LIST
97300: LIST
97301: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
97302: LD_ADDR_VAR 0 43
97306: PUSH
97307: LD_INT 2
97309: PUSH
97310: LD_INT 2
97312: PUSH
97313: EMPTY
97314: LIST
97315: LIST
97316: PUSH
97317: LD_INT 3
97319: PUSH
97320: LD_INT 2
97322: PUSH
97323: EMPTY
97324: LIST
97325: LIST
97326: PUSH
97327: LD_INT 2
97329: PUSH
97330: LD_INT 3
97332: PUSH
97333: EMPTY
97334: LIST
97335: LIST
97336: PUSH
97337: EMPTY
97338: LIST
97339: LIST
97340: LIST
97341: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
97342: LD_ADDR_VAR 0 44
97346: PUSH
97347: LD_INT 0
97349: PUSH
97350: LD_INT 2
97352: PUSH
97353: EMPTY
97354: LIST
97355: LIST
97356: PUSH
97357: LD_INT 1
97359: PUSH
97360: LD_INT 3
97362: PUSH
97363: EMPTY
97364: LIST
97365: LIST
97366: PUSH
97367: LD_INT 1
97369: NEG
97370: PUSH
97371: LD_INT 2
97373: PUSH
97374: EMPTY
97375: LIST
97376: LIST
97377: PUSH
97378: EMPTY
97379: LIST
97380: LIST
97381: LIST
97382: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
97383: LD_ADDR_VAR 0 45
97387: PUSH
97388: LD_INT 2
97390: NEG
97391: PUSH
97392: LD_INT 0
97394: PUSH
97395: EMPTY
97396: LIST
97397: LIST
97398: PUSH
97399: LD_INT 2
97401: NEG
97402: PUSH
97403: LD_INT 1
97405: PUSH
97406: EMPTY
97407: LIST
97408: LIST
97409: PUSH
97410: LD_INT 3
97412: NEG
97413: PUSH
97414: LD_INT 1
97416: NEG
97417: PUSH
97418: EMPTY
97419: LIST
97420: LIST
97421: PUSH
97422: EMPTY
97423: LIST
97424: LIST
97425: LIST
97426: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
97427: LD_ADDR_VAR 0 46
97431: PUSH
97432: LD_INT 2
97434: NEG
97435: PUSH
97436: LD_INT 2
97438: NEG
97439: PUSH
97440: EMPTY
97441: LIST
97442: LIST
97443: PUSH
97444: LD_INT 2
97446: NEG
97447: PUSH
97448: LD_INT 3
97450: NEG
97451: PUSH
97452: EMPTY
97453: LIST
97454: LIST
97455: PUSH
97456: LD_INT 3
97458: NEG
97459: PUSH
97460: LD_INT 2
97462: NEG
97463: PUSH
97464: EMPTY
97465: LIST
97466: LIST
97467: PUSH
97468: EMPTY
97469: LIST
97470: LIST
97471: LIST
97472: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
97473: LD_ADDR_VAR 0 47
97477: PUSH
97478: LD_INT 2
97480: NEG
97481: PUSH
97482: LD_INT 3
97484: NEG
97485: PUSH
97486: EMPTY
97487: LIST
97488: LIST
97489: PUSH
97490: LD_INT 1
97492: NEG
97493: PUSH
97494: LD_INT 3
97496: NEG
97497: PUSH
97498: EMPTY
97499: LIST
97500: LIST
97501: PUSH
97502: EMPTY
97503: LIST
97504: LIST
97505: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
97506: LD_ADDR_VAR 0 48
97510: PUSH
97511: LD_INT 1
97513: PUSH
97514: LD_INT 2
97516: NEG
97517: PUSH
97518: EMPTY
97519: LIST
97520: LIST
97521: PUSH
97522: LD_INT 2
97524: PUSH
97525: LD_INT 1
97527: NEG
97528: PUSH
97529: EMPTY
97530: LIST
97531: LIST
97532: PUSH
97533: EMPTY
97534: LIST
97535: LIST
97536: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
97537: LD_ADDR_VAR 0 49
97541: PUSH
97542: LD_INT 3
97544: PUSH
97545: LD_INT 1
97547: PUSH
97548: EMPTY
97549: LIST
97550: LIST
97551: PUSH
97552: LD_INT 3
97554: PUSH
97555: LD_INT 2
97557: PUSH
97558: EMPTY
97559: LIST
97560: LIST
97561: PUSH
97562: EMPTY
97563: LIST
97564: LIST
97565: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
97566: LD_ADDR_VAR 0 50
97570: PUSH
97571: LD_INT 2
97573: PUSH
97574: LD_INT 3
97576: PUSH
97577: EMPTY
97578: LIST
97579: LIST
97580: PUSH
97581: LD_INT 1
97583: PUSH
97584: LD_INT 3
97586: PUSH
97587: EMPTY
97588: LIST
97589: LIST
97590: PUSH
97591: EMPTY
97592: LIST
97593: LIST
97594: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
97595: LD_ADDR_VAR 0 51
97599: PUSH
97600: LD_INT 1
97602: NEG
97603: PUSH
97604: LD_INT 2
97606: PUSH
97607: EMPTY
97608: LIST
97609: LIST
97610: PUSH
97611: LD_INT 2
97613: NEG
97614: PUSH
97615: LD_INT 1
97617: PUSH
97618: EMPTY
97619: LIST
97620: LIST
97621: PUSH
97622: EMPTY
97623: LIST
97624: LIST
97625: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
97626: LD_ADDR_VAR 0 52
97630: PUSH
97631: LD_INT 3
97633: NEG
97634: PUSH
97635: LD_INT 1
97637: NEG
97638: PUSH
97639: EMPTY
97640: LIST
97641: LIST
97642: PUSH
97643: LD_INT 3
97645: NEG
97646: PUSH
97647: LD_INT 2
97649: NEG
97650: PUSH
97651: EMPTY
97652: LIST
97653: LIST
97654: PUSH
97655: EMPTY
97656: LIST
97657: LIST
97658: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
97659: LD_ADDR_VAR 0 53
97663: PUSH
97664: LD_INT 1
97666: NEG
97667: PUSH
97668: LD_INT 3
97670: NEG
97671: PUSH
97672: EMPTY
97673: LIST
97674: LIST
97675: PUSH
97676: LD_INT 0
97678: PUSH
97679: LD_INT 3
97681: NEG
97682: PUSH
97683: EMPTY
97684: LIST
97685: LIST
97686: PUSH
97687: LD_INT 1
97689: PUSH
97690: LD_INT 2
97692: NEG
97693: PUSH
97694: EMPTY
97695: LIST
97696: LIST
97697: PUSH
97698: EMPTY
97699: LIST
97700: LIST
97701: LIST
97702: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
97703: LD_ADDR_VAR 0 54
97707: PUSH
97708: LD_INT 2
97710: PUSH
97711: LD_INT 1
97713: NEG
97714: PUSH
97715: EMPTY
97716: LIST
97717: LIST
97718: PUSH
97719: LD_INT 3
97721: PUSH
97722: LD_INT 0
97724: PUSH
97725: EMPTY
97726: LIST
97727: LIST
97728: PUSH
97729: LD_INT 3
97731: PUSH
97732: LD_INT 1
97734: PUSH
97735: EMPTY
97736: LIST
97737: LIST
97738: PUSH
97739: EMPTY
97740: LIST
97741: LIST
97742: LIST
97743: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
97744: LD_ADDR_VAR 0 55
97748: PUSH
97749: LD_INT 3
97751: PUSH
97752: LD_INT 2
97754: PUSH
97755: EMPTY
97756: LIST
97757: LIST
97758: PUSH
97759: LD_INT 3
97761: PUSH
97762: LD_INT 3
97764: PUSH
97765: EMPTY
97766: LIST
97767: LIST
97768: PUSH
97769: LD_INT 2
97771: PUSH
97772: LD_INT 3
97774: PUSH
97775: EMPTY
97776: LIST
97777: LIST
97778: PUSH
97779: EMPTY
97780: LIST
97781: LIST
97782: LIST
97783: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
97784: LD_ADDR_VAR 0 56
97788: PUSH
97789: LD_INT 1
97791: PUSH
97792: LD_INT 3
97794: PUSH
97795: EMPTY
97796: LIST
97797: LIST
97798: PUSH
97799: LD_INT 0
97801: PUSH
97802: LD_INT 3
97804: PUSH
97805: EMPTY
97806: LIST
97807: LIST
97808: PUSH
97809: LD_INT 1
97811: NEG
97812: PUSH
97813: LD_INT 2
97815: PUSH
97816: EMPTY
97817: LIST
97818: LIST
97819: PUSH
97820: EMPTY
97821: LIST
97822: LIST
97823: LIST
97824: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
97825: LD_ADDR_VAR 0 57
97829: PUSH
97830: LD_INT 2
97832: NEG
97833: PUSH
97834: LD_INT 1
97836: PUSH
97837: EMPTY
97838: LIST
97839: LIST
97840: PUSH
97841: LD_INT 3
97843: NEG
97844: PUSH
97845: LD_INT 0
97847: PUSH
97848: EMPTY
97849: LIST
97850: LIST
97851: PUSH
97852: LD_INT 3
97854: NEG
97855: PUSH
97856: LD_INT 1
97858: NEG
97859: PUSH
97860: EMPTY
97861: LIST
97862: LIST
97863: PUSH
97864: EMPTY
97865: LIST
97866: LIST
97867: LIST
97868: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
97869: LD_ADDR_VAR 0 58
97873: PUSH
97874: LD_INT 2
97876: NEG
97877: PUSH
97878: LD_INT 3
97880: NEG
97881: PUSH
97882: EMPTY
97883: LIST
97884: LIST
97885: PUSH
97886: LD_INT 3
97888: NEG
97889: PUSH
97890: LD_INT 2
97892: NEG
97893: PUSH
97894: EMPTY
97895: LIST
97896: LIST
97897: PUSH
97898: LD_INT 3
97900: NEG
97901: PUSH
97902: LD_INT 3
97904: NEG
97905: PUSH
97906: EMPTY
97907: LIST
97908: LIST
97909: PUSH
97910: EMPTY
97911: LIST
97912: LIST
97913: LIST
97914: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
97915: LD_ADDR_VAR 0 59
97919: PUSH
97920: LD_INT 1
97922: NEG
97923: PUSH
97924: LD_INT 2
97926: NEG
97927: PUSH
97928: EMPTY
97929: LIST
97930: LIST
97931: PUSH
97932: LD_INT 0
97934: PUSH
97935: LD_INT 2
97937: NEG
97938: PUSH
97939: EMPTY
97940: LIST
97941: LIST
97942: PUSH
97943: LD_INT 1
97945: PUSH
97946: LD_INT 1
97948: NEG
97949: PUSH
97950: EMPTY
97951: LIST
97952: LIST
97953: PUSH
97954: EMPTY
97955: LIST
97956: LIST
97957: LIST
97958: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
97959: LD_ADDR_VAR 0 60
97963: PUSH
97964: LD_INT 1
97966: PUSH
97967: LD_INT 1
97969: NEG
97970: PUSH
97971: EMPTY
97972: LIST
97973: LIST
97974: PUSH
97975: LD_INT 2
97977: PUSH
97978: LD_INT 0
97980: PUSH
97981: EMPTY
97982: LIST
97983: LIST
97984: PUSH
97985: LD_INT 2
97987: PUSH
97988: LD_INT 1
97990: PUSH
97991: EMPTY
97992: LIST
97993: LIST
97994: PUSH
97995: EMPTY
97996: LIST
97997: LIST
97998: LIST
97999: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
98000: LD_ADDR_VAR 0 61
98004: PUSH
98005: LD_INT 2
98007: PUSH
98008: LD_INT 1
98010: PUSH
98011: EMPTY
98012: LIST
98013: LIST
98014: PUSH
98015: LD_INT 2
98017: PUSH
98018: LD_INT 2
98020: PUSH
98021: EMPTY
98022: LIST
98023: LIST
98024: PUSH
98025: LD_INT 1
98027: PUSH
98028: LD_INT 2
98030: PUSH
98031: EMPTY
98032: LIST
98033: LIST
98034: PUSH
98035: EMPTY
98036: LIST
98037: LIST
98038: LIST
98039: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
98040: LD_ADDR_VAR 0 62
98044: PUSH
98045: LD_INT 1
98047: PUSH
98048: LD_INT 2
98050: PUSH
98051: EMPTY
98052: LIST
98053: LIST
98054: PUSH
98055: LD_INT 0
98057: PUSH
98058: LD_INT 2
98060: PUSH
98061: EMPTY
98062: LIST
98063: LIST
98064: PUSH
98065: LD_INT 1
98067: NEG
98068: PUSH
98069: LD_INT 1
98071: PUSH
98072: EMPTY
98073: LIST
98074: LIST
98075: PUSH
98076: EMPTY
98077: LIST
98078: LIST
98079: LIST
98080: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
98081: LD_ADDR_VAR 0 63
98085: PUSH
98086: LD_INT 1
98088: NEG
98089: PUSH
98090: LD_INT 1
98092: PUSH
98093: EMPTY
98094: LIST
98095: LIST
98096: PUSH
98097: LD_INT 2
98099: NEG
98100: PUSH
98101: LD_INT 0
98103: PUSH
98104: EMPTY
98105: LIST
98106: LIST
98107: PUSH
98108: LD_INT 2
98110: NEG
98111: PUSH
98112: LD_INT 1
98114: NEG
98115: PUSH
98116: EMPTY
98117: LIST
98118: LIST
98119: PUSH
98120: EMPTY
98121: LIST
98122: LIST
98123: LIST
98124: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
98125: LD_ADDR_VAR 0 64
98129: PUSH
98130: LD_INT 1
98132: NEG
98133: PUSH
98134: LD_INT 2
98136: NEG
98137: PUSH
98138: EMPTY
98139: LIST
98140: LIST
98141: PUSH
98142: LD_INT 2
98144: NEG
98145: PUSH
98146: LD_INT 1
98148: NEG
98149: PUSH
98150: EMPTY
98151: LIST
98152: LIST
98153: PUSH
98154: LD_INT 2
98156: NEG
98157: PUSH
98158: LD_INT 2
98160: NEG
98161: PUSH
98162: EMPTY
98163: LIST
98164: LIST
98165: PUSH
98166: EMPTY
98167: LIST
98168: LIST
98169: LIST
98170: ST_TO_ADDR
// end ; 2 :
98171: GO 101437
98173: LD_INT 2
98175: DOUBLE
98176: EQUAL
98177: IFTRUE 98181
98179: GO 101436
98181: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
98182: LD_ADDR_VAR 0 29
98186: PUSH
98187: LD_INT 4
98189: PUSH
98190: LD_INT 0
98192: PUSH
98193: EMPTY
98194: LIST
98195: LIST
98196: PUSH
98197: LD_INT 4
98199: PUSH
98200: LD_INT 1
98202: NEG
98203: PUSH
98204: EMPTY
98205: LIST
98206: LIST
98207: PUSH
98208: LD_INT 5
98210: PUSH
98211: LD_INT 0
98213: PUSH
98214: EMPTY
98215: LIST
98216: LIST
98217: PUSH
98218: LD_INT 5
98220: PUSH
98221: LD_INT 1
98223: PUSH
98224: EMPTY
98225: LIST
98226: LIST
98227: PUSH
98228: LD_INT 4
98230: PUSH
98231: LD_INT 1
98233: PUSH
98234: EMPTY
98235: LIST
98236: LIST
98237: PUSH
98238: LD_INT 3
98240: PUSH
98241: LD_INT 0
98243: PUSH
98244: EMPTY
98245: LIST
98246: LIST
98247: PUSH
98248: LD_INT 3
98250: PUSH
98251: LD_INT 1
98253: NEG
98254: PUSH
98255: EMPTY
98256: LIST
98257: LIST
98258: PUSH
98259: LD_INT 3
98261: PUSH
98262: LD_INT 2
98264: NEG
98265: PUSH
98266: EMPTY
98267: LIST
98268: LIST
98269: PUSH
98270: LD_INT 5
98272: PUSH
98273: LD_INT 2
98275: PUSH
98276: EMPTY
98277: LIST
98278: LIST
98279: PUSH
98280: LD_INT 3
98282: PUSH
98283: LD_INT 3
98285: PUSH
98286: EMPTY
98287: LIST
98288: LIST
98289: PUSH
98290: LD_INT 3
98292: PUSH
98293: LD_INT 2
98295: PUSH
98296: EMPTY
98297: LIST
98298: LIST
98299: PUSH
98300: LD_INT 4
98302: PUSH
98303: LD_INT 3
98305: PUSH
98306: EMPTY
98307: LIST
98308: LIST
98309: PUSH
98310: LD_INT 4
98312: PUSH
98313: LD_INT 4
98315: PUSH
98316: EMPTY
98317: LIST
98318: LIST
98319: PUSH
98320: LD_INT 3
98322: PUSH
98323: LD_INT 4
98325: PUSH
98326: EMPTY
98327: LIST
98328: LIST
98329: PUSH
98330: LD_INT 2
98332: PUSH
98333: LD_INT 3
98335: PUSH
98336: EMPTY
98337: LIST
98338: LIST
98339: PUSH
98340: LD_INT 2
98342: PUSH
98343: LD_INT 2
98345: PUSH
98346: EMPTY
98347: LIST
98348: LIST
98349: PUSH
98350: LD_INT 4
98352: PUSH
98353: LD_INT 2
98355: PUSH
98356: EMPTY
98357: LIST
98358: LIST
98359: PUSH
98360: LD_INT 2
98362: PUSH
98363: LD_INT 4
98365: PUSH
98366: EMPTY
98367: LIST
98368: LIST
98369: PUSH
98370: LD_INT 0
98372: PUSH
98373: LD_INT 4
98375: PUSH
98376: EMPTY
98377: LIST
98378: LIST
98379: PUSH
98380: LD_INT 0
98382: PUSH
98383: LD_INT 3
98385: PUSH
98386: EMPTY
98387: LIST
98388: LIST
98389: PUSH
98390: LD_INT 1
98392: PUSH
98393: LD_INT 4
98395: PUSH
98396: EMPTY
98397: LIST
98398: LIST
98399: PUSH
98400: LD_INT 1
98402: PUSH
98403: LD_INT 5
98405: PUSH
98406: EMPTY
98407: LIST
98408: LIST
98409: PUSH
98410: LD_INT 0
98412: PUSH
98413: LD_INT 5
98415: PUSH
98416: EMPTY
98417: LIST
98418: LIST
98419: PUSH
98420: LD_INT 1
98422: NEG
98423: PUSH
98424: LD_INT 4
98426: PUSH
98427: EMPTY
98428: LIST
98429: LIST
98430: PUSH
98431: LD_INT 1
98433: NEG
98434: PUSH
98435: LD_INT 3
98437: PUSH
98438: EMPTY
98439: LIST
98440: LIST
98441: PUSH
98442: LD_INT 2
98444: PUSH
98445: LD_INT 5
98447: PUSH
98448: EMPTY
98449: LIST
98450: LIST
98451: PUSH
98452: LD_INT 2
98454: NEG
98455: PUSH
98456: LD_INT 3
98458: PUSH
98459: EMPTY
98460: LIST
98461: LIST
98462: PUSH
98463: LD_INT 3
98465: NEG
98466: PUSH
98467: LD_INT 0
98469: PUSH
98470: EMPTY
98471: LIST
98472: LIST
98473: PUSH
98474: LD_INT 3
98476: NEG
98477: PUSH
98478: LD_INT 1
98480: NEG
98481: PUSH
98482: EMPTY
98483: LIST
98484: LIST
98485: PUSH
98486: LD_INT 2
98488: NEG
98489: PUSH
98490: LD_INT 0
98492: PUSH
98493: EMPTY
98494: LIST
98495: LIST
98496: PUSH
98497: LD_INT 2
98499: NEG
98500: PUSH
98501: LD_INT 1
98503: PUSH
98504: EMPTY
98505: LIST
98506: LIST
98507: PUSH
98508: LD_INT 3
98510: NEG
98511: PUSH
98512: LD_INT 1
98514: PUSH
98515: EMPTY
98516: LIST
98517: LIST
98518: PUSH
98519: LD_INT 4
98521: NEG
98522: PUSH
98523: LD_INT 0
98525: PUSH
98526: EMPTY
98527: LIST
98528: LIST
98529: PUSH
98530: LD_INT 4
98532: NEG
98533: PUSH
98534: LD_INT 1
98536: NEG
98537: PUSH
98538: EMPTY
98539: LIST
98540: LIST
98541: PUSH
98542: LD_INT 4
98544: NEG
98545: PUSH
98546: LD_INT 2
98548: NEG
98549: PUSH
98550: EMPTY
98551: LIST
98552: LIST
98553: PUSH
98554: LD_INT 2
98556: NEG
98557: PUSH
98558: LD_INT 2
98560: PUSH
98561: EMPTY
98562: LIST
98563: LIST
98564: PUSH
98565: LD_INT 4
98567: NEG
98568: PUSH
98569: LD_INT 4
98571: NEG
98572: PUSH
98573: EMPTY
98574: LIST
98575: LIST
98576: PUSH
98577: LD_INT 4
98579: NEG
98580: PUSH
98581: LD_INT 5
98583: NEG
98584: PUSH
98585: EMPTY
98586: LIST
98587: LIST
98588: PUSH
98589: LD_INT 3
98591: NEG
98592: PUSH
98593: LD_INT 4
98595: NEG
98596: PUSH
98597: EMPTY
98598: LIST
98599: LIST
98600: PUSH
98601: LD_INT 3
98603: NEG
98604: PUSH
98605: LD_INT 3
98607: NEG
98608: PUSH
98609: EMPTY
98610: LIST
98611: LIST
98612: PUSH
98613: LD_INT 4
98615: NEG
98616: PUSH
98617: LD_INT 3
98619: NEG
98620: PUSH
98621: EMPTY
98622: LIST
98623: LIST
98624: PUSH
98625: LD_INT 5
98627: NEG
98628: PUSH
98629: LD_INT 4
98631: NEG
98632: PUSH
98633: EMPTY
98634: LIST
98635: LIST
98636: PUSH
98637: LD_INT 5
98639: NEG
98640: PUSH
98641: LD_INT 5
98643: NEG
98644: PUSH
98645: EMPTY
98646: LIST
98647: LIST
98648: PUSH
98649: LD_INT 3
98651: NEG
98652: PUSH
98653: LD_INT 5
98655: NEG
98656: PUSH
98657: EMPTY
98658: LIST
98659: LIST
98660: PUSH
98661: LD_INT 5
98663: NEG
98664: PUSH
98665: LD_INT 3
98667: NEG
98668: PUSH
98669: EMPTY
98670: LIST
98671: LIST
98672: PUSH
98673: EMPTY
98674: LIST
98675: LIST
98676: LIST
98677: LIST
98678: LIST
98679: LIST
98680: LIST
98681: LIST
98682: LIST
98683: LIST
98684: LIST
98685: LIST
98686: LIST
98687: LIST
98688: LIST
98689: LIST
98690: LIST
98691: LIST
98692: LIST
98693: LIST
98694: LIST
98695: LIST
98696: LIST
98697: LIST
98698: LIST
98699: LIST
98700: LIST
98701: LIST
98702: LIST
98703: LIST
98704: LIST
98705: LIST
98706: LIST
98707: LIST
98708: LIST
98709: LIST
98710: LIST
98711: LIST
98712: LIST
98713: LIST
98714: LIST
98715: LIST
98716: LIST
98717: LIST
98718: LIST
98719: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
98720: LD_ADDR_VAR 0 30
98724: PUSH
98725: LD_INT 4
98727: PUSH
98728: LD_INT 4
98730: PUSH
98731: EMPTY
98732: LIST
98733: LIST
98734: PUSH
98735: LD_INT 4
98737: PUSH
98738: LD_INT 3
98740: PUSH
98741: EMPTY
98742: LIST
98743: LIST
98744: PUSH
98745: LD_INT 5
98747: PUSH
98748: LD_INT 4
98750: PUSH
98751: EMPTY
98752: LIST
98753: LIST
98754: PUSH
98755: LD_INT 5
98757: PUSH
98758: LD_INT 5
98760: PUSH
98761: EMPTY
98762: LIST
98763: LIST
98764: PUSH
98765: LD_INT 4
98767: PUSH
98768: LD_INT 5
98770: PUSH
98771: EMPTY
98772: LIST
98773: LIST
98774: PUSH
98775: LD_INT 3
98777: PUSH
98778: LD_INT 4
98780: PUSH
98781: EMPTY
98782: LIST
98783: LIST
98784: PUSH
98785: LD_INT 3
98787: PUSH
98788: LD_INT 3
98790: PUSH
98791: EMPTY
98792: LIST
98793: LIST
98794: PUSH
98795: LD_INT 5
98797: PUSH
98798: LD_INT 3
98800: PUSH
98801: EMPTY
98802: LIST
98803: LIST
98804: PUSH
98805: LD_INT 3
98807: PUSH
98808: LD_INT 5
98810: PUSH
98811: EMPTY
98812: LIST
98813: LIST
98814: PUSH
98815: LD_INT 0
98817: PUSH
98818: LD_INT 3
98820: PUSH
98821: EMPTY
98822: LIST
98823: LIST
98824: PUSH
98825: LD_INT 0
98827: PUSH
98828: LD_INT 2
98830: PUSH
98831: EMPTY
98832: LIST
98833: LIST
98834: PUSH
98835: LD_INT 1
98837: PUSH
98838: LD_INT 3
98840: PUSH
98841: EMPTY
98842: LIST
98843: LIST
98844: PUSH
98845: LD_INT 1
98847: PUSH
98848: LD_INT 4
98850: PUSH
98851: EMPTY
98852: LIST
98853: LIST
98854: PUSH
98855: LD_INT 0
98857: PUSH
98858: LD_INT 4
98860: PUSH
98861: EMPTY
98862: LIST
98863: LIST
98864: PUSH
98865: LD_INT 1
98867: NEG
98868: PUSH
98869: LD_INT 3
98871: PUSH
98872: EMPTY
98873: LIST
98874: LIST
98875: PUSH
98876: LD_INT 1
98878: NEG
98879: PUSH
98880: LD_INT 2
98882: PUSH
98883: EMPTY
98884: LIST
98885: LIST
98886: PUSH
98887: LD_INT 2
98889: PUSH
98890: LD_INT 4
98892: PUSH
98893: EMPTY
98894: LIST
98895: LIST
98896: PUSH
98897: LD_INT 2
98899: NEG
98900: PUSH
98901: LD_INT 2
98903: PUSH
98904: EMPTY
98905: LIST
98906: LIST
98907: PUSH
98908: LD_INT 4
98910: NEG
98911: PUSH
98912: LD_INT 0
98914: PUSH
98915: EMPTY
98916: LIST
98917: LIST
98918: PUSH
98919: LD_INT 4
98921: NEG
98922: PUSH
98923: LD_INT 1
98925: NEG
98926: PUSH
98927: EMPTY
98928: LIST
98929: LIST
98930: PUSH
98931: LD_INT 3
98933: NEG
98934: PUSH
98935: LD_INT 0
98937: PUSH
98938: EMPTY
98939: LIST
98940: LIST
98941: PUSH
98942: LD_INT 3
98944: NEG
98945: PUSH
98946: LD_INT 1
98948: PUSH
98949: EMPTY
98950: LIST
98951: LIST
98952: PUSH
98953: LD_INT 4
98955: NEG
98956: PUSH
98957: LD_INT 1
98959: PUSH
98960: EMPTY
98961: LIST
98962: LIST
98963: PUSH
98964: LD_INT 5
98966: NEG
98967: PUSH
98968: LD_INT 0
98970: PUSH
98971: EMPTY
98972: LIST
98973: LIST
98974: PUSH
98975: LD_INT 5
98977: NEG
98978: PUSH
98979: LD_INT 1
98981: NEG
98982: PUSH
98983: EMPTY
98984: LIST
98985: LIST
98986: PUSH
98987: LD_INT 5
98989: NEG
98990: PUSH
98991: LD_INT 2
98993: NEG
98994: PUSH
98995: EMPTY
98996: LIST
98997: LIST
98998: PUSH
98999: LD_INT 3
99001: NEG
99002: PUSH
99003: LD_INT 2
99005: PUSH
99006: EMPTY
99007: LIST
99008: LIST
99009: PUSH
99010: LD_INT 3
99012: NEG
99013: PUSH
99014: LD_INT 3
99016: NEG
99017: PUSH
99018: EMPTY
99019: LIST
99020: LIST
99021: PUSH
99022: LD_INT 3
99024: NEG
99025: PUSH
99026: LD_INT 4
99028: NEG
99029: PUSH
99030: EMPTY
99031: LIST
99032: LIST
99033: PUSH
99034: LD_INT 2
99036: NEG
99037: PUSH
99038: LD_INT 3
99040: NEG
99041: PUSH
99042: EMPTY
99043: LIST
99044: LIST
99045: PUSH
99046: LD_INT 2
99048: NEG
99049: PUSH
99050: LD_INT 2
99052: NEG
99053: PUSH
99054: EMPTY
99055: LIST
99056: LIST
99057: PUSH
99058: LD_INT 3
99060: NEG
99061: PUSH
99062: LD_INT 2
99064: NEG
99065: PUSH
99066: EMPTY
99067: LIST
99068: LIST
99069: PUSH
99070: LD_INT 4
99072: NEG
99073: PUSH
99074: LD_INT 3
99076: NEG
99077: PUSH
99078: EMPTY
99079: LIST
99080: LIST
99081: PUSH
99082: LD_INT 4
99084: NEG
99085: PUSH
99086: LD_INT 4
99088: NEG
99089: PUSH
99090: EMPTY
99091: LIST
99092: LIST
99093: PUSH
99094: LD_INT 2
99096: NEG
99097: PUSH
99098: LD_INT 4
99100: NEG
99101: PUSH
99102: EMPTY
99103: LIST
99104: LIST
99105: PUSH
99106: LD_INT 4
99108: NEG
99109: PUSH
99110: LD_INT 2
99112: NEG
99113: PUSH
99114: EMPTY
99115: LIST
99116: LIST
99117: PUSH
99118: LD_INT 0
99120: PUSH
99121: LD_INT 4
99123: NEG
99124: PUSH
99125: EMPTY
99126: LIST
99127: LIST
99128: PUSH
99129: LD_INT 0
99131: PUSH
99132: LD_INT 5
99134: NEG
99135: PUSH
99136: EMPTY
99137: LIST
99138: LIST
99139: PUSH
99140: LD_INT 1
99142: PUSH
99143: LD_INT 4
99145: NEG
99146: PUSH
99147: EMPTY
99148: LIST
99149: LIST
99150: PUSH
99151: LD_INT 1
99153: PUSH
99154: LD_INT 3
99156: NEG
99157: PUSH
99158: EMPTY
99159: LIST
99160: LIST
99161: PUSH
99162: LD_INT 0
99164: PUSH
99165: LD_INT 3
99167: NEG
99168: PUSH
99169: EMPTY
99170: LIST
99171: LIST
99172: PUSH
99173: LD_INT 1
99175: NEG
99176: PUSH
99177: LD_INT 4
99179: NEG
99180: PUSH
99181: EMPTY
99182: LIST
99183: LIST
99184: PUSH
99185: LD_INT 1
99187: NEG
99188: PUSH
99189: LD_INT 5
99191: NEG
99192: PUSH
99193: EMPTY
99194: LIST
99195: LIST
99196: PUSH
99197: LD_INT 2
99199: PUSH
99200: LD_INT 3
99202: NEG
99203: PUSH
99204: EMPTY
99205: LIST
99206: LIST
99207: PUSH
99208: LD_INT 2
99210: NEG
99211: PUSH
99212: LD_INT 5
99214: NEG
99215: PUSH
99216: EMPTY
99217: LIST
99218: LIST
99219: PUSH
99220: EMPTY
99221: LIST
99222: LIST
99223: LIST
99224: LIST
99225: LIST
99226: LIST
99227: LIST
99228: LIST
99229: LIST
99230: LIST
99231: LIST
99232: LIST
99233: LIST
99234: LIST
99235: LIST
99236: LIST
99237: LIST
99238: LIST
99239: LIST
99240: LIST
99241: LIST
99242: LIST
99243: LIST
99244: LIST
99245: LIST
99246: LIST
99247: LIST
99248: LIST
99249: LIST
99250: LIST
99251: LIST
99252: LIST
99253: LIST
99254: LIST
99255: LIST
99256: LIST
99257: LIST
99258: LIST
99259: LIST
99260: LIST
99261: LIST
99262: LIST
99263: LIST
99264: LIST
99265: LIST
99266: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
99267: LD_ADDR_VAR 0 31
99271: PUSH
99272: LD_INT 0
99274: PUSH
99275: LD_INT 4
99277: PUSH
99278: EMPTY
99279: LIST
99280: LIST
99281: PUSH
99282: LD_INT 0
99284: PUSH
99285: LD_INT 3
99287: PUSH
99288: EMPTY
99289: LIST
99290: LIST
99291: PUSH
99292: LD_INT 1
99294: PUSH
99295: LD_INT 4
99297: PUSH
99298: EMPTY
99299: LIST
99300: LIST
99301: PUSH
99302: LD_INT 1
99304: PUSH
99305: LD_INT 5
99307: PUSH
99308: EMPTY
99309: LIST
99310: LIST
99311: PUSH
99312: LD_INT 0
99314: PUSH
99315: LD_INT 5
99317: PUSH
99318: EMPTY
99319: LIST
99320: LIST
99321: PUSH
99322: LD_INT 1
99324: NEG
99325: PUSH
99326: LD_INT 4
99328: PUSH
99329: EMPTY
99330: LIST
99331: LIST
99332: PUSH
99333: LD_INT 1
99335: NEG
99336: PUSH
99337: LD_INT 3
99339: PUSH
99340: EMPTY
99341: LIST
99342: LIST
99343: PUSH
99344: LD_INT 2
99346: PUSH
99347: LD_INT 5
99349: PUSH
99350: EMPTY
99351: LIST
99352: LIST
99353: PUSH
99354: LD_INT 2
99356: NEG
99357: PUSH
99358: LD_INT 3
99360: PUSH
99361: EMPTY
99362: LIST
99363: LIST
99364: PUSH
99365: LD_INT 3
99367: NEG
99368: PUSH
99369: LD_INT 0
99371: PUSH
99372: EMPTY
99373: LIST
99374: LIST
99375: PUSH
99376: LD_INT 3
99378: NEG
99379: PUSH
99380: LD_INT 1
99382: NEG
99383: PUSH
99384: EMPTY
99385: LIST
99386: LIST
99387: PUSH
99388: LD_INT 2
99390: NEG
99391: PUSH
99392: LD_INT 0
99394: PUSH
99395: EMPTY
99396: LIST
99397: LIST
99398: PUSH
99399: LD_INT 2
99401: NEG
99402: PUSH
99403: LD_INT 1
99405: PUSH
99406: EMPTY
99407: LIST
99408: LIST
99409: PUSH
99410: LD_INT 3
99412: NEG
99413: PUSH
99414: LD_INT 1
99416: PUSH
99417: EMPTY
99418: LIST
99419: LIST
99420: PUSH
99421: LD_INT 4
99423: NEG
99424: PUSH
99425: LD_INT 0
99427: PUSH
99428: EMPTY
99429: LIST
99430: LIST
99431: PUSH
99432: LD_INT 4
99434: NEG
99435: PUSH
99436: LD_INT 1
99438: NEG
99439: PUSH
99440: EMPTY
99441: LIST
99442: LIST
99443: PUSH
99444: LD_INT 4
99446: NEG
99447: PUSH
99448: LD_INT 2
99450: NEG
99451: PUSH
99452: EMPTY
99453: LIST
99454: LIST
99455: PUSH
99456: LD_INT 2
99458: NEG
99459: PUSH
99460: LD_INT 2
99462: PUSH
99463: EMPTY
99464: LIST
99465: LIST
99466: PUSH
99467: LD_INT 4
99469: NEG
99470: PUSH
99471: LD_INT 4
99473: NEG
99474: PUSH
99475: EMPTY
99476: LIST
99477: LIST
99478: PUSH
99479: LD_INT 4
99481: NEG
99482: PUSH
99483: LD_INT 5
99485: NEG
99486: PUSH
99487: EMPTY
99488: LIST
99489: LIST
99490: PUSH
99491: LD_INT 3
99493: NEG
99494: PUSH
99495: LD_INT 4
99497: NEG
99498: PUSH
99499: EMPTY
99500: LIST
99501: LIST
99502: PUSH
99503: LD_INT 3
99505: NEG
99506: PUSH
99507: LD_INT 3
99509: NEG
99510: PUSH
99511: EMPTY
99512: LIST
99513: LIST
99514: PUSH
99515: LD_INT 4
99517: NEG
99518: PUSH
99519: LD_INT 3
99521: NEG
99522: PUSH
99523: EMPTY
99524: LIST
99525: LIST
99526: PUSH
99527: LD_INT 5
99529: NEG
99530: PUSH
99531: LD_INT 4
99533: NEG
99534: PUSH
99535: EMPTY
99536: LIST
99537: LIST
99538: PUSH
99539: LD_INT 5
99541: NEG
99542: PUSH
99543: LD_INT 5
99545: NEG
99546: PUSH
99547: EMPTY
99548: LIST
99549: LIST
99550: PUSH
99551: LD_INT 3
99553: NEG
99554: PUSH
99555: LD_INT 5
99557: NEG
99558: PUSH
99559: EMPTY
99560: LIST
99561: LIST
99562: PUSH
99563: LD_INT 5
99565: NEG
99566: PUSH
99567: LD_INT 3
99569: NEG
99570: PUSH
99571: EMPTY
99572: LIST
99573: LIST
99574: PUSH
99575: LD_INT 0
99577: PUSH
99578: LD_INT 3
99580: NEG
99581: PUSH
99582: EMPTY
99583: LIST
99584: LIST
99585: PUSH
99586: LD_INT 0
99588: PUSH
99589: LD_INT 4
99591: NEG
99592: PUSH
99593: EMPTY
99594: LIST
99595: LIST
99596: PUSH
99597: LD_INT 1
99599: PUSH
99600: LD_INT 3
99602: NEG
99603: PUSH
99604: EMPTY
99605: LIST
99606: LIST
99607: PUSH
99608: LD_INT 1
99610: PUSH
99611: LD_INT 2
99613: NEG
99614: PUSH
99615: EMPTY
99616: LIST
99617: LIST
99618: PUSH
99619: LD_INT 0
99621: PUSH
99622: LD_INT 2
99624: NEG
99625: PUSH
99626: EMPTY
99627: LIST
99628: LIST
99629: PUSH
99630: LD_INT 1
99632: NEG
99633: PUSH
99634: LD_INT 3
99636: NEG
99637: PUSH
99638: EMPTY
99639: LIST
99640: LIST
99641: PUSH
99642: LD_INT 1
99644: NEG
99645: PUSH
99646: LD_INT 4
99648: NEG
99649: PUSH
99650: EMPTY
99651: LIST
99652: LIST
99653: PUSH
99654: LD_INT 2
99656: PUSH
99657: LD_INT 2
99659: NEG
99660: PUSH
99661: EMPTY
99662: LIST
99663: LIST
99664: PUSH
99665: LD_INT 2
99667: NEG
99668: PUSH
99669: LD_INT 4
99671: NEG
99672: PUSH
99673: EMPTY
99674: LIST
99675: LIST
99676: PUSH
99677: LD_INT 4
99679: PUSH
99680: LD_INT 0
99682: PUSH
99683: EMPTY
99684: LIST
99685: LIST
99686: PUSH
99687: LD_INT 4
99689: PUSH
99690: LD_INT 1
99692: NEG
99693: PUSH
99694: EMPTY
99695: LIST
99696: LIST
99697: PUSH
99698: LD_INT 5
99700: PUSH
99701: LD_INT 0
99703: PUSH
99704: EMPTY
99705: LIST
99706: LIST
99707: PUSH
99708: LD_INT 5
99710: PUSH
99711: LD_INT 1
99713: PUSH
99714: EMPTY
99715: LIST
99716: LIST
99717: PUSH
99718: LD_INT 4
99720: PUSH
99721: LD_INT 1
99723: PUSH
99724: EMPTY
99725: LIST
99726: LIST
99727: PUSH
99728: LD_INT 3
99730: PUSH
99731: LD_INT 0
99733: PUSH
99734: EMPTY
99735: LIST
99736: LIST
99737: PUSH
99738: LD_INT 3
99740: PUSH
99741: LD_INT 1
99743: NEG
99744: PUSH
99745: EMPTY
99746: LIST
99747: LIST
99748: PUSH
99749: LD_INT 3
99751: PUSH
99752: LD_INT 2
99754: NEG
99755: PUSH
99756: EMPTY
99757: LIST
99758: LIST
99759: PUSH
99760: LD_INT 5
99762: PUSH
99763: LD_INT 2
99765: PUSH
99766: EMPTY
99767: LIST
99768: LIST
99769: PUSH
99770: EMPTY
99771: LIST
99772: LIST
99773: LIST
99774: LIST
99775: LIST
99776: LIST
99777: LIST
99778: LIST
99779: LIST
99780: LIST
99781: LIST
99782: LIST
99783: LIST
99784: LIST
99785: LIST
99786: LIST
99787: LIST
99788: LIST
99789: LIST
99790: LIST
99791: LIST
99792: LIST
99793: LIST
99794: LIST
99795: LIST
99796: LIST
99797: LIST
99798: LIST
99799: LIST
99800: LIST
99801: LIST
99802: LIST
99803: LIST
99804: LIST
99805: LIST
99806: LIST
99807: LIST
99808: LIST
99809: LIST
99810: LIST
99811: LIST
99812: LIST
99813: LIST
99814: LIST
99815: LIST
99816: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
99817: LD_ADDR_VAR 0 32
99821: PUSH
99822: LD_INT 4
99824: NEG
99825: PUSH
99826: LD_INT 0
99828: PUSH
99829: EMPTY
99830: LIST
99831: LIST
99832: PUSH
99833: LD_INT 4
99835: NEG
99836: PUSH
99837: LD_INT 1
99839: NEG
99840: PUSH
99841: EMPTY
99842: LIST
99843: LIST
99844: PUSH
99845: LD_INT 3
99847: NEG
99848: PUSH
99849: LD_INT 0
99851: PUSH
99852: EMPTY
99853: LIST
99854: LIST
99855: PUSH
99856: LD_INT 3
99858: NEG
99859: PUSH
99860: LD_INT 1
99862: PUSH
99863: EMPTY
99864: LIST
99865: LIST
99866: PUSH
99867: LD_INT 4
99869: NEG
99870: PUSH
99871: LD_INT 1
99873: PUSH
99874: EMPTY
99875: LIST
99876: LIST
99877: PUSH
99878: LD_INT 5
99880: NEG
99881: PUSH
99882: LD_INT 0
99884: PUSH
99885: EMPTY
99886: LIST
99887: LIST
99888: PUSH
99889: LD_INT 5
99891: NEG
99892: PUSH
99893: LD_INT 1
99895: NEG
99896: PUSH
99897: EMPTY
99898: LIST
99899: LIST
99900: PUSH
99901: LD_INT 5
99903: NEG
99904: PUSH
99905: LD_INT 2
99907: NEG
99908: PUSH
99909: EMPTY
99910: LIST
99911: LIST
99912: PUSH
99913: LD_INT 3
99915: NEG
99916: PUSH
99917: LD_INT 2
99919: PUSH
99920: EMPTY
99921: LIST
99922: LIST
99923: PUSH
99924: LD_INT 3
99926: NEG
99927: PUSH
99928: LD_INT 3
99930: NEG
99931: PUSH
99932: EMPTY
99933: LIST
99934: LIST
99935: PUSH
99936: LD_INT 3
99938: NEG
99939: PUSH
99940: LD_INT 4
99942: NEG
99943: PUSH
99944: EMPTY
99945: LIST
99946: LIST
99947: PUSH
99948: LD_INT 2
99950: NEG
99951: PUSH
99952: LD_INT 3
99954: NEG
99955: PUSH
99956: EMPTY
99957: LIST
99958: LIST
99959: PUSH
99960: LD_INT 2
99962: NEG
99963: PUSH
99964: LD_INT 2
99966: NEG
99967: PUSH
99968: EMPTY
99969: LIST
99970: LIST
99971: PUSH
99972: LD_INT 3
99974: NEG
99975: PUSH
99976: LD_INT 2
99978: NEG
99979: PUSH
99980: EMPTY
99981: LIST
99982: LIST
99983: PUSH
99984: LD_INT 4
99986: NEG
99987: PUSH
99988: LD_INT 3
99990: NEG
99991: PUSH
99992: EMPTY
99993: LIST
99994: LIST
99995: PUSH
99996: LD_INT 4
99998: NEG
99999: PUSH
100000: LD_INT 4
100002: NEG
100003: PUSH
100004: EMPTY
100005: LIST
100006: LIST
100007: PUSH
100008: LD_INT 2
100010: NEG
100011: PUSH
100012: LD_INT 4
100014: NEG
100015: PUSH
100016: EMPTY
100017: LIST
100018: LIST
100019: PUSH
100020: LD_INT 4
100022: NEG
100023: PUSH
100024: LD_INT 2
100026: NEG
100027: PUSH
100028: EMPTY
100029: LIST
100030: LIST
100031: PUSH
100032: LD_INT 0
100034: PUSH
100035: LD_INT 4
100037: NEG
100038: PUSH
100039: EMPTY
100040: LIST
100041: LIST
100042: PUSH
100043: LD_INT 0
100045: PUSH
100046: LD_INT 5
100048: NEG
100049: PUSH
100050: EMPTY
100051: LIST
100052: LIST
100053: PUSH
100054: LD_INT 1
100056: PUSH
100057: LD_INT 4
100059: NEG
100060: PUSH
100061: EMPTY
100062: LIST
100063: LIST
100064: PUSH
100065: LD_INT 1
100067: PUSH
100068: LD_INT 3
100070: NEG
100071: PUSH
100072: EMPTY
100073: LIST
100074: LIST
100075: PUSH
100076: LD_INT 0
100078: PUSH
100079: LD_INT 3
100081: NEG
100082: PUSH
100083: EMPTY
100084: LIST
100085: LIST
100086: PUSH
100087: LD_INT 1
100089: NEG
100090: PUSH
100091: LD_INT 4
100093: NEG
100094: PUSH
100095: EMPTY
100096: LIST
100097: LIST
100098: PUSH
100099: LD_INT 1
100101: NEG
100102: PUSH
100103: LD_INT 5
100105: NEG
100106: PUSH
100107: EMPTY
100108: LIST
100109: LIST
100110: PUSH
100111: LD_INT 2
100113: PUSH
100114: LD_INT 3
100116: NEG
100117: PUSH
100118: EMPTY
100119: LIST
100120: LIST
100121: PUSH
100122: LD_INT 2
100124: NEG
100125: PUSH
100126: LD_INT 5
100128: NEG
100129: PUSH
100130: EMPTY
100131: LIST
100132: LIST
100133: PUSH
100134: LD_INT 3
100136: PUSH
100137: LD_INT 0
100139: PUSH
100140: EMPTY
100141: LIST
100142: LIST
100143: PUSH
100144: LD_INT 3
100146: PUSH
100147: LD_INT 1
100149: NEG
100150: PUSH
100151: EMPTY
100152: LIST
100153: LIST
100154: PUSH
100155: LD_INT 4
100157: PUSH
100158: LD_INT 0
100160: PUSH
100161: EMPTY
100162: LIST
100163: LIST
100164: PUSH
100165: LD_INT 4
100167: PUSH
100168: LD_INT 1
100170: PUSH
100171: EMPTY
100172: LIST
100173: LIST
100174: PUSH
100175: LD_INT 3
100177: PUSH
100178: LD_INT 1
100180: PUSH
100181: EMPTY
100182: LIST
100183: LIST
100184: PUSH
100185: LD_INT 2
100187: PUSH
100188: LD_INT 0
100190: PUSH
100191: EMPTY
100192: LIST
100193: LIST
100194: PUSH
100195: LD_INT 2
100197: PUSH
100198: LD_INT 1
100200: NEG
100201: PUSH
100202: EMPTY
100203: LIST
100204: LIST
100205: PUSH
100206: LD_INT 2
100208: PUSH
100209: LD_INT 2
100211: NEG
100212: PUSH
100213: EMPTY
100214: LIST
100215: LIST
100216: PUSH
100217: LD_INT 4
100219: PUSH
100220: LD_INT 2
100222: PUSH
100223: EMPTY
100224: LIST
100225: LIST
100226: PUSH
100227: LD_INT 4
100229: PUSH
100230: LD_INT 4
100232: PUSH
100233: EMPTY
100234: LIST
100235: LIST
100236: PUSH
100237: LD_INT 4
100239: PUSH
100240: LD_INT 3
100242: PUSH
100243: EMPTY
100244: LIST
100245: LIST
100246: PUSH
100247: LD_INT 5
100249: PUSH
100250: LD_INT 4
100252: PUSH
100253: EMPTY
100254: LIST
100255: LIST
100256: PUSH
100257: LD_INT 5
100259: PUSH
100260: LD_INT 5
100262: PUSH
100263: EMPTY
100264: LIST
100265: LIST
100266: PUSH
100267: LD_INT 4
100269: PUSH
100270: LD_INT 5
100272: PUSH
100273: EMPTY
100274: LIST
100275: LIST
100276: PUSH
100277: LD_INT 3
100279: PUSH
100280: LD_INT 4
100282: PUSH
100283: EMPTY
100284: LIST
100285: LIST
100286: PUSH
100287: LD_INT 3
100289: PUSH
100290: LD_INT 3
100292: PUSH
100293: EMPTY
100294: LIST
100295: LIST
100296: PUSH
100297: LD_INT 5
100299: PUSH
100300: LD_INT 3
100302: PUSH
100303: EMPTY
100304: LIST
100305: LIST
100306: PUSH
100307: LD_INT 3
100309: PUSH
100310: LD_INT 5
100312: PUSH
100313: EMPTY
100314: LIST
100315: LIST
100316: PUSH
100317: EMPTY
100318: LIST
100319: LIST
100320: LIST
100321: LIST
100322: LIST
100323: LIST
100324: LIST
100325: LIST
100326: LIST
100327: LIST
100328: LIST
100329: LIST
100330: LIST
100331: LIST
100332: LIST
100333: LIST
100334: LIST
100335: LIST
100336: LIST
100337: LIST
100338: LIST
100339: LIST
100340: LIST
100341: LIST
100342: LIST
100343: LIST
100344: LIST
100345: LIST
100346: LIST
100347: LIST
100348: LIST
100349: LIST
100350: LIST
100351: LIST
100352: LIST
100353: LIST
100354: LIST
100355: LIST
100356: LIST
100357: LIST
100358: LIST
100359: LIST
100360: LIST
100361: LIST
100362: LIST
100363: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
100364: LD_ADDR_VAR 0 33
100368: PUSH
100369: LD_INT 4
100371: NEG
100372: PUSH
100373: LD_INT 4
100375: NEG
100376: PUSH
100377: EMPTY
100378: LIST
100379: LIST
100380: PUSH
100381: LD_INT 4
100383: NEG
100384: PUSH
100385: LD_INT 5
100387: NEG
100388: PUSH
100389: EMPTY
100390: LIST
100391: LIST
100392: PUSH
100393: LD_INT 3
100395: NEG
100396: PUSH
100397: LD_INT 4
100399: NEG
100400: PUSH
100401: EMPTY
100402: LIST
100403: LIST
100404: PUSH
100405: LD_INT 3
100407: NEG
100408: PUSH
100409: LD_INT 3
100411: NEG
100412: PUSH
100413: EMPTY
100414: LIST
100415: LIST
100416: PUSH
100417: LD_INT 4
100419: NEG
100420: PUSH
100421: LD_INT 3
100423: NEG
100424: PUSH
100425: EMPTY
100426: LIST
100427: LIST
100428: PUSH
100429: LD_INT 5
100431: NEG
100432: PUSH
100433: LD_INT 4
100435: NEG
100436: PUSH
100437: EMPTY
100438: LIST
100439: LIST
100440: PUSH
100441: LD_INT 5
100443: NEG
100444: PUSH
100445: LD_INT 5
100447: NEG
100448: PUSH
100449: EMPTY
100450: LIST
100451: LIST
100452: PUSH
100453: LD_INT 3
100455: NEG
100456: PUSH
100457: LD_INT 5
100459: NEG
100460: PUSH
100461: EMPTY
100462: LIST
100463: LIST
100464: PUSH
100465: LD_INT 5
100467: NEG
100468: PUSH
100469: LD_INT 3
100471: NEG
100472: PUSH
100473: EMPTY
100474: LIST
100475: LIST
100476: PUSH
100477: LD_INT 0
100479: PUSH
100480: LD_INT 3
100482: NEG
100483: PUSH
100484: EMPTY
100485: LIST
100486: LIST
100487: PUSH
100488: LD_INT 0
100490: PUSH
100491: LD_INT 4
100493: NEG
100494: PUSH
100495: EMPTY
100496: LIST
100497: LIST
100498: PUSH
100499: LD_INT 1
100501: PUSH
100502: LD_INT 3
100504: NEG
100505: PUSH
100506: EMPTY
100507: LIST
100508: LIST
100509: PUSH
100510: LD_INT 1
100512: PUSH
100513: LD_INT 2
100515: NEG
100516: PUSH
100517: EMPTY
100518: LIST
100519: LIST
100520: PUSH
100521: LD_INT 0
100523: PUSH
100524: LD_INT 2
100526: NEG
100527: PUSH
100528: EMPTY
100529: LIST
100530: LIST
100531: PUSH
100532: LD_INT 1
100534: NEG
100535: PUSH
100536: LD_INT 3
100538: NEG
100539: PUSH
100540: EMPTY
100541: LIST
100542: LIST
100543: PUSH
100544: LD_INT 1
100546: NEG
100547: PUSH
100548: LD_INT 4
100550: NEG
100551: PUSH
100552: EMPTY
100553: LIST
100554: LIST
100555: PUSH
100556: LD_INT 2
100558: PUSH
100559: LD_INT 2
100561: NEG
100562: PUSH
100563: EMPTY
100564: LIST
100565: LIST
100566: PUSH
100567: LD_INT 2
100569: NEG
100570: PUSH
100571: LD_INT 4
100573: NEG
100574: PUSH
100575: EMPTY
100576: LIST
100577: LIST
100578: PUSH
100579: LD_INT 4
100581: PUSH
100582: LD_INT 0
100584: PUSH
100585: EMPTY
100586: LIST
100587: LIST
100588: PUSH
100589: LD_INT 4
100591: PUSH
100592: LD_INT 1
100594: NEG
100595: PUSH
100596: EMPTY
100597: LIST
100598: LIST
100599: PUSH
100600: LD_INT 5
100602: PUSH
100603: LD_INT 0
100605: PUSH
100606: EMPTY
100607: LIST
100608: LIST
100609: PUSH
100610: LD_INT 5
100612: PUSH
100613: LD_INT 1
100615: PUSH
100616: EMPTY
100617: LIST
100618: LIST
100619: PUSH
100620: LD_INT 4
100622: PUSH
100623: LD_INT 1
100625: PUSH
100626: EMPTY
100627: LIST
100628: LIST
100629: PUSH
100630: LD_INT 3
100632: PUSH
100633: LD_INT 0
100635: PUSH
100636: EMPTY
100637: LIST
100638: LIST
100639: PUSH
100640: LD_INT 3
100642: PUSH
100643: LD_INT 1
100645: NEG
100646: PUSH
100647: EMPTY
100648: LIST
100649: LIST
100650: PUSH
100651: LD_INT 3
100653: PUSH
100654: LD_INT 2
100656: NEG
100657: PUSH
100658: EMPTY
100659: LIST
100660: LIST
100661: PUSH
100662: LD_INT 5
100664: PUSH
100665: LD_INT 2
100667: PUSH
100668: EMPTY
100669: LIST
100670: LIST
100671: PUSH
100672: LD_INT 3
100674: PUSH
100675: LD_INT 3
100677: PUSH
100678: EMPTY
100679: LIST
100680: LIST
100681: PUSH
100682: LD_INT 3
100684: PUSH
100685: LD_INT 2
100687: PUSH
100688: EMPTY
100689: LIST
100690: LIST
100691: PUSH
100692: LD_INT 4
100694: PUSH
100695: LD_INT 3
100697: PUSH
100698: EMPTY
100699: LIST
100700: LIST
100701: PUSH
100702: LD_INT 4
100704: PUSH
100705: LD_INT 4
100707: PUSH
100708: EMPTY
100709: LIST
100710: LIST
100711: PUSH
100712: LD_INT 3
100714: PUSH
100715: LD_INT 4
100717: PUSH
100718: EMPTY
100719: LIST
100720: LIST
100721: PUSH
100722: LD_INT 2
100724: PUSH
100725: LD_INT 3
100727: PUSH
100728: EMPTY
100729: LIST
100730: LIST
100731: PUSH
100732: LD_INT 2
100734: PUSH
100735: LD_INT 2
100737: PUSH
100738: EMPTY
100739: LIST
100740: LIST
100741: PUSH
100742: LD_INT 4
100744: PUSH
100745: LD_INT 2
100747: PUSH
100748: EMPTY
100749: LIST
100750: LIST
100751: PUSH
100752: LD_INT 2
100754: PUSH
100755: LD_INT 4
100757: PUSH
100758: EMPTY
100759: LIST
100760: LIST
100761: PUSH
100762: LD_INT 0
100764: PUSH
100765: LD_INT 4
100767: PUSH
100768: EMPTY
100769: LIST
100770: LIST
100771: PUSH
100772: LD_INT 0
100774: PUSH
100775: LD_INT 3
100777: PUSH
100778: EMPTY
100779: LIST
100780: LIST
100781: PUSH
100782: LD_INT 1
100784: PUSH
100785: LD_INT 4
100787: PUSH
100788: EMPTY
100789: LIST
100790: LIST
100791: PUSH
100792: LD_INT 1
100794: PUSH
100795: LD_INT 5
100797: PUSH
100798: EMPTY
100799: LIST
100800: LIST
100801: PUSH
100802: LD_INT 0
100804: PUSH
100805: LD_INT 5
100807: PUSH
100808: EMPTY
100809: LIST
100810: LIST
100811: PUSH
100812: LD_INT 1
100814: NEG
100815: PUSH
100816: LD_INT 4
100818: PUSH
100819: EMPTY
100820: LIST
100821: LIST
100822: PUSH
100823: LD_INT 1
100825: NEG
100826: PUSH
100827: LD_INT 3
100829: PUSH
100830: EMPTY
100831: LIST
100832: LIST
100833: PUSH
100834: LD_INT 2
100836: PUSH
100837: LD_INT 5
100839: PUSH
100840: EMPTY
100841: LIST
100842: LIST
100843: PUSH
100844: LD_INT 2
100846: NEG
100847: PUSH
100848: LD_INT 3
100850: PUSH
100851: EMPTY
100852: LIST
100853: LIST
100854: PUSH
100855: EMPTY
100856: LIST
100857: LIST
100858: LIST
100859: LIST
100860: LIST
100861: LIST
100862: LIST
100863: LIST
100864: LIST
100865: LIST
100866: LIST
100867: LIST
100868: LIST
100869: LIST
100870: LIST
100871: LIST
100872: LIST
100873: LIST
100874: LIST
100875: LIST
100876: LIST
100877: LIST
100878: LIST
100879: LIST
100880: LIST
100881: LIST
100882: LIST
100883: LIST
100884: LIST
100885: LIST
100886: LIST
100887: LIST
100888: LIST
100889: LIST
100890: LIST
100891: LIST
100892: LIST
100893: LIST
100894: LIST
100895: LIST
100896: LIST
100897: LIST
100898: LIST
100899: LIST
100900: LIST
100901: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
100902: LD_ADDR_VAR 0 34
100906: PUSH
100907: LD_INT 0
100909: PUSH
100910: LD_INT 4
100912: NEG
100913: PUSH
100914: EMPTY
100915: LIST
100916: LIST
100917: PUSH
100918: LD_INT 0
100920: PUSH
100921: LD_INT 5
100923: NEG
100924: PUSH
100925: EMPTY
100926: LIST
100927: LIST
100928: PUSH
100929: LD_INT 1
100931: PUSH
100932: LD_INT 4
100934: NEG
100935: PUSH
100936: EMPTY
100937: LIST
100938: LIST
100939: PUSH
100940: LD_INT 1
100942: PUSH
100943: LD_INT 3
100945: NEG
100946: PUSH
100947: EMPTY
100948: LIST
100949: LIST
100950: PUSH
100951: LD_INT 0
100953: PUSH
100954: LD_INT 3
100956: NEG
100957: PUSH
100958: EMPTY
100959: LIST
100960: LIST
100961: PUSH
100962: LD_INT 1
100964: NEG
100965: PUSH
100966: LD_INT 4
100968: NEG
100969: PUSH
100970: EMPTY
100971: LIST
100972: LIST
100973: PUSH
100974: LD_INT 1
100976: NEG
100977: PUSH
100978: LD_INT 5
100980: NEG
100981: PUSH
100982: EMPTY
100983: LIST
100984: LIST
100985: PUSH
100986: LD_INT 2
100988: PUSH
100989: LD_INT 3
100991: NEG
100992: PUSH
100993: EMPTY
100994: LIST
100995: LIST
100996: PUSH
100997: LD_INT 2
100999: NEG
101000: PUSH
101001: LD_INT 5
101003: NEG
101004: PUSH
101005: EMPTY
101006: LIST
101007: LIST
101008: PUSH
101009: LD_INT 3
101011: PUSH
101012: LD_INT 0
101014: PUSH
101015: EMPTY
101016: LIST
101017: LIST
101018: PUSH
101019: LD_INT 3
101021: PUSH
101022: LD_INT 1
101024: NEG
101025: PUSH
101026: EMPTY
101027: LIST
101028: LIST
101029: PUSH
101030: LD_INT 4
101032: PUSH
101033: LD_INT 0
101035: PUSH
101036: EMPTY
101037: LIST
101038: LIST
101039: PUSH
101040: LD_INT 4
101042: PUSH
101043: LD_INT 1
101045: PUSH
101046: EMPTY
101047: LIST
101048: LIST
101049: PUSH
101050: LD_INT 3
101052: PUSH
101053: LD_INT 1
101055: PUSH
101056: EMPTY
101057: LIST
101058: LIST
101059: PUSH
101060: LD_INT 2
101062: PUSH
101063: LD_INT 0
101065: PUSH
101066: EMPTY
101067: LIST
101068: LIST
101069: PUSH
101070: LD_INT 2
101072: PUSH
101073: LD_INT 1
101075: NEG
101076: PUSH
101077: EMPTY
101078: LIST
101079: LIST
101080: PUSH
101081: LD_INT 2
101083: PUSH
101084: LD_INT 2
101086: NEG
101087: PUSH
101088: EMPTY
101089: LIST
101090: LIST
101091: PUSH
101092: LD_INT 4
101094: PUSH
101095: LD_INT 2
101097: PUSH
101098: EMPTY
101099: LIST
101100: LIST
101101: PUSH
101102: LD_INT 4
101104: PUSH
101105: LD_INT 4
101107: PUSH
101108: EMPTY
101109: LIST
101110: LIST
101111: PUSH
101112: LD_INT 4
101114: PUSH
101115: LD_INT 3
101117: PUSH
101118: EMPTY
101119: LIST
101120: LIST
101121: PUSH
101122: LD_INT 5
101124: PUSH
101125: LD_INT 4
101127: PUSH
101128: EMPTY
101129: LIST
101130: LIST
101131: PUSH
101132: LD_INT 5
101134: PUSH
101135: LD_INT 5
101137: PUSH
101138: EMPTY
101139: LIST
101140: LIST
101141: PUSH
101142: LD_INT 4
101144: PUSH
101145: LD_INT 5
101147: PUSH
101148: EMPTY
101149: LIST
101150: LIST
101151: PUSH
101152: LD_INT 3
101154: PUSH
101155: LD_INT 4
101157: PUSH
101158: EMPTY
101159: LIST
101160: LIST
101161: PUSH
101162: LD_INT 3
101164: PUSH
101165: LD_INT 3
101167: PUSH
101168: EMPTY
101169: LIST
101170: LIST
101171: PUSH
101172: LD_INT 5
101174: PUSH
101175: LD_INT 3
101177: PUSH
101178: EMPTY
101179: LIST
101180: LIST
101181: PUSH
101182: LD_INT 3
101184: PUSH
101185: LD_INT 5
101187: PUSH
101188: EMPTY
101189: LIST
101190: LIST
101191: PUSH
101192: LD_INT 0
101194: PUSH
101195: LD_INT 3
101197: PUSH
101198: EMPTY
101199: LIST
101200: LIST
101201: PUSH
101202: LD_INT 0
101204: PUSH
101205: LD_INT 2
101207: PUSH
101208: EMPTY
101209: LIST
101210: LIST
101211: PUSH
101212: LD_INT 1
101214: PUSH
101215: LD_INT 3
101217: PUSH
101218: EMPTY
101219: LIST
101220: LIST
101221: PUSH
101222: LD_INT 1
101224: PUSH
101225: LD_INT 4
101227: PUSH
101228: EMPTY
101229: LIST
101230: LIST
101231: PUSH
101232: LD_INT 0
101234: PUSH
101235: LD_INT 4
101237: PUSH
101238: EMPTY
101239: LIST
101240: LIST
101241: PUSH
101242: LD_INT 1
101244: NEG
101245: PUSH
101246: LD_INT 3
101248: PUSH
101249: EMPTY
101250: LIST
101251: LIST
101252: PUSH
101253: LD_INT 1
101255: NEG
101256: PUSH
101257: LD_INT 2
101259: PUSH
101260: EMPTY
101261: LIST
101262: LIST
101263: PUSH
101264: LD_INT 2
101266: PUSH
101267: LD_INT 4
101269: PUSH
101270: EMPTY
101271: LIST
101272: LIST
101273: PUSH
101274: LD_INT 2
101276: NEG
101277: PUSH
101278: LD_INT 2
101280: PUSH
101281: EMPTY
101282: LIST
101283: LIST
101284: PUSH
101285: LD_INT 4
101287: NEG
101288: PUSH
101289: LD_INT 0
101291: PUSH
101292: EMPTY
101293: LIST
101294: LIST
101295: PUSH
101296: LD_INT 4
101298: NEG
101299: PUSH
101300: LD_INT 1
101302: NEG
101303: PUSH
101304: EMPTY
101305: LIST
101306: LIST
101307: PUSH
101308: LD_INT 3
101310: NEG
101311: PUSH
101312: LD_INT 0
101314: PUSH
101315: EMPTY
101316: LIST
101317: LIST
101318: PUSH
101319: LD_INT 3
101321: NEG
101322: PUSH
101323: LD_INT 1
101325: PUSH
101326: EMPTY
101327: LIST
101328: LIST
101329: PUSH
101330: LD_INT 4
101332: NEG
101333: PUSH
101334: LD_INT 1
101336: PUSH
101337: EMPTY
101338: LIST
101339: LIST
101340: PUSH
101341: LD_INT 5
101343: NEG
101344: PUSH
101345: LD_INT 0
101347: PUSH
101348: EMPTY
101349: LIST
101350: LIST
101351: PUSH
101352: LD_INT 5
101354: NEG
101355: PUSH
101356: LD_INT 1
101358: NEG
101359: PUSH
101360: EMPTY
101361: LIST
101362: LIST
101363: PUSH
101364: LD_INT 5
101366: NEG
101367: PUSH
101368: LD_INT 2
101370: NEG
101371: PUSH
101372: EMPTY
101373: LIST
101374: LIST
101375: PUSH
101376: LD_INT 3
101378: NEG
101379: PUSH
101380: LD_INT 2
101382: PUSH
101383: EMPTY
101384: LIST
101385: LIST
101386: PUSH
101387: EMPTY
101388: LIST
101389: LIST
101390: LIST
101391: LIST
101392: LIST
101393: LIST
101394: LIST
101395: LIST
101396: LIST
101397: LIST
101398: LIST
101399: LIST
101400: LIST
101401: LIST
101402: LIST
101403: LIST
101404: LIST
101405: LIST
101406: LIST
101407: LIST
101408: LIST
101409: LIST
101410: LIST
101411: LIST
101412: LIST
101413: LIST
101414: LIST
101415: LIST
101416: LIST
101417: LIST
101418: LIST
101419: LIST
101420: LIST
101421: LIST
101422: LIST
101423: LIST
101424: LIST
101425: LIST
101426: LIST
101427: LIST
101428: LIST
101429: LIST
101430: LIST
101431: LIST
101432: LIST
101433: ST_TO_ADDR
// end ; end ;
101434: GO 101437
101436: POP
// case btype of b_depot , b_warehouse :
101437: LD_VAR 0 1
101441: PUSH
101442: LD_INT 0
101444: DOUBLE
101445: EQUAL
101446: IFTRUE 101456
101448: LD_INT 1
101450: DOUBLE
101451: EQUAL
101452: IFTRUE 101456
101454: GO 101657
101456: POP
// case nation of nation_american :
101457: LD_VAR 0 5
101461: PUSH
101462: LD_INT 1
101464: DOUBLE
101465: EQUAL
101466: IFTRUE 101470
101468: GO 101526
101470: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
101471: LD_ADDR_VAR 0 9
101475: PUSH
101476: LD_VAR 0 11
101480: PUSH
101481: LD_VAR 0 12
101485: PUSH
101486: LD_VAR 0 13
101490: PUSH
101491: LD_VAR 0 14
101495: PUSH
101496: LD_VAR 0 15
101500: PUSH
101501: LD_VAR 0 16
101505: PUSH
101506: EMPTY
101507: LIST
101508: LIST
101509: LIST
101510: LIST
101511: LIST
101512: LIST
101513: PUSH
101514: LD_VAR 0 4
101518: PUSH
101519: LD_INT 1
101521: PLUS
101522: ARRAY
101523: ST_TO_ADDR
101524: GO 101655
101526: LD_INT 2
101528: DOUBLE
101529: EQUAL
101530: IFTRUE 101534
101532: GO 101590
101534: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
101535: LD_ADDR_VAR 0 9
101539: PUSH
101540: LD_VAR 0 17
101544: PUSH
101545: LD_VAR 0 18
101549: PUSH
101550: LD_VAR 0 19
101554: PUSH
101555: LD_VAR 0 20
101559: PUSH
101560: LD_VAR 0 21
101564: PUSH
101565: LD_VAR 0 22
101569: PUSH
101570: EMPTY
101571: LIST
101572: LIST
101573: LIST
101574: LIST
101575: LIST
101576: LIST
101577: PUSH
101578: LD_VAR 0 4
101582: PUSH
101583: LD_INT 1
101585: PLUS
101586: ARRAY
101587: ST_TO_ADDR
101588: GO 101655
101590: LD_INT 3
101592: DOUBLE
101593: EQUAL
101594: IFTRUE 101598
101596: GO 101654
101598: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
101599: LD_ADDR_VAR 0 9
101603: PUSH
101604: LD_VAR 0 23
101608: PUSH
101609: LD_VAR 0 24
101613: PUSH
101614: LD_VAR 0 25
101618: PUSH
101619: LD_VAR 0 26
101623: PUSH
101624: LD_VAR 0 27
101628: PUSH
101629: LD_VAR 0 28
101633: PUSH
101634: EMPTY
101635: LIST
101636: LIST
101637: LIST
101638: LIST
101639: LIST
101640: LIST
101641: PUSH
101642: LD_VAR 0 4
101646: PUSH
101647: LD_INT 1
101649: PLUS
101650: ARRAY
101651: ST_TO_ADDR
101652: GO 101655
101654: POP
101655: GO 102210
101657: LD_INT 2
101659: DOUBLE
101660: EQUAL
101661: IFTRUE 101671
101663: LD_INT 3
101665: DOUBLE
101666: EQUAL
101667: IFTRUE 101671
101669: GO 101727
101671: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
101672: LD_ADDR_VAR 0 9
101676: PUSH
101677: LD_VAR 0 29
101681: PUSH
101682: LD_VAR 0 30
101686: PUSH
101687: LD_VAR 0 31
101691: PUSH
101692: LD_VAR 0 32
101696: PUSH
101697: LD_VAR 0 33
101701: PUSH
101702: LD_VAR 0 34
101706: PUSH
101707: EMPTY
101708: LIST
101709: LIST
101710: LIST
101711: LIST
101712: LIST
101713: LIST
101714: PUSH
101715: LD_VAR 0 4
101719: PUSH
101720: LD_INT 1
101722: PLUS
101723: ARRAY
101724: ST_TO_ADDR
101725: GO 102210
101727: LD_INT 16
101729: DOUBLE
101730: EQUAL
101731: IFTRUE 101789
101733: LD_INT 17
101735: DOUBLE
101736: EQUAL
101737: IFTRUE 101789
101739: LD_INT 18
101741: DOUBLE
101742: EQUAL
101743: IFTRUE 101789
101745: LD_INT 19
101747: DOUBLE
101748: EQUAL
101749: IFTRUE 101789
101751: LD_INT 22
101753: DOUBLE
101754: EQUAL
101755: IFTRUE 101789
101757: LD_INT 20
101759: DOUBLE
101760: EQUAL
101761: IFTRUE 101789
101763: LD_INT 21
101765: DOUBLE
101766: EQUAL
101767: IFTRUE 101789
101769: LD_INT 23
101771: DOUBLE
101772: EQUAL
101773: IFTRUE 101789
101775: LD_INT 24
101777: DOUBLE
101778: EQUAL
101779: IFTRUE 101789
101781: LD_INT 25
101783: DOUBLE
101784: EQUAL
101785: IFTRUE 101789
101787: GO 101845
101789: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
101790: LD_ADDR_VAR 0 9
101794: PUSH
101795: LD_VAR 0 35
101799: PUSH
101800: LD_VAR 0 36
101804: PUSH
101805: LD_VAR 0 37
101809: PUSH
101810: LD_VAR 0 38
101814: PUSH
101815: LD_VAR 0 39
101819: PUSH
101820: LD_VAR 0 40
101824: PUSH
101825: EMPTY
101826: LIST
101827: LIST
101828: LIST
101829: LIST
101830: LIST
101831: LIST
101832: PUSH
101833: LD_VAR 0 4
101837: PUSH
101838: LD_INT 1
101840: PLUS
101841: ARRAY
101842: ST_TO_ADDR
101843: GO 102210
101845: LD_INT 6
101847: DOUBLE
101848: EQUAL
101849: IFTRUE 101901
101851: LD_INT 7
101853: DOUBLE
101854: EQUAL
101855: IFTRUE 101901
101857: LD_INT 8
101859: DOUBLE
101860: EQUAL
101861: IFTRUE 101901
101863: LD_INT 13
101865: DOUBLE
101866: EQUAL
101867: IFTRUE 101901
101869: LD_INT 12
101871: DOUBLE
101872: EQUAL
101873: IFTRUE 101901
101875: LD_INT 15
101877: DOUBLE
101878: EQUAL
101879: IFTRUE 101901
101881: LD_INT 11
101883: DOUBLE
101884: EQUAL
101885: IFTRUE 101901
101887: LD_INT 14
101889: DOUBLE
101890: EQUAL
101891: IFTRUE 101901
101893: LD_INT 10
101895: DOUBLE
101896: EQUAL
101897: IFTRUE 101901
101899: GO 101957
101901: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
101902: LD_ADDR_VAR 0 9
101906: PUSH
101907: LD_VAR 0 41
101911: PUSH
101912: LD_VAR 0 42
101916: PUSH
101917: LD_VAR 0 43
101921: PUSH
101922: LD_VAR 0 44
101926: PUSH
101927: LD_VAR 0 45
101931: PUSH
101932: LD_VAR 0 46
101936: PUSH
101937: EMPTY
101938: LIST
101939: LIST
101940: LIST
101941: LIST
101942: LIST
101943: LIST
101944: PUSH
101945: LD_VAR 0 4
101949: PUSH
101950: LD_INT 1
101952: PLUS
101953: ARRAY
101954: ST_TO_ADDR
101955: GO 102210
101957: LD_INT 36
101959: DOUBLE
101960: EQUAL
101961: IFTRUE 101965
101963: GO 102021
101965: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
101966: LD_ADDR_VAR 0 9
101970: PUSH
101971: LD_VAR 0 47
101975: PUSH
101976: LD_VAR 0 48
101980: PUSH
101981: LD_VAR 0 49
101985: PUSH
101986: LD_VAR 0 50
101990: PUSH
101991: LD_VAR 0 51
101995: PUSH
101996: LD_VAR 0 52
102000: PUSH
102001: EMPTY
102002: LIST
102003: LIST
102004: LIST
102005: LIST
102006: LIST
102007: LIST
102008: PUSH
102009: LD_VAR 0 4
102013: PUSH
102014: LD_INT 1
102016: PLUS
102017: ARRAY
102018: ST_TO_ADDR
102019: GO 102210
102021: LD_INT 4
102023: DOUBLE
102024: EQUAL
102025: IFTRUE 102047
102027: LD_INT 5
102029: DOUBLE
102030: EQUAL
102031: IFTRUE 102047
102033: LD_INT 34
102035: DOUBLE
102036: EQUAL
102037: IFTRUE 102047
102039: LD_INT 37
102041: DOUBLE
102042: EQUAL
102043: IFTRUE 102047
102045: GO 102103
102047: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
102048: LD_ADDR_VAR 0 9
102052: PUSH
102053: LD_VAR 0 53
102057: PUSH
102058: LD_VAR 0 54
102062: PUSH
102063: LD_VAR 0 55
102067: PUSH
102068: LD_VAR 0 56
102072: PUSH
102073: LD_VAR 0 57
102077: PUSH
102078: LD_VAR 0 58
102082: PUSH
102083: EMPTY
102084: LIST
102085: LIST
102086: LIST
102087: LIST
102088: LIST
102089: LIST
102090: PUSH
102091: LD_VAR 0 4
102095: PUSH
102096: LD_INT 1
102098: PLUS
102099: ARRAY
102100: ST_TO_ADDR
102101: GO 102210
102103: LD_INT 31
102105: DOUBLE
102106: EQUAL
102107: IFTRUE 102153
102109: LD_INT 32
102111: DOUBLE
102112: EQUAL
102113: IFTRUE 102153
102115: LD_INT 33
102117: DOUBLE
102118: EQUAL
102119: IFTRUE 102153
102121: LD_INT 27
102123: DOUBLE
102124: EQUAL
102125: IFTRUE 102153
102127: LD_INT 26
102129: DOUBLE
102130: EQUAL
102131: IFTRUE 102153
102133: LD_INT 28
102135: DOUBLE
102136: EQUAL
102137: IFTRUE 102153
102139: LD_INT 29
102141: DOUBLE
102142: EQUAL
102143: IFTRUE 102153
102145: LD_INT 30
102147: DOUBLE
102148: EQUAL
102149: IFTRUE 102153
102151: GO 102209
102153: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
102154: LD_ADDR_VAR 0 9
102158: PUSH
102159: LD_VAR 0 59
102163: PUSH
102164: LD_VAR 0 60
102168: PUSH
102169: LD_VAR 0 61
102173: PUSH
102174: LD_VAR 0 62
102178: PUSH
102179: LD_VAR 0 63
102183: PUSH
102184: LD_VAR 0 64
102188: PUSH
102189: EMPTY
102190: LIST
102191: LIST
102192: LIST
102193: LIST
102194: LIST
102195: LIST
102196: PUSH
102197: LD_VAR 0 4
102201: PUSH
102202: LD_INT 1
102204: PLUS
102205: ARRAY
102206: ST_TO_ADDR
102207: GO 102210
102209: POP
// temp_list2 = [ ] ;
102210: LD_ADDR_VAR 0 10
102214: PUSH
102215: EMPTY
102216: ST_TO_ADDR
// for i in temp_list do
102217: LD_ADDR_VAR 0 8
102221: PUSH
102222: LD_VAR 0 9
102226: PUSH
102227: FOR_IN
102228: IFFALSE 102280
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
102230: LD_ADDR_VAR 0 10
102234: PUSH
102235: LD_VAR 0 10
102239: PUSH
102240: LD_VAR 0 8
102244: PUSH
102245: LD_INT 1
102247: ARRAY
102248: PUSH
102249: LD_VAR 0 2
102253: PLUS
102254: PUSH
102255: LD_VAR 0 8
102259: PUSH
102260: LD_INT 2
102262: ARRAY
102263: PUSH
102264: LD_VAR 0 3
102268: PLUS
102269: PUSH
102270: EMPTY
102271: LIST
102272: LIST
102273: PUSH
102274: EMPTY
102275: LIST
102276: ADD
102277: ST_TO_ADDR
102278: GO 102227
102280: POP
102281: POP
// result = temp_list2 ;
102282: LD_ADDR_VAR 0 7
102286: PUSH
102287: LD_VAR 0 10
102291: ST_TO_ADDR
// end ;
102292: LD_VAR 0 7
102296: RET
// export function EnemyInRange ( unit , dist ) ; begin
102297: LD_INT 0
102299: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
102300: LD_ADDR_VAR 0 3
102304: PUSH
102305: LD_VAR 0 1
102309: PPUSH
102310: CALL_OW 255
102314: PPUSH
102315: LD_VAR 0 1
102319: PPUSH
102320: CALL_OW 250
102324: PPUSH
102325: LD_VAR 0 1
102329: PPUSH
102330: CALL_OW 251
102334: PPUSH
102335: LD_VAR 0 2
102339: PPUSH
102340: CALL 75670 0 4
102344: PUSH
102345: LD_INT 4
102347: ARRAY
102348: ST_TO_ADDR
// end ;
102349: LD_VAR 0 3
102353: RET
// export function PlayerSeeMe ( unit ) ; begin
102354: LD_INT 0
102356: PPUSH
// result := See ( your_side , unit ) ;
102357: LD_ADDR_VAR 0 2
102361: PUSH
102362: LD_OWVAR 2
102366: PPUSH
102367: LD_VAR 0 1
102371: PPUSH
102372: CALL_OW 292
102376: ST_TO_ADDR
// end ;
102377: LD_VAR 0 2
102381: RET
// export function ReverseDir ( unit ) ; begin
102382: LD_INT 0
102384: PPUSH
// if not unit then
102385: LD_VAR 0 1
102389: NOT
102390: IFFALSE 102394
// exit ;
102392: GO 102417
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
102394: LD_ADDR_VAR 0 2
102398: PUSH
102399: LD_VAR 0 1
102403: PPUSH
102404: CALL_OW 254
102408: PUSH
102409: LD_INT 3
102411: PLUS
102412: PUSH
102413: LD_INT 6
102415: MOD
102416: ST_TO_ADDR
// end ;
102417: LD_VAR 0 2
102421: RET
// export function ReverseArray ( array ) ; var i ; begin
102422: LD_INT 0
102424: PPUSH
102425: PPUSH
// if not array then
102426: LD_VAR 0 1
102430: NOT
102431: IFFALSE 102435
// exit ;
102433: GO 102490
// result := [ ] ;
102435: LD_ADDR_VAR 0 2
102439: PUSH
102440: EMPTY
102441: ST_TO_ADDR
// for i := array downto 1 do
102442: LD_ADDR_VAR 0 3
102446: PUSH
102447: DOUBLE
102448: LD_VAR 0 1
102452: INC
102453: ST_TO_ADDR
102454: LD_INT 1
102456: PUSH
102457: FOR_DOWNTO
102458: IFFALSE 102488
// result := Join ( result , array [ i ] ) ;
102460: LD_ADDR_VAR 0 2
102464: PUSH
102465: LD_VAR 0 2
102469: PPUSH
102470: LD_VAR 0 1
102474: PUSH
102475: LD_VAR 0 3
102479: ARRAY
102480: PPUSH
102481: CALL 107135 0 2
102485: ST_TO_ADDR
102486: GO 102457
102488: POP
102489: POP
// end ;
102490: LD_VAR 0 2
102494: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
102495: LD_INT 0
102497: PPUSH
102498: PPUSH
102499: PPUSH
102500: PPUSH
102501: PPUSH
102502: PPUSH
// if not unit or not hexes then
102503: LD_VAR 0 1
102507: NOT
102508: PUSH
102509: LD_VAR 0 2
102513: NOT
102514: OR
102515: IFFALSE 102519
// exit ;
102517: GO 102642
// dist := 9999 ;
102519: LD_ADDR_VAR 0 5
102523: PUSH
102524: LD_INT 9999
102526: ST_TO_ADDR
// for i = 1 to hexes do
102527: LD_ADDR_VAR 0 4
102531: PUSH
102532: DOUBLE
102533: LD_INT 1
102535: DEC
102536: ST_TO_ADDR
102537: LD_VAR 0 2
102541: PUSH
102542: FOR_TO
102543: IFFALSE 102630
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
102545: LD_ADDR_VAR 0 6
102549: PUSH
102550: LD_VAR 0 1
102554: PPUSH
102555: LD_VAR 0 2
102559: PUSH
102560: LD_VAR 0 4
102564: ARRAY
102565: PUSH
102566: LD_INT 1
102568: ARRAY
102569: PPUSH
102570: LD_VAR 0 2
102574: PUSH
102575: LD_VAR 0 4
102579: ARRAY
102580: PUSH
102581: LD_INT 2
102583: ARRAY
102584: PPUSH
102585: CALL_OW 297
102589: ST_TO_ADDR
// if tdist < dist then
102590: LD_VAR 0 6
102594: PUSH
102595: LD_VAR 0 5
102599: LESS
102600: IFFALSE 102628
// begin hex := hexes [ i ] ;
102602: LD_ADDR_VAR 0 8
102606: PUSH
102607: LD_VAR 0 2
102611: PUSH
102612: LD_VAR 0 4
102616: ARRAY
102617: ST_TO_ADDR
// dist := tdist ;
102618: LD_ADDR_VAR 0 5
102622: PUSH
102623: LD_VAR 0 6
102627: ST_TO_ADDR
// end ; end ;
102628: GO 102542
102630: POP
102631: POP
// result := hex ;
102632: LD_ADDR_VAR 0 3
102636: PUSH
102637: LD_VAR 0 8
102641: ST_TO_ADDR
// end ;
102642: LD_VAR 0 3
102646: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
102647: LD_INT 0
102649: PPUSH
102650: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
102651: LD_VAR 0 1
102655: NOT
102656: PUSH
102657: LD_VAR 0 1
102661: PUSH
102662: LD_INT 21
102664: PUSH
102665: LD_INT 2
102667: PUSH
102668: EMPTY
102669: LIST
102670: LIST
102671: PUSH
102672: LD_INT 23
102674: PUSH
102675: LD_INT 2
102677: PUSH
102678: EMPTY
102679: LIST
102680: LIST
102681: PUSH
102682: EMPTY
102683: LIST
102684: LIST
102685: PPUSH
102686: CALL_OW 69
102690: IN
102691: NOT
102692: OR
102693: IFFALSE 102697
// exit ;
102695: GO 102744
// for i = 1 to 3 do
102697: LD_ADDR_VAR 0 3
102701: PUSH
102702: DOUBLE
102703: LD_INT 1
102705: DEC
102706: ST_TO_ADDR
102707: LD_INT 3
102709: PUSH
102710: FOR_TO
102711: IFFALSE 102742
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
102713: LD_VAR 0 1
102717: PPUSH
102718: CALL_OW 250
102722: PPUSH
102723: LD_VAR 0 1
102727: PPUSH
102728: CALL_OW 251
102732: PPUSH
102733: LD_INT 1
102735: PPUSH
102736: CALL_OW 453
102740: GO 102710
102742: POP
102743: POP
// end ;
102744: LD_VAR 0 2
102748: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
102749: LD_INT 0
102751: PPUSH
102752: PPUSH
102753: PPUSH
102754: PPUSH
102755: PPUSH
102756: PPUSH
// if not unit or not enemy_unit then
102757: LD_VAR 0 1
102761: NOT
102762: PUSH
102763: LD_VAR 0 2
102767: NOT
102768: OR
102769: IFFALSE 102773
// exit ;
102771: GO 103240
// if GetLives ( i ) < 250 then
102773: LD_VAR 0 4
102777: PPUSH
102778: CALL_OW 256
102782: PUSH
102783: LD_INT 250
102785: LESS
102786: IFFALSE 102799
// begin ComAutodestruct ( i ) ;
102788: LD_VAR 0 4
102792: PPUSH
102793: CALL 102647 0 1
// exit ;
102797: GO 103240
// end ; x := GetX ( enemy_unit ) ;
102799: LD_ADDR_VAR 0 7
102803: PUSH
102804: LD_VAR 0 2
102808: PPUSH
102809: CALL_OW 250
102813: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
102814: LD_ADDR_VAR 0 8
102818: PUSH
102819: LD_VAR 0 2
102823: PPUSH
102824: CALL_OW 251
102828: ST_TO_ADDR
// if not x or not y then
102829: LD_VAR 0 7
102833: NOT
102834: PUSH
102835: LD_VAR 0 8
102839: NOT
102840: OR
102841: IFFALSE 102845
// exit ;
102843: GO 103240
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
102845: LD_ADDR_VAR 0 6
102849: PUSH
102850: LD_VAR 0 7
102854: PPUSH
102855: LD_INT 0
102857: PPUSH
102858: LD_INT 4
102860: PPUSH
102861: CALL_OW 272
102865: PUSH
102866: LD_VAR 0 8
102870: PPUSH
102871: LD_INT 0
102873: PPUSH
102874: LD_INT 4
102876: PPUSH
102877: CALL_OW 273
102881: PUSH
102882: EMPTY
102883: LIST
102884: LIST
102885: PUSH
102886: LD_VAR 0 7
102890: PPUSH
102891: LD_INT 1
102893: PPUSH
102894: LD_INT 4
102896: PPUSH
102897: CALL_OW 272
102901: PUSH
102902: LD_VAR 0 8
102906: PPUSH
102907: LD_INT 1
102909: PPUSH
102910: LD_INT 4
102912: PPUSH
102913: CALL_OW 273
102917: PUSH
102918: EMPTY
102919: LIST
102920: LIST
102921: PUSH
102922: LD_VAR 0 7
102926: PPUSH
102927: LD_INT 2
102929: PPUSH
102930: LD_INT 4
102932: PPUSH
102933: CALL_OW 272
102937: PUSH
102938: LD_VAR 0 8
102942: PPUSH
102943: LD_INT 2
102945: PPUSH
102946: LD_INT 4
102948: PPUSH
102949: CALL_OW 273
102953: PUSH
102954: EMPTY
102955: LIST
102956: LIST
102957: PUSH
102958: LD_VAR 0 7
102962: PPUSH
102963: LD_INT 3
102965: PPUSH
102966: LD_INT 4
102968: PPUSH
102969: CALL_OW 272
102973: PUSH
102974: LD_VAR 0 8
102978: PPUSH
102979: LD_INT 3
102981: PPUSH
102982: LD_INT 4
102984: PPUSH
102985: CALL_OW 273
102989: PUSH
102990: EMPTY
102991: LIST
102992: LIST
102993: PUSH
102994: LD_VAR 0 7
102998: PPUSH
102999: LD_INT 4
103001: PPUSH
103002: LD_INT 4
103004: PPUSH
103005: CALL_OW 272
103009: PUSH
103010: LD_VAR 0 8
103014: PPUSH
103015: LD_INT 4
103017: PPUSH
103018: LD_INT 4
103020: PPUSH
103021: CALL_OW 273
103025: PUSH
103026: EMPTY
103027: LIST
103028: LIST
103029: PUSH
103030: LD_VAR 0 7
103034: PPUSH
103035: LD_INT 5
103037: PPUSH
103038: LD_INT 4
103040: PPUSH
103041: CALL_OW 272
103045: PUSH
103046: LD_VAR 0 8
103050: PPUSH
103051: LD_INT 5
103053: PPUSH
103054: LD_INT 4
103056: PPUSH
103057: CALL_OW 273
103061: PUSH
103062: EMPTY
103063: LIST
103064: LIST
103065: PUSH
103066: EMPTY
103067: LIST
103068: LIST
103069: LIST
103070: LIST
103071: LIST
103072: LIST
103073: ST_TO_ADDR
// for i = tmp downto 1 do
103074: LD_ADDR_VAR 0 4
103078: PUSH
103079: DOUBLE
103080: LD_VAR 0 6
103084: INC
103085: ST_TO_ADDR
103086: LD_INT 1
103088: PUSH
103089: FOR_DOWNTO
103090: IFFALSE 103191
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
103092: LD_VAR 0 6
103096: PUSH
103097: LD_VAR 0 4
103101: ARRAY
103102: PUSH
103103: LD_INT 1
103105: ARRAY
103106: PPUSH
103107: LD_VAR 0 6
103111: PUSH
103112: LD_VAR 0 4
103116: ARRAY
103117: PUSH
103118: LD_INT 2
103120: ARRAY
103121: PPUSH
103122: CALL_OW 488
103126: NOT
103127: PUSH
103128: LD_VAR 0 6
103132: PUSH
103133: LD_VAR 0 4
103137: ARRAY
103138: PUSH
103139: LD_INT 1
103141: ARRAY
103142: PPUSH
103143: LD_VAR 0 6
103147: PUSH
103148: LD_VAR 0 4
103152: ARRAY
103153: PUSH
103154: LD_INT 2
103156: ARRAY
103157: PPUSH
103158: CALL_OW 428
103162: PUSH
103163: LD_INT 0
103165: NONEQUAL
103166: OR
103167: IFFALSE 103189
// tmp := Delete ( tmp , i ) ;
103169: LD_ADDR_VAR 0 6
103173: PUSH
103174: LD_VAR 0 6
103178: PPUSH
103179: LD_VAR 0 4
103183: PPUSH
103184: CALL_OW 3
103188: ST_TO_ADDR
103189: GO 103089
103191: POP
103192: POP
// j := GetClosestHex ( unit , tmp ) ;
103193: LD_ADDR_VAR 0 5
103197: PUSH
103198: LD_VAR 0 1
103202: PPUSH
103203: LD_VAR 0 6
103207: PPUSH
103208: CALL 102495 0 2
103212: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
103213: LD_VAR 0 1
103217: PPUSH
103218: LD_VAR 0 5
103222: PUSH
103223: LD_INT 1
103225: ARRAY
103226: PPUSH
103227: LD_VAR 0 5
103231: PUSH
103232: LD_INT 2
103234: ARRAY
103235: PPUSH
103236: CALL_OW 111
// end ;
103240: LD_VAR 0 3
103244: RET
// export function PrepareApemanSoldier ( ) ; begin
103245: LD_INT 0
103247: PPUSH
// uc_nation := 0 ;
103248: LD_ADDR_OWVAR 21
103252: PUSH
103253: LD_INT 0
103255: ST_TO_ADDR
// hc_sex := sex_male ;
103256: LD_ADDR_OWVAR 27
103260: PUSH
103261: LD_INT 1
103263: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
103264: LD_ADDR_OWVAR 28
103268: PUSH
103269: LD_INT 15
103271: ST_TO_ADDR
// hc_gallery :=  ;
103272: LD_ADDR_OWVAR 33
103276: PUSH
103277: LD_STRING 
103279: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
103280: LD_ADDR_OWVAR 31
103284: PUSH
103285: LD_INT 0
103287: PPUSH
103288: LD_INT 3
103290: PPUSH
103291: CALL_OW 12
103295: PUSH
103296: LD_INT 0
103298: PPUSH
103299: LD_INT 3
103301: PPUSH
103302: CALL_OW 12
103306: PUSH
103307: LD_INT 0
103309: PUSH
103310: LD_INT 0
103312: PUSH
103313: EMPTY
103314: LIST
103315: LIST
103316: LIST
103317: LIST
103318: ST_TO_ADDR
// end ;
103319: LD_VAR 0 1
103323: RET
// export function PrepareApemanEngineer ( ) ; begin
103324: LD_INT 0
103326: PPUSH
// uc_nation := 0 ;
103327: LD_ADDR_OWVAR 21
103331: PUSH
103332: LD_INT 0
103334: ST_TO_ADDR
// hc_sex := sex_male ;
103335: LD_ADDR_OWVAR 27
103339: PUSH
103340: LD_INT 1
103342: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
103343: LD_ADDR_OWVAR 28
103347: PUSH
103348: LD_INT 16
103350: ST_TO_ADDR
// hc_gallery :=  ;
103351: LD_ADDR_OWVAR 33
103355: PUSH
103356: LD_STRING 
103358: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
103359: LD_ADDR_OWVAR 31
103363: PUSH
103364: LD_INT 0
103366: PPUSH
103367: LD_INT 3
103369: PPUSH
103370: CALL_OW 12
103374: PUSH
103375: LD_INT 0
103377: PPUSH
103378: LD_INT 3
103380: PPUSH
103381: CALL_OW 12
103385: PUSH
103386: LD_INT 0
103388: PUSH
103389: LD_INT 0
103391: PUSH
103392: EMPTY
103393: LIST
103394: LIST
103395: LIST
103396: LIST
103397: ST_TO_ADDR
// end ;
103398: LD_VAR 0 1
103402: RET
// export function PrepareApeman ( agressivity ) ; begin
103403: LD_INT 0
103405: PPUSH
// uc_side := 0 ;
103406: LD_ADDR_OWVAR 20
103410: PUSH
103411: LD_INT 0
103413: ST_TO_ADDR
// uc_nation := 0 ;
103414: LD_ADDR_OWVAR 21
103418: PUSH
103419: LD_INT 0
103421: ST_TO_ADDR
// hc_sex := sex_male ;
103422: LD_ADDR_OWVAR 27
103426: PUSH
103427: LD_INT 1
103429: ST_TO_ADDR
// hc_class := class_apeman ;
103430: LD_ADDR_OWVAR 28
103434: PUSH
103435: LD_INT 12
103437: ST_TO_ADDR
// hc_gallery :=  ;
103438: LD_ADDR_OWVAR 33
103442: PUSH
103443: LD_STRING 
103445: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
103446: LD_ADDR_OWVAR 35
103450: PUSH
103451: LD_VAR 0 1
103455: NEG
103456: PPUSH
103457: LD_VAR 0 1
103461: PPUSH
103462: CALL_OW 12
103466: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
103467: LD_ADDR_OWVAR 31
103471: PUSH
103472: LD_INT 0
103474: PPUSH
103475: LD_INT 3
103477: PPUSH
103478: CALL_OW 12
103482: PUSH
103483: LD_INT 0
103485: PPUSH
103486: LD_INT 3
103488: PPUSH
103489: CALL_OW 12
103493: PUSH
103494: LD_INT 0
103496: PUSH
103497: LD_INT 0
103499: PUSH
103500: EMPTY
103501: LIST
103502: LIST
103503: LIST
103504: LIST
103505: ST_TO_ADDR
// end ;
103506: LD_VAR 0 2
103510: RET
// export function PrepareTiger ( agressivity ) ; begin
103511: LD_INT 0
103513: PPUSH
// uc_side := 0 ;
103514: LD_ADDR_OWVAR 20
103518: PUSH
103519: LD_INT 0
103521: ST_TO_ADDR
// uc_nation := 0 ;
103522: LD_ADDR_OWVAR 21
103526: PUSH
103527: LD_INT 0
103529: ST_TO_ADDR
// hc_class := class_tiger ;
103530: LD_ADDR_OWVAR 28
103534: PUSH
103535: LD_INT 14
103537: ST_TO_ADDR
// hc_gallery :=  ;
103538: LD_ADDR_OWVAR 33
103542: PUSH
103543: LD_STRING 
103545: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
103546: LD_ADDR_OWVAR 35
103550: PUSH
103551: LD_VAR 0 1
103555: NEG
103556: PPUSH
103557: LD_VAR 0 1
103561: PPUSH
103562: CALL_OW 12
103566: ST_TO_ADDR
// end ;
103567: LD_VAR 0 2
103571: RET
// export function PrepareEnchidna ( ) ; begin
103572: LD_INT 0
103574: PPUSH
// uc_side := 0 ;
103575: LD_ADDR_OWVAR 20
103579: PUSH
103580: LD_INT 0
103582: ST_TO_ADDR
// uc_nation := 0 ;
103583: LD_ADDR_OWVAR 21
103587: PUSH
103588: LD_INT 0
103590: ST_TO_ADDR
// hc_class := class_baggie ;
103591: LD_ADDR_OWVAR 28
103595: PUSH
103596: LD_INT 13
103598: ST_TO_ADDR
// hc_gallery :=  ;
103599: LD_ADDR_OWVAR 33
103603: PUSH
103604: LD_STRING 
103606: ST_TO_ADDR
// end ;
103607: LD_VAR 0 1
103611: RET
// export function PrepareFrog ( ) ; begin
103612: LD_INT 0
103614: PPUSH
// uc_side := 0 ;
103615: LD_ADDR_OWVAR 20
103619: PUSH
103620: LD_INT 0
103622: ST_TO_ADDR
// uc_nation := 0 ;
103623: LD_ADDR_OWVAR 21
103627: PUSH
103628: LD_INT 0
103630: ST_TO_ADDR
// hc_class := class_frog ;
103631: LD_ADDR_OWVAR 28
103635: PUSH
103636: LD_INT 19
103638: ST_TO_ADDR
// hc_gallery :=  ;
103639: LD_ADDR_OWVAR 33
103643: PUSH
103644: LD_STRING 
103646: ST_TO_ADDR
// end ;
103647: LD_VAR 0 1
103651: RET
// export function PrepareFish ( ) ; begin
103652: LD_INT 0
103654: PPUSH
// uc_side := 0 ;
103655: LD_ADDR_OWVAR 20
103659: PUSH
103660: LD_INT 0
103662: ST_TO_ADDR
// uc_nation := 0 ;
103663: LD_ADDR_OWVAR 21
103667: PUSH
103668: LD_INT 0
103670: ST_TO_ADDR
// hc_class := class_fish ;
103671: LD_ADDR_OWVAR 28
103675: PUSH
103676: LD_INT 20
103678: ST_TO_ADDR
// hc_gallery :=  ;
103679: LD_ADDR_OWVAR 33
103683: PUSH
103684: LD_STRING 
103686: ST_TO_ADDR
// end ;
103687: LD_VAR 0 1
103691: RET
// export function PrepareBird ( ) ; begin
103692: LD_INT 0
103694: PPUSH
// uc_side := 0 ;
103695: LD_ADDR_OWVAR 20
103699: PUSH
103700: LD_INT 0
103702: ST_TO_ADDR
// uc_nation := 0 ;
103703: LD_ADDR_OWVAR 21
103707: PUSH
103708: LD_INT 0
103710: ST_TO_ADDR
// hc_class := class_phororhacos ;
103711: LD_ADDR_OWVAR 28
103715: PUSH
103716: LD_INT 18
103718: ST_TO_ADDR
// hc_gallery :=  ;
103719: LD_ADDR_OWVAR 33
103723: PUSH
103724: LD_STRING 
103726: ST_TO_ADDR
// end ;
103727: LD_VAR 0 1
103731: RET
// export function PrepareHorse ( ) ; begin
103732: LD_INT 0
103734: PPUSH
// uc_side := 0 ;
103735: LD_ADDR_OWVAR 20
103739: PUSH
103740: LD_INT 0
103742: ST_TO_ADDR
// uc_nation := 0 ;
103743: LD_ADDR_OWVAR 21
103747: PUSH
103748: LD_INT 0
103750: ST_TO_ADDR
// hc_class := class_horse ;
103751: LD_ADDR_OWVAR 28
103755: PUSH
103756: LD_INT 21
103758: ST_TO_ADDR
// hc_gallery :=  ;
103759: LD_ADDR_OWVAR 33
103763: PUSH
103764: LD_STRING 
103766: ST_TO_ADDR
// end ;
103767: LD_VAR 0 1
103771: RET
// export function PrepareMastodont ( ) ; begin
103772: LD_INT 0
103774: PPUSH
// uc_side := 0 ;
103775: LD_ADDR_OWVAR 20
103779: PUSH
103780: LD_INT 0
103782: ST_TO_ADDR
// uc_nation := 0 ;
103783: LD_ADDR_OWVAR 21
103787: PUSH
103788: LD_INT 0
103790: ST_TO_ADDR
// vc_chassis := class_mastodont ;
103791: LD_ADDR_OWVAR 37
103795: PUSH
103796: LD_INT 31
103798: ST_TO_ADDR
// vc_control := control_rider ;
103799: LD_ADDR_OWVAR 38
103803: PUSH
103804: LD_INT 4
103806: ST_TO_ADDR
// end ;
103807: LD_VAR 0 1
103811: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
103812: LD_INT 0
103814: PPUSH
103815: PPUSH
103816: PPUSH
// uc_side = 0 ;
103817: LD_ADDR_OWVAR 20
103821: PUSH
103822: LD_INT 0
103824: ST_TO_ADDR
// uc_nation = 0 ;
103825: LD_ADDR_OWVAR 21
103829: PUSH
103830: LD_INT 0
103832: ST_TO_ADDR
// InitHc_All ( ) ;
103833: CALL_OW 584
// InitVc ;
103837: CALL_OW 20
// if mastodonts then
103841: LD_VAR 0 6
103845: IFFALSE 103912
// for i = 1 to mastodonts do
103847: LD_ADDR_VAR 0 11
103851: PUSH
103852: DOUBLE
103853: LD_INT 1
103855: DEC
103856: ST_TO_ADDR
103857: LD_VAR 0 6
103861: PUSH
103862: FOR_TO
103863: IFFALSE 103910
// begin vc_chassis := 31 ;
103865: LD_ADDR_OWVAR 37
103869: PUSH
103870: LD_INT 31
103872: ST_TO_ADDR
// vc_control := control_rider ;
103873: LD_ADDR_OWVAR 38
103877: PUSH
103878: LD_INT 4
103880: ST_TO_ADDR
// animal := CreateVehicle ;
103881: LD_ADDR_VAR 0 12
103885: PUSH
103886: CALL_OW 45
103890: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
103891: LD_VAR 0 12
103895: PPUSH
103896: LD_VAR 0 8
103900: PPUSH
103901: LD_INT 0
103903: PPUSH
103904: CALL 106040 0 3
// end ;
103908: GO 103862
103910: POP
103911: POP
// if horses then
103912: LD_VAR 0 5
103916: IFFALSE 103983
// for i = 1 to horses do
103918: LD_ADDR_VAR 0 11
103922: PUSH
103923: DOUBLE
103924: LD_INT 1
103926: DEC
103927: ST_TO_ADDR
103928: LD_VAR 0 5
103932: PUSH
103933: FOR_TO
103934: IFFALSE 103981
// begin hc_class := 21 ;
103936: LD_ADDR_OWVAR 28
103940: PUSH
103941: LD_INT 21
103943: ST_TO_ADDR
// hc_gallery :=  ;
103944: LD_ADDR_OWVAR 33
103948: PUSH
103949: LD_STRING 
103951: ST_TO_ADDR
// animal := CreateHuman ;
103952: LD_ADDR_VAR 0 12
103956: PUSH
103957: CALL_OW 44
103961: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
103962: LD_VAR 0 12
103966: PPUSH
103967: LD_VAR 0 8
103971: PPUSH
103972: LD_INT 0
103974: PPUSH
103975: CALL 106040 0 3
// end ;
103979: GO 103933
103981: POP
103982: POP
// if birds then
103983: LD_VAR 0 1
103987: IFFALSE 104054
// for i = 1 to birds do
103989: LD_ADDR_VAR 0 11
103993: PUSH
103994: DOUBLE
103995: LD_INT 1
103997: DEC
103998: ST_TO_ADDR
103999: LD_VAR 0 1
104003: PUSH
104004: FOR_TO
104005: IFFALSE 104052
// begin hc_class := 18 ;
104007: LD_ADDR_OWVAR 28
104011: PUSH
104012: LD_INT 18
104014: ST_TO_ADDR
// hc_gallery =  ;
104015: LD_ADDR_OWVAR 33
104019: PUSH
104020: LD_STRING 
104022: ST_TO_ADDR
// animal := CreateHuman ;
104023: LD_ADDR_VAR 0 12
104027: PUSH
104028: CALL_OW 44
104032: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104033: LD_VAR 0 12
104037: PPUSH
104038: LD_VAR 0 8
104042: PPUSH
104043: LD_INT 0
104045: PPUSH
104046: CALL 106040 0 3
// end ;
104050: GO 104004
104052: POP
104053: POP
// if tigers then
104054: LD_VAR 0 2
104058: IFFALSE 104142
// for i = 1 to tigers do
104060: LD_ADDR_VAR 0 11
104064: PUSH
104065: DOUBLE
104066: LD_INT 1
104068: DEC
104069: ST_TO_ADDR
104070: LD_VAR 0 2
104074: PUSH
104075: FOR_TO
104076: IFFALSE 104140
// begin hc_class = class_tiger ;
104078: LD_ADDR_OWVAR 28
104082: PUSH
104083: LD_INT 14
104085: ST_TO_ADDR
// hc_gallery =  ;
104086: LD_ADDR_OWVAR 33
104090: PUSH
104091: LD_STRING 
104093: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
104094: LD_ADDR_OWVAR 35
104098: PUSH
104099: LD_INT 7
104101: NEG
104102: PPUSH
104103: LD_INT 7
104105: PPUSH
104106: CALL_OW 12
104110: ST_TO_ADDR
// animal := CreateHuman ;
104111: LD_ADDR_VAR 0 12
104115: PUSH
104116: CALL_OW 44
104120: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104121: LD_VAR 0 12
104125: PPUSH
104126: LD_VAR 0 8
104130: PPUSH
104131: LD_INT 0
104133: PPUSH
104134: CALL 106040 0 3
// end ;
104138: GO 104075
104140: POP
104141: POP
// if apemans then
104142: LD_VAR 0 3
104146: IFFALSE 104269
// for i = 1 to apemans do
104148: LD_ADDR_VAR 0 11
104152: PUSH
104153: DOUBLE
104154: LD_INT 1
104156: DEC
104157: ST_TO_ADDR
104158: LD_VAR 0 3
104162: PUSH
104163: FOR_TO
104164: IFFALSE 104267
// begin hc_class = class_apeman ;
104166: LD_ADDR_OWVAR 28
104170: PUSH
104171: LD_INT 12
104173: ST_TO_ADDR
// hc_gallery =  ;
104174: LD_ADDR_OWVAR 33
104178: PUSH
104179: LD_STRING 
104181: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
104182: LD_ADDR_OWVAR 35
104186: PUSH
104187: LD_INT 2
104189: NEG
104190: PPUSH
104191: LD_INT 2
104193: PPUSH
104194: CALL_OW 12
104198: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
104199: LD_ADDR_OWVAR 31
104203: PUSH
104204: LD_INT 1
104206: PPUSH
104207: LD_INT 3
104209: PPUSH
104210: CALL_OW 12
104214: PUSH
104215: LD_INT 1
104217: PPUSH
104218: LD_INT 3
104220: PPUSH
104221: CALL_OW 12
104225: PUSH
104226: LD_INT 0
104228: PUSH
104229: LD_INT 0
104231: PUSH
104232: EMPTY
104233: LIST
104234: LIST
104235: LIST
104236: LIST
104237: ST_TO_ADDR
// animal := CreateHuman ;
104238: LD_ADDR_VAR 0 12
104242: PUSH
104243: CALL_OW 44
104247: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104248: LD_VAR 0 12
104252: PPUSH
104253: LD_VAR 0 8
104257: PPUSH
104258: LD_INT 0
104260: PPUSH
104261: CALL 106040 0 3
// end ;
104265: GO 104163
104267: POP
104268: POP
// if enchidnas then
104269: LD_VAR 0 4
104273: IFFALSE 104340
// for i = 1 to enchidnas do
104275: LD_ADDR_VAR 0 11
104279: PUSH
104280: DOUBLE
104281: LD_INT 1
104283: DEC
104284: ST_TO_ADDR
104285: LD_VAR 0 4
104289: PUSH
104290: FOR_TO
104291: IFFALSE 104338
// begin hc_class = 13 ;
104293: LD_ADDR_OWVAR 28
104297: PUSH
104298: LD_INT 13
104300: ST_TO_ADDR
// hc_gallery =  ;
104301: LD_ADDR_OWVAR 33
104305: PUSH
104306: LD_STRING 
104308: ST_TO_ADDR
// animal := CreateHuman ;
104309: LD_ADDR_VAR 0 12
104313: PUSH
104314: CALL_OW 44
104318: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104319: LD_VAR 0 12
104323: PPUSH
104324: LD_VAR 0 8
104328: PPUSH
104329: LD_INT 0
104331: PPUSH
104332: CALL 106040 0 3
// end ;
104336: GO 104290
104338: POP
104339: POP
// if fishes then
104340: LD_VAR 0 7
104344: IFFALSE 104411
// for i = 1 to fishes do
104346: LD_ADDR_VAR 0 11
104350: PUSH
104351: DOUBLE
104352: LD_INT 1
104354: DEC
104355: ST_TO_ADDR
104356: LD_VAR 0 7
104360: PUSH
104361: FOR_TO
104362: IFFALSE 104409
// begin hc_class = 20 ;
104364: LD_ADDR_OWVAR 28
104368: PUSH
104369: LD_INT 20
104371: ST_TO_ADDR
// hc_gallery =  ;
104372: LD_ADDR_OWVAR 33
104376: PUSH
104377: LD_STRING 
104379: ST_TO_ADDR
// animal := CreateHuman ;
104380: LD_ADDR_VAR 0 12
104384: PUSH
104385: CALL_OW 44
104389: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
104390: LD_VAR 0 12
104394: PPUSH
104395: LD_VAR 0 9
104399: PPUSH
104400: LD_INT 0
104402: PPUSH
104403: CALL 106040 0 3
// end ;
104407: GO 104361
104409: POP
104410: POP
// end ;
104411: LD_VAR 0 10
104415: RET
// export function WantHeal ( sci , unit ) ; begin
104416: LD_INT 0
104418: PPUSH
// if GetTaskList ( sci ) > 0 then
104419: LD_VAR 0 1
104423: PPUSH
104424: CALL_OW 437
104428: PUSH
104429: LD_INT 0
104431: GREATER
104432: IFFALSE 104502
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
104434: LD_VAR 0 1
104438: PPUSH
104439: CALL_OW 437
104443: PUSH
104444: LD_INT 1
104446: ARRAY
104447: PUSH
104448: LD_INT 1
104450: ARRAY
104451: PUSH
104452: LD_STRING l
104454: EQUAL
104455: PUSH
104456: LD_VAR 0 1
104460: PPUSH
104461: CALL_OW 437
104465: PUSH
104466: LD_INT 1
104468: ARRAY
104469: PUSH
104470: LD_INT 4
104472: ARRAY
104473: PUSH
104474: LD_VAR 0 2
104478: EQUAL
104479: AND
104480: IFFALSE 104492
// result := true else
104482: LD_ADDR_VAR 0 3
104486: PUSH
104487: LD_INT 1
104489: ST_TO_ADDR
104490: GO 104500
// result := false ;
104492: LD_ADDR_VAR 0 3
104496: PUSH
104497: LD_INT 0
104499: ST_TO_ADDR
// end else
104500: GO 104510
// result := false ;
104502: LD_ADDR_VAR 0 3
104506: PUSH
104507: LD_INT 0
104509: ST_TO_ADDR
// end ;
104510: LD_VAR 0 3
104514: RET
// export function HealTarget ( sci ) ; begin
104515: LD_INT 0
104517: PPUSH
// if not sci then
104518: LD_VAR 0 1
104522: NOT
104523: IFFALSE 104527
// exit ;
104525: GO 104592
// result := 0 ;
104527: LD_ADDR_VAR 0 2
104531: PUSH
104532: LD_INT 0
104534: ST_TO_ADDR
// if GetTaskList ( sci ) then
104535: LD_VAR 0 1
104539: PPUSH
104540: CALL_OW 437
104544: IFFALSE 104592
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
104546: LD_VAR 0 1
104550: PPUSH
104551: CALL_OW 437
104555: PUSH
104556: LD_INT 1
104558: ARRAY
104559: PUSH
104560: LD_INT 1
104562: ARRAY
104563: PUSH
104564: LD_STRING l
104566: EQUAL
104567: IFFALSE 104592
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
104569: LD_ADDR_VAR 0 2
104573: PUSH
104574: LD_VAR 0 1
104578: PPUSH
104579: CALL_OW 437
104583: PUSH
104584: LD_INT 1
104586: ARRAY
104587: PUSH
104588: LD_INT 4
104590: ARRAY
104591: ST_TO_ADDR
// end ;
104592: LD_VAR 0 2
104596: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
104597: LD_INT 0
104599: PPUSH
104600: PPUSH
104601: PPUSH
104602: PPUSH
// if not base_units then
104603: LD_VAR 0 1
104607: NOT
104608: IFFALSE 104612
// exit ;
104610: GO 104699
// result := false ;
104612: LD_ADDR_VAR 0 2
104616: PUSH
104617: LD_INT 0
104619: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
104620: LD_ADDR_VAR 0 5
104624: PUSH
104625: LD_VAR 0 1
104629: PPUSH
104630: LD_INT 21
104632: PUSH
104633: LD_INT 3
104635: PUSH
104636: EMPTY
104637: LIST
104638: LIST
104639: PPUSH
104640: CALL_OW 72
104644: ST_TO_ADDR
// if not tmp then
104645: LD_VAR 0 5
104649: NOT
104650: IFFALSE 104654
// exit ;
104652: GO 104699
// for i in tmp do
104654: LD_ADDR_VAR 0 3
104658: PUSH
104659: LD_VAR 0 5
104663: PUSH
104664: FOR_IN
104665: IFFALSE 104697
// begin result := EnemyInRange ( i , 22 ) ;
104667: LD_ADDR_VAR 0 2
104671: PUSH
104672: LD_VAR 0 3
104676: PPUSH
104677: LD_INT 22
104679: PPUSH
104680: CALL 102297 0 2
104684: ST_TO_ADDR
// if result then
104685: LD_VAR 0 2
104689: IFFALSE 104695
// exit ;
104691: POP
104692: POP
104693: GO 104699
// end ;
104695: GO 104664
104697: POP
104698: POP
// end ;
104699: LD_VAR 0 2
104703: RET
// export function FilterByTag ( units , tag ) ; begin
104704: LD_INT 0
104706: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
104707: LD_ADDR_VAR 0 3
104711: PUSH
104712: LD_VAR 0 1
104716: PPUSH
104717: LD_INT 120
104719: PUSH
104720: LD_VAR 0 2
104724: PUSH
104725: EMPTY
104726: LIST
104727: LIST
104728: PPUSH
104729: CALL_OW 72
104733: ST_TO_ADDR
// end ;
104734: LD_VAR 0 3
104738: RET
// export function IsDriver ( un ) ; begin
104739: LD_INT 0
104741: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
104742: LD_ADDR_VAR 0 2
104746: PUSH
104747: LD_VAR 0 1
104751: PUSH
104752: LD_INT 55
104754: PUSH
104755: EMPTY
104756: LIST
104757: PPUSH
104758: CALL_OW 69
104762: IN
104763: ST_TO_ADDR
// end ;
104764: LD_VAR 0 2
104768: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
104769: LD_INT 0
104771: PPUSH
104772: PPUSH
// list := [ ] ;
104773: LD_ADDR_VAR 0 5
104777: PUSH
104778: EMPTY
104779: ST_TO_ADDR
// case d of 0 :
104780: LD_VAR 0 3
104784: PUSH
104785: LD_INT 0
104787: DOUBLE
104788: EQUAL
104789: IFTRUE 104793
104791: GO 104926
104793: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
104794: LD_ADDR_VAR 0 5
104798: PUSH
104799: LD_VAR 0 1
104803: PUSH
104804: LD_INT 4
104806: MINUS
104807: PUSH
104808: LD_VAR 0 2
104812: PUSH
104813: LD_INT 4
104815: MINUS
104816: PUSH
104817: LD_INT 2
104819: PUSH
104820: EMPTY
104821: LIST
104822: LIST
104823: LIST
104824: PUSH
104825: LD_VAR 0 1
104829: PUSH
104830: LD_INT 3
104832: MINUS
104833: PUSH
104834: LD_VAR 0 2
104838: PUSH
104839: LD_INT 1
104841: PUSH
104842: EMPTY
104843: LIST
104844: LIST
104845: LIST
104846: PUSH
104847: LD_VAR 0 1
104851: PUSH
104852: LD_INT 4
104854: PLUS
104855: PUSH
104856: LD_VAR 0 2
104860: PUSH
104861: LD_INT 4
104863: PUSH
104864: EMPTY
104865: LIST
104866: LIST
104867: LIST
104868: PUSH
104869: LD_VAR 0 1
104873: PUSH
104874: LD_INT 3
104876: PLUS
104877: PUSH
104878: LD_VAR 0 2
104882: PUSH
104883: LD_INT 3
104885: PLUS
104886: PUSH
104887: LD_INT 5
104889: PUSH
104890: EMPTY
104891: LIST
104892: LIST
104893: LIST
104894: PUSH
104895: LD_VAR 0 1
104899: PUSH
104900: LD_VAR 0 2
104904: PUSH
104905: LD_INT 4
104907: PLUS
104908: PUSH
104909: LD_INT 0
104911: PUSH
104912: EMPTY
104913: LIST
104914: LIST
104915: LIST
104916: PUSH
104917: EMPTY
104918: LIST
104919: LIST
104920: LIST
104921: LIST
104922: LIST
104923: ST_TO_ADDR
// end ; 1 :
104924: GO 105624
104926: LD_INT 1
104928: DOUBLE
104929: EQUAL
104930: IFTRUE 104934
104932: GO 105067
104934: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
104935: LD_ADDR_VAR 0 5
104939: PUSH
104940: LD_VAR 0 1
104944: PUSH
104945: LD_VAR 0 2
104949: PUSH
104950: LD_INT 4
104952: MINUS
104953: PUSH
104954: LD_INT 3
104956: PUSH
104957: EMPTY
104958: LIST
104959: LIST
104960: LIST
104961: PUSH
104962: LD_VAR 0 1
104966: PUSH
104967: LD_INT 3
104969: MINUS
104970: PUSH
104971: LD_VAR 0 2
104975: PUSH
104976: LD_INT 3
104978: MINUS
104979: PUSH
104980: LD_INT 2
104982: PUSH
104983: EMPTY
104984: LIST
104985: LIST
104986: LIST
104987: PUSH
104988: LD_VAR 0 1
104992: PUSH
104993: LD_INT 4
104995: MINUS
104996: PUSH
104997: LD_VAR 0 2
105001: PUSH
105002: LD_INT 1
105004: PUSH
105005: EMPTY
105006: LIST
105007: LIST
105008: LIST
105009: PUSH
105010: LD_VAR 0 1
105014: PUSH
105015: LD_VAR 0 2
105019: PUSH
105020: LD_INT 3
105022: PLUS
105023: PUSH
105024: LD_INT 0
105026: PUSH
105027: EMPTY
105028: LIST
105029: LIST
105030: LIST
105031: PUSH
105032: LD_VAR 0 1
105036: PUSH
105037: LD_INT 4
105039: PLUS
105040: PUSH
105041: LD_VAR 0 2
105045: PUSH
105046: LD_INT 4
105048: PLUS
105049: PUSH
105050: LD_INT 5
105052: PUSH
105053: EMPTY
105054: LIST
105055: LIST
105056: LIST
105057: PUSH
105058: EMPTY
105059: LIST
105060: LIST
105061: LIST
105062: LIST
105063: LIST
105064: ST_TO_ADDR
// end ; 2 :
105065: GO 105624
105067: LD_INT 2
105069: DOUBLE
105070: EQUAL
105071: IFTRUE 105075
105073: GO 105204
105075: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
105076: LD_ADDR_VAR 0 5
105080: PUSH
105081: LD_VAR 0 1
105085: PUSH
105086: LD_VAR 0 2
105090: PUSH
105091: LD_INT 3
105093: MINUS
105094: PUSH
105095: LD_INT 3
105097: PUSH
105098: EMPTY
105099: LIST
105100: LIST
105101: LIST
105102: PUSH
105103: LD_VAR 0 1
105107: PUSH
105108: LD_INT 4
105110: PLUS
105111: PUSH
105112: LD_VAR 0 2
105116: PUSH
105117: LD_INT 4
105119: PUSH
105120: EMPTY
105121: LIST
105122: LIST
105123: LIST
105124: PUSH
105125: LD_VAR 0 1
105129: PUSH
105130: LD_VAR 0 2
105134: PUSH
105135: LD_INT 4
105137: PLUS
105138: PUSH
105139: LD_INT 0
105141: PUSH
105142: EMPTY
105143: LIST
105144: LIST
105145: LIST
105146: PUSH
105147: LD_VAR 0 1
105151: PUSH
105152: LD_INT 3
105154: MINUS
105155: PUSH
105156: LD_VAR 0 2
105160: PUSH
105161: LD_INT 1
105163: PUSH
105164: EMPTY
105165: LIST
105166: LIST
105167: LIST
105168: PUSH
105169: LD_VAR 0 1
105173: PUSH
105174: LD_INT 4
105176: MINUS
105177: PUSH
105178: LD_VAR 0 2
105182: PUSH
105183: LD_INT 4
105185: MINUS
105186: PUSH
105187: LD_INT 2
105189: PUSH
105190: EMPTY
105191: LIST
105192: LIST
105193: LIST
105194: PUSH
105195: EMPTY
105196: LIST
105197: LIST
105198: LIST
105199: LIST
105200: LIST
105201: ST_TO_ADDR
// end ; 3 :
105202: GO 105624
105204: LD_INT 3
105206: DOUBLE
105207: EQUAL
105208: IFTRUE 105212
105210: GO 105345
105212: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
105213: LD_ADDR_VAR 0 5
105217: PUSH
105218: LD_VAR 0 1
105222: PUSH
105223: LD_INT 3
105225: PLUS
105226: PUSH
105227: LD_VAR 0 2
105231: PUSH
105232: LD_INT 4
105234: PUSH
105235: EMPTY
105236: LIST
105237: LIST
105238: LIST
105239: PUSH
105240: LD_VAR 0 1
105244: PUSH
105245: LD_INT 4
105247: PLUS
105248: PUSH
105249: LD_VAR 0 2
105253: PUSH
105254: LD_INT 4
105256: PLUS
105257: PUSH
105258: LD_INT 5
105260: PUSH
105261: EMPTY
105262: LIST
105263: LIST
105264: LIST
105265: PUSH
105266: LD_VAR 0 1
105270: PUSH
105271: LD_INT 4
105273: MINUS
105274: PUSH
105275: LD_VAR 0 2
105279: PUSH
105280: LD_INT 1
105282: PUSH
105283: EMPTY
105284: LIST
105285: LIST
105286: LIST
105287: PUSH
105288: LD_VAR 0 1
105292: PUSH
105293: LD_VAR 0 2
105297: PUSH
105298: LD_INT 4
105300: MINUS
105301: PUSH
105302: LD_INT 3
105304: PUSH
105305: EMPTY
105306: LIST
105307: LIST
105308: LIST
105309: PUSH
105310: LD_VAR 0 1
105314: PUSH
105315: LD_INT 3
105317: MINUS
105318: PUSH
105319: LD_VAR 0 2
105323: PUSH
105324: LD_INT 3
105326: MINUS
105327: PUSH
105328: LD_INT 2
105330: PUSH
105331: EMPTY
105332: LIST
105333: LIST
105334: LIST
105335: PUSH
105336: EMPTY
105337: LIST
105338: LIST
105339: LIST
105340: LIST
105341: LIST
105342: ST_TO_ADDR
// end ; 4 :
105343: GO 105624
105345: LD_INT 4
105347: DOUBLE
105348: EQUAL
105349: IFTRUE 105353
105351: GO 105486
105353: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
105354: LD_ADDR_VAR 0 5
105358: PUSH
105359: LD_VAR 0 1
105363: PUSH
105364: LD_VAR 0 2
105368: PUSH
105369: LD_INT 4
105371: PLUS
105372: PUSH
105373: LD_INT 0
105375: PUSH
105376: EMPTY
105377: LIST
105378: LIST
105379: LIST
105380: PUSH
105381: LD_VAR 0 1
105385: PUSH
105386: LD_INT 3
105388: PLUS
105389: PUSH
105390: LD_VAR 0 2
105394: PUSH
105395: LD_INT 3
105397: PLUS
105398: PUSH
105399: LD_INT 5
105401: PUSH
105402: EMPTY
105403: LIST
105404: LIST
105405: LIST
105406: PUSH
105407: LD_VAR 0 1
105411: PUSH
105412: LD_INT 4
105414: PLUS
105415: PUSH
105416: LD_VAR 0 2
105420: PUSH
105421: LD_INT 4
105423: PUSH
105424: EMPTY
105425: LIST
105426: LIST
105427: LIST
105428: PUSH
105429: LD_VAR 0 1
105433: PUSH
105434: LD_VAR 0 2
105438: PUSH
105439: LD_INT 3
105441: MINUS
105442: PUSH
105443: LD_INT 3
105445: PUSH
105446: EMPTY
105447: LIST
105448: LIST
105449: LIST
105450: PUSH
105451: LD_VAR 0 1
105455: PUSH
105456: LD_INT 4
105458: MINUS
105459: PUSH
105460: LD_VAR 0 2
105464: PUSH
105465: LD_INT 4
105467: MINUS
105468: PUSH
105469: LD_INT 2
105471: PUSH
105472: EMPTY
105473: LIST
105474: LIST
105475: LIST
105476: PUSH
105477: EMPTY
105478: LIST
105479: LIST
105480: LIST
105481: LIST
105482: LIST
105483: ST_TO_ADDR
// end ; 5 :
105484: GO 105624
105486: LD_INT 5
105488: DOUBLE
105489: EQUAL
105490: IFTRUE 105494
105492: GO 105623
105494: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
105495: LD_ADDR_VAR 0 5
105499: PUSH
105500: LD_VAR 0 1
105504: PUSH
105505: LD_INT 4
105507: MINUS
105508: PUSH
105509: LD_VAR 0 2
105513: PUSH
105514: LD_INT 1
105516: PUSH
105517: EMPTY
105518: LIST
105519: LIST
105520: LIST
105521: PUSH
105522: LD_VAR 0 1
105526: PUSH
105527: LD_VAR 0 2
105531: PUSH
105532: LD_INT 4
105534: MINUS
105535: PUSH
105536: LD_INT 3
105538: PUSH
105539: EMPTY
105540: LIST
105541: LIST
105542: LIST
105543: PUSH
105544: LD_VAR 0 1
105548: PUSH
105549: LD_INT 4
105551: PLUS
105552: PUSH
105553: LD_VAR 0 2
105557: PUSH
105558: LD_INT 4
105560: PLUS
105561: PUSH
105562: LD_INT 5
105564: PUSH
105565: EMPTY
105566: LIST
105567: LIST
105568: LIST
105569: PUSH
105570: LD_VAR 0 1
105574: PUSH
105575: LD_INT 3
105577: PLUS
105578: PUSH
105579: LD_VAR 0 2
105583: PUSH
105584: LD_INT 4
105586: PUSH
105587: EMPTY
105588: LIST
105589: LIST
105590: LIST
105591: PUSH
105592: LD_VAR 0 1
105596: PUSH
105597: LD_VAR 0 2
105601: PUSH
105602: LD_INT 3
105604: PLUS
105605: PUSH
105606: LD_INT 0
105608: PUSH
105609: EMPTY
105610: LIST
105611: LIST
105612: LIST
105613: PUSH
105614: EMPTY
105615: LIST
105616: LIST
105617: LIST
105618: LIST
105619: LIST
105620: ST_TO_ADDR
// end ; end ;
105621: GO 105624
105623: POP
// result := list ;
105624: LD_ADDR_VAR 0 4
105628: PUSH
105629: LD_VAR 0 5
105633: ST_TO_ADDR
// end ;
105634: LD_VAR 0 4
105638: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
105639: LD_INT 0
105641: PPUSH
105642: PPUSH
105643: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
105644: LD_VAR 0 1
105648: NOT
105649: PUSH
105650: LD_VAR 0 2
105654: PUSH
105655: LD_INT 1
105657: PUSH
105658: LD_INT 2
105660: PUSH
105661: LD_INT 3
105663: PUSH
105664: LD_INT 4
105666: PUSH
105667: EMPTY
105668: LIST
105669: LIST
105670: LIST
105671: LIST
105672: IN
105673: NOT
105674: OR
105675: IFFALSE 105679
// exit ;
105677: GO 105762
// tmp := [ ] ;
105679: LD_ADDR_VAR 0 5
105683: PUSH
105684: EMPTY
105685: ST_TO_ADDR
// for i in units do
105686: LD_ADDR_VAR 0 4
105690: PUSH
105691: LD_VAR 0 1
105695: PUSH
105696: FOR_IN
105697: IFFALSE 105731
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
105699: LD_ADDR_VAR 0 5
105703: PUSH
105704: LD_VAR 0 5
105708: PPUSH
105709: LD_VAR 0 4
105713: PPUSH
105714: LD_VAR 0 2
105718: PPUSH
105719: CALL_OW 259
105723: PPUSH
105724: CALL 107135 0 2
105728: ST_TO_ADDR
105729: GO 105696
105731: POP
105732: POP
// if not tmp then
105733: LD_VAR 0 5
105737: NOT
105738: IFFALSE 105742
// exit ;
105740: GO 105762
// result := SortListByListDesc ( units , tmp ) ;
105742: LD_ADDR_VAR 0 3
105746: PUSH
105747: LD_VAR 0 1
105751: PPUSH
105752: LD_VAR 0 5
105756: PPUSH
105757: CALL_OW 77
105761: ST_TO_ADDR
// end ;
105762: LD_VAR 0 3
105766: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
105767: LD_INT 0
105769: PPUSH
105770: PPUSH
105771: PPUSH
// result := false ;
105772: LD_ADDR_VAR 0 3
105776: PUSH
105777: LD_INT 0
105779: ST_TO_ADDR
// if not building then
105780: LD_VAR 0 2
105784: NOT
105785: IFFALSE 105789
// exit ;
105787: GO 105927
// x := GetX ( building ) ;
105789: LD_ADDR_VAR 0 4
105793: PUSH
105794: LD_VAR 0 2
105798: PPUSH
105799: CALL_OW 250
105803: ST_TO_ADDR
// y := GetY ( building ) ;
105804: LD_ADDR_VAR 0 5
105808: PUSH
105809: LD_VAR 0 2
105813: PPUSH
105814: CALL_OW 251
105818: ST_TO_ADDR
// if not x or not y then
105819: LD_VAR 0 4
105823: NOT
105824: PUSH
105825: LD_VAR 0 5
105829: NOT
105830: OR
105831: IFFALSE 105835
// exit ;
105833: GO 105927
// if GetTaskList ( unit ) then
105835: LD_VAR 0 1
105839: PPUSH
105840: CALL_OW 437
105844: IFFALSE 105927
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
105846: LD_STRING e
105848: PUSH
105849: LD_VAR 0 1
105853: PPUSH
105854: CALL_OW 437
105858: PUSH
105859: LD_INT 1
105861: ARRAY
105862: PUSH
105863: LD_INT 1
105865: ARRAY
105866: EQUAL
105867: PUSH
105868: LD_VAR 0 4
105872: PUSH
105873: LD_VAR 0 1
105877: PPUSH
105878: CALL_OW 437
105882: PUSH
105883: LD_INT 1
105885: ARRAY
105886: PUSH
105887: LD_INT 2
105889: ARRAY
105890: EQUAL
105891: AND
105892: PUSH
105893: LD_VAR 0 5
105897: PUSH
105898: LD_VAR 0 1
105902: PPUSH
105903: CALL_OW 437
105907: PUSH
105908: LD_INT 1
105910: ARRAY
105911: PUSH
105912: LD_INT 3
105914: ARRAY
105915: EQUAL
105916: AND
105917: IFFALSE 105927
// result := true end ;
105919: LD_ADDR_VAR 0 3
105923: PUSH
105924: LD_INT 1
105926: ST_TO_ADDR
// end ;
105927: LD_VAR 0 3
105931: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
105932: LD_INT 0
105934: PPUSH
// result := false ;
105935: LD_ADDR_VAR 0 4
105939: PUSH
105940: LD_INT 0
105942: ST_TO_ADDR
// if GetTaskList ( unit ) then
105943: LD_VAR 0 1
105947: PPUSH
105948: CALL_OW 437
105952: IFFALSE 106035
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
105954: LD_STRING M
105956: PUSH
105957: LD_VAR 0 1
105961: PPUSH
105962: CALL_OW 437
105966: PUSH
105967: LD_INT 1
105969: ARRAY
105970: PUSH
105971: LD_INT 1
105973: ARRAY
105974: EQUAL
105975: PUSH
105976: LD_VAR 0 2
105980: PUSH
105981: LD_VAR 0 1
105985: PPUSH
105986: CALL_OW 437
105990: PUSH
105991: LD_INT 1
105993: ARRAY
105994: PUSH
105995: LD_INT 2
105997: ARRAY
105998: EQUAL
105999: AND
106000: PUSH
106001: LD_VAR 0 3
106005: PUSH
106006: LD_VAR 0 1
106010: PPUSH
106011: CALL_OW 437
106015: PUSH
106016: LD_INT 1
106018: ARRAY
106019: PUSH
106020: LD_INT 3
106022: ARRAY
106023: EQUAL
106024: AND
106025: IFFALSE 106035
// result := true ;
106027: LD_ADDR_VAR 0 4
106031: PUSH
106032: LD_INT 1
106034: ST_TO_ADDR
// end ; end ;
106035: LD_VAR 0 4
106039: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
106040: LD_INT 0
106042: PPUSH
106043: PPUSH
106044: PPUSH
106045: PPUSH
// if not unit or not area then
106046: LD_VAR 0 1
106050: NOT
106051: PUSH
106052: LD_VAR 0 2
106056: NOT
106057: OR
106058: IFFALSE 106062
// exit ;
106060: GO 106238
// tmp := AreaToList ( area , i ) ;
106062: LD_ADDR_VAR 0 6
106066: PUSH
106067: LD_VAR 0 2
106071: PPUSH
106072: LD_VAR 0 5
106076: PPUSH
106077: CALL_OW 517
106081: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
106082: LD_ADDR_VAR 0 5
106086: PUSH
106087: DOUBLE
106088: LD_INT 1
106090: DEC
106091: ST_TO_ADDR
106092: LD_VAR 0 6
106096: PUSH
106097: LD_INT 1
106099: ARRAY
106100: PUSH
106101: FOR_TO
106102: IFFALSE 106236
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
106104: LD_ADDR_VAR 0 7
106108: PUSH
106109: LD_VAR 0 6
106113: PUSH
106114: LD_INT 1
106116: ARRAY
106117: PUSH
106118: LD_VAR 0 5
106122: ARRAY
106123: PUSH
106124: LD_VAR 0 6
106128: PUSH
106129: LD_INT 2
106131: ARRAY
106132: PUSH
106133: LD_VAR 0 5
106137: ARRAY
106138: PUSH
106139: EMPTY
106140: LIST
106141: LIST
106142: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
106143: LD_INT 92
106145: PUSH
106146: LD_VAR 0 7
106150: PUSH
106151: LD_INT 1
106153: ARRAY
106154: PUSH
106155: LD_VAR 0 7
106159: PUSH
106160: LD_INT 2
106162: ARRAY
106163: PUSH
106164: LD_INT 2
106166: PUSH
106167: EMPTY
106168: LIST
106169: LIST
106170: LIST
106171: LIST
106172: PPUSH
106173: CALL_OW 69
106177: PUSH
106178: LD_INT 0
106180: EQUAL
106181: IFFALSE 106234
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
106183: LD_VAR 0 1
106187: PPUSH
106188: LD_VAR 0 7
106192: PUSH
106193: LD_INT 1
106195: ARRAY
106196: PPUSH
106197: LD_VAR 0 7
106201: PUSH
106202: LD_INT 2
106204: ARRAY
106205: PPUSH
106206: LD_VAR 0 3
106210: PPUSH
106211: CALL_OW 48
// result := IsPlaced ( unit ) ;
106215: LD_ADDR_VAR 0 4
106219: PUSH
106220: LD_VAR 0 1
106224: PPUSH
106225: CALL_OW 305
106229: ST_TO_ADDR
// exit ;
106230: POP
106231: POP
106232: GO 106238
// end ; end ;
106234: GO 106101
106236: POP
106237: POP
// end ;
106238: LD_VAR 0 4
106242: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
106243: LD_INT 0
106245: PPUSH
106246: PPUSH
106247: PPUSH
// if not side or side > 8 then
106248: LD_VAR 0 1
106252: NOT
106253: PUSH
106254: LD_VAR 0 1
106258: PUSH
106259: LD_INT 8
106261: GREATER
106262: OR
106263: IFFALSE 106267
// exit ;
106265: GO 106454
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
106267: LD_ADDR_VAR 0 4
106271: PUSH
106272: LD_INT 22
106274: PUSH
106275: LD_VAR 0 1
106279: PUSH
106280: EMPTY
106281: LIST
106282: LIST
106283: PUSH
106284: LD_INT 21
106286: PUSH
106287: LD_INT 3
106289: PUSH
106290: EMPTY
106291: LIST
106292: LIST
106293: PUSH
106294: EMPTY
106295: LIST
106296: LIST
106297: PPUSH
106298: CALL_OW 69
106302: ST_TO_ADDR
// if not tmp then
106303: LD_VAR 0 4
106307: NOT
106308: IFFALSE 106312
// exit ;
106310: GO 106454
// enable_addtolog := true ;
106312: LD_ADDR_OWVAR 81
106316: PUSH
106317: LD_INT 1
106319: ST_TO_ADDR
// AddToLog ( [ ) ;
106320: LD_STRING [
106322: PPUSH
106323: CALL_OW 561
// for i in tmp do
106327: LD_ADDR_VAR 0 3
106331: PUSH
106332: LD_VAR 0 4
106336: PUSH
106337: FOR_IN
106338: IFFALSE 106445
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
106340: LD_STRING [
106342: PUSH
106343: LD_VAR 0 3
106347: PPUSH
106348: CALL_OW 266
106352: STR
106353: PUSH
106354: LD_STRING , 
106356: STR
106357: PUSH
106358: LD_VAR 0 3
106362: PPUSH
106363: CALL_OW 250
106367: STR
106368: PUSH
106369: LD_STRING , 
106371: STR
106372: PUSH
106373: LD_VAR 0 3
106377: PPUSH
106378: CALL_OW 251
106382: STR
106383: PUSH
106384: LD_STRING , 
106386: STR
106387: PUSH
106388: LD_VAR 0 3
106392: PPUSH
106393: CALL_OW 254
106397: STR
106398: PUSH
106399: LD_STRING , 
106401: STR
106402: PUSH
106403: LD_VAR 0 3
106407: PPUSH
106408: LD_INT 1
106410: PPUSH
106411: CALL_OW 268
106415: STR
106416: PUSH
106417: LD_STRING , 
106419: STR
106420: PUSH
106421: LD_VAR 0 3
106425: PPUSH
106426: LD_INT 2
106428: PPUSH
106429: CALL_OW 268
106433: STR
106434: PUSH
106435: LD_STRING ],
106437: STR
106438: PPUSH
106439: CALL_OW 561
// end ;
106443: GO 106337
106445: POP
106446: POP
// AddToLog ( ]; ) ;
106447: LD_STRING ];
106449: PPUSH
106450: CALL_OW 561
// end ;
106454: LD_VAR 0 2
106458: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
106459: LD_INT 0
106461: PPUSH
106462: PPUSH
106463: PPUSH
106464: PPUSH
106465: PPUSH
// if not area or not rate or not max then
106466: LD_VAR 0 1
106470: NOT
106471: PUSH
106472: LD_VAR 0 2
106476: NOT
106477: OR
106478: PUSH
106479: LD_VAR 0 4
106483: NOT
106484: OR
106485: IFFALSE 106489
// exit ;
106487: GO 106678
// while 1 do
106489: LD_INT 1
106491: IFFALSE 106678
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
106493: LD_ADDR_VAR 0 9
106497: PUSH
106498: LD_VAR 0 1
106502: PPUSH
106503: LD_INT 1
106505: PPUSH
106506: CALL_OW 287
106510: PUSH
106511: LD_INT 10
106513: MUL
106514: ST_TO_ADDR
// r := rate / 10 ;
106515: LD_ADDR_VAR 0 7
106519: PUSH
106520: LD_VAR 0 2
106524: PUSH
106525: LD_INT 10
106527: DIVREAL
106528: ST_TO_ADDR
// time := 1 1$00 ;
106529: LD_ADDR_VAR 0 8
106533: PUSH
106534: LD_INT 2100
106536: ST_TO_ADDR
// if amount < min then
106537: LD_VAR 0 9
106541: PUSH
106542: LD_VAR 0 3
106546: LESS
106547: IFFALSE 106565
// r := r * 2 else
106549: LD_ADDR_VAR 0 7
106553: PUSH
106554: LD_VAR 0 7
106558: PUSH
106559: LD_INT 2
106561: MUL
106562: ST_TO_ADDR
106563: GO 106591
// if amount > max then
106565: LD_VAR 0 9
106569: PUSH
106570: LD_VAR 0 4
106574: GREATER
106575: IFFALSE 106591
// r := r / 2 ;
106577: LD_ADDR_VAR 0 7
106581: PUSH
106582: LD_VAR 0 7
106586: PUSH
106587: LD_INT 2
106589: DIVREAL
106590: ST_TO_ADDR
// time := time / r ;
106591: LD_ADDR_VAR 0 8
106595: PUSH
106596: LD_VAR 0 8
106600: PUSH
106601: LD_VAR 0 7
106605: DIVREAL
106606: ST_TO_ADDR
// if time < 0 then
106607: LD_VAR 0 8
106611: PUSH
106612: LD_INT 0
106614: LESS
106615: IFFALSE 106632
// time := time * - 1 ;
106617: LD_ADDR_VAR 0 8
106621: PUSH
106622: LD_VAR 0 8
106626: PUSH
106627: LD_INT 1
106629: NEG
106630: MUL
106631: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
106632: LD_VAR 0 8
106636: PUSH
106637: LD_INT 35
106639: PPUSH
106640: LD_INT 875
106642: PPUSH
106643: CALL_OW 12
106647: PLUS
106648: PPUSH
106649: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
106653: LD_INT 1
106655: PPUSH
106656: LD_INT 5
106658: PPUSH
106659: CALL_OW 12
106663: PPUSH
106664: LD_VAR 0 1
106668: PPUSH
106669: LD_INT 1
106671: PPUSH
106672: CALL_OW 55
// end ;
106676: GO 106489
// end ;
106678: LD_VAR 0 5
106682: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
106683: LD_INT 0
106685: PPUSH
106686: PPUSH
106687: PPUSH
106688: PPUSH
106689: PPUSH
106690: PPUSH
106691: PPUSH
106692: PPUSH
// if not turrets or not factories then
106693: LD_VAR 0 1
106697: NOT
106698: PUSH
106699: LD_VAR 0 2
106703: NOT
106704: OR
106705: IFFALSE 106709
// exit ;
106707: GO 107016
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
106709: LD_ADDR_VAR 0 10
106713: PUSH
106714: LD_INT 5
106716: PUSH
106717: LD_INT 6
106719: PUSH
106720: EMPTY
106721: LIST
106722: LIST
106723: PUSH
106724: LD_INT 2
106726: PUSH
106727: LD_INT 4
106729: PUSH
106730: EMPTY
106731: LIST
106732: LIST
106733: PUSH
106734: LD_INT 3
106736: PUSH
106737: LD_INT 5
106739: PUSH
106740: EMPTY
106741: LIST
106742: LIST
106743: PUSH
106744: EMPTY
106745: LIST
106746: LIST
106747: LIST
106748: PUSH
106749: LD_INT 24
106751: PUSH
106752: LD_INT 25
106754: PUSH
106755: EMPTY
106756: LIST
106757: LIST
106758: PUSH
106759: LD_INT 23
106761: PUSH
106762: LD_INT 27
106764: PUSH
106765: EMPTY
106766: LIST
106767: LIST
106768: PUSH
106769: EMPTY
106770: LIST
106771: LIST
106772: PUSH
106773: LD_INT 42
106775: PUSH
106776: LD_INT 43
106778: PUSH
106779: EMPTY
106780: LIST
106781: LIST
106782: PUSH
106783: LD_INT 44
106785: PUSH
106786: LD_INT 46
106788: PUSH
106789: EMPTY
106790: LIST
106791: LIST
106792: PUSH
106793: LD_INT 45
106795: PUSH
106796: LD_INT 47
106798: PUSH
106799: EMPTY
106800: LIST
106801: LIST
106802: PUSH
106803: EMPTY
106804: LIST
106805: LIST
106806: LIST
106807: PUSH
106808: EMPTY
106809: LIST
106810: LIST
106811: LIST
106812: ST_TO_ADDR
// result := [ ] ;
106813: LD_ADDR_VAR 0 3
106817: PUSH
106818: EMPTY
106819: ST_TO_ADDR
// for i in turrets do
106820: LD_ADDR_VAR 0 4
106824: PUSH
106825: LD_VAR 0 1
106829: PUSH
106830: FOR_IN
106831: IFFALSE 107014
// begin nat := GetNation ( i ) ;
106833: LD_ADDR_VAR 0 7
106837: PUSH
106838: LD_VAR 0 4
106842: PPUSH
106843: CALL_OW 248
106847: ST_TO_ADDR
// weapon := 0 ;
106848: LD_ADDR_VAR 0 8
106852: PUSH
106853: LD_INT 0
106855: ST_TO_ADDR
// if not nat then
106856: LD_VAR 0 7
106860: NOT
106861: IFFALSE 106865
// continue ;
106863: GO 106830
// for j in list [ nat ] do
106865: LD_ADDR_VAR 0 5
106869: PUSH
106870: LD_VAR 0 10
106874: PUSH
106875: LD_VAR 0 7
106879: ARRAY
106880: PUSH
106881: FOR_IN
106882: IFFALSE 106923
// if GetBWeapon ( i ) = j [ 1 ] then
106884: LD_VAR 0 4
106888: PPUSH
106889: CALL_OW 269
106893: PUSH
106894: LD_VAR 0 5
106898: PUSH
106899: LD_INT 1
106901: ARRAY
106902: EQUAL
106903: IFFALSE 106921
// begin weapon := j [ 2 ] ;
106905: LD_ADDR_VAR 0 8
106909: PUSH
106910: LD_VAR 0 5
106914: PUSH
106915: LD_INT 2
106917: ARRAY
106918: ST_TO_ADDR
// break ;
106919: GO 106923
// end ;
106921: GO 106881
106923: POP
106924: POP
// if not weapon then
106925: LD_VAR 0 8
106929: NOT
106930: IFFALSE 106934
// continue ;
106932: GO 106830
// for k in factories do
106934: LD_ADDR_VAR 0 6
106938: PUSH
106939: LD_VAR 0 2
106943: PUSH
106944: FOR_IN
106945: IFFALSE 107010
// begin weapons := AvailableWeaponList ( k ) ;
106947: LD_ADDR_VAR 0 9
106951: PUSH
106952: LD_VAR 0 6
106956: PPUSH
106957: CALL_OW 478
106961: ST_TO_ADDR
// if not weapons then
106962: LD_VAR 0 9
106966: NOT
106967: IFFALSE 106971
// continue ;
106969: GO 106944
// if weapon in weapons then
106971: LD_VAR 0 8
106975: PUSH
106976: LD_VAR 0 9
106980: IN
106981: IFFALSE 107008
// begin result := [ i , weapon ] ;
106983: LD_ADDR_VAR 0 3
106987: PUSH
106988: LD_VAR 0 4
106992: PUSH
106993: LD_VAR 0 8
106997: PUSH
106998: EMPTY
106999: LIST
107000: LIST
107001: ST_TO_ADDR
// exit ;
107002: POP
107003: POP
107004: POP
107005: POP
107006: GO 107016
// end ; end ;
107008: GO 106944
107010: POP
107011: POP
// end ;
107012: GO 106830
107014: POP
107015: POP
// end ;
107016: LD_VAR 0 3
107020: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
107021: LD_INT 0
107023: PPUSH
// if not side or side > 8 then
107024: LD_VAR 0 3
107028: NOT
107029: PUSH
107030: LD_VAR 0 3
107034: PUSH
107035: LD_INT 8
107037: GREATER
107038: OR
107039: IFFALSE 107043
// exit ;
107041: GO 107102
// if not range then
107043: LD_VAR 0 4
107047: NOT
107048: IFFALSE 107059
// range := - 12 ;
107050: LD_ADDR_VAR 0 4
107054: PUSH
107055: LD_INT 12
107057: NEG
107058: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
107059: LD_VAR 0 1
107063: PPUSH
107064: LD_VAR 0 2
107068: PPUSH
107069: LD_VAR 0 3
107073: PPUSH
107074: LD_VAR 0 4
107078: PPUSH
107079: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
107083: LD_VAR 0 1
107087: PPUSH
107088: LD_VAR 0 2
107092: PPUSH
107093: LD_VAR 0 3
107097: PPUSH
107098: CALL_OW 331
// end ;
107102: LD_VAR 0 5
107106: RET
// export function Video ( mode ) ; begin
107107: LD_INT 0
107109: PPUSH
// ingame_video = mode ;
107110: LD_ADDR_OWVAR 52
107114: PUSH
107115: LD_VAR 0 1
107119: ST_TO_ADDR
// interface_hidden = mode ;
107120: LD_ADDR_OWVAR 54
107124: PUSH
107125: LD_VAR 0 1
107129: ST_TO_ADDR
// end ;
107130: LD_VAR 0 2
107134: RET
// export function Join ( array , element ) ; begin
107135: LD_INT 0
107137: PPUSH
// result := Replace ( array , array + 1 , element ) ;
107138: LD_ADDR_VAR 0 3
107142: PUSH
107143: LD_VAR 0 1
107147: PPUSH
107148: LD_VAR 0 1
107152: PUSH
107153: LD_INT 1
107155: PLUS
107156: PPUSH
107157: LD_VAR 0 2
107161: PPUSH
107162: CALL_OW 1
107166: ST_TO_ADDR
// end ;
107167: LD_VAR 0 3
107171: RET
// export function JoinUnion ( array , element ) ; begin
107172: LD_INT 0
107174: PPUSH
// result := array union element ;
107175: LD_ADDR_VAR 0 3
107179: PUSH
107180: LD_VAR 0 1
107184: PUSH
107185: LD_VAR 0 2
107189: UNION
107190: ST_TO_ADDR
// end ;
107191: LD_VAR 0 3
107195: RET
// export function GetBehemoths ( side ) ; begin
107196: LD_INT 0
107198: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
107199: LD_ADDR_VAR 0 2
107203: PUSH
107204: LD_INT 22
107206: PUSH
107207: LD_VAR 0 1
107211: PUSH
107212: EMPTY
107213: LIST
107214: LIST
107215: PUSH
107216: LD_INT 31
107218: PUSH
107219: LD_INT 25
107221: PUSH
107222: EMPTY
107223: LIST
107224: LIST
107225: PUSH
107226: EMPTY
107227: LIST
107228: LIST
107229: PPUSH
107230: CALL_OW 69
107234: ST_TO_ADDR
// end ;
107235: LD_VAR 0 2
107239: RET
// export function Shuffle ( array ) ; var i , index ; begin
107240: LD_INT 0
107242: PPUSH
107243: PPUSH
107244: PPUSH
// result := [ ] ;
107245: LD_ADDR_VAR 0 2
107249: PUSH
107250: EMPTY
107251: ST_TO_ADDR
// if not array then
107252: LD_VAR 0 1
107256: NOT
107257: IFFALSE 107261
// exit ;
107259: GO 107360
// Randomize ;
107261: CALL_OW 10
// for i = array downto 1 do
107265: LD_ADDR_VAR 0 3
107269: PUSH
107270: DOUBLE
107271: LD_VAR 0 1
107275: INC
107276: ST_TO_ADDR
107277: LD_INT 1
107279: PUSH
107280: FOR_DOWNTO
107281: IFFALSE 107358
// begin index := rand ( 1 , array ) ;
107283: LD_ADDR_VAR 0 4
107287: PUSH
107288: LD_INT 1
107290: PPUSH
107291: LD_VAR 0 1
107295: PPUSH
107296: CALL_OW 12
107300: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
107301: LD_ADDR_VAR 0 2
107305: PUSH
107306: LD_VAR 0 2
107310: PPUSH
107311: LD_VAR 0 2
107315: PUSH
107316: LD_INT 1
107318: PLUS
107319: PPUSH
107320: LD_VAR 0 1
107324: PUSH
107325: LD_VAR 0 4
107329: ARRAY
107330: PPUSH
107331: CALL_OW 2
107335: ST_TO_ADDR
// array := Delete ( array , index ) ;
107336: LD_ADDR_VAR 0 1
107340: PUSH
107341: LD_VAR 0 1
107345: PPUSH
107346: LD_VAR 0 4
107350: PPUSH
107351: CALL_OW 3
107355: ST_TO_ADDR
// end ;
107356: GO 107280
107358: POP
107359: POP
// end ;
107360: LD_VAR 0 2
107364: RET
// export function GetBaseMaterials ( base ) ; begin
107365: LD_INT 0
107367: PPUSH
// result := [ 0 , 0 , 0 ] ;
107368: LD_ADDR_VAR 0 2
107372: PUSH
107373: LD_INT 0
107375: PUSH
107376: LD_INT 0
107378: PUSH
107379: LD_INT 0
107381: PUSH
107382: EMPTY
107383: LIST
107384: LIST
107385: LIST
107386: ST_TO_ADDR
// if not base then
107387: LD_VAR 0 1
107391: NOT
107392: IFFALSE 107396
// exit ;
107394: GO 107445
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
107396: LD_ADDR_VAR 0 2
107400: PUSH
107401: LD_VAR 0 1
107405: PPUSH
107406: LD_INT 1
107408: PPUSH
107409: CALL_OW 275
107413: PUSH
107414: LD_VAR 0 1
107418: PPUSH
107419: LD_INT 2
107421: PPUSH
107422: CALL_OW 275
107426: PUSH
107427: LD_VAR 0 1
107431: PPUSH
107432: LD_INT 3
107434: PPUSH
107435: CALL_OW 275
107439: PUSH
107440: EMPTY
107441: LIST
107442: LIST
107443: LIST
107444: ST_TO_ADDR
// end ;
107445: LD_VAR 0 2
107449: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
107450: LD_INT 0
107452: PPUSH
107453: PPUSH
// result := array ;
107454: LD_ADDR_VAR 0 3
107458: PUSH
107459: LD_VAR 0 1
107463: ST_TO_ADDR
// if size >= result then
107464: LD_VAR 0 2
107468: PUSH
107469: LD_VAR 0 3
107473: GREATEREQUAL
107474: IFFALSE 107478
// exit ;
107476: GO 107528
// if size then
107478: LD_VAR 0 2
107482: IFFALSE 107528
// for i := array downto size do
107484: LD_ADDR_VAR 0 4
107488: PUSH
107489: DOUBLE
107490: LD_VAR 0 1
107494: INC
107495: ST_TO_ADDR
107496: LD_VAR 0 2
107500: PUSH
107501: FOR_DOWNTO
107502: IFFALSE 107526
// result := Delete ( result , result ) ;
107504: LD_ADDR_VAR 0 3
107508: PUSH
107509: LD_VAR 0 3
107513: PPUSH
107514: LD_VAR 0 3
107518: PPUSH
107519: CALL_OW 3
107523: ST_TO_ADDR
107524: GO 107501
107526: POP
107527: POP
// end ;
107528: LD_VAR 0 3
107532: RET
// export function ComExit ( unit ) ; var tmp ; begin
107533: LD_INT 0
107535: PPUSH
107536: PPUSH
// if not IsInUnit ( unit ) then
107537: LD_VAR 0 1
107541: PPUSH
107542: CALL_OW 310
107546: NOT
107547: IFFALSE 107551
// exit ;
107549: GO 107611
// tmp := IsInUnit ( unit ) ;
107551: LD_ADDR_VAR 0 3
107555: PUSH
107556: LD_VAR 0 1
107560: PPUSH
107561: CALL_OW 310
107565: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
107566: LD_VAR 0 3
107570: PPUSH
107571: CALL_OW 247
107575: PUSH
107576: LD_INT 2
107578: EQUAL
107579: IFFALSE 107592
// ComExitVehicle ( unit ) else
107581: LD_VAR 0 1
107585: PPUSH
107586: CALL_OW 121
107590: GO 107601
// ComExitBuilding ( unit ) ;
107592: LD_VAR 0 1
107596: PPUSH
107597: CALL_OW 122
// result := tmp ;
107601: LD_ADDR_VAR 0 2
107605: PUSH
107606: LD_VAR 0 3
107610: ST_TO_ADDR
// end ;
107611: LD_VAR 0 2
107615: RET
// export function ComExitAll ( units ) ; var i ; begin
107616: LD_INT 0
107618: PPUSH
107619: PPUSH
// if not units then
107620: LD_VAR 0 1
107624: NOT
107625: IFFALSE 107629
// exit ;
107627: GO 107655
// for i in units do
107629: LD_ADDR_VAR 0 3
107633: PUSH
107634: LD_VAR 0 1
107638: PUSH
107639: FOR_IN
107640: IFFALSE 107653
// ComExit ( i ) ;
107642: LD_VAR 0 3
107646: PPUSH
107647: CALL 107533 0 1
107651: GO 107639
107653: POP
107654: POP
// end ;
107655: LD_VAR 0 2
107659: RET
// export function ResetHc ; begin
107660: LD_INT 0
107662: PPUSH
// InitHc ;
107663: CALL_OW 19
// hc_importance := 0 ;
107667: LD_ADDR_OWVAR 32
107671: PUSH
107672: LD_INT 0
107674: ST_TO_ADDR
// end ;
107675: LD_VAR 0 1
107679: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
107680: LD_INT 0
107682: PPUSH
107683: PPUSH
107684: PPUSH
// _x := ( x1 + x2 ) div 2 ;
107685: LD_ADDR_VAR 0 6
107689: PUSH
107690: LD_VAR 0 1
107694: PUSH
107695: LD_VAR 0 3
107699: PLUS
107700: PUSH
107701: LD_INT 2
107703: DIV
107704: ST_TO_ADDR
// if _x < 0 then
107705: LD_VAR 0 6
107709: PUSH
107710: LD_INT 0
107712: LESS
107713: IFFALSE 107730
// _x := _x * - 1 ;
107715: LD_ADDR_VAR 0 6
107719: PUSH
107720: LD_VAR 0 6
107724: PUSH
107725: LD_INT 1
107727: NEG
107728: MUL
107729: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
107730: LD_ADDR_VAR 0 7
107734: PUSH
107735: LD_VAR 0 2
107739: PUSH
107740: LD_VAR 0 4
107744: PLUS
107745: PUSH
107746: LD_INT 2
107748: DIV
107749: ST_TO_ADDR
// if _y < 0 then
107750: LD_VAR 0 7
107754: PUSH
107755: LD_INT 0
107757: LESS
107758: IFFALSE 107775
// _y := _y * - 1 ;
107760: LD_ADDR_VAR 0 7
107764: PUSH
107765: LD_VAR 0 7
107769: PUSH
107770: LD_INT 1
107772: NEG
107773: MUL
107774: ST_TO_ADDR
// result := [ _x , _y ] ;
107775: LD_ADDR_VAR 0 5
107779: PUSH
107780: LD_VAR 0 6
107784: PUSH
107785: LD_VAR 0 7
107789: PUSH
107790: EMPTY
107791: LIST
107792: LIST
107793: ST_TO_ADDR
// end ;
107794: LD_VAR 0 5
107798: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
107799: LD_INT 0
107801: PPUSH
107802: PPUSH
107803: PPUSH
107804: PPUSH
// task := GetTaskList ( unit ) ;
107805: LD_ADDR_VAR 0 7
107809: PUSH
107810: LD_VAR 0 1
107814: PPUSH
107815: CALL_OW 437
107819: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
107820: LD_VAR 0 7
107824: NOT
107825: PUSH
107826: LD_VAR 0 1
107830: PPUSH
107831: LD_VAR 0 2
107835: PPUSH
107836: CALL_OW 308
107840: NOT
107841: AND
107842: IFFALSE 107846
// exit ;
107844: GO 107964
// if IsInArea ( unit , area ) then
107846: LD_VAR 0 1
107850: PPUSH
107851: LD_VAR 0 2
107855: PPUSH
107856: CALL_OW 308
107860: IFFALSE 107878
// begin ComMoveToArea ( unit , goAway ) ;
107862: LD_VAR 0 1
107866: PPUSH
107867: LD_VAR 0 3
107871: PPUSH
107872: CALL_OW 113
// exit ;
107876: GO 107964
// end ; if task [ 1 ] [ 1 ] <> M then
107878: LD_VAR 0 7
107882: PUSH
107883: LD_INT 1
107885: ARRAY
107886: PUSH
107887: LD_INT 1
107889: ARRAY
107890: PUSH
107891: LD_STRING M
107893: NONEQUAL
107894: IFFALSE 107898
// exit ;
107896: GO 107964
// x := task [ 1 ] [ 2 ] ;
107898: LD_ADDR_VAR 0 5
107902: PUSH
107903: LD_VAR 0 7
107907: PUSH
107908: LD_INT 1
107910: ARRAY
107911: PUSH
107912: LD_INT 2
107914: ARRAY
107915: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
107916: LD_ADDR_VAR 0 6
107920: PUSH
107921: LD_VAR 0 7
107925: PUSH
107926: LD_INT 1
107928: ARRAY
107929: PUSH
107930: LD_INT 3
107932: ARRAY
107933: ST_TO_ADDR
// if InArea ( x , y , area ) then
107934: LD_VAR 0 5
107938: PPUSH
107939: LD_VAR 0 6
107943: PPUSH
107944: LD_VAR 0 2
107948: PPUSH
107949: CALL_OW 309
107953: IFFALSE 107964
// ComStop ( unit ) ;
107955: LD_VAR 0 1
107959: PPUSH
107960: CALL_OW 141
// end ;
107964: LD_VAR 0 4
107968: RET
// export function Abs ( value ) ; begin
107969: LD_INT 0
107971: PPUSH
// result := value ;
107972: LD_ADDR_VAR 0 2
107976: PUSH
107977: LD_VAR 0 1
107981: ST_TO_ADDR
// if value < 0 then
107982: LD_VAR 0 1
107986: PUSH
107987: LD_INT 0
107989: LESS
107990: IFFALSE 108007
// result := value * - 1 ;
107992: LD_ADDR_VAR 0 2
107996: PUSH
107997: LD_VAR 0 1
108001: PUSH
108002: LD_INT 1
108004: NEG
108005: MUL
108006: ST_TO_ADDR
// end ;
108007: LD_VAR 0 2
108011: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
108012: LD_INT 0
108014: PPUSH
108015: PPUSH
108016: PPUSH
108017: PPUSH
108018: PPUSH
108019: PPUSH
108020: PPUSH
108021: PPUSH
// if not unit or not building then
108022: LD_VAR 0 1
108026: NOT
108027: PUSH
108028: LD_VAR 0 2
108032: NOT
108033: OR
108034: IFFALSE 108038
// exit ;
108036: GO 108264
// x := GetX ( building ) ;
108038: LD_ADDR_VAR 0 4
108042: PUSH
108043: LD_VAR 0 2
108047: PPUSH
108048: CALL_OW 250
108052: ST_TO_ADDR
// y := GetY ( building ) ;
108053: LD_ADDR_VAR 0 6
108057: PUSH
108058: LD_VAR 0 2
108062: PPUSH
108063: CALL_OW 251
108067: ST_TO_ADDR
// d := GetDir ( building ) ;
108068: LD_ADDR_VAR 0 8
108072: PUSH
108073: LD_VAR 0 2
108077: PPUSH
108078: CALL_OW 254
108082: ST_TO_ADDR
// r := 4 ;
108083: LD_ADDR_VAR 0 9
108087: PUSH
108088: LD_INT 4
108090: ST_TO_ADDR
// for i := 1 to 5 do
108091: LD_ADDR_VAR 0 10
108095: PUSH
108096: DOUBLE
108097: LD_INT 1
108099: DEC
108100: ST_TO_ADDR
108101: LD_INT 5
108103: PUSH
108104: FOR_TO
108105: IFFALSE 108262
// begin _x := ShiftX ( x , d , r + i ) ;
108107: LD_ADDR_VAR 0 5
108111: PUSH
108112: LD_VAR 0 4
108116: PPUSH
108117: LD_VAR 0 8
108121: PPUSH
108122: LD_VAR 0 9
108126: PUSH
108127: LD_VAR 0 10
108131: PLUS
108132: PPUSH
108133: CALL_OW 272
108137: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
108138: LD_ADDR_VAR 0 7
108142: PUSH
108143: LD_VAR 0 6
108147: PPUSH
108148: LD_VAR 0 8
108152: PPUSH
108153: LD_VAR 0 9
108157: PUSH
108158: LD_VAR 0 10
108162: PLUS
108163: PPUSH
108164: CALL_OW 273
108168: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
108169: LD_VAR 0 5
108173: PPUSH
108174: LD_VAR 0 7
108178: PPUSH
108179: CALL_OW 488
108183: PUSH
108184: LD_VAR 0 5
108188: PPUSH
108189: LD_VAR 0 7
108193: PPUSH
108194: CALL_OW 428
108198: PPUSH
108199: CALL_OW 247
108203: PUSH
108204: LD_INT 3
108206: PUSH
108207: LD_INT 2
108209: PUSH
108210: EMPTY
108211: LIST
108212: LIST
108213: IN
108214: NOT
108215: AND
108216: IFFALSE 108260
// begin ComMoveXY ( unit , _x , _y ) ;
108218: LD_VAR 0 1
108222: PPUSH
108223: LD_VAR 0 5
108227: PPUSH
108228: LD_VAR 0 7
108232: PPUSH
108233: CALL_OW 111
// result := [ _x , _y ] ;
108237: LD_ADDR_VAR 0 3
108241: PUSH
108242: LD_VAR 0 5
108246: PUSH
108247: LD_VAR 0 7
108251: PUSH
108252: EMPTY
108253: LIST
108254: LIST
108255: ST_TO_ADDR
// exit ;
108256: POP
108257: POP
108258: GO 108264
// end ; end ;
108260: GO 108104
108262: POP
108263: POP
// end ;
108264: LD_VAR 0 3
108268: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
108269: LD_INT 0
108271: PPUSH
108272: PPUSH
108273: PPUSH
// result := 0 ;
108274: LD_ADDR_VAR 0 3
108278: PUSH
108279: LD_INT 0
108281: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
108282: LD_VAR 0 1
108286: PUSH
108287: LD_INT 0
108289: LESS
108290: PUSH
108291: LD_VAR 0 1
108295: PUSH
108296: LD_INT 8
108298: GREATER
108299: OR
108300: PUSH
108301: LD_VAR 0 2
108305: PUSH
108306: LD_INT 0
108308: LESS
108309: OR
108310: PUSH
108311: LD_VAR 0 2
108315: PUSH
108316: LD_INT 8
108318: GREATER
108319: OR
108320: IFFALSE 108324
// exit ;
108322: GO 108399
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
108324: LD_ADDR_VAR 0 4
108328: PUSH
108329: LD_INT 22
108331: PUSH
108332: LD_VAR 0 2
108336: PUSH
108337: EMPTY
108338: LIST
108339: LIST
108340: PPUSH
108341: CALL_OW 69
108345: PUSH
108346: FOR_IN
108347: IFFALSE 108397
// begin un := UnitShoot ( i ) ;
108349: LD_ADDR_VAR 0 5
108353: PUSH
108354: LD_VAR 0 4
108358: PPUSH
108359: CALL_OW 504
108363: ST_TO_ADDR
// if GetSide ( un ) = side1 then
108364: LD_VAR 0 5
108368: PPUSH
108369: CALL_OW 255
108373: PUSH
108374: LD_VAR 0 1
108378: EQUAL
108379: IFFALSE 108395
// begin result := un ;
108381: LD_ADDR_VAR 0 3
108385: PUSH
108386: LD_VAR 0 5
108390: ST_TO_ADDR
// exit ;
108391: POP
108392: POP
108393: GO 108399
// end ; end ;
108395: GO 108346
108397: POP
108398: POP
// end ;
108399: LD_VAR 0 3
108403: RET
// export function GetCargoBay ( units ) ; begin
108404: LD_INT 0
108406: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
108407: LD_ADDR_VAR 0 2
108411: PUSH
108412: LD_VAR 0 1
108416: PPUSH
108417: LD_INT 2
108419: PUSH
108420: LD_INT 34
108422: PUSH
108423: LD_INT 12
108425: PUSH
108426: EMPTY
108427: LIST
108428: LIST
108429: PUSH
108430: LD_INT 34
108432: PUSH
108433: LD_INT 51
108435: PUSH
108436: EMPTY
108437: LIST
108438: LIST
108439: PUSH
108440: LD_INT 34
108442: PUSH
108443: LD_INT 32
108445: PUSH
108446: EMPTY
108447: LIST
108448: LIST
108449: PUSH
108450: LD_INT 34
108452: PUSH
108453: LD_INT 89
108455: PUSH
108456: EMPTY
108457: LIST
108458: LIST
108459: PUSH
108460: EMPTY
108461: LIST
108462: LIST
108463: LIST
108464: LIST
108465: LIST
108466: PPUSH
108467: CALL_OW 72
108471: ST_TO_ADDR
// end ;
108472: LD_VAR 0 2
108476: RET
// export function Negate ( value ) ; begin
108477: LD_INT 0
108479: PPUSH
// result := not value ;
108480: LD_ADDR_VAR 0 2
108484: PUSH
108485: LD_VAR 0 1
108489: NOT
108490: ST_TO_ADDR
// end ;
108491: LD_VAR 0 2
108495: RET
// export function Inc ( value ) ; begin
108496: LD_INT 0
108498: PPUSH
// result := value + 1 ;
108499: LD_ADDR_VAR 0 2
108503: PUSH
108504: LD_VAR 0 1
108508: PUSH
108509: LD_INT 1
108511: PLUS
108512: ST_TO_ADDR
// end ;
108513: LD_VAR 0 2
108517: RET
// export function Dec ( value ) ; begin
108518: LD_INT 0
108520: PPUSH
// result := value - 1 ;
108521: LD_ADDR_VAR 0 2
108525: PUSH
108526: LD_VAR 0 1
108530: PUSH
108531: LD_INT 1
108533: MINUS
108534: ST_TO_ADDR
// end ;
108535: LD_VAR 0 2
108539: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
108540: LD_INT 0
108542: PPUSH
108543: PPUSH
108544: PPUSH
108545: PPUSH
108546: PPUSH
108547: PPUSH
108548: PPUSH
108549: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
108550: LD_VAR 0 1
108554: PPUSH
108555: LD_VAR 0 2
108559: PPUSH
108560: CALL_OW 488
108564: NOT
108565: PUSH
108566: LD_VAR 0 3
108570: PPUSH
108571: LD_VAR 0 4
108575: PPUSH
108576: CALL_OW 488
108580: NOT
108581: OR
108582: IFFALSE 108595
// begin result := - 1 ;
108584: LD_ADDR_VAR 0 5
108588: PUSH
108589: LD_INT 1
108591: NEG
108592: ST_TO_ADDR
// exit ;
108593: GO 108830
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
108595: LD_ADDR_VAR 0 12
108599: PUSH
108600: LD_VAR 0 1
108604: PPUSH
108605: LD_VAR 0 2
108609: PPUSH
108610: LD_VAR 0 3
108614: PPUSH
108615: LD_VAR 0 4
108619: PPUSH
108620: CALL 107680 0 4
108624: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
108625: LD_ADDR_VAR 0 11
108629: PUSH
108630: LD_VAR 0 1
108634: PPUSH
108635: LD_VAR 0 2
108639: PPUSH
108640: LD_VAR 0 12
108644: PUSH
108645: LD_INT 1
108647: ARRAY
108648: PPUSH
108649: LD_VAR 0 12
108653: PUSH
108654: LD_INT 2
108656: ARRAY
108657: PPUSH
108658: CALL_OW 298
108662: ST_TO_ADDR
// distance := 9999 ;
108663: LD_ADDR_VAR 0 10
108667: PUSH
108668: LD_INT 9999
108670: ST_TO_ADDR
// for i := 0 to 5 do
108671: LD_ADDR_VAR 0 6
108675: PUSH
108676: DOUBLE
108677: LD_INT 0
108679: DEC
108680: ST_TO_ADDR
108681: LD_INT 5
108683: PUSH
108684: FOR_TO
108685: IFFALSE 108828
// begin _x := ShiftX ( x1 , i , centerDist ) ;
108687: LD_ADDR_VAR 0 7
108691: PUSH
108692: LD_VAR 0 1
108696: PPUSH
108697: LD_VAR 0 6
108701: PPUSH
108702: LD_VAR 0 11
108706: PPUSH
108707: CALL_OW 272
108711: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
108712: LD_ADDR_VAR 0 8
108716: PUSH
108717: LD_VAR 0 2
108721: PPUSH
108722: LD_VAR 0 6
108726: PPUSH
108727: LD_VAR 0 11
108731: PPUSH
108732: CALL_OW 273
108736: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
108737: LD_VAR 0 7
108741: PPUSH
108742: LD_VAR 0 8
108746: PPUSH
108747: CALL_OW 488
108751: NOT
108752: IFFALSE 108756
// continue ;
108754: GO 108684
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
108756: LD_ADDR_VAR 0 9
108760: PUSH
108761: LD_VAR 0 12
108765: PUSH
108766: LD_INT 1
108768: ARRAY
108769: PPUSH
108770: LD_VAR 0 12
108774: PUSH
108775: LD_INT 2
108777: ARRAY
108778: PPUSH
108779: LD_VAR 0 7
108783: PPUSH
108784: LD_VAR 0 8
108788: PPUSH
108789: CALL_OW 298
108793: ST_TO_ADDR
// if tmp < distance then
108794: LD_VAR 0 9
108798: PUSH
108799: LD_VAR 0 10
108803: LESS
108804: IFFALSE 108826
// begin result := i ;
108806: LD_ADDR_VAR 0 5
108810: PUSH
108811: LD_VAR 0 6
108815: ST_TO_ADDR
// distance := tmp ;
108816: LD_ADDR_VAR 0 10
108820: PUSH
108821: LD_VAR 0 9
108825: ST_TO_ADDR
// end ; end ;
108826: GO 108684
108828: POP
108829: POP
// end ;
108830: LD_VAR 0 5
108834: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
108835: LD_INT 0
108837: PPUSH
108838: PPUSH
// if not driver or not IsInUnit ( driver ) then
108839: LD_VAR 0 1
108843: NOT
108844: PUSH
108845: LD_VAR 0 1
108849: PPUSH
108850: CALL_OW 310
108854: NOT
108855: OR
108856: IFFALSE 108860
// exit ;
108858: GO 108950
// vehicle := IsInUnit ( driver ) ;
108860: LD_ADDR_VAR 0 3
108864: PUSH
108865: LD_VAR 0 1
108869: PPUSH
108870: CALL_OW 310
108874: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
108875: LD_VAR 0 1
108879: PPUSH
108880: LD_STRING \
108882: PUSH
108883: LD_INT 0
108885: PUSH
108886: LD_INT 0
108888: PUSH
108889: LD_INT 0
108891: PUSH
108892: LD_INT 0
108894: PUSH
108895: LD_INT 0
108897: PUSH
108898: LD_INT 0
108900: PUSH
108901: EMPTY
108902: LIST
108903: LIST
108904: LIST
108905: LIST
108906: LIST
108907: LIST
108908: LIST
108909: PUSH
108910: LD_STRING E
108912: PUSH
108913: LD_INT 0
108915: PUSH
108916: LD_INT 0
108918: PUSH
108919: LD_VAR 0 3
108923: PUSH
108924: LD_INT 0
108926: PUSH
108927: LD_INT 0
108929: PUSH
108930: LD_INT 0
108932: PUSH
108933: EMPTY
108934: LIST
108935: LIST
108936: LIST
108937: LIST
108938: LIST
108939: LIST
108940: LIST
108941: PUSH
108942: EMPTY
108943: LIST
108944: LIST
108945: PPUSH
108946: CALL_OW 446
// end ;
108950: LD_VAR 0 2
108954: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
108955: LD_INT 0
108957: PPUSH
108958: PPUSH
// if not driver or not IsInUnit ( driver ) then
108959: LD_VAR 0 1
108963: NOT
108964: PUSH
108965: LD_VAR 0 1
108969: PPUSH
108970: CALL_OW 310
108974: NOT
108975: OR
108976: IFFALSE 108980
// exit ;
108978: GO 109070
// vehicle := IsInUnit ( driver ) ;
108980: LD_ADDR_VAR 0 3
108984: PUSH
108985: LD_VAR 0 1
108989: PPUSH
108990: CALL_OW 310
108994: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
108995: LD_VAR 0 1
108999: PPUSH
109000: LD_STRING \
109002: PUSH
109003: LD_INT 0
109005: PUSH
109006: LD_INT 0
109008: PUSH
109009: LD_INT 0
109011: PUSH
109012: LD_INT 0
109014: PUSH
109015: LD_INT 0
109017: PUSH
109018: LD_INT 0
109020: PUSH
109021: EMPTY
109022: LIST
109023: LIST
109024: LIST
109025: LIST
109026: LIST
109027: LIST
109028: LIST
109029: PUSH
109030: LD_STRING E
109032: PUSH
109033: LD_INT 0
109035: PUSH
109036: LD_INT 0
109038: PUSH
109039: LD_VAR 0 3
109043: PUSH
109044: LD_INT 0
109046: PUSH
109047: LD_INT 0
109049: PUSH
109050: LD_INT 0
109052: PUSH
109053: EMPTY
109054: LIST
109055: LIST
109056: LIST
109057: LIST
109058: LIST
109059: LIST
109060: LIST
109061: PUSH
109062: EMPTY
109063: LIST
109064: LIST
109065: PPUSH
109066: CALL_OW 447
// end ;
109070: LD_VAR 0 2
109074: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
109075: LD_INT 0
109077: PPUSH
109078: PPUSH
109079: PPUSH
// tmp := [ ] ;
109080: LD_ADDR_VAR 0 5
109084: PUSH
109085: EMPTY
109086: ST_TO_ADDR
// for i in units do
109087: LD_ADDR_VAR 0 4
109091: PUSH
109092: LD_VAR 0 1
109096: PUSH
109097: FOR_IN
109098: IFFALSE 109136
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
109100: LD_ADDR_VAR 0 5
109104: PUSH
109105: LD_VAR 0 5
109109: PPUSH
109110: LD_VAR 0 5
109114: PUSH
109115: LD_INT 1
109117: PLUS
109118: PPUSH
109119: LD_VAR 0 4
109123: PPUSH
109124: CALL_OW 256
109128: PPUSH
109129: CALL_OW 2
109133: ST_TO_ADDR
109134: GO 109097
109136: POP
109137: POP
// if not tmp then
109138: LD_VAR 0 5
109142: NOT
109143: IFFALSE 109147
// exit ;
109145: GO 109195
// if asc then
109147: LD_VAR 0 2
109151: IFFALSE 109175
// result := SortListByListAsc ( units , tmp ) else
109153: LD_ADDR_VAR 0 3
109157: PUSH
109158: LD_VAR 0 1
109162: PPUSH
109163: LD_VAR 0 5
109167: PPUSH
109168: CALL_OW 76
109172: ST_TO_ADDR
109173: GO 109195
// result := SortListByListDesc ( units , tmp ) ;
109175: LD_ADDR_VAR 0 3
109179: PUSH
109180: LD_VAR 0 1
109184: PPUSH
109185: LD_VAR 0 5
109189: PPUSH
109190: CALL_OW 77
109194: ST_TO_ADDR
// end ;
109195: LD_VAR 0 3
109199: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
109200: LD_INT 0
109202: PPUSH
109203: PPUSH
// task := GetTaskList ( mech ) ;
109204: LD_ADDR_VAR 0 4
109208: PUSH
109209: LD_VAR 0 1
109213: PPUSH
109214: CALL_OW 437
109218: ST_TO_ADDR
// if not task then
109219: LD_VAR 0 4
109223: NOT
109224: IFFALSE 109228
// exit ;
109226: GO 109270
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
109228: LD_ADDR_VAR 0 3
109232: PUSH
109233: LD_VAR 0 4
109237: PUSH
109238: LD_INT 1
109240: ARRAY
109241: PUSH
109242: LD_INT 1
109244: ARRAY
109245: PUSH
109246: LD_STRING r
109248: EQUAL
109249: PUSH
109250: LD_VAR 0 4
109254: PUSH
109255: LD_INT 1
109257: ARRAY
109258: PUSH
109259: LD_INT 4
109261: ARRAY
109262: PUSH
109263: LD_VAR 0 2
109267: EQUAL
109268: AND
109269: ST_TO_ADDR
// end ;
109270: LD_VAR 0 3
109274: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
109275: LD_INT 0
109277: PPUSH
// SetDir ( unit , d ) ;
109278: LD_VAR 0 1
109282: PPUSH
109283: LD_VAR 0 4
109287: PPUSH
109288: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
109292: LD_VAR 0 1
109296: PPUSH
109297: LD_VAR 0 2
109301: PPUSH
109302: LD_VAR 0 3
109306: PPUSH
109307: LD_VAR 0 5
109311: PPUSH
109312: CALL_OW 48
// end ;
109316: LD_VAR 0 6
109320: RET
// export function ToNaturalNumber ( number ) ; begin
109321: LD_INT 0
109323: PPUSH
// result := number div 1 ;
109324: LD_ADDR_VAR 0 2
109328: PUSH
109329: LD_VAR 0 1
109333: PUSH
109334: LD_INT 1
109336: DIV
109337: ST_TO_ADDR
// if number < 0 then
109338: LD_VAR 0 1
109342: PUSH
109343: LD_INT 0
109345: LESS
109346: IFFALSE 109356
// result := 0 ;
109348: LD_ADDR_VAR 0 2
109352: PUSH
109353: LD_INT 0
109355: ST_TO_ADDR
// end ;
109356: LD_VAR 0 2
109360: RET
// export function SortByClass ( units , class ) ; var un ; begin
109361: LD_INT 0
109363: PPUSH
109364: PPUSH
// if not units or not class then
109365: LD_VAR 0 1
109369: NOT
109370: PUSH
109371: LD_VAR 0 2
109375: NOT
109376: OR
109377: IFFALSE 109381
// exit ;
109379: GO 109476
// result := [ ] ;
109381: LD_ADDR_VAR 0 3
109385: PUSH
109386: EMPTY
109387: ST_TO_ADDR
// for un in units do
109388: LD_ADDR_VAR 0 4
109392: PUSH
109393: LD_VAR 0 1
109397: PUSH
109398: FOR_IN
109399: IFFALSE 109474
// if GetClass ( un ) = class then
109401: LD_VAR 0 4
109405: PPUSH
109406: CALL_OW 257
109410: PUSH
109411: LD_VAR 0 2
109415: EQUAL
109416: IFFALSE 109443
// result := Insert ( result , 1 , un ) else
109418: LD_ADDR_VAR 0 3
109422: PUSH
109423: LD_VAR 0 3
109427: PPUSH
109428: LD_INT 1
109430: PPUSH
109431: LD_VAR 0 4
109435: PPUSH
109436: CALL_OW 2
109440: ST_TO_ADDR
109441: GO 109472
// result := Replace ( result , result + 1 , un ) ;
109443: LD_ADDR_VAR 0 3
109447: PUSH
109448: LD_VAR 0 3
109452: PPUSH
109453: LD_VAR 0 3
109457: PUSH
109458: LD_INT 1
109460: PLUS
109461: PPUSH
109462: LD_VAR 0 4
109466: PPUSH
109467: CALL_OW 1
109471: ST_TO_ADDR
109472: GO 109398
109474: POP
109475: POP
// end ;
109476: LD_VAR 0 3
109480: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
109481: LD_INT 0
109483: PPUSH
109484: PPUSH
109485: PPUSH
109486: PPUSH
109487: PPUSH
109488: PPUSH
109489: PPUSH
// result := [ ] ;
109490: LD_ADDR_VAR 0 4
109494: PUSH
109495: EMPTY
109496: ST_TO_ADDR
// if x - r < 0 then
109497: LD_VAR 0 1
109501: PUSH
109502: LD_VAR 0 3
109506: MINUS
109507: PUSH
109508: LD_INT 0
109510: LESS
109511: IFFALSE 109523
// min_x := 0 else
109513: LD_ADDR_VAR 0 8
109517: PUSH
109518: LD_INT 0
109520: ST_TO_ADDR
109521: GO 109539
// min_x := x - r ;
109523: LD_ADDR_VAR 0 8
109527: PUSH
109528: LD_VAR 0 1
109532: PUSH
109533: LD_VAR 0 3
109537: MINUS
109538: ST_TO_ADDR
// if y - r < 0 then
109539: LD_VAR 0 2
109543: PUSH
109544: LD_VAR 0 3
109548: MINUS
109549: PUSH
109550: LD_INT 0
109552: LESS
109553: IFFALSE 109565
// min_y := 0 else
109555: LD_ADDR_VAR 0 7
109559: PUSH
109560: LD_INT 0
109562: ST_TO_ADDR
109563: GO 109581
// min_y := y - r ;
109565: LD_ADDR_VAR 0 7
109569: PUSH
109570: LD_VAR 0 2
109574: PUSH
109575: LD_VAR 0 3
109579: MINUS
109580: ST_TO_ADDR
// max_x := x + r ;
109581: LD_ADDR_VAR 0 9
109585: PUSH
109586: LD_VAR 0 1
109590: PUSH
109591: LD_VAR 0 3
109595: PLUS
109596: ST_TO_ADDR
// max_y := y + r ;
109597: LD_ADDR_VAR 0 10
109601: PUSH
109602: LD_VAR 0 2
109606: PUSH
109607: LD_VAR 0 3
109611: PLUS
109612: ST_TO_ADDR
// for _x = min_x to max_x do
109613: LD_ADDR_VAR 0 5
109617: PUSH
109618: DOUBLE
109619: LD_VAR 0 8
109623: DEC
109624: ST_TO_ADDR
109625: LD_VAR 0 9
109629: PUSH
109630: FOR_TO
109631: IFFALSE 109732
// for _y = min_y to max_y do
109633: LD_ADDR_VAR 0 6
109637: PUSH
109638: DOUBLE
109639: LD_VAR 0 7
109643: DEC
109644: ST_TO_ADDR
109645: LD_VAR 0 10
109649: PUSH
109650: FOR_TO
109651: IFFALSE 109728
// begin if not ValidHex ( _x , _y ) then
109653: LD_VAR 0 5
109657: PPUSH
109658: LD_VAR 0 6
109662: PPUSH
109663: CALL_OW 488
109667: NOT
109668: IFFALSE 109672
// continue ;
109670: GO 109650
// if GetResourceTypeXY ( _x , _y ) then
109672: LD_VAR 0 5
109676: PPUSH
109677: LD_VAR 0 6
109681: PPUSH
109682: CALL_OW 283
109686: IFFALSE 109726
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
109688: LD_ADDR_VAR 0 4
109692: PUSH
109693: LD_VAR 0 4
109697: PPUSH
109698: LD_VAR 0 4
109702: PUSH
109703: LD_INT 1
109705: PLUS
109706: PPUSH
109707: LD_VAR 0 5
109711: PUSH
109712: LD_VAR 0 6
109716: PUSH
109717: EMPTY
109718: LIST
109719: LIST
109720: PPUSH
109721: CALL_OW 1
109725: ST_TO_ADDR
// end ;
109726: GO 109650
109728: POP
109729: POP
109730: GO 109630
109732: POP
109733: POP
// end ;
109734: LD_VAR 0 4
109738: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
109739: LD_INT 0
109741: PPUSH
109742: PPUSH
109743: PPUSH
109744: PPUSH
109745: PPUSH
109746: PPUSH
109747: PPUSH
109748: PPUSH
// if not units then
109749: LD_VAR 0 1
109753: NOT
109754: IFFALSE 109758
// exit ;
109756: GO 110282
// result := UnitFilter ( units , [ f_ok ] ) ;
109758: LD_ADDR_VAR 0 3
109762: PUSH
109763: LD_VAR 0 1
109767: PPUSH
109768: LD_INT 50
109770: PUSH
109771: EMPTY
109772: LIST
109773: PPUSH
109774: CALL_OW 72
109778: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
109779: LD_ADDR_VAR 0 8
109783: PUSH
109784: LD_VAR 0 1
109788: PUSH
109789: LD_INT 1
109791: ARRAY
109792: PPUSH
109793: CALL_OW 255
109797: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
109798: LD_ADDR_VAR 0 10
109802: PUSH
109803: LD_INT 29
109805: PUSH
109806: LD_INT 91
109808: PUSH
109809: LD_INT 49
109811: PUSH
109812: EMPTY
109813: LIST
109814: LIST
109815: LIST
109816: ST_TO_ADDR
// if not result then
109817: LD_VAR 0 3
109821: NOT
109822: IFFALSE 109826
// exit ;
109824: GO 110282
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
109826: LD_ADDR_VAR 0 5
109830: PUSH
109831: LD_INT 81
109833: PUSH
109834: LD_VAR 0 8
109838: PUSH
109839: EMPTY
109840: LIST
109841: LIST
109842: PPUSH
109843: CALL_OW 69
109847: ST_TO_ADDR
// for i in result do
109848: LD_ADDR_VAR 0 4
109852: PUSH
109853: LD_VAR 0 3
109857: PUSH
109858: FOR_IN
109859: IFFALSE 110280
// begin tag := GetTag ( i ) + 1 ;
109861: LD_ADDR_VAR 0 9
109865: PUSH
109866: LD_VAR 0 4
109870: PPUSH
109871: CALL_OW 110
109875: PUSH
109876: LD_INT 1
109878: PLUS
109879: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
109880: LD_ADDR_VAR 0 7
109884: PUSH
109885: LD_VAR 0 4
109889: PPUSH
109890: CALL_OW 250
109894: PPUSH
109895: LD_VAR 0 4
109899: PPUSH
109900: CALL_OW 251
109904: PPUSH
109905: LD_INT 6
109907: PPUSH
109908: CALL 109481 0 3
109912: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
109913: LD_VAR 0 4
109917: PPUSH
109918: CALL_OW 247
109922: PUSH
109923: LD_INT 2
109925: EQUAL
109926: PUSH
109927: LD_VAR 0 7
109931: AND
109932: PUSH
109933: LD_VAR 0 4
109937: PPUSH
109938: CALL_OW 264
109942: PUSH
109943: LD_VAR 0 10
109947: IN
109948: NOT
109949: AND
109950: IFFALSE 109989
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
109952: LD_VAR 0 4
109956: PPUSH
109957: LD_VAR 0 7
109961: PUSH
109962: LD_INT 1
109964: ARRAY
109965: PUSH
109966: LD_INT 1
109968: ARRAY
109969: PPUSH
109970: LD_VAR 0 7
109974: PUSH
109975: LD_INT 1
109977: ARRAY
109978: PUSH
109979: LD_INT 2
109981: ARRAY
109982: PPUSH
109983: CALL_OW 116
109987: GO 110278
// if path > tag then
109989: LD_VAR 0 2
109993: PUSH
109994: LD_VAR 0 9
109998: GREATER
109999: IFFALSE 110207
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
110001: LD_ADDR_VAR 0 6
110005: PUSH
110006: LD_VAR 0 5
110010: PPUSH
110011: LD_INT 91
110013: PUSH
110014: LD_VAR 0 4
110018: PUSH
110019: LD_INT 8
110021: PUSH
110022: EMPTY
110023: LIST
110024: LIST
110025: LIST
110026: PPUSH
110027: CALL_OW 72
110031: ST_TO_ADDR
// if nearEnemy then
110032: LD_VAR 0 6
110036: IFFALSE 110105
// begin if GetWeapon ( i ) = ru_time_lapser then
110038: LD_VAR 0 4
110042: PPUSH
110043: CALL_OW 264
110047: PUSH
110048: LD_INT 49
110050: EQUAL
110051: IFFALSE 110079
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
110053: LD_VAR 0 4
110057: PPUSH
110058: LD_VAR 0 6
110062: PPUSH
110063: LD_VAR 0 4
110067: PPUSH
110068: CALL_OW 74
110072: PPUSH
110073: CALL_OW 112
110077: GO 110103
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
110079: LD_VAR 0 4
110083: PPUSH
110084: LD_VAR 0 6
110088: PPUSH
110089: LD_VAR 0 4
110093: PPUSH
110094: CALL_OW 74
110098: PPUSH
110099: CALL 111207 0 2
// end else
110103: GO 110205
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
110105: LD_VAR 0 4
110109: PPUSH
110110: LD_VAR 0 2
110114: PUSH
110115: LD_VAR 0 9
110119: ARRAY
110120: PUSH
110121: LD_INT 1
110123: ARRAY
110124: PPUSH
110125: LD_VAR 0 2
110129: PUSH
110130: LD_VAR 0 9
110134: ARRAY
110135: PUSH
110136: LD_INT 2
110138: ARRAY
110139: PPUSH
110140: CALL_OW 297
110144: PUSH
110145: LD_INT 6
110147: GREATER
110148: IFFALSE 110191
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
110150: LD_VAR 0 4
110154: PPUSH
110155: LD_VAR 0 2
110159: PUSH
110160: LD_VAR 0 9
110164: ARRAY
110165: PUSH
110166: LD_INT 1
110168: ARRAY
110169: PPUSH
110170: LD_VAR 0 2
110174: PUSH
110175: LD_VAR 0 9
110179: ARRAY
110180: PUSH
110181: LD_INT 2
110183: ARRAY
110184: PPUSH
110185: CALL_OW 114
110189: GO 110205
// SetTag ( i , tag ) ;
110191: LD_VAR 0 4
110195: PPUSH
110196: LD_VAR 0 9
110200: PPUSH
110201: CALL_OW 109
// end else
110205: GO 110278
// if enemy then
110207: LD_VAR 0 5
110211: IFFALSE 110278
// begin if GetWeapon ( i ) = ru_time_lapser then
110213: LD_VAR 0 4
110217: PPUSH
110218: CALL_OW 264
110222: PUSH
110223: LD_INT 49
110225: EQUAL
110226: IFFALSE 110254
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
110228: LD_VAR 0 4
110232: PPUSH
110233: LD_VAR 0 5
110237: PPUSH
110238: LD_VAR 0 4
110242: PPUSH
110243: CALL_OW 74
110247: PPUSH
110248: CALL_OW 112
110252: GO 110278
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
110254: LD_VAR 0 4
110258: PPUSH
110259: LD_VAR 0 5
110263: PPUSH
110264: LD_VAR 0 4
110268: PPUSH
110269: CALL_OW 74
110273: PPUSH
110274: CALL 111207 0 2
// end ; end ;
110278: GO 109858
110280: POP
110281: POP
// end ;
110282: LD_VAR 0 3
110286: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
110287: LD_INT 0
110289: PPUSH
110290: PPUSH
110291: PPUSH
// if not unit or IsInUnit ( unit ) then
110292: LD_VAR 0 1
110296: NOT
110297: PUSH
110298: LD_VAR 0 1
110302: PPUSH
110303: CALL_OW 310
110307: OR
110308: IFFALSE 110312
// exit ;
110310: GO 110403
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
110312: LD_ADDR_VAR 0 4
110316: PUSH
110317: LD_VAR 0 1
110321: PPUSH
110322: CALL_OW 250
110326: PPUSH
110327: LD_VAR 0 2
110331: PPUSH
110332: LD_INT 1
110334: PPUSH
110335: CALL_OW 272
110339: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
110340: LD_ADDR_VAR 0 5
110344: PUSH
110345: LD_VAR 0 1
110349: PPUSH
110350: CALL_OW 251
110354: PPUSH
110355: LD_VAR 0 2
110359: PPUSH
110360: LD_INT 1
110362: PPUSH
110363: CALL_OW 273
110367: ST_TO_ADDR
// if ValidHex ( x , y ) then
110368: LD_VAR 0 4
110372: PPUSH
110373: LD_VAR 0 5
110377: PPUSH
110378: CALL_OW 488
110382: IFFALSE 110403
// ComTurnXY ( unit , x , y ) ;
110384: LD_VAR 0 1
110388: PPUSH
110389: LD_VAR 0 4
110393: PPUSH
110394: LD_VAR 0 5
110398: PPUSH
110399: CALL_OW 118
// end ;
110403: LD_VAR 0 3
110407: RET
// export function SeeUnits ( side , units ) ; var i ; begin
110408: LD_INT 0
110410: PPUSH
110411: PPUSH
// result := false ;
110412: LD_ADDR_VAR 0 3
110416: PUSH
110417: LD_INT 0
110419: ST_TO_ADDR
// if not units then
110420: LD_VAR 0 2
110424: NOT
110425: IFFALSE 110429
// exit ;
110427: GO 110474
// for i in units do
110429: LD_ADDR_VAR 0 4
110433: PUSH
110434: LD_VAR 0 2
110438: PUSH
110439: FOR_IN
110440: IFFALSE 110472
// if See ( side , i ) then
110442: LD_VAR 0 1
110446: PPUSH
110447: LD_VAR 0 4
110451: PPUSH
110452: CALL_OW 292
110456: IFFALSE 110470
// begin result := true ;
110458: LD_ADDR_VAR 0 3
110462: PUSH
110463: LD_INT 1
110465: ST_TO_ADDR
// exit ;
110466: POP
110467: POP
110468: GO 110474
// end ;
110470: GO 110439
110472: POP
110473: POP
// end ;
110474: LD_VAR 0 3
110478: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
110479: LD_INT 0
110481: PPUSH
110482: PPUSH
110483: PPUSH
110484: PPUSH
// if not unit or not points then
110485: LD_VAR 0 1
110489: NOT
110490: PUSH
110491: LD_VAR 0 2
110495: NOT
110496: OR
110497: IFFALSE 110501
// exit ;
110499: GO 110591
// dist := 99999 ;
110501: LD_ADDR_VAR 0 5
110505: PUSH
110506: LD_INT 99999
110508: ST_TO_ADDR
// for i in points do
110509: LD_ADDR_VAR 0 4
110513: PUSH
110514: LD_VAR 0 2
110518: PUSH
110519: FOR_IN
110520: IFFALSE 110589
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
110522: LD_ADDR_VAR 0 6
110526: PUSH
110527: LD_VAR 0 1
110531: PPUSH
110532: LD_VAR 0 4
110536: PUSH
110537: LD_INT 1
110539: ARRAY
110540: PPUSH
110541: LD_VAR 0 4
110545: PUSH
110546: LD_INT 2
110548: ARRAY
110549: PPUSH
110550: CALL_OW 297
110554: ST_TO_ADDR
// if tmpDist < dist then
110555: LD_VAR 0 6
110559: PUSH
110560: LD_VAR 0 5
110564: LESS
110565: IFFALSE 110587
// begin result := i ;
110567: LD_ADDR_VAR 0 3
110571: PUSH
110572: LD_VAR 0 4
110576: ST_TO_ADDR
// dist := tmpDist ;
110577: LD_ADDR_VAR 0 5
110581: PUSH
110582: LD_VAR 0 6
110586: ST_TO_ADDR
// end ; end ;
110587: GO 110519
110589: POP
110590: POP
// end ;
110591: LD_VAR 0 3
110595: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
110596: LD_INT 0
110598: PPUSH
// uc_side := side ;
110599: LD_ADDR_OWVAR 20
110603: PUSH
110604: LD_VAR 0 1
110608: ST_TO_ADDR
// uc_nation := 3 ;
110609: LD_ADDR_OWVAR 21
110613: PUSH
110614: LD_INT 3
110616: ST_TO_ADDR
// vc_chassis := 25 ;
110617: LD_ADDR_OWVAR 37
110621: PUSH
110622: LD_INT 25
110624: ST_TO_ADDR
// vc_engine := engine_siberite ;
110625: LD_ADDR_OWVAR 39
110629: PUSH
110630: LD_INT 3
110632: ST_TO_ADDR
// vc_control := control_computer ;
110633: LD_ADDR_OWVAR 38
110637: PUSH
110638: LD_INT 3
110640: ST_TO_ADDR
// vc_weapon := 59 ;
110641: LD_ADDR_OWVAR 40
110645: PUSH
110646: LD_INT 59
110648: ST_TO_ADDR
// result := CreateVehicle ;
110649: LD_ADDR_VAR 0 5
110653: PUSH
110654: CALL_OW 45
110658: ST_TO_ADDR
// SetDir ( result , d ) ;
110659: LD_VAR 0 5
110663: PPUSH
110664: LD_VAR 0 4
110668: PPUSH
110669: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
110673: LD_VAR 0 5
110677: PPUSH
110678: LD_VAR 0 2
110682: PPUSH
110683: LD_VAR 0 3
110687: PPUSH
110688: LD_INT 0
110690: PPUSH
110691: CALL_OW 48
// end ;
110695: LD_VAR 0 5
110699: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
110700: LD_INT 0
110702: PPUSH
110703: PPUSH
110704: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
110705: LD_ADDR_VAR 0 2
110709: PUSH
110710: LD_INT 0
110712: PUSH
110713: LD_INT 0
110715: PUSH
110716: LD_INT 0
110718: PUSH
110719: LD_INT 0
110721: PUSH
110722: EMPTY
110723: LIST
110724: LIST
110725: LIST
110726: LIST
110727: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
110728: LD_VAR 0 1
110732: NOT
110733: PUSH
110734: LD_VAR 0 1
110738: PPUSH
110739: CALL_OW 264
110743: PUSH
110744: LD_INT 12
110746: PUSH
110747: LD_INT 51
110749: PUSH
110750: LD_INT 32
110752: PUSH
110753: LD_INT 89
110755: PUSH
110756: EMPTY
110757: LIST
110758: LIST
110759: LIST
110760: LIST
110761: IN
110762: NOT
110763: OR
110764: IFFALSE 110768
// exit ;
110766: GO 110866
// for i := 1 to 3 do
110768: LD_ADDR_VAR 0 3
110772: PUSH
110773: DOUBLE
110774: LD_INT 1
110776: DEC
110777: ST_TO_ADDR
110778: LD_INT 3
110780: PUSH
110781: FOR_TO
110782: IFFALSE 110864
// begin tmp := GetCargo ( cargo , i ) ;
110784: LD_ADDR_VAR 0 4
110788: PUSH
110789: LD_VAR 0 1
110793: PPUSH
110794: LD_VAR 0 3
110798: PPUSH
110799: CALL_OW 289
110803: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
110804: LD_ADDR_VAR 0 2
110808: PUSH
110809: LD_VAR 0 2
110813: PPUSH
110814: LD_VAR 0 3
110818: PPUSH
110819: LD_VAR 0 4
110823: PPUSH
110824: CALL_OW 1
110828: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
110829: LD_ADDR_VAR 0 2
110833: PUSH
110834: LD_VAR 0 2
110838: PPUSH
110839: LD_INT 4
110841: PPUSH
110842: LD_VAR 0 2
110846: PUSH
110847: LD_INT 4
110849: ARRAY
110850: PUSH
110851: LD_VAR 0 4
110855: PLUS
110856: PPUSH
110857: CALL_OW 1
110861: ST_TO_ADDR
// end ;
110862: GO 110781
110864: POP
110865: POP
// end ;
110866: LD_VAR 0 2
110870: RET
// export function Length ( array ) ; begin
110871: LD_INT 0
110873: PPUSH
// result := array + 0 ;
110874: LD_ADDR_VAR 0 2
110878: PUSH
110879: LD_VAR 0 1
110883: PUSH
110884: LD_INT 0
110886: PLUS
110887: ST_TO_ADDR
// end ;
110888: LD_VAR 0 2
110892: RET
// export function PrepareArray ( array ) ; begin
110893: LD_INT 0
110895: PPUSH
// result := array diff 0 ;
110896: LD_ADDR_VAR 0 2
110900: PUSH
110901: LD_VAR 0 1
110905: PUSH
110906: LD_INT 0
110908: DIFF
110909: ST_TO_ADDR
// if not result [ 1 ] then
110910: LD_VAR 0 2
110914: PUSH
110915: LD_INT 1
110917: ARRAY
110918: NOT
110919: IFFALSE 110939
// result := Delete ( result , 1 ) ;
110921: LD_ADDR_VAR 0 2
110925: PUSH
110926: LD_VAR 0 2
110930: PPUSH
110931: LD_INT 1
110933: PPUSH
110934: CALL_OW 3
110938: ST_TO_ADDR
// end ;
110939: LD_VAR 0 2
110943: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
110944: LD_INT 0
110946: PPUSH
110947: PPUSH
110948: PPUSH
110949: PPUSH
// sibRocketRange := 25 ;
110950: LD_ADDR_VAR 0 6
110954: PUSH
110955: LD_INT 25
110957: ST_TO_ADDR
// result := false ;
110958: LD_ADDR_VAR 0 4
110962: PUSH
110963: LD_INT 0
110965: ST_TO_ADDR
// for i := 0 to 5 do
110966: LD_ADDR_VAR 0 5
110970: PUSH
110971: DOUBLE
110972: LD_INT 0
110974: DEC
110975: ST_TO_ADDR
110976: LD_INT 5
110978: PUSH
110979: FOR_TO
110980: IFFALSE 111047
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
110982: LD_VAR 0 1
110986: PPUSH
110987: LD_VAR 0 5
110991: PPUSH
110992: LD_VAR 0 6
110996: PPUSH
110997: CALL_OW 272
111001: PPUSH
111002: LD_VAR 0 2
111006: PPUSH
111007: LD_VAR 0 5
111011: PPUSH
111012: LD_VAR 0 6
111016: PPUSH
111017: CALL_OW 273
111021: PPUSH
111022: LD_VAR 0 3
111026: PPUSH
111027: CALL_OW 309
111031: IFFALSE 111045
// begin result := true ;
111033: LD_ADDR_VAR 0 4
111037: PUSH
111038: LD_INT 1
111040: ST_TO_ADDR
// exit ;
111041: POP
111042: POP
111043: GO 111049
// end ;
111045: GO 110979
111047: POP
111048: POP
// end ;
111049: LD_VAR 0 4
111053: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
111054: LD_INT 0
111056: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
111057: LD_VAR 0 1
111061: PPUSH
111062: LD_VAR 0 2
111066: PPUSH
111067: LD_INT 0
111069: PPUSH
111070: LD_INT 0
111072: PPUSH
111073: LD_INT 1
111075: PPUSH
111076: LD_INT 0
111078: PPUSH
111079: CALL_OW 587
// end ;
111083: LD_VAR 0 3
111087: RET
// export function CenterOnNow ( unit ) ; begin
111088: LD_INT 0
111090: PPUSH
// result := IsInUnit ( unit ) ;
111091: LD_ADDR_VAR 0 2
111095: PUSH
111096: LD_VAR 0 1
111100: PPUSH
111101: CALL_OW 310
111105: ST_TO_ADDR
// if not result then
111106: LD_VAR 0 2
111110: NOT
111111: IFFALSE 111123
// result := unit ;
111113: LD_ADDR_VAR 0 2
111117: PUSH
111118: LD_VAR 0 1
111122: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
111123: LD_VAR 0 1
111127: PPUSH
111128: CALL_OW 87
// end ;
111132: LD_VAR 0 2
111136: RET
// export function ComMoveHex ( unit , hex ) ; begin
111137: LD_INT 0
111139: PPUSH
// if not hex then
111140: LD_VAR 0 2
111144: NOT
111145: IFFALSE 111149
// exit ;
111147: GO 111202
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
111149: LD_VAR 0 2
111153: PUSH
111154: LD_INT 1
111156: ARRAY
111157: PPUSH
111158: LD_VAR 0 2
111162: PUSH
111163: LD_INT 2
111165: ARRAY
111166: PPUSH
111167: CALL_OW 428
111171: IFFALSE 111175
// exit ;
111173: GO 111202
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
111175: LD_VAR 0 1
111179: PPUSH
111180: LD_VAR 0 2
111184: PUSH
111185: LD_INT 1
111187: ARRAY
111188: PPUSH
111189: LD_VAR 0 2
111193: PUSH
111194: LD_INT 2
111196: ARRAY
111197: PPUSH
111198: CALL_OW 111
// end ;
111202: LD_VAR 0 3
111206: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
111207: LD_INT 0
111209: PPUSH
111210: PPUSH
111211: PPUSH
// if not unit or not enemy then
111212: LD_VAR 0 1
111216: NOT
111217: PUSH
111218: LD_VAR 0 2
111222: NOT
111223: OR
111224: IFFALSE 111228
// exit ;
111226: GO 111352
// x := GetX ( enemy ) ;
111228: LD_ADDR_VAR 0 4
111232: PUSH
111233: LD_VAR 0 2
111237: PPUSH
111238: CALL_OW 250
111242: ST_TO_ADDR
// y := GetY ( enemy ) ;
111243: LD_ADDR_VAR 0 5
111247: PUSH
111248: LD_VAR 0 2
111252: PPUSH
111253: CALL_OW 251
111257: ST_TO_ADDR
// if ValidHex ( x , y ) then
111258: LD_VAR 0 4
111262: PPUSH
111263: LD_VAR 0 5
111267: PPUSH
111268: CALL_OW 488
111272: IFFALSE 111352
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
111274: LD_VAR 0 2
111278: PPUSH
111279: CALL_OW 247
111283: PUSH
111284: LD_INT 3
111286: PUSH
111287: LD_INT 2
111289: PUSH
111290: EMPTY
111291: LIST
111292: LIST
111293: IN
111294: PUSH
111295: LD_VAR 0 1
111299: PPUSH
111300: CALL_OW 255
111304: PPUSH
111305: LD_VAR 0 2
111309: PPUSH
111310: CALL_OW 292
111314: AND
111315: IFFALSE 111333
// ComAttackUnit ( unit , enemy ) else
111317: LD_VAR 0 1
111321: PPUSH
111322: LD_VAR 0 2
111326: PPUSH
111327: CALL_OW 115
111331: GO 111352
// ComAgressiveMove ( unit , x , y ) ;
111333: LD_VAR 0 1
111337: PPUSH
111338: LD_VAR 0 4
111342: PPUSH
111343: LD_VAR 0 5
111347: PPUSH
111348: CALL_OW 114
// end ;
111352: LD_VAR 0 3
111356: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
111357: LD_INT 0
111359: PPUSH
111360: PPUSH
111361: PPUSH
// list := AreaToList ( area , 0 ) ;
111362: LD_ADDR_VAR 0 5
111366: PUSH
111367: LD_VAR 0 1
111371: PPUSH
111372: LD_INT 0
111374: PPUSH
111375: CALL_OW 517
111379: ST_TO_ADDR
// if not list then
111380: LD_VAR 0 5
111384: NOT
111385: IFFALSE 111389
// exit ;
111387: GO 111519
// if all then
111389: LD_VAR 0 2
111393: IFFALSE 111481
// begin for i := 1 to list [ 1 ] do
111395: LD_ADDR_VAR 0 4
111399: PUSH
111400: DOUBLE
111401: LD_INT 1
111403: DEC
111404: ST_TO_ADDR
111405: LD_VAR 0 5
111409: PUSH
111410: LD_INT 1
111412: ARRAY
111413: PUSH
111414: FOR_TO
111415: IFFALSE 111477
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
111417: LD_ADDR_VAR 0 3
111421: PUSH
111422: LD_VAR 0 3
111426: PPUSH
111427: LD_VAR 0 3
111431: PUSH
111432: LD_INT 1
111434: PLUS
111435: PPUSH
111436: LD_VAR 0 5
111440: PUSH
111441: LD_INT 1
111443: ARRAY
111444: PUSH
111445: LD_VAR 0 4
111449: ARRAY
111450: PUSH
111451: LD_VAR 0 5
111455: PUSH
111456: LD_INT 2
111458: ARRAY
111459: PUSH
111460: LD_VAR 0 4
111464: ARRAY
111465: PUSH
111466: EMPTY
111467: LIST
111468: LIST
111469: PPUSH
111470: CALL_OW 1
111474: ST_TO_ADDR
111475: GO 111414
111477: POP
111478: POP
// exit ;
111479: GO 111519
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
111481: LD_ADDR_VAR 0 3
111485: PUSH
111486: LD_VAR 0 5
111490: PUSH
111491: LD_INT 1
111493: ARRAY
111494: PUSH
111495: LD_INT 1
111497: ARRAY
111498: PUSH
111499: LD_VAR 0 5
111503: PUSH
111504: LD_INT 2
111506: ARRAY
111507: PUSH
111508: LD_INT 1
111510: ARRAY
111511: PUSH
111512: EMPTY
111513: LIST
111514: LIST
111515: PUSH
111516: EMPTY
111517: LIST
111518: ST_TO_ADDR
// end ;
111519: LD_VAR 0 3
111523: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
111524: LD_INT 0
111526: PPUSH
111527: PPUSH
// list := AreaToList ( area , 0 ) ;
111528: LD_ADDR_VAR 0 4
111532: PUSH
111533: LD_VAR 0 1
111537: PPUSH
111538: LD_INT 0
111540: PPUSH
111541: CALL_OW 517
111545: ST_TO_ADDR
// if not list then
111546: LD_VAR 0 4
111550: NOT
111551: IFFALSE 111555
// exit ;
111553: GO 111596
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
111555: LD_ADDR_VAR 0 3
111559: PUSH
111560: LD_VAR 0 4
111564: PUSH
111565: LD_INT 1
111567: ARRAY
111568: PUSH
111569: LD_INT 1
111571: ARRAY
111572: PUSH
111573: LD_VAR 0 4
111577: PUSH
111578: LD_INT 2
111580: ARRAY
111581: PUSH
111582: LD_INT 1
111584: ARRAY
111585: PUSH
111586: LD_VAR 0 2
111590: PUSH
111591: EMPTY
111592: LIST
111593: LIST
111594: LIST
111595: ST_TO_ADDR
// end ;
111596: LD_VAR 0 3
111600: RET
// export function First ( array ) ; begin
111601: LD_INT 0
111603: PPUSH
// if not array then
111604: LD_VAR 0 1
111608: NOT
111609: IFFALSE 111613
// exit ;
111611: GO 111627
// result := array [ 1 ] ;
111613: LD_ADDR_VAR 0 2
111617: PUSH
111618: LD_VAR 0 1
111622: PUSH
111623: LD_INT 1
111625: ARRAY
111626: ST_TO_ADDR
// end ;
111627: LD_VAR 0 2
111631: RET
// export function Last ( array ) ; begin
111632: LD_INT 0
111634: PPUSH
// if not array then
111635: LD_VAR 0 1
111639: NOT
111640: IFFALSE 111644
// exit ;
111642: GO 111660
// result := array [ array ] ;
111644: LD_ADDR_VAR 0 2
111648: PUSH
111649: LD_VAR 0 1
111653: PUSH
111654: LD_VAR 0 1
111658: ARRAY
111659: ST_TO_ADDR
// end ;
111660: LD_VAR 0 2
111664: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
111665: LD_INT 0
111667: PPUSH
111668: PPUSH
// result := [ ] ;
111669: LD_ADDR_VAR 0 5
111673: PUSH
111674: EMPTY
111675: ST_TO_ADDR
// if not array then
111676: LD_VAR 0 1
111680: NOT
111681: IFFALSE 111685
// exit ;
111683: GO 111797
// for i := 1 to array do
111685: LD_ADDR_VAR 0 6
111689: PUSH
111690: DOUBLE
111691: LD_INT 1
111693: DEC
111694: ST_TO_ADDR
111695: LD_VAR 0 1
111699: PUSH
111700: FOR_TO
111701: IFFALSE 111795
// if array [ i ] [ index ] = value then
111703: LD_VAR 0 1
111707: PUSH
111708: LD_VAR 0 6
111712: ARRAY
111713: PUSH
111714: LD_VAR 0 2
111718: ARRAY
111719: PUSH
111720: LD_VAR 0 3
111724: EQUAL
111725: IFFALSE 111793
// begin if indexColumn then
111727: LD_VAR 0 4
111731: IFFALSE 111767
// result := Join ( result , array [ i ] [ indexColumn ] ) else
111733: LD_ADDR_VAR 0 5
111737: PUSH
111738: LD_VAR 0 5
111742: PPUSH
111743: LD_VAR 0 1
111747: PUSH
111748: LD_VAR 0 6
111752: ARRAY
111753: PUSH
111754: LD_VAR 0 4
111758: ARRAY
111759: PPUSH
111760: CALL 107135 0 2
111764: ST_TO_ADDR
111765: GO 111793
// result := Join ( result , array [ i ] ) ;
111767: LD_ADDR_VAR 0 5
111771: PUSH
111772: LD_VAR 0 5
111776: PPUSH
111777: LD_VAR 0 1
111781: PUSH
111782: LD_VAR 0 6
111786: ARRAY
111787: PPUSH
111788: CALL 107135 0 2
111792: ST_TO_ADDR
// end ;
111793: GO 111700
111795: POP
111796: POP
// end ;
111797: LD_VAR 0 5
111801: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
111802: LD_INT 0
111804: PPUSH
111805: PPUSH
111806: PPUSH
// if btype = b_depot then
111807: LD_VAR 0 2
111811: PUSH
111812: LD_INT 0
111814: EQUAL
111815: IFFALSE 111827
// begin result := true ;
111817: LD_ADDR_VAR 0 3
111821: PUSH
111822: LD_INT 1
111824: ST_TO_ADDR
// exit ;
111825: GO 111943
// end ; pom := GetBase ( depot ) ;
111827: LD_ADDR_VAR 0 4
111831: PUSH
111832: LD_VAR 0 1
111836: PPUSH
111837: CALL_OW 274
111841: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
111842: LD_ADDR_VAR 0 5
111846: PUSH
111847: LD_VAR 0 2
111851: PPUSH
111852: LD_VAR 0 1
111856: PPUSH
111857: CALL_OW 248
111861: PPUSH
111862: CALL_OW 450
111866: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
111867: LD_ADDR_VAR 0 3
111871: PUSH
111872: LD_VAR 0 4
111876: PPUSH
111877: LD_INT 1
111879: PPUSH
111880: CALL_OW 275
111884: PUSH
111885: LD_VAR 0 5
111889: PUSH
111890: LD_INT 1
111892: ARRAY
111893: GREATEREQUAL
111894: PUSH
111895: LD_VAR 0 4
111899: PPUSH
111900: LD_INT 2
111902: PPUSH
111903: CALL_OW 275
111907: PUSH
111908: LD_VAR 0 5
111912: PUSH
111913: LD_INT 2
111915: ARRAY
111916: GREATEREQUAL
111917: AND
111918: PUSH
111919: LD_VAR 0 4
111923: PPUSH
111924: LD_INT 3
111926: PPUSH
111927: CALL_OW 275
111931: PUSH
111932: LD_VAR 0 5
111936: PUSH
111937: LD_INT 3
111939: ARRAY
111940: GREATEREQUAL
111941: AND
111942: ST_TO_ADDR
// end ;
111943: LD_VAR 0 3
111947: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
111948: LD_INT 0
111950: PPUSH
// if not vehicles or not parkingPoint then
111951: LD_VAR 0 1
111955: NOT
111956: PUSH
111957: LD_VAR 0 2
111961: NOT
111962: OR
111963: IFFALSE 111967
// exit ;
111965: GO 112065
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
111967: LD_ADDR_VAR 0 1
111971: PUSH
111972: LD_VAR 0 1
111976: PPUSH
111977: LD_INT 50
111979: PUSH
111980: EMPTY
111981: LIST
111982: PUSH
111983: LD_INT 3
111985: PUSH
111986: LD_INT 92
111988: PUSH
111989: LD_VAR 0 2
111993: PUSH
111994: LD_INT 1
111996: ARRAY
111997: PUSH
111998: LD_VAR 0 2
112002: PUSH
112003: LD_INT 2
112005: ARRAY
112006: PUSH
112007: LD_INT 8
112009: PUSH
112010: EMPTY
112011: LIST
112012: LIST
112013: LIST
112014: LIST
112015: PUSH
112016: EMPTY
112017: LIST
112018: LIST
112019: PUSH
112020: EMPTY
112021: LIST
112022: LIST
112023: PPUSH
112024: CALL_OW 72
112028: ST_TO_ADDR
// if not vehicles then
112029: LD_VAR 0 1
112033: NOT
112034: IFFALSE 112038
// exit ;
112036: GO 112065
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
112038: LD_VAR 0 1
112042: PPUSH
112043: LD_VAR 0 2
112047: PUSH
112048: LD_INT 1
112050: ARRAY
112051: PPUSH
112052: LD_VAR 0 2
112056: PUSH
112057: LD_INT 2
112059: ARRAY
112060: PPUSH
112061: CALL_OW 111
// end ; end_of_file end_of_file
112065: LD_VAR 0 3
112069: RET
// export globalGameSaveCounter ; every 0 0$1 do
112070: GO 112072
112072: DISABLE
// begin enable ;
112073: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
112074: LD_STRING updateTimer(
112076: PUSH
112077: LD_OWVAR 1
112081: STR
112082: PUSH
112083: LD_STRING );
112085: STR
112086: PPUSH
112087: CALL_OW 559
// end ;
112091: END
// every 0 0$1 do
112092: GO 112094
112094: DISABLE
// begin globalGameSaveCounter := 0 ;
112095: LD_ADDR_EXP 146
112099: PUSH
112100: LD_INT 0
112102: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
112103: LD_STRING setGameSaveCounter(0)
112105: PPUSH
112106: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
112110: LD_STRING initStreamRollete();
112112: PPUSH
112113: CALL_OW 559
// InitStreamMode ;
112117: CALL 113443 0 0
// DefineStreamItems ( false ) ;
112121: LD_INT 0
112123: PPUSH
112124: CALL 113907 0 1
// end ;
112128: END
// export function SOS_MapStart ( ) ; begin
112129: LD_INT 0
112131: PPUSH
// if streamModeActive then
112132: LD_EXP 147
112136: IFFALSE 112145
// DefineStreamItems ( true ) ;
112138: LD_INT 1
112140: PPUSH
112141: CALL 113907 0 1
// UpdateLuaVariables ( ) ;
112145: CALL 112162 0 0
// UpdateFactoryWaypoints ( ) ;
112149: CALL 126776 0 0
// UpdateWarehouseGatheringPoints ( ) ;
112153: CALL 127033 0 0
// end ;
112157: LD_VAR 0 1
112161: RET
// function UpdateLuaVariables ( ) ; begin
112162: LD_INT 0
112164: PPUSH
// if globalGameSaveCounter then
112165: LD_EXP 146
112169: IFFALSE 112203
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
112171: LD_ADDR_EXP 146
112175: PUSH
112176: LD_EXP 146
112180: PPUSH
112181: CALL 108496 0 1
112185: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
112186: LD_STRING setGameSaveCounter(
112188: PUSH
112189: LD_EXP 146
112193: STR
112194: PUSH
112195: LD_STRING )
112197: STR
112198: PPUSH
112199: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
112203: LD_STRING setGameDifficulty(
112205: PUSH
112206: LD_OWVAR 67
112210: STR
112211: PUSH
112212: LD_STRING )
112214: STR
112215: PPUSH
112216: CALL_OW 559
// end ;
112220: LD_VAR 0 1
112224: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
112225: LD_INT 0
112227: PPUSH
// if p2 = stream_mode then
112228: LD_VAR 0 2
112232: PUSH
112233: LD_INT 100
112235: EQUAL
112236: IFFALSE 113239
// begin if not StreamModeActive then
112238: LD_EXP 147
112242: NOT
112243: IFFALSE 112253
// StreamModeActive := true ;
112245: LD_ADDR_EXP 147
112249: PUSH
112250: LD_INT 1
112252: ST_TO_ADDR
// if p3 = 0 then
112253: LD_VAR 0 3
112257: PUSH
112258: LD_INT 0
112260: EQUAL
112261: IFFALSE 112267
// InitStreamMode ;
112263: CALL 113443 0 0
// if p3 = 1 then
112267: LD_VAR 0 3
112271: PUSH
112272: LD_INT 1
112274: EQUAL
112275: IFFALSE 112285
// sRocket := true ;
112277: LD_ADDR_EXP 152
112281: PUSH
112282: LD_INT 1
112284: ST_TO_ADDR
// if p3 = 2 then
112285: LD_VAR 0 3
112289: PUSH
112290: LD_INT 2
112292: EQUAL
112293: IFFALSE 112303
// sSpeed := true ;
112295: LD_ADDR_EXP 151
112299: PUSH
112300: LD_INT 1
112302: ST_TO_ADDR
// if p3 = 3 then
112303: LD_VAR 0 3
112307: PUSH
112308: LD_INT 3
112310: EQUAL
112311: IFFALSE 112321
// sEngine := true ;
112313: LD_ADDR_EXP 153
112317: PUSH
112318: LD_INT 1
112320: ST_TO_ADDR
// if p3 = 4 then
112321: LD_VAR 0 3
112325: PUSH
112326: LD_INT 4
112328: EQUAL
112329: IFFALSE 112339
// sSpec := true ;
112331: LD_ADDR_EXP 150
112335: PUSH
112336: LD_INT 1
112338: ST_TO_ADDR
// if p3 = 5 then
112339: LD_VAR 0 3
112343: PUSH
112344: LD_INT 5
112346: EQUAL
112347: IFFALSE 112357
// sLevel := true ;
112349: LD_ADDR_EXP 154
112353: PUSH
112354: LD_INT 1
112356: ST_TO_ADDR
// if p3 = 6 then
112357: LD_VAR 0 3
112361: PUSH
112362: LD_INT 6
112364: EQUAL
112365: IFFALSE 112375
// sArmoury := true ;
112367: LD_ADDR_EXP 155
112371: PUSH
112372: LD_INT 1
112374: ST_TO_ADDR
// if p3 = 7 then
112375: LD_VAR 0 3
112379: PUSH
112380: LD_INT 7
112382: EQUAL
112383: IFFALSE 112393
// sRadar := true ;
112385: LD_ADDR_EXP 156
112389: PUSH
112390: LD_INT 1
112392: ST_TO_ADDR
// if p3 = 8 then
112393: LD_VAR 0 3
112397: PUSH
112398: LD_INT 8
112400: EQUAL
112401: IFFALSE 112411
// sBunker := true ;
112403: LD_ADDR_EXP 157
112407: PUSH
112408: LD_INT 1
112410: ST_TO_ADDR
// if p3 = 9 then
112411: LD_VAR 0 3
112415: PUSH
112416: LD_INT 9
112418: EQUAL
112419: IFFALSE 112429
// sHack := true ;
112421: LD_ADDR_EXP 158
112425: PUSH
112426: LD_INT 1
112428: ST_TO_ADDR
// if p3 = 10 then
112429: LD_VAR 0 3
112433: PUSH
112434: LD_INT 10
112436: EQUAL
112437: IFFALSE 112447
// sFire := true ;
112439: LD_ADDR_EXP 159
112443: PUSH
112444: LD_INT 1
112446: ST_TO_ADDR
// if p3 = 11 then
112447: LD_VAR 0 3
112451: PUSH
112452: LD_INT 11
112454: EQUAL
112455: IFFALSE 112465
// sRefresh := true ;
112457: LD_ADDR_EXP 160
112461: PUSH
112462: LD_INT 1
112464: ST_TO_ADDR
// if p3 = 12 then
112465: LD_VAR 0 3
112469: PUSH
112470: LD_INT 12
112472: EQUAL
112473: IFFALSE 112483
// sExp := true ;
112475: LD_ADDR_EXP 161
112479: PUSH
112480: LD_INT 1
112482: ST_TO_ADDR
// if p3 = 13 then
112483: LD_VAR 0 3
112487: PUSH
112488: LD_INT 13
112490: EQUAL
112491: IFFALSE 112501
// sDepot := true ;
112493: LD_ADDR_EXP 162
112497: PUSH
112498: LD_INT 1
112500: ST_TO_ADDR
// if p3 = 14 then
112501: LD_VAR 0 3
112505: PUSH
112506: LD_INT 14
112508: EQUAL
112509: IFFALSE 112519
// sFlag := true ;
112511: LD_ADDR_EXP 163
112515: PUSH
112516: LD_INT 1
112518: ST_TO_ADDR
// if p3 = 15 then
112519: LD_VAR 0 3
112523: PUSH
112524: LD_INT 15
112526: EQUAL
112527: IFFALSE 112537
// sKamikadze := true ;
112529: LD_ADDR_EXP 171
112533: PUSH
112534: LD_INT 1
112536: ST_TO_ADDR
// if p3 = 16 then
112537: LD_VAR 0 3
112541: PUSH
112542: LD_INT 16
112544: EQUAL
112545: IFFALSE 112555
// sTroll := true ;
112547: LD_ADDR_EXP 172
112551: PUSH
112552: LD_INT 1
112554: ST_TO_ADDR
// if p3 = 17 then
112555: LD_VAR 0 3
112559: PUSH
112560: LD_INT 17
112562: EQUAL
112563: IFFALSE 112573
// sSlow := true ;
112565: LD_ADDR_EXP 173
112569: PUSH
112570: LD_INT 1
112572: ST_TO_ADDR
// if p3 = 18 then
112573: LD_VAR 0 3
112577: PUSH
112578: LD_INT 18
112580: EQUAL
112581: IFFALSE 112591
// sLack := true ;
112583: LD_ADDR_EXP 174
112587: PUSH
112588: LD_INT 1
112590: ST_TO_ADDR
// if p3 = 19 then
112591: LD_VAR 0 3
112595: PUSH
112596: LD_INT 19
112598: EQUAL
112599: IFFALSE 112609
// sTank := true ;
112601: LD_ADDR_EXP 176
112605: PUSH
112606: LD_INT 1
112608: ST_TO_ADDR
// if p3 = 20 then
112609: LD_VAR 0 3
112613: PUSH
112614: LD_INT 20
112616: EQUAL
112617: IFFALSE 112627
// sRemote := true ;
112619: LD_ADDR_EXP 177
112623: PUSH
112624: LD_INT 1
112626: ST_TO_ADDR
// if p3 = 21 then
112627: LD_VAR 0 3
112631: PUSH
112632: LD_INT 21
112634: EQUAL
112635: IFFALSE 112645
// sPowell := true ;
112637: LD_ADDR_EXP 178
112641: PUSH
112642: LD_INT 1
112644: ST_TO_ADDR
// if p3 = 22 then
112645: LD_VAR 0 3
112649: PUSH
112650: LD_INT 22
112652: EQUAL
112653: IFFALSE 112663
// sTeleport := true ;
112655: LD_ADDR_EXP 181
112659: PUSH
112660: LD_INT 1
112662: ST_TO_ADDR
// if p3 = 23 then
112663: LD_VAR 0 3
112667: PUSH
112668: LD_INT 23
112670: EQUAL
112671: IFFALSE 112681
// sOilTower := true ;
112673: LD_ADDR_EXP 183
112677: PUSH
112678: LD_INT 1
112680: ST_TO_ADDR
// if p3 = 24 then
112681: LD_VAR 0 3
112685: PUSH
112686: LD_INT 24
112688: EQUAL
112689: IFFALSE 112699
// sShovel := true ;
112691: LD_ADDR_EXP 184
112695: PUSH
112696: LD_INT 1
112698: ST_TO_ADDR
// if p3 = 25 then
112699: LD_VAR 0 3
112703: PUSH
112704: LD_INT 25
112706: EQUAL
112707: IFFALSE 112717
// sSheik := true ;
112709: LD_ADDR_EXP 185
112713: PUSH
112714: LD_INT 1
112716: ST_TO_ADDR
// if p3 = 26 then
112717: LD_VAR 0 3
112721: PUSH
112722: LD_INT 26
112724: EQUAL
112725: IFFALSE 112735
// sEarthquake := true ;
112727: LD_ADDR_EXP 187
112731: PUSH
112732: LD_INT 1
112734: ST_TO_ADDR
// if p3 = 27 then
112735: LD_VAR 0 3
112739: PUSH
112740: LD_INT 27
112742: EQUAL
112743: IFFALSE 112753
// sAI := true ;
112745: LD_ADDR_EXP 188
112749: PUSH
112750: LD_INT 1
112752: ST_TO_ADDR
// if p3 = 28 then
112753: LD_VAR 0 3
112757: PUSH
112758: LD_INT 28
112760: EQUAL
112761: IFFALSE 112771
// sCargo := true ;
112763: LD_ADDR_EXP 191
112767: PUSH
112768: LD_INT 1
112770: ST_TO_ADDR
// if p3 = 29 then
112771: LD_VAR 0 3
112775: PUSH
112776: LD_INT 29
112778: EQUAL
112779: IFFALSE 112789
// sDLaser := true ;
112781: LD_ADDR_EXP 192
112785: PUSH
112786: LD_INT 1
112788: ST_TO_ADDR
// if p3 = 30 then
112789: LD_VAR 0 3
112793: PUSH
112794: LD_INT 30
112796: EQUAL
112797: IFFALSE 112807
// sExchange := true ;
112799: LD_ADDR_EXP 193
112803: PUSH
112804: LD_INT 1
112806: ST_TO_ADDR
// if p3 = 31 then
112807: LD_VAR 0 3
112811: PUSH
112812: LD_INT 31
112814: EQUAL
112815: IFFALSE 112825
// sFac := true ;
112817: LD_ADDR_EXP 194
112821: PUSH
112822: LD_INT 1
112824: ST_TO_ADDR
// if p3 = 32 then
112825: LD_VAR 0 3
112829: PUSH
112830: LD_INT 32
112832: EQUAL
112833: IFFALSE 112843
// sPower := true ;
112835: LD_ADDR_EXP 195
112839: PUSH
112840: LD_INT 1
112842: ST_TO_ADDR
// if p3 = 33 then
112843: LD_VAR 0 3
112847: PUSH
112848: LD_INT 33
112850: EQUAL
112851: IFFALSE 112861
// sRandom := true ;
112853: LD_ADDR_EXP 196
112857: PUSH
112858: LD_INT 1
112860: ST_TO_ADDR
// if p3 = 34 then
112861: LD_VAR 0 3
112865: PUSH
112866: LD_INT 34
112868: EQUAL
112869: IFFALSE 112879
// sShield := true ;
112871: LD_ADDR_EXP 197
112875: PUSH
112876: LD_INT 1
112878: ST_TO_ADDR
// if p3 = 35 then
112879: LD_VAR 0 3
112883: PUSH
112884: LD_INT 35
112886: EQUAL
112887: IFFALSE 112897
// sTime := true ;
112889: LD_ADDR_EXP 198
112893: PUSH
112894: LD_INT 1
112896: ST_TO_ADDR
// if p3 = 36 then
112897: LD_VAR 0 3
112901: PUSH
112902: LD_INT 36
112904: EQUAL
112905: IFFALSE 112915
// sTools := true ;
112907: LD_ADDR_EXP 199
112911: PUSH
112912: LD_INT 1
112914: ST_TO_ADDR
// if p3 = 101 then
112915: LD_VAR 0 3
112919: PUSH
112920: LD_INT 101
112922: EQUAL
112923: IFFALSE 112933
// sSold := true ;
112925: LD_ADDR_EXP 164
112929: PUSH
112930: LD_INT 1
112932: ST_TO_ADDR
// if p3 = 102 then
112933: LD_VAR 0 3
112937: PUSH
112938: LD_INT 102
112940: EQUAL
112941: IFFALSE 112951
// sDiff := true ;
112943: LD_ADDR_EXP 165
112947: PUSH
112948: LD_INT 1
112950: ST_TO_ADDR
// if p3 = 103 then
112951: LD_VAR 0 3
112955: PUSH
112956: LD_INT 103
112958: EQUAL
112959: IFFALSE 112969
// sFog := true ;
112961: LD_ADDR_EXP 168
112965: PUSH
112966: LD_INT 1
112968: ST_TO_ADDR
// if p3 = 104 then
112969: LD_VAR 0 3
112973: PUSH
112974: LD_INT 104
112976: EQUAL
112977: IFFALSE 112987
// sReset := true ;
112979: LD_ADDR_EXP 169
112983: PUSH
112984: LD_INT 1
112986: ST_TO_ADDR
// if p3 = 105 then
112987: LD_VAR 0 3
112991: PUSH
112992: LD_INT 105
112994: EQUAL
112995: IFFALSE 113005
// sSun := true ;
112997: LD_ADDR_EXP 170
113001: PUSH
113002: LD_INT 1
113004: ST_TO_ADDR
// if p3 = 106 then
113005: LD_VAR 0 3
113009: PUSH
113010: LD_INT 106
113012: EQUAL
113013: IFFALSE 113023
// sTiger := true ;
113015: LD_ADDR_EXP 166
113019: PUSH
113020: LD_INT 1
113022: ST_TO_ADDR
// if p3 = 107 then
113023: LD_VAR 0 3
113027: PUSH
113028: LD_INT 107
113030: EQUAL
113031: IFFALSE 113041
// sBomb := true ;
113033: LD_ADDR_EXP 167
113037: PUSH
113038: LD_INT 1
113040: ST_TO_ADDR
// if p3 = 108 then
113041: LD_VAR 0 3
113045: PUSH
113046: LD_INT 108
113048: EQUAL
113049: IFFALSE 113059
// sWound := true ;
113051: LD_ADDR_EXP 175
113055: PUSH
113056: LD_INT 1
113058: ST_TO_ADDR
// if p3 = 109 then
113059: LD_VAR 0 3
113063: PUSH
113064: LD_INT 109
113066: EQUAL
113067: IFFALSE 113077
// sBetray := true ;
113069: LD_ADDR_EXP 179
113073: PUSH
113074: LD_INT 1
113076: ST_TO_ADDR
// if p3 = 110 then
113077: LD_VAR 0 3
113081: PUSH
113082: LD_INT 110
113084: EQUAL
113085: IFFALSE 113095
// sContamin := true ;
113087: LD_ADDR_EXP 180
113091: PUSH
113092: LD_INT 1
113094: ST_TO_ADDR
// if p3 = 111 then
113095: LD_VAR 0 3
113099: PUSH
113100: LD_INT 111
113102: EQUAL
113103: IFFALSE 113113
// sOil := true ;
113105: LD_ADDR_EXP 182
113109: PUSH
113110: LD_INT 1
113112: ST_TO_ADDR
// if p3 = 112 then
113113: LD_VAR 0 3
113117: PUSH
113118: LD_INT 112
113120: EQUAL
113121: IFFALSE 113131
// sStu := true ;
113123: LD_ADDR_EXP 186
113127: PUSH
113128: LD_INT 1
113130: ST_TO_ADDR
// if p3 = 113 then
113131: LD_VAR 0 3
113135: PUSH
113136: LD_INT 113
113138: EQUAL
113139: IFFALSE 113149
// sBazooka := true ;
113141: LD_ADDR_EXP 189
113145: PUSH
113146: LD_INT 1
113148: ST_TO_ADDR
// if p3 = 114 then
113149: LD_VAR 0 3
113153: PUSH
113154: LD_INT 114
113156: EQUAL
113157: IFFALSE 113167
// sMortar := true ;
113159: LD_ADDR_EXP 190
113163: PUSH
113164: LD_INT 1
113166: ST_TO_ADDR
// if p3 = 115 then
113167: LD_VAR 0 3
113171: PUSH
113172: LD_INT 115
113174: EQUAL
113175: IFFALSE 113185
// sRanger := true ;
113177: LD_ADDR_EXP 200
113181: PUSH
113182: LD_INT 1
113184: ST_TO_ADDR
// if p3 = 116 then
113185: LD_VAR 0 3
113189: PUSH
113190: LD_INT 116
113192: EQUAL
113193: IFFALSE 113203
// sComputer := true ;
113195: LD_ADDR_EXP 201
113199: PUSH
113200: LD_INT 1
113202: ST_TO_ADDR
// if p3 = 117 then
113203: LD_VAR 0 3
113207: PUSH
113208: LD_INT 117
113210: EQUAL
113211: IFFALSE 113221
// s30 := true ;
113213: LD_ADDR_EXP 202
113217: PUSH
113218: LD_INT 1
113220: ST_TO_ADDR
// if p3 = 118 then
113221: LD_VAR 0 3
113225: PUSH
113226: LD_INT 118
113228: EQUAL
113229: IFFALSE 113239
// s60 := true ;
113231: LD_ADDR_EXP 203
113235: PUSH
113236: LD_INT 1
113238: ST_TO_ADDR
// end ; if p2 = hack_mode then
113239: LD_VAR 0 2
113243: PUSH
113244: LD_INT 101
113246: EQUAL
113247: IFFALSE 113375
// begin case p3 of 1 :
113249: LD_VAR 0 3
113253: PUSH
113254: LD_INT 1
113256: DOUBLE
113257: EQUAL
113258: IFTRUE 113262
113260: GO 113269
113262: POP
// hHackUnlimitedResources ; 2 :
113263: CALL 125522 0 0
113267: GO 113375
113269: LD_INT 2
113271: DOUBLE
113272: EQUAL
113273: IFTRUE 113277
113275: GO 113284
113277: POP
// hHackSetLevel10 ; 3 :
113278: CALL 125655 0 0
113282: GO 113375
113284: LD_INT 3
113286: DOUBLE
113287: EQUAL
113288: IFTRUE 113292
113290: GO 113299
113292: POP
// hHackSetLevel10YourUnits ; 4 :
113293: CALL 125740 0 0
113297: GO 113375
113299: LD_INT 4
113301: DOUBLE
113302: EQUAL
113303: IFTRUE 113307
113305: GO 113314
113307: POP
// hHackInvincible ; 5 :
113308: CALL 126188 0 0
113312: GO 113375
113314: LD_INT 5
113316: DOUBLE
113317: EQUAL
113318: IFTRUE 113322
113320: GO 113329
113322: POP
// hHackInvisible ; 6 :
113323: CALL 126299 0 0
113327: GO 113375
113329: LD_INT 6
113331: DOUBLE
113332: EQUAL
113333: IFTRUE 113337
113335: GO 113344
113337: POP
// hHackChangeYourSide ; 7 :
113338: CALL 126356 0 0
113342: GO 113375
113344: LD_INT 7
113346: DOUBLE
113347: EQUAL
113348: IFTRUE 113352
113350: GO 113359
113352: POP
// hHackChangeUnitSide ; 8 :
113353: CALL 126398 0 0
113357: GO 113375
113359: LD_INT 8
113361: DOUBLE
113362: EQUAL
113363: IFTRUE 113367
113365: GO 113374
113367: POP
// hHackFog ; end ;
113368: CALL 126499 0 0
113372: GO 113375
113374: POP
// end ; if p2 = game_save_mode then
113375: LD_VAR 0 2
113379: PUSH
113380: LD_INT 102
113382: EQUAL
113383: IFFALSE 113438
// begin if p3 = 1 then
113385: LD_VAR 0 3
113389: PUSH
113390: LD_INT 1
113392: EQUAL
113393: IFFALSE 113405
// globalGameSaveCounter := p4 ;
113395: LD_ADDR_EXP 146
113399: PUSH
113400: LD_VAR 0 4
113404: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
113405: LD_VAR 0 3
113409: PUSH
113410: LD_INT 2
113412: EQUAL
113413: PUSH
113414: LD_EXP 146
113418: AND
113419: IFFALSE 113438
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
113421: LD_STRING setGameSaveCounter(
113423: PUSH
113424: LD_EXP 146
113428: STR
113429: PUSH
113430: LD_STRING )
113432: STR
113433: PPUSH
113434: CALL_OW 559
// end ; end ;
113438: LD_VAR 0 7
113442: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
113443: LD_INT 0
113445: PPUSH
// streamModeActive := false ;
113446: LD_ADDR_EXP 147
113450: PUSH
113451: LD_INT 0
113453: ST_TO_ADDR
// normalCounter := 36 ;
113454: LD_ADDR_EXP 148
113458: PUSH
113459: LD_INT 36
113461: ST_TO_ADDR
// hardcoreCounter := 18 ;
113462: LD_ADDR_EXP 149
113466: PUSH
113467: LD_INT 18
113469: ST_TO_ADDR
// sRocket := false ;
113470: LD_ADDR_EXP 152
113474: PUSH
113475: LD_INT 0
113477: ST_TO_ADDR
// sSpeed := false ;
113478: LD_ADDR_EXP 151
113482: PUSH
113483: LD_INT 0
113485: ST_TO_ADDR
// sEngine := false ;
113486: LD_ADDR_EXP 153
113490: PUSH
113491: LD_INT 0
113493: ST_TO_ADDR
// sSpec := false ;
113494: LD_ADDR_EXP 150
113498: PUSH
113499: LD_INT 0
113501: ST_TO_ADDR
// sLevel := false ;
113502: LD_ADDR_EXP 154
113506: PUSH
113507: LD_INT 0
113509: ST_TO_ADDR
// sArmoury := false ;
113510: LD_ADDR_EXP 155
113514: PUSH
113515: LD_INT 0
113517: ST_TO_ADDR
// sRadar := false ;
113518: LD_ADDR_EXP 156
113522: PUSH
113523: LD_INT 0
113525: ST_TO_ADDR
// sBunker := false ;
113526: LD_ADDR_EXP 157
113530: PUSH
113531: LD_INT 0
113533: ST_TO_ADDR
// sHack := false ;
113534: LD_ADDR_EXP 158
113538: PUSH
113539: LD_INT 0
113541: ST_TO_ADDR
// sFire := false ;
113542: LD_ADDR_EXP 159
113546: PUSH
113547: LD_INT 0
113549: ST_TO_ADDR
// sRefresh := false ;
113550: LD_ADDR_EXP 160
113554: PUSH
113555: LD_INT 0
113557: ST_TO_ADDR
// sExp := false ;
113558: LD_ADDR_EXP 161
113562: PUSH
113563: LD_INT 0
113565: ST_TO_ADDR
// sDepot := false ;
113566: LD_ADDR_EXP 162
113570: PUSH
113571: LD_INT 0
113573: ST_TO_ADDR
// sFlag := false ;
113574: LD_ADDR_EXP 163
113578: PUSH
113579: LD_INT 0
113581: ST_TO_ADDR
// sKamikadze := false ;
113582: LD_ADDR_EXP 171
113586: PUSH
113587: LD_INT 0
113589: ST_TO_ADDR
// sTroll := false ;
113590: LD_ADDR_EXP 172
113594: PUSH
113595: LD_INT 0
113597: ST_TO_ADDR
// sSlow := false ;
113598: LD_ADDR_EXP 173
113602: PUSH
113603: LD_INT 0
113605: ST_TO_ADDR
// sLack := false ;
113606: LD_ADDR_EXP 174
113610: PUSH
113611: LD_INT 0
113613: ST_TO_ADDR
// sTank := false ;
113614: LD_ADDR_EXP 176
113618: PUSH
113619: LD_INT 0
113621: ST_TO_ADDR
// sRemote := false ;
113622: LD_ADDR_EXP 177
113626: PUSH
113627: LD_INT 0
113629: ST_TO_ADDR
// sPowell := false ;
113630: LD_ADDR_EXP 178
113634: PUSH
113635: LD_INT 0
113637: ST_TO_ADDR
// sTeleport := false ;
113638: LD_ADDR_EXP 181
113642: PUSH
113643: LD_INT 0
113645: ST_TO_ADDR
// sOilTower := false ;
113646: LD_ADDR_EXP 183
113650: PUSH
113651: LD_INT 0
113653: ST_TO_ADDR
// sShovel := false ;
113654: LD_ADDR_EXP 184
113658: PUSH
113659: LD_INT 0
113661: ST_TO_ADDR
// sSheik := false ;
113662: LD_ADDR_EXP 185
113666: PUSH
113667: LD_INT 0
113669: ST_TO_ADDR
// sEarthquake := false ;
113670: LD_ADDR_EXP 187
113674: PUSH
113675: LD_INT 0
113677: ST_TO_ADDR
// sAI := false ;
113678: LD_ADDR_EXP 188
113682: PUSH
113683: LD_INT 0
113685: ST_TO_ADDR
// sCargo := false ;
113686: LD_ADDR_EXP 191
113690: PUSH
113691: LD_INT 0
113693: ST_TO_ADDR
// sDLaser := false ;
113694: LD_ADDR_EXP 192
113698: PUSH
113699: LD_INT 0
113701: ST_TO_ADDR
// sExchange := false ;
113702: LD_ADDR_EXP 193
113706: PUSH
113707: LD_INT 0
113709: ST_TO_ADDR
// sFac := false ;
113710: LD_ADDR_EXP 194
113714: PUSH
113715: LD_INT 0
113717: ST_TO_ADDR
// sPower := false ;
113718: LD_ADDR_EXP 195
113722: PUSH
113723: LD_INT 0
113725: ST_TO_ADDR
// sRandom := false ;
113726: LD_ADDR_EXP 196
113730: PUSH
113731: LD_INT 0
113733: ST_TO_ADDR
// sShield := false ;
113734: LD_ADDR_EXP 197
113738: PUSH
113739: LD_INT 0
113741: ST_TO_ADDR
// sTime := false ;
113742: LD_ADDR_EXP 198
113746: PUSH
113747: LD_INT 0
113749: ST_TO_ADDR
// sTools := false ;
113750: LD_ADDR_EXP 199
113754: PUSH
113755: LD_INT 0
113757: ST_TO_ADDR
// sSold := false ;
113758: LD_ADDR_EXP 164
113762: PUSH
113763: LD_INT 0
113765: ST_TO_ADDR
// sDiff := false ;
113766: LD_ADDR_EXP 165
113770: PUSH
113771: LD_INT 0
113773: ST_TO_ADDR
// sFog := false ;
113774: LD_ADDR_EXP 168
113778: PUSH
113779: LD_INT 0
113781: ST_TO_ADDR
// sReset := false ;
113782: LD_ADDR_EXP 169
113786: PUSH
113787: LD_INT 0
113789: ST_TO_ADDR
// sSun := false ;
113790: LD_ADDR_EXP 170
113794: PUSH
113795: LD_INT 0
113797: ST_TO_ADDR
// sTiger := false ;
113798: LD_ADDR_EXP 166
113802: PUSH
113803: LD_INT 0
113805: ST_TO_ADDR
// sBomb := false ;
113806: LD_ADDR_EXP 167
113810: PUSH
113811: LD_INT 0
113813: ST_TO_ADDR
// sWound := false ;
113814: LD_ADDR_EXP 175
113818: PUSH
113819: LD_INT 0
113821: ST_TO_ADDR
// sBetray := false ;
113822: LD_ADDR_EXP 179
113826: PUSH
113827: LD_INT 0
113829: ST_TO_ADDR
// sContamin := false ;
113830: LD_ADDR_EXP 180
113834: PUSH
113835: LD_INT 0
113837: ST_TO_ADDR
// sOil := false ;
113838: LD_ADDR_EXP 182
113842: PUSH
113843: LD_INT 0
113845: ST_TO_ADDR
// sStu := false ;
113846: LD_ADDR_EXP 186
113850: PUSH
113851: LD_INT 0
113853: ST_TO_ADDR
// sBazooka := false ;
113854: LD_ADDR_EXP 189
113858: PUSH
113859: LD_INT 0
113861: ST_TO_ADDR
// sMortar := false ;
113862: LD_ADDR_EXP 190
113866: PUSH
113867: LD_INT 0
113869: ST_TO_ADDR
// sRanger := false ;
113870: LD_ADDR_EXP 200
113874: PUSH
113875: LD_INT 0
113877: ST_TO_ADDR
// sComputer := false ;
113878: LD_ADDR_EXP 201
113882: PUSH
113883: LD_INT 0
113885: ST_TO_ADDR
// s30 := false ;
113886: LD_ADDR_EXP 202
113890: PUSH
113891: LD_INT 0
113893: ST_TO_ADDR
// s60 := false ;
113894: LD_ADDR_EXP 203
113898: PUSH
113899: LD_INT 0
113901: ST_TO_ADDR
// end ;
113902: LD_VAR 0 1
113906: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
113907: LD_INT 0
113909: PPUSH
113910: PPUSH
113911: PPUSH
113912: PPUSH
113913: PPUSH
113914: PPUSH
113915: PPUSH
// result := [ ] ;
113916: LD_ADDR_VAR 0 2
113920: PUSH
113921: EMPTY
113922: ST_TO_ADDR
// if campaign_id = 1 then
113923: LD_OWVAR 69
113927: PUSH
113928: LD_INT 1
113930: EQUAL
113931: IFFALSE 117097
// begin case mission_number of 1 :
113933: LD_OWVAR 70
113937: PUSH
113938: LD_INT 1
113940: DOUBLE
113941: EQUAL
113942: IFTRUE 113946
113944: GO 114022
113946: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
113947: LD_ADDR_VAR 0 2
113951: PUSH
113952: LD_INT 2
113954: PUSH
113955: LD_INT 4
113957: PUSH
113958: LD_INT 11
113960: PUSH
113961: LD_INT 12
113963: PUSH
113964: LD_INT 15
113966: PUSH
113967: LD_INT 16
113969: PUSH
113970: LD_INT 22
113972: PUSH
113973: LD_INT 23
113975: PUSH
113976: LD_INT 26
113978: PUSH
113979: EMPTY
113980: LIST
113981: LIST
113982: LIST
113983: LIST
113984: LIST
113985: LIST
113986: LIST
113987: LIST
113988: LIST
113989: PUSH
113990: LD_INT 101
113992: PUSH
113993: LD_INT 102
113995: PUSH
113996: LD_INT 106
113998: PUSH
113999: LD_INT 116
114001: PUSH
114002: LD_INT 117
114004: PUSH
114005: LD_INT 118
114007: PUSH
114008: EMPTY
114009: LIST
114010: LIST
114011: LIST
114012: LIST
114013: LIST
114014: LIST
114015: PUSH
114016: EMPTY
114017: LIST
114018: LIST
114019: ST_TO_ADDR
114020: GO 117095
114022: LD_INT 2
114024: DOUBLE
114025: EQUAL
114026: IFTRUE 114030
114028: GO 114114
114030: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
114031: LD_ADDR_VAR 0 2
114035: PUSH
114036: LD_INT 2
114038: PUSH
114039: LD_INT 4
114041: PUSH
114042: LD_INT 11
114044: PUSH
114045: LD_INT 12
114047: PUSH
114048: LD_INT 15
114050: PUSH
114051: LD_INT 16
114053: PUSH
114054: LD_INT 22
114056: PUSH
114057: LD_INT 23
114059: PUSH
114060: LD_INT 26
114062: PUSH
114063: EMPTY
114064: LIST
114065: LIST
114066: LIST
114067: LIST
114068: LIST
114069: LIST
114070: LIST
114071: LIST
114072: LIST
114073: PUSH
114074: LD_INT 101
114076: PUSH
114077: LD_INT 102
114079: PUSH
114080: LD_INT 105
114082: PUSH
114083: LD_INT 106
114085: PUSH
114086: LD_INT 108
114088: PUSH
114089: LD_INT 116
114091: PUSH
114092: LD_INT 117
114094: PUSH
114095: LD_INT 118
114097: PUSH
114098: EMPTY
114099: LIST
114100: LIST
114101: LIST
114102: LIST
114103: LIST
114104: LIST
114105: LIST
114106: LIST
114107: PUSH
114108: EMPTY
114109: LIST
114110: LIST
114111: ST_TO_ADDR
114112: GO 117095
114114: LD_INT 3
114116: DOUBLE
114117: EQUAL
114118: IFTRUE 114122
114120: GO 114210
114122: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
114123: LD_ADDR_VAR 0 2
114127: PUSH
114128: LD_INT 2
114130: PUSH
114131: LD_INT 4
114133: PUSH
114134: LD_INT 5
114136: PUSH
114137: LD_INT 11
114139: PUSH
114140: LD_INT 12
114142: PUSH
114143: LD_INT 15
114145: PUSH
114146: LD_INT 16
114148: PUSH
114149: LD_INT 22
114151: PUSH
114152: LD_INT 26
114154: PUSH
114155: LD_INT 36
114157: PUSH
114158: EMPTY
114159: LIST
114160: LIST
114161: LIST
114162: LIST
114163: LIST
114164: LIST
114165: LIST
114166: LIST
114167: LIST
114168: LIST
114169: PUSH
114170: LD_INT 101
114172: PUSH
114173: LD_INT 102
114175: PUSH
114176: LD_INT 105
114178: PUSH
114179: LD_INT 106
114181: PUSH
114182: LD_INT 108
114184: PUSH
114185: LD_INT 116
114187: PUSH
114188: LD_INT 117
114190: PUSH
114191: LD_INT 118
114193: PUSH
114194: EMPTY
114195: LIST
114196: LIST
114197: LIST
114198: LIST
114199: LIST
114200: LIST
114201: LIST
114202: LIST
114203: PUSH
114204: EMPTY
114205: LIST
114206: LIST
114207: ST_TO_ADDR
114208: GO 117095
114210: LD_INT 4
114212: DOUBLE
114213: EQUAL
114214: IFTRUE 114218
114216: GO 114314
114218: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
114219: LD_ADDR_VAR 0 2
114223: PUSH
114224: LD_INT 2
114226: PUSH
114227: LD_INT 4
114229: PUSH
114230: LD_INT 5
114232: PUSH
114233: LD_INT 8
114235: PUSH
114236: LD_INT 11
114238: PUSH
114239: LD_INT 12
114241: PUSH
114242: LD_INT 15
114244: PUSH
114245: LD_INT 16
114247: PUSH
114248: LD_INT 22
114250: PUSH
114251: LD_INT 23
114253: PUSH
114254: LD_INT 26
114256: PUSH
114257: LD_INT 36
114259: PUSH
114260: EMPTY
114261: LIST
114262: LIST
114263: LIST
114264: LIST
114265: LIST
114266: LIST
114267: LIST
114268: LIST
114269: LIST
114270: LIST
114271: LIST
114272: LIST
114273: PUSH
114274: LD_INT 101
114276: PUSH
114277: LD_INT 102
114279: PUSH
114280: LD_INT 105
114282: PUSH
114283: LD_INT 106
114285: PUSH
114286: LD_INT 108
114288: PUSH
114289: LD_INT 116
114291: PUSH
114292: LD_INT 117
114294: PUSH
114295: LD_INT 118
114297: PUSH
114298: EMPTY
114299: LIST
114300: LIST
114301: LIST
114302: LIST
114303: LIST
114304: LIST
114305: LIST
114306: LIST
114307: PUSH
114308: EMPTY
114309: LIST
114310: LIST
114311: ST_TO_ADDR
114312: GO 117095
114314: LD_INT 5
114316: DOUBLE
114317: EQUAL
114318: IFTRUE 114322
114320: GO 114434
114322: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
114323: LD_ADDR_VAR 0 2
114327: PUSH
114328: LD_INT 2
114330: PUSH
114331: LD_INT 4
114333: PUSH
114334: LD_INT 5
114336: PUSH
114337: LD_INT 6
114339: PUSH
114340: LD_INT 8
114342: PUSH
114343: LD_INT 11
114345: PUSH
114346: LD_INT 12
114348: PUSH
114349: LD_INT 15
114351: PUSH
114352: LD_INT 16
114354: PUSH
114355: LD_INT 22
114357: PUSH
114358: LD_INT 23
114360: PUSH
114361: LD_INT 25
114363: PUSH
114364: LD_INT 26
114366: PUSH
114367: LD_INT 36
114369: PUSH
114370: EMPTY
114371: LIST
114372: LIST
114373: LIST
114374: LIST
114375: LIST
114376: LIST
114377: LIST
114378: LIST
114379: LIST
114380: LIST
114381: LIST
114382: LIST
114383: LIST
114384: LIST
114385: PUSH
114386: LD_INT 101
114388: PUSH
114389: LD_INT 102
114391: PUSH
114392: LD_INT 105
114394: PUSH
114395: LD_INT 106
114397: PUSH
114398: LD_INT 108
114400: PUSH
114401: LD_INT 109
114403: PUSH
114404: LD_INT 112
114406: PUSH
114407: LD_INT 116
114409: PUSH
114410: LD_INT 117
114412: PUSH
114413: LD_INT 118
114415: PUSH
114416: EMPTY
114417: LIST
114418: LIST
114419: LIST
114420: LIST
114421: LIST
114422: LIST
114423: LIST
114424: LIST
114425: LIST
114426: LIST
114427: PUSH
114428: EMPTY
114429: LIST
114430: LIST
114431: ST_TO_ADDR
114432: GO 117095
114434: LD_INT 6
114436: DOUBLE
114437: EQUAL
114438: IFTRUE 114442
114440: GO 114574
114442: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
114443: LD_ADDR_VAR 0 2
114447: PUSH
114448: LD_INT 2
114450: PUSH
114451: LD_INT 4
114453: PUSH
114454: LD_INT 5
114456: PUSH
114457: LD_INT 6
114459: PUSH
114460: LD_INT 8
114462: PUSH
114463: LD_INT 11
114465: PUSH
114466: LD_INT 12
114468: PUSH
114469: LD_INT 15
114471: PUSH
114472: LD_INT 16
114474: PUSH
114475: LD_INT 20
114477: PUSH
114478: LD_INT 21
114480: PUSH
114481: LD_INT 22
114483: PUSH
114484: LD_INT 23
114486: PUSH
114487: LD_INT 25
114489: PUSH
114490: LD_INT 26
114492: PUSH
114493: LD_INT 30
114495: PUSH
114496: LD_INT 31
114498: PUSH
114499: LD_INT 32
114501: PUSH
114502: LD_INT 36
114504: PUSH
114505: EMPTY
114506: LIST
114507: LIST
114508: LIST
114509: LIST
114510: LIST
114511: LIST
114512: LIST
114513: LIST
114514: LIST
114515: LIST
114516: LIST
114517: LIST
114518: LIST
114519: LIST
114520: LIST
114521: LIST
114522: LIST
114523: LIST
114524: LIST
114525: PUSH
114526: LD_INT 101
114528: PUSH
114529: LD_INT 102
114531: PUSH
114532: LD_INT 105
114534: PUSH
114535: LD_INT 106
114537: PUSH
114538: LD_INT 108
114540: PUSH
114541: LD_INT 109
114543: PUSH
114544: LD_INT 112
114546: PUSH
114547: LD_INT 116
114549: PUSH
114550: LD_INT 117
114552: PUSH
114553: LD_INT 118
114555: PUSH
114556: EMPTY
114557: LIST
114558: LIST
114559: LIST
114560: LIST
114561: LIST
114562: LIST
114563: LIST
114564: LIST
114565: LIST
114566: LIST
114567: PUSH
114568: EMPTY
114569: LIST
114570: LIST
114571: ST_TO_ADDR
114572: GO 117095
114574: LD_INT 7
114576: DOUBLE
114577: EQUAL
114578: IFTRUE 114582
114580: GO 114694
114582: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
114583: LD_ADDR_VAR 0 2
114587: PUSH
114588: LD_INT 2
114590: PUSH
114591: LD_INT 4
114593: PUSH
114594: LD_INT 5
114596: PUSH
114597: LD_INT 7
114599: PUSH
114600: LD_INT 11
114602: PUSH
114603: LD_INT 12
114605: PUSH
114606: LD_INT 15
114608: PUSH
114609: LD_INT 16
114611: PUSH
114612: LD_INT 20
114614: PUSH
114615: LD_INT 21
114617: PUSH
114618: LD_INT 22
114620: PUSH
114621: LD_INT 23
114623: PUSH
114624: LD_INT 25
114626: PUSH
114627: LD_INT 26
114629: PUSH
114630: EMPTY
114631: LIST
114632: LIST
114633: LIST
114634: LIST
114635: LIST
114636: LIST
114637: LIST
114638: LIST
114639: LIST
114640: LIST
114641: LIST
114642: LIST
114643: LIST
114644: LIST
114645: PUSH
114646: LD_INT 101
114648: PUSH
114649: LD_INT 102
114651: PUSH
114652: LD_INT 103
114654: PUSH
114655: LD_INT 105
114657: PUSH
114658: LD_INT 106
114660: PUSH
114661: LD_INT 108
114663: PUSH
114664: LD_INT 112
114666: PUSH
114667: LD_INT 116
114669: PUSH
114670: LD_INT 117
114672: PUSH
114673: LD_INT 118
114675: PUSH
114676: EMPTY
114677: LIST
114678: LIST
114679: LIST
114680: LIST
114681: LIST
114682: LIST
114683: LIST
114684: LIST
114685: LIST
114686: LIST
114687: PUSH
114688: EMPTY
114689: LIST
114690: LIST
114691: ST_TO_ADDR
114692: GO 117095
114694: LD_INT 8
114696: DOUBLE
114697: EQUAL
114698: IFTRUE 114702
114700: GO 114842
114702: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
114703: LD_ADDR_VAR 0 2
114707: PUSH
114708: LD_INT 2
114710: PUSH
114711: LD_INT 4
114713: PUSH
114714: LD_INT 5
114716: PUSH
114717: LD_INT 6
114719: PUSH
114720: LD_INT 7
114722: PUSH
114723: LD_INT 8
114725: PUSH
114726: LD_INT 11
114728: PUSH
114729: LD_INT 12
114731: PUSH
114732: LD_INT 15
114734: PUSH
114735: LD_INT 16
114737: PUSH
114738: LD_INT 20
114740: PUSH
114741: LD_INT 21
114743: PUSH
114744: LD_INT 22
114746: PUSH
114747: LD_INT 23
114749: PUSH
114750: LD_INT 25
114752: PUSH
114753: LD_INT 26
114755: PUSH
114756: LD_INT 30
114758: PUSH
114759: LD_INT 31
114761: PUSH
114762: LD_INT 32
114764: PUSH
114765: LD_INT 36
114767: PUSH
114768: EMPTY
114769: LIST
114770: LIST
114771: LIST
114772: LIST
114773: LIST
114774: LIST
114775: LIST
114776: LIST
114777: LIST
114778: LIST
114779: LIST
114780: LIST
114781: LIST
114782: LIST
114783: LIST
114784: LIST
114785: LIST
114786: LIST
114787: LIST
114788: LIST
114789: PUSH
114790: LD_INT 101
114792: PUSH
114793: LD_INT 102
114795: PUSH
114796: LD_INT 103
114798: PUSH
114799: LD_INT 105
114801: PUSH
114802: LD_INT 106
114804: PUSH
114805: LD_INT 108
114807: PUSH
114808: LD_INT 109
114810: PUSH
114811: LD_INT 112
114813: PUSH
114814: LD_INT 116
114816: PUSH
114817: LD_INT 117
114819: PUSH
114820: LD_INT 118
114822: PUSH
114823: EMPTY
114824: LIST
114825: LIST
114826: LIST
114827: LIST
114828: LIST
114829: LIST
114830: LIST
114831: LIST
114832: LIST
114833: LIST
114834: LIST
114835: PUSH
114836: EMPTY
114837: LIST
114838: LIST
114839: ST_TO_ADDR
114840: GO 117095
114842: LD_INT 9
114844: DOUBLE
114845: EQUAL
114846: IFTRUE 114850
114848: GO 114998
114850: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
114851: LD_ADDR_VAR 0 2
114855: PUSH
114856: LD_INT 2
114858: PUSH
114859: LD_INT 4
114861: PUSH
114862: LD_INT 5
114864: PUSH
114865: LD_INT 6
114867: PUSH
114868: LD_INT 7
114870: PUSH
114871: LD_INT 8
114873: PUSH
114874: LD_INT 11
114876: PUSH
114877: LD_INT 12
114879: PUSH
114880: LD_INT 15
114882: PUSH
114883: LD_INT 16
114885: PUSH
114886: LD_INT 20
114888: PUSH
114889: LD_INT 21
114891: PUSH
114892: LD_INT 22
114894: PUSH
114895: LD_INT 23
114897: PUSH
114898: LD_INT 25
114900: PUSH
114901: LD_INT 26
114903: PUSH
114904: LD_INT 28
114906: PUSH
114907: LD_INT 30
114909: PUSH
114910: LD_INT 31
114912: PUSH
114913: LD_INT 32
114915: PUSH
114916: LD_INT 36
114918: PUSH
114919: EMPTY
114920: LIST
114921: LIST
114922: LIST
114923: LIST
114924: LIST
114925: LIST
114926: LIST
114927: LIST
114928: LIST
114929: LIST
114930: LIST
114931: LIST
114932: LIST
114933: LIST
114934: LIST
114935: LIST
114936: LIST
114937: LIST
114938: LIST
114939: LIST
114940: LIST
114941: PUSH
114942: LD_INT 101
114944: PUSH
114945: LD_INT 102
114947: PUSH
114948: LD_INT 103
114950: PUSH
114951: LD_INT 105
114953: PUSH
114954: LD_INT 106
114956: PUSH
114957: LD_INT 108
114959: PUSH
114960: LD_INT 109
114962: PUSH
114963: LD_INT 112
114965: PUSH
114966: LD_INT 114
114968: PUSH
114969: LD_INT 116
114971: PUSH
114972: LD_INT 117
114974: PUSH
114975: LD_INT 118
114977: PUSH
114978: EMPTY
114979: LIST
114980: LIST
114981: LIST
114982: LIST
114983: LIST
114984: LIST
114985: LIST
114986: LIST
114987: LIST
114988: LIST
114989: LIST
114990: LIST
114991: PUSH
114992: EMPTY
114993: LIST
114994: LIST
114995: ST_TO_ADDR
114996: GO 117095
114998: LD_INT 10
115000: DOUBLE
115001: EQUAL
115002: IFTRUE 115006
115004: GO 115202
115006: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
115007: LD_ADDR_VAR 0 2
115011: PUSH
115012: LD_INT 2
115014: PUSH
115015: LD_INT 4
115017: PUSH
115018: LD_INT 5
115020: PUSH
115021: LD_INT 6
115023: PUSH
115024: LD_INT 7
115026: PUSH
115027: LD_INT 8
115029: PUSH
115030: LD_INT 9
115032: PUSH
115033: LD_INT 10
115035: PUSH
115036: LD_INT 11
115038: PUSH
115039: LD_INT 12
115041: PUSH
115042: LD_INT 13
115044: PUSH
115045: LD_INT 14
115047: PUSH
115048: LD_INT 15
115050: PUSH
115051: LD_INT 16
115053: PUSH
115054: LD_INT 17
115056: PUSH
115057: LD_INT 18
115059: PUSH
115060: LD_INT 19
115062: PUSH
115063: LD_INT 20
115065: PUSH
115066: LD_INT 21
115068: PUSH
115069: LD_INT 22
115071: PUSH
115072: LD_INT 23
115074: PUSH
115075: LD_INT 24
115077: PUSH
115078: LD_INT 25
115080: PUSH
115081: LD_INT 26
115083: PUSH
115084: LD_INT 28
115086: PUSH
115087: LD_INT 30
115089: PUSH
115090: LD_INT 31
115092: PUSH
115093: LD_INT 32
115095: PUSH
115096: LD_INT 36
115098: PUSH
115099: EMPTY
115100: LIST
115101: LIST
115102: LIST
115103: LIST
115104: LIST
115105: LIST
115106: LIST
115107: LIST
115108: LIST
115109: LIST
115110: LIST
115111: LIST
115112: LIST
115113: LIST
115114: LIST
115115: LIST
115116: LIST
115117: LIST
115118: LIST
115119: LIST
115120: LIST
115121: LIST
115122: LIST
115123: LIST
115124: LIST
115125: LIST
115126: LIST
115127: LIST
115128: LIST
115129: PUSH
115130: LD_INT 101
115132: PUSH
115133: LD_INT 102
115135: PUSH
115136: LD_INT 103
115138: PUSH
115139: LD_INT 104
115141: PUSH
115142: LD_INT 105
115144: PUSH
115145: LD_INT 106
115147: PUSH
115148: LD_INT 107
115150: PUSH
115151: LD_INT 108
115153: PUSH
115154: LD_INT 109
115156: PUSH
115157: LD_INT 110
115159: PUSH
115160: LD_INT 111
115162: PUSH
115163: LD_INT 112
115165: PUSH
115166: LD_INT 114
115168: PUSH
115169: LD_INT 116
115171: PUSH
115172: LD_INT 117
115174: PUSH
115175: LD_INT 118
115177: PUSH
115178: EMPTY
115179: LIST
115180: LIST
115181: LIST
115182: LIST
115183: LIST
115184: LIST
115185: LIST
115186: LIST
115187: LIST
115188: LIST
115189: LIST
115190: LIST
115191: LIST
115192: LIST
115193: LIST
115194: LIST
115195: PUSH
115196: EMPTY
115197: LIST
115198: LIST
115199: ST_TO_ADDR
115200: GO 117095
115202: LD_INT 11
115204: DOUBLE
115205: EQUAL
115206: IFTRUE 115210
115208: GO 115414
115210: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
115211: LD_ADDR_VAR 0 2
115215: PUSH
115216: LD_INT 2
115218: PUSH
115219: LD_INT 3
115221: PUSH
115222: LD_INT 4
115224: PUSH
115225: LD_INT 5
115227: PUSH
115228: LD_INT 6
115230: PUSH
115231: LD_INT 7
115233: PUSH
115234: LD_INT 8
115236: PUSH
115237: LD_INT 9
115239: PUSH
115240: LD_INT 10
115242: PUSH
115243: LD_INT 11
115245: PUSH
115246: LD_INT 12
115248: PUSH
115249: LD_INT 13
115251: PUSH
115252: LD_INT 14
115254: PUSH
115255: LD_INT 15
115257: PUSH
115258: LD_INT 16
115260: PUSH
115261: LD_INT 17
115263: PUSH
115264: LD_INT 18
115266: PUSH
115267: LD_INT 19
115269: PUSH
115270: LD_INT 20
115272: PUSH
115273: LD_INT 21
115275: PUSH
115276: LD_INT 22
115278: PUSH
115279: LD_INT 23
115281: PUSH
115282: LD_INT 24
115284: PUSH
115285: LD_INT 25
115287: PUSH
115288: LD_INT 26
115290: PUSH
115291: LD_INT 28
115293: PUSH
115294: LD_INT 30
115296: PUSH
115297: LD_INT 31
115299: PUSH
115300: LD_INT 32
115302: PUSH
115303: LD_INT 34
115305: PUSH
115306: LD_INT 36
115308: PUSH
115309: EMPTY
115310: LIST
115311: LIST
115312: LIST
115313: LIST
115314: LIST
115315: LIST
115316: LIST
115317: LIST
115318: LIST
115319: LIST
115320: LIST
115321: LIST
115322: LIST
115323: LIST
115324: LIST
115325: LIST
115326: LIST
115327: LIST
115328: LIST
115329: LIST
115330: LIST
115331: LIST
115332: LIST
115333: LIST
115334: LIST
115335: LIST
115336: LIST
115337: LIST
115338: LIST
115339: LIST
115340: LIST
115341: PUSH
115342: LD_INT 101
115344: PUSH
115345: LD_INT 102
115347: PUSH
115348: LD_INT 103
115350: PUSH
115351: LD_INT 104
115353: PUSH
115354: LD_INT 105
115356: PUSH
115357: LD_INT 106
115359: PUSH
115360: LD_INT 107
115362: PUSH
115363: LD_INT 108
115365: PUSH
115366: LD_INT 109
115368: PUSH
115369: LD_INT 110
115371: PUSH
115372: LD_INT 111
115374: PUSH
115375: LD_INT 112
115377: PUSH
115378: LD_INT 114
115380: PUSH
115381: LD_INT 116
115383: PUSH
115384: LD_INT 117
115386: PUSH
115387: LD_INT 118
115389: PUSH
115390: EMPTY
115391: LIST
115392: LIST
115393: LIST
115394: LIST
115395: LIST
115396: LIST
115397: LIST
115398: LIST
115399: LIST
115400: LIST
115401: LIST
115402: LIST
115403: LIST
115404: LIST
115405: LIST
115406: LIST
115407: PUSH
115408: EMPTY
115409: LIST
115410: LIST
115411: ST_TO_ADDR
115412: GO 117095
115414: LD_INT 12
115416: DOUBLE
115417: EQUAL
115418: IFTRUE 115422
115420: GO 115642
115422: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
115423: LD_ADDR_VAR 0 2
115427: PUSH
115428: LD_INT 1
115430: PUSH
115431: LD_INT 2
115433: PUSH
115434: LD_INT 3
115436: PUSH
115437: LD_INT 4
115439: PUSH
115440: LD_INT 5
115442: PUSH
115443: LD_INT 6
115445: PUSH
115446: LD_INT 7
115448: PUSH
115449: LD_INT 8
115451: PUSH
115452: LD_INT 9
115454: PUSH
115455: LD_INT 10
115457: PUSH
115458: LD_INT 11
115460: PUSH
115461: LD_INT 12
115463: PUSH
115464: LD_INT 13
115466: PUSH
115467: LD_INT 14
115469: PUSH
115470: LD_INT 15
115472: PUSH
115473: LD_INT 16
115475: PUSH
115476: LD_INT 17
115478: PUSH
115479: LD_INT 18
115481: PUSH
115482: LD_INT 19
115484: PUSH
115485: LD_INT 20
115487: PUSH
115488: LD_INT 21
115490: PUSH
115491: LD_INT 22
115493: PUSH
115494: LD_INT 23
115496: PUSH
115497: LD_INT 24
115499: PUSH
115500: LD_INT 25
115502: PUSH
115503: LD_INT 26
115505: PUSH
115506: LD_INT 27
115508: PUSH
115509: LD_INT 28
115511: PUSH
115512: LD_INT 30
115514: PUSH
115515: LD_INT 31
115517: PUSH
115518: LD_INT 32
115520: PUSH
115521: LD_INT 33
115523: PUSH
115524: LD_INT 34
115526: PUSH
115527: LD_INT 36
115529: PUSH
115530: EMPTY
115531: LIST
115532: LIST
115533: LIST
115534: LIST
115535: LIST
115536: LIST
115537: LIST
115538: LIST
115539: LIST
115540: LIST
115541: LIST
115542: LIST
115543: LIST
115544: LIST
115545: LIST
115546: LIST
115547: LIST
115548: LIST
115549: LIST
115550: LIST
115551: LIST
115552: LIST
115553: LIST
115554: LIST
115555: LIST
115556: LIST
115557: LIST
115558: LIST
115559: LIST
115560: LIST
115561: LIST
115562: LIST
115563: LIST
115564: LIST
115565: PUSH
115566: LD_INT 101
115568: PUSH
115569: LD_INT 102
115571: PUSH
115572: LD_INT 103
115574: PUSH
115575: LD_INT 104
115577: PUSH
115578: LD_INT 105
115580: PUSH
115581: LD_INT 106
115583: PUSH
115584: LD_INT 107
115586: PUSH
115587: LD_INT 108
115589: PUSH
115590: LD_INT 109
115592: PUSH
115593: LD_INT 110
115595: PUSH
115596: LD_INT 111
115598: PUSH
115599: LD_INT 112
115601: PUSH
115602: LD_INT 113
115604: PUSH
115605: LD_INT 114
115607: PUSH
115608: LD_INT 116
115610: PUSH
115611: LD_INT 117
115613: PUSH
115614: LD_INT 118
115616: PUSH
115617: EMPTY
115618: LIST
115619: LIST
115620: LIST
115621: LIST
115622: LIST
115623: LIST
115624: LIST
115625: LIST
115626: LIST
115627: LIST
115628: LIST
115629: LIST
115630: LIST
115631: LIST
115632: LIST
115633: LIST
115634: LIST
115635: PUSH
115636: EMPTY
115637: LIST
115638: LIST
115639: ST_TO_ADDR
115640: GO 117095
115642: LD_INT 13
115644: DOUBLE
115645: EQUAL
115646: IFTRUE 115650
115648: GO 115858
115650: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
115651: LD_ADDR_VAR 0 2
115655: PUSH
115656: LD_INT 1
115658: PUSH
115659: LD_INT 2
115661: PUSH
115662: LD_INT 3
115664: PUSH
115665: LD_INT 4
115667: PUSH
115668: LD_INT 5
115670: PUSH
115671: LD_INT 8
115673: PUSH
115674: LD_INT 9
115676: PUSH
115677: LD_INT 10
115679: PUSH
115680: LD_INT 11
115682: PUSH
115683: LD_INT 12
115685: PUSH
115686: LD_INT 14
115688: PUSH
115689: LD_INT 15
115691: PUSH
115692: LD_INT 16
115694: PUSH
115695: LD_INT 17
115697: PUSH
115698: LD_INT 18
115700: PUSH
115701: LD_INT 19
115703: PUSH
115704: LD_INT 20
115706: PUSH
115707: LD_INT 21
115709: PUSH
115710: LD_INT 22
115712: PUSH
115713: LD_INT 23
115715: PUSH
115716: LD_INT 24
115718: PUSH
115719: LD_INT 25
115721: PUSH
115722: LD_INT 26
115724: PUSH
115725: LD_INT 27
115727: PUSH
115728: LD_INT 28
115730: PUSH
115731: LD_INT 30
115733: PUSH
115734: LD_INT 31
115736: PUSH
115737: LD_INT 32
115739: PUSH
115740: LD_INT 33
115742: PUSH
115743: LD_INT 34
115745: PUSH
115746: LD_INT 36
115748: PUSH
115749: EMPTY
115750: LIST
115751: LIST
115752: LIST
115753: LIST
115754: LIST
115755: LIST
115756: LIST
115757: LIST
115758: LIST
115759: LIST
115760: LIST
115761: LIST
115762: LIST
115763: LIST
115764: LIST
115765: LIST
115766: LIST
115767: LIST
115768: LIST
115769: LIST
115770: LIST
115771: LIST
115772: LIST
115773: LIST
115774: LIST
115775: LIST
115776: LIST
115777: LIST
115778: LIST
115779: LIST
115780: LIST
115781: PUSH
115782: LD_INT 101
115784: PUSH
115785: LD_INT 102
115787: PUSH
115788: LD_INT 103
115790: PUSH
115791: LD_INT 104
115793: PUSH
115794: LD_INT 105
115796: PUSH
115797: LD_INT 106
115799: PUSH
115800: LD_INT 107
115802: PUSH
115803: LD_INT 108
115805: PUSH
115806: LD_INT 109
115808: PUSH
115809: LD_INT 110
115811: PUSH
115812: LD_INT 111
115814: PUSH
115815: LD_INT 112
115817: PUSH
115818: LD_INT 113
115820: PUSH
115821: LD_INT 114
115823: PUSH
115824: LD_INT 116
115826: PUSH
115827: LD_INT 117
115829: PUSH
115830: LD_INT 118
115832: PUSH
115833: EMPTY
115834: LIST
115835: LIST
115836: LIST
115837: LIST
115838: LIST
115839: LIST
115840: LIST
115841: LIST
115842: LIST
115843: LIST
115844: LIST
115845: LIST
115846: LIST
115847: LIST
115848: LIST
115849: LIST
115850: LIST
115851: PUSH
115852: EMPTY
115853: LIST
115854: LIST
115855: ST_TO_ADDR
115856: GO 117095
115858: LD_INT 14
115860: DOUBLE
115861: EQUAL
115862: IFTRUE 115866
115864: GO 116090
115866: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
115867: LD_ADDR_VAR 0 2
115871: PUSH
115872: LD_INT 1
115874: PUSH
115875: LD_INT 2
115877: PUSH
115878: LD_INT 3
115880: PUSH
115881: LD_INT 4
115883: PUSH
115884: LD_INT 5
115886: PUSH
115887: LD_INT 6
115889: PUSH
115890: LD_INT 7
115892: PUSH
115893: LD_INT 8
115895: PUSH
115896: LD_INT 9
115898: PUSH
115899: LD_INT 10
115901: PUSH
115902: LD_INT 11
115904: PUSH
115905: LD_INT 12
115907: PUSH
115908: LD_INT 13
115910: PUSH
115911: LD_INT 14
115913: PUSH
115914: LD_INT 15
115916: PUSH
115917: LD_INT 16
115919: PUSH
115920: LD_INT 17
115922: PUSH
115923: LD_INT 18
115925: PUSH
115926: LD_INT 19
115928: PUSH
115929: LD_INT 20
115931: PUSH
115932: LD_INT 21
115934: PUSH
115935: LD_INT 22
115937: PUSH
115938: LD_INT 23
115940: PUSH
115941: LD_INT 24
115943: PUSH
115944: LD_INT 25
115946: PUSH
115947: LD_INT 26
115949: PUSH
115950: LD_INT 27
115952: PUSH
115953: LD_INT 28
115955: PUSH
115956: LD_INT 29
115958: PUSH
115959: LD_INT 30
115961: PUSH
115962: LD_INT 31
115964: PUSH
115965: LD_INT 32
115967: PUSH
115968: LD_INT 33
115970: PUSH
115971: LD_INT 34
115973: PUSH
115974: LD_INT 36
115976: PUSH
115977: EMPTY
115978: LIST
115979: LIST
115980: LIST
115981: LIST
115982: LIST
115983: LIST
115984: LIST
115985: LIST
115986: LIST
115987: LIST
115988: LIST
115989: LIST
115990: LIST
115991: LIST
115992: LIST
115993: LIST
115994: LIST
115995: LIST
115996: LIST
115997: LIST
115998: LIST
115999: LIST
116000: LIST
116001: LIST
116002: LIST
116003: LIST
116004: LIST
116005: LIST
116006: LIST
116007: LIST
116008: LIST
116009: LIST
116010: LIST
116011: LIST
116012: LIST
116013: PUSH
116014: LD_INT 101
116016: PUSH
116017: LD_INT 102
116019: PUSH
116020: LD_INT 103
116022: PUSH
116023: LD_INT 104
116025: PUSH
116026: LD_INT 105
116028: PUSH
116029: LD_INT 106
116031: PUSH
116032: LD_INT 107
116034: PUSH
116035: LD_INT 108
116037: PUSH
116038: LD_INT 109
116040: PUSH
116041: LD_INT 110
116043: PUSH
116044: LD_INT 111
116046: PUSH
116047: LD_INT 112
116049: PUSH
116050: LD_INT 113
116052: PUSH
116053: LD_INT 114
116055: PUSH
116056: LD_INT 116
116058: PUSH
116059: LD_INT 117
116061: PUSH
116062: LD_INT 118
116064: PUSH
116065: EMPTY
116066: LIST
116067: LIST
116068: LIST
116069: LIST
116070: LIST
116071: LIST
116072: LIST
116073: LIST
116074: LIST
116075: LIST
116076: LIST
116077: LIST
116078: LIST
116079: LIST
116080: LIST
116081: LIST
116082: LIST
116083: PUSH
116084: EMPTY
116085: LIST
116086: LIST
116087: ST_TO_ADDR
116088: GO 117095
116090: LD_INT 15
116092: DOUBLE
116093: EQUAL
116094: IFTRUE 116098
116096: GO 116322
116098: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
116099: LD_ADDR_VAR 0 2
116103: PUSH
116104: LD_INT 1
116106: PUSH
116107: LD_INT 2
116109: PUSH
116110: LD_INT 3
116112: PUSH
116113: LD_INT 4
116115: PUSH
116116: LD_INT 5
116118: PUSH
116119: LD_INT 6
116121: PUSH
116122: LD_INT 7
116124: PUSH
116125: LD_INT 8
116127: PUSH
116128: LD_INT 9
116130: PUSH
116131: LD_INT 10
116133: PUSH
116134: LD_INT 11
116136: PUSH
116137: LD_INT 12
116139: PUSH
116140: LD_INT 13
116142: PUSH
116143: LD_INT 14
116145: PUSH
116146: LD_INT 15
116148: PUSH
116149: LD_INT 16
116151: PUSH
116152: LD_INT 17
116154: PUSH
116155: LD_INT 18
116157: PUSH
116158: LD_INT 19
116160: PUSH
116161: LD_INT 20
116163: PUSH
116164: LD_INT 21
116166: PUSH
116167: LD_INT 22
116169: PUSH
116170: LD_INT 23
116172: PUSH
116173: LD_INT 24
116175: PUSH
116176: LD_INT 25
116178: PUSH
116179: LD_INT 26
116181: PUSH
116182: LD_INT 27
116184: PUSH
116185: LD_INT 28
116187: PUSH
116188: LD_INT 29
116190: PUSH
116191: LD_INT 30
116193: PUSH
116194: LD_INT 31
116196: PUSH
116197: LD_INT 32
116199: PUSH
116200: LD_INT 33
116202: PUSH
116203: LD_INT 34
116205: PUSH
116206: LD_INT 36
116208: PUSH
116209: EMPTY
116210: LIST
116211: LIST
116212: LIST
116213: LIST
116214: LIST
116215: LIST
116216: LIST
116217: LIST
116218: LIST
116219: LIST
116220: LIST
116221: LIST
116222: LIST
116223: LIST
116224: LIST
116225: LIST
116226: LIST
116227: LIST
116228: LIST
116229: LIST
116230: LIST
116231: LIST
116232: LIST
116233: LIST
116234: LIST
116235: LIST
116236: LIST
116237: LIST
116238: LIST
116239: LIST
116240: LIST
116241: LIST
116242: LIST
116243: LIST
116244: LIST
116245: PUSH
116246: LD_INT 101
116248: PUSH
116249: LD_INT 102
116251: PUSH
116252: LD_INT 103
116254: PUSH
116255: LD_INT 104
116257: PUSH
116258: LD_INT 105
116260: PUSH
116261: LD_INT 106
116263: PUSH
116264: LD_INT 107
116266: PUSH
116267: LD_INT 108
116269: PUSH
116270: LD_INT 109
116272: PUSH
116273: LD_INT 110
116275: PUSH
116276: LD_INT 111
116278: PUSH
116279: LD_INT 112
116281: PUSH
116282: LD_INT 113
116284: PUSH
116285: LD_INT 114
116287: PUSH
116288: LD_INT 116
116290: PUSH
116291: LD_INT 117
116293: PUSH
116294: LD_INT 118
116296: PUSH
116297: EMPTY
116298: LIST
116299: LIST
116300: LIST
116301: LIST
116302: LIST
116303: LIST
116304: LIST
116305: LIST
116306: LIST
116307: LIST
116308: LIST
116309: LIST
116310: LIST
116311: LIST
116312: LIST
116313: LIST
116314: LIST
116315: PUSH
116316: EMPTY
116317: LIST
116318: LIST
116319: ST_TO_ADDR
116320: GO 117095
116322: LD_INT 16
116324: DOUBLE
116325: EQUAL
116326: IFTRUE 116330
116328: GO 116466
116330: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
116331: LD_ADDR_VAR 0 2
116335: PUSH
116336: LD_INT 2
116338: PUSH
116339: LD_INT 4
116341: PUSH
116342: LD_INT 5
116344: PUSH
116345: LD_INT 7
116347: PUSH
116348: LD_INT 11
116350: PUSH
116351: LD_INT 12
116353: PUSH
116354: LD_INT 15
116356: PUSH
116357: LD_INT 16
116359: PUSH
116360: LD_INT 20
116362: PUSH
116363: LD_INT 21
116365: PUSH
116366: LD_INT 22
116368: PUSH
116369: LD_INT 23
116371: PUSH
116372: LD_INT 25
116374: PUSH
116375: LD_INT 26
116377: PUSH
116378: LD_INT 30
116380: PUSH
116381: LD_INT 31
116383: PUSH
116384: LD_INT 32
116386: PUSH
116387: LD_INT 33
116389: PUSH
116390: LD_INT 34
116392: PUSH
116393: EMPTY
116394: LIST
116395: LIST
116396: LIST
116397: LIST
116398: LIST
116399: LIST
116400: LIST
116401: LIST
116402: LIST
116403: LIST
116404: LIST
116405: LIST
116406: LIST
116407: LIST
116408: LIST
116409: LIST
116410: LIST
116411: LIST
116412: LIST
116413: PUSH
116414: LD_INT 101
116416: PUSH
116417: LD_INT 102
116419: PUSH
116420: LD_INT 103
116422: PUSH
116423: LD_INT 106
116425: PUSH
116426: LD_INT 108
116428: PUSH
116429: LD_INT 112
116431: PUSH
116432: LD_INT 113
116434: PUSH
116435: LD_INT 114
116437: PUSH
116438: LD_INT 116
116440: PUSH
116441: LD_INT 117
116443: PUSH
116444: LD_INT 118
116446: PUSH
116447: EMPTY
116448: LIST
116449: LIST
116450: LIST
116451: LIST
116452: LIST
116453: LIST
116454: LIST
116455: LIST
116456: LIST
116457: LIST
116458: LIST
116459: PUSH
116460: EMPTY
116461: LIST
116462: LIST
116463: ST_TO_ADDR
116464: GO 117095
116466: LD_INT 17
116468: DOUBLE
116469: EQUAL
116470: IFTRUE 116474
116472: GO 116698
116474: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
116475: LD_ADDR_VAR 0 2
116479: PUSH
116480: LD_INT 1
116482: PUSH
116483: LD_INT 2
116485: PUSH
116486: LD_INT 3
116488: PUSH
116489: LD_INT 4
116491: PUSH
116492: LD_INT 5
116494: PUSH
116495: LD_INT 6
116497: PUSH
116498: LD_INT 7
116500: PUSH
116501: LD_INT 8
116503: PUSH
116504: LD_INT 9
116506: PUSH
116507: LD_INT 10
116509: PUSH
116510: LD_INT 11
116512: PUSH
116513: LD_INT 12
116515: PUSH
116516: LD_INT 13
116518: PUSH
116519: LD_INT 14
116521: PUSH
116522: LD_INT 15
116524: PUSH
116525: LD_INT 16
116527: PUSH
116528: LD_INT 17
116530: PUSH
116531: LD_INT 18
116533: PUSH
116534: LD_INT 19
116536: PUSH
116537: LD_INT 20
116539: PUSH
116540: LD_INT 21
116542: PUSH
116543: LD_INT 22
116545: PUSH
116546: LD_INT 23
116548: PUSH
116549: LD_INT 24
116551: PUSH
116552: LD_INT 25
116554: PUSH
116555: LD_INT 26
116557: PUSH
116558: LD_INT 27
116560: PUSH
116561: LD_INT 28
116563: PUSH
116564: LD_INT 29
116566: PUSH
116567: LD_INT 30
116569: PUSH
116570: LD_INT 31
116572: PUSH
116573: LD_INT 32
116575: PUSH
116576: LD_INT 33
116578: PUSH
116579: LD_INT 34
116581: PUSH
116582: LD_INT 36
116584: PUSH
116585: EMPTY
116586: LIST
116587: LIST
116588: LIST
116589: LIST
116590: LIST
116591: LIST
116592: LIST
116593: LIST
116594: LIST
116595: LIST
116596: LIST
116597: LIST
116598: LIST
116599: LIST
116600: LIST
116601: LIST
116602: LIST
116603: LIST
116604: LIST
116605: LIST
116606: LIST
116607: LIST
116608: LIST
116609: LIST
116610: LIST
116611: LIST
116612: LIST
116613: LIST
116614: LIST
116615: LIST
116616: LIST
116617: LIST
116618: LIST
116619: LIST
116620: LIST
116621: PUSH
116622: LD_INT 101
116624: PUSH
116625: LD_INT 102
116627: PUSH
116628: LD_INT 103
116630: PUSH
116631: LD_INT 104
116633: PUSH
116634: LD_INT 105
116636: PUSH
116637: LD_INT 106
116639: PUSH
116640: LD_INT 107
116642: PUSH
116643: LD_INT 108
116645: PUSH
116646: LD_INT 109
116648: PUSH
116649: LD_INT 110
116651: PUSH
116652: LD_INT 111
116654: PUSH
116655: LD_INT 112
116657: PUSH
116658: LD_INT 113
116660: PUSH
116661: LD_INT 114
116663: PUSH
116664: LD_INT 116
116666: PUSH
116667: LD_INT 117
116669: PUSH
116670: LD_INT 118
116672: PUSH
116673: EMPTY
116674: LIST
116675: LIST
116676: LIST
116677: LIST
116678: LIST
116679: LIST
116680: LIST
116681: LIST
116682: LIST
116683: LIST
116684: LIST
116685: LIST
116686: LIST
116687: LIST
116688: LIST
116689: LIST
116690: LIST
116691: PUSH
116692: EMPTY
116693: LIST
116694: LIST
116695: ST_TO_ADDR
116696: GO 117095
116698: LD_INT 18
116700: DOUBLE
116701: EQUAL
116702: IFTRUE 116706
116704: GO 116854
116706: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
116707: LD_ADDR_VAR 0 2
116711: PUSH
116712: LD_INT 2
116714: PUSH
116715: LD_INT 4
116717: PUSH
116718: LD_INT 5
116720: PUSH
116721: LD_INT 7
116723: PUSH
116724: LD_INT 11
116726: PUSH
116727: LD_INT 12
116729: PUSH
116730: LD_INT 15
116732: PUSH
116733: LD_INT 16
116735: PUSH
116736: LD_INT 20
116738: PUSH
116739: LD_INT 21
116741: PUSH
116742: LD_INT 22
116744: PUSH
116745: LD_INT 23
116747: PUSH
116748: LD_INT 25
116750: PUSH
116751: LD_INT 26
116753: PUSH
116754: LD_INT 30
116756: PUSH
116757: LD_INT 31
116759: PUSH
116760: LD_INT 32
116762: PUSH
116763: LD_INT 33
116765: PUSH
116766: LD_INT 34
116768: PUSH
116769: LD_INT 35
116771: PUSH
116772: LD_INT 36
116774: PUSH
116775: EMPTY
116776: LIST
116777: LIST
116778: LIST
116779: LIST
116780: LIST
116781: LIST
116782: LIST
116783: LIST
116784: LIST
116785: LIST
116786: LIST
116787: LIST
116788: LIST
116789: LIST
116790: LIST
116791: LIST
116792: LIST
116793: LIST
116794: LIST
116795: LIST
116796: LIST
116797: PUSH
116798: LD_INT 101
116800: PUSH
116801: LD_INT 102
116803: PUSH
116804: LD_INT 103
116806: PUSH
116807: LD_INT 106
116809: PUSH
116810: LD_INT 108
116812: PUSH
116813: LD_INT 112
116815: PUSH
116816: LD_INT 113
116818: PUSH
116819: LD_INT 114
116821: PUSH
116822: LD_INT 115
116824: PUSH
116825: LD_INT 116
116827: PUSH
116828: LD_INT 117
116830: PUSH
116831: LD_INT 118
116833: PUSH
116834: EMPTY
116835: LIST
116836: LIST
116837: LIST
116838: LIST
116839: LIST
116840: LIST
116841: LIST
116842: LIST
116843: LIST
116844: LIST
116845: LIST
116846: LIST
116847: PUSH
116848: EMPTY
116849: LIST
116850: LIST
116851: ST_TO_ADDR
116852: GO 117095
116854: LD_INT 19
116856: DOUBLE
116857: EQUAL
116858: IFTRUE 116862
116860: GO 117094
116862: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
116863: LD_ADDR_VAR 0 2
116867: PUSH
116868: LD_INT 1
116870: PUSH
116871: LD_INT 2
116873: PUSH
116874: LD_INT 3
116876: PUSH
116877: LD_INT 4
116879: PUSH
116880: LD_INT 5
116882: PUSH
116883: LD_INT 6
116885: PUSH
116886: LD_INT 7
116888: PUSH
116889: LD_INT 8
116891: PUSH
116892: LD_INT 9
116894: PUSH
116895: LD_INT 10
116897: PUSH
116898: LD_INT 11
116900: PUSH
116901: LD_INT 12
116903: PUSH
116904: LD_INT 13
116906: PUSH
116907: LD_INT 14
116909: PUSH
116910: LD_INT 15
116912: PUSH
116913: LD_INT 16
116915: PUSH
116916: LD_INT 17
116918: PUSH
116919: LD_INT 18
116921: PUSH
116922: LD_INT 19
116924: PUSH
116925: LD_INT 20
116927: PUSH
116928: LD_INT 21
116930: PUSH
116931: LD_INT 22
116933: PUSH
116934: LD_INT 23
116936: PUSH
116937: LD_INT 24
116939: PUSH
116940: LD_INT 25
116942: PUSH
116943: LD_INT 26
116945: PUSH
116946: LD_INT 27
116948: PUSH
116949: LD_INT 28
116951: PUSH
116952: LD_INT 29
116954: PUSH
116955: LD_INT 30
116957: PUSH
116958: LD_INT 31
116960: PUSH
116961: LD_INT 32
116963: PUSH
116964: LD_INT 33
116966: PUSH
116967: LD_INT 34
116969: PUSH
116970: LD_INT 35
116972: PUSH
116973: LD_INT 36
116975: PUSH
116976: EMPTY
116977: LIST
116978: LIST
116979: LIST
116980: LIST
116981: LIST
116982: LIST
116983: LIST
116984: LIST
116985: LIST
116986: LIST
116987: LIST
116988: LIST
116989: LIST
116990: LIST
116991: LIST
116992: LIST
116993: LIST
116994: LIST
116995: LIST
116996: LIST
116997: LIST
116998: LIST
116999: LIST
117000: LIST
117001: LIST
117002: LIST
117003: LIST
117004: LIST
117005: LIST
117006: LIST
117007: LIST
117008: LIST
117009: LIST
117010: LIST
117011: LIST
117012: LIST
117013: PUSH
117014: LD_INT 101
117016: PUSH
117017: LD_INT 102
117019: PUSH
117020: LD_INT 103
117022: PUSH
117023: LD_INT 104
117025: PUSH
117026: LD_INT 105
117028: PUSH
117029: LD_INT 106
117031: PUSH
117032: LD_INT 107
117034: PUSH
117035: LD_INT 108
117037: PUSH
117038: LD_INT 109
117040: PUSH
117041: LD_INT 110
117043: PUSH
117044: LD_INT 111
117046: PUSH
117047: LD_INT 112
117049: PUSH
117050: LD_INT 113
117052: PUSH
117053: LD_INT 114
117055: PUSH
117056: LD_INT 115
117058: PUSH
117059: LD_INT 116
117061: PUSH
117062: LD_INT 117
117064: PUSH
117065: LD_INT 118
117067: PUSH
117068: EMPTY
117069: LIST
117070: LIST
117071: LIST
117072: LIST
117073: LIST
117074: LIST
117075: LIST
117076: LIST
117077: LIST
117078: LIST
117079: LIST
117080: LIST
117081: LIST
117082: LIST
117083: LIST
117084: LIST
117085: LIST
117086: LIST
117087: PUSH
117088: EMPTY
117089: LIST
117090: LIST
117091: ST_TO_ADDR
117092: GO 117095
117094: POP
// end else
117095: GO 117326
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
117097: LD_ADDR_VAR 0 2
117101: PUSH
117102: LD_INT 1
117104: PUSH
117105: LD_INT 2
117107: PUSH
117108: LD_INT 3
117110: PUSH
117111: LD_INT 4
117113: PUSH
117114: LD_INT 5
117116: PUSH
117117: LD_INT 6
117119: PUSH
117120: LD_INT 7
117122: PUSH
117123: LD_INT 8
117125: PUSH
117126: LD_INT 9
117128: PUSH
117129: LD_INT 10
117131: PUSH
117132: LD_INT 11
117134: PUSH
117135: LD_INT 12
117137: PUSH
117138: LD_INT 13
117140: PUSH
117141: LD_INT 14
117143: PUSH
117144: LD_INT 15
117146: PUSH
117147: LD_INT 16
117149: PUSH
117150: LD_INT 17
117152: PUSH
117153: LD_INT 18
117155: PUSH
117156: LD_INT 19
117158: PUSH
117159: LD_INT 20
117161: PUSH
117162: LD_INT 21
117164: PUSH
117165: LD_INT 22
117167: PUSH
117168: LD_INT 23
117170: PUSH
117171: LD_INT 24
117173: PUSH
117174: LD_INT 25
117176: PUSH
117177: LD_INT 26
117179: PUSH
117180: LD_INT 27
117182: PUSH
117183: LD_INT 28
117185: PUSH
117186: LD_INT 29
117188: PUSH
117189: LD_INT 30
117191: PUSH
117192: LD_INT 31
117194: PUSH
117195: LD_INT 32
117197: PUSH
117198: LD_INT 33
117200: PUSH
117201: LD_INT 34
117203: PUSH
117204: LD_INT 35
117206: PUSH
117207: LD_INT 36
117209: PUSH
117210: EMPTY
117211: LIST
117212: LIST
117213: LIST
117214: LIST
117215: LIST
117216: LIST
117217: LIST
117218: LIST
117219: LIST
117220: LIST
117221: LIST
117222: LIST
117223: LIST
117224: LIST
117225: LIST
117226: LIST
117227: LIST
117228: LIST
117229: LIST
117230: LIST
117231: LIST
117232: LIST
117233: LIST
117234: LIST
117235: LIST
117236: LIST
117237: LIST
117238: LIST
117239: LIST
117240: LIST
117241: LIST
117242: LIST
117243: LIST
117244: LIST
117245: LIST
117246: LIST
117247: PUSH
117248: LD_INT 101
117250: PUSH
117251: LD_INT 102
117253: PUSH
117254: LD_INT 103
117256: PUSH
117257: LD_INT 104
117259: PUSH
117260: LD_INT 105
117262: PUSH
117263: LD_INT 106
117265: PUSH
117266: LD_INT 107
117268: PUSH
117269: LD_INT 108
117271: PUSH
117272: LD_INT 109
117274: PUSH
117275: LD_INT 110
117277: PUSH
117278: LD_INT 111
117280: PUSH
117281: LD_INT 112
117283: PUSH
117284: LD_INT 113
117286: PUSH
117287: LD_INT 114
117289: PUSH
117290: LD_INT 115
117292: PUSH
117293: LD_INT 116
117295: PUSH
117296: LD_INT 117
117298: PUSH
117299: LD_INT 118
117301: PUSH
117302: EMPTY
117303: LIST
117304: LIST
117305: LIST
117306: LIST
117307: LIST
117308: LIST
117309: LIST
117310: LIST
117311: LIST
117312: LIST
117313: LIST
117314: LIST
117315: LIST
117316: LIST
117317: LIST
117318: LIST
117319: LIST
117320: LIST
117321: PUSH
117322: EMPTY
117323: LIST
117324: LIST
117325: ST_TO_ADDR
// if result then
117326: LD_VAR 0 2
117330: IFFALSE 118116
// begin normal :=  ;
117332: LD_ADDR_VAR 0 5
117336: PUSH
117337: LD_STRING 
117339: ST_TO_ADDR
// hardcore :=  ;
117340: LD_ADDR_VAR 0 6
117344: PUSH
117345: LD_STRING 
117347: ST_TO_ADDR
// active :=  ;
117348: LD_ADDR_VAR 0 7
117352: PUSH
117353: LD_STRING 
117355: ST_TO_ADDR
// for i = 1 to normalCounter do
117356: LD_ADDR_VAR 0 8
117360: PUSH
117361: DOUBLE
117362: LD_INT 1
117364: DEC
117365: ST_TO_ADDR
117366: LD_EXP 148
117370: PUSH
117371: FOR_TO
117372: IFFALSE 117473
// begin tmp := 0 ;
117374: LD_ADDR_VAR 0 3
117378: PUSH
117379: LD_STRING 0
117381: ST_TO_ADDR
// if result [ 1 ] then
117382: LD_VAR 0 2
117386: PUSH
117387: LD_INT 1
117389: ARRAY
117390: IFFALSE 117455
// if result [ 1 ] [ 1 ] = i then
117392: LD_VAR 0 2
117396: PUSH
117397: LD_INT 1
117399: ARRAY
117400: PUSH
117401: LD_INT 1
117403: ARRAY
117404: PUSH
117405: LD_VAR 0 8
117409: EQUAL
117410: IFFALSE 117455
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
117412: LD_ADDR_VAR 0 2
117416: PUSH
117417: LD_VAR 0 2
117421: PPUSH
117422: LD_INT 1
117424: PPUSH
117425: LD_VAR 0 2
117429: PUSH
117430: LD_INT 1
117432: ARRAY
117433: PPUSH
117434: LD_INT 1
117436: PPUSH
117437: CALL_OW 3
117441: PPUSH
117442: CALL_OW 1
117446: ST_TO_ADDR
// tmp := 1 ;
117447: LD_ADDR_VAR 0 3
117451: PUSH
117452: LD_STRING 1
117454: ST_TO_ADDR
// end ; normal := normal & tmp ;
117455: LD_ADDR_VAR 0 5
117459: PUSH
117460: LD_VAR 0 5
117464: PUSH
117465: LD_VAR 0 3
117469: STR
117470: ST_TO_ADDR
// end ;
117471: GO 117371
117473: POP
117474: POP
// for i = 1 to hardcoreCounter do
117475: LD_ADDR_VAR 0 8
117479: PUSH
117480: DOUBLE
117481: LD_INT 1
117483: DEC
117484: ST_TO_ADDR
117485: LD_EXP 149
117489: PUSH
117490: FOR_TO
117491: IFFALSE 117596
// begin tmp := 0 ;
117493: LD_ADDR_VAR 0 3
117497: PUSH
117498: LD_STRING 0
117500: ST_TO_ADDR
// if result [ 2 ] then
117501: LD_VAR 0 2
117505: PUSH
117506: LD_INT 2
117508: ARRAY
117509: IFFALSE 117578
// if result [ 2 ] [ 1 ] = 100 + i then
117511: LD_VAR 0 2
117515: PUSH
117516: LD_INT 2
117518: ARRAY
117519: PUSH
117520: LD_INT 1
117522: ARRAY
117523: PUSH
117524: LD_INT 100
117526: PUSH
117527: LD_VAR 0 8
117531: PLUS
117532: EQUAL
117533: IFFALSE 117578
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
117535: LD_ADDR_VAR 0 2
117539: PUSH
117540: LD_VAR 0 2
117544: PPUSH
117545: LD_INT 2
117547: PPUSH
117548: LD_VAR 0 2
117552: PUSH
117553: LD_INT 2
117555: ARRAY
117556: PPUSH
117557: LD_INT 1
117559: PPUSH
117560: CALL_OW 3
117564: PPUSH
117565: CALL_OW 1
117569: ST_TO_ADDR
// tmp := 1 ;
117570: LD_ADDR_VAR 0 3
117574: PUSH
117575: LD_STRING 1
117577: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
117578: LD_ADDR_VAR 0 6
117582: PUSH
117583: LD_VAR 0 6
117587: PUSH
117588: LD_VAR 0 3
117592: STR
117593: ST_TO_ADDR
// end ;
117594: GO 117490
117596: POP
117597: POP
// if isGameLoad then
117598: LD_VAR 0 1
117602: IFFALSE 118077
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
117604: LD_ADDR_VAR 0 4
117608: PUSH
117609: LD_EXP 152
117613: PUSH
117614: LD_EXP 151
117618: PUSH
117619: LD_EXP 153
117623: PUSH
117624: LD_EXP 150
117628: PUSH
117629: LD_EXP 154
117633: PUSH
117634: LD_EXP 155
117638: PUSH
117639: LD_EXP 156
117643: PUSH
117644: LD_EXP 157
117648: PUSH
117649: LD_EXP 158
117653: PUSH
117654: LD_EXP 159
117658: PUSH
117659: LD_EXP 160
117663: PUSH
117664: LD_EXP 161
117668: PUSH
117669: LD_EXP 162
117673: PUSH
117674: LD_EXP 163
117678: PUSH
117679: LD_EXP 171
117683: PUSH
117684: LD_EXP 172
117688: PUSH
117689: LD_EXP 173
117693: PUSH
117694: LD_EXP 174
117698: PUSH
117699: LD_EXP 176
117703: PUSH
117704: LD_EXP 177
117708: PUSH
117709: LD_EXP 178
117713: PUSH
117714: LD_EXP 181
117718: PUSH
117719: LD_EXP 183
117723: PUSH
117724: LD_EXP 184
117728: PUSH
117729: LD_EXP 185
117733: PUSH
117734: LD_EXP 187
117738: PUSH
117739: LD_EXP 188
117743: PUSH
117744: LD_EXP 191
117748: PUSH
117749: LD_EXP 192
117753: PUSH
117754: LD_EXP 193
117758: PUSH
117759: LD_EXP 194
117763: PUSH
117764: LD_EXP 195
117768: PUSH
117769: LD_EXP 196
117773: PUSH
117774: LD_EXP 197
117778: PUSH
117779: LD_EXP 198
117783: PUSH
117784: LD_EXP 199
117788: PUSH
117789: LD_EXP 164
117793: PUSH
117794: LD_EXP 165
117798: PUSH
117799: LD_EXP 168
117803: PUSH
117804: LD_EXP 169
117808: PUSH
117809: LD_EXP 170
117813: PUSH
117814: LD_EXP 166
117818: PUSH
117819: LD_EXP 167
117823: PUSH
117824: LD_EXP 175
117828: PUSH
117829: LD_EXP 179
117833: PUSH
117834: LD_EXP 180
117838: PUSH
117839: LD_EXP 182
117843: PUSH
117844: LD_EXP 186
117848: PUSH
117849: LD_EXP 189
117853: PUSH
117854: LD_EXP 190
117858: PUSH
117859: LD_EXP 200
117863: PUSH
117864: LD_EXP 201
117868: PUSH
117869: LD_EXP 202
117873: PUSH
117874: LD_EXP 203
117878: PUSH
117879: EMPTY
117880: LIST
117881: LIST
117882: LIST
117883: LIST
117884: LIST
117885: LIST
117886: LIST
117887: LIST
117888: LIST
117889: LIST
117890: LIST
117891: LIST
117892: LIST
117893: LIST
117894: LIST
117895: LIST
117896: LIST
117897: LIST
117898: LIST
117899: LIST
117900: LIST
117901: LIST
117902: LIST
117903: LIST
117904: LIST
117905: LIST
117906: LIST
117907: LIST
117908: LIST
117909: LIST
117910: LIST
117911: LIST
117912: LIST
117913: LIST
117914: LIST
117915: LIST
117916: LIST
117917: LIST
117918: LIST
117919: LIST
117920: LIST
117921: LIST
117922: LIST
117923: LIST
117924: LIST
117925: LIST
117926: LIST
117927: LIST
117928: LIST
117929: LIST
117930: LIST
117931: LIST
117932: LIST
117933: LIST
117934: ST_TO_ADDR
// tmp :=  ;
117935: LD_ADDR_VAR 0 3
117939: PUSH
117940: LD_STRING 
117942: ST_TO_ADDR
// for i = 1 to normalCounter do
117943: LD_ADDR_VAR 0 8
117947: PUSH
117948: DOUBLE
117949: LD_INT 1
117951: DEC
117952: ST_TO_ADDR
117953: LD_EXP 148
117957: PUSH
117958: FOR_TO
117959: IFFALSE 117995
// begin if flags [ i ] then
117961: LD_VAR 0 4
117965: PUSH
117966: LD_VAR 0 8
117970: ARRAY
117971: IFFALSE 117993
// tmp := tmp & i & ; ;
117973: LD_ADDR_VAR 0 3
117977: PUSH
117978: LD_VAR 0 3
117982: PUSH
117983: LD_VAR 0 8
117987: STR
117988: PUSH
117989: LD_STRING ;
117991: STR
117992: ST_TO_ADDR
// end ;
117993: GO 117958
117995: POP
117996: POP
// for i = 1 to hardcoreCounter do
117997: LD_ADDR_VAR 0 8
118001: PUSH
118002: DOUBLE
118003: LD_INT 1
118005: DEC
118006: ST_TO_ADDR
118007: LD_EXP 149
118011: PUSH
118012: FOR_TO
118013: IFFALSE 118059
// begin if flags [ normalCounter + i ] then
118015: LD_VAR 0 4
118019: PUSH
118020: LD_EXP 148
118024: PUSH
118025: LD_VAR 0 8
118029: PLUS
118030: ARRAY
118031: IFFALSE 118057
// tmp := tmp & ( 100 + i ) & ; ;
118033: LD_ADDR_VAR 0 3
118037: PUSH
118038: LD_VAR 0 3
118042: PUSH
118043: LD_INT 100
118045: PUSH
118046: LD_VAR 0 8
118050: PLUS
118051: STR
118052: PUSH
118053: LD_STRING ;
118055: STR
118056: ST_TO_ADDR
// end ;
118057: GO 118012
118059: POP
118060: POP
// if tmp then
118061: LD_VAR 0 3
118065: IFFALSE 118077
// active := tmp ;
118067: LD_ADDR_VAR 0 7
118071: PUSH
118072: LD_VAR 0 3
118076: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
118077: LD_STRING getStreamItemsFromMission("
118079: PUSH
118080: LD_VAR 0 5
118084: STR
118085: PUSH
118086: LD_STRING ","
118088: STR
118089: PUSH
118090: LD_VAR 0 6
118094: STR
118095: PUSH
118096: LD_STRING ","
118098: STR
118099: PUSH
118100: LD_VAR 0 7
118104: STR
118105: PUSH
118106: LD_STRING ")
118108: STR
118109: PPUSH
118110: CALL_OW 559
// end else
118114: GO 118123
// ToLua ( getStreamItemsFromMission("","","") ) ;
118116: LD_STRING getStreamItemsFromMission("","","")
118118: PPUSH
118119: CALL_OW 559
// end ;
118123: LD_VAR 0 2
118127: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
118128: LD_EXP 147
118132: PUSH
118133: LD_EXP 152
118137: AND
118138: IFFALSE 118262
118140: GO 118142
118142: DISABLE
118143: LD_INT 0
118145: PPUSH
118146: PPUSH
// begin enable ;
118147: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
118148: LD_ADDR_VAR 0 2
118152: PUSH
118153: LD_INT 22
118155: PUSH
118156: LD_OWVAR 2
118160: PUSH
118161: EMPTY
118162: LIST
118163: LIST
118164: PUSH
118165: LD_INT 2
118167: PUSH
118168: LD_INT 34
118170: PUSH
118171: LD_INT 7
118173: PUSH
118174: EMPTY
118175: LIST
118176: LIST
118177: PUSH
118178: LD_INT 34
118180: PUSH
118181: LD_INT 45
118183: PUSH
118184: EMPTY
118185: LIST
118186: LIST
118187: PUSH
118188: LD_INT 34
118190: PUSH
118191: LD_INT 28
118193: PUSH
118194: EMPTY
118195: LIST
118196: LIST
118197: PUSH
118198: LD_INT 34
118200: PUSH
118201: LD_INT 47
118203: PUSH
118204: EMPTY
118205: LIST
118206: LIST
118207: PUSH
118208: EMPTY
118209: LIST
118210: LIST
118211: LIST
118212: LIST
118213: LIST
118214: PUSH
118215: EMPTY
118216: LIST
118217: LIST
118218: PPUSH
118219: CALL_OW 69
118223: ST_TO_ADDR
// if not tmp then
118224: LD_VAR 0 2
118228: NOT
118229: IFFALSE 118233
// exit ;
118231: GO 118262
// for i in tmp do
118233: LD_ADDR_VAR 0 1
118237: PUSH
118238: LD_VAR 0 2
118242: PUSH
118243: FOR_IN
118244: IFFALSE 118260
// begin SetLives ( i , 0 ) ;
118246: LD_VAR 0 1
118250: PPUSH
118251: LD_INT 0
118253: PPUSH
118254: CALL_OW 234
// end ;
118258: GO 118243
118260: POP
118261: POP
// end ;
118262: PPOPN 2
118264: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
118265: LD_EXP 147
118269: PUSH
118270: LD_EXP 153
118274: AND
118275: IFFALSE 118359
118277: GO 118279
118279: DISABLE
118280: LD_INT 0
118282: PPUSH
118283: PPUSH
// begin enable ;
118284: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
118285: LD_ADDR_VAR 0 2
118289: PUSH
118290: LD_INT 22
118292: PUSH
118293: LD_OWVAR 2
118297: PUSH
118298: EMPTY
118299: LIST
118300: LIST
118301: PUSH
118302: LD_INT 32
118304: PUSH
118305: LD_INT 3
118307: PUSH
118308: EMPTY
118309: LIST
118310: LIST
118311: PUSH
118312: EMPTY
118313: LIST
118314: LIST
118315: PPUSH
118316: CALL_OW 69
118320: ST_TO_ADDR
// if not tmp then
118321: LD_VAR 0 2
118325: NOT
118326: IFFALSE 118330
// exit ;
118328: GO 118359
// for i in tmp do
118330: LD_ADDR_VAR 0 1
118334: PUSH
118335: LD_VAR 0 2
118339: PUSH
118340: FOR_IN
118341: IFFALSE 118357
// begin SetLives ( i , 0 ) ;
118343: LD_VAR 0 1
118347: PPUSH
118348: LD_INT 0
118350: PPUSH
118351: CALL_OW 234
// end ;
118355: GO 118340
118357: POP
118358: POP
// end ;
118359: PPOPN 2
118361: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
118362: LD_EXP 147
118366: PUSH
118367: LD_EXP 150
118371: AND
118372: IFFALSE 118465
118374: GO 118376
118376: DISABLE
118377: LD_INT 0
118379: PPUSH
// begin enable ;
118380: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
118381: LD_ADDR_VAR 0 1
118385: PUSH
118386: LD_INT 22
118388: PUSH
118389: LD_OWVAR 2
118393: PUSH
118394: EMPTY
118395: LIST
118396: LIST
118397: PUSH
118398: LD_INT 2
118400: PUSH
118401: LD_INT 25
118403: PUSH
118404: LD_INT 5
118406: PUSH
118407: EMPTY
118408: LIST
118409: LIST
118410: PUSH
118411: LD_INT 25
118413: PUSH
118414: LD_INT 9
118416: PUSH
118417: EMPTY
118418: LIST
118419: LIST
118420: PUSH
118421: LD_INT 25
118423: PUSH
118424: LD_INT 8
118426: PUSH
118427: EMPTY
118428: LIST
118429: LIST
118430: PUSH
118431: EMPTY
118432: LIST
118433: LIST
118434: LIST
118435: LIST
118436: PUSH
118437: EMPTY
118438: LIST
118439: LIST
118440: PPUSH
118441: CALL_OW 69
118445: PUSH
118446: FOR_IN
118447: IFFALSE 118463
// begin SetClass ( i , 1 ) ;
118449: LD_VAR 0 1
118453: PPUSH
118454: LD_INT 1
118456: PPUSH
118457: CALL_OW 336
// end ;
118461: GO 118446
118463: POP
118464: POP
// end ;
118465: PPOPN 1
118467: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
118468: LD_EXP 147
118472: PUSH
118473: LD_EXP 151
118477: AND
118478: PUSH
118479: LD_OWVAR 65
118483: PUSH
118484: LD_INT 7
118486: LESS
118487: AND
118488: IFFALSE 118502
118490: GO 118492
118492: DISABLE
// begin enable ;
118493: ENABLE
// game_speed := 7 ;
118494: LD_ADDR_OWVAR 65
118498: PUSH
118499: LD_INT 7
118501: ST_TO_ADDR
// end ;
118502: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
118503: LD_EXP 147
118507: PUSH
118508: LD_EXP 154
118512: AND
118513: IFFALSE 118715
118515: GO 118517
118517: DISABLE
118518: LD_INT 0
118520: PPUSH
118521: PPUSH
118522: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
118523: LD_ADDR_VAR 0 3
118527: PUSH
118528: LD_INT 81
118530: PUSH
118531: LD_OWVAR 2
118535: PUSH
118536: EMPTY
118537: LIST
118538: LIST
118539: PUSH
118540: LD_INT 21
118542: PUSH
118543: LD_INT 1
118545: PUSH
118546: EMPTY
118547: LIST
118548: LIST
118549: PUSH
118550: EMPTY
118551: LIST
118552: LIST
118553: PPUSH
118554: CALL_OW 69
118558: ST_TO_ADDR
// if not tmp then
118559: LD_VAR 0 3
118563: NOT
118564: IFFALSE 118568
// exit ;
118566: GO 118715
// if tmp > 5 then
118568: LD_VAR 0 3
118572: PUSH
118573: LD_INT 5
118575: GREATER
118576: IFFALSE 118588
// k := 5 else
118578: LD_ADDR_VAR 0 2
118582: PUSH
118583: LD_INT 5
118585: ST_TO_ADDR
118586: GO 118598
// k := tmp ;
118588: LD_ADDR_VAR 0 2
118592: PUSH
118593: LD_VAR 0 3
118597: ST_TO_ADDR
// for i := 1 to k do
118598: LD_ADDR_VAR 0 1
118602: PUSH
118603: DOUBLE
118604: LD_INT 1
118606: DEC
118607: ST_TO_ADDR
118608: LD_VAR 0 2
118612: PUSH
118613: FOR_TO
118614: IFFALSE 118713
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
118616: LD_VAR 0 3
118620: PUSH
118621: LD_VAR 0 1
118625: ARRAY
118626: PPUSH
118627: LD_VAR 0 1
118631: PUSH
118632: LD_INT 4
118634: MOD
118635: PUSH
118636: LD_INT 1
118638: PLUS
118639: PPUSH
118640: CALL_OW 259
118644: PUSH
118645: LD_INT 10
118647: LESS
118648: IFFALSE 118711
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
118650: LD_VAR 0 3
118654: PUSH
118655: LD_VAR 0 1
118659: ARRAY
118660: PPUSH
118661: LD_VAR 0 1
118665: PUSH
118666: LD_INT 4
118668: MOD
118669: PUSH
118670: LD_INT 1
118672: PLUS
118673: PPUSH
118674: LD_VAR 0 3
118678: PUSH
118679: LD_VAR 0 1
118683: ARRAY
118684: PPUSH
118685: LD_VAR 0 1
118689: PUSH
118690: LD_INT 4
118692: MOD
118693: PUSH
118694: LD_INT 1
118696: PLUS
118697: PPUSH
118698: CALL_OW 259
118702: PUSH
118703: LD_INT 1
118705: PLUS
118706: PPUSH
118707: CALL_OW 237
118711: GO 118613
118713: POP
118714: POP
// end ;
118715: PPOPN 3
118717: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
118718: LD_EXP 147
118722: PUSH
118723: LD_EXP 155
118727: AND
118728: IFFALSE 118748
118730: GO 118732
118732: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
118733: LD_INT 4
118735: PPUSH
118736: LD_OWVAR 2
118740: PPUSH
118741: LD_INT 0
118743: PPUSH
118744: CALL_OW 324
118748: END
// every 0 0$1 trigger StreamModeActive and sShovel do
118749: LD_EXP 147
118753: PUSH
118754: LD_EXP 184
118758: AND
118759: IFFALSE 118779
118761: GO 118763
118763: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
118764: LD_INT 19
118766: PPUSH
118767: LD_OWVAR 2
118771: PPUSH
118772: LD_INT 0
118774: PPUSH
118775: CALL_OW 324
118779: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
118780: LD_EXP 147
118784: PUSH
118785: LD_EXP 156
118789: AND
118790: IFFALSE 118892
118792: GO 118794
118794: DISABLE
118795: LD_INT 0
118797: PPUSH
118798: PPUSH
// begin enable ;
118799: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
118800: LD_ADDR_VAR 0 2
118804: PUSH
118805: LD_INT 22
118807: PUSH
118808: LD_OWVAR 2
118812: PUSH
118813: EMPTY
118814: LIST
118815: LIST
118816: PUSH
118817: LD_INT 2
118819: PUSH
118820: LD_INT 34
118822: PUSH
118823: LD_INT 11
118825: PUSH
118826: EMPTY
118827: LIST
118828: LIST
118829: PUSH
118830: LD_INT 34
118832: PUSH
118833: LD_INT 30
118835: PUSH
118836: EMPTY
118837: LIST
118838: LIST
118839: PUSH
118840: EMPTY
118841: LIST
118842: LIST
118843: LIST
118844: PUSH
118845: EMPTY
118846: LIST
118847: LIST
118848: PPUSH
118849: CALL_OW 69
118853: ST_TO_ADDR
// if not tmp then
118854: LD_VAR 0 2
118858: NOT
118859: IFFALSE 118863
// exit ;
118861: GO 118892
// for i in tmp do
118863: LD_ADDR_VAR 0 1
118867: PUSH
118868: LD_VAR 0 2
118872: PUSH
118873: FOR_IN
118874: IFFALSE 118890
// begin SetLives ( i , 0 ) ;
118876: LD_VAR 0 1
118880: PPUSH
118881: LD_INT 0
118883: PPUSH
118884: CALL_OW 234
// end ;
118888: GO 118873
118890: POP
118891: POP
// end ;
118892: PPOPN 2
118894: END
// every 0 0$1 trigger StreamModeActive and sBunker do
118895: LD_EXP 147
118899: PUSH
118900: LD_EXP 157
118904: AND
118905: IFFALSE 118925
118907: GO 118909
118909: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
118910: LD_INT 32
118912: PPUSH
118913: LD_OWVAR 2
118917: PPUSH
118918: LD_INT 0
118920: PPUSH
118921: CALL_OW 324
118925: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
118926: LD_EXP 147
118930: PUSH
118931: LD_EXP 158
118935: AND
118936: IFFALSE 119117
118938: GO 118940
118940: DISABLE
118941: LD_INT 0
118943: PPUSH
118944: PPUSH
118945: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
118946: LD_ADDR_VAR 0 2
118950: PUSH
118951: LD_INT 22
118953: PUSH
118954: LD_OWVAR 2
118958: PUSH
118959: EMPTY
118960: LIST
118961: LIST
118962: PUSH
118963: LD_INT 33
118965: PUSH
118966: LD_INT 3
118968: PUSH
118969: EMPTY
118970: LIST
118971: LIST
118972: PUSH
118973: EMPTY
118974: LIST
118975: LIST
118976: PPUSH
118977: CALL_OW 69
118981: ST_TO_ADDR
// if not tmp then
118982: LD_VAR 0 2
118986: NOT
118987: IFFALSE 118991
// exit ;
118989: GO 119117
// side := 0 ;
118991: LD_ADDR_VAR 0 3
118995: PUSH
118996: LD_INT 0
118998: ST_TO_ADDR
// for i := 1 to 8 do
118999: LD_ADDR_VAR 0 1
119003: PUSH
119004: DOUBLE
119005: LD_INT 1
119007: DEC
119008: ST_TO_ADDR
119009: LD_INT 8
119011: PUSH
119012: FOR_TO
119013: IFFALSE 119061
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
119015: LD_OWVAR 2
119019: PUSH
119020: LD_VAR 0 1
119024: NONEQUAL
119025: PUSH
119026: LD_OWVAR 2
119030: PPUSH
119031: LD_VAR 0 1
119035: PPUSH
119036: CALL_OW 81
119040: PUSH
119041: LD_INT 2
119043: EQUAL
119044: AND
119045: IFFALSE 119059
// begin side := i ;
119047: LD_ADDR_VAR 0 3
119051: PUSH
119052: LD_VAR 0 1
119056: ST_TO_ADDR
// break ;
119057: GO 119061
// end ;
119059: GO 119012
119061: POP
119062: POP
// if not side then
119063: LD_VAR 0 3
119067: NOT
119068: IFFALSE 119072
// exit ;
119070: GO 119117
// for i := 1 to tmp do
119072: LD_ADDR_VAR 0 1
119076: PUSH
119077: DOUBLE
119078: LD_INT 1
119080: DEC
119081: ST_TO_ADDR
119082: LD_VAR 0 2
119086: PUSH
119087: FOR_TO
119088: IFFALSE 119115
// if Prob ( 60 ) then
119090: LD_INT 60
119092: PPUSH
119093: CALL_OW 13
119097: IFFALSE 119113
// SetSide ( i , side ) ;
119099: LD_VAR 0 1
119103: PPUSH
119104: LD_VAR 0 3
119108: PPUSH
119109: CALL_OW 235
119113: GO 119087
119115: POP
119116: POP
// end ;
119117: PPOPN 3
119119: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
119120: LD_EXP 147
119124: PUSH
119125: LD_EXP 160
119129: AND
119130: IFFALSE 119249
119132: GO 119134
119134: DISABLE
119135: LD_INT 0
119137: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
119138: LD_ADDR_VAR 0 1
119142: PUSH
119143: LD_INT 22
119145: PUSH
119146: LD_OWVAR 2
119150: PUSH
119151: EMPTY
119152: LIST
119153: LIST
119154: PUSH
119155: LD_INT 21
119157: PUSH
119158: LD_INT 1
119160: PUSH
119161: EMPTY
119162: LIST
119163: LIST
119164: PUSH
119165: LD_INT 3
119167: PUSH
119168: LD_INT 23
119170: PUSH
119171: LD_INT 0
119173: PUSH
119174: EMPTY
119175: LIST
119176: LIST
119177: PUSH
119178: EMPTY
119179: LIST
119180: LIST
119181: PUSH
119182: EMPTY
119183: LIST
119184: LIST
119185: LIST
119186: PPUSH
119187: CALL_OW 69
119191: PUSH
119192: FOR_IN
119193: IFFALSE 119247
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
119195: LD_VAR 0 1
119199: PPUSH
119200: CALL_OW 257
119204: PUSH
119205: LD_INT 1
119207: PUSH
119208: LD_INT 2
119210: PUSH
119211: LD_INT 3
119213: PUSH
119214: LD_INT 4
119216: PUSH
119217: EMPTY
119218: LIST
119219: LIST
119220: LIST
119221: LIST
119222: IN
119223: IFFALSE 119245
// SetClass ( un , rand ( 1 , 4 ) ) ;
119225: LD_VAR 0 1
119229: PPUSH
119230: LD_INT 1
119232: PPUSH
119233: LD_INT 4
119235: PPUSH
119236: CALL_OW 12
119240: PPUSH
119241: CALL_OW 336
119245: GO 119192
119247: POP
119248: POP
// end ;
119249: PPOPN 1
119251: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
119252: LD_EXP 147
119256: PUSH
119257: LD_EXP 159
119261: AND
119262: IFFALSE 119341
119264: GO 119266
119266: DISABLE
119267: LD_INT 0
119269: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
119270: LD_ADDR_VAR 0 1
119274: PUSH
119275: LD_INT 22
119277: PUSH
119278: LD_OWVAR 2
119282: PUSH
119283: EMPTY
119284: LIST
119285: LIST
119286: PUSH
119287: LD_INT 21
119289: PUSH
119290: LD_INT 3
119292: PUSH
119293: EMPTY
119294: LIST
119295: LIST
119296: PUSH
119297: EMPTY
119298: LIST
119299: LIST
119300: PPUSH
119301: CALL_OW 69
119305: ST_TO_ADDR
// if not tmp then
119306: LD_VAR 0 1
119310: NOT
119311: IFFALSE 119315
// exit ;
119313: GO 119341
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
119315: LD_VAR 0 1
119319: PUSH
119320: LD_INT 1
119322: PPUSH
119323: LD_VAR 0 1
119327: PPUSH
119328: CALL_OW 12
119332: ARRAY
119333: PPUSH
119334: LD_INT 100
119336: PPUSH
119337: CALL_OW 234
// end ;
119341: PPOPN 1
119343: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
119344: LD_EXP 147
119348: PUSH
119349: LD_EXP 161
119353: AND
119354: IFFALSE 119452
119356: GO 119358
119358: DISABLE
119359: LD_INT 0
119361: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
119362: LD_ADDR_VAR 0 1
119366: PUSH
119367: LD_INT 22
119369: PUSH
119370: LD_OWVAR 2
119374: PUSH
119375: EMPTY
119376: LIST
119377: LIST
119378: PUSH
119379: LD_INT 21
119381: PUSH
119382: LD_INT 1
119384: PUSH
119385: EMPTY
119386: LIST
119387: LIST
119388: PUSH
119389: EMPTY
119390: LIST
119391: LIST
119392: PPUSH
119393: CALL_OW 69
119397: ST_TO_ADDR
// if not tmp then
119398: LD_VAR 0 1
119402: NOT
119403: IFFALSE 119407
// exit ;
119405: GO 119452
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
119407: LD_VAR 0 1
119411: PUSH
119412: LD_INT 1
119414: PPUSH
119415: LD_VAR 0 1
119419: PPUSH
119420: CALL_OW 12
119424: ARRAY
119425: PPUSH
119426: LD_INT 1
119428: PPUSH
119429: LD_INT 4
119431: PPUSH
119432: CALL_OW 12
119436: PPUSH
119437: LD_INT 3000
119439: PPUSH
119440: LD_INT 9000
119442: PPUSH
119443: CALL_OW 12
119447: PPUSH
119448: CALL_OW 492
// end ;
119452: PPOPN 1
119454: END
// every 0 0$1 trigger StreamModeActive and sDepot do
119455: LD_EXP 147
119459: PUSH
119460: LD_EXP 162
119464: AND
119465: IFFALSE 119485
119467: GO 119469
119469: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
119470: LD_INT 1
119472: PPUSH
119473: LD_OWVAR 2
119477: PPUSH
119478: LD_INT 0
119480: PPUSH
119481: CALL_OW 324
119485: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
119486: LD_EXP 147
119490: PUSH
119491: LD_EXP 163
119495: AND
119496: IFFALSE 119579
119498: GO 119500
119500: DISABLE
119501: LD_INT 0
119503: PPUSH
119504: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
119505: LD_ADDR_VAR 0 2
119509: PUSH
119510: LD_INT 22
119512: PUSH
119513: LD_OWVAR 2
119517: PUSH
119518: EMPTY
119519: LIST
119520: LIST
119521: PUSH
119522: LD_INT 21
119524: PUSH
119525: LD_INT 3
119527: PUSH
119528: EMPTY
119529: LIST
119530: LIST
119531: PUSH
119532: EMPTY
119533: LIST
119534: LIST
119535: PPUSH
119536: CALL_OW 69
119540: ST_TO_ADDR
// if not tmp then
119541: LD_VAR 0 2
119545: NOT
119546: IFFALSE 119550
// exit ;
119548: GO 119579
// for i in tmp do
119550: LD_ADDR_VAR 0 1
119554: PUSH
119555: LD_VAR 0 2
119559: PUSH
119560: FOR_IN
119561: IFFALSE 119577
// SetBLevel ( i , 10 ) ;
119563: LD_VAR 0 1
119567: PPUSH
119568: LD_INT 10
119570: PPUSH
119571: CALL_OW 241
119575: GO 119560
119577: POP
119578: POP
// end ;
119579: PPOPN 2
119581: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
119582: LD_EXP 147
119586: PUSH
119587: LD_EXP 164
119591: AND
119592: IFFALSE 119703
119594: GO 119596
119596: DISABLE
119597: LD_INT 0
119599: PPUSH
119600: PPUSH
119601: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
119602: LD_ADDR_VAR 0 3
119606: PUSH
119607: LD_INT 22
119609: PUSH
119610: LD_OWVAR 2
119614: PUSH
119615: EMPTY
119616: LIST
119617: LIST
119618: PUSH
119619: LD_INT 25
119621: PUSH
119622: LD_INT 1
119624: PUSH
119625: EMPTY
119626: LIST
119627: LIST
119628: PUSH
119629: EMPTY
119630: LIST
119631: LIST
119632: PPUSH
119633: CALL_OW 69
119637: ST_TO_ADDR
// if not tmp then
119638: LD_VAR 0 3
119642: NOT
119643: IFFALSE 119647
// exit ;
119645: GO 119703
// un := tmp [ rand ( 1 , tmp ) ] ;
119647: LD_ADDR_VAR 0 2
119651: PUSH
119652: LD_VAR 0 3
119656: PUSH
119657: LD_INT 1
119659: PPUSH
119660: LD_VAR 0 3
119664: PPUSH
119665: CALL_OW 12
119669: ARRAY
119670: ST_TO_ADDR
// if Crawls ( un ) then
119671: LD_VAR 0 2
119675: PPUSH
119676: CALL_OW 318
119680: IFFALSE 119691
// ComWalk ( un ) ;
119682: LD_VAR 0 2
119686: PPUSH
119687: CALL_OW 138
// SetClass ( un , class_sniper ) ;
119691: LD_VAR 0 2
119695: PPUSH
119696: LD_INT 5
119698: PPUSH
119699: CALL_OW 336
// end ;
119703: PPOPN 3
119705: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
119706: LD_EXP 147
119710: PUSH
119711: LD_EXP 165
119715: AND
119716: PUSH
119717: LD_OWVAR 67
119721: PUSH
119722: LD_INT 4
119724: LESS
119725: AND
119726: IFFALSE 119745
119728: GO 119730
119730: DISABLE
// begin Difficulty := Difficulty + 1 ;
119731: LD_ADDR_OWVAR 67
119735: PUSH
119736: LD_OWVAR 67
119740: PUSH
119741: LD_INT 1
119743: PLUS
119744: ST_TO_ADDR
// end ;
119745: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
119746: LD_EXP 147
119750: PUSH
119751: LD_EXP 166
119755: AND
119756: IFFALSE 119859
119758: GO 119760
119760: DISABLE
119761: LD_INT 0
119763: PPUSH
// begin for i := 1 to 5 do
119764: LD_ADDR_VAR 0 1
119768: PUSH
119769: DOUBLE
119770: LD_INT 1
119772: DEC
119773: ST_TO_ADDR
119774: LD_INT 5
119776: PUSH
119777: FOR_TO
119778: IFFALSE 119857
// begin uc_nation := nation_nature ;
119780: LD_ADDR_OWVAR 21
119784: PUSH
119785: LD_INT 0
119787: ST_TO_ADDR
// uc_side := 0 ;
119788: LD_ADDR_OWVAR 20
119792: PUSH
119793: LD_INT 0
119795: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
119796: LD_ADDR_OWVAR 29
119800: PUSH
119801: LD_INT 12
119803: PUSH
119804: LD_INT 12
119806: PUSH
119807: EMPTY
119808: LIST
119809: LIST
119810: ST_TO_ADDR
// hc_agressivity := 20 ;
119811: LD_ADDR_OWVAR 35
119815: PUSH
119816: LD_INT 20
119818: ST_TO_ADDR
// hc_class := class_tiger ;
119819: LD_ADDR_OWVAR 28
119823: PUSH
119824: LD_INT 14
119826: ST_TO_ADDR
// hc_gallery :=  ;
119827: LD_ADDR_OWVAR 33
119831: PUSH
119832: LD_STRING 
119834: ST_TO_ADDR
// hc_name :=  ;
119835: LD_ADDR_OWVAR 26
119839: PUSH
119840: LD_STRING 
119842: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
119843: CALL_OW 44
119847: PPUSH
119848: LD_INT 0
119850: PPUSH
119851: CALL_OW 51
// end ;
119855: GO 119777
119857: POP
119858: POP
// end ;
119859: PPOPN 1
119861: END
// every 0 0$1 trigger StreamModeActive and sBomb do
119862: LD_EXP 147
119866: PUSH
119867: LD_EXP 167
119871: AND
119872: IFFALSE 119881
119874: GO 119876
119876: DISABLE
// StreamSibBomb ;
119877: CALL 119882 0 0
119881: END
// export function StreamSibBomb ; var i , x , y ; begin
119882: LD_INT 0
119884: PPUSH
119885: PPUSH
119886: PPUSH
119887: PPUSH
// result := false ;
119888: LD_ADDR_VAR 0 1
119892: PUSH
119893: LD_INT 0
119895: ST_TO_ADDR
// for i := 1 to 16 do
119896: LD_ADDR_VAR 0 2
119900: PUSH
119901: DOUBLE
119902: LD_INT 1
119904: DEC
119905: ST_TO_ADDR
119906: LD_INT 16
119908: PUSH
119909: FOR_TO
119910: IFFALSE 120109
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
119912: LD_ADDR_VAR 0 3
119916: PUSH
119917: LD_INT 10
119919: PUSH
119920: LD_INT 20
119922: PUSH
119923: LD_INT 30
119925: PUSH
119926: LD_INT 40
119928: PUSH
119929: LD_INT 50
119931: PUSH
119932: LD_INT 60
119934: PUSH
119935: LD_INT 70
119937: PUSH
119938: LD_INT 80
119940: PUSH
119941: LD_INT 90
119943: PUSH
119944: LD_INT 100
119946: PUSH
119947: LD_INT 110
119949: PUSH
119950: LD_INT 120
119952: PUSH
119953: LD_INT 130
119955: PUSH
119956: LD_INT 140
119958: PUSH
119959: LD_INT 150
119961: PUSH
119962: EMPTY
119963: LIST
119964: LIST
119965: LIST
119966: LIST
119967: LIST
119968: LIST
119969: LIST
119970: LIST
119971: LIST
119972: LIST
119973: LIST
119974: LIST
119975: LIST
119976: LIST
119977: LIST
119978: PUSH
119979: LD_INT 1
119981: PPUSH
119982: LD_INT 15
119984: PPUSH
119985: CALL_OW 12
119989: ARRAY
119990: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
119991: LD_ADDR_VAR 0 4
119995: PUSH
119996: LD_INT 10
119998: PUSH
119999: LD_INT 20
120001: PUSH
120002: LD_INT 30
120004: PUSH
120005: LD_INT 40
120007: PUSH
120008: LD_INT 50
120010: PUSH
120011: LD_INT 60
120013: PUSH
120014: LD_INT 70
120016: PUSH
120017: LD_INT 80
120019: PUSH
120020: LD_INT 90
120022: PUSH
120023: LD_INT 100
120025: PUSH
120026: LD_INT 110
120028: PUSH
120029: LD_INT 120
120031: PUSH
120032: LD_INT 130
120034: PUSH
120035: LD_INT 140
120037: PUSH
120038: LD_INT 150
120040: PUSH
120041: EMPTY
120042: LIST
120043: LIST
120044: LIST
120045: LIST
120046: LIST
120047: LIST
120048: LIST
120049: LIST
120050: LIST
120051: LIST
120052: LIST
120053: LIST
120054: LIST
120055: LIST
120056: LIST
120057: PUSH
120058: LD_INT 1
120060: PPUSH
120061: LD_INT 15
120063: PPUSH
120064: CALL_OW 12
120068: ARRAY
120069: ST_TO_ADDR
// if ValidHex ( x , y ) then
120070: LD_VAR 0 3
120074: PPUSH
120075: LD_VAR 0 4
120079: PPUSH
120080: CALL_OW 488
120084: IFFALSE 120107
// begin result := [ x , y ] ;
120086: LD_ADDR_VAR 0 1
120090: PUSH
120091: LD_VAR 0 3
120095: PUSH
120096: LD_VAR 0 4
120100: PUSH
120101: EMPTY
120102: LIST
120103: LIST
120104: ST_TO_ADDR
// break ;
120105: GO 120109
// end ; end ;
120107: GO 119909
120109: POP
120110: POP
// if result then
120111: LD_VAR 0 1
120115: IFFALSE 120175
// begin ToLua ( playSibBomb() ) ;
120117: LD_STRING playSibBomb()
120119: PPUSH
120120: CALL_OW 559
// wait ( 0 0$14 ) ;
120124: LD_INT 490
120126: PPUSH
120127: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
120131: LD_VAR 0 1
120135: PUSH
120136: LD_INT 1
120138: ARRAY
120139: PPUSH
120140: LD_VAR 0 1
120144: PUSH
120145: LD_INT 2
120147: ARRAY
120148: PPUSH
120149: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
120153: LD_VAR 0 1
120157: PUSH
120158: LD_INT 1
120160: ARRAY
120161: PPUSH
120162: LD_VAR 0 1
120166: PUSH
120167: LD_INT 2
120169: ARRAY
120170: PPUSH
120171: CALL_OW 429
// end ; end ;
120175: LD_VAR 0 1
120179: RET
// every 0 0$1 trigger StreamModeActive and sReset do
120180: LD_EXP 147
120184: PUSH
120185: LD_EXP 169
120189: AND
120190: IFFALSE 120202
120192: GO 120194
120194: DISABLE
// YouLost (  ) ;
120195: LD_STRING 
120197: PPUSH
120198: CALL_OW 104
120202: END
// every 0 0$1 trigger StreamModeActive and sFog do
120203: LD_EXP 147
120207: PUSH
120208: LD_EXP 168
120212: AND
120213: IFFALSE 120227
120215: GO 120217
120217: DISABLE
// FogOff ( your_side ) ;
120218: LD_OWVAR 2
120222: PPUSH
120223: CALL_OW 344
120227: END
// every 0 0$1 trigger StreamModeActive and sSun do
120228: LD_EXP 147
120232: PUSH
120233: LD_EXP 170
120237: AND
120238: IFFALSE 120266
120240: GO 120242
120242: DISABLE
// begin solar_recharge_percent := 0 ;
120243: LD_ADDR_OWVAR 79
120247: PUSH
120248: LD_INT 0
120250: ST_TO_ADDR
// wait ( 5 5$00 ) ;
120251: LD_INT 10500
120253: PPUSH
120254: CALL_OW 67
// solar_recharge_percent := 100 ;
120258: LD_ADDR_OWVAR 79
120262: PUSH
120263: LD_INT 100
120265: ST_TO_ADDR
// end ;
120266: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
120267: LD_EXP 147
120271: PUSH
120272: LD_EXP 171
120276: AND
120277: IFFALSE 120516
120279: GO 120281
120281: DISABLE
120282: LD_INT 0
120284: PPUSH
120285: PPUSH
120286: PPUSH
// begin tmp := [ ] ;
120287: LD_ADDR_VAR 0 3
120291: PUSH
120292: EMPTY
120293: ST_TO_ADDR
// for i := 1 to 6 do
120294: LD_ADDR_VAR 0 1
120298: PUSH
120299: DOUBLE
120300: LD_INT 1
120302: DEC
120303: ST_TO_ADDR
120304: LD_INT 6
120306: PUSH
120307: FOR_TO
120308: IFFALSE 120413
// begin uc_nation := nation_nature ;
120310: LD_ADDR_OWVAR 21
120314: PUSH
120315: LD_INT 0
120317: ST_TO_ADDR
// uc_side := 0 ;
120318: LD_ADDR_OWVAR 20
120322: PUSH
120323: LD_INT 0
120325: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
120326: LD_ADDR_OWVAR 29
120330: PUSH
120331: LD_INT 12
120333: PUSH
120334: LD_INT 12
120336: PUSH
120337: EMPTY
120338: LIST
120339: LIST
120340: ST_TO_ADDR
// hc_agressivity := 20 ;
120341: LD_ADDR_OWVAR 35
120345: PUSH
120346: LD_INT 20
120348: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
120349: LD_ADDR_OWVAR 28
120353: PUSH
120354: LD_INT 17
120356: ST_TO_ADDR
// hc_gallery :=  ;
120357: LD_ADDR_OWVAR 33
120361: PUSH
120362: LD_STRING 
120364: ST_TO_ADDR
// hc_name :=  ;
120365: LD_ADDR_OWVAR 26
120369: PUSH
120370: LD_STRING 
120372: ST_TO_ADDR
// un := CreateHuman ;
120373: LD_ADDR_VAR 0 2
120377: PUSH
120378: CALL_OW 44
120382: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
120383: LD_VAR 0 2
120387: PPUSH
120388: LD_INT 1
120390: PPUSH
120391: CALL_OW 51
// tmp := tmp ^ un ;
120395: LD_ADDR_VAR 0 3
120399: PUSH
120400: LD_VAR 0 3
120404: PUSH
120405: LD_VAR 0 2
120409: ADD
120410: ST_TO_ADDR
// end ;
120411: GO 120307
120413: POP
120414: POP
// repeat wait ( 0 0$1 ) ;
120415: LD_INT 35
120417: PPUSH
120418: CALL_OW 67
// for un in tmp do
120422: LD_ADDR_VAR 0 2
120426: PUSH
120427: LD_VAR 0 3
120431: PUSH
120432: FOR_IN
120433: IFFALSE 120507
// begin if IsDead ( un ) then
120435: LD_VAR 0 2
120439: PPUSH
120440: CALL_OW 301
120444: IFFALSE 120464
// begin tmp := tmp diff un ;
120446: LD_ADDR_VAR 0 3
120450: PUSH
120451: LD_VAR 0 3
120455: PUSH
120456: LD_VAR 0 2
120460: DIFF
120461: ST_TO_ADDR
// continue ;
120462: GO 120432
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
120464: LD_VAR 0 2
120468: PPUSH
120469: LD_INT 3
120471: PUSH
120472: LD_INT 22
120474: PUSH
120475: LD_INT 0
120477: PUSH
120478: EMPTY
120479: LIST
120480: LIST
120481: PUSH
120482: EMPTY
120483: LIST
120484: LIST
120485: PPUSH
120486: CALL_OW 69
120490: PPUSH
120491: LD_VAR 0 2
120495: PPUSH
120496: CALL_OW 74
120500: PPUSH
120501: CALL_OW 115
// end ;
120505: GO 120432
120507: POP
120508: POP
// until not tmp ;
120509: LD_VAR 0 3
120513: NOT
120514: IFFALSE 120415
// end ;
120516: PPOPN 3
120518: END
// every 0 0$1 trigger StreamModeActive and sTroll do
120519: LD_EXP 147
120523: PUSH
120524: LD_EXP 172
120528: AND
120529: IFFALSE 120583
120531: GO 120533
120533: DISABLE
// begin ToLua ( displayTroll(); ) ;
120534: LD_STRING displayTroll();
120536: PPUSH
120537: CALL_OW 559
// wait ( 3 3$00 ) ;
120541: LD_INT 6300
120543: PPUSH
120544: CALL_OW 67
// ToLua ( hideTroll(); ) ;
120548: LD_STRING hideTroll();
120550: PPUSH
120551: CALL_OW 559
// wait ( 1 1$00 ) ;
120555: LD_INT 2100
120557: PPUSH
120558: CALL_OW 67
// ToLua ( displayTroll(); ) ;
120562: LD_STRING displayTroll();
120564: PPUSH
120565: CALL_OW 559
// wait ( 1 1$00 ) ;
120569: LD_INT 2100
120571: PPUSH
120572: CALL_OW 67
// ToLua ( hideTroll(); ) ;
120576: LD_STRING hideTroll();
120578: PPUSH
120579: CALL_OW 559
// end ;
120583: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
120584: LD_EXP 147
120588: PUSH
120589: LD_EXP 173
120593: AND
120594: IFFALSE 120657
120596: GO 120598
120598: DISABLE
120599: LD_INT 0
120601: PPUSH
// begin p := 0 ;
120602: LD_ADDR_VAR 0 1
120606: PUSH
120607: LD_INT 0
120609: ST_TO_ADDR
// repeat game_speed := 1 ;
120610: LD_ADDR_OWVAR 65
120614: PUSH
120615: LD_INT 1
120617: ST_TO_ADDR
// wait ( 0 0$1 ) ;
120618: LD_INT 35
120620: PPUSH
120621: CALL_OW 67
// p := p + 1 ;
120625: LD_ADDR_VAR 0 1
120629: PUSH
120630: LD_VAR 0 1
120634: PUSH
120635: LD_INT 1
120637: PLUS
120638: ST_TO_ADDR
// until p >= 60 ;
120639: LD_VAR 0 1
120643: PUSH
120644: LD_INT 60
120646: GREATEREQUAL
120647: IFFALSE 120610
// game_speed := 4 ;
120649: LD_ADDR_OWVAR 65
120653: PUSH
120654: LD_INT 4
120656: ST_TO_ADDR
// end ;
120657: PPOPN 1
120659: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
120660: LD_EXP 147
120664: PUSH
120665: LD_EXP 174
120669: AND
120670: IFFALSE 120816
120672: GO 120674
120674: DISABLE
120675: LD_INT 0
120677: PPUSH
120678: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
120679: LD_ADDR_VAR 0 1
120683: PUSH
120684: LD_INT 22
120686: PUSH
120687: LD_OWVAR 2
120691: PUSH
120692: EMPTY
120693: LIST
120694: LIST
120695: PUSH
120696: LD_INT 2
120698: PUSH
120699: LD_INT 30
120701: PUSH
120702: LD_INT 0
120704: PUSH
120705: EMPTY
120706: LIST
120707: LIST
120708: PUSH
120709: LD_INT 30
120711: PUSH
120712: LD_INT 1
120714: PUSH
120715: EMPTY
120716: LIST
120717: LIST
120718: PUSH
120719: EMPTY
120720: LIST
120721: LIST
120722: LIST
120723: PUSH
120724: EMPTY
120725: LIST
120726: LIST
120727: PPUSH
120728: CALL_OW 69
120732: ST_TO_ADDR
// if not depot then
120733: LD_VAR 0 1
120737: NOT
120738: IFFALSE 120742
// exit ;
120740: GO 120816
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
120742: LD_ADDR_VAR 0 2
120746: PUSH
120747: LD_VAR 0 1
120751: PUSH
120752: LD_INT 1
120754: PPUSH
120755: LD_VAR 0 1
120759: PPUSH
120760: CALL_OW 12
120764: ARRAY
120765: PPUSH
120766: CALL_OW 274
120770: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
120771: LD_VAR 0 2
120775: PPUSH
120776: LD_INT 1
120778: PPUSH
120779: LD_INT 0
120781: PPUSH
120782: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
120786: LD_VAR 0 2
120790: PPUSH
120791: LD_INT 2
120793: PPUSH
120794: LD_INT 0
120796: PPUSH
120797: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
120801: LD_VAR 0 2
120805: PPUSH
120806: LD_INT 3
120808: PPUSH
120809: LD_INT 0
120811: PPUSH
120812: CALL_OW 277
// end ;
120816: PPOPN 2
120818: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
120819: LD_EXP 147
120823: PUSH
120824: LD_EXP 175
120828: AND
120829: IFFALSE 120926
120831: GO 120833
120833: DISABLE
120834: LD_INT 0
120836: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
120837: LD_ADDR_VAR 0 1
120841: PUSH
120842: LD_INT 22
120844: PUSH
120845: LD_OWVAR 2
120849: PUSH
120850: EMPTY
120851: LIST
120852: LIST
120853: PUSH
120854: LD_INT 21
120856: PUSH
120857: LD_INT 1
120859: PUSH
120860: EMPTY
120861: LIST
120862: LIST
120863: PUSH
120864: LD_INT 3
120866: PUSH
120867: LD_INT 23
120869: PUSH
120870: LD_INT 0
120872: PUSH
120873: EMPTY
120874: LIST
120875: LIST
120876: PUSH
120877: EMPTY
120878: LIST
120879: LIST
120880: PUSH
120881: EMPTY
120882: LIST
120883: LIST
120884: LIST
120885: PPUSH
120886: CALL_OW 69
120890: ST_TO_ADDR
// if not tmp then
120891: LD_VAR 0 1
120895: NOT
120896: IFFALSE 120900
// exit ;
120898: GO 120926
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
120900: LD_VAR 0 1
120904: PUSH
120905: LD_INT 1
120907: PPUSH
120908: LD_VAR 0 1
120912: PPUSH
120913: CALL_OW 12
120917: ARRAY
120918: PPUSH
120919: LD_INT 200
120921: PPUSH
120922: CALL_OW 234
// end ;
120926: PPOPN 1
120928: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
120929: LD_EXP 147
120933: PUSH
120934: LD_EXP 176
120938: AND
120939: IFFALSE 121018
120941: GO 120943
120943: DISABLE
120944: LD_INT 0
120946: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
120947: LD_ADDR_VAR 0 1
120951: PUSH
120952: LD_INT 22
120954: PUSH
120955: LD_OWVAR 2
120959: PUSH
120960: EMPTY
120961: LIST
120962: LIST
120963: PUSH
120964: LD_INT 21
120966: PUSH
120967: LD_INT 2
120969: PUSH
120970: EMPTY
120971: LIST
120972: LIST
120973: PUSH
120974: EMPTY
120975: LIST
120976: LIST
120977: PPUSH
120978: CALL_OW 69
120982: ST_TO_ADDR
// if not tmp then
120983: LD_VAR 0 1
120987: NOT
120988: IFFALSE 120992
// exit ;
120990: GO 121018
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
120992: LD_VAR 0 1
120996: PUSH
120997: LD_INT 1
120999: PPUSH
121000: LD_VAR 0 1
121004: PPUSH
121005: CALL_OW 12
121009: ARRAY
121010: PPUSH
121011: LD_INT 60
121013: PPUSH
121014: CALL_OW 234
// end ;
121018: PPOPN 1
121020: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
121021: LD_EXP 147
121025: PUSH
121026: LD_EXP 177
121030: AND
121031: IFFALSE 121130
121033: GO 121035
121035: DISABLE
121036: LD_INT 0
121038: PPUSH
121039: PPUSH
// begin enable ;
121040: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
121041: LD_ADDR_VAR 0 1
121045: PUSH
121046: LD_INT 22
121048: PUSH
121049: LD_OWVAR 2
121053: PUSH
121054: EMPTY
121055: LIST
121056: LIST
121057: PUSH
121058: LD_INT 61
121060: PUSH
121061: EMPTY
121062: LIST
121063: PUSH
121064: LD_INT 33
121066: PUSH
121067: LD_INT 2
121069: PUSH
121070: EMPTY
121071: LIST
121072: LIST
121073: PUSH
121074: EMPTY
121075: LIST
121076: LIST
121077: LIST
121078: PPUSH
121079: CALL_OW 69
121083: ST_TO_ADDR
// if not tmp then
121084: LD_VAR 0 1
121088: NOT
121089: IFFALSE 121093
// exit ;
121091: GO 121130
// for i in tmp do
121093: LD_ADDR_VAR 0 2
121097: PUSH
121098: LD_VAR 0 1
121102: PUSH
121103: FOR_IN
121104: IFFALSE 121128
// if IsControledBy ( i ) then
121106: LD_VAR 0 2
121110: PPUSH
121111: CALL_OW 312
121115: IFFALSE 121126
// ComUnlink ( i ) ;
121117: LD_VAR 0 2
121121: PPUSH
121122: CALL_OW 136
121126: GO 121103
121128: POP
121129: POP
// end ;
121130: PPOPN 2
121132: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
121133: LD_EXP 147
121137: PUSH
121138: LD_EXP 178
121142: AND
121143: IFFALSE 121283
121145: GO 121147
121147: DISABLE
121148: LD_INT 0
121150: PPUSH
121151: PPUSH
// begin ToLua ( displayPowell(); ) ;
121152: LD_STRING displayPowell();
121154: PPUSH
121155: CALL_OW 559
// uc_side := 0 ;
121159: LD_ADDR_OWVAR 20
121163: PUSH
121164: LD_INT 0
121166: ST_TO_ADDR
// uc_nation := 2 ;
121167: LD_ADDR_OWVAR 21
121171: PUSH
121172: LD_INT 2
121174: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
121175: LD_ADDR_OWVAR 37
121179: PUSH
121180: LD_INT 14
121182: ST_TO_ADDR
// vc_engine := engine_siberite ;
121183: LD_ADDR_OWVAR 39
121187: PUSH
121188: LD_INT 3
121190: ST_TO_ADDR
// vc_control := control_apeman ;
121191: LD_ADDR_OWVAR 38
121195: PUSH
121196: LD_INT 5
121198: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
121199: LD_ADDR_OWVAR 40
121203: PUSH
121204: LD_INT 29
121206: ST_TO_ADDR
// un := CreateVehicle ;
121207: LD_ADDR_VAR 0 2
121211: PUSH
121212: CALL_OW 45
121216: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
121217: LD_VAR 0 2
121221: PPUSH
121222: LD_INT 1
121224: PPUSH
121225: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
121229: LD_INT 35
121231: PPUSH
121232: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
121236: LD_VAR 0 2
121240: PPUSH
121241: LD_INT 22
121243: PUSH
121244: LD_OWVAR 2
121248: PUSH
121249: EMPTY
121250: LIST
121251: LIST
121252: PPUSH
121253: CALL_OW 69
121257: PPUSH
121258: LD_VAR 0 2
121262: PPUSH
121263: CALL_OW 74
121267: PPUSH
121268: CALL_OW 115
// until IsDead ( un ) ;
121272: LD_VAR 0 2
121276: PPUSH
121277: CALL_OW 301
121281: IFFALSE 121229
// end ;
121283: PPOPN 2
121285: END
// every 0 0$1 trigger StreamModeActive and sStu do
121286: LD_EXP 147
121290: PUSH
121291: LD_EXP 186
121295: AND
121296: IFFALSE 121312
121298: GO 121300
121300: DISABLE
// begin ToLua ( displayStucuk(); ) ;
121301: LD_STRING displayStucuk();
121303: PPUSH
121304: CALL_OW 559
// ResetFog ;
121308: CALL_OW 335
// end ;
121312: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
121313: LD_EXP 147
121317: PUSH
121318: LD_EXP 179
121322: AND
121323: IFFALSE 121464
121325: GO 121327
121327: DISABLE
121328: LD_INT 0
121330: PPUSH
121331: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
121332: LD_ADDR_VAR 0 2
121336: PUSH
121337: LD_INT 22
121339: PUSH
121340: LD_OWVAR 2
121344: PUSH
121345: EMPTY
121346: LIST
121347: LIST
121348: PUSH
121349: LD_INT 21
121351: PUSH
121352: LD_INT 1
121354: PUSH
121355: EMPTY
121356: LIST
121357: LIST
121358: PUSH
121359: EMPTY
121360: LIST
121361: LIST
121362: PPUSH
121363: CALL_OW 69
121367: ST_TO_ADDR
// if not tmp then
121368: LD_VAR 0 2
121372: NOT
121373: IFFALSE 121377
// exit ;
121375: GO 121464
// un := tmp [ rand ( 1 , tmp ) ] ;
121377: LD_ADDR_VAR 0 1
121381: PUSH
121382: LD_VAR 0 2
121386: PUSH
121387: LD_INT 1
121389: PPUSH
121390: LD_VAR 0 2
121394: PPUSH
121395: CALL_OW 12
121399: ARRAY
121400: ST_TO_ADDR
// SetSide ( un , 0 ) ;
121401: LD_VAR 0 1
121405: PPUSH
121406: LD_INT 0
121408: PPUSH
121409: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
121413: LD_VAR 0 1
121417: PPUSH
121418: LD_OWVAR 3
121422: PUSH
121423: LD_VAR 0 1
121427: DIFF
121428: PPUSH
121429: LD_VAR 0 1
121433: PPUSH
121434: CALL_OW 74
121438: PPUSH
121439: CALL_OW 115
// wait ( 0 0$20 ) ;
121443: LD_INT 700
121445: PPUSH
121446: CALL_OW 67
// SetSide ( un , your_side ) ;
121450: LD_VAR 0 1
121454: PPUSH
121455: LD_OWVAR 2
121459: PPUSH
121460: CALL_OW 235
// end ;
121464: PPOPN 2
121466: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
121467: LD_EXP 147
121471: PUSH
121472: LD_EXP 180
121476: AND
121477: IFFALSE 121583
121479: GO 121481
121481: DISABLE
121482: LD_INT 0
121484: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
121485: LD_ADDR_VAR 0 1
121489: PUSH
121490: LD_INT 22
121492: PUSH
121493: LD_OWVAR 2
121497: PUSH
121498: EMPTY
121499: LIST
121500: LIST
121501: PUSH
121502: LD_INT 2
121504: PUSH
121505: LD_INT 30
121507: PUSH
121508: LD_INT 0
121510: PUSH
121511: EMPTY
121512: LIST
121513: LIST
121514: PUSH
121515: LD_INT 30
121517: PUSH
121518: LD_INT 1
121520: PUSH
121521: EMPTY
121522: LIST
121523: LIST
121524: PUSH
121525: EMPTY
121526: LIST
121527: LIST
121528: LIST
121529: PUSH
121530: EMPTY
121531: LIST
121532: LIST
121533: PPUSH
121534: CALL_OW 69
121538: ST_TO_ADDR
// if not depot then
121539: LD_VAR 0 1
121543: NOT
121544: IFFALSE 121548
// exit ;
121546: GO 121583
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
121548: LD_VAR 0 1
121552: PUSH
121553: LD_INT 1
121555: ARRAY
121556: PPUSH
121557: CALL_OW 250
121561: PPUSH
121562: LD_VAR 0 1
121566: PUSH
121567: LD_INT 1
121569: ARRAY
121570: PPUSH
121571: CALL_OW 251
121575: PPUSH
121576: LD_INT 70
121578: PPUSH
121579: CALL_OW 495
// end ;
121583: PPOPN 1
121585: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
121586: LD_EXP 147
121590: PUSH
121591: LD_EXP 181
121595: AND
121596: IFFALSE 121807
121598: GO 121600
121600: DISABLE
121601: LD_INT 0
121603: PPUSH
121604: PPUSH
121605: PPUSH
121606: PPUSH
121607: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
121608: LD_ADDR_VAR 0 5
121612: PUSH
121613: LD_INT 22
121615: PUSH
121616: LD_OWVAR 2
121620: PUSH
121621: EMPTY
121622: LIST
121623: LIST
121624: PUSH
121625: LD_INT 21
121627: PUSH
121628: LD_INT 1
121630: PUSH
121631: EMPTY
121632: LIST
121633: LIST
121634: PUSH
121635: EMPTY
121636: LIST
121637: LIST
121638: PPUSH
121639: CALL_OW 69
121643: ST_TO_ADDR
// if not tmp then
121644: LD_VAR 0 5
121648: NOT
121649: IFFALSE 121653
// exit ;
121651: GO 121807
// for i in tmp do
121653: LD_ADDR_VAR 0 1
121657: PUSH
121658: LD_VAR 0 5
121662: PUSH
121663: FOR_IN
121664: IFFALSE 121805
// begin d := rand ( 0 , 5 ) ;
121666: LD_ADDR_VAR 0 4
121670: PUSH
121671: LD_INT 0
121673: PPUSH
121674: LD_INT 5
121676: PPUSH
121677: CALL_OW 12
121681: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
121682: LD_ADDR_VAR 0 2
121686: PUSH
121687: LD_VAR 0 1
121691: PPUSH
121692: CALL_OW 250
121696: PPUSH
121697: LD_VAR 0 4
121701: PPUSH
121702: LD_INT 3
121704: PPUSH
121705: LD_INT 12
121707: PPUSH
121708: CALL_OW 12
121712: PPUSH
121713: CALL_OW 272
121717: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
121718: LD_ADDR_VAR 0 3
121722: PUSH
121723: LD_VAR 0 1
121727: PPUSH
121728: CALL_OW 251
121732: PPUSH
121733: LD_VAR 0 4
121737: PPUSH
121738: LD_INT 3
121740: PPUSH
121741: LD_INT 12
121743: PPUSH
121744: CALL_OW 12
121748: PPUSH
121749: CALL_OW 273
121753: ST_TO_ADDR
// if ValidHex ( x , y ) then
121754: LD_VAR 0 2
121758: PPUSH
121759: LD_VAR 0 3
121763: PPUSH
121764: CALL_OW 488
121768: IFFALSE 121803
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
121770: LD_VAR 0 1
121774: PPUSH
121775: LD_VAR 0 2
121779: PPUSH
121780: LD_VAR 0 3
121784: PPUSH
121785: LD_INT 3
121787: PPUSH
121788: LD_INT 6
121790: PPUSH
121791: CALL_OW 12
121795: PPUSH
121796: LD_INT 1
121798: PPUSH
121799: CALL_OW 483
// end ;
121803: GO 121663
121805: POP
121806: POP
// end ;
121807: PPOPN 5
121809: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
121810: LD_EXP 147
121814: PUSH
121815: LD_EXP 182
121819: AND
121820: IFFALSE 121914
121822: GO 121824
121824: DISABLE
121825: LD_INT 0
121827: PPUSH
121828: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
121829: LD_ADDR_VAR 0 2
121833: PUSH
121834: LD_INT 22
121836: PUSH
121837: LD_OWVAR 2
121841: PUSH
121842: EMPTY
121843: LIST
121844: LIST
121845: PUSH
121846: LD_INT 32
121848: PUSH
121849: LD_INT 1
121851: PUSH
121852: EMPTY
121853: LIST
121854: LIST
121855: PUSH
121856: LD_INT 21
121858: PUSH
121859: LD_INT 2
121861: PUSH
121862: EMPTY
121863: LIST
121864: LIST
121865: PUSH
121866: EMPTY
121867: LIST
121868: LIST
121869: LIST
121870: PPUSH
121871: CALL_OW 69
121875: ST_TO_ADDR
// if not tmp then
121876: LD_VAR 0 2
121880: NOT
121881: IFFALSE 121885
// exit ;
121883: GO 121914
// for i in tmp do
121885: LD_ADDR_VAR 0 1
121889: PUSH
121890: LD_VAR 0 2
121894: PUSH
121895: FOR_IN
121896: IFFALSE 121912
// SetFuel ( i , 0 ) ;
121898: LD_VAR 0 1
121902: PPUSH
121903: LD_INT 0
121905: PPUSH
121906: CALL_OW 240
121910: GO 121895
121912: POP
121913: POP
// end ;
121914: PPOPN 2
121916: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
121917: LD_EXP 147
121921: PUSH
121922: LD_EXP 183
121926: AND
121927: IFFALSE 121993
121929: GO 121931
121931: DISABLE
121932: LD_INT 0
121934: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
121935: LD_ADDR_VAR 0 1
121939: PUSH
121940: LD_INT 22
121942: PUSH
121943: LD_OWVAR 2
121947: PUSH
121948: EMPTY
121949: LIST
121950: LIST
121951: PUSH
121952: LD_INT 30
121954: PUSH
121955: LD_INT 29
121957: PUSH
121958: EMPTY
121959: LIST
121960: LIST
121961: PUSH
121962: EMPTY
121963: LIST
121964: LIST
121965: PPUSH
121966: CALL_OW 69
121970: ST_TO_ADDR
// if not tmp then
121971: LD_VAR 0 1
121975: NOT
121976: IFFALSE 121980
// exit ;
121978: GO 121993
// DestroyUnit ( tmp [ 1 ] ) ;
121980: LD_VAR 0 1
121984: PUSH
121985: LD_INT 1
121987: ARRAY
121988: PPUSH
121989: CALL_OW 65
// end ;
121993: PPOPN 1
121995: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
121996: LD_EXP 147
122000: PUSH
122001: LD_EXP 185
122005: AND
122006: IFFALSE 122135
122008: GO 122010
122010: DISABLE
122011: LD_INT 0
122013: PPUSH
// begin uc_side := 0 ;
122014: LD_ADDR_OWVAR 20
122018: PUSH
122019: LD_INT 0
122021: ST_TO_ADDR
// uc_nation := nation_arabian ;
122022: LD_ADDR_OWVAR 21
122026: PUSH
122027: LD_INT 2
122029: ST_TO_ADDR
// hc_gallery :=  ;
122030: LD_ADDR_OWVAR 33
122034: PUSH
122035: LD_STRING 
122037: ST_TO_ADDR
// hc_name :=  ;
122038: LD_ADDR_OWVAR 26
122042: PUSH
122043: LD_STRING 
122045: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
122046: LD_INT 1
122048: PPUSH
122049: LD_INT 11
122051: PPUSH
122052: LD_INT 10
122054: PPUSH
122055: CALL_OW 380
// un := CreateHuman ;
122059: LD_ADDR_VAR 0 1
122063: PUSH
122064: CALL_OW 44
122068: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
122069: LD_VAR 0 1
122073: PPUSH
122074: LD_INT 1
122076: PPUSH
122077: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
122081: LD_INT 35
122083: PPUSH
122084: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
122088: LD_VAR 0 1
122092: PPUSH
122093: LD_INT 22
122095: PUSH
122096: LD_OWVAR 2
122100: PUSH
122101: EMPTY
122102: LIST
122103: LIST
122104: PPUSH
122105: CALL_OW 69
122109: PPUSH
122110: LD_VAR 0 1
122114: PPUSH
122115: CALL_OW 74
122119: PPUSH
122120: CALL_OW 115
// until IsDead ( un ) ;
122124: LD_VAR 0 1
122128: PPUSH
122129: CALL_OW 301
122133: IFFALSE 122081
// end ;
122135: PPOPN 1
122137: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
122138: LD_EXP 147
122142: PUSH
122143: LD_EXP 187
122147: AND
122148: IFFALSE 122160
122150: GO 122152
122152: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
122153: LD_STRING earthquake(getX(game), 0, 32)
122155: PPUSH
122156: CALL_OW 559
122160: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
122161: LD_EXP 147
122165: PUSH
122166: LD_EXP 188
122170: AND
122171: IFFALSE 122262
122173: GO 122175
122175: DISABLE
122176: LD_INT 0
122178: PPUSH
// begin enable ;
122179: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
122180: LD_ADDR_VAR 0 1
122184: PUSH
122185: LD_INT 22
122187: PUSH
122188: LD_OWVAR 2
122192: PUSH
122193: EMPTY
122194: LIST
122195: LIST
122196: PUSH
122197: LD_INT 21
122199: PUSH
122200: LD_INT 2
122202: PUSH
122203: EMPTY
122204: LIST
122205: LIST
122206: PUSH
122207: LD_INT 33
122209: PUSH
122210: LD_INT 3
122212: PUSH
122213: EMPTY
122214: LIST
122215: LIST
122216: PUSH
122217: EMPTY
122218: LIST
122219: LIST
122220: LIST
122221: PPUSH
122222: CALL_OW 69
122226: ST_TO_ADDR
// if not tmp then
122227: LD_VAR 0 1
122231: NOT
122232: IFFALSE 122236
// exit ;
122234: GO 122262
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
122236: LD_VAR 0 1
122240: PUSH
122241: LD_INT 1
122243: PPUSH
122244: LD_VAR 0 1
122248: PPUSH
122249: CALL_OW 12
122253: ARRAY
122254: PPUSH
122255: LD_INT 1
122257: PPUSH
122258: CALL_OW 234
// end ;
122262: PPOPN 1
122264: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
122265: LD_EXP 147
122269: PUSH
122270: LD_EXP 189
122274: AND
122275: IFFALSE 122416
122277: GO 122279
122279: DISABLE
122280: LD_INT 0
122282: PPUSH
122283: PPUSH
122284: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
122285: LD_ADDR_VAR 0 3
122289: PUSH
122290: LD_INT 22
122292: PUSH
122293: LD_OWVAR 2
122297: PUSH
122298: EMPTY
122299: LIST
122300: LIST
122301: PUSH
122302: LD_INT 25
122304: PUSH
122305: LD_INT 1
122307: PUSH
122308: EMPTY
122309: LIST
122310: LIST
122311: PUSH
122312: EMPTY
122313: LIST
122314: LIST
122315: PPUSH
122316: CALL_OW 69
122320: ST_TO_ADDR
// if not tmp then
122321: LD_VAR 0 3
122325: NOT
122326: IFFALSE 122330
// exit ;
122328: GO 122416
// un := tmp [ rand ( 1 , tmp ) ] ;
122330: LD_ADDR_VAR 0 2
122334: PUSH
122335: LD_VAR 0 3
122339: PUSH
122340: LD_INT 1
122342: PPUSH
122343: LD_VAR 0 3
122347: PPUSH
122348: CALL_OW 12
122352: ARRAY
122353: ST_TO_ADDR
// if Crawls ( un ) then
122354: LD_VAR 0 2
122358: PPUSH
122359: CALL_OW 318
122363: IFFALSE 122374
// ComWalk ( un ) ;
122365: LD_VAR 0 2
122369: PPUSH
122370: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
122374: LD_VAR 0 2
122378: PPUSH
122379: LD_INT 9
122381: PPUSH
122382: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
122386: LD_INT 28
122388: PPUSH
122389: LD_OWVAR 2
122393: PPUSH
122394: LD_INT 2
122396: PPUSH
122397: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
122401: LD_INT 29
122403: PPUSH
122404: LD_OWVAR 2
122408: PPUSH
122409: LD_INT 2
122411: PPUSH
122412: CALL_OW 322
// end ;
122416: PPOPN 3
122418: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
122419: LD_EXP 147
122423: PUSH
122424: LD_EXP 190
122428: AND
122429: IFFALSE 122540
122431: GO 122433
122433: DISABLE
122434: LD_INT 0
122436: PPUSH
122437: PPUSH
122438: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
122439: LD_ADDR_VAR 0 3
122443: PUSH
122444: LD_INT 22
122446: PUSH
122447: LD_OWVAR 2
122451: PUSH
122452: EMPTY
122453: LIST
122454: LIST
122455: PUSH
122456: LD_INT 25
122458: PUSH
122459: LD_INT 1
122461: PUSH
122462: EMPTY
122463: LIST
122464: LIST
122465: PUSH
122466: EMPTY
122467: LIST
122468: LIST
122469: PPUSH
122470: CALL_OW 69
122474: ST_TO_ADDR
// if not tmp then
122475: LD_VAR 0 3
122479: NOT
122480: IFFALSE 122484
// exit ;
122482: GO 122540
// un := tmp [ rand ( 1 , tmp ) ] ;
122484: LD_ADDR_VAR 0 2
122488: PUSH
122489: LD_VAR 0 3
122493: PUSH
122494: LD_INT 1
122496: PPUSH
122497: LD_VAR 0 3
122501: PPUSH
122502: CALL_OW 12
122506: ARRAY
122507: ST_TO_ADDR
// if Crawls ( un ) then
122508: LD_VAR 0 2
122512: PPUSH
122513: CALL_OW 318
122517: IFFALSE 122528
// ComWalk ( un ) ;
122519: LD_VAR 0 2
122523: PPUSH
122524: CALL_OW 138
// SetClass ( un , class_mortar ) ;
122528: LD_VAR 0 2
122532: PPUSH
122533: LD_INT 8
122535: PPUSH
122536: CALL_OW 336
// end ;
122540: PPOPN 3
122542: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
122543: LD_EXP 147
122547: PUSH
122548: LD_EXP 191
122552: AND
122553: IFFALSE 122697
122555: GO 122557
122557: DISABLE
122558: LD_INT 0
122560: PPUSH
122561: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
122562: LD_ADDR_VAR 0 2
122566: PUSH
122567: LD_INT 22
122569: PUSH
122570: LD_OWVAR 2
122574: PUSH
122575: EMPTY
122576: LIST
122577: LIST
122578: PUSH
122579: LD_INT 21
122581: PUSH
122582: LD_INT 2
122584: PUSH
122585: EMPTY
122586: LIST
122587: LIST
122588: PUSH
122589: LD_INT 2
122591: PUSH
122592: LD_INT 34
122594: PUSH
122595: LD_INT 12
122597: PUSH
122598: EMPTY
122599: LIST
122600: LIST
122601: PUSH
122602: LD_INT 34
122604: PUSH
122605: LD_INT 51
122607: PUSH
122608: EMPTY
122609: LIST
122610: LIST
122611: PUSH
122612: LD_INT 34
122614: PUSH
122615: LD_INT 32
122617: PUSH
122618: EMPTY
122619: LIST
122620: LIST
122621: PUSH
122622: EMPTY
122623: LIST
122624: LIST
122625: LIST
122626: LIST
122627: PUSH
122628: EMPTY
122629: LIST
122630: LIST
122631: LIST
122632: PPUSH
122633: CALL_OW 69
122637: ST_TO_ADDR
// if not tmp then
122638: LD_VAR 0 2
122642: NOT
122643: IFFALSE 122647
// exit ;
122645: GO 122697
// for i in tmp do
122647: LD_ADDR_VAR 0 1
122651: PUSH
122652: LD_VAR 0 2
122656: PUSH
122657: FOR_IN
122658: IFFALSE 122695
// if GetCargo ( i , mat_artifact ) = 0 then
122660: LD_VAR 0 1
122664: PPUSH
122665: LD_INT 4
122667: PPUSH
122668: CALL_OW 289
122672: PUSH
122673: LD_INT 0
122675: EQUAL
122676: IFFALSE 122693
// SetCargo ( i , mat_siberit , 100 ) ;
122678: LD_VAR 0 1
122682: PPUSH
122683: LD_INT 3
122685: PPUSH
122686: LD_INT 100
122688: PPUSH
122689: CALL_OW 290
122693: GO 122657
122695: POP
122696: POP
// end ;
122697: PPOPN 2
122699: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
122700: LD_EXP 147
122704: PUSH
122705: LD_EXP 192
122709: AND
122710: IFFALSE 122893
122712: GO 122714
122714: DISABLE
122715: LD_INT 0
122717: PPUSH
122718: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
122719: LD_ADDR_VAR 0 2
122723: PUSH
122724: LD_INT 22
122726: PUSH
122727: LD_OWVAR 2
122731: PUSH
122732: EMPTY
122733: LIST
122734: LIST
122735: PPUSH
122736: CALL_OW 69
122740: ST_TO_ADDR
// if not tmp then
122741: LD_VAR 0 2
122745: NOT
122746: IFFALSE 122750
// exit ;
122748: GO 122893
// for i := 1 to 2 do
122750: LD_ADDR_VAR 0 1
122754: PUSH
122755: DOUBLE
122756: LD_INT 1
122758: DEC
122759: ST_TO_ADDR
122760: LD_INT 2
122762: PUSH
122763: FOR_TO
122764: IFFALSE 122891
// begin uc_side := your_side ;
122766: LD_ADDR_OWVAR 20
122770: PUSH
122771: LD_OWVAR 2
122775: ST_TO_ADDR
// uc_nation := nation_american ;
122776: LD_ADDR_OWVAR 21
122780: PUSH
122781: LD_INT 1
122783: ST_TO_ADDR
// vc_chassis := us_morphling ;
122784: LD_ADDR_OWVAR 37
122788: PUSH
122789: LD_INT 5
122791: ST_TO_ADDR
// vc_engine := engine_siberite ;
122792: LD_ADDR_OWVAR 39
122796: PUSH
122797: LD_INT 3
122799: ST_TO_ADDR
// vc_control := control_computer ;
122800: LD_ADDR_OWVAR 38
122804: PUSH
122805: LD_INT 3
122807: ST_TO_ADDR
// vc_weapon := us_double_laser ;
122808: LD_ADDR_OWVAR 40
122812: PUSH
122813: LD_INT 10
122815: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
122816: LD_VAR 0 2
122820: PUSH
122821: LD_INT 1
122823: ARRAY
122824: PPUSH
122825: CALL_OW 310
122829: NOT
122830: IFFALSE 122877
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
122832: CALL_OW 45
122836: PPUSH
122837: LD_VAR 0 2
122841: PUSH
122842: LD_INT 1
122844: ARRAY
122845: PPUSH
122846: CALL_OW 250
122850: PPUSH
122851: LD_VAR 0 2
122855: PUSH
122856: LD_INT 1
122858: ARRAY
122859: PPUSH
122860: CALL_OW 251
122864: PPUSH
122865: LD_INT 12
122867: PPUSH
122868: LD_INT 1
122870: PPUSH
122871: CALL_OW 50
122875: GO 122889
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
122877: CALL_OW 45
122881: PPUSH
122882: LD_INT 1
122884: PPUSH
122885: CALL_OW 51
// end ;
122889: GO 122763
122891: POP
122892: POP
// end ;
122893: PPOPN 2
122895: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
122896: LD_EXP 147
122900: PUSH
122901: LD_EXP 193
122905: AND
122906: IFFALSE 123128
122908: GO 122910
122910: DISABLE
122911: LD_INT 0
122913: PPUSH
122914: PPUSH
122915: PPUSH
122916: PPUSH
122917: PPUSH
122918: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
122919: LD_ADDR_VAR 0 6
122923: PUSH
122924: LD_INT 22
122926: PUSH
122927: LD_OWVAR 2
122931: PUSH
122932: EMPTY
122933: LIST
122934: LIST
122935: PUSH
122936: LD_INT 21
122938: PUSH
122939: LD_INT 1
122941: PUSH
122942: EMPTY
122943: LIST
122944: LIST
122945: PUSH
122946: LD_INT 3
122948: PUSH
122949: LD_INT 23
122951: PUSH
122952: LD_INT 0
122954: PUSH
122955: EMPTY
122956: LIST
122957: LIST
122958: PUSH
122959: EMPTY
122960: LIST
122961: LIST
122962: PUSH
122963: EMPTY
122964: LIST
122965: LIST
122966: LIST
122967: PPUSH
122968: CALL_OW 69
122972: ST_TO_ADDR
// if not tmp then
122973: LD_VAR 0 6
122977: NOT
122978: IFFALSE 122982
// exit ;
122980: GO 123128
// s1 := rand ( 1 , 4 ) ;
122982: LD_ADDR_VAR 0 2
122986: PUSH
122987: LD_INT 1
122989: PPUSH
122990: LD_INT 4
122992: PPUSH
122993: CALL_OW 12
122997: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
122998: LD_ADDR_VAR 0 4
123002: PUSH
123003: LD_VAR 0 6
123007: PUSH
123008: LD_INT 1
123010: ARRAY
123011: PPUSH
123012: LD_VAR 0 2
123016: PPUSH
123017: CALL_OW 259
123021: ST_TO_ADDR
// if s1 = 1 then
123022: LD_VAR 0 2
123026: PUSH
123027: LD_INT 1
123029: EQUAL
123030: IFFALSE 123050
// s2 := rand ( 2 , 4 ) else
123032: LD_ADDR_VAR 0 3
123036: PUSH
123037: LD_INT 2
123039: PPUSH
123040: LD_INT 4
123042: PPUSH
123043: CALL_OW 12
123047: ST_TO_ADDR
123048: GO 123058
// s2 := 1 ;
123050: LD_ADDR_VAR 0 3
123054: PUSH
123055: LD_INT 1
123057: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
123058: LD_ADDR_VAR 0 5
123062: PUSH
123063: LD_VAR 0 6
123067: PUSH
123068: LD_INT 1
123070: ARRAY
123071: PPUSH
123072: LD_VAR 0 3
123076: PPUSH
123077: CALL_OW 259
123081: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
123082: LD_VAR 0 6
123086: PUSH
123087: LD_INT 1
123089: ARRAY
123090: PPUSH
123091: LD_VAR 0 2
123095: PPUSH
123096: LD_VAR 0 5
123100: PPUSH
123101: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
123105: LD_VAR 0 6
123109: PUSH
123110: LD_INT 1
123112: ARRAY
123113: PPUSH
123114: LD_VAR 0 3
123118: PPUSH
123119: LD_VAR 0 4
123123: PPUSH
123124: CALL_OW 237
// end ;
123128: PPOPN 6
123130: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
123131: LD_EXP 147
123135: PUSH
123136: LD_EXP 194
123140: AND
123141: IFFALSE 123220
123143: GO 123145
123145: DISABLE
123146: LD_INT 0
123148: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
123149: LD_ADDR_VAR 0 1
123153: PUSH
123154: LD_INT 22
123156: PUSH
123157: LD_OWVAR 2
123161: PUSH
123162: EMPTY
123163: LIST
123164: LIST
123165: PUSH
123166: LD_INT 30
123168: PUSH
123169: LD_INT 3
123171: PUSH
123172: EMPTY
123173: LIST
123174: LIST
123175: PUSH
123176: EMPTY
123177: LIST
123178: LIST
123179: PPUSH
123180: CALL_OW 69
123184: ST_TO_ADDR
// if not tmp then
123185: LD_VAR 0 1
123189: NOT
123190: IFFALSE 123194
// exit ;
123192: GO 123220
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
123194: LD_VAR 0 1
123198: PUSH
123199: LD_INT 1
123201: PPUSH
123202: LD_VAR 0 1
123206: PPUSH
123207: CALL_OW 12
123211: ARRAY
123212: PPUSH
123213: LD_INT 1
123215: PPUSH
123216: CALL_OW 234
// end ;
123220: PPOPN 1
123222: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
123223: LD_EXP 147
123227: PUSH
123228: LD_EXP 195
123232: AND
123233: IFFALSE 123345
123235: GO 123237
123237: DISABLE
123238: LD_INT 0
123240: PPUSH
123241: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
123242: LD_ADDR_VAR 0 2
123246: PUSH
123247: LD_INT 22
123249: PUSH
123250: LD_OWVAR 2
123254: PUSH
123255: EMPTY
123256: LIST
123257: LIST
123258: PUSH
123259: LD_INT 2
123261: PUSH
123262: LD_INT 30
123264: PUSH
123265: LD_INT 27
123267: PUSH
123268: EMPTY
123269: LIST
123270: LIST
123271: PUSH
123272: LD_INT 30
123274: PUSH
123275: LD_INT 26
123277: PUSH
123278: EMPTY
123279: LIST
123280: LIST
123281: PUSH
123282: LD_INT 30
123284: PUSH
123285: LD_INT 28
123287: PUSH
123288: EMPTY
123289: LIST
123290: LIST
123291: PUSH
123292: EMPTY
123293: LIST
123294: LIST
123295: LIST
123296: LIST
123297: PUSH
123298: EMPTY
123299: LIST
123300: LIST
123301: PPUSH
123302: CALL_OW 69
123306: ST_TO_ADDR
// if not tmp then
123307: LD_VAR 0 2
123311: NOT
123312: IFFALSE 123316
// exit ;
123314: GO 123345
// for i in tmp do
123316: LD_ADDR_VAR 0 1
123320: PUSH
123321: LD_VAR 0 2
123325: PUSH
123326: FOR_IN
123327: IFFALSE 123343
// SetLives ( i , 1 ) ;
123329: LD_VAR 0 1
123333: PPUSH
123334: LD_INT 1
123336: PPUSH
123337: CALL_OW 234
123341: GO 123326
123343: POP
123344: POP
// end ;
123345: PPOPN 2
123347: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
123348: LD_EXP 147
123352: PUSH
123353: LD_EXP 196
123357: AND
123358: IFFALSE 123645
123360: GO 123362
123362: DISABLE
123363: LD_INT 0
123365: PPUSH
123366: PPUSH
123367: PPUSH
// begin i := rand ( 1 , 7 ) ;
123368: LD_ADDR_VAR 0 1
123372: PUSH
123373: LD_INT 1
123375: PPUSH
123376: LD_INT 7
123378: PPUSH
123379: CALL_OW 12
123383: ST_TO_ADDR
// case i of 1 :
123384: LD_VAR 0 1
123388: PUSH
123389: LD_INT 1
123391: DOUBLE
123392: EQUAL
123393: IFTRUE 123397
123395: GO 123407
123397: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
123398: LD_STRING earthquake(getX(game), 0, 32)
123400: PPUSH
123401: CALL_OW 559
123405: GO 123645
123407: LD_INT 2
123409: DOUBLE
123410: EQUAL
123411: IFTRUE 123415
123413: GO 123429
123415: POP
// begin ToLua ( displayStucuk(); ) ;
123416: LD_STRING displayStucuk();
123418: PPUSH
123419: CALL_OW 559
// ResetFog ;
123423: CALL_OW 335
// end ; 3 :
123427: GO 123645
123429: LD_INT 3
123431: DOUBLE
123432: EQUAL
123433: IFTRUE 123437
123435: GO 123541
123437: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
123438: LD_ADDR_VAR 0 2
123442: PUSH
123443: LD_INT 22
123445: PUSH
123446: LD_OWVAR 2
123450: PUSH
123451: EMPTY
123452: LIST
123453: LIST
123454: PUSH
123455: LD_INT 25
123457: PUSH
123458: LD_INT 1
123460: PUSH
123461: EMPTY
123462: LIST
123463: LIST
123464: PUSH
123465: EMPTY
123466: LIST
123467: LIST
123468: PPUSH
123469: CALL_OW 69
123473: ST_TO_ADDR
// if not tmp then
123474: LD_VAR 0 2
123478: NOT
123479: IFFALSE 123483
// exit ;
123481: GO 123645
// un := tmp [ rand ( 1 , tmp ) ] ;
123483: LD_ADDR_VAR 0 3
123487: PUSH
123488: LD_VAR 0 2
123492: PUSH
123493: LD_INT 1
123495: PPUSH
123496: LD_VAR 0 2
123500: PPUSH
123501: CALL_OW 12
123505: ARRAY
123506: ST_TO_ADDR
// if Crawls ( un ) then
123507: LD_VAR 0 3
123511: PPUSH
123512: CALL_OW 318
123516: IFFALSE 123527
// ComWalk ( un ) ;
123518: LD_VAR 0 3
123522: PPUSH
123523: CALL_OW 138
// SetClass ( un , class_mortar ) ;
123527: LD_VAR 0 3
123531: PPUSH
123532: LD_INT 8
123534: PPUSH
123535: CALL_OW 336
// end ; 4 :
123539: GO 123645
123541: LD_INT 4
123543: DOUBLE
123544: EQUAL
123545: IFTRUE 123549
123547: GO 123623
123549: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
123550: LD_ADDR_VAR 0 2
123554: PUSH
123555: LD_INT 22
123557: PUSH
123558: LD_OWVAR 2
123562: PUSH
123563: EMPTY
123564: LIST
123565: LIST
123566: PUSH
123567: LD_INT 30
123569: PUSH
123570: LD_INT 29
123572: PUSH
123573: EMPTY
123574: LIST
123575: LIST
123576: PUSH
123577: EMPTY
123578: LIST
123579: LIST
123580: PPUSH
123581: CALL_OW 69
123585: ST_TO_ADDR
// if not tmp then
123586: LD_VAR 0 2
123590: NOT
123591: IFFALSE 123595
// exit ;
123593: GO 123645
// CenterNowOnUnits ( tmp [ 1 ] ) ;
123595: LD_VAR 0 2
123599: PUSH
123600: LD_INT 1
123602: ARRAY
123603: PPUSH
123604: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
123608: LD_VAR 0 2
123612: PUSH
123613: LD_INT 1
123615: ARRAY
123616: PPUSH
123617: CALL_OW 65
// end ; 5 .. 7 :
123621: GO 123645
123623: LD_INT 5
123625: DOUBLE
123626: GREATEREQUAL
123627: IFFALSE 123635
123629: LD_INT 7
123631: DOUBLE
123632: LESSEQUAL
123633: IFTRUE 123637
123635: GO 123644
123637: POP
// StreamSibBomb ; end ;
123638: CALL 119882 0 0
123642: GO 123645
123644: POP
// end ;
123645: PPOPN 3
123647: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
123648: LD_EXP 147
123652: PUSH
123653: LD_EXP 197
123657: AND
123658: IFFALSE 123814
123660: GO 123662
123662: DISABLE
123663: LD_INT 0
123665: PPUSH
123666: PPUSH
123667: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
123668: LD_ADDR_VAR 0 2
123672: PUSH
123673: LD_INT 81
123675: PUSH
123676: LD_OWVAR 2
123680: PUSH
123681: EMPTY
123682: LIST
123683: LIST
123684: PUSH
123685: LD_INT 2
123687: PUSH
123688: LD_INT 21
123690: PUSH
123691: LD_INT 1
123693: PUSH
123694: EMPTY
123695: LIST
123696: LIST
123697: PUSH
123698: LD_INT 21
123700: PUSH
123701: LD_INT 2
123703: PUSH
123704: EMPTY
123705: LIST
123706: LIST
123707: PUSH
123708: EMPTY
123709: LIST
123710: LIST
123711: LIST
123712: PUSH
123713: EMPTY
123714: LIST
123715: LIST
123716: PPUSH
123717: CALL_OW 69
123721: ST_TO_ADDR
// if not tmp then
123722: LD_VAR 0 2
123726: NOT
123727: IFFALSE 123731
// exit ;
123729: GO 123814
// p := 0 ;
123731: LD_ADDR_VAR 0 3
123735: PUSH
123736: LD_INT 0
123738: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
123739: LD_INT 35
123741: PPUSH
123742: CALL_OW 67
// p := p + 1 ;
123746: LD_ADDR_VAR 0 3
123750: PUSH
123751: LD_VAR 0 3
123755: PUSH
123756: LD_INT 1
123758: PLUS
123759: ST_TO_ADDR
// for i in tmp do
123760: LD_ADDR_VAR 0 1
123764: PUSH
123765: LD_VAR 0 2
123769: PUSH
123770: FOR_IN
123771: IFFALSE 123802
// if GetLives ( i ) < 1000 then
123773: LD_VAR 0 1
123777: PPUSH
123778: CALL_OW 256
123782: PUSH
123783: LD_INT 1000
123785: LESS
123786: IFFALSE 123800
// SetLives ( i , 1000 ) ;
123788: LD_VAR 0 1
123792: PPUSH
123793: LD_INT 1000
123795: PPUSH
123796: CALL_OW 234
123800: GO 123770
123802: POP
123803: POP
// until p > 20 ;
123804: LD_VAR 0 3
123808: PUSH
123809: LD_INT 20
123811: GREATER
123812: IFFALSE 123739
// end ;
123814: PPOPN 3
123816: END
// every 0 0$1 trigger StreamModeActive and sTime do
123817: LD_EXP 147
123821: PUSH
123822: LD_EXP 198
123826: AND
123827: IFFALSE 123862
123829: GO 123831
123831: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
123832: LD_INT 28
123834: PPUSH
123835: LD_OWVAR 2
123839: PPUSH
123840: LD_INT 2
123842: PPUSH
123843: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
123847: LD_INT 30
123849: PPUSH
123850: LD_OWVAR 2
123854: PPUSH
123855: LD_INT 2
123857: PPUSH
123858: CALL_OW 322
// end ;
123862: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
123863: LD_EXP 147
123867: PUSH
123868: LD_EXP 199
123872: AND
123873: IFFALSE 123994
123875: GO 123877
123877: DISABLE
123878: LD_INT 0
123880: PPUSH
123881: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
123882: LD_ADDR_VAR 0 2
123886: PUSH
123887: LD_INT 22
123889: PUSH
123890: LD_OWVAR 2
123894: PUSH
123895: EMPTY
123896: LIST
123897: LIST
123898: PUSH
123899: LD_INT 21
123901: PUSH
123902: LD_INT 1
123904: PUSH
123905: EMPTY
123906: LIST
123907: LIST
123908: PUSH
123909: LD_INT 3
123911: PUSH
123912: LD_INT 23
123914: PUSH
123915: LD_INT 0
123917: PUSH
123918: EMPTY
123919: LIST
123920: LIST
123921: PUSH
123922: EMPTY
123923: LIST
123924: LIST
123925: PUSH
123926: EMPTY
123927: LIST
123928: LIST
123929: LIST
123930: PPUSH
123931: CALL_OW 69
123935: ST_TO_ADDR
// if not tmp then
123936: LD_VAR 0 2
123940: NOT
123941: IFFALSE 123945
// exit ;
123943: GO 123994
// for i in tmp do
123945: LD_ADDR_VAR 0 1
123949: PUSH
123950: LD_VAR 0 2
123954: PUSH
123955: FOR_IN
123956: IFFALSE 123992
// begin if Crawls ( i ) then
123958: LD_VAR 0 1
123962: PPUSH
123963: CALL_OW 318
123967: IFFALSE 123978
// ComWalk ( i ) ;
123969: LD_VAR 0 1
123973: PPUSH
123974: CALL_OW 138
// SetClass ( i , 2 ) ;
123978: LD_VAR 0 1
123982: PPUSH
123983: LD_INT 2
123985: PPUSH
123986: CALL_OW 336
// end ;
123990: GO 123955
123992: POP
123993: POP
// end ;
123994: PPOPN 2
123996: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
123997: LD_EXP 147
124001: PUSH
124002: LD_EXP 200
124006: AND
124007: IFFALSE 124295
124009: GO 124011
124011: DISABLE
124012: LD_INT 0
124014: PPUSH
124015: PPUSH
124016: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
124017: LD_OWVAR 2
124021: PPUSH
124022: LD_INT 9
124024: PPUSH
124025: LD_INT 1
124027: PPUSH
124028: LD_INT 1
124030: PPUSH
124031: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
124035: LD_INT 9
124037: PPUSH
124038: LD_OWVAR 2
124042: PPUSH
124043: CALL_OW 343
// uc_side := 9 ;
124047: LD_ADDR_OWVAR 20
124051: PUSH
124052: LD_INT 9
124054: ST_TO_ADDR
// uc_nation := 2 ;
124055: LD_ADDR_OWVAR 21
124059: PUSH
124060: LD_INT 2
124062: ST_TO_ADDR
// hc_name := Dark Warrior ;
124063: LD_ADDR_OWVAR 26
124067: PUSH
124068: LD_STRING Dark Warrior
124070: ST_TO_ADDR
// hc_gallery :=  ;
124071: LD_ADDR_OWVAR 33
124075: PUSH
124076: LD_STRING 
124078: ST_TO_ADDR
// hc_noskilllimit := true ;
124079: LD_ADDR_OWVAR 76
124083: PUSH
124084: LD_INT 1
124086: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
124087: LD_ADDR_OWVAR 31
124091: PUSH
124092: LD_INT 30
124094: PUSH
124095: LD_INT 30
124097: PUSH
124098: LD_INT 30
124100: PUSH
124101: LD_INT 30
124103: PUSH
124104: EMPTY
124105: LIST
124106: LIST
124107: LIST
124108: LIST
124109: ST_TO_ADDR
// un := CreateHuman ;
124110: LD_ADDR_VAR 0 3
124114: PUSH
124115: CALL_OW 44
124119: ST_TO_ADDR
// hc_noskilllimit := false ;
124120: LD_ADDR_OWVAR 76
124124: PUSH
124125: LD_INT 0
124127: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
124128: LD_VAR 0 3
124132: PPUSH
124133: LD_INT 1
124135: PPUSH
124136: CALL_OW 51
// ToLua ( playRanger() ) ;
124140: LD_STRING playRanger()
124142: PPUSH
124143: CALL_OW 559
// p := 0 ;
124147: LD_ADDR_VAR 0 2
124151: PUSH
124152: LD_INT 0
124154: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
124155: LD_INT 35
124157: PPUSH
124158: CALL_OW 67
// p := p + 1 ;
124162: LD_ADDR_VAR 0 2
124166: PUSH
124167: LD_VAR 0 2
124171: PUSH
124172: LD_INT 1
124174: PLUS
124175: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
124176: LD_VAR 0 3
124180: PPUSH
124181: CALL_OW 256
124185: PUSH
124186: LD_INT 1000
124188: LESS
124189: IFFALSE 124203
// SetLives ( un , 1000 ) ;
124191: LD_VAR 0 3
124195: PPUSH
124196: LD_INT 1000
124198: PPUSH
124199: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
124203: LD_VAR 0 3
124207: PPUSH
124208: LD_INT 81
124210: PUSH
124211: LD_OWVAR 2
124215: PUSH
124216: EMPTY
124217: LIST
124218: LIST
124219: PUSH
124220: LD_INT 91
124222: PUSH
124223: LD_VAR 0 3
124227: PUSH
124228: LD_INT 30
124230: PUSH
124231: EMPTY
124232: LIST
124233: LIST
124234: LIST
124235: PUSH
124236: EMPTY
124237: LIST
124238: LIST
124239: PPUSH
124240: CALL_OW 69
124244: PPUSH
124245: LD_VAR 0 3
124249: PPUSH
124250: CALL_OW 74
124254: PPUSH
124255: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
124259: LD_VAR 0 2
124263: PUSH
124264: LD_INT 80
124266: GREATER
124267: PUSH
124268: LD_VAR 0 3
124272: PPUSH
124273: CALL_OW 301
124277: OR
124278: IFFALSE 124155
// if un then
124280: LD_VAR 0 3
124284: IFFALSE 124295
// RemoveUnit ( un ) ;
124286: LD_VAR 0 3
124290: PPUSH
124291: CALL_OW 64
// end ;
124295: PPOPN 3
124297: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
124298: LD_EXP 201
124302: IFFALSE 124418
124304: GO 124306
124306: DISABLE
124307: LD_INT 0
124309: PPUSH
124310: PPUSH
124311: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
124312: LD_ADDR_VAR 0 2
124316: PUSH
124317: LD_INT 81
124319: PUSH
124320: LD_OWVAR 2
124324: PUSH
124325: EMPTY
124326: LIST
124327: LIST
124328: PUSH
124329: LD_INT 21
124331: PUSH
124332: LD_INT 1
124334: PUSH
124335: EMPTY
124336: LIST
124337: LIST
124338: PUSH
124339: EMPTY
124340: LIST
124341: LIST
124342: PPUSH
124343: CALL_OW 69
124347: ST_TO_ADDR
// ToLua ( playComputer() ) ;
124348: LD_STRING playComputer()
124350: PPUSH
124351: CALL_OW 559
// if not tmp then
124355: LD_VAR 0 2
124359: NOT
124360: IFFALSE 124364
// exit ;
124362: GO 124418
// for i in tmp do
124364: LD_ADDR_VAR 0 1
124368: PUSH
124369: LD_VAR 0 2
124373: PUSH
124374: FOR_IN
124375: IFFALSE 124416
// for j := 1 to 4 do
124377: LD_ADDR_VAR 0 3
124381: PUSH
124382: DOUBLE
124383: LD_INT 1
124385: DEC
124386: ST_TO_ADDR
124387: LD_INT 4
124389: PUSH
124390: FOR_TO
124391: IFFALSE 124412
// SetSkill ( i , j , 10 ) ;
124393: LD_VAR 0 1
124397: PPUSH
124398: LD_VAR 0 3
124402: PPUSH
124403: LD_INT 10
124405: PPUSH
124406: CALL_OW 237
124410: GO 124390
124412: POP
124413: POP
124414: GO 124374
124416: POP
124417: POP
// end ;
124418: PPOPN 3
124420: END
// every 0 0$1 trigger s30 do var i , tmp ;
124421: LD_EXP 202
124425: IFFALSE 124494
124427: GO 124429
124429: DISABLE
124430: LD_INT 0
124432: PPUSH
124433: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
124434: LD_ADDR_VAR 0 2
124438: PUSH
124439: LD_INT 22
124441: PUSH
124442: LD_OWVAR 2
124446: PUSH
124447: EMPTY
124448: LIST
124449: LIST
124450: PPUSH
124451: CALL_OW 69
124455: ST_TO_ADDR
// if not tmp then
124456: LD_VAR 0 2
124460: NOT
124461: IFFALSE 124465
// exit ;
124463: GO 124494
// for i in tmp do
124465: LD_ADDR_VAR 0 1
124469: PUSH
124470: LD_VAR 0 2
124474: PUSH
124475: FOR_IN
124476: IFFALSE 124492
// SetLives ( i , 300 ) ;
124478: LD_VAR 0 1
124482: PPUSH
124483: LD_INT 300
124485: PPUSH
124486: CALL_OW 234
124490: GO 124475
124492: POP
124493: POP
// end ;
124494: PPOPN 2
124496: END
// every 0 0$1 trigger s60 do var i , tmp ;
124497: LD_EXP 203
124501: IFFALSE 124570
124503: GO 124505
124505: DISABLE
124506: LD_INT 0
124508: PPUSH
124509: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
124510: LD_ADDR_VAR 0 2
124514: PUSH
124515: LD_INT 22
124517: PUSH
124518: LD_OWVAR 2
124522: PUSH
124523: EMPTY
124524: LIST
124525: LIST
124526: PPUSH
124527: CALL_OW 69
124531: ST_TO_ADDR
// if not tmp then
124532: LD_VAR 0 2
124536: NOT
124537: IFFALSE 124541
// exit ;
124539: GO 124570
// for i in tmp do
124541: LD_ADDR_VAR 0 1
124545: PUSH
124546: LD_VAR 0 2
124550: PUSH
124551: FOR_IN
124552: IFFALSE 124568
// SetLives ( i , 600 ) ;
124554: LD_VAR 0 1
124558: PPUSH
124559: LD_INT 600
124561: PPUSH
124562: CALL_OW 234
124566: GO 124551
124568: POP
124569: POP
// end ;
124570: PPOPN 2
124572: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
124573: LD_INT 0
124575: PPUSH
// case cmd of 301 :
124576: LD_VAR 0 1
124580: PUSH
124581: LD_INT 301
124583: DOUBLE
124584: EQUAL
124585: IFTRUE 124589
124587: GO 124621
124589: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
124590: LD_VAR 0 6
124594: PPUSH
124595: LD_VAR 0 7
124599: PPUSH
124600: LD_VAR 0 8
124604: PPUSH
124605: LD_VAR 0 4
124609: PPUSH
124610: LD_VAR 0 5
124614: PPUSH
124615: CALL 125830 0 5
124619: GO 124742
124621: LD_INT 302
124623: DOUBLE
124624: EQUAL
124625: IFTRUE 124629
124627: GO 124666
124629: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
124630: LD_VAR 0 6
124634: PPUSH
124635: LD_VAR 0 7
124639: PPUSH
124640: LD_VAR 0 8
124644: PPUSH
124645: LD_VAR 0 9
124649: PPUSH
124650: LD_VAR 0 4
124654: PPUSH
124655: LD_VAR 0 5
124659: PPUSH
124660: CALL 125921 0 6
124664: GO 124742
124666: LD_INT 303
124668: DOUBLE
124669: EQUAL
124670: IFTRUE 124674
124672: GO 124711
124674: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
124675: LD_VAR 0 6
124679: PPUSH
124680: LD_VAR 0 7
124684: PPUSH
124685: LD_VAR 0 8
124689: PPUSH
124690: LD_VAR 0 9
124694: PPUSH
124695: LD_VAR 0 4
124699: PPUSH
124700: LD_VAR 0 5
124704: PPUSH
124705: CALL 124747 0 6
124709: GO 124742
124711: LD_INT 304
124713: DOUBLE
124714: EQUAL
124715: IFTRUE 124719
124717: GO 124741
124719: POP
// hHackTeleport ( unit , x , y ) ; end ;
124720: LD_VAR 0 2
124724: PPUSH
124725: LD_VAR 0 4
124729: PPUSH
124730: LD_VAR 0 5
124734: PPUSH
124735: CALL 126514 0 3
124739: GO 124742
124741: POP
// end ;
124742: LD_VAR 0 12
124746: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
124747: LD_INT 0
124749: PPUSH
124750: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
124751: LD_VAR 0 1
124755: PUSH
124756: LD_INT 1
124758: LESS
124759: PUSH
124760: LD_VAR 0 1
124764: PUSH
124765: LD_INT 3
124767: GREATER
124768: OR
124769: PUSH
124770: LD_VAR 0 5
124774: PPUSH
124775: LD_VAR 0 6
124779: PPUSH
124780: CALL_OW 428
124784: OR
124785: IFFALSE 124789
// exit ;
124787: GO 125517
// uc_side := your_side ;
124789: LD_ADDR_OWVAR 20
124793: PUSH
124794: LD_OWVAR 2
124798: ST_TO_ADDR
// uc_nation := nation ;
124799: LD_ADDR_OWVAR 21
124803: PUSH
124804: LD_VAR 0 1
124808: ST_TO_ADDR
// bc_level = 1 ;
124809: LD_ADDR_OWVAR 43
124813: PUSH
124814: LD_INT 1
124816: ST_TO_ADDR
// case btype of 1 :
124817: LD_VAR 0 2
124821: PUSH
124822: LD_INT 1
124824: DOUBLE
124825: EQUAL
124826: IFTRUE 124830
124828: GO 124841
124830: POP
// bc_type := b_depot ; 2 :
124831: LD_ADDR_OWVAR 42
124835: PUSH
124836: LD_INT 0
124838: ST_TO_ADDR
124839: GO 125461
124841: LD_INT 2
124843: DOUBLE
124844: EQUAL
124845: IFTRUE 124849
124847: GO 124860
124849: POP
// bc_type := b_warehouse ; 3 :
124850: LD_ADDR_OWVAR 42
124854: PUSH
124855: LD_INT 1
124857: ST_TO_ADDR
124858: GO 125461
124860: LD_INT 3
124862: DOUBLE
124863: EQUAL
124864: IFTRUE 124868
124866: GO 124879
124868: POP
// bc_type := b_lab ; 4 .. 9 :
124869: LD_ADDR_OWVAR 42
124873: PUSH
124874: LD_INT 6
124876: ST_TO_ADDR
124877: GO 125461
124879: LD_INT 4
124881: DOUBLE
124882: GREATEREQUAL
124883: IFFALSE 124891
124885: LD_INT 9
124887: DOUBLE
124888: LESSEQUAL
124889: IFTRUE 124893
124891: GO 124953
124893: POP
// begin bc_type := b_lab_half ;
124894: LD_ADDR_OWVAR 42
124898: PUSH
124899: LD_INT 7
124901: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
124902: LD_ADDR_OWVAR 44
124906: PUSH
124907: LD_INT 10
124909: PUSH
124910: LD_INT 11
124912: PUSH
124913: LD_INT 12
124915: PUSH
124916: LD_INT 15
124918: PUSH
124919: LD_INT 14
124921: PUSH
124922: LD_INT 13
124924: PUSH
124925: EMPTY
124926: LIST
124927: LIST
124928: LIST
124929: LIST
124930: LIST
124931: LIST
124932: PUSH
124933: LD_VAR 0 2
124937: PUSH
124938: LD_INT 3
124940: MINUS
124941: ARRAY
124942: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
124943: LD_ADDR_OWVAR 45
124947: PUSH
124948: LD_INT 9
124950: ST_TO_ADDR
// end ; 10 .. 13 :
124951: GO 125461
124953: LD_INT 10
124955: DOUBLE
124956: GREATEREQUAL
124957: IFFALSE 124965
124959: LD_INT 13
124961: DOUBLE
124962: LESSEQUAL
124963: IFTRUE 124967
124965: GO 125044
124967: POP
// begin bc_type := b_lab_full ;
124968: LD_ADDR_OWVAR 42
124972: PUSH
124973: LD_INT 8
124975: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
124976: LD_ADDR_OWVAR 44
124980: PUSH
124981: LD_INT 10
124983: PUSH
124984: LD_INT 12
124986: PUSH
124987: LD_INT 14
124989: PUSH
124990: LD_INT 13
124992: PUSH
124993: EMPTY
124994: LIST
124995: LIST
124996: LIST
124997: LIST
124998: PUSH
124999: LD_VAR 0 2
125003: PUSH
125004: LD_INT 9
125006: MINUS
125007: ARRAY
125008: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
125009: LD_ADDR_OWVAR 45
125013: PUSH
125014: LD_INT 11
125016: PUSH
125017: LD_INT 15
125019: PUSH
125020: LD_INT 12
125022: PUSH
125023: LD_INT 15
125025: PUSH
125026: EMPTY
125027: LIST
125028: LIST
125029: LIST
125030: LIST
125031: PUSH
125032: LD_VAR 0 2
125036: PUSH
125037: LD_INT 9
125039: MINUS
125040: ARRAY
125041: ST_TO_ADDR
// end ; 14 :
125042: GO 125461
125044: LD_INT 14
125046: DOUBLE
125047: EQUAL
125048: IFTRUE 125052
125050: GO 125063
125052: POP
// bc_type := b_workshop ; 15 :
125053: LD_ADDR_OWVAR 42
125057: PUSH
125058: LD_INT 2
125060: ST_TO_ADDR
125061: GO 125461
125063: LD_INT 15
125065: DOUBLE
125066: EQUAL
125067: IFTRUE 125071
125069: GO 125082
125071: POP
// bc_type := b_factory ; 16 :
125072: LD_ADDR_OWVAR 42
125076: PUSH
125077: LD_INT 3
125079: ST_TO_ADDR
125080: GO 125461
125082: LD_INT 16
125084: DOUBLE
125085: EQUAL
125086: IFTRUE 125090
125088: GO 125101
125090: POP
// bc_type := b_ext_gun ; 17 :
125091: LD_ADDR_OWVAR 42
125095: PUSH
125096: LD_INT 17
125098: ST_TO_ADDR
125099: GO 125461
125101: LD_INT 17
125103: DOUBLE
125104: EQUAL
125105: IFTRUE 125109
125107: GO 125137
125109: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
125110: LD_ADDR_OWVAR 42
125114: PUSH
125115: LD_INT 19
125117: PUSH
125118: LD_INT 23
125120: PUSH
125121: LD_INT 19
125123: PUSH
125124: EMPTY
125125: LIST
125126: LIST
125127: LIST
125128: PUSH
125129: LD_VAR 0 1
125133: ARRAY
125134: ST_TO_ADDR
125135: GO 125461
125137: LD_INT 18
125139: DOUBLE
125140: EQUAL
125141: IFTRUE 125145
125143: GO 125156
125145: POP
// bc_type := b_ext_radar ; 19 :
125146: LD_ADDR_OWVAR 42
125150: PUSH
125151: LD_INT 20
125153: ST_TO_ADDR
125154: GO 125461
125156: LD_INT 19
125158: DOUBLE
125159: EQUAL
125160: IFTRUE 125164
125162: GO 125175
125164: POP
// bc_type := b_ext_radio ; 20 :
125165: LD_ADDR_OWVAR 42
125169: PUSH
125170: LD_INT 22
125172: ST_TO_ADDR
125173: GO 125461
125175: LD_INT 20
125177: DOUBLE
125178: EQUAL
125179: IFTRUE 125183
125181: GO 125194
125183: POP
// bc_type := b_ext_siberium ; 21 :
125184: LD_ADDR_OWVAR 42
125188: PUSH
125189: LD_INT 21
125191: ST_TO_ADDR
125192: GO 125461
125194: LD_INT 21
125196: DOUBLE
125197: EQUAL
125198: IFTRUE 125202
125200: GO 125213
125202: POP
// bc_type := b_ext_computer ; 22 :
125203: LD_ADDR_OWVAR 42
125207: PUSH
125208: LD_INT 24
125210: ST_TO_ADDR
125211: GO 125461
125213: LD_INT 22
125215: DOUBLE
125216: EQUAL
125217: IFTRUE 125221
125219: GO 125232
125221: POP
// bc_type := b_ext_track ; 23 :
125222: LD_ADDR_OWVAR 42
125226: PUSH
125227: LD_INT 16
125229: ST_TO_ADDR
125230: GO 125461
125232: LD_INT 23
125234: DOUBLE
125235: EQUAL
125236: IFTRUE 125240
125238: GO 125251
125240: POP
// bc_type := b_ext_laser ; 24 :
125241: LD_ADDR_OWVAR 42
125245: PUSH
125246: LD_INT 25
125248: ST_TO_ADDR
125249: GO 125461
125251: LD_INT 24
125253: DOUBLE
125254: EQUAL
125255: IFTRUE 125259
125257: GO 125270
125259: POP
// bc_type := b_control_tower ; 25 :
125260: LD_ADDR_OWVAR 42
125264: PUSH
125265: LD_INT 36
125267: ST_TO_ADDR
125268: GO 125461
125270: LD_INT 25
125272: DOUBLE
125273: EQUAL
125274: IFTRUE 125278
125276: GO 125289
125278: POP
// bc_type := b_breastwork ; 26 :
125279: LD_ADDR_OWVAR 42
125283: PUSH
125284: LD_INT 31
125286: ST_TO_ADDR
125287: GO 125461
125289: LD_INT 26
125291: DOUBLE
125292: EQUAL
125293: IFTRUE 125297
125295: GO 125308
125297: POP
// bc_type := b_bunker ; 27 :
125298: LD_ADDR_OWVAR 42
125302: PUSH
125303: LD_INT 32
125305: ST_TO_ADDR
125306: GO 125461
125308: LD_INT 27
125310: DOUBLE
125311: EQUAL
125312: IFTRUE 125316
125314: GO 125327
125316: POP
// bc_type := b_turret ; 28 :
125317: LD_ADDR_OWVAR 42
125321: PUSH
125322: LD_INT 33
125324: ST_TO_ADDR
125325: GO 125461
125327: LD_INT 28
125329: DOUBLE
125330: EQUAL
125331: IFTRUE 125335
125333: GO 125346
125335: POP
// bc_type := b_armoury ; 29 :
125336: LD_ADDR_OWVAR 42
125340: PUSH
125341: LD_INT 4
125343: ST_TO_ADDR
125344: GO 125461
125346: LD_INT 29
125348: DOUBLE
125349: EQUAL
125350: IFTRUE 125354
125352: GO 125365
125354: POP
// bc_type := b_barracks ; 30 :
125355: LD_ADDR_OWVAR 42
125359: PUSH
125360: LD_INT 5
125362: ST_TO_ADDR
125363: GO 125461
125365: LD_INT 30
125367: DOUBLE
125368: EQUAL
125369: IFTRUE 125373
125371: GO 125384
125373: POP
// bc_type := b_solar_power ; 31 :
125374: LD_ADDR_OWVAR 42
125378: PUSH
125379: LD_INT 27
125381: ST_TO_ADDR
125382: GO 125461
125384: LD_INT 31
125386: DOUBLE
125387: EQUAL
125388: IFTRUE 125392
125390: GO 125403
125392: POP
// bc_type := b_oil_power ; 32 :
125393: LD_ADDR_OWVAR 42
125397: PUSH
125398: LD_INT 26
125400: ST_TO_ADDR
125401: GO 125461
125403: LD_INT 32
125405: DOUBLE
125406: EQUAL
125407: IFTRUE 125411
125409: GO 125422
125411: POP
// bc_type := b_siberite_power ; 33 :
125412: LD_ADDR_OWVAR 42
125416: PUSH
125417: LD_INT 28
125419: ST_TO_ADDR
125420: GO 125461
125422: LD_INT 33
125424: DOUBLE
125425: EQUAL
125426: IFTRUE 125430
125428: GO 125441
125430: POP
// bc_type := b_oil_mine ; 34 :
125431: LD_ADDR_OWVAR 42
125435: PUSH
125436: LD_INT 29
125438: ST_TO_ADDR
125439: GO 125461
125441: LD_INT 34
125443: DOUBLE
125444: EQUAL
125445: IFTRUE 125449
125447: GO 125460
125449: POP
// bc_type := b_siberite_mine ; end ;
125450: LD_ADDR_OWVAR 42
125454: PUSH
125455: LD_INT 30
125457: ST_TO_ADDR
125458: GO 125461
125460: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
125461: LD_ADDR_VAR 0 8
125465: PUSH
125466: LD_VAR 0 5
125470: PPUSH
125471: LD_VAR 0 6
125475: PPUSH
125476: LD_VAR 0 3
125480: PPUSH
125481: CALL_OW 47
125485: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
125486: LD_OWVAR 42
125490: PUSH
125491: LD_INT 32
125493: PUSH
125494: LD_INT 33
125496: PUSH
125497: EMPTY
125498: LIST
125499: LIST
125500: IN
125501: IFFALSE 125517
// PlaceWeaponTurret ( b , weapon ) ;
125503: LD_VAR 0 8
125507: PPUSH
125508: LD_VAR 0 4
125512: PPUSH
125513: CALL_OW 431
// end ;
125517: LD_VAR 0 7
125521: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
125522: LD_INT 0
125524: PPUSH
125525: PPUSH
125526: PPUSH
125527: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
125528: LD_ADDR_VAR 0 4
125532: PUSH
125533: LD_INT 22
125535: PUSH
125536: LD_OWVAR 2
125540: PUSH
125541: EMPTY
125542: LIST
125543: LIST
125544: PUSH
125545: LD_INT 2
125547: PUSH
125548: LD_INT 30
125550: PUSH
125551: LD_INT 0
125553: PUSH
125554: EMPTY
125555: LIST
125556: LIST
125557: PUSH
125558: LD_INT 30
125560: PUSH
125561: LD_INT 1
125563: PUSH
125564: EMPTY
125565: LIST
125566: LIST
125567: PUSH
125568: EMPTY
125569: LIST
125570: LIST
125571: LIST
125572: PUSH
125573: EMPTY
125574: LIST
125575: LIST
125576: PPUSH
125577: CALL_OW 69
125581: ST_TO_ADDR
// if not tmp then
125582: LD_VAR 0 4
125586: NOT
125587: IFFALSE 125591
// exit ;
125589: GO 125650
// for i in tmp do
125591: LD_ADDR_VAR 0 2
125595: PUSH
125596: LD_VAR 0 4
125600: PUSH
125601: FOR_IN
125602: IFFALSE 125648
// for j = 1 to 3 do
125604: LD_ADDR_VAR 0 3
125608: PUSH
125609: DOUBLE
125610: LD_INT 1
125612: DEC
125613: ST_TO_ADDR
125614: LD_INT 3
125616: PUSH
125617: FOR_TO
125618: IFFALSE 125644
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
125620: LD_VAR 0 2
125624: PPUSH
125625: CALL_OW 274
125629: PPUSH
125630: LD_VAR 0 3
125634: PPUSH
125635: LD_INT 99999
125637: PPUSH
125638: CALL_OW 277
125642: GO 125617
125644: POP
125645: POP
125646: GO 125601
125648: POP
125649: POP
// end ;
125650: LD_VAR 0 1
125654: RET
// export function hHackSetLevel10 ; var i , j ; begin
125655: LD_INT 0
125657: PPUSH
125658: PPUSH
125659: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
125660: LD_ADDR_VAR 0 2
125664: PUSH
125665: LD_INT 21
125667: PUSH
125668: LD_INT 1
125670: PUSH
125671: EMPTY
125672: LIST
125673: LIST
125674: PPUSH
125675: CALL_OW 69
125679: PUSH
125680: FOR_IN
125681: IFFALSE 125733
// if IsSelected ( i ) then
125683: LD_VAR 0 2
125687: PPUSH
125688: CALL_OW 306
125692: IFFALSE 125731
// begin for j := 1 to 4 do
125694: LD_ADDR_VAR 0 3
125698: PUSH
125699: DOUBLE
125700: LD_INT 1
125702: DEC
125703: ST_TO_ADDR
125704: LD_INT 4
125706: PUSH
125707: FOR_TO
125708: IFFALSE 125729
// SetSkill ( i , j , 10 ) ;
125710: LD_VAR 0 2
125714: PPUSH
125715: LD_VAR 0 3
125719: PPUSH
125720: LD_INT 10
125722: PPUSH
125723: CALL_OW 237
125727: GO 125707
125729: POP
125730: POP
// end ;
125731: GO 125680
125733: POP
125734: POP
// end ;
125735: LD_VAR 0 1
125739: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
125740: LD_INT 0
125742: PPUSH
125743: PPUSH
125744: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
125745: LD_ADDR_VAR 0 2
125749: PUSH
125750: LD_INT 22
125752: PUSH
125753: LD_OWVAR 2
125757: PUSH
125758: EMPTY
125759: LIST
125760: LIST
125761: PUSH
125762: LD_INT 21
125764: PUSH
125765: LD_INT 1
125767: PUSH
125768: EMPTY
125769: LIST
125770: LIST
125771: PUSH
125772: EMPTY
125773: LIST
125774: LIST
125775: PPUSH
125776: CALL_OW 69
125780: PUSH
125781: FOR_IN
125782: IFFALSE 125823
// begin for j := 1 to 4 do
125784: LD_ADDR_VAR 0 3
125788: PUSH
125789: DOUBLE
125790: LD_INT 1
125792: DEC
125793: ST_TO_ADDR
125794: LD_INT 4
125796: PUSH
125797: FOR_TO
125798: IFFALSE 125819
// SetSkill ( i , j , 10 ) ;
125800: LD_VAR 0 2
125804: PPUSH
125805: LD_VAR 0 3
125809: PPUSH
125810: LD_INT 10
125812: PPUSH
125813: CALL_OW 237
125817: GO 125797
125819: POP
125820: POP
// end ;
125821: GO 125781
125823: POP
125824: POP
// end ;
125825: LD_VAR 0 1
125829: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
125830: LD_INT 0
125832: PPUSH
// uc_side := your_side ;
125833: LD_ADDR_OWVAR 20
125837: PUSH
125838: LD_OWVAR 2
125842: ST_TO_ADDR
// uc_nation := nation ;
125843: LD_ADDR_OWVAR 21
125847: PUSH
125848: LD_VAR 0 1
125852: ST_TO_ADDR
// InitHc ;
125853: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
125857: LD_INT 0
125859: PPUSH
125860: LD_VAR 0 2
125864: PPUSH
125865: LD_VAR 0 3
125869: PPUSH
125870: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
125874: LD_VAR 0 4
125878: PPUSH
125879: LD_VAR 0 5
125883: PPUSH
125884: CALL_OW 428
125888: PUSH
125889: LD_INT 0
125891: EQUAL
125892: IFFALSE 125916
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
125894: CALL_OW 44
125898: PPUSH
125899: LD_VAR 0 4
125903: PPUSH
125904: LD_VAR 0 5
125908: PPUSH
125909: LD_INT 1
125911: PPUSH
125912: CALL_OW 48
// end ;
125916: LD_VAR 0 6
125920: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
125921: LD_INT 0
125923: PPUSH
125924: PPUSH
// uc_side := your_side ;
125925: LD_ADDR_OWVAR 20
125929: PUSH
125930: LD_OWVAR 2
125934: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
125935: LD_VAR 0 1
125939: PUSH
125940: LD_INT 1
125942: PUSH
125943: LD_INT 2
125945: PUSH
125946: LD_INT 3
125948: PUSH
125949: LD_INT 4
125951: PUSH
125952: LD_INT 5
125954: PUSH
125955: EMPTY
125956: LIST
125957: LIST
125958: LIST
125959: LIST
125960: LIST
125961: IN
125962: IFFALSE 125974
// uc_nation := nation_american else
125964: LD_ADDR_OWVAR 21
125968: PUSH
125969: LD_INT 1
125971: ST_TO_ADDR
125972: GO 126017
// if chassis in [ 11 , 12 , 13 , 14 ] then
125974: LD_VAR 0 1
125978: PUSH
125979: LD_INT 11
125981: PUSH
125982: LD_INT 12
125984: PUSH
125985: LD_INT 13
125987: PUSH
125988: LD_INT 14
125990: PUSH
125991: EMPTY
125992: LIST
125993: LIST
125994: LIST
125995: LIST
125996: IN
125997: IFFALSE 126009
// uc_nation := nation_arabian else
125999: LD_ADDR_OWVAR 21
126003: PUSH
126004: LD_INT 2
126006: ST_TO_ADDR
126007: GO 126017
// uc_nation := nation_russian ;
126009: LD_ADDR_OWVAR 21
126013: PUSH
126014: LD_INT 3
126016: ST_TO_ADDR
// vc_chassis := chassis ;
126017: LD_ADDR_OWVAR 37
126021: PUSH
126022: LD_VAR 0 1
126026: ST_TO_ADDR
// vc_engine := engine ;
126027: LD_ADDR_OWVAR 39
126031: PUSH
126032: LD_VAR 0 2
126036: ST_TO_ADDR
// vc_control := control ;
126037: LD_ADDR_OWVAR 38
126041: PUSH
126042: LD_VAR 0 3
126046: ST_TO_ADDR
// vc_weapon := weapon ;
126047: LD_ADDR_OWVAR 40
126051: PUSH
126052: LD_VAR 0 4
126056: ST_TO_ADDR
// un := CreateVehicle ;
126057: LD_ADDR_VAR 0 8
126061: PUSH
126062: CALL_OW 45
126066: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
126067: LD_VAR 0 8
126071: PPUSH
126072: LD_INT 0
126074: PPUSH
126075: LD_INT 5
126077: PPUSH
126078: CALL_OW 12
126082: PPUSH
126083: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
126087: LD_VAR 0 8
126091: PPUSH
126092: LD_VAR 0 5
126096: PPUSH
126097: LD_VAR 0 6
126101: PPUSH
126102: LD_INT 1
126104: PPUSH
126105: CALL_OW 48
// end ;
126109: LD_VAR 0 7
126113: RET
// export hInvincible ; every 1 do
126114: GO 126116
126116: DISABLE
// hInvincible := [ ] ;
126117: LD_ADDR_EXP 204
126121: PUSH
126122: EMPTY
126123: ST_TO_ADDR
126124: END
// every 10 do var i ;
126125: GO 126127
126127: DISABLE
126128: LD_INT 0
126130: PPUSH
// begin enable ;
126131: ENABLE
// if not hInvincible then
126132: LD_EXP 204
126136: NOT
126137: IFFALSE 126141
// exit ;
126139: GO 126185
// for i in hInvincible do
126141: LD_ADDR_VAR 0 1
126145: PUSH
126146: LD_EXP 204
126150: PUSH
126151: FOR_IN
126152: IFFALSE 126183
// if GetLives ( i ) < 1000 then
126154: LD_VAR 0 1
126158: PPUSH
126159: CALL_OW 256
126163: PUSH
126164: LD_INT 1000
126166: LESS
126167: IFFALSE 126181
// SetLives ( i , 1000 ) ;
126169: LD_VAR 0 1
126173: PPUSH
126174: LD_INT 1000
126176: PPUSH
126177: CALL_OW 234
126181: GO 126151
126183: POP
126184: POP
// end ;
126185: PPOPN 1
126187: END
// export function hHackInvincible ; var i ; begin
126188: LD_INT 0
126190: PPUSH
126191: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
126192: LD_ADDR_VAR 0 2
126196: PUSH
126197: LD_INT 2
126199: PUSH
126200: LD_INT 21
126202: PUSH
126203: LD_INT 1
126205: PUSH
126206: EMPTY
126207: LIST
126208: LIST
126209: PUSH
126210: LD_INT 21
126212: PUSH
126213: LD_INT 2
126215: PUSH
126216: EMPTY
126217: LIST
126218: LIST
126219: PUSH
126220: EMPTY
126221: LIST
126222: LIST
126223: LIST
126224: PPUSH
126225: CALL_OW 69
126229: PUSH
126230: FOR_IN
126231: IFFALSE 126292
// if IsSelected ( i ) then
126233: LD_VAR 0 2
126237: PPUSH
126238: CALL_OW 306
126242: IFFALSE 126290
// begin if i in hInvincible then
126244: LD_VAR 0 2
126248: PUSH
126249: LD_EXP 204
126253: IN
126254: IFFALSE 126274
// hInvincible := hInvincible diff i else
126256: LD_ADDR_EXP 204
126260: PUSH
126261: LD_EXP 204
126265: PUSH
126266: LD_VAR 0 2
126270: DIFF
126271: ST_TO_ADDR
126272: GO 126290
// hInvincible := hInvincible union i ;
126274: LD_ADDR_EXP 204
126278: PUSH
126279: LD_EXP 204
126283: PUSH
126284: LD_VAR 0 2
126288: UNION
126289: ST_TO_ADDR
// end ;
126290: GO 126230
126292: POP
126293: POP
// end ;
126294: LD_VAR 0 1
126298: RET
// export function hHackInvisible ; var i , j ; begin
126299: LD_INT 0
126301: PPUSH
126302: PPUSH
126303: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
126304: LD_ADDR_VAR 0 2
126308: PUSH
126309: LD_INT 21
126311: PUSH
126312: LD_INT 1
126314: PUSH
126315: EMPTY
126316: LIST
126317: LIST
126318: PPUSH
126319: CALL_OW 69
126323: PUSH
126324: FOR_IN
126325: IFFALSE 126349
// if IsSelected ( i ) then
126327: LD_VAR 0 2
126331: PPUSH
126332: CALL_OW 306
126336: IFFALSE 126347
// ComForceInvisible ( i ) ;
126338: LD_VAR 0 2
126342: PPUSH
126343: CALL_OW 496
126347: GO 126324
126349: POP
126350: POP
// end ;
126351: LD_VAR 0 1
126355: RET
// export function hHackChangeYourSide ; begin
126356: LD_INT 0
126358: PPUSH
// if your_side = 8 then
126359: LD_OWVAR 2
126363: PUSH
126364: LD_INT 8
126366: EQUAL
126367: IFFALSE 126379
// your_side := 0 else
126369: LD_ADDR_OWVAR 2
126373: PUSH
126374: LD_INT 0
126376: ST_TO_ADDR
126377: GO 126393
// your_side := your_side + 1 ;
126379: LD_ADDR_OWVAR 2
126383: PUSH
126384: LD_OWVAR 2
126388: PUSH
126389: LD_INT 1
126391: PLUS
126392: ST_TO_ADDR
// end ;
126393: LD_VAR 0 1
126397: RET
// export function hHackChangeUnitSide ; var i , j ; begin
126398: LD_INT 0
126400: PPUSH
126401: PPUSH
126402: PPUSH
// for i in all_units do
126403: LD_ADDR_VAR 0 2
126407: PUSH
126408: LD_OWVAR 3
126412: PUSH
126413: FOR_IN
126414: IFFALSE 126492
// if IsSelected ( i ) then
126416: LD_VAR 0 2
126420: PPUSH
126421: CALL_OW 306
126425: IFFALSE 126490
// begin j := GetSide ( i ) ;
126427: LD_ADDR_VAR 0 3
126431: PUSH
126432: LD_VAR 0 2
126436: PPUSH
126437: CALL_OW 255
126441: ST_TO_ADDR
// if j = 8 then
126442: LD_VAR 0 3
126446: PUSH
126447: LD_INT 8
126449: EQUAL
126450: IFFALSE 126462
// j := 0 else
126452: LD_ADDR_VAR 0 3
126456: PUSH
126457: LD_INT 0
126459: ST_TO_ADDR
126460: GO 126476
// j := j + 1 ;
126462: LD_ADDR_VAR 0 3
126466: PUSH
126467: LD_VAR 0 3
126471: PUSH
126472: LD_INT 1
126474: PLUS
126475: ST_TO_ADDR
// SetSide ( i , j ) ;
126476: LD_VAR 0 2
126480: PPUSH
126481: LD_VAR 0 3
126485: PPUSH
126486: CALL_OW 235
// end ;
126490: GO 126413
126492: POP
126493: POP
// end ;
126494: LD_VAR 0 1
126498: RET
// export function hHackFog ; begin
126499: LD_INT 0
126501: PPUSH
// FogOff ( true ) ;
126502: LD_INT 1
126504: PPUSH
126505: CALL_OW 344
// end ;
126509: LD_VAR 0 1
126513: RET
// export function hHackTeleport ( unit , x , y ) ; begin
126514: LD_INT 0
126516: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
126517: LD_VAR 0 1
126521: PPUSH
126522: LD_VAR 0 2
126526: PPUSH
126527: LD_VAR 0 3
126531: PPUSH
126532: LD_INT 1
126534: PPUSH
126535: LD_INT 1
126537: PPUSH
126538: CALL_OW 483
// CenterOnXY ( x , y ) ;
126542: LD_VAR 0 2
126546: PPUSH
126547: LD_VAR 0 3
126551: PPUSH
126552: CALL_OW 84
// end ;
126556: LD_VAR 0 4
126560: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
126561: LD_INT 0
126563: PPUSH
126564: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
126565: LD_VAR 0 1
126569: NOT
126570: PUSH
126571: LD_VAR 0 2
126575: PPUSH
126576: LD_VAR 0 3
126580: PPUSH
126581: CALL_OW 488
126585: NOT
126586: OR
126587: PUSH
126588: LD_VAR 0 1
126592: PPUSH
126593: CALL_OW 266
126597: PUSH
126598: LD_INT 3
126600: NONEQUAL
126601: PUSH
126602: LD_VAR 0 1
126606: PPUSH
126607: CALL_OW 247
126611: PUSH
126612: LD_INT 1
126614: EQUAL
126615: NOT
126616: AND
126617: OR
126618: IFFALSE 126622
// exit ;
126620: GO 126771
// if GetType ( factory ) = unit_human then
126622: LD_VAR 0 1
126626: PPUSH
126627: CALL_OW 247
126631: PUSH
126632: LD_INT 1
126634: EQUAL
126635: IFFALSE 126652
// factory := IsInUnit ( factory ) ;
126637: LD_ADDR_VAR 0 1
126641: PUSH
126642: LD_VAR 0 1
126646: PPUSH
126647: CALL_OW 310
126651: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
126652: LD_VAR 0 1
126656: PPUSH
126657: CALL_OW 266
126661: PUSH
126662: LD_INT 3
126664: NONEQUAL
126665: IFFALSE 126669
// exit ;
126667: GO 126771
// if HexInfo ( x , y ) = factory then
126669: LD_VAR 0 2
126673: PPUSH
126674: LD_VAR 0 3
126678: PPUSH
126679: CALL_OW 428
126683: PUSH
126684: LD_VAR 0 1
126688: EQUAL
126689: IFFALSE 126716
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
126691: LD_ADDR_EXP 205
126695: PUSH
126696: LD_EXP 205
126700: PPUSH
126701: LD_VAR 0 1
126705: PPUSH
126706: LD_INT 0
126708: PPUSH
126709: CALL_OW 1
126713: ST_TO_ADDR
126714: GO 126767
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
126716: LD_ADDR_EXP 205
126720: PUSH
126721: LD_EXP 205
126725: PPUSH
126726: LD_VAR 0 1
126730: PPUSH
126731: LD_VAR 0 1
126735: PPUSH
126736: CALL_OW 255
126740: PUSH
126741: LD_VAR 0 1
126745: PUSH
126746: LD_VAR 0 2
126750: PUSH
126751: LD_VAR 0 3
126755: PUSH
126756: EMPTY
126757: LIST
126758: LIST
126759: LIST
126760: LIST
126761: PPUSH
126762: CALL_OW 1
126766: ST_TO_ADDR
// UpdateFactoryWaypoints ;
126767: CALL 126776 0 0
// end ;
126771: LD_VAR 0 4
126775: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
126776: LD_INT 0
126778: PPUSH
126779: PPUSH
126780: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
126781: LD_STRING resetFactoryWaypoint();
126783: PPUSH
126784: CALL_OW 559
// if factoryWaypoints then
126788: LD_EXP 205
126792: IFFALSE 126918
// begin list := PrepareArray ( factoryWaypoints ) ;
126794: LD_ADDR_VAR 0 3
126798: PUSH
126799: LD_EXP 205
126803: PPUSH
126804: CALL 110893 0 1
126808: ST_TO_ADDR
// for i := 1 to list do
126809: LD_ADDR_VAR 0 2
126813: PUSH
126814: DOUBLE
126815: LD_INT 1
126817: DEC
126818: ST_TO_ADDR
126819: LD_VAR 0 3
126823: PUSH
126824: FOR_TO
126825: IFFALSE 126916
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
126827: LD_STRING setFactoryWaypointXY(
126829: PUSH
126830: LD_VAR 0 3
126834: PUSH
126835: LD_VAR 0 2
126839: ARRAY
126840: PUSH
126841: LD_INT 1
126843: ARRAY
126844: STR
126845: PUSH
126846: LD_STRING ,
126848: STR
126849: PUSH
126850: LD_VAR 0 3
126854: PUSH
126855: LD_VAR 0 2
126859: ARRAY
126860: PUSH
126861: LD_INT 2
126863: ARRAY
126864: STR
126865: PUSH
126866: LD_STRING ,
126868: STR
126869: PUSH
126870: LD_VAR 0 3
126874: PUSH
126875: LD_VAR 0 2
126879: ARRAY
126880: PUSH
126881: LD_INT 3
126883: ARRAY
126884: STR
126885: PUSH
126886: LD_STRING ,
126888: STR
126889: PUSH
126890: LD_VAR 0 3
126894: PUSH
126895: LD_VAR 0 2
126899: ARRAY
126900: PUSH
126901: LD_INT 4
126903: ARRAY
126904: STR
126905: PUSH
126906: LD_STRING )
126908: STR
126909: PPUSH
126910: CALL_OW 559
126914: GO 126824
126916: POP
126917: POP
// end ; end ;
126918: LD_VAR 0 1
126922: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
126923: LD_INT 0
126925: PPUSH
// if HexInfo ( x , y ) = warehouse then
126926: LD_VAR 0 2
126930: PPUSH
126931: LD_VAR 0 3
126935: PPUSH
126936: CALL_OW 428
126940: PUSH
126941: LD_VAR 0 1
126945: EQUAL
126946: IFFALSE 126973
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
126948: LD_ADDR_EXP 206
126952: PUSH
126953: LD_EXP 206
126957: PPUSH
126958: LD_VAR 0 1
126962: PPUSH
126963: LD_INT 0
126965: PPUSH
126966: CALL_OW 1
126970: ST_TO_ADDR
126971: GO 127024
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
126973: LD_ADDR_EXP 206
126977: PUSH
126978: LD_EXP 206
126982: PPUSH
126983: LD_VAR 0 1
126987: PPUSH
126988: LD_VAR 0 1
126992: PPUSH
126993: CALL_OW 255
126997: PUSH
126998: LD_VAR 0 1
127002: PUSH
127003: LD_VAR 0 2
127007: PUSH
127008: LD_VAR 0 3
127012: PUSH
127013: EMPTY
127014: LIST
127015: LIST
127016: LIST
127017: LIST
127018: PPUSH
127019: CALL_OW 1
127023: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
127024: CALL 127033 0 0
// end ;
127028: LD_VAR 0 4
127032: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
127033: LD_INT 0
127035: PPUSH
127036: PPUSH
127037: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
127038: LD_STRING resetWarehouseGatheringPoints();
127040: PPUSH
127041: CALL_OW 559
// if warehouseGatheringPoints then
127045: LD_EXP 206
127049: IFFALSE 127175
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
127051: LD_ADDR_VAR 0 3
127055: PUSH
127056: LD_EXP 206
127060: PPUSH
127061: CALL 110893 0 1
127065: ST_TO_ADDR
// for i := 1 to list do
127066: LD_ADDR_VAR 0 2
127070: PUSH
127071: DOUBLE
127072: LD_INT 1
127074: DEC
127075: ST_TO_ADDR
127076: LD_VAR 0 3
127080: PUSH
127081: FOR_TO
127082: IFFALSE 127173
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
127084: LD_STRING setWarehouseGatheringPointXY(
127086: PUSH
127087: LD_VAR 0 3
127091: PUSH
127092: LD_VAR 0 2
127096: ARRAY
127097: PUSH
127098: LD_INT 1
127100: ARRAY
127101: STR
127102: PUSH
127103: LD_STRING ,
127105: STR
127106: PUSH
127107: LD_VAR 0 3
127111: PUSH
127112: LD_VAR 0 2
127116: ARRAY
127117: PUSH
127118: LD_INT 2
127120: ARRAY
127121: STR
127122: PUSH
127123: LD_STRING ,
127125: STR
127126: PUSH
127127: LD_VAR 0 3
127131: PUSH
127132: LD_VAR 0 2
127136: ARRAY
127137: PUSH
127138: LD_INT 3
127140: ARRAY
127141: STR
127142: PUSH
127143: LD_STRING ,
127145: STR
127146: PUSH
127147: LD_VAR 0 3
127151: PUSH
127152: LD_VAR 0 2
127156: ARRAY
127157: PUSH
127158: LD_INT 4
127160: ARRAY
127161: STR
127162: PUSH
127163: LD_STRING )
127165: STR
127166: PPUSH
127167: CALL_OW 559
127171: GO 127081
127173: POP
127174: POP
// end ; end ;
127175: LD_VAR 0 1
127179: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
127180: LD_EXP 206
127184: IFFALSE 127869
127186: GO 127188
127188: DISABLE
127189: LD_INT 0
127191: PPUSH
127192: PPUSH
127193: PPUSH
127194: PPUSH
127195: PPUSH
127196: PPUSH
127197: PPUSH
127198: PPUSH
127199: PPUSH
// begin enable ;
127200: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
127201: LD_ADDR_VAR 0 3
127205: PUSH
127206: LD_EXP 206
127210: PPUSH
127211: CALL 110893 0 1
127215: ST_TO_ADDR
// if not list then
127216: LD_VAR 0 3
127220: NOT
127221: IFFALSE 127225
// exit ;
127223: GO 127869
// for i := 1 to list do
127225: LD_ADDR_VAR 0 1
127229: PUSH
127230: DOUBLE
127231: LD_INT 1
127233: DEC
127234: ST_TO_ADDR
127235: LD_VAR 0 3
127239: PUSH
127240: FOR_TO
127241: IFFALSE 127867
// begin depot := list [ i ] [ 2 ] ;
127243: LD_ADDR_VAR 0 8
127247: PUSH
127248: LD_VAR 0 3
127252: PUSH
127253: LD_VAR 0 1
127257: ARRAY
127258: PUSH
127259: LD_INT 2
127261: ARRAY
127262: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
127263: LD_ADDR_VAR 0 5
127267: PUSH
127268: LD_VAR 0 3
127272: PUSH
127273: LD_VAR 0 1
127277: ARRAY
127278: PUSH
127279: LD_INT 1
127281: ARRAY
127282: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
127283: LD_VAR 0 8
127287: PPUSH
127288: CALL_OW 301
127292: PUSH
127293: LD_VAR 0 5
127297: PUSH
127298: LD_VAR 0 8
127302: PPUSH
127303: CALL_OW 255
127307: NONEQUAL
127308: OR
127309: IFFALSE 127338
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
127311: LD_ADDR_EXP 206
127315: PUSH
127316: LD_EXP 206
127320: PPUSH
127321: LD_VAR 0 8
127325: PPUSH
127326: LD_INT 0
127328: PPUSH
127329: CALL_OW 1
127333: ST_TO_ADDR
// exit ;
127334: POP
127335: POP
127336: GO 127869
// end ; x := list [ i ] [ 3 ] ;
127338: LD_ADDR_VAR 0 6
127342: PUSH
127343: LD_VAR 0 3
127347: PUSH
127348: LD_VAR 0 1
127352: ARRAY
127353: PUSH
127354: LD_INT 3
127356: ARRAY
127357: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
127358: LD_ADDR_VAR 0 7
127362: PUSH
127363: LD_VAR 0 3
127367: PUSH
127368: LD_VAR 0 1
127372: ARRAY
127373: PUSH
127374: LD_INT 4
127376: ARRAY
127377: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
127378: LD_ADDR_VAR 0 9
127382: PUSH
127383: LD_VAR 0 6
127387: PPUSH
127388: LD_VAR 0 7
127392: PPUSH
127393: LD_INT 16
127395: PPUSH
127396: CALL 109481 0 3
127400: ST_TO_ADDR
// if not cratesNearbyPoint then
127401: LD_VAR 0 9
127405: NOT
127406: IFFALSE 127412
// exit ;
127408: POP
127409: POP
127410: GO 127869
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
127412: LD_ADDR_VAR 0 4
127416: PUSH
127417: LD_INT 22
127419: PUSH
127420: LD_VAR 0 5
127424: PUSH
127425: EMPTY
127426: LIST
127427: LIST
127428: PUSH
127429: LD_INT 3
127431: PUSH
127432: LD_INT 60
127434: PUSH
127435: EMPTY
127436: LIST
127437: PUSH
127438: EMPTY
127439: LIST
127440: LIST
127441: PUSH
127442: LD_INT 91
127444: PUSH
127445: LD_VAR 0 8
127449: PUSH
127450: LD_INT 6
127452: PUSH
127453: EMPTY
127454: LIST
127455: LIST
127456: LIST
127457: PUSH
127458: LD_INT 2
127460: PUSH
127461: LD_INT 25
127463: PUSH
127464: LD_INT 2
127466: PUSH
127467: EMPTY
127468: LIST
127469: LIST
127470: PUSH
127471: LD_INT 25
127473: PUSH
127474: LD_INT 16
127476: PUSH
127477: EMPTY
127478: LIST
127479: LIST
127480: PUSH
127481: EMPTY
127482: LIST
127483: LIST
127484: LIST
127485: PUSH
127486: EMPTY
127487: LIST
127488: LIST
127489: LIST
127490: LIST
127491: PPUSH
127492: CALL_OW 69
127496: PUSH
127497: LD_VAR 0 8
127501: PPUSH
127502: CALL_OW 313
127506: PPUSH
127507: LD_INT 3
127509: PUSH
127510: LD_INT 60
127512: PUSH
127513: EMPTY
127514: LIST
127515: PUSH
127516: EMPTY
127517: LIST
127518: LIST
127519: PUSH
127520: LD_INT 2
127522: PUSH
127523: LD_INT 25
127525: PUSH
127526: LD_INT 2
127528: PUSH
127529: EMPTY
127530: LIST
127531: LIST
127532: PUSH
127533: LD_INT 25
127535: PUSH
127536: LD_INT 16
127538: PUSH
127539: EMPTY
127540: LIST
127541: LIST
127542: PUSH
127543: EMPTY
127544: LIST
127545: LIST
127546: LIST
127547: PUSH
127548: EMPTY
127549: LIST
127550: LIST
127551: PPUSH
127552: CALL_OW 72
127556: UNION
127557: ST_TO_ADDR
// if tmp then
127558: LD_VAR 0 4
127562: IFFALSE 127642
// begin tmp := ShrinkArray ( tmp , 3 ) ;
127564: LD_ADDR_VAR 0 4
127568: PUSH
127569: LD_VAR 0 4
127573: PPUSH
127574: LD_INT 3
127576: PPUSH
127577: CALL 107450 0 2
127581: ST_TO_ADDR
// for j in tmp do
127582: LD_ADDR_VAR 0 2
127586: PUSH
127587: LD_VAR 0 4
127591: PUSH
127592: FOR_IN
127593: IFFALSE 127636
// begin if IsInUnit ( j ) then
127595: LD_VAR 0 2
127599: PPUSH
127600: CALL_OW 310
127604: IFFALSE 127615
// ComExit ( j ) ;
127606: LD_VAR 0 2
127610: PPUSH
127611: CALL 107533 0 1
// AddComCollect ( j , x , y ) ;
127615: LD_VAR 0 2
127619: PPUSH
127620: LD_VAR 0 6
127624: PPUSH
127625: LD_VAR 0 7
127629: PPUSH
127630: CALL_OW 177
// end ;
127634: GO 127592
127636: POP
127637: POP
// exit ;
127638: POP
127639: POP
127640: GO 127869
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
127642: LD_ADDR_VAR 0 4
127646: PUSH
127647: LD_INT 22
127649: PUSH
127650: LD_VAR 0 5
127654: PUSH
127655: EMPTY
127656: LIST
127657: LIST
127658: PUSH
127659: LD_INT 91
127661: PUSH
127662: LD_VAR 0 8
127666: PUSH
127667: LD_INT 8
127669: PUSH
127670: EMPTY
127671: LIST
127672: LIST
127673: LIST
127674: PUSH
127675: LD_INT 2
127677: PUSH
127678: LD_INT 34
127680: PUSH
127681: LD_INT 12
127683: PUSH
127684: EMPTY
127685: LIST
127686: LIST
127687: PUSH
127688: LD_INT 34
127690: PUSH
127691: LD_INT 51
127693: PUSH
127694: EMPTY
127695: LIST
127696: LIST
127697: PUSH
127698: LD_INT 34
127700: PUSH
127701: LD_INT 32
127703: PUSH
127704: EMPTY
127705: LIST
127706: LIST
127707: PUSH
127708: LD_INT 34
127710: PUSH
127711: LD_INT 89
127713: PUSH
127714: EMPTY
127715: LIST
127716: LIST
127717: PUSH
127718: EMPTY
127719: LIST
127720: LIST
127721: LIST
127722: LIST
127723: LIST
127724: PUSH
127725: EMPTY
127726: LIST
127727: LIST
127728: LIST
127729: PPUSH
127730: CALL_OW 69
127734: ST_TO_ADDR
// if tmp then
127735: LD_VAR 0 4
127739: IFFALSE 127865
// begin for j in tmp do
127741: LD_ADDR_VAR 0 2
127745: PUSH
127746: LD_VAR 0 4
127750: PUSH
127751: FOR_IN
127752: IFFALSE 127863
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
127754: LD_VAR 0 2
127758: PPUSH
127759: CALL_OW 262
127763: PUSH
127764: LD_INT 3
127766: EQUAL
127767: PUSH
127768: LD_VAR 0 2
127772: PPUSH
127773: CALL_OW 261
127777: PUSH
127778: LD_INT 20
127780: GREATER
127781: OR
127782: PUSH
127783: LD_VAR 0 2
127787: PPUSH
127788: CALL_OW 314
127792: NOT
127793: AND
127794: PUSH
127795: LD_VAR 0 2
127799: PPUSH
127800: CALL_OW 263
127804: PUSH
127805: LD_INT 1
127807: NONEQUAL
127808: PUSH
127809: LD_VAR 0 2
127813: PPUSH
127814: CALL_OW 311
127818: OR
127819: AND
127820: IFFALSE 127861
// begin ComCollect ( j , x , y ) ;
127822: LD_VAR 0 2
127826: PPUSH
127827: LD_VAR 0 6
127831: PPUSH
127832: LD_VAR 0 7
127836: PPUSH
127837: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
127841: LD_VAR 0 2
127845: PPUSH
127846: LD_VAR 0 8
127850: PPUSH
127851: CALL_OW 172
// exit ;
127855: POP
127856: POP
127857: POP
127858: POP
127859: GO 127869
// end ;
127861: GO 127751
127863: POP
127864: POP
// end ; end ;
127865: GO 127240
127867: POP
127868: POP
// end ; end_of_file
127869: PPOPN 9
127871: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
127872: LD_INT 0
127874: PPUSH
127875: PPUSH
127876: PPUSH
127877: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
127878: LD_VAR 0 1
127882: PPUSH
127883: CALL_OW 264
127887: PUSH
127888: LD_INT 91
127890: EQUAL
127891: IFFALSE 127963
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
127893: LD_INT 68
127895: PPUSH
127896: LD_VAR 0 1
127900: PPUSH
127901: CALL_OW 255
127905: PPUSH
127906: CALL_OW 321
127910: PUSH
127911: LD_INT 2
127913: EQUAL
127914: IFFALSE 127926
// eff := 70 else
127916: LD_ADDR_VAR 0 4
127920: PUSH
127921: LD_INT 70
127923: ST_TO_ADDR
127924: GO 127934
// eff := 30 ;
127926: LD_ADDR_VAR 0 4
127930: PUSH
127931: LD_INT 30
127933: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
127934: LD_VAR 0 1
127938: PPUSH
127939: CALL_OW 250
127943: PPUSH
127944: LD_VAR 0 1
127948: PPUSH
127949: CALL_OW 251
127953: PPUSH
127954: LD_VAR 0 4
127958: PPUSH
127959: CALL_OW 495
// end ; end ;
127963: LD_VAR 0 2
127967: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
127968: LD_INT 0
127970: PPUSH
// end ;
127971: LD_VAR 0 4
127975: RET
// export function SOS_Command ( cmd ) ; begin
127976: LD_INT 0
127978: PPUSH
// end ;
127979: LD_VAR 0 2
127983: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
127984: LD_INT 0
127986: PPUSH
// end ;
127987: LD_VAR 0 6
127991: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
127992: LD_INT 0
127994: PPUSH
127995: PPUSH
// if not vehicle or not factory then
127996: LD_VAR 0 1
128000: NOT
128001: PUSH
128002: LD_VAR 0 2
128006: NOT
128007: OR
128008: IFFALSE 128012
// exit ;
128010: GO 128243
// if factoryWaypoints >= factory then
128012: LD_EXP 205
128016: PUSH
128017: LD_VAR 0 2
128021: GREATEREQUAL
128022: IFFALSE 128243
// if factoryWaypoints [ factory ] then
128024: LD_EXP 205
128028: PUSH
128029: LD_VAR 0 2
128033: ARRAY
128034: IFFALSE 128243
// begin if GetControl ( vehicle ) = control_manual then
128036: LD_VAR 0 1
128040: PPUSH
128041: CALL_OW 263
128045: PUSH
128046: LD_INT 1
128048: EQUAL
128049: IFFALSE 128130
// begin driver := IsDrivenBy ( vehicle ) ;
128051: LD_ADDR_VAR 0 4
128055: PUSH
128056: LD_VAR 0 1
128060: PPUSH
128061: CALL_OW 311
128065: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
128066: LD_VAR 0 4
128070: PPUSH
128071: LD_EXP 205
128075: PUSH
128076: LD_VAR 0 2
128080: ARRAY
128081: PUSH
128082: LD_INT 3
128084: ARRAY
128085: PPUSH
128086: LD_EXP 205
128090: PUSH
128091: LD_VAR 0 2
128095: ARRAY
128096: PUSH
128097: LD_INT 4
128099: ARRAY
128100: PPUSH
128101: CALL_OW 171
// AddComExitVehicle ( driver ) ;
128105: LD_VAR 0 4
128109: PPUSH
128110: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
128114: LD_VAR 0 4
128118: PPUSH
128119: LD_VAR 0 2
128123: PPUSH
128124: CALL_OW 180
// end else
128128: GO 128243
// if GetControl ( vehicle ) = control_remote then
128130: LD_VAR 0 1
128134: PPUSH
128135: CALL_OW 263
128139: PUSH
128140: LD_INT 2
128142: EQUAL
128143: IFFALSE 128204
// begin wait ( 0 0$2 ) ;
128145: LD_INT 70
128147: PPUSH
128148: CALL_OW 67
// if Connect ( vehicle ) then
128152: LD_VAR 0 1
128156: PPUSH
128157: CALL 77752 0 1
128161: IFFALSE 128202
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
128163: LD_VAR 0 1
128167: PPUSH
128168: LD_EXP 205
128172: PUSH
128173: LD_VAR 0 2
128177: ARRAY
128178: PUSH
128179: LD_INT 3
128181: ARRAY
128182: PPUSH
128183: LD_EXP 205
128187: PUSH
128188: LD_VAR 0 2
128192: ARRAY
128193: PUSH
128194: LD_INT 4
128196: ARRAY
128197: PPUSH
128198: CALL_OW 171
// end else
128202: GO 128243
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
128204: LD_VAR 0 1
128208: PPUSH
128209: LD_EXP 205
128213: PUSH
128214: LD_VAR 0 2
128218: ARRAY
128219: PUSH
128220: LD_INT 3
128222: ARRAY
128223: PPUSH
128224: LD_EXP 205
128228: PUSH
128229: LD_VAR 0 2
128233: ARRAY
128234: PUSH
128235: LD_INT 4
128237: ARRAY
128238: PPUSH
128239: CALL_OW 171
// end ; end ;
128243: LD_VAR 0 3
128247: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
128248: LD_INT 0
128250: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
128251: LD_VAR 0 1
128255: PUSH
128256: LD_INT 250
128258: EQUAL
128259: PUSH
128260: LD_VAR 0 2
128264: PPUSH
128265: CALL_OW 264
128269: PUSH
128270: LD_INT 81
128272: EQUAL
128273: AND
128274: IFFALSE 128295
// MinerPlaceMine ( unit , x , y ) ;
128276: LD_VAR 0 2
128280: PPUSH
128281: LD_VAR 0 4
128285: PPUSH
128286: LD_VAR 0 5
128290: PPUSH
128291: CALL 131285 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
128295: LD_VAR 0 1
128299: PUSH
128300: LD_INT 251
128302: EQUAL
128303: PUSH
128304: LD_VAR 0 2
128308: PPUSH
128309: CALL_OW 264
128313: PUSH
128314: LD_INT 81
128316: EQUAL
128317: AND
128318: IFFALSE 128339
// MinerDetonateMine ( unit , x , y ) ;
128320: LD_VAR 0 2
128324: PPUSH
128325: LD_VAR 0 4
128329: PPUSH
128330: LD_VAR 0 5
128334: PPUSH
128335: CALL 131560 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
128339: LD_VAR 0 1
128343: PUSH
128344: LD_INT 252
128346: EQUAL
128347: PUSH
128348: LD_VAR 0 2
128352: PPUSH
128353: CALL_OW 264
128357: PUSH
128358: LD_INT 81
128360: EQUAL
128361: AND
128362: IFFALSE 128383
// MinerCreateMinefield ( unit , x , y ) ;
128364: LD_VAR 0 2
128368: PPUSH
128369: LD_VAR 0 4
128373: PPUSH
128374: LD_VAR 0 5
128378: PPUSH
128379: CALL 131977 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
128383: LD_VAR 0 1
128387: PUSH
128388: LD_INT 253
128390: EQUAL
128391: PUSH
128392: LD_VAR 0 2
128396: PPUSH
128397: CALL_OW 257
128401: PUSH
128402: LD_INT 5
128404: EQUAL
128405: AND
128406: IFFALSE 128427
// ComBinocular ( unit , x , y ) ;
128408: LD_VAR 0 2
128412: PPUSH
128413: LD_VAR 0 4
128417: PPUSH
128418: LD_VAR 0 5
128422: PPUSH
128423: CALL 132346 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
128427: LD_VAR 0 1
128431: PUSH
128432: LD_INT 254
128434: EQUAL
128435: PUSH
128436: LD_VAR 0 2
128440: PPUSH
128441: CALL_OW 264
128445: PUSH
128446: LD_INT 99
128448: EQUAL
128449: AND
128450: PUSH
128451: LD_VAR 0 3
128455: PPUSH
128456: CALL_OW 263
128460: PUSH
128461: LD_INT 3
128463: EQUAL
128464: AND
128465: IFFALSE 128481
// HackDestroyVehicle ( unit , selectedUnit ) ;
128467: LD_VAR 0 2
128471: PPUSH
128472: LD_VAR 0 3
128476: PPUSH
128477: CALL 130649 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
128481: LD_VAR 0 1
128485: PUSH
128486: LD_INT 255
128488: EQUAL
128489: PUSH
128490: LD_VAR 0 2
128494: PPUSH
128495: CALL_OW 264
128499: PUSH
128500: LD_INT 14
128502: PUSH
128503: LD_INT 53
128505: PUSH
128506: EMPTY
128507: LIST
128508: LIST
128509: IN
128510: AND
128511: PUSH
128512: LD_VAR 0 4
128516: PPUSH
128517: LD_VAR 0 5
128521: PPUSH
128522: CALL_OW 488
128526: AND
128527: IFFALSE 128551
// CutTreeXYR ( unit , x , y , 12 ) ;
128529: LD_VAR 0 2
128533: PPUSH
128534: LD_VAR 0 4
128538: PPUSH
128539: LD_VAR 0 5
128543: PPUSH
128544: LD_INT 12
128546: PPUSH
128547: CALL 128646 0 4
// if cmd = 256 then
128551: LD_VAR 0 1
128555: PUSH
128556: LD_INT 256
128558: EQUAL
128559: IFFALSE 128580
// SetFactoryWaypoint ( unit , x , y ) ;
128561: LD_VAR 0 2
128565: PPUSH
128566: LD_VAR 0 4
128570: PPUSH
128571: LD_VAR 0 5
128575: PPUSH
128576: CALL 126561 0 3
// if cmd = 257 then
128580: LD_VAR 0 1
128584: PUSH
128585: LD_INT 257
128587: EQUAL
128588: IFFALSE 128609
// SetWarehouseGatheringPoint ( unit , x , y ) ;
128590: LD_VAR 0 2
128594: PPUSH
128595: LD_VAR 0 4
128599: PPUSH
128600: LD_VAR 0 5
128604: PPUSH
128605: CALL 126923 0 3
// if cmd = 258 then
128609: LD_VAR 0 1
128613: PUSH
128614: LD_INT 258
128616: EQUAL
128617: IFFALSE 128641
// BurnTreeXYR ( unit , x , y , 8 ) ;
128619: LD_VAR 0 2
128623: PPUSH
128624: LD_VAR 0 4
128628: PPUSH
128629: LD_VAR 0 5
128633: PPUSH
128634: LD_INT 8
128636: PPUSH
128637: CALL 129040 0 4
// end ;
128641: LD_VAR 0 6
128645: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
128646: LD_INT 0
128648: PPUSH
128649: PPUSH
128650: PPUSH
128651: PPUSH
128652: PPUSH
128653: PPUSH
128654: PPUSH
128655: PPUSH
128656: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
128657: LD_VAR 0 1
128661: PPUSH
128662: CALL_OW 302
128666: NOT
128667: PUSH
128668: LD_VAR 0 2
128672: PPUSH
128673: LD_VAR 0 3
128677: PPUSH
128678: CALL_OW 488
128682: NOT
128683: OR
128684: PUSH
128685: LD_VAR 0 4
128689: NOT
128690: OR
128691: IFFALSE 128695
// exit ;
128693: GO 129035
// list := [ ] ;
128695: LD_ADDR_VAR 0 13
128699: PUSH
128700: EMPTY
128701: ST_TO_ADDR
// if x - r < 0 then
128702: LD_VAR 0 2
128706: PUSH
128707: LD_VAR 0 4
128711: MINUS
128712: PUSH
128713: LD_INT 0
128715: LESS
128716: IFFALSE 128728
// min_x := 0 else
128718: LD_ADDR_VAR 0 7
128722: PUSH
128723: LD_INT 0
128725: ST_TO_ADDR
128726: GO 128744
// min_x := x - r ;
128728: LD_ADDR_VAR 0 7
128732: PUSH
128733: LD_VAR 0 2
128737: PUSH
128738: LD_VAR 0 4
128742: MINUS
128743: ST_TO_ADDR
// if y - r < 0 then
128744: LD_VAR 0 3
128748: PUSH
128749: LD_VAR 0 4
128753: MINUS
128754: PUSH
128755: LD_INT 0
128757: LESS
128758: IFFALSE 128770
// min_y := 0 else
128760: LD_ADDR_VAR 0 8
128764: PUSH
128765: LD_INT 0
128767: ST_TO_ADDR
128768: GO 128786
// min_y := y - r ;
128770: LD_ADDR_VAR 0 8
128774: PUSH
128775: LD_VAR 0 3
128779: PUSH
128780: LD_VAR 0 4
128784: MINUS
128785: ST_TO_ADDR
// max_x := x + r ;
128786: LD_ADDR_VAR 0 9
128790: PUSH
128791: LD_VAR 0 2
128795: PUSH
128796: LD_VAR 0 4
128800: PLUS
128801: ST_TO_ADDR
// max_y := y + r ;
128802: LD_ADDR_VAR 0 10
128806: PUSH
128807: LD_VAR 0 3
128811: PUSH
128812: LD_VAR 0 4
128816: PLUS
128817: ST_TO_ADDR
// for _x = min_x to max_x do
128818: LD_ADDR_VAR 0 11
128822: PUSH
128823: DOUBLE
128824: LD_VAR 0 7
128828: DEC
128829: ST_TO_ADDR
128830: LD_VAR 0 9
128834: PUSH
128835: FOR_TO
128836: IFFALSE 128953
// for _y = min_y to max_y do
128838: LD_ADDR_VAR 0 12
128842: PUSH
128843: DOUBLE
128844: LD_VAR 0 8
128848: DEC
128849: ST_TO_ADDR
128850: LD_VAR 0 10
128854: PUSH
128855: FOR_TO
128856: IFFALSE 128949
// begin if not ValidHex ( _x , _y ) then
128858: LD_VAR 0 11
128862: PPUSH
128863: LD_VAR 0 12
128867: PPUSH
128868: CALL_OW 488
128872: NOT
128873: IFFALSE 128877
// continue ;
128875: GO 128855
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
128877: LD_VAR 0 11
128881: PPUSH
128882: LD_VAR 0 12
128886: PPUSH
128887: CALL_OW 351
128891: PUSH
128892: LD_VAR 0 11
128896: PPUSH
128897: LD_VAR 0 12
128901: PPUSH
128902: CALL_OW 554
128906: AND
128907: IFFALSE 128947
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
128909: LD_ADDR_VAR 0 13
128913: PUSH
128914: LD_VAR 0 13
128918: PPUSH
128919: LD_VAR 0 13
128923: PUSH
128924: LD_INT 1
128926: PLUS
128927: PPUSH
128928: LD_VAR 0 11
128932: PUSH
128933: LD_VAR 0 12
128937: PUSH
128938: EMPTY
128939: LIST
128940: LIST
128941: PPUSH
128942: CALL_OW 2
128946: ST_TO_ADDR
// end ;
128947: GO 128855
128949: POP
128950: POP
128951: GO 128835
128953: POP
128954: POP
// if not list then
128955: LD_VAR 0 13
128959: NOT
128960: IFFALSE 128964
// exit ;
128962: GO 129035
// for i in list do
128964: LD_ADDR_VAR 0 6
128968: PUSH
128969: LD_VAR 0 13
128973: PUSH
128974: FOR_IN
128975: IFFALSE 129033
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
128977: LD_VAR 0 1
128981: PPUSH
128982: LD_STRING M
128984: PUSH
128985: LD_VAR 0 6
128989: PUSH
128990: LD_INT 1
128992: ARRAY
128993: PUSH
128994: LD_VAR 0 6
128998: PUSH
128999: LD_INT 2
129001: ARRAY
129002: PUSH
129003: LD_INT 0
129005: PUSH
129006: LD_INT 0
129008: PUSH
129009: LD_INT 0
129011: PUSH
129012: LD_INT 0
129014: PUSH
129015: EMPTY
129016: LIST
129017: LIST
129018: LIST
129019: LIST
129020: LIST
129021: LIST
129022: LIST
129023: PUSH
129024: EMPTY
129025: LIST
129026: PPUSH
129027: CALL_OW 447
129031: GO 128974
129033: POP
129034: POP
// end ;
129035: LD_VAR 0 5
129039: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
129040: LD_INT 0
129042: PPUSH
129043: PPUSH
129044: PPUSH
129045: PPUSH
129046: PPUSH
129047: PPUSH
129048: PPUSH
129049: PPUSH
129050: PPUSH
129051: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
129052: LD_VAR 0 1
129056: PPUSH
129057: CALL_OW 302
129061: NOT
129062: PUSH
129063: LD_VAR 0 2
129067: PPUSH
129068: LD_VAR 0 3
129072: PPUSH
129073: CALL_OW 488
129077: NOT
129078: OR
129079: PUSH
129080: LD_VAR 0 4
129084: NOT
129085: OR
129086: IFFALSE 129090
// exit ;
129088: GO 129603
// list := [ ] ;
129090: LD_ADDR_VAR 0 13
129094: PUSH
129095: EMPTY
129096: ST_TO_ADDR
// if x - r < 0 then
129097: LD_VAR 0 2
129101: PUSH
129102: LD_VAR 0 4
129106: MINUS
129107: PUSH
129108: LD_INT 0
129110: LESS
129111: IFFALSE 129123
// min_x := 0 else
129113: LD_ADDR_VAR 0 7
129117: PUSH
129118: LD_INT 0
129120: ST_TO_ADDR
129121: GO 129139
// min_x := x - r ;
129123: LD_ADDR_VAR 0 7
129127: PUSH
129128: LD_VAR 0 2
129132: PUSH
129133: LD_VAR 0 4
129137: MINUS
129138: ST_TO_ADDR
// if y - r < 0 then
129139: LD_VAR 0 3
129143: PUSH
129144: LD_VAR 0 4
129148: MINUS
129149: PUSH
129150: LD_INT 0
129152: LESS
129153: IFFALSE 129165
// min_y := 0 else
129155: LD_ADDR_VAR 0 8
129159: PUSH
129160: LD_INT 0
129162: ST_TO_ADDR
129163: GO 129181
// min_y := y - r ;
129165: LD_ADDR_VAR 0 8
129169: PUSH
129170: LD_VAR 0 3
129174: PUSH
129175: LD_VAR 0 4
129179: MINUS
129180: ST_TO_ADDR
// max_x := x + r ;
129181: LD_ADDR_VAR 0 9
129185: PUSH
129186: LD_VAR 0 2
129190: PUSH
129191: LD_VAR 0 4
129195: PLUS
129196: ST_TO_ADDR
// max_y := y + r ;
129197: LD_ADDR_VAR 0 10
129201: PUSH
129202: LD_VAR 0 3
129206: PUSH
129207: LD_VAR 0 4
129211: PLUS
129212: ST_TO_ADDR
// for _x = min_x to max_x do
129213: LD_ADDR_VAR 0 11
129217: PUSH
129218: DOUBLE
129219: LD_VAR 0 7
129223: DEC
129224: ST_TO_ADDR
129225: LD_VAR 0 9
129229: PUSH
129230: FOR_TO
129231: IFFALSE 129348
// for _y = min_y to max_y do
129233: LD_ADDR_VAR 0 12
129237: PUSH
129238: DOUBLE
129239: LD_VAR 0 8
129243: DEC
129244: ST_TO_ADDR
129245: LD_VAR 0 10
129249: PUSH
129250: FOR_TO
129251: IFFALSE 129344
// begin if not ValidHex ( _x , _y ) then
129253: LD_VAR 0 11
129257: PPUSH
129258: LD_VAR 0 12
129262: PPUSH
129263: CALL_OW 488
129267: NOT
129268: IFFALSE 129272
// continue ;
129270: GO 129250
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
129272: LD_VAR 0 11
129276: PPUSH
129277: LD_VAR 0 12
129281: PPUSH
129282: CALL_OW 351
129286: PUSH
129287: LD_VAR 0 11
129291: PPUSH
129292: LD_VAR 0 12
129296: PPUSH
129297: CALL_OW 554
129301: AND
129302: IFFALSE 129342
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
129304: LD_ADDR_VAR 0 13
129308: PUSH
129309: LD_VAR 0 13
129313: PPUSH
129314: LD_VAR 0 13
129318: PUSH
129319: LD_INT 1
129321: PLUS
129322: PPUSH
129323: LD_VAR 0 11
129327: PUSH
129328: LD_VAR 0 12
129332: PUSH
129333: EMPTY
129334: LIST
129335: LIST
129336: PPUSH
129337: CALL_OW 2
129341: ST_TO_ADDR
// end ;
129342: GO 129250
129344: POP
129345: POP
129346: GO 129230
129348: POP
129349: POP
// if not list then
129350: LD_VAR 0 13
129354: NOT
129355: IFFALSE 129359
// exit ;
129357: GO 129603
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
129359: LD_ADDR_VAR 0 13
129363: PUSH
129364: LD_VAR 0 1
129368: PPUSH
129369: LD_VAR 0 13
129373: PPUSH
129374: LD_INT 1
129376: PPUSH
129377: LD_INT 1
129379: PPUSH
129380: CALL 74894 0 4
129384: ST_TO_ADDR
// ComStop ( flame ) ;
129385: LD_VAR 0 1
129389: PPUSH
129390: CALL_OW 141
// for i in list do
129394: LD_ADDR_VAR 0 6
129398: PUSH
129399: LD_VAR 0 13
129403: PUSH
129404: FOR_IN
129405: IFFALSE 129436
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
129407: LD_VAR 0 1
129411: PPUSH
129412: LD_VAR 0 6
129416: PUSH
129417: LD_INT 1
129419: ARRAY
129420: PPUSH
129421: LD_VAR 0 6
129425: PUSH
129426: LD_INT 2
129428: ARRAY
129429: PPUSH
129430: CALL_OW 176
129434: GO 129404
129436: POP
129437: POP
// repeat wait ( 0 0$1 ) ;
129438: LD_INT 35
129440: PPUSH
129441: CALL_OW 67
// task := GetTaskList ( flame ) ;
129445: LD_ADDR_VAR 0 14
129449: PUSH
129450: LD_VAR 0 1
129454: PPUSH
129455: CALL_OW 437
129459: ST_TO_ADDR
// if not task then
129460: LD_VAR 0 14
129464: NOT
129465: IFFALSE 129469
// exit ;
129467: GO 129603
// if task [ 1 ] [ 1 ] <> | then
129469: LD_VAR 0 14
129473: PUSH
129474: LD_INT 1
129476: ARRAY
129477: PUSH
129478: LD_INT 1
129480: ARRAY
129481: PUSH
129482: LD_STRING |
129484: NONEQUAL
129485: IFFALSE 129489
// exit ;
129487: GO 129603
// _x := task [ 1 ] [ 2 ] ;
129489: LD_ADDR_VAR 0 11
129493: PUSH
129494: LD_VAR 0 14
129498: PUSH
129499: LD_INT 1
129501: ARRAY
129502: PUSH
129503: LD_INT 2
129505: ARRAY
129506: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
129507: LD_ADDR_VAR 0 12
129511: PUSH
129512: LD_VAR 0 14
129516: PUSH
129517: LD_INT 1
129519: ARRAY
129520: PUSH
129521: LD_INT 3
129523: ARRAY
129524: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
129525: LD_VAR 0 11
129529: PPUSH
129530: LD_VAR 0 12
129534: PPUSH
129535: CALL_OW 351
129539: NOT
129540: PUSH
129541: LD_VAR 0 11
129545: PPUSH
129546: LD_VAR 0 12
129550: PPUSH
129551: CALL_OW 554
129555: NOT
129556: OR
129557: IFFALSE 129591
// begin task := Delete ( task , 1 ) ;
129559: LD_ADDR_VAR 0 14
129563: PUSH
129564: LD_VAR 0 14
129568: PPUSH
129569: LD_INT 1
129571: PPUSH
129572: CALL_OW 3
129576: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
129577: LD_VAR 0 1
129581: PPUSH
129582: LD_VAR 0 14
129586: PPUSH
129587: CALL_OW 446
// end ; until not HasTask ( flame ) ;
129591: LD_VAR 0 1
129595: PPUSH
129596: CALL_OW 314
129600: NOT
129601: IFFALSE 129438
// end ;
129603: LD_VAR 0 5
129607: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
129608: LD_EXP 208
129612: NOT
129613: IFFALSE 129663
129615: GO 129617
129617: DISABLE
// begin initHack := true ;
129618: LD_ADDR_EXP 208
129622: PUSH
129623: LD_INT 1
129625: ST_TO_ADDR
// hackTanks := [ ] ;
129626: LD_ADDR_EXP 209
129630: PUSH
129631: EMPTY
129632: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
129633: LD_ADDR_EXP 210
129637: PUSH
129638: EMPTY
129639: ST_TO_ADDR
// hackLimit := 3 ;
129640: LD_ADDR_EXP 211
129644: PUSH
129645: LD_INT 3
129647: ST_TO_ADDR
// hackDist := 12 ;
129648: LD_ADDR_EXP 212
129652: PUSH
129653: LD_INT 12
129655: ST_TO_ADDR
// hackCounter := [ ] ;
129656: LD_ADDR_EXP 213
129660: PUSH
129661: EMPTY
129662: ST_TO_ADDR
// end ;
129663: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
129664: LD_EXP 208
129668: PUSH
129669: LD_INT 34
129671: PUSH
129672: LD_INT 99
129674: PUSH
129675: EMPTY
129676: LIST
129677: LIST
129678: PPUSH
129679: CALL_OW 69
129683: AND
129684: IFFALSE 129937
129686: GO 129688
129688: DISABLE
129689: LD_INT 0
129691: PPUSH
129692: PPUSH
// begin enable ;
129693: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
129694: LD_ADDR_VAR 0 1
129698: PUSH
129699: LD_INT 34
129701: PUSH
129702: LD_INT 99
129704: PUSH
129705: EMPTY
129706: LIST
129707: LIST
129708: PPUSH
129709: CALL_OW 69
129713: PUSH
129714: FOR_IN
129715: IFFALSE 129935
// begin if not i in hackTanks then
129717: LD_VAR 0 1
129721: PUSH
129722: LD_EXP 209
129726: IN
129727: NOT
129728: IFFALSE 129811
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
129730: LD_ADDR_EXP 209
129734: PUSH
129735: LD_EXP 209
129739: PPUSH
129740: LD_EXP 209
129744: PUSH
129745: LD_INT 1
129747: PLUS
129748: PPUSH
129749: LD_VAR 0 1
129753: PPUSH
129754: CALL_OW 1
129758: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
129759: LD_ADDR_EXP 210
129763: PUSH
129764: LD_EXP 210
129768: PPUSH
129769: LD_EXP 210
129773: PUSH
129774: LD_INT 1
129776: PLUS
129777: PPUSH
129778: EMPTY
129779: PPUSH
129780: CALL_OW 1
129784: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
129785: LD_ADDR_EXP 213
129789: PUSH
129790: LD_EXP 213
129794: PPUSH
129795: LD_EXP 213
129799: PUSH
129800: LD_INT 1
129802: PLUS
129803: PPUSH
129804: EMPTY
129805: PPUSH
129806: CALL_OW 1
129810: ST_TO_ADDR
// end ; if not IsOk ( i ) then
129811: LD_VAR 0 1
129815: PPUSH
129816: CALL_OW 302
129820: NOT
129821: IFFALSE 129834
// begin HackUnlinkAll ( i ) ;
129823: LD_VAR 0 1
129827: PPUSH
129828: CALL 129940 0 1
// continue ;
129832: GO 129714
// end ; HackCheckCapturedStatus ( i ) ;
129834: LD_VAR 0 1
129838: PPUSH
129839: CALL 130383 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
129843: LD_ADDR_VAR 0 2
129847: PUSH
129848: LD_INT 81
129850: PUSH
129851: LD_VAR 0 1
129855: PPUSH
129856: CALL_OW 255
129860: PUSH
129861: EMPTY
129862: LIST
129863: LIST
129864: PUSH
129865: LD_INT 33
129867: PUSH
129868: LD_INT 3
129870: PUSH
129871: EMPTY
129872: LIST
129873: LIST
129874: PUSH
129875: LD_INT 91
129877: PUSH
129878: LD_VAR 0 1
129882: PUSH
129883: LD_EXP 212
129887: PUSH
129888: EMPTY
129889: LIST
129890: LIST
129891: LIST
129892: PUSH
129893: LD_INT 50
129895: PUSH
129896: EMPTY
129897: LIST
129898: PUSH
129899: EMPTY
129900: LIST
129901: LIST
129902: LIST
129903: LIST
129904: PPUSH
129905: CALL_OW 69
129909: ST_TO_ADDR
// if not tmp then
129910: LD_VAR 0 2
129914: NOT
129915: IFFALSE 129919
// continue ;
129917: GO 129714
// HackLink ( i , tmp ) ;
129919: LD_VAR 0 1
129923: PPUSH
129924: LD_VAR 0 2
129928: PPUSH
129929: CALL 130076 0 2
// end ;
129933: GO 129714
129935: POP
129936: POP
// end ;
129937: PPOPN 2
129939: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
129940: LD_INT 0
129942: PPUSH
129943: PPUSH
129944: PPUSH
// if not hack in hackTanks then
129945: LD_VAR 0 1
129949: PUSH
129950: LD_EXP 209
129954: IN
129955: NOT
129956: IFFALSE 129960
// exit ;
129958: GO 130071
// index := GetElementIndex ( hackTanks , hack ) ;
129960: LD_ADDR_VAR 0 4
129964: PUSH
129965: LD_EXP 209
129969: PPUSH
129970: LD_VAR 0 1
129974: PPUSH
129975: CALL 74191 0 2
129979: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
129980: LD_EXP 210
129984: PUSH
129985: LD_VAR 0 4
129989: ARRAY
129990: IFFALSE 130071
// begin for i in hackTanksCaptured [ index ] do
129992: LD_ADDR_VAR 0 3
129996: PUSH
129997: LD_EXP 210
130001: PUSH
130002: LD_VAR 0 4
130006: ARRAY
130007: PUSH
130008: FOR_IN
130009: IFFALSE 130035
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
130011: LD_VAR 0 3
130015: PUSH
130016: LD_INT 1
130018: ARRAY
130019: PPUSH
130020: LD_VAR 0 3
130024: PUSH
130025: LD_INT 2
130027: ARRAY
130028: PPUSH
130029: CALL_OW 235
130033: GO 130008
130035: POP
130036: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
130037: LD_ADDR_EXP 210
130041: PUSH
130042: LD_EXP 210
130046: PPUSH
130047: LD_VAR 0 4
130051: PPUSH
130052: EMPTY
130053: PPUSH
130054: CALL_OW 1
130058: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
130059: LD_VAR 0 1
130063: PPUSH
130064: LD_INT 0
130066: PPUSH
130067: CALL_OW 505
// end ; end ;
130071: LD_VAR 0 2
130075: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
130076: LD_INT 0
130078: PPUSH
130079: PPUSH
130080: PPUSH
// if not hack in hackTanks or not vehicles then
130081: LD_VAR 0 1
130085: PUSH
130086: LD_EXP 209
130090: IN
130091: NOT
130092: PUSH
130093: LD_VAR 0 2
130097: NOT
130098: OR
130099: IFFALSE 130103
// exit ;
130101: GO 130378
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
130103: LD_ADDR_VAR 0 2
130107: PUSH
130108: LD_VAR 0 1
130112: PPUSH
130113: LD_VAR 0 2
130117: PPUSH
130118: LD_INT 1
130120: PPUSH
130121: LD_INT 1
130123: PPUSH
130124: CALL 74841 0 4
130128: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
130129: LD_ADDR_VAR 0 5
130133: PUSH
130134: LD_EXP 209
130138: PPUSH
130139: LD_VAR 0 1
130143: PPUSH
130144: CALL 74191 0 2
130148: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
130149: LD_EXP 210
130153: PUSH
130154: LD_VAR 0 5
130158: ARRAY
130159: PUSH
130160: LD_EXP 211
130164: LESS
130165: IFFALSE 130354
// begin for i := 1 to vehicles do
130167: LD_ADDR_VAR 0 4
130171: PUSH
130172: DOUBLE
130173: LD_INT 1
130175: DEC
130176: ST_TO_ADDR
130177: LD_VAR 0 2
130181: PUSH
130182: FOR_TO
130183: IFFALSE 130352
// begin if hackTanksCaptured [ index ] = hackLimit then
130185: LD_EXP 210
130189: PUSH
130190: LD_VAR 0 5
130194: ARRAY
130195: PUSH
130196: LD_EXP 211
130200: EQUAL
130201: IFFALSE 130205
// break ;
130203: GO 130352
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
130205: LD_ADDR_EXP 213
130209: PUSH
130210: LD_EXP 213
130214: PPUSH
130215: LD_VAR 0 5
130219: PPUSH
130220: LD_EXP 213
130224: PUSH
130225: LD_VAR 0 5
130229: ARRAY
130230: PUSH
130231: LD_INT 1
130233: PLUS
130234: PPUSH
130235: CALL_OW 1
130239: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
130240: LD_ADDR_EXP 210
130244: PUSH
130245: LD_EXP 210
130249: PPUSH
130250: LD_VAR 0 5
130254: PUSH
130255: LD_EXP 210
130259: PUSH
130260: LD_VAR 0 5
130264: ARRAY
130265: PUSH
130266: LD_INT 1
130268: PLUS
130269: PUSH
130270: EMPTY
130271: LIST
130272: LIST
130273: PPUSH
130274: LD_VAR 0 2
130278: PUSH
130279: LD_VAR 0 4
130283: ARRAY
130284: PUSH
130285: LD_VAR 0 2
130289: PUSH
130290: LD_VAR 0 4
130294: ARRAY
130295: PPUSH
130296: CALL_OW 255
130300: PUSH
130301: EMPTY
130302: LIST
130303: LIST
130304: PPUSH
130305: CALL 74406 0 3
130309: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
130310: LD_VAR 0 2
130314: PUSH
130315: LD_VAR 0 4
130319: ARRAY
130320: PPUSH
130321: LD_VAR 0 1
130325: PPUSH
130326: CALL_OW 255
130330: PPUSH
130331: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
130335: LD_VAR 0 2
130339: PUSH
130340: LD_VAR 0 4
130344: ARRAY
130345: PPUSH
130346: CALL_OW 141
// end ;
130350: GO 130182
130352: POP
130353: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
130354: LD_VAR 0 1
130358: PPUSH
130359: LD_EXP 210
130363: PUSH
130364: LD_VAR 0 5
130368: ARRAY
130369: PUSH
130370: LD_INT 0
130372: PLUS
130373: PPUSH
130374: CALL_OW 505
// end ;
130378: LD_VAR 0 3
130382: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
130383: LD_INT 0
130385: PPUSH
130386: PPUSH
130387: PPUSH
130388: PPUSH
// if not hack in hackTanks then
130389: LD_VAR 0 1
130393: PUSH
130394: LD_EXP 209
130398: IN
130399: NOT
130400: IFFALSE 130404
// exit ;
130402: GO 130644
// index := GetElementIndex ( hackTanks , hack ) ;
130404: LD_ADDR_VAR 0 4
130408: PUSH
130409: LD_EXP 209
130413: PPUSH
130414: LD_VAR 0 1
130418: PPUSH
130419: CALL 74191 0 2
130423: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
130424: LD_ADDR_VAR 0 3
130428: PUSH
130429: DOUBLE
130430: LD_EXP 210
130434: PUSH
130435: LD_VAR 0 4
130439: ARRAY
130440: INC
130441: ST_TO_ADDR
130442: LD_INT 1
130444: PUSH
130445: FOR_DOWNTO
130446: IFFALSE 130618
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
130448: LD_ADDR_VAR 0 5
130452: PUSH
130453: LD_EXP 210
130457: PUSH
130458: LD_VAR 0 4
130462: ARRAY
130463: PUSH
130464: LD_VAR 0 3
130468: ARRAY
130469: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
130470: LD_VAR 0 5
130474: PUSH
130475: LD_INT 1
130477: ARRAY
130478: PPUSH
130479: CALL_OW 302
130483: NOT
130484: PUSH
130485: LD_VAR 0 5
130489: PUSH
130490: LD_INT 1
130492: ARRAY
130493: PPUSH
130494: CALL_OW 255
130498: PUSH
130499: LD_VAR 0 1
130503: PPUSH
130504: CALL_OW 255
130508: NONEQUAL
130509: OR
130510: IFFALSE 130616
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
130512: LD_VAR 0 5
130516: PUSH
130517: LD_INT 1
130519: ARRAY
130520: PPUSH
130521: CALL_OW 305
130525: PUSH
130526: LD_VAR 0 5
130530: PUSH
130531: LD_INT 1
130533: ARRAY
130534: PPUSH
130535: CALL_OW 255
130539: PUSH
130540: LD_VAR 0 1
130544: PPUSH
130545: CALL_OW 255
130549: EQUAL
130550: AND
130551: IFFALSE 130575
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
130553: LD_VAR 0 5
130557: PUSH
130558: LD_INT 1
130560: ARRAY
130561: PPUSH
130562: LD_VAR 0 5
130566: PUSH
130567: LD_INT 2
130569: ARRAY
130570: PPUSH
130571: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
130575: LD_ADDR_EXP 210
130579: PUSH
130580: LD_EXP 210
130584: PPUSH
130585: LD_VAR 0 4
130589: PPUSH
130590: LD_EXP 210
130594: PUSH
130595: LD_VAR 0 4
130599: ARRAY
130600: PPUSH
130601: LD_VAR 0 3
130605: PPUSH
130606: CALL_OW 3
130610: PPUSH
130611: CALL_OW 1
130615: ST_TO_ADDR
// end ; end ;
130616: GO 130445
130618: POP
130619: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
130620: LD_VAR 0 1
130624: PPUSH
130625: LD_EXP 210
130629: PUSH
130630: LD_VAR 0 4
130634: ARRAY
130635: PUSH
130636: LD_INT 0
130638: PLUS
130639: PPUSH
130640: CALL_OW 505
// end ;
130644: LD_VAR 0 2
130648: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
130649: LD_INT 0
130651: PPUSH
130652: PPUSH
130653: PPUSH
130654: PPUSH
// if not hack in hackTanks then
130655: LD_VAR 0 1
130659: PUSH
130660: LD_EXP 209
130664: IN
130665: NOT
130666: IFFALSE 130670
// exit ;
130668: GO 130755
// index := GetElementIndex ( hackTanks , hack ) ;
130670: LD_ADDR_VAR 0 5
130674: PUSH
130675: LD_EXP 209
130679: PPUSH
130680: LD_VAR 0 1
130684: PPUSH
130685: CALL 74191 0 2
130689: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
130690: LD_ADDR_VAR 0 4
130694: PUSH
130695: DOUBLE
130696: LD_INT 1
130698: DEC
130699: ST_TO_ADDR
130700: LD_EXP 210
130704: PUSH
130705: LD_VAR 0 5
130709: ARRAY
130710: PUSH
130711: FOR_TO
130712: IFFALSE 130753
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
130714: LD_EXP 210
130718: PUSH
130719: LD_VAR 0 5
130723: ARRAY
130724: PUSH
130725: LD_VAR 0 4
130729: ARRAY
130730: PUSH
130731: LD_INT 1
130733: ARRAY
130734: PUSH
130735: LD_VAR 0 2
130739: EQUAL
130740: IFFALSE 130751
// KillUnit ( vehicle ) ;
130742: LD_VAR 0 2
130746: PPUSH
130747: CALL_OW 66
130751: GO 130711
130753: POP
130754: POP
// end ;
130755: LD_VAR 0 3
130759: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
130760: LD_EXP 214
130764: NOT
130765: IFFALSE 130800
130767: GO 130769
130769: DISABLE
// begin initMiner := true ;
130770: LD_ADDR_EXP 214
130774: PUSH
130775: LD_INT 1
130777: ST_TO_ADDR
// minersList := [ ] ;
130778: LD_ADDR_EXP 215
130782: PUSH
130783: EMPTY
130784: ST_TO_ADDR
// minerMinesList := [ ] ;
130785: LD_ADDR_EXP 216
130789: PUSH
130790: EMPTY
130791: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
130792: LD_ADDR_EXP 217
130796: PUSH
130797: LD_INT 5
130799: ST_TO_ADDR
// end ;
130800: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
130801: LD_EXP 214
130805: PUSH
130806: LD_INT 34
130808: PUSH
130809: LD_INT 81
130811: PUSH
130812: EMPTY
130813: LIST
130814: LIST
130815: PPUSH
130816: CALL_OW 69
130820: AND
130821: IFFALSE 131282
130823: GO 130825
130825: DISABLE
130826: LD_INT 0
130828: PPUSH
130829: PPUSH
130830: PPUSH
130831: PPUSH
// begin enable ;
130832: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
130833: LD_ADDR_VAR 0 1
130837: PUSH
130838: LD_INT 34
130840: PUSH
130841: LD_INT 81
130843: PUSH
130844: EMPTY
130845: LIST
130846: LIST
130847: PPUSH
130848: CALL_OW 69
130852: PUSH
130853: FOR_IN
130854: IFFALSE 130926
// begin if not i in minersList then
130856: LD_VAR 0 1
130860: PUSH
130861: LD_EXP 215
130865: IN
130866: NOT
130867: IFFALSE 130924
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
130869: LD_ADDR_EXP 215
130873: PUSH
130874: LD_EXP 215
130878: PPUSH
130879: LD_EXP 215
130883: PUSH
130884: LD_INT 1
130886: PLUS
130887: PPUSH
130888: LD_VAR 0 1
130892: PPUSH
130893: CALL_OW 1
130897: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
130898: LD_ADDR_EXP 216
130902: PUSH
130903: LD_EXP 216
130907: PPUSH
130908: LD_EXP 216
130912: PUSH
130913: LD_INT 1
130915: PLUS
130916: PPUSH
130917: EMPTY
130918: PPUSH
130919: CALL_OW 1
130923: ST_TO_ADDR
// end end ;
130924: GO 130853
130926: POP
130927: POP
// for i := minerMinesList downto 1 do
130928: LD_ADDR_VAR 0 1
130932: PUSH
130933: DOUBLE
130934: LD_EXP 216
130938: INC
130939: ST_TO_ADDR
130940: LD_INT 1
130942: PUSH
130943: FOR_DOWNTO
130944: IFFALSE 131280
// begin if IsLive ( minersList [ i ] ) then
130946: LD_EXP 215
130950: PUSH
130951: LD_VAR 0 1
130955: ARRAY
130956: PPUSH
130957: CALL_OW 300
130961: IFFALSE 130989
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
130963: LD_EXP 215
130967: PUSH
130968: LD_VAR 0 1
130972: ARRAY
130973: PPUSH
130974: LD_EXP 216
130978: PUSH
130979: LD_VAR 0 1
130983: ARRAY
130984: PPUSH
130985: CALL_OW 505
// if not minerMinesList [ i ] then
130989: LD_EXP 216
130993: PUSH
130994: LD_VAR 0 1
130998: ARRAY
130999: NOT
131000: IFFALSE 131004
// continue ;
131002: GO 130943
// for j := minerMinesList [ i ] downto 1 do
131004: LD_ADDR_VAR 0 2
131008: PUSH
131009: DOUBLE
131010: LD_EXP 216
131014: PUSH
131015: LD_VAR 0 1
131019: ARRAY
131020: INC
131021: ST_TO_ADDR
131022: LD_INT 1
131024: PUSH
131025: FOR_DOWNTO
131026: IFFALSE 131276
// begin side := GetSide ( minersList [ i ] ) ;
131028: LD_ADDR_VAR 0 3
131032: PUSH
131033: LD_EXP 215
131037: PUSH
131038: LD_VAR 0 1
131042: ARRAY
131043: PPUSH
131044: CALL_OW 255
131048: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
131049: LD_ADDR_VAR 0 4
131053: PUSH
131054: LD_EXP 216
131058: PUSH
131059: LD_VAR 0 1
131063: ARRAY
131064: PUSH
131065: LD_VAR 0 2
131069: ARRAY
131070: PUSH
131071: LD_INT 1
131073: ARRAY
131074: PPUSH
131075: LD_EXP 216
131079: PUSH
131080: LD_VAR 0 1
131084: ARRAY
131085: PUSH
131086: LD_VAR 0 2
131090: ARRAY
131091: PUSH
131092: LD_INT 2
131094: ARRAY
131095: PPUSH
131096: CALL_OW 428
131100: ST_TO_ADDR
// if not tmp then
131101: LD_VAR 0 4
131105: NOT
131106: IFFALSE 131110
// continue ;
131108: GO 131025
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
131110: LD_VAR 0 4
131114: PUSH
131115: LD_INT 81
131117: PUSH
131118: LD_VAR 0 3
131122: PUSH
131123: EMPTY
131124: LIST
131125: LIST
131126: PPUSH
131127: CALL_OW 69
131131: IN
131132: PUSH
131133: LD_EXP 216
131137: PUSH
131138: LD_VAR 0 1
131142: ARRAY
131143: PUSH
131144: LD_VAR 0 2
131148: ARRAY
131149: PUSH
131150: LD_INT 1
131152: ARRAY
131153: PPUSH
131154: LD_EXP 216
131158: PUSH
131159: LD_VAR 0 1
131163: ARRAY
131164: PUSH
131165: LD_VAR 0 2
131169: ARRAY
131170: PUSH
131171: LD_INT 2
131173: ARRAY
131174: PPUSH
131175: CALL_OW 458
131179: AND
131180: IFFALSE 131274
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
131182: LD_EXP 216
131186: PUSH
131187: LD_VAR 0 1
131191: ARRAY
131192: PUSH
131193: LD_VAR 0 2
131197: ARRAY
131198: PUSH
131199: LD_INT 1
131201: ARRAY
131202: PPUSH
131203: LD_EXP 216
131207: PUSH
131208: LD_VAR 0 1
131212: ARRAY
131213: PUSH
131214: LD_VAR 0 2
131218: ARRAY
131219: PUSH
131220: LD_INT 2
131222: ARRAY
131223: PPUSH
131224: LD_VAR 0 3
131228: PPUSH
131229: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
131233: LD_ADDR_EXP 216
131237: PUSH
131238: LD_EXP 216
131242: PPUSH
131243: LD_VAR 0 1
131247: PPUSH
131248: LD_EXP 216
131252: PUSH
131253: LD_VAR 0 1
131257: ARRAY
131258: PPUSH
131259: LD_VAR 0 2
131263: PPUSH
131264: CALL_OW 3
131268: PPUSH
131269: CALL_OW 1
131273: ST_TO_ADDR
// end ; end ;
131274: GO 131025
131276: POP
131277: POP
// end ;
131278: GO 130943
131280: POP
131281: POP
// end ;
131282: PPOPN 4
131284: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
131285: LD_INT 0
131287: PPUSH
131288: PPUSH
// result := false ;
131289: LD_ADDR_VAR 0 4
131293: PUSH
131294: LD_INT 0
131296: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
131297: LD_VAR 0 1
131301: PPUSH
131302: CALL_OW 264
131306: PUSH
131307: LD_INT 81
131309: EQUAL
131310: NOT
131311: IFFALSE 131315
// exit ;
131313: GO 131555
// index := GetElementIndex ( minersList , unit ) ;
131315: LD_ADDR_VAR 0 5
131319: PUSH
131320: LD_EXP 215
131324: PPUSH
131325: LD_VAR 0 1
131329: PPUSH
131330: CALL 74191 0 2
131334: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
131335: LD_EXP 216
131339: PUSH
131340: LD_VAR 0 5
131344: ARRAY
131345: PUSH
131346: LD_EXP 217
131350: GREATEREQUAL
131351: IFFALSE 131355
// exit ;
131353: GO 131555
// ComMoveXY ( unit , x , y ) ;
131355: LD_VAR 0 1
131359: PPUSH
131360: LD_VAR 0 2
131364: PPUSH
131365: LD_VAR 0 3
131369: PPUSH
131370: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
131374: LD_INT 35
131376: PPUSH
131377: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
131381: LD_VAR 0 1
131385: PPUSH
131386: LD_VAR 0 2
131390: PPUSH
131391: LD_VAR 0 3
131395: PPUSH
131396: CALL 105932 0 3
131400: NOT
131401: PUSH
131402: LD_VAR 0 1
131406: PPUSH
131407: CALL_OW 314
131411: AND
131412: IFFALSE 131416
// exit ;
131414: GO 131555
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
131416: LD_VAR 0 2
131420: PPUSH
131421: LD_VAR 0 3
131425: PPUSH
131426: CALL_OW 428
131430: PUSH
131431: LD_VAR 0 1
131435: EQUAL
131436: PUSH
131437: LD_VAR 0 1
131441: PPUSH
131442: CALL_OW 314
131446: NOT
131447: AND
131448: IFFALSE 131374
// PlaySoundXY ( x , y , PlantMine ) ;
131450: LD_VAR 0 2
131454: PPUSH
131455: LD_VAR 0 3
131459: PPUSH
131460: LD_STRING PlantMine
131462: PPUSH
131463: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
131467: LD_VAR 0 2
131471: PPUSH
131472: LD_VAR 0 3
131476: PPUSH
131477: LD_VAR 0 1
131481: PPUSH
131482: CALL_OW 255
131486: PPUSH
131487: LD_INT 0
131489: PPUSH
131490: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
131494: LD_ADDR_EXP 216
131498: PUSH
131499: LD_EXP 216
131503: PPUSH
131504: LD_VAR 0 5
131508: PUSH
131509: LD_EXP 216
131513: PUSH
131514: LD_VAR 0 5
131518: ARRAY
131519: PUSH
131520: LD_INT 1
131522: PLUS
131523: PUSH
131524: EMPTY
131525: LIST
131526: LIST
131527: PPUSH
131528: LD_VAR 0 2
131532: PUSH
131533: LD_VAR 0 3
131537: PUSH
131538: EMPTY
131539: LIST
131540: LIST
131541: PPUSH
131542: CALL 74406 0 3
131546: ST_TO_ADDR
// result := true ;
131547: LD_ADDR_VAR 0 4
131551: PUSH
131552: LD_INT 1
131554: ST_TO_ADDR
// end ;
131555: LD_VAR 0 4
131559: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
131560: LD_INT 0
131562: PPUSH
131563: PPUSH
131564: PPUSH
// if not unit in minersList then
131565: LD_VAR 0 1
131569: PUSH
131570: LD_EXP 215
131574: IN
131575: NOT
131576: IFFALSE 131580
// exit ;
131578: GO 131972
// index := GetElementIndex ( minersList , unit ) ;
131580: LD_ADDR_VAR 0 6
131584: PUSH
131585: LD_EXP 215
131589: PPUSH
131590: LD_VAR 0 1
131594: PPUSH
131595: CALL 74191 0 2
131599: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
131600: LD_ADDR_VAR 0 5
131604: PUSH
131605: DOUBLE
131606: LD_EXP 216
131610: PUSH
131611: LD_VAR 0 6
131615: ARRAY
131616: INC
131617: ST_TO_ADDR
131618: LD_INT 1
131620: PUSH
131621: FOR_DOWNTO
131622: IFFALSE 131783
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
131624: LD_EXP 216
131628: PUSH
131629: LD_VAR 0 6
131633: ARRAY
131634: PUSH
131635: LD_VAR 0 5
131639: ARRAY
131640: PUSH
131641: LD_INT 1
131643: ARRAY
131644: PUSH
131645: LD_VAR 0 2
131649: EQUAL
131650: PUSH
131651: LD_EXP 216
131655: PUSH
131656: LD_VAR 0 6
131660: ARRAY
131661: PUSH
131662: LD_VAR 0 5
131666: ARRAY
131667: PUSH
131668: LD_INT 2
131670: ARRAY
131671: PUSH
131672: LD_VAR 0 3
131676: EQUAL
131677: AND
131678: IFFALSE 131781
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
131680: LD_EXP 216
131684: PUSH
131685: LD_VAR 0 6
131689: ARRAY
131690: PUSH
131691: LD_VAR 0 5
131695: ARRAY
131696: PUSH
131697: LD_INT 1
131699: ARRAY
131700: PPUSH
131701: LD_EXP 216
131705: PUSH
131706: LD_VAR 0 6
131710: ARRAY
131711: PUSH
131712: LD_VAR 0 5
131716: ARRAY
131717: PUSH
131718: LD_INT 2
131720: ARRAY
131721: PPUSH
131722: LD_VAR 0 1
131726: PPUSH
131727: CALL_OW 255
131731: PPUSH
131732: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
131736: LD_ADDR_EXP 216
131740: PUSH
131741: LD_EXP 216
131745: PPUSH
131746: LD_VAR 0 6
131750: PPUSH
131751: LD_EXP 216
131755: PUSH
131756: LD_VAR 0 6
131760: ARRAY
131761: PPUSH
131762: LD_VAR 0 5
131766: PPUSH
131767: CALL_OW 3
131771: PPUSH
131772: CALL_OW 1
131776: ST_TO_ADDR
// exit ;
131777: POP
131778: POP
131779: GO 131972
// end ; end ;
131781: GO 131621
131783: POP
131784: POP
// for i := minerMinesList [ index ] downto 1 do
131785: LD_ADDR_VAR 0 5
131789: PUSH
131790: DOUBLE
131791: LD_EXP 216
131795: PUSH
131796: LD_VAR 0 6
131800: ARRAY
131801: INC
131802: ST_TO_ADDR
131803: LD_INT 1
131805: PUSH
131806: FOR_DOWNTO
131807: IFFALSE 131970
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
131809: LD_EXP 216
131813: PUSH
131814: LD_VAR 0 6
131818: ARRAY
131819: PUSH
131820: LD_VAR 0 5
131824: ARRAY
131825: PUSH
131826: LD_INT 1
131828: ARRAY
131829: PPUSH
131830: LD_EXP 216
131834: PUSH
131835: LD_VAR 0 6
131839: ARRAY
131840: PUSH
131841: LD_VAR 0 5
131845: ARRAY
131846: PUSH
131847: LD_INT 2
131849: ARRAY
131850: PPUSH
131851: LD_VAR 0 2
131855: PPUSH
131856: LD_VAR 0 3
131860: PPUSH
131861: CALL_OW 298
131865: PUSH
131866: LD_INT 6
131868: LESS
131869: IFFALSE 131968
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
131871: LD_EXP 216
131875: PUSH
131876: LD_VAR 0 6
131880: ARRAY
131881: PUSH
131882: LD_VAR 0 5
131886: ARRAY
131887: PUSH
131888: LD_INT 1
131890: ARRAY
131891: PPUSH
131892: LD_EXP 216
131896: PUSH
131897: LD_VAR 0 6
131901: ARRAY
131902: PUSH
131903: LD_VAR 0 5
131907: ARRAY
131908: PUSH
131909: LD_INT 2
131911: ARRAY
131912: PPUSH
131913: LD_VAR 0 1
131917: PPUSH
131918: CALL_OW 255
131922: PPUSH
131923: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
131927: LD_ADDR_EXP 216
131931: PUSH
131932: LD_EXP 216
131936: PPUSH
131937: LD_VAR 0 6
131941: PPUSH
131942: LD_EXP 216
131946: PUSH
131947: LD_VAR 0 6
131951: ARRAY
131952: PPUSH
131953: LD_VAR 0 5
131957: PPUSH
131958: CALL_OW 3
131962: PPUSH
131963: CALL_OW 1
131967: ST_TO_ADDR
// end ; end ;
131968: GO 131806
131970: POP
131971: POP
// end ;
131972: LD_VAR 0 4
131976: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
131977: LD_INT 0
131979: PPUSH
131980: PPUSH
131981: PPUSH
131982: PPUSH
131983: PPUSH
131984: PPUSH
131985: PPUSH
131986: PPUSH
131987: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
131988: LD_VAR 0 1
131992: PPUSH
131993: CALL_OW 264
131997: PUSH
131998: LD_INT 81
132000: EQUAL
132001: NOT
132002: PUSH
132003: LD_VAR 0 1
132007: PUSH
132008: LD_EXP 215
132012: IN
132013: NOT
132014: OR
132015: IFFALSE 132019
// exit ;
132017: GO 132341
// index := GetElementIndex ( minersList , unit ) ;
132019: LD_ADDR_VAR 0 6
132023: PUSH
132024: LD_EXP 215
132028: PPUSH
132029: LD_VAR 0 1
132033: PPUSH
132034: CALL 74191 0 2
132038: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
132039: LD_ADDR_VAR 0 8
132043: PUSH
132044: LD_EXP 217
132048: PUSH
132049: LD_EXP 216
132053: PUSH
132054: LD_VAR 0 6
132058: ARRAY
132059: MINUS
132060: ST_TO_ADDR
// if not minesFreeAmount then
132061: LD_VAR 0 8
132065: NOT
132066: IFFALSE 132070
// exit ;
132068: GO 132341
// tmp := [ ] ;
132070: LD_ADDR_VAR 0 7
132074: PUSH
132075: EMPTY
132076: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
132077: LD_ADDR_VAR 0 5
132081: PUSH
132082: DOUBLE
132083: LD_INT 1
132085: DEC
132086: ST_TO_ADDR
132087: LD_VAR 0 8
132091: PUSH
132092: FOR_TO
132093: IFFALSE 132288
// begin _d := rand ( 0 , 5 ) ;
132095: LD_ADDR_VAR 0 11
132099: PUSH
132100: LD_INT 0
132102: PPUSH
132103: LD_INT 5
132105: PPUSH
132106: CALL_OW 12
132110: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
132111: LD_ADDR_VAR 0 12
132115: PUSH
132116: LD_INT 2
132118: PPUSH
132119: LD_INT 6
132121: PPUSH
132122: CALL_OW 12
132126: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
132127: LD_ADDR_VAR 0 9
132131: PUSH
132132: LD_VAR 0 2
132136: PPUSH
132137: LD_VAR 0 11
132141: PPUSH
132142: LD_VAR 0 12
132146: PPUSH
132147: CALL_OW 272
132151: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
132152: LD_ADDR_VAR 0 10
132156: PUSH
132157: LD_VAR 0 3
132161: PPUSH
132162: LD_VAR 0 11
132166: PPUSH
132167: LD_VAR 0 12
132171: PPUSH
132172: CALL_OW 273
132176: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
132177: LD_VAR 0 9
132181: PPUSH
132182: LD_VAR 0 10
132186: PPUSH
132187: CALL_OW 488
132191: PUSH
132192: LD_VAR 0 9
132196: PUSH
132197: LD_VAR 0 10
132201: PUSH
132202: EMPTY
132203: LIST
132204: LIST
132205: PUSH
132206: LD_VAR 0 7
132210: IN
132211: NOT
132212: AND
132213: PUSH
132214: LD_VAR 0 9
132218: PPUSH
132219: LD_VAR 0 10
132223: PPUSH
132224: CALL_OW 458
132228: NOT
132229: AND
132230: IFFALSE 132272
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
132232: LD_ADDR_VAR 0 7
132236: PUSH
132237: LD_VAR 0 7
132241: PPUSH
132242: LD_VAR 0 7
132246: PUSH
132247: LD_INT 1
132249: PLUS
132250: PPUSH
132251: LD_VAR 0 9
132255: PUSH
132256: LD_VAR 0 10
132260: PUSH
132261: EMPTY
132262: LIST
132263: LIST
132264: PPUSH
132265: CALL_OW 1
132269: ST_TO_ADDR
132270: GO 132286
// i := i - 1 ;
132272: LD_ADDR_VAR 0 5
132276: PUSH
132277: LD_VAR 0 5
132281: PUSH
132282: LD_INT 1
132284: MINUS
132285: ST_TO_ADDR
// end ;
132286: GO 132092
132288: POP
132289: POP
// for i in tmp do
132290: LD_ADDR_VAR 0 5
132294: PUSH
132295: LD_VAR 0 7
132299: PUSH
132300: FOR_IN
132301: IFFALSE 132339
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
132303: LD_VAR 0 1
132307: PPUSH
132308: LD_VAR 0 5
132312: PUSH
132313: LD_INT 1
132315: ARRAY
132316: PPUSH
132317: LD_VAR 0 5
132321: PUSH
132322: LD_INT 2
132324: ARRAY
132325: PPUSH
132326: CALL 131285 0 3
132330: NOT
132331: IFFALSE 132337
// exit ;
132333: POP
132334: POP
132335: GO 132341
132337: GO 132300
132339: POP
132340: POP
// end ;
132341: LD_VAR 0 4
132345: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
132346: LD_INT 0
132348: PPUSH
132349: PPUSH
132350: PPUSH
132351: PPUSH
132352: PPUSH
132353: PPUSH
132354: PPUSH
// if not GetClass ( unit ) = class_sniper then
132355: LD_VAR 0 1
132359: PPUSH
132360: CALL_OW 257
132364: PUSH
132365: LD_INT 5
132367: EQUAL
132368: NOT
132369: IFFALSE 132373
// exit ;
132371: GO 132761
// dist := 8 ;
132373: LD_ADDR_VAR 0 5
132377: PUSH
132378: LD_INT 8
132380: ST_TO_ADDR
// viewRange := 12 ;
132381: LD_ADDR_VAR 0 7
132385: PUSH
132386: LD_INT 12
132388: ST_TO_ADDR
// side := GetSide ( unit ) ;
132389: LD_ADDR_VAR 0 6
132393: PUSH
132394: LD_VAR 0 1
132398: PPUSH
132399: CALL_OW 255
132403: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
132404: LD_INT 61
132406: PPUSH
132407: LD_VAR 0 6
132411: PPUSH
132412: CALL_OW 321
132416: PUSH
132417: LD_INT 2
132419: EQUAL
132420: IFFALSE 132430
// viewRange := 16 ;
132422: LD_ADDR_VAR 0 7
132426: PUSH
132427: LD_INT 16
132429: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
132430: LD_VAR 0 1
132434: PPUSH
132435: LD_VAR 0 2
132439: PPUSH
132440: LD_VAR 0 3
132444: PPUSH
132445: CALL_OW 297
132449: PUSH
132450: LD_VAR 0 5
132454: GREATER
132455: IFFALSE 132534
// begin ComMoveXY ( unit , x , y ) ;
132457: LD_VAR 0 1
132461: PPUSH
132462: LD_VAR 0 2
132466: PPUSH
132467: LD_VAR 0 3
132471: PPUSH
132472: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
132476: LD_INT 35
132478: PPUSH
132479: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
132483: LD_VAR 0 1
132487: PPUSH
132488: LD_VAR 0 2
132492: PPUSH
132493: LD_VAR 0 3
132497: PPUSH
132498: CALL 105932 0 3
132502: NOT
132503: IFFALSE 132507
// exit ;
132505: GO 132761
// until GetDistUnitXY ( unit , x , y ) < dist ;
132507: LD_VAR 0 1
132511: PPUSH
132512: LD_VAR 0 2
132516: PPUSH
132517: LD_VAR 0 3
132521: PPUSH
132522: CALL_OW 297
132526: PUSH
132527: LD_VAR 0 5
132531: LESS
132532: IFFALSE 132476
// end ; ComTurnXY ( unit , x , y ) ;
132534: LD_VAR 0 1
132538: PPUSH
132539: LD_VAR 0 2
132543: PPUSH
132544: LD_VAR 0 3
132548: PPUSH
132549: CALL_OW 118
// wait ( 5 ) ;
132553: LD_INT 5
132555: PPUSH
132556: CALL_OW 67
// _d := GetDir ( unit ) ;
132560: LD_ADDR_VAR 0 10
132564: PUSH
132565: LD_VAR 0 1
132569: PPUSH
132570: CALL_OW 254
132574: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
132575: LD_ADDR_VAR 0 8
132579: PUSH
132580: LD_VAR 0 1
132584: PPUSH
132585: CALL_OW 250
132589: PPUSH
132590: LD_VAR 0 10
132594: PPUSH
132595: LD_VAR 0 5
132599: PPUSH
132600: CALL_OW 272
132604: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
132605: LD_ADDR_VAR 0 9
132609: PUSH
132610: LD_VAR 0 1
132614: PPUSH
132615: CALL_OW 251
132619: PPUSH
132620: LD_VAR 0 10
132624: PPUSH
132625: LD_VAR 0 5
132629: PPUSH
132630: CALL_OW 273
132634: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
132635: LD_VAR 0 8
132639: PPUSH
132640: LD_VAR 0 9
132644: PPUSH
132645: CALL_OW 488
132649: NOT
132650: IFFALSE 132654
// exit ;
132652: GO 132761
// ComAnimCustom ( unit , 1 ) ;
132654: LD_VAR 0 1
132658: PPUSH
132659: LD_INT 1
132661: PPUSH
132662: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
132666: LD_VAR 0 8
132670: PPUSH
132671: LD_VAR 0 9
132675: PPUSH
132676: LD_VAR 0 6
132680: PPUSH
132681: LD_VAR 0 7
132685: PPUSH
132686: CALL_OW 330
// repeat wait ( 1 ) ;
132690: LD_INT 1
132692: PPUSH
132693: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
132697: LD_VAR 0 1
132701: PPUSH
132702: CALL_OW 316
132706: PUSH
132707: LD_VAR 0 1
132711: PPUSH
132712: CALL_OW 314
132716: OR
132717: PUSH
132718: LD_VAR 0 1
132722: PPUSH
132723: CALL_OW 302
132727: NOT
132728: OR
132729: PUSH
132730: LD_VAR 0 1
132734: PPUSH
132735: CALL_OW 301
132739: OR
132740: IFFALSE 132690
// RemoveSeeing ( _x , _y , side ) ;
132742: LD_VAR 0 8
132746: PPUSH
132747: LD_VAR 0 9
132751: PPUSH
132752: LD_VAR 0 6
132756: PPUSH
132757: CALL_OW 331
// end ; end_of_file
132761: LD_VAR 0 4
132765: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
132766: LD_INT 0
132768: PPUSH
132769: PPUSH
132770: PPUSH
132771: PPUSH
132772: PPUSH
132773: PPUSH
132774: PPUSH
132775: PPUSH
132776: PPUSH
132777: PPUSH
132778: PPUSH
132779: PPUSH
132780: PPUSH
132781: PPUSH
132782: PPUSH
132783: PPUSH
132784: PPUSH
132785: PPUSH
132786: PPUSH
132787: PPUSH
132788: PPUSH
132789: PPUSH
132790: PPUSH
132791: PPUSH
132792: PPUSH
132793: PPUSH
132794: PPUSH
132795: PPUSH
132796: PPUSH
132797: PPUSH
132798: PPUSH
132799: PPUSH
132800: PPUSH
132801: PPUSH
// if not list then
132802: LD_VAR 0 1
132806: NOT
132807: IFFALSE 132811
// exit ;
132809: GO 137470
// base := list [ 1 ] ;
132811: LD_ADDR_VAR 0 3
132815: PUSH
132816: LD_VAR 0 1
132820: PUSH
132821: LD_INT 1
132823: ARRAY
132824: ST_TO_ADDR
// group := list [ 2 ] ;
132825: LD_ADDR_VAR 0 4
132829: PUSH
132830: LD_VAR 0 1
132834: PUSH
132835: LD_INT 2
132837: ARRAY
132838: ST_TO_ADDR
// path := list [ 3 ] ;
132839: LD_ADDR_VAR 0 5
132843: PUSH
132844: LD_VAR 0 1
132848: PUSH
132849: LD_INT 3
132851: ARRAY
132852: ST_TO_ADDR
// flags := list [ 4 ] ;
132853: LD_ADDR_VAR 0 6
132857: PUSH
132858: LD_VAR 0 1
132862: PUSH
132863: LD_INT 4
132865: ARRAY
132866: ST_TO_ADDR
// mined := [ ] ;
132867: LD_ADDR_VAR 0 27
132871: PUSH
132872: EMPTY
132873: ST_TO_ADDR
// bombed := [ ] ;
132874: LD_ADDR_VAR 0 28
132878: PUSH
132879: EMPTY
132880: ST_TO_ADDR
// healers := [ ] ;
132881: LD_ADDR_VAR 0 31
132885: PUSH
132886: EMPTY
132887: ST_TO_ADDR
// to_heal := [ ] ;
132888: LD_ADDR_VAR 0 30
132892: PUSH
132893: EMPTY
132894: ST_TO_ADDR
// repairs := [ ] ;
132895: LD_ADDR_VAR 0 33
132899: PUSH
132900: EMPTY
132901: ST_TO_ADDR
// to_repair := [ ] ;
132902: LD_ADDR_VAR 0 32
132906: PUSH
132907: EMPTY
132908: ST_TO_ADDR
// if not group or not path then
132909: LD_VAR 0 4
132913: NOT
132914: PUSH
132915: LD_VAR 0 5
132919: NOT
132920: OR
132921: IFFALSE 132925
// exit ;
132923: GO 137470
// side := GetSide ( group [ 1 ] ) ;
132925: LD_ADDR_VAR 0 35
132929: PUSH
132930: LD_VAR 0 4
132934: PUSH
132935: LD_INT 1
132937: ARRAY
132938: PPUSH
132939: CALL_OW 255
132943: ST_TO_ADDR
// if flags then
132944: LD_VAR 0 6
132948: IFFALSE 133092
// begin f_ignore_area := flags [ 1 ] ;
132950: LD_ADDR_VAR 0 17
132954: PUSH
132955: LD_VAR 0 6
132959: PUSH
132960: LD_INT 1
132962: ARRAY
132963: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
132964: LD_ADDR_VAR 0 18
132968: PUSH
132969: LD_VAR 0 6
132973: PUSH
132974: LD_INT 2
132976: ARRAY
132977: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
132978: LD_ADDR_VAR 0 19
132982: PUSH
132983: LD_VAR 0 6
132987: PUSH
132988: LD_INT 3
132990: ARRAY
132991: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
132992: LD_ADDR_VAR 0 20
132996: PUSH
132997: LD_VAR 0 6
133001: PUSH
133002: LD_INT 4
133004: ARRAY
133005: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
133006: LD_ADDR_VAR 0 21
133010: PUSH
133011: LD_VAR 0 6
133015: PUSH
133016: LD_INT 5
133018: ARRAY
133019: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
133020: LD_ADDR_VAR 0 22
133024: PUSH
133025: LD_VAR 0 6
133029: PUSH
133030: LD_INT 6
133032: ARRAY
133033: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
133034: LD_ADDR_VAR 0 23
133038: PUSH
133039: LD_VAR 0 6
133043: PUSH
133044: LD_INT 7
133046: ARRAY
133047: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
133048: LD_ADDR_VAR 0 24
133052: PUSH
133053: LD_VAR 0 6
133057: PUSH
133058: LD_INT 8
133060: ARRAY
133061: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
133062: LD_ADDR_VAR 0 25
133066: PUSH
133067: LD_VAR 0 6
133071: PUSH
133072: LD_INT 9
133074: ARRAY
133075: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
133076: LD_ADDR_VAR 0 26
133080: PUSH
133081: LD_VAR 0 6
133085: PUSH
133086: LD_INT 10
133088: ARRAY
133089: ST_TO_ADDR
// end else
133090: GO 133172
// begin f_ignore_area := false ;
133092: LD_ADDR_VAR 0 17
133096: PUSH
133097: LD_INT 0
133099: ST_TO_ADDR
// f_capture := false ;
133100: LD_ADDR_VAR 0 18
133104: PUSH
133105: LD_INT 0
133107: ST_TO_ADDR
// f_ignore_civ := false ;
133108: LD_ADDR_VAR 0 19
133112: PUSH
133113: LD_INT 0
133115: ST_TO_ADDR
// f_murder := false ;
133116: LD_ADDR_VAR 0 20
133120: PUSH
133121: LD_INT 0
133123: ST_TO_ADDR
// f_mines := false ;
133124: LD_ADDR_VAR 0 21
133128: PUSH
133129: LD_INT 0
133131: ST_TO_ADDR
// f_repair := false ;
133132: LD_ADDR_VAR 0 22
133136: PUSH
133137: LD_INT 0
133139: ST_TO_ADDR
// f_heal := false ;
133140: LD_ADDR_VAR 0 23
133144: PUSH
133145: LD_INT 0
133147: ST_TO_ADDR
// f_spacetime := false ;
133148: LD_ADDR_VAR 0 24
133152: PUSH
133153: LD_INT 0
133155: ST_TO_ADDR
// f_attack_depot := false ;
133156: LD_ADDR_VAR 0 25
133160: PUSH
133161: LD_INT 0
133163: ST_TO_ADDR
// f_crawl := false ;
133164: LD_ADDR_VAR 0 26
133168: PUSH
133169: LD_INT 0
133171: ST_TO_ADDR
// end ; if f_heal then
133172: LD_VAR 0 23
133176: IFFALSE 133203
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
133178: LD_ADDR_VAR 0 31
133182: PUSH
133183: LD_VAR 0 4
133187: PPUSH
133188: LD_INT 25
133190: PUSH
133191: LD_INT 4
133193: PUSH
133194: EMPTY
133195: LIST
133196: LIST
133197: PPUSH
133198: CALL_OW 72
133202: ST_TO_ADDR
// if f_repair then
133203: LD_VAR 0 22
133207: IFFALSE 133234
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
133209: LD_ADDR_VAR 0 33
133213: PUSH
133214: LD_VAR 0 4
133218: PPUSH
133219: LD_INT 25
133221: PUSH
133222: LD_INT 3
133224: PUSH
133225: EMPTY
133226: LIST
133227: LIST
133228: PPUSH
133229: CALL_OW 72
133233: ST_TO_ADDR
// units_path := [ ] ;
133234: LD_ADDR_VAR 0 16
133238: PUSH
133239: EMPTY
133240: ST_TO_ADDR
// for i = 1 to group do
133241: LD_ADDR_VAR 0 7
133245: PUSH
133246: DOUBLE
133247: LD_INT 1
133249: DEC
133250: ST_TO_ADDR
133251: LD_VAR 0 4
133255: PUSH
133256: FOR_TO
133257: IFFALSE 133286
// units_path := Replace ( units_path , i , path ) ;
133259: LD_ADDR_VAR 0 16
133263: PUSH
133264: LD_VAR 0 16
133268: PPUSH
133269: LD_VAR 0 7
133273: PPUSH
133274: LD_VAR 0 5
133278: PPUSH
133279: CALL_OW 1
133283: ST_TO_ADDR
133284: GO 133256
133286: POP
133287: POP
// repeat for i = group downto 1 do
133288: LD_ADDR_VAR 0 7
133292: PUSH
133293: DOUBLE
133294: LD_VAR 0 4
133298: INC
133299: ST_TO_ADDR
133300: LD_INT 1
133302: PUSH
133303: FOR_DOWNTO
133304: IFFALSE 137426
// begin wait ( 5 ) ;
133306: LD_INT 5
133308: PPUSH
133309: CALL_OW 67
// tmp := [ ] ;
133313: LD_ADDR_VAR 0 14
133317: PUSH
133318: EMPTY
133319: ST_TO_ADDR
// attacking := false ;
133320: LD_ADDR_VAR 0 29
133324: PUSH
133325: LD_INT 0
133327: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
133328: LD_VAR 0 4
133332: PUSH
133333: LD_VAR 0 7
133337: ARRAY
133338: PPUSH
133339: CALL_OW 301
133343: PUSH
133344: LD_VAR 0 4
133348: PUSH
133349: LD_VAR 0 7
133353: ARRAY
133354: NOT
133355: OR
133356: IFFALSE 133465
// begin if GetType ( group [ i ] ) = unit_human then
133358: LD_VAR 0 4
133362: PUSH
133363: LD_VAR 0 7
133367: ARRAY
133368: PPUSH
133369: CALL_OW 247
133373: PUSH
133374: LD_INT 1
133376: EQUAL
133377: IFFALSE 133423
// begin to_heal := to_heal diff group [ i ] ;
133379: LD_ADDR_VAR 0 30
133383: PUSH
133384: LD_VAR 0 30
133388: PUSH
133389: LD_VAR 0 4
133393: PUSH
133394: LD_VAR 0 7
133398: ARRAY
133399: DIFF
133400: ST_TO_ADDR
// healers := healers diff group [ i ] ;
133401: LD_ADDR_VAR 0 31
133405: PUSH
133406: LD_VAR 0 31
133410: PUSH
133411: LD_VAR 0 4
133415: PUSH
133416: LD_VAR 0 7
133420: ARRAY
133421: DIFF
133422: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
133423: LD_ADDR_VAR 0 4
133427: PUSH
133428: LD_VAR 0 4
133432: PPUSH
133433: LD_VAR 0 7
133437: PPUSH
133438: CALL_OW 3
133442: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
133443: LD_ADDR_VAR 0 16
133447: PUSH
133448: LD_VAR 0 16
133452: PPUSH
133453: LD_VAR 0 7
133457: PPUSH
133458: CALL_OW 3
133462: ST_TO_ADDR
// continue ;
133463: GO 133303
// end ; if f_repair then
133465: LD_VAR 0 22
133469: IFFALSE 133958
// begin if GetType ( group [ i ] ) = unit_vehicle then
133471: LD_VAR 0 4
133475: PUSH
133476: LD_VAR 0 7
133480: ARRAY
133481: PPUSH
133482: CALL_OW 247
133486: PUSH
133487: LD_INT 2
133489: EQUAL
133490: IFFALSE 133680
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
133492: LD_VAR 0 4
133496: PUSH
133497: LD_VAR 0 7
133501: ARRAY
133502: PPUSH
133503: CALL_OW 256
133507: PUSH
133508: LD_INT 700
133510: LESS
133511: PUSH
133512: LD_VAR 0 4
133516: PUSH
133517: LD_VAR 0 7
133521: ARRAY
133522: PUSH
133523: LD_VAR 0 32
133527: IN
133528: NOT
133529: AND
133530: IFFALSE 133554
// to_repair := to_repair union group [ i ] ;
133532: LD_ADDR_VAR 0 32
133536: PUSH
133537: LD_VAR 0 32
133541: PUSH
133542: LD_VAR 0 4
133546: PUSH
133547: LD_VAR 0 7
133551: ARRAY
133552: UNION
133553: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
133554: LD_VAR 0 4
133558: PUSH
133559: LD_VAR 0 7
133563: ARRAY
133564: PPUSH
133565: CALL_OW 256
133569: PUSH
133570: LD_INT 1000
133572: EQUAL
133573: PUSH
133574: LD_VAR 0 4
133578: PUSH
133579: LD_VAR 0 7
133583: ARRAY
133584: PUSH
133585: LD_VAR 0 32
133589: IN
133590: AND
133591: IFFALSE 133615
// to_repair := to_repair diff group [ i ] ;
133593: LD_ADDR_VAR 0 32
133597: PUSH
133598: LD_VAR 0 32
133602: PUSH
133603: LD_VAR 0 4
133607: PUSH
133608: LD_VAR 0 7
133612: ARRAY
133613: DIFF
133614: ST_TO_ADDR
// if group [ i ] in to_repair then
133615: LD_VAR 0 4
133619: PUSH
133620: LD_VAR 0 7
133624: ARRAY
133625: PUSH
133626: LD_VAR 0 32
133630: IN
133631: IFFALSE 133678
// begin if not IsInArea ( group [ i ] , f_repair ) then
133633: LD_VAR 0 4
133637: PUSH
133638: LD_VAR 0 7
133642: ARRAY
133643: PPUSH
133644: LD_VAR 0 22
133648: PPUSH
133649: CALL_OW 308
133653: NOT
133654: IFFALSE 133676
// ComMoveToArea ( group [ i ] , f_repair ) ;
133656: LD_VAR 0 4
133660: PUSH
133661: LD_VAR 0 7
133665: ARRAY
133666: PPUSH
133667: LD_VAR 0 22
133671: PPUSH
133672: CALL_OW 113
// continue ;
133676: GO 133303
// end ; end else
133678: GO 133958
// if group [ i ] in repairs then
133680: LD_VAR 0 4
133684: PUSH
133685: LD_VAR 0 7
133689: ARRAY
133690: PUSH
133691: LD_VAR 0 33
133695: IN
133696: IFFALSE 133958
// begin if IsInUnit ( group [ i ] ) then
133698: LD_VAR 0 4
133702: PUSH
133703: LD_VAR 0 7
133707: ARRAY
133708: PPUSH
133709: CALL_OW 310
133713: IFFALSE 133781
// begin z := IsInUnit ( group [ i ] ) ;
133715: LD_ADDR_VAR 0 13
133719: PUSH
133720: LD_VAR 0 4
133724: PUSH
133725: LD_VAR 0 7
133729: ARRAY
133730: PPUSH
133731: CALL_OW 310
133735: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
133736: LD_VAR 0 13
133740: PUSH
133741: LD_VAR 0 32
133745: IN
133746: PUSH
133747: LD_VAR 0 13
133751: PPUSH
133752: LD_VAR 0 22
133756: PPUSH
133757: CALL_OW 308
133761: AND
133762: IFFALSE 133779
// ComExitVehicle ( group [ i ] ) ;
133764: LD_VAR 0 4
133768: PUSH
133769: LD_VAR 0 7
133773: ARRAY
133774: PPUSH
133775: CALL_OW 121
// end else
133779: GO 133958
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
133781: LD_ADDR_VAR 0 13
133785: PUSH
133786: LD_VAR 0 4
133790: PPUSH
133791: LD_INT 95
133793: PUSH
133794: LD_VAR 0 22
133798: PUSH
133799: EMPTY
133800: LIST
133801: LIST
133802: PUSH
133803: LD_INT 58
133805: PUSH
133806: EMPTY
133807: LIST
133808: PUSH
133809: EMPTY
133810: LIST
133811: LIST
133812: PPUSH
133813: CALL_OW 72
133817: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
133818: LD_VAR 0 4
133822: PUSH
133823: LD_VAR 0 7
133827: ARRAY
133828: PPUSH
133829: CALL_OW 314
133833: NOT
133834: IFFALSE 133956
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
133836: LD_ADDR_VAR 0 10
133840: PUSH
133841: LD_VAR 0 13
133845: PPUSH
133846: LD_VAR 0 4
133850: PUSH
133851: LD_VAR 0 7
133855: ARRAY
133856: PPUSH
133857: CALL_OW 74
133861: ST_TO_ADDR
// if not x then
133862: LD_VAR 0 10
133866: NOT
133867: IFFALSE 133871
// continue ;
133869: GO 133303
// if GetLives ( x ) < 1000 then
133871: LD_VAR 0 10
133875: PPUSH
133876: CALL_OW 256
133880: PUSH
133881: LD_INT 1000
133883: LESS
133884: IFFALSE 133908
// ComRepairVehicle ( group [ i ] , x ) else
133886: LD_VAR 0 4
133890: PUSH
133891: LD_VAR 0 7
133895: ARRAY
133896: PPUSH
133897: LD_VAR 0 10
133901: PPUSH
133902: CALL_OW 129
133906: GO 133956
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
133908: LD_VAR 0 23
133912: PUSH
133913: LD_VAR 0 4
133917: PUSH
133918: LD_VAR 0 7
133922: ARRAY
133923: PPUSH
133924: CALL_OW 256
133928: PUSH
133929: LD_INT 1000
133931: LESS
133932: AND
133933: NOT
133934: IFFALSE 133956
// ComEnterUnit ( group [ i ] , x ) ;
133936: LD_VAR 0 4
133940: PUSH
133941: LD_VAR 0 7
133945: ARRAY
133946: PPUSH
133947: LD_VAR 0 10
133951: PPUSH
133952: CALL_OW 120
// end ; continue ;
133956: GO 133303
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
133958: LD_VAR 0 23
133962: PUSH
133963: LD_VAR 0 4
133967: PUSH
133968: LD_VAR 0 7
133972: ARRAY
133973: PPUSH
133974: CALL_OW 247
133978: PUSH
133979: LD_INT 1
133981: EQUAL
133982: AND
133983: IFFALSE 134461
// begin if group [ i ] in healers then
133985: LD_VAR 0 4
133989: PUSH
133990: LD_VAR 0 7
133994: ARRAY
133995: PUSH
133996: LD_VAR 0 31
134000: IN
134001: IFFALSE 134274
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
134003: LD_VAR 0 4
134007: PUSH
134008: LD_VAR 0 7
134012: ARRAY
134013: PPUSH
134014: LD_VAR 0 23
134018: PPUSH
134019: CALL_OW 308
134023: NOT
134024: PUSH
134025: LD_VAR 0 4
134029: PUSH
134030: LD_VAR 0 7
134034: ARRAY
134035: PPUSH
134036: CALL_OW 314
134040: NOT
134041: AND
134042: IFFALSE 134066
// ComMoveToArea ( group [ i ] , f_heal ) else
134044: LD_VAR 0 4
134048: PUSH
134049: LD_VAR 0 7
134053: ARRAY
134054: PPUSH
134055: LD_VAR 0 23
134059: PPUSH
134060: CALL_OW 113
134064: GO 134272
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
134066: LD_VAR 0 4
134070: PUSH
134071: LD_VAR 0 7
134075: ARRAY
134076: PPUSH
134077: CALL 104515 0 1
134081: PPUSH
134082: CALL_OW 256
134086: PUSH
134087: LD_INT 1000
134089: EQUAL
134090: IFFALSE 134109
// ComStop ( group [ i ] ) else
134092: LD_VAR 0 4
134096: PUSH
134097: LD_VAR 0 7
134101: ARRAY
134102: PPUSH
134103: CALL_OW 141
134107: GO 134272
// if not HasTask ( group [ i ] ) and to_heal then
134109: LD_VAR 0 4
134113: PUSH
134114: LD_VAR 0 7
134118: ARRAY
134119: PPUSH
134120: CALL_OW 314
134124: NOT
134125: PUSH
134126: LD_VAR 0 30
134130: AND
134131: IFFALSE 134272
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
134133: LD_ADDR_VAR 0 13
134137: PUSH
134138: LD_VAR 0 30
134142: PPUSH
134143: LD_INT 3
134145: PUSH
134146: LD_INT 54
134148: PUSH
134149: EMPTY
134150: LIST
134151: PUSH
134152: EMPTY
134153: LIST
134154: LIST
134155: PPUSH
134156: CALL_OW 72
134160: PPUSH
134161: LD_VAR 0 4
134165: PUSH
134166: LD_VAR 0 7
134170: ARRAY
134171: PPUSH
134172: CALL_OW 74
134176: ST_TO_ADDR
// if z then
134177: LD_VAR 0 13
134181: IFFALSE 134272
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
134183: LD_INT 91
134185: PUSH
134186: LD_VAR 0 13
134190: PUSH
134191: LD_INT 10
134193: PUSH
134194: EMPTY
134195: LIST
134196: LIST
134197: LIST
134198: PUSH
134199: LD_INT 81
134201: PUSH
134202: LD_VAR 0 13
134206: PPUSH
134207: CALL_OW 255
134211: PUSH
134212: EMPTY
134213: LIST
134214: LIST
134215: PUSH
134216: EMPTY
134217: LIST
134218: LIST
134219: PPUSH
134220: CALL_OW 69
134224: PUSH
134225: LD_INT 0
134227: EQUAL
134228: IFFALSE 134252
// ComHeal ( group [ i ] , z ) else
134230: LD_VAR 0 4
134234: PUSH
134235: LD_VAR 0 7
134239: ARRAY
134240: PPUSH
134241: LD_VAR 0 13
134245: PPUSH
134246: CALL_OW 128
134250: GO 134272
// ComMoveToArea ( group [ i ] , f_heal ) ;
134252: LD_VAR 0 4
134256: PUSH
134257: LD_VAR 0 7
134261: ARRAY
134262: PPUSH
134263: LD_VAR 0 23
134267: PPUSH
134268: CALL_OW 113
// end ; continue ;
134272: GO 133303
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
134274: LD_VAR 0 4
134278: PUSH
134279: LD_VAR 0 7
134283: ARRAY
134284: PPUSH
134285: CALL_OW 256
134289: PUSH
134290: LD_INT 700
134292: LESS
134293: PUSH
134294: LD_VAR 0 4
134298: PUSH
134299: LD_VAR 0 7
134303: ARRAY
134304: PUSH
134305: LD_VAR 0 30
134309: IN
134310: NOT
134311: AND
134312: IFFALSE 134336
// to_heal := to_heal union group [ i ] ;
134314: LD_ADDR_VAR 0 30
134318: PUSH
134319: LD_VAR 0 30
134323: PUSH
134324: LD_VAR 0 4
134328: PUSH
134329: LD_VAR 0 7
134333: ARRAY
134334: UNION
134335: ST_TO_ADDR
// if group [ i ] in to_heal then
134336: LD_VAR 0 4
134340: PUSH
134341: LD_VAR 0 7
134345: ARRAY
134346: PUSH
134347: LD_VAR 0 30
134351: IN
134352: IFFALSE 134461
// begin if GetLives ( group [ i ] ) = 1000 then
134354: LD_VAR 0 4
134358: PUSH
134359: LD_VAR 0 7
134363: ARRAY
134364: PPUSH
134365: CALL_OW 256
134369: PUSH
134370: LD_INT 1000
134372: EQUAL
134373: IFFALSE 134399
// to_heal := to_heal diff group [ i ] else
134375: LD_ADDR_VAR 0 30
134379: PUSH
134380: LD_VAR 0 30
134384: PUSH
134385: LD_VAR 0 4
134389: PUSH
134390: LD_VAR 0 7
134394: ARRAY
134395: DIFF
134396: ST_TO_ADDR
134397: GO 134461
// begin if not IsInArea ( group [ i ] , to_heal ) then
134399: LD_VAR 0 4
134403: PUSH
134404: LD_VAR 0 7
134408: ARRAY
134409: PPUSH
134410: LD_VAR 0 30
134414: PPUSH
134415: CALL_OW 308
134419: NOT
134420: IFFALSE 134444
// ComMoveToArea ( group [ i ] , f_heal ) else
134422: LD_VAR 0 4
134426: PUSH
134427: LD_VAR 0 7
134431: ARRAY
134432: PPUSH
134433: LD_VAR 0 23
134437: PPUSH
134438: CALL_OW 113
134442: GO 134459
// ComHold ( group [ i ] ) ;
134444: LD_VAR 0 4
134448: PUSH
134449: LD_VAR 0 7
134453: ARRAY
134454: PPUSH
134455: CALL_OW 140
// continue ;
134459: GO 133303
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
134461: LD_VAR 0 4
134465: PUSH
134466: LD_VAR 0 7
134470: ARRAY
134471: PPUSH
134472: LD_INT 10
134474: PPUSH
134475: CALL 102297 0 2
134479: NOT
134480: PUSH
134481: LD_VAR 0 16
134485: PUSH
134486: LD_VAR 0 7
134490: ARRAY
134491: PUSH
134492: EMPTY
134493: EQUAL
134494: NOT
134495: AND
134496: IFFALSE 134762
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
134498: LD_VAR 0 4
134502: PUSH
134503: LD_VAR 0 7
134507: ARRAY
134508: PPUSH
134509: CALL_OW 262
134513: PUSH
134514: LD_INT 1
134516: PUSH
134517: LD_INT 2
134519: PUSH
134520: EMPTY
134521: LIST
134522: LIST
134523: IN
134524: IFFALSE 134565
// if GetFuel ( group [ i ] ) < 10 then
134526: LD_VAR 0 4
134530: PUSH
134531: LD_VAR 0 7
134535: ARRAY
134536: PPUSH
134537: CALL_OW 261
134541: PUSH
134542: LD_INT 10
134544: LESS
134545: IFFALSE 134565
// SetFuel ( group [ i ] , 12 ) ;
134547: LD_VAR 0 4
134551: PUSH
134552: LD_VAR 0 7
134556: ARRAY
134557: PPUSH
134558: LD_INT 12
134560: PPUSH
134561: CALL_OW 240
// if units_path [ i ] then
134565: LD_VAR 0 16
134569: PUSH
134570: LD_VAR 0 7
134574: ARRAY
134575: IFFALSE 134760
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
134577: LD_VAR 0 4
134581: PUSH
134582: LD_VAR 0 7
134586: ARRAY
134587: PPUSH
134588: LD_VAR 0 16
134592: PUSH
134593: LD_VAR 0 7
134597: ARRAY
134598: PUSH
134599: LD_INT 1
134601: ARRAY
134602: PUSH
134603: LD_INT 1
134605: ARRAY
134606: PPUSH
134607: LD_VAR 0 16
134611: PUSH
134612: LD_VAR 0 7
134616: ARRAY
134617: PUSH
134618: LD_INT 1
134620: ARRAY
134621: PUSH
134622: LD_INT 2
134624: ARRAY
134625: PPUSH
134626: CALL_OW 297
134630: PUSH
134631: LD_INT 6
134633: GREATER
134634: IFFALSE 134709
// begin if not HasTask ( group [ i ] ) then
134636: LD_VAR 0 4
134640: PUSH
134641: LD_VAR 0 7
134645: ARRAY
134646: PPUSH
134647: CALL_OW 314
134651: NOT
134652: IFFALSE 134707
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
134654: LD_VAR 0 4
134658: PUSH
134659: LD_VAR 0 7
134663: ARRAY
134664: PPUSH
134665: LD_VAR 0 16
134669: PUSH
134670: LD_VAR 0 7
134674: ARRAY
134675: PUSH
134676: LD_INT 1
134678: ARRAY
134679: PUSH
134680: LD_INT 1
134682: ARRAY
134683: PPUSH
134684: LD_VAR 0 16
134688: PUSH
134689: LD_VAR 0 7
134693: ARRAY
134694: PUSH
134695: LD_INT 1
134697: ARRAY
134698: PUSH
134699: LD_INT 2
134701: ARRAY
134702: PPUSH
134703: CALL_OW 114
// end else
134707: GO 134760
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
134709: LD_ADDR_VAR 0 15
134713: PUSH
134714: LD_VAR 0 16
134718: PUSH
134719: LD_VAR 0 7
134723: ARRAY
134724: PPUSH
134725: LD_INT 1
134727: PPUSH
134728: CALL_OW 3
134732: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
134733: LD_ADDR_VAR 0 16
134737: PUSH
134738: LD_VAR 0 16
134742: PPUSH
134743: LD_VAR 0 7
134747: PPUSH
134748: LD_VAR 0 15
134752: PPUSH
134753: CALL_OW 1
134757: ST_TO_ADDR
// continue ;
134758: GO 133303
// end ; end ; end else
134760: GO 137424
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
134762: LD_ADDR_VAR 0 14
134766: PUSH
134767: LD_INT 81
134769: PUSH
134770: LD_VAR 0 4
134774: PUSH
134775: LD_VAR 0 7
134779: ARRAY
134780: PPUSH
134781: CALL_OW 255
134785: PUSH
134786: EMPTY
134787: LIST
134788: LIST
134789: PPUSH
134790: CALL_OW 69
134794: ST_TO_ADDR
// if not tmp then
134795: LD_VAR 0 14
134799: NOT
134800: IFFALSE 134804
// continue ;
134802: GO 133303
// if f_ignore_area then
134804: LD_VAR 0 17
134808: IFFALSE 134896
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
134810: LD_ADDR_VAR 0 15
134814: PUSH
134815: LD_VAR 0 14
134819: PPUSH
134820: LD_INT 3
134822: PUSH
134823: LD_INT 92
134825: PUSH
134826: LD_VAR 0 17
134830: PUSH
134831: LD_INT 1
134833: ARRAY
134834: PUSH
134835: LD_VAR 0 17
134839: PUSH
134840: LD_INT 2
134842: ARRAY
134843: PUSH
134844: LD_VAR 0 17
134848: PUSH
134849: LD_INT 3
134851: ARRAY
134852: PUSH
134853: EMPTY
134854: LIST
134855: LIST
134856: LIST
134857: LIST
134858: PUSH
134859: EMPTY
134860: LIST
134861: LIST
134862: PPUSH
134863: CALL_OW 72
134867: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
134868: LD_VAR 0 14
134872: PUSH
134873: LD_VAR 0 15
134877: DIFF
134878: IFFALSE 134896
// tmp := tmp diff tmp2 ;
134880: LD_ADDR_VAR 0 14
134884: PUSH
134885: LD_VAR 0 14
134889: PUSH
134890: LD_VAR 0 15
134894: DIFF
134895: ST_TO_ADDR
// end ; if not f_murder then
134896: LD_VAR 0 20
134900: NOT
134901: IFFALSE 134959
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
134903: LD_ADDR_VAR 0 15
134907: PUSH
134908: LD_VAR 0 14
134912: PPUSH
134913: LD_INT 3
134915: PUSH
134916: LD_INT 50
134918: PUSH
134919: EMPTY
134920: LIST
134921: PUSH
134922: EMPTY
134923: LIST
134924: LIST
134925: PPUSH
134926: CALL_OW 72
134930: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
134931: LD_VAR 0 14
134935: PUSH
134936: LD_VAR 0 15
134940: DIFF
134941: IFFALSE 134959
// tmp := tmp diff tmp2 ;
134943: LD_ADDR_VAR 0 14
134947: PUSH
134948: LD_VAR 0 14
134952: PUSH
134953: LD_VAR 0 15
134957: DIFF
134958: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
134959: LD_ADDR_VAR 0 14
134963: PUSH
134964: LD_VAR 0 4
134968: PUSH
134969: LD_VAR 0 7
134973: ARRAY
134974: PPUSH
134975: LD_VAR 0 14
134979: PPUSH
134980: LD_INT 1
134982: PPUSH
134983: LD_INT 1
134985: PPUSH
134986: CALL 74841 0 4
134990: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
134991: LD_VAR 0 4
134995: PUSH
134996: LD_VAR 0 7
135000: ARRAY
135001: PPUSH
135002: CALL_OW 257
135006: PUSH
135007: LD_INT 1
135009: EQUAL
135010: IFFALSE 135458
// begin if WantPlant ( group [ i ] ) then
135012: LD_VAR 0 4
135016: PUSH
135017: LD_VAR 0 7
135021: ARRAY
135022: PPUSH
135023: CALL 74342 0 1
135027: IFFALSE 135031
// continue ;
135029: GO 133303
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
135031: LD_VAR 0 18
135035: PUSH
135036: LD_VAR 0 4
135040: PUSH
135041: LD_VAR 0 7
135045: ARRAY
135046: PPUSH
135047: CALL_OW 310
135051: NOT
135052: AND
135053: PUSH
135054: LD_VAR 0 14
135058: PUSH
135059: LD_INT 1
135061: ARRAY
135062: PUSH
135063: LD_VAR 0 14
135067: PPUSH
135068: LD_INT 21
135070: PUSH
135071: LD_INT 2
135073: PUSH
135074: EMPTY
135075: LIST
135076: LIST
135077: PUSH
135078: LD_INT 58
135080: PUSH
135081: EMPTY
135082: LIST
135083: PUSH
135084: EMPTY
135085: LIST
135086: LIST
135087: PPUSH
135088: CALL_OW 72
135092: IN
135093: AND
135094: IFFALSE 135130
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
135096: LD_VAR 0 4
135100: PUSH
135101: LD_VAR 0 7
135105: ARRAY
135106: PPUSH
135107: LD_VAR 0 14
135111: PUSH
135112: LD_INT 1
135114: ARRAY
135115: PPUSH
135116: CALL_OW 120
// attacking := true ;
135120: LD_ADDR_VAR 0 29
135124: PUSH
135125: LD_INT 1
135127: ST_TO_ADDR
// continue ;
135128: GO 133303
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
135130: LD_VAR 0 26
135134: PUSH
135135: LD_VAR 0 4
135139: PUSH
135140: LD_VAR 0 7
135144: ARRAY
135145: PPUSH
135146: CALL_OW 257
135150: PUSH
135151: LD_INT 1
135153: EQUAL
135154: AND
135155: PUSH
135156: LD_VAR 0 4
135160: PUSH
135161: LD_VAR 0 7
135165: ARRAY
135166: PPUSH
135167: CALL_OW 256
135171: PUSH
135172: LD_INT 800
135174: LESS
135175: AND
135176: PUSH
135177: LD_VAR 0 4
135181: PUSH
135182: LD_VAR 0 7
135186: ARRAY
135187: PPUSH
135188: CALL_OW 318
135192: NOT
135193: AND
135194: IFFALSE 135211
// ComCrawl ( group [ i ] ) ;
135196: LD_VAR 0 4
135200: PUSH
135201: LD_VAR 0 7
135205: ARRAY
135206: PPUSH
135207: CALL_OW 137
// if f_mines then
135211: LD_VAR 0 21
135215: IFFALSE 135458
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
135217: LD_VAR 0 14
135221: PUSH
135222: LD_INT 1
135224: ARRAY
135225: PPUSH
135226: CALL_OW 247
135230: PUSH
135231: LD_INT 3
135233: EQUAL
135234: PUSH
135235: LD_VAR 0 14
135239: PUSH
135240: LD_INT 1
135242: ARRAY
135243: PUSH
135244: LD_VAR 0 27
135248: IN
135249: NOT
135250: AND
135251: IFFALSE 135458
// begin x := GetX ( tmp [ 1 ] ) ;
135253: LD_ADDR_VAR 0 10
135257: PUSH
135258: LD_VAR 0 14
135262: PUSH
135263: LD_INT 1
135265: ARRAY
135266: PPUSH
135267: CALL_OW 250
135271: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
135272: LD_ADDR_VAR 0 11
135276: PUSH
135277: LD_VAR 0 14
135281: PUSH
135282: LD_INT 1
135284: ARRAY
135285: PPUSH
135286: CALL_OW 251
135290: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
135291: LD_ADDR_VAR 0 12
135295: PUSH
135296: LD_VAR 0 4
135300: PUSH
135301: LD_VAR 0 7
135305: ARRAY
135306: PPUSH
135307: CALL 102382 0 1
135311: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
135312: LD_VAR 0 4
135316: PUSH
135317: LD_VAR 0 7
135321: ARRAY
135322: PPUSH
135323: LD_VAR 0 10
135327: PPUSH
135328: LD_VAR 0 11
135332: PPUSH
135333: LD_VAR 0 14
135337: PUSH
135338: LD_INT 1
135340: ARRAY
135341: PPUSH
135342: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
135346: LD_VAR 0 4
135350: PUSH
135351: LD_VAR 0 7
135355: ARRAY
135356: PPUSH
135357: LD_VAR 0 10
135361: PPUSH
135362: LD_VAR 0 12
135366: PPUSH
135367: LD_INT 7
135369: PPUSH
135370: CALL_OW 272
135374: PPUSH
135375: LD_VAR 0 11
135379: PPUSH
135380: LD_VAR 0 12
135384: PPUSH
135385: LD_INT 7
135387: PPUSH
135388: CALL_OW 273
135392: PPUSH
135393: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
135397: LD_VAR 0 4
135401: PUSH
135402: LD_VAR 0 7
135406: ARRAY
135407: PPUSH
135408: LD_INT 71
135410: PPUSH
135411: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
135415: LD_ADDR_VAR 0 27
135419: PUSH
135420: LD_VAR 0 27
135424: PPUSH
135425: LD_VAR 0 27
135429: PUSH
135430: LD_INT 1
135432: PLUS
135433: PPUSH
135434: LD_VAR 0 14
135438: PUSH
135439: LD_INT 1
135441: ARRAY
135442: PPUSH
135443: CALL_OW 1
135447: ST_TO_ADDR
// attacking := true ;
135448: LD_ADDR_VAR 0 29
135452: PUSH
135453: LD_INT 1
135455: ST_TO_ADDR
// continue ;
135456: GO 133303
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
135458: LD_VAR 0 4
135462: PUSH
135463: LD_VAR 0 7
135467: ARRAY
135468: PPUSH
135469: CALL_OW 257
135473: PUSH
135474: LD_INT 17
135476: EQUAL
135477: PUSH
135478: LD_VAR 0 4
135482: PUSH
135483: LD_VAR 0 7
135487: ARRAY
135488: PPUSH
135489: CALL_OW 110
135493: PUSH
135494: LD_INT 71
135496: EQUAL
135497: NOT
135498: AND
135499: IFFALSE 135645
// begin attacking := false ;
135501: LD_ADDR_VAR 0 29
135505: PUSH
135506: LD_INT 0
135508: ST_TO_ADDR
// k := 5 ;
135509: LD_ADDR_VAR 0 9
135513: PUSH
135514: LD_INT 5
135516: ST_TO_ADDR
// if tmp < k then
135517: LD_VAR 0 14
135521: PUSH
135522: LD_VAR 0 9
135526: LESS
135527: IFFALSE 135539
// k := tmp ;
135529: LD_ADDR_VAR 0 9
135533: PUSH
135534: LD_VAR 0 14
135538: ST_TO_ADDR
// for j = 1 to k do
135539: LD_ADDR_VAR 0 8
135543: PUSH
135544: DOUBLE
135545: LD_INT 1
135547: DEC
135548: ST_TO_ADDR
135549: LD_VAR 0 9
135553: PUSH
135554: FOR_TO
135555: IFFALSE 135643
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
135557: LD_VAR 0 14
135561: PUSH
135562: LD_VAR 0 8
135566: ARRAY
135567: PUSH
135568: LD_VAR 0 14
135572: PPUSH
135573: LD_INT 58
135575: PUSH
135576: EMPTY
135577: LIST
135578: PPUSH
135579: CALL_OW 72
135583: IN
135584: NOT
135585: IFFALSE 135641
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
135587: LD_VAR 0 4
135591: PUSH
135592: LD_VAR 0 7
135596: ARRAY
135597: PPUSH
135598: LD_VAR 0 14
135602: PUSH
135603: LD_VAR 0 8
135607: ARRAY
135608: PPUSH
135609: CALL_OW 115
// attacking := true ;
135613: LD_ADDR_VAR 0 29
135617: PUSH
135618: LD_INT 1
135620: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
135621: LD_VAR 0 4
135625: PUSH
135626: LD_VAR 0 7
135630: ARRAY
135631: PPUSH
135632: LD_INT 71
135634: PPUSH
135635: CALL_OW 109
// continue ;
135639: GO 135554
// end ; end ;
135641: GO 135554
135643: POP
135644: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
135645: LD_VAR 0 4
135649: PUSH
135650: LD_VAR 0 7
135654: ARRAY
135655: PPUSH
135656: CALL_OW 257
135660: PUSH
135661: LD_INT 8
135663: EQUAL
135664: PUSH
135665: LD_VAR 0 4
135669: PUSH
135670: LD_VAR 0 7
135674: ARRAY
135675: PPUSH
135676: CALL_OW 264
135680: PUSH
135681: LD_INT 28
135683: PUSH
135684: LD_INT 45
135686: PUSH
135687: LD_INT 7
135689: PUSH
135690: LD_INT 47
135692: PUSH
135693: EMPTY
135694: LIST
135695: LIST
135696: LIST
135697: LIST
135698: IN
135699: OR
135700: IFFALSE 135956
// begin attacking := false ;
135702: LD_ADDR_VAR 0 29
135706: PUSH
135707: LD_INT 0
135709: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
135710: LD_VAR 0 14
135714: PUSH
135715: LD_INT 1
135717: ARRAY
135718: PPUSH
135719: CALL_OW 266
135723: PUSH
135724: LD_INT 32
135726: PUSH
135727: LD_INT 31
135729: PUSH
135730: LD_INT 33
135732: PUSH
135733: LD_INT 4
135735: PUSH
135736: LD_INT 5
135738: PUSH
135739: EMPTY
135740: LIST
135741: LIST
135742: LIST
135743: LIST
135744: LIST
135745: IN
135746: IFFALSE 135932
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
135748: LD_ADDR_VAR 0 9
135752: PUSH
135753: LD_VAR 0 14
135757: PUSH
135758: LD_INT 1
135760: ARRAY
135761: PPUSH
135762: CALL_OW 266
135766: PPUSH
135767: LD_VAR 0 14
135771: PUSH
135772: LD_INT 1
135774: ARRAY
135775: PPUSH
135776: CALL_OW 250
135780: PPUSH
135781: LD_VAR 0 14
135785: PUSH
135786: LD_INT 1
135788: ARRAY
135789: PPUSH
135790: CALL_OW 251
135794: PPUSH
135795: LD_VAR 0 14
135799: PUSH
135800: LD_INT 1
135802: ARRAY
135803: PPUSH
135804: CALL_OW 254
135808: PPUSH
135809: LD_VAR 0 14
135813: PUSH
135814: LD_INT 1
135816: ARRAY
135817: PPUSH
135818: CALL_OW 248
135822: PPUSH
135823: LD_INT 0
135825: PPUSH
135826: CALL 83752 0 6
135830: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
135831: LD_ADDR_VAR 0 8
135835: PUSH
135836: LD_VAR 0 4
135840: PUSH
135841: LD_VAR 0 7
135845: ARRAY
135846: PPUSH
135847: LD_VAR 0 9
135851: PPUSH
135852: CALL 102495 0 2
135856: ST_TO_ADDR
// if j then
135857: LD_VAR 0 8
135861: IFFALSE 135930
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
135863: LD_VAR 0 8
135867: PUSH
135868: LD_INT 1
135870: ARRAY
135871: PPUSH
135872: LD_VAR 0 8
135876: PUSH
135877: LD_INT 2
135879: ARRAY
135880: PPUSH
135881: CALL_OW 488
135885: IFFALSE 135930
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
135887: LD_VAR 0 4
135891: PUSH
135892: LD_VAR 0 7
135896: ARRAY
135897: PPUSH
135898: LD_VAR 0 8
135902: PUSH
135903: LD_INT 1
135905: ARRAY
135906: PPUSH
135907: LD_VAR 0 8
135911: PUSH
135912: LD_INT 2
135914: ARRAY
135915: PPUSH
135916: CALL_OW 116
// attacking := true ;
135920: LD_ADDR_VAR 0 29
135924: PUSH
135925: LD_INT 1
135927: ST_TO_ADDR
// continue ;
135928: GO 133303
// end ; end else
135930: GO 135956
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
135932: LD_VAR 0 4
135936: PUSH
135937: LD_VAR 0 7
135941: ARRAY
135942: PPUSH
135943: LD_VAR 0 14
135947: PUSH
135948: LD_INT 1
135950: ARRAY
135951: PPUSH
135952: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
135956: LD_VAR 0 4
135960: PUSH
135961: LD_VAR 0 7
135965: ARRAY
135966: PPUSH
135967: CALL_OW 265
135971: PUSH
135972: LD_INT 11
135974: EQUAL
135975: IFFALSE 136253
// begin k := 10 ;
135977: LD_ADDR_VAR 0 9
135981: PUSH
135982: LD_INT 10
135984: ST_TO_ADDR
// x := 0 ;
135985: LD_ADDR_VAR 0 10
135989: PUSH
135990: LD_INT 0
135992: ST_TO_ADDR
// if tmp < k then
135993: LD_VAR 0 14
135997: PUSH
135998: LD_VAR 0 9
136002: LESS
136003: IFFALSE 136015
// k := tmp ;
136005: LD_ADDR_VAR 0 9
136009: PUSH
136010: LD_VAR 0 14
136014: ST_TO_ADDR
// for j = k downto 1 do
136015: LD_ADDR_VAR 0 8
136019: PUSH
136020: DOUBLE
136021: LD_VAR 0 9
136025: INC
136026: ST_TO_ADDR
136027: LD_INT 1
136029: PUSH
136030: FOR_DOWNTO
136031: IFFALSE 136106
// begin if GetType ( tmp [ j ] ) = unit_human then
136033: LD_VAR 0 14
136037: PUSH
136038: LD_VAR 0 8
136042: ARRAY
136043: PPUSH
136044: CALL_OW 247
136048: PUSH
136049: LD_INT 1
136051: EQUAL
136052: IFFALSE 136104
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
136054: LD_VAR 0 4
136058: PUSH
136059: LD_VAR 0 7
136063: ARRAY
136064: PPUSH
136065: LD_VAR 0 14
136069: PUSH
136070: LD_VAR 0 8
136074: ARRAY
136075: PPUSH
136076: CALL 102749 0 2
// x := tmp [ j ] ;
136080: LD_ADDR_VAR 0 10
136084: PUSH
136085: LD_VAR 0 14
136089: PUSH
136090: LD_VAR 0 8
136094: ARRAY
136095: ST_TO_ADDR
// attacking := true ;
136096: LD_ADDR_VAR 0 29
136100: PUSH
136101: LD_INT 1
136103: ST_TO_ADDR
// end ; end ;
136104: GO 136030
136106: POP
136107: POP
// if not x then
136108: LD_VAR 0 10
136112: NOT
136113: IFFALSE 136253
// begin attacking := true ;
136115: LD_ADDR_VAR 0 29
136119: PUSH
136120: LD_INT 1
136122: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
136123: LD_VAR 0 4
136127: PUSH
136128: LD_VAR 0 7
136132: ARRAY
136133: PPUSH
136134: CALL_OW 250
136138: PPUSH
136139: LD_VAR 0 4
136143: PUSH
136144: LD_VAR 0 7
136148: ARRAY
136149: PPUSH
136150: CALL_OW 251
136154: PPUSH
136155: CALL_OW 546
136159: PUSH
136160: LD_INT 2
136162: ARRAY
136163: PUSH
136164: LD_VAR 0 14
136168: PUSH
136169: LD_INT 1
136171: ARRAY
136172: PPUSH
136173: CALL_OW 250
136177: PPUSH
136178: LD_VAR 0 14
136182: PUSH
136183: LD_INT 1
136185: ARRAY
136186: PPUSH
136187: CALL_OW 251
136191: PPUSH
136192: CALL_OW 546
136196: PUSH
136197: LD_INT 2
136199: ARRAY
136200: EQUAL
136201: IFFALSE 136229
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
136203: LD_VAR 0 4
136207: PUSH
136208: LD_VAR 0 7
136212: ARRAY
136213: PPUSH
136214: LD_VAR 0 14
136218: PUSH
136219: LD_INT 1
136221: ARRAY
136222: PPUSH
136223: CALL 102749 0 2
136227: GO 136253
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
136229: LD_VAR 0 4
136233: PUSH
136234: LD_VAR 0 7
136238: ARRAY
136239: PPUSH
136240: LD_VAR 0 14
136244: PUSH
136245: LD_INT 1
136247: ARRAY
136248: PPUSH
136249: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
136253: LD_VAR 0 4
136257: PUSH
136258: LD_VAR 0 7
136262: ARRAY
136263: PPUSH
136264: CALL_OW 264
136268: PUSH
136269: LD_INT 29
136271: EQUAL
136272: IFFALSE 136638
// begin if WantsToAttack ( group [ i ] ) in bombed then
136274: LD_VAR 0 4
136278: PUSH
136279: LD_VAR 0 7
136283: ARRAY
136284: PPUSH
136285: CALL_OW 319
136289: PUSH
136290: LD_VAR 0 28
136294: IN
136295: IFFALSE 136299
// continue ;
136297: GO 133303
// k := 8 ;
136299: LD_ADDR_VAR 0 9
136303: PUSH
136304: LD_INT 8
136306: ST_TO_ADDR
// x := 0 ;
136307: LD_ADDR_VAR 0 10
136311: PUSH
136312: LD_INT 0
136314: ST_TO_ADDR
// if tmp < k then
136315: LD_VAR 0 14
136319: PUSH
136320: LD_VAR 0 9
136324: LESS
136325: IFFALSE 136337
// k := tmp ;
136327: LD_ADDR_VAR 0 9
136331: PUSH
136332: LD_VAR 0 14
136336: ST_TO_ADDR
// for j = 1 to k do
136337: LD_ADDR_VAR 0 8
136341: PUSH
136342: DOUBLE
136343: LD_INT 1
136345: DEC
136346: ST_TO_ADDR
136347: LD_VAR 0 9
136351: PUSH
136352: FOR_TO
136353: IFFALSE 136485
// begin if GetType ( tmp [ j ] ) = unit_building then
136355: LD_VAR 0 14
136359: PUSH
136360: LD_VAR 0 8
136364: ARRAY
136365: PPUSH
136366: CALL_OW 247
136370: PUSH
136371: LD_INT 3
136373: EQUAL
136374: IFFALSE 136483
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
136376: LD_VAR 0 14
136380: PUSH
136381: LD_VAR 0 8
136385: ARRAY
136386: PUSH
136387: LD_VAR 0 28
136391: IN
136392: NOT
136393: PUSH
136394: LD_VAR 0 14
136398: PUSH
136399: LD_VAR 0 8
136403: ARRAY
136404: PPUSH
136405: CALL_OW 313
136409: AND
136410: IFFALSE 136483
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
136412: LD_VAR 0 4
136416: PUSH
136417: LD_VAR 0 7
136421: ARRAY
136422: PPUSH
136423: LD_VAR 0 14
136427: PUSH
136428: LD_VAR 0 8
136432: ARRAY
136433: PPUSH
136434: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
136438: LD_ADDR_VAR 0 28
136442: PUSH
136443: LD_VAR 0 28
136447: PPUSH
136448: LD_VAR 0 28
136452: PUSH
136453: LD_INT 1
136455: PLUS
136456: PPUSH
136457: LD_VAR 0 14
136461: PUSH
136462: LD_VAR 0 8
136466: ARRAY
136467: PPUSH
136468: CALL_OW 1
136472: ST_TO_ADDR
// attacking := true ;
136473: LD_ADDR_VAR 0 29
136477: PUSH
136478: LD_INT 1
136480: ST_TO_ADDR
// break ;
136481: GO 136485
// end ; end ;
136483: GO 136352
136485: POP
136486: POP
// if not attacking and f_attack_depot then
136487: LD_VAR 0 29
136491: NOT
136492: PUSH
136493: LD_VAR 0 25
136497: AND
136498: IFFALSE 136593
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
136500: LD_ADDR_VAR 0 13
136504: PUSH
136505: LD_VAR 0 14
136509: PPUSH
136510: LD_INT 2
136512: PUSH
136513: LD_INT 30
136515: PUSH
136516: LD_INT 0
136518: PUSH
136519: EMPTY
136520: LIST
136521: LIST
136522: PUSH
136523: LD_INT 30
136525: PUSH
136526: LD_INT 1
136528: PUSH
136529: EMPTY
136530: LIST
136531: LIST
136532: PUSH
136533: EMPTY
136534: LIST
136535: LIST
136536: LIST
136537: PPUSH
136538: CALL_OW 72
136542: ST_TO_ADDR
// if z then
136543: LD_VAR 0 13
136547: IFFALSE 136593
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
136549: LD_VAR 0 4
136553: PUSH
136554: LD_VAR 0 7
136558: ARRAY
136559: PPUSH
136560: LD_VAR 0 13
136564: PPUSH
136565: LD_VAR 0 4
136569: PUSH
136570: LD_VAR 0 7
136574: ARRAY
136575: PPUSH
136576: CALL_OW 74
136580: PPUSH
136581: CALL_OW 115
// attacking := true ;
136585: LD_ADDR_VAR 0 29
136589: PUSH
136590: LD_INT 1
136592: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
136593: LD_VAR 0 4
136597: PUSH
136598: LD_VAR 0 7
136602: ARRAY
136603: PPUSH
136604: CALL_OW 256
136608: PUSH
136609: LD_INT 500
136611: LESS
136612: IFFALSE 136638
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
136614: LD_VAR 0 4
136618: PUSH
136619: LD_VAR 0 7
136623: ARRAY
136624: PPUSH
136625: LD_VAR 0 14
136629: PUSH
136630: LD_INT 1
136632: ARRAY
136633: PPUSH
136634: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
136638: LD_VAR 0 4
136642: PUSH
136643: LD_VAR 0 7
136647: ARRAY
136648: PPUSH
136649: CALL_OW 264
136653: PUSH
136654: LD_INT 49
136656: EQUAL
136657: IFFALSE 136778
// begin if not HasTask ( group [ i ] ) then
136659: LD_VAR 0 4
136663: PUSH
136664: LD_VAR 0 7
136668: ARRAY
136669: PPUSH
136670: CALL_OW 314
136674: NOT
136675: IFFALSE 136778
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
136677: LD_ADDR_VAR 0 9
136681: PUSH
136682: LD_INT 81
136684: PUSH
136685: LD_VAR 0 4
136689: PUSH
136690: LD_VAR 0 7
136694: ARRAY
136695: PPUSH
136696: CALL_OW 255
136700: PUSH
136701: EMPTY
136702: LIST
136703: LIST
136704: PPUSH
136705: CALL_OW 69
136709: PPUSH
136710: LD_VAR 0 4
136714: PUSH
136715: LD_VAR 0 7
136719: ARRAY
136720: PPUSH
136721: CALL_OW 74
136725: ST_TO_ADDR
// if k then
136726: LD_VAR 0 9
136730: IFFALSE 136778
// if GetDistUnits ( group [ i ] , k ) > 10 then
136732: LD_VAR 0 4
136736: PUSH
136737: LD_VAR 0 7
136741: ARRAY
136742: PPUSH
136743: LD_VAR 0 9
136747: PPUSH
136748: CALL_OW 296
136752: PUSH
136753: LD_INT 10
136755: GREATER
136756: IFFALSE 136778
// ComMoveUnit ( group [ i ] , k ) ;
136758: LD_VAR 0 4
136762: PUSH
136763: LD_VAR 0 7
136767: ARRAY
136768: PPUSH
136769: LD_VAR 0 9
136773: PPUSH
136774: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
136778: LD_VAR 0 4
136782: PUSH
136783: LD_VAR 0 7
136787: ARRAY
136788: PPUSH
136789: CALL_OW 256
136793: PUSH
136794: LD_INT 250
136796: LESS
136797: PUSH
136798: LD_VAR 0 4
136802: PUSH
136803: LD_VAR 0 7
136807: ARRAY
136808: PUSH
136809: LD_INT 21
136811: PUSH
136812: LD_INT 2
136814: PUSH
136815: EMPTY
136816: LIST
136817: LIST
136818: PUSH
136819: LD_INT 23
136821: PUSH
136822: LD_INT 2
136824: PUSH
136825: EMPTY
136826: LIST
136827: LIST
136828: PUSH
136829: EMPTY
136830: LIST
136831: LIST
136832: PPUSH
136833: CALL_OW 69
136837: IN
136838: AND
136839: IFFALSE 136964
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
136841: LD_ADDR_VAR 0 9
136845: PUSH
136846: LD_OWVAR 3
136850: PUSH
136851: LD_VAR 0 4
136855: PUSH
136856: LD_VAR 0 7
136860: ARRAY
136861: DIFF
136862: PPUSH
136863: LD_VAR 0 4
136867: PUSH
136868: LD_VAR 0 7
136872: ARRAY
136873: PPUSH
136874: CALL_OW 74
136878: ST_TO_ADDR
// if not k then
136879: LD_VAR 0 9
136883: NOT
136884: IFFALSE 136888
// continue ;
136886: GO 133303
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
136888: LD_VAR 0 9
136892: PUSH
136893: LD_INT 81
136895: PUSH
136896: LD_VAR 0 4
136900: PUSH
136901: LD_VAR 0 7
136905: ARRAY
136906: PPUSH
136907: CALL_OW 255
136911: PUSH
136912: EMPTY
136913: LIST
136914: LIST
136915: PPUSH
136916: CALL_OW 69
136920: IN
136921: PUSH
136922: LD_VAR 0 9
136926: PPUSH
136927: LD_VAR 0 4
136931: PUSH
136932: LD_VAR 0 7
136936: ARRAY
136937: PPUSH
136938: CALL_OW 296
136942: PUSH
136943: LD_INT 5
136945: LESS
136946: AND
136947: IFFALSE 136964
// ComAutodestruct ( group [ i ] ) ;
136949: LD_VAR 0 4
136953: PUSH
136954: LD_VAR 0 7
136958: ARRAY
136959: PPUSH
136960: CALL 102647 0 1
// end ; if f_attack_depot then
136964: LD_VAR 0 25
136968: IFFALSE 137080
// begin k := 6 ;
136970: LD_ADDR_VAR 0 9
136974: PUSH
136975: LD_INT 6
136977: ST_TO_ADDR
// if tmp < k then
136978: LD_VAR 0 14
136982: PUSH
136983: LD_VAR 0 9
136987: LESS
136988: IFFALSE 137000
// k := tmp ;
136990: LD_ADDR_VAR 0 9
136994: PUSH
136995: LD_VAR 0 14
136999: ST_TO_ADDR
// for j = 1 to k do
137000: LD_ADDR_VAR 0 8
137004: PUSH
137005: DOUBLE
137006: LD_INT 1
137008: DEC
137009: ST_TO_ADDR
137010: LD_VAR 0 9
137014: PUSH
137015: FOR_TO
137016: IFFALSE 137078
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
137018: LD_VAR 0 8
137022: PPUSH
137023: CALL_OW 266
137027: PUSH
137028: LD_INT 0
137030: PUSH
137031: LD_INT 1
137033: PUSH
137034: EMPTY
137035: LIST
137036: LIST
137037: IN
137038: IFFALSE 137076
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
137040: LD_VAR 0 4
137044: PUSH
137045: LD_VAR 0 7
137049: ARRAY
137050: PPUSH
137051: LD_VAR 0 14
137055: PUSH
137056: LD_VAR 0 8
137060: ARRAY
137061: PPUSH
137062: CALL_OW 115
// attacking := true ;
137066: LD_ADDR_VAR 0 29
137070: PUSH
137071: LD_INT 1
137073: ST_TO_ADDR
// break ;
137074: GO 137078
// end ;
137076: GO 137015
137078: POP
137079: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
137080: LD_VAR 0 4
137084: PUSH
137085: LD_VAR 0 7
137089: ARRAY
137090: PPUSH
137091: CALL_OW 302
137095: PUSH
137096: LD_VAR 0 29
137100: NOT
137101: AND
137102: IFFALSE 137424
// begin if GetTag ( group [ i ] ) = 71 then
137104: LD_VAR 0 4
137108: PUSH
137109: LD_VAR 0 7
137113: ARRAY
137114: PPUSH
137115: CALL_OW 110
137119: PUSH
137120: LD_INT 71
137122: EQUAL
137123: IFFALSE 137164
// begin if HasTask ( group [ i ] ) then
137125: LD_VAR 0 4
137129: PUSH
137130: LD_VAR 0 7
137134: ARRAY
137135: PPUSH
137136: CALL_OW 314
137140: IFFALSE 137146
// continue else
137142: GO 133303
137144: GO 137164
// SetTag ( group [ i ] , 0 ) ;
137146: LD_VAR 0 4
137150: PUSH
137151: LD_VAR 0 7
137155: ARRAY
137156: PPUSH
137157: LD_INT 0
137159: PPUSH
137160: CALL_OW 109
// end ; k := 8 ;
137164: LD_ADDR_VAR 0 9
137168: PUSH
137169: LD_INT 8
137171: ST_TO_ADDR
// x := 0 ;
137172: LD_ADDR_VAR 0 10
137176: PUSH
137177: LD_INT 0
137179: ST_TO_ADDR
// if tmp < k then
137180: LD_VAR 0 14
137184: PUSH
137185: LD_VAR 0 9
137189: LESS
137190: IFFALSE 137202
// k := tmp ;
137192: LD_ADDR_VAR 0 9
137196: PUSH
137197: LD_VAR 0 14
137201: ST_TO_ADDR
// for j = 1 to k do
137202: LD_ADDR_VAR 0 8
137206: PUSH
137207: DOUBLE
137208: LD_INT 1
137210: DEC
137211: ST_TO_ADDR
137212: LD_VAR 0 9
137216: PUSH
137217: FOR_TO
137218: IFFALSE 137316
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
137220: LD_VAR 0 14
137224: PUSH
137225: LD_VAR 0 8
137229: ARRAY
137230: PPUSH
137231: CALL_OW 247
137235: PUSH
137236: LD_INT 1
137238: EQUAL
137239: PUSH
137240: LD_VAR 0 14
137244: PUSH
137245: LD_VAR 0 8
137249: ARRAY
137250: PPUSH
137251: CALL_OW 256
137255: PUSH
137256: LD_INT 250
137258: LESS
137259: PUSH
137260: LD_VAR 0 20
137264: AND
137265: PUSH
137266: LD_VAR 0 20
137270: NOT
137271: PUSH
137272: LD_VAR 0 14
137276: PUSH
137277: LD_VAR 0 8
137281: ARRAY
137282: PPUSH
137283: CALL_OW 256
137287: PUSH
137288: LD_INT 250
137290: GREATEREQUAL
137291: AND
137292: OR
137293: AND
137294: IFFALSE 137314
// begin x := tmp [ j ] ;
137296: LD_ADDR_VAR 0 10
137300: PUSH
137301: LD_VAR 0 14
137305: PUSH
137306: LD_VAR 0 8
137310: ARRAY
137311: ST_TO_ADDR
// break ;
137312: GO 137316
// end ;
137314: GO 137217
137316: POP
137317: POP
// if x then
137318: LD_VAR 0 10
137322: IFFALSE 137346
// ComAttackUnit ( group [ i ] , x ) else
137324: LD_VAR 0 4
137328: PUSH
137329: LD_VAR 0 7
137333: ARRAY
137334: PPUSH
137335: LD_VAR 0 10
137339: PPUSH
137340: CALL_OW 115
137344: GO 137370
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
137346: LD_VAR 0 4
137350: PUSH
137351: LD_VAR 0 7
137355: ARRAY
137356: PPUSH
137357: LD_VAR 0 14
137361: PUSH
137362: LD_INT 1
137364: ARRAY
137365: PPUSH
137366: CALL_OW 115
// if not HasTask ( group [ i ] ) then
137370: LD_VAR 0 4
137374: PUSH
137375: LD_VAR 0 7
137379: ARRAY
137380: PPUSH
137381: CALL_OW 314
137385: NOT
137386: IFFALSE 137424
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
137388: LD_VAR 0 4
137392: PUSH
137393: LD_VAR 0 7
137397: ARRAY
137398: PPUSH
137399: LD_VAR 0 14
137403: PPUSH
137404: LD_VAR 0 4
137408: PUSH
137409: LD_VAR 0 7
137413: ARRAY
137414: PPUSH
137415: CALL_OW 74
137419: PPUSH
137420: CALL_OW 115
// end ; end ; end ;
137424: GO 133303
137426: POP
137427: POP
// wait ( 0 0$2 ) ;
137428: LD_INT 70
137430: PPUSH
137431: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
137435: LD_VAR 0 4
137439: NOT
137440: PUSH
137441: LD_VAR 0 4
137445: PUSH
137446: EMPTY
137447: EQUAL
137448: OR
137449: PUSH
137450: LD_INT 81
137452: PUSH
137453: LD_VAR 0 35
137457: PUSH
137458: EMPTY
137459: LIST
137460: LIST
137461: PPUSH
137462: CALL_OW 69
137466: NOT
137467: OR
137468: IFFALSE 133288
// end ;
137470: LD_VAR 0 2
137474: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
137475: LD_INT 0
137477: PPUSH
137478: PPUSH
137479: PPUSH
137480: PPUSH
137481: PPUSH
137482: PPUSH
// if not base or not mc_bases [ base ] or not solds then
137483: LD_VAR 0 1
137487: NOT
137488: PUSH
137489: LD_EXP 101
137493: PUSH
137494: LD_VAR 0 1
137498: ARRAY
137499: NOT
137500: OR
137501: PUSH
137502: LD_VAR 0 2
137506: NOT
137507: OR
137508: IFFALSE 137512
// exit ;
137510: GO 138066
// side := mc_sides [ base ] ;
137512: LD_ADDR_VAR 0 6
137516: PUSH
137517: LD_EXP 127
137521: PUSH
137522: LD_VAR 0 1
137526: ARRAY
137527: ST_TO_ADDR
// if not side then
137528: LD_VAR 0 6
137532: NOT
137533: IFFALSE 137537
// exit ;
137535: GO 138066
// for i in solds do
137537: LD_ADDR_VAR 0 7
137541: PUSH
137542: LD_VAR 0 2
137546: PUSH
137547: FOR_IN
137548: IFFALSE 137609
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
137550: LD_VAR 0 7
137554: PPUSH
137555: CALL_OW 310
137559: PPUSH
137560: CALL_OW 266
137564: PUSH
137565: LD_INT 32
137567: PUSH
137568: LD_INT 31
137570: PUSH
137571: EMPTY
137572: LIST
137573: LIST
137574: IN
137575: IFFALSE 137595
// solds := solds diff i else
137577: LD_ADDR_VAR 0 2
137581: PUSH
137582: LD_VAR 0 2
137586: PUSH
137587: LD_VAR 0 7
137591: DIFF
137592: ST_TO_ADDR
137593: GO 137607
// SetTag ( i , 18 ) ;
137595: LD_VAR 0 7
137599: PPUSH
137600: LD_INT 18
137602: PPUSH
137603: CALL_OW 109
137607: GO 137547
137609: POP
137610: POP
// if not solds then
137611: LD_VAR 0 2
137615: NOT
137616: IFFALSE 137620
// exit ;
137618: GO 138066
// repeat wait ( 0 0$2 ) ;
137620: LD_INT 70
137622: PPUSH
137623: CALL_OW 67
// enemy := mc_scan [ base ] ;
137627: LD_ADDR_VAR 0 4
137631: PUSH
137632: LD_EXP 124
137636: PUSH
137637: LD_VAR 0 1
137641: ARRAY
137642: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
137643: LD_EXP 101
137647: PUSH
137648: LD_VAR 0 1
137652: ARRAY
137653: NOT
137654: PUSH
137655: LD_EXP 101
137659: PUSH
137660: LD_VAR 0 1
137664: ARRAY
137665: PUSH
137666: EMPTY
137667: EQUAL
137668: OR
137669: IFFALSE 137706
// begin for i in solds do
137671: LD_ADDR_VAR 0 7
137675: PUSH
137676: LD_VAR 0 2
137680: PUSH
137681: FOR_IN
137682: IFFALSE 137695
// ComStop ( i ) ;
137684: LD_VAR 0 7
137688: PPUSH
137689: CALL_OW 141
137693: GO 137681
137695: POP
137696: POP
// solds := [ ] ;
137697: LD_ADDR_VAR 0 2
137701: PUSH
137702: EMPTY
137703: ST_TO_ADDR
// exit ;
137704: GO 138066
// end ; for i in solds do
137706: LD_ADDR_VAR 0 7
137710: PUSH
137711: LD_VAR 0 2
137715: PUSH
137716: FOR_IN
137717: IFFALSE 138038
// begin if IsInUnit ( i ) then
137719: LD_VAR 0 7
137723: PPUSH
137724: CALL_OW 310
137728: IFFALSE 137739
// ComExitBuilding ( i ) ;
137730: LD_VAR 0 7
137734: PPUSH
137735: CALL_OW 122
// if GetLives ( i ) > 500 then
137739: LD_VAR 0 7
137743: PPUSH
137744: CALL_OW 256
137748: PUSH
137749: LD_INT 500
137751: GREATER
137752: IFFALSE 137805
// begin e := NearestUnitToUnit ( enemy , i ) ;
137754: LD_ADDR_VAR 0 5
137758: PUSH
137759: LD_VAR 0 4
137763: PPUSH
137764: LD_VAR 0 7
137768: PPUSH
137769: CALL_OW 74
137773: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
137774: LD_VAR 0 7
137778: PPUSH
137779: LD_VAR 0 5
137783: PPUSH
137784: CALL_OW 250
137788: PPUSH
137789: LD_VAR 0 5
137793: PPUSH
137794: CALL_OW 251
137798: PPUSH
137799: CALL_OW 114
// end else
137803: GO 138036
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
137805: LD_VAR 0 7
137809: PPUSH
137810: LD_EXP 101
137814: PUSH
137815: LD_VAR 0 1
137819: ARRAY
137820: PPUSH
137821: LD_INT 2
137823: PUSH
137824: LD_INT 30
137826: PUSH
137827: LD_INT 0
137829: PUSH
137830: EMPTY
137831: LIST
137832: LIST
137833: PUSH
137834: LD_INT 30
137836: PUSH
137837: LD_INT 1
137839: PUSH
137840: EMPTY
137841: LIST
137842: LIST
137843: PUSH
137844: LD_INT 30
137846: PUSH
137847: LD_INT 6
137849: PUSH
137850: EMPTY
137851: LIST
137852: LIST
137853: PUSH
137854: EMPTY
137855: LIST
137856: LIST
137857: LIST
137858: LIST
137859: PPUSH
137860: CALL_OW 72
137864: PPUSH
137865: LD_VAR 0 7
137869: PPUSH
137870: CALL_OW 74
137874: PPUSH
137875: CALL_OW 296
137879: PUSH
137880: LD_INT 10
137882: GREATER
137883: IFFALSE 138036
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
137885: LD_ADDR_VAR 0 8
137889: PUSH
137890: LD_EXP 101
137894: PUSH
137895: LD_VAR 0 1
137899: ARRAY
137900: PPUSH
137901: LD_INT 2
137903: PUSH
137904: LD_INT 30
137906: PUSH
137907: LD_INT 0
137909: PUSH
137910: EMPTY
137911: LIST
137912: LIST
137913: PUSH
137914: LD_INT 30
137916: PUSH
137917: LD_INT 1
137919: PUSH
137920: EMPTY
137921: LIST
137922: LIST
137923: PUSH
137924: LD_INT 30
137926: PUSH
137927: LD_INT 6
137929: PUSH
137930: EMPTY
137931: LIST
137932: LIST
137933: PUSH
137934: EMPTY
137935: LIST
137936: LIST
137937: LIST
137938: LIST
137939: PPUSH
137940: CALL_OW 72
137944: PPUSH
137945: LD_VAR 0 7
137949: PPUSH
137950: CALL_OW 74
137954: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
137955: LD_VAR 0 7
137959: PPUSH
137960: LD_VAR 0 8
137964: PPUSH
137965: CALL_OW 250
137969: PPUSH
137970: LD_INT 3
137972: PPUSH
137973: LD_INT 5
137975: PPUSH
137976: CALL_OW 272
137980: PPUSH
137981: LD_VAR 0 8
137985: PPUSH
137986: CALL_OW 251
137990: PPUSH
137991: LD_INT 3
137993: PPUSH
137994: LD_INT 5
137996: PPUSH
137997: CALL_OW 273
138001: PPUSH
138002: CALL_OW 111
// SetTag ( i , 0 ) ;
138006: LD_VAR 0 7
138010: PPUSH
138011: LD_INT 0
138013: PPUSH
138014: CALL_OW 109
// solds := solds diff i ;
138018: LD_ADDR_VAR 0 2
138022: PUSH
138023: LD_VAR 0 2
138027: PUSH
138028: LD_VAR 0 7
138032: DIFF
138033: ST_TO_ADDR
// continue ;
138034: GO 137716
// end ; end ;
138036: GO 137716
138038: POP
138039: POP
// until not solds or not enemy ;
138040: LD_VAR 0 2
138044: NOT
138045: PUSH
138046: LD_VAR 0 4
138050: NOT
138051: OR
138052: IFFALSE 137620
// MC_Reset ( base , 18 ) ;
138054: LD_VAR 0 1
138058: PPUSH
138059: LD_INT 18
138061: PPUSH
138062: CALL 42905 0 2
// end ;
138066: LD_VAR 0 3
138070: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
138071: LD_INT 0
138073: PPUSH
138074: PPUSH
138075: PPUSH
138076: PPUSH
138077: PPUSH
138078: PPUSH
138079: PPUSH
138080: PPUSH
138081: PPUSH
138082: PPUSH
138083: PPUSH
138084: PPUSH
138085: PPUSH
138086: PPUSH
138087: PPUSH
138088: PPUSH
138089: PPUSH
138090: PPUSH
138091: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
138092: LD_ADDR_VAR 0 12
138096: PUSH
138097: LD_EXP 101
138101: PUSH
138102: LD_VAR 0 1
138106: ARRAY
138107: PPUSH
138108: LD_INT 25
138110: PUSH
138111: LD_INT 3
138113: PUSH
138114: EMPTY
138115: LIST
138116: LIST
138117: PPUSH
138118: CALL_OW 72
138122: ST_TO_ADDR
// if mc_remote_driver [ base ] then
138123: LD_EXP 141
138127: PUSH
138128: LD_VAR 0 1
138132: ARRAY
138133: IFFALSE 138157
// mechs := mechs diff mc_remote_driver [ base ] ;
138135: LD_ADDR_VAR 0 12
138139: PUSH
138140: LD_VAR 0 12
138144: PUSH
138145: LD_EXP 141
138149: PUSH
138150: LD_VAR 0 1
138154: ARRAY
138155: DIFF
138156: ST_TO_ADDR
// for i in mechs do
138157: LD_ADDR_VAR 0 4
138161: PUSH
138162: LD_VAR 0 12
138166: PUSH
138167: FOR_IN
138168: IFFALSE 138203
// if GetTag ( i ) > 0 then
138170: LD_VAR 0 4
138174: PPUSH
138175: CALL_OW 110
138179: PUSH
138180: LD_INT 0
138182: GREATER
138183: IFFALSE 138201
// mechs := mechs diff i ;
138185: LD_ADDR_VAR 0 12
138189: PUSH
138190: LD_VAR 0 12
138194: PUSH
138195: LD_VAR 0 4
138199: DIFF
138200: ST_TO_ADDR
138201: GO 138167
138203: POP
138204: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
138205: LD_ADDR_VAR 0 8
138209: PUSH
138210: LD_EXP 101
138214: PUSH
138215: LD_VAR 0 1
138219: ARRAY
138220: PPUSH
138221: LD_INT 2
138223: PUSH
138224: LD_INT 25
138226: PUSH
138227: LD_INT 1
138229: PUSH
138230: EMPTY
138231: LIST
138232: LIST
138233: PUSH
138234: LD_INT 25
138236: PUSH
138237: LD_INT 5
138239: PUSH
138240: EMPTY
138241: LIST
138242: LIST
138243: PUSH
138244: LD_INT 25
138246: PUSH
138247: LD_INT 8
138249: PUSH
138250: EMPTY
138251: LIST
138252: LIST
138253: PUSH
138254: LD_INT 25
138256: PUSH
138257: LD_INT 9
138259: PUSH
138260: EMPTY
138261: LIST
138262: LIST
138263: PUSH
138264: EMPTY
138265: LIST
138266: LIST
138267: LIST
138268: LIST
138269: LIST
138270: PPUSH
138271: CALL_OW 72
138275: ST_TO_ADDR
// if not defenders and not solds then
138276: LD_VAR 0 2
138280: NOT
138281: PUSH
138282: LD_VAR 0 8
138286: NOT
138287: AND
138288: IFFALSE 138292
// exit ;
138290: GO 140062
// depot_under_attack := false ;
138292: LD_ADDR_VAR 0 16
138296: PUSH
138297: LD_INT 0
138299: ST_TO_ADDR
// sold_defenders := [ ] ;
138300: LD_ADDR_VAR 0 17
138304: PUSH
138305: EMPTY
138306: ST_TO_ADDR
// if mechs then
138307: LD_VAR 0 12
138311: IFFALSE 138464
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
138313: LD_ADDR_VAR 0 4
138317: PUSH
138318: LD_VAR 0 2
138322: PPUSH
138323: LD_INT 21
138325: PUSH
138326: LD_INT 2
138328: PUSH
138329: EMPTY
138330: LIST
138331: LIST
138332: PPUSH
138333: CALL_OW 72
138337: PUSH
138338: FOR_IN
138339: IFFALSE 138462
// begin if GetTag ( i ) <> 20 then
138341: LD_VAR 0 4
138345: PPUSH
138346: CALL_OW 110
138350: PUSH
138351: LD_INT 20
138353: NONEQUAL
138354: IFFALSE 138368
// SetTag ( i , 20 ) ;
138356: LD_VAR 0 4
138360: PPUSH
138361: LD_INT 20
138363: PPUSH
138364: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
138368: LD_VAR 0 4
138372: PPUSH
138373: CALL_OW 263
138377: PUSH
138378: LD_INT 1
138380: EQUAL
138381: PUSH
138382: LD_VAR 0 4
138386: PPUSH
138387: CALL_OW 311
138391: NOT
138392: AND
138393: IFFALSE 138460
// begin un := mechs [ 1 ] ;
138395: LD_ADDR_VAR 0 10
138399: PUSH
138400: LD_VAR 0 12
138404: PUSH
138405: LD_INT 1
138407: ARRAY
138408: ST_TO_ADDR
// ComExit ( un ) ;
138409: LD_VAR 0 10
138413: PPUSH
138414: CALL 107533 0 1
// AddComEnterUnit ( un , i ) ;
138418: LD_VAR 0 10
138422: PPUSH
138423: LD_VAR 0 4
138427: PPUSH
138428: CALL_OW 180
// SetTag ( un , 19 ) ;
138432: LD_VAR 0 10
138436: PPUSH
138437: LD_INT 19
138439: PPUSH
138440: CALL_OW 109
// mechs := mechs diff un ;
138444: LD_ADDR_VAR 0 12
138448: PUSH
138449: LD_VAR 0 12
138453: PUSH
138454: LD_VAR 0 10
138458: DIFF
138459: ST_TO_ADDR
// end ; end ;
138460: GO 138338
138462: POP
138463: POP
// if solds then
138464: LD_VAR 0 8
138468: IFFALSE 138527
// for i in solds do
138470: LD_ADDR_VAR 0 4
138474: PUSH
138475: LD_VAR 0 8
138479: PUSH
138480: FOR_IN
138481: IFFALSE 138525
// if not GetTag ( i ) then
138483: LD_VAR 0 4
138487: PPUSH
138488: CALL_OW 110
138492: NOT
138493: IFFALSE 138523
// begin defenders := defenders union i ;
138495: LD_ADDR_VAR 0 2
138499: PUSH
138500: LD_VAR 0 2
138504: PUSH
138505: LD_VAR 0 4
138509: UNION
138510: ST_TO_ADDR
// SetTag ( i , 18 ) ;
138511: LD_VAR 0 4
138515: PPUSH
138516: LD_INT 18
138518: PPUSH
138519: CALL_OW 109
// end ;
138523: GO 138480
138525: POP
138526: POP
// repeat wait ( 0 0$2 ) ;
138527: LD_INT 70
138529: PPUSH
138530: CALL_OW 67
// enemy := mc_scan [ base ] ;
138534: LD_ADDR_VAR 0 21
138538: PUSH
138539: LD_EXP 124
138543: PUSH
138544: LD_VAR 0 1
138548: ARRAY
138549: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
138550: LD_EXP 101
138554: PUSH
138555: LD_VAR 0 1
138559: ARRAY
138560: NOT
138561: PUSH
138562: LD_EXP 101
138566: PUSH
138567: LD_VAR 0 1
138571: ARRAY
138572: PUSH
138573: EMPTY
138574: EQUAL
138575: OR
138576: IFFALSE 138613
// begin for i in defenders do
138578: LD_ADDR_VAR 0 4
138582: PUSH
138583: LD_VAR 0 2
138587: PUSH
138588: FOR_IN
138589: IFFALSE 138602
// ComStop ( i ) ;
138591: LD_VAR 0 4
138595: PPUSH
138596: CALL_OW 141
138600: GO 138588
138602: POP
138603: POP
// defenders := [ ] ;
138604: LD_ADDR_VAR 0 2
138608: PUSH
138609: EMPTY
138610: ST_TO_ADDR
// exit ;
138611: GO 140062
// end ; for i in defenders do
138613: LD_ADDR_VAR 0 4
138617: PUSH
138618: LD_VAR 0 2
138622: PUSH
138623: FOR_IN
138624: IFFALSE 139522
// begin e := NearestUnitToUnit ( enemy , i ) ;
138626: LD_ADDR_VAR 0 13
138630: PUSH
138631: LD_VAR 0 21
138635: PPUSH
138636: LD_VAR 0 4
138640: PPUSH
138641: CALL_OW 74
138645: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
138646: LD_ADDR_VAR 0 7
138650: PUSH
138651: LD_EXP 101
138655: PUSH
138656: LD_VAR 0 1
138660: ARRAY
138661: PPUSH
138662: LD_INT 2
138664: PUSH
138665: LD_INT 30
138667: PUSH
138668: LD_INT 0
138670: PUSH
138671: EMPTY
138672: LIST
138673: LIST
138674: PUSH
138675: LD_INT 30
138677: PUSH
138678: LD_INT 1
138680: PUSH
138681: EMPTY
138682: LIST
138683: LIST
138684: PUSH
138685: EMPTY
138686: LIST
138687: LIST
138688: LIST
138689: PPUSH
138690: CALL_OW 72
138694: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
138695: LD_ADDR_VAR 0 16
138699: PUSH
138700: LD_VAR 0 7
138704: NOT
138705: PUSH
138706: LD_VAR 0 7
138710: PPUSH
138711: LD_INT 3
138713: PUSH
138714: LD_INT 24
138716: PUSH
138717: LD_INT 600
138719: PUSH
138720: EMPTY
138721: LIST
138722: LIST
138723: PUSH
138724: EMPTY
138725: LIST
138726: LIST
138727: PPUSH
138728: CALL_OW 72
138732: OR
138733: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
138734: LD_VAR 0 4
138738: PPUSH
138739: CALL_OW 247
138743: PUSH
138744: LD_INT 2
138746: DOUBLE
138747: EQUAL
138748: IFTRUE 138752
138750: GO 139148
138752: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
138753: LD_VAR 0 4
138757: PPUSH
138758: CALL_OW 256
138762: PUSH
138763: LD_INT 1000
138765: EQUAL
138766: PUSH
138767: LD_VAR 0 4
138771: PPUSH
138772: LD_VAR 0 13
138776: PPUSH
138777: CALL_OW 296
138781: PUSH
138782: LD_INT 40
138784: LESS
138785: PUSH
138786: LD_VAR 0 13
138790: PPUSH
138791: LD_EXP 126
138795: PUSH
138796: LD_VAR 0 1
138800: ARRAY
138801: PPUSH
138802: CALL_OW 308
138806: OR
138807: AND
138808: IFFALSE 138930
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
138810: LD_VAR 0 4
138814: PPUSH
138815: CALL_OW 262
138819: PUSH
138820: LD_INT 1
138822: EQUAL
138823: PUSH
138824: LD_VAR 0 4
138828: PPUSH
138829: CALL_OW 261
138833: PUSH
138834: LD_INT 30
138836: LESS
138837: AND
138838: PUSH
138839: LD_VAR 0 7
138843: AND
138844: IFFALSE 138914
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
138846: LD_VAR 0 4
138850: PPUSH
138851: LD_VAR 0 7
138855: PPUSH
138856: LD_VAR 0 4
138860: PPUSH
138861: CALL_OW 74
138865: PPUSH
138866: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
138870: LD_VAR 0 4
138874: PPUSH
138875: LD_VAR 0 7
138879: PPUSH
138880: LD_VAR 0 4
138884: PPUSH
138885: CALL_OW 74
138889: PPUSH
138890: CALL_OW 296
138894: PUSH
138895: LD_INT 6
138897: LESS
138898: IFFALSE 138912
// SetFuel ( i , 100 ) ;
138900: LD_VAR 0 4
138904: PPUSH
138905: LD_INT 100
138907: PPUSH
138908: CALL_OW 240
// end else
138912: GO 138928
// ComAttackUnit ( i , e ) ;
138914: LD_VAR 0 4
138918: PPUSH
138919: LD_VAR 0 13
138923: PPUSH
138924: CALL_OW 115
// end else
138928: GO 139031
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
138930: LD_VAR 0 13
138934: PPUSH
138935: LD_EXP 126
138939: PUSH
138940: LD_VAR 0 1
138944: ARRAY
138945: PPUSH
138946: CALL_OW 308
138950: NOT
138951: PUSH
138952: LD_VAR 0 4
138956: PPUSH
138957: LD_VAR 0 13
138961: PPUSH
138962: CALL_OW 296
138966: PUSH
138967: LD_INT 40
138969: GREATEREQUAL
138970: AND
138971: PUSH
138972: LD_VAR 0 4
138976: PPUSH
138977: CALL_OW 256
138981: PUSH
138982: LD_INT 650
138984: LESSEQUAL
138985: OR
138986: PUSH
138987: LD_VAR 0 4
138991: PPUSH
138992: LD_EXP 125
138996: PUSH
138997: LD_VAR 0 1
139001: ARRAY
139002: PPUSH
139003: CALL_OW 308
139007: NOT
139008: AND
139009: IFFALSE 139031
// ComMoveToArea ( i , mc_parking [ base ] ) ;
139011: LD_VAR 0 4
139015: PPUSH
139016: LD_EXP 125
139020: PUSH
139021: LD_VAR 0 1
139025: ARRAY
139026: PPUSH
139027: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
139031: LD_VAR 0 4
139035: PPUSH
139036: CALL_OW 256
139040: PUSH
139041: LD_INT 1000
139043: LESS
139044: PUSH
139045: LD_VAR 0 4
139049: PPUSH
139050: CALL_OW 263
139054: PUSH
139055: LD_INT 1
139057: EQUAL
139058: AND
139059: PUSH
139060: LD_VAR 0 4
139064: PPUSH
139065: CALL_OW 311
139069: AND
139070: PUSH
139071: LD_VAR 0 4
139075: PPUSH
139076: LD_EXP 125
139080: PUSH
139081: LD_VAR 0 1
139085: ARRAY
139086: PPUSH
139087: CALL_OW 308
139091: AND
139092: IFFALSE 139146
// begin mech := IsDrivenBy ( i ) ;
139094: LD_ADDR_VAR 0 9
139098: PUSH
139099: LD_VAR 0 4
139103: PPUSH
139104: CALL_OW 311
139108: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
139109: LD_VAR 0 9
139113: PPUSH
139114: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
139118: LD_VAR 0 9
139122: PPUSH
139123: LD_VAR 0 4
139127: PPUSH
139128: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
139132: LD_VAR 0 9
139136: PPUSH
139137: LD_VAR 0 4
139141: PPUSH
139142: CALL_OW 180
// end ; end ; unit_human :
139146: GO 139493
139148: LD_INT 1
139150: DOUBLE
139151: EQUAL
139152: IFTRUE 139156
139154: GO 139492
139156: POP
// begin b := IsInUnit ( i ) ;
139157: LD_ADDR_VAR 0 18
139161: PUSH
139162: LD_VAR 0 4
139166: PPUSH
139167: CALL_OW 310
139171: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
139172: LD_ADDR_VAR 0 19
139176: PUSH
139177: LD_VAR 0 18
139181: NOT
139182: PUSH
139183: LD_VAR 0 18
139187: PPUSH
139188: CALL_OW 266
139192: PUSH
139193: LD_INT 32
139195: PUSH
139196: LD_INT 31
139198: PUSH
139199: EMPTY
139200: LIST
139201: LIST
139202: IN
139203: OR
139204: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
139205: LD_VAR 0 18
139209: PPUSH
139210: CALL_OW 266
139214: PUSH
139215: LD_INT 5
139217: EQUAL
139218: PUSH
139219: LD_VAR 0 4
139223: PPUSH
139224: CALL_OW 257
139228: PUSH
139229: LD_INT 1
139231: PUSH
139232: LD_INT 2
139234: PUSH
139235: LD_INT 3
139237: PUSH
139238: LD_INT 4
139240: PUSH
139241: EMPTY
139242: LIST
139243: LIST
139244: LIST
139245: LIST
139246: IN
139247: AND
139248: IFFALSE 139285
// begin class := AllowSpecClass ( i ) ;
139250: LD_ADDR_VAR 0 20
139254: PUSH
139255: LD_VAR 0 4
139259: PPUSH
139260: CALL 71230 0 1
139264: ST_TO_ADDR
// if class then
139265: LD_VAR 0 20
139269: IFFALSE 139285
// ComChangeProfession ( i , class ) ;
139271: LD_VAR 0 4
139275: PPUSH
139276: LD_VAR 0 20
139280: PPUSH
139281: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
139285: LD_VAR 0 16
139289: PUSH
139290: LD_VAR 0 2
139294: PPUSH
139295: LD_INT 21
139297: PUSH
139298: LD_INT 2
139300: PUSH
139301: EMPTY
139302: LIST
139303: LIST
139304: PPUSH
139305: CALL_OW 72
139309: PUSH
139310: LD_INT 1
139312: LESSEQUAL
139313: OR
139314: PUSH
139315: LD_VAR 0 19
139319: AND
139320: PUSH
139321: LD_VAR 0 4
139325: PUSH
139326: LD_VAR 0 17
139330: IN
139331: NOT
139332: AND
139333: IFFALSE 139426
// begin if b then
139335: LD_VAR 0 18
139339: IFFALSE 139388
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
139341: LD_VAR 0 18
139345: PPUSH
139346: LD_VAR 0 21
139350: PPUSH
139351: LD_VAR 0 18
139355: PPUSH
139356: CALL_OW 74
139360: PPUSH
139361: CALL_OW 296
139365: PUSH
139366: LD_INT 10
139368: LESS
139369: PUSH
139370: LD_VAR 0 18
139374: PPUSH
139375: CALL_OW 461
139379: PUSH
139380: LD_INT 7
139382: NONEQUAL
139383: AND
139384: IFFALSE 139388
// continue ;
139386: GO 138623
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
139388: LD_ADDR_VAR 0 17
139392: PUSH
139393: LD_VAR 0 17
139397: PPUSH
139398: LD_VAR 0 17
139402: PUSH
139403: LD_INT 1
139405: PLUS
139406: PPUSH
139407: LD_VAR 0 4
139411: PPUSH
139412: CALL_OW 1
139416: ST_TO_ADDR
// ComExitBuilding ( i ) ;
139417: LD_VAR 0 4
139421: PPUSH
139422: CALL_OW 122
// end ; if sold_defenders then
139426: LD_VAR 0 17
139430: IFFALSE 139490
// if i in sold_defenders then
139432: LD_VAR 0 4
139436: PUSH
139437: LD_VAR 0 17
139441: IN
139442: IFFALSE 139490
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
139444: LD_VAR 0 4
139448: PPUSH
139449: CALL_OW 314
139453: NOT
139454: PUSH
139455: LD_VAR 0 4
139459: PPUSH
139460: LD_VAR 0 13
139464: PPUSH
139465: CALL_OW 296
139469: PUSH
139470: LD_INT 30
139472: LESS
139473: AND
139474: IFFALSE 139490
// ComAttackUnit ( i , e ) ;
139476: LD_VAR 0 4
139480: PPUSH
139481: LD_VAR 0 13
139485: PPUSH
139486: CALL_OW 115
// end ; end ; end ;
139490: GO 139493
139492: POP
// if IsDead ( i ) then
139493: LD_VAR 0 4
139497: PPUSH
139498: CALL_OW 301
139502: IFFALSE 139520
// defenders := defenders diff i ;
139504: LD_ADDR_VAR 0 2
139508: PUSH
139509: LD_VAR 0 2
139513: PUSH
139514: LD_VAR 0 4
139518: DIFF
139519: ST_TO_ADDR
// end ;
139520: GO 138623
139522: POP
139523: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
139524: LD_VAR 0 21
139528: NOT
139529: PUSH
139530: LD_VAR 0 2
139534: NOT
139535: OR
139536: PUSH
139537: LD_EXP 101
139541: PUSH
139542: LD_VAR 0 1
139546: ARRAY
139547: NOT
139548: OR
139549: IFFALSE 138527
// MC_Reset ( base , 18 ) ;
139551: LD_VAR 0 1
139555: PPUSH
139556: LD_INT 18
139558: PPUSH
139559: CALL 42905 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
139563: LD_ADDR_VAR 0 2
139567: PUSH
139568: LD_VAR 0 2
139572: PUSH
139573: LD_VAR 0 2
139577: PPUSH
139578: LD_INT 2
139580: PUSH
139581: LD_INT 25
139583: PUSH
139584: LD_INT 1
139586: PUSH
139587: EMPTY
139588: LIST
139589: LIST
139590: PUSH
139591: LD_INT 25
139593: PUSH
139594: LD_INT 5
139596: PUSH
139597: EMPTY
139598: LIST
139599: LIST
139600: PUSH
139601: LD_INT 25
139603: PUSH
139604: LD_INT 8
139606: PUSH
139607: EMPTY
139608: LIST
139609: LIST
139610: PUSH
139611: LD_INT 25
139613: PUSH
139614: LD_INT 9
139616: PUSH
139617: EMPTY
139618: LIST
139619: LIST
139620: PUSH
139621: EMPTY
139622: LIST
139623: LIST
139624: LIST
139625: LIST
139626: LIST
139627: PPUSH
139628: CALL_OW 72
139632: DIFF
139633: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
139634: LD_VAR 0 21
139638: NOT
139639: PUSH
139640: LD_VAR 0 2
139644: PPUSH
139645: LD_INT 21
139647: PUSH
139648: LD_INT 2
139650: PUSH
139651: EMPTY
139652: LIST
139653: LIST
139654: PPUSH
139655: CALL_OW 72
139659: AND
139660: IFFALSE 139998
// begin tmp := FilterByTag ( defenders , 19 ) ;
139662: LD_ADDR_VAR 0 11
139666: PUSH
139667: LD_VAR 0 2
139671: PPUSH
139672: LD_INT 19
139674: PPUSH
139675: CALL 104704 0 2
139679: ST_TO_ADDR
// if tmp then
139680: LD_VAR 0 11
139684: IFFALSE 139754
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
139686: LD_ADDR_VAR 0 11
139690: PUSH
139691: LD_VAR 0 11
139695: PPUSH
139696: LD_INT 25
139698: PUSH
139699: LD_INT 3
139701: PUSH
139702: EMPTY
139703: LIST
139704: LIST
139705: PPUSH
139706: CALL_OW 72
139710: ST_TO_ADDR
// if tmp then
139711: LD_VAR 0 11
139715: IFFALSE 139754
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
139717: LD_ADDR_EXP 113
139721: PUSH
139722: LD_EXP 113
139726: PPUSH
139727: LD_VAR 0 1
139731: PPUSH
139732: LD_EXP 113
139736: PUSH
139737: LD_VAR 0 1
139741: ARRAY
139742: PUSH
139743: LD_VAR 0 11
139747: UNION
139748: PPUSH
139749: CALL_OW 1
139753: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
139754: LD_VAR 0 1
139758: PPUSH
139759: LD_INT 19
139761: PPUSH
139762: CALL 42905 0 2
// repeat wait ( 0 0$1 ) ;
139766: LD_INT 35
139768: PPUSH
139769: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
139773: LD_EXP 101
139777: PUSH
139778: LD_VAR 0 1
139782: ARRAY
139783: NOT
139784: PUSH
139785: LD_EXP 101
139789: PUSH
139790: LD_VAR 0 1
139794: ARRAY
139795: PUSH
139796: EMPTY
139797: EQUAL
139798: OR
139799: IFFALSE 139836
// begin for i in defenders do
139801: LD_ADDR_VAR 0 4
139805: PUSH
139806: LD_VAR 0 2
139810: PUSH
139811: FOR_IN
139812: IFFALSE 139825
// ComStop ( i ) ;
139814: LD_VAR 0 4
139818: PPUSH
139819: CALL_OW 141
139823: GO 139811
139825: POP
139826: POP
// defenders := [ ] ;
139827: LD_ADDR_VAR 0 2
139831: PUSH
139832: EMPTY
139833: ST_TO_ADDR
// exit ;
139834: GO 140062
// end ; for i in defenders do
139836: LD_ADDR_VAR 0 4
139840: PUSH
139841: LD_VAR 0 2
139845: PUSH
139846: FOR_IN
139847: IFFALSE 139936
// begin if not IsInArea ( i , mc_parking [ base ] ) then
139849: LD_VAR 0 4
139853: PPUSH
139854: LD_EXP 125
139858: PUSH
139859: LD_VAR 0 1
139863: ARRAY
139864: PPUSH
139865: CALL_OW 308
139869: NOT
139870: IFFALSE 139894
// ComMoveToArea ( i , mc_parking [ base ] ) else
139872: LD_VAR 0 4
139876: PPUSH
139877: LD_EXP 125
139881: PUSH
139882: LD_VAR 0 1
139886: ARRAY
139887: PPUSH
139888: CALL_OW 113
139892: GO 139934
// if GetControl ( i ) = control_manual then
139894: LD_VAR 0 4
139898: PPUSH
139899: CALL_OW 263
139903: PUSH
139904: LD_INT 1
139906: EQUAL
139907: IFFALSE 139934
// if IsDrivenBy ( i ) then
139909: LD_VAR 0 4
139913: PPUSH
139914: CALL_OW 311
139918: IFFALSE 139934
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
139920: LD_VAR 0 4
139924: PPUSH
139925: CALL_OW 311
139929: PPUSH
139930: CALL_OW 121
// end ;
139934: GO 139846
139936: POP
139937: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
139938: LD_VAR 0 2
139942: PPUSH
139943: LD_INT 95
139945: PUSH
139946: LD_EXP 125
139950: PUSH
139951: LD_VAR 0 1
139955: ARRAY
139956: PUSH
139957: EMPTY
139958: LIST
139959: LIST
139960: PPUSH
139961: CALL_OW 72
139965: PUSH
139966: LD_VAR 0 2
139970: EQUAL
139971: PUSH
139972: LD_EXP 124
139976: PUSH
139977: LD_VAR 0 1
139981: ARRAY
139982: OR
139983: PUSH
139984: LD_EXP 101
139988: PUSH
139989: LD_VAR 0 1
139993: ARRAY
139994: NOT
139995: OR
139996: IFFALSE 139766
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
139998: LD_ADDR_EXP 123
140002: PUSH
140003: LD_EXP 123
140007: PPUSH
140008: LD_VAR 0 1
140012: PPUSH
140013: LD_VAR 0 2
140017: PPUSH
140018: LD_INT 21
140020: PUSH
140021: LD_INT 2
140023: PUSH
140024: EMPTY
140025: LIST
140026: LIST
140027: PPUSH
140028: CALL_OW 72
140032: PPUSH
140033: CALL_OW 1
140037: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
140038: LD_VAR 0 1
140042: PPUSH
140043: LD_INT 19
140045: PPUSH
140046: CALL 42905 0 2
// MC_Reset ( base , 20 ) ;
140050: LD_VAR 0 1
140054: PPUSH
140055: LD_INT 20
140057: PPUSH
140058: CALL 42905 0 2
// end ; end_of_file
140062: LD_VAR 0 3
140066: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
140067: LD_VAR 0 1
140071: PUSH
140072: LD_INT 200
140074: DOUBLE
140075: GREATEREQUAL
140076: IFFALSE 140084
140078: LD_INT 299
140080: DOUBLE
140081: LESSEQUAL
140082: IFTRUE 140086
140084: GO 140118
140086: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
140087: LD_VAR 0 1
140091: PPUSH
140092: LD_VAR 0 2
140096: PPUSH
140097: LD_VAR 0 3
140101: PPUSH
140102: LD_VAR 0 4
140106: PPUSH
140107: LD_VAR 0 5
140111: PPUSH
140112: CALL 128248 0 5
140116: GO 140195
140118: LD_INT 300
140120: DOUBLE
140121: GREATEREQUAL
140122: IFFALSE 140130
140124: LD_INT 399
140126: DOUBLE
140127: LESSEQUAL
140128: IFTRUE 140132
140130: GO 140194
140132: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
140133: LD_VAR 0 1
140137: PPUSH
140138: LD_VAR 0 2
140142: PPUSH
140143: LD_VAR 0 3
140147: PPUSH
140148: LD_VAR 0 4
140152: PPUSH
140153: LD_VAR 0 5
140157: PPUSH
140158: LD_VAR 0 6
140162: PPUSH
140163: LD_VAR 0 7
140167: PPUSH
140168: LD_VAR 0 8
140172: PPUSH
140173: LD_VAR 0 9
140177: PPUSH
140178: LD_VAR 0 10
140182: PPUSH
140183: LD_VAR 0 11
140187: PPUSH
140188: CALL 124573 0 11
140192: GO 140195
140194: POP
// end ;
140195: PPOPN 11
140197: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
140198: LD_VAR 0 1
140202: PPUSH
140203: LD_VAR 0 2
140207: PPUSH
140208: LD_VAR 0 3
140212: PPUSH
140213: LD_VAR 0 4
140217: PPUSH
140218: LD_VAR 0 5
140222: PPUSH
140223: CALL 127984 0 5
// end ; end_of_file
140227: PPOPN 5
140229: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
140230: LD_VAR 0 1
140234: PPUSH
140235: LD_VAR 0 2
140239: PPUSH
140240: LD_VAR 0 3
140244: PPUSH
140245: LD_VAR 0 4
140249: PPUSH
140250: LD_VAR 0 5
140254: PPUSH
140255: LD_VAR 0 6
140259: PPUSH
140260: CALL 112225 0 6
// end ;
140264: PPOPN 6
140266: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
140267: LD_INT 0
140269: PPUSH
// begin if not units then
140270: LD_VAR 0 1
140274: NOT
140275: IFFALSE 140279
// exit ;
140277: GO 140279
// end ;
140279: PPOPN 7
140281: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
140282: CALL 112129 0 0
// end ;
140286: PPOPN 1
140288: END
